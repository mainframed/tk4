         PRINT NOGEN
         DMSMACRO
         PRINT ON,GEN
MNTR     TITLE 'D M S M N T R  MONITOR ROUTINE OF DMS'
DMSMNTR  CSECT
MNTRTAB  DS    0F
MNTRDSCN DC    AL4(DISCONN-MNTRTAB)     -> OFFSET TO DISCONNECT RTN
MNTRRES  DC    AL4(RESENTRY-MNTRTAB)    -> OFFSET TO RESTART
MNTREXT  DC    AL4(EXTENTRY-MNTRTAB)    -> OFFSET TO EXTERNAL
MNTRSVC  DC    AL4(SVCENTRY-MNTRTAB)    -> OFFSET TO SUP CALL
MNTRPGM  DC    AL4(PGMENTRY-MNTRTAB)    -> OFFSET TO PGM CHECK
MNTRMCH  DC    AL4(MCHENTRY-MNTRTAB)    -> OFFSET TO MCH CHECK
MNTRIOI  DC    AL4(IOIENTRY-MNTRTAB)    -> OFFSET TO I/O INTRPT
MNTRSIO  DC    AL4(SIOENTRY-MNTRTAB)    -> OFFSET TO SIO ENTRY
MNTRDSP  DC    AL4(DSPENTRY-MNTRTAB)    -> OFFSET TO DISPATCHER
MNTRVCPU DC    AL4(CPUENTRY-MNTRTAB)    -> OFFSET TO VARY CPU
MNTRACR  DC    AL4(ACRENTRY-MNTRTAB)    -> OFFSET TO ACR ROUTINE
MNTRRTM  DC    AL4(RTMENTRY-MNTRTAB)    -> OFFSET TO RTM REFRAISH
MNTRSTOP DC    AL4(STPENTRY-MNTRTAB)    -> OFFSET TO STOP CPU
MNTRFILL DC    AL4(FILLENTR-MNTRTAB)    -> OFFSET TO COMPLETE PREFIX
MNTRBLSV DC    AL4(BLSAVERT-MNTRTAB)    -> OFFSET TO BLOCK SAVE ROUTINE
MNTRSAVE DC    AL4(SAVERTN-MNTRTAB)     -> OFFSET TO USER SAVE RTN
MNTRBACK DC    AL4(BACKRTN-MNTRTAB)     -> OFFSET TO LEAVE DMS RTN
MNTRJOB  DC    AL4(JOBNSEL-MNTRTAB)     -> OFFSET TO JOBNAME SUBROUTINE
         CSECTID DMSMNTR
         EJECT
DISCONN  DS    0D
         USING PSA,PSAREG
         STM   R11,R14,PDISSAVE         SAVE CALLERS REGISTER
         BALR  R11,R0                   ASSIGN
         USING *,R11                    BASE
         USING DMSCONST,DMSREG          DMSREG MUST BE VALID ON INPUT
         SERILIZE WORD=CONLOCK
         SR    R12,R12                  CLEAR REGISTER 12
         LA    R13,HOOKTAB              POINT TO START OF TABLE
         LA    R14,11                   PROCESS ELEVEN HOOKS
DCLOOP   CLC   0(12,R13),DUMYHOOK       IS IT A VALID HOOK
         BE    DCNEXT                   NO, DO NOT RESTORE
         ICM   R12,1,0(R13)             GET LENGTH OF HOOK
         BZ    DCNEXT                   GET NEXT IF INVALID
         LNR   R8,R12                   GET LENGTH INTO WORKREG
         ICM   R7,7,1(R13)              GET ADDRESS OF INTRPT
         BZ    DCNEXT                   GO OUT IF NOT VALID
         LA    R7,0(R7)                 CLEAR HIGH ORDER BYTE
         ALR   R7,R8                    SUBTRACT LENGTH OF HOOK
         BCTR  R12,R0                   SUBTRACT ONE FOR EXECUTE
         EX    R12,DCMOVE               MOVE IT BACK
         XC    0(1,R13),0(R13)          CLEAR ENTRY LENGTH
DCNEXT   LA    R13,12(R13)              POINT TO NEXT
         BCT   R14,DCLOOP               DO  ALL
         B     DCPSW                    GO AND DISCONNECT PSW'S
DCMOVE   MVC   0(1,R7),4(R13)           EXECUTED MOVE INSTRUCTION
         SPACE 3
DCPSW    TM    STARTFL1,PSWSAVED        WERE PSW'S SAVED
         BNO   DCNOPSW                  NO, DO NOT RESTORE BAD PSW'S
DCNMASK  STNSM DCORMASK+1,BIT5          ENABLE TRANSLATION
         L     R6,PCCAVTP               GET AVT FOR PCCA'S
         LA    R12,16                   CPU 0 - F
         MVC   FLCRNPSW(8),RESNPSW      RESTORE RESTART NEW PSW
         MVC   FLCENPSW(8),EXTNPSW      MODIFY EXTRNAL NEW PSW
         MVC   FLCSNPSW(8),SVCNPSWD     MODIFY SVC NEW PSW
         MVC   FLCPNPSW(8),PGMNPSW      MODIFY PGM NEW PSW TO OLD
         MVC   FLCMNPSW(8),MCHNPSW      RESTORE MCH NEW PSW
         MVC   FLCINPSW(8),IOINPSW      RESTORE I/O NEW PSW
DCNXTPSW L     R7,0(R6)                 -> PCCA
         LA    R7,0(R7)                 CLEAR HIGH ORDER BYTE
         LTR   R7,R7                    IS THERE A PCCA
         BNZ   DCOKPCA                  YES, CONTINUE
         LA    R6,4(R6)                 POINT TO NEXT
         BCT   R12,DCNXTPSW             CHECK NEXT
         B     DCENDPSW
DCOKPCA  EQU   *
         L     R8,24(R7)                -> OF VIRTUAL PSA
         DROP  PSAREG
         USING PSA,R8
         MVC   FLCRNPSW(8),RESNPSW      RESTORE RESTART NEW PSW
         MVC   FLCENPSW(8),EXTNPSW      RESTORE EXTERNAL NEW PSW
         MVC   FLCSNPSW(8),SVCNPSWD     RESTORE SVC NEW PSW
         MVC   FLCPNPSW(8),PGMNPSW      RESTORE PGM NEW PSW
         MVC   FLCMNPSW(8),MCHNPSW      RESTORE MCH NEW PSW
         MVC   FLCINPSW(8),IOINPSW      RESTORE IOI NEW PSW
         LA    R6,4(R6)                 POINT TO NEXT PCCA
         BCT   R12,DCNXTPSW
         DROP  R8
         USING PSA,PSAREG
DCENDPSW XC    RESNPSW(48),RESNPSW      DELETE PSW'S
         NI    STARTFL1,ALLBIT-PSWSAVED INDICATE VALID SYSTEM PSW'S
DCORMASK STOSM DCNMASK+1,0              ENABLE FOR NORMAL PROCESSING
         L     R12,DMSCPSAL             GET LENGTH OF PSA
         LA    R13,PSLPSW               POINT TO LOW CORE
         LA    R14,DMSCPSA              POINT TO RESERVED SPACE
         SRL   R12,2                    DIVIDE BY FOUR
PCOLOOP  MVC   0(4,R14),0(R13)          MOVE IT TO CONST
         LA    R13,4(R13)               INCREMENT BY FOUR
         LA    R14,4(R14)               INCREMENT BY FOUR
         BCT   R12,PCOLOOP              MOVE ALL
         MVC   DMSCUSR(256),PSUSER      MOVE USER DATA
DCNOPSW  OI    DMSFUNCT,DMSSTOP         FORCE STOP PROCESSING
         L     R12,DMSDISBF             GET MY CURRENT BUFFER AND
         USING BUFFER,R12               SET
         OI    BFRFLG,BFRFULL           IT
         DROP  R12                      FULL
         FREE  WORD=CONLOCK
         LM    R11,R14,PDISSAVE         RESTORE CALLERS REGISTER
         BR    R14                      AND GO TO HIM
         TITLE 'D M S M N T R  MONITOR ROUTINE OF DMS: RESTART'
RESENTRY DS    0D
         STM   R0,R15,PRESSAVE          SAVE CALLERS REGISTER
         BALR  R11,R0                   ASSIGN NEW
         USING *,R11                    BASE
         USING DMSCONST,DMSREG          ADDRESSABILITY
         OI    PSDMSTR1,FOOTRES         MARJ CORRECT ENTRY           RM
         ICM   DMSREG,7,PSACONST+1      GET CONST ADDRESS
         BZ    RSNOPSA                  DANGER, NO VALID CONST POINTER
         CLC   DMSID(8),=C'DMSCONST'    IS IT VALID CONST
         BNE   RSNOPSA                  NO, NOT VALID
         L     R15,DMMNTR+16            ADDRESS OF DMSMNTR           RM
         USING MRTABLE,R15                                           RM
         CLC   DMMNTR+17(3),FLCROPSW+5  LOOP IN DMSMNTR              RM
         BH    RSRCVR1                  NO                           RM
         L     R14,DMMNTR+12            GET LENGTH OF DMSMNTR IN R14 RM
         LA    R15,0(R14,R15)           GET ADDR FROM END OF DMSMNTR RM
         L     R14,FLCROPSW+4           GET INTERRUPT ADDR           RM
         LA    R14,0(R14)               CLEAR                        RM
         CLR   R14,R15                  LOOP IN DMSMNTR              RM
         BH    RSRCVR1                  NO                           RM
         NI    PSDMSTR1,X'7F'           CLEAR FOOTRES                RM
         B     RESDOWN                                               RM
RSRCVR1  MVI   PSDMSTR1,FOOTRES         MARK CORRECT ENTRY           RM
         DROP  R15                                                   RM
RSRCVR   CALLMNTR FOR=DSCN              DISCONNECT DMS
         OI    DMSFUNCT,DMSEOJ          FORCE TERMINATION
         MVC   PREGSAVE(64),PRESSAVE    MOVE REGISTERS TO LOW CORE
         MVC   PSLPSW(8),FLCROPSW       MOVE RESTART OLD PSW
         CALLMNTR FOR=BACK              RETURN TO OS
RSNOPSA  ICM   DMSREG,7,PSCPUBLK+1      IS THERE A CPUBLOCK
         MVI   PSDMSTR1,FOOTRES         MARJ CORRECT ENTRY           RM
         BZ    RESDOWN
         L     DMSREG,0(DMSREG)         TRY TO RECOVER
         STCM  DMSREG,7,PSACONST+1      REFRESH POINTR
         B     RSRCVR                   AND GO BACK
RESDOWN  LM    R0,R15,PRESSAVE          GET CALLERS REGISTER
         LPSW  FLCROPSW                 AND IGNORE INTERRUPT
         LTORG
         TITLE 'D M S M N T R  MONITOR ROUTINE OF DMS: BACK TO OS/VS'
BACKRTN  DS    0D
         BALR  R11,R0                   GET BASE
         USING *,R11                    ASSIGN BASE
         USING DMSCONST,DMSREG          ASSIGN CONST BASE
         TM    DMSFUNCT,DMSSTOP+DMSEOJ  IS DMS TO BE STOPPED
         BZ    NOTDOSTP                 NO, DO NOT STOP
         CALLMNTR FOR=DSCN              YES, DISCONNECT IF NECASSARY
         NI    PSLPSW,ALLBIT-BIT1       SET PER OFF
NOTDOSTP EQU   *
         TM    PSADMSF,BIT1             WAS CONTROL REGISTER CHANGED
         BZ    *+8                      NO, SO DO NOT RELOAD
         LCTL  R1,R1,PSCTRL1            RELOAD CHANGED CONTROL REG.
         TM    STARTFL3,DMSSLOCK        WAS SALLOC LOCK OBTAINED BY DMS
         BZ    BACKCONT                 NO, CONTINUE
         CLC   STARTFL4(1),PSACPULA+1   YES, WAS IT THIS CPU
         BNE   BACKCONT                 NO, CONTINUE
FSALLOC1 SETLOCK RELEASE,TYPE=SALLOC,DISABLED,RELATED=(GSALLOC)
         NI    STARTFL3,ALLBIT-DMSSLOCK INDICATE LOCK RELEASED
         MVI   STARTFL4,0               CLEAR OWNERS CPUID
BACKCONT DS    0H
         CLI   DMPER+6,BLANK            IS PER SELECTED
         BE    BACKNPER                 NO, CONTINUE
         TESTCPU NOTON=BACKNPER         SI CPU SELECTED
         SR    R4,R4                    CLEAR REGISTER
         ICM   R4,7,PERASCB+1           IS PER ASID SELECTED
         BZ    BACKNCOM                 DO NOT COMPARE
         CL    R4,PSAAOLD               YES, IS IT THIS ASCB
         BNE   BACKNPER                 NO, SKIP
BACKNCOM SR    R3,R3                    CLEAR REGISTER
         LA    R15,100                  SET R15 TO NONZERO
         CALLMNTR FOR=JOB,RG=R12
         LTR   R15,R15                  IS JOBNAME SELECTED
         BZ    BACKNPER                 NO, SKIP
         TM    DMSFUNCT,DMSSTOP+DMSEOJ  IS STOP IN PROGRESS
         BNZ   BACKNPER                 YES, SKIP
         SR    R6,R6                    CLEAR REGISTER
         IC    R6,PSDMSTR1              GET ENTRY CODE
         LA    R7,PERMODEF              GET FUNCTION CODE
         EX    R6,DMSTSTMK              TEST BIT FOR SELECTION
         BZ    BACKNPER                 SKIP IF NOT SELECTED
         OI    PSLPSW,BIT1              SET PER BIT ON
         LCTL  R9,R11,PEREMASK          LOAD CONTROL REGISTERS
BACKNPER DS    0H
         LM    R0,R15,PREGSAVE          LOAD THE CALLERS REGS
         XC    PSDMSTR1(3),PSDMSTR1     CLEAR FOOTPRINTS
         NI    PSADMSF,ALLBIT-BIT0-BIT1 INDICATE OS/VS IN CONTROL
         LPSW  PSLPSW
         TITLE 'D M S M N T R  MONITOR ROUTINE OF DMS: E X T  ENTRY'
EXTENTRY DS    0D
         STCK  PSCLOCK                  SAVE TIME
         STM   R0,R15,PSHRSAVE          SAVE ALL REGISTERS
         NI    FLCEOPSW,ALLBIT-BIT1     SET PER OFF
         MVI   PSDMSTR1,FOOTEXT         MARK CORRECT ENTRY
         BALR  R11,R0                   ASSIGN BASE
         USING *,R11                    REGISTER
         TM    PSADMSF,BIT0             RECURSIVE ENTRANCE
         BO    EXTRECVE                 YES, HANDLE RECURSIVE ENTRY
         OI    PSADMSF,BIT0             PREVENT SYSTEM LOOP ON NEXT
         MVC   PREGSAVE(64),PSHRSAVE    MOVE USERS REGISTER
         ICM   DMSREG,7,PSACONST+1      -> TO DMSCONST
         BZ    EXTIGNRE                 NO CONST AVAILABLE
         USING DMSCONST,DMSREG          ADDRESSABILITY
EXTRCVR  MVC   PSLPSW(8),EXTNPSW        CONTINUATION IN FLIH
         TM    STARTFL2,STARTGO         IS INITIALIZATION COMPLETE
         BNO   EXTRET                   NO, DO NOT SAVE
         CLI   DMEXT+6,BLANK            IS A SPECIAL RTN LOADED
         BNE   EXCHKIT                  YES, CHECK MORE ABOUT
EXTRET   CALLMNTR FOR=BACK              RETURN TO FLIH
EXCHKIT  SR    R6,R6                    CLEAR REGISTER
         ICM   R6,3,EXTINT              GET CODES TO BE SELECTED
         BZ    EXTRET                   RETURN IF NO CODES SELECTED
         N     R6,FLCEICOD-2(R0)        IS THIS ONE SELECTED
         BZ    EXTRET                   NO, IGNORE
         TESTCPU NOTON=EXTRET           IS THIS CPU SELECTED
         ICM   R9,7,PSCPUBLK+1          LOAD -> TO MY CPU BLOCK
         BZ    EXTRET                   GO BACK IF NO BLOCK
         USING CPUBLK,R9
         RECID TYPE=EXT                 SET RECORD IDENTIFIER
         LM    R6,R7,FLCEOPSW           GET EXTERNAL OLD PSW
         STM   R6,R7,BLKPSW             INTO RECORD
         MVC   BLKPSWCD(2),FLCEICOD     GET INTERRUPT CODE INTO PSW
         SR    R3,R3                    INDICATE NO ASCB TO SUBRTN
         CALLMNTR FOR=FILL              FILL IN NORMOL PREFIX
         L     R14,DMMNTR+16            STARTADDRESS OF MNTOR
         USING MRTABLE,R14
         L     R13,MRSAVE               OFFSET OF DATASAVERTN
         LA    R13,0(R14,R13)           ADDRESS OF DATASAVE RTN
         ICM   R15,7,DMEXT+17           GET DATA-SAVE RTN
         BZ    EXTRET                   GO BACK IF THERE IS NONE
         SR    R3,R3                    INDICATE NO ASCB TO SUBRTN
         DROP  R14
         CALLMNTR FOR=JOB,RG=R12        CHECK FOR SELECTION
         USING MRTABLE,R14
         LTR   R15,R15                  IS ROUTINE TO BE ENTERED
         BZ    EXTRET                   NO, RETURN WITHOUT
         STM   R9,R11,PSHRSAV3          SAVE REGISTERS 9 TO 11
         BALR  R14,R15                  GO TO USER RTN
         LM    R9,R11,PSHRSAV3          RELOAD MY REGISTERS
         LTR   R15,R15                  IS RECORD TO BE SAVED
         BNZ   EXTRET                   NO, RETURN
         RECNUM                         GET RECORD SEQUENCE #
         L     R14,DMMNTR+16            GET ENTRY OF MNTR
         L     R11,MRBLKSAV             GET OFFSET TO BLOCK SAVE RTN
         LA    R11,0(R14,R11)           GET ENTRY TO BLOCKSAVE RTN
         BR    R11                      GO TO BLOCK SAVE
EXTIGNRE ICM   DMSREG,7,PSCPUBLK+1      IS THERE A CPUBLOCK
         BZ    EXTRECVE                 NO, WAIT
         L     DMSREG,0(DMSREG)         TRY TO RECOVER
         STCM  DMSREG,7,PSACONST+1      REFRESH POINTR
         B     EXTRCVR                  AND CONTINUE
EXTRECVE MVC   PSHRSAVE(8),EXTWPSW      MOVE  WAIT PSW TO LOW CORE AND
         MVI   EXTWPSW+4,C'1'           INDICATE EXTERNAL
         LPSW  PSHRSAVE                 LOAD  DISASTROUS WAIT
EXTWPSW  DC    X'000200F1'              CATASTROPHIC
         DC    X'00',C'DMS'             WAIT-PSW
         TITLE 'D M S M N T R  MONITOR ROUTINE OF DMS: PREFIX SETUP'
FILLENTR DS    0D
         USING *,R15                    ASSIGN  BASE
         USING DMSCONST,DMSREG          DMSCONST REG MUST BE VALID
         USING CPUBLK,R9                REGISTER 9 POINTS TO BLKPAGE
         MVI   PSDMSTR2,FOOTFILL        MARK CORRECT ENTRY
         LM    R1,R2,PSCLOCK            GET TIME OF THIS EVENT
         STM   R1,R2,BLKCLOCK           INTO RECORD
         LM    R1,R2,PDCLOCK            GET TIME OF LAST DISP. EVENT
         STM   R1,R2,BLKDICLK           INTO RECORD
         STIDP BLKCPUID                 GET CPU-ID INTO RECORD
         LTR   R3,R3                    DID CALLER SPECIFY ASCB
         BZ    FILASCB                  NO, SO LOAD CURRENT
         LR    R1,R3                    POINT TO CALLERS ASCB
         CLI   0(R3),C'A'               IS IT A ASCB
         BNE   FILASCB                  NO, SO USE CURRENT
         B     FILUSCB                  GO AROUND LOADING
FILASCB  L     R1,PSAAOLD(R0)           LOAD CURRENT ASCB
FILUSCB  EQU   *
         LRA   R0,0(R1)                 IS IT VALID ASCB
         BNE   FILLASCB                 NO, USE ASCB AND TCB POINTERS
         ICM   R2,7,X'AD'(R1)           IS THERE A POINTER TO NAME
FILLCHK  BZ    FILLNPT                  NO, GET NEXT POINTER
         LRA   R0,0(R2)                 DO NE HAVE ACCESS TO JOBNAME
         BNE   FILLASCB                 NO, USE ASCB
         MVC   BLKJOBN(8),0(R2)         MOVE JOBNAME INTO RECORD
FILLEND  LA    R1,48(R0,R0)             GET LENGTH OF WHOLE RECORD
         STH   R1,BLKRLEN               GET LENGTH INTO RECORD
         LA    R2,4096-(BLKBUFF-CPUBLK) GET RESIDUAL LENGTH
         SLR   R2,R1                    GET NEW RESIDUAL LENGTH
         ST    R2,BLKRESLN              AND SAVE IT
         XC    BLKRLEN+2(2),BLKRLEN+2   CLEAR UNUSED BYTES
         BR    R14                      RETURN TO CALLER
FILLNPT  ICM   R2,7,X'B1'(R1)           IS THERE A POINTER TO NAME
         BNZ   FILLCHK                  GO AND CHECK
FILLASCB L     R1,PSAAOLD(R0)           GET ASCB ADDRESS
         LA    R1,0(R1)                 CLEAR HIGH ORDER BYTE
         ST    R1,BLKASCB               SAVE ADDRESS INTO RECORD
         L     R1,PSATOLD(R0)           GET TCB ADDRESS
         LA    R1,0(R1)                 CLEAR HIGH ORDER BYTE
         ST    R1,BLKTCB                SAVE IT TO RECORD
         B     FILLEND
         TITLE 'D M S M N T R  MONITOR ROUTINE OF DMS: S V C  ENTRY'
SVCENTRY DS    0D
         STCK  PSCLOCK                  SAVE TIME OF EVENT
         STM   R0,R15,PSHRSAVE          SAVE ALL REGISTERS
         BALR  R11,R0                   ASSIGN BASE
         USING *,R11                    REGISTER
         MVI   PSDMSTR1,FOOTSVC         MARK CORRECT ENTRY
         ICM   DMSREG,7,PSACONST+1      GET ADDRESS OF DMS-CONST
         BNZ   SVCDMSOK                 POINTER TO CONST IS OK
         ICM   DMSREG,7,PSCPUBLK+1      IS THERE A CPUBLOCK
         BZ    SVCWAIT                  NO, CANT RECOVER
         L     DMSREG,0(DMSREG)         TRY TO RECOVER
         STCM  DMSREG,7,PSACONST+1      REFRESH POINTER
         B     SVCDMSOK                 AND CONTINUE
SVCWAIT  MVC   PSHRSAVE(8),SVCWPSW      MOVE  CATASTROPHIC WAIT PSW
         MVI   SVCWPSW+4,C'2'           INDICATE
         LPSW  PSHRSAVE                 AND LOAD IT
SVCWPSW  DC    X'000200F2'              INDICATE
         DC    X'00',C'DMS'             ERROR PSW
SVCDMSOK EQU   *
         USING DMSCONST,DMSREG
         TM    PSADMSF,BIT0             IS THIS A RECURSIVE ENTRY
         BO    SVCRESIV                 YES, GO AND HANDLE RECURSIVE
         OI    PSADMSF,BIT0             SET DMS IN CONTROL
         CLI   DMSID,C'D'               CHECK FOR VALID DMSCONST
         BNE   SVCWAIT                  NOT VALID, DISASTER
         MVC   PREGSAVE(64),PSHRSAVE    REGISTERS TO LOW CORE
         CLI   FLCSVCN+1,HOOKSVC        IS IT A HOOK
         BE    SVCHK                    YES, HANDLE HOOK
         MVC    PSVCSA00(8),FLCSOPSW    SAVE SVC OLD PSW
         MVC   PSVCSA00+8(4),PSAESPSW   AND ILC
SVCISSVC MVC   PSLPSW(8),SVCNPSWD        POINT TO FLIH
         NI    FLCSOPSW,ALLBIT-BIT1     SET PER OFF
         CLI   FLCSVCN+1,13             IS IT ABEND SVC
         BE    SVCABEND                 YES GO OUT
         CLI   FLCSVCN+1,56             IS IT ENQ
         BE    SVCENQ01                 YES, CHECK MORE ABOUT
SVCNOABE TM    STARTFL2,STARTGO         IS INITIALIZATION COMPLETE
         BNO   SVCRET                   NO, DO NOT SAVE
         CLI   DMSVC+6,BLANK            IS A SPECIAL RTN LOADED
         BNE   SVCHKIT                  YES, CHECK MORE ABOUT
SVCRET   CALLMNTR FOR=BACK              RETURN TO FLIH OR HOOK CONTIN
SVCHKIT  TESTCPU NOTON=SVCRET           CHECK IS CPU IS SELECTED
         SR    R6,R6                    CLEAR REGISTER
         IC    R6,FLCSVCN+1(R0)         GET SVC INTRPT CODE
         LR    R5,R6                    SAME VALUE INTO SECOND REG
         SRL   R5,3                     DIVIDE BY EIGHT
         LA    R7,7                     GET AND MASK
         NR    R6,R7                    GET BIT VALUE
         IC    R4,DMSTRTAB(R6)          GET BIT MASK
         LA    R7,SVCINT(R5)            POINT TO TABLE ENTRY
         EX    R4,DMSTSTMK              IS BIT ON
         BZ    SVCRET                   NO, GO OUT
SVCTRACE ICM   R9,7,PSCPUBLK+1          GET MY BLOCK
         BZ    SVCRET                   GO OUT IF NO BLOCK
         USING CPUBLK,R9
         RECID TYPE=SVC
         LM    R6,R7,FLCSOPSW           GET SVC-OLD PSW
         STM   R6,R7,BLKPSW             INTO RECORD
         MVC   BLKPSWCD(2),FLCSVCN      MOVE SVC NUMBER TO RECORD
         SR    R3,R3                    INDICATE NO ASCB TO SUBRTN
         CALLMNTR FOR=FILL              COMPTETE PREFIX
         L     R14,DMMNTR+16            ADDRESS OF MNTRTABLE
         USING MRTABLE,R14
         L     R13,MRSAVE               OFFSET TO MY DATA SAVE RTN
         LA    R13,0(R14,R13)           ADRESS OF DATA-SAVE
         ICM   R15,7,DMSVC+17           GET USER ROUTINE
         BZ    SVCRET                   RETURN IF NONE
         SR    R3,R3                    INDICATE NO ASCB TO SUBRTN
         DROP  R14
         CALLMNTR FOR=JOB,RG=R12
         LTR   R15,R15
         BZ    SVCRET
         STM   R9,R11,PSHRSAV3          SAVE REGISTERS 9 TO 11
         BALR  R14,R15                  GO TO USER-ROUTINE
         LM    R9,R11,PSHRSAV3          RELOAD MY REGISTERS
         LTR   R15,R15                  IS RECORD TO BE SAVED
         BNZ   SVCRET                   NO, DROP FULL RECORD
         RECNUM                         GET RECORD NUMBER
         L     R14,DMMNTR+16            MONITOR ENTRY
         USING MRTABLE,R14
         L     R11,MRBLKSAV             POINT TO BLOCKSAVE OFFSET
         LA    R11,0(R14,R11)           POINT TO BLOCKSAVE ENTRY
         BR    R11                      GO TO IT
         SPACE 3
SVCRESIV MVC   PSLPSW(8),SVCNPSWD       POINT TO FLIH
         MVC   PREGSAVE(64),PSHRSAVE    WITH CALLERS REGS
         CALLMNTR FOR=DSCN              DISCONNECT
         OI    DMSFUNCT,DMSEOJ          FORCE TERMINATION
         OI    DMSREAS1,SVCRECUR        INDICATE REASON WHY
         MVC   DMSPGMCD(4),FLCSVCN-2    MOVE SVC CODE TO CONST
         MVC   DMSPGMW(8),FLCSOPSW      AND SVC OLD PSW
         MVI   RETCODE+2,1              NENZERO RETCODE
         CALLMNTR FOR=BACK              GO BACK WITH A DISCONNECTED DMS
         SPACE 3
SVCABEND CLC   DMSASCBP+1(3),PSAAOLD+1  IS IT MY ASCB
         BNE   SVCNOABE                 NO, NOT MY JOB
         MVC   DMSPGMCD(8),PREGSAVE     SAVE ABEND CODE
         MVC   DMSPGMW(8),FLCSOPSW      AND ABEND PSW
         MVC   PREGSAVE+4(4),=X'80000064'
         MVC   PREGSAVE(4),=X'80000000'
         CALLMNTR FOR=DSCN              DISCONNECT
         OI    DMSFUNCT,DMSEOJ          FORCE EOJ
         OI    DMSREAS1,DMSABEND        INDICATE REASON
         CALLMNTR FOR=BACK              CONTINUE ABEND PROCESSING
         EJECT
SVCENQ01 L     R15,PREGSAVE+4           GET CALLERS REG 1
         LRA   R14,11(R15)              IS IT GOOD PARMLIST
         BNE   SVCNOABE                 NO, SO GO BACK
         L     R6,4(R15)                GET -> OF MAJOR
         LRA   R14,7(R6)                IS IT GOOD ADDRESS
         BNE   SVCNOABE                 NO, GO BACK
         CLC   0(8,R6),=CL8'SYSZVARY'   IS IT VARY
         BNE   SVCNOABE                 NO, GO BACK
         L     R6,8(R15)                 GET MINOR
         LRA   R14,2(R6)                GOOD ADDRESS
         BNE   SVCNOABE                 NO GO BACK
         CLC   0(3,R6),=CL3'CPU'        IS IT CPU
         BNE   SVCNOABE                 NO, GO BACK
         CALLMNTR FOR=VCPU              YES, CALL CPU HOOK
         DC    H'0'                     CAUSE 0C1 IF RETURN IS MADE
SVCHK    EQU   *
         LA    R13,HOOKTAB              POINT TO HOOK TABLE
         LA    R12,11                   PROCESS ELEVEN HOOKS
HOKLOP   CLC   1(3,R13),FLCSOPSW+5      IS IT THIS HOOK
         BE    HOOKFND                  YES, GO OUT
         LA    R13,12(R13)              POINT TO NEXT HOOK
         BCT   R12,HOKLOP               GO AND CHECK NEXT
         B     SVCISSVC                 SOMEBODY USING RAD SVC
HOOKFND  MVC   PSLPSW(8),FLCSOPSW       CONTINUE BEHIND HOOK
         MVC   FLCSOPSW(8),PSVCSA00     RESTORE SVC OLD PSW
         MVC   PSAESPSW(4),PSVCSA00+8   AND ILC
         L     R15,8(R13)               GET ENTRY OF HOOK PROCESSOR
         BR    R15                      AND GO TO IT
         LTORG
         TITLE 'D M S M N T R  MONITOR ROUTINE OF DMS: P G M  ENTRY'
PGMENTRY DS    0D
         STCK  PSCLOCK                  SAVE TIME
         STM   R0,R15,PSHRSAVE          SAVE REGISTERS
         MVI   PSDMSTR1,FOOTPGM         MARK CORRECT ENTRY
         ICM   DMSREG,7,PSACONST+1      POINT TO MY CONST
         BZ    PPGMFLIH(R0)             GO TO PGM FLIH (TRY IT AT LEAST
         LRA   R9,0(DMSREG)             CHECK IF TRANSLATION OK
         BNE   PPGMFLIH(R0)             NOT OK, TRY TO RETURN
         USING DMSCONST,DMSREG
         BALR  R11,R0                   ASSIGN
         USING *,R11                    BASE
         TM    PSADMSF,BIT0             IS IT RECURSIVE ENTRY
         BO    PGMRECUR                 YES, HANDLE IT
         OI    PSADMSF,BIT0             NO,  SET BIT
         MVC   PREGSAVE(64),PSHRSAVE    REGISTERS TO LOW CORE
         MVC   PSLPSW(8),PGMNPSW        MOVE FLIH PSW TO RESTART
         CLI   FLCPICOD+1,BIT0          IS IT PER ONLY INTERRUPT
         BE    PGMPER                   YES, CHECK PER
PGMNOPER TM    FLCPICOD+1,BIT1          IS IT A MONITOR CALL
         BO    PGMMONM0                 YES, GO AND SEE MORE ABOUT
PGMNOMON NI    FLCPOPSW,ALLBIT-BIT1     SET PER OFF
         TM    FLCPICOD+1,BIT3          IS IT A DAT INTERRUPT
         BZ    PGMNODAT                 NO DAT
         TM    FLCPICOD+1,BIT6+BIT7     IS IT A DAT
         BNO   PGMDAT                   YES GO AND CHECK MORE ABOUT
PGMNODAT TM    STARTFL2,STARTGO         IS INITIALIZATION COMPLETE
         BNO   PGMRET                   NO, DO NOT SAVE
         CLI   DMPGM+6,BLANK            IS A SPECIAL RTN LOADED
         BE    PGMRET                   NO RETURN
         SR    R6,R6                    CLEAR REG
         IC    R6,FLCPICOD+1            INSERT PGM CODE
         LA    R7,ALLBIT-192            GET AND MASK
         NR    R6,R7                    SEE IF THERE IS SOMETHING
         BZ    PGMRET                   NO, RETURN
         LR    R5,R6                    SAME VALUE INTO WORKREG
         SRL   R5,3                     DIVIDE BY EIGHT
         LA    R7,7                     GET AND MASK
         NR    R6,R7                    RESULT IS BIT COMPLEMENT
         IC    R6,DMSTRTAB(R6)          GET MASK INTO R6
         LA    R7,PGMINT(R5)            POINT TO BYTE WITHIN TABLE
         EX    R6,DMSTSTMK              TEST IF THIS IS SELECTED
         BZ    PGMRET                   NO, RETURN
PGMTRCE  TESTCPU NOTON=PGMRET
         ICM   R9,7,PSCPUBLK+1          GET MY BLOCK
         BZ    PGMRET                   GO BACK IF NO BLOCK THERE
         USING CPUBLK,R9
         RECID TYPE=PGM                 GET RECORD ID
         LM    R6,R7,FLCPOPSW           GET PGM OLD PSW
         STM   R6,R7,BLKPSW             INTO PREFIX
         MVC   BLKPSWCD(2),FLCPICOD     MOVE PGM CODE INTO PREFIX
         SR    R3,R3                    INDICATE NO ASCB TO SUBRTN
         CALLMNTR FOR=FILL              COMPLETE PREFIX
         L     R14,DMMNTR+16            ADDR. OF MONITOR
         USING MRTABLE,R14
         L     R13,MRSAVE               DATA SAVE RTN OFFSET
         LA    R13,0(R14,R13)           ROUTINE ->
         ICM   R15,7,DMPGM+17           -> USER ROUTINE
         BZ    PGMRET                   RETURN IF NO RTN
         SR    R3,R3                    INDICATE NO ASCB TO SUBRTN
         DROP  R14
         CALLMNTR FOR=JOB,RG=R12        TEST FOR JOB SELECTION
         USING MRTABLE,R14
         LTR   R15,R15                  IS RECORD NEEDED
         BZ    PGMRET                   NO, RETURN
         STM   R9,R11,PSHRSAV3          SAVE REGISTERS 9 TO 11
         BALR  R14,R15                  GO TO USER ROUTINE
         LM    R9,R11,PSHRSAV3          RELOAD MY REGISTERS
         LTR   R15,R15                  IS RECORD TO BE SAVED
         BNZ   PGMRET                   NO,DROP FULL RECORD
         RECNUM                         GET RECORD NUMBER
         L     R14,DMMNTR+16            MONITOR ENTRY
         L     R11,MRBLKSAV             POINT TO BLOCKSAVE OFFSET
         LA    R11,0(R14,R11)           POINT TO BLOCKSAVE ENTRY
         BR    R11                      GO AND SAVE
         SPACE 3
PGMRET   CALLMNTR FOR=BACK              RETURN TO FLIH
PGMRECUR EQU   *
         OI    DMSREAS1,DMSPREC         SET PGM-CHECK REASON
         OI    DMSFUNCT,DMSTST          FORCE DUMP
         MVC   DMSPGMW(8),FLCPOPSW      MOVE PSW TO CONST
         MVC   DMSPGMCD(8),PSAEPPSW     MOVE CODE TO CONST
         CALLMNTR FOR=DSCN              DISCONNECT DMS
         OI    DMSFUNCT,DMSEOJ+DMSTST   FORCE TERMINATION WITH DUMP
         MVI   RETCODE+2,2              SET NONZERO RETURN CODE
         CALLMNTR FOR=BACK              IGNORE DMS-PGM CHECK
         EJECT
PGMPER   MVC   PSLPSW(8),FLCPOPSW       MOVE CORRECT PSW TO LOW CORE
         TM    STARTFL2,STARTGO         IS INITIALIZATION COMPLETE
         BNO   PGMRET                   NO, DO NOT SAVE
         CLI   DMPER+6,BLANK            IS A SPECIAL RTN LOADED
         BE    PGMRET                   NO, RETURN
         TESTCPU NOTON=PGMRET           IS THIS CPU SELECTED
         SR    R5,R5                    CLEAR REGISTERS
         SR    R4,R4                    CLEAR REGISTER
         IC    R4,FLCPERCD              GET PER INTRPT CODE
         IC    R5,PEREMASK              AND GET CODE SPECIFICATION
         NR    R4,R5                    IS THIS CODE SELECTED
         BZ    PGMRET                   NO, GO BACK
         L     R4,FLCPER                GET PER ADDRESS
         TM    FLCPERCD,X'90'           IS IT CODE FOR STORAGE COMPARE
         BZ    PERNADOM                 NO, CODE IS OK
         CLC   PERSTART(4),PEREND       ARE ADDRESSES SPECIFIED
         BE    PERNADOM                 NO, DO NOT COMPARE
         CLC   PERSTART(4),PEREND       IS START ADDRESS HIGHER THAN EA
         BL    *+24                     NO, BRANCH
         C     R4,PEREND                IS INTRPT BELOW END
         BC    12,PERNADOM              YES, CONTINUE
         C     R4,PERSTART              IS INTRPT HIGHER THAN START
         BC    10,PERNADOM              YES, CONTINUE
         B     PGMRET                   NO, RETURN
         C     R4,PERSTART              IS ADDRESS WITHIN RANGE
         BL    PGMRET                   NO RETURN
         C     R4,PEREND                IS ADDRESS TOO HIGH
         BH    PGMRET                   YES, GO BACK
PERNADOM DS    0H
         ICM   R4,7,PERASCB+1           IS A SPECIFIC ADDRESS SPACE
         BZ    PERTRACE                 NO, TRACE ALL
         C     R4,PSAAOLD               IS THIS THE WANTED ASCB
         BNE   PGMRET                   NO, GO BACK
PERTRACE ICM   R9,7,PSCPUBLK+1          ADDRESS THIS CPU PAGE
         BZ    PGMRET                   GO BACK IF NO
         USING CPUBLK,R9
         RECID TYPE=PER
         LM    R6,R7,FLCPOPSW           MOVE PGM-OLD PSW TO
         STM   R6,R7,BLKPSW             RECORD
         MVC   BLKPSWCD+1(1),FLCPICOD+1 MOVE PGM CODE TO PSW
         MVC   BLKPSWCD(1),FLCPERCD     MOVE PER CODE TO PSW
         SR    R3,R3                    INDICATE NO ASCB TO SUBRTN
         CALLMNTR FOR=FILL              FILL IN REST OF RECORD
         L     R14,DMMNTR+16            ADDRESS OF MONITOR
         USING MRTABLE,R14
         L     R13,MRSAVE               DATA SAVE ROUTINE OFFSET
         LA    R13,0(R14,R13)           DATA SAVE ROUTINE ->
         ICM   R15,7,DMPER+17           -> USER ROUTINE
         BZ    PGMRET                   GO BACK IF NONE
         SR    R3,R3                    INDICATE NO ASCB TO SUBRTN
         DROP  R14
         CALLMNTR FOR=JOB,RG=R12        IS JOBNAME SELECTED
         USING MRTABLE,R14
         LTR   R15,R15                  IS IT
         BZ    PGMRET                   NO, GO BACK
         STM   R9,R11,PSHRSAV3          SAVE REGISTERS 9 TO 11
         BALR  R14,R15                  GO TO DS ROUTINE
         LM    R9,R11,PSHRSAV3          RELOAD MY REGISTERS
         LTR   R15,R15                  IS RECORD TO BE SAVED
         BNZ   PGMRET                   NO, GO BACK
         RECNUM
         L     R14,DMMNTR+16            -> TO MONITOR
         L     R11,MRBLKSAV             GET OFFSET TO BLOCKSAVE
         LA    R11,0(R14,R11)           GET ENTRY POINT TO RTN AND
         BR    R11                      GO THERE
         EJECT
PGMMONM0 DS    0H
         MVC   PSLPSW(8),FLCPOPSW       CONTINUE BEHIND MONITOR CALL
         TM    STARTFL2,STARTGO         IS INITIALIZATION COMPLETE
         BNO   PGMRET                   NO, DO NOT SAVE
         CLI   DMMON+6,BLANK            IS A SPECIAL RTN LOADED
         BE    PGMRET                   NO, GO BACK
         TESTCPU NOTON=PGMRET           IS THIS CPU SELECTED
         SR    R5,R5                    CLEAR REGISTER
         IC    R5,FLCMCNUM              GET MCLASS
         LR    R6,R5                    SAME VALUE TO SECOND REG.
         SRL   R5,3                     DIVIDE BY  8 TO GET BYTE OFFSET
         LA    R7,7                     GET AND MASK
         NR    R6,R7                    AND WITH BITMASK
         IC    R4,DMSTRTAB(R6)          GET MASK FOR TEST
         LA    R7,MONEMASK(R5)          POINT TO TWO BYTE TABLE
         EX    R4,DMSTSTMK              SEE IF BIT IS ON
         BZ    PGMRET                   GO BACK, IT IS OFF
MONTRACE ICM   R9,7,PSCPUBLK+1          ->   MY BLOCK
         BZ    PGMRET                   RETURN - NO BLOCK
         RECID TYPE=MON
         LM    R6,R7,FLCPOPSW           GET PGM OLD PSW
         STM   R6,R7,BLKPSW             INTO RECORD
         MVC   BLKPSWCD+1(1),FLCPICOD+1     INTRT CODE TO PREFIX
         MVC   BLKPSWCD(1),FLCMCNUM     MOVE MONITOR CLASS TO PREFIX
         SR    R3,R3                    INDICATE NO ASCB TO SUBRTN
         CALLMNTR FOR=FILL              COMPLETE PREFIX
         L     R14,DMMNTR+16            ADDRESS OF MONITOR
         USING MRTABLE,R14
         L     R13,MRSAVE               -> SAVE RTN OFFSET
         LA    R13,0(R14,R13)           -> ROUTINE ENTRY
         ICM   R15,7,DMMON+17           -> USER ROUTINE
         BZ    PGMRET                   NOT AVAILABLE
         SR    R3,R3                    INDICATE NO ASCB TO SUBRTN
         DROP R14
         CALLMNTR FOR=JOB,RG=R12        BASE R13
         USING MRTABLE,R14
         LTR   R15,R15                  IS SELECTION DONE
         BZ    PGMRET                   GO BACK IF NONE
         STM   R9,R11,PSHRSAV3          SAVE REGISTERS 9 TO 11
         BALR  R14,R15                  GO TO DATA-SAVE RTN
         LM    R9,R11,PSHRSAV3          RELOAD MY REGISTERS
         LTR   R15,R15                  IS RECORD TO BE SAVED
         BNZ   PGMRET                   NO, GO BACK
         RECNUM
         L     R14,DMMNTR+16            MONITOR ENTRY
         L     R11,MRBLKSAV             BLOCK-SAVE OFFSET
         LA    R11,0(R14,R11)           -> SAVE E.P.
         BR    R11                      GO THERE
         EJECT
PGMDAT   DS    0D
         CLI   DMDAT+6,BLANK            IS THERE A DAT RTN
         BE    PGMNODAT                 NO, CONTINUE
         TM    STARTFL2,STARTGO         IS INITIALIZATION COMPLETE
         BNO   PGMRET                   NO, DO NOT SAVE
         ICM   R9,7,PSCPUBLK+1          -> MY CPU BLOCK
         BZ    PGMRET                   RETURN IF NO
         USING CPUBLK,R9
         TESTCPU NOTON=PGMRET
         SPACE
         RECID TYPE=DAT                 GET RECORD ID
         LM    R6,R7,FLCPOPSW           GET PGM OD PSW
         STM   R6,R7,BLKPSW             SAVE ADDRESS
         MVC   BLKPSWCD(2),FLCPICOD     MOVE PGM CODE TO PREFIX
         SR    R3,R3                    INDICATE NO ASCB TO SUBRTN
         CALLMNTR FOR=FILL              COMPLETE PREFIX
         L     R14,DMMNTR+16            ADDRESS OF MONITOR
         USING MRTABLE,R14
         L     R13,MRSAVE               POINT TO OFFSET
         LA    R13,0(R14,R13)           ROUTINE EP
         ICM   R15,7,DMDAT+17           -> ENTRY POINT OF RTN
         BZ    PGMRET
         SR    R3,R3                    INDICATE NO ASCB TO SUBRTN
         DROP R14
         CALLMNTR FOR=JOB,RG=R12
         USING MRTABLE,R14
         LTR   R15,R15                  IS ROUTINE TO BE USED
         BZ    PGMRET                   NO, GO BACK
         STM   R9,R11,PSHRSAV3          SAVE REGISTERS 9 TO 11
         BALR  R14,R15                  GO TO ROUTINE
         LM    R9,R11,PSHRSAV3          RELOAD MY REGISTERS
         LTR   R15,R15                  IS RECORD TO BE SAVED
         BNZ   PGMRET                   NO, GO BACK
         RECNUM                         GET RECORD NUMBER
         L     R14,DMMNTR+16            GET MONITOR ENTRY
         L     R11,MRBLKSAV             POINT TO BLOCKSAVE OFFSET
         LA    R11,0(R14,R11)           -> ENTRY
         BR    R11                      GO THERE
         TITLE 'D M S M N T R  MONITOR ROUTINE OF DMS: M C H  ENTRY'
MCHENTRY DS    0D
         STCK  PSCLOCK                  SAVE TIME
         STM   R0,R15,PMCHSAVE          SAVE REGISTERS
         NI    FLCMOPSW,ALLBIT-BIT1     SET PER OFF
         BALR  R11,R0                   GET BASE
         USING *,R11
         MVI   PSDMSTR1,FOOTMCH         MARK CORRECT ENTRY
         TM    PSADMSF,BIT0             IS DMS IN CONTROL
         BO    MCHINDMS                 YES HANDLE MCH IN DMS
         OI    PSADMSF,BIT0             INDICATE DMS IN- CONTROL
         MVC   PREGSAVE(64),PMCHSAVE    MOVE USERS REGISTER
         ICM   DMSREG,7,PSACONST+1      -> TO DMSCONST
         BZ    MCHIGNRE                 NO POINTER, IGNORE INTRPT
         USING DMSCONST,DMSREG
MCHRCVR  MVC   PSLPSW(8),MCHNPSW        CONTINUE IN MC HANDLER
         TM    STARTFL2,STARTGO         IS INITIALIZATION COMPLETE
         BNO   MCHRET                   NO, DO NOT SAVE
         CLI   DMMCH+6,BLANK            IS A MCH RTN LOADED
         BNE   MCHHKIT                  YES, CHECK MORE ABOUT
MCHRET   CALLMNTR FOR=BACK              RETURN TO FLIH
MCHHKIT  TESTCPU NOTON=MCHRET
         ICM   R9,7,PSCPUBLK+1          GET CPU BLOCK
         BZ    MCHRET                   GO BACK IF NONE
         USING CPUBLK,R9
         RECID TYPE=MCH                 SET RECORD ID
         LM    R6,R7,FLCMOPSW           GET MCH OLD PSW
         STM   R6,R7,BLKPSW             INTO PREFIX
         SR    R3,R3                    INDICATE NO ASCB TO SUBRTN
         CALLMNTR FOR=FILL              COMPLETE PREFIX
         L     R14,DMMNTR+16            -> MONITOR
         USING MRTABLE,R14
         L     R13,MRSAVE               SAVE ROUTINE OFFSET
         LA    R13,0(R14,R13)           SAVE ROUTINE ->
         ICM   R15,7,DMMCH+17           -> TO USER RTN
         BZ    MCHRET                   GO BACK IF NONE
         SR    R3,R3                    INDICATE NO ASCB TO SUBRTN
         DROP R14
         CALLMNTR FOR=JOB,RG=R12        SEE JOBNAME SELECTION
         USING MRTABLE,R14
         LTR   R15,R15                  STILL NEEDED
         BZ    MCHRET                   NO, RETURN
         STM   R9,R11,PSHRSAV3          SAVE REGISTERS AND
         BALR  R14,R15                  GO TO USER
         LM    R9,R11,PSHRSAV3          RELOAD NY REGISTERS
         LTR   R15,R15                  RECORD NEEDED
         BNZ   MCHRET                   NO, DROP FULL RECORD
         RECNUM                         GET A SEQUENCE NUMBER
         L     R14,DMMNTR+16            -> MONITOR
         L     R11,MRBLKSAV             -> SAVE RTN OFFSET
         LA    R11,0(R14,R11)           -> SAVE RTN
         BR    R11                      GO THERE
MCHIGNRE ICM   DMSREG,7,PSCPUBLK+1      IS THERE A CPUBLK
         BZ    MCHWPSWL                 NO,WAIT
         L     DMSREG,0(DMSREG)         TRY TO RECOVER
         STCM  DMSREG,7,PSACONST+1      REFRESH POINTER
         B     MCHRCVR                  AND CONTINUE
MCHWPSWL MVC   PSHRSAVE(8),MCHWPSW      WAIT PSW TO LOW CORE
         MVI   MCHWPSW+4,C'3'           INDICATE MCH
         LPSW  PSHRSAVE                 AND WAIT
MCHWPSW  DC    X'000200F3'              HARD WAIT
         DC    X'00',C'DMS'             PSW
         SPACE
MCHINDMS ICM   DMSREG,7,PSACONST+1      GET POINTER TO CONST
         BZ    MCHIGNRE                 WAIT STATE IF NO
         CALLMNTR FOR=DSCN              DISCONNECT DMS
         MVI   RETCODE+3,16             SET HIGH RETCODE
         OI    DMSFUNCT,DMSTST+DMSEOJ   SET STOP
         OI    DMSREAS1,DMSMREC         INDICATE MCH CHECK
         MVC   PSLPSW(8),MCHNPSW        AND LEAVE
         CALLMNTR FOR=BACK              THEN SYSTEM
         TITLE 'D M S M N T R  MONITOR ROUTINE OF DMS: I / O  ENTRY'
IOIENTRY DS    0D
         STCK  PSCLOCK                  SAVE TIME OF EVENT
         STM   R0,R15,PSHRSAVE          AND REGISTERS
         NI    FLCIOPSW,ALLBIT-BIT1     SET PER OFF
         BALR  R11,R0                   ASSIGN
         USING *,R11                    BASE REGISTER
         MVI   PSDMSTR1,FOOTIOI         MARK CORRECT ENTRY
         ICM   DMSREG,7,PSACONST+1      GET ADDRESS OF DMSCONST
         BNZ   IOIDMSOK                 POINTER JS OK
         ICM   DMSREG,7,PSCPUBLK+1      IS THERE A CPUBLOCK
         BZ    IOIWAIT                  NO, WAIT
         L     DMSREG,0(DMSREG)         TRY TO RECOVER
         STCM  DMSREG,7,PSACONST+1      REFRESH POINTER
         B     IOIDMSOK                 AND CONTINUE
IOIWAIT  MVC   PSHRSAVE(8),IOIWPSW      CATASTROPHIC WAIT
         MVI   IOIWPSW+4,C'4'           INDICATE IOI
         LPSW  PSHRSAVE                 STATE
IOIWPSW  DC    X'000200F4'              ERROR
         DC    X'00',C'DMS'             PSW
IOIDMSOK EQU   *
         USING DMSCONST,DMSREG
         TM    PSADMSF,BIT0             IS DMS IN CONTROL
         BO    IOIRESIV                 YES, RECURSIVE ENTRY
         OI    PSADMSF,BIT0
         MVC   PREGSAVE(64),PSHRSAVE    REGISTERS TO LOW CORE
         MVC   PSLPSW(8),IOINPSW        CONTINUE IN I/O FLIH
         TM    STARTFL2,STARTGO         IS INITIALIZATION COMPLETE
         BNO   IOIRET                   NO, DO NOT SAVE
         CLI   DMUNT+6,BLANK            IS UNIT RTN SELECTED
         BNE   IOIUTYPE                 YES, CHECK MORE ABOUT
         CLI   DMIOI+6,BLANK            IS A SPECIAL RTN LOADED
         BNE   IOIHKIT                  CHECK MORE ABOUT
IOIRET   CALLMNTR FOR=BACK              NO,GO BACK
IOIUTYPE TM    DMSUTYPE,DMSUTYPI        IS IOI TYPE SELECTED
         BZ    IOIRET                   NO, SO RETURN
IOIHKIT  TM    FLCCSW+5,BIT0            IS IT A PCI
         BZ    IONOPCI                  NO, CONTINUE
         TM    PCIINT,PCIALL            IS PCI SELECTED
         BZ    IOIRET                   NO, SO RETURN
IONOPCI  TESTCPU NOTON=IOIRET           SEE IF CPU IS SELECTED
         LH    R6,FLCIOA+2              GET UNIT ADDRESS
         LR    R5,R6                    GET SAME VALUE INTO R5
         SRL   R5,3                     DIVIDE BY EIGHT TO GET BYTE
         LA    R7,7                     GET AND MASK
         NR    R6,R7                    GET BIT COMPLEMENT
         IC    R4,DMSTRTAB(R6)          GET MASK FOR TEST
         LA    R7,IOSINT(R5)            GET ADDRESS TO BE TESTED
         EX    R4,DMSTSTMK              SEE IF BIT IS ON
         BZ    IOIRET                   GO BACK
         ICM   R9,7,PSCPUBLK+1          -> CPUBLOCK
         BZ    IOIRET                   NO BLOCK, GO BACK
         USING CPUBLK,R9                BASE IT
         RECID TYPE=IOI                 GET RECORD ID INTO PREFIX
         LM    R6,R7,FLCIOPSW           MOVE OLD PSW
         STM   R6,R7,BLKPSW             INTO PREFIX
         MVC   BLKPSWCD(2),FLCIOA+2     MOVE UNIT # TO PREFIX
         SR    R3,R3                    INDICATE NO ASCB TO SUBRTN
         CALLMNTR FOR=FILL              COMPLETE PREFIX
         L     R14,DMMNTR+16            POINT TO TABLE
         USING MRTABLE,R14              BASE IT
         L     R13,MRSAVE               -> OFFSET TO DATASAVE
         LA    R13,0(R14,R13)           -> ADDRESS
         ICM   R15,7,DMIOI+17           -> USER RTN
         BZ    IOIRET
         SR    R3,R3                    INDICATE NO ASCB TO SUBRTN
         TM    DMSSELF1,SELUNIT         IS UNIT=ALL SPEC.
         BZ    NOIOJOB                  NO, DO NOT TEST JOBN.
         DROP  R14
         CALLMNTR FOR=JOB,RG=12         SEE IF JOBNAME IS SPECIFIED
         USING MRTABLE,R14
         LTR   R15,R15                  TO BE ENTERED
         BZ    IOIRET                   NO, DONT GO
NOIOJOB  DS    0H
         L     R7,FLCIOA                TAKE UNIT ADDRESS
         LA    R7,0(R7)                 CLEAR HIGH ORDER BYTE
         L     R1,DMSCVTP               -> CVT
         USING CVT,R1
         L     R4,CVTILK1               -> IECIELK1
         L     R5,CVTILK2               -> IECIELK2
         DROP  R1
         SLDL  R6,24                    INSERT CHANNEL VALUE
         SR    R3,R3                    CLEAR FOR INSERT
         IC    R3,0(R4,R6)              LOAD K VALUE
         SR    R6,R6                    CLEAR REG
         SLDL  R6,4                     INSERT CU VALUE
         ALR   R6,R3                    ADD VALUE   T7607
         ALR   R6,R6                    AND DOUBLE  T7607
         LH    R3,0(R4,R6)              TAKE L VALUE
         SRL   R7,27                    TWICE UNIT
         SLL   R3,1                     DOUBLE L VALUE
         ALR   R7,R3                    ADD IT TO UNIT
         ALR   R5,R7                    -> TABLE
         LH    R6,0(R5)                 LOAD UCB ADDRESS
         CLI   2(R6),X'FF'              IS IT UCB IDENT
         BNE   IOIRET                   DO NOT MONITOR
         CLC   5(1,R6),FLCIOA+3         VERIFY THE UNIT ADDRESS
         BNE   IOIRET                   DO NOT MONITOR
         TM    6(R6),X'20'              IS IOQE VALID
         BO    *+12                     YES, USE IT
         TM    7(R6),X'20'              IS IOQE VALID
         BZ    LDMASTER                 NO,LOAD MASTER CONTROL REGS
         SL    R6,=F'4'                 SUBTRACT FOUR
         L     R5,0(R6)                 -> IOQ ELEMENT
         L     R7,8(R5)                 -> IOSB
         LRA   R0,0(R7)                 IS IT VALID ADDRESS
         BNE   IOIRET                   NO, RETURN
         L     R2,DMSCVTP               -> CVT
         STCTL R1,R1,PSCTRL1
         USING CVT,R2
         L     R3,CVTASCBH              -> TOP ASCB
         DS    0H
         USING ASCB,R3
IOIASCBL CLC   6(2,R7),ASCBASID         IS IT THIS ASCB
         BE    LOADCIOI                 YES, GO OUT
         L     R3,ASCBFWDP              NEXT ASCB
         LTR   R3,R3                    IS THE ASCB PRESENT
         BZ    LDMASTER                 NO, LOAD MASTER CONTROL REGS
         LRA   R0,0(R3)                 IS IT VALID ADDRESS
         BNE   IOIRET                   NO, RETURN
         B     IOIASCBL                 PROCESS NEXT
LDMASTER L     R2,DMSCVTP               GET CVT ADDRESS
         L     R3,CVTASCBH              AND MASTERS ASCB
         STCTL R1,R1,PSCTRL1            SAVE CONTROL REGISTER 1
         DROP  R2
LOADCIOI LA    R7,1
         CLC   ASCBEGIN(4),=C'ASCB'     VALIDATE ASCB
         BNE   IOIWPSW
         LA    R7,2
         CLI   ASCBSTOR,15
         BNE   IOIWPSW
         LA    R7,3
         CLI   ASCBSTOR+3,0
         BNE   IOIWPSW
         LCTL  R1,R1,ASCBSTOR
         DROP  R3
         OI    PSADMSF,BIT1             SET CREG CHANGED FLAG
NLODCIOI EQU   *
         STM   R9,R11,PSHRSAV3          SAVE REGISTERS 9 TO 11
         BALR  R14,R15                  GO TO CALLER
         LM    R9,R11,PSHRSAV3          RELOAD MY REGISTERS
         NI    PSADMSF,ALLBIT-BIT1      SET C FLAG OFF
         LCTL  R1,R1,PSCTRL1            RELOAD CONTROL REGISTER
         LTR   R15,R15                  RECORD TO BE SAVED
         BNZ   IOIRET                   NO,DROP RECORD
         RECNUM                         GET RECORD NUMBER
         L     R14,DMMNTR+16            -> TABLE
         L     R11,MRBLKSAV             BLOCKSAVE OFFSET
         LA    R11,0(R14,R11)           -> BLOCKSAVE
         BR    R11
         SPACE 3
IOIRESIV CALLMNTR FOR=DSCN              TERMINATE
         OI    DMSFUNCT,DMSEOJ          DMS
         OI    DMSFUNCT,DMSTST          FORCE DUMP
         OI    DMSREAS1,IOIRECUR        INDICATE WHY
         MVC   DMSPGMW(8),FLCIOPSW      SAVE PSW
         MVC   DMSPGMCD(8),FLCIOA       AND INTERUPT CODE
         MVI   RETCODE+3,16             SET RETURNCODE
         CALLMNTR FOR=BACK              AND FLUSH
         TITLE 'D M S M N T R  MONITOR ROUTINE OF DMS: S I O  ENTRY'
SIOENTRY DS    0D
         BALR  R11,R0                   GET BASE
         USING *,R11
         USING DMSCONST,DMSREG
         MVI   PSDMSTR1,FOOTSIO         MARK CORRECT ENTRY
         TM    STARTFL2,STARTGO         IS INITIALIZATION COMPLETE
         BNO   SIORET                   NO, DO NOT SAVE
         CLI   DMUNT+6,BLANK            IS UNIT RTN SELECTED
         BNE   SIOUTYPE                 YES, CHECK MORE ABOUT
         CLI   DMSIO+6,BLANK            IS SIO SELECTED
         BNE   SIOHKIT                  YES, SEE MORE ABOUT
SIORET   CALLMNTR FOR=BACK              NO, GO BACK AND CONTINUE
SIOUTYPE TM    DMSUTYPE,DMSUTYPS        IS SIO TYPE SELECTED
         BZ    SIORET                   NO, SO RETURN
SIOHKIT  TESTCPU NOTON=SIORET           IS THIS CPU SELECTED
         LH    R6,PREGSAVE+26(R0)       GET UNIT ADDRESS FROM
         LR    R5,R6                    USERS REGISTER 6
         SRL   R5,3                     DIVIDE BY EIGHT
         LA    R7,7                     LOAD AND MASK
         NR    R6,R7                    BIT COMPLEMENT
         IC    R4,DMSTRTAB(R6)          GET BIT MASK
         LA    R7,SIOINT(R5)            POINT TO TABLE
         EX    R4,DMSTSTMK              AND TEST IT
         BZ    SIORET                   NOT, GO BACK
         ICM   R9,7,PSCPUBLK+1          POINT TO THE CPU BLOCK
         BZ    SIORET                   NO BLOCK NO TRACE
         USING CPUBLK,R9                REGISTER ASSIGNMENT
         RECID TYPE=SIO
         XC    BLKPSW(8),BLKPSW         SET PSW TO ZERO ON SIO EVENT
         MVC   BLKPSWCD(2),PREGSAVE+26     UNIT ADDRESS TO PSW AND
         SR    R14,R14                  CLEAR REGISTER
         IC    R14,PSLPSW+2             CONDITION CODE
         SRL   R14,4                    EXTRACT CC
         STC   R14,BLKPSW               AND ALSO TO RECORD
         L     R2,PREGSAVE+8(R0)        -> IOSB
         L     R2,28(R2)                -> SRB
         L     R3,8(R2)                 -> ASCB
         CALLMNTR FOR=FILL              COMPLETE PREFIX
         L     R14,DMMNTR+16            -> MRTABLE
         USING MRTABLE,R14
         L     R13,MRSAVE               SAVE RTN OFFSET
         LA    R13,0(R14,R13)           -> SAVE RTN
         ICM   R15,7,DMSIO+17           -> USER DATA
         BZ    SIORET                   BACK IF NO
         L     R2,PREGSAVE+8(R0)        -> IOSB
         L     R2,28(R2)                -> SRB
         L     R3,8(R2)                 -> ASCB
         TM    DMSSELF1,SELUNIT         IS UNIT=ALL SPECIFIED
         BZ    NOSIOJOB                 NO, DO NOT TEST FOR JOBNAME
         DROP  R14
         CALLMNTR FOR=JOB,RG=R12        CHECK FOR JOBNAME
         LTR   R15,R15                  RECORD NEEDED
         USING MRTABLE,R14
         BZ    SIORET                   NO, GO BACK
NOSIOJOB DS    0H
         L     R2,PREGSAVE+8            -> IOSB
         L     R7,DMSCVTP               -> CVT
         STCTL R1,R1,PSCTRL1
         USING CVT,R7
         L     R3,CVTASCBH              -> TOP ASCB
         DROP  R7
         USING ASCB,R3
SIOASCBL CLC   6(2,R2),ASCBASID         IS IT THIS ASCB
         BE    LOADCSIO                 YES, GO OUT
         L     R3,ASCBFWDP              NO, GET NEXT
         LTR   R3,R3                    IE THERE ONE
         BZ    NLODCSIO
         B     SIOASCBL                 GET NEST
LOADCSIO LA    R7,1
         CLC   ASCBEGIN(4),=C'ASCB'
         BNE   BLWTPSW
         LA    R7,2
         CLI   ASCBSTOR,15
         BNE   BLWTPSW
         LA    R7,3
         CLI   ASCBSTOR+3,0
         BNE   BLWTPSW
         STCTL R1,R1,PSCTRL1            SAVE CONTROL REGISTER 1
         LCTL  R1,R1,ASCBSTOR
         DROP  R3
         OI    PSADMSF,BIT1             SET CREG CHANGED FLAG
NLODCSIO EQU   *
         STM   R9,R11,PSHRSAV3          SAVE REGISTERS 9 TO 11
         BALR  R14,R15                  GO THERE
         LM    R9,R11,PSHRSAV3          RELOAD REGISTERS
         NI    PSADMSF,ALLBIT-BIT1      SET C FLAG OFF
         LCTL  R1,R1,PSCTRL1            RELOAD CONTROL REGISTER
         LTR   R15,R15                  IS RECORD TO BE SAVED
         BNZ   SIORET                   NO, TO BE DROPPED
         RECNUM                         NEXT FREE NUMBER
         L     R14,DMMNTR+16            -> MRTABLE
         L     R11,MRBLKSAV             OFFSET TO BLOCKSAVE
         LA    R11,0(R14,R11)           -> ENTRY TO BLKSAVE
         BR    R11                      GO THERE
         LTORG
         TITLE 'D M S M N T R  MONITOR ROUTINE OF DMS: JOBNAME'
JOBNSEL  DS    0D
         USING *,R12                    ASSIGN BASE
         USING DMSCONST,DMSREG
         SPACE
         TM    DMSSELF1,ALLBIT          IS ANY SELECTION DONE
         BZR   R14                      NO, RETURN
         SPACE
         TM    DMSSELF1,SELASID         IS ASID TO BE COMPARED
         BZ    JONASID                  NO, DO NOT COMPARE
         LTR   R3,R3                    DID CALLER SPECIFY ASCB
         BZ    JOBASCB                  NO, SO LOAD CURRENT
         LR    R5,R3                    TAKE CALLERS ASCB
         CLI   0(R5),C'A'               IS IT VALID
         BNE   JOBASCB                  NO USE CURRENT
         B     JOBUSCB                  YES, GO AROUND
JOBASCB  L     R5,PSAAOLD(R0)           LOAD CURRENT ASCB
JOBUSCB  EQU   *
         USING ASCB,R5
         CLC   ASCBASID(2),DMSASID      IS THIS ASCB TO BE USED
         BE    JONASID                  TREAT AS IF NOT SPECIFIED
JOBNDISP SR    R15,R15                  FORCE  ROUTINE NOT TO BE
         BR    R14                      DISPATCHED
         SPACE
JONASID  TM    DMSSELF1,SELJOBN         IS JOBNAME SELECTED
         BZR   R14                      IF NO JOBNAME, GO BACK
         LTR   R5,R3                    DID CALLER SPECIFY ASCB
         BNZ   JONLASCB                 YES, DO NOT CHANGE
         L     R5,PSAAOLD(R0)           NO, LOAD CURRENT ASCB
JONLASCB L     R6,ASCBJBNI              GET POINTER TO JOBNAME
         LTR   R6,R6                    IS THERE A POINTER
         BZ    JONXASCB                 NO, USE NEXT
         CLC   0(8,R6),DMSJOBN          IS JOBNAME EQUAL
         BNE   JOBNDISP                 NO, GO OUT
         LA    R6,8(R6)                 INCREMENT BY EIGTH
         B     JONCOMP
JONXASCB L     R6,ASCBJBNS              GET PROC NAME
         LTR   R6,R6                    IS THERE ONE
         BZ    JOBNDISP                 NO, GO OUT
         CLC   0(8,R6),DMSJOBN          IS JOBNAME EQUAL
         BNE   JOBNDISP                 NO, RETURN
JONCOMP  TM    DMSSELF1,SELSTEPN        IS STEPNAME TO BE TESTED
         BZR   R14                      NO, RETURN
         CLC   48(8,R6),DMSSTEPN        IS IT THE RIGHT STEP
         BNE   JOBNDISP                 NO, IT IS NOT
         BR    R14                      YES IT IS
         DROP  R5
         TITLE 'D M S M N T R  MONITOR ROUTINE OF DMS: DATA SAVE'
SAVERTN  DS    0H
         USING *,R13
         MVI   PSDMSTR2,FOOTSAVE        MARK CORRECT ENTRY
         STM   R0,R14,PDATSAVE          SAVE CALLERS REGISTER
         L     R9,PSCPUBLK(R0)          POINT TO CPU-BLOCK
         L     DMSREG,PSACONST(R0)      GET MY SHARED CONST
         USING CPUBLK,R9
         USING DMSCONST,DMSREG
         LTR   R2,R0                    WHAT WANTS CALLER
         BZ    RETLNGT                  HE WANTS TO KNOW THE RESIDUAL
         BM    DATWLNGT                 HE WANTS TO ADD DATA AND LENGTH
DATSAVEN C     R2,BLKRESLN              NORMAL ADD REQUEST
         BH    RETLNGT                  GO BACK WITH ERROR
         LRA   R3,0(R1)                 IS START ADDRESS AVAILABLE
         BNE   ADDRERR                  NO, SO RETURN
         LA    R5,0(R1,R2)              ADD LENGTH TO START ADDRESS
         BCTR  R5,R0                    SUBTRACT ONE
         LRA   R3,0(R5)                 IS END ADDRESS AVAILABLE
         BNE   ADDRERR                  NO, SO RETURN
         LH    R5,BLKRLEN               GET LENGTH OF CURRENT RECORD
         LA    R4,BLKBUFF(R5)           POINT TO START OF FREE AREA
         LA    R7,0(R4,R2)              POINT TO FIRST FREE BYTE
         BCTR  R7,R0                    POINT TO LAST USED BYTE
         LA    R5,2048                  POINT TO
         LA    R5,2048(R9,R5)           FIRST BYTE NOT TO BE USED
         CLR   R7,R5                    DOES IT FIT
         BNL   RETLNGT                  NO, SO RETURN
         LR    R5,R2                    GET LENGTH TO OPERANDS
         LR    R7,R5
         LR    R6,R1                    POINT TO DATA START
         MVCL  R4,R6                    AND MOVE DATA
         L     R4,BLKRESLN              GET OLD LENGTH
         SLR   R4,R2                    FROM OLD
         ST    R4,BLKRESLN              VALUE
         LH    R4,BLKRLEN               GET RECORD LENGTH
         ALR   R4,R2                    AND INCREASE TO
         STH   R4,BLKRLEN               NEW VALUE
         SR    R15,R15                  INDICATE DATA ADDED
DATRET   LM    R0,R14,PDATSAVE          AND
         BR    R12                      RETURN
         SPACE
RETLNGT  L     R15,BLKRESLN             GET RESIDUAL LENGTH
         LA    R15,1(R15)               COUNT IS ALLWAYS COUNT+1
         B     DATRET
         SPACE
ADDRERR  BAL   R15,DATRET               RETURN WITH NEGATIVE REGISTER
         SPACE
DATWLNGT LPR   R2,R2                    SET VALUE POSITIVE AND
         LA    R3,2(R2)                 GET NEW LENGTH
         C     R3,BLKRESLN              DOES IT FIT INTO RECORD
         BH    RETLNGT                  NO, SO RETURN MAXIMUM LENGTH
         LH    R5,BLKRLEN               GET LENGTH OF CURRENT ENTRY
         LA    R4,BLKBUFF(R5)
         LA    R5,2(R5)                 GET NEW RECORD LENGTH
         STH   R5,BLKRLEN               INTO IT
         LA    R15,2                    LOAD TWO BYTE COUNT FIELD
         STCM  R15,3,0(R4)              INTO RECORD
         L     R15,BLKRESLN             UPDATE
         BCTR  R15,R0                   RESIDUAL
         BCTR  R15,R0                   COUNT
         ST    R15,BLKRESLN
         LRA   R15,0(R1)                IS DATA ADDRESS VALID
         BNE   ADDRERR                  NO, RETURN
         LA    R15,0(R1,R2)             ADDLENGTH TO START ADDRESS
         BCTR  R15,R0                   SUBTRACT ONE
         LRA   R6,0(R15)                IS END ADDRESS AVAILABLE
         BNE   ADDRERR                  NO, SO RETURN
         STCM  R3,3,0(R4)               GET DATA LENGTH TO RECORD
         B     DATSAVEN                 AS NORMAL
         TITLE 'D M S M N T R  MONITOR ROUTINE OF DMS: BLOCK SAVE'
BLSAVERT DS    0D
         BALR  R11,R0                   ASSIGN
         USING *,R11                    BASE REGISTER
         USING DMSCONST,DMSREG
         USING CPUBLK,R9
         USING BUFFER,R8
         MVI   PSDMSTR2,FOOTBLOC        MARK CORRECT ENTRY
         SERILIZE WORD=DMSBUFFW,BUSY=BLSBUSY
         L     R8,DMSDISBF                OF MY CURRENT BUFFER
BLSMOVE  TM    BFRFLG,BFRFULL           IS THIS BUFFER FULL
         BO    BLSLOST                  YES,GO AND INDICATE LOST EVENTS
         LA    R1,BFRSTART              POINT TO START
         LA    R14,BFREND               AND END
         L     R12,BFRLNGT              GET CURRENT LENGTH OF RECORD
         LA    R2,0(R1,R12)             POINT TO REAL START
         LH    R3,BLKRLEN               GET LENGTH OF BLOCK TO BE ADDED
         LA    R13,0(R3,R2)             ADD RECORD
         CR    R13,R14                  COMPARE WITH END ADDRESS
         BH    BLFULL                   RECORD TOO BIG, DOES NOT FIT
         LR    R4,R2                    REAL START POINT
         LR    R5,R3                    GET LENGTH OF MOVE
         LR    R7,R3                    INTO BOTH REGISTERS
         LA    R6,BLKBUFF               POINT TO FROM ADDRESS
         MVCL  R4,R6                    AND MOVE TRACE ENTRY
         ALR   R12,R3                   ADD LENGTH AND SAVE IT
         ST    R12,BFRLNGT              INTO BUFFER
BLSRET   FREE  WORD=DMSBUFFW            DESERIALIZE
         CALLMNTR FOR=BACK              RETURN
         SPACE
BLSLOST  EQU   *
         L     R13,DMSLSTEV             GET NUMBER OF LOST EVENTS
         LA    R13,1(R13)               INCREASE BY ONE,
         ST    R13,DMSLSTEV             SAVE VALUE TO CONST AND
         B     BLSRET                   RETURN
         SPACE
BLFULL   L     R1,BFRNEXT               POINT TO NEXT BLOCK
         OI    BFRFLG,BFRFULL           SET THIS BUFFER FULL
         CLI   BUFECB,BIT0              IS ECB WAITING
         BNE   BLNOPOST                 NO, DO NOT POST
         TM    STARTFL2,DMSPDONE        HAD POST BEEN ENTERED
         BO    BLNOPOST                 YES, DO NOT ENTER AGAIN
         LH    R8,PSAHLHI+2             CHECK HIERARCHY OF
         CLM   R8,3,=XL2'0400'          LOCKS FOR AVAILABILITY
         BNL   BLNOPOST                 SALLOC CANNOT BE OBTAINED
         L     R8,PSALCCAV              GET MY LCCA ->
         TM    X'20C'(R8),ALLBIT        IS ANY SPINBIT ON
         BNZ   BLNOPOST                 YES, SO DO NOT ENTER POST
         L     R8,DMSASCBP              GET MY ASCB
         C     R8,PSAAOLD               IS IT NORMAL POST
         BE    BLNOPOST                 DO NOT ENTER POST
CROSSPST DS    0H
         STCTL R0,R2,PSDMSCS0           SAVE CONTROL REGISTERS
         XC    PSDMSCL0(12),PSDMSCL0    CLEAR LOAD AREA
         MVC   PSDMSCL0(2),PSDMSCS0     DISABLE FOR ALL
         MVC   PSDMSCL1(4),PSDMSCS1     SET CONTROL REGISTER 1
         LCTL  R0,R2,PSDMSCL0           LOAD CONTROL REGISTERS
         STOSM PSDMSNMK,BIT6+BIT7       SET PSEUDO ENABLE
         STM   R0,R14,PDATSAVE          SAVE REGISTERS TO LOW CORE
         MVC   DMSAMPSW(8),PSAMPSW      SAVE
         MVC   DMSALKSA(64),PSALKSA     SETLOCK'S
         MVC   DMSAHLHI(4),PSAHLHI      DYNAMIC
         MVC   DMSASUP1(1),PSASUP1      AREA
GSALLOC  SETLOCK OBTAIN,TYPE=SALLOC,MODE=COND,                         C
               RELATED=(FSALLOC)        OBTAIN SALLOC FOR XMPOST
         STNSM PSDMSNMK,BIT5            DISABLE
         LR    R15,R13                  SET RETURN CODE TO OUTPUT
         LM    R0,R14,PDATSAVE          RELOAD REGISTERS
         LCTL  R0,R2,PSDMSCS0           RELOAD CALLERS REGISTER
         ST    R15,PDATSAVE+32          SAVE RETURN CODE TO R8 LOC
         CL    R15,=F'4'                CHECK RETURN CODE
         BH    BLWAIT                   DO NOT ENTER POST
         BE    *+14                     NOT GOTTEN, DO NEVER RELEASE
         OI    STARTFL3,DMSSLOCK        INDICATE LOCK GOTTEN
         MVC   STARTFL4(1),PSACPULA+1   SAVE ID OF OWNING CPU
         OI    STARTFL2,POSTFLAG        INDICATE POST ENTERED
         OI    STARTFL2,DMSPDONE        SET POST ENTERED FLAG
         L     R15,DMSCVTP              GET CVT ADDRESS
         USING CVT,R15
         L     R15,CVT0PT01             -> OF XMPOST
         DROP  R15
         LA    R12,POSTERET             -> ERROR RETURN
         L     R13,DMSASCBP             GET -> TO MY ASCB
         LA    R5,BUFECB                ASSUME NORMAL POST
         LA    R4,128                   LOAD MASK TO
         SLL   R4,24                    MAKE REGISTER NEGATIVE
         OR    R5,R4                    NO, DO XMPOST
         OR    R12,R4                   SET NOT MEMORY RELATED
         L     R2,DMSXMPST              GET COUNT OF XMPOST
         LA    R2,1(0,R2)               INCREASE BY ONE
         ST    R2,DMSXMPST              SAVE NEW VALUE
         LR    R11,R5                   GET ECB ADDRESS
         SR    R10,R10                  SET COMPLETION CODE TO ZERO
         STCTL R0,R2,PSDMSCS0           SAVE CONTROL REGS 0-2
         XC    PSDMSCL0(12),PSDMSCL0    CLEAR PSW LOAD AREA
         MVC   PSDMSCL0(2),PSDMSCS0     MOVE USED CODE
         MVC   PSDMSCL1(4),PSDMSCS1     TO CONTROL LOAD AREA
         LCTL  R0,R2,PSDMSCL0           LOAD CONTROL REGS 0-2
         STOSM PSDMSNMK,BIT6+BIT7       ENABLE
         BALR  R14,R15                  GO TO POST
         STNSM PSDMSNMK,BIT5            DISABLE
         LCTL  R0,R2,PSDMSCS0           RELOAD CONTROL REGISTERS
         LM    R8,R11,PDATSAVE+32       RETURN CODE INTO REG 8
         LTR   R8,R8                    WAS LOCK OBTAINED FROM DMS
         BNZ   BLWAIT                   NO, SO DO NOT RELEASE
         LCTL  R0,R2,PSDMSCL0
         STOSM PSDMSNMK,BIT6+BIT7       ENABLE
FSALLOC  SETLOCK RELEASE,TYPE=SALLOC,DISABLED,                         C
               RELATED=(GSALLOC)        FREE SALLOC LOCK
         NI    STARTFL3,ALLBIT-DMSSLOCK INDICATE LOCK RELEASED
         MVI   STARTFL4,0               CLEAR OWNERS CPUID
BLWAIT   LM    R0,R15,PDATSAVE          RELOAD MY REGISTERS
         STNSM PSDMSNMK,BIT5            DISABLE I/O AND EXTERNAL
         LCTL  R0,R2,PSDMSCS0           RELOAD CONTROL REGS 0-2
         NI    STARTFL2,ALLBIT-POSTFLAG RESET POST ACTIVE BIT
         MVC   PSAMPSW(8),DMSAMPSW      RESTORE
         MVC   PSALKSA(64),DMSALKSA     SETLOCK'S
         MVC   PSAHLHI(4),DMSAHLHI      DYNAMIC
         MVC   PSASUP1(1),DMSASUP1      AREA
BLNOPOST LR    R8,R1                    POINT TO NEXT BLOCK
         ST    R8,DMSDISBF              SET NEW AS CURRENT
         B     BLSMOVE
         SPACE
POSTERET L     DMSREG,PSACONST          LOAD ADDRESS OF CONST
         LRA   R11,0(,DMSREG)           IS IT VALID
         BNER  R14                      NO RETURN TO OS
         NI    STARTFL2,ALLBIT-DMSPDONE SET POST ENETERED FLAG OFF
         BR    R14                      AND GO BACK
         LTORG
BLWTPSW  EQU   *
         EX    R15,*                    FORCE 0C3 PGM CHECK
BLSBUSY  TM    STARTFL2,POSTFLAG        WAS POST ENTERED
         BO    BLSPSTIN                 YES, LOOK FOR SECOND ENTRY
         NI    STARTFL2,ALLBIT-BLSSECND CLEAR SECOND ENTRY IF ON
         SERILIZE WORD=DMSBUFFW         SERIALIZE RESOURCE
         L     R8,DMSDISBF              GET MY CURRENT BUFFER
         B     BLSMOVE                  AND CONTINUE
BLSPSTIN TM    STARTFL2,BLSSECND        IS IT SECOND TIME
         BO    BLSECON                  YES, CLEAN UP
         OI    STARTFL2,BLSSECND        SET FLAG FOR SECOND ENTRY
         L     R13,DMSLSTEV             GET NUMBER OF LOST EVENTS
         LA    R13,1(R13)               BUMP BY ONE
         ST    R13,DMSLSTEV             AND SAVE NEW VALUE
         CALLMNTR FOR=BACK              RETURN NOW
         SPACE
BLSECON  NI    STARTFL2,ALLBIT-POSTFLAG RESET POST BIT
         NI    STARTFL2,ALLBIT-BLSSECND RESET SECOND ENTRY SWITCH
         B     BLSLOST
         TITLE 'D M S M N T R  MONITOR ROUTINE OF DMS: D S P  ENTRY'
DSPENTRY DS    0D
         BALR  R11,R0                   ASSIGN
         USING *,R11                    BASE
         USING DMSCONST,DMSREG
         MVI   PSDMSTR1,FOOTDSP         MARK CORRECT ENTRY
         LA    R3,1                     ASSUME  SRB DISPATCH GLOBAL
         CLC   DSPHOOK1+1(3),PSLPSW+5   IS IT SRB
         BE    DSPTYPOK                 YES GO OUT
         LA    R3,2                     NO, ASSUME NECT
         CLC   DSPHOOK2+1(3),PSLPSW+5   IS IT WAIT
         BE    DSPTYPOK                 YES GO OUT
         LA    R3,3
         CLC   DSPHOOK3+1(3),PSLPSW+5   IS IT LOCAL SRB
         BE    DSPTYPOK                 YES GO OUT
         LA    R3,4                     ASSUME NEXT LOCAL SUPERVISOR
         CLC   DSPHOOK4+1(3),PSLPSW+5   IS IT LOCAL SUPERVISOR
         BE    DSPTYPOK                 YES GO OUT
         LA    R3,5                     LOAD TASK DISPATCHER VALUE
         CLC   DSPHOOK5+1(3),PSLPSW+5   IS IT TASK
         BE    DSPTYPOK
         LA    R3,6                     LOAD EXIT DISPATCHER VALUE
         CLC   DSPHOOK6+1(3),PSLPSW+5   IS IT EXIT
         BE    DSPTYPOK                 YES, GO OUT
         B     DSPRET                   IGNORE OTHER IF THERE ARE
DSPTYPOK ST    R3,PSDSPCDE(R0)          SAVE DISPATCHER EVENT CODE
         NI    PSAPSWSV,ALLBIT-BIT1     SET PER OFF
         STCK  PDCLOCK                  SAVE TIME OF DISP EVENT
         CLI   DMPER+6,BLANK            IS PROGRAM EVENT RECORDING ON
         BNE   DSPPERON                 GO AND HANDLE PER
DSPNOPER TM    STARTFL2,STARTGO         IS INITIALIZATION COMPLETE
         BNO   DSPRET                   NO, DO NOT SAVE
         CLI   DMDSP+6,BLANK            IS A SPECIAL RTN LOADED
         BNE   DSPHKIT                  YES, SEE MORE ABOUT
DSPRET   CALLMNTR FOR=BACK              NO  GO BACK
DSPHKIT  TESTCPU NOTON=DSPRET           LOOK IF THIS CPU SELECTED
         ICM   R9,7,PSCPUBLK+1          -> CPU-BLOCK
         BZ    DSPRET
         USING CPUBLK,R9                ASSIGN REGISTER
         RECID TYPE=DSP
         LM    R6,R7,PSAPSWSV           GET DISPATCHER PSW
         STM   R6,R7,BLKPSW             INTO PREFIX
         MVC   BLKPSWCD(2),PSDSPCDE+2   MOVE DISPATCHER CODE TO PREFIX
         SR    R3,R3                    INDICATE NO ASCB TO SUBRTN
         CALLMNTR FOR=FILL              COMPLETE PREFIX
         L     R14,DMMNTR+16            -> MRTABLE
         USING MRTABLE,R14
         L     R13,MRSAVE               SAVE RTN OFFSET
         LA    R13,0(R14,R13)           -> SAVE RTN ENTRY
         ICM   R15,7,DMDSP+17           -> USER RTN
         BZ    DSPRET                   BACK IF NONE
         SR    R3,R3                    INDICATE NO ASCB TO SUBRTN
         DROP R14
         CALLMNTR FOR=JOB,RG=R12        CHECK FOR JOBNAME
         LTR   R15,R15                  IS RECORD NEEDED
         USING MRTABLE,R14
         BZ    DSPRET                   NO, GO BACK
         STM   R9,R11,PSHRSAV3          RELOAD REGISTERS AND
         BALR  R14,R15                  GO THERE
         LM    R9,R11,PSHRSAV3          RELOAD REGISTERS
         LTR   R15,R15                  IS RECORD TO BE SAVED
         BNZ   DSPRET                   NO, RETURN
         RECNUM
         L     R14,DMMNTR+16            -> MRTABLE
         STCK  PDCLOCK                  GET MORE PRECISE TIME INTO
         LM    R6,R7,PDCLOCK            PREFIX
         STM   R6,R7,BLKCLOCK           RECORD
         STM   R6,R7,BLKDICLK           TIME
         L     R11,MRBLKSAV             OFFSET TO BLOCK SAVE
         LA    R11,0(R14,R11)           ->     TO BLOCK SAVE
         BR    R11                      GO THERE
         SPACE
DSPPERON DS    0H
         L     R15,PSDSPCDE             GET  DISPATCHER TYPE
         SLL   R15,2                    MULTIPLY BY FOUR
         B     *(R15)                   USE BRANCHTABLE AND R15 AS INDE
DSPERBTB B     DSPERH01                 GLOBAL SRB
         B     DSPERH02                 WAIT TASK
         B     DSPERH03                 LOCAL SRB
         B     DSPERH04                 LOCAL SUPERVISOR
         B     DSPERH05                 TASK DISPATCH
         B     DSPERH06                 EXIT DISPATCH
DSPERH01 TM    PERMODES,X'80'           IS GLOBAL ON
         BZ    DSPNOPER                 NO, GO BACK
         CLC   DMSASCBP+1(3),PSAAOLD+1  IS IT FOR DMS
         BE    DSPNOPER                 YES, IGNORE PER
         TM    PEREMASK,X'40'           IS INSTRUCTION FETSCH
         BO    DSPNOPER                 YES, NOT SUPPORTED
         B     DSPTASKD                 YES, PROCESS
DSPERH02 TM    PERMODES,X'40'           IS WAIT OM
         BZ    DSPNOPER
         B     DSPTASKD
DSPERH03 TM    PERMODES,X'20'           LOCAL SRB
         BZ    DSPNOPER
         CLC   DMSASCBP+1(3),PSAAOLD+1  IS IT FOR DMS
         BE    DSPNOPER                 YES, IGNORE PER
         TM    PEREMASK,X'40'           IS INSTRUCTION FETSCH
         BO    DSPNOPER                 YES, NOT SUPPORTED
         B     DSPTASKD
DSPERH04 TM    PERMODES,X'10'           LOCAL SUPERVISOR
         BZ    DSPNOPER
         CLC   DMSASCBP+1(3),PSAAOLD+1  IS IT FOR DMS
         BE    DSPNOPER                 YES, IGNORE PER
         TM    PEREMASK,X'40'           IS INSTRUCTION FETSCH
         BO    DSPNOPER                 YES, NOT SUPPORTED
         B     DSPTASKD
DSPERH05 TM    PERMODES,X'08'           TASK DISPATCH
         BZ    DSPNOPER
         B     DSPTASKD
DSPERH06 TM    PERMODES,X'04'           EXIT DISPATCH
         BZ    DSPNOPER
         B     DSPTASKD
         DS    0H
DSPTASKD EQU   *                        TASK DISPATCHER -> PER PROC
         SR    R3,R3                    INDICATE NO ASCB TO SUBRTN
         DROP R14
         CALLMNTR FOR=JOB,RG=R12        SEE IF JOB IS TO BE PROCESSED
         USING MRTABLE,R14
         LTR   R15,R15                  IS JOB TO BE PROCESSED
         BZ    DSPNOPER                 NO, GO BACK
         LCTL  R9,R11,PEREMASK          YES LOAD CONTROL REGISTERS
         OI    PSAPSWSV,BIT1            AND SET BIT IN PSW FOR PER
         B     DSPNOPER                 AND TREAT AS IT NOT
         TITLE 'D M S M N T R  MONITOR ROUTINE OF DMS: VARY CPU'
CPUENTRY DS    0D
         BALR  R11,R0                   ASSIGN BASE
         USING *,R11                    REGISTER
         USING DMSCONST,DMSREG
         MVI   PSDMSTR2,FOOTCPU         MARK CORRECT ENTRY
         OI    DMSREAS1,CPUADDED        SET REASON CODE
         CALLMNTR FOR=DSCN              DISCONNECT DMS
         CALLMNTR FOR=BACK              AND FLUSH
         TITLE 'D M S M N T R  MONITOR ROUTINE OF DMS: A C R  ENTRY'
ACRENTRY DS    0D
         BALR  R11,R0                   ASSIGN BASE
         USING *,R11                    REGISTER
         USING DMSCONST,DMSREG
         MVI   PSDMSTR2,FOOTACR         MARK CORRECT ENTRY
         TM    STARTFL2,STARTGO         IS INITIALIZATION COMPLETE
         BNO   ACRRET                   NO, DO NOT SAVE
         CLI   DMIOI+6,BLANK            IS A SPECIAL I/O RTN LOADED
         BNE   ACRHKIT                  CHECK MORE ABOUT IF YES
ACRRET   CALLMNTR FOR=BACK              NO, GO BACK
ACRHKIT  TESTCPU NOTON=ACRRET
         LH    R6,FLCIOA+2(R0)          GET UNIT ADDRESS
         LR    R5,R6                    ALSO INTO THIS REG
         SRL   R5,3                     DIVIDE BY EIGHT
         LA    R7,7                     TAKE AND MASK
         NR    R6,R7                    GET BIT COMPLEMENT MASK
         IC    R4,DMSTRTAB(R6)          CORRESPONDING MASK
         LA    R7,IOSINT(R5)            ADDRESS TO BE TESTED
         EX    R4,DMSTSTMK              IS THIS UNIT ON
         BZ    ACRRET                   NO GO BACK
         ICM   R9,7,PSCPUBLK+1          -> CPUBLOCK
         BZ    ACRRET                   GO BACK IF NO
         USING CPUBLK,R9                BASE IT
         RECID TYPE=IOI                 SET I/O INTRPT
         LM    R6,R7,FLCIOPSW           MOVE OLD PSW
         STM   R6,R7,BLKPSW             INTO PREFIX
         MVC   BLKPSWCD(2),FLCIOA+2     STORE UNIT TO PREFIX
         SR    R3,R3                    INDICATE NO ASCB TO SUBRTN
         CALLMNTR FOR=FILL
         L     R14,DMMNTR+16            -> TABLE
         USING MRTABLE,R14
         L     R13,MRSAVE               ->  DATASAVE OFFSET
         LA    R13,0(R14,R13)           ->  DATASAVE RTN
         ICM   R15,7,DMIOI+17           ->  USER RTN
         BZ    ACRRET                   GO BACK IF NONE
         SR    R3,R3                    INDICATE NO ASCB TO SUBRTN
         DROP R14
         CALLMNTR FOR=JOB,RG=R12        DO JOBNAME PROCESSING
         USING MRTABLE,R14
         LTR   R15,R15                  IS RTN TO BE ENTERED
         BZ    ACRRET                   NO, GO BACK
         STM   R9,R11,PSHRSAV3          SAVE REGISTERS 9 TO 11
         BALR  R14,R15                  GO THERE
         LM    R9,R11,PSHRSAV3          RELOAD MY REGISTERS
         LTR   R15,R15                  IS RECORD TO BE SAVED
         BNZ   ACRRET                   NO, GO BACK
         RECNUM
         L     R14,DMMNTR+16            -> MRTABLE
         L     R11,MRBLKSAV             -> BLOCKSAVE OFFSET
         LA    R11,0(R14,R11)           -> BLOCKSAVE RTN
         BR    R11                      GO THERE
         TITLE 'D M S M N T R  MONITOR ROUTINE OF DMS: R T M  ENTRY'
RTMENTRY DS    0D
         BALR  R11,R0                   ASSIGN
         USING *,R11                    BASE
         USING DMSCONST,DMSREG
         MVI   PSDMSTR2,FOOTRTM         MARK CORRECT ENTRY
         L     R14,DMMNTR+16            -> MRTABLE
         USING MRTABLE,R14
         L     R12,MRRES                -> RESTART ENTRY OFFSET
         LA    R13,0(R12,R14)           -> RTN
         ST    R13,FLCRNPSW+4           RESTORE RESTART NEW PSW
         L     R12,MRPGM                -> PGM OFFSET
         LA    R13,0(R12,R14)           -> PGM RTN
         ST    R13,FLCPNPSW+4           RESTORE PGM NEW PSW
         OI    FLCPNPSW,BIT5            ENABLE DAT
         DROP  R14
         CALLMNTR FOR=BACK              AND CONTINUE PROCESSING
         TITLE 'D M S M N T R  MONITOR ROUTINE OF DMS: STOP CPU'
STPENTRY DS    0D
         BALR  R11,R0                   ASSIGN
         USING *,R11                    BASE
         USING DMSCONST,DMSREG
         MVI   PSDMSTR2,FOOTSTP         MARK CORRECT ENTRY
         OI    DMSREAS1,CPUSTOPD        SET REASON CODE
         CALLMNTR FOR=DSCN
         OI    DMSFUNCT,DMSEOJ          STOP BIT ON
         CALLMNTR FOR=BACK              AND RETURN
         END
