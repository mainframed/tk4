***********************************************************************
*
*        M V S    L O G O N    P R E P R O M P T E R
*
*        L I N K E D   T O   B Y   I K J E F L D
*        R10 (LGNREG)  ->  L O G O N   D S E C T   D A P A R M
*
*
***********************************************************************
IKJEXIT  CSECT
         SAVE  (14,12),,*          SAVE REGISTERS
         LR    BASREG,LNKREG
         USING IKJEXIT,BASREG      ESTABLISH BASE REGISTER
         L     R0,SAVESIZE
         GETMAIN R,LV=(0)          GET WORKING STORAGE
         LR    LNKREG,SAVREG
         ST    SAVREG,4(PRMREG)    CHAIN SAVE AREAS
         ST    PRMREG,8(SAVREG)
         LR    SAVREG,PRMREG
         USING SAVEAREA,SAVREG     MAKE SCRATCHPAD DSECT ADDRESSIBLE
         USING DAPARM,LGNREG       MAKE DAPARM     DSECT ADDRESSIBLE
         EJECT
*
*        PERFORM IKJEXIT HOUSEKEEPING
*
         XC    ECB(WORKLNG),ECB    ZERO SCRATCHPAD STORAGE AREA
         L     ECTREG,DAPECTPT     FETCH PTR TO ECT SDV
         USING SDV,ECTREG          MAKE SDV ADDRESSIBLE
         L     ECTREG,SDVPTR       ESTABLISH ADDR OF ECT
         USING ECT,ECTREG          MAKE ECT ADDRESSIBLE
         L     UPTREG,DAPUPTPT     FETCH PTR TO UPT SDV
         USING SDV,UPTREG          MAKE SDV ADDRESSIBLE
         L     UPTREG,SDVPTR       ESTABLISH ADDR OF UPT
         USING UPT,UPTREG          MAKE UPT ADDRESSIBLE
         XC    UPT(16),UPT         ZERO USER PROFILE TABLE
         L     CTLREG,DAPBUFPT     FETCH PTR TO LOGON KEY-IN SDV
         USING SDV,CTLREG          MAKE SDV ADDRESSIBLE
         L     CTLREG,SDVPTR       CTLREG -> LOGON KEY-IN
         DROP  CTLREG              DROP SDV ADDRESSIBILITY
        MVC MYLGNBUF(80),0(CTLREG) COPY LOGON KEY-IN TO MY BUFFER
         OC    MYLGNBUF,BLNKS      CONVERT LOGON KEY-IN TO UPPER CASE
         EJECT
*
*        ADVISE USER HE IS IN LOGON PREPROMPTER!!
*
         LA    MSGREG,MSG1
         BAL   LNKREG,PUTMSG
*
*        IF SECRET '*DEBUG' KEYWORD IS FOUND, TURN ON DEBUGGING MSGS
*
         MVI   DEBUGSW,X'00'   TURN DEBUGGING SWITCH OFF
         LA    PARREG,MYLGNBUF
         LA    FNDREG,DEBUGKW
         BAL   LNKREG,PARSE    DOES '*DEBUG' KEYWORD EXSIST IN BUFFER?
         B     CHKPSWD         NO  - DONT PRINT OUT INTERNAL STUFF.
         MVI   DEBUGSW,X'01'   YES - LET MR. PRIVELEGED SEE WHAT'S WHAT
*
*        ECHO USER'S LOGON INPUT SDV (ONLY IF DEBUGGING SWITCH IS ON)
*
         MVC   LOGONLNG(2),=XL2'0050'  SET LNG TO 80 CHARS
         MVC   LOGONLNG+2(2),=XL2'0000' FILL IN MSG CNTL AREA
         LA    MSGREG,LOGONLNG
         BAL   LNKREG,PUTMSG   ECHO IKJEFLA'S TEXT BUFFER TO USER!!
         EJECT
*
*        DETERMINE IF USER HAS SPECFIED A PASSWORD (IE, A SLASH)
*
CHKPSWD  LA    PARREG,MYLGNBUF
         LA    FNDREG,SLASH
         BAL   LNKREG,PARSE    PASSWORD PRESENT ON LOGON KEY-IN?
         B     NOPSWD          NO -  CONTINUE
         B     SKPEXIT         YES - THAT'S ALL, FOLKS!!
*
*        LOCATE 'LOGON ' KEYWORD
*
NOPSWD   LA    FNDREG,LOGONKW  PARSE FOR 'LOGON '
         BAL   LNKREG,PARSE
         B     ER1             ER1 - LOGON KEYWORD NOT FOUND
*
*        MOVE CHAR PTR TO 1ST CHAR OF USER'S USERID
*
         LA    WRKREG,5         MAX OF 5 BLANKS AFTER 'LOGON' KEYWORD
GETC     CLI   0(FNDREG),X'40'  SLEW PAST BLANKS
         BNE   GETID            FOUND A NONBLANK AT LAST!
         LA    FNDREG,1(FNDREG)
         BCT   WRKREG,GETC      STILL LOOKING
         B     ER2              ER 2 - NO USERID SPECIFIED
         EJECT
*
*        PROCESS USER'S USERID
*
GETID    LR    WRKREG,FNDREG    SAVE LOC. OF 1ST CHAR OF USERID
         LR    PARREG,FNDREG    MOVE SCAN PTR TO 1ST CHAR OF USERID
         LA    FNDREG,BLANK
         BAL   LNKREG,PARSE     PARSE FOR BLANK AFTER USERID
         B     ER3              ER 3 - INVALID USERID
         LR    PARREG,FNDREG    MOVE INITIAL SCAN PTR
         SR    FNDREG,WRKREG    COMPUTE LNG OF USERID + 1
         S     FNDREG,=F'2'     COMPUTE LNG OF USERID - 1
         C     FNDREG,=F'6'     MORE THAN 7 CHARS IN USERID?
         BH    ER4              ER 4 - TOO MANY CHARS IN USERID
         L     CTLREG,DAPUSEPT  FETCH PTR TO USERID SDV
         MVC   USERID(7),BLNKS  BLANK OUT USERID AREA BEFORE FILLING IN
         EX    FNDREG,SETID     ESTABLISH USERID
         B     GETID2
SETID    MVC   USERID(0),0(WRKREG)
GETID2   LA    FNDREG,1(FNDREG) SET (FNDREG) = # OF CHARS IN USERID
         STH   FNDREG,IDLNG     ESTABLISH # OF CHARS IN USERID
         EJECT
*
*        LOCATE AND VALIDATE CHARGE NUMBER
*
         LA    FNDREG,APAREN
         BAL   LNKREG,PARSE     PARSE FOR 'A('
         B     ACT1             NOT FOUND
         B     VALIDATE         GOT IT - GO VALIDATE IT.
*
ACT1     LA    FNDREG,ACPAREN
         BAL   LNKREG,PARSE     PARSE FOR 'AC('
         B     ACT2             NOT FOUND
         B     VALIDATE         GOT IT - GO VALIDATE IT.
*
ACT2     LA    FNDREG,AKEYWD
         BAL   LNKREG,PARSE     PARSE FOR 'ACCT('
         B     SKPEXIT          ACCOUNT NOT SPECIFIED - QUIT.
*
VALIDATE MVC   ACCT(9),BLNKS     BLANK OUT CHARGE NUMBER FIELD
         BAL   LNKREG,CHKCHGNO   IS CHARGE # SYNTAX ACCEPTABLE?
         B     ER5               NO  - ISSUE ERROR MSG AND QUIT.
         STH   TM2REG,ACLNG      YES - ESTABLISH LNG OF ACCT FOR SDV
         BCT   TM2REG,ACT3       DECREMENT CHAR KNT 1 FOR MVC INSTR
ACT3     EX    TM2REG,SETCHGNO   ESTABLISH USER'S CHARGE NUMBER.
         B     GETPROC           GO GET LOGON PROCEDURE NAME.
*
SETCHGNO MVC   ACCT(0),0(FNDREG)
         EJECT
*
*        LOCATE LOGON PROCEDURE NAME
*
GETPROC  LA    FNDREG,PPAREN
         BAL   LNKREG,PARSE      PARSE FOR 'P('
         B     PROC1             NOT FOUND
         B     GETPLNG           ESTABLISH LOGON PROCEDURE NAME
*
PROC1    LA    FNDREG,PRPAREN
         BAL   LNKREG,PARSE      PARSE FOR 'PR('
         B     PROC2             NOT FOUND
         B     GETPLNG           ESTABLISH LOGON PROCEDURE NAME
*
PROC2    LA    FNDREG,PKEYWD
         BAL   LNKREG,PARSE      PARSE FOR 'PROC('
         B     SKPEXIT           PROCEDURE NOT SPECIFIED - QUIT.
*
GETPLNG  LR    TM1REG,FNDREG     SAVE POS OF 1ST CHAR OF PROC. NAME
         LA    WRKREG,9          SET MAX # CHARS ALLOWED = 8
FINDRP   CLI   0(FNDREG),C')'    FOUND CLOSING PARENTHESIS?
         BE    SETPROC           YES - GO CHECK LNG OF PROC. NAME
         CLI   0(FNDREG),C' '    IS CHAR INSIDE ( ) A BLANK?
         BE    ER7               YES - KILL USER, NO BLANKS ALLOWED.
         LA    FNDREG,1(FNDREG)  NO  - MOVE CHAR PTR 1 POSITION RIGHT
         BCT   WRKREG,FINDRP     LENGTH > 8 CHARACTERS?
         B     ER6               YES - PROC. NAME IS TOO LONG. QUIT.
*
SETPROC  MVC   PROC(8),BLNKS     BLANK OUT PROCEDURE NAME IN DSECT.
         SR    FNDREG,TM1REG     COMPUTE LNG OF PROC. NAME
         LTR   FNDREG,FNDREG     ANY CHARACTERS BETWEEN ()?
         BZ    ER8               NO - PROCNAME IS MISSING. (TSO009I)
         BCT   FNDREG,SETPROC1   REDUCE BY 1 FOR MVC INSTR.
SETPROC1 EX    FNDREG,PROCMOVE   ESTABLISH LOGON PROCEDURE NAME
         B     SETPROC2
PROCMOVE MVC   PROC(0),0(TM1REG)
SETPROC2 LA    FNDREG,1(FNDREG)  SET (FNDREG) = LNG OF PROC. NAME
         STH   FNDREG,PRLNG      SET SDVCUR FOR PROCEDURE.
         EJECT
*
*        PARSE LOGON FOR EXCLUSION OF NOTICES OR MAIL
*
         MVI   MAIL,C'X'      SET 'MAIL'    SWITCH ON
         MVI   NOTICE,C'Y'    SET 'NOTICES' SWITCH ON
         LA    FNDREG,NON
         BAL   LNKREG,PARSE   PARSE FOR ' NON'
         B     CHKMAIL        NOT FOUND - USER WILL GET NOTICES
         MVI   NOTICE,C'N'    SET SWITCH TO INDICATE 'NONOTICES'
*
CHKMAIL  LA    FNDREG,NOM
         BAL   LNKREG,PARSE   PARSE FOR ' NOM'
         B     ENDOPT         NOT FOUND - USER WILL GET HIS MAIL.
         MVI   MAIL,C'M'      SET SWITCH TO INDICATE 'NOMAIL'
*
ENDOPT   EQU   *
         EJECT
*
*        ECHO USERID, ACCT, PROCNAME, FLAGS IF DEBUGGING
*
         CLI   DEBUGSW,X'00'  IS DEBUGGING OPTION ON?
         BE    SKIPMSG        NO - DO NOT ISSUE DEBUGGING MSG
         MVC   DB1MSG(4),=XL4'001E0000'
         LA    MSGREG,DB1MSG  OUTPUT USERID, ACCOUNT, PROCNAME, FLAGS.
         BAL   LNKREG,PUTMSG  TO VERIFY PROPER PARSING.
*
*        INFORM USER ACCOUNT AND PROCNAME ARE ACCEPTABLE
*
SKIPMSG  LA    MSGREG,MSG3
         BAL   LNKREG,PUTMSG
*
*        TEST IF LOGON FAILED DUE TO MISSING RESOURCE (NO CORE, ETC.)
*
         L     CTLREG,DAPCTLPT FETCH PTR TO CNTL SWITCHES SDV
         USING SDV,CTLREG      MAKE SDV ADDRESSIBLE
         L     CTLREG,SDVPTR   CTLREG -> CONTROL SWITCHES
         DROP  CTLREG
         TM  0(CTLREG),CTLFAIL ALL REQUIRED RESOURCES AVAILABLE?
         BO    ER9             NO  - ISSUE MSG AND ABORT LOGON
         B     SETSMF          YES - PASS INFO BACK TO TSO LOGON
         EJECT
*
*        RETURN INFO ESTABLISHED BY LOGON PREPROMPTER TO TSO.
*        FILL IN ALL REQUIRED SDV'S, SET BIT SWITCHES, ETC.
*        EXIT WILL RETURN US TO IKJEFLI WHO WILL DOUBLE CHECK
*        OUR WORK - IF HE SAYS O.K., THE USER WILL BE LOGGED ON.
*
SETSMF   CLI   MAIL,C'M'          WAS 'NOMAIL' SPECIFIED?
         BE    SETNMAIL           YES
         NI    ECTSWS,X'F7'       NO - TURN 'NOMAIL' BIT OFF
         B     SETNOTI
SETNMAIL OI    ECTSWS,X'08'       TURN ON 'NOMAIL' BIT
*
SETNOTI  CLI   NOTICE,C'N'        WAS 'NONOTICES' SPECIFIED?
         BE    SETNNON            YES
         NI    ECTSWS,X'FB'       NO - TURN 'NONOTICES' BIT OFF
         B     SETATR
SETNNON  OI    ECTSWS,X'04'       TURN ON 'NONOTICES' BIT
*
*        ESTABLISH PSCB ATR1:
*
SETATR   L     CTLREG,DAPAT1PT    CTLREG -> PSCB ATR1 SDV
         USING SDV,CTLREG         ESTABLISH SDV ADDRESSIBILITY
         L     TM1REG,SDVPTR      TM1REG -> ATR1 STRING
         MVI   SDVCUR+1,3         SET ATR1 CURRENT LENGTH
         OI    0(TM1REG),PSCBJCL  TURN ON JCL SUBMISSION BIT
         CLC USERID(6),=C'SSTEST' IS THIS MR. PRIVILEGED HIMSELF?
         BNE   SETATR2            NO, SIR.  ALL HE GETS IS JCL.
         OI    0(TM1REG),PSCBCTRL YES - MAKE HIM AN OPERATOR.
         OI    0(TM1REG),PSCBACCT       MAKE HIM SYSTEM MGR.
*
*        ESTABLISH PSCBATR2
*
SETATR2  L     CTLREG,DAPAT2PT    CTLREG -> PSCB ATR2 SDV
         L     TM1REG,SDVPTR      TM1REG -> ATR2 STRING
         MVI   SDVCUR+1,2         SET ATR2 CURRENT LENGTH
         XC    0(2,TM1REG),0(TM1REG) ZERO PSCB ATR2
         EJECT
*
*        ESTABLISH GENERIC GROUP NAME FOR DYNAMIC ALLOCATION
*
         L     CTLREG,DAPGUNPT      CTLREG -> GENERIC GROUPNAME SDV
         L     TM1REG,SDVPTR        TM1REG -> GENERIC GROUPNAME STRING
         MVI   SDVCUR+1,6           SET LENGTH OF STRING TO 6 CHARS
       MVC   0(6,TM1REG),=C'TSOVIO' GENERIC UNIT NAME IS 'TSOVIO'
*
*        ESTABLISH REGION SIZE
*
         L     CTLREG,DAPRGNPT      CTLREG -> REGION SIZE FULLWORD
         MVC   0(4,CTLREG),REGSIZE  SET REGION SIZE
*
*        ESTABLISH TSO PERFORMANCE GROUP NUMBER
*
         L     CTLREG,DAPPRFPT      CTLREG -> PERFORMANCE GROUP NUMBER
         MVC   0(4,CTLREG),PERFGRP  SET PERFORMANCE GROUP NUMBER
*
*        ESTABLISH USERID
*
         L     CTLREG,DAPUSEPT      CTLREG -> USERID SDV
         L     TM1REG,SDVPTR        TM1REG -> USERID STRING
         LH    TM2REG,IDLNG         TM2REG =  # OF CHARS IN USERID
         STH   TM2REG,SDVCUR        SET SDV LENGTH
         BCT   TM2REG,SETID1        DECREMENT TM2REG BY 1 FOR MVC INSTR
SETID1   EX    TM2REG,MOVEID        FILL IN USERID IN SDV
         B     SETACCT
MOVEID   MVC   0(0,TM1REG),USERID
*
*        ESTABLISH ACCOUNT
*
SETACCT  L     CTLREG,DAPACCPT      CTLREG -> ACCOUNT SDV
         L     TM1REG,SDVPTR        TM1REG -> ACCOUNT STRING
         LH    TM2REG,ACLNG         TM2REG =  # OF CHARS IN ACCOUNT
         STH   TM2REG,SDVCUR        SET SDV LENGTH
         BCT   TM2REG,SETAC1        DECREMENT TM2REG BY 1 FOR MVC INSTR
SETAC1   EX    TM2REG,MOVEAC        FILL IN ACCOUNT IN SDV
         B     SETPROCN
MOVEAC   MVC   0(0,TM1REG),ACCT
*
*        ESTABLISH PROCEDURE
*
SETPROCN L     CTLREG,DAPROCPT      CTLREG -> PROCEDURE SDV
         L     TM1REG,SDVPTR        TM1REG -> PROCEDURE STRING
         LH    TM2REG,PRLNG         TM2REG =  # OF CHARS IN PROCEDURE
         STH   TM2REG,SDVCUR        SET SDV LENGTH
         BCT   TM2REG,SETPR1        DECREMENT TM2REG BY 1 FOR MVC INSTR
SETPR1   EX    TM2REG,MOVEPR        FILL IN PROCEDURE IN SDV
         B      FINAL
MOVEPR   MVC   0(0,TM1REG),PROC
         EJECT
*
*        EVERYTHING HAS BEEN FILLED IN.  TURN ON BIT SWITCHES
*        TO INFORM IKJEFLI THAT WE ARE SUPPLYING EVERYTHING.
*
FINAL    L     CTLREG,DAPCTLPT      CTLREG -> BIT SWITCHES SDV
         L     CTLREG,SDVPTR        CTLREG -> BIT SWITCHES
         DROP  CTLREG               DROP SDV ADDRESSIBILITY
         OI    0(CTLREG),CTLNOPR    DON'T PROMPT
         OI    0(CTLREG),CTLNUAD    DON'T CHECK UADS
         OI    1(CTLREG),CTLATR1    PSCB ATR1 INFO       SUPPLIED BY US
         OI    1(CTLREG),CTLATR2    PSCB ATR2 INFO       SUPPLIED BY US
         OI    1(CTLREG),CTLUNIT    GENERIC UNIT NAME    SUPPLIED BY US
         OI    1(CTLREG),CTLBUPT    USER PROFILE TABLE   SUPPLIED BY US
*        OI    1(CTLREG),CTLNONQ    ALLOW MULTIPLE USE OF SAME USERID.
*
*        IKJEXIT WILL NOW EXIT TO IKJEFLD WHO WILL GO TO IKJEFLI.
*
         B     EXIT
         EJECT
*
*        THE WRITING OF ERROR MSGS IS DONE HERE:
*
ER1      LA     MSGREG,ER1MSG
         BAL    LNKREG,PUTMSG
         B      GOODBYE
ER2      LA     MSGREG,ER2MSG
         BAL    LNKREG,PUTMSG
         B      GOODBYE
ER3      LA     MSGREG,ER3MSG
         BAL    LNKREG,PUTMSG
         B      GOODBYE
ER4      LA     MSGREG,ER4MSG
         BAL    LNKREG,PUTMSG
         B      GOODBYE
ER5      LA     MSGREG,ER5MSG
         BAL    LNKREG,PUTMSG
         B      GOODBYE
ER6      LA     MSGREG,ER6MSG
         BAL    LNKREG,PUTMSG
         B      GOODBYE
ER7      LA     MSGREG,ER7MSG
         BAL    LNKREG,PUTMSG
         B      GOODBYE
ER8      LA     MSGREG,ER8MSG
         BAL    LNKREG,PUTMSG
         B      GOODBYE
ER9      LA     MSGREG,ER9MSG
         BAL    LNKREG,PUTMSG
         B      GOODBYE
*
*        ISSUE GOODBYE MESSAGE - RESOURCE(S) UNAVAILABLE
*
GOODBYE  LA    MSGREG,FAILMSG
         BAL   LNKREG,PUTMSG
         EJECT
*
*        TO KILL A LOGON, BRANCH TO DISCUSER
*        WARNING:  ISSUE ANY REQUIRED MESSAGE BEFORE COMING HERE
*
DISCUSER L     CTLREG,DAPCTLPT  FETCH PTR TO CNTL SWITCHES SDV
         USING SDV,CTLREG       MAKE SDV ADDRESSIBLE
         L     CTLREG,SDVPTR    CTLREG -> LOGON CONTROL SWITCHES
         DROP  CTLREG
         OI  0(CTLREG),CTLDISC  TURN 'ABORT LOGON' SWITCH ON
*
*        RETURN TO REAL TSO LOGON EXIT MODULE IKJEFLD
*
EXIT     LR    PRMREG,SAVREG
         L     R0,SAVESIZE
         L     SAVREG,4(SAVREG)
         FREEMAIN R,LV=(0),A=(1)
         RETURN (14,12),T,RC=0
*
*        SKPEXIT IS EXECUTED IF PREPROMPTER IS TO BE BYPASSED.
*
SKPEXIT  LA    MSGREG,SKPMSG
         BAL   LNKREG,PUTMSG
         B     EXIT
         EJECT
*
*        PUTMSG - WRITE A MSG TO THE TERMINAL
*                 MSGREG HAS ADDR OF 'PUT' FORMAT MSG
*                 NO REGISTERS ARE DESTROYED BY THIS ROUTINE
*
PUTMSG   STM   R14,PRMREG,PUTSAVE
         XC    ECB,ECB        ZERO ECB
       PUTLINE PARM=PUTLINE,UPT=(UPTREG),ECT=(ECTREG),ECB=ECB,         X
               OUTPUT=((MSGREG),,,DATA),MF=(E,IOPL)
         LTR   LNKREG,LNKREG  ANY ERRORS?
         LM    R14,PRMREG,PUTSAVE
         BNZ   DISCUSER       YES - KILL THE HAPLESS CHILD
         BR    LNKREG         NO  - EXIT WITH REGISTERS RESTORED
         EJECT
*
*        CHKCHGNO - CHECK IF CHARGE NUMBER HAS ACCEPTABLE FORMAT
*                   ANNNNNB WHERE A=ALPHA, N=DIGIT, B=LETTER D,M,S,A
*
*                   FNDREG SHOULD POINT TO THE 1ST CHAR OF THE CHGNO
*                   WHEN CHKCHGNO IS CALLED.  TM2REG CONTAINS LNG OF
*                   CHGNO IF VALID.  EXITS: * INVALID CHGNO, *+4 VALID.
*
CHKCHGNO BAL   TM1REG,CHKALPH  IS 1ST CHAR ALPHABETIC (A-Z)?
         B     BADNO           NO  - ERROR
*
*        TEST 2ND THRU 6TH POSITIONS OF CHGNO FOR NUMERIC CHARACTERS
*
         CLI   1(FNDREG),X'F0'
         BL    BADNO
         CLI   1(FNDREG),X'F9'
         BH    BADNO
         CLI   2(FNDREG),X'F0'
         BL    BADNO
         CLI   2(FNDREG),X'F9'
         BH    BADNO
         CLI   3(FNDREG),X'F0'
         BL    BADNO
         CLI   3(FNDREG),X'F9'
         BH    BADNO
         CLI   4(FNDREG),X'F0'
         BL    BADNO
         CLI   4(FNDREG),X'F9'
         BH    BADNO
         CLI   5(FNDREG),X'F0'
         BL    BADNO
         CLI   5(FNDREG),X'F9'
         BH    BADNO
         EJECT
*
*        PROCESS CHARGE NUMBER MODIFIER/PHASE CODE SYNTAX.
*        ACCEPTABLE SYNTAXES ARE:  ACCT(ANNNNNP)   - TYPE 1
*                                  ACCT(ANNNNNAP)  - TYPE 2
*                                  ACCT(ANNNNNAAP) - TYPE 3
*
         LA    FNDREG,6(FNDREG) FNDREG -> MODIFIER/PHASE CODE CHARS
*
         CLI   1(FNDREG),C')'   IS CHARGE # TYPE 1?
         BNE   CHKTYPE2         NO
*
*        PROCESS TYPE 1 CHGNO SYNTAX: 7 CHAR CHGNO
*
         LA    TM2REG,7         SET LNG OF CHGNO TO 7
         B     CHKPHASE         VALIDATE PHASE CODE
*
CHKTYPE2 CLI   2(FNDREG),C')'   IS CHARGE # TYPE 2?
         BNE   CHKTYPE3         NO
*
*        PROCESS TYPE 2 CHGNO SYNTAX: 8 CHAR CHGNO
*
         LA    TM2REG,8         SET LNG OF CHGNO TO 8
         BAL   TM1REG,CHKALPH   IS 7TH CHARACTER ALPHABETIC?
         B     BADNO            NO - BAD SYNTAX.
         LA    FNDREG,1(FNDREG) FNDREG -> PHASE CODE CHARACTER.
         B     CHKPHASE         GO CHECK PHASE CODE.
*
CHKTYPE3 CLI   3(FNDREG),C')'   IS CHARGE # TYPE 3?
         BNE   BADNO            NO - BAD SYNTAX.
*
*        PROCESS TYPE 3 CHGNO SYNTAX: 9 CHAR CHGNO
*
         LA    TM2REG,9         SET LNG OF CHGNO TO 9
         BAL   TM1REG,CHKALPH   IS 7TH CHARACTER ALPHABETIC?
         B     BADNO            NO - BAD SYNTAX.
         LA    FNDREG,1(FNDREG) FNDREG -> 8TH CHARACTER.
         BAL   TM1REG,CHKALPH   IS 8TH CHARACTER ALPHABETIC?
         B     BADNO            NO - BAD SYNTAX.
         LA    FNDREG,1(FNDREG) FNDREG -> PHASE CODE CHARACTER.
         B     CHKPHASE         GO CHECK PHASE CODE.
         EJECT
*
*        VALIDATE PHASE CODE
*
CHKPHASE CLI   0(FNDREG),C'D'   IS PHASE CODE CHAR A 'D'?
         BE    CHGOK            YES - CHGNO IS ACCEPTABLE
         CLI   0(FNDREG),C'M'   IS 7TH CHAR A 'M'
         BE    CHGOK            YES - CHGNO IS ACCEPTABLE
         CLI   0(FNDREG),C'S'   IS 7TH CHAR A 'S'
         BE    CHGOK            YES - CHGNO IS ACCEPTABLE
         CLI   0(FNDREG),C'A'   IS 7TH CHAR A 'A'
         BNE   BADNO            NO -  BAD ENDING DELIMITER
*
*        ALL CHARGE NUMBER SYNTAX CHECKS PASSED.
*
CHGOK    LA     FNDREG,1(FNDREG) FNDREG -> CLOSING ')'.
         SR     FNDREG,TM2REG    FNDREG -> 1ST CHAR OF   CHGNO.
         LA     LNKREG,4(LNKREG) EXIT AT *+4 FOR VALID   CHGNO.
BADNO    BR     LNKREG           EXIT AT *   FOR INVALID CHGNO.
         EJECT
*
* SUBROUTINE TO CHECK IF FNDREG -> ALPHABETIC CHAR A-Z.
*
CHKALPH  CLI   0(FNDREG),X'C1' 1ST CHAR < 'A'?
         BL    BADALPH         YES - ERROR
         CLI   0(FNDREG),X'CA' 1ST CHAR < '!'?
         BL    OKALPH          YES - 1ST CHAR IS OK
         CLI   0(FNDREG),X'D1' 1ST CHAR < 'J'?
         BL    BADALPH         YES - ERROR
         CLI   0(FNDREG),X'DA' 1ST CHAR < 'S'?
         BL    OKALPH          YES - 1ST CHAR IS OK
         CLI   0(FNDREG),X'E2' 1ST CHAR > R AND < S?
         BL    BADALPH         YES - ERROR
         CLI   0(FNDREG),X'EA' 1ST CHAR =< 'Z'?
         BL    OKALPH          YES - 1ST CHAR IS OK
         B     BADALPH         NO  - ERROR
OKALPH   LA   TM1REG,4(TM1REG) CHAR  OK: SET TO EXIT AT *+4.
BADALPH  BR    TM1REG          CHAR ^OK: SET TO EXIT AT *.
         EJECT
*
*        PARSE - PARREG -> STRING BEING PARSED
*                FNRREG -> STRING BEING SEARCHED FOR
*
*        IF TEXT FOUND, FNDREG -> BYTE AFTER TEXT UPON EXIT
*        EXIT AT *   IF TEXT NOT FOUND
*        EXIT AT *+4 IF TEXT IS  FOUND
*
PARSE    STM     PARREG,TM2REG,PSV    SAVE WORKING REGISTERS
         SR      TM1REG,TM1REG        CLEAR OUT TEXT LENGTH REGISTER.
         IC      TM1REG,0(FNDREG)     LOAD LNG OF STRG BEING SRCHED FOR
         BCT     TM1REG,PARSEI        DECREMENT LNG BY 1 FOR CLC INSTR
PARSEI   LA      FNDREG,1(FNDREG)     SET FNDREG -> 1ST CHAR OF TEXT.
         LA      TM2REG,50            ALLOW 50 ATTEMPTS TO LOCATE
PARSE1   EX      TM1REG,CLC           DO TEXT STRINGS MATCH?
         LA      PARREG,1(PARREG)     (MOVE CHAR PTR 1 POS RIGHT)
         BE      FOUND                YES - TAKE 'FOUND MATCH' EXIT.
         BCT     TM2REG,PARSE1        NO  - TRIED 50 TIMES YET?
         B       PEXIT                YES - TOO BAD.  TEXT NOT FOUND.
FOUND    AR      PARREG,TM1REG        MAKE (PARREG)->1 BYTE BEYOND TEXT
         ST      PARREG,PSV+4         BUT ON EXIT, WILL BE IN FNDREG!!
         LA      LNKREG,4(LNKREG)     TEXT FOUND.  SET EXIT AT *+4
PEXIT    LM      PARREG,TM2REG,PSV    RESTORE REGISTERS.
         BR      LNKREG               RETURN TO CALLER.
*
CLC      CLC   0(0,FNDREG),0(PARREG)  TARGET OF 'EX' INSTR
         EJECT
*
*        GENERAL USER MESSAGES:
*
         DS     0F
MSG1     DC    AL2(MSG1L)
         DC    AL2(00)
         DC    C'TSO001I LOGON PREPROCESSOR INVOKED.'
MSG1L    EQU   *-MSG1
         DS    0H
MSG3     DC    AL2(MSG3L)
         DC    AL2(00)
         DC    C'TSO002I CHARGE NUMBER AND PROCEDURE ACCEPTED.'
MSG3L    EQU   *-MSG3
FAILMSG  DC    AL2(FAILMSGL)
         DC    AL2(00)
         DC    C'TSO999I LOGON ATTEMPT FAILED - PLEASE TRY AGAIN.'
FAILMSGL EQU   *-FAILMSG
SKPMSG   DC    AL2(SKPMSGL)
         DC    AL2(00)
         DC   C'TSO100I USERID DEFAULTS WILL BE USED FOR THIS SESSION.'
SKPMSGL  EQU   *-SKPMSG
         EJECT
*
*        DETAILED EXPLANATION ERROR MESSAGES:
*
ER1MSG   DC    AL2(ER1LNG)
         DC    AL2(00)
         DC    C'TSO003I LOGON KEYWORD NOT FOUND.'
ER1LNG   EQU   *-ER1MSG
ER2MSG   DC    AL2(ER2LNG)
         DC    AL2(00)
         DC    C'TSO004I TOO MANY BLANKS AFTER ''LOGON'' KEYWORD.'
ER2LNG   EQU   *-ER2MSG
ER3MSG   DC    AL2(ER3LNG)
         DC    AL2(00)
         DC    C'TSO005I INVALID SYNTAX IN USERID.'
ER3LNG   EQU   *-ER3MSG
ER4MSG   DC    AL2(ER4LNG)
         DC    AL2(00)
         DC    C'TSO006I TOO MANY CHARACTERS IN USERID.'
ER4LNG   EQU   *-ER4MSG
ER5MSG   DC    AL2(ER5LNG)
         DC    AL2(00)
         DC    C'TSO007I INVALID CHARGE NUMBER SYNTAX.'
ER5LNG   EQU   *-ER5MSG
ER6MSG   DC    AL2(ER6LNG)
         DC    AL2(00)
         DC    C'TSO008I TOO MANY CHARACTERS IN PROCEDURE NAME.(MAX=8)'
ER6LNG   EQU   *-ER6MSG
ER7MSG   DC    AL2(ER7LNG)
         DC    AL2(00)
         DC    C'TSO009I NO BLANKS ALLOWED IN PROCEDURE SPECIFICATION.'
ER7LNG   EQU   *-ER7MSG
ER8MSG   DC    AL2(ER8LNG)
         DC    AL2(00)
         DC    C'TSO010I REQUIRED LOGON PROCEDURE NAME IS MISSING.'
ER8LNG   EQU   *-ER8MSG
ER9MSG   DC    AL2(ER9LNG)
         DC    AL2(00)
         DC    C'TSO011I REQUIRED LOGON RESOURCE IS UNAVAILBLE.'
ER9LNG   EQU   *-ER9MSG
         EJECT
*
*        CONSTANTS AND TEXT PARSING STRINGS
*
         DS    0F
SAVESIZE DC    A(SAVEND-SAVEAREA)
REGSIZE  DC    F'0'           ACCEPT 1ST AVAILABLE REGION
PERFGRP  DC    F'51'          RUN IN PERFORMANCE GROUP 51
BLANK    DC    XL1'01'        *KEEP**********
BLNKS    DC    80XL1'40'      *****TOGETHER *
DEBUGKW  DC    XL1'06'        PARSING STRING
         DC    C'*DEBUG'
APAREN   DC    XL1'02'        PARSING STRING
         DC    C'A('
ACPAREN  DC    XL1'03'        PARSING STRING
         DC    C'AC('
AKEYWD   DC    XL1'05'        PARSING STRING
         DC    C'ACCT('
PPAREN   DC    XL1'02'        PARSING STRING
         DC    C'P('
PRPAREN  DC    XL1'03'        PARSING STRING
         DC    C'PR('
PKEYWD   DC    XL1'05'        PARSING STRING
         DC    C'PROC('
NON      DC    XL1'04'        PARSING STRING
         DC    C' NON'
NOM      DC    XL1'04'        PARSING STRING
         DC    C' NOM'
SLASH    DC    XL1'01'        PARSING STRING
         DC    C'/'
LOGONKW  DC    XL1'06'        PARSING STRING
         DC    C'LOGON '
         EJECT
*
*        DYNAMIC STORAGE DEFINITIONS
*
SAVEAREA DSECT
SAVE     DS    18F            MUST BE 1ST STMNT AFTER DSECT
ECB      DS    F              MUST BE 2ND STMNT AFTER DSECT
PSV      DS    4F
IOPL     DC    4F'0'          INPUT/OUTPUT PARAMETER LIST
PUTSAVE  DS    4F             PUTMSG SAVE AREA
DEBUGSW  DS    XL1            DEBUGGING SWITCH:  X'00'=OFF, X'01'=ON
LOGONLNG DS    AL2            TEMPORARY - DEBUGGING  DO
         DS    AL2            TEMPORARY - DEBUGGING     NOT
MYLGNBUF DS    CL80           UPPER CASE LOGON KEY-IN TEXT
IDLNG    DS    H
ACLNG    DS    H
PRLNG    DS    H
DB1MSG   DS    CL4            MSG HEADER
USERID   DS    CL7            USER'S ID
ACCT     DS    CL9            USER'S MRS CHARGE NUMBER
PROC     DS    CL8            USER'S LOGON PROCEDURE NAME
MAIL     DS    CL1            MAIL SWITCH (M=MAIL,X=NOMAIL)
NOTICE   DS    CL1            NOTICES SWITCH (N=NOTICE,Y=NONOTICE)
PUTLINE  PUTLINE MF=L
         DS    0H
SAVEND   DS    D
WORKLNG  EQU   SAVEND-ECB
         EJECT
*
*        VECTOR FROM IKJEFLA POINTED TO BY R10 IN THIS MODULE:
*
DAPARM   DSECT
DAPCTLPT DS    F              PNTR TO CTL BIT STRING DOPE VECTOR (SDV)
DAPBUFPT DS    F              PNTR TO USER'S LOGON KEYIN SDV
DAPUSEPT DS    F              PNTR TO USERID CHAR SDV
DAPSWDPT DS    F              PNTR TO PASSWORD CHAR SDV
DAPACCPT DS    F              PNTR TO ACCOUNT CHAR SDV
DAPROCPT DS    F              PNTR TO PROCEDURE CHAR SDV
DAPRGNPT DS    F              REGION SIZE (FIXED BIN(31))
DAPJCLPT DS    F              PNTR TO JCL CHAR SDV
         DS    F              RESERVED
DAPAT1PT DS    F              PNTR TO PSCB ATTR1 BIT SDV
DAPAT2PT DS    F              PNTR TO PSCB ATTR2 BIT SDV
DAPGUNPT DS    F              PNTR TO GENERIC UNIT CHAR SDV
DAPUPTPT DS    F              PNTR TO UPT BIT SDV
DAPECTPT DS    F              PNTR TO ECT BIT SDV
DAPECBPT DS    F              PNTR TO CANCEL ECB (READ ONLY)
DAPCOMPT DS    F              PNTR TO STEP COMP. CODE (READ ONLY)
DAPPRFPT DS    F              PNTR TO MVS PERFORMANCE GROUP
DAPDESPT DS    F              PNTR TO DEFAULT SYSOUT DESTINATION
         EJECT
*
*        OPTION SWITCHS EQUATES FOR CONTROL BITS SDV
*
CTLUFAI  EQU   X'80'          USERID ENQ FAILED
CTLRES1  EQU   X'40'          RESERVED
CTLFAIL  EQU   X'20'          RESERVED
CTLDISC  EQU   X'10'          TERMINATE THIS GUY'S LOGON
CTLNOPR  EQU   X'08'          DONT PROMPT
CTLNUAD  EQU   X'04'          NO UADS CHECKING
CTLJJCL  EQU   X'02'          LOGON JCL SUPPLIED BY EXIT
CTLRES3  EQU   X'01'          RESERVED
CTLATR1  EQU   X'80'          PSCB ATR1 INFO SUPPLIED BY EXIT
CTLATR2  EQU   X'40'          PSCB ATR2 INFO SUPPLIED BY EXIT
CTLUNIT  EQU   X'20'          GENERIC UNIT NAME SUPPLIED BY EXIT
CTLBUPT  EQU   X'10'          UPT SUPPLIED BY EXIT
CTLNONQ  EQU   X'08'          NO ENQ ON USERID
CTLDEST  EQU   X'04'          DEFAULT SYSOUT DESTINATION SUPPLIED
CTLABND  EQU   X'02'          ABENDED LOGON IS BEING RETRIED
CTLRES4  EQU   X'01'          RESERVED
*
*        A MODEL SDV (STRING DOPE VECTOR) IS DEFINED HERE:
*
SDV      DSECT
SDVPTR   DS    A              POINTER TO THE CHAR STRING ITSELF
SDVMX    DS    H              MAX # OF CHARS ALLOWED IN THE STRING
SDVCUR   DS    H              CURRENT # OF CHARS IN THE STRING
         EJECT
         SPACE 2
**********************************************************************
*        REGISTER EQUATE STATEMENTS                                  *
**********************************************************************
         SPACE 1
R0       EQU   0             WORKING     REGISTER
PRMREG   EQU   1             PARAMETER   REGISTER
MSGREG   EQU   2             PUTMSG      REGISTER
CTLREG   EQU   3             SDV         REGISTER
ECTREG   EQU   4             ECT         REGISTER
UPTREG   EQU   5             UPT         REGISTER
PARREG   EQU   6             PARSED STRG REGISTER *DO*****************
FNDREG   EQU   7             MATCH  STRG REGISTER *  NOT             *
TM1REG   EQU   8             WORKING     REGISTER *     SHUFFLE      *
TM2REG   EQU   9             WORKING     REGISTER *************THESE**
LGNREG   EQU   10            LOGON DSECT REGISTER
WRKREG   EQU   11            WORKING     REGISTER
BASREG   EQU   12            BASE        REGISTER
SAVREG   EQU   13            SAVE AREA   REGISTER
R14      EQU   14            NONWORKING  REGISTER
LNKREG   EQU   15            LINKAGE     REGISTER
         EJECT
         IKJPSCB
         EJECT
         IKJUPT
         EJECT
         IKJECT
         EJECT
         IKJPGPB
         SPACE 5
         IKJGTPB
         END
