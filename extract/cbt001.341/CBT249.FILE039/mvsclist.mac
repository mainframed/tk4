./ ADD NAME=ASMAIDS
./ NUMBER NEW1=10,INCR=10
PROC 1 MEMBER DLIB RENT PRINT                           DEBUG
IF &DEBUG EQ DEBUG THEN CONTROL MSG LIST CON SYM NOPROMPT MAIN
          ELSE CONTROL NOMSG NOCON NOSYM NOPROMPT MAIN NOLIST
SET &MODGEN = &STR( )
IF &DLIB EQ DLIB THEN SET &MODGEN = &STR('SYS1.AMODGEN')
FREE DD(SYSIN,SYSPRINT,SYSLIB,SYSPUNCH,SYSTERM,SYSUT1,SYSUT2,SYSUT3)
STATE &MEMBER..OBJ R
IF &LASTCC NE 0 THEN +
   ALLOC DA(&MEMBER..OBJ) NEW CATALOG SPACE(7,4) TRACKS DD(SYSPUNCH)
   ELSE ALLOC DA(&MEMBER..OBJ) SHR DD(SYSPUNCH)
CONTROL MSG
ALLOC DA(SERVAIDS.DATA(&MEMBER)) SHR DD(SYSIN)
IF &PRINT EQ PRINT THEN ALLOC F(SYSPRINT) SYSOUT(A)
IF &PRINT EQ PRINT THEN SET &LIST = LIST
                   ELSE SET &LIST = NOLIST
IF &RENT EQ RENT THEN SET &LIST = &LIST&STR(,RENT)
ALLOC DA('SYS1.MACLIB' &MODGEN  'USER.MACLIB') +
      SHR F(SYSLIB)
ALLOC DA(*) DD(SYSTERM)
ALLOC DD(SYSUT1) NEW DEL SPACE(1,1) CYLINDERS
ALLOC DD(SYSUT2) NEW DEL SPACE(1,1) CYLINDERS
ALLOC DD(SYSUT3) NEW DEL SPACE(1,1) CYLINDERS
CLEAR
WRITE ASSEMBLER INVOKED
XEQ IFOX00 'TERM,&LIST,DECK,NOOBJ'
SET &CC = &LASTCC
FREE DD(SYSLIB,SYSIN,SYSPUNCH,SYSUT1,SYSUT2,SYSUT3,SYSTERM)
IF &CC EQ 0 THEN GOTO CONT
IF &PRINT EQ PRINT THEN FREE F(SYSPRINT) SYSOUT(Z) NOHOLD
            GOTO CLEAN
CONT: +
IF &PRINT EQ PRINT THEN FREE F(SYSPRINT) SYSOUT(A) NOHOLD
CLEAR
LINK (&MEMBER..OBJ,*) PR(*) LIST &RENT XREF +
     LO('SYSL.PRODUCTS(&MEMBER)'/IPL)
IF &LASTCC EQ 0 THEN DEL &MEMBER..OBJ
CLEAN: +
ALLOC F(SYSPRINT) DA(*)
ALLOC F(SYSIN) DA(*)
./ ADD  NAME=ASMF
./ NUMBER NEW1=10,INCR=10
PROC 1 MEMBER RENT TEST LIST PRINT NODLIB LIB(Z)                 DEBUG
IF &DEBUG EQ DEBUG THEN CONTROL MSG LIST CON SYM NOPROMPT MAIN
                   ELSE CONTROL NOMSG NOCON NOSYM NOPROMPT MAIN NOLIST
IF &PRINT NE PRINT OR &LIST NE LIST THEN GOTO GO
     WRITE 'PRINT' IS INVALID WITH 'LIST' ... SELECT ONLY ONE OPTION
     EXIT CODE(4)
GO: SET &MODGEN = &STR('SYS1.AMODGEN')
IF &NODLIB EQ NODLIB THEN SET &MODGEN = &STR()
FREE DD(SYSIN,SYSPRINT,SYSLIB,SYSPUNCH,SYSTERM,SYSUT1,SYSUT2,SYSUT3)
CONTROL MSG
ALLOC DA(&LIB..ASM(&MEMBER)) SHR DD(SYSIN)
STATE MACLIB       R
IF &LASTCC EQ 0 THEN SET &MACLIB = MACLIB
                ELSE SET &MACLIB =
STATE &MEMBER..OBJ R
IF &LASTCC NE 0 THEN +
   ALLOC DA(&MEMBER..OBJ) NEW CATALOG SPACE(4,7) TRACKS DD(SYSPUNCH)
   ELSE  ALLOC DA(&MEMBER..OBJ) SHR DD(SYSPUNCH)
IF &LIST EQ LIST THEN DO
  STATE &MEMBER..LIST R
  IF &LASTCC NE 0 THEN +
    ALLOC DA(&MEMBER..LIST) NEW CATALOG SPACE(4,7) TRACKS DD(SYSPRINT)
    ELSE  ALLOC DA(&MEMBER..LIST) SHR DD(SYSPRINT)
  END
IF &PRINT EQ PRINT THEN ALLOC F(SYSPRINT) SYSOUT(A)
IF &PRINT EQ PRINT OR &LIST EQ LIST THEN SET &OPT = LIST
                                    ELSE SET &OPT = NOLIST
IF &RENT EQ RENT THEN SET &OPT = &OPT&STR(,RENT)
IF &TEST EQ TEST THEN SET &OPT = &OPT&STR(,TEST)
ALLOC DA('SYS1.MACLIB' &MODGEN 'USER.MACLIB' &MACLIB) SHR F(SYSLIB)
ALLOC DA(*) DD(SYSTERM)
ALLOC DD(SYSUT1) NEW DEL SPACE(5,20) TRACKS
ALLOC DD(SYSUT2) NEW DEL SPACE(5,20) TRACKS
ALLOC DD(SYSUT3) NEW DEL SPACE(5,20) TRACKS
CLEAR
WRITE ASSEMBLER INVOKED
XEQ IFOX00 'TERM,DECK,NOOBJ,&OPT'
SET &CC = &LASTCC
FREE DD(SYSLIB,SYSIN,SYSPUNCH,SYSUT1,SYSUT2,SYSUT3,SYSTERM)
IF &CC NE 0 AND &PRINT EQ PRINT THEN FREE F(SYSPRINT) SYSOUT(Z) NOHOLD
   ELSE IF &PRINT EQ PRINT OR &LIST EQ LIST THEN FREE F(SYSPRINT)
ALLOC F(SYSPRINT) DA(*)
ALLOC F(SYSIN) DA(*)
EXIT CODE(&CC)
./ ADD  NAME=ASMFCL
./ NUMBER NEW1=10,INCR=10
PROC 1 MEMBER RENT TEST LIST PRINT NODLIB LIB(Z) LOAD(Z)         DEBUG
IF &DEBUG EQ DEBUG THEN CONTROL MSG LIST CON SYM NOPROMPT MAIN
                   ELSE CONTROL NOMSG NOCON NOSYM NOPROMPT MAIN NOLIST
IF &PRINT NE PRINT OR &LIST NE LIST THEN GOTO GO
     WRITE 'PRINT' IS INVALID WITH 'LIST' ... SELECT ONLY ONE OPTION
     EXIT CODE(4)
GO: SET &MODGEN = &STR('SYS1.AMODGEN')
IF &NODLIB EQ NODLIB THEN SET &MODGEN = &STR()
IF &LOAD EQ PRODUCTS THEN SET &LOAD = &STR('SYSL.PRODUCTS')
FREE DD(SYSIN,SYSPRINT,SYSLIB,SYSPUNCH,SYSTERM,SYSUT1,SYSUT2,SYSUT3)
CONTROL MSG
ALLOC DA(&LIB..ASM(&MEMBER)) SHR DD(SYSIN)
STATE MACLIB       R
IF &LASTCC EQ 0 THEN SET &MACLIB = MACLIB
                ELSE SET &MACLIB =
STATE &MEMBER..OBJ R
IF &LASTCC NE 0 THEN +
   ALLOC DA(&MEMBER..OBJ) NEW CATALOG SPACE(4,7) TRACKS DD(SYSPUNCH)
   ELSE  ALLOC DA(&MEMBER..OBJ) SHR DD(SYSPUNCH)
IF &LIST EQ LIST THEN DO
  STATE &MEMBER..LIST R
  IF &LASTCC NE 0 THEN +
    ALLOC DA(&MEMBER..LIST) NEW CATALOG SPACE(4,7) TRACKS DD(SYSPRINT)
    ELSE  ALLOC DA(&MEMBER..LIST) SHR DD(SYSPRINT)
  END
IF &PRINT EQ PRINT THEN ALLOC F(SYSPRINT) SYSOUT(A)
IF &PRINT EQ PRINT OR &LIST EQ LIST THEN SET &OPT = LIST
                                    ELSE SET &OPT = NOLIST
IF &RENT EQ RENT THEN SET &OPT = &OPT&STR(,RENT)
IF &TEST EQ TEST THEN SET &OPT = &OPT&STR(,TEST)
ALLOC DA('SYS1.MACLIB' &MODGEN 'USER.MACLIB' &MACLIB) SHR F(SYSLIB)
ALLOC DA(*) DD(SYSTERM)
ALLOC DD(SYSUT1) NEW DEL SPACE(5,20) TRACKS
ALLOC DD(SYSUT2) NEW DEL SPACE(5,20) TRACKS
ALLOC DD(SYSUT3) NEW DEL SPACE(5,20) TRACKS
IF &DEBUG NE DEBUG THEN CLEAR
WRITE ASSEMBLER INVOKED
IF &DEBUG NE DEBUG THEN XEQ IFOX00 'TERM,DECK,NOOBJ,&OPT'
SET &CC = &LASTCC
FREE DD(SYSLIB,SYSIN,SYSPUNCH,SYSUT1,SYSUT2,SYSUT3,SYSTERM)
IF &CC NE 0 AND &PRINT EQ PRINT THEN FREE F(SYSPRINT) SYSOUT(Z) NOHOLD
   ELSE IF &PRINT EQ PRINT OR &LIST EQ LIST THEN FREE F(SYSPRINT)
IF &CC NE 0 THEN GOTO CLEAN
IF &DEBUG EQ DEBUG THEN GOTO CLEAN
CONTROL PROMPT
CLEAR
LINK (&MEMBER..OBJ,*)   PRINT(*) LIST &RENT &TEST XREF LOAD(&LOAD)
IF &LASTCC EQ 0 THEN DEL &MEMBER..OBJ
CLEAN: +
ALLOC F(SYSPRINT) DA(*)
ALLOC F(SYSIN) DA(*)
EXIT CODE(&CC)
./ ADD  NAME=ASMH
./ NUMBER NEW1=10,INCR=10
PROC 1 MEMBER RENT TEST LIST PRINT NODLIB LIB(Z)                 DEBUG
IF &DEBUG EQ DEBUG THEN CONTROL MSG LIST CON SYM NOPROMPT MAIN
                   ELSE CONTROL NOMSG NOCON NOSYM NOPROMPT MAIN NOLIST
IF &PRINT NE PRINT OR &LIST NE LIST THEN GOTO GO
     WRITE 'PRINT' IS INVALID WITH 'LIST' ... SELECT ONLY ONE OPTION
     EXIT CODE(4)
GO: SET &MODGEN = &STR('SYS1.AMODGEN')
IF &NODLIB EQ NODLIB THEN SET &MODGEN = &STR()
FREE DD(SYSIN,SYSPRINT,SYSLIB,SYSPUNCH,SYSTERM,SYSUT1)
CONTROL MSG
ALLOC DA(&LIB..ASM(&MEMBER)) SHR DD(SYSIN)
STATE MACLIB       R
IF &LASTCC EQ 0 THEN SET &MACLIB = MACLIB
                ELSE SET &MACLIB =
STATE &MEMBER..OBJ R
IF &LASTCC NE 0 THEN +
   ALLOC DA(&MEMBER..OBJ) NEW CATALOG SPACE(4,7) TRACKS DD(SYSPUNCH)
   ELSE  ALLOC DA(&MEMBER..OBJ) SHR DD(SYSPUNCH)
IF &LIST EQ LIST THEN DO
  STATE &MEMBER..LIST R
  IF &LASTCC NE 0 THEN +
    ALLOC DA(&MEMBER..LIST) NEW CATALOG SPACE(4,7) TRACKS DD(SYSPRINT)
    ELSE  ALLOC DA(&MEMBER..LIST) SHR DD(SYSPRINT)
  END
IF &PRINT EQ PRINT THEN ALLOC F(SYSPRINT) SYSOUT(A)
IF &PRINT EQ PRINT OR &LIST EQ LIST THEN SET &OPT = LIST
                                    ELSE SET &OPT = NOLIST
IF &RENT EQ RENT THEN SET &OPT = &OPT&STR(,RENT)
IF &TEST EQ TEST THEN SET &OPT = &OPT&STR(,TEST)
ALLOC DA('SYS1.MACLIB' &MODGEN 'USER.MACLIB' &MACLIB) SHR F(SYSLIB)
ALLOC DA(*) DD(SYSTERM)
ALLOC DD(SYSUT1) NEW DEL SPACE(5,20) TRACKS
CLEAR
WRITE ASSEMBLER-H INVOKED
XEQ IEV90  'TERM,DECK,NOLOAD,&OPT'
SET &CC = &LASTCC
FREE DD(SYSLIB,SYSIN,SYSPUNCH,SYSUT1,SYSTERM)
IF &CC NE 0 AND &PRINT EQ PRINT THEN FREE F(SYSPRINT) SYSOUT(Z) NOHOLD
   ELSE IF &PRINT EQ PRINT OR &LIST EQ LIST THEN FREE F(SYSPRINT)
ALLOC F(SYSPRINT) DA(*)
ALLOC F(SYSIN) DA(*)
EXIT CODE(&CC)
./ ADD  NAME=ASMHCL
./ NUMBER NEW1=10,INCR=10
PROC 1 MEMBER RENT TEST LIST PRINT NODLIB LIB(Z) LOAD(Z)         DEBUG
IF &DEBUG EQ DEBUG THEN CONTROL MSG LIST CON SYM NOPROMPT MAIN
                   ELSE CONTROL NOMSG NOCON NOSYM NOPROMPT MAIN NOLIST
IF &PRINT NE PRINT OR &LIST NE LIST THEN GOTO GO
     WRITE 'PRINT' IS INVALID WITH 'LIST' ... SELECT ONLY ONE OPTION
     EXIT CODE(4)
GO: SET &MODGEN = &STR('SYS1.AMODGEN')
IF &NODLIB EQ NODLIB THEN SET &MODGEN = &STR()
IF &LOAD EQ PRODUCTS THEN SET &LOAD = &STR('SYSL.PRODUCTS')
FREE DD(SYSIN,SYSPRINT,SYSLIB,SYSPUNCH,SYSTERM,SYSUT1)
CONTROL MSG
ALLOC DA(&LIB..ASM(&MEMBER)) SHR DD(SYSIN)
STATE MACLIB       R
IF &LASTCC EQ 0 THEN SET &MACLIB = MACLIB
                ELSE SET &MACLIB =
STATE &MEMBER..OBJ R
IF &LASTCC NE 0 THEN +
   ALLOC DA(&MEMBER..OBJ) NEW CATALOG SPACE(4,7) TRACKS DD(SYSPUNCH)
   ELSE  ALLOC DA(&MEMBER..OBJ) SHR DD(SYSPUNCH)
IF &LIST EQ LIST THEN DO
  STATE &MEMBER..LIST R
  IF &LASTCC NE 0 THEN +
    ALLOC DA(&MEMBER..LIST) NEW CATALOG SPACE(4,7) TRACKS DD(SYSPRINT)
    ELSE  ALLOC DA(&MEMBER..LIST) SHR DD(SYSPRINT)
  END
IF &PRINT EQ PRINT THEN ALLOC F(SYSPRINT) SYSOUT(A)
IF &PRINT EQ PRINT OR &LIST EQ LIST THEN SET &OPT = LIST
                                    ELSE SET &OPT = NOLIST
IF &RENT EQ RENT THEN SET &OPT = &OPT&STR(,RENT)
IF &TEST EQ TEST THEN SET &OPT = &OPT&STR(,TEST)
ALLOC DA('SYS1.MACLIB' &MODGEN 'USER.MACLIB' &MACLIB) SHR F(SYSLIB)
ALLOC DA(*) DD(SYSTERM)
ALLOC DD(SYSUT1) NEW DEL SPACE(5,20) TRACKS
IF &DEBUG NE DEBUG THEN CLEAR
WRITE ASSEMBLER-H INVOKED
IF &DEBUG NE DEBUG THEN XEQ IEV90 'TERM,DECK,NOLOAD,&OPT'
SET &CC = &LASTCC
FREE DD(SYSLIB,SYSIN,SYSPUNCH,SYSUT1,SYSTERM)
IF &CC NE 0 AND &PRINT EQ PRINT THEN FREE F(SYSPRINT) SYSOUT(Z) NOHOLD
   ELSE IF &PRINT EQ PRINT OR &LIST EQ LIST THEN FREE F(SYSPRINT)
IF &CC NE 0 THEN GOTO CLEAN
IF &DEBUG EQ DEBUG THEN GOTO CLEAN
CONTROL PROMPT
CLEAR
LINK (&MEMBER..OBJ,*)   PRINT(*) LIST &RENT &TEST XREF LOAD(&LOAD)
IF &LASTCC EQ 0 THEN DEL &MEMBER..OBJ
CLEAN: +
ALLOC F(SYSPRINT) DA(*)
ALLOC F(SYSIN) DA(*)
EXIT CODE(&CC)
./ ADD  NAME=CALC
./ NUMBER NEW1=10,INCR=10
PROC 3 P1 P2 P3
WRITE ANSWER IS: &EVAL(&P1 &P2 &P3)
./ ADD  NAME=COMPRESS
./ NUMBER NEW1=10,INCR=10
PROC 1 DSNAME LIST REL SER()                                      DEBUG
IF &DEBUG EQ DEBUG THEN CONTROL CON SYM MSG NOPROMPT LIST
                   ELSE CONTROL NOCON NOSYM NOMSG NOPROMPT NOLIST
FREE DD(SYSIN SYSPRINT SYSUT3 SYSUT4 #UT1)
CONTROL  MSG
IF &SUBSTR(1:2,&DSNAME) EQ &STR(Z.) THEN SET &REL = REL
IF &LENGTH(&SER) EQ 0 THEN ALLOC DD(#UT1) DSN(&DSNAME.) SHR &REL
   ELSE ALLOC DD(#UT1) DSN(&DSNAME.) SHR &REL UNIT(SYSALLDA) VOL(&SER)
SET &RETCODE EQ &LASTCC
IF &RETCODE NE 0 THEN GOTO EXIT
IF &LIST EQ LIST THEN ALLOC DD(SYSPRINT) DSN(*)
                ELSE ALLOC DD(SYSPRINT) DUMMY
ALLOC DD(SYSIN) NEW DEL SP(1)
XEQ PARMSIN '> C I=#UT1,O=#UT1'
ALLOC DD(SYSUT3) NEW DEL SP(5 10) TRA
ALLOC DD(SYSUT4) NEW DEL SP(5 10) TRA
CONTROL MAIN
ATTN   DO
       XEQ IEFBR14
       WRITE COMPRESS INTERRUPTED BY USER, POSSIBLE DATASET DAMAGE
       SET &RETCODE EQ 100
       RETURN
       END
IF &LIST EQ LIST THEN CLEAR
XEQ IEBCOPY
IF &RETCODE EQ 0 THEN WRITE COMPRESS RETURN CODE IS &LASTCC
                 ELSE WRITE COMPRESS RETURN CODE IS &RETCODE
ATTN  OFF
EXIT: CONTROL FLUSH
FREE  DD(SYSPRINT SYSIN SYSUT3 SYSUT4 #UT1)
ALLOC DD(SYSPRINT) DSN(*)
ALLOC DD(SYSIN) DSN(*)
EXIT  CODE(&RETCODE)
./ ADD  NAME=GV
./ NUMBER NEW1=10,INCR=10
PROC 1 SER                                                       DEBUG
IF &DEBUG EQ DEBUG THEN CONTROL MSG SYM CON LIST NOPROMPT MAIN
                   ELSE CONTROL NOMSG NOSYM NOCON NOLIST NOPROMPT MAIN
ALLOC DA('USER.VOLUME.&SER') SHR F(&SER)
IF &LASTCC EQ 0 THEN EXIT CODE(&LASTCC)
CONTROL MSG
ALLOC DA('USER.VOLUME.&SER') NE SP(0) -
      TRA UNIT(SYSALLDA) VOL(&SER) F(&SER)
EXIT CODE(&LASTCC)
./ ADD NAME=ID
./ NUMBER NEW1=10,INCR=10
PROC 0
IF &SYSUID EQ &SYSPREF THEN WRITE USERID(&SYSUID)
ELSE DO
     IF &LENGTH(&SYSPREF) EQ 0 THEN WRITE USERID(&SYSUID) NOPREFIX
                               ELSE WRITE USERID(&SYSUID) PRE(&SYSPREF)
     END
EXIT CODE(0)
./ ADD NAME=PDSGENER
./ NUMBER NEW1=10,INCR=10
PROC 2 INPUTFILE PDSDATASETNAME KEEP DEBUG
IF &KEEP EQ DEBUG THEN SET &DEBUG = DEBUG
IF &DEBUG EQ DEBUG THEN CONTROL SYM CON MSG LIST NOPROMPT
                   ELSE CONTROL NOSYM NOCON MSG NOPROMPT
SET &LEN = &LENGTH(&INPUTFILE)
SET &CNT = 2
IF &SUBSTR(1:1,&INPUTFILE) EQ &STR(.) THEN GOTO ERROR
DO WHILE &CNT LT 10
   IF &SUBSTR(&CNT:&CNT,&INPUTFILE) EQ &STR(.) THEN GOTO FOUND
   SET &CNT = &CNT + 1
   END
ERROR: WRITE &INPUTFILE IS AN INVALID NAME
EXIT CODE(100)
FOUND: SET &CNT = &CNT - 1
SET &MEMBERNAME = &SUBSTR(1:&CNT,&INPUTFILE)
WRITE MEMBER IS &MEMBERNAME
IF &DEBUG NE DEBUG THEN CONTROL NOMSG
FREE F(SYSUT1 SYSUT2)
CONTROL MSG
ALLOC F(SYSUT1) DA(&INPUTFILE) SHR
IF &LASTCC NE 0 THEN EXIT CODE(100)
ALLOC F(SYSUT2) DA('&PDSDATASETNAME(&MEMBERNAME)') SHR
IF &LASTCC NE 0 THEN EXIT CODE(100)
XEQ SYSGENER
FREE F(SYSUT1 SYSUT2)
IF &KEEP NE KEEP THEN DELETE &INPUTFILE
./ ADD  NAME=REPLY
./ NUMBER NEW1=10,INCR=10
PROC 0
OPER
D R,L
END
WRITENR AUTH CMD ---- REPLY
READ &REPLY &DATA
IF &REPLY EQ THEN EXIT CODE(0)
AUTH CMD 'REPLY &REPLY,&DATA'
./ ADD  NAME=RESET
./ NUMBER NEW1=10,INCR=10
PROC 0 JOB() PERFORM(14)                                          DEBUG
IF &DEBUG EQ DEBUG THEN CONTROL CON SYM MSG NOPROMPT LIST
                ELSE CONTROL NOCON NOSYM NOMSG NOPROMPT NOLIST
IF &LENGTH(&JOB) NE 0 THEN GOTO AUTH
DJ
WRITENR ENTER JOBNAME AND OPTIONALLY PERFORMANCE GROUP
READ &JOB &PERFORM
IF &LENGTH(&JOB) EQ 0 THEN EXIT CODE(0)
IF &LENGTH(&PERFORM) EQ 0 THEN SET &PERFORM = 14
AUTH: AUTH CMD 'E &JOB,PERFORM=&PERFORM'
EXIT CODE(0)
./ ADD  NAME=SMP
./ NUMBER NEW1=10,INCR=10
PROC 0 LOG ACDS SER(SYSRES) DEBUG LEVEL(SYS1)
IF &DEBUG NE DEBUG THEN CONTROL NOMSG NOCON NOSYM NOPROMPT
                   ELSE CONTROL MSG CON SYM NOPROMPT
FREE F(SMPLOG SMPCDS SMPMTS SMPSTS SMPPTS SMPOUT SMPCNTL SMPACDS)
CONTROL MSG
IF &LOG NE LOG THEN ALLOC F(SMPLOG) DUMMY
  ELSE ALLOC F(SMPLOG) DA('&LEVEL..SMPLOG') MOD UNIT(SYSDA) VOL(&SER)
SET &Q =
IF &SUBSTR(1:3,&LEVEL) EQ IMS THEN SET &Q = SMP
IF &ACDS EQ ACDS THEN ALLOC DA('&LEVEL..&Q.ACDS') SHR F(SMPACDS)
ALLOC DA('&LEVEL..SMPCDS') F(SMPCDS) SHR UNIT(SYSDA) VOL(&SER.)
ALLOC DA('&LEVEL..SMPMTS') F(SMPMTS) SHR UNIT(SYSDA) VOL(&SER.)
ALLOC DA('&LEVEL..SMPSTS') F(SMPSTS) SHR UNIT(SYSDA) VOL(&SER.)
ALLOC DA('&LEVEL..SMPPTS') F(SMPPTS) SHR UNIT(SYSDA) VOL(&SER.)
ALLOC F(SMPOUT) DA(*)
ALLOC F(SMPCNTL) DA(*)
XEQ HMASMP   'DATE=U,NODIS'
IF &DEBUG NE DEBUG THEN CONTROL NOMSG
FREE F(SMPLOG SMPCDS SMPMTS SMPSTS SMPPTS SMPOUT SMPCNTL SMPACDS)
./ ADD  NAME=T
./ NUMBER NEW1=10,INCR=10
PROC 0
ST
WRITENR ENTER JOB NUMBER AND NEWCLASS
READ &JOBNO &CLASS
IF &JOBNO EQ THEN EXIT CODE(0)
CONTROL LIST
AUTH CMD '$TJ&JOBNO,C=&CLASS,P=99'
./ ADD  NAME=WAIT
./ NUMBER NEW1=10,INCR=10
PROC 1 TIME                             DEBUG
IF &DEBUG EQ DEBUG THEN CONTROL SYM CON LIST
SET &COUNT = &TIME / 4
DO WHILE &COUNT GT 0
CLEAR
SET &TIME = 4 * &COUNT
SET &MIN = &TIME / 60
SET &SEC = 60 * &MIN
SET &SEC = &TIME - &SEC
WRITE
WRITE
WRITE
WRITE
WRITE
WRITE
WRITE
WRITE                   YOUR TERMINAL WILL RETURN CONTROL TO
IF &MIN EQ 0 THEN +
WRITE                         YOU IN ABOUT &TIME SECONDS
IF &SEC EQ 0 THEN +
WRITE                         YOU IN ABOUT &MIN MINUTES
IF &SEC NE 0 AND &MIN NE 0 THEN +
WRITE                   YOU IN ABOUT &MIN MINUTES AND &SEC SECONDS
WRITE
WRITE
WRITE
WRITE                      UNTIL THEN, PLEASE FEEL FREE TO
WRITE                           HAVE A CUP OF COFFEE
WRITE
WRITE
WRITE
WRITE
WRITE
WRITE
WRITE
XEQ SYSWAIT '00000300'
SET &COUNT = &COUNT - 1
END
