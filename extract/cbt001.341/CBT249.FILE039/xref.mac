         MACRO
&NAME    EDIT  &PR,&NUM,&ED
         LCLA  &A1,&A2,&A3,&A4
         LCLB  &B1,&B2
         LCLC  &C1,&C2,&C3
         ACTR  200
         AIF   (N'&SYSLIST EQ 2 AND K'&ED EQ 0).ANOP1
         AIF   (N'&SYSLIST NE 3).MNOTE1
         AIF   ('&ED'(1,1) EQ '-' OR '&ED'(1,1) EQ '$').EDMK
.ANOP1   ANOP
&A1      SETA  &A1+1
         AIF   (K'&ED LT &A1).CONT
&A2      SETA  &A2+1
&A4      SETA  &A4+1
         AIF   ('&ED'(&A1,1) NE 'Z' AND '&ED'(&A1,1) NE '&C2').NINE
.ANOP2   ANOP
&C1      SETC  '&C1.20'
         AGO   .ANOP1
.NINE    AIF   ('&ED'(&A1,1) NE '9').PER
         AIF   (&B1).ANOP2
&B1      SETB  1
         AIF   (&A1 EQ 1).SIGNIF
         AIF   (&A1 EQ 2 AND &B2).SIGNIF
&C3      SETC  '&C1'(&A4*2-3,2)
         AIF   ('&C3' NE '20').NINE2
&C1      SETC  '&C1'(1,&A4*2-4).'2120'
         AGO   .ANOP1
.NINE2   ANOP
&C1      SETC  '&C1'(1,&A4*2-6).'21&C3.20'
         AGO   .ANOP1
.SIGNIF  ANOP
&C1      SETC  '21'
         AGO   .ANOP1
.PER     AIF   ('&ED'(&A1,1) NE '.').COMMA
&C1      SETC  '&C1.4B'
&A2      SETA  &A2-1
         AGO   .ANOP1
.COMMA   AIF   ('&ED'(&A1,1) NE 'V').SLASH
&C1      SETC  '&C1.6B'
&A2      SETA  &A2-1
         AGO   .ANOP1
.SLASH   AIF   ('&ED'(&A1,1) NE '/').DBCR
&C1      SETC  '&C1.61'
&A2      SETA  &A2-1
         AGO   .ANOP1
.DBCR    AIF   (&A1+1 NE K'&ED).MNOTE2
         AIF   ('&ED'(&A1,2) NE 'CR').DB
&C1      SETC  '&C1.C3D9'
&A2      SETA  &A2-1
         AGO   .CONT
.DB      AIF   ('&ED'(&A1,2) NE 'DB').MNOTE2
&C1      SETC  '&C1.C4C2'
&A2      SETA  &A2-1
.CONT    ANOP
&C3      SETC  '&PR'
         AIF   (L'&NUM*2-1 NE &A2).EDSIZE
.ENDCHEC ANOP
&A2      SETA  0
         AIF   (K'&C1/2+1 NE L'&PR).AREASIZ
.LAST    AIF   (&B2).EDMKEND
&NAME    MVC   &C3,=X'40&C1'
         ED    &C3,&NUM
         MEXIT
.EDSIZE  AIF   (L'&NUM*2-1 LT &A2).LONG
.SHORT   ANOP
&C1      SETC  '20&C1'
&A3      SETA  &A3+1
         AIF   (L'&NUM*2-1 GT &A2+&A3).SHORT
         AGO   .ENDCHEC
.LONG    ANOP
&C1      SETC  '&C1'(3,K'&C1-2)
&A3      SETA  &A3+1
         AIF   (L'&NUM*2-1 LT &A2-&A3).LONG
         AGO   .ENDCHEC
.AREASIZ AIF   (K'&C1/2+1 LT L'&PR).LESS
&A2      SETA  K'&C1/2+1-L'&PR
&A3      SETA  K'&C1/2+1
&C3      SETC  '&C3-&A2.(&A3)'
&B1      SETB  1
         AGO   .LAST
.LESS    ANOP
&B1      SETB  0
&A3      SETA  K'&C1/2+1
         AIF   (K'&C1/2+5 GE L'&PR).PLUSET
&C3      SETC  '&C3.(&A3)'
         AGO   .LAST
.PLUSET  ANOP
&A2      SETA  L'&PR-K'&C1/2-1
&C3      SETC  '&C3+&A2.(&A3)'
         AGO   .LAST
.EDMK    AIF   ('&ED'(1,1) EQ '-').NEG
&C2      SETC  '$'
         AGO   .C2SET
.NEG     ANOP
&C2      SETC  '-'
.C2SET   ANOP
&A1      SETA  1
&B2      SETB  1
         AGO   .ANOP1
.EDMKEND ANOP
&A1      SETA  -1
.EDMKNOP ANOP
&A1      SETA  &A1+2
         AIF   (K'&C1 LT &A1).SETA
         AIF   ('&C1'(&A1,2) EQ '21').SETAA
         AIF   ('&C1'(&A1,2) NE '4B').EDMKNOP
&A1      SETA  (&A1+1)/2
         AGO   .LA
.SETA    ANOP
&A1      SETA  (&A1+1)/2-1
         AGO   .LA
.SETAA   ANOP
&A1      SETA  (&A1+1)/2+1
.LA      ANOP
         AIF   (&B1).MINUS
&A1      SETA  &A1+&A2
         AGO   .MVC
.MINUS   ANOP
&A1      SETA  &A1-&A2
.MVC     ANOP
&NAME    MVC   &C3,=X'40&C1'
         LA    1,&PR+&A1
         EDMK  &C3,&NUM
         AIF   ('&C2' EQ '$').DOLLAR
         BNM   EDIT&SYSNDX
         BCTR  1,0
         MVI   0(1),C'-'
&C3      SETC  '&SYSNDX'
EDIT&C3  EQU   *
         MEXIT
.DOLLAR  BCTR  1,0
         MVI   0(1),C'$'
         MEXIT
.MNOTE1  MNOTE 8,'THREE OPERANDS MUST BE SPECIFIED'
         MEXIT
.MNOTE2  MNOTE 8,'INVALID EDIT PATTERN'
         MEND
***********************************************************************
*
*        THE OBJECTIVE OF THIS PROGRAM IS TO READ SELECTED SYSTEM
*        LOAD LIBRARIES, SEARCHING FOR EITHER ALL OR SELECTED
*        CSECT ENTRIES (OR OPTIONALLY 'ENTRY' TYPE ENTRIES) AND
*        PROVIDE A CSECT/ENTRY TO MODULE TO LIBRARY CROSS-REFERENCE
*        REPORT.  ALSO INCLUDED IS ALL PERTINENT DATA RELETIVE TO
*        TYPE OF ENTRY (E.G. COMPILE DATE, LINK DATE, IDR DATA, ETC).
*        FOR EACH LIBRARY REQUEST, A 'SYSLIBXX' DDCARD MUST BE
*        INCLUDED IN THE EXECUTION DECK AS DEFINED BELOW.
*
*        WRITTEN  -- AUG. 1975 BY
*        MODIFIED -- JAN. 1976 BY
*
*        SOURCE FOR ALL FORMATS  AND STRUCTURE OF LOAD MODULES
*        WAS THE  I.B.M. - SYSTEMS - OS/VS LINKAGE EDITOR LOGIC
*        MANUAL  VS1 REL.1  SY26-3815-0
*
*  THE FOLLOWING IS AN EXAMPLE OF THE REQUIRED JCL FOR EXECUTION
*
*  //XREF     EXEC PGM=XREF,REGION=256K
*  //SYSPRINT DD SYSOUT=A                    <=== XREF REPORT LISTING
*  //SYSLIB01 DD DSN=USER.TESTLIB,DISP=SHR   <=== USER LIBRARIES
*  //SYSLIB02 DD DSN=USER.PRODLIB,DISP=SHR   <=== FOR THE XREF
*  //SYSLIB03 DD DSN=USER.SUBRLIB,DISP=SHR   <=== EXECUTION RUN
*  //SORTLIB  DD DSN=SYS1.SORTLIB,DISP=SHR   <=== SORT LIB
*  //SYSOUT   DD SYSOUT=A                    <=== SORT LISTING
*  //SORTIN   DD UNIT=SYSDA,SPACE=(CYL,(3,1),RLSE) <== WORK FILE
*  //SORTOUT  DD UNIT=SYSDA,SPACE=(CYL,(3,1),RLSE) <== WORK FILE
*  //SORTWK01 DD UNIT=SYSDA,SPACE=(CYL,(10))
*  //SORTWK02 DD UNIT=SYSDA,SPACE=(CYL,(10))
*  //SORTWK03 DD UNIT=SYSDA,SPACE=(CYL,(10))
*  //SORTWK04 DD UNIT=SYSDA,SPACE=(CYL,(10))
*  //SORTWK05 DD UNIT=SYSDA,SPACE=(CYL,(10))
*  //SORTWK06 DD UNIT=SYSDA,SPACE=(CYL,(10))
*  //SORTWK07 DD UNIT=SYSDA,SPACE=(CYL,(10))
*  //SORTWK08 DD UNIT=SYSDA,SPACE=(CYL,(10))
*  //SORTIN DD DSN=&&DATA,DISP=(OLD,DELETE)
*
***********************************************************************
         EJECT
*
*        OPEN FILES, PROCESS PARM INFORMATION IF ANY
*        AND BUILD PARM TABLE FOR QUALIFED RUN.
*
XREF     $PROLOG R12,R11,R10  ENTRY LINKAGE
         USING OUTREC,R8      BASE REG FOR OUTPUT TABLE
         MVC   SAVEPARM,0(R1)  SAVE ADDRESS OF PARM LIST
         OPEN  (SORTIN,(OUTPUT))  OPEN WORK SPILL FILE
         OPEN  (SYSPRINT,(OUTPUT))  OPEN OUTPUT LISTING FILE
         L     R1,16                CVT ADDR TO REG 1
         ZAP   JULDATE,57(3,R1)     MOVE DATE TO CALL AREA
         CALL  JULCAL,(JULDATE,CALDATE) CALL CONVERSION ROUTINE
         MVC   CURRDATE,PATTERN2
         ED    CURRDATE,CALDATE
         MVC   DATE,CURRDATE+2      MOVE TO HEADING LINE
         MVC   DATE2,CURRDATE+2     MOVE TO SECONDARY LINE
         PUT   SYSPRINT,HEADER1  PRINT
         PUT   SYSPRINT,HEADER2  HEADER
         PUT   SYSPRINT,HEADER3  LINES
*
*                  THIS ROUTINE CHECKS PARM LIST FOR REQUESTED
*                  MEMBERS. IF NO DATA IN PARM LIST THEN
*                  DEFAULT IS GET ALL MEMBERS OF ALL DATA SETS
*                  FIELDS CAN BE OF VARIABLE LENGTH TO ALLOW GENERIC
*                  SEARCH ON CSECT,ENTRY OR MEMBER NAMES
*
GETPARMS LA    R8,OUTTABLE    INITIALIZE WORKING POINTER
         MVI   RPTTYPE,C'C'   SET FLAG FOR CSECT REPORT
         MVC   ERRTYPE,=C' CSECTS '  SET UP ERROR LINE
         L     R5,SAVEPARM    LOAD ADDRESS OF PARM LIST INTO
         XR    R6,R6          R5 AND CLEAR R6
         ICM   R6,3,0(R5)     INSERT LENGTH OF PARMLIST
         BZ    PARMEND        NO PARM SPECIFIED, DEFAULT
         LA    R5,2(R5)       POINT TO FIRST ENTRY
         AR    R6,R5          LENGTH + START ADDR = END ADDR
         LA    R4,PARMTBLE    LOAD START OF PARM TABLE
         LR    R7,R5          LOAD 7 WITH START OF PARMS
         LA    R3,9           SET BCT FOR 1 + (MAX = 8) LOOPS
         CLI   1(R5),C'='     IS FIRST ENTRY A KEYWORD ?
         BE    SETPARMS       YES THEN FIND KEYWORD
         MVI   CSECTSW+1,X'00'  ASSUME CSECT
         MVI   MEMBSW+1,X'00'  AND MEMBER SEARCH
         B     SCANLOOP       CONTINUE
PARMLOOP CLI   1(R5),C'='     IS THIS ENTRY A NEW KEYWORD ?
         BNE   SCANLOOP       NO THEN CONTINUE ELSE
SETPARMS CLI   0(R5),C'M'     MEMBER SEARCH ?
         BE    PARMMEMB       YES GO TO MEMBER LOGIC
         CLI   0(R5),C'E'     ENTRY SEARCH ?
         BE    PARMENT        YES GO TO ENTRY LOGIC
         MVI   CSECTSW+1,X'00'  SET BRANCH TO NOP SO THAT
*                             PARM TABLE SEARCH LOGIC WILL
*                             BE EXECUTED
         B     ENDSETR5       POINT R5 TO NEXT BYTE
PARMMEMB MVI   MEMBSW+1,X'00'  SET BRANCH TO NOP SO THAT
*                             PARM TABLE SEARCH LOGIC WILL
*                             BE EXECUTED
         B     ENDSETR5       POINT R5 TO NEXT BYTE
PARMENT  MVI   CSECTSW+1,X'00'  SET BRANCH TO NOP SO THAT
*                             PARM TABLE SEARCH LOGIC WILL
*                             BE EXECUTED
         MVI   RPTTYPE,C'E'   SET FLAG FOR ENTRY REPORT
         MVC   ERRTYPE,=C' ENTRYS '  SET UP ERROR LINE
         MVI   ENTRYNOP+1,X'80'  SET ENTRY TEST FOR BE
         B     ENDSETR5       POINT R5 TO NEXT BYTE
ENDSETR5 LA    R5,2(R5)       BUMP PAST KEYWORD
         CLI   0(R5),C','     COMMA AFTER KEYWORD ?
         BNE   ENDSETR7       NO, SET R7 = R5
         LA    R5,1(R5)       YES, THEN BUMP AROUND IT
ENDSETR7 LR    R7,R5          COPY TO HOLD REG
         B     SCANLOOP       CHECK NEXT PARM
SCANLOOP CLI   0(R7),C','     CHECK FOR COMMA FIELD SEPARATOR
         BE    FIELDEND       YES THEN MOVE DATA
         LA    R7,1(R7)       BUMP TO NEXT BYTE OF PARM LIST
         CR    R7,R6          CHECK FOR END OF PARMS
         BNL   FIELDEND       YES THEN MOVE DATA
         BCT   R3,SCANLOOP    NO THEN TEST FOR MAX = 8
         MVC   ERRNAME1(9),0(R5)  MOVE FIELD TO ERROR LINE
         PUT   SYSPRINT,ERROR1  INFORM USER OF ERROR
FINDCOMA CLI   0(R7),C','     NEXT CHARACTER A 'COMMA' ?
         BE    NEXTPARM       YES, CONTINUE PARM LOOP
         LA    R7,1(R7)       NO, CHECK NEXT BYTE
         CR    R7,R6          END OF PARM LIST ?
         BL    FINDCOMA       NO, CONTINUE TO LOOK
         B     PARMEND        YES, QUIT PARM LOOP
FIELDEND LR    R1,R7          GET END OF FIELD
         SR    R1,R5          SUBTRACT START OF FIELD
         LTR   R1,R1          CHECK FOR ZERO LENGTH
         BNZ   NOTZERO        NO, CONTINUE
         LR    R1,R5          YES, RESET TO ORIG
         BCTR  R1,0           BACK OFF 2 BYTES
         BCTR  R1,0           AND PRINT 4 BYTES
         MVC   ERRNAME2(4),0(R1)  MOVE FIELD TO ERROR LINE
         PUT   SYSPRINT,ERROR2  INFORM USER OF ERROR
         B     NEXTPARM       CHECK NEXT PARM IF ANY
NOTZERO  BCTR  R1,0           SUBTRACT 1 FOR EXECUTE INSTR.
         EX    R1,MOVEPARM    MOVE VARIABLE LENGTH TO TABLE
         STC   R1,8(R4)       STORE LENGTH OF MOVE IN TABLE
         LA    R4,9(R4)       BUMP TO NEXT TABLE ENTRY
NEXTPARM LA    R7,1(R7)       BUMP PAST COMMA
         LR    R5,R7          POINT TO START OF NEXT FIELD
         CR    R5,R6          END OF PARMLIST ?
         BNL   PARMEND        NO, PROCESS NEXT BYTE
         LA    R3,9           YES, SET LOOP CONTROL
         B     PARMLOOP       PROCESS NEXT ENTRY
MOVEPARM MVC   0(0,R4),0(R5)  EXECUTED MOVE TO BUILD PARM TABLE
         EJECT
*
*               THIS ROUTINE USES AN EXTRACT MACRO TO GET
*               ADDRESS OF THE TIOT. THEN RETRIEVES FROM
*               THE TIOT THE DDNAMES USED IN THIS JOB. THE PGM
*               WILL THEN OPEN AND CLOSE EACH DDNAME UNTIL ALL
*               DATA SETS HAVE BEEN SEARCHED.
*
PARMEND  EXTRACT TIOTADDR,'S',FIELDS=(TIOT) LOCATE TIOT
         L     R5,TIOTADDR    GET ADDRESS OF TIOT
         LA    R5,24(R5)      BUMP TO FIRST DDNAME ENTRY
         B     CHECKDD        BRANCH TO CHECK 1ST ENTRY
ENDFILE  CLOSE (SYSLIB)       END OF FILE ON CURRENT LIBDIR
         CLOSE (LIBDIR)       CLOSE BOTH SYSLIB AND LIBDIR
         MVC   OUTLIB,OUTTABLE+1  LIB NAME TO OUT PUT RECORD
         EDIT  OUTTOTAL,DIRCOUNT,ZZZ99  EDIT DIRECTORY COUNT
         PUT   SYSPRINT,TOTALINE  WRITE RECORD
         AP    TOTCOUNT,DIRCOUNT  TOTAL ALL LIBRARY COUNTS
         ZAP   DIRCOUNT,=P'0'  RESET DIRCOUNT FOR NEXT DD
         L     R5,SAVEDD      RESTORE ADDRESS OF PREVIOUS DD ENTRY
         L     R6,SAVELEN     RESTORE LENGTH OF PREVIOUS DD ENTRY
LOOPDD   LA    R5,0(R6,R5)    BUMP TO NEXT DDENTRY
CHECKDD  XR    R6,R6          CLEAR DD ENTRY LENGTH REG
         ICM   R6,1,0(R5)     PICK UP LENGTH OF ENTRY
         BZ    ENDJOB         FINISHED IF ZERO
         CLC   4(6,R5),=CL6'SYSLIB'  VALID SYSLIBNN DD NAME ?
         BNE   LOOPDD         NO, BYPASS IT
         MVC   LIBDIR+40(8),4(R5)  MOVE DD NAME TO LIBDIR DCB
         MVC   SYSLIB+40(8),4(R5)  MOVE DD NAME TO SYSLIB DCB
         ST    R6,SAVELEN     SAVE LENGTH OF DD ENTRY
         ST    R5,SAVEDD      SAVE ADDRESS OF DD ENTRY
         EJECT
*
*              THIS ROUTINE WILL READ THE JFCB FOR EACH DDNAME
*              AND THEN RETRIEVE THE DSN TO INCLUDE IN THE
*              REPORT.  ONLY LOAD LIBRARIES CAN BE PROCESSED BY
*              THIS PROGRAM THEREFORE OBJ LIBS SHOULD NOT BE USED.
*
         RDJFCB  LIBDIR       RDJFCB TO OBTAIN DSN
         OPEN  (SYSLIB,(INPUT))  OPEN SYSLIB AS PDS (BPAM)
         OPEN  (LIBDIR,(INPUT))  OPEN LIBDIR (SYSLIB) DIRECTORY
GETDIR   GET   LIBDIR         READ A DIRECTORY BLOCK
         USING DRECTBLK,R2    BASE R FOR DIRECTORY DSECT
         LR    R2,R1          INITIALIZE USING TO DIR BLOCK
         ST    R2,SAVEDIR     SAVE ADDRESS OF DIR BLOCK
         XR    R6,R6          CLEAR FOR ICM
         ICM   R6,3,ACTBYTES  GET SIZE OF DIR BLOCK DATA
         SH    R6,=H'2'       ADJUST SIZE FOR COUNT BYTES
         LR    R5,R1          GET ADDRESS OF DIR BLOCK
         AR    R5,R6          GET END OF DIR BLOCK DATA ADDRESS
         ST    R5,SAVEEND     SAVE ADDRESS
*
*        THIS ROUTINE DEBLOCKS EACH DIRECTORY BLOCK AND
*        PASSES EACH DIRECTORY ENTRY TO THE MAINLINE
*
PRODIR   L     R2,SAVEDIR     RESTORE ADDRESS OF CURRENT DIR BLOCK
         C     R2,SAVEEND     CHECK FOR END OF DIRECTORY DATA
         BNL   GETDIR         YES, GET NEXT DIRECTORY BLOCK
         CLC   MEMNAME,=8X'FF'  LAST ENTRY OF LAST BLOCK ?
         BE    ENDFILE        YES, TO CLOSE ROUTINE
         XR    R6,R6          NO, CLEAR WORK REG FOR ICM
         ICM   R6,1,MEMC      PICK UP SIZE OF ENTRY
         N     R6,=F'31'      NUMBER OF HALFWORDS IN LOW 5 BITS
         SLL   R6,1           MULTIPLY NO. OF HALFWORDS BY 2
         AH    R6,=H'12'      ADD 12 BYTE PREFIX TO USER LEN.
         LR    R3,R6          SAVE SIZE FOR SSI COMPARE
MEMBSW   B     FINDTTRC       CHANGED TO NOP IF PARM REQUEST
         EJECT
*
*              THIS ROUTINE LOOKS IN PARM TABLE TO SEE IF THIS
*              MEMBER IS BEING REQUESTED.  IF  FOUND THEN MEMBFIND
*              NOP IS SET TO BYPASS CSECT SEARCH LOGIC
*
         MVI   MEMBFIND+1,X'00'  INITIALIZE SWITCH TO NOP
         LA    R7,PARMTBLE    LOAD START OF TABLE
         XR    R4,R4          CLEAR WORK REG
MEMBLOOP CLC   0(8,R7),=CL8' '  END OF TABLE ?
         BE    NOFIND         YES, NOT TO BE PROCESSED
         IC    R4,8(R7)       LOAD LENGTH OF TABLE ENTRY
         EX    R4,COMPMEMB    EX. VARIABLE COMPARE TO TABLE
         BE    FINDMEMB       FOUND, PROCESS MEMBER NAME
         LA    R7,9(R7)       NOT FOUND, BUMP TO NEXT ENTRY
         B     MEMBLOOP       CHECK NEXT ENTRY
COMPMEMB CLC   MEMNAME(0),0(R7)  EXECUTED FOR VAR. LENGTH
FINDMEMB MVI   MEMBFIND+1,X'F0'  NOP TO BR AROUND CSECT SEARCH
         B     FINDTTRC       CONTINUE DIRECTORY LOGIC
NOFIND   CLI   CSECTSW+1,X'00'  CSECT SEARCH REQUESTED ?
         BE    FINDTTRC       YES CONTINUE DIRECTORY LOGIC
         AR    R6,R2          NO THEN POINT TO NEXT ENTRY
         ST    R6,SAVEDIR     SAVE NEXT ENTRY ADDRESS
         B     ADDDIRCT       THEN BYPASS THIS MEMBER
FINDTTRC AR    R6,R2          POINT TO NEXT ENRTY
         ST    R6,SAVEDIR     SAVE ADDRESS OF ENTRY
         TM    MEMC,X'80'     IS THIS AN ALIAS ENTRY ?
         BO    PRODIR         YES, SKIP THIS ENTRY
         LA    R0,OUTTABLE+15  CLEAR AFTER LIBNAME
         LA    R14,OUTTABLE   GET ADDR OF OUTPUT TABLE
         L     R1,=A(OUTTABEN-15) GET END OF TABLE MINUS 15
         SR    R1,R14         GET SIZE OF TABLE - 15
         LA    R14,BLANK      START OF MOVE FROM FIELD
         XR    R15,R15        SET MOVE LENGTH TO ZERO
         ICM   R15,8,BLANK    INSERT PADDING CHARACTER
         MVCL  R0,R14         CLEAR OUTPUT TABLE TO BLANKS
         LA    R8,OUTTABLE    START OF OUTPUT TABLE
         MVC   LIBNAME,JFCB   MOVE DSNAME TO OUT AREA PREFIX
         LA    R15,36(R2)     POINT TO BLOCK FORMAT SSI POINTER
         TM    MEMATTR2,X'80'  BUILT BY V/S LINK EDITOR ?
         BZ    SSISKIP        NO, SKIP SSI CHECK (ASSUME)
         TM    MEMATTR2,X'10' IS  MODULE SSI INFO PRESENT ?
         BZ    SSIDONE        NO, SKIP SSI PROCESSING
SSISKIP  TM    MEMATTR,X'04'  IS MODULE SCATTER FORMAT ?
         BZ    SSIBLK         NO, BLOCK FORMAT
         LA    R15,44(R2)     YES, ADJUST TO SSI FOR SCTR FORMAT
         CH    R3,=H'46'      DOES SSI EXIST ?
         BL    SSIDONE        NO, IGNORE IT
         B     MOVESSI        ELSE, MOVE IT
SSIBLK   CH    R3,=H'38'      DOES SSI EXIST ?
         BL    SSIDONE        NO IGNORE IT
MOVESSI  MVC   LKEDSSI,0(R15)  MOVE SSI INFO INTO OUTREC
SSIDONE  MVI   MEMC,X'00'     CLEAR CONTROL BYTE PRIOR TO READ
         FIND  SYSLIB,MEMTTR,C  POINT TO REL TRK ADD OF MODULE
         MVC   LINEID,=X'FFFF'  SET END OF TABLE MARKER
         MVC   MODNAME,MEMNAME  MOVE MEMBER NAME TO WORK RECORD
         MVC   MODATTR,MEMATTR  ATTRIBUTE BYTES TO WORK RECORD
         MVC   MODLEN,MEMLEN  LENGTH TO OUT AREA
         EJECT
*
*        THIS ROUTINE READS EACH LOAD MODULE CESD AND IDR
*        RECORD AND EXTRACTS INFORMATION FOR THE WORK FILE
*        TO BE SORTED AND REPORTED ON LATER.
*
LOADMOD  CLC   MODLEN,=X'000000'  IF ZERO LENGTH,
         BE    ADDDIRCT       THEN BYPASS MODULE
         ZAP   CESDTOT,=P'0'  CLEAR CEST COUNT FIELD
         ST    R8,SAVEOUT     SAVE NEXT OUTPUT TABLE LINE ADDR
READBPAM READ  BPAMDECB,SF,SYSLIB,AREA,256 READ MODULE RECORD
         CHECK BPAMDECB       INSURE GOOD READ
AFTERCK  EQU   *              IDR TRAN. ROUTINE RETURNS HERE AFTER
*                                  READ AHEAD
**             TEST FOR TYPE OF LOAD MODULE RECORD
         TM    AREA,X'40'     IS THIS A 'SYM' RECORD ?
         BO    READBPAM       YES, IGNORE IT
         TM    AREA,X'10'     IS THIS A 'SCTR' RECORD ?
         BO    READBPAM       YES, IGNORE IT
         CLI   AREA,X'20'     IS THIS A 'CESD' RECORD ?
         BE    PROCESD        YES, PROCESS CESD RECORD
         CLI   AREA,X'80'     IS THIS A 'IDR' RECORD ?
         BE    PROIDR         YES, PROCESS IDR RECORD
*
*        THIS ROUTINE WRITES THE CREATED TABLE ENTRIES TO THE
*        WORK FILE FOR LATER SORTING.  WHEN THE TABLE HAS BEEN
*        WRITTEN, ANOTHER MODULE WILL BE PROCESSED.
*
ENDMOD   LA    R8,OUTTABLE    START OF OUTPUT TABLE
OUTLOOP  CLC   LINEID,=X'FFFF'  END OF TABLE ENTRIES ?
         BE    ADDDIRCT       YES, ALL DONE
         PUT   SORTIN,0(R8)   NO, WRITE OUT RECORD
         MVC   PREFIX+132,PREFIX  MOVE RECORD PREFIX TO NEXT ENTRY
         LA    R8,132(R8)     BUMP TO NEXT ENTRY IN TABLE
         B     OUTLOOP        CHECK NEXT ENTRY
ADDDIRCT AP    DIRCOUNT,=P'1'  SUM UP NO OF DIRECTORY MEMBERS
         B     PRODIR         GET NEXT ENTRY
         EJECT
*
*        THIS ROUTINE INTERPRETS A CESD RECORD, AND DEBLOCKS
*        EACH ESD ENTRY WITHIN IT.
*
         USING CESDBLK,R2     INFORM ASSEMBLER OF BASE
PROCESD  L     R8,SAVEOUT     LOAD NEXT OUTPUT TABLE LINE ADDR
         LA    R2,AREA        POINT DSECT REGTO RECORD
         LR    R5,R2          LOAD START ADDRESS INTO R5
         XR    R6,R6          CLEAR R 6
         ICM   R6,3,CESDLEN   LENGHT OF DATA INTO R6
         AR    R5,R6          POINT TO END OF DATA
         XR    R4,R4          CLEAR R4
         ICM   R4,3,CSECTID   LINE-ID OF 1ST. ENTRY
*
*        THIS SECTION WILL SELECT ONLY CSECT OR ENTRY RECORDS AS
*        BASED ON PARM SECTION LOGIC. IF ENTRY REPORT THEN
*        ENTRY NOP WILL BE SET TO BNE TO BYPASS ALL BUT ENTRY
*        RECORDS. IF CSECT REPORT THEN TEST WILL FALL INTO CSECT
*        RECORD TEST.
*
CESDLOOP CR    R2,R5          DSECT = END OF DATA
         BNL   CESDEND        YES TO END ROUTINE
         CLI   CESDTYPE,X'03'  SUB TYPE OF CESD ENTRY
ENTRYNOP NOP   ENTRY          SET TO BE  FOR ENTRY ONLY REPORT
         TM    CESDTYPE,X'0F'  SUB TYPE OF CESD ENTRY
         BNZ   NEXTCESD       ONLY CSECT RECORDS CONSIDERED
         B     SUBCHECK       CHECK SUBROUTINE LOGIC
ENTRY    MVC   CESDCSLN,=X'000000'  CLEAR LENGTH IF ENTRY RECORD
SUBCHECK EQU   *              BYPASS SYSTEM SUBROUTINES
         CLC   CESDNAME(3),=C'IHE'  IF PL1 SUB-ROUTINES
         BE    NEXTCESD       THEN BYPASS
         CLC   CESDNAME(3),=C'IBM'  IF PL1 SUB-ROUTINES
         BE    NEXTCESD       THEN BYPASS
         CLC   CESDNAME(3),=C'ILB'  IF ANSI COBOL SUBROUTINES
         BE    NEXTCESD       THEN BYPASS
         CLC   CESDNAME(3),=C'IHD'  COBOL-F SUBROUTINES
         BE    NEXTCESD       THEN BYPASS
         CLC   CESDNAME(3),=C'IKL'  COBOL F TO ANSI CONV. PROGRAM
         BE    NEXTCESD       THEN BYPASS
         CLC   CESDNAME(3),=C'IEC'  BTAM SOUBROUTINES
         BE    NEXTCESD       THEN BYPASS
         CLC   CESDNAME(3),=C'IED'  TCAM SOUBROUTINES
         BE    NEXTCESD       THEN BYPASS
         CLC   CESDNAME(3),=C'IHC'  IF FORTRAN SUB-ROUTINES
         BE    NEXTCESD       THEN BYPASS
         CLC   CESDNAME(3),=C'IHK'  IF REMOTE JOB ENTRY ROUTINES
         BE    NEXTCESD       THEN BYPASS
         CLC   CESDNAME(3),=C'DKB'  UNKNOWN IBM SUBROUTINES
         BE    NEXTCESD       THEN BYPASS
         EJECT
*
*        THIS ROUTINE LOOKS IN PARM TABLE TO SEE IF CSECT IN CESD
*        RECORD IN ONE OF THE REQUESTED ONES. IF NOT FOUND THEN
*        NEXT CESD ENTRY IS CONSIDERED. IF NO PARM LIST THEN THIS
*        CODE IS NOT EXECUTED.
*
CSECTSW  B     MOVENAME       CHANGED TO NOP IF PARM REQUEST
MEMBFIND NOP   MOVENAME
*
*              IF MEMBER SEARCH ARGRUMENT IN PARM LIST IS FOUND
*              THEN NOP IS SET TO BRANCH AROUND CSECT SEARCH
*              ROUTINE.  RESET TO NOP AT NEXT MEMBER
*
         LA    R7,PARMTBLE    START OF PARM TABLE
         XR    R6,R6          CLEAR R
SEARCH   CLC   0(8,R7),=CL8' '  CHECK FOR END OF TABLE
         BE    ENDPARMS       YES THEN DONE
         IC    R6,8(R7)       LOAD LENGTH OF FIELD IN TABLE
         EX    R6,COMPNAME    EX. VARIABLE COMPARE TO TABLE
         BE    MOVENAME       YES THEN GO TO MOVE
         LA    R7,9(R7)       BUMP TO NEXT TABLE ENTRY
         B     SEARCH
COMPNAME CLC   CESDNAME(0),0(R7)  EXECUTED FOR VAR. LENGTH
MOVENAME MVC   CSECLEN,CESDCSLN  CSECT LENGTH TO OUT AREA
         MVC   CSECNAME,CESDNAME  CSECT NAME TO OUT AREA
         STCM  R4,3,LINEID    STORE LINE-1D INTO OUT TABLE
         LA    R8,132(R8)     BUMP TO NEXT TABLE ENTRY
         AP    CESDTOT,=P'1'
ENDPARMS EQU   *
NEXTCESD LA    R2,16(R2)      NO THEN BUMP TO NEXT ENTRY
         AH    R4,=H'1'       ADD ONE FOR EACH ENTRY IN BLOCK
         L     R1,=A(OUTTABEN)  GET END OF OUTPUT TABLE
         CR    R8,R1          CHECK IF STILL WITHIN TABLE
         BL    CESDLOOP       LOW, STILL WITHIN TABLE, CONTINUE
ERRORMSG LA    R8,OUTTABLE    POINT TO START OF OUTPUT TABLE
         MVC   ERRLIB,LIBNAME  LIB NAME TO OUT PUT RECORD
         MVC   ERRMEMB,MODNAME  MODULE NAME TO OUTPUT RECORD
         EDIT  ERRTOTAL,CESDTOT,Z99
         MVC   ERRMESG,=C'OUTPUT TABLE FULL NOTIFY SYSTEMS PERSONNEL'
         PUT   SYSPRINT,ERROR3
         MVC   ERRMESG,=42C' '
         MVC   LINEID,=X'FFFF'  MARK END OF TABLE ENTRIES
         B     ENDMOD         GO TO END OF MODULE ROUTINE
CESDEND  MVC   LINEID,=X'FFFF'  MARK END OF TABLE ENTRIES
         ST    R8,SAVEOUT     SAVE NEXT OUTPUT ENTRY ADDRESS
         B     READBPAM       READ NEXT LOAD MODULE RECORD
         DROP  R2             DROP DSECT REG
         EJECT
*
*        THIS ROUTINE PROCESSES IDR RECORDS.  EACH IDR RECORD
*        READ IS TESTED TO DETERMINE TYPE AND THE APPROPRIATE
*        ROUTINE IS ENTERED FOR PROCESSING.
*
         USING IDRBLK,R2      BASE R FOR IDR DSECT
PROIDR   LA    R2,AREA        LOAD DSECT REG
         TM    IDRSUB,X'01'   ZAP RECORD
         BO    PROZAP         TO IMASPZAP ROUTINE
         TM    IDRSUB,X'02'   LINK EDIT RECORD
         BO    PROLINK        LINK-EDITOR ROUTINE
         TM    IDRSUB,X'04'   LANGUAGE TRANSLATOR RECORD
         BO    PROTRAN        LANGUAGE TRANSLATOR ROUTINE
         TM    IDRSUB,X'08'   IDENTIFY RECORD
         BO    PROIDENT       IDENTIFY ROUTINE
         TM    IDRSUB,X'80'   LAST IDR RECORD IN MEMBER
         BO    ENDMOD         GO TO END OF MODULE ROUTINE
         B     READBPAM       READ NEXT LOAD MODULE RECORD
         DROP  R2             DROP DSECT REG
         SPACE 3
*
*        THIS ROUTINE PROCESSES SUPERZAP IDR RECORDS
*
         USING IDRBLK,R2      BASE R FOR IDR DSECT
PROZAP   LA    R2,AREA        LOAD DSECT REG
         TM    PZAPCNT,X'3F'  DOES COUNT = 0
         BZ    NOPZAP         YES THEN GO TO END OF ROUTINE
         XR    R5,R5          YES THEN CLEAR R
         ICM   R5,1,PZAPCNT   NO. OF ENTRIES IN LOW 6 BITS
         N     R5,=F'63'      CLEAR 26 HIGH ORDER BITS
         LA    R8,OUTTABLE    START OF OUT PUT TABLE
PZAPLOOP CLC   LINEID,=X'FFFF'  END OF TABLE ENTRIES
         BE    PLOOPEND       YES THEN EXIT ROUTINE
         CLC   LINEID,PZAPID  IF SAME LINE NO.
         BE    MOVEPZAP       MOVE DATA TO OUTPUT TABLE
         BH    PLOOPEND       IF NO FIND SKIP REST OF TABLE
***                                    CAN OCCUR IF PARM OPTION IS USED
         LA    R8,132(R8)     ELSE, BUMP TO NEXT TABLE ENTRY
         B     PZAPLOOP       TO NEXT TABLE CHECK
NEXTPZAP LA    R2,13(R2)      BUMP TO NEXT ENTRY IN RECORD
         LA    R8,OUTTABLE    RESET TO START OF TABLE
         B     PZAPLOOP       TO SEARCH TABLE ROUTINE
MOVEPZAP CLC   ZAPREC(3),=CL3' ' ZAP DATE ALREADY THERE ?
         BNE   ZAPEXT         YES, EXTEND CSECT ENTRY
         CLC   IDENDATE(3),=CL3' ' IDENT DATE ALREADY THERE ?
         BE    MOVEZAPD       NO, MOVE IN ZAP DATE AND DATA
ZAPEXT   LR    R15,R8         SAVE CURRENT ENTRY POINTER
         LA    R8,OUTTABLE    INITIALIZE TO START OF TABLE
PZAPEXT  CLC   LINEID,=X'FFFF' END OF TABLE FLAG ENTRY ?
         BE    NULLFND        YES, BUILD NEW ENTRY
         LA    R8,132(R8)     BUMP TO NEXT ENTRY
         B     PZAPEXT        CHECK NEXT ENTRY
NULLFND  L     R1,=A(OUTTABEN) GET END OF TABLE PTR
         CR    R8,R1          STILL WITHIN TABLE ?
         BNL   ERRORMSG       NO, ISSUE ERROR MESSAGE
         MVC   0(132,R8),0(R15) COPY CSECT ENTRY
         MVC   IDENREC,=CL44' ' CLEAR FOR POSSIBLE LINK IDR
         MVC   LINEID+132,=X'FFFF' FLAG LAST ENTRY
         AP    CESDTOT,=P'1'  BUMP CESD COUNT (ARTIFICIAL)
MOVEZAPD MVC   ZAPREC,PZAPDATE  MOVE ZAP DATA TO OUTPUT TABLE
         CLC   ZAPDATA,=C'NO IDENT' NULL IDR DATA ?
         BNE   PLOOPEND       NO, LEAVE AS IS
         MVC   ZAPDATA,=CL8' ' YES, CLEAR NULL ENTRY FOR IDENT
PLOOPEND BCT   R5,NEXTPZAP    SUBTRACT 1 FROM ENTRY COUNT
NOPZAP   LA    R2,AREA        RELOAD START ADD FOR CHECK IF
         TM    IDRSUB,X'80'   LAST IDR RECORD IN MEMBER
         BO    ENDMOD         GO TO END OF MODULE ROUTINE
         B     READBPAM       READ NEXT LOAD MODULE RECORD
         DROP  R2             DROP DSECT REG
         EJECT
*
*        THIS ROUTINE PROCESSES LINKAGE EDITOR IDR RECORDS
*
         USING IDRBLK,R2      BASE R FOR IDR DSECT
PROLINK  LA    R2,AREA        LOAD DSECT REG
         LA    R8,OUTTABLE    START OF OUTPUT TABLE
         MVC   LKEDDATE,LINKDATE  MOVE LINK EDIT DATE TO OUTREC
         TM    IDRSUB,X'80'   LAST IDR RECORD IN MEMBER
         BO    ENDMOD         GO TO END OF MODULE ROUTINE
         B     READBPAM       READ NEXT LOAD MODULE RECORD
         DROP  R2             DROP DSECT REG
         EJECT
*
*        THIS ROUTINE PROCESSES COMPILER IDR RECORDS
*
         USING IDRBLK,R2      BASE R FOR IDR DSECT
PROTRAN  LA    R2,AREA        LOAD DSECT REG
         MVC   TM+1(1),IDRSUB  USE CURRENT IDRSUB FOR MASK
         BAL   R7,BUILDREC    BUILD COMBINED RECORD
         LA    R2,WORKAREA-3  POINT DSECT REGTO WORK AREA
***                                    MINUS 3 FOR 3 BYTE PREFIX
         L     R6,WORKADDR    LOAD ENDING ADDRESS IN WORK
         SH    R6,=H'3'       ADJ END FOR 3 BYTE START OFFSET
         XR    R7,R7          CLEAR CTR R
*
*       IF 2 OR MORE CSECT WERE COMPILED ON THE SAME DAY
*       BY THE SAME TRANSLATOR THEN A LIST OF CSECT
*       LINE-IDS IS BUILT IN FRONT OF THE DATA ENTRY
*       EACH ENTRY CONSIST OF A 2 BYTE LINE-ID FIELD
*       WITH THE HIGH ORDER BIT OF THE LAST ENTRY
*       SET TO 1
*
LISTLOOP LA    R7,1(R7)       ADD TO CNTR AT EACH PASS
         TM    TRANID,X'80'   CHECK FOR END OF LIST
         BO    ENDLIST        YES THEN CHECK TABLE
         LA    R2,2(R2)       BUMP TO NEXT LIST ENTRY
         B     LISTLOOP
ENDLIST  EQU   *              FIND CSECT IN TABLE FOR LAST ENTRY IN
*                                  LIST
***                THEN BACK OUT THROUGH LIST AND MOVE DATA TO TABLE
         NI    TRANID,X'7F'   CLEAR FLAG BIT
         MVC   HOLDTRAN,TRANNAME  MOVE TO HOLD AREA
         LR    R3,R2          SAVE POINTER TO LAST ENTRY
         LA    R8,OUTTABLE    START OF OUT PUT TABLE
TRANLOOP EQU   *
         CLC   LINEID,=X'FFFF'  END OF TABLE ENTRIES
         BE    TLOOPEND       YES THEN EXIT ROUTINE
         CLC   LINEID,TRANID  HIT IN TABLE
         BNE   TRANBUMP       NO, BUMP TO NEXT ENTRY
         MVC   TRANREC,HOLDTRAN YES, MOVE TO CSECT ENTRY
TRANBUMP LA    R8,132(R8)     ELSE, BUMP TO NEXT TABLE ENTRY
         B     TRANLOOP       TO NEXT TABLE CHECK
TLOOPEND EQU   *
         BCT   R7,NEXTLIST    DECREMENT CTR
         B     LISTEND        BR IF END OF LIST
NEXTLIST EQU   *
         SH    R2,=H'2'       BACK UP BY 1 LIST ENTRY
         CLC   LINEID,TRANID  CHECK POSITION IN TABLE
         BNH   TRANLOOP       RESTART SEARCH AT SAME ENTRY
         LA    R8,OUTTABLE    ELSE RESET TO START OF TABLE
         B     TRANLOOP       TO SEARCH TABLE ROUTINE
LISTEND  EQU   *
         LR    R2,R3          POINT TO LAST ENTRY IN LIST
         CLI   TRANIND,X'00'  CHECK FOR 1 OR 2 RECORDS
         BE    ONERECD
         LA    R2,15(R2)      BUMP FOR LENGTH OF 2ND RECD
ONERECD  LA    R2,18(R2)      BUMP FOR LENGTH OF 1ST RECD
***                                    PLUS 2 BYTES FOR ID PREFIX
         CR    R2,R6          END OF ENTRIES
         BNL   ENDTRAN        YES THEN GO TO END OF ROUTINE
         XR    R7,R7          CLEAR CTR R
         B     LISTLOOP       PROCESS NEXT IDR ENTRY
ENDTRAN  EQU   *
         LA    R2,AREA        RELOAD START ADDRESS
         B     AFTERCK        RETURN TO AFTER CHECK
         DROP  R2             DROP DSECT REG
         EJECT
*
*        THIS ROUTINE PROCESSES USER IDENTIFY IDR RECORDS
*
         USING IDRBLK,R2      BASE R FOR IDR DSECT
PROIDENT LA    R2,AREA        LOAD DSECT REG
         MVC   TM+1(1),IDRSUB  USE CURRENT IDRSUB FOR MASK
         BAL   R7,BUILDREC    BUILD COMBINED RECORD
         LA    R2,WORKAREA-3  POINT DSECT REGTO WORK AREA
***                                    MINUS 3 FOR 3 BYTE PREFIX
         L     R7,WORKADDR    LOAD ENDING ADDRESS IN WORK
         SH    R7,=H'3'       ADJ END FOR 3 BYTE START OFFSET
         LA    R8,OUTTABLE    START OF OUT PUT TABLE
LOOPLIST EQU   *
         XR    R6,R6          CLEAR R 6
         ICM   R6,1,IDENTCNT  LOAD LENGTH OF USER DATA
         LA    R6,4(R6)       ADD 4 FOR DATE ,COUNT FIELDS
IDENLOOP EQU   *
         CLC   LINEID,=X'FFFF'  END OF TABLE ENTRIES ?
         BE    ILOOPEND       YES THEN EXIT ROUTINE
         CLC   LINEID,IDENTID  IF SAME LINE NO.
         BE    MOVEIDEN       MOVE DATA TO OUTPUT TABLE
         BH    ILOOPEND       IF NO FIND SKIP REST OF TABLE
***                                    CAN OCCUR IF PARM OPTION IS USED
         LA    R8,132(R8)     ELSE, BUMP TO NEXT TABLE ENTRY
         B     IDENLOOP       TO NEXT TABLE CHECK
MOVEIDEN CLC   ZAPDATA(8),=CL8' ' HAS IDR DATA BEEN USED BY ZAP
         BE    IDENTGO        NO, MOVE IT IN
         LR    R15,R8         SAVE CURRENT ENTRY POINTER
         LA    R8,OUTTABLE    INITIALIZE TO START OF TABLE
IDREXTL  CLC   LINEID,=X'FFFF' END OF TABLE FLAG ENTRY ?
         BE    INULLFND       YES, BUILD NEW ENTRY
         LA    R8,132(R8)     BUMP TO NEXT ENTRY
         B     IDREXTL        CHECK NEXT ENTRY
INULLFND L     R1,=A(OUTTABEN) GET END OF TABLE PTR
         CR    R8,R1          STILL WITHIN TABLE ?
         BNL   ERRORMSG       NO, ISSUE ERROR MESSAGE
         MVC   0(132,R8),0(R15) COPY CSECT ENTRY
         MVC   ZAPREC,=CL11' ' CLEAR FOR POSSIBLE ZAP IDR
         MVC   LINEID+132,=X'FFFF' FLAG LAST ENTRY
         AP    CESDTOT,=P'1'  BUMP CESD COUNT (ARTIFICIAL)
IDENTGO  BCTR  R6,0           SUBTRACT 1 FOR EXECUTE INST.
         EX    R6,IDENMOVE    MOVE TO OUTPUT TABLE
         LA    R6,1(R6)       ADD BACK 1 FOR EXEC INST
ILOOPEND EQU   *
         LA    R6,2(R6)       ADD 2 FOR ID FIELD
         AR    R2,R6          BUMP TO NEXT ENTRY
         CR    R2,R7          AT END ?
         BNL   IDENDONE       YES THEN EXIT ROUTINE ELSE
         CLC   LINEID,TRANID  CHECK POSITION IN TABLE
         BNH   LOOPLIST       RESTART SEARCH AT SAME ENTRY
         LA    R8,OUTTABLE    ELSE RESET TO START OF TABLE
         B     LOOPLIST       TO SEARCH ROUTINE
IDENDONE EQU   *
         LA    R2,AREA        POINT TO READ AHEAD RECD
         B     AFTERCK        RETURN TO AFTER CHECK
IDENMOVE MVC   IDENREC(0),IDENTREC
         DROP  R2             DROP DSECT REG
BUILDREC EQU   *
***      TRANSLATOR & IDENTIFY RECORDS CAN OVERFLOW TO NEXT RECORD  ***
***      THEREFORE THIS ROUTINE WILL READ AS MANY RECORDS IT TAKES  ***
***      TO BUILD A COMPLETE RECORD WHICH WILL BE PROCESSED AS ONE  ***
***      UNIQUE RECORD. THIS WILL ENTAIL A READ AHEAD UNTIL         ***
***      A NON IDR RECORD OF THIS TYPE IS ENCOUNTERED. THEREFORE    ***
***      THE RETURN FROM THIS ROUTINE WILL BE TO THE LOGIC AFTER    ***
***      THE PRIMARY BPAMREAD INSTRUCTION                           ***
         USING IDRBLK,R2      BASE R FOR IDR DSECT
         LA    R2,AREA        LOAD DSECT REG
         LA    R4,WORKAREA    START OF TRANSLATOR WORK AREA
         ST    R4,WORKADDR    SAVE ADDRESS IN WORK AREA
MOVEDATA EQU   *
         XR    R6,R6          CLEAR
         ICM   R6,1,IDRLEN    NO OF BYTES INCLUDING COUNT BYTE
         BCTR  R6,0           SUBTRACT 1 FOR COUNT BYTE
         BCTR  R6,0           SUBTRACT 1 FOR SUB-TYPE BYTE
         BCTR  R6,0           SUBTRACT 1 FOR EXECUTE INST
         L     R4,WORKADDR    LOAD NEXT ADDRESS IN WORK AREA
         EX    R6,MOVERECD    EXECUTE MOVE INSTR
         LA    R6,1(R6)       ADD BACK 1 BYTE FROM EXECUTE
         AR    R4,R6          POINT PAST MOVED DATA
         ST    R4,WORKADDR    STORE NEXT ADDRESS IN WORK AREA
         READ  WORKDECB,SF,SYSLIB,AREA,256
         CHECK WORKDECB
         C     R6,=X'000000FD'  WAS LENGTH = 253 BYTES
         BLR   R7             IF THEN DONE WITH MOVES
         CLI   IDRID,X'80'    IS NEXT RECORD AN IDR RECORD
         BNER  R7             NO THEN DONE WITH MOVES
TM       TM    IDRSUB,X'00'   THE MASK FOR THIS INSTRUCTION IS
*                                      SUPPLIED AT EXECUTION TIME BY
*                                      INSERTING THE IDRSUB TYPE FROM
*                                      PREVIOUS IDR READ.
         BNOR  R7             IF SUBTYPE NOT = THEN DONE
         B     MOVEDATA
MOVERECD MVC   0(0,R4),IDRREC  MOVE VAR RECORD TO NEXT SPACES
         DROP  R2             DROP DSECT REG
         B     GETPARMS       TO PARAMATER LOGIC
ENDJOB   EQU   *
         MVC   OUTLIB(24),=CL24'ALL LIBRARIES   HAVE '
         MVC   ENDLIB(5),=CL5' ' CLEAR 'LIB =' FIELD
         EDIT  OUTTOTAL,TOTCOUNT,ZZZ99
         PUT   SYSPRINT,TOTALINE
         CLOSE (SORTIN)      CLOSE OUTPUT FILE
         FREEPOOL SORTIN      FREE DYNAMIC I/O BUFFERS
         OPEN (SORTOUT,(OUTPUT)) PROVIDE DCB INFO FOR SORT
         CLOSE (SORTOUT)      CLOSE SORTOUT DCB
         FREEPOOL SORTOUT     FREE DYNAMIC I/O BUFFERS
*
*        SORT THE JUST BUILT SORTIN FILE VIA 'SORT' LINK
*
         LA    R1,SORTPARM    SET PARM POINTER FOR SORT
         LINK  EP=SORT        LINK TO SORT
         LTR   R15,R15        CHECK SORT RETURN CODE
         BZ    SORT1OK        ZERO RETURN, CONTINUE
         WTO   'XREF - NON-ZERO SORT RETURN CODE',ROUTCDE=11
         B     EXIT           RETURN TO THE SYSTEM
SORT1OK  OPEN  (SORTOUT,(INPUT)) OPEN SORTED RECORDS FILE
         LA    R8,OUTTABLE    INITIALIZE BUFFER POINTER
         MVC   OUTLINE,BLANKS  CLEAR OUTPUT BUFFER
         ZAP   LINECNT,=P'60'  INITIALIZE LINE COUNT
         GET   SORTOUT,OUTREC  GET 1ST RECD FOR REPORT TEST
         CLI   RPTTYPE,C'C'   IF CSECT SET UP CSECT HEADINGS
         BNE   ENTRYPT        NOT CSECT, SKIP SET UP
*        IF CSECT REPORT SET UP HEADING LINES TO
*                                  PRINT CSECT
         MVC   RPTHEAD1,=C'CSECT'
         MVC   HEAD2(15),=C'-CSECT    CSECT'
         B     LINETEST
ENTRYPT  EQU   *              IF ENTRY REPORT SET UP HEADING LINES TO
*                                  PRINT ENTRY
         MVC   RPTHEAD1,=C'ENTRY'
         MVC   HEAD2(15),=C'-ENTRY    ENTRY'
         B     LINETEST
GETREC   GET   SORTOUT,OUTREC
LINETEST CP    LINECNT,=P'52'  BOTTOM OF PAGE ?
         BL    NOHEAD         NO THEN PRINT
         AP    PAGECNT,=P'1'
         EDIT  PAGENO,PAGECNT,ZZZZ9
         PUT   SYSPRINT,HEAD1   ELSE PRINT HEADING LINES
         PUT   SYSPRINT,HEAD1B
         PUT   SYSPRINT,HEAD2
         PUT   SYSPRINT,HEAD3
         MVI   OUTLINE,C'-'
         ZAP   LINECNT,=P'6'
         MVC   SAVEKEY,=CL11' '  CLEAR KEY FIELD
         MVC   SAVELIB,=CL15' '
NOHEAD   EQU   *
         CLC   SAVEKEY,CSECKEY  SAME CSECT AND LENGTH ?
         MVC   SAVEKEY,CSECKEY  MOVE NEW TO OLD
         BE    SAMEKEY        YES THEN BYPASS MOVES
         MVC   OUTCSECT,CSECNAME
         MVI   OUTCCC,C'0'    SKIP 2 LINES
         AP    LINECNT,=P'1'  ADD 1 FOR EXTRA LINE
         UNPK  OUTCSLEN(7),CSECLEN(4) UNPACK FOR PRINT
         TR    OUTCSLEN(6),TBL-240 CONVERT TO PRINTABLE
         MVI   OUTCSLEN+6,C' ' CLEAR EXTRA CHARACTER
SAMEKEY  EQU   *
         CLC   TRNDATE,=C'   '  ANY DATE PASSED ?
         BE    NOTRAN         NO THEN BYPASS MOVES
         TRT   TRNDATE,TRTTBL
         BC    12,NOTRAN
         LA    1,1
         NR    1,2
         BC    7,NOTRAN
         OI    TRNDATE+2,X'0F'
         ZAP   JULDATE,TRNDATE  MOVE TO CALL AREA
         CALL  JULCAL,(JULDATE,CALDATE)  CALL CONVERSION ROUTINE
         MVC   WORKDATE,PATTERN
         ED    WORKDATE,CALDATE
         MVC   DATECOMP,WORKDATE+2  MOVE TO OUTPUT LINE
NOTRAN   EQU   *
         CLC   ZAPDATE,=C'   '  ANY DATE PASSED ?
         BE    NOZAP          NO THEN BYPASS MOVES
         TRT   ZAPDATE,TRTTBL
         BC    12,NOZAP
         LA    1,1
         NR    1,2
         BC    7,NOZAP
         ZAP   JULDATE,ZAPDATE  MOVE TO CALL AREA
         CALL  JULCAL,(JULDATE,CALDATE)  CALL CONVERSION ROUTINE
         MVC   WORKDATE,PATTERN
         ED    WORKDATE,CALDATE
         MVC   OZAPDATE,WORKDATE+2  MOVE TO OUTPUT LINE
         CLC   ZAPDATA,=C'NO IDENT'  NO MESSAGE MESSAGE ?
         BE    NOZAP          YES THEN DO NOT PRINT
         MVC   OUTMESG(8),ZAPDATA  MOVE DATA TO PRINT LINE
NOZAP    EQU   *
         CLC   IDENDATE,=C'   '  ANY DATE PASSED ?
         BE    NOIDEN         NO THEN BYPASS MOVES
         TRT   IDENDATE,TRTTBL
         BC    12,NOIDEN
         LA    1,1
         NR    1,2
         BC    7,NOIDEN
         ZAP   JULDATE,IDENDATE  MOVE TO CALL AREA
         CALL  JULCAL,(JULDATE,CALDATE)  CALL CONVERSION ROUTINE
         MVC   WORKDATE,PATTERN
         ED    WORKDATE,CALDATE
         MVC   OIDENDTE,WORKDATE+2  MOVE TO OUTPUT LINE
         MVC   OUTMESG,IDENFLD
NOIDEN   MVC   OLIBNAME,LIBNAME
         CLC   LKEDDATE,=C'   '  ANY DATE PASSED ?
         BE    NOLKED
         TRT   LKEDDATE,TRTTBL
         BC    12,NOLKED
         LA    1,1
         NR    1,2
         BC    7,NOLKED
         ZAP   JULDATE,LKEDDATE  MOVE TO CALL AREA
         CALL  JULCAL,(JULDATE,CALDATE)  CALL CONVERSION ROUTINE
         MVC   WORKDATE,PATTERN
         ED    WORKDATE,CALDATE
         MVC   DATELINK,WORKDATE+2  MOVE TO OUTPUT LINE
NOLKED   EQU   *
         UNPK  OUTMELEN(7),MODLEN(4) UNPACK FOR PRINT
         TR    OUTMELEN(6),TBL-240 CONVERT TO PRINTABLE
         MVI   OUTMELEN+6,C' ' CLEAR EXTRA CHARACTER
         MVC   OUTMEMB,MODNAME
         UNPK  OUTATTR(7),MODATTR(4) UNPACK FOR PRINT
         TR    OUTATTR(6),TBL-240 CONVERT TO PRINTABLE
         MVI   OUTATTR+6,C' ' CLEAR EXTRA CHARACTER
         CLC   LKEDSSI(4),=CL4' '  ANY SSI INFO ?
         BE    OUTNOSSI       NO, SKIP SSI CONVERSION
         UNPK  OUTMESSI(9),LKEDSSI(5)  UNPACK FOR PRINT
         TR    OUTMESSI(8),TBL-240 CONVERT TO PRINTABLE
         MVI   OUTMESSI+8,C' ' CLEAR EXTRA CHARACTER
OUTNOSSI PUT   SYSPRINT,OUTLINE
         MVC   OUTLINE,BLANKS
         AP    LINECNT,=P'1'
         B     GETREC
CLOSEEM  CLOSE (SORTOUT)      CLOSE INPUT FILE
         CLOSE (SYSPRINT)     CLOSE REPORT FILE
EXIT     $EPILOG 0
TBL      DC    C'0123456789ABCDEF' TRANSLATE TABLE
TRTTBL   DC    10XL16'00000000000000000000010180800180',96XL1'01'
JULDATE  DC    PL4'0'
CALDATE  DC    PL4'0'
SAVEKEY  DC    CL11' '
SAVELIB  DC    CL15' '
LINECNT  DC    PL5'0'
PAGECNT  DC    PL3'0'
HEAD1    DS    0CL133
         DC    C'1',49C' '
         DC    C' LOAD LIBRARY STATUS REPORT    '
         DC    53C' '
HEAD1B   DC    C'0     '     (JOB)
         DC    CL8' '
         DC    C'       '    (PGM)
         DC    CL8' '
         DC    16C' '
RPTHEAD1 DC    CL5' '
         DC    C' TO MEMBER CROSS-REFERENCE LISTING',18C' ',C'DATE '
DATE     DC    CL8' '
         DC    C'  PAGE'
PAGENO   DC    CL6' '
         DC    CL10' '
HEAD2    DC    C'-                '
         DC    C'COMP''D ZAP    IDR    IDR     '
         DC    CL33' '
         DC    C'MODULE   MODULE  MODULE  ATTR-  LKED   MODULE',CL15' '
HEAD3    DC    C' NAME     LENGTH '
         DC    C'DATE   DATE   DATE   DATA'
         DC    36C'-',C' '
         DC    C'NAME     LENGTH SSI-INFO BUTES  DATE   '
         DC    C'LIBRARY-NAME       '
PATTERN  DC    X'4021202020202020'
PATTERN2 DC    X'40202120612020612020'
WORKDATE DC    CL8' '
CURRDATE DC    CL10' '
BLANKS   DC    X'40'
OUTLINE  DS    0CL133
OUTCCC   DS    CL1
OUTCSECT DS    CL8            NAME OF CSECT
         DS    CL1
OUTCSLEN DS    CL6            LENGHT OF CSECT
         DS    CL1
DATECOMP DS    CL6            DATE COMPILED
         DS    CL1
OZAPDATE DS    CL6            DATE OF ZAP
         DS    CL1
OIDENDTE DS    CL6            DATE OF IDR
         DS    CL1
OUTMESG  DS    CL40           IDR DATA
         DS    CL1
OUTMEMB  DS    CL8            NAME OF MEMBER
         DS    CL1
OUTMELEN DS    CL6            LENGTH OF MEMBER
         DS    CL1
OUTMESSI DS    CL8            MEMBER SSI INFORMATION
         DS    CL1
OUTATTR  DS    CL4            LINKEDIT ATTRIBUTES OF MEMBER
         DS    CL3
DATELINK DS    CL6            DATE MEMBER WAS LINK EDITED
         DS    CL1
OLIBNAME DS    CL16           NAME OF LIBRARY OF MEMBER
         DS    CL1
*        PARM LIST FOR SORT ONE
         DS    0D
SORTPARM DC    X'80',AL3(PARM1)
         CNOP  2,4            ALIGNMENT
PARM1    DC    AL2(EPARM1-PARM1-2)
         DC    A(SSORT1)      SORT FIELD START
         DC    A(ESORT1)      SORT END ADDRESS
         DC    A(SREC1)       START OF RECORD STATEMENT
         DC    A(EREC1)       END OF RECORD STATEMENT
         DC    F'0'           E15 EXIT NOT USED
         DC    F'0'           E35 EXIT NOT USED
         DC    C'SORT'        ALTERNATE DDNAME
         DC    X'00',XL3'30000'
         DC    X'FF00',C'AP'
EPARM1   EQU   *
SSORT1   DC    C' SORT FIELDS=('  SORT STATEMENT
         DC    C'47,8,BI,A,55,3,BI,A,17,8,BI,A,2,15,BI,A' FIELDS
         DC    C'),SIZE=E100000'  ESTIMATED NUMBER OF RECORDS
ESORT1   DC    C' '
SREC1    DC    C' RECORD TYPE=F,LENGTH=132'
EREC1    DC    C' '
HEADER1  DC    C'1',50C' ',C'LOAD LIBRARY STATUS REPORT',60C' '
HEADER2  DC    C'0',C'JOB  '
         DC    CL8' ',C'  PGM  '
         DC    31C' ',C'SUMMARY OR ERROR LISTING',19C' ',C'DATE'
         DC    C' '
DATE2    DC    CL8' ',15C' '
HEADER3  DC    CL133' '       DUMMY HEADING LINE FOR SPACING
ERROR1   DC    C' PARM FIELD TOO LONG '
ERRNAME1 DC    CL12' '
         DC    91C' '
ERROR2   DC    C' PARM FIELD HAS ZERO LENGTH '
ERRNAME2 DC    CL12' '
         DC    84C' '
TOTALINE DS    0CL133
         DC    CL11' '
ENDLIB   DC    C'LIB = '
OUTLIB   DC    CL15' '
         DC    C' HAS     '
OUTTOTAL DC    CL5' '
         DC    C'   MEMBERS',80C' '
DIRCOUNT DC    PL3'0'
TOTCOUNT DC    PL3'0'
         CNOP  0,4
ERROR3   DS    0CL133
         DC    CL11' ',C'LIB = '
ERRLIB   DC    CL15' '
         DC    C' MEMBER = '
ERRMEMB  DC    CL8' '
         DC    C' HAS '
ERRTOTAL DC    CL5' '
ERRTYPE  DC    CL8' '
ERRMESG  DC    CL42' '
         DC    CL24' '
CESDTOT  DC    PL3'0'
         CNOP  0,4
HOLDTRAN DC    CL15' '
SAVEPARM DC    F'0'           ADDRESS OF PARM LIST
SAVEOUT  DC    F'0'           ADDRESS OF NEXT OUTPUT TBLE LINE
SAVELEN  DC    F'0'
SAVEDD   DC    F'0'
TIOTADDR DC    F'0'
SAVELOAD DC    F'0'
SAVEDIR  DC    F'0'
SAVEEND  DC    F'0'
WORKADDR DC    F'0'
DCBLIST  DC    X'87',AL3(JFCB)
JFCB     DS    CL176
         DS    0D
LIBDIR   DCB   DSORG=PS,MACRF=GL,EODAD=ENDFILE,EXLST=DCBLIST
SYSLIB   DCB   DSORG=PO,MACRF=R,EODAD=ENDFILE
SYSPRINT DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,LRECL=133,            X
               BLKSIZE=133,RECFM=FBA
SORTIN   DCB   DDNAME=SORTIN,DSORG=PS,MACRF=PM,LRECL=132,BLKSIZE=3960, X
               RECFM=FBS
SORTOUT  DCB   DDNAME=SORTOUT,DSORG=PS,MACRF=(GM,PM),LRECL=132,        X
               RECFM=FBS,EODAD=CLOSEEM,BLKSIZE=3960
AREA     DC    256C' '        BUFFER AREA FOR BPAMREAD
BLANK    DC    X'40'
         LTORG
PARMTBLE DC    31X'404040404040404000'  CAN HOLD 31 9 BYTE RECORDS
***                NAME 8 BYTES  LENGTH 1 BYTE
WORKAREA DC    3795C' '       HOLDS 15 TRANSLATOR OR IDENTIFY IDR RECDS
*                            ABOUT 80 CSECT ENTRIES
OUTTABLE DC    9240C' '       EACH BLOCK OF 9240
         DC    9240C' '       CHARACTERS DEFINED
         DC    9240C' '       HERE CAN HOLD 70 132
         DC    9240C' '       BYTE RECORDS
OUTTABEN EQU   *              END OF OUTPUT TABLE
         EJECT
OUTREC   DSECT DUMMY          SECTION FOR OUTPUT TABLE
PREFIX   DS    0CL44          COMMON DATA FOR ALL OUTPUT LINES
RPTTYPE  DS    CL1            C FOR CSECT, E FOR ENTRY
LIBNAME  DS    CL15           LIBRARY NAME OF MEMBER MODULE
MODNAME  DS    CL8            MEMBER NAME
MODLEN   DS    CL3            LENGHT OF MEMBER
MODATTR  DS    CL2            ATTRIBUTES OF MEMBER
LKEDREC  DS    0CL15          LINK EDITOR DATA FIELD IS 15 BYTES
LKEDSSI  DS    CL4            MODULE SSI INFO
LKEDRSVD DS    PL8            RESERVED
LKEDDATE DS    PL3            PACKED JULIAN DATE OF LINK-EDIT YYDDD+
SUFFIX   DS    0CL85          UNIQUE DATA FOR EACH LINE
LINEID   DS    CL2            LINE NO. IN CESD RECORDS
CSECKEY  DS    0CL11          NAME AND LENGTH MAKE UNIQUE KEY
CSECNAME DS    CL8            CSECT NAME IN MEMBER
CSECLEN  DS    CL3            LENGTH OF CSECT IN MEMBER
ZAPREC   DS    0CL13          IMAPSZAP RECORD DATA
ZAPESD   DS    CL2
ZAPDATE  DS    PL3            PACKED JULIAN DATE OF ZAP YYDDD+
ZAPDATA  DS    CL8            USER INFO ENTERED AT TIME OF ZAP
ZAPFLAG  DS    CL1            SET TO M IF MULTIPLE ZAPS
TRANREC  DS    0CL15          LANGUAGE-TRANSLATOR RECORD DATA
TRNNAME  DS    CL10           NAME OF TRANSLATOR
TRNVM    DS    PL2            PACKED VERSION-MODIFICATION NUMBER VVMM
*                                  NO SIGN
TRNDATE  DS    PL3            PACKED JULIAN DATE OF TRANSLATOR YYDDD+
TRNFLAG  DS    CL1            SET TO M IF MULTIPLE RECDS
IDENREC  DS    0CL44          VARIABLE LENGTH IDENTIFY RECORD
IDENDATE DS    PL3            PACKED JULIAN DATE OF IDENTIFY YYDDD+
IDENCNT  DS    CL1            NUMBER OF USER BYTES
IDENFLD  DS    CL40           VAR. LENGTH OF PRINTABLE DATA
DRECTBLK DSECT DUMMY          SECTION FOR DIRECTORY BLOCKS
DRECTDAT DS    0CL256         DIRECTORY BLOCKS CONTAIN A
***                                    VARIABLE NO. OF VARIABLE LENGTH
***                                    ENTRIES IN A 256 BYTE BLOCK
ACTBYTES DS    CL2            NO. OF ACTIVE BYTES IN BLOCK
DRECTREC DS    0CL254
         ORG   DRECTREC
MEMBREC  DS    0CL74          MAXIMUN LENGTH IS 74 BYTES
MEMNAME  DS    CL8
MEMTTR   DS    CL3
MEMC     DS    CL1
MEMUSER  DS    0CL62          VARIABLE USER DATA MAX 31 H-WORD
         DS    CL8
MEMATTR  DS    CL2            LINK EDIT ATTRIBUTES
MEMLEN   DS    CL3            LENGTH OF LOAD MODULE
MEMEP    DS    CL3            ENTRY POINT OF MODULE
         DS    CL2
MEMATTR2 DS    CL1            ATTRIBUTE BYTE 2
         DS    CL49
CESDBLK  DSECT DUMMY          SECTION FOR CESD BLOCKS
CESDDATA DS    0CL248
**              CESD BLOCK CONTAINS A VARIABLE NO. OF 16 BYTE CSECT
**             RECORDS IN A 248 BYTE BLOCK
         DS    0CL8           PREFIX TO CESD BLOCK
CESID    DS    CL1            ID OF LOAD MODULE RECORD
**                                     X'20' FOR CESD RECORD
         DS    CL3
CSECTID  DS    CL2            LINE ID OF 1ST CESD ENTRY
CESDLEN  DS    CL2            NO. OF USER BYTES IN BLOCK
CESDREC  DS    0CL16
CESDNAME DS    CL8            NAME OF CSECT OR ENTRY
CESDTYPE DS    CL1            TYPE OF ENTRY
**                                     X'00'  =  CSECT RECORD
**                                     X'03'  =  ENTRY RECORD
**                                     X'07'  =  NULL  RECORD
CESDADDR DS    CL3            DISPLACEMENT INTO MODULE
CESDSEG  DS    CL1            SEGMENT NO IN MODLULE
CESDCSLN DS    CL3            LENGTH OF CSECT OR ENTRY IN HEX
         DS    CL226          VARIABLE LEN USER FIELDS
IDRBLK   DSECT DUMMY          SECTION FOR IDR BLOCKS
IDRDATA  DS    0CL256
**              IDR BLOCK CONTAINS CSECT INFORMATION , VARIABLE NO.
**             OF ENTRIES IN A 256 BYTE BLOCK
         DS    0CL3           PREFIX TO IDR BLOCK
IDRID    DS    CL1            ID OF LOAD MODULE RECORD
**                                     X'80'  =  IDR BLOCK
IDRLEN   DS    CL1            LENGTH OF IDR ENTRY
***                                    INCLUDING THIS BYTE
IDRSUB   DS    CL1            SUBTYPE OF IDR RECORD
**                                     X'01'  =  IMASPZAP
**                                     X'02'  =  LINK EDITOR
**                                     X'04'  =  LANGUAGE TRANNSLATOR
**                                     X'08'  =  IDENTIFY
**                                     X'80'  =  LAST IDR RECORD
IDRREC   DS    0CL253         VARIABLE LENGTH USER DATA
         ORG   IDRREC
PZAPCNT  DS    CL1            BITS 2 - 7 = NUMBER OF ZAP RECORDS IN
*                                  BLOCK
PZAPREC  DS    0CL13          EACH ZAP ENTRY IS 13 BYTES
PZAPID   DS    CL2            LINE ID OF ENRTY IN MEMBER WITH A ZAP
PZAPDATE DS    PL3            PACKED JULIAN DATE OF ZAP YYDDD+
PZAPDATA DS    CL8            USER INFO ENTERED AT TIME OF ZAP
         ORG   IDRREC
LINKREC  DS    0CL15          LINK EDITOR DATA FIELD IS 15 BYTES
LINKNAME DS    CL10           LINK EDITOR NAME
LINKVM   DS    PL2            PACKED VERSION-MODIFICATION NUMBER VVMM
*                                  NO SIGN
LINKDATE DS    PL3            PACKED JULIAN DATE OF LINK-EDIT YYDDD+
         ORG   IDRREC
TRANID   DS    CL2            LINE ID OF ENTRY IN MEMBER
TRANDATA DS    0CL31          VAR. LENGTH DATA SUPPLIED BY TRANSLATOR
***                     16 BYTES IF TRANIND = X'00',
***                     31 BYTES IF TRANIND = X'01'
TRANIND  DS    CL1            X'00' = ONLY 1 TRANSLATOR RECORD THIS
*                                  CSECT
***                     X'01' = 2 TRANSLATOR RECORDS THIS CSECT
TRANNAME DS    CL10           NAME OF TRANSLATOR
TRANVM   DS    PL2            PACKED VERSION-MODIFICATION NUMBER VVMM
*                                  NO SIGN
TRANDATE DS    PL3            PACKED JULIAN DATE OF TRANSLATOR YYDDD+
         DS    CL15
         ORG   IDRREC
IDENTID  DS    CL2            LINE ID OF ENTRY IN MEMBER WITH IDENTIFY
*                                  DATA
IDENTREC DS    0CL44          VARIABLE LENGTH IDENTIFY RECORD
IDENTATE DS    PL3            PACKED JULIAN DATE OF IDENTIFY YYDDD+
IDENTCNT DS    CL1            NUMBER OF USER BYTES
IDENTFLD DS    CL40           VAR. LENGTH OF PRINTABLE DATA
JULCAL   CSECT
         SAVE  (14,12)
         BALR  R2,0
         USING *,R2
         ST    13,SAVE+4
         LA    12,SAVE        ACCEPT 4 POSITIONS PACKED
         ST    12,8(13)       00YYDDDS
         LR    13,12
         L     R3,0(1)        GIVES  4 POSITIONS PACKED
         L     R4,4(1)        0MMDDYYS
         OI    3(R3),X'0F'    CHANGE SIGN BIT TO F
         UNPK  HLDA,0(4,R3)
         LA    R8,HLDA
         LA    R9,7
LOPER    TM    0(R8),X'F0'
         BNO   ERROR
         LA    R8,1(R8)
         BCT   R9,LOPER
         MVC   WRK2,0(R3)
         CVB   R6,WRK
         SRDA  R6,32(0)
         LA    R5,1000
         DR    R6,R5          7 IS  QUOTIENT
         ST    R7,HOLD
         MVC   FEB,=H'28'
         LA    R8,366
         TM    HOLD+3,X'03'
         BZ    LEAP
LEAPOVR  LTR   R6,R6
         BNP   ERROR
         CR    R6,R8
         BNL   ERROR
         LA    R9,1
         LA    R10,MONTH
LOOP     CH    R6,0(R10)
         BNH   FOUND
         LA    R9,1(R9)
         SH    R6,0(R10)
         LA    R10,2(R10)
         B     LOOP
FOUND    CVD   R7,WRK         6 IS DAY
         MVC   YEAR,WRK2      9 IS MONTH
         CVD   R6,WRK         7 IS YEAR
         MVC   DAY,WRK2
         CVD   R9,WRK
         MVC   MNTH,WRK2
         MVZ   YEAR+2(1),DAY+3
         MVN   YEAR+1(1),DAY+2
         MVN   YEAR(1),MNTH+2
         MVZ   YEAR+1(1),MNTH+3
RETURN   MVC   0(4,R4),YEAR
         L     13,SAVE+4
         RETURN  (14,12)
LEAP     MVC   FEB,=H'29'
         LA    R8,367
         B     LEAPOVR
ERROR    MVC   YEAR,=PL4'0'
         B     RETURN
*
         LTORG
HLDA     DS    CL7
HOLD     DS    F
SAVE     DC    18F'0'
         DS    0D
WRK      DS    0PL8
WRK1     DC    4XL1'00'
WRK2     DS    PL4
DAY      DS    F
YEAR     DS    F
MNTH     DS    F
MONTH    DS    0H
         DC    H'31'          JAN
FEB      DC    H'28'          FEB
         DC    H'31'          MARCH
         DC    H'30'          APRIL
         DC    H'31'          MAY
         DC    H'30'          JUNE
         DC    H'31'          JULY
         DC    H'31'          AUGUST
         DC    H'30'          SEPT
         DC    H'31'          OCT
         DC    H'30'          NOV
         DC    H'31'          DEC
         END
