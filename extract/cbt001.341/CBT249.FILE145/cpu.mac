         TITLE 'CPU - DOCUMENTATION'
* FUNCTION - AN ALC REPLACEMENT FOR THE CPU COMMAND ORIGINALLY WRITTEN
*            BY HOWARD GILBERT OF YALE UNIV COMPUTING CENTER. THAT
*            COMMAND CANNOT BE USED BY INSTALLATIONS WITHOUT THE PLI
*            OPTIMIZER.
*            WHILE THERE HAVE BEEN SOME MODIFICATIONS TO SCREEN
*            FORMAT, PROGRAM-TABLE MANAGEMENT, AND PERFORMANCE-GROUP
*            REPORTING, GILBERT'S ORIGINAL IDEAS HAVE BEEN FOLLOWED
*            CLOSELY.
*            FOR EXTENSIVE DOCUMENTATION ON THE ORIGINAL, SEE THE
*            OURMF SYSTEM DISTRIBUTED ON THE CBT TAPE. THE DIFFERENCES
*            BETWEEN THIS COMMAND AND THE ORIGINAL WILL BE OBVIOUS
*            WHEN YOU USE IT.
*            AS OF 8/80, I HAVE NOT BEEN ABLE TO TEST THIS AGAINST
*            GILBERT'S ORIGINAL CPU COMMAND OR GET A PLI/ASM EXPERT
*            TO CONFIRM THE CODE'S VALIDITY.
*            IF YOU ARE ABLE TO COMPARE THE TWO VERSIONS IN USE OR
*            BY INSPECTING THE SOURCE CODE, OR IF YOU
*            HAVE ANY CRITICISMS/SUGGESTIONS, PLEASE CALL-
*                        JACK MACLEAN
*                        HOBART CORP. (TROY, OHIO)
*                        513-335-7171 X2957
* OPERATION - START STATDIE AND LET RUN FOR AT LEAST 1 MINUTE.
*           - ENTER CPU. IT HAS VARIOUS EXPLANATORY ERROR MESSAGES.
*           - TO TERMINATE, USE PF12
*           - TO RE-EXECUTE, HIT ENTER.
*
* VERSION 2 CHANGES. THIS VERSION TESTED 11/14/81.
*           - BUG FIXED. SVC NUMBERS OVER 99 WERE LOSING HI-ORD DIGIT
*           - BUG PROBABLY FIXED. RANKING COLUMNS WERE BEING ONLY
*           PARTLY FILLED. SEE ''PROBLEMS'' BELOW. THIS WAS HAPPENING
*           INTERMITTENTLY, WHEN STATDIE HAD BEEN RUNNING ONLY A FEW
*           MINUTES.
*           - ENHANCEMENT. PRESSING ENTER WILL NOW REFRESH THE SCREEN
*           WITH NEW DATA IF MORE THAN 30 SECONDS HAVE PASSED.
         EJECT
* NOTES - THIS IS WRITTEN FOR NON-MVSSE, UNIPROCESSOR ENVIRONMENT, BUT
*         HAS BEEN RUN ON THE SE SYSTEM AT CBT. IN ADDITION,
*         THERE IS ROOM ON THE SCREEN FOR STATISTICS COVERING 2
*         PROCESSORS. IF YOU ADD CODE FOR THIS PLEASE LET ME KNOW.
*       - IT HANDLES UP TO 30 PERFORMANCE GROUPS, UP TO 2 DIGITS LONG.
*       - IT FOLLOWS STANDARDS FOR COMPATIBILITY WITH THE DCMS MONITOR.
*       - REQUIRES THAT STATDIE (SAME SOURCE AS ORIGINAL CPU COMMAND)
*         BE IMPLEMENTED AND RUNNING FOR AT LEAST ONE MINUTE.
*       - SOME PARTS OF THE CODE (TIMESPAN CALCULATION) ASSUME THAT THE
*         REALTIME INTERVAL FOR SCHEDULING THE BUFFER-COPY SRB, SET IN
*         STATDIE, IS 30 SECONDS. INTERVAL IS DETERMINED INDIRECTLY
*         BY THE INTERACTION OF SEVERAL VALUES IN THE MACROS SUPPLIED
*         WITH GILBERT'S OURMF-SYSTEM, AND YOU SHOULD CHECK THE VALUES
*         AT YOUR INSTALLATION BEFORE IMPLEMENTING THIS COMMAND.
*       - THE OURMF-SYSTEM MACROS ARE REQUIRED TO ASSEMBLE CPU COMMAND,
*         AND HAVE NOT BEEN MODIFIED. ALSO, THE CSECTS XCMDSTAE AND
*         TERMIO# ARE CALLED AT LINKEDIT TIME. TERMIO# EXISTS IN ALL
*         FORMS IN THE DISTRIBUTED DCMS SYSTEM, BUT XCMDSTAE SEEMS TO
*         EXIST ONLY IN LOADMODULE FORM, SO BOTH ARE INCLUDED WITH THE
*         LOADMODULE FORM OF THE CPU COMMAND, SO THAT YOU MAY RELINK
*         WITHOUT RISKING DIFFERENT VERSIONS OF THOSE 2 CSECTS.
*       - IF YOU WISH TO RUN THIS COMMAND UNDER TSO TEST, UN-COMMENT
*         THE 2 INSTRUCTIONS THAT MODIFY THE TERMIO# CSECT. TO LOCATE
*         THEM DO A FIND ON =V(TERMIO.
*       - THIS CSECT IS DESIGNED TO BE REFRESHABLE BUT HAS NOT YET BEEN
*         RUN FROM LPALIB. I HAVE NOT CHECKED THE REENTERABILITY OF
*         XCMDSTAE OR TERMIO# CSECTS, BUT THE DCMSTART MACRO USED HERE
*         DOES HAVE 2 MINOR REENTRANCY VIOLATIONS.
*       - TO COVER ALL CONTINGENCIES, I USE THIS SYSLIB CONCATENATION -
*          DCMS.MACRO,DCMS.MACLIB,SYS1.MACLIB,SYS1.AMODGEN,SYS1.AMACLIB
*          AND OURMF.SOURCE.
*
* PROBLEMS - IF RUNNING UNDER STRAIGHT TSO, THE CLEAR-SCREEN ROUTINE
*            LEAVES THE SCREEN LOCKED, UNABLE TO INPUT ANOTHER COMMAND
*            AFTER CPU, WITHOUT MANUALLY CLEARING SCREEN FIRST.
*          * VERY RARELY, A RANKING COLUMN ON THE DISPLAY WILL NOT
*            HAVE ALL NON-ZERO ENTRIES DISPLAYED. RE-ISSUING THE CPU
*            COMMAND SEEMS TO CLEAR THE PROBLEM, BUT ITS CAUSE IS
*            UNKNOWN. A PARTIALLY-FILLED COLUMN IS NORMAL WITH KEY
*            AND PERFORMANCE-GROUP (DEPENDING ON THE NUMBER RUNNING)
*            RANKINGS, BUT NOT WITH PROGRAM OR SVC RANKINGS.
*       *    THINK THIS IS FIXED WITH V-2. PLEASE CALL IF YOU HIT IT.
*
* ENHANCEMENTS - PERMIT USER TO SPECIFY TIMESPAN SHORTER THAN THAT
* NEEDED IN      COVERED BY STATDIE'S NON-EMPTY PAGEABLE BUFFERS
* FUTURE       - DISPLAY NUMBER OF SYNONYMS GENERATED IN PROGRAM-NAME
* VERSIONS       HASHING TABLE
*              - REDUCE CSECT AND WORKING-STORAGE SIZE TO 4K EACH,
*                SIMPLIFYING REGISTER USAGE AND ADDRESSABILITY
* IF YOU ACCOMPLISH ANY OF THESE, OR IF YOU WOULD LIKE TO SEE OTHERS,
* PLEASE LET ME KNOW. SEE PREVIOUS PAGE.
         EJECT
* REGISTER USAGE AFTER INITIALIZATION -
*     15 - LOOP CONTROL FOR PERFORMANCE-GROUP COUNTERS
*     14 - INTERNAL LINKING
*     13 - GETMAINED SAVE AND WORK AREAS
*     12 - PRIMARY BASE
*     11 - SECONDARY BASE
*     10 - PROGRAM-NAME INDIVIDUAL BUCKETS (GETMAINED)
*        - SECONDARY WORK-AREA PTR AFTER ALL PGM-NAME BUCKETS FILLED
*      9 - PROGRAM-NAME HASH TABLE (GETMAINED)
*      8 - WORK, ALSO USED BY PERCENT ROUTINE
*      7 - WORK, ALSO USED BY PERCENT ROUTINE
*      6 - WORK, ALSO USED BY PERCENT ROUTINE
*      5 - LOOP CONTROL THRU STATDIE BUFFER COPY OR PGM-NAME TABLE
*      4 - LOOP CONTROL THRU STATDIE BUFFER COPY OR PGM-NAME TABLE
*      3 - LOOP CONTROL THRU STATDIE BUFFER COPY OR PGM-NAME TABLE
*      2 - WORK
*      1 - LOOP CONTROL FOR PERFORMANCE-GROUP TABLES
*      0 - LOOP CONTROL FOR PERFORMANCE-GROUP TABLES
*
****
* NOTE - REGS 0-9 HAVE SPECIAL USAGE DURING RANK ROUTINE - SEE COMMENTS
*      - REGS 1-7 HAVE SPECIAL USAGE DURING MOVE ROUTINE - SEE COMMENTS
****
*
****
* FOLLOWING EQUATES USED THROUGHOUT THE PROGRAM
****
*
MODULUS  EQU   283           USED FOR HASHING PGM NAMES
BUKTNBR  EQU   1000          NBR OF BUCKETS AVAIL FOR PGM DATA ACCUM
BUKTSIZE EQU   16            SIZE OF EACH BUCKET
LINKREG  EQU   14            REGISTER USED FOR INTERNAL LINKAGE
PGNBR    EQU   30            MAX NBR OF PERF GROUPS TO BE HANDLED
         TITLE 'CPU - DSECTS AND EQUATES FOR STATDIE INTERFACE'
****
* FOLLOWING DSECTS NEEDED FOR COMPATIBILITY WITH THE COUNTERS SET UP
* BY THE STATDIE DIE EXIT. SIZE, NUMBER, AND MAPPING OF THIS COMMAND'S
* COUNTERS ARE LARGELY DETERMINED BY STATDIE, AND CHANGES MUST BE
* COORDINATED BETWEEN THEM.
****
*
         STATGLBL
         EJECT
         STATPSW
         EJECT
         STDE
         EJECT
         PGBUF
         TITLE 'CPU - PROGRAM-NAME AND HASH-TABLE DSECT'
****
* FOLLOWING DSECT MAPS STORAGE GETMAINED AFTER COMMAND DETERMINES THAT
* IT HAS ENOUGH DATA TO PROCESS COMPLETELY.
* THIS WORK AREA CONSISTS OF A HASH TABLE FOLLOWED BY A PROGRAM-NAME
* TABLE. THE HASH TABLE IS ENTERED AFTER RANDOMIZING A PROGRAM NAME,
* AND ITS ENTRIES POINT TO CORRESPONDING ENTRIES IN THE PROGRAM-NAME
* TABLE. THAT TABLE'S ENTRIES HOLD THE PRIMARY PROGRAM NAME, COUNTERS
* FOR THAT PROGRAM, AND A LINK POINTER TO THE ENTRY FOR THE NEXT
* SYNONYM (IF ANY) GENERATED BY THE HASHING ALORITHM.
****
*
HASHTAB  DSECT         HASHING TABLE FOR PROGRAM NAMES
         DS    XL(MODULUS*4)
HASHBKTS DS    (BUKTNBR)XL(BUKTSIZE)
         ORG   HASHBKTS
HASHNAME DS    CL8   PGM NAME USED FOR THIS BUCKET
HASHCHN  DS    F     CHAIN PTR FOR NEXT SYNONYM
HASHCNT  DS    F     NBR OF TIMES PGM FOUND IN SAMPLE
         TITLE 'CPU - RANKING OUTPUT-TABLE DSECT'
****
* FOLLOWING DSECT MAPS A SINGLE ELEMENT OF THE TABLES USED AS OUTPUT
* BY THE RANK ROUTINE. EACH TABLE HAS AN ORIGIN AND NUMBER OF ELEMENTS
* DETERMINED BY THE ROUTINE'S CALLER.
****
*
RANKTBLE DSECT         OUTPUT TABLE FOR RANKING ROUTINE
MAXADDR  DS    F       PTR TO HIGHEST COUNT-FIELD OF CURRENT PASS
MAXID    DS    CL8     EBCDIC-FORMAT ID OF HIGHEST ELEMENT
MAXPOSN  DS    PL2     POSITIONAL-FORMAT ID OF HIGHEST ELEMENT
MAXCOUNT DS    PL3     VALUE OF HIGHEST COUNT FIELD
RANKPAD  DS    XL1     PADDING TO KEEP ALIGNMENT
MAXPCT   DS    CL6     EDITED PERCENT OF ACTIVES TO NEAREST TENTH
EDPOSN   DS    CL4     EDITED POSITION OF HIGHEST ELEMENT
         ORG
         TITLE 'CPU - INITIALIZATION'
CPU      DCMSTART R,STAE=YES,LV=8192,SA=DCMSAVE,IOCB=YES,BASE=12,      *
               REGS=1,KEEP=PARMADDR,TEMP=2,                            *
               WORK=DCMSWORK,PARM=3
****
* FOLLOWING INSTRUCTIONS ARE FOR RUNNING UNDER TSO TEST ONLY.
* THEY SHOULD BE COMMENTED OUT WHEN ASSEMBLING FOR REGULAR TSO COMMAND.
* THEY MODIFY THE TERMIO# CSECT SO THAT IT WON'T BE FOOLED BY TEST
* INTO THINKING THAT STANDALONE DCMS HAS INVOKED THIS COMMAND.
****
*
*        L     R2,=V(TERMIO#)   LOCATE TERMIO# CSECT
*        MVI   201(R2),X'00'    NO-OP THE BRANCH AFTER TM IN 'NOTINIT'
*
****
* CLEAR PREVIOUS DATA FROM SCREEN IMAGE-BUILD AREA
****
*
REFRESH  EQU   *
         SR    R8,R8
         DCMSNULL FORMAT=FORMAT,IMAGE=SCREEN
*
****
* DETERMINE WHETHER SAMPLING EXIT IS OPERATING.
* IF NOT, MESSAGE ERROR AND TERMINATE.
* ELSE, STORE SAMPLING CONSTANTS AND BUFFER POINTERS FOR USE IN
* DATA-GATHERING ROUTINES.
****
*
         LOAD  EP=STATSTDE,ERRET=NODIE
         ST    R0,STDEPTR     KEEP PTR TO MAIN STATS CTL BLOCK
         LR    R3,R0
         USING STDE,R3
         EJECT
****
* NOTE - THE FOLLOWING TEST IS EQUIVALENT TO BOTH INIT AND PURGE
*        TESTS IN PLI MODULE.
****
*
         TM    STDELAST,STDEATIV  IS DIE ALIVE?
         BZ    DIEDEAD            NO, MESSAGE AND TERMINATE
****
* COPY THE PAGEABLE BUFFERS FROM CSA BUFFER POOL USED BY DIE EXIT
* INTO PRIVATE STORAGE USED BY THIS COMMAND IN ORDER TO FREEZE THEM.
****
*
         XC    GETMLIST,GETMLIST  CLEAR GETMAIN LIST
         L     R5,STDEGET         SIZE OF CSA POOL IN USE
         LA    R7,0(,R5)          SIZE OF PRIVATE POOL
         ST    R7,BFPLSIZE
         MVC   STATBUFS,=F'0'     INIT SO FREEMAIN WILL KNOW IF OK
         GETMAIN EC,LV=(7),SP=0,A=STATBUFS,MF=(E,GETMLIST),BNDRY=PAGE
         BXH   R15,R15,TOOSMALL   INSUFFICIENT REGION SIZE?
         L     R4,STATBUFS        OK, POINT TO PRIVATE POOL
         L     R6,STDEBUFP        PAGEABLE BUFFER POOL IN CSA
         LA    R6,0(,R6)             (SET PADDING CHAR TO X00)
         LR    R2,R7              BEFORE MVCL, INIT BUFFER LOOP WHILE
         AL    R2,STATBUFS        THE ADDRESSES ARE AVAILABLE
         BCTR  R2,0           THIS WILL BE USED IN BXLE
         ST    R2,BUFPTRS+8        -LIMIT VALUE
         LA    R2,PGBLEN
         ST    R2,BUFPTRS+4        -INCREMENT VALUE
         ST    R4,BUFPTRS          -INDEX VALUE
         MVCL  R4,R6              NOW, COPY ALL THE STATDIE BUFFERS
         DROP  R3
         EJECT
****
* COPY THE STATIC TITLE INFORMATION FOR THE CPU PRIMARY DISPLAY INTO
* ITS SCREEN IMAGE AREA
****
*
         MVC   S1UTILIT,=C'CPU BUSY  '
         MVC   S1SAMPLT,=C'SAMPLES  '
         MVC   S1USERT,=C'USER-MODE '
         MVC   S1TIMEST,=C'TIMESPAN '
         MVC   S1SUPVT,=C'SUPV STATE'
         MVC   S1READYT,=C'READY TASKS '
         MVC   S1SVCPT,=C'SUPV STATE PROFILE - SVC:'
         MVC   S1SRBPT,=C'SRB:'
         MVC   S1OTHEPT,=C'OTHER:'
*
****
* INTIALIZE A SET OF COUNTERS FOR PROGRAM-NAME STATISTICS AND A
* HASHING TABLE TO MAP PROGRAM NAMES INTO THE COUNTERS.
****
*
         XC    GETMLIST,GETMLIST  CLEAR GETMAIN LIST
         L     R5,CNTRSIZE        SIZE OF COUNTERS PLUS MAPPING TABLE
         MVC   PGMTABLE,=F'0'     INIT SO FREEMAIN CAN TELL IF OK
         GETMAIN EC,LV=(5),SP=0,A=PGMTABLE,MF=(E,GETMLIST),BNDRY=PAGE
         BXH   R15,R15,TOOSMALL   INSUFFICIENT REGION SIZE?
         TITLE 'CPU - ACCUM DATA FROM COPY OF STATDIE BUFFERS'
****
* FOLLOWING CODE LOOPS THROUGH ALL BUFFERS IN COPY OF STATDIE
* PAGEABLE BUFFERS, ACCUMULATING DATA ABOUT THE INTERVAL REPRESENTED.
* WITHIN EACH BUFFER, IT LOOPS THROUGH ALL PSW COUNTERS, ACCUMULATING
* DATA ABOUT EACH SAMPLE. ALL DATA IN ALL BUFFERS MUST BE CHECKED
* BEFORE THE MAIN DISPLAY CAN BE GENERATED.
****
*
         L     R9,PGMTABLE        ALIGN TO HASHING TABLE
         USING HASHTAB,R9
         LA    R10,HASHNAME       ALIGN TO INDIVIDUAL BUCKETS
         ST    R10,NXTBUCKT       INIT PTR TO AVAILABLE NAME-TABLE
         USING HASHNAME,R10
         LM    R3,R5,BUFPTRS      INIT OUTER LOOP CONTROL FOR BUFFERS
         USING PGBUF,R3
         MVC   STARTIME,PGBTOD   INIT FIRST AND LAST TIME STAMPS TO
         MVC   LASTIME,PGBTOD   BE USED LATER FOR TIME SPAN CALCULATION
         MVC   PSWPTRS+4(4),=A(PSWLEN)  SETUP INCREM FOR PSW LOOP CTL
         LA    R2,PG               SET UP INITIAL LOOP CONTROL FOR
         ST    R2,PGSTART        PERFORMANCE GROUP COUNTERS.
         S     R2,=F'5'            SETUP TO FORCE FIRST BXLE FAIL, AS
         ST    R2,PGEND            PGEND WILL BE INCREMENTED AS MORE
         MVC   PGINCR,=F'5'     PERFORMANCE GROUPS ARE ENCOUNTERED.
         MVC   PACKCTRS(PACKEND-PACKCTRS),PACKINIT     INITIALIZE
         MVC   KEYS(SYNONYMS-KEYS),KEYINIT             ALL
         MVC   SVCS+000(192),SVCINIT                   THE
         MVC   SVCS+192(192),SVCINIT                   PACKED
         MVC   SVCS+384(192),SVCINIT                   DECIMAL
         MVC   SVCS+576(195),SVCINIT                   COUNTERS
         MVC   PG(PGNBR*5+5),PGINIT                    (ALL)
         EJECT
****
* OUTER BUFFER LOOP STARTS HERE.
****
*
STARTPSW EQU   *
         LA    R2,PGBPSWS         SETUP INDEX FOR PSW LOOP CTL
         ST    R2,PSWPTRS
         L     R1,=A(PSWLEN*SRBINTVL-PSWLEN)
         LA    R2,0(R1,R2)
         ST    R2,PSWPTRS+8    AND LIMIT FOR PSW LOOP CTL
         ST    R3,BUFPTRS         STORE CURRENT STATUS OF OUTER LOOP
*
****
* DETERMINE WHETHER THIS IS CANDIDATE FOR TIME SPAN BOUNDARY
****
*
         CLC   PGBTOD,ZEROS       IS TIME-STAMP PRESENT?
         BE    NEXTBUFR           NO, CAN'T USE IT
         CLC   STARTIME,PGBTOD    COULD THIS BE TRUE START OF PERIOD?
         BNH   CKLASTIM           NO, IMPOSSIBLE
         MVC   STARTIME,PGBTOD    YES, REPLACE CURRENT CANDIDATE
         B     NEXTBUFR
CKLASTIM EQU   *
         CLC   LASTIME,PGBTOD     COULD IT BE TRUE END OF PERIOD?
         BNL   NEXTBUFR           NO, CAN'T USE IT AT ALL
         MVC   LASTIME,PGBTOD     YES, REPLACE CURRENT CANDIDATE
NEXTBUFR EQU   *
         LM    R3,R5,PSWPTRS      PICK UP STATUS OF INNER LOOP
         USING PSW,R3
*
****
* DETERMINE WHETHER CURRENT PSW COUNTER REPRESENTS A VALID SAMPLE
* INNER PSW LOOP STARTS HERE.
****
*
CKPSWCTR EQU   *
         CLC   PSWINST,=F'0'
         BE    CKSAMPLE
         CLC   PSWINST,=F'1'
         BNE   COUNTSAM           DONT BOTHER TO TEST MASK
CKSAMPLE EQU   *
         CLI   PSWMASK,X'00'
         BE    NEXTPSW            GO SETUP TO CHECK NEXT PSW CTR
COUNTSAM EQU   *
         AP    SAMPLE,=P'1'       OK TO COUNT ONE SAMPLE
*
****
* DETERMINE WHETHER CURRENT PSW SAMPLE IS FOR CPU ACTIVE
****
*
CKACTIVE EQU   *
         TM    PSWMASK,PSWWAIT    IS IT WAIT-STATE PSW?
         BO    NEXTPSW       YES, GO SETUP TO CHECK NEXT PSW CTR
         AP    ACTIVES,=P'1' NO, COUNT ONE ACTIVE SAMPLE
         EJECT
****
* DETERMINE KEY OF ACTIVE TASK AND COUNT ONE ACTIVE SAMPLE FOR THAT KEY
****
*
         SR    R6,R6              CLEAN OUT EXTRANEOUS BITS
         IC    R6,PSWMASK         PICK UP 2ND BYTE OF PSW
         SRL   R6,4               KEY IS IN LEFT HALF
         MH    R6,=H'3'           DEVELOP INDEX VALUE
         LA    R2,KEYS(R6)        INDEX INTO COUNTER SET
         AP    0(3,R2),=P'1'      AND COUNT AN ACTIVE FOR THIS KEY
*
****
* INCREMENT TOTAL OF READY TCBS
* CAUTION *** DONT INSERT ANYTHING TO PUT BITS INTO REGISTER 6
****
*
         IC    R6,PSWRDY          R6 BETTER BE CLEAR IN HI-ORDER BYTES
         CVD   R6,DBLWORD         KEEP EVERYTHING PACKED FOR CLARITY
         AP    TCBRDYS,DBLWORD
*
****
* DETERMINE PERFORMANCE GROUP AND COUNT AN ACTIVE SAMPLE FOR IT
* IF PERFORMANCE GROUP ISN'T IN TABLE, ADD IT TO TABLE
****
*
         LM    R15,R1,PGPTRS      SET UP LOOP CONTROL
         SR    R2,R2              CONVERT PG TO EBCDIC
         IC    R2,PSWPG
         CVD   R2,DBLWORD
         UNPK  CURRPG,DBLWORD+6(2)
         OI    CURRPG+2,X'F0'
CHKPG    EQU   *
         CLC   CURRPG+1(2),0(R15) PG FROM PSW MATCH PG IN COUNTER ?
         BE    COUNTPG            YES, GO COUNT IT
         BXLE  R15,R0,CHKPG       NO, TRY NEXT ENTRY
INSERTPG EQU   *
         TM    4(R15),B'00001100' IS THIS CTR PACKED-DECIMAL?
         BNO   EXCESSPG           NO, SEND ERROR MSSG.
         ST    R15,PGEND          NOT ANYWHERE IN TABLE, SO ADJ. LIMIT
         MVC   0(2,R15),CURRPG+1  TAG NEW ENTRY WITH ITS OWN PERF GROUP
COUNTPG  EQU   *
         AP    2(3,R15),=P'1'     COME HERE IF PG IS ALREADY IN TABLE
         EJECT
****
* COUNT SAMPLE UNDER PROBLEM STATE IF BIT ON
****
*
CHKPBLM  EQU   *
         TM    PSWMASK,PSWPROB    WAS CPU IN PROBLEM STATE?
         BNO   CHKSRB             NO, COUNT IN SUPV STATE BREAKDOWN
         AP    PBLMCNT,=P'1'
*
****
* COUNT SAMPLE UNDER USERMODE IF PROBLEM STATE AND KEY IS 8 OR HIGHER
****
*
CHKUSER  EQU   *
         TM    PSWMASK,X'80'      IN USER KEY?
         BNO   CHKNAME            NO, BYPASS FURTHER CLASSIFICATION
         AP    USERCNT,=P'1'
         B     CHKNAME            SKIP SUPERVISOR-STATE BREAKDOWN
         EJECT
****
* PSW INDICATES SUPERVISOR STATE, SO BREAK IT DOWN INTO SRB, SVC, OR
* OTHER MODE.
*
* COUNT SAMPLE UNDER SRBS IF BIT ON
****
*
CHKSRB   EQU   *
         TM    PSWMASK,PSWSRB     IN SRB MODE?
         BNO   CHKSVC             NO, TRY SVC
         AP    SRBST,=P'1'
         B     CHKNAME            SKIP REST OF COUNTS & GO CK PGM NAME
*
****
* COUNT SAMPLE UNDER SVC STATE IF BIT ON
****
*
CHKSVC   EQU   *
         TM    PSWMASK,PSWSVCMD   SVC IN CONTROL?
         BNO   ADDOTHER           NO, COUNT IN OTHER CATEGORY
         AP    SVCST,=P'1'
*
****
* COUNT SAMPLE UNDER SPECIFIC SVC SINCE SVC WAS IN CONTROL
* CAUTION *** AFTER THIS ROUTINE, R6 MAY HAVE BITS IN 3RD BYTE ***
****
*
         IC    R6,PSWSVC          PICK UP SVC FROM BUFFER
         MH    R6,=H'3'           DEVELOP INDEXING VALUE
         LA    R2,SVCS(R6)        INDEX INTO COUNTERS
         AP    0(3,R2),=P'1'
         B     CHKNAME
ADDOTHER EQU   *
         AP    OTHER,=P'1'        NOT PROBLEM, SRB, OR SVC
         TITLE 'CPU - COUNT ACTIVES BY PROGRAM NAME'
****
* DEVELOP HASHING INDEX FROM NAME OF PROGRAM IN CONTROL
****
*
CHKNAME  EQU   *
         CLC   =CL8' ',PSWNAME    CHECK NAME OF PROGRAM IN CONTROL
         BE    NEXTPSW            IF BLANK, BYPASS COUNT
         MVC   CDENAME,PSWNAME    PREPARE FOR EXCLUSIVE OR'S
         XC    KEYBITS1,KEYBITS2  X'OR FIRST 2 PAIRS
         XC    KEYBITS3,KEYBITS4  THEN 3RD AND 4TH PAIRS
         XC    KEYBITS1,KEYBITS3  AND LAST THE 2 INTERMEDIATE RESULTS
         LM    R6,R7,ZEROS        SETUP FOR DIVIDE
         ICM   R7,3,KEYBITS1      GET THE RESULT OF X'OR CHAIN
         LA    R8,MODULUS
         DR    R6,R8              REMAINDER IS INDEX INTO HASH TABLE
*
****
* HASH TABLE ENTRY WILL NOW POINT TO PRIME ENTRY. IF PROGRAM NAME
* MATCHES PRIME ENTRY, COUNT IT. IF NOT, FOLLOW CHAIN OF SYNONYMS.
* IF NO MATCH BY END OF CHAIN, CREATE A NEW ENTRY, EITHER AS PRIME OR
* SYNONYM.
****
*
         SLL   R6,2               INDEX INTO HASHING TABLE
         L     R10,HASHTAB(R6)    POINT TO PRIME ENTRY
         LTR   R10,R10            ENTRY EVER USED?
         BNZ   PGMCHK             YES, GO CHECK FOR SYNONYMS
PGMNEW   EQU   *
         L     R10,NXTBUCKT       NO, SO ASSIGN A NAME-TABLE ENTRY
         ST    R10,HASHTAB(R6)    SET HASH-TABLE ENTRY TO PRIME
PGMSYNON EQU   *
         LA    R7,16(R10)         POINT TO NEXT UNUSED ENTRY
         ST    R7,NXTBUCKT        AND REFRESH UNUSED-POINTER
         MVC   HASHNAME,PSWNAME   STORE PROGRAM NAME
         ZAP   HASHCNT,=P'0'      AND INIT USE COUNT TO PACKED-DECIMAL
PGMCOUNT EQU   *
         AP    HASHCNT,=P'1'      INCREMENT USE COUNT
         B     NEXTPSW
         EJECT
****
* FOLLOWING ROUTINE CHECKS PROGRAM-NAME TABLE FOR SYNONYMS
****
*
PGMRECHK EQU   *
         LR    R10,R8             POINT TO NEXT LINK IN CHAIN
PGMCHK   EQU   *
         CLC   PSWNAME,HASHNAME   ENTRY BELONG TO THIS PROGRAM?
         BE    PGMCOUNT           YES, GO COUNT IT AS ACTIVE
         AP    SYNONYMS,=P'1'     NO, COUNT ONE SYNONYM HIT
         L     R8,HASHCHN         AND FOLLOW CHAIN OF SYNONYMS
         LTR   R8,R8              AT END OF CHAIN?
         BNZ   PGMRECHK           NO, GO CHECK NEXT LINK
         MVC   HASHCHN,NXTBUCKT   YES, ADD NEW LINK PTR
         L     R10,NXTBUCKT       POINT TO NEW ENTRY
         B     PGMSYNON           AND ADD REST OF INFORMATION
NEXTPSW  BXLE  R3,R4,CKPSWCTR     REPEAT EXTRACTION FOR NEXT PSW CTR
*
****
* ALL PSW CTRS FOR THIS BUFFER HAVE BEEN PROCESSED, SO ADJUST LOOP
* CONTROL TO NEXT BUFFER. PSW (INNER) LOOP ENDS HERE.
****
*
         USING PGBUF,R3
         LM    R3,R5,BUFPTRS       RESTORE CURRENT BUFFER POINTERS
         BXLE  R3,R4,STARTPSW      STEP UP TO NEXT BUFFER
         DROP  R3
*
****
* BUFFER DATA EXTRACTION IS NOW COMPLETE. BUFFER LOOP ENDS HERE.
****
*
         DROP  R10          PROGRAM TABLE NO LONGER ADDRESSABLE
         L     R10,=F'4096' NOW ADDRESS SECOND 4K OF WORK AREA
         LA    R10,0(R10,R13)
         USING DCMSWORK+4096,R10
*
****
* BE CAREFUL ABOUT ADDRESSABILITY OF WORKING-STORAGE FIELDS. UP TO
* THIS POINT ONLY THE FIRST 4K IS ADDRESSABLE.
****
         TITLE 'CPU - COMPUTE TIME SPAN COVERED BY SAMPLES'
****
* DIFFERENCE BETWEEN LOWEST AND HIGHEST TIME-STAMPS ENCOUNTERED WILL
* BE MEASURE OF TIMESPAN COVERED BY NON-EMPTY BUFFERS. NEEDS TO BE
* ADJUSTED.
*  - SINCE EACH BUFFER HOLDS A FULL 30 SECONDS, THAT MUCH MUST BE
*   ADDED FOR THE LAST BUFFER
****
*
         L     R6,LASTIME    DETERMINE WHETHER ENOUGH BUFFERS WERE
         SL    R6,STARTIME   FILLED TO MAKE FURTHER PROCESSING USEFUL
         BC    10,TRYAGAIN   NOT ENOUGH - TELL USER TO TRY LATER
         AH    R6,=H'30'     ADD 30 SECS FOR LAST BUFFER GIVING ELAPSED
         CVD   R6,DBLWORD      TIME COVERED BY ACTIVE SAMPLES
         DP    DBLWORD,=P'60'     CONVERT TIME TO MINUTES
         ZAP   TIMINTVL,DBLWORD+4(2)  STORE INTERVAL TO USE LATER
         EJECT
****
* SINCE BUFFER TIME-STAMP IS IN SYSTEM-CLOCK NOTATION, FOLLOWING
* ROUTINE APPROXIMATES WHAT HUMAN-CLOCK START TIME WOULD HAVE BEEN.
* IT GETS THE CURRENT TIME IN BOTH UNITS, THEN CALCULATES THE
* TIME ELAPSED SINCE FIRST TIME-STAMP. THE VALUE IS APPROXIMATE SINCE
* THE ROUTINE USES THE HIGH-ORDER CLOCK WORD AS NUMBER OF SECONDS,
* AND THIS CAN BE ALMOST 1 MINUTE OFF IN 20 MINUTES.
* BECAUSE OF THIS THE VALUE MUST BE ADJUSTED IF ENOUGH TIME HAS
* ELAPSED.
****
*
         TIME  STCK,CURTIME  GET SYSTEM CLOCK FOR CURRENT TIME
         TIME  DEC           GET DECIMAL VALUE FOR CURRENT TIME
         L     R6,CURTIME    DETERMINE HOW MANY SECONDS HAVE ELAPSED
         SL    R6,STARTIME
         CVD   R6,DBLWORD    WE NOW HAVE DIFFERENCE BETWEEN 2 CLOCKS
         CP    DBLWORD,=P'300' ADJUSTMENT NEEDED?
         BNH   CONVERT         NO, INTERVAL WAS TOO SHORT
         AP    DBLWORD,=P'30'  COMPENSATE FOR AT LEAST 1/2 MIN
         CP    DBLWORD,=P'900' BIG ENOUGH FOR ANOTHER ADJUSTMENT?
         BNH   CONVERT
         AP    DBLWORD,=P'30'
CONVERT  EQU   *
         DP    DBLWORD,=P'60'  CONVERT UNITS TO MINUTES
         STCM  R0,4,MINVALUE    GET MINUTE VALUE OF CURRENT TIME
         MVO   MINVALUE,MINVALUE(1) PUT IN PROPER PACKED FORMAT
         OI    MINVALUE+1,X'0F' BE SURE IT'S PD FORMAT
         STCM  R0,8,HRSVALUE    THEN DO THE SAME WITH HOURS
         MVO   HRSVALUE,HRSVALUE(1)
         OI    HRSVALUE+1,X'0F' BE SURE IT'S PD FORMAT
         SP    MINVALUE,DBLWORD+4(2)   COMPUTE HUMAN-CLOCK START TIME
         BNM   EDSTRTME                IF NO UNDERFLOW, DONT DECREMENT
         SP    HRSVALUE,=P'1'          THE HOURS VALUE
         AP    MINVALUE,=P'60'
         EJECT
EDSTRTME EQU   *
         MVC   STRTMINS,MINSEDT        EDIT START TIME INTO DISPLAY
         ED    STRTMINS,MINVALUE       SCREEN
         MVC   STRTHRS,HRSEDT
         ED    STRTHRS,HRSVALUE
         AP    MINVALUE,TIMINTVL       NOW COMPUTE ENDING TIME OF RANGE
         CP    MINVALUE,=P'60'         IF NO OVERFLOW, DONT INCREMENT
         BNH   EDENDTME                THE HOURS VALUE
         AP    HRSVALUE,=P'1'
         SP    MINVALUE,=P'60'
EDENDTME EQU   *
         MVC   ENDMINS,MINSEDT         EDIT START TIME INTO DISPLAY
         ED    ENDMINS,MINVALUE        SCREEN
         MVC   ENDHRS,HRSEDT
         ED    ENDHRS,HRSVALUE
         MVI   ENDHRS,C'-'
         TITLE 'CPU - COMPUTE AND EDIT PRIMARY STATISTICS'
****
* CPU UTILIZIATION PERCENT
****
*
         LA    R6,SAMPLE     POINT TO BASE
         LA    R7,ACTIVES    POINT TO STATISTIC
         LA    R8,S1UTILIZ   POINT TO RECEIVING FIELD IN SCREEN1
         BAL   R14,PERCENT
*
****
* SUPERVISOR STATE PERCENT
****
*
         ZAP   SUPVST,ACTIVES  CALCULATE SUPERVISOR STATE TOTAL
         SP    SUPVST,PBLMCNT    EQUALS ACTIVES - PROBLEM STATE.
         LA    R6,ACTIVES    POINT TO BASE
         LA    R7,SUPVST     POINT TO STATISTIC
         LA    R8,S1SUPVST   POINT TO RECEIVING FIELD IN SCREEN1
         BAL   R14,PERCENT
*
****
* USER STATE PERCENT
****
*
         LA    R6,ACTIVES    POINT TO BASE
         LA    R7,USERCNT    POINT TO STATISTIC
         LA    R8,S1USERST   POINT TO RECEIVING FIELD IN SCREEN1
         BAL   R14,PERCENT
*
****
* SAMPLE COUNT
****
*
         MVC   S1SAMPLE(6),SAMPLEDT
         ED    S1SAMPLE(6),SAMPLE           XXXX
*
****
* READY TASK AVERAGE
****
*
         ZAP   DBLWORD,TCBRDYS
         MP    DBLWORD,=P'10'     CALC AVERAGE TO 1 DECIMAL
         DP    DBLWORD,ACTIVES
         MVC   S1READYS(5),READYEDT
         ED    S1READYS(5),DBLWORD+3        XX.X
         MVC   S1READYS(4),S1READYS+2       SHIFT EDITED RESULT LEFT
         MVC   S1READYS+4(2),=C'  '         AND CLEAR RIGHTMOST CHARS.
         EJECT
****
* SVC PART OF SUPERVISOR STATE
****
*
         LA    R6,ACTIVES    POINT TO BASE SUM OF BOTH CPUS
         LA    R7,SVCST      POINT TO STATISTIC
         LA    R8,S1SVCPCT   POINT TO RECEIVING FIELD IN SCREEN1
         BAL   R14,PERCENT
*
****
* SRB PART OF SUPERVISOR STATE
****
*
         LA    R6,ACTIVES    POINT TO BASE SUM OF BOTH CPUS
         LA    R7,SRBST      POINT TO STATISTIC
         LA    R8,S1SRBPCT   POINT TO RECEIVING FIELD IN SCREEN1
         BAL   R14,PERCENT
*
****
* OTHER PART OF SUPERVISOR STATE
****
*
         LA    R6,ACTIVES    POINT TO BASE SUM OF BOTH CPUS
         LA    R7,OTHER      POINT TO STATISTIC
         LA    R8,S1OTHPCT   POINT TO RECEIVING FIELD IN SCREEN1
         BAL   R14,PERCENT
         TITLE 'CPU - COMPUTE AND FORMAT RANK STATISTICS'
****
* RANK PROGRAM NAMES
****
*
         LA    R0,HASHNAME-HASHBKTS    DISPL. OF ID FIELD
         LA    R1,L'HASHNAME          LTH. OF ID FIELD
         LA    R2,15        NBR OF RANKINGS
         L     R6,PGMTABLE             GET ADDRESSABILITY
         USING HASHTAB,R6
         LA    R3,HASHBKTS             START OF TABLE
         DROP  R6
         LA    R4,BUKTSIZE             SIZE OF ELEMENT
         LR    R5,R3                   1 SHORT OF TABLE END
         A     R5,PGMLIMIT
         LA    R6,HASHCNT-HASHBKTS+1   LAST 3 BYTES OF COUNT FIELD
         LA    R9,PGMRANK
         BAL   R14,RANK
         LA    R1,PGMRANK              START OF FROM TABLE
         LA    R2,28                   ELEMENT SIZE
         LA    R3,PGMRANKX-1           END OF FROM TABLE
         LA    R4,8                    LTH OF ID FIELD
         LA    R5,S1L6                 POSN OF FIRST ID
         LA    R6,S1L20                POSN OF LAST ID
         BAL   R14,MOVE
         EJECT
****
* RANK SVC NUMBERS
****
*
         LA    R0,0                   DISPL. OF ID FIELD - POSITIONAL
         LA    R1,0                   LTH. OF ID FIELD - POSITIONAL
         LA    R2,15                  NBR OF RANKINGS
         LA    R3,SVCS                 START OF TABLE
         LA    R4,3                    SIZE OF ELEMENT
         LA    R5,SVCS+256*3-1         1 SHORT OF TABLE END
         LA    R6,0                    COUNT FIELD IS ENTIRE TABLE ELEM
         LA    R9,SVCRANK
         BAL   R14,RANK
         LA    R1,SVCRANK              START OF FROM TABLE
         LA    R2,28                   ELEMENT SIZE
         LA    R3,SVCRANKX-1           END OF FROM TABLE
         LA    R4,0                    LTH OF ID FIELD - INDICATE POSNL
         LA    R5,S1L6+20              POSN OF FIRST ID
         LA    R6,S1L20+20             POSN OF LAST ID
         BAL   R14,MOVE
         EJECT
****
* RANK PERFORMANCE GROUP NUMBERS
****
*
         LA    R0,0                   DISPL. OF ID FIELD
         LA    R1,2                   LTH. OF ID FIELD
         LA    R2,15                  NBR OF RANKINGS
         LA    R3,PG                   START OF TABLE
         LA    R4,5                    SIZE OF ELEMENT
         LA    R5,PG+PGNBR*5-6         1 SHORT OF TABLE END
         LA    R6,2                    COUNT FIELD IS ENTIRE TABLE ELEM
         LA    R9,PGRANK
         BAL   R14,RANK
         LA    R1,PGRANK               START OF FROM TABLE
         LA    R2,28                   ELEMENT SIZE
         LA    R3,PGRANKX-1            END OF FROM TABLE
         LA    R4,2                    LTH OF ID FIELD
         LA    R5,S1L6+37              POSN OF FIRST ID
         LA    R6,S1L20+37             POSN OF LAST ID
         BAL   R14,MOVE
         EJECT
****
* RANK PROTECT KEYS
****
*
         LA    R0,0                   DISPL. OF ID FIELD - POSITIONAL
         LA    R1,0                   LTH. OF ID FIELD - POSITIONAL
         LA    R2,15                  NBR OF RANKINGS
         LA    R3,KEYS                 START OF TABLE
         LA    R4,3                    SIZE OF ELEMENT
         LA    R5,KEYS+15*3-1          1 SHORT OF TABLE END
         LA    R6,0                    COUNT FIELD IS ENTIRE TABLE ELEM
         LA    R9,KEYRANK
         BAL   R14,RANK
         LA    R1,KEYRANK              START OF FROM TABLE
         LA    R2,28                   ELEMENT SIZE
         LA    R3,KEYRANKX-1           END OF FROM TABLE
         LA    R4,0                    LTH OF ID FIELD - INDICATE POSNL
         LA    R5,S1L6+53              POSN OF FIRST ID
         LA    R6,S1L20+53             POSN OF LAST ID
         BAL   R14,MOVE
         TITLE 'CPU - PRIMARY DISPLAY OUTPUT'
         MVC   S1L5(14),=C'PROGRAM   PCT.'
         MVC   S1L5+20(9),=C'SVC  PCT.'
         MVC   S1L5+37(8),=C'PG  PCT.'
         MVC   S1L5+53(9),=C'KEY  PCT.'
*        MVC   S1L1PAD(4),=C'TEST' *****FOR TESTING ONLY*****
         MVC   S1L22(LTERMMSG),MTERMMSG
         TRMIO IOCB,CONV,FORMAT=SCREEN1,IMAGE=SCREEN1A,RESTORE=YES,    *
               RESET=YES
         BAL   LINKREG,CKINPUT
         B     RESTART       USER PRESSED CLEAR
         CLI   IOCBAID,AIDENT
         B     RESTART       USER PRESSED ENTER
         TITLE 'CPU - SPECIAL SERVICE ROUTINES'
****
* ROUTINE TO CHECK FOR UNEXPECTED TERMINAL INPUT
* NOTE THAT ROUTINE RETURNS TO NSI IF USER ENTERS CLEAR, AND TO
* NSI+4 IF USER PRESSES ANY OTHER NON-TERMINATION KEY
****
*
CKINPUT  EQU   *
         CLI   IOCBAID,AIDPF12      TERMINATE IMMEDIATELY
         BE    TERMNORM
         CLI   IOCBAID,AIDPA1       TERMINATE IMMEDIATELY
         BE    TERMNORM
         CLI   IOCBAID,AIDCLR       RETURN TO NSI, NULL INPUT
         BER   LINKREG
         LA    LINKREG,4(,LINKREG)  RETURN TO NSI+4
         BR    LINKREG
*
****
* ROUTINE TO CALCULATE PERCENT TO ONE DECIMAL AND EDIT THE RESULT
* INTO A DISPLAY FIELD.
* ENTERED VIA R14, WITH R6 POINTING TO PERCENTAGE BASE, R7 POINTING TO
* STATISTIC BEING PERCENTAGED, AND R8 POINTING TO RECEIVING FIELD IN
* DISPLAY SCREEN. BASE AND STATISTIC MUST BE PACKED DECIMAL FIELDS,
* EACH 3 BYTES LONG. RECEIVING FIELD BEGINS WHERE THE EDIT PADDING
* CHARACTER GOES.
****
*
PERCENT  EQU   *
         ZAP   PCTWORK,0(3,R7)       STATISTIC X 1000
         MP    PCTWORK,=P'1000'
         DP    PCTWORK,0(3,R6)       DIVIDED BY BASE
         MVC   0(7,R8),PCTEDT
         ED    0(7,R8),PCTWORK
         MVC   0(5,R8),2(R8)         SHIFT EDITED RESULT LEFT 2 POSNS
         MVC   5(2,R8),=C'  '        AND CLEAR RIGHTMOST CHARS
         BR    LINKREG
         EJECT
****
* ROUTINE TO RANK TABLE ENTRIES FROM HIGHEST TO LOWEST VALUE.
* PROCESSES AN INPUT RAW-COUNT TABLE AND CREATES AN OUTPUT PERCENT-
* RANKING TABLE WHOSE ENTRIES CAN THEN BE MOVED INTO A DISPLAY.
* ALL INPUT COUNT FIELDS MUST BE 3 BYTES, PACKED DECIMAL.
* INPUT TABLE LIMITED TO MAX 100 ENTRIES.
* INPUT AND OUTPUT TABLES MUST BE DEFINED BY CALLER.
* REGS 0-6, AND 9 MUST BE SET UP BY CALLER AND MAY BE ADJUSTED
* OR USED BY ROUTINE AS IT PROCESSES.
* ID FIELDS MAY BE FROM 0 TO 8 BYTES IN LENGTH. 0 LENGTH SIGNIFIES
* THAT ID IS THE POSITION OF THE ELEMENT WITHIN THE INPUT-TABLE.
* THE RANKING FIELD IS CONVERTED FROM RAW COUNT TO PERCENT OF SAMPLES
* WHEN CPU WAS BUSY. PERCENT IS TRUNCATED TO NEAREST TENTH.
* REGISTER USAGE IS --
* 0   DISPLACEMENT OF I/P TABLE ELEMENT-ID FIELD
* 1   LENGTH OF ABOVE FIELD (0 MEANS ID IS ELEMENT-POSITION)
* 2   NUMBER OF RANKINGS WANTED
* 3   LOOP CONTROL, POINTS TO CURRENT INPUT TABLE ELEMENT
* 4   LOOP CONTROL, SIZE OF INPUT TABLE ELEMENT
* 5   LOOP CONTROL, END OF LAST INPUT TABLE ELEMENT
* 6   DISP OF I/P COUNT FIELD WITHIN TABLE ELEMENT
* 7   WORK, USED BY PERCENT SERVICE ROUTINE
* 8   WORK, USED BY PERCENT SERVICE ROUTINE
* 9   START OF O/P RANK TABLE, ADJUSTED UP ONE ELEMENT FOR EACH RANK
****
*
         USING RANKTBLE,R9
RANK     EQU   *
         ST    R14,RANKEXIT  PRESERVE LINKING REGISTER
         BCTR  R1,0       ADJUST ID-LENGTH LENGTH FOR EXECUTE INSTR
         AR    R3,R6      ADJUST LOOP CTL FOR DISPLACEMENT OF COUNT
         AR    R5,R6      FIELD WITHIN INPUT COUNTER ENTRY
         SR    R0,R6      ADJUST RELATIVE DISPLACEMENT OF ID FIELD
         ST    R3,RANKSAVE SAVE TO INIT ON EACH NEW PASS
*
****
* REG 6 IS NOW FREE
****
*
         SH    R9,=H'28'        INIT OUTER LOOP
NEXTPASS EQU   *
         L     R3,RANKSAVE      RESTORE STARTING POINT IN I/P TABLE
         LA    R9,28(,R9)       POINT TO NEXT OUTPUT TABLE ENTRY
         ZAP   CURPOSN,=P'-1'   INIT INPUT-TABLE ELEMENT POSITION
         ZAP   MAXCOUNT,0(3,R3) INIT HIGHEST-COUNT-FOUND RAW-COUNT
         ZAP   0(3,R3),=P'-1'       AND SET COUNT SO IT WONT BE USED
         ST    R3,MAXADDR       INIT HIGHEST-COUNT-FOUND TABLE ADDRESS
         ZAP   MAXPOSN,=P'0'    INIT HIGHEST-COUNT-FOUND TABLE-POSN
         LTR   R1,R1            WHAT WILL BE USED FOR IDENT?
         BM    NXTENTRY         POSITIONAL, NOTHING ELSE NEEDED
         AR    R3,R0            NAME-FIELD, ADJUST POINTER TO IT
         EX    R1,NAMEMOVE      INIT THE O/P TABLE ID-FIELD
         SR    R3,R0            AND RESET THE POINTER
         EJECT
****
* NEXT INSTRUCTIONS DO MOST OF THE WORK.
* THEY MAKE COMPLETE PASS THROUGH INPUT TABLE TO FIND HIGHEST RAW COUNT
* IF CURRENT ENTRY IS HIGHEST YET IT WILL BE STORED AND ZEROED SO IT
* CAN'T COMPETE ON NEXT PASS
****
*
NXTENTRY EQU   *
         TM    2(R3),B'00001100' PACKED DECIMAL?
         BNO   CTREMPTY          NO, MUST BE AT END OF COUNTERS
         LTR   R1,R1           ARE COUNTERS POSITIONAL?
         BM    COUNTPOS        YES, BYPASS CHECK FOR ZERO VALUE
         CP    0(3,R3),=P'0'     ANY COUNT RECORDED?
         BE    CTREMPTY          NO, AT END OF NAME-ORIENTED COUNTERS
COUNTPOS EQU   *
         AP    CURPOSN,=P'1'    COUNT 1 POSITION IN TABLE
         CP    MAXCOUNT,0(3,R3)   IS THIS COUNT HIGHEST SO FAR?
         BL    STORRANK           YES, GO STORE IT
ADVANCE1 EQU   *
         BXLE  R3,R4,NXTENTRY     NO, CHECK NEXT ENTRY
*
****
* NOW AT END OF ONE PASS THROUGH INPUT TABLE.
* HAVE TO FORMAT THE VALUE AND ID OF HIGHEST ENTRY FOUND.
****
*
CTREMPTY EQU   *
         LTR   R1,R1            IS TABLE POSITION THE ELEMENT ID?
         BNM   CALCPCT          NO, GO TAKE CARE OF PERCENT
         MVC   EDPOSN,POSNEDT   YES, EDIT POSITION NUMBER
         ED    EDPOSN,MAXPOSN
CALCPCT  EQU   *
         LA    R6,ACTIVES  SET UP FOR PERCENT SERVICE ROUTINE - BASE
         LA    R7,MAXCOUNT  - STATISTIC
         LA    R8,MAXPCT    - EDITED PERCENT
         BAL   R14,PERCENT
         BCT   R2,NEXTPASS    ANY MORE RANKS WANTED?
         L     R14,RANKEXIT   WAS CHANGED IN LINK TO PERCENT ROUTINE
         BR    R14
STORRANK EQU   *
         L     R6,MAXADDR           RESTORE PREVIOUS HIGH COUNT IN
         ZAP   0(3,R6),MAXCOUNT    ITS ORIGINAL TABLE ENTRY
         ZAP   MAXCOUNT,0(3,R3)     NOW STORE THE NEW HIGH
         ST    R3,MAXADDR          AND ITS ADDRESS
         ZAP   0(3,R3),=P'-1'        SET COUNT SO IT WONT BE REUSED
         LTR   R1,R1            IS POSITION TO BE THE IDENT?
         BM    STORPOSN
         AR    R3,R0            ADJUST PTR TO TABLE-ELEMENT ID FIELD
         EX    R1,NAMEMOVE      NO, MOVE IDENT FROM TABLE
         SR    R3,R0            RESET PTR TO TABLE-ELEMENT COUNT FIELD
         B     ADVANCE1         AND RETURN TO CHECK NEXT ENTRY
NAMEMOVE MVC   MAXID-RANKTBLE(0,R9),0(R3)  EX'ED INSTRUCTION
STORPOSN EQU   *
         ZAP   MAXPOSN,CURPOSN  STORE I/P ELEMENT TABLE POSN IN O/P
         B     ADVANCE1
         DROP  R9
         EJECT
****
* ROUTINE TO MOVE RANK TABLE ENTRIES FROM THE RANK TABLES TO THE
* MAIN DISPLAY SCREEN.
* IT STARTS AT FRONT OF TABLE AND CONTINUES MOVING ENTRIES UNTIL
* THE RANK TABLE END OR THE FIRST EDITED PERCENT VALUE OF 0.0 IS
* REACHED, WHICHEVER HAPPENS FIRST.
* IT MOVES DATA FROM EACH TABLE ELEMENT EXACTLY ONE LINE (79 CHARS)
* BELOW THE PREVIOUS ONE, BUILDING A TABLE ON THE SCREEN. PERCENT
* IS PUT JUST AFTER THE ID, EXACT POSITION DEPENDING ON THE ID'S
* LENGTH.
* IT USES REGISTERS 1-7. ON ENTRY, REGISTERS MUST BE -
* 1 START OF RANK TABLE
* 2 SIZE OF RANK TABLE ELEMENT
* 3 1 BEFORE END OF RANK TABLE
* 4 LENGTH OF ID-FIELD - 0 INDICATES ID IS POSITIONAL INSTEAD OF EBCDIC
* 5 POSITION OF FIRST ID FIELD WITHIN DISPLAY
* 6 POSITION OF LAST ID FIELD WITHIN DISPLAY
****
*
         USING RANKTBLE,R1
MOVE     EQU   *
         BCTR  R4,0
         LA    R7,78(,R6)
         LA    R6,79
MOVE2    EQU   *
         CLC   =C'0.0',MAXPCT+2  ANY MORE NON-ZERO RANKS?
         BER   R14               NO, RETURN TO CALLER
         LTR   R4,R4
         BM    MOVEPOSN
         EX    R4,MOVEMOVE
         AR    R5,R4
         MVC   2(5,R5),MAXPCT-RANKTBLE(R1)
         SR    R5,R4
NXTLINE  EQU   *
         BXLE  R5,R6,MOVAGAIN
         BR    R14
MOVEMOVE MVC   0(0,R5),MAXID-RANKTBLE(R1)
MOVAGAIN EQU   *
         BXLE  R1,R2,MOVE2
         B     MOVE2
MOVEPOSN MVC   0(3,R5),EDPOSN+1-RANKTBLE(R1)
         MVC   4(5,R5),MAXPCT-RANKTBLE(R1)
         B     NXTLINE
         TITLE 'CPU - ERROR ROUTINES'
****
* LOAD FOR EP=STATSTDE WAS UNSUCCESSFUL
****
*
NODIE    EQU   *
         MVC   L2(LNODIE),MNODIE
MSGABORT EQU   *
         MVC   L3(LTERMMSG),MTERMMSG   REMIND USER HOW TO TERMINATE
         TRMIO IOCB,CONV,FORMAT=FORMAT,IMAGE=SCREEN,RESTORE=YES,       *
               RESET=YES,BEEP=YES
         BAL   LINKREG,CKINPUT
         B     MSGABORT        USER ENTERED CLEAR, MESSAGE AGAIN
         CLI   IOCBAID,AIDENT  DID USER PRESS ENTER?
         BE    RESTART         YES, REFRESH THE COMMAND
         B     MSGABORT        NO, MESSAGE AGAIN
*
****
* DIE ACTIVE BIT NOT TURNED ON, EVEN THOUGH MODULE AND COUNTERS
* HAVE BEEN LOCATED
****
*
DIEDEAD  EQU   *
         MVC   L2(LDIEDEAD),MDIEDEAD
         B     MSGABORT
*
****
* GETMAIN FAILED FOR PRIVATE BUFFER AREA, REGION TOO SMALL
****
*
TOOSMALL EQU   *
         MVC   L2(LTOOSMAL),MTOOSMAL
         B     MSGABORT
         EJECT
****
* PAGEABLE BUFFERS DONT COVER LONG ENOUGH TIME SPAN TO PROCESS
****
*
TRYAGAIN EQU   *
         DCMSNULL FORMAT=FORMAT,IMAGE=SCREEN  CLEAN OUT TITLE INFO
         MVC   L2(LTRYAGN),MTRYAGN
         B     MSGABORT
*
****
* MORE THAN 30 DIFFERENT PERFORMANCE GROUPS ENCOUNTERED
****
*
EXCESSPG EQU   *
         DCMSNULL FORMAT=FORMAT,IMAGE=SCREEN  CLEAN OUT TITLE INFO
         MVC   L2(LEXCSPG),MEXCSPG
         B     MSGABORT
         EJECT
****
* ERROR MESSAGE TEXTS FOLLOW
****
*
MTOOSMAL DC    C'REGION TOO SMALL'
LTOOSMAL EQU   *-MTOOSMAL
MDIEDEAD DC    C'STATDIE NOT RUNNING'
LDIEDEAD EQU   *-MDIEDEAD
MNODIE   DC    C'UNABLE TO LOCATE STATDIE'
LNODIE   EQU   *-MNODIE
MTRYAGN  DC    C'STATDIE TIMESPAN TOO SHORT - TRY AGAIN IN ONE MINUTE'
LTRYAGN  EQU   *-MTRYAGN
MTERMMSG DC    C'USE PF12 TO END CPU COMMAND, ENTER TO REFRESH SCREEN'
LTERMMSG EQU   *-MTERMMSG
MEXCSPG  DC    C'MORE THAN 30 PERFORMANCE GROUPS - MODIFY CPU COMMAND'
LEXCSPG  EQU   *-MEXCSPG
         TITLE 'CPU - LOCALLY DEFINED CONSTANTS'
ZEROS    DC    4F'0'   TO INIT REGISTERS
PASSWORD DC    CL4'RSTR' USED TO INDICATE RESTART REQUEST
CNTRSIZE DC    A(MODULUS*4+BUKTNBR*BUKTSIZE)
PGMLIMIT DC    A(BUKTNBR*BUKTSIZE-1)   INPUT TO RANK ROUTINE
PACKINIT EQU   *
         DC    PL4'0'
         DC    24PL3'0'
KEYINIT  DC    16PL3'0'
         DC    XL3'00'                 STOPPER FOR RANK ROUTINE
SVCINIT  DC    64PL3'0'
         DC    XL3'00'                 STOPPER FOR RANK ROUTINE
PGINIT   DC    (PGNBR)X'000C00000C'
         DC    XL5'00'                 STOPPER FOR RANK ROUTINE
PCTEDT   DC    X'40202021204B20'       PERCENT TO 1 DECIMAL
READYEDT DC    X'4021204B20'           AVG READY TASKS TO 1 DECIMAL
SAMPLEDT DC    X'402020202120'         NUMBER OF SAMPLES
MINSEDT  DC    X'7A212020'             MINUTES IN TIME SPAN - W/COLON
HRSEDT   DC    X'40212020'             HOURS IN TIME SPAN
POSNEDT  DC    X'40202120'
         TITLE 'CPU - SCREEN DEFINITIONS'
****
* MAIN CPU-SAMPLING DISPLAY
****
*
SCREEN1  SFMT  BEEP=NO,RESTORE=YES,RESET=YES
S1UTILIT FIELD 10,INTEN=HI    'CPU UTIL. '
S1UTILIZ FIELD 23,INTEN=LO
S1SAMPLT FIELD 9,INTEN=HI    'SAMPLES  '
S1SAMPLE FIELD 13,INTEN=LO
S1L1PAD  FIELD 20            BALANCE OF FIRST LINE
S1USERT  FIELD 10,INTEN=HI    'USER STATE'
S1USERST FIELD 23,INTEN=LO
S1TIMEST FIELD 9,INTEN=HI    'TIMESPAN '
S1TIMESP FIELD 16,INTEN=LO
S1L2PAD  FIELD 17            BALANCE OF SECOND LINE
S1SUPVT  FIELD 10,INTEN=HI    'SUPV STATE'
S1SUPVST FIELD 23,INTEN=LO
S1READYT FIELD 12,INTEN=HI   'READY TASKS '
S1READYS FIELD 5,INTEN=LO
S1L3PAD  FIELD 25            BALANCE OF THIRD LINE
S1SVCPT  FIELD 25,INTEN=HI   'SUPV STATE PROFILE - SVC:
S1SVCPCT FIELD 7,INTEN=LO
S1SRBPT  FIELD 4,INTEN=HI    'SRB:'
S1SRBPCT FIELD 7,INTEN=LO
S1OTHEPT FIELD 6,INTEN=HI    'OTHER:'
S1OTHPCT FIELD 7,INTEN=LO
S1L4PAD  FIELD 17            BALANCE OF FOURTH LINE
S1L5     FIELD 79,INTEN=HI
S1L6     FIELD 79,INTEN=HI
S1L7     FIELD 79,INTEN=HI
S1L8     FIELD 79,INTEN=HI
S1L9     FIELD 79,INTEN=HI
S1L10    FIELD 79,INTEN=HI
S1L11    FIELD 79,INTEN=HI
S1L12    FIELD 79,INTEN=HI
S1L13    FIELD 79,INTEN=HI
S1L14    FIELD 79,INTEN=HI
S1L15    FIELD 79,INTEN=HI
S1L16    FIELD 79,INTEN=HI
S1L17    FIELD 79,INTEN=HI
S1L18    FIELD 79,INTEN=HI
S1L19    FIELD 79,INTEN=HI
S1L20    FIELD 79,INTEN=HI
S1L21    FIELD 79,INTEN=HI
S1L22 FIELD 79,INTEN=HI,CURSOR=YES
         SFEND
         TITLE 'CPU - LOCAL TERMINATION ROUTINES'
RESTART  EQU   *
         L     R8,PASSWORD      SET RESTART SWITCH
TERMNORM EQU   *
         CLC   PGMTABLE,=F'0'   WAS GETMAIN SUCCESSFUL?
         BE    FREEBUFS         NO, BYPASS FREEMAIN
         L     R2,CNTRSIZE
         LA    R3,PGMTABLE
         FREEMAIN EU,LV=(2),A=(3),SP=0
FREEBUFS EQU   *
         CLC   STATBUFS,=F'0'   WAS GETMAIN SUCCESSFUL?
         BE    CLRSCRN          NO, BYPASS FREEMAIN
         L     R2,BFPLSIZE
         LA    R3,STATBUFS
         FREEMAIN EU,LV=(2),A=(3),SP=0
         EJECT
****
* CLEAR SCREEN IN PREPARATION FOR EXITING THE COMMAND
****
*
CLRSCRN  EQU   *
         CL    R8,PASSWORD  IS THIS A RESTART REQUEST?
         BE    REFRESH      YES, GO REFRESH AND RE-EXECUTE
         DCMSNULL FORMAT=SCREEN1,IMAGE=SCREEN1A  *CHK
         TRMIO IOCB,WRITE,FORMAT=FORMAT,IMAGE=SCREEN,RESTORE=YES,      *
               RESET=YES,BEEP=NO
         SLR   R4,R4     CLEAR RETURN CODE
         TITLE 'CPU - STANDARD DCMS TERMINATION, SCREEN, CONSTANTS, AND*
                WORK AREAS'
         CNOP  0,4  PROTECT AGAINST BUG IN DCMSTOP MACRO
         DCMSTOP RC=(4),LIT=NO,SCREEN=YES,WORK=YES,IOCB=YES,           *
               SERV=YES
         TITLE 'CPU - SCREEN WORK AREAS'
SCRNEND  EQU   *                END OF SCREEN GENERATED BY DCMSTOP
SCRNSIZE EQU   SCRNEND-SCREEN   MAX SIZE OF SCREEN
         ORG   SCREEN
SCREEN1A EQU   *
         DSGEN SCREEN1          AREA TO BUILD MAIN DISPLAY SCREEN
         EJECT
         ORG   S1TIMESP         DEFINE SUBFIELDS FOR TIME SPAN COVERED
STRTHRS  DS    CL4              HOUR DIGITS OF START TIME
         ORG   *-1              OVERLAP DUE TO EDIT REQUIREMENTS
STRTMINS DS    CL4              MINUTE DIGITS OF START TIME
         DS    C                MAKE - SYMMETRICAL
ENDHRS   DS    CL4              HOUR DIGITS OF END TIME
         ORG   *-1              OVERLAP DUE TO EDIT REQUIREMENTS
ENDMINS  DS    CL4              MINUTE DIGITS OF END TIME
         ORG   SCRNEND          RESET TO END OF SCREEN-BUILD AREA
         TITLE 'CPU - PROGRAM COUNTERS AND WORK AREAS'
DBLWORD  DS    D                FOR CVD OPERATION
CURTIME  DS    XL8              FOR TIME STCK MACRO
LISTART  EQU   *
         GETMAIN EC,MF=L        TO GETMAIN THE PRIVATE BUFFER POOL
LISTEND  EQU   *
LISTLEN  EQU   (LISTEND-LISTART) LENGTH OF GETMAIN LIST
         ORG   LISTART
GETMLIST DS    XL(LISTLEN)
         ORG
STDEPTR  DS    F                PTR TO DIE'S FIXED BUFFER CTL INFO
STATBUFS DS    F                PTR TO PRIVATE BUFFER POOL
LASTIME  DS    F                FOR COMPUTING TIME RANGE
STARTIME DS    F                FOR COMPUTING TIME RANGE
RANKEXIT DS    A                FOR STORING LINK REG IN RANK ROUTINE
RANKSAVE DS    A                FOR STORING COUNT-FIELD PTR BETW PASSES
BFPLSIZE DS    A                SIZE OF PRIVATE COPY OF STATDIE BFRS
BUFPTRS  DS    3A               LOOP CONTROL FOR BUFFER DATA EXTR
PSWPTRS  DS    3A               LOOP CONTROL FOR PSW DATA EXTR
PGPTRS   EQU   *                LOOP CONTROL FOR PERF GROUP CTRS
PGSTART  DS    A
PGINCR   DS    A
PGEND    DS    A
PGMTABLE DS    A  PTR TO GETMAINED AREA FOR PROGRAM HASHING AND DATA
MINVALUE DS    PL2              FOR COMPUTING TIME RANGE
HRSVALUE DS    PL2              FOR COMPUTING TIME RANGE
TIMINTVL DS    PL2              FOR COMPUTING TIME RANGE
PCTWORK  DS    PL6   WORKING CTR FOR PERCENT CALCULATIONS
CURPOSN  DS    PL2   POSITION IN INPUT-TABLE FOR RANK ROUTINE
         EJECT
CTRSET   EQU   *  SET OF COUNTERS FOR GLOBAL SUMMARY DATA
PACKCTRS EQU   *
TCBRDYS  DS    PL4   COUNTER FOR NUMBER OF TCBS READY
SAMPLE   DS    PL3   COUNTER FOR NUMBER OF VALID SAMPLES
ACTIVES  DS    PL3   COUNTER FOR NUMBER OF SAMPLES WITH PSW ACTIVE
PBLMCNT  DS    PL3   COUNTER FOR NUMBER OF SAMPLES IN PROBLEM STATE
SUPVST   DS    PL3   COUNTER FOR NUMBER OF SAMPLES IN SUPERVISOR STATE
USERCNT  DS    PL3   COUNTER FOR NUMBER OF SAMPLES IN USER KEY
SRBST    DS    PL3   COUNTER FOR NUMBER OF SAMPLES IN SRB MODE
SVCST    DS    PL3   COUNTER FOR NUMBER OF SAMPLES IN SVC MODE
OTHER    DS    PL3   CTR FOR NUMBER OF SAMPLES NOT USER, SRB, OR SVC
KEYS     DS    17PL3 CTRS FOR NUMBER OF SAMPLES BY PROTECT KEY
SYNONYMS DS    PL3   CTR FOR NBR OF SYNONYM HITS DURING HASHING
PACKEND  EQU   *
SVCS     DS    257PL3 COUNTERS FOR NUMBER OF SAMPLES BY SVC NUMBER
PG       DS    31XL5  TAGS AND CTRS FOR NUMBER OF SAMPLES BY PERF GP
CTRSEND  EQU   *
CTRLENTH EQU   (CTRSEND-CTRSET)
NXTBUCKT DS    F       PTR TO NEXT AVAIL ENTRY IN PGM NAME TABLE
CDENAME  DS    0XL8    COPY OF PGM NAME FOR USE BY HASHING ALGORITHM
KEYBITS1 DS    XL2     PARTS OF
KEYBITS2 DS    XL2           PROGRAM NAME THAT WILL BE
KEYBITS3 DS    XL2              EXCLUSIVE-OR'D
KEYBITS4 DS    XL2                  TOGETHER.....
CURRPG   DS    CL3              FOR UNPACKING PERF. GROUP NUMBER
PGMRANK  DS    XL(28*15)        FOR RANKING PROGRAM NAMES
PGMRANKX EQU   *
SVCRANK  DS    XL(28*15)        FOR RANKING SVC NUMBERS
SVCRANKX EQU   *
PGRANK   DS    XL(28*15)        FOR RANKING PERF GROUP NUMBERS
PGRANKX  EQU   *
KEYRANK  DS    XL(28*15)        FOR RANKING PERF GROUP NUMBERS
KEYRANKX EQU   *
         TITLE 'CPU - LITERALS'
CPU      CSECT
         LTORG
         END
