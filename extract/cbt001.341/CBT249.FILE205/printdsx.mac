         TITLE 'PRINTDSX  RELEASE 2.0  11/29/79  M.J.SPRINZEN'
*        PRINT NOGEN
*
*  FUNCTION: THIS ROUTINE WILL PRINT (1) ALL MEMBERS OF A PDS, OR
*            (2) A SEQUENTIAL DATASET, OR (3) SPECIFIED MEMBERS OF
*            A PDS (PASSED IN A LIST).  FORMATTED PAGE HEADINGS
*            ARE PUT AT THE TOP OF EACH OUTPUT PAGE.
*
*  INPUT:  THE ONLY INPUT THIS PROGRAM EXPECTS ARE THE 18 PARMS
*          PASSED: DDNAME OUTPUT, DDNAME INPUT, IOPL (FOR PUTLINE),
*          INPUT DSNAME, FLAGS, ROUTELOC, MEMBER NAME *,LINESIZE,
*          LINECOUNT, START *, COUNT *, MEMPTR *, RANGE *,
*          MEMCOUNT (IF SELECT) *, VOLUME *, SRCHID *, SRCHLNG *,
*          SRCHLOC *                              * = OPTIONAL.
*
*  METHOD: FOR A PARTITIONED DATASET:
*            THE DIRECTORY IS FIRST OPENED AS A SEQUENTIAL DATASET.
*            ALL MEMBER NAMES AND TTR'S ARE READ AND PUT INTO A LIST
*            FORMATTED FOR THIS PROGRAMS USE. OPTIONALLY, A LIST IS
*            PASSED TO THIS ROUTINE (LIST IS GENERATED VIA "SELECT"
*            OPTION. THE PDS IS THEN CLOSED AND REOPENED USING BPAM.
*            DEPENDING ON THE RECFM ("F" OR "V" ALLOWED) DIFFERENT
*            SECTIONS OF CODE ARE BRANCHED TO. THE MEMBERS ARE WRITTEN
*            WITH A HEADING PUT ON EACH PAGE (OPTIONAL). PRINTDSX
*            ALSO WRITES (PUTLINE) A MESSAGE TO THE TERMINAL FOR EACH
*            MEMBER PRINTED. A SYNAD EXIT IS PROVIDED FOR READING THE
*            DIRECTORY.
*          FOR A SEQUENTIAL DATASET:
*            THE SAME CODE AS FOR A PDS IS USED EXCEPT THE DIRECTORY
*            READING IS BYPASSED. THIS WAS DONE TO SHARE THE BSAM
*            CODE FOR PROCESSING. A DCB ABEND EXIT IS PROVIDED IN
*            CASE THE MEMBER OF A PDS IS NOT THERE (IF MEMBER SUPLIED)
*
*  REGISTER USAGE:
*          5,12   USING FOR PROGRAM ADDRESSABILITY
*          11     USING FOR DCBD (ALSO CAN BE WORK)
*          13     USING FOR DSECT FOR RENT (1ST 16F ARE SAVEAREA)
*
*  PROGRAMMING NOTE: THIS MODULE HAS NUMEROUS ROUTINES EMBEDDED IN
*                    IT (WRITE,SEARCH,NEXTPAGE,MEMWRITE,CREATEIX...)
*                    WHICH RETURN TO R7. THESE ROUTINES SAVE AND
*                    RESTORE REGS THEY USE.
*
         SPACE 2
*        @MEMPERB AND @LSZMAX MAY BE EASILY CHANGED.
@MEMPERB EQU   40             NUMBER MEMBERS PER GETMAIN BLOCK
@MEMPER1 EQU   @MEMPERB+1
@LSZMAX  EQU   205            MAXIMUM LINESIZE PGM CAN HANDLE
@LSZMAX1 EQU   @LSZMAX-1
@LSZMIN  EQU   121            MINIMUM LINESIZE (DO NOT DEC W/O PGM)
@COLPAGE EQU   5              NUMBER OF COLS PER PAGE FOR INDEX
@IXSIZE  EQU   24             SIZE OF COLUMN FOR INDEX (CAN NOT BE <14)
SP1      EQU   7              SUBPOOL FOR GETMAINS
         EJECT
*
*   PRINTDSX CSECT
*
PRINTDSX CSECT
         SAVE  (14,12),,*         SAVE REGS
         LR    12,15              ESTABLISH ADDRESSABILITY
         LA    5,2048(12)
         LA    5,2048(5)       FOR USING
         USING PRINTDSX,12,5
* SAVE PARM POINTER IN R3
         LR    3,1
         SPACE 1
* GETMAIN FOR REENT
         GETMAIN R,LV=DSECT1L,SP=SP1
         SPACE 1
         ST    13,4(1)         SAVE R13 INTO NEW SAVEAREA
         ST    1,8(0,13)       STORE A(SAVEAREA) INTO OLD SAVE AREA
         LR    13,1            PUT SAVEAREA ADDR INTO R13
         USING DSECT1,13       ESTAB ADDRESS TO DSECT1
         EJECT
*        INITIALIZE GETMAINED AREA (DSECT1)
         SR    10,10
         ST    10,TOTOUT
         ST    10,PAGENO
         ST    10,ECBPUT
         ST    10,OUTCOUNT
         ST    10,INCOUNT
         STH   10,PUTMSG+2
         STH   10,SYNMSG+2
         LA    10,74
         STH   10,PUTMSG
         LA    10,120
         STH   10,SYNMSG
         SPACE 1
*        SETUP IOPL AND PUTLINE STUFF
         MVC   PUTLIST(12),PUTLIST#
*        PUT A(BUFFER) INTO PUTLINE LIST MACRO
         LA    10,PUTMSG
         ST    10,PUTLIST+4
         LA    10,ECBPUT
         ST    10,IOPL+8
         LA    10,PUTLIST
         ST    10,IOPL+12
         SPACE 1
*        INITIALIZE OUTPUT MESSAGES ETC
         MVC   SEQMSG(8),=XL8'4020202020202120'
         MVC   SEQMSG+8(70),=CL70' LINES ROUTED LOCAL'
         MVC   EDFMT(8),=XL8'4020202020202120'
         MVC   EDFMT2(6),=XL6'402020202020'
         MVC   SYNMSG(124),SYNMSG#    MOVE 2 HALFWORDS + MESSAGE
         MVC   HEADNG1(@LSZMAX),HEADNG1#
         MVC   HEADNG2(@LSZMAX),HEADNG2#
         MVC   MEMCOM1(@LSZMAX),MEMCOM1#
         MVC   MEMMSG(70),MEMMSG#
         SPACE 1
*        MOVE IN BLANKS
         MVC   MEMCOM2(@LSZMAX),BLANKS
         MVC   IXLINE(@LSZMAX),BLANKS
         MVC   MEMCOM2(@LSZMAX),BLANKS
         MVC   IXHEAD(1),=CL1'0'
         MVC   BUFOUTF(@LSZMAX),BLANKS
         SPACE 1
*        MOVE IN DECBS
         MVC   DECB1P(20),DECB1P#
         MVC   DECB2P(20),DECB2P#
         MVC   DECB1S(20),DECB1S#
         MVC   DECB2S(20),DECB2S#
         MVC   DECBF(20),DECBF#
         MVC   DECBDIR(20),DECBDIR#
         SPACE 1
*        MOVE DCBS INTO GETMAINED AREA
         MVC   DCBDIR(DCBDIRL),DCBDIR#
         MVC   DCBSEQ(DCBSEQL),DCBSEQ#
         MVC   DCBPO(DCBPOL),DCBPO#
         MVC   SYSOUTF(SYSOUTFL),SYSOUTF#
*        PUT DCB ADDRESSES INTO DECBS
         LA    10,DCBDIR
         ST    10,DECBDIR+8
         LA    10,DCBPO
         ST    10,DECB1P+8
         ST    10,DECB2P+8
         LA    10,DCBSEQ
         ST    10,DECB1S+8
         ST    10,DECB2S+8
         LA    10,SYSOUTF
         ST    10,DECBF+8
         SPACE 1
*        MOVE OPEN & CLOSE MACROS
         MVC   OPENDIR(4),OPENDIR#
         MVC   CLOSEDIR(4),CLOSEDR#
         MVC   OPENPO(4),OPENPO#
         MVC   OPENSEQ(4),OPENSEQ#
         MVC   OPENF(4),OPENF#
         MVC   CLOSE2(8),CLOSE2#
         SPACE 1
*        MOVE DCB ADDRESSES INTO OPEN & CLOSE MACROS
         LA    10,DCBDIR
         STCM  10,B'0111',OPENDIR+1
         STCM  10,B'0111',CLOSEDIR+1
         LA    10,DCBPO
         STCM  10,B'0111',OPENPO+1
         LA    10,DCBSEQ
         STCM  10,B'0111',OPENSEQ+1
         LA    10,SYSOUTF
         STCM  10,B'0111',OPENF+1
         EJECT
*        GET PARMS
         L     2,0(3)  LOAD 1ST ADDR (OF OUTPUT DDNAME)
         MVC   DDNAME1(8),0(2) STORE OUTPUT DDNAME
         L     2,4(3)  LOAD 2ND ADDR (OF INPUT  DDNAME)
         MVC   DDNAME2(8),0(2) STORE INPUT  DDNAME
         L     2,8(3)  LOAD 3RD ADDRESS (IOPL FOR PUTLINES)
         MVC   IOPL(8),0(2)  MOVE IOPL INTO IOPL FIELDS
*        NOTE: ONLY NEED FIRST 8 BYTES OF IOPL ABOVE..
         L     2,12(3) LOAD 4TH ADDRESS (OF INPUT DSNAME)
         MVC   HEADNG1+35(44),0(2)  MOVE DSNAME INTO HEADING
         L     2,16(3) LOAD 5TH ADDRESS (OF FLAGS FIELD)
         MVC   FLAGS(4),0(2)  MOVE FLAGS FIELD
         L     2,20(3) LOAD 6TH ADDRESS (OF ROUTELOC FIELD)
         CLC   0(7,2),=CL7' '     IS ROUTE BLANK?
         BE    RNOTS              NO
         MVC   SEQMSG+22(7),0(2)  MOVE ROUTE
RNOTS    EQU   *
         L     2,24(3) LOAD 7TH PARM ADDRESS (MAY NEED BELOW)
         ST    2,MEMADDR
         L     2,28(3) LOAD 8TH ADDRESS (OF LINESIZE FIELD)
         LH    2,0(2)  LOAD LINESIZE
         ST    2,LINESIZE     STORE AS FULLWORD
         L     2,32(3) LOAD 9TH ADDRESS (OF LINEMAX  FIELD)
         LH    2,0(2)  LOAD LINEMAX
         ST    2,LINEMAX      STORE AS FULLWORD
         L     2,36(3) LOAD 10TH PARM ADDRESS (START)
         MVC   START(4),0(2)
         L     2,40(3) LOAD 11TH PARM ADDRESS (COUNT)
         MVC   COUNT(4),0(2)
         L     2,44(3) LOAD 12TH PARM ADDRESS (MEMPTR)
         MVC   MEMPTR(4),0(2)
         MVC   MEMSTRT(4),0(2)
         L     2,48(3) LOAD 13TH PARM ADDRESS (RANGES)
         MVC   RANGES(16),0(2)
         L     2,52(3) LOAD 14TH PARM ADDRESS (MEMCOUNT - IF "SELECT")
         MVC   MEMCOUNT(4),0(2)
         L     2,56(3) LOAD 15TH PARM ADDRESS
         TM    FLAGS3,X'04' VOLUME SPEC. ?
         BZ    CONTI
         MVC   HEADNG1+18(4),=CL4'VOL='
         MVC   VOLUME(6),0(2)
         MVC   HEADNG1+22(6),VOLUME
CONTI    EQU   *
         L     2,60(3) LOAD 16TH PARM ADDRESS (SRCHID)
         MVC   SRCHID(L'SRCHID),0(2)
         L     2,64(3) LOAD 17TH PARM ADDRESS (SRCHLNG)
         MVC   SRCHLNG(4),0(2)
         L     2,68(3) LOAD 18TH PARM ADDRESS (SRCHLOC)
         MVC   SRCHLOC(4),0(2)
         SPACE 3
*        PDS OR SEQ  PROCESSING?
         TM    FLAGS,X'20' IS INPUT A PDS?
         BO    PDS         YES
         EJECT
*
*  SEQUENTIAL INPUT PROCESSING
*
*        1. IF MEMBER OF A PDS, MOVE MEMBER NAME TO OUTPUT HEADING
*        2. OPEN INPUT DCB
*        3. LOAD PROPER DECB ADDRESSES IN DECB ADDRESS FIELDS
*
         TM    FLAGS,X'10' WAS SEQDS A MEMBER OF A PDS?
         BZ    NOMEM       NO
         L     7,MEMADDR
         MVC   HEADNG1+8(8),0(7) MOVE MEMBER NAME INTO OUTPUT
         B     CONTM
NOMEM    MVC   HEADNG1+1(6),HEADNG1+7 ZILCH OUT MEMBER
CONTM    EQU   *
         SPACE 3
*        MOVE IN DDNAME AND OPEN DCB
         USING IHADCB,11   FOR MOVING IN DDNAMES
         LA    11,DCBSEQ   ALREADY USING R11
         MVC   DCBDDNAM(8),DDNAME2  MOVE DDNAME INTO DCB.
         OPEN  ,MF=(E,OPENSEQ) OPEN SEQUENTIAL DATASET
         LTR   15,15
         BNZ   ERROPENI
         OI    FLAGS3,X'40'   INDICATE SEQ DCB OPEN (IN CASE ERROR)
         SPACE 2
*        WAS DCB ABEND EXIT TAKEN? IF SO - TERMINATE.
         TM    FLAGS2,X'80'
         BZ    NOABEND        NO, CONTINUE
         L     13,SAVEAREA+4
         RETURN (14,12),RC=12
NOABEND  EQU   *
         SPACE 3
*        PUT SEQDS DECB ADDRESSES INTO DECB ADDRESS FIELDS TO USE
*        WITH READS AND CHECKS BELOW.
         LA    7,DECB1S
         ST    7,DECB1ADR
         LA    7,DECB2S
         ST    7,DECB2ADR
         B     COMCODE
         EJECT
*
*  PDS PROCESSING
*
*         1. GETMAIN FOR LIST OF MEMBER NAMES AND TTRS.
*         2. OPEN DIRECTORY AND READ MEMBER NAMES + TTRS, PUT IN LIST.
*         3. DO ADDITIONAL GETMAINS FOR LINKED LIST IF NECESSARY.
*         4. OPEN INPUT DCB  USING BPAM
*         5. LOAD PROPER DECB ADDRESSES IN DECB ADDRESS FIELDS
*         REGISTERS USED:
*           R2 USED AS POINTER INTO MEMLIST (LIST OF NAMES + TTRS)
*           R3 USED AS POINTER INTO DIR. BLK AS IT IS BEING ANALYZED
*           R4 COUNTER OF MEMBERS IN EACH BLOCK (MEMLIST)
*           R11 AS USING FOR DCBD - IHADCB DSECT
*
         SPACE 1
*        PUT PDSDS DECB ADDRESSES INTO DECB ADDRESS FIELDS
PDS      LA    7,DECB1P
         ST    7,DECB1ADR
         LA    7,DECB2P
         ST    7,DECB2ADR
         SPACE 2
*        SELECT OPTION ?
         TM    FLAGS2,X'08'   SELECT OPTION SPEC ?
         BO    OPENPDS        YES - SKIP DIRECTORY READ
         SPACE 2
*        GETMAIN FOR MEMLIST
*        GET A BLOCK FOR 1ST 40 ENTRIES. IF MORE THAN 40 MEMBERS,
*        WILL DO ADDTINAL GETS LATER AND LINK BLOCKS TOGETHER.
         LA    7,@MEMPER1*12   MEMBER ENTRIES IN MEMLIST +PTR
         GETMAIN R,LV=(7),SP=SP1 GETMAIN FOR MEMLIST
         ST    1,MEMPTR  STORE ADDR IN MEMPTR
         ST    1,MEMSTRT STORE ADDR IN MEMSTRT ALSO
         LR    2,1       FOR USE BELOW
         SPACE 3
*        MOVE IN DDNAME AND OPEN DCB
         LA    11,DCBDIR
         MVC   DCBDDNAM(8),DDNAME2  MOVE DDNAME INTO DCB.
         OPEN  ,MF=(E,OPENDIR) OPEN PDS AS SEQ TO READ DIRECTORY
         LTR   15,15
         BNZ   ERROPENS
         SPACE 3
*        READ DIRECTORY
         LA    4,@MEMPERB     FOR COUNTING NUMBER OF MEMBERS
DIRLOOP  LA    3,DIRBLOCK     KEEP ADDR OF DIR BLOCK IN R3
         READ  DECBDIR,SF,,(3),MF=E  GET A BLOCK
         CHECK DECBDIR
         MVC   LASTENT(8),0(3) SAVE HIGH KEY FOR COMPARISIONS
         LA    3,10(3)         POINT TO FIRST ENTRY (PAST KEY+LNGTH)
         B     WITHIN
         SPACE 3
*        LOOP THRU DIRECTORY BLOCK
NEXTMEM  IC    7,11(3)       INSERT "C" FIELD FROM DIRECTORY ENTRY
*        "C" FIELD - BIT 0 ALIAS, BIT 1-2 NO. OF USER TTRNS,
*                    BIT 3-7 NO. OF USER HALFWORDS.
         SLL   7,27          GET RID OF ALL BUT RIGHTMOST 5 BITS
         SRL   7,26          EFFEC. MULT BY 2 TO GET BYTES FROM HALFWDS
         AR    3,7           ADD NO. USER BYTES TO BUFFER PTR.
         LA    3,12(3)       ADD   12 = MEMBER NAME(8)+TTR(3)+"C"(1)
*        NOW R3 POINTS TO NEXT DIRECTORY ENTRY IN BUFFER.
WITHIN   TM    11(3),X'80'   IS THIS ENTRY AN ALIAS?
         BO    ALIAS          YES - IGNORE
         SPACE 1
*        IF RANGE OPTION SPECIFIED, ASSURE WITHIN RANGE
         TM    FLAGS2,X'10'   RANGE OPTION ?
         BZ    CONTP1         NO
         CLC   RANGES(8),0(3)
         BH    CONTP2         IGNORE ENTRY IF LESS THAN START RANGE
         CLC   RANGES+8(8),0(3)
         BNL   CONTP1         WITHIN RANGE - PROCESS
*        IF FELL THRU THEN END OF RANGE - INDICATE AND LEAVE
         MVC   0(8,2),HIGHFF  INDICATE LAST ENTRY
         B     ENDDIR
         SPACE 1
CONTP1   L     7,MEMCOUNT
         LA    7,1(7)         INCR COUNT BY 1
         ST    7,MEMCOUNT
         MVC   0(11,2),0(3) MOVE INTO MEMLIST, MEMBER NAME + TTR
         MVI   11(2),X'00'  MUST INSERT 0 FOR "K" FLD FOR FIND MACRO
         LA    2,12(2)      INCR POINTER INTO MEMLIST
         BCT   4,CONTP2     DECR COUNT IN THIS BLOCK
         SPACE 1
* NEED ANOTHER BLOCK FOR MEMBERS - DO GETMAIN
         LA    7,@MEMPER1*12  MEMBER ENTRIES IN MEMLIST +PTR
         GETMAIN R,LV=(7),SP=SP1
         MVC   0(8,2),LASTENTB INDICATE LAST ENTRY IN BLOCK
         ST    1,8(2)      LINK BLOCK WITH PREVIOUS
         LR    2,1         PUT ADDR OF BLOCK IN R2
         LA    4,@MEMPERB     FOR COUNTING NUMBER OF MEMBERS
         SPACE 1
CONTP2   EQU   *
ALIAS    CLC   LASTENT(8),0(3) WAS THIS LAST ENTRY IN THIS BLK
         BNE   NEXTMEM         NO
         CLC   HIGHFF(8),0(3)  WAS THIS LAST ENTRY IN DIRECTORY?
         BNE   DIRLOOP         NO
         SPACE 2
*  DECREASE COUNT BY 1 (DONT COUNT HIGHFF ENTRY)
         L     7,MEMCOUNT
         BCTR  7,0
         ST    7,MEMCOUNT
         SPACE 2
* LAST ENTRY FROM DIRECTORY READ
ENDDIR   CLOSE ,MF=(E,CLOSEDIR)
         SPACE 2
*  ASSURE SOME MEMBERS FOUND
         ICM    7,B'1111',MEMCOUNT
         BZ     ERRNOMEM
         SPACE 3
*  REOPEN DATASET AS PDS USING BPAM
*
*  STILL USING IHADCB,11   FOR MOVING IN DDNAMES
OPENPDS  LA    11,DCBPO
         MVC   DCBDDNAM(8),DDNAME2  MOVE DDNAME INTO DCB.
         OPEN  ,MF=(E,OPENPO)
         LTR   15,15
         BNZ   ERROPENI
         OI    FLAGS3,X'80'   INDICATE PDS DCB OPEN IN CASE OF ERROR
         EJECT
*
*    COMMON CODE FOR PDS + SEQ: AQUISITION OF BUFFERS, GET DATE+TIME, &
*                               CHECK DSORG.
         SPACE 1
*        GET TODAY'S DATE + TIME, PLACE IN OUTPUT BUFFER
COMCODE  EQU   *
         TIME
         STCM  0,15,TIMEX         PLACE TIME IN LOCATIO
         MVO   TIMEX(4),TIMEX(3)       HUNDREDTHS OUT
         OI    TIMEX+3,X'0F'           FIX SIGN
         UNPK  TIMEX(8),TIMEX(4)       UNPACK THE TIME
         MVC   TIMEX(2),TIMEX+2        BRING HOURS UP TO RIG
         MVC   TIMEX+3(2),TIMEX+4      BRING MINUTES UP TO R
         MVI   TIMEX+2,C':'            INSERT EDIT CHARACTE
         MVI   TIMEX+5,C':'              (CONTINUED)
*        INITIALIZE TABLE
         MVC   TABLE(TABLEL),TABLE#
         STCM  1,3,DATEX                STORE JULIAN DATE IN
         SRL   1,12                    LEAVE YEAR IN REG 1
         O     1,=F'15'                FIX SIGN
         STCM  1,7,DATEX+5               STORE PACKED YEAR
         DP    DATEX+5(3),=P'4'        DIVIDE FOR REMAINDER
         CLI   DATEX+7,X'0C'           CHECK FOR ZERO REMAIN
         BNE   $0018NLP       IN NOT LEAP YEAR SKIP
         AP    $0018FEB,=P'1' ELSE INCREMENT
         AP    $0018JAN,=P'1' BOTH FEBUARY AND JANR
$0018NLP STCM   1,3,DATEX+6   PLACE YEAR IN LOCATIO
         UNPK  DATEX+6(2),DATEX+6(2)   UNPACK THE YEAR
         ZAP   $0018DYS,$0018JAN
         LA    1,22                    SET 1 TO LENGTH OF TA
         SP    $0018DYS,DATEX(2)   GET COMPLEMENT OF DA
         ZAP   DATEX+4(2),=P'13'         INITIALIZE MONTHS OF
         LA    1,$0018JAN(1) LOAD 15 TO TABLE
$0018LU  SP    DATEX+4(2),=P'1'  SET MONTH DOWN BY 1
         CP    $0018DYS,0(2,1) CHECK FOR TABLE HIGH
         BL    $0018FD        HIT IF TABLE LOW
         BCTR  1,0                     SET 1 DOWN
         BCT   1,$0018LU      SET IT DOWN AGAIN
         SP    DATEX+4(2),=P'1'     DROP MONTH TO DEC
$0018FD  ZAP   DATEX+2(2),0(2,1) PUT IN DAYS
         SP    DATEX+2(2),$0018DYS
         UNPK  DATEX(2),DATEX+4(2)   MONTHS
         OI    DATEX+1,X'F0'
         UNPK  DATEX+3(2),DATEX+2(2)     UNPACK DAYS
         OI    DATEX+4,X'F0'
         MVI   DATEX+2,C'/'      INSERT EDIT CHARACTER
         MVI   DATEX+5,C'/'       (CONTINUED)
         B     $0018XT        SKIP AROUND LITERALS
TABLE#   DC    PL2'365'
         DC    PL2'365'
         DC    PL2'334'
         DC    PL2'306'
         DC    PL2'275'
         DC    PL2'245'
         DC    PL2'214'
         DC    PL2'184'
         DC    PL2'153'
         DC    PL2'122'
         DC    PL2'092'
         DC    PL2'061'
         DC    PL2'031'
$0018XT  EQU   *
         SPACE 1
*        MOVE DATE AND TIME INTO HEADING
         MVC   HEADNG1+93(8),TIMEX
         MVC   HEADNG1+81(8),DATEX
         SPACE 3
*        GET BUFFERS
         LH    7,DCBBLKSI  LOAD BLKSI INTO R7
         SLL   7,1            MULT BLKSI BY 2 FOR
         GETMAIN R,LV=(7),SP=SP1  2 BUFFERS
         SPACE 1
         ST    1,BUFADR1      STORE ADDR OF BUFFER 1.
         AH    1,DCBBLKSI     GET LOCATION OF 2ND BUFFER
         ST    1,BUFADR2      STORE ADDR OF BUFFER 2.
         SPACE 3
*        CHECK RECFM
*        IF ASA LET DEFAULT = NOHEADING, ELSE DEFAULT = HEADING
*           (UNLESS HEAD/NOHEAD EXPLICITELY SPECIFIED)
         TM    DCBRECFM,DCBRECCM  RECFM "M" ?              SCL 01/17/80
         BZ    CONTB1X        NO - GO ON                   SCL 01/17/80
         OI    FLAGS4,X'08'   INDICATE MACHINE C.C.        SCL 01/17/80
         B     RECFMM         CONTINUE AS IF RECFM 'A'     SCL 01/17/80
CONTB1X  EQU   *                                           SCL 01/17/80
         TM    DCBRECFM,DCBRECCA  RECFM "A" ?
         BZ    CONTB4         NO - LEAVE BIT AS "0" (INDICATES HEADNG)
RECFMM   OI    FLAGS4,X'80'   INDICATE ASA
         TM    FLAGS4,X'20'   HEAD/NOHEAD EXPLICITELY DEF ?
         BO    CONTB1         YES
         OI    FLAGS4,X'40'   INDICATE NOHEADING
CONTB1   DS    0H
*        IF "ASA" AND "NOH" THEN SEE IF  LRECL <= LINESIZE
         TM    FLAGS4,X'C0'   ASA AND NOH ?
         BZ    CONTB4         NO
         LH    7,DCBLRECL     GET INPUT LRECL FROM OPEN DCB
         L     9,LINESIZE
         LA    9,1(9)         INC BY 1 SINCE LINESIZE EXCLUDES ASA CHAR
         CR    7,9
         BNH   CONTB4         LRECL <= LINESIZE + 1
         MVC   PUTTEXT(70),TRUNCMSG
         PUTLINE MF=(E,IOPL)
CONTB4   DS    0H
         SPACE 1
*        CHECK RECORD TYPE
         OI    FLAGS,X'08'    TEMP INDICATE FIXED RECORDS
         TM    DCBRECFM,DCBRECF "F" FORMAT
         BO    CONTB5            YES
         XI    FLAGS,X'08'    INDICATE NOT FIXED RECORDS
         TM    DCBRECFM,DCBRECV "V" FORMAT
         BNO   ERRFORM        IF NOT - THEN ERROR
         TM    DCBRECFM,DCBRECSB SPANNED RECORDS ?
         BNO   CONTB5         IF NOT - O.K.
         B     ERRFORM
         SPACE 1
CONTB5   DS    0H
         EJECT
*        OPEN OUTPUT DCB & DO FIND (IF PDS)
*
         SPACE 1
*        OPEN OUTPUT DCB THAT SPECIFIES RECFM=F
*        STILL USING IHADCB,11   FOR MOVING IN DDNAME INTO OUTPUT DCB
         LA    11,SYSOUTF
         MVC   DCBDDNAM(8),DDNAME1  MOVE DDNAME INTO DCB.
         SPACE 2
         TM    FLAGS4,X'08'   MACHINE C.C.?                SCL 01/17/80
         BNO   NOMACH         NO; SKIP IT...      .        SCL 01/17/80
         NI    DCBRECFM,X'FF'-DCBRECCA  TURN OFF 'A'       SCL 01/17/80
         OI    DCBRECFM,DCBRECCM TURN ON 'M'               SCL 01/17/80
NOMACH   EQU   *                                           SCL 01/17/80
         SPACE 2                                           SCL 01/17/80
*        ASSURE  @LSZMIN <= BLKSIZE <= @LSZMAX
*         WHERE   @LSZMIN=121   AND  @LSZMAX=205
*         NOTE:   PARSE LIMITS LINESIZE TO  10 -> 999
         SPACE 1
         LA    7,@LSZMAX      205
         C     7,LINESIZE     GREATER ?
         BL    ERRLINS        YEP
         LA    7,@LSZMIN      121
         C     7,LINESIZE     LESS ?
         BH    ERRLINS        YEP
         L     7,LINESIZE     O.K. - WITHIN RANGE
         STH   7,DCBBLKSI     SAVE FOR OPEN
         L     7,LINESIZE     DECR LINESIZE BY 1 (IGNORE ASA
         BCTR  7,0                 CHAR FROM NOW ON)
         ST    7,LINESIZE
         SPACE 1
*        MOVE "PAGE NNNNN" INTO HEADING AND SAVE ADDRESS
         LA    7,HEADNG1      GET START ADDRESS
         A     7,LINESIZE     POINT JUST BEYOND HEADING
         S     7,=F'9'        LESS 9 BYTES
         MVC   0(10,7),=CL10'PAGE NNNNN' MOVE IN
         ST    7,APAGEHD      SAVE ADDRESS FOR NNNNN TO BE SET
         SPACE 2
         OPEN  ,MF=(E,OPENF)
         LTR   15,15
         BNZ   ERROPENJ
         OI    FLAGS3,X'20'   INDICATE SYSOUT DCB OPEN (IN CASE ERROR)
         SPACE 2
*  IF SEARCH OPTION, PRINT SEARCH INFO.
         TM    FLAGS3,X'10'   SEARCH OPTION ?
         BZ    CONTC03        NO
         PRINT NOGEN
         MVC   BUFOUTF+1(L'PMSG1),PMSG1  MOVE IN FIRST COMMENT
         WRITE DECBF,SF,,BUFOUTF,MF=E
         CHECK DECBF
*        CLEAR BUFFER & WRITE BLANK LINE
         MVC   BUFOUTF+1(@LSZMAX1),BLANKS
         WRITE DECBF,SF,,BUFOUTF,MF=E
         CHECK DECBF
*        MOVE IN SEARCH MESSAGE AND PRINT
         MVC   BUFOUTF+1(L'SRCHMSG),SRCHMSG MOVE IN MESSAGE
         L     7,SRCHLNG      GET LENGTH
         L     9,LINESIZE
         LA    10,L'SRCHMSG+1 GET LENGTH OF SRCHMSG
         SR    9,10           LINSIZE-L'SRCHMSG+1 IS BYTES AVAIL
         CR    7,9            IS THIS ENOUGH ?
         BNH   CONTC01        YES
         LR    7,9            OTHERWISE DEFAULT TO LINESIZE-L'SRCHMSG
CONTC01  EQU   *
         BCTR  7,0            DEC BY 1 FOR MVC
         LA    9,SRCHID
         EX    7,SRCHMVC      MOVE IN DATA
*        INSERT TIC MARK AFTER ARGUMENT
         LA    9,BUFOUTF+L'SRCHMSG+2 POINT PAST COMMENT
         AR    9,7            ADD LENGTH OF SEARCH ARGUMENT
         MVI   0(9),C''''     INSERT TIC MARK
         WRITE DECBF,SF,,BUFOUTF,MF=E  WRITE RECORD
         CHECK DECBF
         MVC   BUFOUTF+1(@LSZMAX1),BLANKS CLEAR BUFFER
*        IF LOCATION SPECIFIED, PRINT COMMENTS
         TM    FLAGS3,X'08'   LOC SPEC. ?
         BZ    CONTC02        NO
         MVC   BUFOUTF+1(L'LOCMSG),LOCMSG
         L     7,SRCHLOC      PRINT NUMBER
         CVD   7,WORKP           FIRST CONVERT
         MVC   BUFOUTF+21(8),EDFMT
         ED    BUFOUTF+21(8),WORKP+4 LOW ORDER 7 DIGITS IS SUFF.
         WRITE DECBF,SF,,BUFOUTF,MF=E
         CHECK DECBF
         MVC   BUFOUTF+1(@LSZMAX1),BLANKS CLEAR BUFFER
CONTC02  EQU   *
*        IF "NOH", INDICATE NEXT LINE IS TO START NEW PAGE
         TM    FLAGS4,X'40'   NOHEADING ?
         BZ    CONTC03        NO
         OI    FLAGS4,X'10'   INDICATE NEXT LINE STARTS NEW PAGE
         B     CONTC03
SRCHMVC  MVC   BUFOUTF+1+L'SRCHMSG(0),0(9)
SRCHMSG  DC    CL20'SEARCH ARGUMENT IS '''
PMSG1    DC    CL20'PRINTDS COMMENTS:'
LOCMSG   DC    CL20'SEARCH LOCATION IS'
CONTC03  DS    0H
         PRINT GEN
         SPACE 2
*        PRINT FIRST PAGE HEADING - IF "PAGE" IS ALSO REQSTD, DONT
*        FOR A PDS, OTHERWISE 2 FIRST PAGES WILL BE PRODUCED.
         TM    FLAGS,X'A0'  PDS+PAGE OPTIONS?
         BO    CONTC1       YES
         BAL   7,NEXTPAGE   PUT HEADING
CONTC1   DS    0H
         SPACE 3
*        LOAD R11 WITH DCB ADDR AND IF A PDS, MUST DO "FIND"
         LA    11,DCBPO     STILL USING 11 BUT POINT TO PDS DCB
         TM    FLAGS,X'20'  PDS?
         BO    CONTC2       YES
         LA    11,DCBSEQ    STILL USING 11 BUT POINT TO SEQ DCB
         B     PROCESS         BYPASS "FIND" LOGIC
CONTC2   DS    0H
         SPACE 2
*        BRANCH TO EODAD, ENTRY FIRST TO SHARE CODE FOR
*        FIND, PAGE FORMATTING ETC...RETURN WILL BE TO PROCESSF
         B     FIRST         RETURN WILL BE TO PROCESSF
         EJECT
PROCESS  DS    0H
*
*  PROCESS INPUT DATASET
*
*  PDS: LOOP TO FIND 1 MEMBER AT A TIME AND PRINT
*  SEQ: ONE PASS THRU MAJOR LOOP TO PRINT
*
*  SET R3 TO POINT TO LOCATION WITHIN BUFFER
*      R4 TO # RECS/BLK (FIXED) OR # BYTES/BLOCK (VARIABLE)
*      R11 USING FOR IHADCB- DCBD MACRO
         SPACE 2
         TM    FLAGS,X'08'  FIXED RECFM ?
         BNO   CONTC4       NO
         SPACE 2
* INIT DATA FOR FIXED RECFM
         LH    7,DCBLRECL   LOAD LRECL INTO R8
         ST    7,LRECL      SAVE AS FULLWORD
         SR    6,6
         D     6,LINESIZE   FIND # OUTPUT LINES PER INPUT RECORD
         LTR   6,6          REMAINDER ??
         BNZ   CONTC3       YES
         L     6,LINESIZE   FOR STORE
         B     CONTC31
CONTC3   LA    7,1(7)       INCR. BY 1
CONTC31  ST    7,LINEWRAP   SAVE # OUPUT LINES PER INPUT RECORD
         ST    6,LLAST      SAVE NO. BYTES IN LAST RECORD
         SPACE 1
* DO PRIMING READ
CONTC4   NI    FLAGS,B'11111011'  TURN OFF SECOND BUFFER BIT
         L     7,BUFADR1
         L     9,DECB1ADR LOAD ADDRESS OF DECB1
         READ  (9),SF,,(7),MF=E  INITIALIZATION READ.
         SPACE 2
*        WHICH BUFFER NEXT?
NEXTBUF  TM    FLAGS,X'04' FIRST BUFFER BEING READ?
         BO    SECBUF   NO
         L     9,DECB1ADR LOAD ADDRESS OF DECB1
         CHECK (9)      CHECK 1ST   READ NOW
         L     6,16(9)  LOAD ADDR OF IOB INTO R6 FROM DECB
         L     7,BUFADR2
         L     9,DECB2ADR LOAD ADDRESS OF DECB2
         READ  (9),SF,,(7),MF=E  ISSUE NEXT READ INTO 2ND BUFFER
         OI    FLAGS,X'04' RESET 1ST BUFFER SWITCH
         L     3,BUFADR1  LOAD BUFFER LOC INTO 3 FOR MVC
         B     CONTC5
         SPACE 1
SECBUF   L     9,DECB2ADR LOAD ADDRESS OF DECB2
         CHECK (9)        CHECK 2ND   READ NOW
         L     6,16(9)    LOAD ADDR OF IOB INTO R6 FROM DECB
         L     7,BUFADR1
         L     9,DECB1ADR LOAD ADDRESS OF DECB1
         READ  (9),SF,,(7),MF=E  READ 1
         XI    FLAGS,X'04' RESET 2ND BUFFER SWITCH
         L     3,BUFADR2  LOAD BUFFER LOC INTO R3 FOR MVC
         SPACE 1
* BRANCH TO SETUP FOR FIXED OR VARIABLE
CONTC5   TM    FLAGS,X'08'    FIXED ?
         BNO   CONTC6         NO
         SPACE 2
*        SETUP TO READ BUFFER FOR FIXED FORMAT
*        R6 STILL CONTAINS ADDR OF IOB
         LH    6,14(6)        LOAD LAST 2 BYTES FROM IOBCSW
         LH    7,DCBBLKSI     LOAD BLKSI INTO R7   (X'3E' OFFSET)
         SR    7,6      SUBTRACT BYTES LEFT OVER FROM BLKSIZE
         SR    6,6      FOR DIVIDE
         D     6,LRECL  GET BLOCKING FACTOR FOR "F" RECORDS
         LR    4,7     PUT BLOCKING FACTOR IN R4 FOR LOOP
         LA    4,1(4)  ADD 1 SINCE BCT DONE AT BEG OF LOOP
*        R4 NOW CONTAINS BLOCKING FACTOR FOR PREVIOUS READ
         B     CONTC7
         SPACE 2
*        SETUP TO READ BUFFER FOR VARIABLE FORMAT
CONTC6   EQU   *
         LH    4,0(3)         LOAD BDW
         LA    3,4(3)         INCR. BUFFER POINTER TO FIRST RECORD
         S     4,=F'4'        DEC # BYTES LEFT IN BLOCK
*        R4 NOW CONTAINS BYTES IN BUFFER-4
         SPACE 1
CONTC7   EQU   *
*
*  AT THIS POINT INPUT BUFFER IS FULL, R3 CONTAINS BUFFER ADDRESS, AND
*  R4 IS # RECS/BLK (FIXED) OR # BYTES/BLOCK (VARIABLE)
*
         EJECT
* LOOP THRU BUFFER READING 1 RECORD AT A TIME
         SPACE 1
*  R2 IS # OUTPUT LINES PER INPUT REC
*  R3 IS POINTER IN BUFFER
*  R4 IS # RECS/BLK (FIXED) OR # BYTES/BLOCK (VARIABLE)
*  R7 IS USED FOR BAL TO NEXTPAGE (AND WORK)
*  R6,8,9    FOR WORK
         SPACE 1
NEXTREC  TM    FLAGS,X'08'    FIXED ?
         BO    FIXEDF         YES
         SPACE 2
* VARIABLE FORMAT RECORD
         LTR   4,4            ANOTHER RECORD LEFT ?
         BZ    BUFDONE        NO
         LH    7,0(3)         LOAD RDW
         SR    4,7            DECREASE BYTES LEFT IN BLOCK
         LA    3,4(3)         POINT PAST RDW
         S     7,=F'4'        DEC RECSIZE BY RDW
         ST    7,LRECL        SAVE LRECL FOR SEARCH ROUTINE
         SR    6,6            FOR DIVIDE
         D     6,LINESIZE     FIND # LINES PER INPUT RECORD
         LTR   6,6            REMAINDER ?
         BZ    CONTL1
         LA    7,1(7)         INCR. R7 IF REMAINDER
         B     CONTL2
CONTL1   L     6,LINESIZE     LAST RECORD WILL BE LINESIZE BYTES
CONTL2   LR    2,7            R2 = # OUTPUT LINES PER INPUT RECORD
         ST    6,LLAST        SAVE LENGTH OF LAST LINE
         B     CHECK
         SPACE 2
* FIXED FORMAT RECORD
FIXEDF   L     2,LINEWRAP     LOAD # OUTPUT LINES PER INPUT RECORD
         BCT   4,CHECK        ANY MORE FIXED RECORDS IN BLOCK ?
         B     BUFDONE        NO
         SPACE 3
*        START OPTION ?  MAY NEGATE WRITE
CHECK    TM    FLAGS2,X'20'   START ?
         BZ    CONTL3         NOT SPEC
         L     6,INCOUNT
         LA    6,1(6)         INC SINCE THIS RECORD NOT YET COUNTED
         C     6,START        START WRITING YET?
         BL    RECCOMP        NO
*        START WRITING - RESET INCOUNT & SWITCH START FLAG BITS
         LA    6,0
         ST    6,INCOUNT      STORE COUNT OF 0
         XI    FLAGS2,X'20'   TURN OFF START OPTION BIT
         OI    FLAGS2,X'02'   INDICATE SWITCH FOR EODADP ROUTINE
         SPACE 1
*        CHECK IF COUNT OPTION SPEC
CONTL3   TM    FLAGS2,X'40'   COUNT ?
         BZ    CONTL4         NOT SPEC
         L     6,INCOUNT
         LA    6,1(6)         INC SINCE THIS RECORD NOT YET COUNTED
         C     6,COUNT        ALL PRINTED ?
         BNH   CONTL4         NO
*        IF FELL THRU, SIMULATE END OF DATASET
*        MUST DO CHECK FIRST FOR OUTSTANDING READ
         TM    FLAGS,X'04'    1ST BUFFER BEING READ ?
         BO    SECBUF2        NO
         L     6,DECB1ADR     LOAD DECB ADDR FOR CHECK
         B     CHECKM
SECBUF2  L     6,DECB2ADR
CHECKM   CHECK (6)
*        BRANCH TO PROPER END OF DATA ROUTINE
         TM    FLAGS,X'20'    PDS ?
         BO    EODADP         YES
         B     EODADS
CONTL4   EQU   *
         SPACE 2
*    SEARCH OPTION SPEC. ?  IF SO , BRANCH TO SEARCH ROUTINE
         TM    FLAGS3,X'10'   SEARCH OPTION ?
         BZ    CONTL7         NO
         BAL   7,SEARCH
         LTR   7,7            SHOULD RECORD BE PRINTED ?
         BM    RECCOMP        NO
CONTL7   EQU   *
         EJECT
* PRINT 1 INPUT RECORD (MAY BE MULTIPLE OUTPUT RECORDS)
         SPACE 1
PRNTREC  DS    0H
         TM    FLAGS4,X'C0'   NOH AND ASA SPEC. ?
         BNO   NOASA          NO - GO DO PRINTING WITH HEADING
         SPACE 2
*        "ASA" & "NOH" - PRINT RECORD USING USER ASA WITHOUT HEADING
         TM    FLAGS,X'08'    FIXED ?
         BO    CONTG1         YES
         L     9,LINESIZE     OTHERWISE
         BCTR  9,0              BLANK OUT BUFFER SINCE PREVIOUSLY
         EX    9,MVCBLNK        WRITTEN RECORD MAY HAVE BEEN SMALLER
CONTG1   L     9,LRECL        GET LRECL
         L     7,LINESIZE      FOR "F" OR "V" AT THIS POINT
         LA    7,1(7)         INC BY 1 SINCE LINESIZE DOESNT HAVE ASA
         CR    9,7            ASSURE  LRECL <= LINESIZE + 1
         BNH   CONTG2         YES
         LR    9,7            ELSE JUST MOVE LINESIZE + 1  BYTES
CONTG2   BCTR  9,0            DEC BY 1 FOR MVC
         EX    9,MVCRECA      R3 POINTS TO RECORD IN BUFFER
         LA    8,BUFOUTF       LOAD PTR FOR "WRITE" ROUTINE
         BAL   7,WRITE        WRITE RECORD
         B     RECCOMP
         SPACE 2
*  PRINT FULL RECORD USING SPECIFIC ASA CHARS - WRAPAROUND IF REQ.
NOASA    LR    6,3            USE R6 AS POINTER IN BUFFER
LOOPWRAP L     9,LINESIZE     WILL MOVE LINESIZE FOR OUTPUT
         BCTR  9,0              DEC BY 1 FOR MVC
         C     2,=F'1'        LAST LINE OF WRAP ?
         BNE   CONTG3         NO
         EX    9,MVCBLNK      MOVE IN BLANKS
         L     9,LLAST        WILL MOVE LAST LINE OF WRAP
         BCTR  9,0             DEC BY 1 FOR MVC
CONTG3   EX    9,MVCREC       MOVE RECORD
         LA    8,BUFOUTF       LOAD PTR FOR "WRITE" ROUTINE
         BAL   7,WRITE        WRITE RECORD
         AR    6,9             POINT TO NEXT POS IN BUFFER
         LA    6,1(6)         INC BY 1 SINCE DEC ABOVE
*        FOLOWING IS DONE IN CASE "LIST" OPTION USED IN ROUTINE "WRITE"
         OI    FLAGS3,X'01'   INDICATE 1ST LINE OF WRAPAROUND PRINTED
         BCT   2,LOOPWRAP     ANY MORE OUTPUT LINES FOR THIS RECORD ?
         NI    FLAGS3,B'11111110' TURN OFF 1ST LINE OF WRAP PRINTED
         B     RECCOMP        NO, GET NEXT INPUT RECORD
         SPACE 2
*  MVCS FOR EXECUTE
MVCREC   MVC   BUFOUTF+1(0),0(6) MOVE RECORD
MVCRECA  MVC   BUFOUTF(0),0(3)   MOVE RECORD WITH ASA CHAR
MVCBLNK  MVC   BUFOUTF+1(0),BLANKS CLEAR BUFFER
         SPACE 2
* RECORD NOW PRINTED - INC COUNT, BUF PTR, GO PRINT NEXT RECORD
RECCOMP  L     7,INCOUNT
         LA    7,1(7)         INCR COUNT OF INPUT RECORDS
         ST    7,INCOUNT
         A     3,LRECL        POINT PAST THIS RECORD IN BUFFER
         B     NEXTREC
         SPACE 2
BUFDONE  B     NEXTBUF        RETURN
         EJECT
*        WRITE: ROUTINE TO PRINT ONE LINE
*        R7 - RETURN, R8 - BUFFER
WRITE    DS    0H
         STM   7,8,WRITESV    SAVE REGS USED
         SPACE 2
*  SEE IF MEMBER COMMENT IS TO BE WRITTEN PRIOR TO THIS LINE
         TM    FLAGS3,X'02'
         BZ    CONTW1         NO
         BAL   7,MEMWRITE     YES
         XI    FLAGS3,X'02'   TURN OFF INDICATOR
CONTW1   EQU   *
         SPACE 2
* INSERT ASA CHAR IF THIS LINE SHOULD START NEW PAGE
         TM    FLAGS4,X'10'   NEW PAGE ?
         BZ    CONTW2         NO
         MVI   0(8),X'F1'
CONTW2   EQU   *
         SPACE 1
         WRITE DECBF,SF,,(8),MF=E
         SPACE 1
         CHECK DECBF
         SPACE 2
*   LIST OPTION SPECIFIED ?  IF SO, PUTLINE RECORD
         TM    FLAGS3,X'01'  1ST LINE OF WRAPAROUND RECORD?
         BO    CONTW4        NO
         TM    FLAGS2,X'04'  LIST OPTION ?
         BZ    CONTW4        NO
         L     6,LRECL       GET LRECL
         LA    8,@LSZMAX     FOR COMPARISION
         CR    6,8
         BNH   CONTW3        O.K. LENGTH
*        IF FELL THRU ABOVE TEST, PUTLINE ERROR MESSAGE
         MVC   PUTTEXT,=CL70'>>>> NEXT RECORD TRUNCATED (TOO LONG)<<<<'
         PUTLINE MF=(E,IOPL)
         LA    6,@LSZMAX     ONLY PUTLINE MAXIMUM
CONTW3   BCTR  6,0           DEC BY 1 FOR MVC
         EX    6,MVCPUT
         LA    6,5(6)        INCR FOR PUT LENGTH
         STH   6,PUTMSG      SAVE LENGTH
TERMPUT  PUTLINE MF=(E,IOPL)
         LA    6,74
         STH   6,PUTMSG      RESET LENGTH FOR PUTLINE
         B     CONTW4
MVCPUT   MVC   PUTTEXT(0),0(3)
CONTW4   EQU   *
         SPACE 2
*        INCR COUNT OF OUTPUT RECORDS
         L     7,OUTCOUNT
         LA    7,1(7)         INCR. COUNT OF OUTPUT RECORDS
         ST    7,OUTCOUNT
         SPACE 2
*        INCR LINE COUNT UNLESS NOH & ASA
         TM    FLAGS4,X'C0'   NOH & ASA ?
         BO    CONTW5         YES
         L     7,LPCOUNT
         LA    7,1(7)         INCR. COUNT OF LINES ON THIS PAGE
         ST    7,LPCOUNT
         C     7,LINEMAX      NEW PAGE ??
         BL    CONTW5         NO
*        NEXTPAGE ONLY CHANGES R7
         BAL   7,NEXTPAGE     WRITE HEADINGS
         B     CONTW6         DON'T TURN OFF NEWPAGE FLAG  SCL 02/29/80
CONTW5   EQU   *
         SPACE 2
*  IF NEW PAGE WAS SPEC, RESET
         TM    FLAGS4,X'10'   SET ?
         BZ    CONTW6         NO
         XI    FLAGS4,X'10'   RESET TO 0
         L     8,WRITESV+4    MAKE SURE R8 IS OKAY         SCL 01/14/80
         MVI   0(8),X'40'
CONTW6   EQU   *
         SPACE 2
         LM    7,8,WRITESV
         BR    7              RETURN
         EJECT
*  SEARCH: ROUTINE TO SEARCH RECORD FOR SPECIFIED FIELD
*
*  R3 - PTR IN BUFFER
*  R7 - RETURN (ALSO, HIGH BYTE='00' IF NOT FOUND, ELSE = 'FF')
*  R2,4,6,8,9,10,11 - WORK (ARE SAVED)
*
*
SEARCH   DS    0H
         STM   2,11,SRCHSV     SAVE REGS
         SPACE 1
         TM    FLAGS3,X'08' SEARCH WITH LOC SPEC. ?
         BO    LOCSRCH      YES
         SPACE 1
*     CALCULATE NUMBER OF COMPARISIONS REQUIRED
*       NUMBER REQ. = LRECL-SRCHLNG+1
         L     4,LRECL
         LA    4,1(4)       INCR BY 1
         S     4,SRCHLNG
         LTR   4,4          ASSURE ATLEAST 1 CLC
         BNP   NOTTHERE
         SPACE 1
*        DO CLC'S
         L     8,SRCHLNG
         BCTR  8,0          DEC BY 1 FOR CLC
CLCLOOP  EX    8,CLCSRCH
         BE    FOUND
         LA    3,1(3)       INCR PTR IN BUFFER
         BCT   4,CLCLOOP    LOOP
         B     NOTTHERE
         SPACE 2
*        CODE TO DO CLC FOR FIXED LOC.
*        ASSURE  SRCHLOC + SRCHLNG -1 <= LRECL
LOCSRCH  L     4,LRECL
         L     8,SRCHLOC    SRCHLOC
         A     8,SRCHLNG    SRCHLOC + SRCHLNG
         BCTR  8,0          SRCHLOC + SRCHLNG - 1
         CR    8,4
         BH    NOTTHERE       ASSUME NOTFOUND
         A     3,SRCHLOC      PT R3 TO LOC
         BCTR  3,0            POINT TO PREVIOUS BYTE (LOC CANT BE 0)
         L     8,SRCHLNG      FOR EX
         BCTR  8,0            DEC BY 1 FOR CLC
         EX    8,CLCSRCH
         BE    FOUND
         B     NOTTHERE
         SPACE 2
*        SET RETURN INDICATOR AND RETURN
FOUND    LM    2,11,SRCHSV
         ICM   7,B'1000',=X'00'
         BR    7
NOTTHERE LM    2,11,SRCHSV
         ICM   7,B'1000',=X'FF'
         BR    7
         SPACE 2
CLCSRCH  CLC   0(0,3),SRCHID
         EJECT
*        NEXTPAGE: ROUTINE TO PRINT HEADINGS.
*
*        R7 IS RETURN & WORK
NEXTPAGE ST    7,SAVE7NE     SAVE RETURN
         SPACE 1
*  IF ASA & NOH, DO NOT COUNT PAGES ETC.
         TM    FLAGS4,X'C0'  NOH & ASA ?
         BOR   7             YES, RETURN
         SPACE 2
         L     7,PAGENO      LOAD PAGENO
         LA    7,1(7)        INCR. PAGENO
         ST    7,PAGENO      STORE NEW PAGE NO.
         SPACE 2
*   IF "NOH" THEN INDICATE NEXT LINE SHOULD START NEW PAGE & RETURN
         TM    FLAGS4,X'40'  NOHEADING ?
         BZ    CONTN0        NO
         OI    FLAGS4,X'10'  INDICATE NEXT LINE STARTS NEW PAGE
*  RESET LINE COUNTER
         SR    7,7
         ST    7,LPCOUNT
         B     NEXTRET       RETURN
         SPACE 1
CONTN0   EQU   *
*  RESET LINE COUNTER
         LA    7,2
         ST    7,LPCOUNT
         SPACE 2
*  MOVE IN FORMAT & CONVERT PAGENO
         L     7,PAGENO      GET PAGE NUMBER
         CVD   7,WORKP       COVERT TO DECIMAL
         L     7,APAGEHD     GET ADDRESS FOR MVC SINCE SIZE IS VAR
         MVC   4(6,7),EDFMT2  MOVE IN FORMAT FOR EDITING
         ED    4(6,7),WORKP+5 USE LOW ORDER 5 DIGITS
         SPACE 2
*        IF PDS, MUST MOVE MEMBER NAME INTO HEADING
         TM    FLAGS,X'20'    PDS?
         BZ    CONTN1         NO
         L     7,MEMPTR       LOAD POINTER TO PRESENT MEMBER NAME
         MVC   HEADNG1+8(8),0(7) MOVE MEMBER NAME INTO HEADING
CONTN1   EQU   *
         SPACE 2
*        WRITE HEADINGS
         WRITE DECBF,SF,,HEADNG1,MF=E
         CHECK DECBF
         SPACE 1
         WRITE DECBF,SF,,HEADNG2,MF=E
         CHECK DECBF
         SPACE 2
NEXTRET  L     7,SAVE7NE
         BR    7     RETURN
         EJECT
*
*        MEMWRITE: ROUTINE TO PRINT COMMENT PRIOR TO EACH MEMBER.
*
*        R7 IS RETURN & WORK
MEMWRITE ST    7,SAVE7ME
         SPACE 2
*  GET MEMBER NAME AND MOVE INTO COMMENT FIELD
         L     7,MEMPTR       GET CURRENT MEMBER NAME FROM MEMLIST
         MVC   MEMCOM1+14(8),0(7) MOVE MEMBER NAME TO COMMENT
         SPACE 2
*  IF "LIST" OPTION, PUTLINE MEMBER COMMENT
         TM    FLAGS2,X'04'
         BZ    CONTM01        NO
         MVC   PUTTEXT(@LSZMAX),BLANKS  CLEAR BUFFER
         MVC   PUTTEXT(27),MEMCOM1+1    MOVE IN COMMENT
         PUTLINE MF=(E,IOPL)
CONTM01  EQU   *
         SPACE 2
*   IF "PAGE" OPTION, RETURN
         TM    FLAGS,X'80'
         BO    MEMRTN         YES, RETURN
         SPACE 2
*  IF "NOH" PUT COMMENT ON NEW PAGE AND INDICATE NEXT LINE PRINTED
*        SHOULD START NEW PAGE
         TM    FLAGS4,X'40'   "NOH"
         BZ    CONTM0         NO
         OI    FLAGS4,X'10'   INDICATE NEXT LINE START NEW PAGE
*        NOTE: IF USER SUPPLIED ASA, HIS 1ST LINE MUST START NEW PAGE
         MVI   MEMCOM1,X'F1'  INDICATE MEMBER COMMENT START NEW PAGE
         SR    7,7
         ST    7,LPCOUNT      RESET LPCOUNT
         B     WRITEM
CONTM0   EQU   *
         SPACE 2
*        WRITE MEMBER COMMENTS
         L     7,LPCOUNT      LOAD PRESENT LINE COUNT
         LA    7,3(7)         INCR. LINE COUNTER BY 3.
         ST    7,LPCOUNT      STORE NEW LINE COUNT
         SPACE 1
WRITEM   WRITE DECBF,SF,,MEMCOM1,MF=E
         CHECK DECBF
         SPACE 1
         WRITE DECBF,SF,,MEMCOM2,MF=E
         CHECK DECBF
         SPACE 2
MEMRTN   L     7,SAVE7ME
         BR    7               RETURN
         EJECT
*
*        EODADP: EODAD EXIT, USED TO SWITCH TO NEXT MEMBER FOR A PDS.
*
*        MAINTAIN TOTAL COUNT OF OUTPUT RECORDS
EODADP   L     7,OUTCOUNT     GET COUNT OF RECORDS
         LR    9,7            PUT COUNT FOR THIS MEMBER IN R9 FOR BELOW
         A     7,TOTOUT       MAINTAIN TOTAL COUNT OF OUTPUT
         ST    7,TOTOUT
         L     7,INCOUNT
         A     7,TOTIN        MAINTAIN TOTAL COUNT OF INPUT
         ST    7,TOTIN
         SR    7,7
         ST    7,OUTCOUNT     RESET COUNT
         ST    7,INCOUNT        "     "
         SPACE 2
*        RESET START OPTION IF SWITCHED SO USED FOR EACH MEMBER
         TM    FLAGS2,X'02'   SWITCHED ?
         BZ    CONTE          NO
         XI    FLAGS2,X'02'   TURN OFF START SWITCHED BIT
         OI    FLAGS2,X'20'   TURN ON START OPTION BIT FOR NEXT MEMBER
CONTE    EQU   *
         SPACE 2
*        PUTLINE MEMBER MESSAGE - IF REQUESTED
         TM    FLAGS,X'01'    PRINT MEMBER MESSAGE?
         BO    CONTE0         NO
         CVD   9,WORKP        COUNT OF RECORDS
         L     7,MEMPTR       FOR MVC TO GET MEMBER NAME
         MVC   MEMMSG+7(8),0(7)     FOR PUTLINE
         MVC   MEMMSG+17(8),EDFMT   MOVE IN FORMAT FOR EDIT
         ED    MEMMSG+17(8),WORKP+4 LOW ORDER 7 DIGITS USED
         MVC   PUTTEXT(70),MEMMSG   MOVE TOTAL MESSAGE FOR PUTLINE
         PUTLINE MF=(E,IOPL)
CONTE0   EQU   *
         SPACE 2
*        IF "LIST" OPTION, SKIP A LINE ON TERMINAL FOR READABILITY
         TM    FLAGS2,X'04'   LIST ?
         BZ    CONTE01        NO
         MVC   PUTTEXT(70),BLANKS  CLEAR BUFFER
         PUTLINE MF=(E,IOPL)
CONTE01  EQU   *
         SPACE 2
*        RESET POINTER TO NEXT MEMBER IN MEMBER LINKED LIST
RESET    L     7,MEMPTR
         LA    7,12(7)        POINT TO NEXT ENTRY
         CLC   0(8,7),LASTENTB LAST ENTRY IN BLOCK ?
         BNE   CONTE1         NO
         L     7,8(7)         LOAD ADDRESS OF NEXT BLOCK
CONTE1   EQU   *
         ST    7,MEMPTR       SAVE POINTER
         SPACE 3
*        ENTRY POINT PRIOR TO FIRST MEMBER READ
FIRST    L     7,MEMPTR
         CLC   0(8,7),HIGHFF  LAST ENTRY IN LIST?
         BE    FINISHP
         SPACE 2
*        IF SELECT OPTION DO FIND TYPE "D", ELSE TYPE "C"
         TM    FLAGS2,X'08'
         BZ    FINDC
         SPACE 2
         FIND  DCBPO,(7),D   R7 IS ADDRESS IN MEMLIST
         B     CHECKCC
         SPACE 2
FINDC    LA    7,8(7)         LOAD PTR TO TTR FOR NEXT MEMBER
         FIND  DCBPO,(7),C    FIND MEMBER
         SPACE 3
*        CHECK CC FROM FIND
CHECKCC  B     CHECKCC+4(15)  USE BRANCH TABLE
         B     CONTE10
         B     NOTFOUND
         B     IOERR          PERM ERROR
         B     NOVS           PERM ERROR
         SPACE 2
*        MEMBER NOT FOUND, PUTLINE MESSAGE
NOTFOUND MVC   PUTTEXT(70),NOMEMMSG
         MVC   PUTTEXT+7(8),0(7) MOVE IN MEMBER NAME
         PUTLINE MF=(E,IOPL)
         B     RESET          TRY NEXT MEMBER
         SPACE 2
*        CALL MEMWRITE IF "NOH" OR "NOPAGE".
*         ACTUALLY INDICATE VIA FLAG BIT SO THAT "MEMWRITE" ONLY
*         CALLED IF A RECORD IS WRITTEN (I.E. WITH SEARCH OPTION)
CONTE10  TM    FLAGS4,X'40'   "NOH" ?
         BO    CONTE11        YES - PUT MEMBER COMMENT
         TM    FLAGS,X'80'    NEW PAGE FOR EACH MEMBER?
         BO    CONTE12        YES.
CONTE11  OI    FLAGS3,X'02'   INDICATE MEMBER COMMENT TO BE PRINTED
CONTE12  EQU   *
         SPACE 2
*  CALL NEXTPAGE UNLESS NOPAGE (THEN, WILL PRINT MEMBER COMMENT)
         TM    FLAGS,X'80'    PAGE
         BZ    CONTE13        NO
         BAL   7,NEXTPAGE
         B     CONTE14
*        CHECK TO SEE IF ENOUGH ROOM ON PAGE FOR MEMBER COMMENT
CONTE13  L     7,LINEMAX      LOAD MAX. LINE COUNT
         S     7,=F'4'        NEED AT LEAST 4 LINES.
         C     7,LPCOUNT      NEED ANOTHER PAGE ?
         BNL   CONTE14        YES.
         BAL   7,NEXTPAGE     OTHERWISE, PRINT NEW PAGE HEADING
CONTE14  EQU   *
         SPACE 2
* SAVE PAGENO WHERE TTR WAS.
         L     9,PAGENO       LOAD PRESENT PAGENO
         L     7,MEMPTR       LOAD PRESENT MEMBER PTR
         STH   9,8(7)         STORE PAGNO WHERE TTR WAS (AS HALFWORD)
         SPACE 1
* RETURN TO INLINE CODE
         B     PROCESS
         SPACE 3
*        LAST MEMBER PROCESSED, PRINT TOTAL COUNT
FINISHP  L     10,TOTOUT   LOAD TOTAL COUNT
         CVD   10,WORKP    COUNT OF RECORDS
         LA    1,SEQMSG+7  IN CASE EDMK DOESNT LOAD R1 (LT 10)
         EDMK  SEQMSG(8),WORKP+4
         MVC   PUTTEXT(70),0(1) MOVE MESSAGE FOR PUTLINE
         PUTLINE MF=(E,IOPL)
         SPACE 3
*        PRINT INDEX IF REQUESTED.
         TM    FLAGS,X'02'   INDEX REQUESTED?
         BZ    NOINDEX
         BAL   7,CREATEIX    RETURN IS TO R7
NOINDEX  LA    6,DCBPO       LOAD PDS DCB FOR CLOSE
         SPACE 3
*        ENTRY FROM SEQDS EODAD ROUTINE
FINISHS  LA    7,SYSOUTF   DCB ADDRESS FOR "F" FORMAT
         CLOSE ((6),,(7),FREE),MF=(E,CLOSE2)
         SR    15,15          INDICATE RC=0
         SPACE 2
END      L     13,SAVEAREA+4
         RETURN (14,12),RC=(15)
         EJECT
*
*        EODADS: EODAD EXIT, FOR SEQUENTIAL DATASET.
*
EODADS   L     10,OUTCOUNT
         CVD   10,WORKP  COUNT OF RECORDS
         LA    1,SEQMSG+7 IN CASE EDMK DOESNT LOAD R1 (LT 10)
         EDMK  SEQMSG(8),WORKP+4
         MVC   PUTTEXT(70),0(1) MOVE MESSAGE FOR PUTLINE
         PUTLINE MF=(E,IOPL)
         LA    6,DCBSEQ    LOAD DCB ADDRESS FOR CLOSE
         B     FINISHS     CLOSE IS IN PDS EODAD ROUTINE "EODADP"
         EJECT
*
*        CREATEIX: ROUTINE TO CREATE INDEX FOR A PDS LISTING
*
*        R2 - PTR INTO MEMLIST
*        R3 - PTR INTO OUTPUT BUFFER
*        R4 - COUNT OF COLUMNS
*        R7 - RETURN AND WORK
*        R9 - LINE COUNTING
*        R6,7,8 FOR WORK
*
CREATEIX EQU   *
         SPACE 2
* SAVE REGS
         STM   2,11,SAVEIX
         L     7,MEMSTRT
         ST    7,COLLIST       INITIALIZE COLLIST
         L     7,LINEMAX
         S     7,=F'10'       SUBTRACT 10 FOR HEADINGS
*        IF R7 IS LE 0 DUE TO SMALL LINECOUNT SPEC., ERROR MSG
         LTR   7,7
         BNP   ERRIX
         ST    7,LINEMAXI     SAVE FOR USE BELOW
         SPACE 2
*        CALCULATE NUMBER OF COLUMNS REQUIRED
         SR    4,4
         L     7,LINEMAXI  ASSUME 50 LINES WILL BE PRINTED
         L     6,MEMCOUNT
COLLOOP  LA    4,1(4)     INCR. R4 1
         SR    6,7
         BP    COLLOOP    NEED ANOTHER COLUMN
         ST    4,NUMCOL
         SPACE 2
*        LOOP TO PRINT A PAGE AT A TIME
NEXTPGE  SR    9,9        USED FOR LINE COUNTING
*        SET "THISCOL" TO NUMBER OF COLUMNS FOR THIS PAGE AND DECREMENT
*            "NUMCOL" FOR NEXT TIME THRU LOOP
         ICM   6,B'1111',NUMCOL  GET NUMBER OF COLUMNS LEFT AND SET CC
         BNP   IXFINISH   WAS LAST PAGE DONE ? IF YES THAN DONE
         LA    7,@COLPAGE NUMBER OF COLUMNS PER PAGE (MAX)
         CR    6,7        MORE THAN 1 PAGE STILL NEEDED ?
         BL    CONTI1     NO
         ST    7,THISCOL  SAVE NUMBER OF COLUMNS ON THIS PAGE
         B     CONTI2
CONTI1   ST    6,THISCOL  SAVE NUMBER OF COLUMNS ON THIS PAGE
CONTI2   EQU   *
         SR    6,7
         ST    6,NUMCOL   FOR NEXT TIME THRU LOOP
         SPACE 2
*        SETUP ADDRESS LIST FOR COLUMNS - USED TO MAP 2 DIMENSIONAL
*        ARRAY (ROWS & COLS ON PAGE) ON LINKED LIST OF MEMBER ENTRIES.
         LA    6,@COLPAGE     NUM COLS PER PAGE
         BCTR  6,0            DEC BY 1 SINCE FIRST COLLIST ENTRY SAVED
         L     8,COLLIST      USE R8 FOR LOOPING THRU MEMBERS
LOOPA2   L     7,LINEMAXI     FOR BCT BELOW
         SPACE 1
LOOPA1   CLC   0(8,8),HIGHFF  LAST ENTRY ?
         BE    CONTI7         YEP
         LA    8,12(8)        GET NEXT ENTRY
         CLC   0(8,8),LASTENTB LAST ENTRY IN BLOCK ?
         BNE   CONTI6         NO
         L     8,8(8)         GET ADDRESS OF NEXT BLOCK
CONTI6   EQU   *
         BCT   7,LOOPA1       DO LINEMAXI TIMES
         SPACE 1
         LA    7,@COLPAGE       SINCE 6 IS @COLPAGE-1,-2,-3 ETC. WILL
         SR    7,6            GET 1,2,3  ETC. FOR STORING
         SLL   7,2            X 4 FOR "ST"
         ST    8,COLLIST(7)   ST ADDRESS OF MEMBER IN COLUMN LIST
         BCT   6,LOOPA2
         SPACE 1
CONTI7   EQU   *              BR TO IF LAST MEMBER FOUND
         SPACE 2
*        MOVE CORRECT NO. OF COLUMN HEADINGS FOR OUTPUT
*        FIRST CLEAR OUT HEADINGS FROM PREVIOUS PASS
         MVC   IXHEAD+1(@LSZMAX),BLANKS
         MVC   IXHEAD2+1(@LSZMAX),BLANKS
         L     7,THISCOL  NUMBER OF COLUMNS FOR THIS PAGE
         LA    4,@IXSIZE
         MR    6,4        NO. OF BYTES FOR MVC
         BCTR  7,0        FOR MVC DEC BY 1
         EX    7,IXMVC1
         EX    7,IXMVC2
         B     CONTI8
IXMVC1   MVC   IXHEAD+1(0),IXTEMPL MOVE FIRST HEADING
IXMVC2   MVC   IXHEAD2+1(0),IXTEMPL2 MOVE 2ND HEADING
CONTI8   EQU   *
         SPACE 3
*        NOW PRINT PAGE HEADING
         MVC   HEADNG1+1(L'INDEXCOM),INDEXCOM  MOVE IN HEADING
         XI    FLAGS,X'20' TURN OFF PDS BIT SO "NEXTPAGE" WILL NOT
*                          INSERT A MEMBER NAME IN HEADING
         NI    FLAGS4,B'10111111' HEADING PRINTED ON INDEX PAGES
         BAL   7,NEXTPAGE  PUT HEADING
         OI    FLAGS,X'20' TURN PDS BIT BACK ON.
         SPACE 2
*        PRINT COLUMN HEADINGS
         WRITE DECBF,SF,,IXHEAD,MF=E
         CHECK DECBF
         WRITE DECBF,SF,,IXHEAD2,MF=E
         CHECK DECBF
         EJECT
*  CREATEIX: PRINT A PAGE
*
*        LOOP FOR EACH LINE TO BE PRINTED
NEXTLINE L     2,COLLIST      GET ADDRESS FOR FIRST COLUMN
         LA    3,IXLINE+1     OUTPUT BUFFER
         L     4,THISCOL
         SPACE 1
* LOOP FOR EACH COLUMN ON THIS LINE
IXLOOP   CLC   0(8,2),HIGHFF  LAST ENTRY?
         BNE   CONTI9         NO
         L     8,THISCOL
         BCTR  8,0            DEC COLS TO BE PRINTED BY 1
         LTR   8,8
         BZ    IXFINISH       IF ONLY 1 COL, THEN THIS IS END OF LIST
         ST    8,THISCOL      RESTORE NEW NUMBER OF COLS
         MVC   0(@IXSIZE,3),BLANKS BLANK OUT THIS COLUMN
         B     WRITEIX        MUST STILL WRITE RECORD
CONTI9   MVC   0(8,3),0(2)    MOVE MEMBER NAME TO OUTPUT
         LH    8,8(2)         LOAD PAGENO (WAS STORED AS HALFWORD)
         CVD   8,WORKP
         MVC   8(6,3),EDFMT2  MOVE 6 EDIT BYTES
         ED    8(6,3),WORKP+5 LOW ORDER 5 DIGITS
         SPACE 1
* RESET COLLIST POINTER TO NEXT MEMBER AND RESET R2
         L     7,THISCOL      COLS FOR THIS PAGE
         SR    7,4            WILL GIVE 0,1,2,3 ETC
         SLL   7,2            X 4 SINCE WILL USE AS INDEX
         L     6,COLLIST(7)   GET POINTER INTO MEMLIST
         L     2,COLLIST+4(7) RESET R2 FOR NEXT PASS THRU IXLOOP
         LA    6,12(6)        GET NEXT MEMBER
         CLC   0(8,6),LASTENTB LAST ENTRY ?
         BNE   CONTI10        NO
         L     6,8(6)         GET NEXT BLOCK
CONTI10  ST    6,COLLIST(7)   SAVE FOR NEXT TIME THRU
         SPACE 1
         LA    3,@IXSIZE(3)        INCR R3 TO NEXT COLUMN IN BUFFER
         BCT   4,IXLOOP
         SPACE 2
WRITEIX  WRITE DECBF,SF,,IXLINE,MF=E
         CHECK DECBF
         LA    9,1(9)         INCR R9 FOR LINE COUNTING
         C     9,LINEMAXI     LAST LINE WRITTEN?
         BNE   NEXTLINE       NO
         SPACE 2
*  NEW PAGE REQRD:
*    SETUP FIRST COLLIST ENTRY & BR TO NEXTPGE
         LA    7,@COLPAGE     COLLUMNS PER PAGE
         BCTR  7,0            - 1
         SLL   7,2            X 4
         L     6,COLLIST(7)   GET LAST ENTRY
         ST    6,COLLIST      RESET 1ST ENTRY FOR NEXT PAGE
*        CLEAR BUFFER FOR NEXT PASS THRU
         MVC   IXLINE+1(@LSZMAX1),BLANKS
         B     NEXTPGE
         SPACE 2
IXFINISH LM    2,11,SAVEIX    RETURN
         BR    7
         EJECT
*
*   SYNAD EXIT - FOR READING DIRECTORY
*
SYNAD    SYNADAF ACSMETH=BSAM
         MVC   SYNTEXT+38(70),50(1)
         MVC   PUTMSG(124),SYNMSG  MOVE HDR+MSG TO PUTMSG
         PUTLINE MF=(E,IOPL)
         SYNADRLS
         CLOSE ,MF=(E,CLOSEDIR)
         SPACE 2
*        RETURN TO TMP TO AVOID ABEND.
         L     13,SAVEAREA+4
         RETURN (14,12),RC=12
         EJECT
*
*        DCB ERROR EXIT (NO ABEND IF MEMBER OF PDS SPEC. WRONG)
*
DCBERRX  LR    7,13           MUST USE R7 FOR USING SINCE R13 USED
         DROP  13             TEMPORARILY DROP 13
         USING DSECT1,7       USE R7
         LA    13,DCBSV       MUST PROVIDE OWN SAVE AREA FOR PUTLINE
         ST    14,DCBSV14     SAVE 14 FOR RETURN TO CONTROL PGM
         CLC   0(3,1),=X'013018' CC=013 + RC=018 (MEMBER NOT THERE)?
         BNE   OTHERABD       NO
         SPACE 2
*        MEMBER NOT IN THIS PDS.
         MVI   3(1),X'04'      INDICATE NO ABEND
         MVC   PUTTEXT(L'ERRMSG7),ERRMSG7 MEMBER OF A PDS NOT THERE
         B     TPUTX
         SPACE 2
*        UNKNOWN ERROR -  CONTINUE ABEND
OTHERABD MVC   PUTTEXT(L'ERRMSG3),ERRMSG3 PUT OPEN ERROR MSG + ABEND
         SPACE 2
TPUTX    PUTLINE MF=(E,IOPL)
         SPACE 2
         OI    FLAGS2,X'80'   INDICATE ABEND EXIT WAS TAKEN
         L     14,DCBSV14
         BR    14
         SPACE 2
         DROP  7              GO BACK TO USING 13
         USING DSECT1,13
         EJECT
*
*        ERROR CONDITIONS FOLLOW
*
ERRNOMEM MVC   PUTTEXT(L'ERRMSG1),ERRMSG1 NO MEMBERS FOUND
         TM    FLAGS2,X'10'   RANGE OPTION ?
         BZ    TPUTIT         NO
         MVC   PUTTEXT+24(L'ERRMSG1A),ERRMSG1A  ADD RANGE MESSAGE
         B     TPUTIT
ERROPENS MVC   PUTTEXT(L'ERRMSG2),ERRMSG2 OPEN ERROR - DIRECTORY OF PDS
         B     TPUTIT
ERROPENI MVC   PUTTEXT(L'ERRMSG3),ERRMSG3 OPEN FOR PDS OR SEQ ERROR
         B     TPUTIT
ERRFORM  MVC   PUTTEXT(L'ERRMSG4),ERRMSG4 ERROR IN RECFM (U OR VS)
         B     TPUTIT
ERROPENJ MVC   PUTTEXT(L'ERRMSG5),ERRMSG5 ERROR IN OPEN - SYSOUT
         B     TPUTIT
IOERR    MVC   PUTTEXT(L'ERRMSG6),ERRMSG6 IO ERROR IN READING DIRECTORY
         B     TPUTIT
NOVS     MVC   PUTTEXT(L'ERRMSG8),ERRMSG8 NO VIRTUAL STOR FOR FIND
         B     TPUTIT
ERRLINS  MVC   PUTTEXT(L'ERRMSG9),ERRMSG9 ERROR IN SPEC OF LINESIZE
         B     TPUTIT
ERRIX    MVC   PUTTEXT(L'ERRMSG10),ERRMSG10 LINECOUNT TOO SMALL FOR IX
         B     TPUTIT
         SPACE 2
TPUTIT   PUTLINE MF=(E,IOPL)
         SPACE 2
*        CLOSE ANY DCBS STILL OPEN (I.E. ERROR OCCURRED)
         TM    FLAGS3,X'80'   PDS DCB OPEN ?
         BZ    NO1            NO
         LA    6,DCBPO
         BAL   7,CLOSEX       CLOSE IT
NO1      TM    FLAGS3,X'40'   SEQ DCB OPEN ?
         BZ    NO2            NO
         LA    6,DCBSEQ
         BAL   7,CLOSEX       CLOSE IT
NO2      TM    FLAGS3,X'20'   SYSOUT DCB OPEN ?
         BZ    NO3            NO
         LA    6,SYSOUTF
         BAL   7,CLOSEX       CLOSE IT
NO3      B     CONTERR
         SPACE 1
CLOSEX   MVC   CLOSERR(4),CLOSEDR# MOVE IN LIST FORM
         CLOSE ((6),FREE),MF=(E,CLOSERR)
         BR    7              RETURN TO INLINE CODE
         SPACE 2
*        RETURN WITH RC=12
CONTERR  LA    15,12          SET RC
         B     END
         EJECT
         PRINT NOGEN
*
*  PDS DCB TO READ MEMBERS - BPAM
*
DCBPO#   DCB   DSORG=PO,MACRF=R,DDNAME=IN,EODAD=EODADP,NCP=2,          X
               SYNAD=SYNAD,KEYLEN=0
DCBPOL   EQU   *-DCBPO#
         SPACE 2
*
*  DCB TO READ A SEQUENTIAL DATASET - BSAM
*
DCBSEQ#  DCB   DSORG=PS,MACRF=R,DDNAME=IN,EODAD=EODADS,NCP=2,          X
               EXLST=EXLST
DCBSEQL  EQU   *-DCBSEQ#
         SPACE 2
*
*  PDS DCB TO READ DIRECTORY - BSAM
*
DCBDIR#  DCB   DSORG=PS,MACRF=R,BLKSIZE=256,RECFM=F,KEYLEN=8,DDNAME=IN
DCBDIRL  EQU   *-DCBDIR#
         SPACE 2
*
*  OUTPUT DCB - BSAM
*
SYSOUTF# DCB   DSORG=PS,MACRF=W,DDNAME=OUT,RECFM=FA,BUFNO=1
SYSOUTFL EQU   *-SYSOUTF#
         PRINT GEN
         EJECT
DSECT1   DSECT
         SPACE 1
*    DSECT FOR REENTERABILITY
         SPACE 1
SAVEAREA DS    18F
         SPACE 1
FLAGS    DS    X  BIT 1000 0000 - NEW PAGE
*                     0100 0000 - RESERVED
*                     0010 0000 - PDS
*                     0001 0000 - MEMBER SPECIFIED
*                     0000 1000 - "F" RECFM
*                     0000 0100 - BUFFER SWITCH 0=BUF1, 1=BUF2
*                     0000 0010 - PAGE INDEX
*                     0000 0001 - NOMESSAGES
FLAGS2   DS    X  BIT 1000 0000 - ABEND EXIT WAS TAKEN
*                     0100 0000 - COUNT OPTION SPEC
*                     0010 0000 - START   "     "
*                     0001 0000 - RANGE   "     "
*                     0000 1000 - SELECT  "     "
*                     0000 0100 - LIST    "     "
*                     0000 0010 - START OPTION SWITCHED OFF INDICATOR
*                     0000 0001 - FCB, UCS, OR FORMS SPECIFIED
FLAGS3   DS    X  BIT 1000 0000 - PDS DCB OPEN
*                     0100 0000 - SEQ DCB OPEN
*                     0010 0000 - SYSOUT DCB OPEN
*                     0001 0000 - SEARCH OPTION SPEC
*                     0000 1000 - SEARCH OPTION WITH LOC SPECIFIED
*                     0000 0100 - VOLUME & UNIT SUPPLIED
*                     0000 0010 - PRINT MEMBER COMM PRIOR TO NEXT LINE
*                     0000 0001 - 1ST LINE OF WRAPAROUND PRINTED
FLAGS4   DS    X  BIT 1000 0000 - ASA CHAR ON INPUT DATASET
*                     0100 0000 - NOHEADING
*                     0010 0000 - HEAD/NOHEAD EXPLICITELY DEF.
*                     0001 0000 - INDICATE NEW PAGE WITH NEXT LINE
*                     0000 1000 - MACHINE CHAR CONTROL     SCL 01/17/80
*                     0000 0100 -   "
*                     0000 0010 -   "
*                     0000 0001 -   "
         SPACE 1
LINEMAX  DS    F '60' LINES PER PAGE
LINEMAXI DS    F      LINES PER PAGE - 10
PAGENO   DS    F '0'  PAGE NUMBER
ECBPUT   DS    F '0'
OUTCOUNT DS    F '0'  USED TO COUNT OUTPUT RECORDS
TOTOUT   DS    F '0'  FOR COUNTING TOTAL LINES OF OUTPUT
INCOUNT  DS    F '0'  USED TO COUNT INPUT  RECORDS
TOTIN    DS    F '0'  FOR COUNTING TOTAL INPUT RECORDS
MEMCOUNT DS    F '0'
COLLIST  DS    (@COLPAGE)F
THISCOL  DS    F
LINESIZE DS    F
LRECL    DS    F
START    DS    F      USED IF START OPTION SPEC
COUNT    DS    F       "    " COUNT   "      "
LINEWRAP DS    F
LLAST    DS    F
LPCOUNT  DS    F      USED TO KEEP TRACK OF LINES ON A PAGE
SAVEIX   DS    10A  FOR USE AS SAVEAREA BY "CREATEIX"
SAVE7NE  DS    A    TO SAVE R7 FOR RETURN - ROUTINE "NEXTPAGE"
SAVE7ME  DS    A     "  "   "   "     "         "   "MEMWRITE"
APAGEHD  DS    A    USED TO LOCATE POS IN HEADING FOR PAGE NUMBER
MEMADDR  DS    A
RANGES   DS    2CL8 USED IF RANGE OPTION SPEC
DDNAME1  DS    CL8  OUTPUT DDNAME - PASSED AS PARM
DDNAME2  DS    CL8  INPUT  DDNAME - PASSED AS PARM
IOPL     DS    A            UPT=
         DS    A            ECT=
         DS    A (ECBPUT)   ECB=
         DS    A (PUTLIST)  PARM=
WRITESV  DS    2F SAVE R7,8
TTTLRECL DS    1H
PUTMSG   DS    H '74' LENGTH OF OUTPUT LINE FOR PUTLINE
         DS    H '0'  RESERVED
PUTTEXT  DS    (@LSZMAX)CL1  NOTE: SYNAD REQUIRES ATLEAST 120 BYTES
SYNMSG   DS    H '120' LENGTH OF OUTPUT LINE FOR PUTLINE
         DS    H '0'   RESERVED
SYNTEXT  DS    CL120 'I/O ERROR OCCURED WITH PDS DIRECTORY, ' 38
SEQMSG   DS    XL8 '4020202020202120'
         DS    CL70 ' LINES ROUTED LOCAL' 70 SINCE BLANKS IGNORED
WORKP    DS    D  FOR PL8 WORKSPACE
MEMPTR   DS    F     CONTAINS POINTER INTO MEMLIST
MEMSTRT  DS    F        "      "      TO MEMLIST- NOT UPDATED.
NUMCOL   DS    F
EDFMT    DS    XL8 '4020202020202120'
EDFMT2   DS    XL6 '402020202020'
DCBSV    DS    18F
DCBSV14  DS    F
SRCHSV   DS    10F  TO SAVE REGS 2-11
BUFADR1  DS    A
BUFADR2  DS    A
DECB1ADR DS    A                 "    "  INPUT DECB FOR 1ST BUFFER
DECB2ADR DS    A                 "    "    "    "    "  2ND BUFFER
* NOTE: IF @LSZMIN IS CHANGED, FOLLOWING MUST ALSO CHANGE
HEADNG1  DS    CL1 '1'  FOR CHARRIAGE CONTROL - NEW PAGE
         DS    CL17 'MEMBER'
         DS    CL13 'VOL=' OPTIONAL
         DS    CL90 'DSN='
         DS    (@LSZMAX1-120)CL1
HEADNG2  DS    CL1 ' '
         DS    (@LSZMAX1)CL1 '-' UNDER HEADING
MEMCOM1  DS    (@LSZMAX)CL1 '0***** MEMBER 12345678 *****' IF "NOPAGE"
MEMCOM2  DS    (@LSZMAX)CL1 ' ' FOR BLANK LINE
IXHEAD   DS    CL1 '0'
         DS    (@LSZMAX1)CL1
IXHEAD2  DS    CL1 ' '
         DS    (@LSZMAX1)CL1
IXLINE   DS    (@LSZMAX)CL1  ' '  WILL CONTAIN INDEX LINES
MEMMSG   DS    CL70 'MEMBER 12345678 -12345678 LINES PRINTED'
*                   0123456789012345678901234567890123456789
BUFOUTF  DS    CL1 ' '  FOR CHARRIAGE CONTROL
         DS    (@LSZMAX1)CL1  FOR F RECORDS
LASTENT  DS    CL8
DIRBLOCK DS    CL264
$0018DYS DS    PL2 '365'
TABLE    EQU   $0018DYS
$0018JAN DS    PL2 '365'
$0018FEB DS    PL2 '334'
         DS    PL2 '306'
         DS    PL2 '275'
         DS    PL2 '245'
         DS    PL2 '214'
         DS    PL2 '184'
         DS    PL2 '153'
         DS    PL2 '122'
         DS    PL2 '092'
         DS    PL2 '061'
         DS    PL2 '031'
TABLEL   EQU   *-TABLE
DATEX    DS    CL8            AREA INTO WHICH DATE IS TEMP PLACED
TIMEX    DS    CL8             "    "     "   TIME  "   "    "
VOLUME   DS    CL6
         SPACE 2
*        MACROS FOLLOW
PUTLIST  DS    3F
         SPACE 1
* DECBS
DECB1P   DS    5F
DECB2P   DS    5F
DECB1S   DS    5F
DECB2S   DS    5F
DECBF    DS    5F
DECBDIR  DS    5F
         SPACE 1
* DCBS
DCBDIR   DS    0F,(DCBDIRL)CL1
DCBSEQ   DS    0F,(DCBSEQL)CL1
DCBPO    DS    0F,(DCBPOL)CL1
SYSOUTF  DS    0F,(SYSOUTFL)CL1
         SPACE 1
* OPEN & CLOSE MACROS
OPENDIR  DS    F
CLOSEDIR DS    F
OPENPO   DS    F
OPENF    DS    F
OPENSEQ  DS    F
CLOSE2   DS    2F
CLOSERR  DS    F
         SPACE 1
* SEARCH INFORMATION (IF SEARCH OPTION SPECIFIED)
SRCHLNG  DS    F              SEARCH ARGUMENT LENGTH
SRCHLOC  DS    F              SEARCH ARGUMENT LOCATION
SRCHID   DS    CL256          SEARCH ARGUMENT
         SPACE 1
DSECT1L  EQU   *-DSECT1
         EJECT
PRINTDSX CSECT
*        PROGRAM CONSTANTS
         SPACE 1    012345678901234567890123456789012345678901234567890
ERRMSG1  DC    CL70'NO MEMBERS FOUND IN PDS'
ERRMSG1A DC    CL19'FOR RANGE SPECIFIED'
ERRMSG2  DC    CL70'OPEN ERROR - INPUT DATASET - DIRECTORY'
ERRMSG3  DC    CL70'OPEN ERROR - INPUT DATASET - (BSAM)'
ERRMSG4  DC    CL70'ERROR - ONLY F/FB/FBA/V/VB/VBA RECFM ALLOWED'
ERRMSG5  DC    CL70'OPEN ERROR - SYSOUT DATASET'
ERRMSG6  DC    CL70'PERM I/O ERROR IN READING DIRECTORY - FIND MACRO'
ERRMSG7  DC    CL70'ERROR - MEMBER SPECIFIED NOT IN PDS'
ERRMSG8  DC    CL70'ERROR - NOT ENOUGH VIRTUAL STOR FOR FIND MACRO'
ERRMSG9  DC    CL70'ERROR - LINESIZE MUST BE >=121 AND <=205'
ERRMSG10 DC    CL70'ERROR - INDEX NOT PRINTED - LINECOUNT TOO SMALL'
* NOTE: @IXSIZE MUST BE >= 14
IXTEMPL  DC    (@COLPAGE)CL(@IXSIZE)'MEMBER    PAGE'
IXTEMPL2 DC    (@COLPAGE)CL(@IXSIZE)'--------  ----'
INDEXCOM DC    CL17'***** INDEX *****'
WRNMSG1  DC    CL70'WARNING - ASA CHARACTERS TREATED AS DATA UNLESS "NOX
               HEADING" SPECIFIED'
NOMEMMSG DC    CL70'MEMBER 12345678 NOT IN DATASET'
HIGHFF   DC    8X'FF'
LASTENTB DC    7X'FF',X'FE'  USED TO INDICATE LAST ENTRY IN LINK BLOCK
         SPACE 1
*  FOLLOWING ARE TEMPLATES COPIED INTO DSECT
HEADNG1# DC    CL1'1'  FOR CHARRIAGE CONTROL - NEW PAGE
         DC    CL17'MEMBER'
         DC    CL13' ' VOL=
         DC    CL90'DSN='
         DC    (@LSZMAX-121)CL1' '
HEADNG2# DC    CL1' ',(@LSZMAX1)CL1'-' UNDER HEADING
MEMCOM1# DC    CL28'0***** MEMBER 12345678 *****',(@LSZMAX-28)CL1' '
BLANKS   DC    (@LSZMAX)CL1' '
MEMMSG#  DC    CL70'MEMBER 12345678 -12345678 LINES PRINTED'
*                   0123456789012345678901234567890123456789
TRUNCMSG DC    CL70'PRINT LINES MAY BE TRUNCATED SINCE LRECL>LINESIZE'
SYNMSG#  DC    H'120' LENGTH OF OUTPUT LINE FOR PUTLINE
         DC    H'0'   RESERVED
SYNTEXT# DC    CL120'I/O ERROR OCCURED WITH PDS DIRECTORY, ' 38
         SPACE 1
         LTORG
         EJECT
*
*        DCB EXLST, PUTLINE, READ, OPEN, AND CLOSE MACROS
*
         DS    0F             ALIGNMENT
EXLST    DC    X'91',AL3(DCBERRX) INDICATE LAST ENTRY
         SPACE 3
PUTLIST# PUTLINE OUTPUT=(,TERM,SINGLE,DATA),                           X
               TERMPUT=(EDIT,WAIT,NOHOLD,BREAKIN),MF=L
         SPACE 3
         READ  DECBDIR#,SF,MF=L  DECB TO READ DIRECTORY
         SPACE 3
         READ  DECB1P#,SF,MF=L  1ST PDS DECB
         SPACE 3
         READ  DECB2P#,SF,MF=L  2ND PDS DECB
         SPACE 3
         READ  DECB1S#,SF,MF=L  1ST SEQ DECB
         SPACE 3
         READ  DECB2S#,SF,MF=L  2ND SEQ DECB
         SPACE 3
         WRITE DECBF#,SF,MF=L  OUTPUT DECB FOR RECFM=F
         SPACE 3
OPENDIR# OPEN  (,INPUT),MF=L
         SPACE 3
CLOSEDR# CLOSE (,),MF=L
         SPACE 3
OPENSEQ# OPEN  (,INPUT),MF=L
         SPACE 3
OPENPO#  OPEN  (,INPUT),MF=L
         SPACE 3
OPENF#   OPEN  (,OUTPUT),MF=L
         SPACE 3
CLOSE2#  CLOSE (,,,),MF=L
         EJECT
         PRINT NOGEN
         DCBD  DSORG=BS,DEVD=DA
         PRINT GEN
         END   PRINTDSX
