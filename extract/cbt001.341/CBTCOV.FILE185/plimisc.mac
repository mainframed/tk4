* MODULE: PLIMISC
* FUNCTION: VARIOUS PRIMITIVE UTILITY SUBROUTINES FOR PLIX
* ATTRIBUTES: LINKEDIT WITH REENTRANT ATTRIBUTE
*            THE AMDPRSEG SUBROUTINE IS NOT REENTRANT, SO
*            PROGRAMS WHICH CALL ENTRY POINT TODCNVTR SHOULD
*            NOT BE DECLARED REENTRANT, BUT ALL OTHER ENTRY
*            POINTS ARE REENTRANT.
* EXTERNAL: CALLS TODCNVRT ENTRY POINT OF AMDPRSEG MODULE.
* DISTRIBUTION:
*      THIS MODULE IS NOT RESTRICTED IN ANY WAY AND CAN BE
* FREELY REPRODUCED AND USED FOR ANY PURPOSE.
*****************************************************************
* THE INDIVIDUAL CALLING ASSUMPTIONS ARE DOCUMENTED FOR EACH
*     ROUTINE. THIS IS NOT AN EXHAUSTIVE LIST AND IT MAY BE
*     ADDED TO PERIODICALLY. REDUNDANCY IN FUNCTION IS PERMITTED
*     WHERE THERE IS A SIGNIFICANT IMPROVEMENT IN USABILITY.
* CONVENTIONS: EACH ROUTINE IS PRECEEDED BY ITS OWN DOCUMENTATION.
*     ROUTINES REQUIRING PLI PROLOGUE AND EPILOGUE CODE USE
*     PLIENTRY AND PLIEND MACROS. ADDITIONAL PRIVATE MACROS MUST BE
*     PHYSICALLY INSERTED INTO THE MODULE BELOW.
* DOCUMENTATION MUST INCLUDE AUTHOR, DATE, A PLI DECLARATION OF THE
*     ENTRY, AND INFORMATION ON THE ARGUMENTS.
         EJECT
         MACRO
&NAME    PLIENTRY &DSA=88,&BR=11
.* THIS MACRO PROVIDES ENTRY CODE FOR AN ASSEMBLER SUBROUTINE
.* OF A PLIX PROGRAM. THIS LINKAGE ALLOWS RECURSIVE OR
.* REENTRANT USE OF THE ROUTINE, IF THE REST OF THE CODE IS
.* WRITTEN CORRECTLY. IF REGISTER 12 IS UNCHANGED THROUGHOUT
.* THE SUBROUTINE, THEN NORMAL PLIX ERROR CORRECTION AND
.* OTHER LINKAGES ARE PRESERVED AND PLIX SUBROUTINES CAN BE
.* CALLED NORMALLY.
.*
.* ARGUMENTS-
.* &DSA IS THE LENGTH OF THE DYNAMIC STORAGE AREA NEEDED BY
.* THE PROGRAM FOR SAVE AREA, HOUSKEEPING, AND AUTOMATIC
.* VARIABLE STORAGE. THE FIRST 88 BYTES ARE RESERVED, BUT THE
.* REST OF REQUESTED MEMORY CAN BE ADDRESSED BY A DSECT BASED
.* ON REGISTER 13.
.* &BR IS THE REGISTER USED AS THE BASE FOR THE REMAINDER OF
.* THE SUBROUTINES EXECUTABLE CODE.
         DC    CL7'&NAME'
         DC    AL1(7)
         ENTRY &NAME
&NAME    STM   14,12,12(13)
         LR    4,1            SAVE ARGLIST TEMPORARILY
         LA    0,&DSA
         USING &NAME,15       TEMPORARY ADDRESSABILITY
         CH    0,=H'88'
         BNL   *+8
         LA    0,88
.* FOLLOWING CODE COPIED ESSENTIALLY FROM FIG 12.2 OF PLIX
.* PROGRAMMERS GUIDE. REFER TO IT FOR DETAILED DESCRIPTION.
         L     1,76(13)
         ALR   0,1
         CL    0,12(12)
         BNH   *+10
         DROP  15
         L     15,116(12)
         BALR  14,15
         ST    0,76(1)
         ST    13,4(1)
         MVC   72(4,1),72(13)
         LR    13,1
         MVI   0(13),X'80'
         MVI   86(13),X'91'
         MVI   87(13),X'C0'
         LR    1,4
         BALR  &BR,0
         USING *,&BR
         MEND
         EJECT
         MACRO
&NAME    PLIEND
.* RETURN SEQUENCE FROM ASSEMBLER SUBROUTINE OF PLIX
.* PRESERVES R15 AS RETURN CODE.
.* THIS CODE WAS COPIED FROM A REAL COMPILER LISTING
&NAME    LR     0,13
         L     13,4(13)
         L     14,12(13)
         LM    2,12,28(13)
         BALR  1,14
         MEND
         EJECT
         PUNCH ' ALIAS SVC'
         PUNCH ' ALIAS LINKER'
         PUNCH ' ALIAS LOADPTR'
         PUNCH ' ALIAS STCK'
         PUNCH ' ALIAS TCAPTR'
         PUNCH ' ALIAS PTRIN'
         PUNCH ' ALIAS PTROUT'
         PUNCH ' ALIAS SDL'
         PUNCH ' ALIAS ADL'
         PUNCH ' ALIAS TODCNVT'
         PUNCH ' ALIAS COMWAIT'
         PRINT NOGEN
PLIMISC  CSECT
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         EJECT
         SPACE 5
* ENTRY: SVC
* FUNCTION: ISSUE AN SVC. SUPPORTS VARIOUS MACROS PROVIDING
*     SUPERVISOR SERVICES TO A PLI PROGRAM
* AUTHOR: HOWARD GILBERT
* DATE: JAN 20, 1977
         SPACE 1
*        DCL SVC ENTRY(FIXED BIN, 1, 2 /*R0*/ PTR, 2 /*R1*/ PTR,
*              2 /*R15*/ PTR) OPTIONS(ASM INTER RETCODE);
*        THE FIRST ARGUMENT IS THE SVC NUMBER
*        THE SECOND ARGUMENT IS AN ARRAY OR STRUCTURE CONTAINING
*           THE INITIAL VALUES FOR REGISTERS 0,1, AND 15.
*        THE SECOND ARGUMENT IS CHANGED BY EXECUTION OF THIS ROUTINE
*           AND RECEIVES THE CONTENTS OF THE REGISTERS AFTER
*           EXECUTION OF THE SVC. THE CONTENTS OF R15 ARE ALSO
*           PASSED BACK AS THE RETURN CODE AND CAN BE DETERMINED BY
*           THE RETCODE CONVENTIONS.
SVC      PLIENTRY
         LM    R2,R3,0(R1)
         LH    R2,0(R2)           GET SVC #
         LM    R0,R1,0(R3)
         L     R15,8(R3)
         EX    R2,SVCINST
         ST    R15,8(R3)
         STM   R0,R1,0(R3)
         PLIEND
SVCINST  SVC   0                  EXECUTED INSTRUCTION
         EJECT
* ENTRY: LINKER
* FUNCTION: TO ALLOW PLI TO CALL SUBROUTINES IN LPALIB AND LINKLIB
*        WITHOUT UNDUE OVERHEAD.
* SYSTEM:      MVS ONLY
* AUTHOR:      HOWARD GILBERT
* DATE:  JAN 20, 1977
         SPACE 2
*        DCL LINKER ENTRY(CHAR(8),.....) OPTIONS(ASM INTER RETCODE);
*        THE FIRST ARGUMENT IS THE NAME OF THE MODULE TO BE CALLED
*        THE SECOND AND SUBSEQUENT ARGUMENTS ARE PASSED TO THE
*          MODULE. IF LINKER IS PASSED 'N' ARGUMENTS, 'N-1' ARE
*          PASSED TO THE CALLED ROUTINE. THIS IS ACCOMPLISHED
*          BY INCREMENTING R1 BY 4 BEFORE THE CALL.
*        THE RETURN CODE IS PASSED BACK IN R15.
         SPACE 2
* LOGIC:
*        FIRST WE CALL IEAVVMSR TO SEARCH THE MVS LINK PACK FOR
*        THE MODULE NAME. IF IT IS FOUND IT IS BRANCHED TO
*        DIRECTLY.
*        OTHERWISE, WE USE THE LINK MACRO TO EFFECT THE CALL
*        IF AN ERROR IS DETECTED IN THE LINK, WE PASS BACK
*        F'806' AS A RETURN CODE.
         SPACE 2
* NOW A WORD ABOUT IEAVVMSR IS IN ORDER HERE, SINCE DOCUMENTATION
* ON IT IS HARD TO FIND. IT IS AN ENTRY OF IEAVLK00 IN THE NUCLEUS
* AND IT HAS STRANGE REGISTER CONVENTIONS:
*  R0  ON INPUT, FIRST HALF OF MODULE NAME. ON OUTPUT, LPDE ADDR
*  R1  ON INPUT, SECOND HALF OF MODULE NAME.
*  R3  ON INPUT, CVT ADDRESS
*  R6, R8, AND R9 CHANGED BY IEAVVMSR WITHOUT RESTORING
* AND OF COURSE YOU FIND IEAVVMSR FROM THE CVT
         SPACE 2
LINKER   PLIENTRY DSA=LINKSIZE
         USING LINKDSA,R13
         L     R2,0(R1)           GET ADDRESS OF NAME
         LA    R4,4(R1)           SKIP FIRST ARGUMENT FOR
*                                 SUBSEQUENT CALL
         MVC   LINKWKA(LINKSFLL),LINKSFL
         LM    R0,R1,0(R2)
         L     R3,CVTPTR          NEED THIS FOR IEAVVMSR
         CLI   CVTDCB-CVT(R3),X'13' TEST FOR MVS
         BNE   LNK
         L     R15,CVTLPDSR-CVT(R3) ADDR OF IEAVVMSR
         BALR  R14,R15
         B     BALRCODE           MODULE FOUND IN LPA
LNK      LR    R1,R4              PICK UP SAVED ARGUMENT ADDR
         LINK  EPLOC=(2),ERRET=ERR806,SF=(E,LINKWKA)
RET      PLIEND
ERR806   LA    R15,806
         B     RET
BALRCODE LR    R1,R4
         LR    R15,R0
         L     R15,LPDENTP-LPDE(R15)
         BALR  R14,R15
         B     RET
LINKSFL  LINK  SF=L
LINKSFLL EQU   *-LINKSFL
LINKDSA  DSECT
         DS    CL88
LINKWKA  LINK  SF=L
LINKSIZE EQU   *-LINKDSA
PLIMISC  CSECT
         EJECT
* ENTRY: LOADPTR
* FUNCTION: TO ALLOW PLI TO LOAD DATA MODULES IN LPALIB AND
*        LINKLIB WITHOUT UNDUE OVERHEAD.
* SYSTEM:      MVS ONLY
* AUTHOR:      HOWARD GILBERT
* DATE:  JAN 20, 1977
         SPACE 2
*        DCL LOADPTR ENTRY(CHAR(8),PTR) OPTIONS(ASM INTER RETCODE);
*        THE FIRST ARGUMENT IS THE NAME OF THE MODULE TO BE LOADED
*        THE SECOND ARGUMENT IS A POINTER SET TO THE ADDRESS OF THE
*        DATA MODULE. NO PROVISION IS MADE TO DELETE THE MODULE.
*        THE RETURN CODE IS PASSED BACK IN R15.
         SPACE 2
* LOGIC:
*        FIRST WE CALL IEAVVMSR TO SEARCH THE MVS LOAD PACK FOR
*        THE MODULE NAME. IF IT IS FOUND, ITS ADDRESS IS RETURNED
*        OTHERWISE, WE USE THE LOAD MACRO TO FIND IT
*        IF AN ERROR IS DETECTED IN THE LOAD, WE PASS BACK
*        F'806' AS A RETURN CODE.
         SPACE 2
LOADPTR   PLIENTRY
         L     R2,0(R1)           GET ADDRESS OF NAME
         L     R4,4(R1)           GET PTR ADDRESS
         LM    R0,R1,0(R2)
         L     R3,CVTPTR          NEED THIS FOR IEAVVMSR
         CLI   CVTDCB-CVT(R3),X'13' TEST FOR MVS
         BNE   LOD
         L     R15,CVTLPDSR-CVT(R3) ADDR OF IEAVVMSR
         BALR  R14,R15
         B     LPACODE           MODULE FOUND IN LPA
LOD      LOAD  EPLOC=(2),ERRET=ERR806X
         ST    R0,0(R4)
RET2     PLIEND
ERR806X  LA    R15,806
         MVC   0(4,R4),=X'FF000000'
         B     RET2
LPACODE  LR    R15,R0
         L     R15,LPDENTP-LPDE(R15)
         ST    R15,0(R4)
         SR    R15,R15
         B     RET2
         EJECT
* ENTRY: STCK
* FUNCTION: PRODUCE 64 BIT  TIME STAMP
*        CONTAINING MILLISECONDS SINCE 1/1/1900.
* AUTHOR: HOWARD GILBERT
* DATE: JAN 27,1977
* SYSTEM: ANY VS1 OR MVS
* NOTE: NO CORRECTION FOR GMT IS MADE
         SPACE 1
*        DCL STCK ENTRY(CHAR(8));
         SPACE 1
         ENTRY STCK
STCK     L     R1,0(R1)           ADDRESS DESCRIPTOR
         L     R1,0(R1)
         STCK  0(R1)             USE PART OF SAVE AREA
         BR    R14
         EJECT
* ENTRY: TCAPTR
* FUNCTION: RETURNS R12 AS A PTR SO A PLI PROGRAM CAN ACCESS
*           THE PLI SYSTEM CONTROL BLOCKS
* AUTHOR:   HOWARD GILBERT
* DATE:     JULY 16, 1977
*   DCL TCAPTR ENTRY RETURNS(PTR);
*   USE TCAPTR AS BASE FOR A STRUCTURE
         ENTRY TCAPTR
TCAPTR   L     R1,0(R1)
         ST    R12,0(R1)
         BR    R14
         EJECT
* ENTRY: PTRIN AND PTROUT
* FUNCTION: PERMITS POINTER ARITHMETIC
* AUTHOR:   HOWARD GILBERT
* DATE:     APRIL 10, 1977
*
* KLUGE:    PLI IS A 'PURE' LANGUAGE FROM IBM'S POINT OF VIEW.
*           IN ADDITION TO THE OTHER MACHINE DEPENDENT THINGS IT
*           EXCLUDES, ONE IS NOT PERMITTED TO CALCULATE POINTERS.
*           SUCH OPERATIONS ARE VALID IN PLS, AND A LOT OF PLS
*           STRUCTURES DEPEND ON IT. SO, TO GET AROUND THIS
*           PTRIN ACCEPTS A POINTER, CLEARS THE HIGH ORDER BYTE,
*           AND RETURNS IT AS A FIXED BIN(31) NUMBER. LIKEWISE
*           PTROUT ACCEPTS A FIXED BIN(31) NUMBER AND RETURNS
*           IT TO YOU AS A POINTER. YOU CAN DO THIS SORT OF THING
*           DIRECTLY IN PLI WITH UNSPEC TOO, BUT ITS A MATTER OF
*           ASTHETICS WHICH IS BEST.
         ENTRY PTRIN
PTRIN    SAVE  (2,3),,*
* DCL PTRIN ENTRY(PTR) RETURNS(FIXED BIN(31));
         LM    R2,R3,0(R1)
         L     R1,0(R2)
         LA    R1,0(R1)
         ST    R1,0(R3)
         RETURN (2,3)
         SPACE 5
         ENTRY PTROUT
PTROUT   SAVE  (2,3),,*
* DCL PTROUT ENTRY(FIXED BIN(31)) RETURNS(PTR);
         LM    R2,R3,0(R1)
         MVC   0(4,R3),0(R2)
         RETURN (2,3)
         EJECT
* ENTRY:    SDL,ADL
* FUNCTION: SUBTRACT AND ADD DOUBLE LOGICAL PSEUDO INSTRUCTIONS
*           GOOD FOR WORKING WITH TIMESTAMPS
* AUTHOR:   HOWARD GILBERT
* DATE:     MAY 10,1977
*  DCL SDL ENTRY(*,*);
*  DCL ADL ENTRY(*,*);
* THE TWO ARGUMENTS SHOULD BE 64 BIT ITEMS WITH DESCRIPTORS. CHAR(8),
* BIT(64), (2) FIXED BIN(31), OR 1, 2 FIXED BIN(31), 2 FIXED BIN(31)
* WILL ALL DO FINE.
* THE SECOND ARGUMENT IS ADDED TO (SUBTRACTED FROM) THE FIRST AND THE
* RESULT IS STORED BACK INTO THE FIRST ARGUMENT.
         ENTRY SDL,ADL
SDL      SAVE  (14,5)
         USING SDL,R15
         LM    R2,R3,0(R1)
         L     R2,0(R2)
         L     R3,0(R3)
         LM    R4,R5,0(R2)
         SL    R5,4(R3)
         BC    3,NOCARRY1
         BCTR  R4,0
NOCARRY1 SL    R4,0(R3)
         STM   R4,R5,0(R2)
         RETURN (14,5)
ADL      SAVE  (14,5)
         USING ADL,R15
         LM    R2,R3,0(R1)
         L     R2,0(R2)
         L     R3,0(R3)
         LM    R4,R5,0(R2)
         AL    R5,4(R3)
         BC    12,NOCARRY2
         AL    R4,ONE
NOCARRY2 AL    R4,0(R3)
         STM   R4,R5,0(R2)
         RETURN (14,5)
ONE      DC    F'1'
         EJECT
* ENTRY: TODCNVT
*
* FUNCTION: INTERFACE TO AMDPRSEG MODULE TO CONVERT A 64 BIT TIMESTAMP
*           OBTAINED BY STCK INTO A CHARACTER STRING GIVING YEAR,
*           JULIAN DATE AND TIME OF DAY
*
* ENTRY CONDITIONS:
*           DCL TODCNVT ENTRY(*) RETURNS(CHAR(24));
*
*   ARGUMENT CAN BE DECLARED CHAR(8) OR BIT(64) ALIGNED
*   VALUE RETURNED IS YYYYDDDHH.MM.SS.MMMMMM
         EJECT
TODCNVT PLIENTRY DSA=TCDSALEN
         USING TCDSA,R13
         LM    R2,R3,0(R1)
         MVC   TCARGL+4(4),0(R2)
         MVC   TCARGL+8(4),0(R3)
         L     R2,CVTPTR
         LA    R2,CVTTZ-CVT(R2)
         ST    R2,TCARGL
         LA    R1,TCARGL
         LA    R2,1
         BALR  R3,0
         SR    R0,R0
         SPM   R0
* THE ENTRY CONDITIONS TO TODCNVRT ARE:
*   R1 POINTS TO AN ARGUMENT LIST WITH 3 ADCONS
*       THE FIRST ARGUMENT IS A CVTTZ VALUE FOR GMT ADJUSTMENT
*       THE SECOND ARGUMENT IS AN 8 BYTE TOD CLOCK VALUE FROM STCK
*       THE THIRD ARGUMENT IS A 24 CHARACTER RETURN AREA
*   R2 CONTAINS A F'1' MEANING 'RETURN FULL DATE'
*   R13 POINTS TO A SAVE AREA
*   THE PROGRAM MASK IS DISABLED FOR FIXED POINT OVERFLOW
         WXTRN TODCNVRT
         CALL  TODCNVRT
         SPM   R3
         PLIEND
TCDSA    DSECT
         DS    CL88
TCARGL   DS    3A
TCDSALEN EQU   *-TCDSA
PLIMISC  CSECT
         EJECT
* PROCEDURE: COMWAIT
* FUNCTION: WAIT FOR TIME INTERVAL TO ELAPSE OR FOR
*     THE OPERATOR TO ISSUE A MODIFY OR STOP COMMAND
* ATTRIBUTES: REENTRANT
* VERSION: JUNE 4,1977
* AUTHOR: HOWARD GILBERT
* ENTRY CONDITIONS:
*
*      DCL COMWAIT ENTRY(FIXED BIN(31), CHAR(256) VAR)
*           RETURNS(FIXED BIN);
* THE FIRST ARGUMENT IS A TIME INTERVAL TO WAIT IN
*     UNITS OF 0.01 SECONDS.
* EXIT CONDITIONS:
* THE FUNCTION RETURNS A RETURN CODE:
*    0 - THE TIME INTERVAL ELAPSED AND NO OPERATOR ACTION
*        OCCURRED
*    4 - THE OPERATOR ISSUED A MODIFY COMMAND. THE DATA
*        ENTERED IN IN THE SECOND ARGUMENT.
*    8 - THE OPERATOR ISSUED A STOP COMMAND.
*   12 - AN ERROR HAS OCCURRED.
*****
* REGISTER USAGE:
*    R2 -> CSCB
*    R3 -> CIB
*    R4 -> FIRST ARG
*    R5 -> SECOND ARG
*    R6 -> THIRD ARG
*    R7 =  RETURN CODE
*
* SUPERVISOR SERVICES USED: WAIT,POST,STIMER,TTIMER,QEDIT
*
* NOTE:
*   THERE IS NO PROVISION FOR A PARAMETER TO BE PASSED TO
* THE STIMER EXIT. SO IT MUST BE COPIED TO THE GETMAIN
* AREA SO IT CAN USE ITS BASE ADDRESS TO FIND THE ECB.
*   THERE IS NO FEEDBACK ON THE AMOUNT OF TIME CONSUMED
* IF RETURN IS EFFECTED BY AN OPERATOR MODIFY COMMAND.
* APPLICATIONS WHICH REQUIRE A FIXED LENGHT INTERVAL
* AND PERMIT A MODIFY MUST RECALCULATE THE FIRST ARGUMENT
* BEFORE CALLING THIS ROUTINE AGAIN.  USE STCK TO
* TIMESTAMP THE START AND END OF THE WAIT.
*****
         EJECT
COMWAIT  PLIENTRY DSA=COMDSAL
         USING COMDSA,R13
         SPACE 2
* LOAD ARGUMENTS
         LM    R4,R6,0(R1)
         L     R5,0(R5)
         SR    R7,R7              PROVISIONAL RETURN CODE
         SPACE 2
* FIND CSCB
         L     R2,PSATOLD-PSA
         L     R2,TCBJSCB-TCB(R2)
         L     R2,JSCBCSCB-IEZJSCB(R2)
         USING CHAIN,R2
         SPACE 2
* CHECK STATUS OF CIB CHAIN
CIBCHK   L     R3,CHCIBP
         LTR   R3,R3
         BNZ   GETCIB
         SPACE 2
* NOW DOES THIS GUY WANT TO WAIT?
         L     R0,0(R4)
         LTR   R0,R0
         BNP   CWR
         SPACE 2
* COPY EXIT AND ECB TO DSA
         MVC   GETEXIT(EXITLEN),TIMEEXIT
         SPACE 2
* SET STIMER INTERVAL
         STIMER REAL,GETEXIT,BINTVL=(R4)
         SPACE 2
* BUILD ECB LIST AND WAIT
         LA    R0,TIMEECB-TIMEEXIT+GETEXIT DSA ECB
         ST    R0,ECBL1
         LA    R0,CHECB
         ST    R0,ECBL2
         OI    ECBL2,X'80'
         WAIT  ECBLIST=ECBL1,LONG=YES
         SPACE 2
* NOW WHAT HAPPENNED??
         L     R3,CHCIBP
         LTR   R3,R3
         BNZ   GETCIB
         TM    TIMEECB-TIMEEXIT+GETEXIT,X'40'
         BO    CWR
         LA    R7,12
         B     CWR
         SPACE 2
* WE HAVE A CIB, NOW IT CAN BE THE START CIB IF THIS IS THE
* FIRST CALL TO THIS SUBROUTINE IN THE CURRENT JOB. IF SO,
* WE THROW IT AWAY AND GO BACK TO CIBCHK
         USING CIB,R3
GETCIB   CLI   CIBVERB,CIBSTART
         BNE   ISITMOD
         QEDIT ORIGIN=CHCIBP,BLOCK=(R3)
         QEDIT ORIGIN=CHCIBP,CIBCTR=2
         B     CIBCHK
         SPACE 2
* NOW TEST FOR MODIFY
ISITMOD  CLI   CIBVERB,CIBMODFY
         BNE   STOP
         LH    R1,CIBDATLN
         STH   R1,0(R5)
         LTR   R1,R1
         LA    R7,4
         BZ    TCWR
         BCTR  R1,0
         EX    R1,MOVEDATA
         B     TCWR
         SPACE 2
STOP     LA    R7,8
TCWR     TTIMER CANCEL
         QEDIT ORIGIN=CHCIBP,BLOCK=(R3)
CWR      STH   R7,0(R6)
         PLIEND
         SPACE 2
MOVEDATA MVC   2(0,R5),CIBDATA
         DROP  R2,R3
         SPACE 2
* THIS IS THE PROTOTYPE STIMER EXIT. IT IS COPIED TO THE
* DSA ALONG WITH THE PROTOTYPE ECB. IT MUST BE ALIGNED ON
* A FULLWORD BOUNDARY SO THE ECB WILL BE MOVED TO A FULLWORD
* BOUNDARY.
TIMEEXIT DS    0F
         USING *,R15
         POST  TIMEECB
         BR    R14
         DROP  R15
TIMEECB  DC    A(0)
EXITLEN  EQU   *-TIMEEXIT
         SPACE 2
COMDSA   DSECT
         DS    CL88
ECBL1    DS    A
ECBL2    DS    A
GETEXIT  DS    (EXITLEN)X
COMDSAL  EQU   *-COMDSA
PLIMISC  CSECT
         EJECT
         LTORG
         PRINT NOGEN
         CVT   DSECT=YES
         IHAPSA
         IHAASCB
         IKJTCB
         IEZJSCB
CSCB     DSECT
         IEECHAIN
CIB      DSECT
         IEZCIB
         IHALPDE
         END
