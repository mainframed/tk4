CMST     TITLE 'CMS DUMP TAPE CONVERSION UTILITY'
CMSTOPDS CSECT ,
         USING *,R3,R11            DEFINE PROGRAM BASE
         STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS
         LR    R3,R15              LOAD PROGRAM BASE
         LA    R11,2048(,R3)       SETUP SECONDARY BASE
         LA    R11,2048(,R11)      DITTO
         LR    R2,R1               SAVE POINTER TO EXEC PARM FIELD
         LA    R0,72               INIDCATE LENGTH OF GETMAIN AREA
         GETMAIN R,LV=(0)          GET A REGISTER SAVE AREA
         ST    R1,8(,R13)          CHAIN AHEAD
         ST    R13,4(,R1)          AND BACK
         LR    R13,R1              POINT TO THE SAVE AREA
         SPACE 2
**       THE CMS DUMP TAPE CONSISTS OF SERIES OF FILE DATA RECORDS,
**       FOLLOWED BY A DESCRIPTOR RECORD FOR EACH FILE. THIS
**       DESCRIPTOR RECORD CONTAINS VITAL INFORMATION ABOUT THE FILE,
**       SUCH AS RECORD FORMAT, SIZE, FILE NAME, TYPE AND MODE, ETC.
**       BECAUSE OF THIS, THE FILE CANNOT BE COPIED TO AN OS DISK
**       IN ITS FINAL FORM UNTIL THE DESCRIPTOR RECORD HAS BEEN READ
**       FROM TAPE. THIS PROGRAM ATTEMPTS TO READ THE ENTIRE CMS FILE
**       INTO CORE, AND RE-WRITE IT TO DISK AFTER THE DESCRIPTOR RECORD
**       HAS BEEN READ.  IF NOT ENOUGH CORE IS AVAILABLE IN THE REGION,
**       A TEMPORARY WORK FILE IS USED TO CONTAIN OVERFLOW RECORDS.
**
**
**       A GETMAIN IS DONE FOR ALL OF THE UNUSED CORE IN THE REGION.
**       20K OF THIS IS THEN RETURNED FOR USE BY SUBSEQUENT STORAGE
**       REQUESTS BY DATA MANAGEMENT ROUTINES, ETC.
         GETMAIN VU,LA=CORELIMS,A=COREWHER GET A LOT OF CORE
         FREEMAIN V,A=COREWHER     FREE IT, BUT REMEMBER HOW MUCH
         L     R0,COREMUCH         GET MAX AMOUNT OF CORE
         SH    R0,=Y(20000)        GIVE UP SOME FOR LATER USE
         ST    R0,COREMUCH         PLACE AMOUNT IN ARGUMENT LIST
         GETMAIN R,LV=(0)          RE-ACQUIRE THE CORE BLOCK
         ST    R1,COREWHER         SAVE ITS START ADDRESS
         ST    R1,CORENEXT         AND AGAIN, FOR SUB-ALLOCATION
         SR    R14,R14             CLEAR FOR DIVIDE
         L     R15,COREMUCH        GET TOTAL ALLOCATED CORE
         D     R14,=A(800)         GET NO. OF 800-BYTE BLOCKS
         MH    R15,=Y(800)         FIND OUT HOW MUCH WE'LL USE
         AR    R1,R15              PT PAST LAST USABLE BYTE
         ST    R1,CORETOP          AND REMEMBER CEILING OF BLOCK
         SPACE 1
         OPEN  (SYSPRINT,(OUTPUT))
         LA    R15,C'1'            SKIP TO TOP OF PAGE
         LA    R0,L'PRTITLE        GET LENGTH OF TITLE
         LA    R1,PRTITLE          AND POINT TO IT
         BAL   R14,PRTSUB          GO TO PRINT THE TITLE
         SPACE 1
         L     R2,0(,R2)           PT TO THE PARM LENGTH FIELD
         LH    R4,0(,R2)           GET LENGTH OF PARM FIELD
         LA    R2,2(,R2)           PT TO START OF PARM DATA
         LR    R8,R2               REMEMBER FOR LATER LENGTH CALCS
         SPACE 2
**       THE PARM FIELD IS INTERPRETED HERE TO SEE HOW THE USER
**       WANTS TO DEFINE AND/OR LIMIT OPERATION OF THE PROGRAM
PARMLOOP DS    0H
         LTR   R4,R4               ANY PARM FIELD LEFT
         BZ    PARMDONE            NO, GO TO PROCESS FILES
         NOP   PARMBYPP            FIRST TIME OPEN GATE
         OI    *-3,X'F0'           CLOSE THE GATE
         LA    R15,C'0'            SKIP A LINE
         LA    R0,L'PARMHDR        GET LENGTH OF MESSAGE
         LA    R1,PARMHDR          PT TO THE MESSAGE
         BAL   R14,PRTSUB          GO TO PRINT THE MESSAGE
         LA    R15,C' '            GO TO NEXT LINE
         LR    R0,R4               GET LENGTH OF PARM FIELD TO PRINT
         LR    R1,R2               POINT TO THE PARM FIELD
         BAL   R14,PRTSUB          GO TO PRINT THE PARM FIELD
         SPACE 2
**       A TABLE IS SEARCHED TO VALIDATE THE NEXT PARM KEYWORD, AND
**       TO FIND OUT WHAT IT MEANS.
PARMBYPP DS    0H
         LA    R14,9               INIT LOOP INCREMENT
         LA    R15,PARMTABN-1      PT TO END OF TABLE
         LA    R12,PARMTABL-9      AND TO START - (ELT SIZE)
         SPACE 1
PARMTBXH BXH   R12,R14,PARMERR     LOOP THRU THE KEYWORD TABLE
         CLC   0(5,R2),0(R12)      DOES PARM KEYWD MATCH TABLE
         BNE   PARMTBXH            NO, GO LOOK AGAIN
         MVC   DWORD(4),5(R12)     ALIGN HANDLER ADDRESS
         L     R1,DWORD            GET IT FOR BRANCHING
         BR    R1                  AND GO TO PROCESS KEYWORD
         SPACE 2
**       AN UNRECOGNIZABLE PARAMETER STRING HAS BEEN USED. PRINT
**       A DIAGNOSTIC MESSAGE, AND EXIT WITH AN ERROR CODE
PARMERR  DS    0H
         MVI   RETCODE,12          INDICATE THE ERROR CODE
         SR    R2,R8               FIND OUT WHERE ERROR EXISTS
         CVD   R2,DWORD            GET POSITION NO. IN DECIMAL
         UNPK  DWORD(4),DWORD+6(2) MAKE IT PRINTABLE
         OI    DWORD+3,X'F0'       AND FIX THE FUCKING SIGN
         MVC   PARMERRM+19(2),DWORD+2 PLACE ERROR POSITION IN MESSAGE
         LA    R15,C'0'            SKIP A LINE FIRST
         LA    R0,L'PARMERRM       GET LENGTH OF MESSAGE
         LA    R1,PARMERRM         PT TO THE MESSAGE
         BAL   R14,PRTSUB          GO TO PRINT THE MESSAGE
         B     DONE                AND EXIT TO CALLER
         SPACE 4
**       'CONT=' KEYWORD HANDLER
PARMCONT DS    0H
         LA    R15,CONTNAME        PT TO CONT KEYWORD SAVE FIELD
         BAL   R14,PARMCHOP        GO TO RETRIEVE THE VALUE
         B     PARMLOOP            AND CONTINUE PARAMETER ANALYSIS
         SPACE 1
**       'MASK=' KEYWORD HANDLER.
PARMMASK DS    0H
         LA    R15,MASKNAME        PT TO MASK TARGET FIELD
         BAL   R14,PARMCHOP        GO TO EXTRACT MASK
         LTR   R0,R0               WAS THERE REALLY ONE GIVEN
         BNM   PARMMSKY            YES, GO TO SETUP ITS USE
         OI    MASKBRAN+1,X'F0'    NO, DON'T CHECK FOR IT
         B     PARMLOOP            GO TO LOOK FOR MORE PARAMETERS
PARMMSKY STC   R0,MASKCLC+1        SETUP TO CHECK FOR SPECIAL FILES
         NI    MASKBRAN+1,X'8F'    BE SURE TO CHECK FOR THEM
         B     PARMLOOP            GO TO LOOK FOR MORE PARAMETERS
         SPACE 1
**       'MODE=' KEYWORD HANDLER
PARMMODE DS    0H
         LA    R15,MODENAME        PT TO MODE TARGET FIELD
         BAL   R14,PARMCHOP        GO TO EXTRACT THE MODE
         LTR   R0,R0               WAS ONE REALLY GIVEN
         BNM   PARMMDEY            YES, GO TO SETUP ITS USE
         OI    MODEBRAN+1,X'F0'    NO, SKIP LOOKING FOR IT LATER
         B     PARMLOOP            GO TO LOOK FOR MORE PARAMETERS
PARMMDEY STC   R0,MODECLC+1        SETUP TO CHECK FOR FILE MODES
         NI    MODEBRAN+1,X'8F'    BE SURE TO CHECK FOR THEM
         B     PARMLOOP            GO TO LOOK FOR MORE PARAMETERS NOW
         SPACE 1
**       'NAME=' KEYWORD HANDLER.
PARMNAME DS    0H
         LA    R15,NAMENAME        PT OT NAME TARGET FIELD
         BAL   R14,PARMCHOP        GO TO EXTRACT THE LIMITING NAME
         NI    NAMEBRAN+1,X'8F'    BE SURE TO CHECK IN CASE THERE IS
         LTR   R0,R0               WAS ONE INDEED GIVEN
         BNM   PARMLOOP            YES, IT WILL BE CHECKED FOR LATER
         OI    NAMEBRAN+1,X'F0'    NO, SKIP LOOKING FOR IT LATER
         B     PARMLOOP            AND GO LOOK FOR MORE PARAMETERS NOW
         SPACE 1
**       'OUTF=' KEYWORD HANDLER.
PARMOUTF DS    0H
         LA    R15,OUTFNAME        PT TO OUTF KEYWORD SAVE FIELD
         BAL   R14,PARMCHOP        GO GET SPECIFIED VALUE
         B     PARMLOOP            AND THEN CHECK FOR MORE PARAMETERS
         SPACE 1
**       'TYPE=' KEYWORD HANDLER.
PARMTYPE DS    0H
         LA    R15,TYPENAME        PT TO TYPE TARGET FIELD
         BAL   R14,PARMCHOP        GO TO EXTRACT THE TYPE
         LTR   R0,R0               WAS ONE REALLY SPECIFIED
         BNM   PARMTPEY            YES, GO TO SETUP FOR IT
         OI    TYPEBRAN+1,X'F0'    NO, SKIP LOOKING AT IT
         B     PARMLOOP            GO TO LOOK FOR MORE PARAMETERS
PARMTPEY STC   R0,TYPECLC+1        SETUP TO LOOK AT TYPE LATER
         NI    TYPEBRAN+1,X'8F'    BE SURE TO CHECK FOR IT
         B     PARMLOOP            AND GO TO LOOK FOR MORE PARMS NOW
         SPACE 1
**       'REPL=' KEYWORD HANDLER.
PARMREPL DS    0H
         LA    R15,REPLNAME        PT TO TARGET FIELD
         BAL   R14,PARMCHOP        GO TO EXTRACT REPL VALUE
         B     PARMLOOP            AND GO LOOK FOR MORE PARMS
         SPACE 2
**       ANALYSIS OF THE PARM FIELD IS COMPLETE. NOW START PROCESSING
**       THE CMS DUMP TAPE.
PARMDONE DS    0H
         CLC   OUTFNAME(3),=CL3'SEQ' IS PS OUTPUT DESIRED
         BNE   OUTPDS              NO, SKIP DCB REDEFINITION
         MVC   PDSMACR(2),=AL1(0,DCBMRPUT+DCBMRMVP) YES, REDEF MACRF
         NI    PDSDSORG,255-DCBDSGPO MAKE UNPARTITIONED
         OI    PDSDSORG,DCBDSGPS   AND SEQUENTIAL
OUTPDS   OPEN  (DISK,(OUTPUT))     OPEN THE TARGET FILE
         TM    PDSOFLGS,DCBOFOPN   WAS IT OPENED OK
         BO    DSKOPEND            YES, CONTINUE NORMALLY
         LA    R15,C'0'            NO, START DIAGNOSTIC SETUP
         LA    R0,L'DISKOMSG       GET LENGTH OF THE DIAGNOSTIC
         LA    R1,DISKOMSG         AND START OF MESSAGE
         BAL   R14,PRTSUB          GO TO PRINT IT
         MVI   RETCODE,20          SHOW THINGS DIDN'T GO TOO WELL
         B     DONE                GO TO EXIT
         SPACE 1
DSKOPEND DS    0H
**       IF TARGET DATASET IS VARIABLE LENGTH, ACQUIRE A BUFFER
**       TO WRITE THE RDW PREFIXED RECORDS FROM.
         TM    PDSRECFM,DCBRECV    IS FILE VARIABLE LENGTH FORMAT
         BZ    DSKNVAR             NO, SKIP BUFFER SETUP
         LH    R0,PDSLRECL         YES, GET POSSIBLE LENGTH OF BUFFER
         TM    PDSDSORG,DCBDSGPS   IS IT ALSO SEQUENTIAL
         BO    *+8                 YES, WE HAVE THE CORRECT BUFFER LEN
         LH    R0,PDSBLKSI         NO,PARTITIONED, GET LARGE BUFFER
         GETMAIN R,LV=(0)          GET THE RECORD BUFFER
         ST    R1,VARBUFR          SAVE THE BUFFER ADDRESS
DSKNVAR  DS    0H
         LA    R15,C'0'            PREPARE HEADER LINE
         LA    R0,L'HEADS          GET LENGTH OF HEADER
         LCR   R0,R0               NEGATE FOR POST-SKIP
         LA    R1,HEADS            POINT TO THE MESSAGE
         BAL   R14,PRTSUB          AND GO TO PRINT IT
         LH    R1,PDSBLKSI         GET DATASET BLOCKSIZE
         STH   R1,MAXBLKSI         AND REMEMBER FOR WRITE ROUTINE
         OPEN  (CMSTAPE)           OPEN THE CMS DUMP TAPE FILE
         TM    CMSOFLGS,DCBOFOPN   IS THE TAPE THERE, AND ALL
         BO    CMSOPEND            YES, START TO READ
         LA    R15,C'0'            NO, FORM ERROR MESSAGE
         LA    R0,L'CMSOMSG        GET LENGTH OF THE MESSAGE
         LA    R1,CMSOMSG          AND ITS START POINT
         BAL   R14,PRTSUB          GO TO PRINT THE MESSAGE
         MVI   RETCODE,16          INDICATE ERROR CODE
         B     DONE                GO TO RETURN TO CALLER
         SPACE 1
CMSOPEND DS    0H
         LA    R12,CODES-L'CODE1   GET START OF DESCRIPTOR MSG TABLE
         LA    R8,L'CODE1          GET MESSAGE SIZE
         LA    R9,CODESEND-1       PT TO LOOP TERMINATOR
CODESBXH BXH   R12,R8,CODESDON     LOOP THRU DESCRIPTOR TABLE
         LA    R15,C' '            SINGLE SPACE THE MESSAGE
         LR    R0,R8               GET ELEMENT LENGTH
         LR    R1,R12              AND ITS ADDRESS
         BAL   R14,PRTSUB          GO TO PRINT A DESCRIPTION LINE
         B     CODESBXH            AND GET NEXT MESSAGE
CODESDON DS    0H
         SPACE 2
**       EACH BLOCK ON THE DUMP TAPE IS 805 BYTES LONG.  THE
**       BLOCKS ARE SIMPLY READ AND SAVED IN CORE OR ON DISK, UNTIL THE
**       DESCRIPTOR RECORD IS READ, SIGNALLING THE END OF THE CMS FILE.
CMSRD    GET   CMSTAPE             READ THE NEXT BLOCK
         LR    R4,R1               REMEMBER WHERE IT IS
         CLC   0(4,R1),CMSCONST    IS THIS REALLY A CMS DUMP TAPE
         BNE   NOTCMS              NO, GO TO TELL ABOUT IT ALL
         CLI   4(R1),C'N'          IS THIS THE DESCRIPTOR RECORD
         BE    CMSEOF              YES, GO TO PROCESS THE FULL FILE
CMSWORKA NOP   WRKOPEND            GATE FOR CORE/DISK USAGE
         L     R2,CORENEXT         GET NEXT AVAILABLE CORE SLOT
         LA    R15,800(,R2)        UPDATE TO WHERE BLOCK WILL END
         CL    R15,CORETOP         IS IT WITHIN BOUNDS
         BH    OUTOFCOR            NO, START USING DISK SPACE
         MVC   0(256,R2),5(R1)     GET RECORD INTO CORE BLOCK
         MVC   256(256,R2),261(R1) DITTO...
         MVC   512(256,R2),517(R1) .DITTO..
         MVC   768(32,R2),773(R1)  ..DITTO.
         ST    R15,CORENEXT        UPDATE NEXT AVAILABLE POINTER
         B     CMSRD               AND GO BACK FOR MORE
         SPACE 2
**       IF TAPE IS NOT IN CMS DUMP TAPE FORMAT, A DIAGNOSTIC IS
**       PRINTED, AND THE PROGRAM TERMINATES
NOTCMS   LA    R15,C'0'            SKIP A LINE
         LA    R0,L'NOTCMSG        GET LENGTH OF DIAGNOSTIC
         LA    R1,NOTCMSG          PT TO THE MESSAGE
         BAL   R14,PRTSUB          GO TO PRINT THE MESSAGE
         MVI   RETCODE,4           PASS ERROR CODE
         B     TAPEEOF             AND RETURN TO CALLER
         SPACE 2
**       IF THERE IS NOT ENOUGH CORE TO CONTAIN THE FILE, IT IS
**       SPILLED TO TEMPORARY DISK SPACE.  A RECORD IS MAINTAINED
**       OF THE CORE THAT SHOULD BE ALLOCATED TO PREVENT DISK USAGE,
**       AND THE USER IS INFORMED OF THE AMOUNT OF CORE THAT EACH FILE
**       NEEDS.
OUTOFCOR DS    0H
         XC    CORENEXT(4),CORENEXT SHOW NO CORE LEFT
         XC    OVERFLOW(2),OVERFLOW AND INIT THE DISK RECORD COUNTER
         OI    CMSWORKA+1,X'F0'    FORCE DISK USAGE ON SUBSEQ RECORDS
CMSWORKB NOP   WRKOPEND            OPEN WORKFILE GATE
         OI    *-3,X'F0'           CLOSE THE GATE
         OPEN  (SYSUT1,(OUTPUT))   AND OPEN THE FILE
         TM    UT1OFLGS,DCBOFOPN   IS IT OPEN
         BO    WRKOPEND            YES, GO USE IT
         LA    R15,C'0'            NO, SETUP ERROR MESSAGE
         LA    R0,L'WRKOMSG        GET LENGTH OF DIAGNOSTIC
         LA    R1,WRKOMSG          PT TO THE MESSAGE
         BAL   R14,PRTSUB          AND GO TO PRINT IT
         MVI   RETCODE,16          INDICATE ERROR CODE
         B     DONE                AND RETURN TO CALLER
         SPACE 2
**       THE WORK FILE IS OPEN.  UPDATE THE RECORD COUNT, AND WRITE
**       THE RECORD
WRKOPEND DS    0H
         LH    R1,OVERFLOW         GET CURRENT RECORD COUNT
         LA    R1,1(,R1)           UP IT
         STH   R1,OVERFLOW         AND RESTORE IT
         LA    R4,5(,R4)           PT PAST CMS ID BYTES
         PUT   SYSUT1,(R4)         WRITE THE RECORD
         B     CMSRD               AND GO FOR ANOTHER ONE
         SPACE 2
**       THE DESCRIPTOR RECORD HAS BEEN REACHED, SIGNALLING THE END
**       OF THE CMS DUMPED FILE. EXTRACT FILE INFORMATION FROM THE
**       RECORD, AND DETERMINE WHAT TO DO WITH THE FILE
CMSEOF   DS    0H
         USING PARTFST,R2          ADDRESS THE FILE STATUS TABLE DSECT
         LR    R2,R1               POINT TO IT
         OC    CORENEXT(4),CORENEXT WAS THE WORK FILE USED THIS TIME
         BNZ   CMSEOFNW            NO, SKIP RE-POSITION
         CLOSE (SYSUT1,REREAD)     RE-POSITION THE FILE TO READ IT
         OPEN  (SYSUT1,(INPUT))    PREPARE TO READ OVERFLOWS
         NI    CMSWORKB+1,X'0F'    OPEN GATE FOR NEXT OUTPUT USE
CMSEOFNW DS    0H
         MVC   0(24,R2),5(R2)      SHIFT THE DESCRIPTOR INFORMATION
         MVC   24(18,R2),69(R2)    AND ALIGN ID. INFORMATION
         MVI   REPORT,C' '         CLEAR...
         MVC   REPORT+1(L'REPORT-1),REPORT ...PRINT LINE
         MVC   RNAME(8),FSTFNAME   MOVE FILE NAME TO PRINTLINE
         MVC   RTYPE(8),FSTFTYPE   MOVE FILE TYPE TO PRINTLINE
         MVC   RMODE(2),FSTFMODE   MOVE FILE MODE TO PRINTLINE
         MVC   RVF(1),FSTRECFM     MOVE FILE FORMAT TO PRINTLINE
         UNPK  DWORD(9),FSTDATE(5) MAKE DATE/TIME PRINTABLE
         MVC   RMMDDYY(2),DWORD    GET THE MM PART
         MVI   RMMDDYY+2,C'/'      MAKE IT FAMILIAR
         MVC   RMMDDYY+3(2),DWORD+2 GET THE DD PART
         MVI   RMMDDYY+5,C'/'      MAKE IT FAMILIAR
         MVC   RMMDDYY+6(2),FSTYEAR GET THE YY PART
         MVC   RHHMM(2),DWORD+4    GET THE HH PART
         MVI   RHHMM+2,C'.'        MAKE IT FAMILIAR
         MVC   RHHMM+3(2),DWORD+6  GET THE MM PART
         LH    R14,FSTRECS         GET NO OF RECORDS THIS FILE USES
         CVD   R14,DWORD           START PRINTABLE CONVERSION
         UNPK  RNOREC(5),DWORD+5(3) GET IT IN EBCDIC
         OI    RNOREC+4,X'F0'      AND FIX THE FUCKING SIGN
         LH    R14,FSTITEMS        GET NO. OF LOGICAL RECORDS IN FILE
         CVD   R14,DWORD           START PRINTABLE CONVERSION
         UNPK  RLRECS(5),DWORD+5(3) GET IT IN EBCDIC
         OI    RLRECS+4,X'F0'      FIX THE FUCKING SIGN
         L     R14,FSTMAXL         GET RECORD SIZE
         CVD   R14,DWORD           START PRINTABLE THING
         UNPK  RMAXSIZ(10),DWORD+3(5) TO EBCDIC
         OI    RMAXSIZ+9,X'F0'     AND FIX THE FUCKING SIGN
         SPACE 2
**       THE ATTRIBUTES OF THE CMS FILE ARE EXAMINED TO
**       DETERMINE IF IT SHOULD BE COPIED TO THE OUTPUT
**       DATA SET.
         MVC   RACTION(L'BYPASSED),BYPASSED ASSUME NO COPY ACTION
         TM    PDSRECFM,DCBRECF    IS TARGET FILE FIXED LENGTH
         BO    CMSFIXED            YES, GO CHECK LENGTH
CMSNFIXD DS    0H
         TM    PDSRECFM,DCBRECV    IS FILE VARIABLE LENGTH
         BO    CMSVRYNG            YES, GO COPY TO IT
         MVI   RACTION+10,C'1'     NO, CAN'T COPY TO IT
         SR    R2,R2               SHOW NO COPY
         B     CMSPRT              AND GO TO TELL ABOUT IT
CMSVRYNG DS    0H
         LH    R14,PDSLRECL        GET TARGET FILE RECORD LENGTH
         SH    R14,=Y(4)           ADJUST FOR IMBEDDED RDW
         C     R14,FSTMAXL         WILL PDS ACCOMODATE FILE
         BNL   CMSIZOK             YES, GO SEE IF ITS WANTED
         B     CMSBADLN            NO, SET ERROR CODE
CMSFIXED DS    0H
         LH    R14,PDSLRECL        GET RECORD LENGTH OF EXISTING PDS
         C     R14,FSTMAXL         CAN PDS ACCOMODATE THE FILE
         BE    CMSIZOK             YES, SEE IF ITS WANTED
CMSBADLN MVI   RACTION+10,C'2'     NO, TELL WHY
         SR    R2,R2               SHOW NO-COPY OF FILE
         B     CMSPRT              GO TO TELL ABOUT IT
         SPACE 1
CMSIZOK  DS    0H
TYPECLC  CLC   FSTFTYPE(0),TYPENAME DOES TYPE MATCH TYPE LIMITER
TYPEBRAN BC    15,MODECLC          ACCEPT IF SO
         MVI   RACTION+10,C'3'     NO, TELL WHY NOT
         SR    R2,R2               SHOW NO-COPY
         B     CMSPRT              GO TO TELL ABOUT IT ALL
         SPACE 1
MODECLC  CLC   FSTFMODE(0),MODENAME DOES MODE MATCH LIMITER
MODEBRAN BC    15,MASKCLC          ACCEPT IF SO
         MVI   RACTION+10,C'4'     NO, TELL WHY
         SR    R2,R2               SHOW NO-COPY
         B     CMSPRT              GO TO TELL ABOUT IT ALL
         SPACE 1
MASKCLC  CLC   FSTFNAME(0),MASKNAME DOES NAME MATCH MASK LIMITER
MASKBRAN BC    15,NAMECLC          ACCEPT IF SO
         MVI   RACTION+10,C'5'     NO, TELL WHY
         SR    R2,R2               SHOW NO-COPY
         B     CMSPRT              GO TO TELL ABOUT IT ALL
         SPACE 1
NAMECLC  CLC   FSTFNAME(8),NAMENAME DOES NAME MATCH LIMITER
NAMEBRAN BC    15,CMSCOPY          ACCEPT IF SO
         MVI   RACTION+10,C'6'     NO, TELL WHY
         SR    R2,R2               SHOW NO-COPY
         B     CMSPRT              GO TO TELL ALL ABOUT IT
         SPACE 2
**       A COPY OF THE CMS FILE IS OK. APPROPRIATE CONTROLS ARE
**       SET UP, AND THE COPY IS PERFORMED
CMSCOPY  LH    R5,FSTITEMS         GET NO OF LOGICAL RECS TO COPY
         LH    R4,PDSLRECL         SET REC LENGTH IN CASE SEQ.
         L     R7,COREWHER         YES, POINT TO FIRST RECORD
         TM    PDSRECFM,DCBRECF    IS FILE FIXED
         BZ    CPYVARY             NO, GO PROCESS VARYING FILE
         LA    R1,CPYFXOUT         GET SYSUT1 EODAD ADDRESS
         ST    R1,CPYUTEOF         AND SAVE FOR LATER
         TM    PDSDSORG,DCBDSGPS   IS OUTPUT SEQUENTIAL
         BO    CPYFXOUT            YES, SKIP BUFFERING SETUP
         LH    R15,MAXBLKSI        NO, GET PDS BLOCKSIZE
         SR    R14,R14             CLEAR FOR DIVIDE
         L     R1,FSTMAXL          GET LOGICAL RECORD LENGTH
         DR    R14,R1              COMPUTE BLOCKING FACTOR
         LTR   R14,R14             IS IT INTEGRAL
         BZ    CPYFXINT            YES,CONTINUE SETUP
         MVI   RACTION+10,C'2'     INDICATE LRECL PROBLEMS
         SR    R2,R2               SHOW NO COPY
         B     CMSPRT              AND GO TO SHOW FILE STATUS
CPYFXINT SR    R4,R4               CLEAR FOR DIVIDE
         DR    R4,R15              COMPUTE PHYS BLKS TO BE WRITTEN
         STH   R4,LEFTOVER         REMEMBER FOR SHORT LAST BLK
         LTR   R5,R5               ANY FULL BLOCKS TO WRITE
         BZ    CPYFXSRT            NO, GO WRITE ONE SHORT BLOCK
         LH    R4,MAXBLKSI         SET TO LENGTH OF WRITES
         SPACE 1
CPYFXOUT TM    PDSDSORG,DCBDSGPS   IS OUTPUT SEQUENTIAL DATA SET
         BZ    CPYTOPDS            NO, SET UP FOR PARTITIONED WRITE
         PUT   DISK,(R7)           YES, WRITE OUT NEXT LOGICAL RECORD
         B     CPYFXNXT            AND GET NEXT RECORD
CPYTOPDS STH   R4,PDSBLKSI         SET LENGTH OF WRITE
         WRITE PDSDECB,SF,DISK,(R7),MF=E WRITE NEXT PHYS BLOCK
         CHECK PDSDECB             AND WAIT FOR COMPLETION
CPYFXNOT NOP   CPYFXNXT            GATE FOR FIRST BLK OF MEMBER
         OI    *-3,X'F0'           CLOSE THE GATE
         NOTE  DISK                GET FIRST BLOCK ADDRESS
         ST    R1,STOWTTR          AND REMEBER IT
         SPACE 1
CPYFXNXT DS    0H
         AR    R7,R4               UPDATE TO NEXT LOGICAL RECORD
         BCT   R5,CPYFXDCR         DECREMENT MASTER RECORD COUNT
         TM    PDSDSORG,DCBDSGPS   IS THIS A SEQ DATASET
         BO    CPYFXDON            YES, NO BUFFER HANDLING REQUIRED
         LH    R4,LEFTOVER         NO, GET REMAINING NO OF LRECS
         LTR   R4,R4               ARE THERE ANY
         BZ    STOW                NONE LEFT, GO STORE MEMBER NAME
CPYFXSRT XC    LEFTOVER(2),LEFTOVER CLEAR FOR NEXT PASS THRU
         MH    R4,FSTMAXL+2        GET REMAINING NO OF BYTES
         LA    R5,1                FORCE ONE MORE BLOCK WRITE
CPYFXDCR L     R15,CORETOP         POINT ABOVE OUR FILE BUFFER
         SR    R15,R7              GET BYTES LEFT IN THE BUFFER
         CR    R4,R15              IS IT AT LEAST ONE RECORD
         BNH   CPYFXOUT            YES, WRITE IT OUT
         BAL   R14,CPYUT1          NO, REST OF CMS FILE IS ON UT1
         B     CPYFXOUT            SOME MORE IN CORE TO COPY
         SPACE 2
**       ALL FULL RECORDS IN CORE HAVE BEEN WRITTEN TO THE TARGET
**       DATASET.  THE OVERFLOW WORK FILE IS NOW READ FOR AS MANY
**       RECORDS AS WILL FIT IN THE CORE BUFFER.  THE FRAGMENT
**       RECORD STILL IN CORE (IF ANY) IS REPOSITIONED AT THE START OF
**       THE CORE BUFFER.
CPYUT1   ST    R14,RETSAVEB        SAVE CALLER'S RETURN ADDRESS
         L     R6,COREWHER         GET START OF CMS BUFFER BLOCK
         LR    R7,R6               POINT TO START OF CORE BUFFER
         LTR   R15,R15             IS A PARTIAL RECORD IN CORE
         BZ    CPYFXGET            NO, NOTHING TO SAVE
         LR    R9,R15              YES, REMEMBER HOW MUCH IS LEFT
         SR    R8,R8               CLEAR FOR DIVIDE
         D     R8,=A(800)          GET NO. OF CMS BLOCKS IT OCCUPIES
         LTR   R8,R8               IS IT AN INTEGRAL AMOUNT
         BZ    CPYFXCPY            YES, NO FIDDLING TO DO
         LA    R1,800              GET CMS DATA BLOCK SIZE
         SR    R1,R8               FIND RELATIVE START OF RECORD IN BK
         AR    R7,R1               NOW GET ABSOLUTE START OF FRAGMENT
         LA    R9,1(,R9)           GET REAL NO OF BLOCKS TO MOVE
CPYFXCPY LR    R15,R9              GET NO OF BLOCKS TO COPY
         MH    R15,=Y(800)         AND NO OF BYTES THAT WILL BE
         L     R14,CORETOP         PT ABOVE LAST BYTE TO BE MOVED
         SR    R14,R15             GET FIRST BYTE THAT WILL BE MOVED
CPYFXMVC MVC   0(256,R6),0(R14)    MOVE A CHUNK
         MVC   256(256,R6),256(R14) AND ANOTHER
         MVC   512(256,R6),512(R14)  AND ANOTHER
         MVC   768(32,R6),768(R14) AND WE'RE DONE WITH THIS CMS BLOCK
         LA    R6,800(,R6)         UPDATE TARGET AREA
         LA    R14,800(,R14)       AND PT TO NEXT CMS BLOCK
         BCT   R9,CPYFXMVC         GO COPY NEXT BLOCK
         SPACE 1
**       THE FRAGMENT LOGICAL CMS RECORD HAS BEEN PLACED SO THAT
**       IT WILL BE CONTIGUOUS WITH THE REMAINDER OF THE RECORD, WHICH
**       WILL NOW BE READ FROM THE WORK FILE
CPYFXGET GET   SYSUT1,(R6)         GET AN OVERFLOW RECORD
         LA    R6,800(,R6)         PT TO NEXT TARGET AREA
         CL    R6,CORETOP          IS IT TOO HIGH
         BL    CPYFXGET            NO, GET ANOTHER REOCRD
         L     R14,RETSAVEB        GET CALLER'S RETURN ADDRESS
         BR    R14                 AND GO THERE
         SPACE 1
UT1EOF   DS    0H
         L     R1,CPYUTEOF         ALL OVERFLOW RECORDS ARE IN CORE
         BR    R1                  RETURN TO APPROPRIATE COPYING ROUTIN
         SPACE 3
CPYVARY  DS    0H
         L     R10,VARBUFR         GET ADDRESS OF VARIABLE RECORD BUFFR
         LA    R1,CPYVROUT         PT TO UT1 EOD RETURN
         ST    R1,CPYUTEOF         AND SAVE FOR WHEN IT HAPPENS
CPYVROUT TM    PDSDSORG,DCBDSGPS   IS THE OUTPUT SEQUENTIAL
         BZ    CPYVRPDS            NO, GO TO PDS HANDLER
         CLI   FSTRECFM,C'F'       IS CMS FILE FIXED LENGTH
         BNE   CPYVROUV            NO, GO HANDLE VARIABLE LENGTH FILE
         LH    R15,FSTMAXL+2       YES, GET CONSTANT LENGTH
         BCTR  R7,0                BACKUP FOR COMMON MOVE
         BCTR  R7,0                DITTO
         B     CPYVROUC            AND REJOIN COMMON COPY CODE
CPYVROUV MVC   DWORD(2),0(R7)      GET CURRENT CMS RECORD LENGTH ALGND
         LH    R15,DWORD           AND PUT IT WHERE ITS USEFUL
CPYVROUC LA    R14,2(,R15)         GET CMS BUFFER INCREMENT
         BCTR  R15,0               SUB 1 FOR MVC LENGTH CODE
         STC   R15,CPYVRMVS+1      PLACE LENGTH IN THE MOVE
         LA    R15,5(,R15)         NOW GET OS RECORD LENGTH
         SLL   R15,16              PLACE IN HIGH HALFWORD
         ST    R15,DWORD           ALIGN RECORD LENGTH
         MVC   0(4,R10),DWORD      AND PLACE IN OUTPUT RECORD
CPYVRMVS MVC   4(*-*,R10),2(R7)    MOVE FROM CMS TO OS BUFFER
         AR    R7,R14              INCREMENT TO NEXT POTENTIAL CMS REC
         PUT   DISK,(R10)          WRITE OUT THE OS VARIABLE LENGTH REC
         BCTR  R5,0                DECREMENT RECORD COUNT
         LTR   R5,R5               ANY LOGICAL CMS RECORDS LEFT
         BZ    CPYVRDON            NO, SKIP OUT OF COPY
         BAL   R14,CPYVRNXT        YES, VERIFY THEY'RE IN CORE
         B     CPYVROUT            AND GO COPY THEM
         SPACE 1
**       VARIABLE OR FIXED LENGTH CMS RECORDS ARE COPIED TO A
**       VARIABLE LENGTH OS PDS
CPYVRPDS DS    0H
         LA    R1,4                SET INIT BLOCK LEN FOR BDW
         AR    R10,R1              POINT TO INIT SPOT IN BLOCK BUFFER
CPYVRPLP CLI   FSTRECFM,C'F'       IS TEH CMS RECORD FIXED
         BNE   CPYVRPLV            NO, GO HANDLE VARIABLE LENGTH REC
         LH    R15,FSTMAXL+2       YES, GET CONSTANT LENGTH
         BCTR  R7,0                FUDGE FOR COMMON MVC
         BCTR  R7,0                DITTO
         B     CPYVRPLC            GO REJOIN COMMON CODE
CPYVRPLV MVC   DWORD(2),0(R7)      GET LENGTH OF CMS RECORD ALIGNED
         LH    R15,DWORD           AND NOW MAKE IT USEFUL
CPYVRPLC LA    R14,2(,R15)         GET CMS BUFFER INCREMENT TO NXT REC
         LA    R1,2(R1,R14)        AND GET BYTES USED IN OS BUFFER
         BCTR  R15,0               SUB 1 FOR MVC LENGTH CODE
         STC   R15,CPYVRMVP+1      SET LENGTH OF MVC
         LA    R15,5(,R15)         NOW GET LENGTH OF OS RECORD
         SLL   R15,16              PUT IN TOP HALF OF REGISTER
         ST    R15,DWORD           ALIGN RECORD LENGTH
         MVC   0(4,R10),DWORD      AND PLACE IN OUTPUT BLOCK
CPYVRMVP MVC   4(*-*,R10),2(R7)    MOVE FROM CMS TO OS BUFFER
         SRL   R15,16              GET REAL LENGTH AGAIN
         AR    R10,R15             GET NEXT SLOT IS OS BUFFER
         AR    R7,R14              AND NEXT RECORD IN CMS BUFFER
         BCTR  R5,0                DECREMENT CMS LOG RECORD COUNT
         LTR   R5,R5               ANY RECORDS LEFT
         BZ    CPYVRWRT            NO, GO WRITE LAST BLOCK
         ST    R1,REGSAVE          YES, SAVE OUTPUT BYTE COUNT
         BAL   R14,CPYVRNXT        AND  GO SEE IF THEY'RE IN CORE
         L     R1,REGSAVE          RESTORE OUTPUT BYTE COUNT
         LR    R0,R1               GET CURRENT BYTES IN OS BUFFER
         CLI   FSTRECFM,C'F'       IS CMS FILE FIXED
         BNE   CPYVRBLV            NO, GO HANDLE VARYING RECORDS
         MVC   DWORD(2),FSTMAXL+2  YES, GET CONSTANT RECORD LENGTH
         B     CPYVRBLC            AND REJOIN COMMON CODE
CPYVRBLV MVC   DWORD(2),0(R7)      GET LENGTH OF NEXT RECORD
CPYVRBLC AH    R0,DWORD            UP FOR NEXT RECORD...
         AH    R0,=Y(4)            AND IT'S COUNT FIELD
         CH    R0,PDSBLKSI         ENOUGH ROOM FOR ANOTHER REOCORD
         BNH   CPYVRPLP            YES, GO GET IT
         SPACE 1
CPYVRWRT DS    0H
         SLL   R1,16               GET BLOCK LENGTH IN TOP OF REGISTER
         L     R10,VARBUFR         POINT TO START OF BUFFER
         ST    R1,0(,R10)          SHOW HOW MUCH TO WRITE
         WRITE PDSDECB,SF,DISK,(R10),MF=E AND WRITE THE BLOCK
         CHECK PDSDECB             WAIT FOR COMPLETION
CPYVRNOT NOP   CPYVRNNO            GATE FOR FIRST MEMBER BLK
         OI    *-3,X'F0'           CLOSE THE GATE
         NOTE  DISK                REMEMBER WHERE WE STARTED MEMBER
         ST    R1,STOWTTR          AND SAVE IN STOW PARAMETER AREA
CPYVRNNO DS    0H
         LTR   R5,R5               IS THE COPY COMPLETE
         BNZ   CPYVARY             NO, MORE RECORDS TO COPY
         SPACE 2
CPYVRDON DS    0H
         TM    PDSDSORG,DCBDSGPS   IS OUTPUT FILE SEQUENTIAL
         BO    CPYFXDON            YES, GO TELL ABOUT THE COPY
         NI    CPYVRNOT+1,X'0F'    RE-OPEN THE NOTE GATE
         B     STOWCOMM            AND GO STOW THE MEMBER
         SPACE 1
CPYVRNXT DS    0H
         ST    R14,RETSAVEA        SAVE RETURN ADDRESS
         L     R15,CORETOP         POINT ABOVE LARGE BUFFER
         SR    R15,R7              GET BYTES LEFT IN THAT BUFFER
         CH    R15,=Y(1)           JUST 1 LEFT
         BNH   CPYVRNX1            YES, OR LESS, MUST GET NXT FROM OFLW
         CLI   FSTRECFM,C'F'       IS THE CMS FILE FIXED
         BNE   CPYVRNXV            NO, GO HANDLE VARYING FILE
         LH    R1,FSTMAXL+2        YES, GET CONSTANT LENGTH
         B     CPYVRNXC            REJOIN COMMON CODE
CPYVRNXV MVC   DWORD(2),0(R7)      GET RECORD LENGTH ALIGNED
         LH    R1,DWORD            AND MAKE IT USEFUL
         LA    R1,2(,R1)           ADJUST FOR 2-BYTE CMS LENGTH FIELD
CPYVRNXC CR    R1,R15              IS A FULL RECORD IN CORE
         BNHR  R14                 YES, RETURN TO CALLER
CPYVRNX1 BAL   R14,CPYUT1          GO GET SOME NEW RECORDS FROM OFLOW
D        L     R14,RETSAVEA        RESTORE RETURN ADDRESS
         BR    R14                 AND RETURN TO CALLER
         SPACE 1
STOW     DS    0H
         NI    CPYFXNOT+1,X'0F'    OPEN NOTE GATE FOR NEXT FILE
STOWCOMM LA    R0,STOWLIST         POINT TO THE DIRECTORY ENTRY IN CORE
         LA    R1,DISK             AND TO DCB TO BE STOWED
         MVC   STOWNAME(8),FSTFNAME GET PREFERRED PDS MEMBER NAME
         CLC   REPLNAME(3),=CL3'YES' CAN OLD MEMBER BE REPLACED
         BNE   *+6                 NO,SKIP ALLOWING
         LCR   R1,R1               YES,INDICATE AS SUCH TO STOW
         STOW  (1),(0)             ATTEMPT TO STORE THE MEMBER
         STC   R15,RETSAVEA        PLACE STOW RETURN CODE IN CORE
         LTR   R15,R15             WAS IT SUCCESSFUL
         BZ    CPYPRT              YES, FOR SURE, GO TELL ABOUT IT
         CLI   RETSAVEA,X'08'      MAYBE, IF MEMBER REPLACED
         BE    CPYPRT              THAT'S IT, GO TELL ABOUT IT
         BH    STOWERR             ERROR DURING STOW, GO TELL
         MVI   STOWNAME+1,C'$'     COULN'T REPL EXISTING MEMBER
         MVC   STOWNAME+2(1),FSTFTYPE CREATE ALTERNATE NAME
         STOW  DISK,STOWLIST,A     TRY WITH NEW NAME
         LTR   R15,R15             DID IT WORK THIS TIME
         BZ    CPYPRT              YES, GO TELL ABOUT IT
         LA    R4,999              NO, FOR A TEMPORARY NAME
         MVC   STOWNAME(5),=CL5'$TEMP' MOVE IN THE TEMPNAME PREFIX
STOWLOOP CVD   R4,DWORD            GET NEXT INDEX IN DECIMAL
         UNPK  STOWNAME+5(3),DWORD+6(2) MAKE IT READABLE
         OI    STOWNAME+7,X'F0'    FIX THE FUCKING SIGN
         STOW  DISK,STOWLIST,A     TRY WITH THIS TEMPNAME
         LTR   R15,R15             DID THIS ONE GET STORED
         BZ    CPYPRT               YES, GO TO TELL ABOUT IT
         BCT   R4,STOWLOOP         NO, TRY ANOTHER NAME
         SPACE 1
STOWERR  MVI   RACTION+10,C'7'     INDICATE TROUBLES WITH STOW
         SR    R2,R2               SHOW MEMBER NOT STORED
         LA    R0,STOWTTR          GET START OF MEMBER
         POINT DISK,(0)            AND RE-USE IT'S SPACE
         B     CMSPRT              GO TO TELL WHAT HAPPENED
CPYPRT   MVC   RACTION(L'COPIED),COPIED SHOW FILE AS COPIED
         MVC   RACTION+11(8),STOWNAME AND TELL ITS NAME ON THE PDS
         B     CMSPRT              GO TO PRINT IT ALL
         SPACE 1
**       THE WRITING OF THE CMS FILE TO THE TARGET FILE IS
**       COMPLETE.
CPYFXDON DS    0H
         MVC   RACTION(L'COPIED),COPIED SHOW FILE COPIED
         MVC   RACTION+11(5),=CL5'(SEQ)' TO SEQ OUTPUT FILE
         SPACE 1
CMSPRT   DS    0H
         LA    R15,C' '            SKIP TO NEXT LINE
         LA    R0,L'REPORT         INDICATE LENGTH OF LINE
         LA    R1,REPORT           PT TO THE LINE
         BAL   R14,PRTSUB          AND GO TO PRINT IT
         SPACE 2
**       SEE IF THE OVERFLOW INFORMATION SHOULD BE SHOWN TO THE USER
         LH    R14,OVERFLOW        GET NO OF OVERFLOW RECORDS
         LTR   R14,R14             ARE THERE ANY
         BZ    NOOVFLOW            NO, SKIP REPORTING IT
         MH    R14,=Y(800)         YES, GET IN BYTES
         CVD   R14,DWORD           START PRINT CONVERSION
         UNPK  OVFLMSG+11(9),DWORD+3(5) TO EBCDIC
         OI    OVFLMSG+19,X'F0'    FIX THE FUCKING SIGN
         LA    R15,C' '            SKIP TO THE NEXT LINE
         LA    R0,L'OVFLMSG        GET MESSAGE LENGTH
         LA    R1,OVFLMSG          POINT TO IT
         BAL   R14,PRTSUB          AND PRINT IT
NOOVFLOW DS    0H
         LTR   R2,R2               WAS CMS FILE REALLY COPIED
         BZ    SKIPCOPY            NO, DON'T STOP HERE
         TM    NAMEBRAN+1,X'70'    WAS SPECIFIC FILE REQUESTED
         BNZ   SKIPCOPY            NO, CONTINUE WITH TAPE
         TM    TYPEBRAN+1,X'70'    MAYBE, BUT BE SURE
         BNZ   SKIPCOPY            NO, CONTINUE WITH TAPE
         CLC   CONTNAME(3),=CL3'YES' YES, DOES USER WNAT REST ANYWAY
         BNE   DONE                NO, GO TO EXIT
         SPACE 2
SKIPCOPY DS    0H
         DROP  R2                  DONE WITH DESCRIPTOR RECORD
         L     R2,COREWHER         GET START OF BLOCK ADDR
         ST    R2,CORENEXT         RE-INIT USABLE CORE BLOCK
         XC    OVERFLOW(2),OVERFLOW DITTO WITH DISK COUNT
         NI    CMSWORKA+1,X'0F'    OPEN THE CORE GATE
         CLOSE (SYSUT1,REREAD)     REPOSITION FOR NEXT WRITE
         B     CMSRD               GO TO READ NEXT CMS FILE
         SPACE 4
**       END OF FILE ON THE CMS TAPE SHOULD COME IMMEDIATELY AFTER
**       A DESCRIPTOR REOCRD.
TAPEEOF  DS    0H
         CLOSE (CMSTAPE)
         CLOSE (SYSUT1)
         CLOSE (SYSPRINT)
         LH    R0,PDSLRECL         GET POSSIBLE VARIABLE BUFFER LENGTH
         TM    PDSDSORG,DCBDSGPS   WAS FILE SEQUENTIAL
         BO    *+8                 YES, BUFFER WAS SHORT
         LH    R0,PDSBLKSI         NO,PARTITIONED, BUFFER WAS FULL BLK
         L     R1,VARBUFR          GET BUFFER ADDRESS
         LTR   R1,R1               WAS THERE A BUFFER
         BZ    SKFRVARB            NO,DON'T FREE IT
         FREEMAIN R,LV=(0),A=(1)   YES, FREE IT
SKFRVARB DS    0H
         CLOSE (DISK)
         SPACE 3
**       PROCESSING OF THE CMS TAPE IS COMPLETE. FREE GOTTEN
**       STORAGE, PASS THE RETURN CODE, AND EXIT
DONE     DS    0H
         L     R1,COREWHER         GET START ADDR OF BLOCK
         L     R0,COREMUCH         AND GET ITS LENGTH
         FREEMAIN R,LV=(0),A=(1) FREE THE LARGE BLOCK
         LR    R1,R13              POINT TO CURRENT SAVE AREA
         L     R13,4(,R13)         PT TO PRIOR SAVE AREA
         LA    R0,72               GET LENGTH OF FREEMAIN
         FREEMAIN R,LV=(0),A=(1)   FREE THE CORE
         SR    R15,R15             CLR RETURN REGISTER
         IC    R15,RETCODE         GET RETURN CODE
         L     R14,12(,R13)        GET RETURN ADDRESS
         LM    R0,R12,20(R13)      AND RESTORE REST OF REGISTERS
         BR    R14                 RETURN TO CALLER
         EJECT
**       THIS SUBROUTINE RETURNS THE VALUE OF THE CURRENT KEYWORD IN
**       THE PAR FIELD.
PARMCHOP DS    0H
         ST    R14,RETSAVEA        SAVE RETURN ADDRESS
         LA    R2,5(,R2)           PT PAST '=' IN PARM FIELD
         LR    R14,R2              REMEMBER WHERE IT STARTS
         LA    R0,9                SET UP MAX LOOP VALUE
         SH    R4,=Y(5)            BOP REMAINDER COUNT
         BNP   PARMOUTA            QUIT IF NOTHING LEFT
         MVI   0(R15),C' '         CLEAR THE VALUE..
         MVC   1(7,R15),0(R15)     ..TARGET FIELD
         SPACE 1
PARMCHLP CLI   0(R2),C','          IS THIS THE END OF THE VALUE
         BE    PARMCOMA            YES, GET LENGTH OF PARAM
         LA    R2,1(,R2)           NO, UP TO NEXT BYTE
         BCT   R4,*+8              DECREMENT MASTER COUNTER
         B     PARMADD             END OF PARM LIST
         BCT   R0,PARMCHLP         LOOK FOR COMMA AGAIN
         B     PARMERR             OPERAND IS TOO LONG
         SPACE 1
PARMOUTA SR    R0,R0               CLEAR TO 0
         BCTR  R0,0                INDICATE NO VALUE GIVEN
PARMOUTB L     R14,RETSAVEA        RESTORE RETURN ADDRESS
         BR    R14                 RETURN TO CALLER
         SPACE 2
PARMCOMA BCTR  R4,0                ACCOUNT FOR COMMA
         AH    R0,=H'1'
PARMADD  AH    R0,=H'1'
PARMGOT  DS    0H
         LA    R2,1(,R2)           INCR PAST COMMA
         CH    R0,=Y(11)           ANY PARM GIVEN
         BNL   PARMOUTA            NO, SKIP MOVE
         SH    R0,=Y(10)           GET NEG LENGTH OF PARM
         LCR   R0,R0               MAKE IT POSITIVE
         STC   R0,PARMMVC+1        SET LENGTH OF MOVE
PARMMVC  MVC   0(0,R15),0(R14)     PLACE PARAMETER IN CALLERS FIELD
         B     PARMOUTB            GO TO RETURN TO CALLER
         SPACE 3
**       ALL OUTPUT TO SYSPRINT IS DONE VIA THIS
**       SUBROUTINE
PRTSUB   DS    0H
         ST    R14,RETSAVEB        SAVE RETURN ADDRESS
         MVI   PRTBUF,C' '         ...CLEAR
         MVC   PRTBUF+1(L'PRTBUF-1),PRTBUF ...THE PRINT AREA
         OI    PRTTWICE+1,X'F0'    PRESET FOR ONE PRINTLINE
         LCR   R14,R0              SEE IF TWO LINES WANTED
         BM    PRTONCE             NO, COUNT WAS POSITIVE
         LR    R0,R14              GET POSITIVE COUNT
         NI    PRTTWICE+1,X'0F'    OPEN THE TWO-TIME GATE
PRTONCE  DS    0H
         STC   R15,PRTBUF          SETUP THE CARRIAGE CONTROL
         BCTR  R0,0                DECRMENT FOR MVC
         STC   R0,PRTMVC+1         PLACE IN MVC INSTRUCTION
PRTMVC   MVC   PRTBUF+1(0),0(R1)   MOVE PRINTLINE TO BUFFER
         PUT   SYSPRINT,PRTBUF     WRITE THE LINE
         L     R14,RETSAVEB        RESTORE RETURN ADDRESS
PRTTWICE BR    R14                 RETURN TO CALLER (MAYBE)
         MVI   PRTBUF+1,C' '       CLEAR...
         MVC   PRTBUF+2(L'PRTBUF-2),PRTBUF+1 ...ALL BUT CARR CTRL
         PUT   SYSPRINT,PRTBUF     PUT THE SECOND LINE
         L     R14,RETSAVEB        RESTORE RETURN ADDRESS AGAIN
         BR    R14                 RETURN TO CALLER
         TITLE 'FILE DEFINITIONS'
         PRINT NOGEN
         $DCBD DEVD=TA,DSORG=PS,PFIX=CMS
         ORG   CMSDCB
CMSTAPE  DCB   DDNAME=IN,DSORG=PS,MACRF=(GL),EODAD=TAPEEOF,RECFM=F,    X
               BLKSIZE=805,LRECL=805,BUFNO=5,OPTCD=C,DEVD=TA
         SPACE 1
         $DCBD DSORG=PS,PFIX=UT1
         ORG   UT1DCB
SYSUT1   DCB   DDNAME=SYSUT1,DSORG=PS,MACRF=(GM,PM),EODAD=UT1EOF,      X
               RECFM=FB,LRECL=800,BLKSIZE=1600,BUFNO=3,OPTCD=C
         SPACE 2
         $DCBD DSORG=PS,PFIX=PRT
         ORG   PRTDCB
SYSPRINT DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=(PM),RECFM=FBA,LRECL=121,X
               BLKSIZE=121
         SPACE 2
         $DCBD DSORG=PO,PFIX=PDS
         ORG   PDSDCB
DISK     DCB   DDNAME=DISK,DSORG=PO,MACRF=(W)
         SPACE 2
         PRINT GEN
         TITLE 'MESSAGE TEXTS'
PARMERRM DC    C'PARAMETER POSITION XX IS IN ERROR'
PRTITLE  DC    C'            CMS TO OS/PDS CONVERSION UTILITY'
PARMHDR  DC    C'THE FOLLOWING PARM FIELD HAS BEEN SPECIFIED:'
CMSOMSG  DC    C'THE CMS DUMP TAPE FILE COULD NOT BE OPENED'
OVFLMSG  DC    C'     ***** XXXXXXXXX MORE BYTES ARE NEEDED TO AVOID USX
               ING DASD WORKSPACE FOR THE ABOVE FILE'
NOTCMSG  DC    C'TAPE IS NOT IN CMS DUMP FORMAT'
HEADS    DC    C'  NAME    TYPE   MODE    V/F   DATE     TIME   BLKS  LX
               RECS   RECSIZE          ACTION'
WRKOMSG  DC    C'WORK FILE COULD NOT BE OPENED'
BYPASSED DC    C'BYPASSED(0X)'
COPIED   DC    CL(L'BYPASSED)'COPIED AS'
DISKOMSG DC    C'TARGET PDS COULD NOT BE OPENED'
         SPACE 1
CODES    DS    0C
CODE1    DC    C'                                                      X
                                    1 - RECFM'
CODE2    DC    C'                                                      X
                                    2 - LRECL'
CODE3    DC    C'                                                      X
                                    3 - FTYPE'
CODE4    DC    C'                                                      X
                                    4 - FMODE'
CODE5    DC    C'                                                      X
                                    5 - FMASK'
CODE6    DC    C'                                                      X
                                    6 - FNAME'
CODE7    DC    C'                                                      X
                                    7 - DRCTY'
CODESEND DS    0C
         TITLE 'MISCELLANEOUS CONSTANTS AND STORAGE'
DWORD    DC    2D'0'
CORELIMS DC    A(40000),A(1000000) ACCEPTABLE CORE SIZE REQUESTS
COREWHER DC    A(0)                ADDR OF LARGE CORE BLOCK
COREMUCH DC    A(0)                SIZE OF LARGE BLOCK
CORETOP  DC    A(0)                CEILING OF LARGE BLOCK
CORENEXT DC    A(0)                NEXT AVAILABLE  FOR SUB-ALLOCATION
         SPACE 2
VARBUFR  DC    A(0)
CPYUTEOF DC    A(0)
REGSAVE  DC    F'0'
         SPACE 2
         WRITE PDSDECB,SF,MF=L     DECB FOR PDS WRITE
         SPACE 2
STOWLIST DS    0D
STOWNAME DS    CL8
STOWTTR  DS    XL3
STOWC    DS    XL1
         SPACE 2
PARMTABL DS    0C
         DC    C'CONT=',AL4(PARMCONT)
         DC    C'MASK=',AL4(PARMMASK)
         DC    C'MODE=',AL4(PARMMODE)
         DC    C'NAME=',AL4(PARMNAME)
         DC    C'OUTF=',AL4(PARMOUTF)
         DC    C'REPL=',AL4(PARMREPL)
         DC    C'TYPE=',AL4(PARMTYPE)
PARMTABN DS    0C
         SPACE 2
RETCODE  DC    X'00'
OVERFLOW DC    Y(0)
RETSAVEA DC    F'0'
RETSAVEB DC    F'0'
PRTBUF   DC    CL121' '
CMSCONST DC    X'02',CL3'CMS'
         SPACE 2
MASKNAME DC    CL8' '
MODENAME DC    CL8' '
NAMENAME DC    CL8' '
TYPENAME DC    CL8' '
REPLNAME DC    CL8' '
OUTFNAME DC    CL8' '
CONTNAME DC    CL8' '
         SPACE 2
MAXBLKSI DC    Y(0)
LEFTOVER DC    Y(0)
         SPACE 1
REPORT   DS    CL120
         ORG   REPORT
RNAME    DC    CL8' '
         DC    CL2' '
RTYPE    DC    CL8' '
         DC    CL2' '
RMODE    DC    CL2' '
         DC    CL4' '
RVF      DC    CL1' '
         DC    CL2' '
RMMDDYY  DC    CL8' '
         DC    CL2' '
RHHMM    DC    CL5' '
         DC    CL2' '
RNOREC   DC    CL5' '
         DC    CL2' '
RLRECS   DC    CL5' '
         DC    CL2' '
RMAXSIZ  DC    CL10' '
         DC    CL4' '
RACTION  DS    0C
         ORG   ,
         SPACE 2
         YREGS
         TITLE 'DSECTS'
PARTFST  DSECT ,
         DS    2Y
FSTMODE  DS    CL2                 MODE OF FILE
FSTITEMS DS    Y                   NO. OF LOGICAL RECORDS IN FILE
         DS    Y
FSTRECFM DS    C                   RECORD FORMAT OF FILE
         DS    X
FSTMAXL  DS    F                   SIZE OF LARGEST RECORD IN FILE
FSTRECS  DS    Y                   NO OF 805 BYTE BLOCKS FILE USES
FSTYEAR  DS    CL2                 YEAR FILE WAS LAST SAVED
FSTDATE  DS    XL2                 MMDD FILE WAS SAVED
FSTTIME  DS    XL2                 HHMM FILE WAS SAVED
FSTFNAME DS    CL8                 FILE NAME
FSTFTYPE DS    CL8                 FILE TYPE
FSTFMODE DS    CL2                 FILE MODE
         SPACE 2
         END
