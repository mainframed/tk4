
                  R   E   A   D   F

         (  W R I T E F   &   R E S E T F )


      AS WE ALL KNOW, FORTRAN UNFORMATTED I/O IS A REAL DOG. YOU MAINLY
 USE IT IN FORTRAN TO WRITE OUT ARRARYS WHERE THE ARRAYS ARE FIXED
 LENGTH. AND SINCE FORTRAN PROGRAMMERS DO NOT KNOW ANYTHING ELSE
 (GENERALLY SPEAKING) THEY WILL USE IT. FORTRAN UNFORMATTED I/O RE-
 QUIRES YOU CODE RECFM=VBS AND YOU GET THE PICTURE. REAL CPU OVER-
 HEAD INVOLVED. THUS CAME TO BE READF, WRITEF, AND RESETF. THE OBJECT
 IS TO USE QSAM WITH FIXED LENGTH RECORDS AND THUS WE CAN BLOCK AND
 THEREFORE, A QUANTUM PERFORMANCE GAIN.  REAL BIGGEY !!!!!!



 PURPOSE :

     THESE SUBROUTINES ALLOW THE READING AND WRITING OF UNFORMATTED
 DATASETS WHOSE LOGICAL RECORDS ARE OF A FIXED LENGTH. LENGTH MUST BE
 GREATER THAN 18 BYTES.


 USAGE :

     A.  RESETF

     TO POSITION A DATASET TO READ OR WRITE THE FIRST LOGICAL RECORD,
 THE FOLLOWING CALLING SEQUENCE IS USED:

            CALL RESETF(DSN0)

 WHERE DSN0 IS AN INTEGER CONSTANT OF LENGTH 4 OR AN INTEGER VARIABLE
 OF LENGTH 4, THAT DENOTES A DATASET ( SEE SECTION ON DD CARDS ).


     B.  WRITEF

     TO WRITE A LOGICAL RECORD, THE FOLLOWING CALLING SEQUENCE IS USED:

            CALL WRITEF(DSN0,X)

 WHERE DSN0 IS A DATASET NUMBER AND X IS THE NAME OF THE FIRST VARIABLE
 IN THE LOGICAL RECORD. THE NUMBER OF BYTES TO BE WRITTEN IS DETER-
 MINED BY THE LRECL IN THE DD CARD.


     C.  READF

     TO READ A LOGICAL RECORD, THE FOLLOWING CALLING SEQUENCE IS USED:

          CALL READF(DSN0,X,&N,L)
1




 NOTE: IF L IS USED AND NO &N IS CODED, THEN A POSITIONAL "," MUST BE
       CODED.

 WHERE DSN0 AND X ARE AS PREVIOUSLY DEFINED AND N IS THE FORTRAN STATE-
 MENT NUMBER TO PROCEED TO IF AN END-OF-DATASET IS ENCOUNTERED. THE
 NUMBER OF BYTES TO BE READ WILL BE THE SAME AS THE NUMBER WRITTEN BY
 THE PROGRAM THAT CREATED THE DATASET, I.E. THE LRECL QUANTITY ON THE
 DD CARD OF THAT PROGRAM. YOU MUST ALLOW SUFFICIENT ROOM IN CORE FOR
 THIS NUMBER OF BYTES, EVEN IF YOU INTEND TO IGNORE SOME PORTION OF
 EACH LOGICAL RECORD. L IS OPTIONAL, BUT IF SUPPLIED, IT WILL BE
 CHECKED AGAINST THE LRECL VALUE TO INSURE THAT YOU ARE NOT INADVERT-
 ENTLY READING A RECORD OF A SIZE OTHER THAN ANTICIPATED. L MUST BE
 AN INTEGER CONSTANT OF LENGTH 4 OR AN INTEGER VARIABLE OF LENGTH 4.



 EXAMPLE:

          COMMON/RECORD/X(10),Y(10)
          CALL RESETF (1)
            ....
            ....
            ....
          CALL WRITEF(1,X)
            ....
            ....
            ....
          CALL RESETF(1)
            ....
            ....
            ....
          CALL READF(1,X,&27,80)
            ....
            ....
            ....
      27  CALL RESETF(1)
          RETURN
          END


 IN THE ABOVE EXAMPLE, COMMON BLOCK /RECORD/ CONSISTS OF 20 WORDS
 ( 80 BYTES ). X DENOTES THE FIRST VARIABLE ( ADDRESS OF THE FIRST
 BYTE ) OF THE COMMON BLOCK.
1


 DD CARDS:

     A MAXIMUM OF 15 DATSETS MAY BE USED. THE DATASETS ARE IDENTIFIED
 WITH THE DDNAMES OF FORT0000 TO FORT0014 INCLUSIVE. IN THE CALLING
 PROGRAM, THESE DATASETS ARE REFERENCED AS 0,1, ... 13,14 RESPECTIVELY.
 FOR EACH DATASET REFERENCED IN THE CALLING PROGRAM, A DD CARD SPEC-
 IFYING THE FOLLOWING DCB PARAMETER MUST BE SUPPLIED:

        RECFM=FB
        LRECL= LOGICAL RECORD LENGTH IN BYTES ( 80 IN THE EXAMPLE )
        BLKSIZE= MULTIPLE OF LRECL

 THE FOLLOWING DD CARD WOULD BE SUFFICIENT TO DEFINE A SCRATCH DATASET
 ON TAPE.

       //GO.FORT0001 DD UNIT=TAPE,DISP=(NEW,DELETE),
       //            DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)





 ABEND USER COMPLETION CODES:


     3000  -   DD CARD NOT SUPPLIED OR IN ERROR

     3004  -   DATASET NOT POSITIONED TO THE FIRST RECORD

     3008  -   'DSN0' NOT IN RANGE OF 0-15

     3012  -   ATTEMPTED TO READ PAST END OF DATA

     3016  -   "L" IN READF CALLING SEQUENCE DOES NOT MATCH LRECL
               IN THE LABEL OR DD CARD, AS APPROPRIATE
