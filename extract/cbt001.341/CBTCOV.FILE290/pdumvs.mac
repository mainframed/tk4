      /*  PDUMP  -  MVS TSO COMMAND PROCESSOR  */
 PDUMP: PROC(PARM) OPTIONS(MAIN) REORDER;
      DCL PARM            CHAR(100) VAR;
      DCL FC              CHAR(100) VAR INIT('');
      DCL (REPLY,TEXT)    CHAR(160) VAR INIT('');
      DCL (TRTAB1,TRTAB2) CHAR(256) INIT(' ');
      DCL (I,BUFRL,REC#,LEN,F,FROM,T,TO,TOP,A,N,
           #W,#B,#H,B,P#                      ) FIXED BIN(31) INIT(0);
      DCL (RC3270,MODE,SALRC,RCSCAN,RCTSOCP,DISPLAY,LNSZ,LNNO,L,
           C#,E#,M#,PP,VUNRC                  ) FIXED BIN(15) INIT(0);
      DCL TT CHAR(4) INIT('2741');
      DCL IO3270 EXTERNAL ENTRY(CHAR(*) VAR , FIXED BIN(15))
                        RETURNS(FIXED BIN(15));
      DCL 1 IOXOPT STATIC EXT,
            2 ISTRING CHAR(30) VAR INIT('CMD'),
            2 PFILE FILE VARIABLE INIT(PDPRT),
            2 IFLAGS,
              3 TRANS  BIT(1)  INIT('0'B),
              3 ATTFLG BIT(1)  INIT('0'B),
              3 IFILL  BIT(14) INIT('0'B),
            2 ROWS  FIXED BIN(15) INIT(24),
            2 PAGES FIXED BIN(15) INIT(100);
      DCL SCANNER ENTRY(ENTRY,CHAR(*) VAR,) RETURNS(FIXED BIN(15));
      DCL 1 VS1,  /* SCANNER ACTION TABLE FOR SELECT COMMAND */
            2 TYPE(6) BIT(1) INIT((6)(1)'0'B),
            2 KW(6) CHAR(4) VAR INIT('FI','DS','BUFL','PASS','BACK',
                                     'CL'),
            2 TRANS BIT(1) INIT('0'B);
      DCL 1 VS2,  /* SCANNER ACTION TABLE FOR FIND COMMAND */
            2 TYPE(3) BIT(1) INIT((3)(1)'0'B),
            2 KW(3) CHAR(4) VAR INIT('LIST','ALL','COPY'),
            2 TRANS BIT(1) INIT('0'B);
      DCL 1 VS3,  /* SCANNER ACTION TABLE FOR SETPFK COMMAND */
            2 TYPE(2) BIT(1) INIT((2)(1)'0'B),
            2 KW(2) CHAR(6) VAR INIT('PREFIX','SUFFIX'),
            2 TRANS BIT(1) INIT('0'B);
      DCL 1 VS4,  /* SCANNER ACTION TABLE FOR "FI(DDNAME)" */
            2 TYPE(1) BIT(1) INIT('0'B),
            2 KW(1) CHAR(2) VAR INIT('FI'),
            2 TRANS BIT(1) INIT('0'B);
      DCL 1 VS5,  /* SCANNER ACTION TABLE FOR SETCOPY COMMAND */
            2 TYPE(2) BIT(1) INIT((2)(1)'0'B),
            2 KW(2) CHAR(2) VAR INIT('FI','CL'),
            2 TRANS BIT(1) INIT('0'B);
      DCL 1 VS6,  /* SCANNER ACTION TABLE FOR TSO COMMAND */
            2 TYPE(1) BIT(1) INIT('0'B),
            2 KW(1) CHAR(2) VAR INIT(''),
            2 TRANS BIT(1) INIT('0'B);
      DCL 1 VS7,  /* SCANNER ACTION TABLE FOR "N" */
            2 TYPE(1) BIT(1) INIT('0'B),
            2 KW(1) CHAR(2) VAR INIT(''),
            2 TRANS BIT(1) INIT('0'B);
      DCL 1 VS8,  /* SCANNER ACTION TABLE FOR FROM COMMAND */
            2 TYPE(1) BIT(1) INIT('0'B),
            2 KW(1) CHAR(2) VAR INIT('TO'),
            2 TRANS BIT(1) INIT('0'B);
      DCL 1 VS9,  /* SCANNER ACTION TABLE FOR CCHAR AND ECHAR */
            2 TYPE(1) BIT(1) INIT('0'B),
            2 KW(1) CHAR(2) VAR INIT(''),
            2 TRANS BIT(1) INIT('0'B);
      DCL CPPL EXTERNAL ENTRY(POINTER,POINTER,POINTER,POINTER);
      DCL TSOCP ENTRY(POINTER,CHAR(*) VAR) RETURNS(FIXED BIN(15));
      DCL PLIXOPT CHAR(20) VAR INIT('ISASIZE(64K)') STATIC EXTERNAL;
      DCL (TA,TB) CHAR(9) INIT(' ');
      DCL (HA,HB,MA,MB,SA,SB,TIMEA,TIMEB,PTIME) FIXED BIN(31) INIT(0);
      DCL E1 EVENT , T1 TASK;
      DCL REF FIXED BIN(15) INIT(5);  /* DEFAULT IS REFLECT */
      DCL PFKEY(24) CHAR(100) VAR INIT('ENTER SELECT MODE','DISPFK',
          'END','PRINT','FIND','OPTIONS','FLIP DUMP',
          'COPY','INFO','FLIP NUM','FREE','SELECT',(12)(1)'NULL');
      DCL PFKTYPE(24) CHAR(1) INIT((24)(1)'S');
      DCL PFKCODES CHAR(24) INIT('123456789:#@ABCDEFGHIÖ.<');
      DCL CH GENERIC (CH31 WHEN(FIXED BIN(31)),
                      CH15 WHEN(FIXED BIN(15)));
      DCL PROFILE EXTERNAL ENTRY(FIXED BIN(15), FIXED BIN(15),
                                 FIXED BIN(15), FIXED BIN(15));
      DCL S99VIN EXTERNAL ENTRY(CHAR(*) VAR, CHAR(*) VAR, CHAR(*) VAR,
          CHAR(*) VAR, FIXED BIN(15), FIXED BIN(15), FIXED BIN(15));
      DCL (S99DSN,S99MISC) CHAR(44) VAR INIT('');
      DCL (S99DDN,S99MEM) CHAR(8) VAR INIT('');
      DCL (S99RC,S99ERROR,S99INFO) FIXED BIN(15) INIT(0);
      DCL S99VAL ENTRY(CHAR(*) VAR, FIXED BIN(15), FIXED BIN(15),
                       FIXED BIN(15), FIXED BIN(15), CHAR(*) VAR,
                       CHAR(*) VAR, CHAR(*) VAR, CHAR(*) VAR);
      DCL S99FREE ENTRY(CHAR(*) VAR, FIXED BIN(15), FIXED BIN(15),
                       FIXED BIN(15), FIXED BIN(15));
      DCL DYNALDDN CHAR(8) VAR INIT('');
      DCL DYNALDSN CHAR(44) VAR INIT('');
      DCL DYNALDSG CHAR(2) VAR INIT('');
      DCL DYNALVOL CHAR(6) VAR INIT('');
      DCL (OPENED,EOF,DUMPFORMAT,COUNTFLAG,PRINTKEY,STOPPER,COMPRESS,
           KIMODE,TSO,PO,AUTO,TERM,ECHO,VFLG,EXPAND,SQ,DQ,IDLE,
           PRTFLG,INTFLG                           ) BIT(1) INIT('0'B);
      DCL CODE PIC'ZZZ9';
      DCL VERB CHAR(20) VAR INIT('');
      DCL (C,CCHAR,ECHAR) CHAR(1) INIT(' ');
      DCL (INDD,DDNAME) CHAR(8) VAR INIT('');
      DCL DSORG CHAR(2) INIT('PS');
      DCL VSPW  CHAR(8) STATIC INIT(' ');
      DCL QSAM  BIT(8) INIT('00000000'B);
      DCL BSAM  BIT(8) INIT('00000100'B);
      DCL BSAML BIT(8) INIT('00001000'B);
      DCL VSAM  BIT(8) INIT('00011100'B);
      DCL TCAM  BIT(8) INIT('00001100'B);
      DCL QISAM BIT(8) INIT('00010000'B);
      DCL BISAM BIT(8) INIT('00010100'B);
      DCL BDAM  BIT(8) INIT('00011000'B);
      DCL SYSXX FILE VARIABLE;
      DCL SYSPS FILE RECORD INPUT ENV(BUFFERS(1) LEAVE);
      DCL SYSPB FILE RECORD INPUT BACKWARDS ENV(BUFFERS(1) LEAVE);
      DCL SYSPD FILE RECORD INPUT ENV(BUFFERS(1) U BLKSIZE(256));
      DCL SYSIS FILE RECORD INPUT KEYED ENV(INDEXED BUFFERS(1) GENKEY);
      DCL SYSR1 FILE RECORD INPUT KEYED ENV(REGIONAL(1));
      DCL SYSR2 FILE RECORD INPUT KEYED ENV(REGIONAL(2));
      DCL SYSR3 FILE RECORD INPUT KEYED ENV(REGIONAL(3));
      DCL SYSVS FILE RECORD INPUT KEYED ENV(VSAM PASSWORD(VSPW));
      DCL SYSVG FILE RECORD INPUT KEYED ENV(VSAM PASSWORD(VSPW) GENKEY);
      DCL SYSVB FILE RECORD INPUT KEYED ENV(VSAM PASSWORD(VSPW) BKWD);
      DCL (DATA,OUTREC) CHAR(*) VAR CONTROLLED INIT('');
      DCL (KEAY,KEEY) CHAR(264) VAR INIT('');
      DCL LS FIXED BIN(31) INIT(80);  /* TERMINAL LINE WIDTH
             SET OUTSIDE PDUMP BY TERMINAL COMMAND */
      DCL LINE CHAR(120) VAR INIT('');
      DCL LOWER CHAR(26) INIT('abcdefghijklmnopqrstuvwxyz');
      DCL UPPER CHAR(26) INIT('ABCDEFGHIJKLMNOPQRSTUVWXYZ');
      DCL ALP CHAR(26) INIT('ABCDEFGHIJKLMNOPQRSTUVWXYZ');
      DCL NUM CHAR(10) INIT('0123456789');
      DCL NAT CHAR(3)  INIT('@$#');
      DCL MSS CHAR(200) VAR INIT('');
      DCL (ONCODE,DATE,TIME,INDEX,ADDR,SUBSTR,TRANSLATE,LENGTH,NULL,
           ALLOCATION,MIN,MOD,VERIFY,MAX,UNSPEC,LOW,PRIORITY,
           REPEAT                                           ) BUILTIN;
      DCL (CVTPTR,DS1PTR,TCBPTR,TCBWPTR,TIOTPTR,DDPTR,UCBPTR,SWAPTR,
           TSBPTR,DS3PTR,FCBPTR,PBUFPTR               ) POINTER;
      DCL FCBLOC EXTERNAL ENTRY(FILE,POINTER);
      DCL HEXOUT EXTERNAL ENTRY(CHAR(*) VAR , CHAR(*));
      DCL X CHAR(200) VAR INIT('');
      DCL SYSIN    FILE STREAM INPUT;
      DCL SYSPRINT FILE STREAM PRINT ENV(BUFFERS(1));
      DCL PDPRT    FILE STREAM PRINT ENV(BUFFERS(1));
      DCL SYSOUT   FILE RECORD OUTPUT ENV(BUFFERS(1));
      DCL COPYDD CHAR(8) VAR INIT('');
      DCL DSCBF1 EXTERNAL ENTRY(CHAR(*),CHAR(*),CHAR(*),FIXED BIN(31));
      DCL RDDSCB EXTERNAL ENTRY(CHAR(*),CHAR(*),CHAR(*),FIXED BIN(31));
      DCL 1 DUMPLINE CONTROLLED,
            2 OFFSET CHAR(6),
            2 WORDS(#W) CHAR(8),
            2 STAR1 CHAR(1) INIT('*'),
            2 INFORM CHAR(#B),
            2 STAR2 CHAR(1) INIT('*');
      DCL HEX64 CHAR(#H) CONTROLLED;
      DCL (LINE32,PREVINFO) CHAR(#B) VAR CONTROLLED;
      DCL (Y,YY) CHAR(4) INIT(' ');
      DCL BIN FIXED BIN(31) BASED(P);
      DCL BAN FIXED BIN(31) BASED(Q);
      DCL P POINTER INIT((ADDR(Y)));
      DCL Q POINTER INIT((ADDR(YY)));
      DCL S99WORK CHAR(2) VAR INIT('');
      DCL (S99INFOX,S99ERRORX) CHAR(4) INIT(' ');
      DCL (WORK,WARK) CHAR(3) VAR INIT('');
      DCL (OFFSET1,OFFSET2) CHAR(6) INIT(' ');
      DCL PREVOFFSET FIXED BIN(31) INIT(0);
      DCL 1 CVT BASED(CVTPTR),
            2 CVTTCBP POINTER;  /* POINTER TO TCB ADDRESS */
      DCL 1 DS1 BASED(DS1PTR),  /* FORMAT 1 DSCB */
            2 DS1FMTID CHAR(1),  /* IDENTIFIER (X'F1') */
            2 DS1DSSN CHAR(6),  /* DATA SET SERIAL NUMBER */
            2 DS1VOLSQ CHAR(2),  /* VOLUME SEQUENCE NUMBER */
            2 DS1CREDT,  /* CREATION DATE */
              3 YEAR BIT(8),  /* 00-99 */
              3 DAY BIT(16),  /* 1-366 */
            2 DS1EXPDT,  /* EXPIRATION DATE */
              3 YEAR BIT(8),  /* 00-99 */
              3 DAY BIT(16),  /* 1-366 */
            2 DS1NOEPV BIT(8),  /* NO. OF SEPARATE EXTENTS
              IN WHICH THE DATASET RESIDES ON THIS VOLUME */
            2 DS1NOBDB BIT(8),  /* NO. BYTES USED IN
              THE LAST PDS DIRECTORY BLOCK */
            2 FILLER1 BIT(8),  /* RESERVED */
            2 DS1SYSCD CHAR(13),  /* SYSTEM CODE */
            2 FILLER2 CHAR(7),  /* RESERVED */
            2 DS1DSORG BIT(16),  /* DATASET ORGANIZATION
              BIT(1) IS ISAM
              BIT(2) PS SEQUENTIAL
              BIT(3) DA DIRECT
              BIT(7) PO PARTITIONED
              BIT(8) U  UNMOVABLE  */
            2 DS1RECFM BIT(8),  /* RECORD FORMAT
              10XX XXXX F FIXED
              01XX XXXX V VARIABLE
              11XX XXXX U UNDEFINED
              XX1X XXXX T TRACK OVERFLOW
              XXX1 XXXX B BLOCKED
              XXXX 1XXX S WITH F: STANDARD
                          WITH V: SPANNED
              XXXX X10X A ANSI CONTROL CHAR
              XXXX X01X M MACHINE CONTROL CHAR
              XXXX X00X   NO CONTROL CHAR */
            2 DS1OPTCD BIT(8),  /* OPTION CODE */
            2 DS1BLKL FIXED BIN(15),  /* BLOCK SIZE */
            2 DS1LRECL FIXED BIN(15),  /* RECORD SIZE */
            2 DS1KEYL BIT(8),  /* KEY LENGTH */
            2 DS1RKP BIT(16),  /* RELATIVE KEY POSITION */
            2 DS1DSIND BIT(8),  /* DATA SET INDICATORS */
            2 DS1SCALO,  /* ALLOCATION PARAMETERS */
              3 ALOFLGS BIT(8),  /* FLAGS */
              3 QUANTITY BIT(24),  /* SECONDARY ALLOCATION QUANTITY */
            2 DS1LSTAR FIXED BIN(15) UNAL,  /* LAST BLK PTR (TTRLL) */
            2 DS1R BIT(8),  /* R PORTION OF TTRLL */
            2 DS1TRBAL FIXED BIN(15) UNAL,  /* LL PORTION OF TTRLL */
            2 FILLER3 BIT(16),  /* RESERVED */
            2 DS1EXT(3),  /* EXTENT DESCRIPTORS */
              3 TYPE CHAR(1),  /* EXTENT TYPE INDICATOR */
              3 SEQ CHAR(1),  /* EXTENT SEQUENCE NUMBER (M) */
              3 LOWER,  /* LOWER LIMIT OF THIS EXTENT (CCHH) */
                4 CYL FIXED BIN(15) UNAL,  /* CYLINDER ADDRESS (CC) */
                4 TRK FIXED BIN(15) UNAL,  /* TRACK ADDRESS (HH) */
              3 UPPER,  /* UPPER LIMIT OF THIS EXTENT (CCHH) */
                4 CYL FIXED BIN(15) UNAL,  /* CYLINDER ADDRESS (CC) */
                4 TRK FIXED BIN(15) UNAL,  /* TRACK ADDRESS (HH) */
            2 DS1PTRDS CHAR(5);  /* PTR TO F2 DSCB (CCHHR) */
      DCL 1 DS3 BASED(DS3PTR),  /* FORMAT 3 DSCB */
            2 DS3KEY CHAR(4),  /* X'03030303' */
            2 DS3EXTNT(4),  /* EXTENT DESCRIPTORS */
              3 TYPE CHAR(1),
              3 SEQ CHAR(1),
              3 LOWER,
                4 CYL FIXED BIN(15) UNAL,
                4 TRK FIXED BIN(15) UNAL,
              3 UPPER,
                4 CYL FIXED BIN(15) UNAL,
                4 TRK FIXED BIN(15) UNAL,
            2 DS3FMTID CHAR(1),  /* IDENTIFIER (X'F3') */
            2 DS3ADEXT(9),  /* EXTENT DESCRIPTORS */
              3 TYPE CHAR(1),
              3 SEQ CHAR(1),
              3 LOWER,
                4 CYL FIXED BIN(15) UNAL,
                4 TRK FIXED BIN(15) UNAL,
              3 UPPER,
                4 CYL FIXED BIN(15) UNAL,
                4 TRK FIXED BIN(15) UNAL,
            2 DS3PTRDS CHAR(5);  /* RESERVED - ZERO */
      DCL 1 TCB BASED(TCBPTR),
            2 TCBRBP POINTER,  /* PTR TO TOP RB ON RB CHAIN */
            2 TCBPIE POINTER,  /* ADDR OF PGM INT ELEM (PIE) */
            2 TCBDEB POINTER,  /* ADDR OF THE DEB QUEUE */
            2 TCBTIO POINTER,  /* ADDR OF TIOT */
            2 TCBCMP FIXED BIN(31);  /* TASK COMPLETION CODE */
      DCL 1 TCBWORDS BASED(TCBWPTR),
            2 TCBWNEXT POINTER,  /* ADDR OF NEXT TCB
              TO BE DISPATCHED */
            2 TCBWCURR POINTER;  /* ADDR OF CURRENT TCB */
      DCL 1 TIOT BASED(TIOTPTR),
            2 TIOCNJOB CHAR(8),  /* JOB NAME */
            2 TIOCSTP CHAR(8),  /* STEP NAME */
            2 TIOCSTP2 CHAR(8),  /* PROCEDURE STEP NAME */
            2 TIODDENT FIXED BIN(31);  /* DD ENTRIES */
      DCL 1 TIOTDD BASED(DDPTR),
              3 TIOELNGH BIT(8),  /* LENGTH OF DD ENTRY IN BYTES
                INCLUDING ALL DEVICE ENTRIES */
              3 TIOESTTA BIT(8),  /* STATUS BYTE A */
              3 TIOERLOC BIT(16),  /* ALLOCATION INFORMATION */
              3 TIOEDDNM CHAR(8),  /* DD NAME */
              3 TIOEJFCB BIT(24),  /* TTR OF JFCB */
                                   /* POINTS TO 16 BYTES BEFORE DSN */
              3 TIOESTTC BIT(8),  /* STATUS BYTE C */
            2 TIODVENT(200),  /* DEVICE ENTRIES */
              3 TIOEUCBA POINTER;  /* UCB ADDRESS */
      DCL 1 SWA BASED(SWAPTR),
            2 SWAJNK CHAR(16),
            2 SWADSN CHAR(44);
      DCL 1 UCB BASED(UCBPTR),
            2 SRTEJBNR BIT(8),  /* INTERNAL JOB IDENT */
            2 UCBFLS BIT(8),  /* ALLOCATION CHANNEL MASK */
            2 UCBID BIT(8),  /* UCB ID (X'FF') */
            2 SRTESTAT BIT(8),  /* STATUS BYTE A */
            2 UCBCHA BIT(8),  /* CHANNEL ADDRESS AND FLAGS */
            2 UCBUA BIT(8),  /* UNIT ADDRESS */
            2 UCBFL1 BIT(8),  /* FLAG BYTE 1 */
            2 UCBDTI BIT(8),  /* INDEX TO DEVICE TABLE */
            2 UCBETI BIT(8),  /* ERROR ROUTINE ID */
            2 UCBSTI BIT(8),  /* STATISTICS TABLE INDEX */
            2 UCBLCI BIT(8),  /* LOGICAL CHANNEL WORD
              TABLE INDEX */
            2 UCBATI BIT(8),  /* ATTENTION TABLE INDEX */
            2 UCBWGT BIT(8),  /* FLAGS AND MASK */
            2 UCBNAME CHAR(3),  /* UNIT NAME (EBCDIC) */
            2 UCBTYP,  /* DEVICE TYPE */
              3 UCBTYP1 BIT(8),
              3 UCBTYP2 BIT(8),
              3 UCBTYP3 BIT(8),  /* DEVICE CLASS:
                X'08' UNIT RECORD
                X'10' GRAPHICS
                X'20' DIRECT ACCESS STORAGE
                X'40' COMMUNICATION EQUIPMENT
                X'80' MAGNETIC TAPE */
              3 UCBTYP4 BIT(8),  /* UNIT TYPE */
            2 UCBLTS BIT(16),  /* LAST REQUEST ELEMENT */
            2 UCBSNS BIT(16),  /* SENSE INFORMATION */
              /* END COMMON SEGMENT , BEGIN DEVICE VARIABLE SEGMENT */
              /* THE FOLLOWING IS APPLICABLE ONLY TO MAGNETIC TAPE
                 AND DIRECT ACCESS STORAGE DEVICES (EXCEPT DATA CELL) */
            2 UCBSNS2 BIT(32),  /* ADDITIONAL SENSE INFO */
            2 SRTEVOLI CHAR(6);  /* VOLUME SERIAL NUMBER */
      DCL 1 TSBD BASED(TSBPTR),  /* TERMINAL STATUS BLOCK */
            2 TSBSTAT BIT(8),  /* STATUS BYTE
              BIT(1) TSB IN USE
              BIT(2) KEYBOARD LOCKED DUE TO LACK OF INPUT BUFFERS
              BIT(3) TSB REPRESENTS A DISPLAY SCREEN
              BIT(4) TPUT FOUND NO BUFFERS
              BIT(5) PROHIBIT NON-SUPERVISORY INTER-TERMINAL MSGS
              BIT(6) TSB HAS BEEN THRU LOGOFF
              BIT(7) TSB REPRESENTS A 3270 TERMINAL
              BIT(8) ATTN FOR INPUT LINE DELETE */
            2 TSBASCB BIT(24),  /* POINTER TO ASCB */
            2 TSBFLG1 BIT(8),  /* FIRST FLAG BYTE */
            2 TSBWTCB BIT(24),  /* ADDR OF TCB OF TASK WAITING ON
                                TSBECB */
            2 TSBLNSZ BIT(8),  /* PHYSICAL LINE SIZE OF TERMINAL */
            2 TSBOTBFP BIT(24),  /* PTR TO TRAILER BUFFER(S) */
            2 TSBNOBF BIT(8),  /* NO. OF BUFFERS ON OUTPUT QUEUE */
            2 TSBOBFP BIT(24),  /* PTR TO OUTPUT BUFFER QUEUE */
            2 TSBFLG2 BIT(8),  /* SECOND FLAG BYTE */
            2 TSBITBFP BIT(24),  /* PTR TO INPUT TRAILER BUFFERS */
            2 TSBNIBF BIT(8),  /* NO. OF BUFFERS ON INPUT QUEUE */
            2 TSBIBFP BIT(24),  /* PTR TO INPUT BUFFER QUEUE */
            2 TSBFLG3 BIT(8),  /* THIRD FLAG BYTE */
            2 TSBFLG5 BIT(8),  /* FIFTH FLAG BYTE */
            2 TSBTERM1 BIT(8),  /* TERMINAL CHARACTERISTICS BYTE 1
              BIT(1) TIME-OUT INHIBITED
              BIT(2) BREAK FEATURE
              BIT(3) ATTENTION FEATURE
              BIT(4) LINE IS 5041
              BIT(5) TERMINAL IS 2741 */
            2 TSBTERM2 BIT(8),  /* TERMINAL CHARACTERISTICS BYTE 2
              BIT(3) TERMINAL IS TWX
              BIT(8) TERMINAL IS 1050 */
            2 TSBECB BIT(32),  /* ECB FOR INTERTERMINAL COMMUNICATION */
            2 TSBWTJID CHAR(2),  /* TJID OF TASK WAITING ON TSBECB */
            2 TSBLNDCC CHAR(1),  /* LINE DELETE CHARACTER */
            2 TSBCHDCC CHAR(1),  /* CHARACTER DELETE CHARACTER */
            2 TSBATNLC FIXED BIN(15),  /* NO. OF SUCCESSIVE OUTPUT LINES
                             BETWEEN ATTENTION SIMULATION */
            2 TSBATNTC FIXED BIN(15),  /* NO. OF CONTINUOUS 1-SECOND
                             TIME INTERVALS */
            2 TSBLNNO BIT(8),  /* NO. OF LINES ON A DISPLAY SCREEN */
            2 TSBFLG4 BIT(8),  /* FLAG BYTE */
            2 TSBASRCE CHAR(2),  /* TCAM TERMINAL INDEX */
            2 TSBATNCC CHAR(4),  /* CHARACTER STRING USED FOR
                                 ATTENTION SIMULATION */
            2 TSBAUTOS FIXED BIN(31),  /* STARTING AND CURRENT SEQ NO.
                             FOR AUTO LINE NUMBERING */
            2 TSBAUTOI FIXED BIN(31),  /* INCREMENT VALUE
                             FOR AUTO LINE NUMBERING */
            2 TSBERSDS CHAR(4),  /* CHARS USED TO ERASE SCREEN */
            2 TSBCTCB POINTER,  /* TCB ADDRESS OF TASK
                                CURRENTLY DOING A TPUT */
            2 TSBRCB CHAR(8),  /* TCAM RESOURCE CTL BLK */
            2 TSBTPOST CHAR(8),  /* TPOSTING COMMUNICATION AREA */
            2 TSBATTNC BIT(8),  /* NO. OF UNPROCESSED ATTN'S */
            2 TSBSTAX BIT(8),  /* NO. OF UNSCHEDULED STAX EXITS */
            2 TSBLINE FIXED BIN(15),  /* LINE ADDRESS OR 3705
                            RESOURCE I.D. OF THIS TERMINAL */
            2 TSBMINL FIXED BIN(31),  /* NO. OF MINUTES LEFT BEFORE
                            A DISCONNECTED USER WILL BE LOGGED OFF */
            2 TSBPSWD CHAR(8),  /* LOGON PASSWORD */
            2 TSBEXTNT POINTER,  /* ADDR OF TSB EXTENTION */
            2 TSBJUNK CHAR(4),  /* RESERVED */
            2 TSBEND CHAR(8);  /* END OF THE TSB */
      DCL 1 FCB BASED(FCBPTR),
               2 F111 CHAR(20),
               2 FADB POINTER,  /* ADDRESS OF DCB OR ACB */
               2 F222 CHAR(16),
               2 FFLA BIT(8),  /* RECORD FORMAT */
                      /* BIT(1) F-FORMAT
                         BIT(2) V-FORMAT
                         BIT(3) U-FORMAT
                         BIT(4) BLOCKED
                         BIT(5) SPANNED */
               2 FFLB BIT(8),  /* FILE ORGANIZATION */
                      /* BIT(1) CONSECUTIVE
                         BIT(2) INDEXED
                         BIT(3) REGIONAL(1)
                         BIT(4) REGIONAL(2)
                         BIT(5) REGIONAL(3)
                         BIT(6) TP(M)
                         BIT(7) TP(R)
                         BIT(8) OTHER */
               2 FFLC BIT(8),  /* ACCESS METHOD */
                      /* X'00'  QSAM
                         X'04'  BSAM
                         X'08'  BSAM(LOAD)
                         X'0C'  TCAM
                         X'10'  QISAM
                         X'14'  BISAM
                         X'18'  BDAM
                         X'1C'  VSAM  */
               2 FFLD BIT(8),
               2 F333 CHAR(4),
               2 FBKZ FIXED BIN(15),  /* BLOCKSIZE */
               2 FKYL FIXED BIN(15),  /* KEYLENGTH */
               2 FRCL FIXED BIN(31),  /* RECORD LENGTH */
               2 F444 CHAR(20),
                 /* BEGIN RECORD I/O OR STREAM I/O SECTION */
               2 F555 CHAR(24),
               2 FFNC BIT(8),
               2 FELV BIT(8);  /* VSAM FLAGS */
                      /* BIT(1) KSDS
                         BIT(2) ESDS
                         BIT(3) RRDS
                         BIT(4) ALTERNATE INDEX PATH
                         BIT(5) ALTERNATE INDEX PATH (NON-UNIQUE)
                         BIT(6) SKIP */
      DCL 1 PBUF BASED(PBUFPTR),  /* COMMAND BUFFER TO PDUMP */
            2 PBLENGTH FIXED BIN(15),
            2 PBOFFSET FIXED BIN(15),
            2 PBTEXT   CHAR(100);
      DCL 1 CPPLX,  /* COMMAND PROCESSOR PARAMETER LIST */
            2 CPPLCBUF POINTER,  /* COMMAND BUFFER */
            2 CPPLUPT POINTER,  /* USER PROFILE TABLE */
            2 CPPLPSCB POINTER,  /* PROTECTED STEP CONTROL BLOCK */
            2 CPPLECT POINTER;  /* ENVIRONMENT CONTROL TABLE */
      DCL 1 CBUF,  /* COMMAND BUFFER */
            2 CBLENGTH FIXED BIN(15),
            2 CBOFFSET FIXED BIN(15),
            2 CBTEXT   CHAR(100);
      OPEN FILE(SYSIN) , FILE(SYSPRINT);
      ON ATTENTION ATTFLG='1'B;
      ON ENDFILE(SYSIN) GOTO EOJ;
      CALL PROFILE(MODE,DISPLAY,LNSZ,LNNO);
      TSO=MODE=1;         /* 1=TSO  0=BATCH */
      /* ALLOW EXECUTION TO CONTINUE IF ERRORS OCCUR IN TSO */
      IF TSO THEN DO;
         ON ERROR BEGIN;
                  CODE=ONCODE;
                  GOTO GET_COMMAND;
                  END;
         DO SYSXX=SYSIS,SYSR1,SYSR2,SYSR3,SYSPS,SYSPB,SYSPD,
                  SYSVS,SYSVB,SYSVG;
         ON UNDF(SYSXX) BEGIN; CODE=ONCODE; GOTO BADFILE; END;
         END;
         IF DISPLAY=1 THEN DO;
            TT='3270';
            CALL SPIN(1);
            IOXOPT.ROWS=LNNO;
            /* CHECK TO SEE IF USER REQUESTED THAT
               WE COME UP IN 2741 MODE */
            CALL CPPL(CPPLCBUF,CPPLUPT,CPPLPSCB,CPPLECT);
            IF CPPLCBUF=NULL
               THEN DO; /* INVOKED BY TSO CALL */
                    IF PARM='2741' THEN TT='2741';
                    END;
               ELSE DO; /* INVOKED AS TSO COMMAND PROCESSOR */
                    PBUFPTR=CPPLCBUF;
                    IF SUBSTR(PBTEXT,PBOFFSET+1)='2741' THEN TT='2741';
                    END;
            IF TT='3270' THEN RC3270=IO3270(' ',0);
            END;
         LS=LNSZ;
         END;
         ELSE DO;
              LS=120;  /* DEFAULT BATCH LINESIZE IS 120 */
              ECHO='1'B;  /* ECHO INPUT COMMANDS IN BATCH MODE */
              END;
      IF LS>=120 THEN #W=8; ELSE #W=4;
      #B=#W*4;
      #H=#B*2;
      ALLOCATE DUMPLINE;
      ALLOCATE HEX64;
      ALLOCATE LINE32;
      ALLOCATE PREVINFO;
      TRTAB1=(256)'.';
      SUBSTR(TRTAB1,65,1)=' ';
      SUBSTR(TRTAB1,75,7)='Ö.<(+×&';
      SUBSTR(TRTAB1,91,8)='!$*);^-/';
      SUBSTR(TRTAB1,108,5)=',%_>?';
      SUBSTR(TRTAB1,123,6)=':#@''="';
      SUBSTR(TRTAB1,130,9)=SUBSTR(LOWER,1,9);
      SUBSTR(TRTAB1,146,9)=SUBSTR(LOWER,10,9);
      SUBSTR(TRTAB1,163,8)=SUBSTR(LOWER,19,8);
      SUBSTR(TRTAB1,194,9)=SUBSTR(UPPER,1,9);
      SUBSTR(TRTAB1,210,9)=SUBSTR(UPPER,10,9);
      SUBSTR(TRTAB1,227,8)=SUBSTR(UPPER,19,8);
      SUBSTR(TRTAB1,241,10)=NUM;
      TRTAB2=TRANSLATE(TRTAB1,' ','.');
      SUBSTR(TRTAB2,76,1)='.';
      FC='';  /* INDICATE NO PREVIOUS FIND COMMAND */
      FROM=1; TO=0;  /* DEFAULT "FROM" AND "TO" VALUES */
      C#=1;  /* DEFAULT "COMPRESS" VALUE */
      DYNALDDN='';  /*  INDICATE NO PREVIOUS SUCCESSFUL
                              DYNAMIC ALLOCATION  */
      CALL PUTMSG(TODAY××'    '××TIMEX);
 GET_COMMAND:
      IDLE='1'B;
      IF ATTFLG×INTFLG
         THEN X='';  /* CLEAR INPUT STACK AFTER ATTENTION */
      KIMODE,ATTFLG,INTFLG='0'B;
      CALL GETMSG(REPLY);
      KIMODE,ATTFLG,INTFLG='0'B;
      TEXT,VERB='';
      IF LENGTH(REPLY)=0 THEN ;
          ELSE DO I=1 TO LENGTH(REPLY);
               C=SUBSTR(REPLY,I);
               IF C=' '&LENGTH(VERB)>0 THEN LEAVE;
               IF C^=' ' THEN VERB=VERB××C;
               END;
      IF LENGTH(VERB)>0 THEN DO;
         I=INDEX(REPLY,VERB);
         IF I+LENGTH(VERB)>LENGTH(REPLY) THEN LEAVE;
         TEXT=SUBSTR(REPLY,I+LENGTH(VERB));
         I=VERIFY(TEXT,' ');
         IF I=0 THEN TEXT='';
                ELSE TEXT=SUBSTR(TEXT,I);
         END;
      IF ECHO THEN CALL PUTMSG('CMD: '××VERB××' '××TEXT);
      IF VERB='INT'×VERB='INTERRUPT' THEN GOTO PANIC;
      IF PTIME>0 THEN DO;
         TA=TIME;
         GET STRING(TA) EDIT(HA,MA,SA) ((3)F(2));
         TIMEA=HA*3600+MA*60+SA;
         IDLE='0'B;
         END;
      SELECT(VERB);
      WHEN('H','HELP') CALL HELP;
      WHEN('DUMP') DUMPFORMAT='1'B;
      WHEN('NODUMP') DUMPFORMAT='0'B;
      WHEN('SK','SKIP') CALL SKIP;
      WHEN('L','LIST','') CALL LIST;
      WHEN('DKEY') PRINTKEY='1'B;
      WHEN('NODKEY') PRINTKEY='0'B;
      WHEN('S','SELECT') CALL SELECT;
      WHEN('O','OPTIONS') CALL OPTIONS;
      WHEN('T','TOP') CALL REWIND;
      WHEN('END') GOTO EOJ;
      WHEN('COUNT') CALL COUNT;
      WHEN('F','FIND') CALL FIND;
      WHEN('FLIP') CALL FLIP;
      WHEN('AC','AUTOCOPY') AUTO='1'B;
      WHEN('NOAC','NOAUTOCOPY') AUTO='0'B;
      WHEN('K','KEY') CALL KEY;
      WHEN('NUM') COUNTFLAG='1'B;
      WHEN('NONUM') COUNTFLAG='0'B;
      WHEN('FROM') CALL FR;
      WHEN('ALLOC') CALL ALLOC;
      WHEN('INFO') CALL INFO;
      WHEN('TIOT') CALL TIOTDISPLAY;
      WHEN('TT','TERMTYPE') CALL TTSET;
      WHEN('NOR','NOREFLECT') REF=3;
      WHEN('R','REFLECT') REF=5;
      WHEN('P','PFK') CALL PFK;
      WHEN('DISP','DISPFK') CALL SHOWPFKS;
      WHEN('SETP','SETPFK') CALL SETPFK;
      WHEN('NULL') ;
      WHEN('FREE') CALL FREE;
      WHEN('TOD') CALL PUTMSG(TODAY××'    '××TIMEX);
      WHEN('COPY') CALL COPY;
      WHEN('SETC','SETCOPY') CALL SETCOPY;
      WHEN('TSO') CALL TSOCMD;
      WHEN('ECHO') ECHO='1'B;
      WHEN('NOECHO') ECHO='0'B;
      WHEN('COMP','COMPRESS') CALL COMP;
      WHEN('NOCOMP','NOCOMPRESS') COMPRESS='0'B;
      WHEN('EXP','EXPAND') CALL EXP;
      WHEN('NOEXP','NOEXPAND') EXPAND='0'B;
      WHEN('ECHAR') CALL SETCHAR(ECHAR);
      WHEN('CCHAR') CALL SETCHAR(CCHAR);
      WHEN('PRINT') CALL SPIN(2);
      OTHERWISE DO;
                X='';  /* CLEAR INPUT STACK AFTER ILLEGAL COMMAND */
                CALL PUTMSG('ILLEGAL COMMAND');
                END;
      END;
      IF INTFLG THEN
         CALL PUTMSG('INTERRUPT TIME EXCEEDED. EXECUTION INTERRUPTED.');
      GOTO GET_COMMAND;
 BADFILE:
      CALL PUTMSG('INPUT FILE IS UNDEFINED. ONCODE='××CODE);
      GOTO GET_COMMAND;
 SELECT: PROC;
      DCL (BCKFLG,CLSFLG) BIT(1) INIT('0'B);
      DCL DSORGV CHAR(2) INIT(' ');
      DCL BUFRLV FIXED BIN(31) INIT(0);
      DDNAME='';
      RCSCAN=SCANNER(VE1,TEXT,VS1);
      IF RCSCAN>4 THEN DO;
         CALL PUTMSG('SELECT COMMAND SYNTAX ERROR');
         RETURN;
         END;
      IF LENGTH(DDNAME)=0 THEN DO;
         IF LENGTH(DYNALDDN)=0 THEN DO;
            CALL PUTMSG('SELECT INVALID. NO FILE ALLOCATED');
            RETURN;
            END;
         DDNAME=DYNALDDN;
         END;
      IF CLSFLG THEN DO;
         IF OPENED THEN CALL CLOSE;
         RETURN;
         END;
      S99DDN=DDNAME;
      CALL S99VIN(S99DDN,S99DSN,S99MEM,S99MISC,
                  S99RC,S99ERROR,S99INFO);
      IF ^S99RCTEST('INFO') THEN DO;
         CALL PUTMSG('SELECT COMMAND REJECTED');
         RETURN;
         END;
      TERM=UNSPEC(SUBSTR(S99MISC,10,1))='01000000'B;
      PO=SUBSTR(UNSPEC(SUBSTR(S99MISC,4,1)),7,1);
      INDD=DDNAME;
      IF OPENED THEN CALL CLOSE;
      DSORG='PS';SYSXX=SYSPS;
      IF PO&LENGTH(S99MEM)=0 THEN DO;
         SYSXX=SYSPD;
         BUFRL=256;
         CALL OPEN;
         CALL SETREC;
         REC#=0;EOF='0'B;
         CALL PUTMSG('PDS DIRECTORY SELECTED');
         RETURN;
         END;
      IF DSORGV^=' ' THEN DO;
         DSORG=DSORGV;
         SELECT(DSORG);
         WHEN('IS') SYSXX=SYSIS;
         WHEN('R1') SYSXX=SYSR1;
         WHEN('R2') SYSXX=SYSR2;
         WHEN('R3') SYSXX=SYSR3;
         WHEN('VS') SYSXX=SYSVS;
         OTHERWISE ;
         END;
         END;
         ELSE DO;
         IF SUBSTR(UNSPEC(SUBSTR(S99MISC,4,1)),3,1) THEN DO;
            DSORG='R1';SYSXX=SYSR1;
            END;
         IF SUBSTR(UNSPEC(SUBSTR(S99MISC,4,1)),1,1) THEN DO;
            DSORG='IS';SYSXX=SYSIS;
            END;
         IF SUBSTR(UNSPEC(SUBSTR(S99MISC,5,1)),5,1) THEN DO;
            DSORG='VS';SYSXX=SYSVS;
            END;
         END;
      IF DSORG='PS'&BCKFLG THEN SYSXX=SYSPB;
      IF DSORG='VS'&BCKFLG THEN SYSXX=SYSVB;
      BUFRL=BUFRLV;
      CALL OPEN;
      CALL SETREC;
      /* IF THE FILE IS A VSAM KSDS AND BACKWARD PROCESSING HAS NOT
         BEEN REQUESTED, THEN WE CAN USE THE GENKEY OPTION SO THAT
         GENERIC KEYS WILL BE POSSIBLE WHEN IN KEY INPUT MODE */
      IF SYSXX=SYSVS THEN DO;  /* IF VSAM FORWARD PROCESSING */
         CALL FCBLOC(SYSXX,FCBPTR);
         IF SUBSTR(FELV,1,1) THEN DO;  /* IF KSDS */
            CALL CLOSE;
            SYSXX=SYSVG;
            CALL OPEN;
            END;
         END;
      REC#=0; EOF='0'B;
      CALL ACMETH;
 VE1: PROC(KW#,VALUE) RETURNS(FIXED BIN(15));
      DCL (KW#,RC) FIXED BIN(15);
      DCL VALUE CHAR(*) VAR;
      RC=0;
      SELECT(KW#);
      WHEN(5) DDNAME=VALUE;
      WHEN(6) SELECT(VALUE);
              WHEN('PS','IS','R1','R2','R3','VS') DSORGV=VALUE;
              OTHERWISE RC=99;
              END;
      WHEN(7) DO;
              IF VERIFY(VALUE,NUM)>0×LENGTH(VALUE)>5 THEN RC=99;
              ELSE DO;
              GET STRING(VALUE) LIST(BUFRLV);
              IF BUFRLV<1×BUFRLV>32767 THEN RC=99;
              END;
              END;
      WHEN(8) VSPW=VALUE;
      WHEN(9) BCKFLG='1'B;
      WHEN(10) CLSFLG='1'B;
      OTHERWISE RC=99;
      END;
      RETURN(RC);
      END VE1;
 SETREC: PROC;
      /*********************************************************
      THIS ROUTINE SETS THE LENGTH(BUFRL) OF THE INTERNAL
      CHARACTER STRING(DATA) INTO WHICH WE WILL READ RECORDS FROM
      THE USERS FILE.
      IF THE USER SUPPLIES A VALUE (IE. BUFL>0) WE USE IT,
      OTHERWISE WE USE THE MAXIMUM RECORD SIZE GIVEN IN THE
      FILE CONTROL BLOCK (FCB).
      *********************************************************/
      IF ALLOCATION(DATA)>0 THEN FREE DATA;
      IF BUFRL<=0 THEN BUFRL=RECMAX(SYSXX);
      ALLOCATE DATA CHAR(BUFRL);
      END SETREC;
      END SELECT;
 RECMAX: PROC(FNAME) RETURNS(FIXED BIN(15));
      /**********************************************************
      DETERMINE THE MAXIMUM RECORD LENGTH FOR THE GIVEN FILE.
      USE THE FCB RECORD LENGTH (FRCL) FOR ALL ACCESS METHODS.
      THE ONLY EXCEPTION TO THIS IS BSAM OR QSAM FILES WITH
      U-FORMAT RECORDS IN WHICH CASE WE USE THE BLOCKSIZE (FBKZ).
      **********************************************************/
      DCL M FIXED BIN(15) INIT(0);
      DCL FNAME FILE;
      CALL FCBLOC(FNAME,FCBPTR);
      M=FRCL;  /* USE RECORD LENGTH */
      IF FFLC=QSAM×FFLC=BSAM×FFLC=BSAML THEN DO;
         IF SUBSTR(FFLA,3,1)  /* IF RECFM=U */
            THEN M=FBKZ;  /* USE BLOCKSIZE */
         END;
      RETURN(M);
      END RECMAX;
 ACMETH: PROC;
      DCL M CHAR(20) VAR INIT('');
      CALL FCBLOC(SYSXX,FCBPTR);
      SELECT(FFLC);
      WHEN(QSAM) M='QSAM';
      WHEN(BSAM,BSAML) M='BSAM';
      WHEN(TCAM) M='TCAM';
      WHEN(QISAM) M='QISAM';
      WHEN(BISAM) M='BISAM';
      WHEN(BDAM) M='BDAM';
      WHEN(VSAM) DO;
                 M='VSAM';
                      IF SUBSTR(FELV,1,1) THEN M=M××' (KSDS)';
                 ELSE IF SUBSTR(FELV,2,1) THEN M=M××' (ESDS)';
                 ELSE IF SUBSTR(FELV,3,1) THEN M=M××' (RRDS)';
                 END;
      OTHERWISE M='UNKNOWN';
      END;
      CALL PUTMSG('ACCESS METHOD IS '××M);
      END ACMETH;
 OPEN: PROC;
      IF OPENED THEN RETURN;
      OPEN FILE(SYSXX) SEQL TITLE(INDD);
      OPENED='1'B;
      END OPEN;
 CLOSE: PROC;
      IF ^OPENED THEN RETURN;
      CLOSE FILE(SYSXX);
      OPENED='0'B;
      END CLOSE;
 REWIND: PROC;
      IF ^OPENED THEN DO;
             CALL PUTMSG('FILE NOT OPEN. TOP INVALID');
             RETURN;
             END;
      IF TERM THEN DO;
         CALL PUTMSG('TOP INVALID FOR TERMINAL INPUT FILE');
         RETURN;
         END;
      CALL CLOSE;
      CALL OPEN;
      REC#=0; EOF='0'B;
      END REWIND;
 LIST: PROC;
      ON ENDFILE(SYSXX) GOTO ENDUP;
      IF ^OPENED THEN DO;
             CALL PUTMSG('FILE NOT OPEN. ENTER SELECT COMMAND');
             RETURN;
             END;
      IF INDEX(TEXT,'*')>0 THEN DO;
               IF REC#=0 THEN DO;
                              CALL PUTMSG('RECORD COUNTER IS ZERO');
                              RETURN;
                              END;
               CALL PRINT(DATA,'RECORD ');
               IF PRINTKEY&DSORG^='PS' THEN CALL PRINT(KEAY,'KEY ');
               RETURN;
               END;
      IF EOF THEN GOTO ENDUP;
      IF LENGTH(VERB)=0 THEN N=1;
         ELSE DO;
              N=2000000000;
              RCSCAN=SCANNER(VE7,TEXT,VS7);
              IF RCSCAN>4 THEN DO;
                 CALL PUTMSG('LIST COMMAND SYNTAX ERROR');
                 RETURN;
                 END;
              END;
      DO I=1 TO N;
      IF ATTFLG×INTFLG THEN RETURN;
      SELECT(DSORG);
      WHEN('PS') SELECT;
                 WHEN(TERM) DO;
                            SELECT(TT);
                            WHEN('3270') DO;
                                         ISTRING='DATA'××(9)' '××TIMEX;
                                         RC3270=IO3270(DATA,3);
                                         IF LENGTH(DATA)<=1 THEN
                                         SIGNAL ENDFILE(SYSXX);
                                         DATA=SUBSTR(DATA,2);
                                         END;
                            OTHERWISE DO;
                                      PUT EDIT('DATA: ') (SKIP,A);
                                      GET EDIT(DATA) (SKIP(0),A(80));
                                      IF DATA=' ' THEN DATA='';
                                      END;
                            END;
                            IF LENGTH(DATA)=0×DATA='/*' THEN
                            SIGNAL ENDFILE(SYSXX);
                            END;
                 OTHERWISE READ FILE(SYSXX) INTO(DATA);
                 END;
      OTHERWISE READ FILE(SYSXX) INTO(DATA) KEYTO(KEAY);
      END;
      REC#=REC#+1;
      IF AUTO THEN CALL COPY;
      CALL PRINT(DATA,'RECORD ');
      IF PRINTKEY&DSORG^='PS' THEN CALL PRINT(KEAY,'KEY ');
      END;
      RETURN;
 ENDUP: EOF='1'B;
      CALL PUTMSG('END OF FILE IN INPUT DATASET');
      END LIST;
 PRINT: PROC(DODO,U);
      DCL U CHAR(*);
      DCL DODO CHAR(*) VAR;
      IF ATTFLG×INTFLG THEN RETURN;
      LEN=LENGTH(DODO);
      IF COUNTFLAG THEN CALL PUTMSG(U××CH(REC#)××
                                    '  LENGTH '××CH(LEN));
      IF U='KEY ' THEN DO; F=1; T=LEN; END;
                  ELSE DO;
      IF FROM<1×FROM>LEN THEN F=1; ELSE F=FROM;
      IF TO<F THEN T=LEN; ELSE T=MIN(TO,LEN);
                       END;
      IF DUMPFORMAT
         THEN DO;
              F=F-MOD(F-1,4);  /* ROUND DOWN TO NEXT FULLWORD */
              DO A=F BY #B TO T;
              IF ATTFLG×INTFLG THEN RETURN;
              TOP=A+#B-1;
              TOP=MIN(TOP,T);
              LINE32=SUBSTR(DODO,A,TOP-A+1);
              BIN=A-1;
              IF A=F THEN GOTO ZA;
              IF A+#B<=T&LINE32=PREVINFO THEN GOTO ZB;
              IF BIN-PREVOFFSET=#B THEN GOTO ZA;
              BAN=BIN-#B;
              WARK=SUBSTR(YY,2,3);
              CALL HEXOUT(WARK,OFFSET2);
              IF BIN-PREVOFFSET=#H THEN DO;
              CALL PUTMSG('LINE '××OFFSET2××' SAME AS ABOVE');
              END;
              ELSE DO;
              BAN=PREVOFFSET+#B;
              WARK=SUBSTR(YY,2,3);
              CALL HEXOUT(WARK,OFFSET1);
              CALL PUTMSG('LINES '××OFFSET1××'-'××OFFSET2××
                          ' SAME AS ABOVE');
              END;
           ZA:WORK=SUBSTR(Y,2,3);
              CALL HEXOUT(WORK,OFFSET);
              INFORM=TRANSLATE(LINE32,TRTAB1);
              CALL HEXOUT(LINE32,HEX64);
              DO B=1 TO #W;
              WORDS(B)=SUBSTR(HEX64,B*8-7);
              END;
              IF #W=8 THEN PUT STRING(LINE) EDIT(DUMPLINE) (R(F8));
                      ELSE PUT STRING(LINE) EDIT(DUMPLINE) (R(F4));
           F8:FORMAT(A,X(1),(4)(X(1),A),X(3),(4)(X(1),A),X(2),A,A,A);
           F4:FORMAT(A,X(1),(4)(X(1),A),                 X(2),A,A,A);
              CALL PUTMSG(LINE);
              PREVINFO=LINE32;
              PREVOFFSET=BIN;
           ZB:END;
           END;
      ELSE DO A=F BY LS TO T;
           IF ATTFLG×INTFLG THEN RETURN;
           TOP=A+LS-1;
           TOP=MIN(TOP,T);
           LINE=SUBSTR(DODO,A,TOP-A+1);
           LINE=TRANSLATE(LINE,TRTAB2);
           CALL PUTMSG(LINE);
           END;
      END PRINT;
 CH31: PROC(A) RETURNS(CHAR(11) VAR);
      DCL B CHAR(11) VAR , (A,W) FIXED BIN(31);
      PUT STRING(B) EDIT(A) (F(11));
      GOTO CHX;
 CH15: ENTRY(C) RETURNS(CHAR(11) VAR);
      DCL C FIXED BIN(15);
      PUT STRING(B) EDIT(C) (F(11));
 CHX: W=VERIFY(B,' ');
      B=SUBSTR(B,W);
      RETURN(B);
      END CH31;
 S99DSTYP: PROC(T,D);
      DCL T CHAR(1) , D CHAR(*) VAR;
      SELECT(UNSPEC(T));
      WHEN('10000000'B) CALL PUTMSG('DDNAME '××D××
                        ' IS A DUMMY DATASET');
      WHEN('01000000'B) CALL PUTMSG('DDNAME '××D××
                        ' IS ALLOCATED TO THE TERMINAL');
      OTHERWISE ;
      END;
      END S99DSTYP;
 S99DSORG: PROC(Z);
      DCL Z CHAR(2) , M CHAR(7);
      VFLG='0'B;
      SELECT(UNSPEC(Z));
      WHEN('0000000000000100'B) M='TR';
      WHEN('0000000000001000'B) DO; M='VSAM'; VFLG='1'B; END;
      WHEN('0000000000100000'B) M='TQ';
      WHEN('0000000001000000'B) M='TX';
      WHEN('0000000010000000'B) M='GS';
      WHEN('0000001000000000'B) M='PO';
      WHEN('0000001100000000'B) M='POU';
      WHEN('0000010000000000'B) M='MQ';
      WHEN('0000100000000000'B) M='CQ';
      WHEN('0001000000000000'B) M='CX';
      WHEN('0010000000000000'B) M='DA';
      WHEN('0010000100000000'B) M='DAU';
      WHEN('0100000000000000'B) M='PS';
      WHEN('0100000100000000'B) M='PSU';
      WHEN('1000000000000000'B) M='IS';
      WHEN('1000000100000000'B) M='ISU';
      OTHERWISE M='UNKNOWN';
      END;
      CALL PUTMSG('DATASET ORGANIZATION IS '××M);
      END S99DSORG;
 S99RCTEST: PROC(TYPE) RETURNS(BIT(1));
      DCL TYPE CHAR(*);
      IF S99RC=0 THEN RETURN('1'B);
      CALL PUTMSG('DYNALLOC '××TYPE××' FAILED');
      BIN=S99ERROR;
      S99WORK=SUBSTR(Y,3,2);
      CALL HEXOUT(S99WORK,S99ERRORX);
      BIN=S99INFO;
      S99WORK=SUBSTR(Y,3,2);
      CALL HEXOUT(S99WORK,S99INFOX);
      CALL PUTMSG('DYNAMIC ALLOCATION RETURN CODES ARE: S99RC('××
                  CH(S99RC)××') S99ERROR('××S99ERRORX××
                  ') S99INFO('××S99INFOX××')');
      RETURN('0'B);
      END S99RCTEST;
 PUTMSG: PROC(MSG);
      DCL I FIXED BINARY(15);
      DCL MSG CHAR(*) VAR;
      I=LENGTH(MSG);
      IF I=0 THEN RETURN;
      DO WHILE(I>1&SUBSTR(MSG,I,1)=' ');
      I=I-1;
      END;
      MSS=SUBSTR(MSG,1,I);
      IF TT='3270' THEN RC3270=IO3270(MSS,1);
                   ELSE PUT EDIT(MSS) (SKIP,A);
      END PUTMSG;
 GETMSG: PROC(MSG);
      DCL I FIXED BIN(31);
      DCL C CHAR(1);
      DCL MSG CHAR(*) VAR;
      DCL (F1,F2) BIT(1) INIT('0'B);
      DCL AID CHAR(1);
      MSG='';
      IF LENGTH(X)=0 THEN DO;
         IF TSO THEN DO;
            IF TT='3270' THEN DO;
               IF KIMODE THEN ISTRING='KEY'××(10)' '××TIMEX;
                         ELSE ISTRING='CMD'××(10)' '××TIMEX;
               INPUT3270: RC3270=IO3270(X,REF);
               IF ATTFLG THEN DO; ATTFLG='0'B; GOTO INPUT3270; END;
               AID=X;
               IF LENGTH(X)>1 THEN X=SUBSTR(X,2); ELSE X='';
               I=INDEX(PFKCODES,AID);
               IF I>0 THEN DO;
                  IF LENGTH(X)>0 THEN DO;
                     IF PFKTYPE(I)='S' THEN X=X××';P '××CH(I);
                                       ELSE X='P '××CH(I)××';'××X;
                     END;
                     ELSE X='P '××CH(I);
                  END;
               END;
               ELSE DO;
                    IF KIMODE THEN PUT EDIT('KEY: ') (SKIP,A);
                              ELSE PUT EDIT('CMD: ') (SKIP,A);
                    GET EDIT(X) (SKIP(0),A(200));
                    END;
            END;
            ELSE GET EDIT(X) (A(80));
         IF X=' ' THEN DO; X=''; RETURN; END;
         END;
      DO I=1 TO LENGTH(X);
      C=SUBSTR(X,I);
      IF F2 THEN DO;
                 MSG=MSG××C;
                 IF C='''' THEN F2='0'B;
                 END;
            ELSE SELECT(C);
                 WHEN(' ') DO;
                           IF LENGTH(MSG)>0 THEN F1='1'B;
                           END;
                 WHEN(';') DO;
                           X=SUBSTR(X,I+1);
                           IF X=' ' THEN X='';
                           RETURN;
                           END;
                 OTHERWISE DO;
                           C=TRANSLATE(C,UPPER,LOWER);
                           IF C='''' THEN F2='1'B;
                           IF F1 THEN DO;
                                      MSG=MSG××' '××C;
                                      F1='0'B;
                                      END;
                                 ELSE MSG=MSG××C;
                           END;
                 END;
      END;
      X='';
      END GETMSG;
 HELP: PROC;
      IF LENGTH(TEXT)=0 THEN DO;
      CALL PUTMSG('AVAILABLE SUBCOMMANDS ARE:');
      CALL PUTMSG('ALLOC,AUTOCOPY,CCHAR,COMPRESS,COPY,COUNT,DISPFK,DKEY,
 DUMP,ECHAR,');
      CALL PUTMSG('ECHO,END,EXPAND,FIND,FLIP,FREE,FROM,HELP,INFO,INTERRU
 PT,KEY,LIST,');
      CALL PUTMSG('NUM,OPTIONS,PFK,PRINT,REFLECT,SELECT,SETCOPY,SETPFK,S
 KIP,TERMTYPE,');
      CALL PUTMSG('TIOT,TOD,TOP,TSO');
      CALL PUTMSG('FOR MORE INFORMATION TYPE: HELP SUBCOMMANDNAME');
      RETURN;
      END;
      SELECT(TEXT);
      WHEN('ALLOC')
      CALL PUTMSG('COMBINED SYNTAX OF TSO ALLOC AND ATTR COMMANDS');
      WHEN('AUTOCOPY')
      CALL PUTMSG('AUTOCOPY×AC<-->NOAUTOCOPY×NOAC');
      WHEN('COPY','COUNT','END','TIOT','TOD')
      CALL PUTMSG(TEXT);
      WHEN('DISPFK') CALL PUTMSG('DISPfk <n>');
      WHEN('DKEY') CALL PUTMSG('DKEY<-->NODKEY');
      WHEN('DUMP') CALL PUTMSG('DUMP<-->NODUMP');
      WHEN('FIND') CALL PUTMSG('Find <string> <n> <LIST> <ALL> <COPY>');
      WHEN('FLIP') CALL PUTMSG('FLIP DUMP×NUM×REFLECT×AUTOCOPY×DKEY');
      WHEN('FREE')
      CALL PUTMSG('SAME SYNTAX AS TSO FREE COMMAND');
      WHEN('FROM') CALL PUTMSG('FROM n1 <TO n2>');
      WHEN('PRINT')
      CALL PUTMSG('PRINT <DEST(stationid)> <SYSOUT(class)>'
                  ××' <HOLD×NOHOLD>');
      WHEN('HELP') CALL PUTMSG('Help <subcommandname>');
      WHEN('INFO') CALL PUTMSG('INFO <FI(ddname)>');
      WHEN('INTERRUPT') CALL PUTMSG('INTerrupt n');
      WHEN('KEY') CALL PUTMSG('Key');
      WHEN('LIST') CALL PUTMSG('List <n×*>');
      WHEN('NUM') CALL PUTMSG('NUM<-->NONUM');
      WHEN('OPTIONS') CALL PUTMSG('Options');
      WHEN('PFK') CALL PUTMSG('Pfk n');
      WHEN('REFLECT') CALL PUTMSG('Reflect<-->NOReflect');
      WHEN('SELECT') CALL PUTMSG('Select <FI(ddname)> <DSorg(v)>'
           ××' <BUFL(n)> <PASSword(pw)> <BACKwards> <CLose>');
      WHEN('SETCOPY') CALL PUTMSG('SETCopy FI(ddname)×CLose');
      WHEN('SETPFK')
      CALL PUTMSG('SETPfk n <string> <PREFIX×SUFFIX>');
      WHEN('SKIP') CALL PUTMSG('SKip <n>');
      WHEN('TERMTYPE') CALL PUTMSG('TERMTYPE×TT 3270×2741');
      WHEN('TOP') CALL PUTMSG('Top');
      WHEN('TSO') CALL PUTMSG('TSO command');
      WHEN('COMPRESS') CALL PUTMSG('COMPress <n> <--> NOCOMPress');
      WHEN('EXPAND') CALL PUTMSG('EXPand <n> <--> NOEXPand');
      WHEN('ECHO') CALL PUTMSG('ECHO<-->NOECHO');
      WHEN('CCHAR') CALL PUTMSG('CCHAR c ');
      WHEN('ECHAR') CALL PUTMSG('ECHAR c ');
      OTHERWISE CALL PUTMSG('UNKNOWN SUBCOMMAND');
      END;
      END HELP;
 SKIP: PROC;
      ON ENDFILE(SYSXX) GOTO ENDUP;
      IF ^OPENED THEN DO;
             CALL PUTMSG('FILE NOT OPEN. ENTER SELECT COMMAND');
             RETURN;
             END;
      IF TERM THEN DO;
         CALL PUTMSG('SKIP INVALID FOR TERMINAL INPUT FILE');
         RETURN;
         END;
      IF EOF THEN GOTO ENDUP;
      N=1;
      RCSCAN=SCANNER(VE7,TEXT,VS7);
      IF RCSCAN>4 THEN DO;
         CALL PUTMSG('SKIP COMMAND SYNTAX ERROR');
         RETURN;
         END;
      DO I=1 TO N;
      IF ATTFLG×INTFLG THEN RETURN;
      SELECT(DSORG);
      WHEN('PS') READ FILE(SYSXX) INTO(DATA);
      OTHERWISE  READ FILE(SYSXX) INTO(DATA) KEYTO(KEAY);
      END;
      REC#=REC#+1;
      IF AUTO THEN CALL COPY;
      END;
      RETURN;
 ENDUP: EOF='1'B;
      CALL PUTMSG('END OF FILE IN INPUT DATASET');
      END SKIP;
 COUNT: PROC;
      DCL TRUE BIT(1) INIT('1'B);
      ON ENDFILE(SYSXX) GOTO ENDUP;
      IF ^OPENED THEN DO;
         CALL PUTMSG('FILE NOT OPEN. ENTER SELECT COMMAND');
         RETURN;
         END;
      IF TERM THEN DO;
         CALL PUTMSG('COUNT INVALID FOR TERMINAL INPUT FILE');
         RETURN;
         END;
      IF REC#>0×EOF THEN CALL REWIND;
      DO WHILE(TRUE);
      IF ATTFLG×INTFLG THEN RETURN;
      SELECT(DSORG);
      WHEN('PS') READ FILE(SYSXX) INTO(DATA);
      OTHERWISE  READ FILE(SYSXX) INTO(DATA) KEYTO(KEAY);
      END;
      REC#=REC#+1;
      IF AUTO THEN CALL COPY;
      END;
 ENDUP: EOF='1'B;
      CALL PUTMSG(CH(REC#));
      CALL REWIND;
      END COUNT;
 FLIP: PROC;
      SELECT(TEXT);
      WHEN('DUMP') DUMPFORMAT=^DUMPFORMAT;
      WHEN('NUM') COUNTFLAG=^COUNTFLAG;
      WHEN('REFLECT') IF REF=5 THEN REF=3; ELSE REF=5;
      WHEN('AUTOCOPY') AUTO=^AUTO;
      WHEN('DKEY') PRINTKEY=^PRINTKEY;
      OTHERWISE CALL PUTMSG('FLIP PARAMETER INVALID');
      END;
      END FLIP;
 OPTIONS: PROC;
      DCL O CHAR(100) VAR;
      DCL CIN CHAR(1) VAR;
      DCL COUT CHAR(2);
      IF OPENED THEN DO;
         O='FI('××INDD××') DSORG('××DSORG××') BUFL('××CH(BUFRL)××')';
         IF SYSXX=SYSPB×SYSXX=SYSVB THEN O=O××' BACKWARDS';
         CALL PUTMSG(O);
         END;
      IF DUMPFORMAT THEN O='DUMP;'; ELSE O='NODUMP;';
      IF PRINTKEY THEN O=O××'DKEY;'; ELSE O=O××'NODKEY;';
      IF COUNTFLAG THEN O=O××'NUM;'; ELSE O=O××'NONUM;';
      O=O××'FROM '××CH(FROM)××' TO ' ××CH(TO)××';';
      O=O××'TT '××TT××';';
      IF REF=3 THEN O=O××'NOREFLECT;';
               ELSE O=O××'REFLECT;';
      IF AUTO THEN O=O××'AC;'; ELSE O=O××'NOAC;';
      O=O××'INT '××CH(P#)××';';
      CALL PUTMSG(O);
      IF EXPAND THEN O='EXPAND '××CH(E#)××';';
                ELSE O='NOEXPAND'××';';
      IF COMPRESS THEN O=O××'COMPRESS '××CH(C#)××';';
                  ELSE O=O××'NOCOMPRESS'××';';
      CIN=CCHAR;
      CALL HEXOUT(CIN,COUT);
      O=O××'CCHAR "'××COUT××'";';
      CIN=ECHAR;
      CALL HEXOUT(CIN,COUT);
      O=O××'ECHAR "'××COUT××'";';
      CALL PUTMSG(O);
      IF LENGTH(FC)>0 THEN CALL PUTMSG('LAST FIND COMMAND: FIND '××FC);
      END OPTIONS;
 TTSET: PROC;
      IF ^TSO THEN RETURN;
      IF DISPLAY=0 THEN RETURN;
      RCSCAN=SCANNER(VE7,TEXT,VS7);
      IF RCSCAN>0 THEN DO;
         CALL PUTMSG('TERMTYPE COMMAND SYNTAX ERROR');
         RETURN;
         END;
      IF N=3270 THEN DO;
         IF TT='2741' THEN RC3270=IO3270(' ',6);
         TT='3270';
         RC3270=IO3270(' ',0);
         RETURN;
         END;
      IF N=2741 THEN DO;
         IF TT='3270' THEN RC3270=IO3270(' ',4);
         TT='2741';
         RETURN;
         END;
      CALL PUTMSG('ILLEGAL TERMINAL TYPE');
      END TTSET;
 PFK: PROC;
      RCSCAN=SCANNER(VE7,TEXT,VS7);
      IF RCSCAN>0 THEN DO;
         CALL PUTMSG('PFK COMMAND SYNTAX ERROR');
         RETURN;
         END;
      IF N<2×N>24 THEN CALL PUTMSG('ILLEGAL PFK NUMBER');
                  ELSE X=PFKEY(N)××';'××X;
      END PFK;
 SHOWPFKS: PROC;
      N=0;
      RCSCAN=SCANNER(VE7,TEXT,VS7);
      IF RCSCAN>4 THEN DO;
         CALL PUTMSG('DISPFK COMMAND SYNTAX ERROR');
         RETURN;
         END;
      IF N<0×N>24 THEN DO;
         CALL PUTMSG('ILLEGAL PFK NUMBER');
         RETURN;
         END;
      IF N>0 THEN CALL PUTMSG('PFK '××CH(N)××'('××PFKTYPE(N)××'): '××
                               PFKEY(N));
         ELSE DO N=1 TO 24;
              IF ATTFLG×INTFLG THEN RETURN;
              IF PFKEY(N)^='NULL' THEN
              CALL PUTMSG('PFK '××CH(N)××'('××PFKTYPE(N)××'): '××
                           PFKEY(N));
              END;
      END SHOWPFKS;
 SETPFK: PROC;
      DCL (PFK#,S#) FIXED BIN(15) INIT(0);
      DCL PFKVAL CHAR(100) VAR INIT('');
      DCL PRESUF CHAR(1) INIT(' ');
      RCSCAN=SCANNER(VE3,TEXT,VS3);
      IF RCSCAN>0 THEN DO;
         CALL PUTMSG('SETPFK COMMAND SYNTAX ERROR');
         RETURN;
         END;
      IF PFK#<2×PFK#>24 THEN DO;
         CALL PUTMSG('ILLEGAL PFK NUMBER');
         RETURN;
         END;
      IF LENGTH(PFKVAL)>0 THEN PFKEY(PFK#)=PFKVAL;
      IF PRESUF^=' ' THEN PFKTYPE(PFK#)=PRESUF;
 VE3: PROC(KW#,VALUE) RETURNS(FIXED BIN(15));
      DCL (KW#,RC) FIXED BIN(15);
      DCL VALUE CHAR(*) VAR;
      RC=0;
      SELECT(KW#);
      WHEN(1,2,3,4) DO;
                    S#=S#+1;
                    SELECT(S#);
                    WHEN(1) SELECT(KW#);
                            WHEN(3) GET STRING(VALUE) LIST(PFK#);
                            OTHERWISE RC=99;
                            END;
                    WHEN(2) SELECT(KW#);
                            WHEN(1) GET STRING(VALUE) LIST(PFKVAL);
                            OTHERWISE PFKVAL=VALUE;
                            END;
                    OTHERWISE RC=99;
                    END;
                    END;
      WHEN(5,6) PRESUF=VS3.KW(KW#-4);
      OTHERWISE RC=99;
      END;
      RETURN(RC);
      END VE3;
      END SETPFK;
 TSOCMD: PROC;
      DCL RTCDE CHAR(8) VAR INIT('');
      DCL I FIXED BIN(15) INIT(0);
      DCL (V1,V2) CHAR(100) VAR INIT('');
      IF ^TSO THEN RETURN;
      IF LENGTH(TEXT)=0 THEN RETURN;
      RCSCAN=SCANNER(VE6,TEXT,VS6);
      IF INDEX('LOGON LOGOFF PDUMP TEST',V1)>0×LENGTH(V1)>8
         THEN DO;
              CALL PUTMSG('TSO COMMAND INVALID');
              RETURN;
              END;
      IF I=1 THEN CBOFFSET=LENGTH(V1);
             ELSE CBOFFSET=INDEX(TEXT,V2)-1;
      CBLENGTH=LENGTH(TEXT)+4;
      CBTEXT=TEXT;
      CALL CPPL(CPPLCBUF,CPPLUPT,CPPLPSCB,CPPLECT);
      IF CPPLCBUF=NULL THEN RETURN;  /*  PDUMP INVOKED BY TSO CALL */
      CPPLCBUF=ADDR(CBLENGTH);
      IF TT='3270' THEN RC3270=IO3270(' ',4);
      RCTSOCP=TSOCP(CPPLCBUF,RTCDE);
      IF TT='3270' THEN RC3270=IO3270(' ',6);
      IF RCTSOCP>0 THEN CALL PUTMSG('TSO COMMAND NOT FOUND');
                   ELSE CALL PUTMSG('TSO COMMAND RETURN CODE '××RTCDE);
 VE6: PROC(KW#,VALUE) RETURNS(FIXED BIN(15));
      DCL (KW#,RC) FIXED BIN(15);
      DCL VALUE CHAR(*) VAR;
      RC=0;
      I=I+1;
      SELECT(I);
      WHEN(1) V1=VALUE;
      WHEN(2) V2=VALUE;
      OTHERWISE RC=99;
      END;
      RETURN(RC);
      END VE6;
      END TSOCMD;
 FREE: PROC;
      DDNAME='';
      IF LENGTH(TEXT)=0 THEN DO;
         IF OPENED THEN DO; DDNAME=INDD; CALL CLOSE; END;
                   ELSE DDNAME=DYNALDDN;
         IF LENGTH(DDNAME)=0 THEN DO;
            CALL PUTMSG('FREE INVALID. NO FILE SELECTED OR ALLOCATED');
            RETURN;
            END;
         TEXT='FI('××DDNAME××')';
         END;
      CALL S99FREE(TEXT,VUNRC,S99RC,S99ERROR,S99INFO);
      IF VUNRC>0 THEN DO;
         CALL PUTMSG('FREE SYNTAX ERROR. SCAN RC='××CH(VUNRC));
         RETURN;
         END;
      IF ^S99RCTEST('FREE') THEN RETURN;
      CALL PUTMSG('FILE '××DDNAME××' FREED');
      END FREE;
 FIND: PROC;
      DCL (N,S#) FIXED BIN(15) INIT(0);
      DCL (CS,FS,SS) CHAR(100) VAR INIT('');
      DCL (HEX,L,ALL,FCOPY) BIT(1) INIT('0'B);
      ON ENDFILE(SYSXX) GOTO ENDUP;
      IF ^OPENED THEN DO;
             CALL PUTMSG('FILE NOT OPEN. ENTER SELECT COMMAND');
             RETURN;
             END;
      IF TERM THEN DO;
         CALL PUTMSG('FIND INVALID FOR TERMINAL INPUT FILE');
         RETURN;
         END;
      IF EOF THEN GOTO ENDUP;
      IF LENGTH(TEXT)=0 THEN TEXT=FC; ELSE FC=TEXT;
      RCSCAN=SCANNER(VE2,TEXT,VS2);
      IF RCSCAN>4 THEN DO;
         CALL PUTMSG('FIND COMMAND SYNTAX ERROR');
         RETURN;
         END;
      IF LENGTH(FS)=0 THEN DO;
         CALL PUTMSG('FIND INVALID. NO SEARCH STRING AVAILABLE');
         RETURN;
         END;
      IF FCOPY&LENGTH(COPYDD)=0 THEN DO;
         FCOPY='0'B;
         CALL PUTMSG('COPY OPTION IGNORED. NO COPY FILE AVAILABLE');
         END;
      IF RCSCAN=0 THEN DO;
         IF HEX THEN DO;
            IF ^HEXIN(FS,SS) THEN GOTO HEXERR;
            FS=SS;
            END;
         END;
 RDLOOP:
      IF ATTFLG×INTFLG THEN RETURN;
      SELECT(DSORG);
      WHEN('PS') READ FILE(SYSXX) INTO(DATA);
      OTHERWISE  READ FILE(SYSXX) INTO(DATA) KEYTO(KEAY);
      END;
      REC#=REC#+1;
      IF AUTO THEN CALL COPY;
      SELECT(N);
      WHEN(0)   DO;
                IF INDEX(DATA,FS)>0 THEN GOTO FOUND;
                END;
      OTHERWISE DO;
                IF N>LENGTH(DATA) THEN LEAVE;
                CS=SUBSTR(DATA,N);
                IF FS=SUBSTR(CS,1,MIN(LENGTH(FS),LENGTH(CS)))
                            THEN GOTO FOUND;
                END;
      END;
      IF L THEN DO;
                CALL PRINT(DATA,'RECORD ');
                IF PRINTKEY&DSORG^='PS' THEN CALL PRINT(KEAY,'KEY ');
                END;
      GOTO RDLOOP;
 FOUND:
      CALL PRINT(DATA,'RECORD ');
      IF PRINTKEY&DSORG^='PS' THEN CALL PRINT(KEAY,'KEY ');
      IF FCOPY THEN CALL COPY;
      IF ALL THEN GOTO RDLOOP;
      RETURN;
 VE2: PROC(KW#,VALUE) RETURNS(FIXED BIN(15));
      DCL (KW#,RC) FIXED BIN(15);
      DCL VALUE CHAR(*) VAR;
      RC=0;
      SELECT(KW#);
      WHEN(1,2,3,4) DO;
                    S#=S#+1;
                    SELECT(S#);
                    WHEN(1) SELECT(KW#);
                            WHEN(1) GET STRING(VALUE) LIST(FS);
                            OTHERWISE DO;
                                      FS=VALUE;
                                      IF SUBSTR(FS,1,1)='"'&
                                      SUBSTR(FS,LENGTH(FS),1)='"'
                                      THEN DO;
                                      HEX='1'B;
                                      FS=SUBSTR(FS,2,LENGTH(FS)-2);
                                      END;
                                      END;
                            END;
                    WHEN(2) SELECT(KW#);
                            WHEN(1,2,4) RC=99;
                            OTHERWISE GET STRING(VALUE) LIST(N);
                            END;
                    OTHERWISE RC=99;
                    END;
                    END;
      WHEN(5) L='1'B;
      WHEN(6) ALL='1'B;
      WHEN(7) FCOPY='1'B;
      OTHERWISE RC=99;
      END;
      RETURN(RC);
      END VE2;
 HEXERR: CALL PUTMSG('INVALID HEX SEARCH STRING'); RETURN;
 ENDUP: EOF='1'B;
      CALL PUTMSG('END OF FILE IN INPUT DATASET');
      END FIND;
 HEXIN: PROC(IS,OS) RETURNS(BIT(1));
      DCL (IS,OS) CHAR(*) VAR;
      DCL SET CHAR(16) INIT('0123456789ABCDEF');
      DCL P POINTER;
      DCL BIN FIXED BIN(31) BASED(P);
      DCL Y(4) CHAR(1);
      DCL (K,NC1,NC2) FIXED BIN(15) INIT(0);
      P=ADDR(Y);
      OS='';
      K=1;
      IF MOD(LENGTH(IS),2)^=0 THEN RETURN('0'B);
      DO WHILE(K<LENGTH(IS));
      NC1=INDEX(SET,SUBSTR(IS,K,1))-1;
      NC2=INDEX(SET,SUBSTR(IS,K+1,1))-1;
      IF NC1=-1×NC2=-1 THEN RETURN('0'B);
      BIN=NC1*16+NC2;
      OS=OS××Y(4);
      K=K+2;
      END;
      RETURN('1'B);
      END HEXIN;
 KEY: PROC;
      IF ^OPENED THEN DO;
             CALL PUTMSG('FILE NOT OPEN. ENTER SELECT COMMAND');
             RETURN;
             END;
      SELECT(DSORG);
      WHEN('PS') DO;
                 CALL PUTMSG('KEY INPUT MODE INVALID'××
                             ' FOR SEQUENTIAL FILE');
                 RETURN;
                 END;
      WHEN('IS','VS') ;
      OTHERWISE DO;
                CALL CLOSE;
                CALL OPEN_DIR;
                END;
      END;
      ON ERROR GOTO GET_KEY;
      ON KEY(SYSXX) GOTO NOREC;
      ON CONVERSION GOTO CONVK;
      CALL PUTMSG('KEY INPUT MODE');
      KIMODE='1'B;
 GET_KEY:
      ATTFLG='0'B;
      CALL GETMSG(REPLY);
      IF LENGTH(REPLY)=0 THEN GOTO S_MODE;
      SQ,DQ='0'B;
      IF LENGTH(REPLY)>1 THEN DO;
         SQ=SUBSTR(REPLY,1,1)=''''&SUBSTR(REPLY,LENGTH(REPLY),1)='''';
         DQ=SUBSTR(REPLY,1,1)='"' &SUBSTR(REPLY,LENGTH(REPLY),1)='"';
         END;
      KEEY=REPLY;
      IF SQ THEN GET STRING(REPLY) LIST(KEEY);
      IF DQ THEN DO;
                 IF ^HEXIN(SUBSTR(REPLY,2,LENGTH(REPLY)-2),KEEY)
                    THEN GOTO CONVK;
                 IF ECHO THEN CALL PUTMSG('KEY: '××REPLY);
                 END;
            ELSE IF ECHO THEN CALL PUTMSG('KEY: '××KEEY);
      READ FILE(SYSXX) INTO(DATA) KEY(KEEY);
      KEAY=KEEY;
      REC#=REC#+1;
      IF AUTO THEN CALL COPY;
      CALL PRINT(DATA,'RECORD ');
      IF PRINTKEY THEN CALL PRINT(KEEY,'KEY ');
      GOTO GET_KEY;
 NOREC:
      CALL PUTMSG('KEYED RECORD NOT FOUND. KEY='××KEEY);
      GOTO GET_KEY;
 CONVK:
      CALL PUTMSG('INVALID KEY. RE-ENTER');
      GOTO GET_KEY;
 S_MODE:
      IF DSORG='IS'×DSORG='VS' THEN ; ELSE CALL REWIND;
      CALL PUTMSG('SEQUENTIAL INPUT MODE');
 OPEN_DIR: PROC;
      IF OPENED THEN RETURN;
      OPEN FILE(SYSXX) DIRECT TITLE(INDD);
      OPENED='1'B;
      END OPEN_DIR;
      END KEY;
 FR: PROC;
      DCL S# FIXED BIN(15) INIT(0);
      DCL (F#,T#) FIXED BIN(31) INIT(0);
      RCSCAN=SCANNER(VE8,TEXT,VS8);
      IF RCSCAN>0 THEN DO;
         CALL PUTMSG('FROM COMMAND SYNTAX ERROR');
         RETURN;
         END;
      IF F#<1×F#>32760×T#<0×T#>32760×(T#<F#&T#>0) THEN DO;
         CALL PUTMSG('FROM COMMAND PARAMETER VALUE ERROR');
         RETURN;
         END;
      FROM=F#;
      TO=T#;
 VE8: PROC(KW#,VALUE) RETURNS(FIXED BIN(15));
      DCL (KW#,RC) FIXED BIN(15);
      DCL VALUE CHAR(*) VAR;
      RC=0;
      SELECT(KW#);
      WHEN(3) DO;
              S#=S#+1;
              SELECT(S#);
              WHEN(1) GET STRING(VALUE) LIST(F#);
              WHEN(2) GET STRING(VALUE) LIST(T#);
              OTHERWISE RC=99;
              END;
              END;
      WHEN(5) ;
      OTHERWISE RC=99;
      END;
      RETURN(RC);
      END VE8;
      END FR;
 ALLOC: PROC;
      DCL DSG CHAR(2);
      DYNALDSN,DYNALDSG,DYNALVOL='';
      CALL S99VAL(TEXT,SALRC,S99RC,S99ERROR,S99INFO,
                  DYNALDDN,DYNALDSN,DYNALDSG,DYNALVOL);
      IF SALRC>0 THEN DO;
         CALL PUTMSG('ALLOC SYNTAX ERROR. SCAN RC='××CH(SALRC));
         RETURN;
         END;
      IF ^S99RCTEST('ALLOCATION') THEN RETURN;
      CALL PUTMSG('DATASET '××DYNALDSN××' SUCCESSFULLY ALLOCATED '××
                  'TO DDNAME '××DYNALDDN);
      IF DYNALVOL^='' THEN CALL PUTMSG('ON VOLUME '××DYNALVOL);
      DSG=DYNALDSG;
      CALL S99DSORG(DSG);
      END ALLOC;
 INFO: PROC;
      DCL (P,P2) POINTER;
      DCL I FIXED BIN(31) BASED(P2);
      DCL P1 POINTER BASED(P);
      DCL M CHAR(100) VAR;
      DCL DSCB CHAR(96);
      DCL RECFM CHAR(5) VAR;
      DCL DSNAME CHAR(44);
      DCL (L,B,ORC) FIXED BIN(31);
      DCL VOLSER CHAR(6);
      DCL UI CHAR(6);
      DCL DEVTRK(15) FIXED BIN(15) INIT(10,8,10,46,20,8,8,20,
                     19,12,30,12,19,15,0);  /* TRACKS PER CYLINDER */
      DCL DASD(15) CHAR(8) VAR INIT('2311','2301','2303','2302',
      '2321','2305-1','2305-2','2314','3330','3340','3350','3375',
              '3330-1','3380','?');
      DCL (#EXT,TPC,UTYPE,TRACKS,Q) FIXED BIN(15);
      DCL DSCBF3 CHAR(140);
      DDNAME='';
      RCSCAN=SCANNER(VE4,TEXT,VS4);
      IF RCSCAN>4 THEN DO;
         CALL PUTMSG('INFO COMMAND SYNTAX ERROR');
         RETURN;
         END;
      IF LENGTH(DDNAME)=0 THEN DO;
         IF OPENED THEN DDNAME=INDD;
            ELSE DO;
            CALL PUTMSG('INFO INVALID. NO FILE SELECTED');
            RETURN;
            END;
         CALL PUTMSG('DDNAME IS '××DDNAME);
         END;
      S99DDN=DDNAME;
      CALL S99VIN(S99DDN,S99DSN,S99MEM,S99MISC,
                  S99RC,S99ERROR,S99INFO);
      IF ^S99RCTEST('INFO') THEN RETURN;
      CALL S99DSTYP(SUBSTR(S99MISC,10,1),S99DDN);
      CALL S99DSORG(SUBSTR(S99MISC,4,2));
      CALL PUTMSG('DSNAME IS '××S99DSN);
      IF LENGTH(S99MEM)>0 THEN CALL PUTMSG('MEMBER NAME IS '××S99MEM);
      IF ATTFLG×INTFLG THEN RETURN;
      P2=ADDR(P);  /* OVERLAY I WITH P */
      I=16;  /* P->(LOC 16=A(CVT)) */
      CVTPTR=P1;  /* SET CVT POINTER */
      TCBWPTR=CVTTCBP;  /* SET POINTER TO TCB WORDS */
      TCBPTR=TCBWCURR;  /* SET POINTER TO CURRENT TCB */
      TIOTPTR=TCBTIO;  /* SET POINTER TO TIOT */
      DDPTR=ADDR(TIODDENT);  /* SET POINTER TO FIRST DD ENTRY */
      P2=ADDR(DDPTR);
      DO WHILE(TIOELNGH^='00000000'B);
      IF TIOEDDNM=DDNAME THEN LEAVE;
      I=I+TIOELNGH;
      END;
      IF TIOELNGH='00000000'B THEN DO;
         CALL PUTMSG('DDNAME NOT FOUND IN TIOT');
         RETURN;
         END;
      UCBPTR=TIOTDD.TIODVENT(1).TIOEUCBA;  /* SET PTR TO UCB */
      IF SUBSTR(UNSPEC(UCBPTR),9)='0'B THEN RETURN;
      M='UNIT='××UCBNAME;
      UTYPE=UCBTYP4;  /* UNIT TYPE AS AN INTEGER */
      SELECT(UCBTYP3);
      WHEN('10000000'B) M=M××' (TAPE) VOL=SER='××SRTEVOLI;
      WHEN('01000000'B) M=M××' (COMMUNICATIONS)';
      WHEN('00100000'B) M=M××' (DASD/'××DASD(UTYPE)××') VOL=SER='××
                             SRTEVOLI;
      WHEN('00010000'B) M=M××' (DISPLAY)';
      WHEN('00001000'B) M=M××' (UNIT RECORD)';
      OTHERWISE ;
      END;
      CALL PUTMSG(M);
      IF ATTFLG×INTFLG THEN RETURN;
      IF VFLG THEN RETURN;  /* RETURN IF VSAM */
      IF UCBTYP3^='00100000'B THEN RETURN;  /* RETURN IF NOT DASD */
      DSNAME=S99DSN;
      VOLSER=SRTEVOLI;
      CALL DSCBF1(DSNAME,VOLSER,DSCB,ORC);
      IF ORC^=0 THEN DO;
         CALL PUTMSG('FORMAT1 DSCB NOT FOUND. OBTAIN RC='××CH(ORC));
         RETURN;
         END;
      DS1PTR=ADDR(DSCB);
      SELECT(SUBSTR(DS1RECFM,1,2));
      WHEN('10'B) RECFM='F';
      WHEN('01'B) RECFM='V';
      WHEN('11'B) RECFM='U';
      OTHERWISE RECFM='?';
      END;
      IF SUBSTR(DS1RECFM,4,1) THEN RECFM=RECFM××'B';
      IF SUBSTR(DS1RECFM,5,1) THEN RECFM=RECFM××'S';
      IF SUBSTR(DS1RECFM,3,1) THEN RECFM=RECFM××'T';
      SELECT(SUBSTR(DS1RECFM,6,2));
      WHEN('10'B) RECFM=RECFM××'A';
      WHEN('01'B) RECFM=RECFM××'M';
      OTHERWISE ;
      END;
      L=DS1LRECL; B=DS1BLKL;
      M='F1 DSCB: RECFM('××RECFM;
      M=M××') LRECL('××CH(L);
      M=M××') BLKSIZE('××CH(B)××')';
      CALL PUTMSG(M);
      TPC=DEVTRK(UTYPE);  /* TRACKS PER CYLINDER */
      #EXT=DS1NOEPV;  /* NO. EXTENTS IN THIS DATASET */
      TRACKS=0;
      DO Q=1 TO MIN(3,#EXT);
      TRACKS=TRACKS+(DS1EXT(Q).UPPER.CYL*TPC+DS1EXT(Q).UPPER.TRK)
                 +1-(DS1EXT(Q).LOWER.CYL*TPC+DS1EXT(Q).LOWER.TRK);
      END;
      IF #EXT>3 THEN DO;
      DS3PTR=ADDR(DSCBF3);
      CALL RDDSCB(DS1PTRDS,VOLSER,DSCBF3,ORC);
      IF ORC^=0 THEN GOTO NOF3;
      IF DS3FMTID='2' THEN DO;
         CALL RDDSCB(DS3PTRDS,VOLSER,DSCBF3,ORC);
         IF ORC^=0 THEN GOTO NOF3;
         END;
      DO Q=1 TO MIN(4,#EXT-3);
      TRACKS=TRACKS+(DS3EXTNT(Q).UPPER.CYL*TPC+DS3EXTNT(Q).UPPER.TRK)
                 +1-(DS3EXTNT(Q).LOWER.CYL*TPC+DS3EXTNT(Q).LOWER.TRK);
      END;
      END;
      IF #EXT>7 THEN DO;
      DO Q=1 TO #EXT-7;
      TRACKS=TRACKS+(DS3ADEXT(Q).UPPER.CYL*TPC+DS3ADEXT(Q).UPPER.TRK)
                 +1-(DS3ADEXT(Q).LOWER.CYL*TPC+DS3ADEXT(Q).LOWER.TRK);
      END;
      END;
      CALL PUTMSG('DATASET OCCUPIES '××VPCT××CH(TRACKS)××' TRACKS IN '
                  ××CH(#EXT)××' EXTENTS');
      RETURN;
 NOF3: CALL PUTMSG('FORMAT3 DSCB NOT FOUND. OBTAIN RC='××CH(ORC));
      RETURN;
 VPCT: PROC RETURNS(CHAR(10) VAR);
      DCL TRKSIZE(15) FIXED BIN(31) INIT(3625,20483,4892,4984,2000,
          14136,14660,7294,13030,8368,19069,35616,13030,47476,0);
      DCL (PCT,BPT) FIXED BIN(31);
      IF ^(SUBSTR(DS1DSORG,2,1)×SUBSTR(DS1DSORG,7,1))
         ×DS1LSTAR=0×TRACKS=0 THEN RETURN('');
      BPT=TRKSIZE(UTYPE);  /* BYTES PER TRACK */
      PCT=(((DS1LSTAR+1)*BPT-MAX(DS1TRBAL,0))*100)/(TRACKS*BPT);
      RETURN(CH(PCT)××'% OF ');
      END VPCT;
 TIOTDISPLAY: ENTRY;
      P2=ADDR(P);
      I=16;
      CVTPTR=P1;
      TCBWPTR=CVTTCBP;
      TCBPTR=TCBWCURR;
      TIOTPTR=TCBTIO;
      CALL PUTMSG('JOB:'××TIOCNJOB××' STEP:'××TIOCSTP××
                  ' PROCSTEP:'××TIOCSTP2);
      DDPTR=ADDR(TIODDENT);
      P2=ADDR(DDPTR);
      DO WHILE(TIOELNGH^='00000000'B);
      IF SUBSTR(TIOEDDNM,1,1)^=LOW(1) THEN DO;
         /* FREE TIOT SPACE HAS X'00' IN FIRST BYTE OF DDNAME */
      IF ATTFLG×INTFLG THEN RETURN;
      UI=' ';
      DSNAME=' ';
      IF SUBSTR(TIOERLOC,11,1) THEN UI='*';  /* ALLOCATED TO TERMINAL */
      ELSE IF SUBSTR(TIOERLOC,15,1) THEN UI='JES';
      ELSE IF SUBSTR(TIOERLOC,12,1) THEN UI='DYNAM';
      ELSE DO;
           UCBPTR=TIOTDD.TIODVENT(1).TIOEUCBA;
           IF SUBSTR(UNSPEC(UCBPTR),9)^='0'B THEN DO;
              UI=UCBNAME;
              IF SUBSTR(SRTEJBNR,1,1) THEN LEAVE;  /* BIT FOR VIO */
              IF UCBTYP3='10000000'B×UCBTYP3='00100000'B
                 THEN UI=SRTEVOLI;  /* GET VOLSER FOR TAPE AND DASD */
              END;
           END;
      IF TIOEJFCB^='0'B&UI^='*' THEN DO;
         UNSPEC(SWAPTR)=(8)'0'B××TIOEJFCB;
         DSNAME=SWADSN;
         END;
      CALL PUTMSG(TIOEDDNM××' '××UI××' '××DSNAME);
      END;
      I=I+TIOELNGH;
      END;
      END INFO;
 VE7: PROC(KW#,VALUE) RETURNS(FIXED BIN(15));
      DCL (KW#,RC) FIXED BIN(15);
      DCL VALUE CHAR(*) VAR;
      RC=0;
      IF KW#=3 THEN GET STRING(VALUE) LIST(N);
               ELSE RC=99;
      RETURN(RC);
      END VE7;
 PANIC:
      RCSCAN=SCANNER(VE7,TEXT,VS7);  /* OBTAIN TIME INTERVAL */
      IF RCSCAN>0 THEN DO;
         CALL PUTMSG('INTERRUPT COMMAND SYNTAX ERROR');
         GOTO GET_COMMAND;
         END;
      P#=N;
      IF PTIME>0&P#>0 THEN DO;  /* CHANGE TIME INTERVAL */
         PTIME=P#;
         GOTO GET_COMMAND;
         END;
      IF PTIME=0&P#>0 THEN DO;  /* START SUBTASK */
         PTIME=P#;
         STOPPER='0'B;
         PRIORITY(T1)=1;
         CALL INT TASK(T1) EVENT(E1);
         GOTO GET_COMMAND;
         END;
      IF PTIME>0&P#=0 THEN DO;  /* STOP SUBTASK */
         STOPPER='1'B;
         WAIT(E1);
         PTIME=0;
         GOTO GET_COMMAND;
         END;
      GOTO GET_COMMAND;
 INT: PROC;  /* TIMER INTERRUPT SUBTASK */
      /* THE TIMER FIRES EVERY 30 SECONDS.
         IF DISABLED (IDLE='1'B), WE IGNORE THE INTERRUPT.
         IF THE REQUIRED TIME INTERVAL HAS EXPIRED, WE SET
         THE INTERRUPT FLAG AND DISABLE */
 DEL: DELAY(30000);  /* WAIT 30 SECONDS */
      IF STOPPER THEN RETURN;  /* TERMINATE IF STOP FLAG IS SET */
      IF IDLE THEN GOTO DEL;  /* IGNORE INTERRUPT IF DISABLED */
      TB=TIME;  /* COMPUTE CURRENT TIME */
      GET STRING(TB) EDIT(HB,MB,SB) ((3)F(2));
      TIMEB=HB*3600+MB*60+SB;
      IF TIMEB-TIMEA>PTIME THEN DO;  /* TEST TIME INTERVAL */
         IDLE='1'B;  /* DISABLE */
         INTFLG='1'B; /* SET INTERRUPT FLAG */
         END;
      GOTO DEL;
      END INT;
 VE4: PROC(KW#,VALUE) RETURNS(FIXED BIN(15));
      DCL (KW#,RC) FIXED BIN(15);
      DCL VALUE CHAR(*) VAR;
      RC=0;
      IF KW#=5 THEN DDNAME=VALUE;
               ELSE RC=99;
      RETURN(RC);
      END VE4;
 SETCOPY: PROC;
      DCL CFLAG BIT(1) INIT('0'B);
      ON UNDF(SYSOUT) BEGIN; CODE=ONCODE; GOTO OFAIL; END;
      DDNAME='';
      RCSCAN=SCANNER(VE5,TEXT,VS5);
      IF RCSCAN>0 THEN DO;
         CALL PUTMSG('SETCOPY COMMAND SYNTAX ERROR');
         RETURN;
         END;
      IF LENGTH(COPYDD)>0
         THEN DO;
              IF ALLOCATION(OUTREC)>0 THEN FREE OUTREC;
              CLOSE FILE(SYSOUT);
              END;
      COPYDD='';
      IF CFLAG THEN RETURN;
      OPEN FILE(SYSOUT) TITLE(DDNAME);
      COPYDD=DDNAME;
      M#=RECMAX(SYSOUT);
      ALLOCATE OUTREC CHAR(M#);
      RETURN;
 OFAIL: CALL PUTMSG('COPY FILE IS UNDEFINED. ONCODE='××CODE);
 VE5: PROC(KW#,VALUE) RETURNS(FIXED BIN(15));
      DCL (KW#,RC) FIXED BIN(15);
      DCL VALUE CHAR(*) VAR;
      RC=0;
      SELECT(KW#);
      WHEN(5) DDNAME=VALUE;
      WHEN(6) CFLAG='1'B;
      OTHERWISE RC=99;
      END;
      RETURN(RC);
      END VE5;
      END SETCOPY;
 COPY: PROC;
      IF LENGTH(COPYDD)=0 THEN DO;
         CALL PUTMSG('COPY INVALID. NO COPY FILE AVAILABLE.');
         IF AUTO THEN DO;
            AUTO='0'B;
            CALL PUTMSG('AUTOCOPY OPTION SUPPRESSED');
            END;
         RETURN;
         END;
      IF ^OPENED THEN DO;
         CALL PUTMSG('COPY INVALID. NO FILE SELECTED.');
         RETURN;
         END;
      IF REC#=0 THEN DO;
         CALL PUTMSG('COPY INVALID. RECORD COUNTER IS ZERO.');
         RETURN;
         END;
      IF FROM=1&TO=0&^(COMPRESS×EXPAND) THEN DO;
         OUTREC=DATA;
         WRITE FILE(SYSOUT) FROM(OUTREC);
         RETURN;
         END;
      L=LENGTH(DATA);
      IF FROM<1×FROM>L THEN F=1; ELSE F=FROM;
      IF TO<F THEN T=L; ELSE T=MIN(TO,L);
      IF ^(COMPRESS×EXPAND) THEN DO;
         OUTREC=SUBSTR(DATA,F,T-F+1);
         WRITE FILE(SYSOUT) FROM(OUTREC);
         RETURN;
         END;
      IF COMPRESS THEN DO;
         PP=T;
         DO WHILE(SUBSTR(DATA,PP,1)=CCHAR&(C#+F-1)<PP&F<PP);
         PP=PP-1;
         END;
         OUTREC=SUBSTR(DATA,F,PP-F+1);
         WRITE FILE(SYSOUT) FROM(OUTREC);
         RETURN;
         END;
      /* ASSUME EXPAND */
      IF E#=0 THEN E#=M#;
              ELSE E#=MIN(E#,M#);
      OUTREC=SUBSTR(DATA,F,T-F+1);
      IF E#>(T-F+1) THEN OUTREC=OUTREC××REPEAT(ECHAR,E#-T+F-2);
      WRITE FILE(SYSOUT) FROM(OUTREC);
      END COPY;
 COMP: PROC;
      IF EXPAND THEN DO;
         EXPAND='0'B;
         CALL PUTMSG('NOEXPAND OPTION FORCED');
         END;
      COMPRESS='1'B;
      IF LENGTH(TEXT)=0 THEN RETURN;
      RCSCAN=SCANNER(VE7,TEXT,VS7);
      IF RCSCAN>4 THEN DO;
         CALL PUTMSG('COMPRESS COMMAND SYNTAX ERROR');
         RETURN;
         END;
      IF N<1×N>32760 THEN DO;
         N=1;
         CALL PUTMSG('COMPRESS PARAMETER INVALID.  COMPRESS 1 USED.');
         END;
      C#=N;
      END COMP;
 EXP: PROC;
      IF COMPRESS THEN DO;
         COMPRESS='0'B;
         CALL PUTMSG('NOCOMPRESS OPTION FORCED');
         END;
      EXPAND='1'B;
      IF LENGTH(TEXT)=0 THEN RETURN;
      RCSCAN=SCANNER(VE7,TEXT,VS7);
      IF RCSCAN>4 THEN DO;
         CALL PUTMSG('EXPAND COMMAND SYNTAX ERROR');
         RETURN;
         END;
      IF N<0×N>32760 THEN DO;
         N=0;
         CALL PUTMSG('EXPAND PARAMETER INVALID.  EXPAND 0 USED.');
         END;
      E#=N;
      END EXP;
 SETCHAR: PROC(INCHAR);
      DCL INCHAR CHAR(1);
      DCL (VC,VC1) CHAR(10) VAR INIT('');
      DCL HEX BIT(1) INIT('0'B);
      RCSCAN=SCANNER(VE9,TEXT,VS9);
      IF RCSCAN>0 THEN DO;
         CALL PUTMSG('CCHAR/ECHAR INVALID PARAMETER');
         RETURN;
         END;
      IF HEX THEN DO;
                  IF ^HEXIN(VC,VC1) THEN DO;
                     CALL PUTMSG('CCHAR/ECHAR INVALID HEX STRING');
                     RETURN;
                     END;
                  INCHAR=VC1;
                  END;
             ELSE INCHAR=VC;
 VE9: PROC(KW#,VALUE) RETURNS(FIXED BIN(15));
      DCL (KW#,RC) FIXED BIN(15);
      DCL VALUE CHAR(*) VAR;
      RC=0;
      SELECT(KW#);
      WHEN(1) GET STRING(VALUE) LIST(VC);
      WHEN(3) VC=VALUE;
      WHEN(4) DO;
              VC=VALUE;
              IF LENGTH(VC)>1 THEN DO;
                 IF SUBSTR(VALUE,1,1)='"'&
                    SUBSTR(VALUE,LENGTH(VALUE),1)='"' THEN DO;
                    VC=SUBSTR(VALUE,2,LENGTH(VALUE)-2);
                    HEX='1'B;
                    END;
                 END;
              END;
      OTHERWISE RC=99;
      END;
      RETURN(RC);
      END VE9;
      END SETCHAR;
 SPIN: PROC(OP);
      DCL OP FIXED BIN(15);
      DCL CMDP CHAR(20) VAR INIT('FI(PDPRT) SYSOUT(A)');
      DCL (SPINDDN,SPINDSN,SPINDSG,SPINVOL) CHAR(8) VAR INIT('');
      IF OP>1&^PRTFLG THEN RETURN;
      SELECT(OP);
      WHEN(1) DO;  /* START - ALLOCATE PRINT FILE */
              CALL S99VAL(CMDP,SALRC,S99RC,S99ERROR,S99INFO,
                          SPINDDN,SPINDSN,SPINDSG,SPINVOL);
              PRTFLG='1'B;
              END;
      WHEN(2) DO;  /* RELEASE - CLOSE/FREE/ALLOCATE */
              CLOSE FILE(PDPRT);
              IF LENGTH(TEXT)=0 THEN TEXT='FI(PDPRT)';
              CALL S99FREE(TEXT,VUNRC,S99RC,S99ERROR,S99INFO);
              IF VUNRC>0
                 THEN CALL PUTMSG('PRINT COMMAND SYNTAX ERROR. '××
                                  'SCAN RC='××CH(VUNRC));
                 ELSE DO;
                      IF S99RCTEST('FREE') THEN DO;
                         CALL PUTMSG('PRINT RELEASED');
                         CALL S99VAL(CMDP,SALRC,S99RC,S99ERROR,S99INFO,
                                     SPINDDN,SPINDSN,SPINDSG,SPINVOL);
                         END;
                      END;
              END;
      WHEN(3) DO;  /* STOP - CLOSE AND FREE PRINT FILE */
              CLOSE FILE(PDPRT);
              TEXT='FI(PDPRT)';
              CALL S99FREE(TEXT,VUNRC,S99RC,S99ERROR,S99INFO);
              END;
      OTHERWISE  ;
      END;
      END SPIN;
 TODAY: PROC RETURNS(CHAR(7));
      DCL X CHAR(7) , N FIXED BIN(15) , MO CHAR(36);
      DCL Y CHAR(6);
      Y=DATE; GET STRING(Y) EDIT(N) (X(2),F(2));
      MO='JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC';
      SUBSTR(X,1,2)=SUBSTR(Y,5,2);
      SUBSTR(X,3,3)=SUBSTR(MO,3*N-2,3);
      SUBSTR(X,6,2)=SUBSTR(Y,1,2);
      RETURN(X);
      END TODAY;
 TIMEX: PROC RETURNS(CHAR(5));
      DCL T CHAR(9);
      T=TIME;
      RETURN(SUBSTR(T,1,2)××':'××SUBSTR(T,3,2));
      END TIMEX;
 EOJ:
      REVERT ERROR;
      IF PRTFLG THEN CALL SPIN(3);
      IF OPENED THEN CALL CLOSE;
      IF LENGTH(COPYDD)>0 THEN CLOSE FILE(SYSOUT);
      CALL PUTMSG('END OF JOB');
      IF TT='3270' THEN RC3270=IO3270(' ',2);
      END PDUMP;
