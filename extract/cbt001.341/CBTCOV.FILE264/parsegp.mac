 /* PARSEGP */
 /*
0*$.HE GENERALIZED SUBROUTINES - PARSEGP
0*$.HE GENERALIZED PARSE SUBROUTINE FOR GPPP
0*$.PL 55
0*$.PN 0
0*$.PA
0*$.SS
0*$.NF
0*$08/26/76
0*$AUTHOR:  HOWARD GILBERT, YALE COMPUTER CENTER
0*$         MODIFIED BY T. SMITH, KIM
0*$SOURCE MODULE NAME:  PARSEGP
0*$DOCUMENTATION ID:  0*$
0*$.FI L
0*$.SP 5
0*$PARSEGP IS THE PARSING SUBROUTINE USED BY THE GENERAL PURPOSE
0*$PREPROCESSOR.  IT IS USED IN GPPP TO PARSE A MACRO STATEMENT
0*$AND EXTRACT THE KEYWORDS AND POSITIONAL PARAMETERS.  IT WILL
0*$ALSO SERVE AS A GENERALIZED PARSER IN OTHER APPLICATIONS AS WELL.
0*$SEE THE DOCUMENTATION ON GPPP FOR A DETAILED DESCRIPTION OF THE
0*$KINDS OF PARAMETERS PARSEGP WILL HANDLE.
0*$.SP 1
0*$CALL FORMAT IS AS FOLLOWS:
0*$.SP 1
0*$CALL PARSEGP(STRING,PARMBLOK,POSITION,SPECIAL,SYNTAX);
0*$.SP 1
0*$WHERE -
0*$.SP 1
0*$STRING CHAR(*) VAR, CONTAINS THE STRING TO BE PARSED.
0*$.SP 1
0*$PARMBLOK IS A STRUCTURE OF THE FOLLOWING FORMAT:
0*$.SP 1
0*$.IN 5
0*$.NF
0*$DCL 1 PARMBLOK,
0*$ 2 KEYWORDS(*),
0*$     *** ONE ELEMENT IN THIS MINOR STRUCTURE
0*$     FOR EVERY POSSIBLE KEYWORD THAT COULD
0*$     APPEAR IN STRING.  THE CALLER IS
0*$     RESPONSIBLE FOR INITIALIZING ALL THE
0*$     ELEMENTS IN THIS MINOR STRUCTURE. ***
0*$   3 PARMNAMES CHAR(16) VAR,
0*$     *** EACH ELEMENT IS A KEYWORD ***
0*$   3 PNUM FIXED BIN(15,0),
0*$     *** INDEXES THE ELEMENT IN MINOR STRUCTURE
0*$     PARAMETERS, WHICH IS NEXT IN PARMBLOK,
0*$     THAT IS ASSOCIATED WITH THIS PARTICULAR
0*$     KEYWORD ***
0*$ 2 PARAMETERS(*),
0*$     *** ONE ELEMENT IN THIS MINOR STRUCTURE
0*$     FOR EVERY POSSIBLE PARAMETER, POSITIONAL
0*$     OR KEYWORD, THAT COULD APPEAR IN STRING.
0*$     PARAMETER(0) IS ASSOCIATED WITH ANY
0*$     LABEL (E.G. LAB:) FOUND AT THE BEGINNING
0*$     OF STRING.  PARAMETER(1) IS ASSOCIATED
0*$     WITH THE FIRST POSITIONAL PARAMETER,
0*$     AND SO ON UNTIL ALL POSITIONAL PARAMETERS
0*$     HAVE BEEN EXHAUSTED.  ELEMENTS FOR KEYWORD
0*$     PARAMETERS THEN FOLLOW. ***
0*$   3 PARMS CHAR(*) VAR,
0*$     *** EACH ELEMENT WILL BE SET BY PARSEGP
0*$     TO THE VALUE IN STRING ASSOCIATED WITH
0*$     A PARTICULAR PARAMETER.  IF A PARAMETER IS
0*$     NOT FOUND IN STRING, THE ELEMENT IN PARMS
0*$     ASSOCIATED WITH THAT PARAMETER WILL BE LEFT
0*$     ALONE.  THIS MEANS THAT YOU CAN INITIALIZE
0*$     THE ELEMENTS IN PARMS TO DEFAULT VALUES.
0*$     PARMS(0) IS ASSOCIATED WITH A LABEL.
0*$     IT WILL BE SET TO WHATEVER LABEL IS ON THE
0*$     MACRO CALL FOUND IN STRING.
0*$     IN THE CASE OF A POSITIONAL PARAMETER,
0*$     PARMS(N) IS SET TO THE VALUE FOUND IN STRING
0*$     (EXCEPT THAT THE PARENS SURROUNDING A LIST
0*$     WILL BE REMOVED).  IN THE CASE OF A KEYWORD,
0*$     IF THE KEYWORD DOESN'T REQUIRE A SUBFIELD,
0*$     PARMS(N) WILL BE SET TO THE KEYWORD ITSELF.
0*$     IF A SUBFIELD IS REQUIRED FOR A KEYWORD,
0*$     PARMS(N) WILL BE SET TO THE SUBFIELD VALUE
0*$     FOUND IN STRING.
0*$     ***
0*$   3 STATUS BIT(8) ALIGNED,
0*$     *** SHOULD BE SET BY THE CALLER BEFORE
0*$         CALLING PARSEGP.  THESE FLAGS INDICATE
0*$         THE TYPE OF EACH PARAMETER AS
0*$         FOLLOWS:
0*$
0*$         '1000....'B = PREPOSITION
0*$         '0100....'B = POSITIONAL
0*$         '0010....'B = ENDSCAN
0*$         '0001....'B = REQUIRED
0*$         '00001...'B = BIT (NO SUBFIELD)
0*$         '000001..'B = LIST
0*$         '00000001'B = SET BY TO PARSEGP
0*$                       IF PARAMETER IS FOUND
0*$                       IN STRING.
0*$         '.1......'B = APPLIES ONLY TO STATUS(0),
0*$                       AND INDICATES WHETHER OR
0*$                       NOT A LABEL IS OK ON THE
0*$                       MACRO CALL IN STRING.
0*$         '...1....'B = APPLIES ONLY TO STATUS(0),
0*$                       AND INDICATES WHETHER OR
0*$                       NOT A LABEL IS REQUIRED ON
0*$                       THE MACRO CALL IN STRING.
0*$
0*$
0*$     ***
0*$   3 SUBSCR FIXED BIN(15,0),
0*$     *** IF THE SUBSCRIPT OPTION APPLIES,
0*$     THIS FIELD WILL CONTAIN THE INDEX IN
0*$     MINOR STRUCTURE ARRAY PARAMETERS TO THE
0*$     ELEMENT ASSOCIATED WITH THE SUBSCRIPT
0*$     PARAMETER. ***
0*$   3 NAMEUSED CHAR(16) VAR;
0*$     *** IN THE CASE OF POSITIONAL PARAMETERS
0*$     THIS FIELD IS SET TO BLANKS.  IN THE
0*$     CASE OF KEYWORD PARAMETERS, NAMEUSED WILL
0*$     BE SET BY PARSEGP TO THE KEYWORD USED IN
0*$     STRING TO IDENTIFY THIS PARAMETER.  THIS COULD
0*$     BE USEFUL IF A KEYWORD HAS ONE OR MORE
0*$     ALIASES. ***
0*$.FI L
0*$.IN 0
0*$.SP 1
0*$POSITION FIXED BIN(15,0) TO BE SET BY PARSEGP TO THE POSITION
0*$IN STRING AT WHICH PARSING WAS TERMINATED.  IF ENDSCAN IS BEING
0*$USED, THIS OPERAND IS USEFUL FOR IDENTIFYING THE PART OF THE
0*$MACRO CALL WHICH HAS NOT YET BEEN PARSED.
0*$.SP 1
0*$SPECIAL BIT ALIGNED.  IF SPECIAL IS '0'B WHEN PARSEGP IS CALLED,
0*$IT ASSUMES THAT THE FIRST WORD IT ENCOUNTERS (OTHER THAN A
0*$LABEL), IS THE VERB.  FOR EXAMPLE, IF STRING IS SET TO
0*$'ALLOC FI(XYZ) DA(CNTL) SHR', AND SPECIAL='0'B, THEN "ALLOC" IS
0*$CONSIDERED TO BE THE VERB, AND "FI(XYZ)" IS CONSIDERED TO BE THE
0*$FIRST OPERAND.  IS SPECIAL='1'B IN THIS CASE, "ALLOC" WOULD BE
0*$CONSIDERED TO BE THE FIRST OPERAND.
0*$.SP 1
0*$SYNTAX ENTRY(CHAR(*) VAR,CHAR(8),FIXED BIN(15,0)).
0*$SYNTAX IS AN ENTRY POINT THAT PARSEGP WILL USE IF IT DISCOVERS A
0*$SYNTACTICAL ERROR WHEN PARSING STRING.  THE FIRST ARGUMENT,
0*$CHAR(*) VAR, WILL BE TEXT DESCRIBING THE ERROR.  'LABEL NOT
0*$SUPPORTED BY MACRO', AND 'SUBFIELD NOT ALLOWED' ARE EXAMPLES.
0*$THE SECOND ARGUMENT, CHAR(8), WILL BE AN ERROR MESSAGE NUMBER.
0*$'GPPP016I' AND 'GPPP008I' ARE EXAMPLES.  A COMPLETE TABLE OF
0*$ERROR MESSAGES AND NUMBERS IS LISTED BELOW.  THE THIRD ARGUMENT,
0*$FIXED BIN(15,0), SHOULD BE SET TO THE POSITION IN STRING WHERE
0*$THE ERROR WAS ENCOUNTERED.  NOTE THAT PARSEGP DOES NOT EXPECT
0*$CONTROL TO BE RETURNED FROM A CALL TO SYNTAX.
0*$.SP 1
0*$.IN 5
0*$LIST OF ERROR MESSAGES AND NUMBERS
0*$.SP 1
0*$.NF
0*$GPPP003I TOO MANY PARMS
0*$GPPP004I STATEMENT UNINTELLIGIBLE
0*$GPPP005I MISSING REQUIRED PARM
0*$GPPP006I PREMATURE KEYWORD <VALUE>
0*$GPPP007I UNRECOGNIZED KEYWORD <VALUE>
0*$GPPP008I <VALUE> SUBFIELD NOT ALLOWED
0*$GPPP009I IMPROPER POSITIONAL PARM
0*$GPPP010I INCOMPLETE PARAMETER
0*$GPPP011I IMPROPER LIST PARAMETER
0*$GPPP012I <VALUE> KEYWORD REQ
0*$GPPP013I DUPLICATE OR EXCLUSIVE KEYWORDS
0*$GPPP016I LABEL NOT SUPPORTED BY MACRO
0*$GPPP017I MISSING REQUIRED LABEL
0*$.IN 0
0*$.SP 1
0*$.FI L
 */
 PARSEGP:PROC(STRING,PARMBLOK,POSITION,SPECIAL,SYNTAX);
 DCL STRING CHAR(*) VAR;
 DCL POSITION FIXED BIN;
 DCL SPECIAL BIT ALIGNED;
 DCL RETCODE FIXED BIN;
 DCL 1 PARMBLOK,
         2 KEYWORDS(*),
              3 PARMNAMES CHAR(16) VAR,
              3 PNUM FIXED BIN,
         2 PARAMETERS(*),
              3 PARMS CHAR(*) VAR,
              3 STATUS BIT(8) ALIGNED,
              3 SUBSCR FIXED BIN,
              3 NAMEUSED CHAR(16) VAR;
 DCL SYNTAX ENTRY(CHAR(*) VAR, CHAR(8), FIXED BIN(15,0));
 DCL GETWORD ENTRY(CHAR(*) VAR, FIXED BIN(15,0), FIXED BIN(15,0))
   RETURNS(CHAR(1024) VAR);
 DCL OBJECT                       /* RETURN CODES FROM GETWORD/      */
         FIXED BIN STATIC INIT(0);/* GETTOKEN (VARIABLE OR NUMBER)   */
 DCL OPERATOR                     /* OPERATOR (OR SPECIALCHAR STRING)*/
         FIXED BIN STATIC INIT(1);/*                                 */
 DCL PSTRING                      /* (STRING) OR "STRING"            */
         FIXED BIN STATIC INIT(2);/*                                 */
 DCL QSTRING                      /* 'STRING'                        */
         FIXED BIN STATIC INIT(3);/*                                 */
 DCL KEYWORD                      /* STRING(                         */
         FIXED BIN STATIC INIT(4);/*                                 */
 DCL COMMA                        /* LONE COMMA (,)                  */
         FIXED BIN STATIC INIT(5);/*                                 */
 DCL SEMICOLON                    /* LONE SEMICOLON (;)              */
         FIXED BIN STATIC INIT(6);/*                                 */
 DCL EOS                          /* END OF STRING                   */
         FIXED BIN STATIC INIT(7);/*                                 */
 DCL GIBBERISH                    /* USUALLY UNCLOSED QUOTE × COMMENT*/
         FIXED BIN STATIC INIT(8);/*                                 */
 DCL PREP   BIT(8) ALIGNED INIT('1000'B) STATIC;
 DCL POSIT  BIT(8) ALIGNED INIT('0100'B) STATIC;
 DCL ENDSCN BIT(8) ALIGNED INIT('0010'B) STATIC;
 DCL REQ    BIT(8) ALIGNED INIT('0001'B) STATIC;
 DCL NOSUB  BIT(8) ALIGNED INIT('00001'B) STATIC;
 DCL LIST   BIT(8) ALIGNED INIT('000001'B) STATIC;
 DCL ISSET  BIT(8) ALIGNED INIT('00000001'B) STATIC;
 DCL (NEXTWORD,VALUE) CHAR(1024) VAR INIT('');
 DCL PARM# FIXED BIN;
 DCL POSPARM FIXED BIN INIT(1);
 DCL GOTAKEY BIT INIT('0'B);
 DCL LSTPOSITION FIXED BIN;
 NAMEUSED='';
 %SKIP;
         POSITION=0;
 MACN:
         NEXTWORD=GETWORD(STRING,POSITION,RETCODE);
         IF POSITION<LENGTH(STRING) THEN
            IF SUBSTR(STRING,POSITION+1,1)=':'
              THEN
                   DO;
                   IF (STATUS(0) & POSIT)='0'B THEN
                      CALL SYNTAX('LABEL NOT SUPPORTED BY MACRO',
                         'GPPP016I',POSITION+1);
                   CALL SETPARM(0,NEXTWORD);
                   POSITION=POSITION+1;
                   GO TO MACN;
                   END;
         IF (STATUS(0) & (REQ × ISSET))=REQ THEN
            CALL SYNTAX('MISSING REQUIRED LABEL','GPPP017I',1);
 %SKIP;
 PARMLOOP:
         IF SPECIAL THEN
            SPECIAL='0'B;
            ELSE NEXTWORD=GETWORD(STRING,POSITION,RETCODE);
         LSTPOSITION=POSITION-LENGTH(NEXTWORD)+1;
         IF POSPARM>HBOUND(PARMS,1) & RETCODE<SEMICOLON THEN
              CALL SYNTAX('TOO MANY PARMS','GPPP003I',LSTPOSITION);
         IF RETCODE=GIBBERISH THEN
 SYNERR:
            CALL SYNTAX('STATEMENT UNINTELLIGIBLE','GPPP004I',
                        LSTPOSITION);
         IF POSPARM>HBOUND(PARMS,1)
            THEN RETURN;
         IF STATUS(POSPARM) & ENDSCN THEN DO;
            POSITION=POSITION+1;
            RETURN;
            END;
         IF RETCODE=COMMA
            THEN DO;
               NEXTWORD=GETWORD(STRING,POSITION,RETCODE);
               IF RETCODE=GIBBERISH THEN
                  GO TO SYNERR;
            END;
         SELECT (RETCODE);
              WHEN (SEMICOLON,EOS)
                   DO;
                   IF POSPARM>HBOUND(STATUS,1) THEN RETURN;
                   IF (STATUS(POSPARM) & (POSIT × REQ))=(POSIT × REQ)
                   THEN CALL SYNTAX('MISSING REQUIRED PARM','GPPP005I',
                             LSTPOSITION);
                   RETURN;
                   END;
              WHEN (COMMA)
                   DO;
                   IF POSPARM<=HBOUND(STATUS,1)
                      THEN DO;
                         IF STATUS(POSPARM) & REQ THEN
                            CALL SYNTAX('MISSING REQUIRED PARM',
                               'GPPP005I',LSTPOSITION);
                         POSPARM=POSPARM+1;
                      END;
                   END;
              WHEN (KEYWORD)
                   DO;
                   IF (STATUS(POSPARM) & (POSIT×REQ))=(POSIT×REQ) THEN
                        DO;
                        IF SUBSCR(POSPARM)=0 THEN
                             CALL SYNTAX('PREMATURE KEYWORD '××NEXTWORD,
                                'GPPP006I',LSTPOSITION);
                        PARM#=SUBSCR(POSPARM);
                        CALL SETPARM(POSPARM,NEXTWORD);
                        POSPARM=POSPARM+1;
                        GO TO GOTPARM;
                        END;
                   GOTAKEY='1'B;
                        DO PARM#=1 TO HBOUND(PARMNAMES,1);
                        IF NEXTWORD=PARMNAMES(PARM#)
                             THEN GO TO GOTNAME;
                        END;
                   CALL SYNTAX('UNRECOGNIZED KEYWORD '××NEXTWORD,
                        'GPPP007I',LSTPOSITION);
 GOTNAME:
                   IF STATUS(PNUM(PARM#)) & NOSUB THEN
                      CALL SYNTAX(NEXTWORD××' SUBFIELD NOT ALLOWED',
                         'GPPP008I',LSTPOSITION);
                   NAMEUSED(PNUM(PARM#))=NEXTWORD;
                   PARM#=PNUM(PARM#);
 GOTPARM:
                   VALUE=GETWORD(STRING,POSITION,RETCODE);
                   IF RETCODE>QSTRING
                        THEN
                             CALL SYNTAX('INCOMPLETE PARAMETER',
                                      'GPPP010I',LSTPOSITION);
                   IF SUBSTR(VALUE,1,1)='(' THEN
                   CALL SETPARM(PARM#,SUBSTR(VALUE,2,LENGTH(VALUE)-2));
                      ELSE CALL SETPARM(PARM#,VALUE);
                   END;
              WHEN (PSTRING,QSTRING)
                   DO;
                   IF (STATUS(POSPARM) & POSIT)='0'B × GOTAKEY THEN
                        CALL SYNTAX('IMPROPER POSITIONAL PARM',
                             'GPPP009I',LSTPOSITION);
                   IF (STATUS(POSPARM) & LIST)=LIST &
                      SUBSTR(STRING,POSITION,1)='"' THEN
                         CALL SYNTAX('IMPROPER LIST PARAMETER',
                            'GPPP011I',LSTPOSITION);
                   IF SUBSTR(STRING,POSITION,1)^=')' THEN
                      CALL SETPARM(POSPARM,NEXTWORD);
                      ELSE CALL SETPARM(POSPARM,SUBSTR(NEXTWORD,2,
                         LENGTH(NEXTWORD)-2));
                   POSPARM=POSPARM+1;
                   END;
              WHEN (OBJECT)
                   DO;
                   IF (STATUS(POSPARM) & (POSIT×REQ))^=(POSIT×REQ) THEN
                        DO PARM#=1 TO HBOUND(PARMNAMES,1);
                        IF NEXTWORD=PARMNAMES(PARM#)
                             THEN
                                  DO;
                                  IF STATUS(PNUM(PARM#)) & REQ THEN
                                     CALL SYNTAX(NEXTWORD××' KEYWORD REQ
 UIRES SUBFIELD',                       'GPPP012I',LSTPOSITION);
                                  NAMEUSED(PNUM(PARM#))=NEXTWORD;
                                  PARM#=PNUM(PARM#);
                                  GOTAKEY='1'B;
                                  IF STATUS(PARM#) & PREP
                                       THEN
                                            GO TO GOTPARM;
                                  CALL SETPARM(PARM#,'');
                                  GO TO PARMLOOP;
                                  END;
                        END;
                   IF (STATUS(POSPARM) & POSIT)='0'B × GOTAKEY THEN
                        CALL SYNTAX('UNRECOGNIZED KEYWORD '××NEXTWORD,
                             'GPPP007I',LSTPOSITION);
                   CALL SETPARM(POSPARM,NEXTWORD);
                   POSPARM=POSPARM+1;
                   END;
         END;
         GOTO PARMLOOP;
 SETPARM: PROC(I,VAL);
         DCL I FIXED BIN;
         DCL VAL CHAR(*) VAR;
         IF STATUS(I)&ISSET THEN
              CALL SYNTAX('DUPLICATE OR EXCLUSIVE KEYWORDS',
                   'GPPP013I',LSTPOSITION);
         STATUS(I)=STATUS(I)×ISSET;
         IF VAL='' THEN
           PARMS(I)=' ';
           ELSE PARMS(I)=VAL;
         END;
 END PARSEGP;
