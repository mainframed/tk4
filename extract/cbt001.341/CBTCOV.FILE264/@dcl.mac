 /* @DCL */
 %NOPRINT;
 /*
0*$.HE GENERALIZED SUBROUTINES - @DCL
0*$.HE PLI PREPROCESSOR TEXT
0*$.HE ASSOCIATIVE ARRAYS
0*$.PL 55
0*$.PN 0
0*$.PA
0*$.SS
0*$.NF
0*$01/23/81
0*$AUTHOR:  T. SMITH
0*$SOURCE MODULE NAME:  @DCL
0*$DOCUMENTATION ID:  0*$
0*$.FI L
0*$.SP 5
0*$THIS PREPROCESSOR PROCEDURE IMPLEMENTS ASSOCIATIVE ARRAYS IN PL/I.
0*$THESE ARE ARRAYS OF UP TO 15 DIMENSIONS, EACH DIMENSION BEING
0*$INDEXED EITHER NUMERICALLY OR ASSOCIATIVELY, AND HAVING UNLIMITED
0*$AND DYNAMICALLY CHANGING BOUNDS.
0*$AN INDEX VALUE FOR A NUMERICALLY INDEXED DIMENSION CAN BE
0*$ANY INTEGER FROM -2147483647 TO 2147483647.  AN INDEX VALUE FOR
0*$AN ASSOCIATIVELY INDEXED DIMENSION CAN BE A CHARACTER STRING UP TO
0*$32767 BYTES IN LENGTH CONTAINING ANY EBCDIC CHARACTERS.
0*$.SP 1
0*$ASSOCIATIVE ARRAYS ARE DECLARED USING THE @DCL STATEMENT, WHICH
0*$MUST BE INCLUDED IN YOUR PROGRAM VIA THE %INCLUDE STATEMENT FROM
0*$SYS2.MACLIB.  IN EACH @DCL STATEMENT, THE SYMBOL 'N' IS USED TO
0*$DENOTE NUMERICALLY INDEXED DIMENSIONS, AND THE SYMBOL 'A' TO DENOTE
0*$ASSOCIATIVELY INDEXED DIMENSIONS.  AN EXAMPLE FOLLOWS:
0*$.SP 1
0*$@DCL (MYARRAY,A,N) TYPE(CHARACTER) MAX(256);
0*$.SP 1
0*$IN THE ABOVE @DCL STATEMENT THE ASSOCIATIVE ARRAY NAMED MYARRAY IS
0*$DEFINED TO HAVE TWO DIMENSIONS INDEXED ASSOCIATIVELY, AND
0*$NUMERICALLY, RESPECTIVELY.  ELEMENTS OF THE ARRAY WILL BE CHARACTER
0*$STRINGS OF A MAXIMUM LENGTH OF 256 CHARACTERS.  OTHER VALID TYPES
0*$THE ARRAY COULD ALSO HAVE BEEN DEFINED WITH ARE 'TYPE(FIXED)',
0*$INDICATING FIXED BIN(31,0) ARRAY ELEMENTS, OR 'TYPE(FLOAT)',
0*$INDICATING FLOAT DEC(6) ARRAY ELEMENTS, OR 'TYPE(PTR)', INDICATING
0*$POINTER VARIABLES AS ELEMENTS.
0*$.SP 1
0*$NOTE THAT THE @DCL STATEMENTS GENERATE SOME PL/I STATEMENTS TO
0*$PERFORM INITIALIZATION FUNCTIONS.  THEREFORE, YOU SHOULD PLACE
0*$@DCL STATEMENTS IN YOUR PROGRAM SO THAT FLOW OF CONTROL FALLS
0*$THROUGH THEM ONCE AT THE START OF EXECUTION.
0*$.SP 1
0*$THE @DCL STATEMENT ALSO GENERATES A SERIES OF NESTED PL/I
0*$PROCEDURES YOU CAN INVOKE IN YOUR PROGRAM TO PERFORM SUCH FUNCTIONS
0*$AS ASSIGNMENT TO THE ARRAY, AND REFERRAL TO AN ELEMENT.
0*$THESE PROCEDURE NAMES ALL HAVE THE FORM NAME_FUNCTION, WHERE
0*$'NAME' IS THE NAME OF THE ARRAY AS SPECIFIED IN THE @DCL STATEMENT,
0*$AND 'FUNCTION' IS THE NAME IDENTIFYING THE FUNCTION PERFORMED BY
0*$THAT PROCEDURE.
0*$FOLLOWING IS A LIST OF THESE PROCEDURES, INDICATING WHAT FUNCTION IS
0*$PERFORMED BY EACH:
0*$.SP 1
0*$NAME_ASSIGN:  PROC(P1,P2,...,PN,PLAST);  CALL THIS PROCEDURE TO
0*$ASSIGN A VALUE TO AN ELEMENT OF THE ARRAY.  PARAMETERS P1 THRU PN
0*$ARE INDEX VALUES, AND PLAST IS THE VALUE TO BE ASSIGNED TO THE
0*$ELEMENT.  IN THE CASE OF THE SAMPLE @DCL STATEMENT SHOWN ABOVE,
0*$FOR EXAMPLE, THE FOLLOWING STATEMENT MIGHT BE USED:
0*$.SP 1
0*$CALL MYARRAY_ASSIGN('ANGELA',23,'BEAUTIFUL');
0*$.SP 1
0*$NAME_REFER:  PROC(P1,P2,...PN) RETURNS(DEPENDS_ON_ARRAY);  THIS
0*$PROCEDURE IS A FUNCTION THAT RETURNS THE VALUE OF THE ELEMENT
0*$ASSOCIATED WITH THE SPECIFIED INDICES.  A SAMPLE INVOCATION:
0*$.SP 1
0*$LOOKS = MYARRAY_REFER('ANGELA',23);
0*$.SP 1
0*$NAME_FIRST:  PROC RETURNS(DEPENDS_ON_ARRAY);
0*$.IN 0
0*$NAME_NEXT:  PROC RETURNS(DEPENDS_ON_ARRAY);
0*$.IN 0
0*$NAME_FIRST RETURNS THE VALUE FOR THE FIRST ELEMENT OF THE ARRAY,
0*$AND NAME_NEXT RETURNS THE VALUE FOR THE NEXT SEQUENTIAL ELEMENT
0*$OF THE ARRAY FOLLOWING THE LAST ONE REFERENCED.  IN THE FOLLOWING
0*$EXAMPLE, THESE FUNCTIONS ARE USED TO PRINT OUT THE INDICES
0*$AND VALUE OF EACH ELEMENT OF MYARRAY:
0*$.SP 1
0*$.NF
0*$ON CONDITION(ASAREOF) GO TO EOJ;
0*$*** MYARRAY_NEXT WILL SIGNAL CONDITION ***
0*$*** ASAREOF WHEN THE LAST ELEMENT HAS  ***
0*$*** BEEN RETURNED.                     ***
0*$DO LOOKS=MYARRAY_FIRST REPEAT MYARRAY_NEXT;
0*$  PUT SKIP LIST(@INDEX(MYARRAY,1,A),
0*$    @INDEX(MYARRAY,2,N),
0*$    LOOKS);
0*$  *** THE ABOVE ALSO ILLUSTRATES HOW TO GET AT THE   ***
0*$  *** MOST RECENTLY USED INDICES FOR EACH DIMENSION. ***
0*$  *** @INDEX ACCEPTS THREE PARAMETERS, THE FIRST     ***
0*$  *** BEING THE NAME OF THE ARRAY, THE SECOND THE    ***
0*$  *** NUMBER OF THE DIMENSION FOR WHICH THE INDEX    ***
0*$  *** VALUE IS TO BE OBTAINED, AND THE THIRD IS ONE  ***
0*$  *** OF THE TWO LETTERS 'A' OR 'N', INDICATING      ***
0*$  *** WHETHER THE DESIRED DIMENSION IS INDEXED       ***
0*$  *** ASSOCIATIVELY OR NUMERICALLY.  SEE ALSO MEMBER ***
0*$  *** ASARDCL OF SYS2.MACLIB FOR MORE DETAILS ON THE ***
0*$  *** INTERNAL STRUCTURE OF ASSOCIATIVE ASSAYS.**
0*$  END;
0*$EOJ:;
0*$.FI L
0*$.SP 1
0*$NAME_NULL:  PROC(P1,...,PN) RETURNS(BIT(1));  WHEN YOU INVOKE
0*$NAME_REFER, IF THE ELEMENT DOESN'T CURRENTLY EXIST, A NULL STRING
0*$('') WILL BE RETURNED IF TYPE IS CHARACTER, AND 0 OR 0E WILL BE
0*$RETURNED IF TYPE IS FIXED OR FLOAT.  IF YOU REALLY WANT TO FIND
0*$OUT IF THE ELEMENT EXISTS, INVOKE NAME_NULL, WHICH WILL RETURN
0*$'1'B IF IT DOES NOT EXIST, AND '0'B OTHERWISE.
0*$.SP 1
0*$NAME_LSUB:  PROC(COUNT,P1,...,PN) RETURNS(FIXED BIN(31,0));
0*$.SP 1
0*$NAME_HSUB:  PROC(COUNT,P1,...,PN) RETURNS(FIXED BIN(31,0));
0*$.SP 1
0*$TO FACILITATE INDEXING NUMERICALLY SUBSCRIPTED ARRAYS, THESE
0*$TWO FUNCTIONS (HSUB AND LSUB) RETURN THE HIGHEST AND LOWEST
0*$SUBSCRIPTS FOR WHICH ARRAY ELEMENTS EXIST.  THIS FACILITY IS
0*$PROVIDED FOR NUMERICALLY SUBSCRIPTED DIMENSIONS OF AN ARRAY ONLY.
0*$IF NO ELEMENTS EXIST THEN HSUB AND LSUB RETURN THE VALUES
0*$ZERO AND ONE RESPECTIVELY.  WHEN INVOKING HSUB OR LSUB, THE
0*$FIRST PARAMETER (CALLED COUNT ABOVE) MUST BE THE NUMBER OF THE
0*$DIMENSION FOR WHICH A COUNT IS TO BE RETURNED.  THE ASSOCIATED
0*$INDEX IN P1,...,PN WILL BE IGNORED, ALTHOUGH IT MUST BE SUPPLIED
0*$FOR CONSISTENCY OF FORMAT.
0*$EXAMPLE:
0*$.SP 1
0*$.IN 5
0*$.NF
0*$@DCL (B,N) TYPE(FIXED); *** B_HSUB(1,0)=0, B_LSUB(1,0)=1 ***
0*$CALL B_ASSIGN(1,4);     *** B_HSUB(1,0)=1, B_LSUB(1,0)=1 ***
0*$CALL B_ASSIGN(1,5);     *** B_HSUB(1,0)=2, B_LSUB(1,0)=1 ***
0*$CALL B_ASSIGN(-1,0);    *** B_HSUB(1,0)=2, B_LSUB(1,0)=-1 ***
0*$.SP 1
0*$.IN 0
0*$.FI L
0*$NOTE:  IF @DCL IS TO BE USED IN A PLIST, @DCL SHOULD BE INCLUDED
0*$IN THE FOLLOWING SEQUENCE:
0*$.SP 1
0*$.IN 5
0*$.NF
0*$%INCLUDE CPINIT1;
0*$%@STRIPSW='N';
0*$%@STRIPI='Y';
0*$%@NULLBSW='N';
0*$%INCLUDE CPINIT2;
0*$%INCLUDE @DCL;
0*$@DCL OPERANDS ETC...
   */
   %INCLUDE ASARDCL;
   %INCLUDE @STRIP;
   % INCLUDE @NUMSTR;
   %DCL @DCL ENTRY;
 %@DCL:  PROC(PN,P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11,P12,P13,P14,P15,
  TYPE,MAX) STATEMENT RETURNS(CHAR);
   DCL (PN,P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11,P12,P13,P14,P15,
     TYPE,MAX) CHAR;
   DCL (R,W,ATY,EC,DLM,TNU,TNA,IPTS,IPTE,PR,PL,PAC,RT,PD,PP,RD) CHAR;
   DCL (IX,I) FIXED;
   R='';
   ATY='';
   IF TYPE=''
     THEN TYPE='C'; /* DEFAULT TYPE IS CHARACTER */
     ELSE IF TYPE^='CHARACTER' & TYPE^='FLOAT' & TYPE^='FIXED' &
       TYPE^='PTR'
       THEN RETURN('ERROR - INVALID TYPE');
       ELSE IF TYPE='CHARACTER'
         THEN TYPE='C';
         ELSE IF TYPE='FLOAT'
           THEN TYPE='E';
           ELSE IF TYPE='PTR'
             THEN TYPE='P';
             ELSE TYPE='F';
   IF MAX=''
     THEN MAX='256'; /* DEFAULT MAX IS 256 */
   /* NOW FIND # DIMENSIONS - PREPROCESSOR IS DUMB */
   IX = 0;
   DO I = 15 TO 1 BY -1;
     IF I=1 THEN W = P1; ELSE
     IF I=2 THEN W = P2; ELSE
     IF I=3 THEN W = P3; ELSE
     IF I=4 THEN W = P4; ELSE
     IF I=5 THEN W = P5; ELSE
     IF I=6 THEN W = P6; ELSE
     IF I=7 THEN W = P7; ELSE
     IF I=8 THEN W = P8; ELSE
     IF I=9 THEN W = P9; ELSE
     IF I=10 THEN W = P10; ELSE
     IF I=11 THEN W = P11; ELSE
     IF I=12 THEN W = P12; ELSE
     IF I=13 THEN W = P13; ELSE
     IF I=14 THEN W = P14;
     ELSE W = P15;
     W=@STRIP(W);
     IF W^=''
       THEN IF W^='N' & W^='A'
         THEN RETURN('ERROR - ONLY ''N'' OR ''A'' CAN BE USED FOR'××
           ' ADDRESS TYPE, OPERAND='''××W××'''');
         ELSE DO;
           IF IX=0
             THEN IX=I;
           ATY=W××ATY;
           END;
     END;
   /* IX NOW = # DIMENSIONS IN ASSOC. ARRAY BEING DEFINED. */
   R='DCL 1 '××PN××', 2 ASARFIRST PTR, 2 ASARHDFL BIT(8) INIT(''0''B)'××
     ', 2 ASARDTY CHAR(1) INIT('''××
     TYPE××'''), 2 ASARDCT FIXED BIN(15,0) INIT('××IX××
     '), 2 ASARARY('××IX××'), 3 ASARATY CHAR(1) INIT(';
   DO I = 1 TO IX;
     R=R××''''××SUBSTR(ATY,I,1)××'''';
     IF I < IX
       THEN R=R××',';
     END;
   R=R××'), 3 ASARDPT PTR, 3 ASARIPT PTR;'××
     PN××'.ASARFIRST=NULL;'××
     PN××'.ASARDPT,'××PN××'.ASARIPT=NULL;';
   /* NOW GENERATE THE TEXT FOR THE INTERFACE PROCEDURES */
   PD = ''; /* DECLARES FOR PARAMETERS */
   PP = ''; /* PARAMETER NAMES FOR PROC STATEMENTS */
   IPTS=''; /* INITIALIZATION OF ASARIPT */
   IPTE='';/* FREES FOR CSELS POINTED TO BY ASARIPT */
   RD=''; /* DECLARE FOR RET */
   DLM = '';
   DO I = 1 TO IX;
     TNU=@NUMSTR(I);
     TNA='P'××TNU;
     PP=PP××DLM××TNA;
     DLM=',';
     IF SUBSTR(ATY,I,1)='A'
       THEN DO;
         PD=PD××' DCL '××TNA××' CHAR(*);';
         IPTS=IPTS××'L=LENGTH('××TNA××'); ALLOC CSEL SET('××PN××
           '.ASARIPT('××TNU××')); '××PN××'.ASARIPT('××TNU××')->CSESTR='
           ××TNA××';';
         IPTE=IPTE××'FREE '××PN××'.ASARIPT('××TNU××')->CSEL;';
         END;
       ELSE DO;
         PD=PD××' DCL '××TNA××' FIXED BIN(31,0);';
         IPTS=IPTS××'UNSPEC('××
         PN××'.ASARIPT('××TNU××'))=UNSPEC('××TNA××');';
         END;
     END;
   /* NOW SET PR TO RETURN CLAUSE OF PROC STMT FOR NAME_REFER, */
   /* AND PL TO DCL FOR PLAST FOR NAME_ASSIGN, */
   /* AND PAC TO CALL STMTS FOR NAME_ASSIGN, */
   /* AND RT TO RETURN STMTS FOR NAME_REFER. */
   /* RD IS DECLARATION OF RET */
   RT='IF I<='××PN××'.ASARDCT THEN RETURN(';
   IF TYPE='C'
     THEN DO;
       RD='';
       PR='RETURNS(CHAR('××@NUMSTR(MAX)××'));';
       PL='DCL PLAST CHAR(*);';
       PAC='L=LENGTH(PLAST); ALLOC CSEL; CSESTR=PLAST; '××
         'CALL SETASAR(ADDR('××PN××'),CSELP);';
       RT=RT××'''''); ELSE RETURN('××PN××'.ASARDPT('××PN××
         '.ASARDCT)->ASAREL->CSESTR);';
       END;
     ELSE DO;
       IF TYPE='P'
         THEN PAC='CALL SETASAR(ADDR('××PN××'),PLAST);';
         ELSE PAC='UNSPEC(WRKP)=UNSPEC(PLAST);'××
           'CALL SETASAR(ADDR('××PN××'),WRKP);';
       IF TYPE='F'
         THEN DO;
           PR='RETURNS(FIXED BIN(31,0));';
           PL='DCL PLAST FIXED BIN(31,0);';
           RD='DCL RET FIXED BIN(31,0);';
           RT=RT××'0); ELSE DO; RET='××PN××'.ASARDPT('××
             PN××'.ASARDCT)->ASARFEL; RETURN(RET); END;';
           END;
         ELSE IF TYPE='E'
           THEN DO;
             PR='RETURNS(DEC FLOAT(6));';
             PL='DCL PLAST DEC FLOAT(6);';
             RD='DCL RET DEC FLOAT(6);';
             RT=RT××'0); ELSE DO; RET='××PN××'.ASARDPT('
               ××PN××'.ASARDCT)->ASAREEL; RETURN(RET); END;';
             END;
           ELSE IF TYPE='P'
             THEN DO;
               RD='';
               PR='RETURNS(PTR);';
               PL='DCL PLAST PTR;';
               RT=RT××'NULL); ELSE RETURN('××PN××'.ASARDPT('××PN××
                 '.ASARDCT)->ASAREL);';
               END;
       END;
   /* NOW ADD TO R TEXT FOR NAME_ASSIGN */
   R=R××PN××'_ASSIGN:  PROC('××PP××',PLAST);'××PD××PL××
     'DCL WRKP PTR;'××IPTS××PAC××IPTE××'END '××PN××'_ASSIGN;';
   /* NOW ADD TO R TEXT FOR NAME_REFER */
   R=R××PN××'_REFER: PROC('××PP××')'××PR××PD××RD××
     'DCL I FIXED BIN(15,0);'××IPTS××
     'I=REFASAR(ADDR('××PN××'));'××IPTE××RT××
     'END '××PN××'_REFER;';
   /* NOW ADD TO R TEXT FOR NAME_NULL */
   R=R××PN××'_NULL: PROC('××PP××') RETURNS(BIT(1));'××PD××
     'DCL I FIXED BIN(15,0);'××IPTS××
     'I=REFASAR(ADDR('××PN××'));'××IPTE××
     'IF I<='××PN××'.ASARDCT THEN RETURN(''1''B); ELSE RETURN(''0''B);'
     ××'END '××PN××'_NULL;';
   /* NOW ADD TO R TEXT FOR NAME_LSUB */
   R=R××PN××'_LSUB: PROC(COUNT,'××PP××') RETURNS(FIXED BIN(31,0));'××
     PD××'DCL COUNT FIXED BIN(31,0);'××
     'DCL I FIXED BIN(15,0);'××IPTS××
     'RETURN(LSUASAR(ADDR('××PN××'),COUNT));'××
     'END '××PN××'_LSUB;';
   /* NOW ADD TO R TEXT FOR NAME_HSUB */
   R=R××PN××'_HSUB: PROC(COUNT,'××PP××') RETURNS(FIXED BIN(31,0));'××
     PD××'DCL COUNT FIXED BIN(31,0);'××
     'DCL I FIXED BIN(15,0);'××IPTS××
     'RETURN(HSUASAR(ADDR('××PN××'),COUNT));'××
     'END '××PN××'_HSUB;';
   /* NOW ADD TO R TEXT FOR NAME_NEXT */
   R=R××PN××'_NEXT: PROC '××PR××RD××'DCL I FIXED BIN(15,0);'××
     'CALL NXTASAR(ADDR('××PN××'));IF '××PN××'.ASARDPT('××PN××
     '.ASARDCT)=NULL THEN DO;I=0;SIGNAL CONDITION(ASAREOF);'××
     'END; ELSE I='××PN××'.ASARDCT+1;'××RT××
     ' END '××PN××'_NEXT;';
   /* NOW ADD TO R TEXT FOR NAME_FIRST */
   R=R××PN××'_FIRST: PROC '××PR××PN××'.ASARDPT(*)=NULL;RETURN('××
     PN××'_NEXT); END '××PN××'_FIRST;';
   RETURN(R);
   % END @DCL;
   %DCL @LSUB ENTRY;
 %@LSUB:  PROC(PN,P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11,P12,P13,P14,P15)
   STATEMENT RETURNS(CHAR);
   DCL (PN,P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11,P12,P13,P14,P15) CHAR;
   DCL I FIXED;
   DCL (W,COUNT,R,COMMA) CHAR;
   COMMA='';
   R='';
   DO I = 1 TO 15;
     IF I=1 THEN W = P1; ELSE
     IF I=2 THEN W = P2; ELSE
     IF I=3 THEN W = P3; ELSE
     IF I=4 THEN W = P4; ELSE
     IF I=5 THEN W = P5; ELSE
     IF I=6 THEN W = P6; ELSE
     IF I=7 THEN W = P7; ELSE
     IF I=8 THEN W = P8; ELSE
     IF I=9 THEN W = P9; ELSE
     IF I=10 THEN W = P10; ELSE
     IF I=11 THEN W = P11; ELSE
     IF I=12 THEN W = P12; ELSE
     IF I=13 THEN W = P13; ELSE
     IF I=14 THEN W = P14;
     ELSE W = P15;
     W=@STRIP(W);
     IF W^=''
       THEN DO;
         IF W='*'
           THEN DO;
             R=R××COMMA××'0';
             COUNT=@NUMSTR(I);
             END;
           ELSE R=R××COMMA××W;
         COMMA=',';
         END;
     END;
   RETURN(PN××'_LSUB(ADDR('××PN××'),COUNT'××R××')');
   %END @LSUB;
 %@HSUB:  PROC(PN,P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11,P12,P13,P14,P15)
   STATEMENT RETURNS(CHAR);
   DCL (PN,P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11,P12,P13,P14,P15) CHAR;
   DCL I FIXED;
   DCL (W,COUNT,R,COMMA) CHAR;
   COMMA='';
   R='';
   DO I = 1 TO 15;
     IF I=1 THEN W = P1; ELSE
     IF I=2 THEN W = P2; ELSE
     IF I=3 THEN W = P3; ELSE
     IF I=4 THEN W = P4; ELSE
     IF I=5 THEN W = P5; ELSE
     IF I=6 THEN W = P6; ELSE
     IF I=7 THEN W = P7; ELSE
     IF I=8 THEN W = P8; ELSE
     IF I=9 THEN W = P9; ELSE
     IF I=10 THEN W = P10; ELSE
     IF I=11 THEN W = P11; ELSE
     IF I=12 THEN W = P12; ELSE
     IF I=13 THEN W = P13; ELSE
     IF I=14 THEN W = P14;
     ELSE W = P15;
     W=@STRIP(W);
     IF W^=''
       THEN DO;
         IF W='*'
           THEN DO;
             R=R××COMMA××'0';
             COUNT=@NUMSTR(I);
             END;
           ELSE R=R××COMMA××W;
         COMMA=',';
         END;
     END;
   RETURN(PN××'_HSUB(ADDR('××PN××'),COUNT'××R××')');
   %END @HSUB;
   %DCL @INDEX ENTRY;
 %@INDEX:  PROC(PN,N,T) RETURNS(CHAR);
   DCL (PN,N,T,RET) CHAR;
   IF PN='' × N='' × T=''
     THEN RETURN('ERROR - 3 PARAMETERS ARE NEEDED');
   PN=@STRIP(PN);
   N=@STRIP(N);
   T=@STRIP(T);
   IF T^='A' & T^='N'
     THEN RETURN('ERROR - TYPE MUST BE A OR N');
   RET=PN××'.ASARDPT('××N××')->';
   IF T='A'
     THEN RETURN(RET××'ASARELIX->CSESTR');
     ELSE RETURN(RET××'ASARFES');
 %END @INDEX;
 %PRINT;
