*PROCESS CS(60);
 /* WTORMSG
0*$.HE GENERALIZED UTILITIES - WTORMSG
0*$.HE QUERY THE CONSOLE OPERATOR
0*$.PL 55
0*$.PN 0
0*$.PA
0*$.SS
0*$.NF
0*$10/20/79
0*$AUTHOR:  P. DIXON
0*$SOURCE MODULE NAME:  WTORMSG
0*$DOCUMENTATION ID:  0*$
0*$.FI L
0*$.SP 5
0*$THIS UTILITY PROGRAM PROVIDES THE USER WITH THE FACILITY FOR
0*$SENDING MESSAGE TO THE CONSOLE OPERATOR FROM HIS JOB, AND TO
0*$CONTROL SUBSEQUENT EXECUTION BY SETTING A RETURN CODE BASED
0*$ON A "YES" OR "NO" RESPONSE FROM THE OPERATOR.  THE RETURN CODE
0*$CAN BE TESTED BY SUBSEQUENT STEPS IN THE JOB TO CONTROL THEIR
0*$EXECUTION.
0*$.SP 1
0*$NOTE:  THE OPERATOR IS RESPONSIBLE FOR KEEPING TRACK OF A GREAT
0*$NUMBER OF CONSOLE MESSAGES.  DO NOT USE THIS PROGRAM UNLESS IT IS
0*$CRITICAL THAT YOU DO SO.
0*$.SP 1
0*$.NF
0*$.IN 5
0*$// EXEC PGM=WTORMSG,REGION=80K,
0*$// PARM='MESSAGE'
0*$//SYSPRINT DD SYSOUT=A
0*$//SYSIN DD *
0*$MESSAGE
0*$MESSAGE
0*$ .
0*$ .
0*$ .
0*$MESSAGE
0*$/*
0*$.IN 0
0*$.SP 1
0*$.FI L
0*$IF YOU HAVE ONLY ONE MESSAGE, YOU MAY ENTER IT VIA THE PARM FIELD AND
0*$OMIT THE SYSIN DATA SET.  ALSO, IF YOU HAVE MORE THAN ONE MESSAGE,
0*$YOU MAY OMIT THE PARM FIELD AND ENTER ALL MESSAGES IN THE SYSIN DATA
0*$SET.
0*$.SP 1
0*$AFTER THE PROGRAM HAS WRITTEN ALL OF THE MESSAGES YOU HAVE SPECIFIED,
0*$IT WILL WRITE THE FOLLOWING MESSAGE TO THE CONSOLE, AND WAIT FOR
0*$A RESPONSE FROM THE OPERATOR:
0*$.SP 1
0*$.IN 10
0*$XXXXXXXX - RESPOND YES OR NO
0*$.IN 0
0*$.SP 1
0*$XXXXXXXX IN THE ABOVE MESSAGE IS A CHARACTER STRING CONSISTING OF THE
0*$FIRST EIGHT CHARACTERS IN THE LAST MESSAGE YOU SPECIFIED.  THIS
0*$SHOULD BE IDENTIFYING CHARACTERS SO THAT THE CONSOLE OPERATOR CAN
0*$ASSOCIATE THE MESSAGE REQUIRING A RESPONSE WITH THE PRECEDING
0*$INFORMATION MESSAGES.
0*$.SP 1
0*$IF THE OPERATOR RESPONDS "YES" THE PROGRAM WILL SET A RETURN CODE
0*$OF 0.  A RETURN CODE OF 4 WILL BE SET FOR A RESPONSE OF "NO".
0*$.SP 1
0*$.CE 1
0*$EXAMPLE
0*$.SP 1
0*$SUPPOSE THAT YOU HAVE A JOB THAT CAUSES THE OPERATING SYSTEM TO
0*$FAIL WHENEVER IT RUNS.  TECHNICAL SUPPORT HAS SUGGESTED A POSSIBLE
0*$CORRECTION, AND YOU WANT TO MAKE A TEST RUN TO SEE IF IT WORKS.
0*$SO YOU CONTACT OPERATIONS AND SCHEDULE THE RUNNING OF YOUR JOB AT
0*$A NON-CRITICAL TIME.  BUT TO BE ABSOLUTELY CERTAIN THAT YOU TEST
0*$DOESN'T GET RUN AT THE WRONG TIME, YOU CAN INSERT THE FOLLOWING JCL
0*$AFTER THE JOB STATEMENT IN YOUR TEST DECK:
0*$.SP 1
0*$.IN 5
0*$.NF
0*$//CHECK EXEC PGM=WTORMSG,REGION=80K
0*$//SYSPRINT DD SYSOUT=A
0*$//SYSIN DD *
0*$SPECIAL - THIS JOB HAS CAUSED OS
0*$SPECIAL - TO FAIL IN THE PAST,
0*$SPECIAL - AND HAS BEEN SCHEDULED
0*$SPECIAL - TO RUN AT A NON-CRITICAL
0*$SPECIAL - TIME.  CAN YOU AFFORD
0*$SPECIAL - AN OS FAILURE AT THIS TIME?
0*$//STEP2 EXEC PGM=NONAME,
0*$// REGION=20K,COND=(0,EQ,CHECK)
0*$.SP 1
0*$.IN 0
0*$.FI L
0*$IN THIS EXAMPLE, IF THE OPERATOR RESPONDS "NO", YOUR TEST WILL ABORT
0*$IN STEP2 WITH AN 806 ABEND.  IF HE RESPONDS "YES", STEP2 WILL BE
0*$BYPASSED AND THE REST OF YOUR JOB WILL EXECUTE.
 */
1WTORMSG: /* WRITE MESSAGES TO OPERATOR AND CHECK REPLY */
          /* WRITTEN 10/22/79 BY PAUL DIXON             */
 PROCEDURE(PARM) OPTIONS(MAIN) REORDER;
0DCL PARM            CHAR(100) VARYING;
 DCL SYSIN           FILE RECORD INPUT ENV(FB RECSIZE(80) TOTAL);
 DCL (NULL,PLIRETC)  BUILTIN;
 DCL (SUBSTR,UNSPEC) BUILTIN;
 DCL MESSAGE_ID      CHAR(8) INIT('');
 DCL REPLY           CHAR(3) INIT('');
 DCL SYSIN_POINTER   POINTER INIT(NULL());
 DCL MESSAGE         CHAR(72) BASED(SYSIN_POINTER);
 DCL MORE_MESSAGES   ALIGNED BIT INIT('1'B);
 DCL GOOD_REPLY      ALIGNED BIT INIT('1'B);
0ON ENDFILE(SYSIN)       MORE_MESSAGES = '0'B;
 ON UNDEFINEDFILE(SYSIN) MORE_MESSAGES = '0'B;
0IF PARM ^= '' THEN
    DO;
       DISPLAY(PARM);
       MESSAGE_ID = SUBSTR(PARM××(7)' ',1,8);
    END;
 OPEN FILE(SYSIN);
 IF MORE_MESSAGES THEN READ FILE(SYSIN) SET(SYSIN_POINTER);
 DO WHILE(MORE_MESSAGES);
    DISPLAY(MESSAGE);
    MESSAGE_ID = SUBSTR(MESSAGE,1,8);
    READ FILE(SYSIN) SET(SYSIN_POINTER);
 END;
 CALL PLIRETC(8)  /* INDICATES NO MESSAGES PROVIDED IN PARM OR SYSIN */;
 IF MESSAGE_ID ^= '' THEN
    DO UNTIL(GOOD_REPLY);
       GOOD_REPLY = '1'B  /* PLAN ON GOOD REPLY */;
       DISPLAY(MESSAGE_ID××' -- REPLY YES OR NO') REPLY(REPLY);
       UNSPEC(REPLY) = UNSPEC(REPLY) × (3)'01000000'B  /* UPPER CASE */;
       SELECT(REPLY);
          WHEN('YES','Y  ') CALL PLIRETC(0);
          WHEN('NO ','N  ') CALL PLIRETC(4);
          OTHERWISE GOOD_REPLY = '0'B;
       END;
    END;
 CLOSE FILE(SYSIN);
 END WTORMSG;
