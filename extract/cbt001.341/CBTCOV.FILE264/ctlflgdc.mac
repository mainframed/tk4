.HE GENERALIZED SUBROUTINES - CTLFLGDC
.HE DEPENDENT JOB CONTOL
.PL 55
.PN 0
.PA
.SS
.NF
5/16/74
AUTHOR:  T. SMITH
SOURCE MODULE NAME:  CTLFLGDC
DOCUMENTATION ID:  NONE
.FI L
.SP 5
.CE 1
PURPOSE
.SP 1
THE SITUATION OFTEN ARISES IN WHICH A COLLECTION OF JOBS MUST
BE EXECUTED IN A SPECIFIC ORDER, AND TYPICALLY, THE COMPUTER OPERATOR
IS HELD RESPONSIBLE FOR MANUALLY ENSURING THE PROPER SEQUENCE OF
EXECUTION.  SUCH SYSTEMS ARE MORE SUSCEPTIBLE TO ERROR BECAUSE OF
THIS MANUAL INTERVENTION, AND IT WOULD BE BETTER IF
THEY COULD BE RUN AUTOMATICALLY.  THIS PAPER DOCUMENTS A
TECHNIQUE FOR PROGRAMMING AUTOMATIC CONTROL OF INTER-DEPENDENT JOBS.
.SP 1
THE TECHNIQUE INVOLVES THE USE OF A SMALL CONTROL FILE.
USING A STANDARD UTILITY, JOBS IN AN INTER-DEPENDENT
NETWORK CAN RECORD IN THIS CONTROL FILE
THE FACT THAT THEY HAVE SUCCESSFULLY EXECUTED.  ANOTHER UTILITY
PROGRAM CAN BE USED TO INTERROGATE THE CONTROL FILE TO DETERMINE
WHETHER ALL JOBS FOR WHICH DEPENDENT JOBS EXISTS HAVE EXECUTED.
BASED ON THE RESULTS OF THIS INTERROGATION, ANOTHER UTILITY CAN
BE EXECUTED TO CAUSE THE DEPENDENT JOB(S) TO BE READ INTO THE
QUEUE.
.SP 1
.CE 1
CONTROL FILE
.SP 1
THE CONTROL FILE IS A SEQUENTIAL FILE OF 80-COLUMN RECORDS.
THE FIRST RECORD IN THIS FILE CONTAINS 256 SWITCHES WHICH
CAN BE SET AND INTERROGATED BY THE UTILITY PROGRAMS "SETFLG"
"RSTFLG" AND "TSTFLG".
THE SWITCHES ARE REPRESENTED BEGINNING IN COLUMN 1 OF THE FIRST
RECORD AS A 64-COLUMN STRING OF EXTERNAL HEXADECIMAL DIGITS.  THAT IS,
IF YOU LISTED THE FILE DIRECTLY OUT ON THE PRINTER, AND YOU READ
223100000...00, THEN SWITCHES TWO, SIX, TEN, ELEVEN AND FIFTEEN WOULD
BE ON.
.SP 1
.CE 1
EXTERNAL HEXADECIMAL
.SP 1
"EXTERNAL HEXADECIMAL" IS EXPLAINED IN DETAIL HERE.  IF YOU FEEL
YOU UNDERSTAND EXTERNAL HEX, THEN SKIP TO THE HEADING "SYMBOLIC
NAMES" BELOW.
.SP 1
TO BETTER UNDERSTAND HOW THE SWITCHES ARE REPRESENTED IN THE
CONTROL FILE, CONSIDER THE FIRST CARD OF THIS FILE AS AN 80-COLUMN
CARD IMAGE.  ALL 256 SWITCHES ARE REPRESENTED ON THIS CARD BY THE
CHARACTERS PUNCHED IN COLUMNS 1 THRU 64.  THE CHARACTER PUNCHED
IN EACH COLUMN REPRESENTS THE SETTINGS OF  FOUR SWITCHES; THAT IS,
THE CHARACTER PUNCHED IN COLUMN 1 REPRESENTS SWITCHES 0, 1, 2, AND 3,
THE CHARACTER PUNCHED IN COLUMN 2 REPRESENTS SWITCHES 4, 5, 6, AND 7,
AND SO FORTH THROUGH COLUMN 64.  THE SETTINGS OF EACH OF THE FOUR
SWITCHES REPRESENTED BY A GIVEN CHARACTER PUNCHED IN THE CARD CAN BE
DETERMINED USING THE FOLLOWING TABLE:
.SP 1
.NF
.IN 20
           FIRST SWITCH SETTING
            SECOND SWITCH SETTING
CHARACTER    THIRD SWITCH SETTING
 PUNCHED      FOURTH SWITCH SETTING
    0      0000
    1      0001
    2      0010
    3      0011
    4      0100
    5      0101
    6      0110
    7      0111
    8      1000
    9      1001
    A      1010
    B      1011
    C      1100
    D      1101
    E      1110
    F      1111
    BLANK  0000
.IN 0
.SP 1
.FI L
NOW TRY AN EXAMPLE.  SUPPOSE THAT YOU PRINTED OUT THE FIRST RECORD
IN THE CONTROL FILE, AND IT READ AS INDICATED BELOW.  WHICH SWITCHES
SHOULD BE ON?
.SP 1
88A10
.SP 1
THE ANSWER IS SWITCHES ZERO, FOUR, EIGHT, TEN, AND FIFTEEN.
.SP 1
.SP 1
.CE 1
SYMBOLIC NAMES
.SP 1
SUBSEQUENT RECORDS IN THE CONTROL FILE CONTAIN SYMBOLIC NAMES
THAT CAN BE USED TO REFERENCE THE SWITCHES IN THE FIRST RECORD.
THE FIRST SYMBOLIC NAME REFERENCES THE FIRST SWITCH, THE SECOND
SYMBOLIC NAME, THE SECOND SWITCH, ETC.  EACH SYMBOLIC NAME
CAN CONTAIN ANY CHARACTERS EXCEPT BLANK, AND CAN BE UP TO 72 CHARACTERS
LONG.  A SYMBOLIC NAME CANNOT BE CONTINUED FROM ONE RECORD TO THE NEXT,
AND IS SEPARATED FROM ITS NEIGHBORS BY ONE OR MORE BLANKS.
.SP 1
.CE 1
INITIAL CREATION OF THE CONTROL FILE
.SP 1
THERE ARE SEVERAL WAYS IN WHICH THE CONTROL FILE CAN BE
CREATED INITIALLY.  TO DO SO IN BACKGROUND, YOU MIGHT USE
THE IBM UTILITY IEBGENER AS FOLLOWS:
.SP 1
.IN 5
.NF
// EXEC PGM=IEBGENER,REGION=80K
//SYSPRINT DD SYSOUT=A
//SYSIN DD DUMMY
//SYSUT2 DD DSN=MNEB.CONTROL,DISP=(NEW,CATLG),
// UNIT=3330,VOL=SER=XXXXXX,SPACE=(TRK,(1)),
// DCB=(LRECL=80,BLKSIZE=80,RECFM=F)
//SYSUT1 DD *
ALL BLANKS
JOBA JOBB JOBC JOBD JOBE JOBF JOBG JOBH
EXAMPLE_OF_A_SYMBOLIC_NAME_THAT_COULD_BE_VERY_DESCRIPTIVE
.IN 0
.FI L
.SP 1
IN THE ABOVE EXAMPLE, THE FIRST CARD IN THE SYSUT1 DATA SET
CAN BE EITHER ALL BLANKS, OR YOU MAY SPECIFIY AN INITIAL
SETTING FOR THE SWITCHES.  (NOTE: A BLANK IS CONSIDERED TO BE THE
SAME THING AS A HEX 0)  FOR EXAMPLE, IF THE CHARACTERS
"C1" WERE PLACED IN THIS CARD BEGINNING IN COLUMN 1, THEN
SWITCHES ZERO, ONE, AND SEVEN WILL HAVE BEEN INITIALIZED ON.
ALL OTHER SWITCHES WILL HAVE BEEN INITIALIZED OFF.  SUBSEQUENT
CARDS IN THE SYSUT1 DATA SET CONTAIN THE SYMBOLIC NAMES THAT
YOU CAN LATER USE TO REFERENCE SOME OF THE SWITCHES ON THE FIRST
CARD.  AS YOU CAN SEE FROM THE LAST SYMBOLIC NAME SPECIFIED, YOU
CAN BE AS DESCRIPTIVE AS YOU LIKE WITH YOUR NAMES.
.SP 1
YOU CAN ALSO CREATE A CONTROL FILE USING THE TSO EDIT COMMAND
AS FOLLOWS:
.IN 5
.NF
EDIT CONTROL DATA NEW LINE(80)
00010 ALL BLANKS
00020 JOBA JOBB JOBC JOBD JOBE JOBF JOBG JOBH
00030 EXAMPLE_OF_A_LONG_SYMBOLIC_NAME
00040 NULL LINE
EDIT
S
SAVED
END
.IN 0
.FI 6
.SP 1
.CE 1
CHANGING THE LIST OF SYMBOLIC NAMES
.SP 1
DURING THE LIFE OF A SYSTEM, YOU MIGHT WISH TO SPECIFY
ADDITIONAL SYMBOLIC NAMES, OR ALTER OLD ONES.  YOU CAN
ACCOMPLISH THIS IN BACKGROUND USING THE IEBUPDTE UTILITY
AS FOLLOWS:  SUPPOSE THE CONTROL FILE LOOKS LIKE THIS -
.SP 1
.IN 5
.NF
SEQ #     RECORD
CC 73-80  CC 1-72
00000010  CC12ABC00000000
00000020  JOBA JOBB JOBC JOBD JOBE JOBF JOBG JOBH
.IN 0
.FI L
.SP 1
THEN TO REPLACE SYMBOLIC_NAME "JOBG" WITH "NEW_SYMBOL"
THE FOLLOWING STEP SHOULD BE EXECUTED -
.SP 1
.IN 5
.NF
// EXEC PGM=IEBUPDTE,REGION=80K
//SYSPRINT DD SYSOUT=A
//SYSUT1 DD DSN=MNEB.CONTROL,DISP=SHR
 ./ CHANGE UPDATE=INPLACE
JOBA JOBB JBOC JOBD JOBE JOBF NEW_SYMBOL JOBH
.SP 1
.FI L
NOTE: SEQ# 00000020 SHOULD GO IN CC 73-80 IN THE ABOVE CARD.
.IN 0
.SP 1
THE SAME THING COULD BE ACCOMPLISHED USING TSO EDIT -
.SP 1
.IN 5
.NF
EDIT 'MNEB.CONTROL' CNTL
EDIT
C 20 /JOBG/NEW_SYMBOL/
S
SAVED
END
.SP 1
.IN 0
.FI L
.CE 1
HOW TO TURN SWITCHES ON AND OFF
.SP 1
THE UTILITY PROGRAMS "SETFLG" AND "RSTFLG" ARE USED TO
ALTER THE SETTING OF SWITCHES IN THE CONTROL FILE.
NOTE THAT IN ALL THE EXAMPLES GIVEN IN THE FOLLOWING TEXT,
DISP=SHR IS ALWAYS USED TO REFERENCE THE CONTROL FILE.  THIS CAN
BE DONE BECAUSE ALL OF THE UTILITY PROGRAMS USE THEIR OWN
INTERNAL ENQUEUE TO PREVENT SIMULTANEOUS UPDATES.
.SP 1
.CE 1
SETFLG
.SP 1
SETFLG CAN BE USED TO TURN ONE OR MORE SWITCHES ON OR OFF
IN THE CONTROL FILE.  SWITCHES CAN BE REFERENCED DIRECTLY IN THE
FORM OF A MASK, OR THEY MAY BE REFERENCED BY THEIR SYMBOLIC
NAMES.  TWO EXAMPLES ARE GIVEN BELOW, ONE USING A MASK TO
TURN ON SOME SWITCHES, AND ONE USING SYMBOLIC NAMES TO
TURN SOME SWITCHES OFF, AND OTHERS ON.
.SP 1
.IN 5
.NF
EXAMPLE #1
// EXEC PGM=SETFLG,REGION=80K,PARM=C1
//SYSPRINT DD SYSOUT=A
//CONTROL DD DSN=MNEB.CONTROL,DISP=SHR
.SP 1
.FI L
.IN 0
NOTE #1:  THE MASK IS SPECIFIED AS A STRING OF EXTERNAL
HEXADECIMAL DIGITS IN THE PARM FIELD ON THE EXEC CARD.
THE MASK IS USED ONLY TO TURN SWITCHES ON, AND WILL NOT
CAUSE ANY SWITCHES TO BE TURNED OFF.  IN THIS CASE, SWITCHES
ZERO, ONE, AND SEVEN WILL BE TURNED ON IN THE CONTROL FILE.
.SP 1
NOTE #2:  THE DISPOSITION REFERRING TO THE CONTROL FILE SHOULD
ALWAYS BE SHARE TO PREVENT DATA SET CONTENTION BETWEEN JOBS.
SETFLG DOES ITS OWN ENQUEUE ON THE CONTROL FILE TO
PREVENT AN ATTEMPT TO ALTER THE FILE SIMULTANEOUSLY
FROM TWO SEPARATE JOBS.
.SP 1
.NF
.IN 5
EXAMPLE #2
// EXEC PGM=SETFLG,REGION=80K
//SYSPRINT DD SYSOUT=A
//CONTROL DD DSN=MNEB.CONTROL,DISP=SHR
JOBA
^JOBB
.SP 1
.FI L
.IN 0
NOTE #1:  IN THIS EXAMPLE, THE SWITCHES TO BE ALTERED ARE
REFERENCED BY SYMBOLIC NAMES.  THESE SYMBOLIC NAMES ARE
SPECIFIED, ONE PER CARD, IN THE SYSIN DATA SET.  IF THE
SYMBOLIC NAME IS PRECEDED BY THE "^" SIGN, THE REFERENCED
SWITCH WILL BE TURNED OFF.  OTHERWISE, THE REFERENCED SWITCH
WILL BE TURNED ON.
.SP 1
NOTE #2:  IF A SYMBOLIC NAME IS NOT FOUND IN THE CONTROL
FILE, SETFLG WILL TERMINATE WITHOUT SETTING ANY SWITCHES
WITH A RETURN CODE OF 8.
.SP 1
.IN 0
.CE 1
RSTFLG
.SP 1
RSTFLG IS USED TO TURN OFF SWITCHES IN THE CONTROL FILE.  THE
SWITCHES TO BE TURNED OFF ARE SPECIFIED IN A MASK IN
THE PARM FIELD ON THE EXEC STATEMENT.  SYMBOLIC NAMES
CANNOT BE USED.
.SP 1
.IN 5
.NF
EXAMPLE:
// EXEC PGM=RSTFLG,REGION=80K,PARM=8801
//SYSPRINT DD SYSOUT=A
//CONTROL DD DSN=MNEB.CONTROL,DISP=SHR
.SP 1
.IN 0
.FI L
WHEN THE ABOVE JOB CONTROL IS EXECUTED, SWITCHES ZERO, FOUR
AND FIFTEEN WILL BE TURNED OFF IN THE CONTROL FILE.
.IN 0
.FI L
.SP 1
.CE 1
HOW TO TEST SWITCHES IN THE CONTROL FILE
.SP 1
THE UTILITY PROGRAM "TSTFLG" IS USED TO TEST THE CURRENT
SETTING OF SWITCHES IN THE CONTROL FILE.  AS IN THE CASE
WITH SETFLG, THE SWITCHES TO BE TESTED CAN BE SPECIFIED
EITHER IN A MASK, OR BY SYMBOLIC NAME.  THE FIRST EXAMPLE
BELOW ILLUSTRATES THE USE OF THE MASK, AND THE SECOND
EXAMPLE SYMBOLIC NAMES:
.SP 1
.IN 5
.NF
EXAMPLE #1
//TST EXEC PGM=TSTFLG,REGION=80K,PARM=0046
//SYSPRINT DD SYSOUT=A
//CONTROL DD DSN=MNEB.CONTROL,DISP=SHR
// EXEC JCLRDR,JOB=NEXTJOB,COND=(0,EQ,TST)
.SP 1
.FI L
.IN 0
WHEN THE ABOVE JOB CONTROL IS EXECUTED, SWITCHES NINE,
THIRTEEN, AND FOURTEEN WILL BE TESTED.  IF THEY ARE ALL ON,
THE RETURN CODE FROM STEP TST WILL BE ZERO.  IF ANY ONE OF
THE THREE SWITCHES TESTED IS NOT ON, THE RETURN
CODE WILL BE SET TO FOUR.
.SP 1
NOTE:  IN THIS EXAMPLE, THE PURPOSE FOR EXECUTING TSTFLG IN
THE FIRST STEP IS TO DETERMINE WHETHER THE SECOND STEP, WHICH
EXECUTES A PROCEDURE CALLED JCLRDR, SHOULD BE EXECUTED.  THE
PROCEDURE JCLRDR IS DOCUMENTED IN DETAIL IN ANOTHER PAPER, BUT
BRIEFLY, THIS PROCEDURE WILL CAUSE THE JCL FOR THE SPECIFIED
JOB TO BE READ INTO THE INPUT QUEUE.  THE JCL FOR THE JOB MUST
HAVE BEEN PREVIOUSLY STORED AS A MEMBER OF A CATALOGED
PARTITIONED DATA SET.  WHEN EXECUTING THE PROCEDURE, YOU SPECIFY
THE MEMBER NAME AS THE SYMBOLIC KEYWORD PARAMETER "JOB=" AND THE
PARTITIONED DATA SET NAME AS THE SYMBOLIC KEYWORD PARAMETER "LIB=".
IF YOU DON'T SPECIFY "LIB=" THE DEFAULT IS "SYS2.JOBPROC".
.IN 5
.SP 1
.NF
EXAMPLE #2
//TST EXEC PGM=TSTFLG,REGION=80K
//SYSPRINT DD SYSOUT=A
//CONTROL DD DSN=MNEB.CONTROL,DISP=SHR
JOBA × (JOBB & JOBC)
// EXEC JCLRDR,JOB=NEXTJOB,COND=(0,NE,TST)
.SP 1
.IN 0
.FI L
THE LOGICAL EXPRESSION IN THE SYSIN DATA SET IS EVALUATED
TO DETERMINE IF IT IS TRUE OR FALSE.  IF IT REDUCES TO THE
SINGLE VALUE 1, IT IS CONSIDERED TO BE TRUE, AND FALSE IF
IT REDUCES TO THE SINGLE VALUE 0.  THIS EXPRESSION CAN
BE CONTINUED ON AS MANY CARDS AS NECESSARY, AND CAN CONTAIN UP
TO 256 OPERATORS AND 256 OPERANDS.  THE ACCEPTABLE OPERATORS
ARE ^, ^=, =, &, ×, AND PREFIX ^.  THE ONLY ACCEPTABLE OPERAND IS
A SYMBOLIC NAME.  THE FOLLOWING PROCEDURE IS USED TO EVALUATE
THE LOGICAL EXPRESSION:
.IN 5
.SP 1
1.  EACH SYMBOLIC NAME IS REPLACED WITH THE VALUE OF ITS
CORRESPONDING SWITCH IN THE CONTROL FILE.
.SP 1
2. THE LOGICAL OPERATIONS OF THE SAME PRIORITY ARE PERFORMED
LEFT TO RIGHT, EXCEPT
PARENTHISIZED PORTIONS ARE EVALUATED BEFORE THE REST OF THE
TERMS.  IF A SEQUENCE OF PARENTHESIZED TERMS APPEARS WITHIN
ANOTHER PARENTHESIZED SEQUENCE, THE INNERMOST SEQUENCE IS
EVALUATED FIRST.
.SP 1
3.  THE PRIORITY OF THE OPERATORS IS AS FOLLOWS:  PREFIX ^
IS PERFORMED BEFORE INFIX ^, OR ^=, (NOTE: INFIX ^ AND ^= PERFORM
THE SAME OPERATION) WHICH ARE PERFORMED BEFORE =, WHICH IS
PERFORMED BEFORE &, WHICH IS PERFORMED BEFORE ×.
.SP 1
.IN 0
IF THE EXPRESSION IS DETERMINED TO BE TRUE, THE RETURN CODE
IS SET TO ZERO, AND IF FALSE, THE RETURN CODE IS SET TO 4.
IF ANY SYMBOLIC NAME IS NOT FOUND IN THE CONTROL FILE, THE
RETURN CODE WILL BE SET TO 8.
THUS IN THIS EXAMPLE, "NEXTJOB" WILL NOT BE READ INTO THE QUEUE
UNLESS EITHER "JOBB" AND "JOBC" HAVE RUN, OR "JOBA" HAS RUN.
.SP 1
.CE 1
INVOKING SETFLG AND TSTFLG UNDER THE SAME ENQUEUE
.SP 1
SUPPOSE YOU HAVE A SYSTEM IN WHICH JOBS A AND B CAN RUN IN ANY
ORDER, BUT BOTH OF THEM MUST BE RUN BEFORE JOB C.  YOU MIGHT DO
THE FOLLOWING IN ORDER TO SCHEDULE THE RUNNING OF JOB C AT
THE CORRECT TIME AUTOMATICALLY:
.SP 1
.IN 5
1.  SET UP A CONTROL FILE WITH ALL SWITCHES INITIALIZED TO THE
OFF POSITION (SEE PREVIOUS EXAMPLE).
.SP 1
3.  ADD THE FOLLOWING JOB CONTROL TO THE END OF THE JCL FOR
JOB C.
.IN 10
.NF
//RESET EXEC PGM=SETFLG,REGION=80K
//SYSPRINT DD SYSOUT=A
//CONTROL DD DSN=SAMPLE.CONTROL,DISP=SHR
^JOBA
^JOBB
.SP 1
.FI L
.IN 5
3.  PUT THE JOB CONTROL TO RUN JOB C IN SYS2.JOBPROC
UNDER THE MEMBER NAME JOBC.
.SP 1
4.  ADD THE FOLLOWING JOB CONTROL TO THE JCL FOR JOB A.
.SP 1
.IN 10
.NF
//SET EXEC PGM=SETFLG,REGION=80K
//SYSPRINT DD SYSOUT=A
//CONTROL DD DSN=MNEB.CONTROL,DISP=SHR
JOBA
//TST EXEC PGM=TSTFLG,REGION=80K
//SYSPRINT DD SYSOUT=A
//CONTROL DD DSN=MNEB.CONTROL,DISP=SHR
JOBA & JOBB
// EXEC JCLRDR,JOB=JOBC,COND=(0,NE,TST)
.SP 1
.IN 5
.FI L
5.  ADD THE FOLLOWING JOB CONTROL TO THE JCL FOR JOBB.
.SP 1
.IN 10
.NF
//SET EXEC PGM=SETFLG,REGION=80K
//SYSPRINT DD SYSOUT=A
//CONTROL DD DSN=MNEB.CONTROL,DISP=SHR
JOBB
//TST EXEC PGM=TSTFLG,REGION=80K
//SYSPRINT DD SYSOUT=A
//CONTROL DD DSN=MNEB.CONTROL,DISP=SHR
JOBA & JOBB
// EXEC JCLRDR,JOB=JOBC,COND=(0,NE,TST)
.SP 1
.IN 0
.FI L
THERE IS ONE CONDITION UNDER WHICH THE ABOVE SYSTEM WILL NOT
RUN CORRECTLY; THAT IS, IT IS POSSIBLE FOR JOBC TO BE READ IN
TWICE.  THIS WOULD HAPPEN IF THE STEPS NAMED "SET" IN BOTH
JOBA AND JOBB COMPLETED BEFORE EITHER OF THE STEPS NAMED "TST".
TO PREVENT SUCH AN ERROR, THE SYSTEM SHOULD BE CHANGED TO EMPLOY
A FACILITY OF THE SETFLG UTILITY
WHEREBY THE TSTFLG UTILITY CAN BE INVOKED BEFORE SETFLG
DEQUEUES FOR EXCLUSIVE ACCESS TO THE CONTROL FILE.
SETFLG WILL INVOKE TSTFLG IN THIS MANNER WHEN IT ENCOUNTERS
A CARD IMAGE HAVING THE FOLLOWING FORMAT IN THE SYSIN DATA SET:
.SP 1
.IN 5
CALL TSTFLG;
.SP 1
.IN 0
THE WORD "CALL" MUST BEGIN IN COLUMN 1 AND MUST BE FOLLOWED BY
EXACTLY ONE BLANK AND THE CHARACTERS "TSTFLG;".  THE REST OF
THE CARD MUST BE BLANK.
ANY SUBSEQUENT CARD IMAGES IN THE SYSIN DATA SET WILL BE READ BY
THE TSTFLG UTILITY, AND THE RETURN CODE WILL BE SET ACCORDINGLY.
HERE FOLLOWS THE JCL FOR JOBS "JOBA" AND "JOBB" PROPERLY
ALTERED:
.SP 1
.IN 10
.NF
//* JCL FOR JOBA
//SET EXEC PGM=SETFLG,REGION=80K
//SYSPRINT DD SYSOUT=A
//CONTROL DD DSN=MNEB.CONTROL,DISP=SHR
JOBA
CALL TSTFLG;
JOBA & JOBB
// EXEC JCLRDR,JOB=JOBC,COND=(0,NE,SET)
.SP 1
//* JCL FOR JOBB
//SET EXEC PGM=SETFLG,REGION=80K
//SYSPRINT DD SYSOUT=A
//CONTROL DD DSN=MNEB.CONTROL,DISP=SHR
JOBB
CALL TSTFLG;
JOBA & JOBB
// EXEC JCLRDR,JOB=JOBC,COND=(0,NE,SET)
.SP 1
.IN 0
.FI L
