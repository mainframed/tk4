   /* COPYRIGHT 1983 BY THOMAS GLEN SMITH */
   /* ABE059 - TRANSPOSE SUBCOMMAND */
   %INCLUDE ABESUB;
 ABESUB(ABE059) PARS(01) CHECK(YES);
   %INCLUDE ABESUBA;
   DCL 1 LRN_STRUCTURE BASED(LRNPTR),
   %INCLUDE ABELRN;
   %INCLUDE ABELRNA;

   DCL MAXLEN ENTRY(CHAR(*) VAR)
     RETURNS(FIXED BIN(15,0));
   DCL AXIS CHAR(1) INIT('\');
   DCL 1 STR BASED(STRP),
     2 (DIM1,DIM2,CHARLEN) FIXED BIN(15,0),
     2 ARY(I REFER(DIM1),J REFER(DIM2)) CHAR(RH_LEN REFER(CHARLEN));
   DCL (SAVPTR,DELPTR,ADDPTR,ORGPTR) PTR;
   DCL 1 NEWHDR, /* QUEUE OF TRANSFORMED RECORDS */
     2 LSTNEW PTR,
     2 NXTNEW PTR;

   LSTNEW=ADDR(NEWHDR);
   NXTNEW=ADDR(NEWHDR);

   /* 1         4      */
   /* TRANSPOSE <AXIS> */
   IF PARY(1)^=''
     THEN AXIS=PARY(1);
   IF AXIS^='/'&AXIS^='\'&AXIS^='-'&AXIS^='×'
     THEN DO;
       MSGDATA='AXIS MUST BE /, \, -, OR ×';
       RHRC=8;
       RETURN;
       END;
   N=RH_NCOLS;
   IF RH_L1>RH_L2
     THEN DO;
       I=RH_L1;
       RH_L1=RH_L2;
       RH_L2=I;
       END;

   /* NOW SET M TO THE NUMBER OF ROWS(RECORDS) IN ORIGINAL MATRIX */
   M=0;
   DO FOREVER=1 REPEAT FOREVER;
     CALL #ABELSP(RHHDRPT,LRNPTR); /* GET NEXT FROM-SEGMENT */
     IF LRN_STRUCTURE.LRN_BUFP=NULL
       THEN LEAVE; /* ALL DONE */
     IF LRN_CURCOL=1
       THEN M=M+1;
     END;
   IF M=0
     THEN DO;
       MSGDATA='AT LEAST ONE ROW(RECORD) MUST BE IN LINE RANGE';
       RHRC=8;
       RETURN;
       END;
   IF PARY(2)^=''
     THEN P=PARY(2); /* SUBGROUP NUMBER */
     ELSE P=M; /* DEFAULT TO 1 SUBGROUP */

   /* NOW CHECK TO ENSURE WORK NEEDS TO BE DONE */
   SELECT(AXIS);
     WHEN('×') IF N=1
       THEN RETURN;
     WHEN('-') IF P=1
       THEN RETURN;
     OTHERWISE IF P=1 & N=1
       THEN DO;
         RHRC=0;
         RETURN;
         END;
     END; /* SELECT */

   /* NOW ALLOCATE WORKING MATRIX */
   SELECT(AXIS);
     WHEN('×','-') DO;  /* OUTPUT MATRIX WILL BE MXN */
       I=P;
       J=N;
       END;
     OTHERWISE DO; /* FOR '/' '\', OUTPUT MATRIX WILL BE NXM */
       I=N;
       J=P;
       END;
     END; /* SELECT */
   ALLOCATE STR;
   DO I=1 TO DIM1;
     DO J=1 TO DIM2;
       ARY(I,J)='';
       END;
     END;

   /* NOW COPY RECORDS TO WORKING MATRIX AND DELETE THEM */
   Z=0;
   DO UNTIL(Z=1);
     ILUP: DO I=1 TO P; /* I=ROW */
       DO K=1 TO N; /* K=COL */
         CALL #ABELSP(RHHDRPT,LRNPTR); /* GET NEXT FROM-SEGMENT */
         IF LRN_STRUCTURE.LRN_BUFP=NULL
           THEN Z=1; /* ALL DONE */
         IF Z=1
           THEN LEAVE ILUP; /* ALL DONE */
         SELECT(AXIS);
           WHEN('-') ARY(P-I+1,K)    =LSPBUF;
           WHEN('×') ARY(I,N-K+1)    =LSPBUF;
           WHEN('\') ARY(K,I)        =LSPBUF;
           WHEN('/') ARY(N-K+1,P-I+1)=LSPBUF;
           OTHERWISE;
           END; /* SELECT */
         SUBSTR(RECFLGS,5,1)='1'B; /* TELL ABELSP TO DELETE */
         END;
       END;
     /* NOW ADD REARRANGED DATA TO QUEUE OF TRANSFORMED RECORDS */
     IF ^(Z=1 & I=1 & K=1)
       THEN DO;
         ADDPTR=LSTNEW;
         IF ADDPTR=ADDR(NEWHDR)
           THEN SEQ=1;
           ELSE SEQ=-1;
         DO I=1 TO DIM1;
           BUF='';
           DO J=1 TO DIM2;
             BUF=BUF××ARY(I,J);
             ARY(I,J)='';
             END;
           CALL #ADD(RHPTR,RHHDRPT,ADDPTR,ADDPTR,SEQ,BUF,0);
           SEQ=-1;
           END;
         END;
     END;

   /* NOW ADD REARRANGED DATA TO CURRENT DATA SET */
   ORGPTR=RECPTR;
   I=MIN(RH_L1,RH_L2);
   IF I=0
     THEN ADDPTR=HDPTR; /* TO BE ADDED AT TOP OF DATA SET */
     ELSE DO;
       CALL #MD(RHPTR,RHHDRPT,I);
       ADDPTR=RECPTR;
       END;
   NXTNEW->LSTPTR=ADDPTR;
   LSTNEW->NXTPTR=ADDPTR->NXTPTR;
   ADDPTR->NXTPTR=NXTNEW;
   LSTNEW->NXTPTR->LSTPTR=LSTNEW;
   LAST=99999999;
   CALL #RESEQ(RHPTR,RHHDRPT,ADDPTR,'NOSAVE','NORENUM',LAST);
   IF ORGPTR=HDPTR
     THEN CALL #MD(RHPTR,RHHDRPT,0);
     ELSE CALL #NC(RHPTR,ORGPTR);
   RHRC = 0;
   FREE STR;

   END ABE059;
