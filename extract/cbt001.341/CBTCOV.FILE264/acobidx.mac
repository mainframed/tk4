*$.HE GENERALIZED SUBROUTINES - ACOBIDX
*$.HE FIND A VARIABLE LENGTH STRING IN A VARIABLE LENGTH STRING - COBOL
*$.PL 55
*$.PN 0
*$.PA
*$.SS
*$.NF
*$02/27/85
*$AUTHOR: R. FLOOD
*$SOURCE MODULE NAME: ACOBIDX
*$DOCUMENTATION ID: *$
*$.FI L
*$.SP 5
*$THIS ROUTINE IS INTENDED FOR USE BY COBOL PROGRAMS ONLY. IT
*$PROVIDES A MEANS OF DETERMINING IF A VARIABLE LENGTH STRING OF
*$UP TO 256 BYTES IS IN ANOTHER STRING OF UP TO 8192 BYTES.
*$.SP 1
*$.IN 4
*$CALL 'ACOBIDX' USING W-PARM-AREA.
*$.SP 1
*$.IN 0
*$W-PARM-AREA
*$.IN 4
*$            AN 01 LEVEL AREA IN WORKING STORAGE IS PASSED TO
*$THIS MODULE WITH THE FIELDS LISTED BELOW DEFINED WITHIN IT.
*$.IN 0
*$RETURN CODE
*$.IN 4
*$PIC X(1).   AN 05 LEVEL CHARACTER VARIABLE WHICH THIS MODULE
*$WILL PUT AN "F" IN IF THE DATA IS FOUND OR AND "N" IN IF IT IS
*$NOT FOUND.
*$.IN 0
*$ARGUMENT 1 LENGTH
*$.IN 4
*$PIC S9(4) COMP. AN 05 LEVEL HALFWORD BINARY VARIABLE
*$WHICH CONTAINS THE LENGTH OF THE ARGUMENT WHICH WILL BE LOOKED
*$FOR. IT MUST BE GREATER THAN 0 AND LESS THAN 257 OR THIS MODULE
*$WILL RETURN AN "N".
*$.IN 0
*$ARGUMENT 1
*$.IN 4
*$PIC X(256)    . AN 05 LEVEL CHARACTER STRING THAT IS EXACTLY 256
*$BYTES LONG. THIS CONTAINS THE DATA TO BE LOOKED FOR. THIS MODULE
*$USES THIS DATA STARTING IN POSTION 1 OF THE STRING FOR A LENGTH
*$DETERMINED BY THE ABOVE ARGUMENT 1 LENGTH FIELD TO SEARCH FOR THE
*$DATA IN ARGUMENT 2.
*$.IN 0
*$ARGUMENT 2 LENGTH
*$.IN 4
*$PIC S9(4) COMP. AN 05 LEVEL HALFWORD BINARY VARIABLE
*$WHICH CONTAINS THE LENGTH OF THE ARGUMENT WHICH WILL BE SEARCHED
*$IN. IT MUST BE GREATER THAN 0 AND LESS THAN 8193 OR THIS MODULE
*$WILL RETURN AN "N". AN "N " WILL ALSO BE RETURNED IF THIS LENGTH
*$IS LESS THAN THE ARGUMENT 1 LENGTH.
*$.IN 0
*$ARGUMENT 2
*$.IN 4
*$PIC X(???)    . AN 05 LEVEL CHARACTER STRING THAT IS FROM 1 TO
*$8192 BYTES LONG. UNPREDICTABLE RESULTS MAY OCCUR IF THIS VARIABLE
*$IS DECLARED TO BE LESS THAN THE ARGUMENT 2 LENGTH. THIS AREA IS
*$SEARCHED USING THE ARGUMENT 1 DATA STARTING IN POSTION 1 OF THIS AREA
*$IF THE ARGUMENT 1 DATA IS NOT FOUND, THE MODULE WILL TRY TO FIND IT
*$STARTING IN POSITION 2 AND SO ON UNTIL A MATCH IS FOUND OR THE NEXT
*$COMPARE WOULD BE BEYOND THE END OF ARGUMENT 2.
*$.NF
*$.SP 1
*$.IN 0
*$SUGGESTIONS:
*$.IN 4
*$- IF YOU HAVE MORE THAN ONE STRING IN YOUR PROGRAM
*$ THAT YOU WISH TO SEARCH AND THEY HAVE DIFFERENT
*$ LENGTHS, YOU CAN CAN USE THE SAME PARAMETER AREA IN
*$ EITHER CASE AND DECLARE THE ARGUMENT 2 VARIABLE TO
*$ BE BIG ENOUGH FOR EITHER OF THEM.
*$.SP 1
*$.IN 0
*$EXAMPLE1: IF YOU WISH TO SEARCH FOR " MAX " YOU SHOULD
*$    ASSIGN A LENGTH OF 5 TO THE ARGUMENT 1 LENGTH. ONLY
*$    THOSE STRINGS THAT ARE PLACED IN THE ARGUMENT 2 AREA
*$    WHICH CONTAIN THOSE 5 CHARACTERS IN ORDER ANYWHERE IN
*$    THEMSELVES WILL CUASE A "F" (FOUND) TO BE RETURNED.
*$    IN THIS CASE WE ARE SEARCING FOR A STAND-ALONE WORD.
*$.SP 1
*$EXAMPLE2: IF YOU WISH TO SEARCH FOR "MAX" YOU SHOULD
*$    ASSIGN A 3 TO THE ARGUMENT 1 LENGTH. ALL STRINGS
*$    THAT CONTAIN THOSE 3 CHARACTERS IN ORDER ANYWHERE
*$    IN THEMSELVES WILL CAUSE A "F" (FOUND) TO BE RETURNED.
*$    IN THIS CASE THE 3 LETTERS MAY BE IMBEDED IN A WORD.
*$.SP 1
*$EXAMPLE3: IF YOU WISH TO SEARCH FOR " MAX" YOU SHOULD
*$    ASSIGN A 4 TO THE ARGUMENT 1 LENGTH. ALL STRINGS
*$    THAT CONTAIN THOSE 4 CHARACTERS IN ORDER ANYWHERE
*$    IN THEMSELVES WILL CAUSE A "F" (FOUND) TO BE RETURNED.
*$    IN THIS CASE THE LETTERS "MAX" MUST BEGIN A WORD.
ACOBID   TITLE 'ACOBIDX - INDEX FUNCTION CALLED BY A COBOL PROGRAM'
         PUNCH './ ADD NAME=ACOBID'
*******************************************************************
* MODULE ACOBIDX - INDEX FUNCTIO CALLED BY A COBOL PROGRAM.
*    INPUT PARMS - 1 BYTE RETURN CODE        F = FOUND OR N IF NOT
*                  2 BYTE ARGUMENT 1 LENGTH  LENGTH OF SEARCH ARG
*                256 BYTE ARGUMENT 1         DATA TO SEARCH WITH
*                  2 BYTE ARGUMENT 2 LENGTH  LENGTH OF AREA TO SEARCH
*               8192 BYTE MAX ARGUMENT 2     AREA TO SEARCH IN
*
* THE SEARCH ARGUMENT (ARG1) IS COMPARED TO THE CONTENTS OF ARG2 FROM
* LEFT TO RIGHT STARTING AT POSITION 1 IN ARGUMENT 2. IF A MATCH IS
* NOT FOUND, THE COMPARE IS MADE AT POSITION 2 IN ARGUMENT 2 AND SO
* ON UNTIL A MATCH IS FOUND OR UNTIL WE RUN OUT OF ARGUMENT 2.
* THE LENGTH OF ARGUMENT 1 IS LIMITED TO 256 BYTES. THE LENGHT OF
* ARGUMENT 2 IS LIMITED TO 8192 BYTES.
*******************************************************************
*
*        REGISTER USAGE
*              R15-ENTRY
*              R14-RETURN
*              R13-SAVE
*              R11-
*              R10-BASE
*              R9 -
*              R8 -
*              R7 - ONE BYTE PAST LAST GOOD BYTE IN ARG 2
*              R6 -
*              R5 -ARG2 POINTER
*              R4 -
*              R3 -ARG1 POINTER
*              R2 - WORK REGISTER
*              R1 -POINTS TO THE ARGUMENT LIST AT ENTRY TIME
*              R0 -WORK REGISTER
         EJECT
ACOBID   START 0
         PRINT NOGEN
         ENTRY ACOBIDX
         USING ACOBIDX,R15
ACOBIDX  SAVE  (14,12)                  SAVE REGISTERS
         LR    R10,R15
         DROP  R15
         USING ACOBIDX,R10
         LR    R11,R13
         LA    R13,SAVE
         ST    R13,8(R11)
         ST    R11,4(R13)
         B     START
SAVE     DS    18F
START    L     R2,0(R1)                GET ADDR OF PARMS
         ST    R2,PARMADDR             SAVE FOR LATER
*
         MVI   RETCODE,C'N'            DEFAULT RETURN CODE
         MVC   ARG1LEN,1(R2)           GET LENGTH OF ARG1
         AH    R2,=H'3'                GET START OF ARG1
         ST    R2,ARG1ADDR             SAVE IT FOR PROCESSING
         AH    R2,=H'256'              GET ADDR OF ARG2 LEN
         MVC   ARG2LEN,0(R2)           SAVE IT FOR PROCESSING
         AH    R2,=H'2'                GET ADDR OF ARG2
         ST    R2,ARG2ADDR             SAVE IT FOR PROCESSING
*
         SR    R2,R2                   CLEAR
         SR    R3,R3                        THE
         SR    R5,R5                           WORK
         SR    R7,R7                               REGS
         LH    R2,ARG2LEN              GET LENGTH OF ARG2
         CH    R2,=H'1'                LESS THAN 1 BYTE ?
         BL    RETBAD                  YES, RETURN NOT FOUND
         CH    R2,=H'8192'             MORE THAN 8192 BYTES ?
         BH    RETBAD                  YES, RETURN NOT FOUND
         LR    R7,R2                   GET LENGTH OF ARG2
         LH    R2,ARG1LEN              GET LENGTH OF ARG1
         CR    R7,R2                   ARG2 LENGTH LESS THAN ARG1 ?
         BL    RETBAD                  YES, RETURN NOT FOUND
         CH    R2,=H'256'              MORE THAN 256 BYTES ?
         BH    RETBAD                  YES, RETURN NOT FOUND
         CH    R2,=H'1'                LESS THAN 1 BYTE ?
         BL    RETBAD                  YES, RETURN NOT FOUND
*
*
         SH    R2,=H'1'                REDUCE ARG1 LENGTH BY ONE
         STC   R2,COMP+1               PUT LENGTH IN COMPARE INSTR
         L     R3,ARG1ADDR             GET START OF ARG1
         L     R5,ARG2ADDR             GET START OF ARG2
         LH    R7,ARG2LEN              GET LENGTH OF ARG2
         AR    R7,R5                   GET ADDR OF END OF ARG2 + 1
COMP     CLC   0(0,R3),0(R5)           FOUND THE MATCH ?
         BE    RETGOOD                 YES, GO SET RETURN CODE
         AH    R5,=H'1'                BUMP TO NEXT BYTE
         CR    R5,R7                   DONE WITH COMPARES ?
         BL    COMP                    NO, GO DO NEXT COMPARE
         B     RETBAD                  YES, RETURN NOT FOUND
RETGOOD  DS    0H
         MVI   RETCODE,C'F'            INDICATE FOUND
RETBAD   DS    0H
         L     R2,PARMADDR
         MVC   0(1,R2),RETCODE
         L     R13,4(R13)              RESTORE ADDR OF SAVE AREA
         SR    R15,R15                 RESTORE ADDR OF SAVE AREA
         RETURN (14,12),T,RC=(15)
         LTORG
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU  10
R11      EQU  11
R12      EQU  12
R13      EQU  13
R14      EQU  14
R15      EQU  15
         DS    0F
*
         DC    C'START OF WORK AREA FOR ACOBIDX'
PARMADDR DS    F
ARG1LEN  DS    H                        LENGTH OF ARG1
ARG2LEN  DS    H                        LENGTH OF ARG2
ARG1ADDR DS    F                        ADDR   OF ARG1
ARG2ADDR DS    F                        ADDR   OF ARG2
RETCODE  DS    CL1                      RETURN CODE
         DC    C'END   OF WORK AREA FOR ACOBIDX'
         END
