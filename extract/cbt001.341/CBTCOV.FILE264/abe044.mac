 /* COPYRIGHT 1983 BY THOMAS GLEN SMITH */
 /* ABE044 (WAS DENTFSS), $STORE */
 /* CALLED TO PROCESS -
    $STORE <PANEL> DUP(<N>) LIST LINE(<L>) MASK NOBREAK NAME() BREAK() -
                   SKIP(N1:N2 ...) */
   %INCLUDE ABESUB;
 ABESUB(ABE044) PARS(000000000000000) CHECK(YES);
   %INCLUDE ABESUBA;
   %INCLUDE ABERHPNL;

   % INCLUDE ABEPNL;
   DCL SETCAPS ENTRY;
   DCL PREFIX ENTRY(CHAR(*), CHAR(*))
     RETURNS(FIXED BIN(15,0));
   DCL NAME CHAR(8);
   DCL AD(0:32766) CHAR(1) UNALIGNED BASED(T);
   DCL HWD UNALIGNED FIXED BIN(15,0) BASED(DUMPTR);
   DCL 1 MPNLCALL,
     2 MCURPNL FIXED BIN(15,0) INIT(0),
     2 MNXTPNL FIXED BIN(15,0) INIT(1),
     2 MARYPTR PTR,
     2 MAID BIT(8),
     2 MCURLOC FIXED BIN(15,0),
     2 MCHGCURS FIXED BIN(15,0) INIT(-1),
     2 MCALLFLGS BIT(8) INIT('0'B);
   DCL 1 @PNLARYS,
     2 @ARYCNT FIXED BIN(31,0) INIT(1),
     2 @PNLARY(1),
      3 @PNLSTAPT PTR,
       /* PTR TO STATIC PORTION OF DEFINITION */
      3 @PNLDYNPT PTR;
       /* PTR TO DYNAMIC PORTION OF DEFINITION */
   DCL KEYTABLE(8) CHAR(80) VAR STATIC
     INIT('DUP','LIST','LINE','MASK','NOBREAK','BREAK','NAME','SKIP');
   DCL INDX FIXED BIN(15,0);
   DCL OPER CHAR(80) VAR;
   DCL KEYLAB(0:8) LABEL;
   DCL (NOBRSW,LINESW) BIT(1) INIT('0'B);
   DCL LISTLN FIXED BIN(15,0) INIT(0);
   DCL DUPNO FIXED BIN(15,0) INIT(0);
   DCL DUPLEN FIXED BIN(15,0) INIT(0);
   DCL DUPDATA CHAR(4000) VAR INIT('');
   DCL (SKHD,RHP,SAVPTR,ORGPTR,RHOPTR) PTR;
   DCL 1 SKEL BASED(SKELPTR),
     2 SKNXT PTR, /* SINGLY-LINKED LIST */
     2 STC FIXED BIN(15,0), /* STARTING COLUMN TO SKIP */
     2 ENC FIXED BIN(15,0); /* ENDING COLUMN TO SKIP */
   DCL MASKSW BIT(1) INIT('0'B);
   DCL BLANKS CHAR(4000) STATIC INIT(' ');
   RHRC=0;
   SKHD=NULL; /* EMPTY SKIP LIST - HDPTR = NULL */
   RHOPTR=RHPTR; /* SAVE IN CASE NAME KEYWORD IS SPECIFIED */
   BREAK=1;
   DO I=2 TO 16 WHILE(PARY(I)^='');
     CALL SETCAPS(PARY(I));
     CALL #SPARS(PARY(I),KEYTABLE,OPER,INDX);
       /* CALL SPARS */
     GO TO KEYLAB(INDX);
 KEYLAB(0): /* INVALID OPERAND */
     PUT SKIP LIST('ERROR ON $STORE, INVALID OPERAND = ',PARY(I));
     SIGNAL ERROR;
 KEYLAB(1): /* DUP */
     DUPNO=OPER;
     GO TO ENDCASE;
 KEYLAB(2): /* LIST */
     LISTLN=1;
     GO TO ENDCASE;
 KEYLAB(3): /* LINE */
     LINESW='1'B;
     LINE=OPER;
     GO TO ENDCASE;
 KEYLAB(4): /* MASK */
     MASKSW='1'B;
     GO TO ENDCASE;
 KEYLAB(5): /* NOBREAK */
     NOBRSW='1'B;
     GO TO ENDCASE;
 KEYLAB(6): /* BREAK */
     BREAK=OPER;
     GO TO ENDCASE;
 KEYLAB(7): /* NAME */
     DO RHP=NXTRHEL REPEAT RHP->RHNXT WHILE(RHP^=NULL)
       UNTIL(RHP->RHNAME=OPER);
       END;
     IF RHP^=NULL
       THEN RHPTR=RHP;
       ELSE DO;
         MSGDATA='UNABLE TO FIND NAMED DATA SET';
         RHRC=8;
         RETURN;
         END;
     GO TO ENDCASE;
 KEYLAB(8): /* SKIP */
     SKHD= #SKIP(OPER); /* GO SET UP SKIP LIST */
     IF SKHD=NULL
       THEN DO;
         RHRC=8;
         MSGDATA='INVALID SKIP SPECIFICATION';
         RETURN; /* GET OUT IF SETSKIP FOUND AN ERROR */
         END;
     GO TO ENDCASE;
 ENDCASE:
     END;
   ORGPTR=LSTHDR; /* ORGPTR POINTS TO PRIOR LINE */
   IF LINESW
     THEN DO;
       DO ORGPTR=NXTHDR REPEAT ORGPTR->NXTPTR WHILE(ORGPTR^=HDPTR)
         UNTIL(ORGPTR->RECSEQ >= LINE);
         END;
       ORGPTR=ORGPTR->LSTPTR; /* POINT TO LINE PRIOR TO ONE TO USE */
       END;
   L=BUFLN;
   IF OUTDDN^=NULL
     THEN IF SUBSTR(OUTDDN->ALCFLAG,6,1)='0'B /* IS IT NUMBERED? */
       THEN L=L-OUTDDN->ALCSEQLEN;
   /* L NOW EQUALS LENGTH TO STORE IN EACH RECORD. */
   BUF='';
   OLINE=-1;
   BRCNT=0;
   NAME=PARY(1);
   CALL SETCAPS(NAME);
   T=#PFN(RHHDRPT,NAME); /* GO GET PANEL */
   PNLPTR,WRKPTR=ADDR(AD(4));
   IF WRKPTR->PNLLEN<0
     THEN DO;
       WRKADJ=WRKADJ+WRKPTR->NEWLEN;
       SFLDPTR=ADDR(FLDLOC); /* POINT TO FIRST FIELD DESCR */
       END;
     ELSE DO;
       WRKADJ=WRKADJ+WRKPTR->PNLLEN;
       SFLDPTR=ADDR(NEWLEN); /* POINT TO FIRST FIELD DESCR */
       END;
   DYNPTR=WRKPTR;
   WRKADJ=WRKADJ+DINOF; /* WRKPTR POINTS AT PANEL_IN SUBSTRUCTURE */
   DLUP: DO;
     DO SFLDADJ=SFLDADJ REPEAT SFLDADJ+FLDLEN UNTIL(FLDNUM=FLDCNT);
       IF ^SUBSTR(FLAGS,3,1) /* UNPROTECTED? */
         THEN DO; /* IT IS INPUT FIELD */
           NLINE=FLDSBAB/LINESIZE;
           DFLDADJ=WRKADJ+INOFF; /* DFLDPTR POINTS AT INPUT DATA */
           CALL BUFCK;
           IF NLINE=OLINE × NOBRSW
             THEN IF INLEN+LENGTH(BUF)+LISTLN > L
               THEN DO; /* TIME TO ADD A NEW RECORD */
                 IF ^ADDREC & ^(MASKSW × NOBRSW)
                     THEN LEAVE DLUP;
                 BUF='';
                 CALL BUFCK;
                 OLINE=NLINE;
                 END;
           IF FLDINUM<=DUPNO
             THEN DO;
               IF MASKSW & DATA^=''
                 THEN DUPDATA=DUPDATA××DATA××LOW(INLEN-LENGTH(DATA));
                 ELSE DUPDATA=DUPDATA××DATA××SUBSTR(BLANKS,1,
                  INLEN-LENGTH(DATA));
               IF LISTLN=1
                 THEN DUPDATA=DUPDATA××' ';
               DUPLEN=LENGTH(DUPDATA);
               END;
             ELSE DO;
               IF ^NOBRSW
                THEN IF NLINE^=OLINE
                  THEN DO;
                    BRCNT=BRCNT+1;
                    IF BRCNT>BREAK
                      THEN DO; /* TIME TO WRITE A NEW LINE */
                        BRCNT=1;
                        IF ^ADDREC & ^MASKSW
                          THEN LEAVE DLUP;
                        BUF=DUPDATA;
                        CALL BUFCK;
                        END;
                    OLINE=NLINE;
                    END;
               END;
           DATA=DATA××SUBSTR(BLANKS,1,INLEN-LENGTH(DATA));
           IF MASKSW & DATA^=''
             THEN DATA=TRANSLATE(DATA,LOW(1),' ');
           BUF=BUF××DATA;
           IF LISTLN=1
             THEN BUF=BUF××' ';
           END;
       END;
     /* NOW ADD LAST RECORD */
     IF ^ADDREC & ^(MASKSW × NOBRSW)
       THEN LEAVE DLUP;
     END DLUP;
   RHPTR=RHOPTR; /* RESTORE ORIGINAL RHPTR */
   DO SKELPTR=SKHD REPEAT SKHD WHILE(SKHD^=NULL);
     SKHD=SKNXT;
     FREE SKEL;
     END;
 BUFCK:  PROC;
 /* CALLED TO CHECK THE SKIP OPTION */
    DCL D FIXED BIN(15,0);
   D=LENGTH(BUF);
   DO SKELPTR=SKHD REPEAT SKNXT WHILE(SKELPTR^=NULL)
     UNTIL((D+1>=STC)&(D+1<=ENC));
     END;
   IF SKELPTR^=NULL
     THEN BUF=BUF××SUBSTR(BLANKS,1,ENC-D);
   END BUFCK;
 ADDREC:  PROC RETURNS(BIT(1));
   DCL (I,L) FIXED BIN(31,0);
   DCL R BIT(1);
   IF BUF=DUPDATA
     THEN IF MASKSW
       THEN IF DUPDATA=''
         THEN R='0'B; /* INDICATE EMPTY RECORD */
         ELSE R='1'B;
       ELSE R='0'B; /* INDICATE EMPTY RECORD */
     ELSE R='1'B;
   IF ^(MASKSW × NOBRSW) & ^R
     THEN RETURN(R);
   IF ORGPTR=LSTHDR
     THEN DO;
       BUF=TRANSLATE(BUF,' ',LOW(1));
       IF ORGPTR=HDPTR
         THEN SEQ=1;
         ELSE SEQ=ORGPTR->RECSEQ+1;
       CALL #ADD(RHPTR,RHHDRPT,ORGPTR,ORGPTR,SEQ,BUF,0);
       END;
     ELSE DO;
       ORGPTR=ORGPTR->NXTPTR;
       IF ^MASKSW
         THEN ORGPTR->RECSTR=BUF;
         ELSE IF R
           THEN DO;
             L=MIN(LENGTH(ORGPTR->RECSTR),LENGTH(BUF));
             DO I=1 TO L;
               IF SUBSTR(BUF,I,1)^=' '
                 THEN IF SUBSTR(BUF,I,1)=LOW(1)
                   THEN SUBSTR(ORGPTR->RECSTR,I,1)=' ';
                   ELSE SUBSTR(ORGPTR->RECSTR,I,1)=SUBSTR(BUF,I,1);
               END;
             IF LENGTH(BUF)>=LENGTH(ORGPTR->RECSTR)
               THEN DO;
                 IF LENGTH(BUF)>LENGTH(ORGPTR->RECSTR)
                   THEN ORGPTR->RECSTR=ORGPTR->RECSTR××
                     SUBSTR(BUF,LENGTH(ORGPTR->RECSTR)+1);
                 ORGPTR->RECSTR=TRANSLATE(ORGPTR->RECSTR,' ',LOW(1));
                 END;
             END;
       END;
   RETURN(R);
   END ADDREC;
   END ABE044;
