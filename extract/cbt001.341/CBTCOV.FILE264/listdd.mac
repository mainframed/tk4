 /* LISTDD */
 /*
0*$.HE TSO COMMAND PROCESSOR - LISTDD
0*$.HE LISTS ALLOCATIONS BY DDNAME
0*$.PL 55
0*$.PN 0
0*$.PA
0*$.SS
0*$.NF
0*$12/31/78
0*$AUTHOR:  T. SMITH
0*$SOURCE MODULE NAME:  LISTDD
0*$DOCUMENTATION ID:  0*$
0*$HELP DATA ID:  0*#
0*$.FI L
0*$.SP 5
0*$THIS COMMAND PROCESSOR ALLOWS THE TSO USER TO FIND OUT WHAT
0*$DATA SETS HAVE BEEN ALLOCATED TO HIS SESSION UNDER SPECIFIC
0*$DDNAMES.  IT IS A PL/I PROGRAM WRITTEN USING THE PLIST
0*$FACILITY.
0*#)F FUNCTION
0*#    THE LISTDD COMMAND CAN BE USED TO FIND OUT WHAT DATA SETS ARE
0*#    ALLOCATED UNDER A SPECIFIED DDNAME, OR UNDER WHAT DDNAMES A
0*#    PARTICULAR DATA SET IS ALLOCATED.
0*#)X SYNTAX
0*#    LISTDD 'DDNAME-LIST' MASK() ALL NOL
0*#
0*#  ALIAS:  LDD
0*#  REQUIRED OPERAND:  'DDNAME-LIST'
0*#
0*#     EX: LISTDD SYSLOAD -- INDICATES WHAT DATA SETS ARE ALLOCATED
0*#         UNDER THE DDNAME OF SYSLOAD. RETURN CODE IS 4 IF DDNAME
0*#         NOT FOUND.
0*#     EX: LISTDD (SYSIN SYSOUT) -- INDICATES WHAT DATA SETS ARE
0*#         ALLOCATED UNDER THE DDNAMES SYSIN AND SYSOUT.  RETURN
0*#         CODE IS 4 ONLY IF NEITHER DDNAME IS FOUND.
0*#     EX: LISTDD DUMMY MASK(SYSUT.)  -- LISTS ALL THE DATA SETS
0*#         ALLOCATED WITH DDNAMES BEGINNING WITH 'SYSUT', AND
0*#         FOLLOWED BY ONE OTHER CHARACTER.  RETURN CODE IS 4 IF
0*#         NO MATCHES ARE FOUND.
0*#     EX: LISTDD '' ALL -- LISTS ALL THE DATA SETS ALLOCATED TO
0*#         THE SESSION.
0*#     EX: LDD '' DSN('SYS2.PROCLIB') -- LISTS ALL DDNAMES WHERE
0*#         'SYS2.PROCLIB' IS ALLOCATED.  RETURN CODE IS 4 IF
0*#         DSNAME IS NOT FOUND.
0*#     EX: LDD SYSLOAD DSN('SYS1.GDDMLOAD') -- LISTS ONLY IF
0*#         DDNAME IS SYSLOAD AND DSN='SYS1.GDDMLOAD' IS ALLOCATED
0*#         UNDER THAT DDNAME.  IN THAT CASE, RETURN CODE IS 0, AND
0*#         IS 4 OTHERWISE.
0*#
0*#)O OPERANDS
0*#  'DDNAME-LIST' - THIS IS A LIST OF ONE OR MORE DDNAMES FOR
0*#    WHICH DATA SETS ARE TO BE LISTED.  IF MORE THAN ONE DDNAME
0*#    IS SPECIFIED, THE LIST MUST BE SURROUNDED IN PARENTHESES.
0*#    IF THE MASK OR ALL KEYWORDS ARE SPECIFIED, THE VALUE SPECIFIED
0*#    FOR 'DDNAME-LIST' WILL BE IGNORED, ALTHOUGH YOU MUST STILL
0*#    ENTER SOMETHING.  THIS IS A REQUIREMENT OF THE IBM
0*#    PARSING ALGORITHM.
0*#))ALL - INDICATES ALL DATA SET ALLOCATED TO THE SESSION ARE TO
0*#    BE LISTED.
0*#))DSN() - USED TO SPECIFY A DSNAME (TSO STANDARD NAMING CONVENTIONS
0*#    SHOULD BE USED).  ALL DDNAMES UNDER WHICH THIS DATA SET IS
0*#    ALLOCATED WILL BE LISTED.
0*#))MASK() - THIS KEYWORD CAN BE USED TO INDICATE A RANGE OF
0*#    DDNAMES FOR WHICH DATA SETS ARE TO BE LISTED.  SPECIFYING
0*#    'MASK(SYSUT.)', FOR EXAMPLE, INDICATES THAT ALL DDNAMES
0*#    BEGINNING WITH 'SYSUT' AND FOLLOWED BY EXACTLY ONE OTHER
0*#    CHARACTER ARE TO BE LISTED.  A PERIOD IN ANY POSITION IN
0*#    THE MASK INDICATES THAT ANY CHARACTER IN THE SAME POSITION
0*#    IN THE DDNAME WILL COMPARE "EQUAL" IN THE TEST TO DETERMINE
0*#    IF IT IS TO BE LISTED.
0*#))NOL - SPECIFY THIS KEYWORD IF YOU ARE ONLY INTERESTED IN THE RETURN
0*#    CODE FROM LISTDD AND NOT A LISTING AT THE TERMINAL.  THE RETURN
0*#    CODE WILL BE 0 IF THE DDNAME IS ALLOCATED, AND 4 IF NOT.
 */
   % INCLUDE CPINIT1;
   % @CMP ='O';
   % INCLUDE CPINIT2;
   @PROC(1,DDN#(LIST),MASK(),ALL,DSN(),NOL);
   % INCLUDE JFCB;
   DCL JFCBCOR CHAR(176);
   JFCBPTR = ADDR(JFCBCOR);
   DCL SYSJFCB ENTRY(CHAR(8),PTR);
   DCL PLIRETRC BUILTIN;
   DCL NUMPIC PIC'ZZZZ9';
   DCL RFMSTR CHAR(8) VAR;
   DCL PREFIX ENTRY(CHAR(*),CHAR(*))RETURNS(FIXED BIN(15,0));
   DCL SYSSVC ENTRY(FIXED BIN(15,0),PTR,PTR)RETURNS(FIXED BIN(31,0));
   DCL MYMASK CHAR(8);
   DCL MYDSN CHAR(44) VAR;
   DCL REQNUM FIXED BIN(15,0),
     DSADSLNG FIXED BIN(15,0),
     DSADSNAM CHAR(44) VAR,
     DYNAMCNT FIXED BIN(15,0),
     DSACNTRL BIT(8),
     LSTENTRY CHAR(1),
     DSTYPE BIT(8),
     DMEMLNT FIXED BIN(15,0),
     DSAMEM CHAR(8) VAR,
     (DSADDNAM,LASTDDN) CHAR(8),
     DSANDISP FIXED BIN(15,0),
     DSACDISP FIXED BIN(15,0);
   DCL STATCON(0:4) CHAR(3) INIT('','OLD','MOD','NEW','SHR');
   DCL DISPCON(0:5) CHAR(7) VAR INIT('','UNCATLG','CATLG','DELETE',
     'KEEP','PASS');
   DCL ATTRCON(0:3) CHAR(25) VAR INIT('PERMANENTLY CONCATENATED',
     'IN-USE','PERMANENTLY ALLOCATED','CONVERTIBLE ATTRIBUTE');
   DCL (HITSW,LASTHITSW) BIT(1);
   DCL (LASTSW,MATCHSW) BIT(1) INIT('0'B);
   DCL DDNSW BIT(1);

   PDEPTR=ADDR(DDN);
   WRKPTR=PDEIKPT;
   DDNSW=^(''''''=SUBSTR(WRKSTR,1,PDEIKL));
   MYMASK = SYMC('&MASK');
   MYDSN=SYMC('&DSN');
   IF LENGTH(MYDSN)>0
     THEN IF SUBSTR(MYDSN,1,1)=''''
       THEN MYDSN=SUBSTR(MYDSN,2,LENGTH(MYDSN)-2);
       ELSE MYDSN=SYMC('&SYSPREF')××'.'××MYDSN;
   LASTDDN='';
   LASTHITSW='0'B;
   DO REQNUM = 1 REPEAT REQNUM+1 UNTIL(LSTENTRY ^= LOW(1));
     CALL DAR(REQNUM);
     IF DSADDNAM^=''
       THEN DO;
         LASTDDN=DSADDNAM;
         LASTHITSW='0'B;
         END;
     IF ALL^=0
       THEN HITSW='1'B;
       ELSE DO;
         HITSW ='0'B;
         IF MASK = 0
           THEN HITSW=MASK_NO;
           ELSE HITSW=MASK_YES;
         LASTHITSW=LASTHITSW×HITSW;
         IF LENGTH(MYDSN)^=0
           THEN HITSW=DSN_YES;
         END;
     IF HITSW × (LASTSW & DSADDNAM ='')
       THEN DO;
         LASTSW ='1'B;
         CALL LISTIT; /* GO WRITE DISPLAY */
         END;
       ELSE LASTSW ='0'B;
     MATCHSW=MATCHSW×HITSW;
     END;
   IF MASK=0 & ALL=0 & DSN=0
     THEN DO PDEPTR=ADDR(DDN) REPEAT PDEIKLP WHILE(PDEPTR ^= NULL);
       WRKPTR = PDEIKPT;
       IF SUBSTR(WRKSTR,1,PDEIKL) ^= LOW(PDEIKL)
         THEN DO;
           @SETL(&NOTFND = SUBSTR(WRKSTR,1,PDEIKL));
           IF NOL=0
             THEN @WRITE('DDNAME = &NOTFND, NOT FOUND');
           END;
       END;
   IF MATCHSW
     THEN CALL PLIRETC(0);
     ELSE CALL PLIRETC(4);
   DAR:PROC(REQ);
     DCL REQ FIXED BIN(15,0);
     DCL DARRET FIXED BIN(31,0);
     DCL DAPARM PTR INIT(ADDR(DARQBLK)),DAPARM_HIBIT BIT(8) DEFINED
     DAPARM;
     DCL REG1 PTR INIT(ADDR(DAPARM));
     DAPARM_HIBIT ='10000000'B;
     DCL 1 DARQBLK UNALIGNED,
       2 DABLKLN BIT(8) INIT('00010100'B), /* LENGTH OF BLOCK */
       2 DAVERB BIT(8) INIT('00000111'B),
       /* VERB CODE = INFORMATION RETRIEVAL */
       2 DAFLGS1 FIXED BIN(15,0) INIT(0), /* FLAGS */
       2 DAERRCD FIXED BIN(15,0) INIT(0), /* ERROR RETURN CODES */
       2 DAINFO FIXED BIN(15,0) INIT(0), /* INFORMATION RETURN CODES */
       2 DATXTPT PTR INIT(ADDR(DAPTR)), /* ADDRESS OF TEXT POINTERS */
       2 DARSVD FIXED BIN(31,0) INIT(0), /* RESERVED */
       2 DAFLGS2 FIXED BIN(31,0) INIT(0); /* FLAGS */
     DCL DAPTR(11) PTR INIT(ADDR(DAREQ),ADDR(DADSNM),ADDR(DALIMIT),ADDR(
     DATTR),ADDR(DALENTRY),ADDR(DADSTYPE),ADDR(DAMEM),ADDR(DADDNM),ADDR(
     DASTAT),ADDR(DANDISP),ADDR(DACDISP));
     DCL DAPTRDEF(11) BIT(32) DEF(DAPTR);
     SUBSTR(DAPTRDEF(11),1,1) ='1'B;
     % DCL @DINIT ENTRY;
     % @DINIT:PROC(P0,P1,P2,P3) RETURNS(CHAR);
       DCL (P0,P1,P2,P3) CHAR;
       RETURN(P0××',3 KEY FIXED BIN(15,0) INIT('××P1××
       '), 3 NUMB FIXED BIN(15,0) INIT('××P2××
       '), 3 LENG FIXED BIN(15,0) INIT('××P3××'), 3 PARM CHAR('××P3××')'
       );
       % END @DINIT;
       DCL 1 DATXT UNALIGNED,
         2  @DINIT(DAREQ,15,1,2),
         2  @DINIT(DADSNM,5,1,44),
         2  @DINIT(DALIMIT,11,1,2),
         2  @DINIT(DATTR,12,1,1),
         2  @DINIT(DALENTRY,13,1,1),
         2  @DINIT(DADSTYPE,14,1,1),
         2  @DINIT(DAMEM,6,1,8),
         2  @DINIT(DADDNM,4,1,8),
         2  @DINIT(DASTAT,7,1,1),
         2  @DINIT(DANDISP,8,1,1),
         2  @DINIT(DACDISP,9,1,1);
       UNSPEC(DAREQ.PARM) = UNSPEC(REQ);
       DARRET = SYSSVC(99,NULL,REG1);
       DSADSLNG = DADSNM.LENG;
       DSADSNAM = SUBSTR(DADSNM.PARM,1,DADSNM.LENG);
       DYNAMCNT = UNSPEC(DALIMIT.PARM);
       DSACNTRL = UNSPEC(DATTR.PARM);
       LSTENTRY = DALENTRY.PARM;
       DSTYPE = UNSPEC(DADSTYPE.PARM);
       DMEMLNT = DAMEM.LENG;
       DSAMEM = SUBSTR(DAMEM.PARM,1,DAMEM.LENG);
       DSADDNAM = SUBSTR(DADDNM.PARM,1,DADDNM.LENG);
       DSASTAT = UNSPEC(DASTAT.PARM);
       IF DSASTAT ^= 0
         THEN DSASTAT = LOG2(DSASTAT)+1;
       DSANDISP = UNSPEC(DANDISP.PARM);
       IF DSANDISP ^= 0
         THEN DSANDISP = LOG2(DSANDISP)+1;
       DSACDISP = UNSPEC(DACDISP.PARM);
       IF DSACDISP ^= 0
         THEN DSACDISP = LOG2(DSACDISP)+1;
       END DAR;

 DSN_YES: PROC RETURNS(BIT(1));
 /**********************************************************************
 *                                                                     *
 * CALLED FOR EACH ALLOCATION ENTRY WHEN THE DSN KEYWORD WAS USED.     *
 * IF THE LEFTMOST PART OF THE CURRENT DSNAME MATCHES THE DSNAME       *
 * SPECIFIED WITH THE DSN KEYWORD, HITSW IS SET ON.                    *
 *                                                                     *
 **********************************************************************/
   DCL DSNSW BIT(1) INIT('0'B);

   LASTSW='0'B;
   IF DDNSW & ^LASTHITSW
     THEN RETURN('0'B); /* NO HIT IF NO DDNAME MATCH */
   IF LENGTH(MYDSN)<=LENGTH(DSADSNAM)
     THEN DO;
       DSNSW='1'B;
       DO I=1 REPEAT I+1 WHILE(I<=LENGTH(MYDSN))
         UNTIL(^DSNSW);
         IF SUBSTR(DSADSNAM,I,1)^=SUBSTR(MYDSN,I,1)
           THEN DSNSW='0'B;
         END;
       END;
   RETURN(DSNSW);
   END DSN_YES;

 LISTIT: PROC;
 /**********************************************************************
 *                                                                     *
 * CALLED TO GENERATE TERMINAL OUTPUT.                                 *
 *                                                                     *
 **********************************************************************/
   IF DMEMLNT = 0
     THEN @SETL(&DSN = DSADSNAM);
     ELSE @SETL(&DSN = DSADSNAM××'('××DSAMEM××')');
   @SETL(&DDN = DSADDNAM);
   @SETL(&DSP1 = STATCON(DSASTAT));
   @SETL(&DSP2 = DISPCON(DSANDISP));
   @SETL(&DSP3 = DISPCON(DSACDISP));
   IF SUBSTR(DSACNTRL,2,1)
     THEN @SETL(&ST1 ='IN USE');
     ELSE @SETL(&ST1 ='');
   IF SUBSTR(DSACNTRL,3,1)
     THEN @SETL(&ST2 ='PERMANENTLY ALLOCATED');
     ELSE @SETL(&ST2 ='');
   SELECT(DSTYPE);
     WHEN('10000000'B) @SETL(&LOC ='NULLFILE');
     WHEN('01000000'B) @SETL(&LOC ='TERMINAL');
     OTHERWISE @SETL(&LOC ='');
     END;
   IF NOL=0
     THEN @WRITE('//&DDN DD DSN=&DSN,DISP=(&DSP1,&DSP2,&DSP3)');
   IF DSADDNAM =''
     THEN @SETL(&CAT='CONCATENATED TO '××LASTDDN);
     ELSE DO;
       @SETL(&CAT='');
       CALL SYSJFCB(DSADDNAM,JFCBPTR);
       NUMPIC = JFCLRECL;
       @SETL(&LR = SUBSTR(NUMPIC,PREFIX(NUMPIC,' ')));
       NUMPIC = JFCBLKSI;
       @SETL(&BL = SUBSTR(NUMPIC,PREFIX(NUMPIC,' ')));
       SELECT(SUBSTR(JFCRECFM,1,2));
         WHEN('10'B) RFMSTR ='F';
         WHEN('01'B) RFMSTR ='V';
         OTHERWISE RFMSTR ='U';
         END;
       IF SUBSTR(JFCRECFM,4,1)
         THEN RFMSTR=RFMSTR××'B';
       IF SUBSTR(JFCRECFM,5,1)
         THEN RFMSTR=RFMSTR××'S';
       SELECT(SUBSTR(JFCRECFM,6,2));
         WHEN('10'B) RFMSTR = RFMSTR××'A';
         WHEN('01'B) RFMSTR = RFMSTR××'M';
         OTHERWISE;
         END;
       @SETL(&RF = RFMSTR);
       IF NOL=0
         THEN @WRITE('// DCB=(LRECL=&LR,BLKSIZE=&BL,RECFM=&RF)');
       END;
   IF NOL=0
     THEN @WRITE('//* &ST1  &ST2 &LOC &CAT');
   END LISTIT;

 MASK_NO: PROC RETURNS(BIT(1));
 /**********************************************************************
 *                                                                     *
 * CALLED FOR EACH ALLOCATION ENTRY WHEN THE MASK KEYWORD WAS NOT      *
 * USED.  THE FOLLOWING IS DONE:                                       *
 *                                                                     *
 * 1.  PDEPTR WILL EITHER BE NULL OR WILL POINT TO THE DDNAME ELEMENT  *
 *     THAT MATCHES THE CURRENT DDNAME.                                *
 * 2.  HITSW WILL BE TURNED ON IF A MATCH IS FOUND.                    *
 * 3.  IF A MATCH IS FOUND, THE FIRST BYTE IN THE DDNAME ELEMENT       *
 *     (PDEIKL) IS SET TO ZERO.                                        *
 *                                                                     *
 **********************************************************************/
   DCL HITSW BIT(1) INIT('0'B);

   DO PDEPTR=ADDR(DDN) REPEAT PDEIKLP WHILE(PDEPTR ^= NULL)
     UNTIL(HITSW);
     WRKPTR = PDEIKPT;
     IF DSADDNAM = SUBSTR(WRKSTR,1,PDEIKL)
       THEN DO;
         HITSW ='1'B;
         SUBSTR(WRKSTR,1,PDEIKL) = LOW(PDEIKL);
         END;
     END;
   RETURN(HITSW);
   END MASK_NO;

 MASK_YES: PROC RETURNS(BIT(1));
 /**********************************************************************
 *                                                                     *
 * CALLED FOR EACH ALLOCATION ENTRY WHEN THE MASK KEYWORD WAS USED.    *
 * THE CURRENT DDNAME IS COMPARED TO THE MASK, AND HITSW WILL BE SET   *
 * ON IF A MATCH IS FOUND.                                             *
 *                                                                     *
 **********************************************************************/
   DCL I FIXED BIN;
   DCL HITSW BIT(1) INIT('0'B);

   DO I = 1 TO 8;
     IF SUBSTR(MYMASK,I,1) ^='.'
       THEN IF SUBSTR(MYMASK,I,1)^=SUBSTR(DSADDNAM,I,1)
         THEN LEAVE;
     END;
   IF I = 9
     THEN HITSW ='1'B;
   RETURN(HITSW);
   END MASK_YES;

   END;
