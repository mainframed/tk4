 /* PSTR */
 /*
0*$.HE GENERALIZED SUBROUTINES - PSTR
0*$.HE GIVEN AN OPENING PARENTHESIS,
0*$.HE FIND THE CLOSING PARENTHESIS
0*$.PL 55
0*$.PN 0
0*$.PA
0*$.SS
0*$.NF
0*$01/16/79
0*$AUTHOR:  T. SMITH
0*$SOURCE MODULE NAME:  PSTR
0*$DOCUMENTATION ID:  0*$
0*$.FI L
0*$.SP 5
0*$THIS SUBROUTINE, GIVEN THE INDEX TO AN OPENING PARENTHESIS,
0*$WILL RETURN THE INDEX OF THE MATCHING CLOSING PARENTHESIS.
0*$CALL FORMAT IS AS FOLLOWS:
0*$.IN 5
0*$.NF
0*$.SP 1
0*$DCL PSTR ENTRY(CHAR(*) VAR, FIXED BIN(15,0))
0*$  RETURNS(FIXED BIN(15,0));
0*$DCL MAINSTR CHAR(100) VAR INIT(
0*$  'GO (AT (MINE+23)) SIT');
0*$I = INDEX(MAINSTR,'(');
0*$J = PSTR(MAINSTR,I);
0*$** J NOW EQUALS 17 **
 */
 /* INSTR CONTAIN PARENTHESIZE STRING. */
 /* INDX CONTAINS OFFSET, REL. 1, TO STARTING PARENTHESIS IN INSTR.
         MUST BE SET BY CALLER. */
 /* PSTR WILL RETURN OFFSET OF CLOSING PARENTHESIS, OR ZERO IF
         PARENTHESIS DON'T MATCH. */
 PSTR:  PROC(INSTR,INDX) RETURNS(FIXED BIN(15,0)) OPTIONS(REENTRANT);
         DCL INSTR CHAR(*) VAR;
         DCL INDX FIXED BIN(15,0);
         DCL (I,J,K,L) FIXED BIN(15,0);
         I = INDX;
         K = 1;
         DO UNTIL(K = 0);
           L = INDEX(SUBSTR(INSTR,I+1),')')+I;
           IF L = I
             THEN RETURN(0); /* NO CLOSING PAREN */
           J = INDEX(SUBSTR(INSTR,I+1),'(')+I;
           IF J = I × J > L
             THEN DO; /* FOUND NEXT CLOSING PAREN */
             K = K - 1;
             I = L;
             END;
           ELSE DO; /* FOUND NEXT OPENING PAREN */
             K = K + 1;
             I = J;
             END;
           END;
         RETURN(I);
         END PSTR;
