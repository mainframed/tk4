 /* COPYRIGHT 1983 BY THOMAS GLEN SMITH */
 /* ABE061D - APL */
   %INCLUDE ABESUB;
 ABESUB(ABE061D) CHECK(YES) RECURS(YES)
   PARMS(RHPTR,RHHDRPT,PARMSPTR,SYMBOLS,SYMBOL_NAMES);
   %INCLUDE ABESUBA;

   DCL PARMSPTR PTR;
   DCL SYMBOLS(72) CHAR(3);
   DCL SYMBOL_NAMES(72) CHAR(14);
   DCL 1 PARMS_STRUCTURE BASED(PARMSPTR),
   %INCLUDE ABE061A;
   DCL ABE061E ENTRY;

   DO_BASE=DO_BASE_REAL;
   DO_BASE_NULL=DO_BASE_NULL_REAL;
   DO_GRADE=DO_GRADE_REAL;
   DO_INNER_PRODUCT=DO_INNER_PRODUCT_REAL;
   DO_MEMBERSHIP=DO_MEMBERSHIP_REAL;
   DO_TOP=DO_TOP_REAL;
   DO_TRANSPOSE=DO_TRANSPOSE_REAL;
   GET_ELEMENT_AXIS=GET_ELEMENT_AXIS_REAL;
   TAKE_DROP_COMMON=TAKE_DROP_COMMON_REAL;
   CALL ABE061E(RHPTR,RHHDRPT,PARMSPTR,SYMBOLS,SYMBOL_NAMES);

 DO_BASE_REAL: PROC;
 /**********************************************************************
 *                                                                     *
 * CALLED TO HANDLE BASE (DECODE).                                     *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT,TMP) PTR;
   DCL PRODUCT CHAR(13) INIT('DECODE');
   DCL CHARCHAR BIT(1) INIT('0'B);

   CALL GET_OPERANDS(PRODUCT,LEFT,RIGHT);
   IF LEFT=NULL × RIGHT=NULL
     THEN DO;
       MSGDATA='DECODE IS A DYADIC OPERATOR';
       SIGNAL CONDITION(BADAPL);
       END;
   IF LEFT->RH_APL->RH_APL_TYPE=CHAR_TYPE ×
     RIGHT->RH_APL->RH_APL_TYPE=CHAR_TYPE
     THEN DO;
       MSGDATA='DECODE ACCEPTS ONLY NUMERIC OPERANDS';
       SIGNAL CONDITION(BADAPL);
       END;
   I,J=MAX(LEFT->RH_APL->RH_APL_DIM(LEFT->RH_APL->RH_APL_RANK),
     RIGHT->RH_APL->RH_APL_DIM(1));
   TMP=DO_INNER_PRODUCT_COMMON(LEFT,RIGHT,'PLUS','PLUS',
     DO_BASE_LEFT_FUNCTION,DO_BASE_RIGHT_FUNCTION,CHARCHAR,PRODUCT);
   CALL END_OPER(LEFT,RIGHT,TMP);

   DO_BASE_LEFT_FUNCTION: PROC(NEXT,SEL) RETURNS(DEC FLOAT(16));
     DCL (NEXT,SEL) DEC FLOAT(16);
     RETURN(NEXT+SEL);
     END DO_BASE_LEFT_FUNCTION;

   DCL B DEC FLOAT(16);
   DCL (I,J) FIXED BIN;
   DO_BASE_RIGHT_FUNCTION: PROC(LFT,RHT) RETURNS(DEC FLOAT(16));
     DCL (LFT,RHT,RET) DEC FLOAT(16);
     J=J+1;
     IF J>I
       THEN DO;
         J=1;
         B=1;
         END;
     RET=RHT*B;
     B=B*LFT;
     RETURN(RET);
     END DO_BASE_RIGHT_FUNCTION;

   END DO_BASE_REAL;

 DO_BASE_NULL_REAL: PROC;
 /**********************************************************************
 *                                                                     *
 * CALLED TO HANDLE BASE NULL (EXECUTE).                               *
 *                                                                     *
 **********************************************************************/
   DCL (CBP,RIGHT,RPT,TMP) PTR;
   DCL CMD CHAR(1024) VAR;
   DCL (CIX,I,MIX) FIXED BIN;

   RIGHT=POP_OPERAND(OPERAND_STACK,OPERAND_COUNT); /* GET RIGHT OP */
   IF RIGHT=NULL
     THEN DO;
       MSGDATA='EXECUTE OPERATOR MUST HAVE A RIGHT OPERAND';
       SIGNAL CONDITION(BADAPL);
       END;
   CALL VECTOR_CHECK(RIGHT); /* MAKE SURE RIGHT SIDE IS A VECTOR */
   CMD='APL ';
   RPT=NULL;
   DO I=1 TO EL_CNT(RIGHT->RH_APL);
     CMD=CMD××GET_EL('FORWARD',RIGHT,RPT,CIX,MIX);
     END;
   IF CMD='APL'
     THEN DO;
       MSGDATA='ARGUMENT TO EXECUTE MUST BE NONBLANK';
       SIGNAL CONDITION(BADAPL);
       END;
   TMP=DO_APL_STMT(CMD);
   CALL END_OPER(NULL,RIGHT,TMP);
   END DO_BASE_NULL_REAL;

 DO_GRADE_REAL: PROC(OPERATOR);
 /**********************************************************************
 *                                                                     *
 * GRADE UP AND DOWN OPERATORS.                                        *
 *                                                                     *
 **********************************************************************/
   DCL OPERATOR CHAR(*);
   DCL (CBP,NBP,RIGHT,TMP,TMPI) PTR;
   DCL (I,J) FIXED BIN;
   DCL CMD CHAR(256) VAR;
   DCL OTYPETAB(7) CHAR(8) VAR STATIC INIT(
     'RB','$CHAR','','PD','N/A','N/A','IB');

   RIGHT=POP_OPERAND(OPERAND_STACK,OPERAND_COUNT); /* GET RIGHT OP */
   IF RIGHT=NULL
     THEN DO;
       MSGDATA=OPERATOR××' OPERATOR MUST HAVE A RIGHT OPERAND';
       SIGNAL CONDITION(BADAPL);
       END;
   IF OTYPETAB(RIGHT->RH_APL->RH_APL_TYPE)='N/A'
     THEN DO;
       MSGDATA='DON''T SUPPORT GRADE ON DATA TYPE '××
         TYPETAB(RIGHT->RH_APL->RH_APL_TYPE);
       SIGNAL CONDITION(BADAPL);
       END;
   CALL VECTOR_CHECK(RIGHT); /* MAKE SURE RIGHT SIDE IS A VECTOR */
   CBP=CREATE_APLCB(1); /* CREATE INTERMEDIATE VECTOR */
   CBP->RH_APL_TYPE=RIGHT->RH_APL->RH_APL_TYPE;
   CBP->RH_APL_ELEN=RIGHT->RH_APL->RH_APL_ELEN;
   CBP->RH_APL_DIM(1)=RIGHT->RH_APL->RH_APL_DIM(1);
   CBP->RH_APL_RHCOUNT=CBP->RH_APL_DIM(1);
   CBP->RH_APL_ELCOUNT=1;
   CBP->RH_APL_DEMARC=1;
   TMPI=CREATE_VAR(8+RIGHT->RH_APL->RH_APL_ELEN,CBP,'');
   CALL COPY_DATA(RIGHT,TMPI);
   I=#CMD('SR 8',TMPI,RHHDRPT);
   I=#CMD('USE FIXED @ 1 SQ RB8. @ 9 A '××
     OTYPETAB(RIGHT->RH_APL->RH_APL_TYPE)××
     BARENUM(RIGHT->RH_APL->RH_APL_ELEN)××'.',
     TMPI,RHHDRPT);
   I=#CMD('UPDATE SET SQ=SEQ',TMPI,RHHDRPT);
   CMD='ORDER BY A';
   IF OPERATOR='GRADE DOWN'
     THEN CMD=CMD××' DESC';
   I=#CMD(CMD,TMPI,RHHDRPT);
   CBP->RH_APL_TYPE=FLOAT_TYPE;
   CBP->RH_APL_ELEN=8;
   NBP=CREATE_APLCB(1); /* CREATE OUTPUT VECTOR */
   NBP->RH_APL_DIM(1)=CBP->RH_APL_DIM(1);
   NBP->RH_APL_ELCOUNT=CBP->RH_APL_DIM(1);
   NBP->RH_APL_RHCOUNT=1;
   TMP=CREATE_VAR(NBP->RH_APL_DIM(1)*NBP->RH_APL_ELEN,NBP,'');
   CALL COPY_DATA(TMPI,TMP);
   I=#CMD('END I',TMPI,RHHDRPT);
   CALL END_OPER(NULL,RIGHT,TMP);
   END DO_GRADE_REAL;

 DO_INNER_PRODUCT_REAL: PROC(RIGHT_FUNCTION_NAME,LEFT,RIGHT)
   RETURNS(PTR);
 /**********************************************************************
 *                                                                     *
 * INNER PRODUCT.                                                      *
 *                                                                     *
 **********************************************************************/
   DCL RIGHT_FUNCTION_NAME CHAR(*);
   DCL LEFT_FUNCTION_NAME CHAR(14);
   DCL (LEFT_FUNCTION,RIGHT_FUNCTION) VARIABLE
     ENTRY(DEC FLOAT(16), DEC FLOAT(16))
     RETURNS(DEC FLOAT(16));
   DCL (LEFT,RIGHT) PTR;
   DCL PRODUCT CHAR(13);
   DCL CHARCHAR BIT(1);

   CURTOK=PRIOR_TOKEN->PRIOR_TOKEN; /* POINT TO LEFT OPERATOR */
   IF CURTOK=NULL
     THEN DO;
       MSGDATA='INVALID SYNTAX FOR INNER PRODUCT';
       SIGNAL CONDITION(BADAPL);
       END;
   IF TYPE<=0
     THEN DO;
       MSGDATA='INVALID SYNTAX FOR INNER PRODUCT';
       SIGNAL CONDITION(BADAPL);
       END;
   LEFT_FUNCTION_NAME=SYMBOL_NAMES(TYPE);
   IF LEFT_FUNCTION_NAME='NULL'
     THEN PRODUCT='OUTER PRODUCT';
     ELSE PRODUCT='INNER PRODUCT';
   CALL GET_OPERANDS(PRODUCT,LEFT,RIGHT);
   IF LEFT=NULL × RIGHT=NULL
     THEN DO;
       MSGDATA=PRODUCT××' REQUIRES TWO ARGUMENTS';
       SIGNAL CONDITION(BADAPL);
       END;
   IF PRODUCT='INNER PRODUCT'
     THEN CALL DO_PRIMITIVE_DYADIC_ENT(LEFT_FUNCTION_NAME,
       LEFT_FUNCTION);
   CHARCHAR=(LEFT->RH_APL->RH_APL_TYPE=CHAR_TYPE &
     RIGHT->RH_APL->RH_APL_TYPE=CHAR_TYPE);
   IF CHARCHAR
     THEN
       CALL DO_PRIMITIVE_DYADIC_ECH(RIGHT_FUNCTION_NAME,RIGHT_FUNCTION);
     ELSE
       CALL DO_PRIMITIVE_DYADIC_ENT(RIGHT_FUNCTION_NAME,RIGHT_FUNCTION);
   RETURN(DO_INNER_PRODUCT_COMMON(LEFT,RIGHT,LEFT_FUNCTION_NAME,
     RIGHT_FUNCTION_NAME,LEFT_FUNCTION,RIGHT_FUNCTION,CHARCHAR,
     PRODUCT));
   END DO_INNER_PRODUCT_REAL;

 DO_INNER_PRODUCT_COMMON: PROC(LEFT,RIGHT,LEFT_FUNCTION_NAME,
   RIGHT_FUNCTION_NAME,LEFT_FUNCTION,RIGHT_FUNCTION,CHARCHAR,
   PRODUCT)
   RETURNS(PTR);
 /**********************************************************************
 *                                                                     *
 * INNER PRODUCT, DECODE AND ENCODE.                                   *
 *                                                                     *
 **********************************************************************/
   DCL RIGHT_FUNCTION_NAME CHAR(*);
   DCL LEFT_FUNCTION_NAME CHAR(14);
   DCL (LEFT_FUNCTION,RIGHT_FUNCTION) VARIABLE
     ENTRY(DEC FLOAT(16), DEC FLOAT(16))
     RETURNS(DEC FLOAT(16));
   DCL (LEFT,RIGHT,TMP) PTR;
   DCL (I,J,K,LAXIS,LCNT,M,N,P,R,RCNT) FIXED BIN;
   DCL OTYPE CHAR(8);
   DCL PRODUCT CHAR(13);
   DCL CHARCHAR BIT(1);

   LCNT=EL_CNT(LEFT->RH_APL);
   RCNT=EL_CNT(RIGHT->RH_APL);
   LAXIS=LEFT->RH_APL->RH_APL_RANK;
   I=LEFT->RH_APL->RH_APL_RANK+RIGHT->RH_APL->RH_APL_RANK;
   IF PRODUCT='INNER PRODUCT' × PRODUCT='DECODE'
     THEN DO;
       I=I-2;
       IF LEFT->RH_APL->RH_APL_DIM(LAXIS)^=
         RIGHT->RH_APL->RH_APL_DIM(1)
         THEN IF ^(LCNT=1 × RCNT=1)
           THEN DO;
             MSGDATA='SHAPES DISAGREE FOR '××PRODUCT;
             CALL END_OPER(LEFT,RIGHT,TMP);
             SIGNAL CONDITION(BADAPL);
             END;
       END;
   IF PRODUCT='ENCODE'
     THEN DO;
       IF LEFT->RH_APL->RH_APL_SCALAR
         THEN I=I-1;
       IF RIGHT->RH_APL->RH_APL_SCALAR
         THEN I=I-1;
       END;
   CBP=CREATE_APLCB(MAX(1,I));
   OTYPE=TYPETAB(CBP->RH_APL_TYPE);
   J,R=1; /* WILL BE # ELEMENTS/RECORD, R W/B #RECS */
   IF I=0
     THEN DO;
       CBP->RH_APL_SCALAR='1'B;
       CBP->RH_APL_DIM(1)=1;
       END;
     ELSE DO;
       IF PRODUCT='INNER PRODUCT' × PRODUCT='DECODE'
         THEN P=1;
         ELSE P=0;
       IF LAXIS>P
         THEN DO K=1 TO LAXIS-P;
           CBP->RH_APL_DIM(K)=LEFT->RH_APL->RH_APL_DIM(K);
           IF K>CBP->RH_APL_DEMARC
             THEN J=J*CBP->RH_APL_DIM(K);
             ELSE R=R*CBP->RH_APL_DIM(K);
           END;
       IF RIGHT->RH_APL->RH_APL_RANK>P
         THEN DO;
           M=P; /* M IS INDEX TO RIGHT */
           DO K=K TO CBP->RH_APL_RANK;
             M=M+1;
             CBP->RH_APL_DIM(K)=RIGHT->RH_APL->RH_APL_DIM(M);
             IF K>CBP->RH_APL_DEMARC
               THEN J=J*CBP->RH_APL_DIM(K);
               ELSE R=R*CBP->RH_APL_DIM(K);
             END;
           END;
       END;
   CBP->RH_APL_RHCOUNT=R;
   CBP->RH_APL_ELCOUNT=J;
   TMP=CREATE_VAR(J*CBP->RH_APL_ELEN,CBP,''); /* OUTPUT DATASET */
   J=J*R; /* J=# ELEMENTS IN OUTPUT DATA SET */
   IF J>0
     THEN CALL DO_INNER_PRODUCT_SUB(PRODUCT,J,TMP,LEFT,RIGHT,
       LEFT_FUNCTION,LEFT_FUNCTION_NAME,
       RIGHT_FUNCTION,RIGHT_FUNCTION,RIGHT_FUNCTION_NAME,
       LCNT,RCNT,LAXIS,OTYPE,CHARCHAR);
   RETURN(TMP);
   END DO_INNER_PRODUCT_COMMON;

 DO_INNER_PRODUCT_SUB: PROC(PRODUCT,NOUT,TMP,LEFT,RIGHT,
   LEFT_FUNCTION,LEFT_FUNCTION_NAME,
   RIGHT_FUNCTION,RIGHT_FUNCTIONCH,RIGHT_FUNCTION_NAME,
   LCNT,RCNT,LAXIS,OTYPE,CHARCHAR);
 /**********************************************************************
 *                                                                     *
 * CALLED TO COMPLETE INNER PRODUCT PROCESSING AFTER ALL THE INITIAL   *
 * SETUP HAS BEEN DONE.                                                *
 *                                                                     *
 **********************************************************************/
   DCL PRODUCT CHAR(13);
   DCL (TMP,LEFT,LIXW,OIXW,RIGHT,RIXW) PTR;
   DCL (LEFT_FUNCTION,RIGHT_FUNCTION) VARIABLE
     ENTRY(DEC FLOAT(16), DEC FLOAT(16))
     RETURNS(DEC FLOAT(16));
   DCL RIGHT_FUNCTIONCH VARIABLE
     ENTRY(CHAR(*) VAR, CHAR(*) VAR)
     RETURNS(DEC FLOAT(16));
   DCL (LEFT_FUNCTION_NAME,RIGHT_FUNCTION_NAME) CHAR(*);
   DCL OTYPE CHAR(8);
   DCL (A,BUMP,I,J,K,LAXIS,LCNT,M,N,NCUR,NOUT,OCIX,OMIX,RAXIS,RCNT)
     FIXED BIN;
   DCL (LEL,NEXT,REL,SEL)  DEC FLOAT(16),
     LELDF CHAR(8) BASED(ADDR(LEL)),
     RELDF CHAR(8) BASED(ADDR(REL));
   DCL (LELCH,RELCH) CHAR(256) VAR;
   DCL CHARCHAR BIT(1);
   DCL LVAL DEC FLOAT(16),
       LSTR CHAR(8) BASED(ADDR(LVAL)),
       RVAL DEC FLOAT(16),
       RSTR CHAR(8) BASED(ADDR(RVAL));

   L=LEFT->RH_APL->RH_APL_RANK;
   ALLOCATE IXW SET(LIXW);
   LIXW->IXWRHP=LEFT;
   LIXW->IXWROW=MISSING_INTEGER;
   L=RIGHT->RH_APL->RH_APL_RANK;
   ALLOCATE IXW SET(RIXW);
   RIXW->IXWRHP=RIGHT;
   RIXW->IXWROW=MISSING_INTEGER;
   IF PRODUCT='ENCODE'
     THEN DO;
       L=CBP->RH_APL_RANK;
       ALLOCATE IXW SET(OIXW);
       OIXW->IXWRHP=TMP;
       OIXW->IXWROW=MISSING_INTEGER;
       RAXIS=RIGHT->RH_APL->RH_APL_RANK;
       NCUR=0;
       DO UNTIL(NCUR=NOUT);
         DO I=1 TO RCNT;
           CALL GET_ELEMENT_AXIS(RIXW,1,-1,1,-1);
           RELCH=GET_ELEMENT(RIXW);
           RELDF=CONVERT(PTROUT(PTRIN(ADDR(RELCH))+2),
             TYPETAB(RIGHT->RH_APL->RH_APL_TYPE),LENGTH(RELCH),0,
             'FLOAT',8,0);
           DO J=LEFT->RH_APL->RH_APL_DIM(1) TO 1 BY -1;
             CALL GET_ELEMENT_AXIS(LIXW,1,-1,1,-1);
             LELCH=GET_ELEMENT(LIXW);
             LELDF=CONVERT(PTROUT(PTRIN(ADDR(LELCH))+2),
               TYPETAB(LEFT->RH_APL->RH_APL_TYPE),LENGTH(LELCH),0,
               'FLOAT',8,0);
             SEL=RIGHT_FUNCTION(LEL,REL);
             CALL GET_ELEMENT_AXIS(OIXW,1,-1,1,-1);
             CALL PUT_ELEMENT(
               CONVERT(ADDR(SEL),'FLOAT',8,0,OTYPE,CBP->RH_APL_ELEN,0),
               OIXW);
             NCUR=NCUR+1;
             END;
           END;
         END;
       FREE OIXW->IXW;
       END;
     ELSE DO; /* IT IS INNER OR OUTER PRODUCT, OR DECODE */
       N=MAX(LEFT->RH_APL->RH_APL_DIM(LEFT->RH_APL->RH_APL_RANK),
             RIGHT->RH_APL->RH_APL_DIM(1)); /* # EL EACH SUB-VECTOR */
       IF N=0
         THEN SEL=DYADIC_SCALAR_IDENTITY(RIGHT_FUNCTION_NAME);
         ELSE IF PRODUCT='OUTER PRODUCT'
           THEN N=1;
       BUMP=1;
       K=0;
       IF PRODUCT='INNER PRODUCT' × PRODUCT='DECODE'
         THEN M=-1;
         ELSE M=+1;
       DO I=1 TO NOUT; /* LOOP ONCE FOR EACH OUTPUT ELEMENT */
         IF N^=0
           THEN DO J=1 TO N;
             IF PRODUCT='INNER PRODUCT' × BUMP=1
               THEN DO;
                 CALL GET_ELEMENT_AXIS(LIXW,LAXIS,M,LAXIS,BUMP);
                 LELCH=GET_ELEMENT(LIXW);
                 END;
             CALL GET_ELEMENT_AXIS(RIXW,1    ,M,1,1);
             RELCH=GET_ELEMENT(RIXW);
             K=K+1;
             IF K=RCNT
               THEN DO;
                 K=0;
                 BUMP=1;
                 END;
               ELSE BUMP=0;
             IF CHARCHAR
               THEN NEXT=RIGHT_FUNCTIONCH(LELCH,RELCH);
               ELSE DO;
                 LSTR=CONVERT(PTROUT(PTRIN(ADDR(LELCH))+2),
                   TYPETAB(LIXW->IXWRHP->RH_APL->RH_APL_TYPE),
                   LENGTH(LELCH),0,'FLOAT',8,0);
                 RSTR=CONVERT(PTROUT(PTRIN(ADDR(RELCH))+2),
                   TYPETAB(RIXW->IXWRHP->RH_APL->RH_APL_TYPE),
                   LENGTH(RELCH),0,'FLOAT',8,0);
                 NEXT=RIGHT_FUNCTION(LVAL,RVAL);
                 END;
             IF J=1 × PRODUCT='OUTER PRODUCT'
               THEN SEL=NEXT;
               ELSE SEL=LEFT_FUNCTION(NEXT,SEL);
             END;
         CALL PUT_EL(
           CONVERT(ADDR(SEL),'FLOAT',8,0,OTYPE,CBP->RH_APL_ELEN,0),
           TMP,OCIX,OMIX);
         END;
       END;
   FREE LIXW->IXW;
   FREE RIXW->IXW;
   END DO_INNER_PRODUCT_SUB;

 DO_MEMBERSHIP_REAL: PROC;
 /**********************************************************************
 *                                                                     *
 * CALLED FROM MAIN_LINE TO PROCESS DYADIC MEMBERSHIP (EPSILON).       *
 *                                                                     *
 **********************************************************************/
   DCL (CBP,LEFT,LRPT,RIGHT,RPT,RRPT,TMP) PTR;
   DCL (I,J,K,LCIX,LMIX,OCIX,OMIX,R,RCIX,RCNT,RMIX) FIXED BIN;
   DCL (LCHAR,RCHAR) CHAR(256) VAR;
   DCL (LNUM,RNUM) DEC FLOAT(16);
   DCL EL DEC FLOAT(16),
       ELCH CHAR(8) BASED(ADDR(EL));
   DCL CHARCHAR BIT(1);

   CALL GET_OPERANDS('MEMBERSHIP',LEFT,RIGHT);
   IF LEFT=NULL
     THEN DO;
       MSGDATA='EPSILON/MEMBERSHIP IS A DYADIC OPERATOR';
       SIGNAL CONDITION(BADAPL);
       END;
   IF LEFT->RH_APL->RH_APL_TYPE=CHAR_TYPE &
     RIGHT->RH_APL->RH_APL_TYPE=CHAR_TYPE
     THEN CHARCHAR='1'B; /* BOTH OPERANDS ARE CHARACTER */
     ELSE CHARCHAR='0'B; /* ONE OR BOTH ARE NOT CHAR - CONVERT TO NUM */
   CBP=CREATE_APLCB(LEFT->RH_APL->RH_APL_RANK);
   STRING(CBP->RH_APL_FLAGS)=STRING(LEFT->RH_APL->RH_APL_FLAGS);
   CBP->RH_APL_TYPE=FLOAT_TYPE;
   CBP->RH_APL_ELEN=8;
   J,K,R=1;
   DO I=1 TO LEFT->RH_APL->RH_APL_RANK;
     CBP->RH_APL_DIM(I)=LEFT->RH_APL->RH_APL_DIM(I);
     J=J*CBP->RH_APL_DIM(I);
     IF I>LEFT->RH_APL->RH_APL_DEMARC
       THEN K=K*CBP->RH_APL_DIM(I);
       ELSE R=R*CBP->RH_APL_DIM(I);
     END;
   /* J = COUNT OF OUTPUT ELEMENTS */
   /* K = COUNT OF OUTPUT ELEMENTS EACH RECORD */
   /* R = COUNT OF OUTPUT RECORDS */
   CBP->RH_APL_RHCOUNT=R;
   CBP->RH_APL_ELCOUNT=K;
   TMP=CREATE_VAR(K*CBP->RH_APL_ELEN,CBP,'');
   IF J>0
     THEN DO; /* OUTPUT IS NOT EMPTY */
       LRPT,RPT=NULL;
       RCNT=EL_CNT(RIGHT->RH_APL); /* COUNT ELEMENTS RIGHT OPERAND */
       DO I=1 TO J; /* THERE ARE ELEMENTS TO PROCESS */
         RRPT=NULL;
         IF CHARCHAR
           THEN DO;
             LCHAR=GET_EL('FORWARD',LEFT,LRPT,LCIX,LMIX);
             DO K=1 TO RCNT
               UNTIL(LCHAR=GET_EL('FORWARD',RIGHT,RRPT,RCIX,RMIX));
               END;
             END;
           ELSE DO;
             LNUM=GET_SCALAR_SEQ('FORWARD',LEFT,RPT,CIX,MIX);
             DO K=1 TO RCNT
               UNTIL(LNUM=GET_SCALAR_SEQ('FORWARD',RIGHT,RRPT,RCIX,
                 RMIX));
               END;
             END;
         IF K>RCNT
           THEN EL=0;
           ELSE EL=1;
         CALL PUT_EL(ELCH,TMP,OCIX,OMIX);
         END;
       END;
   CALL END_OPER(LEFT,RIGHT,TMP); /* FINISH UP */
   END DO_MEMBERSHIP_REAL;

 DO_TOP_REAL: PROC;
 /**********************************************************************
 *                                                                     *
 * CALLED TO HANDLE TOP (ENCODE).                                      *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT,TMP) PTR;
   DCL PRODUCT CHAR(13) INIT('ENCODE');
   DCL CHARCHAR BIT(1) INIT('0'B);

   CALL GET_OPERANDS(PRODUCT,LEFT,RIGHT);
   IF LEFT=NULL × RIGHT=NULL
     THEN DO;
       MSGDATA='ENCODE IS A DYADIC OPERATOR';
       SIGNAL CONDITION(BADAPL);
       END;
   IF LEFT->RH_APL->RH_APL_TYPE=CHAR_TYPE ×
     RIGHT->RH_APL->RH_APL_TYPE=CHAR_TYPE
     THEN DO;
       MSGDATA='DECODE ACCEPTS ONLY NUMERIC OPERANDS';
       SIGNAL CONDITION(BADAPL);
       END;
   TMP=DO_INNER_PRODUCT_COMMON(LEFT,RIGHT,'PLUS','PLUS',
     DO_TOP_LEFT_FUNCTION,DO_TOP_RIGHT_FUNCTION,CHARCHAR,PRODUCT);
   CALL END_OPER(LEFT,RIGHT,TMP);

   DO_TOP_LEFT_FUNCTION: PROC(NEXT,SEL) RETURNS(DEC FLOAT(16));
     DCL (NEXT,SEL) DEC FLOAT(16);
     RETURN(NEXT+SEL);
     END DO_TOP_LEFT_FUNCTION;

   DO_TOP_RIGHT_FUNCTION: PROC(LFT,RHT) RETURNS(DEC FLOAT(16));
     DCL (LFT,RHT,RET) DEC FLOAT(16);
     IF LFT=0
       THEN RET=RHT;
       ELSE DO;
         RET=RHT-LFT*FLOOR(RHT/(LFT+(LFT=0)));
         RHT=(RHT-RET)/LFT;
         END;
     RETURN(RET);
     END DO_TOP_RIGHT_FUNCTION;

   END DO_TOP_REAL;

 DO_TRANSPOSE_REAL: PROC;
 /**********************************************************************
 *                                                                     *
 * CALLED FROM MAIN_LINE TO PROCESS DYADIC AND MONADIC TRANSPOSE.      *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT,TMP) PTR;
   DCL I FIXED BIN;

   CALL GET_OPERANDS('TRANSPOSE',LEFT,RIGHT);
   IF LEFT=NULL
     THEN TMP=DO_TRANSPOSE_MONADIC(RIGHT);
     ELSE TMP=DO_TRANSPOSE_DYADIC(LEFT,RIGHT);
   CALL END_OPER(LEFT,RIGHT,TMP); /* FINISH UP */
   END DO_TRANSPOSE_REAL;

 DO_TRANSPOSE_DYADIC: PROC(LEFT,RIGHT) RETURNS(PTR);
 /**********************************************************************
 *                                                                     *
 * CALLED TO PROCESS DYADIC TRANSPOSE.                                 *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,LFT,RHT,RIGHT,RPT,TMP) PTR;
   DCL (CIX,I,J,K,LCNT,MIX) FIXED BIN;
   DCL (LFLOAT,NEXT)  DEC FLOAT(16);

   CALL VECTOR_CHECK(LEFT); /* MAKE SURE LEFT SIDE IS A VECTOR */
   L,LCNT=LEFT->RH_APL->RH_APL_DIM(1);
   IF LCNT^=RIGHT->RH_APL->RH_APL_RANK
     THEN DO;
       MSGDATA='LEFT ARGUMENT TO TRANSPOSE DOESN''T CONFORM';
       SIGNAL CONDITION(BADAPL);
       END;
   ALLOCATE IXW SET(LFT);
   LFT->IXWRHP=LEFT;
   LFT->IXWROW=MISSING_INTEGER;
   ALLOCATE IXW SET(RHT);
   RHT->IXWRHP=RIGHT;
   RHT->IXWROW=MISSING_INTEGER;
   RHT->IX(*)=-1;
   RPT=NULL;
   K=0;
   LFLOAT=L;
   DO I=1 TO LCNT;
     NEXT=GET_SCALAR_SEQ('FORWARD',LEFT,RPT,CIX,MIX);
     IF MOD(NEXT,1.0)^=0.0 × NEXT<1.0 × NEXT>LFLOAT
       THEN DO;
         MSGDATA='LEFT ARG. TO TRANSPOSE IS INVALID NUMBER';
         SIGNAL CONDITION(BADAPL);
         END;
     J=NEXT;
     LFT->IX(I)=J;
     IF RHT->IX(J)=-1
       THEN RHT->IX(J)=RIGHT->RH_APL->RH_APL_DIM(I);
       ELSE RHT->IX(J)=MIN(RHT->IX(J),RIGHT->RH_APL->RH_APL_DIM(I));
     K=MAX(K,J); /* K WILL BE THE HIGHEST INDEX VALUE HIT */
     END;
   DO I=1 TO K;
     IF RHT->IX(I)=-1
       THEN DO;
         MSGDATA='LEFT ARG. TO TRANSPOSE IS NOT COMPLETE';
         SIGNAL CONDITION(BADAPL);
         END;
     END;
   RETURN(DO_TRANSPOSE_DYADIC_SUB(RIGHT,LFT,RHT,K));
   END DO_TRANSPOSE_DYADIC;

 DO_TRANSPOSE_DYADIC_SUB: PROC(RIGHT,LFT,RHT,K) RETURNS(PTR);
 /**********************************************************************
 *                                                                     *
 * CALLED TO PROCESS DYADIC TRANSPOSE AFTER LEFT ARGUMENT HAS BEEN     *
 * PROCESSED.  LFT AND RHT WILL BOTH BE IXW STRUCTURES OF LENGTH EQUAL *
 * TO THE RANK OF THE RIGHT ARGUMENT.  LFT->IX WILL BE FILLED IN WITH  *
 * ALL THE VALUES FROM THE LEFT ARGUMENT (OR THE DEFAULT IN THE CASE   *
 * OF MONADIC TRANSPOSE).  K WILL CONTAIN THE RANK OF THE VARIABLE TO  *
 * BE PRODUCED AS OUTPUT FROM TRANSPOSE.  RHT->IX(1) THRU RHT->IX(K)   *
 * WILL CONTAIN THE DIMENSIONS OF THE VARIABLE TO BE PRODUCED AS       *
 * OUTPUT FROM TRANSPOSE.                                              *
 *                                                                     *
 **********************************************************************/
   DCL (LFT,OUT,RIGHT,RHT,CBP,TMP) PTR;
   DCL (I,J,K,M,OCIX,OMIX,R) FIXED BIN;

   CBP=CREATE_APLCB(K);
   STRING(CBP->RH_APL_FLAGS)=STRING(RIGHT->RH_APL->RH_APL_FLAGS);
   CBP->RH_APL_TYPE=RIGHT->RH_APL->RH_APL_TYPE;
   CBP->RH_APL_ELEN=RIGHT->RH_APL->RH_APL_ELEN;
   J,M,R=1;
   DO I=1 TO K;
     CBP->RH_APL_DIM(I)=RHT->IX(I);
     J=J*CBP->RH_APL_DIM(I);
     IF I>CBP->RH_APL_DEMARC
       THEN M=M*CBP->RH_APL_DIM(I);
       ELSE R=R*CBP->RH_APL_DIM(I);
     END;
   /* J NOW EQUALS COUNT OF OUTPUT ELEMENTS */
   /* M NOW EQUALS COUNT OF OUTPUT ELEMENTS PER RECORD */
   /* R NOW EQUALS COUNT OF OUTPUT RECORDS */
   CBP->RH_APL_RHCOUNT=R;
   CBP->RH_APL_ELCOUNT=M;
   TMP=CREATE_VAR(M*CBP->RH_APL_ELEN,CBP,'');
   L=K;
   ALLOCATE IXW SET(OUT);
   OUT->IXWRHP=TMP;
   OUT->IXWROW=MISSING_INTEGER;
   DO I=1 TO J;
     CALL GET_ELEMENT_AXIS(OUT,K,1,K,1);
     OUT->IXWROW=0; /* PREVENT RE-INITILIZATION IN GET_ELEMENT_AXIS */
     DO M=1 TO RHT->IXL;
       RHT->IX(M)=OUT->IX(LFT->IX(M));
       END;
     CALL PUT_EL(GET_ELEMENT(RHT),TMP,OCIX,OMIX);
     END;
   FREE LFT->IXW;
   FREE RHT->IXW;
   FREE OUT->IXW;
   RETURN(TMP);
   END DO_TRANSPOSE_DYADIC_SUB;

 DO_TRANSPOSE_MONADIC: PROC(RIGHT) RETURNS(PTR);
 /**********************************************************************
 *                                                                     *
 * CALLED TO PROCESS MONADIC TRANSPOSE.                                *
 *                                                                     *
 **********************************************************************/
   DCL (LFT,RHT,RIGHT) PTR;
   DCL (I,J) FIXED BIN;

   L=RIGHT->RH_APL->RH_APL_RANK;
   ALLOCATE IXW SET(LFT);
   LFT->IXWRHP=NULL;
   LFT->IXWROW=MISSING_INTEGER;
   ALLOCATE IXW SET(RHT);
   RHT->IXWRHP=RIGHT;
   RHT->IXWROW=MISSING_INTEGER;
   DO I=1 TO L;
     J=L-I+1;
     LFT->IX(I)=J;
     RHT->IX(I)=RIGHT->RH_APL->RH_APL_DIM(J);
     END;
   RETURN(DO_TRANSPOSE_DYADIC_SUB(RIGHT,LFT,RHT,L));
   END DO_TRANSPOSE_MONADIC;

 GET_ELEMENT_AXIS_REAL: PROC(W,AXIS,SEQ,QDIM,BUMP);
 /**********************************************************************
 *                                                                     *
 * CALLED TO SEQUENTIALLY PROCESS ELEMENTS FROM A NON-EMPTY VARIABLE BY*
 * THE SPECIFIED AXIS NUMBER.  PARAMETER W SHOULD POINT TO A STRUCTURE *
 * DESCRIBED BY THE DCL FOR BASED VARIABLE IXW.  IXWROW IN IXW         *
 * SHOULD BE INITIALIZED TO MISSING_INTEGER.  QDIM DETERMINES THE      *
 * DIMENSION WHICH IS TO BE INCREMENTED MOST RAPIDLY.  BUMP SHOULD BE  *
 * SET BY THE USER TO EITHER 0, 1, OR -1 DEPENDING ON WHETHER YOU WANT *
 * TO CYCLE ON JUST THE QDIM DIMENSION OR NOT (0=CYCLE, 1=FORWARD      *
 * PROCESSING, -1=BACKWARD PROCESSING.                                 *
 *   NOTE THAT THE AXIS DIMENSION WILL BE PROCESSED EITHER             *
 * FRONT-TO-BACK OR BACK-TO-FRONT DEPENDING ON THE VALUE OF ARGUMENT   *
 * SEQ, +1 OR -1 RESPECTIVELY.  ALL OTHER DIMENSIONS ARE PROCESSED     *
 * ACCORDING TO THE SETTING OF BUMP.                                   *
 *   TO HELP UNDERSTAND HOW THIS ROUTINE WORKS, IMAGINE A 3-DIMENSIONAL*
 * ARRAY, A#2 2 2RI8, AS FOLLOWS:                                      *
 *                                                                     *
 *                           ________________                          *
 *                          /       /       /\                         *
 *                         /       /       /  \                        *
 *                        /  5    /   6   /    \                       *
 *                       /       /       /      \                      *
 *                      /       /       /        \                     *
 *      2D AXIS        /_______/_______/     6    \                    *
 *           \        /       /       / \         /\                   *
 *            \      /       /       /   \       /  \                  *
 *             \    /   1   /   2   /     \     /    \                 *
 *                 /       /       /       \   /      \                *
 * 3RD AXIS ___   /_______/_______/         \ /        \               *
 *                \       \       \    2     \    8    /               *
 *                 \       \       \        / \       /                *
 *                  \       \       \      /   \     /                 *
 *            /      \  1    \   2   \    /     \   /                  *
 *           /        \       \       \  /       \ /                   *
 *          /          \_______\_______\/    4    /                    *
 *         1ST AXIS     \       \       \        /                     *
 *                       \       \       \      /                      *
 *                        \  3    \   4   \    /                       *
 *                         \       \       \  /                        *
 *                          \_______\_______\/                         *
 *                                                                     *
 * apl +/{1}a produces  6  8                                           *
 *                     10 12                                           *
 *                                                                     *
 * apl +/{2}a produces  4  6                                           *
 *                     12 14                                           *
 *                                                                     *
 * apl +/{3}a produces  3  7                                           *
 *                     11 15                                           *
 *                                                                     *
 *                                                                     *
 * FOLLOWING IS A TABLE SHOWING VARIOUS COMBINATIONS OF PARAMETER      *
 * VALUES, AND THE RESULTING ORDER IN WHICH ELEMENTS OF THE ABOVE      *
 * ARRAY WOULD BE RETURNED:                                            *
 *                                                                     *
 *          AXIS                                                       *
 *          × SEQ                                                      *
 *          ×  × QDIM                                                  *
 *          ×  ×  × BUMP                                               *
 *          ×  ×  ×  ×   ORDER OF                                      *
 *          V  V  V  V    RETURN                                       *
 *          ____________ ________                                      *
 *         (1  1  1  1)  15263748 1ST AXIS, FORWARD SEQUENCE           *
 *         (2  1  2  1)  13245768 2D  AXIS, FORWARD SEQUENCE           *
 *         (3  1  3  1)  12345678 3RD AXIS, FORWARD SEQUENCE           *
 *         (1 -1  1 -1)  84736251 1ST AXIS, REVERSE SEQUENCE           *
 *         (2 -1  2 -1)  86754231 2D  AXIS, REVERSE SEQUENCE           *
 *         (3 -1  3 -1)  87654321 3RD AXIS, REVERSE SEQUENCE           *
 *         (1 -1  1  1)  51627384                                      *
 *         (1 -1  2  1)  57681324                                      *
 *         (1 -1  3  1)  56781234                                      *
 *         (2 -1  1  1)  37481526                                      *
 *         (2 -1  2  1)  31427586                                      *
 *         (2 -1  3  1)  34127856                                      *
 *         (3 -1  1  1)  26154837                                      *
 *         (3 -1  2  1)  24136857                                      *
 *         (3 -1  3  1)  21436587                                      *
 *         (1  1  1 -1)  48372615                                      *
 *         (1  1  2 -1)  42318675                                      *
 *         (1  1  3 -1)  43218765                                      *
 *         (2  1  1 -1)  62518473                                      *
 *         (2  1  2 -1)  68572413                                      *
 *         (2  1  3 -1)  65872143                                      *
 *         (3  1  1 -1)  73845162                                      *
 *         (3  1  2 -1)  75863142                                      *
 *         (3  1  3 -1)  78563412                                      *
 *         (1  1  2  1)  13245768                                      *
 *         (1  1  3  1)  12345678                                      *
 *         (2  1  1  1)  15263748                                      *
 *         (2  1  3  1)  12345678                                      *
 *         (3  1  1  1)  15263748                                      *
 *         (3  1  2  1)  13245768                                      *
 *                                                                     *
 * FOLLOWING IS A 2X2 ARRAY, AND A TABLE OF VARIOUS PROCESSING         *
 * SEQUENCES:                                                          *
 *                                                                     *
 * _________                                                           *
 * ×   ×   ×                                                           *
 * × 1 × 2 ×                                                           *
 * ×___×___×                                                           *
 * ×   ×   ×                                                           *
 * × 3 × 4 ×                                                           *
 * ×___×___×                                                           *
 *         `                                                           *
 *         (1  1  1  1) 1324 1ST AXIS, FORWARD SEQUNCE                 *
 *         (2  1  2  1) 1234 2D  AXIS, FORWARD SEQUENCE                *
 *         (1 -1  1 -1) 4231 1ST AXIS, REVERSE SEQUENCE                *
 *         (2 -1  2 -1) 4321 2D  AXIS, REVERSE SEQUENCE                *
 *         (1 -1  1  1) 3142                                           *
 *         (1 -1  2  1) 3412                                           *
 *         (2 -1  1  1) 2413                                           *
 *         (2 -1  2  1) 2143                                           *
 *                                                                     *
 **********************************************************************/
   DCL W PTR;
   DCL (AXIS,BUMP,I,J,QDIM,SEQ) FIXED BIN;

   IF W->IXWROW=MISSING_INTEGER
     THEN DO;
       IF BUMP>=0
         THEN W->IX(*)=1;
         ELSE DO I=1 TO W->IXL;
           W->IX(I)=W->IXWRHP->RH_APL->RH_APL_DIM(I);
           END;
       IF SEQ>=0
         THEN W->IX(AXIS)=1;
         ELSE W->IX(AXIS)=W->IXWRHP->RH_APL->RH_APL_DIM(AXIS);
       END;
     ELSE DO;
       IF QDIM=AXIS
         THEN W->IX(QDIM)=W->IX(QDIM)+SEQ;
         ELSE W->IX(QDIM)=W->IX(QDIM)+BUMP;
       IF (W->IX(QDIM) > W->IXWRHP->RH_APL->RH_APL_DIM(QDIM)) ×
         (W->IX(QDIM) < 1)
         THEN DO; /* TIME TO START A NEW SUB-VECTOR */
           IF (QDIM=AXIS & SEQ>=0) × (QDIM^=AXIS & BUMP>=0)
             THEN W->IX(QDIM)=1;
             ELSE W->IX(QDIM)=W->IXWRHP->RH_APL->RH_APL_DIM(QDIM);
           J=BUMP;
           DO I=W->IXL TO 1 BY -1 WHILE(J^=0);
             IF I^=QDIM
               THEN DO;
                 IF I=AXIS
                   THEN W->IX(I)=W->IX(I)+SEQ;
                   ELSE W->IX(I)=W->IX(I)+J;
                 IF (W->IX(I) > W->IXWRHP->RH_APL->RH_APL_DIM(I)) ×
                   (W->IX(I) < 1)
                   THEN IF (I=AXIS & SEQ>=0) × (I^=AXIS & BUMP>=0)
                     THEN W->IX(I)=1;
                     ELSE W->IX(I)=W->IXWRHP->RH_APL->RH_APL_DIM(I);
                   ELSE J=0;
                 END;
             END;
           END;
       END;
   END GET_ELEMENT_AXIS_REAL;

 PUT_EL_REV: PROC(EL,RHP,CIX,MIX);
 /**********************************************************************
 *                                                                     *
 * CALLED TO STORE THE NEXT ELEMENT, EL, IN THE DATASET POINTED TO BY  *
 * RHP.  CIX AND MIX ARE USED INTERNALLY, AND SHOULD NOT BE CHANGED BY *
 * THE CALLER FROM ONE INVOCATION TO THE NEXT.  RHP SHOULD INITIALLY   *
 * POINT TO AN EMPTY DATA SET.                                         *
 *                                                                     *
 * THIS SUBROUTINE DIFFERS FROM SUBROUTINE PUT_EL IN THAT PUT_EL_REV   *
 * STORES ELEMENTS IN THE OUTPUT DATA SET INCREMENTING THE FIRST       *
 * DIMENSION MOST RAPIDLY IN REVERSE SEQUENCE (FROM HIGHEST TO LOWEST) *
 * WHEREAS PUT_EL INCREMENTS THE LAST DIMENSION MOST RAPIDLY IN        *
 * REGULAR SEQUENCE (FROM LOWEST TO HIGHEST).                          *
 *                                                                     *
 **********************************************************************/
   DCL EL CHAR(*) VAR;
   DCL RHP PTR;
   DCL (CIX,MIX) FIXED BIN;
   DCL (I,LEN,OFF) FIXED BIN;

   IF RHP->RECPTR=RHP
     THEN DO; /* IT IS INITIALIZATION TIME */
       MIX=RHP->RH_APL->RH_APL_RHCOUNT;
       /* MIX=NUMBER OF RECORDS TO GENERATE */
       CIX=RHP->RH_APL->RH_APL_ELCOUNT;
       I=#CMD('0 BL 1',RHP,RHHDRPT);
       I=#CMD('TOP',RHP,RHHDRPT);
       END;
     ELSE DO;
       MIX=MIX-1; /* GET INDEX TO NEXT RECORD */
       IF MIX<1
         THEN DO; /* CYCLE BACK TO LAST RECORD */
           MIX=RHP->RH_APL->RH_APL_RHCOUNT;
           /* MIX=NUMBER OF RECORDS TO GENERATE */
           IF MIX>1
             THEN I=#CMD('B V',RHP,RHHDRPT);
           CIX=CIX-1;
           END;
         ELSE IF RHP->RECPTR->LSTPTR=RHP
           THEN DO;
             I=#CMD('0 BL 1',RHP,RHHDRPT);
             I=#CMD('TOP',RHP,RHHDRPT);
             END;
           ELSE I=#CMD('*-1 V',RHP,RHHDRPT);
       END;
   OFF=(CIX-1)*RHP->RH_APL->RH_APL_ELEN+1;
   CALL PUT_EL_SUB(EL,RHP,RHP->RECPTR,
     (CIX-1)*RHP->RH_APL->RH_APL_ELEN,RHP->RH_APL->RH_APL_ELEN);
   END PUT_EL_REV;

 TAKE_DROP_COMMON_REAL: PROC(OPNAME);
 /**********************************************************************
 *                                                                     *
 * CALLED FROM TAKE AND DROP ROUTINES TO DO COMMON INITIALIZATION      *
 * PROCESSING. OPNAME SHOULD SAY EITHER 'TAKE' OR 'DROP'.              *
 *                                                                     *
 **********************************************************************/
   DCL OPNAME CHAR(4);
   DCL (CBP,LEFT,LFT,RHT,RIGHT,RPT,TMP,TO) PTR;
   DCL (CIX,I,J,K,M,MIX,N,P,R) FIXED BIN;
   DCL (DFT,WRK) CHAR(256) VAR;
   DCL ZEROCON CHAR(1) STATIC INIT('0');

   CALL GET_OPERANDS(OPNAME,LEFT,RIGHT);
   IF LEFT=NULL × RIGHT=NULL
     THEN DO;
       MSGDATA=OPNAME××' REQUIRES TWO ARGUMENTS';
       SIGNAL CONDITION(BADAPL);
       END;
   CALL VECTOR_CHECK(LEFT); /* MAKE SURE LEFT SIDE IS A VECTOR */
   IF LEFT->RH_APL->RH_APL_DIM(1)^=RIGHT->RH_APL->RH_APL_RANK
     THEN DO;
       MSGDATA=OPNAME××' LEFT ARGUMENT INCORRECT LENGTH';
       SIGNAL CONDITION(BADAPL);
       END;
   L=MAX(1,RIGHT->RH_APL->RH_APL_RANK); /* CHANGED 10/13/86 */
   CBP=CREATE_APLCB(L);
   STRING(CBP->RH_APL_FLAGS)=STRING(RIGHT->RH_APL->RH_APL_FLAGS);
   CBP->RH_APL_SCALAR='0'B;
   CBP->RH_APL_TYPE=RIGHT->RH_APL->RH_APL_TYPE;
   CBP->RH_APL_ELEN=RIGHT->RH_APL->RH_APL_ELEN;
   ALLOCATE IXW SET(TO);
   ALLOCATE IXW SET(LFT);
   ALLOCATE IXW SET(RHT);
   RHT->IXWRHP=RIGHT;
   RHT->IXWROW=MISSING_INTEGER;
   RPT=NULL;
   J=1; /* J WILL BE NUMBER OF ELEMENTS IN OUTPUT */
   DO I=1 TO CBP->RH_APL_RANK;
     N=RIGHT->RH_APL->RH_APL_DIM(I);
     R=GET_SCALAR_SEQ('FORWARD',LEFT,RPT,CIX,MIX);
     IF OPNAME='DROP'
       THEN SELECT; /* CONVERT DROP VALUE TO TAKE VALUE */
         WHEN(ABS(R)>N) R=0; /* TAKE 0 */
         WHEN(R<=0) R=N+R;
         OTHERWISE R=R-N;
         END; /* SELECT */
     LFT->IX(I)=R; /* SAVE VALUE FOR LATER PROCESSING */
     CBP->RH_APL_DIM(I)=ABS(R); /* SET NEXT OUTPUT DIMENSION */
     J=J*CBP->RH_APL_DIM(I);
     END;
   CBP->RH_APL_RHCOUNT=1;
   CBP->RH_APL_ELCOUNT=J;
   TMP=CREATE_VAR(J*CBP->RH_APL_ELEN,CBP,''); /* OUTPUT DATASET */
   TMP->HEXMODE=RIGHT->HEXMODE;
   IF CBP->RH_APL_TYPE=CHAR_TYPE
     THEN DFT=' ';
     ELSE DFT=CONVERT(ADDR(ZEROCON),'CHAR',1,0,
       TYPETAB(CBP->RH_APL_TYPE),CBP->RH_APL_ELEN,0);
   IF J>0
     THEN DO; /* THERE ARE ELEMENTS TO PROCESS */
       I,K=0;
       CALL BUMPIX(I);
       DO UNTIL(I=0);
         IF I<=K
           THEN K=0; /* K SET TO 1 IF INDEX OUT OF RANGE */
         TO->IX(I)=TO->IX(I)+1;
         RHT->IX(I)=RHT->IX(I)+1;
         IF RHT->IX(I)<1 × RHT->IX(I)>RIGHT->RH_APL->RH_APL_DIM(I)
           THEN IF K=0
             THEN K=I; /* INDICATE INDEX OUT OF RANGE */
         IF TO->IX(I)>CBP->RH_APL_DIM(I)
           THEN I=I-1;
           ELSE IF I=L
             THEN IF K=0
               THEN CALL PUT_EL(GET_ELEMENT(RHT),TMP,OCIX,OMIX);
               ELSE CALL PUT_EL(DFT,TMP,OCIX,OMIX);
             ELSE CALL BUMPIX(I);
         ELOOP:
         END;
       END;

   BUMPIX: PROC(I);
     DCL I FIXED BIN;
     I=I+1;
     TO->IX(I)=0;
     IF LFT->IX(I)<0
       THEN RHT->IX(I)=RIGHT->RH_APL->RH_APL_DIM(I)+LFT->IX(I);
       ELSE RHT->IX(I)=0;
     END BUMPIX;

   FREE LFT->IXW;
   FREE RHT->IXW;
   FREE TO->IXW;
   CALL END_OPER(LEFT,RIGHT,TMP); /* FINISH UP */
   END TAKE_DROP_COMMON_REAL;

   END ABE061D;
