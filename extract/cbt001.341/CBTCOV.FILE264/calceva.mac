 /* CALCEVA */
 /*
0*$.HE GENERALIZED SUBROUTINES - CALCEVA
0*$.HE GENERALIZED EXPRESSION CALCULATOR
0*$.PL 55
0*$.PN 0
0*$.PA
0*$.SS
0*$.NF
0*$07/12/82
0*$AUTHOR:  T. SMITH
0*$SOURCE MODULE NAME:  CALCEVA
0*$DOCUMENTATION ID:  0*$
0*$.FI L
0*$.SP 5
0*$THIS SUBROUTINE PROVIDES A GENERALIZED EXPRESSION CALCULATOR
0*$FUNCTION.  CALL FORMAT IS AS FOLLOWS:
0*$.SP 1
0*$.IN 5
0*$CALL CALCEVA(PROMPT,WRITE,GET_OPERAND,GET_OPERAND_CHAR,
0*$PUT_OPERAND,ODD_FUNCTION);
0*$.IN 0
0*$.SP 1
0*$WHERE -
0*$.HI 4
0*$.SP 1
0*$PROMPT IS AN ENTRY WHICH RETURNS CHAR(256) VAR.  CALCEVA WILL CALL
0*$PROMPT WHEN IT WANTS THE NEXT EXPRESSION TO EVALUATE.  THE
0*$CHARACTER STRING RETURNED IS EXPECTED TO CONTAIN EITHER AN
0*$EXPRESSION TO EVALUATE, OR THE WORD 'END'.  IF IT CONTAINS 'END'
0*$CALCEVA WILL RETURN TO ITS CALLER.
0*$.SP 1
0*$WRITE IS AN ENTRY WHICH HAS A SINGLE PARAMETER DECLARED CHAR(*) VAR.
0*$CALCEVA WILL CALL WRITE WHENEVER IT HAS A LINE OF OUTPUT, WHICH MAY
0*$BE EITHER THE RESULTS OF EVALUATING AN EXPRESSION, OR A MESSAGE
0*$DESCRIBING AN ERROR ENCOUNTERED DURING THE EVALUATION OF AN
0*$EXPRESSION.
0*$.SP 1
0*$GET_OPERAND IS AN ENTRY WHICH WILL BE CALLED BY CALCEVA WHENEVER IT
0*$WANTS THE CURRENT VALUE OF AN OPERAND.  GET_OPERAND SHOULD EXPECT A
0*$SINGLE PARAMETER, WHICH IS A POINTER TO THE TOKEN STRUCTURE
0*$DESCRIBING THE REFERENCED OPERAND NAME (SEE BELOW).
0*$.SP 1
0*$GET_OPERAND_CHAR IS AN ENTRY WHICH WILL BE CALLED BY CALCEVA
0*$WHENEVER IT ENCOUNTERS AN EXPRESSION INVOLVING A QUOTED STRING.
0*$IT RECOGNIZES THIS SITUATION BY THE OPERATOR SUBTYPE BEING
0*$NEGATIVE .  GET_OPERAND_CHAR WILL THEN BE CALLED TO OBTAIN THE
0*$CHARACTER STRING FOR THE VARIABLE NAME REFERENCE.
0*$.HI 0
0*$.IN 10
0*$.NF
0*$DCL 1 TOKEN BASED(TOKPTR),
0*$2 PRIOR_TOKEN PTR,
0*$2 NEXT_TOKEN PTR,
0*$2 ELIX FIXED BIN(15,0),
0*$2 TYPE FIXED BIN(15,0),
0*$2 SUBTYPE FIXED BIN(15,0),
0*$2 TOKSTR CHAR(256) VAR;
0*$.FI L
0*$.IN 0
0*$.SP 1
0*$VARIABLE TOKSTR IN THE ABOVE STRUCTURE WILL CONTAIN THE OPERAND
0*$NAME.  FOR A MORE DETAILED DESCRIPTION OF THIS STRUCTURE, SEE ALSO
0*$DOCUMENTATION ON THE SCANNER AND POLISH SUBROUTINES.  GET_OPERAND
0*$SHOULD DECLARE ITSELF TO RETURN DEC FLOAT(16).
0*$.HI 4
0*$.SP 1
0*$PUT_OPERAND IS AN ENTRY WHICH WILL BE CALLED BY CALCEVA WHENEVER
0*$IT WANTS TO ASSIGN A VALUE TO AN OPERAND.  CALL FORMAT WILL BE:
0*$.IN 5
0*$.SP 1
0*$CALL PUT_OPERAND(PRMPTR,VALUE,MSG);
0*$.IN 5
0*$.SP 1
0*$WHERE -
0*$.SP 1
0*$PRMPTR IS A POINTER TO THE TOKEN STRUCTURE DESCRIBING THE OPERAND
0*$NAME. VALUE IS DEC FLOAT(16).
0*$IT CONTAINS THE VALUE TO BE ASSIGNED.  MSG IS CHAR(80) VAR, AND
0*$MAY BE USED BY PUT_OPERAND TO CONTAIN A MESSAGE IF YOU ENCOUNTER
0*$AND ERROR.  IF PUT_OPERAND DOES ENCOUNTER AN ERROR, IT SHOULD
0*$SIGNAL CONDITION(BADEXP).
0*$.IN 0
0*$.SP 1
0*$ODD_FUNCTION IS AN ENTRY WHICH WILL BE CALLED BY CALCEVA WHENEVER
0*$IT ENCOUNTERS A FUNCTION REFERENCE IT DOESN'T HANDLE.  YOU WILL
0*$SEE A MORE COMPLETE LIST LATER ON IN THIS DOCUMENTATION, BUT
0*$CALCEVA WILL HANDLE FUNCTIONS SUCH AS SIN, COS, SQRT, ETC.  ANY
0*$FUNCTION NAME IT DOESN'T RECOGNIZE, IT WILL PASS CONTROL TO
0*$ODD_FUNCTION.  A FUNCTION REFERENCE IS CONSIDERED TO BE A NAME
0*$FOLLOWED BY A PARENTHESIZED LIST OF ARGUMENTS, E.G. 'ABC(1,2,3+4)'.
0*$THE ONE EXCEPTION TO THIS IS THAT THE KEYWORD 'LIST' IS ALWAYS
0*$RECOGNIZED TO BE A FUNCTION REFERENCE REGARDLESS OF WHETHER IT
0*$IS FOLLOWED BY A PARENTHESIZED LIST OF ARGUMENTS, AND ODD_FUNCTION
0*$WILL BE GIVEN CONTROL.  THE CALL FORMAT CALCEVA WILL USE WILL BE:
0*$.SP 1
0*$.IN 5
0*$VALUE=ODD_FUNCTION(MSG,PRMPTR,PARMCNT,OP);
0*$.IN 0
0*$.SP 1
0*$WHERE VALUE IS DEC FLOAT(16).  ODD_FUNCTION SHOULD RETURN THE VALUE
0*$OF THE FUNCTION REFERENCE.  MSG IS DECLARED CHAR(80) VAR, AND
0*$ODD_FUNCTION MAY STORE AN ERROR MESSAGE HERE.  IF AN ERROR IS
0*$RECOGNIZED, ODD_FUNCTION SHOULD SIGNAL CONDITION(BADEXP) AFTER
0*$SETTING MSG.  PRMPTR IS A POINTER TO THE TOKEN STRUCTURE
0*$DESCRIBING THE FUNCTION NAME.
0*$PARMCNT IS FIXED BIN(15,0), AND WILL CONTAIN THE
0*$NUMBER OF ELEMENTS IN ARRAY OP THAT CONTAIN ARGUMENTS TO THE
0*$FUNCTION.  FOR EXAMPLE, IF THE FUNCTION REFERENCE WERE
0*$'ABC(1,2,3+4)', PARMCNT WOULD CONTAIN 3, AND OP(1), OP(2), AND
0*$OP(3) WOULD CONTAIN THE VALUES 1, 2, AND 7, RESPECTIVELY.  OP IS
0*$DECLARED OP(*) DEC FLOAT(16).
0*$.HI 0
0*$.SP 1
0*$CALCEVA PROVIDES A DESK CALCULATOR FUNCTION.  IT ACCEPTS FROM THE
0*$PROMPT ENTRY POINT STATEMENTS WHICH CONSIST OF ARITHMETIC
0*$EXPRESSIONS, ASSIGNMENT OPERATORS, AND FUNCTION REFERENCES, AND
0*$CALLS ENTRY POINT WRITE WITH RESULTS AND ERROR MESSAGES.  IT
0*$CONTINUES TO DO THIS UNTIL IT RECEIVES THE STRING 'END' FROM
0*$THE PROMPT ENTRY POINT.  A TYPICAL STATEMENT MIGHT BE -
0*$.SP 1
0*$A#23+B#14
0*$.SP 1
0*$WHICH WOULD FIRST ASSIGN THE VALUE 14 TO VARIABLE NAMED B, AND THEN
0*$WOULD ASSIGN 37 TO VARIABLE A.
0*$.SP 1
0*$TO LIST THE CONTENTS OF ANY VARIABLE, PROMPT SHOULD RETURN ITS NAME -
0*$.SP 1
0*$A
0*$.SP 1
0*$THE RESULT PASSED TO ENTRY POINT WRITE IN THIS CASE WOULD BE
0*$.SP 1
0*$3.70000E+01
0*$.SP 1
0*$VARIABLE NAMES MUST BEGIN WITH AN ALPHABETIC CHARACTER A-Z.  SECOND
0*$AND SUBSEQUENT CHARACTERS CAN BE EITHER ALPHABETIC OR NUMERIC.
0*$MAXIMUM LENGTH OF A VARIABLE NAME IS 256 CHARACTERS.
0*$.SP 1
0*$FUNCTION REFERENCES ARE ALSO ALLOWED.  ENTERING, FOR EXAMPLE -
0*$.SP 1
0*$1+SIN(3.14159/4)
0*$.SP 1
0*$WOULD RESULT IN -
0*$.SP 1
0*$1.70710E+00
0*$.SP 1
0*$BEING PASSED TO ENTRY WRITE (NOTE THAT WHENEVER THE LEFTMOST
0*$OPERATOR IS NOT AN ASSIGNMENT OPERATOR, THE RESULTS OF THE
0*$EXPRESSION WILL BE PASSED TO ENTRY WRITE).
0*$.SP 1
0*$ A COMPLETE LIST OF VALID FUNCTIONS FOLLOWS:
0*$.HI 4
0*$.SP 1
0*$NILADIC FUNCTIONS - REQUIRING NO PARAMETERS
0*$.SP 1
0*$DATE  - DATE IN THE FORM YYMMDD
0*$.IN 0
0*$ECHO  - CAUSES ALL SUBSEQUENTLY ENTERED EXPRESSIONS TO BE
0*$ECHOED BACK TO ENTRY WRITE AFTER BEING CONVERTED TO
0*$POLISH NOTATION.  ALSO, IF THE LEFTMOST OPERATOR IN
0*$AN EXPRESSION IS AN ASSIGNMENT, THE VALUE ASSIGNED
0*$WILL BE PASSED TO ENTRY WRITE.
0*$.IN 0
0*$TIME  - TIME IN THE FORM HHMMSS
0*$.HI 0
0*$.SP 1
0*$MONADIC FUNCTIONS - REQUIRING ONE PARAMETER
0*$.SP 1
0*$.NF
0*$ABS   - ABSOLUTE VALUE
0*$ACOS  - INVERSE COSINE IN RADIANS
0*$ASIN  - INVERSE SINE IN RADIANS
0*$ATAN  - INVERSE TANGENT IN RADIANS
0*$ATAND - INVERSE TANGENT IN DEGREES
0*$ATANH - INVERSE HYPERBOLIC TANGENT
0*$CEIL  - SMALLEST INTEGER VALUE > PARAMETER
0*$COS   - COSINE (PARAMETER IN RADIANS)
0*$COSD  - COSINE (PARAMETER IN DEGREES)
0*$COSH  - HYPERBOLIC COSINE
0*$ERF   - ERROR FUNCTION OF PARAMETER
0*$ERFC  - COMPLEMENT OF ERROR FUNCTION
0*$EXP   - BASE, E, OF NATURAL LOGARITHM SYSTEM
0*$FACT  - FACTORIAL
0*$FIXED - TRUNCATE AT INTEGER VALUE
0*$FLOOR - LARGEST INTEGER VALUE <= PARAMETER
0*$INT   - TRUNCATE AT INTEGER VALUE - SAME AS FIXED
0*$LOG   - LOGARITHM TO THE BASE E OF PARAMETER
0*$LOG2  - LOGARITHM TO THE BASE 2 OF PARAMETER
0*$LOG10 - LOGARITH TO THE BASE 10 OF PARAMETER
0*$RND   - RANDOM NUMBER GENERATOR
0*$SIGN  - +1, 0, -1 IF PARAMETER IS POSITIVE, ZERO, OR NEGATIVE
0*$SIN   - SINE (PARAMETER IN RADIANS)
0*$SIND  - SINE (PARAMETER IN DEGREES)
0*$SINH  - HYPERBOLIC SINE
0*$SQRT  - SQUARE ROOT
0*$TAN   - TANGENT (PARAMETER IN RADIANS)
0*$TAND  - TANGENT (PARAMETER IN DEGREES)
0*$TANH  - HYPERBOLIC TANGENT
0*$TRUNC - INTEGER VALUE
0*$ROUND - FLOATING POINT ROUND
0*$.FI L
0*$.SP 1
0*$DYADIC FUNCTIONS - REQUIRING TWO PARAMETERS
0*$.SP 1
0*$MOD   - MOD(X,Y) RETURNS SMALLEST NON-NEGATIVE VALUE, R,
0*$SUCH THAT (X - R)/Y = N
0*$.SP 1
0*$POLYADIC FUNCTIONS - REQUIRING UP TO 10 PARAMETERS
0*$.SP 1
0*$MAX   - RETURNS LARGEST VALUE FROM SET OF UP TO 10 EXPRESSIONS
0*$.IN 0
0*$MIN   - RETURNS SMALLEST VALUE FROM SET OF UP TO 10 EXPRESSIONS
0*$.SP 1
0*$NOTE THAT EXCEPT FOR ECHO, ALL OF THE FUNCTIONS LISTED
0*$ABOVE ARE PART OF THE STANDARD PL/I OPTIMIZING COMPILER REPERTOIRE.
0*$FOR FURTHER DETAILS ON ANY OF THESE FUNCTIONS, SEE "OS AND DOS
0*$PL/I LANGUAGE REFERENCE MANUAL", GC26-3977.
0*$.SP 1
0*$ACCEPTABLE OPERATORS AND THEIR EVALUATION PRIORITIES ARE LISTED
0*$BELOW.  NOTE THAT EXCEPT FOR THE ASSIGNMENT OPERATOR, OPERATORS
0*$ARE PROCESSED LEFT-TO-RIGHT BY EVALUATION PRIORITY
0*$(E.G. MULTIPLICATION IS EVALUATED BEFORE ADDITION).  IF YOU
0*$HAVE ANY QUESTIONS AS TO THE ORDER OF EVALUATION OF ANY EXPRESSION,
0*$ENTER THE ECHO FUNCTION.  FROM THAT POINT UNTIL THE ECHO FUNCTION
0*$IS REISSUED, ALL EXPRESSIONS WILL BE PRINTED BACK AT THE TERMINAL
0*$AFTER THEY HAVE BEEN CONVERTED TO POLISH NOTATION.  THIS WILL MAKE
0*$THE ORDER OF EVALUATION OBVIOUS.
0*$.SP 1
0*$.NF
0*$ EVALUATION
0*$ PRIORITY    OPERATOR
0*$
0*$ -2          ** (EXPONENTIATION - PROCESSED RIGHT-TO-LEFT)
0*$  5          ^>
0*$  5          >=
0*$  5          ^=
0*$  5          <=
0*$  5          ^<
0*$  5          <
0*$  5          =
0*$  5          >
0*$  7          ×  (LOGICAL OR)
0*$  6          &  (LOGICAL AND)
0*$  3          *  (MULTIPLICATION)
0*$  3          /  (DIVISION)
0*$  4          INFIX +
0*$  4          INFIX -
0*$ -1          # (ASSIGNMENT OPERATOR - PROCESSED RIGHT-TO-LEFT)
0*$  2          PREFIX +
0*$  2          PREFIX -
0*$  2          PREFIX ^
0*$.SP 1
0*$.FI L
 */
 CALCEVA: PROC(PROMPT,WRITE,GET_OPERAND,GET_OPERAND_CHAR,
   PUT_OPERAND,ODD_FUNCTION)
   RECURSIVE OPTIONS(REENTRANT);
 /**********************************************************************
 * THIS IS THE MAINLINE OF THE CALC TSO COMMAND PROCESSOR.  IT USES    *
 * SUBROUTINES SCANNER, POLISH, AND EVAL TO PROCESS ARITHMETIC         *
 * EXPRESSIONS OBTAINED AT THE TERMINAL VIA THE PROMPT ENTRY PARAMETER,*
 * AND PRINTS MESSAGES AND RESULTS AT THE TERMINAL VIA THE WRITE ENTRY *
 * PARAMETER.                                                          *
 **********************************************************************/
   DCL PROMPT ENTRY RETURNS(CHAR(256) VAR); /* PROMPT FOR EXPRESSIONS */
   DCL WRITE ENTRY(CHAR(*) VAR); /* PRINT RESULTS */
   DCL GET_OPERAND ENTRY(PTR)
     RETURNS(FLOAT DEC(16));
   DCL GET_OPERAND_CHAR ENTRY(PTR)
     RETURNS(CHAR(256) VAR);
   DCL PUT_OPERAND ENTRY(PTR,FLOAT DEC(16),CHAR(80) VAR);
   DCL ODD_FUNCTION ENTRY(CHAR(80) VAR,PTR,FIXED BIN(15,0),)
     RETURNS(DEC FLOAT(16));
   DCL CALCPRT ENTRY(DEC FLOAT(16))
     RETURNS(CHAR(80) VAR);
   DCL CALCEVB ENTRY(,,,,BIT(1),PTR,CHAR(80) VAR)
     RETURNS(DEC FLOAT(16));
   DFT RANGE(*) FIXED BIN VALUE(FIXED BIN(31,0));
   DCL OPERAND          INIT(0) FIXED STATIC;
   DCL OPERATOR         INIT(1) FIXED STATIC;
   DCL KEYWORD          INIT(2) FIXED STATIC;
   DCL TYPE_SPCHAR      INIT(3) FIXED STATIC;
   DCL QUOTED_STRING    INIT(4) FIXED STATIC;
   DCL NUMERIC_CONSTANT INIT(5) FIXED STATIC;
   DCL NO_MORE_TOKENS   INIT(6) FIXED STATIC;
   DCL OTHER            INIT(7) FIXED STATIC;
   DCL FUNCTION_A       INIT(8) FIXED STATIC;
   DCL TEMPORARY        INIT(9) FIXED STATIC;
   DCL FUNCTION_B       INIT(10) FIXED STATIC;
   DCL ASSIGNMENT       INIT(17) FIXED STATIC;
   DCL TIME BUILTIN;
   DCL NULL BUILTIN;
   DCL SCANNER ENTRY;
   DCL POLISH ENTRY RETURNS(PTR);
   DCL CMDDATA CHAR(256) VAR;
   DCL (NEWHDR,LSTPTR) PTR;
   DCL MSG CHAR(80) VAR;
   DCL ECHOSW BIT(1) INIT('0'B);
   DCL VALUE DEC FLOAT(16);
   DCL 1 SCANPARM,
     2 TOKHDR PTR,
     2 CURTOK PTR,
     2 SCANIX FIXED BIN(15,0);
   DCL 1 TOKEN BASED(TOKPTR),
     2 PRIOR_TOKEN PTR,
     2 NEXT_TOKEN PTR,
     2 ELIX FIXED BIN(15,0),
     2 TYPE FIXED BIN(15,0),
     2 SUBTYPE FIXED BIN(15,0),
     2 TOKSTR CHAR(256) VAR;
   DCL 1 TOKEN2 BASED(TOKPTR),
     2 PAD CHAR(12),
     2 TEMPVALUE FLOAT DEC(16);
   DCL KEYWORDS(40) CHAR(8) VAR STATIC INIT(
   /* NILADIC FUNCTIONS */
     'DATE',     /*  1 */
     'ECHO',     /*  2 */
     'LIST',     /*  3 */
     'TIME',     /*  4 */
   /* MONADIC FUNCTIONS */
     'ABS',      /*  5 */
     'ACOS',     /*  6 */
     'ASIN',     /*  7 */
     'ATAN',     /*  8 */
     'ATAND',    /*  9 */
     'ATANH',    /* 10 */
     'CEIL',     /* 11 */
     'COS',      /* 12 */
     'COSD',     /* 13 */
     'COSH',     /* 14 */
     'ERF',      /* 15 */
     'ERFC',     /* 16 */
     'EXP',      /* 17 */
     'FACT',     /* 18 */
     'FIXED',    /* 19 */
     'FLOOR',    /* 20 */
     'LOG',      /* 21 */
     'LOG2',     /* 22 */
     'LOG10',    /* 23 */
     'SIGN',     /* 24 */
     'SIN',      /* 25 */
     'SIND',     /* 26 */
     'SINH',     /* 27 */
     'SQRT',     /* 28 */
     'TAN',      /* 29 */
     'TAND',     /* 30 */
     'TANH',     /* 31 */
     'TRUNC',    /* 32 */
     'RND',      /* 33 */
     'INT',      /* 34 */
   /* DYADIC FUNCTIONS */
     'MOD',      /* 35 */
     'ROUND',    /* 36 */
     'INDEX',    /* 37 */
     'VERIFY',   /* 38 */
   /* POLYADIC FUNCTIONS */
      'MAX',     /* 39 */
      'MIN');    /* 40 */
   DCL NILADIC_IX FIXED BIN(15,0) STATIC INIT(4);
   DCL MONADIC_IX FIXED BIN(15,0) STATIC INIT(34);
   DCL DYADIC_IX  FIXED BIN(15,0) STATIC INIT(38);
   DCL POLYADIC_IX FIXED BIN(15,0) STATIC INIT(40);
   DCL OPERATORS(17) CHAR(2) VAR STATIC INIT(
     '**',  /*  1 */
     '^>',  /*  2 */
     '>=',  /*  3 */
     '^=',  /*  4 */
     '<=',  /*  5 */
     '^<',  /*  6 */
     '<',   /*  7 */
     '=',   /*  8 */
     '>',   /*  9 */
     '×',   /* 10 */
     '&',   /* 11 */
     '*',   /* 12 */
     '/',   /* 13 */
     '+',   /* 14 */
     '-',   /* 15 */
     '^',   /* 16 */
     '#');  /* 17 (ASSIGNMENT) */
   DCL PRECEDENCE(2,17) FIXED BIN(15,0) STATIC INIT(
     /* DIADIC OPERATOR PRECEDENCE */
     -2, /*  1 - ** */
      5, /*  2 - ^> */
      5, /*  3 - >= */
      5, /*  4 - ^= */
      5, /*  5 - <= */
      5, /*  6 - ^< */
      5, /*  7 - <  */
      5, /*  8 - =  */
      5, /*  9 - >  */
      7, /* 10 - ×  */
      6, /* 11 - &  */
      3, /* 12 - *  */
      3, /* 13 - /  */
      4, /* 14 - +  */
      4, /* 15 - -  */
      0, /* 16 - ^  */
     -1, /* 17 - #  */
     /* MONADIC OPERATOR PRECEDENCE */
      0, /*  1 - ** */
      0, /*  2 - ^> */
      0, /*  3 - >= */
      0, /*  4 - ^= */
      0, /*  5 - <= */
      0, /*  6 - ^< */
      0, /*  7 - <  */
      0, /*  8 - =  */
      0, /*  9 - >  */
      0, /* 10 - ×  */
      0, /* 11 - &  */
      0, /* 12 - *  */
      0, /* 13 - /  */
      1, /* 14 - +  */
      1, /* 15 - -  */
      1, /* 16 - ^  */
     -1);/* 17 - #  */
   DCL SPCHARS CHAR(2) VAR STATIC INIT('()');
   DCL PSTR CHAR(80) VAR;
   DO CMDDATA=PROMPT REPEAT PROMPT WHILE(CMDDATA^='END');
     TOKHDR,CURTOK=NULL;
     SCANIX=1;
     DO UNTIL(CURTOK->TYPE=NO_MORE_TOKENS); /* WAS 6 */
       CALL SCANNER(CMDDATA,SCANPARM,OPERATORS,KEYWORDS,SPCHARS);
       END;
     NEWHDR=POLISH(TOKHDR,PRECEDENCE,MSG,LSTPTR);
     IF MSG=''
       THEN IF LSTPTR->TYPE^=NO_MORE_TOKENS
         THEN MSG=
           'ERROR - END OF EXPRESSION FOUND BEFORE END OF INPUT';
     IF MSG^=''
       THEN CALL WRITE(MSG);
       ELSE IF NEWHDR^=NULL
         THEN DO;
           CALL CHAR_CHECK(NEWHDR); /* CHECK FOR QUOTED STRINGS */
           IF ECHOSW
             THEN DO;
               CMDDATA='';
               DO TOKPTR=NEWHDR REPEAT NEXT_TOKEN
                 WHILE(TOKPTR^=NULL);
                 CMDDATA=CMDDATA××' '××TOKSTR;
                 END;
               CALL WRITE(CMDDATA);
               END;
           VALUE=CALCEVB(
             GET_OPERAND,GET_OPERAND_CHAR,PUT_OPERAND,
             ODD_FUNCTION,ECHOSW,NEWHDR,MSG);
           IF MSG^=''
             THEN CALL WRITE(MSG);
             ELSE IF ECHOSW × NEWHDR->PRIOR_TOKEN->TOKSTR^='#'
               THEN CALL WRITE(CALCPRT(VALUE));
           END;
     DO TOKPTR=TOKHDR REPEAT TOKHDR WHILE(TOKHDR^=NULL);
       TOKHDR=NEXT_TOKEN;
       FREE TOKEN;
       END;
     DO TOKPTR=NEWHDR REPEAT NEWHDR WHILE(TOKPTR^=NULL);
       NEWHDR=NEXT_TOKEN;
       FREE TOKEN;
       END;
     END; /* MAINLINE */

 CHAR_CHECK: PROC(S);
 /**********************************************************************
 *                                                                     *
 * CALLED TO CHECK A GIVEN EXPRESSION FOR CHARACTER-STRING OPERATIONS. *
 * THE SUBTYPES FOR THE OPERATORS INVOLVED WILL BE NEGATED TO CAUSE    *
 * CALCEVB TO DO CHARACTER STRING OPERATIONS.                          *
 *                                                                     *
 **********************************************************************/
   DCL (S,T) PTR;
   DCL STRSW BIT(1) INIT('0'B);

   /* NOW CHECK FOR CHARACTER STRING OPERATIONS */
   DO T=S REPEAT T->NEXT_TOKEN WHILE(T^=NULL);
     SELECT;
       WHEN(T->TYPE=OPERATOR) DO;
         IF STRSW
           THEN DO;
             STRSW='0'B;
             T->SUBTYPE=-T->SUBTYPE;
             END;
         END;
       WHEN(T->TYPE=QUOTED_STRING)
         STRSW='1'B;
       OTHERWISE;
       END; /* SELECT */
     END;

   END CHAR_CHECK;

   END CALCEVA;
