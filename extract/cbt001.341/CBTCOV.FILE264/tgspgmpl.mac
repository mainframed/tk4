// EXEC FORTGCL
//FORT.SYSLIN DD UNIT=SYSDA
//FORT.SYSIN DD *
C          DATA SET TGSPGMPL   AT LEVEL 006 AS OF 07/09/71
C
C     PROGPLOT - WRITTEN AT THE STANFORD LINEAR ACCELERATOR CENTER
C                BY R.H. JOHNSON
C     VERSION OF JUNE 9,1970
C
      INTEGER*4 KK(2500,3),TCB(500),HOS(500),LOAD(500)
      REAL*8 NAME(500),SNAME(10),NME
      INTEGER*4 IFR(500),LST(500)
      DIMENSION COL(6),CHAR(6)
      DATA COL/0.0,25.0,50.0,75.0,100.0,0.0/
      DATA CHAR/1H.,1H.,1H.,1H.,1H.,1H*/
      DIMENSION KTOTW(500),KTOTR(500)
      DIMENSION KTWM(500),KTRM(500)
      REAL*8 ONAME
      DATA ONAME/'ZZZZZZZZ'/
C     SIGNON
      WRITE(6,1)
1     FORMAT('1*** BEGIN PROGRAM TIMER PLOT ***'/
     X  ' *** VERSION THREE ***'/
     X  ' *** WRITTEN BY RICHARD JOHNSON - STANFORD',
     X' LINEAR ACCELERATOR CENTER ***')
      KOTCB=0
      KOHOS=0
      KDISP=0
      KMATX=0
      NENTM=500
      KBUC=2500
      N=0
C     READ INPUT PARAMS (IF ANY)
C     SET DEFAULTS FIRST
      KDEL=256
      MSWTCH=0
      KDUMP=0
      KSNM=0
      READ(5,10,END=100)KKK,NNN,MMMM,KDDD
10    FORMAT(4I5)
      MSWTCH=MMMM
      KDEL=KKK
      KDUMP=KDDD
      IF(NNN.LE.0)GO TO 100
      READ(5,11)(SNAME(I),I=1,NNN)
11    FORMAT(10A8)
      WRITE(6,12)(SNAME(I),I=1,NNN)
12    FORMAT('0PROGRAM SELECTION LIST --- ',10A10)
      KSNM=NNN
100   CONTINUE
      WRITE(6,13)KDEL
13    FORMAT('0PLOT INCREMENT = ',Z6,' HEX')
C     CLEAR ALL ARRAYS
      DO 200 I=1,KBUC
      KK(I,1)=0
      KK(I,3)=0
200   KK(I,2)=0
      DO 300 I=1,NENTM
      KTOTW(I)=0
      KTOTR(I)=0
      KTWM(I)=0
      KTRM(I)=0
      TCB(I)=0
      HOS(I)=0
      LOAD(I)=0
      NAME(I)=0.0D0
      IFR(I)=0
300   LST(I)=0
C
C     READ DATA RECORDS
C
      WRITE(6,999)
999   FORMAT('0PROGRAM TIMELINE'//)
      NREC=0
      NENT=0
      KODE=0
C     CALL QSAM INPUT READER
1000  CALL READ(KODE,IWT,IADD,NME,ITCB,ISEG,LD)
C     CHECK FOR END OF INPUT
      IF(KODE.GT.1)GO TO 10000
      NREC=NREC+1
      KODE=1
C
C     SEE IF RECORD IS A RUN SAMPLE TO BE
C     SKIPPED BECAUSE IT HAD THE SAME ADDRESS
C     AS THE PREVIOUS SAMPLE.
C
      CALL CHECK(ITCB,NME,ISEG,IWT,IADD,KRET,KDUMP)
CTGS
CTGS KDISP MUST BE A COUNT OF REJECTS
CTGS
      IF(KRET.NE.0)KDISP=KDISP+1
      IF(KRET .NE. 0)GO TO 1000
C     MAKE CONTROL MATRIX ENTRY
      CALL MATRIX(ITCB,NME,ISEG,KMATX,MSWTCH)
      KMATX=1
CTGS ARRAY C -
CTGS ARRAY C IS COMPOSED OF THE ELEMENTS TCB/NAME/HOS/LOAD/IFR/LST
CTGS ARRAY C IS COMPOSED OF THE ELEMENTS TCB/NAME/HOS/LOAD/IFR/LST/
CTGS         KTOTW/KTOTR/KTWM/KTRM
CTGS
CTGS   TCB   - IS THE TCB ADDRESS
CTGS
CTGS   NAME  - IS THE LOAD MODULE NAME
CTGS
CTGS   HOS   - IS THE SEGMENT NUMBER
CTGS
CTGS   LOAD  - LOAD MODULE ADDRESS - FIRST NON-ZERO VALUE ENCOUNTERED.
CTGS
CTGS   IFR   - IS THE VALUE OF THE LOWEST SUBSCRIPT WHICH POINTS TO
CTGS           AN ENTRY IN ARRAY D ASSOCIATED WITH THIS TCB
CTGS
CTGS   LST   - IS THE VALUE OF THE HIGHEST SUBSCRIPT WHICH POINTS TO
CTGS           AN ENTRY IN ARRAY D ASSOCIATED WITH THIS TCB.
CTGS
CTGS   KTOTW - IS THE TOTAL COUNT OF ALL THOSE SAMPLES TAKEN THAT WERE
CTGS           ASSOCIATED WITH EACH TCB/NAME/HOS COMBINATION AND WHICH
CTGS           INDICATE THAT THE ENTITY WAS WAITING.
CTGS
CTGS   KTOTR - IS THE TOTAL COUNT OF ALL THOSE SAMPLES TAKEN THAT WERE
CTGS           ASSOCIATED WITH EACH TCB/NAME/HOS COMBINATION AND WHICH
CTGS           INDICATE THAT THE ENTITY WAS RUNNING.
CTGS
CTGS   KTWM  - IS SET EQUAL TO THE LARGEST KK(M,2) ENCOUNTERED IN ARRAY
CTGS           D AND WHICH IS ASSOCIATED WITH THIS PARTICULAR TCB/NAME/H
CTGS
CTGS   KTRM  - IS SET EQUAL TO THE LARGEST KK(M,3) ENCOUNTERED IN ARRAY
CTGS           D AND WHICH IS ASSOCIATED WITH THIS PARTICULAR TCB/NAME/H
CTGS
CTGS   IFR/LST ARE USED TO LIMIT THE SCAN OF ARRAY D TO FIND THE /
CTGS   APPROPRIATE ENTRY IN ARRAY D
CTGS
CTGS AN ENTRY IS CREATED IN ARRAY C FOR EACH UNIQUE COMBINATION OF
CTGS TCB/NAME/HOS.  NENT CONTAINS A COUNT OF THE NUMBER OF ENTRIES
CTGS IN ARRAY C.
C
C     SEE IF THIS ENTITY HAS OCCURRED ALREADY.
C
      IF(NENT.EQ.0)GO TO 1101
      DO 1100 I=1,NENT
      IF(TCB(I).NE.ITCB)GO TO 1100
      IF(NAME(I).NE.NME)GO TO 1100
      IF(ISEG.NE.HOS(I))GO TO 1100
      J=I
C     SET LOAD ADDRESS IF PREVIOUSLY UNDEFINED
      IF((LD.GT.0) .AND. (LOAD(J).EQ.0))LOAD(J)=LD
      GO TO 1200
1100  CONTINUE
C
C     CREATE A NEW ENTITY
C
1101  NENT=NENT+1
      IF(NENT.LE.NENTM)GO TO 1110
      WRITE(6,1111)NENTM
1111  FORMAT('0*** YE GAD!  MORE THEN ',I3,' ENTITIES ENCOUNTERED ***'/
     X   ' ----- BYE BYE -----')
      STOP
1110  TCB(NENT)=ITCB
      NAME(NENT)=NME
      HOS(NENT)=ISEG
      LOAD(NENT)=LD
      J=NENT
1200  CONTINUE
CTGS
CTGS  AT THIS POINT, AN ENTRY EXISTS FOR THE CURRENT RECORD AND IS
CTGS  SUBSCRIPTED BY J.
CTGS
C
C     SEE IF WE WANT THIS RECORD
C
CTGS
CTGS  CKSNM = # OF SELECTED PGMS IF SPECIFIED ON CTL CARD
CTGS
      IF(KSNM.LE.0)GO TO 1500
      DO 1300 I=1,KSNM
      IF(NAME(J).EQ.SNAME(I))GO TO 1500
1300  CONTINUE
      GO TO 1000
C
C     MAKE NEW BUCKET ENTRY
C
1500  IF(N.GT.0)GO TO 1600
      IFR(J)=1
      LST(J)=1
      N=1
      M=1
      GO TO 2000
1600  CONTINUE
      IF(IFR(J).GT.0)GO TO 1900
C
C     CREATE NEW BUCKET AND BUCKET POINTER
C
CTGS
CTGS  N = # OF ENTRIES IN ARRAY D
CTGS
      IFR(J)=N+1
1610  N=N+1
      IF(N.LE.KBUC)GO TO 1620
1605  WRITE(6,1606)KBUC
1606  FORMAT('0** WOULD YOU BELIEVE THAT ',I5,
     X ' BUCKETS IS NOT ENOUGH? **'/' BYE.')
      STOP
1620  LST(J)=N
      M=N
      GO TO 2000
C
C     SEE IF WE ALREADY HIT THIS CATEGORY
C
1900  KKF=IFR(J)
      KKL=LST(J)
      DO 1950 I=KKF,KKL
      KENT=KK(I,1)/10000000
      IF(KENT.NE.J)GO TO 1950
      KLOW=KK(I,1)-10000000*KENT
      KHIGH=KLOW+KDEL
      IF(IADD.LT.KLOW)GO TO 1950
      IF(IADD.GE.KHIGH)GO TO 1950
      M=I
      GO TO 2100
1950  CONTINUE
      GO TO 1610
C
C     MAKE A NEW ENTRY
C
CTGS  ARRAY D -
CTGS  KK(M,1) IS SET UP TO CONTAIN TWO DIFFERENT VALUES SIMULTANEOUSLY.
CTGS  TO DO THIS, THE PROGRAMMER ASSUMED THAT NO INSTRUCTION ADDRESSES
CTGS  WOULD BE RECEIVED THAT WERE GREATER THAN 10,000,000.  THUS -
CTGS
CTGS    - (KK(M,1)/10000000) = THE PROPER SUBSCRIPT VALUE FOR THE
CTGS      RELATED ENTRY IN ARRAY C.
CTGS
CTGS    - (KK(M,1)-10000000*(KK(M,1)/10000000)) = IADD-MOD(IADD,KDEL)
CTGS      IADD-MOD(IADD,KDEL) IS A VALUE EQUAL TO THE FIRST INTEGER
CTGS      SMALLER THAN THE INSTRUCTION ADDRESS (IADD) THAT IS EVENLY
CTGS      DIVISIBLE BY KDEL, WHICH IS THE VALUE SPECIFIED AS THE FIRST
CTGS      PARAMETER ON THE FIRST CONTROL CARD PASSED TO THIS PROGRAM
CTGS      FROM DATA SET FT05F001.
CTGS
CTGS  KK(M,2) IS AN ACCUMULATOR CONTAINING A COUNT OF THE NUMBER OF RECO
CTGS  ENCOUNTERED THAT WERE ASSOCIATED WITH THE ENTITY IN ARRAY C POINTE
CTGS  TO BY THE SUBSCRIPT VALUE IN KK(M,1) AND WHICH INDICATED THAT THAT
CTGS  ENTITY WAS WAITING WHEN THE RECORD WAS CREATED.
CTGS
CTGS  KK(M,3) IS AN ACCUMULATOR CONTAINING A COUNT OF THE NUMBER OF RECO
CTGS  ENCOUNTERED THAT WERE ASSOCIATED WITH THE ENTITY IN ARRAY C POINTE
CTGS  TO BY THE SUBSCRIPT VALUE IN KK(M,1) AND WATCH INDICATED THAT THAT
CTGS  ENTITY WAS RUNNING WHEN THE RECORD WAS CREATED.
CTGS
CTGS  AN ENTRY IS CREATED IN KK FOR EACH RANGE OF INSTRUCTION ADDRESSES
CTGS  ENCOUNTERED FOR EACH VALUE OF J (SUBSCRIPT OF ARRAY C) WHERE THE
1960  CONTINUE
CTGS  RANGES OF INSTRUCTION ADDRESSES IS DETERMINED AS FOLLOWS.  THE
CTGS  VALUE IADD-MOD(IADD,KDEL) IS ASSIGNED TO KLOW.  KK IS THEN SCANNED
CTGS  FOR EACH ENTRY IN KK, IADD-MOD(IADD,KDEL) IS EXTRACTED FROM KK(M,1
CTGS  THE RANGE FOR THAT ENTRY IS FROM THE VALUE (IADD-MOD(IADD,KDEL)
CTGS  FROM KK(M,1) TO THE VALUE (IADD-MOD(IADD,KDEL)+KDEL).  IF THE NEW
CTGS  VALUE READ IN FALLS WITHIN THAT RANGE THAT ENTRY IN KK IS USED
CTGS  FOR ACCUMULATING STATISTICS FROM THE RECORD.  IF, HOWEVER, THE
CTGS  VALUE FROM THE NEW RECORD DOES NOT FALL INTO THE RANGE OF ONE OF
CTGS  THE ENTRIES IN KK, A NEW ENTRY IS CREATED.
2000  KLOW=IADD-MOD(IADD,KDEL)
      KK(M,1)=10000000*J+KLOW
2100  IF(IWT.EQ.1)GO TO 2110
      KK(M,3)=KK(M,3)+1
      GO TO 1000
2110  KK(M,2)=KK(M,2)+1
      GO TO 1000
10000 CONTINUE
C
C     ALL DATA HAS BEEN READ, BEGIN PRODUCING PRINTED REPORTS
C
      WRITE(6,3000)NREC
3000  FORMAT('1END DATA AFTER ',I5,' RECORDS'//)
      IF(NREC.LE.0)STOP
      IF(KDISP.GT.1)WRITE(6,3015)KDISP
3015  FORMAT(1H ,I6,' RUN SAMPLES DISCARDED BECAUSE MEASURED ',
     X'SUBTASK WAS DISPATCHABLE'/
     X8X,'BUT NOT ACTUALLY RUNNING WHEN SAMPLED.'/
     X8X,'IF THIS NUMBER IS LARGE COMPARED TO TOTAL RUN',
     X' SAMPLES ACCEPTED,'/
     X8X,'YOUR SUBTASK WAS HELD UP BY OTHER JOBS OF HIGHER',
     X' DISPATCHING PRIORITY.'//)
      WRITE(6,3010)NENT
3010  FORMAT(' ENTITIES ENCOUNTERED = ',I3/)
      DO 3020 I=1,NENT
      WRITE(6,3025)I,TCB(I),NAME(I),HOS(I),LOAD(I)
3025  FORMAT(I9,' TCB=',Z10,' NAME=',A8,' HIGHEST SEGMENT=',
     X  I3,' LOAD POINT=',Z10)
3020  CONTINUE
      WRITE(6,3030)N
3030  FORMAT('0',I5,' BUCKETS TO BE SORTED '///)
      IF(N.LE.1)GO TO 3031
      CALL DSORTN(N,2,KK(1,1),KK(1,2),M,M,M,KK(1,3))
CTGS
CTGS  AT THIS POINT, KK SHOULD BE SORTED INTO ASCENDING SEQUENCE ON
CTGS  THE MAJOR KEY OF THE SUBSCRIPT VALUE IN KK(M,1), AND THE
CTGS  MINOR KEY OF INSTRUCTION ADDR WHICH IS ALSO STORED IN KK(M,1)
CTGS
3031  CONTINUE
      MTW=0
      MTR=0
      DO 4000 I=1,N
      IEN=KK(I,1)/10000000
CTGS
CTGS  IEN = THE SUBSCRIPT VALUE FOR THE RELATED ENTRY IN ARRAY C.
CTGS
      IAD=KK(I,1)-10000000*IEN
CTGS
CTGS  IAD = INSTRUCTION ADDRESS FOR THIS ENTRY
CTGS
      IWT=KK(I,2)
CTGS
CTGS  IWT = WAIT COUNT FOR THIS ENTRY
CTGS
      NWT=KK(I,3)
CTGS
CTGS  MWT = RUN COUNT FOR THIS ENTRY
CTGS
C     FIND TOTALS BY ENTITY
      KTOTW(IEN)=KTOTW(IEN)+IWT
      KTOTR(IEN)=KTOTR(IEN)+NWT
C     FIND WAIT AND RUN TOTALS FOR ALL ENTITIES
      MTW=MTW+IWT
      MTR=MTR+NWT
CTGS
CTGS  MTR AND MTW WILL EQUAL THE TOTAL COUNTS OF SAMPLES INDICATING
CTGS  RUNNING AND WAITING STATES, RESPECTIVELY.
CTGS
C     FIND MAX BUCKET BY ENTITY
      IF(KTWM(IEN).LT.IWT)KTWM(IEN)=IWT
      IF(KTRM(IEN).LT.NWT)KTRM(IEN)=NWT
4000  CONTINUE
      WRITE(6,3999)
3999  FORMAT(4X,'ENTITY',5X,'IDENTIFIER',6X,2('NUMBER  '),
     X  'TOTAL',3X,'RUNNING',1X,'WAITING'/
     X  4X,'NUMBER',3X,'TCB',4X,'NAME',3X,'SEG',1X,'WAITING',1X,
     X  'RUNNING',1X,3('PERCENT '))
      XREC=NREC
      BOTR=MTR
      BOTW=MTW
      DO 4100 I=1,NENT
      XTT=KTOTW(I)+KTOTR(I)
      XP=100.0*(XTT/XREC)
      XXPR=0.0
      IF(MTR.LE.0)GO TO 4200
      XXPR=100.0*(KTOTR(I)/BOTR)
4200  XXPW=0.0
      IF(MTW.LE.0)GO TO 4300
      XXPW=100.0*(KTOTW(I)/BOTW)
4300  CONTINUE
      WRITE(6,4110)I,TCB(I),NAME(I),HOS(I),KTOTW(I),KTOTR(I),XP,XXPR,
     X  XXPW
4110  FORMAT(5X,I3,3X,Z6,1X,A8,1X,I3,1X,I6,
     X  2X,I6,3X,3(F5.2,3X))
4100  CONTINUE
      WRITE(6,4111)MTW,MTR
4111  FORMAT(31X,2(I6,2X))
      XXX=100.0*(BOTR/(BOTR+BOTW))
      WRITE(6,4333)XXX
4333  FORMAT(1H0//' TOTAL PERCENT OF TIME SUBTASK WAS RUNNING ',F5.2)
C     PLOT WAIT PROFILES
      KHEAD=1
      IF( (KSNM.EQ.0) .AND. (NENT.GT.20) ) KHEAD=0
      NEXT=0
      DO 5000 I=1,N
      IEN=KK(I,1)/10000000
      IABS=KK(I,1)-10000000*IEN
      IWT=KK(I,2)
      NWT=KK(I,3)
      IF(KTOTW(IEN).LE.0)GO TO 5000
      IF(NEXT.EQ.IEN)GO TO 5500
C     TITLE FOR NEXT GRAPH
      NEXT=IEN
      TOTAL=KTOTW(IEN)
      WRITE(6,5100)KHEAD,IEN,NAME(IEN),HOS(IEN),TCB(IEN)
5100  FORMAT(I1,T10,'WAIT PROFILE FOR ENTITY ',I3,10X,A8,I5,Z10//)
      XTP=(  100*KTWM(IEN))/KTOTW(IEN)
      CALL HEADER(KTWM(IEN),XTP,COL)
5500  IREL=IABS-LOAD(IEN)
      IF(IREL.LE.0)IREL=0
      IF(IWT.EQ.0)GO TO 5000
      XX=IWT
      COL(6)=(100.0*XX)/TOTAL
      CALL GRAPH(IABS,IREL,COL,CHAR,6,0.5*XTP,XTP,6,IWT)
5000  CONTINUE
C     PLOT RUNNING PROFILES
      NEXT=0
      DO 6000 I=1,N
      IEN=KK(I,1)/10000000
      IABS=KK(I,1)-10000000*IEN
      IWT=KK(I,2)
      NWT=KK(I,3)
      IF(KTOTR(IEN).LE.0)GO TO 6000
      IF(NEXT.EQ.IEN)GO TO 6500
C     TITLE FOR NEXT GRAPH
      NEXT=IEN
      TOTAL=KTOTR(IEN)
      WRITE(6,6100)KHEAD,IEN,NAME(IEN),HOS(IEN),TCB(IEN)
6100  FORMAT(I1,T10,'RUNNING PROFILE FOR ENTITY ',I3,10X,A8,I5,Z10//)
      XTP=(100*KTRM(IEN))/KTOTR(IEN)
      CALL HEADER(KTRM(IEN),XTP,COL)
6500  IREL=IABS-LOAD(IEN)
      IF(IREL.LT.0)IREL=0
      IF(NWT.EQ.0)GO TO 6000
      XX=NWT
      COL(6)=(100.0*XX)/TOTAL
      CALL GRAPH(IABS,IREL,COL,CHAR,6,0.5*XTP,XTP,6,NWT)
6000  CONTINUE
      IF(NENT .LE. 1 ) GO TO 8000
      IF(N.LE.1)GO TO 8000
      KTW=0
      KTNW=0
C     DO SUMMARY PLOTS
      DO 7000 I=1,N
      IEN=KK(I,1)/10000000
      KK(I,1)=KK(I,1)-10000000*IEN
CTGS
CTGS  THE ABOVE INSTRUCTIONS REMOVE THE SUBSCRIPT PORTION, LEAVING ONLY
CTGS  THE INSTRUCTION ADDRESS IN KK(M,1).
CTGS
      IWT=KK(I,2)
      NWT=KK(I,3)
      KTW=KTW+IWT
      KTNW=KTNW+NWT
7000  CONTINUE
C     RE-SORT THE LIST
      CALL DSORTN(N,2,KK(1,1),KK(1,2),M,M,M,KK(1,3))
CTGS
CTGS  AT THIS POINT, KK SHOULD BE RE-SORTED INTO ASCENDING SEQUENCE
CTGS  ON INSTRUCTION ADDRESS ONLY.
CTGS
C     ELIMINATE DUPLICATES
CTGS
CTGS  A SCAN IS NOW MADE OF KK, AND ENTRIES WITH THE SAME INSTRUCTION
CTGS  ADDRESS ARE COMBINED.  THE RESULTANT DUMMY ENTRIES ARE IDENTIFIED
CTGS  BY SETTING KK(I,1) EQUAL TO -10.  DSORTN IS THEN CALLED AGAIN TO
CTGS  RESORT INTO ASCENDING SEQUENCE ON INSTRUCTION ADDRESS.  THIS WILL
CTGS  CAUSE ALL OF THE DUMMY ENTRIES TO FLOAT TO THE TOP OF THE ARRAY.
CTGS
      IF(N.LT.2)GO TO 7100
      NN=N-1
      DO 7200 I=1,NN
      IF(KK(I,1).NE.KK(I+1,1))GO TO 7200
      KK(I,1)=-10
      KK(I+1,2)=KK(I+1,2)+KK(I,2)
      KK(I+1,3)=KK(I+1,3)+KK(I,3)
7200  CONTINUE
7100  CONTINUE
C     ONE MORE TIME BABY
      CALL DSORTN(N,2,KK(1,1),KK(1,2),M,M,M,KK(1,3))
      MWM=0
      MRM=0
      DO 8500 I=1,N
      IF(KK(I,1).LT.0)GO TO 8500
      IWT=KK(I,2)
      NWT=KK(I,3)
      IF(MWM.LT.IWT)MWM=IWT
      IF(MRM.LT.NWT)MRM=NWT
8500  CONTINUE
      KSW=0
      KTMM=MWM
      KTT=KTW
      WRITE(6,7300)
7300  FORMAT(1H1,T10,'WAIT PROFILE SUMMARY'//)
7500  XTP=(100*KTMM)/KTT
      CALL HEADER(KTMM,XTP,COL)
      TOTAL=KTT
      DO 7600 I=1,N
      IF(KTT.LE.0)GO TO 7600
      IF(KK(I,1).LT.0)GO TO 7600
      IABS=KK(I,1)
      IWT=KK(I,2)
      NWT=KK(I,3)
      IREL=0
      XX=IWT
      IF(KSW.NE.0)XX=NWT
      COL(6)=(100.0*XX)/TOTAL
      IJK=XX+0.5
      IF(IJK.EQ.0)GO TO 7600
      CALL GRAPH(IABS,IREL,COL,CHAR,6,0.5*XTP,XTP,6,IJK)
7600  CONTINUE
      IF(KSW.NE.0)GO TO 8000
      KSW=1
      KTMM=MRM
      KTT=KTNW
      WRITE(6,7610)
7610  FORMAT(1H1,T10,'RUN PROFILE SUMMARY'//)
      GO TO 7500
8000  CONTINUE
C     PRINT OUT CONTROL MATRIX
      CALL MATRIX(ITCB,NME,ISEG,2,MSWTCH)
      WRITE(6,6001)
6001  FORMAT(1H1,'*** AUF WIEDERSEHEN ***'/////)
      WRITE(6,6002)
6002  FORMAT(1H1)
      STOP
      END
      SUBROUTINE MATRIX(ITCB,NME,ISEG,KODE,KSWTCH)
      REAL*8 FNAME(500),TNAME(500),NME
      INTEGER*4 ITCB,TCB(500),FSEG(500),TSEG(500),ISEG,NUM(500)
C
C     ROUTINE TO SUMMARIZE PASSAGE OF CONTROL FROM
C     ONE MODULE TO THE NEXT (BY TCB).
C
CTGS THIS ROUTINE IS INVOKED EACH TIME A NEW RECORD IS READ IN.
CTGS USING INFORMATION, THE RTNE CONSTRUCTS THE FOLLOWING TWO ARRAYS -
CTGS
CTGS ARRAY A -
CTGS ARRAY A IS COMPOSED OF THE ELEMENTS KTCB/KNAME/KSEG.  THERE IS A
CTGS ENTRY BUILT IN ARRAY A EACH TIME A RECORD IS READ CONTAINING A TCB
CTGS ADDRESS NOT ALREADY REPRESENTED IN ARRAY A.  IN OTHER WORDS, ARRAY
CTGS A REPRESENTS ALL THE TCBS THAT WERE CREATED UP TO THIS POINT IN
CTGS TIME IN THE TEST RUN.
CTGS
CTGS   KTCB  - IS THE TCB ADDRESS
CTGS
CTGS   KNAME - IS THE LOAD MODULE NAME FROM THE RECORD MOST CURRENTLY
CTGS           READ FOR THIS TCB.
CTGS   KSEG  - IS THE SEGMENT NUMBER FROM THE RECORD MOST CURRENTLY
CTGS           READ FOR THIS TCB.
CTGS
CTGS ARRAY B -
CTGS ARRAY B IS COMPOSED OF THE ELEMENTS TCB/FNAME/FSEG/TNAME/TSEG/NUM.
CTGS EACH ENTRY IN ARRAY REPRESENTS THE PASSING OF CONTROL FROM A GIVEN
CTGS LOAD MODULE/SEGMENT NUMBER TO ANOTHER GIVEN LOAD MODULE/SEGMENT
CTGS NUMBER.  THE NUM ASSOCIATED WITH EACH ENTRY IS A COUNT OF THE NUMBE
CTGS OF TIMES CONTROL WAS PASSED BETWEEN THOSE TWO ENTITIES.
CTGS
CTGS   TCB   - IS THE TCB ADDRESS
CTGS
      INTEGER*4 KTCB(255),KSEG(255)
CTGS   TNAME - IS THE NAME OF THE LOAD MODULE TO WHICH CONTROL IS BEING
CTGS           PASSED
CTGS
CTGS   TSEG  - IS THE SEGMENT NUMBER TO WHICH CONTROL IS BEING PASSED
CTGS
CTGS   FNAME - IS THE NAME OF THE LOAD MODULE FROM WHICH CONTROL IS BEIN
CTGS           PASSED
CTGS
CTGS   FSEG  - IS THE SEGMENT NUMBER FROM WHICH CONTROL IS BEING PASSED
CTGS
CTGS   NUM   - IS AN ACCUMULATOR. ONE IS ADDED TO NUM EACH TIME IT IS
CTGS           DETERMINED THAT CONTROL WAS PASSED FROM THIS PARTICULAR
CTGS           FNAME/FSEG TO A PARTICULAR TNAME/TSEG.
CTGS
CTGS THE CALLING PROGRAM SETS THE PARAMETER KODE TO ONE OF THREE VALUES.
CTGS
CTGS   KODE = 0  - FIRST TIME CALLED - PERFORM INITIALIZATION BEFORE
CTGS               PROCESSING RECORD.
CTGS
CTGS   KODE = 1  - NOT FIRST TIME CALLED - NORMAL PROCESS.
CTGS
CTGS   KODE GT 1 - PRINT OUT THE CONTENTS OF ARRAY B UNDER THE HEADING
CTGS               'CONTROL PASSING SUMMARY ---'
CTGS
      REAL*8 KNAME(255)
      IF(KODE.GT.0)GO TO 1000
C     INITIALIZE
      MAXT=255
      KSW=0
      MAX=500
      NENT=0
      NTCB=1
      DO 10 I=1,MAXT
      KTCB(I)=0
      KNAME(I)=0.0D0
10    KSEG(I)=0
      KTCB(1)=ITCB
      KNAME(1)=NME
      KSEG(1)=ISEG
C     TIMELINE ENTRY
      WRITE(6,996)ITCB,NME,ISEG
996   FORMAT(' TCB=',Z6,' NAME=',A8,' SEGMENT=',I3)
      RETURN
1000  IF(KODE.GT.1)GO TO 5000
C     SEE IF SYSTEM ROUTINES ARE TO BE IGNORED
      IF(KSWTCH.GT.0)GO TO 1111
      IF(ISEG.LE.0)RETURN
1111  CONTINUE
C     LOOK FOR TCB
      DO 100 I=1,NTCB
      IF(ITCB.NE.KTCB(I))GO TO 100
      K=I
      GO TO 200
100   CONTINUE
C     ADD NEW ACTIVE TCB
      NTCB=NTCB+1
      IF(NTCB.GT.MAXT)GO TO 900
      KTCB(NTCB)=ITCB
      KNAME(NTCB)=NME
      KSEG(NTCB)=ISEG
C     WRITE TIMELINE ENTRY
      WRITE(6,996)ITCB,NME,ISEG
      RETURN
C     SEE IF TASK HAS SWITCHED CONTROL
200   IF(KNAME(K).NE.NME)GO TO 500
      IF(KSEG(K).NE.ISEG)GO TO 500
C     CONTROL HAS NOT CHANGED FOR THIS TCB
      RETURN
C     LOOK FOR MATRIX ENTRY
500   IF(NENT.GT.0)GO TO 600
C     MAKE NEW MATRIX ENTRY
510   NENT=NENT+1
      IF(NENT.GT.MAX)GO TO 900
      TCB(NENT)=ITCB
      FNAME(NENT)=KNAME(K)
      FSEG(NENT)=KSEG(K)
      NUM(NENT)=1
      TNAME(NENT)=NME
      TSEG(NENT)=ISEG
      GO TO 800
C     SEARCH FOR PREVIOUS MATRIX ENTRY
600   DO 650 I=1,NENT
      IF(TCB(I).NE.ITCB)GO TO 650
      IF(FNAME(I).NE.KNAME(K))GO TO 650
      IF(FSEG(I).NE.KSEG(K))GO TO 650
      IF(TNAME(I).NE.NME)GO TO 650
      IF(TSEG(I).NE.ISEG)GO TO 650
C     INCREMENT COUNTER
      NUM(I)=NUM(I)+1
      GO TO 800
650   CONTINUE
      GO TO 510
C     CHANGE STATUS
800   KNAME(K)=NME
      KSEG(K)=ISEG
C     WRITE TIMELINE ENTRY
810   WRITE(6,996)ITCB,NME,ISEG
      RETURN
C     TURN ON TABLE OVERFLOW SWITCH
900   KSW=10
      GO TO  810
C
C     PRINT OUT RESULTS
C
5000  IF(KSW.LE.0)GO TO 1100
      WRITE(6,1001)
1001  FORMAT('1TABLE OVERFLOW OCCURRED IN MATRIX ROUTINE,',
     X   ' RESULTS PRINTED ARE ONLY PARTIAL SUMMARY'///)
1100  IF(NTCB.LE.0)RETURN
      IF(NENT.LE.0)RETURN
      DO 2000 I=1,NTCB
      M=KTCB(I)
      WRITE(6,1200)M
1200  FORMAT(1H1,'CONTROL PASSING SUMMARY FOR TASK WITH TCB',
     X  ' ADDRESS OF ',Z6//
     X  7X,'FROM',18X,'TO',15X,'NUMBER OF'/
     X  2(' NAME  OVERLAY SEGMENT'),2X,'OCCURRENCES'//)
      DO 2500 J=1,NENT
      IF(TCB(J).NE.M)GO TO 2500
      WRITE(6,2510)FNAME(J),FSEG(J),TNAME(J),TSEG(J),NUM(J)
2510  FORMAT(1H ,2(A8,4X,I3,7X),I9)
2500  CONTINUE
2000  CONTINUE
      RETURN
      END
      SUBROUTINE HEADER(N,XTP,COL)
C
C     WRITE LEGEND FOR THIS GRAPH.
C
      DIMENSION KP(5),K(5)
      DIMENSION COL(5)
      FACT=XTP/100.0
      DO 10 I=1,5
      XI=I
      KP(I)=FACT*(25.0*(XI-1.0))+0.5
      COL(I)=KP(I)
      XP=KP(I)
      XN=N
      K(I)=((XN*XP)/XTP)+0.5
10    CONTINUE
      WRITE(6,100)KP
100   FORMAT(11X,5(I3,' PERCENT',13X))
      WRITE(6,200)K
200   FORMAT(11X,5('  (',I5,')  ',13X))
      WRITE(6,300)
300   FORMAT(2X,'ABS.',3X,'REL.',3X,100(1H-),' NUMBER')
      RETURN
      END
      SUBROUTINE GRAPH(IABS,IREL,COL,CHAR,N,ORIGIN,FULL,IOUT,KNT)
C
C     ROUTINE TO DO PLOTTING ON STANDARD SYSTEM OUTPUT.
C
C     IABS - ABSOLUTE ADDRESS
C     IREL - RELATIVE ADDRESS
C     COL- ARRAY CONTAINING VALUES TO BE PLOTTED.
C     CHAR- ARRAY WITH BCD CHARACTERS TO BE PLOTTED FOR
C           CORRESPONDING VALUE.
C     N- NUMBER OF POINTS IN EACH COLUMN.
C     ORIGIN- VALUE AT CENTER LINE.
C     FULL- RANGE BETWEEN TOP AND BOTTOM OF GRAPH.
C     IOUT- LOGICAL UNIT TO BE PLOTTED ON (USUALLY 6)
C     KNT- NUMBER IN BUCKET
C
C
      DATA BLANK/1H /
      DIMENSION ARRAY(100),COL(1),CHAR(1)
      ONE = ORIGIN - 0.5 * FULL
      DO 10 I=1,100
  10  ARRAY(I) = BLANK
      DO 1000 I=1,N
      IF( COL(I) - ONE ) 100,100,200
 100  II = 1
      GO TO 300
 200  II = MIN0( 100 , INT( 100.0*((COL(I)-ONE)/FULL) + 0.5 ) )
      IF( II .LT. 1 ) II=1
 300  ARRAY(II) = CHAR(I)
      IF(I.NE.N)GO TO 1000
      DO 310 MMM=1,II
310   ARRAY(MMM)=CHAR(N)
 1000 CONTINUE
      WRITE(IOUT,1)IABS,IREL,ARRAY,KNT
1     FORMAT(1H ,Z6,1X,Z6,2X,100A1,I7)
      RETURN
      END
      SUBROUTINE CHECK(ITCB,NME,ISEG,IWT,IADD,KRET,KDUMP)
C
C     ROUTINE TO CHECK FOR DUPLICATE RUN RECORDS
C     WITH SAME ADDRESS. THIS MEANS THE MEASURED
C     TASK HAS NOT BEEN DISPATCHED DURING THE
C     TIME INTERVAL AND THE RECORD IS IGNORED.
C
      DATA NTCB/0/
      INTEGER*4 TCB(255),SEG(255),ADD(255),COUNT(255)
      REAL*8 NME,NAME(255)
C     TURN REJECT SWITCH OFF
      KRET=0
      IF(NTCB.GT.0)GO TO 100
      NTCB=1
      I=1
C     RESET THIS TCB
50    TCB(I)=ITCB
      SEG(I)=ISEG
      ADD(I)=IADD
      COUNT(I)=-IWT
      NAME(I)=NME
51    RETURN
C     FIND THIS TCB
100   DO 110 J=1,NTCB
      IF(TCB(J).NE.ITCB)GO TO 110
      I=J
      GO TO 200
110   CONTINUE
C     TCB NOT FOUND, ENTER NEW ONE
      NTCB=NTCB+1
      IF(NTCB.GT.255)STOP 88
      I=NTCB
      GO TO 50
C     SEE IF THIS IS A DUPLICATE RUN SAMPLE
200   IF(IWT.EQ.0)GO TO 300
C     SEE IF PRINT IS NEEDED BEFORE RESET
210   IF(COUNT(I).LE.0)GO TO 50
C     PRINT MESSAGE ON SKIPPED RECORDS
      IF(KDUMP.EQ.0)GO TO 1234
250   WRITE(6,251)COUNT(I),ADD(I),TCB(I),NAME(I),SEG(I)
251   FORMAT(1H ,I6,' SUCCESSIVE RUN SAMPLES DISCARDED AT',
     1 ' ADDRESS=',Z6,',TCB=',Z6,',NAME=',A8,',SEG=',I3)
1234  CONTINUE
      GO TO 50
C     CHECK NAME AND SEGMENT
300   IF(NAME(I).NE.NME)GO TO 210
      IF(SEG(I).NE.ISEG)GO TO 210
C     FINALLY, CHECK THE ADDRESS
      IF(ADD(I).NE.IADD)GO TO 210
C     TURN REJECT SWITCH ON
      KRET=10
C     INCREASE COUNTER
      IF(COUNT(I).LT.0)COUNT(I)=0
      COUNT(I)=COUNT(I)+1
      RETURN
         END
//LKED.SYSLMOD DD DSN=SYS2.USERLIB(PROGPLOT),DISP=SHR,VOL=
//LKED.SB DD DSN=&SB,DISP=OLD
//LKED.ST DD DSN=&ST,DISP=OLD
//LKED.SYSIN DD *
 INCLUDE SB(OBJSB)
 INCLUDE ST(OBJST)
 ENTRY MAIN
