 /* @WRITE */
 %NOPRINT;
         % IF @SPARSI ^= 'Y'
              % THEN % INCLUDE @SPARS;
         % IF @SETBUFI ^= 'Y'
              % THEN % INCLUDE @SETBUF;
         % @WRITEI = 'Y';
         % DCL @WRITE ENTRY;
 % @WRITE:  PROC(PARM1,PARM2,PARM3) STATEMENT RETURNS(CHAR);
 /*
0*$.HE GENERALIZED SUBROUTINES - @WRITE
0*$.HE PLI PREPROCESSOR TEXT
0*$.HE PUTS A LINE TO THE TSO TERMINAL
0*$.PL 55
0*$.PN 0
0*$.PA
0*$.SS
0*$.NF
0*$08/27/76
0*$AUTHOR:  T. SMITH
0*$SOURCE MODULE NAME:  @WRITE
0*$DOCUMENTATION ID:  0*$
0*$.FI L
0*$.SP 5
0*$THIS PLI PREPROCESSOR PROCEDURE CAN BE INVOKED TO GENERATE THE
0*$NECESSARY PLI STATEMENTS TO PRINT A LINE OF TEXT AT A TSO
0*$TERMINAL.  IT ITS SIMPLEST FORM, THE INVOCATION STATEMENT IS
0*$AS FOLLOWS -
0*$.SP 1
0*$.IN 5
0*$@WRITE('HELLO');
0*$.IN 0
0*$.SP 1
0*$AS A RESULT OF THE ABOVE STATEMENT, A PLI DECLARE STATEMENT
0*$TO DEFINE THE MESSAGE TEXT IS GENERATED, A CALL STATEMENT TO
0*$PERFORM SYMBOLIC REPLACEMENT (SEE EXPLANATION FURTHER ON), AND
0*$A CALL STATEMENT TO PUTLINE ARE GENERATED.
0*$.SP 1
0*$A SECOND FORMAT IS AS FOLLOWS -
0*$.SP 1
0*$.IN 5
0*$@WRITE(GREET,'HELLO');
0*$.IN 0
0*$.SP 1
0*$THE SAME PLI STATEMENTS WILL BE GENERATED AS IN THE FIRST
0*$FORMAT, EXCEPT THE NAME USED IN THE GENERATED DECLARE STATEMENT
0*$FOR THE MESSAGE TEXT WILL BE GREET.
0*$.SP 1
0*$A THIRD FORMAT IS -
0*$.SP 1
0*$.IN 5
0*$@WRITE(GREET,'HELLO',MF=L);
0*$.IN 0
0*$.SP 1
0*$THIS WILL GENERATE ONLY THE DECLARE STATEMENT FOR THE MESSAGE
0*$TEXT, AND WILL NOT GENERATE THE NECESSARY CALLS TO PUT THE
0*$MESSAGE TO THE TERMINAL.
0*$.SP 1
0*$A FOURTH FORMAT IS -
0*$.SP 1
0*$.IN 5
0*$@WRITE(GREET);
0*$.IN 0
0*$.SP 1
0*$THIS WILL GENERATE THE PLI CALL STATEMENTS TO PERFORM SYMBOLIC
0*$REPLACEMENT AND TO PUT THE MESSAGE TEXT PREVIOUSLY DEFINED WITH
0*$THE NAME GREET TO THE TSO TERMINAL.
0*$.SP 1
0*$THE FOLLOWING FORMAT IS ALSO VALID:
0*$.SP 1
0*$.IN 5
0*$@WRITE(NAME,MF=S);
0*$.IN 0
0*$.SP 1
0*$WHERE NAME IS THE NAME OF ANY CHARACTER STRING TO BE PRINTED AT
0*$THE TERMINAL.  EXAMPLE -
0*$.SP 1
0*$.IN 5
0*$.NF
0*$DCL STR(3) CHAR(5) INIT('DO','ANTS','SLEEP');
0*$DO I = 1 TO 3;
0*$  @WRITE(STR(I),MF=S);
0*$  END;
0*$.FI L
0*$.IN 0
0*$.SP 1
0*$NOTE THAT THIS PREPROCESSOR PROCEDURE ASSUMES THAT THE PROGRAM
0*$HAS BEEN INITIALIZED AS A TSO COMMAND PROCESSOR (SEE CPINIT -
0*$PREPROCESSOR TEXT TO INITIALIZE A TSO COMMAND PROCESSOR PROGRAM),
0*$AND HAS BEEN INVOKED AS A COMMAND PROCESSOR.
0*$.SP 1
0*$SEVERAL TIMES IN THE PRECEDING TEXT, SYMBOLIC REPLACEMENT HAS
0*$BEEN MENTIONED.  THIS IS A FACILITY WHEREBY SYMBOLS INDENTIFIED
0*$BY AN AMPERSAND AS THEIR FIRST CHARACTER CAN BE INCLUDED IN
0*$THE MESSAGE TEXT.  A CALL IS GENERATED BY @WRITE SO THAT AT
0*$EXECUTION TIME, THE VALUE WHICH EACH SYMBOLIC LABEL REPRESENTS
0*$REPLACES IT IN THE MESSAGE TEXT.  GENERAL RULES FOR THE
0*$SYMBOLIC LABELS ARE THAT THEY MUST BE EIGHT CHARACTERS OR LESS
0*$IN LENGTH, INCLUDING THE AMPERSAND, AND EXCEPT FOR THE
0*$AMPERSAND, THEY MAY CONTAIN ONLY ALPHANUMERIC CHARACTERS.
0*$SEE DOCUMENTATION FOR SUBROUTINES @SETL/@SETG TO FIND OUT HOW TO
0*$ESTABLISH VALUES FOR SYMBOLIC LABELS.
 */
         DCL (PARM1,PARM2,PARM3,NAME,TEXT,MF,RETSTR) CHAR;
         DCL (I,J) FIXED;
         PARM2=@STRIP(PARM2);
         PARM3=@STRIP(PARM3);
         RETSTR = 'DO;';
         RETSTR=RETSTR××@SETBUF(PARM1,PARM2,PARM3,NAME,MF);
         IF MF ^= 'MF=L'
              THEN RETSTR = RETSTR ××
                   ' BUFFER@='××NAME××'; CALL REP@(BUFFER@);'××
                   ' CALL PUTLINE(CPPLUPT,'××
                   'CPPLECT,CPECB,BUFFER@,IKJRET,''DATA'');'××
                   ' IF IKJRET^=0 THEN SIGNAL ERROR;';
         RETSTR=RETSTR ×× ' END;';
         RETURN(RETSTR);
         % END @WRITE;
 %PRINT;
