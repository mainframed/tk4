  /*ABE*/
 /**********************************************************************
 * COPYRIGHT 1983 BY THOMAS GLEN SMITH                                 *
 *                                                                     *
 * PERMISSION TO MAKE PRIVATE COPIES OF THIS PROGRAM AND TO USE IT     *
 * FREELY IS HEREBY GRANTED BY THE AUTHOR.  THIS PROGRAM MAY NOT BE    *
 * SOLD, NOR ANY SECTION OF IT BE INCORPORATED INTO ANY WORK FOR SALE  *
 * WITHOUT PERMISSION OF THE AUTHOR.                                   *
 *                                                                     *
 **********************************************************************/
   %INCLUDE ABESUB;
 ABESUB(MAIN); /* CHECK(YES); */
   %INCLUDE ABERHHDR;
   %INCLUDE ABEREC;
   %INCLUDE ABENTRYS;
   DCL 1 CPPL,
     2 CPPLCBUF PTR, /* COMMAND BUFFER */
     2 CPPLUPT PTR,  /* USER PROFILE TABLE */
     2 CPPLPSCB PTR, /* PROTECTED STEP CONTROL BLOCK */
     2 CPPLECT PTR;  /* ENVIRONMENT CONTROL TABLE */
   % DCL @SETBUFI CHAR;
   % INCLUDE @SETBUF;
   % DCL @LISTSW CHAR;
   % @LISTSW='N';
   % DCL @CMDI CHAR;
   % INCLUDE @CMD;
   % DCL @FREEI CHAR;
   % DCL @DA18SW CHAR;
   % @DA18SW='N';
   % INCLUDE @FREE;
   % INCLUDE @STRIP;
   % INCLUDE @SPARS;
   % INCLUDE @NULL;
   % DCL @ALLOCI CHAR;
   % DCL @DA08SW CHAR;
   % @DA08SW='N';
   % INCLUDE @ALLOC;
   DCL 1 TMPDSN@,
     2 DSNLEN FIXED BIN(15,0),
     2 DSNSTR CHAR(44);
   DCL PLIRETC BUILTIN;
   DCL (SYSDAIR,DAIRERR,SYSCTLG,SYSVTOC,SYSCMD,SYSGETM,PUTLINE,ABEFI)
     ENTRY;
   DCL SETDSN@ ENTRY RETURNS(CHAR(44) VARYING);
   DCL PSTR ENTRY(CHAR(*) VAR, FIXED BIN(15,0))
     RETURNS(FIXED BIN(15,0));
   DCL 1 BUFFER@,
     2 BUFLEN@ FIXED BIN(15,0),
     2 BUFOFF@ FIXED BIN(15,0) INIT(0),
     2 BUFSTR@ CHAR(256);
   DCL IKJRET FIXED BIN(31,0);
   DCL CPECB FIXED BIN(31,0) INIT(0);
   % INCLUDE IKJPSCB;
   % INCLUDE IKJECT;
   % INCLUDE IKJUPT;
   DCL SYMHD@ PTR;
   DCL ZZZZPTR PTR;
   DCL @NULLZ PTR,
       @NULLZD FIXED BIN(31,0) BASED(ZZZZPTR);
   ZZZZPTR=ADDR(@NULLZ);
   @NULLZD=0;

   DCL STACK ENTRY;
   DCL SETCAPS ENTRY;
   DCL (ABEBCH,ABESPF,ABETSO,ABEA,ABEIN) ENTRY;
   DCL SYSIN FILE RECORD INPUT ENV(FB RECSIZE(80));
   DCL SYSINSW BIT(1) INIT('1'B);
   DCL (PREFIX,SUFFIX) ENTRY RETURNS(FIXED BIN(15,0));
   DCL MYDSN CHAR(44) VAR;
   DCL (VTNAM,MYNAM) CHAR(8) VAR;
   DCL (INSW,OUTSW) BIT(1) INIT('0'B);
   DCL L FIXED BIN(15,0);
   DCL 1 CBUF BASED(CPPLCBUF),
      2 BUFLEN FIXED BIN(15,0) INIT(80),
      2 OFFSET FIXED BIN(15,0) INIT(0),
      2 BUFFER CHAR(80) INIT('SSE '''' INP(SCAN) HARDCOPY');
   DCL DCBPATPT PTR;
   DCL DUMCOR(28) FIXED BIN(31,0) INIT((28)0),
       DCBCOR CHAR(112) DEF DUMCOR;
   DCL 1 TRCON STATIC,
     2 TR1A CHAR(64) INIT((64)'.'),      /*   0 */
     2 TR1B CHAR(1)  INIT(' '),          /*  64 */
     2 TR1C CHAR(9)  INIT((9)'.'),       /*  65 */
     2 TR1D CHAR(7)  INIT('Ö.<(+×&'),    /*  74 */
     2 TR1E CHAR(9)  INIT((9)'.'),       /*  81 */
     2 TR1F CHAR(8)  INIT('!$*);^-/'),   /*  90 */
     2 TR1G CHAR(8)  INIT((8)'.'),       /*  98 */
     2 TR1H CHAR(6)  INIT('|,%_>?'),     /* 106 */
     2 TR1J CHAR(9)  INIT((9)'.'),       /* 112 */
     2 TR1K CHAR(7)  INIT('`:#@''="'),   /* 121 */
     2 TR1L CHAR(1)  INIT('.'),          /* 128 */
     2 TR1M CHAR(9)  INIT('abcdefghi'),  /* 129 */
     2 TR1N CHAR(7)  INIT((7)'.'),       /* 138 */
     2 TR1O CHAR(9)  INIT('jklmnopqr'),  /* 145 */
     2 TR1P CHAR(7)  INIT((7)'.'),       /* 154 */
     2 TR1Q CHAR(9)  INIT('~stuvwxyz'),  /* 161 */
     2 TR1I CHAR(22) INIT((22)'.'),      /* 170 */
     2 TR2 CHAR(10)  INIT('{ABCDEFGHI'), /* 192 */
     2 TR3 CHAR(6)   INIT((6)'.'),       /* 202 */
     2 TR4 CHAR(10)  INIT('}JKLMNOPQR'), /* 208 */
     2 TR4A CHAR(6)  INIT((6)'.'),       /* 218 */
     2 TR4B CHAR(1)  INIT((1)'\'),       /* 224 */
     2 TR4C CHAR(1)  INIT('.'),          /* 225 */
     2 TR5 CHAR(8)   INIT('STUVWXYZ'),   /* 226 */
     2 TR6 CHAR(6)   INIT((6)'.'),       /* 234 */
     2 TR7 CHAR(10)  INIT('0123456789'), /* 240 */
     2 TR8 CHAR(6)   INIT((6)'.');       /* 250 */
   DCL TRDEF CHAR(256) DEF TRCON;
   DCL TRTAB CHAR(256);

   ON UNDEFINEDFILE(SYSIN) SYSINSW='0'B;
   SYMHD@=NULL;
   DCBPATPT=NULL;
   ALLOCATE RHHDR;
   RH_XSCALE,RH_YSCALE=1.0;
   RH_XOFFSET,RH_YOFFSET=0.0;
   RH_XCOMPTR=NULL;
   RH_STACK,RH_QUEUE=NULL;
   RH_APLPTR=NULL;
   TRTAB=TRDEF;
   RHTRTAB=ADDR(TRTAB);
   RHUPT=CPPLUPT;
   RHPSCB=CPPLPSCB;
   RHECT=CPPLECT;
   RHRC=0;
   RH_SYMTREE=NULL;
   ALLOCATE SUBENTSTR;
   #DOFRE     = DOFRE;   /* FREE DATASET */
   #DOALC     = DOALC;   /* ALLOC DATASET */
   #DOCMD     = DOCMD;   /* EXECUTE TSO COMMAND */
   #PROMPT    = DOPRM;   /* PROMPT FOR ISTACK INPUT */
   #TERM      = TERMWRT; /* HARDCOPY TERMINAL OUTPUT */
   #PROMPTL   = DOPRMLO; /* PROMPT FOR TERMINAL INPUT - LO */
   #STACK     = DOSTK;   /* TSO STACK INTERFACE */
   #ABEA      = ABEA;    /* ABE MAINLINE PROCESSING */
   #ABEIN     = ABEIN;   /* ABE MAINLINE INITIALIZATION */
   #ABETR     = ABETR;   /* COMMON TRANSLATE ROUTINE */
   SELECT(SUBSTR(CBUF.BUFFER,1,3));
     WHEN('BCH') DO;
       #TERM=TERMBCH;
       OPEN FILE(SYSIN) RECORD INPUT;
       FETCH ABEBCH;
       CALL ABEBCH(RHHDRPT,CPPLCBUF,SYSIN,SYSINSW);
       END;
     WHEN('SPF') CALL ABESPF(RHHDRPT,CPPLCBUF);
     WHEN('ABS') DO;
       UNSPEC(RH_XCOMPTR)=UNSPEC(SUBSTR(CBUF.BUFFER,5,4));
       CBUF.BUFLEN=7;
       CALL ABETSO(RHHDRPT,CPPLCBUF);
       END;
     OTHERWISE   CALL ABETSO(RHHDRPT,CPPLCBUF);
     END; /* SELECT */
   /* NOW SET RETURN CODE */
   CALL PLIRETC(#SYMA(RHHDRPT,RH_SYMTREE,'RC'));

 ABETR:  PROC(REC);
   DCL REC CHAR(*) VAR;
   DCL TRT CHAR(256) BASED(TRTPTR);

   REC=TRANSLATE(REC,RHTRTAB->TRT);
   END ABETR;

 DOALC:PROC(PRMDSN,IO,RETDDN,PRH,PVOL);
   /* IO='BPA' IF THE DATA SET IS TO BE PROCESSED USING BPAM */
   /* IO='NPR' IF THE USER IS NOT TO BE PROMPTED IF DATA SET IS NEW */
   /* IO='SAS' IF THE DATASET IS A SAS LIBRARY */
   DCL (DOADSN,PRMDSN,PREVAL) CHAR(44) VARYING;
   DCL PVOL CHAR(6);
   DCL LDDDSN CHAR(44);
   DCL LDDDDN CHAR(8);
   DCL ABEBLD ENTRY(PTR,CHAR(112),CHAR(8),CHAR(8))RETURNS(BIT(1));
   DCL (RETDDN,PRH) PTR;
   DCL IO CHAR(3) VAR;
   % INCLUDE DSCB1;
   % INCLUDE JFCB;
   % INCLUDE CTLGDEF;
   % INCLUDE DAIR14;
   DCL JFCBCOR CHAR(176);
   DCL SYSJFCB ENTRY(CHAR(8),PTR);
   DCL ABELDD ENTRY(CHAR(44),CHAR(6))
     RETURNS(CHAR(8));
   DCL VSW BIT(1);
   DCL QUAL CHAR(8) VAR;
   DCL 1 Q1,
     2 QUALEN FIXED BIN(15,0) INIT(80),
     2 ANYN1 FIXED BIN(15,0) INIT(0),
     2 QUALSTR CHAR(76) INIT(' ');
   DCL 1 Q2 DEF Q1,
     2 QUALARY(10) CHAR(8);
   DCL Q3 CHAR(80) DEF Q1;
   DCL MYP CHAR(3) VAR;
   DCL CVOL CHAR(6) INIT('SYSRES');
   DCL RETCODE FIXED BIN(31,0);
   DCL RETCODC CHAR(4) DEF RETCODE;
   DCL RET BIT(32) DEF RETCODE;
   DCL WKAREA CHAR(148);
   DCL DSCB1PTR PTR,PTR1ADJ FIXED BIN(31,0) DEF DSCB1PTR;
   JFCBPTR=ADDR(JFCBCOR);
   DSCB1PTR = ADDR(WKAREA);
   PTR1ADJ = PTR1ADJ - 44;
   DCL SAVRFM BIT(8);
   DCL (MYLRECL,MYBLKL) FIXED BIN(31,0);
   DCL AREA CHAR(265);
   CTLGPTR = ADDR(AREA);
   DCL MOD BUILTIN;
   DCL AINSW BIT(1);
   DCL PREALCSW BIT(1) INIT('0'B);

   RETDDN=NULL;
   AINSW ='0'B;
   SUBSTR(DA08CTL,3,1)='0'B;
   DOADSN = PRMDSN;
   DA08DDN='';
   DA08PDSN=ADDR(TMPDSN@);
   IF SUBSTR(DOADSN,1,1) =''''
     THEN DOADSN=SUBSTR(DOADSN,2,LENGTH(DOADSN)-2);
     ELSE DO;
       PREVAL=#SYMC(RHHDRPT,RH_SYMTREE,'SYSPREF');
       IF PREVAL=''
         THEN PREVAL=#SYMC(RHHDRPT,RH_SYMTREE,'SYSUID');
       DOADSN=PREVAL××'.'××DOADSN;
       END;
   I = INDEX(DOADSN,'(');
   IF I ^= 0
     THEN DO;
       DA08MNM=SUBSTR(DOADSN,I+1,LENGTH(DOADSN)-I-1);
       DOADSN=SUBSTR(DOADSN,1,I-1);
       END;
     ELSE DA08MNM='';
   IF PVOL=''
     THEN DO;
       DA14PDSN=ADDR(DOADSN);
       DA14PRET=ADDR(QUALEN);
       CALL SYSDAIR(CPPLUPT,CPPLECT,CPECB,CPPLPSCB,DAIR14,IKJRET);
       IF IKJRET = 0
         THEN IF QUALARY(1) ^= LOW(8)
           THEN DO;
             IF QUALARY(2) = LOW(8)
               THEN DOADSN=DOADSN××'.'××SUBSTR(QUALARY(1),1,
                   SUFFIX(QUALARY(1),' '));
               ELSE DO;
                 CALL #TERM
                   ('QUALIFIERS FOR DATA SET '××DOADSN××' ARE ');
                 CALL #TERM(Q3);
                 QUAL= #PROMPTL('ENTER QUALIFIER-');
                 CALL SETCAPS(QUAL);
                 DOADSN=DOADSN××'.'××QUAL;
                 END;
             END;
       END;
   TMPDSN@.DSNSTR=DOADSN;
   TMPDSN@.DSNLEN=LENGTH(DOADSN);
   LDDDSN=DOADSN;
   IF DA08MNM^=''
     THEN LDDDSN=DOADSN××'('××SUBSTR(DA08MNM,1,SUFFIX(DA08MNM,' '))××
       ')';
     ELSE LDDDSN=DOADSN;
   IF IO^='SAS'
     THEN DA08DDN = ABELDD(LDDDSN,PVOL);
   IF DA08DDN^=''
     THEN DO;
       PREALCSW='1'B; /* DATA SET IS PREALLOCATED */
       RETCODE=0;
       CALL SYSJFCB(DA08DDN,JFCBPTR);
       VOLID.VOLSER(1)=JFCBVOLS(1);
       END;
     ELSE DO;
       PREALCSW='0'B; /* DATA SET IS NOT PREALLOCATED */
       IF PVOL=''
         THEN DO;
           CALL SYSCTLG('NAME',RET,DOADSN,CVOL,AREA);
           JFCBCOR=LOW(176);
           END;
         ELSE DO; /* DOESN'T NEED TO BE CATALOGED. */
           @ALLOC(DA,VOLUME(PVOL),SHR);
           CALL SYSJFCB(DA08DDN,JFCBPTR);
           VOLID.VOLSER(1)=JFCBVOLS(1);
           RETCODE=0;
           END;
       END;
   IF VOLID.VOLSER(1)^=PVOL & PVOL^=''
     THEN DO;
       CALL #TERM('JFCB/DSCB VOL DOESN''T MATCH PVOL');
       RETURN;
       END;
   IF RETCODE ^= 0
     THEN DO;
       IF IO^='NPR'
         THEN DO;
           IF ^OKDSN(DOADSN)
             THEN DO;
               CALL #TERM('DSNAME '××DOADSN××' NO GOOD.');
               RETURN;
               END;
           CALL #TERM('DATA SET '××DOADSN××' DOESN''T EXIST.');
           DO UNTIL(MYP='Y'×MYP='N'×MYP='YES'× MYP='NO'×MYP='');
             MYP= #PROMPTL
                         ('ENTER A NULL LINE, ''YES'', OR ''Y'' TO CREAT
 E A DATA SET, OR ''NO'' OR ''N''');
             CALL SETCAPS(MYP);
             END;
           IF MYP^='YES'& MYP^='Y'& MYP^=''
             THEN RETURN;
           END;
       SELECT;
         WHEN(DA08MNM^='' & PVOL='') DO;
           @ALLOC(DA,NEW,SP(1,4),TRKS,DIR(27));
           END;
         WHEN(DA08MNM='' & PVOL='') DO;
           @ALLOC(DA,NEW,SP(1,4),TRKS);
           END;
         WHEN(DA08MNM^='' & PVOL^='') DO;
           @ALLOC(DA,NEW,SP(1,4),TRKS,DIR(27),VOLUME(PVOL));
           END;
         WHEN(DA08MNM='' & PVOL^='') DO;
           @ALLOC(DA,NEW,SP(1,4),TRKS,VOLUME(PVOL));
           END;
         OTHERWISE;
         END; /* SELECT */
       DA18DDN=DA08DDN;
       @FREE(DA);
       IF IO='SAS'
         THEN IF PVOL=''
           THEN @ALLOC(DA,OLD);
           ELSE @ALLOC(DA,OLD,VOLUME(PVOL));
         ELSE IF PVOL=''
           THEN @ALLOC(DA,SHR);
           ELSE @ALLOC(DA,SHR,VOLUME(PVOL));
       IF PRH=NULL
         THEN DO;
           L,MYLRECL=80;
           B,MYBLKL=1680;
           SAVRFM='10010000'B;
           VSW='0'B;
           END;
         ELSE DO;
           L,MYLRECL=PRH->RHLRECL;
           B,MYBLKL=PRH->RHBLKL;
           SAVRFM=PRH->RHRECFM;
           SELECT(SUBSTR(PRH->RHRECFM,1,2));
             WHEN('01'B) VSW='1'B; /* RECFM=VB. */
             WHEN('10'B) VSW='0'B; /* RECFM=FB. */
             OTHERWISE   VSW='0'B; /* RECFM=U */
             END;
           END;
       FETCH ABEFI;
       CALL ABEFI(MYLRECL,MYBLKL,SAVRFM,DA08DDN);
       END;
     ELSE DO; /* DATA SET ALREADY EXISTS */
       CALL SYSVTOC('SEARCH',RET,DOADSN,VOLID.VOLSER(1),WKAREA);
       IF DA08DDN^=''
         THEN DO;
           IF JFCDSORG^='0'B
             THEN DS1DSORG=JFCDSORG;
           IF JFCRECFM^='0'B
             THEN DS1RECFM=JFCRECFM;
           IF JFCLRECL^='0'B
             THEN DS1LRECL=JFCLRECL;
           IF JFCBLKSI^='0'B
             THEN DS1BLKL=JFCBLKSI;
           END;
       CKDS:DO;
         IF RET ^= 0
           THEN DO;
             DA08DDN=''; /* MAKE SURE AN ERROR IS INDICATED */
             LEAVE CKDS;
             END;
         IF SUBSTR(DS1DSORG,2,1) /* PS? */ & DA08MNM^=''
           THEN DO;
             DA08DDN=''; /* MAKE SURE AN ERROR IS INDICATED */
             LEAVE CKDS;
             END;
         IF ^SUBSTR(DS1DSORG,2,1) /* PS? */
           THEN IF SUBSTR(DS1DSORG,7,1) /* PO? */
             THEN IF DA08MNM =''& IO^='BPA'
               THEN DA08MNM ='TEMPNAME';
               ELSE;
             ELSE IF IO^='SAS'
               THEN LEAVE CKDS;
         IF DA08MNM=''
           THEN IF DS1LSTAR='0'B
             THEN AINSW='1'B;
         SELECT(SUBSTR(DS1RECFM,1,2));
           WHEN('01'B)DO; /* RECFM=V */
             VSW ='1'B;
             L = DS1LRECL;
             END;
           WHEN('10'B)DO; /* RECFM=F */
             VSW ='0'B;
             L = DS1LRECL;
             END;
           OTHERWISE DO /* RECFM=U */
             VSW ='1'B;
             IF IO='SAS'
               THEN L = 256;
               ELSE L = DS1BLKL;
             END;
           END;
         B=DS1BLKL;
         SAVRFM=DS1RECFM;
         IF DA08DDN=''
           THEN CALL DOALC_SUB(IO);
         END CKDS;
       END;
   IF DA08DDN ^=''
     THEN DO;
       ALLOCATE ALCSTR SET(RETDDN);
       /* NOTE THAT THE ALLOCATE WILL SET
       FIELD ALCRECL WITH THE CURRENT
       VALUE OF L. */
       RETDDN->ALCDSN = DOADSN;
       RETDDN->ALCMEM = DA08MNM;
       RETDDN->ALCDDN = DA08DDN;
       RETDDN->ALCFLAG ='0'B;
       SUBSTR(RETDDN->ALCFLAG,5,1)=PREALCSW;
       RETDDN->ALCBLKL=B;
       RETDDN->ALCRECFM=SAVRFM;
       IF DA08MNM ^=''
         THEN DO;
           DA08DDN,LDDDDN=ABELDD(DOADSN,PVOL);
           IF LDDDDN=''
             THEN DO;
               DA08MNM='';
               IF PVOL=''
                 THEN @ALLOC(DA,SHR);
                 ELSE @ALLOC(DA,SHR,VOLUME(PVOL));
               END;
           SUBSTR(RETDDN->ALCFLAG,7,1)=^ABEBLD(DCBPATPT,DCBCOR,
             DA08DDN,RETDDN->ALCMEM);
           IF LDDDDN=''
             THEN DO;
               DA18DDN=DA08DDN;
               @FREE(DA);
               END;
           END;
         ELSE SUBSTR(RETDDN->ALCFLAG,7,1)=AINSW;
       SUBSTR(RETDDN->ALCFLAG,3,1) = VSW;
       DO I = LENGTH(RETDDN->ALCDSN) TO 1 BY -1 WHILE(SUBSTR(RETDDN->
         ALCDSN,I,1)^='.');
         END;
       QUAL = SUBSTR(RETDDN->ALCDSN,I+1);
       SELECT(QUAL);
         WHEN('COBOL')DO;
           RETDDN->ALCSEQOFF = 0;
           RETDDN->ALCSEQLEN = 6;
           END;
         WHEN('VSBASIC')DO;
           RETDDN->ALCSEQOFF = 0;
           RETDDN->ALCSEQLEN = 5;
           END;
         OTHERWISE DO;
           RETDDN->ALCSEQLEN = 8;
           IF SUBSTR(RETDDN->ALCFLAG,3,1) /* RECFM = V? */
             THEN RETDDN->ALCSEQOFF = 0;
             ELSE RETDDN->ALCSEQOFF = RETDDN->ALCRECL-8;
           END;
         END;
       IF QUAL ='TEXT'
         THEN SUBSTR(RETDDN->ALCFLAG,8,1)='1'B;
       END;
     ELSE RETDDN = NULL;
   END DOALC;

 DOALC_SUB: PROC(IO);
  /*********************************************************************
  * USED TO CONTROL ERROR CONDITIONS DURING ALLOCATE.                  *
  *********************************************************************/
   DCL IO CHAR(3) VAR;

   ON ERROR GOTO DOALC_SUB_BADRET;
   IF IO='SAS'
     THEN @ALLOC(DA,OLD);
     ELSE @ALLOC(DA,SHR);
   RETURN;
 DOALC_SUB_BADRET:;
   DA08DDN='';
   END DOALC_SUB;

 DOCMD:PROC(CMD,HELP);
  /*********************************************************************
  * DOCMD, SUBENT(7), SUBENT(49), #DOCMD FOR TSO EXECUTION             *
  *********************************************************************/
   DCL HELP CHAR(4) VAR;
   DCL CMD CHAR(240) VAR;
   IF HELP ='HELP'
     THEN DO;
       @CMD(CMD,MF=S,,HELP);
       END;
     ELSE DO;
       @CMD(CMD,MF=S);
       END;
   END DOCMD;
 DOFRE:PROC(PRMDDN);
   DCL PRMDDN PTR;
   DA18DDN = PRMDDN->ALCDDN;
   @FREE(DA,KEEP);
   FREE PRMDDN->ALCSTR;
   END DOFRE;
 DOPRM:PROC(PRMPT,INP);
   DCL PRMPT CHAR(80) VAR;
   DCL INP CHAR(*) VAR;
   DCL GETCMD ENTRY(PTR,PTR,CHAR(80) VAR, FIXED BIN(31,0),CHAR(*) VAR);
   CALL GETCMD(CPPLUPT,CPPLECT,PRMPT,IKJRET,INP);
   CALL SETCAPS(INP);
   RETURN;
   END DOPRM;
 DOPRMLO:PROC(PRMPT,INP);
   DCL PRMPT CHAR(80) VAR;
   DCL INP CHAR(*) VAR;
   DCL GETCMD ENTRY(PTR,PTR,CHAR(80) VAR, FIXED BIN(31,0),CHAR(*) VAR);
   CALL GETCMD(CPPLUPT,CPPLECT,PRMPT,IKJRET,INP);
   END DOPRMLO;
 DOSTK:PROC(CMD);
   DCL CMD CHAR(*) VAR;
   DCL SP FIXED BIN(15,0) INIT(78);
   DCL IOECB FIXED BIN(31,0) INIT(0);
   DCL 1 STOR78 UNALIGNED BASED(PTR78),
     2 LSDADATA PTR,
     2 LSDRCLEN FIXED BIN(15,0),
     2 LSDTOTLN FIXED BIN(15,0),
     2 LSDANEXT PTR,
     2 LSDRSVRD FIXED BIN(31,0),
     2 STARTLIST FIXED BIN(31,0);
   DCL 1 LISTEL UNALIGNED BASED(LELPTR),
     2 LELLEN FIXED BIN(15,0),
     2 LELCMD CHAR(256) VAR;
   DCL 1 LISTEL2 UNALIGNED BASED(LELPTR),
     2 LELPAD FIXED BIN(15,0),
     2 LELZRO FIXED BIN(15,0);
   DCL (LV,RETCODE) FIXED BIN(31,0);
   LV=LENGTH(CMD)+20;
   CALL SYSGETM('EU',LV,PTR78,SP,RETCODE);
   IF RETCODE^=0
     THEN SIGNAL ERROR;
   LSDADATA,LSDANEXT,LELPTR=ADDR(STARTLIST);
   LSDRCLEN=0;
   LSDTOTLN=LENGTH(CMD)+4;
   LSDRSVRD=0;
   LELCMD=CMD;
   LELLEN=LENGTH(CMD)+4;
   LELZRO=0;
   CALL STACK(CPPLUPT,CPPLECT,IOECB,RETCODE,'PROCN',PTR78);
   END DOSTK;
 OKDSN: PROC(PARM) RETURNS(BIT(1));
 /**********************************************************************
 * OKDSN IS CALLED TO CONFIRM THAT A DSNAME IS OF PROPER FORMAT.       *
 * A '1'B WILL BE RETURNED IF DSNAME IS OK.                            *
 **********************************************************************/
   DCL PARM CHAR(44) VAR;
   DCL ALPHA CHAR(29) STATIC INIT('ABCDEFGHIJKLMNOPQRSTUVWXYZ$@#');
   DCL NUM CHAR(10) STATIC INIT('0123456789');
   DCL (I,J,K,L) FIXED BIN;

   L=LENGTH(PARM);
   IF L=0
     THEN RETURN('0'B); /* NOT OK */
   I,J=1;
   DO WHILE(I<=L) UNTIL(J=0);
     IF VERIFY(SUBSTR(PARM,I,1),ALPHA)^=0
       THEN J=0; /* INVALID STARTING CHARACTER */
       ELSE DO;
         K=INDEX(SUBSTR(PARM,I),'.');
         IF K=0
           THEN K=L-I+2;
         IF K=1
           THEN J=0; /* ERROR - PERIOD AT START OR TWO IN ROW */
           ELSE IF K>9
             THEN J=0; /* ERROR - QUALIFIER LONGER THAN 8 */
             ELSE DO;
               IF K>2 /* IS QUALIFIER LONGER THAN 1 CHAR? */
                 THEN IF VERIFY(SUBSTR(PARM,I+1,K-2),ALPHA××NUM)^=0
                   THEN J=0; /* INVALID CHARACTER */
               I=I+K;
               IF I=L+1
                 THEN J=0; /* ERROR - PERIOD AT END */
               END;
         END;
     END;
   IF J=0
     THEN RETURN('0'B); /* NOT OK */
     ELSE RETURN('1'B); /* OK */
   END OKDSN;

 SETDSN:PROC(PDEPARM) RETURNS(CHAR(44) VAR);
   DCL PDEPARM CHAR(24);
   DCL DSNRET CHAR(44) VAR;
   DSNRET=SETDSN@(PDEPARM);
   IF DSNRET^=''
     THEN DSNRET=''''××DSNRET××'''';
   RETURN(DSNRET);
   END SETDSN;

 TERMBCH:PROC(TMSG);
   DCL TMSG CHAR(*) VAR;

   PUT SKIP EDIT(TMSG)(A);
   END TERMBCH;

 TERMWRT:PROC(TMSG);
   DCL TMSG CHAR(*) VAR;
   BUFLEN@=MIN(256,LENGTH(TMSG))+4;
   BUFSTR@=TMSG;
   CALL PUTLINE(CPPLUPT,CPPLECT,CPECB,BUFFER@,IKJRET,'DATA');
   IF IKJRET^=0
     THEN SIGNAL ERROR;
   END TERMWRT;

   END;
