.LL 65
.HE GENERALIZED ROUTINES - PLIST
.HE WRITING TSO COMMAND PROCESSORS IN PLI
.PL 55
.PN 0
.PA
.SS
.NF
09/14/76
AUTHOR:  T. SMITH
SOURCE MODULE NAME:  PLIST
.SP 5
CONTENTS
.SP 1
GENERAL INTRODUCTION--------------------------- 02
COMMAND PROCESSOR INITIALIZATION--------------- 09
@CMD - INVOKING OTHER TSO COMMANDS------------- 10
@READ - READ A LINE FROM THE TERMINAL---------- 11
@WRITE - WRITE A LINE TO THE TERMINAL---------- 12
@PUTGET - PROMPT THE TERMINAL AND GET A LINE--- 13
SYMBOLIC REPLACEMENT--------------------------- 14
@REP - SYMBOLIC REPLACEMENT FUNCTION----------- 16
@PROC - OBTAIN COMMAND OPERANDS --------------- 17
@ALLOC - DIRECT INTERFACE TO ALLOCATION-------- 20
@FREE - DIRECT INTERFACE TO FREE--------------- 22
ABBREVIATION OF @ALLOC AND @FREE KEYWORDS------ 23
HOW TO COMPILE AND EXECUTE A PLI/TSO COMMAND--- 24
DAIRERR - SUBROUTINE TO HANDLE DAIR ERRORS----- 26
ACCESSING THE COMMAND BUFFER------------------- 27
USING THE IBM-SUPPLIED PARSE ROUTINE----------- 28
HOW TO COMPILE WHEN USING ASSEMBLER
     PARSING MACROS---------------------------- 30
.FI L
.PA
***** GENERAL INTRODUCTION
.SP 2
THIS PAPER DESCRIBES A SERIES OF SUBROUTINES AND PL/I PREPROCESSOR
FUNCTIONS COLLECTIVELY CALLED PLIST.  PLIST MAKES IT VERY EASY TO
CREATE A LOAD MODULE WHICH CAN FUNCTION AS A TSO COMMAND PROCESSOR.
SEVERAL SAMPLE SOURCE DECKS ARE LISTED IN THE FOLLOWING PAGES TO
ILLUSTRATE THE EASE WITH WHICH COMMAND PROCESSORS CAN BE WRITTEN.
.PA
SAMPLE SOURCE DECK #1 - TOD
.SP 1
.NF
 % INCLUDE CPINIT;
 @WRITE('DATE=&SYSDATE, TIME=&SYSTIME, USERID=&SYSUID');
 END;
.FI L
.SP 1
.IN 0
THE TOD COMMAND PROCESSOR WILL CAUSE THE CURRENT DATE, TIME, AND USERID
TO BE LISTED AT THE TERMINAL.
.PA
SAMPLE SOURCE DECK #2 - BGD
.SP 1
.NF
 % INCLUDE CPINIT;
 @PROC(1,DSN);
 @WRITE('BGD NOT SUPPORTED IN MVS - CMD CHANGED TO SUBMIT');
 @CMD('SUBMIT &DSN');
 END;
.FI L
.SP 1
THIS COMMAND WAS USED IN A CONVERSION FROM MVT TO MVS.  UNDER MVT, A
USER COMMAND CALLED BGD WAS USED TO SUBMIT JOBS TO HASP FROM TSO.
UNDER MVS HOWEVER, THE NORMAL SUBMIT COMMAND CAN BE USED.  WITH THE
ABOVE SOURCE COMPILED AND LINKEDITED INTO THE COMMAND LIBRARY,
IF THE USER ENTERS THE BGD COMMAND, HE IS REMINDED WITH A MESSAGE,
AND THE SUBMIT COMMAND IS ISSUED FOR HIM.
.PA
EXAMPLE #3 - PIZZA
.SP 1
PLIST ALLOWS YOU TO SPECIFY TSO RELATED FUNCTIONS IN THE PLI PROGRAM
WITH A SYNTAX SIMILAR TO THAT USED WHEN CODING MVS CLIST DATA SETS.
IN EXAMPLE #3, THE PIZZA CLIST FROM THE OS/VS2 TERMINAL USER'S GUIDE
HAS BEEN RECODED AS A PLI PROGRAM.  NOTE THAT THE PLI PROGRAM IS
APPROXIMATELY 40 STATEMENTS LONG WHEN THE ORIGINAL CLIST WAS ABOUT
75 STATEMENTS.  THE PL/I PROGRAM
EXECUTES MORE THAN 3 TIMES AS FAST.
THE PL/I SOURCE IS FIRST LISTED ON THE FOLLOWING PAGE, THEN THE
MVS CLIST IS GIVEN FOR COMPARISON.
.SP 1
.PA
EXAMPLE #3 - PIZZA PL/I PROGRAM
.SP 1
.NF
% INCLUDE CPINIT;
DFT RANGE(*) FIXED BIN;
@PROC(0,SLICE(33),SODA(35),COFFEE(25),MILK(30));
@WRITE('SLICES    1     2     3     4     5     6     7
8     9     10');
@WRITE(' ');
DCL HEAD(9) CHAR(9) INIT('NO DRINK','1 SODA','2 SODAS',
'3 SODAS','1 COFFEE','2 COFFEES','3 COFFEES','1 MILK',
'2 MILKS');
DCL (COST(10),COSTOUT,SLCE,WORK,I,J,K) FIXED DEC(7,4);
DCL SYMTAB(3) CHAR(7) INIT('&SODA','&COFFEE','&MILK');
DCL COSTLNE CHAR(78) INIT(' ');
COST(1)=0;
DO I = 1 TO 3;
  WORK = SYMA(SYMTAB(I));
  DO K = 1 TO 3;
    COST((I-1)*3+1+K)=K*WORK/100;
    END;
  END;
SLCE=SYMA('&SLICE');
SLCE=SLCE/100;
DO I = 1 TO 9;
  DO J = 1 TO 10;
    COSTOUT=ROUND(COST(I)+SLCE*J*.15+SLCE*J,2);
    WORK=MOD(COSTOUT,.05);
    IF WORK > .02
      THEN COSTOUT=COSTOUT+.05-WORK;
      ELSE COSTOUT=COSTOUT-WORK;
    PUT STRING(SUBSTR(COSTLNE,(J-1)*6+10,5))
      EDIT(COSTOUT)(P'Z9V.99');
    END;
  PUT STRING(SUBSTR(COSTLNE,1,9)) EDIT(HEAD(I))(A);
  @WRITE(COSTLNE,MF=S);
  END;
@WRITE(' ');
@WRITE('THE ABOVE PRICES APPLY TO:');
@WRITE('  SLICE OF PIZZA .&SLICE');
@WRITE('  A SODA         .&SODA');
@WRITE('  A COFFEE       .&COFFEE');
@WRITE('  A MILK         .&MILK');
@WRITE('A TIP OF 15% ON THE COST OF THE PIZZA
  IS ALSO INCLUDED');
@WRITE('FOR OTHER DRINK ITEMS, FIGURE RESULTS
  SEPARATELY');
END;
EXAMPLE #3 - MVS PIZZA CLIST FOR COMPARISON
.SP 1
PROC 0 SLICE(33) SODA(35) COFFEE(25) MILK(30)
WRITE SLICES  1     2     3     4     5     6     7
8     9     10
WRITE
SET RETNUM=1
SET HEAD1=NO DRINK
SET COST1=0
SET HEAD2=1 SODA
SET COST2=&SODA
SET HEAD3=2 SODAS
SET COST3=&SODA*2
SET HEAD4=3 SODAS
SET COST4=&SODA*3
SET HEAD5=1 COFFEE
SET COST5=&COFFEE
SET HEAD6=2 COFFEES
SET COST6=&COFFEE*2
SET HEAD7=3 COFFEES
SET COST7=&COFFEE*3
SET HEAD8=1 MILK
SET COST8=&MILK
SET HEAD9=2 MILKS
SET COST9=&MILK*2
DO WHILE &RETNUM LE 9
  SET HEAD=&&HEAD
  SET COST=&&COST
  SET HEAD=&HEAD&RETNUM
  SET COST=&COST&RETNUM
  GOTO ROUTINE
RETURN: +
END
WRITE
WRITE THE ABOVE PRICES APPLY TO:
WRITE   SLICE OF PIZZA .&SLICE
WRITE   A SODA         .&SODA
WRITE   A COFFEE       .&COFFEE
WRITE   A MILK         .&MILK
WRITE A TIP OF 15% ON THE COST OF THE PIZZA IS ALSO INCLUDED
WRITE FOR OTHER DRINK ITEMS, FIGURE RESULTS SEPARATELY
EXIT CODE(0)
ROUTINE: +
SET RETNUM=&RETNUM+1
WRITENR &SUBSTR(1:10),&HEAD
SET N=1
DO WHILE &N LE 10
  SET AMT=&N*&SLICE+&COST+(&N*&SLICE*15)/100
  IF (&N*&SLICE*15)//100 >= 50 THEN +
    SET AMT=&AMT+1
  SET AMT=&STR(   &AMT)
  SET AMT1=&SUBSTR(1:&LENGTH(&STR(&AMT))-2,&AMT)
  SET AMT1=&AMT1
  SET AMT2=&SUBSTR(&LENGTH(&STR(&AMT))-1,&AMT)
  IF &SUBSTR(&LENGTH(&STR(&AMT)),&AMT) LT 8 THEN +
    DO
      SET AMT2=&AMT2
      IF &SUBSTR(&LENGTH(&STR(&AMT)),&AMT) GT 2 THEN +
        SET AMT3=5
      ELSE +
        SET AMT3=0
    END
  ELSE +
    DO
      IF &AMT2=9 THEN +
        DO
          SET AMT2=0
          SET AMT1=&AMT1+1
        END
      ELSE +
        SET AMT2=&AMT2+1
      SET AMT3=0
    END
  WRITENR &SUBSTR(&LENGTH(&AMT1)+1:
  &LENGTH(&AMT1)+4,   &AMT1).&AMT2&AMT3
  SET &N=&N+1
END
WRITE
GOTO RETURN
.FI L
.PA
***** COMMAND PROCESSOR INITIALIZATION.
.SP 1
A STANDARD SET OF INITIALIZATION PLI STATEMENTS
HAS BEEN SET UP AND STORED IN SYS2.MACLIB.  TO INCLUDE THESE
STATEMENTS, PLACE THE FOLLOWING STATEMENT AT THE FRONT OF YOUR
PROGRAM:
.SP 1
 % INCLUDE CPINIT;
.SP 1
ONE OF THE STATEMENTS IN CPINIT IS A PROCEDURE OPTIONS(MAIN) STATEMENT.
THE DEFAULT NAME FOR THE PROCEDURE IS "CP".  TO CHANGE THIS TO
"LISTRF" FOR EXAMPLE, REPLACE THE "%INCLUDE CPINIT" STATEMENT AT THE
FRONT OF THE PROGRAM WITH THE FOLLOWING:
.SP 1
.IN 5
.NF
% INCLUDE CPINIT1;
% @CP = 'LISTRF';
% INCLUDE CPINIT2;
.FI L
.IN 0
.PA
***** @CMD - INVOKING OTHER TSO COMMANDS FROM PLI
.SP 1
TO INVOKE OTHER TSO COMMAND PROCESSORS FROM PLI, USE THE @CMD
PREPROCESSOR PROCEDURE.  FOR EXAMPLE, TO ISSUE AN ALLOCATE COMMAND:
.SP 1
 @CMD('ALLOC FI(SYSLIB) DA(''SYS2.MACLIB'') SHR');
.SP 1
ANOTHER EXAMPLE TO ILLUSTRATE HOW @CMD CAN BE USED IN IF-THEN-ELSE
STATEMENTS:
.SP 1
.IN 5
.NF
IF EOJ
 THEN @CMD('FREE FI(SYSLIB)');
 ELSE @CMD('CALL TEST(MYPGM)');
.FI L
.IN 0
.SP 1
YOU CAN GENERATE THE COMMAND TEXT IN AN ACCEPTABLE FORMAT FOR
LATER REFERENCE AS FOLLOWS:
.SP 1
.IN 5
@CMD(FREECMD,'FREE FI(SYSLIB)',MF=L);
.IN 0
.SP 1
FREECMD WILL BE THE NAME TO USE WHEN SUBSEQUENTLY REFERENCING THE
COMMAND TEXT AS FOLLOWS:
.SP 1
.IN 5
@CMD(FREECMD);
.IN 0
.SP 1
A FOURTH FORMAT IS ALSO VALID:
.SP 1
.IN 5
@CMD(NAME,MF=S);
.IN 0
.SP 1
WHERE NAME IS THE NAME OF A CHARACTER STRING CONTAINING A COMMAND
TO BE EXECUTED AS IN THIS EXAMPLE:
.SP 1
.IN 5
.NF
DCL CMD(2) CHAR(80) INIT('L TEST1','D TEST1');
DO I = 1 TO 2;
  @CMD(CMD(I),MF=S);
  END;
.FI L
.IN 0
.SP 1
.PA
***** @READ - READ A LINE FROM THE TERMINAL.
.SP 1
 TO READ A LINE FROM THE TERMINAL USE THE @READ PREPROCESSOR AS
FOLLOWS:
.SP 1
.IN 5
 @READ(LINE);
.IN 0
.SP 1
LINE IS A CHARACTER STRING OF ANY LENGTH (TRUNCATION OR PADDING IS
PERFORMED, AS NECESSARY), AND IT CAN BE EITHER FIXED OR VARYING.  THE
LINE OF TEXT WILL BE TRANSLATED AUTOMATICALLY TO UPPERCASE.  IF YOU
DON'T WANT THIS, ENTER
.SP 1
.IN 5
@READ(LINE,NOCAPS);
.IN 0
.PA
***** @WRITE - WRITE A LINE TO THE TERMINAL.
.SP 1
TO WRITE A LINE TO THE TERMINAL, USE THE @WRITE PREPROCESSOR AS
FOLLOWS:
.SP 1
.IN 5
 @WRITE('HELLO THERE');
.IN 0
.SP 1
YOU CAN GENERATE THE MESSAGE TEXT IN AN ACCEPTABLE FORMAT FOR LATER
REFERENCE AS FOLLOWS:
.SP 1
.IN 5
 @WRITE(GREETING,'HELLO THERE',MF=L);
.IN 0
.SP 1
GREETING WILL BE THE NAME TO USE WHEN SUBSEQUENTLY REFERENCING THE
MESSAGE TEXT:
.SP 1
.IN 5
 @WRITE(GREETING);
.IN 0
.SP 1
THE FOLLOWING FORMAT IS ALSO VALID:
.SP 1
.IN 5
@WRITE(NAME,MF=S);
.IN 0
.SP 1
WHERE NAME IS THE NAME OF ANY CHARACTER STRING TO BE PRINTED AT
THE TERMINAL.  EXAMPLE -
.SP 1
.IN 5
.NF
DCL STR(3) CHAR(5) INIT('DO','ANTS','SLEEP?');
DO I = 1 TO 3;
  @WRITE(STR(I),MF=S);
  END;
.FI L
.SP 1
.IN 0
.PA
***** @PUTGET - PROMPT THE TERMINAL AND GET A LINE.
.SP 1
USE @PUTGET TO FIRST WRITE A PROMPTING MESSAGE AT THE TERMINAL,
AND THEN READ A LINE FROM THE TERMINAL.  THIS IS MORE EFFICIENT THAN
FIRST USING AN @WRITE AND THEN @READ, SINCE IT REQUIRES ONLY ONE
CALL.
.SP 1
.IN 5
 @PUTGET(' PLEASE ENTER SECURITY CODE',CODE);
.IN 0
.SP 1
CODE IS A CHARACTER STRING AS IN @READ.  NOCAPS CAN ALSO BE USED IN
@PUTGET AS IN @READ.  A PREVIOUSLY DEFINED MESSAGE USING @WRITE
WITH THE MF=L OPTION CAN ALSO BE REFERENCED AS IN THE FOLLOWING:
.SP 1
.IN 5
.NF
@WRITE(PROMPT,' PLEASE ENTER CODE',MF=L);
 .
 .
 .
@PUTGET(PROMPT,CODE);
.FI L
.IN 0
NOTE - BECAUSE OF THE WAY THE TSO INTERFACE MACROS WORK, YOU MUST
START YOUR PROMPTING MESSAGE WITH AT LEAST ONE BLANK.
.PA
***** SYMBOLIC REPLACEMENT.
.SP 1
.IN 5
.NF
DCL (DATE,TIME) BUILTIN;
@SETL(&DATE = DATE);
@SETL(&TIME = TIME);
@WRITE('DATE=&DATE, TIME=&TIME');
.FI L
.IN 0
.SP 1
THE ABOVE SEQUENCE OF PLI STATEMENTS WOULD RESULT IN A MESSAGE
CONTAINING THE CURRENT DATE AND TIME OF DAY APPEARING AT THE TSO
TERMINAL.  THIS ILLUSTRATES A FACILITY WHEREBY VARIABLE SYMBOLS,
IDENTIFIED BY AN AMPERSAND IN POSITION 1, CAN BE INSERTED INTO THE
TEXT IN AN @WRITE, @PUTGET, OR @CMD STATEMENT, TO BE REPLACED AT
EXECUTION TIME BY A VALUE ASSIGNED IN AN @SET STATEMENT.
.SP 1
VARIABLE SYMBOLS MUST BEGIN WITH AN AMPERSAND.  THE REMAINING 1 TO
7 CHARACTERS MUST BE ALPHANUMERIC.  VARIABLE SYMBOLS CAN APPEAR
ANYWHERE IN THE TEXT FOR @WRITE, @PUTGET, AND @CMD STATEMENTS.  THEY
ARE DELIMITED BY THE AMPERSAND IN FRONT AND A NON-ALPHANUMERIC
CHARACTER AT THE END.  IF TRAILING CONCATENATION WITH ALPHANUMERIC
DATA IS DESIRED, A CONNECTING PERIOD MUST BE USED
AS IN THIS EXAMPLE:
.SP 1
.IN 5
.NF
@SETL(&PRE = 'UN');
@WRITE('VARIABLE A IS &PRE.KNOWN);
.FI L
.IN 0
.SP 1
THE MESSAGE RECEIVED AT THE TERMINAL WOULD BE "VARIABLE A IS UNKNOWN."
IF CONCATENATION WITH A TRAILING PERIOD IS DESIRED, TWO PERIODS MUST
BE WRITTEN:
.SP 1
.IN 5
.NF
@SETL(&DSN = 'MY');
@CMD('ALLOC DA(&DSN..DATA)');
.FI L
.IN 0
.SP 1
THE COMMAND AT EXECUTION TIME WOULD BE "ALLOC DA(MY.DATA)."  NOTE
THAT IF AN AMPERSAND IS DESIRED IN THE TEXT, TWO CONTIGUOUS AMPERSANDS
MUST BE WRITTEN;  ONE WILL BE ELIMINATED AT EXECUTION TIME.
.SP 1
THERE ARE THREE KINDS OF VARIABLES;  LOCAL, GLOBAL, AND SYSTEM.
LOCAL VARIABLES ARE KNOWN ONLY TO THE CURRENT COMMAND PROCESSOR, AND
WILL BE ELIMINATED WHEN THE COMMAND PROCESSOR TERMINATES.  GLOBAL
VARIABLES ARE KNOWN TO AN ARBITRARY "INITIAL" COMMAND PROCESSOR, AND TO
ALL SUBSEQUENT COMMAND PROCESSORS INVOKED UNDER THE "INITIAL" COMMAND
PROCESSOR VIA @CMD.  YOU DETERMINE WHETHER A GIVEN COMMAND
PROCESSOR WILL BE THE "INITIAL" ONE BY SETTING THE VALUE OF
PREPROCESSOR SWITCH @INITGSW IN BETWEEN THE INCLUDING OF CPINIT1 AND
CPINIT2.  BY DEFAULT, THE SWITCH IS SET TO INDICATE THAT THIS WILL
BE THE "INITIAL" COMMAND PROCESSOR.  TO INDICATE OTHERWISE, USE
THE FOLLOWING SEQUENCE:
.SP 1
.IN 5
.NF
% INCLUDE CPINIT1;
% @INITGSW = 'N';
% INCLUDE CPINIT2;
.FI L
.IN 0
.SP 1
SYSTEM VARIABLES ARE ONES THAT HAVE AN IMPLIED VALUE, AND DO NOT
NEED TO BE ASSIGNED ONE THROUGH USE OF @SET.  FIVE SYSTEM VARIABLES
HAVE BEEN IMPLEMENTED SO FAR;  &SYSUID, &LASTCC, &SYSDATE,
&SYSTIME, AND &SYSPREF.  REFERENCE TO
&SYSUID WILL RETURN THE CURRENT TSO SYSTEM USER IDENTIFICATION.
REFERENCE TO &SYSPREF WILL RETURN THE CURRENT PREFIX SETTING AS
ESTABLISHED THROUGH THE PROFILE COMMAND.
&LASTCC GIVES THE RETURN CODE OF THE MOST RECENTLY INVOKED COMMAND
PROCESSOR USING @CMD.  NOTE THAT THE VALUE FOR SYSTEM VARIABLES CAN
BE ALTERED EITHER LOCALLY OR GLOBALLY BY USING @SETL AND @SETG.
FOR EXAMPLE, IF THE STATEMENT
.SP 1
 @SETL(&SYSUID = 'ANYBODY');
.SP 1
IS ISSUED, ALL SUBSEQUENT REFERENCES TO &SYSUID IN THE CURRENT
COMMAND PROCESSOR WILL RETURN THE VALUE "ANYBODY".
.SP 1
&SYSACCT GIVES YOU THE FIRST ACCOUNTING FIELD FOR THE JOB.
.SP 1
THE VALUES ASSIGNED TO TEXT VARIABLES CAN BE INTERROGATED DIRECTLY
BY USING THE LCLA, LCLC, GBLA, GBLC, SYMA, AND SYMC SUBROUTINES.
THOSE ENTRY POINTS SUFFIXED WITH THE CHARACTER A WILL RETURN THE VALUE
FOR THE SPECIFIED TEXT VARIABLE AS FIXED BIN(31,0).  THOSE ENTRY
POINTS SUFFIXED WITH CHARACTER C WILL RETURN CHARACTER(100) VARYING.
THOSE ENTRY POINTS PREFIXED WITH LCL WILL SEARCH THE TABLE OF
LOCAL VARIABLES ONLY.  THOSE ENTRY POINTS PREFIXED WITH GBL WILL
SEARCH THE TABLE OF GLOBAL VARIABLES ONLY. THOSE ENTRY POINTS
PREFIXED WITH SYM WILL FIRST SEARCH THE TABLE OF LOCAL VARIABLES, THEN
THE TABLE OF GLOBAL VARIABLES.
.SP 1
EXAMPLE:
.SP 1
.IN 5
.NF
@SETL(&WEEKDAY = 'FRIDAY');
IF SYMC('&WEEKDAY') = 'FRIDAY'
 THEN @WRITE('THANK GOD, IT''S FRIDAY');
.FI L
.IN 0
.PA
***** @REP - SYMBOLIC REPLACEMENT FUNCTION
.SP 1
THIS PROCEDURE CAN BE INVOKED TO PERFORM REPLACEMENT OF TEXT
VARIABLES IN A CHARACTER STRING.  EXAMPLE:
.SP 1
.IN 5
DCL STR CHAR(80) INIT('THE &NAME WILL BE &DISP');
@REP(STR=STR);
.IN 0
.SP 1
&NAME AND &DISP WILL BE REPLACED IN THE CHARACTER STRING WITH THEIR
REPLACEMENT VALUES.
.PA
***** @PROC - OBTAIN COMMAND OPERANDS
.SP 1
USE @PROC TO OBTAIN THE VALUES FOR OPERANDS THE USER SPECIFIED ON THE
COMMAND WHEN HE ENTERED IT.  FOR EXAMPLE -
.SP 1
.IN 5
@PROC(1,NAME,SIZE,DISP(KEEP));
.IN 0
.SP 1
THIS STATEMENT INDICATES THAT THE PROGRAM EXPECTS THE USER TO ENTER
ONE POSITIONAL PARAMETER AND OPTIONALLY TWO KEYWORD PARAMETERS.  IF
HE DOESN'T ENTER A VALUE FOR THE DISP KEYWORD, A DEFAULT OF "KEEP"
WILL BE SET UP.  THE VALUES FOR THESE PARAMETERS AT EXECUTION TIME
ARE ASSIGNED TO TEXT VARIABLES &NAME, &SIZE, AND &DISP.  THE VALUE
FOR KEYWORD PARAMETERS DEPENDS ON THE WAY YOU SPECIFIED YOUR @PROC
STATEMENT:  (1) KEYWORD(VALUE) MEANS THAT THE USER, IF HE SPECIFIES
THIS PARTICULAR KEYWORD, MUST FOLLOW IT WITH A PARENTHESIZED VALUE.
THIS VALUE WILL BE ASSIGNED TO THE MATCHING TEXT VARIABLE.  IF THE
USER DOESN'T SPECIFY THIS KEYWORD, THE SPECIFIED DEFAULT VALUE WILL
BE ASSIGNED TO THE MATCHING TEXT VARIABLE;  (2) KEYWORD() MEANS THE
SAME AS IN CASE 1, EXCEPT IF THE USER DOESN'T SPECIFY THIS KEYWORD,
THE DEFAULT WILL BE A NULL STRING;  (3) KEYWORD MEANS THAT THE USER
MAY SPECIFY THE KEYWORD, BUT HE IS NOT TO SPECIFY A PARENTHESIZED
VALUE.  THE MATCHING TEXT VARIABLE WILL BE SET TO THE KEYWORD NAME
IF THE KEYWORD IS SPECIFIED, AND WILL BE SET TO A NULL STRING
OTHERWISE.
.SP 1
IN ADDITION TO THE STANDARD OPERAND SPECIFICATIONS DESCRIBED ABOVE,
THERE ARE A NUMBER OF SPECIAL FORMATS.  THE FIRST OF THESE IS AS
FOLLOWS:
.SP 1
.IN 5
KEYWD#(KEYWD1,...,KEYWDN)
.IN 0
.SP 1
THIS SPECIFICATION IS USED TO SPECIFY A LIST OF ALTERNATIVE KEYWORD
OPERANDS.  THE ALTERNATIVES ARE SPECIFIED IN A PARENTHESIZED LIST
AS IN THE FOLLOWING EXAMPLE:
.SP 1
.IN 5
@PROC(0,WEEKDAY#(SUN,MON,TUE,WED,THU,FRI,SAT));
.IN 0
.SP 1
BECAUSE OF THIS SPECIFICATION, A FIXED BINARY(15,0) ITEM NAMED WEEKDAY
WILL BE DEFINED IN YOUR PROGRAM.  AT EXECUTION TIME,
IF THE USER SPECIFIED NONE OF THE
ALTERNATIVES, WEEKDAY WILL BE SET TO 0.  OTHERWISE, IT WILL BE SET
TO THE NUMBER CORRESPONDING TO THE POSITION OF THE SPECIFIED ALTERNATIVE
IN THE LIST.  FOR EXAMPLE, IF "TUE" WERE SPECIFIED BY THE USER, WEEKDAY
WOULD BE SET TO 3.  NOTE THAT A MATCHING TEXT VARIABLE, &WEEKDAY, IS
ALSO SET.
.SP 1
.IN 5
MYNAME#(NUMERIC) OR KEYWD(23#(NUMERIC))
.IN 0
.SP 1
THE FIRST FORMAT WOULD BE USED FOR POSITIONAL PARAMETERS, AND THE
SECOND FORMAT FOR KEYWORD PARAMETERS.  IN EITHER CASE THE SPECIFICATION
INDICATES THAT THE USER MAY ENTER ONLY NUMERIC DATA FOR THAT PARAMETER.
FOR POSITIONAL PARAMETERS, TEXT VARIABLE &MYNAME WILL BE SET TO THE
VALUE ENTERED AT THE TERMINAL, AND THE USER WILL BE PROMPTED IF HE
FORGETS TO ENTER SOMETHING.  FOR KEYWORD PARAMETERS, THE 23 SPECIFIED
ABOVE REPRESENTS AN OPTIONAL DEFAULT VALUE, AND TEXT VARIABLE &KEYWD
WILL BE SET TO EITHER THE VALUE ENTERED AT THE TERMINAL, OR THE
SPECIFIED DEFAULT VALUE IN THE @PROC STATEMENT IF THE USER CHOSE
NOT TO ENTER ANYTHING.
.SP 1
.IN 5
MYNAME#(DSNAME,DEFAULT=JCL.CNTL)
.IN 5
OR KEYWD(MYNAM#(DSNAME,DEFAULT=JCL.CNTL)
.IN 5
OR KEYWD(#(DSNAME,DEFAULT=JCL.CNTL))
.SP 1
.IN 0
THE FIRST FORMAT SPECIFICATION IS FOR POSITIONAL PARAMETERS, AND
THE SECOND AND THIRD ARE FOR KEYWORD PARAMETERS. THESE SPECIAL FORMATS
ARE USED TO SPECIFY THAT THE USER MUST ENTER A DSNAME USING STANDARD
TSO NAMING CONVENTIONS.  A TEXT VARIABLE WILL NOT BE SET WITH THE
VALUE ENTERED AT THE TERMINAL.  INSTEAD, A SPECIAL PARSING CONTROL
BLOCK IS FILLED IN.  THE NAME YOU USE TO REFERENCE THIS BLOCK IS
'MYNAME' FOR THE FIRST FORMAT, 'MYNAM' FOR THE SECOND FORMAT, AND
'KEYWDSUB' FOR THE THIRD FORMAT.  FORMAT OF THE CONTROL BLOCK IS
DEFINED IN MEMBER IKJPDEDS OF SYS2.MACLIB.  HERE IS AN EXAMPLE TO
ILLUSTRATE HOW SUCH A SPECIFICATION MIGHT BE USED.  NOTE THAT THE
EXAMPLE INVOLVES USE OF THE @ALLOC FUNCTION.  THIS FUNCTION IS
EXPLAINED IN DETAIL LATER ON.  IN THIS CASE, IT IS BEING USED TO
DYNAMICALLY ALLOCATE THE SPECIFIED DATA SET WITH THE DISPOSITION
SHR.
.SP 1
.IN 5
.NF
@PROC(1,MYDSN#(DSNAME,DEFAULT=JOBCARD));
@SETDSN(MYDSN,'CNTL');
@ALLOC(SHR);
.FI L
.SP 1
.IN 0
IN THE ABOVE EXAMPLE, THE @SETDSN FUNCTION SETS UP THE NECESSARY
CONTROL BLOCKS SO THAT WHEN @ALLOC IS SUBSEQUENTLY ENCOUNTERED, THE
DESIRED DATA SET WILL BE ALLOCATED.  MYDSN MUST BE THE NAME OF AN
OPERAND IN THE @PROC STATEMENT, AND THAT PARTICULAR OPERAND MUST BE
A DSNAME TYPE OPERAND.  THE SECOND PARAMETER TO @SETDSN IS OPTIONAL.
IF SPECIFIED, IT INDICATES THAT IF THE DSNAME WAS NOT ENTERED IN
QUOTES, AND IF THE DSNAME IS NOT QUALIFIED (AT LEAST ONE PERIOD IN
THE DSNAME), THEN THE SPECIFIED CHARACTER STRING IS APPENDED AS THE
LOW-LEVEL QUALIFIER.  IN THIS EXAMPLE, IF THE USER OF THE COMMAND
HAD NOT ENTERED THE MYDSN KEYWORD AT THE TERMINAL, THEN THE
DATA SET ALLOCATED WOULD HAVE BEEN USERID.JOBCARD.CNTL.
.PA
***** @ALLOC - DIRECT INTERFACE TO ALLOCATION.
.SP 1
IF YOU WISH TO ALLOCATE A DATA SET, THE SIMPLEST WAY IS TO USE @CMD
TO INVOKE THE ALLOCATE TSO COMMAND.  IF, FOR EXAMPLE, YOU WISH TO READ
A FILE CALLED USERID.CONTROL.DATA, WHERE USERID IS YOUR TSO USER
IDENTIFICATION, THE FOLLOWING SEQUENCE COULD BE USED:
.SP 1
.IN 5
.NF
@CMD('FREE FI(INFILE)');
@CMD('ALLOC FI(INFILE) DA(CONTROL.DATA) SHR');
READ FILE(INFILE) INTO(RECORD);
.FI L
.IN 0
.SP 1
THIS IS INEFFICIENT FOR A NUMBER OF REASONS.  @CMD ISSUES AN ATTACH
MACRO TO INVOKE ALLOCATE.  THIS INVOLVES ADDITIONAL SYSTEM OVERHEAD.
ALSO, YOU MUST FIRST ISSUE A FREE COMMAND TO ENSURE THAT THE FILE
NAME IS NOT IN USE.  ALSO, IF THE DATA SET IS ALREADY ALLOCATED UNDER
A DIFFERENT FILE NAME,  IT WOULD BE MORE EFFICIENT IF THE DDNAME WERE
RETURNED TO YOU RATHER THAN ALLOCATING THE FILE A SECOND TIME.  THE
FOLLOWING SEQUENCE IS MORE EFFICIENT:
.SP 1
.IN 5
.NF
@ALLOC(DA(CONTROL.DATA),SHR);
OPEN FILE(INFILE) TITLE(DA08DDN);
READ FILE(INFILE) INTO(RECORD);
.FI L
.IN 0
.SP 1
FOLLOWING ARE ALL THE KEYWORD OPTIONS WHICH MAY BE SPECIFIED WITH
THE @ALLOC COMMAND:
.SP 1
.IN 5
.NF
DATASET()
FILE()
UNIT()
VOLUME()
SPACE()
DIR()
SHR/NEW/MOD/OLD/WORK
KEEP/DELETE/CATLG/UNCATLG
BLOCK()/TRKS/CYLS
RLSE
DUMMY
USING
.FI L
.IN 0
.SP 1
MOST OF THE @ALLOC OPERANDS ARE SELF-EXPLANATORY, BUT THE WORK
KEYWORD IS NEW AND HAS SPECIAL SIGNIFICANCE.  IT INDICATES THAT
AN ATTEMPT SHOULD FIRST BE MADE TO ALLOCATE THE SPECIFIED DATA SET
WITH A DISPOSITION OF NEW.  IT THAT FAILS, TRY TO ALLOCATE THE DATA
SET WITH A DISPOSITION OF OLD.
.SP 1
NOTE ALSO THAT IF NONE OF THE OPTIONS KEEP, DELETE, CATLG, OR
UNCATLG ARE SPECIFIED, IS THE DISPOSITION IS NEW, THE DEFAULT WILL
BE CATLG.  OTHERWISE THE DEFAULT IS KEEP.
.SP 1
IF THE RETURN CODE FROM THE ALLOCATE FUNCTION IS NON-ZERO, A CALL IS
MADE TO SUBROUTINE DAIRERR (SEE DOCUMENTATION LATER IN THIS PAPER)
TO PRINT THE APPROPRIATE ERROR EMSSAGE AT THE TERMINAL, AND RAISE THE
ERROR CONDITION.
.PA
***** @FREE - DIRECT INTERFACE TO FREE A DATA SET.
.SP 1
 @FREE(FILE(INFILE));
.SP 1
ALL OF THE POSSIBLE KEYWORDS ARE
.SP 1
.IN 5
.NF
FILE()
DATASET()
SYSOUT()
PERMANENT
KEEP/DELETE/CATLG/UNCATLG
.FI L
.IN 0
.SP 1
PERMANENT SPECIFIES THAT PERMANENTLY ALLOCATED DATA SETS ARE MARKED
"NOT IN USE" BUT ARE NOT UNALLOCATED.  KEEP, DELETE, CATLG, OR UNCATLG
SPECIFY THE DISPOSITION OF THE DATA SET.  KEEP IS THE DEFAULT.
.SP 1
NOTE THAT YOU MUST CHECK THE VALUE OF VARIABLE IKJRET AFTER THE @FREE
HAS BEEN ISSUED TO DETERMINE IF THE OPERATION WAS SUCCESSFUL.  IF
IKJRET IS NON-ZERO, YOU MAY ELECT TO CALL DAIRERR TO PUT OUT THE
APPROPRIATE ERROR MESSAGE AND TO SIGNAL THE ERROR CONDITION.
.SP 1
NOTE:  SPECIFY @FREE(DA) IF YOU HAVE PREINITIALIZED FIELD DA18DDN,
AND SPECIFY @FREE(FI) IF YOU HAVE PREINITIALIZED FIELD DA18PDSN.
.PA
***** ABBREVIATION OF @ALLOC AND @FREE KEYWORDS.
.SP 1
NOTE THAT THE COMMANDS
.SP 1
.IN 5
.NF
@FREE(F(INFILE));
@ALLOC(DA('SYS1.PROCLIB'));
.FI L
.IN 0
.SP 1
MEAN THE SAME AS
.SP 1
.IN 5
.NF
@FREE(FILE(INFILE));
@ALLOC(DATASET('SYS1.PROCLIB'));
.FI L
.IN 0
.SP 1
ANY KEYWORD OF THE @FREE AND @ALLOC COMMANDS CAN BE ABBREVIATED DOWN
TO THE POINT OF UNIQUENESS, OR ANYWHERE IN BETWEEN, UP TO THE FULL
SPELLING.
.PA
***** HOW TO COMPILE AND EXECUTE A PLI/TSO COMMAND
.SP 1
IN ORDER TO CREATE AN EXECUTABLE TSO COMMAND PROCESSOR, YOU MUST FIRST
COMPILE YOUR PL/I SOURCE PROGRAM UNDER EITHER THE PLI CHECKOUT OR
OPTIMIZING COMPILER.  COMMAND FORMATS ARE AS FOLLOWS:
.SP 1
.IN 5
OPTIMIZER
.IN 10
PLI SORC M LIB('SYS2.MACLIB') OBJ(SORC)
.IN 5
CHECKER
.IN 10
PLIC SORC M LIB('SYS2.MACLIB') OBJ(SORC SORC)
.IN 0
.SP 1
REPLACE 'SORC' WITH THE NAME OF YOUR PL/I SOURCE PROGRAM.
.SP 1
IF YOU COMPILE WITH THE CHECKER, REPLACE THE % INCLUDE CPINIT AT THE
FRONT OF THE SOURCE PROGRAM WITH THE FOLLOWING SEQUENCE:
.SP 1
.IN 5
.NF
% INCLUDE CPINIT1;
% @CMP='C';
% INCLUDE CPINIT2;
.FI L
.IN 0
.SP 1
ONCE YOU HAVE SUCCESSFULLY COMPILED, YOU MUST LINKEDIT A LOAD MODULE.
NOTE THAT THE LINK COMMAND IS ENTERED THE SAME WHETHER YOU HAVE USED
THE CHECKER OR THE OPTIMIZER, BUT A DIFFERENT LINKAGE EDITOR ENTRY
CONTROL STATEMENT MUST BE USED IN EACH CASE.
.SP 1
.IN 5
LINK (SORC *) LOAD(TEST(SORC)) LIB('SYS2.PLIBASE') PLIBASE PRINT(*)
.IN 0
.SP 1
WHEN THE LINK COMMAND PROMPTS YOU FOR CONTROL STATEMENTS, ENTER AS
FOLLOWS:
.SP 1
.IN 5
OPTIMIZER
.IN 10
 ENTRY PLICALLA
.IN 5
CHECKER
.IN 10
 ENTRY TESTCPE
.IN 0
.SP 1
DON'T FORGET THAT LINKAGE EDITOR REQUIRES THAT CONTROL STATEMENTS
START WITH AT LEAST ONE BLANK.
.SP 1
DURING TESTING, YOU USE THE TEST COMMAND TO EXECUTE YOUR COMMAND
PROCESSOR.  NOTE HOWEVER, THAT IF YOU COMPILED USING THE CHECKER,
YOU MUST FIRST ALLOCATE THE SYSITEXT FILE AS FOLLOWS:
.SP 1
.IN 5
ALLOC FI(SYSITEXT) DA(SORC.ITEXT)
.IN 0
.SP 1
YOU THEN ISSUE THE TEST COMMAND AS FOLLOWS:
.SP 1
.IN 5
TEST TEST(SORC) CP
.IN 0
.SP 1
TEST WILL PROMPT YOU TO ENTER THE COMMAND LINE.  ONCE YOU HAVE DONE
SO AND HAVE RECEIVED THE 'TEST' MESSAGE, ENTER "GO".  IF YOU ARE
USING THE CHECKER, YOU WILL THEN BE PROMPTED FOR CHECKER PARAMETERS
SUCH AS HALT, SIZE, ETC.  IF YOU HAVE NO CHECKER PARAMETERS TO ENTER,
JUST ENTER A NULL LINE.
.PA
***** DAIRERR - SUBROUTINE TO HANDLE DAIR ERRORS.
.SP 1
WHEN THE @FREE AND @ALLOC COMMANDS ARE ISSUED, A CALL TO DAIR
(DYNAMIC ALLOCATION INTERFACE ROUTINE) IS GENERATED.  A VARIABLE
NAMED IKJRET (FIXED BINARY(31,0)) IS SET TO ZERO IF THE ALLOCATE OR
FREE WAS SUCCESSFUL.  IF THE RETURN CODE IS NON-ZERO, A CALL TO
DAIRERR IS GENERATED TO PUT THE APPROPRIATE ERROR MESSAGE AT THE
TERMINAL, AND TO SIGNAL THE ERROR CONDITION.  CALL FORMAT IS
AS FOLLOWS:
.SP 1
 CALL DAIRERR(BLKPTR);
.SP 1
WHERE BLKPTR IS A POINTER VARIABLE SET TO THE ADDRESS OF THE
ALLOCATION CONTROL BLOCK PASSED TO DAIR (DAIR08 FOR ALLOCATE, AND
DAIR18 FOR FOR FREE).  THESE CONTROL BLOCKS ARE SET UP AUTOMATICALLY
BY THE PREPROCESSOR CODE.
.PA
***** ACCESSING THE COMMAND BUFFER.
.SP 1
SUPPOSE YOU MAKE THE FOLLOWING DECLARATION IN YOUR PLI PROGRAM:
.SP 1
.IN 5
.NF
DCL 1 CBUF BASED(CPPLCBUF),
     2 BUFLEN FIXED BIN(15,0),
     2 OFFSET FIXED BIN(15,0),
     2 BUFFER CHAR(100);
.FI L
.IN 0
.SP 1
THE POINTER CPPLCBUF WILL BE SET FOR YOU IN THE INITIALIZATION CODE
INCLUDED IN THE FRONT OF YOUR PROGRAM.
BUFFER WILL CONTAIN THE COMMAND EXACTLY AS IT
WAS ENTERED BY THE USER AT THE TERMINAL.  BUFLEN WILL CONTAIN THE
LENGTH OF THE TEXT IN BUFFER PLUS 4 FOR THE LENGTH OF FIELDS BUFLEN
AND OFFSET.  OFFSET WILL CONTAIN THE OFFSET IN BUFFER, RELATIVE 0,
TO THE FIRST BYTE OF THE FIRST PARAMETER BEYOND THE COMMAND NAME.
.PA
***** USING THE IBM SUPPLIED PARSE ROUTINE.
.SP 1
YOU MAY CHOOSE TO ACCESS THE COMMAND BUFFER DIRECTLY AS DESCRIBED
ABOVE AND PARSE THE OPERANDS OF THE COMMAND IN YOUR OWN FASHION.
OR, YOU CAN USE A PARSING ROUTINE SUPPLIED BY IBM.  THERE ARE A
NUMBER OF ADVANTAGES TO USING THIS ROUTINE.  FOR EXAMPLE, YOU CAN
EASILY SET DEFAULTS FOR SOME PARAMETERS, AND INDICATE FOR OTHERS
THAT THEY ARE REQUIRED, IN WHICH CASE, THE IBM ROUTINE WILL PROMPT THE
USER AT THE TERMINAL FOR YOU.
.SP 1
TO USE THE IBM PARSE ROUTINE YOU MUST DEFINE THE FORMAT OF THE
OPERANDS EXPECTED USING ASSEMBLER LANGUAGE MACROS.  ONLY A SUBSET
WILL BE DESCRIBED HERE;  ENOUGH TO PARSE SIMPLE KEYWORD AND
POSITIONAL PARAMETERS.  SEE SRL GC28-6764, "GUIDE TO WRITING A
TERMINAL MONITOR PROGRAM OR A COMMAND PROCESSOR" FOR INFORMATION ON
HOW TO DEFINE MORE COMPLICATED LISTS OF PARAMETERS.
 FOLLOWING IS A SAMPLE ASSEMBLER SOURCE DECK TO DEFINE ONE POSITIONAL
AND TWO KEYWORD PARAMETERS, ONE HAVING A SUBFIELD:
.SP 1
.IN 5
.NF
PCL    IKJPARM
DSN    IKJPOSIT DSNAME,PROMPT=' DSNAME'
DISP   IKJKEYWD DEFAULT='KEEP'
       IKJNAME 'KEEP'
       IKJNAME 'DELETE'
SPACE  IKJKEYWD
       IKJNAME 'CYL',SUBFLD=SPSUB
       IKJNAME 'TRK',SUBFLD=SPSUB
SPSUB  IKJSUBF
SPSUBI IKJIDENT 'SPACE',MAXLNTH=5,FIRST=NUMERIC,
                OTHER=NUMERIC,DEFAULT='1'
       IKJENDP
       END
.FI L
.IN 0
.SP 1
.SP 1
THE FIRST STATEMENT AND THE LAST TWO ARE FIXED IN FORMAT.  THE REST
MAY VARY.  POSITIONAL PARAMETERS MUST BE DEFINED FIRST, FOLLOWED BY ALL
KEYWORD PARAMETERS, FOLLOWED BY ALL SUBFIELD DEFINITIONS.
.SP 1
THE IKJPOSIT MACRO LABELLED DSN INDICATES THAT THE FIRST POSITIONAL
PARAMETER (IN THIS CASE THE ONLY POSITIONAL) WILL BE A DSNAME.  IF
THE USER DOESN'T ENTER A POSITIONAL PARAMETER, HE WILL BE PROMPTED
WITH THE MESSAGE "ENTER DSNAME."  TO ACCESS THE PARAMETER IN THE PLI
SOURCE, USE THE STATEMENT "PDEPTR=ADDR(DSN);".  THIS ADDRESSES A
CONTROL BLOCK DEFINED IN MEMBER IKJPDEDS OF SYS2.MACLIB.  THIS MEMBER
IS INCLUDED FOR YOU BY CPINIT (SEE DOCUMENTATION LATER IN THIS PAPER).
.SP 1
NOTE THAT FOLLOWING THE IKJPOSIT MACRO, OTHER IKJPOSIT AND IKJIDENT
MACROS COULD BE SPECIFIED TO DEFINE ADDITIONAL POSITIONAL PARAMETERS.
IN THIS CASE, HOWEVER, THE NEXT MACRO DEFINES A KEYWORD PARAMETER
CALLED DISP.  DISP IS THE NAME YOU WILL USE IN THE PLI SOURCE TO
REFERENCE THIS KEYWORD PARAMETER.  IT IS DEFINED AS FIXED BINARY(15,0),
AND IS SET TO A NUMBER EQUALING THE POSITION OF THE SPECIFIED KEYWORD
IN THE LIST OF IKJNAME MACROS IMMEDIATELY FOLLOWING THE IKJKEYWD MACRO.
THE IKJNAME MACROS DEFINE THE POSSIBLE KEYWORDS.  NOTE THAT IN THE
CASE OF THE DISP KEYWORD PARAMETER, IF THE USER ENTERING THE COMMAND
AT THE TERMINAL DOESN'T SPECIFY ONE OF THE POSSIBLE KEYWORDS, A DEFAULT
OF KEEP WILL BE SET UP BY THE PARSING ROUTINE.
.SP 1
THE IKJKEYWD MACRO LABELLED SPACE AND ASSOCIATED IKJNAME MACROS
ILLUSTRATE THE SITUATION WHERE DATA IS TO BE EXPECTED IN PARENTHESES
FOLLOWING THE KEYWORD.  THE IKJIDENT MACRO LABELLED SPSUBI DESCRIBES
THE EXPECTED FORMAT OF THE DATA.
.PA
***** HOW TO COMPILE AND EXECUTE A TSO COMMAND PROCESSOR
      WHEN USING THE ASSEMBLER PARSING MACROS
.SP 1
FOUR CLIST COMMANDS ARE CURRENTLY AVAILABLE:  CPPLI, CPPLIA,
CPPLIB, AND CPPLICB.  FORMATS FOR THESE FOUR COMMANDS ARE AS
FOLLOWS:
.SP 1
.IN 5
CPPLI 'SORC' 'PCL' LOAD(TEST) NAME(TEMPNAME) USERID() AT(LOCAL)
.SP 1
CPPLIA 'PCL' NAME(TEMPNAME) USERID() AT(LOCAL)
.SP 1
CPPLIB 'SORC' LOAD(TEST) NAME(TEMPNAME) USERID() AT(LOCAL)
.SP 1
CPPLICB 'SORC' LOAD(TEST) NAME(TEMPNAME) USERID() AT(LOCAL)
.SP 1
.IN 0
WHERE
.SP 1
'SORC'
.IN 5
IS THE NAME OF THE PLI SOURCE DECK FOR THE TSO COMMAND PROCESSOR.
IF THE DESCRIPTIVE QUALIFIER IS NOT PLI, THE NAME MUST BE SPECIFIED
FULLY QUALIFIED IN QUOTES.
.IN 0
'PCL'
.IN 5
IS THE NAME OF THE ASSEMBLER SOURCE DECK CONTAINING THE PARSING MACROS
(IKJPOSIT, IKJKEYWD, ETC.).
.IN 0
LOAD(TEST)
.IN 5
IS THE NAME OF THE LOAD LIBRARY INTO WHICH THE LINKEDITED COMMAND
PROCESSOR IS TO BE PLACED.  THE DEFAULT IS TEST.LOAD (THE DESCRIPTIVE
QUALIFIER LOAD SHOULD NOT BE SPECIFIED; IT IS THE DEFAULT).
.IN 0
NAME(TEMPNAME)
.IN 5
SPECIFIES THE LOAD MODULE NAME, AND ALSO SPECIFIES THE NAME TO USE WHEN
CREATING A DATA SET WITH NAME OF THE FORM &NAME..OBJ.  THE DEFAULT IS
TEMPNAME.
.IN 0
USERID()
.IN 5
SPECIFIES YOUR TSO USER IDENTIFICATION.
.IN 0
AT(LOCAL)
.IN 5
SPECIFIES THE LOCATION AT WHICH ANY GENERATED LISTINGS ARE TO BE
PRINTED.
.IN 0
.SP 1
CPPLI WILL ASSEMBLE THE PARSING MACROS, COMPILE THE PLI SOURCE AND
LINKEDIT THE OBJECT TEXT.
.SP 1
CPPLIA WILL ONLY ASSEMBLE THE PARSING MACROS, PLACING THE OUTPUT,
(PLI DECLARE STATEMENTS FOR PARAMETER DESCRIPTOR LIST (PDL) AND
OBJECT TEXT FOR THE PARSING CONTROL LIST (PCL)) INTO A NEWLY CREATED
PARTITIONED DATA SET WITH A NAME OF THE FORM &NAME..OBJ.
.SP 1
CPPLIB WILL COMPILE THE PLI SOURCE PROGRAM, LINKEDIT THE COMMAND
PROCESSOR. CPPLIB EXPECTS THAT CPPLIA HAS BEEN RUN, CREATING DATA SET
&NAME..OBJ.
.SP 1
CPPLICB WILL COMPILE THE PLI SOURCE PROGRAM USING THE CHECKOUT
COMPILER INSTEAD OF THE OPTIMIZER, LINKEDIT THE OBJECT TEXT.
CPPLIA MUST HAVE BEEN EXECUTED BEFOREHAND.  IN
ORDER TO USE THIS OPTION, YOU MUST HAVE USED THE FOLLOWING SEQUENCE IN
YOUR PLI SOURCE:
.SP 1
.IN 5
.NF
% INCLUDE CPINIT1;
% @CMP = 'C';
% INCLUDE CPINIT2;
