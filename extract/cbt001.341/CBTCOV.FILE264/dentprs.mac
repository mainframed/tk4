 /* COPYRIGHT 1983 BY THOMAS GLEN SMITH */
 /* DENTPRS */
 /*
0*$.HE GENERALIZED SUBROUTINES - DENTPRS
0*$.HE SIMPLIFIED PARSING ROUTINE
0*$.PL 55
0*$.PN 0
0*$.PA
0*$.SS
0*$.NF
0*$03/10/78
0*$AUTHOR:  T. SMITH
0*$SOURCE MODULE NAME:  DENTPRS
0*$DOCUMENTATION ID:  0*$
0*$.FI L
0*$.SP 5
0*$THIS PL/I SUBROUTINE PROVIDES A SIMPLIFIED METHOD OF PARSING
0*$A COMMAND BUFFER.  SEE ALSO DOCUMENTATION ON THE PARS SUBROUTINE.
0*$PARS EXPECTS TO RECEIVE TWO PARAMETERS,
0*$THE FIRST BEING THE COMMAND BUFFER ITSELF.  IT MUST BE A VARYING
0*$CHARACTER STRING, AND CAN BE ANY LENGTH.  THE SECOND PARAMETER IS
0*$A STRUCTURE OF THE FORMAT DESCRIBED BELOW:
0*$.SP 1
0*$.IN 5
0*$.NF
0*$DCL 1 PARSTR UNALIGNED,
0*$2 CMDINDX FIXED BIN(15,0),
0*$ ** WILL BE ST BY DENTPRS TO THE INDEX VALUE
0*$    CORRESPONDING TO THE COMMAND NAME IN THE
0*$    BUFFER.  WILL BE SET TO 0 IF THE COMMAND
0*$    NAME DOESN'T MATCH AN ENTRY IN CMDTAB. **
0*$2 OPERCK BIT(16),
0*$ ** EACH BIT WILL BE SET TO '0'B BY DENTPRS IF
0*$    THE CORRESPONDING OPERAND IF VALID.  NOTE
0*$    THAT SUBSTR(OPERCK,1,1) CORRESPONDS
0*$    TO THE COMMAND NAME ITSELF. **
0*$2 QUOTCK BIT(16),
0*$ ** EACH BIT WILL BE SET TO '1'B BY DENTPRS IF
0*$    THE CORRESPONDING OPERAND WAS A QUOTED STRING.
0*$2 PARY(16) CHAR(256) VAR,
0*$ ** PARY(1) IS SET BY DENTPRS TO THE COMMAND NAME
0*$    ITSELF, AND WILL BE TRANSLATED TO CAPITAL
0*$    LETTERS,  PARY(2) IS SET TO THE FIRST OPERAND,
0*$    PARY(3) TO THE SECOND, ETC.  EITHER A BLANK
0*$    OR A COMMA IS CONSIDERED TO BE A DELIMITER,
0*$    EXCEPT QUOTED STRINGS ARE CONSIDERED TO BE
0*$    AN ITEM REGARDLESS OF WHETHER THEY CONTAIN
0*$    BLANKS OR NOT.  ALL DELIMITERS ARE ALSO
0*$    IGNORED INSIDE PARENTHESIZED STRINGS THAT
0*$    DO NOT OCCUR INSIDE QUOTED STRINGS.  IF THE
0*$    RIGHT PARENTHESIS IS NOT FOLLOWED BY A BLANK
0*$    OR COMMA, THEN THE RIGHT PARENTHESIS IS
0*$    CONSIDERED AS THE DELIMITER FOR THE
0*$    OPERAND.  OTHERWISE, THE COMMA OR PARENTHESIS
0*$    IS CONSIDERED THE DELIMITER FOR THE OPERAND.
0*$    IN EITHER CASE, THE RIGHT PARENTHESIS WILL BE
0*$    THE LAST CHARACTER OF THE OPERAND.
0*$    NOTE THAT ANY OPERANDS BEYOND THE FIFTEENTH
0*$    IN THE COMMAND BUFFER WILL BE IGNORED. **
0*$2 NUMCKA(*) BIT(16),
0*$ ** EACH SUB-ARRAY OF 16 BITS CORRESPONDS TO
0*$    THE MATCHING COMMAND NAME IN CMDTAB.  THE
0*$    USER SHOULD SET EACH BIT TO '1'B IF THAT
0*$    PARTICULAR OPERAND SHOULD BE NUMERICS ONLY.
0*$    NOTE THAT THE FIRST BIT CORRESPONDS TO THE
0*$    COMMAND NAME ITSELF.  IN OTHER WORDS,
0*$    SUBSTR(NUMCKA(X),2,1) REFERS TO THE BIT
0*$    CORRESPONDING TO THE FIRST OPERAND. **
0*$2 CMDTAB(*) CHAR(8) VARYING;
0*$ ** LIST OF VALID COMMAND NAMES, FILLED IN
0*$    BY THE CALLER OF DENTPRS. **
0*$.FI L
0*$.IN 0
0*$.SP 1
0*$A SAMPLE DECLARATION AND INVOCATION OF DENTPRS FOLLOWS:
0*$.SP 1
0*$.IN 5
0*$.NF
0*$DCL 1 PARSTR UNALIGNED STATIC,
0*$2 CMDINDX FIXED BIN(15,0),
0*$2 OPERCK BIT(16),
0*$2 QUOTCK BIT(16),
0*$2 PARY(16) CHAR(256) VAR,
0*$2 NUMCKA(5) BIT(16) INIT(
0*$'0'B,    ** GO **
0*$'0'B,    ** PUTCMD **
0*$'011'B,  ** END **
0*$'0'B,    ** LIST **
0*$'0'B),   ** BREAK **
0*$2 CMDTAB(5) CHAR(8) VAR INIT(
0*$'GO',
0*$'PUTCMD',
0*$'END',
0*$'LIST',
0*$'BREAK');
0*$DCL DENTPRS ENTRY(CHAR(*) VAR,);
0*$CALL DENTPRS('PUTCMD OPERA OPERB',PARSTR);
0*$ **CMDINDX WILL BE 2,
0*$   OPERCK WILL BE '0'B,
0*$   PARY(1) WILL BE 'PUTCMD',
0*$   PARY(2) WILL BE 'OPERA',
0*$   PARY(3) WILL BE 'OPERB'**
 */
 DENTPRS:  PROC(CMDDATA,PARSTR) OPTIONS(REENTRANT);
         DCL CMDDATA CHAR(*) VAR;
         DCL 1 PARSTR UNALIGNED,
              2 CMDINDX FIXED BIN(15,0),
                   /* WILL BE ST BY DENTPRS TO THE INDEX VALUE
                      CORRESPONDING TO THE COMMAND NAME IN THE
                      BUFFER.  WILL BE SET TO 0 IF THE COMMAND
                      NAME DOESN'T MATCH AN ENTRY IN CMDTAB. */
              2 OPERCK BIT(16),
                   /* EACH BIT WILL BE SET TO '1'B BY DENTPRS IF
                      THE CORRESPONDING OPERAND IF VALID.  NOTE
                      THAT SUBSTR(OPERCK,1,1) CORRESPONDS
                      TO THE COMMAND NAME ITSELF. */
              2 QUOTCK BIT(16),
                   /* EACH BIT WILL BE SET TO '1'B BY DENTPRS IF
                      THE CORRESPONDING OPERAND IS A QUOTED STRING. */
              2 PARY(16) CHAR(256) VAR,
                   /* PARY(1) IS SET BY DENTPRS TO THE COMMAND NAME
                      ITSELF, PARY(2) IS SET TO THE FIRST OPERAND,
                      PARY(3) TO THE SECOND, ETC.  EITHER A BLANK
                      OR A COMMA IS CONSIDERED TO BE A DELIMITER,
                      EXCEPT QUOTED STRINGS ARE CONSIDERED TO BE
                      AN ITEM REGARDLESS OF WHETHER THEY CONTAIN
                      BLANKS OR NOT. */
              2 NUMCKA(*) BIT(16),
                   /* EACH SUB-ARRAY OF 16 BITS CORRESPONDS TO
                      THE MATCHING COMMAND NAME IN CMDTAB.  THE
                      USER SHOULD SET EACH BIT TO '1'B IF THAT
                      PARTICULAR OPERAND SHOULD BE NUMERICS ONLY.
                      NOTE THAT THE FIRST BIT CORRESPONDS TO THE
                      COMMAND NAME ITSELF.  IN OTHER WORDS,
                      NUMCKA(X,2) REFERS TO THE BIT CORRESPONDING
                      TO THE FIRST OPERAND. */
              2 CMDTAB(*) CHAR(8) VARYING;
                   /* LIST OF VALID COMMAND NAMES, FILLED IN
                      BY THE CALLER OF DENTPRS. */
 /* DENTPRS - ATOMIZES THE COMMAND.  PARY(1) IS SET TO THE COMMAND
 NAME ITSELF, PARY(2) IS SET TO THE FIRST OPERAND, PARY(3) TO
 THE SECOND, ETC.  EITHER A BLANK OR A COMMA IS CONSIDERED TO
 BE A DELIMITER, EXCEPT QUOTED STRINGS ARE CONSIDERED TO BE AN ITEM
 REGARDLESS OF WHETHER THEY CONTAIN BLANKS OR NOT.  ALL DELIMITERS
 ARE ALSO IGNORED INSIDE PARENTHESIZED STRINGS THAT DO NOT OCCUR
 INSIDE QUOTED STRINGS.  THE RIGHT PARENTHESIS IN THIS CASE IS
 CONSIDERED AS THE DELIMITER FOR THE OPERAND. */
         DCL PREFIX ENTRY RETURNS(FIXED BIN(15,0));
         DCL PSTR ENTRY(CHAR(*) VAR, FIXED BIN(15,0))
           RETURNS(FIXED BIN(15,0));
         PARY(*) = '';
         QUOTCK = '0'B;
         L = LENGTH(CMDDATA);
         I,J,K = 0;
         PLUP:  DO K = 0 TO 15 WHILE(J < L);
           I = PREFIX(SUBSTR(CMDDATA,J+1),' ')+J;/*GET NXT NONBLNK*/
           IF I = J
             THEN LEAVE PLUP; /* NO MORE PARMS */
           IF SUBSTR(CMDDATA,I,1)=''''
             THEN DO; /* OPERAND IS QUOTED STRING */
               J = I;
               FPOST:  DO UNTIL(J > L);
                 M=INDEX(SUBSTR(CMDDATA,J+1),'''')+J;
                 IF M = J
                   THEN J = L+1;
                   ELSE DO;
                     J = M;
                     IF J = L
                       THEN LEAVE FPOST;
                       ELSE IF SUBSTR(CMDDATA,J+1,1)=''''
                         THEN DO;
                           SUBSTR(CMDDATA,J)=SUBSTR(CMDDATA,J+1);
                           L = L-1;
                           IF J = L
                             THEN J=L+1;
                           END;
                         ELSE LEAVE FPOST;
                     END;
                 END FPOST;
               PARY(K+1)=SUBSTR(CMDDATA,I+1,J-I-1);
               SUBSTR(QUOTCK,K+1,1)='1'B;
               J = J + 1;
               END;
             ELSE DO; /* OPERAND IS NOT QUOTED STRING */
               IF SUBSTR(CMDDATA,I,1)='('
                 THEN J = PSTR(CMDDATA,I)+1;
                 ELSE DO;
                   J = INDEX(SUBSTR(CMDDATA,I+1),' ')+I;
                     /*GET NXT DELIMITER*/
                   M = INDEX(SUBSTR(CMDDATA,I+1),',')+I;
                     /*GET NXT DELIMITER*/
                   IF J = M
                     THEN J = L+1; /* NO MORE DELIMITERS */
                     ELSE IF J = I
                       THEN J = M; /* J = INDEX TO COMMA */
                       ELSE IF M > I
                         THEN IF M < J
                           THEN J = M; /* J = INDEX TO COMMA */
                   /* AT THIS POINT, J = INDEX TO NEXT COMMA OR BLANK,
                      WHICHEVER IS NEXT */
                   P=INDEX(SUBSTR(CMDDATA,I+1),'(')+I;
                   IF P^=I
                     THEN IF P<J
                       THEN J=MAX(J,PSTR(CMDDATA,P)+1);
                   END;
               PARY(K+1)=SUBSTR(CMDDATA,I,J-I);
               IF J<=L
                 THEN IF SUBSTR(CMDDATA,J-1,1)=')'
                   & SUBSTR(CMDDATA,J,1)^=' '
                   & SUBSTR(CMDDATA,J,1)^=','
                   THEN J=J-1;
               END;
           END PLUP;
         CALL SETCAPS(PARY(1));
         DO CMDINDX = DIM(CMDTAB,1) TO 1 BY -1
           WHILE(PARY(1) ^= CMDTAB(CMDINDX));
           END;
         IF ^SUBSTR(QUOTCK,2,1)
           THEN IF PARY(2)='all' × PARY(2)='ALL'
             THEN DO;
               DO I = 16 TO 3 BY -1;
                 PARY(I)=PARY(I-1);
                 END;
               PARY(2)='0';
               PARY(3)='99999999';
               QUOTCK='000'B××SUBSTR(QUOTCK,3);
               END;
         OPERCK = '0'B;
         IF CMDINDX ^= 0
           THEN DO I = 1 TO 16;
             IF SUBSTR(NUMCKA(CMDINDX),I,1)
               THEN IF PARY(I)^='*'
                 THEN IF VERIFY(PARY(I),'0123456789')^=0
                   THEN IF SUBSTR(PARY(I),1,1)='+' ×
                     SUBSTR(PARY(I),1,1)='-' & LENGTH(PARY(I))>1
                     THEN IF VERIFY(SUBSTR(PARY(I),2),'0123456789')^=0
                       THEN SUBSTR(OPERCK,I,1)='1'B;
                       ELSE;
                     ELSE SUBSTR(OPERCK,I,1) = '1'B;
             END;
         END DENTPRS;
