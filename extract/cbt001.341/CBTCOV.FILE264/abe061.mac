 /* COPYRIGHT 1983 BY THOMAS GLEN SMITH */
 /* ABE061 - APL,API */
   %INCLUDE ABESUB;
 ABESUB(ABE061) CHECK(YES) RECURS(YES) APL(YES);
   %INCLUDE ABESUBA;

   DCL TROUT ENTRY(CHAR(4)) RETURNS(CHAR(8)); /*TESTING*/
   DCL TROUTSTR CHAR(4) BASED(TROUTPTR); /*TESTING*/

   DCL 1 SYMBOLS(73) CHAR(3) STATIC INIT(
     'Ö  ',  /*CIRCLE STILE  */
     '.  ',  /*DOT           */
     '<  ',  /*LESS          */
     '(  ',  /*LEFT PAREN    */
     '+  ',  /*PLUS          */
     '×  ',  /*STILE         */
     '&  ',  /*AND           */
     '!  ',  /*QUOTE DOT     */
     '$  ',  /*RIGHT ARROW   */
     '*  ',  /*STAR          */
     ')  ',  /*RIGHT PAREN   */
     ';  ',  /*SEMICOLON     */
     '^  ',  /*NOT EQUAL     */
     '-  ',  /*BAR           */
     '/  ',  /*SLASH         */
     '|  ',  /*NOR           */
     ',  ',  /*COMMA         */
     '%  ',  /*DIVIDE        */
     '>  ',  /*GREATER       */
     '?  ',  /*QUERY         */
     '`Ö ',  /*CIRCLE BAR    */
     '`/ ',  /*SLASH BAR     */
     '_  ',  /*OVERBAR       */
     '`_ ',  /*UNDERBAR      */
     '`A ',  /*ALPHA         */
     '`B ',  /*ACCENT BASE   */
     '`C ',  /*CAP           */
     '`G ',  /*DEL TILDE     */
     '`H ',  /*DELTA UNDERBAR*/
     '`I ',  /*I-BEAM        */
     '`R ',  /*ACCENT RHO    */
     '`\ ',  /*SLOPE BAR     */
     '`V ',  /*CUP           */
     '`W ',  /*OMEGA         */
     '`X ',  /*RIGHT SHOE    */
     '`Z ',  /*LEFT SHOE     */
     '`1 ',  /*DIERESIS      */
     ':  ',  /*COLON         */
     '#  ',  /*LEFT ARROW    */
     '@  ',  /*LOG           */
     ''' ',  /*QUOTE         */
     '=  ',  /*EQUAL         */
     '"  ',  /*CAP NULL      */
     '~  ',  /*TILDE         */
     '{  ',  /*LEFT BRACKET  */
     'A  ',  /*DELTA STILE   */
     'B  ',  /*BASE          */
     'C  ',  /*BASE NULL     */
     'D  ',  /*DOWNSTILE     */
     'E  ',  /*EPSILON       */
     'F  ',  /*TOP NULL      */
     'G  ',  /*DEL           */
     'H  ',  /*DELTA         */
     'I  ',  /*IOTA          */
     '}  ',  /*RIGHT BRACKET */
     'J  ',  /*NULL          */
     'K  ',  /*NOT GREATER   */
     'L  ',  /*QUAD          */
     'M  ',  /*DOMINO        */
     'N  ',  /*TOP           */
     'O  ',  /*CIRCLE        */
     'P  ',  /*NAND          */
     'Q  ',  /*QUOTE-QUAD    */
     'R  ',  /*RHO           */
     '\  ',  /*SLOPE         */
     'S  ',  /*UPSTILE       */
     'T  ',  /*CIRCLE SLOPE  */
     'U  ',  /*DOWN ARROW    */
     'V  ',  /*OR            */
     'W  ',  /*DEL STILE     */
     'X  ',  /*TIMES         */
     'Y  ',  /*UP ARROW      */
     'Z  '); /*NOT LESS      */

   DCL 1 SYMBOL_NAMES(73) CHAR(14) STATIC INIT(
     'CIRCLE STILE  ',  /*Ö  */
     'DOT           ',  /*.  */
     'LESS          ',  /*<  */
     'LEFT PAREN    ',  /*(  */
     'PLUS          ',  /*+  */
     'STILE         ',  /*×  */
     'AND           ',  /*&  */
     'QUOTE DOT     ',  /*!  */
     'RIGHT ARROW   ',  /*$  */
     'STAR          ',  /**  */
     'RIGHT PAREN   ',  /*)  */
     'SEMICOLON     ',  /*;  */
     'NOT EQUAL     ',  /*^  */
     'BAR           ',  /*-  */
     'SLASH         ',  /*/  */
     'NOR           ',  /*|  */
     'COMMA         ',  /*,  */
     'DIVIDE        ',  /*%  */
     'GREATER       ',  /*>  */
     'QUERY         ',  /*?  */
     'CIRCLE BAR    ',  /*`Ö */
     'SLASH BAR     ',  /*`/ */
     'OVERBAR       ',  /*`_ */
     'UNDERBAR      ',  /*``_*/
     'ALPHA         ',  /*`A */
     'ACCENT BASE   ',  /*`B */
     'CAP           ',  /*`C */
     'DEL TILDE     ',  /*`G */
     'DELTA UNDERBAR',  /*`H */
     'I-BEAM        ',  /*`I */
     'ACCENT RHO    ',  /*`R */
     'SLOPE BAR     ',  /*`\ */
     'CUP           ',  /*`V */
     'OMEGA         ',  /*`W */
     'RIGHT SHOE    ',  /*`X */
     'LEFT SHOE     ',  /*`Z */
     'DIERESIS      ',  /*`1 */
     'COLON         ',  /*:  */
     'LEFT ARROW    ',  /*#  */
     'LOG           ',  /*@  */
     'QUOTE         ',  /*'' */
     'EQUAL         ',  /*=  */
     'CAP NULL      ',  /*"  */
     'TILDE         ',  /*á  */
     'LEFT BRACKET  ',  /*{  */
     'DELTA STILE   ',  /*A  */
     'BASE          ',  /*B  */
     'BASE NULL     ',  /*C  */
     'DOWNSTILE     ',  /*D  */
     'EPSILON       ',  /*E  */
     'TOP NULL      ',  /*F  */
     'DEL           ',  /*G  */
     'DELTA         ',  /*H  */
     'IOTA          ',  /*I  */
     'RIGHT BRACKET ',  /*}  */
     'NULL          ',  /*J  */
     'NOT GREATER   ',  /*K  */
     'QUAD          ',  /*L  */
     'DOMINO        ',  /*M  */
     'TOP           ',  /*N  */
     'CIRCLE        ',  /*O  */
     'NAND          ',  /*P  */
     'QUOTE-QUAD    ',  /*Q  */
     'RHO           ',  /*R  */
     'SLOPE         ',  /*\  */
     'UPSTILE       ',  /*S  */
     'CIRCLE SLOPE  ',  /*T  */
     'DOWN ARROW    ',  /*U  */
     'OR            ',  /*V  */
     'DEL STILE     ',  /*W  */
     'TIMES         ',  /*X  */
     'UP ARROW      ',  /*Y  */
     'NOT LESS      '); /*Z  */
   DCL SCANAPL ENTRY;
   DCL 1 PARMS_STRUCTURE,
   %INCLUDE ABE061A;
   DCL ABE061B ENTRY;

   UNSPEC(MISSING)='1'B;
   BARENUM=BARENUM_REAL;
   CLEANUP=CLEANUP_REAL;
   COPY_DATA=COPY_DATA_REAL;
   COPY_RH_APL=COPY_RH_APL_REAL;
   CREATE_APLCB=CREATE_APLCB_REAL;
   CREATE_VAR=CREATE_VAR_REAL;
   DO_ACCENT_RHO=DO_ACCENT_RHO_REAL;
   DO_APL_STMT=DO_APL_STMT_REAL;
   DO_ASSIGNMENT=DO_ASSIGNMENT_REAL;
   DO_ASSIGNMENT_INDEXED=DO_ASSIGNMENT_INDEXED_REAL;
   DO_ASSIGNMENT_INDEXED_SUB=DO_ASSIGNMENT_INDEXED_SUB_REAL;
   DO_BRACKET=DO_BRACKET_REAL;
   DO_BRACKET_GET=DO_BRACKET_GET_REAL;
   DO_BRACKET_INDEX=DO_BRACKET_INDEX_REAL;
   DO_BRACKET_INDEX_GET=DO_BRACKET_INDEX_GET_REAL;
   DO_BRACKET_INDEX_STACK=DO_BRACKET_INDEX_STACK_REAL;
   DO_CONSTANT_OPERAND=DO_CONSTANT_OPERAND_REAL;
   DO_IOTA=DO_IOTA_REAL;
   DO_IOTA_DYADIC=DO_IOTA_DYADIC_REAL;
   DO_IOTA_MONADIC=DO_IOTA_MONADIC_REAL;
   DO_LITERAL_OPERAND=DO_LITERAL_OPERAND_REAL;
   DO_OPERAND=DO_OPERAND_REAL;
   DO_RHO=DO_RHO_REAL;
   DO_RHO_DYADIC=DO_RHO_DYADIC_REAL;
   DO_RHO_MONADIC=DO_RHO_MONADIC_REAL;
   END_OPER=END_OPER_REAL;
   END_OPER_SUB=END_OPER_SUB_REAL;
   GET_DIM=GET_DIM_REAL;
   GET_DYADIC_OPERANDS=GET_DYADIC_OPERANDS_REAL;
   GET_EL=GET_EL_REAL;
   GET_ELEMENT=GET_ELEMENT_REAL;
   GET_ELEMENT_POSITION=GET_ELEMENT_POSITION_REAL;
   GET_OPERANDS=GET_OPERANDS_REAL;
   GET_PRIOR=GET_PRIOR_REAL;
   PAREN_CHECK=PAREN_CHECK_REAL;
   POP_OPERAND=POP_OPERAND_REAL;
   PUSH_OPERAND=PUSH_OPERAND_REAL;
   PUT_EL=PUT_EL_REAL;
   PUT_EL_SUB=PUT_EL_SUB_REAL;
   PUT_ELEMENT=PUT_ELEMENT_REAL;
   RHP_LOC=RHP_LOC_REAL;
   VECTOR_CHECK=VECTOR_CHECK_REAL;

   ON CONDITION(BADAPL) BEGIN;
     IF MSGDATA=''
       THEN MSGDATA='BAD APL EXPRESSION';
     RHRC=8;
     GOTO EOJ;
     END;

   TOKHDR,CURTOK,INDEX_STACK,OPERAND_STACK,SHOWPTR=NULL;
   DO UNTIL(TYPE=NO_MORE_TOKENS × TYPE=OTHER);
     CALL SCANAPL(CMDBUF,SCANPARM,SYMBOLS);
     END;
   IF TYPE=OTHER
     THEN DO;
       MSGDATA='INVALID TEXT='××TOKSTR;
       RHRC=8;
       CALL CLEANUP;
       RETURN;
       END;

   IF TOKHDR=NULL
     THEN RETURN;
   TOKHDR->PRIOR_TOKEN=NULL;
   CURTOK=CURTOK->PRIOR_TOKEN;
   CALL ABE061B(RHPTR,RHHDRPT,ADDR(PARMS_STRUCTURE),SYMBOLS,
     SYMBOL_NAMES);
   IF CURTOK^=NULL
     THEN DO;
       IF MSGDATA=''
         THEN MSGDATA='INVALID SYNTAX AT TOKEN='××TOKSTR;
       SIGNAL CONDITION(BADAPL);
       END;
 EOJ:
   IF OPERAND_STACK^=NULL
     THEN SHOWPTR=POP_OPERAND(OPERAND_STACK,OPERAND_COUNT);
   IF OPERAND_STACK^=NULL
     THEN IF MSGDATA=''
       THEN MSGDATA='OPERAND STACK NOT EMPTY AT END OF EVALUATION';
       ELSE;
     ELSE IF SHOWPTR^=NULL
       THEN IF CMDINDX^=3
         THEN DO;
           IF SUBSTR(SHOWPTR->RHNAME,1,1)='T' &
             (VERIFY(SUBSTR(SHOWPTR->RHNAME,2,1),'0123456789')=0)
             THEN I=#CMD('LINES 99999',SHOWPTR,RHHDRPT);
           SHOWPTR->RH_APL->RH_APL_TEMP='0'B;
           CALL END_OPER_SUB(SHOWPTR);
           END;
   RH_APLPTR=SHOWPTR;
   CALL CLEANUP;

 BARENUM_REAL: PROC(PRM) RETURNS(CHAR(20) VAR);
 /**********************************************************************
 *                                                                     *
 * CALLED TO CONVERT FIXED BIN TO CHAR, STRIPPING NONESSENTIAL BLANKS. *
 *                                                                     *
 **********************************************************************/
   DCL PRM FIXED BIN;
   DCL PIC PIC'ZZZZZZZZZZZZZZ9';
   DCL RET CHAR(20) VAR;

   PIC=PRM;
   RET=SUBSTR(PIC,PREFIX(PIC,' '));
   RET=SUBSTR(RET,1,SUFFIX(RET,' '));
   RETURN(RET);
   END BARENUM_REAL;

 CLEANUP_REAL: PROC;
 /**********************************************************************
 * CLEANUP IS CALLED TO CLEAN UP MEMORY AT END OF PROCESSING IN THIS   *
 * SUBCOMMAND.                                                         *
 **********************************************************************/
   DCL (DELPTR,RHP) PTR;
   DCL I FIXED BIN;

   /* CLEAN OUT OPERAND STACK */
   DO DELPTR=OPERAND_STACK REPEAT OPERAND_STACK WHILE(DELPTR^=NULL);
     OPERAND_STACK=DELPTR->OSENXT;
     RHP=DELPTR->OSERHP;
     FREE DELPTR->OSE;
     IF RHP->RH_APL^=NULL
       THEN SELECT;
         WHEN(RHP->RH_APL->RH_APL_TEMP)
           I=#CMD('END I',RHP,RHHDRPT); /* FREE TEMPORARY */
         WHEN(RHP->RH_APL->RH_APL_TRANSIENT) DO;
           FREE RHP->RH_APL->APLCB;
           RHP->RH_APL=NULL;
           END;
         OTHERWISE;
         END; /* SELECT */
     END;
   OPERAND_COUNT=0;

   /* CLEAN OUT INDEX STACK */
   CALL CLEANUP_INDEX;

   /* CLEAN OUT TOKENIZED STATEMENT */
   DO DELPTR=TOKHDR REPEAT TOKHDR WHILE(DELPTR^=NULL);
     TOKHDR=DELPTR->NEXT_TOKEN;
     FREE DELPTR->TOKEN;
     END;
   TOKHDR=NULL;
   SCANIX=1;
   END CLEANUP_REAL;

 CLEANUP_INDEX: PROC;
 /**********************************************************************
 * CLEANUP IS CALLED TO CLEAN UP MEMORY AT END OF PROCESSING IN THIS   *
 * SUBCOMMAND FOR THE INDEX STACK.                                     *
 **********************************************************************/
   DCL (DELPTR,RHP) PTR;
   DCL I FIXED BIN;

   DO DELPTR=INDEX_STACK REPEAT INDEX_STACK WHILE(DELPTR^=NULL);
     INDEX_STACK=DELPTR->IXWNXT;
     RHP=DELPTR->IXWRHP;
     FREE DELPTR->IXW;
     CALL END_OPER_SUB(RHP);
     END;
   INDEX_COUNT=0;
   END CLEANUP_INDEX;

 COPY_DATA_REAL: PROC(FROM,TO);
 /**********************************************************************
 *                                                                     *
 * CALLED TO COPY FROM ONE DATA SET TO ANOTHER.  THIS PROCEDURE IS     *
 * INVOKED FROM SEVERAL OTHER PROCEDURES, INCLUDING DO_ASSIGNMENT,     *
 * DO_ACCENT_RHO, AND DO_RHO_DYADIC.                                   *
 *                                                                     *
 **********************************************************************/
   DCL (FROM,RPT,TO) PTR;
   DCL (CIX,I,J,K,MIX,TOCIX,TOMIX) FIXED BIN;
   DCL (FROMSTR,TOSTR) CHAR(256) VAR;

   IF TO->RECPTR^=TO
     THEN I=#CMD('DEL',TO,RHHDRPT); /* CLEAN OUT TO DATA SET */
   RPT=NULL;
   DO I=1 TO TO->RH_APL->RH_APL_RHCOUNT*TO->RH_APL->RH_APL_ELCOUNT;
     DO J=1 REPEAT J+1 UNTIL(LENGTH(FROMSTR)^=0);
       IF J>2
         THEN SIGNAL ERROR;
       FROMSTR=GET_EL('FORWARD',FROM,RPT,CIX,MIX);
       END;
     TOSTR=CONVERT(PTROUT(PTRIN(ADDR(FROMSTR))+2),
       TYPETAB(FROM->RH_APL->RH_APL_TYPE),LENGTH(FROMSTR),0,
       TYPETAB(TO->RH_APL->RH_APL_TYPE),TO->RH_APL->RH_APL_ELEN,0);
     CALL PUT_EL(TOSTR,TO,TOCIX,TOMIX);
     END;
   END COPY_DATA_REAL;

 COPY_RH_APL_REAL: PROC(PBP) RETURNS(PTR);

 /**********************************************************************
 *                                                                     *
 * CALLED TO CREATE A COPY OF AN EXISTING APLCB.                       *
 *                                                                     *
 **********************************************************************/
   DCL (CBP,PBP) PTR;
   DCL I FIXED BIN;

   CBP=CREATE_APLCB(PBP->RH_APL_RANK);
   STRING(CBP->RH_APL_FLAGS)=STRING(PBP->RH_APL_FLAGS);
   DO I=1 TO CBP->RH_APL_RANK;
     CBP->RH_APL_DIM(I)=PBP->RH_APL_DIM(I);
     END;
   CBP->RH_APL_TYPE=PBP->RH_APL_TYPE;
   CBP->RH_APL_ELEN=PBP->RH_APL_ELEN;
   CBP->RH_APL_DEMARC=PBP->RH_APL_DEMARC;
   CBP->RH_APL_RHCOUNT=PBP->RH_APL_RHCOUNT;
   CBP->RH_APL_ELCOUNT=PBP->RH_APL_ELCOUNT;
   RETURN(CBP);
   END COPY_RH_APL_REAL;

 CREATE_APLCB_REAL: PROC(RANK) RETURNS(PTR);
 /**********************************************************************
 *                                                                     *
 * CALLED TO CREATE AND INITIALIZE A NEW APLCB.                        *
 *                                                                     *
 **********************************************************************/
   DCL RANK FIXED BIN(31,0);
   DCL CBP PTR;

   L=MAX(1,RANK); /* SET REFER VARIABLE */
   ALLOCATE APLCB SET(CBP);
   CBP->RH_APL_LEN=STORAGE(CBP->APLCB)-2;
   STRING(CBP->RH_APL_FLAGS)='0'B;
   IF RANK=0
     THEN CBP->RH_APL_SCALAR='1'B;
   CBP->RH_APL_TYPE=FLOAT_TYPE; /* DEFAULT TO FLOAT */
   CBP->RH_APL_ELEN=8; /* DEFAULT TO LENGTH 8 */
   CBP->RH_APL_DIM(*)=0;
   CBP->RH_APL_DEMARC=0; /* DEFAULT TO SINGLE RECORD */
   CBP->RH_APL_RHCOUNT=0;
   CBP->RH_APL_ELCOUNT=0;
   CBP->RH_APL_DISPLAY1,CBP->RH_APL_DISPLAY2=-1;
   RETURN(CBP);
   END CREATE_APLCB_REAL;

 CREATE_APLCB_TRANSIENT: PROC(RHP);
 /**********************************************************************
 *                                                                     *
 * CALLED TO CREATE AND INITIALIZE A TRANSIENT APLCB.                  *
 *                                                                     *
 **********************************************************************/
   DCL RHP PTR;

   RHP->RH_APL=CREATE_APLCB(2); /* SET APL CB, MXN MATRIX */
   RHP->RH_APL->RH_APL_DIM(1)=RHP->RHCOUNT;
   RHP->RH_APL->RH_APL_DIM(2)=RHP->BUFPTR->BUFLN; /* SET N */
   RHP->RH_APL->RH_APL_RHCOUNT=RHP->RHCOUNT;
   RHP->RH_APL->RH_APL_ELCOUNT=RHP->BUFPTR->BUFLN;
   RHP->RH_APL->RH_APL_DEMARC=1;
   RHP->RH_APL->RH_APL_ELEN=1;
   RHP->RH_APL->RH_APL_TYPE=CHAR_TYPE;
   RHP->RH_APL->RH_APL_TRANSIENT='1'B;
   END CREATE_APLCB_TRANSIENT;

 CREATE_VAR_REAL: PROC(RECSIZE,CBP,NAME) RETURNS(PTR);
 /**********************************************************************
 *                                                                     *
 * CALLED TO CREATE AND INITIALIZE A NEW VARIABLE.                     *
 *                                                                     *
 **********************************************************************/
   DCL RECSIZE FIXED BIN(31,0);
   DCL (CBP,RHP) PTR;
   DCL NAME CHAR(*) VAR;
   DCL I FIXED BIN;
   DCL CMD CHAR(256) VAR;
   DCL PRECSIZE PIC'99999';

   PRECSIZE=MIN(RECSIZE,32767);
   CMD='ABE '''' NOSHOW HEX RECSIZE('××PRECSIZE××') ';
   IF NAME^=''
     THEN CMD=CMD××' NAME('××NAME××')';
   RHP=RHPTR;
   I=#CMD(CMD,RHP,RHHDRPT);
   IF I^=0
     THEN SIGNAL ERROR;
   RHP->RH_APL=CBP;
   IF NAME=''
     THEN CBP->RH_APL_TEMP='1'B;
   RETURN(RHP);
   END CREATE_VAR_REAL;

 DO_ACCENT_RHO_REAL: PROC;
 /**********************************************************************
 *                                                                     *
 * CALLED TO PERFORM THE ACCENT RHO OPERATOR.                          *
 *                                                                     *
 **********************************************************************/
   DCL (CBP,LEFT,RHP,RIGHT,RPT,SAVECBP) PTR;
   DCL NEWRANK FIXED BIN;
   DCL (I,J,K,L,M) FIXED BIN;

   CALL GET_DYADIC_OPERANDS('ACCENT RHO',LEFT,RIGHT);
   IF LEFT->RH_APL->RH_APL_RANK^=1
     THEN DO;
       MSGDATA='LEFT OPERAND TO ACCENT RHO MUST BE SCALAR OR VECTOR';
       SIGNAL CONDITION(BADAPL);
       END;
   NEWRANK=LEFT->RH_APL->RH_APL_DIM(1)-1;
   IF NEWRANK<1
     THEN DO;
       MSGDATA='LEFT OPERAND TO ACCENT RHO MUST BE SCALAR OR VECTOR';
       SIGNAL CONDITION(BADAPL);
       END;
   CBP=CREATE_APLCB(NEWRANK);
   CBP->RH_APL_TYPE=CHAR_TYPE;
   CBP->RH_APL_DEMARC=1;
   J=GET_DIM('ACCENT',LEFT,CBP); /* GET DIMEN., SET RHCOUNT,ELCOUNT */
   IF CBP->RH_APL_RHCOUNT^=RIGHT->RHCOUNT
     THEN DO;
       /* NOW FIGURE OUT DIMENSION DEMARCATION POINT */
       K=1;
       M=0;
       DO WHILE(K<RIGHT->RHCOUNT);
         M=M+1;
         K=K*CBP->RH_APL_DIM(M);
         END;
       IF K^=RIGHT->RHCOUNT
         THEN DO;
           FREE CBP->APLCB;
           MSGDATA='ACCENT-RHO CAN''T MATCH DIMENSIONS TO DATA SET';
           SIGNAL CONDITION(BADAPL);
           END;
       CBP->RH_APL_DEMARC=M;
       CBP->RH_APL_RHCOUNT=K; /* SET PHYSICAL RECORD COUNT */
       K=1;
       DO I=CBP->RH_APL_DEMARC+1 TO CBP->RH_APL_RANK;
         K=K*CBP->RH_APL_DIM(I); /* K=# ELEMENTS PER TO-RECORD */
         END;
       CBP->RH_APL_ELCOUNT=K; /* SET # ELEMENTS PER RECORD */
       END;
   L=CBP->RH_APL_ELCOUNT*CBP->RH_APL_ELEN; /* LENGTH OF TO-RECORD */
   RHP=CREATE_VAR(L,CBP,''); /* CREATE TO DATASET */
   RHP->HEXMODE=RIGHT->HEXMODE;
   SAVECBP=RIGHT->RH_APL;
   RIGHT->RH_APL=CBP;
   CALL COPY_DATA(RIGHT,RHP);
   RIGHT->RH_APL=SAVECBP;
   CALL END_OPER(LEFT,RIGHT,RHP);
   END DO_ACCENT_RHO_REAL;

 DO_APL_STMT_REAL: PROC(STMT) RETURNS(PTR);
 /**********************************************************************
 *                                                                     *
 * CALLED TO RECURSIVELY EXECUTE AN APL STATEMENT.                     *
 *                                                                     *
 **********************************************************************/
   DCL STMT CHAR(*) VAR;
   DCL (RETPTR,SAVPTR) PTR;
   DCL I FIXED BIN;

   SAVPTR=RHPTR;
   I=#CMD(STMT,RHPTR,RHHDRPT);
   IF I^=0
     THEN DO;
       MSGDATA='INVALID STMT='××STMT;
       SIGNAL CONDITION(BADAPL);
       END;
   RHPTR=SAVPTR;
   RETURN(RH_APLPTR);
   END DO_APL_STMT_REAL;

 DO_ASSIGNMENT_REAL: PROC RECURSIVE;
 /**********************************************************************
 *                                                                     *
 * CALLED TO PERFORM THE ASSIGNMENT OPERATOR.                          *
 *                                                                     *
 **********************************************************************/
   DCL (CBP,FROM,TO) PTR;
   DCL (I,SOC) FIXED BIN;
   DCL PIC PIC'ZZZZZZ9';

   FROM=POP_OPERAND(OPERAND_STACK,OPERAND_COUNT);   /* GET FROM */
   IF FROM=NULL
     THEN DO;
       MSGDATA='NO FROM VARIABLE FOUND IN ASSIGNMENT';
       SIGNAL CONDITION(BADAPL);
       END;
   CALL GET_PRIOR; /* GO CHANGE CURTOK TO POINT TO VARIABLE NAME */
   SOC=OPERAND_COUNT; /* SAVE INITIAL OPERAND COUNT */
   IF TYPE>0
     THEN IF SYMBOL_NAMES(TYPE)='RIGHT BRACKET'
       THEN DO;
         CALL DO_BRACKET_GET; /* GO PUSH INDICES ONTO OPERAND STACK */
         CALL GET_PRIOR; /* POINT TO OPERAND NAME */
         END;
   IF TYPE^=OPERAND
     THEN DO;
       CURTOK=NEXT_TOKEN;
       TO=GET_LEFT; /* GET VARIABLE TO WHICH TO ASSIGN TO */
       IF TO=NULL
         THEN DO;
           MSGDATA='VARIABLE NOT FOUND AT LEFT OF ASSIGNMENT OPER.';
           SIGNAL CONDITION(BADAPL);
           END;
       END;
     ELSE TO=RHP_LOC(TOKSTR); /* GET RHPTR TO TO-DATA SET */
   IF OPERAND_COUNT>SOC
     THEN CALL DO_ASSIGNMENT_INDEXED(TO,FROM,SOC);
     ELSE IF FROM^=TO
       THEN DO;
         IF TO^=NULL
           THEN IF TO^=RHPTR
             THEN I=#CMD('END I',TO,RHHDRPT);
             ELSE DO; /* CAN'T DELETE CURRENT DATASET NOW */
               /* FIRST GIVE IT A TEMPORARY NAME */
               PIC=RHUNQNO;
               RHUNQNO=RHUNQNO+1;
               RHNAME='T'××SUBSTR(PIC,PREFIX(PIC,' '));
               /* AND SCHEDULE IT LATER FOR DELETION */
               CMDDATA='END I';
               END;
         CBP=COPY_RH_APL(FROM->RH_APL);
         CBP->RH_APL_TEMP='0'B;
         TO=CREATE_VAR(CBP->RH_APL_RHCOUNT*CBP->RH_APL_ELCOUNT*
           CBP->RH_APL_ELEN,CBP,TOKSTR);
         TO->HEXMODE=FROM->HEXMODE;
         CALL COPY_DATA(FROM,TO);
         I=#CMD('TOP',TO,RHHDRPT);
         END;
   CALL END_OPER_SUB(FROM);
   CALL PUSH_OPERAND(OPERAND_STACK,OPERAND_COUNT,TO);
   END DO_ASSIGNMENT_REAL;

 DO_ASSIGNMENT_INDEXED_REAL: PROC(TO,FROM,SOC);
 /**********************************************************************
 *                                                                     *
 * CALLED WHEN ASSIGNMENT INVOLVES A SET OF INDICES TO THE LEFT OF THE *
 * ASSIGNMENT OPERATOR.                                                *
 *                                                                     *
 **********************************************************************/
   DCL (FROM,TO) PTR;
   DCL (I,SOC) FIXED BIN;

   IF TO=NULL
     THEN DO;
       MSGDATA='INDEX OF NONEXISTENT VARIABLE IN ASSIGNMENT';
       SIGNAL CONDITION(BADAPL);
       END;
   I=DO_BRACKET_INDEX_STACK(SOC,TO); /* SET INDEX STACK */
   L=FROM->RH_APL->RH_APL_RANK;
   ALLOCATE IXW SET(FROMIXW);
   FROMIXW->IXWRHP=FROM;
   FROMIXW->IXWROW=MISSING_INTEGER;
   DO I=1 TO FROMIXW->IXL;
     FROMIXW->IX(I)=1;
     END;
   L=TO->RH_APL->RH_APL_RANK;
   ALLOCATE IXW SET(TOIXW);
   TOIXW->IXWRHP=TO;
   TOIXW->IXWROW=MISSING_INTEGER;
   CALL DO_ASSIGNMENT_INDEXED_SUB(FROMIXW,TOIXW,1,INDEX_STACK,1);
   CALL CLEANUP_INDEX; /* CLEAN OUT INDEX STACK */
   END DO_ASSIGNMENT_INDEXED_REAL;

 DO_ASSIGNMENT_INDEXED_SUB_REAL: PROC(FROMIXW,TOIXW,TOLVL,
   CURIXW,CURLVL) RECURSIVE;
 /**********************************************************************
 *                                                                     *
 * CALLED WHEN ASSIGNMENT INVOLVES A SET OF INDICES TO THE LEFT OF THE *
 * ASSIGNMENT OPERATOR.                                                *
 *                                                                     *
 **********************************************************************/
   DCL (CURIXW,FROMIXW,TOIXW) PTR;
   DCL (CURLVL,TOLVL) FIXED BIN;
   DCL (I,J,K) FIXED BIN;
   DCL (FROMSTR,TOSTR) CHAR(256) VAR;
   DCL IXB FIXED BIN(31,0),
       IXSTR CHAR(4) BASED(ADDR(IXB));

   DO CURIXW->IX(CURLVL)=1 TO
     CURIXW->IXWRHP->RH_APL->RH_APL_DIM(CURLVL);
     IF CURLVL=CURIXW->IXL
       THEN DO;
         TOSTR=GET_ELEMENT(CURIXW);
         IXSTR=CONVERT(PTROUT(PTRIN(ADDR(TOSTR))+2),
           TYPETAB(CURIXW->IXWRHP->RH_APL->RH_APL_TYPE),LENGTH(TOSTR),0,
           'FIXED',4,0);
         TOIXW->IX(TOLVL)=IXB;
         IF TOLVL=TOIXW->IXL
           THEN DO;
             FROMSTR=GET_ELEMENT(FROMIXW);
             TOSTR=CONVERT(PTROUT(PTRIN(ADDR(FROMSTR))+2),
               TYPETAB(FROMIXW->IXWRHP->RH_APL->RH_APL_TYPE),
                 LENGTH(FROMSTR),0,
               TYPETAB(TOIXW  ->IXWRHP->RH_APL->RH_APL_TYPE),
                 TOIXW->IXWRHP->RH_APL->RH_APL_ELEN,0);
             CALL PUT_ELEMENT(TOSTR,TOIXW);
             DO I=FROMIXW->IXL TO 1 BY -1;
               FROMIXW->IX(I)=FROMIXW->IX(I)+1;
               IF FROMIXW->IX(I)<=FROMIXW->IXWRHP->RH_APL->RH_APL_DIM(I)
                 THEN LEAVE;
               FROMIXW->IX(I)=1;
               END;
             END;
           ELSE CALL DO_ASSIGNMENT_INDEXED_SUB(FROMIXW,
             TOIXW,TOLVL+1,CURIXW->IXWNXT,1);
         END;
     END;
   END DO_ASSIGNMENT_INDEXED_SUB_REAL;

 DO_BRACKET_REAL: PROC RECURSIVE;
 /**********************************************************************
 *                                                                     *
 * CALLED WHEN A RIGHT BRACKET IS ENCOUNTERED IN THE RIGHT-TO-LEFT     *
 * SCAN OF THE APL STATEMENT.                                          *
 *                                                                     *
 **********************************************************************/
   DCL (COC,SOC) FIXED BIN;
   DCL (LEFT,TMP) PTR;

   SOC=OPERAND_COUNT; /* SAVE INITIAL OPERAND COUNT */
   CALL DO_BRACKET_GET; /* GO PUSH INDICES ONTO OPERAND STACK */
   LEFT=GET_LEFT; /* GET LEFT-OPERAND, IF ANY */
   IF LEFT=NULL
     THEN TMP=DO_AXIS(SOC);
     ELSE TMP=DO_BRACKET_INDEX(SOC,LEFT);
   CALL END_OPER(LEFT,NULL,TMP);
   END DO_BRACKET_REAL;

 DO_BRACKET_GET_REAL: PROC RECURSIVE;
 /**********************************************************************
 *                                                                     *
 * CALLED AFTER A RIGHT BRACKET IS ENCOUNTERED IN THE RIGHT-TO-LEFT    *
 * SCAN OF THE APL STATEMENT.  THIS SUBROUTINE WILL CONTINUE THE       *
 * RIGHT-TO-LEFT SCAN, PUSHING INDICES ONTO THE OPERAND STACK, UNTIL   *
 * THE CLOSING LEFT BRACKET IS ENCOUNTERED.                            *
 *                                                                     *
 **********************************************************************/
   DCL COC FIXED BIN;

   DO FOREVER=1 REPEAT FOREVER;
     CURTOK=PRIOR_TOKEN;
     COC=OPERAND_COUNT; /* SAVE CURRENT OPERAND COUNT */
     CALL MAIN_LOOP(0); /* GO GET NEXT OPERAND */
     IF COC=OPERAND_COUNT /* OMITTED INDEX? */
       THEN CALL PUSH_OPERAND(OPERAND_STACK,OPERAND_COUNT,NULL);
     SELECT(SYMBOL_NAMES(TYPE));
       WHEN('LEFT BRACKET') LEAVE;
       WHEN('SEMICOLON'); /* OK */
       OTHERWISE DO;
         MSGDATA='INVALID INDEX VALUE='××TOKSTR;
         SIGNAL CONDITION(BADAPL);
         END;
       END; /* SELECT */
     END;
   END DO_BRACKET_GET_REAL;

 DO_BRACKET_INDEX_REAL: PROC(SOC,LEFT) RETURNS(PTR);
 /**********************************************************************
 *                                                                     *
 * CALLED AFTER A LEFT BRACKET IS ENCOUNTERED IN THE RIGHT-TO-LEFT     *
 * SCAN OF THE APL STATEMENT.  THE INDICES WILL BE ON THE OPERAND      *
 * STACK, AND THE VARIABLE TO BE INDEXED WILL BE POINTED TO BY LEFT.   *
 * SOC CONTAINS THE OPERAND_COUNT PRIOR TO STACKING THE INDICES.       *
 *                                                                     *
 **********************************************************************/
   DCL (CIX,I,J,K,MIX,NEWRANK,SOC) FIXED BIN;
   DCL (CBP,FROMIXW,IXP,TOIXW,LEFT,IXWLAST,IXWNEW,TMP) PTR;

   NEWRANK=DO_BRACKET_INDEX_STACK(SOC,LEFT); /* GO SETUP INDEX STACK */
   CBP=CREATE_APLCB(NEWRANK); /* FOR NEW VARIABLE */
   CBP->RH_APL_TYPE=LEFT->RH_APL->RH_APL_TYPE;
   CBP->RH_APL_ELEN=LEFT->RH_APL->RH_APL_ELEN;
   CBP->RH_APL_DEMARC=0; /* ALL ELEMENTS IN ONE RECORD */
   CBP->RH_APL_RHCOUNT=1; /* ONE PHYSICAL RECORD IN DATA SET */

   /* NOW SET DIMENSIONS FOR NEW VARIABLE AND DETERMINE K=#ELS/REC */
   K=1;
   IF NEWRANK=0
     THEN CBP->RH_APL_DIM(1)=1;
     ELSE DO;
       J=0;
       DO IXP=INDEX_STACK REPEAT IXP->IXWNXT WHILE(IXP^=NULL);
         IF ^IXP->IXWRHP->RH_APL->RH_APL_SCALAR
           THEN DO I=1 TO IXP->IXWRHP->RH_APL->RH_APL_RANK;
             J=J+1;
             CBP->RH_APL_DIM(J)=IXP->IXWRHP->RH_APL->RH_APL_DIM(I);
             K=K*CBP->RH_APL_DIM(J);
             END;
         END;
       END;
   CBP->RH_APL_ELCOUNT=K; /* # ELEMENTS PER RECORD */

   /* NOW CREATE THE NEW VARIABLE AND SET THE VALUES */
   TMP=CREATE_VAR(K*CBP->RH_APL_ELEN,CBP,'');
   TMP->HEXMODE=LEFT->HEXMODE;
   L=LEFT->RH_APL->RH_APL_RANK;
   ALLOCATE IXW SET(FROMIXW);
   FROMIXW->IXWRHP=LEFT;
   FROMIXW->IXWROW=MISSING_INTEGER;
   L=MAX(1,NEWRANK);
   ALLOCATE IXW SET(TOIXW);
   TOIXW->IXWRHP=TMP;
   CALL DO_BRACKET_INDEX_GET(FROMIXW,1,TOIXW,1,INDEX_STACK,1,CIX,MIX);
   FREE TOIXW->IXW;
   FREE FROMIXW->IXW;
   I=#CMD('TOP',TMP,RHHDRPT);
   CALL CLEANUP_INDEX; /* CLEAN OUT INDEX STACK */
   RETURN(TMP);
   END DO_BRACKET_INDEX_REAL;

 DO_BRACKET_INDEX_GET_REAL:
   PROC(FROMIXW,FROMLVL,TOIXW,TOLVL,CURPRM,CURLVL,CIX,MIX)
   RECURSIVE;
 /**********************************************************************
 *                                                                     *
 * RECURSIVELY CALLED TO SET THE DATA VALUES IN A NEW VARIABLE         *
 * ACCORDING TO A SET OF BRACKETED INDEX VALUES.                       *
 *                                                                     *
 * FROMIXW - POINTS TO DATA SET FROM WHICH DATA VALUES ARE TO BE       *
 *           COPIED.                                                   *
 * FROMLVL - INDEX LEVEL BEING PROCESSED IN FROM DATASET.              *
 * TOIXW   - POINTS TO DATA SET TO WHICH DATA VALUES ARE TO BE COPIED. *
 * TOLVL   - INDEX LEVEL BEING PROCESSED IN TO DATASET.                *
 * CURIXW  - POINTS TO DATA SET FROM WHICH INDEX VALUES TO BE USED     *
 *           IN ACCESSING THE FROM DATASET ARE TO BE OBTAINED.         *
 * CURLVL  - INDEX LEVEL BEING PROCESSED IN INDEX DATASET.             *
 *                                                                     *
 * EACH DATASET ON THE CUR-CHAIN (LINKED VIA CURIXW->IXWNXT) IS        *
 * UNIQUELY ASSOCIATED WITH AN INDEX LEVEL IN THE FROM DATASET.        *
 * EACH DIMENSION IN A CUR-CHAIN DATASET THAT DOESN'T REPRESENT A      *
 * SCALAR IS UNIQUELY ASSOCIATED WITH AN INDEX LEVEL IN THE TO-DATASET.*
 *                                                                     *
 **********************************************************************/
   DCL (CURIXW,CURPRM,FROMIXW,TOIXW,WRKPTRA,WRKPTRB) PTR;
   DCL (CIX,CURLVL,FROMLVL,I,J,MIX,TOLVL) FIXED BIN;
   DCL (CURSTR,FROMSTR,TOSTR) CHAR(256) VAR;

   /* FIRST HANDLE SHRINKAGE DUE TO SCALAR INDICES */
   CALL DO_BRACKET_INDEX_GET_SHRINK(CURIXW,CURPRM,FROMIXW,FROMLVL);
   /* AT THIS POINT, TOIXW->RH_APL->RH_APL_DIM(TOLVL) MUST EQUAL
   CURIXW->IXWRHP->RH_APL->RH_APL_DIM(CURLVL), UNLESS CURIXW=NULL,
   WHICH SHOULD ONLY OCCUR AT THIS POINT IF THE TO-DATASET IS A
   SCALAR. */
   DO I=1 TO TOIXW->IXWRHP->RH_APL->RH_APL_DIM(TOLVL);
     TOIXW->IX(TOLVL)=I;
     IF CURIXW^=NULL
       THEN DO;
         CURIXW->IX(CURLVL)=I;
         IF CURLVL=CURIXW->IXL
           THEN DO;
             CURSTR=GET_ELEMENT(CURIXW);
             TOSTR=CONVERT(PTROUT(PTRIN(ADDR(CURSTR))+2),
               TYPETAB(CURIXW->IXWRHP->RH_APL->RH_APL_TYPE),
               LENGTH(CURSTR),0,
               'FIXED',4,0);
             FROMIXW->IX(FROMLVL)=UNSPEC(SUBSTR(TOSTR,1,4));
             END;
         END;
     SELECT;
       WHEN(TOLVL=HBOUND(TOIXW->IX,1)) DO; /* TIME TO COPY ELEMENT */
         IF CURIXW^=NULL
           THEN IF CURIXW->IXWNXT^=NULL
             THEN DO; /* HANDLE SHRINKAGE BELOW */
               WRKPTRB=CURIXW->IXWNXT;
               CALL DO_BRACKET_INDEX_GET_SHRINK(WRKPTRA,WRKPTRB,
                 FROMIXW,FROMLVL+1);
               END;
         FROMSTR=GET_ELEMENT(FROMIXW);
         TOSTR=CONVERT(PTROUT(PTRIN(ADDR(FROMSTR))+2),
           TYPETAB(FROMIXW->IXWRHP->RH_APL->RH_APL_TYPE),
           LENGTH(FROMSTR),0,
           TYPETAB(TOIXW->IXWRHP->RH_APL->RH_APL_TYPE),
           TOIXW->IXWRHP->RH_APL->RH_APL_ELEN,0);
         CALL PUT_EL(TOSTR,TOIXW->IXWRHP,CIX,MIX);
         END;
       WHEN(CURIXW=NULL) SIGNAL ERROR; /* SHOULD NEVER HAPPEN */
       WHEN(CURLVL=CURIXW->IXL)
         CALL DO_BRACKET_INDEX_GET(FROMIXW,FROMLVL+1,TOIXW,
           TOLVL+1,CURIXW->IXWNXT,1,CIX,MIX);
       OTHERWISE
         CALL DO_BRACKET_INDEX_GET(FROMIXW,FROMLVL+0,TOIXW,
           TOLVL+1,CURIXW,CURLVL+1,CIX,MIX);
       END; /* SELECT */
     END;
   END DO_BRACKET_INDEX_GET_REAL;

 DO_BRACKET_INDEX_GET_SHRINK:
   PROC(CURIXW,CURPRM,FROMIXW,FROMLVL);
 /**********************************************************************
 *                                                                     *
 * CALLED DURING INDEX PROCESSING TO HANDLE SHRINKAGE DUE TO A         *
 * SCALAR BEING SPECIFIED FOR ONE OR MORE INDICES.                     *
 *                                                                     *
 **********************************************************************/
   DCL (CURIXW,CURPRM,FROMIXW) PTR;
   DCL FROMLVL FIXED BIN;
   DCL (CURSTR,TOSTR) CHAR(256) VAR;

   DO CURIXW=CURPRM REPEAT CURIXW->IXWNXT;
     IF CURIXW=NULL
       THEN LEAVE;
     IF ^CURIXW->IXWRHP->RH_APL->RH_APL_SCALAR
       THEN LEAVE;
     CURIXW->IX(1)=1;
     CURSTR=GET_ELEMENT(CURIXW);
     TOSTR=CONVERT(PTROUT(PTRIN(ADDR(CURSTR))+2),
       TYPETAB(CURIXW->IXWRHP->RH_APL->RH_APL_TYPE),LENGTH(CURSTR),0,
       'FIXED',4,0);
     FROMIXW->IX(FROMLVL)=UNSPEC(SUBSTR(TOSTR,1,4));
     FROMLVL=FROMLVL+1;
     END;
   END DO_BRACKET_INDEX_GET_SHRINK;

 DO_BRACKET_INDEX_STACK_REAL: PROC(SOC,LEFT) RETURNS(FIXED BIN(31,0));
 /**********************************************************************
 *                                                                     *
 * CALLED AFTER A LEFT BRACKET IS ENCOUNTERED IN THE RIGHT-TO-LEFT     *
 * SCAN OF THE APL STATEMENT.  THE INDICES WILL BE ON THE OPERAND      *
 * STACK, AND THE VARIABLE TO BE INDEXED WILL BE POINTED TO BY LEFT.   *
 * SOC CONTAINS THE OPERAND_COUNT PRIOR TO STACKING THE INDICES.       *
 * THIS SUBROUTINE WILL POP THE INDICES OFF THE OPERAND STACK AND PUSH *
 * THEM ONTO THE INDEX STACK, FILLING IN DEFAULTS.  THE RANK OF THE    *
 * NEW VARIABLE ACCORDING TO THE INDEX VALUES SPECIFIED WILL BE        *
 * RETURNED.                                                           *
 *                                                                     *
 **********************************************************************/
   DCL (I,J,K,NEWRANK,SOC) FIXED BIN;
   DCL (FROMIXW,IXP,LEFT,IXWLAST,IXWNEW) PTR;
   DCL PIC PIC'ZZZZZZ9';

   I=OPERAND_COUNT-SOC;
   IF I^=LEFT->RH_APL->RH_APL_RANK
     THEN DO;
       MSGDATA='RANK ERROR AT OFFSET '××BARENUM(ELIX);
       SIGNAL CONDITION(BADAPL);
       END;

   /* NOW POP THE INDICES OFF THE OPERAND STACK, FILL IN DEFAULTS,
      CREATE AN INDEX STACK,
      AND DETERMINE THE RANK OF THE NEW VARIABLE */
   IXWNEW=NULL;
   NEWRANK=0;
   DO J=1 TO I;
     IXP=POP_OPERAND(OPERAND_STACK,OPERAND_COUNT);
     IF IXP=NULL /* IF NULL, DEFAULT MUST BE SUPPLIED FOR INDEX */
       THEN DO;
         IXP=DO_APL_STMT('APL I'××BARENUM(LEFT->RH_APL->RH_APL_DIM(J)));
         IXP->RH_APL->RH_APL_TEMP='1'B;
         END;
     /* NOW PUSH OPERAND ON INDEX_STACK IN FIFO ORDER */
     INDEX_COUNT=INDEX_COUNT+1;
     IXWLAST=IXWNEW;
     L=IXP->RH_APL->RH_APL_RANK;
     ALLOCATE IXW SET(IXWNEW);
     IXWNEW->IXWNXT=NULL;
     IXWNEW->IXWRHP=IXP;
     IXWNEW->IXWROW=MISSING_INTEGER;
     IF IXWLAST=NULL
       THEN INDEX_STACK=IXWNEW;
       ELSE IXWLAST->IXWNXT=IXWNEW;
     IF ^IXP->RH_APL->RH_APL_SCALAR
       THEN NEWRANK=NEWRANK+IXP->RH_APL->RH_APL_RANK;
     END;
   RETURN(NEWRANK);
   END DO_BRACKET_INDEX_STACK_REAL;

 DO_CONSTANT_OPERAND_REAL: PROC;
 /**********************************************************************
 *                                                                     *
 * THIS SUBROUTINE IS CALLED WHEN THE NEXT ELEMENT (RIGHT-TO-LEFT) IS  *
 * EITHER A NUMERIC SCALAR, OR A VECTOR.  THE CONSTANT WILL BE         *
 * EXTRACTED, AND A TEMPORARY VARIABLE WILL BE CREATED TO CONTAIN IT.  *
 *                                                                     *
 **********************************************************************/
   DCL (I,J,K,L,M,TOCIX,TOMIX) FIXED BIN;
   DCL (CONSTANT_STACK,RHP,CBP) PTR;
   DCL 1 CONSTANT_STACK_ELEMENT BASED(CSEPTR),
     2 CSENXT PTR, /* NEXT ELEMENT ON STACK */
     2 CSETOK PTR; /* TOKSTR CONTAINING CONSTANT */
   DCL TOSTR CHAR(256) VAR;

   CONSTANT_STACK=NULL;
   K=0; /* K IS REAL VALUE CHECK */
   DO I=1 REPEAT I+1; /* I=COUNT OF ELEMENTS IN VECTOR */
     K=K+INDEX(TOKSTR,'.');
     ALLOCATE CONSTANT_STACK_ELEMENT;
     CSENXT=CONSTANT_STACK;
     CONSTANT_STACK=CSEPTR;
     CSETOK=CURTOK;
     IF PRIOR_TOKEN=NULL
       THEN LEAVE;
     IF PRIOR_TOKEN->TYPE^=NUMERIC_CONSTANT
       THEN LEAVE;
     CURTOK=PRIOR_TOKEN;
     END;
   IF I=1
     THEN CBP=CREATE_APLCB(0); /* CREATE APLCB FOR SCALAR */
     ELSE CBP=CREATE_APLCB(1); /* CREATE APLCB FOR VECTOR */
   CBP->RH_APL_DIM(1)=I; /* STORE COUNT OF ELEMENTS IN VECTOR */
   CBP->RH_APL_TEMP='1'B; /* MARK AS TEMPORARY DATA SET */
   CBP->RH_APL_ELCOUNT=I; /* ALL ELEMENTS GO IN ONE RECORD */
   CBP->RH_APL_RHCOUNT=1; /* ONE PHYSICAL RECORD */
   RHP=CREATE_VAR(I*8,CBP,''); /* GO CREATE TEMPORARY DATA SET */
   DO CSEPTR=CONSTANT_STACK REPEAT CONSTANT_STACK WHILE(CSEPTR^=NULL);
     CONSTANT_STACK=CSENXT;
     TOSTR=CONVERT(PTROUT(PTRIN(ADDR(CSETOK->TOKSTR))+2),
       'CHAR',LENGTH(CSETOK->TOKSTR),0,
       'FLOAT',8,0);
     CALL PUT_EL(TOSTR,RHP,TOCIX,TOMIX);
     FREE CONSTANT_STACK_ELEMENT;
     END;
   M=#CMD('TOP',RHP,RHHDRPT);
   CALL PUSH_OPERAND(OPERAND_STACK,OPERAND_COUNT,RHP);
   END DO_CONSTANT_OPERAND_REAL;

 DO_IOTA_REAL: PROC;
 /**********************************************************************
 *                                                                     *
 * CALLED TO PERFORM THE IOTA OPERATOR.                                *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT,TMP) PTR;
   DCL I FIXED BIN;

   CALL GET_OPERANDS('IOTA',LEFT,RIGHT);
   IF LEFT=NULL
     THEN TMP=DO_IOTA_MONADIC(RIGHT); /* IT IS MONADIC */
     ELSE TMP=DO_IOTA_DYADIC(LEFT,RIGHT); /* IT IS DYADIC */
   CALL END_OPER(LEFT,RIGHT,TMP); /* FINISH UP */
   END DO_IOTA_REAL;

 DO_IOTA_DYADIC_REAL: PROC(LEFT,RIGHT) RETURNS(PTR);
 /**********************************************************************
 *                                                                     *
 * CALLED TO PERFORM THE DYADIC IOTA OPERATOR, OR INDEX OF.            *
 *                                                                     *
 **********************************************************************/
   DCL (CBP,LEFT,LRPT,RIGHT,RRPT,TMP) PTR;
   DCL (I,J,K,LCIX,LMIX,N,OCIX,OMIX,RCIX,RMIX) FIXED BIN;
   DCL (LEL,REL,TSTR) CHAR(256) VAR;
   DCL KF DEC FLOAT(16),
       KFCH CHAR(8) BASED(ADDR(KF));

   CALL VECTOR_CHECK(LEFT);
   CBP=CREATE_APLCB(RIGHT->RH_APL->RH_APL_RANK);
   CBP->RH_APL_SCALAR=RIGHT->RH_APL->RH_APL_SCALAR;
   J=1;
   DO I=1 TO RIGHT->RH_APL->RH_APL_RANK; /* COPY DIMENSIONS */
     K,CBP->RH_APL_DIM(I)=RIGHT->RH_APL->RH_APL_DIM(I);
     J=J*K;
     END;
   /* J NOW EQUALS TOTAL # ELEMENTS TO PROCESS */
   CBP->RH_APL_RHCOUNT=1;
   CBP->RH_APL_ELCOUNT=J;
   IF J=0
     THEN TMP=CREATE_VAR(0,CBP,''); /* IT IS A NULL VECTOR */
     ELSE DO;
       TMP=CREATE_VAR(J*CBP->RH_APL_ELEN,CBP,'');
       RRPT=NULL;
       DO FOREVER=1 REPEAT FOREVER;
         TSTR=GET_EL('FORWARD',RIGHT,RRPT,RCIX,RMIX); /* NXT RIGHT EL */
         IF LENGTH(TSTR)=0
           THEN LEAVE; /* ALL DONE */
         REL=CONVERT(PTROUT(PTRIN(ADDR(TSTR))+2),
           TYPETAB(RIGHT->RH_APL->RH_APL_TYPE),
           LENGTH(TSTR),0,
           TYPETAB(LEFT->RH_APL->RH_APL_TYPE),
           LEFT->RH_APL->RH_APL_ELEN,0);
         LRPT=NULL;
         DO KF=1 TO LEFT->RH_APL->RH_APL_DIM(1);
           LEL=GET_EL('FORWARD',LEFT,LRPT,LCIX,LMIX); /* NEXT LEFT EL */
           IF LENGTH(LEL)=0
             THEN SIGNAL ERROR; /* SHOULDN'T HAPPEN */
           IF LEL=REL
             THEN LEAVE; /* FOUND INDEX VALUE */
           END;
         CALL PUT_EL(KFCH,TMP,OCIX,OMIX); /* PUT OUT INDEX */
         END;
       I=#CMD('TOP',TMP,RHHDRPT);
       END;
   RETURN(TMP);
   END DO_IOTA_DYADIC_REAL;

 DO_IOTA_MONADIC_REAL: PROC(RIGHT) RETURNS(PTR);
 /**********************************************************************
 *                                                                     *
 * CALLED TO PERFORM THE MONADIC IOTA OPERATOR, OR INDEX GENERATOR.    *
 *                                                                     *
 **********************************************************************/
   DCL (CBP,RIGHT,TMP) PTR;
   DCL (CIX,I,J,K,MIX) FIXED BIN(31,0),
     ICH CHAR(4) BASED(ADDR(I));
   DCL JF DEC FLOAT(16),
       JFCH CHAR(8) BASED(ADDR(JF));
   IF RIGHT->RH_APL->RH_APL_RANK>1 × RIGHT->RH_APL->RH_APL_DIM(1)^=1
     THEN DO;
       MSGDATA='OPERAND TO MONADIC IOTA M/B SCALAR OR 1-ELEMENT VECTOR';
       SIGNAL CONDITION(BADAPL);
       END;
   IF RIGHT->NXTHDR=RIGHT
     THEN DO;
       MSGDATA='DATA DOESN''T MATCH DIMENSIONS, NAME='××RIGHT->RHNAME;
       SIGNAL CONDITION(BADAPL);
       END;
   ICH=CONVERT(PTROUT(PTRIN(ADDR(RIGHT->NXTHDR->RECSTR))+2),
     TYPETAB(RIGHT->RH_APL->RH_APL_TYPE),
     RIGHT->RH_APL->RH_APL_ELEN,0,
     'FIXED',STORAGE(I),0);
   IF I<0
     THEN DO;
       MSGDATA='OPERAND TO MONADIC IOTA M/B GE 0';
       SIGNAL CONDITION(BADAPL);
       END;
   CBP=CREATE_APLCB(1); /* FOR NEW VECTOR */
   CBP->RH_APL_DIM(1)=I; /* # ELEMENTS IN NEW VECTOR */
   CBP->RH_APL_RHCOUNT=1; /* # PHYSICAL RECORDS */
   CBP->RH_APL_ELCOUNT=I; /* # ELS/RECORD */
   TMP=CREATE_VAR(I*CBP->RH_APL_ELEN,CBP,''); /* CREATE TEMPORARY */
   IF I>0
     THEN DO JF=1 TO I;
       CALL PUT_EL(JFCH,TMP,CIX,MIX); /* PUT OUT INDEX */
       END;
   K=#CMD('TOP',TMP,RHHDRPT);
   RETURN(TMP);
   END DO_IOTA_MONADIC_REAL;

 DO_LITERAL_OPERAND_REAL: PROC;
 /**********************************************************************
 *                                                                     *
 * CALLED WHEN THE NEXT ELEMENT (RIGHT-TO-LEFT) IN THE CURRENT APL     *
 * STATEMENT IS A QUOTED STRING.                                       *
 *                                                                     *
 **********************************************************************/
   DCL (CBP,RHP) PTR;
   DCL (I,J) FIXED BIN;

   CBP=CREATE_APLCB(1); /* CREATE APLCB FOR VECTOR */
   CBP->RH_APL_DIM(1)=LENGTH(TOKSTR);
   IF LENGTH(TOKSTR)=1
     THEN CBP->RH_APL_SCALAR='1'B;
   CBP->RH_APL_TEMP='1'B;
   CBP->RH_APL_TYPE=CHAR_TYPE;
   CBP->RH_APL_ELEN=1;
   RHP=CREATE_VAR(LENGTH(TOKSTR),CBP,''); /* CREATE TEMP DATASET */
   RHP->LOFLAG='1'B;
   RHP->HEXMODE='0'B;
   IF LENGTH(TOKSTR)>0
     THEN DO;
       CBP->RH_APL_RHCOUNT=1;
       CBP->RH_APL_ELCOUNT=LENGTH(TOKSTR);
       J=#CMD('NL '××TOKSTR,RHP,RHHDRPT);
       I=#CMD('TOP',RHP,RHHDRPT);
       END;
   CALL PUSH_OPERAND(OPERAND_STACK,OPERAND_COUNT,RHP);
   END DO_LITERAL_OPERAND_REAL;

 DO_OPERAND_REAL: PROC;
 /**********************************************************************
 *                                                                     *
 * CALLED WHEN THE NEXT TOKEN (RIGHT-TO-LEFT) IS AN OPERAND NAME.      *
 *                                                                     *
 **********************************************************************/
   DCL (CBP,RHP) PTR;
   DCL I FIXED BIN(15,0);
   DCL 1 IST BASED(ADDR(I)),
     2 IPAD CHAR(1),
     2 ICH CHAR(1);
   DCL MYCMD CHAR(300) VAR;

   IF TOKSTR='AV'
     THEN IF PRIOR_TOKEN^=NULL
       THEN IF PRIOR_TOKEN->TYPE>0
         THEN IF SYMBOL_NAMES(PRIOR_TOKEN->TYPE)='QUAD'
           THEN DO; /* IT IS A REFERENCE TO THE ATOMIC VECTOR */
             CURTOK=PRIOR_TOKEN;
             CBP=CREATE_APLCB(1); /* SET UP APL CB FOR VECTOR */
             CBP->RH_APL_DIM(1)=256;
             CBP->RH_APL_RHCOUNT=1;
             CBP->RH_APL_ELCOUNT=256;
             CBP->RH_APL_DEMARC=0;
             CBP->RH_APL_ELEN=1;
             CBP->RH_APL_TYPE=CHAR_TYPE;
             RHP=CREATE_VAR(256,CBP,''); /* GO CREATE TEMP DATASET */
             RHP->LOFLAG='1'B;
             RHP->HEXMODE='1'B;
             MYCMD='NL ';
             DO I=0 TO 255;
               MYCMD=MYCMD××ICH;
               END;
             I=#CMD(MYCMD,RHP,RHHDRPT);
             I=#CMD('TOP',RHP,RHHDRPT);
             CALL PUSH_OPERAND(OPERAND_STACK,OPERAND_COUNT,RHP);
             RETURN;
             END;
   RHP=RHP_LOC(TOKSTR); /* LOCATE DATA SET */
   IF RHP=NULL
     THEN DO;
       MSGDATA='SYMBOL '××TOKSTR××' NOT DEFINED.';
       SIGNAL CONDITION(BADAPL);
       END;
   CALL PUSH_OPERAND(OPERAND_STACK,OPERAND_COUNT,RHP);
   END DO_OPERAND_REAL;

 DO_RHO_REAL: PROC;
 /**********************************************************************
 *                                                                     *
 * CALLED TO PERFORM THE RHO OPERATOR.                                 *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT,TMP) PTR;
   DCL I FIXED BIN;

   CALL GET_OPERANDS('RHO',LEFT,RIGHT);
   IF LEFT=NULL
     THEN TMP=DO_RHO_MONADIC(RIGHT); /* IT IS MONADIC RHO */
     ELSE TMP=DO_RHO_DYADIC(LEFT,RIGHT); /* IT IS DYADIC RHO */
   CALL END_OPER(LEFT,RIGHT,TMP); /* FINISH UP */
   END DO_RHO_REAL;

 DO_RHO_DYADIC_REAL: PROC(LEFT,RIGHT) RETURNS(PTR);
 /**********************************************************************
 *                                                                     *
 * CALLED TO PERFORM THE DYADIC RHO OPERATOR.                          *
 *                                                                     *
 **********************************************************************/
   DCL (CBP,LEFT,RHP,RIGHT,RPT) PTR;
   DCL NEWRANK FIXED BIN;
   DCL (I,J,K,L,M) FIXED BIN;

   CALL VECTOR_CHECK(LEFT);
   NEWRANK=LEFT->RH_APL->RH_APL_DIM(1);
   CBP=CREATE_APLCB(MAX(1,NEWRANK));
   CBP->RH_APL_TYPE=RIGHT->RH_APL->RH_APL_TYPE;
   IF NEWRANK=0
     THEN DO;
       CBP->RH_APL_SCALAR='1'B;
       K,CBP->RH_APL_ELEN=RIGHT->RH_APL->RH_APL_ELEN;
       CBP->RH_APL_DIM(1)=1;
       CBP->RH_APL_RHCOUNT=1;
       CBP->RH_APL_ELCOUNT=1;
       RHP=CREATE_VAR(K,CBP,'');
       CALL COPY_DATA(RIGHT,RHP);
       END;
     ELSE DO;
       /* FIRST SET UP DIMENSIONS FOR NEW DATASET */
       J=GET_DIM('RHO',LEFT,CBP);
       /* J CONTAINS # ELEMENTS IN NEW DATASET, AND RH_APL_RHCOUNT AND
       RH_APL_ELCOUNT ARE SET */
       IF J=0
         THEN RHP=CREATE_VAR(0,CBP,''); /* IT IS A NULL VECTOR */
         ELSE DO; /* RESHAPE DATA */
           CBP->RH_APL_ELEN=RIGHT->RH_APL->RH_APL_ELEN;
           L=CBP->RH_APL_ELCOUNT*CBP->RH_APL_ELEN; /* LENGTH TO-RECORD*/
           RHP=CREATE_VAR(L,CBP,''); /* CREATE TO DATASET */
           RHP->HEXMODE=RIGHT->HEXMODE;
           CALL COPY_DATA(RIGHT,RHP);
           END;
       END;
   RETURN(RHP);
   END DO_RHO_DYADIC_REAL;

 DO_RHO_MONADIC_REAL: PROC(RIGHT) RETURNS(PTR);
 /**********************************************************************
 *                                                                     *
 * CALLED TO PERFORM THE MONADIC RHO OPERATOR.                         *
 *                                                                     *
 **********************************************************************/
   DCL (CBP,RHP,RIGHT) PTR;
   DCL (CIX,I,J,K,L,R,MIX) FIXED BIN;
   DCL TMPSTR CHAR(80) VAR;
   DCL JF DEC FLOAT(16),
       JFC CHAR(8) BASED(ADDR(JF));

   CBP=CREATE_APLCB(1); /* FOR NEW VECTOR */
   R=RIGHT->RH_APL->RH_APL_RANK; /* OFTEN-USED VALUE */
   CBP->RH_APL_RHCOUNT=1;
   CBP->RH_APL_ELCOUNT=R;
   CBP->RH_APL_DIM(1)=R; /* # ELEMENTS IN NEW VECTOR */
   CBP->RH_APL_TEMP='1'B; /* MARK AS TEMPORARY DATA SET */
   IF RIGHT->RH_APL->RH_APL_SCALAR
     THEN J=0; /* IT IS A NULL VECTOR */
     ELSE J=R;
   RHP=CREATE_VAR(J*8,CBP,''); /* GO CREATE TEMP DATASET */
   IF J>0
     THEN DO I=1 TO R; /* IT IS NOT A NULL VECTOR */
       JF=RIGHT->RH_APL->RH_APL_DIM(I);
       CALL PUT_EL(JFC,RHP,CIX,MIX);
       END;
   J=#CMD('TOP',RHP,RHHDRPT);
   RETURN(RHP);
   END DO_RHO_MONADIC_REAL;

 END_OPER_REAL: PROC(LEFT,RIGHT,TMP);
 /**********************************************************************
 *                                                                     *
 * CALLED TO FINISH UP AFTER AN OPERATOR HAS BEEN PROCESSED.           *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT,TMP) PTR;
   DCL I FIXED BIN;

   CALL PUSH_OPERAND(OPERAND_STACK,OPERAND_COUNT,TMP);
   CALL END_OPER_SUB(RIGHT);
   CALL END_OPER_SUB(LEFT);
   IF TMP^=NULL
     THEN DO;
       I=#CMD('TOP',TMP,RHHDRPT);
       IF TMP->RH_APL->RH_APL_TRANSIENT
         THEN DO;
           FREE TMP->RH_APL->APLCB;
           TMP->RH_APL=NULL;
           END;
       END;
   END END_OPER_REAL;

 END_OPER_SUB_REAL: PROC(OPT);
 /**********************************************************************
 *                                                                     *
 * CALLED TO FINISH UP AFTER AN OPERATOR HAS BEEN PROCESSED.           *
 *                                                                     *
 **********************************************************************/
   DCL OPT PTR;
   DCL I FIXED BIN;

   IF OPT^=NULL
     THEN SELECT;
       WHEN(OPT->RH_APL->RH_APL_TEMP)
         I=#CMD('END I',OPT,RHHDRPT); /* FREE TEMPORARY */
       WHEN(OPT->RH_APL->RH_APL_TRANSIENT) DO;
         FREE OPT->RH_APL->APLCB;
         OPT->RH_APL=NULL;
         END;
       OTHERWISE;
       END; /* SELECT */
   END END_OPER_SUB_REAL;

 GET_DIM_REAL: PROC(TYPGET,RHP,CBP) RETURNS(FIXED BIN);
 /**********************************************************************
 *                                                                     *
 * CALLED TO FILL IN THE RH_APL_DIM ARRAY OF THE CONTROL BLOCK POINTED *
 * TO BY CBP WITH THE VALUES FROM THE VECTOR REPRESENTED IN THE DATA   *
 * SET POINTED TO BY RHP. GET_DIM WILL RETURN THE NUMBER OF ELEMENTS   *
 * IN THE NEW DATA SET, AND WILL ALSO SET CBP->RH_APL_RHCOUNT AND      *
 * CBP->RH_APL_ELCOUNT TO THE NUMBER OF PHYSICAL RECORDS REQUIRED      *
 * AND THE NUMBER OF ELEMENTS PER PHYSICAL RECORD RESPECTIVELY.        *
 *                                                                     *
 * TYPGET SHOULD BE SET TO 'ACCENT' IF INVOCATION FROM ACCENT-RHO, AND *
 * SHOULD BE SET TO 'RHO   ' IF INVOCATION FROM RHO.                   *
 *                                                                     *
 **********************************************************************/
   DCL (CBP,RHP,RPT) PTR;
   DCL (CIX,I,J,K,MIX) FIXED BIN;
   DCL TYPGET CHAR(*);

   J=1;
   CBP->RH_APL_RHCOUNT,CBP->RH_APL_ELCOUNT=1;
   RPT=NULL;
   IF TYPGET='ACCENT'
     THEN DO; /* RIGHTMOST ELEMENT S/B ELEN */
       CBP->RH_APL_ELEN=GET_INTEGER_SEQ('BACKWARD',RHP,RPT,CIX,MIX);
       IF RPT=NULL
         THEN DO;
           MSGDATA='DATA DOESN''T MATCH DIMENSIONS IN '××RHP->RHNAME;
           SIGNAL CONDITION(BADAPL);
           END;
       END;
   DO I=CBP->RH_APL_RANK TO 1 BY -1 UNTIL(RPT=NULL);
     K,CBP->RH_APL_DIM(I)=GET_INTEGER_SEQ('BACKWARD',RHP,RPT,CIX,MIX);
     J=J*K;
     IF I=CBP->RH_APL_DEMARC+1
       THEN DO;
         CBP->RH_APL_ELCOUNT=J;
         J=1;
         END;
     END;
   CBP->RH_APL_RHCOUNT=J;
   IF RPT=NULL & I>0
     THEN DO;
       MSGDATA='DATA DOESN''T MATCH DIMENSIONS IN '××RHP->RHNAME;
       SIGNAL CONDITION(BADAPL);
       END;
   RETURN(J);
   END GET_DIM_REAL;

 GET_DYADIC_OPERANDS_REAL: PROC(OPERATOR,LEFT,RIGHT);
 /**********************************************************************
 *                                                                     *
 * CALLED TO OBTAIN THE LEFT AND RIGHT OPERANDS OF A DYADIC OPERATOR.  *
 *                                                                     *
 **********************************************************************/
   DCL OPERATOR CHAR(*);
   DCL (LEFT,RIGHT) PTR;
   DCL I FIXED BIN;

   CALL GET_OPERANDS(OPERATOR,LEFT,RIGHT);
   IF LEFT=NULL
     THEN DO;
       MSGDATA=OPERATOR××' OPERATOR MUST HAVE A LEFT OPERAND';
       SIGNAL CONDITION(BADAPL);
       END;
   END GET_DYADIC_OPERANDS_REAL;

   %INCLUDE ABE061F; /* INCLUDE SOURCE FOR GET_EL_REAL, GET_EL_SUB */

 GET_ELEMENT_REAL: PROC(W) RETURNS(CHAR(256) VAR);
 /**********************************************************************
 *                                                                     *
 * CALLED TO GET AN ELEMENT FROM A VARIABLE.  PARAMETER W SHOULD POINT *
 * TO A STRUCTURE DESCRIBED BY THE DCL FOR BASED VARIABLE IXW.  THE    *
 * NECESSARY INDEX VALUES SHOULD BE STORED IN THIS STRUCTURE.          *
 *                                                                     *
 **********************************************************************/
   DCL W PTR;
   DCL (I,J,K,L,LEN,OFF) FIXED BIN;

   CALL GET_ELEMENT_POSITION(W,OFF,LEN);
   RETURN(GET_EL_SUB(W->IXWRHP,W->IXWREC,OFF,LEN));
   END GET_ELEMENT_REAL;

 GET_ELEMENT_POSITION_REAL: PROC(W,OFF,LEN);
 /**********************************************************************
 *                                                                     *
 * CALLED TO POSITION A DATASET TO A PARTICULAR ELEMENT IN A DATASET.  *
 * PARAMETER W SHOULD POINT TO A STRUCTURE DESCRIBED BY THE DCL FOR    *
 * BASED VARIABLE IXW.  THE NECESSARY INDEX VALUES SHOULD BE STORED    *
 * IN THIS STRUCTURE.                                                  *
 *                                                                     *
 **********************************************************************/
   DCL W PTR;
   DCL (DESROW,I,J,K,L,LEN,OFF) FIXED BIN;

   ON CONDITION(BADIX) BEGIN;
     MSGDATA='INVALID INDEX VALUE';
     SIGNAL CONDITION(BADAPL);
     END;
   IF W->IXWROW=MISSING_INTEGER
     THEN DO; /* INITIALIZATION TIME */
       W->IXWROW=1;
       W->IXWREC=W->IXWRHP->NXTHDR;
       END;
   IF W->IXWREC=W->IXWRHP
     THEN DO;
       I=#CMD('NL',W->IXWRHP,RHHDRPT);
       W->IXWREC=W->IXWRHP->NXTHDR;
       END;
   /* NOW FIGURE OUT DESIRED ROW, E.G. DESIRED RELATIVE RECORD NUMBER */
   DESROW,J=1;
   DO I=W->IXWRHP->RH_APL->RH_APL_DEMARC REPEAT I-1 WHILE(I>0);
     DESROW=DESROW+J*(W->IX(I)-1);
     J=J*W->IXWRHP->RH_APL->RH_APL_DIM(I);
     END;
   DO WHILE(W->IXWROW < DESROW);
     W->IXWROW=W->IXWROW+1;
     W->IXWREC=#SUCC(RHHDRPT,W->IXWRHP,W->IXWREC);
     IF W->IXWREC=W->IXWRHP
       THEN DO;
         I=#CMD('B BL 1',W->IXWRHP,RHHDRPT);
         W->IXWREC=W->IXWRHP->LSTHDR;
         END;
     END;
   DO WHILE(W->IXWROW > DESROW);
     W->IXWROW=W->IXWROW-1;
     W->IXWREC=#PRED(RHHDRPT,W->IXWRHP,W->IXWREC);
     IF W->IXWREC=W->IXWRHP
       THEN SIGNAL CONDITION(BADIX);
     END;
   /* WE ARE NOW POSITIONED TO THE CORRECT ROW */
   J=1;
   K=0;
   IF W->IXWRHP->RH_APL->RH_APL_ELCOUNT>1
     THEN DO I=W->IXL TO W->IXWRHP->RH_APL->RH_APL_DEMARC+1 BY -1;
       L=W->IXWRHP->RH_APL->RH_APL_DIM(I);
       IF W->IX(I)>L
         THEN SIGNAL CONDITION(BADIX);
       K=K+(W->IX(I)-1)*J;
       J=J*L;
       END;
   LEN=W->IXWRHP->RH_APL->RH_APL_ELEN;
   OFF=K*LEN;
   END GET_ELEMENT_POSITION_REAL;

 GET_OPERANDS_REAL: PROC(OPERATOR,LEFT,RIGHT) RECURSIVE;
 /**********************************************************************
 *                                                                     *
 * CALLED TO OBTAIN THE LEFT AND RIGHT OPERANDS.  THERE MUST BE A      *
 * RIGHT OPERAND, BUT THE LEFT OPERAND IS OPTIONAL, AND POINTER LEFT   *
 * WILL SIMPLY BE SET TO NULL IF THE LEFT OPERAND DOESN'T EXIST.       *
 *                                                                     *
 **********************************************************************/
   DCL OPERATOR CHAR(*);
   DCL (LEFT,RIGHT) PTR;
   DCL I FIXED BIN;

   RIGHT=POP_OPERAND(OPERAND_STACK,OPERAND_COUNT); /* GET RIGHT OP */
   IF RIGHT=NULL
     THEN DO;
       MSGDATA=OPERATOR××' OPERATOR MUST HAVE A RIGHT OPERAND';
       SIGNAL CONDITION(BADAPL);
       END;
   LEFT=GET_LEFT; /* GO GET RHPTR FOR LEFT OPERAND */
   END GET_OPERANDS_REAL;

 GET_PRIOR_REAL: PROC;
 /**********************************************************************
 *                                                                     *
 * CALLED TO CHANGE CURTOK TO POINT TO THE PRIOR TOKEN.  IF THERE IS   *
 * NO PRIOR TOKEN, AN ERROR MESSAGE WILL BE PRODUCED AND BADAPL WILL   *
 * BE SIGNALLED.                                                       *
 *                                                                     *
 **********************************************************************/

   CURTOK=PRIOR_TOKEN;
   IF CURTOK=NULL
     THEN DO;
       MSGDATA='OPERAND OR OPERATOR NOT FOUND WHEN EXPECTED';
       SIGNAL CONDITION(BADAPL);
       END;
   END GET_PRIOR_REAL;

 PAREN_CHECK_REAL: PROC;
 /**********************************************************************
 *                                                                     *
 * CALLED TO CHECK FOR UNBALANCED PARENTHESES.                         *
 *                                                                     *
 **********************************************************************/
   IF CURTOK=NULL
     THEN DO;
       MSGDATA='UNBALANCED PARENTHESES';
       SIGNAL CONDITION(BADAPL);
       END;
   IF SYMBOL_NAMES(TYPE)^='LEFT PAREN'
     THEN DO;
       MSGDATA='UNBALANCED PARENTHESES';
       SIGNAL CONDITION(BADAPL);
       END;
   END PAREN_CHECK_REAL;

 POP_OPERAND_REAL: PROC(OPERAND_STACK,OPERAND_COUNT) RETURNS(PTR);
 /**********************************************************************
 *                                                                     *
 * CALLED TO POP AN OPERAND FROM THE OPERAND STACK.                    *
 *                                                                     *
 **********************************************************************/
   DCL (RHP,OPERAND_STACK) PTR;
   DCL OPERAND_COUNT FIXED BIN;

   IF OPERAND_STACK=NULL
     THEN RETURN(NULL);
   OSEPTR=OPERAND_STACK;
   OPERAND_STACK=OSENXT;
   OPERAND_COUNT=OPERAND_COUNT-1;
   RHP,SHOWPTR=OSERHP;
   FREE OSE;
   IF RHP^=NULL
     THEN IF RHP->RH_APL=NULL
       THEN CALL CREATE_APLCB_TRANSIENT(RHP);
   RETURN(RHP);
   END POP_OPERAND_REAL;

 PUSH_OPERAND_REAL: PROC(OPERAND_STACK,OPERAND_COUNT,RHP);
 /**********************************************************************
 *                                                                     *
 * CALLED TO PUSH AN OPERAND ONTO THE OPERAND STACK.                   *
 *                                                                     *
 **********************************************************************/
   DCL (OPERAND_STACK,RHP) PTR;
   DCL OPERAND_COUNT FIXED BIN;

   ALLOCATE OSE;
   OSENXT=OPERAND_STACK;
   OPERAND_STACK=OSEPTR;
   OSERHP=RHP;
   OPERAND_COUNT=OPERAND_COUNT+1;
   END PUSH_OPERAND_REAL;

 PUT_EL_REAL: PROC(EL,RHP,CIX,MIX);
 /**********************************************************************
 *                                                                     *
 * CALLED TO STORE THE NEXT ELEMENT, EL, IN THE DATASET POINTED TO BY  *
 * RHP.  CIX AND MIX ARE USED INTERNALLY, AND SHOULD NOT BE CHANGED BY *
 * THE CALLER FROM ONE INVOCATION TO THE NEXT.  RHP SHOULD INITIALLY   *
 * POINT TO AN EMPTY DATA SET.                                         *
 *                                                                     *
 **********************************************************************/
   DCL EL CHAR(*) VAR;
   DCL (RHP,ELP) PTR;
   DCL (CIX,MIX) FIXED BIN;
   DCL (I,LEN,OFF) FIXED BIN;

   IF RHP->RECPTR=RHP
     THEN DO; /* IT IS INITIALIZATION TIME */
       MIX=RHP->RH_APL->RH_APL_ELCOUNT;
       /* MIX = MAXIMUM NUMBER ELEMENTS IN EACH RECORD */
       CIX=MIX; /* CAUSE BUMP TO NEW RECORD */
       END;
   IF MIX=0
     THEN RETURN;
   CIX=CIX+1; /* GET INDEX TO NEXT ELEMENT */
   IF CIX>MIX
     THEN DO; /* TIME TO GET A NEW RECORD */
       I=#CMD('NL',RHP,RHHDRPT);
       CIX=1;
       END;
   OFF=(CIX-1)*RHP->RH_APL->RH_APL_ELEN;
   CALL PUT_EL_SUB(EL,RHP,RHP->RECPTR,OFF,RHP->RH_APL->RH_APL_ELEN);
   END PUT_EL_REAL;

 PUT_EL_SUB_REAL: PROC(EL,RHP,RPT,OFF,LEN);
 /**********************************************************************
 *                                                                     *
 * CALLED TO DO THE ACTUAL INSERTION OF AN ELEMENT INTO THE SPECIFIED  *
 * RECORD AT THE SPECIFIED OFFSET AND LENGTH.                          *
 *                                                                     *
 **********************************************************************/
   DCL EL CHAR(*) VAR;
   DCL (RHP,RPT) PTR;
   DCL (I,LEN,OFF) FIXED BIN;
   DCL WRKSTR CHAR(32767) BASED(WRKPTR);

   I=OFF+LEN;
   IF I <= RPT->RECLEN
     THEN CALL #ABEINS(EL,ADDR(RPT->RECLEN),OFF+1,LEN);
     ELSE IF I < RPT->RECLEN+RPT->RECPNLN**2
       THEN SUBSTR(PTROUT(PTRIN(ADDR(RPT->RECSTR))+2+OFF)->WRKSTR,
         OFF-RPT->RECLEN+1,LEN)=EL;
   END PUT_EL_SUB_REAL;

 PUT_ELEMENT_REAL: PROC(EL,W);
 /**********************************************************************
 *                                                                     *
 * CALLED TO STORE THE NEXT ELEMENT, EL, IN THE DATASET POINTED TO BY  *
 * W->IXWRHP.  PUT_ELEMENT DIFFERS FROM PUT_EL IN THAT THE ELEMENT IS  *
 * TO BE INSERTED BY RANDOM ADDRESSING, RATHER THAN SEQUENTIALLY AS    *
 * WITH PUT_EL.                                                        *
 *                                                                     *
 **********************************************************************/
   DCL EL CHAR(*) VAR;
   DCL W PTR;
   DCL (I,LEN,OFF) FIXED BIN;
   DCL WRKSTR CHAR(32767) BASED(WRKPTR);

   CALL GET_ELEMENT_POSITION(W,OFF,LEN); /* POSITION THE FILE */
   CALL PUT_EL_SUB(EL,W->IXWRHP,W->IXWREC,OFF,LEN);
   END PUT_ELEMENT_REAL;

 RHP_LOC_REAL: PROC(NAME) RETURNS(PTR);
 /**********************************************************************
 *                                                                     *
 * CALLED TO LOCATE THE NAMED DATA SET.  IF IT FOUND, ITS RHPTR WILL   *
 * BE RETURNED.  OTHERWISE NULL WILL BE RETURNED.                      *
 *                                                                     *
 **********************************************************************/
   DCL NAME CHAR(*);
   DCL RPT PTR;

   RPT=#RHPLOC(NAME,RHHDRPT);
   IF RPT^=NULL
     THEN IF RPT->RH_APL=NULL
       THEN CALL CREATE_APLCB_TRANSIENT(RPT);
   RETURN(RPT);
   END RHP_LOC_REAL;

 VECTOR_CHECK_REAL: PROC(RHP);
 /**********************************************************************
 *                                                                     *
 * CALLED TO CHECK FOR A VECTOR.                                       *
 *                                                                     *
 **********************************************************************/
   DCL RHP PTR;

   IF RHP->RH_APL->RH_APL_RANK^=1
     THEN DO;
       MSGDATA='RANK ERROR IN RHO, OPERAND='××LEFT->RHNAME;
       SIGNAL CONDITION(BADAPL);
       END;
   END VECTOR_CHECK_REAL;

   END ABE061;
