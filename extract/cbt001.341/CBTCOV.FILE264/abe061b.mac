 /* COPYRIGHT 1983 BY THOMAS GLEN SMITH */
 /* ABE061B - APL */
   %INCLUDE ABESUB;
 ABESUB(ABE061B) CHECK(YES) RECURS(YES)
   PARMS(RHPTR,RHHDRPT,PARMSPTR,SYMBOLS,SYMBOL_NAMES);
   %INCLUDE ABESUBA;

   DCL PARMSPTR PTR;
   DCL SYMBOLS(72) CHAR(3);
   DCL SYMBOL_NAMES(72) CHAR(14);
   DCL 1 PARMS_STRUCTURE BASED(PARMSPTR),
   %INCLUDE ABE061A;
   DCL ABE061C ENTRY;

   DO_AND=DO_AND_REAL;
   DO_AND_CHAR=DO_AND_CHAR_REAL;
   DO_BINOMIAL=DO_BINOMIAL_REAL;
   DO_BINOMIAL_CHAR=DO_BINOMIAL_CHAR_REAL;
   DO_CEILING=DO_CEILING_REAL;
   DO_CIRCLE=DO_CIRCLE_REAL;
   DO_CIRCLE_CHAR=DO_CIRCLE_CHAR_REAL;
   DO_CONJUGATE=DO_CONJUGATE_REAL;
   DO_DEAL=DO_DEAL_REAL;
   DO_DEAL_CHAR=DO_DEAL_CHAR_REAL;
   DO_DIVIDE=DO_DIVIDE_REAL;
   DO_DIVIDE_CHAR=DO_DIVIDE_CHAR_REAL;
   DO_EQUAL=DO_EQUAL_REAL;
   DO_EQUAL_CHAR=DO_EQUAL_CHAR_REAL;
   DO_EXPONENTIAL=DO_EXPONENTIAL_REAL;
   DO_FLOOR=DO_FLOOR_REAL;
   DO_GREATER=DO_GREATER_REAL;
   DO_GREATER_CHAR=DO_GREATER_CHAR_REAL;
   DO_LESS=DO_LESS_REAL;
   DO_LESS_CHAR=DO_LESS_CHAR_REAL;
   DO_LOG=DO_LOG_REAL;
   DO_LOG_CHAR=DO_LOG_CHAR_REAL;
   DO_MAGNITUDE=DO_MAGNITUDE_REAL;
   DO_MAXIMUM=DO_MAXIMUM_REAL;
   DO_MAXIMUM_CHAR=DO_MAXIMUM_CHAR_REAL;
   DO_MINIMUM=DO_MINIMUM_REAL;
   DO_MINIMUM_CHAR=DO_MINIMUM_CHAR_REAL;
   DO_MINUS=DO_MINUS_REAL;
   DO_MINUS_CHAR=DO_MINUS_CHAR_REAL;
   DO_NAND=DO_NAND_REAL;
   DO_NAND_CHAR=DO_NAND_CHAR_REAL;
   DO_NATURAL_LOGARITHM=DO_NATURAL_LOGARITHM_REAL;
   DO_NEGATIVE=DO_NEGATIVE_REAL;
   DO_NOT=DO_NOT_REAL;
   DO_NOR=DO_NOR_REAL;
   DO_NOR_CHAR=DO_NOR_CHAR_REAL;
   DO_NOT_EQUAL=DO_NOT_EQUAL_REAL;
   DO_NOT_EQUAL_CHAR=DO_NOT_EQUAL_CHAR_REAL;
   DO_NOT_LESS=DO_NOT_LESS_REAL;
   DO_NOT_LESS_CHAR=DO_NOT_LESS_CHAR_REAL;
   DO_NOT_GREATER=DO_NOT_GREATER_REAL;
   DO_NOT_GREATER_CHAR=DO_NOT_GREATER_CHAR_REAL;
   DO_OR=DO_OR_REAL;
   DO_OR_CHAR=DO_OR_CHAR_REAL;
   DO_PI_TIMES=DO_PI_TIMES_REAL;
   DO_PLUS=DO_PLUS_REAL;
   DO_PLUS_CHAR=DO_PLUS_CHAR_REAL;
   DO_POWER=DO_POWER_REAL;
   DO_POWER_CHAR=DO_POWER_CHAR_REAL;
   DO_PRIMITIVE=DO_PRIMITIVE_REAL;
   DO_PRIMITIVE_DYADIC=DO_PRIMITIVE_DYADIC_REAL;
   DO_PRIMITIVE_DYADIC_BAL=DO_PRIMITIVE_DYADIC_BAL_REAL;
   DO_PRIMITIVE_DYADIC_ENT=DO_PRIMITIVE_DYADIC_ENT_REAL;
   DO_PRIMITIVE_DYADIC_ECH=DO_PRIMITIVE_DYADIC_ECH_REAL;
   DO_PRIMITIVE_DYADIC_UNBAL=DO_PRIMITIVE_DYADIC_UNBAL_REAL;
   DO_PRIMITIVE_MONADIC=DO_PRIMITIVE_MONADIC_REAL;
   DO_PRIMITIVE_MONADIC_SUB=DO_PRIMITIVE_MONADIC_SUB_REAL;
   DO_RECIPROCAL=DO_RECIPROCAL_REAL;
   DO_RESIDUE=DO_RESIDUE_REAL;
   DO_RESIDUE_CHAR=DO_RESIDUE_CHAR_REAL;
   DO_ROLL=DO_ROLL_REAL;
   DO_SIGNUM=DO_SIGNUM_REAL;
   DO_TIMES=DO_TIMES_REAL;
   DO_TIMES_CHAR=DO_TIMES_CHAR_REAL;
   EL_CNT=EL_CNT_REAL;
   GET_INTEGER_SEQ=GET_INTEGER_SEQ_REAL;
   GET_LEFT=GET_LEFT_REAL;
   GET_SCALAR_SEQ=GET_SCALAR_SEQ_REAL;
   RND=RND_REAL;

   CALL ABE061C(RHPTR,RHHDRPT,PARMSPTR,SYMBOLS,SYMBOL_NAMES);

 DO_AND_REAL: PROC(LEFT,RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * CALLED TO PERFORM THE SCALAR DYADIC FUNCTION AND.                   *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT) DEC FLOAT(16);

   SELECT;
     WHEN(LEFT=0 & RIGHT=0) RETURN(0);
     WHEN(LEFT=0 & RIGHT=1) RETURN(0);
     WHEN(LEFT=1 & RIGHT=0) RETURN(0);
     WHEN(LEFT=1 & RIGHT=1) RETURN(1);
     OTHERWISE DO;
       MSGDATA='LOGICAL AND ACCEPTS ONLY 0 AND 1';
       SIGNAL CONDITION(BADAPL);
       END;
     END; /* SELECT */
   END DO_AND_REAL;

 DO_AND_CHAR_REAL: PROC(LEFT,RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * CALLED TO PERFORM THE SCALAR DYADIC FUNCTION AND.                   *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT) CHAR(*) VAR;

   RETURN(DO_AND(LEFT,RIGHT));
   END DO_AND_CHAR_REAL;

 DO_BINOMIAL_REAL: PROC(LEFT,RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * CALLED TO PERFORM THE SCALAR DYADIC FUNCTION BINOMIAL.              *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT) DEC FLOAT(16);

   RETURN(FACTORL(RIGHT)/(FACTORL(LEFT)*FACTORL(RIGHT-LEFT)));
   END DO_BINOMIAL_REAL;

 DO_BINOMIAL_CHAR_REAL: PROC(LEFT,RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * CALLED TO PERFORM THE SCALAR DYADIC FUNCTION BINOMIAL.              *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT) CHAR(*) VAR;

   RETURN(DO_BINOMIAL(LEFT,RIGHT));
   END DO_BINOMIAL_CHAR_REAL;

 DO_CEILING_REAL: PROC(RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * STANDARD APL SCALAR MONADIC FUNCTION CEILING.                       *
 *                                                                     *
 **********************************************************************/
   DCL (RIGHT,WRK,FRACTION) DEC FLOAT(16);

   WRK=ABS(RIGHT);
   FRACTION=MOD(WRK,1);
   IF FRACTION=0
     THEN RETURN(RIGHT);
   WRK=WRK-FRACTION;
   IF RIGHT>=0
     THEN RETURN(WRK+1);
     ELSE RETURN(-WRK);
   END DO_CEILING_REAL;

 DO_CIRCLE_REAL: PROC(LEFT,RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * STANDARD APL SCALAR DYADIC CIRCULAR, HYPERBOLIC, AND PYTHAGOREAN    *
 * FUNCTIONS.                                                          *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT) DEC FLOAT(16);

   SELECT(LEFT);
     WHEN(-7) RETURN(ATANH(RIGHT));
     WHEN(-6) RETURN(LOG(RIGHT+SQRT(RIGHT**2-1)))   /* ACOSH */;
     WHEN(-5) RETURN(LOG(RIGHT+SQRT(RIGHT**2+1)))   /* ASINH */;
     WHEN(-4) RETURN(SQRT(-1+RIGHT**2));
     WHEN(-3) RETURN(ATAN(RIGHT));
     WHEN(-2) RETURN(ACOS(RIGHT));
     WHEN(-1) RETURN(ASIN(RIGHT));
     WHEN( 0) RETURN(SQRT(1-RIGHT**2));
     WHEN(+1) RETURN(SIN(RIGHT));
     WHEN(+2) RETURN(COS(RIGHT));
     WHEN(+3) RETURN(TAN(RIGHT));
     WHEN(+4) RETURN(SQRT(1+RIGHT**2));
     WHEN(+5) RETURN(SINH(RIGHT));
     WHEN(+6) RETURN(COSH(RIGHT));
     WHEN(+7) RETURN(TANH(RIGHT));
     OTHERWISE DO;
       MSGDATA='DOMAIN ERROR - INVALID LEFT OPERAND TO CIRCLE FUNCTION';
       SIGNAL CONDITION(BADAPL);
       END;
     END; /* SELECT */
   END DO_CIRCLE_REAL;

 DO_CIRCLE_CHAR_REAL: PROC(LEFT,RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * STANDARD APL SCALAR DYADIC CIRCULAR, HYPERBOLIC, AND PYTHAGOREAN    *
 * FUNCTIONS.                                                          *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT) CHAR(*) VAR;

   RETURN(DO_CIRCLE(LEFT,RIGHT));
   END DO_CIRCLE_CHAR_REAL;

 DO_CONJUGATE_REAL: PROC(RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * STANDARD APL SCALAR MONADIC FUNCTION CONJUGATE.                     *
 *                                                                     *
 **********************************************************************/
   DCL RIGHT DEC FLOAT(16);

   RETURN(RIGHT);
   END DO_CONJUGATE_REAL;

 DO_DEAL_REAL: PROC(LEFT,RIGHT) RETURNS(PTR);
 /**********************************************************************
 *                                                                     *
 * STANDARD APL MIXED DYADIC FUNCTION DEAL.                            *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT) DEC FLOAT(16);
   DCL (CBP,SAV,TMP) PTR;
   DCL CMD CHAR(256) VAR;
   DCL I FIXED BIN;

   IF LEFT>RIGHT
     THEN DO;
       MSGDATA='LEFT MUST BE <= RIGHT ARGUMENT TO DEAL';
       SIGNAL CONDITION(BADAPL);
       END;
   IF MOD(LEFT,1)+MOD(RIGHT,1)^=0 × LEFT<=0 × RIGHT<=0
     THEN DO;
       MSGDATA='ONLY POSITIVE INTEGERS ACCEPTED BY DEAL FUNCTION';
       SIGNAL CONDITION(BADAPL);
       END;
   PUT STRING(CMD) EDIT('RANDOM ',RIGHT,LEFT,' -1')(A,F(8),X(1),F(8),A);
   SAV=RHPTR;
   I=#CMD('ABE '''' RECSIZE(8)',RHPTR,RHHDRPT);
   TMP=RHPTR;
   RHPTR=SAV;
   I=#CMD(CMD,TMP,RHHDRPT);
   CBP=CREATE_APLCB(1);
   TMP->RH_APL=CBP;
   CBP->RH_APL_TYPE=ZONED_TYPE;
   CBP->RH_APL_ELEN=8;
   CBP->RH_APL_DIM(1)=LEFT;
   CBP->RH_APL_RHCOUNT=LEFT;
   CBP->RH_APL_ELCOUNT=1;
   CBP->RH_APL_DEMARC=1;
   CBP->RH_APL_TEMP='1'B;
   RETURN(TMP);
   END DO_DEAL_REAL;

 DO_DEAL_CHAR_REAL: PROC(LEFT,RIGHT) RETURNS(PTR);
 /**********************************************************************
 *                                                                     *
 * STANDARD APL MIXED DYADIC FUNCTION DEAL.                            *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT) CHAR(*) VAR;
   RETURN(DO_DEAL(LEFT,RIGHT));
   END DO_DEAL_CHAR_REAL;

 DO_DIVIDE_REAL: PROC(LEFT,RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * STANDARD APL SCALAR DYADIC FUNCTION DIVIDE.                         *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT) DEC FLOAT(16);

   IF RIGHT=0
     THEN IF LEFT=0
       THEN RETURN(1);
       ELSE DO;
         MSGDATA='DIVISION BY ZERO';
         SIGNAL CONDITION(BADAPL);
         END;
   NOUNDERFLOW:RETURN(LEFT/RIGHT);
   END DO_DIVIDE_REAL;

 DO_DIVIDE_CHAR_REAL: PROC(LEFT,RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * STANDARD APL SCALAR DYADIC FUNCTION DIVIDE.                         *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT) CHAR(*) VAR;

   RETURN(DO_DIVIDE(LEFT,RIGHT));
   END DO_DIVIDE_CHAR_REAL;

 DO_EQUAL_REAL: PROC(LEFT,RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * STANDARD APL SCALAR DYADIC FUNCTION EQUAL (=).                      *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT) DEC FLOAT(16);

   RETURN(RIGHT=LEFT);
   END DO_EQUAL_REAL;

 DO_EQUAL_CHAR_REAL: PROC(LEFT,RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * STANDARD APL SCALAR DYADIC FUNCTION EQUAL (=).                      *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT) CHAR(*) VAR;

   RETURN(RIGHT=LEFT);
   END DO_EQUAL_CHAR_REAL;

 DO_EXPONENTIAL_REAL: PROC(RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * STANDARD APL SCALAR MONADIC FUNCTION EXPONENTIAL.                   *
 *                                                                     *
 **********************************************************************/
   DCL RIGHT DEC FLOAT(16);

   RETURN(EXP(RIGHT));
   END DO_EXPONENTIAL_REAL;

 DO_FLOOR_REAL: PROC(RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * STANDARD APL SCALAR MONADIC FUNCTION FLOOR.                         *
 *                                                                     *
 **********************************************************************/
   DCL (RIGHT,WRK,FRACTION) DEC FLOAT(16);

   WRK=ABS(RIGHT);
   FRACTION=MOD(WRK,1);
   IF FRACTION=0
     THEN RETURN(RIGHT);
   WRK=WRK-FRACTION;
   IF RIGHT>=0
     THEN RETURN(WRK);
     ELSE RETURN(-1-WRK);
   END DO_FLOOR_REAL;

 DO_GREATER_REAL: PROC(LEFT,RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * STANDARD APL SCALAR DYADIC FUNCTION LESS THAN (>).                  *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT) DEC FLOAT(16);

   RETURN(LEFT>RIGHT);
   END DO_GREATER_REAL;

 DO_GREATER_CHAR_REAL: PROC(LEFT,RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * STANDARD APL SCALAR DYADIC FUNCTION LESS THAN (>).                  *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT) CHAR(*) VAR;

   RETURN(LEFT>RIGHT);
   END DO_GREATER_CHAR_REAL;

 DO_LESS_REAL: PROC(LEFT,RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * STANDARD APL SCALAR DYADIC FUNCTION LESS THAN (<).                  *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT) DEC FLOAT(16);

   RETURN(LEFT<RIGHT);
   END DO_LESS_REAL;

 DO_LESS_CHAR_REAL: PROC(LEFT,RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * STANDARD APL SCALAR DYADIC FUNCTION LESS THAN (<).                  *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT) CHAR(*) VAR;

   RETURN(LEFT<RIGHT);
   END DO_LESS_CHAR_REAL;

 DO_LOG_REAL: PROC(LEFT,RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * STANDARD APL SCALAR DYADIC FUNCTION LOGARITHM.                      *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT) DEC FLOAT(16);

   RETURN(LOG(RIGHT)/LOG(LEFT));
   END DO_LOG_REAL;

 DO_LOG_CHAR_REAL: PROC(LEFT,RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * STANDARD APL SCALAR DYADIC FUNCTION LOGARITHM.                      *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT) CHAR(*) VAR;

   RETURN(DO_LOG(LEFT,RIGHT));
   END DO_LOG_CHAR_REAL;

 DO_MAGNITUDE_REAL: PROC(RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * STANDARD APL SCALAR MONADIC FUNCTION MAGNITUDE.                     *
 *                                                                     *
 **********************************************************************/
   DCL RIGHT DEC FLOAT(16);

   RETURN(ABS(RIGHT));
   END DO_MAGNITUDE_REAL;

 DO_MAXIMUM_REAL: PROC(LEFT,RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * STANDARD APL SCALAR DYADIC FUNCTION MAXIMUM.                        *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT) DEC FLOAT(16);

   RETURN(MAX(LEFT,RIGHT));
   END DO_MAXIMUM_REAL;

 DO_MAXIMUM_CHAR_REAL: PROC(LEFT,RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * STANDARD APL SCALAR DYADIC FUNCTION MAXIMUM.                        *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT) CHAR(*) VAR;

   RETURN(DO_MAXIMUM(LEFT,RIGHT));
   END DO_MAXIMUM_CHAR_REAL;

 DO_MINIMUM_REAL: PROC(LEFT,RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * STANDARD APL SCALAR DYADIC FUNCTION MINIMUM.                        *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT) DEC FLOAT(16);

   RETURN(MIN(LEFT,RIGHT));
   END DO_MINIMUM_REAL;

 DO_MINIMUM_CHAR_REAL: PROC(LEFT,RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * STANDARD APL SCALAR DYADIC FUNCTION MINIMUM.                        *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT) CHAR(*) VAR;

   RETURN(DO_MINIMUM(LEFT,RIGHT));
   END DO_MINIMUM_CHAR_REAL;

 DO_MINUS_REAL: PROC(LEFT,RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * STANDARD APL SCALAR FUNCTION MINUS.                                 *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT) DEC FLOAT(16);

   RETURN(LEFT-RIGHT);
   END DO_MINUS_REAL;

 DO_MINUS_CHAR_REAL: PROC(LEFT,RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * STANDARD APL SCALAR FUNCTION MINUS.                                 *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT) CHAR(*) VAR;

   RETURN(DO_MINUS(LEFT,RIGHT));
   END DO_MINUS_CHAR_REAL;

 DO_NAND_REAL: PROC(LEFT,RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * CALLED TO PERFORM THE SCALAR DYADIC FUNCTION NAND.                  *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT) DEC FLOAT(16);

   SELECT;
     WHEN(LEFT=0 & RIGHT=0) RETURN(1);
     WHEN(LEFT=0 & RIGHT=1) RETURN(1);
     WHEN(LEFT=1 & RIGHT=0) RETURN(1);
     WHEN(LEFT=1 & RIGHT=1) RETURN(0);
     OTHERWISE DO;
       MSGDATA='LOGICAL NAND ACCEPTS ONLY 0 AND 1';
       SIGNAL CONDITION(BADAPL);
       END;
     END; /* SELECT */
   END DO_NAND_REAL;

 DO_NAND_CHAR_REAL: PROC(LEFT,RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * CALLED TO PERFORM THE SCALAR DYADIC FUNCTION NAND.                  *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT) CHAR(*) VAR;

   RETURN(DO_NAND(LEFT,RIGHT));
   END DO_NAND_CHAR_REAL;

 DO_NATURAL_LOGARITHM_REAL: PROC(RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * STANDARD APL SCALAR MONADIC FUNCTION NATURAL LOGARITHM.             *
 *                                                                     *
 **********************************************************************/
   DCL RIGHT DEC FLOAT(16);

   RETURN(LOG(RIGHT));
   END DO_NATURAL_LOGARITHM_REAL;

 DO_NEGATIVE_REAL: PROC(RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * STANDARD APL SCALAR MONADIC FUNCTION NEGATIVE.                      *
 *                                                                     *
 **********************************************************************/
   DCL RIGHT DEC FLOAT(16);

   RETURN(-RIGHT);
   END DO_NEGATIVE_REAL;

 DO_NOT_REAL: PROC(RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * STANDARD APL SCALAR MONADIC FUNCTION NOT.                           *
 *                                                                     *
 **********************************************************************/
   DCL RIGHT DEC FLOAT(16);

   SELECT(RIGHT);
     WHEN(0) RETURN(1);
     WHEN(1) RETURN(0);
     OTHERWISE DO;
       MSGDATA='MONADIC NOT ACCEPTS ONLY 0 AND 1';
       SIGNAL CONDITION(BADAPL);
       END;
     END; /* SELECT */
   END DO_NOT_REAL;

 DO_NOR_REAL: PROC(LEFT,RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * CALLED TO PERFORM THE SCALAR DYADIC FUNCTION NOR.                   *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT) DEC FLOAT(16);

   SELECT;
     WHEN(LEFT=0 & RIGHT=0) RETURN(1);
     WHEN(LEFT=0 & RIGHT=1) RETURN(0);
     WHEN(LEFT=1 & RIGHT=0) RETURN(0);
     WHEN(LEFT=1 & RIGHT=1) RETURN(0);
     OTHERWISE DO;
       MSGDATA='LOGICAL NOR ACCEPTS ONLY 0 AND 1';
       SIGNAL CONDITION(BADAPL);
       END;
     END; /* SELECT */
   END DO_NOR_REAL;

 DO_NOR_CHAR_REAL: PROC(LEFT,RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * CALLED TO PERFORM THE SCALAR DYADIC FUNCTION NOR.                   *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT) CHAR(*) VAR;

   RETURN(DO_NOR(LEFT,RIGHT));
   END DO_NOR_CHAR_REAL;

 DO_NOT_EQUAL_REAL: PROC(LEFT,RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * STANDARD APL SCALAR DYADIC FUNCTION NOT EQUAL (^=).                 *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT) DEC FLOAT(16);

   RETURN(RIGHT^=LEFT);
   END DO_NOT_EQUAL_REAL;

 DO_NOT_EQUAL_CHAR_REAL: PROC(LEFT,RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * STANDARD APL SCALAR DYADIC FUNCTION NOT EQUAL (^=).                 *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT) CHAR(*) VAR;

   RETURN(RIGHT^=LEFT);
   END DO_NOT_EQUAL_CHAR_REAL;

 DO_NOT_LESS_REAL: PROC(LEFT,RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * STANDARD APL SCALAR DYADIC FUNCTION NOT LESS (>=).                  *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT) DEC FLOAT(16);

   RETURN(LEFT>=RIGHT);
   END DO_NOT_LESS_REAL;

 DO_NOT_LESS_CHAR_REAL: PROC(LEFT,RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * STANDARD APL SCALAR DYADIC FUNCTION NOT LESS (>=).                  *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT) CHAR(*) VAR;

   RETURN(LEFT>=RIGHT);
   END DO_NOT_LESS_CHAR_REAL;

 DO_NOT_GREATER_REAL: PROC(LEFT,RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * STANDARD APL SCALAR DYADIC FUNCTION NOT GREATER THAN (<=).          *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT) DEC FLOAT(16);

   RETURN(LEFT<=RIGHT);
   END DO_NOT_GREATER_REAL;

 DO_NOT_GREATER_CHAR_REAL: PROC(LEFT,RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * STANDARD APL SCALAR DYADIC FUNCTION NOT GREATER THAN (<=).          *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT) CHAR(*) VAR;

   RETURN(LEFT<=RIGHT);
   END DO_NOT_GREATER_CHAR_REAL;

 DO_OR_REAL: PROC(LEFT,RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * CALLED TO PERFORM THE SCALAR DYADIC FUNCTION OR.                    *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT) DEC FLOAT(16);

   SELECT;
     WHEN(LEFT=0 & RIGHT=0) RETURN(0);
     WHEN(LEFT=0 & RIGHT=1) RETURN(1);
     WHEN(LEFT=1 & RIGHT=0) RETURN(1);
     WHEN(LEFT=1 & RIGHT=1) RETURN(1);
     OTHERWISE DO;
       MSGDATA='LOGICAL OR ACCEPTS ONLY 0 AND 1';
       SIGNAL CONDITION(BADAPL);
       END;
     END; /* SELECT */
   END DO_OR_REAL;

 DO_OR_CHAR_REAL: PROC(LEFT,RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * CALLED TO PERFORM THE SCALAR DYADIC FUNCTION OR.                    *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT) CHAR(*) VAR;

   RETURN(DO_OR(LEFT,RIGHT));
   END DO_OR_CHAR_REAL;

 DO_PI_TIMES_REAL: PROC(RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * STANDARD APL SCALAR MONADIC FUNCTION PI TIMES.                      *
 *                                                                     *
 **********************************************************************/
   DCL RIGHT DEC FLOAT(16);

   RETURN(RIGHT*3.141592654);
   END DO_PI_TIMES_REAL;

 DO_PLUS_REAL: PROC(LEFT,RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * STANDARD APL SCALAR FUNCTION PLUS.                                  *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT) DEC FLOAT(16);

   RETURN(LEFT+RIGHT);
   END DO_PLUS_REAL;

 DO_PLUS_CHAR_REAL: PROC(LEFT,RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * STANDARD APL SCALAR FUNCTION PLUS.                                  *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT) CHAR(*) VAR;

   RETURN(DO_PLUS(LEFT,RIGHT));
   END DO_PLUS_CHAR_REAL;

 DO_POWER_REAL: PROC(LEFT,RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * STANDARD APL SCALAR DYADIC FUNCTION POWER.                          *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT,RET) DEC FLOAT(16);

   RET = ABS(LEFT) ** RIGHT;
   IF LEFT<0 & MOD(RIGHT,2)^=0
     THEN RET=-RET;
   RETURN(RET);
   END DO_POWER_REAL;

 DO_POWER_CHAR_REAL: PROC(LEFT,RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * STANDARD APL SCALAR DYADIC FUNCTION POWER.                          *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT) CHAR(*) VAR;

   RETURN(DO_POWER(LEFT,RIGHT));
   END DO_POWER_CHAR_REAL;

 DO_PRIMITIVE_REAL: PROC(FUNCTION_NAME);
 /**********************************************************************
 *                                                                     *
 * CALLED WHEN THE CURRENT OPERATOR IS A STANDARD APL SCALAR FUNCTION. *
 *                                                                     *
 **********************************************************************/
   DCL FUNCTION_NAME CHAR(*);
   DCL (LEFT,RIGHT,TMP) PTR;
   DCL I FIXED BIN;

   I=0;
   IF PRIOR_TOKEN^=NULL
     THEN IF PRIOR_TOKEN->TYPE>0
       THEN IF SYMBOL_NAMES(PRIOR_TOKEN->TYPE)='DOT'
         THEN I=1; /* IT IS INNER PRODUCT */
   IF I=0
     THEN DO;
       CALL GET_OPERANDS(FUNCTION_NAME,LEFT,RIGHT);
       IF LEFT=NULL
         THEN TMP=DO_PRIMITIVE_MONADIC(FUNCTION_NAME,RIGHT);
         ELSE TMP=DO_PRIMITIVE_DYADIC(FUNCTION_NAME,LEFT,RIGHT);
       END;
     ELSE TMP=DO_INNER_PRODUCT(FUNCTION_NAME,LEFT,RIGHT);
   CALL END_OPER(LEFT,RIGHT,TMP); /* FINISH UP */
   END DO_PRIMITIVE_REAL;

 DO_PRIMITIVE_DYADIC_REAL: PROC(FUNCTION_NAME,LEFT,RIGHT) RETURNS(PTR);
 /**********************************************************************
 *                                                                     *
 * CALLED WHEN THE CURRENT OPERATOR IS A STANDARD APL SCALAR FUNCTION, *
 * AND IT IS DYADIC.                                                   *
 *                                                                     *
 **********************************************************************/
   DCL FUNCTION_NAME CHAR(*);
   DCL (LEFT,RIGHT,TMP) PTR;
   DCL FUNCTION ENTRY VARIABLE;
   DCL (I,J,K,M,N) FIXED BIN;
   DCL CHARCHAR BIT(1);

   CHARCHAR=(LEFT->RH_APL->RH_APL_TYPE=CHAR_TYPE &
     RIGHT->RH_APL->RH_APL_TYPE=CHAR_TYPE);
   IF CHARCHAR
     THEN CALL DO_PRIMITIVE_DYADIC_ECH(FUNCTION_NAME,FUNCTION);
     ELSE CALL DO_PRIMITIVE_DYADIC_ENT(FUNCTION_NAME,FUNCTION);
   M=EL_CNT(LEFT->RH_APL);
   N=EL_CNT(RIGHT->RH_APL);
   SELECT;
     WHEN(FUNCTION_NAME='QUERY') DO;
       IF ^(M=1 & N=1)
         THEN DO;
           MSGDATA='ONLY SINGLE ELEMENT ARGUMENTS TO DEAL ALLOWED';
           SIGNAL CONDITION(BADAPL);
           END;
       RETURN(DO_DEAL(
         GET_SCALAR_SEQ('FORWARD',LEFT, NULL,I,J),
         GET_SCALAR_SEQ('FORWARD',RIGHT,NULL,I,J)));
       END;
     WHEN(M=1 & N=1)
       IF LEFT->RH_APL->RH_APL_RANK>RIGHT->RH_APL->RH_APL_RANK
         THEN RETURN(DO_PRIMITIVE_DYADIC_UNBAL('LEFT',FUNCTION_NAME,
           FUNCTION,FUNCTION,LEFT,RIGHT,1,CHARCHAR));
         ELSE RETURN(DO_PRIMITIVE_DYADIC_UNBAL('RIGHT',FUNCTION_NAME,
           FUNCTION,FUNCTION,RIGHT,LEFT,1,CHARCHAR));
     WHEN(M=1) RETURN(DO_PRIMITIVE_DYADIC_UNBAL('RIGHT',FUNCTION_NAME,
       FUNCTION,FUNCTION,RIGHT,LEFT,N,CHARCHAR));
     WHEN(N=1) RETURN(DO_PRIMITIVE_DYADIC_UNBAL('LEFT',FUNCTION_NAME,
       FUNCTION,FUNCTION,LEFT,RIGHT,M,CHARCHAR));
     WHEN(M=N) RETURN(DO_PRIMITIVE_DYADIC_BAL(FUNCTION_NAME,
       FUNCTION,FUNCTION,LEFT,RIGHT,M,CHARCHAR));
     OTHERWISE DO;
       MSGDATA='ARGUMENTS TO SCALAR DYADIC FUNCTION DISAGREE IN SHAPE';
       SIGNAL CONDITION(BADAPL);
       END;
     END; /* SELECT */
   END DO_PRIMITIVE_DYADIC_REAL;

 DO_PRIMITIVE_DYADIC_BAL_REAL: PROC(FUNCTION_NAME,FUNCTION,FUNCTIONCH,
   LEFT,RIGHT,NELS,CHARCHAR) RETURNS(PTR);
 /**********************************************************************
 *                                                                     *
 * CALLED WHEN IT IS TIME TO DO A PRIMITIVE SCALAR DYADIC FUNCTION,    *
 * AND IT HAS BEEN DETERMINED THAT BOTH THE LEFT AND RIGHT OPERANDS    *
 * HAVE THE SAME NUMBER OF ELEMENTS, AND THIS NUMBER IS NOT 1.         *
 *                                                                     *
 **********************************************************************/
   DCL FUNCTION_NAME CHAR(*);
   DCL FUNCTION ENTRY(DEC FLOAT(16),DEC FLOAT(16))
     RETURNS(DEC FLOAT(16));
   DCL FUNCTIONCH ENTRY(CHAR(*) VAR, CHAR(*) VAR)
     RETURNS(DEC FLOAT(16));
   DCL (CBP,LEFT,LRPT,PATCBP,PATRHP,RIGHT,RRPT,TMP) PTR;
   DCL (I,J,K,LCIX,LMIX,NELS,OCIX,OMIX,RCIX,RMIX) FIXED BIN;
   DCL FLOAT DEC FLOAT(16);
   DCL OTYPE CHAR(8);
   DCL CHARCHAR BIT(1);
   DCL TOSTR CHAR(256) VAR;

   IF LEFT->RH_APL->RH_APL_RANK^=RIGHT->RH_APL->RH_APL_RANK
     THEN DO;
       MSGDATA='ARGUMENTS TO '××FUNCTION_NAME××' DON''T AGREE IN SHAPE';
       SIGNAL CONDITION(BADAPL);
       END;
   DO I=1 TO LEFT->RH_APL->RH_APL_RANK;
     IF LEFT->RH_APL->RH_APL_DIM(I)^=RIGHT->RH_APL->RH_APL_DIM(I)
       THEN DO;
         MSGDATA='ARGUMENTS TO '××FUNCTION_NAME××' DIFFER IN SHAPE';
         SIGNAL CONDITION(BADAPL);
         END;
     END;
   IF LEFT->RH_APL->RH_APL_ELEN>RIGHT->RH_APL->RH_APL_ELEN
     THEN PATRHP=LEFT;
     ELSE PATRHP=RIGHT;
   PATCBP=PATRHP->RH_APL;
   CBP=CREATE_APLCB(PATCBP->RH_APL_RANK); /* DEMARC W/B SET TO 0 */
   CBP->RH_APL_SCALAR=PATCBP->RH_APL_SCALAR;
   OTYPE=TYPETAB(CBP->RH_APL_TYPE);
   J,K=1;
   DO I=1 TO CBP->RH_APL_RANK;
     CBP->RH_APL_DIM(I)=PATCBP->RH_APL_DIM(I);
     IF I<=CBP->RH_APL_DEMARC
       THEN J=J*CBP->RH_APL_DIM(I);
       ELSE K=K*CBP->RH_APL_DIM(I);
     END;
   CBP->RH_APL_RHCOUNT=J;
   CBP->RH_APL_ELCOUNT=K;
   J=K*CBP->RH_APL_ELEN;
   TMP=CREATE_VAR(J,CBP,''); /* OUTPUT DATASET */
   LRPT,RRPT=NULL;
   DO I=1 TO NELS;
     IF CHARCHAR
       THEN FLOAT=FUNCTIONCH(
         GET_EL('FORWARD',LEFT, LRPT,LCIX,LMIX),
         GET_EL('FORWARD',RIGHT,RRPT,RCIX,RMIX));
       ELSE FLOAT=FUNCTION(
         GET_SCALAR_SEQ('FORWARD',LEFT, LRPT,LCIX,LMIX),
         GET_SCALAR_SEQ('FORWARD',RIGHT,RRPT,RCIX,RMIX));
     TOSTR=CONVERT(ADDR(FLOAT),'FLOAT',8,0,OTYPE,CBP->RH_APL_ELEN,0);
     CALL PUT_EL(TOSTR,TMP,OCIX,OMIX);
     END;
   RETURN(TMP);
   END DO_PRIMITIVE_DYADIC_BAL_REAL;

 DO_PRIMITIVE_DYADIC_ENT_REAL: PROC(FUNCTION_NAME,FUNCTION);
 /**********************************************************************
 *                                                                     *
 * CALLED TO OBTAIN THE ENTRY FOR A SUBROUTINE TO HANDLE A PRIMITIVIE  *
 * SCALAR DYADIC FUNCTION.                                             *
 *                                                                     *
 **********************************************************************/
   DCL FUNCTION_NAME CHAR(*);
   DCL FUNCTION ENTRY VARIABLE;

   SELECT(FUNCTION_NAME);
     WHEN('PLUS')        FUNCTION=DO_PLUS;
     WHEN('BAR')         FUNCTION=DO_MINUS;
     WHEN('TIMES')       FUNCTION=DO_TIMES;
     WHEN('DIVIDE')      FUNCTION=DO_DIVIDE;
     WHEN('STILE')       FUNCTION=DO_RESIDUE;
     WHEN('DOWNSTILE')   FUNCTION=DO_MINIMUM;
     WHEN('UPSTILE')     FUNCTION=DO_MAXIMUM;
     WHEN('QUERY')       FUNCTION=DO_DEAL;
     WHEN('STAR')        FUNCTION=DO_POWER;
     WHEN('LOG')         FUNCTION=DO_LOG;
     WHEN('CIRCLE')      FUNCTION=DO_CIRCLE;
     WHEN('QUOTE DOT')   FUNCTION=DO_BINOMIAL;
     WHEN('AND')         FUNCTION=DO_AND;
     WHEN('OR')          FUNCTION=DO_OR;
     WHEN('NAND')        FUNCTION=DO_NAND;
     WHEN('NOR')         FUNCTION=DO_NOR;
     WHEN('LESS')        FUNCTION=DO_LESS;
     WHEN('NOT GREATER') FUNCTION=DO_NOT_GREATER;
     WHEN('EQUAL')       FUNCTION=DO_EQUAL;
     WHEN('NOT LESS')    FUNCTION=DO_NOT_LESS;
     WHEN('GREATER')     FUNCTION=DO_GREATER;
     WHEN('NOT EQUAL')   FUNCTION=DO_NOT_EQUAL;
     OTHERWISE DO;
       MSGDATA='INVALID DYADIC FUNCTION NAME='××FUNCTION_NAME;
       SIGNAL CONDITION(BADAPL);
       END;
     END; /* SELECT */
   END DO_PRIMITIVE_DYADIC_ENT_REAL;

 DO_PRIMITIVE_DYADIC_ECH_REAL: PROC(FUNCTION_NAME,FUNCTION);
 /**********************************************************************
 *                                                                     *
 * CALLED TO OBTAIN THE ENTRY FOR A SUBROUTINE TO HANDLE A PRIMITIVIE  *
 * SCALAR DYADIC FUNCTION WHEN BOTH OPERANDS WILL BE CHAR.             *
 *                                                                     *
 **********************************************************************/
   DCL FUNCTION_NAME CHAR(*);
   DCL FUNCTION ENTRY VARIABLE;

   SELECT(FUNCTION_NAME);
     WHEN('PLUS')        FUNCTION=DO_PLUS_CHAR;
     WHEN('BAR')         FUNCTION=DO_MINUS_CHAR;
     WHEN('TIMES')       FUNCTION=DO_TIMES_CHAR;
     WHEN('DIVIDE')      FUNCTION=DO_DIVIDE_CHAR;
     WHEN('STILE')       FUNCTION=DO_RESIDUE_CHAR;
     WHEN('DOWNSTILE')   FUNCTION=DO_MINIMUM_CHAR;
     WHEN('UPSTILE')     FUNCTION=DO_MAXIMUM_CHAR;
     WHEN('QUERY')       FUNCTION=DO_DEAL_CHAR;
     WHEN('STAR')        FUNCTION=DO_POWER_CHAR;
     WHEN('LOG')         FUNCTION=DO_LOG_CHAR;
     WHEN('CIRCLE')      FUNCTION=DO_CIRCLE_CHAR;
     WHEN('QUOTE DOT')   FUNCTION=DO_BINOMIAL_CHAR;
     WHEN('AND')         FUNCTION=DO_AND_CHAR;
     WHEN('OR')          FUNCTION=DO_OR_CHAR;
     WHEN('NAND')        FUNCTION=DO_NAND_CHAR;
     WHEN('NOR')         FUNCTION=DO_NOR_CHAR;
     WHEN('LESS')        FUNCTION=DO_LESS_CHAR;
     WHEN('NOT GREATER') FUNCTION=DO_NOT_GREATER_CHAR;
     WHEN('EQUAL')       FUNCTION=DO_EQUAL_CHAR;
     WHEN('NOT LESS')    FUNCTION=DO_NOT_LESS_CHAR;
     WHEN('GREATER')     FUNCTION=DO_GREATER_CHAR;
     WHEN('NOT EQUAL')   FUNCTION=DO_NOT_EQUAL_CHAR;
     OTHERWISE DO;
       MSGDATA='INVALID DYADIC FUNCTION NAME='××FUNCTION_NAME;
       SIGNAL CONDITION(BADAPL);
       END;
     END; /* SELECT */
   END DO_PRIMITIVE_DYADIC_ECH_REAL;

 DO_PRIMITIVE_DYADIC_UNBAL_REAL: PROC(SIDE,FUNCTION_NAME,FUNCTION,
   FUNCTIONCH,ARRY,VALPTR,NELS,CHARCHAR) RETURNS(PTR);
 /**********************************************************************
 *                                                                     *
 * CALLED WHEN IT IS TIME TO DO A PRIMITIVE SCALAR DYADIC FUNCTION,    *
 * AND IT HAS BEEN DETERMINED THAT ONE OF THE OPERANDS CONSISTS OF     *
 * A SINGLE ELEMENT.                                                   *
 *                                                                     *
 **********************************************************************/
   DCL SIDE CHAR(*);
   DCL FUNCTION_NAME CHAR(*);
   DCL FUNCTION ENTRY(DEC FLOAT(16),DEC FLOAT(16))
     RETURNS(DEC FLOAT(16));
   DCL FUNCTIONCH ENTRY(CHAR(*) VAR, CHAR(*) VAR)
     RETURNS(DEC FLOAT(16));
   DCL (CBP,ARRY,LRPT,PATCBP,TMP,VALPTR) PTR;
   DCL (I,J,K,LCIX,LMIX,NELS,OCIX,OMIX) FIXED BIN;
   DCL (FLOAT,VAL) DEC FLOAT(16);
   DCL VALSTR CHAR(256) VAR;
   DCL OTYPE CHAR(8);
   DCL CHARCHAR BIT(1);

   IF CHARCHAR
     THEN VALSTR=GET_EL('FORWARD',VALPTR,NULL,I,J);
     ELSE VAL=GET_SCALAR_SEQ('FORWARD',VALPTR,NULL,I,J);
   PATCBP=ARRY->RH_APL;
   CBP=CREATE_APLCB(PATCBP->RH_APL_RANK);
   CBP->RH_APL_SCALAR=PATCBP->RH_APL_SCALAR;
   OTYPE=TYPETAB(CBP->RH_APL_TYPE);
   J,K=1;
   DO I=1 TO CBP->RH_APL_RANK;
     CBP->RH_APL_DIM(I)=PATCBP->RH_APL_DIM(I);
     IF I<=CBP->RH_APL_DEMARC
       THEN J=J*CBP->RH_APL_DIM(I);
       ELSE K=K*CBP->RH_APL_DIM(I);
     END;
   CBP->RH_APL_RHCOUNT=J;
   CBP->RH_APL_ELCOUNT=K;
   J=K*CBP->RH_APL_ELEN;
   TMP=CREATE_VAR(J,CBP,''); /* OUTPUT DATASET */
   LRPT=NULL;
   DO I=1 TO NELS;
     IF SIDE='LEFT'
       THEN IF CHARCHAR
         THEN FLOAT=FUNCTIONCH(GET_EL('FORWARD',
           ARRY,LRPT,LCIX,LMIX),VALSTR);
         ELSE FLOAT=FUNCTION(GET_SCALAR_SEQ('FORWARD',
           ARRY,LRPT,LCIX,LMIX),VAL);
       ELSE IF CHARCHAR
         THEN FLOAT=FUNCTIONCH(VALSTR,GET_EL('FORWARD',
           ARRY,LRPT,LCIX,LMIX));
         ELSE FLOAT=FUNCTION(VAL,GET_SCALAR_SEQ('FORWARD',
           ARRY,LRPT,LCIX,LMIX));
     CALL PUT_EL(
       CONVERT(ADDR(FLOAT),'FLOAT',8,0,OTYPE,CBP->RH_APL_ELEN,0),
       TMP,OCIX,OMIX);
     END;
   RETURN(TMP);
   END DO_PRIMITIVE_DYADIC_UNBAL_REAL;

 DO_PRIMITIVE_MONADIC_REAL: PROC(FUNCTION_NAME,RIGHT) RETURNS(PTR);
 /**********************************************************************
 *                                                                     *
 * CALLED WHEN THE CURRENT OPERATOR IS A STANDARD APL SCALAR FUNCTION, *
 * AND IT IS MONADIC.                                                  *
 *                                                                     *
 **********************************************************************/
   DCL FUNCTION_NAME CHAR(*);
   DCL FUNCTION ENTRY VARIABLE;
   DCL (RIGHT,TMP) PTR;

   SELECT(FUNCTION_NAME);
     WHEN('PLUS')        FUNCTION=DO_CONJUGATE;
     WHEN('BAR')         FUNCTION=DO_NEGATIVE;
     WHEN('TIMES')       FUNCTION=DO_SIGNUM;
     WHEN('DIVIDE')      FUNCTION=DO_RECIPROCAL;
     WHEN('STILE')       FUNCTION=DO_MAGNITUDE;
     WHEN('DOWNSTILE')   FUNCTION=DO_FLOOR;
     WHEN('UPSTILE')     FUNCTION=DO_CEILING;
     WHEN('QUERY')       FUNCTION=DO_ROLL;
     WHEN('STAR')        FUNCTION=DO_EXPONENTIAL;
     WHEN('LOG')         FUNCTION=DO_NATURAL_LOGARITHM;
     WHEN('CIRCLE')      FUNCTION=DO_PI_TIMES;
     WHEN('QUOTE DOT')   FUNCTION=FACTORL;
     WHEN('TILDE')       FUNCTION=DO_NOT;
     OTHERWISE DO;
       MSGDATA='INVALID MONADIC FUNCTION NAME='××FUNCTION_NAME;
       SIGNAL CONDITION(BADAPL);
       END;
     END; /* SELECT */
   RETURN(DO_PRIMITIVE_MONADIC_SUB(FUNCTION_NAME,FUNCTION,RIGHT,
     EL_CNT(RIGHT->RH_APL)));
   END DO_PRIMITIVE_MONADIC_REAL;

 DO_PRIMITIVE_MONADIC_SUB_REAL: PROC(FUNCTION_NAME,FUNCTION,RIGHT,NELS)
   RETURNS(PTR);
 /**********************************************************************
 *                                                                     *
 * CALLED WHEN IT IS TIME TO DO A PRIMITIVE SCALAR MONADIC FUNCTION.   *
 *                                                                     *
 **********************************************************************/
   DCL FUNCTION_NAME CHAR(*);
   DCL FUNCTION ENTRY(DEC FLOAT(16))
     RETURNS(DEC FLOAT(16));
   DCL (CBP,RIGHT,PATCBP,RRPT,TMP) PTR;
   DCL (I,J,K,RCIX,RMIX,NELS,OCIX,OMIX) FIXED BIN;
   DCL FLOAT DEC FLOAT(16);
   DCL OTYPE CHAR(8);

   PATCBP=RIGHT->RH_APL;
   CBP=CREATE_APLCB(PATCBP->RH_APL_RANK);
   CBP->RH_APL_SCALAR=PATCBP->RH_APL_SCALAR;
   OTYPE=TYPETAB(CBP->RH_APL_TYPE);
   J,K=1;
   DO I=1 TO CBP->RH_APL_RANK;
     CBP->RH_APL_DIM(I)=PATCBP->RH_APL_DIM(I);
     IF I<=CBP->RH_APL_DEMARC
       THEN J=J*CBP->RH_APL_DIM(I);
       ELSE K=K*CBP->RH_APL_DIM(I);
     END;
   CBP->RH_APL_RHCOUNT=J;
   CBP->RH_APL_ELCOUNT=K;
   K=K*CBP->RH_APL_ELEN;
   TMP=CREATE_VAR(K,CBP,''); /* OUTPUT DATASET */
   RRPT=NULL;
   DO I=1 TO NELS;
     FLOAT=FUNCTION(GET_SCALAR_SEQ('FORWARD',RIGHT,RRPT,RCIX,RMIX));
     CALL PUT_EL(
       CONVERT(ADDR(FLOAT),'FLOAT',8,0,OTYPE,
         CBP->RH_APL_ELEN,0),
       TMP,OCIX,OMIX);
     END;
   RETURN(TMP);
   END DO_PRIMITIVE_MONADIC_SUB_REAL;

 DO_RECIPROCAL_REAL: PROC(RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * STANDARD APL SCALAR MONADIC FUNCTION RECIPROCAL.                    *
 *                                                                     *
 **********************************************************************/
   DCL RIGHT DEC FLOAT(16);

   RETURN(1/RIGHT);
   END DO_RECIPROCAL_REAL;

 DO_RESIDUE_REAL: PROC(LEFT,RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * STANDARD APL SCALAR DYADIC FUNCTION RESIDUE.                        *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT) DEC FLOAT(16);

   RETURN(RIGHT-LEFT*FLOOR(RIGHT/(LEFT+(LEFT=0))));
   END DO_RESIDUE_REAL;

 DO_RESIDUE_CHAR_REAL: PROC(LEFT,RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * STANDARD APL SCALAR DYADIC FUNCTION RESIDUE.                        *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT) DEC FLOAT(16);

   RETURN(DO_RESIDUE(LEFT,RIGHT));
   END DO_RESIDUE_CHAR_REAL;

 DO_ROLL_REAL: PROC(RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * STANDARD APL MIXED MONADIC FUNCTION ROLL.                           *
 *                                                                     *
 **********************************************************************/
   DCL (RIGHT,RET) DEC FLOAT(16);

   IF RIGHT<=0 × MOD(RIGHT,1)^=0
     THEN DO;
       MSGDATA='ROLL DOMAIN IS LIMITED TO POSITIVE INTEGERS';
       SIGNAL CONDITION(BADAPL);
       END;
   IF RIGHT=1
     THEN RETURN(1);
   RET=RND(-1)*RIGHT;
   RETURN(RET-MOD(RET,1)+1);
   END DO_ROLL_REAL;

 DO_SIGNUM_REAL: PROC(RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * STANDARD APL SCALAR MONADIC FUNCTION SIGNUM.                     *
 *                                                                     *
 **********************************************************************/
   DCL RIGHT DEC FLOAT(16);

   RETURN((RIGHT>0)-(RIGHT<0));
   END DO_SIGNUM_REAL;

 DO_TIMES_REAL: PROC(LEFT,RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * STANDARD APL SCALAR FUNCTION TIMES.                                 *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT) DEC FLOAT(16);

   NOUNDERFLOW:RETURN(LEFT*RIGHT);
   END DO_TIMES_REAL;

 DO_TIMES_CHAR_REAL: PROC(LEFT,RIGHT) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * STANDARD APL SCALAR FUNCTION TIMES.                                 *
 *                                                                     *
 **********************************************************************/
   DCL (LEFT,RIGHT) CHAR(*) VAR;

   RETURN(DO_TIMES(LEFT,RIGHT));
   END DO_TIMES_CHAR_REAL;

 EL_CNT_REAL: PROC(CBP) RETURNS(FIXED BIN(31,0));
 /**********************************************************************
 *                                                                     *
 * CALLED TO DETERMINE COUNT OF ELEMENTS IN VARIABLE.                  *
 *                                                                     *
 **********************************************************************/
   DCL CBP PTR;
   DCL (I,J) FIXED BIN;

   IF CBP->RH_APL_RANK=0
     THEN RETURN(0);
   J=1;
   DO I=1 TO CBP->RH_APL_RANK;
     J=J*CBP->RH_APL_DIM(I);
     END;
   RETURN(J);
   END EL_CNT_REAL;

 GET_INTEGER_SEQ_REAL: PROC(FB,RHP,RPT,CIX,MIX)
   RETURNS(FIXED BIN(31,0));
 /**********************************************************************
 *                                                                     *
 * CALLED TO OBTAIN THE INTEGER VALUE (FIXED BIN(31)) FOR THE NEXT     *
 * SEQUENTIAL ELEMENT IN THE VARIABLE POINTED TO BY RHP. RPT SHOULD BE *
 * INITIALIZED TO NULL BEFORE INVOKING THIS SUBROUTINE.  CIX AND MIX   *
 * DO NOT HAVE TO BE INITIALIZED.  RPT, CIX, AND MIX SHOULD NOT BE     *
 * CHANGED FROM ONE INVOCATION TO THE NEXT.  RPT WILL BE SET TO NULL   *
 * WHEN THERE ARE NO MORE ELEMENTS TO RETURN.                          *
 *                                                                     *
 * FB SHOULD BE SET TO 'FORWARD' OR 'BACKWARD' TO INDICATE THE         *
 * DIRECTION OF SEQUENTIAL PROCESSING.                                 *
 *                                                                     *
 **********************************************************************/
   DCL FB CHAR(*);
   DCL (RHP,RPT) PTR;
   DCL (CIX,MIX) FIXED BIN;
   DCL RET FIXED BIN(31,0),
       RETSTR CHAR(4) BASED(ADDR(RET));
   DCL STR CHAR(256) VAR;

   STR=GET_EL(FB,RHP,RPT,CIX,MIX);
   IF LENGTH(STR)=0
     THEN DO;
       RPT=NULL;
       RETURN(MISSING);
       END;
   RETSTR=CONVERT(PTROUT(PTRIN(ADDR(STR))+2),
     TYPETAB(RHP->RH_APL->RH_APL_TYPE),LENGTH(STR),0,
     'FIXED',4,0);
   RETURN(RET);
   END GET_INTEGER_SEQ_REAL;

 GET_LEFT_REAL: PROC RETURNS(PTR) RECURSIVE;
 /**********************************************************************
 *                                                                     *
 * CALLED TO OBTAIN THE LEFT OPERAND, IF ANY, FOR A GIVEN OPERATOR.    *
 *                                                                     *
 **********************************************************************/

   IF PRIOR_TOKEN=NULL
     THEN RETURN(NULL);
   SELECT;
     WHEN(PRIOR_TOKEN->TYPE>0) SELECT(SYMBOL_NAMES(PRIOR_TOKEN->TYPE));
       WHEN('LEFT PAREN') RETURN(NULL); /* NO LEFT OPERAND */
       WHEN('RIGHT PAREN') DO;
         CURTOK=PRIOR_TOKEN->PRIOR_TOKEN;
         CALL MAIN_LOOP(1); /* WILL PUSH OPERAND ON STACK */
         CALL PAREN_CHECK; /* CHECK FOR UNBALANCED PARENS */
         END;
       OTHERWISE RETURN(NULL); /* NO LEFT OPERAND */
       END; /* SELECT */
     WHEN(PRIOR_TOKEN->TYPE=NUMERIC_CONSTANT) DO;
       CURTOK=PRIOR_TOKEN;
       CALL DO_CONSTANT_OPERAND;
       END;
     WHEN(PRIOR_TOKEN->TYPE=OPERAND) DO;
       CURTOK=PRIOR_TOKEN;
       CALL DO_OPERAND;
       END;
     WHEN(PRIOR_TOKEN->TYPE=QUOTED_STRING) DO;
       CURTOK=PRIOR_TOKEN;
       CALL DO_LITERAL_OPERAND;
       END;
     OTHERWISE RETURN(NULL); /* I DON'T KNOW WHAT IT IS */
     END; /* SELECT */

   /* AT THIS POINT, THE LEFT OPERAND SHOULD BE AT THE TOP OF STACK */
   RETURN(POP_OPERAND(OPERAND_STACK,OPERAND_COUNT));
   END GET_LEFT_REAL;

 GET_SCALAR_SEQ_REAL: PROC(FB,RHP,RPT,CIX,MIX)
   RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * CALLED TO OBTAIN THE NUMERIC VALUE (DEC FLOAT(16)) FOR THE NEXT     *
 * SEQUENTIAL ELEMENT IN THE VARIABLE POINTED TO BY RHP. RPT SHOULD BE *
 * INITIALIZED TO NULL BEFORE INVOKING THIS SUBROUTINE.  CIX AND MIX   *
 * DO NOT HAVE TO BE INITIALIZED.  RPT, CIX, AND MIX SHOULD NOT BE     *
 * CHANGED FROM ONE INVOCATION TO THE NEXT.  RPT WILL BE SET TO NULL   *
 * WHEN THERE ARE NO MORE ELEMENTS TO RETURN.                          *
 *                                                                     *
 **********************************************************************/
   DCL FB CHAR(*);
   DCL (RHP,RPT) PTR;
   DCL (CIX,MIX) FIXED BIN;
   DCL RET DEC FLOAT(16) BASED(RETPTR);
   DCL (STR,RETSTR) CHAR(256) VAR;

   STR=GET_EL(FB,RHP,RPT,CIX,MIX);
   IF LENGTH(STR)=0
     THEN DO;
       RPT=NULL;
       RETURN(MISSING);
       END;
   RETSTR=CONVERT(PTROUT(PTRIN(ADDR(STR))+2),
     TYPETAB(RHP->RH_APL->RH_APL_TYPE),LENGTH(STR),0,
     'FLOAT',8,0);
   RETURN(PTROUT(PTRIN(ADDR(RETSTR))+2)->RET);
   END GET_SCALAR_SEQ_REAL;

 RND_REAL: PROC(OP) RETURNS(DEC FLOAT(16));
   DCL (OP,RET) DEC FLOAT(16);
   DCL INT FIXED BIN(31,0);
   DCL PI DEC FLOAT(16) STATIC INIT(3.141592654);

   IF OP<0
     THEN DO;
       RET=SUBSTR(TIME,7);
       OP=RET/1000;
       END;
   RET,INT=(PI+OP)**8;
   RET=RET-INT;
   RETURN(RET);
   END RND_REAL;

   END ABE061B;
