*PROCESS CS(60);
  /* PSTOPO
0*$.HE GENERALIZED UTILITIES - PSTOPO
0*$.HE PSTOPO - COPY SEQUENTIAL TO PDS
0*$.PL 55
0*$.PN 0
0*$.PA
0*$.SS
0*$.NF
0*$03/17/82
0*$AUTHOR:  T. SMITH
0*$SOURCE MODULE NAME:  PSTOPO
0*$DOCUMENTATION ID:  0*$
0*$.FI L
0*$.SP 5
0*$THIS UTILITY CAN BE USED TO COPY A SEQUENTIAL DATA SET TO A
0*$PARTITIONED DATA SET.  CALL FORMAT IS AS FOLLOWS:
0*$.IN 5
0*$.SP 1
0*$.NF
0*$// EXEC PGM=PSTOPO,PARM='/73'
0*$//SYSPRINT DD SYSOUT=*
0*$//IN DD DSN=SEQNAME,DISP=SHR
0*$//OUT DD DSN=&PDS,DISP=(NEW,PASS),
0*$// UNIT=DISK,SPACE=(TRK,(1,1,5)),
0*$// DCB=(LRECL=80,BLKSIZE=19040,RECFM=FB)
0*$.SP 1
0*$.IN 0
0*$.FI L
0*$THE IN DATA SET CAN BE EITHER TAPE OR DISK.  YOU MAY OPTIONALLY
0*$SPECIFY DCB PARAMETERS FOR THE OUT DATA SET, AND THEY MAY BE
0*$DIFFERENT FROM THE INPUT DATA SET.  IF YOU DON'T SPECIFY DCB
0*$PARAMETERS, THOSE FROM THE INPUT DATASET WILL BE USED.
0*$.SP 1
0*$THE OPTIONAL PARM FIELD MUST CONTAIN A NUMBER INDICATING WHERE IN
0*$EACH INPUT RECORD THE MEMBER NAME IS STORED.  IF PARM IS NOT
0*$SPECIFIED, PSTOPO ASSUMES THE MEMBER NAME IS STORED IN COLUMNS
0*$1-8 OF EACH INPUT RECORD.  PSTOPO WILL SET THE COLUMNS CONTAINING
0*$THE MEMBER NAME TO BLANKS BEFORE WRITING THE OUTPUT RECORD.
  */
  PSTOPO:PROC(PARM) OPTIONS(MAIN);
   % INCLUDE DCB;
   % INCLUDE DCBQSAM;
   DCL PARM CHAR(100) VAR;
   DFT RANGE(*) FIXED BIN VALUE(FIXED BIN(31,0));
   DCL BUFPTR PTR STATIC,BUFPADJ FIXED BIN(31,0) DEF BUFPTR;
   DCL BCNTSAV FIXED BIN(15,0) STATIC INIT(0);
   DCL BUFFER CHAR(*) VARYING CONTROLLED;
   DCL 1 DW UNALIGNED BASED(DWPTR),
     2 DWLEN FIXED BIN(15,0),
     2 DWZRO FIXED BIN(15,0);
   DCL (BDWPTR,RDWPTR) PTR;
   DCL OUT FILE RECORD OUTPUT;
   DCL PDSPTR PTR;
   DCL 1 STOWDATA,
     2 MEMNAM CHAR(8) INIT(''),
     2 TTR BIT(24) INIT('0'B),
     2 C BIT(8) INIT('0'B);
   DCL NEWNAM CHAR(8) INIT(' ');
   DCL DDNAME CHAR(8) STATIC INIT('OUT');
   DCL (PDSREC,INREC) CHAR(*) VARYING CONTROLLED;
   DCL SAVBLKSI FIXED BIN(15,0);
   DCL 1 PDSDCB UNALIGNED BASED(PDSPTR),
     2 PDSPAD1 CHAR(36),
     2 PDSRECFM BIT(8),
     2 PDSPAD2 CHAR(25),
     2 PDSBLKSI FIXED BIN(15,0),
     2 PDSPAD3 CHAR(18),
     2 PDSLRECL FIXED BIN(15,0);
   DCL RECFM BIT(2),
       V BIT(2) STATIC INIT('01'B);
   DCL PTRIN ENTRY(PTR)
     RETURNS(FIXED BIN(31,0));
   DCL PTROUT ENTRY(FIXED BIN(31,0))
     RETURNS(PTR);
   DCL FINDDCB ENTRY(CHAR(8))
     RETURNS(PTR);
   DCL (SYSWRIT,SYSCLOS,SYSSTOW,SYSFIND,SYSDCBP,SYSOPEN,SYSREAD) ENTRY;
   DCL SYSJFCB ENTRY;
   DCL JFCBAREA CHAR(176);
   %INCLUDE JFCB;
   IF PARM^=''
     THEN IP=PARM;
     ELSE IP=1;
   OPEN FILE(IN) RECORD INPUT;
   DCBPTR=FINDDCB('IN');
   L=DCBLRECL;
   ALLOCATE INREC CHAR(L);
   CALL SYSDCBP(PDSPTR,DDNAME);
   JFCBPTR=ADDR(JFCBAREA);
   CALL SYSJFCB(DDNAME,JFCBPTR);
   PDSRECFM=JFCRECFM;
   IF SUBSTR(PDSRECFM,1,2)='00'B
     THEN SUBSTR(PDSRECFM,1,2)=SUBSTR(DCBRECFM,1,2);
   RECFM=SUBSTR(PDSRECFM,1,2);
   PDSLRECL=JFCLRECL;
   IF PDSLRECL=0
     THEN PDSLRECL=DCBLRECL;
   PDSBLKSI=JFCBLKSI;
   IF PDSBLKSI=0
     THEN PDSBLKSI=DCBBLKSI;
   CALL SYSOPEN(PDSPTR,'OUTPUT');
   L=PDSLRECL;
   IF RECFM=V
     THEN L=L-4;
   ALLOCATE PDSREC CHAR(L);
   ALLOCATE BUFFER CHAR(PDSBLKSI);
   SAVBLKSI=PDSBLKSI;
   IF RECFM=V
     THEN DO;
       BUFFER='    '; /* RESERVE STORAGE FOR A BDW */
       BDWPTR=PTROUT(PTRIN(ADDR(BUFFER))+2); /* SKIP OF 2-BYTE LEN */
       BDWPTR->DWZRO=0;
       END;
     ELSE BUFFER='';
   ON ENDFILE(IN) GO TO EOJ;
   DO FOREVER=1 REPEAT FOREVER;
     READ FILE(IN) INTO(INREC);
     IF LENGTH(INREC)<IP
       THEN NEWNAM='';
       ELSE DO;
         NEWNAM=SUBSTR(INREC,IP);
         SUBSTR(INREC,IP,MIN(8,LENGTH(INREC)-IP+1))='';
         END;
     PDSREC=INREC;
     IF LENGTH(PDSREC)<L & RECFM^=V
       THEN PDSREC=PDSREC××REPEAT(' ',L-LENGTH(PDSREC)-1);
     IF MEMNAM^=NEWNAM
       THEN DO;
         IF MEMNAM ^= ''
           THEN CALL ENDMEM;
         MEMNAM=NEWNAM;
         END;
     CALL PUTREC(PDSREC);
     END;
   SIGNAL CONDITION(SYSEOD);
 EOJ:;
   CALL ENDMEM;
   CALL SYSCLOS(PDSPTR);
 ENDMEM: PROC;
   IF LENGTH(BUFFER)>4 & RECFM=V
     THEN DO;
       BDWPTR->DWLEN=LENGTH(BUFFER);
       CALL SYSWRIT(PDSPTR,BUFFER);
       BUFFER='    ';
       BDWPTR->DWZRO=0;
       END;
     ELSE IF LENGTH(BUFFER)>0 & RECFM^=V
       THEN DO;
         PDSBLKSI=LENGTH(BUFFER);
         CALL SYSWRIT(PDSPTR,BUFFER);
         PDSBLKSI=SAVBLKSI;
         BUFFER='';
         END;
   CALL SYSSTOW(PDSPTR,STOWDATA,'A',RETCODE);
   IF RETCODE^=0
     THEN DO;
       PUT SKIP LIST('ERROR - RETURN CODE FROM STOW =',RETCODE);
       SIGNAL ERROR;
       END;
   END ENDMEM;
 PUTREC:PROC(REC);
   DCL REC CHAR(*) VARYING;
   DCL (I,J,K,L,M,N) FIXED BIN(31,0);
   L=LENGTH(REC);
   IF RECFM=V
     THEN L=L+4; /* L= REQUIRED BUFFER STORAGE FOR NEW RECORD */
   IF LENGTH(BUFFER)+L > PDSBLKSI
     THEN DO; /* TIME TO WRITE A FULL BUFFER */
       IF RECFM=V
         THEN BDWPTR->DWLEN=LENGTH(BUFFER);
       CALL SYSWRIT(PDSPTR,BUFFER);
       IF RECFM=V
         THEN DO;
           BUFFER='    ';
           BDWPTR->DWZRO=0;
           END;
         ELSE BUFFER='';
       END;
   IF RECFM=V
     THEN DO;
       RDWPTR=PTROUT(PTRIN(ADDR(BUFFER))+2+LENGTH(BUFFER));
       BUFFER=BUFFER××'    '; /* 4 BLANKS FOR RDW */
       RDWPTR->DWLEN=L;
       RDWPTR->DWZRO=0;
       END;
   BUFFER=BUFFER××REC;
   END PUTREC;
   END;
