 /* POLISH */
 /*
0*$.HE GENERALIZED SUBROUTINES - POLISH
0*$.HE CONVERT EXPRESSION TO POLISH NOTATION
0*$.PL 55
0*$.PN 0
0*$.PA
0*$.SS
0*$.NF
0*$06/21/82
0*$AUTHOR:  T. SMITH
0*$SOURCE MODULE NAME: POLISH
0*$DOCUMENTATION ID: 0*$
0*$.FI L
0*$.SP 5
0*$THIS SUBROUTINE MAY BE USED TO CONVERT AN EXPRESSION TO POLISH
0*$NOTATION.  THE FOLLOWING THREE EXPRESSIONS FOR EXAMPLE:
0*$.SP 1
0*$.IN 5
0*$.NF
0*$A+B
0*$A+B*C
0*$U+V*(X+Y)+Z
0*$.IN 0
0*$.SP 1
0*$WILL BE CONVERTED TO -
0*$.SP 1
0*$.IN 5
0*$A,B,+
0*$A,B,C,*,+
0*$U,V,(X,Y,+),*,+,Z,+
0*$.FI L
0*$.IN 0
0*$.SP 1
0*$SEE ALSO DOCUMENTATION ON THE SCANNER AND EVAL SUBROUTINES.  FOR
0*$AN EXAMPLE OF USE, SEE THE SOURCE PROGRAM FOR THE CALC TSO
0*$COMMAND PROCESSOR.
0*$.SP 1
0*$CALL FORMAT IS - NEWHDR=POLISH(TOKHDR,PRECEDENCE,MSG,LSTPTR);
0*$.SP 1
0*$WHERE -
0*$.SP 1
0*$NEWHDR IS A POINTER VARIABLE TO BE SET TO POINT TO THE QUEUE OF
0*$TOKENS REPRESENTING THE EXPRESSION CONVERTED TO POLISH NOTATION.
0*$ELEMENTS OF THIS QUEUE HAVE THE FOLLOWING FORMAT (SEE ALSO
0*$DOCUMENTATION ON SUBROUTINE SCANNER, WHICH IS USED TO TOKENIZE
0*$A STRING OF TEXT):
0*$.SP 1
0*$.IN 5
0*$.NF
0*$DCL 1 TOKEN BASED(TOKPTR),
0*$  2 PRIOR_TOKEN PTR,
0*$    ** PTR TO THE PREVIOUS TOKEN IN THE QUEUE POINTED TO BY **
0*$    ** NEWHDR, EXCEPT THAT IF THIS IS THE FIRST TOKEN IN THE**
0*$    ** QUEUE, IT WILL CONTAIN THE ADDR OF THE LAST TOKEN IN **
0*$    ** THE QUEUE.                                           **
0*$  2 NEXT_TOKEN PTR,
0*$    ** PTR TO THE NEXT TOKEN IN THE QUEUE POINTED TO BY     **
0*$    ** NEWHDR.  WILL BE NULL IN THE LAST TOKEN IN QUEUE.    **
0*$  2 ELIX FIXED BIN(15,0);
0*$    ** SCANIX VALUE AFTER THIS TOKEN WAS ENCOUNTERED **
0*$  2 TYPE FIXED BIN(15,0),
0*$    ** 0=OPERAND, 1=OPERATOR, 2=KEYWORD, 3=SPCHAR **
0*$    ** 4=QUOTED STRING, 5=NUMERIC CONSTANT        **
0*$    ** 6=NO MORE TOKENS (NOT USED IN POLISH QUEUE)**
0*$    ** 7=OTHER                                    **
0*$    ** 8=OPERAND IDENTIFIED AS FUNCTION REFERENCE **
0*$    ** 10=KEYWORD IDENTIFIED AS FUNCTION REFERENCE**
0*$    ** 11=HEXADECIMAL CONSTANT                    **
0*$  2 SUBTYPE FIXED BIN(15,0),
0*$    ** IF TYPE=OPERATOR,KEYWORD,SPCHAR, SUBTYPE WILL CONTAIN **
0*$    ** THE INDEX TO OPERATORS,KEYWORDS,OR SPCHARS TO THE     **
0*$    ** APPROPRIATE ENTRY.  SEE ALSO DOCUMENTATION FOR THE    **
0*$    ** PRECEDENCE PARAMETER TO THE POLISH SUBROUTINE.        **
0*$  2 TOKSTR CHAR(256) VAR;
0*$    ** CONTAINS TOKEN STRING FROM CMDDATA.  IN THE CASE OF A **
0*$    ** QUOTED STRING, THE SURROUNDING QUOTES WILL HAVE BEEN  **
0*$    ** REMOVED, AND ANY CONTAINED DOUBLE QUOTES WILL HAVE    **
0*$    ** BEEN REDUCED TO A SINGLE QUOTE.                       **
0*$.FI L
0*$.SP 1
0*$.IN 0
0*$TOKHDR IS THE HEAD POINTER TO THE QUEUE OF TOKENS REPRESENTING
0*$THE EXPRESSION TO BE CONVERTED.  ELEMENTS OF THIS QUEUE HAVE THE
0*$STRUCTURE DESCRIBED ABOVE.
0*$.SP 1
0*$PRECEDENCE IS DECLARED 'PRECEDENCE(2,*) FIXED BIN(15,0)', AND SHOULD
0*$BE SET BY THE CALLER TO THE PRECEDENCE PRIORITY OF EACH OPERATOR.
0*$THE SECOND DIMENSION OF PRECEDENCE SHOULD EQUAL THE NUMBER OF
0*$POSSIBLE OPERATORS.  (IN THE DISCUSSION WHICH FOLLOWS, NOTE THAT IF
0*$TYPE=OPERATOR, SUBTYPE IS A NUMBER IDENTIFYING WHICH OPERATOR).
0*$THE ABSOLUTE VALUE OF PRECEDENCE(1,SUBTYPE) INDICATES THE
0*$PRECEDENCE OF THE OPERATOR WHEN IT IS USED DYADICALLY (AS AN
0*$INFIX OPERATOR).  IF PRECEDENCE(1,SUBTYPE) IS GREATER THAN ZERO,
0*$IT INDICATES THAT OPERATORS AT THAT PRECEDENCE LEVEL ARE TO BE
0*$PROCESSED LEFT-TO-RIGHT.  IF PRECEDENCE(1,SUBTYPE) IS LESS THAN
0*$ZERO, IT INDICATES THAT OPERATORS AT THAT PRECEDENCE LEVEL ARE TO
0*$BE PROCESSED RIGHT-TO-LEFT. IF PRECEDENCE(1,SUBTYPE)=0 THEN THAT
0*$OPERATOR CANNOT BE USED DYADICALLY.
0*$.SP 1
0*$PRECEDENCE(2,SUBTYPE) INDICATES THE PRECEDENCE OF THE OPERATOR
0*$WHEN IT IS USED MONADICALLY (AS A PREFIX OPERATOR) IF
0*$PRECEDENCE(2,SUBTYPE) IS GREATER THAN ZERO, AND INDICATES THE
0*$OPERATOR IS TO RIGHT-ASSOCIATE ONLY.  TO BETTER UNDERSTAND THE
0*$DIFFERENCE, CONSIDER THE TWO EXPRESSIONS A**B**3+4 AND A#B#3+4.
0*$IN THE FIRST CASE, YOU WOULD LIKE IT TO EVALUATE EQUIVALENT TO
0*$THE PARENTHESIZED EXPRESSION ((A**(B**3)+4)), AND TO (A#(B#(3+4)))
0*$IN THE SECOND CASE.  IF AN OPERATOR IS NOT TO BE USED MONADICALLY,
0*$OR IS NOT TO RIGHT-ASSOCIATE ONLY, SET PRECEDENCE(2,SUBTYPE)
0*$TO 0.  IF AN OPERATOR IS DISCOVERED TO BE USED MONADICALLY,
0*$SUBROUTINE POLISH WILL ADD HBOUND(PRECEDENCE,2) TO THE SUBTYPE FIELD
0*$FOR THAT OPERATOR.
0*$.SP 1
0*$MSG IS DECLARED 'CHAR(*) VAR', AND IF POLISH ENCOUNTERS AN ERROR
0*$DURING CONVERSION TO POLISH NOTATION, THIS VARIABLE WILL BE SET
0*$TO AN APPROPRIATE ERROR MESSAGE.  OTHERWISE IT WILL BE SET TO NULL.
0*$.SP 1
0*$LSTPTR IS A PTR SET BY POLISH TO THE NEXT TOKEN AFTER THE LAST
0*$ONE IDENTIFIED AS PART OF THE EXPRESSION TO BE CONVERTED.
0*$.SP 1
0*$AS NOTED ABOVE, POLISH WILL IDENTIFY FUNCTION REFERENCES, AND
0*$'SIN(A+B)' FOR EXAMPLE, WOULD BE CONVERTED TO '(A B +) SIN'.
0*$POLISH WILL ALSO RECOGNIZE FUNCTION REFERENCES HAVING MULTIPLE
0*$PARAMETERS.  'MOD(3,2)' FOR EXAMPLE, WILL BE CONVERTED TO
0*$'( 2 , 3 ) MOD'.
0*$.SP 1
0*$NOTE ALSO THAT FUNCTION AND VARIABLE NAMES CAN BE QUALIFIED.
0*$THAT IS, THEY MAY CONSIST OF A SERIES OF ONE OR MORE
0*$CONVENTIONAL NAMES (FIRST CHARACTER ALPHA, SUBSEQUENT CHARACTERS
0*$ALPHAMERIC) SEPARATED FROM EACH OTHER BY PERIODS (E.G. A.B.C).
0*$.SP 1
0*$NOTE: IF AN EXPRESSION OR SUBEXPRESSION IS ENCOUNTERED OF THE
0*$FORM OP1 RELOP OP2, WHERE RELOP IS ONE OF THE RELATIONALS
0*$^>, >=, ^=, <=, ^<, <, =, >, AND ONE OR BOTH OF THE OPERATORS
0*$IS A QUOTED STRING, POLISH WILL BUMP THE OPERATOR SUBTYPE BY THE
0*$INDEX OF THE LAST OPERATOR IN THE OPERATOR TABLE.
 */
 POLISH:  PROC(TOKHDR,PRECEDENCE,MSG,LSTPTR) RETURNS(PTR) RECURSIVE
   RECURSIVE OPTIONS(REENTRANT);
   DFT RANGE(*) FIXED BIN VALUE(FIXED BIN(31,0));
   DCL (NULL,ABS) BUILTIN;
   DCL (TOKHDR,LSTPTR) PTR;
   DCL PRECEDENCE(2,*) FIXED BIN(15,0);
   DCL MSG CHAR(*) VAR;
   DCL OPERAND          INIT(0) FIXED STATIC;
   DCL OPERATOR         INIT(1) FIXED STATIC;
   DCL KEYWORD          INIT(2) FIXED STATIC;
   DCL TYPE_SPCHAR      INIT(3) FIXED STATIC;
   DCL QUOTED_STRING    INIT(4) FIXED STATIC;
   DCL NUMERIC_CONSTANT INIT(5) FIXED STATIC;
   DCL NO_MORE_TOKENS   INIT(6) FIXED STATIC;
   DCL OTHER            INIT(7) FIXED STATIC;
   DCL 1 TOKEN BASED(TOKPTR),
     2 PRIOR_TOKEN PTR,
       /* NOTE THAT DURING INTERNAL PROCESSING THIS FIELD CONTAINS THE
       ADDR OF THE LAST TOKEN ELEMENT IN A SEGMENT. */
     2 NEXT_TOKEN PTR,
     2 ELIX FIXED BIN(15,0),
     2 TYPE FIXED BIN(15,0),
     2 SUBTYPE FIXED BIN(15,0),
     2 TOKSTR CHAR(256) VAR;
   DCL (NEWHDR,CURTOK) PTR;
   DCL PTOP FIXED BIN(15,0);
   NEWHDR,CURTOK=NULL;
   MSG='';
   IF TOKHDR=NULL
     THEN RETURN(NULL); /* GET OUT IF NO INPUT EXPRESSION */
   TOKPTR,LSTPTR=TOKHDR;
   IF TYPE=NO_MORE_TOKENS
     THEN RETURN(NULL); /* SAME REASON */
   PTOP=0;
   DO I=1 TO HBOUND(PRECEDENCE,2);
     PTOP=MAX(PTOP,ABS(PRECEDENCE(1,I)),PRECEDENCE(2,I));
     END;
   NEWHDR=POLE(PTOP); /* GO CONVERT TO POLISH */
   IF MSG^='' /* FREE EVERYTHING IF ERROR IS FOUND */
     THEN DO TOKPTR=NEWHDR REPEAT NEWHDR WHILE(TOKPTR^=NULL);
       NEWHDR=NEXT_TOKEN;
       FREE TOKEN;
       END;
   LSTPTR=TOKPTR;
   RETURN(NEWHDR);
 COPYTOK: PROC(PPTR) RETURNS(PTR);
 /**********************************************************************
 * CALLED TO MAKE A COPY OF A TOKEN STRUCTURE.                         *
 **********************************************************************/
   DCL (PPTR,NEXT) PTR;
   ALLOCATE TOKEN SET(NEXT); /* ALLOCATE FOR COPY */
   NEXT->TOKEN=PPTR->TOKEN;
   NEXT->NEXT_TOKEN=NULL;
   NEXT->PRIOR_TOKEN=NEXT;
   RETURN(NEXT);
   END COPYTOK;
 QUEUE:  PROC(PTRA,PTRB) RETURNS(PTR);
 /**********************************************************************
 * CALLED TO JOIN TWO STRINGS OF TOKENS INTO A SINGLE STRING           *
 **********************************************************************/
   DCL (PTRA,PTRB,SAVE) PTR;
   IF PTRA=NULL
     THEN RETURN(PTRB);
   IF PTRB=NULL
     THEN RETURN(PTRA);
   SAVE=PTRA->PRIOR_TOKEN;
   PTRA->PRIOR_TOKEN=PTRB->PRIOR_TOKEN;
   SAVE->NEXT_TOKEN=PTRB;
   PTRB->PRIOR_TOKEN=SAVE;
   RETURN(PTRA);
   END QUEUE;
 POLE: PROC(OPLVL) RETURNS(PTR) RECURSIVE;
 /**********************************************************************
 * CALLED TO CONVERT AN EXPRESSION TO POLISH NOTATION.                 *
 * THE SOLE PARAMETER IS THE OPERATOR PRECEDENCE LEVEL.  THE RETURNED  *
 * VALUE WILL BE A POINTER TO THE LIST OF TOKEN STRUCTURES             *
 * DESCRIBING THE POLISH EXPRESSION, OR NULL IF NO EXPRESSION IS       *
 * FOUND.                                                              *
 **********************************************************************/
   DCL (OPLVL,PRLVL) FIXED BIN(15,0);
   DCL (TERMPTR,OPTOKPTR,TERM2PTR) PTR;
   DCL (I,J,K) FIXED BIN(15,0);
   DCL SW BIT(1);
   IF TYPE=NO_MORE_TOKENS
     THEN RETURN(NULL);
   IF OPLVL=0
     THEN RETURN(GET_OPERAND); /* HAS TO BE LOOKING FOR AN OPERAND */
   /* FOLLOWING IMPLEMENTATION TO MAKE CHECKER/OPT WORK CONSISTENTLY */
   SW=(TYPE^=OPERATOR);
   IF ^SW
     THEN SW=SW × (OPLVL>PRECEDENCE(2,SUBTYPE));
   IF SW
 /* WAS AS FOLLOWS, BUT CHECKER COULDN'T HANDLE IT
   IF TYPE^=OPERATOR × (TYPE=OPERATOR & OPLVL>PRECEDENCE(2,SUBTYPE))
 */
     THEN TERMPTR=POLE(OPLVL-1); /* GO FIND FIRST TERM */
     ELSE DO; /* TIME TO PROCESS PREFIX OPERATOR */
       IF PRECEDENCE(2,SUBTYPE)=0
         THEN DO;
           MSG='INFIX OPERATOR FOUND OUT OF PLACE';
           RETURN(NULL);
           END;
       PRLVL=PRECEDENCE(2,SUBTYPE);
       SUBTYPE=SUBTYPE+HBOUND(PRECEDENCE,2);
       OPTOKPTR=COPYTOK(TOKPTR); /* GO COPY OPERATOR TOKEN */
       TOKPTR=NEXT_TOKEN;
       TERMPTR=POLE(PRLVL);
       IF TERMPTR=NULL
         THEN DO;
           MSG='PREFIX OPERAND EXPECTED BUT NOT FOUND';
           FREE OPTOKPTR->TOKEN;
           TERMPTR=NULL;
           END;
         ELSE TERMPTR=QUEUE(TERMPTR,OPTOKPTR); /* STRING=TERM OP */
       END;
   /* NOW PROCESS DIADIC INFIX OPERATORS */
   IF TERMPTR=NULL × TYPE^=OPERATOR
     THEN RETURN(TERMPTR); /* END OF EXPRESSION*/
   ON CONDITION(BADTERM)
     BEGIN; /* INVALID SYNTAX - TERM OP ? */
       MSG='SECOND DIADIC OPERAND EXPECTED BUT NOT FOUND';
       FREE OPTOKPTR->TOKEN;
       DO TERMPTR=TERMPTR REPEAT OPTOKPTR WHILE(TERMPTR^=NULL);
         OPTOKPTR=TERMPTR->NEXT_TOKEN; /* SAVE NEXT PTR */
         FREE TERMPTR->TOKEN;
         END;
       GO TO ENDPOLE;
       END;
   IF PRECEDENCE(1,SUBTYPE)<0
     THEN DO; /* OPERATOR IS TO BE PROCESSED RIGHT-TO-LEFT */
       IF ABS(PRECEDENCE(1,SUBTYPE))^=OPLVL
         THEN LEAVE;
       OPTOKPTR=COPYTOK(TOKPTR); /* GO COPY OPERATOR TOKEN */
       TOKPTR=NEXT_TOKEN;
       IF PRECEDENCE(2,OPTOKPTR->SUBTYPE)<0
         THEN TERM2PTR=POLE(PTOP); /* RIGHT-ASSOCIATE ONLY */
         ELSE TERM2PTR=POLE(OPLVL); /* LEFT- AND RIGHT-ASSOCIATE */
       IF TERM2PTR=NULL
         THEN SIGNAL CONDITION(BADTERM);
         ELSE TERMPTR=QUEUE(TERMPTR,QUEUE(TERM2PTR,OPTOKPTR));
       END;
     ELSE DO FOREVER=1 REPEAT FOREVER; /* PROCESS LEFT-TO-RIGHT */
       IF TYPE^=OPERATOR
         THEN LEAVE;
       IF PRECEDENCE(1,SUBTYPE)^=OPLVL
         THEN LEAVE;
       OPTOKPTR=COPYTOK(TOKPTR); /* GO COPY OPERATOR TOKEN */
       TOKPTR=NEXT_TOKEN;
       TERM2PTR=POLE(OPLVL-1); /* GET SECOND TERM */
       IF TERM2PTR=NULL
         THEN SIGNAL CONDITION(BADTERM);
         ELSE TERMPTR=QUEUE(TERMPTR,QUEUE(TERM2PTR,OPTOKPTR));
       END;
 ENDPOLE:
   RETURN(TERMPTR); /* ANSWER TERM,TERM,OPER,TERM,TERM,OPER,ETC. */
   END POLE;
 GET_OPERAND: PROC RETURNS(PTR) RECURSIVE;
 /**********************************************************************
 * CALLED TO IDENTIFY AND RETURN THE OPERAND WHICH SHOULD BE NEXT      *
 * IN CMDDATA.                                                         *
 **********************************************************************/
   DCL (FIRST,NEXT,SAVE,HDR,NEXTEXP,LPAREN) PTR;
   DCL SW BIT(1);
   FIRST=NULL;
   IF TYPE=NO_MORE_TOKENS
     THEN RETURN(NULL);
   IF TYPE=OPERATOR
     THEN DO;
       MSG='OPERATOR FOUND WHEN OPERAND WAS EXPECTED';
       RETURN(NULL);
       END;
   IF TOKSTR='(' & TYPE^=QUOTED_STRING
     THEN RETURN(EXPRESSION);
   ON CONDITION(BADLIST)
     BEGIN; /* BAD LIST ENCOUNTERED */
       DO NEXT=NEXT REPEAT SAVE WHILE(NEXT^=NULL);
         SAVE=NEXT->NEXT_TOKEN;
         FREE NEXT->TOKEN;
         END;
       DO NEXT=FIRST REPEAT SAVE WHILE(NEXT^=NULL);
         SAVE=NEXT->NEXT_TOKEN;
         FREE NEXT->TOKEN;
         END;
       FIRST=NULL;
       GO TO END_GET_OP;
       END;
   FIRST=COPYTOK(TOKPTR);
   IF ^(TYPE=OPERAND × TYPE=KEYWORD)
     THEN TOKPTR=NEXT_TOKEN;
     ELSE DO;
       DO SW='1'B REPEAT ^SW;
         TOKPTR=NEXT_TOKEN;
         SELECT(SW);
           WHEN('1'B) IF TOKSTR^='.'
             THEN LEAVE;
             ELSE TYPE=OTHER; /* QUALIFIER, NOT NUMERIC CONSTANT */
           OTHERWISE IF ^(TYPE=OPERAND × TYPE=KEYWORD)
             THEN LEAVE;
           END; /* SELECT */
         FIRST=QUEUE(FIRST,COPYTOK(TOKPTR));
         END;
       IF TOKSTR='(' & TYPE^=QUOTED_STRING
         THEN DO;
           DO SAVE=FIRST REPEAT SAVE->NEXT_TOKEN WHILE(SAVE^=NULL);
             IF SAVE->TYPE=OPERAND × SAVE->TYPE=KEYWORD
               THEN SAVE->TYPE=SAVE->TYPE+8; /* FUNCTION REFERENCE */
             END;
           LPAREN=COPYTOK(TOKPTR); /* ALLOCATE FOR '(' */
           TOKPTR=NEXT_TOKEN;
           NEXT=NULL;
           DO UNTIL(TOKSTR=')' & TYPE^=QUOTED_STRING);
             HDR=TOKPTR;
             NEXTEXP=POLISH(HDR,PRECEDENCE,MSG,TOKPTR);
             IF NEXTEXP=NULL
               THEN SIGNAL CONDITION(BADLIST);
             NEXT=QUEUE(NEXTEXP,NEXT); /* GO QUEUE TOGETHER */
             IF TOKSTR=','
               THEN DO;
                 NEXTEXP=COPYTOK(TOKPTR);
                 NEXT=QUEUE(NEXTEXP,NEXT); /* ADD ',' TO QUEUE */
                 TOKPTR=NEXT_TOKEN;
                 IF TOKSTR=')' & TYPE^=QUOTED_STRING
                   THEN DO;
                     MSG='PARAMETER EXPECTED BUT NOT ENCOUNTERED';
                     SIGNAL CONDITION(BADLIST);
                     END;
                 END;
             END;
           FIRST=QUEUE(QUEUE(LPAREN,QUEUE(NEXT,COPYTOK(TOKPTR))),FIRST);
           TOKPTR=NEXT_TOKEN; /* SKIP PAST LEFT PARENTHESIS */
           END;
       END;
 END_GET_OP:
   RETURN(FIRST);
   END GET_OPERAND;
 EXPRESSION: PROC RETURNS(PTR) RECURSIVE;
 /**********************************************************************
 * CALLED TO PROCESS A PARENTHESIZED EXPRESSION.                       *
 **********************************************************************/
   DCL (OP1,OP2,OP3,HDR,LAST) PTR;
   OP1=COPYTOK(TOKPTR);
   TOKPTR=NEXT_TOKEN;
   HDR=TOKPTR;
   OP1=QUEUE(OP1,POLISH(HDR,PRECEDENCE,MSG,TOKPTR));
   IF MSG^=''
     THEN DO;
       FREE OP1->TOKEN;
       RETURN(NULL);
       END;
   IF ^(TOKSTR=')' & TYPE^=QUOTED_STRING)
     THEN DO;
       MSG='RIGHT PARENTHESIS NOT FOUND WHERE EXPECTED';
       DO OP2=OP1 REPEAT OP3 WHILE(OP2^=NULL);
         OP3=OP2->NEXT_TOKEN;
         FREE OP2->TOKEN;
         END;
       RETURN(NULL);
       END;
   OP1=QUEUE(OP1,COPYTOK(TOKPTR));
   TOKPTR=NEXT_TOKEN;
   RETURN(OP1);
   END EXPRESSION;
   END POLISH;
