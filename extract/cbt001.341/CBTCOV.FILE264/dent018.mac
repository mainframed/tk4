  /* COPYRIGHT 1983 BY THOMAS GLEN SMITH */
   /* DENT018 - LINES,SHOW,SUPPORT,SWAP */
   % DCL @PROCNAME CHAR;
   % DCL @RENTNAME CHAR;
   % @PROCNAME ='RENT';
   % @RENTNAME ='DENT018';
   % INCLUDE DENTSUB;
   DCL SETCAPS ENTRY;
   DCL (TRH,SAVNXT,SAVLST,QP,SAVRH) PTR;
   DCL RECLUP PTR;
   DCL CMDLAB(5) LABEL;
   DCL HEIR CHAR(8) INIT('');
   GO TO CMDLAB(CMDINDX);
  CMDLAB(1): /* DENT018) */
  CMDLAB(2): /* LINES */
   /* LINES <NUM> */
   RHRC = 0;
   TRH=NULL;
   IF PARY(2) =''
     THEN KEEP = 0;
     ELSE IF VERIFY(PARY(2),'0123456789')^=0
       THEN DO;
         KEEP=0; /* LINES TO KEEP */
         HEIR=PARY(2);
         CALL SETCAPS(HEIR);
         DO TRH=NXTRHEL REPEAT TRH->RHNXT WHILE(TRH^=NULL)
           UNTIL(TRH->RHNAME=HEIR);
           END;
         IF TRH=NULL
           THEN DO;
             MSGDATA='NAME NOT FOUND = '××HEIR;
             RHRC=8;
             RETURN;
             END;
         END;
       ELSE KEEP = PARY(2); /* LINES TO KEEP */
   IF KEEP>SCREENLEN-4
     THEN KEEP=SCREENLEN-4;
   IF RHCST=0
     THEN OWN=0;
     ELSE OWN=RHCEN-RHCST+1; /* LINES CURRENTLY OWNED */
   GIVE=OWN-KEEP; /* LINES TO GIVE AWAY */
   SELECT;
     WHEN(GIVE=0) RETURN; /* NULL OPERATION */
     WHEN(GIVE>0) DO; /* WANTS TO GIVE UP LINES */
       IF TRH=NULL
         THEN DO; /* FIND SOMEBODY TO GIVE THE LINES */
           DO TRH=RHNXT REPEAT TRH->RHNXT WHILE(TRH^=NULL)
             UNTIL((^TRH->RHSUPSW & ^TRH->RHNOSHOWSW) ×
             (TRH->RHCST^=0));
             END; /* FIND 1ST NON-SUPPORT DATA SET NOT OWNING LINES */
           IF TRH=NULL
             THEN TRH=RHLST; /* PRIOR DATA SET, MAYBE */
           END;
       IF TRH=NULL
         THEN RETURN; /* NULL OPERATION */
       IF KEEP=0
         THEN RHCST,RHCEN=0;
         ELSE DO;
           RHCST=1;
           RHCEN=KEEP;
           END;
       IF TRH->RHCST=0
         THEN TRH->RHCEN=GIVE;
         ELSE TRH->RHCEN=TRH->RHCEN-TRH->RHCST+1+GIVE;
       TRH->RHCST=1; /* REAL CST WILL BE SET BELOW */
       END;
     OTHERWISE DO; /* WANTS TO GRAB LINES */
       DO TRH=RHNXT REPEAT TRH->RHNXT WHILE(TRH^=NULL & GIVE<0);
         CALL TRANSFER; /* GO TRANSFER LINES */
         END;
       DO TRH=RHLST REPEAT TRH->RHLST WHILE(TRH^=NULL & GIVE<0);
         CALL TRANSFER; /* GO TRANSFER LINES */
         END;
       RHCST=1;
       RHCEN=KEEP;
       END;
     END; /* SELECT */
   /* FIRST FIND LAST DATA SET OWNING LINES */
   QP=NULL;
   DO TRH=NXTRHEL REPEAT TRH->RHNXT WHILE(TRH^=NULL);
     IF TRH->RHCST^=0
       THEN QP=TRH;
     END;
   /* NOW MOVE ALL DATA SETS WITH ZERO LINES TO END OF Q */
   IF QP^=NULL
     THEN DO;
       TRH=NULL;
       DO FOREVER=1 REPEAT FOREVER;
         IF TRH=NULL
           THEN TRH=NXTRHEL;
           ELSE TRH=TRH->RHNXT;
         IF TRH=QP
           THEN LEAVE;
         IF TRH->RHCST=0
           THEN DO;
             SAVRH=TRH->RHLST;
             CALL DEQUEUE(TRH); /* FIRST DEQUEUE */
             CALL ENQUEUE(LSTRHEL,TRH); /* REQUEUE AT END Q */
             TRH=SAVRH;
             END;
         END;
       END;
   /* NOW ADJUST ALL RHCST,RHCEN PAIRS */
   AVAILABLE=SCREENLEN-4; /* LINES FOR USE ON SCREEN */
   NEXT=1;
   DO TRH=NXTRHEL REPEAT TRH->RHNXT WHILE(TRH^=NULL);
     IF AVAILABLE=0
       THEN TRH->RHCST,TRH->RHCEN=0;
       ELSE DO;
         OWN=TRH->RHCEN-TRH->RHCST+1;
         IF OWN>AVAILABLE
           THEN OWN=AVAILABLE;
         TRH->RHCST=NEXT;
         TRH->RHCEN=TRH->RHCST+OWN-1;
         AVAILABLE=AVAILABLE-OWN;
         NEXT=NEXT+OWN;
         END;
     END;
   RHRC=0;
   RETURN;

 TRANSFER: PROC;
 /**********************************************************************
 *                                                                     *
 * TRANSFER IS CALLED TO TRANSFER LINES TO THE CURRENT DATA SET        *
 * POINTED TO BY RHPTR FROM THE DATA SET POINTED TO BY TRH.  VARIABLE  *
 * GIVE CONTAINS THE NEGATIVE VALUE OF THE NUMBER OF LINES TO TAKE.    *
 *                                                                     *
 **********************************************************************/
   DCL (I,OWN) FIXED BIN(15,0);
   IF TRH->RHCST=0
     THEN RETURN;
   OWN=TRH->RHCEN-TRH->RHCST+1; /* LINES OWNED BY OTHER DATA SET */
   GIVE=GIVE+OWN;
   IF GIVE<=0
     THEN TRH->RHCST,TRH->RHCEN=0;
     ELSE DO;
       TRH->RHCEN=TRH->RHCST+GIVE-1;
       GIVE=0;
       END;
   END TRANSFER;
  CMDLAB(5): /* SWAP */
  CMDLAB(3): /* SHOW */
   IF RHCST=0
     THEN DO;
       RHRC=8;
       MSGDATA='SWAP OR SHOW IGNORED';
       RETURN;
       END;
   CALL SETCAPS(PARY(2));
   DO TRH=NXTRHEL REPEAT TRH->RHNXT WHILE(TRH^=NULL)
     UNTIL(TRH->RHNAME=PARY(2));
     END;
   IF TRH=NULL
     THEN DO;
       MSGDATA='NAME NOT FOUND';
       RHRC = 8;
       RETURN;
       END;
   IF TRH->RHNAME^=PARY(2)
     THEN DO;
       MSGDATA='NAME NOT FOUND';
       RHRC = 8;
       RETURN;
       END;
   IF TRH->RHCEN^=0
     THEN DO;
       IF CMDINDX=3 /* SHOW? */
         THEN DO;
           MSGDATA='NAME ALREADY DISPLAYED';
           RHRC = 8;
           RETURN;
           END;
       SAVRHCST=TRH->RHCST;
       SAVRHCEN=TRH->RHCEN;
       TRH->RHCST=RHCST;
       TRH->RHCEN=RHCEN;
       RHCST=SAVRHCST;
       RHCEN=SAVRHCEN;
       SELECT;
         WHEN(RHNXT=TRH) DO; /* BACK-TO-BACK */
           CALL DEQUEUE(RHPTR);
           CALL ENQUEUE(TRH,RHPTR);
           END;
         WHEN(RHLST=TRH) DO; /* BACK-TO-BACK */
           CALL DEQUEUE(TRH);
           CALL ENQUEUE(RHPTR,TRH);
           END;
         OTHERWISE DO;
           QP=TRH->RHLST; /* SAVE QUEUE POINT */
           CALL DEQUEUE(TRH); /* DEQUEUE SWAPPEE */
           CALL ENQUEUE(RHPTR,TRH);
             /* ENQUEUE SWAPPEE BEHIND SWAPPER */
           CALL DEQUEUE(RHPTR); /* DEQUEUE SWAPPER */
           CALL ENQUEUE(QP,RHPTR);
             /* ENQUEUE SWAPPER AT SWAPPEE'S OLD SPOT*/
           END;
         END; /* END SELECT */
       RHRC=0;
       RETURN;
       END;
   /* AT THIS POINT, A SWAP AND A SHOW ARE ONE AND THE SAME. */
   /* NOW DEQUEUE ELEMENT POINTED TO BY TRH */
   CALL DEQUEUE(TRH);
   TRH->RHCST=RHCST;
   TRH->RHCEN=RHCEN;
   RHCST,RHCEN=0;
   /* NOW ENQUEUE ELEMENT POINTED TO BY TRH */
   TRH->RHNXT=RHNXT;
   TRH->RHLST=RHLST;
   IF TRH->RHNXT^=NULL
     THEN TRH->RHNXT->RHLST=TRH;
     ELSE LSTRHEL = TRH;
   IF TRH->RHLST^=NULL
     THEN TRH->RHLST->RHNXT=TRH;
     ELSE NXTRHEL = TRH;
   /* NOW ENQUEUE REPLACED ELEMENT AT END OF QUEUE */
   RHNXT=NULL;
   RHLST=LSTRHEL;
   LSTRHEL=RHPTR;
   IF RHLST=NULL
     THEN NXTRHEL=RHPTR;
     ELSE RHLST->RHNXT=RHPTR;
   /* FINIS */
   RHPTR=TRH;
   RHRC = 0;
   RETURN;
  CMDLAB(4): /* SUPPORT */
   CALL SETCAPS(PARY(2));
   RHRC=0;
   SELECT(PARY(2));
     WHEN('ON','') RHSUPSW='1'B;
     WHEN('OFF') RHSUPSW='0'B;
     WHEN('NOSHOW') RHNOSHOWSW='1'B;
     WHEN('SHOW') RHNOSHOWSW='0'B;
     OTHERWISE DO;
       MSGDATA='INVALID OPERAND - MUST BE ON, OFF, SHOW OR NOSHOW';
       RHRC=16;
       END;
     END;
   RETURN;
  DEQUEUE: PROC(PPTR);
   DCL PPTR PTR;
   IF PPTR->RHLST = NULL
     THEN NXTRHEL = PPTR->RHNXT;
     ELSE PPTR->RHLST->RHNXT = PPTR->RHNXT;
   IF PPTR->RHNXT = NULL
     THEN LSTRHEL = PPTR->RHLST;
     ELSE PPTR->RHNXT->RHLST = PPTR->RHLST;
   END DEQUEUE;
  ENQUEUE: PROC(HEAD,TAIL);
   DCL (HEAD,TAIL) PTR;
   IF HEAD=NULL
     THEN DO; /* NEW ELEMENT IS TO BE QUEUED AT TOP OF LIST */
       TAIL->RHNXT=NXTRHEL;
       TAIL->RHLST=NULL;
       NXTRHEL=TAIL;
       IF LSTRHEL=NULL
         THEN LSTRHEL=TAIL; /* TAIL IS THE ONLY ONE ON QUEUE */
         ELSE TAIL->RHNXT->RHLST=TAIL;
       END;
     ELSE DO; /* NEW ELEMENT IS NOT AT TOP OF LIST */
       TAIL->RHLST=HEAD;
       TAIL->RHNXT=HEAD->RHNXT;
       HEAD->RHNXT=TAIL;
       IF TAIL->RHNXT=NULL
         THEN LSTRHEL=TAIL; /* NEW ELEMENT IS LAST IN QUEUE */
         ELSE TAIL->RHNXT->RHLST=TAIL;
       END;
   END ENQUEUE;
   END;
