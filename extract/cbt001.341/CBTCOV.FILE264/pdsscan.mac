*PROCESS CS(60);
 /* PDSSCAN */
 /*
0*$.HE GENERALIZED UTILITIES - PDSSCAN
0*$.HE LOAD LIBRARY SCAN
0*$.PL 55
0*$.PN 0
0*$.PA
0*$.SS
0*$.NF
0*$08/26/76
0*$AUTHOR:  P. DIXON
0*$SOURCE MODULE NAME:  PDSSCAN
0*$DOCUMENTATION ID:  0*$
0*$.FI L
0*$.SP 5
0*$THIS UTILITY PROGRAM CAN BE USED TO SCAN A LOAD LIBRARY
0*$DIRECTORY TO EITHER LIST ALL OF THE CSECTS CONTAINED WITHIN
0*$EACH LOAD MODULE, OR TO PRODUCE A FILE OF 16-BYTE RECORDS,
0*$EACH RECORD CONTAINING A CSECT NAME IN POSITIONS 9 TO 16,
0*$AND IN POSITIONS 1 TO 8, THE NAME OF THE LOAD MODULE CONTAINING
0*$THAT CSECT.  THIS FILE CAN BE INPUT TO THE PDSXREF UTILITY
0*$(SEE DOCUMENTATION FOR PDSXREF) TO OBTAIN A LISTING FOR EACH
0*$CSECT SHOWING THE LOAD MODULES CONTAINING THAT CSECT.
0*$EXECUTION JCL IS AS FOLLOWS:
0*$.SP 1
0*$.IN 5
0*$.NF
0*$// EXEC PGM=PDSSCAN,PARM='/NN'
0*$//STEPLIB DD DSN=U.SD.U000.TGSLOAD,DISP=SHR
0*$//SYSPRINT DD SYSOUT=A
0*$//SYSLIB DD DSN=LOAD.LIBRARY,DISP=SHR
0*$//XREF DD DSN=&XREF,DISP=(NEW,PASS),
0*$// UNIT=DISK,SPACE=(TRK,(10,10)),
0*$// DCB=(LRECL=16,BLKSIZE=19056,RECFM=FB)
0*$//SORTLIB DD DSN=SYS1.SORTLIB,DISP=SHR
0*$//SYSOUT DD SYSOUT=A
0*$//SORTWK01 DD UNIT=DISK,SPACE=(TRK,(10,10))
0*$//SORTWK02 DD UNIT=DISK,SPACE=(TRK,(10,10))
0*$//SORTWK03 DD UNIT=DISK,SPACE=(TRK,(10,10))
0*$.FI L
0*$.HI 5
0*$.SP 1
0*$WHERE:
0*$.SP 1
0*$NN IN THE PARM FIELD IS OPTIONAL, AND INDICATES THE LINESIZE
0*$TO BE USED ON THE SYSPRINT FILE. IF NOT SPECIFIED, THE DEFAULT
0*$IS 121.
0*$.SP 1
0*$SYSPRINT WILL CONTAIN THE LIST OF CSECTS WITHIN EACH LOAD
0*$MODULE.  NOTE THAT THIS LISTING WILL NOT BE GENERATED IF
0*$THE XREF DD STATEMENT IS SUPPLIED.
0*$.SP 1
0*$SYSLIB WILL POINT TO THE LOAD LIBRARY TO BE LISTED.
0*$.SP 1
0*$XREF IS AN OPTIONAL DD STATEMENT TO CONTAIN THE FILE OF
0*$16-BYTE RECORDS.
 */
 SCAN: /* SCAN LOADLIB FOR SECTION DEFINITIONS             */
       /* WRITTEN 1/16/79 BY PAUL DIXON                    */
 PROCEDURE(PARM) OPTIONS(MAIN) REORDER;
 DEFAULT RANGE(*) STATIC FIXED;
 DCL SYSPRINT PRINT;                                              /*
 DCL SYSLIB   FILE RECORD INPUT  ENV(U) PARTITIONED;              */
 DCL XREF FILE RECORD OUTPUT ENV(FB RECSIZE(16));
 DCL 1 REC,
      2 RECMEM CHAR(8),
      2 RCSECT CHAR(8);
 DCL XREFSW BIT(1) INIT('1'B);
 ON UNDF(XREF) XREFSW = '0'B;
 OPEN FILE(XREF);
 DCL PARM CHAR(100) VARYING;
 DCL GETDIR  EXTERNAL ENTRY(CHAR(8)) RETURNS(CHAR(8));
 DCL SYSDCBP EXTERNAL ENTRY(POINTER,CHAR(8));
 DCL SYSOPEN EXTERNAL ENTRY(POINTER,CHAR(*));
 DCL SYSCLOS EXTERNAL ENTRY(POINTER);
 DCL SYSFIND EXTERNAL ENTRY(POINTER,CHAR(8),CHAR(1),FIXED BINARY(31));
 DCL SYSREAD EXTERNAL ENTRY(POINTER,VARYING CHAR(*));
 DCL (ADDR,HIGH,INDEX,LENGTH,NULL,SUBSTR,UNSPEC) BUILTIN;
 DCL 01 CESD BASED(ADDR(SYSLIB_RECORD)),
        05 FILL#00      BINARY(15),
        05 FILL#01      CHAR(6),
        05 CSECT_COUNT  BINARY(15),
        05 FILL#02(15) ,
           10 CSECT     CHAR(8),
           10 FILL#03   BIT(4),
           10 CSECT_ID  BIT(4),
           10 FILL#04   CHAR(7);
 DCL SYSLIB_POINTER POINTER INIT(NULL());
 DCL SYSLIB_RECORD VARYING CHAR(32000) INIT('');
 DCL MEMBER CHAR(8) INIT('');
 DCL RETURN_CODE BINARY(31) INIT(0);
 DCL MORE_RECORDS BIT INIT('1'B);
 DCL LINE_SIZE BINARY(15) INIT(132);
 DCL (K,L) BINARY(15) INIT(0);
 DCL CESD# BIT(8) INIT('00100000'B);  /* ESD RECORD CODE */
 DCL SD# BIT(4) INIT('0000'B);    /* SECTION DEFINITION FIELD CODE */
 DCL RETURN_LABEL LABEL(SYSREAD_1,SYSREAD_2,SYSREAD_3);
 DCL SYSEOD CONDITION;
 ON ENDPAGE(SYSPRINT);
 ON CONDITION(SYSEOD)
    BEGIN;
       MORE_RECORDS = '0'B;
       GOTO RETURN_LABEL;
    END;
1IF LENGTH(PARM) > 0 THEN
    DO;
       ON ERROR PUT FILE(SYSPRINT) LIST('PARM FIELD INVALID');
       LINE_SIZE = PARM;
       IF LINE_SIZE < 19 × LINE_SIZE > 255 THEN SIGNAL ERROR;
       ON ERROR SYSTEM;
    END;
 CALL SYSDCBP(SYSLIB_POINTER,'SYSLIB');
 CALL SYSOPEN(SYSLIB_POINTER,'INPUT');
 IF ^XREFSW
   THEN OPEN FILE(SYSPRINT) LINESIZE(LINE_SIZE);
 DO MEMBER = GETDIR('SYSLIB') REPEAT GETDIR('SYSLIB')
             WHILE (MEMBER ^= HIGH(8));
    CALL SYSFIND(SYSLIB_POINTER,MEMBER,'D',RETURN_CODE);
    IF RETURN_CODE ^= 0 THEN SIGNAL ERROR;
    MORE_RECORDS = '1'B;
    IF XREFSW
      THEN RECMEM = MEMBER;
      ELSE PUT FILE(SYSPRINT) SKIP EDIT(MEMBER,' ') (A,A);
    K = 9;
    RETURN_LABEL = SYSREAD_1;
    CALL SYSREAD(SYSLIB_POINTER,SYSLIB_RECORD);
    SYSREAD_1:;
    DO WHILE(MORE_RECORDS & UNSPEC(SUBSTR(SYSLIB_RECORD,1,1)) ^= CESD#);
       RETURN_LABEL = SYSREAD_2;
       CALL SYSREAD(SYSLIB_POINTER,SYSLIB_RECORD);
       SYSREAD_2:;
    END;
    DO WHILE(MORE_RECORDS & UNSPEC(SUBSTR(SYSLIB_RECORD,1,1)) = CESD#);
       DO L = 1 TO CSECT_COUNT/16;
          IF CSECT_ID(L) = SD# THEN
             DO;
                IF K+9 > LINE_SIZE THEN
                   DO;
                      IF ^XREFSW THEN
                      PUT FILE(SYSPRINT) SKIP EDIT((9)' ') (A);
                      K = 9;
                   END;
                IF XREFSW
                  THEN DO;
                    RCSECT = CSECT(L);
                    WRITE FILE(XREF) FROM(REC);
                    END;
                  ELSE
                PUT FILE(SYSPRINT) EDIT (CSECT(L)) (X(1),A);
                K = K + 9;
             END /* IF CSECT_ID = SD */;
       END /* DO K */;
       RETURN_LABEL = SYSREAD_3;
       CALL SYSREAD(SYSLIB_POINTER,SYSLIB_RECORD);
       SYSREAD_3:;
    END /* DO WHILE */;
 END /* DO WHILE MEMBER ^= HIGH(8) */;
 IF ^XREFSW THEN
 CLOSE FILE(SYSPRINT);
 CALL SYSCLOS(SYSLIB_POINTER);
 END SCAN;
