 /* PREPROCESSOR VARIABLE FCNT SHOULD BE SET TO THE DESIRED
    MAXIMUM NUMBER OF OUTPUT FILES */
 /*
0*$.HE GENERALIZED UTILITIES - SMFSPLIT
0*$.HE SMF SPLIT UTILITY
0*$.PL 55
0*$.PN 0
0*$.PA
0*$.SS
0*$.NF
0*$12/24/74
0*$AUTHOR:  T. SMITH
0*$SOURCE MODULE NAME:  SMFSPLIT
0*$DOCUMENTATION ID:  0*$
0*$.FI L
0*$.SP 5
0*$THIS UTILITY IS DESIGNED TO FACILITATE THE COPYING OF SPECIFIC
0*$SMF RECORDS FROM THE MAIN FILE INTO SEPARATE FILES FOR LATER
0*$PROCESSING.
0*$.SP 1
0*$TYPES OF SMF RECORDS ARE SELECTED TO BE WRITTEN INTO A PARTICULAR
0*$FILE BASED ON INFORMATION DERIVED FROM THE FORMAT OF THE DDNAME.
0*$EACH DDNAME REPRESENTING A FILE INTO WHICH SMF RECORDS ARE TO BE
0*$COPIED MUST BEGIN WITH AN ALPHABETIC CHARACTER, AND MUST BE FOLLOWED
0*$WITH NUMBERS REPRESENTING THE SMF RECORD TYPES TO BE COPIED TO THIS
0*$PARTICULAR FILE.  EACH NUMBER IS SEPARATED FROM ITS NEIGHBORS BY THE
0*$CHARACTER "@".  THE FIRST CHARACTER OF THE DDNAME INDICATES WHETHER
0*$THE NUMBERS THAT FOLLOW ARE IN HEXADECIMAL OR DECIMAL NOTATION.
0*$FOR EXAMPLE, THE DDNAME "D4@5" WOULD INDICATE THAT ALL SMF RECORD
0*$TYPES 4 AND 5 SHOULD BE COPIED INTO THIS FILE.  THE DDNAME
0*$"XDE@DF" WOULD INDICATE THAT ALL SMF RECORD TYPES 222 AND 223
0*$SHOULD BE COPIED INTO THIS FILE.
0*$.SP 1
0*$AN ALTERNATIVE FORM OF DDNAME ALLOWS YOU TO SPECIFY A RANGE OF
0*$LINES.  "D70T79" AS A DDNAME, FOR EXAMPLE, ALLOWS THE SELECTION
0*$OF SMF RECORD TYPES 70 THRU 79.  NOTE THAT ONLY THE DECIMAL
0*$SPECIFICATION IS ALLOWED IN THIS FORMAT.
0*$.SP 1
0*$NOTE THAT A GIVEN SMF RECORD TYPE CAN BE SPECIFIED ON MORE
0*$THAN ONE DDNAME.
0*$.SP 1
0*$UP TO 10 FILES WITH DDNAMES IN THE ABOVE FORMAT CAN BE
0*$SPECIFIED.  THIS NUMBER COULD BE INCREASED BY CHANGING THE SETTING
0*$OF PREPROCESSOR VARIABLE %FCNT IN THE SOURCE AND RECOMPILING THE
0*$PROGRAM.
0*$.SP 1
0*$IN ADDITION TO DDNAMES ALREADY MENTIONED, A SPECIAL DDNAME,
0*$"ODDFILE", CAN ALSO OPTIONALLY BE SPECIFIED.  ANY SMF RECORD
0*$TYPES WHICH ARE NOT SELECTED FOR COPYING INTO ANY OF THE OTHER
0*$FILES WILL BE COPIED INTO THIS FILE.
0*$.SP 1
0*$THE DDNAME REPRESENTING THE MAIN SMF FILE IS "SMFDATA".  AN EXAMPLE
0*$FOLLOWS IN WHICH RECORD TYPES 4, 5 AND 8 ARE SELECTED TO ONE FILE,
0*$AND TYPES 222 AND 223 TO ANOTHER.
0*$.SP 1
0*$.IN 10
0*$.NF
0*$// EXEC PGM=SMFSPLIT,REGION=100K
0*$//STEPLIB DD DSN=U.SD.U000.TGSLOAD,DISP=SHR
0*$//SYSPRINT DD SYSOUT=A
0*$//SMFDATA DD DSN=SYS1.MANX,DISP=SHR
0*$// DD DSN=SYS1.MANY,DISP=SHR
0*$//D4@5@8 DD DSN=&SMF1,DISP=(NEW,PASS),SPACE=(CYL,(1,1)),
0*$// VOL=REF=SYS1.WORK1
0*$//D222@223 DD DSN=&SMF2,DISP=(NEW,PASS),SPACE=(CYL,(1,1)),
0*$// VOL=REF=SYS1.WORK1
0*$.SP 1
0*$.IN 0
0*$.FI L
0*$YOU MAY ALSO RESTRICT THE SELECTION OR RECORDS TO A SPECIFIC
0*$DATE OR RANGE OF DATES BY SPECIFYING ONE OF THE FOLLOWING FORMATS
0*$IN THE PARM FIELD ON THE EXECUTE STATEMENT:
0*$.SP 1
0*$.IN 10
0*$.NF
0*$PARM='/<DATE-SPEC>'
0*$PARM='/<DATE-SPEC> TIMES(<TIME-SPEC>)'
0*$PARM='/DATES(<DATE-SPEC>) TIMES(<TIME-SPEC>)'
0*$PARM='/TIMES(<TIME-SPEC>) DATES(<DATE-SPEC>)'
0*$PARM='/TIMES(<TIME-SPEC>)'
0*$PARM='/DATES(<DATE-SPEC>)'
0*$.FI L
0*$.IN 0
0*$.SP 1
0*$<DATE-SPEC> CAN BE ANY OF THE FORMS YYDDD, YYDDD-YYDDD,
0*$MMDDYY, OR MMDDYY-MMDDYY, WHERE
0*$YYDDD IS THE DATE IN JULIAN FORM, AND MMDDYY IS THE DATE IN
0*$GREGORIAN FORM.
0*$.SP 1
0*$<TIME-SPEC> CAN BE ONE OF THE FORMS <START>-<END>, OR
0*$<START>.  BOTH <START> AND <END> MAY HAVE ONE OF THE FORMS
0*$HH:MM, OR HH, WHERE HH IS HOURS, AND MM IS MINUTES.
0*$.SP 1
0*$IF YOU WANT TO SELECT ALL SMF RECORDS FOR A SPECIFIC DATE OR
0*$RANGE OF DATES AND TIME OR RANGE OF TIMES, INCLUDE A DD STATEMENT
0*$WITH THE DDNAME OF ALLFILE.  ALL SMF RECORDS MEETING THE
0*$DATE AND TIME SPECIFICATIONS IN THE PARM FIELD WILL BE WRITTEN
0*$TO THIS FILE IN ADDITION TO ANY OTHER FILES THEY ARE ELIGIBLE
0*$FOR.
0*$.SP 1
0*$YOU CAN SELECT ONLY SMF RECORDS ASSOCIATED WITH A SPECIFIC
0*$JOBNAME BY SPECIFYING THE KEYWORD OPERAND "JBN(JBN-SPEC)" IN
0*$THE PARM FIELD OF THE EXEC STATEMENT.  JBN-SPEC CAN BE 1 TO 8
0*$CHARACTERS IN LENGTH.  ONLY SMF RECORDS THAT MATCH THE JBN-SPEC
0*$WILL BE SELECTED.  NOTE THAT A PERIOD IN ANY POSITION OF JBN-SPEC
0*$MATCHES ALL CHARACTERS.  FOR EXAMPLE, JBN(EUP...) SPECIFIES THAT
0*$ONLY JOB NAMES 3 TO 6 CHARACTERS LONG BEGINNING WITH "EUP" ARE TO
0*$BE SELECTED.
 */
 SPLIT:  PROC(PARM) OPTIONS(MAIN);
         %DCL FCNT FIXED;
         %FCNT = 10;
         %DCL FNAME CHAR;
         %FNAME = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
         %DCL INDX FIXED;
         %DCL FNM CHAR;
         DCL (
         %DO INDX = 1 TO FCNT;
         %FNM = SUBSTR(FNAME,INDX,1);
         FNM,
         %END;
         ODDFILE,ALLFILE)
         FILE RECORD OUTPUT ENV(VBS BLKSIZE(13030) RECSIZE(32760)
           CONSECUTIVE);
         DCL (SRNGE,ERNGE,CRNGE) FIXED BIN(15,0);
         DCL (TIX,SIX) FIXED BIN(15,0);
         DCL SUFFIX ENTRY(CHAR(*), CHAR(*))
           RETURNS(FIXED BIN(15,0));
         DCL PARM CHAR(100) VARYING;
         DCL (DATESTART,DATEEND) FIXED DEC(5,0) INIT(0);
         DCL GREGDATE CHAR(6);
         DCL JBN CHAR(8) INIT('');
         DCL 1 PARSTR UNALIGNED,
           2 CMDINDX FIXED BIN(31,0),
           2 OPERCK BIT(16),
           2 PARY(16) CHAR(80) VAR,
           2 NUMCKA(1) BIT(16) INIT('0'B),
           2 CMDTAB(1) CHAR(8) VAR INIT('');
         DCL PARS ENTRY(CHAR(*) VAR,);
         DCL OPERBUF CHAR(100) VAR,
         KEYTAB(3) CHAR(20) VAR STATIC INIT(
           'DATES','TIMES','JBN'),
           KEYVAL CHAR(80) VAR,
           KEYINDX FIXED BIN(15,0);
         DCL KEYLAB(0:3) LABEL;
         IF PARM^=''
           THEN DO;
             CALL PARS(PARM,PARSTR);
             DO IT = 1 TO 16 WHILE(PARY(IT)^='');
               CALL SPARS(PARY(IT),KEYTAB,KEYVAL,KEYINDX);
               GO TO KEYLAB(KEYINDX);
  KEYLAB(0):  /* ERROR IN PARM FIELD */
               KEYVAL=PARY(IT);
               KEYLAB(1):  /* DATES */
               PARM = KEYVAL;
               IX = LENGTH(PARM);
               IF IX > 0
                 THEN IF (IX = 5) × (IX = 11)
                   THEN DO;
                     DATESTART = SUBSTR(PARM,1,5);
                     IF IX = 11
                       THEN DATEEND = SUBSTR(PARM,7,5);
                     END;
                   ELSE DO;
                     GREGDATE = SUBSTR(PARM,1,6);
                     CALL GREGJUL(GREGDATE,DATESTART);
                     IF IX = 13
                       THEN DO;
                         GREGDATE = SUBSTR(PARM,8,6);
                         CALL GREGJUL(GREGDATE,DATEEND);
                         END;
                     END;
               IF DATEEND = 0
                 THEN DATEEND = DATESTART;
               GO TO ENDCASE;
  KEYLAB(2):  /* TIMES */
               JT = INDEX(KEYVAL,'-');
               IF JT = 0
                 THEN JT = LENGTH(KEYVAL)+1;
                 ELSE ETME = PTME(SUBSTR(KEYVAL,JT+1));
               STME = PTME(SUBSTR(KEYVAL,1,JT-1));
               GO TO ENDCASE;
 KEYLAB(3):  /* JBN */
               JBN = KEYVAL;
               GO TO ENDCASE;
  ENDCASE:
               END;
             END;
         DCL STME FIXED BIN(31,0) INIT(0);
         DCL ETME FIXED BIN(31,0) INIT(8640000);
 PTME:  PROC(TMSTR) RETURNS(FIXED BIN(31,0));
         DCL TMSTR CHAR(*);
         DCL (HH,MM,PI) FIXED BIN(31,0);
         MM = 0;
         PI = INDEX(TMSTR,':');
         IF PI = 0
           THEN PI = LENGTH(TMSTR)+1;
           ELSE MM=SUBSTR(TMSTR,PI+1);
         HH = SUBSTR(TMSTR,1,PI-1);
         RETURN(HH*360000+MM*6000);
         END PTME;
         ON ENDFILE(SMFDATA) GO TO EOJ;
         DCL SMFDATA FILE RECORD INPUT ENV(VBS RECSIZE(32760)
         CONSECUTIVE);
         DCL SMFREC CHAR(32760) VARYING;
         DCL SMFPTR PTR,
             SMFADJ FIXED BIN(31,0) DEF SMFPTR;
         SMFPTR = ADDR(SMFREC);
         SMFADJ = SMFADJ + 2;
         DCL 1 SMFDEF UNALIGNED BASED(SMFPTR),
           2 PAD CHAR(1),
           2 SMFTYPE BIT(8),
           2 SMFTIME FIXED BIN(31,0),
           2 SMFDATE FIXED DEC(7,0),
           2 PAD2 CHAR(4),
           2 SMF5JBN CHAR(8);
         DCL ((NXFIRST,NXLAST) BIT(1),
           DDNAME CHAR(8),
           TIOTPTR PTR) EXTERNAL;
         NXFIRST = '1'B;
         NXLAST = '0'B;
         DCL FILEINDEX FIXED BIN;
         DCL TDDN(FCNT) CHAR(8);
         DCL TDDNPTR(FCNT) PTR;
         DCL 1 TDDNSTR BASED(ALLPTR),
           2 TDDNY FIXED BIN(15,0),
           2 TDDNA(ICTL REFER (TDDNY)) BIT(8);
         DCL (ODDSW,ALLSW) BIT(1) STATIC INIT('0'B);
         DCL HITSW BIT(1);
         DCL RECEIVE FIXED BIN(15,0);
         DCL 1 BITSTR DEF RECEIVE,
           2 TRCHAR BIT(8),
           2 RECBIT BIT(8);
         DCL OUTCHAR CHAR(1) DEF RECEIVE;
         DCL INCHAR CHAR(2);
         DCL WRITE(FCNT) LABEL;
         DO FILEINDEX = 1 TO FCNT WHILE(NXLAST = '0'B);
  NXTDD:
           CALL NEXTDD;
           IF NXLAST
             THEN GO TO NXTDDB;
           IF DDNAME = 'SMFDATA' THEN GO TO NXTDD;
           IF DDNAME = 'ODDFILE'
             THEN DO;
               ODDSW = '1'B;
               OPEN FILE(ODDFILE);
               GO TO NXTDD;
               END;
             ELSE IF DDNAME='ALLFILE'
               THEN DO;
                 ALLSW = '1'B;
                 OPEN FILE(ALLFILE);
                 GO TO NXTDD;
                 END;
               ELSE DO;
                 TDDN(FILEINDEX) = DDNAME;
                 ICTL = 1;
                 DO I1 = 2 TO 8;
                   IF SUBSTR(DDNAME,I1,1) = '@'
                     THEN ICTL = ICTL + 1;
                     ELSE IF SUBSTR(DDNAME,I1,1) = 'T'
                       THEN DO;
                         CALL RNGE(I1);
                         ICTL = ICTL + CRNGE;
                         END;
                   END;
                 ALLOCATE TDDNSTR;
                 TDDNPTR(FILEINDEX) = ALLPTR;
                 K1 = 2;
                 DO J1 = 1 TO ICTL;
                   DO I1 = K1 TO 8 WHILE(SUBSTR(DDNAME,I1,1) ^= '@'
                     & SUBSTR(DDNAME,I1,1) ^= ' '
                     & SUBSTR(DDNAME,I1,1) ^= 'T');
                     END;
                   L1 = I1 - K1;
                   IF SUBSTR(DDNAME,1,1) = 'D'
                     THEN DO;
                       IF SUBSTR(DDNAME,I1,1) = 'T'
                         THEN DO;
                           CALL RNGE(I1);
                           DO RECEIVE=SRNGE TO ERNGE;
                             TDDNA(J1) = RECBIT;
                             J1 = J1 + 1;
                             END;
                           J1 = J1 - 1;
                           I1 = TIX+1;
                           END;
                         ELSE DO;
                           RECEIVE = SUBSTR(DDNAME,K1,L1);
                           TDDNA(J1) = RECBIT;
                           END;
                       END;
                     ELSE DO;
                       IF L1 = 1
                         THEN INCHAR = '0' ××
                           SUBSTR(DDNAME,K1,1);
                       ELSE INCHAR =
                         SUBSTR(DDNAME,K1,2);
                       CALL TRIN(INCHAR,OUTCHAR);
                       TDDNA(J1) = TRCHAR;
                       END;
                   K1 = I1 + 1;
                   END;
                 END;
 NXTDDA:
           END;
 NXTDDB:
         FILEINDEX = FILEINDEX - 1;
         I1 = 1;
         %DO INDX = 1 TO FCNT;
           %FNM = SUBSTR(FNAME,INDX,1);
           IF I1 > FILEINDEX
             THEN GO TO NXT;
           OPEN FILE(FNM) TITLE(TDDN(INDX));
           I1 = I1 + 1;
           %END;
 NXT:
         READ FILE(SMFDATA) INTO(SMFREC);
         IF STME<ETME
           THEN IF SMFTIME<STME × SMFTIME>ETME
             THEN GO TO NXT;
             ELSE IF SMFTIME<STME & SMFTIME>ETME
           THEN GO TO NXT;
         IF DATESTART ^= 0
           THEN IF SMFDATE < DATESTART
             THEN GO TO NXT;
         IF DATEEND ^= 0
           THEN IF SMFDATE > DATEEND
             THEN GO TO NXT;
         IF JBN^=''
           THEN DO;
             IA = SMFTYPE;
             IF ^(IA=4 × IA=5 × IA=6 × IA=20 × IA=26 × IA=34 × IA=35)
               THEN GO TO NXT;
             DO IA = 1 TO 8;
               IF SUBSTR(JBN,IA,1)^='.' & SUBSTR(JBN,IA,1) ^=
                 SUBSTR(SMF5JBN,IA,1)
                 THEN GO TO NXT;
               END;
             END;
         IF ALLSW
           THEN WRITE FILE(ALLFILE) FROM(SMFREC);
         HITSW = '0'B;
         DO I1 = 1 TO FILEINDEX;
           ALLPTR = TDDNPTR(I1);
           DO J1 = 1 TO TDDNY;
             IF SMFTYPE = TDDNA(J1)
               THEN GO TO WRITE(I1);
               ELSE GO TO BYSET;
             %DO INDX = 1 TO FCNT;
               %FNM = SUBSTR(FNAME,INDX,1);
               WRITE(INDX):
               WRITE FILE(FNM) FROM(SMFREC);
               GO TO SETRET;
               %END;
 SETRET:
             HITSW = '1'B;
 BYSET:
             END;
           END;
         IF HITSW
           THEN GO TO NXT;
         IF ODDSW
           THEN WRITE FILE(ODDFILE) FROM(SMFREC);
         GO TO NXT;
 RNGE:  PROC(I);
         DCL I FIXED BIN(15,0);
         SIX=SUFFIX(SUBSTR(DDNAME,1,I-1),'0123456789')+1;
           /* SIX = OFFSET TO START OF FIRST NUMBER */
         TIX=VERIFY(SUBSTR(DDNAME,I+1),'0123456789');
           /* TIX = OFFSET JUST BEYOND END SECOND NUMBER */
         IF TIX=0
           THEN TIX=LENGTH(DDNAME)+1;
           ELSE TIX=TIX+I;
         SRNGE=SUBSTR(DDNAME,SIX,I-SIX);
         ERNGE=SUBSTR(DDNAME,I+1,TIX-I-1);
         CRNGE=ERNGE-SRNGE+1;
         END RNGE;
 EOJ:
         END;
