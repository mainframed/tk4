 /* @SETL/@SETG */
 %NOPRINT;
         % @SETLI = 'Y';
         % DCL @SETCOM ENTRY;
 % @SETCOM:  PROC(GSW,INSTR) STATEMENT RETURNS(CHAR);
 /*
0*$.HE GENERALIZED SUBROUTINES - @SETL/@SETG
0*$.HE PLI PREPROCESSOR TEXT
0*$.HE ASSIGN A VALUE TO A TEXT VARIABLE
0*$.PL 55
0*$.PN 0
0*$.PA
0*$.SS
0*$.NF
0*$09/11/76
0*$AUTHOR:  T. SMITH
0*$SOURCE MOUDLE NAME:  @SETL
0*$DOCUMENTATION ID:  0*$
0*$.FI L
0*$.SP 5
0*$THIS IS A PLI PREPROCESSOR PROCEDURE WHICH CAN BE INVOKED TO ASSIGN
0*$A VALUE TO EITHER A LOCAL OR A GLOBAL TEXT VARIABLE.  SEE ALSO
0*$DOCUMENTATION FOR REP@, SYM@, AND SET@.  CALL FORMAT IS AS FOLLOWS -
0*$.SP 1
0*$.IN 5
0*$@SETL(&LAB = VALUE);
0*$.IN 0
0*$.SP 1
0*$WHERE &LAB IS THE NAME OF THE VARIABLE FOR WHICH A VALUE IS
0*$TO BE ASSIGNED.  THIS WILL BE A LOCAL VARIABLE IF @SETL IS
0*$INVOKED, AND A GLOBAL VARIABLE IF @SETG IS INVOKED.  VALUE
0*$CAN BE EITHER A LITERAL, A PLI VARIABLE NAME, OR A COMBINATION OF
0*$BOTH IN THE FORM OF AN EXPRESSION.
0*$.SP 1
0*$NOTE THAT IF THE FIRST CHAR OF &LAB IS NOT '&', THE ROUTINE
0*$ASSUMES IT IS THE NAME OF A CHARACTER STRING CONTAINING THE
0*$& NAME.
0*$.SP 1
0*$EXAMPLES -
0*$.IN 5
0*$.NF
0*$@SETL(&NAME = 'MARY');
0*$@SETL(&NAME = NAME);
0*$@SETL(&CNT = 23+I-1);
0*$.FI L
0*$.IN 0
0*$.SP 1
0*$THE VALUE TO BE ASSIGNED WILL FIRST BE CONVERTED TO CHAR(256)
0*$VARYING.
 */
         DCL (GSW,INSTR) CHAR;
         DCL (I,J,K,L) FIXED;
         DCL (SYMBOL,EXP) CHAR;
         L = LENGTH(INSTR);
         I = INDEX(INSTR,'=');
         J = INDEX(INSTR,' ');
         IF J = 0 × J > I
              THEN J = I;
         SYMBOL = SUBSTR(INSTR,1,J-1);
         IF SUBSTR(SYMBOL,1,1)='&'
              THEN SYMBOL=''''××SYMBOL××'''';
         DO J = 1 TO L-I;
              IF SUBSTR(INSTR,I+J,1) ^= ' '
                   THEN GO TO STRT;
              END;
 STRT:
         EXP = SUBSTR(INSTR,I+J,L-(I+J)+1);
         RETURN('DO; CALL SET@('''××GSW××'''B,'××SYMBOL××','××EXP××
           '); END;');
         % END @SETCOM;
         % DCL @SETL ENTRY;
 % @SETL:  PROC(P1,P2,P3,P4,P5,P6) STATEMENT RETURNS(CHAR);
         DCL (P1,P2,P3,P4,P5,P6) CHAR;
         DCL (INSTR,RETSTR) CHAR;
         DCL GSW CHAR;
         GSW = '0';
         INSTR = P1××P2××P3××P4××P5××P6;
         RETURN(@SETCOM(GSW,INSTR));
         % END @SETL;
         % DCL @SETG ENTRY;
 % @SETG:  PROC(P1,P2,P3,P4,P5,P6) STATEMENT RETURNS(CHAR);
         DCL (P1,P2,P3,P4,P5,P6) CHAR;
         DCL (INSTR,RETSTR) CHAR;
         DCL GSW CHAR;
         GSW = '1';
         INSTR = P1××P2××P3××P4××P5××P6;
         RETURN(@SETCOM(GSW,INSTR));
         % END @SETG;
 %PRINT;
