  /*DENT*/
 /**********************************************************************
 * COPYRIGHT 1983 BY THOMAS GLEN SMITH                                 *
 *                                                                     *
 * PERMISSION TO MAKE PRIVATE COPIES OF THIS PROGRAM AND TO USE IT     *
 * FREELY IS HEREBY GRANTED BY THE AUTHOR.  THIS PROGRAM MAY NOT BE    *
 * SOLD, NOR ANY SECTION OF IT BE INCORPORATED INTO ANY WORK FOR SALE  *
 * WITHOUT PERMISSION OF THE AUTHOR.                                   *
 *                                                                     *
 **********************************************************************/
   % DCL @CMP CHAR;
   % @CMP = 'C';
   %IF @CMP='O' %THEN %DO;
 DENT:  PROC(CPPL1,CPPL2,CPPL3,CPPL4) OPTIONS(REENTRANT,MAIN);
   CPPLCBUF=ADDR(CPPL1);
   CPPLUPT=ADDR(CPPL2);
   CPPLPSCB=ADDR(CPPL3);
   CPPLECT=ADDR(CPPL4);
                      %END;
   %IF @CMP='C' %THEN %DO;
 DENT:  PROC OPTIONS(MAIN,REENTRANT);
   DCL TESTCP ENTRY;
   CALL TESTCP(CPPLCBUF,CPPLUPT,CPPLPSCB,CPPLECT);
                      %END;
   DCL 1 CPPL,
     2 CPPLCBUF PTR, /* COMMAND BUFFER */
     2 CPPLUPT PTR,  /* USER PROFILE TABLE */
     2 CPPLPSCB PTR, /* PROTECTED STEP CONTROL BLOCK */
     2 CPPLECT PTR;  /* ENVIRONMENT CONTROL TABLE */
   % DCL @SETBUFI CHAR;
   % INCLUDE @SETBUF;
   % DCL @LISTSW CHAR;
   % @LISTSW='N';
   % DCL @CMDI CHAR;
   % INCLUDE @CMD;
   % DCL @FREEI CHAR;
   % DCL @DA18SW CHAR;
   % @DA18SW='N';
   % INCLUDE @FREE;
   % INCLUDE @STRIP;
   % INCLUDE @SPARS;
   % INCLUDE @NULL;
   % DCL @ALLOCI CHAR;
   % DCL @DA08SW CHAR;
   % @DA08SW='N';
   % INCLUDE @ALLOC;
   DCL 1 TMPDSN@,
     2 DSNLEN FIXED BIN(15,0),
     2 DSNSTR CHAR(44);
   DCL (SYSDAIR,DAIRERR,SYSCTLG,SYSVTOC,SYSCMD,SYSGETM,PUTLINE,DENTFI)
     ENTRY;
   DCL SETDSN@ ENTRY RETURNS(CHAR(44) VARYING);
   DCL 1 BUFFER@,
     2 BUFLEN@ FIXED BIN(15,0),
     2 BUFOFF@ FIXED BIN(15,0) INIT(0),
     2 BUFSTR@ CHAR(256);
   DCL NULL BUILTIN;
   DCL IKJRET FIXED BIN(31,0);
   DCL CPECB FIXED BIN(31,0) INIT(0);
   % INCLUDE IKJPSCB;
   % INCLUDE IKJECT;
   % INCLUDE IKJUPT;
   DCL SYMHD@ PTR;
   DCL ZZZZPTR PTR;
   DCL @NULLZ PTR,
       @NULLZD FIXED BIN(31,0) BASED(ZZZZPTR);
   ZZZZPTR=ADDR(@NULLZ);
   @NULLZD=0;

   % DCL @PROCNAME CHAR;
   % @PROCNAME ='MAIN';
   % INCLUDE DENTSUB;
   DCL STACK ENTRY;
   DCL DREGSUB ENTRY RETURNS(FIXED BIN(15,0));
   DCL SETCAPS ENTRY;
   DCL (DENTBCH,DENTSPF,DENTSQL,DENTTSO) ENTRY;
   DCL DENTEP ENTRY VARIABLE;
   DCL (PREFIX,SUFFIX) ENTRY RETURNS(FIXED BIN(15,0));
   DCL MYDSN CHAR(44) VAR;
   DCL (VTNAM,MYNAM) CHAR(8) VAR;
   DCL (INSW,OUTSW) BIT(1) INIT('0'B);
   DCL L FIXED BIN(15,0);
   DCL 1 CBUF BASED(CPPLCBUF),
      2 BUFLEN FIXED BIN(15,0) INIT(80),
      2 OFFSET FIXED BIN(15,0) INIT(0),
      2 BUFFER CHAR(80) INIT('SSE '''' INP(SCAN) HARDCOPY');
   DCL SUBENT(100) ENTRY;
   DCL #TERM ENTRY(CHAR(*) VAR) DEF SUBENT(29);
   DCL #PROMPTL ENTRY(CHAR(80) VAR)
       RETURNS(CHAR(240) VAR) DEF SUBENT(30);
   DCL DCBPATPT PTR;
   DCL DUMCOR(28) FIXED BIN(31,0) INIT((28)0),
       DCBCOR CHAR(112) DEF DUMCOR;
   HALT;
   SYMHD@=NULL;
   DCBPATPT=NULL;
   SUBENT(1)  = DOFRE;   /* FREE DATASET */
   SUBENT(2)  = DOALC;   /* ALLOC DATASET */
   SUBENT(7)  = DOCMD;   /* EXECUTE TSO COMMAND */
   SUBENT(8)  = DOPRM;   /* PROMPT FOR ISTACK INPUT */
   SUBENT(23) = SYMC;    /* RESOLVES SYMBOLIC VARIABLES */
   SUBENT(24) = REP@;    /* INTERNAL SYMBOLIC SUBSTITUTION */
   SUBENT(28) = SET@;    /* SET SUBSTITUTION VALUES */
   SUBENT(29) = TERMWRT; /* HARDCOPY TERMINAL OUTPUT */
   SUBENT(30) = DOPRMLO; /* PROMPT FOR TERMINAL INPUT - LO */
   SUBENT(41) = DOSTK;   /* TSO STACK INTERFACE */
   SUBENT(42) = SYMC;
   SUBENT(43) = REP@;
   SUBENT(44) = SET@;
   RHPTR = NULL;
   SELECT(SUBSTR(CBUF.BUFFER,1,3));
     WHEN('SQL') DENTEP=DENTSQL;
     WHEN('BCH') DENTEP=DENTBCH;
     WHEN('SPF') DENTEP=DENTSPF;
     OTHERWISE   DENTEP=DENTTSO;
     END; /* SELECT */
   CALL DENTEP(RHPTR,SUBENT,RHHDRPT,CPPLCBUF,CPPLUPT,CPPLPSCB,CPPLECT);
 DOALC:PROC(PRMDSN,IO,RETDDN,PRH);
   /* IO='BPA' IF THE DATA SET IS TO BE PROCESSED USING BPAM */
   /* IO='NPR' IF THE USER IS NOT TO BE PROMPTED IF DATA SET IS NEW */
   DCL (DOADSN,PRMDSN) CHAR(44) VARYING;
   DCL LDDDSN CHAR(44);
   DCL LDDDDN CHAR(8);
   DCL DENTBLD ENTRY(PTR,CHAR(112),CHAR(8),CHAR(8))RETURNS(BIT(1));
   DCL (RETDDN,PRH) PTR;
   DCL IO CHAR(3) VAR;
   % INCLUDE DSCB1;
   % INCLUDE JFCB;
   % INCLUDE CTLGDEF;
   % INCLUDE DAIR14;
   DCL JFCBCOR CHAR(176);
   DCL SYSJFCB ENTRY(CHAR(8),PTR);
   DCL DENTLDD ENTRY(CHAR(44))
     RETURNS(CHAR(8));
   DCL VSW BIT(1);
   DCL QUAL CHAR(8) VAR;
   DCL 1 Q1,
     2 QUALEN FIXED BIN(15,0) INIT(80),
     2 ANYN1 FIXED BIN(15,0) INIT(0),
     2 QUALSTR CHAR(76) INIT(' ');
   DCL 1 Q2 DEF Q1,
     2 QUALARY(10) CHAR(8);
   DCL Q3 CHAR(80) DEF Q1;
   DCL MYP CHAR(3) VAR;
   DCL CVOL CHAR(6) INIT('SYSRES');
   DCL RETCODE FIXED BIN(31,0);
   DCL RETCODC CHAR(4) DEF RETCODE;
   DCL RET BIT(32) DEF RETCODE;
   DCL WKAREA CHAR(148);
   DCL DSCB1PTR PTR,PTR1ADJ FIXED BIN(31,0) DEF DSCB1PTR;
   JFCBPTR=ADDR(JFCBCOR);
   DSCB1PTR = ADDR(WKAREA);
   PTR1ADJ = PTR1ADJ - 44;
   DCL SAVRFM BIT(8);
   DCL (MYLRECL,MYBLKL) FIXED BIN(31,0);
   DCL AREA CHAR(265);
   CTLGPTR = ADDR(AREA);
   DCL MOD BUILTIN;
   DCL AINSW BIT(1);
   DCL PREALCSW BIT(1) INIT('0'B);
   RETDDN=NULL;
   AINSW ='0'B;
   SUBSTR(DA08CTL,3,1)='0'B;
   DOADSN = PRMDSN;
   DA08DDN='';
   DA08PDSN=ADDR(TMPDSN@);
   IF SUBSTR(DOADSN,1,1) =''''
     THEN DOADSN=SUBSTR(DOADSN,2,LENGTH(DOADSN)-2);
     ELSE DOADSN=SYMC('&SYSPREF')××'.'××DOADSN;
   I = INDEX(DOADSN,'(');
   IF I ^= 0
     THEN DO;
       DA08MNM=SUBSTR(DOADSN,I+1,LENGTH(DOADSN)-I-1);
       DOADSN=SUBSTR(DOADSN,1,I-1);
       END;
     ELSE DA08MNM='';
   DA14PDSN=ADDR(DOADSN);
   DA14PRET=ADDR(QUALEN);
   CALL SYSDAIR(CPPLUPT,CPPLECT,CPECB,CPPLPSCB,DAIR14,IKJRET);
   IF IKJRET = 0
     THEN IF QUALARY(1) ^= LOW(8)
       THEN DO;
         IF QUALARY(2) = LOW(8)
           THEN DO;
             DOADSN=DOADSN××'.'××SUBSTR(QUALARY(1),1,SUFFIX(QUALARY(1)
             ,' '));
             END;
           ELSE DO;
             CALL #TERM
               ('QUALIFIERS FOR DATA SET '××DOADSN××' ARE ');
             CALL #TERM(Q3);
             QUAL= #PROMPTL('ENTER QUALIFIER-');
             CALL SETCAPS(QUAL);
             DOADSN=DOADSN××'.'××QUAL;
             END;
         END;
   TMPDSN@.DSNSTR=DOADSN;
   TMPDSN@.DSNLEN=LENGTH(DOADSN);
   LDDDSN=DOADSN;
   IF DA08MNM^=''
     THEN LDDDSN=DOADSN××'('××SUBSTR(DA08MNM,1,SUFFIX(DA08MNM,' '))××
       ')';
     ELSE LDDDSN=DOADSN;
   DA08DDN = DENTLDD(LDDDSN);
   IF DA08DDN^=''
     THEN DO;
       PREALCSW='1'B; /* DATA SET IS PREALLOCATED */
       RETCODE=0;
       CALL SYSJFCB(DA08DDN,JFCBPTR);
       VOLID.VOLSER(1)=JFCBVOLS(1);
       END;
     ELSE DO;
       PREALCSW='0'B; /* DATA SET IS NOT PREALLOCATED */
       CALL SYSCTLG('NAME',RET,DOADSN,CVOL,AREA);
       END;
   IF RETCODE ^= 0
     THEN DO;
       IF IO^='NPR'
         THEN DO;
           CALL #TERM('DATA SET '××DOADSN××' DOESN''T EXIST.');
           DO UNTIL(MYP='Y'×MYP='N'×MYP='YES'× MYP='NO'×MYP='');
             MYP= #PROMPTL
                         ('ENTER A NULL LINE, ''YES'', OR ''Y'' TO CREAT
 E A DATA SET, OR ''NO'' OR ''N''');
             CALL SETCAPS(MYP);
             END;
           IF MYP^='YES'& MYP^='Y'& MYP^=''
             THEN RETURN;
           END;
       IF DA08MNM^=''
         THEN @ALLOC(DA,NEW,SP(1,2),TRKS,DIR(27));
         ELSE @ALLOC(DA,NEW,SP(1,2),TRKS);
       DA18DDN=DA08DDN;
       @FREE(DA);
       @ALLOC(DA,SHR);
       IF PRH=NULL
         THEN DO;
           L,MYLRECL=80;
           B,MYBLKL=1680;
           SAVRFM='10010000'B;
           VSW='0'B;
           END;
         ELSE DO;
           L,MYLRECL=PRH->RHLRECL;
           B,MYBLKL=PRH->RHBLKL;
           SAVRFM=PRH->RHRECFM;
           SELECT(SUBSTR(PRH->RHRECFM,1,2));
             WHEN('01'B) VSW='1'B; /* RECFM=VB. */
             WHEN('10'B) VSW='0'B; /* RECFM=FB. */
             OTHERWISE   VSW='0'B; /* RECFM=U */
             END;
           END;
       FETCH DENTFI;
       CALL DENTFI(MYLRECL,MYBLKL,SAVRFM,DA08DDN);
       END;
     ELSE DO;
       CALL SYSVTOC('SEARCH',RET,DOADSN,VOLID.VOLSER(1),WKAREA);
       IF DA08DDN^=''
         THEN DO;
           IF JFCDSORG^='0'B
             THEN DS1DSORG=JFCDSORG;
           IF JFCRECFM^='0'B
             THEN DS1RECFM=JFCRECFM;
           IF JFCLRECL^='0'B
             THEN DS1LRECL=JFCLRECL;
           IF JFCBLKSI^='0'B
             THEN DS1BLKL=JFCBLKSI;
           END;
       CKDS:DO;
         IF RET ^= 0
           THEN LEAVE CKDS;
         IF ^SUBSTR(DS1DSORG,2,1) /* PS? */
           THEN IF SUBSTR(DS1DSORG,7,1) /* PO? */
             THEN IF DA08MNM =''& IO^='BPA'
               THEN DA08MNM ='TEMPNAME';
               ELSE;
             ELSE LEAVE CKDS;
         IF DA08MNM=''
           THEN IF DS1LSTAR='0'B
             THEN AINSW='1'B;
         SELECT(SUBSTR(DS1RECFM,1,2));
           WHEN('01'B)DO; /* RECFM=V */
             VSW ='1'B;
             L = DS1LRECL;
             END;
           WHEN('10'B)DO; /* RECFM=F */
             VSW ='0'B;
             L = DS1LRECL;
             END;
           OTHERWISE DO /* RECFM=U */
           VSW ='1'B;
             L = DS1BLKL;
             END;
           END;
         B=DS1BLKL;
         SAVRFM=DS1RECFM;
         IF DA08DDN=''
           THEN @ALLOC(DA,SHR);
         END CKDS;
       END;
   IF DA08DDN ^=''
     THEN DO;
       ALLOCATE ALCSTR SET(RETDDN);
       /* NOTE THAT THE ALLOCATE WILL SET
       FIELD ALCRECL WITH THE CURRENT
       VALUE OF L. */
       RETDDN->ALCDSN = DOADSN;
       RETDDN->ALCMEM = DA08MNM;
       RETDDN->ALCDDN = DA08DDN;
       RETDDN->ALCFLAG ='0'B;
       SUBSTR(RETDDN->ALCFLAG,5,1)=PREALCSW;
       RETDDN->ALCBLKL=B;
       RETDDN->ALCRECFM=SAVRFM;
       IF DA08MNM ^=''
         THEN DO;
           DA08DDN,LDDDDN=DENTLDD(DOADSN);
           IF LDDDDN=''
             THEN DO;
               DA08MNM='';
               @ALLOC(DA,SHR);
               END;
           FETCH DENTBLD;
           SUBSTR(RETDDN->ALCFLAG,7,1)=^DENTBLD(DCBPATPT,DCBCOR,
             DA08DDN,RETDDN->ALCMEM);
           IF LDDDDN=''
             THEN DO;
               DA18DDN=DA08DDN;
               @FREE(DA);
               END;
           END;
         ELSE SUBSTR(RETDDN->ALCFLAG,7,1)=AINSW;
       SUBSTR(RETDDN->ALCFLAG,3,1) = VSW;
       DO I = LENGTH(RETDDN->ALCDSN) TO 1 BY -1 WHILE(SUBSTR(RETDDN->
       ALCDSN,I,1)^='.');
         END;
       QUAL = SUBSTR(RETDDN->ALCDSN,I+1);
       SELECT(QUAL);
         WHEN('COBOL')DO;
           RETDDN->ALCSEQOFF = 0;
           RETDDN->ALCSEQLEN = 6;
           END;
         WHEN('VSBASIC')DO;
           RETDDN->ALCSEQOFF = 0;
           RETDDN->ALCSEQLEN = 5;
           END;
         OTHERWISE DO;
           RETDDN->ALCSEQLEN = 8;
           IF SUBSTR(RETDDN->ALCFLAG,3,1) /* RECFM = V? */
             THEN RETDDN->ALCSEQOFF = 0;
             ELSE RETDDN->ALCSEQOFF = RETDDN->ALCRECL-8;
           END;
         END;
       IF QUAL ='TEXT'
         THEN SUBSTR(RETDDN->ALCFLAG,8,1)='1'B;
       END;
     ELSE RETDDN = NULL;
   END DOALC;
 DOCMD:PROC(CMD,HELP);
  /*********************************************************************
  * DOCMD, SUBENT(7), SUBENT(49), #DOCMD FOR TSO EXECUTION             *
  *********************************************************************/
   DCL HELP CHAR(4) VAR;
   DCL CMD CHAR(240) VAR;
   IF HELP ='HELP'
     THEN DO;
       @CMD(CMD,MF=S,,HELP);
       END;
     ELSE DO;
       @CMD(CMD,MF=S);
       END;
   END DOCMD;
 DOFRE:PROC(PRMDDN);
   DCL PRMDDN PTR;
   DA18DDN = PRMDDN->ALCDDN;
   @FREE(DA,KEEP);
   FREE PRMDDN->ALCSTR;
   END DOFRE;
 DOPRM:PROC(PRMPT,INP);
   DCL PRMPT CHAR(80) VAR;
   DCL INP CHAR(*) VAR;
   DCL GETCMD ENTRY(PTR,PTR,CHAR(80) VAR, FIXED BIN(31,0),CHAR(*) VAR);
   CALL GETCMD(CPPLUPT,CPPLECT,PRMPT,IKJRET,INP);
   CALL SETCAPS(INP);
   RETURN;
   END DOPRM;
 DOPRMLO:PROC(PRMPT,INP);
   DCL PRMPT CHAR(80) VAR;
   DCL INP CHAR(*) VAR;
   DCL GETCMD ENTRY(PTR,PTR,CHAR(80) VAR, FIXED BIN(31,0),CHAR(*) VAR);
   CALL GETCMD(CPPLUPT,CPPLECT,PRMPT,IKJRET,INP);
   END DOPRMLO;
 DOSTK:PROC(CMD);
   DCL CMD CHAR(*) VAR;
   DCL SP FIXED BIN(15,0) INIT(78);
   DCL IOECB FIXED BIN(31,0) INIT(0);
   DCL 1 STOR78 UNALIGNED BASED(PTR78),
     2 LSDADATA PTR,
     2 LSDRCLEN FIXED BIN(15,0),
     2 LSDTOTLN FIXED BIN(15,0),
     2 LSDANEXT PTR,
     2 LSDRSVRD FIXED BIN(31,0),
     2 STARTLIST FIXED BIN(31,0);
   DCL 1 LISTEL UNALIGNED BASED(LELPTR),
     2 LELLEN FIXED BIN(15,0),
     2 LELCMD CHAR(256) VAR;
   DCL 1 LISTEL2 UNALIGNED BASED(LELPTR),
     2 LELPAD FIXED BIN(15,0),
     2 LELZRO FIXED BIN(15,0);
   DCL (LV,RETCODE) FIXED BIN(31,0);
   LV=LENGTH(CMD)+20;
   CALL SYSGETM('EU',LV,PTR78,SP,RETCODE);
   IF RETCODE^=0
     THEN SIGNAL ERROR;
   LSDADATA,LSDANEXT,LELPTR=ADDR(STARTLIST);
   LSDRCLEN=0;
   LSDTOTLN=LENGTH(CMD)+4;
   LSDRSVRD=0;
   LELCMD=CMD;
   LELLEN=LENGTH(CMD)+4;
   LELZRO=0;
   CALL STACK(CPPLUPT,CPPLECT,IOECB,RETCODE,'PROCN',PTR78);
   END DOSTK;
 SETDSN:PROC(PDEPARM) RETURNS(CHAR(44) VAR);
   DCL PDEPARM CHAR(24);
   DCL DSNRET CHAR(44) VAR;
   DSNRET=SETDSN@(PDEPARM);
   IF DSNRET^=''
     THEN DSNRET=''''××DSNRET××'''';
   RETURN(DSNRET);
   END SETDSN;
 TERMWRT:PROC(TMSG);
   DCL TMSG CHAR(*) VAR;
   BUFLEN@=LENGTH(TMSG)+4;
   BUFSTR@=TMSG;
   CALL PUTLINE(CPPLUPT,CPPLECT,CPECB,BUFFER@,IKJRET,'DATA');
   IF IKJRET^=0
     THEN SIGNAL ERROR;
   END TERMWRT;
 SYMC: PROC(LAB) RETURNS(CHAR(256) VARYING) OPTIONS(REENTRANT);
 /**********************************************************************
 * SYMC RETURNS THE CURRENT REPLACEMENT VALUE FOR A GIVEN SYMBOLIC     *
 * VARIABLE.                                                           *
 **********************************************************************/
   MYHD = SYMHD@;
   DCL MYHD PTR,
       MYHDC CHAR(4) DEF MYHD;
   DCL (DATE,TIME) BUILTIN;
   DCL DTSTR CHAR(8);
   DCL SYMSW BIT(1) INIT('0'B);
   % DCL SYSCNT@ FIXED;
        /* SYSCNT@ = NUMBER OF GLOBAL VARIABLES */
   % SYSCNT@ = 7;
   DCL SYSLAB(SYSCNT@) LABEL;
   DCL SYSTAB(SYSCNT@) CHAR(8) STATIC INIT(
     '&SYSUID',
     '&LASTCC',
     '&SYSDATE',
     '&SYSTIME',
     '&SYSPREF',
     '&SYSACCT',
     '&SYSNAME');
   DCL IRC FIXED BIN(31,0);
   DCL LAB CHAR(*);
   DCL 1 SYMTAB BASED(SYMPTR),
        2 NXTPTR PTR,
        2 LSTPTR PTR,
        2 SYMBOL CHAR(8),
        2 MAXLEN FIXED BIN(15,0),
        2 CURLEN FIXED BIN(15,0),
        2 TEXT CHAR(TXTLEN REFER(MAXLEN));
   DCL TXTLEN FIXED BIN(15,0);
   % INCLUDE @CVT;
   DCL 1 JCT BASED(JCTPTR),
     2 PAD CHAR(56),
     2 ACTP BIT(24);
   DCL 1 ACT BASED(ACTPTR),
     2 PAD1 CHAR(24),
     2 NAME CHAR(20),
     2 PAD2 CHAR(3),
     2 FLDCNT BIT(8),
     2 LEN BIT(8),
     2 ACCOUNT CHAR(200);
   DCL DUMPTR PTR,
       DUMADJ FIXED BIN(31,0) DEF DUMPTR;
   DO SYMPTR=MYHD REPEAT SYMPTR->NXTPTR WHILE(SYMPTR ^= NULL);
     IF SYMBOL = LAB
       THEN RETURN(SUBSTR(TEXT,1,CURLEN));
     END;
   DO I = 1 TO SYSCNT@ WHILE(SYSTAB(I) ^= LAB);
        END;
   IF I > SYSCNT@
        THEN RETURN('');
   SELECT(I);
     WHEN(1) DO;  /* USERID */
       DO I = 1 TO 7 WHILE(SUBSTR(PSCBUSER,I,1) ^= ' ');
         END;
       RETURN(SUBSTR(PSCBUSER,1,I-1));
       END;
     WHEN(2) DO; /* LAST RETURN CODE */
       IRC = ECTRTCD;
       RETURN(IRC);
       END;
     WHEN(3) DO; /* DATE */
       DTSTR = DATE;
       DTSTR=SUBSTR(DTSTR,3,2)××'/'××SUBSTR(DTSTR,5,2)××'/'××
         SUBSTR(DTSTR,1,2);
       RETURN(DTSTR);
       END;
     WHEN(4) DO; /* TIME */
       DTSTR = TIME;
       DTSTR=SUBSTR(DTSTR,1,2)××':'××SUBSTR(DTSTR,3,2)××':'××
         SUBSTR(DTSTR,5,2);
       RETURN(DTSTR);
       END;
     WHEN(5) DO; /* PREFIX */
       I = UPTPREFL;
       RETURN(SUBSTR(UPTPREFX,1,I));
       END;
     WHEN(6,7) DO; /* SYSACCT,SYSNAME */
       JCTPTR=@CVT(0,0,1,45,65);
       DUMADJ=BIN(ACTP);
       ACTPTR=DUMPTR;
       IF I = 6
         THEN DO; /* SYSACCT */
           L=BIN(LEN);
           RETURN(SUBSTR(ACCOUNT,1,L));
           END;
         ELSE     /* SYSNAME */
           RETURN(SUBSTR(NAME,1,SUFFIX(NAME,' ')));
       END;
     OTHERWISE RETURN('');
     END; /* SELECT */
   END SYMC;
 REP@:  PROC(BUF) OPTIONS(REENTRANT);
 /**********************************************************************
 * REP @                                                               *
 * THIS PROCEDURE CAN BE INVOKED TO PERFORM REPLACEMENT OF             *
 * VARIABLES IN A CHARACTER STRING WITH VALUES THEY HAVE BEEN          *
 * PREVIOUSLY BEEN ASSIGNED.  SEE ALSO DOCUMENTATION FOR THE SYMC      *
 * AND SET@ SUBROUTINES.  CALL FORMAT IS AS FOLLOWS -                  *
 *                                                                     *
 * CALL REP@(BUFFER);                                                  *
 *                                                                     *
 * WHERE BUFFER IS DECLARED AS FOLLOWS -                               *
 *                                                                     *
 * DCL 1 BUFFER,                                                       *
 *      2 BUFLEN FIXED BIN(15,0),                                      *
 *      2 OFFSET FIXED BIN(15,0),                                      *
 *      2 BUF CHAR(*);                                                 *
 *                                                                     *
 * BUFLEN MUST CONTAIN THE LENGTH OF TEXT IN BUF PLUS 4, NOT           *
 * COUNTING BLANKS PADDED ON THE RIGHT.  NOTE THAT SUFFICIENT SPACE    *
 * SHOULD BE ALLOWED FOR EXPANSION AS THE VARIABLES IN BUF             *
 * ARE REPLACED WITH THEIR ASSIGNED VALUES.  AS REPLACEMENT OCCURS,    *
 * REP@ WILL UPDATE BUFLEN TO REFLECT EXPANSION OR CONTRACTION OF THE  *
 * TEXT.                                                               *
 **********************************************************************/
   DCL 1 BUF,
     2 BUFLEN FIXED BIN(15,0),
     2 OFFSET FIXED BIN(15,0),
     2 BUFFER CHAR(*);
   DCL TXT CHAR(256) VARYING;
   DCL (I,J,K,L,IL,INDX) FIXED BIN(15,0);
   IL = LENGTH(BUFFER);
   DO INDX=0 REPEAT INDX-1 WHILE(INDX < BUFLEN-4);
     I = INDEX(SUBSTR(BUFFER,INDX+1,BUFLEN-4-INDX),'&');
     IF I = 0
       THEN RETURN;
     INDX = INDX+I;
     IF SUBSTR(BUFFER,INDX+1,1) = '&'
       THEN DO;
         BUFLEN = BUFLEN-1;
         SUBSTR(BUFFER,INDX+1,IL-INDX) =
           SUBSTR(BUFFER,INDX+2,IL-INDX-1);
         INDX=INDX+1;
         END;
       ELSE DO;
         I = PREFIX(SUBSTR(BUFFER,INDX+1,7),
           'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789');
         IF I = 0
           THEN I = 8;
         TXT = SYMC(SUBSTR(BUFFER,INDX,I));
         L = LENGTH(TXT);
         IF SUBSTR(BUFFER,INDX+I,1) = '.'
           THEN I = I + 1;
         BUFLEN = BUFLEN-I+L;
         IF BUFLEN > IL
           THEN BUFLEN = IL;
         J = INDX+I;
         IF IL > J
           THEN SUBSTR(BUFFER,INDX,IL-INDX) = TXT ××
             SUBSTR(BUFFER,J,IL-J);
           ELSE SUBSTR(BUFFER,INDX,IL-INDX) = TXT;
         END;
     END;
   END REP@;
 SET@:  PROC(GBLSW,SYMBOLPM,TEXTPM) OPTIONS(REENTRANT);
 /**********************************************************************
 * SET@ IS CALLED TO SET THE REPLACEMENT VALUE FOR A SYMBOLIC VARIABLE.*
 **********************************************************************/
   DCL GBLSW BIT(1);
   DCL SYMBOLPM CHAR(8);
   DCL TEXTPM CHAR(256) VARYING;
   DCL 1 SYMTAB BASED(SYMPTR),
        2 NXTPTR PTR,
        2 LSTPTR PTR,
        2 SYMBOL CHAR(8),
        2 MAXLEN FIXED BIN(15,0),
        2 CURLEN FIXED BIN(15,0),
        2 TEXT CHAR(TXTLEN REFER(MAXLEN));
   DCL TXTLEN FIXED BIN(15,0);
   DCL (SYMPTRA,SYMPTRB) PTR;
   TXTLEN = LENGTH(TEXTPM);
   SYMPTRA=NULL;
   DO SYMPTR=SYMHD@ REPEAT NXTPTR WHILE(SYMPTR^=NULL)
     UNTIL(SYMBOL>=SYMBOLPM);
     SYMPTRA=SYMPTR; /* SAVE POINTER TO PREVIOUS STRUCTURE */
     END;
   IF SYMPTR^=NULL
     THEN IF SYMBOL=SYMBOLPM
       THEN IF TXTLEN > MAXLEN
         THEN DO;
           IF NXTPTR^=NULL
             THEN SYMPTRA=NXTPTR;
             ELSE SYMPTRA=LSTPTR;
           /* FIRST DEQUEUE OLD ENTRY */
           IF LSTPTR^=NULL
             THEN LSTPTR->NXTPTR=NXTPTR;
           IF NXTPTR^=NULL
             THEN NXTPTR->LSTPTR=LSTPTR;
           FREE SYMTAB;
           SYMPTR=SYMPTRA;
           IF SYMPTR^=NULL
             THEN IF NXTPTR=NULL
               THEN SYMPTR=NULL;
           END;
         ELSE DO;
           TEXT=TEXTPM;
           CURLEN=TXTLEN;
           RETURN;
           END;
   /* IT IS A BRAND NEW SYMBOL, OR A BIGGER VERSION OF AN OLD ONE */
   ALLOCATE SYMTAB;
   SYMBOL=SYMBOLPM;
   CURLEN=MAXLEN;
   TEXT=TEXTPM;
   IF SYMPTRA=NULL
     THEN LSTPTR,NXTPTR=NULL;/* NEW ELEMENT IS ONLY IN QUEUE */
     ELSE IF SYMBOL>SYMPTRA->SYMBOL
       THEN DO; /* NEW ELEMENT IS LAST IN QUEUE */
         LSTPTR=SYMPTRA;
         NXTPTR=NULL;
         END;
       ELSE DO; /* NEW ELEMENT GOES IN FRONT OF SYMPTRA */
         LSTPTR=SYMPTRA->LSTPTR;
         NXTPTR=SYMPTRA;
         END;
   IF LSTPTR^=NULL
     THEN LSTPTR->NXTPTR=SYMPTR;
   IF NXTPTR^=NULL
     THEN NXTPTR->LSTPTR=SYMPTR;
   IF LSTPTR=NULL
     THEN SYMHD@=SYMPTR; /* IT IS FIRST IN QUEUE */
   END SET@;
  END;
