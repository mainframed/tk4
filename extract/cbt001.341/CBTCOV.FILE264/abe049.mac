 /* COPYRIGHT 1983 BY THOMAS GLEN SMITH */
 /* ABE049 - SELECT, UPDATE, ORDER, LOCATE, REMOVE, UPDATEC */
 /* 1        2       3       4      5       6       7       */
   %INCLUDE ABESUB;
 ABESUB(ABE049) CHECK(YES);
   %INCLUDE ABESUBA;

   % INCLUDE ABESEL;
   DCL (ABE49A,ABE49B,ABE49C,ABE49L,ABE49R,ABE49S) ENTRY;
   DCL ABE49U ENTRY(,,,,CHAR(*));

   DCL SCANNER ENTRY;
   DCL SETCAPS ENTRY;
   DCL (PREFIX,SUFFIX) ENTRY(CHAR(*), CHAR(*))
     RETURNS(FIXED BIN(15,0));
   DCL POLISH ENTRY RETURNS(PTR);
   DCL CALCPRT ENTRY(DEC FLOAT(16))
     RETURNS(CHAR(80) VAR);
   DCL (TPTR,RHP,P) PTR;
   DCL DO_STACK PTR;
   DCL SAVE_SRCH_PTR PTR;
   DCL QNUMBER FIXED BIN(31,0) INIT(0);
   DCL TYPETAB(8) CHAR(8) VAR STATIC INIT(
     'FLOAT','CHAR','CHAR','PACKED','HEX','BIT','FIXED','BEST');
   DCL PTRIN ENTRY(PTR)
     RETURNS(FIXED BIN(31,0));
   DCL PTROUT ENTRY(FIXED BIN(31,0))
     RETURNS(PTR);
   DCL CONVERT ENTRY(PTR,
     CHAR(*),FIXED BIN(15,0),FIXED BIN(15,0),
     CHAR(*),FIXED BIN(15,0),FIXED BIN(15,0))
     RETURNS(CHAR(256) VAR);
   DCL KEYWORDS(38) CHAR(12) VAR STATIC INIT(
   /* NILADIC FUNCTIONS */
   /*  1 */ 'DATE',         /*  2 */ 'ECHO',      /*  3 */ 'LIST',
   /*  4 */ 'TIME',
   /* MONADIC FUNCTIONS */
   /*  5 */ 'ABS',          /*  6 */ 'ACOS',      /*  7 */ 'ASIN',
   /*  8 */ 'ATAN',         /*  9 */ 'ATAND',     /* 10 */ 'ATANH',
   /* 11 */ 'CEIL',         /* 12 */ 'COS',       /* 13 */ 'COSD',
   /* 14 */ 'COSH',         /* 15 */ 'ERF',       /* 16 */ 'ERFC',
   /* 17 */ 'EXP',          /* 18 */ 'FACT',
   /* 19 */ 'FIXED',        /* 20 */ 'FLOOR',
   /* 21 */ 'LOG',          /* 22 */ 'LOG2',      /* 23 */ 'LOG10',
   /* 24 */ 'SIGN',         /* 25 */ 'SIN',       /* 26 */ 'SIND',
   /* 27 */ 'SINH',         /* 28 */ 'SQRT',      /* 29 */ 'TAN',
   /* 30 */ 'TAND',         /* 31 */ 'TANH',      /* 32 */ 'TRUNC',
   /* 33 */ 'RND',          /* 34 */ 'INT',
   /* DYADIC FUNCTIONS */
   /* 35 */ 'MOD',          /* 36 */ 'ROUND',
   /* POLYADIC FUNCTIONS */
   /* 37 */ 'MAX',          /* 38 */ 'MIN'
   );
   /* SQL/DS KEYWORDS #/
   NOTE: THESE KEYWORDS WERE PART OF THE KEYWORDS ARRAY.  THEY WERE
   TAKEN OUT BECAUSE I DON'T THINK THEY ARE NEEDED, AND IN FACT,
   IF THEY ARE IN THE KEYWORDS ARRAY, ARE CONSIDERED TO BE RESERVED
   WORDS.
   /# 34 #/ 'ACQUIRE',      /# 35 #/ 'ADD',       /# 36 #/ 'ALL',
   /# 37 #/ 'ALTER',        /# 38 #/ 'AND',       /# 39 #/ 'ANY',
   /# 40 #/ 'AS',           /# 41 #/ 'ASC',       /# 42 #/ 'AVG',
   /# 43 #/ 'BETWEEN',      /# 44 #/ 'BY',        /# 45 #/ 'CHAR',
   /# 46 #/ 'COLUMN',       /# 47 #/ 'COMMENT',   /# 48 #/ 'COMMIT',
   /# 49 #/ 'CONNECT',      /# 50 #/ 'COUNT',     /# 51 #/ 'CREATE',
   /# 52 #/ 'CURRENT',      /# 53 #/ 'DBA',       /# 54 #/ 'DBSPACE',
   /# 55 #/ 'DECIMAL',      /# 56 #/ 'DELETE',    /# 57 #/ 'DESC',
   /# 58 #/ 'DISTINCT',     /# 59 #/ 'DROP',      /# 60 #/ 'EXCLUSIVE',
   /# 61 #/ 'EXISTS',       /# 62 #/ 'FLOAT',     /# 63 #/ 'FOR',
   /# 64 #/ 'FROM',         /# 65 #/ 'GRANT',     /# 66 #/ 'GROUP',
   /# 67 #/ 'HAVING',       /# 68 #/ 'IABEIFIED',/# 69 #/ 'IN',
   /# 70 #/ 'INDEX',        /# 71 #/ 'INSERT',    /# 72 #/ 'INTEGER',
   /# 73 #/ 'INTO',         /# 74 #/ 'IS',        /# 75 #/ 'LIKE',
   /# 76 #/ 'LOCK',         /# 77 #/ 'LONG',      /# 78 #/ 'MAX',
   /# 79 #/ 'MIN',          /# 80 #/ 'MODE',      /# 81 #/ 'NAMED',
   /# 82 #/ 'NHEADER',      /# 83 #/ 'NOT',       /# 84 #/ 'NULL',
   /# 85 #/ 'OF',           /# 86 #/ 'ON',        /# 87 #/ 'OPTION',
   /# 88 #/ 'OR',           /# 89 #/ 'ORDER',     /# 90 #/ 'PAGE',
   /# 91 #/ 'PAGES',        /# 92 #/ 'PCTFREE',   /# 93 #/ 'PCTINDEX',
   /# 94 #/ 'PRIVATE',      /# 95 #/ 'PRIVILEGES',/# 96 #/ 'PROGRAM',
   /# 97 #/ 'PUBLIC',       /# 98 #/ 'RELEASE',   /# 99 #/ 'RESOURCE',
   /#100 #/ 'REVOKE',       /#101 #/ 'ROLLBACK',  /#102 #/ 'ROW',
   /#103 #/ 'RUN',          /#104 #/ 'SCHEDULE',  /#105 #/ 'SELECT',
   /#106 #/ 'SET',          /#107 #/ 'SHARE',     /#108 #/ 'SMALLINT',
   /#109 #/ 'STATISTICS',   /#110 #/ 'STORPOOL',  /#111 #/ 'SUM',
   /#112 #/ 'SYNONYM',      /#113 #/ 'TABLE',     /#114 #/ 'TO',
   /#115 #/ 'UNION',        /#116 #/ 'UNIQUE',    /#117 #/ 'UPDATE',
   /#118 #/ 'USER',         /#119 #/ 'VALUES',    /#120 #/ 'VARCHAR',
   /#121 #/ 'VIEW',         /#122 #/ 'WHERE',     /#123 #/ 'WITH',
                                                  /#190 #/ 'WORK'
   */
   DCL OPERATORS(17) CHAR(2) VAR STATIC INIT(
     '**',  /*  1 */
     '^>',  /*  2 */
     '>=',  /*  3 */
     '^=',  /*  4 */
     '<=',  /*  5 */
     '^<',  /*  6 */
     '<',   /*  7 */
     '=',   /*  8 */
     '>',   /*  9 */
     '×',   /* 10 */
     '&',   /* 11 */
     '*',   /* 12 */
     '/',   /* 13 */
     '+',   /* 14 */
     '-',   /* 15 */
     '^',   /* 16 */
     '#');  /* 17 (ASSIGNMENT) */
   DCL PRECEDENCE(2,17) FIXED BIN(15,0) STATIC INIT(
     /* DIADIC OPERATOR PRECEDENCE */
     -2, /*  1 - ** */
      5, /*  2 - ^> */
      5, /*  3 - >= */
      5, /*  4 - ^= */
      5, /*  5 - <= */
      5, /*  6 - ^< */
      5, /*  7 - <  */
      5, /*  8 - =  */
      5, /*  9 - >  */
      7, /* 10 - ×  */
      6, /* 11 - &  */
      3, /* 12 - *  */
      3, /* 13 - /  */
      4, /* 14 - +  */
      4, /* 15 - -  */
      0, /* 16 - ^  */
     -1, /* 17 - #  */
     /* MONADIC OPERATOR PRECEDENCE */
      0, /*  1 - ** */
      0, /*  2 - ^> */
      0, /*  3 - >= */
      0, /*  4 - ^= */
      0, /*  5 - <= */
      0, /*  6 - ^< */
      0, /*  7 - <  */
      0, /*  8 - =  */
      0, /*  9 - >  */
      0, /* 10 - ×  */
      0, /* 11 - &  */
      0, /* 12 - *  */
      0, /* 13 - /  */
      1, /* 14 - +  */
      1, /* 15 - -  */
      1, /* 16 - ^  */
     -1);/* 17 - #  */
   DCL SPCHARS CHAR(2) VAR STATIC INIT('()');
   DCL (TRH,TRHNXT) PTR;
   %INCLUDE ABEMISS;
   DCL CH CHAR(8) VAR;
   DCL CMDNAME CHAR(9);
   DCL ZD FIXED BIN(15,0) STATIC INIT(3); /* ZONED DECIMAL TYPE */
   DCL CHR FIXED BIN(15,0) STATIC INIT(2); /* CHAR TYPE */


   /********************************************************************
   * START OF INITIALIZATION CODE                                      *
   ********************************************************************/

   DO_STACK=NULL;
   CHAR_CHECK=CHAR_CHECK_REAL;
   CLEAN_HTEXT=ABE49C;
   CONVERT_INTFC=#CONVERT;
   COPYTOK=COPYTOK_REAL;
   DEL_LIST=DEL_LIST_REAL;
   DELTOK=DELTOK_REAL;
   DO_SELECT=ABE49B;
   DUM_ODD_FUNCTION=DUM_ODD_FUNCTION_REAL;
   DUM_PUT_OPERAND=DUM_PUT_OPERAND_REAL;
   END_CLAUSE=END_CLAUSE_REAL;
   EVAL_COMMON=EVAL_COMMON_REAL;
   EXPNEXT=EXPNEXT_REAL;
   FIND_FIELD=FIND_FIELD_REAL;
   GET_OPERAND=GET_OPERAND_REAL;
   GET_SET=GET_SET_REAL;
   GETDATA=GETDATA_REAL;
   GETDATC_SUB=GETDATC_SUB_REAL;
   GETDATC=GETDATC_REAL;
   GETFIELD=GETFIELD_REAL;
   LIST_QUERY_TYPE=LIST_QUERY_TYPE_REAL;
   LOC_DB=LOC_DB_REAL;
   LOC_DBD=LOC_DBD_REAL;
   MYSCAN=SCANNER;
   ODD_FUNCTION_COMMON=ODD_FUNCTION;
   PARSE_SELECT=ABE49A;
   QNUM=QNUM_REAL;
   QNUMSTR=QNUMSTR_REAL;
   QUEUE=QUEUE_REAL;
   RUN_BUF=RUN_BUF_REAL;
   RUN_SORT=ABE49S;
   SELECT_LIST=SELECT_LIST_REAL;
   SET_FIELD=SET_FIELD_REAL;
   SIGNUM=SIGNUM_REAL;
   SIGNUM_COMMON=SIGNUM_COMMON_REAL;
   SINGLE_QUEUE=SINGLE_QUEUE_REAL;
   SUBQUERY_TYPE=SUBQUERY_TYPE_REAL;
   SUBQUERY_TYPE_SUB=SUBQUERY_TYPE_SUB_REAL;
   WHERE_EVAL=WHERE_EVAL_REAL;

   RHRC=0;
   SUBQ_FIRST,SUBQ_LAST=NULL;
   SUBQ_CNT=0;

   ON CONDITION(BADSTMT) BEGIN;
     IF MSGDATA=''
       THEN MSGDATA='INVALID SELECT STATEMENT';
     RHRC=8;
     GOTO CLEANUP;
     END;

   /* NOW FIND HIGHEST QNUMBER CURRENTLY IN USE */
   DO TRH=NXTRHEL REPEAT TRH->RHNXT WHILE(TRH^=NULL);
     QNUMBER=MAX(QNUM(TRH->RHNAME,'Q'),QNUMBER);
     END;

   /********************************************************************
   * START OF MAINLINE CODE                                            *
   ********************************************************************/

   SELECT(CMDINDX);
     WHEN(1,2) CMDNAME='SELECT';
     WHEN(3)   CMDNAME='UPDATE';
     WHEN(4)   CMDNAME='ORDER';
     WHEN(5)   CMDNAME='LOCATE';
     WHEN(6)   CMDNAME='REMOVE';
     WHEN(7)   CMDNAME='UPDATEC';
     END; /* SELECT */
   CALL PARSE_SELECT(CMDNAME××CMDBUF,
     MSGDATA,RHRC,SUBQ_HDR,SUBRTNES,OPERATORS,
     KEYWORDS,SPCHARS,PRECEDENCE,MAINPARM); /* GO PARSE */
   IF RHRC=0
     THEN DO; /* NOW RESCAN THE QUEUE OF TOKENS */
       MCURTOK=MTOKHDR;
       SELECT(MCURTOK->TOKSTR);
         WHEN('SELECT0001') DO;
           RHP=DO_SELECT(SUBQ_FIRST,
             RHPTR,RHHDRPT,SUBQ_HDR,SUBRTNES,DO_STACK);
           IF RHP^=NULL
             THEN IF QNUM(RHP->RHNAME,'Q')>=0
               THEN CALL #ABEDFN(RHP,RHHDRPT); /* CALL ABEDFN */
           END;
         WHEN('UPDATE','UPDATEC')
           CALL ABE49U(RHPTR,RHHDRPT,SUBRTNES,SUBQ_FIRST,
             MCURTOK->TOKSTR);
         WHEN('ORDER')  CALL ABE49S(RHPTR,RHHDRPT,SUBRTNES,SUBQ_FIRST);
         WHEN('LOCATE') CALL ABE49L(RHPTR,RHHDRPT,SUBRTNES,SUBQ_FIRST);
         WHEN('REMOVE') CALL ABE49R(RHPTR,RHHDRPT,SUBRTNES,SUBQ_FIRST);
         OTHERWISE DO;
           MSGDATA='INVALID SUBCOMMAND NAME';
           SIGNAL CONDITION(BADSTMT);
           END;
         END;
       END;

 CLEANUP:
   /* NOW CLEAN UP MEMORY */
   DO P=DO_STACK REPEAT DO_STACK WHILE(P^=NULL);
     DO_STACK=P->SUBQ_NEXT;
     P->SUBQ_NEXT,P->SUBQ_PREV=NULL;
     CALL CLEAN_HTEXT(RHPTR,RHHDRPT,SUBRTNES,P,'EXEC');
     END;

   DO P=SUBQ_FIRST REPEAT SUBQ_FIRST WHILE(P^=NULL);
     SUBQ_FIRST=P->SUBQ_NEXT;
     P->SUBQ_NEXT,P->SUBQ_PREV=NULL;
     CALL CLEAN_HTEXT(RHPTR,RHHDRPT,SUBRTNES,P,'NXEC');
     END;

   /* NOW DO AN 'END N' FOR ALL TEMPORARY DATA SETS */
   DO TRH=NXTRHEL REPEAT TRHNXT WHILE(TRH^=NULL);
     TRHNXT=TRH->RHNXT;
     IF TRH^=RHPTR
       THEN IF SUBSTR(TRH->RHNAME,1,1)='Q'
         THEN DO;
           CH=SUBSTR(TRH->RHNAME,2);
           CH=SUBSTR(CH,1,SUFFIX(CH,' '));
           IF VERIFY(CH,'0123456789')=0
             THEN I=#CMD('END NOSAVE',TRH,RHHDRPT);
           END;
     END;

   RETURN;

 CHAR_CHECK_REAL: PROC(D);
 /**********************************************************************
 *                                                                     *
 * CHAR_CHECK IS CALLED JUST BEFORE A SELECT IS EXECUTED TO CHECK ALL  *
 * EXPRESSIONS FOR OPERATIONS INVOLVING CHARACTER STRINGS.  THE SIGN   *
 * OF THE SUBTYPE FIELD FOR ALL TOKEN ELEMENTS REPRESENTING OPERATIONS *
 * INVOLVING CHARACTER STRINGS WILL BE NEGATED.  THIS WILL CAUSE       *
 * CALCEVB TO CALL GET_OPERAND_CHAR RATHER THAN GET_OPERAND TO OBTAIN  *
 * OPERANDS.                                                           *
 *                                                                     *
 **********************************************************************/
   DCL (D,E,S,W) PTR;

   /* FIRST CHECK ALL SELECT-LIST ELEMENTS FOR EXPRESSIONS */
   DO S=D->SELECT_LIST_PTR REPEAT S->SELECT_NEXT_FIELD WHILE(S^=NULL);
     IF S->SELECT_EXP /* IS IT AN EXPRESSION? */
       THEN CALL CHAR_CHECK_SUB(D,S->FIELD_EXP_HDR);
     END;

   /* NOW CHECK THE WHERE_CLAUSE FOR EXPRESSIONS */
   IF D->WHERE_PTR^=NULL
     THEN CALL CHAR_CHECK_SRCH(D,D->WHERE_PTR);

   /* NOW CHECK GROUP-BY CLAUSE FOR EXPRESSIONS */
   IF D->GROUP_BY_PTR^=NULL
     THEN IF D->GROUP_BY_PTR->GROUP_SEARCH_CONDITION^=NULL
       THEN CALL CHAR_CHECK_SRCH(D,
         D->GROUP_BY_PTR->GROUP_SEARCH_CONDITION);

   END CHAR_CHECK_REAL;

 CHAR_CHECK_SRCH: PROC(D,S);
 /**********************************************************************
 *                                                                     *
 * CALLED TO CHECK ANY EXPRESSIONS IN A GIVEN SEARCH_CONDITION_BLOCK   *
 * FOR CHARACTER-STRING OPERATIONS.  THE SUBTYPES FOR THE OPERATORS    *
 * INVOLVED WILL BE NEGATED TO CAUSE CALCEVB TO DO CHARACTER STRING    *
 * OPERATIONS.                                                         *
 *                                                                     *
 **********************************************************************/
   DCL (D,E,S,T,W) PTR;
   DCL I FIXED BIN(15,0);

   SELECT;
     WHEN(S->SIMPLE)
       CALL CHAR_CHECK_SUB(D,S->SEARCH_EXP(1));
     WHEN(S->BETWEEN) DO I=2 TO 3;
       CALL CHAR_CHECK_SUB(D,S->SEARCH_EXP(I));
       END;
     WHEN(S->IN) DO;
       DO T=S->SEARCH_EXP(2) REPEAT T->SELECT_NEXT_FIELD WHILE(T^=NULL);
         IF T->SELECT_EXP /* IS IT AN EXPRESSION? */
           THEN CALL CHAR_CHECK_SUB(D,T->FIELD_EXP_HDR);
         END;
       END;
     OTHERWISE;
     END; /* SELECT */

   END CHAR_CHECK_SRCH;

 CHAR_CHECK_SUB: PROC(D,S);
 /**********************************************************************
 *                                                                     *
 * CALLED TO CHECK A GIVEN EXPRESSION FOR CHARACTER-STRING OPERATIONS. *
 * THE SUBTYPES FOR THE OPERATORS INVOLVED WILL BE NEGATED TO CAUSE    *
 * CALCEVB TO DO CHARACTER STRING OPERATIONS.                          *
 *                                                                     *
 **********************************************************************/
   DCL (D,FR,RH,S,T) PTR;
   DCL I FIXED BIN(15,0);
   DCL STRSW BIT(1) INIT('0'B);
   DCL (FNAME,DNAME) CHAR(8);

   /* NOW CHECK FOR CHARACTER STRING OPERATIONS */
   DO T=S REPEAT T->NEXT_TOKEN WHILE(T^=NULL);
     SELECT;
       WHEN(T->TYPE=OPERATOR) DO;
         IF STRSW
           THEN DO;
             STRSW='0'B;
             T->SUBTYPE=-T->SUBTYPE;
             END;
         END;
       WHEN(T->TYPE=QUOTED_STRING)
         STRSW='1'B;
       WHEN(T->TYPE=OPERAND) DO;
         CALL GET_SET(D,T,DNAME,FNAME,FR); /* GO SET DNAME,FNAME */
         RH=FIND_FIELD(D,DNAME,FNAME,FR); /* GET A(RHNAMESTR) */
         IF RH^=NULL
           THEN IF RH->RHNTYPE=2 /* IS IT CHAR */
             THEN STRSW='1'B;
         END;
       OTHERWISE;
       END; /* SELECT */
     END;

   END CHAR_CHECK_SUB;

 COPYTOK_REAL: PROC(PPTR) RETURNS(PTR);
 /**********************************************************************
 * CALLED TO MAKE A COPY OF A TOKEN STRUCTURE.                         *
 **********************************************************************/
   DCL (PPTR,NEXT) PTR;
   ALLOCATE TOKEN SET(NEXT); /* ALLOCATE FOR COPY */
   NEXT->TOKEN=PPTR->TOKEN;
   NEXT->NEXT_TOKEN=NULL;
   NEXT->PRIOR_TOKEN=NEXT;
   RETURN(NEXT);
   END COPYTOK_REAL;

 DEL_LIST_REAL: PROC(LPTR);
 /**********************************************************************
 * CALLED TO FREE THE STORAGE ALLOCATED FOR THE SELECT_LIST POINTED TO *
 * BY PARAMETER LPTR.                                                  *
 **********************************************************************/
   DCL (LPTR,LIST,TOK) PTR;
   LIST=LPTR;
   DO WHILE(LIST^=NULL);
     TOK=LIST->FIELD_EXP_HDR;
     DO WHILE(TOK^=NULL);
       DEL=TOK;
       TOK=TOK->NEXT_TOKEN;
       FREE DEL->TOKEN;
       END;
     DEL=LIST;
     LIST=LIST->SELECT_NEXT_FIELD;
     FREE DEL->SELECT_LIST_ELEMENT;
     END;
   END DEL_LIST_REAL;

 DELTOK_REAL: PROC(PPTR);
 /**********************************************************************
 * CALLED TO DELETE THE LAST TOKEN IN THE QUEUE OF TOKENS POINTED TO BY*
 * PPTR.                                                               *
 **********************************************************************/
   DCL (PPTR,DELPTR) PTR;
   DELPTR=PPTR->PRIOR_TOKEN; /* DELPTR POINTS TO LAST TOKEN IN QUEUE */
   PPTR->PRIOR_TOKEN=DELPTR->PRIOR_TOKEN;
   DELPTR->PRIOR_TOKEN->NEXT_TOKEN=NULL;
   FREE DELPTR->TOKEN;
   END DELTOK_REAL;

 DUM_ODD_FUNCTION_REAL: PROC RETURNS(CHAR(256) VAR);
   MSGDATA='FUNCTION NOT RECOGNIZED IN WHERE-CLAUSE EXPRESSION';
   SIGNAL CONDITION(BADSTMT);
   END DUM_ODD_FUNCTION_REAL;

 DUM_PUT_OPERAND_REAL: PROC(PRMPTR,VALUE,MSG);
   DCL PRMPTR PTR;
   DCL VALUE FLOAT DEC(16);
   DCL (MSG,TXT) CHAR(80) VAR;

   CALL #SETA(RHHDRPT,RH_SYMTREE,PRMPTR->TOKSTR,VALUE);
   END DUM_PUT_OPERAND_REAL;

 END_CLAUSE_REAL: PROC(PRMPTR) RETURNS(BIT(1));
 /**********************************************************************
 * CALLED TO DETERMINE WHETHER THE END OF THE CURRENT CLAUSE HAS BEEN  *
 * REACHED.  THE DETERMINATION IS MADE BY CHECKING THE TOKEN POINTED TO*
 * BY PRMPTR. IF IT POINTS TO THE NO_MORE_TOKENS TOKEN,                *
 * OR TO A KEYWORD TOKEN BEGINNING A NEW CLAUSE, END_CLAUSE WILL RETURN*
 * '1'B.  OTHERWISE IT WILL RETURN '0'B.                               *
 **********************************************************************/
   DCL PRMPTR PTR;
   IF PRMPTR->TYPE=NO_MORE_TOKENS
     THEN RETURN('1'B);
   SELECT(PRMPTR->TOKSTR);
     WHEN('FROM','WHERE','GROUP','ORDER','TO','DBD','ORDER','BY',
       'MERGE','SET','UPDATE','DROP','DISPLAY','RENAME') RETURN('1'B);
     OTHERWISE RETURN('0'B);
     END; /* SELECT */
   END END_CLAUSE_REAL;

 EVAL_COMMON_REAL: PROC(D,S,C,EVAL_ODD_FUNCTION)
   RETURNS(CHAR(256) VAR);
 /**********************************************************************
 *                                                                     *
 * CALLED TO EVALUATE AN EXPRESSION POINTED TO BY THE                  *
 * SELECT_LIST_ELEMENT POINTED TO BY PARAMETER S.  D POINTS TO THE     *
 * SELECT_HTEXT CONTROL BLOCK, AND C POINTS TO THE RHNAMESTR FROM      *
 * WHICH A DESCRIPTION OF THE DESIRED OUTPUT FORMAT WILL BE EXTRACTED. *
 *                                                                     *
 **********************************************************************/
   DCL (C,D,R,S) PTR;
   DCL EVAL_ODD_FUNCTION ENTRY;
   DCL RET DEC FLOAT(16),
       RETCH CHAR(8) DEF RET;
   DCL STR CHAR(256) VAR INIT('');
   DCL ECHOSW BIT(1);
   DCL VAL FLOAT DEC(16) INIT(1),
       VALCH CHAR(8) DEF VAL;
   DCL MSG CHAR(80) VAR INIT('');

   IF S->SELECT_EXP
     THEN DO;
       IF S->FIELD_EXP_HDR^=NULL
         THEN IF S->FIELD_EXP_HDR->TYPE=QUOTED_STRING
           THEN IF S->FIELD_EXP_HDR->NEXT_TOKEN=NULL
             THEN RETURN(S->FIELD_EXP_HDR->TOKSTR); /* RETURN LITERAL */
       VAL=#CALCEVB(EVAL_GET_OPERAND,EVAL_GET_OPERAND_CHAR,
         DUM_PUT_OPERAND,EVAL_ODD_FUNCTION,
         ECHOSW,S->FIELD_EXP_HDR,MSG);
       IF MSG^=''
         THEN RETURN('.'); /* BAD RESULT */
       IF TYPETAB(C->RHNTYPE)='CHAR' × TYPETAB(C->RHNTYPE)='BEST'
         THEN RETURN(CALCPRT(VAL));
       RETURN(CONVERT(ADDR(VALCH),
         'FLOAT',8,0,
         TYPETAB(C->RHNTYPE),C->RHNLNG,C->RHNFD));
       END;
   R=NULL;
   STR=GETDATA(D,S->FIELD_EXP_HDR,R);
   RETURN(CONVERT_INTFC(STR,R,C));
 EVAL_GET_OPERAND: PROC(S) RETURNS(DEC FLOAT(16));
   DCL S PTR;
   RETURN(GET_OPERAND(D,S));
   END EVAL_GET_OPERAND;
 EVAL_GET_OPERAND_CHAR: PROC(S) RETURNS(CHAR(256) VAR);
   DCL (R,S) PTR;
   R=NULL;
   RETURN(GETDATA(D,S,R));
   END EVAL_GET_OPERAND_CHAR;
   END EVAL_COMMON_REAL;

 EXPNEXT_REAL: PROC(S,EXPNO) RETURNS(CHAR(8));
 /*********************************************************************
 *                                                                     *
 * EXPNEXT IS CALLED WHENEVER A NEW EXPRESSION IS ENCOUNTERED IN THE   *
 * CURRENT SELECT LIST.  IT WILL RETURN A UNIQUE NAME OF THE FORM      *
 * 'EXPN' WHERE N IS A UNIQUE NUMBER.                                  *
 *                                                                     *
 * IT WILL ALSO SET BIT SELECT_EXP TO INDICATE THE CURRENT SELECT      *
 * LIST ELEMENT IS AN EXPRESSION, AND NOT JUST A SIMPLE VARIABLE       *
 * REFERENCE                                                           *
 *                                                                     *
 *********************************************************************/
   DCL EXPNO FIXED BIN(31,0);
   DCL S PTR;
   DCL PIC PIC 'ZZZZ9';
   S->SELECT_EXP='1'B;
   EXPNO=EXPNO+1;
   PIC = EXPNO;
   RETURN('EXP'××SUBSTR(PIC,PREFIX(PIC,' ')));
   END EXPNEXT_REAL;

 FIND_FIELD_REAL: PROC(D,DBNAME,FNAME,FR) RETURNS(PTR);
 /**********************************************************************
 *                                                                     *
 * THIS SUBROUTINE IS CALLED TO LOCATE A SPECIFIC FROM-FIELD.  IT WILL *
 * RETURN A POINTER TO THE RHNAMESTR STRUCTURE FOR THE SPECIFIED       *
 * FIELD, AND WILL ALSO SET POINTER FR TO POINT TO THE FROM_FIELD      *
 * STRUCTURE FOR THE SPECIFIED FIELD IF IT IS FOUND.  IF THE FIELD IS  *
 * NOT FOUND, FIND_FIELD WILL RETURN NULL.                             *
 *                                                                     *
 **********************************************************************/
   DCL (DBNAME,FNAME) CHAR(8);
   DCL (D,F,FR,T) PTR;
   IF FR^=NULL
     THEN F=FIND_FIELD_SRCH(FR->FROM_RHP->RHUSETR,FNAME);
     ELSE DO;
       F=NULL;
       DO FR=D->FROM_LIST_PTR REPEAT FR->FROM_NEXT_FIELD
         WHILE(FR^=NULL);
         IF (DBNAME='' & ^FR->FROM_SKIP) × DBNAME=FR->FROM_NAME
           THEN DO;
             F=FIND_FIELD_SRCH(FR->FROM_RHP->RHUSETR,FNAME);
             IF F^=NULL
               THEN RETURN(F); /* GOT FIELD DESCRIPTION */
               ELSE IF DBNAME^='' × (DBNAME='' & FNAME='SEQ')
                 THEN RETURN(NULL); /* FIELD NOT FOUND */
             END;
         END;
       END;
   RETURN(F);
   END FIND_FIELD_REAL;

 FIND_FIELD_SRCH: PROC(T,FNAME) RETURNS(PTR);
 /**********************************************************************
 *                                                                     *
 * THIS SUBROUTINE IS CALLED TO LOCATE A SPECIFIC FIELD.  IT WILL      *
 * RETURN A POINTER TO THE RHNAMESTR STRUCTURE FOR THE SPECIFIED       *
 * FIELD.  IF NOT FOUND, WILL RETURN NULL.  NOTE THAT THIS ROUTINE     *
 * USES THE AVL SEARCH TREE POINTED BY RHUSETR, AND BUILT BY ABE053.   *
 *                                                                     *
 **********************************************************************/
   DCL FNAME CHAR(8);
   DCL (P,T) PTR;

   IF T=NULL
     THEN RETURN(NULL);
   P=T;
   DO WHILE(P^=NULL); /* SEARCH T FOR INSERTION POINT FOR X */
     SELECT;
       WHEN(FNAME<P->RHNNAME) P=P->RHLCHILD; /* TAKE LEFT BRANCH */
       WHEN(FNAME>P->RHNNAME) P=P->RHRCHILD; /* TAKE RIGHT BRANCH */
       OTHERWISE RETURN(P); /* FOUND IT */
       END; /* SELECT */
     END;
   RETURN(P);
   END FIND_FIELD_SRCH;

 GET_OPERAND_REAL: PROC(D,S) RETURNS(DEC FLOAT(16));
 /**********************************************************************
 *                                                                     *
 * CALLED TO OBTAIN THE NUMERIC VALUE FOR A GIVEN FIELD NAME.          *
 *                                                                     *
 **********************************************************************/
   DCL (D,R,S) PTR;
   DCL STR CHAR(256) VAR;
   DCL RET DEC FLOAT(16);
   ON CONVERSION BEGIN;
     RET=MISSING;
     GOTO GET_OPERAND_RETURN;
     END;
   R=NULL;
   STR=GETDATA(D,S,R);
   IF R=NULL & S->TOKSTR^='SEQ'
     THEN RET=#SYMA(RHHDRPT,RH_SYMTREE,S->TOKSTR);
     ELSE IF STR='' × STR='.'
       THEN RET=MISSING;
       ELSE RET=#GETFLOAT(STR,R);
 GET_OPERAND_RETURN:
   RETURN(RET);
   END GET_OPERAND_REAL;

 GET_SET_REAL: PROC(D,S,DNAME,FNAME,FR);
 /**********************************************************************
 *                                                                     *
 * CALLED TO SET PARAMETERS DNAME AND FNAME TO THE DATABASE NAME AND   *
 * FIELD NAME, RESPECTIVELY, FOR THE TOKEN LIST POINTED TO BY POINTER  *
 * S.                                                                  *
 *                                                                     *
 **********************************************************************/
   DCL (D,S,FR) PTR;
   DCL (FNAME,DNAME) CHAR(8);
   FNAME=S->TOKSTR;
   SELECT;
     WHEN(S->NEXT_TOKEN=NULL) DNAME='';
     WHEN(^(S->NEXT_TOKEN->TOKSTR='.' & S->NEXT_TOKEN->TYPE=OTHER))
       DNAME='';
     OTHERWISE DO;
       DNAME=FNAME;
       FNAME=S->NEXT_TOKEN->NEXT_TOKEN->TOKSTR;
       END;
     END; /* SELECT */
   FR=NULL;
   IF DNAME^=''
     THEN DO FR=D->FROM_LIST_PTR REPEAT FR->FROM_NEXT_FIELD
       WHILE(FR^=NULL)
       UNTIL(FR->FROM_NAME=DNAME × FR->SHORT_FROM_NAME=DNAME);
       END;
   END GET_SET_REAL;

 GETDATA_REAL: PROC(D,S,R) RETURNS(CHAR(256) VAR);
 /**********************************************************************
 * CALLED TO OBTAIN THE VALUE FROM A FIELD DESCRIBED BY THE TOKEN LIST *
 * POINTED TO BY PTR S.  PTR D POINTS TO THE SELECT_HTEXT CONTROL      *
 * BLOCK FOR THE CURRENTLY EXECUTING SELECT STATEMENT.  NOTE THAT THE  *
 * TOKEN LIST MAY BE QUALIFIED WITH THE DATABASE NAME FROM WHICH THE   *
 * FIELD IS TO BE EXTRACTED.  IF NOT QUALIFIED, THE QUEUE OF FROM-     *
 * DATABASES WILL BE SEARCHED UNTIL THE FIELD NAME IS FOUND.           *
 * IF THE FIELD NAME IS NOT FOUND, A NULL STRING WILL BE RETURNED.     *
 **********************************************************************/
   DCL (D,R,S,FR) PTR;
   DCL (FNAME,DNAME) CHAR(8);
   CALL GET_SET(D,S,DNAME,FNAME,FR);
   IF (DNAME='' & FNAME='MISSING') × (DNAME^='' & FR=NULL)
     THEN RETURN(''); /* RETURN MISSING VALUE */
     ELSE RETURN(GETDATC(D,DNAME,FNAME,FR,R));
   END GETDATA_REAL;

 GETDATC_REAL: PROC(D,DNAME,FNAME,F,G) RETURNS(CHAR(256) VAR);
 /**********************************************************************
 *                                                                     *
 * CALLED TO OBTAIN THE VALUE FROM A FIELD NAMED IN PARAMETER FNAME    *
 * FROM THE DATABASE NAMED IN PARAMETER DNAME. PTR D POINTS TO THE     *
 * SELECT_HTEXT CONTROL BLOCK FOR THE CURRENTLY EXECUTING SELECT       *
 * IF THE FIELD NAME IS NOT FOUND, A NULL STRING WILL BE RETURNED.     *
 * A NULL STRING IS ALSO RETURNED IF EOF HAS ALREADY OCCURRED.         *
 *                                                                     *
 * NOTE THAT WHEN THE FIELD IS FOUND, IT IS ASSUMED THAT THE 'USE SET' *
 * SUBCOMMAND HAS BEEN ISSUED FOR THE CURRENT RECORD TO SET RHNCPOS    *
 * AND RHNCLNG.                                                        *
 *                                                                     *
 **********************************************************************/
   DCL (D,S,F,G,TRH,R) PTR;
   DCL (FNAME,DNAME) CHAR(8);
   DCL L FIXED BIN;
   G=FIND_FIELD(D,DNAME,FNAME,F); /* GO FIND FROM_FIELD */
   RETURN(GETDATC_SUB(F,G,FNAME));
   END GETDATC_REAL;

 GETDATC_SUB_REAL: PROC(F,G,FNAME) RETURNS(CHAR(256) VAR);
 /**********************************************************************
 *                                                                     *
 * CALLED TO OBTAIN THE VALUE FROM A FIELD. G POINTS TO RHNAMESTR      *
 * CONTROL BLOCK FOR THE FIELD, AND F POINTS TO THE FROM_FIELD CONTROL *
 * BLOCK FOR THE FIELD.                                                *
 *                                                                     *
 **********************************************************************/
   DCL (D,S,F,G,TRH,R) PTR;
   DCL FNAME CHAR(8);
   DCL L FIXED BIN;
   DCL PIC PIC'99999999';
   IF F=NULL
     THEN RETURN(''); /* CAN'T FIND DATABASE */
   IF F->FROM_EOF × F->FROM_SKIP
     THEN RETURN(''); /* EOF OR RECORD IS TO BE SKIPPED */
   TRH=F->FROM_RHP;
   IF F->FROM_RECPTR=TRH
     THEN RETURN(''); /* NO CURRENT RECORD */
   IF G=NULL
     THEN IF FNAME='SEQ'
       THEN DO;
         PIC=F->FROM_RECPTR->RECSEQ;
         RETURN(PIC);
         END;
       ELSE RETURN(''); /* CAN'T FIND FIELD */
   RETURN(GETFIELD(G,ADDR(F->FROM_RECPTR->RECLEN)));
   END GETDATC_SUB_REAL;

 GETFIELD_REAL: PROC(G,B) RETURNS(CHAR(256) VAR);
 /**********************************************************************
 *                                                                     *
 * CALLED TO OBTAIN THE VALUE FOR A FIELD. G POINTS TO RHNAMESTR       *
 * CONTROL BLOCK FOR THE FIELD, AND B POINTS TO THE BUFFER CONTAINING  *
 * THE RECORD FROM WHICH THE FIELD IS TO BE EXTRACTED.                 *
 *                                                                     *
 * IF THE FIELD IS OF TYPE CHARACTER OR ZONED, THIS SUBROUTINE WILL    *
 * RETURN A STRING OF LENGTH 0 TO INDICATE A MISSING VALUE.            *
 *                                                                     *
 **********************************************************************/
   DCL (G,B) PTR;
   DCL RET CHAR(256) VAR;

   IF G->RHNCLNG=0 × G->RHNCPOS=0
     THEN RETURN(''); /* FIELD IS ZERO LENGTH */
   L=LENGTH(B->BUF);
   IF L < G->RHNCPOS
     THEN RETURN(''); /* EMPTY FIELD */
   IF G->RHNCPOS+G->RHNCLNG-1 >= L
     THEN RET=SUBSTR(B->BUF,G->RHNCPOS);
     ELSE RET=SUBSTR(B->BUF,G->RHNCPOS,G->RHNCLNG);
   IF G->RHNTYPE=ZD × G->RHNTYPE=CHR
     THEN IF RET=''
       THEN RET=''; /* MAKE ZERO LENGTH = MISSING */
       ELSE IF SUBSTR(RET,PREFIX(RET,' '))='.'
         THEN RET=''; /* MAKE ZERO LENGTH = MISSING */
   RETURN(RET);
   END GETFIELD_REAL;

 LIST_QUERY_TYPE_REAL: PROC(T) RETURNS(PTR);
 /**********************************************************************
 * CALLED TO DETERMINE WHETHER A SELECT_LIST_ELEMENT REPRESENTS A      *
 * LIST_QUERY (SEE BNF DEFINITION).  IF IT IS A LIST_QUERY, THIS       *
 * SUBROUTINE WILL RETURN A PTR TO THE TOKEN STRUCTURE FOR THE         *
 * SUBQUERY NAME (E.G. SELECT0009).  OTHERWISE, IT RETURNS NULL.       *
 **********************************************************************/
   DCL (T,S,U) PTR;
   IF T->FIELD_EXP_HDR->TOKSTR='(' &
     T->FIELD_EXP_HDR->TYPE^=QUOTED_STRING
     THEN S=T->FIELD_EXP_HDR->NEXT_TOKEN;
     ELSE S=T->FIELD_EXP_HDR;
   S=T->FIELD_EXP_HDR;
   IF S->TOKSTR='(' & S->TYPE^=QUOTED_STRING
     THEN S=S->NEXT_TOKEN;
   IF ^SUBQUERY_TYPE(S)
     THEN RETURN(NULL);
   U=S->NEXT_TOKEN;
   IF U->TOKSTR=')' & U->TYPE^=QUOTED_STRING
     THEN U=U->NEXT_TOKEN;
   IF ^(U->TYPE=NO_MORE_TOKENS)
     THEN RETURN(NULL);
   END LIST_QUERY_TYPE_REAL;

 LOC_DB_REAL: PROC(FPTR) RECURSIVE;
 /**********************************************************************
 * CALLED TO LOCATE A DATA BASE TO SATISFY A FROM SPECIFICATION.  FPTR *
 * WILL POINT TO THE FROM_FIELD STRUCTURE FOR THE DATA BASE.           *
 **********************************************************************/
   DCL (FPTR,TRH,SAVE) PTR;
   DCL I FIXED BIN(15,0);
   DCL MYBUF CHAR(256) VAR;

   /* FIRST FIND OUT IF DATABASE CURRENTLY BEING EDITED. */
   IF SUBQUERY_TYPE_SUB(FPTR->FROM_NAME)
     THEN DO;
       TRH=LOC_DB_SUB(FPTR); /* PROCESS FROM-SUBQUERY */
       IF TRH^=NULL
         THEN FPTR->FROM_NAME=TRH->RHNAME;
       END;
     ELSE DO TRH=NXTRHEL REPEAT TRH->RHNXT WHILE(TRH^=NULL)
       UNTIL(TRH->RHNAME=FPTR->FROM_NAME);
       END;
   IF TRH^=NULL
     THEN DO;
       FPTR->FROM_RHP=TRH;
       RETURN;
       END;

   /* DATABASE NOT CURRENTLY BEING EDITED - TRY FOR DDNAME */
   SAVE=RHPTR; /* SSE SUBCOMMAND MAY CHANGE RHPTR */
   I=#CMD('SSE '''' INFI('××FPTR->FROM_NAME××') DBD NAME('××
     FPTR->FROM_NAME××')',
     RHPTR,RHHDRPT);
   TRH=RHPTR;
   RHPTR=SAVE;
   IF I=0
     THEN DO;
       FPTR->FROM_RHP=TRH;
       DO MYBUF=TRH->RECHDR.CMDDATA REPEAT TRH->RECHDR.CMDDATA
         WHILE(MYBUF^='');
         MYBUF=TRH->RECHDR.CMDDATA;
         TRH->RECHDR.CMDDATA='';
         I=#CMD(MYBUF,TRH,RHHDRPT);
         IF I^=0
           THEN SIGNAL ERROR;
         END;
       RETURN;
       END;

   /* FOR NOW SIGNAL ERROR AT THIS POINT */
   MSGDATA = 'FROM DATA BASE NOT FOUND';
   SIGNAL ERROR;


   /* NO MATCHING DDNAME - TRY FOR MATCHING DSNAME */



   END LOC_DB_REAL;

 LOC_DB_SUB: PROC(FPTR) RETURNS(PTR) RECURSIVE;
 /**********************************************************************
 *                                                                     *
 * CALLED IF THE CURRENT FROM-FIELD IS A SUBQUERY. IT WILL GET THE     *
 * SUBQUERY EXECUTED AND RETURN A POINTER TO THE RECHDR AS A RESULT    *
 * OF EXECUTING THE SUBQUERY.                                          *
 *                                                                     *
 **********************************************************************/
   DCL (FPTR,HTP,TRH) PTR;
   DCL I FIXED BIN(31,0);
   I=SUBSTR(FPTR->FROM_NAME,7); /* GET SUBQUERY NUMBER */
   DO HTP=SUBQ_FIRST REPEAT HTP->SUBQ_NEXT
     WHILE(HTP^=NULL) UNTIL(HTP->SUBQ_NUM=I);
     END;
   IF HTP=NULL
     THEN DO;
       MSGDATA='INVALID FROM = '××FPTR->FROM_NAME;
       SIGNAL CONDITION(BADSTMT);
       END;
   TRH=DO_SELECT(HTP,RHPTR,RHHDRPT,SUBQ_HDR,SUBRTNES,DO_STACK);
     /* GO EXECUTE SUBQUERY */
   IF TRH=NULL
     THEN DO;
       MSGDATA='INVALID FROM = '××FPTR->FROM_NAME;
       SIGNAL CONDITION(BADSTMT);
       END;
   RETURN(TRH);
   END LOC_DB_SUB;

 LOC_DBD_REAL: PROC(FPTR);
 /**********************************************************************
 * CALLED TO LOCATE A DATA BASE DEFINITION. FPTR WILL POINT TO THE     *
 * FROM_FIELD STRUCTURE FOR THE DATA BASE.  FROM_RECPTR WILL BE SET TO *
 * POINT TO THE RECORD (OR RECHDR) IMMEDIATELY IN FRONT OF THE FIRST   *
 * RECORD TO BE PROCESSED IN THE FILE.                                 *
 **********************************************************************/
   DCL (FPTR,F) PTR;
   DCL PIC PIC'9999';
   IF FPTR->FROM_RHP=NULL
     THEN SIGNAL ERROR;
   FPTR->FROM_RECPTR=FPTR->FROM_RHP->HDPTR;
   IF FPTR->FROM_RHP->RHUSEHD^=NULL
     THEN RETURN;
   ALLOC RHNAMESTR SET(F);
   FPTR->FROM_RHP->RHUSEHD=F;
   F->RHNLINK=NULL;
   F->RHNVAR0,F->RHNFL=0;
   F->RHNFD,F->RHNF,F->RHNJUST,F->RHNCPOS,F->RHNCLNG=0;
   F->RHNNAME=FPTR->FROM_RHP->RHNAME;
   F->RHNLABEL,F->RHNFORM,F->RHNIFORM='';
   F->RHNTYPE=2; /* TYPE = CHAR */
   F->RHNPOS=0; /* WAS 1 */
   F->RHNLNG=0; /* WAS FPTR->FROM_RHP->BUFPTR->BUFLN */
   END LOC_DBD_REAL;

 %INCLUDE ABE050A;

 QNUM_REAL: PROC(NAME,CH) RETURNS(FIXED BIN(31,0));
 /**********************************************************************
 *                                                                     *
 * IS CALLED TO TEST THE ARGUMENT NAME FOR THE FORM "QDDD".  IF IT IS  *
 * NOT OF THAT FORM, QNUM WILL RETURN -1.  OTHERWISE QNUM WILL RETURN  *
 * DDD.                                                                *
 *                                                                     *
 **********************************************************************/
   DCL NAME CHAR(8);
   DCL CH CHAR(1);
   DCL NV CHAR(8) VAR;
   IF SUBSTR(NAME,1,1)^=CH
     THEN RETURN(-1);
   IF VERIFY(SUBSTR(NAME,2),'0123456789')^=0
     THEN RETURN(-1);
   RETURN(SUBSTR(NAME,2));
   END QNUM_REAL;

 QNUMSTR_REAL: PROC RETURNS(CHAR(8));
 /**********************************************************************
 *                                                                     *
 * IS CALLED TO OBTAIN A NAME OF THE FORM "QDDD", WHERE DDD IS         *
 * GLOBAL VARIABLE QNUMBER.                                            *
 *                                                                     *
 **********************************************************************/
   DCL PIC PIC'9999999';
   QNUMBER=QNUMBER+1;
   PIC=QNUMBER;
   RETURN('Q'××PIC);
   END QNUMSTR_REAL;

 QUEUE_REAL:  PROC(PTRA,PTRB) RETURNS(PTR);
 /**********************************************************************
 * CALLED TO JOIN TWO STRINGS OF TOKENS INTO A SINGLE STRING           *
 **********************************************************************/
   DCL (PTRA,PTRB,SAVE) PTR;
   IF PTRA=NULL
     THEN RETURN(PTRB);
   IF PTRB=NULL
     THEN RETURN(PTRA);
   SAVE=PTRA->PRIOR_TOKEN;
   PTRA->PRIOR_TOKEN=PTRB->PRIOR_TOKEN;
   SAVE->NEXT_TOKEN=PTRB;
   PTRB->PRIOR_TOKEN=SAVE;
   RETURN(PTRA);
   END QUEUE_REAL;

 RUN_BUF_REAL: PROC(B,POS,LNG,DATA,F);
 /**********************************************************************
 * RUN_BUF IS CALLED TO STORE 'DATA' AT OFFSET 'POS' FOR A LENGTH OF   *
 * 'LNG' IN THE BUFFER POINTED TO BY 'B'.  IF F IS NOT NULL, IT MUST   *
 * POINT AT THE RHNAMESTR CONTROL BLOCK FOR THIS FIELD.  RUN_BUF WILL  *
 * UPDATE RHNCPOS AND RHNCLNG.                                         *
 **********************************************************************/
   DCL (B,F) PTR;
   DCL (POS,LNG) FIXED BIN(15,0);
   DCL DATA CHAR(*) VAR;
   DCL MYDATA CHAR(256) VAR;
   DCL (I,J,K,L) FIXED BIN;
   IF POS=0
     THEN DO; /* IT IS LIST OUTPUT */
       IF DATA=''
         THEN RETURN; /* GET OUT IF NO DATA */
       L=LENGTH(B->BUF);
       IF L ^= 0
         THEN DO;
           I=SUFFIX(B->BUF,' '); /* FIND LAST NON-BLANK */
           IF I<L
             THEN B->BUF=SUBSTR(B->BUF,1,I);
           END;
       IF F^=NULL
         THEN DO;
           F->RHNCPOS=LENGTH(B->BUF)+1;
           F->RHNCLNG=SUFFIX(DATA,' ')-PREFIX(DATA,' ')+1;
           END;
       B->BUF=B->BUF××' '××SUBSTR(DATA,PREFIX(DATA,' '));
       END;
     ELSE DO; /* IT IS FIXED OUTPUT */
       IF F^=NULL
         THEN DO;
           F->RHNCPOS=POS;
           F->RHNCLNG=LNG;
           END;
       IF LENGTH(DATA)>LNG
         THEN CALL RUN_BUF_REAL_OVFLO(F,DATA,LNG);
       IF LENGTH(DATA)=0
         THEN MYDATA=#GET_MISSING(F);
         ELSE MYDATA=DATA;
       CALL #ABEINS(MYDATA,B,POS,LNG); /* INSERT INTO BUFFER */
       END;
   IF F^=NULL
     THEN IF LENGTH(B->BUF)<F->RHNCPOS
       THEN F->RHNCPOS,F->RHNCLNG=0;
       ELSE IF LENGTH(B->BUF)<F->RHNCPOS+F->RHNCLNG-1
         THEN F->RHNCLNG=LENGTH(B->BUF)-F->RHNCPOS+1;

   END RUN_BUF_REAL;

 RUN_BUF_REAL_OVFLO: PROC(F,DATA,LNG);
 /**********************************************************************
 * CALLED TO PROCESS AN OVERFLOW CONDITION.                            *
 **********************************************************************/
   DCL F PTR;
   DCL DATA CHAR(*) VAR;
   DCL LNG FIXED BIN(15,0);
   DCL (I,J,K,L) FIXED BIN(15,0);

   IF F=NULL
     THEN DO;
       DATA=SUBSTR(DATA,1,LNG);
       RETURN;
       END;
   IF F->RHNTYPE=2 /* CHAR? */
     THEN DO;
       DATA=SUBSTR(DATA,1,LNG);
       RETURN;
       END;
   IF F->RHNTYPE^=3 & F->RHNTYPE^=8 /* ZONED? */
     THEN DO;
       DATA='.'; /* SET MISSING VALUE */
       RETURN;
       END;
   /* FOR ZONED, IF SCIENTIFIC NOTATION, LOSE PRECISION */
   I=INDEX(DATA,'.');
   IF I=0
     THEN DO;
       DATA='.'; /* SET MISSING VALUE */
       RETURN;
       END;
   J=INDEX(DATA,'E');
   K=J-I-2; /* K=MAXIMUM LENGTH TO REMOVE */
   L=LENGTH(DATA)-LNG; /* L=LENGTH TO REMOVE */
   IF L>K
     THEN DO;
       DATA='.'; /* SET MISSING VALUE */
       RETURN;
       END;
   DATA=SUBSTR(DATA,1,I+1)××SUBSTR(DATA,I+1+L);
   END RUN_BUF_REAL_OVFLO;

 SELECT_LIST_REAL: PROC(PSLPTR,CMDDATA,SCANPARM);
 /**********************************************************************
 * CALLED TO PROCESS A SELECT-LIST.                                    *
 **********************************************************************/
   DCL PSLPTR PTR; /* SELECT_LIST_PTR */
   DCL CMDDATA CHAR(*) VAR;
   DCL 1 SCANPARM,
     2 TOKHDR PTR,
     2 CURTOK PTR,
     2 SCANIX FIXED BIN(15,0);
   DCL (EXPPTR,LASTFLD) PTR;
   DCL ID FIXED BIN(15,0) INIT(0);
   LASTFLD=PSLPTR;
   DO WHILE(CURTOK->TYPE^=NO_MORE_TOKENS);
     IF CURTOK->TOKSTR=')' & CURTOK->TYPE^=QUOTED_STRING
       THEN LEAVE;
     EXPPTR=POLISH(CURTOK,PRECEDENCE,MSGDATA,CURTOK);
       /* GO CONVERT TO POLISH NOTATION */
     IF MSGDATA^=''
       THEN SIGNAL CONDITION(BADSTMT); /* POLISH FOUND AN ERROR */
     IF EXPPTR->TOKSTR='COUNT'
       THEN EXPPTR->TYPE=FUNCTION_A; /* MONADIC FUNCTION COUNT */
     ALLOCATE SELECT_LIST_ELEMENT;
     /* NOW QUEUE SELECT_FIELD AT END OF LINKED LIST */
     CALL SINGLE_QUEUE(PSLPTR,LASTFLD,SELFPTR);
     FIELD_EXP_HDR=EXPPTR;
     SELECT_NAME='';
     STRING(SELECT_ELEMENT_FLAGS)='0'B;
     ID=ID+1;
     SELECT_ID=ID;
     SELECT_BUCKET1,SELECT_BUCKET2,SELECT_COUNT=MISSING;
     IF CURTOK->TOKSTR^=','
       THEN LEAVE;
     SCAN; /* SKIP OVER DELIMITING COMMA */
     END;
   END SELECT_LIST_REAL;

 SET_FIELD_REAL: PROC(D,PRIOR,FROM,PNAME,S);
 /**********************************************************************
 *                                                                     *
 * CALLED TO ALLOCATE, INITIALIZE, AND QUEUE A NEW RHNAMESTR STRUCTURE *
 * FOR A TO- FIELD.  PARAMETER D IS A POINTER TO THE CURRENT EXECUTION *
 * SELECT_HTEXT CONTROL BLOCK, PRIOR IS A POINTER TO THE RHNAMESTR     *
 * STRUCTURE FOR THE PRIOR TO- FIELD, FROM (IF NOT NULL), IS A         *
 * POINTER TO THE RHNAMESTR STRUCTURE FOR THE FROM- FIELD, AND PNAME   *
 * IS THE NAME TO BE ASSIGNED TO THE TO- FIELD. S WILL EITHER BE NULL, *
 * OR WILL POINT TO THE SELECT_LIST_ELEMENT FOR THE FIELD BEING        *
 * DEFINED.                                                            *
 *                                                                     *
 **********************************************************************/
   DCL (D,F,FROM,NODEPTR,PRIOR,S,T) PTR;
   DCL I FIXED BIN(15,0);
   DCL PNAME CHAR(*);

   ALLOCATE RHNAMESTR SET(F);
   IF PRIOR^=NULL
     THEN T=PRIOR;
     ELSE DO T=D->TO_RHP->RHUSEHD REPEAT T->RHNLINK
       WHILE(T^=NULL) UNTIL(T->RHNLINK=NULL); /* GET LAST IN DBD */
       END;
   IF T=NULL
     THEN DO; /* IT IS FIRST IN NEW DBD */
       F->RHNLINK=D->TO_RHP->RHUSEHD;
       D->TO_RHP->RHUSEHD=F;
       END;
     ELSE DO; /* QUEUE BEHIND PRIOR */
       F->RHNLINK=T->RHNLINK;
       T->RHNLINK=F;
       END;
   F->RHNTYPE,F->RHNPOS,F->RHNLNG,F->RHNVAR0,F->RHNFL=0;
   F->RHNFD,F->RHNF,F->RHNJUST,F->RHNCPOS,F->RHNCLNG=0;
   F->RHNNAME=PNAME;
   F->RHNLABEL,F->RHNFORM,F->RHNIFORM='';
   D->TO_RHP->RHUSETR=NULL; /* INITIALIZE ROOT TO NULL */
   DO NODEPTR=D->TO_RHP->RHUSEHD REPEAT NODEPTR->RHNLINK
     WHILE(NODEPTR^=NULL);
     CALL #ABE053A(D->TO_RHP->RHUSETR,NODEPTR);
     END;
   IF FROM=NULL
     THEN DO; /* IT MUST BE AN EXPRESSION */
       F->RHNLNG=15;
       F->RHNTYPE=3; /* NORMAL DEFAULTS NOW SET */
       IF S^=NULL    /* NOW CHECK FOR SINGLE LITERAL */
         THEN IF S->FIELD_EXP_HDR^=NULL
           THEN IF S->FIELD_EXP_HDR->TYPE=QUOTED_STRING
             THEN IF S->FIELD_EXP_HDR->NEXT_TOKEN=NULL
               THEN DO; /* IT IS SINGLE LITERAL */
                 F->RHNLNG=LENGTH(S->FIELD_EXP_HDR->TOKSTR);
                 F->RHNTYPE=2; /* TYPE=CHARACTER */
                 END;
       END;
     ELSE IF D->SELECT_DISPLAY
       THEN DO;
         IF FROM->RHNTYPE=2 × FROM->RHNTYPE=3
           THEN DO; /* IT IS ZONED OR CHAR */
             F->RHNTYPE=FROM->RHNTYPE;
             I=SUFFIX(FROM->RHNNAME,' '); /* FIND LAST NONBLANK */
             IF F->RHNTYPE=2
               THEN I=I+3; /* ADD 3 FOR $ IF CHAR */
             IF I>FROM->RHNLNG
               THEN F->RHNLNG=I;
               ELSE F->RHNLNG=FROM->RHNLNG;
             END;
           ELSE DO;
             F->RHNLNG=15;
             F->RHNTYPE=3;
             END;
         END;
       ELSE DO;
         F->RHNLNG=FROM->RHNLNG;
         F->RHNTYPE=FROM->RHNTYPE;
         END;
   IF F->RHNLNG^=0 /* CHECK FOR FREE-FORM */
     THEN IF PRIOR=NULL
       THEN F->RHNPOS=1; /* IT IS FIRST AND ONLY FIELD IN DB */
       ELSE F->RHNPOS=PRIOR->RHNPOS+PRIOR->RHNLNG;
   END SET_FIELD_REAL;

 SIGNUM_REAL: PROC(C,A,B) RETURNS(FIXED BIN(15,0));
 /**********************************************************************
 *                                                                     *
 * CALLED TO COMPARE FIELDS DESCRIBED BY RHNAMESTR POINTED TO BY C     *
 * FROM BUFFERS POINTED TO BY A,B.  RETURNS -1,0,+1 IF A AND B COMPARE *
 * LOW, EQUAL, OR HIGH, RESPECTIVELY.                                  *
 *                                                                     *
 **********************************************************************/
   DCL (C,A,B) PTR;
   DCL (CA,CB) CHAR(256) VAR;
   DCL (NA,NB) DEC FLOAT(16);
   CA=GETFIELD(C,A);
   CB=GETFIELD(C,B);
   RETURN(SIGNUM_COMMON(CA,CB,C,C));
   END SIGNUM_REAL;

 SIGNUM_COMMON_REAL: PROC(CA,CB,C,D) RETURNS(FIXED BIN(15,0));
 /**********************************************************************
 *                                                                     *
 * CALLED TO COMPARE FIELDS DESCRIBED BY RHNAMESTR POINTED TO BY C AND *
 * D, WHERE DATA FOR FIELDS IS IN STRINGS CA AND CB.  RETURNS -1,0,+1  *
 * IF CA AND CB COMPARE LOW, EQUAL, OR HIGH, RESPECTIVELY.             *
 *                                                                     *
 **********************************************************************/
   DCL (C,D) PTR;
   DCL (CA,CB) CHAR(256) VAR;
   DCL (NA,NB) DEC FLOAT(16);
   IF (C->RHNTYPE=2 & D->RHNTYPE=2)
     THEN SELECT; /* THEY ARE BOTH  CHARACTER FIELDS */
       WHEN(CA=CB) RETURN(0);
       WHEN(CA<CB) RETURN(-1);
       OTHERWISE   RETURN(1);
       END; /* SELECT */
     ELSE DO;     /* IT IS NUMERIC FIELD */
       NA=#GETFLOAT(CA,C);
       NB=#GETFLOAT(CB,D);
       SELECT;
         WHEN(UNSPEC(NA)=UNSPEC(MISSING) & UNSPEC(NB)=UNSPEC(MISSING))
           RETURN(0);
         WHEN(UNSPEC(NA)=UNSPEC(MISSING))
           RETURN(-1);
         WHEN(UNSPEC(NB)=UNSPEC(MISSING))
           RETURN(1);
         OTHERWISE
           SELECT;
             WHEN(NA=NB) RETURN(0);
             WHEN(NA<NB) RETURN(-1);
             OTHERWISE   RETURN(1);
             END; /* SELECT */
         END; /* SELECT */
       END;
   END SIGNUM_COMMON_REAL;

 SINGLE_QUEUE_REAL: PROC(HDR,LAST,CUR);
 /**********************************************************************
 * CALLED TO QUEUE A NEW ELEMENT AT THE END OF A SINGLY LINKED LIST    *
 **********************************************************************/
   DCL (HDR,LAST,CUR,DUM) PTR;
   DCL 1 EL BASED(DUM),
     2 NEXT PTR;
   CUR->NEXT=NULL;
   IF HDR=NULL
     THEN HDR=CUR;
     ELSE LAST->NEXT=CUR;
   LAST=CUR;
   END SINGLE_QUEUE_REAL;

 SUBQUERY_TYPE_REAL: PROC(S) RETURNS(BIT(1));
 /**********************************************************************
 * CALLED TO SEE IF A GIVEN TOKEN REPRESENTS A SUBQ OR NOT             *
 **********************************************************************/
   DCL S PTR;
   IF S=NULL
     THEN RETURN('0'B);
   RETURN(SUBQUERY_TYPE_SUB(S->TOKSTR));
   END SUBQUERY_TYPE_REAL;

 SUBQUERY_TYPE_SUB_REAL: PROC(S) RETURNS(BIT(1));
 /**********************************************************************
 * CALLED TO SEE IF A GIVEN STRING REPRESENTS A SUBQ OR NOT            *
 **********************************************************************/
   DCL S CHAR(*) VAR;
   IF LENGTH(S)^=10
     THEN RETURN('0'B);
   IF SUBSTR(S,1,6)^='SELECT'
     THEN RETURN('0'B);
   IF VERIFY(SUBSTR(S,7,4),'0123456789')^=0
     THEN RETURN('0'B);
   RETURN('1'B);
   END SUBQUERY_TYPE_SUB_REAL;

 WHERE_EVAL_REAL: PROC(D) RETURNS(BIT(1));
 /**********************************************************************
 *                                                                     *
 * CALLED TO EVALUATE THE WHERE-CLAUSE POINTED TO BY WHERE_PTR IN THE  *
 * SELECT_HTEXT CONTROL BLOCK POINTED TO BY PARAMETER POINTER D.       *
 * RETURNS '0'B IF THE EXPRESSION EVALUATES TO 0, AND RETURNS '1'B     *
 * OTHERWISE.                                                          *
 *                                                                     *
 **********************************************************************/
   DCL D PTR;
   DCL ECHOSW BIT(1);
   DCL VAL FLOAT DEC(16) INIT(1);
   DCL MSG CHAR(80) VAR INIT('');
   DCL LIKESTR CHAR(256) VAR;
   IF D->WHERE_PTR=NULL
     THEN RETURN('1'B); /* GET OUT IF NOT WHERE CLAUSE */
   IF D->WHERE_PTR->LIKE
     THEN RETURN(WHERE_LIKE(
       WHERE_GET_OPERAND_CHAR(D->WHERE_PTR->SEARCH_EXP(1)),
       D->WHERE_PTR->SEARCH_EXP(2)->TOKSTR));
   IF D->WHERE_PTR->IN
     THEN RETURN(WHERE_IN(
       WHERE_GET_OPERAND,WHERE_GET_OPERAND_CHAR,
       D->WHERE_PTR->SEARCH_EXP(1),
       D->WHERE_PTR->SEARCH_EXP(2)));

   /* IF NOT LIKE OR IN, IT MUST BE A SIMPLE EXPRESSION - THESE ARE
   THE ONLY THREE FORMATS SUPPORTED AT THIS POINT */
   ON CONDITION(BADEXP) GOTO BYVAL;
   VAL=#CALCEVB(WHERE_GET_OPERAND,WHERE_GET_OPERAND_CHAR,
     DUM_PUT_OPERAND,DUM_ODD_FUNCTION,
     ECHOSW,D->WHERE_PTR->SEARCH_EXP(1),MSG);
 BYVAL:
   IF VAL=0 × MSG^=''
     THEN RETURN('0'B);
     ELSE RETURN('1'B);
 WHERE_GET_OPERAND: PROC(S) RETURNS(DEC FLOAT(16));
   DCL S PTR;
   RETURN(GET_OPERAND(D,S));
   END WHERE_GET_OPERAND;
 WHERE_GET_OPERAND_CHAR: PROC(S) RETURNS(CHAR(256) VAR);
   DCL (R,S) PTR;
   R=NULL;
   RETURN(GETDATA(D,S,R));
   END WHERE_GET_OPERAND_CHAR;
   END WHERE_EVAL_REAL;

 WHERE_IN: PROC(GOP,GOPC,PEXP1,PEXP2) RETURNS(BIT(1));
 /**********************************************************************
 *                                                                     *
 * CALLED TO DO A WHERE-IN COMPARISON.                                 *
 *                                                                     *
 **********************************************************************/
   DCL GOP ENTRY RETURNS(DEC FLOAT(16));
   DCL GOPC ENTRY RETURNS(CHAR(256) VAR);
   DCL (PEXP1,PEXP2,S) PTR;
   DCL (VAL1,VAL2) FLOAT DEC(16) INIT(1);
   DCL ECHOSW BIT(1);
   DCL MSG CHAR(80) VAR INIT('');

   /* FIRST GET VALUE OF FIRST OPERAND */
   VAL1=#CALCEVB(GOP,GOPC,
     DUM_PUT_OPERAND,DUM_ODD_FUNCTION,
     ECHOSW,PEXP1,MSG);
   IF MSG^=''
     THEN DO;
       MSGDATA=MSG;
       SIGNAL CONDITION(BADSTMT);
       END;
   /* NOW LOOP THROUGH COMPARING AGAINST ALL EXPRESSIONS IN LIST */
   DO S=PEXP2 REPEAT S->SELECT_NEXT_FIELD WHILE(S^=NULL)
     UNTIL(VAL1=VAL2);
     VAL2=#CALCEVB(GOP,GOPC,DUM_PUT_OPERAND,DUM_ODD_FUNCTION,
     ECHOSW,S->FIELD_EXP_HDR,MSG);
     IF MSG^=''
       THEN DO;
         MSGDATA=MSG;
         SIGNAL CONDITION(BADSTMT);
         END;
     END;
   IF S=NULL
     THEN RETURN('0'B); /* NO MATCH */
     ELSE RETURN('1'B); /* YES MATCH */
   END WHERE_IN;

 WHERE_LIKE: PROC(PSTR,PLIKE) RETURNS(BIT(1));
 /**********************************************************************
 *                                                                     *
 * CALLED TO DO A LIKE COMPARISON. A % CHARACTER REPRESENTS ANY STRING *
 * OF ZERO OR MORE CHARACTERS.  A _ CHARACTER REPRESENTS A SINGLE      *
 * CHARACTER POSITION AND MATCHES ANY SINGLE CHARACTER.                *
 *                                                                     *
 **********************************************************************/
   DCL (PSTR,PLIKE) CHAR(*) VAR;
   DCL (I,J,K,L,M,N,P) FIXED BIN(15,0);
   DCL CH CHAR(1);
   J=1;
   DO I=1 REPEAT I+1 WHILE(I<=LENGTH(PLIKE) & J<=LENGTH(PSTR));
     CH=SUBSTR(PLIKE,I,1);
     SELECT(CH);
       WHEN('%') DO;
         IF I=LENGTH(PLIKE)
           THEN RETURN('1'B); /* MATCH */
         K=INDEX(SUBSTR(PLIKE,I+1),'%');
         IF K=0
           THEN K=LENGTH(PLIKE)+1;
           ELSE K=K+I;
         M=INDEX(SUBSTR(PLIKE,I+1),'_');
         IF M=0
           THEN M=LENGTH(PLIKE)+1;
           ELSE M=M+I;
         N=MIN(K,M);
         P=INDEX(SUBSTR(PSTR,J),SUBSTR(PLIKE,I+1,N-I-1));
         IF P=0
           THEN RETURN('0'B); /* NO MATCH */
         I=N-1;
         J=J+P+N-I-3;
         END;
       WHEN('_');
       OTHERWISE
         IF SUBSTR(PSTR,J,1)^=SUBSTR(PLIKE,I,1)
           THEN RETURN('0'B); /* NO MATCH */
       END; /* SELECT */
     J=J+1;
     END;
   RETURN('1'B); /* MATCH */
   END WHERE_LIKE;

   END ABE049;
