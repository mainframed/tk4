 /* COPYRIGHT 1983 BY THOMAS GLEN SMITH */
 /* ABE048 - CONVERT (TO-SPEC) <FORM1> <FORM2> LEFT/RIGHT   */
 /*                  1         2       3       4            */
   %INCLUDE ABESUB;
 ABESUB(ABE048) PARS(000000000000) CHECK(YES);
   %INCLUDE ABESUBA;
   DCL 1 LRN_STRUCTURE BASED(LRNPTR),
   %INCLUDE ABELRN;
   %INCLUDE ABELRNA;

   DCL NSAVE FIXED BIN(15,0);
   DCL (SETCAPS,TRIN,TROUT) ENTRY;
   DCL (PREFIX,SUFFIX) ENTRY(CHAR(*),CHAR(*))
     RETURNS(FIXED BIN(15,0));
   DCL PTRIN ENTRY(PTR)
     RETURNS(FIXED BIN(31,0));
   DCL PTROUT ENTRY(FIXED BIN(31,0))
     RETURNS(PTR);
   DCL CALCPRT ENTRY(DEC FLOAT(16))
     RETURNS(CHAR(80) VAR);
   DCL SAVRHN CHAR(8);
   DCL (LEFTSW,RIGHTSW,NAMESW) BIT(1) INIT('0'B);
   DCL TLEFTSW BIT(1);
   DCL KEYTABLE(7) CHAR(80) VAR STATIC
     INIT('CHAR','HEX','FIXED','PACKED','FLOAT','BIT','BEST');
   DCL LRKEYS(3) CHAR(80) VAR STATIC INIT('LEFT','RIGHT','NAME');
   DCL INDX FIXED BIN(15,0);
   DCL OPER CHAR(80) VAR;
   DCL (ORGRHP,ORGTRH,TRH,SAVPTR,ORGPTR,SEQPTR) PTR;
   DCL 1 FSTR(2),
     2 TYPE FIXED BIN(15,0) INIT((2)0),
       /* 1=CHAR,2=HEX,3=FIXED,4=PACKED,5=FLOAT */
     2 OFF FIXED BIN(15,0) INIT((2)0),
     2 LEN FIXED BIN(15,0) INIT((2)0),
     2 SCALE FIXED BIN(15,0) INIT((2)0);
   DCL (INBUF,OUTBUF) CHAR(*) VAR CONTROLLED;
   DCL (INPTR,OUTPTR) PTR;

   RHRC=0; /* SET DEFAULT RETURN CODE */

   /* PROCESS FROM-SPEC AND TO-SPEC */
   DO I=1 TO 2;
     IF PARY(I)=''
       THEN DO;
         MSGDATA='MISSING OPERAND';
         RHRC=8;
         RETURN;
         END;
     CALL SETCAPS(PARY(I));
     CALL #SPARS(PARY(I),KEYTABLE,OPER,INDX);
     IF INDX=0
       THEN DO; /* INVALID OPERAND */
         MSGDATA='INVALID OPERAND';
         RHRC=8;
         RETURN;
         END;
       ELSE DO;
         RHRC=SETFSTR(I);
         IF RHRC^=0
           THEN DO; /* INVALID OPERAND */
             MSGDATA='INVALID OPERAND';
             RETURN;
             END;
         END;
     END;

   DO I=3 TO HBOUND(PARY,1) WHILE(PARY(I)^='');
     CALL SETCAPS(PARY(I));
     CALL #SPARS(PARY(I),LRKEYS,OPER,INDX);
     SELECT(INDX);
       WHEN(1) LEFTSW='1'B;
       WHEN(2) RIGHTSW='1'B;
       OTHERWISE DO;
         MSGDATA='INVALID OPERAND';
         RHRC=8;
         RETURN;
         END;
       END; /* SELECT */
     END;
   ALLOC INBUF CHAR(RHPTR->BUFPTR->BUFLN);
   ALLOC OUTBUF CHAR(RHPTR->BUFPTR->BUFLN);
   INBUF,OUTBUF='';
   /* SET INPTR,OUTPTR - BYPASS HALFWORD LENGTH FIELDS */
   INPTR=PTROUT(PTRIN(ADDR(INBUF))+2);
   OUTPTR=PTROUT(PTRIN(ADDR(OUTBUF))+2);

   /* MAINLINE PROCESSING */
   DO FOREVER=1 REPEAT FOREVER;
     CALL #ABELSP(RHHDRPT,LRNPTR); /* GET NEXT FROM-SEGMENT */
     IF LRN_STRUCTURE.LRN_BUFP=NULL
       THEN LEAVE;
     CALL CONVERT; /* GO DO CONVERSION */
     CALL #ABEINS(OUTBUF,LRN_BUFP,OFF(2),LEN(2));
     END;
   FREE INBUF;
   FREE OUTBUF;
   RHRC=0; /* ALL DONE */

 (SIZE): CONVERT: PROC;
 /**********************************************************************
 *  DOES THE ACTUAL CONVERSION.  LSPBUF CONTAINS DATA TO BE CONVERTED. *
 **********************************************************************/
   DCL (I,J,K,L,O,P,S,T) FIXED BIN(15,0);
   DCL ERRCNT FIXED BIN(15,0) INIT(0);
   DCL PADCH CHAR(1);
   DCL MYBIT BIT(32760) VAR,
       MYCH CHAR(4095) VAR BASED(ADDR(MYBIT)),
       MYLEN FIXED BIN(15,0) BASED(ADDR(MYBIT));
   DCL (BITSTR BIT(32767) VAR,
       FIXED_SHORT FIXED BIN(15,0),
       FIXED_LONG  FIXED BIN(31,0),
       FLOAT_SHORT    BIN FLOAT(21),
       FLOAT_LONG     BIN FLOAT(53),
       FLOAT_EXTENDED BIN FLOAT(109),
       PACKED_1 FIXED DEC(1,0),
       PACKED_2 FIXED DEC(3,0),
       PACKED_3 FIXED DEC(5,0),
       PACKED_4 FIXED DEC(7,0),
       PACKED_5 FIXED DEC(9,0),
       PACKED_6 FIXED DEC(11,0),
       PACKED_7 FIXED DEC(13,0),
       PACKED_8 FIXED DEC(15,0)) BASED(SOMEPTR);
   /* NEXT GET INPUT DATA */
   IF OFF(1)>LENGTH(LSPBUF)
     THEN INBUF='';
     ELSE INBUF=SUBSTR(LSPBUF,OFF(1),
       MIN(LEN(1),LENGTH(LSPBUF)-OFF(1)+1));
   IF LENGTH(INBUF)<LEN(1)
     THEN SELECT(TYPE(1));
       WHEN(3,5,6) /* FIXED,FLOAT */
         INBUF=INBUF××LOW(LEN(1)-LENGTH(INBUF));
       WHEN(1) /* CHAR */
         INBUF=INBUF××REPEAT(' ',LEN(1)-LENGTH(INBUF)-1);
       WHEN(2) /* HEX */
         INBUF=INBUF××REPEAT('0',LEN(1)-LENGTH(INBUF)-1);
       WHEN(4) /* PACKED */
         INBUF=LOW(LEN(1)-LENGTH(INBUF))××INBUF;
       END;
   L=LENGTH(INBUF); /* L=LENGTH OF INPUT DATA */
   T=TYPE(1)*10+TYPE(2);
   PADCH=LOW(1); /* DEFAULT PADDING CHARACTER */
   OUTBUF=REPEAT(' ',LEN(2)-1);
   IF LENGTH(OUTBUF)<LEN(2)
     THEN IF LEN(2)<=16
       THEN GOTO BADDATA; /* MUST HAVE SOME LENGTH */
   ON CONVERSION GOTO BADDATA;
   ON SIZE       GOTO BADDATA;
   ON ERROR GOTO BADDATA;
   GOTO SELECT;
 BADDATA:
   OUTBUF=REPEAT('*',LEN(2)-1);
   GO TO BYSEL;
 SELECT:
   SELECT(T);
     WHEN(11) DO; /* CHAR-TO-CHAR */
       IF LEN(2)<L
         THEN OUTBUF=SUBSTR(INBUF,1,LEN(2));
         ELSE OUTBUF=INBUF;
       PADCH=' ';
       END;
     WHEN(12) DO; /* CHAR TO HEX */
       OUTBUF=REPEAT(' ',L*2-1);
       CALL TROUT(INBUF,OUTBUF);
       IF LENGTH(OUTBUF)>LEN(2)
         THEN OUTBUF=SUBSTR(OUTBUF,1,LEN(2));
       PADCH='0';
       END;
     WHEN(13) DO; /* CHAR TO FIXED */
       OUTBUF=REPEAT(' ',LEN(2)-1);
       IF LEN(2)=2
         THEN OUTPTR->FIXED_SHORT=INBUF;
         ELSE OUTPTR->FIXED_LONG=INBUF;
       END;
     WHEN(14) DO; /* CHAR TO PACKED */
       SELECT(LEN(2));
         WHEN(1) OUTPTR->PACKED_1=INBUF;
         WHEN(2) OUTPTR->PACKED_2=INBUF;
         WHEN(3) OUTPTR->PACKED_3=INBUF;
         WHEN(4) OUTPTR->PACKED_4=INBUF;
         WHEN(5) OUTPTR->PACKED_5=INBUF;
         WHEN(6) OUTPTR->PACKED_6=INBUF;
         WHEN(7) OUTPTR->PACKED_7=INBUF;
         WHEN(8) OUTPTR->PACKED_8=INBUF;
         END;
       END;
     WHEN(15) DO; /* CHAR TO FLOAT */
       SELECT(LEN(2));
         WHEN(4)  OUTPTR->FLOAT_SHORT=INBUF;
         WHEN(8)  OUTPTR->FLOAT_LONG=INBUF;
         WHEN(16) OUTPTR->FLOAT_EXTENDED=INBUF;
         END; /* SELECT */
       END;
     WHEN(16) DO; /* CHAR TO BIT */
       I=MOD(LENGTH(INBUF),8);
       IF I^=0
         THEN INBUF=REPEAT('0',8-I-1)××INBUF; /* LENGTH M/B /8 */
       MYBIT=INBUF;
       MYLEN=MYLEN/8;
       OUTBUF=MYCH;
       END;
     WHEN(21,22,23,24,25,26) DO; /* HEX TO WHATEVER */
       IF VERIFY(INBUF,'0123456789ABCDEF')=0
         THEN CALL TRIN(INBUF,OUTBUF);
         ELSE OUTBUF=REPEAT('*',LEN(2)-1);
       PADCH=' ';
       END;
     WHEN(31) DO; /* FIXED TO CHAR */
       IF LEN(1)=2
         THEN OUTBUF=INPTR->FIXED_SHORT;
         ELSE OUTBUF=INPTR->FIXED_LONG;
       PADCH=' ';
       END;
     WHEN(32) DO; /* FIXED TO HEX */
       CALL TROUT(INBUF,OUTBUF);
       PADCH='0';
       END;
     WHEN(33) DO; /* FIXED TO FIXED */
       SELECT(LEN(2)*10+LEN(1));
         WHEN(22) OUTPTR->FIXED_SHORT=INPTR->FIXED_SHORT;
         WHEN(24) OUTPTR->FIXED_SHORT=INPTR->FIXED_LONG;
         WHEN(42) OUTPTR->FIXED_LONG=INPTR->FIXED_SHORT;
         WHEN(44) OUTPTR->FIXED_LONG=INPTR->FIXED_LONG;
         END;
       END;
     WHEN(34) DO; /* FIXED TO PACKED */
       IF LEN(1)=2
         THEN SELECT(LEN(2));
           WHEN(1) OUTPTR->PACKED_1=INPTR->FIXED_SHORT;
           WHEN(2) OUTPTR->PACKED_2=INPTR->FIXED_SHORT;
           WHEN(3) OUTPTR->PACKED_3=INPTR->FIXED_SHORT;
           WHEN(4) OUTPTR->PACKED_4=INPTR->FIXED_SHORT;
           WHEN(5) OUTPTR->PACKED_5=INPTR->FIXED_SHORT;
           WHEN(6) OUTPTR->PACKED_6=INPTR->FIXED_SHORT;
           WHEN(7) OUTPTR->PACKED_7=INPTR->FIXED_SHORT;
           WHEN(8) OUTPTR->PACKED_8=INPTR->FIXED_SHORT;
           END;
         ELSE SELECT(LEN(2));
           WHEN(1) OUTPTR->PACKED_1=INPTR->FIXED_LONG;
           WHEN(2) OUTPTR->PACKED_2=INPTR->FIXED_LONG;
           WHEN(3) OUTPTR->PACKED_3=INPTR->FIXED_LONG;
           WHEN(4) OUTPTR->PACKED_4=INPTR->FIXED_LONG;
           WHEN(5) OUTPTR->PACKED_5=INPTR->FIXED_LONG;
           WHEN(6) OUTPTR->PACKED_6=INPTR->FIXED_LONG;
           WHEN(7) OUTPTR->PACKED_7=INPTR->FIXED_LONG;
           WHEN(8) OUTPTR->PACKED_8=INPTR->FIXED_LONG;
           END;
       END;
     WHEN(35) DO; /* FIXED TO FLOAT */
       IF LEN(1)=2
         THEN SELECT(LEN(2));
           WHEN(4) OUTPTR->FLOAT_SHORT=INPTR->FIXED_SHORT;
           WHEN(8) OUTPTR->FLOAT_LONG=INPTR->FIXED_SHORT;
           WHEN(16) OUTPTR->FLOAT_EXTENDED=INPTR->FIXED_SHORT;
           END;
         ELSE SELECT(LEN(2));
           WHEN(4) OUTPTR->FLOAT_SHORT=INPTR->FIXED_LONG;
           WHEN(8) OUTPTR->FLOAT_LONG=INPTR->FIXED_LONG;
           WHEN(16) OUTPTR->FLOAT_EXTENDED=INPTR->FIXED_LONG;
           END;
       END;
     WHEN(36) DO; /* FIXED TO BIT */
       IF LEN(1)=2
         THEN MYBIT=INPTR->FIXED_SHORT;
         ELSE MYBIT=INPTR->FIXED_LONG;
       I=MOD(LENGTH(MYBIT),8);
       IF I^=0
         THEN MYBIT=REPEAT('0'B,8-I-1)××MYBIT;
       MYLEN=MYLEN/8; /* SET LENGTH FOR CHARACTER */
       OUTBUF=MYCH;
       END;
     WHEN(41) DO; /* PACKED TO CHAR */
       SELECT(LEN(1));
         WHEN(1) OUTBUF=INPTR->PACKED_1;
         WHEN(2) OUTBUF=INPTR->PACKED_2;
         WHEN(3) OUTBUF=INPTR->PACKED_3;
         WHEN(4) OUTBUF=INPTR->PACKED_4;
         WHEN(5) OUTBUF=INPTR->PACKED_5;
         WHEN(6) OUTBUF=INPTR->PACKED_6;
         WHEN(7) OUTBUF=INPTR->PACKED_7;
         WHEN(8) OUTBUF=INPTR->PACKED_8;
         END;
       PADCH=' ';
       END;
     WHEN(42) DO; /* PACKED TO HEX */
       CALL TROUT(INBUF,OUTBUF);
       PADCH='0';
       END;
     WHEN(43) DO; /* PACKED TO FIXED */
       IF LEN(2)=2
         THEN SELECT(LEN(1));
           WHEN(1) OUTPTR->FIXED_SHORT=INPTR->PACKED_1;
           WHEN(2) OUTPTR->FIXED_SHORT=INPTR->PACKED_2;
           WHEN(3) OUTPTR->FIXED_SHORT=INPTR->PACKED_3;
           WHEN(4) OUTPTR->FIXED_SHORT=INPTR->PACKED_4;
           WHEN(5) OUTPTR->FIXED_SHORT=INPTR->PACKED_5;
           WHEN(6) OUTPTR->FIXED_SHORT=INPTR->PACKED_6;
           WHEN(7) OUTPTR->FIXED_SHORT=INPTR->PACKED_7;
           WHEN(8) OUTPTR->FIXED_SHORT=INPTR->PACKED_8;
           END;
         ELSE SELECT(LEN(1));
           WHEN(1) OUTPTR->FIXED_LONG=INPTR->PACKED_1;
           WHEN(2) OUTPTR->FIXED_LONG=INPTR->PACKED_2;
           WHEN(3) OUTPTR->FIXED_LONG=INPTR->PACKED_3;
           WHEN(4) OUTPTR->FIXED_LONG=INPTR->PACKED_4;
           WHEN(5) OUTPTR->FIXED_LONG=INPTR->PACKED_5;
           WHEN(6) OUTPTR->FIXED_LONG=INPTR->PACKED_6;
           WHEN(7) OUTPTR->FIXED_LONG=INPTR->PACKED_7;
           WHEN(8) OUTPTR->FIXED_LONG=INPTR->PACKED_8;
           END;
       END;
     WHEN(44) DO; /* PACKED TO PACKED */
       SELECT(LEN(1));
         WHEN(1) OUTPTR->PACKED_1=INPTR->PACKED_1;
         WHEN(2) OUTPTR->PACKED_2=INPTR->PACKED_2;
         WHEN(3) OUTPTR->PACKED_3=INPTR->PACKED_3;
         WHEN(4) OUTPTR->PACKED_4=INPTR->PACKED_4;
         WHEN(5) OUTPTR->PACKED_5=INPTR->PACKED_5;
         WHEN(6) OUTPTR->PACKED_6=INPTR->PACKED_6;
         WHEN(7) OUTPTR->PACKED_7=INPTR->PACKED_7;
         WHEN(8) OUTPTR->PACKED_8=INPTR->PACKED_8;
         END;
       END;
     WHEN(45) DO; /* PACKED TO FLOAT */
       SELECT(LEN(2));
         WHEN(4)
           SELECT(LEN(1));
             WHEN(1) OUTPTR->FLOAT_SHORT=INPTR->PACKED_1;
             WHEN(2) OUTPTR->FLOAT_SHORT=INPTR->PACKED_2;
             WHEN(3) OUTPTR->FLOAT_SHORT=INPTR->PACKED_3;
             WHEN(4) OUTPTR->FLOAT_SHORT=INPTR->PACKED_4;
             WHEN(5) OUTPTR->FLOAT_SHORT=INPTR->PACKED_5;
             WHEN(6) OUTPTR->FLOAT_SHORT=INPTR->PACKED_6;
             WHEN(7) OUTPTR->FLOAT_SHORT=INPTR->PACKED_7;
             WHEN(8) OUTPTR->FLOAT_SHORT=INPTR->PACKED_8;
             END;
         WHEN(8)
           SELECT(LEN(1));
             WHEN(1) OUTPTR->FLOAT_LONG=INPTR->PACKED_1;
             WHEN(2) OUTPTR->FLOAT_LONG=INPTR->PACKED_2;
             WHEN(3) OUTPTR->FLOAT_LONG=INPTR->PACKED_3;
             WHEN(4) OUTPTR->FLOAT_LONG=INPTR->PACKED_4;
             WHEN(5) OUTPTR->FLOAT_LONG=INPTR->PACKED_5;
             WHEN(6) OUTPTR->FLOAT_LONG=INPTR->PACKED_6;
             WHEN(7) OUTPTR->FLOAT_LONG=INPTR->PACKED_7;
             WHEN(8) OUTPTR->FLOAT_LONG=INPTR->PACKED_8;
             END;
         WHEN(16)
           SELECT(LEN(1));
             WHEN(1) OUTPTR->FLOAT_EXTENDED=INPTR->PACKED_1;
             WHEN(2) OUTPTR->FLOAT_EXTENDED=INPTR->PACKED_2;
             WHEN(3) OUTPTR->FLOAT_EXTENDED=INPTR->PACKED_3;
             WHEN(4) OUTPTR->FLOAT_EXTENDED=INPTR->PACKED_4;
             WHEN(5) OUTPTR->FLOAT_EXTENDED=INPTR->PACKED_5;
             WHEN(6) OUTPTR->FLOAT_EXTENDED=INPTR->PACKED_6;
             WHEN(7) OUTPTR->FLOAT_EXTENDED=INPTR->PACKED_7;
             WHEN(8) OUTPTR->FLOAT_EXTENDED=INPTR->PACKED_8;
             END;
         END;
       END;
     WHEN(46) DO; /* PACKED TO BIT */
       SELECT(LEN(1));
         WHEN(1) MYBIT=INPTR->PACKED_1;
         WHEN(2) MYBIT=INPTR->PACKED_2;
         WHEN(3) MYBIT=INPTR->PACKED_3;
         WHEN(4) MYBIT=INPTR->PACKED_4;
         WHEN(5) MYBIT=INPTR->PACKED_5;
         WHEN(6) MYBIT=INPTR->PACKED_6;
         WHEN(7) MYBIT=INPTR->PACKED_7;
         WHEN(8) MYBIT=INPTR->PACKED_8;
         END;
       I=MOD(LENGTH(MYBIT),8);
       IF I^=0
         THEN MYBIT=REPEAT('0'B,8-I-1)××MYBIT;
       MYLEN=MYLEN/8; /* ADJUST LENGTH FOR CHARACTER MOVE */
       OUTBUF=MYCH;
       END;
     WHEN(51) DO; /* FLOAT TO CHAR */
       SELECT(LEN(1));
         WHEN(4) OUTBUF=INPTR->FLOAT_SHORT;
         WHEN(8) OUTBUF=INPTR->FLOAT_LONG;
         WHEN(16) OUTBUF=INPTR->FLOAT_EXTENDED;
         END;
       PADCH=' ';
       END;
     WHEN(52) DO; /* FLOAT TO HEX */
       CALL TROUT(INBUF,OUTBUF);
       END;
     WHEN(53) DO; /* FLOAT TO FIXED */
       IF LEN(2)=2
         THEN SELECT(LEN(1));
           WHEN(4) OUTPTR->FIXED_SHORT=INPTR->FLOAT_SHORT;
           WHEN(8) OUTPTR->FIXED_SHORT=INPTR->FLOAT_LONG;
           WHEN(16) OUTPTR->FIXED_SHORT=INPTR->FLOAT_EXTENDED;
           END;
         ELSE SELECT(LEN(1));
           WHEN(4) OUTPTR->FIXED_LONG=INPTR->FLOAT_SHORT;
           WHEN(8) OUTPTR->FIXED_LONG=INPTR->FLOAT_LONG;
           WHEN(16) OUTPTR->FIXED_LONG=INPTR->FLOAT_EXTENDED;
           END;
       END;
     WHEN(54) DO; /* FLOAT TO PACKED */
       SELECT(LEN(1));
         WHEN(4) SELECT(LEN(2));
           WHEN(1) OUTPTR->PACKED_1=INPTR->FLOAT_SHORT;
           WHEN(2) OUTPTR->PACKED_2=INPTR->FLOAT_SHORT;
           WHEN(3) OUTPTR->PACKED_3=INPTR->FLOAT_SHORT;
           WHEN(4) OUTPTR->PACKED_4=INPTR->FLOAT_SHORT;
           WHEN(5) OUTPTR->PACKED_5=INPTR->FLOAT_SHORT;
           WHEN(6) OUTPTR->PACKED_6=INPTR->FLOAT_SHORT;
           WHEN(7) OUTPTR->PACKED_7=INPTR->FLOAT_SHORT;
           WHEN(8) OUTPTR->PACKED_8=INPTR->FLOAT_SHORT;
           END;
         WHEN(8) SELECT(LEN(2));
           WHEN(1) OUTPTR->PACKED_1=INPTR->FLOAT_LONG;
           WHEN(2) OUTPTR->PACKED_2=INPTR->FLOAT_LONG;
           WHEN(3) OUTPTR->PACKED_3=INPTR->FLOAT_LONG;
           WHEN(4) OUTPTR->PACKED_4=INPTR->FLOAT_LONG;
           WHEN(5) OUTPTR->PACKED_5=INPTR->FLOAT_LONG;
           WHEN(6) OUTPTR->PACKED_6=INPTR->FLOAT_LONG;
           WHEN(7) OUTPTR->PACKED_7=INPTR->FLOAT_LONG;
           WHEN(8) OUTPTR->PACKED_8=INPTR->FLOAT_LONG;
           END;
         WHEN(16) SELECT(LEN(2));
           WHEN(1) OUTPTR->PACKED_1=INPTR->FLOAT_EXTENDED;
           WHEN(2) OUTPTR->PACKED_2=INPTR->FLOAT_EXTENDED;
           WHEN(3) OUTPTR->PACKED_3=INPTR->FLOAT_EXTENDED;
           WHEN(4) OUTPTR->PACKED_4=INPTR->FLOAT_EXTENDED;
           WHEN(5) OUTPTR->PACKED_5=INPTR->FLOAT_EXTENDED;
           WHEN(6) OUTPTR->PACKED_6=INPTR->FLOAT_EXTENDED;
           WHEN(7) OUTPTR->PACKED_7=INPTR->FLOAT_EXTENDED;
           WHEN(8) OUTPTR->PACKED_8=INPTR->FLOAT_EXTENDED;
           END;
         END;
       END;
     WHEN(55) DO; /* FLOAT TO FLOAT */
       SELECT(LEN(2)*100+LEN(1));
         WHEN(0404) OUTPTR->FLOAT_SHORT=INPTR->FLOAT_SHORT;
         WHEN(0408) OUTPTR->FLOAT_SHORT=INPTR->FLOAT_LONG;
         WHEN(0416) OUTPTR->FLOAT_SHORT=INPTR->FLOAT_EXTENDED;
         WHEN(0804) OUTPTR->FLOAT_LONG=INPTR->FLOAT_SHORT;
         WHEN(0808) OUTPTR->FLOAT_LONG=INPTR->FLOAT_LONG;
         WHEN(0816) OUTPTR->FLOAT_LONG=INPTR->FLOAT_EXTENDED;
         WHEN(1604) OUTPTR->FLOAT_EXTENDED=INPTR->FLOAT_SHORT;
         WHEN(1608) OUTPTR->FLOAT_EXTENDED=INPTR->FLOAT_LONG;
         WHEN(1616) OUTPTR->FLOAT_EXTENDED=INPTR->FLOAT_EXTENDED;
         END;
       END;
     WHEN(56) DO; /* FLOAT TO BIT */
       SELECT(LEN(1));
         WHEN(4) MYBIT=INPTR->FLOAT_SHORT;
         WHEN(8) MYBIT=INPTR->FLOAT_LONG;
         WHEN(16) MYBIT=INPTR->FLOAT_EXTENDED;
         END;
       I=MOD(LENGTH(MYBIT),8);
       IF I^=0
         THEN MYBIT=REPEAT('0'B,8-I-1)××MYBIT;
       MYLEN=MYLEN/8;
       OUTBUF=MYCH;
       END;
     WHEN(61) DO; /* BIT TO CHAR */
       MYCH=INBUF;
       MYLEN=MYLEN*8;
       OUTBUF=MYBIT;
       PADCH='0';
       END;
     WHEN(62) DO; /* BIT TO HEX */
       CALL TROUT(INBUF,OUTBUF);
       PADCH='0';
       END;
     WHEN(63) DO; /* BIT TO FIXED */
       MYCH=INBUF;
       MYLEN=MYLEN*8;
       IF LEN(2)=2
         THEN OUTPTR->FIXED_SHORT=MYBIT;
         ELSE OUTPTR->FIXED_LONG=MYBIT;
       END;
     WHEN(64) DO; /* BIT TO PACKED */
       MYCH=INBUF;
       MYLEN=MYLEN*8;
       SELECT(LEN(2));
         WHEN(1) OUTPTR->PACKED_1=MYBIT;
         WHEN(2) OUTPTR->PACKED_2=MYBIT;
         WHEN(3) OUTPTR->PACKED_3=MYBIT;
         WHEN(4) OUTPTR->PACKED_4=MYBIT;
         WHEN(5) OUTPTR->PACKED_5=MYBIT;
         WHEN(6) OUTPTR->PACKED_6=MYBIT;
         WHEN(7) OUTPTR->PACKED_7=MYBIT;
         WHEN(8) OUTPTR->PACKED_8=MYBIT;
         END;
       END;
     WHEN(65) DO; /* BIT TO FLOAT */
       MYCH=INBUF;
       MYLEN=MYLEN*8;
       SELECT(LEN(2));
         WHEN(4) OUTPTR->FLOAT_SHORT=MYBIT;
         WHEN(8) OUTPTR->FLOAT_LONG=MYBIT;
         WHEN(16) OUTPTR->FLOAT_EXTENDED=MYBIT;
         END;
       END;
     WHEN(66) DO; /* BIT TO BIT */
       OUTBUF=INBUF;
       END;
     WHEN(67) DO; /* BIT TO BEST */
       MYCH=INBUF;
       MYLEN=MYLEN*8;
       OUTBUF=CALCPRT(MYBIT);
       END;
     END; /* SELECT */
   /* NOW APPLY THE SCALE PARAMETERS */
   S=(SCALE(1)-SCALE(2))*10;
   SELECT(SIGN(S));
     WHEN(1) DO; /* MUST SCALE DOWN */
       SELECT(TYPE(2));
         WHEN(3) /* FIXED */
           IF LEN(2)=2
             THEN OUTPTR->FIXED_SHORT=OUTPTR->FIXED_SHORT/S;
             ELSE OUTPTR->FIXED_LONG=OUTPTR->FIXED_LONG/S;
         WHEN(4) /* PACKED */
           SELECT(LEN(2));
             WHEN(1) OUTPTR->PACKED_1=OUTPTR->PACKED_1/S;
             WHEN(2) OUTPTR->PACKED_2=OUTPTR->PACKED_2/S;
             WHEN(3) OUTPTR->PACKED_3=OUTPTR->PACKED_3/S;
             WHEN(4) OUTPTR->PACKED_4=OUTPTR->PACKED_4/S;
             WHEN(5) OUTPTR->PACKED_5=OUTPTR->PACKED_5/S;
             WHEN(6) OUTPTR->PACKED_6=OUTPTR->PACKED_6/S;
             WHEN(7) OUTPTR->PACKED_7=OUTPTR->PACKED_7/S;
             WHEN(8) OUTPTR->PACKED_8=OUTPTR->PACKED_8/S;
             END;
         WHEN(5) /* FLOAT */
           SELECT(LEN(2));
             WHEN(4) OUTPTR->FLOAT_SHORT=OUTPTR->FLOAT_SHORT/S;
             WHEN(8) OUTPTR->FLOAT_LONG=OUTPTR->FLOAT_LONG/S;
             WHEN(16) OUTPTR->FLOAT_EXTENDED=OUTPTR->FLOAT_EXTENDED/S;
             END;
         OTHERWISE;
         END;
       END;
     WHEN(-1) DO; /* MUST SCALE UP */
       S=0-S;
       SELECT(TYPE(2));
         WHEN(3) /* FIXED */
           IF LEN(2)=2
             THEN OUTPTR->FIXED_SHORT=OUTPTR->FIXED_SHORT*S;
             ELSE OUTPTR->FIXED_LONG=OUTPTR->FIXED_LONG*S;
         WHEN(4) /* PACKED */
           SELECT(LEN(2));
             WHEN(1) OUTPTR->PACKED_1=OUTPTR->PACKED_1*S;
             WHEN(2) OUTPTR->PACKED_2=OUTPTR->PACKED_2*S;
             WHEN(3) OUTPTR->PACKED_3=OUTPTR->PACKED_3*S;
             WHEN(4) OUTPTR->PACKED_4=OUTPTR->PACKED_4*S;
             WHEN(5) OUTPTR->PACKED_5=OUTPTR->PACKED_5*S;
             WHEN(6) OUTPTR->PACKED_6=OUTPTR->PACKED_6*S;
             WHEN(7) OUTPTR->PACKED_7=OUTPTR->PACKED_7*S;
             WHEN(8) OUTPTR->PACKED_8=OUTPTR->PACKED_8*S;
             END;
         WHEN(5) /* FLOAT */
           SELECT(LEN(2));
             WHEN(4) OUTPTR->FLOAT_SHORT=OUTPTR->FLOAT_SHORT*S;
             WHEN(8) OUTPTR->FLOAT_LONG=OUTPTR->FLOAT_LONG*S;
             WHEN(16) OUTPTR->FLOAT_EXTENDED=OUTPTR->FLOAT_EXTENDED*S;
             END;
         OTHERWISE;
         END;
       END;
     OTHERWISE; /* SCALE DOES NOT CHANGE */
     END;
 BYSEL:; /* CONTROL BRANCHES HERE ON CONVERSION AND SIZE CONDITION,
            AFTER SETTING OUTPUT DATA TO ASTERISKS. */
   REVERT ERROR;
   IF TYPE(2)=1 × TYPE(2)=2
     THEN DO; /* MUST BE CHAR, OR HEX FOR PADDING */
       IF (LEFTSW × RIGHTSW) /* DID USER OVERRIDE PAD DEFAULT? */
         THEN TLEFTSW=LEFTSW;
         ELSE IF TYPE(2)=1
           THEN TLEFTSW='1'B; /* LEFT ADJUST */
           ELSE TLEFTSW='0'B; /* RIGHT ADJUST */
       IF LENGTH(OUTBUF)>0
         THEN OUTBUF=SUBSTR(OUTBUF,1,SUFFIX(OUTBUF,' '));
       IF LENGTH(OUTBUF)>0
         THEN DO;
           P=PREFIX(OUTBUF,' ');
           IF P=0
             THEN OUTBUF='';
               ELSE OUTBUF=SUBSTR(OUTBUF,P);
           END;
       IF LENGTH(OUTBUF)>0
         THEN IF TLEFTSW
           THEN OUTBUF=SUBSTR(OUTBUF,1,SUFFIX(OUTBUF,PADCH));
           ELSE DO;
             P=PREFIX(OUTBUF,PADCH);
             IF P=0
               THEN OUTBUF='';
               ELSE OUTBUF=SUBSTR(OUTBUF,P);
             END;
       IF LENGTH(OUTBUF)>LEN(2)
         THEN OUTBUF=REPEAT('*',LEN(2)-1);
       /* NOW PAD IF NECESSARY */
       IF LENGTH(OUTBUF)<LEN(2)
         THEN IF TLEFTSW
           THEN OUTBUF=OUTBUF××REPEAT(PADCH,LEN(2)-LENGTH(OUTBUF)-1);
           ELSE OUTBUF=REPEAT(PADCH,LEN(2)-LENGTH(OUTBUF)-1)××OUTBUF;
       END;
   END CONVERT;

 SETFSTR:  PROC(PI) RETURNS(FIXED BIN(31,0));
 /* PARSES TYPE,OFFSET,LENGTH,SCALE FOR <FORM1> AND <FORM2> */
   DCL (PI,IP,I,J,K,L) FIXED BIN(31,0);
   IF PI=1
     THEN IP=2; /* IP=INDEX TO OTHER FORM */
     ELSE IP=1;
   FSTR(PI)=FSTR(IP); /* SET INITIAL DEFAULTS */
   TYPE(PI)=INDX;
   SCALE(PI)=0; /* DON'T DEFAULT SCALE */
   DCL PARY(16) CHAR(256) VAR;
   DCL PARQCK(16) BIT(1);
   DCL NUMCK BIT(16) STATIC INIT('0'B);
   I=#ABEPRS(OPER,PARY,PARQCK,NUMCK);
   IF I^=0
     THEN RETURN(4); /* INVALID OPERAND */
   IF PARY(1)^=''
     THEN DO;
       OFF(PI)=PARY(1);
       IF PARY(2)^=''
         THEN DO;
           LEN(PI)=PARY(2);
           IF PARY(3)^=''
             THEN SCALE(PI)=PARY(3);
           END;
       END;
   SELECT(INDX);
     WHEN(1,2,5,6)
       IF SCALE(PI)^=0
         THEN RETURN(4); /* NO SCALE ALLOWED FOR CHAR,HEX,FLOAT, BIT */
       OTHERWISE;
       END;
   SELECT(INDX);
     WHEN(6) /* BIT */
       IF LEN(PI)>4095
         THEN RETURN(4); /* MAX LEN FOR BIT DATA = 4095 */
     WHEN(5) /* FLOATING POINT */
       IF ^(LEN(PI)=4 × LEN(PI)=8 × LEN(PI)=16)
         THEN RETURN(4); /* FLOATING POINT M/B LEN=4, 8, OR 16 */
     WHEN(4) /* PACKED DECIMAL */
       IF LEN(PI)>8
         THEN RETURN(4); /* PACKED DECIMAL LENGTH <= 8 */
     WHEN(3) /* FIXED */
       IF ^(LEN(PI)=4 × LEN(PI)=2)
         THEN RETURN(4);
     OTHERWISE IF LEN(PI)>32767
       THEN RETURN(4); /* ALL OTHERS, MAX LENGTH=32767 */
     END; /* SELECT */
   RETURN(0);
   END SETFSTR;
   END ABE048;
