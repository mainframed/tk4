 % NOPRINT;
   % @ALLOCI = 'Y';
   % DCL @ALLOC ENTRY;
   % IF @DA08SW ^= 'Y'
     % THEN % DO;
       % @DA08SW = 'Y';
       % INCLUDE DAIR08;
       DCL D08PTR PTR;
       D08PTR = ADDR(DAIR08);
       % END;
 % @ALLOC:  PROC(P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11,P12,P13,P14,P15)
            STATEMENT RETURNS(CHAR);
 /* @ALLOC */
 /*
0*$.HE GENERALIZED SUBROUTINES - @ALLOC
0*$.HE PLI PREPROCESSOR TEXT
0*$.HE DYNAMICALLY ALLOCATE A DATA SET
0*$.PL 55
0*$.PN 0
0*$.PA
0*$.SS
0*$.NF
0*$09/02/76
0*$AUTHOR:  T. SMITH
0*$SOURCE MODULE NAME:  @ALLOC
0*$DOCUMENTATION ID:  0*$
0*$.FI L
0*$.SP 5
0*$THIS PLI PREPROCESSOR PROCEDURE CAN BE INVOKED TO GENERATE THE
0*$NECESSARY PLI STATEMENTS TO DYNAMICALLY ALLOCATE A DATA SET.
0*$CALL FORMAT IS AS FOLLOWS -
0*$.SP 1
0*$.IN 5
0*$@ALLOC(KEYWORD-PARAMETER-LIST);
0*$.IN 0
0*$.SP 1
0*$KEYWORD-PARAMETER-LIST MAY BE A MIXTURE OF THE FOLLOWING
0*$PARAMETERS.  NOTE THAT THE PARAMETERS MAY BE SPECIFIED IN ANY
0*$ORDER IN THE LIST, AND THAT KEYWORDS MAY BE ABBREVIATED TO ANY
0*$DEPTH THAT STILL PROVIDES UNIQUENESS.
0*$.SP 1
0*$DATASET(DSNAME)
0*$.IN 5
0*$SPECIFIES THE NAME OF THE DATA SET THAT IS TO BE ALLOCATED.
0*$STANDARD TSO CONVENTIONS ARE OBSERVED.
0*$NOTE THAT IF THIS PARAMETER IS NOT SPECIFIED, IT IS ASSUMED
0*$THAT @SETDSN WAS PREVIOUSLY INVOKED TO SET THE APPROPRIATE
0*$CONTROL BLOCKS (SEE DOCUMENTATION ON @SETDSN).
0*$TO ALLOCATE A UTILITY DATA SET, USE A DSNAME OF THE FORM &NAME.
0*$.SP 1
0*$EXAMPLE 1:  DA('SYS1.PROCLIB')
0*$.IN 10
0*$REFERENCES DATA SET SYS1.PROCLIB
0*$.IN 5
0*$EXAMPLE2:  DA(JCL.CNTL)
0*$.IN 10
0*$REFERENCES DATA SET USERID.JCL.CNTL.
0*$.IN 0
0*$FILE(NAME)
0*$.IN 5
0*$SPECIFIES THE DDNAME TO BE ASSOCIATED WITH THE DATA SET.  IF
0*$YOU OMIT THIS PARAMETER, THE SYSTEM WILL ASSIGN AN
0*$AVAILABLE FILE NAME AND WILL RETURN IT IN FIELD DA08DDN.
0*$.SP 1
0*$EXAMPLE:  FILE(SYSPRINT)
0*$.IN 0
0*$UNIT(NAME)
0*$.IN 5
0*$UNIT NAME DESIRED.  IF OMITTED, STANDARD SYSTEM DEFAULT.
0*$.SP 1
0*$EXAMPLE:  UNIT(SYSDA)
0*$.IN 0
0*$VOLUME(<SERIAL>)
0*$.IN 5
0*$SPECIFIES THE SERIAL NUMBER OF THE DIRECT ACCESS VOLUME ON
0*$WHICH A NEW DATA SET IS TO RESIDE OR ON WHICH AN OLD DATA SET
0*$IS LOCATED.  OPTIONAL.  NOTE THAT THIS PARAMETER IS HANDLE
0*$EXCEPTIONALLY. <SERIAL> MAY BE EITHER A QUOTED STRING OR A
0*$VARIABLE NAME.  IF I HAD IT TO DO OVER AGAIN, MOST PARAMETERS
0*$WOULD BE HANDLED IN THIS FASHION TO PROVIDE MORE FLEXIBILITY.
0*$.SP 1
0*$EXAMPLE:  VOL('OSD400')
0*$.IN 0
0*$SPACE(P,S)
0*$.IN 5
0*$SPECIFIES THE AMOUNT OF SPACE TO BE RESERVED FOR THE NEW DATA
0*$SET.  P IS THE PRIMARY QUANTITY, AND S IS THE SECONDARY.
0*$.SP 1
0*$EXAMPLE:  SP(1,1)
0*$.IN 0
0*$DIR(INTEGER)
0*$.IN 5
0*$SPECIFIES THE NUMBER OF 256 BYTE RECORDS THAT ARE TO BE
0*$ALLOCATED TO THE DIRECTORY OF A NEW PARTITIONED DATA SET.
0*$.SP 1
0*$EXAMPLE:  DIR(5)
0*$.IN 0
0*$SHR
0*$.IN 5
0*$ALLOCATE DISP=SHR.
0*$.IN 0
0*$NEW
0*$.IN 5
0*$ALLOCATE DISP=NEW.
0*$.IN 0
0*$MOD
0*$.IN 5
0*$ALLOCATE DISP=MOD.
0*$.IN 0
0*$OLD
0*$.IN 5
0*$ALLOCATE DISP=OLD - THIS IS THE DEFAULT
0*$.IN 0
0*$WORK
0*$.IN 5
0*$FIRST TRY DISP=NEW.  IF ERROR, TRY DISP=OLD.
0*$.IN 0
0*$KEEP
0*$.IN 5
0*$ALLOCATE DISP=KEEP - THIS IS THE DEFAULT
0*$.IN 0
0*$DELETE
0*$.IN 5
0*$ALLOCATE DISP=DELETE
0*$.IN 0
0*$CATLG
0*$.IN 5
0*$ALLOCATE DISP=CATLG
0*$.IN 0
0*$UNCATLG
0*$.IN 5
0*$ALLOCATE DISP=UNCATLG
0*$.IN 0
0*$ABDISP()
0*$.IN 5
0*$SPECIFIES THE DISPOSITION OF THE DATA SET IN THE EVENT OF
0*$ABNORMAL TERMINATION.  MAY BE SET TO KEEP, DELETE, CATLG, OR
0*$UNCATLG.  IF NOT SPECIFIED, DEFAULTS TO SAME DISPOSITION AS
0*$FOR NORMAL TERMINATION.
0*$.IN 0
0*$BLOCK(BLOCK-LENGTH)
0*$.IN 5
0*$SPECIFIES THE AVERAGE BLOCK LENGTH FOR ALLOCATION.
0*$.IN 0
0*$TRKS
0*$.IN 5
0*$SPACE IS TO BE ALLOCATED IN TRACKS.
0*$.IN 0
0*$CYLS
0*$.IN 5
0*$SPACE IS TO BE ALLOCATED IN CYLS.
0*$.IN 0
0*$RLSE
0*$.IN 5
0*$UNUSED SPACE AT THE END OF THE DATA SET IS TO BE FREED.
0*$.IN 0
0*$PERMANENT
0*$.IN 5
0*$THE DATA SET IS TO BE PERMANENTLY ALLOCATED; IT IS NOT TO BE
0*$FREED UNTIL SPECIFICALLY REQUESTED.
0*$.IN 0
0*$TEMPORARY
0*$.IN 5
0*$NOT PERMANENT.
0*$.IN 0
0*$DUMMY
0*$.IN 5
0*$A DUMMY DATA SET IS DESIRED.
0*$.IN 0
0*$USING(ATTR-LIST-NAME)
0*$.IN 5
0*$SPECIFIES THE NAME OF AN ATTRIBUTE LIST TO BE USED FOR THIS
0*$ALLOCATION.
0*$.IN 0
0*$EXAMPLES:
0*$.SP 1
0*$THE FOLLOWING SEQUENCE ALLOCATES DATA SET SYS1.MACLIB UNDER
0*$THE DDNAME SYSLIB, DISP=SHR -
0*$.IN 5
0*$@ALLOC(FI(SYSLIB),DA('SYS1.MACLIB'),SHR);
0*$.IN 0
0*$THE FOLLOWING SEQUENCE ALLOCATED A NEW DATA SET CALLED
0*$USERID.MYPGM.OBJ UNDER ANY AVAILABLE DDNAME, AND THEN OPENS THE
0*$FILENAME OUTOBJ TO THE NEW DATA SET -
0*$.IN 5
0*$.NF
0*$@ALLOC(DATASET(MYPGM.OBJ),NEW,BL(400),SP(5,1));
0*$OPEN FILE(OUTOBJ) TITLE(DA08DDN);
0*$.FI L
0*$.IN 0
 */
   DCL (P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11,P12,P13,P14,P15) CHAR;
   DCL KEYTAB CHAR;
   KEYTAB = 'DATASET,FILE,UNIT,VOLUME,SPACE,DIR,SHR,NEW,MOD,'××
     'OLD,KEEP,DELETE,CATLG,UNCATLG,BLOCK,TRKS,CYLS,RLSE,'××
     'PERMANENT,TEMPORARY,DUMMY,USING,ABDISP,WORK';
   DCL INDX FIXED;
   DCL (TEXT,PARM,RETSTR,DSNLAB,PMASK,WORKSW) CHAR;
   DCL (I,J,K,L,M) FIXED;
   WORKSW = '0';
   PMASK='00000'××'00000'××'00000'××'00000'××'00000'××'00000';
   RETSTR='DO; DA08FLG=''0''B; DA08DARC=0; DA08CTRC=0; '××
     'DA08PSWD=''''; DA08DSO=0; SUBSTR(DA08CTL,8,1)=''0''B; ';
   DO I = 1 TO 15;
     IF I = 1 THEN PARM = P1; ELSE
     IF I = 2 THEN PARM = P2; ELSE
     IF I = 3 THEN PARM = P3; ELSE
     IF I = 4 THEN PARM = P4; ELSE
     IF I = 5 THEN PARM = P5; ELSE
     IF I = 6 THEN PARM = P6; ELSE
     IF I = 7 THEN PARM = P7; ELSE
     IF I = 8 THEN PARM = P8; ELSE
     IF I = 9 THEN PARM = P9; ELSE
     IF I = 10 THEN PARM = P10; ELSE
     IF I = 11 THEN PARM = P11; ELSE
     IF I = 12 THEN PARM = P12; ELSE
     IF I = 13 THEN PARM = P13; ELSE
     IF I = 14 THEN PARM = P14; ELSE
     IF I = 15 THEN PARM = P15;
     IF PARM = ''
       THEN GO TO ENDLP;
     PARM=@STRIP(PARM);
     TEXT = @SPARS(PARM,KEYTAB,INDX);
 INDLUP:
     IF INDX ^= 0
       THEN PMASK=SUBSTR(PMASK,1,INDX-1)××'1'××
         SUBSTR(PMASK,INDX+1,25-INDX);
     L = LENGTH(TEXT);
     IF INDX = 0
       THEN DO;
         RETSTR=' PARAMETER #'××I××' IS IN ERROR';
         RETURN(RETSTR);
         END;
     IF INDX = 1 /* TEST FOR DATASET KEYWORD */
       THEN DO;
         IF TEXT ^= ''
           THEN DO;
             IF SUBSTR(TEXT,1,1) = ''''
               THEN DO;
                 TEXT = SUBSTR(TEXT,2,L-2);
                 L = L - 2;
                 RETSTR = RETSTR ×× ' SUBSTR(DA08CTL,3,1)=''0''B;';
                 END;
               ELSE RETSTR=RETSTR ×× ' SUBSTR(DA08CTL,3,1)=''1''B;';
             J = INDEX(TEXT,'(');
             IF J = 0
               THEN RETSTR=RETSTR××' DA08MNM='''';';
               ELSE DO;
                 RETSTR=RETSTR××' DA08MNM=''' ××
                   SUBSTR(TEXT,J+1,L-J-1)××''';';
                 L = J - 1;
                 END;
             DSNLAB = @NULL;
             RETSTR=RETSTR××' DCL 1 '××DSNLAB××' STATIC, 2 '××@NULL××
               ' FIXED BIN(15,0) INIT('××L××'), 2 '××
               @NULL××' CHAR(44) INIT(''' ××
               SUBSTR(TEXT,1,L)××'''); DA08PDSN=ADDR('××DSNLAB××');';
             END;
         END;
     ELSE IF INDX = 2 /* TEST FOR FILE KEYWORD */
       THEN RETSTR=RETSTR××' DA08DDN='''××TEXT××''';';
     ELSE IF INDX = 3 /* TEST FOR UNIT KEYWORD */
       THEN RETSTR=RETSTR××' DA08UNIT='''××TEXT××''';';
     ELSE IF INDX = 4 /* TEST FOR VOLUME KEYWORD */
       THEN RETSTR=RETSTR××' DA08SER='××TEXT××';';
     ELSE IF INDX = 5 /* TEST FOR SPACE KEYWORD */
       THEN DO;
         J = INDEX(TEXT,',');
         IF J = 0
           THEN J = INDEX(TEXT,' ');
         IF J = 0
           THEN DO;
             RETSTR=RETSTR××' DA08SQTY=0;';
             J = L+1;
             END;
           ELSE DO;
             DO K = J+1 TO L;
               IF SUBSTR(TEXT,K,1) ^= ' '
                    THEN GO TO GOTD;
               END;
 GOTD:
             RETSTR=RETSTR××' DA08SQTY='××SUBSTR(TEXT,K,L-K+1)××';';
             END;
         RETSTR=RETSTR××' DA08PQTY='××
           SUBSTR(TEXT,1,J-1)××';';
         END;
     ELSE IF INDX = 6 /* TEST FOR DIR KEYWORD */
       THEN RETSTR=RETSTR××' DA08DQTY='××TEXT××';';
     ELSE IF INDX = 7 /* TEST FOR SHR KEYWORD */
       THEN RETSTR=RETSTR××' DA08DSP1=''00001000''B;';
     ELSE IF INDX = 8 /* TEST FOR NEW KEYWORD */
       THEN DO;
         RETSTR=RETSTR××' DA08DSP1=''00000100''B;';
         INDX=13; /* SET DISP=CATLG */
         GO TO INDLUP;
         END;
     ELSE IF INDX = 9 /* TEST FOR MOD KEYWORD */
       THEN RETSTR=RETSTR××' DA08DSP1=''00000010''B;';
     ELSE IF INDX = 10 /* TEST FOR OLD KEYWORD */
       THEN RETSTR=RETSTR××' DA08DSP1=''00000001''B;';
     ELSE IF INDX = 11 /* TEST FOR KEEP KEYWORD */
       THEN RETSTR=RETSTR××' DA08DPS2=''00001000''B;';
     ELSE IF INDX = 12 /* TEST FOR DELETE KEYWORD */
       THEN RETSTR=RETSTR××' DA08DPS2=''00000100''B;';
     ELSE IF INDX = 13 /* TEST FOR CATLG KEYWORD */
       THEN RETSTR=RETSTR××' DA08DPS2=''00000010''B;';
     ELSE IF INDX = 14 /* TEST FOR UNCATLG KEYWORD */
       THEN RETSTR=RETSTR××' DA08DPS2=''00000001''B;';
     ELSE IF INDX = 15 /* TEST FOR BLOCK KEYWORD */
       THEN RETSTR=RETSTR××' DA08BLK='××TEXT××
         '; SUBSTR(DA08CTL,1,2)=''01''B;';
     ELSE IF INDX = 16 /* TEST FOR TRKS KEYWORD */
       THEN RETSTR=RETSTR××'DA08BLK=0; SUBSTR(DA08CTL,1,2)=''10''B;';
     ELSE IF INDX = 17 /* TEST FOR CYLS KEYWORD */
       THEN RETSTR=RETSTR××' DA08BLK=0; SUBSTR(DA08CTL,1,2)=''11''B;';
     ELSE IF INDX = 18 /* TEST FOR RLSE KEYWORD */
       THEN RETSTR=RETSTR××' SUBSTR(DA08CTL,4,1)=''1''B;';
     ELSE IF INDX = 19 /* TEST FOR PERMANENT KEYWORD */
       THEN RETSTR=RETSTR××' SUBSTR(DA08CTL,5,1)=''1''B;';
     ELSE IF INDX = 20 /*TEST FOR TEMPORARY KEYWORD */
       THEN RETSTR=RETSTR××' SUBSTR(DA08CTL,5,1)=''0''B;';
     ELSE IF INDX = 21 /* TEST FOR DUMMY KEYWORD */
       THEN RETSTR=RETSTR××' SUBSTR(DA08CTL,6,1)=''1''B;';
     ELSE IF INDX = 22 /* TEST FOR ATTRIB KEYWORD */
       THEN RETSTR=RETSTR×× ' SUBSTR(DA08CTL,7,1)=''1''B; DA08ALN='''××
         TEXT ×× ''';';
     ELSE IF INDX = 23 /* TEST FOR ABDISP KEYWORD */
       THEN IF TEXT='KEEP'
         THEN RETSTR=RETSTR××' DA08DPS3=''00001000''B;';
         ELSE IF TEXT='DELETE'
           THEN RETSTR=RETSTR××' DA08DPS3=''00000100''B;';
           ELSE IF TEXT='CATLG'
             THEN RETSTR=RETSTR××' DA08DPS3=''00000010''B;';
             ELSE RETSTR=RETSTR××' DA08DPS3=''00000001''B;';
     ELSE IF INDX=24
       THEN DO;
         WORKSW='1';
         INDX=8;
         GO TO INDLUP;
         END;
     END;
 ENDLP:
   IF SUBSTR(PMASK,2,1) = '0' /* FILE KEYWORD */
     THEN RETSTR=RETSTR××' DA08DDN='''';';
   IF SUBSTR(PMASK,3,1) = '0' /* UNIT KEYWORD */
     THEN RETSTR=RETSTR××' DA08UNIT='''';';
   IF SUBSTR(PMASK,4,1) = '0' /* VOLUME KEYWORD */
     THEN RETSTR=RETSTR××' DA08SER='''';';
   IF SUBSTR(PMASK,5,1) = '0' /* SPACE KEYWORD */
     THEN RETSTR=RETSTR××' DA08PQTY,DA08SQTY=0;';
   IF SUBSTR(PMASK,6,1) = '0' /* DIR KEYWORD */
     THEN RETSTR=RETSTR××' DA08DQTY=0;';
   IF SUBSTR(PMASK,7,4) = '0000' /* SHR,NEW,MOD,OLD KEYWORDS */
     THEN RETSTR=RETSTR××' DA08DSP1=''00000001''B;';
   IF SUBSTR(PMASK,11,4) = '0000' /* KEEP,DELETE,CATLG,UNCATLG */
     THEN RETSTR=RETSTR××' DA08DPS2=''00001000''B;';
   IF SUBSTR(PMASK,15,3) = '000' /* BLOCK,TRKS,CYLS KEYWORDS */
     THEN RETSTR=RETSTR×× ' DA08BLK=0; SUBSTR(DA08CTL,1,2)=''00''B;';
   IF SUBSTR(PMASK,18,1) = '0' /* RLSE KEYWORD */
     THEN RETSTR=RETSTR××' SUBSTR(DA08CTL,4,1)=''0''B;';
   IF SUBSTR(PMASK,19,2) = '00' /* PERMANENT,TEMPORARY KEYWORDS */
     THEN RETSTR=RETSTR××' SUBSTR(DA08CTL,5,1)=''1''B;';
   IF SUBSTR(PMASK,21,1) = '0' /* DUMMY KEYWORD */
     THEN RETSTR=RETSTR××' SUBSTR(DA08CTL,6,1)=''0''B;';
   IF SUBSTR(PMASK,22,1) = '0' /* ATTRIB KEYWORD */
     THEN RETSTR=RETSTR××' SUBSTR(DA08CTL,7,1)=''0''B; DA08ALN='''';';
   IF SUBSTR(PMASK,23,1) = '0' /* ABDISP KEYWORD */
     THEN RETSTR=RETSTR××' DA08DPS3=DA08DPS2;';
   RETSTR=RETSTR××
     ' CALL SYSDAIR(CPPLUPT,CPPLECT,CPECB,CPPLPSCB,DAIR08,IKJRET);';
   IF WORKSW='1'
     THEN RETSTR=RETSTR××' IF IKJRET^=0 THEN @ALLOC(OLD);';
   RETSTR=RETSTR××' IF IKJRET^=0 THEN CALL DAIRERR(D08PTR);';
   RETSTR=RETSTR××' END;';
   RETURN(RETSTR);
   % END @ALLOC;
 % PRINT;
