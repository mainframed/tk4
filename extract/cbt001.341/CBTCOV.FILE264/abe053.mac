 /* COPYRIGHT 1983 BY THOMAS GLEN SMITH */
 /* ABE053 - USE */
   %INCLUDE ABESUB;
 ABESUB(ABE053)  CHECK(YES);
   %INCLUDE ABESUBA;

   % DCL SCAN CHAR;
   % SCAN = 'CALL SCANNER(USEBUF,SCANPARM,OPERATORS,KEYWORDS,SPCHARS)';
 /* DCL HEX ENTRY(CHAR(*)) RETURNS(CHAR(32767) VAR); /* TESTING ONLY */
   DCL SCANNER ENTRY;
   DCL SETCAPS ENTRY;
   DCL (PREFIX,SUFFIX) ENTRY(CHAR(*),CHAR(*))
     RETURNS(FIXED BIN(15,0));
   DCL PTRIN ENTRY(PTR)
     RETURNS(FIXED BIN(31,0));
   DCL PTROUT ENTRY(FIXED BIN(31,0))
     RETURNS(PTR);
   DCL CONVERT ENTRY(PTR,
     CHAR(*),FIXED BIN(15,0),FIXED BIN(15,0),
     CHAR(*),FIXED BIN(15,0),FIXED BIN(15,0))
     RETURNS(CHAR(256) VAR);

   DCL USEBUF CHAR(1024) VAR;
   DCL TYPETAB(8) CHAR(8) VAR STATIC INIT(
     'RB','$CHAR','ZD','PD','HEX','PIB','IB','BEST');
   DCL KEYWORDS(12)  CHAR(12) VAR STATIC
     INIT('*','INPUT','LIST','NAME','SET','FIXED','NOSYM','IN','OUT',
      'LISTAVL','DISPLAY','NODISPLAY');
   DCL OPERATORS(1) CHAR(2) VAR STATIC INIT('');
   DCL PRECEDENCE(2,1) FIXED BIN(15,0) STATIC INIT(0,0);
   DCL SPCHARS CHAR(1) VAR STATIC INIT('');
   DCL 1 SCANPARM,
     2 TOKHDR PTR,
     2 CURTOK PTR,
     2 SCANIX FIXED BIN(15,0) INIT(1);
   DCL 1 TOKEN BASED(CURTOK),
     2 PRIOR_TOKEN PTR,
     2 NEXT_TOKEN PTR,
     2 ELIX FIXED BIN(15,0),
     2 TYPE FIXED BIN(15,0),
     2 SUBTYPE FIXED BIN(15,0),
     2 TOKSTR CHAR(256) VAR;
   DCL KEYWORD FIXED BIN(15,0) STATIC INIT(2);
   DCL OPERAND FIXED BIN(15,0) STATIC INIT(0);
   DCL NO_MORE_TOKENS FIXED BIN(15,0) STATIC INIT(6);
   DCL NUMBER FIXED BIN(15,0) STATIC INIT(5);
   DCL ZD FIXED BIN(15,0) STATIC INIT(3); /* ZONED DECIMAL TYPE */
   DCL BEST FIXED BIN(15,0) STATIC INIT(8); /* BEST TYPE */
   DCL CHR FIXED BIN(15,0) STATIC INIT(2); /* CHAR TYPE */
   DCL BITTYPE FIXED BIN(15,0) STATIC INIT(6); /* CHAR TYPE */
   DCL (NEWHDR,LAST) PTR;

   USEBUF=CMDBUF;
   CALL SETCAPS(USEBUF);
   TOKHDR,NEWHDR,CURTOK=NULL;
   RHRC=0;
   ON CONDITION(BADUSE) BEGIN;
     IF MSGDATA=''
       THEN MSGDATA='INVALID SYNTAX';
     RHRC=8;
     GO TO EOJ;
     END; /* BEGIN */
   SCAN; /* GO GET KEYWORD, E.G.  *, INPUT, LIST, NAME. ETC. */
   IF TOKSTR='×'
     THEN CALL USEFORM('INPUT');
       /* IT IS 'USE × NAME1 ×   × NAME2 × ... ' */
   IF TYPE^=KEYWORD
     THEN CALL USECOPY;
     ELSE SELECT(TOKSTR);
       WHEN('DISPLAY')
         IF RHUSEHD=NULL & RH_APL^=NULL
           THEN CALL DISPLAY_APL;
           ELSE CALL DISPLAY;
       WHEN('FIXED')     CALL INPUT('1'B);
       WHEN('IN')        CALL IN;
       WHEN('INPUT')     CALL INPUT('0'B);
       WHEN('LIST')      CALL LIST;
       WHEN('LISTAVL')   CALL LISTAVL(RHUSETR);
       WHEN('NODISPLAY') CALL DELDBD(ADDR(RH_DISPLAY_HDR));
       WHEN('NOSYM')     CALL SET('0'B);
       WHEN('OUT')       CALL OUT;
       WHEN('SET')       CALL SET('1'B);
       OTHERWISE DO;
         MSGDATA=
           'ONLY INPUT, LIST, AND SET  ARE CURRENTLY IMPLEMENTED';
         SIGNAL CONDITION(BADUSE);
         END;
       END; /* SELECT */
 EOJ:;
   CALL CLEANUP;

 BLDAVL: PROC(USEHD) RETURNS(PTR);
 /**********************************************************************
 *                                                                     *
 * CALLED TO BUILD THE AVL SEARCH TREE.                                *
 *                                                                     *
 **********************************************************************/
   DCL (NODEPTR,USEHD,USETR) PTR;

   ON ERROR BEGIN;
     USETR=NULL;
     GOTO END_BLDAVL;
     END;
   USETR=NULL; /* INITIALIZE ROOT TO NULL */
   DO NODEPTR=USEHD REPEAT NODEPTR->RHNLINK WHILE(NODEPTR^=NULL);
     CALL #ABE053A(USETR,NODEPTR);
     END;
 END_BLDAVL:
   RETURN(USETR);
   END BLDAVL;

 BUFCK: PROC(NEWLNG,DISPLAY);
 /**********************************************************************
 *                                                                     *
 * CALLED TO ALLOCATE A LARGER BUF.                                    *
 *                                                                     *
 **********************************************************************/
   DCL NEWLNG FIXED BIN(15,0);
   DCL DISPLAY BIT(1);
   DCL I FIXED BIN;
   DCL (ORGPTR,SAVPTR) PTR;


   IF NEWLNG<=BUFLN
     THEN RETURN; /* REALLOCATION NOT NECESSARY */
   IF OUTDDN^=NULL
     THEN IF BUFPTR=ADDR(OUTDDN->ALCRECL)
       THEN BUFPTR=NULL;
   IF INDDN^=NULL
     THEN IF BUFPTR=ADDR(INDDN->ALCRECL)
       THEN BUFPTR=NULL;
   IF BUFPTR^=NULL
     THEN DO;
       FREE BUFSTR;
       BUFPTR = NULL;
       END;
   L=NEWLNG;
   ALLOCATE BUFSTR SET(BUFPTR);
   IF ^DISPLAY
     THEN DO;
       ORGPTR,SAVPTR=RHPTR;
       I=#CMD('ABE '''' RECSIZE('××NEWLNG××')',SAVPTR,RHHDRPT);
       I=#CMD('COPY '××SAVPTR->RHNAME,RHPTR,RHHDRPT);
       I=#CMD('DEL',RHPTR,RHHDRPT);
       I=#CMD('MB '××SAVPTR->RHNAME,RHPTR,RHHDRPT);
       RHPTR=ORGPTR;
       END;
   END BUFCK;

 CLEANUP: PROC;
 /**********************************************************************
 * CLEANUP IS CALLED TO CLEAN UP MEMORY AT END OF PROCESSING IN THIS   *
 * SUBCOMMAND.  ALSO CALLED BY USEFORM.                                *
 **********************************************************************/
   DCL DELPTR PTR;
   DO DELPTR=TOKHDR REPEAT TOKHDR WHILE(DELPTR^=NULL);
     TOKHDR=DELPTR->NEXT_TOKEN;
     FREE DELPTR->TOKEN;
     END;
   DO DELPTR=NEWHDR REPEAT NEWHDR WHILE(DELPTR^=NULL);
     NEWHDR=DELPTR->RHNLINK;
     FREE DELPTR->RHNAMESTR;
     END;
   TOKHDR,NEWHDR,CURTOK=NULL;
   SCANIX=1;
   END CLEANUP;

 DELDBD: PROC(DBDHDRPTR);
 /**********************************************************************
 *                                                                     *
 * CALLED TO DELETE AN EXISTENT DBD LIST.                              *
 *                                                                     *
 **********************************************************************/
   DCL (DBDHDRPTR,DELPTR) PTR;
   DCL HDR PTR BASED(DBDHDRPTR);

   DO DELPTR=HDR REPEAT HDR WHILE(DELPTR^=NULL);
     HDR=DELPTR->RHNLINK;
     FREE DELPTR->RHNAMESTR;
     END;
   END DELDBD;

 DISPLAY: PROC RECURSIVE;
 /**********************************************************************
 *                                                                     *
 * DISPLAY IS CALLED FOR OTHER THAN THE DISPLAY OF AN APL VARIABLE,    *
 * WHEN THE FORMAT OF THE CURRENT COMMAND IS -                         *
 * 'USE DISPLAY ....'.  IT WILL SET UP THE DISPLAY DBD LIST HEADED     *
 * BY RH_DISPLAY_HDR.  THE FOLLOWING FORMATS ARE ACCEPTABLE:           *
 *                                                                     *
 * FORMAT 1:  USE DISPLAY                                              *
 *   USE DISPLAY WITH NO OPERANDS INDICATES THIS SUBCOMMAND IS TO      *
 *   DERIVE THE DISPLAY FROM THE USAGE DBD DETERMINING THE LENGTHS     *
 *   TO BE DISPLAYED ON ITS OWN.                                       *
 *                                                                     *
 * FORMAT 2:  USE DISPLAY × NAME1 ×  × NAME2 × ...                     *
 *   THIS FORMAT WILL BE TRANSFORMED INTO FORMAT 1 IF "USE DISPLAY ×"  *
 *   IS SPECIFIED, AND OTHERWISE WILL BE TRANSFORMED TO FORMAT 3.      *
 *                                                                     *
 * FORMAT 3:  EXAMPLE FOLLOWS:                                         *
 *   USE DISPLAY A 1-1 B 5-10                                          *
 *     FIELD A WILL BEGIN IN COLUMN 1, AND WILL BE 1 COLUMN LONG.      *
 *     FIELD B WILL BEGIN IN COLUMN 5, AND WILL BE 6 COLUMNS LONG.     *
 *                                                                     *
 * FORMAT 4:  USE DISPLAY NAME1 NAME2 ...                              *
 *   THE LIST POINTED TO BY RHUSEHD WILL BE SCANNED, AND FOR EACH      *
 *   NAME SPECIFIED ON THE FORMAT 2 USE DISPLAY SUBCOMMAND THE         *
 *   APPROPRIATE RHNAMESTR ELEMENT WILL BE ADDED TO THE RH_DISPLAY_HDR *
 *   LIST.                                                             *
 *                                                                     *
 **********************************************************************/

   SCAN; /* GET NEXT TOKEN */
   IF TOKSTR='×'
     THEN CALL USEFORM(''); /* IT IS FORMAT 1 */
   IF TYPE=NO_MORE_TOKENS
     THEN CALL DISPLAY_DEFAULT; /* SET UP DEFAULT DISPLAY */
     ELSE CALL DISPLAY_DEFINE;  /* SET UP USER-SPECIFIED DISPLAY */
   CALL DELDBD(ADDR(RH_DISPLAY_HDR)); /* GO DELETE DISPLAY DBD */
   RH_DISPLAY_HDR=NEWHDR;
   NEWHDR=NULL;

   /* NOW DETERMINE IF BUFFER NEEDS TO BE REALLOCATED */
   DO RHNAMPTR=RH_DISPLAY_HDR REPEAT RHNLINK WHILE(RHNAMPTR^=NULL)
     UNTIL(RHNLINK=NULL);
     END;
   IF RHNAMPTR^=NULL
     THEN CALL BUFCK(RHNPOS+RHNLNG,'1'B); /* GO REALLOCATE BUFFER */
   END DISPLAY;

 DISPLAY_APL: PROC;
 /**********************************************************************
 *                                                                     *
 * DISPLAY IS CALLED TO PREPARE FOR THE DISPLAY ON AN APL VARIABLE.    *
 * FORMAT OF THE CURRENT COMMAND MUST BE 'USE DISPLAY'.                *
 *                                                                     *
 **********************************************************************/
   %INCLUDE APLCB;
   DCL 1 LRN_STRUCTURE BASED(LRNPTR),
   %INCLUDE ABELRN;
   %INCLUDE ABELRNA;
   DCL 1 MY_STRUCTURE,
   %INCLUDE ABELRN;
   DCL (I,J,K) FIXED BIN;
   DCL STR CHAR(256) VAR;

   DCL TYPETAB(8) CHAR(8) VAR STATIC INIT(
     'FLOAT','CHAR','CHAR','PACKED','HEX','BIT','FIXED','BEST');

   SCAN; /* GET NEXT TOKEN */
   IF TYPE^=NO_MORE_TOKENS
     THEN DO;
       MSGDATA='ONLY "USE DISPLAY" IS ACCEPTABLE FOR APL VARIABLES.';
       SIGNAL CONDITION(BADUSE);
       END;
   IF RH_APL_TYPE=2 /* CHAR? */
     THEN DO;
       MSGDATA='CHARACTER VARIABLES DON''T NEED DISPLAY PROCESSING.';
       RETURN;
       END;
   CALL DELDBD(ADDR(RH_DISPLAY_HDR)); /* GO DELETE DISPLAY DBD */

   /* NOW PROCESS THE ENTIRE DATASET TO FIND LENGTH TO DISPLAY */
   LRNPTR=ADDR(MY_STRUCTURE);
   CALL #ABELSPP(RHHDRPT,RHPTR,LRNPTR,'',I);
   RH_LEN=RH_APL_ELEN;
   RH_NCOLS=RH_APL_ELCOUNT;
   I=0;
   DO FOREVER=1 REPEAT FOREVER;
     CALL #ABELSP(RHHDRPT,LRNPTR); /* GET NEXT FROM-SEGMENT */
     IF LRN_STRUCTURE.LRN_BUFP=NULL
       THEN LEAVE;
     STR=CONVERT(PTROUT(PTRIN(ADDR(LSPBUF))+2),
       TYPETAB(RH_APL_TYPE),LENGTH(LSPBUF),0,
       'BEST',256,0);
     I=MAX(I,SUFFIX(STR,' ')+1);
     END;
   /* I NOW CONTAINS MAX LENGTH NEEDED TO DISPLAY ALL ELEMENTS */

   /* NOW DETERMINE MAXIMUM FIELD NAME LENGTH */
   J=1; /* ONE FOR VERTICAL BAR */
   DO K=1 TO RH_APL_RANK;
     J=J+1+MAX(CEIL(LOG10(RH_APL_DIM(K)+1)),1);
     END;
   J=J-1; /* LESS 1 FOR TRAILING SEMICOLON */

   CALL INPSUB3; /* ALLOC RHNAMESTR AND QUEUE OFF NEWHDR */
   RHNNAME='E';
   RHNTYPE=BEST; /* BEST */
   RHNPOS=1;
   RHNLNG=MAX(I,J,1);
   RH_DISPLAY_HDR=NEWHDR;
   NEWHDR=NULL;
   END DISPLAY_APL;

 DISPLAY_DEFAULT: PROC;
 /**********************************************************************
 *                                                                     *
 * DISPLAY IS CALLED WHEN THE FORMAT OF THE CURRENT COMMAND IS         *
 * 'USE DISPLAY' WITH NO OPERANDS.  IT WILL SET UP THE DISPLAY DBD     *
 * LIST HEADED BY RH_DISPLAY_HDR, ACCORDING TO THE CURRENT CONTENTS    *
 * OF THE USAGE DBD.                                                   *
 *                                                                     *
 **********************************************************************/
   DCL WPT PTR;
   DCL (LNG,POS) FIXED BIN;

   POS=1;
   DO WPT=RHUSEHD REPEAT WPT->RHNLINK WHILE(WPT^=NULL);
     CALL INPSUB4(WPT,POS); /* SETUP DISPLAY RHNAMESTR */
     POS=POS+1;
     END;
   END DISPLAY_DEFAULT;

 DISPLAY_DEFINE: PROC;
 /**********************************************************************
 *                                                                     *
 * DISPLAY IS CALLED WHEN THE FORMAT OF THE CURRENT COMMAND IS -       *
 *                                                                     *
 *   USE DISPLAY A 1-1 B 5-10                                          *
 *                                                                     *
 * OR                                                                  *
 *                                                                     *
 *   USE DISPLAY A  B                                                  *
 *                                                                     *
 * THIS SUBROUTINE WILL SET UP THE DISPLAY DBD LIST HEADED BY          *
 * RH_DISPLAY_HDR ACCORDING TO THIS LIST.                              *
 *                                                                     *
 **********************************************************************/
   DCL J FIXED BIN;
   DCL WPT PTR;

   J=1; /* NEXT AVAILABLE BYTE ON DISPLAY LINE */
   DO UNTIL(TYPE=NO_MORE_TOKENS);
     SELECT;
       WHEN(TYPE=OPERAND × TYPE=KEYWORD) DO;
         SCAN;
         IF (TYPE=OPERAND × TYPE=KEYWORD × TYPE=NO_MORE_TOKENS)
           THEN DO; /* IT IS USE DISPLAY A B */
             CURTOK=PRIOR_TOKEN;
             DO WPT=RHUSEHD REPEAT WPT->RHNLINK WHILE(WPT^=NULL)
               UNTIL(WPT->RHNNAME=TOKSTR);
               END;
             IF WPT=NULL
               THEN DO; /* FIELD NOT FOUND */
                 MSGDATA='DISPLAY FIELD IS NOT DEFINED IN DBD';
                 SIGNAL CONDITION(BADUSE);
                 END;
               ELSE DO;
                 CALL INPSUB4(WPT,J);
                 /* ALLOC AND FILL RHNAMESTR, Q OFF NEWHDR */
                 J=J+1;
                 END;
             END;
           ELSE DO;
             CURTOK=PRIOR_TOKEN;
             CALL INPSUB1(J,'1'B); /* GO PROCESS COLUMNAR INPUT */
             END;
         SCAN;
         END;
       WHEN(TOKSTR='@') DO; /* IT IS FORMATTED INPUT */
         CALL INPSUB2(J); /* GO PROCESS FORMATTED INPUT */
         END;
       OTHERWISE LEAVE; /* IT MAY BE BAD INPUT */
       END; /* SELECT */
     END;
   IF TYPE^=NO_MORE_TOKENS
     THEN DO;
       MSGDATA='INVALID SYNTAX = '××TOKSTR;
       SIGNAL CONDITION(BADUSE);
       END;
   DO RHNAMPTR=NEWHDR REPEAT RHNLINK WHILE(RHNAMPTR^=NULL)
     UNTIL(RHNLINK=NULL);
     IF RHNTYPE^=ZD
       THEN RHNTYPE=CHR;
     IF RHNPOS=0
       THEN DO;
         MSGDATA='USE DISPLAY MUST EXPLICITLY SPECIFY FIELD BOUNDARIES';
         SIGNAL CONDITION(BADUSE);
         END;
     END;
   END DISPLAY_DEFINE;

 DOCOL: PROC;
 /**********************************************************************
 * DOCOL IS CALLED WHEN THE CURRENT TOKEN IS THE FIRST OR ONLY NUMBER  *
 * OF A COLUMN RANGE SPECIFICATION.  DOCOL WILL SET FIELDS RHNPOS AND  *
 * RHNLNG IN THE STRUCTURE POINTED TO BY GLOBAL RHNAMPTR, AND WILL     *
 * ADVANCE THE CURRENT TOKEN POINTER TO THE NEXT TOKEN BEYOND THE      *
 * CURRENT COLUMN RANGE SPECIFICATION.                                 *
 **********************************************************************/
   DCL I FIXED BIN;
   RHNPOS=TOKSTR; /* GET START OF FIELD */
   SCAN; /* GET NEXT TOKEN */
   IF TOKSTR^='-'
     THEN RHNLNG=1;
     ELSE DO;
       SCAN; /* GET NEXT TOKEN */
       IF TYPE^=NUMBER
         THEN DO;
           MSGDATA='NUMBER EXPECTED THIS FOUND - '××TOKSTR;
           SIGNAL CONDITION(BADUSE);
           END;
       I=TOKSTR;
       RHNLNG=I-RHNPOS+1;
       IF RHNLNG<1
         THEN DO;
           MSGDATA='FIELD LENGTH MUST BE 1 OR MORE';
           SIGNAL CONDITION(BADUSE);
           END;
       IF RHNLNG>256
         THEN DO;
           MSGDATA='FIELD LENGTH MUST BE NO MORE THAN 256';
           SIGNAL CONDITION(BADUSE);
           END;
       SCAN; /* GET NEXT TOKEN */
       END;
   CURSOR=RHNPOS+RHNLNG;
   END DOCOL;

 FINDCOL: PROC(RHNPOS,RHNLNG,TRIM);
 /**********************************************************************
 * FINDCOL IS CALLED WHEN THE POSITION AND LENGTH OF THE CURRENT FIELD *
 * IS TO BE CALCULATED ACCORDING TO THE FORMAT OF THE CURRENT RECORD   *
 * IN THE DATA SET.  FINDCOL WILL SET FIELDS RHNPOS AND RHNLNG.        *
 * GLOBAL VARIABLE CURSOR POINTS AT THE START OF THE CURRENT FIELD IN  *
 * THE CURRENT RECORD, AND GLOBAL VARIABLE L CONTAINS THE LENGTH OF    *
 * THE CURRENT RECORD.                                                 *
 **********************************************************************/
   DCL (RHNPOS,RHNLNG) FIXED BIN(15,0);
   DCL TRIM BIT(1);
   DCL I FIXED BIN;
   IF TRIM & ^(CURSOR=0 × CURSOR>L)
     THEN DO;
       I=PREFIX(SUBSTR(RECSTR,CURSOR),' '); /* FIND NON-BLANK */
       IF I=0
         THEN CURSOR=L+1;
         ELSE CURSOR=CURSOR+I-1;
       END;
   IF CURSOR=0 × CURSOR>L
     THEN DO; /* MISSING FIELD */
       RHNPOS=1;
       RHNLNG=0;
       RETURN;
       END;
   RHNPOS=CURSOR;
   I=INDEX(SUBSTR(RECSTR,CURSOR),' '); /* FIND NEXT BLANK */
   IF I>0
     THEN CURSOR=CURSOR+I-1;
     ELSE CURSOR=L+1;
   IF ^TRIM & CURSOR<=L
     THEN DO;
       I=PREFIX(SUBSTR(RECSTR,CURSOR),' '); /* FIND NEXT NON-BLANK */
       IF I=0
         THEN CURSOR=L+1;
         ELSE CURSOR=CURSOR+I-1;
       END;
   RHNLNG=CURSOR-RHNPOS;
   END FINDCOL;

 FUNCK: PROC(PRM);
 /**********************************************************************
 *                                                                     *
 * CALLED TO DETERMINE IF A NAME IS RESERVED.                          *
 *                                                                     *
 **********************************************************************/
   DCL PRM CHAR(*) VAR;
   DCL RESERVED(33) CHAR(12) VAR STATIC INIT(
   /* NILADIC FUNCTIONS */
   /*  1 */ 'DATE',         /*  2 */ 'ECHO',      /*  3 */ 'LIST',
   /*  4 */ 'TIME',
   /* MONADIC FUNCTIONS */
   /*  5 */ 'ABS',          /*  6 */ 'ACOS',      /*  7 */ 'ASIN',
   /*  8 */ 'ATAN',         /*  9 */ 'ATAND',     /* 10 */ 'ATANH',
   /* 11 */ 'CEIL',         /* 12 */ 'COS',       /* 13 */ 'COSD',
   /* 14 */ 'COSH',         /* 15 */ 'ERF',       /* 16 */ 'ERFC',
   /* 17 */ 'EXP',          /* 18 */ 'FIXED',     /* 19 */ 'FLOOR',
   /* 20 */ 'LOG',          /* 21 */ 'LOG2',      /* 22 */ 'LOG10',
   /* 23 */ 'SIGN',         /* 24 */ 'SIN',       /* 25 */ 'SIND',
   /* 26 */ 'SINH',         /* 27 */ 'SQRT',      /* 28 */ 'TAN',
   /* 29 */ 'TAND',         /* 30 */ 'TANH',      /* 31 */ 'TRUNC',
   /* DYADIC FUNCTIONS */
   /* 32 */ 'MOD',          /* 33 */ 'ROUND');
   DCL I FIXED BIN(15,0);
   DO I=1 TO HBOUND(RESERVED,1) WHILE(RESERVED(I)^=PRM);
     END;
   IF I<=HBOUND(RESERVED,1)
     THEN DO;
       MSGDATA=PRM××' IS A RESERVED WORD';
       SIGNAL CONDITION(BADUSE);
       END;
   END FUNCK;

 IN: PROC;
 /**********************************************************************
 *                                                                     *
 * CALLED TO OBTAIN THE DBD FROM THE FRONT OF THE CURRENTLY EDITED     *
 * DATASET.  AFTER THE DBD HAS BEEN OBTAINED, THE RECORDS DEFINING     *
 * THE DBD WILL BE DELETED FROM THE FRONT OF THE DATA SET.             *
 *                                                                     *
 **********************************************************************/
   DCL CMD CHAR(1024) VAR INIT('USE ');
   DCL (I,SAVSEQ) FIXED BIN(31,0);
   DCL (ORGPTR,SAVPTR,DELPTR) PTR;

   ORGPTR=RECPTR;
   ON CONDITION(BADIN) BEGIN;
     IF ORGPTR=HDPTR
       THEN CALL #NC(RHPTR,NXTHDR); /* CALL NEWCUR */
       ELSE CALL #NC(RHPTR,ORGPTR); /* CALL NEWCUR */
     MSGDATA='THERE IS NO VALID DBD AT THE FRONT OF THIS DATASET';
     SIGNAL CONDITION(BADUSE);
     END;


   /* GET SET TO READ FIRST RECORD IN DATA SET */
   RECPTR=RHPTR;
   CURSEQ=0;
   RECPTR=#SUCC(RHHDRPT,RHPTR,RECPTR); /* GET FIRST RECORD */
   IF RECPTR=RHPTR
     THEN SIGNAL CONDITION(BADIN); /* EMPTY DATA SET */
   IF LENGTH(RECSTR)<5
     THEN SIGNAL CONDITION(BADIN);
   IF SUBSTR(RECSTR,1,5)^='DATA '
     THEN SIGNAL CONDITION(BADIN); /* FIRST RECORD M/B DATA STMT */
   RECPTR=#SUCC(RHHDRPT,RHPTR,RECPTR); /* GET NEXT RECORD */
   IF RECPTR=RHPTR
     THEN SIGNAL CONDITION(BADIN); /* NOT ENOUGH RECORDS */
   IF LENGTH(RECSTR)<5
     THEN SIGNAL CONDITION(BADIN);
   IF SUBSTR(RECSTR,1,5)^='INPUT'
     THEN SIGNAL CONDITION(BADIN); /* SECOND RECORD M/B INPUT STMT */
   DO FOREVER=1 REPEAT FOREVER;
     I=INDEX(RECSTR,';'); /* END OF INPUT STMT? */
     IF I=0
       THEN I=LENGTH(RECSTR)+1;
     IF I>1
       THEN CMD=CMD××' '××SUBSTR(RECSTR,1,I-1);
     IF I<=LENGTH(RECSTR)
       THEN LEAVE; /* WE ARE AT END OF INPUT STMT */
     RECPTR=#SUCC(RHHDRPT,RHPTR,RECPTR); /* GET NEXT RECORD */
     IF RECPTR=RHPTR
       THEN SIGNAL CONDITION(BADIN); /* NOT ENOUGH RECORDS */
     END;
   RECPTR=#SUCC(RHHDRPT,RHPTR,RECPTR); /* GET NEXT RECORD */
   IF ^(RECSTR='CARDS;' × RECSTR='CARDS4;')
     THEN SIGNAL CONDITION(BADIN); /* THIRD STMT M/B CARDS STMT */
   SAVSEQ=RECSEQ+1;
   RECPTR=#SUCC(RHHDRPT,RHPTR,RECPTR); /* GET NEXT RECORD */
   IF RECPTR^=RHPTR
     THEN SAVSEQ=RECSEQ;
   /* NOW DELETE RECORDS TO THIS POINT */
   /* GET SET TO READ FIRST RECORD IN DATA SET */
   RECPTR=RHPTR;
   CURSEQ=0;
   /* NOW DELETE THE DBD FROM THE FRONT OF THE DATA SET */
   DO RECPTR=#SUCC(RHHDRPT,RHPTR,RECPTR) REPEAT NXTPTR
     WHILE(RECPTR^=HDPTR);
     IF RECSEQ>=SAVSEQ
       THEN LEAVE;
     IF RECPTR=ORGPTR
       THEN ORGPTR=RHPTR;
     DELPTR=RECPTR;
     RECPTR=LSTPTR;
     CALL #PUTSLOT(RHPTR,RHHDRPT,DELPTR);
     END;
   IF ORGPTR=HDPTR
     THEN CALL #NC(RHPTR,NXTHDR); /* CALL NEWCUR */
     ELSE CALL #NC(RHPTR,ORGPTR); /* CALL NEWCUR */
   RECHDR.CMDDATA=CMD; /* SCHEDULE USE SUBCOMMAND FOR EXECUTION NEXT */
   END IN;

 INPUT: PROC(FIXED);
 /**********************************************************************
 * INPUT IS CALLED TO PROCESS A USE SUBCOMMAND IN WHICH THE FIRST      *
 * OPERAND IS THE INPUT OR FIXED KEYWORDS.  PARAMETER FIXED WILL BE    *
 * '1'B IF THE KEYWORD IS FIXED.  IF FIXED IS SPECIFIED, IF COLUMN     *
 * SPECIFICATIONS ARE OMITTED FOR A FIELD ON THE SUBCOMMAND (E.G.      *
 * INPUT X Y Z) THE COLUMN SPECIFICATIONS WILL BE DERIVED FROM THE     *
 * DATA IN THE CURRENT RECORD, AND WILL APPLY UNTIL THE NEXT USE       *
 * SUBCOMMAND IS ISSUED TO CHANGE FIELD SPECIFICATIONS.  IF FIXED IS   *
 * NOT SPECIFIED AND COLUMN SPECIFICATIONS ARE OMITTED FOR A FIELD ON  *
 * THE SUBCOMMAND THE COLUMN SPECIFICATIONS WILL BE DERIVED FROM THE   *
 * DATA IN THE CURRENT RECORD WHEN THE 'USE SET' SUBCOMMAND IS ISSUED. *
 *                                                                     *
 * SOME SAMPLE SUBCOMMANDS FOLLOW -                                    *
 *                                                                     *
 *   USE INPUT X Y Z                                                   *
 *     THE ABOVE STATEMENT INDICATES THREE FIELDS ARE TO BE DEFINED    *
 *     AND THE OFFSETS AND LENGTHS ARE TO BE BASED ON THE DATA IN THE  *
 *     FIRST RECORD IN THE DATA SET.  FIELD NAMED X WILL START AT      *
 *     THE POSITION OF THE FIRST NON-BLANK CHARACTER IN THE FIRST      *
 *     RECORD.  ALL FIELDS WILL TERMINATE ONE COLUMN PREVIOUS TO       *
 *     THE STARTING COLUMN OF THE NEXT FIELD, E.G. IF FIELD Y STARTS   *
 *     IN COLUMN 10, FIELD X WILL STOP IN COLUMN 9.  THE START OF      *
 *     FIELD Y WILL BE DETERMINED BY FINDING THE FIRST BLANK           *
 *     CHARACTER IN X. FIELD Y WILL START WITH THE FIRST NON-BLANK     *
 *     CHARACTER AFTER THAT.                                           *
 *   USE INPUT A 1 B 5-10 C D                                          *
 *     FIELD A WILL BEGIN IN COLUMN 1, AND WILL BE 1 COLUMN LONG.      *
 *     FIELD B WILL BEGIN IN COLUMN 5, AND WILL BE 6 COLUMNS LONG.     *
 *     FIELD C WILL BEGIN IN THE FIRST NON-BLANK COLUMN BEYOND         *
 *     COLUMN 10 IN THE FIRST RECORD IN THE DATA SET.  THE LENGTH OF   *
 *     C, AND THE OFFSET AND LENGTH OF D WILL BE CALCULATED AS IN      *
 *     THE FIRST EXAMPLE ABOVE.                                        *
 *   USE INPUT                                                         *
 *     USE INPUT FOLLOWED BY NO OPERANDS SIGNIFIES THAT THE CURRENT    *
 *     DATABASE DEFINITION, IF ANY, IS TO BE DELETED, AND THE DATA SET *
 *     IS NOT TO BE ASSOCIATED WITH A DATABASE DEFINITION.             *
 *   USE INPUT @ 23 XYZ PIB1. @ 47 ABC PD5.;                           *
 *     FIELD XYZ IS POSITIVE INTEGER BINARY (PIB) OF LENGTH 1, AND     *
 *     STARTS IN COLUMN 23.  FIELD ABC IS PACKED DECIMAL OF LENGTH 5,  *
 *     AND STARTS IN COLUMN 47.  OTHER ACCEPTABLE FORMATS ARE          *
 *                                                                     *
 *          $CHAR  - CHARACTER - LENGTH <= 256.                        *
 *          HEX    - HEXADECIMAL - LENGTH <= 256.                      *
 *          IB     - INTEGER BINARY (FIXED POINT) LENGTH = 2 OR 4.     *
 *          PACKED - PACKED DECIMAL - LENGTH <= 8.                     *
 *          RB     - REAL BINARY (FLOATING POINT) - LENGTH = 4, 8, 16. *
 *                                                                     *
 *     NOTE THAT IS NO FORMAT IS SPECIFIED, E.G. "@ 23 ABC 8." THE     *
 *     FORMAT ASSUMED IS ZONED DECIMAL.                                *
 *                                                                     *
 *   NOTE THAT THE SECOND AND FOURTH FORMATS SHOWN ABOVE MAY BE        *
 *   INTERMIXED.                                                       *
 *                                                                     *
 **********************************************************************/
   DCL FIXED BIT(1);
   DCL (I,J,K) FIXED BIN(31,0) INIT(0);
   DCL (JOINHDR,JOINLAST,NEWUSETR) PTR;
   DCL 1 JOINSTR BASED(JOINPTR),
     2 JOINNXT PTR,
     2 JOINPOINT FIXED BIN(31,0);

   JOINHDR,JOINLAST=NULL;
   IF RECPTR^=HDPTR
     THEN DO;
       L=LENGTH(RECSTR);
       CURSOR=PREFIX(RECSTR,' '); /* FIND FIRST NONBLANK */
       END;
     ELSE CURSOR,L=0;
   SCAN; /* GET NEXT TOKEN */
   J=1; /* JOIN POSITION */
   DO FOREVER=1 REPEAT FOREVER;
     SELECT;
       WHEN(TYPE=OPERAND × TYPE=KEYWORD) DO;
         CALL INPSUB1(J,FIXED); /* GO PROCESS COLUMNAR INPUT */
         END;
       WHEN(TOKSTR='/') DO; /* TIME TO JOIN RECORDS */
         ALLOCATE JOINSTR;
         J=RHNPOS+RHNLNG; /* SET NEW J VALUE */
         JOINPOINT=J;
         JOINNXT=NULL;
         IF JOINLAST=NULL
           THEN JOINHDR=JOINPTR;
           ELSE JOINLAST->JOINNXT=JOINPTR;
         JOINLAST=JOINPTR;
         SCAN; /* GET NEXT TOKEN */
         END;
       WHEN(TOKSTR='@') DO; /* IT IS FORMATTED INPUT */
         CALL INPSUB2(J); /* GO PROCESS FORMATTED INPUT */
         END;
       OTHERWISE LEAVE; /* IT MAY BE BAD INPUT */
       END; /* SELECT */
     END;
   IF TYPE^=NO_MORE_TOKENS
     THEN DO;
       MSGDATA='INVALID SYNTAX = '××TOKSTR;
       SIGNAL CONDITION(BADUSE);
       END;
   IF NEWHDR=NULL
     THEN NEWUSETR=NULL;
     ELSE DO;
       NEWUSETR=BLDAVL(NEWHDR); /* GO BUILD AVL SEARCH TREE */
       IF NEWUSETR=NULL
         THEN DO;
           MSGDATA='ERROR - DUPLICATE FIELD NAMES';
           SIGNAL CONDITION(BADUSE);
           END;
       END;
   CALL DELDBD(ADDR(RHUSEHD)); /* GO DELETE USAGE DBD */
   CALL DELDBD(ADDR(RH_DISPLAY_HDR)); /* GO DELETE DISPLAY DBD */
   RHUSEHD=NEWHDR;
   RHUSETR=NEWUSETR;
   NEWHDR=NULL;

   /* NOW DETERMINE IF BUFFER NEEDS TO BE REALLOCATED */
   DO RHNAMPTR=RHUSEHD REPEAT RHNLINK WHILE(RHNAMPTR^=NULL)
     UNTIL(RHNLINK=NULL);
     END;
   IF RHNAMPTR^=NULL
     THEN IF RHNPOS^=0
       THEN CALL BUFCK(RHNPOS+RHNLNG,'0'B); /* GO REALLOCATE BUFFER */
   CALL JOININ(JOINHDR); /* GO PERFORM JOINS */
   CALL CLEANUP;
   USEBUF='';
   END INPUT;

 INPSUB1: PROC(JOFF,FIXED);
 /**********************************************************************
 *                                                                     *
 * THIS SUBRTNE IS CALLED WHEN COLUMNAR INPUT IS RECOGNIZED.           *
 *                                                                     *
 **********************************************************************/
   DCL JOFF FIXED BIN(31,0);
   DCL FIXED BIT(1);

   CALL FUNCK(TOKSTR);
   CALL INPSUB3; /* GO ALLOCATE AND QUEUE RHNAMESTR */
   RHNNAME=TOKSTR;
   SCAN; /* GET NEXT TOKEN */
   SELECT;
     WHEN(TYPE=NUMBER) DO;
       RHNTYPE=ZD; /* IT IS ZONED DECIMAL FIELD */
       CALL DOCOL; /* GO PROCESS COLUMN RANGE */
       END;
     WHEN(TOKSTR='$') DO;
       RHNTYPE=CHR; /* IT IS CHARACTER FIELD */
       SCAN; /* GET NEXT TOKEN */
       IF TYPE=NUMBER
         THEN CALL DOCOL;
         ELSE IF FIXED
           THEN CALL FINDCOL(RHNPOS,RHNLNG,'0'B);
             /* GO FIGURE RHNPOS,RHNLNG FROM DATA */
       END;
     OTHERWISE DO;
       RHNTYPE=ZD; /* IT IS ZONED DECIMAL FIELD */
       IF FIXED
        THEN CALL FINDCOL(RHNPOS,RHNLNG,'0'B);
          /* GO FIGURE RHNPOS,RHNLNG FROM DATA */
       END;
     END; /* SELECT */
   RHNPOS=RHNPOS+JOFF-1;
   END INPSUB1;

 INPSUB2: PROC(JOFF);
 /**********************************************************************
 *                                                                     *
 * THIS SUBRTNE IS CALLED WHEN FORMATTED INPUT IS RECOGNIZED.          *
 *                                                                     *
 **********************************************************************/
   DCL JOFF FIXED BIN(31,0);
   DCL (I,J,K,L) FIXED BIN(15,0);

   CALL INPSUB3; /* GO ALLOCATE AND QUEUE RHNAMESTR */
   SCAN; /* GET NEXT TOKEN */
   IF TYPE^=NUMBER
     THEN SIGNAL CONDITION(BADUSE);
   RHNPOS=TOKSTR; /* STORE FIELD OFFSET */
   SCAN;
   IF ^(TYPE=OPERAND × TYPE=KEYWORD)
     THEN SIGNAL CONDITION(BADUSE); /* MISSING FIELD NAME */
   CALL FUNCK(TOKSTR);
   RHNNAME=TOKSTR; /* STORE FIELD NAME */
   SCAN;
   IF LENGTH(TOKSTR)>=2
     & VERIFY(SUBSTR(TOKSTR,1,LENGTH(TOKSTR)-1),'0123456789')=0
     & SUBSTR(TOKSTR,LENGTH(TOKSTR),1)='.'
     THEN DO; /* IT IS ZONED DECIMAL */
       RHNTYPE=ZD; /* SET TYPE=ZONED DECIMAL */
       RHNLNG=TOKSTR; /* SET FIELD LENGTH */
       END;
     ELSE DO;
       IF TOKSTR='$'
         THEN DO;
           SCAN;
           IF INDEX(TOKSTR,'CHAR')=1
             THEN TOKSTR='$'××TOKSTR;
             ELSE SIGNAL CONDITION(BADUSE); /* S/B $CHAR */
           END;
       J=LENGTH(TOKSTR);
       DO I=1 TO HBOUND(TYPETAB,1);
         L=LENGTH(TYPETAB(I));
         IF J>L
           THEN IF SUBSTR(TOKSTR,1,L)=TYPETAB(I)
             THEN LEAVE; /* GOT INPUT FORMAT */
         END;
       IF I>HBOUND(TYPETAB,1)
         THEN SIGNAL CONDITION(BADUSE); /* INVALID DATA TYPE */
       RHNTYPE=I; /* SET FIELD TYPE */
       IF VERIFY(SUBSTR(TOKSTR,L+1),'0123456789')^=0
         THEN SIGNAL CONDITION(BADUSE); /* INVALID LENGTH */
       RHNLNG=SUBSTR(TOKSTR,L+1); /* SET FIELD LENGTH */
       SCAN; /* GET PERIOD */
       IF TOKSTR^='.'
         THEN SIGNAL CONDITION(BADUSE);
       END;
   SELECT(RHNTYPE);
     WHEN(2,5,6,8) /* CHAR, HEX, BIT, BEST */
       IF RHNLNG>256
         THEN SIGNAL CONDITION(BADUSE); /* BAD LENGTH */
     WHEN(7) /* FIXED */
       IF RHNLNG^=2 & RHNLNG^=4
         THEN SIGNAL CONDITION(BADUSE); /* BAD LENGTH */
     WHEN(4) /* PACKED */
       IF RHNLNG>8
         THEN SIGNAL CONDITION(BADUSE); /* BAD LENGTH */
     WHEN(3) /* ZONED */
       IF RHNLNG>15
         THEN SIGNAL CONDITION(BADUSE); /* BAD LENGTH */
     OTHERWISE /* FLOAT */
       IF RHNLNG^=4 & RHNLNG^=8 & RHNLNG^=16
         THEN SIGNAL CONDITION(BADUSE); /* BAD LENGTH */
     END; /* SELECT */
   SELECT(RHNTYPE);
     WHEN(2,3,5);
     OTHERWISE HEXMODE='1'B; /* MUST BE DISPLAYED IN HEX */
     END; /* SELECT */
   /* FOR NOW, WE WON'T HANDLE SCALE */
   SCAN; /* GET START OF NEXT FORMAT, MAYBE */
   RHNPOS=RHNPOS+JOFF-1;
   END INPSUB2;

 INPSUB3: PROC;
 /**********************************************************************
 *                                                                     *
 * THIS SUBROUTINE IS CALLED WHEN A NEW RHNAMESTR STRUCTURE IS TO BE   *
 * ALLOCATED.                                                          *
 *                                                                     *
 **********************************************************************/

   ALLOCATE RHNAMESTR SET(RHNAMPTR);
   /* NOW QUEUE AT END OF QUEUE */
   RHNLINK=NULL;
   IF NEWHDR=NULL
     THEN NEWHDR=RHNAMPTR;
     ELSE LAST->RHNLINK=RHNAMPTR;
   LAST=RHNAMPTR;
   RHNTYPE,RHNPOS,RHNLNG,RHNVAR0,RHNFL,RHNFD,RHNF,RHNJUST=0;
   RHNCPOS,RHNCLNG=0;
   RHNLABEL,RHNFORM,RHNIFORM='';
   END INPSUB3;

 INPSUB4: PROC(WPT,J);
 /**********************************************************************
 *                                                                     *
 * THIS SUBROUTINE IS CALLED WHEN A NEW RHNAMESTR STRUCTURE IS TO BE   *
 * ALLOCATED FOR THE DISPLAY LINE.                                     *
 *                                                                     *
 **********************************************************************/
   DCL (J,LNG) FIXED BIN;
   DCL WPT PTR;

   CALL INPSUB3; /* ALLOC RHNAMESTR AND QUEUE OFF NEWHDR */
   RHNNAME=WPT->RHNNAME;
   IF WPT->RHNTYPE=ZD × WPT->RHNTYPE=CHR
     THEN LNG=WPT->RHNLNG;
     ELSE LNG=20;
   RHNTYPE=WPT->RHNTYPE;
   IF RHNTYPE=BITTYPE
     THEN RHNTYPE=BEST;
     ELSE IF RHNTYPE^=CHR
       THEN RHNTYPE=ZD;
   RHNPOS=J;
   RHNLNG=LNG;
   J=J+LNG;
   END INPSUB4;

 JOININ: PROC(JOINHDR);
 /**********************************************************************
 *                                                                     *
 * CALLED WHEN IT IS TIME TO JOIN RECORDS. THIS SUBRTNE IS NESTED IN   *
 * THE INPUT SUBRTNE.                                                  *
 *                                                                     *
 **********************************************************************/
   DCL (I,J,K) FIXED BIN;
   DCL (DELPTR,JOINHDR,JOINPTR,RPT) PTR;
   DCL 1 JOINSTR BASED(JOINPTR),
     2 JOINNXT PTR,
     2 JOINPOINT FIXED BIN(31,0);

   DO RPT=NXTHDR REPEAT RPT->NXTPTR WHILE(RPT^=HDPTR);
     DO JOINPTR=JOINHDR REPEAT JOINNXT WHILE(JOINPTR^=NULL);
       IF RPT->NXTPTR=HDPTR
         THEN DO;
           PUT SKIP LIST('ERROR DURING JOIN IN USE');
           SIGNAL CONDITION(BADUSE);
           END;
       RPT->RECSTR=SUBSTR(RPT->RECSTR,1,JOINPOINT-1)××
           RPT->NXTPTR->RECSTR;
       DELPTR=RPT->NXTPTR;
       CALL #PUTSLOT(RHPTR,RHHDRPT,DELPTR);
       END;
     END;
   DO JOINPTR=JOINHDR REPEAT JOINHDR WHILE(JOINHDR^=NULL);
     JOINHDR=JOINNXT;
     FREE JOINSTR;
     END;
   I=#CMD('TOP',RHPTR,RHHDRPT);
   END JOININ;

 LIST: PROC;
 /**********************************************************************
 * LIST IS CALLED TO PROCESS A USE SUBCOMMAND IN WHICH THE FIRST       *
 * OPERAND IS THE LIST KEYWORD.                                        *
 **********************************************************************/
   DCL STR CHAR(80) VAR;
   DO RHNAMPTR=RHUSEHD REPEAT RHNLINK WHILE(RHNAMPTR^=NULL);
     CALL LISTCOM(RHNAMPTR);
     END;
   CALL #TERM('END-OF-LIST');
   END LIST;

 LISTCOM: PROC(PPT);
 /**********************************************************************
 * LISTCOM CALLED TO PROCESS PRINT VALUES FOR THE CURRENT LIST ELEMENT.*
 **********************************************************************/
   DCL PPT PTR;
   DCL STR CHAR(80) VAR;

   PUT STRING(STR) EDIT
     (' NAME=',PPT->RHNNAME)(A,A)
     (' OFF=',PPT->RHNPOS)(A,P'ZZZ9')
     (' LEN=',PPT->RHNLNG)(A,P'ZZZ9')
     (' TYPE=',TYPETAB(PPT->RHNTYPE))(A,A)
     (' CURR. OFF=',PPT->RHNCPOS)(A,P'ZZZ9')
     (' CURR. LEN=',PPT->RHNCLNG)(A,P'ZZZ9');
   CALL #TERM(STR);
   END LISTCOM;

 LISTAVL: PROC(PPT) RECURSIVE;
 /**********************************************************************
 * LIST IS CALLED TO PROCESS A USE SUBCOMMAND IN WHICH THE FIRST       *
 * OPERAND IS THE LISTAVL KEYWORD.                                     *
 **********************************************************************/
   DCL PPT PTR;
   DCL STR CHAR(80) VAR;

   IF PPT=NULL
     THEN RETURN;
   IF PPT->RHLCHILD^=NULL
     THEN CALL LISTAVL(PPT->RHLCHILD);
   CALL LISTCOM(PPT);
   CALL LISTAVL(PPT->RHRCHILD);
   END LISTAVL;

 OUT: PROC;
 /**********************************************************************
 *                                                                     *
 * CALLED TO ADD THE DBD ON THE FRONT OF THE CURRENTLY EDITED DATASET. *
 *                                                                     *
 **********************************************************************/
   DCL LAST FIXED BIN(31,0) INIT(99999999);
   DCL (SAVPTR,ORGPTR,CURPTR) PTR;
   DCL DOLLAR CHAR(3) VAR;
   DCL (I,J,SEQ) FIXED BIN(31,0);
   DCL BUF CHAR(80) VAR;
   DCL CARDS4SW BIT(1) INIT('0'B);

   IF NXTHDR^=HDPTR
     THEN CALL OUTTRIM; /* TRIM & SPLIT RECORDS, IF NECESSARY */
   ORGPTR=RECPTR;
   IF RECPTR^=HDPTR
     THEN IF LSTPTR=HDPTR
       THEN ORGPTR=HDPTR;
   ON CONDITION(BADOUT) BEGIN;
     IF ORGPTR=HDPTR
       THEN CALL #NC(RHPTR,NXTHDR); /* CALL NEWCUR */
       ELSE CALL #NC(RHPTR,ORGPTR); /* CALL NEWCUR */
     MSGDATA='NO VALID DBD TO STORE AT THE FRONT OF THIS DATASET';
     SIGNAL CONDITION(BADUSE);
     END;
   IF RHUSEHD=NULL
     THEN SIGNAL CONDITION(BADOUT);
   CALL #NC(RHPTR,HDPTR); /* POSITION TO START OF DATA SET */
   BUF='DATA '××RHNAME××';';
   SAVPTR,CURPTR=RECPTR;
   SEQ=-1;
   CALL #ADD(RHPTR,RHHDRPT,SAVPTR,SAVPTR,SEQ,BUF,0); /* ADD REC */
   BUF='INPUT ';
   J=0; /* RHNPOS FROM PREVIOUS FIELD */
   DO RHNAMPTR=RHUSEHD REPEAT RHNLINK WHILE(RHNAMPTR^=NULL);
     IF LENGTH(BUF)>53
       THEN DO;
         SEQ=-1;
         CALL #ADD(RHPTR,RHHDRPT,SAVPTR,SAVPTR,SEQ,BUF,0);
         BUF='';
         END;
     IF RHNPOS^=0
       THEN IF RHNPOS<=J
         THEN BUF=BUF××' /'; /* SPLIT HERE TO NEW CARD */
     J=RHNPOS;
     IF RHNTYPE=2 × RHNTYPE=3
       THEN DO; /* CHAR, ZONED */
         IF RHNTYPE=2
           THEN DOLLAR=' $ ';
           ELSE DOLLAR=' ';
         PUT STRING(BUF) EDIT(BUF,' ',RHNNAME,DOLLAR)(A,A,A,A);
         IF RHNPOS^=0
           THEN PUT STRING(BUF) EDIT(BUF,OUTSUB(RHNPOS),'-',
             OUTSUB(RHNPOS+RHNLNG-1))(A,A,A,A);
         END;
       ELSE DO;
         PUT STRING(BUF) EDIT(BUF,' @',OUTSUB(RHNPOS),RHNNAME,
           TYPETAB(RHNTYPE),OUTSUB(RHNLNG),'.')
           (A,A,A,X(1),A,X(1),A,A,A);
         CARDS4SW='1'B;
         END;
     END;
   BUF=BUF××';';
   SEQ=-1;
   CALL #ADD(RHPTR,RHHDRPT,SAVPTR,SAVPTR,SEQ,BUF,0); /* ADD REC */
   IF CARDS4SW
     THEN BUF='CARDS4;';
     ELSE BUF='CARDS;';
   SEQ=-1;
   CALL #ADD(RHPTR,RHHDRPT,SAVPTR,SAVPTR,SEQ,BUF,0); /* ADD REC */
   CALL #RESEQ(RHPTR,RHHDRPT,SAVPTR->LSTPTR,'NOSAVE','NORENUM',LAST);
   IF ORGPTR = HDPTR
     THEN CALL #NC(RHPTR,NXTHDR);/*CALL NEWCUR*/
     ELSE CALL #NC(RHPTR,ORGPTR);/*CALL NEWCUR*/
   RECHDR.CMDDATA='USE ×'; /* ELIMINATE DBD */
   END OUT;

 OUTSUB: PROC(NUM) RETURNS(CHAR(5) VAR);
 /**********************************************************************
 *                                                                     *
 * OUTSUB WILL RETURN THE PRINTABLE EQUIVALENT OF NUM WITH LEADING     *
 * ZEROS REMOVED.                                                      *
 *                                                                     *
 **********************************************************************/
   DCL NUM FIXED BIN(15,0);
   DCL PIC PIC'ZZZZ9';
   PIC=NUM;
   RETURN(SUBSTR(PIC,PREFIX(PIC,' ')));
   END OUTSUB;

 OUTTRIM: PROC;
 /**********************************************************************
 *                                                                     *
 * CALLED WHEN IT IS TIME TO DO A "USE OUT" SUBCOMMAND.  THIS SUBRTNE  *
 * WILL SPLIT AND TRIM ALL DATA LINES SO THAT NO LINE EXCEEDS 72 BYTES *
 * IN LENGTH. NOTE THAT IT WILL DO THIS ONLY IF THE FORMAT IS FIXED.   *
 * IT ALSO ASSUMES THAT THE FIELDS ARE LINKED IN ASCENDING ORDER BY    *
 * FIELD POSITION.                                                     *
 *                                                                     *
 **********************************************************************/
   DCL (I,J,K,L,M,N,P,Q) FIXED BIN(15,0);
   DCL KCH CHAR(5) VAR;
   DCL (CPT,RPT) PTR;

   K=0;
   DO RHNAMPTR=RHUSEHD REPEAT RHNLINK WHILE(RHNAMPTR^=NULL);
     IF RHNPOS=0
       THEN RETURN; /* WON'T HANDLE FREE-FORM */
     K=MAX(K,RHNPOS+RHNLNG);
     END;
   /* K NOW CONTAINS THE OFFSET TO THE FIRST USELESS DATA BYTE. */
   KCH=OUTSUB(K);
   /* NOW ENSURE BLANKS OUT TO THIS POINT */
   I=#CMD(KCH××'.1 FLIP '××KCH××'.1',RHPTR,RHHDRPT);
   /* NOW CLEAR USELESS TRAILING BYTES */
   I=#CMD('CLEAR '××KCH,RHPTR,RHHDRPT);
   /* NOW PERFORM ANY NECESSARY LINE SPLITS */
   IF K<=73
     THEN RETURN; /* NO SPLITS NECESSARY */
   DO RPT=LSTHDR REPEAT RPT->LSTPTR WHILE(RPT^=HDPTR);
     CPT=RPT;
     M=0;
     DO RHNAMPTR=RHUSEHD REPEAT RHNLINK WHILE(RHNAMPTR^=NULL);
       P=RHNPOS; /* SAVE ORIGINAL RHNPOS */
       Q=RHNPOS-M; /* Q=ADJUSTED POS */
       K=Q+RHNLNG-1; /* MAXIMUM OFFSET THIS FIELD */
       IF K>72
         THEN DO; /* TIME TO SPLIT */
           IF LENGTH(CPT->RECSTR)<Q
             THEN BUF='';
             ELSE DO;
               BUF=SUBSTR(CPT->RECSTR,Q);
               CPT->RECSTR=SUBSTR(CPT->RECSTR,1,Q-1);
               END;
           CALL #ADD(RHPTR,RHHDRPT,CPT,CPT,-1,BUF,0);
           M=P-1; /* NEW OFFSET DIFFERENTIAL */
           END;
       END;
     END;
   CALL #RESEQ(RHPTR,RHHDRPT,NXTHDR,'NOSAVE','RENUM',99999999);
   CALL #NC(RHPTR,NXTHDR); /* CALL ABENC */
   /* NOW ADJUST ALL RHNPOS VALUES */
   M=0;
   DO RHNAMPTR=RHUSEHD REPEAT RHNLINK WHILE(RHNAMPTR^=NULL);
     P=RHNPOS; /* SAVE ORIGINAL RHNPOS */
     RHNPOS=RHNPOS-M;
     K=RHNPOS+RHNLNG-1; /* MAXIMUM OFFSET THIS FIELD */
     IF K>72
       THEN DO; /* TIME TO SPLIT */
         M=P-1; /* NEW OFFSET DIFFERENTIAL */
         RHNPOS=1;
         END;
     END;
   RETURN;
   END OUTTRIM;

 SET: PROC(SYMSW);
 /**********************************************************************
 * SET IS CALLED TO PROCESS A USE SUBCOMMAND IN WHICH THE FIRST        *
 * OPERAND IS THE SET OR NOSYM KEYWORDS.  IN BOTH CASES, THE AIM IS TO *
 * LOCATE THE DATA IN THE CURRENT RECORD FOR EACH FIELD DEFINED.  THE  *
 * NOSYM KEYWORD IMPLIES THE SET KEYWORD, BUT IT INDICATES THAT THE    *
 * REPLACEMENT VALUE FOR THE SYMBOLIC VARIABLE ASSOCIATED WITH EACH    *
 * FIELD IS NOT TO BE SET.  THE NOSYM KEYWORD IS NORMALLY USED BY THE  *
 * SELECT SUBCOMMAND.                                                  *
 **********************************************************************/
   DCL SYMSW BIT(1);
   DCL GBLSW BIT(1) STATIC INIT('0'B);
   DCL SYMBOLPM CHAR(8);
   DCL (TXT,CCC) CHAR(256) VAR;
   DCL (POS,LNG) FIXED BIN(15,0);
   DCL TMP PTR;
   DCL FLT DEC FLOAT(16),
       FLC BASED(ADDR(FLT)) CHAR(8);

   ALLOC RHNAMESTR SET(TMP);
   TMP->RHNTYPE=1; /* FLOAT */
   TMP->RHNLNG=8;
   TMP->RHNFD=0;
   IF RECPTR=HDPTR
     THEN CURSOR,L=0;
     ELSE DO;
       CURSOR=1;
       L=LENGTH(RECSTR);
       END;
   DO RHNAMPTR=RHUSEHD REPEAT RHNLINK WHILE(RHNAMPTR^=NULL);
     SYMBOLPM=RHNNAME;
     IF RECPTR=HDPTR
       THEN IF SYMSW
         THEN CALL #SETC(RHHDRPT,RH_SYMTREE,SYMBOLPM,''); /* EMPTY */
         ELSE;
       ELSE DO;
         IF RHNPOS=0
           THEN DO;
             CALL FINDCOL(RHNCPOS,RHNCLNG,'1'B);
             IF RHNCLNG=0
               THEN TXT='';
               ELSE TXT=SUBSTR(RECSTR,RHNCPOS,RHNCLNG);
             END;
           ELSE DO;
             RHNCPOS=RHNPOS;
             RHNCLNG=RHNLNG;
             IF RHNLNG=0 × L<RHNPOS
               THEN TXT='';
               ELSE IF L<RHNPOS+RHNLNG-1
                 THEN TXT=SUBSTR(RECSTR,RHNPOS);
                 ELSE TXT=SUBSTR(RECSTR,RHNPOS,RHNLNG);
             END;
         SELECT(RHNTYPE);
           WHEN(2,3,8)  /* CHAR,ZONED,BEST */
             IF SYMSW
               THEN CALL #SETC(RHHDRPT,RH_SYMTREE,SYMBOLPM,TXT);
           OTHERWISE DO;
             FLC=#CONVERT(TXT,RHNAMPTR,TMP);
             IF SYMSW
               THEN CALL #SETA(RHHDRPT,RH_SYMTREE,SYMBOLPM,FLT);
             END; /* OTHERWISE */
           END; /* SELECT */
         END;
     END;
   FREE TMP->RHNAMESTR;
   END SET;

 USECOPY: PROC;
 /**********************************************************************
 *                                                                     *
 * CALLED TO PROCESS A USE SUBCOMMAND OF THE FORM "USE <NAME>" WHERE   *
 * <NAME> IS THE SYMBOLIC NAME OF A DATA SET WHOSE DBD IS TO BE        *
 * COPIED.                                                             *
 *                                                                     *
 **********************************************************************/
   DCL (TRH,DELPTR,NEWPTR,LAST) PTR;
   DO TRH=NXTRHEL REPEAT TRH->RHNXT WHILE(TRH^=NULL)
     UNTIL(TRH->RHNAME=TOKSTR);
     END;
   IF TRH=NULL
     THEN DO;
       MSGDATA='INVALID KEYWORD = '××TOKSTR;
       SIGNAL CONDITION(BADUSE);
       END;
   DO DELPTR=RHUSEHD REPEAT RHUSEHD WHILE(DELPTR^=NULL);
     RHUSEHD=DELPTR->RHNLINK;
     FREE DELPTR->RHNAMESTR;
     END;
   RHUSETR=NULL;
   DO DELPTR=TRH->RHUSEHD REPEAT DELPTR->RHNLINK WHILE(DELPTR^=NULL);
     ALLOCATE RHNAMESTR SET(NEWPTR);
     NEWPTR->RHNAMESTR=DELPTR->RHNAMESTR;
     NEWPTR->RHNLINK=NULL;
     IF RHUSEHD=NULL
       THEN RHUSEHD=NEWPTR;
       ELSE LAST->RHNLINK=NEWPTR;
     LAST=NEWPTR;
     END;
   RHUSETR=BLDAVL(RHPTR->RHUSEHD); /* GO BUILD AVL SEARCH TREE */
   END USECOPY;

 USEFORM: PROC(PCMD);
 /**********************************************************************
 *                                                                     *
 * THIS SUBROUTINE IS CALLED TO PROCESS A USE SUBCOMMAND OF THE FORM   *
 * '× NAME1 ×   × NAME2 × ...' THE SUBROUTINE WILL REWRITE THE         *
 * COMMAND BUFFER TO LOOK LIKE E.G.                                    *
 *                                                                     *
 * 'USE '××PCMD××'  NAME1 1-23 NAME2 25-27'                            *
 *                                                                     *
 * BASED ON THE RELATIVE OFFSETS OF THE VERTICAL BARS.  THE FIRST      *
 * VERTICAL BAR IS ASSUMED TO BE IN POSITION 1 OF THE ACTUAL RECORD.   *
 *                                                                     *
 * ONE CAN ALSO SPECIFY E.G. 'USE × NAME1 × (NAME2 NAME3) × ...'.      *
 * NAMES 'NAME2' AND 'NAME3' WILL HAVE FREE FORMAT.  THAT IS, THE      *
 * USE SUBCOMMAND GENERATED WILL BE 'USE INPUT NAME1 1-8 NAME2 NAME3', *
 * AND FIELDS NAME2 AND NAME3 WILL HAVE THEIR FIELD POSITIONS AND      *
 * LENGTHS DERIVED DYNAMICALLY FROM THE DATA FORMAT OF THE CURRENT     *
 * RECORD WHEN THE USE SUBCOMMAND IS ISSUED WITHOUT ANY OPERANDS.      *
 *                                                                     *
 **********************************************************************/
   DCL PCMD CHAR(*);
   DCL NEWCMD CHAR(256) VAR;
   DCL (ORG,LEFT,RIGHT,ZCNT) FIXED BIN(15,0);
   DCL NNAME CHAR(10) VAR;
   DCL PRMSG CHAR(80) VAR;

   NEWCMD=PCMD;
   ZCNT=0; /* COUNT OF Z NAMES IN DEFINITION */
   ORG,LEFT=SCANIX-1; /* SAVE POSITION OF FIRST × */
   RIGHT=0;
   NNAME='';
   DO UNTIL(TYPE=NO_MORE_TOKENS);
     SCAN; /* GET NEXT TOKEN */
     IF TOKSTR='('
       THEN DO; /* IT IS A STRING OF FREE-FORM FIELDS */
         IF NNAME^=''
           THEN DO;
             MSGDATA='INVALID OPERAND='''××TOKSTR××'''';
             SIGNAL CONDITION(BADUSE);
             END;
         DO UNTIL(TOKSTR=')' × TYPE=NO_MORE_TOKENS);
           SCAN;
           IF TYPE=OPERAND × TYPE=KEYWORD
             THEN IF TOKSTR='Z'
               THEN DO;
                 ZCNT=ZCNT+1;
                 PUT STRING(PRMSG)
                   EDIT('ENTER FULL NAME FOR Z VARIABLE #',ZCNT)
                   (A,P'ZZ9');
                 NEWCMD=NEWCMD××' '××#PROMPT(PRMSG);
                 END;
               ELSE NEWCMD=NEWCMD××' '××TOKSTR;
             ELSE IF TOKSTR='$'
               THEN NEWCMD=NEWCMD××' '××TOKSTR;
           END;
         IF TOKSTR=')'
           THEN SCAN;
         END;
     IF TYPE=NO_MORE_TOKENS
       THEN RIGHT=BUFLN; /* DEFAULT TO A × AT END */
       ELSE IF TOKSTR='×'
         THEN RIGHT=SCANIX-2;
         ELSE IF TOKSTR='$' & NNAME^=''
           THEN NNAME=NNAME××' '××TOKSTR;
           ELSE IF (TYPE^=OPERAND & TYPE^=KEYWORD) × NNAME^=''
             THEN DO;
               MSGDATA='INVALID OPERAND='''××TOKSTR××'''';
               SIGNAL CONDITION(BADUSE);
               END;
             ELSE NNAME=TOKSTR;
     IF RIGHT^=0
       THEN DO;
         IF NNAME^=''
           THEN DO;
             IF NNAME='Z'
               THEN DO;
                 ZCNT=ZCNT+1;
                 PUT STRING(PRMSG)
                   EDIT('ENTER FULL NAME FOR Z VARIABLE #',ZCNT)
                   (A,P'ZZ9');
                 NNAME=#PROMPT(PRMSG);
                 END;
             PUT STRING(NEWCMD)
               EDIT(NEWCMD,' ',NNAME,OUTSUB(LEFT-ORG+1),'-',
               OUTSUB(RIGHT-ORG+1))
               (A,A,X(1),A,X(1),A,A,A);
             END;
         LEFT=RIGHT+1;
         RIGHT=0;
         NNAME='';
         END;
     END;
   CALL CLEANUP;
   USEBUF=NEWCMD;
   SCAN;
   END USEFORM;

   END ABE053;
