.HE GENERALIZED ROUTINES - PLICPDC
.HE HOW TO WRITE TSO COMMAND PROCESSORS IN PLI
.HE PRELIMINARY DRAFT
.PL 55
.PN 0
.PA
.SS
.NF
09/14/76
AUTHOR:  T. SMITH
SOURCE MODULE NAME:  PLICPDC
.SP 5
INDEX
.SP 1
COMMAND PROCESSOR INITIALIZATION--------------- 02
@CMD - INVOKING OTHER TSO COMMANDS------------- 03
@READ - READ A LINE FROM THE TERMINAL---------- 04
@WRITE - WRITE A LINE TO THE TERMINAL---------- 05
@PUTGET - PROMPT THE TERMINAL AND GET A LINE--- 06
SYMBOLIC REPLACEMENT--------------------------- 07
@PROC - OBTAIN COMMAND OPERANDS --------------- 09
ACCESSING THE COMMAND BUFFER------------------- 10
USING THE IBM-SUPPLIED PARSE ROUTINE----------- 11
@ALLOC - DIRECT INTERFACE TO ALLOCATION-------- 13
@FREE - DIRECT INTERFACE TO FREE--------------- 14
ABBREVIATION OF @ALLOC AND @FREE KEYWORDS------ 15
DAIRERR - SUBROUTINE TO HANDLE DAIR ERRORS----- 16
HOW TO COMPILE AND EXECUTE A PLI/TSO COMMAND--- 17
.FI L
.PA
***** COMMAND PROCESSOR INITIALIZATION.
.SP 1
A STANDARD SET OF INITIALIZATION PLI STATEMENTS
HAS BEEN SET UP AND STORED IN SYS2.MACLIB.  TO INCLUDE THESE
STATEMENTS, PLACE THE FOLLOWING STATEMENT AT THE FRONT OF YOUR
PROGRAM:
.SP 1
 % INCLUDE CPINIT;
.SP 1
ONE OF THE STATEMENTS IN CPINIT IS A PROCEDURE OPTIONS(MAIN) STATEMENT.
THE DEFAULT NAME FOR THE PROCEDURE IS "CP".  TO CHANGE THIS TO
"LISTRF" FOR EXAMPLE, REPLACE THE "%INCLUDE CPINIT" STATEMENT AT THE
FRONT OF THE PROGRAM WITH THE FOLLOWING:
.SP 1
.IN 5
.NF
% INCLUDE CPINIT1;
% @CP = 'LISTRF';
% INCLUDE CPINIT2;
.FI L
.IN 0
.PA
***** @CMD - INVOKING OTHER TSO COMMANDS FROM PLI
.SP 1
TO INVOKE OTHER TSO COMMAND PROCESSORS FROM PLI, USE THE @CMD
PREPROCESSOR PROCEDURE.  FOR EXAMPLE, TO ISSUE AN ALLOCATE COMMAND:
.SP 1
 @CMD('ALLOC FI(SYSLIB) DA(''SYS2.MACLIB'') SHR');
.SP 1
ANOTHER EXAMPLE TO ILLUSTRATE HOW @CMD CAN BE USED IN IF-THEN-ELSE
STATEMENTS:
.SP 1
.IN 5
.NF
IF EOJ
 THEN @CMD('FREE FI(SYSLIB)');
 ELSE @CMD('CALL TEST(MYPGM)');
.FI L
.IN 0
.PA
***** @READ - READ A LINE FROM THE TERMINAL.
.SP 1
 TO READ A LINE FROM THE TERMINAL USE THE @READ PREPROCESSOR AS
FOLLOWS:
.SP 1
 @READ(LINE);
.SP 1
LINE IS A CHARACTER STRING OF ANY LENGTH (TRUNCATION OR PADDING IS
PERFORMED, AS NECESSARY), AND IT CAN BE EITHER FIXED OR VARYING.  THE
LINE OF TEXT WILL BE TRANSLATED AUTOMATICALLY TO UPPERCASE.  IF YOU
DON'T WANT THIS, ENTER
.SP 1
@READ(LINE,NOCAPS);
.PA
***** @WRITE - WRITE A LINE TO THE TERMINAL.
.SP 1
TO WRITE A LINE TO THE TERMINAL, USE THE @WRITE PREPROCESSOR AS
FOLLOWS:
.SP 1
 @WRITE('HELLO THERE');
.SP 1
YOU CAN GENERATE THE MESSAGE TEXT IN AN ACCEPTABLE FORMAT FOR LATER
REFERENCE AS FOLLOWS:
.SP 1
 @WRITE(GREETING,'HELLO THERE',MF=L);
.SP 1
GREETING WILL BE THE NAME TO USE WHEN SUBSEQUENTLY REFERENCING THE
MESSAGE TEXT:
.SP 1
 @WRITE(GREETING);
.PA
***** @PUTGET - PROMPT THE TERMINAL AND GET A LINE.
.SP 1
USE @PUTGET TO FIRST WRITE A PROMPTING MESSAGE AT THE TERMINAL,
AND THEN READ A LINE FROM THE TERMINAL.  THIS IS MORE EFFICIENT THAN
FIRST USING AN @WRITE AND THEN @READ, SINCE IT REQUIRES ONLY ONE
CALL.
.SP 1
 @PUTGET(' PLEASE ENTER SECURITY CODE',CODE);
.SP 1
CODE IS A CHARACTER STRING AS IN @READ.  NOCAPS CAN ALSO BE USED IN
@PUTGET AS IN @READ.  A PREVIOUSLY DEFINED MESSAGE USING @WRITE
WITH THE MF=L OPTION CAN ALSO BE REFERENCED AS IN THE FOLLOWING:
.SP 1
.IN 5
.NF
@WRITE(PROMPT,' PLEASE ENTER CODE',MF=L);
 .
 .
 .
@PUTGET(PROMPT,CODE);
.FI L
.IN 0
.PA
***** SYMBOLIC REPLACEMENT.
.SP 1
.IN 5
.NF
DCL (DATE,TIME) BUILTIN;
@SETL(&DATE = DATE);
@SETL(&TIME = TIME);
@WRITE('DATE=&DATE, TIME=&TIME');
.FI L
.IN 0
.SP 1
THE ABOVE SEQUENCE OF PLI STATEMENTS WOULD RESULT IN A MESSAGE
CONTAINING THE CURRENT DATE AND TIME OF DAY APPEARING AT THE TSO
TERMINAL.  THIS ILLUSTRATES A FACILITY WHEREBY VARIABLE SYMBOLS,
IDENTIFIED BY AN AMPERSAND IN POSITION 1, CAN BE INSERTED INTO THE
TEXT IN AN @WRITE, @PUTGET, OR @CMD STATEMENT, TO BE REPLACED AT
EXECUTION TIME BY A VALUE ASSIGNED IN AN @SET STATEMENT.
.SP 1
VARIABLE SYMBOLS MUST BEGIN WITH AN AMPERSAND.  THE REMAINING 1 TO
7 CHARACTERS MUST BE ALPHANUMERIC.  VARIABLE SYMBOLS CAN APPEAR
ANYWHERE IN THE TEXT FOR @WRITE, @PUTGET, AND @CMD STATEMENTS.  THEY
ARE DELIMITED BY THE AMPERSAND IN FRONT AND A NON-ALPHANUMERIC
CHARACTER AT THE END.  IF TRAILING CONCATENATION WITH ALPHANUMERIC
DATA IS DESIRED, A CONNECTING PERIOD MUST BE USED
.SP 1
.IN 5
.NF
@SETL(&PRE = 'UN');
@WRITE('VARIABLE A IS &PRE.UNKNOWN);
.FI L
.IN 0
.SP 1
THE MESSAGE RECEIVED AT THE TERMINAL WOULD BE "VARIABLE A IS UNKNOWN."
IF CONCATENATION WITH A TRAILING PERIOD IS DESIRED, TWO PERIODS MUST
BE WRITTEN:
.SP 1
.IN 5
.NF
@SETL(&DSN = 'MY');
@CMD('ALLOC DA(&DSN..DATA)');
.FI L
.IN 0
.SP 1
THE COMMAND AT EXECUTION TIME WOULD BE "ALLOC DA(MY.DATA)."  NOTE
THAT IF AN AMPERSAND IS DESIRED IN THE TEXT, TWO CONTIGUOUS AMPERSANDS
MUST BE WRITTEN;  ONE WILL BE ELIMINATED AT EXECUTION TIME.
.SP 1
THERE ARE THREE KINDS OF VARIABLES;  LOCAL, GLOBAL, AND SYSTEM.
LOCAL VARIABLES ARE KNOWN ONLY TO THE CURRENT COMMAND PROCESSOR, AND
WILL BE ELIMINATED WHEN THE COMMAND PROCESSOR TERMINATES.  GLOBAL
VARIABLES ARE KNOWN TO AN ARBITRARY "INITIAL" COMMAND PROCESSOR, AND TO
ALL SUBSEQUENT COMMAND PROCESSORS INVOKED UNDER THE "INITIAL" COMMAND
PROCESSOR VIA @CMD.  YOU DETERMINE WHETHER A GIVEN COMMAND
PROCESSOR WILL BE THE "INITIAL" ONE BY SETTING THE VALUE OF
PROCESSOR SWITCH @INITGSW IN BETWEEN THE INCLUDING OF CPINIT1 AND
CPINIT2.  BY DEFAULT, THE SWITCH IS SET TO INDICATE THAT THIS WILL
BE THE "INITIAL" COMMAND PROCESSOR.  TO INDICATE OTHERWISE, USE
THE FOLLOWING SEQUENCE:
.SP 1
.IN 5
.NF
% INCLUDE CPINIT1;
% @INITGSW = 'N';
% INCLUDE CPINIT2;
.FI L
.IN 0
.SP 1
SYSTEM VARIABLES ARE ONES THAT HAVE AN IMPLIED VALUE, AND DO NOT
NEED TO BE ASSIGNED ONE THROUGH USE OF @SET.  ONLY TWO SYSTEM VARIABLES
WILL BE INITIALLY IMPLEMENTED;  &SYSUID AND &LASTCC.  REFERENCE TO
&SYSUID WILL RETURN THE CURRENT TSO SYSTEM USER IDENTIFICATION.
&LASTCC GIVES THE RETURN CODE OF THE MOST RECENTLY INVOKED COMMAND
PROCESSOR USING @CMD.  NOTE THAT THE VALUE FOR SYSTEM VARIABLES CAN
BE ALTERED EITHER LOCALLY OR GLOBALLY BY USING @SETL AND @SETG.
FOR EXAMPLE, IF THE STATEMENT
.SP 1
 @SETL(&SYSUID = 'ANYBODY');
.SP 1
IS ISSUED, ALL SUBSEQUENT REFERENCES TO &SYSUID IN THE CURRENT
COMMAND PROCESSOR WILL RETURN THE VALUE "ANYBODY".
.SP 1
THE VALUES ASSIGNED TO TEXT VARIABLES CAN BE INTERROGATED DIRECTLY
BY USING THE LCLA, LCLC, GBLA, GBLC, SYMA, AND SYMC SUBROUTINES.
THOSE ENTRY POINTS SUFFIXED WITH THE CHARACTER A WILL RETURN THE VALUE
FOR THE SPECIFIED TEXT VARIABLE AS FIXED BIN(31,0).  THOSE ENTRY
POINTS SUFFIXED WITH CHARACTER C WILL RETURN CHARACTER(100) VARYING.
THOSE ENTRY POINTS PREFIXED WITH LCL WILL SEARCH THE TABLE OF
LOCAL VARIABLES ONLY.  THOSE ENTRY POINTS PREFIXED WITH GBL WILL
SEARCH THE TABLE OF GLOBAL VARIABLES ONLY. THOSE ENTRY POINTS
PREFIXED WITH SYM WILL FIRST SEARCH THE TABLE OF LOCAL VARIABLES, THEN
THE TABLE OF GLOBAL VARIABLES.
.SP 1
EXAMPLE:
.SP 1
.IN 5
.NF
@SETL(&WEEKDAY = 'FRIDAY');
IF SYMC(&WEEKDAY) = 'FRIDAY'
 THEN @WRITE('THANK GOD, IT''S FRIDAY');
.FI L
.IN 0
.PA
***** @PROC - OBTAIN COMMAND OPERANDS
.SP 1
USE @PROC TO OBTAIN THE VALUES FOR OPERANDS THE USER SPECIFIED ON THE
COMMAND WHEN HE ENTERED IT.  FOR EXAMPLE -
.SP 1
.IN 5
@PROC(1,NAME,SIZE,DISP(KEEP));
.IN 0
.SP 1
THIS STATEMENT INDICATES THAT THE PROGRAM EXPECTS THE USER TO ENTER
ONE POSITIONAL PARAMETER AND OPTIONALLY TWO KEYWORD PARAMETERS.  IF
HE DOESN'T ENTER A VALUE FOR THE DISP KEYWORD, A DEFAULT OF "KEEP"
WILL BE SET UP.  THE VALUES FOR THESE PARAMETERS AT EXECUTION TIME
ARE ASSIGNED TO TEXT VARIABLES &NAME, &SIZE, AND &DISP.  THE VALUE
FOR KEYWORD PARAMETERS DEPENDS ON THE WAY YOU SPECIFIED YOUR @PROC
STATEMENT:  (1) KEYWORD(VALUE) MEANS THAT THE USER, IF HE SPECIFIES
THIS PARTICULAR KEYWORD, MUST FOLLOW IT WITH A PARENTHESIZED VALUE.
THIS VALUE WILL BE ASSIGNED TO THE MATCHING TEXT VARIABLE.  IF THE
USER DOESN'T SPECIFY THIS KEYWORD, THE SPECIFIED DEFAULT VALUE WILL
BE ASSIGNED TO THE MATCHING TEXT VARIABLE;  (2) KEYWORD() MEANS THE
SAME AS IN CASE 1, EXCEPT IF THE USER DOESN'T SPECIFY THIS KEYWORD,
THE DEFAULT WILL BE A NULL STRING;  (3) KEYWORD MEANS THAT THE USER
MAY SPECIFY THE KEYWORD, BUT HE IS NOT TO SPECIFY A PARENTHESIZED
VALUE.  THE MATCHING TEXT VARIABLE WILL BE SET TO THE KEYWORD NAME
IT THE KEYWORD IS SPECIFIED, AND WILL BE SET TO A NULL STRING
OTHERWISE.
.PA
***** ACCESSING THE COMMAND BUFFER.
.SP 1
SUPPOSE YOU MAKE THE FOLLOWING DECLARATION IN YOUR PLI PROGRAM:
.SP 1
.IN 5
.NF
DCL 1 CBUF BASED(CPPLCBUF),
     2 BUFLEN FIXED BIN(15,0),
     2 OFFSET FIXED BIN(15,0),
     2 BUFFER CHAR(100);
.FI L
.IN 0
.SP 1
THE POINTER CPPLCBUF WILL BE SET FOR YOU IN THE INITIALIZATION CODE
INCLUDED IN THE FRONT OF YOUR  PROGRAM
BUFFER WILL CONTAIN THE COMMAND EXACTLY AS IT
WAS ENTERED BY THE USER AT THE TERMINAL.  BUFLEN WILL CONTAIN THE
LENGTH OF THE TEXT IN BUFFER PLUS 4 FOR THE LENGTH OF FIELDS BUFLEN
AND OFFSET.  OFFSET WILL CONTAIN THE OFFSET IN BUFFER, RELATIVE 0,
TO THE FIRST BYTE OF THE FIRST PARAMETER BEYOND THE COMMAND NAME.
.PA
***** USING THE IBM SUPPLIED PARSE ROUTINE.
.SP 1
YOU MAY CHOOSE TO ACCESS THE COMMAND BUFFER DIRECTLY AS DESCRIBED
ABOVE AND PARSE THE OPERANDS OF THE COMMAND IN YOUR OWN FASHION.
OR, YOU CAN USE A PARSING ROUTINE SUPPLIED BY IBM.  THERE ARE A
NUMBER OF ADVANTAGES TO USING THIS ROUTINE.  FOR EXAMPLE, YOU CAN
EASILY SET DEFAULTS FOR SOME PARAMETERS, AND INDICATE FOR OTHERS
THAT THEY ARE REQUIRED, IN WHICH CASE, THE IBM ROUTINE WILL PROMPT THE
USER AT THE TERMINAL FOR YOU.
.SP 1
TO USE THE IBM PARSE ROUTINE YOU MUST DEFINE THE FORMAT OF THE
OPERANDS EXPECTED USING ASSEMBLER LANGUAGE MACROS.  ONLY A SUBSET
WILL BE DESCRIBED HERE;  ENOUGH TO PARSE SIMPLE KEYWORD AND
POSITIONAL PARAMETERS.  SEE SRL GC28-6764, "GUIDE TO WRITING A
TERMINAL MONITOR PROGRAM OR A COMMAND PROCESSOR" FOR INFORMATION ON
HOW TO DEFINE MORE COMPLICATED LISTS OF PARAMETERS.
 FOLLOWING IS A SAMPLE ASSEMBLER SOURCE DECK TO DEFINE ONE POSITIONAL
AND TWO KEYWORD PARAMETERS, ONE HAVING A SUBFIELD:
.SP 1
.IN 5
.NF
PCL    IKJPARM
DSN    IKJPOSIT DSNAME,PROMPT=' DSNAME'
DISP   IKJKEYWD DEFAULT='KEEP'
       IKJNAME 'KEEP'
       IKJNAME 'DELETE'
SPACE  IKJKEYWD
       IKJNAME 'CYL',SUBFLD=SPSUB
       IKJNAME 'TRK',SUBFLD=SPSUB
SPSUB  IKJSUBF
SPSUBI IKJIDENT 'SPACE',MAXLNTH=5,FIRST=NUMERIC,
                OTHER=NUMERIC,DEFAULT='1'
       IKJENDP
       END
.FI L
.IN 0
.SP 1
.SP 1
THE FIRST STATEMENT AND THE LAST TWO ARE FIXED IN FORMAT.  THE REST
MAY VARY.  POSITIONAL PARAMETERS MUST BE DEFINED FIRST, FOLLOWED BY ALL
KEYWORD PARAMETERS, FOLLOWED BY ALL SUBFIELD DEFINITIONS.
.SP 1
THE IKJPOSIT MACRO LABELLED DSN INDICATES THAT THE FIRST POSITIONAL
PARAMETER (IN THIS CASE THE ONLY POSITIONAL) WILL BE A DSNAME.  IF
THE USER DOESN'T ENTER A POSITIONAL PARAMETER, HE WILL BE PROMPTED
WITH THE MESSAGE "ENTER DSNAME."  TO ACCESS THE PARAMETER IN THE PLI
SOURCE, USE THE STATEMENT "PDEPTR=ADDR(DSN);".  THIS ADDRESSES A
CONTROL BLOCK DEFINED IN MEMBER IKJPDEDS OF SYS2.MACLIB.  THIS MEMBER
IS INCLUDED FOR YOU BY CPINIT (SEE DOCUMENTATION LATER IN THIS PAPER).
.SP 1
NOTE THAT FOLLOWING THE IKJPOSIT MACRO, OTHER IKJPOSIT AND IKJIDENT
MACROS COULD BE SPECIFIED TO DEFINE ADDITIONAL POSITIONAL PARAMETERS.
IN THIS CASE, HOWEVER, THE NEXT MACRO DEFINES A KEYWORD PARAMETER
CALLED DISP.  DISP IS THE NAME YOU WILL USE IN THE PLI SOURCE TO
REFERENCE THIS KEYWORD PARAMETER.  IT IS DEFINED AS FIXED BINARY(15,0),
AND IS SET TO A NUMBER EQUALING THE POSITION OF THE SPECIFIED KEYWORD
IN THE LIST OF IKJNAME MACROS IMMEDIATELY FOLLOWING THE IKJKEYWD MACRO.
THE IKJNAME MACROS DEFINE THE POSSIBLE KEYWORDS.  NOTE THAT IN THE
CASE OF THE DISP KEYWORD PARAMETER, IF THE USER ENTERING THE COMMAND
AT THE TERMINAL DOESN'T SPECIFY ONE OF THE POSSIBLE KEYWORDS, A DEFAULT
OF KEEP WILL BE SET UP BY THE PARSING ROUTINE.
.SP 1
THE IKJKEYWD MACRO LABELLED SPACE AND ASSOCIATED IKJNAME MACROS
ILLUSTRATE THE SITUATION WHERE DATA IS TO BE EXPECTED IN PARENTHESES
FOLLOWING THE KEYWORD.  THE IKJIDENT MACRO LABELLED SPSUBI DESCRIBES
THE EXPECTED FORMAT OF THE DATA.
.PA
***** @ALLOC - DIRECT INTERFACE TO ALLOCATION.
.SP 1
IF YOU WISH TO ALLOCATE A DATA SET, THE SIMPLEST WAY IS TO USE @CMD
TO INVOKE THE ALLOCATE TSO COMMAND.  IF, FOR EXAMPLE, YOU WISH TO READ
A FILE CALLED USERID.CONTROL.DATA, WHERE USERID IS YOUR TSO USER
IDENTIFICATION, THE FOLLOWING SEQUENCE COULD BE USED:
.SP 1
.IN 5
.NF
@CMD('FREE FI(INFILE)');
@CMD('ALLOC FI(INFILE) DA(CONTROL.DATA) SHR');
READ FILE(INFILE) INTO(RECORD);
.FI L
.IN 0
.SP 1
THIS IS INEFFICIENT FOR A NUMBER OF REASONS.  @CMD ISSUES AN ATTACH
MACRO TO INVOKE ALLOCATE.  THIS INVOLVES ADDITIONAL SYSTEM OVERHEAD.
ALSO, YOU MUST FIRST ISSUE A FREE COMMAND TO ENSURE THAT THE FILE
NAME IS NOT IN USE.  ALSO, IF THE DATA SET IS ALREADY ALLOCATED UNDER
A DIFFERENT FILE NAME,  IT WOULD BE MORE EFFICIENT IF THE DDNAME WERE
RETURNED TO YOU RATHER THAN ALLOCATING THE FILE A SECOND TIME.  THE
FOLLOWING SEQUENCE IS MORE EFFICIENT:
.SP 1
.IN 5
.NF
@ALLOC(DA(CONTROL.DATA),SHR);
OPEN FILE(INFILE) TITLE(DA08DDN);
READ FILE(INFILE) INTO(RECORD);
.FI L
.IN 0
.SP 1
FOLLOWING ARE ALL THE KEYWORD OPTIONS WHICH MAY BE SPECIFIED WITH
THE @ALLOC COMMAND:
.SP 1
.IN 5
.NF
DATASET()
FILE()
UNIT()
VOLUME()
SPACE()
DIR()
SHR/NEW/MOD/OLD
KEEP/DELETE/CATLG/UNCATLG
BLOCK()/TRKS/CYLS
RLSE
DUMMY
USING
.FI L
.IN 0
.PA
***** @FREE - DIRECT INTERFACE TO FREE A DATA SET.
.SP 1
 @FREE(FILE(INFILE));
.SP 1
ALL OF THE POSSIBLE KEYWORDS ARE
.SP 1
.IN 5
.NF
FILE()
DATASET()
SYSOUT()
PERMANENT
KEEP/DELETE/CATLG/UNCATLG
.FI L
.IN 0
.SP 1
PERMANENT SPECIFIES THAT PERMANENTLY ALLOCATED DATA SETS ARE MARKED
"NOT IN USE" BUT ARE NOT UNALLOCATED.  KEEP, DELETE, CATLG, OR UNCATLG
SPECIFY THE DISPOSITION OF THE DATA SET.  KEEP IS THE DEFAULT.
.PA
***** ABBREVIATION OF @ALLOC AND @FREE KEYWORDS.
.SP 1
NOTE THAT THE COMMAND
.SP 1
.IN 5
.NF
@FREE(F(INFILE));
@ALLOC(DA('SYS1.PROCLIB'));
.FI L
.IN 0
.SP 1
MEAN THE SAME AS
.SP 1
.IN 5
.NF
@FREE(FILE(INFILE));
@ALLOC(DATASET('SYS1.PROCLIB'));
.FI L
.IN 0
.SP 1
ANY KEYWORD OF THE @FREE AND @ALLOC COMMANDS CAN BE ABBREVIATED DOWN
TO THE POINT OF UNIQUENESS, OR ANYWHERE IN BETWEEN, UP TO THE FULL
SPELLING.
.PA
***** DAIRERR - SUBROUTINE TO HANDLE DAIR ERRORS.
.SP 1
WHEN THE @FREE AND @ALLOC COMMANDS ARE ISSUED, A CALL TO DAIR
(DYNAMIC ALLOCATION INTERFACE ROUTINE) IS GENERATED.  A VARIABLE
NAMED IKJRET (FIXED BINARY(31,0)) IS SET TO ZERO IF THE ALLOCATE OR
FREE WAS SUCCESSFUL.  IF THE RETURN CODE IS NON-ZERO, A CALL TO
SUBROUTINE DAIRERR WILL GENERATE THE APPROPRIATE ERROR MESSAGE AT
THE TERMINAL, AND WILL SIGNAL THE ERROR CONDITION.  CALL FORMAT IS
AS FOLLOWS:
.SP 1
 CALL DAIRERR(BLKPTR);
.SP 1
WHERE BLKPTR IS A POINTER VARIABLE SET TO THE ADDRESS OF THE
ALLOCATION CONTROL BLOCK PASSED TO DAIR (DAIR08 FOR ALLOCATE, AND
DAIR18 FOR FOR FREE).  THESE CONTROL BLOCKS ARE SET UP AUTOMATICALLY
BY THE PREPROCESSOR CODE.
.PA
***** HOW TO COMPILE AND EXECUTE A TSO COMMAND PROCESSOR
.SP 1
FOUR CLIST COMMANDS ARE CURRENTLY AVAILABLE:  CPPLI, CPPLIA,
CPPLIB, AND CPPLICB.  FORMATS FOR THESE FOUR COMMANDS ARE AS
FOLLOWS:
.SP 1
.IN 5
CPPLI 'SORC' 'PCL' LOAD(TEST) NAME(TEMPNAME) USERID() AT(LOCAL)
.SP 1
CPPLIA 'PCL' NAME(TEMPNAME) USERID() AT(LOCAL)
.SP 1
CPPLIB 'SORC' LOAD(TEST) NAME(TEMPNAME) USERID() AT(LOCAL)
.SP 1
CPPLICB 'SORC' LOAD(TEST) NAME(TEMPNAME) USERID() AT(LOCAL)
.SP 1
.IN 0
WHERE
.SP 1
'SORC'
.IN 5
IS THE NAME OF THE PLI SOURCE DECK FOR THE TSO COMMAND PROCESSOR.
IF THE DESCRIPTIVE QUALIFIER IS NOT PLI, THE NAME MUST BE SPECIFIED
FULLY QUALIFIED IN QUOTES.
.IN 0
'PCL'
.IN 5
IS THE NAME OF THE ASSEMBLER SOURCE DECK CONTAINING THE PARSING MACROS
(IKJPOSIT, IKJKEYWD, ETC.).
.IN 0
LOAD(TEST)
.IN 5
IS THE NAME OF THE LOAD LIBRARY INTO WHICH THE LINKEDITED COMMAND
PROCESSOR IS TO BE PLACED.  THE DEFAULT IS TEST.LOAD (THE DESCRIPTIVE
QUALIFIER LOAD SHOULD NOT BE SPECIFIED; IT IS THE DEFAULT).
.IN 0
NAME(TEMPNAME)
.IN 5
SPECIFIES THE LOAD MODULE NAME, AND ALSO SPECIFIES THE NAME TO USE WHEN
CREATING A DATA SET WITH NAME OF THE FORM &NAME..OBJ.  THE DEFAULT IS
TEMPNAME.
.IN 0
USERID()
.IN 5
SPECIFIES YOUR TSO USER IDENTIFICATION.
.IN 0
AT(LOCAL)
.IN 5
SPECIFIES THE LOCATION AT WHICH ANY GENERATED LISTINGS ARE TO BE
PRINTED.
.IN 0
.SP 1
CPPLI WILL ASSEMBLE THE PARSING MACROS, COMPILE THE PLI SOURCE AND
LINKEDIT THE OBJECT TEXT.
.SP 1
CPPLIA WILL ONLY ASSEMBLE THE PARSING MACROS, PLACING THE OUTPUT,
(PLI DECLARE STATEMENTS FOR PARAMETER DESCRIPTOR LIST (PDL) AND
OBJECT TEXT FOR THE PARSING CONTROL LIST (PCL)) INTO A NEWLY CREATED
PARTITIONED DATA SET WITH A NAME OF THE FORM &NAME..OBJ.
.SP 1
CPPLIB WILL COMPILE THE PLI SOURCE PROGRAM, LINKEDIT THE COMMAND
PROCESSOR. CPPLIB EXPECTS THAT CPPLIA HAS BEEN RUN, CREATING DATA SET
&NAME..OBJ.
.SP 1
CPPLICB WILL COMPILE THE PLI SOURCE PROGRAM USING THE CHECKOUT
COMPILER INSTEAD OF THE OPTIMIZER, LINKEDIT THE OBJECT TEXT.
CPPLIA MUST HAVE BEEN EXECUTED BEFOREHAND.  IN
ORDER TO USE THIS OPTION, YOU MUST HAVE USED THE FOLLOWING SEQUENCE IN
YOUR PLI SOURCE:
.SP 1
.IN 5
.NF
% INCLUDE CPINIT1;
% @CMP = 'C';
% INCLUDE CPINIT2;
