 /* UNCATLG
0*$.HE GENERALIZED UTILITIES - UNCATLG
0*$.HE UNCATLG UTILITY PROGRAM
0*$.PL 55
0*$.PN 0
0*$.PA
0*$.SS
0*$.NF
0*$6/6/74
0*$AUTHOR:  T. SMITH
0*$SOURCE MODULE NAME:  UNCATLG
0*$DOCUMENTATION ID:  0*$
0*$.FI L
0*$.SP 5
0*$THE UNCATLG UTILITY PROGRAM PERMITS THE USER TO UNCATALOG ALL DATA
0*$SETS AND DELETE ALL INDEXES BELOW A SPECIFIED INDEX LEVEL.
0*$.SP 1
0*$.IN 5
0*$.NF
0*$// EXEC PGM=UNCATLG,PARM='NAME1,CVOL=VOLSER'
0*$//SYSPRINT DD SYSOUT=A
0*$//SYSIN DD *
0*$NAME2,CVOL=VOLSER
0*$NAME3,CVOL=VOLSER
0*$ .
0*$ .
0*$ .
0*$NAMEN,CVOL=VOLSER
0*$.IN 0
0*$.FI L
0*$.SP 1
0*$NAME1, NAME2, NAME3, ..., NAMEN ARE ALL QUALIFIED NAMES, EACH OF
0*$WHICH REPRESENTS EITHER AN INDEX LEVEL OR A FULLY QUALIFIED
0*$DATA SET NAME.  IF A NAME REPRESENTS A FULLY QUALIFIED DATA SET NAME,
0*$THE UTILITY PROGRAM WILL UNCATALOG IT.  IF A NAME REPRESENTS AN INDEX
0*$LEVEL, THE UTILITY PROGRAM WILL FIRST UNCATALOG ALL DATA SETS AND
0*$INDEX LEVELS BELOW THE SPECIFIED INDEX LEVEL, AND THEN WILL DELETE
0*$THE SPECIFIED INDEX LEVEL.
0*$.SP 1
0*$"CVOL=VOLSER" IN THE ABOVE FORMAT DESCRIPTION IS OPTIONAL.
0*$IF SPECIFIED, THE UNCATLG UTILITY WILL PERFORM ITS FUNCTIONS
0*$ON NAMES AND INDEX LEVELS IN THE CATALOG ON THE SPECIFIED
0*$VOLUME, RATHER THAN GOING THROUGH THE NORMAL PROCEDURE OF
0*$SEARCHING THE SYSTEM RESIDENT CATALOG AND/OR ANY CATALOGS
0*$ASSOCIATED WITH THE SYSTEM RESIDENT CATALOG VIA CONNECT FUNCTION.
0*$.SP 1
0*$SPECIFYING A SYSIN DATA SET IS OPTIONAL.  IF YOU HAVE ONLY ONE NAME
0*$TO ENTER, IT MAY BE ENTERED VIA THE PARM FIELD ON THE EXEC CARD.
0*$NOTE ALSO THAT SPECIFYING THE FIRST OR ONLY NAME VIA THE PARM
0*$FIELD IS ALSO OPTIONAL.  ALL NAMES, INCLUDING THE FIRST, CAN BE
0*$ENTERED VIA THE SYSIN DATA SET.
0*$.SP 1
0*$AN ADDITIONAL DD STATEMENT IS REQUIRED IF THE SYSTEM CATALOG IN WHICH
0*$THE SPECIFIED INDEX LEVELS AND/OR DATA SETS ARE CATALOGED IS NOT
0*$NORMALLY MOUNTED.  THIS STATEMENT TAKES THE FOLLOWING FORM:
0*$.SP 1
0*$.IN 5
0*$//ANYNAME DD UNIT=3330,VOL=SER=VOLSER,DISP=OLD
0*$.IN 0
0*$.SP 1
0*$.CE 1
0*$EXAMPLE
0*$.SP 1
0*$SUPPOSE TWO SYSTEMS ARE SHARING THE SAME SYSTEM CATALOG.  ALL DATA
0*$SET NAMES FOR SYSTEM A BEGIN WITH THE INDEX QUALIFIER SYSA, AND ALL
0*$DATA SET NAMES FOR SYSTEM B BEGIN WITH THE INDEX QUALIFIER SYSB.
0*$EACH SYSTEM, AS PART OF ITS STANDARD BACKUP PROCEDURE, EXECUTES A
0*$JOB STEP SIMILAR TO THE ONE BELOW:
0*$.SP 1
0*$.IN 5
0*$.NF
0*$// EXEC PGM=IEHMOVE
0*$//SYSPRINT DD SYSOUT=A
0*$//SYSUT1 DD VOL=REF=SYS1.WORK1,DISP=OLD
0*$//CTLG DD UNIT=3330,VOL=SER=SYSCTG,
0*$// DISP=OLD
0*$//TAPE DD DSN=BACKUP,DISP=(NEW,KEEP),
0*$// UNIT=TAPE,VOL=SER=BACKUP,
0*$// DCB=(LRECL=80,BLKSIZE=800,RECFM=FB)
0*$//SYSIN DD *
0*$ COPY CATALOG=SYSA,TO=2400-3=BACKUP,
0*$         CVOL=3330=SYSCTG,TODD=TAPE
0*$(NOTE:  FOR SYSTEM B, IT WOULD BE
0*$COPY CATALOG=SYSB)
0*$/*
0*$.IN 0
0*$.FI L
0*$.SP 1
0*$THIS STEP WILL CAUSE ONLY CATALOG ENTRIES WHOSE NAMES ARE
0*$QUALIFIED BY SYSA (OR SYSB, WHICHEVER THE CASE MAY BE), TO
0*$BE UNLOADED TO TAPE.
0*$.SP 1
0*$NOW SUPPOSE THAT A MACHINE FAILURE OCCURS DURING THE
0*$EXECUTION OF SYSTEM A, REQUIRING THAT A RERUN BE MADE.
0*$TO RESTORE THE CATALOG BACK TO THE WAY IT WAS BEFORE THE
0*$RUN WAS MADE, THE FOLLOWING JCL COULD BE EXECUTED:
0*$.SP 1
0*$.IN 5
0*$.NF
0*$// EXEC PGM=UNCATLG,PARM=SYSA
0*$//SYSPRINT DD SYSOUT=A
0*$// EXEC PGM=IEHMOVE
0*$//SYSPRINT DD SYSOUT=A
0*$//SYSUT1 DD VOL=REF=SYS1.WORK1,DISP=OLD
0*$//CTLG DD UNIT=3330,VOL=SER=SYSCTG,
0*$// DISP=OLD
0*$//TAPE DD DSN=BACKUP,DISP=OLD,UNIT=TAPE,
0*$// VOL=SER=BACKUP
0*$//SYSIN DD *
0*$ COPY CATALOG,TO=3330=SYSCTG,
0*$          FROM=2400-3=BACKUP,
0*$          FROMDD=TAPE
********************************************************************/
 DCTLG.. PROC(PARM) OPTIONS(MAIN),.
         // INCLUDE CTLGDEF,.
         DCL IHESARC ENTRY(FIXED BIN(31,0)),.
         DCL PARM CHAR(100) VARYING,.
         DCL PAGE FIXED BIN(15,0) STATIC INIT(0),.
         DCL ROMAN ENTRY (FIXED BIN) RETURNS(CHAR(15) VARYING),.
         DCL DTE CHAR(6),.
         DTE = DATE,.
         DCL RETCODE FIXED BIN(31,0) STATIC INIT(0),.
 ON ENDPAGE(SYSPRINT) BEGIN,.
         PUT PAGE,.
         PAGE = PAGE + 1,.
         PUT EDIT('PAGE ', ROMAN(PAGE), 'MARINE BANK UNCATLG UTILITY PRO
 GRAM','DATE=', DTE)(A,A,X(10),A,X(10),A,A),.
         PUT SKIP(2),.
         END,.
         SIGNAL ENDPAGE(SYSPRINT),.
 ON CONDITION(CTLGERR) BEGIN,.
         CALL TROUT(RETC,RETP),.
         PUT EDIT('ERROR ENCOUNTERED WHILE ACCESSING CATALOG=',RETP)
           (A,A) SKIP(1),.
         SIGNAL ERROR,.
          END,.
 ON ERROR BEGIN,.
         RETCODE = 16,.
         CALL IHESARC(RETCODE),.
         CALL IHEDUMT,.
         END,.
         DCL ((NXFIRST, NXLAST) BIT(1),
               DDNAME CHAR(8)) EXT,.
         NXFIRST = '1'B,.
         NXLAST = '0'B,.
         DO WHILE(NXLAST = '0'B),.
              CALL D10201C,.
              IF DDNAME = 'SYSIN'
                   THEN INSW = '1'B,.
              END,.
         DCL INCARD CHAR(80) STATIC,.
         INCARD = PARM,.
         DCL INA(80) CHAR(1) DEF INCARD,.
         ON ENDFILE(SYSIN) GO TO EOJ,.
         DCL DSN  CHAR(44) VARYING STATIC,.
         DCL CVOL CHAR(6) STATIC INIT('SYSRES'),.
         DCL PTRFIX FIXED BIN(31,0) DEF CTLGPTR,.
         DCL 1 BINONB STATIC UNALIGNED,
              2 B1 BIT(63) INIT('0'B),
              2 B2 BIT(1) INIT('1'B),.
         DCL BINONE CHAR(8) DEF BINONB,.
         DCL RETB FIXED BIN(31,0) STATIC,.
         DCL RET BIT(32) DEF RETB,.
         DCL REG15 BIT(8) DEF RETB,.
         DCL RETC CHAR(4) DEF RETB,.
         DCL RETP CHAR(8),.
         DCL 1 MFLGS UNALIGNED STATIC,
              2 MALSW BIT(1) INIT('0'B),
              2 MGSW BIT(1) INIT('0'B),.
         DCL MTTR CHAR(3),.
         DCL 1 ABND,
              2 DUM BIN FLOAT(53),
              2 MAREA CHAR(265),.
         DCL INSW BIT(1) STATIC INIT('0'B),.
         IF INA(1) NE ' '
              THEN GO TO PRODSN,.
 READ..
         IF INSW
              THEN READ FILE(SYSIN) INTO(INCARD),.
              ELSE RETURN,.
 PRODSN..
         CTLGPTR = ADDR(MAREA),.
         PTRFIX = PTRFIX + 2,.
         PUT EDIT('CONTROL CARD = ',INCARD)(A,A) SKIP(1),.
         DO I = 1 TO 80,.
              IF INA(I) NE ' '
                   THEN GO TO FRONT,.
              END,.
         GO TO READ,.
 FRONT..
         DO J = I TO 80 WHILE((INA(J) NE ' ') AND (INA(J) NE ',')),.
              END,.
         L = J - I,.
         DSN = SUBSTR(INCARD,I,L),.
         IF INA(J) = ' '
              THEN CVOL = 'SYSRES',.
              ELSE CVOL = SUBSTR(INCARD,J+6,6),.
         CALL SYSCTLG('NAME',RET,DSN,CVOL,MAREA),.
         CVOL = SUBSTR(MAREA,260,6),.
         IF RETB = 0
              THEN DO,.
                   CALL SYSCTLG('UNCAT',RET,DSN,CVOL),.
                   IF RETB NE 0
                        THEN SIGNAL CONDITION(CTLGERR),.
                   PUT EDIT('DSNAME = ',DSN,', UNCATALOGED')(A,A,A)
                     SKIP(1),.
                   GO TO READ,.
                   END,.
         IF REG15 = '00011000'B
              THEN SIGNAL CONDITION(CTLGERR),.
         IF REG15 NE '00001100'B
              THEN DO,.
                   CALL IHESARC(12),.
              CALL TROUT(RETC,RETP),.
              PUT EDIT('CONTROL STATEMENT ERROR=',RETP)
                (A,A) SKIP(1),.
                   GO TO READ,.
                   END,.
         CALL RECURS(INDLO,MFLGS),.
         GO TO READ,.
 RECURS.. PROC(PTTR,PFLGS) RECURSIVE,.
         DCL SAVPTR PTR,.
         DCL PTTR CHAR(3),.
         DCL 1 PFLGS UNALIGNED,
              2 PALSW BIT(1),
              2 PGDGSW BIT(1),.
         DCL 1 FLGS UNALIGNED,
              2 ALSW BIT(1) INIT('0'B),
              2 GDGSW BIT(1) INIT('0'B),.
         DCL 1 ABND,
              2 DUM BIN FLOAT(50),
              2 AREA,
               3 BLK CHAR(256),
               3 ATTR CHAR(3),
               3 ACVOL CHAR(6),.
         DCL TTRC CHAR(3),.
         DCL N FIXED BIN(15,0),.
         DCL 1 GDGNAM BASED(CTLGPTR),
              2 GDGG CHAR(1),
              2 GDGNUM BIT(32),.
         TTRC = PTTR,.
 NEWBLK..
         CALL SYSCTLG('BLOCK',RET,TTRC,CVOL,AREA),.
         IF RETB NE 0
              THEN SIGNAL CONDITION(CTLGERR),.
         CTLGPTR = ADDR(AREA),.
         PTRFIX = PTRFIX + 2,.
 NEWENT..
         IF NAME = HIGH(8)
              THEN IF TTR = LOW(3)
                   THEN IF PALSW
                        THEN RETURN,.
                        ELSE DO,.
                             CALL SYSCTLG('DLTX',RET,DSN,CVOL),.
                             IF RETB NE 0
                                  THEN SIGNAL CONDITION(CTLGERR),.
                             PUT EDIT('INDEX  = ',DSN,', DELETED')
                               (A,A,A) SKIP(1),.
                             RETURN,.
                             END,.
                   ELSE GO TO NEWBLK,.
         IF HCNT GT '00000010'B AND HCNT LT '00000110'B
              THEN GO TO GETENT,.
         IF SUBSTR(GDGNUM,1,8) GT '00000101'B
           AND SUBSTR(GDGNUM,1,8) LT '00010000'B
              THEN GDGNUM = NOT GDGNUM,.
         DO N = 1 TO 8 WHILE(SUBSTR(NAME,N,1) NE ' '),.
              END,.
         DSN = DSN CAT '.' CAT SUBSTR(NAME,1,N-1),.
         IF HCNT GT '00000101'B OR HCNT = '00000001'B
              THEN GO TO UNCATLG,.
         SAVPTR = CTLGPTR,.
         CALL RECURS(TTR,FLGS),.
         CTLGPTR = SAVPTR,.
 UNCAT..
         DSN = SUBSTR(DSN,1,LENGTH(DSN) - N),.
         GO TO GETENT,.
 UNCATLG..
         CALL SYSCTLG('UNCAT',RET,DSN,CVOL),.
         IF RETB NE 0
              THEN SIGNAL CONDITION(CTLGERR),.
         PUT EDIT('DSNAME = ',DSN,', UNCATALOGED')(A,A,A) SKIP(1),.
         GO TO UNCAT,.
 GETENT..
         PTRFIX = PTRFIX + 12 + 2*HCNT,.
         GO TO NEWENT,.
         END RECURS,.
 EOJ..
         END DCTLG,.
