* RNDGN
*$.HE GENERALIZED SUBROUTINES - RNDGN
*$.HE RANDOM NUMBERS FROM A NORMAL DISTRIBUTION
*$.PL 55
*$.PN 0
*$.PA
*$.SS
*$.NF
*$09/17/76
*$AUTHOR:  HAROLD WRIGHT, HUGHES AIRCRAFT
*$SOURCE MODULE NAME:  RNDGN
*$DOCUMENTATION ID:  *$
*$.FI L
*$.SP 5
*$THIS SUBROUTINE GENERATES RANDOM NUMBERS FROM A GAUSSIAN
*$(NORMAL) DISTRIBUTION HAVING ZERO MEAN AND UNIT STANDARD
*$DEVIATION.  THE NUMBERS GENERATED ARE IN THE RANGE FROM
*$06 TO +6.  CALL FORMAT IS AS FOLLOWS:
*$.IN 5
*$.SP 1
*$.NF
*$CALL RNDGN(I,Y,N)
*$.SP 1
*$WHERE:
*$.FI L
*$.HI 5
*$Y IS THE FLOATING POINT ARRAY WHERE THE SEQUENCE OF RANDOM NUMBERS
*$WILL BE STORED.  THIS ARRAY MUST BE DIMENSIONED AT LEAST N.
*$.SP 1
*$I IS AN INTEGER VARIABLE INITIALIZED BY THE USER AND USED BY THE
*$ROUTINE TO GENERATE THE RANDOM NUMBERS.
*$.SP 1
*$N IS THE NUMBER OF RANDOM NUMBERS TO BE GENERATED AND TO BE
*$STORED INTO THE ARRAY Y.
*$.HI 0
*$.IN 0
*$.SP 1
*$TO GENERATE ONE SEQUENCE OF RANDOM NUMBERS USING THE FUNCTION
*$RNDG, INITIALIZE I AND GENERATE THE FIRST NUMBER IN THE SEQUENCE
*$BY A STATEMENT OF THE FORM Y = RNDG(I).  THEN, WITHOUT REVISING
*$I, GENERATE SUBSEQUENT NUMBERS IN THE SEQUENCE BY REPEATED
*$FUNCTIONAL REFERENCES TO RNDG(I).  SEE EXAMPLE(1).
*$.SP 1
*$TO GENERATE SEVERAL SEQUENCES OF RANDOM NUMBERS USING THE FUNCTION
*$RNDG:  BY USING DISTINCTLY NAMED VARIABLES FOR THE ARGUMENT AND
*$DISTINCTLY INITIALIZING EACH, THE USER MAY GENERATE SEVERAL
*$DISTINCT SEQUENCES OF RANDOM NUMBERS, EACH SEQUENCE INITIALIZED
*$AND GENERATED AS DESCRIBED IMMEDIATELY PRECEDING.  AS BEFORE,
*$THE VARIABLES MUST NOT BE CHANGED WHILE A SEQUENCE IS BEING
*$GENERATED.
*$.SP 1
*$RESTRICTION:  I MUST BE IN INTEGER VARIABLE INITIALIZED TO A
*$POSITIVE VALUE.
*$.SP 1
*$EXAMPLE:
*$.SP 1
*$TO GENERATE A SEQUENCE OF 500 RANDOM NUMBERS AND A DISTINCT
*$SEQUENCE OF 250 RANDOM NUMBERS EACH SEQUENCE BEING N(0.,1.):
*$.SP 1
*$.NF
*$.IN 5
*$DIMENSION Y(500),Z(250)
*$I1 = 33
*$I2 = 635
*$CALL RNDGN(I1,Y,500)
*$CALL RNDGN(I2,Z,250)
*$ .
*$ .
*$ .
RNDGN    CSECT CONTROL SECTION FOR FLOATING-POINT NUMBER.
         USING RNDGN,15 ESTABLISH BASE REGISTER
         STM   14,12,12(13)   SAVE REGISTERS
         LM    1,3,0(1)      ADDRESS OF PARAMETERS
         LR    5,1
         L     3,0(3)        3 = NUMBER
LOOP1    LD    0,=D'0.0'     ZERO
         STD   0,TEMP1       CLEAR TEMPORARY ACCUMULATOR
         LA    4,12(0)       INDEX
LOOP     EQU   *
         L     1,0(5)   PICK UP X(N)
         M     0,=F'16807'  X(N+1)=K*X(N) MOD(2**31-1)  K=7**5=16807
         SLDA  0,1 ISOLATE HIGH ORDER 31 BITS (R).
         SRL   1,1 ISOLATE LOW ORDER 31 BITS. SIGN +.
         AR    0,1 X'(N+1) = K*X(N) + R (LOW ORDER 31 BITS).
         BO    OVF X'(N+1) OVERFLOW.
CONT     ST    0,0(5)   STORE X(N+1)
         SR    1,1 ZERO LOW ORDER DOUBLEWORD.
         SRDA  0,7 MAKE PCOM FOR MASK.
         A     0,=X'40000000' MASK IN FLOATING-POINT EXPONENT.
         STM   0,1,TEMP STORE UNNORMALIZED DOUBLEWORD TEMPORARILY.
         SDR   0,0 CLEAR LOW-ORDER DOUBLE FLOATING-POINT REG.
         AD    0,TEMP PLACE NORMALIZED DOUBLEWORD FLOATING-POINT       X
               NUMBER IN FLOATING-POINT REGISTER 0.
         AD    0,TEMP1       ADD ACCUMULATOR
         STD   0,TEMP1       NEW ACCUMULATOR
         BCT   4,LOOP        TEST FOR DONE
         SD    0,=D'6.0'     MINUS 6
         STE   0,0(2)        VALUE TO ARRAY
         LA    2,4(2)        BUMP ARRAY
         BCT   3,LOOP1       TEST FOR DONE
         LM    14,12,12(13)   RESTORE REGISTERS
         MVI   12(13),X'FF'   SET RETURN INDICATOR
         BR    14 RETURN TO FORTRAN.
OVF      SLL   0,1 SIGN BIT +.
         SRL   0,1 SIGN BIT +.
         A     0,=F'1' ADD 1 TO GET X'(N+1) + 1.
         B     CONT RETURN TO MAIN CODING TO FINISH.
TEMP     DS    D TEMPORARY STORAGE ON DOUBLEWORD BOUNDARY FOR SPEED.
TEMP1    DS    D             TEMPORARY ACCUMULATOR
         LTORG FORCE LITERAL ASSEMBLY INTO THIS CONTROL SECTION.
         END
