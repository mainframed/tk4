 /* EVAL */
 /*
0*$.HE GENERALIZED SUBROUTINES - EVAL
0*$.HE EVALUATE A POLISH EXPRESSION
0*$.PL 55
0*$.PN 0
0*$.PA
0*$.SS
0*$.NF
0*$06/30/82
0*$AUTHOR:  T. SMITH
0*$SOURCE MODULE NAME: EVAL
0*$DOCUMENTATION ID: 0*$
0*$.FI L
0*$.SP 5
0*$THIS SUBROUTINE MAY BE USED TO EVALUATE AN ARITHMETIC EXPRESSION
0*$EXPRESSED IN POLISH NOTATION.  SEE ALSO DOCUMENTATION ON
0*$THE SCANNER AND POLISH SUBROUTINES, THE THE CALC TSO COMMAND
0*$PROCESSOR.
0*$.SP 1
0*$CALL FORMAT IS AS FOLLOWS:
0*$.SP 1
0*$.IN 5
0*$VALUE=EVAL(NEWHDR,MSG,FUNCTION,DO_OPERATOR,GET_OPERAND);
0*$.IN 0
0*$.SP 1
0*$WHERE -
0*$.SP 1
0*$VALUE IS FLOAT DEC(16), AND WILL CONTAIN THE RESULT FROM
0*$EVALUATING THE POLISH EXPRESSION.
0*$.SP 1
0*$NEWHDR IS A PTR, AND SHOULD BE SET BY THE CALLER TO THE QUEUE
0*$OF TOKEN STRUCTURES DESCRIBING THE POLISH EXPRESSION.  FOR A
0*$DETAILED DESCRIPTION OF THIS QUEUE AND THE STRUCTURES IT CONTAINS
0*$SEE DOCUMENTATION ON THE POLISH SUBROUTINE.
0*$.SP 1
0*$MSG IS CHAR(80) VAR, AND WILL BE SET TO '' BY EVAL IF NO ERRORS
0*$ARE ENCOUNTERED DURING THE EVALUATION OF THE EXPRESSION.  OTHERWISE
0*$AN ERROR MESSAGE WILL BE STORED HERE.
0*$.SP 1
0*$FUNCTION IS DECLARED 'ENTRY(CHAR(80) VAR, FIXED BIN(15,0),PTR,PTR,)
0*$RETURNS(FLOAT DEC(16))'.  THIS ENTRY POINT IS SUPPLIED BY THE CALLER
0*$TO PROCESS ANY FUNCTION REFERENCES (E.G. SIN(45)) ENCOUNTERED IN
0*$THE EXPRESSION.  A SAMPLE CALL MIGHT BE -
0*$.SP 1
0*$.IN 5
0*$VALUE=FUNCTION(MSG,PARMCNT,TOKPTR,STACK,POP)
0*$.SP 1
0*$WHERE -
0*$.SP 1
0*$VALUE IS FLOAT DEC(16), AND SHOULD BE SET BY PROCEDURE FUNCTION TO
0*$THE VALUE RESULTING FROM THE FUNCTION REFERENCE. SIN(3.14159/4)
0*$FOR EXAMPLE, SHOULD RESULT IN 7.07106E-01.
0*$.SP 1
0*$MSG IS CHAR(80) VAR, AND SHOULD BE SET BY PROCEDURE FUNCTION TO
0*$AN ERROR MESSAGE DESCRIBING ANY ERROR ENCOUNTERED BY THE FUNCTION.
0*$NOTE THAT IF AN ERROR SHOULD OCCUR, PROCEDURE FUNCTION CAN STOP
0*$ANY FURTHER PROCESSING OF THE EXPRESSION BY SIGNALLING
0*$CONDITION(BADEXP).
0*$.SP 1
0*$PARMCNT IS FIXED BIN(15,0), AND WILL CONTAIN A COUNT OF PARAMETERS
0*$IN THE FUNCTION REFERENCE.  IN THE CASE OF MOD(3,2) FOR EXAMPLE,
0*$PARMCNT WILL BE SET TO 2.
0*$.SP 1
0*$TOKPTR IS PTR POINTING TO THE TOKEN STRUCTURE DESCRIBING THE
0*$FUNCTION NAME.  SEE DOCUMENTATION ON THE POLISH SUBROUTINE FOR
0*$A DETAILED DESCRIPTION OF THIS TOKEN STRUCTURE.  USING THE
0*$NAMES DESCRIBED THERE, IF THE FUNCTION REFERENCE WERE MOD(3,2),
0*$THEN TOKPTR->TOKSTR WOULD CONTAIN 'MOD'.
0*$.SP 1
0*$STACK POINTS TO ELEMENTS CONTAINING POINTERS TO TOKEN DESCRIPTORS
0*$DESCRIBING THE PARAMETERS TO THE FUNCTION.  SEE THE DESCRIPTION
0*$OF PARAMETER POP BELOW FOR MORE INFORMATION ABOUT THE STACK.
0*$.SP 1
0*$POP IS AN ENTRY POINT SUPPLIED BY PROCEDURE EVAL, AND SHOULD BE
0*$USED BY YOUR FUNCTION PROCEDURE TO POP PARAMETERS FROM THE STACK.
0*$A TYPICAL INVOCATION OF POP WOULD BE -
0*$.SP 1
0*$.IN 10
0*$VALUE = POP(MSG,STACK,GET_OPERAND)
0*$.SP 1
0*$WHERE -
0*$.SP 1
0*$VALUE IS FLOAT DEC(16), AND WILL BE SET BY POP TO THE PARAMETER
0*$VALUE POPPED FROM THE STACK.  IN THE CASE OF FUNCTION REFERENCE
0*$MOD(3*9,2) FOR EXAMPLE, THE FIRST INVOCATION OF POP WILL RETURN
0*$THE VALUE 27, AND THE SECOND INVOCATION THE VALUE 2.
0*$.SP 1
0*$MSG IS CHAR(80) VAR, AND MAY BE SET BY POP TO A MESSAGE IF AN ERROR
0*$IS ENCOUNTERED.  IN THE CASE OF AN ERROR, POP WILL ALSO SIGNAL
0*$CONDITION(BADEXP).
0*$.SP 1
0*$STACK IS DECLARED PTR, AND IS THE STACK FROM WHICH
0*$PARAMETERS ARE TO BE POPPED.
0*$.SP 1
0*$GET_OPERAND IS A PROCEDURE WHICH YOUR FUNCTION PROCEDURE MUST
0*$SUPPLY.  GIVEN AS A PARAMETER THE ADDRESS OF THE TOKEN STRUCTURE
0*$DESCRIBING A VARIABLE NAME, GET_OPERAND MUST RETURN THE VALUE
0*$CURRENTLY ASSIGNED TO THAT VARIABLE.  SUPPOSE GET_OPERAND IS
0*$CALLED WITH A TOKEN STRUCTURE DESCRIBING VARIABLE NAMED 'A',
0*$WHICH CURRENTLY IS ASSIGNED THE VALUE 23.45.  THEN GET_OPERAND
0*$SHOULD RETURN 23.45.  CALL FORMAT IS AS FOLLOWS:
0*$.SP 1
0*$.IN 15
0*$VALUE = GET_OPERAND(TOKPTR);
0*$.SP 1
0*$VALUE IS FLOAT DEC(16).
0*$.SP 1
0*$TOKPTR IS A PTR POINTING TO A TOKEN STRUCTURE AS DESCRIBED IN THE
0*$DOCUMENTATION FOR SUBROUTINE POLISH.  AS INDICATED PREVIOUSLY,
0*$THIS TOKEN STRUCTURE SHOULD DESCRIBE A VARIABLE NAME.
0*$.SP 1
0*$.IN 0
0*$DO_OPERATOR IS DECLARED 'ENTRY CHAR(80) VAR,PTR,PTR,)
0*$RETURNS(FLOAT DEC(16))'.  THIS ENTRY POINT IS SUPPLIED BY THE CALLER
0*$TO PROCESS ALL OPERATORS ENCOUNTERED IN THE EXPRESSION
0*$(E.G 5+4).  A SAMPLE CALL MIGHT BE -
0*$.SP 1
0*$.IN 5
0*$VALUE=DO_OPERATOR(MSG,TOKPTR,STACK,POP)
0*$.SP 1
0*$WHERE -
0*$.SP 1
0*$VALUE IS FLOAT DEC(16), AND SHOULD BE SET BY DO_OPERATOR TO THE
0*$RESULTS OF APPLYING THE OPERATOR TO ITS OPERANDS. IF THE OPERATOR
0*$IS '+' AND THE OPERANDS AND 5 AND 3, THEN DO_OPERATOR SHOULD RETURN
0*$8.
0*$.SP 1
0*$MSG IS CHAR(80) VAR, AND SERVES EXACTLY THE SAME PURPOSE AS IT
0*$DOES FOR PROCEDURE FUNCTION DESCRIBED PREVIOUSLY.
0*$.SP 1
0*$TOKPTR IS PTR, AND POINTS TO THE TOKEN DESCRIPTOR DESCRIBING THE
0*$OPERATOR.
0*$.SP 1
0*$STACK IS DECLARED PTR, AND IS THE OPERAND STACK.
0*$.SP 1
0*$POP IS AN ENTRY POINT SUPPLIED BY EVAL, AND IS USED TO POP
0*$OPERANDS FROM THE STACK.  IT IS DESCRIBED ABOVE UNDER THE
0*$FUNCTION PROCEDURE.
0*$.SP 1
0*$.IN 0
0*$GET_OPERAND IS DESCRIBED ABOVE UNDER THE FUNCTION PROCEDURE.
 */
 EVAL: PROC(NEWHDR,MSG,FUNCTION,DO_OPERATOR,GET_OPERAND)
   RETURNS(FLOAT DEC(16)) RECURSIVE OPTIONS(REENTRANT);
 /**********************************************************************
 * THIS SUBROUTINE IS CALLED TO EVALUATE THE POLISH EXPRESSION POINTED *
 * TO BY NEWHDR.                                                       *
 **********************************************************************/
   DCL NEWHDR PTR; /* PTR TO POLISH EXPRESSION */
   DCL MSG CHAR(80) VAR;
   DCL FUNCTION ENTRY(CHAR(80) VAR,FIXED BIN(15,0),PTR,PTR,)
     RETURNS(FLOAT DEC(16));
   DCL DO_OPERATOR ENTRY(CHAR(80) VAR,PTR,PTR,)
     RETURNS(FLOAT DEC(16));
   DCL GET_OPERAND ENTRY(CHAR(80) VAR,PTR)
     RETURNS(FLOAT DEC(16));
   DFT RANGE(*) FIXED BIN VALUE(FIXED BIN(31,0));
   DCL OPERAND          INIT(0) FIXED STATIC;
   DCL OPERATOR         INIT(1) FIXED STATIC;
   DCL KEYWORD          INIT(2) FIXED STATIC;
   DCL TYPE_SPCHAR      INIT(3) FIXED STATIC;
   DCL QUOTED_STRING    INIT(4) FIXED STATIC;
   DCL NUMERIC_CONSTANT INIT(5) FIXED STATIC;
   DCL NO_MORE_TOKENS   INIT(6) FIXED STATIC;
   DCL OTHER            INIT(7) FIXED STATIC;
   DCL FUNCTION_A       INIT(8) FIXED STATIC;
   DCL TEMPORARY        INIT(9) FIXED STATIC;
   DCL FUNCTION_B       INIT(10) FIXED STATIC;
   DCL HEX_STRING       INIT(11) FIXED STATIC;
   DCL ASSIGNMENT       INIT(17) FIXED STATIC;
   DCL 1 TOKEN BASED(TOKPTR),
     2 PRIOR_TOKEN PTR,
     2 NEXT_TOKEN PTR,
     2 ELIX FIXED BIN(15,0),
     2 TYPE FIXED BIN(15,0),
     2 SUBTYPE FIXED BIN(15,0),
     2 TOKSTR CHAR(256) VAR;
   DCL 1 TOKEN2 BASED(TOKPTR),
     2 PAD CHAR(12),
     2 TEMPVALUE FLOAT DEC(16);
   DCL 1 TOKEN3 BASED(TOKPTR),
     2 PAD CHAR(16),
     2 HEXVALUE FLOAT DEC(16);
   DCL NULL BUILTIN;
   DCL (STACK,DUMMY) PTR;
   DCL 1 STACKEL BASED(STACKPTR),
     2 STACKNEXT PTR,
     2 STACKELP PTR;
   DCL SW BIT(1);
   DCL SAVE PTR;
   DCL RET DEC FLOAT(16);
   DCL PARMSTACK PTR;
   DCL 1 PARMSTACKEL BASED(PARMSTACKPTR),
     2 PARMSTACKNEXT PTR,
     2 PARMSTACKELP FIXED BIN(15,0);
   DCL PARMCNT FIXED BIN(15,0) INIT(0);

   PARMSTACK,STACK,DUMMY=NULL;
   MSG='';
   ALLOCATE STACKEL;
   DUMMY=STACKPTR;
   STACKNEXT,STACKELP=NULL;
   ON CONDITION(BADEXP) GO TO CLEANUP;
   ON ERROR BEGIN;
     ON ERROR SYSTEM;
     MSG='ERROR CONDITION RAISED';
     GO TO CLEANUP;
     END;
   DO TOKPTR=NEWHDR REPEAT NEXT_TOKEN WHILE(TOKPTR^=NULL);
     SELECT(TYPE);
       WHEN(OPERATOR) /* IT IS AN OPERATOR */
         CALL PUSH(DO_OPERATOR(MSG,TOKPTR,STACK,POP));
       WHEN(KEYWORD) /* IT IS NILADIC FUNCTION REFERENCE */
         CALL PUSH(FUNCTION(MSG,0,TOKPTR,DUMMY,POP));
       WHEN(FUNCTION_A,FUNCTION_B) /* IT IS FUNCTION REFERENCE */
         CALL PUSH(FUNCTION(MSG,PARMCNT,TOKPTR,STACK,POP));
       WHEN(OPERAND) DO;
         ALLOCATE STACKEL;
         STACKNEXT=STACK;
         STACK=STACKPTR;
         STACKELP=TOKPTR;
         DO SW='1'B REPEAT ^SW;
           SAVE=TOKPTR;
           IF NEXT_TOKEN=NULL
             THEN LEAVE;
           TOKPTR=NEXT_TOKEN;
           SELECT(SW);
             WHEN('1'B) IF ^(TOKSTR='.' & TYPE=OTHER)
               THEN LEAVE;
             OTHERWISE IF ^(TYPE=OPERAND × TYPE=KEYWORD)
               THEN LEAVE;
             END; /* SELECT */
           END;
         TOKPTR=SAVE;
         END;
       WHEN(QUOTED_STRING,NUMERIC_CONSTANT,HEX_STRING) DO;
         ALLOCATE STACKEL;
         STACKNEXT=STACK;
         STACK=STACKPTR;
         STACKELP=TOKPTR;
         END;
       OTHERWISE SELECT(TOKSTR);
         WHEN('(') DO;
           ALLOCATE PARMSTACKEL;
           PARMSTACKNEXT=PARMSTACK;
           PARMSTACK=PARMSTACKPTR;
           PARMSTACKELP=1;
           END;
         WHEN(')') DO;
           PARMCNT=PARMSTACK->PARMSTACKELP;
             /* SAVE MOST RECENT PARM COUNT */
           PARMSTACKPTR=PARMSTACK;
           PARMSTACK=PARMSTACKNEXT;
           FREE PARMSTACKEL;
           END;
         WHEN(',')
           PARMSTACK->PARMSTACKELP=PARMSTACK->PARMSTACKELP+1;
         OTHERWISE; /* IGNORE ANYTHING ELSE */
         END; /* SELECT */
       END; /* SELECT */
     END;
   IF STACK^=NULL
     THEN RET=POP(MSG,STACK,GET_OPERAND);
     ELSE DO;
       MSG='ERROR - EXPRESSION DIDN''T REDUCE TO A SINGLE VALUE';
       RETURN(0);
       END;
 CLEANUP:
   DO WHILE(STACK^=NULL);
     STACKPTR=STACK;
     STACK=STACKNEXT;
     FREE STACKEL;
     END;
   DO WHILE(PARMSTACK^=NULL);
     PARMSTACKPTR=PARMSTACK;
     PARMSTACK=PARMSTACKNEXT;
     FREE PARMSTACKEL;
     END;
   DO WHILE(DUMMY^=NULL);
     STACKPTR=DUMMY;
     DUMMY=STACKNEXT;
     FREE STACKEL;
     END;
   RETURN(RET);
 POP: PROC(MSG,STACK,GET_OPERAND) RETURNS(FLOAT DEC(16));
 /* POPS OPERAND FROM STACK */
   DCL MSG CHAR(80) VAR;
   DCL STACK PTR;
   DCL GET_OPERAND ENTRY(PTR)
     RETURNS(FLOAT DEC(16));
   DCL RET FLOAT DEC(16);
   DCL BIN FIXED BIN(31,0);
   IF STACK=NULL
     THEN DO;
       MSG='OPERAND EXPECTED BUT OPERAND STACK EMPTY';
       SIGNAL CONDITION(BADEXP);
       RETURN;
       END;
   SELECT(STACK->STACKELP->TYPE);
     WHEN(TEMPORARY) DO;
       RET=STACK->STACKELP->TEMPVALUE;
       FREE STACK->STACKELP->TOKEN;
       END;
     WHEN(NUMERIC_CONSTANT,QUOTED_STRING) DO;
       RET=0;
       IF STACK->STACKELP->TOKSTR='.'
         THEN UNSPEC(RET)='1'B; /* MISSING VALUE */
         ELSE RET=STACK->STACKELP->TOKSTR;
       END;
     WHEN(HEX_STRING)
       RET=STACK->STACKELP->HEXVALUE;
     WHEN(OPERAND,KEYWORD)
       RET=GET_OPERAND(STACK->STACKELP);
     OTHERWISE;
     END;
   STACKPTR=STACK;
   STACK=STACKNEXT;
   FREE STACKEL;
   RETURN(RET);
   END POP;
 PUSH: PROC(VALUE);
 /* PUSHES A TEMPORARY ONTO THE STACK */
   DCL VALUE FLOAT DEC(16);
   ALLOCATE STACKEL;
   STACKNEXT=STACK;
   STACK=STACKPTR;
   ALLOCATE TOKEN SET(STACKELP);
   STACKELP->TYPE=TEMPORARY;
   STACKELP->TOKSTR=(16)' ';
   STACKELP->TEMPVALUE=VALUE;
   END PUSH;
   END EVAL;
