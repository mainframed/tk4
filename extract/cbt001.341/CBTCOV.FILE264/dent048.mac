 /* COPYRIGHT 1983 BY THOMAS GLEN SMITH */
 /* DENT048 - CONVERT <L1> <L2> <FORM1> <FORM2> LEFT/RIGHT <NAME> */
 /*           1       2    3    4       5       6          7      */
   % DCL @PROCNAME CHAR;
   % DCL @RENTNAME CHAR;
   % @PROCNAME = 'RENT';
   % @RENTNAME = 'DENT048';
   % INCLUDE DENTSUB;
   DCL (SETCAPS,TRIN,TROUT) ENTRY;
   DCL (PREFIX,SUFFIX) ENTRY(CHAR(*),CHAR(*))
     RETURNS(FIXED BIN(15,0));
   DCL PTRIN ENTRY(PTR)
     RETURNS(FIXED BIN(31,0));
   DCL PTROUT ENTRY(FIXED BIN(31,0))
     RETURNS(PTR);
   DCL SAVRHN CHAR(8);
   DCL (LEFTSW,RIGHTSW,NAMESW) BIT(1) INIT('0'B);
   DCL TLEFTSW BIT(1);
   DCL KEYTABLE(6) CHAR(80) VAR STATIC
     INIT('CHAR','HEX','FIXED','PACKED','FLOAT','BIT');
   DCL LRKEYS(3) CHAR(80) VAR STATIC INIT('LEFT','RIGHT','NAME');
   DCL INDX FIXED BIN(15,0);
   DCL OPER CHAR(80) VAR;
   DCL (ORGRHP,ORGTRH,TRH,SAVPTR) PTR;
   DCL 1 FSTR(2),
     2 TYPE FIXED BIN(15,0) INIT((2)0),
       /* 1=CHAR,2=HEX,3=FIXED,4=PACKED,5=FLOAT */
     2 OFF FIXED BIN(15,0) INIT((2)0),
     2 LEN FIXED BIN(15,0) INIT((2)0),
     2 SCALE FIXED BIN(15,0) INIT((2)0);
   DCL (INBUF,OUTBUF) CHAR(*) VAR CONTROLLED;
   DCL (INPTR,OUTPTR) PTR;
   RHRC=0; /* SET DEFAULT RETURN CODE */
   L1=PARY(2);
   L2=PARY(3);
   IF L2<L1
     THEN DO;
       MSGDATA='INVALID LINE RANGE';
       RHRC=8;
       RETURN;
       END;
   DO I=4 TO 5;
     IF PARY(I)=''
       THEN DO;
         MSGDATA='MISSING OPERAND';
         RHRC=8;
         RETURN;
         END;
     CALL SETCAPS(PARY(I));
     CALL #SPARS(PARY(I),KEYTABLE,OPER,INDX);
     IF INDX=0
       THEN DO; /* INVALID OPERAND */
         MSGDATA='INVALID OPERAND';
         RHRC=8;
         RETURN;
         END;
       ELSE DO;
         RHRC=SETFSTR(I-3);
         IF RHRC^=0
           THEN DO; /* INVALID OPERAND */
             MSGDATA='INVALID OPERAND';
             RETURN;
             END;
         END;
     END;
   DO I=6 TO 15 WHILE(PARY(I)^='');
     CALL SETCAPS(PARY(I));
     CALL #SPARS(PARY(I),LRKEYS,OPER,INDX);
     SELECT(INDX);
       WHEN(1) LEFTSW='1'B;
       WHEN(2) RIGHTSW='1'B;
       WHEN(3) DO; /* IT IS NAME KEYWORD */
         NAMESW='1'B;
         SAVRHN=OPER;
         END;
       OTHERWISE DO;
         MSGDATA='INVALID OPERAND';
         RHRC=8;
         RETURN;
         END;
       END; /* SELECT */
     END;
   IF ^NAMESW
     THEN TRH=RHPTR; /* NO <NAME> SPECIFIED */
     ELSE DO;
       DO TRH=NXTRHEL REPEAT TRH->RHNXT WHILE(TRH^=NULL)
         UNTIL(TRH->RHNAME=SAVRHN);
         END;
       IF TRH=NULL
         THEN DO;
           SAVPTR=RHPTR;
           PARY(*)='';
           PARY(4)='SUBCALL';
           CALL #DENT(CMDINDX,PARPTR,RHPTR,SUBENT,RHHDRPT);
           HEXMODE=SAVPTR->HEXMODE;
           RHTRANSW=SAVPTR->RHTRANSW;
           LOFLAG=SAVPTR->LOFLAG;
           RHNAME=SAVRHN;
           TRH=RHPTR;
           RHPTR=SAVPTR;
           END;
       END;
   ORGRHP=RHPTR->RECPTR;
   ORGTRH=TRH->RECPTR;
   ALLOC INBUF CHAR(RHPTR->BUFPTR->BUFLN);
   ALLOC OUTBUF CHAR(TRH->BUFPTR->BUFLN);
   INBUF,OUTBUF='';
   /* SET INPTR,OUTPTR - BYPASS HALFWORD LENGTH FIELDS */
   INPTR=PTROUT(PTRIN(ADDR(INBUF))+2);
   OUTPTR=PTROUT(PTRIN(ADDR(OUTBUF))+2);
   CALL #MD(RHPTR,SUBENT,L1);
   CALL #MD(TRH,SUBENT,L1);
   DO RECPTR=RECPTR REPEAT NXTPTR WHILE(RECSEQ<=L2) UNTIL(NXTPTR=HDPTR);
     CALL SEQMATCH; /* GO MATCH UP SEQUENCE NUMBERS */
     CALL CONVERT; /* GO DO CONVERSION AND ASSIGNMENT */
     END;
   IF ORGTRH=TRH
     THEN CALL #NC(TRH,SUBENT,TRH->NXTHDR);
     ELSE CALL #NC(TRH,SUBENT,ORGTRH);
   CALL #NC(RHPTR,SUBENT,ORGRHP);
   FREE INBUF;
   FREE OUTBUF;
   RHRC=0; /* ALL DONE */
 SEQMATCH: PROC;
 /* THIS SUBROUTINE ENSURES THAT THERE IS A MATCHING SEQUENCE NUMBER
 IN BOTH THE TO AND FROM DATA SETS.  IF THERE IS NOT, A RECORD WILL
 BE ADDED TO THE TO DATA SET. */
   DCL SAVPTR PTR;
   DCL DIR CHAR(4);
   DCL FOREVER FIXED BIN(15,0);
   IF TRH->RECPTR=TRH
     THEN DIR='NEXT'; /* SCAN FORWARD FROM HERE */
     ELSE IF TRH->RECPTR->RECSEQ=RECPTR->RECSEQ
       THEN RETURN; /* WE HAVE MATCHING SEQUENCE NUMBERS */
       ELSE IF TRH->RECPTR->RECSEQ>RECPTR->RECSEQ
         THEN DIR='LAST';
         ELSE DIR='NEXT';
   IF TRH->NXTHDR^=TRH
     THEN OUTER: DO;
       DO FOREVER=1 REPEAT FOREVER;
         IF DIR='NEXT'
           THEN IF TRH->RECPTR=TRH
             THEN TRH->RECPTR=TRH->NXTHDR;
             ELSE IF TRH->RECPTR->RECSEQ>RECPTR->RECSEQ
               THEN DO;
                 TRH->RECPTR=TRH->RECPTR->LSTPTR; /* BACK UP */
                 LEAVE OUTER; /* AND ADD A NEW RECORD */
                 END;
               ELSE IF TRH->RECPTR->NXTPTR=TRH
                 THEN LEAVE OUTER; /* RECORD MUST BE ADDED AT END */
                 ELSE TRH->RECPTR=TRH->RECPTR->NXTPTR;
           ELSE IF TRH->RECPTR=TRH
             THEN LEAVE OUTER; /* RECORD MUST BE ADDED AT FRONT */
             ELSE IF TRH->RECPTR->RECSEQ<RECPTR->RECSEQ
               THEN LEAVE OUTER; /* ADD A NEW RECORD */
               ELSE TRH->RECPTR=TRH->RECPTR->LSTPTR;
         IF TRH->RECPTR^=TRH
           THEN IF TRH->RECPTR->RECSEQ=RECPTR->RECSEQ
             THEN RETURN; /* WE HAVE MATCHING SEQUENCE NUMBERS */
         END;
       END OUTER;
   SAVPTR=TRH->RECPTR;
   TRH->BUFPTR->BUF='';
   CALL #ADD(TRH,SUBENT,SAVPTR,SAVPTR,RECSEQ,TRH->BUFPTR->BUF,RHPPTR);
   CALL #RESEQ(TRH,SUBENT,SAVPTR,'NOSAVE','NORENUM',99999999,
     RHPPTR);
   TRH->RECPTR=SAVPTR;
   TRH->CURSEQ=TRH->RECPTR->RECSEQ;
   END SEQMATCH;
 (SIZE): CONVERT: PROC;
 /**********************************************************************
 *  DOES THE ACTUAL CONVERSION. RHPTR->RECPTR POINTS TO RECORD FROM    *
 *  WHICH DATA IS TO BE OBTAINED.  TRH->RECPTR POINTS TO RECORD        *
 *  WHERE CONVERTED DATA IS TO BE STORED.  FSTR CONTAINS THE           *
 *  OFFSETS AND LENGTHS.                                               *
 **********************************************************************/
   DCL (I,J,K,L,O,P,S,T) FIXED BIN(15,0);
   DCL ERRCNT FIXED BIN(15,0) INIT(0);
   DCL PADCH CHAR(1);
   DCL MYBIT BIT(32760) VAR,
       MYCH CHAR(4095) VAR DEF MYBIT,
       MYLEN FIXED BIN(15,0) DEF MYBIT;
   DCL (BITSTR BIT(32767) VAR,
       FIXED_SHORT FIXED BIN(15,0),
       FIXED_LONG  FIXED BIN(31,0),
       FLOAT_SHORT    BIN FLOAT(21),
       FLOAT_LONG     BIN FLOAT(53),
       FLOAT_EXTENDED BIN FLOAT(109),
       PACKED_1 FIXED DEC(1,0),
       PACKED_2 FIXED DEC(3,0),
       PACKED_3 FIXED DEC(5,0),
       PACKED_4 FIXED DEC(7,0),
       PACKED_5 FIXED DEC(9,0),
       PACKED_6 FIXED DEC(11,0),
       PACKED_7 FIXED DEC(13,0),
       PACKED_8 FIXED DEC(15,0)) BASED(SOMEPTR);
   /* NEXT GET INPUT DATA */
   IF OFF(1)>LENGTH(RHPTR->RECPTR->RECSTR)
     THEN INBUF='';
     ELSE INBUF=SUBSTR(RHPTR->RECPTR->RECSTR,OFF(1),
       MIN(LEN(1),LENGTH(RHPTR->RECPTR->RECSTR)-OFF(1)+1));
   IF LENGTH(INBUF)<LEN(1)
     THEN SELECT(TYPE(1));
       WHEN(3,5,6) /* FIXED,FLOAT */
         INBUF=INBUF××LOW(LEN(1)-LENGTH(INBUF));
       WHEN(1) /* CHAR */
         INBUF=INBUF××REPEAT(' ',LEN(1)-LENGTH(INBUF)-1);
       WHEN(2) /* HEX */
         INBUF=INBUF××REPEAT('0',LEN(1)-LENGTH(INBUF)-1);
       WHEN(4) /* PACKED */
         INBUF=LOW(LEN(1)-LENGTH(INBUF))××INBUF;
       END;
   L=LENGTH(INBUF); /* L=LENGTH OF INPUT DATA */
   T=TYPE(1)*10+TYPE(2);
   PADCH=LOW(1); /* DEFAULT PADDING CHARACTER */
   OUTBUF=REPEAT(' ',LEN(2)-1);
   IF LENGTH(OUTBUF)<LEN(2)
     THEN IF LEN(2)<=16
       THEN GOTO BADDATA; /* MUST HAVE SOME LENGTH */
   ON CONVERSION GOTO BADDATA;
   ON SIZE       GOTO BADDATA;
   ON ERROR GOTO BADDATA;
   GOTO SELECT;
 BADDATA:
   OUTBUF=REPEAT('*',LEN(2)-1);
   GO TO BYSEL;
 SELECT:
   SELECT(T);
     WHEN(11) DO; /* CHAR-TO-CHAR */
       IF LEN(2)<L
         THEN OUTBUF=SUBSTR(INBUF,1,LEN(2));
         ELSE OUTBUF=INBUF;
       PADCH=' ';
       END;
     WHEN(12) DO; /* CHAR TO HEX */
       OUTBUF=REPEAT(' ',L*2-1);
       CALL TROUT(INBUF,OUTBUF);
       IF LENGTH(OUTBUF)>LEN(2)
         THEN OUTBUF=SUBSTR(OUTBUF,1,LEN(2));
       PADCH='0';
       END;
     WHEN(13) DO; /* CHAR TO FIXED */
       OUTBUF=REPEAT(' ',LEN(2)-1);
       IF LEN(2)=2
         THEN OUTPTR->FIXED_SHORT=INBUF;
         ELSE OUTPTR->FIXED_LONG=INBUF;
       END;
     WHEN(14) DO; /* CHAR TO PACKED */
       SELECT(LEN(2));
         WHEN(1) OUTPTR->PACKED_1=INBUF;
         WHEN(2) OUTPTR->PACKED_2=INBUF;
         WHEN(3) OUTPTR->PACKED_3=INBUF;
         WHEN(4) OUTPTR->PACKED_4=INBUF;
         WHEN(5) OUTPTR->PACKED_5=INBUF;
         WHEN(6) OUTPTR->PACKED_6=INBUF;
         WHEN(7) OUTPTR->PACKED_7=INBUF;
         WHEN(8) OUTPTR->PACKED_8=INBUF;
         END;
       END;
     WHEN(15) DO; /* CHAR TO FLOAT */
       SELECT(LEN(2));
         WHEN(4)  OUTPTR->FLOAT_SHORT=INBUF;
         WHEN(8)  OUTPTR->FLOAT_LONG=INBUF;
         WHEN(16) OUTPTR->FLOAT_EXTENDED=INBUF;
         END; /* SELECT */
       END;
     WHEN(16) DO; /* CHAR TO BIT */
       I=MOD(LENGTH(INBUF),8);
       IF I^=0
         THEN INBUF=REPEAT('0',8-I-1)××INBUF; /* LENGTH M/B /8 */
       MYBIT=INBUF;
       MYLEN=MYLEN/8;
       OUTBUF=MYCH;
       END;
     WHEN(21,22,23,24,25,26) DO; /* HEX TO WHATEVER */
       IF VERIFY(INBUF,'0123456789ABCDEF')=0
         THEN CALL TRIN(INBUF,OUTBUF);
         ELSE OUTBUF=REPEAT('*',LEN(2)-1);
       PADCH=' ';
       END;
     WHEN(31) DO; /* FIXED TO CHAR */
       IF LEN(1)=2
         THEN OUTBUF=INPTR->FIXED_SHORT;
         ELSE OUTBUF=INPTR->FIXED_LONG;
       PADCH=' ';
       END;
     WHEN(32) DO; /* FIXED TO HEX */
       CALL TROUT(INBUF,OUTBUF);
       PADCH='0';
       END;
     WHEN(33) DO; /* FIXED TO FIXED */
       SELECT(LEN(2)*10+LEN(1));
         WHEN(22) OUTPTR->FIXED_SHORT=INPTR->FIXED_SHORT;
         WHEN(24) OUTPTR->FIXED_SHORT=INPTR->FIXED_LONG;
         WHEN(42) OUTPTR->FIXED_LONG=INPTR->FIXED_SHORT;
         WHEN(44) OUTPTR->FIXED_LONG=INPTR->FIXED_LONG;
         END;
       END;
     WHEN(34) DO; /* FIXED TO PACKED */
       IF LEN(1)=2
         THEN SELECT(LEN(2));
           WHEN(1) OUTPTR->PACKED_1=INPTR->FIXED_SHORT;
           WHEN(2) OUTPTR->PACKED_2=INPTR->FIXED_SHORT;
           WHEN(3) OUTPTR->PACKED_3=INPTR->FIXED_SHORT;
           WHEN(4) OUTPTR->PACKED_4=INPTR->FIXED_SHORT;
           WHEN(5) OUTPTR->PACKED_5=INPTR->FIXED_SHORT;
           WHEN(6) OUTPTR->PACKED_6=INPTR->FIXED_SHORT;
           WHEN(7) OUTPTR->PACKED_7=INPTR->FIXED_SHORT;
           WHEN(8) OUTPTR->PACKED_8=INPTR->FIXED_SHORT;
           END;
         ELSE SELECT(LEN(2));
           WHEN(1) OUTPTR->PACKED_1=INPTR->FIXED_LONG;
           WHEN(2) OUTPTR->PACKED_2=INPTR->FIXED_LONG;
           WHEN(3) OUTPTR->PACKED_3=INPTR->FIXED_LONG;
           WHEN(4) OUTPTR->PACKED_4=INPTR->FIXED_LONG;
           WHEN(5) OUTPTR->PACKED_5=INPTR->FIXED_LONG;
           WHEN(6) OUTPTR->PACKED_6=INPTR->FIXED_LONG;
           WHEN(7) OUTPTR->PACKED_7=INPTR->FIXED_LONG;
           WHEN(8) OUTPTR->PACKED_8=INPTR->FIXED_LONG;
           END;
       END;
     WHEN(35) DO; /* FIXED TO FLOAT */
       IF LEN(1)=2
         THEN SELECT(LEN(2));
           WHEN(4) OUTPTR->FLOAT_SHORT=INPTR->FIXED_SHORT;
           WHEN(8) OUTPTR->FLOAT_LONG=INPTR->FIXED_SHORT;
           WHEN(16) OUTPTR->FLOAT_EXTENDED=INPTR->FIXED_SHORT;
           END;
         ELSE SELECT(LEN(2));
           WHEN(4) OUTPTR->FLOAT_SHORT=INPTR->FIXED_LONG;
           WHEN(8) OUTPTR->FLOAT_LONG=INPTR->FIXED_LONG;
           WHEN(16) OUTPTR->FLOAT_EXTENDED=INPTR->FIXED_LONG;
           END;
       END;
     WHEN(36) DO; /* FIXED TO BIT */
       IF LEN(1)=2
         THEN MYBIT=INPTR->FIXED_SHORT;
         ELSE MYBIT=INPTR->FIXED_LONG;
       I=MOD(LENGTH(MYBIT),8);
       IF I^=0
         THEN MYBIT=REPEAT('0'B,8-I-1)××MYBIT;
       MYLEN=MYLEN/8; /* SET LENGTH FOR CHARACTER */
       OUTBUF=MYCH;
       END;
     WHEN(41) DO; /* PACKED TO CHAR */
       SELECT(LEN(1));
         WHEN(1) OUTBUF=INPTR->PACKED_1;
         WHEN(2) OUTBUF=INPTR->PACKED_2;
         WHEN(3) OUTBUF=INPTR->PACKED_3;
         WHEN(4) OUTBUF=INPTR->PACKED_4;
         WHEN(5) OUTBUF=INPTR->PACKED_5;
         WHEN(6) OUTBUF=INPTR->PACKED_6;
         WHEN(7) OUTBUF=INPTR->PACKED_7;
         WHEN(8) OUTBUF=INPTR->PACKED_8;
         END;
       PADCH=' ';
       END;
     WHEN(42) DO; /* PACKED TO HEX */
       CALL TROUT(INBUF,OUTBUF);
       PADCH='0';
       END;
     WHEN(43) DO; /* PACKED TO FIXED */
       IF LEN(2)=2
         THEN SELECT(LEN(1));
           WHEN(1) OUTPTR->FIXED_SHORT=INPTR->PACKED_1;
           WHEN(2) OUTPTR->FIXED_SHORT=INPTR->PACKED_2;
           WHEN(3) OUTPTR->FIXED_SHORT=INPTR->PACKED_3;
           WHEN(4) OUTPTR->FIXED_SHORT=INPTR->PACKED_4;
           WHEN(5) OUTPTR->FIXED_SHORT=INPTR->PACKED_5;
           WHEN(6) OUTPTR->FIXED_SHORT=INPTR->PACKED_6;
           WHEN(7) OUTPTR->FIXED_SHORT=INPTR->PACKED_7;
           WHEN(8) OUTPTR->FIXED_SHORT=INPTR->PACKED_8;
           END;
         ELSE SELECT(LEN(1));
           WHEN(1) OUTPTR->FIXED_LONG=INPTR->PACKED_1;
           WHEN(2) OUTPTR->FIXED_LONG=INPTR->PACKED_2;
           WHEN(3) OUTPTR->FIXED_LONG=INPTR->PACKED_3;
           WHEN(4) OUTPTR->FIXED_LONG=INPTR->PACKED_4;
           WHEN(5) OUTPTR->FIXED_LONG=INPTR->PACKED_5;
           WHEN(6) OUTPTR->FIXED_LONG=INPTR->PACKED_6;
           WHEN(7) OUTPTR->FIXED_LONG=INPTR->PACKED_7;
           WHEN(8) OUTPTR->FIXED_LONG=INPTR->PACKED_8;
           END;
       END;
     WHEN(44) DO; /* PACKED TO PACKED */
       SELECT(LEN(1));
         WHEN(1) OUTPTR->PACKED_1=INPTR->PACKED_1;
         WHEN(2) OUTPTR->PACKED_2=INPTR->PACKED_2;
         WHEN(3) OUTPTR->PACKED_3=INPTR->PACKED_3;
         WHEN(4) OUTPTR->PACKED_4=INPTR->PACKED_4;
         WHEN(5) OUTPTR->PACKED_5=INPTR->PACKED_5;
         WHEN(6) OUTPTR->PACKED_6=INPTR->PACKED_6;
         WHEN(7) OUTPTR->PACKED_7=INPTR->PACKED_7;
         WHEN(8) OUTPTR->PACKED_8=INPTR->PACKED_8;
         END;
       END;
     WHEN(45) DO; /* PACKED TO FLOAT */
       SELECT(LEN(2));
         WHEN(4)
           SELECT(LEN(1));
             WHEN(1) OUTPTR->FLOAT_SHORT=INPTR->PACKED_1;
             WHEN(2) OUTPTR->FLOAT_SHORT=INPTR->PACKED_2;
             WHEN(3) OUTPTR->FLOAT_SHORT=INPTR->PACKED_3;
             WHEN(4) OUTPTR->FLOAT_SHORT=INPTR->PACKED_4;
             WHEN(5) OUTPTR->FLOAT_SHORT=INPTR->PACKED_5;
             WHEN(6) OUTPTR->FLOAT_SHORT=INPTR->PACKED_6;
             WHEN(7) OUTPTR->FLOAT_SHORT=INPTR->PACKED_7;
             WHEN(8) OUTPTR->FLOAT_SHORT=INPTR->PACKED_8;
             END;
         WHEN(8)
           SELECT(LEN(1));
             WHEN(1) OUTPTR->FLOAT_LONG=INPTR->PACKED_1;
             WHEN(2) OUTPTR->FLOAT_LONG=INPTR->PACKED_2;
             WHEN(3) OUTPTR->FLOAT_LONG=INPTR->PACKED_3;
             WHEN(4) OUTPTR->FLOAT_LONG=INPTR->PACKED_4;
             WHEN(5) OUTPTR->FLOAT_LONG=INPTR->PACKED_5;
             WHEN(6) OUTPTR->FLOAT_LONG=INPTR->PACKED_6;
             WHEN(7) OUTPTR->FLOAT_LONG=INPTR->PACKED_7;
             WHEN(8) OUTPTR->FLOAT_LONG=INPTR->PACKED_8;
             END;
         WHEN(16)
           SELECT(LEN(1));
             WHEN(1) OUTPTR->FLOAT_EXTENDED=INPTR->PACKED_1;
             WHEN(2) OUTPTR->FLOAT_EXTENDED=INPTR->PACKED_2;
             WHEN(3) OUTPTR->FLOAT_EXTENDED=INPTR->PACKED_3;
             WHEN(4) OUTPTR->FLOAT_EXTENDED=INPTR->PACKED_4;
             WHEN(5) OUTPTR->FLOAT_EXTENDED=INPTR->PACKED_5;
             WHEN(6) OUTPTR->FLOAT_EXTENDED=INPTR->PACKED_6;
             WHEN(7) OUTPTR->FLOAT_EXTENDED=INPTR->PACKED_7;
             WHEN(8) OUTPTR->FLOAT_EXTENDED=INPTR->PACKED_8;
             END;
         END;
       END;
     WHEN(46) DO; /* PACKED TO BIT */
       SELECT(LEN(1));
         WHEN(1) MYBIT=INPTR->PACKED_1;
         WHEN(2) MYBIT=INPTR->PACKED_2;
         WHEN(3) MYBIT=INPTR->PACKED_3;
         WHEN(4) MYBIT=INPTR->PACKED_4;
         WHEN(5) MYBIT=INPTR->PACKED_5;
         WHEN(6) MYBIT=INPTR->PACKED_6;
         WHEN(7) MYBIT=INPTR->PACKED_7;
         WHEN(8) MYBIT=INPTR->PACKED_8;
         END;
       I=MOD(LENGTH(MYBIT),8);
       IF I^=0
         THEN MYBIT=REPEAT('0'B,8-I-1)××MYBIT;
       MYLEN=MYLEN/8; /* ADJUST LENGTH FOR CHARACTER MOVE */
       OUTBUF=MYCH;
       END;
     WHEN(51) DO; /* FLOAT TO CHAR */
       SELECT(LEN(1));
         WHEN(4) OUTBUF=INPTR->FLOAT_SHORT;
         WHEN(8) OUTBUF=INPTR->FLOAT_LONG;
         WHEN(16) OUTBUF=INPTR->FLOAT_EXTENDED;
         END;
       PADCH=' ';
       END;
     WHEN(52) DO; /* FLOAT TO HEX */
       CALL TROUT(INBUF,OUTBUF);
       END;
     WHEN(53) DO; /* FLOAT TO FIXED */
       IF LEN(2)=2
         THEN SELECT(LEN(1));
           WHEN(4) OUTPTR->FIXED_SHORT=INPTR->FLOAT_SHORT;
           WHEN(8) OUTPTR->FIXED_SHORT=INPTR->FLOAT_LONG;
           WHEN(16) OUTPTR->FIXED_SHORT=INPTR->FLOAT_EXTENDED;
           END;
         ELSE SELECT(LEN(1));
           WHEN(4) OUTPTR->FIXED_LONG=INPTR->FLOAT_SHORT;
           WHEN(8) OUTPTR->FIXED_LONG=INPTR->FLOAT_LONG;
           WHEN(16) OUTPTR->FIXED_LONG=INPTR->FLOAT_EXTENDED;
           END;
       END;
     WHEN(54) DO; /* FLOAT TO PACKED */
       SELECT(LEN(1));
         WHEN(4) SELECT(LEN(2));
           WHEN(1) OUTPTR->PACKED_1=INPTR->FLOAT_SHORT;
           WHEN(2) OUTPTR->PACKED_2=INPTR->FLOAT_SHORT;
           WHEN(3) OUTPTR->PACKED_3=INPTR->FLOAT_SHORT;
           WHEN(4) OUTPTR->PACKED_4=INPTR->FLOAT_SHORT;
           WHEN(5) OUTPTR->PACKED_5=INPTR->FLOAT_SHORT;
           WHEN(6) OUTPTR->PACKED_6=INPTR->FLOAT_SHORT;
           WHEN(7) OUTPTR->PACKED_7=INPTR->FLOAT_SHORT;
           WHEN(8) OUTPTR->PACKED_8=INPTR->FLOAT_SHORT;
           END;
         WHEN(8) SELECT(LEN(2));
           WHEN(1) OUTPTR->PACKED_1=INPTR->FLOAT_LONG;
           WHEN(2) OUTPTR->PACKED_2=INPTR->FLOAT_LONG;
           WHEN(3) OUTPTR->PACKED_3=INPTR->FLOAT_LONG;
           WHEN(4) OUTPTR->PACKED_4=INPTR->FLOAT_LONG;
           WHEN(5) OUTPTR->PACKED_5=INPTR->FLOAT_LONG;
           WHEN(6) OUTPTR->PACKED_6=INPTR->FLOAT_LONG;
           WHEN(7) OUTPTR->PACKED_7=INPTR->FLOAT_LONG;
           WHEN(8) OUTPTR->PACKED_8=INPTR->FLOAT_LONG;
           END;
         WHEN(16) SELECT(LEN(2));
           WHEN(1) OUTPTR->PACKED_1=INPTR->FLOAT_EXTENDED;
           WHEN(2) OUTPTR->PACKED_2=INPTR->FLOAT_EXTENDED;
           WHEN(3) OUTPTR->PACKED_3=INPTR->FLOAT_EXTENDED;
           WHEN(4) OUTPTR->PACKED_4=INPTR->FLOAT_EXTENDED;
           WHEN(5) OUTPTR->PACKED_5=INPTR->FLOAT_EXTENDED;
           WHEN(6) OUTPTR->PACKED_6=INPTR->FLOAT_EXTENDED;
           WHEN(7) OUTPTR->PACKED_7=INPTR->FLOAT_EXTENDED;
           WHEN(8) OUTPTR->PACKED_8=INPTR->FLOAT_EXTENDED;
           END;
         END;
       END;
     WHEN(55) DO; /* FLOAT TO FLOAT */
       SELECT(LEN(2)*100+LEN(1));
         WHEN(0404) OUTPTR->FLOAT_SHORT=INPTR->FLOAT_SHORT;
         WHEN(0408) OUTPTR->FLOAT_SHORT=INPTR->FLOAT_LONG;
         WHEN(0416) OUTPTR->FLOAT_SHORT=INPTR->FLOAT_EXTENDED;
         WHEN(0804) OUTPTR->FLOAT_LONG=INPTR->FLOAT_SHORT;
         WHEN(0808) OUTPTR->FLOAT_LONG=INPTR->FLOAT_LONG;
         WHEN(0816) OUTPTR->FLOAT_LONG=INPTR->FLOAT_EXTENDED;
         WHEN(1604) OUTPTR->FLOAT_EXTENDED=INPTR->FLOAT_SHORT;
         WHEN(1608) OUTPTR->FLOAT_EXTENDED=INPTR->FLOAT_LONG;
         WHEN(1616) OUTPTR->FLOAT_EXTENDED=INPTR->FLOAT_EXTENDED;
         END;
       END;
     WHEN(56) DO; /* FLOAT TO BIT */
       SELECT(LEN(1));
         WHEN(4) MYBIT=INPTR->FLOAT_SHORT;
         WHEN(8) MYBIT=INPTR->FLOAT_LONG;
         WHEN(16) MYBIT=INPTR->FLOAT_EXTENDED;
         END;
       I=MOD(LENGTH(MYBIT),8);
       IF I^=0
         THEN MYBIT=REPEAT('0'B,8-I-1)××MYBIT;
       MYLEN=MYLEN/8;
       OUTBUF=MYCH;
       END;
     WHEN(61) DO; /* BIT TO CHAR */
       MYCH=INBUF;
       MYLEN=MYLEN*8;
       OUTBUF=MYBIT;
       PADCH='0';
       END;
     WHEN(62) DO; /* BIT TO HEX */
       CALL TROUT(INBUF,OUTBUF);
       PADCH='0';
       END;
     WHEN(63) DO; /* BIT TO FIXED */
       MYCH=INBUF;
       MYLEN=MYLEN*8;
       IF LEN(2)=2
         THEN OUTPTR->FIXED_SHORT=MYBIT;
         ELSE OUTPTR->FIXED_LONG=MYBIT;
       END;
     WHEN(64) DO; /* BIT TO PACKED */
       MYCH=INBUF;
       MYLEN=MYLEN*8;
       SELECT(LEN(2));
         WHEN(1) OUTPTR->PACKED_1=MYBIT;
         WHEN(2) OUTPTR->PACKED_2=MYBIT;
         WHEN(3) OUTPTR->PACKED_3=MYBIT;
         WHEN(4) OUTPTR->PACKED_4=MYBIT;
         WHEN(5) OUTPTR->PACKED_5=MYBIT;
         WHEN(6) OUTPTR->PACKED_6=MYBIT;
         WHEN(7) OUTPTR->PACKED_7=MYBIT;
         WHEN(8) OUTPTR->PACKED_8=MYBIT;
         END;
       END;
     WHEN(65) DO; /* BIT TO FLOAT */
       MYCH=INBUF;
       MYLEN=MYLEN*8;
       SELECT(LEN(2));
         WHEN(4) OUTPTR->FLOAT_SHORT=MYBIT;
         WHEN(8) OUTPTR->FLOAT_LONG=MYBIT;
         WHEN(16) OUTPTR->FLOAT_EXTENDED=MYBIT;
         END;
       END;
     WHEN(66) DO; /* BIT TO BIT */
       OUTBUF=INBUF;
       END;
     END; /* SELECT */
   /* NOW APPLY THE SCALE PARAMETERS */
   S=(SCALE(1)-SCALE(2))*10;
   SELECT(SIGN(S));
     WHEN(1) DO; /* MUST SCALE DOWN */
       SELECT(TYPE(2));
         WHEN(3) /* FIXED */
           IF LEN(2)=2
             THEN OUTPTR->FIXED_SHORT=OUTPTR->FIXED_SHORT/S;
             ELSE OUTPTR->FIXED_LONG=OUTPTR->FIXED_LONG/S;
         WHEN(4) /* PACKED */
           SELECT(LEN(2));
             WHEN(1) OUTPTR->PACKED_1=OUTPTR->PACKED_1/S;
             WHEN(2) OUTPTR->PACKED_2=OUTPTR->PACKED_2/S;
             WHEN(3) OUTPTR->PACKED_3=OUTPTR->PACKED_3/S;
             WHEN(4) OUTPTR->PACKED_4=OUTPTR->PACKED_4/S;
             WHEN(5) OUTPTR->PACKED_5=OUTPTR->PACKED_5/S;
             WHEN(6) OUTPTR->PACKED_6=OUTPTR->PACKED_6/S;
             WHEN(7) OUTPTR->PACKED_7=OUTPTR->PACKED_7/S;
             WHEN(8) OUTPTR->PACKED_8=OUTPTR->PACKED_8/S;
             END;
         WHEN(5) /* FLOAT */
           SELECT(LEN(2));
             WHEN(4) OUTPTR->FLOAT_SHORT=OUTPTR->FLOAT_SHORT/S;
             WHEN(8) OUTPTR->FLOAT_LONG=OUTPTR->FLOAT_LONG/S;
             WHEN(16) OUTPTR->FLOAT_EXTENDED=OUTPTR->FLOAT_EXTENDED/S;
             END;
         OTHERWISE;
         END;
       END;
     WHEN(-1) DO; /* MUST SCALE UP */
       S=0-S;
       SELECT(TYPE(2));
         WHEN(3) /* FIXED */
           IF LEN(2)=2
             THEN OUTPTR->FIXED_SHORT=OUTPTR->FIXED_SHORT*S;
             ELSE OUTPTR->FIXED_LONG=OUTPTR->FIXED_LONG*S;
         WHEN(4) /* PACKED */
           SELECT(LEN(2));
             WHEN(1) OUTPTR->PACKED_1=OUTPTR->PACKED_1*S;
             WHEN(2) OUTPTR->PACKED_2=OUTPTR->PACKED_2*S;
             WHEN(3) OUTPTR->PACKED_3=OUTPTR->PACKED_3*S;
             WHEN(4) OUTPTR->PACKED_4=OUTPTR->PACKED_4*S;
             WHEN(5) OUTPTR->PACKED_5=OUTPTR->PACKED_5*S;
             WHEN(6) OUTPTR->PACKED_6=OUTPTR->PACKED_6*S;
             WHEN(7) OUTPTR->PACKED_7=OUTPTR->PACKED_7*S;
             WHEN(8) OUTPTR->PACKED_8=OUTPTR->PACKED_8*S;
             END;
         WHEN(5) /* FLOAT */
           SELECT(LEN(2));
             WHEN(4) OUTPTR->FLOAT_SHORT=OUTPTR->FLOAT_SHORT*S;
             WHEN(8) OUTPTR->FLOAT_LONG=OUTPTR->FLOAT_LONG*S;
             WHEN(16) OUTPTR->FLOAT_EXTENDED=OUTPTR->FLOAT_EXTENDED*S;
             END;
         OTHERWISE;
         END;
       END;
     OTHERWISE; /* SCALE DOES NOT CHANGE */
     END;
 BYSEL:; /* CONTROL BRANCHES HERE ON CONVERSION AND SIZE CONDITION,
            AFTER SETTING OUTPUT DATA TO ASTERISKS. */
   REVERT ERROR;
   IF TYPE(2)=1 × TYPE(2)=2
     THEN DO; /* MUST BE CHAR, OR HEX FOR PADDING */
       IF (LEFTSW × RIGHTSW) /* DID USER OVERRIDE PAD DEFAULT? */
         THEN TLEFTSW=LEFTSW;
         ELSE IF TYPE(2)=1
           THEN TLEFTSW='1'B; /* LEFT ADJUST */
           ELSE TLEFTSW='0'B; /* RIGHT ADJUST */
       IF LENGTH(OUTBUF)>0
         THEN OUTBUF=SUBSTR(OUTBUF,1,SUFFIX(OUTBUF,' '));
       IF LENGTH(OUTBUF)>0
         THEN DO;
           P=PREFIX(OUTBUF,' ');
           IF P=0
             THEN OUTBUF='';
               ELSE OUTBUF=SUBSTR(OUTBUF,P);
           END;
       IF LENGTH(OUTBUF)>0
         THEN IF TLEFTSW
           THEN OUTBUF=SUBSTR(OUTBUF,1,SUFFIX(OUTBUF,PADCH));
           ELSE DO;
             P=PREFIX(OUTBUF,PADCH);
             IF P=0
               THEN OUTBUF='';
               ELSE OUTBUF=SUBSTR(OUTBUF,P);
             END;
       IF LENGTH(OUTBUF)>LEN(2)
         THEN OUTBUF=REPEAT('*',LEN(2)-1);
       /* NOW PAD IF NECESSARY */
       IF LENGTH(OUTBUF)<LEN(2)
         THEN IF TLEFTSW
           THEN OUTBUF=OUTBUF××REPEAT(PADCH,LEN(2)-LENGTH(OUTBUF)-1);
           ELSE OUTBUF=REPEAT(PADCH,LEN(2)-LENGTH(OUTBUF)-1)××OUTBUF;
       END;
   /* NOW INSERT OUTBUF IN OUTPUT RECORD */
   P=LENGTH(TRH->RECPTR->RECSTR)-OFF(2)+1;
   SELECT(SIGN(P));
     WHEN(0) /* NEW DATA GOES EXACTLY AT END OF OLD DATA */
       TRH->RECPTR->RECSTR=TRH->RECPTR->RECSTR××OUTBUF;
     WHEN(-1) /* PADDING IS REQUIRED */
       TRH->RECPTR->RECSTR=TRH->RECPTR->RECSTR××REPEAT(' ',-1-P)××
         OUTBUF;
     WHEN(1) DO; /* TRUNCATION/OVERLAP IS REQUIRED */
       IF P<LEN(2)
         THEN TRH->RECPTR->RECSTR=SUBSTR(TRH->RECPTR->RECSTR,1,LEN(2)-P)
           ××OUTBUF;
         ELSE SUBSTR(TRH->RECPTR->RECSTR,OFF(2),LEN(2))=OUTBUF;
       END;
     END;
   END CONVERT;
 SETFSTR:  PROC(PI) RETURNS(FIXED BIN(31,0));
 /* PARSES TYPE,OFFSET,LENGTH,SCALE FOR <FORM1> AND <FORM2> */
   DCL (PI,IP,I,J,K,L) FIXED BIN(31,0);
   IF PI=1
     THEN IP=2; /* IP=INDEX TO OTHER FORM */
     ELSE IP=1;
   FSTR(PI)=FSTR(IP); /* SET INITIAL DEFAULTS */
   TYPE(PI)=INDX;
   SCALE(PI)=0; /* DON'T DEFAULT SCALE */
   DCL DENTPRS ENTRY(CHAR(*) VAR,);
   DCL 1 PARSTR UNALIGNED,
     2 CMDINDX FIXED BIN(15,0),
     2 OPERCK BIT(16),
     2 QUOTCK BIT(16),
     2 PARY(16) CHAR(256) VAR,
     2 NUMCKA(1) BIT(16) INIT('0111'B),
     2 CMDTAB(1) CHAR(8) VAR INIT('LSP');
   DCL VAL CHAR(256) VAR;
   VAL='LSP '××OPER;
   CALL DENTPRS(VAL,PARSTR);
   IF OPERCK^='0'B
     THEN RETURN(4); /* INVALID OPERAND */
   IF PARY(2)^=''
     THEN DO;
       OFF(PI)=PARY(2);
       IF PARY(3)^=''
         THEN DO;
           LEN(PI)=PARY(3);
           IF PARY(4)^=''
             THEN SCALE(PI)=PARY(4);
           END;
       END;
   SELECT(INDX);
     WHEN(1,2,5,6)
       IF SCALE(PI)^=0
         THEN RETURN(4); /* NO SCALE ALLOWED FOR CHAR,HEX,FLOAT, BIT */
       OTHERWISE;
       END;
   SELECT(INDX);
     WHEN(6) /* BIT */
       IF LEN(PI)>4095
         THEN RETURN(4); /* MAX LEN FOR BIT DATA = 4095 */
     WHEN(5) /* FLOATING POINT */
       IF ^(LEN(PI)=4 × LEN(PI)=8 × LEN(PI)=16)
         THEN RETURN(4); /* FLOATING POINT M/B LEN=4, 8, OR 16 */
     WHEN(4) /* PACKED DECIMAL */
       IF LEN(PI)>8
         THEN RETURN(4); /* PACKED DECIMAL LENGTH <= 8 */
     WHEN(3) /* FIXED */
       IF ^(LEN(PI)=4 × LEN(PI)=2)
         THEN RETURN(4);
     OTHERWISE IF LEN(PI)>32767
       THEN RETURN(4); /* ALL OTHERS, MAX LENGTH=32767 */
     END; /* SELECT */
   RETURN(0);
   END SETFSTR;
   END DENT048;
