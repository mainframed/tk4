 /* DB2PUT */
 /*
0*$.HE GENERALIZED SUBROUTINES - DB2PUT
0*$.HE OBTAIN A DB2 TABLE
0*$.PL 55
0*$.PN 0
0*$.PA
0*$.SS
0*$.NF
0*$02/01/84
0*$AUTHOR:  T. SMITH
0*$SOURCE MODULE NAME: DB2PUT
0*$DOCUMENTATION ID: 0*$
0*$.FI L
0*$.SP 5
0*$THIS SUBROUTINE CAN BE USED TO INTERFACE TO DB2 TO REPLACE ALL
0*$OF THE ROWS OF A TABLE STORED IN A DB2 DATABASE.  IF THE TABLE
0*$DOESN'T CURRENTLY EXIST, DB2PUT WILL ATTEMPT TO CREATE IT FOR YOU.
0*$CALL FORMAT IS AS FOLLOWS:
0*$.SP 1
0*$.NF
0*$DCL DB2PUT ENTRY(CHAR(*), ENTRY, ENTRY)
0*$RETURNS(FIXED BIN(31,0));
0*$FETCH DB2PUT;
0*$I=DB2PUT('TABLENAME',SUBRTNE,TERM);
0*$IF I^=0 THEN SIGNAL ERROR;
0*$.FI L
0*$.SP 1
0*$WHERE -
0*$.SP 1
0*$'TABLENAME' IS THE NAME OF THE TABLE TO BE REPLACED.  THIS IS
0*$THE DB2 NAME, AND MAY BE QUALIFIED AS DOCUMENTED IN THE DB2
0*$REFERENCE MANUAL, E.G. 'X75826.TABLE'.
0*$.SP 1
0*$SUBRTNE IS THE NAME OF A FUNCTION YOU AS THE CALLER OF DB2PUT
0*$MUST SUPPLY.  YOUR SUBRTNE FUNCTION SHOULD RETURN CHAR(32767) VAR,
0*$AND SHOULD EXPECT CHAR(*) AS THE SOLE PARAMETER.
0*$.SP 1
0*$DB2PUT WILL FIRST DELETE ALL THE ROWS CURRENTLY IN THE SPECIFIED
0*$TABLE BY ISSUING THE SQL STATEMENT -
0*$.SP 1
0*$DELETE FROM TABLENAME
0*$.SP 1
0*$IF THIS RESULTS IN AN ERROR INDICATING THE TABLE DOESN'T CURRENTLY
0*$EXIST, DB2PUT WILL TRY TO CREATE ONE FOR YOU.  IT WILL FIRST
0*$INVOKE YOUR SUBRTNE FUNCTION AS FOLLOWS:
0*$.SP 1
0*$STRING=SUBRTNE('CREATE');
0*$.SP 1
0*$YOUR SUBRTNE FUNCTION SHOULD RETURN A CHARACTER STRING OF A FORMAT
0*$IDENTICAL TO THE COLUMN-NAME/DATA-TYPE SPECIFICATION LIST AS
0*$DOCUMENTED IN THE IBM DATABASE-2 REFERENCE FOR THE 'CREATE TABLE'
0*$STATEMENT.  IF YOU DON'T NEED TO SPECIFY 'NOT NULL' IN THE LIST,
0*$THE FORMAT WILL BE AS FOLLOWS:
0*$.SP 1
0*$COLUMN-NAME1 DATA-TYPE1,...,COLUMN-NAMEN DATA-TYPEN
0*$.SP 1
0*$WHERE DATA-TYPE IS INTEGER, SMALLINT, FLOAT, DECIMAL(M,N),
0*$CHAR(M), ETC.
0*$.SP 1
0*$IF YOU DON'T WANT DB2PUT TO CREATE A TABLE FOR YOU, HAVE YOUR
0*$SUBRTNE FUNCTION RETURN A NULL STRING. DB2PUT WILL THEN TERMINATE
0*$WITH ERROR MESSAGES AND A NON-ZERO RETURN CODE. OTHERWISE, DB2PUT
0*$WILL NEXT CALL YOUR SUBRTNE FUNCTION AS FOLLOWS:
0*$.SP 1
0*$STRING=SUBRTNE('IN');
0*$.SP 1
0*$YOU CAN EITHER RETURN A STRING CONTAINING
0*$'DATABASE-NAME.TABLESPACE-NAME' OR JUST 'TABLESPACE-NAME', OR
0*$A NULL STRING IF YOU WANT THE DATA-BASE AND TABLESPACE-NAMES TO
0*$BE IMPLIED.
0*$.SP 1
0*$DB2PUT WILL THEN ASSEMBLE AND EXECUTE THE 'CREATE TABLE' STATEMENT.
0*$.SP 1
0*$DB2PUT WILL NEXT INVOKE YOUR SUBRTNE AS FOLLOWS:
0*$.SP 1
0*$STRING=SUBRTNE('NAMES');
0*$.SP 1
0*$WHEN IT DOES SO, YOUR SUBRTNE PROCEDURE SHOULD RETURN A CHARACTER
0*$STRING OF THE FOLLOWING FORMAT:
0*$.SP 1
0*$COLUMN-NAME1,COLUMN-NAME2,...,COLUMN-NAMEN
0*$.SP 1
0*$THE COLUMN-NAMES IN THE RETURNED STRING SHOULD BE THE NAMES OF THE
0*$COLUMNS YOU WANT TO INSERT INTO THE TABLE.
0*$.SP 1
0*$DB2PUT WILL NEXT ENTER A LOOP IN WHICH YOUR SUBRTNE IS INVOKED
0*$DURING EACH ITERATION IN THE FOLLOWING MANNER:
0*$.SP 1
0*$STRING=SUBRTNE('VALUES');
0*$.SP 1
0*$YOUR SUBRTNE PROCEDURE SHOULD RETURN A CHARACTER STRING OF THE
0*$FOLLOWING FORMAT:
0*$.SP 1
0*$CONSTANT1,CONSTANT2,...,CONSTANTN
0*$.SP 1
0*$CONSTANT1 BEING THE DATA FOR THE FIRST COLUMN NAME SPECIFIED ABOVE,
0*$ETC.
0*$DB2PUT WILL THEN BUILD A DB2 INSERT STATEMENT OF THE FORM -
0*$.SP 1
0*$INSERT INTO TABLENAME (COLUMN-NAME1,COLUMN-NAME2,...,COLUMN-NAMEN)
0*$VALUES(CONSTANT1,CONSTANT2,...,CONSTANTN)
0*$.SP 1
0*$AND WILL INVOKE DB2 TO EXECUTE IT.  WHEN YOU HAVE NO MORE ROWS TO
0*$ADD TO THE TABLE, YOUR SUBRTNE SHOULD RETURN A NULL STRING (STRING
0*$OF LENGTH(0)).
0*$.SP 1
0*$TERM IS ALSO THE NAME OF A PROCEDURE YOU AS THE CALLER OF DB2PUT
0*$MUST SUPPLY.  IT WILL BE CALLED BY DB2PUT WITH ERROR MESSAGES IF
0*$AN ERROR IS ENCOUNTERED DURING PROCESSING.  DB2PUT DECLARES AND
0*$CALLS TERM AS FOLLOWS:
0*$.SP 1
0*$.NF
0*$DCL TERM ENTRY(CHAR(*) VAR);
0*$CALL TERM('ERROR ENCOUNTERED DURING DB2 PROCESSING');
0*$.FI L
0*$.SP 1
0*$DB2GET WILL RETURN ZERO AS A RETURN CODE IF NORMAL PROCESSING IS
0*$COMPLETED, AND ALL ROWS OF THE SPECIFIED TABLE HAVE BEEN
0*$SUCCESSFULLY COMPLETED.
0*$.SP 1
0*$NOTE THAT IN ORDER TO USE THE DB2PUT SUBROUTINE, YOUR PROGRAM MUST
0*$BE RUNNING UNDER THE DSN COMMAND OF TSO.  A TYPICAL SEQUENCE OF
0*$TSO COMMANDS TO ESTABLISH THIS ENVIRONMENT FOR A PROGRAM CALLED
0*$'TEST' IS SHOWN BELOW:
0*$.SP 1
0*$.NF
0*$DSN
0*$RUN PROG(TEST) PLAN(ABE) LIB(TEST.LOAD)
0*$.FI L
0*$.SP 1
 */
 DB2PUT: PROC(NAME,SUBRTNE,TERM) RETURNS(FIXED BIN(31,0));
   DCL NAME CHAR(*);
   DCL SUBRTNE ENTRY(CHAR(*)) RETURNS(CHAR(32767) VAR);
   DCL TERM ENTRY(CHAR(*) VAR);
   DCL (QSTRING,NAMES) CHAR(32767) VAR;
   DCL INSTR CHAR(256) VAR;
   DCL (PLIRETV,DIM) BUILTIN;
   DCL DSNTIAR ENTRY OPTIONS(ASM,INTER,RETCODE);
   DCL DATA_LEN FIXED BIN(31) STATIC INIT(120);
   DCL DATA_DIM FIXED BIN(31) STATIC INIT(8);
   DCL 1 ERROR_MESSAGE,
     2 ERROR_LEN FIXED BIN(15,0) UNAL INIT((DATA_LEN*DATA_DIM)),
     2 ERROR_TEXT(DATA_DIM) CHAR(DATA_LEN);
   DCL MSG CHAR(130) VAR;
   DCL COMMIT CHAR(20) STATIC INIT('COMMIT');
   EXEC SQL INCLUDE SQLCA;

   EXEC SQL WHENEVER SQLWARNING CONTINUE;
   GOTO BY_SQLERROR;
 SQLERROR:
   PUT STRING(MSG) EDIT('SQL ERROR, RETCODE=',SQLCODE)(A,F(10));
   CALL TERM(MSG);
 /*FETCH DSNTIAR; CAUSES 0C1 PROGRAM CHECK
 */CALL DSNTIAR(SQLCA,ERROR_MESSAGE,DATA_LEN);
   IF PLIRETV=0
     THEN DO I=1 TO DIM(ERROR_TEXT,1);
       CALL TERM(ERROR_TEXT(I));
       END;
   RETURN(SQLCODE);
 BY_SQLERROR:;
   EXEC SQL WHENEVER SQLERROR GOTO CREATE;
   QSTRING='DELETE FROM '××NAME;
   EXEC SQL EXECUTE IMMEDIATE QSTRING;
   EXEC SQL WHENEVER SQLERROR GOTO SQLERROR;
   GOTO BY_CREATE;
 CREATE:;
   EXEC SQL WHENEVER SQLERROR GOTO SQLERROR;
   IF SQLCODE^=-204 /* -204 IS UNDEFINED TABLE NAME */
     THEN GOTO SQLERROR;
   QSTRING=SUBRTNE('CREATE'); /* GO GET COLUMN SPECS */
   IF LENGTH(QSTRING)=0
     THEN GOTO SQLERROR; /* CALLER DOESN'T WANT TO CREATE TABLE */
   INSTR=SUBRTNE('IN'); /* GET IN DATABASE/TABLESPACE NAMES */
   IF INSTR^=''
     THEN INSTR=' IN '××INSTR;
   QSTRING='CREATE TABLE '××NAME××' ('××QSTRING××')'××INSTR;
   EXEC SQL EXECUTE IMMEDIATE QSTRING;
 BY_CREATE:;
   NAMES=SUBRTNE('NAMES'); /* GET LIST OF COLUMN NAMES */
   DO FOREVER=1 REPEAT FOREVER;
     QSTRING=SUBRTNE('VALUES');
     IF LENGTH(QSTRING)=0
       THEN LEAVE;
     QSTRING='INSERT INTO '××NAME××' ('××NAMES××') VALUES ('××QSTRING××
       ')';
     EXEC SQL EXECUTE IMMEDIATE QSTRING;
     END;

   EXEC SQL EXECUTE IMMEDIATE COMMIT;
   RETURN(0); /* SUCCESSFUL COMPLETION */
   END DB2PUT;
