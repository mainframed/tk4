.HE GENERALIZED UTILITIES - GPPP
.HE GENERAL PURPOSE PREPROCESSOR
.PL 55
.PN 0
.PA
.SS
.NF
08/19/81
AUTHOR:  HOWARD GILBERT, YALE COMPUTER CENTER
         MODIFIED BY ALAN BEALE, MWPLC
         MODIFIED BY T. SMITH, KIM
SOURCE MODULE NAME:  GPPPDOC, GPPP, GPPPSYM, GPPPTCA, MACINFO,
                     MACRO, NULLPGM, PLILOAD, PTRIN, SYSLIBR,
                     GETWORD, PARSEGP
DOCUMENTATION ID:  NONE
.fi l
.pa
.ce 1
TABLE OF CONTENTS
.sp 1
 Abstract ------------------------------------------3
 GPPP Usage-----------------------------------------4
 INPUT FORMATS--------------------------------------4
 Macro Call Syntax----------------------------------5
 Tokenization---------------------------------------5
 Macro Operands-------------------------------------6
 OUTPUT FORMATS-------------------------------------7
 Punch Output---------------------------------------7
 Listing Format-------------------------------------8
 Message File Format--------------------------------8
 EXECUTION OPTIONS----------------------------------9
 BUILT-IN MACROS-----------------------------------10
 USE macro-----------------------------------------11
 PRINT Macro---------------------------------------11
 PAGE Macro----------------------------------------11
 TITLE Macro---------------------------------------12
 INCLUDE Macro-------------------------------------12
 GEN Macro-----------------------------------------13
 Writing Grammars----------------------------------14
 THE MACRO GRAMMAR---------------------------------14
 GRAMMAR Macro-------------------------------------15
 DEFMAC Macro--------------------------------------15
 MACRO Macro---------------------------------------16
 PARAMETER Macro-----------------------------------17
 LABEL Macro---------------------------------------20
 PARSE Macro---------------------------------------21
 OPEN and GET Macros-------------------------------22
 PUT Macro-----------------------------------------23
 NOTE Macro----------------------------------------23
 MISCELLANEOUS FACILITIES--------------------------25
 Additional Routines-------------------------------25
 File Processing-----------------------------------26
 Setup Routines------------------------------------26
 Global Variables----------------------------------27
 Conditional Compilation---------------------------28
 Appendix A - Symbol Tables------------------------29
 SYMBOL TABLE ROUTINES-----------------------------30
 Appendix B - GPPP and MACRO Diagnostics-----------32
.pa
.ce 1
I. Abstract
A frequent problem in the development of large software projects is
the need to extend the facilities of a programming language, for
instance, to add new data types, and statements to process them.  A
common solution to this problem is the use of a preprocessor (i.e.,
a translator from an extended programming language to a base
language).  Both the IBM assembler and PL/I compilers include a
preprocessor to translate "macro" statements to base language
statements.
.sp 1
Unfortunately, both of these preprocessors have significant
drawbacks, which have tended to give macro techniques a bad
reputation.  These preprocessors allow a programmer to define
transformation macros, but only in a restricted language without
most of the amenities of languages such as PL/I.  For instance, the
macro language allows no control structures other than nested macro
calls and conditional branching.  Quite apart from their
clumsiness, these macro languages are interpretive, and therefore
unacceptably slow for major applications.  The General Purpose
PreProcessor (GPPP) is a preprocessor writing system which
circumvents these problems by allowing macro statements to be
written in full PL/I, thereby providing both convenience and
efficiency.
.sp 1
GPPP may be used as either a PL/I or a basic assembler language
(BAL) preprocessor.  The input to GPPP consists of a mixture of
base language statements and macro calls, which have the appearance
of PL/I statements.  Base language statements are copied "as is" to
the output file.  Macro calls, on the other hand, are passed to
pre-compiled macro routines, which may generate base language
statements to be written to the output file in place of the macro
call.  Macro routines are organized into load modules called
"grammars", which are loaded by GPPP upon request.
.sp 1
The writing of grammars is a typical preprocessor application.
GPPP provides a standard grammar named MACRO which preprocesses
macro-writing macros, such as: PARAMETER, to define the syntax of a
macro parameter; PUT, to generate output statements; and NOTE, to
generate a diagnostic message.  MACRO is written in its own
extended language.  The MACRO statements are described later in
this document.
.pa
.ce 1
II. GPPP Usage
.sp 1
INPUT FORMATS
.sp 1
General Information
.sp 1
GPPP reads input from the SYSIN file, plus optionally from members
of a SYSLIB data set if the INCLUDE statement is used.  Input data
must consist of card images, where columns 73 through 80 may
contain sequence numbers, and are otherwise ignored.  Columns 1 and
72 require special processing, depending on the base language.  In
the PL/I case, column 1 may be used for carriage control, as
standard in PL/I, and column 72 is unrestricted.  In the BAL case,
both columns 1 and 72 are used normally in assembler statements,
but must be blank for macro calls.
.sp 1
GPPP offers two different mechanisms for distinguishing macro
statements and base language statements.  The GPPP user may specify
an ID character ("?" by default), which is used to identify macro
statements.  In BAL, the ID character appears in column 1 of the
first card of a macro call.  In PL/I, the ID character appears in
the normal program area (columns 2 through 72), immediately
preceding (except possibly for a label) a macro call.  In either
case, the macro call extends until the next semicolon not contained
in a comment or quoted string, proceeding to continuation cards as
necessary.  In the BAL environment, the contents of the final card
of a macro call after the terminating semicolon are ignored.
.sp 1
Alternately, GPPP may be used with no ID character.  In the BAL
case, this means that all input records are assumed to contain
macro calls, except for cards between a "GEN;" statement and an
"@ENDGEN;" statement, as described below.  In the PL/I case, this
means that macros are recognized by context (i.e., by their
appearance after a semicolon or THEN, ELSE or OTHERWISE keyword).
Assignment statements, and any other statements for which no
macro routine is provided, are treated as base language statements.
.sp 1
The choice between the ID and NOID modes of GPPP generally depends
on the nature of the application; if most input statements will be
macro calls, the NOID mode is likely to be preferable and
conversly.  In many cases, a grammar may require one of ID or NOID
to operate correctly.  (For example, the MACRO grammar requires the
use of an ID character, so that the MACRO OPEN, GET and PUT
statements can be distinguished from the corresponding PL/I
statements.)
.sp 1
Macro Call Syntax
.sp 1
The general syntax of a macro call is as follows:
.sp 1
.in 5
{label:}  verb {operand...} {keyword{(value)}...};
.in 0
.sp 1
Some examples of macro calls are as follows:
.sp 1
.in 5
.nf
QUIT;
PART4: SECTION;
SEND MESSAGE TO(FRED) BY(USMAIL);
PARAMETER (LENGTH,LEN) FIXED DEFAULT(1);
NOTE 8 "VARIABLE NOT KNOWN";
.fi l
.in 0
.sp 1
The verb identifies the statement, and is used to determine the
grammar routine which will process the statement.  The names of the
keywords and the form of the label, operands, and keyword subfields
(when permitted) are specified by the macro routine for the verb.
.sp 1
Note:  When BAL is the base language, GPPP will also treat a
statement with the syntax of a PL/I assignment statement as a
macro call.  In this case, the verb is implicitly defined as
%ASSIGN%.
.sp 1
Tokenization
.sp 1
Before explaining the handling of operands, a digression into
statement "tokenization" is required.  Normally, an operand is
simply a "word", i.e., a string of characters containing no blanks,
commas, semicolons, mayonnaise or glue.  This basic definition can
be modified by the use of special characters.  Either the single
quote (') or double quote (") may be used to demarcate character
strings, possibly including special characters.  Within such a
string, quotes of the same type as the demarcation character must
be written twice (e.g., "'" is a valid string containing one single
quote, whereas """" is required to indicate one double quote).  The
two quote marks have different semantics, best illustrated by an
example.  Consider a macro X with a single positional parameter.
Then the parameter of the macro call
.sp 1
.in 5
X 'ABC'
.in 5
.sp 1
is 'ABC' including the quotes, whereas for
.sp 1
.in 5
X "ABC"
.in 0
.sp 1
the parameter is ABC, without any quotes.
.sp 1
A similar construction is the parenthesized string, beginning with
an open parenthesis ("(") and ending with a close parenthesis
(")").  Parentheses in such a string must be balanced (i.e. for
each open parenthesis in the string a corresponding close parenthesis
must appear later).  Naturally, parentheses in a quoted string are
not counted.  The outermost parentheses in a string are not
considered part of the value.  For example, in
.sp 1
.in 5
X (A+B(C))
.in 0
.sp 1
the operand is A+B(C).
.sp 1
One other important construct is the comment, consisting of text
between a "/*" and a "*/".  Quotes and parentheses within a comment
are considered insignificant (as are comment delimiters with a
quoted string).  Generally, comments are ignored or replaced by a
blank, as described below.
.sp 1
A character is said to be "unenclosed" if it is not in a quoted
string, a comment or an inner parenthesize string.
.sp 1
Macro Operands
.sp 1
Macro calls may have positional and/or keyword parameters.
Positional parameters must appear in order, before any keyword
parameters.  A macro may specify that some number of positional
parameters must be present.  A positional parameter may be a word
or a quoted or parenthesized string.  It may not take the form of a
word followed immediately by a parenthesized string, as this is
assumed to represent a keyword parameter.  Thus, if the example
macro X has a required positional parameter, the call
.sp 1
.in 5
X A(B)
.in 0
.sp 1
is illegal, while
.sp 1
.in 5
X "A(B)"
.in 0
.sp 1
could be used to produce the (presumably) intended effect.
.sp 1
Keyword parameters have the format keyword{ (value) }, where (value)
meets the syntax requirements for a parenthesized string.  If no
value is specified, an implicit value consisting of a single blank
is used.  The value is returned as is, so that for the keyword
A("BC"), the value if A is "BC", including the quotes.
.sp 1
Note:  Whenever an unquoted, unparenthesized word (without a
subfield) appears in a position where an optional positional
parameter may appear, the word is first checked against any
permissible keywords.  If it matches, the word is considered
a keyword rather than a positional parameter.
.sp 1
At the discretion of the macro routine, either positional
parameters or keyword values may be in a list format.  A list is a
series of items separated by unenclosed commas.  In the positional
case, the list should be enclosed in parentheses; if it is not, the
value is treated as a single list element.  Note that in
interpreting a list element, strings of blanks and coments not in
quotes are replaced by a single blank (or removed if at either end
of the value).  Thus, the value of the keyword X in
X(A , B+/* PLUS */C) is a list of two elements, the first "A" and
the second "B+ C" (without the quotes).  List items may be in
double quotes, in which case the quotes are removed from the
values.  For instance, the elements of X("A,B",C) are "A,B" and "C"
(without the quotes), unlike X(A,B,C), which has three values.
.sp 1
Other refinements in the syntax of macro calls are permitted.
Since these apply to rather special cases, they are treated later,
in the discussion of the MACRO grammar.
.sp 1
OUTPUT FORMATS
.sp 1
Punch Output
.sp 1
The output of GPPP consists of a "punch" file (SYSPUNCH) containing
base language statements, as well as a listing file (SYSPRINT) and
a message file (SYSTERM).  The SYSPUNCH output contains copied and
generated statements; it may also, at user option, contain
annotations (i.e., interspersed comments containing the source
macro calls which generated succeeding statements).  The
terminating semicolon is removed from an annotated macro call to
avoid producing PL/I "COMMENT CONTAINS SEMICOLON" messages at
compile-time.  The SYSPUNCH output is always numbered in columns 73
through 80.  The first record generated by an input line has the
same number as the input line; succeeding generated reocrds have
their numbers incremented by a user-specified value (1 by default).
If the input data set is not numbered, the input lines are numbered
by 1000, and then the output lines are handled as in the numbered
case.
.sp 1
Listing Format
.sp 1
The SYSPRINT file contains a listing of the input and output
statements, with embellishments to aid interpretation, and possibly
with interspersed error messages.  Each line of the listing
contains the following information:
.sp 1
.in 5
.hi 3
 - The INCLUDE nesting level
 - The base language statement number
 - A sequential line number
 - The source text
 - The (possibly generated) input or ouptut sequence number
 - The origin of the line (the name of the generating macro,
or the current INCLUDE member, preceded by a period).
.hi 0
.in 0
.sp 1
The line number field may be modified by several special notations.
A line number preceded by several hyphens indicates display of the
remainder of a line previously interrupted, as by an error message
or output generation. If the line number is followed by a plus
sign (+), it indicates a macro-generated output line, while if it
is followed by a minus sign (-), the line is an input line which
has been suppressed from the SYSPUNCH output.
.sp 1
Message File Format
.sp 1
The message file (SYSTERM) is a detailed diagnostic listing.  Each
message printed includes the following information:
.sp 1
.in 5
.hi 3
 - A message id
 - The sequence number of the responsible input record
 - A severity level (where I, W, E and S represent severities
of 0, 4, 8 and 12 respectively)
.hi 0
.in 0
.sp 1
The sequence number may be immediately followed by a G, to indicate
an error in a macro call generated by the indicated line, rather
than in the line itself.  Each message is preceded by a listing of
the text to which it applies.  For a syntax error, the point at
which the error was detected is flagged by a question mark (?).
.sp 1
If, horrible to contemplate, a PL/I error occurs in GPPP or a
grammar, the resulting message is also directed to SYSTERM.
.sp 1
EXECUTION OPTIONS
.sp 1
The basic operation of GPPP is directed by its parameter string
(from the EXEC card), whose syntax is:
.sp 1
.nf
     _________________________________________________________
     ×R×D×                                                   ×
     ×E×E×                                                   ×
     ×Q×F×                                                   ×
     ×U×A×                                                   ×
     ×I×U×                                                   ×
     ×R×L×                                                   ×
     ×E×T×                                                   ×
     ×D× ×  OPTIONS                                          ×
     ×_×_×___________________________________________________×
     ×X× ×  language                                         ×
     ×_×_×___________________________________________________×
     × × ×  ID(char)                                         ×
     × ×X×  NOID                                             ×
     ×_×_×___________________________________________________×
     × × ×  NUM                                              ×
     × ×X×  NONUM                                            ×
     ×_×_×___________________________________________________×
     × × ×  INCR(incr)                                       ×
     ×_×_×___________________________________________________×
     × ×X×  ANNOTATE(ON)                                     ×
     × × ×  ANNOTATE(OFF)                                    ×
     ×_×_×___________________________________________________×
     × × ×  DEBUG                                            ×
     ×_×_×___________________________________________________×
     × × ×  PARM(value)                                      ×
     ×_×_×___________________________________________________×
     × × ×  USE(grammar)                                     ×
     _________________________________________________________
.fi l
.in 0
.sp 1
The rules for the options are as follows:
.sp 1
.hi 5
language must be either BAL or PLI, specifying the language for
which output is to be produced.
.sp 1
ID(char) specifies the character to be used to identify macro
calls.
.sp 1
NOID specifies that no macro identifier is to be used.
.sp 1
NUM states that all input (including INCLUDED data) contains
sequence numbers in columns 73 through 80.
.sp 1
NONUM states that input columns 73 through 80 are to be ignored,
and sequence numbers generated.
.sp 1
INCR(incr) specifies the sequence number increment for output
records produced from the same input record.
.sp 1
ANNOTATE(ON×OFF) specifies whether the SYSPUNCH output is to be
annotated with the text of input macro calls.
.sp 1
DEBUG may be specified to set a switch available to grammar
routines.  It might be used to cause the output of grammar-
related debugging information.
.sp 1
PARM(value) may be specified to assign an up-to-eight character
value to the variable SYSPARM, which can be referenced by
grammar routines to influence the statements generated.
.sp 1
USE(grammar,...) may be specified to cause the use of one or more
grammars.  If the USE option is omitted, grammars can be
invoked later by the USE macro, described below.
.hi 0
.sp 1
The default specification is:
.sp 1
.in 5
PLI ID(?) NONUM INCR(1) ANNOTATE(ON) PARM()
.in 0
.sp 1
The execution-time parameter string is used to generate a call to a
built-in OPTIONS macro; if an error is detected, this macro call
will be printed as the text in error.  In most cases, if the
parameter string is erroneous, GPPP will terminate immediately.
.sp 1
BUILT-IN MACROS
.sp 1
In addition to macros interpreted by grammar routines, GPPP
supports a few built-in macros, which can be used with any (or no)
grammar.
.sp 1
The USE Macro
.sp 1
The USE macro is used to establish one or more grammars.  Its
syntax is as follows:
.sp 1
.in 5
.nf
_________________________________________________________
×                                                       ×
× USE (grammar,...);                                    ×
×                                                       ×
_________________________________________________________
.fi l
.in 0
.sp 1
Example:  Establish the use of the MACRO grammar (where ? is defined
as the ID character).
.sp 1
.in 5
? USE (MACRO);
.in 0
.sp 1
The PRINT Macro
.sp 1
The PRINT macro is used to control the output listing.  Its syntax
is as follows:
.sp 1
.in 5
.nf
_________________________________________________________
×                                                       ×
× PRINT {ON   };                                        ×
×       {OFF  }                                         ×
×       {GEN  }                                         ×
×       {NOGEN}                                         ×
×                                                       ×
_________________________________________________________
.fi l
.in 0
.sp 1
PRINT OFF and PRINT NOGEN suppress the printing of all statements
and of generated statements respectively.  PRINT ON and PRINT GEN
can be used to restore such printing.
.sp 1
Example:  Suppress the printing of statements generated by the
expansion of a macro call:
.sp 1
.in 5
.nf
? PRINT NOGEN;
? SYSUT1: DCB QSAM DDNAME('SYSUT1') USAGE(GET,LOCATE);
? PRINT GEN;
.fi l
.in 0
.sp 1
The PAGE Macro
.sp 1
The PAGE macro is used to force the output listing to a new page.
It also generates a base language statement with the same effect on
SYSPUNCH.  Its syntax is as follows:
.sp 1
.in 5
.nf
_________________________________________________________
×                                                       ×
× PAGE ;                                                ×
×                                                       ×
_________________________________________________________
.fi l
.in 0
.sp 1
The TITLE Macro
.sp 1
The TITLE macro is used to define a title for the output listing
and force a new page.  In BAL, a statement with similar effect is
generated on SYSPUNCH.  The syntax of TITLE is as follows:
.sp 1
.in 5
.nf
_________________________________________________________
×                                                       ×
× TITLE "listing title";                                ×
×                                                       ×
_________________________________________________________
.fi l
.in 0
.sp 1
Until a TITLE macro appears, the first input line is used as a
title.
.sp 1
Example:  Skip to a new page and change the title to "MATRIX
INVERSION ROUTINE".
.sp 1
.in 5
? TITLE "MATRIX INVERSION ROUTINE";
.in 0
.sp 1
The INCLUDE Macro
.sp 1
The INCLUDE macro is used to include source from a partitioned data
set (PDS) member.  The PDS must be allocated to the DDname SYSLIB.
.sp 1
.in 5
.nf
_________________________________________________________
×                                                       ×
× INCLUDE member {NOPRINT};                             ×
×                                                       ×
_________________________________________________________
.fi l
.in 0
.sp 1
Up to ten levels of nested INCLUDE are allowed.  INCLUDed text is
always printed, unless PRINT OFF is in effect or NOPRINT is
specified on the INCLUDE.  If the PRINT macro is used in INCLUDEd
text, its effect is temporary, that is, the previous specification
is restored at the end of the member.
.sp 1
Example:  INCLUDE member DECLARE of the SYSLIB data set. (Note:
the NOID options is in use).
.sp 1
.in 5
? INCLUDE DECLARE;
.in 0
.sp 1
The GEN Macro
.sp 1
The GEN macro is used to generate base language statements.  Its
syntax is as follows:
.sp 1
.in 5
.nf
_________________________________________________________
×                                                       ×
× GEN {"statement"};                                    ×
×                                                       ×
_________________________________________________________
.fi l
.in 0
.sp 1
If a statement is specified, it is generated to the SYSPUNCH output
file.  GEN may be used without an operand only in a BAL
environment.  In this case, all following input records are treated
as BAL statements and copied directly to SYSPUNCH, until a card
containing only an "@ENDGEN;" statement is encountered.  When BAL
is used with NOID, the GEN macro is the only mechanism for
inclusion of BAL statement (other than comments) in the input
stream.
.sp 1
Example:  Generate a PL/I %INCLUDE statement while using % as the
ID character.  (A %INCLUDE statement in the text itself will
be treated as a call to the INCLUDE macro).
.sp 1
.in 5
% GEN "% INCLUDE COMMON(FILES);";
.in 0
.sp 1
Example:  Generate several assembler statements in a program
preprocessed with the NOID option.
.sp 1
.in 5
.nf
GEN;
L R1,PARMADDR
LINK EPLOC=ROUTINE
ST R15,RETCODE
@ENDGEN;
.fi l
.in 0
.pa
.ce 1
III. Writing Grammars
.sp 1
GENERAL INFORMATION
.sp 1
Grammars are PL/I load modules, containing a grammar initialization
procedure and one or more macro procedures.  One macro procedure
may handle several different macros, through the same or different
entry points.  Grammar load modules are dynamically loaded by GPPP
and therefore cannot execute independently.  For this reason, they
must be link-edited as if they were to be called by FETCH, as
described in the PL/I Programmer's Guide.  Like FETCHed procedures,
they may not use FETCH, RELEASE, CONTROLLED variables or FILES,
except those passed by GPPP.  (See below for information about file
usage).
.sp 1
The initialization routine, which must be the load module entry
point, is called when a USE statement or USE run-time option is
encountered.  It is this routine's responsibility to define the macro
procedures of the grammar.  The macro procedures are called whenever
the macro verb is encountered in a macro call in the input
text.  Both the initialization routine and the macro routine are
passed a structure named GPPPTCA, which contains global data and
interfaces to GPPP proper.  Most of the GPPP facilities are used by
way of MACRO statements, translated to PL/I by GPPP using the MACRO
grammar.  GPPP also supports operations on symbol tables and work
files.  These are described later.
.sp 1
Note:  The MACRO grammar should always be used in ID mode, due to
the use of macros with the same names as PL/I statements.  The
preprocessed output of MACRO must be compiled using the INCLUDE
option, with SYSLIB addressing the GPPP source library so that the
GPPPTCA and symbol table mappings may be included.
.sp 1
THE MACRO GRAMMAR
.sp 1
Introduction
.sp 1
The macros defined by the MACRO grammar and their functions are as
follows:
.sp 1
.in 5
GRAMMAR - To define a grammar initialization routine.
.sp 1
DEFMAC - To specify the macro verbs and procedures for a grammar.
.sp 1
MACRO - To define a macro procedure or entry point.
.sp 1
PARAMETER - To specify the format and usage of a macro parameter.
.sp 1
LABEL - To specify the label usage of a macro.
.sp 1
PARSE - To extract label and parameter values from a source macro call.
.sp 1
GET - To obtain an entry from a list-type parameter.
.sp 1
OPEN - To prepare a list for the use of GET.
.sp 1
PUT - To generate replacement text for a macro call.
.sp 1
NOTE - To generate an error message or warning.
.sp 1
.in 0
The GRAMMAR Macro
.sp 1
The GRAMMAR macro is used in place of a PROC statement for a
grammar initialization routine.  its syntax is as follows:
.sp 1
.in 5
.nf
_________________________________________________________
×                                                       ×
× name:  GRAMMAR {(macro,...)};                         ×
×                                                       ×
_________________________________________________________
.fi l
.in 0
.sp 1
name is the name of the grammar, and is used as the name of the
generated procedure.
.sp 1
(macro,...) is a list of macros defined for this grammar.  Each
name in the list is assumed to be both the macro verb and the
name of the supporting procedure.
.sp 1
Example:  Use the GRAMMAR macro to begin a grammar which defines ENQ
and DEQ macros.
.sp 1
.in 5
? EQDQ: GRAMMAR (ENQ,DEQ);
.in 0
.sp 1
The DEFMAC Macro
.sp 1
DEFMAC is used to define verbs and procedure names for macros
supported by a grammar.  Its syntax is as follows:
.sp 1
.in 5
.nf
_________________________________________________________
×                                                       ×
× DEFMAC (macro,...) {ENTRY(name)};                     ×
×                                                       ×
_________________________________________________________
.fi l
.in 0
.sp 1
(macro,...) is a list of supported macro verbs.
.sp 1
ENTRY(name) specifies the procedure or entry which is to process
the named verbs.  If the ENTRY keyword is omitted, each macro
routine in the verb list is assumed to be supported by a
procedure with the same name as the corresponding verb.
.sp 1
Normally, a grammar initialization routine need contain only a
GRAMMAR macro, optional DEFMAC macros, and an END statement.
Additional statements may also be present to initialize EXTERNAL
variables for use by macro routines.
.sp 1
Example:  Sepcify that the macro verbs BACKSPACE and REWIND are to
be handled by the procedure name TAPEIO.
.sp 1
.in 5
? DEFMAC (BACKSPACE,REWIND) ENTRY(TAPEIO);
.in 0
.sp 1
The MACRO Macro
.sp 1
The MACRO macro is used in place of a PROC or ENTRY statement for a
macro processing routine.  Its syntax is as follows:
.sp 1
.in 5
.nf
_________________________________________________________
×                                                       ×
× name: MACRO {length} {ENTRY};                         ×
×                                                       ×
_________________________________________________________
.fi l
.in 0
.sp 1
name is the name to be given to the macro procedure or entry.
.sp 1
length is the maximum length of the value for any macro parameter.
The default is 256.  Note that when list-type parameters are
permitted, this length is the maximum length of the entire
parameter list, and not merely of an individual element.
.sp 1
ENTRY may be specified to indicate that this macro processor is an
entry point to an already started macro processor.
.sp 1
The MACRO statement expands into a PROC or ENTRY statement with
three parameters:  STRING (the source of the macro call), GPPPTCA
(the GPPP global communication structure) and MACNAME (the macro
verb name).  The use of MACNAME allows a procedure used for several
similar verbs to determine the one for which it is currently
processing.
.sp 1
Example:  Begin a macro procedure named MESSAGE, with maximum
parameter length 500.
.sp 1
.in 5
MESSAGE:  MACRO 500;
.in 0
.sp 1
The PARAMETER Macro
.sp 1
The PARAMETER macro defines the syntax of one parameter or set of
related parameters.  A macro procedure will usually contain one or
more PARAMETER macros, to define the syntax of a macro call.  (The
use of PARAMETER is not necessary if a macro procedure does not use
the GPPP parsing facility.)  For positional parameters, the order
of the PARAMETER macros defines the order in which the parameters
are expected to occur in a macro call.  Operands of the PARAMETER
macro are as follows:
.sp 1
.nf
     _________________________________________________________
     ×R×D×                                                   ×
     ×E×E×                                                   ×
     ×Q×F×                                                   ×
     ×U×A×                                                   ×
     ×I×U×                                                   ×
     ×R×L×                                                   ×
     ×E×T×                                                   ×
     ×D× ×  OPERANDS                                         ×
     ×_×_×___________________________________________________×
     ×X× ×  (name,...)                                       ×
     ×_×_×___________________________________________________×
     × × ×  POSITIONAL                                       ×
     × ×X×  KEYWORD                                          ×
     ×_×_×___________________________________________________×
     × × ×  REQUIRED                                         ×
     ×_×_×___________________________________________________×
     × × ×  SUBFIELD                                         ×
     ×_×_×___________________________________________________×
     × × ×  LIST                                             ×
     ×_×_×___________________________________________________×
     × ×X×  CHAR                                             ×
     × × ×  FIXED                                            ×
     × × ×  BIT                                              ×
     ×_×_×___________________________________________________×
     × × ×  DEFAULT(value)                                   ×
     ×_×_×___________________________________________________×
     × × ×  ALIAS(Name)                                      ×
     ×_×_×___________________________________________________×
     × × ×  PREPOSITION                                      ×
     ×_×_×___________________________________________________×
     × × ×  SUBSCRIPT(name)                                  ×
     ×_×_×___________________________________________________×
     × × ×  ENDSCAN                                          ×
     _________________________________________________________
.fi l
.in 0
.sp 1
(name,...) has several functions.  For keyword parameters, it
defines the keywords which identify this parameter.  It also
defines the name of the PL/I variable which is to contain the
returned value, with the following qualifications.
.in 5
.sp 1
- For other that a BIT parameter, the first name in the list
is used as the variable name (unless ALIAS is used to
specify another name).  The other names in the list are not
used.
.sp 1
- For a BIT parameter, each name in the list is defined as an
independent variable name.
.in 0
.sp 1
Declarations for these variables are generated by the macro
expansions, and so should not be supplied by the programmer.
Note that there is never any reason to specify more than one
name for a positional parameter.
.sp 1
POSITIONAL specifies that this parameter is positional.  Any
PARAMETER macros specifying POSITIONAL must precede any
defining KEYWORD parameters.
.sp 1
KEYWORD specifies that this parameter is a keyword.  If neither
POSITIONAL nor KEYWORD is specified, KEYWORD is assumed.
.sp 1
REQUIRED may be specified for a POSITIONAL parameter to indicate
that the presence of the parameter is mandatory.  PARAMETER
macros for REQUIRED parameters must precede any for non-REQUIRED
parameters.
.sp 1
SUBFIELD may be specified for a KEYWORD parameter to indicate that
a subfield is required (i.e., that the keyword may not be
specified without a following parenthesized value).
.sp 1
LIST specifies that the parameter may be a list.  To access
elements of the source list, the OPEN and GET macros must be
used;  after each GET macro the parameter variable will contain
the next value in the list.  Note that the combined size of
all list elements must be less than the maximum length
specified on the MACRO statement.
.sp 1
CHAR specifies that the parameter value is to be interpreted as a
character string (or maximum length as specified by a previous
MACRO statement).  For a LIST parameter, each list element is
interpreted as a character string.
.sp 1
FIXED specifies that the parameter value is to be interpreted as a
FIXED BIN(15,0) value.  If the source parameter is not an
integer constant, an error message will be produced and a
value of zero used.  For a LIST parameter, each list element
is interpreted as an integer.
.sp 1
BIT specifies that the parameter value is a single bit, indicating
whether the corresponding keyword was present.  If more than
one parameter name is specified for a BIT parameter, each name
is defined as a separate value, but at most one will be set to
'1'b.  BIT and LIST are mutually exclusive.
.sp 1
DEFAULT(value) specifies the value to be assumed if the parameter
is omitted.  It may not be specified with BIT.  For a LIST
parameter, it defines a default for the entire list, rather
than for each element.  Note:  In general, the default value
cannot be distinguished from the same value specified
explicitly.  However, if DEFAULT is omitted for a CHAR
parameter, the null (length 0) string is used as the default.
Since any explicit parameter value always has a non-zero
length, whether the parameter was allowed to default can be
reliably determined in this case.  If DEFAULT is omitted for a
FIXED parameter, DEFAULT(0) is assumed.
.sp 1
ALIAS(name) may be used to specify a name for the PL/I variable for
a keyword other than the keyword identifier.
.sp 1
PREPOSITION is a special option which may be specified for keyword
parameters only.  A keyword with this options may be used as a
preposition (i.e., if an explicit subfield is not specified,
the next parameter is treated as a subfield).  For
example, if FROM were a prepositional keyword, the string
"FROM A+B" would be interpreted the same as "FROM(A+B)".
.sp 1
SUBSCRIPT(name) is a special option which may be specified for
positional parameters only.  It specifies that the positional
parameter may be followed by a subscript-like parenthesized
string, which is to be treated as a subfield of the keyword
"name".  For instance, if the two PARAMETER macros
.sp 1
.in 5
PARAMETER VAR POSITIONAL REQUIRED SUBSCRIPT(DIMENSION);
.in 5
PARAMETER DIMENSION KEYWORD SUBFIELD FIXED;
.in 0
.sp 1
were used, the two operand strings "X(10)" and "X dimension(10)"
would be treated identically.
.sp 1
ENDSCAN is a special option which may be specified for POSITIONAL
parameters only.  It specifies that if the parameter is
present, the statement parse is to terminate without checking
for succeeding parameters.  This feature can be used to
support macros with several different forms.
.sp 1
Example:  Define the (above) syntax for the PARAMETER macro.
.sp 1
.in 5
.nf
? PARAMETER NAME POSITIONAL REQUIRED LIST;
? PARAMETER (POSITIONAL,KEYWORD) BIT;
? PARAMETER REQUIRED BIT;
? PARAMETER SUBFIELD BIT;
? PARAMETER LIST BIT;
? PARAMETER (CHAR,FIXED,BIT) BIT;
? PARAMETER DEFAULT SUBFIELD;
? PARAMETER ALIAS SUBFIELD;
? PARAMETER PREPOSITION BIT;
? PARAMETER SUBSCRIPT SUBFIELD;
? PARAMETER ENDSCAN BIT;
.fi l
.in 0
.sp 1
The LABEL Macro
.sp 1
The LABEL macro is used to specify that a label is permitted (or
required) on a macro call.  The syntax of LABEL is as follows:
.sp 1
.in 5
.nf
_________________________________________________________
×                                                       ×
× LABEL name {REQUIRED};                                ×
×                                                       ×
_________________________________________________________
.fi l
.in 0
.sp 1
name specifies the name of the PL/I variable into which the label
on the source macro call is to be stored.  (It will be set to
the null string if no label is present.)
.sp 1
REQUIRED specifies that a label must be present.  If REQUIRED is
not specified, the label is considered optional.
.sp 1
If a LABEL macro is used, it must precede all PARAMETER macros in
the same routine.  Only one LABEL macro may be present in a
routine; if none is present, a label will not be accepted on a
corresponding macro call.
.sp 1
Note.  When GPPP oeprates in NOID mode with PL/I as the base
language, a label on a source macro call is interpreted as a PL/I
label rather than as a GPPP label.  Thus, a macro routine which may
be used in NOID mode should not use the LABEL macro.
.sp 1
Example:  Define the syntax (as described above) for the MACRO
macro.
.sp 1
.in 5
.nf
? LABEL NAME REQUIRED;
? PARAMETER LENGTH POSITIONAL FIXED DEFAULT(256);
? PARAMETER ENTRY BIT;
.fi l
.in 0
.sp 1
The PARSE Macro
.sp 1
The PARSE macro is used to cause a macro call to be parsed
according to the syntax specified by previous PARAMETER macros.
PARSE may be used even if no PARAMETER macros have been specified,
in which case it simply verifies that there were no operands on the
macro call.  Note:  If errors are detected in the parsing process,
control does not return to the calling procedure.  The syntax of
PARSE is as follows:
.sp 1
.in 5
.nf
_________________________________________________________
×                                                       ×
× PARSE {POSITION(variable)} {SPECIAL};                 ×
×                                                       ×
_________________________________________________________
.fi l
.in 0
.sp 1
POSITION(variable) may be used to specify a FIXED BIN variable into
which is to be stored the position in the macro call string at
which parsing was terminated.  If a PARAMETER macro specifying
ENDSCAN is present, this operand is useful for identifying the
part of the macro call which has not yet been parsed.
.sp 1
SPECIAL may be specified to indicate that the GPPP parser should
not treat the first item (other than a label) in the macro
call as the verb.  This operand should be used for a
"%ASSIGN%" macro processor, where the verb is not actually
present in the macro call.
.sp 1
The OPEN and GET Macros
.sp 1
The OPEN and GET macros are used to extract elements from list-type
parameters.  GET obtains the next element from a list and stores it
in the variable of the same name.  (If there are no more elements
in the list, the BIT variable ENDLIST is set to '1'b to so
indicate; the value returned will be the null string for a CHAR
list, or 0 for a FIXED list.)  OPEN is used to prepare for the use
of GET; the effect of GET on a list which has not been OPENed is
undefined.  The syntax of GET and OPEN is as follows:
.sp 1
.in 5
.nf
_________________________________________________________
×                                                       ×
× OPEN listname;                                        ×
× GET                                                   ×
×                                                       ×
_________________________________________________________
.fi l
.in 0
.sp 1
listname is the name of the list parameter to be OPENed or
accessed.
.sp 1
Note:  Only one list can be effectively OPEN at a time (i.e., after
a list is OPENed, the elements of any previously OPEN list are no
longer accessible to GET).
.sp 1
Example:  Define a list paramter NUMBERS, and compute the sum of
the numbers in the list.
.sp 1
.in 5
.nf
? PARAMETER NUMBERS SUBFIELD FIXED LIST;
? PARSE;
  .
  .
  .
? OPEN NUMBERS;
SUM=0;
? GET NUMBERS;
DO WHILE(^ENDLIST);
  SUM=SUM+NUMBERS;
  ? GET NUMBERS;
  END;
.fi l
.in 0
.sp 1
The PUT Macro
.sp 1
The PUT macro is used to generate replacement text for a macro
call.  The syntax of PUT is as follows:
.sp 1
.in 5
.nf
_________________________________________________________
×                                                       ×
× PUT "shorthand expression";                           ×
×                                                       ×
_________________________________________________________
.fi l
.in 0
.sp 1
The "shorthand expression" is an abbreviated form of string
expression, with non-constant text enclosed in "<" and ">"
brackets, and unenclosed text treated as constant.  For example,
the statement 'PUT "<A>=<B>+<C(1)>;";' would generate the value of
the PL/I expression A××'='××B××'+'××C(1)××';'.  Unmatched brackets
are not detected, and will generally cause errors.  The PUT macro
expands into
.sp 1
.in 5
CALL GEN(string-expression);
.in 0
.sp 1
If replacement text must contain the "<" or ">" character, the CALL
GEN form must be used.
.sp 1
Example:  Generate a DECLARE statement for the variable specified
by the VAR macro parameter.
.sp 1
.in 5
? PUT "DECLARE <VAR> char(<LENGTH>) INIT(' ');";
.in 0
.sp 1
The NOTE Macro
.sp 1
The NOTE macro is used to generate diagnostic or informational
messages.  Its syntax is as follows:
.sp 1
.in 5
.nf
_________________________________________________________
×                                                       ×
× NOTE severity "shorthand message" {ID(msgid)};        ×
×                                                       ×
_________________________________________________________
.fi l
.in 0
.sp 1
severity is an integer constant (from 0 to 999) indicating the
severity of the error.  By convention, severities are assigned
as follows:
.sp 1
.nf
.in 5
0  informational messages
4  warnings
8  errors
12 severe errors
.fi l
.in 0
.sp 1
"shorthand message" is the message text, expressed in the same
shorthand as the PUT macro text.
.sp 1
ID(msgid) may be used to specify an eight-character id for the
message.  If this keyword is omitted, the id ****NOTE is used.
.sp 1
Example:  Write an error message for incorrect macro usage.
.sp 1
.in 5
? NOTE 8 "VARIABLE <VAR> NOT DECLARED";
.in 0
.pa
MISCELLANEOUS FACILITIES
.sp 1
In addition to the facilities available through MACRO statements,
GPPP provides a number of miscellaneous services to grammar and
macro routines.  These services are obtained via ENTRY variables
and global data addressed through the GPPPTCA structure.  GPPPTCA
also contains data for symbol table management (described in
Appendix A) and a few items for which full support is not yet
available.  Use of GPPPTCA items which are not defined in this
document should be avoided.
.sp 1
Additional Routines
.sp 1
GPPPTCA contains ENTRY variables to provide the following services:
.sp 1
.in 5
MACCALL - To expand a macro call supplied by the caller.
.in 5
GRAMMAR - To load a grammar.
.in 5
QUIT    - To terminate GPPP.
.in 5
IMAGE   - To convert an integer to a character string,
removing unnecessary blanks.
.in 5
COUNTER - To return a unique integer value.
.in 5
EXPAND  - To expand shorthand character expressions (as
used by the MACRO PUT statement) to their full form.
.in 0
.sp 1
The linkage for these routines is as follows:
.sp 1
.in 5
MACCALL ENTRY(CHAR(*) VAR)
.in 0
.sp 1
The MACCALL argument is a character string containing the source of
a macro call to be expanded (without any preceding ID character).
If the string does not contain a macro call, an error message is
produced.  Any replacement text generated by the call is written to
SYSPUNCH and SYSPRINT in the normal way;  it is not returned or
otherwise made available to the caller of MACCALL.  MACCALL can be
used to support many of the applications of the PL/I preprocessor's
"rescan" facility.
.sp 1
.in 5
GRAMMAR ENTRY(CHAR(16))
.in 0
.sp 1
The argument to GRAMMAR is the name of the grammar to load.  If
this grammar is already loaded, no action is taken.  GRAMMAR is
generally used to ensure that facilities required for macro calls
invoked through MACCALL are present.
.sp 1
.in 5
QUIT ENTRY
.in 0
.sp 1
The QUIT routine has no arguments or return value.  It produces no
special message or return code; the NOTE macro should be used
before a call to QUIT for these purposes.
.sp 1
.in 5
IMAGE ENTRY(FIXED BIN) RETURNS(CHAR(5) VAR)
.in 0
.sp 1
The argument to IMAGE is the integer to be converted to character.
The value returned is a compact character representation of the
argument, without leading blanks.
.sp 1
.in 5
COUNTER ENTRY RETURNS(PIC'99999')
.in 0
.sp 1
COUNTER requires no argument; it returns a unique five-digit number
which can be used for the generation of unique names.
.sp 1
.in 5
EXPAND ENTRY(CHAR(*) VAR) RETURNS(CHAR(1536) VAR)
.in 0
.sp 1
The argument of EXPAND is a shorthand character string, such as
'A<B>'.  The return value is the argument expanded to the form of a
normal PL/I character expression.  For example, EXPAND('A<B>') is
'''A''××B'.
.sp 1
File Processing
.sp 1
Because grammars are dynamically loaded, they cannot use any files
except SYSPRINT and files made available by GPPP.  The PL/I
SYSPRINT FILE is open to the DDname SYSTERM; its use by a grammar
may disrupt its normal GPPP formatting.  To assist grammars which
require work or secondary output files, GPPP makes three additional
files available through GPPPTCA.
.sp 1
These files are provided through FILE variables SYSUT1F, SYSUT2F
and SYSUT3F.  These files must be OPENed and CLOSEd by grammar
routines; other than that, their use is unrestricted.  If an OPEN
does not specify TITLE, DDnames of SYSUT1, SYSUT2 and SYSUT3
respectively will be used.  Note that the use of one of these files
by a grammar will make it incompatible with any other grammar which
uses the same file.
.sp 1
Setup Routines
.sp 1
Grammar load modules may contain EXTERNAL variables for
communication between their external procedures.  Occasionally,
this is not sufficient for an application.  For instance, data may
need to be shared between several grammars, or external data with
adjustable bounds may be required.  To assist in such cases, GPPP
supports the creation of a sub-communication area and its
initialization by one or more setup routines.
.sp 1
In support of such processing, GPPPTCA contains a pointer named
SUBCA and an ENTRY array SETUPS(5).  A grammar initialization
routine can allocate a communication area and store its address in
SUBCA.  Similarly, it can establish a setup routine by executing
the following code:
.sp 1
.in 5
.nf
SETUP#=SETUP#+1;
CALL SETUPS(SETUP#)(GPPPTCA);
.fi l
.in 0
.sp 1
This will eventually route control back to GPPP while keeping the
setup routine active.  This allows use of its internal ENTRYs and
AUTOMATIC data by external routines using pointers in the
sub-communication area.  At the end of the SYSIN input, control returns
from the CALL statement so the setup routine can perform any
necessary termination processing (such as CLOSEing files).  Note
that if termination occurs by a call to QUIT, control will not be
returned.
.sp 1
Global Variables
.sp 1
The following variables are available through GPPPTCA.  With the
exception of GENON (discussed below under Condition Compilation)
they should be treated as read-only.
.sp 1
.in 5
.hi 8
PRINTON BIT ALIGNED  Indicates whether PRINT ON or PRINT OFF is in
effect.
.in 5
PRINTGEN BIT ALIGNED  Indicates whether PRINT GEN or PRINT NOGEN is
in effect.
.in 5
GENON BIT ALIGNED  Indicates whether replacement text should be
generated (see below).
.in 5
ANNOT BIT ALIGNED  Indicates whether ANNOTATE(ON) or ANNOTATE(OFF)
is in effect.
.in 5
DEBUGER BIT ALIGNED  Indicates whether the DEBUG option is in effect.
.in 5
SELECT CHAR(1)  The ID character specified in the run-time
parameter string, or ' ' for NOID.
.in 5
LANGUAGE CHAR(8)  The name of the base language ('BAL' or 'ASM').
.in 5
SYSPARM CHAR(8)  The value specified in the PARM run-time option,
or ' ' if not specified.
.in 5
STMTNUM PIC'99999999'  The sequence number (actual or generated)
of the last input record.
.in 0
.hi 0
.sp 1
Conditional Compilation
.sp 1
The GENON flag may be used to support conditional compilation.
When GENON is '1'b (its normal value), all processing proceeds
normally.  When GENON is set to '0'b, no statements or generated
text are written to SYSPUNCH, but macro recognition and invocation
continue.  Thus, all text, including macro calls, between a macro
call which sets GENON to '0'b and one which restores it to '1'b will
produce no output on SYSPUNCH.  Note that the INCLUDE macro has no
effect when GENON is '0'b.
.pa
.ce 2
Appendix A
Symbol Tables
.sp 1
FACILITIES
.sp 1
GPPP offers facilities for block-structured and/or tree-structured
symbol tables.  These facilities are used within GPPP (to manage
its grammar and macro data), but are also available to macro
procedures.
.sp 1
A symbol table is a list of entries indexed by a sixteen character
"symbol name".  The information addressed by a symbol name can be
of any length and data type, varying from one symbol to the next.
Table entries are logically divided into two distinct areas, a
"static" area and a "variable" area.  By convention, the static
area contains information which is set when a symbol is defined and
not changed thereafter, while the variable area contains more
dynamic information.  The variable area for a symbol may be
formatted as a "minor" symbol table, allowing a tree-structured
data organization.  The major GPPP symbol table initially contains
two symbols, %GRAMMARS% and %MACROS%, where the corresponding table
entries contain minor tables for grammar and macro names
respectively.
.sp 1
In addition to a possible tree structure, the GPPP symbol table has
a stack structure, in support of block-structured macro languages.
A macro routine (supporting a macro which is used to begin a
program sub-block) may call the routine PUSH to create a new level
of the GPPP major symbol table.  It is still possible to use
information contained in previous levels of the symbol table, but
not to add new symbols.  New symbols can be added only to the
current level.  When a macro procedure (such as a processor for a
block end statement) calls the POP routine, the top level of symbol
table is deleted and the previous level restored, thereby
effectively removing any symbols added while the PUSH was in
effect.
.sp 1
The stacking of symbol tables applies directly only to the major
symbol table.  After a PUSH, minor symbol tables are contained in a
previous level of the major symbol table and as such should not be
modified by the addition of new symbols.  GPPP provides a facility
to copy variable information (such as a subsymbol table) from a
lower level to the current level, so it can be modified.  Of
course, when the symbol table is POPed, any symbol additions (or
other modifications to a copied table) will be lost.
.sp 1
After the symbol table usage by GPPP proper is taken into account,
approximately 48k is available for use by macro procedures.  Any
static or variable data as well as the table entries themselves is
allocated from this space.
.sp 1
SYMBOL TABLE ROUTINES
.sp 1
Declarations for the use of symbol tables may be obtained by
INCLUDEing the member GPPPSYM from 'SYS2.MACLIB'.  The
BASED structures SYMBOLTABLE and SYMBOL should be used for access
to a symbol table or symbol table entry respectively.  These
structures apply both to major and minor tables.
.sp 1
GPPPTCA contains the following ENTRY variables for symbol table
access and manipulation.
.sp 1
.hi 10
.in 5
PUSH    To create a new level of the lmajor symbol table.
.in 5
POP     To restore the previous level of the major symbol table.
.in 5
FIND    To find an entry in any level of the major symbol table.
.in 5
SCAN    To find an entry in a specific symbol table.
.in 5
NEWSYM  To add a symbol to a table.
.in 5
NEWTAB  To define a sub-symbol table.
.in 5
COPYVAR To copy variable information from a previous symbol table
level.
.hi 0
.in 0
.sp 1
The specific linkage requirements for these routines are as follows:
.sp 1
.in 5
PUSH ENTRY(FIXED BIN)
.in 0
The argument to PUSH is the maximum number of symbols in the new
symbol table level.  (level 1 is created with a capacity of 300.).
.sp 1
.in 5
POP ENTRY
.in 0
.sp 1
The POP routine requires no argument.
.sp 1
.in 5
FIND ENTRY(CHAR(16)) RETURNS(PTR)
.in 0
.sp 1
The argument to FIND is the name of the symbol to be located in
(some level of) the major symbol table.  The value returned is a
pointer to the table entry, or NULL if none was found.
.sp 1
.in 5
SCAN ENTRY(CHAR(16),PTR) RETURNS(PTR)
.in 0
.sp 1
The first argument to SCAN is the symbol name; the second is the
address of the symbol table to check.  The return value is the
address of the required entry, or NULL if none was found.
.sp 1
.in 5
NEWSYM ENTRY(CHAR(16),FIXED BIN,FIXED BIN,PTR) RETURNS(PTR)
.in 0
.sp 1
The arguments to NEWSYM are as follows:
.sp 1
.hi 4
.in 5
1.  The name of the symbol to add.
.in 5
2.  The size of the static area (the amount of user data plus
12 bytes for standard information).
.in 5
3.  The size of the variable area (the amount of user data
plus 12 bytes for standard information).
.in 5
4.  The address of the table to which the symbol is to be added.
.hi 0
.in 0
.sp 1
The return value is the address of the new entry, or NULL if it
already exists.
.sp 1
.in 5
NEWTAB ENTRY(CHAR(16),FIXED BIN,PTR,PTR) RETURNS(PTR)
.in 0
.sp 1
The arguments to NEWTAB are as follows:
.sp 1
.in 5
.hi 4
 1.  The name of the new table.
 2.  The maximum number of symbols in the new table.
 3.  The address of the symbol table for which the subtable is
to be created.
 4.  A pointer into which is to be stored the address of the
entry referencing the new table.
.hi 0
.in 0
.sp 1
The return value is the address of the address of the new table.
If a table already exists by this name, the return value is NULL.
.sp 1
.in 5
VARCOPY ENTRY(PTR)
.in 0
.sp 1
The argument to VARCOPY is the address of the symbol table whose
variable data is to be copied to the current level.  The address of
the copied data should be obtained normally (via SCAN) after
VARCOPY is complete.  Until POP is called, the previous level of
the variable data is not avaialable.
.pa
.ce 2
Appendix B
GPPP and MACRO Diagnostics
.sp 1
The messages produced by GPPP and the MACRO grammar are listed
below in message id sequence.  After each message is a more
detailed explanation of the meaning of the message.  Note that
other diagnostics may be produced by other grammars using the NOTE
statement.
.hi 10
.sp 1
GPPP001I  INVALID MACRO SYNTAX.
A macro verb has incorrect syntax (e.g. is a quoted string).
.sp 1
GPPP002I  VERB NOT FOUND.
A macro call contains a verb which is neither built-in nor
handled by any grammar presently in use.
.sp 1
GPPP003I  TOO MANY PARMS.
A macro call contains more positional parameters than the macro
procedure supports.
.sp 1
GPPP004I  STATEMENT UNINTELLIGIBLE.
A macro call has unintelligible syntax (e.g. parentheses are
unbalanced).
.sp 1
GPPP005I  MISSING REQUIRED PARM.
A required positional parameter is not present.
.sp 1
GPPP006I  PREMATURE KEYWORD word.
The indicated keyword appears on a macro call before all required
positional parameters have been specified.
.sp 1
GPPP007I  UNRECOGNIZED KEYWORD word.
The indicated keyword is not defined for this macro.
.sp 1
GPPP008I  word SUBFIELD NOT ALLOWED.
The indicated keyword was defined as BIT, and therefore not permitted
to have a subfield.
.sp 1
GPPP009I  IMPROPER POSITIONAL PARAMETER.
An apparent positional parameter (a quoted or parenthesized string)
appears in place of a keyword.
.sp 1
GPPP010I  INCOMPLETE PARAMETER.
A prepositional keyword is followed by a comma or semicolon.
.sp 1
GPPP011I  IMPROPER LIST PARAMETER.
A string in double quotes appears for a list type parameter.
(To correct this error, put the quoted string within parentheses.)
.sp 1
GPPP012I  word KEYWORD REQUIRES SUBFIELD.
The indicated keyword appears without a subfield.
.sp 1
GPPP013I  DUPLICATE OR EXCLUSIVE KEYWORDS.
The same keyword was specified twice, or two exclusive BIT keywords
were specified.
.sp 1
GPPP014I  INVALID NUMBER 'value' FOR word.
A FIXED parameter has a non-numeric value.
.sp 1
GPPP015I  ERROR IN SUBPARAMETER LIST.
An element of a subparameter list is invalid (e.g., contains a
semicolon or unmatched quote).
.sp 1
GPPP016I  LABEL NOT SUPPORTED BY MACRO.
A labelled macro call is not permitted for this verb.
.sp 1
GPPP017I  MISSING REQUIRED LABEL.
A label was not specified on a macro call where a label is required.
.sp 1
GPPP020I  INCOMPLETE GEN OUTPUT.
A macro has generated text which contains an unclosed quoted string
or comment.
.sp 1
GPPP021I  UNEXPECTED EOF.
The SYSIN input or an INCLUDE member has terminated in the middle
of a statement.
.sp 1
GPPP100I  INVALID PRINT OPTION.
An invalid option was specified on the PRINT keyword.
.sp 1
GPPP101I  GEN NOT SUPPORTED IN PL/I.
The GEN macro was used in PL/I without any parameters.
.sp 1
GPPP102I  MEMBER name NOT FOUND.
The SYSLIB member specified on an INCLUDE macro could not be found.
.sp 1
GPPP200I  INVALID LANGUAGE.
The EXEC card parameter string specified a language other than BAL
or PLI.
.sp 1
GPPP201I  INVALID ANNOTATE OPTION.
The ANNOTATE run-time option specified a subfield other than ON or
OFF.
.sp 1
GPPP202I  ID MUST SPECIFY EXACTLY 1 CHARACTER.
The ID option specified more than one character.
.sp 1
GPPP203I  ILLEGAL ID CHARACTER.
An illegal ID character was requested.  The ID must not be
alphanumeric or national.  It may also not be an underscore, colon,
semicolon, slash, asterisk, parenthesis, comma, equal sign or
single or double quote, as the use of these characters is likely
to interfere with the GPPP syntax scan.
.sp 1
GPPP900I  SYMBOL STACK OVERFLOW.
Too many levels (more than 9) of symbol table have been
created.  This may indicate a logic error in a grammar,
or too much nesting of blocks in use of block-structured
grammar.
.sp 1
GPPP901I  SYMBOL STACK UNDERFLOW.
An attempt has been made to POP the bottom level of
symbol table.  This indicates a logic error in a grammar.
.sp 1
GPPP902I  SYMBOL TABLE OVERFLOW.
An attempt has been made to add a symbol to a full symbol table.
This may indicate a logic error in a grammar, or
that a maximum value associated with the grammar has been
exceeded.
.sp 1
GPPP903I  SYMBOL STORAGE OVERFLOW.
The storage available to symbol tables has been exceeded.
The maximum storage avaiable cannot at this time be
increased at run-time.
.sp 1
GPPP904I  GRAMMAR name NOT LOADED.
The named grammar could not be found or some other error
(such as insufficient memory) occurred trying to load it.
Usually, a system message is produced in the job log
containing further information.
.sp 1
GPPP905I  TOO MANY NESTED INCLUDES.
An attempt was made to exceed the limit of 9 nested INCLUDE
macro calls.
.sp 1
GPPP906I  SYSLIB OPEN FAILURE.
The SYSLIB data set could not be opened for an INCLUDE statement.
The job log may contain further information about the failure.
.sp 1
GPPP907I  SYSLIB READ ERROR.
A transmission or logical error occurred trying to read a
data block from SYSLIB.
.sp 1
MACR001I  TOO MANY PARAMETERS.
The upper limit of 40 PARAMETER macro calls per procedure
has been exceeded.
.sp 1
MACR002I  PARAMETER OUT OF ORDER.
A positional parameter is defined after a keyword
parameter, or a required parameter after a non-required
parameter.
.sp 1
MACR003I  EXTRA NAMES FOR POSITIONAL PARAMETER IGNORED.
More than one parameter name has been specified for a
positional parameter.  Only the first name is meaningful.
.sp 1
MACR004I  opt1 CONFLICTS WITH opt2 OPTION.
Conflicting options were specified on the PARAMETER macro.
.sp 1
MACR005I  option REQUIRES POSITIONAL.
The listed option is only meaningful for a positional parameter.
.sp 1
MACR006I  SUBSCRIPT VAR NOT FOUND FOR name.
The SUBSCRIPT variable specified in the PARAMETER macro for the
named parameter could not be found.
.sp 1
MACR007I  UNRECOGNIZED PARM NAME name.
The parameter referenced by an OPEN or GET macro has not been
defined.
.sp 1
MACR008I  PARAMETER IS NOT LIST TYPE.
The parameter referenced by an OPEN or GET macro is not a
LIST parameter.
