 /* COPYRIGHT 1983 BY THOMAS GLEN SMITH */
 /**********************************************************************
 * ABERP                                                               *
 * THIS SUBROUTINE PROVIDES THE INTERFACE TO THE CLIST SYMBOLIC        *
 * SUBSTITUTION SYSTEM.                                                *
 * XXX = ABESY(PPP);                                                   *
 *                                                                     *
 *   PPP IS CHAR(*), AND SHOULD CONTAIN THE SYMBOLIC PARAMETER NAME,   *
 *   PRECEDED BY AN AMPERSAND (&).  ABESY WILL RETURN CHAR(256) VAR    *
 *   CONTAINING THE REPLACEMENT VALUE ASSOCIATED WITH THE SYMBOLIC     *
 *   PARAMETER.                                                        *
 *                                                                     *
 * CALL ABERP(PPP,XXX);                                                *
 *                                                                     *
 *   PPP IS CHAR(*), AND SHOULD CONTAIN THE SYMBOLIC PARAMETER NAME,   *
 *   PRECEDED BY AN AMPERSAND (&).  ABERP WILL RETURN XXX, WHICH       *
 *   MUST BE CHAR(*) VAR,                                              *
 *   CONTAINING THE REPLACEMENT VALUE ASSOCIATED WITH THE SYMBOLIC     *
 *   PARAMETER.                                                        *
 *                                                                     *
 * CALL ABEST(SYMBOL,VALUE);                                           *
 *                                                                     *
 *   SYMBOL IS CHAR(8), AND SHOULD CONTAIN THE SYMBOLIC PARAMETER NAME,*
 *   PRECEDED BY AN AMPERSAND (&).  VALUE IS CHAR(256) VAR, AND        *
 *   SHOULD BE SET BY THE CALLER TO THE NEW SUBSTITUTION VALUE TO      *
 *   BE ASSIGNED TO THE SPECIFIED SYMBOLIC PARAMETER NAME.             *
 **********************************************************************/

 ABERP: PROC(PPP,XXX) OPTIONS(REENTRANT);
   DFT RANGE(*) FIXED BIN VALUE(FIXED BIN(31,0));
   DCL XXX CHAR(*) VAR;
   DCL TSOMOCK ENTRY;
   DCL SYSCLV ENTRY(CHAR(3),CHAR(*),CHAR(*) VAR)
     RETURNS(FIXED BIN(31,0));
   DCL SYSCLVRET FIXED BIN(31,0);

   XXX=ABESY(PPP);
   RETURN;

 ABESY: ENTRY(PPP) RETURNS(CHAR(256) VAR) OPTIONS(REENTRANT);
   DCL PPP CHAR(*);
   DCL ABESYTXT CHAR(256) VAR;

   MYSYMV=SUBSTR(PPP,2);
   SYSCLVRET=SYSCLV('GET',MYSYMV,ABESYTXT);
   SELECT;
     WHEN(SYSCLVRET>0) RETURN('');
     WHEN(SYSCLVRET=0) RETURN(ABESYTXT);
     OTHERWISE;
     END; /* SELECT */
   MYSYM=MYSYMV;
   CALL TSOMOCK(MOCKUPT,MOCKPSCB,ECTADR);
   EXECDPTR=LSDEXEC; /* GET ADDRESSIBILITY TO LOCAL VARIABLES */
   L=SUFFIX(MYSYM,' '); /* FIND LENGTH OF SYMBOL NAME */
   CALL LOCATE(MYSYM,L,0); /* LOCATE TABLE ENTRY */
   IF ERROR^=0
     THEN RETURN(''); /* RETURN A NULL STRING IF NOT FOUND */
     ELSE RETURN(SUBSTR(SVTDATA,1,SVTLNG));

 ABEST: ENTRY(SYMBOL,VALUE) OPTIONS(REENTRANT);
   DCL SYMBOL CHAR(8),
       VALUE CHAR(256) VAR;

   MYSYM=SYMBOL;
   L=SUFFIX(MYSYM,' '); /* FIND LENGTH OF SYMBOL NAME */
   MYSYMV=SUBSTR(MYSYM,1,L);
   SYSCLVRET=SYSCLV('PUT',MYSYMV,VALUE);
   SELECT;
     WHEN(SYSCLVRET>0) SIGNAL ERROR;
     WHEN(SYSCLVRET=0) RETURN;
     OTHERWISE;
     END; /* SELECT */
   CALL TSOMOCK(MOCKUPT,MOCKPSCB,ECTADR);
   EXECDPTR=LSDEXEC; /* GET ADDRESSIBILITY TO LOCAL VARIABLES */
   CALL LOCATE(MYSYM,L,8); /* LOCATE TABLE ENTRY - ADD IF NECESSARY */
   IF ERROR^=0
     THEN SIGNAL ERROR; /* LOCATE FAILED */
   CALL UPDATE(VALUE,LENGTH(VALUE)); /* GO UPDATE VALUE */
   IF ERROR^=0
     THEN SIGNAL ERROR; /* UPDATE FIELD */
   RETURN;
 LOCATE:  PROC(NAME,NAML,FUNC) OPTIONS(REENTRANT);
   DCL NAME CHAR(*),
       NAML FIXED BIN(31,0),
       FUNC FIXED BIN(31,0);
   SNTABPTR=SNTABFST; /* POINT TO FIRST SNTAB */
   SNTELPTR=ADDR(SNTELFST); /* POINT TO FIRST NAME ENTRY */
   EXITB=NO;
   IF NAML>252
     THEN ERCOM=940; /* SET NOT FOUND RETURN CODE */
   DO WHILE(EXITB=NO & ERCOM=0);
     /* SEARCH TABLE UNTIL FOUND OR UNTIL ERCOM OCCURS */
     IF NAML=SNTLNG & SUBSTR(NAME,1,NAML)=SNTDATA
       THEN EXITB=YES; /* WE FOUND IT */
       ELSE IF SNTLAST
         THEN IF PTRIN(SNTABNXT)=0 /* IS IT LAST TABLE? */
           THEN IF FUNC=8 /* IS VARIABLE TO BE ADDED? */
             THEN DO;
               CALL NAMEADD; /* ADD NAME TO TABLE */
               EXITB=YES; /* INDICATE WE FOUND IT */
               END;
             ELSE ERCOM=904; /* SET NOT FOUND RC */
           ELSE DO; /* IF NOT LAST TABLE */
             SNTABPTR=SNTABNXT; /* LOOK AT NEXT SNTAB */
             SNTELPTR=ADDR(SNTELFST); /* POINT TO 1ST NAME ENTRY */
             END;
         ELSE SNTELPTR=PTROUT(PTRIN(SNTELPTR)+SNTELPTR->SNTLNG+
           LENGTH_SNTELEM); /* LOOK AT NEXT NAME ENTRY */
     END;
   IF ERCOM=0 & ((FUNC^=4 & SNTLABEL) × (FUNC=4 & ^SNTLABEL))
     THEN ERCOM=944; /* LABEL WAS FOUND WHEN IT SHOULDN'T HAVE BEEN
       OR IT WASN'T FOUND WHEN IT WAS SUPPOSED TO BE. */
   IF ERCOM=0 & SNTGLOB
     THEN CALL GLOCATE; /* IF A GLOBAL, DO A GLOBAL SEARCH */
   ERROR=ERCOM;
 NAMEADD: PROC OPTIONS(REENTRANT); /* NESTED WITHIN LOCATE */
   IF NAML>31
     THEN ERCOM=940; /* NAME TOO LONG */
     ELSE IF NAML+LENGTH_SNTELEM > SNTABLNG-SNTABUSE
       THEN DO; /* NO ROOM LEFT IN THIS TABLE. GET ANOTHER */
         NEWLNG=MAX(SNTABLNG,NAML+LENGTH_SNTELEM+LENGTH_SNTAB+GAS);
         CALL SYSGETM('EC',NEWLNG,SNTSAVE,SP,ERCOM);
         IF ERCOM ^= 0
           THEN ERCOM=16; /* INDICATE GETMAIN ERROR */
           ELSE DO; /* OTHERWISE CHAIN NEW TABLE */
             SNTSAVE->SNTABNXT=PTROUT(0); /* NO NEXT TABLE */
             SNTSAVE->SNTABLNG=NEWLNG; /* LENGTH OF THIS TABLE */
             SNTSAVE->SNTABUSE=LENGTH_SNTAB; /* LENGTH OF HEADER */
             SNTABNXT=SNTSAVE; /* CHAIN NEW TABLE */
             SNTABPTR=SNTSAVE; /* SET BASE TO NEW TABLE */
             END;
         END;
       ELSE SNTLAST='0'B; /* CLEAR OLD LAST SWITCH */
   IF ERCOM=0
     THEN DO; /* IF NO GETMAIN ERROR, ADD ENTRY */
       SNTELPTR=PTROUT(PTRIN(SNTABPTR)+SNTABUSE); /* POINT TO NEW SLOT*/
       SNTFLAGS='0'B; /* CLEAR FLAGS */
       SNTKEYW='1'B; /* KEYWORD WITH VALUE */
       SNTLAST='1'B; /* NOW LAST ELEMENT */
       SNTVLPTR=PTROUT(PTRIN(SVTABFST)+LENGTH_SVTAB);
       SNTLNG=NAML; /* LENGTH OF NAME */
       SNTDATA=SUBSTR(NAME,1,NAML); /* NAME */
       SNTABUSE=SNTABUSE+NAML+LENGTH_SNTELEM; /* AMT IN USE */
       END;
   END NAMEADD;
   END LOCATE;
 GLOCATE:  PROC OPTIONS(REENTRANT);
   SNTSAVE=SNTELPTR; /* SAVE NAME POINTER */
   EXECDPTR=GEXECDAT; /* POINT TO GLOBAL EXEC */
   SNTABPTR=SNTABFST; /* POINT TO GLOBAL FIRST NAME TAB */
   SNTELPTR=ADDR(SNTELFST); /* BEGIN GLOBAL NAMES */
   EXITB=NO;
   DO WHILE(EXITB=NO & ERCOM=0);
     IF SNTLNG=4 & SNTSAVE->SNTGVAL=SUBSTR(SNTDATA,1,4)
       THEN EXITB=YES; /* WE FOUND IT */
       ELSE IF SNTLAST
         THEN IF PTRIN(SNTABNXT)=0
           THEN ERCOM=312; /* WE DIDN'T FIND IT */
           ELSE DO; /* ELSE SCAN NEXT TABLE */
             SNTABPTR=SNTABNXT;
             SNTELPTR=ADDR(SNTELFST);
             END;
         ELSE SNTELPTR=PTROUT(PTRIN(SNTELPTR)+SNTLNG+LENGTH_SNTELEM);
     END;
   ERROR=ERCOM;
   END GLOCATE;
 UPDATE: PROC(VALUE,VALLEN) OPTIONS(REENTRANT);
   /* SYMBOLIC VARIABLE UPDATE */
   DCL VALUE CHAR(*),
       VALLEN FIXED BIN(31,0);
   SVTABPTR=SVTABFST; /* POINT TO CURRENT VALUE TABLE */
   IF SNTNAUTH
     THEN ERCOM=300;
     ELSE DO; /* UPDATE VAR */
       IF VALLEN > SVTORIG
         THEN DO; /* NEW SLOT IS NEEDED */
           IF VALLEN+LENGTH_SVTELEM > SVTABLNG-SVTABUSE
             THEN DO; /* NEW SVTAB IS NEEDED */
               SNTSAVE=SNTELPTR;
               EXITC=NO;
               NEWLNG=MAX(SVTABLNG+VALLEN+GAS,(SVTABUSE-SVTABFRE)*3/2);
               CALL SYSGETM('EC',NEWLNG,SVTABPTR,SP,ERCOM);
               IF ERCOM ^= 0
                 THEN DO; /* GETMAIN ERROR */
                   ERCOM=16;
                   ERROR=ERCOM;
                   RETURN;
                   END;
                 ELSE DO; /* OTHERWISE SET UP AND COPY TABLE */
                   SVTABNXT=SVTABFST; /* POINT TO OLD TABLE */
                   SVTABFRE=0; /* NO FREE SPACE IN TABLE */
                   SVTABLNG=NEWLNG; /* LENGTH OF THIS TABLE */
                   SVTABUSE=LENGTH_SVTAB+LENGTH_NULELEM;
                   SVTABFST=SVTABPTR; /* INIT EXEC DATA POINTER */
                   SNTABPTR=SNTABFST; /* POINT TO FIRST NAME TABLE */
                   SNTELPTR=ADDR(SNTELFST); /* GET ADDR FIRST NAME */
                   EXITC=NO;
                   R2=PTROUT(PTRIN(ADDR(SVTELFST))+LENGTH_NULELEM);
                     /* GET FIRST AVAILABLE SLOT */
                   NULELEM=0; /* INITIALIZE THE NULL ELEMENT */
                   DO WHILE(EXITC=NO);
                     IF SNTELPTR^=SNTSAVE & ^SNTLABEL & ^SNTGLOB
                       THEN DO; /* MOVE INTO NEW TABLE */
                         IF SVTORIG=0
                           THEN SNTVLPTR=ADDR(NULELEM);
                           ELSE DO; /* ELSE ASSIGN SLOT IN NEW TABLE */
                             R3=SVTORIG+LENGTH_SVTELEM; /* LEN MOVE */
                             R4=SNTVLPTR; /* POINT TO OLD DATA */
                             R5=R3; /* GET FROM LENGTH */
                             SVTABFRE=SVTABFRE+SVTORIG-SVTLNG;
                             SVTABUSE=SVTABUSE+SVTORIG+LENGTH_SVTELEM;
                             SNTVLPTR=R2; /* RESET VALUE PTR */
                             SUBSTR(R2->WRKSTR,1,R3)=
                               SUBSTR(R4->WRKSTR,1,R5);
                                 /* COPY INTO NEW TABLE */
                             R2=PTROUT(PTRIN(R2)+R3);
                             END;
                         END;
                     IF SNTLAST
                       THEN IF PTRIN(SNTABNXT)=0
                         THEN EXITC=YES; /* END COPY */
                         ELSE DO; /* GET NEXT TABLE */
                           SNTABPTR=SNTABNXT;
                           SNTELPTR=ADDR(SNTELFST);
                           END;
                       ELSE SNTELPTR=PTROUT(PTRIN(SNTELPTR)+SNTLNG+
                         LENGTH_SNTELEM);
                     END;
                   SNTELPTR=SNTSAVE; /* RESTORE SNTEL PTR */
                   SNTABPTR=SNTABFST; /* RESTORE TABLE PTR */
                   CALL SYSFREM(SVTABNXT->SVTABLNG,SVTABNXT,SP);
                   SVTABNXT=PTROUT(0);
                   END;
               END;
           SNTVLPTR=PTROUT(PTRIN(SVTABPTR)+SVTABUSE);
             /* ASSIGN NEW SLOT */
           SVTORIG=VALLEN; /* SET LENGTH OF VALUE */
           SVTLNG=VALLEN;
           SVTABUSE=SVTABUSE+VALLEN+LENGTH_SVTELEM;
           END;
       SVTABFRE=SVTABFRE+SVTLNG-VALLEN; /* ADJUST FREE AREA */
       SVTLNG=VALLEN;
       R2=ADDR(SVTDATA);
       R3=SVTORIG;
       R4=ADDR(VALUE);
       R5=SVTLNG;
       SUBSTR(R2->WRKSTR,1,R3)=SUBSTR(R4->WRKSTR,1,R5);
         /* MOVE NEW DATA */
       END;
   EXECDPTR=LSDEXEC; /* RESET EXEC DATA POINTER */
   ERROR=ERCOM;
   END UPDATE;
 /*
 *   START OF DCLS
 */
   DCL MYSYM CHAR(8);
   DCL MYSYMV CHAR(8) VAR;
   DCL SP FIXED BIN(15,0) STATIC INIT(78);
   DCL (SNTSAVE,R2,R4) PTR;
   DCL WRKSTR CHAR(32767) BASED(WRKPTR);
   DCL (PREFIX,SUFFIX) ENTRY(CHAR(*),CHAR(*))
     RETURNS(FIXED BIN(15,0));
   DCL PTRIN ENTRY(PTR)
     RETURNS(FIXED BIN(31,0));
   DCL PTROUT ENTRY(FIXED BIN(31,0))
     RETURNS(PTR);
   DCL SYSFREM ENTRY(FIXED BIN(31,0),PTR,FIXED BIN(15,0));
   DCL SYSGETM ENTRY(CHAR(2),FIXED BIN(31,0),PTR,FIXED BIN(15,0),
     FIXED BIN(31,0));
   DCL GAS FIXED BIN(31,0) STATIC INIT(200);
   DCL LENGTH_SVTAB FIXED BIN(31,0) STATIC INIT(16);
   DCL LENGTH_SNTAB FIXED BIN(31,0) STATIC INIT(12);
   DCL LENGTH_SNTELEM FIXED BIN(31,0) STATIC INIT(8);
   DCL LENGTH_SVTELEM FIXED BIN(31,0) STATIC INIT(4);
   DCL LENGTH_NULELEM FIXED BIN(31,0) STATIC INIT(4);
   DCL YES FIXED BIN(31,0) STATIC INIT(1);
   DCL NO FIXED BIN(31,0) STATIC INIT(0);
   DCL (ERCOM,ERROR) FIXED BIN(31,0) INIT(0);
   DCL (ECTADR,MOCKUPT,MOCKPSCB) PTR;
   DCL 1 ECT BASED(ECTADR),
     2 PAD CHAR(4),
     2 ECTIOWA PTR;
   DCL IOSRL PTR BASED(ECTIOWA);
   DCL LSDPTR PTR BASED(IOSRL);
   % INCLUDE IKJLSD;
   DCL 1 EXECDATA BASED(EXECDPTR),
       /* POINTED TO BY +12 IN LSD FOR CLIST */
     2 SNTABFST PTR,
       /* ADDR FIRST SNTAB */
     2 SVTABFST PTR,
       /* ADDR FIRST SVTAB */
     2 GEXECDAT PTR,
       /* ADDR GLOBAL EXECDATA */
     2 LASTTSO PTR,
       /* ADDR LAST TSO COMMAND EXECUTED. */
     2 ETC CHAR(1);
       /* MORE FIELDS I DON'T NEED */
   DCL 1 SNTAB BASED(SNTABPTR),
       /* SYMBOLIC NAME TABLE */
     2 SNTABNXT PTR,
       /* ADDR NEXT SNTAB */
     2 SNTABLNG FIXED BIN(31,0),
       /* LENGTH OF THIS SNTAB */
     2 SNTABUSE FIXED BIN(31,0),
       /* # BYTES IN THIS SNTAB IN USE */
     2 SNTELFST CHAR(1);
       /* FIRST SNTAB ELEMENT */
   DCL SNTGVAL FIXED BIN(31,0) BASED(SNTELPTR);
       /* IF ELEMENT IS FOR A GLOBAL VARIABLE */
   DCL 1 SNTELEM BASED(SNTELPTR),
       /* SYMBOLIC NAME TABLE ELEMENT */
     2 SNTVLPTR PTR,
       /* ADDR SVTAB ELEMENT FOR THIS SYMBOLIC PARAMETER OR
       THE GLOBAL VARIABLE NAME IF PARAMETER IS GLOBAL. */
     2 SNTFLAGS,
      3 SNTPOSIT BIT(1), /* POSITIONAL */
      3 SNTKEY BIT(1), /* KEYWORD ELEMENT */
      3 SNTKEYW BIT(1), /* KEYWORD WITH VALUE ELEMENT */
      3 SNTLABEL BIT(1), /* LABEL ELEMENT */
      3 SNTNOSCN BIT(1), /* VARIABLE NOT RESCANNABLE */
      3 SNTNAUTH BIT(1), /* CONTROL VARIABLE CANNTO BE SET
                            BY THE USER */
      3 SNTEVAL BIT(1), /* CONTROL VARIABLE REQUIRES IMMEDIATE
                           EVALUATION. */
      3 SNTLAST BIT(1), /* DEFINES THE LAST ELEMENT IN THIS SNTAB. */
      3 SNTGLOB BIT(1), /* VARIABLE IS A GLOBAL VARIABLE. */
      3 SNTRSVD BIT(7), /* RESERVED */
     2 SNTLNG FIXED BIN(15,0),
       /* LENGTH OF SYMBOLIC PARAMETER NAME */
     2 SNTDATA CHAR(L REFER(SNTLNG));
       /* NAME OF THE SYMBOLIC PARAMETER */
   DCL 1 SVTAB BASED(SVTABPTR),
       /* SYMBOLIC VALUE TABLE */
     2 SVTABNXT PTR,
       /* ADDR NEXT SVTAB */
     2 SVTABLNG FIXED BIN(31,0),
       /* LENGTH OF THIS SVTAB */
     2 SVTABUSE FIXED BIN(31,0),
       /* # BYTES IN THIS SVTAB IN USE */
     2 SVTABFRE FIXED BIN(31,0),
       /* # BYTES IN THIS SVTAB ASSIGNED BUT UNUSED */
     2 SVTELFST,
       /* FIRST SYMBOLIC VALUE ELEMENT */
      3 NULELEM FIXED BIN(31,0);
       /* FIRST ELEMENT IN SVTAB IS A NULL ELEMENT */
   DCL 1 SVTELEM BASED(SNTVLPTR),
       /* SYMBOLIC VALUE TABLE ELEMENT */
     2 SVTLNG FIXED BIN(15,0),
       /* LENGTH OF THE SYMBOLIC PARAMETER VALUE */
     2 SVTORIG FIXED BIN(15,0),
       /* ORIGINAL LENGTH OF THIS ELEMENT */
     2 SVTDATA CHAR(256);
   END;
