   /* COPYRIGHT 1983 BY THOMAS GLEN SMITH */
   /* ABE034 - ITEIN */
   %INCLUDE ABESUB;
 ABESUB(ABE034) PARS(0000000000000000) CHECK(YES);
   %INCLUDE ABESUBA;
   DCL 1 LRN_STRUCTURE BASED(LRNPTR),
   %INCLUDE ABELRN;
   %INCLUDE ABELRNA;

   /* NOTE THAT YOU HAVE TO GIVE ITEIN A COMPLETE SET OF STATEMENTS.
      THAT IS, L1 HAS TO BEGIN WITH THE START OF A PL/I STATEMENT,
      AND L2 MUST END WITH THE SEMICOLON ENDING A COMPLETE PL/I
      STATEMENT.
   */
   DCL SETCAPS ENTRY;
   DCL QSTR ENTRY(CHAR(*) VAR, FIXED BIN(15,0),
     CHAR(*) VAR, FIXED BIN(15,0));
   DCL BINDEX ENTRY(CHAR(*) VAR,
     CHAR(*) VAR, CHAR(*) VAR,
     FIXED BIN(15,0))
     RETURNS(FIXED BIN(15,0));
   DCL (PREFIX,SUFFIX) ENTRY(CHAR(*),CHAR(*))
     RETURNS(FIXED BIN(15,0));
   DCL MAXLEN ENTRY(CHAR(*) VAR)
     RETURNS(FIXED BIN(15,0));
   DCL REPEAT BUILTIN;
   DCL KEYTABLE(4) CHAR(80) VAR STATIC
   INIT('SUPPRESS','TEST','SAS','PLI');
   DCL (SUPPRESS,SAS,PLI) BIT(1) INIT('0'B);
   DCL INDX FIXED BIN(15,0);
   DCL OPER CHAR(80) VAR;
   DCL KEYLAB(0:5) LABEL;
   DCL LAST FIXED BIN(31,0) INIT(99999999);
   DCL DLMTAB CHAR(40) STATIC INIT(
     '$@*_ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789');
   DCL (ORGPTR,TMPPTR,SAVPTR,PRMPTR,RECPT) PTR;
   DCL SPLITKEY(15) CHAR(9) VAR STATIC INIT('THEN','ELSE','DO','END',
     'SELECT','BEGIN','PROC','IF','DCL','DECLARE','WHEN','OTHERWISE',
     'PROCEDURE','DATA','CARDS');
   DCL BLTAB(0:2) CHAR(6) VAR STATIC INIT('DO','IF','SELECT');
     OTKEY=HBOUND(SPLITKEY,1)+1;   /* OTHER PL/I STATEMENTS */
     QUKEY=HBOUND(SPLITKEY,1)+2;   /* QUOTED STRING */
     SCKEY=HBOUND(SPLITKEY,1)+3;   /* SEMICOLON - END OF STATEMENT */
     COKEY=HBOUND(SPLITKEY,1)+4;   /* PLI COMMENT */
     TDKEY=HBOUND(SPLITKEY,1)+5;   /* THEN-DO CLAUSE */
     TIKEY=HBOUND(SPLITKEY,1)+6;   /* THEN-IF CLAUSE */
     TSKEY=HBOUND(SPLITKEY,1)+7;   /* THEN-SELECT CLAUSE */
     EDKEY=HBOUND(SPLITKEY,1)+8;   /* ELSE-DO CLAUSE */
     EIKEY=HBOUND(SPLITKEY,1)+9;   /* ELSE-IF CLAUSE */
     ESKEY=HBOUND(SPLITKEY,1)+10;  /* ELSE-SELECT CLAUSE */
     WDKEY=HBOUND(SPLITKEY,1)+11;  /* WHEN-DO CLAUSE */
     WIKEY=HBOUND(SPLITKEY,1)+12;  /* WHEN-IF CLAUSE */
     WSKEY=HBOUND(SPLITKEY,1)+13;  /* WHEN-SELECT CLAUSE */
     ODKEY=HBOUND(SPLITKEY,1)+14;  /* OTHERWISE-DO CLAUSE */
     OIKEY=HBOUND(SPLITKEY,1)+15;  /* OTHERWISE-IF CLAUSE */
   OSKEY=HBOUND(SPLITKEY,1)+16;  /* OTHERWISE-SELECT CLAUSE */
   L1 = RH_L1;
   L2 = RH_L2;
   IF L1>L2
     THEN DO; /* PROCESS FRONT TO BACK ONLY */
       I=L1;
       L1=L2;
       L2=I;
       END;
   L4=0; /* SET DEFAULT TEST VALUE */
   L3=2; /* SET DEFAULT INDENTATION */
   PLI='1'B; /* SET DEFAULT PLI SOURCE */
   DO I = 1 TO HBOUND(PARY,1) WHILE(PARY(I)^='');
     CALL SETCAPS(PARY(I));
     CALL #SPARS(PARY(I),KEYTABLE,OPER,INDX); /* CALL SPARS */
     GOTO KEYLAB(INDX);
 KEYLAB(0):  /* INVALID OPERAND */
     MSGDATA='INVALID OPERAND='××PARY(I);
     RHRC=8;
     RETURN;
 KEYLAB(1):  /* SUPPRESS */
     SUPPRESS='1'B;
     GO TO ENDCASE;
 KEYLAB(2):  /* TEST */
     L4=OPER;
     GO TO ENDCASE;
 KEYLAB(3):  /* SAS */
     SAS='1'B;
     PLI='0'B;
     GO TO ENDCASE;
 KEYLAB(4):  /* PLI */
     PLI='1'B;
     SAS='0'B;
     GO TO ENDCASE;
 KEYLAB(5):  /* INDENT */
     L3=OPER;
     GO TO ENDCASE;
 ENDCASE:
     END;
   ORGPTR = RECPTR;
   IN,INSTART = L3;
   CALL #MD(RHPTR,RHHDRPT,L1); /* CALL MDPROC */
   SAVPTR=RECPTR;
   IF PLI & L4^=2
     THEN DO;
       ON CONDITION(ENDRNGE) GO TO ENDPLI;
       DO RECPT=RECPTR REPEAT BUMP(RECPT);
         IF LENGTH(RECPT->RECSTR)>0
           THEN SUBSTR(RECPT->RECSTR,1,1)=' '; /* ELIM. CARR. CTL */
         END;
       END;
 ENDPLI:
   IF L4=0 × L4=1
     THEN DO;
       ON CONDITION(ENDRNGE) GO TO ENDPASS;
       DO RECPT=SAVPTR REPEAT BUMP(RECPT);
         RECPT = FORM(RECPT);
         END;
       END;
 ENDPASS:
   IF ^(L4=1)
     THEN DO;
       ON CONDITION(ENDRNGE) GO TO EOJ;
       PRMPTR = SAVPTR;
       CALL RECURS(IN,PRMPTR);
       END;
 EOJ:
   CALL #RESEQ(RHPTR,RHHDRPT,HDPTR,'NOSAVE','NORENUM',LAST);
   CALL #NC(RHPTR,ORGPTR);
   RHRC = 0;
   SAVEFLAG='1'B;

 RECURS:  PROC(PIN,PRMPTR) RECURSIVE;
   /* WHEN RECURS RETURNS CONTROL, RECPTR WILL POINT TO LAST LINE OF
      STATEMENT JUST PROCESSED, IF ANY. */
   DCL (IN,PIN) FIXED BIN(15,0);
   DCL (PRMPTR,T,SAVEPTR,RECPT,WRKPTR) PTR;
   DCL SUSW BIT(1);
   DCL TDSW BIT(1);
   DCL (I,OLDI,SAVI,J,K,TIN,S) FIXED BIN(15,0) INIT(0);
   IF PRMPTR=HDPTR
     THEN RETURN;
   IN=PIN;
   I=0;
   DO RECPT=PRMPTR REPEAT BUMP(RECPT);
     /* S/B BE AT START OF STATEMENT */
     OLDI=I;
     I = TYPE(RECPT);
     IF ^ELSE(I) & THEN(OLDI)
       THEN DO;
         RECPT=RECPT->LSTPTR;
         RETURN;
         END;
     IF IF(I)
       THEN DO;
         DO T=BUMP(SKIPCOM(RECPT)) REPEAT(BUMP(SKIPCOM(T)))
           UNTIL(THEN(S)); /* FIND THE NESTED THEN */
           S = TYPE(T);
           END;
         CALL SHIFT(IN,RECPT,T,'0'B);/* SHIFT IF PART-NO SUPPRESS */
         CALL RECURS(IN+2,T); /* RECURS WILL UPDATE RECPT.*/
         IF ELSE(I)
           THEN RETURN;
         END;
       ELSE DO;
         IF I=COKEY
           THEN DO;
             T=SKIPCOM(RECPT); /* FIND END OF RANGE */
             CALL SHIFT(IN,RECPT,T,SUPPRESS);
             RECPT=T->LSTPTR; /* POINT TO END OF LAST STATEMENT */
             RETURN; /* COMMENT AT END OF RANGE */
             END;
         IF SAS & (I=14 × I=7) & IN > INSTART
           THEN DO;
             RECPT=RECPT->LSTPTR;
             RETURN; /* ALL DONE AT THIS LEVEL */
             END;
         DO T=BUMP(SKIPCOM(RECPT)) REPEAT(BUMP(SKIPCOM(T)))
           UNTIL(S=SCKEY); /* FIND THE ENDING SEMICOLON */
           T=SKIPCOM(T);
           S=TYPE(T);
           END;
         SAVEPTR=T->NXTPTR;
         IF ELSE(I) × THEN(I) × IF(I) × (I>=3 & I<=7)
           THEN SUSW='0'B;
           ELSE SUSW=SUPPRESS;
         WRKPTR=T->NXTPTR;
         CALL SHIFT(IN,RECPT,WRKPTR,SUSW); /* SHIFT STATEMENT */
         RECPT=SAVEPTR->LSTPTR; /* POINT TO END OF STATEMENT */
         SELECT(I);
           WHEN(15) /* IT IS CARDS */
             DO;
               DO T=BUMP(T) REPEAT(BUMP(T));
                 IF INDEX(T->RECSTR,';')^=0
                   THEN LEAVE;
                 END;
               T=T->LSTPTR;
               END;
           WHEN(3,5,6,7,13,TDKEY,EDKEY,WDKEY,ODKEY,TSKEY,ESKEY,WSKEY,
             OSKEY,14,15) CALL RECURS(IN+2,BUMP(RECPT));
               /* IT IS DO, BEGIN, SELECT, THEN-DO, ETC. */
           WHEN(4) /* IT IS END */
             IF IN > INSTART
               THEN RETURN;
           OTHERWISE;
           END;
         IF ELSE(I)
           THEN RETURN; /* ALL DONE AT THIS LEVEL */
         END;
     END;
   END RECURS;

 BUMP:  PROC(T) RETURNS(PTR);
   DCL T PTR;
   IF ^TEST(T)
     THEN SIGNAL CONDITION(ENDRNGE);
     ELSE RETURN(T->NXTPTR);
   END BUMP;

 TEST:  PROC(T) RETURNS(BIT(1));
   DCL T PTR;
   IF T=HDPTR
     THEN RETURN('0'B);
   IF T->NXTPTR=HDPTR
     THEN RETURN('0'B);
   IF T->NXTPTR->RECSEQ>L2
     THEN RETURN('0'B);
   RETURN('1'B);
   END TEST;

 SPLIT:  PROC(T,J,LB);
   DCL (T,TMPPTR) PTR;
   DCL J FIXED BIN(15,0);
   DCL LB BIT(1);
   /* LB=1 IF LEADING BLANKS ARE TO ELIMINATED AFTER SPLIT */
   IF J>LENGTH(T->RECSTR)
     THEN RETURN;
   IF LB
     THEN BUF=SUBSTR(T->RECSTR,J);
     ELSE BUF=REPEAT(' ',J-2)××SUBSTR(T->RECSTR,J);
   T->RECSTR=SUBSTR(T->RECSTR,1,J-1);
   T->RECSTR=SUBSTR(T->RECSTR,1,SUFFIX(T->RECSTR,' '));
   /* ELIMINATES TRAILING BLANKS */
   SEQ=-1;
   CALL #ADD(RHPTR,RHHDRPT,T,TMPPTR,SEQ,BUF,0);
   IF TMPPTR->RECSEQ>L2
     THEN L2=TMPPTR->RECSEQ;
   END SPLIT;

 TYPE:  PROC(T) RETURNS(FIXED BIN(15,0));
 /* WILL IDENTIFY THE TYPE OF THE CURRENT STATEMENT FRAGMENT:
    1 = THEN
    2 = ELSE
    3 = DO
    4 = END
    5 = SELECT
    6 = BEGIN
    7 = PROC
    8 = IF STATEMENT START
    9 = DCL STATEMENT
   10 = DECLARE STATEMENT (WILL RETURN 9)
 OTKEY= OTHER - MUST END W/SEMICOLON
 COKEY= PLI COMMENT (WILL RETURN THIS VALUE ONLY IF COMMENT IS LAST
 *                   STATEMENT IN RANGE)
 QUKEY= QUOTED STRING
 SCKEY= SEMICOLON ENDING STATEMENT
 TDKEY= THEN-DO
 EDKEY= ELSE-DO
 WDKEY= WHEN-DO
 ODKEY= OTHERWISE-DO
 TIKEY= THEN-IF
 EIKEY= ELSE-IF
 WIKEY= WHEN-IF
 OIKEY= OTHERWISE-IF
 TSKEY= THEN-SELECT
 ESKEY= ELSE-SELECT
 WSKEY= WHEN-SELECT
 OSKEY= OTHERWISE-SELECT
 */
   DCL (T,MYT,MYK,RECPT,WRKPTR) PTR;
   DCL (I,J) FIXED BIN(15,0);
   MYT=SKIPCOM(T); /* GO FIND NON-COMMENT */
   IF MYT->LSTPTR^=HDPTR
     THEN IF ^TEST(MYT->LSTPTR)
       THEN RETURN(COKEY); /* IT MUST BE COMMENT AT END */
   IF MYT->RECSTR=';'
     THEN RETURN(SCKEY);
   DO MYT=MYT REPEAT BUMP(MYT);
     IF SUBSTR(MYT->RECSTR,1,1)=''''
       THEN LEAVE;
     IF SUBSTR(MYT->RECSTR,LENGTH(MYT->RECSTR),1)^=':'
       THEN LEAVE;
       END;
   DO I=1 TO HBOUND(SPLITKEY,1) UNTIL(J=1);
     J=BINDEX(MYT->RECSTR,SPLITKEY(I),'WORD',1);
     END;
   IF J=0
     THEN IF SUBSTR(MYT->RECSTR,1,1)=''''
       THEN I = QUKEY; /* IT IS QUOTED STRING */
       ELSE I = OTKEY; /* IT IS OTHER TYPE OF STATEMENT */
     ELSE IF I=10
       THEN I=9; /* CODE 10 (DECLARE) = CODE 9  (DCL) */
       ELSE IF I=1 × I=2 × I=11 × I=12 /* THEN,ELSE,WHEN,OTHERWISE? */
         THEN DO;
           IF I=11 /* IS IT WHEN? */
             THEN DO;
               J=INDEX(MYT->RECSTR,'(');
               IF J^=0
                 THEN MYK=FIND_PAREN(MYT,J);
                 ELSE MYK=MYT;
               MYK=SKIPCOM(MYK);
               END;
             ELSE DO;
               WRKPTR=MYT->NXTPTR;
               MYK=SKIPCOM(MYT->NXTPTR); /* GO FIND NON-COMMENT */
               END;
           DO B=0 TO HBOUND(BLTAB,1) UNTIL(J=1);
             J = BINDEX(MYK->RECSTR,BLTAB(B),'WORD',1);
             IF J=1
               THEN IF LENGTH(MYK->RECSTR)>LENGTH(BLTAB(B))
                 THEN IF ^(B=2 & SUBSTR(MYK->RECSTR,
                   LENGTH(BLTAB(B))+1,1)='(') &
                   SUBSTR(MYK->RECSTR,LENGTH(BLTAB(B))+1,1)^=' '
                   THEN J=0;
             END;
           IF B<=HBOUND(BLTAB,1)
             THEN DO;
               SELECT(I); /* SET BASIC TYPE CODE */
                 WHEN(1)   I=TDKEY; /* IT IS THEN-DO */
                 WHEN(2)   I=EDKEY; /* IT IS ELSE-DO */
                 WHEN(11)  I=WDKEY; /* IT IS WHEN-DO */
                 OTHERWISE I=ODKEY; /* IT IS OTHERWISE-DO */
                 END;
               I=I+B; /* IT IS ?-DO, ?-IF, OR ?-SELECT */
               END;
           END;
   RETURN(I);
   END TYPE;

 ELSE:  PROC(I) RETURNS(BIT(1));
   DCL I FIXED BIN(15,0);
   IF I=2 × I=EDKEY × I=EIKEY × I=ESKEY
     THEN RETURN('1'B);
     ELSE RETURN('0'B);
   END ELSE;

 THEN:  PROC(I) RETURNS(BIT(1));
   DCL I FIXED BIN(15,0);
   IF I=1 × I=TDKEY × I=TIKEY × I=TSKEY
     THEN RETURN('1'B);
     ELSE RETURN('0'B);
   END THEN;

 IF:  PROC(I) RETURNS(BIT(1));
   DCL I FIXED BIN(15,0);
   IF I=8 × I=TIKEY × I=EIKEY × I=WIKEY × I=OIKEY
     THEN RETURN('1'B);
     ELSE RETURN('0'B);
   END IF;

 SKIPCOM:  PROC(T) RETURNS(PTR);
 /* RETURNS NEXT FRAGMENT NOT A COMMENT, BLANK OR LABEL */
   DCL (T,MYT) PTR;
   DO MYT=T REPEAT(BUMP(MYT));
     DO MYT=MYT REPEAT(BUMP(MYT));
       IF INDEX(MYT->RECSTR,'/*')^=1
         THEN LEAVE; /* TO BYPASS BUG IN COMPILER */
       DO MYT=MYT REPEAT BUMP(MYT);
         IF INDEX(MYT->RECSTR,'*/')^=0
           THEN IF ^TEST(MYT)
             THEN RETURN(MYT->NXTPTR); /* COMMENT AT END */
             ELSE LEAVE;
         END;
       END;
     IF MYT->RECSTR^=''
       THEN IF SUBSTR(MYT->RECSTR,1,1)=''''
         THEN LEAVE;
         ELSE IF SUBSTR(MYT->RECSTR,LENGTH(MYT->RECSTR),1)^=':'
           THEN LEAVE;
     END;
   RETURN(MYT);
   END SKIPCOM;

 JUSTIFY:  PROC(T);
   DCL T PTR;
   T->RECSTR=SUBSTR(T->RECSTR,PREFIX(T->RECSTR,' '));
     /* ELIMINATES LEADING BLANKS */
   T->RECSTR=SUBSTR(T->RECSTR,1,SUFFIX(T->RECSTR,' '));
     /* ELIMINATES TRAILING BLANKS */
   END JUSTIFY;

 FORM:  PROC(PRMT) RETURNS(PTR);
 /* FORM WILL PROCESS AN ENTIRE STATEMENT.  THAT IS, UNTIL IT
    ENCOUNTERS A SEMICOLON */
 /* THIS PROCEDURE BEGINS THE RE-FORMAT PROCESS BY -
    (1) ELIMINATING LEADING AND TRAILING BLANKS.
    (2) REMOVING ALL COMMENTS TO SEPARATE LINES.
    (3) ENSURING THAT ONLY ONE STATEMENT, AT MOST,  APPEARS
        ON EACH LINE.
    (4) REMOVING QUOTED STRINGS TO SEPARATE LINES,
        AND READJUSTING THEM SO THEY START IN COLUMN 1.
    (5) ENSURING THAT ANY OF THE KEYWORDS IN SPLITKEY
        SHOW UP ONLY IN COLUMN 1.
    (6) REMOVES FROM CONSIDERATION BLANK LINES.
    (7) WHAT ABOUT LABELS?
    (8) NOTE:  IN THE ORIGINAL SOURCE, IF A STATEMENT IS CONTINUED
        FROM ONE LINE TO THE NEXT, AND IT IS BROKEN OFF IN THE MIDDLE
        OF A WORD, THIS SUBROUTINE WILL RECOMBINE THE WORD ON A
        SEPARATE LINE BY ITSELF.
    (9) ALL STATEMENTS WILL BE SPLIT AT COLONS, AND THE ONLY PART
        OF A STATEMENT TO BE CONSIDERED WILL BE AFTER THE LAST
        COLON.
   (10) SEMICOLONS WILL BE SPLIT TO A SEPARATE LINE
   */
   DCL SYMCK CHAR(100) VAR STATIC INIT(
     '$#@_ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789');
   DCL (I,J,K,L,LQ,S) FIXED BIN(15,0);
   DCL (PRMT,TMPPTR,T,Q,R,RECPT) PTR;
   DCL CARDSW BIT(1) INIT('0'B);
   T=PRMT;
   IF SAS
     THEN DO;
       I=INDEX(T->RECSTR,'CARDS');
       IF I=0
         THEN LEAVE;
       IF SUBSTR(T->RECSTR,1,I-1)=' '
         THEN CARDSW='1'B;
       END;
   DO T=T REPEAT BUMP(T);
     /* DO UNTIL WE FIND THE SEMICOLON */
     /* THIS DO-LOOP ELIMINATES BLANK LINES, COMMENTS AND QUOTES */
     DO WHILE('1'B);
       DO T=T REPEAT BUMP(T);
         IF T->RECSTR^=''
           THEN LEAVE;
         END;
       I = INDEX(T->RECSTR,''''); /* FIND FIRST QUOTE */
       J = INDEX(T->RECSTR,'/*'); /* FIND FIRST COMMENT, IF ANY */
       IF I+J=0
         THEN LEAVE; /* NO QUOTES OR COMMENTS */
       IF J^=0 & (J<I × I=0)
         THEN /* LINE HAS COMMENT ON IT */
           T = FORM_COMMENT(J,T);
         ELSE IF I^=0 & (I<J × J=0)
           THEN /* LINE HAS QUOTED STRING ON IT */
             T = FORM_QUOTE(I,T);
       END;
     /* AT THIS POINT, CURRENT LINE IS FREE OF QUOTED STRINGS
        AND PL/I-TYPE COMMENTS */
     /* NOW FIND AND FIX WORDS SPLIT BETWEEN LINES */
     IF LENGTH(T->RECSTR)=72
       THEN DO;
         L=SUFFIX(T->RECSTR,SYMCK);
         IF L=72
           THEN LEAVE;
         IF VERIFY(SUBSTR(T->RECSTR,L+1,1),'0123456789_')=0
           THEN LEAVE;
         Q=BUMP(T);
         IF Q->RECSTR=''
           THEN LEAVE;
         IF LENGTH(Q->RECSTR)<2
           THEN LEAVE;
         QL=PREFIX(SUBSTR(Q->RECSTR,2),SYMCK);
         IF QL=1
           THEN LEAVE;
         CALL SPLIT(T,L+1,'0'B);
         R=T->NXTPTR;
         CALL JUSTIFY(R); /* GO ELIMINATE LEADING & TRAILING BLANKS */
         R->RECSTR=R->RECSTR××SUBSTR(Q->RECSTR,2,QL);
         SUBSTR(Q->RECSTR,2,QL)='';
         END;
     CALL CHECK_SEMI(T); /* GO SPLIT OFF SEMICOLONS */
     IF T->RECSTR=';'
       THEN DO;
         IF CARDSW
           THEN DO;
             DO T=BUMP(T) REPEAT(BUMP(T));
               IF INDEX(T->RECSTR,';')^=0
                 THEN LEAVE;
               END;
             T=T->LSTPTR;
             END;
         RETURN(T);
         END;
     /* THE FOLLOWING DO LOOP WILL SPLIT ALL STATEMENTS AT COLONS,
        AND WILL ELIMINATE FROM FURTHER PROCESSING THAT PART
        PRECEDING THE LAST COLON.  */
     DO T=T REPEAT BUMP(T) UNTIL(J=0);
       CALL JUSTIFY(T); /* ELIMINATE LEADING AND TRAILING BLANKS */
       J = INDEX(T->RECSTR,':'); /* FIND FIRST COLON */
       IF J^=0
         THEN IF LENGTH(T->RECSTR)>J
           THEN CALL SPLIT(T,J+1,'0'B);/*SPLIT ALL LINES AT COLONS*/
       END;
     CALL CHECK_SEMI(T); /* GO SPLIT OFF SEMICOLONS */
     IF T->RECSTR=';'
       THEN RETURN(T);
     /* FOLLOWING DO LOOP SPLITS OFF ALL DATA
        BEGINNING WITH SPLITKEY VALUES */
     I = OTKEY; /* SET DEFAULT I */
     IF T->RECSTR^=''
       THEN IF SUBSTR(T->RECSTR,1,1)^='%'
         THEN DO I = 1 TO HBOUND(SPLITKEY,1);
           J = BINDEX(T->RECSTR,SPLITKEY(I),'WORD',2);
           IF J ^= 0
             THEN DO;
               IF LENGTH(T->RECSTR) >= J+LENGTH(SPLITKEY(I))
                 THEN IF (SUBSTR(T->RECSTR,J+LENGTH(SPLITKEY(I)),1)=
                   '(' & I^=5 /* SELECT */ & I^=11 /* WHEN */)
                   × SUBSTR(T->RECSTR,J+LENGTH(SPLITKEY(I)),1)='_'
                     THEN LEAVE;
               IF J>1
                 THEN IF SUBSTR(T->RECSTR,J-1,1)='_'
                   THEN LEAVE;
               CALL SPLIT(T,J,'0'B);
               END;
           END;
     END;
   END FORM;

 CHECK_SEMI:  PROC(T);
   DCL T PTR;
   DCL L FIXED BIN(15,0);
   CALL JUSTIFY(T); /* GO ELIMINATE LEADING & TRAILING BLANKS */
   L=INDEX(T->RECSTR,';');
   IF L>1
     THEN CALL SPLIT(T,L,'1'B);
     ELSE IF L=1
     THEN IF LENGTH(T->RECSTR)>1
       THEN CALL SPLIT(T,2,'0'B);
   /* AT THIS POINT T POINTS TO LINE CONTAINING EITHER ONLY A
   SEMICOLON IN COLUMN 1, OR NO SEMICOLONS WHATSOEVER. */
   END CHECK_SEMI;

 FORM_QUOTE:  PROC(I,PRMT) RETURNS(PTR);
 /* I IS OFFSET IN LINE POINTED TO BY PRMT WHERE QUOTE BEGINS.
    WHEN THIS SUBROUTINE RETURNS CONTROL, IT WILL RETURN THE
    POINTER TO THE LINE IMMEDIATELY FOLLOWING THE QUOTED STRING,
    IF THE QUOTED STRING ORIGINALLY BEGAN THE LINE, AND WILL
    RETURN THE LINE PRIOR TO THE QUOTED STRING IF THE QUOTED
    STRING DID NOT BEGIN THE LINE.
    THE QUOTED STRING WILL HAVE BEEN ISOLATED AND LEFT-JUSTIFIED.
 */
   DCL (I,J,K,L,S) FIXED BIN(15,0);
   DCL (T,PRMT,Q,RECPT) PTR;
   T = PRMT;
   IF I^=1 & SUBSTR(T->RECSTR,1,I-1)^=''
     THEN DO;
       CALL SPLIT(T,I,'0'B); /* SPLITS OFF QUOTE */
       RETURN(T); /* RETURN UNQUOTED DATA */
       END;
   /* NOW FIND END OF QUOTED STRING */
   S = I; /* FIRST TIME, STARTING QUOTE IN COL I */
   DO Q=T REPEAT BUMP(Q) UNTIL(K>0);
     CALL QSTR(Q->RECSTR,S,BUF,K);
     S=0; /* NEXT TIME, STARTING QUOTE IN PRIOR LINE */
     IF K=0
       THEN IF LENGTH(Q->RECSTR)<71
         THEN Q->RECSTR=Q->RECSTR××REPEAT(' ',70-LENGTH(Q->RECSTR));
     END;
   Q->RECSTR=SUBSTR(Q->RECSTR,1,SUFFIX(Q->RECSTR,' '));
   IF LENGTH(Q->RECSTR) >= K
     THEN IF SUBSTR(Q->RECSTR,K)^=' '
       THEN CALL SPLIT(Q,K,'0'B);/*SPLIT AFTER QUOTE*/
   T->RECSTR=SUBSTR(T->RECSTR,PREFIX(T->RECSTR,' '));
     /* ELIMINATE LEADING BLANKS */
   S=1;
   DO T=T REPEAT(BUMP(T)) UNTIL(K>0);
     CALL QSTR(T->RECSTR,S,BUF,K);
     IF S=0 /* IS IT SECOND LINE? */
       THEN DO;
         J=72-LENGTH(T->LSTPTR->RECSTR);
         /* J=NUMBER BYTES AVAILABLE IN PREVIOUS LINE */
         T->LSTPTR->RECSTR=T->LSTPTR->RECSTR××
           SUBSTR(T->RECSTR,2,MIN(J,LENGTH(T->RECSTR)));
         IF J<(LENGTH(T->RECSTR)-1)
           THEN T->RECSTR=SUBSTR(T->RECSTR,J+2);
           ELSE DO;
             Q=T->LSTPTR;
             CALL #PUTSLOT(RHPTR,RHHDRPT,T); /* CALL PUTSLOT */
             T=Q;
             END;
         END;
     S=0; /* INDICATE QUOTE STARTS IN PRIOR LINE */
     END;
   RETURN(T->NXTPTR); /* PASS BACK DATA AFTER QUOTE */
   END FORM_QUOTE;

 FORM_COMMENT:  PROC(J,PRMT) RETURNS(POINTER);
 /* LINE POINTED TO BY T HAS COMMENT ON IT.  J IS INDEX TO
    START OF COMMENT.  COMMENT WILL BE ISOLATED AND LEFT-JUSTIFIED.
    IF COMMENT STARTED LINE, POINTER TO LINE CONTAINING DATA AFTER
    COMMENT WILL BE RETURNED.  IF COMMENT DID NOT START LINE,
    POINTER TO LINE CONTAINING DATA BEFORE COMMENT WILL BE RETURNED.*/
   DCL (J,K) FIXED BIN(15,0);
   DCL (PRMT,T,RECPT) PTR;
   T = PRMT;
   IF J^=1 & SUBSTR(T->RECSTR,1,J-1)^=''
     THEN DO;
       CALL SPLIT(T,J,'0'B); /* SPLITS OFF COMMENT */
       RETURN(T);
       END;
   /* NOW FIND END OF COMMENT */
   K=0;
   DO T=T REPEAT BUMP(T) UNTIL(K^=0);
     CALL JUSTIFY(T); /* ELIMINATE LEADING AND TRAILING BLANKS */
     K=INDEX(T->RECSTR,'*/');
     END;
   IF SUBSTR(T->RECSTR,K+2)^=''
     THEN CALL SPLIT(T,K+2,'1'B);/*SPLIT OFF AFTER COMMENT*/
   RETURN(BUMP(T)); /* RETURN POINTER TO DATA AFTER COMMENT */
   END FORM_COMMENT;

 SHIFT:  PROC(IN,SPTR,EPTR,SUSW);
   DCL IN FIXED BIN(15,0);
   DCL (SPTR,EPTR,CPTR,T,Q,RECPT) PTR;
   DCL SUSW BIT(1);
   DCL (I,J,PRIOR) FIXED BIN(15,0);
   I=IN;
   T=SPTR;
   /* NOW FIND FIRST NON-COMMENT AND FIND ITS TYPE. */
   Q = SKIPCOM(T);
   IF Q^=HDPTR /* MAKE SURE IT ISN'T COMMENT AT END OF RANGE */
     THEN IF TYPE(Q)=9 /* IS IT DCL STATEMENT? */
       THEN DO;
         J=INDEX(Q->RECSTR,' ');
         IF J=0
           THEN DO;
             Q=BUMP(Q);
             K=1;
             END;
           ELSE K=PREFIX(SUBSTR(Q->RECSTR,J+1),' ')+J;
         IF VERIFY(SUBSTR(Q->RECSTR,K,1),'0123456789')=0
           THEN DO;
             CPTR=SPTR;
             CALL SHIFT_DCL(IN,1,EPTR);
             T=CPTR;
             END;
         END;
   CALL SHIFT_LOOP(IN,T,EPTR);

 SHIFT_LOOP:  PROC(IN,T,EPTR);
   DCL (T,SPTR,EPTR) PTR;
   DCL IN FIXED BIN(15,0);
   PRIOR=0;
   DO WHILE(T^=EPTR);
     IF SUBSTR(T->RECSTR,1,1)=''''
       THEN CALL SHIFT_QUOTE(IN,T);
       ELSE IF INDEX(T->RECSTR,'/*')=1
         THEN CALL SHIFT_COMMENT(IN,T);
         ELSE CALL SHIFT_OTHER(IN,T,EPTR);
     END;
   END SHIFT_LOOP;

 SHIFT_DCL:  PROC(IN,LVL,EPTR) RECURSIVE;
 /* IT IS DECLARE OF STRUCTURE */
   DCL (SPTR,EPTR,T,Q,RECPT) PTR;
   DCL (IN,LVL,NIN,NLVL,I,J,K) FIXED BIN(15,0);
   DO UNTIL(CPTR=EPTR);
     /* NOW FIND DELIMITING COMMA */
     T=CPTR;
     CPTR=FIND_COMMA(T);
     /* TELL SHIFT_OTHER NOT TO JOIN THIS TO PRIOR LINE. */
     /* GO SHIFT THIS LEVEL OF DECLARE */
     CALL SHIFT_LOOP(IN,T,CPTR);
     IF CPTR=EPTR
       THEN RETURN;
     Q=SKIPCOM(CPTR);
     I=INDEX(Q->RECSTR,' ');
     IF VERIFY(SUBSTR(Q->RECSTR,1,I-1),'0123456789')^=0
       /* ? */
       THEN RETURN;
     NLVL=SUBSTR(Q->RECSTR,1,I-1);
     IF NLVL<LVL
       THEN RETURN;
       ELSE IF NLVL>LVL
         THEN CALL SHIFT_DCL(IN+2,NLVL,EPTR);
     END;
   END SHIFT_DCL;

 SHIFT_QUOTE:  PROC(I,T);
   DCL (T,Q,RECPT) PTR;
   DCL (I,J,K) FIXED BIN(15,0);
   PRIOR=QUKEY;
   SUBSTR(T->RECFLGS,2,1)=SUSW;
   CALL QSTR(T->RECSTR,1,BUF,K);
     /* FIND OUT IF THIS LINE CONTAINS COMPLETE QUOTE */
   J=72-LENGTH(T->LSTPTR->RECSTR);
     /* J WILL EQUAL NUMBER OF BYTES AVAILABLE IN PREVIOUS LINE */
   IF J>=LENGTH(T->RECSTR)
     THEN DO;
       T->LSTPTR->RECSTR=T->LSTPTR->RECSTR××T->RECSTR;
       Q=T->NXTPTR;
       CALL #PUTSLOT(RHPTR,RHHDRPT,T); /* CALL PUTSLOT */
       T=Q;
       IF K>0 /* WAS IT COMPLETE QUOTED STRING? */
         THEN RETURN;
       /* IF THE ABOVE RETURN IS TAKEN, IT IS CASE 1:  T->RECSTR
          CONTAINS A COMPLETE QUOTED STRING WHICH FITS ON THE
          PREVIOUS LINE. */
       /* IF THE ABOVE RETURN IS NOT TAKEN, IT IS CASE 2:  T->RECSTR
          CONTAINS THE BEGINNING PART OF A QUOTED STRING, AND THIS
          PART FITS ON THE PREVIOUS LINE.  T NOW POINTS TO THE NEXT
          LINE CONTAINING PART OF THE QUOTED STRING. */
       SUBSTR(T->RECFLGS,2,1)=SUSW;
       END;
     ELSE IF K>0 & LENGTH(T->RECSTR)+I <= 72
       THEN DO;
         /* IT IS CASE 3:  T->RECSTR CONTAINS A COMPLETE QUOTED
            STRING THAT WILL NOT FIT ON THE PREVIOUS LINE, BUT
            WILL FIT ON THIS LINE. */
         T->RECSTR=REPEAT(' ',I-1)××T->RECSTR;
         T=BUMP(T);
         RETURN;
         END;
       ELSE DO;
         /* IT IS CASE 4:  T->RECSTR CONTAINS THE BEGINNING PART OF A
            QUOTED STRING THAT WILL NOT FIT ON THE PREVIOUS LINE,
            AND WILL NOT FIT IN ITS ENTIRETY ON THIS LINE. */
         T->LSTPTR->RECSTR=T->LSTPTR->RECSTR××SUBSTR(T->RECSTR,1,J);
         T->RECSTR=SUBSTR(T->RECSTR,J+1);
         END;
   /* AT THIS POINT T WILL NOT CONTAIN THE STARTING SEGMENT OF A
      QUOTED STRING, BUT IT WILL POINT TO A LINE CONTAINING A
      SEGMENT OF A QUOTED STRING. */
   DO T=T REPEAT(BUMP(T)) UNTIL(K>0);
     SUBSTR(T->RECFLGS,2,1)=SUSW;
     J=72-LENGTH(T->LSTPTR->RECSTR);
       /* J WILL EQUAL NUMBER OF BYTES AVAILABLE IN PREVIOUS LINE */
     IF J>0
       THEN DO;
         J = MIN(J,LENGTH(T->RECSTR));
         T->LSTPTR->RECSTR=T->LSTPTR->RECSTR××SUBSTR(T->RECSTR,1,J);
         IF J=LENGTH(T->RECSTR)
           THEN DO;
             CALL QSTR(T->RECSTR,0,BUF,K);
               /* FIND OUT IF THIS LINE ENDS THE QUOTE */
             Q=T->NXTPTR;
             CALL #PUTSLOT(RHPTR,RHHDRPT,T); /* CALL PUTSLOT */
             T=Q;
             IF K>0
              THEN RETURN;
             END;
           ELSE T->RECSTR=SUBSTR(T->RECSTR,J);
         END;
     /* AT THIS POINT, PREVIOUS LINE HAS BEEN FILLED UP, AND T->RECSTR
        CONTAINS THE NEXT SEGMENT OF THE QUOTED STRING. */
     CALL QSTR(T->RECSTR,0,BUF,K);
       /* FIND OUT IF THIS LINE ENDS THE QUOTE */
     END;
   T=BUMP(T);
   END SHIFT_QUOTE;

 SHIFT_COMMENT:  PROC(I,T);
   DCL (T,Q,RECPT) PTR;
   DCL (I,J,K,P) FIXED BIN(15,0);
   P=PRIOR;
   PRIOR=COKEY;
   SUBSTR(T->RECFLGS,2,1)=SUSW;
   K=INDEX(T->RECSTR,'*/'); /* IS IT COMPLETE COMMENT? */
   IF K>0 & P^=COKEY & T->LSTPTR^=HDPTR
     THEN DO;
       J=71-LENGTH(T->LSTPTR->RECSTR);
        /* J WILL EQUAL NUMBER OF BYTES AVAILABLE IN PREVIOUS LINE */
       IF J>=LENGTH(T->RECSTR)
         THEN DO;
           T->LSTPTR->RECSTR=T->LSTPTR->RECSTR××' '××T->RECSTR;
           Q=T->NXTPTR;
           CALL #PUTSLOT(RHPTR,RHHDRPT,T); /* CALL PUTSLOT */
           T=Q;
           RETURN;
           END;
       END;
   DO T=T REPEAT(BUMP(T)) UNTIL(K>0);
     SUBSTR(T->RECFLGS,2,1)=SUSW;
     J = 72-I;
       /* J = MAX NUMBER OF BYTES TO GO ON THIS LINE */
     IF J < LENGTH(T->RECSTR)
       THEN CALL SPLIT(T,J,'1'B);
         /* SHIFT EXCESS TO NEXT LINE */
     T->RECSTR=REPEAT(' ',I-1)××T->RECSTR;
     K=INDEX(T->RECSTR,'*/');
     END;
   T = BUMP(T);
   END SHIFT_COMMENT;

 SHIFT_OTHER:  PROC(IN,T,EPTR);
   DCL (T,EPTR,Q,RECPT) PTR;
   DCL BLANK CHAR(1) VAR;
   DCL (IN,I,J,K,L,P) FIXED BIN(15,0);
   P=PRIOR;
   PRIOR=OTKEY;
   SUBSTR(T->RECFLGS,2,1)=SUSW;
   IF P^=0 & (P^=COKEY × (P=COKEY & (T->RECSTR=';' × T->RECSTR=',')))
     THEN DO;
       J=71-LENGTH(T->LSTPTR->RECSTR);
       /* J WILL EQUAL NUMBER BYTES AVAILABLE IN PREVIOUS LINE */
       IF J>0
         THEN DO;
           K=SPOT(T,J);
           /* K=FIRST OFFSET LESS THAN J WHERE LINE CAN BE SPLIT */
           IF K>0
             THEN DO;
               IF VERIFY(SUBSTR(T->LSTPTR->RECSTR,
                 LENGTH(T->LSTPTR->RECSTR),1),DLMTAB)=0 &
                 VERIFY(SUBSTR(T->RECSTR,1,1),DLMTAB)=0
                 THEN BLANK=' ';
                 ELSE BLANK='';
               T->LSTPTR->RECSTR=T->LSTPTR->RECSTR××BLANK××
                 SUBSTR(T->RECSTR,1,K);
               IF K=LENGTH(T->RECSTR)
                 THEN DO;
                   Q=T->NXTPTR;
                   CALL #PUTSLOT(RHPTR,RHHDRPT,T);
                     /* CALL PUTSLOT */
                   T=Q;
                   RETURN;
                   END;
                 ELSE T->RECSTR=SUBSTR(T->RECSTR,K+1);
               END;
           END;
       END;
   DO UNTIL(K>=L);
     SUBSTR(T->RECFLGS,2,1)=SUSW;
       /* SHIFT ALL DATA ON THIS LINE */
     J=72-IN;
       /* J=MAX NUMBER OF BYTES TO GO ON THIS LINE */
     K=SPOT(T,J);
       /* K=LAST SPOT TO SPLIT T->RECSTR <= J */
     L=LENGTH(T->RECSTR);
     IF K < L
       /* SHIFT EXCESS TO NEXT LINE */
       THEN CALL SPLIT(T,K+1,'1'B);
     T->RECSTR=REPEAT(' ',IN-1)××T->RECSTR;
     /* SHIFT LINE */
     T=BUMP(T);
     END;
   END SHIFT_OTHER;

 SPOT:  PROC(T,J) RETURNS(FIXED BIN(15,0));
   /* THIS SUBROUTINE RETURNS THE FIRST OFFSET LESS THAN OR
      EQUAL TO THE OFFSET SPECIFIED IN J WHERE THE LINE CAN BE SPLIT*/
   DCL T PTR;
   DCL (J,K) FIXED BIN(15,0);
   IF LENGTH(T->RECSTR)<=J
     THEN RETURN(LENGTH(T->RECSTR));
   K=SUFFIX(SUBSTR(T->RECSTR,1,J),DLMTAB);
   IF SUBSTR(T->RECSTR,K,1)='-'
     THEN IF LENGTH(T->RECSTR)>K
       THEN IF SUBSTR(T->RECSTR,K+1,1)='>'
         THEN K=K-1;
   RETURN(K);
   END SPOT;

 FIND_COMMA:  PROC(SPTR) RETURNS(PTR);
   DCL SPTR PTR;
 /* THIS SUBROUTINE, WILL SCAN FOR AND LOCATE THE NEXT
 DELIMITING COMMA OR SEMICOLON OUTSIDE PARENTHESES AND
 QUOTED STRINGS.  THE SUBROUTINE WILL FIRST SPLIT THE
 LINE FOLLOWING THE COMMA, IF NECESSARY, AND WILL RETURN
 THE POINTER TO THE LINE FOLLOWING THE COMMA OR SEMICOLON */
   DCL T PTR;
   DCL (I,J,K,L,M) FIXED BIN(15,0);
   T=SPTR;
   DO WHILE('1'B);
     T=SKIPCOM(T);
     IF T->RECSTR=';'
       THEN RETURN(T->NXTPTR);
     IF SUBSTR(T->RECSTR,1,1)=''''
       THEN T=SKIPQUOT(T);
       ELSE DO;
         I=INDEX(T->RECSTR,',');
         J=INDEX(T->RECSTR,'(');
         IF I+J=0
           THEN T=BUMP(T);
           ELSE IF I^=0 & (J=0 × I<J)
             THEN DO;
               IF LENGTH(T->RECSTR)>I
                 THEN CALL SPLIT(T,I+1,'1'B);
               RETURN(T->NXTPTR);
               END;
             ELSE IF J^=0 /* DO WE HAVE OPENING PARENTHESIS? */
               THEN T=FIND_PAREN(T,J); /* T SET AFTER CLOSING ) */
         END;
     END;
   END FIND_COMMA;

 SKIPQUOT:  PROC(T) RETURNS(PTR);
 /* RETURNS NEXT FRAGMENT NOT A QUOTE */
   DCL (T,MYT) PTR;
   DCL (K,S) FIXED BIN(15,0);
   S=1;
   DO MYT=T REPEAT BUMP(MYT) UNTIL(K>0);
     CALL QSTR(MYT->RECSTR,S,BUF,K);
     S=0;
     END;
   RETURN(BUMP(MYT));
   END SKIPQUOT;
   END SHIFT;

 FIND_PAREN:  PROC(PPTR,PJ) RETURNS(PTR);
 /* PPTR POINTS TO RECORD CONTAINING STARTING PARENTHESIS. */
 /* PJ IS INDEX WITHIN RECORD TO STARTING PARENTHESIS. */
 /* FIND_PAREN WILL LOCATE THE CLOSING PARENTHESIS, WILL SPLIT OFF */
 /* TRAILING DATA AFTER THE CLOSING PARENTHESIS, IF NECESSARY, */
 /* AND WILL RETURN THE POINTER TO THE DATA FOLLOWING THE CLOSING */
 /* PARENTHESIS. */
   DCL (PJ,I,J,K,L) FIXED BIN(31,0);
   DCL (PPTR,T) PTR;
   T=PPTR;
   K=1;
   I=PJ;
   DO UNTIL(K=0);
     L=INDEX(SUBSTR(T->RECSTR,I+1),')')+I;
     IF L=I
       THEN L=LENGTH(T->RECSTR)+1;
     J=INDEX(SUBSTR(T->RECSTR,I+1),'(')+I;
     IF J > L × (J=I & L<=LENGTH(T->RECSTR))
       /* FOUND NEXT CLOSING PAREN */
       THEN DO;
         K=K-1;
         I=L;
         END;
       ELSE IF J>I
         /* FOUND NEXT OPENING PAREN */
         THEN DO;
           K=K+1;
           I=J;
           END;
         ELSE DO;
           /* GO EXAMINE NEXT LINE */
           T=BUMP(T);
           I=0;
           END;
     END;
   /* AT THIS POINT L=INDEX TO CLOSING PAREN */
   IF LENGTH(T->RECSTR)>L
     THEN CALL SPLIT(T,L+1,'1'B);
   T=BUMP(T);
   RETURN(T);
   END FIND_PAREN;
   END ABE034;
