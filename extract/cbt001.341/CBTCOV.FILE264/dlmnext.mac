 /* COPYRIGHT 1983 BY THOMAS GLEN SMITH */
 /*
0*$.HE GENERALIZED SUBROUTINES - DLMNEXT
0*$.HE LOCATE NEXT DELIMITER
0*$.PL 55
0*$.PN 0
0*$.PA
0*$.SS
0*$.NF
0*$11/15/83
0*$AUTHOR:  T. SMITH
0*$SOURCE MODULE NAME: DLMNEXT
0*$DOCUMENTATION ID:  0*$
0*$.FI L
0*$.SP 5
0*$THIS PL/I SUBROUTINE PROVIDES A SIMPLIFIED METHOD OF LOCATING THE
0*$NEXT OPERAND IN A COMMAND BUFFER.  AN OPERAND CAN BE ONE OF THE
0*$FOLLOWING:
0*$.IN 2
0*$.SP 1
0*$1.  A QUOTED STRING, E.G. 'DON''T'.  NOTE THAT ANY NESTED SINGLE
0*$QUOTES MUST BE PAIRED, AS IN THE EXAMPLE.
0*$.SP 1
0*$2.  A PARENTHESIZED STRING, E.G. (A ' (ABC)).  NOTE THAT ANY
0*$NESTED LEFT PARENTHESES MUST HAVE MATCHING RIGHT PARENTHESES,
0*$AS IN THE EXAMPLE.  NOTE ALSO THAT SINGLE QUOTES DO NOT HAVE TO
0*$BE PAIRED.
0*$.SP 1
0*$3.  A KEYWORD-TYPE, E.G. ABC(XYZ ' (ABC)).
0*$.SP 1
0*$4.  A PLAIN OPERAND, E.G. ABC.
0*$.IN 0
0*$.SP 1
0*$EACH OPERAND MUST BE DELIMITED FROM ITS NEIGHBOR BY AT LEAST ONE
0*$BLANK, EXCEPT AN OPERAND DELIMITED BY PARENTHESES.
0*$.SP 1
0*$CALL FORMAT IS AS FOLLOWS:
0*$.SP 1
0*$CALL DLMNEXT(BUF,M,N);
0*$.SP 1
0*$WHERE -
0*$.SP 1
0*$BUF IS CHAR(*) VARYING, AND IS THE COMMAND BUFFER TO BE SCANNED.
0*$.SP 1
0*$M IS FIXED BIN(15,0), AND IS FIRST SET TO THE MAX(N,0). IF IT IS
0*$NOT THE CONDITION THAT M IS GREATER THAN 0 AND SUBSTR(BUF,M,1)='('
0*$THEN M IS INCREMENTED BY 1.
0*$N SHOULD CONTAIN THE INDEX VALUE INTO BUF WHERE THE SCAN IS TO
0*$BEGIN.  AFTER SETTING M, IF SUBSTR(BUF,M,1)=' ', M WILL BE
0*$UPDATED TO POINT TO THE NEXT NON-BLANK CHARACTER IN BUF.  IF
0*$A NON-BLANK ISN'T FOUND BEFORE THE END OF BUF, M WILL BE SET TO
0*$LENGTH(BUF)+1.
0*$.SP 1
0*$N IS FIXED BIN(15,0), AND WILL BE SET BY DLMNEXT TO THE NEXT
0*$DELIMITER, AS DEFINED ABOVE, AFTER THE NON-BLANK CHARACTER
0*$INDEXED BY M, AFTER M HAS BEEN UPDATED AS INDICATED ABOVE.
 */
 DLMNEXT: PROC(BUF,M,N) OPTIONS(REENTRANT);
   DCL BUF CHAR(*) VAR;
   DCL (M,N) FIXED BIN(15,0);
   DFT RANGE(*) FIXED BIN VALUE(FIXED BIN(15,0));
   DCL PSTR ENTRY(CHAR(*) VAR, FIXED BIN(15,0))
     RETURNS(FIXED BIN(15,0));
   HALT;
   M=MAX(N,0);
   L=LENGTH(BUF);
   IF M>L
     THEN DO;
       M=L+1;
       N=M;
       RETURN;
       END;
   /* NOW FIND NEXT NON-BLANK */
   DO;
     IF M>0
       THEN IF SUBSTR(BUF,M,1)='('
         THEN LEAVE;
     DO M=M+1 REPEAT M+1 WHILE(M<=L);
       IF SUBSTR(BUF,M,1)^=' '
         THEN LEAVE;
       END;
     END;
   IF M>L
     THEN DO;
       N=M;
       RETURN;
       END;

   /* NOW SET N */
   IF SUBSTR(BUF,M,1)=''''
     THEN DO; /* IT IS QUOTED STRING OPERAND */
       N=QPROC(M);
       RETURN;
       END;
   IF SUBSTR(BUF,M,1)='('
     THEN DO; /* IT IS PARENTHESIZED OPERAND */
       N=PSTR(BUF,M);
       IF N=0
         THEN N=L;
       N=N+1;
       RETURN;
       END;
   I=INDEX(SUBSTR(BUF,M),' ');
   IF I=0
     THEN I=L+1;
     ELSE I=I+M-1;
   J=INDEX(SUBSTR(BUF,M),'(');
   IF J=0
     THEN J=L+1;
     ELSE J=J+M-1;
   IF I<=J
     THEN DO; /* IT IS PLAIN OPERAND */
       N=I;
       RETURN;
       END;
   /* IF CONTROL REACHES HERE, IT MUST BE KEYWORD OPERAND */
   N=PSTR(BUF,J)+1;
   IF N=1
     THEN N=L+1;
   RETURN;

 QPROC: PROC(M) RETURNS(FIXED BIN(15,0));
 /**********************************************************************
 *                                                                     *
 * QPROC IS CALLED TO LOCATE THE END OF A QUOTED STRING.               *
 *                                                                     *
 **********************************************************************/
   DCL (M,I,J,K,D) FIXED BIN(15,0);
   I = M;
   D=0;
   DO UNTIL(D=1);
     J=INDEX(SUBSTR(BUF,I+1),'''')+I;
     IF J > I
       THEN DO;
         I=J;
         IF I < L
           THEN IF SUBSTR(BUF,I+1,1) = ''''
             THEN I=I+1;
             ELSE D=1;
           ELSE D=1;
         END;
       ELSE D=1;
     END;
   RETURN(I+1);
   END QPROC;

   END DLMNEXT;
