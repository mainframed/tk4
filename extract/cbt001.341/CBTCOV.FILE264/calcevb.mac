 /* CALCEVB */
 /*
0*$.HE GENERALIZED SUBROUTINES - CALCEVB
0*$.HE GENERALIZED EXPRESSION CALCULATOR
0*$.PL 55
0*$.PN 0
0*$.PA
0*$.SS
0*$.NF
0*$03/17/83
0*$AUTHOR:  T. SMITH
0*$SOURCE MODULE NAME:  CALCEVB
0*$DOCUMENTATION ID:  0*$
0*$.FI L
0*$.SP 5
0*$THIS SUBROUTINE PROVIDES A GENERALIZED EXPRESSION CALCULATOR
0*$FUNCTION.  CALL FORMAT IS AS FOLLOWS:
0*$.SP 1
0*$.IN 5
0*$VALUE=CALCEVB(GET_OPERAND,GET_OPERAND_CHAR,PUT_OPERAND,
0*$ODD_FUNCTION,ECHOSW,NEWHDR,MSG);
0*$.IN 0
0*$.SP 1
0*$WHERE -
0*$.HI 4
0*$.SP 1
0*$VALUE IS DEC FLOAT(16).  IT WILL CONTAIN THE VALUE OF THE
0*$EVALUATED EXPRESSION POINTED TO BY NEWHDR (SEE BELOW).
0*$.SP 1
0*$GET_OPERAND,GET_OPERAND_CHAR,PUT_OPERAND, AND ODD_FUNCTION ARE
0*$IDENTICAL TO THE SAME OPERANDS TO SUBROUTINE CALCEVA (SEE
0*$DOCUMENTATION ELSEWHERE).
0*$.SP 1
0*$ECHOSW IS BIT(1), AND IS USED INTERNALLY BY CALCEVB.
0*$.SP 1
0*$NEWHDR IS A POINTER TO THE LIST OF TOKENS RETURNED BY THE
0*$POLISH SUBROUTINE.  IT REPRESENTS THE EXPRESSION TO BE EVALUATED
0*$DURING THIS INVOCATION OF CALCEVB.
0*$.SP 1
0*$MSG CHAR(80) VAR, AND WILL BE SET TO AN ERROR MESSAGE IF ANY
0*$THING IS FOUND IN ERROR IN THE EXPRESSION TO BE EVALUATED.
0*$.HI 0
0*$.SP 1
0*$CALCEVB IS CALLED BY CALCEVA AS A SUBROUTINE FOR EACH EXPRESSION
0*$TO BE EVALUATED.  MUCH OF THE DOCUMENTATION REGARDING EXPRESSIONS
0*$CAN BE READ IN THE TEXT DESCRIBING CALCEVA.  A NOTE, HOWEVER,
0*$SHOULD BE MADE REGARDING MISSING VALUES.  ANY OPERAND WHOSE
0*$FLOATING POINT VALUE IS INTERNALLY REPRESENTED BY X'80000000'
0*$IS CONSIDERED TO BE A MISSING VALUE.  ANY ARITHMETIC OPERATION
0*$INVOLVING A MISSING VALUE WILL RESULT IN A MISSING VALUE.
0*$FOR COMPARISON PURPOSES, MISSING VALUES ARE EQUIVALENT TO MINUS
0*$INFINITY.
 */
 CALCEVB: PROC(GET_OPERAND,GET_OPERAND_CHAR,PUT_OPERAND,ODD_FUNCTION,
   ECHOSW,NEWHDR,MSG) RETURNS(DEC FLOAT(16))
   RECURSIVE OPTIONS(REENTRANT);
   DCL GET_OPERAND ENTRY(PTR)
     RETURNS(FLOAT DEC(16));
   DCL GET_OPERAND_CHAR ENTRY(PTR)
     RETURNS(CHAR(256) VAR);
   DCL PUT_OPERAND ENTRY(PTR,FLOAT DEC(16),CHAR(80) VAR);
   DCL ODD_FUNCTION ENTRY(CHAR(80) VAR,PTR,FIXED BIN(15,0),)
     RETURNS(DEC FLOAT(16));
   DCL CALCPRT ENTRY(DEC FLOAT(16))
     RETURNS(CHAR(80) VAR);
   DCL ECHOSW BIT(1);
   DCL (NEWHDR,LSTPTR) PTR;
   DCL MSG CHAR(80) VAR;
   DCL VALUE DEC FLOAT(16);
   DCL NILADIC_IX FIXED BIN(15,0) STATIC INIT(4);
   DCL MONADIC_IX FIXED BIN(15,0) STATIC INIT(34);
   DCL DYADIC_IX  FIXED BIN(15,0) STATIC INIT(38);
   DCL POLYADIC_IX FIXED BIN(15,0) STATIC INIT(40);
   DFT RANGE(*) FIXED BIN VALUE(FIXED BIN(31,0));
   DCL OPERAND          INIT(0) FIXED STATIC;
   DCL OPERATOR         INIT(1) FIXED STATIC;
   DCL KEYWORD          INIT(2) FIXED STATIC;
   DCL TYPE_SPCHAR      INIT(3) FIXED STATIC;
   DCL QUOTED_STRING    INIT(4) FIXED STATIC;
   DCL NUMERIC_CONSTANT INIT(5) FIXED STATIC;
   DCL NO_MORE_TOKENS   INIT(6) FIXED STATIC;
   DCL OTHER            INIT(7) FIXED STATIC;
   DCL FUNCTION_A       INIT(8) FIXED STATIC;
   DCL TEMPORARY        INIT(9) FIXED STATIC;
   DCL FUNCTION_B       INIT(10) FIXED STATIC;
   DCL ASSIGNMENT       INIT(17) FIXED STATIC;
   DCL TIME BUILTIN;
   DCL NULL BUILTIN;
   DCL EVAL ENTRY(PTR,CHAR(80) VAR,,,)
     RETURNS(FLOAT DEC(16));
   DCL 1 TOKEN BASED(TOKPTR),
     2 PRIOR_TOKEN PTR,
     2 NEXT_TOKEN PTR,
     2 ELIX FIXED BIN(15,0),
     2 TYPE FIXED BIN(15,0),
     2 SUBTYPE FIXED BIN(15,0),
     2 TOKSTR CHAR(256) VAR;
   DCL 1 TOKEN2 BASED(TOKPTR),
     2 PAD CHAR(12),
     2 TEMPVALUE FLOAT DEC(16);
   DCL MISSING DEC FLOAT(16);
   DCL 1 STACKEL BASED(STACKPTR),
     2 STACKNEXT PTR,
     2 STACKELP PTR;

   UNSPEC(MISSING)='1'B; /* SET MISSING VALUE */
   RETURN(EVAL(NEWHDR,MSG,FUNCTION,DO_OPERATOR,GET_OPERAND));

 FUNCTION: PROC(MSG,PARMCNT,PRMPTR,STACK,POP) RETURNS(FLOAT DEC(16));
 /**********************************************************************
 * CALLED BY EVAL WHENEVER A FUNCTION REFERENCE IS RECOGNIZED IN THE   *
 * POLISH EXPRESSION BEING EVALUATED.                                  *
 **********************************************************************/
   DCL MSG CHAR(80) VAR;
     /* PLACE TO STORE ERROR MESSAGES */
   DCL PARMCNT FIXED BIN(15,0);
     /* PARMCNT=NUMBER OF PARAMETERS ON STACK FOR FUNCTION */
   DCL PRMPTR PTR;
     /* PTR TO THE TOKEN STRUCTURE FOR THE FUNCTION NAME */
   DCL STACK PTR; /* OPERAND STACK */

   DCL POP ENTRY(CHAR(80) VAR,PTR,) RETURNS(FLOAT DEC(16));
   DCL RET FLOAT DEC(16);
   DCL (DATE,TIME) BUILTIN;
   DCL FACTORL ENTRY(DEC FLOAT(16)) RETURNS(DEC FLOAT(16));
   DCL OP(10) DEC FLOAT(16);
   DCL OPCH(2) CHAR(256) VAR;
   DCL (I,J,K) FIXED BIN(15,0);
   DCL INT FIXED BIN(31,0);
   DCL PI DEC FLOAT(16) STATIC INIT(3.141592654);

   IF PARMCNT>HBOUND(OP,1)
     THEN DO;
       MSG='TOO MANY PARAMETERS';
       SIGNAL CONDITION(BADEXP);
       END;
   /* FIRST CHECK FOR CHARACTER FUNCTIONS */
   SELECT(PRMPTR->TOKSTR);
     WHEN('LENGTH')
       RETURN(LENGTH(POPCH(MSG,STACK)));
     WHEN('INDEX','VERIFY') DO;
       DO I=1 TO 2;
         OPCH(I)=POPCH(MSG,STACK);
         END;
       IF PRMPTR->TOKSTR='INDEX'
         THEN RETURN(INDEX(OPCH(1),OPCH(2)));
         ELSE RETURN(VERIFY(OPCH(1),OPCH(2)));
       END;
     OTHERWISE;
     END; /* SELECT */

   /* NO CHARACTER FUNCTIONS GET TO THIS POINT */
   DO I=1 TO PARMCNT;
     OP(I)=POP(MSG,STACK,GET_OPERAND);
     END;
   SELECT(PARMCNT);
     WHEN(0) SELECT(PRMPTR->TOKSTR); /* NILADIC FUNCTION REFERENCE */
       WHEN('ECHO') RET=ECHO;
       WHEN('DATE') DO;
         RET=GET_OPERAND(PRMPTR);
         IF RET<1
           THEN RET=DATE;
         END;
       WHEN('TIME') RET=TIME;
       OTHERWISE RET=ODD_FUNCTION(MSG,PRMPTR,PARMCNT,OP);
       END; /* SELECT */
     WHEN(1) SELECT(PRMPTR->TOKSTR); /* MONADIC FUNCTION REFERENCE */
       WHEN('ABS')   RET=ABS(OP(1));
       WHEN('ACOS')  RET=ACOS(OP(1));
       WHEN('ASIN')  RET=ASIN(OP(1));
       WHEN('ATAN')  RET=ATAN(OP(1));
       WHEN('ATAND') RET=ATAND(OP(1));
       WHEN('ATANH') RET=ATANH(OP(1));
       WHEN('CEIL')  RET=CEIL(OP(1));
       WHEN('COS')   RET=COS(OP(1));
       WHEN('COSD')  RET=COSD(OP(1))+0.0;
       WHEN('COSH')  RET=COSH(OP(1));
       WHEN('ERF')   RET=ERF(OP(1));
       WHEN('ERFC')  RET=ERFC(OP(1));
       WHEN('EXP')   RET=EXP(OP(1));
       WHEN('FACT')  RET=FACTORL(OP(1));
       WHEN('FIXED','INT') RET=FIXED(OP(1));
       WHEN('FLOOR') RET=FLOOR(OP(1));
       WHEN('LOG')   RET=LOG(OP(1));
       WHEN('LOG2')  RET=LOG2(OP(1));
       WHEN('LOG10') RET=LOG10(OP(1));
       WHEN('MAX')   RET=OP(1);
       WHEN('MIN')   RET=OP(1);
       WHEN('ROUND') RET=ROUND(OP(1),0);
       WHEN('SIGN')  RET=SIGN(OP(1));
       WHEN('SIN')   RET=SIN(OP(1));
       WHEN('SIND')  RET=SIND(OP(1))+0.0;
       WHEN('SINH')  RET=SINH(OP(1));
       WHEN('SQRT')  RET=SQRT(OP(1));
       WHEN('TAN')   RET=TAN(OP(1));
       WHEN('TAND')  RET=TAND(OP(1));
       WHEN('TANH')  RET=TANH(OP(1));
       WHEN('TRUNC') RET=TRUNC(OP(1));
       WHEN('RND') DO;
         IF OP(1)<0
           THEN DO;
             RET=SUBSTR(TIME,7);
             OP(1)=RET/1000;
             END;
         RET,INT=(PI+OP(1))**8;
         RET=RET-INT;
         END;
       OTHERWISE RET=ODD_FUNCTION(MSG,PRMPTR,PARMCNT,OP);
       END; /* SELECT */
     WHEN(2) SELECT(PRMPTR->TOKSTR); /* DYADIC FUNCTION REFERENCE */
       WHEN('ATAN') RET=ATAN(OP(1),OP(2));
       WHEN('ATAND') RET=ATAND(OP(1),OP(2));
       WHEN('MAX') RET=MAX(OP(1),OP(2));
       WHEN('MIN') RET=MIN(OP(1),OP(2));
       WHEN('MOD') RET=MOD(OP(1),OP(2));
       OTHERWISE RET=ODD_FUNCTION(MSG,PRMPTR,PARMCNT,OP);
       END; /* SELECT */
     OTHERWISE DO; /* POLYADIC FUNCTION REFERENCE */
       IF ^(PRMPTR->SUBTYPE>DYADIC_IX & PRMPTR->SUBTYPE<=POLYADIC_IX)
         THEN RET=ODD_FUNCTION(MSG,PRMPTR,PARMCNT,OP);
         ELSE DO;
           RET=OP(1);
           DO I=2 TO PARMCNT;
             IF PRMPTR->TOKSTR='MAX'
               THEN RET=MAX(RET,OP(I));
               ELSE RET=MIN(RET,OP(I));
             END;
           END;
       END;
     END; /* SELECT */
   RETURN(RET);
   END FUNCTION;

 ECHO: PROC RETURNS(FLOAT DEC(16));
   ECHOSW=^ECHOSW;
   RETURN(ECHOSW);
   END ECHO;

 DO_OPERATOR: PROC(MSG,PRMPTR,STACK,POP) RETURNS(FLOAT DEC(16));
 /**********************************************************************
 * CALLED TO PROCESS AN OPERATOR IN THE POLISH EXPRESSION BEING        *
 * EVALUATED.                                                          *
 **********************************************************************/
   DCL MSG CHAR(80) VAR;
     /* PLACE TO STORE ERROR MESSAGES */
   DCL PRMPTR PTR;
     /* PTR TO OPERATOR TOKEN */
   DCL STACK PTR; /* OPERAND STACK */
   DCL POP ENTRY(CHAR(80) VAR,PTR,) RETURNS(FLOAT DEC(16));
     /* POPS OPERANDS FROM OPERAND STACK */
   DCL (OP1,OP2,RET) FLOAT DEC(16);
   DCL I FIXED BIN(15,0);
   DCL BSTR BIT(80) VAR;
   DCL CSTR CHAR(80) VAR;
   IF PRMPTR->SUBTYPE<0
     THEN RETURN(DO_LITOP(
       POPCH(MSG,STACK),
       POPCH(MSG,STACK))); /* STRING OPERATION */
   OP2=POP(MSG,STACK,GET_OPERAND);
   IF UNSPEC(OP2)=UNSPEC(MISSING)
     THEN IF ^MISSING_OK(PRMPTR->SUBTYPE)
       THEN RETURN(MISSING);
   SELECT(PRMPTR->SUBTYPE);
     WHEN(31) /* PREFIX PLUS */
       RET=OP2;
     WHEN(32) /* PREFIX MINUS */
       RET=-OP2;
     WHEN(33) DO; /* PREFIX NOT */
       CSTR=CALCPRT(OP2);
       I=INDEX(CSTR,'.');
       IF I^=0
         THEN CSTR=SUBSTR(CSTR,1,I-1);
       IF LENGTH(CSTR)=0
         THEN CSTR='0';
       IF VERIFY(CSTR,' 01')=0
         THEN BSTR=CSTR;
         ELSE BSTR='0'B;
       BSTR=^BSTR;
       RET=BSTR;
       END;
     WHEN(17) DO; /* IS IT ASSIGNMENT OPERATOR? */
       IF STACK=NULL
         THEN DO;
           MSG='ERROR IN ASSIGNMENT - NO VALUE ON OPERAND STACK';
           SIGNAL CONDITION(BADEXP);
           END;
       IF STACK->STACKELP->TYPE^=OPERAND &
         STACK->STACKELP->TYPE^=KEYWORD
         THEN DO;
           MSG='INVALID ASSIGNMENT';
           SIGNAL CONDITION(BADEXP);
           END;
       CALL PUT_OPERAND(STACK->STACKELP,OP2,MSG);
       STACKPTR=STACK;
       STACK=STACKNEXT;
       FREE STACKEL;
       RET=OP2; /* PUSH TEMPORARY ONTO STACK */
       END;
     OTHERWISE DO; /* IT IS DYADIC */
       OP1=POP(MSG,STACK,GET_OPERAND); /* IT IS DYADIC */
       IF UNSPEC(OP1)=UNSPEC(MISSING)
         THEN IF ^MISSING_OK(PRMPTR->SUBTYPE)
           THEN RETURN(MISSING);
       IF UNSPEC(OP1)=UNSPEC(MISSING) × UNSPEC(OP2)=UNSPEC(MISSING)
         & RELATIONAL(PRMPTR->SUBTYPE)
         THEN RET=REL_MISS(PRMPTR->SUBTYPE,OP1,OP2);
         ELSE SELECT(PRMPTR->SUBTYPE);
           WHEN(01) DO;
             RET = ABS(OP1) ** OP2;
             IF OP1<0 & MOD(OP2,2)^=0
               THEN RET=-RET;
             END;
           WHEN(02)
             RET = OP1 ^> OP2;
           WHEN(03)
             RET = OP1 >= OP2;
           WHEN(04)
             RET = OP1 ^= OP2;
           WHEN(05)
             RET = OP1 <= OP2;
           WHEN(06)
             RET = OP1 ^< OP2;
           WHEN(07)
             RET = OP1 <  OP2;
           WHEN(08)
             RET = OP1 =  OP2;
           WHEN(09)
             RET = OP1 >  OP2;
           WHEN(10)
             RET = OP1 ×  OP2;
           WHEN(11)
             RET = OP1 &  OP2;
           WHEN(12)
             RET = OP1 *  OP2;
           WHEN(13)
             RET = OP1 /  OP2;
           WHEN(14)
             RET = OP1 +  OP2;
           WHEN(15)
             RET = OP1 -  OP2;
           WHEN(16)
             RET = OP1 ^= OP2;
           OTHERWISE DO;
             MSG='UNRECOGNIZED OPERATOR = '××PRMPTR->TOKSTR××
               ' SUBTYPE='××CALCPRT(PRMPTR->SUBTYPE);
             SIGNAL CONDITION(BADEXP);
             END;
           END; /* SELECT */
       END; /* OTHERWISE */
     END; /* SELECT */
   RETURN(RET);

 DO_LITOP: PROC(OP2,OP1) RETURNS(FLOAT DEC(16));
 /**********************************************************************
 * DO_LITOP IS NESTED WITHIN DO_OPERATOR, AND IS CALLED TO PROCESS A   *
 * COMPARISON OPERATOR INVOLVING QUOTED STRINGS.                       *
 **********************************************************************/
   DCL (OP2,OP1) CHAR(256) VAR;
   DCL RET FLOAT DEC(16);

   SELECT(ABS(PRMPTR->SUBTYPE));
     WHEN(02)
       RET = OP1 ^> OP2;
     WHEN(03)
       RET = OP1 >= OP2;
     WHEN(04)
       RET = OP1 ^= OP2;
     WHEN(05)
       RET = OP1 <= OP2;
     WHEN(06)
       RET = OP1 ^< OP2;
     WHEN(07)
       RET = OP1 <  OP2;
     WHEN(08)
       RET = OP1 =  OP2;
     WHEN(09)
       RET = OP1 >  OP2;
     OTHERWISE DO;
       MSG='UNRECOGNIZED LITERAL OPERATOR = '××PRMPTR->TOKSTR;
       SIGNAL CONDITION(BADEXP);
       END;
     END; /* SELECT */
   RETURN(RET);
   END DO_LITOP;

 MISSING_OK: PROC(PRMTYPE) RETURNS(BIT(1));
 /**********************************************************************
 * CALLED TO DETERMINE WHETHER A MISSING VALUE IS ACCEPTABLE FOR THE   *
 * GIVEN OPERATION.                                                    *
 **********************************************************************/
   DCL PRMTYPE FIXED BIN(15,0);
   SELECT(PRMTYPE);
     WHEN(31, /* PREFIX PLUS */
          32, /* PREFIX MINUS */
          33, /* PREFIX NOT */
          01, /* ** */
              /* RELATIONALS OK */
          10, /* × */
          11, /* & */
          12, /* * */
          13, /* / */
          14, /* + */
          15) /* - */
          RETURN('0'B); /* MISSING NOT OK */
     OTHERWISE RETURN('1'B); /* MISSING OK  */
     END; /* SELECT */
   END MISSING_OK;

 REL_MISS: PROC(PRMTYPE,OP1,OP2) RETURNS(FLOAT DEC(16));
 /**********************************************************************
 * CALLED TO PERFORM A RELATIONAL INVOLVING MISSING VALUES.            *
 **********************************************************************/
   DCL PRMTYPE FIXED BIN(15,0);
   DCL (OP1,OP2,RET) DEC FLOAT(16);
   SELECT;
     WHEN(UNSPEC(OP1)=UNSPEC(MISSING) & UNSPEC(OP2)=UNSPEC(MISSING))
       SELECT(PRMPTR->SUBTYPE);
         WHEN(02)
           RET = OP1 ^> OP2;
         WHEN(03)
           RET = OP1 >= OP2;
         WHEN(04)
           RET = OP1 ^= OP2;
         WHEN(05)
           RET = OP1 <= OP2;
         WHEN(06)
           RET = OP1 ^< OP2;
         WHEN(07)
           RET = OP1 <  OP2;
         WHEN(08)
           RET = OP1 =  OP2;
         WHEN(09)
           RET = OP1 >  OP2;
         WHEN(16)
           RET = OP1 ^= OP2;
         OTHERWISE DO;
           MSG='UNRECOGNIZED RELATIONAL OPERATOR = '××PRMPTR->TOKSTR;
           SIGNAL CONDITION(BADEXP);
           END;
         END; /* SELECT */
     WHEN(UNSPEC(OP1)=UNSPEC(MISSING)) /* OP1 < OP2 */
       SELECT(PRMPTR->SUBTYPE);
         WHEN(02) /* OP1 ^> OP2 */
           RET = 1;
         WHEN(03) /* OP1 >= OP2 */
           RET = 0;
         WHEN(04) /* OP1 ^= OP2 */
           RET = 1;
         WHEN(05) /* OP1 <= OP2 */
           RET = 1;
         WHEN(06) /* OP1 ^< OP2 */
           RET = 0;
         WHEN(07) /* OP1 < OP2 */
           RET = 1;
         WHEN(08) /* OP1 = OP2 */
           RET = 0;
         WHEN(09) /* OP1 > OP2 */
           RET = 0;
         WHEN(16) /* OP1 ^= OP2 */
           RET = 1;
         OTHERWISE DO;
           MSG='UNRECOGNIZED RELATIONAL OPERATOR = '××PRMPTR->TOKSTR;
           SIGNAL CONDITION(BADEXP);
           END;
         END; /* SELECT */
     OTHERWISE /* OP1 > OP2 */
       SELECT(PRMPTR->SUBTYPE);
         WHEN(02) /* OP1 ^> OP2 */
           RET = 0;
         WHEN(03) /* OP1 >= OP2 */
           RET = 1;
         WHEN(04) /* OP1 ^= OP2 */
           RET = 1;
         WHEN(05) /* OP1 <= OP2 */
           RET = 0;
         WHEN(06) /* OP1 ^< OP2 */
           RET = 1;
         WHEN(07) /* OP1 < OP2 */
           RET = 0;
         WHEN(08) /* OP1 = OP2 */
           RET = 0;
         WHEN(09) /* OP1 > OP2 */
           RET = 1;
         WHEN(16) /* OP1 ^= OP2 */
           RET = 1;
         OTHERWISE DO;
           MSG='UNRECOGNIZED RELATIONAL OPERATOR = '××PRMPTR->TOKSTR;
           SIGNAL CONDITION(BADEXP);
           END;
         END; /* SELECT */
     END; /* SELECT */
   RETURN(RET);
   END REL_MISS;

 RELATIONAL: PROC(PRMTYPE) RETURNS(BIT(1));
 /**********************************************************************
 * CALLED TO DETERMINE WHETHER AN OPERATOR IS A RELATIONAL.            *
 **********************************************************************/
   DCL PRMTYPE FIXED BIN(15,0);
   SELECT(PRMTYPE);
     WHEN(2,3,4,5,6,7,8,9,16) RETURN('1'B); /* IS RELATIONAL */
     OTHERWISE RETURN('0'B);
     END; /* SELECT */
   END RELATIONAL;

   END DO_OPERATOR;

 POPCH: PROC(MSG,STACK) RETURNS(CHAR(256) VAR);
 /**********************************************************************
 * POPCH IS USED TO OBTAIN THE                                         *
 * CHARACTER STRING VALUE FOR THE TOP OPERAND ON THE STACK.            *
 **********************************************************************/
   DCL STACK PTR;
   DCL MSG CHAR(80) VAR;
   DCL RET CHAR(256) VAR INIT('');

   IF STACK=NULL
     THEN DO;
       MSG='OPERAND EXPECTED BUT OPERAND STACK EMPTY';
       SIGNAL CONDITION(BADEXP);
       RETURN('');
       END;
   SELECT(STACK->STACKELP->TYPE);
     WHEN(TEMPORARY) DO;
       RET=CALCPRT(STACK->STACKELP->TEMPVALUE);
       FREE STACK->STACKELP->TOKEN;
       END;
     WHEN(NUMERIC_CONSTANT,QUOTED_STRING)
       RET=STACK->STACKELP->TOKSTR;
     WHEN(OPERAND,KEYWORD)
       RET=GET_OPERAND_CHAR(STACK->STACKELP);
     OTHERWISE;
     END;
   STACKPTR=STACK;
   STACK=STACKNEXT;
   FREE STACKEL;
   RETURN(RET);
   END POPCH;

   END CALCEVB;
