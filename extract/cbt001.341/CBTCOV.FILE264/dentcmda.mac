 /* COPYRIGHT 1983 BY THOMAS GLEN SMITH */
 /* DENTCMDA */
 %NOPRINT;
 /* @PARM IS SET TO THE PARAMETERS (AFTER CMDDATA) TO BE ACCEPTED
    BY THIS PROCEDURE AND PASSED TO THE FETCHED MODULE (AFTER CMDINDX
    AND PARY. */
         % DCL @PARM CHAR;
         % @PARM = '';
 /* @PARMDCL IS SET TO THE DECLARATIONS FOR ALL OF THE PARAMETERS IN
    @PARM */
         % DCL @PARMDCL CHAR;
         % @PARMDCL = '';
 /* @PROCNAME IS SET TO THE NAME TO BE ASSIGNED TO THE GENERATED
    PROCEDURE. */
         % DCL @PROCNAME CHAR;
         % @PROCNAME = 'SUBCALL';
 /* @DEBUG WILL BE SET BY THE USER TO 'Y' IF HE WANTS TO HANDLE
    ERROR CONDITIONS ON HIS OWN. */
         % DCL @DEBUG CHAR;
         % @DEBUG = 'N';
 /* @SNMCNT WILL CONTAIN THE TOTAL NUMBER OF SUBCOMMMAND NAMES
    ENCOUNTERED IN ALL @SUBCMD MACROS. */
         % DCL @SNMCNT FIXED;
         % @SNMCNT = 0;
 /* @SUBCNT WILL CONTAIN A COUNT OF @SUBCMD MACROS ENCOUNTERED. */
         % DCL @SUBCNT FIXED;
         % @SUBCNT = 0;
 /* @NAMSTR WILL CONTAIN INITIALIZATION VALUES FOR ARRAY CMDTAB. */
         % DCL @NAMSTR CHAR;
         % @NAMSTR = '';
         % DCL @NAMCOMMA CHAR;
         % @NAMCOMMA = '';
 /* @NUMSTR WILL CONTAIN INITIALIZATION VALUES FOR ARRAY NUMCKA */
         % DCL @NUMSTR CHAR;
         % @NUMSTR = '';
         % DCL @NUMCOMMA CHAR;
         % @NUMCOMMA = '';
 /* @RNGESTR WILL CONTAIN INITIALIZATION VALUES FOR RNGEARY */
         % DCL @RNGESTR CHAR;
         % @RNGESTR = '';
         % DCL @RNGECOMMA CHAR;
         % @RNGECOMMA = '';
 /* @ENTDCL WILL CONTAIN ALL FETCH AND DCL STMTS FOR ENTRY POINTS */
         % DCL @ENTDCL CHAR;
         % @ENTDCL = '';
 /* @CALCOD WILL CONTAIN THE GENERATED CALL STATEMENTS */
         % DCL @CALCOD CHAR;
         % @CALCOD = '';
         % DCL DENTCMD ENTRY;
 /* @NOPSTR WILL CONTAIN NAMES OF ALL SUBCOMMANDS THAT DO THEIR OWN
    PARSING. */
         % DCL @NOPSTR CHAR;
         % @NOPSTR = '';
         % DCL @NOPCOMMA CHAR;
         % @NOPCOMMA = '';
 /* @NOPCNT WILL CONTAIN TOTAL NUMBER OF SUBCOMMAND NAMES THAT DO
    THEIR OWN PARSING. */
         % DCL @NOPCNT FIXED;
         % @NOPCNT = 0;
 % DENTCMD:  PROC(P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11,P12,P13,P14,P15,
           P16,P17,P18,P19,P20,P21,P22,P23,P24,P25)
           STATEMENT RETURNS(CHAR);
 /*
0*$.HE GENERALIZED SUBROUTINES - DENTCMD
0*$.HE PLI PREPROCESSOR TEXT
0*$.PL 55
0*$.PN 0
0*$.PA
0*$.SS
0*$.NF
0*$02/05/78
0*$AUTHOR:  T. SMITH
0*$SOURCE MODULE NAME:  DENTCMDA, DENTCMDB
0*$DOCUMENTATION ID:  0*$
0*$.FI L
0*$.SP 5
0*$THIS PL/I PREPROCESSOR PROCEDURE CAN BE USED TO PROVIDE AN INTERFACE
0*$BETWEEN A MAINLINE COMMAND PROCESSOR AND A SERIES OF SUBCOMMANDS.
0*$FORMAT FOR THE DENTCMD MACRO IS AS AS FOLLOWS:
0*$.SP 1
0*$.IN 5
0*$.NF
0*$DENTCMD(SUBNAME1,SUBNAME2,...SUBNAMEN,
0*$        EDITMASK,NOFETCH,NOPARSE);
0*$.FI L
0*$.SP 1
0*$'SUBNAME1' IS THE PRIMARY SUBCOMMAND NAME, AND IF THE SUBCOMMAND
0*$IS LINKEDITED OUT AS A SEPARATE MODULE TO BE FETCHED IN AT
0*$EXECUTION TIME (SEE THE NOFETCH OPERAND), THE MODULE NAME MUST BE
0*$EQUAL TO 'SUBNAME1'.  'SUBNAME2' THRU 'SUBNAMEN' ARE ALL ALIASES
0*$OF THE SAME SUBCOMMAND.
0*$.SP 1
0*$'EDITMASK' IS AN OPTIONAL OPERAND.  IF SPECIFIED, IT MUST BE A
0*$STRING OF '0'S AND '1'S, AND INDICATES WHICH OPERANDS MUST BE
0*$NUMERIC DATA.  DENTCMD(XYZ,0101), FOR EXAMPLE, SPECIFIES THAT
0*$OPERANDS TWO AND FOUR FOR SUBCOMMAND XYZ MUST BE NUMERIC.  IF AT
0*$EXECUTION TIME, THESE OPERANDS FAIL THE NUMERIC TEST, THE SUBCOMMAND
0*$WILL NOT BE GIVEN CONTROL.
0*$.SP 1
0*$'NOFETCH' IS ALSO AN OPTIONAL OPERAND.  IT IS A KEYWORD OPERAND,
0*$AND IF SPECIFIED, INDICATES THAT THE SUBCOMMAND IS AN EXTERNAL
0*$PL/I PROCEDURE WHICH WILL BE LINKEDITED INTO THE MODULE CONTAINING
0*$THE COMMAND PROCESSOR MAINLINE PROCEDURE.  IF 'NOFETCH' IS NOT
0*$SPECIFIED, THE SUBCOMMAND IS CONSIDERED TO BE A MODULE LINKEDITED
0*$SEPARATELY FROM THE MAINLINE, AND A FETCH STATEMENT WILL BE ISSUED
0*$FOR THE SUBCOMMAND.
0*$'NOPARSE' IS ALSO OPTIONAL, AND SHOULD BE SPECIFIED IF THE
0*$SUBCOMMAND DOES ITS OWN PARSING.
0*$.PA
0*$.IN 0
0*$TO GIVE YOU A BETTER IDEA OF HOW DENTCMD IS USED, FOLLOWING IS THE
0*$SOURCE FOR A SAMPLE SUBCOMMAND INTERFACE:
0*$.SP 1
0*$.IN 5
0*$.NF
0*$% INCLUDE @SUBCMDA            0010
0*$DENTCMD(PLOT001,HIST,H,11);   0020
0*$DENTCMD(PLOT002,RANGE);       0030
0*$DENTCMD(PLOT003,MENU);        0040
0*$% @PROCNAME = 'PLOTB';        0050
0*$% @PARM = 'DISPLAY,SUBENT';   0060
0*$% @PARMDCL = 'DCL DISPLAY(25) 0070
0*$  CHAR(79),SUBENT(*) ENTRY';  0080
0*$% INCLUDE DENTCMDB;           0090
0*$.FI L
0*$.SP 1
0*$IN THE ABOVE SOURCE, STATEMENT 10 INCLUDES THE PREPROCESSOR CODE
0*$NECESSARY TO PROCESS THE SUBSEQUENT DENTCMD STATEMENTS.  THE
0*$DENTCMD MACRO IN STATEMENT 20 DEFINES A SUBCOMMAND CALLED PLOT001
0*$WHICH WILL BE DYNAMICALLY FETCHED AT EXECUTION TIME, AND WILL BE
0*$GIVEN CONTROL FOR ANY OF THE SUBCOMMANDS 'PLOT001', 'HIST', OR 'H',
0*$PROVIDED THE FIRST TWO OPERANDS ARE NUMERIC DATA.
0*$.SP 1
0*$BECAUSE OF STATEMENTS 50 THRU 80, THE GENERATED PROCEDURE
0*$CONTAINING THE SUBCOMMAND INTERFACE WILL HAVE THE FOLLOWING
0*$PROCEDURE STATEMENT AT THE BEGINNING:
0*$.SP 1
0*$.IN 10
0*$PLOTB: PROC(CMDDATA,DISPLAY,SUBENT);
0*$.IN 5
0*$.SP 1
0*$AND THE GENERATED CALL STATEMENT FOR EACH DEFINED SUBCOMMAND IN
0*$PLOTB WILL HAVE THE FOLLOWING FORMAT IF THE KEYWORD 'NOPARSE' WAS
0*$NOT SPECIFIED:
0*$.SP 1
0*$.IN 10
0*$CALL PLOT001(CMDINDX,PARPTR,DISPLAY,SUBENT);
0*$.IN 5
0*$.SP 1
0*$IF THE KEYWORD 'NOPARSE' WAS SPECIFIED, THE GENERATED CALL
0*$STATEMENT IS:
0*$.SP 1
0*$.IN 10
0*$CALL PLOT001(CMDINDX,CMDDATA,DISPLAY,SUBENT);
0*$.IN 5
0*$.SP 1
0*$CMDDATA IS DECLARED CHAR(*) VARYING, AND IS THE COMMAND BUFFER
0*$CONTAINING THE SUBCOMMAND WITH ITS OPERANDS, AND MUST BE FILLED IN BY
0*$THE MAINLINE PROCEDURE BEFORE CALLING PLOTB.
0*$.SP 1
0*$CMDINDX IS DECLARED FIXED BIN(15,0), AND IS SET BY PLOTB TO
0*$A NUMBER CORRESPONDING TO THE PARTICULAR NAME BY WHICH THE
0*$SUBCOMMAND IS BEING INVOKED.  IN THIS CASE, IF THE SUBCOMMAND
0*$WERE 'HIST', CMDINDX WOULD BE SET TO 2.
0*$.SP 1
0*$PARPTR IS A POINTER VARIABLE, AND WILL BE SET TO THE ADDRESS
0*$OF THE STRUCTURE PASSED TO SUBROUTINE DENTPRS, AND WHICH CONTAINS
0*$PARSING INFORMATION.  SEE THE DOCUMENTATION FOR THE DENTPRS
0*$SUBROUTINE FOR DETAILS ON THIS STRUCTURE.
0*$.SP 1
0*$THE CALL STATEMENT TO INVOKE PLOTB FROM THE MAINLINE PROCEDURE
0*$WOULD BE AS FOLLOWS:
0*$.SP 1
0*$.IN 10
0*$CALL PLOTB(CMDDATA,DISPLAY,SUBENT);
0*$.IN 5
0*$.SP 1
0*$ASSUMING THE SOURCE FOR THE MAINLINE PROCEDURE WAS IN DATA SET
0*$'USERID.MAINLINE.PLI', AND THE ABOVE SAMPLE SOURCE WERE IN DATA
0*$SET 'USERID.PLOTB.PLI', THE THE FOLLOWING SEQUENCE OF TSO
0*$COMMANDS MIGHT BE USED TO CREATE THE MAINLINE COMMAND PROCESSOR
0*$MODULE:
0*$.SP 1
0*$.IN 10
0*$.NF
0*$PLI MAINLINE OBJ
0*$PLI PLOTB M LIB('SYS2.MACLIB') OBJ
0*$LINK (MAINLINE PLOTB) LOAD(TEST(MAINLINE))-
0*$  LIB('SYS2.PLIBASE') PLIBASE PRINT(*)
0*$.FI L
0*$.IN 5
0*$ASSUMING THE NAME OF THE DATA SET CONTAINING THE SOURCE FOR
0*$SUBCOMMAND PLOT001 WAS 'USERID.PLOT001.PLI', AND IF THE NAME
0*$ON THE PROCEDURE STATEMENT IN THAT SOURCE WERE PLOT001, THE
0*$FOLLOWING TSO COMMANDS MIGHT BE USED TO CREATE AN EXECUTABLE
0*$SUBCOMMAND:
0*$.SP 1
0*$.IN 10
0*$.NF
0*$PLI PLOT001 OBJ
0*$LINK (PLOT001 *) LOAD(TEST(PLOT001))-
0*$  PLIBASE PRINT(*)
0*$ - ENTER LINKEDIT CONTROL STATEMENTS -
0*$ ENTRY PLOT001
0*$ (NULL LINE)
0*$.IN 0
0*$.FI L
0*$.SP 1
0*$NOTE THAT YOU CAN INDICATE THAT YOU DO NOT WANT AN "ON ERROR"
0*$BLOCK TO BE GENERATED IN THE INTERFACE BY ADDING THE STATEMENT
0*$"% @DEBUG=Y;" AFTER THE INCLUDE OF @SUBCMDA.
 */
         DCL (P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11,P12,P13,P14,P15,P16,
           P17,P18,P19,P20,P21,P22,P23,P24,P25) CHAR;
         DCL (I,J) FIXED;
         DCL (LAST,FETCH,CURRENT,PARSE,PARCODE) CHAR;
         FETCH = 'YES';
         PARSE = 'YES';
         @SUBCNT = @SUBCNT + 1;
         IF P25 ^= '' THEN DO; I = 25; LAST = P25; END;
    ELSE IF P24 ^= '' THEN DO; I = 24; LAST = P24; END;
    ELSE IF P23 ^= '' THEN DO; I = 23; LAST = P23; END;
    ELSE IF P22 ^= '' THEN DO; I = 22; LAST = P22; END;
    ELSE IF P21 ^= '' THEN DO; I = 21; LAST = P21; END;
    ELSE IF P20 ^= '' THEN DO; I = 20; LAST = P20; END;
    ELSE IF P19 ^= '' THEN DO; I = 19; LAST = P19; END;
    ELSE IF P18 ^= '' THEN DO; I = 18; LAST = P18; END;
    ELSE IF P17 ^= '' THEN DO; I = 17; LAST = P17; END;
    ELSE IF P16 ^= '' THEN DO; I = 16; LAST = P16; END;
    ELSE IF P15 ^= '' THEN DO; I = 15; LAST = P15; END;
    ELSE IF P14 ^= '' THEN DO; I = 14; LAST = P14; END;
    ELSE IF P13 ^= '' THEN DO; I = 13; LAST = P13; END;
    ELSE IF P12 ^= '' THEN DO; I = 12; LAST = P12; END;
    ELSE IF P11 ^= '' THEN DO; I = 11; LAST = P11; END;
    ELSE IF P10 ^= '' THEN DO; I = 10; LAST = P10; END;
    ELSE IF P9 ^= '' THEN DO; I = 9; LAST = P9; END;
    ELSE IF P8 ^= '' THEN DO; I = 8; LAST = P8; END;
    ELSE IF P7 ^= '' THEN DO; I = 7; LAST = P7; END;
    ELSE IF P6 ^= '' THEN DO; I = 6; LAST = P6; END;
    ELSE IF P5 ^= '' THEN DO; I = 5; LAST = P5; END;
    ELSE IF P4 ^= '' THEN DO; I = 4; LAST = P4; END;
    ELSE IF P3 ^= '' THEN DO; I = 3; LAST = P3; END;
    ELSE IF P2 ^= '' THEN DO; I = 2; LAST = P2; END;
    ELSE                  DO; I = 1; LAST = P1; END;
         IF LAST = 'NOF' × LAST = 'NOFETCH'
              THEN DO;
                   FETCH = 'NO';
                   I = I - 1;
                   IF I = 25 THEN LAST = P25;
              ELSE IF I = 24 THEN LAST = P24;
              ELSE IF I = 23 THEN LAST = P23;
              ELSE IF I = 22 THEN LAST = P22;
              ELSE IF I = 21 THEN LAST = P21;
              ELSE IF I = 20 THEN LAST = P20;
              ELSE IF I = 19 THEN LAST = P19;
              ELSE IF I = 18 THEN LAST = P18;
              ELSE IF I = 17 THEN LAST = P17;
              ELSE IF I = 16 THEN LAST = P16;
              ELSE IF I = 15 THEN LAST = P15;
              ELSE IF I = 14 THEN LAST = P14;
              ELSE IF I = 13 THEN LAST = P13;
              ELSE IF I = 12 THEN LAST = P12;
              ELSE IF I = 11 THEN LAST = P11;
              ELSE IF I = 10 THEN LAST = P10;
              ELSE IF I = 9 THEN LAST = P9;
              ELSE IF I = 8 THEN LAST = P8;
              ELSE IF I = 7 THEN LAST = P7;
              ELSE IF I = 6 THEN LAST = P6;
              ELSE IF I = 5 THEN LAST = P5;
              ELSE IF I = 4 THEN LAST = P4;
              ELSE IF I = 3 THEN LAST = P3;
              ELSE IF I = 2 THEN LAST = P2;
              ELSE               LAST = P1;
                   END;
         IF LAST = 'NOP' × LAST = 'NOPARSE'
              THEN DO;
                   PARSE = 'NO';
                   I = I - 1;
                   IF I = 25 THEN LAST = P25;
              ELSE IF I = 24 THEN LAST = P24;
              ELSE IF I = 23 THEN LAST = P23;
              ELSE IF I = 22 THEN LAST = P22;
              ELSE IF I = 21 THEN LAST = P21;
              ELSE IF I = 20 THEN LAST = P20;
              ELSE IF I = 19 THEN LAST = P19;
              ELSE IF I = 18 THEN LAST = P18;
              ELSE IF I = 17 THEN LAST = P17;
              ELSE IF I = 16 THEN LAST = P16;
              ELSE IF I = 15 THEN LAST = P15;
              ELSE IF I = 14 THEN LAST = P14;
              ELSE IF I = 13 THEN LAST = P13;
              ELSE IF I = 12 THEN LAST = P12;
              ELSE IF I = 11 THEN LAST = P11;
              ELSE IF I = 10 THEN LAST = P10;
              ELSE IF I = 9 THEN LAST = P9;
              ELSE IF I = 8 THEN LAST = P8;
              ELSE IF I = 7 THEN LAST = P7;
              ELSE IF I = 6 THEN LAST = P6;
              ELSE IF I = 5 THEN LAST = P5;
              ELSE IF I = 4 THEN LAST = P4;
              ELSE IF I = 3 THEN LAST = P3;
              ELSE IF I = 2 THEN LAST = P2;
              ELSE               LAST = P1;
                   END;
         IF SUBSTR(LAST,1,1) ^= '0' & SUBSTR(LAST,1,1) ^= '1'
              THEN DO;
                   LAST = '0'; /* SET DEFAULT EDIT MASK */
                   I = I + 1;
                   END;
         I = I - 1;
         J = @SNMCNT + 1;
         @RNGESTR = @RNGESTR××@RNGECOMMA××J;
         @RNGECOMMA = ',';
         @SNMCNT = @SNMCNT + I;
         IF PARSE='NO'
              THEN @NOPCNT=@NOPCNT+I;
         DO J = 1 TO I;
              IF J = 1 THEN CURRENT = P1;
         ELSE IF J = 2 THEN CURRENT = P2;
         ELSE IF J = 3 THEN CURRENT = P3;
         ELSE IF J = 4 THEN CURRENT = P4;
         ELSE IF J = 5 THEN CURRENT = P5;
         ELSE IF J = 6 THEN CURRENT = P6;
         ELSE IF J = 7 THEN CURRENT = P7;
         ELSE IF J = 8 THEN CURRENT = P8;
         ELSE IF J = 9 THEN CURRENT = P9;
         ELSE IF J = 10 THEN CURRENT = P10;
         ELSE IF J = 11 THEN CURRENT = P11;
         ELSE IF J = 12 THEN CURRENT = P12;
         ELSE IF J = 13 THEN CURRENT = P13;
         ELSE IF J = 14 THEN CURRENT = P14;
         ELSE IF J = 15 THEN CURRENT = P15;
         ELSE IF J = 16 THEN CURRENT = P16;
         ELSE IF J = 17 THEN CURRENT = P17;
         ELSE IF J = 18 THEN CURRENT = P18;
         ELSE IF J = 19 THEN CURRENT = P19;
         ELSE IF J = 20 THEN CURRENT = P20;
         ELSE IF J = 21 THEN CURRENT = P21;
         ELSE IF J = 22 THEN CURRENT = P22;
         ELSE IF J = 23 THEN CURRENT = P23;
         ELSE IF J = 24 THEN CURRENT = P24;
         ELSE IF J = 25 THEN CURRENT = P25;
              @NAMSTR=@NAMSTR××@NAMCOMMA××''''××CURRENT××'''';
              @NAMCOMMA = ',';
              IF PARSE='NO'
                THEN DO;
                  @NOPSTR=@NOPSTR××@NOPCOMMA××''''××CURRENT××'''';
                  @NOPCOMMA=',';
                  END;
              @NUMSTR=@NUMSTR××@NUMCOMMA××'''0'××LAST××'''B';
              @NUMCOMMA = ',';
              END;
         IF PARSE='YES'
           THEN PARCODE='(IX,PARPTR @PARM);';
           ELSE PARCODE='(IX,CMDDATA @PARM);';
         @ENTDCL=@ENTDCL××' DCL '××P1××' ENTRY;';
         @CALCOD=@CALCOD××'CASE('××@SUBCNT××'): CALL '××P1××PARCODE;
         IF FETCH = 'YES'
              THEN DO;
                   @ENTDCL=@ENTDCL××'FETCH '××P1××';';
                   @CALCOD=@CALCOD××' IF @RELEASE THEN RELEASE '××P1××
                     ';';
         @CALCOD=@CALCOD××'GO TO ENDCASE;';
         RETURN('');
         % END DENTCMD;
 %PRINT;
