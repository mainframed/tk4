 /* COPYRIGHT 1983 BY THOMAS GLEN SMITH */
 DENTCIN:  PROC(PREC,PDATA,RHPTR,SUBENT,RHHDRPT) OPTIONS(REENTRANT);
 /* THIS SUBROUTINE IS CALLED BY DENTC TO PROCESS A LINE OF DATA
    ENTERED ON THE DISPLAY. */
   % DCL @PROCNAME CHAR;
   % @PROCNAME='';
   % INCLUDE DENTSUB;
   DCL (PREC,PDATA) CHAR(*) VAR;
   DCL 1 SKEL BASED(SKELPTR),
     2 SKNXT PTR,
     2 STC FIXED BIN(15,0),
     2 ENC FIXED BIN(15,0);
   IF HEXMODE
     THEN LM=LENGTH(PDATA);
     ELSE LM=SCANLEN;
   /* LM = MAXIMUM LENGTH OF DATA ACCEPTED FROM DISPLAY */
   PDATA=SUBSTR(PDATA,1,MIN(LENGTH(PDATA),LM));
   OD=1; /* NEXT AVAILABLE BYTE OF DISPLAY DATA */
   LO=LENGTH(PREC); /* SAVE ORIGINAL LENGTH OF DATA RECORD */
   LD=LENGTH(PDATA); /* GET LENGTH OF DISPLAY DATA */
   IF RHPSKHD=NULL
     THEN CALL NSEG(COLUMN,TRUNCATE);
     ELSE DO SKELPTR=RHPSKHD REPEAT SKNXT WHILE(SKELPTR^=NULL);
       CALL NSEG(STC,ENC);
       END;
 NSEG:  PROC(ST,EN) OPTIONS(REENTRANT);
   DCL (ST,EN) FIXED BIN(15,0);
 /**********************************************************************
 * NSEG IS CALLED TO PROCESS A SEGMENT OF INPUT DATA.  ST AND EN
 * INDICATE THE COLUMNS IN THE DATA RECORD (PREC) WHERE THE DATA
 * FROM THE DISPLAY (PDATA) IS TO BE STORED.  LO INDICATES THE
 * COLUMN POSITION IN THE DISPLAY DATA (PDATA) WHERE THE NEXT BYTE
 * IS TO BE EXTRACTED.
 **********************************************************************/
   DCL (I,J,K,LS,LA) FIXED BIN(15,0);
   DCL DATA CHAR(4000) VAR;
   IF OD > LD
     THEN RETURN; /* NO MORE DATA FROM DISPLAY TO PROCESS */
   LS=EN-ST+1; /* LS=LENGTH OF THIS RECORD SEGMENT */
   IF LS+OD-1 > LM
     THEN LS=LM-OD+1; /* DON'T TRUNCATE AT RIGHT EDGE OF DISPLAY */
   LA=LD-OD+1; /* LA=LENGTH OF DATA AVAILABLE FROM DISPLAY */
   IF LA<LS
     THEN DATA=SUBSTR(PDATA,OD,LA)××REPEAT(' ',LS-LA-1);
     ELSE DATA=SUBSTR(PDATA,OD,LS);
   /* DATA = DATA FROM DISPLAY, PADDED WITH BLANKS TO LENGTH(SEG) */
   IF ST+LS-1 > LO /* IS NEW SEGMENT AT THE END OF THE RECORD */
     THEN DO;
       IF LO<ST-1 /* NEW SEG IS BEYOND CURRENT END OF RECORD */
         THEN PREC=SUBSTR(PREC,1,LO)××REPEAT(' ',ST-LO-2)××DATA;
         ELSE PREC=SUBSTR(PREC,1,ST-1)××DATA;
       LO=LENGTH(PREC); /* UPDATE LENGTH(DATA RECORD) */
       END;
     ELSE SUBSTR(PREC,ST,LS)=DATA; /* NOT AT END OF RECORD */
   OD=OD+LS;
   END NSEG;
   END DENTCIN;
