 /* @CMD */
 %NOPRINT;
         % @CMDI = 'Y';
         % DCL @CMD ENTRY;
 % @CMD:  PROC(PARM1,PARM2,PARM3,PARM4,PARM5)
           STATEMENT RETURNS(CHAR);
 /*
0*$.HE GENERALIZED SUBROUTINES - @CMD
0*$.HE PLI PREPROCESSOR TEXT
0*$.HE INVOKE TSO COMMAND PROCESSORS.
0*$.PL 55
0*$.PN 0
0*$.PA
0*$.SS
0*$.NF
0*$09/12/76
0*$AUTHOR:  T. SMITH
0*$SOURCE MODULE NAME:  @CMD
0*$DOCUMENTATION ID:  0*$
0*$.FI L
0*$.SP 5
0*$THIS PLI PREPROCESSOR PROCEDURE CAN BE INVOKED TO GENERATE THE
0*$NECESSARY PLI STATEMENTS TO INVOKE OTHER TSO COMMAND PROCESSORS.
0*$FORMAT IS AS FOLLOWS -
0*$.SP 1
0*$.IN 5
0*$@CMD('ALLOC FI(SYSIN) DA(IN.DATA)',,,HELP);
0*$.IN 0
0*$.SP 1
0*$THE HELP KEYWORD PARAMETER IS OPTIONAL.  YOU SHOULD USE THIS
0*$KEYWORD IF A HELP COMMAND IS BEING ISSUED FOR A SUBCOMMAND.
0*$.SP 1
0*$A SECOND FORMAT IS -
0*$.SP 1
0*$.IN 5
0*$@CMD(ALLC,'ALLOC FI(SYSIN) DA(IN.DATA)',MF=L);
0*$.IN 0
0*$.SP 1
0*$THIS WILL GENERATE THE COMMAND BUFFER WITH THE NAME ALLC, BUT
0*$WILL NOT GENERATE ANY CALL STATEMENTS.  THE COMMAND CAN
0*$SUBSEQUENTLY BE ISSUED AS FOLLOWS -
0*$.SP 1
0*$.IN 5
0*$@CMD(ALLC);
0*$.IN 0
0*$.SP 1
0*$NOTE THAT THE COMMAND TEXT IS SUBJECT TO SYMBOLIC REPLACEMENT.
0*$THIS IS A FACILITY WHEREBY SYMBOLS IDENTIFIED BY AN AMPERSAND
0*$AS THEIR FIRST CHARACTER CAN BE INCLUDED IN THE COMMAND TEXT.
0*$A CALL IS GENERATED BY @CMD SO THAT AT EXECUTION TIME, THE VALUE
0*$WHICH EACH SYMBOLIC LABEL REPRESENTS REPLACES IT IN THE
0*$COMMAND TEXT.  SEE DOCUMENTATION FOR @SETL AND @SETG TO FIND
0*$OUT HOW TO ASSIGN A REPLACEMENT VALUE TO A SYMBOLIC LABEL.
0*$.SP 1
0*$GENERAL RULES FOR THE SYMBOLIC LABELS ARE THAT THEY MUST BY 8
0*$CHARACTERS OR LESS IN LENGTH, INCLUDING THE AMPERSAND IN POSITION 1
0*$AND, EXCEPT FOR THE AMPERSAND, THEY MAY CONTAIN ONLY ALPHANUMERIC
0*$CHARACTERS.
0*$.SP 1
0*$NOTE THAT BY SETTING PREPROCESSOR VARIABLE
0*$@LISTSW = 'Y', YOU CAN CAUSE ALL SUBSEQUENT
0*$ENCOUNTERS OF @CMD TO WRITE A COPY OF THE COMMAND AT
0*$THE TERMINAL.
0*$.SP 1
0*$A THIRD FORMAT IS -
0*$.SP 1
0*$.IN 5
0*$@CMD('WHATEVER',,,HELP);
0*$.IN 0
0*$.SP 1
0*$THIS INDICATES THAT THE COMMAND NAME IS NOT TO BE CHANGED IN THE
0*$ECT.  THIS IS USED PRINCIPALLY WHEN INVOKING HELP FOR SUBCOMMANDS.
0*$THE HELP COMMAND DETERMINES WHETHER IT SHOULD PUT OUT HELP DATA
0*$FOR MAJOR COMMANDS OR FOR SUBCOMMANDS BY LOOKING AT THE COMMAND
0*$NAME IN THE ECT.
0*$.SP 1
0*$A FOURTH FORMAT (WHICH ISN'T WORKING TOO WELL YET) IS AS FOLLOWS -
0*$.SP 1
0*$.IN 5
0*$@CMD('XXX',,,START,ASYNCHPTR);
0*$.IN 10
0*$AND
0*$.IN 5
0*$@CMD(,,,,STOP,ASYNCHPTR);
0*$.IN 0
0*$.SP 1
0*$WHERE ASYNCHPTR IS A POINTER VARIABLE CONTAINING THE ADDRESS
0*$OF A STRUCTURE SUCH AS THE FOLLOWING:
0*$.NF
0*$.IN 5
0*$.SP 1
0*$DCL 1 REC BASED(ASYNCHPTR),
0*$     2 CMDNAME CHAR(8),
0*$         ** NAME OF COMMAND **
0*$     2 SUBTCBP PTR,
0*$         ** ADDR OF ASYNCH CMD SUBTASK TCB **
0*$     2 SUBECB FIXED BIN(31,0),
0*$         ** SUBTASK ECB - POSTED ON COMPLETION OF SUBTASK **
0*$     2 STAIECB FIXED BIN(31,0),
0*$         ** POSTED ON STAI EXIT FROM SUBTASK.  NOTE THAT
0*$            THE POSTING OF EITHER SUBECB OR STAIECB
0*$            SHOULD BE TAKEN TO MEAN THAT THE SUBTASK
0*$            IS FINISHED. **
0*$     2 STAIECB2 FIXED BIN(31,0),
0*$         ** ECB USED IN STAI EXIT **
0*$     2 STAICMPL FIXED BIN(31,0),
0*$         ** COMPLETION CODE FIELD SET BY STAI EXIT **
0*$     2 STAIPGM CHAR(8);
0*$         ** PGM NAME SET BY STAI EXIT **
0*$.IN 0
0*$.FI L
0*$.SP 1
0*$YOUR WOULD ISSUE THE @CMD WITH 'START' INDICATED TO START UP
0*$A TSO COMMAND WITHOUT WAITING FOR IT TO COMPLETE.  YOUR MUST
0*$CHECK FOR THE COMPLETION OF EITHER OF THE EVENTS SUBECB OR
0*$STAIECB, AND THEN YOU MUST ISSUE @CMD AGAIN WITH 'STOP'
0*$INDICATED.
0*$.SP 1
0*$A FIFTH FORMAT IS -
0*$.SP 1
0*$@CMD(CMD,MF=S,,HELP)
0*$.IN 0
0*$OR
0*$.IN 0
0*$@CMD(CMD,MF=S);
0*$.SP 1
0*$THE FORMAT ABOVE WHICH INCLUDES ',,HELP' IS USED ONLY WHEN INVOKING
0*$THE HELP TSO COMMAND.  WHEN 'MF=S' IS USED, CMD MUST BE CHAR(*)
0*$VARYING, CONTAINING THE COMMAND STRING TO BE EXECUTED.
 */
         DCL (PARM1,PARM2,PARM3,PARM4,PARM5,NAME,MF,RETSTR) CHAR;
         DCL (I,J) FIXED;
         RETSTR = 'DO;';
         RETSTR = RETSTR ×× @SETBUF(PARM1,PARM2,PARM3,NAME,MF);
         IF MF ^= 'MF=L'
              THEN DO;
                   RETSTR=RETSTR××' BUFFER@='××NAME××
                     '; CALL REP@(BUFFER@);';
                   IF @LISTSW = 'Y'
                        THEN RETSTR=RETSTR××' @WRITE(BUFFER@);';
                   RETSTR=RETSTR××' CPPLCBUF=ADDR(BUFFER@); '××
                     'BUFOFF@=0; CALL SYSCMD(CPPL,IKJRET';
                   IF PARM4 = 'HELP'
                     THEN RETSTR=RETSTR××',''HELP'');';
                     ELSE IF PARM4 = 'START'
                       THEN RETSTR=RETSTR××',''START'','××PARM5××');';
                       ELSE IF PARM4 = 'STOP'
                         THEN RETSTR=RETSTR××',''STOP'','××PARM5××');';
                         ELSE RETSTR=RETSTR××');';
                   END;
         RETSTR=RETSTR××' END;';
         RETURN(RETSTR);
         % END @CMD;
 %PRINT;
