   /* COPYRIGHT 1987 BY THOMAS GLEN SMITH */
   /* ABE056 - RANDOM,WATDATE,LISTRF,VOLSER */
   %INCLUDE ABESUB;
 ABESUB(ABE056) PARS(0000000000000000) CHECK(YES);
   %INCLUDE ABESUBA;
   DCL 1 LRN_STRUCTURE BASED(LRNPTR),
   %INCLUDE ABELRN;
   %INCLUDE ABELRNA;

   DCL SETCAPS ENTRY;
   DCL PTRIN ENTRY(PTR)
     RETURNS(FIXED BIN(31,0));
   DCL PTROUT ENTRY(FIXED BIN(31,0))
     RETURNS(PTR);
   DCL (SYSCTLG,SYSVTOC) ENTRY;
   DCL JULGREG ENTRY(CHAR(6),FIXED DEC(5,0));

   %INCLUDE CTLGDEF;
   %INCLUDE DSCB1;
   DCL RET BIT(32);
   DCL CVOL CHAR(6) STATIC INIT('SYSRES');
   DCL AREA CHAR(265);
   DCL WKAREA CHAR(148);
   DCL 1 WKAREA2 BASED(ADDR(WKAREA)),
        2 PAD1 CHAR(9),
        2 CREDT CHAR(3),
        2 PAD2 CHAR(19),
        2 REFDT CHAR(3);
   DCL 1 WKAREA3 BASED(ADDR(WKAREA)),
        2 PAD CHAR(31),
        2 YYREF BIT(8),
        2 DDDREF BIT(16);

   SELECT(CMDINDX);
     WHEN(1,2) CALL RANDOM;
     WHEN(3)   CALL WATDATE;
     WHEN(4)   CALL LISTRF;
     OTHERWISE CALL VOLSER_PROC;
     END; /* SELECT */

 LISTRF: PROC;
   DCL VOLSW CHAR(1);

   CALL SETCAPS(PARY(1));
   IF PARY(1)=''
     THEN VOLSW='N';
     ELSE IF PARY(1)=SUBSTR('VOLSER',1,MIN(6,LENGTH(PARY(1))))
       THEN VOLSW='Y';
       ELSE VOLSW='N';
   DO FOREVER=1 REPEAT FOREVER;
     CALL #ABELSP(RHHDRPT,LRNPTR); /* GET NEXT FROM-SEGMENT */
     IF LRN_STRUCTURE.LRN_BUFP=NULL
       THEN LEAVE; /* ALL DONE */
     LSPBUF=LISTRF_SUB(LSPBUF,VOLSW);
     END;
   END LISTRF;

 LISTRF_SUB: PROC(PRM,VOLSW) RETURNS(CHAR(256) VAR);
   DCL PRM CHAR(*) VAR;
   DCL VOLSW CHAR(1);
   DCL GREGORIAN CHAR(6);
   DCL JULIAN FIXED DEC(5,0);
   DCL VOLSTR CHAR(6);
   DCL HDR CHAR(14) VAR;

   VOLSTR=VOLSER_SUB(PRM);
   IF VOLSTR=''
     THEN RETURN('.      '××PRM); /* MISSING VALUE */
   IF VOLSW='Y'
     THEN HDR=VOLSTR××' ';
     ELSE HDR='';
   CALL SYSVTOC('SEARCH',RET,PRM,VOLSTR,WKAREA);
   DSCB1PTR=PTROUT(PTRIN(ADDR(WKAREA))-44);
   IF REFDT = LOW(3)
     THEN REFDT = CREDT;
   I = YYREF;
   J = DDDREF;
   JULIAN=I*1000+J;
   GREGORIAN='';
   CALL JULGREG(GREGORIAN,JULIAN);
   IF VERIFY(GREGORIAN,'0123456789')^=0
     THEN GREGORIAN='.';
   HDR=HDR××SUBSTR(GREGORIAN,5,2)××SUBSTR(GREGORIAN,1,4)××' ';
   RETURN(HDR××PRM);
   END LISTRF_SUB;

 WATDATE: PROC;

   IF PARQCK(1) × (VERIFY(PARY(1),'0123456789')^=0)
     THEN CALL WATDATE_LSU;
     ELSE DO;
       MSGDATA=WATDATE_SUB(PARY(1));
       IF MSGDATA='.'
         THEN DO;
           MSGDATA='ERROR - DATE MUST BE ALL NUMERIC';
           RETURN;
           END;
       END;
   END WATDATE;

 WATDATE_LSU: PROC;
   DCL 1 OUTPOS,
   %INCLUDE ABELRN;

   DCL (ALTPTR,IPTR,OPTR,SAVPTR) PTR;
   DCL NSAVE FIXED BIN(15,0);

   IPTR=ADDR(LRN_STRUCTURE.POSITIONALS(1));
   OPTR=ADDR(OUTPOS.POSITIONALS(1));
   CALL #ABELSPP(RHHDRPT,RHPTR,ADDR(OUTPOS),PARY(1),NSAVE);
   IF NSAVE<=LENGTH(PARY(1))
     THEN DO;
       MSGDATA='INVALID FIRST OPERAND=TO-SPECIFICATION';
       RHRC=8;
       RETURN;
       END;
   ALTPTR=LRN_STRUCTURE.LRN_RHP;
   DO FOREVER=1 REPEAT FOREVER;
     CALL #ABELSP(RHHDRPT,ADDR(OUTPOS)); /* GET NEXT TO-SEGMENT */
     IF OUTPOS.LRN_BUFP=NULL
       THEN LEAVE;
     SAVPTR=RECPTR;
     RECPTR=ALTPTR;
     CALL #ABELSP(RHHDRPT,LRNPTR); /* NEXT FROM-SEGMENT */
     IF LRN_STRUCTURE.LRN_BUFP=NULL
       THEN CALL #ABELSP(RHHDRPT,LRNPTR); /* START OVER */
     ALTPTR=RECPTR;
     RECPTR=SAVPTR;
     OUTPOS.LRN_BUFP->LSPBUF=
       WATDATE_SUB(LRN_STRUCTURE.LRN_BUFP->LSPBUF);
     END;
   IF LRN_STRUCTURE.LRN_BUFP^=NULL
     THEN DO; /* CLEAN OUT FROM BUFFER */
       SAVPTR=RECPTR;
       RECPTR=ALTPTR;
       CALL #ABELSP(RHHDRPT,LRNPTR); /* START OVER */
       RECPTR=SAVPTR;
       END;
   END WATDATE_LSU;

 WATDATE_SUB: PROC(PDATE) RETURNS(CHAR(80) VAR);
   DCL PDATE CHAR(*) VAR;
   DCL RETSTR CHAR(80) VAR;

   DCL (PREFIX,SUFFIX) ENTRY(CHAR(*), CHAR(*))
     RETURNS(FIXED BIN(15,0));
   DCL SPELDTE ENTRY(CHAR(6))
     RETURNS(CHAR(40) VARYING);
   DCL GREGJUL ENTRY(CHAR(6))
     RETURNS(FIXED DEC(5,0));
   DCL JULGREG ENTRY(CHAR(6),FIXED DEC(5,0));
   DCL MINDTE CHAR(6) VARYING;
   DCL JULIAN FIXED DEC(5,0);
   DCL GREGORIAN CHAR(6);
   DCL (MM,DD,YY) CHAR(2);
   DCL SPEL CHAR(40) VAR;

   IF PDATE=''
     THEN RETURN('.');
   MINDTE = SUBSTR(PDATE,PREFIX(PDATE,' '));
   MINDTE = SUBSTR(MINDTE,1,SUFFIX(MINDTE,' '));
   IF VERIFY(MINDTE,'0123456789')^=0
     THEN DO;
       RETSTR='.';
       RETURN(RETSTR);
       END;
   IF LENGTH(MINDTE) = 5
     THEN DO; /* INPUT IS JULIAN */
       JULIAN = MINDTE;
       CALL JULGREG(GREGORIAN,JULIAN);
       END;
     ELSE DO;  /* INPUT IS GREGORIAN */
       GREGORIAN = MINDTE;
       IF SUBSTR(GREGORIAN,1,2)>'12'
         THEN GREGORIAN=SUBSTR(GREGORIAN,3,4)××SUBSTR(GREGORIAN,1,2);
       JULIAN = GREGJUL(GREGORIAN);
       END;
   MM = SUBSTR(GREGORIAN,1,2);
   DD = SUBSTR(GREGORIAN,3,2);
   YY = SUBSTR(GREGORIAN,5,2);
   SPEL = SPELDTE(SUBSTR(GREGORIAN,5,2)××SUBSTR(GREGORIAN,1,4));
   PUT STRING(RETSTR) EDIT
     ('GREGORIAN=',YY,'/',MM,'/',DD, ', JULIAN=',JULIAN,', DATE=',SPEL)
     (A           ,A ,A  ,A ,A  ,A , A          ,P'99999',A      ,A   )
     ;
   RETURN(RETSTR);
   END WATDATE_SUB;

 RANDOM: PROC;
   DCL (SEED,F1,F2) DEC FLOAT(16);
   DCL TIME BUILTIN;
   DCL MYCMD CHAR(256) VAR;
   DCL PI DEC FLOAT(16) STATIC INIT(3.141592654);
   DCL INTERNAL CHAR(8);

   RANGE=PARY(1);
   COUNT=PARY(2);
   SEED =PARY(3);
   IF PARY(4)^=''
     THEN DO;
       CALL SETCAPS(PARY(4));
       IF PARY(4)=SUBSTR('INTERNAL',1,MIN(8,LENGTH(PARY(4))))
         THEN INTERNAL='INTERNAL';
         ELSE DO;
           RHRC=8;
           MSGDATA='INVALID KEYWORD = '××PARY(4);
           RETURN;
           END;
       END;
   IF RANGE<=0 × RANGE>99999999
     THEN DO;
       MSGDATA='RANGE MUST BE 0<RANGE<100000000';
       RHRC=8;
       RETURN;
       END;
   IF RANGE<=COUNT
     THEN DO;
       MSGDATA='RANGE MUST BE > COUNT';
       RHRC=8;
       RETURN;
       END;
   IF SEED<-1 × SEED>9
     THEN DO;
       MSGDATA='SEED MUST BE -1<=SEED<=9';
       RHRC=8;
       RETURN;
       END;
   IF COUNT<=0 × COUNT>5000
     THEN DO;
       MSGDATA='COUNT MUST BE 0<COUNT<=5000';
       RHRC=8;
       RETURN;
       END;
   I=#CMD('DEL',RHPTR,RHHDRPT);
   IF INTERNAL='INTERNAL'
     THEN DO;
       HEXMODE='1'B;
       I=#CMD('NL ',RHPTR,RHHDRPT);
       RECSTR='';
       END;
   IF RANGE>50000 × COUNT<=RANGE/16
     THEN CALL SLOW;
     ELSE CALL FAST;
   I=#CMD('TOP',RHPTR,RHHDRPT);
   RHRC=0;
   RETURN;


 NEWREC: PROC(J);
 /**********************************************************************
 *                                                                     *
 * CALLED TO STORE NEW VALUE IN DATA SET.                              *
 *                                                                     *
 **********************************************************************/
   DCL (I,J) FIXED BIN,
     JC CHAR(4) BASED(ADDR(J));
   DCL NUMSTR CHAR(8);

   IF INTERNAL='INTERNAL'
     THEN RECSTR=RECSTR××JC;
     ELSE DO;
       PUT STRING(NUMSTR) EDIT(J)(F(8));
       PUT STRING(MYCMD) EDIT('NL ',NUMSTR)(A,A);
       I=#CMD(MYCMD,RHPTR,RHHDRPT);
       END;
   END NEWREC;

 SLOW: PROC;
 /**********************************************************************
 *                                                                     *
 * SLOW METHOD FOR SELECTING UNIQUE RANDOM NUMBERS.                    *
 *                                                                     *
 **********************************************************************/
   DCL K FIXED BIN(31,0);

   K=0;
   DO WHILE(K<COUNT);
     DO UNTIL(UNIQUE(J));
       SEED=RND(SEED);
       J=RANGE*SEED+1;
       END;
     K=K+1;
     CALL NEWREC(J);
     END;
   END SLOW;

 UNIQUE: PROC(J) RETURNS(BIT(1));
 /**********************************************************************
 *                                                                     *
 * CALLED TO DETERMINE IF NEW NUMBER IS UNIQUE.                        *
 *                                                                     *
 **********************************************************************/
   DCL (J,K,L) FIXED BIN;
   DCL NUMSTR CHAR(8);
   DCL R PTR;
   DCL N FIXED BIN BASED(R);

   IF INTERNAL='INTERNAL'
     THEN DO;
       R=PTROUT(PTRIN(RECPTR)+2); /* POINT AT START OF RECORD */
       K=PTRIN(R)+LENGTH(RECSTR); /* POINT AT END OF RECORD */
       DO R=R REPEAT PTROUT(PTRIN(R)+4) UNTIL(R->N=J);
         IF PTRIN(R)>=K
           THEN RETURN('1'B); /* NUMBER IS UNIQUE */
         END;
       RETURN('0'B); /* NUMBER IS NOT UNIQUE */
       END;
     ELSE DO;
       PUT STRING(NUMSTR) EDIT(J)(F(8));
       DO R=NXTHDR REPEAT R->NXTPTR WHILE(R^=HDPTR);
         IF R->RECSTR=NUMSTR
           THEN LEAVE;
         END;
       IF R=HDPTR
         THEN RETURN('1'B);
         ELSE RETURN('0'B);
       END;
   END UNIQUE;

 FAST: PROC;
 /**********************************************************************
 *                                                                     *
 * FAST METHOD FOR SELECTING UNIQUE RANDOM NUMBERS.                    *
 *                                                                     *
 **********************************************************************/

   DCL 1 ARYSTR BASED(ARYPTR),
     2 ARYBND FIXED BIN(15,0),
     2 ARY(RANGE REFER(ARYBND)) FIXED BIN(31,0);

   /* ALLOCATE AND INITIALIZE ARY */
   ALLOCATE ARYSTR;
   DO I=1 TO RANGE;
     ARY(I)=I;
     END;

   /* NOW SHUFFLE THE FIRST COUNT ELEMENTS */
   DO I=1 TO COUNT;
     SEED=RND(SEED);
     J=RANGE*SEED+1;
     K=ARY(I);
     ARY(I)=ARY(J);
     ARY(J)=K;
     END;

   /* NOW CREATE RECORDS WITH NUMBERS IN THEM */
   DO I=1 TO COUNT;
     CALL NEWREC(ARY(I));
     END;
   FREE ARYSTR;
   END FAST;

 RND: PROC(OP) RETURNS(DEC FLOAT(16));
   DCL (OP,RET) DEC FLOAT(16);
   DCL INT FIXED BIN(31,0);
   IF OP<0
     THEN DO;
       RET=SUBSTR(TIME,7);
       OP=RET/1000;
       END;
   RET,INT=(PI+OP)**8;
   RET=RET-INT;
   RETURN(RET);
   END RND;
   END RANDOM;

 VOLSER_PROC: PROC;
 /**********************************************************************
 * VOLSER <DSNAME> <SYMNAME>                                           *
 **********************************************************************/
   DCL (PRMDSN,PREVAL) CHAR(44) VAR;
   DCL GBLSW BIT(1) STATIC INIT('0'B);
   DCL SYMBOLPM CHAR(8);
   DCL SETTXT CHAR(100) VAR;

   IF PARY(2)=''
     THEN SYMBOLPM='VOLSER';
     ELSE DO;
       SYMBOLPM=PARY(2);
       CALL SETCAPS(SYMBOLPM);
       END;
   IF PARQCK(1)
     THEN PRMDSN=PARY(1);
     ELSE DO;
       PREVAL=#SYMC(RHHDRPT,RH_SYMTREE,'SYSPREF');
       IF PREVAL=''
         THEN PREVAL=#SYMC(RHHDRPT,RH_SYMTREE,'SYSUID');
       PRMDSN=PREVAL××'.'××PARY(1);
       END;
   SETTXT=VOLSER_SUB(PRMDSN);
   CALL #SETC(RHHDRPT,RH_SYMTREE,SYMBOLPM,SETTXT);
   MSGDATA=SETTXT;
   END VOLSER_PROC;

 VOLSER_SUB: PROC(PRMDSN) RETURNS(CHAR(6) VAR);
   DCL PRMDSN CHAR(*) VAR;
   DCL SETTXT CHAR(6) VAR;

   CALL SETCAPS(PRMDSN);
   CALL SYSCTLG('NAME',RET,PRMDSN,CVOL,AREA);
   IF RET^='0'B
     THEN SETTXT='';
     ELSE SETTXT=ADDR(AREA)->VOLID.VOLSER(1);
   RETURN(SETTXT);
   END VOLSER_SUB;

   END ABE056;
