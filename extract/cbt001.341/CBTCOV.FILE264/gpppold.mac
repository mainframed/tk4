*PROCESS INCLUDE,MARGINS(2,72);
 /* GPPP: GENERAL PURPROSE PRE-PROCESSOR (YALE/RICE)                 */
 /* GRAMMAR MACRO                                                    */
 /* PRINT OFF                                                        */
 /* (STRINGRANGE): /* FOR CHECKER ONLY*/
 GPPP: PROC(PARM) OPTIONS(MAIN);
 /* PROC:     GPPP                                                   */
 /* FUNCTION:    GENERAL PURPOSE PRE PROCESSOR                       */
 /* VERSION:  JUL 14,1981                                            */
 /* COPYRIGHT   1979  BY HOWARD K. GILBERT                           */
 /*                                                                  */
 /* AUTHOR:                                                          */
 /*                                                                  */
 /*                HOWARD GILBERT                                    */
 /*                YALE COMPUTER CENTER                              */
 /*                175 WHITNEY AVE.                                  */
 /*                NEW HAVEN, CONN.   06520                          */
 /*                203 432 4080                                      */
 /*                                                                  */
 /*  PERMISSION TO MAKE PRIVATE COPIES OF THIS PROGRAM AND           */
 /*  TO USE IT FREELY IS HEREBY GRANTED BY THE AUTHOR. THIS          */
 /*  PROGRAM MAY NOT BE SOLD, NOR MAY ANY SECTION OF IT BE           */
 /*  INCORPORATED INTO ANY WORK FOR SALE WITHOUT PERMISSION OF       */
 /* THE AUTHOR.                                                      */
 /*                                                                  */
 /* ACKNOWLEDGEMENTS:                                                */
 /*      THE AUTHOR WOULD LIKE TO THANK ROB STROM AND PHIL LONG      */
 /*      OF YCC FOR THEIR COMMENTS AND SUGGESTIONS IN THE DESIGN     */
 /*      OF THIS PROGRAM.                                            */
 % PAGE;
 DCL VERSION CHAR(9)              /* VERSION DATE OF PGM             */
         INIT('14 JUL 81');       /*                                 */
 DCL COPYRIT  CHAR(40)            /* COPYRIGHT NOTICE                */
         STATIC EXT               /*                                 */
         INIT('COPYRIGHT 1979 BY HOWARD K. GILBERT');
 DCL ADENDUM CHAR(30)             /* CREDIT WHERE IT'S DUE           */
         STATIC EXT               /*                                 */
         INIT('MODIFIED 1981 BY ALAN BEALE');
 DCL PARM                         /* OS PARM FIELD                   */
         CHAR(100) VAR;           /*                                 */
 DCL PLIXOPT CHAR(8) VAR EXT      /* DEFAULT ISASIZE                 */
          INIT('ISA(160K)');      /*                                 */
 DCL INPUT                        /* PRIMARY INPUT DATASET           */
          INPUT RECORD;           /*    CARD IMAGE                   */
 DCL SYSPUN                       /* PRIMARY OUTPUT DATASET          */
          OUTPUT RECORD           /*                                 */
          ENV(FB RECSIZE(80));    /*                                 */
 DCL SYSPRINT                     /*                                 */
         OUTPUT STREAM PRINT;     /*                                 */
 DCL LISTING                      /*                                 */
         OUTPUT PRINT             /*                                 */
         ENV(VB RECSIZE(132)      /*                                 */
         BLKSIZE(4240 ));         /*                                 */
 DCL LISTFILE FILE VARIABLE;      /*                                 */
 DCL SYSUT1                       /* SCRATCH SEQUENTIAL WORKFILE     */
         FILE;                    /*                                 */
 DCL SYSUT2                       /*                                 */
         FILE;                    /*                                 */
 DCL SYSUT3                       /*                                 */
         FILE;                    /*                                 */
 DCL SYSUTV                       /* VSAM (KEYED) WORKFILE           */
         FILE                     /*                                 */
         ENV(VSAM  REUSE);        /*                                 */
 DCL BUFF                         /* FULL TRACK BUFFER FOR SYSLIB    */
         (162) CHAR(80)           /*   INPUT BLOCKS                  */
         INIT((162)(1) '');       /*                                 */
 DCL INCL#                        /* DEPTH OF INCLUDED MEMBERS       */
         FIXED BIN                /*                                 */
         INIT(0);                 /*                                 */
 DCL MEMNAME(0:10)                /* NAMES OF INCLUDE MEMBERS        */
         CHAR(8) INIT((11)(8)' ');/*                                 */
 DCL REC#                         /* LAST RECORD OFFSET IN BLOCK     */
         FIXED BIN                /*   TO DEBLOCK CARDS              */
         INIT(0);                 /*                                 */
 DCL TTRSAVE(0:10)                /* REMEMBER TTR OF BLOCKS          */
         FIXED BIN(31);           /*   WHERE INCL WAS INTERRUPTED    */
 DCL RECSAVE(0:10)                /* REMEMBER REC# OF INCLUDE IN     */
         FIXED BIN;               /*   INCLUDED MEMBER               */
 DCL 1 SYSLBBLK,                  /* PARAMETER BLOCK FOR SYSLIBR     */
         2 MEMBER CHAR(8)         /*   MEMBER NAME (REQMEM)          */
              INIT(' '),          /*                                 */
         2 TTR FIXED BIN(31)      /* TTR (REQREC)                    */
              INIT(0),
         2 BUFFAD PTR             /* ADDR OF INPUT BUFFER            */
              INIT((ADDR(BUFF))), /*                                 */
         2 WORKAPTR PTR           /* WORK AREA USED BY SYSLIBR       */
              INIT((NULL)),       /*   TO HOLD DCB & DECB            */
         2 BUFFLEN FIXED BIN      /* LENGTH OF INPUT BUFFER          */
              INIT(12960),        /*   SET TO FULL 3330 TRK          */
         2 RECSIZE FIXED BIN,     /* RETURNED LENGTH OF INPUT        */
         2 REQUEST BIT(8) ALIGNED,/* REQUEST TYPE,SEE BELOW          */
         2 ERRORS  BIT(8) ALIGNED,/* ERROR FLAGS, SEE BELOW          */
     REQMEM BIT(8) INIT('1000'B), /*  REQUEST NEW MEMBER             */
     REQREC BIT(8) INIT('0100'B), /*  REQUEST TTR SEARCH             */
     ERREOF BIT(8) INIT('1000'B), /*  END OF FILE                    */
     ERRIO  BIT(8) INIT('0100'B), /*  IO ERROR (USUSED NOW)          */
     ERROPN BIT(8) INIT('0010'B), /*  OPEN ERROR                     */
     ERRMEM BIT(8) INIT('0001'B); /*  MEMBER NOT FOUND               */
 DCL SYSLIBR ENTRY(*)             /* SYSLIB READER                   */
         OPTIONS(ASM INTER);      /*                                 */
 DCL CARDBUF(0:10)                /* INPUT/INCLUDE BUFFERS           */
         CHAR(80) INIT((11)(80)' '); /*                              */
 DCL READPOS(0:10)                /* STMTREAD READ POSITION          */
         FIXED BIN INIT((11) 73); /*                                 */
 DCL PRINTSAVE(0:10)              /* PRINT ON MEMORY                 */
         BIT(1) ALIGNED;          /*                                 */
 DCL PGENSAVE(0:10)               /* PRINT GEN MEMORY                */
         BIT(1) ALIGNED;          /*                                 */
 DCL STMTCOL                      /* STARTING INPUT COLUMN FOR       */
         FIXED BIN;               /* CURRENT INPUT STATEMENT         */
 DCL STRING                       /* HOLDS COMPLETE MACRO STATEMENT  */
          CHAR(10240) VARYING;    /*    FOR CALL TO MACCALL          */
 DCL SOURCEPTR POINTER;           /* POINTER TO CURRENT MACRO STMT   */
 DCL MACCTR                       /* MACRO CALL COUNTER              */
          FIXED BIN INIT(0);      /*                                 */
 DCL CURMAC                       /* NUMBER OF CURRENT ACTIVE MACRO  */
          FIXED BIN INIT(0);      /*                                 */
 DCL BASEMAC                      /* NUMBER OF MACRO CALLED FROM     */
          FIXED BIN INIT(0);      /* SOURCE                          */
 DCL MACNAME CHAR(16);            /* NAME OF MACRO INVOKED FROM INPUT*/
 DCL NOMAC BIT(1) ALIGNED;        /* INPUT NOT MACRO FLAG            */
 DCL ONLYCOM BIT(1) ALIGNED;      /* INPUT ONLY COMMENTS FLAG        */
 DCL MAXRETC                      /* HIGHEST RETURN CODE FOR         */
          FIXED BIN(31)           /*   JOB STEP COMPLETION           */
          INIT(0);                /*                                 */
 DCL CARDNUM(0:10)                /* CARD SEQUENCE NUMBER TO BE      */
          PIC'99999999';          /*   INCREMENTED BY GEN            */
 DCL SEQ#TAB(145)                 /* TABLE OF LINE SEQUENCE NUMBERS  */
          PIC'(8)9',              /*                                 */
     SEQTAB(145)                  /* REDEFINED AS CHARACTER STRINGS  */
          CHAR(8) DEFINED SEQ#TAB;/*                                 */
 DCL LINEX                        /* INDEX INTO SEQ#TAB              */
          FIXED BIN INIT(1);      /*                                 */
 DCL LCARRCTL CHAR(1),            /* LISTING CARR. CTL CHAR          */
     PCARRCTL CHAR(1);            /* SYSPUNCH CARR. CTL CHAR         */
 DCL REPRINT BIT INIT('0'B);      /* NEXT PRINT LINE IS A REPRINT    */
 DCL NOTED BIT INIT('0'B);        /* SYSPRINT IN NOTE STATE          */
 DCL STMTCTR                      /* OBJECT LANGUAGE STMT COUNTER    */
          FIXED BIN INIT(0);      /*                                 */
 DCL UNCOUNTED                    /* TRUE IF STMT NOT TO BE COUNTED  */
          BIT;                    /*                                 */
 DCL SYMBOLSTORE(2)               /* BUFFER FOR SYMBOL TABLES        */
          CHAR(32000);            /*                                 */
 DCL MAXSTORE                     /* SIZE OF SYMBOLSTORE             */
          FIXED BIN(31)           /*   TESTED BY SYMALLOC            */
          INIT(64000);            /*                                 */
 DCL MAXLEVEL                     /* DIMENSION OF LEVELPTR VECTOR    */
          FIXED BIN               /*   TESTED BY PUSH                */
          INIT(40);               /*                                 */
 DCL STOREADDR                    /* CONVERTED VALUE OF SYMBOLSTORE  */
          FIXED BIN(31);          /*   ADDRESS FOR PTR ARITHMETIC    */
 DCL SCANSTATE                    /*                                 */
         FIXED BIN;               /*                                 */
 DCL EXIT FIXED BIN INIT(0)       /*                                 */
         STATIC;
 DCL RESET FIXED BIN INIT(1)      /* THE FOLLOWING                   */
         STATIC;
 DCL QUOTE FIXED BIN INIT(2)      /* VALUES ARE STATES OF            */
         STATIC;
 DCL QUOTE2  FIXED BIN INIT(3)    /* SCANSTATE VARIABLE              */
         STATIC;
 DCL COMMENT FIXED BIN INIT(4)    /*                                 */
         STATIC;
 DCL SLASH FIXED BIN INIT(5)      /*                                 */
         STATIC;
 DCL ASTERISK FIXED BIN INIT(6)   /*                                 */
         STATIC;
 DCL NEXTSTATE(1:6,0:5) FIXED BIN /* STATE TRANSITION MATRIX         */
                                  /* COLUMNS ARE: X ' " ; / *        */
         INIT(RESET,QUOTE,QUOTE2,EXIT,SLASH,RESET, /* RESET ROW      */
              QUOTE,RESET,QUOTE,QUOTE,QUOTE,QUOTE, /* QUOTE ROW      */
              QUOTE2,QUOTE2,RESET,QUOTE2,QUOTE2,QUOTE2,
                                                   /* DBL QUOTE ROW  */
              COMMENT,COMMENT,COMMENT,COMMENT,COMMENT,ASTERISK,
                                                   /* COMMENT ROW    */
              (-RESET),QUOTE,QUOTE2,EXIT,(-SLASH),COMMENT,
                                                   /* SLASH ROW      */
              COMMENT,COMMENT,COMMENT,COMMENT,RESET,ASTERISK);
                                                   /* ASTERISK ROW   */
 DCL OBJECT                       /* RETURN CODES FROM GETWORD/      */
         FIXED BIN STATIC INIT(0);/* GETTOKEN (VARIABLE OR NUMBER)   */
 DCL OPERATOR                     /* OPERATOR (OR SPECIALCHAR STRING)*/
         FIXED BIN STATIC INIT(1);/*                                 */
 DCL PSTRING                      /* (STRING) OR "STRING"            */
         FIXED BIN STATIC INIT(2);/*                                 */
 DCL QSTRING                      /* 'STRING'                        */
         FIXED BIN STATIC INIT(3);/*                                 */
 DCL KEYWORD                      /* STRING(                         */
         FIXED BIN STATIC INIT(4);/*                                 */
 DCL COMMA                        /* LONE COMMA (,)                  */
         FIXED BIN STATIC INIT(5);/*                                 */
 DCL SEMICOLON                    /* LONE SEMICOLON (;)              */
         FIXED BIN STATIC INIT(6);/*                                 */
 DCL EOS                          /* END OF STRING                   */
         FIXED BIN STATIC INIT(7);/*                                 */
 DCL GIBBERISH                    /* USUALLY UNCLOSED QUOTE × COMMENT*/
         FIXED BIN STATIC INIT(8);/*                                 */
 DCL EXPR                         /* STATES FOR IF STATEMENT SCAN    */
         FIXED BIN STATIC INIT(1);/* (EXPRESSION EXPECTED)           */
 DCL VAR                          /* VARIABLE EXPECTED (ASSIGNMENT   */
         FIXED BIN STATIC INIT(1);/* STATEMENT SCAN)                 */
 DCL OPER                         /* OPERATOR EXPECTED               */
         FIXED BIN STATIC INIT(2);/*                                 */
 DCL SUB                          /* SUBSCRIPT EXPECTED              */
         FIXED BIN STATIC INIT(3);/*                                 */
 DCL LIT                          /* LITERAL FOUND                   */
         FIXED BIN STATIC INIT(4);/*                                 */
 DCL NOGOOD                       /* ERROR FOUND                     */
         FIXED BIN STATIC INIT(-1);
 DCL EXPECT(1:3,0:3) FIXED BIN    /* IF STATE TRANSITION MATRIX      */
                                  /* COLUMNS ARE OBJECT, OPERATOR,   */
                                  /*             PSTRING,QSTRING     */
          INIT(SUB,EXPR,OPER,LIT,       /* EXPR ROW                  */
               EXIT,EXPR,NOGOOD,LIT,    /* OPER ROW                  */
               EXIT,EXPR,SUB,NOGOOD);   /* SUBSCRIPT ROW             */
 DCL (I,L)                        /*                                 */
          FIXED BIN;              /*                                 */
 DCL NUMSW BIT                    /* TSO NUMBERING SWITCH            */
          INIT('0'B);             /*                                 */
 DCL RMARG                        /* RIGHT MARGIN COLUMN (72 FOR PLI */
          FIXED BIN INIT(72);     /* 71 FOR BAL)                     */
 DCL INCREMENT                    /* SEQUENCE NUMBER INCREMENT       */
         FIXED BIN                /*   FOR GENNED STATEMENTS         */
         INIT(1);                 /*                                 */
 DCL GENSTMT                      /* NEXT GEN IS NEW STMT FLAG       */
         BIT INIT('1'B);          /*                                 */
 DCL PAGENUM                      /* CURRENT LISTING  PAGE NUMBER    */
         FIXED BIN                /*                                 */
         INIT(0);                 /*                                 */
 DCL TITLE                        /* CURRENT LISTING TITLE           */
         CHAR(71)                 /*                                 */
         INIT(' ');               /*                                 */
 DCL EJECT BIT ALIGNED INIT('0'B);/* FORCE NEW PAGE SWITCH           */
 DCL ANTIC BIT ALIGNED;           /* ANTICIPATORY READ FLAG          */
 DCL YESNO(0:1) CHAR(3)           /*                                 */
         INIT('NO','YES');        /*                                 */
 DCL IDLABEL CHAR(5);             /* ID: STRING FOR HEADLINE         */
 DCL (ADDR,                       /*                                 */
      PLIRETC,                    /*                                 */
      NULL,                       /*                                 */
      MAX,                        /*                                 */
      SUBSTR,                     /*                                 */
      LOW   ,                     /*                                 */
      LENGTH,                     /*                                 */
      VERIFY,                     /*                                 */
      ONSOURCE,                   /*                                 */
      INDEX,                      /*                                 */
      ABS,
      MOD,
      TRANSLATE,
      MIN,                        /*                                 */
      HBOUND)                     /*                                 */
          BUILTIN;                /*                                 */
 DCL PTRIN                        /* ENTRY TO PERMIT PTR ARITHMETIC  */
          ENTRY(PTR)              /*   CONVERTS PTR TO NUMBER        */
          RETURNS(FIXED BIN(31)); /*                                 */
 DCL PTROUT                       /* INVERSE OF PTRIN, CONVERTS A    */
          ENTRY(FIXED BIN(31))    /*   NUMBER TO A POINTER           */
          RETURNS(PTR);           /*                                 */
 DCL NULLPGM ENTRY;               /* IEFBR14-TYPE USED FOR TSO TEST  */
 % PAGE;
 DCL 1 GPPPTCA,
 % INCLUDE GPPPTCA;
 % PAGE;
 /*   THE SYMBOL TABLE IS STORED IN ARRAY SYMBOLSTORE. IT IS         */
 /*   ORGANIZED AS:                                                  */
 /*                                                                  */
 /*          LEVELPTR(0) ->   ---------------                        */
 /*                           ×   LEVEL 0   ×                        */
 /*          LEVELPTR(1) ->   ---------------                        */
 /*                           ×   LEVEL 1   ×                        */
 /*                           ×    . . .    ×                        */
 /*    LEVELPTR(LEVEL#)  ->   ---------------                        */
 /*                           × CURRENTLEVEL×                        */
 /*                           ---------------                        */
 /*                           ×UNUSED AREA  ×                        */
 /*   EACH LEVEL BEGINS WITH A MAJOR SYMBOL TABLE, THEN              */
 /*   CONTAINS STORAGE FOR THE STATIC AND VARIABLE DATA AREAS        */
 /*   FOR THE SYMBOLS USED AT THAT LEVEL.                            */
 /*  THE VARIABLE AND STATIC DATA PARTS ARE CHAINED OFF THE          */
 /*  SYMBOL TABLE ENTRY, AND EACH VARIABLE PART POINTS BACK          */
 /*  THROUGH SYMPTR TO ITS ORIGINATING SYMBOL TABLE ENTRY.           */
 /*   FOR CLEANUP AT EACH LEVEL, THERE IS A CHAIN FROM 'VARCHAIN'    */
 /*  THROUGH EACH VARIABLE DATA ITEM AT THIS LEVEL USING THE         */
 /*  'NEXTVAR' POINTER:                                              */
 /*     (NULL)  <-  <VAR 1>  <-  ...  <- <VAR N-1> <- <VAR N>        */
 /*      ×                                                           */
 /*     VARCHAIN -----------------------------------------           */
 /*                (LEVEL CLEAN UP CHAIN)                            */
 /*                                                                  */
 /*   FOR EACH SYMBOL, ALL OF THE COPIES OF THE VARIABLE INFO        */
 /*  AT EACH LEVEL ARE CHAINED UP USING THE 'BACKVAR' PTR.           */
 /*   ×SYMBOL TABLE ENTRY×          <STATIC> <VAR +0>                */
 /*      VARPTR -------------                    ×                   */
 /*                          ×                   ×                   */
 /*     INTERMEDIATE LEVEL   ×               <VAR +I>                */
 /*                          ×                   ×                   */
 /*     CURRENT LEVEL        --------------> <VAR +N>                */
 /*                  (VAR INFO GENERATION CHAIN)                     */
 /*                                                                  */
 /*   THERE IS ONE MAJOR SYMBOL TABLE AT THE BEGINNING OF            */
 /*  THE DATA FOR ANY LEVEL, BUT IT IS POSSIBLE FOR ANY SYMBOL       */
 /*  TO CONTAIN WITHIN ITS STATIC OR VARIABLE INFORMATION A          */
 /*  SIMILARLY FORMATTED MINOR (SUB)SYMBOL TABLE AND ITS             */
 /*  ENTRIES CAN ACQUIRE STATIC AND VARIABLE DATA AREAS. THE         */
 /*  TABLE SCAN, SYMBOL ADD, AND LEVEL CLEANUP DO NOT                */
 /*  DISTINGUISH MINOR TABLES AND THEIR VARIABLE AREAS FROM          */
 /*  MAJOR SYMBOLS.                                                  */
 % PAGE;
 % INCLUDE GPPPSYM;
 % PAGE;
 /* ON STRINGRANGE HALT; /* FOR CHECKER ONLY */
 ON ERROR SNAP SYSTEM;
 ON ENDFILE(INPUT) GO TO FINN;
 OPEN FILE(SYSPUN) OUTPUT RECORD TITLE('SYSPUNCH'),
      FILE(SYSPRINT) TITLE('SYSTERM'),
      FILE(LISTING) TITLE('SYSPRINT') LINESIZE(132) PAGESIZE(55),
      FILE(INPUT) TITLE('SYSIN');
 ANTIC='1'B;
 READ FILE(INPUT) INTO(CARDBUF(0));
 TITLE=SUBSTR(CARDBUF(0),2,71);
 ON ENDPAGE(LISTING )
         BEGIN;
         PAGENUM=PAGENUM+1;
         IF PAGENUM^=1 THEN PUT FILE(LISTING) PAGE;
         PUT FILE(LISTING ) EDIT('G3P0 R2V2',TITLE,'PAGE',PAGENUM)
         (A,X(13),A(71),COL(110),A(4),F(5));
         PUT FILE(LISTING) SKIP(2) EDIT('INCL','STMT','LINE',
             'SOURCE')(COL(5),A,COL(11),A,X(3),A,COL(109),A);
         IF PAGENUM=1 THEN PUT FILE(LISTING) SKIP;
            ELSE PUT FILE(LISTING) SKIP(2);
         EJECT='0'B;
         END;
 SIGNAL ENDPAGE(LISTING );
 %SKIP;
 SYSPUNCH=SYSPUN;
 SYSUT1F=SYSUT1;
 SYSUT2F=SYSUT2;
 SYSUT3F=SYSUT3;
 AUTOFILE=SYSUT3;
 SYSUTVF=SYSUTV;
 GEN=GENNER;
 NOTE=NOTER;
 QUIT=QUITTER;
 MACCALL=MCALLER;
 PARSE=PARSER;
 PUSH=PUSHER;
 POP=POPPER;
 FIND=FINDER;
 SCAN=SCANNER;
 NEWSYM=SYMADD;
 NEWTAB=MINORTAB;
 COPYVAR=VARCOPIER;
 GRAMMAR=GRAMMER;
 MACADD=MACADDER;
 NUMBER=NUMBERS;
 GETLIST=GETLISTER;
 COUNTER=COUNT;
 IMAGE=IMAGES;
 EXPAND=LONGHAND;
 %SKIP;
 CALL NULLPGM(GPPPTCA);
 /*    TO ALLOW DEBUGGING USING THE TSO TEST COMMAND, WE NOW         */
 /* CALL A DUMMY ENTRY POINT PASSING IT THE TCA ADDRESS. IF          */
 /* YOU SET A BREAKPOINT AT .NULLPGM, YOU CAN USE THE TCA            */
 /* ADDRESS TO SET BREAKPOINTS AT ANY INTERNAL PROCEDURE             */
 /* ENTRY POINT, AND IF YOU REMEMBER THE TCA, YOU CAN INTERACTIVELY  */
 /* INTERROGATE THE SYMBOL TABLE AND STATUS INFO                     */
 % PAGE;
 /* INITIALIZE THE SYMBOL TABLE INFO                                 */
 PRINTON,PRINTGEN,GENON,ANNOT='1'B;
 BLKGEN,GENAUTO,DEBUGER='0'B;
 STMTSTAT,LSTSTAT='0'B;
 SELECT='?';
 LANGUAGE='PLI';
 INCREMENT=1;
 STMTNUM=0;
 SYSCSECT='';
 SYSDSECT='';
 AUTOOF,STATOF=0;
 DSECTOF=0;
 SYSPARM=' ';
 SETUP#=1;
 SETUPS(1)=MAINLINE;
 SUBCA=NULL;
 SYMBOLSTORE=LOW(32000);
 LEVEL#=0;
 SYMBOLTABPTR,LEVELPTR(0)=ADDR(SYMBOLSTORE);
 STOREADDR=PTRIN(ADDR(SYMBOLSTORE));
 VARCHAIN=NULL;
 MAXKEYS=300;
 USEDKEYS=0;
 NEXTSTORE=STPREFIXLEN+300*ITEMLEN;
 SYMBOLTABPTR=NEWTAB('%GRAMMARS%',40,NULL,SYMBOLPTR);
 SYMBOLTABPTR=NEWTAB('%MACROS%',300,NULL,SYMBOLPTR);
 CALL MACADD('USE',USEMAC);
 CALL MACADD('PRINT',PRINTMAC);
 CALL MACADD('INCLUDE',INCLDMAC);
 CALL MACADD('GEN',GENERMAC);
 CALL MACADD('PAGE',PAGEMAC);
 CALL MACADD('TITLE',TITLEMAC);
 CALL MACADD('OPTIONS',OPTIONMAC);
 %SKIP(5);
 ON CONDITION(SEVERR) GO TO FINN;
 SOURCEPTR=NULL;
 IF PARM^='' THEN
         CALL MACCALL('OPTIONS '××PARM);
    ELSE CALL MACCALL('OPTIONS PLI');
 IF LANGUAGE ^='UTIL' THEN
 DO;
 IF SELECT=' ' THEN
    IDLABEL='NOID';
    ELSE IDLABEL='ID: '××SELECT;
 PUT FILE(SYSPRINT ) EDIT('VERSION:',VERSION,'LANGUAGE:',
         LANGUAGE,IDLABEL,'INCREMENT:',INCREMENT,
         'NUMBER:',YESNO(NUMSW),'ANNOTATE:',YESNO(ANNOT),
         'DEBUG:',YESNO(DEBUGER),'PARM:',SYSPARM)
         (SKIP,(2) (A,X(1),A,X(2)),A,X(2), A, F(3),X(2),
         A,X(1),A,X(2),(3) (A,X(1),A,X(2)));
 END;
 READPOS=RMARG;
 CALL SETUPS(SETUP#)(GPPPTCA);
 % SKIP(3);
 FINN:
          CALL PLIRETC(MAXRETC);
          RETURN;
 % PAGE;
 /* PROCEDURE    OPTIONMAC                                          */
 /* FUNCTION     INTERPRETS THE RUN-TIME OPTIONS PARM STRING        */
 /*OPTIONMAC: MACRO                                                 */
    OPTIONMAC: PROC(STRING,GPPPTCA,MACNAME);
    DCL STRING CHAR(*) VAR;
    % NOPRINT;
    DCL 1 GPPPTCA CONNECTED,
    %INCLUDE GPPPTCA;
    % PRINT;
    DCL MACNAME CHAR(16);
 /*PARAMETER LANG REQUIRED POSITIONAL                                */
 /*PARAMETER (NUM,NONUM) BIT                                         */
 /*PARAMETER INCR FIXED DEFAULT(1) SUBFIELD                          */
 /*PARAMETER ID SUBFIELD DEFAULT(?)                                  */
 /*PARAMETER NOID BIT                                                */
 /*PARAMETER ANNOTATE                                                */
 /*PARAMETER DEBUG DEFAULT(NO)                                       */
 /*PARAMETER (GRAMMARS,GRAMMAR,USE) LIST                             */
 /*PARAMETER PARM SUBFIELD                                           */
 DCL GRAMMARNAME CHAR(16);
 /*PARSE                                                             */
    DCL 1 PARMBLOK,
        2 KEYWORDS(011),
            3 PARMN CHAR(16) VAR INIT('NUM','NONUM','INCR','ID','NOID','
 ANNOTATE','DEBUG','GRAMMARS','GRAMMAR','USE','PARM'),
            3 PNUM FIXED BIN INIT(02,02,03,04,05,06,07,08,08,08,09),
       2 PARAMETERS(0:09),
            3 PARMS CHAR(256) VAR INIT('','','','1','?','','','NO','',''
 ),
            3 STATUS BIT(8) ALIGNED INIT('0000'B,'010100'B,'000010'B,'00
 0100'B,'000100'B,'000010'B,'000000'B,'000000'B,'000001'B,'000100'B),
            3 SUBS FIXED BIN INIT(0,0,0,0,0,0,0,0,0,0),
            3 NAMEUSED CHAR(16) VAR;
    DCL LANG CHAR(256) VAR DEF(PARMS(01));
    DCL NUM BIT;
    DCL NONUM BIT;
    DCL INCR FIXED BIN;
    DCL ID CHAR(256) VAR DEF(PARMS(04));
    DCL NOID BIT;
    DCL ANNOTATE CHAR(256) VAR DEF(PARMS(06));
    DCL DEBUG CHAR(256) VAR DEF(PARMS(07));
    DCL GRAMMARS CHAR(256) VAR;
    DCL PARM CHAR(256) VAR DEF(PARMS(09));
    DCL NEXTWORD CHAR(256) VAR;
    DCL POSITION FIXED BIN;
    CALL PARSE(STRING,PARMBLOK,0,'0'B);
    NUM=NAMEUSED(02)='NUM';
    NONUM=NAMEUSED(02)='NONUM';
    INCR=NUMBER(PARMS(03),'INCR');
    NOID=NAMEUSED(05)='NOID';
 SYMBOLPTR=SCAN('%MACROS%',LEVELPTR(0));
 SYMBOLTABPTR=ADDR(VARTEXT);
 IF ADDR(ITEM(USEDKEYS))->KEY=MACNAME THEN
    USEDKEYS=USEDKEYS-1;
 SELECT(LANG);
    WHEN('PLI','UTIL');
    WHEN('BAL') RMARG=71;
    OTHER DO;
       CALL NOTE(16,'INVALID LANGUAGE','GPPP200I');
       CALL QUIT;
    END;
 END;
 LANGUAGE=LANG;
 NUMSW=NUM;
 INCREMENT=INCR;
 SELECTER:
 IF NOID THEN
    SELECT=' ';
    ELSE DO;
      IF LENGTH(ID)^=1 THEN DO;
        CALL NOTE(16,'ID MUST SPECIFY EXACTLY 1 CHARACTER','GPPP202I');
        CALL QUIT;
      END;
        ELSE IF VERIFY(ID,'ABCDEFGHIJKLMNOPQRSTUVWXYZ@#$_1234567890;:/*(
 ),''"=')=0 THEN DO;
        CALL NOTE(16,'ILLEGAL ID CHARACTER','GPPP203I');
        CALL QUIT;
      END;
      SELECT=ID;
      END;
 IF ANNOTATE='OFF' THEN ANNOT='0'B;
 ELSE IF ANNOTATE='ON' THEN ANNOT='1'B;
 ELSE IF ANNOTATE^='' THEN
         CALL NOTE(8,'INVALID ANNOTATE OPTION','GPPP201I');
 IF DEBUG='' THEN DEBUGER='1'B;
 /*OPEN GRAMMARS                                                     */
    POSITION=0;
 /*GET GRAMMARS                                                      */
    NEXTWORD=GETLIST(PARMS(08),POSITION);
    GRAMMARS=NEXTWORD;
     DO WHILE(GRAMMARS^='');
     GRAMMARNAME=GRAMMARS;
     CALL GRAMMAR(GRAMMARNAME);
 /*  GET GRAMMARS                                                    */
    NEXTWORD=GETLIST(PARMS(08),POSITION);
    GRAMMARS=NEXTWORD;
     END;
 SYSPARM=PARM;
 END OPTIONMAC;
 % PAGE;
 /* PROCEDURE    MAINLINE                                            */
 /* FUNCTION     READ INPUT, WRITE OUTPUT, UNTIL THE END             */
 /* THIS IS THE BASIC READ LOOP. ITS FUNCTION IS TO                  */
 /*   READ A CARD                                                    */
 /*   TRY TO INTERPRET AND EXPAND IT AS A MACRO                      */
 /*   ELSE REPRODUCE IT IN THE OUTPUT STREAM                         */
 /* EXIT FROM THIS ROUTINE WILL OCCUR ONLY VIA ON-UNIT (HOPEFULLY    */
 /* FOR ENDFILE ON SYSIN.                                            */
 MAINLINE: PROC;
 READLOOP:
              CALL STMTREADER(STRING,STMTCOL,NOMAC);
              IF ^NOMAC THEN
                 IF MACINV(STRING) THEN
                    GO TO READLOOP;
              IF BLKGEN & STRING='@ENDGEN;' THEN DO;
                 BLKGEN='0'B;
                 IF GENON & ANNOT THEN
                    CALL ANNOTE(STRING,STMTCOL);
                 END;
                 ELSE IF GENON THEN
                    IF LANGUAGE='BAL' & ONLYCOM THEN
                       CALL ANNOTE(STRING,STMTCOL);
                 ELSE
                    CALL COPYSTMT(STRING,STMTCOL,LENGTH(STRING));
         GO TO READLOOP;
 END MAINLINE;
 % PAGE;
 /* PROCEDURE    MACINV                                              */
 /* FUNCTION     TO DETERINE WHETHER A STATEMENT IS A MACRO CALL,    */
 /*              AND TO INVOKE THE MACRO ROUTINE IF SO               */
 MACINV: PROC(STRING) RETURNS(BIT(1) ALIGNED);
 DCL STRING CHAR(*) VAR;
 /* %INCLUDE GPPPSYM; */
 %NOPRINT;
 %INCLUDE GPPPSYM;
 %PRINT;
 %SKIP;
 DCL ENTRYPT ENTRY VARIABLE BASED(ADDR(VARTEXT));
 DCL LABEL CHAR(31) VAR INIT('');
 DCL NEXTWORD CHAR(256) VAR;
 DCL RETCODE FIXED BIN;
 DCL INVOKED BIT ALIGNED INIT('0'B);
 DCL (LOC,POS) FIXED BIN;
 DCL OLDGEN BIT ALIGNED INIT(GENON);
 DCL (CONTINUE,NOMAC) BIT ALIGNED;
         ON CONDITION(SEVERR) GO TO CLEANUP;
         CURMAC,BASEMAC,MACCTR=MACCTR+1;
         SOURCEPTR=ADDR(STRING);
         GENSTMT='1'B;
         IF LANGUAGE='BAL'
            THEN SYMBOLPTR=MACID(STRING,'1'B);
            ELSE DO;
              LOC=0;
              IF SELECT^=' ' THEN DO;
                 DO UNTIL(RETCODE>=SEMICOLON × NEXTWORD=SELECT);
                    NEXTWORD=GETTOKEN(STRING,LOC,RETCODE);
                 END;
                 IF RETCODE>=SEMICOLON THEN
                    GO TO CLEANUP;
                 SUBSTR(STRING,LOC,1)=' ';
              END;
              ELSE DO;
 PRELUDE:
                 POS=LOC;
                 NEXTWORD=GETTOKEN(STRING,LOC,RETCODE);
                 IF RETCODE=PSTRING & SUBSTR(STRING,LOC,1)=')' THEN DO;
                    NEXTWORD=GETTOKEN(STRING,LOC,RETCODE);
                    IF NEXTWORD=':' THEN GO TO PRELUDE;
                       ELSE GO TO CLEANUP;
                    END;
                    ELSE IF RETCODE>PSTRING THEN
                       GO TO CLEANUP;
                    ELSE DO;
                       NOMAC='1'B;
                       SELECT(NEXTWORD);
                          WHEN('OTHER','OTHERWISE','ELSE')
                             CALL ELSESCAN(STRING,LOC,CONTINUE);
                          WHEN('WHEN')
                             CALL WHENSCAN(STRING,LOC,CONTINUE);
                          WHEN('IF')
                             CALL IFSCAN(STRING,LOC,CONTINUE);
                          OTHER
                             CALL ASGNSCAN(STRING,LOC,CONTINUE,NOMAC);
                          END;
                       IF CONTINUE THEN GO TO PRELUDE;
                       IF NOMAC THEN GO TO CLEANUP;
                       END;
                    LOC=POS;
              END;
              IF LOC>1 THEN DO;
                 IF SUBSTR(STRING,1,LOC)^='' THEN DO;
                    NEXTWORD=GETTOKEN(STRING,LOC,RETCODE);
                    LOC=LOC-LENGTH(NEXTWORD);
                    GENSTMT='0'B;
                    CALL COPYSTMT(STRING,STMTCOL,(LOC));
                 END;
                 STRING=SUBSTR(STRING,LOC+1);
              END;
              SYMBOLPTR=MACID(STRING,SELECT^=' ');
              IF SYMBOLPTR=NULL & SELECT^=' '
                 THEN SUBSTR(STRING,1,1)=SELECT;
         END;
         IF SYMBOLPTR^=NULL THEN DO;
            IF ^UNCOUNTED & GENSTMT THEN DO;
               UNCOUNTED='1'B;
               CALL KILLSTMT;
               STMTCTR=STMTCTR-1;
            END;
            IF ANNOT & GENON THEN
               CALL ANNOTE((STRING),STMTCOL);
            CARDNUM(INCL#)=SEQ#TAB(LINEX);
            ON CONDITION(SEVERR) GO TO MACOVER;
            MACNAME=SYMBOL.KEY;
            CALL ENTRYPT(STRING,GPPPTCA,SYMBOL.KEY);
 MACOVER:
            IF OLDGEN^=GENON THEN
               CALL ECHOSPILL;
            INVOKED='1'B;
         END;
 CLEANUP:
         CURMAC,BASEMAC=0;
         SOURCEPTR=NULL;
         RETURN(INVOKED);
 END MACINV;
 % SKIP(3);
 /* PROCEDURE    MCALLER                                             */
 /* FUNCTION     PERFORM AN INTERPRETIVE MACRO CALL FROM NON-INPUT   */
 /*              TEXT                                                */
 /* LINKAGE      THIS PROCEDURE IS KNOWN IN THE TCA UNDER THE        */
 /*             ALIAS 'MACCALL'. IT IS INVOKED BY                    */
 /*               CALL MACCALL(STATEMENT);                           */
 /*             WHERE STATEMENT IS A CHARACTER STRING CONTAINING A   */
 /*             MACRO STATEMENT                                      */
 /* EXTERNAL     CALLS THE MACRO ENTRY POINT WHICH IT FINDS          */
 /*             IN THE SYMBOL TABLE.                                 */
 MCALLER:PROC(STRING) RECURSIVE;
 DCL STRING CHAR(*) VAR;
 /* %INCLUDE GPPPSYM; */
 %NOPRINT;
 %INCLUDE GPPPSYM;
 %PRINT;
 %SKIP;
 DCL ENTRYPT ENTRY VARIABLE BASED(ADDR(VARTEXT));
 DCL PREVPTR POINTER;
         PREVPTR=SOURCEPTR;
         SOURCEPTR=ADDR(STRING);
         CURMAC,MACCTR=MACCTR+1;
         SYMBOLPTR=MACID(STRING,'1'B);
         IF SYMBOLPTR^=NULL THEN
              CALL ENTRYPT(STRING,GPPPTCA,SYMBOL.KEY);
         CURMAC=CURMAC-1;
         SOURCEPTR=PREVPTR;
 END MCALLER;
 %SKIP(3);
 /* PROCEDURE    MACID                                                */
 /* FUNCTION     TO IDENTIFY THE VERB IN A MCRO STATEMENT AND FIND    */
 /*              THE CORRESPONDING MACRO ENTRY POINT. IF THERE IS     */
 /*              NONE, OPTIONALLY TO WRITE AN ERROR MESSAGE           */
 MACID: PROC(STRING,ERRMSG) RETURNS(POINTER);
 DCL STRING CHAR(*) VAR;
 DCL ERRMSG BIT(1) ALIGNED;
 DCL POSITION FIXED BIN;
 DCL RETCODE FIXED BIN;
 DCL (TEMP,NEXTWORD) CHAR(1024) VAR INIT('');
 DCL MACNAME CHAR(16);
 /* %INCLUDE GPPPSYM; */
 %NOPRINT;
 %INCLUDE GPPPSYM;
 %PRINT;
 %SKIP;
         POSITION=0;
 MACN:
         NEXTWORD=GETWORD(STRING,POSITION,RETCODE);
         IF RETCODE=SEMICOLON THEN RETURN(NULL);
         IF NEXTWORD='' × (RETCODE^= OBJECT & RETCODE^=KEYWORD)
            THEN DO;
               IF ERRMSG
                  THEN CALL SYNTAX('INVALID MACRO SYNTAX','GPPP001I',
                                   POSITION);
               RETURN(NULL);
            END;
         IF POSITION<LENGTH(STRING) THEN
            IF SUBSTR(STRING,POSITION+1,1)=':' THEN DO;
               POSITION=POSITION+1;
               GO TO MACN;
            END;
         SYMBOLPTR=SCAN('%MACROS%',LEVELPTR(0));
         SYMBOLTABPTR=ADDR(VARTEXT);
         IF RETCODE=KEYWORD & LANGUAGE='BAL'
            THEN DO;
               TEMP=GETWORD(STRING,POSITION,RETCODE);
         IF RETCODE=PSTRING
            THEN
               TEMP=GETWORD(STRING,POSITION,RETCODE);
               IF TEMP='='
                  THEN
                     NEXTWORD='%ASSIGN%';
            END;
         MACNAME=NEXTWORD;
         SYMBOLPTR=SCAN(MACNAME,SYMBOLTABPTR);
         IF SYMBOLPTR=NULL & ERRMSG THEN
              CALL SYNTAX('VERB NOT FOUND','GPPP002I',POSITION);
         RETURN(SYMBOLPTR);
 END MACID;
 % PAGE;
 /* PROCEDURE    PARSER                                              */
 /* FUNCTION     TO PARSE A MACRO STATEMENT AND EXTRACT THE          */
 /*          KEYWORDS AND POSITIONAL PARAMETERS.                     */
 /* LINKAGE      THIS PROCEDURE IS KNOWN IN THE TCA UNDER THE        */
 /*          ALIAS 'PARSE'. IT IS INVOKED BY                         */
 /*             CALL PARSE(STATEMENT,PARMBLOK);
 /*          WHERE STATEMENT IS A CHARACTER STRING CONTAINING A      */
 /*          MACRO CALL STATEMENT.                                   */
 /* EXTERNAL     CALLS GETWORD                                       */
 /* EXIT         FOR SYNTAX ERROR, CALLS 'ERR' TO EXIT               */
 PARSER:PROC(STRING,PARMBLOK,POSITION,SPECIAL);
 DCL STRING CHAR(*) VAR;
 DCL POSITION FIXED BIN;
 DCL SPECIAL BIT ALIGNED;
 DCL RETCODE FIXED BIN;
 DCL 1 PARMBLOK,
         2 KEYWORDS(*),
              3 PARMNAMES CHAR(16) VAR,
              3 PNUM FIXED BIN,
         2 PARAMETERS(*),
              3 PARMS CHAR(*) VAR,
              3 STATUS BIT(8) ALIGNED,
              3 SUBSCR FIXED BIN,
              3 NAMEUSED CHAR(16) VAR;
 DCL PREP   BIT(8) ALIGNED INIT('1000'B) STATIC;
 DCL POSIT  BIT(8) ALIGNED INIT('0100'B) STATIC;
 DCL ENDSCN BIT(8) ALIGNED INIT('0010'B) STATIC;
 DCL REQ    BIT(8) ALIGNED INIT('0001'B) STATIC;
 DCL NOSUB  BIT(8) ALIGNED INIT('00001'B) STATIC;
 DCL LIST   BIT(8) ALIGNED INIT('000001'B) STATIC;
 DCL ISSET  BIT(8) ALIGNED INIT('00000001'B) STATIC;
 DCL (NEXTWORD,VALUE) CHAR(1024) VAR INIT('');
 DCL PARM# FIXED BIN;
 DCL POSPARM FIXED BIN INIT(1);
 DCL GOTAKEY BIT INIT('0'B);
 DCL LSTPOSITION FIXED BIN;
 NAMEUSED='';
 %SKIP;
         POSITION=0;
 MACN:
         NEXTWORD=GETWORD(STRING,POSITION,RETCODE);
         IF POSITION<LENGTH(STRING) THEN
            IF SUBSTR(STRING,POSITION+1,1)=':'
              THEN
                   DO;
                   IF (STATUS(0) & POSIT)='0'B THEN
                      CALL SYNTAX('LABEL NOT SUPPORTED BY MACRO',
                         'GPPP016I',POSITION+1);
                   CALL SETPARM(0,NEXTWORD);
                   POSITION=POSITION+1;
                   GO TO MACN;
                   END;
         IF (STATUS(0) & (REQ × ISSET))=REQ THEN
            CALL SYNTAX('MISSING REQUIRED LABEL','GPPP017I',1);
 %SKIP;
 PARMLOOP:
         IF SPECIAL THEN
            SPECIAL='0'B;
            ELSE NEXTWORD=GETWORD(STRING,POSITION,RETCODE);
         LSTPOSITION=POSITION-LENGTH(NEXTWORD)+1;
         IF POSPARM>HBOUND(PARMS,1) & RETCODE<SEMICOLON THEN
              CALL SYNTAX('TOO MANY PARMS','GPPP003I',LSTPOSITION);
         IF RETCODE=GIBBERISH THEN
 SYNERR:
            CALL SYNTAX('STATEMENT UNINTELLIGIBLE','GPPP004I',
                        LSTPOSITION);
         IF POSPARM>HBOUND(PARMS,1)
            THEN RETURN;
         IF STATUS(POSPARM) & ENDSCN THEN DO;
            POSITION=POSITION+1;
            RETURN;
            END;
         IF RETCODE=COMMA
            THEN DO;
               NEXTWORD=GETWORD(STRING,POSITION,RETCODE);
               IF RETCODE=GIBBERISH THEN
                  GO TO SYNERR;
            END;
         SELECT (RETCODE);
              WHEN (SEMICOLON,EOS)
                   DO;
                   IF POSPARM>HBOUND(STATUS,1) THEN RETURN;
                   IF (STATUS(POSPARM) & (POSIT × REQ))=(POSIT × REQ)
                   THEN CALL SYNTAX('MISSING REQUIRED PARM','GPPP005I',
                             LSTPOSITION);
                   RETURN;
                   END;
              WHEN (COMMA)
                   DO;
                   IF POSPARM<=HBOUND(STATUS,1)
                      THEN DO;
                         IF STATUS(POSPARM) & REQ THEN
                            CALL SYNTAX('MISSING REQUIRED PARM',
                               'GPPP005I',LSTPOSITION);
                         POSPARM=POSPARM+1;
                      END;
                   END;
              WHEN (KEYWORD)
                   DO;
                   IF (STATUS(POSPARM) & (POSIT×REQ))=(POSIT×REQ) THEN
                        DO;
                        IF SUBSCR(POSPARM)=0 THEN
                             CALL SYNTAX('PREMATURE KEYWORD '××NEXTWORD,
                                'GPPP006I',LSTPOSITION);
                        PARM#=SUBSCR(POSPARM);
                        CALL SETPARM(POSPARM,NEXTWORD);
                        POSPARM=POSPARM+1;
                        GO TO GOTPARM;
                        END;
                   GOTAKEY='1'B;
                        DO PARM#=1 TO HBOUND(PARMNAMES,1);
                        IF NEXTWORD=PARMNAMES(PARM#)
                             THEN GO TO GOTNAME;
                        END;
                   CALL SYNTAX('UNRECOGNIZED KEYWORD '××NEXTWORD,
                        'GPPP007I',LSTPOSITION);
 GOTNAME:
                   IF STATUS(PNUM(PARM#)) & NOSUB THEN
                      CALL SYNTAX(NEXTWORD××' SUBFIELD NOT ALLOWED',
                         'GPPP008I',LSTPOSITION);
                   NAMEUSED(PNUM(PARM#))=NEXTWORD;
                   PARM#=PNUM(PARM#);
 GOTPARM:
                   VALUE=GETWORD(STRING,POSITION,RETCODE);
                   IF RETCODE>QSTRING
                        THEN
                             CALL SYNTAX('INCOMPLETE PARAMETER',
                                      'GPPP010I',LSTPOSITION);
                   IF SUBSTR(VALUE,1,1)='(' THEN
                   CALL SETPARM(PARM#,SUBSTR(VALUE,2,LENGTH(VALUE)-2));
                      ELSE CALL SETPARM(PARM#,VALUE);
                   END;
              WHEN (PSTRING,QSTRING)
                   DO;
                   IF (STATUS(POSPARM) & POSIT)='0'B × GOTAKEY THEN
                        CALL SYNTAX('IMPROPER POSITIONAL PARM',
                             'GPPP009I',LSTPOSITION);
                   IF (STATUS(POSPARM) & LIST)=LIST &
                      SUBSTR(STRING,POSITION,1)='"' THEN
                         CALL SYNTAX('IMPROPER LIST PARAMETER',
                            'GPPP011I',LSTPOSITION);
                   IF SUBSTR(STRING,POSITION,1)^=')' THEN
                      CALL SETPARM(POSPARM,NEXTWORD);
                      ELSE CALL SETPARM(POSPARM,SUBSTR(NEXTWORD,2,
                         LENGTH(NEXTWORD)-2));
                   POSPARM=POSPARM+1;
                   END;
              WHEN (OBJECT)
                   DO;
                   IF (STATUS(POSPARM) & (POSIT×REQ))^=(POSIT×REQ) THEN
                        DO PARM#=1 TO HBOUND(PARMNAMES,1);
                        IF NEXTWORD=PARMNAMES(PARM#)
                             THEN
                                  DO;
                                  IF STATUS(PNUM(PARM#)) & REQ THEN
                                     CALL SYNTAX(NEXTWORD××' KEYWORD REQ
 UIRES SUBFIELD',                       'GPPP012I',LSTPOSITION);
                                  NAMEUSED(PNUM(PARM#))=NEXTWORD;
                                  PARM#=PNUM(PARM#);
                                  GOTAKEY='1'B;
                                  IF STATUS(PARM#) & PREP
                                       THEN
                                            GO TO GOTPARM;
                                  CALL SETPARM(PARM#,'');
                                  GO TO PARMLOOP;
                                  END;
                        END;
                   IF (STATUS(POSPARM) & POSIT)='0'B × GOTAKEY THEN
                        CALL SYNTAX('UNRECOGNIZED KEYWORD '××NEXTWORD,
                             'GPPP007I',LSTPOSITION);
                   CALL SETPARM(POSPARM,NEXTWORD);
                   POSPARM=POSPARM+1;
                   END;
         END;
         GOTO PARMLOOP;
 SETPARM: PROC(I,VAL);
         DCL I FIXED BIN;
         DCL VAL CHAR(*) VAR;
         IF STATUS(I)&ISSET THEN
              CALL SYNTAX('DUPLICATE OR EXCLUSIVE KEYWORDS',
                   'GPPP013I',LSTPOSITION);
         STATUS(I)=STATUS(I)×ISSET;
         IF VAL='' THEN
           PARMS(I)=' ';
           ELSE PARMS(I)=VAL;
         END;
 END PARSER;
 % PAGE;
 /* PROCEDURE    MINORTAB                                            */
 /* FUNCTION     CREATE A MINOR SYMBOL TABLE                         */
 /* LINKAGE      THIS PROCEDURE IS KNOWN UNDER THE ALIAS 'NEWTAB'    */
 /*    SYMBOLTABPTR=NEWTAB(SYMBOLNAME,NUMENTRIES,MAJORTABPTR,        */
 /*              SYMBOLPTR);                                         */
 /*          WHERE SYMBOLNAME IS THE TABLE NAME                      */
 /*          NUMENTRIES IS THE MAXIMUM NUMBER OF ENTRIES IN THE TABLE*/
 /*          MAJORTABPTR IS A POINTER TO THE CONTAINING SYMBOL TABLE,*/
 /*              OR NULL FOR THE MAJOR TABLE AT THE CURRENT LEVEL    */
 /*          SYMBOLPTR WILL RECEIVE THE ADDRESS OF THE ENTRY ADDED   */
 /*              TO THE SUPER TABLE CONTAINING OR ADDRESSING THE NEW */
 /*              TABLE.                                              */
 MINORTAB: PROC(SYMNAME,TABSIZE,SYMBOLTABPTR,SYMBOLPTR) RETURNS(PTR);
 DCL SYMNAME CHAR(16),
     TABSIZE FIXED BIN,
     NEWTABPTR POINTER;
 DCL (STATSIZE,VARSIZE) FIXED BIN;
 /* %INCLUDE GPPPSYM; */
 %NOPRINT;
 %INCLUDE GPPPSYM;
 %PRINT;
 STATSIZE=12;
 VARSIZE=12+STPREFIXLEN+TABSIZE*ITEMLEN;
 SYMBOLPTR=NEWSYM(SYMNAME,STATSIZE,VARSIZE,SYMBOLTABPTR);
 IF SYMBOLPTR=NULL THEN RETURN(NULL);
 TYPENAME='%SYMTAB%';
 NEWTABPTR=ADDR(VARTEXT);
 NEWTABPTR->VARCHAIN=NULL;
 NEWTABPTR->MAXKEYS=TABSIZE;
 NEWTABPTR->USEDKEYS=0;
 RETURN(NEWTABPTR);
 END MINORTAB;
 % PAGE;
 /* PROCEDURE    SYMADD                                              */
 /* FUNCTION     ADD A NEW SYMBOL TO A SYMBOL TABLE                  */
 /* LINKAGE      THIS PROCEDURE IS KNOWN UNDER THE ALIAS 'NEWSYM'    */
 /*    SYMBOLPTR= NEWSYM(SYMBOLNAME,STATICAREASIZE,VARIABLEAREASIZE, */
 /*              SYMBOLTABLEPTR);                                    */
 /*          WHERE SYMBOLNAME IS THE NEW SYMBOL NAME                 */
 /*          STATICAREASIZE IS THE SIZE OF ITS ASSOCIATED STATIC     */
 /*          DATA AREA (MINIMUM SIZE IS 12).                         */
 /*          VARIABLEAREASIZE IS THE SIZE OF THE ASSOCIATED VARIABLE */
 /*          DATA AREA (MINIMUM SIZE IS 12).                         */
 /*          SYMBOLTABLEPTR IS NULL() IF THE SYMBOL IS TO GO IN      */
 /*          MAJOR SYMBOL TABLE AT THE CURRENT LEVEL, OR IS THE      */
 /*          ADDRESS OF THE SYMBOL TABLE THE NEW ENTRY IS TO GO IN.  */
 /* EXTERNAL     CALLS FIND AND SCAN                                 */
 SYMADD: PROC(SYMNAME,STATSIZE,VARSIZE,STPTR)
          RETURNS(PTR);
 DCL SYMNAME CHAR(16);
 DCL STATSIZE FIXED BIN;
 DCL VARSIZE FIXED BIN;
 DCL STPTR PTR;
 /* %INCLUDE GPPPSYM; */
 %NOPRINT;
 %INCLUDE GPPPSYM;
 %PRINT;
 IF STPTR^=NULL
         THEN
              SYMBOLTABPTR=STPTR;
         ELSE
              SYMBOLTABPTR=LEVELPTR(LEVEL#);
 SYMBOLPTR=SCAN(SYMNAME,SYMBOLTABPTR);
 IF SYMBOLPTR^=NULL
         THEN RETURN(NULL);
 IF USEDKEYS>=MAXKEYS THEN
         CALL INTERR('SYMBOL TABLE OVERFLOW','GPPP902I');
 USEDKEYS=USEDKEYS+1;
 SYMBOLPTR=ADDR(ITEM(USEDKEYS));
 KEY=SYMNAME;
 STATICLEN=MAX(STATSIZE,12);
 VARLEN=MAX(VARSIZE,12);
 STATICPTR=SYMALLOC(STATICLEN);
 VARPTR=SYMALLOC(VARLEN);
 SYMPTR=SYMBOLPTR;
 NEXTVAR=VARCHAIN;
 VARCHAIN=VARPTR;
 BACKVAR=NULL;
 RETURN(SYMBOLPTR);
 END;
 % PAGE;
 /* PROCEDURE    SYMALLOC                                            */
 /* FUNCTION     ALLOCATES STORAGE IN THE SYMBOL TABLE FOR SOME      */
 /*          DATA AREA                                               */
 /* LINKAGE      POINTER=SYMALLOC(AREASIZE)                          */
 /* EXTERNAL     NONE                                                */
 SYMALLOC: PROC(SIZE) RETURNS(PTR);
 DCL SIZE FIXED BIN;
 DCL P PTR;
 P=PTROUT(STOREADDR+NEXTSTORE);
 NEXTSTORE=NEXTSTORE+SIZE;
 IF NEXTSTORE>MAXSTORE THEN
         CALL INTERR('SYMBOL STORAGE OVERFLOW','GPPP903I');
 RETURN(P);
 END;
 % PAGE;
 /* PROCEDURE    FINDER                                              */
 /* FUNCTION     SCAN ALL MAJOR SYMBOL TABLES STARTING AT THE        */
 /*          CURRENT LEVEL FOR AN OCCURENCE OF THE NAMED SYMBOL      */
 /* LINKAGE      KNOWN IN THE TCA UNDER THE ALIAS 'FIND'             */
 /*       SYMBOLPTR= FIND(SYMBOLNAME);                               */
 /* EXTERNAL     CALLS SCAN TO DO THE WORK                           */
 FINDER: PROC(SYMNAME) RETURNS(PTR);
 DCL I FIXED BIN;
 DCL P PTR INIT(NULL);
 DCL SYMNAME CHAR(16);
         DO I=LEVEL# TO 0 BY -1 WHILE(P=NULL);
         P=SCANNER(SYMNAME,LEVELPTR(I));
         END;
 RETURN(P);
 END;
 % SKIP(3);
 /* PROCEDURE    SCANNER                                             */
 /* FUNCTION     EXAMINE A SPECIFIED SYMBOL TABLE FOR                */
 /*          A NAMED SYMBOL                                          */
 /* LINKAGE      THIS ROUTINE IS KNOWN IN THE TCA UNDER THE          */
 /*          ALIAS 'SCAN'.                                           */
 /*              SYMBOLPTR= SCAN(SYMBOLNAME,SYMBOLTABLEPTR);         */
 /* XTERNAL  NONE                                                    */
 SCANNER: PROC(SYMNAME,SYMBOLTABPTR) RETURNS(PTR);
 DCL SYMNAME CHAR(16);
 DCL I FIXED BIN;
 /* %INCLUDE GPPPSYM; */
 %NOPRINT;
 %INCLUDE GPPPSYM;
 %PRINT;
         DO I=1 TO USEDKEYS;
         SYMBOLPTR=ADDR(ITEM(I));
         IF SYMNAME=KEY THEN RETURN(SYMBOLPTR);
         END;
 RETURN(NULL);
 END;
 % PAGE;
 /* PROCEDURE    VARCOPIER                                           */
 /* FUNCTION     PROVIDE A COPY OF THE CURRENT VARIABLE DATA         */
 /*          ASSOCIATED WITH A SYMBOL TO THE CURRENT LEVEL FOR       */
 /*          MODIFICATION BY THE MACRO.                              */
 /* LINKAGE      THIS PROCEDURE IS KNOWN IN THE TCA UNDER THE        */
 /*             ALIAS 'VARCOPY'. THE CALL IS                         */
 /*                CALL VARCOPY(SYMBOLPTR);                          */
 /*          WHERE SYMBOLPTR IS THE ADDRESS OF THE SYMBOLTABLE       */
 /*          ENTRY FOR THE ITEM WHOSE DATA IS TO BE COPIED. IF       */
 /*          A COPY EXISTS AT THE CURRENT LOGICAL LEVEL ALREADY,     */
 /*          WE RETURN WITHOUT DOING ANYTHING.                       */
 /*          OTHERWISE, STORAGE IS ALLOCATED AND THE APPROPRIATE     */
 /*          CHAINS ARE UPDATED.                                     */
 /* EXTERNAL     CALLS SYMALLOC                                      */
 VARCOPIER: PROC(SYMBOLPTR);
 DCL P PTR;
 /* %INCLUDE GPPPSYM; */
 %NOPRINT;
 %INCLUDE GPPPSYM;
 %PRINT;
 SYMBOLTABPTR=LEVELPTR(LEVEL#);
 IF PTRIN(VARPTR)>PTRIN(LEVELPTR(LEVEL#)) THEN RETURN;
 P=SYMALLOC(VARLEN);
 P -> BACKVAR = VARPTR;
 VARPTR = P;
 SYMPTR=SYMBOLPTR;
 NEXTVAR=VARCHAIN;
 VARCHAIN=P;
 SUBSTR(VARTEXT,1,VARLEN-12)=SUBSTR(BACKVAR -> VARTEXT,1,VARLEN-12);
 RETURN;
 END;
 % PAGE;
 /* PROCEDURE    PUSHER                                              */
 /* FUNCTION     PUSHES THE CURRENT SYMBOL TABLE LEVEL DOWN ONE      */
 /* LINKAGE      KNOWN IN THE TCA UNDER THE ALIAS 'PUSH'.            */
 /*             CALL PUSH(SYMBOLCOUNT);                              */
 /*          WHERE SYMBOLCOUNT IS THE MAXIMUM NUMBER OF SYMBOLS      */
 /*          IN THE MAJOR SYMBOL TABLE FOR THIS LEVEL.               */
 /* EXTERNAL     NONE                                                */
 PUSHER: PROC(SYMCOUNT);
 DCL SYMCOUNT FIXED BIN;
 /* %INCLUDE GPPPSYM; */
 %NOPRINT;
 %INCLUDE GPPPSYM;
 %PRINT;
 IF LEVEL#>=MAXLEVEL THEN
         CALL INTERR('SYMBOL STACK OVERFLOW','GPPP900I');
 SYMBOLTABPTR,LEVELPTR(LEVEL#+1)=
          SYMALLOC(STPREFIXLEN+SYMCOUNT*ITEMLEN);
 LEVEL#=LEVEL#+1;
 VARCHAIN=NULL;
 MAXKEYS=SYMCOUNT;
 USEDKEYS=0;
 END PUSHER;
 % SKIP(3);
 /* PROCEDURE    POPPER                                              */
 /* FUNCTION     POPS THE CURRENT SYMBOL TABLE STACK                 */
 /* LINKAGE      KNOWN IN THE TCA AS 'POP'                           */
 /*             CALL POP;                                            */
 POPPER: PROC;
 DCL MYVARPTR PTR;
 % INCLUDE GPPPSYM;
 SYMBOLTABPTR=LEVELPTR(LEVEL#);
 IF LEVEL#<0 THEN
         CALL INTERR('SYMBOL STACK UNDERFLOW','GPPP901I');
         DO MYVARPTR=VARCHAIN REPEAT MYVARPTR->NEXTVAR
            WHILE(MYVARPTR^=NULL);
         MYVARPTR -> SYMPTR -> VARPTR= MYVARPTR -> BACKVAR;
         END;
 NEXTSTORE=PTRIN(LEVELPTR(LEVEL#))-STOREADDR;
 LEVEL#=LEVEL#-1;
 END;
 % PAGE;
 /* PROCEDURE    SYNTAX                                              */
 /* FUNTION  SIGNALS AN ERROR IN THE INPUT                           */
 /*          THIS ROUTINE WILL PRINT AN ERROR MESSAGE LINE,          */
 /*             PLUS THE CUURENT INPUT STATEMENT (TERMINAL ONLY)     */
 /*             AND PUT A '?' UNDER THAT LINE AT THE CURRENT         */
 /*             SCAN POSITION. IT IS INTENDED FOR SYNTAX             */
 /*             ERRORS AND NOT FOR MACRO DETECTED ERRORS             */
 /*             (SEE NOTER BELOW).                                   */
 /* EXIT         VIA SIGNAL CONDITION(SEVERR)                        */
 SYNTAX: PROC(TEXT,ID,POSITION);
 DCL TEXT CHAR(*) VAR;
 DCL ID CHAR(8);
 DCL STRPTR POINTER;
 DCL POSITION FIXED BIN;
 STRPTR=SOURCEPTR;
 GEND=BASEMAC^=CURMAC;
 MACNO=CURMAC;
 GO TO COMMON;
 /* ENTRY       ERR                                                  */
 /* FUNTION  SIGNALS AN ERROR IN A NON-STATEMENT SCAN CONTEXT        */
 /*          THIS ROUTINE WILL PRINT AN ERROR MESSAGE LINE,          */
 /*             PLUS THE TEXT TO WHICH THE ERROR APPLIES             */
 /*             AND PUT A '?' UNDER THAT LINE AT THE APPROXIMATE     */
 /*             ERROR LOCATION. IT SHOULD BE USED ONLY WHEN THE      */
 /*             APPLICABLE TEXT IS NOT THE FULL CURRENT INPUT        */
 /*             STATEMENT.                                           */
 /* EXIT         VIA SIGNAL CONDITION(SEVERR)                        */
 ERR: ENTRY(TEXT,ID,STR,POSITION);
 DCL STR CHAR(*) VAR;
 DCL GEND BIT ALIGNED INIT('1'B);
 DCL MACNO FIXED BIN INIT(0);
 STRPTR=ADDR(STR);
 COMMON:
 CALL MSGWTR(ID,12,TEXT,GEND,MACNO,STRPTR,POSITION);
 SIGNAL CONDITION(SEVERR);
 END SYNTAX;
 % SKIP(3);
 /* PROCEDURE    NOTER                                               */
 /* FUNCTION     GENERATE AN 'MNOTE' MESSAGE IN LISTING AND TERMINAL */
 /*              DATASETS                                            */
 /* LINKAGE      THIS PROCEDURE IS KNOW IN THE TCA UNDER THE ALIAS   */
 /*          'NOTE'. A MACRO CALLS IT BY                             */
 /*             CALL NOTE(RETURNCODE,MESSAGE,ID)                     */
 /*          WHERE                                                   */
 /*             RETURNCODE IS A FIXED BIN NUMBER WHICH IS COMPARED   */
 /*             WITH THE CURRENT MAXIMUM RETURN CODE TO BE PASSED    */
 /*             BACK WHEN THE JOBSTEP ENDS,                          */
 /*             MESSAGE IS AN ERROR MESSAGE TO BE PRINTED ON THE     */
 /*             OUTPUT                                               */
 /*             ID IS A CHAR(8) MESSAGE ID                           */
 NOTER:PROC(RETC,MSG,ID);
 DCL RETC FIXED BIN;
 DCL MSG CHAR(*) VAR;
 DCL ID CHAR(8);
     IF RETC = 0 & LANGUAGE = 'UTIL'
        THEN
           DO;
           PUT FILE(SYSPRINT) EDIT (ID,' ',MSG,'.') (COL(1),4 A);
           RETURN;
           END;
     CALL MSGWTR(ID,RETC,MSG,'0'B,BASEMAC,SOURCEPTR,0);
 END NOTER;
 % SKIP(3);
 /* PROCEDURE    INTERR                                              */
 /* FUNCTION     PRINT AN INTERNAL ERROR MESSAGE ASSOCIATED          */
 /*          WITH SOME TABLE OVERFLOW, ETC.                          */
 /* LINKAGE      CALL INTERR(MESSAGE,ID);                            */
 /* EXTERNAL     NONE                                                */
 /* EXIT         SIGNALS ERROR CONDITION AND TERMINATES PROCESSING   */
 INTERR: PROC(MSG,ID);
 DCL MSG CHAR(*) VAR;
 DCL ID CHAR(8);
 CALL MSGWTR(ID,999,MSG,'0'B,0,NULL,0);
 CALL NULLPGM(GPPPTCA);
 SIGNAL ERROR;
 END;
 % SKIP(3);
 /* PROCEDURE    QUITTER                                             */
 /* FUNCTION     TO TERMINATE THE CURRENT JOBSTEP IMMEDIATELY        */
 /* LINKAGE      QUITTER IS KNOWN IN THE TCA UNDER THE ALIAS         */
 /*             'QUIT'. A MACRO INVOKES IT BY                        */
 /*                CALL QUIT;                                        */
 /* EXTERNAL     NONE                                                */
 /* EXIT         RETURNS TO THE TERMINATION LABEL OF THE MAIN        */
 /*              PROCEDURE                                           */
 QUITTER: PROC;
 GO TO FINN;
 END QUITTER;
 % PAGE;
 /* PROCEDURE    MSGWTR                                              */
 /* FUNCTION     TO WRITE DIAGNOSTICS TO THE LISTING AND TERMINAL    */
 /*              FILES. THE TEXT IN ERROR, AND POSSIBLY A SCAN       */
 /*              POSITION INDICATOR ARE WRITTEN TO THE TERMINAL      */
 /*              BEFORE THE MESSAGE TEXT.                            */
 MSGWTR: PROC(ID,RC,MSG,GEND,MAC#,SOURCEPTR,POSITION);
 DCL ID CHAR(8),
     RC FIXED BIN,
     MSG CHAR(*) VAR,
     GEND BIT(1) ALIGNED,
     MAC# FIXED BIN,
     SOURCEPTR POINTER,
     POSITION FIXED BIN;
 DCL LASTNOTED STATIC FIXED BIN INIT(0);
 DCL CODE CHAR(3);
 DCL 1 SOURCE BASED(SOURCEPTR),
     2 TEXTLEN FIXED BIN,
     2 TEXT CHAR(1 REFER(SOURCE.TEXTLEN));
 DCL STMTID FIXED(8);
 DCL J FIXED BIN;
          CALL ECHOSPILL;
          IF ^NOTED THEN DO;
              PUT FILE(LISTING) SKIP;
              REPRINT,NOTED='1'B;
          END;
          IF MAC#^=LASTNOTED × I^=0 THEN DO;
             LASTNOTED=MAC#;
             PUT SKIP(2);
             IF SOURCEPTR^=NULL THEN DO;
                DO I=1 TO LENGTH(TEXT) BY 71;
                   PUT EDIT(SUBSTR(TEXT,I))(COL(6),A(71));
                   IF POSITION>=I & POSITION<I+71 THEN
                      PUT EDIT('?')(COL(6+POSITION-I),A(1));
                END;
                PUT SKIP;
             END;
          END;
          PUT STRING(CODE) EDIT(RC)(F(3));
          SELECT(CODE);
             WHEN('  0') CODE='  I';
             WHEN('  4') CODE='  W';
             WHEN('  8') CODE='  E';
             WHEN(' 12') CODE='  S';
             OTHER;
          END;
          IF NUMSW THEN
             STMTID=STMTNUM;
             ELSE STMTID=STMTNUM/1000;
          DO LISTFILE=LISTING,SYSPRINT;
             PUT FILE(LISTFILE) EDIT(ID,CODE,STMTID)(SKIP,A,X(1),
                 A,X(1),F(8));
             IF GEND THEN
                 PUT FILE(LISTFILE) EDIT('G')(A(1));
             I=1;
             DO WHILE(I+56<=LENGTH(MSG));
                DO J=I+56 TO I BY -1 WHILE(SUBSTR(MSG,J,1)^=' ');
                END;
                J=J-I;
                IF J=0 THEN J=56;
                PUT FILE(LISTFILE) EDIT(SUBSTR(MSG,I,J))(COL(24),A);
                I=I+J;
                IF SUBSTR(MSG,I,1)=' ' THEN I=I+1;
             END;
             PUT FILE(LISTFILE) EDIT(SUBSTR(MSG,I),'.')(COL(24),A,A);
          END;
          MAXRETC=MAX(MAXRETC,RC);
 END MSGWTR;
 % PAGE;
 /* PROCEDURE:   GENNER                                              */
 /* FUNCTION:    GENERATE ONE CARD IMAGE IN SYSPUNCH DATASET AND     */
 /*              PRINT IT ON LISTING  UNDER CONTROL OF THE CURRENT   */
 /*              'PRINT GEN' OPTION.                                 */
 /* LINKAGE:     THIS ROUTINE IS KNOWN IN THE TCA UNDER THE ALIAS    */
 /*              'GEN'. A MACRO LINKS BY                             */
 /*                   CALL GEN(CARDIMAGE);                           */
 GENNER:PROC(OUTCARD);
 DCL OUTCARD CHAR(*) VAR;
 DCL MYCARD CHAR(80) INIT(' ');
 DCL MYTEXT CHAR(71) DEFINED MYCARD POS(2);
 DCL GENCTR FIXED BIN INIT(0);
 DCL GENSTATE FIXED BIN;
 DCL INPOS FIXED BIN;
 DCL LL FIXED BIN;
 DCL STMTSTART FIXED BIN;
 DCL START_COL FIXED BIN;
 DCL I FIXED BIN;
         IF ^GENON THEN RETURN;
         CALL ECHOSPILL;
         CALL COPYSPILL;
         REPRINT='1'B;
         IF LANGUAGE='BAL'
              THEN
                   DO;
                   MYCARD=OUTCARD;
                   IF LENGTH(OUTCARD)>71
                        THEN
                             SUBSTR(MYCARD,72,1)='*';
                   IF SUBSTR(MYCARD,1,1)^='*' THEN
                      GENCTR,STMTCTR=STMTCTR+1;
                   CALL CARDPUT;
                   GENCTR=0;
                        DO I=72 TO LENGTH(OUTCARD) BY 56;
                        SUBSTR(MYCARD,16)=SUBSTR(OUTCARD,I);
                        IF LENGTH(OUTCARD)>I+55
                             THEN
                                  SUBSTR(MYCARD,72,1)='*';
                        CALL CARDPUT;
                        END;
                   END;
              ELSE
                   DO;
         L=LENGTH(OUTCARD);
         START_COL=STMTCOL;
         MYCARD=' ';
         I=1;
         GENSTATE=RESET;
         DO WHILE(L>0);
            INPOS=2;
            LL=MIN(L,73-START_COL);
            SUBSTR(MYCARD,START_COL,LL)=SUBSTR(OUTCARD,I,LL);
            L=L-LL;
            I=I+LL;
            STMTSTART=0;
            DO UNTIL(GENSTATE^=EXIT);
               IF GENSTATE=EXIT THEN DO;
                  GENSTATE=RESET;
                  STMTSTART=0;
               END;
               CALL SCANLINE(MYCARD,INPOS,72,GENSTATE,STMTSTART,'1'B);
               IF STMTSTART^=0 THEN DO;
                  IF GENSTMT & SUBSTR(MYCARD,STMTSTART,1)^='%' &
                               SUBSTR(MYCARD,STMTSTART,1)^='/'
                     THEN DO;
                        STMTCTR=STMTCTR+1;
                        IF GENCTR=0 THEN
                           GENCTR=STMTCTR;
                  END;
                  GENSTMT=GENSTATE=EXIT;
               END;
            END;
            CALL CARDPUT;
            START_COL=2;
            GENCTR=0;
         END;
         IF ABS(GENSTATE)^=RESET & ABS(GENSTATE)^=SLASH THEN
            CALL ERR('INCOMPLETE GEN OUTPUT','GPPP020I',OUTCARD,I);
                   END;
 %SKIP(3);
 CARDPUT: PROC;
         IF GENAUTO
              THEN
                   DO;
                   WRITE FILE(AUTOFILE) FROM(MYCARD);
                   RETURN;
                   END;
         CALL LINEWTR(SUBSTR(MYCARD,1,1),MYTEXT,CARDNUM(INCL#),'1'B,0,
            GENCTR,PRINTON & PRINTGEN,'0'B);
         CALL PUNCHWTR(MYCARD,CARDNUM(INCL#));
         MYCARD=' ';
 END CARDPUT;
 END GENNER;
 % PAGE;
 /* PROCEDURE    GRAMMER                                             */
 /* FUNCTIONS    ADD A GRAMMAR TO THE SYSTEM, AND LINK TO IT         */
 /* LINKAGE      THIS ROUTINE IS KNOW IN THE TCA UNDER THE           */
 /*              ALIAS 'GRAMMAR'. IT IS INVOKED BY                   */
 /*                 CALL GRAMMAR(GRAMMARNAME);                       */
 /* EXTERNAL     CALLS PLILOAD TO LOAD THE GRAMMAR MODULE,           */
 /*              THEN BRANCHES TO ITS ENTRY POINT.                   */
 GRAMMER: PROC(GRAMMARNAME);
 DCL GRAMMARNAME CHAR(16);
 DCL PLILOAD ENTRY(CHAR(8),ENTRY,FIXED BIN);
 DCL RETC FIXED BIN;
 DCL ENTRYPT ENTRY VARIABLE;
 DCL ENTRYNAME CHAR(8);
 /* %INCLUDE GPPPSYM */
 %NOPRINT;
 %INCLUDE GPPPSYM;
 %PRINT;
         ENTRYNAME=SUBSTR(GRAMMARNAME,1,8);
         SYMBOLPTR=SCAN('%GRAMMARS%',LEVELPTR(0));
         SYMBOLTABPTR=ADDR(VARTEXT);
         SYMBOLPTR=SCAN(GRAMMARNAME,SYMBOLTABPTR);
         IF SYMBOLPTR ^= NULL THEN RETURN;
         SYMBOLPTR=NEWSYM(GRAMMARNAME,12,12,SYMBOLTABPTR);
         TYPENAME='GRAMMAR';
         CALL PLILOAD(ENTRYNAME,ENTRYPT,RETC);
         IF RETC>0 THEN
              CALL INTERR('GRAMMAR '××ENTRYNAME××' NOT LOADED',
                 'GPPP904I');
         CALL ENTRYPT(GPPPTCA);
 END;
 % PAGE;
 /* PROCEDURE    MACADDER                                            */
 /* FUNCTION     ADD A MACRO NAME AND ENTRY POINT TO THE TABLE       */
 /* LINKAGE      THIS ROUTINE IS KNOWN IN THE TCA UNDER THE          */
 /*              ALIAS 'MACADD'. IT IS CALLED BY                     */
 /*                   CALL MACADD(MACRONAME,MACROENTRY);             */
 MACADDER: PROC(MACNAME,ENTRYPT);
 DCL MACNAME CHAR(16);
 DCL ENTRYPT ENTRY;
 DCL ENTRYENTRY ENTRY BASED(ADDR(VARTEXT));
 /* %INCLUDE GPPPSYM */
 %NOPRINT;
 %INCLUDE GPPPSYM;
 %PRINT;
         SYMBOLPTR=SCAN('%MACROS%',LEVELPTR(0));
         SYMBOLTABPTR=ADDR(VARTEXT);
         SYMBOLPTR=SCAN(MACNAME,SYMBOLTABPTR);
         IF SYMBOLPTR ^= NULL THEN RETURN;
         SYMBOLPTR=NEWSYM(MACNAME,12,20,SYMBOLTABPTR);
         TYPENAME='MACRO';
         ENTRYENTRY=ENTRYPT;
         RETURN;
 END;
 % PAGE;
 /* PROCEDURE    NUMBERS                                            */
 /* FUNCTION     CONVERT A STRING TO AN INTEGER, WRITING AN ERROR   */
 /*              MESSAGE IF THE CONVERSION FAILS.                   */
 /* LINKAGE      KNOWN IN THE TCA BY THE ALIAS NUMBER               */
 /*    I=NUMBER(STR,LABEL);                                         */
 /*              WHERE STR IS THE STRING TO CONVERT,                */
 /*              LABEL IS THE NAME TO GIVE IT IN THE ERROR MESSAGE  */
 /*              I IS THE INTEGER VALUE OF THE STRING OR ZERO       */
 NUMBERS:PROC(STRING,WORD) RETURNS(FIXED BIN);
 DCL STRING CHAR(*) VAR;
 DCL WORD CHAR(*) VAR;
 DCL NUM FIXED BIN;
 IF STRING='' THEN GO TO BADNUM;
 ON CONVERSION
         BEGIN;
         CALL NOTE(12,'INVALID NUMBER '''××ONSOURCE××''' FOR '××WORD,
                   'GPPP014I');
         GO TO BADNUM;
         END;
 GET STRING(STRING) EDIT(NUM)(F(LENGTH(STRING)));
 RETURN(NUM);
 BADNUM:
         RETURN(0);
 END NUMBERS;
 % SKIP(3);
 /* PROCEDURE    IMAGES                                             */
 /* FUNCTION     TO PRODUCE A COMPACT CHARACTER-STRING              */
 /*              REPRESENTATION OF AN INTEGER.                      */
 /* LINKAGE      KNOWN IN THE TCA UNDER THE ALIAS IMAGE             */
 /*    STR=IMAGE(I);                                                */
 /*              WHERE I IS THE INTEGER TO CONVERT                  */
 IMAGES: PROC(NUMBER) RETURNS(CHAR(5) VAR);
 DCL NUMBER FIXED BIN;
 DCL STRING PIC'(4)Z9';
         STRING=NUMBER;
         I=VERIFY(STRING,' ');
         RETURN(SUBSTR(STRING,I));
 END IMAGES;
 % SKIP(3);
 /* PROCEDURE    COUNT                                               */
 /* FUNCTION     RETURN A UNIQUE INTEGER IN CHARACTER FORM (LIKE PL/I*/
 /*              PREPROCESSOR COUNTER BUILTIN)                       */
 /* LINKAGE      KNOWN IN THE TCA AS COUNTER, CALLED BY              */
 /*                    X=COUNTER                                     */
 COUNT: PROC RETURNS(PIC'(5)9');
 DCL COUNTER PIC'(5)9' STATIC INIT(0);
         COUNTER=COUNTER+1;
         RETURN(COUNTER);
 END COUNT;
 % PAGE;
 /* PROCEDURE    LONGHAND                                            */
 /* FUNCTION     EXPAND SHORTHAND CHARACTER EXPRESSIONS (SUCH AS     */
 /*              A<B> FOR 'A'××B) TO THEIR NORMAL FORM               */
 /* LINKAGE      KNOWN IN THE TCA AS EXPAND, CALLED BY               */
 /*                    OUTSTR=EXPAND(INSTR);                         */
 LONGHAND: PROC(TEXT) RETURNS(CHAR(1536) VAR);
 DCL TEXT CHAR(*) VAR;
 DCL OUTSTRING CHAR(1536) INIT(' ') STATIC,
     OUTSTR(1536) CHAR(1) DEF OUTSTRING;
 DCL (I,J) FIXED BIN;
 DCL BRACK BIT ALIGNED INIT('0'B);
 IF SUBSTR(TEXT,1,1)='<'
         THEN
              DO;
              I=2;
              J=1;
              BRACK='1'B;
              END;
         ELSE
              DO;
              I=1;
              J=2;
              OUTSTR(1)='''';
              END;
         DO I=I TO LENGTH(TEXT);
              SELECT (SUBSTR(TEXT,I,1));
                   WHEN ('''') IF ^BRACK THEN
                        DO;
                        OUTSTR(J),OUTSTR(J+1)='''';
                        J=J+1;
                        END;
                          ELSE OUTSTR(J)='''';
                   WHEN ('<')
                        DO;
                        OUTSTR(J)='''';
                        OUTSTR(J+1),OUTSTR(J+2)='×';
                        J=J+2;
                        BRACK='1'B;
                        END;
                   WHEN ('>')
                        DO;
                        OUTSTR(J),OUTSTR(J+1)='×';
                        OUTSTR(J+2)='''';
                        J=J+2;
                        BRACK='0'B;
                        END;
                   OTHERWISE
                        OUTSTR(J)=SUBSTR(TEXT,I,1);
              END;
         J=J+1;
         END;
 IF SUBSTR(TEXT,I-1,1)='>'
         THEN
              DO;
              J=J-4;
              END;
         ELSE
              OUTSTR(J)='''';
 RETURN(SUBSTR(OUTSTRING,1,J));
 END LONGHAND;
 % PAGE;
 /* PROCEDURE    STMTREADER                                          */
 /* FUNCTION     READ IN ONE STATEMENT OR BLOCK OF COMMENTS. THE     */
 /*              STATEMENT IS ECHOED TO THE LISTING FILE AS IT IS    */
 /*              ASSEMBLED.                                          */
 STMTREADER: PROC(STRING,STMTCOL,NOMAC);
 DCL STRING CHAR(*) VAR;
 DCL STMTCOL FIXED BIN;
 DCL NOMAC BIT(1) ALIGNED;
 DCL START_COL FIXED BIN;
 DCL EOF BIT ALIGNED;
 DCL EMPTY BIT(1) ALIGNED;
 DCL FIRSTLINE BIT ALIGNED;
 DCL CONTINUE BIT ALIGNED STATIC INIT('0'B);
 STRING='';
 NOMAC='0'B;
         SCANSTATE=RESET;
         EMPTY,ONLYCOM='1'B;
         LINEX=0;
 RESTART:
         START_COL=READPOS(INCL#);
         IF START_COL>RMARG THEN
            GO TO NEWCARD;
         IF SUBSTR(CARDBUF(INCL#),START_COL+1,RMARG-START_COL)='' THEN
            GO TO NEWCARD;
         LINEX=1;
         SEQ#TAB(LINEX)=CARDNUM(INCL#);
         IF BLKGEN THEN GO TO NEWCARD;
 FINDSTMT:
         FIRSTLINE=STRING='';
         IF FIRSTLINE THEN
            STMTCOL=0;
            ELSE LCARRCTL=' ';
         I=START_COL;
         CALL SCANLINE(CARDBUF(INCL#),I,RMARG,SCANSTATE,STMTCOL,EMPTY);
         IF FIRSTLINE & STMTCOL^=0 THEN
            STRING=SUBSTR(CARDBUF(INCL#),STMTCOL,I-STMTCOL);
            ELSE
               STRING=STRING××
                SUBSTR(CARDBUF(INCL#),START_COL,I-START_COL);
         IF SCANSTATE=EXIT THEN GO TO ENDSTMT;
         IF STRING='' & START_COL>2 THEN
            STRING='';
         IF EMPTY & SCANSTATE=RESET THEN DO;
            NOMAC='1'B;
            GO TO ENDSTMT;
         END;
         IF ONLYCOM THEN
            IF LANGUAGE='PLI' THEN DO;
               UNCOUNTED=^GENON × SUBSTR(CARDBUF(INCL#),STMTCOL,1)='%' ×
                  SUBSTR(CARDBUF(INCL#),STMTCOL,1)=SELECT;
               IF ^UNCOUNTED & ^EMPTY THEN STMTCTR=STMTCTR+1;
            END;
               ELSE UNCOUNTED='1'B;
         CALL ECHOLINE(CARDBUF(INCL#),START_COL,72,LCARRCTL,
            ^UNCOUNTED & ^EMPTY & ONLYCOM);
         ONLYCOM=EMPTY;
         IF LANGUAGE = 'UTIL'
            THEN DO;
 LASTSCAN:
               DO I=LENGTH(STRING) TO 1 BY -1;
               IF SUBSTR(STRING,I,1)='-'
                  THEN
                     DO;
                     SUBSTR(STRING,I,1)=' ';
                     LEAVE LASTSCAN;
                     END;
               IF SUBSTR(STRING,I,1)^=' '
                  THEN
                     DO;
                     STRING=STRING××';';
                     SUBSTR(CARDBUF(INCL#),72,1)=';';
                     LEAVE LASTSCAN;
                     END;
               END LASTSCAN;
               PUT FILE(SYSPRINT) EDIT(CARDBUF(INCL#))
                   (COL(1),X(20),A(80));
               IF SUBSTR(CARDBUF(INCL#),72,1)=';' THEN GO TO ENDSTMT;
               END;
 NEWCARD:
         CALL CARDREADER(EOF);
         IF EOF THEN DO;
            IF STRING='' THEN
               IF INCL#<0 THEN GO TO FINN;
                 ELSE GO TO RESTART;
            CALL ERR('UNEXPECTED EOF','GPPP021I',STRING,LENGTH(STRING));
            RETURN;
         END;
         LINEX=LINEX+1;
         SEQTAB(LINEX)=SUBSTR(CARDBUF(INCL#),73,8);
         IF LINEX=1 THEN
            STMTNUM=SEQ#TAB(1);
         START_COL,READPOS(INCL#)=2;
         IF STRING='' THEN PCARRCTL=LCARRCTL;
         IF LANGUAGE='BAL' & STRING='' THEN DO;
            UNCOUNTED=CONTINUE × SUBSTR(CARDBUF(INCL#),1,1)='*';
            IF UNCOUNTED × (SELECT^=' ' &
               SUBSTR(CARDBUF(INCL#),1,1)^=SELECT)
                  THEN GO TO PASSCARD;
            END;
         IF ^BLKGEN THEN GO TO FINDSTMT;
         UNCOUNTED=CONTINUE × SUBSTR(CARDBUF(INCL#),1,1)='*';
         IF ^UNCOUNTED THEN DO;
            I=INDEX(CARDBUF(INCL#),' @ENDGEN');
            IF I=0 THEN
              GO TO PASSCARD;
            IF SUBSTR(CARDBUF(INCL#),1,I-1)^=' ' ×
               (SUBSTR(CARDBUF(INCL#),I+8,65-I)^=' ' &
                SUBSTR(CARDBUF(INCL#),I+8,65-I)^=';') THEN
                  GO TO PASSCARD;
            STRING='@ENDGEN;';
         END;
            ELSE
 PASSCARD:
            STRING=SUBSTR(CARDBUF(INCL#),2,71);
         READPOS(INCL#)=RMARG+1;
         NOMAC='1'B;
         ONLYCOM='0'B;
         IF ^GENON THEN UNCOUNTED='1'B;
         IF ^UNCOUNTED THEN STMTCTR=STMTCTR+1;
         CALL ECHOLINE(CARDBUF(INCL#),2,72,LCARRCTL,^UNCOUNTED);
         CONTINUE=SUBSTR(CARDBUF(INCL#),72,1)^=' ';
         CARDNUM(INCL#)=SEQ#TAB(LINEX);
         STMTCOL=2;
         LINEX=1;
         RETURN;
 ENDSTMT:
         I=MIN(I,RMARG+1);
         IF LANGUAGE='BAL' & SELECT^=' ' THEN
            READPOS(INCL#)=72;
            ELSE READPOS(INCL#)=I;
         CARDNUM(INCL#)=SEQ#TAB(LINEX);
         IF STMTCOL=0
            THEN STMTCOL=START_COL;
         LINEX=1;
         IF ONLYCOM THEN
            IF LANGUAGE='PLI' THEN DO;
               UNCOUNTED=^GENON × SUBSTR(CARDBUF(INCL#),STMTCOL,1)='%' ×
                  SUBSTR(CARDBUF(INCL#),STMTCOL,1)=SELECT;
               IF ^UNCOUNTED & ^EMPTY THEN STMTCTR=STMTCTR+1;
            END;
               ELSE UNCOUNTED='1'B;
         CALL ECHOLINE(CARDBUF(INCL#),START_COL,I-1,LCARRCTL,
            ^UNCOUNTED & ^EMPTY & ONLYCOM);
         ONLYCOM=EMPTY;
 END STMTREADER;
 % PAGE;
 /* PROCEDURE    ECHOLINE                                            */
 /* FUNCTION     TO BUFFER A STATEMENT OR STATEMENT SEGMENT FOR      */
 /*              ECHOING TO THE LISTING FILE                         */
 ECHOLINE: PROC(CARD,START_COL,STOP_COL,CARRCTL,COUNT);
 DCL CARD CHAR(80),
     (START_COL,STOP_COL) FIXED BIN,
     CARRCTL CHAR(1),
     COUNT BIT;
 DCL ECHOBUF CHAR(71) INIT(' ') STATIC,
     ECHOPOS FIXED BIN INIT(1) STATIC,
     ECHOSEQ# PIC'(8)9' STATIC,
     ECHOSEQ CHAR(8) DEFINED ECHOSEQ#,
     ECHOCTL CHAR(1) STATIC INIT(' '),
     ECHONEST FIXED BIN STATIC INIT(0),
     ECHOSTMT FIXED BIN STATIC INIT(0),
     ECHOPRINT BIT STATIC INIT('1'B),
     ECHOGEN BIT STATIC;
         IF START_COL<ECHOPOS THEN
            CALL SPILL;
         L=STOP_COL-START_COL+1;
         SUBSTR(ECHOBUF,START_COL-1,L)=SUBSTR(CARD,START_COL,L);
         ECHOSEQ=SUBSTR(CARD,73);
         IF GENON & COUNT & ECHOSTMT=0 THEN ECHOSTMT=STMTCTR;
         IF ECHOPOS=1 THEN DO;
            ECHOPRINT=PRINTON;
            ECHOGEN=GENON;
         END;
         ECHOPOS=STOP_COL+1;
         ECHONEST=INCL#;
         IF ECHOCTL=' ' THEN ECHOCTL=CARRCTL;
         CARRCTL=' ';
         RETURN;
 /* ENTRY        ECHOSPILL                                         */
 /* FUNCTION     TO FORCE THE PRINTING OF ANY CURRENTLY BUFFERED   */
 /*              ECHO TEXT.                                        */
 ECHOSPILL: ENTRY;
         IF ECHOPOS^=1 THEN
            CALL SPILL;
         RETURN;
 /* ENTRY        KILLSTMT                                           */
 /* FUNCTION     TO INDICATE THAT THE MOST RECENTLY ECHOED          */
 /*              STATEMENT WAS A MACRO CALL RATHER THAN AN OUTPUT   */
 /*              LANGUAGE STATEMENT (TO SUPPRESS PRINTING OF A      */
 /*              STATEMENT NUMBER IF POSSIBLE)                      */
 KILLSTMT: ENTRY;
         IF ECHOSTMT=STMTCTR THEN ECHOSTMT=0;
 SPILL: PROC;
         CALL LINEWTR(ECHOCTL,ECHOBUF,ECHOSEQ#,'0'B,ECHONEST,
            ECHOSTMT,ECHOPRINT,^ECHOGEN);
         ECHOBUF=' ';
         ECHOPOS=1;
         ECHOCTL=' ';
         ECHOSTMT=0;
 END SPILL;
 END ECHOLINE;
 %PAGE;
 /* PROCEDURE    COPYSTMT                                            */
 /* FUNCTION     TO COPY AN OUTPUT LANGUAGE STATEMENT TO THE PUNCH   */
 /*              FILE                                                */
 COPYSTMT: PROC(STRING,START_COL,LEN);
 DCL STRING CHAR(*) VAR,
     START_COL FIXED BIN,
     LEN FIXED BIN;
 DCL COPYBUF CHAR(80) INIT(' ') STATIC,
     COPYPOS FIXED BIN INIT(2) STATIC,
     COPYSEQ PIC'(8)9' STATIC;
         IF ^GENON THEN DO;
            START_COL=MOD(START_COL+LEN-2,71)+2;
            RETURN;
         END;
         I=1;
         IF START_COL<COPYPOS THEN
            CALL SPILL;
         IF COPYPOS=2 THEN DO;
            COPYBUF=PCARRCTL;
            PCARRCTL=' ';
            COPYSEQ=SEQ#TAB(LINEX);
            SEQ#TAB(LINEX)=SEQ#TAB(LINEX)+INCREMENT;
         END;
         DO WHILE(LEN>73-START_COL);
            SUBSTR(COPYBUF,START_COL,73-START_COL)=
                  SUBSTR(STRING,I,73-START_COL);
            LEN=LEN-(73-START_COL);
            I=I+(73-START_COL);
            CALL SPILL;
            LINEX=LINEX+1;
            COPYSEQ=SEQ#TAB(LINEX);
            SEQ#TAB(LINEX)=SEQ#TAB(LINEX)+INCREMENT;
            COPYBUF=' ';
            START_COL=2;
         END;
         IF START_COL=2 & LEN<71 & SUBSTR(STRING,I,LEN)=' '
            THEN DO;
               START_COL=START_COL+LEN;
               SEQ#TAB(LINEX)=SEQ#TAB(LINEX)-INCREMENT;
               RETURN;
         END;
         SUBSTR(COPYBUF,START_COL,LEN)=SUBSTR(STRING,I,LEN);
         COPYPOS,START_COL=START_COL+LEN;
         IF START_COL=73 THEN
            START_COL=2;
         RETURN;
 /* ENTRY        COPYSPILL                                           */
 /* FUNCTION     TO FORCE THE PUNCHING OF ANY CURRENTLY BUFFERED     */
 /*              COPIED STATEWMENT TEXT.                             */
 COPYSPILL: ENTRY;
         IF COPYPOS>2 THEN
            CALL SPILL;
         RETURN;
 SPILL: PROC;
         CALL PUNCHWTR(COPYBUF,COPYSEQ);
         COPYPOS=2;
 END SPILL;
 END COPYSTMT;
 %PAGE;
 /* PROCEDURE    ANNOTE                                              */
 /* FUNCTION     TO COPY A MACRO CALL TO THE PUNCH FILE AS A         */
 /*              COMMENT. IN PL/I, ANY COMMENT DELIMITERS IN THE     */
 /*              CALL ARE REPLACED BY <* AND *> TO PREVENT ERRORS.   */
 ANNOTE: PROC(STRING,START_COL);
 DCL STRING CHAR(*) VAR;
 DCL START_COL FIXED BIN;
 DCL CURCOL FIXED BIN INIT(START_COL);
 DCL NOTELINE CHAR(72) STATIC INIT(' ');
         CALL COPYSPILL;
         IF LANGUAGE='PLI' THEN DO;
            DO I=2 TO LENGTH(STRING)-1;
               IF SUBSTR(STRING,I,1)='*'
                  THEN DO;
                     IF SUBSTR(STRING,I-1,1)='/' THEN
                        SUBSTR(STRING,I-1,1)='<';
                     IF SUBSTR(STRING,I+1,1)='/' THEN
                        SUBSTR(STRING,I+1,1)='>';
                  END;
               END;
            NOTELINE=' /*';
            IF CURCOL<4 THEN DO;
               IF SUBSTR(STRING,1,4-CURCOL)=' ' THEN
                  DO;
                  STRING=SUBSTR(STRING,5-CURCOL);
                  START_COL,CURCOL=4;
               END;
                  ELSE
                     CALL SPILL(0);
            END;
         END;
         L=LENGTH(STRING);
         I=1;
         DO WHILE(L>73-CURCOL);
            SUBSTR(NOTELINE,CURCOL,73-CURCOL)=
                  SUBSTR(STRING,I,73-CURCOL);
            I=I+(73-CURCOL);
            L=L-(73-CURCOL);
            CURCOL=2;
            CALL SPILL(1);
         END;
         SUBSTR(NOTELINE,CURCOL,L)=SUBSTR(STRING,I,L);
         IF SUBSTR(NOTELINE,CURCOL+L-1,1)=';' THEN
            SUBSTR(NOTELINE,CURCOL+L-1,1)=' ';
         IF LANGUAGE='PLI' THEN DO;
            IF SUBSTR(NOTELINE,70,3)^=' ' THEN
               CALL SPILL(0);
            SUBSTR(NOTELINE,70,3)='*/ ';
         END;
         CALL SPILL(0);
 SPILL: PROC(INCR);
 DCL INCR FIXED BIN;
         IF LANGUAGE='BAL' THEN
            SUBSTR(NOTELINE,1,1)='*';
            ELSE DO;
               SUBSTR(NOTELINE,1,1)=PCARRCTL;
               PCARRCTL=' ';
            END;
         CALL PUNCHWTR(NOTELINE,SEQ#TAB(LINEX));
         LINEX=LINEX+INCR;
         NOTELINE=' ';
 END SPILL;
 END ANNOTE;
 % PAGE;
 /* PROCEDURE    CARDREADER                                          */
 /* FUNCTION     TO READ A CARD FROM INPUT OR SYSLIB                 */
 CARDREADER: PROC(EOF);
 DCL EOF BIT(1) ALIGNED;
 DCL ARTSEQ PIC'(8)9' STATIC INIT(0);
 DCL DUMMY FIXED(8);
 BEGIN:
         EOF='0'B;
         IF INCL#=0 THEN
              IF ^ANTIC THEN DO;
                  ON ENDFILE(INPUT) GO TO ENDED_ALL;
                  READ FILE(INPUT) INTO(CARDBUF(0));
           END;
           ELSE ANTIC='0'B;
         ELSE
              DO;
              REC#=REC#+1;
              IF REC#*80>RECSIZE THEN
                   DO;
                   REQUEST='0'B;
                   CALL SYSLIBR(SYSLBBLK);
                   IF ERRORS THEN
                        DO;
                        CALL POPMEM;
                        CALL ECHOSPILL;
                        CALL COPYSPILL;
                        REPRINT='1'B;
                        GO TO ENDED;
                        END;
                   REC#=1;
                   END;
              CARDBUF(INCL#)=BUFF(REC#);
              END;
         IF LANGUAGE='UTIL'
            THEN
               IF SUBSTR(CARDBUF(INCL#),1,72)='//'
                  THEN
                     CARDBUF(INCL#)=' %ENDJOB% ;';
            ELSE
               IF SUBSTR(CARDBUF(INCL#),1,2)='//'
                  THEN
                     GOTO BEGIN;
         LCARRCTL=SUBSTR(CARDBUF(INCL#),1,1);
         CALL ECHOSPILL;
         READPOS(INCL#)=1;
         REPRINT='0'B;
         IF NUMSW THEN DO;
            ON CONVERSION BEGIN;
               SUBSTR(CARDBUF(INCL#),73,8)=(8)'0';
               GO TO SEQDONE;
            END;
            GET STRING(CARDBUF(INCL#))EDIT(DUMMY)
                      (X(72),P'(7)Z9');
         END;
            ELSE DO;
               ARTSEQ=ARTSEQ+1000;
               SUBSTR(CARDBUF(INCL#),73,8)=ARTSEQ;
            END;
 SEQDONE:
        RETURN;
 ENDED_ALL:
        CALL ECHOSPILL;
        CALL COPYSPILL;
        INCL#=-1;
 ENDED:
        EOF='1'B;
        RETURN;
 END CARDREADER;
 % PAGE;
 /* PROCEDURE    PUSHMEM                                             */
 /* FUNCTION     TO ADD A NEW MEMBER TO THE SYSLIB INPUT STACK       */
 PUSHMEM: PROC(MEMBER) RETURNS(BIT ALIGNED);
 DCL MEMBER CHAR(8);
 DCL SUCCESS BIT ALIGNED;
 TTRSAVE(INCL#)=TTR;
 RECSAVE(INCL#)=REC#;
 PRINTSAVE(INCL#)=PRINTON;
 PGENSAVE(INCL#)=PRINTGEN;
 INCL#=INCL#+1;
 MEMNAME(INCL#)=MEMBER;
 IF INCL#>10 THEN CALL INTERR('TOO MANY NESTED INCLUDES','GPPP905I');
 REQUEST=REQMEM;
 REC#=0;
 CALL SYSLIBR(SYSLBBLK);
 IF ERRORS&ERROPN THEN CALL INTERR('SYSLIB OPEN FAILURE','GPPP906I');
 IF ERRORS THEN
         DO;
         CALL NOTE(8,'MEMBER '××MEMBER××' NOT FOUND','GPPP102I');
         CALL POPMEM;
         SUCCESS='0'B;
         END;
           ELSE SUCCESS='1'B;
 RETURN(SUCCESS);
 END PUSHMEM;
 % PAGE;
 /* PROCEDURE    POPMEM                                              */
 /* FUNCTION     TO REMOVE A MEMBER FROM THE SYSLIB INPUT STACK      */
 POPMEM: PROC;
              INCL#=INCL#-1;
              IF INCL#^=0 THEN DO;
                  TTR=TTRSAVE(INCL#);
                  REC#=RECSAVE(INCL#);
                  REQUEST=REQREC;
                  CALL SYSLIBR(SYSLBBLK);
             IF ERRORS THEN CALL INTERR('SYSLIB READ ERROR','GPPP907I');
                  END;
              PRINTON=PRINTSAVE(INCL#);
              PRINTGEN=PGENSAVE(INCL#);
              RETURN;
 END POPMEM;
 % PAGE;
 /* PROCEDURE    LINEWTR                                             */
 /* FUNCTION     TO WRITE A NON-MESSAGE (INPUT OR GENERATED) LINE    */
 /*              TO THE LISTING FILE                                 */
 LINEWTR: PROC(CARRCTL,TEXT,SEQ#,GEND,NEST,STMT#,PRINTSW,GENOFF);
 DCL CARRCTL CHAR(1),
     TEXT CHAR(71),
     SEQ# PIC'(8)9',
     GEND BIT(1) ALIGNED,
     NEST FIXED BIN,
     STMT# FIXED BIN,
     PRINTSW BIT ALIGNED,
     GENOFF BIT ALIGNED;
 DCL NEXTCTR FIXED BIN STATIC INIT(1),
     LEVELCTR(0:10) STATIC;
 DCL OUTLINE CHAR(124) INIT(' '),
     INCLEVEL PIC'Z9' DEF OUTLINE POS(7),
     STMT PIC'ZZZ9' DEF OUTLINE POS(11),
     LNUM PIC'ZZZZZ9' DEF OUTLINE POS(16),
     LNUMS CHAR(6) DEF OUTLINE POS(16),
     GENCHAR CHAR(1) DEF OUTLINE POS(22),
     OCARRCTL CHAR(1) DEF OUTLINE POS(23),
     OTEXT CHAR(71) DEF OUTLINE POS(24),
     OSEQ# CHAR(8) DEF OUTLINE POS(96),
     INCHAR CHAR(1) DEF OUTLINE POS(108),
     SOURCE CHAR(16) DEF OUTLINE POS(109);
         IF PRINTSW THEN DO;
            IF NOTED THEN DO;
               PUT FILE(LISTING) SKIP;
               NOTED='0'B;
            END;
            IF LANGUAGE='PLI' THEN DO;
               OCARRCTL=' ';
               SELECT(CARRCTL);
                  WHEN('1') SIGNAL ENDPAGE(LISTING);
                  WHEN('0') PUT FILE(LISTING) SKIP(2);
                  WHEN('-') PUT FILE(LISTING) SKIP(3);
                  OTHER DO;
                     PUT FILE(LISTING) SKIP;
                     OCARRCTL=CARRCTL;
                  END;
               END;
            END;
               ELSE DO;
                  PUT FILE(LISTING) SKIP;
                  OCARRCTL=CARRCTL;
            END;
         IF EJECT THEN
            SIGNAL ENDPAGE(LISTING);
         END;
         CARRCTL=' ';
         IF GEND THEN DO;
            I=NEXTCTR;
            NEXTCTR=NEXTCTR+1;
         END;
            ELSE IF REPRINT & ^GEND THEN
               I=LEVELCTR(NEST);
            ELSE DO;
               I,LEVELCTR(NEST)=NEXTCTR;
               NEXTCTR=NEXTCTR+1;
            END;
         IF ^PRINTSW THEN RETURN;
         IF NEST>0 THEN
            INCLEVEL=NEST;
         IF STMT#^=0 THEN
            STMT=STMT#;
         LNUM=I;
         IF REPRINT & ^GEND THEN
            LNUMS=TRANSLATE(LNUMS,'-',' ');
         IF GEND
            THEN GENCHAR='+';
            ELSE IF GENOFF THEN
               GENCHAR='-';
         OTEXT=TEXT;
         OSEQ#=SEQ#;
         IF GEND THEN
            SOURCE=MACNAME;
         ELSE
            IF NEST>0 THEN DO;
               INCHAR='.';
               SOURCE=MEMNAME(NEST);
         END;
         PUT FILE(LISTING) EDIT(OUTLINE)(COL(1),A);
 END LINEWTR;
 %PAGE;
 /* PROCEDURE    PUNCHWTR                                            */
 /* FUNCTION     TO WRITE A CARD TO SYSPUNCH                         */
 PUNCHWTR: PROC(CARD,SEQFIELD);
 DCL CARD CHAR(80);
 DCL SEQFIELD PIC'(8)9';
         SUBSTR(CARD,73)=SEQFIELD;
         WRITE FILE(SYSPUN) FROM(CARD);
         SEQFIELD=SEQFIELD+INCREMENT;
 END PUNCHWTR;
 % PAGE;
 /* PROCEDURE    ELSESCAN                                            */
 /* FUNCTION     TO SCAN AN APPARENT ELSE STATEMENT TO DETERMINE     */
 /*              WHETHER IT IS IN FACT AN ELSE STATEMENT.            */
 /*              EXAMPLE STATEMENTS:                                 */
 /*                 ELSE X=Y;                                        */
 /*                 ELSE->X=Y;
 /*                 ELSE(2)=Y;                                       */
 /*                 ELSE: X=Y;                                       */
 /*                 ELSE (SIZE): X=Y;                                */
 ELSESCAN: PROC(STRING,LOC,CONTINUE);
 DCL STRING CHAR(*) VAR,
     LOC FIXED BIN,
     CONTINUE BIT ALIGNED;
 DCL NEXTWORD CHAR(256) VAR;
 DCL POS FIXED BIN;
 DCL RETCODE FIXED BIN;
 POS=LOC;
 CONTINUE='1'B;
 NEXTWORD=GETTOKEN(STRING,POS,RETCODE);
 IF NEXTWORD=':' THEN LOC=POS;
   ELSE IF RETCODE=OBJECT THEN RETURN;
   ELSE IF SUBSTR(STRING,POS,1)^=')' THEN CONTINUE='0'B;
   ELSE DO;
     NEXTWORD=GETTOKEN(STRING,POS,RETCODE);
     IF NEXTWORD=':' THEN LOC=POS;
       ELSE CONTINUE='0'B;
   END;
   RETURN;
 END ELSESCAN;
 % SKIP(3);
 /* PROCEDURE    WHENSCAN                                            */
 /* FUNCTION     TO SCAN AN APPARENT WHEN STATEMENT TO DETERMINE     */
 /*              WHETHER IT IS IN FACT A WHEN STATEMENT.             */
 /*              EXAMPLE STATEMENTS:                                 */
 /*                 WHEN(2) X=Y;                                     */
 /*                 WHEN(2): X=Y;                                    */
 /*                 WHEN: X=Y;                                       */
 /*                 WHEN=X=Y;                                        */
 /*                 WHEN(2)->X=Y;                                    */
 WHENSCAN: PROC(STRING,LOC,CONTINUE);
 DCL STRING CHAR(*) VAR,
     LOC FIXED BIN,
     CONTINUE BIT ALIGNED;
 DCL NEXTWORD CHAR(256) VAR;
 DCL POS FIXED BIN;
 DCL RETCODE FIXED BIN;
 POS=LOC;
 CONTINUE='1'B;
 NEXTWORD=GETTOKEN(STRING,POS,RETCODE);
 IF NEXTWORD=':' THEN LOC=POS;
  ELSE IF RETCODE^=PSTRING × SUBSTR(STRING,POS,1)^=')' THEN
    CONTINUE='0'B;
    ELSE DO;
      LOC=POS;
      NEXTWORD=GETTOKEN(STRING,POS,RETCODE);
      IF NEXTWORD=':' THEN LOC=POS;
        ELSE IF RETCODE=OPERATOR × RETCODE>PSTRING ×
          (RETCODE=PSTRING & SUBSTR(STRING,POS,1)^=')') THEN
          CONTINUE='0'B;
  END;
  RETURN;
 END WHENSCAN;
 % SKIP(3);
 /* PROCEDURE    IFSCAN                                              */
 /* FUNCTION     TO SCAN AN APPARENT IF STATEMENT TO DETERMINE       */
 /*              WHETHER IT IS IN FACT AN IF STATEMENT.              */
 /*              EXAMPLE STATEMENTS:                                 */
 /*                 IF A=B THEN X=Y;                                 */
 /*                 IF (A=B) =THEN;                                  */
 /*                 IF (A)=B THEN X=Y;                               */
 /*                 IF(1): THEN: X=Y;                                */
 /*                 IF (A),THEN,X=Y;                                 */
 /*                 IF (A)->B=THEN;                                  */
 IFSCAN: PROC(STRING,LOC,CONTINUE);
 DCL STRING CHAR(*) VAR,
     LOC FIXED BIN,
     CONTINUE BIT ALIGNED;
 DCL NEXTWORD CHAR(256) VAR;
 DCL POS FIXED BIN;
 DCL RETCODE FIXED BIN;
 DCL CONDSTATE FIXED BIN;
 POS=LOC;
 CONTINUE='1'B;
 CONDSTATE=EXPR;
 IFLOOP:
 NEXTWORD=GETTOKEN(STRING,POS,RETCODE);
 IF RETCODE>QSTRING THEN CONTINUE='0'B;
   ELSE IF NEXTWORD=':' THEN LOC=POS;
   ELSE DO;
     CONDSTATE=EXPECT(CONDSTATE,RETCODE);
     IF CONDSTATE=NOGOOD THEN GO TO NOIF;
     IF CONDSTATE=LIT
        THEN DO;
           IF POS<LENGTH(STRING) &
              SUBSTR(STRING,POS+1,1)='B'
              THEN POS=POS+1;
           CONDSTATE=OPER;
        END;
     IF CONDSTATE^=EXIT THEN GO TO IFLOOP;
     IF NEXTWORD='THEN' THEN LOC=POS;
       ELSE
 NOIF:      CONTINUE='0'B;
   END;
 RETURN;
 END IFSCAN;
 % SKIP(3);
 /* PROCEDURE    ASGNSCAN                                            */
 /* FUNCTION     TO SCAN A POSSIBLE MACRO CALL TO DETERMINE          */
 /*              WHETHER IT IS IN FACT AN ASSIGNMENT STATEMENT.      */
 /*              EXAMPLE STATEMENTS:                                 */
 /*                 X(5)=Y;                                          */
 /*                 X(5) Y;                                          */
 /*                 X(5),Y,(A=B);                                    */
 /*                 X(5),Y,A=B;                                      */
 /*                 X(5): Y=Z;                                       */
 /*                 X(5) .Y =Z;                                      */
 /*                 X(5) .2+Y;                                       */
 ASGNSCAN: PROC(STRING,LOC,CONTINUE,NOMAC);
 DCL STRING CHAR(*) VAR,
     LOC FIXED BIN,
     CONTINUE BIT ALIGNED,
     NOMAC BIT ALIGNED;
 DCL NEXTWORD CHAR(256) VAR;
 DCL POS FIXED BIN;
 DCL RETCODE FIXED BIN;
 DCL CONDSTATE FIXED BIN;
 POS=LOC;
 CONTINUE='1'B; NOMAC='1'B;
 ASGNLOOP:
 NEXTWORD=GETTOKEN(STRING,POS,RETCODE);
 SELECT;
    WHEN(NEXTWORD=':') LOC=POS;
    WHEN(NEXTWORD='=') CONTINUE='0'B;
    WHEN(NEXTWORD='->',NEXTWORD='.',
         CONDSTATE=SUB & RETCODE=COMMA) DO;
       CONDSTATE=VAR;
       GO TO ASGNLOOP;
    END;
    WHEN(CONDSTATE=VAR & RETCODE=OBJECT,
         CONDSTATE=SUB & RETCODE=PSTRING)DO;
       CONDSTATE=SUB;
       GO TO ASGNLOOP;
    END;
    OTHERWISE CONTINUE,NOMAC='0'B;
 END;
 RETURN;
 END ASGNSCAN;
 % PAGE;
 /* PROCEDURE    GETLISTER                                           */
 /* FUNCTION     TO RETURN THE NEXT ITEM IN A LIST PARAMETER FOR A   */
 /*              MACRO PROCEDURE.                                    */
 /* LINKAGE      THIS ROUTINE IS KNOWN IN THE TCA UNDER THE ALIAS    */
 /*              'GETLIST'. IT IS INVOKED BY                         */
 /*              NEXTITEM=GETLIST(STRING,POSITION);                  */
 GETLISTER: PROC(STRING,POS) RETURNS(CHAR(1024) VAR);
 DCL STRING CHAR(*) VAR;
 DCL (POS,OLDPOS) FIXED BIN;
 DCL RETSTR CHAR(1024) VAR INIT('');
 DCL NEXTWORD CHAR(1024) VAR;
 DCL RETCODE FIXED BIN;
         DO UNTIL(RETCODE>=COMMA);
            OLDPOS=POS;
            NEXTWORD=GETWORD(STRING,POS,RETCODE);
            IF NEXTWORD^='' THEN
               IF POS-LENGTH(NEXTWORD)^=OLDPOS & RETSTR^='' THEN
                  RETSTR=RETSTR××' '××NEXTWORD;
                  ELSE RETSTR=RETSTR××NEXTWORD;
         END;
         IF RETCODE=SEMICOLON × RETCODE=GIBBERISH
            THEN DO;
               CALL ERR('ERROR IN SUBPARAMETER LIST','GPPP015I',STRING,
                        POS);
               RETURN('');
            END;
         RETURN(RETSTR);
 END GETLISTER;
 % PAGE;
 /* PROCEDURE    SCANLINE                                            */
 /* FUNCTION     ASSIST IN INPUT/OUTPUT SYNTAX SCAN (KEEPING TRACK   */
 /*              OF UNCLOSED QUOTES AND COMMENTS, AND DETECTING      */
 /*              STATEMENT END)                                      */
 SCANLINE: PROC(CARD,SCANPOS,RMARG,SCANSTATE,STMTSTART,EMPTY);
 DCL CARD CHAR(80),
     (SCANPOS,RMARG,SCANSTATE,STMTSTART) FIXED BIN,
     EMPTY BIT(1) ALIGNED;
 DCL CH CHAR(1);
 DCL IX FIXED BIN;
         DO SCANPOS=SCANPOS TO RMARG WHILE(SCANSTATE^=EXIT);
            CH=SUBSTR(CARD,SCANPOS,1);
            IF CH<'*' × CH>'"' THEN IX=0;
               ELSE IX=INDEX('''";/*',CH);
            SCANSTATE=NEXTSTATE(ABS(SCANSTATE),IX);
            IF EMPTY THEN
               SELECT(SCANSTATE);
                  WHEN(SLASH) STMTSTART=SCANPOS;
                  WHEN(COMMENT) STMTSTART=0;
                  WHEN(RESET) IF CH^=' ' & CH^='/' THEN
                     DO;
                     STMTSTART=SCANPOS;
                     EMPTY='0'B;
                     END;
                  WHEN(ASTERISK);
                  OTHER DO;
                     IF STMTSTART=0 THEN
                        STMTSTART=SCANPOS;
                     EMPTY='0'B;
                     END;
                  END;
               END;
 END SCANLINE;
 % PAGE;
 /* PROCEDURE    GETWORD                                             */
 /* FUNCTION     RETURN THE NEXT WORD OR SUBSTRING OF THE            */
 /*              CURRENT MACRO STATEMENT.                            */
 /* LINKAGE      NEXTWORD=GETWORD(STRING,POSITION,RETCODE);          */
 /*              WHERE                                               */
 /*              STRING IS A CHARACTER STRING CONTAINING A MACRO     */
 /*              STATEMENT                                           */
 /*              POSITION IS THE CHARACTER OFFSET IN STRING TO BEGIN */
 /*              THE SYNTAX SCAN.                                    */
 /*              NEXTWORD RECEIVES THE NEXT 'WORD' (DEFINED BELOW).  */
 /*              RETCODE RECEIVES THE RETURN CODE.                   */
 /* SYNTAX       A 'WORD' IS DELIMITED BY THE FOLLOWING:             */
 /*              1) IF THE FIRST NON-BLANK CHARACTER IS '(', THEN    */
 /*                 THE WORD ENDS WHEN A BALENCING ')' IS FOUND.     */
 /*              2) IF IT STARTS WITH DOUBLE QUOTE '"', THEN THE     */
 /*                 WORD ENDS WHEN ANOTHER DOUBLE QUOTE IS FOUND     */
 /*                 WHICH IS NOT IMMEDIATELY FOLLOWED BY A SECOND    */
 /*                 DOUBLE QUOTE. TWO ADJACENT DOUBLE QUOTES         */
 /*                 PRODUCE ONE DOUBLE QUOTE IN THE RETURNED         */
 /*                 STRING.                                          */
 /*              3) IF IT STARTS WITH A SINGLE QUOTE ('), THE WORD   */
 /*                 IS SCANNED THE SAME AS WITH DOUBLE QUOTE, BUT    */
 /*                 ALL QUOTES IN THE WORD (INCLUDING THE STARTING   */
 /*                 AND ENDING QUOTE) ARE RETAINED.                  */
 /*              4) IF EITHER QUOTE IS FOUND IN PARENTHESES,         */
 /*                 THEN THE SCAN PROCEEDS AS IN RULE 2) UNTIL       */
 /*                 THE QUOTE ENDS, AND PARENTHESES IN THE QUOTE     */
 /*                 ARE IGNORED, BUT AFTER THE QUOTE ENDS, THE       */
 /*                 SCAN CONTINUES TILL THE PARENTHESES ARE MATCHED. */
 /*              4) OTHERWISE (IE, THE FIRST CHAR IS A LETTER OR     */
 /*                 DIGIT, ETC), THE SCAN PROCEEDS UNTIL ONE OF      */
 /*                 FOUR CHARACTERS ARE FOUND: BLANK, COLON,         */
 /*                 OPEN PARENTHESES, OR SEMICOLON.                  */
 /*              THIS IS GOOD FOR PARSING STATEMENTS OF THE FORM     */
 /*             LABEL: MACRONAME POSIT POSIT KEYWORD(VALUE) KEYWORD; */
 /* RETURN       SEE DECLARATIONS OF OBJECT...GIBBERISH RETURN CODES */
 /*              ABOVE. GETWORD DOES NOT RETURN THE 'OPERATOR'       */
 /*              RETURN CODE.                                        */
 GETWORD: PROC(STRING,POSITION,RETCODE) RETURNS(CHAR(1024) VAR);
 DCL STRING CHAR(*) VAR;
 DCL POSITION FIXED BIN;
 DCL RETCODE FIXED BIN;
 DCL STRLEN FIXED BIN;
 DCL RETSTR CHAR(1024) VAR INIT('');
 DCL PAREN FIXED BIN INIT(0);
 DCL CH CHAR(1);
 DCL QMARK CHAR(1);
 DCL ALPHANUM FIXED BIN INIT(0);
 DCL I FIXED BIN;
 DCL (LENGTH,SUBSTR) BUILTIN;
 DCL TOKEN BIT;
         TOKEN='0'B;
         GO TO JOIN;
 % SKIP(3);
 /* ENTRY        GETTOKEN                                            */
 /* FUNCTION     RETURNS THE NEXT PL/I TOKEN OF THE CURRENT MACRO    */
 /*              STATEMENT.                                          */
 /* LINKAGE      SAME AS GETWORD                                     */
 /* SYNTAX       A TOKEN IS DEFINED AS A WORD, EXCEPT THAT           */
 /*              A TOKEN CAN CONTAIN ONLY ALPANUMERIC (PLUS NATIONAL */
 /*              CHARACTERS AND UNDERSCORE), OR ONLY SPECIAL         */
 /*              CHARACTERS.                                         */
 /*              THIS IS GOOD FOR PARSING NATIVE PL/I STATEMENTS.    */
 /* RETURN       SEE DECLARATIONS OF OBJECT...GIBBERISH RETURN CODES */
 /*              ABOVE. GETTOKEN DOES NOT RETURN THE 'KEYWORD'       */
 /*              RETURN CODE.                                        */
 GETTOKEN: ENTRY(STRING,POSITION,RETCODE) RETURNS(CHAR(1024) VAR);
         TOKEN='1'B;
 JOIN:
         STRLEN=LENGTH(STRING);
 % PAGE;
 /* BLOCK: PREWORD                                                   */
 /* FUNCTION: SKIPS BLANKS AND COMMENTS BEFORE A WORD. DETECTS A     */
 /*           COMMA AND RETURNS.                                     */
 /* ENTRY:                                                           */
 /*    POSITION POINTS TO NEXT CHAR OR PAST END OF STRING            */
 /* EXIT:                                                            */
 /*    FALLS THROUGH TO NEXTSCAN WITH UPDATED POSITION               */
 %SKIP;
 PREWORD:
         IF POSITION>0 & POSITION<STRLEN
              THEN
                   IF SUBSTR(STRING,POSITION,1)='('
                        THEN
                             POSITION=POSITION-1;
              DO POSITION=POSITION+1 TO STRLEN;
              CH=SUBSTR(STRING,POSITION,1);
              IF CH=','
                   THEN DO;
                                  RETCODE=COMMA;
                                  RETURN('');
                                  END;
                   ELSE
                        IF CH^=' '
                             THEN
                                  LEAVE;
              END;
         IF POSITION < STRLEN THEN
            IF CH='/' & SUBSTR(STRING,POSITION+1,1)='*'
               THEN DO;
                 DO POSITION=POSITION+2 TO STRLEN-1
                    WHILE(SUBSTR(STRING,POSITION,2)^='*/');
                 END;
                 IF POSITION=STRLEN THEN DO;
                    POSITION=STRLEN+1;
                    RETCODE=GIBBERISH;
                    RETURN('');
                 END;
                 POSITION=POSITION+1;
                 GO TO PREWORD;
         END;
 % PAGE;
 /* BLOCK: NEXTSCAN                                                  */
 /* FUNCTION: DETERMINE WHAT IS NEXT                                 */
 /* ENTRY:                                                           */
 /*   POSITION POINTS TO NEXT NON-BLANK, OR PAST END OF STRING       */
 /* EXIT:                                                            */
 /*   GO THE THE RIGHT BLOCK DEPENDING ON THE NEXT CHAR              */
 /*   CHAR   MEANING                                                 */
 /*   ;      END OF STATEMENT                                        */
 /*   (      PARENTHESIS VALUE                                       */
 /*   ",'    QUOTED VALUE                                            */
 /*   OTHER  KEYWORD OR POSITIONAL                                   */
 /*   POSITION IS INCREMENTED FOR '(' OR QUOTE                       */
 /*   IF WE ARE PAST END OF STRING ON ENTRY, RETURN '' RC=EOS        */
 %SKIP;
         RETCODE=EOS;
         IF POSITION>STRLEN THEN RETURN('');
 %SKIP;
         RETCODE=GIBBERISH;
         CH=SUBSTR(STRING,POSITION,1);
         IF CH=';'
              THEN
                   DO;
                   RETCODE=SEMICOLON;
                   RETURN('');
                   END;
         IF CH='('
              THEN
                   DO;
                   PAREN=1;
                   POSITION=POSITION+1;
                   GO TO PARENTHESES;
                   END;
         IF CH='''' × CH='"'
              THEN
                   DO;
                   POSITION=POSITION+1;
                   QMARK=CH;
                   GO TO QUOTE;
                   END;
 % PAGE;
 /* BLOCK: WORD                                                      */
 /* FUNCTION: TO ANALYZE A KEYWORD OR POSITIONAL PARM NOT            */
 /*     IN QUOTES                                                    */
 /* ENTRY:                                                           */
 /*     POSITION POINTS TO FIRST CHARACTER                           */
 /* EXIT:                                                            */
 /*     WHEN NEXT CHAR IS A DELIMITER (GETWORD), OR DIFFERS IN       */
 /*     ALPHAMERIC STATUS FROM THE START, RETURN INTERVENING         */
 /*     CHARACTERS. FOR GETWORD, IF NEXT CHAR IS '(', SET RC TO      */
 /*     KEYWORD. FOR GETTOKEN, SET RC TO OBJECT IF ALPHANUMERIC,     */
 /*     ELSE TO OPERATOR.                                            */
 /* NOTE:                                                            */
 /*     BECAUSE OF DIFFERENT USAGE OF THE PERIOD (.) IN STRUCTURE    */
 /*     EXPRESSIONS AND NUMERIC CONSTANTS, IT MUST BE CONSIDERED ON  */
 /*     THE BORDER BETWEEN ALPHAMERIC AND OPERATOR. THE RULES ARE:   */
 /*     1) AN INITIAL PERIOD IS AN OPERATOR.                         */
 /*     2) A PERIOD AFTER A OPERATOR CHARACTER TERMINATES THE        */
 /*        OPERATOR.                                                 */
 /*     3) A PERIOD WITHIN AN ALPHAMERIC WORD IS JUST FINE.          */
 /*     4) A PERIOD AT THE END OF A WORD THAT STARTS NUMERICALLY     */
 /*        IS JUST FINE.                                             */
 /*     5) A PERIOD AT THE END OF A WORD STARTING ALPHABETICALLY     */
 /*        IS EXCLUDED, AND WILL BE PICKED UP AS AN OPERATOR NEXT    */
 /*        TIME.                                                     */
 %SKIP;
 WORD:
         RETSTR=CH;
         IF TOKEN & CH='.' THEN DO;
            RETCODE=OPERATOR;
            RETURN('.');
         END;
         IF TOKEN THEN
            ALPHANUM=VERIFY(CH,
               'ABCDEFGHIJKLMNOPQRSTUVWXYZ@#$_0123456789.');
              DO POSITION=POSITION+1 TO STRLEN;
              CH=SUBSTR(STRING,POSITION,1);
              IF POSITION<STRLEN THEN
                 IF CH='/' & SUBSTR(STRING,POSITION+1,1)='*'
                    THEN GO TO ENDWORD;
              IF CH=' ' × CH=':' × CH='(' × CH=';' × CH=',' ×
                 CH='''' × CH='"'
                   THEN
                        GO TO ENDWORD;
                   ELSE
                        IF TOKEN & ALPHANUM^=VERIFY(CH,
               'ABCDEFGHIJKLMNOPQRSTUVWXYZ@#$_0123456789.')
                           THEN GO TO ENDWORD;
                   ELSE
                        RETSTR=RETSTR××CH;
              END;
 ENDWORD:
         IF TOKEN THEN DO;
            RETCODE=ALPHANUM;
            IF CH='.' & ALPHANUM=1 & SUBSTR(RETSTR,1,1)<'0'
               THEN DO;
                  POSITION=POSITION-1;
                  RETSTR=SUBSTR(RETSTR,1,LENGTH(RETSTR)-1);
            END;
         END;
            ELSE
               IF POSITION<=STRLEN & CH='('
                  THEN
                             RETCODE=KEYWORD;
                  ELSE RETCODE=OBJECT;
         POSITION=POSITION-1;
         RETURN(RETSTR);
 % PAGE;
 /* BLOCK: PARENTHESES                                               */
 /* FUNCTION: PROCESS A VALUE STRING TILL PARENS MATCH.              */
 /* ENTRY:                                                           */
 /*   POSITION POINTS PAST FIRST PAREN                               */
 /*   PAREN=1                                                        */
 /* ENTRY ALSO FROM QUOTE WITH                                       */
 /*   POSITION PAST " OR '                                           */
 /*   PAREN UNCHANGED                                                */
 /* EXIT:                                                            */
 /*   IF A " IS HIT, GO TO QUOTE WITH PAREN>0                        */
 /* NOTE:                                                            */
 /*   MULTIPLE BLANKS AND/OR COMMENTS WITHIN PARENTHESES ARE REPLACED*/
 /*   BY A SINGLE BLANK                                              */
 %SKIP;
 PARENTHESES:
              RETSTR='(';
 PARETURN:
              DO POSITION=POSITION TO STRLEN;
              CH=SUBSTR(STRING,POSITION,1);
              IF CH=';'
                   THEN
                        DO;
                        RETCODE=GIBBERISH;
                        RETURN('');
                        END;
              ELSE IF CH='('
                   THEN
                        PAREN=PAREN+1;
              ELSE IF CH=')'
                   THEN
                        DO;
                        PAREN=PAREN-1;
                        IF PAREN=0 THEN GO TO PAREND;
                        END;
              ELSE IF CH='''' × CH='"'
                   THEN
                        DO;
                        POSITION=POSITION+1;
                        QMARK=CH;
                        GO TO QUOTE;
                        END;
              ELSE IF CH=' ' THEN DO;
                 IF SUBSTR(RETSTR,LENGTH(RETSTR),1)=' '
                    THEN GO TO PARLOOP;
                 END;
              ELSE IF POSITION<STRLEN THEN
                 IF CH='/' & SUBSTR(STRING,POSITION+1,1)='*'
                    THEN GO TO SUBCOM;
              RETSTR=RETSTR××CH;
 PARLOOP:
              END;
 PAREND:
         RETCODE=PSTRING;
         RETURN(RETSTR××')');
 SUBCOM:
         DO POSITION=POSITION+2 TO STRLEN-1
            WHILE(SUBSTR(STRING,POSITION,2)^='*/');
         END;
         IF POSITION=STRLEN THEN DO;
            POSITION=POSITION+1;
            RETCODE=GIBBERISH;
            RETURN('');
         END;
         IF SUBSTR(RETSTR,LENGTH(RETSTR),1)^=' ' THEN
            RETSTR=RETSTR××' ';
         POSITION=POSITION+2;
         GO TO PARETURN;
 % PAGE;
 /* BLOCK: QUOTE                                                     */
 /* FUNCTION: TO PROCESS QUOTED BLOCK                                */
 /* ENTRY:                                                           */
 /*   POSITION POINTS PAST OPENING QUOTE MARK                        */
 /* EXIT:                                                            */
 /*   COMPRESS "" TO A SINGLE " (IF WITHIN " BUT NOT PARENTHESES     */
 /*   TERMINATE WHEN SINGLE MATCHING QUOTE ENCOUNTERED               */
 %SKIP;
 QUOTE:
         IF PAREN>0 × QMARK='''' THEN
          RETSTR=RETSTR××QMARK;
         DO POSITION=POSITION TO STRLEN;
         CH=SUBSTR(STRING,POSITION,1);
         IF CH=QMARK
              THEN
                   DO;
                   IF PAREN>0 × QMARK='''' THEN
                        RETSTR=RETSTR××QMARK;
                   IF POSITION=STRLEN
                        THEN
                             GOTO ENDQUOTE;
                        ELSE
                             IF SUBSTR(STRING,POSITION+1,1)=QMARK
                              THEN
                               DO;
                               RETSTR=RETSTR××QMARK;
                               POSITION=POSITION+1;
                               END;
                              ELSE
                               GOTO ENDQUOTE;
                   END;
              ELSE
                   RETSTR=RETSTR××CH;
         END;
 ENDQUOTE:
         IF POSITION>STRLEN
              THEN
                   DO;
                   RETCODE=GIBBERISH;
                   RETURN('');
                   END;
         IF PAREN>0 THEN DO;
             POSITION=POSITION+1;
             GO TO PARETURN;
         END;
         IF QMARK='''' THEN
            RETCODE=QSTRING;
            ELSE
               RETCODE=PSTRING;
         RETURN(RETSTR);
 %SKIP;
 END GETWORD;
 % PAGE;
 /* PROCEDURE    USEMAC                                              */
 /* FUNCTION     IMPLIMENTS THE 'USE' MACRO STATEMENT                */
 /* USEMAC:MACRO                                                     */
    USEMAC: PROC(STRING,GPPPTCA,MACNAME);
    DCL STRING CHAR(*) VAR;
    % NOPRINT;
    DCL 1 GPPPTCA CONNECTED,
    %INCLUDE GPPPTCA;
    % PRINT;
    DCL MACNAME CHAR(16);
 /*PARAMETER GRAMMARN REQUIRED POSITIONAL LIST                       */
 DCL GRAMMARNAME CHAR(16);
 /*PARSE                                                             */
    DCL 1 PARMBLOK,
        2 KEYWORDS(001),
            3 PARMN CHAR(16) VAR INIT(' '),
            3 PNUM FIXED BIN INIT(00),
       2 PARAMETERS(0:01),
            3 PARMS CHAR(256) VAR INIT('',''),
            3 STATUS BIT(8) ALIGNED INIT('0000'B,'010101'B),
            3 SUBS FIXED BIN INIT(0,0),
            3 NAMEUSED CHAR(16) VAR;
    DCL GRAMMARN CHAR(256) VAR;
    DCL NEXTWORD CHAR(256) VAR;
    DCL POSITION FIXED BIN;
    CALL PARSE(STRING,PARMBLOK,0,'0'B);
 /* OPEN GRAMMARN                                                    */
    POSITION=0;
 DO UNTIL(GRAMMARN='');
 /* GET GRAMMARN                                                     */
    NEXTWORD=GETLIST(PARMS(01),POSITION);
    GRAMMARN=NEXTWORD;
 GRAMMARNAME=GRAMMARN;
 IF GRAMMARN^='' THEN
 CALL GRAMMAR(GRAMMARNAME);
 END;
 END;
 % PAGE;
 /* PROCEDURE    PRINTMAC                                            */
 /* FUNCTION     IMPLEMENTS THE PRINT MACRO COMMAND                  */
 /* SYNTAX            PRINT (ON×OFF×GEN×NOGEN);                      */
 /* PRINTMAC:MACRO                                                   */
  PRINTMAC: PROC(STRING,GPPPTCA,MACNAME);
  DCL STRING CHAR(*) VAR;
  % NOPRINT;
  DCL 1 GPPPTCA CONNECTED,
  %INCLUDE GPPPTCA;
  % PRINT;
  DCL MACNAME CHAR(16);
 /* PARAMETER  OPTION REQUIRED POSITIONAL                            */
 /* PARSE                                                            */
    DCL 1 PARMBLOK,
        2 KEYWORDS(001),
            3 PARMN CHAR(16) VAR INIT(' '),
            3 PNUM FIXED BIN INIT(00),
       2 PARAMETERS(0:01),
            3 PARMS CHAR(256) VAR INIT('',''),
            3 STATUS BIT(8) ALIGNED INIT('0000'B,'010100'B),
            3 SUBS FIXED BIN INIT(0,0),
            3 NAMEUSED CHAR(16) VAR;
    DCL OPTION CHAR(256) VAR DEF(PARMS(01));
    CALL PARSE(STRING,PARMBLOK,0,'0'B);
 IF OPTION='ON' THEN PRINTON='1'B;
 ELSE IF OPTION='OFF' THEN PRINTON='0'B;
 ELSE IF OPTION='GEN' THEN PRINTGEN='1'B;
 ELSE IF OPTION='NOGEN' THEN PRINTGEN='0'B;
 ELSE CALL NOTE(8,'INVALID PRINT OPTION','GPPP100I');
 IF OPTION='ON' × OPTION='OFF'
    THEN CALL ECHOSPILL;
 END;
 % PAGE;
 /* PROCEDURE    GENERMAC                                            */
 /* FUNCTION     IMPLEMENTS THE GEN   MACRO COMMAND                  */
 /* SYNTAX            GEN   "STMT";                                  */
 /* GENERMAC:MACRO (1024)                                            */
  GENERMAC: PROC(STRING,GPPPTCA,MACNAME);
  DCL STRING CHAR(*) VAR;
  % NOPRINT;
  DCL 1 GPPPTCA CONNECTED,
  %INCLUDE GPPPTCA;
  % PRINT;
  DCL MACNAME CHAR(16);
 /* PARAMETER STMT POSITIONAL                                        */
 /* PARAMETER AUTOMATIC BIT                                          */
 /* PARSE                                                            */
    DCL 1 PARMBLOK,
        2 KEYWORDS(001),
            3 PARMN CHAR(16) VAR INIT('AUTOMATIC'),
            3 PNUM FIXED BIN INIT(02),
       2 PARAMETERS(0:02),
            3 PARMS CHAR(1024) VAR INIT('','',''),
            3 STATUS BIT(8) ALIGNED INIT('0000'B,'010000'B,'000010'B),
            3 SUBS FIXED BIN INIT(0,0,0),
            3 NAMEUSED CHAR(16) VAR;
    DCL STMT CHAR(1024) VAR DEF(PARMS(01));
    DCL AUTOMATIC BIT;
    CALL PARSE(STRING,PARMBLOK,0,'0'B);
    AUTOMATIC=NAMEUSED(02)='AUTOMATIC';
 IF STMT=''
         THEN
              IF LANGUAGE='PLI' THEN
                 CALL NOTE(8,'GEN NOT SUPPORTED IN PL/I','GPPP101I');
                 ELSE DO;
                    BLKGEN='1'B;
                    GENAUTO=AUTOMATIC;
              END;
         ELSE
              DO;
              IF AUTOMATIC
                   THEN
                        GENAUTO='1'B;
              CALL GEN(STMT);
              GENAUTO='0'B;
              END;
 END;
 % PAGE;
 /* PROCEDURE    INCLDMAC                                            */
 /* FUNCTION     IMPLEMENTS THE INCLUDE MACRO COMMAND                */
 /* SYNTAX            INCLUDE MEMBERNAME                             */
 /*INCLDMAC: MACRO                                                   */
    INCLDMAC: PROC(STRING,GPPPTCA,MACNAME);
    DCL STRING CHAR(*) VAR;
    % NOPRINT;
    DCL 1 GPPPTCA CONNECTED,
    %INCLUDE GPPPTCA;
    % PRINT;
    DCL MACNAME CHAR(16);
 /*PARAMETER MEMBERNAME REQUIRED POSITIONAL                          */
 /*PARAMETER NOPRINT BIT                                             */
 /*PARSE                                                             */
    DCL 1 PARMBLOK,
        2 KEYWORDS(001),
            3 PARMN CHAR(16) VAR INIT('NOPRINT'),
            3 PNUM FIXED BIN INIT(02),
       2 PARAMETERS(0:02),
            3 PARMS CHAR(256) VAR INIT('','',''),
            3 STATUS BIT(8) ALIGNED INIT('0000'B,'010100'B,'000010'B),
            3 SUBS FIXED BIN INIT(0,0,0),
            3 NAMEUSED CHAR(16) VAR;
    DCL MEMBERNAME CHAR(256) VAR DEF(PARMS(01));
    DCL NOPRINT BIT;
    CALL PARSE(STRING,PARMBLOK,0,'0'B);
    NOPRINT=NAMEUSED(02)='NOPRINT';
 IF ^GENON THEN RETURN;
 MEMBER=MEMBERNAME;
 IF PUSHMEM(MEMBER) THEN
           IF NOPRINT THEN PRINTON='0'B;
 END;
 % PAGE;
 /* PROCEDURE    PAGEMAC                                             */
 /* FUNCTION     IMPLEMENTS THE PAGE MACRO COMMAND                   */
 /*PAGEMAC:MACRO                                                     */
  PAGEMAC: PROC(STRING,GPPPTCA,MACNAME);
  DCL STRING CHAR(*) VAR;
  % NOPRINT;
  DCL 1 GPPPTCA CONNECTED,
  %INCLUDE GPPPTCA;
  % PRINT;
  DCL MACNAME CHAR(16);
 /*PARSE                                                             */
    DCL 1 PARMBLOK,
        2 KEYWORDS(001),
            3 PARMN CHAR(16) VAR INIT(' '),
            3 PNUM FIXED BIN INIT(00),
       2 PARAMETERS(0:00),
            3 PARMS CHAR(256) VAR INIT(''),
            3 STATUS BIT(8) ALIGNED INIT('0000'B),
            3 SUBS FIXED BIN INIT(0),
            3 NAMEUSED CHAR(16) VAR;
    CALL PARSE(STRING,PARMBLOK,0,'0'B);
 EJECT='1'B;
 IF LANGUAGE='BAL' THEN CALL GEN('         EJECT');
 ELSE IF LANGUAGE='PLI' THEN CALL GEN(' %PAGE;');
 END;
 % SKIP(3);
 /* PROCEDURE    TITLEMAC                                            */
 /* FUNCTION     IMPLEMENTS THE TITLE MACRO COMMAND                  */
 /* TITLEMAC:MACRO                                                   */
  TITLEMAC: PROC(STRING,GPPPTCA,MACNAME);
  DCL STRING CHAR(*) VAR;
  % NOPRINT;
  DCL 1 GPPPTCA CONNECTED,
  %INCLUDE GPPPTCA;
  % PRINT;
  DCL MACNAME CHAR(16);
 /* PARAMETER TITLER REQUIRED POSITIONAL                             */
 /* PARSE                                                            */
    DCL 1 PARMBLOK,
        2 KEYWORDS(001),
            3 PARMN CHAR(16) VAR INIT(' '),
            3 PNUM FIXED BIN INIT(00),
       2 PARAMETERS(0:01),
            3 PARMS CHAR(256) VAR INIT('',''),
            3 STATUS BIT(8) ALIGNED INIT('0000'B,'010100'B),
            3 SUBS FIXED BIN INIT(0,0),
            3 NAMEUSED CHAR(16) VAR;
    DCL TITLER CHAR(256) VAR DEF(PARMS(01));
    CALL PARSE(STRING,PARMBLOK,0,'0'B);
  TITLE=SUBSTR((36)' ',1,(71-LENGTH(TITLER))/2)××TITLER;
  EJECT='1'B;
  IF LANGUAGE='BAL' THEN
    CALL GEN('          TITLE '''××TITLER××'''');
 END TITLEMAC;
 END GPPP;
