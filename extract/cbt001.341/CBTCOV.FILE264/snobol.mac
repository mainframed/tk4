 /* SNOBOL */
 /*
0*$.HE GENERALIZED SUBROUTINES - SNOBOL
0*$.HE SNOBOL PATTERN/ASSIGNMENT DRIVER
0*$.PL 55
0*$.PN 0
0*$.PA
0*$.SS
0*$.NF
0*$06/06/83
0*$AUTHOR:  T. SMITH
0*$SOURCE MODULE NAME:  SNOBOL
0*$DOCUMENTATION ID:  0*$
0*$.FI L
0*$.SP 5
0*$THIS SUBROUTINE WILL MODIFY A GIVEN DATA STRING ACCORDING TO
0*$THE SPECIFICATIONS OF A SNOBOL STATEMENT STRING.  SYNTAX FOR THE
0*$STRING IS GIVEN BELOW IN BNF.  IF A PATTERN MATCH IS FOUND, '1'B
0*$WILL BE RETURNED.
0*$.SP 1
0*$.NF
0*$<STATEMENT>  ::= <PATTERN> ( '=' <ASSIGNMENT> )
0*$<PATTERN>    ::= <1, <ALTERNATE> / '×'>
0*$<ALTERNATE>  ::= <1, <ELEMENT> / ' '>
0*$<ELEMENT>    ::= <REF> ('$' <NAME>)
0*$<REF>        ::= <LITERAL> × <NAMEREF> × <FUNCTIONREF> ×
0*$                 '(' <STATEMENT> ')'
0*$<NAMEREF>    ::= ('*') <NAME>
0*$<FUNCTIONREF>::= <FUNCTION> '(' <0, <ARGUMENTS> / ','> ')'
0*$<FUNCTION>   ::= 'ANY' × 'ARB' × 'BREAK' × 'EQ' × 'EVAL' × 'GE' ×
0*$                 'GT' × 'IDENT' × 'INDEX' × 'LE' × 'LEN' ×
0*$                 'LGT' × 'LT' × 'NE' × 'NOTANY' × 'POS' ×
0*$                 'RPOS' × 'RTAB' × 'SPAN' × 'TAB'
0*$<ARGUMENTS>  ::= <LITERAL> × ('*') <NAME>
0*$<NAME>       E.G. ABC123
0*$<LITERAL>    E.G. 'HOW NOW'
0*$<ASSIGNMENT> ::= <1, <ASSREF> / ' '>
0*$<ASSREF>     ::= <NAME> × <LITERAL> × <NUMBER>
0*$.FI L
0*$.SP 1
0*$CALL FORMAT IS AS FOLLOWS:
0*$.SP 1
0*$MATCH=SNOBOL(DATA,STMT,MSG,GET_OPERAND_CHAR,PUT_OPERAND_CHAR,
0*$SCANKEY,ANCHORKEY,FREEKEY,ALLKEY,PATPTR,CURSOR,LISTHDR,LISTEND);
0*$.SP 1
0*$.HI 5
0*$WHERE-
0*$.SP 1
0*$ALLKEY IS CHAR(*) VAR, AND IS SET BY THE CALLER TO 'ALL' IF ALL
0*$COMBINATIONS OF ALTERNATIVES ARE TO BE TRIED.
0*$.SP 1
0*$ANCHORKEY IS CHAR(*) VAR, AND IS SET BY THE CALLER TO 'ANCHOR'
0*$IF THE SCAN IS TO BE ANCHORED IN COLUMN 1.
0*$.SP 1
0*$CURSOR IS FIXED BIN(15,0), AND IS SET TO BY CALLER TO THE POSITION
0*$IN DATA WHERE THE PATTERN MATCHING SCAN IS TO START.
0*$.SP 1
0*$DATA IS CHAR(*) VAR CONTAINING SUBJECT STRING.
0*$.SP 1
0*$FREEKEY IS CHAR(*) VAR, AND IS SET BY THE CALLER TO 'FREE' IF THE
0*$CONTROL BLOCKS POINTED TO BY PATPTR (SEE BELOW) ARE TO BE FREED
0*$AT THE END OF THE CURRENT INVOCATION.  IF FREEKEY IS 'FREEONLY'
0*$THE ONLY FUNCTION PERFORMED BY THE CURRENT INVOCATION IS TO FREE
0*$THOSE CONTROL BLOCKS.
0*$.SP 1
0*$GET_OPERAND_CHAR IS ENTRY(CHAR(*) VAR, CHAR(*) VAR), AND
0*$IS CALLED BY THE SNOBOL SUBROUTINE WHENEVER IT REQUIRES THE
0*$REPLACEMENT VALUE FOR A SYMBOLIC VARIABLE.
0*$.SP 1
0*$LISTHDR IS PTR, AND WILL BE SET TO EITHER NULL OR A LIST OF
0*$ELEMENTS OF THE FOLLOWING FORMAT, DEPENDING ON WHETHER MORE THAN
0*$ONE OUTPUT STRING WAS DEVELOPED.  THIS MIGHT OCCUR IF <NUMBER>
0*$APPEARS IN THE <ASSIGNMENT> CLAUSE.  SUPPOSE THE CURRENT OFFSET IN
0*$THE OUTPUT STRING IS 25 WHEN A <NUMBER> IS ENCOUNTERED EQUALLING 30.
0*$FIVE BLANKS WILL BE INSERTED AS A RESULT TO GET THE CURRENT OFFSET
0*$TO BE 30.  IF THE CURRENT OFFSET HAD BEEN 25 WHEN A <NUMBER> WAS
0*$ENCOUNTERED IN THE <ASSIGNMENT> CLAUSE EQUALLING 20, THEN A NEW
0*$ELEMENT WILL BE ADDED TO THE LIST POINTED TO BY LISTHDR, 19 BLANKS
0*$INSERTED IN THE FRONT OF IT, FOLLOWED BY THE REST OF THE ORIGINAL
0*$DATA, AND THE REPLACEMENT FUNCTION WOULD CONTINUE WITH CURRENT
0*$OFFSET BEING 20.  IF <NUMBER>=0, REGARDLESS OF WHERE THE CURRENT
0*$OFFSET IS, A NEW LINE WILL BE DEFINED, AND THE CURRENT OFFSET WILL
0*$BE SET TO 1.
0*$.SP 1
0*$LISTEND IS PTR, AND WILL BE SET TO EITHER NULL OR TO THE ADDRESS
0*$OF THE LAST ELEMENT IN THE LIST POINTED TO BY LISTHDR.
0*$.SP 1
0*$THE FORMAT OF A LIST ELEMENT IS AS FOLLOWS:
0*$.SP 1
0*$.NF
0*$DCL 1 LISTELEM BASED(LISTPTR),
0*$2 NEXT PTR, (* POINTER TO NEXT ELEMENT OR NULL *)
0*$2 LENGTH FIXED BIN(15,0), (* STRING LENGTH *)
0*$2 STRING CHAR(L REFER(LENGTH)) VAR;
0*$.FI L
0*$.SP 1
0*$MATCH IS BIT(1) AND WILL BE SET TO '1'B IF A PATTERN MATCH WAS
0*$FOUND.
0*$.SP 1
0*$MSG IS CHAR(*) VAR, AND IS SET TO EITHER '' IF STMT CONTAINS VALID
0*$SYNTAX, OR A MESSAGE DESCRIBING SYNTAX ERROR.
0*$.SP 1
0*$PATPTR IS PTR, AND SHOULD BE SET TO NULL PRIOR TO THE FIRST
0*$INVOCATION OF THE SNOBOL SUBROUTINE.  SNOBOL WILL PARSE THE
0*$STATEMENT IN STMT ON THE FIRST INVOCATION, AND WILL CREATE CONTROL
0*$BLOCKS POINTED TO BY PATPTR.  SEE ALSO THE FREEKEY ARGUMENT ABOVE.
0*$.SP 1
0*$PUT_OPERAND_CHAR IS ENTRY(CHAR(*) VAR, CHAR(*) VAR), AND IS CALLED
0*$BY THE SNOBOL SUBROUTINE TO ASSIGN A REPLACEMENT VALUE SPECIFIED
0*$AS THE SECOND ARGUMENT, TO THE SYMBOLIC VARIABLE SPECIFIED AS THE
0*$FIRST ARGUMENT.
0*$.SP 1
0*$SCANKEY IS CHAR(*) VAR, AND IS SET BY THE CALLER TO 'RESCAN' IF
0*$THE SUBJECT IS TO BE RESCANNED AFTER EACH SUCCESSFUL MATCH.
0*$.SP 1
0*$STMT IS CHAR(*) VAR CONTAINING SNOBOL STATEMENT.
0*$.SP 1
 */
 SNOBOL: PROC(DATA,STMT,MSG,GET_OPERAND_CHAR,PUT_OPERAND_CHAR,SCANKEY,
   ANCHORKEY,FREEKEY,ALLKEY,PATPTR,CURSOR,LISTHDR,LISTEND)
   RETURNS(BIT(1)) OPTIONS(REENTRANT) RECURSIVE;
   DCL (DATA,STMT) CHAR(*) VAR;
   DCL GET_OPERAND_CHAR ENTRY(CHAR(*) VAR,CHAR(*) VAR);
   DCL PUT_OPERAND_CHAR ENTRY(CHAR(*) VAR, CHAR(*) VAR);
   DCL (SCANKEY,ANCHORKEY,FREEKEY,ALLKEY) CHAR(*) VAR;
   DCL (PATPTR,LISTHDR,LISTEND,WORKHDR,WORKEND,WORKSAV) PTR;
   %INCLUDE ABESNO;
   DCL (NULL,STORAGE) BUILTIN;
   DCL SNOPRS ENTRY(CHAR(*) VAR,,CHAR(80) VAR,)
     RETURNS(PTR);
   DCL SNOFUN ENTRY(CHAR(*) VAR,PTR,,FIXED BIN(15,0),CHAR(*) VAR,
     PTR,PTR) RETURNS(BIT(1));
   DCL MSG CHAR(80) VAR;
   DCL (CURSOR,SAVCURSOR,HITCURSOR,NEWLEN,OLDLEN) FIXED BIN(15,0);
   DCL (MATCH,NEWMATCH) BIT(1) INIT('0'B);
   DCL 1 LISTELEM BASED(LISTPTR),
     2 LISTNXT PTR,
     2 LISTLEN FIXED BIN(15,0),
     2 LISTSTR CHAR(L REFER(LISTLEN)) VAR;

   /* HOUSEKEEPING */
   L=STORAGE(DATA)-2; /* LENGTH TO ALLOCATE FOR LISTELEM */
   MSG='';
   SNOGOP=GET_OPERAND_CHAR;
   SNOPOP=PUT_OPERAND_CHAR;
   FREE_PAT=FREE_PAT_REAL;
   FREE_PATEL=FREE_PATEL_REAL;
   FREE_TOKENS=FREE_TOKENS_REAL;
   TOKHDR,CURTOK=NULL;
   SCANIX=1;
   SAVCURSOR=CURSOR;
   HITCURSOR=0;

   /* MAINLINE */
   IF FREEKEY^='FREEONLY'
     THEN DO;
       IF PATPTR=NULL
         THEN PATPTR=SNOPRS(STMT,SCANPARM,MSG,SNOEP);
       IF MSG=''
         THEN DO;
           DO UNTIL(SCANKEY^='RESCAN' × I>LENGTH(DATA));
             NEWMATCH='0'B;
             DO I=SAVCURSOR REPEAT I+1
               UNTIL((I>LENGTH(DATA)) × NEWMATCH);
               CURSOR=I;
               OLDLEN=LENGTH(DATA);
               NEWMATCH=SNOFUN(DATA,PATPTR,SNOEP,CURSOR,ALLKEY,
                 LISTHDR,LISTEND);
               NEWLEN=LENGTH(DATA);
               IF ANCHORKEY='ANCHOR'
                 THEN LEAVE;
               END;
             IF NEWMATCH
               THEN DO;
                 HITCURSOR=CURSOR;
                 MATCH='1'B;
                 IF OLDLEN<=NEWLEN & ANCHORKEY^='ANCHOR'
                   THEN SAVCURSOR=SAVCURSOR+1;
                 END;
             END;
           IF SCANKEY='RESCAN' & ANCHORKEY^='ANCHOR'
             THEN DO LISTPTR=LISTHDR REPEAT LISTNXT
               WHILE(LISTPTR^=NULL);
               WORKHDR,WORKEND=NULL;
               SAVCURSOR=1;
               HITCURSOR=0;
               DO FOREVER=1 REPEAT FOREVER;
                 NEWMATCH='0'B;
                 DO I=SAVCURSOR REPEAT I+1
                   UNTIL(I>LENGTH(DATA) × NEWMATCH);
                   CURSOR=I;
                   OLDLEN=LENGTH(LISTSTR);
                   NEWMATCH=SNOFUN(DATA,PATPTR,SNOEP,CURSOR,ALLKEY,
                     WORKHDR,WORKEND);
                   NEWLEN=LENGTH(LISTSTR);
                   IF I>LENGTH(LISTSTR)
                     THEN LEAVE;
                   END;
                 IF NEWMATCH
                   THEN DO;
                     HITCURSOR=CURSOR;
                     MATCH='1'B;
                     IF OLDLEN<=NEWLEN
                       THEN SAVCURSOR=SAVCURSOR+1;
                     END;
                 END;
               IF WORKHDR^=NULL
                 THEN DO; /* ADD NEW LINES TO MAIN QUEUE */
                   WORKEND->LISTNXT=LISTPTR->LISTNXT;
                   LISTPTR->LISTNXT=WORKHDR;
                   END;
               END;
           END;
       IF MATCH
         THEN CURSOR=HITCURSOR;
       END;
   IF FREEKEY='FREE' × FREEKEY='FREEONLY'
     THEN DO;
       CALL FREE_PAT(PATPTR);
       CALL FREE_TOKENS(TOKHDR);
       END;
   RETURN(MATCH);

 FREE_PAT_REAL: PROC(SPAT) RECURSIVE;
 /**********************************************************************
 *                                                                     *
 * CALLED WHEN INVALID SYNTAX IS ENCOUNTERED IN TEXT BEING PARSED.     *
 *                                                                     *
 **********************************************************************/
   DCL SPAT PTR;
   IF SPAT=NULL
     THEN RETURN;
   CALL FREE_PATEL(SPAT->PATELHD);
   FREE SPAT->PAT;
   SPAT=NULL;
   END FREE_PAT_REAL;

 FREE_PATEL_REAL: PROC(DPT) RECURSIVE;
 /**********************************************************************
 *                                                                     *
 * CALLED TO DELETE A SPECIFIED PATEL.                                 *
 *                                                                     *
 **********************************************************************/
   DCL DPT PTR;
   IF DPT=NULL
     THEN RETURN;
   CALL FREE_PATEL(DPT->PATCAT);
   CALL FREE_PATEL(DPT->PATALT);
   SELECT(DPT->PATTYP);
     WHEN(-1) CALL FREE_PAT(DPT->PATEFH);
     OTHERWISE CALL FREE_TOKENS(DPT->PATEFH);
     END; /* SELECT */
   FREE DPT->PATEL;
   DPT=NULL;
   END FREE_PATEL_REAL;

 FREE_TOKENS_REAL: PROC(THDR);
 /**********************************************************************
 *                                                                     *
 * CALLED TO DELETE A STRING OF TOKEN STRUCTURES.                      *
 *                                                                     *
 **********************************************************************/
   DCL (THDR,NPTR,TPTR) PTR;
   DO TPTR=THDR REPEAT NPTR WHILE(TPTR^=NULL);
     NPTR=TPTR->NEXT_TOKEN;
     FREE TPTR->TOKEN;
     END;
   THDR=NULL;
   END FREE_TOKENS_REAL;

   END SNOBOL;
