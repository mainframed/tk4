  /* POTOPS
0*$.HE GENERALIZED UTILITIES - POTOPS
0*$.HE POTOPS - COPY PDS TO SEQUENTIAL
0*$.PL 55
0*$.PN 0
0*$.PA
0*$.SS
0*$.NF
0*$03/17/82
0*$AUTHOR:  T. SMITH
0*$SOURCE MODULE NAME:  POTOPS
0*$DOCUMENTATION ID:  0*$
0*$.FI L
0*$.SP 5
0*$THIS UTILITY CAN BE USED TO COPY A PARTITIONED DATA SET TO A
0*$SEQUENTIAL DATA SET.  CALL FORMAT IS AS FOLLOWS:
0*$.IN 5
0*$.SP 1
0*$.NF
0*$// EXEC PGM=POTOPS,PARM='/73'
0*$//SYSPRINT DD SYSOUT=*
0*$//IN DD DSN=PDSNAME,DISP=SHR
0*$//OUT DD DSN=&SEQ,DISP=(NEW,PASS),
0*$// UNIT=DISK,SPACE=(TRK,(1,1)),
0*$// DCB=(LRECL=80,BLKSIZE=19040,RECFM=FB)
0*$.SP 1
0*$.IN 0
0*$.FI L
0*$THE OUT DATA SET CAN BE EITHER TAPE OR DISK.  YOU MAY OPTIONALLY
0*$SPECIFY DCB PARAMETERS FOR THE OUT DATA SET, AND THEY MAY BE
0*$DIFFERENT FROM THE INPUT DATA SET.  IF YOU DON'T SPECIFY DCB
0*$PARAMETERS, THOSE FROM THE INPUT PDS WILL BE USED.
0*$.SP 1
0*$THE OPTIONAL PARM FIELD MUST CONTAIN A NUMBER INDICATING WHERE IN
0*$EACH OUTPUT RECORD THE MEMBER NAME IS TO BE STORED.
  */
  POTOPS:PROC(PARM) OPTIONS(MAIN);
   % INCLUDE DCB;
   % INCLUDE DCBQSAM;
   % INCLUDE JFCB;
   DCL PARM CHAR(100) VAR;
   DCL JFCBCOR CHAR(256);
   DFT RANGE(*) FIXED BIN VALUE(FIXED BIN(31,0));
   DCL OUT FILE RECORD OUTPUT;
   DCL PDSPTR PTR;
   DCL MEMNAM CHAR(8) INIT(' ');
   DCL DDNAME CHAR(8) STATIC INIT('IN');
   DCL (INREC,OUTREC) CHAR(*) VARYING CONTROLLED;
   DCL 1 PDSDCB BASED(PDSPTR),
     2 PDSPAD1 CHAR(36),
     2 PDSRECFM BIT(8),
     2 PDSPAD2 CHAR(45),
     2 PDSLRECL FIXED BIN(15,0);
   DCL FINDDCB ENTRY(CHAR(8))
     RETURNS(PTR);
   DCL (SYSFIND,SYSDCBP,SYSOPEN,SYSREAD) ENTRY;
   DCL SYSJFCB ENTRY(CHAR(8),PTR);
   DCL GETDIR ENTRY(CHAR(8))
     RETURNS(CHAR(8));
   DCL VSW BIT(2);
   IF PARM^=''
     THEN IP=PARM;
     ELSE IP=0;
   CALL SYSDCBP(PDSPTR,DDNAME);
   CALL SYSOPEN(PDSPTR,'INPUT');
   ALLOCATE INREC CHAR(PDSLRECL);
   OPEN FILE(OUT);
   JFCBPTR=ADDR(JFCBCOR);
   CALL SYSJFCB('OUT',JFCBPTR);
   IF SUBSTR(JFCBTSDM,3,1)
     THEN DO; /* OUT IS SYSOUT */
       L=JFCLRECL;
       VSW=SUBSTR(JFCRECFM,1,2);
       END;
     ELSE DO;
       DCBPTR=FINDDCB('OUT');
       L=DCBLRECL;
       VSW=SUBSTR(DCBRECFM,1,2);
       END;
   IF L=0
     THEN DO;
       L=PDSLRECL;
       IF SUBSTR(PDSRECFM,1,2)='01'B /* RECFM=V */
         THEN L=L-4;
       END;
     ELSE IF VSW='01'B /* RECFM=V */
       THEN L=L-4;
   ALLOCATE OUTREC CHAR(L);
   ON CONDITION(SYSEOD) BEGIN;
     MEMNAM = GETDIR('IN');
     IF MEMNAM = HIGH(8)
       THEN GO TO EOJ;
     CALL SYSFIND(PDSPTR,MEMNAM,'D',RETCODE);
     IF RETCODE ^= 0
       THEN SIGNAL ERROR;
     GO TO NXT;
     END;
   SIGNAL CONDITION(SYSEOD);
 NXT:
   DO FOREVER=1 REPEAT FOREVER;
     CALL NXTREC(INREC);
     CALL WRITOUT;
     END;
 EOJ:;
 WRITOUT:PROC;
   IF IP=0
     THEN OUTREC=INREC;
     ELSE DO;
       K=IP-LENGTH(INREC)-1;
       SELECT;
         WHEN(K>0) OUTREC=INREC××REPEAT(' ',K-1)××MEMNAM;
         WHEN(K>=-8) OUTREC=SUBSTR(INREC,1,LENGTH(INREC)+K)××MEMNAM;
         OTHERWISE DO;
           OUTREC=INREC;
           SUBSTR(OUTREC,IP,8)=MEMNAM;
           END;
         END;
       END;
   IF LENGTH(OUTREC)<L & VSW^='01'B
     THEN OUTREC=OUTREC××REPEAT(' ',L-LENGTH(OUTREC)-1);
   WRITE FILE(OUT) FROM(OUTREC);
   END WRITOUT;
 NXTREC:PROC(REC);
   DCL REC CHAR(*) VARYING;
   DCL BUFPTR PTR STATIC,BUFPADJ FIXED BIN(31,0) DEF BUFPTR;
   DCL BCNTSAV FIXED BIN(15,0) STATIC INIT(0);
   DCL BUFFER CHAR(32767) VARYING STATIC;
   DCL BYTCNT FIXED BIN(15,0) BASED(BUFPTR);
   DCL RECL FIXED BIN(15,0);
   DCL CURREC CHAR(32767) BASED(CURPTR);
   DCL CURPTR PTR,CURADJ FIXED BIN(31,0) DEF CURPTR;
   IF BCNTSAV = 0
     THEN DO;
       CALL SYSREAD(PDSPTR,BUFFER);
       BCNTSAV = LENGTH(BUFFER);
       BUFPTR = ADDR(BUFFER);
       BUFPADJ = BUFPADJ + 2;
       IF SUBSTR(PDSRECFM,1,2) ='01' /* RECFM=V */
         THEN DO;
           BUFPADJ = BUFPADJ + 4;
           BCNTSAV = BCNTSAV - 4;
           END;
       END;
   IF SUBSTR(PDSRECFM,1,2) ='01'B /* RECFM=V */
     THEN DO;
       RECL = BYTCNT - 4;
       CURADJ = BUFPADJ + 4;
       BCNTSAV = BCNTSAV - BYTCNT;
       BUFPADJ = BUFPADJ + BYTCNT;
       END;
     ELSE DO;
       RECL = PDSLRECL;
       CURADJ = BUFPADJ;
       BCNTSAV = BCNTSAV - PDSLRECL;
       BUFPADJ = BUFPADJ + PDSLRECL;
       END;
   REC = SUBSTR(CURREC,1,RECL);
   END NXTREC;
   END;
