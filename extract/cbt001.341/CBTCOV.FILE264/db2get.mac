 /* DB2GET */
 /*
0*$.HE GENERALIZED SUBROUTINES - DB2GET
0*$.HE OBTAIN A DB2 TABLE
0*$.PL 55
0*$.PN 0
0*$.PA
0*$.SS
0*$.NF
0*$02/01/84
0*$AUTHOR:  T. SMITH
0*$SOURCE MODULE NAME: DB2GET
0*$DOCUMENTATION ID: 0*$
0*$.FI L
0*$.SP 5
0*$THIS SUBROUTINE CAN BE USED TO INTERFACE TO DB2 TO OBTAIN ALL
0*$OF THE ROWS OF A TABLE STORED IN A DB2 DATABASE.  CALL FORMAT
0*$IS AS FOLLOWS:
0*$.SP 1
0*$.NF
0*$DCL DB2GET ENTRY(CHAR(*),ENTRY,ENTRY)
0*$RETURNS(FIXED BIN(31,0));
0*$FETCH DB2GET;
0*$I=DB2GET('TABLENAME',SUBRTNE,TERM);
0*$IF I^=0 THEN SIGNAL ERROR;
0*$.FI L
0*$.SP 1
0*$WHERE -
0*$.SP 1
0*$'TABLENAME' IS THE NAME OF THE TABLE TO BE RETRIEVED.  THIS IS
0*$THE DB2 NAME, AND MAY BE QUALIFIED AS DOCUMENTED IN THE DB2
0*$REFERENCE MANUAL, E.G. 'X75826.TABLE'.
0*$.SP 1
0*$SUBRTNE IS THE NAME OF A FUNCTION YOU AS THE CALLER OF DB2GET
0*$MUST SUPPLY.  IT SHOULD RETURN BIT(1), AND SHOULD RETURN '1'B
0*$IF THE NEXT ROW IS TO BE OBTAINED, OR IT SHOULD RETURN '0'B
0*$IF PROCESSING IS TO BE TERMINATED.  IT WILL BE INVOKED BY DB2GET
0*$FOR EACH ROW RETREIVED FROM THE SPECIFIED TABLE, PASSING THE PTR
0*$TO THE SQLDA AS THE SOLE PARAMETER AS FOLLOWS:
0*$.SP 1
0*$BIT=SUBRTNE(SQLDAPTR);
0*$.SP 1
0*$THE FORMAT OF THE SQLDA IS COMPLETELY DOCUMENTED IN THE DB2
0*$APPLICATION PROGRAMMING GUIDE.  BRIEFLY, HOWEVER, THE SQLDA
0*$HAS IN IT AN ARRAY CONTAINING A SUB-STRUCTURE FOR EACH COLUMN
0*$TO BE RETREIVED.  EACH SUB-STRUCTURE CONTAINS THE NAME OF A
0*$COLUMN, THE DATA TYPE, A POINTER (SQLDATA) TO THE DATA FROM THAT
0*$COLUMN FROM THE CURRENT ROW, AND A POINTER (SQLIND) TO A HALFWORD
0*$(FIXED BIN(15,0)) CONTAINING 0 IF THE COLUMN DATA IS PRESENT IN
0*$THE CURRENT ROW, AND -1 OTHERWISE.
0*$.SP 1
0*$TERM IS ALSO THE NAME OF A PROCEDURE YOU AS THE CALLER OF DB2GET
0*$MUST SUPPLY.  IT WILL BE CALLED BY DB2GET WITH ERROR MESSAGES IF
0*$AN ERROR IS ENCOUNTERED DURING PROCESSING.  DB2GET DECLARES AND
0*$CALLS TERM AS FOLLOWS:
0*$.SP 1
0*$.NF
0*$DCL TERM ENTRY(CHAR(*) VAR);
0*$CALL TERM('ERROR ENCOUNTERED DURING DB2 PROCESSING');
0*$.FI L
0*$.SP 1
0*$DB2GET WILL RETURN ZERO AS A RETURN CODE IF NORMAL PROCESSING IS
0*$COMPLETED, AND ALL ROWS OF THE SPECIFIED TABLE HAVE BEEN
0*$SUCCESSFULLY COMPLETED.
0*$.SP 1
0*$NOTE THAT IN ORDER TO USE THE DB2GET SUBROUTINE, YOUR PROGRAM MUST
0*$BE RUNNING UNDER THE DSN COMMAND OF TSO.  A TYPICAL SEQUENCE OF
0*$TSO COMMANDS TO ESTABLISH THIS ENVIRONMENT FOR A PROGRAM CALLED
0*$'TEST' IS SHOWN BELOW:
0*$.SP 1
0*$.NF
0*$DSN
0*$RUN PROG(TEST) PLAN(ABE) LIB(TEST.LOAD)
0*$.FI L
0*$.SP 1
 */
 DB2GET: PROC(STMT,SUBRTNE,TERM) RETURNS(FIXED BIN(31,0));
   DCL STMT CHAR(*);
   DCL SUBRTNE ENTRY(PTR) RETURNS(BIT(1));
   DCL TERM ENTRY(CHAR(*) VAR);
   DCL (PLIRETV,DIM) BUILTIN;
   DCL DSNTIAR ENTRY OPTIONS(ASM,INTER,RETCODE);
   DCL DATA_LEN FIXED BIN(31) STATIC INIT(120);
   DCL DATA_DIM FIXED BIN(31) STATIC INIT(8);
   DCL 1 ERROR_MESSAGE,
     2 ERROR_LEN FIXED BIN(15,0) UNAL INIT((DATA_LEN*DATA_DIM)),
     2 ERROR_TEXT(DATA_DIM) CHAR(DATA_LEN);
   DCL MSG CHAR(130) VAR;
   DCL 1 COLDATA BASED(COLPTR),
     2 COLIND FIXED BIN(15,0),
     2 COLLEN FIXED BIN(15,0),
     2 COLSTR CHAR(L REFER(COLLEN));
   DCL COMMIT CHAR(20) STATIC INIT('COMMIT');
   EXEC SQL INCLUDE SQLDA;
   EXEC SQL INCLUDE SQLCA;

   EXEC SQL WHENEVER SQLWARNING CONTINUE;
   EXEC SQL WHENEVER SQLERROR GOTO SQLERROR;
   GOTO BY_SQLERROR;
 SQLERROR:
   PUT STRING(MSG) EDIT('SQL ERROR, RETCODE=',SQLCODE)(A,F(10));
   CALL TERM(MSG);
 /*FETCH DSNTIAR; CAUSES 0C1 PROGRAM CHECK
 */CALL DSNTIAR(SQLCA,ERROR_MESSAGE,DATA_LEN);
   IF PLIRETV=0
     THEN DO I=1 TO DIM(ERROR_TEXT,1);
       CALL TERM(ERROR_TEXT(I));
       END;
   RETURN(SQLCODE);
 BY_SQLERROR:;

   SQLSIZE=330; /* ALLOCATE THE MAXIMUM SIZE SQLDA */
   ALLOCATE SQLDA;
   EXEC SQL DECLARE S1 STATEMENT;
   EXEC SQL DECLARE C1 CURSOR FOR S1;
   EXEC SQL PREPARE S1 FROM :STMT;
   EXEC SQL DESCRIBE S1 INTO SQLDA;

   /* NOW ALLOCATE STORAGE FOR COLUMN DATA */
   DO I=1 TO SQLD;
     SELECT(SQLTYPE(I));
       WHEN(484,485) /* FIXED DECIMAL */
         L=SQLLEN(I)/256;
       OTHERWISE
         L=SQLLEN(I);
       END; /* SELECT */
     ALLOCATE COLDATA;
     SQLDATA(I)=ADDR(COLSTR);
     SQLIND(I)=COLPTR;
     END;

   /* NOW PROCESS ALL THE ROWS IN THE TABLE */
   EXEC SQL OPEN C1;
   DO FOREVER=1 REPEAT FOREVER;
     EXEC SQL FETCH C1 USING DESCRIPTOR SQLDA;
     IF SQLCODE^=0
       THEN LEAVE; /* END OF FILE */
     IF ^SUBRTNE(SQLDAPTR)
       THEN LEAVE; /* FORCED END OF FILE */
     END;
   EXEC SQL CLOSE C1;
   EXEC SQL EXECUTE IMMEDIATE COMMIT;

   /* NOW FREE STORAGE */
   DO I=1 TO SQLD;
     COLPTR=SQLIND(I);
     FREE COLDATA;
     END;
   FREE SQLDA;
   RETURN(0); /* SUCCESSFUL COMPLETION */
   END DB2GET;
