 /*DATAENT*/
 DATAENT:  PROC(INDDN,OUTDDN,PNLDDN,DOCMD,DOALC,DOFRE,DOPRM);
         DCL (INDDN,OUTDDN,PNLDDN) CHAR(8);
         DCL DOCMD ENTRY(CHAR(80) VAR,CHAR(4) VAR);
         DCL DOFRE ENTRY(CHAR(8));
         DCL DOALC ENTRY(CHAR(44) VAR,CHAR(3) VAR) RETURNS(CHAR(8));
         DCL DOPRM ENTRY(CHAR(80) VAR) RETURNS(CHAR(120) VAR);
         DFT RANGE(*) FIXED BIN VALUE(FIXED BIN(31,0));
         DCL PLIDUMP BUILTIN;
         DCL HELPSTR CHAR(4) VAR INIT('');
 /*      DCL IDLESUB ENTRY(CHAR(*));
         CALL IDLESUB('START');
 */      DCL 1 REC BASED(RECPTR) UNALIGNED,
                   /* THIS IS THE DEFINITION OF THE ELEMENTS OF THE
                      MAIN STORAGE CHAIN OF RECORDS */
              2 LSTPTR PTR,
                   /* POINTER TO PREVIOUS RECORD OR NULL */
              2 NXTPTR PTR,
                   /* POINTER TO NEXT RECORD OR NULL */
              2 RECPNLN FIXED BIN(15,0),
                   /* PANEL # FOR THIS RECORD */
              2 RECFLGS BIT(8),
                   /* BIT 0 = 1 IF RECORD IS VERIFIED */
              2 RECRES CHAR(1),
                   /* RESERVED */
              2 RECSEQ FIXED BIN(31,0),
                   /* SEQ # FOR THIS REC */
              2 RECSTR CHAR(80);
                   /* CARD IMAGE */
         DCL OUTREC CHAR(80) BASED(OUTPTR);
         DCL 1 RECHDR,
              2 LSTHDR PTR,
                   /* POINTER TO THE LAST RECORD */
              2 NXTHDR PTR;
                   /* POINTER TO THE FIRST RECORD */
         DCL HDPTR PTR;
         HDPTR = ADDR(RECHDR);
         LSTHDR = HDPTR;
         NXTHDR = HDPTR;
         RECPTR = HDPTR;
         DCL RECAREA AREA(1152000);
              /* AREA IS BIG ENOUGH FOR 12,000 RECORDS */
         DCL 1 PNLARYS,
              2 ARYCNT FIXED BIN(31,0) INIT(16),
              2 PNLARY(1:16),
                   3 PNLSTAPT PTR,
                   3 PNLDYNPT PTR;
         DCL 1 @PNLCALL,
              2 @CURPNL FIXED BIN(15,0),
              2 @NXTPNL FIXED BIN(15,0),
              2 @ARYPTR PTR,
              2 @AID BIT(8),
              2 @CURLOC FIXED BIN(15,0),
              2 @CHGCURS FIXED BIN(15,0),
              2 @CALLFLGS BIT(8);
         DCL 1 PANEL UNALIGNED BASED(PNLPTR),
              2 PNLLEN FIXED BIN(15,0),
              2 PNLNAME CHAR(8),
              2 PNLNUM FIXED BIN(15,0),
              2 INCNT FIXED BIN(15,0),
              2 FLDCNT FIXED BIN(15,0),
              2 CURSBA CHAR(2),
              2 CURSBAB FIXED BIN(15,0),
              2 FLDLOC FIXED BIN(15,0);
         DCL 1 FLDDESCR UNALIGNED BASED(SFLDPTR),
              2 FLDLEN FIXED BIN(15,0),
              2 FLDNAME CHAR(8),
              2 FLDNUM FIXED BIN(15,0),
              2 FLDINUM FIXED BIN(15,0),
              2 INLEN FIXED BIN(15,0),
              2 INOFF FIXED BIN(31,0),
              2 OUTOFF FIXED BIN(31,0),
              2 PICOFF FIXED BIN(31,0),
              2 FLAGS BIT(16),
              2 FLDSBA CHAR(2),
              2 FLDSBAB FIXED BIN(15,0),
              2 LITLEN FIXED BIN(15,0),
              2 LITERAL CHAR(L REFER (LITLEN)),
              2 PICLEN FIXED BIN(15,0),
              2 PICTURE CHAR(L REFER (PICLEN));
         DCL 1 PNL_DYNAM UNALIGNED BASED(DYNPTR),
              2 DINOF FIXED BIN(31,0),
              2 DOUTOF FIXED BIN(31,0),
              2 DYNCNT FIXED BIN(15,0),
              2 OUTFLAG(L REFER (DYNCNT)) BIT(1);
         DCL 1 FIELD UNALIGNED BASED(DFLDPTR),
              2 LEN FIXED BIN(15,0),
              2 DATA CHAR(L REFER (LEN)) VARYING;
         DCL WRKPTR PTR,
             WRKADJ FIXED BIN(31,0) DEF WRKPTR;
         DCL SFLDPTR PTR,
             SFLDADJ FIXED BIN(31,0) DEF SFLDPTR;
         DCL DFLDPTR PTR,
             DFLDADJ FIXED BIN(31,0) DEF DFLDPTR;
         DCL DCBPTR PTR;
         DCL NULL BUILTIN;
         DCBPTR = NULL;
         DCL MDDN CHAR(8);
         DCL MDSN CHAR(44) VAR;
         DCL CMDSTR CHAR(120) VAR;
         DCL LINKRET FIXED BIN(31,0);
         DCL (CSEQOFF,CSEQLEN) FIXED BIN(15,0) INIT(0);
         DCL (DELPTR,SAVPTR,COPTR) PTR;
         DCL (ALTSW,BIGALTSW) BIT(1);
         DCL (SCRWRIT,SYSDCBP,SYSOPEN,SYSCLOS,SYSLOAD,SYSLINK) ENTRY;
         DCL FINDTEXT CHAR(80) VARYING INIT('');
         DCL REPSORC CHAR(80) VARYING;
         DCL (MDLAB,TMPLAB,DELLAB) LABEL;
         MDLAB,DELLAB = NXT;
         DCL MPTR(3) PTR;
         DCL MSEQ(3) FIXED BIN(15,0);
         DCL REPRET BIT(2);
         DCL 1 PNLTAB(16),
              2 PNLNAM CHAR(8) INIT('DESCAN',(15)(1)' '),
                   /* PANEL NAME */
              2 DESPTR PTR,
                   /* POINTER TO THE DATA ENTRY DEFINITION STRUCTURE */
              2 EPPTR PTR,
                   /* POINTER RETURNED BY SYSLOAD */
              2 IMAGPTR PTR,
                   /* PTR TO OUTPUT FIELD FOR CARD IMAGE */
              2 IMAGNUM FIXED BIN(15,0),
                   /* FIELD NUMBER FOR CARD IMAGE */
              2 CMDPTR PTR,
                   /* POINTER TO INPUT FIELD FOR COMMAND INPUT AREA */
              2 CMDOPTR PTR,
                   /* POINTER TO OUTPUT FIELD FOR COMMAND OUTPUT AREA */
              2 MSGPTR PTR,
                   /* POINTER TO THE MSG OUTPUT FIELD */
              2 MSGNUM FIXED BIN(15,0),
                   /* FLDNUM FOR MSG FIELD */
              2 INPTR PTR;
                   /* POINTER TO FIRST RECORD INPUT FIELD DESCRIPTOR */
         DCL 1 DESTR UNALIGNED BASED(DESTRPTR),
                   /* THIS STRUCTURE CONTAINS INFORMATION PERTINENT
                      TO DATA ENTRY FOR THIS SCREEN IMAGE */
              2 CARDIMAGE CHAR(80),
                   /* IMAGE OF OUTPUT CARD WITH ANY LITERALS THAT ARE
                      TO BE PRINTED */
              2 SEQOFF FIXED BIN(15,0),
                   /* OFFSET (REL 0) IN OUTPUT CARD TO SEQUENCE FIELD*/
              2 SEQLEN FIXED BIN(15,0),
                   /* LEN SEQUENCE FIELD */
              2 DINCNT FIXED BIN(15,0),
                   /* COUNT OF ELEMENTS IN CARDOFF */
              2 CARDOFF(L REFER (DINCNT)) FIXED BIN(15,0);
                   /* EACH ELEMENT CONTAINS THE OFFSET (REL 0)
                      IN THE OUTPUT CARD WHERE THE CORRESPONDING
                      INPUT FIELD IS TO BE STORED */
         DCL CURSEQ FIXED BIN(15,0) INIT(0);
              /* SEQUENCE CONTROL FIELD.  IN SCAN MODE, THIS FIELD
                 WILL BE SET TO THE SEQUENCE NUMBER OF THE RECORD
                 LISTED ON THE TOPMOST LINE OF THE DISPLAY.  IN
                 INSERT MODE, THIS FIELD IS INCREMENTED TO OBTAIN
                 THE NEW SEQUENCE NUMBERS. */
         DCL SEQBL CHAR(8),
             SEQPIC PIC'(8)9' DEF SEQBL;
              /* MAXIMUM SEQUENCE FIELD LENGTH IS 8 BYTES */
         DCL TABA(16) FIXED BIN(15,0) INIT(
           10,15,20,25,30,35,40,45,50,55,60,65,70,0,0,0);
         DCL PARY(16) CHAR(120) VARYING;
         DCL (PREFIX,SUFFIX) ENTRY RETURNS(FIXED BIN(15,0));
         DCL COLUMN FIXED BIN(15,0);
              /* FOR SCAN PANEL, COLUMN INDICATES THE STARTING
                 POSITION IN THE OUTPUT CARD IMAGE WHERE THE
                 FIRST POSITION FROM INPUT FIELD IS TO BE
                 STORED. */
         DCL TRUNCATE FIXED BIN(15,0);
              /* FOR SCAN PANEL, COLUMN INDICATES THE TRUNCATION
                 POSITION.  COL(3) AND TRUNC(71) WOULD INDICATE
                 THAT INPUT DATA WILL BE ASSIGNED TO POSITIONS
                 3 THRU 71. */
         DCL HDR1 CHAR(79) STATIC INIT('        1         2         3
       4         5        6         7         8');
         DCL HDR2 CHAR(80) STATIC INIT((8)'1234567890');
         DCL BLNKS CHAR(80) STATIC INIT(' ');
         DCL SCANLEN FIXED BIN(15,0);
              /* WILL BE SET TO THE AMOUNT OF DATA TO BE ACCEPTED
                 AS INPUT FROM THE SCAN DISPLAY */
         DCL SCANFLAG BIT(1) INIT('0'B);
              /* THIS FLAG IS TURNED ON IF IN SCAN MODE, AND OFF IF
                 IN INSERT MODE */
         DCL SCANPTR PTR;
         DCL CMDLAB(0:70) LABEL;
         DCL CMDTAB(70) CHAR(8) VARYING STATIC INIT(
              'PANEL',     /*  1 */
              'P',         /*  2 */
              'SAVE',      /*  3 */
              'S',         /*  4 */
              'SF',        /*  5 */
              'SB',        /*  6 */
              'SE',        /*  7 */
              'SCAN',      /*  8 */
              'SC',        /*  9 */
              'MD',        /* 10 */
              'INSERT',    /* 11 */
              'IN',        /* 12 */
              'I',         /* 13 */
              'IF',        /* 14 */
              'IB',        /* 15 */
              'X',         /* 16 */
              'TOP',       /* 17 */
              'T',         /* 18 */
              'BOTTOM',    /* 19 */
              'BOT',       /* 20 */
              'B',         /* 21 */
              'UP',        /* 22 */
              'DOWN',      /* 23 */
              'FIND',      /* 24 */
              'F',         /* 25 */
              'FF',        /* 26 */
              'FB',        /* 27 */
              'COLUMN',    /* 28 */
              'COL',       /* 29 */
              'TRUNCATE',  /* 30 */
              'TRUNC',     /* 31 */
              'TR',        /* 32 */
              'DELETE',    /* 33 */
              'DEL',       /* 34 */
              'D',         /* 35 */
              'BLANK',     /* 36 */
              'BL',        /* 37 */
              'MOVE',      /* 38 */
              'MO',        /* 39 */
              'COPY',      /* 40 */
              'CO',        /* 41 */
              'CHANGE',    /* 42 */
              'C',         /* 43 */
              'REFRESH',   /* 44 */
              'PF',        /* 45 */
              'PB',        /* 46 */
              'RENUM',     /* 47 */
              'REN',       /* 48 */
              'END',       /* 49 */
              'MERGE',     /* 50 */
              'M',         /* 51 */
              'SUBMIT',    /* 52 */
              'SUB',       /* 53 */
              'TABK',      /* 54 */
              'TAB',       /* 55 */
              'HELP',      /* 56 */
              'HF',        /* 57 */
              'HB',        /* 58 */
              'H',         /* 59 */
              'DUMP',      /* 60 */
              'XF',        /* 61 */
              'XB',        /* 62 */
              'SX',        /* 63 */
              'UNNUM',     /* 64 */
              'UN',        /* 65 */
              (5)(1)' ');
         DCL NUMCKARY(0:70) BIT(16) INIT(
              '0'B,          /*  0 - INVALID */
              '0'B,          /*  1 - PANEL */
              '0'B,          /*  2 - P */
              '0'B,          /*  3 - SAVE */
              '0'B,          /*  4 - S */
              '0'B,          /*  5 - SF */
              '0'B,          /*  6 - SB */
              '0'B,          /*  7 - SE */
              '01'B,         /*  8 - SCAN */
              '01'B,         /*  9 - SC */
              '01'B,         /* 10 - MD */
              '01'B,         /* 11 - INSERT */
              '01'B,         /* 12 - IN */
              '01'B,         /* 13 - I */
              '01'B,         /* 14 - IF */
              '01'B,         /* 15 - IB */
              '0'B,          /* 16 - X */
              '0'B,          /* 17 - TOP */
              '0'B,          /* 18 - T */
              '0'B,          /* 19 - BOTTOM */
              '0'B,          /* 20 - BOT */
              '0'B,          /* 21 - B */
              '01'B,         /* 22 - UP */
              '01'B,         /* 23 - DOWN */
              '001'B,        /* 24 - FIND */
              '001'B,        /* 25 - F */
              '001'B,        /* 26 - FF */
              '001'B,        /* 27 - FB */
              '011'B,        /* 28 - COLUMN */
              '011'B,        /* 29 - COL */
              '01'B,         /* 30 - TRUNCATE */
              '01'B,         /* 31 - TRUNC */
              '01'B,         /* 32 - TR */
              '011'B,        /* 33 - DELETE */
              '011'B,        /* 34 - DEL */
              '011'B,        /* 35 - D */
              '011'B,        /* 36 - BLANK */
              '011'B,        /* 37 - BL */
              '0111'B,       /* 38 - MOVE */
              '0111'B,       /* 39 - MO */
              '01111'B,      /* 40 - COPY */
              '01111'B,      /* 41 - CO */
              '01'B,         /* 42 - CHANGE */
              '01'B,         /* 43 - C */
              '0'B,          /* 44 - REFRESH */
              '01'B,         /* 45 - PF */
              '01'B,         /* 46 - PB */
              '011'B,        /* 47 - RENUM */
              '011'B,        /* 48 - REN */
              '0'B,          /* 49 - END */
              '00111'B,      /* 50 - MERGE */
              '00111'B,      /* 51 - M */
              '0'B,          /* 52 - SUBMIT */
              '0'B,          /* 53 - SUB */
              '0'B,          /* 54 - TABK */
              '0111111111111111'B, /* 55 - TAB */
              '0'B,          /* 56 - HELP */
              '0'B,          /* 57 - HF */
              '0'B,          /* 58 - HB */
              '0'B,          /* 59 - H */
              '0'B,          /* 60 - DUMP */
              '0'B,          /* 61 - XF */
              '0'B,          /* 62 - XB */
              '0'B,          /* 63 - SX */
              '0'B,          /* 64 - UNNUM */
              '0'B,          /* 65 - UN */
              (5)(1)'0'B);
         DCL NUMCKA(0:70,16) BIT(1) UNALIGNED DEF NUMCKARY;
         DCL CMDINDX FIXED BIN(15,0);
         DCL PFPB CHAR(2) INIT('PF');
         DCL (REFSW,RENSW) BIT(1) INIT('0'B);
         DCL REPSW BIT(1);
         DCL SAVDDN CHAR(8);
         DCL TABK CHAR(1) VAR INIT('Ö');
         DCL TABPTR PTR;
         DCL TABNUM FIXED BIN(15,0);
         DCL SEQSTRT FIXED BIN INIT(10);
         DCL SEQINCR FIXED BIN INIT(10);
         DCL SEQINCK FIXED BIN(31,0) INIT(0);
         DCL SEQINST CHAR(80) VARYING;
         DCL OUT FILE RECORD OUTPUT ENV(RECSIZE(80));
         DO I = 1 TO 16 WHILE(PNLNAM(I)^='');
              IF SETPNL(I)^=0
                   THEN DO;
                        PUT EDIT('ERROR IN ACCESSING PANEL',PNLNAM(I))
                          (A,A) SKIP(1);
                        SIGNAL ERROR;
                        END;
              END;
 SETPNL:  PROC(I) RETURNS(FIXED BIN);
         DCL I FIXED;
         IF PNLDDN ^= '' & DCBPTR = NULL
              THEN DO;
                   CALL SYSDCBP(DCBPTR,PNLDDN);
                   CALL SYSOPEN(DCBPTR,'INPUT');
                   END;
         IF SUBSTR(PNLNAM(I),1,2)^='DE' & DCBPTR^=NULL
              THEN CALL SYSLOAD(PNLNAM(I),EPPTR(I),DCBPTR);
              ELSE CALL SYSLOAD(PNLNAM(I),EPPTR(I));
         CALL SYSLINK(PNLNAM(I),LINKRET,PNLSTAPT(I),
                PNLDYNPT(I),DESPTR(I));
         IF LINKRET ^= 0
              THEN RETURN(0);
         IF DESPTR(I)->SEQLEN > 0
              THEN DO;
                   CSEQOFF = DESPTR(I)->SEQOFF;
                   CSEQLEN = DESPTR(I)->SEQLEN;
                   END;
         DYNPTR = PNLDYNPT(I);
         PNLPTR = PNLSTAPT(I);
         SFLDPTR = ADDR(FLDLOC);
         DO J = 1 TO FLDCNT WHILE(SUBSTR(FLAGS,3,1));
              WRKPTR = SFLDPTR;
                   /*SAVE POTENTIAL CARD IMAGE FIELD PTR */
              SFLDADJ = SFLDADJ + FLDLEN;
              END;
         DFLDPTR = DYNPTR;
         DFLDADJ = DFLDADJ+DOUTOF+WRKPTR->OUTOFF;
         IMAGPTR(I) = DFLDPTR;
         IMAGNUM(I) = WRKPTR->FLDNUM;
         /* SFLDPTR = A(1ST UNPROTECTED FIELD) */
         DFLDPTR = DYNPTR;
         DFLDADJ = DFLDADJ+DINOF+INOFF;
         CMDPTR(I) = DFLDPTR;
         DFLDPTR = DYNPTR;
         DFLDADJ = DFLDADJ + DOUTOF + OUTOFF;
         CMDOPTR(I) = DFLDPTR;
         SFLDADJ = SFLDADJ + FLDLEN;
         MSGNUM(I) = FLDNUM;
         DFLDPTR = DYNPTR;
         DFLDADJ = DFLDADJ + DOUTOF + OUTOFF;
         MSGPTR(I) = DFLDPTR;
         SFLDADJ = SFLDADJ + FLDLEN;
         IF I = 1 /* SCAN PANEL? */
              THEN DO;
                   DFLDPTR=DYNPTR;
                   DFLDADJ=DFLDADJ+DOUTOF+OUTOFF;
                   TABPTR=DFLDPTR;
                   TABNUM=FLDNUM;
                   END;
         DO J = 1 TO INCNT WHILE(SUBSTR(FLAGS,3,1));
              SFLDADJ = SFLDADJ + FLDLEN;
              END;
         /* SFLDPTR = A(1ST RECORD INPUT FIELD) */
         INPTR(I) = SFLDPTR;
         IF PNLNAM(I+1)=''
              THEN DO;
                   DESTRPTR = DESPTR(1); /*POINT AT SCAN DESTR*/
                   DINCNT = 1;
                   IF I > 1
                        THEN DO;
                             SEQOFF = CSEQOFF;
                             SEQLEN = CSEQLEN;
                             END;
                        ELSE DO;
                             SEQOFF,CSEQOFF = 72;
                             SEQLEN,CSEQLEN = 8;
                             END;
                   IF SEQOFF > 0
                        THEN COLUMN = 1;
                        ELSE COLUMN = SEQLEN;
                   TRUNCATE = 73;
                   IF SEQOFF+SEQLEN = 80 /* SEQ AT END OF RECORD? */
                        THEN IF SEQOFF < 73
                             THEN TRUNCATE = SEQOFF;
                   CALL COLTR;/*GO SET DISPLAY FOR NEW COL/TRUNC*/
                   END;
         RETURN(0);
         END SETPNL;
         @CURPNL = 0;
         @NXTPNL = 1;
         @ARYPTR = ADDR(ARYCNT);
         @CHGCURS = -1;
         @CALLFLGS = '0'B;
         DCL IN FILE RECORD INPUT;
         IF INDDN ^= ''
              THEN DO;
                   @CURPNL = 1;
                   DESTRPTR = DESPTR(1);
                   PNLPTR = PNLSTAPT(1);
                   DYNPTR = PNLDYNPT(1);
                   CALL REFRESH;
                   @CURPNL = 0;
                   END;
         ON ATTENTION BEGIN;
              @CURPNL = 0;
              GO TO NEWPNL;
              END;
 NEWPNL:
         DESTRPTR = DESPTR(@NXTPNL);
         PNLPTR = PNLSTAPT(@NXTPNL);
         DYNPTR = PNLDYNPT(@NXTPNL);
 NXT:
         MSGPTR(@NXTPNL)->DATA='';
         IF SCANFLAG
              THEN CMDOPTR(@NXTPNL)->DATA=PFPB;
              ELSE CMDOPTR(@NXTPNL)->DATA='';
 NXTA:
         OUTFLAG(MSGNUM(@NXTPNL))='1'B;
         SCANPTR = RECPTR;
         SFLDPTR = INPTR(@NXTPNL);
         IF SCANFLAG & (RECPTR->LSTPTR = HDPTR)
              THEN DO;
                   PFPB = 'PF';
                   CMDOPTR(@NXTPNL)->DATA=PFPB;
                   END;
         IF @NXTPNL = 1
              THEN J = 2;
              ELSE J = 1;
         LNCNT,K = 0;
         DO I = 1 TO INCNT-1;
              DO M = 1 TO J;
                 DFLDPTR = DYNPTR;
                 DFLDADJ = DFLDADJ + DOUTOF + OUTOFF;
                 IF @NXTPNL = 1 /* SCAN PANEL?*/ & M = 1
                   THEN DO;
                        IF SCANFLAG
                             THEN DO;
                                  IF SCANPTR^=HDPTR
                                       THEN DO;
                                         SEQPIC = SCANPTR->RECSEQ;
                                         IF SCANPTR->NXTPTR = HDPTR
                                              THEN N = RECSEQ;
                                         END;
                                       ELSE DO;
                                            SEQBL = '';
                                            PFPB = 'PB';
                                            CMDOPTR(@NXTPNL)->DATA=PFPB;
                                            END;
                                  END;
                             ELSE DO;
                                  N = I/2;
                                  N = CURSEQ + N;
                                  N = N + 1;
                                  SEQPIC = N;
                                  END;
                        DATA = SUBSTR(SEQPIC,4,5);
                        OUTFLAG(FLDNUM) = '1'B; /* FORCE WRITE */
                        IF ^SCANFLAG
                          THEN SUBSTR(FLAGS,3,2)='11'B;/*PROTECT FIELD*/
                          ELSE SUBSTR(FLAGS,3,2)='00'B;/*UNPROTECT FLD*/
                        I = I + 1;
                        END;
                   ELSE IF ^SUBSTR(FLAGS,3,1) /*UNPROTECTED?*/
                        THEN DO;
                             IF ^SCANFLAG × SCANPTR = HDPTR
                               THEN DATA = '';
                               ELSE ASGN: DO;
                                 K = K + 1;
                                 IF @NXTPNL = 1
                                   THEN DATA=SUBSTR(SCANPTR->RECSTR,
                                     COLUMN,SCANLEN);
                                   ELSE DATA=SUBSTR(SCANPTR->RECSTR,
                                     CARDOFF(K)+1,LEN);
                                 DATA=SUBSTR(DATA,1,SUFFIX(DATA,' '));
                                 IF K = DINCNT
                                      THEN DO;
                                           K = 0;
                                           LNCNT = LNCNT + 1;
                                           SCANPTR = SCANPTR->NXTPTR;
                                           END;
                                 END;
                             END;
                 SFLDADJ = SFLDADJ + FLDLEN;
                 END;
              END;
         SEQPIC = CURSEQ + 1;
         DFLDPTR = IMAGPTR(@NXTPNL);
         SUBSTR(DATA,SEQOFF+1,SEQLEN) = SUBSTR(SEQPIC,9-SEQLEN);
         OUTFLAG(IMAGNUM(@NXTPNL)) = '1'B;
         CALL SCRWRIT(@PNLCALL);
         CMDOPTR(@CURPNL)->DATA='';
         SFLDPTR = INPTR(@CURPNL);
         SAVPTR = RECPTR;
         PARY(*) = '';
         DELIND = 0;
         BIGALTSW = '0'B;
 INLUP:  DO FOREVER=1 REPEAT FOREVER;
              ALTSW = '0'B;
              I = I + DINCNT - 1;
              DO K = 1 TO DINCNT;
                   DO WHILE(SUBSTR(FLAGS,3,1));/*DO WHILE UNPROTECTED*/
                        IF FLDNUM = FLDCNT
                             THEN LEAVE INLUP;
                        SFLDADJ = SFLDADJ + FLDLEN;
                        END;
         DELCK:  DO;
                   IF @CURPNL = 1 /*SCAN PANEL?*/
                     THEN IF SCANFLAG
                       THEN DO;
                         DFLDPTR=DYNPTR; /*POINT TO SEQ FIELD*/
                         DFLDADJ=DFLDADJ+DINOF+INOFF;
                         SFLDADJ=SFLDADJ+FLDLEN; /*SKIP OVER SEQ FLD */
                         IF DATA ^= ''
                           THEN DO;
                             D=INDEX(DATA,'DD');
                             IF D > 0
                               THEN DO;
                                 BIGALTSW = '1'B;
                                 DELIND=DELIND+1;
                                 PARY(DELIND+1)=SAVPTR->RECSEQ;
                                 IF DELIND = 2
                                   THEN DO;
                                     SAVPTR=DELPTR;
                                     CALL DELPROC;
                                     DELIND = 0;
                                     PARY(2),PARY(3) = '';
                                     END;
                                   ELSE DELPTR = SAVPTR->LSTPTR;
                                 LEAVE DELCK;
                                 END;
                             IF DELIND = 0
                               THEN DO;
                                 D=INDEX(DATA,'D');
                                 IF D > 0
                                   THEN DO;
                                     BIGALTSW = '1'B;
                                     PARY(2)=SAVPTR->RECSEQ;
                                     SAVPTR = SAVPTR->LSTPTR;
                                     CALL DELPROC;
                                     PARY(2) = '';
                                     LEAVE DELCK;
                                     END;
                                 END;
                             END;
                         END;
                   DFLDPTR = DYNPTR;
                   DFLDADJ = DFLDADJ + DINOF + INOFF;
                   IF @CURPNL = 1
                        THEN TLEN = SCANLEN;
                        ELSE TLEN = LEN;
                   IF DATA = ''
                        THEN IF ^SUBSTR(FLAGS,2,1)
                          /* NOT AUTODUP? */
                            THEN SUBSTR(CARDIMAGE,CARDOFF(K)+1,TLEN)='';
                             ELSE;
                        ELSE DO;
                             ALTSW = '1'B;
                             IF @CURPNL = 1
                                  THEN IF TABK^=''
                                       THEN CALL DOTAB;
                             IF SCANFLAG & SAVPTR^=HDPTR
                               THEN SUBSTR(SAVPTR->RECSTR,CARDOFF(K)+1,
                                 TLEN)=DATA;
                               ELSE SUBSTR(CARDIMAGE,CARDOFF(K)+1,TLEN)
                                 =DATA;
                             END;
                      END DELCK;
                   IF FLDNUM = FLDCNT
                        THEN LEAVE INLUP;
                   SFLDADJ = SFLDADJ + FLDLEN;
                   END;
              IF ALTSW
                   THEN DO;
                        BIGALTSW = '1'B;
                        /*SET SEQUENCE FIELD HERE */
                        IF ^SCANFLAG /*INSERT MODE?*/
                             THEN DO;
                                  SAVPTR = ADDREC(SAVPTR);
                                  CALL NEWCUR(SAVPTR);
                                  END;
                             ELSE IF SAVPTR = HDPTR
                                  THEN SAVPTR = ADDREC(LSTHDR);
                        END;
              IF SCANFLAG
                   THEN SAVPTR = SAVPTR->NXTPTR;
              END;
         DFLDPTR = CMDPTR(@CURPNL);
         IF DATA ^= ''
              THEN DO;
                   CALL PARS;
                   GO TO CMDLAB(CMDINDX);
                   END;
              ELSE IF SCANFLAG & ^BIGALTSW
                   THEN DO;
                        PARY(1) = PFPB;
                        IF PFPB = 'PF'
                             THEN GO TO PF;
                             ELSE GO TO PB;
                        END;
         GO TO NXT;
 CMDLAB(0): /* INVALID SUBCMD */
         MSGPTR(@CURPNL)->DATA='INVALID SUBCOMMAND';
         GO TO NXTA;
 CMDLAB(1):  /* PANEL */
 CMDLAB(2):  /* P */
         I = VERIFY(PARY(2),'0123456789');
         IF I=0
              THEN @NXTPNL = PARY(2);
              ELSE DO;
                   DO I=1 TO 16 WHILE(PNLNAM(I)^=''&PNLNAM(I)^=PARY(2));
                        END;
                   IF I > 15
                        THEN DO;
                             MSGPTR(@CURPNL)->DATA='TOO MANY PANELS';
                             GO TO NXTA;
                             END;
                   IF PNLNAM(I)=''
                        THEN DO;
                             PNLNAM(I) = PARY(2);
                             IF SETPNL(I) ^= 0
                                  THEN DO;
                                       PNLNAM(I) = '';
                                       MSGPTR(@CURPNL)->DATA='PANEL '××
                                        PARY(2)××' NOT FOUND';
                                       GO TO NXTA;
                                       END;
                             END;
                   @NXTPNL = I;
                   END;
         GO TO NEWPNL;
 CMDLAB(3):  /* SAVE */
 CMDLAB(4):  /* S */
 CMDLAB(5):  /* SF */
 CMDLAB(6):  /* SB */
 CMDLAB(7):  /* SE */
 CMDLAB(63): /* SX */
         IF PARY(2) ^= ''
              THEN DO;
                   CALL DOFRE(OUTDDN);
                   OUTDDN=DOALC(PARY(2),'OUT');
                   IF OUTDDN = ''
                        THEN DO;
                             MSGPTR(@CURPNL)->DATA='SAVE UNSUCCESSFUL';
                             GO TO NXTA;
                             END;
                   END;
         CALL RESEQ(HDPTR);
         IF CMDINDX = 7 /* SE? */
              THEN DO;
 ENDCMD:
                   @CALLFLGS = '01'B;
                   CALL SCRWRIT(@PNLCALL);
                   IF DCBPTR ^= NULL
                        THEN CALL SYSCLOS(DCBPTR);
 /*                CALL IDLESUB('END');
 */                RETURN;
                   END;
         MSGPTR(@CURPNL)->DATA='SAVED';
         IF CMDINDX = 63 /* SX ? */
              THEN DO;
                   PARY(2) = '';
                   GO TO X;
                   END;
         GO TO NXTA;
 CMDLAB(8):  /* SCAN */
 CMDLAB(9):  /* SC */
         SCANFLAG = '1'B;
         CALL RESEQ(HDPTR);
         IF PARY(2) ^= ''
              THEN GO TO MD;
         GO TO NXT;
 MD:
 CMDLAB(10):  /* MD */
         CALL MDPROC;
         GO TO NXT;
 MDPROC: PROC;
         DCL I FIXED;
         I = PARY(2);  /* I = NEW SEQ */
         IF CURSEQ < I
              THEN DO WHILE(NXTPTR^=HDPTR & RECSEQ<I);
                   CALL NEWCUR(NXTPTR);
                   END;
         IF CURSEQ > I
              THEN DO WHILE(LSTPTR^=HDPTR & RECSEQ>I);
                   CALL NEWCUR(LSTPTR);
                   END;
         END MDPROC;
 CMDLAB(11):  /* INSERT */
 CMDLAB(12):  /* IN */
 CMDLAB(13):  /* I */
 CMDLAB(14):  /* IF */
 CMDLAB(15):  /* IB */
         SCANFLAG = '0'B;
         IF PARY(2) = ''  /* IF NO SEQ SPECIFIED */
              THEN GO TO NXT;  /* THEN INSERT AT CURRENT LOCATION */
              ELSE IF PARY(2) = 0
                   THEN CALL NEWCUR(HDPTR);
                   ELSE GO TO MD;
         GO TO NXT;
 CMDLAB(16):  /* X */
 CMDLAB(61):  /* XF */
 CMDLAB(62):  /* XB */
 X:
         IF PARY(2)=''
              THEN CMDSTR = '';
              ELSE CMDSTR = PARY(2)××' '××PARY(3)××' '××PARY(4)××' '××
                PARY(5)××' '××PARY(6);
 XMODE:
         @CALLFLGS = '01000000'B;
         CALL SCRWRIT(@PNLCALL);
         @CURPNL = 0;
         IF CMDSTR=''
              THEN CMDSTR = DOPRM('DENT');
         DO UNTIL(CMDSTR='');
              CALL DOCMD(CMDSTR,HELPSTR);
              CMDSTR = DOPRM('DENT');
              END;
         HELPSTR = '';
         GO TO NEWPNL;
 CMDLAB(17): /* TOP */
 CMDLAB(18): /* T */
         CALL NEWCUR(NXTHDR);
         PFPB = 'PF';
         GO TO NXT;
 CMDLAB(19): /* BOTTOM */
 CMDLAB(20): /* BOT */
 CMDLAB(21): /* B */
         CALL NEWCUR(LSTHDR);
         PFPB = 'PB';
         GO TO NXT;
 UP:
 CMDLAB(22): /* UP */
         IF PARY(2) = ''
              THEN I = 1; /* DEFAULT IS 1 */
              ELSE I = PARY(2);
         DO I = I TO 1 BY -1 WHILE(LSTPTR^=HDPTR);
              CALL NEWCUR(LSTPTR);
              END;
         GO TO NXT;
 DOWN:
 CMDLAB(23):  /* DOWN */
         IF PARY(2) = ''
              THEN I = 1; /* DEFAULT IF 1 */
              ELSE I = PARY(2);
         DO I = I TO 1 BY -1 WHILE(NXTPTR ^= HDPTR);
              CALL NEWCUR(NXTPTR);
              END;
         GO TO NXT;
 CMDLAB(24): /* FIND */
 CMDLAB(25): /* F */
 CMDLAB(26): /* FF */
 CMDLAB(27): /* FB */
         I = PARY(3);
         K = LENGTH(PARY(2));
         IF K > 0
              THEN DO;
                   FINDTEXT = PARY(2);
                   SAVPTR = RECPTR;
                   END;
              ELSE DO;
                   IF LENGTH(FINDTEXT) = 0
                        THEN DO;
                             MSGPTR(@CURPNL)->DATA = 'FIND WHAT?';
                             GO TO NXTA;
                             END;
                   SAVPTR = RECPTR->NXTPTR;
                   END;
         DO WHILE(SAVPTR ^= HDPTR);
              IF I = 0
                   THEN J = INDEX(SAVPTR->RECSTR,FINDTEXT);
                   ELSE IF SUBSTR(SAVPTR->RECSTR,I,K) = FINDTEXT
                        THEN J = 1;
                        ELSE J = 0;
              IF J ^= 0
                   THEN DO;
                        CALL NEWCUR(SAVPTR);
                        GO TO NXT;
                        END;
              SAVPTR = SAVPTR->NXTPTR;
              END;
 NOTXT:
         CMDOPTR(@CURPNL)->DATA=CMDPTR(@CURPNL)->DATA;
         MSGPTR(@CURPNL)->DATA = 'TEXT NOT FOUND';
         GO TO NXTA;
 CMDLAB(28): /* COLUMN */
 CMDLAB(29): /* COL */
         COLUMN = PARY(2);
         IF PARY(3) ^= ''
              THEN TRUNCATE = PARY(3);
         CALL COLTR;
         GO TO NXT;
 CMDLAB(30): /* TRUNCATE */
 CMDLAB(31): /* TRUNC */
 CMDLAB(32): /* TR */
         TRUNCATE = PARY(2);
         CALL COLTR;
         GO TO NXT;
 CMDLAB(33): /* DELETE */
 CMDLAB(34): /* DEL */
 CMDLAB(35): /* D */
         CALL DELPROC;
         GO TO NXT;
 DELPROC:  PROC;
         SAVSEQ = CURSEQ;
         CALL MDPROC; /*GO MOVE DISPLAY TO 1ST LINE TO DELETE*/
         IF RECPTR = HDPTR
              THEN CALL NEWCUR(NXTHDR);
         S = PARY(2);
         IF PARY(3) = ''
              THEN E = S;
              ELSE E = PARY(3);
 DELP:   DO WHILE(RECPTR ^= HDPTR);
              IF RECSEQ > E
                   THEN LEAVE DELP;
              CALL PUTSLOT(RECPTR);
              END;
         IF RECPTR ^= HDPTR
              THEN CALL RESEQ(LSTPTR);
         PARY(2) = SAVSEQ;
         CALL MDPROC; /* GO MOVE DISPLAY */
         END DELPROC;
 CMDLAB(36):  /* BLANK */
 CMDLAB(37):  /* BL */
         IF PARY(2) = 0
              THEN CALL NEWCUR(HDPTR);
              ELSE CALL MDPROC;
         IF PARY(3) = ''
              THEN I = 1; /* DEFAULT IS 1 */
              ELSE I = PARY(3);
         CARDIMAGE = '';
         SAVPTR = RECPTR;
         DO I = I TO 1 BY -1;
              SAVPTR = ADDREC(SAVPTR);
              END;
         CALL RESEQ(SAVPTR->LSTPTR);
         IF CURSEQ = 0
              THEN CALL NEWCUR(NXTHDR);
         GO TO NXT;
 CMDLAB(38):  /* MOVE */
 CMDLAB(39):  /* MO */
 CMDLAB(40):  /* COPY */
 CMDLAB(41):  /* CO */
         IF PARY(4) = ''
              THEN DO M = 4 TO 3 BY -1;
                   PARY(M) = PARY(M-1);
                   END;
         DO M = 1 TO 3;
              PARY(2) = PARY(M+1);
              IF PARY(2) = 0
                   THEN CALL NEWCUR(HDPTR);
                   ELSE CALL MDPROC;
              MPTR(M) = RECPTR;
              MSEQ(M) = CURSEQ;
              END;
         IF MSEQ(1) < MSEQ(3)
              THEN DELPTR = MPTR(1)->LSTPTR;
              ELSE DELPTR = MPTR(3);
         IF CMDINDX < 40
              THEN DO; /* IT IS MOVE */
                   /* FIRST DEQUEUE RECORDS TO BE MOVE */
                   MPTR(1)->LSTPTR->NXTPTR=MPTR(2)->NXTPTR;
                   MPTR(2)->NXTPTR->LSTPTR=MPTR(1)->LSTPTR;
                   /* NOW ENQUEUE AT NEW LOCATION */
                   MPTR(1)->LSTPTR=MPTR(3);
                   MPTR(2)->NXTPTR=MPTR(3)->NXTPTR;
                   MPTR(1)->LSTPTR->NXTPTR=MPTR(1);
                   MPTR(2)->NXTPTR->LSTPTR=MPTR(2);
                   DO SAVPTR=MPTR(1) REPEAT SAVPTR->NXTPTR
                     UNTIL(SAVPTR=MPTR(2));
                        SAVPTR->RECSEQ=0;
                     END;
                   END;
              ELSE DO;
                   COPTR = RECPTR;
                   IF PARY(5) = ''
                        THEN I = 1;
                        ELSE I = PARY(5);
                   DO J = 1 TO I;
                        DO SAVPTR=MPTR(1) REPEAT
                          SAVPTR->NXTPTR UNTIL(SAVPTR=MPTR(2));
                             CARDIMAGE = SAVPTR->RECSTR;
                             COPTR = ADDREC(COPTR);
                             END;
                        END;
                   END;
         CALL RESEQ(DELPTR);
         IF MPTR(3) = HDPTR
              THEN CALL NEWCUR(NXTHDR);
              ELSE CALL NEWCUR(MPTR(3));
         GO TO NXT;
 CMDLAB(42):  /* CHANGE */
 CMDLAB(43):  /* C */
         IF PARY(5) = ''
              THEN DO I = 5 TO 3 BY -1;
                   PARY(I) = PARY(I-1);
                   END;
         IF PARY(2) = '*'
              THEN DO;
                   PARY(2) = CURSEQ;
                   IF PARY(3) ^= '*'
                        THEN DO;
                             I = PARY(3);
                             I = I + CURSEQ;
                             PARY(3) = I;
                             END;
                   END;
         IF PARY(3) = '*'
              THEN PARY(3) = PARY(2);
         CALL MDPROC;  /* GO MOVE DISPLAY */
         I = PARY(3);
         REPSW = '0'B;
         DO SAVPTR=RECPTR REPEAT SAVPTR->NXTPTR WHILE(SAVPTR ^= HDPTR);
              IF SAVPTR->RECSEQ > I
                   THEN GO TO REPCK;
              REPSORC = SUBSTR(SAVPTR->RECSTR,COLUMN,SCANLEN);
              CALL REPLACE(REPSORC,PARY(4),PARY(5),REPRET,'ALL');
              IF REPRET ^= '00'B
                   THEN DO;
                        SUBSTR(SAVPTR->RECSTR,COLUMN,SCANLEN)=REPSORC;
                        REPSW = '1'B;
                        END;
              END;
 REPCK:
         IF ^REPSW
              THEN GO TO NOTXT;
         GO TO NXT;
 CMDLAB(44):  /* REFRESH */
         CALL REFRESH;
         GO TO NXT;
 REFRESH:  PROC;
         REFSW = '1'B;
         DO WHILE(NXTHDR^=HDPTR);
              CALL PUTSLOT(NXTHDR);
              END;
         IF INDDN ^= ''
              THEN DO;
                   OPEN FILE(IN) TITLE(INDDN);
                   ON ENDFILE(IN) GO TO ENDINP;
                   DO I = 1 REPEAT I+1;
                        READ FILE(IN) INTO(CARDIMAGE);
                        SEQINST=SUBSTR(CARDIMAGE,SEQOFF+1,SEQLEN);
                        IF ^RENSW
                             THEN IF VERIFY(SEQINST,'0123456789')^=0
                                  THEN RENSW = '1'B;
                                  ELSE DO;
                                       J = SEQINST;
                                       IF J <= SEQINCK
                                            THEN RENSW = '1'B;
                                            ELSE DO;
                                                 SEQINCK=J;
                                                 IF SEQINCK>99999
                                                     THEN RENSW = '1'B;
                                                 END;
                                       END;
                        RECPTR = ADDREC(RECPTR);
                        END;
 ENDINP:
                   CLOSE FILE(IN);
                   CMDINDX = 0;
                   IF NXTHDR ^= HDPTR
                        THEN SCANFLAG = '1'B;
                   IF RENSW
                        THEN CALL RESEQ(HDPTR);
                   END;
         CALL NEWCUR(NXTHDR);
         REFSW = '0'B;
         END REFRESH;
 PF:
 CMDLAB(45):  /* PF */
         PFPB = 'PF';
         GO TO PGCOM;
 PB:
 CMDLAB(46):  /* PB */
         PFPB = 'PB';
 PGCOM:
         IF PARY(2) = ''
              THEN I = 1;
              ELSE I = PARY(2);
         IF @CURPNL = 1
              THEN LNCNT = 18;
         I = I*LNCNT;
         PARY(2) = I;
         IF PFPB = 'PB'
              THEN GO TO UP;
              ELSE GO TO DOWN;
 CMDLAB(47):  /* RENUM */
 CMDLAB(48):  /* REN */
         IF PARY(2) ^= ''
              THEN SEQSTRT = PARY(2);
         IF PARY(3) ^= ''
              THEN SEQINCR = PARY(3);
         RENSW = '1'B;
         CALL RESEQ(HDPTR);
         GO TO NXT;
 CMDLAB(49):  /* END */
         GO TO ENDCMD;
 CMDLAB(50):  /* MERGE */
 CMDLAB(51):  /* M */
         MDSN = PARY(2);
         DO I = 5 TO 4 BY -1 WHILE(PARY(I)='');
              END;
         PARY(2) = PARY(I);
         IF PARY(2) ^= '*'
              THEN IF PARY(2) = 0
                   THEN CALL NEWCUR(HDPTR);
                   ELSE CALL MDPROC;
         IF I > 3
              THEN DO;
                   MSTRT = PARY(3);
                   IF I > 4
                        THEN MEND = PARY(4);
                        ELSE MEND = 99999999;
                   END;
              ELSE DO;
                   MSTRT = 0;
                   MEND = 99999999;
                   END;
         MDDN = DOALC(MDSN,'IN');
         IF MDDN = ''
              THEN DO;
                   MSGPTR(@CURPNL)->DATA='ALLOCATE FAILED';
                   GO TO NXTA;
                   END;
         SAVPTR = RECPTR;
         OPEN FILE(IN) TITLE(MDDN);
         ON ENDFILE(IN) GO TO ENDMIN;
 MER:    DO I=1 REPEAT I+1;
              READ FILE(IN) INTO(CARDIMAGE);
              J = SUBSTR(CARDIMAGE,SEQOFF+1,SEQLEN);
              IF J >= MSTRT & J <= MEND
                   THEN SAVPTR = ADDREC(SAVPTR);
                   ELSE IF J > MEND
                        THEN LEAVE MER;
              END;
 ENDMIN:
         CLOSE FILE(IN);
         CALL DOFRE(MDDN);
         CALL RESEQ(RECPTR);
         GO TO NXT;
 CMDLAB(52):  /* SUBMIT */
 CMDLAB(53):  /* SUB */
         SAVDDN = OUTDDN;
         OUTDDN=DOALC('BPRT.CNTL','INO');
         IF OUTDDN = ''
              THEN DO;
                   MSGPTR(@CURPNL)->DATA='ERROR IN ALLOCATE';
                   OUTDDN = SAVDDN;
                   GO TO NXTA;
                   END;
         CMDINDX=3; /* FOOL RESEQ */
         CALL RESEQ(HDPTR);
         @CALLFLGS = '01'B;
         CALL SCRWRIT(@PNLCALL);
         @CURPNL = 0;
         CALL DOCMD('SUBMIT BPRT.CNTL','');
         CALL DOCMD('DELETE BPRT.CNTL','');
         OUTDDN = SAVDDN;
         CMDSTR = '';
         GO TO XMODE;
 CMDLAB(54):  /* TABK */
         TABK = PARY(2);
         CALL TABDISP;
         GO TO NXT;
 CMDLAB(55):  /* TAB */
         IF TABK = ''
              THEN TABK = 'Ö';
         DO I = 2 TO 16;
              TABA(I-1)=PARY(I);
              END;
         CALL TABDISP;
         GO TO NXT;
 CMDLAB(56):  /* HELP */
 CMDLAB(57):  /* HF */
 CMDLAB(58):  /* HB */
 CMDLAB(59):  /* H */
         HELPSTR = 'HELP';
         CMDSTR = 'HELP '××PARY(2)××' '××PARY(3)××' '××PARY(4);
         GO TO XMODE;
 CMDLAB(60):  /* DUMP */
         CALL PLIDUMP('TFCHNB');
         GO TO NXT;
 CMDLAB(64):  /* UNNUM */
 CMDLAB(65):  /* UN */
         DO WRKPTR=NXTHDR REPEAT WRKPTR->NXTPTR WHILE(WRKPTR^=HDPTR);
              SUBSTR(WRKPTR->RECSTR,SEQOFF+1,SEQLEN)='';
              END;
         SEQLEN = 0;
         GO TO NXT;
 CMDLAB(66):  /* UNASSIGNED */
 CMDLAB(67):  /* UNASSIGNED */
 CMDLAB(68):  /* UNASSIGNED */
 CMDLAB(69):  /* UNASSIGNED */
 CMDLAB(70):  /* UNASSIGNED */
         GO TO NXT;
 /* ADDREC
 THIS SUBROUTINE IS USED TO ADD A RECORD TO THE ARRAY OF RECORDS.  THE
 SINGLE PARAMETER MUST BE A POINTER VARIABLE CONTAINING THE ADDR OF THE
 RECORD BEHIND WHICH THE RECORD IS TO BE ADDED.  CARDIMAGE MUST CONTAIN
 RECORD TO BE ADDED. */
 ADDREC:  PROC(PRMPTRPTR) RETURNS(PTR);
         DCL (PRMPTRPTR,PRMPTR,TMPPTR) PTR;
         PRMPTR = PRMPTRPTR;
         DCL I FIXED BIN(15,0);
         TMPPTR = GETSLOT(PRMPTR);
         IF REFSW & ^RENSW
              THEN TMPPTR->RECSEQ = SEQINCK;
              ELSE DO;
                   IF PRMPTR = HDPTR
                        THEN I = 1;
                        ELSE I = PRMPTR->RECSEQ+1;
                   TMPPTR->RECSEQ = I;
                   IF SEQLEN > 0
                        THEN DO;
                             SEQPIC = I;
                             SUBSTR(CARDIMAGE,SEQOFF+1,SEQLEN) =
                              SUBSTR(SEQPIC,9-SEQLEN);
                             END;
                   END;
         TMPPTR->RECSTR = CARDIMAGE;
         TMPPTR->RECPNLN = @CURPNL;
         TMPPTR->RECFLGS = '0'B;
         RETURN(TMPPTR);
         END;
 /* GETSLOT
 THIS SUBROUTINE IS INVOKED WHEN A NEW SLOT IS TO BE ACQUIRED FROM
 THE ARRAY OF RECORDS.  RECPTR MUST CONTAIN THE ADDRESS OF THE SLOT
 BEHIND WHICH THE NEW RECORD IS TO BE ADDED.  IF IT IS THE FIRST
 RECORD TO BE ADDED TO THE ARRAY, OR IF THE NEW SLOT IS TO BE
 INSERTED AT THE FRONT OF THE ARRAY, RECPTR SHOULD CONTAINT THE ADDRESS
 OF THE CONTROL HEADER. */
 GETSLOT:  PROC(RECPTR) RETURNS(PTR);
         DCL RECPTR PTR;
         DCL TMPPTR PTR;
         ALLOCATE REC IN(RECAREA) SET(TMPPTR);
         TMPPTR->LSTPTR = RECPTR;
         TMPPTR->NXTPTR = RECPTR->NXTPTR;
         TMPPTR->LSTPTR->NXTPTR = TMPPTR;
         TMPPTR->NXTPTR->LSTPTR = TMPPTR;
         RETURN(TMPPTR);
         END GETSLOT;
 /* PUTSLOT
 THIS SUBROUTINE IS INVOKED WHEN A SLOT IS TO BE REMOVED FROM THE
 ARRAY OF RECORDS AND RETURNED TO THE POOL OF FREE SLOTS. */
 PUTSLOT:  PROC(PRMPTR);
         DCL PRMPTR PTR;
         DCL TMPPTR PTR;
         TMPPTR = PRMPTR;
         IF RECPTR = TMPPTR
              THEN CALL NEWCUR(TMPPTR->NXTPTR);
         TMPPTR->LSTPTR->NXTPTR = TMPPTR->NXTPTR;
         TMPPTR->NXTPTR->LSTPTR = TMPPTR->LSTPTR;
         FREE TMPPTR->REC IN(RECAREA);
         END PUTSLOT;
 COLTR:  PROC;
 /*THIS PROC IS INVOKED WHENEVER EITHER COLUMN OR TRUNCATE ARE
   CHANGED.  IT ALTERS THE DISPLAY ACCORDINGLY. */
         @NXTPNL = 1;
         DYNPTR = PNLDYNPT(1);
         PNLPTR = PNLSTAPT(1);
         DESTRPTR = DESPTR(1); /* POINT AT SCAN DESTR */
         CARDIMAGE = '';
         CARDOFF = COLUMN-1;
         SFLDPTR = ADDR(FLDLOC); /*GET FIELD DESCR FOR HEADING */
         DFLDPTR = DYNPTR;
         DFLDADJ = DFLDADJ + DOUTOF + OUTOFF;
         SCANLEN = TRUNCATE-COLUMN+1;
         IF SCANLEN > 73
              THEN SCANLEN = 73;
         DATA=(7)' '××SUBSTR(HDR1,COLUMN,SCANLEN)
           ××SUBSTR(BLNKS,1,79-SCANLEN)××SUBSTR(HDR2,COLUMN,SCANLEN);
         OUTFLAG(1) = '1'B;
         CALL TABDISP;
         END COLTR;
 PARS:  PROC;
 /* PARS - ATOMIZES THE COMMAND.  PARY(1) IS SET TO THE COMMAND
 NAME ITSELF, PARY(2) IS SET TO THE FIRST OPERAND, PARY(3) TO
 THE SECOND, ETC.  EITHER A BLANK OR A COMMA IS CONSIDERED TO
 BE A DELIMITER, EXCEPT QUOTED STRINGS ARE CONSIDERED TO BE AN ITEM
 REGARDLESS OF WHETHER THEY CONTAIN BLANKS OR NOT. */
         PARY(*) = '';
         L = LENGTH(DATA);
         I,J,K = 0;
 PLUP:  DO K = 0 TO 15 WHILE(J <= L);
              I = PREFIX(SUBSTR(DATA,J+1),' ')+J;/*GET NXT NONBLNK*/
              IF I = J
                   THEN LEAVE PLUP; /* NO MORE PARMS */
              IF SUBSTR(DATA,I,1)=''''
                   THEN DO;
                        J = I;
                        FPOST:  DO UNTIL(J > L);
                             M=INDEX(SUBSTR(DATA,J+1),'''')+J;
                             IF M = J
                                  THEN J = L+1;
                                  ELSE DO;
                                       J = M;
                                       IF J = L
                                            THEN LEAVE FPOST;
                                            ELSE IF SUBSTR(DATA,J+1,1)
                                              = ''''
                                                 THEN DO;
                                                      SUBSTR(DATA,J+1)=
                                                       SUBSTR(DATA,J+2);
                                                      L = L-1;
                                                      IF J = L
                                                       THEN J=L+1;
                                                      END;
                                                 ELSE LEAVE FPOST;
                                       END;
                             END FPOST;
                        PARY(K+1)=SUBSTR(DATA,I+1,J-I-1);
                        J = J + 1;
                        END;
                   ELSE DO;
                        J = INDEX(SUBSTR(DATA,I+1),' ')+I;
                             /*GET NXT DELIMITER*/
                        M = INDEX(SUBSTR(DATA,I+1),',')+I;
                             /*GET NXT DELIMITER*/
                        IF J = M
                             THEN J = L+1;
                             ELSE IF J = I
                                  THEN J = M;
                                  ELSE IF M > I
                                       THEN IF M < J
                                            THEN J = M;
                        PARY(K+1)=SUBSTR(DATA,I,J-I);
                        END;
              END;
         I = VERIFY(PARY(1),'0123456789');
         IF I = 0
              THEN DO; /* IT IS IMPLICIT PANEL SUBCMD */
                   PARY(2) = PARY(1);
                   PARY(1) = 'P';
                   CMDINDX = '1';
                   RETURN;
                   END;
         DO CMDINDX = 70 TO 1 BY -1 WHILE(PARY(1) ^= CMDTAB(CMDINDX));
              END;
         DO I = 1 TO 16;
              IF NUMCKA(CMDINDX,I)
                   THEN IF PARY(I)^='*'
                        THEN IF VERIFY(PARY(I),'0123456789')^=0
                             THEN DO;
                                  MSGPTR(@CURPNL)->DATA='BAD OPERAND';
                                  CMDOPTR(@CURPNL)->DATA=
                                    CMDPTR(@CURPNL)->DATA;
                                  GO TO NXTA;
                                  END;
              END;
         END PARS;
 /* RESEQ
 THIS SUBROUTINE WILL RESEQUENCE FROM THE SPECIFIED RECORD TO THE
 END OF THE ARRAY OF RECORDS.  IF PRMPTR=HDPTR, RESEQUENCING
 BEGINS WITH #1.  IF CMDINDX IS SET APPROPRIATELY, A SAVE OPERATION
 IS ALSO DONE. */
 RESEQ:  PROC(PRMPTR);
         DCL (PRMPTR,TMPPTR,DPTR) PTR;
         DCL (I,J) FIXED;
         TMPPTR = PRMPTR;
         IF CMDINDX>=3 & CMDINDX<=7 /*SAVE?*/
              THEN OPEN FILE(OUT) TITLE(OUTDDN);
         IF RENSW
              THEN J = SEQINCR;
              ELSE J = 1;
         IF TMPPTR = HDPTR
            THEN IF RENSW
              THEN I = SEQSTRT;
              ELSE I = 1;
            ELSE I = TMPPTR->RECSEQ+J;
         DO I=I REPEAT I+J WHILE(TMPPTR->NXTPTR ^= HDPTR);
              TMPPTR = TMPPTR->NXTPTR;
              IF TMPPTR->RECSEQ < I × RENSW
                   THEN TMPPTR->RECSEQ = I;
                   ELSE I = TMPPTR->RECSEQ;
              IF RECPTR = TMPPTR
                   THEN CURSEQ = I;
              DPTR = DESPTR(TMPPTR->RECPNLN);
              IF DPTR->SEQLEN > 0
                   THEN DO;
                        SEQPIC = I;
                        SUBSTR(TMPPTR->RECSTR,DPTR->SEQOFF+1,DPTR->
                          SEQLEN)=SUBSTR(SEQPIC,9-DPTR->SEQLEN);
                        END;
              IF (CMDINDX>=3 & CMDINDX<=7) × (CMDINDX=63)  /*SAVE?*/
                   THEN WRITE FILE(OUT) FROM(TMPPTR->RECSTR);
              END;
         IF CMDINDX>=3 & CMDINDX<=7 /*SAVE?*/
              THEN CLOSE FILE(OUT);
         CALL NEWCUR(RECPTR);
         RENSW = '0'B;
         RETURN;
         END RESEQ;
 /* NEWCUR
 THIS SUBROUTINE IS INVOKED TO CHANGE THE CURRENT LINE */
 NEWCUR:  PROC(PRMPTR);
         DCL PRMPTR PTR;
         RECPTR = PRMPTR;
         IF RECPTR = HDPTR
              THEN CURSEQ = 0;
              ELSE CURSEQ = RECSEQ;
         END NEWCUR;
 DOTAB: PROC;
         DCL (I,J,K) FIXED;
         I = 1;
         J = 0;
 TABLP:
         K = INDEX(SUBSTR(DATA,J+1),TABK) + J;
         IF K = J
              THEN RETURN;
         J = K;
         DO I= I TO 15 WHILE(TABA(I) < (J+COLUMN));
              END;
         IF I > 15
              THEN RETURN;
         DATA=SUBSTR(DATA,1,J-1)××SUBSTR(BLNKS,1,TABA(I)-COLUMN-J+1)
           ××SUBSTR(DATA,J+1);
         IF LENGTH(DATA)>(TRUNCATE-COLUMN+1)
              THEN DO;
                   DATA=SUBSTR(DATA,1,TRUNCATE-COLUMN+1);
                   RETURN;
                   END;
         GO TO TABLP;
         END DOTAB;
 TABDISP:  PROC;
         DCL I FIXED;
         OUTFLAG(TABNUM) = '1'B;
         DFLDPTR = TABPTR;
         DATA=(6)' ';
         DO I = 1 TO 15 WHILE(TABA(I) < COLUMN);
              END;
         IF I > 15
              THEN RETURN;
         DO I = I TO 15 WHILE((TABA(I)^=0)&(LENGTH(DATA)-6<TRUNCATE-
           COLUMN+1));
              DATA=DATA××SUBSTR(BLNKS,1,TABA(I)-LENGTH(DATA)+6-COLUMN)
                ××TABK;
              END;
         END TABDISP;
         END DATAENT;
