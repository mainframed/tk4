 /* GPRNTPDS
0*$.HE GENERALIZED UTILITIES - GPRNTPDS
0*$.HE GPRNTPDS - GENERALIZED PRINT UTILITY
0*$.PL 55
0*$.PN 0
0*$.PA
0*$.SS
0*$.NF
0*$12/6/76
0*$AUTHOR:  T. SMITH
0*$SOURCE MODULE NAME:  GPRNTPDS
0*$DOCUMENTATION ID:  0*$
0*$.FI L
0*$.SP 5
0*$THIS UTILITY CAN BE USED TO PRINT ALL MEMBERS OF A PARTITIONED
0*$DATA SET WITHOUT HAVING TO SPECIFY EACH MEMBER IN EITHER JCL
0*$UTILITY CONTROL STATEMENTS.  A SECOND OPTION ALLOWS YOU TO SCAN
0*$AN ENTIRE PDS FOR A GIVEN CHARACTER STRING, AND TO OPTIONALLY
0*$REPLACE EACH OCCURRENCE WITH A SECOND CHARACTER STRING;
0*$CALL FORMAT FOR THE SIMPLE PRINT OPTION IS AS FOLLOWS:
0*$.SP 1
0*$.IN 5
0*$.NF
0*$// EXEC PGM=GPRNTPDS,PARM='/DDD'
0*$//SYSPRINT DD SYSOUT=A
0*$//IN DD DSN=PDS,DISP=SHR
0*$//OUT DD SYSOUT=A,DCB=(LRECL=137,BLKSIZE=141,RECFM=VA)
0*$.FI L
0*$.IN 0
0*$.SP 1
0*$THE DDD IN THE PARM FIELD MUST BE A NUMBER FROM 0 TO 32767, AND
0*$INDICATES THE NUMBER OF BLANKS TO BE INSERTED IN FRONT OF EACH RECORD
0*$BEFORE IT IS PRINTED.  BLKSIZE ON THE OUT DD STATEMENT CAN OPTIONALLY
0*$BE INCREASED.  THE RECFM=VA SHOULD BE REPLACED WITH RECFM=VM IF THE
0*$CARRIAGE CONTROL SUPPLIED ON THE INPUT RECORDS IS MACHINE CONTROL
0*$RATHER THAN ASA.  IF THE INPUT DOESN'T CONTAIN CARRIAGE CONTROL,
0*$THE GPRNTPDS UTILITY WILL SUPPLY IT'S OWN.
0*$.SP 1
0*$THE VERIFY/REPLACEMENT OPTION IS USED BY SUPPLYING A SYSIN
0*$DATA SET CONTAINING A CONTROL STATEMENT DEFINING THE FUNCTION
0*$TO BE PERFORMED.  SEVERAL EXAMPLES WILL BE GIVEN TO ILLUSTRATE
0*$THE FORMAT OF THIS CONTROL STATEMENT:
0*$.SP 1
0*$.IN 5
0*$/HOW NOW BROWN COW/
0*$.IN 0
0*$THE ABOVE STATEMENT ON SYSIN WILL CAUSE EVERY RECORD IN THE
0*$PDS CONTAINING THE CHARACTER STRING "HOW NOW BROWN COW" TO
0*$BE PRINTED ON THE FILE REPRESENTED BY THE OUT DD STATEMENT.
0*$NOTE THAT THE SLASH IS A DELIMITER THAT MAY BE ANY CHARACTER
0*$OTHER THAN "L" OR "A"
0*$NOT APPEARING ANYWHERE IN THE CHARACTER STRING TO BE SCANNED FOR,
0*$AND MAY START IN ANY
0*$COLUMN OF THE INPUT RECORD.  ONLY THE FIRST 72 BYTES OF THE
0*$SYSIN RECORDS ARE USED.  AS MANY RECORDS AS ARE NEEDED TO
0*$CONTAIN ALL OF THE NECESSARY INFORMATION MAY BE PLACED ON SYSIN.
0*$.SP 1
0*$.IN 5
0*$L *HOW NOW BROWN COW*
0*$.IN 0
0*$PERFORMS EXACTLY THE SAME FUNCTION AS IN THE FIRST EXAMPLE.
0*$.SP 1
0*$.IN 5
0*$LA /HOW NOW BROWN COW/
0*$.IN 0
0*$PERFORMS THE SAME FUNCTION AS IN THE FIRST TWO EXAMPLES, EXCEPT
0*$THAT ALL RECORDS OF ALL MEMBERS WILL BE PRINTED.  THOSE RECORDS
0*$CONTAINING THE CHARACTER STRING "HOW NOW BROWN COW" WILL BE
0*$HIGHLIGHTED BY PRINTING "VER" OFFSET IN THE LEFT MARGIN.
0*$.SP 1
0*$.IN 5
0*$A #BROWN EYES#BLUE EYES#
0*$.IN 0
0*$THE ABOVE CONTROL STATEMENT WILL CAUSE EVERY OCCURRENCE OF
0*$"BROWN EYES" IN THE PDS TO BE CHANGED TO "BLUE EYES".  NOTE
0*$THAT IF THE KEYWORD "A" HAD BEEN LEFT OFF THE CONTROL STATEMENT,
0*$ONLY THE FIRST OCCURRENCE OF "BROWN EYES" WOULD BE CHANGED IN
0*$EACH RECORD.  NOTE ALSO THAT SINCE NEITHER "L" NOR "LA WAS
0*$SPECIFIED, "L" IS DEFAULTED.
0*$THUS,  FOR EACH RECORD TO BE
0*$CHANGED, BOTH A "BEFORE" AND AN "AFTER" IMAGE WILL BE PRINTED.  THE
0*$"BEFORE" IMAGE WILL BE PRECEDED BY "VER" IN THE LEFT MARGIN, AND
0*$THE "AFTER" IMAGE WILL BE PRECEDED BY "REP".  IF THE KEYWORD "LA"
0*$IS ADDED INSTEAD OF "L", ALL RECORDS FOR ALL MEMBERS WILL BE
0*$PRINTED IN ADDITION TO THE CHANGED RECORDS.
0*$.SP 1
0*$.IN 5
0*$A *MSGCLASS=A**
0*$.IN 0
0*$WILL CAUSE ALL OCCURRENCES OF THE STRING "MSGCLASS=A" TO BE
0*$DELETED FROM THE PDS.
0*$.SP 1
0*$.IN 5
0*$L A T(71) *MSGCLASS=1** *MSGCLASS=A** /MSGCLASS/
0*$.IN 0
0*$IN THIS EXAMPLE, BOTH THE CHARACTER STRINGS "MSGCLASS=1" AND
0*$"MSGCLASS=A" WILL BE DELETED FROM THE PDS.  AS MANY OF THESE
0*$CHARACTER STRING CONSTRUCTS CAN BE SPECIFIED AS DESIRED
0*$(UP TO A CURRENT IMPLEMENTATION RESTRICTION OF A TOTAL OF 1000
0*$BYTES).  ALSO, BECAUSE OF THE SPECIFICATION "/MSGCLASS/", ALL
0*$RECORDS CONTAINING THE CHARACTER STRING "MSGCLASS" THAT ARE
0*$NOT FOLLOWED BY "=1" OR "=A" WILL ALSO BE PRINTED.  NOTE THAT
0*$IF ANY MORE CONSTRUCTS WERE SPECIFIED FOLLOWING THE "/MSGCLASS/"
0*$CONSTRUCT, THEY WOULD HAVE TO USE A DELIMITER OTHER THAN "/".
0*$.SP 1
0*$THE "T(71)" SPECIFICATION IN THE ABOVE EXAMPLE RESTRICTS THE
0*$VERIFY/REPLACE OPERATION TO THE FIRST 72 COLUMNS OF EACH RECORD.
0*$IF THE RECORDS ARE 80 BYTES LONG, FOR EXAMPLE, COLUMNS 72 TO 80
0*$WILL REMAIN UNCHANGED, AND TRUNCATION OR PADDING WITH BLANKS
0*$WILL OCCUR BEGINNING IN COLUMN 71.
 */
  GPRNTPD:PROC(PARM) OPTIONS(MAIN);
    DCL PARM CHAR(100) VARYING;
    DCL NULL BUILTIN;
    DCL HDPTR PTR;
    HDPTR = NULL;
    VRPTR = ADDR(HDPTR);
    DCL 1 VRENT BASED(VRPTR),
      2 NPTR PTR,
      2 VPTR PTR,
      2 RPTR PTR,
      2 FINDSW BIT(1);
    DCL ANYREPSW BIT(1) INIT('0'B);
    DCL VER CHAR(256) VARYING BASED(VPTR);
    DCL REP CHAR(256) VARYING BASED(RPTR);
    DCL TPTR PTR;
    DCL BUFPTR PTR STATIC,BUFPADJ FIXED BIN(31,0) DEF BUFPTR;
    DCL 1 LRECV BASED(BUFPTR),
      2 BYTCNT FIXED BIN(15,0),
      2 RECSTR CHAR(256);
    DCL BCNTSAV FIXED BIN(15,0) STATIC INIT(0);
    DCL BUFFER CHAR(20000) VARYING STATIC;
    DCL LRECF CHAR(256) BASED(BUFPTR);
    DCL RECL FIXED BIN(15,0);
    DCL CURREC CHAR(256) BASED(CURPTR);
    DCL CURPTR PTR,CURADJ FIXED BIN(31,0) DEF CURPTR;
    DCL WRITSW BIT(1) STATIC INIT('0'B);
    DCL CTLSTR CHAR(1000) VARYING INIT('') STATIC;
    DCL CTLREC CHAR(80) STATIC;
    DCL TRUNC FIXED BIN(15,0) STATIC INIT(256);
    DCL SYSINSW BIT(1) STATIC INIT('1'B);
    ON UNDF(SYSIN) SYSINSW ='0'B;
    OPEN FILE(SYSIN) RECORD INPUT;
    DCL CTLCH CHAR(1);
    DCL (PREFIX, SUFFIX) ENTRY RETURNS(FIXED BIN(15,0));
    DCL (ALLSW,LSW,LASW) BIT(1) STATIC INIT('0'B);
    DCL REPCODE BIT(2);
    DCL REPREC CHAR(256) VARYING STATIC;
    /* FORMAT OF CONTROL STATEMENT


    ×-      -×
    ×- L -××- -×  ×-  -×× ×-  -× ×
    ×  LA ×× A × *×TEXT××*×TEXT×*×
    ×-   -××- -×  ×-  -×× ×-  -× ×
    ×-      -×


    *TEXT*TEXT* MAY BE REPEATED AS OFTEN AS DESIRED.
    */
    IF SYSINSW
      THEN DO;
        PARM ='4';
        ON ENDFILE(SYSIN) GO TO SYSINEOF;
        DO FOREVER=1 REPEAT FOREVER;
          READ FILE(SYSIN) INTO(CTLREC);
          CALL SETCAPS(CTLREC);
          OUTREC = MYCC××CTLREC;
          WRITE FILE(OUT) FROM(OUTREC);
          MYCC=' ';
          I = SUFFIX(SUBSTR(CTLREC,1,72),' ');
          CTLSTR=CTLSTR××SUBSTR(CTLREC,1,I+1);
          END;
        SYSINEOF:CLOSE FILE(SYSIN);
        I = PREFIX(CTLSTR,' ');
        IF I = 0
          THEN DO;
            PUT EDIT('ERROR - ONLY BLANKS WERE FOUND ON SYSIN')(A)
            SKIP(1);
            SIGNAL ERROR;
            END;
        KEYLP:DO FOREVER=1 REPEAT FOREVER;
          J=INDEX(SUBSTR(CTLSTR,I),' ')+I-1;
          IF J < I
            THEN J = L+1;
          IF SUBSTR(CTLSTR,I,2) ='T('
            THEN DO;
              K=INDEX(SUBSTR(CTLSTR,I),')')+I-1;
              IF K = 0
                THEN DO;
                  PUT EDIT('ERROR - T KEYWORD IS INCORRECT')(A) SKIP(1)
                  ;
                  SIGNAL ERROR;
                  END;
              TRUNC=SUBSTR(CTLSTR,I+2,K-I-2);
              END;
            ELSE IF SUBSTR(CTLSTR,I,2) ='L '
              THEN LSW ='1'B;
              ELSE IF SUBSTR(CTLSTR,I,2) ='A '
                THEN ALLSW ='1'B;
                ELSE IF SUBSTR(CTLSTR,I,3) ='LA '
                  THEN LASW ='1'B;
                  ELSE LEAVE KEYLP;
          I = PREFIX(SUBSTR(CTLSTR,J),' ')+J-1;
          END;
        IF ^(LSW × LASW)
          THEN LSW ='1'B;
        L = LENGTH(CTLSTR);
        DO WHILE(I < L-3);
          ALLOC VRENT SET(TPTR);
          NPTR = TPTR;
          VRPTR = TPTR;
          NPTR = NULL;
          CTLCH = SUBSTR(CTLSTR,I,1);
          J = INDEX(SUBSTR(CTLSTR,I+1,L-I),CTLCH)+I;
          IF J = I
            THEN DO;
              PUT EDIT('ERROR - TRAILING DELIMITER NOT FOUND')(A) SKIP(
              1);
              SIGNAL ERROR;
              END;
          CHARLEN = J-I-1;
          IF CHARLEN = 0
            THEN DO;
              PUT EDIT('ERROR - VERIFY STRING CANNOT BE NULL')(A) SKIP(
              1);
              SIGNAL ERROR;
              END;
          ALLOC VER;
          VER = SUBSTR(CTLSTR,I+1,CHARLEN);
          I = INDEX(SUBSTR(CTLSTR,J+1,L-J),CTLCH)+J;
          IF I = J
            THEN FINDSW ='1'B; /* FIND FUNCTION */
            ELSE DO;
              ANYREPSW='1'B;
              FINDSW ='0'B;
              CHARLEN = I-J-1;
              ALLOC REP;
              REP=SUBSTR(CTLSTR,J+1,CHARLEN);
              END;
          IF I <= L-4
            THEN I = PREFIX(SUBSTR(CTLSTR,I+2),' ')+I+1;
            /* FIND NXT NON-BLNK */
            ELSE I = L;
          IF SUBSTR(CTLSTR,I,1)=' '
            THEN I = L;
          END;
        END;
    DCL PAD CHAR(80) VARYING STATIC;
    DCL PADL FIXED BIN(15,0);
    PADL = PARM;
    PAD = SUBSTR((80)' ',1,PADL);
    DCL OUT FILE RECORD OUTPUT;
    DCL DDNAME CHAR(8) INIT('IN');
    DCL DCBPTR PTR;
    DCL CARCTL BIT(1);
    DCL MEMNAM CHAR(8) INIT(' ');
    DCL RETCODE FIXED BIN(31,0);
    DCL (INREC,OUTREC) CHAR(256) VARYING STATIC;
    DCL MYCC CHAR(1) STATIC INIT('1');
    DCL 1 DCB2 BASED(DCBPTR),
      2 DCBPAD1 CHAR(36),
      2 DCBRECFM BIT(8),
      2 DCBPAD2 CHAR(45),
      2 DCBLRECL FIXED BIN(15,0);
    CALL SYSDCBP(DCBPTR,DDNAME);
    IF ANYREPSW
      THEN CALL SYSOPEN(DCBPTR,'UPDAT');
      ELSE CALL SYSOPEN(DCBPTR,'INPUT');
    IF SUBSTR(DCBRECFM,6,2)^='00'B
      THEN CARCTL ='1'B;
      ELSE CARCTL ='0'B;
    ON CONDITION(SYSEOD)BEGIN;
    MEMNAM = GETDIR;
    IF MEMNAM = HIGH(8)
      THEN GO TO EOJ;
    CALL SYSFIND(DCBPTR,MEMNAM,'D',RETCODE);
    IF RETCODE ^= 0
      THEN SIGNAL ERROR;
    IF ^CARCTL
      THEN DO;
        LNECNT = 55;
        MYCC ='1';
        END;
    GO TO NXT;
    END;
  SIGNAL CONDITION(SYSEOD);
  NXT:CALL NXTREC(INREC);
  IF ^SYSINSW
    THEN DO;
      CALL WRITOUT;
      GO TO NXT;
      END;
    ELSE DO;
      DO VRPTR=HDPTR REPEAT NPTR WHILE(VRPTR^=NULL);
        IF FINDSW
          THEN DO;
            IF INDEX(INREC,VER) ^= 0
              THEN DO;
                PAD ='VER ';
                CALL WRITOUT;
                PAD = (4)' ';
                END;
              ELSE IF LASW
                THEN CALL WRITOUT;
            GO TO NXT;
            END;
        IF RECL < TRUNC
          THEN J = RECL;
          ELSE J = TRUNC;
        REPREC = SUBSTR(INREC,1,J);
        I = SUFFIX(REPREC,' ');
        REPREC=SUBSTR(REPREC,1,I);
        IF LENGTH(REPREC)=0
          THEN REPCODE='00'B;
          ELSE IF ALLSW
            THEN CALL REPLACE(REPREC,VER,REP,REPCODE,'ALL');
            ELSE CALL REPLACE(REPREC,VER,REP,REPCODE);
        IF REPCODE ^='00'B
          THEN DO;
            PAD ='VER ';
            CALL WRITOUT;
            IF LENGTH(REP)>LENGTH(VER)
              THEN SUBSTR(INREC,1,J)=SUBSTR(REPREC,1,J);
              ELSE SUBSTR(INREC,1,J)=REPREC;
            PAD ='REP ';
            CALL WRITOUT;
            SUBSTR(CURREC,1,RECL)=INREC;
            WRITSW ='1'B;
            PAD = (4)' ';
            END;
          ELSE IF LASW
            THEN CALL WRITOUT;
        END;
      END;
  GO TO NXT;
  WRITOUT:PROC;
    I = LENGTH(INREC);
    IF I > 132-PADL
      THEN IF CARCTL
        THEN INREC = SUBSTR(INREC,1,133-PADL);
        ELSE INREC = SUBSTR(INREC,1,132-PADL);
    IF CARCTL
      THEN DO;
        I = LENGTH(INREC)-1;
        OUTREC = SUBSTR(INREC,1,1)××PAD××SUBSTR(INREC,2,I);
        END;
      ELSE DO;
        LNECNT = LNECNT + 1;
        IF LNECNT > 55
          THEN DO;
            LNECNT = 0;
            IF LSW
              THEN MYCC =' ';
              ELSE MYCC ='1';
            IF LASW × LSW
              THEN DO;
                OUTREC=MYCC××'MEMBER='××MEMNAM;
                WRITE FILE(OUT) FROM(OUTREC);
                MYCC =' ';
                END;
            END;
        OUTREC = MYCC ×× PAD ×× INREC;
        MYCC =' ';
        END;
    WRITE FILE(OUT) FROM(OUTREC);
    END;
  GETDIR:PROC RETURNS(CHAR(8));
    DCL INDIR FILE RECORD INPUT ENV(F RECSIZE(256) BLKSIZE(256));
    DCL BUFPTR PTR STATIC,BUFPADJ FIXED BIN(31,0) DEF BUFPTR;
    DCL BYTCNT FIXED BIN(15,0) BASED(BUFPTR);
    DCL BCNTSAV FIXED BIN(15,0) STATIC INIT(0);
    DCL 1 ENTRY BASED(BUFPTR),
      2 MEMNAM CHAR(8),
      2 TTR CHAR(3),
      2 CFIELD,
        3 CF1 BIT(3),
        3 CF2 BIT(5); /* USER DATA HALFWORDS */
    DCL MYNAME CHAR(8);
    ON ENDFILE(INDIR) GO TO DIREOF;
    DCL INITSW BIT(1) STATIC INIT('1'B);
    IF INITSW
      THEN DO;
        INITSW ='0'B;
        OPEN FILE(INDIR) TITLE(DDNAME);
        END;
    IF BCNTSAV < 3
      THEN GO TO READIR;
    J = 12 + 2 * CF2;
    BUFPADJ = BUFPADJ + J;
    BCNTSAV = BCNTSAV - J;
    IF BCNTSAV > 2
      THEN GO TO RETURN;
    READIR:READ FILE(INDIR) SET(BUFPTR);
    BCNTSAV = BYTCNT;
    BUFPADJ = BUFPADJ + 2;
    GO TO RETURN;
    RETURN:MYNAME = MEMNAM;
    RETURNA:RETURN(MYNAME);
    DIREOF:MYNAME = HIGH(8);
    GO TO RETURNA;
    END;
  NXTREC:PROC(REC);
    DCL REC CHAR(256) VARYING;
    IF BCNTSAV = 0
      THEN DO;
        IF WRITSW
          THEN CALL SYSWRIT(DCBPTR,BUFFER);
        WRITSW ='0'B;
        CALL SYSREAD(DCBPTR,BUFFER);
        BCNTSAV = LENGTH(BUFFER);
        BUFPTR = ADDR(BUFFER);
        BUFPADJ = BUFPADJ + 2;
        IF SUBSTR(DCBRECFM,1,2) ='01' /* RECFM=V */
          THEN DO;
            BUFPADJ = BUFPADJ + 4;
            BCNTSAV = BCNTSAV - 4;
            END;
        END;
    IF SUBSTR(DCBRECFM,1,2) ='01' /* RECFM=V */
      THEN DO;
        RECL = BYTCNT - 4;
        CURADJ = BUFPADJ + 4;
        BCNTSAV = BCNTSAV - BYTCNT;
        BUFPADJ = BUFPADJ + BYTCNT;
        END;
      ELSE DO;
        RECL = DCBLRECL;
        CURADJ = BUFPADJ;
        BCNTSAV = BCNTSAV - DCBLRECL;
        BUFPADJ = BUFPADJ + DCBLRECL;
        END;
    REC = SUBSTR(CURREC,1,RECL);
    END;
  EOJ:END;
