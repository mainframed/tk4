 /* T */
 /*
0*$.HE TSO COMMAND PROCESSOR - T
0*$.HE DYNAMIC STEPLIB FOR TSO
0*$.PL 55
0*$.PN 0
0*$.PA
0*$.SS
0*$.NF
0*$09/15/78
0*$AUTHOR:  T. SMITH
0*$SOURCE MODULE NAME:  T
0*$DOCUMENTATION ID:  0*$
0*$HELP ID:  0*#
0*$.FI L
0*$.SP 5
0*$THIS TSO COMMAND PROCESSOR PROVIDES THE FACILITY FOR ALLOCATING
0*$A STEPLIB DYNAMICALLY DURING A TSO SESSION.  IT IS A PLIST
0*$(PL/I) PROGRAM.
0*#)F FUNCTION -
0*# USE THE T COMMAND TO EXECUTE A TSO COMMAND PROCESSOR WHICH
0*# IS NOT STORED IN ONE OF THE LINK LIST LIBRARIES (SYS1.LINKLIB,
0*# SYS1.CMDLIB, SYS2.CMDLIB, SYS2.USERLIB, ETC.), AND/OR  TO
0*# ESTABLISH A TEMPORARY STEPLIB.
0*#)X SYNTAX -
0*#
0*#    T CMD OPERANDS
0*#  OR
0*#    T DSN(CMD) OPERANDS
0*#  OR
0*#    T (CMD FILE()) OPERANDS
0*#  OR
0*#    T (CMD DATASET()) OPERANDS
0*#
0*# NOTE:  BECAUSE THE SYNTAX OF THIS COMMAND IS SOMEWHAT UNUSUAL, THE
0*# CONVENTIONAL FORMAT FOR HELP TEXT HAS NOT BEEN OBSERVED.
0*# INSTEAD VARIOUS SYNTACTICAL PARTS HAVE BEEN DESIGNATED THE
0*# NAMES "CMD", "DSN", "FILE", "DATASET", AND "OPERANDS".
0*# ENTERING THE COMMAND "HELP T O(XXX)", REPLACING XXX WITH ANY
0*# ONE OF THE NAMES FOR SYNTACTICAL PARTS WILL PRODUCE TEXT
0*# DESCRIBING THAT PART.
0*#
0*#)O OPERANDS -
0*#))CMD - SPECIFIES THE COMMAND NAME TO BE INVOKED.
0*#))DSN - SPECIFIES THE DATA SET NAME FOR THE LOAD LIBRARY TO
0*#     BE ESTABLISHED AS A STEPLIB DURING EXECUTION OF THE COMMAND.
0*#     IF THE SPECIFIED COMMAND IS IN THIS LIBRARY, THAT COPY WILL
0*#     BE INVOKED.  OTHERWISE, THE LINKLST LIBRARIES WILL BE SEARCHED.
0*#     TSO STANDARD NAMEING CONVENTIONS SHOULD BE USED.  THAT IS,
0*#     IF THE NAME IS NOT PREFIXED WITH YOUR USERID, THE NAME
0*#     SHOULD BE SURROUNDED IN APROSTOPHES.
0*#))FILE - SPECIFIED THE FILE NAME UNDER WHICH A LOAD LIBRARY,
0*#     OR SEVERAL CONCATENATED LOAD LIBRARIES, ARE ALLOCATED.
0*#     THIS FILE NAME WILL BE USED TO ESTABLISH A STEPLIB
0*#     DURING EXECUTION OF THE COMMAND.  IF THE SPECIFIED COMMAND
0*#     IS IN THIS LIBRARY OR LIBRARIES, THAT COPY WILL BE INVOKED.
0*#     OTHERWISE, THE LINKLST LIBRARIES WILL BE SEARCHED.
0*#     NOTE THAT IF NEITHER DATASET NOR FILE IS SPECIFIED, THE
0*#     COMMAND WILL ASSUME A DEFAULT FILE NAME OF "SYSLOAD".
0*#))OPERANDS - THIS IS A LIST OF ONE OR MORE OPERANDS TO BE
0*#     PASSED ON TO THE COMMAND TO BE INVOKED.
 */
         % INCLUDE CPINIT1;
         % @CMP = 'O';
         % INCLUDE CPINIT2;
         DCL MYCMD CHAR(8) VAR;
         DCL MYFILE CHAR(8) INIT('SYSLOAD');
         DCL FREESW BIT(1) INIT('0'B);
         DCL PLIRETC BUILTIN;
         DCL 1 MYBUF UNALIGNED,
           2 LEN FIXED BIN(15,0), /* TOTAL LENGTH OF BUF */
           2 OFF FIXED BIN(15,0), /* OFFSET TO DATA */
           2 DATA CHAR(256);
         DCL 1 SUBBUF UNALIGNED,
           2 LEN FIXED BIN(15,0),
           2 OFF FIXED BIN(15,0),
           2 DATA CHAR(256);
         DCL 1 CBUF UNALIGNED BASED(CPPLCBUF),
           2 LEN FIXED BIN(15,0),
           2 OFF FIXED BIN(15,0),
           2 DATA CHAR(256);
         DCL PSTR ENTRY(CHAR(*) VAR, FIXED BIN(15,0))
           RETURNS(FIXED BIN(15,0));
         IF SUBSTR(CBUF.DATA,CBUF.OFF+1,1) = '('
           THEN DO;
             I = PSTR(CBUF.DATA,CBUF.OFF+1);
             IF I = 0
               THEN DO;
                 @WRITE('SYNTAX ERROR IN COMMAND NAME');
                 SIGNAL ERROR;
                 END;
             MYBUF.LEN = I - CBUF.OFF+2;
             MYBUF.DATA = SUBSTR(CBUF.DATA,CBUF.OFF+2,MYBUF.LEN-4);
             CBUF.OFF = CBUF.OFF + MYBUF.LEN-2;
             END;
           ELSE DO;
             I = INDEX(SUBSTR(CBUF.DATA,CBUF.OFF+1,CBUF.LEN-4-CBUF.OFF),
               ' ');
             IF I = 0
               THEN I = CBUF.LEN-3;
               ELSE I = I + CBUF.OFF;
             MYBUF.LEN = I - CBUF.OFF+3;
             MYBUF.DATA = SUBSTR(CBUF.DATA,CBUF.OFF+1,MYBUF.LEN-4);
             CBUF.OFF = CBUF.OFF + MYBUF.LEN - 4;
             J = INDEX(SUBSTR(MYBUF.DATA,1,MYBUF.LEN-4),'(');
             IF J ^= 0
               THEN DO;
                 K = INDEX(MYBUF.DATA,')');
                 IF K = 0 × K > MYBUF.LEN-4
                   THEN DO;
                     @WRITE('SYNTAX ERROR IN COMMAND NAME');
                     SIGNAL ERROR;
                     END;
                 MYBUF.DATA = SUBSTR(MYBUF.DATA,J+1,K-J-1) ×× ' DA('××
                   SUBSTR(MYBUF.DATA,1,J-1) ××
                   SUBSTR(MYBUF.DATA,K+1,MYBUF.LEN-4-K) ×× ')';
                 MYBUF.LEN = MYBUF.LEN+3;
                 END;
             END;
         MYBUF.OFF = 0;
         SUBBUF.LEN = CBUF.LEN - CBUF.OFF;
         SUBBUF.OFF = 0;
         SUBBUF.DATA = SUBSTR(CBUF.DATA,CBUF.OFF+1,SUBBUF.LEN-4);
         PPLCBUF = ADDR(MYBUF);
         @PROC(1,CMD,FILE(),DATASET(#(DSNAME)));
         MYCMD = SYMC('&CMD');
         SUBBUF.DATA = MYCMD ×× ' ' ××
           SUBSTR(SUBBUF.DATA,1,SUBBUF.LEN-4);
         SUBBUF.LEN = SUBBUF.LEN + LENGTH(MYCMD)+1;
         CPPLCBUF = ADDR(SUBBUF);
         IF FILE ^= 0
           THEN MYFILE = SYMC('&FILE');
           ELSE IF SETDSN@(DATASETSUB) ^= ''
             THEN DO;
               @SETDSN(DATASETSUB,,PROMPT);
               @ALLOC(DA,SHR);
               MYFILE = DA08DDN;
               FREESW = '1'B;
               END;
         CALL SYSCMD(CPPL,IKJRET,'TASKL',MYFILE);
         IF FREESW
           THEN DO;
             DA18DDN = DA08DDN;
             @FREE(FI);
             END;
         CALL PLIRETC(SYMA('&LASTCC'));
         END;
