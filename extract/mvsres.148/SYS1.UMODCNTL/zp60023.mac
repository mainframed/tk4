//GREGZ023 JOB SYS,'USERMOD ZP60023',CLASS=A,REGION=4096K,
//             MSGLEVEL=(1,1),MSGCLASS=X,COND=(0,NE),NOTIFY=GREG
//*
//*  MAINTAIN DUAL ADDRESS SPACE ENVIRONMENT FOR TASKS.
//*
//STEP1   EXEC PGM=IEBGENER
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  *
++USERMOD(ZP60023)             /* SUPPORT DAS AT THE TASK LEVEL */  .
++VER(Z038) FMID(FBB1221) PRE(UZ61148,UZ36571,UZ30139,UZ25668)
 /*
   PROBLEM DESCRIPTION:
     NO OPERATING SYSTEM SUPPORT FOR THE DUAL ADDRESS SPACE FACILITY.
       IN ORDER TO EXPLOIT THE DUAL ADDRESS SPACE FACILITY (DAS)
       APPLICATIONS MUST USE DISABLEMENT FOR SERIALIZATION AND
       MANAGE THE CONTENTS OF THE RELEVANT CONTROL REGISTERS.
       THIS IS NOT CONDUCIVE TO GOOD SYSTEM STABILITY, RELIABLITY
       AND PERFORMANCE.

       THIS USERMOD UPDATES THE PROGRAM CHECK FIRST LEVEL INTERRUPT
       HANDLER (PCFLIH) SUCH THAT IF A SPECIAL-OPERATION EXCEPTION
       IS CAUSED BY AN SSAR INSTRUCTION WHEN RUNNING UNDER A TASK,
       THE SPECIFIED SECONDARY ADDRESS SPACE NUMBER (SASN) IS
       VALIDATED, AND IF VALID IS SET UP TO BE THE TASK'S SECONDARY
       ADDRESS SPACE.

       THE PCFLIH STORES THE SECONDARY ASID IN THE PREVIOUSLY
       RESERVED FIELD TCBRV326.

       ALL TASKS CAN USE SSAR TO SET SASN=PASN.  ALL TASKS CAN
       ISSUE SSAR WITH THE SPECIAL SASN VALUE OF ZERO WHICH CAUSES
       ALL DAS SETTINGS TO BE CLEARED FROM CONTROL REGISTERS.
       (SPECIFYING A SASN OF ZERO IS DIFFERENT FROM USING GENERAL
       PURPOSE REGISTER 0 IN THE SSAR INSTRUCTION.)

       SETTING THE SECONDARY ADDRESS SPACE TO ONE OTHER THAN THE
       CURRENT PRIMARY ADDRESS SPACE REQUIRES THAT THE SSAR
       INSTRUCTION IS EXECUTED IN SUPERVISOR STATE.

       THIS USERMOD ALSO CHANGES THE DISPATCHER TO RESTORE THE
       SECONDARY ASID OF A TASK EACH TIME IT IS DISPATCHED.  THE
       DISPATCHER WILL RESET THE DAS ENVIRONMENT, AND REVALIDATE
       THE ASID STORED IN TCBRV326, AND IF FOUND TO BE VALID WILL
       SET THAT ASID AS THE TASK'S SECONDARY ASID BEFORE THE TASK
       RESUMES PROCESSING.

       THE ASID IS CONSIDERED VALID IF IT SPECIFIES AN ASSIGNED
       SWAPPED-IN ADDRESS SPACE.  WHEN A SECONDARY ASID IS SET
       UP FOR A TASK BY THE PCFLIH, OR RESTORED BY THE DISPATCHER,
       THE SECONDARY ASN IS SET INTO CONTROL REGISTER 3, THE
       PRIMARY ASN IS SET INTO CONTROL REGISTER 4, THE SECONDARY
       SEGMENT TABLE ORIGIN AND LENGTH ARE SET INTO CONTROL
       REGISTER 7, AND THE EXTRACTION-AUTHORITY CONTROL AND THE
       SECONDARY-SPACE CONTROL BITS ARE SET ON IN CONTROL REGISTER 0.

   SPECIAL CONDITIONS:
     ACTION:
       AN IPL MUST BE PERFORMED FOR THIS SYSMOD TO BECOME ACTIVE.

     DOC:
       SYSTEM ABEND 0D7 INDICATES THAT THE PC FLIH FOUND AN ADDRESS
       SPACE TO NOT BE BOTH ASSIGNED AND SWAPPED IN.  THE VALUE OF
       GENERAL PURPOSE REGISTER 15 IS 1 IF THE PRIMARY ADDRESS
       SPACE WAS FOUND TO BE INVALID AFTER A PAGE FAULT IN THE
       SECONDARY ADDRESS SPACE WAS RESOLVED, AND 2 IF A PAGE-
       TRANSLATION EXCEPTION OCCURRED FOR AN INVALID SECONDARY
       ADDRESS SPACE.

   COMMENTS:
     PRYCROFT SIX P/L PUBLIC DOMAIN USERMOD FOR MVS 3.8 NUMBER 23.

     REWORK HISTORY:
       2008-11-01: INITIAL RELEASE.
       2012-01-07: SAVE FLOATING POINT REGISTER CONTENTS CORRECTLY.
       2015-06-09: FIX CONDITION CODE SETTING AND BRCL BRANCH ADDRESS.
                   ALSO ADD TRTT, TRTO, TROT, TROO, MSFI AND TP.
       2016-08-06: REMOVE NON-370 INSTRUCTION OPCODE SUPPORT RESIDENT
                   IN THE PCFLIH OPERATION EXCEPTION HANDLER, AND SO
                   PSARV022 IS NO LONGER USED AS A RECURSION FLAG.

     THE FOLLOWING MODULES AND/OR MACROS ARE AFFECTED BY THIS USERMOD:
     MODULES:
       IEAVEDS0
       IEAVEPC
     MACROS:
       IKJTCB
 */.
++MACUPD(IKJTCB) DISTLIB(AMODGEN).
./ CHANGE NAME=IKJTCB
*/*                  ZP60023 USE TCBRV326 FOR SECONDARY ASN  @ZP60023*/
TCBRV326 DS    H -     SECONDARY ADDRESS SPACE NUMBER          @ZP60023
*    2 TCBRV326 FIXED(15),           /* SECONDARY ASN        @ZP60023*/
++MOD(IEAVEPC) DISTLIB(AOSC5).
/*
//SYSUT2   DD  DSN=&&SMPMCS,DISP=(NEW,PASS),UNIT=VIO,SPACE=(CYL,3),
//             DCB=(DSORG=PS,RECFM=FB,LRECL=80,BLKSIZE=4080)
//SYSIN    DD  DUMMY
//STEP2   EXEC PGM=IFOX00,PARM='OBJECT,NODECK,NOTERM,XREF(SHORT)'
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  UNIT=VIO,SPACE=(CYL,10)
//SYSUT2   DD  UNIT=VIO,SPACE=(CYL,10)
//SYSUT3   DD  UNIT=VIO,SPACE=(CYL,10)
//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR
//         DD  DSN=SYS1.SMPMTS,DISP=SHR
//         DD  DSN=SYS1.AMODGEN,DISP=SHR
//         DD  DSN=SYS1.APVTMACS,DISP=SHR
//SYSGO    DD  DSN=&&SMPMCS,DISP=(MOD,PASS)
//SYSIN    DD  *
         TITLE 'IEAVEPC- PROGRAM FIRST LEVEL INTERRUPT HANDLER'
* /* START OF SPECIFICATIONS ****
*
*01*  MODULE-NAME = IEAVEPC
*
*02*     CSECT-NAME = IEAVEPC
*
*01*  DESCRIPTIVE-NAME = PROGRAM INTERRUPT HANDLER
*
*01*  COPYRIGHT = NONE
*
*01*  STATUS = SYSTEM CONTROL PROGRAM II                       @G64RPXO
*
*01*  FUNCTION = SEE ENTRY POINT PURPOSES BELOW.
*
*02*     OPERATION = THE PROGRAM FLIH WILL RECEIVE CONTROL VIA PROGRAM
*        NEW PSW AFTER A PROGRAM TYPE INTERRUPTION HAS OCCURRED. ITS
*        MAIN FUNCTION IS TO DETERMINE WHAT TYPE OF PROGRAM
*        INTERRUPTION HAS OCCURRED AFTER SAVING STATUS, AND ROUTE
*        CONTROL TO THE APPROPRIATE PROCESSOR TO PERFORM THE FUNCTION
*        INDICATED.
*
*01*   NOTES = SEE ENTRY POINT PURPOSES BELOW.
*
*02*        DEPENDENCIES =
*
*           GENERAL:
*           1. IT IS ASSUMED THAT IF A SUPERVISORY CONTROL FUNCTION WAS
*           RUNNING AT THE TIME OF INTERRUPTION, THE PROGRAM RUNNING
*           WILL ALWAYS BE DISABLED (EVEN IF JUST FOR I/O OR EXTERNAL)
*
*           NIP0:
*           1. NIP0 MUST PLACE THE MASTER MEMORY'S C.R.1 IN LCCAMCR1
*           AFTER THE MASTER MEMORY SEGMENT TABLE HAS BEEN CREATED.
*           2. THERE IS A DEPENDENCY ON NIP0 TO PREALLOCATE AN SRB POOL
*           FOR THE PURPOSE OF SUSPENDING SRBS. THE AMOUNT OF CORE THAT
*           WILL BE FORMATED BY NIP0 FOR THIS PURPOSE USING BLDCPOOL
*           WILL BE 8K WITH THE CELL SIZE BEING 480 BYTES. THIS CAL-
*           CULATES TO BE 16 CELLS. THE CPID TO BE USED IN THE
*           BLDCPOOL IS C'SRB'X'00'.
*           3. THE PROGRAM FLIH CODE MUST BE IN V=R STORAGE.
*
*           GTF:
*           1. GTF IS ENTERED UNCONDITIONALLY ON A NON-RECURSIVE
*           PROGRAM INTERRUPT. GTF WILL DECIDE WHETHER MC PROCESSING
*           OR INTERRUPTION RECORDING IS TO BE DONE. IN EITHER CASE
*           RETURN WILL ALWAYS BE BACK TO THE INTERRUPT HANDLER.
*           2. LOCKS MAY NOT BE ASKED FOR.
*           3. DISABLEMENT MUST BE PRESERVED.
*
*           PAGING SUPERVISOR(IEAPIX,RSM):
*           1. THE PAGING SUPERVISOR MUST NOT ENABLE OR ISSUE MC HOOKS
*           (ONLY BRANCH HOOKS MAY BE ISSUED) AS A SLIH.
*           2. ON ENTRY TO THE SUSPEND ROUTINE(ENTRY IEAVSUSP) THE
*           SALLOC LOCK MUST BE HELD.
*           ON RETURN FROM THE SUSPEND ROUTINE, THE PAGING SUPERVISOR
*           MUST KEEP TRACK OF REGISTERS 4,5,6 SO THAT THE RESET
*           ROUTINE(IEAVRSET) CAN BE DONE AT SOME LATER POINT IN TIME.
*           4. ON ENTRY TO THE RESET ROUTINE IT IS NECESSARY FOR THE
*           SALLOC LOCK TO BE HELD AND THE SRB THAT ENTERS RESET MUST
*           BE A NON-QUIESCABLE PRIORITY SRB IF A VALUE OF 4 IN REG-
*           ISTER 6 WAS INDICATED FROM SUSPEND, IF A VALUE OF 0 WAS
*           INDICATED IN REGISTER 6 FROM SUSPEND, THE SRB MUST BE A
*           SYSTEM PRIORITY SRB AND MUST OWN THE LOCAL LOCK IN ADDITION
*           TO THE SALLOC LOCK. IN EITHER CASE THE ADDRESS SPACE BEING
*           SERVICED MUST BE THE ONE THE REST IS BEING DONE FROM.
*           REGISTERS 4 AND 5 TO RESET MUST BE THE SAME AS AT EXIT
*           FROM SUSPEND.
*
*           SLIP PROCESSOR (IEAVTPER):                         @G64RPXO
*           1. IEAVTPER MUST RESIDE IN THE NUCLEUS AND REMAIN  @G64RPXO
*           DISABLED WHILE PROCESSING A PER INTERRUPT.         @G64RPXO
*           2. IEAVTPER MUST PERSERVE REGISTERS 4-10.          @G64RPXO
*
*           DISPATCHER:
*           IN GENERAL:
*           1. THE DISPATCHER MUST, WHEN DISPATCHING AN SRB WITH A NON-
*           ZERO SRBSAVE FIELD , CHECK THE SSRBMAIN BIT BEFORE
*           FREECELLING THE SSRB.  IF THE SSRBMAIN BIT IS ON, THE
*           DISPATCHER MUST FREEMAIN THE SSRB AREA.
*
*           IEA0DS ENTRY:
*           1. THIS ENTRY WILL SAVE ALL STATUS OTHER THAN GENERAL
*           REGISTERS AND PSW FOR A LOCALLY LOCKED TCB, WILL CHECK FOR
*           THE CMS LOCK AND SET INDICATORS IF NECESSARY, AND WILL
*           ZERO ALL NECESSARY LOCK TABLE ENTRIES. THE LOCAL LOCK MUST
*           NOT BE TOUCHED SINCE A SUSPEND ID(X'7FF..FF') IS IN THE
*           LOCK WORD(ASCBLOCK).
*
*           SPIE:
*           1. SPIE MUST SUPPLY A SPIE CONTROL AREA(SCA). THE LENGTH OF
*           THIS AREA IS 4 BYTES FOR A PIE POINTER + THE LENGTH OF AN
*           SRB + 16 BYTES FOR PARAMETERS USED BY THE INTERRUPT HAND-
*           LER. A POINTER TO THE SCA MUST BE PLACED IN THE TCBPIE
*           FIELD. IF A PIE EXISTS THE FIRST 4 BYTES OF THE SCA POINTS
*           TO THE PIE.
*           2. THE ADDRESS OF SPIE'S RMTR HAS BEEN PLACED IN THE
*           SRBRMTR FIELD OF THIS SRB LOCATED WITHIN THE SCA.
*
*           RTM:
*           1. THE SEGMENT AND TRANSLATION RECURSION BITS MUST BE TURN-
*           ED OFF BY RTM IN THE PROGCK AND DATERR ENTRIES AFTER SUC-
*           CESSFUL COMPLETION OF ITS PROCESSING.
*           2. ON THE DATERR ENTRY THE ERROR INFORMATION IS IN LCCAPGR1
*           (GENERAL REGISTERS) AND ALL OTHER INFO IS IN HARDWARE
*           STORED LOW CORE.
*           3. NORMALLY THE PROGCK ENTRY ERROR INFORMATION IS IN
*           LCCAPGR2(GENERAL REGS), LCCAPPSW(FOR PSW), LCCAPINT(ILC +
*           INTERRUPT CODE), AND LCCAPVAD(TRANSLATION ADDRESS). HOWEVER
*           IF A NON-ZERO COMPLETION CODE WAS SPECIFIED ON THE ENTRY
*           THE ERROR INFORMATION IS IN THE SAME AREAS AS FOR DATERR.
*           4. ON THE PGIOERR ENTRY FROM THE RESET ROUTINE, RTM IS EX-
*           PECTED TO TEST THE RB WAIT COUNT (PASSED IN REG 5) IF
*           RESETING AN UNLOCKED TCB, AND IF 0 IGNORE ANY OPERATIONS
*           DUE TO THE FACT THAT ABNORMAL TERMINATION IS ALREADY IN
*           PROGRESS.
*           5. BEFORE THE FREEING OF AN RB(DUE TO AN ABNORMAL TERMINA-
*           TION) OR ALLOWING THE RB TO RETRY IN ANY WAY, RTM MUST
*           PURGE ANY OUTSTANDING PAGING I/O FOR THE RB SO THAT RESET
*           WILL GET CONTROL AND PERFORM ITS CLEAN UP.
*           6. RTM AND EMS/MFA FRRS CAN NOT GIVE UP OR GET LOCKS.
*
*           PC FLIH RECURSIONS  -- PTM VS08516 --
*           IN CASE OF RECURSION IN THE FIRST SEGMENT OF THE PROGRAM
*           FLIH, THE FOLLOWING RECOVERY ACTIONS WILL BE TAKEN:
*           1. IF THE PROBLEM IS CAUSED BY A DAT-TYPE ERROR, MASTER'S
*           C.R.1 WILL BE LOADED, AND THE NORMAL DATERR ENTRY WILL
*           BE TAKEN TO RTM.  THE REGISTERS AT TIME OF INTERRUPT WILL
*           BE STORED IN LCCAPGR1.
*           2. IF THE PROBLEM IS CAUSED BY THE LCCA POINTERS BEING
*           OVERLAID, AN ATTEMPT WILL BE MADE TO RESTORE THEM FROM
*           THE LCCAT, AND THE PCCA POINTERS FROM THE PCCAT.
*           A FAILURE IN THIS ATTEMPT WILL ALSO RESULT IN THE DATERR
*           ENTRY BEING TAKEN TO RTM.  SUCCESSFUL REFRESH OF THESE
*           FIELDS WILL RESULT IN A PROGCHK ENTRY TO RTM, WITH A
*           COMPLETION CODE OF X'4FC', THE PC FLIH STACK AS CURRENT,
*           THE PC FLIH SUPER BIT ON, AND THE INCORRECT VALUES FROM
*           LOCATION X'208' - '217' STORED IN THE FIRST FOUR WORDS
*           OF LCCAPGR1.
*           3.  IF THE RECURSION IS A PER INTERRUPT, THE PSW   @G64RPXO
*           PER BIT IN PROGRAM OLD PSW IS TURNED OFF.  IF NO   @G64RPXO
*           OTHER CONCURRENT PROGRAM CHECK OCCURRED, THEN THE  @G64RPXO
*           ENVIRONMENT OF THE INTERRUPTED PROCESS IS RESTORED @G64RPXO
*           AND CONTROL IS GIVEN BACK TO THE INTERRUPTED       @G64RPXO
*           PROCESS VIA A LPSW OF THE PROGRAM OLD PSW.         @G64RPXO
*
*03*        CHARACTER-CODE-DEPENDENCIES = NONE
*
*02*     RESTRICTIONS = NONE
*
*02*     REGISTER-CONVENTIONS = SEE EQUATE SECTION OF THE MODULE
*
*02*     PATCH-LABEL = NONE(NUCLEUS RESIDENT)
*
*01*  MODULE-TYPE = PROCEDURE
*
*02*     PROCESSOR = ASSEMBLER
*
*02*     MODULE-SIZE = REFERENCE ESD LENGTH AT BEGGINNING OF MODULE.
*
*02*     ATTRIBUTES = NUCLEUS ,ZERO PROTECT KEY,DISABLE,REFRESHABLE,
*        ADDRSPC=REAL,SUPERVISOR MODE
*
*01*  ENTRY-POINT = IEAQPK00
*
*02*     PURPOSE = THIS IS THE MAIN ENTRY POINT INTO PROGRAM FLIH, IT
*        WILL DECIDE WHAT TYPE OF INTERRUPTION HAS OCCURED AND
*        CONSEQUENTLY DECIDE WHAT PROCESSOR SHOULD BE GIVEN CONTROL .
*
*02*     LINKAGE = SEE INPUT SECTION BELOW
*
*02*     INPUT =
*        INPUT ENVIRONMENT:
*        STATE-DISABLED FOR I/O,EXTERNAL,DAT,AND PER INTERRUPTS,
*        SUPERVISOR
*        KEY-0
*        LOCKS REQUIRED-NONE
*        INPUT DATA:
*        PROGRAM OLD PSW-LOCATION DECIMAL 40
*        PROGRAM INTERRUPT CODE-LOCATION DECIMAL 142
*        PROGRAM ILC VALUE-LOCATION DECIMAL 140-141
*        TRANSLATION EXCEPTION ADDRESS-LOCATION DECIMAL 144
*        ALL FIELDS OF THE CONTROL-BLOCKS BELOW
*        INPUT REGISTERS:
*        NONE
*
*02*     OUTPUT = NONE UNIQUE TO THIS ENTRY
*
*01*  ENTRY-POINT = IEAVPSRB
*
*02*     PURPOSE = THIS ROUTINE PERFORMS THE PIE/PICA PROCESSING
*        NECESSARY TO SATISFY AN ENTRY INTO A SPIE EXIT ROUTINE AFTER A
*        PROGRAM CHECK HAS OCCURED FOR AN UNLOCKED, PROBLEM PROGRAM TCB
*        ,WITH A SPIE EXIT.
*
*02*     LINKAGE = SEE INPUT SECTION BELOW
*
*02*     INPUT =
*        INPUT ENVIRONMENT:
*        STATE-ENABLED,SUPERVISOR STATE
*        KEY-0
*        LOCKS REQUIRED-NONE
*        INPUT DATA:
*        SCA(SPIE CONTROL AREA)
*        TCB BEING SERVICED
*        RB BEING SERVICED
*        INPUT REGISTERS:
*        0=CONTAINS ADDRESS OF SRB
*        1=CONTAINS ADDRESS OF PARAMETERS
*        14=CONTAINS RETURN ADDRESS
*        15=CONTAINS ENTRY POINT ADDRESS
*
*02*     OUTPUT = NONE UNIQUE TO THIS ENTRY
*
*01*  ENTRY-POINT = IEAVSUSP
*
*02*     PURPOSE = THIS ENTRY IS PROVIDED TO THE PAGING SUPERVISOR. IT
*        IS ENTERED IF PAGING I/O MUST BE PERFORMED. THIS ENTRY WILL
*        SAVE THE NECESSARY STATUS AND PERFORM THE OPERATIONS NECESSARY
*        TO SUSPEND AN SRB, LOCKED TCB, OR UNLOCKED TCB.
*
*02*     LINKAGE = SEE INPUT SECTION BELOW
*
*02*     INPUT =
*        INPUT ENVIRONMENT:
*        STATE-DISABLED,SUPERVISOR
*        KEY-0
*        LOCKS REQUIRED-SALLOC LOCK
*        INPUT DATA:
*        ALL INFORMATION FROM THE CONTROL-BLOCKS PSA AND LCCA.
*        INPUT REGISTERS:
*        13=SAVE AREA ADDRESS
*        14=RETURN ADDRESS
*
*02*     OUTPUT = NONE UNIQUE TO THIS ENTRY
*
*01*  ENTRY-POINT = IEAVRSET
*
*02*     PURPOSE = THIS ENTRY IS PROVIDED TO THE PAGING SUPERVISOR. IT
*        IS ENTERED ON PAGING I/O COMPLETION OR ON AN I/O ERROR OR ON
*        THE PURGING OF PAGING I/O. THIS ENTRY WILL CAUSE THE SUSPENDED
*        TCB OR SRB TO BE REDISPATCHED. IF AN ERROR IS INDICATED, RTM
*        IS ENTERED AND WILL PERFORM THE NECESSARY SET UP.
*
*02*     LINKAGE = SEE INPUT SECTION BELOW
*
*02*     INPUT =
*        INPUT ENVIRONMENT:
*        STATE-DISABLED,SUPERVISOR
*        KEY-0
*        LOCKS REQUIRED-LOCAL AND SALLOC LOCKS IF SERVICING AN
*                       UNLOCKED TCB.
*                       SALLOC LOCK ONLY OTHERWISE
*        INPUT DATA:
*        NONE
*        INPUT REGISTERS:
*        4=ADDRESS OF TCB OR SRB
*        5=ADDRESS OF RB OR 0(IF SRB)
*        6=0(IF NO ERROR)
*          NON-0(IF ERROR)
*        13=SAVE AREA ADDRESS
*        14=RETURN ADDRESS
*        15=ENTRY POINT ADDRESS
*
*02*     OUTPUT = NONE UNIQUE TO THIS ENTRY
*
*01*  EXIT-NORMAL = IEA0DS
*
*02*     CONDITIONS = IF AN SRB HAS BEEN SCHEDULED TO PERFORM PIE/PICA
*        PROCESSING, EXIT FROM THE PROGRAM FLIH IS TO THE DISPATCHER.
*        OR IF A PAGE EXCEPTION HAS OCCURED AND THE PAGING SUPERVISOR
*        HAS INDICATED THAT I/O HAS TO BE DONE AND SUSPENDED THE
*        TCB OR SRB, EXIT IS TO THE DISPATCHER
*
*02*     OUTPUT =
*        OUTPUT DATA-NONE DIRECTLY
*        OUTPUT REGISTERS-NONE
*        OUTPUT ENVIRONMENT-DISABLED,SUPERVISOR STATE,KEY 0,UNLOCKED
*
*02*     RETURN-CODES = NONE
*
*01*  EXIT-NORMAL = RTM(DATERR)
*
*02*     CONDITIONS = WHEN A TRANSLATION SPECIFICATION HAS OCCURED AND
*        CONTROL REGISTER 0 BITS 8-12 ARE VALID FOR TRANSLATION, OR
*        SEGMENT EXCEPTION RECURSION HAS OCCURED, RTM IS ENTERED AFTER
*        LOADING THE MASTER MEMORY'S CONTROL REGISTER 1(STOR REGISTER)
*        TO TERMINATE THE BAD MEMORY.
*
*02*     OUTPUT =
*        OUTPUT DATA-LCCAPDAT BIT ON,MAYBE LCCAPSG1 BIT ON,ALL OTHER
*                    INFO IN THE PSA
*        OUTPUT REGISTERS-NONE
*        OUTPUT ENVIRONMENT-DISABLED,KEY 0,SUPERVISOR STATE,ANY LOCK
*                           MAY BE HELD,IN MASTER MEMORY ADDRESS
*                           SPACE
*
*02*     RETURN-CODES = NONE
*
*01*  EXIT-NORMAL = RTM(PROGCK)
*
*02*     CONDITIONS = IF A TRANSLATION SPECIFICATION HAS OCCURED AND
*        CONTROL REGISTER 0 BITS 8-12 ARE INVALID FOR TRANSLATION, A
*        DEFAULT VALUE FOR C.R.0 IS LOADED AND RTM IS ENTERED TO
*        INITIATE RECOVERY TERMINATION. THIS ENTRY IS ALSO USED IF 1) A
*        PROGRAM FLIH RECURSION HAS OCCURED, 2) A INTERRUPT OTHER THAN
*        AN MC OR PER HAPPENED IN DISABLED CODE, 3) A SEGMENT EXCEPTION
*        ,INVALID PAGE EXCEPTION, SSM INSTRUCTION OR ANY PROGRAM CHECK
*        HAS OCCURED IN SRB MODE, IN A LOCALLY LOCKED TCB, IN AN
*        UNLOCKED TCB IN SUPERVISOR STATE, OR AN UNLOCKED TCB IN
*        PROBLEM STATE WITHOUT A SPIE EXIT OR 4) A NON-RECURSIVE
*        TRANSLATION SPECIFICATION HAS OCCURRED.
*
*02*     OUTPUT = 5 CASES                                      @G64RPXO
*        CASE 1: PROGRAM FLIH RECURSION
*        OUTPUT DATA-REGS IN LCCAPGR1 ALL OTHER IN HARDWARE STORED
*                    LOCATIONS
*        OUTPUT REGISTERS-1=NEGATIVE
*        OUTPUT ENVIRONMENT-DISABLED,KEY 0,SUPERVISOR STATE,ANY
*                           LOCK HELD
*        CASE 2: C.R.0 BAD
*        OUTPUT DATA-SAME AS CASE 1
*        OUTPUT REGS-1=COMPLETION CODE X'069'
*        OUTPUT ENVIRONMENT-SAME AS CASE 1
*        CASE 3: TRANSLATION SPECIFICATION OR ADDRESSING EXCEPTION
*        ALL OUTPUT AS IN CASE 1 WITH ADDITION LCCAPSG1 BIT OFF
*        CASE 4: RETURN CODE FROM THE SLIP PROCESSSOR WAS      @G64RPXO
*        NON-ZERO.                                             @G64RPXO
*        CASE 5: ALL OTHER REASONS                             @G64RPXO
*        OUTPUT DATA-REGS IN LCCAPGR2,PSW IN LCCAPPSW, ILC AND
*                    INTERRUPT CODE IN LCCAPINT, TRANSLATION ADDRESS
*                    IN LCCAPVAD(IF ANY)
*        OUTPUT REGISTERS-NONE
*        OUTPUT ENVIRONMENT-SAME AS CASE 1
*
*02*     RETURN-CODES = NONE
*
*01*  EXIT-NORMAL = BACK TO INTERRUPTED PROGRAM
*
*02*     CONDITIONS = IF AN MC OR PER INTERRUPT ALONE WAS THE CAUSE OF
*        THE PROGRAM INTERRUPTION, RETURN VIA A LPSW WILL BE BACK TO
*        THE INTERRUPTED PROGRAM AFTER THE NECESSARY TRACING HAS BEEN
*        PERFORMED. OR IF A PAGE EXCEPTION HAS OCCURED AND THE PAGING
*        SUPERVISOR WAS ABLE TO RECLAIM THE PAGE, RETURN VIA A LPSW
*        WILL BE BACK TO THE INTERRUPTED PROGRAM.
*
*02*     OUTPUT = ALL STATUS AND INFO AS AT INTERRUPT TIME
*
*02*     RETURN-CODES = NONE
*
*01*  EXIT-NORMAL = SPIE ROUTINE(TO HANDLE PAGE EXCEPTION)
*
*02*     CONDITIONS = WHEN A PAGE EXCEPTION HAS OCCURED AND THE
*        INTERRUPTED PROGRAM IS NEITHER  IN SRB MODE NOR IN SUPERVISOR
*        STATE AND THE TCBPIE17 BIT IS ON INDICATING A SPIE IS IN
*        EFFECT TO HANDLE THE PAGE EXCEPTION, A LPSW IS TAKEN TO THE
*        SPIE EXIT IF A RECURSIVE PROGRAM INTERRUPTION HAS NOT OCCURED
*        IN SETTING UP THE PIE/PICA.
*
*02*     OUTPUT =
*        OUTPUT DATA-PIE IS SET UP, THE RBOPSW IS SET UP, AND THE
*                    PROGRAM MASK IS AS INDICATED IN THE PICA.
*        OUTPUT REGISTERS-0=TRANSLATION EXCEPTION ADDRESS,
*                         1=ADDRESS OF PIE
*                         14=ADDRESS OF RETURN POINT
*                         15=ADDRESS OF SPIE EXIT
*                         ALL OTHERS AS AT INTERRUPT
*        OUTPUT ENVIRONMENT-ENABLED,PROBLEM STATE,NO LOCKS
*
*02*     RETURN-CODES = NONE
*
*01*  EXIT-NORMAL = PAGING SUPERVISOR(RSM)
*
*02*     CONDITIONS = RETURN TO CALLER AFTER RESET REQUEST HAS BEEN
*        SATISFIED
*
*02*     OUTPUT = NONE TO PAGING SUPERVISOR
*
*02*     RETURN-CODES = NONE
*
*01*  EXIT-NORMAL = RTM/SLIP PROCESSOR(HANDLE PER INTERRUPT)   @G64RPXO
*                                                              @G64RPXO
*02*     CONDITIONS = IF A PER INTERRUPT OCCURS IEAVTPER IS    @G64RPXO
*        CALLED.                                               @G64RPXO
*                                                              @G64RPXO
*02*     OUTPUT =                                              @G64RPXO
*        OUTPUT REGISTERS:                                     @G64RPXO
*                  REGISTERS 11-15 AND 0-3 ARE AVAILABLE TO    @G64RPXO
*                  IEAVTPER AS WORK REGISTERS.                 @G64RPXO
*                                                              @G64RPXO
*02*     RETURN-CODES:                                         @G64RPXO
*                  0=RESTORE THE ENVIRONMENT OF THE INTERRUPTED@G64RPXO
*                    PROCESS AND RESUME AT THE POINT OF        @G64RPXO
*                    INTERRUPTION.                             @G64RPXO
*                  NON-ZERO=FORCE ENTRY TO RECOVERY FOR THE    @G64RPXO
*                    INTERRUPTED PROCESS.                      @G64RPXO
*                                                              @G64RPXO
*01*  EXIT-NORMAL = RETURN TO INTERRUPTED PROCESS IF PER ALONE @G64RPXO
*                   OCCURS WITH THE PROGRAM RECURSION          @G64RPXO
*                   INDICATOR (PSAPI) ON.                      @G64RPXO
*                                                              @G64RPXO
*02*     CONDITIONS = A PER INTERRUPT HAS OCCURRED DURING      @G64RPXO
*                     PROCESSING IN A ROUTINE CALLED BY THE    @G64RPXO
*                     PROGRAM FLIH.                            @G64RPXO
*                                                              @G64RPXO
*02*     OUTPUT =  THE PER BIT IN THE RESUME PSW IS RESET, THE @G64RPXO
*                  ENVIRONMENT OF THE INTERRUPTED PROCESS IS   @G64RPXO
*                  RESTORED AND A LPSW INSTRUCTION IS EXECUTED @G64RPXO
*                  TO CAUSE RESUMPTION OF PROCESSING AT THE    @G64RPXO
*                  POINT OF INTERRUPTION.                      @G64RPXO
*                                                              @G64RPXO
*02*     RETURN-CODES = NONE                                   @G64RPXO
*
*01*  EXIT-ERROR = SYSTEM TERMINATION ROUTINE (IGFPTERM)
*
*02*     CONDITIONS = TRANSLATION SPECIFICATION RECURSION OR SEGMENT
*        EXCEPTION RECURSION(SECOND TIME) HAS OCCURED.
*
*02*     OUTPUT =
*        OUTPUT DATA- 2 WORD PARAMETER LIST
*        WORD 1 = ADDR WTO BUFFER CONTAINING MESSAGE IEA999W
*        WORD 2 = ADDR LOG REC BUFFER CONTAINING WAIT STATE  CODE X'14'
*        OUTPUT REGISTERS- REG 1 = ADDR PARAMETER LIST
*        OUTPUT ENVIRONMENT-DISABLED FOR DAT, I/O AND EXT INTERRUPTS
*        SUPERVISOR STATE, KEY 0, ANY LOCK HELD
*02*     RETURN-CODES = NONE
*
*01*  EXIT-ERROR = RTM (DATERR) OR (PROGCHK)
*
*02*     CONDITIONS = RECURSION IN THE TOP SEGMENT OF THE PROGRAM FLIH
*        DUE TO:
*        1. DAT-TYPE ERRORS REFERENCING THE LCCA ADDRESSES
*           IN A USER MEMORY  (DATERR ENTRY)
*        2. THE LCCA ADDRESSES HAVE BEEN OVERLAID IN LOW-CORE.
*           (PROGCHK ENTRY)
*
*02*     OUTPUT=
*        CASE 1: USUAL DATERR ENTRY -- MASTER'S C.R.1 HAS BEEN
*           LOADED , AND THE REGISTERS AT TIME OF INTERRUPT ARE IN
*           LCCAPGR1.
*        CASE2: PROGCHK ENTRY -- THE LCCA AND PCCA POINTERS HAVE BEEN
*           RESTORED, THE PC FLIH STACK IS CURRENT AND THE SUPER BIT
*           HAS BEEN SET.  A COMPLETION CODE OF X'4FC' IS PASSED IN
*           REGISTER 1.  THE INCORRECT VALUES OF LOCATIONS
*           X'208' - '217' ARE IN THE FIRST FOUR WORDS OF LCCAPGR1.
*
*01*  EXTERNAL-REFERENCES = SEE ROUTINES,DATA AREAS,CONTROL-BLOCKS
*     BELOW
*
*02*     ROUTINES =
*        AHLMCIH(GTF HANDLER)
*        IGFPTERM (SYSTEM TERMINATION FACILITY)
*        IEAVPIX(PAGING SUPERVISOR)
*        TRPI(TRACE ROUTINE)
*        IEAVPSRB(PIE/PICA SRB ROUTINE)
*        IEA0DS(MAIN DISPATCHER ENTRY)
*        RTM(DATERR)
*        RTM(PROGCK)
*        STATUS RESET
*        RTM(ABTERM)
*        SETLOCK (OBTAIN/RELEASE)
*        GETCELL
*        RTM(PGIOERR)
*        SCHEDULE
*        POST(NO ECB)
*        IEAVTPER(SLIP PER INTERFACE ROUTINE)                  @G64RPXO
*
*02*     DATA-AREAS = ALL INCLUDED IN CONTROL-BLOCKS BELOW
*
*02*     CONTROL-BLOCKS =
*        PSA R/W
*        PCCA R
*        LCCA R/W
*        SRB R/W
*        SSRB W
*        ASCB R/W
*        TCB R/W
*        CVT R
*        SCA R/W
*        PIE R/W
*        PICA R
*        RB R/W
*        ASXB R
*        IHSA W
*        WSAG R
*        SSRB R/W
*        SCVT R/W
*        SDWA W
*        PVT R
*        PCCAT R
*        LCCAT R
*
*01*  TABLES = NONE
*
*01*  MACROS =
*        SCHEDULE
*        CALLRTM
*        HOOK
*        SETLOCK
*        SETRP
*        GETCELL
*
*01*  CHANGE-ACTIVITY = Y0715,Y02751,Y02752,D04015
*                       OZ31350 - GO INTO USER KEY BEFORE
*                       REFERENCING PICA                       @ZA31350
*                       OZ32144 = STORE CPU TIMER IF TASK INTERRUPTED
*                                 AND TASK TIMING IS ACTIVE. RESET CPU
*                                 TIMER IF IN TASK MODE AND NOT
*                                 RETURNING TO THE DISPATCHER. @ZA32144
*                       G64RPXO = SLIP/PER SUPPORT             @G64RPXO
*                       ZM49481 = PLACE TRAS TEST PRIOR TO
*                                 TCBTQE TEST                  @ZM49481
*                       ZP60023 = ADDITIONS FOR SSAR, DAS, AND SOME Z
*                                 OPCODES - GREG PRICE  2008   @ZP60023
*                                 Z OPCODES REMOVED     2016   @ZP60023
*
*01*  MESSAGES = NONE
*
*01*  ABEND-CODES =
*        X'0CX'-CODE DEPENDING ON TYPE OF PROGRAM CHECK
*        X'0FB'-BAD C.R. 0 TRANSLATION EXCEPTION
*        X'028'-INTERNAL ERROR IN PAGING SUPERVISOR
*        X'4FC'-LOW CORE OVERLAY                               @YM08516
*
**** END OF SPECIFICATIONS ***/
         EJECT
          SPACE 2
*/*IEAVEPC: CHART PROG FLIH */
*/* HEADER
*/*
*/*
*/*
*/*                                                  SECTION 3.1.8.4
*/* PROGRAM FLIH
*/*                                                  PAGE # */
          SPACE 2
IEAVEPC  CSECT
***      MODID BR=NO
         DC    CL8'IEAVEPC'
         DC    CL9' UZ36571 '
         DC    CL8'04/08/81'
         DC    CL9' ZP60023 '
***********************************************************************
*                                                                     *
*                       REGISTER EQUATES                              *
*                                                                     *
***********************************************************************
CR0      EQU   0                       CONTROL REG 0
CR1      EQU   1                       CONTROL REG 1
CR3      EQU   3                       CONTROL REG 3           @ZP60023
CR4      EQU   4                       CONTROL REG 4           @ZP60023
CR7      EQU   7                       CONTROL REG 7           @ZP60023
FPR0     EQU   0                       FLOATING POINT REG
FPR2     EQU   2                       FLOATING POINT REG
FPR4     EQU   4                       FLOATING POINT REG
FPR6     EQU   6                       FLOATING POINT REG
R0       EQU   0                       GENERAL REG
CPIDREG  EQU   0                       CELL POOL ID REG
COREREG  EQU   0                       GETMAIN REG
R1       EQU   1                       GENERAL REG
PARMREG  EQU   1                       PARAMETER REG
XPIEREG  EQU   1                       PIE ADDRESS
SRBCRREG EQU   1                       SRB CELL REG
R2       EQU   2                       GENERAL REGISTER        @ZA06785
TEMP0    EQU   2                       EVEN WORK REGISTER      @YM08516
R3       EQU   3                       GENERAL REG
ASCBREG  EQU   3                       ASCB REG
CVTREG2  EQU   3                       CVT ADDRESS
TEMP1    EQU   3                       ODD WORK REGISTER       @YM08516
XPIPICA  EQU   3                       PICA REG
PVTPTR   EQU   3                       PVT ADDR FOR SUSPEND ROUTINE
SCAREG2  EQU   3                       SCA ADDRESS
R4       EQU   4                       GENERAL REG
FOOTMARK EQU   4                       RECURSION FOOT PRINT    @YM08516
XTCBREG  EQU   4                       TCB ADDRESS
R5       EQU   5                       GENERAL REG
XPIEREG2 EQU   5                       PIE ADDRESS
RBPTR    EQU   5                       RB ADDRESS
SRBREG   EQU   5                       SRB ADDRESS
R6       EQU   6                       GENERAL REGISTER 6      @YM08516
ASXBREG  EQU   6                       ASXB ADDRESS
DISPRTN  EQU   6                       DISPATCHER ADDRESS
ERREG    EQU   6                       ERROR CODE REGISTER
IHSAREG  EQU   6                       IHSA ADDRESS
XPICODE  EQU   6                       PROGRAM CODE REG
SCHLREG  EQU   6                       SCHEDULE REG
TEMPREG  EQU   6                       TEMPORARY SAVE REG
R7       EQU   7                       GENERAL REG
CCABASE  EQU   7                       LCCA ADDRESS
XSRBREG  EQU   7                       SRB REG
R8       EQU   8                       GENERAL REG             @ZA06785
ASCBBASE EQU   8                       ASCB ADDR FOR SUSPEND ROUTINE
XPICAREG EQU   8                       PICA ADDRESS
SRBSAVER EQU   8                       SRB SAVE AREA ADDRESS
WORKREG2 EQU   8                       WORK REG
R9       EQU   9                       BASE REG FOR IEAVSPER   @ZA06785
BASEREG  EQU   9                       BASE REG
R10      EQU   10                      GENERAL REG
XTRBASE  EQU   10                      TRACE ENTRY POINT ADDRESS
WORKREG1 EQU   10                      WORK REG
R11      EQU   11                      GENERAL REG
XTRET    EQU   11                      TRACE BR INSTRUCTION ADDRESS
WORKREG3 EQU   11                      WORK REG
R12      EQU   12                      GENERAL REG 12
WORKREG4 EQU   12                      WORK REG
R13      EQU   13                      GENERAL REG
CVTREG   EQU   13                      CVT ADDRESS
R14      EQU   14                      GENERAL REG
PCCABASE EQU   14                      PCCA BASE REG
RETREG   EQU   14                      RETURN ADDRESS
WORKREG  EQU   14                      WORK REG
R15      EQU   15                      GENERAL REG
EPREG    EQU   15                      ENTRY POINT ADDRESS
CCABASE2 EQU   15                      LCCA BASE REG
RTCDREG  EQU   15                      RETURN CODE REG
SCAREG   EQU   15                      SCA ADDRESS
***********************************************************************
*                                                                     *
*                       CONSTANT EQUATES                              *
*                                                                     *
***********************************************************************
EXIT     EQU   3                       EXIT SVC
PRCODE   EQU   X'04'                   PROTECTION CHECK CODE
ADCODE   EQU   X'05'                   ADDRESS EXCEPT CODE     @YM08516
SGCODE   EQU   X'10'                   SEGMENT CODE
PGCODE   EQU   X'11'                   PAGE FAULT CODE
TRCODE   EQU   X'12'                   TRANSLATION EXCEPT CODE @YM08516
SOCODE   EQU   X'13'                   SPECIAL OP CHECK CODE   @ZP60023
PERCODE  EQU   X'80'                   PER CODE
CR0MASK  EQU   X'80'                   BIT 8-12 C.R.0 MASK
RCDTYPE  EQU   X'81'                   RECORD TYPE OF LOG REC BUFFER
L1       EQU   1                       LENGTH VALUE
L2       EQU   2                       LENGTH VALUE            @YM08516
L4       EQU   4                       LENGTH VALUE
L6       EQU   6                       LENGTH VALUE
L8       EQU   8                       LENGTH VALUE
L12      EQU   12                      LENGTH VALUE
L60      EQU   60                      LENGTH VALUE
L64      EQU   64                      LENGTH VALUE
L84      EQU   84                      LENGTH VALUE
L256     EQU   256                     LENGTH VALUE
M1       EQU   1                       MASK VALUE
M4       EQU   4                       MASK VALUE              @YM08215
M7       EQU   7                       MASK VALUE
M8       EQU   8                       MASK VALUE
M11      EQU   11                      MASK VALUE
M12      EQU   12                      MASK VALUE
M15      EQU   15                      MASK VALUE
ZERO     EQU   0                       DISPLACEMENT VALUE
FOUR     EQU   4                       DISPLACEMENT VALUE
FIVE     EQU   5                       DISPLACEMENT VALUE
EIGHT    EQU   8                       DISPLACEMENT VALUE
ELEVEN   EQU   11                      DISPLACEMENT VALUE
C0       EQU   0                       DISPLACEMENT VALUE
C1       EQU   1                       DISPLACEMENT VALUE
C2       EQU   2                       DISPLACEMENT VALUE
C3       EQU   3                       DISPLACEMENT VALUE
C4       EQU   4                       DISPLACEMENT VALUE
C5       EQU   5                       DISPLACEMENT VALUE
C6       EQU   6                       DISPLACEMENT VALUE
C8       EQU   8                       DISPLACEMENT VALUE
C12      EQU   12                      DISPLACEMENT VALUE      @ZA06785
C16      EQU   16                      DISPLACEMENT VALUE
C24      EQU   24                      DISPLACEMENT VALUE
C28      EQU   28                      DISPLACEMENT VALUE
C36      EQU   36                      DISPLACEMENT VALUE      @YM08516
C48      EQU   48                      DISPLACEMENT VALUE
C56      EQU   56                      DISPLACEMENT VALUE
C60      EQU   60                      DISPLACEMENT VALUE
C256     EQU   256                     DISPLACEMENT VALUE
CX00     EQU   X'00'                   IMMEDIATE VALUE
CX01     EQU   X'01'                   IMMEDIATE VALUE
CX02     EQU   X'02'                   IMMEDIATE VALUE
CX03     EQU   X'03'                   IMMEDIATE VALUE
CX04     EQU   X'04'                   IMMEDIATE VALUE
CX0C     EQU   X'0C'                   IMMEDIATE VALUE         @ZP60023
CX0F     EQU   X'0F'                   IMMEDIATE VALUE
CX10     EQU   X'10'                   IMMEDIATE VALUE
CX3F     EQU   X'3F'                   IMMEDIATE VALUE
CX80     EQU   X'80'                   IMMEDIATE VALUE
CXC0     EQU   X'C0'                   IMMEDIATE VALUE
CXEF     EQU   X'EF'                   IMMEDIATE VALUE         @ZP60023
CXF0     EQU   X'F0'                   IMMEDIATE VALUE
CXF8     EQU   X'F8'                   IMMEDIATE VALUE
CXFA     EQU   X'FA'                   IMMEDIATE VALUE
CXFF     EQU   X'FF'                   IMMEDIATE VALUE
NODAT    EQU   X'FB'                   IMMEDIATE VALUE         @ZA32144
COMPCOD1 EQU   X'0FB'                  BAD C.R.0 COMP CODE
WAITCODE EQU   X'14'                   SYSTEM TERM WAIT STATE CODE
PCABCODE EQU   X'4FC'                  PC FLIH FRR ABEND CODE  @YM08516
SRBERRCC EQU   X'6FC'                  SRB FRR COMPLETION CODE
PIXABEND EQU   X'028'                  ABEND CODE FOR IEAPIX FAILURE
ASNABEND EQU   X'0D7'                  ASN TRANSLATE FAILURE   @ZP60023
PERBIT   EQU   X'40'                   PER BIT IN PSW BYTE 0   @G64RPXO
PERICODE EQU   X'80'                   PER INTERRUPTION CODE   @G64RPXO
MCICODE  EQU   X'40'                   MONITOR CALL CODE       @G64RPXO
         EJECT
         USING PSA,0
PROGSVC3 SVC   EXIT                    SPECIAL SVC 3 FOR SPIE EXITS-
*                                      PLACEMENT IN FRONT OF IEAQPK00
         ENTRY IEAPSVC3
          SPACE 2
*/*IEAQPK00: E IEAQPK00 */
          SPACE 2
         ENTRY IEAQPK00
IEAPSVC3 DS    0H                      ENTRY STATEMENT FOR EXIT
IEAQPK00 DS    0H
          SPACE 2
*/* P SAVE TWO REGS IN PSAPIREG */
          SPACE 2
         ST    CCABASE,PSAPIREG        SAVE ONE REGISTER IN PSA
         ST    BASEREG,PSAPIR2                                 @YM08516
          SPACE 2
*/* P ESTABLISH ADDRESSABILITY */
          SPACE 2
         BALR  BASEREG,C0              ESTABLISH
         USING *,BASEREG               ADDRESSABILITY
ADDRESS  DS    0H                                              @YM08516
         SPACE 2
*/* D (NO,,YES,PSAREF) RECURSION IN FLIH? */
         SPACE 2
         TM    PSASUP3,PSAPI2          RECURSION IN FLIH?      @YM08516
         BO    PSAREF                  IF SO TRY TO RECOVER    @YM08516
         SPACE 2
*/* P SET RECURSION2 BIT ON */
         SPACE 2
         OI    PSASUP3,PSAPI2          SET RECURSION BIT ON    @YM08516
          SPACE 2
*/* P SAVE CURRENT TIMER VALUE                              */ @ZA32144
         SPACE 2                                               @ZA32144
         L     CCABASE,PSAPCCAR        REAL PCCA ADDRESS       @ZA32144
         TM    PCCAINTE-PCCA(CCABASE),PCCANUIN  CPU TIMER OK?  @ZA32144
         BZ    GETSPT                  YES, GO STORE THE TIMER @ZA32144
         XC    PSAPCPSW(C8),PSAPCPSW   ZERO TIMER VALUE        @ZA32144
         B     NOSPT                   DO NOT SAVE TIMER       @ZA32144
GETSPT   EQU   *                                               @ZA32144
         STPT  PSAPCPSW                SAVE CPU TIMER          @ZA32144
         SPACE 1                                               @ZA32144
NOSPT    EQU   *                                               @ZA32144
         SPACE 2                                               @ZA32144
*/* P GET LCCA ADDR FROM PSALCCAR */
          SPACE 2
         L     CCABASE,PSALCCAR        GET REAL ADDRESS OF LOGICAL CCA
         USING LCCA,CCABASE            ESTABLISH BASE TO LCCA
          SPACE 2
*/* P SAVE ALL REGS IN LCCAPGR1 */
          SPACE 2
         STM   R0,R15,LCCAPGR1         SAVE ALL REGS IN LCCA AREA
         L     WORKREG,PSAPIREG        GET REGISTER SAVED INITIALLY
         ST    WORKREG,LCCAPGR1+C28    SAVE REGISTER USED
         L     WORKREG,PSAPIR2         GET REGISTER 2 SAVED    @YM08516
         ST    WORKREG,LCCAPGR1+C36    SAVE REGISTER USED      @YM08516
          SPACE 2
*/* P REFRESH CVT ADDR FROM INTERNAL ADCON */
          SPACE 2
         L     CVTREG,ADCVT            GET CVT ADDRESS
         ST    CVTREG,FLCCVT           REFRESH CVT POINTER
         ST    CVTREG,FLCCVT2
          SPACE 2
*/* P PICK UP INTERRUPT CODE WITH PER OFF */                   @G64RPXO
          SPACE 2
         USING CVT,CVTREG              ESTABLISH BASE TO CVT
         LH    XPICODE,FLCPICOD        GET PROGRAM INTRPR CODE
         LA    WORKREG,CXFF-PERCODE    GET MASK TO TURN PER OFF
         NR    XPICODE,WORKREG         TURN PER OFF IN REG
         SPACE 2
*/* D (YES,DATON,NO,) PAGE FAULT? */
         SPACE 2
PGFLTST  DS    0H
         STC   XPICODE,PSAPIR2         STORE PI CODE           @YM08516
         CLI   PSAPIR2,PGCODE          IS INTRPT PAGE FAULT    @YM08516
         BE    DATON                   IF SO GO HANDLE         @YM08516
          SPACE 2
*/*TRANSTST: D (YES,TRANS1,NO,) TRANS SPEC? */
          SPACE 2
TRANSTST DC    0H'0'                   TEST LABEL
         CLI   PSAPIR2,TRCODE          IS INTRPT TRANS SPEC
         BE    TRANS1                  IF SO GO PROCESS
          SPACE 2
*/* D (YES,TRANS3,NO,) ADDRESS EXCEPTION? */
          SPACE 2
         CLI   PSAPIR2,ADCODE          IS INTRPT ADDR EXCEPTION
         BE    TRANS3                  IF SO CHECK NEXT ACTION
          SPACE 2
*/*SEGTST: D (NO,DATON,YES,) SEG EXCEPTION? */
          SPACE 2
SEGTST   DC    0H'0'                   TEST LABEL
         CLI   PSAPIR2,SGCODE          IS INTRPT SEGMENT EXCEP
         BNE   DATON                   IF NOT PROCEED
          SPACE 2
*/* D (YES,TRANS2,NO,) SEG RECURSION? */
          SPACE 2
         TM    LCCAIHR1,LCCAPSG1       IS THIS A SEGMENT RECURSION
         BO    TRANS2                  IF SO TRY TO RECOVER
          SPACE 2
*/* P SET SEG REC BIT */
          SPACE 2
         OI    LCCAIHR1,LCCAPSG1       SET SEGMENT RECURSION BIT
          SPACE 2
*/*DATON: P ENABLE PSW FOR DAT */
          SPACE 2
DATON    STOSM LCCAPSMK,CX04           ENABLE FOR DAT
         L     CCABASE,PSALCCAV        GET VIRTUAL ADDRESS OF LCCA
          SPACE 2
*/*PIERCTST: D (YES,BADPIE,NO,PIRCTST) PIE RECURSION? */
          SPACE 2
PIERCTST DC    0H'0'                   TEST LABEL
         TM    LCCAIHR1,LCCAPPIE       IS THE PIE RECURSION BIT ON
         BO    PIEREC                  IF SO GO PROCESS RECURSION
          SPACE 2
*/*PIRCTST: D (NO,PROGCONT,YES,) PROGRAM RECURSION? */
          SPACE 2
PIRCTST  DC    0H'0'                   TEST LABEL
         TM    PSASUP1,PSAPI           DID A PROGRAM RECURSION OCCUR
         BNO   PROGCONT                IF NOT CONTINUE
          SPACE 2
*/* P TURN OFF PER BIT IN INTERRUPT CODE */                    @G64RPXO
          SPACE 2
         NI    FLCPICOD+C1,CXFF-PERCODE RESET PER BIT IN CODE  @G64RPXO
          SPACE 2
*/* P TURN PER OFF IN RESUME PSW */                            @G64RPXO
          SPACE 2
         NI    FLCPOPSW,CXFF-PERBIT    TURN PER BIT OFF IN PSW @G64RPXO
          SPACE 2
*/* D (YES,,NO,ERR35) PER ONLY ? */                            @G64RPXO
          SPACE 2
         CLI   FLCPICOD+C1,C0          ANY PROGRAM INTERRUPT ? @G64RPXO
         BNE   ERR35                   NO...PROCESS RECURSION  @G64RPXO
          SPACE 2
*/* P RESTORE ALL REGISTERS */                                 @G64RPXO
          SPACE 2
         LM    R0,R15,LCCAPGR1         RESTORE ALL REGISTERS   @G64RPXO
          SPACE 2
*/* P CLEAR PSAPI2 RECURSION FLAG */                           @G64RPXO
          SPACE 2
         NI    PSASUP3,CXFF-PSAPI2     CLEAR RECURSION FLAG    @G64RPXO
          SPACE 2
*/* R EXIT TO INTERRUPTED PROCESS */                           @G64RPXO
          SPACE 2
         LPSW  FLCPOPSW                EXIT TO INTERRUPTED RTN @G64RPXO
          SPACE 2
*/*ERR35:  P (,ERR2) SET UP -1 COMPLETION CODE */              @G64RPXO
          SPACE 2
ERR35    EQU   *                                               @G64RPXO
         NI    PSASUP3,CXFF-PSAPI2-PSAPSREG
*                                      CLEAR RECURSION 2 BITS  @YM08516
         MVC   FLCTRACE,CVTTRCA        REFRESH TRACE HEADER    @YA02352
         SR    R1,R1                   ZERO REG 1
         BCTR  R1,C0                   DECREMENT TO MINUS FOR COMPCODE
         B     ERR2                    PROCEED TO RTM          @ZA10452
          SPACE 2
*/*PROGCONT: P SAVE CURRENT FRR STACK POINTER */
          SPACE 2
PROGCONT EQU   *                                               @ZA32144
         L     WORKREG,PSACSTK         GET CURRENT STACK PTR
         ST    WORKREG,PSAPSAV         SAVE CURRENT PTR IN SAVE AREA
          SPACE 2
*/* P MAKE PROG FLIH STACK CURRENT */
          SPACE 2
         L     WORKREG,PSAPSTK         GET PROGRAM FLIH STACK PTR
         ST    WORKREG,PSACSTK         SET PROGRAM FLIH STACK PTR
          SPACE 2
*/* P SET PROGRAM FLIH RECURSION */
          SPACE 2
         OI    PSASUP1,PSAPI           SET PROGRAM FLIH BIT
         SPACE 2
*/* P CLEAR RECURSION2 BIT */
         SPACE 2
         NI    PSASUP3,CXFF-PSAPI2-PSAPSREG
         NI    LCCAIHR1,CXFF-LCCAPSG1
*                                      CLEAR RECURSION 2 BIT   @YM08516
          SPACE 2
*/* S STCPUT: SAVE TIMER VALUE    */                           @ZA32144
         SPACE 2                                               @ZA32144
         BAL   R11,STCPUT              CALL SAVE TIME ROUTINE  @ZA32144
         STCK  PSAPCPSW                SAVE CLOCK FOR JST      @ZA32144
         SPACE 2                                               @ZA32144
*/* P MOVE REGS LCCAPGR1 TO LCCAPGR2 */
          SPACE 2
         MVC   LCCAPGR2(L64),LCCAPGR1  MOVE SAVED REGISTERS INTO SAFE
*                                      AREA FROM RECURSIONS
          SPACE 2
*/* P MOVE PSW PIOPSW TO LCCAPPSW */
          SPACE 2
         MVC   LCCAPPSW(L8),FLCPOPSW   MOVE PSW TO SAFE AREA
          SPACE 2
*/* P MOVE ILC AND INT CODE TO LCCAPINT */
          SPACE 2
         L     WORKREG,FLCPIILC-C1     MOVE ILC AND INTERRUPT CODE
*                                      INTO REGISTER
         ST    WORKREG,LCCAPINT        SAVE ILC AND INTERRUPT CODE
*                                      INTO SAFE AREA
          SPACE 2
*/* P MOVE TRANS ADDR TO LCCAPVAD */
          SPACE 2
         L     WORKREG,FLCTEA          GET DAT EXCEPTION ADDRESS
         ST    WORKREG,LCCAPVAD        SAVE DAT EXCEPTION ADDRESS
*                                      REGISTERS 0,1,15 AS ON ENTRY
          SPACE 2
*/* D (YES,,NO,EXIT10) PER INTERRUPT ? */                      @G64RPXO
          SPACE 2
         TM    LCCAPINT+C3,PERCODE     IS THIS A PER INTERRUPT?@G64RPXO
         BZ    EXIT10                  IF NO, BYPASS PER CHECKS@G64RPXO
          SPACE 2
*   NOTE:  THE IEAVTPER ROUTINE DESTROYS REGS 0-3 AND 11-15    @G64RPXO
*/* S IEAVTPER: CALL SLIP/PER ROUTINE  */                      @G64RPXO
          SPACE 2
         L     R15,AIEATPER            OBTAIN SLIP EPA         @G64RPXO
         BALR  R14,R15                 CALL INTERFACE ROUTINE  @G64RPXO
         SPACE 2
*/* P RESTORE CVT ADDRESS */                                   @G64RPXO
         SPACE 2
         L     CVTREG,ADCVT            OBTAIN CVT @            @G64RPXO
         SPACE 2
*/* D (YES,,NO,RESETPER) PER/MC ONLY ? */                      @G64RPXO
         SPACE 2
         TM    LCCAPINT+C3,CXFF-(PERICODE+MCICODE) PER/MC ONLY?@G64RPXO
         BNZ   RESETPER                NO, RESET PER FLAG      @G64RPXO
          SPACE 2
*/* D (YES,,NO,EXIT10) SLIP RC = 0 ?   */                      @G64RPXO
          SPACE 2
         LTR   R15,R15                 PER HANDLED OK ?        @G64RPXO
         BNZ   EXIT10                  NO, TRACE ERROR         @G64RPXO
          SPACE 2
*/*RESETPER: P CLEAR PER FLAG */                               @G64RPXO
          SPACE 2
RESETPER EQU   *                                               @G64RPXO
         NI    LCCAPINT+C3,CXFF-PERCODE CLEAR PER CODE         @G64RPXO
          SPACE 2
*/* D (YES,,NO,GOBACK) ANY CODE LEFT ? */                      @G64RPXO
          SPACE 2
         BZ    CPUTIME                 NO, FINISHED PER PROCESS@G64RPXO
          SPACE 2
*/*EXIT10: D (YES,,NO,GTF1) IS TRACE TO BE DONE ? */           @G64RPXO
          SPACE 2
EXIT10   EQU   *                                               @G64RPXO
         CLI   LCCAPINT+C3,SOCODE      SPECIAL OPERATION EXCEP?@ZP60023
         BE    CHK4SSAR                IF SO PROCESS           @ZP60023
SKIPSSAR EQU   *                                               @ZP60023
         CLI   CVTTRACE+C1,CXFA        IS TRACE TO BE DONE
         BNE   GTF1                    IF NOT DONT TRACE
         SPACE 2
*/* P RESTORE REGS 1 AND 15 AND SETUP FOR TRACE */             @G64RPXO
          SPACE 2
         L     R1,LCCAPGR2+C4          RESTORE GPR1            @G64RPXO
         L     R15,LCCAPGR2+C60        RESTORE GPR15           @G64RPXO
         L     XTRBASE,ATRPI           GET PI TRACE ENTRY ADDRESS
         L     WORKREG,CVTTRCA         GET TRACE HEADER        @ZA10452
         ST    WORKREG,FLCTRACE        RESTORE TRACE HEADER    @ZA10452
          SPACE 2
*/*TRACEEP: L TRACE-- VIA BALR 11,10 */
          SPACE 2
TRACEEP  DC    0H'0'                   TEST LABEL
         BALR  XTRET,XTRBASE           GO TO TRACE
          SPACE 2
*/*GTF1: L GTF-- HANDLE MC OR TRACE INTERRUPT */
          SPACE 2
GTF1     HOOK  EID=IEAPINT,TYPE=BP     GO HANDLE MC OR TRACE INTERRUPT
          SPACE 2
*/*MCPERTST: D (YES,GOBACK,NO,) WAS INTERRUPT ONLY PER/MC? */
          SPACE 2
MCPERTST DC    0H'0'                   TEST LABEL
         NI    LCCAPINT+C3,CXFF-MCICODE TURN OFF MC + DETERMINE@G64RPXO
*                                       IF ONLY PER/MC INTRUPT @G64RPXO
         BZ    CPUTIME                 IF NOT RETURN TO INTERRUPTED
*                                      PROGRAM
          SPACE 2
*/*DISTST1: D (YES,ERR1,NO,) PSW DISABLED? */
          SPACE 2
DISTST1  DC    0H'0'                   TEST LABEL
         TM    LCCAPPSW,CX03           WAS PSW DISABLED
         BC    M12,ERR1                IF SO PROCEED TO RECOVERY
          SPACE 2
*/*PGTST: D (YES,PAGEPR,NO,) PAGE FAULT? */
          SPACE 2
PGTST    DC    0H'0'                   TEST LABEL
         CLI   LCCAPINT+C3,PGCODE      IS INTERRUPT A PAGE FAULT
         BE    PAGEPR                  IF SO PROCESS
          SPACE 2
*/*PROGCK: D (YES,ERR1,NO,) SRB MODE? */
          SPACE 2
PROGCK   DS    0H
         TM    LCCADSF2,LCCASRBM       IS PROGRAM IN SRB MODE
         BO    ERR1                    IF SO PROCEED TO RECOVERY
          SPACE 2
*/*LTST1: L (YES,ERR1,NO,) SETLOCK-- ANY LOCKS HELD? */
          SPACE 2
LTST1    DC    0H'0'                   TEST LABEL
         SETLOCK TEST,TYPE=ALL,BRANCH=(HELD,ERR1),REGS=(WORKREG)
*                                      ANY LOCKS HELD?
          SPACE 2
*/*TCBERR1: P GET TCB ADDR FROM PSATOLD */
          SPACE 2
TCBERR1  DC    0H'0'                   TEST LABEL
         L     XTCBREG,PSATOLD         GET CURRENT TCB ADDRESS
         USING TCB,XTCBREG
          SPACE 2
*/* P MOVE LCCAPGR2 REGS TO TCBGRS */
          SPACE 2
         MVC   TCBGRS(L64),LCCAPGR2    MOVE REGS TO TCB SAVE AREA
          SPACE 2
*/* P GET RB ADDR FROM TCBRBP */
          SPACE 2
         L     RBPTR,TCBRBP            GET RB ADDRESS
         USING RBSECT,RBPTR
          SPACE 2
*/* P MOVE LCCAPPSW TO RBOPSW */
          SPACE 2
         MVC   RBOPSW(L8),LCCAPPSW     MOVE PSW TO RB SAVE AREA
          SPACE 2
*/*SPSTTST2: D (YES,ERR1,NO,) SUPV STATE? */
          SPACE 2
SPSTTST2 DC    0H'0'                   TEST LABEL
         TM    LCCAPPSW+C1,CX01        IS PROGRAM IN SUPERVISOR STATE
         BZ    ERR1                    IF SO PROCEED TO RECOVERY
         L     SCAREG,TCBPIE           GET PIE ADDRESS
         LA    SCAREG,C0(SCAREG)       CLEAR ANY STATUS BITS IN REG
          SPACE 2
*/*PIE2TST1: D (NO,ERR1,YES,) IS THERE A PIE? */
          SPACE 2
PIE2TST1 DC    0H'0'                   TEST LABEL
         LTR   SCAREG,SCAREG           IS THERE A PIE
         BZ    ERR1                    IF NOT PROCEED TO RECOVERY
          SPACE 2
         USING SCA,SCAREG
         L     XPIEREG,SCAPIE          GET ADDRESS OF PIE
         LA    XPIEREG,C0(XPIEREG)     CLEAR ANY HIGH ORDER BITS
          SPACE 2
*/*PIE2TST2: D (YES,ERR1,NO,) IS PIE ADDR ZER0? */
          SPACE 2
PIE2TST2 DC    0H'0'                   TEST LABEL
         LTR   XPIEREG,XPIEREG         IS PIE EXISTENT
         BZ    ERR1                    IF NOT PROCEED TO RECOVERY
          SPACE 2
*/* D (YES,ERR1,NO,) IS INTERRUPT PER ? */                     @G64RPXO
          SPACE 2
         TM    LCCAPINT+C3,PERICODE    IS INTERRUPT PER ?      @G64RPXO
         BO    ERR1                    IF SO, SKIP PIE PROCESS @G64RPXO
          SPACE 2
*/* D (NO,SCAINIT,YES,) IS INTERRUPT PAGE FAULT OR SEG EXCEP? */
          SPACE 2
         TM    LCCAPINT+C3,CX10        IS INTERRUPT PAGE OR SEG CODE
         BZ    SCAINIT                 IF NOT DONT CONVERT
          SPACE 2
*/* P RESET INTERRUPT CODE TO X'04' AND ZERO ILC VALUE */
          SPACE 2
         MVI   LCCAPINT+C3,PRCODE      RESET TO PROTECTION
         MVI   LCCAPINT+C1,CX00        RESET ILC TO ZERO
          SPACE 2
*/*SCAINIT: P CLEAR SEG REC BIT */
          SPACE 2
SCAINIT  LA    XPIEREG,SCASRB          GET ADDRESS OF PIE/PICA SRB
         NI    LCCAIHR1,CXFF-LCCAPSG1  CLEAR SEG. REC. BIT IF ON
          SPACE 2
*/* P GET ASCB ADDR FROM PSAAOLD */
          SPACE 2
         L     ASCBREG,PSAAOLD         GET ASCB ADDRESS
         USING ASCB,ASCBREG
         USING SRBSECT,XPIEREG
          SPACE 2
*/* P PUT ASCB ADDR IN SRBASCB */
          SPACE 2
         ST    ASCBREG,SRBASCB         PLACE ASCB ADDRESS IN SRB
          SPACE 2
*/* P GET ASCBASID AND PUT IN SRBPASID */
          SPACE 2
         LH    WORKREG,ASCBASID        GET ASID VALUE FOR MEMORY
         STH   WORKREG,SRBPASID        PLACE ASID VALUE IN SRB
          SPACE 2
*/* P PUT TCB ADDR IN SRBPTCB */
          SPACE 2
         ST    XTCBREG,SRBPTCB         PLACE TCB ADDRESS IN SRB
          SPACE 2
*/* P PUT SRB ROUTINE ADDR IEAVPSRB IN SRBEP AND INDICATE SYSTEM
*/*PRIORITY */
          SPACE 2
         LA    WORKREG,IEAVPSRB        GET ROUTINE ENTRY POINT
         ST    WORKREG,SRBEP           PLACE ROUTINE ENTRY POINT IN SRB
         MVI   SRBPRIOR,CX00           INDICATE SYSTEM LEVEL SRB
          SPACE 2
*/* P GET ADDR OF SRBEND AND PUT IN SRBPARM */
          SPACE 2
         LA    WORKREG,SCAPARMS        GET ADDRESS OF PARMS
         ST    WORKREG,SRBPARM         STORE ADDRESS OF PARMS IN SRB
          SPACE 2
*/* P PUT RB ADDR IN AT END OF SRB(PARM) */
          SPACE 2
         ST    RBPTR,SCAPARMS          STORE RB ADDRESS IN SRB
          SPACE 2
*/* P PUT ILC AND INT CODE AFTER RB ADDR */
          SPACE 2
         L     WORKREG,LCCAPINT        GET ILC + INT. CODE VALUES
         ST    WORKREG,SCAPARMS+C4     STORE ILC AND INT CODE IN SRB
         MVC   SCAPARMS+C8(L8),LCCAPPSW MOVE PSW TO PARMS FIELD
          SPACE 2
*/* P SET TCB NON-DISP TCBPIEND=1 TCBDNSSP=1 */
          SPACE 2
         OI    TCBNDSP1,TCBPIEND       SET NON-DISP BIT FOR PIE/PICA
*                                      PROCESSING
         OI    TCBFLGS5,TCBPNDSP       SET NON-DISP SUMMARY BIT
         L     WORKREG,ASCBTCBS        LOAD VALUE OF READY TCBS
          SPACE 2
*/*DECTCBS: P DECREMENT COUNT OF READY TCBS VIA CS IN ASCBTCBS */
          SPACE 2
DECTCBS  LR    WORKREG2,WORKREG        TRANSFER VALUE TO REG
         BCTR  WORKREG2,C0             DECREMENT COUNT
CSINS1   DC    0H'0'                   TEST LABEL
         CS    WORKREG,WORKREG2,ASCBTCBS REPLACE OLD WITH NEW
         BC    M4,DECTCBS              IF UNEQUAL TRY AGAIN    @YM08215
*                                      XPIEREG=1
         DROP  XPIEREG
         DROP  SCAREG
          SPACE 2
*/*SCHED: L SCHEDULE-- SRB TO DO PIE/PICA PROCESS */
          SPACE 2
SCHED    SCHEDULE SRB=(1)              SCHEDULE SRB FOR PIE/PICA PROCES
          SPACE 2
*/*DISPRET: P MOVE CLOCK AND CLEAR PROGRAM FLIH BIT */
          SPACE 2
DISPRET  L     DISPRTN,AIEA0DS         GET DISPATCHER ENTRY ADDRESS
         L     WORKREG2,PSATOLD        HAS J.S.T. BEEN DONE?   @YM08398
         LTR   WORKREG2,WORKREG2       IF TOLD=0 IT HAS, SO    @YM08398
         BZ    CLRPBIT                 BYPASS MOVING CLOCK     @YM08398
         MVC   LCCAITOD,PSAPCPSW       MOVE CLOCK VALUE FOR JOB STEP
*                                      TIMING CALCULATIONS     @YM08398
CLRPBIT  NI    PSASUP1,CXFF-PSAPI      CLEAR PROGRAM FLIH BIT
          SPACE 2
*/*TCBXIT: R EXIT TO DISPATCHER */
          SPACE 2
TCBXIT   DC    0H'0'                   TEST LABEL
         BR    DISPRTN                 BRANCH TO DISPATCHER
          SPACE 2
*/*TRANS1: D (YES,LOADWAIT,NO,) TRANS RECURSION? */
          SPACE 2
TRANS1   TM    LCCAIHR1,LCCAPDAT       IS THIS A TRANSLATION RECURSION
*                                      MEANING MASTER MEMORY IS BAD
         BO    LOADWAIT                IF SO LOAD WAIT STATE
          SPACE 2
*/*STCTL1: P GET C.R.0 VALUE IN LCCACR0 */
          SPACE 2
STCTL1   DC    0H'0'                   TEST LABEL
         ENTRY IEADSS01
IEADSS01 STCTL CR0,CR0,LCCACR0         STORE C.R.0 FOR CHECKING
         NI    LCCACR0+C1,CXF8         TURN OFF BITS 13-15 FOR A
*                                      COMPARE
          SPACE 2
*/*DATBITS: D (YES,MASCHECK,NO,) IS CR 0  OK? */
          SPACE 2
DATBITS  DC    0H'0'                   TEST LABEL
         CLI   LCCACR0+C1,CR0MASK      ARE DAT BITS IN CR0 OK
         BE    MASCHECK                IF SO CHECK NEXT ACTION
          SPACE 2
*/*LCTL1: P (,DATENON) LOAD DEFAULT VALUE */
          SPACE 2
LCTL1    DC    0H'0'                   TEST LABEL
         LCTL  CR0,CR0,DFLCR0          LOAD DEFAULT CR0 VALUE
         LA    R1,COMPCOD1             GET UNIQUE COMP CODE
         B     DATENON
          SPACE 2
*/*TRANS3: D (YES,LOADWAIT,NO,) TRANSLATION RECURSION? */
          SPACE 2
TRANS3   TM    LCCAIHR1,LCCAPDAT       IS THIS A TRANSLATION RECURSION
*                                      MEANING MASTER MEMORY IS BAD
         BO    LOADWAIT                IF SO LOAD WAIT STATE
          SPACE 2
*/*MASCHECK: D (YES,MASMEM,NO,) IS THIS MASTER MEMORY? */
          SPACE 2
MASCHECK TM    LCCAIHR1,LCCAPSG1       IS MASTER BIT ON
         BO    MASMEM                  IF SO SWITCH TO MASTER
*                                      MEMORY
          SPACE 2
*/* P SET SEG RECURSION BIT */
          SPACE 2
         OI    LCCAIHR1,LCCAPSG1       SET MASTER BIT
         NI    PSASUP3,CXFF-PSAPI2-PSAPSREG
*                                      CLEAR RECURSION 2 BITS  @YM08516
         SR    R1,R1                   ZERO REG 1
         BCTR  R1,0                    DECREMENT REG 1 TO MINUS 1
          SPACE 2
*/*DATENON: P ENABLE PSW FOR DAT */
          SPACE 2
DATENON  STOSM LCCAPSMK,CX04           ENABLE DAT
         L     CCABASE,PSALCCAV        GET VIRTUAL ADDRESS OF LCCA
          SPACE 2
*/* S STCPUT: SAVE TIMER VALUE   */                            @ZA32144
        SPACE  2                                               @ZA32144
        BAL    R11,STCPUT              CALL SAVE TIMER ROUTINE @ZA32144
        STCK   PSAPCPSW                SAVE CLOCK FOR JST      @ZA32144
        SPACE  2                                               @ZA32144
*/* D (NO,GTF2,YES,) IS TRACE TO BE DONE? */
          SPACE 2
ERR2     CLI   CVTTRACE+C1,CXFA        IS TRACE TO BE DONE   @ZA10452
         BNE   GTF2                    IF NOT DONT TRACE
          SPACE 2
*/* P GET CVTTRACE VALUE AND TRPIEP */
          SPACE 2
         MVC   FLCTRACE,CVTTRCA        REFRESH TRACE HEADER    @YA02352
         LR    WORKREG,R1              SAVE REG 1 VALUE(COMPCODE)
         L     R1,LCCAPGR1+C4          GET ORIGINAL REG 1 VAL FOR TRACE
         L     XTRBASE,ATRPI           GET PI TRACE ENTRY ADDRESS
          SPACE 2
*/*TRACEEP2: L EP=CVTTRACE--  BALR 11,10 */
          SPACE 2
TRACEEP2 DC    0H'0'                   TEST LABEL
         BALR  XTRET,XTRBASE           GO TO TRACE
         LR    R1,WORKREG              RESTORE COMPCODE VALUE
          SPACE 2
*/*GTF2: L (,ERR3) GTF-- RECORD INTERRUPT */
          SPACE 2
GTF2     HOOK  EID=IEATINT,TYPE=BP     GO TRACE TRANSLATION ERROR
          SPACE 2
*/*ERR3: L () CALL RTM-- TYPE=PROGCK SPECIAL E.P. NO RETURN */
          SPACE 2
ERR3     CALLRTM TYPE=PROGCK,COMPCOD=(R1) GO TO RTM
          SPACE 2
*/*TRANS2: D (YES,LOADWAIT,NO,) TRANSLATION RECURSION? */
          SPACE 2
TRANS2   DS    0H
         TM    LCCAIHR1,LCCAPDAT       IS THIS A TRANSLATION RECURSION
         BO    LOADWAIT                IF SO LOAD WAIT STATE
          SPACE 2
*/*MASMEM: P SET TRANSLATION RECURSION BIT */
          SPACE 2
MASMEM   OI    LCCAIHR1,LCCAPDAT       SET TRANSLATION RECURSION BIT
         NI    PSASUP3,CXFF-PSAPI2-PSAPSREG
*                                      CLEAR RECURSION 2 BITS  @YM08516
          SPACE 2
*/*LCTL2: P LOAD MASTER C.R.1 FROM LCCAMCR1 */
          SPACE 2
LCTL2    DC    0H'0'                   TEST LABEL
         LCTL  CR1,CR1,LCCAMCR1        LOAD MASTER MEMORY STOR REG
          SPACE 2
*/*DATENON2: P ENABLE PSW FOR DAT AND ZERO LCCAITOD */
          SPACE 2
DATENON2 DC    0H'0'                   TEST LABEL
         XC    LCCAITOD,LCCAITOD       ZERO LCCAITOD FOR J.S.T.@YM08398
         STOSM LCCAPSMK,CX04           ENABLE DAT              @YM30128
          SPACE 2
*/* D (NO,GTF3,YES,) IS TRACE TO BE DONE? */
          SPACE 2
         CLI   CVTTRACE+C1,CXFA        IS TRACE TO BE DONE
         BNE   GTF3                    IF NOT DONT TRACE
          SPACE 2
*/* P GET CVTTRACE VALUE AND TRPI EP */
          SPACE 2
         MVC   FLCTRACE,CVTTRCA        REFRESH TRACE HEADER    @YA02352
         L     XTRBASE,ATRPI           GET PI TRACE ENTRY ADDRESS
          SPACE 2
*/*TRACEEP3: L EP=CVTTRACE-- BALR 11,10 */
          SPACE 2
TRACEEP3 DC    0H'0'                   TEST LABEL
         BALR  XTRET,XTRBASE           GO TO TRACE
          SPACE 2
*/*GTF3: L GTF-- RECORD INTERRUPT */
          SPACE 2
GTF3     HOOK  EID=IEATINT,TYPE=BP     GO TRACE TRANSLATION ERROR
          SPACE 2
*/*DATERREP: L () CALL RTM-- TYPE=DATERR NO RETURN */
          SPACE 2
DATERREP DC    0H'0'                   TEST LABEL
         CALLRTM TYPE=DATERR           GO TO RTM
         EJECT
*/*PSAREF: P TRY TO RECOVER LOW CORE OVERLAY */
         SPACE 2
PSAREF   DS    0H                                              @YM08516
         SPACE 2
*/* D (YES,RECURS1,NO,) RECURSIVE ENTRY? */
         SPACE 2
         TM    PSASUP3,PSAPSREG        CHECK RECURSION FLAG    @YM08516
         BO    RECURS1                 WILL SWITCH TO MASTER   @YM08516
         SPACE 2
*/* P SET RECURSION FLAG */
         SPACE 2
         OI    PSASUP3,PSAPSREG   SET RECURSION FLAG ON        @YM08516
         SPACE 2
*/* P REFRESH CVT FROM V-CON */
         SPACE 2
         L     CVTREG,ADCVT       REFRESH CVT PTR              @YM08516
         ST    CVTREG,FLCCVT                                   @YM08516
         SPACE 2
*/*CPUPAREF: P REFRESH PSACPUPA */
         SPACE 2
CPUPAREF DS    0H                                              @YM08516
         L     TEMP1,CVTCSD       OBTAIN CSD ADDRESS           @YM08516
         LRA   TEMP1,CSDFLAGS-CSD(TEMP1)                       @YM08516
*                                 OBTAIN ADDRESS OF FLAG FIELD @YM08516
         BNZ   DATERR             CSDFLAGS ADDRESS IS NOT TRANSLATABLE
         TM    C0(TEMP1),CSDMP    CHECK IF ON MP               @YM08516
         BZ    UPCONFIG           ON UP                        @YM08516
         STAP  PSACPUPA           STORE CPU PHYSICAL ADDRESS   @YM08516
         B     LCCATCHK           CONTINUE VERIFYING LCCAT     @YM08516
UPCONFIG DS    0H                                              @YM08516
         XC    PSACPUPA(L2),PSACPUPA
*                                 CPU PHYSICAL ADDRESS = 0     @YM08516
         SPACE 2
*/*LCCATCHK: P (NE 0,DATERR,EQ 0,) LRA ON CVTLCCAT */
         SPACE 2
LCCATCHK DS    0H
         LH    TEMP1,PSACPUPA     OBTAIN PHYSICAL CPU ADDRESS  @YM08516
         SLL   TEMP1,C2           MULTIPLY BY 4                @YM08516
         L     TEMP0,CVTLCCAT     OBTAIN ADDRESS OF LCCAVT     @YM08516
         AR    TEMP0,TEMP1        ADDRESS LCCAT(PA)            @YM08516
         SPACE 2
*/* P (NE 0,DATERR,EQ 0,) LRA ON LCCAT(CPUPA) */
         SPACE 2
         LRA   TEMP1,0(TEMP0)     CHECK LCCAT(PA) **VIRTUAL**  @YM08516
         BNZ   DATERR             LCCAT(PA) NOT TRANSLATABLE   @YM08516
         L     TEMP0,0(TEMP1)          GET LCCA VIRT ADDR      @YM08516
         LRA   TEMP1,0(TEMP0)          CHECK LCCAV             @YM08516
         BNZ   DATERR                  LCCAV NOT TRANSLATABLE  @YM08516
         SPACE 2
*/*LCCACHK: D (NO,DATERR,YES,) LCCAR--> 'LCCA' ? */
         SPACE 2
LCCACHK  DS    0H
         CLC   LCCAEBC(L4),0(TEMP1)
*                                 CHECK FIRST WORD IS 'LCCA'   @YM08516
         BNE   DATERR
         SPACE 2
*/* P REFRESH PSALCCAV AND PSALCCAR */
         SPACE 2
         LM    R0,R1,PSALCCAV          GET OLD LCCA VALUES     @YM08516
         STM   R0,R1,LCCAPGR1-LCCA(TEMP1)
*                                      SAVE IN LCCAPGR1        @YM08516
         ST    TEMP0,PSALCCAV     REFRESH PSALCCAV             @YM08516
         ST    TEMP1,PSALCCAR     REFERSH PSALCCAR             @YM08516
         SPACE 2
*/* P REFRESH PSAPCCAV AND PSAPCCAR FROM PCCAT */
         SPACE 2
         LH    TEMP1,PSACPUPA    OBTAIN PHYSICAL CPU ADDRESS   @ZA03845
         SLL   TEMP1,C2           MULTIPLY BY 4                @YM08516
         L     TEMP0,CVTPCCAT          GET PCCAT ADDRESS       @YM08516
         AR    TEMP0,TEMP1                                     @YM08516
         LRA   TEMP1,0(TEMP0)                                  @YM08516
         BNZ   DATERR                                          @YM08516
         L     TEMP0,0(TEMP1)          CHECK PCCAT(PA)         @YM08516
         LRA   TEMP1,0(TEMP0)          CHECK PCCAV             @YM08516
         BNZ   DATERR                  PCCAV NOT TRANSLATABLE  @YM08516
         LM    R0,R1,PSAPCCAV          GET OLD PCCA VALUES     @YM08516
         ST    TEMP0,PSAPCCAV                                  @YM08516
         ST    TEMP1,PSAPCCAR                                  @YM08516
         SPACE 2
*/* P (,ERR3) SET UP TO GO TO RTM WITH X'4FC' CODE */
         SPACE 2
         STOSM PSAPIR2,CX04            ENABLE DAT              @YM08516
         L     CCABASE,PSALCCAV        ADDRESS LCCA            @YM08516
         STM   R0,R1,LCCAPGR1+C8       SAVE OLD PCCA VALUES    @YM08516
*                                           IN LCCAPGR1        @YM08516
         MVC   PSAPSAV,PSACSTK         SAVE CURRENT STACK      @YM08516
         MVC   PSACSTK,PSAPSTK         PROGRAM FLIH STACK      @YM08516
         OI    PSASUP1,PSAPI           TURN ON SUPER FLAG      @YM08516
         NI    PSASUP3,CXFF-PSAPI2-PSAPSREG
*                                      TURN OFF RECURS 2 BITS  @YM08516
         LA    R1,PCABCODE             SET COND CODE=X'4FC'    @YM08516
         B     ERR2                    GO TO RTM               @ZA10452
         SPACE 2
*/*RECURS1: P  LCTL MASTER'S C.R.1 */
         SPACE 2
RECURS1  DS    0H                                              @YM08516
         LCTL  CR1,CR1,PSASTOR        SWITCH TO MASTER'S C.R.1 @YM08516
         SPACE 2
*/*DATERR: P SET UP FOR DATERR */
         SPACE 2
DATERR   DS    0H
         L     CCABASE,PSALCCAR   SET UP FOR DAT ERROR         @YM08516
         OI    LCCAIHR1,LCCAPSG1                               @YM08516
         SPACE 2
*/* P (,MASMEM ) TERMINATE MEMORY */
         SPACE 2
         B     MASMEM              CONTINUE FLIH PROCESSING    @YM08516
         EJECT
*/*LOADWAIT: P SET UP LOGOUT AREA FOR SYSTEM TERMINATION */
         SPACE 2
LOADWAIT DS    0H                      SET UP FOR SYSTEM TERMINATION
         USING PCCA,PCCABASE
         L     PCCABASE,PSAPCCAR       ESTABLISH BASE TO PSA FROM PSA
         L     PARMREG,PCCALRBR        GET ADDRESS OF LOG REC BUFFER
         DROP  PCCABASE
         SPACE 2
*/* P MOVE WTO MESSAGE IEA999W INTO LOG OUT AREA */
         SPACE 2
         USING LOGOUT,PARMREG
         MVC   LOGWTOM(L60),MSG999W    MOVE MESSAGE INTO WTO AREA
         LA    WORKREG,LOGWTOM         PARM 1 = ADDR OF WTO MESSAGE
         ST    WORKREG,LOGWTOA
         SPACE 2
*/* P MOVE PERTINENT INFO INTO LOG REC BUFFER */
         SPACE 2
         LA    WORKREG,LOGLRB          PARM 2 = ADDR OF LOG REC BUFFER
         ST    WORKREG,LOGLRBA
         XC    LOGLHDR,LOGLHDR         CLEAR LRB HEADER
         MVI   LOGLRCDT,RCDTYPE        PUT RECORD TYPE IN HEADER
         LA    WORKREG,LOGLRBSZ        SIZE OF LRB IN HEADER
         ST    WORKREG,LOGLSIZE
         SPACE 2
*/* P LOAD WAIT STATE CODE = X'14' INTO LOG REC HEADER */
         SPACE 2
         LA    WORKREG,WAITCODE        WAIT-STATE CODE FOR SYSTEM TERM
         ST    WORKREG,LOGLCODE
         MVC   LOGLGPR(L64),LCCAPGR1   REGISTERS AT TIME OF INTERRUPT
         STCTL CR0,CR1,LOGLCR0         CONTROL REGS 0 AND 1
         MVC   LOGLOPSW,FLCPOPSW       PC FLIH OLD PSW
         MVC   LOGLILC(C4),PSAEPPSW    ILC AND INTERRUPT CODE
         MVC   LOGLTNEW(C16),PSATNEW   TNEW,TOLD,ANEW AND AOLD
         SPACE 2
*/* L () IGFPTERM-- GO TO SYSTEM TERMINATION ROUTINE */
         SPACE 2
         L     R15,SYSTERM             GET ADDR OF SYSTEM TERM. RTN
         BR    R15
         EJECT
*/*ERR1: P CLEAR PROGRAM FLIH BIT */
         SPACE 2
ERR1     NI    PSASUP1,CXFF-PSAPI      CLEAR PROGRAM FLIH BIT
         SPACE 2
*/* P RESTORE FRR STACK TO OLD CURRENT */
         SPACE 2
         L     WORKREG,PSAPSAV         GET SAVED STACK PTR
         ST    WORKREG,PSACSTK         MAKE SAVE PTR CURRENT
          SPACE 2
*/*ERR: L () CALLRTM-- TYPE=PROGCK NO RETURN */
         SPACE 2
ERR      CALLRTM TYPE=PROGCK           PROCEED TO RECOVERY
PIEREC   DS    0H
          SPACE 2
*/*BADPIE: P CLEAR SUPER SPIE RECUR BIT AND SEGMENT RECUR
*/*BIT */
          SPACE 2
BADPIE   NI    LCCAIHR1,CXFF-LCCAPPIE-LCCAPSG1  CLEAR PIE RECURSION
*                                      AND SEGMENT REC BITS
         NI    PSASUP3,CXFF-PSAPI2-PSAPSREG
*                                      CLEAR RECURSION 2 BITS  @YM08516
         B     PGSUPER                 GO TO PAGING SUPERVISOR
          SPACE 2
*/*PAGEPR: D (YES,PGSUPER,NO,SPSTTST1) SRB MODE? */
          SPACE 2
PAGEPR   DS    0H
SRBTST1  DC    0H'0'                   TEST LABEL
         TM    LCCADSF2,LCCASRBM       IS PROGRAM IN SRB MODE
*ZP60023 BZ    SPSTTST1                IF NOT, CONTINUE CHECKING
*ZP60023 B     PGSUPER                 IF SO PROCEED TO PAGING SUPV.
         BNZ   PGSUPER                 IF SO PROCEED TO PAGING SUPV.
          SPACE 2
*/*SPSTTST1: D (YES,PGSUPER,NO,) SUPV STATE? */
          SPACE 2
SPSTTST1 DC    0H'0'                   TEST LABEL
         TM    LCCAPPSW+C1,CX01        IS PROGRAM IN SUPV. STATE
         BZ    PGSUPER2       @ZP60023 IF SO PROCEED TO PAGING SUPV.
          SPACE 2
*/* P GET TCB ADDR FROM PSATOLD */
          SPACE 2
         L     XTCBREG,PSATOLD         GET TCB ADDRESS
         USING TCB,XTCBREG
          SPACE 2
*/*SUPSPCK: D (YES,SUPSPIE,NO,) EXTENDED PICA? */
          SPACE 2
SUPSPCK  DC    0H'0'                   TEST LABEL
         TM    TCBFLGS6,TCBPIE17       IS THERE AN EXTENDED PICA
         BO    SUPSPIE                 IF SO GO HANDLE SPIE    @ZA11376
          SPACE 2
PGSUPER2 DC    0H'0'                   TASK DAS PAGE FAULT CHK @ZP60023
         TM    LCCAPVAD,CX80           2NDARY ASID PAGE FAULT? @ZP60023
         BNO   PGSUPER                 NO, CONTINUE            @ZP60023
         L     WORKREG,PSAAOLD         GET ASCB ADDRESS        @ZP60023
         USING ASCB,WORKREG            GET ASCB ADDRESSABILITY @ZP60023
         STCTL CR3,CR3,LCCACR0         STORE C.R.3 FOR CHECKING@ZP60023
         CLC   ASCBASID,LCCACR0+2      SASN = PASN?            @ZP60023
         BE    PGSUPER                 YES, CAN PAGE IN SELF   @ZP60023
         STCTL CR7,CR7,LCCACR0         STORE C.R.7 FOR CHECKING@ZP60023
         CLC   ASCBSTOR,LCCACR0        PASID STO = SASID STO ? @ZP60023
         BE    PGSUPER                 YES, CAN PAGE IN SELF   @ZP60023
         L     WORKREG,ASCBLDA         GET LDA ADDRESS         @ZP60023
         DROP  WORKREG                 DROP ASCB ACCESS        @ZP60023
         USING LDA,WORKREG             GET LDA ADDRESSABILITY  @ZP60023
         L     WORKREG,ASDPQE          GET PRIVATE PQE ADDRESS @ZP60023
         DROP  WORKREG                 DROP LDA ACCESS         @ZP60023
         L     WORKREG2,PQESIZE(,WORKREG)                      @ZP60023
         L     WORKREG,PQEREGN(,WORKREG)                       @ZP60023
         AR    WORKREG,WORKREG2        POINT TO CSA START      @ZP60023
         CLM   WORKREG,7,LCCAPVAD+1    CSA ABOVE TEA?          @ZP60023
         BNH   PGSUPER                 NO, COMMON IS RESOLVABLE@ZP60023
         SETLOCK TEST,TYPE=LOCAL,BRANCH=(HELD,PROGCK)          @ZP60023
         B     INFLIGHT                UNLOCKED TCB SO PAGE-IN @ZP60023
          SPACE 2
*/*PGSUPER: L IEAPIX-- RETURN REG14 */
          SPACE 2
PGSUPER  L     R15,AIEAPIX             GET ADDRESS OF PAGING SUPV.
PGSPEP   DC    0H'0'                   TEST LABEL
         BALR  R14,R15                 BR TO IEAPIX
          SPACE 2
*/*IEAVEPXR: P REESTABLISH ADDRESSABILITY */
          SPACE 2
         ENTRY IEAVEPXR
IEAVEPXR DS    0H                      RETURN FROM IEAPIX
         USING *,R14
         L     BASEREG,AADDRESS        GET ORIGINAL ADDRESSABILITY ADD.
         DROP  R14                     REESTABLISH
         USING ADDRESS,BASEREG         ADDRESSABILITY
          SPACE 2
*/* P RELOAD LCCA FROM PSALCCAV */
          SPACE 2
         L     CCABASE,PSALCCAV        RELOAD LCCA ADDRESS
          SPACE 2
*/*SUSPTST: D (YES,DISPRET,NO,) WAS USER SUSPENDED? */
          SPACE 2
SUSPTST  DC    0H'0'                   TEST LABEL
         LTR   RTCDREG,RTCDREG         WAS PROGRAM SUSPENDED
         BZ    DISPRET                 IF SO EXIT TO DISPATCHER
          SPACE 2
*/*RCTST: D (=4,GOBACK,=8,PROGCK,=12,PIXABD) CHECK RETURN CODE FROM
*/*IEAPIX */
          SPACE 2
RCTST    DC    0H'0'                   TEST LABEL
         LA    WORKREG,EIGHT           LOAD COMPARE VALUE
         CR    RTCDREG,WORKREG         CHECK RETURN CODE FROM IEAPIX
         BL    CPUTIME                 RC = 4: PAGE RECLAIMED  @ZA32144
         BE    PROGCK                  RC = 8: INVALID PAGING EXCEPTION
         BH    PIXABD                  RC =12: ERROR IN PIX PROCESSING
         SPACE 1                                               @ZA32144
CPUTIME  EQU   *                                               @ZA32144
         L     R15,PSATOLD             GET TCB ADDRESS         @ZA32144
         LTR   R15,R15                 IS THERE A TCB?         @ZA32144
         BZ    GOBACK                  NO, RETURN              @ZA32144
         L     WORKREG,PSAPCCAV        VIRTUAL PCCA ADDRESS    @ZA32144
         OC    LCCAASID,LCCAASID       DIE ACTIVE?
         BNZ   GOBACK                  NO
         TM    PCCAINTE-PCCA(WORKREG),PCCANUIN  CPU TIMER OK?  @ZA32144
         BO    GOBACK                  NOT OK, DO NOT UPDATE   @ZA32144
         L     WORKREG,TCBTME-TCB(R15)  GET TQE POINTER        @ZA32144
         LTR   WORKREG,WORKREG         DOES A TQE EXIST?       @ZA32144
         USING TQE,WORKREG             GET TQE ADDRESSABILITY  @ZA32144
         BNP   GOBACK                  NOT TASK MODE TIMING    @ZA32144
         SETLOCK TEST,TYPE=LOCAL,BRANCH=(HELD,LDSACPUT)        @ZA32144
         SPT   TQEVAL                  SET TIMER FROM TQE      @ZA32144
         DROP  WORKREG                 DROP ADDRESSABILITY     @ZA32144
         B     GOBACK                  RETURN TO INT PROGRAM   @ZA32144
LDSACPUT L     WORKREG,PSAAOLD         GET ASCB ADDRESS        @ZA32144
         USING ASCB,WORKREG            GET ASCB ADDRESSABILITY @ZA32144
         L     WORKREG,ASCBASXB        GET ASXB ADDRESS        @ZA32144
         DROP  WORKREG                 DROP ADDRESSABILITY     @ZA32144
         USING ASXB,WORKREG            GET ASXB ADDRESSABILITY @ZA32144
         L     WORKREG,ASXBIHSA        GET IHSA ADDRESS        @ZA32144
         DROP  WORKREG                 DROP ADDRESSABILITY     @ZA32144
         USING IHSA,WORKREG            GET IHSA ADDRESSABILITY @ZA32144
         SPT   IHSACPUT                SET TIMER FROM IHSA     @ZA32144
         DROP  WORKREG                 DROP ADDRESSABILITY     @ZA32144
          SPACE 2
*/*GOBACK: P MOVE LCCAPPSW TO PIOPSW */
          SPACE 2
GOBACK   MVC   PSAPCPSW(L8),LCCAPPSW   MOVE BACK TO PROGRAM OLD
*                                      PSW TO ALLOW FOR LPSW
          SPACE 2
*/* P LOAD ALL REGS FROM LCCAPGR2 */
          SPACE 2
         LM    R0,R15,LCCAPGR2         RESTORE ALL REGS
          SPACE 2
*/* P CLEAR PROGRAM FLIH BIT AND RESTORE STACK */
          SPACE 2
         NI    PSASUP1,CXFF-PSAPI      CLEAR PROGRAM BIT
         MVC   PSACSTK(4),PSAPSAV      RESTORE SAVED STACK PTR
          SPACE 2
*/*RCRTN: R EXIT VIA LPSW ON PIOPSW */
          SPACE 2
RCRTN    DC    0H'0'                   TEST LABEL
         LPSW  PSAPCPSW                RETURN TO INTERRUPTED PROGRAM
          SPACE 2
*/*PIXABD: P LOAD ALL REGS FROM LCCAPGR2 */
          SPACE 2
PIXABD   DS    0H                      IF RC >8, ABEND
         LM    R0,R15,LCCAPGR2         RESTORE ALL REGS
          SPACE 2
*/* P CLEAR PROGRAM FLIH BIT AND RESTORE THE STACK */
          SPACE 2
         NI    PSASUP1,CXFF-PSAPI      CLEAR PROGRAM BIT
         MVC   PSACSTK(4),PSAPSAV      RESTORE SAVED STACK PTR
         SPACE 2
*/* L () ABEND-- ABEND THE TASK WITH CODE X'028' */
         SPACE 2
         LA    PARMREG,PIXABEND        PUT PIX ABEND CODE IN REG 1
         ABEND (1),DUMP,,SYSTEM        ABEND THE TASK
          SPACE 2
*/*SUPSPIE: P GET PIE ADDRESS FROM THE TCB */
          SPACE 2
SUPSPIE  L     SCAREG,TCBPIE           GET PTR TO PIE ADDRESS
         LA    SCAREG,C0(SCAREG)       CLEAR ANY STAUS BITS IN REG
          SPACE 2
*/*PIETST1: D (YES,PGSUPER,NO,) IS TCBPIE = 0? */
          SPACE 2
PIETST1  DC    0H'0'                   TEST LABEL
         LTR   SCAREG,SCAREG           IS PTR TO PIE ADDRESS ZERO
         BZ    PGSUPER2       @ZP60023 IF SO PROCEED TO HANDLE PAGE
*                                      FAULT
         USING SCA,SCAREG
         L     XPIEREG,SCAPIE          GET PIE ADDRESS
         LA    XPIEREG,C0(XPIEREG)     CLEAR ANY STATUS BITS IN REG
          SPACE 2
*/*PIETST2: D (YES,PGSUPER,NO,) IS PIE ADDR ZERO? */
          SPACE 2
PIETST2  DC    0H'0'                   TEST LABEL
         LTR   XPIEREG,XPIEREG         IS PIE ADDRESS 0
         BZ    PGSUPER2       @ZP60023 IF SO PROCEED TO HANDLE PAGE
*                                      FAULT
*        FROM  HERE SUSEPTABLE TO PAGE FAULTS
         SPACE 2
*/* P SET PIE RECURSION BIT LCCAPPIE = 1 */
         SPACE 2
         OI    LCCAIHR1,LCCAPPIE       SET PIE RECURSION BIT
         USING PIE,XPIEREG
         L     XPIPICA,PIEPICA         GET PICA ADDRESS FROM PIE
          SPACE 2
*/*PIETST3: D (YES,BADPIE,NO,) IS PICA 0 OR PIE BUSY? */
          SPACE 2
PIETST3  DC    0H'0'                   TEST LABEL
         LTR   XPIPICA,XPIPICA         IS PIE BUSY OR NO PICA
         BNP   BADPIE                  IF SO PROCEED TO HANDLE PAGE
*                                      FAULT
         USING PICA,XPIPICA
          SPACE 2
*/*PIETST4: D (NO,BADPIE,YES,) IS PICA EXTENDED? */
          SPACE 2
PIETST4  DC    0H'0'                   TEST LABEL
         TM    PICITMK1,PICAEXT        IS PICA EXTENDED
         BNO   BADPIE                  IF NOT PROCEED TO HANDLE PAGE
*                                      FAULT
          SPACE 2
*/*PIETST5: D (NO,BADPIE,YES,) CAN PAGE FAULT BE HANDLED? */
          SPACE 2
PIETST5  DC    0H'0'                   TEST LABEL
         TM    PICITMK3,PICACD17       CAN PAGE FAULT BE HANDLED
         BNO   BADPIE                  IF NOT PROCEED TO HANDLE PAGE
*                                      FAULT
          SPACE 2
*/* P SET PROTECT KEY = TCB KEY */
          SPACE 2
         IC    WORKREG,TCBPKF          GET TCB PROTECT KEY
         SPKA  0(WORKREG)              SET PROTECT KEY TO USER KEY
          SPACE 2
*/* P MOVE USER REGS 14-2 TO PIEGR14- PIEGR2 */
          SPACE 2
         MVC   PIEGR14(L8),LCCAPGR2+C56 MOVE REGS 14 AND 15 TO PIE
         MVC   PIEGR0(L12),LCCAPGR2    MOVE REGS 0-2 TO PIE
          SPACE 2
*/* P BUILD BC MODE PSW AND PVT IN PIEPSW */
          SPACE 2
         MVC   PIEPSW(L8),LCCAPPSW     MOVE EC MODE PSW TO PIEPSW
         LH    WORKREG,LCCAPINT+C2     GET INTERRUPT CODE
         STH   WORKREG,PIEPSW+C2       STORE INTERRUPT CODE
         IC    R10,LCCAPPSW+C2         GET C.C. AND PROC. MASK
         IC    WORKREG,LCCAPINT+C1     GET ILC CODE
         SLL   WORKREG,FIVE            MOVE ILC TO HIGH ORDER BITS
         OR    R10,WORKREG             PUT TOGETHER ILC+CC+ PROG MASK
         STC   R10,PIEPSW+C4           STORE IN PIE PSW
          SPACE 2
*/* P GET PICAEXIT FROM PICA */
          SPACE 2
         L     R15,PICAEXIT            GET ADDRESS OF USER EXIT
         LA    R15,C0(R15)             CLEAR HIGH ORDER BYTE
          SPACE 2
*/* P GET PICAPRMK VALUE FROM PICA */
          SPACE 2
         IC    WORKREG,PICAPRMK        GET PROG MASK IN PICA
          SPACE 2
*/* P SET PIE BUSY BIT PIENOPI = 1 */
          SPACE 2
         OI    PIEPICA,PIENOPI         SET PIE BUSY BIT THIS MUST BE
*                                      DONE LAST IN PIE/PICA PROCESS
*                                      FOR EXTENDED PICA DUE TO POSS-
*                                      IBLE RECURSION
*        THIS COMPLETES SUSEPTABILITY TO PAGE FAULTS, CAN NOW UPDATE
*        REGISTER SAVE AREA
         DROP  XPIEREG
         DROP  XPIPICA
         DROP  SCAREG
         SPKA  ZERO                    RESET PROTECT KEY TO ZERO
          SPACE 2
*/* P CLEAR SUPER SPIE REC BIT */
          SPACE 2
         NI    LCCAIHR1,CXFF-LCCAPPIE  CLEAR PIE RECURSION BIT
         ST    R15,LCCAPGR2+C60        PUT USER EXIT ADDRESS IN SAVE
*                                      AREA
          SPACE 2
*/* P PUT PICAEXIT IN LCCAPGR2 (REG15) AND RIGHT SIDE OF LCCAPPSW */
          SPACE 2
         ST    R15,LCCAPPSW+C4         PUT EXIT ADDRESS IN PSW
          SPACE 2
*/* P PUT PROG MASK OF PICAPRMK IN LCCAPPSW */
          SPACE 2
         STC   WORKREG,LCCAPPSW+C2     PUT PICA MASK INTO PSW
         NI    LCCAPPSW+C2,CX3F        CLEAR HIGH BITS OF PROG MASK BYTE
                                       OF PSW
          SPACE 2
*/* P PUT TCBPKF IN LCCAPPSW FOR SPIE EXIT */
    SPACE 2
* SPIE EXIT RECEIVES CONTROL IN TCB KEY SINCE SPIES ARE    @ZA11376
*       TASK RELATED                                       @ZA11376
    SPACE 2
        MVZ   LCCAPPSW+C1(L1),TCBPKF   PUT TCB KEY IN PSW     @ZA11376
    SPACE 2
*/* P POINT REG 14 TO SVC 3 IN FRONT OF PROG FLIH */
          SPACE 2
*        L     WORKREG,ASVC3           GET RETURN ADDRESS FOR EXIT
         L     WORKREG,@SVC3                                   @ZP60023
         ST    WORKREG,LCCAPGR2+C56    PUT RETURN ADDRESS IN SAVE ADDA
          SPACE 2
*/* P PUT PIE ADDR IN REG 1 OF LCCAPGR2 */
          SPACE 2
         ST    XPIEREG,LCCAPGR2+C4     PUT PIE ADDRESS IN SAVE AREA R1
          SPACE 2
*/* P PUT VIRT ADDR IN REG 0 OF LCCAPGR2 */
          SPACE 2
         L     WORKREG,LCCAPVAD        GET VIRTUAL ADDRESS ADDRESS
         ST    WORKREG,LCCAPGR2        PUT VIRTUAL ADDRESS ADDRESS IN
*                                      REG 0
          SPACE 2
*/* P MOVE LCCAPPSW TO PIOPSW */
          SPACE 2
         MVC   PSAPCPSW(L8),LCCAPPSW   MOVE SAVED PSW TO PI OLD TO
*                                      DO LPSW
         L     WORKREG,TCBTME          GET THE TQE ADDRESS     @ZA32144
         LTR   WORKREG,WORKREG         IS TASK TIMING ACTIVE?  @ZA32144
         BNP   RESTORE                 NOT TASK TIMING CONTINUE@ZA32144
         L     WORKREG1,PSAPCCAV       GET PCCA ADDRESS        @ZA32144
         USING PCCA,WORKREG1           GET PCCA ADDRESSABILITY @ZA32144
         TM    PCCAINTE,PCCANUIN       IS CPU TIME DAMAGED?    @ZA32144
         DROP  WORKREG1                DROP ADDRESSABILITY     @ZA32144
         BO    RESTORE                 CPU TIMER IS DAMAGED.   @ZA32144
         SETLOCK TEST,TYPE=LOCAL,BRANCH=(HELD,LDCPUTSA)        @ZA32144
         USING TQE,WORKREG             GET TQE ADDRESSABILITY  @ZA32144
         SPT   TQEVAL                  SET CPU TIMER FROM TQE  @ZA32144
         B     RESTORE                 CONTINUE TO RELOAD REGS @ZA32144
LDCPUTSA L     WORKREG,PSAAOLD         GET ASCB ADDRESS        @ZA32144
         DROP  WORKREG                 DROP ADDRESSABILITY     @ZA32144
         USING ASCB,WORKREG            GET ASCB ADDRESSABILITY @ZA32144
         L     WORKREG,ASCBASXB        GET ASXB ADDRESS        @ZA32144
         DROP  WORKREG                 DROP ADDRESSABILITY     @ZA32144
         USING ASXB,WORKREG            GET ASXB ADDRESSABILITY @ZA32144
         L     WORKREG,ASXBIHSA        GET IHSA ADDRESS        @ZA32144
         DROP  WORKREG                 DROP ADDRESSABILITY     @ZA32144
         USING IHSA,WORKREG            GET IHSA ADDRESSABILITY @ZA32144
         SPT   IHSACPUT                SET CPU TIMER FROM IHSA @ZA32144
         DROP  WORKREG                 SROP ADDRESSABILITY     @ZA32144
          SPACE 2
*/* P LOAD ALL REGS FROM LCCAPGR2 */
          SPACE 2
RESTORE  DS    0H
         LM    R0,R15,LCCAPGR2         GET ALL REGS
          SPACE 2
*/* P CLEAR PROGRAM FLIH BIT */
          SPACE 2
         NI    PSASUP1,CXFF-PSAPI      CLEAR PROGRAM FLIH BIT
         MVC   PSACSTK(4),PSAPSAV      RESTORE SAVED STACK PTR
          SPACE 2
*/*SUPSPXIT: R EXIT VIA LPSW ON PIOPSW */
          SPACE 2
SUPSPXIT DC    0H'0'                   TEST LABEL
         LPSW  PSAPCPSW                GO DIRECTLY TO USER EXIT
         DROP  CCABASE
         DROP  RBPTR
         TITLE 'IEAVEPC - CPU TIMER ROUTINE'                   @ZA32144
************************************************************** @ZA32144
*                                                              @ZA32144
*    NAME: STCPUT                                              @ZA32144
*                                                              @ZA32144
*    FUNCTION:  SAVE THE CPU TIMER IN THE APPROPRIATE          @ZA32144
*               TQE OR IHSA                                    @ZA32144
*                                                              @ZA32144
*    INPUT:  PSAPCPSW CONTAINS THE SAVED CPU TIMER VALUE       @ZA32144
*            R11 - RETURN ADDRESS                              @ZA32144
*                                                              @ZA32144
*    OUTPUT:  TQE SAVE IN PROPER PLACE                         @ZA32144
*             WORKREG (R14) UNPREDICTABLE                      @ZA32144
*                                                              @ZA32144
************************************************************** @ZA32144
         SPACE 1                                               @ZA32144
*/*STCPUT: D (YES,%STRET,NO,) SRB MODE?                     */ @ZA32144
         SPACE 1                                               @ZA32144
STCPUT   EQU   *                                               @ZA32144
         TM    PSASUP1,PSAIO+PSAEXT+PSADISP
         BNZR  R11                     NOT IN TCB CODE
         L     WORKREG,PSATOLD         OBTAIN TCB ADDRESS      @ZA32144
         LTR   WORKREG,WORKREG         DOES ONE EXIST?         @ZA32144
         BZR   R11                     NO - SRB MODE, RETURN   @ZA32144
         SPACE
*/* D (YES,%STRET,NO,) TRAS MODE?                           */ @ZM49481
         SPACE
         OC    LCCAASID-LCCA(C4,CCABASE),LCCAASID-LCCA(CCABASE) TRAS
*                                      MODE CALLER ?           @ZM49481
         BNZR  R11                     YES, RETURN TO CALLER   @ZM49481
         SPACE 1                                               @ZA32144
*/* D (YES,,NO,%STRET) TQE EXIST?                           */ @ZA32144
         SPACE 1                                               @ZA32144
         L     WORKREG,TCBTME-TCB(WORKREG)  OBTAIN TQE POINTER @ZA32144
         LTR   WORKREG,WORKREG         DOES A TQE EXIST?       @ZA32144
         BNPR  R11                     NO, RETURN TO CALLER    @ZA32144
         USING TQE,WORKREG                                     @ZA32144
         SPACE 1                                               @ZA32144
*/* D (YES,,NO,%STRET) IS CPU TIMER OK?                     */ @ZA32144
         SPACE 1                                               @ZA32144
         OC    PSAPCPSW(C8),PSAPCPSW   WAS A TIMER STORED?     @ZA32144
         BZR   R11                     NO, RETURN TO CALLER    @ZA32144
         SPACE 1                                               @ZA32144
*/* D (YES,STSACPUT,NO,) LOCAL LOCK HELD?                   */ @ZA32144
         SPACE 1                                               @ZA32144
         SETLOCK TEST,TYPE=LOCAL,BRANCH=(HELD,STSACPUT)        @ZA32144
         SPACE 1                                               @ZA32144
*/* P (,%STRET) SAVE TIMER AND SET HIGH TIMER VALUE         */ @ZA32144
         SPACE 1                                               @ZA32144
         MVC   TQEVAL(C8),PSAPCPSW     MOVE TIMER VALUE TO TQE @ZA32144
         DROP  WORKREG                                         @ZA32144
***      SPT   HIVALUE                 SET HIGH TIMER VALUE    @ZA32144
         BR    R11                     RETURN TO CALLER        @ZA32144
         SPACE 1                                               @ZA32144
*/*STSACPUT: P SAVE TIMER IN IHSA AND SET HIGH TIMER VALUE  */ @ZA32144
         SPACE 1                                               @ZA32144
STSACPUT EQU   *                                               @ZA32144
         L     WORKREG,PSAAOLD         GET CURRENT ASCB ADDR   @ZA32144
         L     WORKREG,ASCBASXB-ASCB(WORKREG)  GET ASXB ADDR   @ZA32144
         L     WORKREG,ASXBIHSA-ASXB(WORKREG)  GET IHSA ADDR   @ZA32144
         MVC   IHSACPUT-IHSA(C8,WORKREG),PSAPCPSW  MOVE TIMER  @ZA32144
*                                      VALUE TO IHSA           @ZA32144
***      SPT   HIVALUE                 SET HIGH TIMER VALUE    @ZA32144
         SPACE 1                                               @ZA32144
*/*%STRET: R RETURN TO CALLER                               */ @ZA32144
         SPACE 1                                               @ZA32144
         BR    R11                                             @ZA32144
         TITLE 'IEAVEPC - CONSTANTS AND STORAGE'               @ZA32144
***********************************************************************
*                                                                     *
*                    CONSTANTS & STORAGE                              *
*                                                                     *
***********************************************************************
@SVC3    DC    A(PROGSVC3)             SVC 3 INSTRUCTION ADDR  @ZP60023
         EXTRN IEACVT
ADCVT    DC    A(IEACVT)               ADDRESS OF CVT
         EXTRN TRPI
ATRPI    DC    A(TRPI)                 PI TRACE ENTRY POINT
IEACON1  DC    V(AHLMCIH)              GTF ENTRY POINT
AIEATPER DC    V(IEAVTPER)             SLIP/PER INTERFACE RTN  @G64RPXO
         EXTRN IEA0DS
AIEA0DS  DC    A(IEA0DS)               DISPATCHER MAIN ENTRY POINT
         EXTRN IEAVPIX
AIEAPIX  DC    A(IEAVPIX)              PAGING SUPERVISOR ENTRY POINT
AADDRESS DC    A(ADDRESS)              ADDRESS TO REESTABLISH ADD.
CLEARBIT DS    0F
         DC    X'000000F0'             MASK USED TO TURN OFF BITS
DISAWAIT DS    0D                      WAIT STATE PSW WITH WAIT STATE
         DC    XL8'000E000000000014'   CODE OF 14
DFLCR0   DC    X'C080EC40'             DEFAULT CR 0 FOR TRANSLATION
         EXTRN IGFPTERM
SYSTERM  DC    V(IGFPTERM)             ADDR SYSTEM TERM RTN
LCCAEBC  DC    CL4'LCCA'               EBCDIC FOR LCCA         @YM08516
MSG999W  WTO   'IEA999W ADDRESS TRANSLATION ERROR IN MASTER MEMORY  ', *
               ROUTCDE=(2),DESC=(1),MF=L
          SPACE 2
***********************************************************************
*                                                                     *
*                     SECONDARY ASID PAGE FAULT HANDLER     @ZP60023  *
*                                                                     *
***********************************************************************
          SPACE
         USING LCCA,CCABASE            ESTABLISH BASE TO LCCA
INFLIGHT DC    0H'0'                   CREATE AN IN-FLIGHT SRB
*
*            UPDATE JOB STEP (TCB) CPU TIME ACCUMULATOR
*
         L     ASCBREG,PSAAOLD         GET ASCB ADDRESS
         USING ASCB,ASCBREG
         LM    R0,R1,PSAPCPSW          LOAD INTERRUPT TIME
         SL    R0,LCCADTOD             GET TIME SINCE TASK DISPATCH
         SL    R1,LCCADTOD+C4
         BC    M11,INFLT01             HANDLE CARRY
         BCTR  R0,C0
INFLT01  LM    R14,R15,ASCBEJST        GET TCB TIME SO FAR
         ALR   R14,R0                  GET NEW TCB TIME TOTAL
         SLR   R15,R1
         BC    M12,INFLT02             HANDLE CARRY
         LA    R14,C1(,R14)
INFLT02  STM   R14,R15,ASCBEJST        SAVE NEW TCB TIME TOTAL
*
*            UPDATE RB, TCB AND ASCB TO SUSPEND TASK
*
         LA    R13,PSALKSA             POINT TO SAVE AREA
         LA    R10,IEAVSUSP-3072       HANDLE ADDRESS RANGE
         BAL   RETREG,3072(,R10)       SUSPEND THE TASK BY RB WAIT
         L     XTCBREG,PSATOLD         GET PURGE TCB ADDRESS
         USING TCB,XTCBREG
         L     R1,TCBXSCT              GET TCB INTERSECT WORD
INFLT03  LR    R0,R1                   COPY VALUE FOR SWAP OP INIT
         N     R0,ACTCPVOF             CLEAR ACTIV/CCPVI IN SWAP OP
         CS    R1,R0,TCBXSCT           CLEAR ACTIV/CCPVI IN TCB
         BNE   INFLT03                 IF UNEQUAL TRY AGAIN
         L     R1,ASCBCPUS             GET ACTIVE TCB COUNT
INFLT04  LR    R0,R1                   COPY IT
         BCTR  R0,C0                   DECREMENT FOR NEW VALUE
         CS    R1,R0,ASCBCPUS          REPLACE OLD WITH NEW
         BNE   INFLT04                 IF UNEQUAL TRY AGAIN
*
*            SAVE FLOATING POINT REGISTERS
*
         L     R2,PCPREFIX             PREFIX VALUE
         AR    R2,XTCBREG              TCB PREFIX ADDRESSING
         USING TCBFIX,R2
         STD   R0,TCBFRS0              *  SAVE
         STD   R2,TCBFRS2              *    FLOATING
         STD   R4,TCBFRS4              *      POINT
         STD   R6,TCBFRS6              *        REGISTERS
         DROP  R2                      TCBFIX
*
*            AFFILIATE SRB WITH INTERRUPTED TCB
*
         LH    R0,ASCBASID             GET PURGE ASID
         STH   R0,LCCAPGTA             SET PURGE ASID
         ST    XTCBREG,LCCAPGTA+2      SET PURGE TCB ADDRESS
*
*            SWITCH INTO SRB MODE
*
         LH    R2,TCBRV326             GET SECONDARY ASID
         DROP  XTCBREG                 TCB
         SR    R0,R0                   GET ZERO
         ST    R0,PSATOLD              CLEAR TCB POINTERS
         ST    R0,PSATNEW
         OI    LCCADSF2,LCCASRBM       SET SRB MODE FLAG
         NI    PSASUP1,CXFF-PSAPI      CLEAR PC FLIH FLAG
*
*            CLEAR CROSS MEMORY ENVIRONMENT
*
         LCTL  CR3,CR3,PSATOLD         CLEAR SECONDARY ASN
         LCTL  CR7,CR7,PSATOLD         CLEAR SECONDARY STO
         LCTL  CR4,CR4,PSATOLD         CLEAR PRIMARY ASN
         STCTL CR0,CR0,LCCACR0         GET CURRENT CR0
         NI    LCCACR0,CXFF-CX0C       DEACTIVATE DAS
         LCTL  CR0,CR0,LCCACR0         UPDATE CR0
*
*            OBTAIN GLOBAL DISPATCHER LOCK TO SERIALIZE ASCBSRBS
*
         L     R13,SPECDISP            USE SPECIAL LOCK MANAGER E.P.
         BALR  RETREG,R13               - FOR DISPATCHER'S USE ONLY
*
*            SET SRB START TIME FROM INTERRUPT TIME
*
         LM    R0,R1,PSAPCPSW          LOAD INTERRUPT TIME
         STM   R0,R1,LCCADTOD          SET INTO DISPATCH TIME
*
*            SWITCH TO ASID CONTAINING PAGED-OUT PAGE
*
         LA    R15,C2                  CHECKING "SECONDARY" ASID
         BAL   RETREG,DASSWTCH         CHANGE ACTIVE MEMORY
         LH    R1,ASCBSRBS
         LA    R1,C1(,R1)              INCREMENT A.S. SRB COUNT
         STH   R1,ASCBSRBS
*
*            RELEASE GLOBAL DISPATCHER LOCK
*
         L     R1,DISPLKAD             OBTAIN DISP LOCK ADDR
         SLR   R0,R0                   ZERO A REGISTER
         ST    R0,C0(R1)               FREE LOCK VIA STORE ZEROS
         NI    PSAHLHI+C2,CXEF         FLAG DISPATCHER LOCK NOT HELD
*
*            BECOME ENABLED - NECESSARY TO TAKE PAGE FAULT
*
         L     R1,LCCAPVAD             GET THE INTERRUPT ADDRESS
         STOSM LCCAPSMK,CX03           ENABLE INTERRUPTS
*
*            TOUCH THE PAGED-OUT PAGE
*
         CLI   0(R1),C0                REFERENCE THE PAGE
*
*            BECOME DISABLED - WHILE SWITCHING MEMORY
*
         STNSM LCCAPSMK,CXFF-CX03      DISABLE INTERRUPTS
*
*            OBTAIN GLOBAL DISPATCHER LOCK TO SERIALIZE ASCBSRBS
*
         L     R13,SPECDISP            USE SPECIAL LOCK MANAGER E.P.
         BALR  RETREG,R13               - FOR DISPATCHER'S USE ONLY
*
*            SWITCH TO BACK TO INTERRUPT ADDRESS SPACE
*
         LH    R1,ASCBSRBS
         BCTR  R1,C0                   DECREMENT A.S. SRB COUNT
         STH   R1,ASCBSRBS
         LA    R15,C1                  CHECKING "PRIMARY" ASID
         LH    R2,LCCAPGTA             GET THE ORIGINAL ASID
         BAL   RETREG,DASSWTCH         CHANGE ACTIVE MEMORY
         LH    R1,ASCBSRBS
         LA    R1,C1(,R1)              INCREMENT A.S. SRB COUNT
         STH   R1,ASCBSRBS
*
*            RELEASE GLOBAL DISPATCHER LOCK
*
         L     R1,DISPLKAD             OBTAIN DISP LOCK ADDR
         SLR   R0,R0                   ZERO A REGISTER
         ST    R0,C0(R1)               FREE LOCK VIA STORE ZEROS
         NI    PSAHLHI+C2,CXEF         FLAG DISPATCHER LOCK NOT HELD
*
*            UNSUSPEND INTERRUPTED TASK
*
         L     XTCBREG,LCCAPGTA+2      POINT TO INTERRUPTED TCB
         USING TCB,XTCBREG
         L     RBPTR,TCBRBP            GET RB ADDRESS
         USING RBSECT,RBPTR
         SR    R1,R1
         IC    R1,RBWCF                GET WAIT COUNT
         BCTR  R1,C0                   DECREMENT COUNT
         STC   R1,RBWCF                PUT WAIT COUNT BACK
         LTR   R1,R1                   RB STILL WAITING?
         BNZ   INFLT06                 YES, DON'T KNOW HOW
          SPACE
         DROP  RBPTR                   RBSECT
         DROP  XTCBREG                 TCB
          SPACE
         L     R1,ASCBTCBS             LOAD VALUE OF READY TCBS
INFLT05  LA    R0,C1
         AR    R0,R1                   INCREMENT COUNT
         CS    R1,R0,ASCBTCBS          REPLACE OLD WITH NEW
         BNE   INFLT05                 IF UNEQUAL TRY AGAIN
*
*            BECOME ENABLED - AS EXPECTED BY THE DISPATCHER
*
INFLT06  STOSM LCCAPSMK,CX03           ENABLE INTERRUPTS
*
*            TERMINATE SRB - EXIT TO DISPATCHER
*
         L     RETREG,SRBRETRN         POINT TO SRB RETURN POINT
         BR    RETREG                  END OF SRB PROCESSING
*
*            CONSTANTS USED BY PCFLIH DISPATCHER FUNCTIONS
*
SPECDISP DC    V(GSLSDISP)             DISP ENTRY FOR DISP LOCK OBTAIN
DISPLKAD DC    V(DISPLOCK)             DISP LOCKWORD ADDRESS
SRBRETRN DC    V(IEAPDSRT)             SRB RETURN POINT
ACTCPVOF DC    AL1(255-(TCBACTIV)),X'FF0000' TCBACTIV/TCBCCPVI MASK OFF
PCPREFIX DC    A(-(TCB-TCBFRS))        TCB PREFIX OFFSET VALUE
*
*            SUBROUTINE TO PERFORM MEMORY SWITCH
*
DASSWTCH LTR   R2,R2                   TEST ASN
         BNP   DASABEND                ABEND IF INVALID
         L     R4,FLCCVT
         L     R4,CVTASVT-CVT(,R4)     GET ASVT ADDRESS
         USING ASVT,R4
         C     R2,ASVTMAXU             TOO BIG FOR THIS IPL?
         BH    DASABEND                YES, ABEND IF INVALID
         SLA   R2,C2                   NO, GET ASN TIMES FOUR
         L     ASCBREG,ASVTENTY-4(R2)  GET ASCB ADDRESS
         DROP  R4                      ASVT
         LTR   ASCBREG,ASCBREG         ASID ASSIGNED?
         BNP   DASABEND                NO, ABEND
         TM    ASCBRCTF,ASCBOUT        ASID SWAPPED OUT?
         BO    DASABEND                YES, ABEND
         ST    ASCBREG,PSAANEW         SET ASCB POINTERS
         ST    ASCBREG,PSAAOLD
         LCTL  CR1,CR1,ASCBSTOR        SWITCH MEMORY
         BR    RETREG                  RETURN TO CALLER
          SPACE
         DROP  ASCBREG                 ASCB
         DROP  CCABASE                 LCCA
*
*            ABEND DUE TO BAD ASN - EXIT TO DISPATCHER
*
DASABEND LA    PARMREG,ASNABEND        PUT PIX ABEND CODE IN REG 1
         ABEND (1),DUMP,,SYSTEM        ABEND THE SRB AND TASK
          SPACE
***********************************************************************
*            END OF:  SECONDARY ASID PAGE FAULT HANDLER     @ZP60023  *
***********************************************************************
          SPACE 2
***********************************************************************
*                                                                     *
*                     SSAR PROCESSING                       @ZP60023  *
*                                                                     *
***********************************************************************
          SPACE
         USING LCCA,CCABASE            (R7)
CHK4SSAR LH    R10,LCCAPINT            GET INSTRUCTION LENGTH
         L     R2,LCCAPPSW+C4          GET ADDRESS FROM FLCPOPSW
         SR    R2,R10                  POINT TO NEW OPCODE
         CLI   0(R2),X'B2'
         BNE   SKIPSSAR                GO BACK IF NOT SSAR
         CLI   1(R2),X'25'
         BNE   SKIPSSAR                GO BACK IF NOT SSAR
         SR    R10,R10
         IC    R10,3(,R2)              GET REGISTER NUMBER TIMES 16
         SRL   R10,C4                  SHIFT OUT POSSIBLY DIRTY BITS
         SLL   R10,C2                  GET REGISTER LOOK-UP INDEX
         LA    R4,LCCAPGR2(R10)        POINT TO REGISTER VALUE
         ICM   R10,3,2(R4)             LOAD ASN
         BZ    ZEROSSAR                ACCEPT ZERO FOR RESET
         L     R4,FLCCVT
         L     R4,CVTASVT-CVT(,R4)     GET ASVT ADDRESS
         USING ASVT,R4
         C     R10,ASVTMAXU            TOO BIG FOR THIS IPL?
         BH    SKIPSSAR                YES, PRETEND NOT TO KNOW
         SLA   R10,C2                  NO, GET ASN TIMES FOUR
         L     R10,ASVTENTY-4(R10)     GET ASCB ADDRESS
         DROP  R4                      (ASVT)
         LTR   R10,R10                 ASID ASSIGNED?
         BNP   SKIPSSAR                NO, USER ERROR SO GIVE UP
         C     R10,PSAAOLD             REQUESTING SASN=PASN?
         BE    SCNDRYOK                YES, ALWAYS ALLOWED
         TM    LCCAPPSW+C1,CX01        IN SUPERVISOR STATE?
         BNZ   SKIPSSAR                NO, CONTINUE
         USING ASCB,R10
         TM    ASCBRCTF,ASCBOUT        SECONDARY ASID SWAPPED OUT?
         BO    SKIPSSAR                YES, USER ERROR SO GIVE UP
SCNDRYOK SR    R15,R15
         IC    R15,LCCAPPSW+C1         GET PSW KEY
         L     XTCBREG,PSATOLD         POINT TO THE CURRENT TCB
         LTR   XTCBREG,XTCBREG         RUNNING UNDER A TCB?
         BZ    SECTSKOK                NO, NONE TO UPDATE
         USING TCB,XTCBREG             (R4)
         MVC   TCBRV326(C2),ASCBASID   YES, SET TASK'S SECONDARY ASN
         IC    R15,TCBPKF              GET TASK'S KEY
SECTSKOK SRL   R15,C4                  GET KEY IN LOW NIBBLE
         LA    R2,CX80
         SLL   R2,C24                  SET SIGN BIT ONLY
         SRL   R2,0(R15)               SET BIT FOR KEY
         ICM   R2,3,ASCBASID           INSERT SECONDARY ASN
         ST    R2,LCCACR0
         LCTL  CR3,CR3,LCCACR0         SET KEY MASK AND SECONDARY ASN
         LCTL  CR7,CR7,ASCBSTOR        SET SECONDARY STO
         L     R10,PSAAOLD             POINT TO THE CURRENT ASCB
         LH    R2,ASCBASID             GET PRIMARY ASN
         ST    R2,LCCACR0
         LCTL  CR4,CR4,LCCACR0         SET PRIMARY ASN
         STCTL CR0,CR0,LCCACR0         GET CURRENT CR0
         OI    LCCACR0,CX0C            ACTIVATE DAS
         LCTL  CR0,CR0,LCCACR0         UPDATE CR0
         B     CPUTIME                 SSAR ALL DONE
         DROP  R10                     (ASCB)
          SPACE 2
ZEROSSAR ST    R10,LCCACR0             GET A ZERO FULLWORD
         LCTL  CR3,CR3,LCCACR0         CLEAR SECONDARY ASN
         LCTL  CR7,CR7,LCCACR0         CLEAR SECONDARY STO
         LCTL  CR4,CR4,LCCACR0         CLEAR PRIMARY ASN
         STCTL CR0,CR0,LCCACR0         GET CURRENT CR0
         NI    LCCACR0,CXFF-CX0C       DEACTIVATE DAS
         LCTL  CR0,CR0,LCCACR0         UPDATE CR0
         L     XTCBREG,PSATOLD         POINT TO THE CURRENT TCB
         LTR   XTCBREG,XTCBREG         RUNNING UNDER A TCB?
         BZ    CPUTIME                 NO, SSAR ALL DONE
         STH   R10,TCBRV326            CLEAR TASK'S SECONDARY ASN
         B     CPUTIME                 SSAR ALL DONE
         DROP  XTCBREG                 (TCB)
         DROP  CCABASE                 (LCCA)
          SPACE
***********************************************************************
*            END OF:  SSAR PROCESSING                       @ZP60023  *
***********************************************************************
          TITLE 'IEAVEPC- SRB ROUTINE (IEAVPSRB)'
*/*IEAVPSRB: E IEAVPSRB */
          SPACE 2
         ENTRY IEAVPSRB
IEAVPSRB DS    0H
          SPACE 2
*/* P ESTABLISH ADDRESSABILITY */
          SPACE 2
         BALR  BASEREG,C0              ESTABLISH
         USING *,BASEREG               ADDRESSABILITY
         LR   TEMPREG,RETREG           SAVE RETURN REGISTER    @YM30620
          SPACE 2
*/*OBTAINLL: L SETLOCK-- OBTAIN LOCAL UNCOND */
          SPACE 2
OBTAINLL SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,RELATED=('LOCK IS OBTAIN*
               ED TO PREVENT IRB TO BE QUEUED FOR TCBS IN THIS ASCB',IE*
               AVEPC(EXIT1))           GET LOCAL LOCK
          SPACE 2
*/* L SETFRR--  SET UP RECOVERY */
          SPACE 2
         SETFRR A,FRRAD=ASRBERR,PARMAD=(2),WRKREGS=(3,4) SETUP RECOVERY
          SPACE 2
*/* D (NO,EXIT1,YES,) IS TCB NON-DISP? */
          SPACE 2
         LR    XSRBREG,R0              GET SRB ADDRESS
         USING SRBSECT,XSRBREG
         L     XTCBREG,SRBPTCB         GET TCB ADDRESS
         ST    XTCBREG,C0(,R2)         PASS TCB ADDRESS TO FRR @ZA06785
         USING TCB,XTCBREG
         TM    TCBNDSP1,TCBPIEND       IS TCB STILL NON-DISP
         BNO   EXIT1                   IF NOT EXIT
          SPACE 2
*/* P GET PIE ADDR AND PICA ADDR */
          SPACE 2
         L     SCAREG2,TCBPIE          GET ADDRESS OF PIE ADDRESS
         USING SCA,SCAREG2
         L     XPIEREG2,SCAPIE         GET PIE ADDRESS
         SPACE 2                                               @ZA31350
*/* P SET PROTECT KEY = TCB'S KEY  */
         SPACE 2                                               @ZA31350
         IC    WORKREG,TCBPKF          GET TCB PROTECT KEY     @ZA31350
         SPKA  0(WORKREG)              SET PROTECT KEY TO USER @ZA31350
         SPACE 2                                               @ZA31350
         USING PIE,XPIEREG2
         L     XPICAREG,PIEPICA        GET PICA ADDRESS FROM PIE
         SPACE 2                                               @ZA31350
*/* P SET PROTECT KEY = 0  */
         SPACE 2                                               @ZA31350
         SPKA  ZERO                    SET PROTECT KEY TO 0    @ZA31350
          SPACE 2
*/* D (YES,TERMINAT,NO,) IS PIE BUSY OR PICA=0? */
          SPACE 2
         LTR   XPICAREG,XPICAREG       IS PIE BUSY OR PICA ADDRESS = 0
         BNP   TERMINAT                IF EITHER ABTERM TCB
         SPACE 2                                               @ZA31350
*/* P SET PROTECT KEY = TCB'S KEY  */
         SPACE 2                                               @ZA31350
         SPKA  0(WORKREG)              SET PROTECT KEY TO USER @ZA31350
         SPACE 2                                               @ZA31350
*/* P GET INTERRUPT MASK FROM PICA  */
         SPACE 2                                               @ZA31350
         USING PICA,XPICAREG
         L     R0,PICAITMK             GET INTRPT MASK FROM PICA
         SPACE 2                                               @ZA31350
*/* P SET PROTECT KEY = 0  */
         SPACE 2                                               @ZA31350
         SPKA  ZERO                    RESET PROTECT KEY TO 0  @ZA31350
          SPACE 2
*/* D (NO,TERMINAT,YES,) CAN INTERRUPT BE HANDLED? */
          SPACE 2
         LH    WORKREG1,SCAPARMS+C6    GET INTRPT CODE FROM SRB
         SLL   R0,C0(WORKREG1)         SHIFT TO ALIGN INTRPT MASK BIT
*                                      FOR THIS INTERRUPT IN HIGHER
*                                      ORDER BIT
         LTR   R0,R0                   CAN INTERRUPT BE HANDLED
         BNM   TERMINAT                IF NOT ABTERM TCB
          SPACE 2
*/* D (YES,REGSFND,NO,) IS THIS THE TOP RB? */
          SPACE 2
         L     WORKREG1,TCBRBP         GET ADDRESS OF TOP RB
         LA    WORKREG3,TCBGRS         GET ADDRESS OF REG.SAVE AREA
         C     WORKREG1,SCAPARMS       IS TOP RB THE ONE BEING SER-
*                                      VICED
         BE    REGSFND                 IF SO CONTINUE PROCESS
          SPACE 2
*/* P CHAIN DOWN RB UNTIL RB BEING SERVICED IS FOUND */
          SPACE 2
         USING RBSECT,WORKREG1
NEXTRB   LA    WORKREG3,RBGRSAVE       GET ADDRESS OF REG SAVE AREA
         L     WORKREG1,RBLINK         GET NEXT RB ADDRESS
         C     WORKREG1,SCAPARMS       IS NEXT RB THE ONE BEING SER-
*                                      VICED
         BNE   NEXTRB                  IF NO TRY AGAIN
          SPACE 2
*/*REGSFND: P SET PROTECT KEY = TCB'S KEY */
          SPACE 2
REGSFND  EQU   *                                               @ZA31350
         SPKA  0(WORKREG)              SET PROTECT KEY TO USERS
          SPACE 2
*/* P MOVE REGS 0,1,2,14 & 15 TO PIE */
          SPACE 2
         MVC   PIEGR14(L8),C56(WORKREG3) MOVE REGS 14 AND 15 TO PIE
         MVC   PIEGR0(L12),C0(WORKREG3) MOVE REGS 0-2 TO PIE
          SPACE 2
*/* P CONSTRUCT PSW IN PIE */
          SPACE 2
         MVC   PIEPSW(L8),SCAPARMS+C8  MOVE PSW AT INTERRUPT TO PIEPSW
         LH    WORKREG4,SCAPARMS+C6    GET INTERRUPT CODE
         STH   WORKREG4,PIEPSW+C2      STORE INTERRUPT CODE
         IC    WORKREG4,RBOPSW+C2      GET C.C. AND PROR MASK
         IC    WORKREG,SCAPARMS+C5     GET ILC CODE
         SLL   WORKREG,FIVE            MOVE ILC TO HIGH ORDER BITS
         OR    WORKREG4,WORKREG        PUT TOGETHER ILC+CC+PROG MASK
         STC   WORKREG4,PIEPSW+C4      STORE IN PIE PSW
          SPACE 2
*/* P SET PIE BUSY BIT */
          SPACE 2
         OI    PIEPICA,PIENOPI         SET PIE BUSY BIT
         SPACE 2
*/* P GET ADDRESS OF USER EXIT FROM PICA  */
         SPACE 2
         L     WORKREG4,PICAEXIT       GET ADDRESS OF USER EXIT
          SPACE 2
*/* P SET PROTECT KEY = 0 */
          SPACE 2
         SPKA  ZERO                    RESET PROTECT KEY TO ZERO
          SPACE 2
*/* P STORE USER EXIT ADDR AND RETURN ADDR IN SAVE AREA */
          SPACE 2
         LA    WORKREG4,C0(WORKREG4)   CLEAR HIGH ORDER BYTE
         ST    WORKREG4,C60(WORKREG3)  PUT USER EXIT ADDRESS IN SAVE
*                                      AREA
         ST    WORKREG4,RBOPSW+C4      PUT EXIT ADDRESS IN PSW
         SPACE 2
*/* P PUT TCBPKF IN RBOPSW FOR SPIE EXIT ROUTINE */
         SPACE 2
* SPIE EXIT RECEIVES CONTROL IN TCBKEY SINCE SPIES ARE TASK @ZA11376
*        RELATED                                            @ZA11376
         SPACE 2
         MVZ   RBOPSW+C1(L1),TCBPKF    PUT KEY IN RB FOR SPIE @ZA11376
         L     WORKREG4,ASVC3          GET RETURN ADDRESS FOR EXIT
         ST    WORKREG4,C56(WORKREG3)  PUT RETURN ADDRESS IN SAVE AREA
         SPACE 2
*/* P SET PROTECT KEY = TCB'S KEY  */
         SPACE 2
         IC    WORKREG4,TCBPKF         GET TCB PROTECT KEY     @ZA31350
         SPKA  0(WORKREG4)             SET PROTECT KEY TO USER @ZA31350
         SPACE 2
*/* P GET PROGRAM MASK FROM PICA  */
         SPACE 2
         IC    WORKREG4,PICAPRMK       GET PICA PROGRAM MASK   @ZA31350
         SPACE 2
*/* P SET PROTECT KEY = 0  */
         SPACE 2
         SPKA  ZERO                    RESET PROTECT KEY TO 0  @ZA31350
         SPACE 2
*/* P PUT PROGRAM MASK IN RBOPSW FOR SPIE EXIT ROUTINE  */
         SPACE 2
         STC   WORKREG4,RBOPSW+C2      STORE PROG MASK IN RB   @ZA31350
         NI    RBOPSW+C2,CX3F          CLEAR PROG MASK
          SPACE 2
*/* P (,EXIT2) SAVE PIE ADDRESS */
          SPACE 2
         ST    XPIEREG2,C4(WORKREG3)   PUT PIE ADDRESS IN SAVE AREA R1
         B     EXIT2                   BRANCH TO EXIT
          SPACE 2
*/*TERMINAT: P SET UP COMPLETION CODE */
          SPACE 2
TERMINAT LH    WORKREG1,C6(PARMREG)    GET COMPLETION CODE
         LA    WORKREG1,CXC0(WORKREG1) PUT 'C' IN FRONT OF COMP CODE
          SPACE 2
*/* L (,EXIT1) CALL RTM-- ABTERM */
          SPACE 2
         CALLRTM TYPE=ABTERM,COMPCOD=(WORKREG1),TCB=(XTCBREG)
         B     EXIT1                   BRANCH TO EXIT
          SPACE 2
*/*EXIT2:  P SET TCB  DISPATCHABLE */
          SPACE 2
EXIT2    LA    R0,ELEVEN               INDICATE SECONDARY NON-DISP
         LR    R1,XTCBREG              GET TCB ADDRESS FOR STATUS
         O     R1,HIGHON               SET HIGH ORDER BIT ON-RESET
         L     CVTREG,FLCCVT           GET CVT ADDRESS
         USING CVT,CVTREG
         L     CVTREG,CVTABEND         GET SECONDARY CVT ADDRESS
         USING SCVTSECT,CVTREG
         L     EPREG,SCVTSTAT          GET ENTRY POINT ADD. OF STATUS
         LA    R13,TCBPIEND            PUT NON-DISP BIT IN REG
         SLL   R13,C16                 MOVE BIT INTO RIGHT POSITION
         BALR  RETREG,EPREG
         SPACE 2
*/*EXIT1: L SETFRR-- REMOVE RECOVERY */
         SPACE 2
EXIT1    SETFRR D,WRKREGS=(3,4)        CLEAR FRR ELEMENT
         DROP  XSRBREG
         DROP  WORKREG1
          SPACE 2
*/* L SETLOCK-- RELEASE LOCAL */
          SPACE 2
         SETLOCK RELEASE,TYPE=LOCAL,RELATED=('PROCESS ON RB CHAIN IS CO*
               MPLETE',IEAVEPC(OBTAINLL)) CLEAR LOCAL LOCK
          SPACE 2
*/* R EXIT */
          SPACE 2
         BR    TEMPREG                 EXIT
***********************************************************************
*                                                                     *
*                     CONSTANTS & STORAGE                             *
*                                                                     *
***********************************************************************
ASVC3    DC    A(PROGSVC3)             SVC 3 INSTRUCTION ADDRESS
HIGHON   DC    X'80000000'             HIGH BIT ON IN WORD
ASRBERR  DC    A(SRBERR)          ADDRESS OF SRB ERROR FRR
         TITLE 'IEAVEPC- SRB ERROR FRR'
         SPACE 2
*/*SRBERR: E ENTRY SRB FRR */
*/* P GET CURRENT TCB ADDRESS (R4=TCB@) */
*/* S IEAVSPER: PROCESS SPIE ERROR */
*/* L SETRP-- CHANGE COMP CODE RELEASE LOCAL LOCK */
*/* P NOTE: CONTINUE WITH ABEND AND PERCOLATE TO NEXT LEVEL OF RECOVERY
*/* */
*/* R RETURN */
         SPACE 2
SRBERR   DC    0H'0'
*                                 **********SRB ERROR FRR**********
*                                 GO PROCESS PIE/PICA ERROR @ZA06785
*                                      CHANGE COMPLETION CODE
*                                      RELEASE LOCAL LOCK
*                                      CONTINUE WITH ABEND
*                                      PERCOLATE TO NEXT RECOVERY LEVEL
         USING *,R15                   ESTABLISH BASE         @ZA06785
         USING SDWA,R1                 ESTABLISH SDWA         @ZA06785
         LR    R5,R14                  SAVE RETURN ADDRESS
         L     R4,SDWAPARM             GET PARMLIST ADDRESS @ZA06785
         L     R4,C0(,R4)              GET CURRENT TCB ADDRESS @ZA06785
         LA    R9,IEAVSPER             GET SPIE ERR RTN ADDR @ZA06785
         BALR  R11,R9                  GO TO SPIE ERR RTN  @ZA06785
         SETRP DUMP=YES,RC=0,COMPCOD=(SRBERRCC,SYSTEM),FRELOCK=(LOCAL)
         LR    R14,R5                  RESTORE RETURN ADDRESS
         BR    R14                     RETURN TO CALLER
         EJECT
*/*IEAVSPER: E ENTRY SPIE ERROR RTN */
*/* D (NO,PIEBAD,YES,) SCA ADDRESS ERROR */
*/* P PUT BAD SCA IN SDWA */
*/*RECORD: L SETRP  RECORD ERROR */
*/* R RETURN TO CALLER */
*/*PIEBAD: P (,RECORD) PUT BAD PIE IN SDWA */
          SPACE 2
*        IEAVSPER IS GIVEN CONTROL WHENEVER PROGRAM FLIH OR @ZA06785
*        PROGRAM MANAGER DETECTS AN INVALID PIE OR PICA. THIS @ZA06785
*        ROUTINE WILL RECORD THE CONTENTS OF THE SCAPIE FIELD @ZA06785
*        IN THE FIRST TWELVE BYTES OF VARIABLE RECORDING AREA @ZA06785
*        IN THE SDWA AFTER A LABEL "SCAPIE= ". IF THE TCBPIE  @ZA06785
*        FIELD IS FOUND TO BE INVALID IT WILL BE RECORDED     @ZA06785
*        FOLLOWING THE LABEL "TCBPIE= "                       @ZA06785
*
*       INPUT: R1= ADDRESS OF SDWA                           @ZA06785
*              R4= ADDRESS OF TCB                            @ZA06785
*              R9= ENTRY POINT ADDRESS                       @ZA06785
*              R11= RETURN ADDRESS                           @ZA06785
*
*        REGISTERS DESTROYED: 2,3,8,12                       @ZA06785
         SPACE 2
IEAVSPER DS  0H                                              @ZA06785
         ENTRY IEAVSPER                                      @ZA06785
         USING *,R9                   ESTABLISH BASE         @ZA06785
         USING SDWA,R1                ADDRESSABILITY TO SDWA @ZA06785
         USING SCA,R3                 ADDRESSABILITY TO SCA  @ZA06785
         SR    R2,R2                  CLEAR WORK REGISTER    @ZA06785
         SR    R8,R8                  DITTO                  @ZA06785
         IC    R8,SDWAURAL            GET LENGTH OF USED VRA @ZA06785
         LA    R12,C12(R8)            ADD LENGTH OF NEW RECORD @ZA06785
         STC   R12,SDWAURAL           UPDATE FIELD IN SDWA    @ZA06785
         OI    SDWADPVA,SDWAHEX       INDICATE DUMP IN HEX    @ZA06785
         LA    R12,SDWAVRA(R8) GET ADDRESS OF NEXT RECORD    @ZA06785
CHKSCA   LRA   R3,TCBPIE-TCB(R4)  Q.SCA ADDRESS TRANS ERROR  @ZA06785
         BZ    PIEBAD             A. NO ERRORS               @ZA06785
         MVC   ZERO(L8,R12),VRAHDR1   PUT HEADER IN VRA      @ZA06785
         MVC   C8(L4,R12),TCBPIE-TCB(R4) PUT BAD SCA IN VRA  @ZA06785
         ST    R2,TCBPIE-TCB(R4)      ZERO SCA POINTER       @ZA06785
RECORD SETRP RECORD=YES,COMPCOD=(SPIERR,SYSTEM) RECORD ERROR @ZA06785
         BR    R11                    RETURN TO CALLER        @ZA06785
PIEBAD   EQU   *                                              @ZA06785
         L     R3,TCBPIE-TCB(R4)      GET SCA ADDRESS         @ZA06785
         MVC   ZERO(L8,R12),VRAHDR2   PUT HEADER IN VRA       @ZA06785
         MVC   C8(L4,R12),SCAPIE      PUT PIE ADDRESS IN VRA  @ZA06785
         ST    R2,SCAPIE              CUT PIE CHAIN           @ZA06785
         B     RECORD                 GO RECORD ERROR         @ZA06785
       EJECT
********************************************************************
*                                                                  *
*                      CONSTANTS AND STORAGE            @ZA06785   *
*                                                                  *
********************************************************************
       SPACE 2
VRAHDR1 DC    CL8'TCBPIE= '    BAD SCA HEADER             @ZA06785
VRAHDR2 DC    CL8'SCAPIE= '    BAD PIE HEADER             @ZA06785
SPIERR  EQU   X'6FC'           SPIE ERROR CODE            @ZA06785
        EJECT
         TITLE 'IEAVEPC- SUSPEND ROUTINE (IEAVSUSP)'
         ENTRY IEAVSUSP
          SPACE 2
*/*IEAVSUSP: E IEAVSUSP */
          SPACE 2
IEAVSUSP DS    0H
          SPACE 2
*/* P SAVE REGS IN SPECIAL GLOBAL LOCK AREA FOR SUSPEND/RESET */
          SPACE 2
         STM   R0,R15,C0(R13)          SAVE ALL REGISTERS
          SPACE 2
*/* P ESTABLISH ADDRESSABILITY */
          SPACE 2
         BALR  BASEREG,C0              ESTABLISH
         USING *,BASEREG               ADDRESSABILITY
          SPACE 2
*/* P GET LCCA ADDRESS */
          SPACE 2
         L     CCABASE,PSALCCAV        GET LCCA ADDRESS
         USING LCCA,CCABASE
          SPACE 2
*/* P GET ASCB ADDR FROM PSAOLD */
          SPACE 2
         L     ASCBBASE,PSAAOLD        GET CURRENT ASCB ADDRESS
         USING ASCB,ASCBBASE
          SPACE 2
*/* D (YES,SRBPRSS,NO,) SRB MODE? */
          SPACE 2
         TM    LCCADSF2,LCCASRBM       IS SRB MODE INDICATED
         BO    SRBPRSS                 IF SO GO PROCESS
          SPACE 2
*/* P GET TCB ADDR FROM PSATOLD */
          SPACE 2
         L     XTCBREG,PSATOLD         GET CURRENT TCB ADDRESS
         USING TCB,XTCBREG
          SPACE 2
*/* P GET RB ADDR FROM TCBRBP */
          SPACE 2
         L     RBPTR,TCBRBP            GET RB ADDRESS
          SPACE 2
*/* P GET PAGE FAULT ADDR FROM LCCAPVAD AND STORE IN RB */
          SPACE 2
         LA    WORKREG3,RBSECT-RBRTRAN GET OFFSET IN PREFIX
         SR    RBPTR,WORKREG3          GET TO RBRTRAN LABEL
         L     WORKREG1,LCCAPVAD       GET PAGE FAULT ADDRESS
         ST    WORKREG1,C0(RBPTR)      PUT ADDRESS IN RBRTRAN
         AR    RBPTR,WORKREG3          GET ADDRESS OF RB BACK
         USING RBSECT,RBPTR
          SPACE 2
*/* L (NO,NOLOCAL,YES,) SETLOCK-- IS LOCAL LOCK HELD? */
          SPACE 2
         SETLOCK TEST,TYPE=LOCAL,BRANCH=(NOTHELD,NOLOCAL)
*                                      IS LOCAL LOCK HELD?
          SPACE 2
*/* P GET ASXB ADDRESS FROM ASCBASXB */
          SPACE 2
         L     ASXBREG,ASCBASXB        GET ASXB ADDRESS
         USING ASXB,ASXBREG
          SPACE 2
*/* P GET IHSA ADDR FROM ASXBIHSA */
          SPACE 2
         L     IHSAREG,ASXBIHSA        GET IHSA ADDRESS
         USING IHSA,IHSAREG
          SPACE 2
*/* P MOVE REGS FROM LCCAPGRL TO IHSAGPRS */
          SPACE 2
         MVC   IHSAGPRS(L64),LCCAPGR2  MOVE REGS SAVE AT PAGE FAULT
*                                      TIME INTO IHSA SAVE AREA
          SPACE 2
*/* P MOVE PSW FROM LCCAPPSW TO IHSACPSW AND MOVE CLOCK TO LCCAITOD */
          SPACE 2
         MVC   IHSACPSW(L8),LCCAPPSW   MOVE PSW SAVE AT PAGE FAULT
*                                      TIME INTO IHSA SAVE AREA
         MVC   LCCAITOD,PSAPCPSW       MOVE CLOCK FOR J.S.T.   @YM08398
         L     R1,PSAPCCAV             PCCA ADDRESS            @ZA32144
         USING PCCA,R1                 GET PCCA ADDRESSABILITY @ZA32144
         TM    PCCAINTE,PCCANUIN       CPU TIMER DAMAGED?      @ZA32144
         DROP  R1                      DROP ADDRESSABILITY     @ZA32144
         BO    CLRSPREG                CPU TIMER IS DAMAGED.   @ZA32144
         ICM   R1,M15,TCBTME           TASK TIMING ACTIVE?     @ZA32144
         BNP   CLRSPREG                NOT TASK TIMING.        @ZA32144
*  SET CPU TIMER FROM SAVED VALUE IN IHSA SO THE COMMON SUSPEND ROUTINE
*  WILL SAVE THE CPU TIMER WITH INTERRUPT TIME EXCLUDED.       @ZA32144
         SPT   IHSACPUT                SET CPU TIMER FROM IHSA @ZA32144
CLRSPREG DS    0H                      BRANCH CPU TIMER NOT SET@ZA32144
         DROP  IHSAREG
          SPACE 2
*/* P SET LOCAL LOCK HELD BIT IN TCB */
          SPACE 2
         OI    TCBFBYT1,TCBLLH         SET LOCAL LOCK HELD BIT
          SPACE 2
*/* P (,SUSPEND) PUT 4 IN REG 6 TO INDICATE NON-QUIESCE SRB TO RUN */
          SPACE 2
         LA    SCHLREG,FOUR            INDICATE NON-QUIESCABLE SRB
*                                      TO BE SCHEDULED TO DO PAGE I/O
         SR    R1,R1                   CLEAR REG 1 FOR SUSPEND ROUTINE
         B     SUSPEND                 GO SET UP FOR COMMON SUSPEND RTN
          SPACE 2
*/*NOLOCAL: P MOVE REGS FROM LCCAPGR2 TO TCBGRS */
          SPACE 2
NOLOCAL  MVC   TCBGRS(L64),LCCAPGR2    MOVE REGS TO TCB
          SPACE 2
*/* P MOVE PSW FROM LCCAPPSW TO RBOPSW */
          SPACE 2
         MVC   RBOPSW(L8),LCCAPPSW     MOVE PSW TO RB
         SR    WORKREG1,WORKREG1       ZERO REG
          SPACE 2
*/* P INCREMENT RB WAIT COUNT */
          SPACE 2
         IC    WORKREG1,RBWCF          GET WAIT COUNT
         LA    WORKREG1,C1(WORKREG1)   ADD ONE TO COUNT
         STC   WORKREG1,RBWCF          PUT WAIT COUNT BACK
          SPACE 2
*/* P ZERO REG 6 TO INDICATE SYSTEM LEVEL SRB TO RUN */
          SPACE 2
         SR    SCHLREG,SCHLREG         INDICATE QUIESCABLE SRB TO BE
*                                      SCHEDULED TO DO  PAGE I/O
         L     WORKREG,ASCBTCBS        LOAD VALUE OF READY TCBS
          SPACE 2
*/*DECTCBS2: P (,EXIT3) DECREMENT COUNT OF READY TCBS */
          SPACE 2
DECTCBS2 LR    WORKREG3,WORKREG        TRANSFER VALUE
         BCTR  WORKREG3,C0             DECREMENT COUNT
         CS    WORKREG,WORKREG3,ASCBTCBS REPLACE OLD WITH NEW
         BC    M4,DECTCBS2             IF UNEQUAL,TRY AGAIN    @YM08215
         LTR   WORKREG3,WORKREG3      NUMBER READY TCBS=0? @ZD04015
         BNZ   EXIT3                NO,BRANCH TO EXIT    @ZD04015
         LH    WORKREG3,ASCBSWCT     GET WAIT COUNT       @ZD04015
         LA    WORKREG3,1(WORKREG3)       INCREMENT COUNT  @ZD04015
         STH   WORKREG3,ASCBSWCT         SAVE NEW WAIT COUNT  @ZD04015
         B     EXIT3                   BRANCH TO EXIT
          SPACE 2
*/*SRBPRSS: P GET CPID VALUE SRB00 IN REG 0 */
          SPACE 2
SRBPRSS  L     CPIDREG,IDFIELD         GET GETCELL CELL POOL ID
          SPACE 2
*/* L GETCELL-- GET SRB-SAVE AREA CELL */
          SPACE 2
         GETCELL CPID=(CPIDREG),BRANCH=YES,SAVE=NO GET SRB CELL
          SPACE 2
*/* D (YES,CELLSOK,NO,) CELL OBTAINED OK? */
          SPACE 2
         LTR   RTCDREG,RTCDREG         WAS CELL OBTAINED
         BZ    CELLSOK                 IF SO GO PROCESS
          SPACE 2
*/* P SET UP ADDRESSABILITY TO THE PVT */
          SPACE 2
         USING PVT,PVTPTR                                      @YM07664
         L     CVTREG2,FLCCVT      GET THE ADDRESS OF THE CVT  @YM07664
*                                  GET THE ADDRESS OF THE PVT  @YM07664
         L     PVTPTR,CVTPVTP-CVTMAP(0,3)                      @YM07664
         SPACE 2
*/* D (NO,SUSPABD,YES,) IS THE PVTSSRB AVAILABLE? */
         SPACE 2
         TM    PVTFLAG1,PVTSIT     CHECK IF PVTSSRB REPLENISH INDICATOR
*                                  IS ON, MEANING NO SSRB AVAILABLE
         BO    SUSPABD             NO AVAILABLE SSRB -- ABEND  @YM07664
          SPACE 2
*/* P USE THE SSRB CHAINED OUT OF THE PVT TO STORE STATUS */
          SPACE 2
         OI    PVTFLAG1,PVTSIT     SET PVTSSRB REPLENISH FLAG  @YM07664
         L     SRBCRREG,PVTSSRB    USE PVTSSRB TO STORE STATUS @YM07664
         DROP  PVTPTR
          SPACE 2
*/* P SET FREEMAIN INDICATOR IN THE SSRB */
          SPACE 2
         USING SRBSECT,SRBCRREG
         LA    R15,SSRBMAIN            SET BIT IN SSRB SO THAT FREEMAIN
*                                      IS DONE RATHER THAN FREECELL
          SPACE 2
*/*CELLSOK: P STORE PAGE FAULT ADDRESS INTO SSRB AND SET MODE OF
*/*RELEASE */
          SPACE 2
CELLSOK  STC   R15,SSRBFLG1            INDICATE HOW AREA IS TO BE FREED
         L     WORKREG1,LCCAPVAD       GET PAGE FAULT ADDRESS
         ST    WORKREG1,SSRBTRAN       PUT ADDRESS IN SSRB
          SPACE 2
*/* P MOVE LCCAPGR2 TO SRBGPRS */
          SPACE 2
         MVC   SSRBGPRS(L64),LCCAPGR2  MOVE REGS TO SRB SAVE AREA
          SPACE 2
*/* P MOVE LCCAPSW TO SRBCPSW */
          SPACE 2
         MVC   SSRBCPSW(L8),LCCAPPSW   MOVE PSW TO SRB SAVE AREA
          SPACE 2
*/* P ZERO REG 5 TO INDICATE SRB */
*/* P REG 4 = PTR(SRB CELL) */
          SPACE 2
         LR    R4,SRBCRREG             SET UP PARM REG 4
         SR    R5,R5                   ZERO PARM REG 5
         SPACE 2
*/* P INDICATE UNLOCKED SRB IN REG 6 */
         SPACE 2
         LA    SCHLREG,EIGHT           INDICATE UNLOCKED SRB SUSPENDED
          SPACE 2
*/* L (NO,SUSPEND,YES,) SETLOCK-- IS LOCAL LOCK HELD? */
          SPACE 2
         SETLOCK TEST,TYPE=LOCAL,BRANCH=(NOTHELD,SUSPEND)
*                                      LOCAL LOCK HELD?
         SPACE 2
*/* P INDICATE LOCAL LOCK HELD IN REG 6 */
         SPACE 2
         LA    SCHLREG,FOUR            INDICATE LOCAL LOCK IS HELD
         SPACE 2
*/*SUSPEND: P REG 12 = ADDR COMMON SUSPEND RTN REG 15 = RETURN ADDR */
*/* L IEAVSPCR-- SUSPEND AND STATUS SAVE */
         SPACE 2
SUSPEND  L     R12,ASPCR               GET ADDRESS COMMON SUSPEND RTN
         BALR  R15,R12                 COMMON RTN PERFORMS SUSPEND
          SPACE 2
*/*EXIT3: P RESTORE ALL REGS EXCEPT PARMS 4,5,6 */
          SPACE 2
EXIT3    DS    0H
         LM    R0,R3,C0(R13)           RESTORE
         LM    R7,R15,C28(R13)         REGISTEGS
         DROP  SRBCRREG
         DROP  ASCBBASE
         DROP  CCABASE
          SPACE 2
*/* R RETURN VIA BR 14 */
          SPACE 2
         BR    RETREG                  RETURN TO CALLER
         SPACE 4
*/*SUSPABD: L () ABEND-- ABEND THE TASK WITH CODE X'028' */
         SPACE 2
SUSPABD  LA    PARMREG,PIXABEND    PUT PIX ABEND CODE IN REG 1 @YM07664
         ABEND (1),DUMP,,SYSTEM                                @YM07664
***********************************************************************
*                                                                     *
*                      CONSTANTS & STORAGE                            *
*                                                                     *
***********************************************************************
         DS    0F                      ALIGN TO FCELL POOL ID TO FWORD
IDFIELD  DS    0CL4                    CELL POOL ID
         DC    C'SRB'                  SRB SAVE AREA CELL POOL ID
         DC    X'00'                   SRB SAVE AREA CELL POOL ID
         EXTRN IEAVSPCR
ASPCR    DC    V(IEAVSPCR)             COMMON SUSPEND ROUTINE
         TITLE 'IEAVEPC- RESET ROUTINE (IEAVRSET)'
         ENTRY IEAVRSET
          SPACE 2
*/*IEAVRSET: E IEAVRSET */
          SPACE 2
IEAVRSET DS    0H
          SPACE 2
*/* P SAVE REGS IN SPECIAL GLOBAL LOCK AREA FOR SUSPEND/RESET */
          SPACE 2
         STM   R0,R15,C0(R13)          SAVE ALL REGS
          SPACE 2
*/* P ESTABLISH ADDRESSABILITY */
          SPACE 2
         BALR  BASEREG,C0              ESTABLISH
         USING *,BASEREG               ADDRESSABILITY
          SPACE 2
*/* D (NO,NOERR,YES,) ERROR DETECTED? */
          SPACE 2
         LTR   ERREG,ERREG             WAS ERROR DETECTED IN I/O PROC.
         BZ    NOERR                   CONTINUE NORMALLY
          SPACE 2
*/* L CALLRTM-- TYPE= PGIOERR */
          SPACE 2
         LR    WORKREG1,R13            SAVE SAVE AREA VALUE
         L     R13,FLCCVT              GET CVT ADDRESS
         L     R13,CVTSPSA-CVT(R13)    GET SAVE AREA VECTOR TABLE ADD
         L     R13,WSAGPGIO-WSAG(R13)  GET PGIOERR SAVE AREA ADD
         CALLRTM TYPE=PGIOERR          LET RTM HANDLE ERROR
         LR    R13,WORKREG1            RESTORE SAVE AREA POINTER
          SPACE 2
*/*NOERR: D (YES,SCHSRB,NO,) SRB MODE? */
          SPACE 2
NOERR    LTR   SRBREG,SRBREG           WAS SRB SUSPENDED
         BZ    SCHSRB                  IF SO GO SCHEDULE
          SPACE 2
*/* P GET TCB ADDRESS FROM REG 4 */
          SPACE 2
         USING TCB,XTCBREG
          SPACE 2
*/* D (NO,NOLLH,YES,) WAS LOCAL LOCK HELD? */
          SPACE 2
         TM    TCBFBYT1,TCBLLH         WAS TCB LOCALLY LOCKED
         BZ    NOLLH                   IF NOT PROCEED TO POST
          SPACE 2
*/* P CLEAR TCBLLH */
          SPACE 2
         NI    TCBFBYT1,CXFF-TCBLLH    CLEAR LOCAL LOCK HELD BIT
          SPACE 2
*/* P (,REXIT) CHANGE SUSPEND ID TO INTERRUPT ID */
          SPACE 2
         L     ASCBREG,PSAAOLD         GET ASCB ADDRESS
         USING ASCB,ASCBREG
         OI    ASCBLOCK,CX80           SET HIGH ORDER BIT OF LOCAL LOCK
*                                      WHICH IS NOW INTERRUPT ID
         B     REXIT                   EXIT
          SPACE 2
*/*NOLLH: P GET RB ADDR FROM REG 5 */
          SPACE 2
NOLLH    DS    0H
         USING RBSECT,RBPTR
          SPACE 2
*/* D (YES,REXIT,NO,) WAIT COUNT = 0? */
          SPACE 2
         CLI   RBWCF,CX00              IS WAIT COUNT ZERO
         BE    REXIT                   IF SO,THEN FINISHED
          SPACE 2
*/* L (,REXIT) POST-- W/O ECB FOR RB */
          SPACE 2
         LR    R10,RBPTR               PUT RB ADDRESS IN REG FOR POST
         SR    R11,R11                 ZERO REG 11 FOR POST NO ECB
         L     EPREG,APOST             GET POST ENTRY POINT
         LR    R1,R13                  SAVE REG 13 VALUE
         BALR  RETREG,EPREG            GO TO POST NO-ECB
         LR    R13,R1                  RESTORE SAVE AREA ADDRESS
         B     REXIT                   GET OUT
          SPACE 2
*/*SCHSRB: L SCHEDULE-- SRB=(REG 4) LOCAL SPL PRIOR=NONQ */
          SPACE 2
SCHSRB   SCHEDULE SRB=(R4)             SCHEDULE SRB SAVE CELL
          SPACE 2
*/*REXIT: P RESTORE ALL SAVED REGISTERS */
          SPACE 2
REXIT    DS    0H
         LM    R0,R15,C0(R13)          RESTORE ALL REGISTERS
          SPACE 2
*/* R RETURN VIA BR 14 */
          SPACE 2
         BR    RETREG                  RETURN TO CALLER
          SPACE 2
*/* FOOTING
*/*
*/*  */
*/*IEAVEPC: END PC FLIH */
          SPACE 2
***********************************************************************
*                                                                     *
*                       CONSTANTS & STORAGE                           *
*                                                                     *
***********************************************************************
          EXTRN IEA0PT01
APOST    DC    A(IEA0PT01)             POST ENTRY ADDRESS
*HIVALUE DS    0D                      GET DOUBLE WORD BOUNDRY @ZA32144
***      DC    X'7FFFFFFFFFFFFFFF'     HIGH VALUE FOR CPU TIME @ZA32144
         TITLE 'IEAVEPC- PSA MAPPING'
         IHAPSA
         TITLE 'IEAVEPC- LCCA DSECT MAPPING'
         IHALCCA
         TITLE 'IEAVEPC- ASCB DSECT MAPPING'
         IHAASCB
         TITLE 'IEAVEPC- ASXB DSECT MAPPING'
         IHAASXB
         TITLE 'IEAVEPC- IHSA DSECT MAPPING'
         IHAIHSA
         TITLE 'IEAVEPC- SSRB DSECT MAPPING'
         IHASSRB
         TITLE 'IEAVEPC- RB DSECT MAPPING'
         IKJRB
         TITLE 'IEAVEPC- TCB DSECT MAPPING'
         IKJTCB
         TITLE 'IEAVEPC- SCA DSECT MAPPING'
         IHASCA
         TITLE 'IEAVEPC- PIE DSECT MAPPING'
         IHAPIE
         TITLE 'IEAVEPC- PICA DSECT MAPPING'
         IHAPICA
         TITLE 'IEAVEPC- FRRS DSECT MAPPING'
         IHAFRRS
         TITLE 'IEAVEPC- WSAVT DSECT MAPPING'
         IHAWSAVT DSECT=YES,CLASS=GLOBAL
         TITLE 'IEAVEPC- CVT DSECT MAPPING'
         CVT   DSECT=YES,PREFIX=NO,LIST=YES
         TITLE 'IEAVEPC- SCVT DSECT MAPPING'
         IHASCVT LIST=YES
         TITLE 'IEAVEPC- SDWA DSECT MAPPING'
         IHASDWA
         TITLE 'IEAVEPC- PCCA DSECT MAPPING'
         IHAPCCA
         TITLE 'IEAVEPC - PVT DSECT MAPPING'
         IHAPVT
         TITLE 'IEAVEPC - CSD DSECT MAPPING'
         IHACSD
         IHATQE                        FOR TASK TIMING         @ZA32144
         IHALDA ,                                              @ZP60023
         IHAASVT ,                                             @ZP60023
PQEFFBQE EQU   0     PTR TO FIRST FBQE OR IF NONE TO PQE       @ZP60023
PQEBFBQE EQU   4     PTR TO LAST FBQE OR IF NONE, TO PQE       @ZP60023
PQEFPQE  EQU   8     ADDR NEXT PQE OR ZERO                     @ZP60023
PQEBPQE  EQU   12    ADDR PREVIOUS PQE OR ZERO                 @ZP60023
PQETCB   EQU   16    ADDR OF OWNING JOB STEP TCB               @ZP60023
PQESIZE  EQU   20    SIZE OF REGION DESCRIBED BY THIS PQE      @ZP60023
PQEREGN  EQU   24    ADDR 1ST REGION BYTE DESCRIBED BY THIS PQE@ZP60023
PQERFLGS EQU   28    FLAG BYTE                                 @ZP60023
PQEHRID  EQU   29    HIERARCHY IDENTIFIER                      @ZP60023
VMMFLGS  EQU   30    SEVEN HIGH ORDER BITS ZERO                @ZP60023
VVVRFLG  EQU   X'01' REAL OR VIRTUAL REGION FLAG               @ZP60023
PQERSVD  EQU   31    RESERVED                                  @ZP60023
         TITLE 'IEAVEPC- LOGOUT DSECT MAPPING'
LOGOUT   DSECT MAPPING OF LOG OUT AREA FOR SYS TERM
LOGWTOA  DS    A                  ADDRESS WTO MESSAGE
LOGLRBA  DS    A                  ADDRESS LOG REC BUFFER
LOGWTOM  DS    CL60               WTO MESSAGE
         DS    0F                 ALLIGN TO FULL WORD BDRY
LOGLRB   DS    0CL132             LOG REC BUFFER
LOGLHDR  DS    0CL32              LOG REC BUFFER HEADER
LOGLRCDT DS    CL1                RECORD TYPE
LOGLRES  DS    CL23               RESERVED BYTES FOR HEADER
LOGLSIZE DS    F                  SIZE OF LOG REC BUFFER
LOGLCODE DS    F                  WAIT-STATE CODE FOR SYSTEM TERMINAT'N
LOGLGPR  DS    CL64               GENERAL REGS AT TIME OF INTERRUPT
LOGLCR0  DS    F                  CONTROL REG 0
LOGLCR1  DS    F                  CONTROL REG 1
LOGLILC  DS    CL1                INSTR LENGTH COUNTER
LOGLINT  DS    CL1                INTERRUPT CODE
LOGLOPSW DS    D                  PROG FLIH OLD PSW
LOGLTNEW DS    A                  T-NEW
LOGLTOLD DS    A                  T-OLD
LOGLANEW DS    A                  A-NEW
LOGLAOLD DS    A                  A-OLD
LOGEND   EQU   *                  END OF LOG OUT AREA
LOGLRBSZ EQU   LOGEND-LOGLRB      SIZE OF LOG REC PORTION
LOGSIZE  EQU   LOGEND-LOGOUT      SIZE OF ENTIRE LOG OUT AREA
         END
/*
//STEP3   EXEC PGM=IEBGENER
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  *
  IDENTIFY IEAVEPC('ZP60023')
++MOD(IEAVEDS0) DISTLIB(AOSC5).
/*
//SYSUT2   DD  DSN=&&SMPMCS,DISP=(MOD,PASS)
//SYSIN    DD  DUMMY
//STEP4   EXEC PGM=IFOX00,PARM='OBJECT,NODECK,NOTERM,XREF(SHORT)'
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  UNIT=VIO,SPACE=(CYL,10)
//SYSUT2   DD  UNIT=VIO,SPACE=(CYL,10)
//SYSUT3   DD  UNIT=VIO,SPACE=(CYL,10)
//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR
//         DD  DSN=SYS1.SMPMTS,DISP=SHR
//         DD  DSN=SYS1.AMODGEN,DISP=SHR
//         DD  DSN=SYS1.APVTMACS,DISP=SHR
//SYSGO    DD  DSN=&&SMPMCS,DISP=(MOD,PASS)
//SYSIN    DD  *
         TITLE 'IEAVEDS0 - PROLOGUE'
* /* START OF SPECIFICATIONS ****
*
*01*  MODULE-NAME = IEAVEDS0
*
*02*     CSECT-NAME = IEAVEDS0
*
*01*  DESCRIPTIVE-NAME = DISPATCHER
*
*01*  COPYRIGHT = NONE
*
*01*  STATUS = CHANGE LEVEL 0
*              SYSTEM CONTROL PROGRAM II                     @G64RP2R
*
*01*  FUNCTION = DISPATCHES TASKS, LOCAL SUPERVISOR ROUTINES AND SRB'S.
*
*02*     OPERATION =THE DISPATCHER SCANS VARIOUS INDICATORS FOR WORK TO
*        BE DONE WHENEVER IT IS ENTERED.  IT STARTS BY TESTING FOR ANY
*        SPECIAL EXITS WHICH MAY HAVE BEEN INDICATED BY SOME SYSTEM
*        FUNCTION SUCH AS VARY CPU PROCESSING OR ACR.  IF NONE OF THE
*        SPECIAL EXITS HAVE BEEN SPECIFIED THE DISPATCHER SCANS ITS
*        VARIOUS QUEUES FOR SRBS, LOCAL SUPERVISOR ROUTINES OR TASKS TO
*        DISPATCH.  QUEUES ARE SCANNED IN THIS ORDER; THE GLOBAL
*        SERVICE MANAGER QUEUE, THE GLOBAL SERVICE PRIORITY LIST, THE
*        LOCAL SERVICE MANAGER QUEUE, THE PSAANEW FIELD (FOR ADDRESS
*        SPACE SWITCH), THE LOCAL SERVICE PRIORITY LIST, THE LOCAL LOCK
*        IS CHECKED FOR LOCAL SUPERVISOR ROUTINES, AND THE TCB
*        DISPATCHING QUEUE IS SCANNED FOR READY TASKS.  IF NO WORK IS
*        FOUND IN THE SYSTEM, THE WAIT TASK IS DISPATCHED.
*
*01*   NOTES =
*
*02*     DEPENDENCIES = NONE
*
*03*        CHARACTER-CODE-DEPENDENCIES = CHARACTER CODE INDEPENDENT
*
*02*     RESTRICTIONS = NONE
*
*02*     REGISTER-CONVENTIONS = DEFINED IN THE EQUATES SECTION OF THIS
*        MODULE
*
*02*     PATCH-LABEL = NUCLEUS PATCH AREA
*
*01*  MODULE-TYPE = PROCEDURE
*
*02*     PROCESSOR = ASSEMBLER-370R
*
*02*     MODULE-SIZE = SEE ESD FOR THIS MODULE
*
*02*     ATTRIBUTES = NUCLEUS SUPERVISOR MODE REFRESHABLE FIXED
*        ZERO PROTECT KEY DISABLED
*
*01*  ENTRY-POINT = IEA0DS
*
*02*     PURPOSE = MAIN DISPATCHER ENTRY POINT. DISABLED, KEY ZERO,
*        SUPERVISOR MODE AND NO LOCKS EXCEPT PERHAPS THE LOCAL LOCK
*        WHEN A LOCAL SUPERVISOR ROUTINE IS BEING PREEMPTED.
*
*02*     LINKAGE = THE DISPATCHER IS ENTERED VIA A BRANCH.  NO
*        PARAMETERS ARE PASSED INTO IT.  MODULES ENTERING THE
*        DISPATCHER AT THIS POINT ARE: THE INTERRUPT HANDLERS, EXIT
*        PROLOG, VARY CPU PROCESSOR, THE LOCK MANAGER, ETC.
*
*02*     INPUT = THE DISPATCHER DOES NOT LOOK AT ANY INPUT REGISTERS ON
*        ENTRY.  DATA REQUIRED FOR IT'S PROCESSING IS OBTAINED FROM THE
*        SPECIAL EXITS INDICATORS IN THE LCCA, THE GLOBAL SERVICE
*        MANAGER QUEUE HEADER, THE GLOBAL SERVICE PRIORITY LIST, THE
*        LOCAL SERVICE MANAGER QUEUE HEADER, THE PSAANEW AND PSAAOLD
*        FIELDS, THE LOCAL SERVICE PRIORITY LISTS, THE CONDITION OF THE
*        LOCAL LOCK AND THE QUEUE OF TASKS IN AN ADDRESS SPACE.
*
*02*     OUTPUT = THE DISPATCHER RESTORES THE STATUS (REGISTERS,
*        FLOATING POINT REGISTERS, CPU INTERVAL TIMER VALUE, LOCKING
*        STATUS AND PSW) OF THE UNIT BEING DISPATCHED.  THE UNIT BEING
*        DISPATCHED MAY OR MAY NOT BE THE UNIT WHICH WAS CURRENTLY
*        ACTIVE WHEN THE DISPATCHER WAS ENTERED.  IF THE UNIT WAS THE
*        CURRENTLY ACTIVE TASK OR LOCAL SUPERVISOR ROUTINE, THE GENERAL
*        PURPOSE REGISTERS AND PSW ARE RESTORED.  IF THE UNIT CHOSEN TO
*        BE DISPATCHED WAS NOT THE CURRENT TASK OR LOCAL SUPERVISOR
*        ROUTINE, THE FLOATING POINT REGISTERS, CPU INTERVAL VALUE AND
*        LOCKING STATUS FOR THE UNIT BEING PREEMPTED IS STORED INTO
*        EITHER THE TCB, FOR A TASK, OR INTO THE INTERRUPT HANDLER SAVE
*        AREA (IHSA), FOR A LOCAL SUPERVISOR ROUTINE.  THIS INFORMATION
*        MUST ALSO BE RESTORED FOR THE NEW UNIT BEING DISPATCHED.
*
*02*     REGISTERS-SAVED = NONE
*
*02*     REGISTER-USAGE = REG 9 - BASE REGISTER , REGISTER 8 - CURRENT
*        ASCB ADDRESS, REGISTER 7 - LCCA ADDRESS.  ALL OTHER REGISTER
*        USAGE VARIES AT DIFFERENT POINTS WITHIN THE MODULE.
*
*02*     REGISTERS-RESTORED = ALL OF THE REGISTERS FOR A LOCAL
*        SUPERVISOR ROUTINE, A SUSPENDED SRB, OR A TASK ARE RESTORED AT
*        DISPATCH.  ON THE INITIAL DISPATCH OF AN SRB, REGISTER 0 IS
*        SET TO THE ADDRESS OF THE SRB, REGISTER 1 CONTAINS THE ADDRESS
*        IN THE PARM FIELD OF THE SRB, REGISTER 14 CONTAINS THE RETURN
*        ADDRESS TO THE DISPATCHER AND REGISTER 15 CONTAINS THE ENTRY
*        POINT ADDRESS OF THE SRB ROUTINE.  ON THE DISPATCH OF THE WAIT
*        TASK, ALL REGISTERS ARE SET TO ZERO.
*
*01*  ENTRY-POINT = IEAVDSTC                                   @Z40FPXJ
*                                                              @Z40FPXJ
*02*     PURPOSE = ENTRY POINT FOR TCTL FUNCTION IN ORDER TO   @Z40FPXJ
*        DISPATCH A TASK, THE ADDRESS OF WHICH IS PASSED IN    @Z40FPXJ
*        REGISTER 6. THIS ENTRY IS WITHIN THE PORTION OF THE   @Z40FPXJ
*        TASK DISPATCHER AFTER A DISPATCHABLE TASK HAS BEEN    @Z40FPXJ
*        CHOSEN.(THE TCTL FUNCTION ALLOWS AN SRB TO GIVE CON-  @Z40FPXJ
*        TROL DIRECTLY TO A TASK BY USING THE DISPATCHER       @Z40FPXJ
*        FACILITIES).                                          @Z40FPXJ
*                                                              @Z40FPXJ
*02*     LINKAGE = THIS IS A BRANCH ENTRY POINT                @Z40FPXJ
*                                                              @Z40FPXJ
*02*     INPUT = THE FOLLOWING REGISTERS ARE SET UP BY TCTL    @Z40FPXJ
*        PRIOR TO ENTERING THE DISPATCHER AT THIS POINT:       @Z40FPXJ
*        REG 5 - RB ADDRESS, REG 6 - TCB ADDRESS, REG 7 -      @Z40FPXJ
*        LCCA ADDRESS, REG 8 - ASCB ADDRESS, REG 9 - DISPATCH- @Z40FPXJ
*        ER BASE ADDRESS, REG 13 - NON-ZERO (USED TO DETERMINE @Z40FPXJ
*        IF ENTRY WAS FROM TCTL FOR LOCAL LOCK PROCESSING      @Z40FPXJ
*                                                              @Z40FPXJ
*02*     REGISTERS-SAVED = NONE                                @Z40FPXJ
*                                                              @Z40FPXJ
*02*     REGISTER-RESTORED = ALL OF THE REGISTERS FOR A TASK   @X40FPXJ
*        ARE RESTORED ON EXIT FROM THE DISPATCHER              @Z40FPXJ
*                                                              @Z40FPXJ
*01*  ENTRY-POINT = DSSRBRTN                                   @Z40FPXJ
*                                                              @Z40FPXJ
*02*     PURPOSE = ENTRY POINT FOR TYPE 6 SVC. THIS ENTRY IS   @Z40FPXJ
*        USED BY THE SVC FLIH WHEN A TYPE 6 SVC ISSUES A       @Z40FPXJ
*        SCHEDULE FOR AN SRB.                                  @Z40FPXJ
*                                                              @Z40FPXJ
*02*     LINKAGE = THIS IS A BRANCH ENTRY POINT                @Z40FPXJ
*                                                              @Z40FPXJ
*02*     INPUT = THE FOLLOWING REGISTERS ARE SET UP BY TYPE 6  @Z40FPXJ
*        PRIOR TO ENTERING THE DISPATCHER AT THIS POINT:       @Z40FPXJ
*        REG 2 -SRB ADDRESS, REG 5 -ASCB ADDRESS, REG 7 -      @Z40FPXJ
*        LCCA ADDRESS, REG 8 - ASCB ADDRESS, REG 9 - DISPATCH- @Z40FPXJ
*        ER BASE ADDRESS.                                      @Z40FPXJ
*                                                              @Z40FPXJ
*02*     REGISTERS-SAVED = NONE                                @Z40FPXJ
*                                                              @Z40FPXJ
*02*     REGISTER-RESTORED = ALL OF THE REGISTERS FOR AN SRB   @X40FPXJ
*        ARE RESTORED ON EXIT FROM THE DISPATCHER              @Z40FPXJ
*                                                              @Z40FPXJ
*01*  ENTRY-POINT = IEAPDS6
*
*02*     PURPOSE = THIS ENTRY POINT IS USED BY END-OF-TASK (EOT) WHEN
*        IT HAS DELETED A TASK.  THE PURPOSE OF THIS ENTRY IS TO
*        PROVIDE THE FOLLOWING FUNCTIONS: JOB STEP TIMING, CLEARING
*        OF PSATNEW AND PSATOLD AND DECREMENTING OF THE COUNT OF THE
*        NUMBER OF CPUS DISPATCHED IN THE ADDRESS SPACE.  ENTRY
*        CONDITIONS ARE: DISABLED, KEY ZERO, SUPERVISOR MODE AND NO
*        LOCKS HELD.
*
*02*     LINKAGE = THE DISPATCHER IS ENTERED VIA A BRANCH.  NO
*        PARAMETERS ARE PASSED INTO IT.  EOT IS THE ONLY USER OF THIS
*        ENTRY POINT.
*
*02*     INPUT = THE DISPATCHER DOES NOT LOOK AT ANY INPUT REGISTERS ON
*        ENTRY.  DATA REQUIRED FOR IT'S PROCESSING IS OBTAINED FROM THE
*        SPECIAL EXITS INDICATORS IN THE LCCA, THE GLOBAL SERVICE
*        MANAGER QUEUE HEADER, THE GLOBAL SERVICE PRIORITY LIST, THE
*        LOCAL SERVICE MANAGER QUEUE HEADER, THE PSAANEW AND PSAAOLD
*        FIELDS, THE LOCAL SERVICE PRIORITY LISTS, THE CONDITION OF THE
*        LOCAL LOCK AND THE QUEUE OF TASKS IN AN ADDRESS SPACE.
*
*02*     OUTPUT = THE DISPATCHER RESTORES THE STATUS (REGISTERS AND
*        PSW) OF THE UNIT BEING DISPATCHED.
*
*02*     REGISTERS-SAVED = NONE
*
*02*     REGISTER-USAGE = REG 9 - BASE REGISTER , REGISTER 8 - CURRENT
*        ASCB ADDRESS, REGISTER 7 - LCCA ADDRESS.  ALL OTHER REGISTER
*        USAGE VARIES AT DIFFERENT POINTS WITHIN THE MODULE.
*
*02*     REGISTERS-RESTORED = ALL OF THE REGISTERS FOR A LOCAL
*        SUPERVISOR ROUTINE, A SUSPENDED SRB, OR A TASK ARE RESTORED ON
*        EXIT FROM THE DISPATCHER.  ON THE INITIAL DISPATCH OF AN SRB,
*        REGISTER 0 IS SET TO THE ADDRESS OF THE SRB, REGISTER 1
*        CONTAINS THE ADDRESS IN THE PARM FIELD OF THE SRB AND REGISTER
*        14 CONTAINS THE RETURN POINT TO THE DISPATCHER.  ON THE
*        DISPATCH OF THE WAIT TASK, ALL REGISTERS ARE SET TO ZERO.
*
*01*  ENTRY-POINT = IEAPDS7
*
*02*     PURPOSE = THIS ENTRY POINT IS USED BY THE I/O AND SVC FLIH'S
*        ON THEIR NORMAL RETURN TO THE DISPATCHER.  THE PURPOSE OF
*        THIS ENTRY IS TO BYPASS THE RESTORING OF THE SUPERSTACK
*        ADDRESS BY THE DISPATCHER SINCE IT IS ALREADY HELD BY THE
*        FLIH'S.  ENTRY CONDITIONS ARE THE SAME AS FOR THE IEA0DS
*        ENTRY.
*
*02*     LINKAGE = THE DISPATCHER IS ENTERED VIA A BRANCH.  NO
*        PARAMETERS ARE PASSED INTO IT.  I/0 AND SVC FLIH'S ARE THE
*        ONLY USERS OF THIS ENTRY POINT.
*
*02*     INPUT = THE DISPATCHER DOES NOT LOOK AT ANY INPUT REGISTERS ON
*        ENTRY.  DATA REQUIRED FOR IT'S PROCESSING IS OBTAINED FROM THE
*        SPECIAL EXITS INDICATORS IN THE LCCA, THE GLOBAL SERVICE
*        MANAGER QUEUE HEADER, THE GLOBAL SERVICE PRIORITY LIST, THE
*        LOCAL SERVICE MANAGER QUEUE HEADER, THE PSAANEW AND PSAAOLD
*        FIELDS, THE LOCAL SERVICE PRIORITY LISTS, THE CONDITION OF THE
*        LOCAL LOCK AND THE QUEUE OF TASKS IN AN ADDRESS SPACE.
*
*02*     OUTPUT = THE DISPATCHER RESTORES THE STATUS (REGISTERS AND
*        PSW) OF THE UNIT BEING DISPATCHED.
*
*02*     REGISTERS-SAVED = NONE
*
*02*     REGISTER-USAGE = REG 9 - BASE REGISTER , REGISTER 8 - CURRENT
*        ASCB ADDRESS, REGISTER 7 - LCCA ADDRESS.  ALL OTHER REGISTER
*        USAGE VARIES AT DIFFERENT POINTS WITHIN THE MODULE.
*
*02*     REGISTERS-RESTORED = ALL OF THE REGISTERS FOR A LOCAL
*        SUPERVISOR ROUTINE, A SUSPENDED SRB, OR A TASK ARE RESTORED ON
*        EXIT FROM THE DISPATCHER.  ON THE INITIAL DISPATCH OF AN SRB,
*        REGISTER 0 IS SET TO THE ADDRESS OF THE SRB, REGISTER 1
*        CONTAINS THE ADDRESS IN THE PARM FIELD OF THE SRB AND REGISTER
*        14 CONTAINS THE RETURN POINT TO THE DISPATCHER.  ON THE
*        DISPATCH OF THE WAIT TASK, ALL REGISTERS ARE SET TO ZERO.
*
*01*  ENTRY-POINT = IEAPDSRT
*
*02*     PURPOSE = RETURN POINT IN THE DISPATCHER FOR ALL SRB ROUTINES.
*        THE DISPATCHER RESETS ALL SRB MODE INDICATORS AND DOES THE JOB
*        STEP TIMING FOR THE ADDRESS SPACE UNDER WHICH THE SRB WAS
*        RUNNING.  ENTRY CONDITIONS ARE: ENABLED OR DISABLED, NO LOCKS,
*        SUPERVISOR MODE.
*
*02*     LINKAGE = THE DISPATCHER IS ENTERED VIA A BRANCH.  NO
*        PARAMETERS ARE PASSED INTO IT.  ALL SRB ROUTINES RETURN TO
*        THIS ENTRY POINT.
*
*02*     INPUT = THE DISPATCHER DOES NOT LOOK AT ANY INPUT REGISTERS ON
*        ENTRY.  DATA REQUIRED FOR IT'S PROCESSING IS OBTAINED FROM THE
*        SPECIAL EXITS INDICATORS IN THE LCCA, THE GLOBAL SERVICE
*        MANAGER QUEUE HEADER, THE GLOBAL SERVICE PRIORITY LIST, THE
*        LOCAL SERVICE MANAGER QUEUE HEADER, THE PSAANEW AND PSAAOLD
*        FIELDS, THE LOCAL SERVICE PRIORITY LISTS, THE CONDITION OF THE
*        LOCAL LOCK AND THE QUEUE OF TASKS IN AN ADDRESS SPACE.
*
*02*     OUTPUT = THE DISPATCHER RESTORES THE STATUS (REGISTERS AND
*        PSW) OF THE UNIT BEING DISPATCHED.
*
*02*     REGISTERS-SAVED = NONE
*
*02*     REGISTER-USAGE = REG 9 - BASE REGISTER , REGISTER 8 - CURRENT
*        ASCB ADDRESS, REGISTER 7 - LCCA ADDRESS.  ALL OTHER REGISTER
*        USAGE VARIES AT DIFFERENT POINTS WITHIN THE MODULE.
*
*02*     REGISTERS-RESTORED = ALL OF THE REGISTERS FOR A LOCAL
*        SUPERVISOR ROUTINE, A SUSPENDED SRB, OR A TASK ARE RESTORED ON
*        EXIT FROM THE DISPATCHER.  ON THE INITIAL DISPATCH OF AN SRB,
*        REGISTER 0 IS SET TO THE ADDRESS OF THE SRB, REGISTER 1
*        CONTAINS THE ADDRESS IN THE PARM FIELD OF THE SRB AND REGISTER
*        14 CONTAINS THE RETURN POINT TO THE DISPATCHER.  ON THE
*        DISPATCH OF THE WAIT TASK, ALL REGISTERS ARE SET TO ZERO.
*
*
*01*  EXIT-NORMAL = GLOBAL SRB DISPATCH
*
*02*     CONDITIONS = LOAD PSW TO THE SRB ROUTINE, ENABLED, SUPERVISOR
*        MODE, AND IN THE KEY SPECIFIED IN THE SRB.
*
*02*     OUTPUT = REGISTER 0 CONTAINS THE ADDRESS OF THE SRB, REGISTER
*        1 CONTAINS THE PARM FIELD FROM THE SRB, REGISTER 14 CONTAINS
*        THE RETURN ADDRESS TO THE DISPATCHER AND REGISTER 15 CONTAINS
*        THE SRB ENTRY POINT ADDRESS.
*
*02*     RETURN-CODES = NONE
*
*01*  EXIT-NORMAL = SUSPENDED SRB DISPATCH
*
*02*     CONDITIONS = LOAD PSW AND ALL REGISTERS TO RE-ESTABLISH THE
*        ENVIRONMENT OF THE SRB WHEN IT WAS SUSPENDED.
*
*02*     OUTPUT = PSW AND REGISTERS RETURNED TO THEIR STATUS AT
*        SUSPEND.
*
*02*     RETURN-CODES = NONE
*
*01*  EXIT-NORMAL = LOCAL SUPERVISOR DISPATCH
*
*02*     CONDITIONS = LOAD PSW AND ALL REGISTERS TO RE-ESTABLISH THE
*        ENVIRONMENT FOR THE LOCAL SUPERVISOR ROUTINE.  THE LOCAL LOCK
*        AND, IF IT WAS HELD, THE CMS LOCK IS ALSO RESTORED.
*
*02*     OUTPUT = THE ENVIRONMENT IS RESTABLISHED TO WHAT IT WAS WHEN
*        THE LOCAL SUPERVISOR ROUTINE WAS PREEMPTED.
*
*02*     RETURN-CODES = NONE
*
*01*  EXIT-NORMAL = TASK DISPATCH
*
*02*     CONDITIONS = LOAD PSW AND ALL REGISTERS TO RE-ESTABLISH THE
*        ENVIRONMENT OF THE INTERRUPTED TASK.
*
*02*     OUTPUT = ENVIRONMENT (REGISTERS AND PSW) RESTORED.
*
*02*     RETURN-CODES = NONE
*
*01*  EXIT-NORMAL = WAIT TASK DISPATCH
*
*02*     CONDITIONS = LOAD WAIT PSW AND ZERO ALL REGISTERS.
*
*02*     OUTPUT = ENABLED WAIT STATE PSW LOADED AND ALL REGISTERS SET
*        TO ZERO.
*
*02*     RETURN-CODES = NONE
*
*01*  EXIT-ERROR = NONE
*
*02*     RETURN-CODES = NONE
*
*01*  EXTERNAL-REFERENCES =
*        IEAGSMQ - GLOBAL SERVICE MANAGER QUEUE HEADER
*        IEALSMQ - LOCAL SERVICE MANAGER QUEUE HEADER
*        IEAGSPL - GLOBAL SERVICE PRIORITY LIST
*        IEAWTCB - WAIT TCB
*        IEAWPSW - WAIT PSW
*        IEAWASCB - WAIT ASCB
*        IEAMASCB - MASTER'S ASCB
*        IEACMSLK - CMS LOCK
*
*02*     ROUTINES =
*       IEAVESC1 - GLOBAL SCHEDULE
*              REASON - PLACE GLOBAL SRB'S ONTO THE GLOBAL SPL QUEUE
*              LINKAGE - BRANCH AND LINK R3,R4
*       IEAVESC2 - LOCAL SCHEDULE
*              REASON - PLACE LOCAL SRB'S ONTO THE LOCAL SPL QUEUES
*              LINKAGE - BRANCH AND LINK R3,R4
*       IEA0EF03 - STAGE THREE EXIT EFFECTOR
*              REASON - PLACE IRB'S ONTO THE RB QUEUE
*              LINKAGE BRANCH AND LINK VIA REGISTERS 10,11
*       IEAVRSPN - TIMER RECOVERY SPIN ROUTINE
*              REASON - TO SYNCHRONIZE THE CLOCKS DURING A RECOVERY
*              SEQUENCE.
*              LINKAGE - BRANCH ON REGISTER 15
*       IEAVEMS0 - MEMORY SWITCH
*              REASON - TO CAUSE A SWITCH TO THE MASTER'S ADDRESS SPACE
*              LINKAGE - BRANCH AND LINK ON REGISTERS 14,15
*       TRDISP - TASK TRACE ENTRY
*              REASON - TO TRACE TASK AND LOCAL SUPERVISOR ACTIVITY
*              LINKAGE - BRANCH AND LINK ON REGISTERS 11,10
*       TRSRB1 - INITIAL SRB TRACE ENTRY
*              REASON - TO TRACE INITIAL SRB DISPATCH ACTIVITY
*              LINKAGE - BRANCH AND LINK ON REGISTERS 11,10
*       TRSRB2 - SUSPENDED SRB TRACE ENTRY
*              REASON - TO TRACE ACTIVITY OF SUSPENDED SRBS
*              LINKAGE - BRANCH AND LINK ON REGISTERS 11,10
*       IEADISP1 - INITIAL SRB GTF ENTRY
*              REASON - TO ALLOW GTF TO TRACK INITIAL SRB ACTIVITY
*              LINKAGE - HOOK MACRO
*       IEADISP2 - SUSPENDED SRB GTF ENTRY
*              REASON - TO ALLOW GTF TO TRACK SUSPENDED SRB ACTIVITY
*              LINKAGE - HOOK MACRO
*       IEADISP3 - TCB/LOCAL SUPERVISOR GTF ENTRY
*              REASON - TO ALLOW GTF TO TRACK TASK ACTIVITY
*              LINKAGE - HOOK MACRO
*
*02*     DATA-AREAS = NONE
*
*02*     CONTROL-BLOCKS =
*              1. PSA - W/R
*              2. LCCA - W/R
*              3. PCCA - R
*              4. CVT - R
*              5. ASCB - W/R
*              6. ASXB - R
*              7. TCB - W/R
*              8. RB - R
*              9. TQE - W/R
*             10. SRB - R
*             11. SSRB - R/D
*             12. IHSA - W/R
*             13. IEAVBK - W/R
*             14. IHAFRRS - W/R
*             15. CSD - W/R
*             16. SPL - W/R
*             17. WSAVT - R
*
*01*  TABLES = WSACEDS0 - DISPATCHER'S REGISTER SAVE AREA.
*
*01*  MACROS =
*              1. HOOK - GTF INTERFACE
*              2. MODESET - RESET TO KEY ZERO ON RETURN FROM SRB
*                 ROUTINE
*              3. SETLOCK - OBTAIN AND RELEASE OF VARIOUS LOCKS
*              4. CALLRTM - RTM INTERFACE
*              5. SCHEDULE - SCHEDULE SRB TO LOCAL QUEUE
*              6. SETFRR - PURGE FRR STACK
*              7. FREECELL - FREE SUSPENDED SRB AND SAVE AREA
*              8. FREEMAIN - FREE SUSPENDED SRB AND SAVE AREA
*
*02*    SERIALIZATION =
*              1. GLOBAL DISPATCHER LOCK - SERIALIZE ON THE ASCB
*                 DISPATCHING QUEUE AND THE SPL QUEUES
*              2. LOCAL LOCK - SERIALIZE ON THE TCB DISPATCHING QUEUE
*              3. SALLOC LOCK - SERIALIZE FREEMAIN
*
*01*  CHANGE-ACTIVITY = SUPPORT CODES - Y02715,Y02751,Y02752
*                       OZ16871 - TEST FOR ASYNCH EXITS TO RUN IN
*                                 CURRENT MEMORY BEFORE DISPATCHING A
*                                 LOWER PRIORITY MEMORY.       @ZA32144
*                       OZ18126 - TURN OFF CDALTCTL IN CDAL TO ALLOW
*                                 IEAVETCL AND IEAVSETS TO SERIALIZE
*                                 PROPERLY.                    @ZA32144
*                       OZ20174 - SERIALIZE THE TCBS3A AND TCBACTIV
*                                 FIELDS WITH IEAVSETS VIA COMPARE AND
*                                 SWAP (IT WAS AND IMMEDIATE). @ZA32144
*                       OZ24768 - TEST FOR LOCALLY LOCKED TCB
*                                 RE-DISPATCH CONDITION AND ADJUST THE
*                                 JOB STEP TIME ACCORDINGLY.   @ZA32144
*                       OZ25275 - REMOVE INVALID AFFINITY BEFORE ABEND
*                                 OF THE SRB.                  @ZA32144
*                       OZ32144 - SET CPU TIME FROM TQE IF TASK MODE
*                                 TIMING IS ACTIVE AND CPU TIMER IS NOT
*                                 DAMAGED WHEN REDISPATCH A TASK AND
*                                 LCCAITOD (INTERRUPT TIME STORED BY
*                                 THE IO OR EXTERNAL FLIH) IS ZERO.
*                                 BYPASS STORING THE CPU CLOCK IN SAVE
*                                 STATUS ROUTINE FOR A PREEMPTED TASK
*                                 IF LCCAITOD IS NONZERO.      @ZA32144
*                       G64RP2R - SLIP ENHANCED TO SUPPORT PROGRAM
*                                 EVENT RECORDING (PER).       @G64RP2R
*                       ZM49527 - CHANGE COMPARE LOGICAL TO A COMPARE
*                                 WHEN CHECKING THE CPU TIMER VALUE
*                                 SAVED IN THE TQE             @ZM49527
*                       ZP60023 - RESTORE TASK'S DAS ENVIRONMENT
*                                 GREG PRICE  2008             @ZP60023
*
*01*  MESSAGES = NONE
*
*01*  ABEND-CODES =
*              1. 22F - ISSUED WHEN AN SRB IS FOUND ON THE SPL QUEUES
*                 WHICH HAS AFFINITY TO A CPU WHICH IS NOT CURRENTLY
*                 ONLINE.
*              2. 072 - ISSUED WHEN A TASK IS FOUND WHICH HAS SPECIFIED
*                 USE OF THE CPU INTERVAL TIMER AND THERE ARE CURRENTLY
*                 NO CPU TIMERS WORKING ON ANY CPUS.
*
**** END OF SPECIFICATIONS ***/
         TITLE 'IEAVEDS0 - CSECT - ENTRIES'
IEAVEDS0 CSECT
         SPACE 4
*/*IEAVEDS0: CHART DISPATCHER */
*/* HEADER
*/*
*/*
*/*
*/*                                        SECTION: 3.1.8.2
*/*         DISPATCHER
*/*                                      PAGE # */
         SPACE 4
*        MODID BR=NO               MODULE IDENTIFICATION
         DC    CL8'IEAVEDS0'
         DC    CL9' UZ30139 '
         DC    CL8'07/17/80'
         DC    CL9' ZP60023 '
         SPACE 4
*   BRANCH ENTRY POINTS TO THE DISPATCHER
         ENTRY IEA0DS
         ENTRY DSBASE
         ENTRY IEAPDS2
         ENTRY IEAPDS6
         ENTRY IEAPDS7
         ENTRY IEAPDSRT
         ENTRY IEAVDSTC                                        @Z40FPXJ
         SPACE 2
*   RANGE OF INSTRUCTINS FOR JOB STEP TIMING
         ENTRY IEAVEDS1
         ENTRY IEAVEDS2
         SPACE 2
*  WAIT PSW ALTERED BY NIP PROCESSING
         ENTRY DSWPSW
         SPACE 2
*   LPSW POINTS
         ENTRY LWAITPSW
         ENTRY LISRBPSW
         ENTRY LSSRBPSW
         ENTRY LLSPVPSW
         ENTRY LTASKPSW
         TITLE 'IEAVEDS0 - EQUATES'
*  REGISTER EQUATES
R0       EQU   0                   REGISTER 0
R1       EQU   1                   REGISTER 1
R2       EQU   2                   REGISTER 2
R3       EQU   3                   REGISTER 3
R4       EQU   4                   REGISTER 4
R5       EQU   5                   REGISTER 5
R6       EQU   6                   REGISTER 6
R7       EQU   7                   LCCA ADDRESS
R8       EQU   8                   ASCB ADDRESS
R9       EQU   9                   BASE REGISTER
RA       EQU   10                  REGISTER 10
RB       EQU   11                  * REGISTERS *
RC       EQU   12                  * USED BY   *
RD       EQU   13                  * LOCK      *
R13      EQU   13                   * REG 13                 @Z40FPXJ
RE       EQU   14                  * MANAGER   *
RF       EQU   15                  REGISTER 15
*  HEX EQUATES
DSX0     EQU   X'00'               HEX ZERO
DSXFF    EQU   X'FF'               HEX FF
*  LENGTH EQUATES
DSL0     EQU   0                   LENGTH 0
DSL1     EQU   1                   LENGTH 1
DSL2     EQU   2                   LENGTH 2
DSL3     EQU   3                   LENGTH 3
DSL4     EQU   4                   LENGTH 4
DSL6     EQU   6                   LENGTH 6
DSL8     EQU   8                   LENGTH 8
DSL60    EQU   60                  LENGTH 60
*  INCREMENT EQUATES
DSI0     EQU   0                   INCREMENT 0
DSI1     EQU   1                   INCREMENT 1
*  CONDITION CODE MASK EQUATES
DSCC1    EQU   1                   CONDITION CODE 3     - MASK 1
DSCC2    EQU   2                   CONDITION CODE 2     - MASK 2
DSCC3    EQU   3                   CONDITION CODE 2/3   - MASK 3
DSCC4    EQU   4                   CONDITION CODE 1     - MASK 4
DSCC6    EQU   6                   CONDITION CODE 1/2   - MASK 6
DSCC7    EQU   7                   CONDITION CODE 1/2/3 - MASK 7
DSCC8    EQU   8                   CONDITION CODE 0     - MASK 8
DSCC11   EQU   11                  CONDITION CODE 0/2/3 - MASK 11
DSCC12   EQU   12                  CONDITION CODE 0/1   - MASK 12
*  MISCELLANEOUS EQUATES
DSO3     EQU   3                       OFFSET 3
DSLLHI   EQU   1                       LOCAL LOCK HELD INDICATOR
DSCMSHI  EQU   2                       CMS LOCK HELD INDICATOR
GSPLSIZ2 EQU   8                   NO. BYTES COMPARED FOR SPL TEST
LSPLSIZ2 EQU   8                   NO. BYTES COMPARED FOR SPL TEST
DSPSWMSK EQU   B'11111100'         PSW MASK WITH I/O AND EXT DISABLED.
DSPSWIOE EQU   B'00000011'         PSW MASK TO ENABLE I/O AND EXT.
DSLSAV   EQU   64                  DISPATCHER'S SAVE AREA LENGTH.
DSRSTKL  EQU   340                 *
DSRSTKM1 EQU   256                 *     RECOVERY STACK MOVE MASKS.
DSRSTKM2 EQU   DSRSTKL-DSRSTKM1    *
*  NOTE THAT DSRSTKL IS PLACED HERE AS AN ABSOLUTE VALUE AND
*        SHOULD BE REPLACED WHEN A MACRO EQUATE BECOMES AVAILABLE.
DSTRACEM EQU   X'FA'               TRACE ACTIVE MASK.
         TITLE 'IEAVEDS0 - ENTRY IEA0DS'
***********************************************************************
*                                                                     *
*        IEA0DS - MAIN DISPATCHER ENTRY POINT                         *
*                                                                     *
***********************************************************************
         SPACE 2
*/*IEA0DS: E MAIN DISPATCHER ENTRY POINT */
         SPACE 2
IEA0DS   DC    0H'0'               MAIN DISPATCHER ENTRY POINT
         SPACE
*/* P ESTABLISH ADDRESSABILITY TO THE FLC */
         SPACE
         USING FLC,R0              FLC-PSA ADDRESSABILITY
LOADPSA  DC    0H'0'               ***** FOR TSO TEST *****
         SPACE 2
*/* P SET SUPER RECOVERY STACK ADDRESS */
         SPACE 2
         L     R1,PSASSTK          SUPER STACK ADDRESS.
         ST    R1,PSACSTK          SET CURRENT TO SUPER STACK ADDRESS.
         SPACE 4
***********************************************************************
*                                                                     *
*        IEAPDS7 - ENTERED FROM THE I/O AND SVC FLIH'S.   THIS IS THE *
*              NORMAL ENTRY POINT FROM THESE FLIH'S.  THE SUPER FRR   *
*              STACK HAS BEEN ESTABLISHED AS CURRENT PRIOR TO ENTRY   *
*              TO THE DISPATCHER.                                     *
*                                                                     *
***********************************************************************
         SPACE 2
*/*IEAPDS7: E ENTRY FROM SVC AND I/O FLIH'S */
         SPACE 2
IEAPDS7  DC    0H'0'               SVC AND I/O FLIH ENTRY POINT.
         SPACE 2
*/* P SET DISPATCHER INDICATOR */
         SPACE 2
         OI    PSASUP1,PSADISP     SET DISPATCHER INDICATOR
         SPACE 2
*/* P ESTABLISH BASE - REGISTER 9 */
         SPACE 2
         BALR  R9,R0               BASE REGISTER - 9
DSBASE   DC    0H'0'
         USING DSBASE,R9           ADDRESSABILITY
         SPACE 2
*/* P ESTABLISH ADDRESSABILITY TO THE LCCA AND ASCB */
         SPACE 2
         L     R8,PSAAOLD          ASCB
         USING ASCB,R8                ADDRESSING
         SPACE
         L     R7,PSALCCAV         LCCA
         USING LCCA,R7                ADDRESSABILITY
         SPACE 2
***********************************************************************
*                                                                     *
*        TEST FOR SPECIAL EXITS                                       *
*                                                                     *
***********************************************************************
         SPACE 2
*/*DS01: D (YES,DS011,NO,) TEST FOR SPECIAL EXITS */
         SPACE 2
DS01     DC    0H'0'               ENTER FOR SPECIAL EXITS TEST
         CLI   LCCADSF1,DSX0       TEST FOR SPECIAL EXITS.
         BNE   DS011               YES. GO TO TEST SPECIFIC EXIT.
         SPACE 2
***********************************************************************
*                                                                     *
*        TEST FOR SRB'S ON THE GSMQ                                   *
*                                                                     *
***********************************************************************
         SPACE 2
*/* D (YES,DS021,NO,) TEST FOR SRB'S ON THE GSMQ */
         SPACE 2
DST001   DC    0H'0'               *** TEST LABEL ***
         L     R6,DSGSMQ           ADDRESS OF START OF GSMQ.
         L     R5,0(R6)            FIRST ENTRY.
         LTR   R5,R5               TEST FOR SRB'S.
         BNZ   DS021               MAY BE SRB'S. GO TO COMPARE AND SWAP
         SPACE 2
***********************************************************************
*                                                                     *
*        TEST FOR SRB'S ON THE GSPL                                   *
*                                                                     *
***********************************************************************
         SPACE 2
*/*DS03: D (YES,DS031,NO,) TEST FOR SRB'S ON THE GSPL */
         SPACE 2
DS03     DC    0H'0'
         L     R4,DSGSPL           ADDRESS OF GSPL
         L     R0,DSL4(R4)         ANY NON-Q SRBS?             @YM03564
         O     R0,DSL8(R4)         OR SYSTEM SRBS?             @YM03564
         BNZ   DS031               SRBS. GO CHECK FURTHER.     @YM03564
         SPACE 2
***********************************************************************
*                                                                     *
*        TEST FOR SRB'S ON THE LOCAL SMQ                              *
*                                                                     *
***********************************************************************
         SPACE 2
*/*DS04: D (YES,DS041,NO,) TEST FOR SRB'S ON THE LSMQ */
         SPACE 2
DS04     DC    0H'0'
         L     R6,DSLSMQ           ADDRESS OF START OF LSMQ.
         L     R5,0(R6)            FIRST ENTRY.
         LTR   R5,R5               TEST FOR SRB'S.
         BNZ   DS041               MAY BE SRB'S. GO TO COMPARE AND SWAP
         SPACE 2
***********************************************************************
*                                                                     *
*        TEST FOR ADDRESS SPACE SWITCH.                               *
*                                                                     *
***********************************************************************
         SPACE 2
*/*DS05: D (YES,DS051,NO,) TEST FOR ADDRESS SPACE SWITCH */
         SPACE 2
DS05     DC    0H'0'
         C     R8,PSAANEW          DOES CURRENT MATCH THE ASCB IN "NEW"
         BNE   DS051               NO. GO TO SWITCH ADDRESS SPACES.
         SPACE 2
***********************************************************************
*                                                                     *
*        TEST FOR SRB'S ON THE LSPL                                   *
*                                                                     *
***********************************************************************
         SPACE 2
*/*DS06: D (YES,DS061,NO,) TEST FOR SRB'S ON THE LSPL */
         SPACE 2
DS06     DC    0H'0'
         L     R4,ASCBSPL          ADDRESS OF LOCAL SPL
         L     R0,DSL4(R4)         ANY NON-Q SRBS?             @YM03564
         O     R0,DSL8(R4)         OR SYSTEM SRBS?             @YM03564
         BNZ   DS061               NOT ZERO. GO TO CHECK FURTHER.
         SPACE 2
***********************************************************************
*                                                                     *
*        TEST FOR LOCAL SUPERVISOR                                    *
*                                                                     *
***********************************************************************
         SPACE 2
*/*DS07: D (YES,DS08,NO,) TEST FOR LOCAL LOCK AVAILABLE */
         SPACE 2
DS07     DC    0H'0'
         L     R1,ASCBLOCK         CURRENT LOCKWORD VALUE      @YM03564
         LH    R3,PSACPULA         LOGICAL CPU ADDRESS.
         LTR   R1,R1               IS LOCK AVAILABLE?          @YM03564
         BZ    DS08                LOCK IS AVAILABLE, OBTAIN IT
         SPACE 2                                               @YM03564
*/* D (YES,DS08A,NO,) TEST FOR LOCAL SUPERVISOR */
         SPACE 2                                               @YM03564
         BM    DS08A               INTERRUPT ID, GO OBTAIN IT  @YM03564
         SPACE 2                                               @YM03564
*/* D (YES,,NO,DS08B) WAS LOCK OWNED BY THIS CPU? */           @ZA24768
         SPACE 2                                               @YM03564
         CR    R1,R3               WAS LOCAL LOCK OWNED BY THIS CPU?
         BNE   DS08B               NO, LOCK IS NOT AVAILABLE.  @ZA24768
         SPACE 2                                               @YM03564
*/* D (NO,DS081,YES,) RE-DISP AFTER I/O OR EXT INTERRUPT? */   @ZA24768
         SPACE 2                                               @ZA24768
         L     R1,LCCAITOD         GET INTERRUPT TOD VALUE.    @ZA24768
         LTR   R1,R1               IF ZERO, NOT RE-DISP AFTER  @ZA24768
         BZ    DS081                    I/O OR EXT INTERRUPT.  @ZA24768
         SPACE 2                                               @ZA24768
*/* S DSJST: ADJUST JST TO EXCLUDE INTERRUPT PROCESSING */     @ZA24768
         SPACE 2                                               @ZA24768
         BAL   RE,DSJST            ADJUST JOB STEP TIMING.     @ZA24768
         SPACE 2                                               @ZA24768
*/* P (,DS081) UPDATE DTOD VALUE FOR RE-DISPATCH */            @ZA24768
         SPACE 2                                               @ZA24768
         STCK  LCCADTOD            SET DTOD FOR RE-DISPATCH.   @ZA24768
         B     DS081               GO TO LOCAL SUPV DISPATCHER.@ZA24768
         SPACE 2                                               @ZA24768
*/*DS08: D (YES,DS08X,NO,) ANY READY TCBS TO DISPATCH? */      @ZA16871
         SPACE 2                                               @YM03564
DS08     DC    0H'0'                                           @YM03564
         L     R4,ASCBTCBS         GET READY TCB COUNT         @YM07654
         C     R4,ASCBCPUS         IS IT GREATER THAN CPUS     @YM07654
         BNL   DS08X               YES. FOUND WORK FOR THIS CPU@ZA16871
         SPACE 2                                               @YM03564
*/* D (YES,,NO,DS08B) ANY ASYNCH EXITS TO DISPATCH? */         @ZA16871
         SPACE 2                                               @ZA16871
         TM    ASCBFLG1,ASCBS3S    TEST FOR ASYNCH EXITS       @ZA16871
         BNO   DS08B               NONE. NO WORK IN THIS ASCB  @ZA16871
         SPACE 2                                               @ZA16871
*/*DS08X: D (YES,DS09,NO,DS08B) OBTAIN LOCAL LOCK SUCCESSFUL? */
         SPACE 2                                               @YM03564
DS08X    DC    0H'0'                                           @YM07654
         CS    R1,R3,ASCBLOCK      OBTAIN FREE LOCK WITH CPUID @YM03564
         BC    DSCC7,DS08B         LOCK WAS NOT AVAILABLE      @YM03564
         OI    PSAHLHI+DSL3,DSLLHI INDICATE LOCAL LOCK NOW OWNED
         B     DS09                GO TO TASK DISPATCHER       @YM03564
         SPACE 2                                               @YM03564
*/*DS08A: D (YES,DS071,NO,) INTERRUPT ID STILL IN LOCK? */
         SPACE 2                                               @YM03564
DS08A    DC    0H'0'                                           @YM03564
         CS    R1,R3,ASCBLOCK      TEST FOR ID.
         BC    DSCC8,DS071         YES.ID WAS IN LOCK. CPU ADDRESS NOW
*                                       IS. GO TO RESTORE LOCAL SUPVR.
         SPACE 2
***********************************************************************
*                                                                     *
*        TEST RECURSION THROUGH WAIT TASK                             *
*                                                                     *
***********************************************************************
         SPACE 2
*/*DS08B: D (NO,DS08C,YES,) WAIT TASK ACTIVE?*/
         SPACE 2
DS08B    DC    0H'0'                                           @YM03564
         L     R3,PSATOLD          TEST CURRENT TCB PTR TO SEE IF IT
         C     R3,DSWTCB                IS THE WAIT TCB.
         BNE   DS08C               NO. GO TO GET NEXT ADDRESS SPACE.
         SPACE 2                                               @YM03564
*/*DS08B2: D (NO,DS05C,YES,)  ANY WORK ON RECURSIVE SEARCH?*/
         SPACE 2                                               @YM03564
DS08B2   DC    0H'0'                                           @ZA09433
         SPACE 1
DST0035  DC    0H'0'               *** TEST LABEL ***
         TM    LCCADSF2,LCCADSRW       RECUSIVE SEARCH OF READY QUEUE
*                                      WAS ANY WORK FOUND.
         BZ    DS05C               NO. RECURSION. GO TO DISPATCH WAIT
*                                       TASK.
         NI    LCCADSF2,DSXFF-LCCADSRW TURN OFF READY WORK IND.
         BAL   RF,DSSAVE           SAVE STATUS                 @YM03564
         SPACE 2
*/*DSLOCKW: S SETLOCK:OBTAIN THE GLOBAL DISPATCHER LOCK */
         SPACE 2
DSLOCKW  DC    0H'0'
*        SETLOCK OBTAIN,TYPE=DISP,MODE=UNCOND,RELATED=('ASCB QUEUE/GSPL*
               /LSPL/PSAANEW',IEAVEDS0,(DSLOCK8,DSLOCK11,DSLOCK14,DSLOC*
               K16,DSLOCK17,DSLOCK18,DSLOCK19))
         L     RD,AGSLDISP         OBTAIN DISPATCHER SPECIAL ENTRY PT
         BALR  RE,RD               LOCK MANAGER'S SPECIAL DISP ENTRY
         ST    RD,PSAANEW          ZERO ANEW TO FORCE TOP OF QUEUE
         B     DSRT01              RE-SEARCH QUEUE FOR READY WORK
         SPACE 2                                               @YM03564
*/*DS08C: S DSSAVE:SAVE PREVIOUS STATUS */
         SPACE 2                                               @YM03564
DS08C    DC    0H'0'                                           @YM03564
         BAL   RF,DSSAVE           SAVE PREVIOUS TASK'S STATUS @YM03564
         SPACE 2                                               @YM03564
*/*S SETLOCK:OBTAIN THE DISPATCHER LOCK */
         SPACE 2                                               @YM03564
         L     RD,AGSLDISP         LOCK MANAGER'S SPECIAL DISP ENTRY PT
         BALR  RE,RD               UNCOND OBTAIN DISPATCHER LOCK
         L     R6,FLCCVT           CVT POINTER FOR MEMORY DISP @YM03564
         L     R5,CVTCSD-CVT(R6)   CSD ADDR FOR MEMORY DISP    @YM03564
         L     R8,ASCBFWDP         NEXT ASCB TO BE PROCESSED   @YM03564
         SPACE 2                                               @YM03564
*/* P (,DS054) SET UP FOR MEMORY DISPATCHER */
         SPACE 2                                               @YM03564
         B     DS054                                           @YM03564
         TITLE 'IEAVEDS0 - ENTRY IEAPDS2'                      @YM03564
***********************************************************************
*                                                                     *
*        IEAPDS2 - ENTERED FROM THE LOCK MANAGER WHEN SUSPENDING      *
*              A CALLER WHICH HAS REQUESTED A BOUNCE LOCK AND CANNOT  *
*              GET IT.  THE GLOBAL DISPATCHER LOCK IS HELD ON THIS    *
*              ENTRY.                                                 *
*                                                                     *
***********************************************************************
         SPACE 2
*/*IEAPDS2: E ENTRY FROM LOCK MANAGER */
         SPACE 2
IEAPDS2  DC    0H'0'
         SPACE 2
*/* P SET SUPER FRR STACK */
         SPACE 2
         L     R1,PSASSTK          SUPER STACK ADDRESS.
         ST    R1,PSACSTK          SET TO CURRENT.
         SPACE 2
*/* P SET THE DISPATCHER INDICATOR */
         SPACE 2
         OI    PSASUP1,PSADISP     DISPATCHER INDICATOR
         SPACE 2
*/* P ESTABLISH MODULE ADDRESSABILITY */
         SPACE 2
         BALR  R9,R0               ESTABLISH LOCAL ADDRESSABILITY
         USING *,R9
         L     R9,DSBASEAD         DISPATCHER BASE ENTRY
         USING DSBASE,R9           ESTABLISH DISPATCHER ADDRESSABILITY.
         SPACE 2
*/* P ESTABLISH ASCB AND LCCA ADDRESSABILITY */
         SPACE 2
         L     R8,PSAAOLD          CURRENT ASCB ADDRESSABILITY
         L     R7,PSALCCAV         LCCA ADDRESSABILITY
         SPACE
DST004   DC    0H'0'               *** TEST LABEL ***
         B     DSRT01              GO TO SRB RETURN MAINLINE.
         TITLE 'IEAVEDS0 - ENTRY IEAPDS6'
***********************************************************************
*                                                                     *
*        IEAPDS6 - ENTERED FROM END-OF-TASK (EOT).  NO LOCKS ARE HELD *
*              ON THIS ENTRY. THE DISPATCHER CLEARS THE PSATNEW AND   *
*              PSATOLD FIELDS, RESETS THE CPU INTERVAL TIMER TO A HIGH*
*              VALUE, DECREMENTS THE COUNT OF THE NUMBER OF CPU'S IN  *
*              THE ADDRESS SPACE AND CALCULATES THE JOB STEP TIME ON  *
*              THIS ENTRY.                                            *
*                                                                     *
***********************************************************************
         SPACE 2
*/*IEAPDS6: E ENTRY FROM EOT */
         SPACE 2
IEAPDS6  DC    0H'0'
         SPACE 2
*/* P SET SUPER RECOVERY STACK ADDRESS */
         SPACE 2
         L     R1,PSASSTK          SUPER STACK ADDRESS.
         ST    R1,PSACSTK          SET CURRENT TO SUPER STACK ADDRESS.
         SPACE 2
*/* P SET DISPATCHER INDICATOR */
         SPACE 2
         OI    PSASUP1,PSADISP     SET DISPATCHER INDICATOR
         SPACE 2
*/* P ESTABLISH MODULE ADDRESSABILITY */
         SPACE 2
         BALR  R9,R0               ESTABLISH LOCAL ADDRESSABILITY
         USING *,R9
         L     R9,DSBASEAD         DISPATCHER BASE ENTRY
         USING DSBASE,R9           ESTABLISH DISPATCHER ADDRESSABILITY
         SPACE 2
*/* P ESTABLISH ASCB AND LCCA ADDRESSABILITY */
         SPACE 2
         L     R8,PSAAOLD          CURRENT ASCB ADDRESSABILITY
         L     R7,PSALCCAV         LCCA ADDRESSABILITY
         SPACE 2
*/* P CLEAR THE PSATNEW/PSATOLD FIELDS */
         SPACE 2
         SR    R1,R1
         ST    R1,PSATNEW          CLEAR THE PSATNEW AND PSATOLD FIELDS
         ST    R1,PSATOLD          SO STATUS WILL NOT BE STORED.
         SPACE 2
*/* P STORE A HIGH VALUE IN THE CPU INTERVAL TIMER */
         SPACE 2
         SPT   DSHITIME            SET HIGH VALUE INTO CPU INTVL TIMER
*                                  SO TIMER WONT POP FOR NEXT GUY.
         SPACE
DS601    DC    0H'0'
         SPACE 2
*/*DS601: P DECREMENT COUNT OF NUMBER OF CPU'S DISPATCHED IN ADDRESS
*/*SPACE*/
         SPACE 2
         L     R2,ASCBCPUS         *
         LR    R3,R2               *   DECREMENT COUNT OF NUMBER OF
         BCTR  R2,R0               *       CPUS DISPATCHED IN
DST0075  DC    0H'0'               *** TEST LABEL ***
         CS    R3,R2,ASCBCPUS      *       THE ADDRESS SPACE.
         BC    DSCC4,DS601         *
         SPACE
DST008   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* S (,DS01) DSJST:CALCULATE JOB STEP TIME */
         SPACE 2
         BAL   RE,DSJST            GO TO CALCULATE JOB STEP TIME
*   DSJST USES REGISTERS 0,1,2,3 AND 14.
         SPACE
DST009   DC    0H'0'               *** TEST LABEL ***
         B     DS01                RETURN TO MAINLINE.
         TITLE 'IEAVEDS0 - ENTRY IEAPDSRT'
***********************************************************************
*                                                                     *
*        IEAPDSRT - ENTERED ON THE RETURN FROM AN SRB ROUTINE.  THE   *
*              RETURN MUST BE IN SUPERVISOR MODE BUT MAY BE IN A NON  *
*              ZERO KEY.  THE DISPATCHER ON THIS ENTRY GETS THE GLOBAL*
*              DISPATCHER LOCK AND PERFORMS A PARALLEL SERIES OF TESTS*
*              AS AT ENTRY POINT IEA0DS.  THE TESTS AT IEA0DS ARE DONE*
*              WITHOUT THE GLOBAL DISPATCHER LOCK.                    *
*                                                                     *
***********************************************************************
         SPACE 2
*/*IEAPDSRT: E ENTRY FOR SRB RETURN */
         SPACE 2
IEAPDSRT DC    0H'0'
         SPACE 2
*/* S MODESET:GET INTO KEY ZERO */
         SPACE 2
         MODESET  EXTKEY=SUPR      GET INTO KEY ZERO
         SPACE 2
*/*DSLOCK6: S SETLOCK:OBTAIN THE GLOBAL DISPATCHER LOCK */
         SPACE 2
DSLOCK6  DC    0H'0'
         SETLOCK OBTAIN,TYPE=DISP,MODE=UNCOND,RELATED=('ASCB QUEUE/GSPL*
               /LSPL/PSAANEW',IEAVEDS0,(DSLOCK8,DSLOCK11,DSLOCK14,DSLOC*
               K16,DSLOCK17,DSLOCK18,DSLOCK19))
DST010   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* P SET SUPER RECOVERY STACK ADDRESS */
         SPACE 2
         L     R1,PSASSTK          SUPER STACK ADDRESS.
         ST    R1,PSACSTK          SET CURRENT TO SUPER STACK ADDRESS.
         SPACE 2
*/* P SET THE DISPATCHER INDICATOR */
         SPACE 2
         OI    PSASUP1,PSADISP     SET DISPATCHER INDICATOR
         SPACE 2
*/* P ESTABLISH LOCAL ADDRESSABILITY */
         SPACE 2
         BALR  R9,R0               LOCAL ADDRESSABILITY
         USING *,R9
         SPACE
DST0095  DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* P ESTABLISH MODULE ADDRESSABILITY */
         SPACE 2
         L     R9,DSBASEAD         DISPATCHER BASE ENTRY
         USING DSBASE,R9           ESTABLISH DISPATCHER ADDRESSABILITY
         SPACE 2
*/* P ESTABLISH LCCA AND ASCB ADDRESSABILITY */
         SPACE 2
         L     R8,PSAAOLD          ASCB ADDRESSABILITY
         L     R7,PSALCCAV         LCCA ADDRESSABILITY
         SPACE
DST0105  DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* S DSJST:CALCULATE JOB STEP TIME */
         SPACE 2
         BAL   RE,DSJST            GO TO CALCULATE JOB STEP TIME
*   DSJST USES REGISTERS 0,1,2,3 AND 14.
         SPACE 2
*/* P RESET THE SRB MODE BITS */
         SPACE 2
         NI    LCCADSF2,DSXFF-LCCASRBM-LCCAGSRB   RESET SRB BITS
         SPACE 2
*/* P DECREMENT COUNT OF NUMBER OF SRB'S IN THE ADDRESS SPACE */
         SPACE 2
DST011   DC    0H'0'               *** TEST LABEL ***
         LH    R4,ASCBSRBS         *  DECREMENT COUNT
         BCTR  R4,DSI0             *    OF THE NUMBER OF SRB'S
         STH   R4,ASCBSRBS         *    DISPATCHED IN THE ADDRESS SPACE
         SPACE 2
*/* D (NO,DSRT01,YES,) ARE TCB'S STOPPED? */
         SPACE 2
         TM    ASCBFLG1,ASCBSTND   ARE TCB'S STOPPED BECAUSE A STATUS
*                                       STOP SRB'S IS IN PROCESS?
         BZ    DSRT01               NO. CONTINUE.
         SPACE 2
*/* D (YES,DSRT005,NO,) IS COUNT OF SRB'S EQUAL ZERO */
         SPACE 2
*   ENTER FOR TCB'S STOPPED BECAUSE OF STATUS STOP SRB'S
DST012   DC    0H'0'               *** TEST LABEL ***
         LTR   R4,R4               IS COUNT OF SRB'S EQUAL ZERO
         BZ    DSRT005             YES. GO TO SET TCB'S DISPATCHABLE.
DST013   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* D (YES,DSRT01,NO,) ARE THERE MORE LOCAL SRB'S? */
         SPACE 2
         L     R3,ASCBSPL          LOCAL SPL ADDRESS.
         L     R0,DSL4(R3)         ANY NON-Q SRBS?             @YM03564
         O     R0,DSL8(R3)         OR SYSTEM SRBS?             @YM03564
         BNZ   DSRT01              YES. GO TO DISPATCHING TESTS.
         SPACE 2
*/* D (YES,DSRT01,NO,) IS ADDRESS SPACE SWITCH SET UP? */
         SPACE 2
DST014   DC    0H'0'               *** TEST LABEL ***
         C     R8,PSAANEW          TEST FOR ADDRESS SPACE SWITCH SET UP
         BNE   DSRT01              YES. GO TO DISPATCHING TESTS.
DST015   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* P (,DSRT01) STORE ZERO INTO "PSAANEW" - DISP WILL SCAN FROM TOP OF
*/*QUEUE */
         SPACE 2
         SR    R3,R3               NO SWITCH SET UP.  FORCE DISP TO
         ST    R3,PSAANEW               SCAN FROM TOP OF QUEUE.
         B     DSRT01              GO TO DISP TESTS
         SPACE 2
*/*DSRT005: P TURN OFF TCB'S NON-DISPATCH. BIT */
         SPACE 2
DSRT005  DC    0H'0'               ENTER TO SET TCB'S DISPATCHABLE.
         NI    ASCBFLG1,DSXFF-ASCBSTND  TURN OFF TCB'S NON-DISPATCHABLE
         SPACE 2
*/* D (YES,DSRT01,NO,) SET UP TO CONTINUE IN THE ADDRESS SPACE */
         SPACE 2
         C     R8,PSAANEW          ARE WE SET UP TO CONTINUE IN THIS
*                                       ADDRESS SPACE?
         BE    DSRT01              YES. GO TO DISPATCHABLE TESTS
DST016   DC    0H'0'               *** TEST LABEL ***
         LR    R1,R8               ASCB ADDRESS.
         L     RF,DSMS0            MEMORY SWITCH ADDRESS
         SPACE 2
*/* S IEAVEMS0:SWITCH TO THIS ADDRESS SPACE */
         SPACE 2
DSTMEMSW DC    0H'0'               *** TEST LABEL ***
         BALR  RE,RF               GO TO MEMORY SWITCH
         SPACE 2
***********************************************************************
*                                                                     *
*        TEST FOR SPECIAL EXITS                                       *
*                                                                     *
***********************************************************************
         SPACE 2
*/*DSRT01: D (NO,DSRT015,YES,) TEST FOR SPECIAL EXITS */
         SPACE 2
DSRT01   DC    0H'0'
         CLI   LCCADSF1,DSX0       TEST FOR SPECIAL EXITS
         BE    DSRT015             NO. CONTINUE
         SPACE 2
*/*DSLOCK19: S (,DS012) SETLOCK:RELEASE GLOBAL DISPATCHER LOCK */
         SPACE 2
DSLOCK19 DC    0H'0'
*        SETLOCK RELEASE,TYPE=DISP,RELATED=('ASCB QUEUE/GSPL/LSPL/PSAAN*
               EW',IEAVEDS0,(DSLOCK5,DSLOCK6,DSLOCK7,DSLOCK9,DSLOCK10,D*
               SLOCK12,DSLOCK13,DSLOCK22,DSLOCK3))
         L     RB,DSDISPLK         OBTAIN DISP LOCK ADDR       @YM03564
         SLR   RD,RD               ZERO A REGISTER             @YM03564
         ST    RD,DSL0(RB)         FREE LOCK VIA STORE ZEROS   @YM03564
         NI    PSAHLHI+DSL2,X'EF'  INDICATE DISPATCHER LOCK NOT HELD
DST017   DC    0H'0'               *** TEST LABEL ***
         B     DS012               GO TO TEST SPECIFIC EXIT.
         SPACE 2
***********************************************************************
*                                                                     *
*        TEST FOR SRB'S ON THE GSMQ                                   *
*                                                                     *
***********************************************************************
         SPACE 2
*/*DSRT015: D (NONE,DSRT017,YES,DS021A) TEST FOR SRB'S ON THE GSMQ */
         SPACE 2
DSRT015  DC    0H'0'
         L     R6,DSGSMQ           ADDRESS OF START OF GSMQ
         L     R5,0(R6)            FIRST ENTRY
         LTR   R5,R5               TEST FOR SRB'S
         BNZ   DS021A              SRB'S. GO TO DEQUEUE.
*   NO SRB'S ON GSMQ.  FALL THROUGH TO TEST FOR SRB'S ON GSPL.
         SPACE 2
***********************************************************************
*                                                                     *
*        TEST FOR SRB'S ON THE GSPL                                   *
*                                                                     *
***********************************************************************
         SPACE 2
*/*DSRT017: D (YES,DS032,NO,) TEST FOR SRB'S ON THE GSPL */
         SPACE 2
DSRT017  DC    0H'0'
         L     R4,DSGSPL           ADDRESS OF GSPL
         L     R0,DSL4(R4)         ANY NON-Q SRBS?             @YM03564
         O     R0,DSL8(R4)         OR SYSTEM SRBS?             @YM03564
         BNZ   DS032               GO TO DEQUEUE AN SRB UNDER THE GDL
         SPACE 2
***********************************************************************
*                                                                     *
*        TEST FOR SRB'S ON THE LOCAL SMQ                              *
*                                                                     *
***********************************************************************
         SPACE 2
*/*DSRT0173: D (NONE,DSRT0177,YES,DS0411) TEST FOR SRB'S ON THE LSMQ */
         SPACE 2
DSRT0173 DC    0H'0'
         L     R6,DSLSMQ           ADDRESS OF START OF LSMQ
         L     R5,0(R6)            FIRST ENTRY
         LTR   R5,R5               TEST FOR SRB'S
         BNZ   DS0411              SRB'S. GO TO DEQUEUE.
*   NO SRB'S ON LSMQ.  FALL THROUGH TO TEST ADDRESS SPACE SWITCH.
         SPACE 2
***********************************************************************
*                                                                     *
*        TEST FOR ADDRESS SPACE SWITCH.                               *
*                                                                     *
***********************************************************************
         SPACE 2
*/*DSRT0177: D (YES,DS052,NO,) TEST FOR ADDRESS SPACE SWITCH INDICATED
*/**/
         SPACE 2
DSRT0177 DC    0H'0'
         C     R8,PSAANEW          DOES OLD ASCB EQUAL NEW ASCB
         BNE   DS052               NO. GO TO MEMORY DISPATCHER
         SPACE 2
***********************************************************************
*                                                                     *
*  TEST FOR SRB'S ON THE LSPL                                         *
*                                                                     *
***********************************************************************
         SPACE 2
*/* D (YES,DS062,NO,) TEST FOR SRB'S ON THE LSPL */
         SPACE 2
DST022   DC    0H'0'               *** TEST LABEL ***
         L     R4,ASCBSPL
         L     R0,DSL4(R4)         ANY NON-Q SRBS?             @YM03564
         O     R0,DSL8(R4)         OR SYSTEM SRBS?             @YM03564
         BNZ   DS062               NOT ZERO. GO TO DEQUEUE SRB'S
         SPACE 2                                               @YM03564
*/* D (YES,DSLOCK8,NO,) ANY READY TCB'S IN ASCB? */            @ZA16871
         SPACE 2                                               @YM03564
         L     RD,ASCBTCBS         GET NUMBER OF TCBS          @YM03564
         C     RD,ASCBCPUS         ANY READY WORK IN MEMORY    @YM03564
         BH    DSLOCK8             YES. GO TRY TO DISPATCH TCB @ZA16871
         SPACE 2
*/* D (YES,,NO,DS052) ANY ASYNCH EXITS TO DISPATCH? */         @ZA16871
         SPACE 2                                               @ZA16871
         TM    ASCBFLG1,ASCBS3S    TEST FOR ASYNCH EXITS       @ZA16871
         BZ    DS052               NONE. NO WORK IN THIS ASCB  @ZA16871
         SPACE 2                                               @ZA16871
*/*DSLOCK8: S SETLOCK: RELEASE THE GLOBAL DISPATCHER LOCK */   @ZA16871
         SPACE 2
DSLOCK8  DC    0H'0'
*        SETLOCK RELEASE,TYPE=DISP,RELATED=('ASCB QUEUE/GSPL/LSPL/PSAAN*
               EW',IEAVEDS0,(DSLOCK5,DSLOCK6,DSLOCK9,DSLOCK10,DSLOCK12)*
               )
         L     RB,DSDISPLK         OBTAIN DISP LOCK ADDR       @YM03564
         SLR   RD,RD               ZERO A REGISTER             @YM03564
         ST    RD,DSL0(RB)         FREE LOCK VIA STORE ZEROS   @YM03564
         NI    PSAHLHI+DSL2,X'EF'  INDICATE DISPATCHER LOCK NOT HELD
         SPACE 2                                               @ZA16871
*/* D (YES,DSRT02,NO,) TEST FOR LOCAL LOCK AVAILABLE */        @ZA16871
         SPACE 2
DST023   DC    0H'0'               *** TEST LABEL ***          @ZA16871
         L     R1,ASCBLOCK         CURRENT LOCKWORD VALUE      @ZA16871
         LH    R3,PSACPULA         LOGICAL CPU ADDRESS.        @ZA16871
         LTR   R1,R1               IS LOCK AVAILABLE?          @ZA16871
         BZ    DSRT02              LOCK IS AVAILABLE, OBTAIN IT@ZA16871
         SPACE 2                                               @ZA16871
*/* D (YES,DSRT025,NO,) TEST FOR LOCAL SUPERVISOR */           @ZA16871
         SPACE 2                                               @ZA16871
         BM    DSRT025             INTERRUPT ID, GO OBTAIN IT  @ZA16871
         SPACE 2                                               @ZA16871
*/* D (YES,DS081,NO,DS08B) WAS LOCAL LOCK HELD BY THIS CPU? */ @ZA16871
         SPACE 2                                               @ZA16871
         CR    R1,R3               LOCAL LOCK HELD BY THIS CPU?@ZA16871
         BE    DS081               YES. GO DISPATCH LOCAL      @ZA16871
*                                    SUPERVISOR ROUTINE.       @ZA16871
         B     DS08B               LOCK IS NOT AVAILABLE. GO   @ZA16871
*                                    TEST WAIT TASK RECURSION. @ZA16871
         SPACE 2                                               @ZA16871
*/*DSRT02: D (YES,DS09,NO,DS08B) OBTAIN LCL LOCK SUCCESSFUL? */@ZA16871
         SPACE 2                                               @ZA16871
DSRT02   DC    0H'0'                                           @ZA16871
         CS    R1,R3,ASCBLOCK      OBTAIN FREE LOCK WITH CPUID @ZA16871
         BC    DSCC7,DS08B         LOCK WAS NOT AVAILABLE. GO  @ZA16871
*                                    TEST WAIT TASK RECURSION. @ZA16871
         OI    PSAHLHI+DSL3,DSLLHI INDICATE LCL LOCK NOW OWNED @ZA16871
         B     DS09                GO TO TASK DISPATCHER       @ZA16871
         SPACE 2                                               @ZA16871
*/*DSRT025: D (YES,DS071,NO,DS08B) INTRUPT ID STILL IN LOCK? */@ZA16871
         SPACE 2                                               @ZA16871
DSRT025  DC    0H'0'                                           @ZA16871
         CS    R1,R3,ASCBLOCK      COMPARE ID : SWAP IN CPULA  @ZA16871
         BC    DSCC8,DS071         SUCCESS. GO RESTROR LOCAL   @ZA16871
*                                      SUPERVISOR.             @ZA16871
         B     DS08B               GO TEST WAIT TASK RECURSION @ZA16871
         TITLE 'IEAVEDS0 - SPECIAL EXITS'
***********************************************************************
*                                                                     *
*        THIS SECTION TESTS FOR SPECIAL EXITS.                        *
*                                                                     *
***********************************************************************
         SPACE 2
*/*DS011: S DSSAVE:SAVE STATUS OF PREVIOUS TASK */
         SPACE 2
DS011    DC    0H'0'
         BAL   RF,DSSAVE           SAVE STATUS OF PREVIOUS TASK.
*   DSSAVE USES REGISTERS 0,1,2,3,14 AND 15.
         SPACE 2
***********************************************************************
*                                                                     *
*        TEST FOR ACR                                                 *
*                                                                     *
***********************************************************************
         SPACE 2
*/*DS012: D (NO,DS013,YES,DSTCLRTM) TEST FOR ACR */
         SPACE 2
DS012    DC    0H'0'
         TM    LCCADSF1,LCCAACR    TEST FOR ACR
         BZ    DS013               NO. GO TO TRY NEXT SPECIAL EXIT
         SPACE 2
*/*DSTCLRTM: R CALLRTM - EXIT TO ACR */
         SPACE 2
DSTCLRTM DC    0H'0'
         NI    PSASUP1,DSXFF-PSADISP    RESET DISPATCHER INDICATOR.
         CALLRTM   TYPE=ACRDISP    GO TO ACR PROCESSOR.
*  NOTE - ACR DOES NOT RETURN HERE - CONTROL WILL COME BACK
*        EVENTUALLY TO IEA0DS.
         SPACE 2
***********************************************************************
*                                                                     *
*        TEST FOR VARY CPU PROCESSING                                 *
*                                                                     *
***********************************************************************
         SPACE 2
*/*DS013: D (NO,DS014,YES,) TEST FOR VARY CPU */
         SPACE 2
DS013    DC    0H'0'
         TM    LCCADSF1,LCCAVCPU   TEST FOR VARY CPU
         BZ    DS014               NO. GO TO TRY NEXT SPECIAL EXIT
DST025   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/*DSLOCK20: S SETLOCK:OBTAIN GLOBAL DISPATCHER LOCK */
         SPACE 2
DSLOCK20 DC    0H'0'
*        SETLOCK OBTAIN,TYPE=DISP,MODE=UNCOND,RELATED=(PSAANEW,IEAVEDS0*
               ,(DSLOCK21))
         L     RD,AGSLDISP         OBTAIN DISPATCHER SPECIAL ENTRY PT
         BALR  RE,RD               LOCK MANAGER'S SPECIAL DISP ENTRY
DST025A  DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* P TRANSFER TO MASTER'S ADDRESS SPACE */
         SPACE 2
         L     R8,DSMASCB          MASTER'S ASCB ADDRESS
         ST    R8,PSAAOLD          SET PSAAOLD
         ST    R8,PSAANEW          SET PSAANEW
         LCTL  R1,R1,PSASTOR       MASTER'S SEG TABLE ORIGIN REG.
         SPACE 2
*/*DSLOCK21: S SETLOCK:RELEASE GLOBAL DISPATCHER LOCK */
         SPACE 2
DSLOCK21 DC    0H'0'
*        SETLOCK RELEASE,TYPE=DISP,RELATED=(PSAANEW,IEAVEDS0,(DSLOCK20)*
               )
         L     RB,DSDISPLK         OBTAIN DISP LOCK ADDR       @YM03564
         SLR   RD,RD               ZERO A REGISTER             @YM03564
         ST    RD,DSL0(RB)         FREE LOCK VIA STORE ZEROS   @YM03564
         NI    PSAHLHI+DSL2,X'EF'  INDICATE DISPATCHER LOCK NOT HELD
DST025B  DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* P RESET THE DISPATCHER INDICATOR */
         SPACE 2
         NI    PSASUP1,DSXFF-PSADISP    RESET DISPATCHER INDICATOR.
         SPACE 2
*/* R EXIT TO VARY CPU PROCESSOR */
         SPACE 2
         L     RB,FLCCVT               LOCATE THE CVT
         USING CVT,RB
         L     RF,CVTQUIT          VARY CPU ENTRY POINT
         DROP  RB
         BR    RF                  EXIT.
         SPACE 2
***********************************************************************
*                                                                     *
*        TEST FOR DSS IN PROCESS                                      *
*                                                                     *
***********************************************************************
         SPACE 2
*/*DS014: D (NO,DS015,YES,) TEST FOR DSS IN PROCESS */
         SPACE 2
DS014    DC    0H'0'
         TM    LCCADSF1,LCCADSS    TEST FOR DSS IN PROCESS
         BZ    DS015               NO. GO TO TRY NEXT SPECIAL EXIT.
         SPACE 2
*/*DSLOCK7: S SETLOCK:OBTAIN GLOBAL DISPATCHER LOCK */
         SPACE 2
DSLOCK7  DC    0H'0'
*        SETLOCK OBTAIN,TYPE=DISP,MODE=UNCOND,RELATED=('ASCB QUEUE/GSPL*
               /LSPL/PSAANEW',IEAVEDS0,(DSLOCK11,DSLOCK14,DSLOCK16,DSLO*
               CK17,DSLOCK18,DSLOCK19))
         L     RD,AGSLDISP         OBTAIN DISPATCHER SPECIAL ENTRY PT
         BALR  RE,RD               LOCK MANAGER'S SPECIAL DISP ENTRY
DST026   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* S IEAVEMS0:SWITCH TO MASTER'S ADDRESS SPACE */
         SPACE 2
         L     R1,DSMASCB          MASTER'S ASCB ADDRESS
         L     RF,DSMS0            MEMORY SWITCH ADDRESS
         BALR  RE,RF               SWITCH TO MASTER'S ADDRESS SPACE
DST027   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* P (,DSRT015) RESET THE DSS IN PROCESS BIT */
         SPACE 2
         NI    LCCADSF1,DSXFF-LCCADSS   TURN OFF DSS IN PROGRESS BIT
         B     DSRT015             GO TO DISP. TESTS UNDER THE GDL LOCK
         SPACE 2
***********************************************************************
*                                                                     *
*        TEST FOR TIMER RECOVERY                                      *
*                                                                     *
***********************************************************************
         SPACE 2
*/*DS015: D (NO,DS016,YES,) TEST FOR TIMER RECOVERY */
         SPACE 2
DS015    DC    0H'0'
         TM    LCCADSF1,LCCATIMR   TEST FOR TIMER RECOVERY.
         BZ    DS016               NO. GO TO TRY NEXT SPECIAL EXIT.
         SPACE 2
*/* R EXIT TO TIMER RECOVERY */
         SPACE 2
DST028   DC    0H'0'               *** TEST LABEL ***
         NI    PSASUP1,DSXFF-PSADISP    RESET DISPATCHER INDICATOR.
         L     RF,DSRSPN           TIMER RECOVERY ROUTINE ENTRY PT.
         BR    RF                  EXIT TO TIMER RECOVERY.
         SPACE 2
*/*DS016: R ADDITIONAL SPECIAL EXITS GO HERE */
         SPACE 2
DS016    DC    0H'0'
*
*  PLACE ADDITIONAL SPECIAL EXITS TESTS HERE
*
         MVI   LCCADSF1,DSX0       CLEAR THE SPECIAL EXITS INDICATOR
         B     DS01                GO FIND SOME WORK.
         TITLE 'IEAVEDS0 - GLOBAL SMQ'
***********************************************************************
*                                                                     *
*  THIS SECTION IS ENTERED WHEN THERE ARE FOUND TO BE SRB'S ON        *
*        THE GLOBAL SERVICE MANAGER QUEUE                             *
*                                                                     *
*  ON ENTRY :                                                         *
*        R5 - FIRST SRB ADDRESS  (CONTENTS OF GSMQ HEADER)            *
*        R6 - ADDRESS OF GSMQ                                         *
*                                                                     *
***********************************************************************
         SPACE 2
*/*DS021: S DSSAVE:SAVE STATUS OF PREVIOUS TASK */
         SPACE 2
DS021    DC    0H'0'
         BAL   RF,DSSAVE           GO TO SAVE PREVIOUS TASK'S STATUS.
*   DSSAVE USES REGISTERS 0,1,2,3,14 AND 15.
         SPACE 2
*/*DSLOCK9: S SETLOCK: OBTAIN GLOBAL DISPATCHER LOCK */
         SPACE 2
DSLOCK9  DC    0H'0'
*        SETLOCK OBTAIN,TYPE=DISP,MODE=UNCOND,RELATED=('ASCB QUEUE/GSPL*
               /LSPL/PSAANEW',IEAVEDS0,(DSLOCK8,DSLOCK11,DSLOCK14,DSLOC*
               K16,DSLOCK17,DSLOCK18,DSLOCK19))
         L     RD,AGSLDISP         OBTAIN DISPATCHER SPECIAL ENTRY PT
         BALR  RE,RD               LOCK MANAGER'S SPECIAL DISP ENTRY
         SPACE 2
*/*DS021A: P CLEAR REG FOR COMPARE AND SWAP */
         SPACE 2
DS021A   DC    0H'0'
         SR    R3,R3               PREPARE TO STORE ZERO INTO GSMQ HDR.
         SPACE 2
*/*DS021B: P (OK,DS021C,ZERO,DSRT017,ADD,DS021B) COMPARE AND SWAP GSMQ
*/**/
         SPACE 2
DS021B   DC    0H'0'
         CS    R5,R3,DSL0(R6)      COMPARE & SWAP TO PICK UP SRB CHAIN.
         BC    DSCC8,DS021C        OK. CONTINUE.
DST029   DC    0H'0'               *** TEST LABEL ***
         LTR   R5,R5               TEST FOR SRB PICKED UP IN C&S.
         BNZ   DS021B              YES. SCHEDULE HAS ADDED ONE. GO TO
*                                       DEQUEUE AGAIN.
DST030   DC    0H'0'               *** TEST LABEL ***
         B     DSRT017             NO. ANOTHER CPU HAS DEQUEUED THEM.
*                                        RETURN TO MAINLINE.
         SPACE
***********************************************************************
*                                                                     *
*  THE SRB'S HAVE BEEN DEQUEUED FROM THE GSMQ PREPARE TO MOVE THEM    *
*        TO THE GSPL AND DISPATCH THEM.                               *
*                                                                     *
*  SET UP TO GO TO GLOBAL SCHEDULE                                    *
*        R3 -  RETURN ADDRESS                                         *
*        R4 -  ENTRY POINT ADDRESS                                    *
*        R5 -  CONTENTS OF GSMQ (FIRST SRB ADDRESS)                   *
*        R7 -  LCCA ADDRESS                                           *
*        R8 -  ASCB ADDRESS                                           *
*        R9 -  DISPATCHER BASE ADDRESS                                *
*                                                                     *
***********************************************************************
         SPACE 2
*/*DS021C: S IEAVESC1:GLOBAL SCHEDULE */
         SPACE 2
DS021C   DC    0H'0'
         ST    R5,LCCASMQJ             JOURNAL SMQ ENTRY
         L     R4,DSVESC1          GLOBAL SCHEDULE ADDRESS
         BALR  R3,R4               GO TO GLOBAL SCHEDULE
DST031   DC    0H'0'               *** TEST LABEL ***
*
*        REGISTERS 7,8 AND 9 ARE RETURNED FROM GLOBAL SCHEDULE
*
         SPACE 2
*/* P (,DS032) SET GSPL ADDRESS */
         SPACE 2
         L     R4,DSGSPL           SET UP GSPL ADDRESS IN REG 4.
         SPACE
         B     DS032               GO TO DEQUEUE AN SRB FROM THE SPL.
         TITLE 'IEAVEDS0 - GLOBAL SPL'
***********************************************************************
*                                                                     *
*  THIS SECTION IS ENTERED WHEN THERE ARE SRB'S ON THE GLOBAL         *
*        SERVICE PRIORITY LIST.                                       *
*        R4 - CONTAINS THE ADDRESS OF THE GSPL.                       *
*                                                                     *
***********************************************************************
         SPACE 2
*/*DS031: S DSSAVE:SAVE PREVIOUS TASK'S STATUS */
         SPACE 2
DS031    DC    0H'0'
         BAL   RF,DSSAVE           GO TO SAVE PREVIOUS TASKS STATUS.
*   DSSAVE USES REGISTERS 0,1,2,3,14 AND 15.
         SPACE
*/*DSLOCK10: S SETLOCK:OBTAIN THE GLOBAL DISPATCHER LOCK */
         SPACE 2
DSLOCK10 DC    0H'0'
*        SETLOCK OBTAIN,TYPE=DISP,MODE=UNCOND,RELATED=('ASCB QUEUE/GSPL*
               /LSPL/PSAANEW',IEAVEDS0,(DSLOCK8,DSLOCK11,DSLOCK14,DSLOC*
               K16,DSLOCK17,DSLOCK18,DSLOCK19))
         L     RD,AGSLDISP         OBTAIN DISPATCHER SPECIAL ENTRY PT
         BALR  RE,RD               LOCK MANAGER'S SPECIAL DISP ENTRY
         SPACE
*
*  DEQUEUE SRB FROM THE GLOBAL SERVICE PRIORITY LIST
*
         SPACE 2
*/*DS032: P SET UP TO INDEX THROUGH SRB'S */
         SPACE 2
DS032    DC    0H'0'
         L     R3,FLCCVT           CVT ADDRESS
         USING CVTMAP,R3
         L     R6,CVTCSD           CSD ADDRESS
         DROP  R3                  DROP CVT ADDRESSING
         USING CSD,R6
         LA    R3,GSPLSIZE(R4)     END OF GSPL
         SPACE 2
*/*DS0321: P GET SRB ADDRESS */
         SPACE 2
DS0321   DC    0H'0'
         L     R2,DSL0(R4)         SRB ADDRESS
         SPACE 2
*/*DS0322: D (YES,DS03225,NO,) IS THERE AN SRB? */
         SPACE 2
DS0322   DC    0H'0'               ENTER FOR LOOP.
         LTR   R2,R2               SRB ?
         BNZ   DS03225             YES. CONTINUE.
         SPACE 2
*/* D (NO,DS0321,YES,DSRT0173) END OF SPL? */
         SPACE 2
DST032   DC    0H'0'               *** TEST LABEL ***
         LA    R4,DSL8(R4)         GET NEXT SPL ENTRY ADDRESS
         CLR   R4,R3               FINISHED ?
         BNE   DS0321              NO. GO TO TEST FOR SRB'S AT THIS LVL
DST033   DC    0H'0'               *** TEST LABEL ***
         B     DSRT0173            DONE. NO SRB'S FOUND.
         SPACE 2
*/*DS03225: P GET SRB'S ASCB ADDRESS */
         SPACE 2
DS03225  DC    0H'0'
         USING SRBSECT,R2          SRB ADDRESSABILITY.
         L     R5,SRBASCB          SRB'S ASCB ADDRESS.
         DROP  R8                  TEMP DROP 8 AS ASCB ADDRESS REG.
         USING ASCB,R5             TEMP SET ASCB ADDRESSABILITY TO 5
         SPACE 2
*/* D (NO,DS0323,YES,) IS SYSTEM NON DISPATCH? */
         SPACE 2
         TM    CSDSCFL1,CSDSYSND   IS SYSTEM NON-DISPATCHABLE.
         BZ    DS0323              NO. GO AROUND EXEMPT CHECK
DST034   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* D (NO,DS0329,YES,DS0323) IS ADDRESS SPACE EXEMPT? */
         SPACE 2
         TM    ASCBFLG2,ASCBXMPT   YES. TEST IF ADDRESS SPACE IS EXEMPT
         BZ    DS0329              NOT EXEMPT. GO TO GET NEXT SRB.
         SPACE 2
*/*DS0323: D (YES,DS0329,NO,) IS ADDR SPACE NON DISPATCH? */
         SPACE 2
DS0323   DC    0H'0'               ENTER FOR SYSTEM DISPATCHABLE.
         CLI   ASCBDSP1,DSX0       IS THIS ADDRESS SPACE NON-DISPATCH.
         BNE   DS0329              YES. GO TO GET NEXT SRB.
         SPACE 2
*/* D (YES,DS0329,NO,) ARE ALL SRB'S STOPPED IN ASCB? */
         SPACE 2
         TM    ASCBFLG2,ASCBSNQS   ARE ALL SRB'S STOPPED IN ASCB?
         BO    DS0329              YES. GO TO GET NEXT SRB.
         SPACE 2
*/* D (YES,DS0324,NO,) IS SRB NON QUIESC? */
         SPACE 2
         CLI   SRBPRIOR,SRBPNONQ   IS THIS SRB NON-QUIESCEABLE.
         BE    DS0324              YES. GO AROUND SYSTEM SRB CHECKS.
         SPACE 2
*/* D (YES,DS0329,NO,DS0324) STOP QUIES. SRB'S IN ASCB? */
         SPACE 2
         LH    R1,ASCBSSRB         STOP QUIESCEABLE SRB'S IN THIS ASCB?
         LTR   R1,R1               TEST COUNT GTR THAN ZERO.
         BNZ   DS0329              YES. GO TO GET NEXT SRB.
         SPACE 2
*/*DS0324: D (NO,DS0325,YES,) IS CPU AFFIN SPEC? */
         SPACE 2
DS0324   DC    0H'0'
         LH    RB,SRBCPAFF         SRB'S CPU AFFINITY MASK.
         LTR   RB,RB               ANY?
         BZ    DS0325              NOT SPECIFIED. BYPASS AFFINITY CHECK
DST038   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* P GET CPU'S AFFINITY MASK */
         SPACE 2
         L     RE,PSAPCCAV         PCCA ADDRESS
         USING PCCA,RE
         LH    RF,PCCACAFM         CPU'S MASK.
         DROP  RE
         SPACE 2
*/* D (NO,DS032A,YES,DS0325) CAN SRB RUN ON THIS CPU? */
         SPACE 2
         NR    RF,RB               CAN SRB RUN ON THIS CPU?
         BC    DSCC8,DS032A        NO. GO TO TEST FOR ANY CPU.
         SPACE 2
*/*DS0325: D (YES,DS03251,NO,) IS THIS TOP SRB ON SPL? */
         SPACE 2
DS0325   DC    0H'0'
         C     R2,DSL0(R4)         IS THIS TOP SRB ON SPL?
         BE    DS03251             YES. CONTINUE.
DST039   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* P (,DS032F) SET RETURN TO GLOBAL SRB DISP */
         SPACE 2
         LA    RD,DS033            SET RTN TO GLBL SRB DISP.
         B     DS032F              GO TO DEQ SRB NOT TOP.
         SPACE 2
*/*DS03251: P CHAIN NEXT SRB TO SPL */
         SPACE 2
DS03251  DC    0H'0'               ENTER FOR DEQ OF TOP SRB.
         L     RC,SRBFLNK          FORWARD CHAIN POINTER.
         ST    RC,DSL0(R4)         RE-CHAIN TO SPL.
         SPACE 2
*/* D (NO,DS0326,YES,) IS THE LAST SRB? */
         SPACE 2
         LTR   RC,RC               IS THIS THE ONLY (LAST) SRB?
         BNZ   DS0326              NO. GO AROUND CLEARING LAST PTR.
DST040   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* P (,DS033) CLEAR POINTER TO LAST SRB */
         SPACE 2
         ST    RC,DSL4(R4)         CLEAR PTR TO LAST SRB.
         B     DS033               GO TO GLOBAL SRB DISPATCHER
         SPACE 2
*/*DS0326: P (,DS033) CLEAR SRB CHAIN ADDRESS */
         SPACE 2
DS0326   DC    0H'0'               ENTER FOR LAST SRB ON SPL.
         SR    RE,RE
         ST    RE,SRBFLNK          CLEAR SRB CHAIN ADDRESS.
         B     DS033               GO TO GLOBAL SRB DISPATCHER.
         SPACE 4
*/*DS0329: D (YES,DS03290,NO,) IS THIS THE TOP SRB? */
         SPACE 2
DS0329   DC    0H'0'               ENTER TO DEQ SRB & SCHEDULE LOCALLY
         C     R2,DSL0(R4)         IS THIS THE TOP SRB ON SPL?
         BE    DS03290             YES. CONTINUE.
DST041   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* P (,DS032F) SET RETURN TO DS03291 */
         SPACE 2
         LA    RD,DS03291          NO. SET RTN.
         B     DS032F              GO TO DEQ SRB NOT ON TOP OF SPL.
         SPACE 2
*/*DS03290: P CHAIN NEXT SRB TO SPL */
         SPACE 2
DS03290  DC    0H'0'               ENTER FOR TOP SRB ON SPL.
         L     RC,SRBFLNK          FORWARD CHAIN POINTER.
         ST    RC,DSL0(R4)         RE-CHAIN TO SPL.
         SPACE 2
*/* D (NO,DS03291,YES,) IS THIS THE ONLY SRB? */
         SPACE 2
         LTR   RC,RC               IS THIS THE ONLY (LAST) SRB?
         BNZ   DS03291             NO. GO AROUND CLEARING LAST POINTER.
DST042   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* P CLEAR SPL POINTER TO LAST SRB */
         SPACE 2
         ST    RC,DSL4(R4)         DEQ'D LAST SRB. CLEAR SPL PTR TO LAS
         SPACE 2
*/*DS03291: S SCHEDULE:SCHEDULE SRB TO LSMQ */
         SPACE 2
DS03291  DC    0H'0'               ENTER FOR SCHEDULING SRB LOCALLY.
         LR    R1,R2               THIS SRB ADDRESS.
         SCHEDULE SRB=(1),SCOPE=LOCAL  SCHEDULE SRB TO LOCAL QUEUE.
         SPACE 2
*/* P (,DS0322) GET NEXT SRB */
         SPACE 2
         LR    R2,RC               GET NEXT SRB.
         B     DS0322              GO TO SEE IF THIS SRB WILL RUN.
         SPACE 4
*/*DS032A: P GET SYSTEM WIDE CPU AFFINITY MASK */
         SPACE 2
DS032A   DC    0H'0'               ENTER FOR SRB AFFINITY CHECK.
         LH    RF,CSDCPUAL         SYSTEM WIDE CPU AFFINITY MASK.
         SPACE 2
*/* D (NO,DS0325,YES,) CAN SRB RUN ON ANY CPU? */
         SPACE 2
         NR    RF,RB               CAN SRB RUN ON ANY CPU.
         BC    DSCC8,DS0325        NO. GO TO DISPATCH AND ABEND.
DST043   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* P (,DS0322) GET NEXT SRB */
         SPACE 2
         L     R2,SRBFLNK          SRB CAN RUN ON OTHER CPU.  GET NEXT.
         B     DS0322              GO TO CHECK NEXT SRB DISPATCHIBILITY
         SPACE 4
*
*  ENTER FOR NOT TOP SRB ON SPL QUEUE.
*
         SPACE 2
*/*DS032F: P GET TOP SRB */
         SPACE 2
DS032F   DC    0H'0'
         L     RE,DSL0(R4)         TOP SRB.
         SPACE 2
*/*DS032F1: P GET NEXT SRB */
         SPACE 2
DS032F1  DC    0H'0'
         L     RF,SRBFLNK-SRBSECT(RE)  NEXT SRB.
         SPACE 2
*/* D (YES,DS032F2,NO,) IS IT THE CURRENT SRB? */
         SPACE 2
         CLR   RF,R2               IS IT CURRENT?
         BE    DS032F2             YES. RE HAS ADDRESS OF PREVIOUS.
DST044   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* P (,DS032F1) SET UP TO SCAN NEXT SRB */
         SPACE 2
         LR    RE,RF               NO. SET UP TO SCAN NEXT SRB.
         B     DS032F1             GO TO GET NEXT SRB.
         SPACE 2
*/*DS032F2: P CHAIN NEXT SRB TO PREVIOUS */
         SPACE 2
DS032F2  DC    0H'0'
         L     RC,SRBFLNK          NEXT SRB FROM CURRENT.
         ST    RC,SRBFLNK-SRBSECT(RE)  CHAIN UP TO PREVIOUS
         SPACE 2
*/* D (NO,DST045A,YES,) WAS SRB LAST ON QUEUE? */
         SPACE 2
         LTR   RC,RC               WAS CURRENT SRB LAST ON QUEUE?
DST044A  DC    0H'0'               *** TEST LABEL ***
         BCR   DSCC7,RD            NO. DONE. GO BACK TO CALLER
DST045   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* P STORE PREVIOUS SRB ADDRESS INTO SPL */
         SPACE 2
         ST    RE,DSL4(R4)         YES. STORE PREVIOUS SRB ADDRESS
*                                       INTO SPL.
         SPACE 2
*/*DST045A: R RETURN TO CALLER */
         SPACE 2
DST045A  DC    0H'0'               *** TEST LABEL ***
         BR    RD                  GO BACK TO CALLER
         DROP  R5
         USING ASCB,R8             RE-ESTABLISH ASCB ADDRESSABILITY
         TITLE 'IEAVEDS0 - GLOBAL SRB DISPATCHER'
***********************************************************************
*                                                                     *
*  GLOBAL SRB DISPATCHER                                              *
*        R2 HAS SRB ADDRESS   R5 HAS ASCB ADDRESS                     *
*                                                                     *
***********************************************************************
         SPACE 2
*/*DS033: P SET SRB MODE INDICATORS */
         SPACE 2
         ENTRY DSSRBRTN                                        @Z40FPXJ
DSSRBRTN DS    0H                                              @Z40FPXJ
DS033    DC    0H'0'
         OI    LCCADSF2,LCCASRBM+LCCAGSRB+LCCADSRW SET SRBMODE AND
*                                  GLOBAL SRB MODE INDICATORS
         ST    R2,LCCASPLJ             JOURNAL GLOBAL ENTRY
         SPACE 2
*/* P RELOAD ASCB ADDRESS FOR ADDRESSABILITY */
         SPACE 2
         LR    R8,R5               RELOAD ASCB FOR ADDRESSABILITY
         SPACE 2
*/* P SET PSAAOLD TO ADDRESS OF ASCB IN SRB */
         SPACE 2
         ST    R5,PSAAOLD          SET "CURRENT" ASCB ADDRESS
         SPACE 2
*/* P LOAD CONTROL REGISTER WITH NEW ASCB'S STOR */
         SPACE 2
         LCTL  R1,R1,ASCBSTOR      LOAD FOR NEW ADDRESS SPACE ADDRESS-
*                                       ABILITY                @YM06905
         SPACE 2
*/*DS0331: P INCREMENT COUNT OF SRB'S IN ADDR. SPACE */
         SPACE 2
DS0331   DC    0H'0'
         LH    R3,ASCBSRBS         *    INCREMENT COUNT OF THE
         LA    R3,DSI1(R3)         *         NUMBER OF SRB'S DISPATCHED
         STH   R3,ASCBSRBS         *         IN THIS ADDRESS SPACE.
DST046   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* P BUILD MODEL PSW IN LOW CORE */
         SPACE 2
         L     R4,DSSRBPSW         MODEL PSW
         ST    R4,PSAPSWSV         MOVE TO LOW CORE.
         SPACE
         IC    R4,ASCBSRBM         GET MODEL PSW BYTE 0 FROM   @G64RP2R
         STC   R4,PSAPSWSV         ASCB IN ORDER TO PROPAGATE  @G64RP2R
*                                  PER TO THE SRB PROCESS      @G64RP2R
         SPACE
         OC    PSAPSWSV+DSL1(DSL1),SRBPKF    SET PROTECT KEY AS
*                                  SPECIFIED IN THE SRB.
         SPACE
         L     RF,SRBEP            *
         LA    RF,DSL0(RF)         *   SET PSW ENTRY ADDRESS
         ST    RF,PSAPSWSV+DSL4    *
         SPACE 2
*/* P MOVE SRB AFFIN, PURGE ASID/TCB ADDRS TO LCCA */
         SPACE 2
         MVC   LCCASRBF(DSL8),SRBFLC   MOVE SRB AFFINITY, PURGE ASID
*                                       AND PURGE TCB ADDR TO LCCA.
         SPACE 2
*/* P PURGE THE NORMAL STACK */
         SPACE 2
         SETFRR F,WRKREGS=(R3,R4)  PURGE THE NORMAL STACK
         SPACE 2
*/* P RESET THE DISPATCHER INDICATOR */
         SPACE 2
         NI    PSASUP1,DSXFF-PSADISP    RESET DISPATCHER INDICATOR
         SPACE 2
*/* P ZERO SPL JOURNAL WORD */
         SPACE 2
         SR    R4,R4                   ZERO A REGISTER
         ST    R4,LCCASPLJ             ZERO THE SPL JOURNAL WORD
         SPACE 2
*/* P RESET SUPER STACK TO NORMAL */
         SPACE 2
LISRBPSW DC    0H'0'
         L     R3,PSANSTK              OBTAIN NORMAL STACK ADDR
         ST    R3,PSACSTK          SET CURRENT STACK TO NORMAL ADDR.
         SPACE 2
*/* P SET R0 = SRB ADDRESS, R1 = PARM ADDRESS AND R14 = RETURN ADDR */
         SPACE 2
         LR    R0,R2               SRB ADDRESS
         L     R1,SRBPARM          PARAMETER ADDRESS
         SPACE 2
*/* P GET ADDRESSABILITY TO CVT */
         SPACE 2
         L     RB,FLCCVT           CVT ADDRESSABILITY TO GET
         USING CVT,RB                   CVT TRACE ENTRY
         SPACE 2
*/* D (NO,DS03315,YES,) DOES SRB HAVE AFFINITY? */
         SPACE 2
         LH    RA,SRBCPAFF         SRB'S CPU AFFINITY MASK.
         LTR   RA,RA               TEST FOR AFFINITY SPECIFIED.
         BZ    DS03315             NO. GO TO TEST TRACE ACTIVE.
         SPACE 2
*/* P GET CPU'S AFFINITY MASK FROM THE PCCA */
         SPACE 2
         L     R5,PSAPCCAV         PCCA'S ADDRESS FROM PSA.
         USING PCCA,R5             ESTABLISH PCCA ADDRESSABILITY.
         LH    R5,PCCACAFM         CPU'S AFFINITY MASK.
         DROP  R5                  DROP PCCA ADDRESSABILITY.
         SPACE 2
*/* D (YES,DS03315,NO,) CAN SRB RUN ON THIS CPU? */
         SPACE 2
         NR    R5,RA               TEST SRB MASK AGAINST CPU MASK.
         BNZ   DS03315             MATCH. SRB CAN RUN ON THIS CPU.
         SPACE 2
*/* P SET REG 1 TO 072 ABEND CODE */
         SPACE 2
         L     R1,DSABAFFN         LOAD REGISTER 1 WITH 072 ABEND CODE
         SPACE 2
*/* P SET SRB'S PSW TO POINT TO SVC ABEND INSTRUCTION IN CVT */
         SPACE 2
         LA    R5,CVTQABST         ADDRESS OF SVC D INST IN CVT.
         ST    R5,PSAPSWSV+DSL4    SET PSW TO GO TO SVC D.
         SPACE 2
*/* P REMOVE SRB'S AFFN TO OFFLINE CPU IN LCCA FOR ABEND */    @ZA25275
         SPACE 2                                               @ZA25275
         SLR   R5,R5               ZERO A REGISTER.            @ZA25275
         STH   R5,LCCASRBF         ZERO SRB'S INVALID AFFN     @ZA25275
*                                       SET IN LCCA.           @ZA25275
         SPACE 2                                               @ZA25275
*/*DS03315: D (NO,DS0332,YES,) IS TRACE ACTIVE? */
         SPACE 2
DS03315  DC    0H'0'
         CLI   CVTTRACE+DSL1,DSTRACEM   IS TRACE ACTIVE?
         BNE   DS0332              NO. BYPASS.
         DROP  RB                  DROP CVT BASE.
         SPACE 2
*/* S TRSRB1:TRACE SRB DISPATCH */
         SPACE 2
         L     RA,DSTRSRB1         TRACE SRB ENTRY ADDRESS
DST046A  DC    0H'0'               *** TEST LABEL ***
         BALR  RB,RA               GO TO TRACE
LOADPSA1 DC    0H'0'               ***** FOR TSO TEST *****
         SPACE 2
*/*DS0332: S IEADISP1:GTF INTERFACE */
         SPACE 2
DS0332   DC    0H'0'
         HOOK  EID=IEADISP1,TYPE=P      GO TO GTF
         SPACE 2
*/* P STORE TOD CLOCK INTO LCCA FOR JOB STEP TIMING */
         SPACE 2
         STCK  LCCADTOD            STORE TOD CLOCK FOR JOB STEP TIMING
         SPACE 2
*/*DSLOCK11: S SETLOCK:RELEASE GLOBAL DISPATCHER LOCK */
         SPACE 2
DSLOCK11 DC    0H'0'
*        SETLOCK RELEASE,TYPE=DISP,RELATED=('ASCB QUEUE/GSPL/LSPL/PSAAN*
               EW',IEAVEDS0,(DSLOCK5,DSLOCK6,DSLOCK7,DSLOCK9,DSLOCK10))
         L     RB,DSDISPLK         OBTAIN DISP LOCK ADDR       @YM03564
         SLR   RD,RD               ZERO A REGISTER             @YM03564
         ST    RD,DSL0(RB)         FREE LOCK VIA STORE ZEROS   @YM03564
         NI    PSAHLHI+DSL2,X'EF'  INDICATE DISPATCHER LOCK NOT HELD
         SPACE 2
***********************************************************************
*                                                                     *
*              LOAD PSW FOR INITIAL DISPATCH OF AN SRB                *
*                                                                     *
***********************************************************************
         SPACE 2
*/*ISRBPSW: R LPSW */
         SPACE 2
ISRBPSW  DC    0H'0'
         LA    RE,IEAPDSRT         RETURN ADDRESS
         LPSW  PSAPSWSV            INITIAL SRB DISPATCH
         TITLE 'IEAVEDS0 - SRBS ON LSMQ'
***********************************************************************
*                                                                     *
*  LOCAL SRB'S ON THE LOCAL SERVICE MANAGER QUEUE PROCESSING.         *
*              R5 - HAS FIRST SRB ADDRESS                             *
*              R6 - HAS LSMQ ADDRESS                                  *
*                                                                     *
***********************************************************************
         SPACE 2
*/*DS041: S DSSAVE:SAVE STATUS OF PREVIOUS TASK */
         SPACE 2
DS041    DC    0H'0'
         BAL   RF,DSSAVE           SAVE STATUS OF PREVIOUS TASK.
*   DSSAVE USES REGISTERS 0,1,2,3,14 AND 15.
         SPACE 2
*/*DSLOCK12: S SETLOCK: OBTAIN GLOBAL DISPATCHER LOCK */
         SPACE 2
DSLOCK12 DC    0H'0'
*        SETLOCK OBTAIN,TYPE=DISP,MODE=UNCOND,RELATED=('ASCB QUEUE/GSPL*
               /LSPL/PSAANEW',IEAVEDS0,(DSLOCK8,DSLOCK14,DSLOCK16,DSLOC*
               K17,DSLOCK18,DSLOCK19))
         L     RD,AGSLDISP         OBTAIN DISPATCHER SPECIAL ENTRY PT
         BALR  RE,RD               LOCK MANAGER'S SPECIAL DISP ENTRY
         SPACE 2
*/*DS0411: P SET UP FOR COMPARE AND SWAP */
         SPACE 2
DS0411   DC    0H'0'
         SR    R3,R3               CLEAR FOR COMPARE AND SWAP
         SPACE 2
*/*DS0412: P (OK,DS042,ZERO,DSRT0177,ADD,DS0412) CMPR & SWAP LSMQ */
         SPACE 2
DS0412   DC    0H'0'
         CS    R5,R3,DSL0(R6)      DEQUEUE ENTIRE QUEUE
         BC    DSCC8,DS042         OK. CONTINUE.
DST050   DC    0H'0'               *** TEST LABEL ***
         LTR   R5,R5               TEST FOR SRB PICKED UP IN CS
         BNZ   DS0412              YES. SCHED HAS ADDED ONE. GO TO TRY
*                                      AGAIN.
DST051   DC    0H'0'               *** TEST LABEL ***
         B     DSRT0177            NO. ANOTHER CPU HAS DEQUEUED THEM.
*                                      GO TO TEST MEMORY SWITCH.
         SPACE
***********************************************************************
*                                                                     *
*  SET UP TO GO TO LOCAL SCHEDULE                                     *
*        R3 -  RETURN ADDRESS                                         *
*        R4 -  ENTRY POINT ADDRESS                                    *
*        R5 -  CONTENTS OF LSMQ (FIRST SRB ADDRESS)                   *
*        R7 -  LCCA ADDRESS                                           *
*        R8 -  ASCB ADDRESS                                           *
*        R9 -  DISPATCHER BASE ADDRESS                                *
*                                                                     *
***********************************************************************
         SPACE 2
*/*DS042: S IEAVESC2:LOCAL SCHEDULE TO MOVE SRB'S TO LSPL'S */
         SPACE 2
DS042    DC    0H'0'
         ST    R5,LCCASMQJ             JOURNAL LOCAL SMQ ENTRY
         L     R4,DSVESC2          LOCAL SCHEDULE ADDRESS
         BALR  R3,R4               GO.
DST052   DC    0H'0'               *** TEST LABEL ***
*
*        REGISTERS 7,8 AND 9 ARE RETURNED FROM LOCAL SCHEDULE
*
         SPACE 2
*/*DS043: D (YES,DS052,NO,) TEST FOR MEMORY SWITCH */
         SPACE 2
DS043    DC    0H'0'
         C     R8,PSAANEW          TEST FOR MEMORY SWITCH.
         BNE   DS052               YES. GO TO MEMORY DISPATCHER.
DST053   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* D (YES,DS062,NO,DSLOCK18) ANY LOCAL SPL ADDRESS */         @ZA20174
         SPACE 2
         L     R4,ASCBSPL          NO. GET LOCAL SPL ADDRESS.
         L     R0,DSL4(R4)         ANY NON-Q SRBS?             @YM03564
         O     R0,DSL8(R4)         OR SYSTEM SRBS?             @YM03564
         BNZ   DS062               YES GO TO LOCAL SPL PROCESSOR
         B     DSLOCK18            NO GO TO PROCESS MEMORY     @YM03564
         TITLE 'IEAVEDS0 - MEMORY DISPATCHER'
***********************************************************************
*                                                                     *
*  MEMORY DISPATCHER SECTION  - THIS SECTION IS ENTERED WHEN AN       *
*        ADDRESS SPACE SWITCH HAS BEEN INDICATED BY PSAANEW NOT BEING *
*        EQUAL TO PSAAOLD.                                            *
*                                                                     *
***********************************************************************
         SPACE 2
*/*DS051: S DSSAVE:SAVE STATUS OF PREVIOUS TASK */
         SPACE 2
DS051    DC    0H'0'
         BAL   RF,DSSAVE           GO TO SAVE STATUS OF PREVIOUS TASK.
*   DSSAVE USES REGISTERS 0,1,2,3,14 AND 15.
         SPACE 2
*/*DSLOCK13: S SETLOCK:OBTAIN GLOBAL DISPATCHER LOCK */
         SPACE 2
DSLOCK13 DC    0H'0'
*        SETLOCK OBTAIN,TYPE=DISP,MODE=UNCOND,RELATED=('ASCB QUEUE/GSPL*
               /LSPL/PSAANEW',IEAVEDS0,(DSLOCK14,DSLOCK16,DSLOCK17,DSLO*
               CK18,DSLOCK19))
         L     RD,AGSLDISP         OBTAIN DISPATCHER SPECIAL ENTRY PT
         BALR  RE,RD               LOCK MANAGER'S SPECIAL DISP ENTRY
         SPACE 2
*/*DS052: P SET UP CVT AND CSD ADDRESSING */
         SPACE 2
DS052    DC    0H'0'
         L     R6,FLCCVT           CVT
         USING CVT,R6                   ADDRESSING.
         L     R5,CVTCSD           CSD
         USING CSD,R5                   ADDRESSING.
         SPACE 2
*/* P GET PSAANEW */
         SPACE 2
         L     R8,PSAANEW          NEXT ASCB TO DISPATCH.
         SPACE 2
*/* D (NO,DS054,YES,DS053) IS PSAANEW EQUAL ZERO? */
         SPACE 2
         LTR   R8,R8               TEST FOR "PSAANEW"=0 - START FROM
*                                       TOP OF ASCB DISPATCHING QUEUE?
         BNZ   DS0543              NO. GO AROUND               @Z40FPXJ
         SPACE 2
*/*DS053: P GET HEAD OF ASCB DISP QUEUE FROM CVT */
         SPACE 2
DS053    DC    0H'0'
         L     R8,CVTASCBH         HEAD OF ASCB DISPATCHING QUEUE.
         SPACE 2
*/*DS054: D (YES,DS05B,NO,) TEST FOR END OF QUEUE */
         SPACE 2
DS054    DC    0H'0'
         LTR   R8,R8               HAVE WE SCANNED ALL ASCB'S AND
*                                       FOUND NO WORK?
         BZ    DS05B               YES. GO TO DISPATCH WAIT TASK.
         SPACE
DST054   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* D (YES,DS053,NO,) IS ASCB OFF QUEUE? */
         SPACE 2
DS0543   DS    0H                                              @Z40FPXJ
         TM    ASCBDSP1,ASCBNOQ    HAS THE ASCB FROM PSAANEW BEEN
*                                       REMOVED FROM THE DISPATCHING Q.
         BO    DS053               YES. GO TO START AT HEAD OF QUEUE.
         SPACE
DST055   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* D (NO,DS0545,YES,) HAS ASCB FAILED? */
         SPACE 2
         TM    ASCBDSP1,ASCBFAIL   IS THIS ASCB IN FAILURE MODE AND IN
*                                       THE PROCESS OF BEING REMOVED
*                                       FROM THE QUEUE OUT OF MASTER.
         BZ    DS0545              NO. CONTINUE.
DST056   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* P (,DS054) GET NEXT ASCB */
         SPACE 2
         L     R8,ASCBFWDP         GET NEXT ASCB.
         B     DS054               GO TO TEST IT'S DISPATCHABILITY.
         SPACE 2
*/*DS0545: D (NO,DS055,YES,) IS SYS NON DISP? */
         SPACE 2
DS0545   DC    0H'0'
         TM    CSDSCFL1,CSDSYSND   IS THE SYSTEM NON-DISPATCHABLE?
         BZ    DS055               NO.  GO AROUND.
DST057   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* D (YES,DS055,NO,) IS ASCB EXEMPT? */
         SPACE 2
         TM    ASCBFLG2,ASCBXMPT   IS THIS ADDRESS SPACE EXEMPT FROM
*                                       BEING SET NON-DISPATCHABLE?
         BO    DS055               YES. CONTINUE.
DST058   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* P (,DS054) GET NEXT ASCB */
         SPACE 2
         L     R8,ASCBFWDP         GET NEXT ASCB.
         B     DS054               GO TO TEST IT'S DISPATCHABILITY.
         SPACE 2
*/*DS055: P GET LOCAL SPL ADDRESS */
         SPACE 2
DS055    DC    0H'0'
         L     R4,ASCBSPL          LOCAL SPL ADDRESS
         SPACE 2
*/* D (NO,DS0551,YES,) ANY LOCAL SRB'S? */
         SPACE 2
         L     R0,DSL4(R4)         ANY NON-Q SRBS?             @YM03564
         O     R0,DSL8(R4)         OR SYSTEM SRBS?             @YM03564
         BZ    DS0551              NO. CONTINUE.               @YM03564
         SPACE 2
*/* D (YES,DS0551,NO,) ARE ALL SRB'S STOPPED IN ASCB? */
         SPACE 2
         TM    ASCBFLG2,ASCBSNQS   ARE ALL SRB'S STOPPED?
         BO    DS0551              YES CONTINUE                @YM03564
         SPACE 2                                               @YM03564
*/*P SET PSAANEW AND PSAAOLD */
         SPACE 2                                               @YM03564
         ST    R8,PSAAOLD          SET "CURRENT".              @YM03564
         ST    R8,PSAANEW          SET "NEXT".                 @YM03564
         SPACE 2                                               @YM03564
*/* P (,DS062A) LOAD CONTROL REGISTER WITH NEW STOR */
         SPACE 2                                               @YM03564
         LCTL  R1,R1,ASCBSTOR      NEW SEGMENT TABLE ORIGIN.   @YM06905
         B     DS062A              GO TO LOCAL SPL PROCESSOR   @YM03564
         SPACE 2                                               @YM03564
*/*DS0551: D (YES,DS056,NO,) IS INTRPT ID IN LCL LOCK? */
         SPACE 2
DS0551   DC    0H'0'
         L     R3,ASCBLOCK         LOCAL LOCK
         C     R3,DSINTPID         DOES IT CONTAIN INTERRUPTED ID.
         BE    DS056               YES. GO TO DISPATCH LOCAL SUPVR.
         SPACE
DST060   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* D (YES,DS0552,NO,) IS LOCAL LOCK AVAILABLE? */
         SPACE 2
         LTR   R3,R3               IS THE LOCAL LOCK AVAILABLE?
         BZ    DS0552              YES. GO AROUND.
DST061   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* P (,DS054) GET NEXT ASCB */
         SPACE 2
         L     R8,ASCBFWDP         GET NEXT ASCB.
         B     DS054               GO TO TEST IT'S DISPATCHABILITY.
         SPACE 2
*/*DS0552: D (YES,DS0554,NO,) ARE TCB'S DISPATCH? */
         SPACE 2
DS0552   DC    0H'0'
         TM    ASCBFLG1,ASCBSTND   ARE TCB'S DISPATCHABLE?
         BZ    DS0554              YES. GO AROUND.
DST062   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* P (,DS054) GET NEXT ASCB */
         SPACE 2
         L     R8,ASCBFWDP         GET NEXT ASCB.
         B     DS054               GO TO TEST IT'S DISPATCHABILITY.
         SPACE 2
*/*DS0554: D (YES,DS056,NO,) ASYNCH EXITS? */
         SPACE 2
DS0554   DC    0H'0'
         TM    ASCBFLG1,ASCBS3S    ARE THERE ASYNCHRONOUS EXITS?
         BO    DS056               YES. GO TO DISPATCH ADDRESS SPACE.
DST063   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* D (YES,DS056,NO,) IS NBR TCB'S GTR NBR CPU'S? */
         SPACE 2
         L     RD,ASCBTCBS         NUMBER OF TCBS READY        @YM03564
         C     RD,ASCBCPUS         IS NUMBER TCB'S GTR NUMBER CPU'S.
         BH    DS056               YES. GO TO DISPATCH THE ADDR SPACE
DST064   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* P (,DS054) GET NEXT ASCB */
         SPACE 2
         L     R8,ASCBFWDP         GET NEXT ASCB.
         B     DS054               GO TO TEST IT'S DISPATCHABILITY.
         SPACE
         DROP  R5                  DROP CSD ADDRESSING
         DROP  R6                  DROP CVT ADDRESSING
         SPACE
*
*  DISPATCH THE ADDRESS SPACE
*        R4 HAS LOCAL SPL ADDRESS
*
DS056    DC    0H'0'
         SPACE 2
*/*DS056: P SET PSAANEW AND PSAAOLD */
         SPACE 2
         ST    R8,PSAAOLD          SET "CURRENT".
         ST    R8,PSAANEW          SET "NEXT".
         SPACE 2
*/* P LOAD CONTROL REGISTER WITH NEW STOR */
         SPACE 2
         LCTL  R1,R1,ASCBSTOR      NEW SEGMENT TABLE ORIGIN.   @YM06905
         SPACE 2
*/*DSLOCK18: S (,DS07) SETLOCK:RELEASE GLOBAL DISPATCHER LOCK */
         SPACE 2
DSLOCK18 DC    0H'0'
*        SETLOCK RELEASE,TYPE=DISP,RELATED=('ASCB QUEUE/GSPL/LSPL/PSAAN*
               EW',IEAVEDS0,(DSLOCK5,DSLOCK6,DSLOCK7,DSLOCK9,DSLOCK10,D*
               SLOCK12,DSLOCK13,DSLOCK22,DSLOCK3))
         L     RB,DSDISPLK         OBTAIN DISP LOCK ADDR       @YM03564
         SLR   RD,RD               ZERO A REGISTER             @YM03564
         ST    RD,DSL0(RB)         FREE LOCK VIA STORE ZEROS   @YM03564
         NI    PSAHLHI+DSL2,X'EF'  INDICATE DISPATCHER LOCK NOT HELD
DST065   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* D (YES,DS08X,NO,) TEST FOR LOCAL LOCK AVAILABLE */
         SPACE 2
         L     R1,ASCBLOCK         CURRENT LOCKWORD VALUE      @YM07654
         LH    R3,PSACPULA         LOGICAL CPU ADDRESS.        @YM07654
         LTR   R1,R1               IS LOCK AVAILABLE?          @YM07654
         BZ    DS08X               LOCK IS AVAILABLE, OBTAIN IT@YM07654
         SPACE 2                                               @YM07654
*/* D (YES,DS08A,NO,) TEST FOR LOCAL SUPERVISOR */
         SPACE 2                                               @YM07654
         BM    DS08A               INTERRUPT ID, GO OBTAIN IT  @YM07654
         SPACE 2                                               @YM07654
*/* D (YES,DS081,NO,DS08B) WAS LOCK OWNED BY THIS CPU? */
         SPACE 2                                               @YM07654
         CR    R1,R3               WAS LOCAL LOCK OWNED BY THIS CPU?
         BE    DS081               YES. GO TO LOCAL SUPVR DISPATCHER
         B     DS08B               LOCK IS NOT AVAILABLE       @YM07654
         TITLE 'IEAVEDS0 - WAIT DISPATCHER'
***********************************************************************
*                                                                     *
*  PREPARE TO DISPATCH THE WAIT TASK                                  *
*        THIS SECTION IS ENTERED WHEN NO WORK HAS BEEN FOUND          *
*        IN THE INITIAL SCAN.  THE WAIT TASK IS SET UP AND THE        *
*        QUEUES ARE SCANNED ONCE MORE TO PICK UP ANY SRB'S WHICH      *
*        MAY HAVE BEEN SCHEDULED DURING THE FIRST SCAN.               *
*                                                                     *
***********************************************************************
         SPACE 2
*/*DS05B: P PICK UP ADDRESS OF WAIT TCB AND ASCB */
         SPACE 2
DS05B    DC    0H'0'
         L     R8,DSWASCB          WAIT ASCB ADDRESS
         L     R5,DSWTCB           WAIT TCB ADDRESS
*/*DS05BB: P OBTAIN OLD CPUS COUNT */
         SPACE 2
DS05BB   DC    0H'0'
         L     R4,ASCBCPUS         NUMBER OF CPUS DISPATCHED TO WAIT
         SPACE 2
*/*DS05B1: P (CHNG,DS05B1,,) COMPARE AND SWAP # CPU'S IN WAIT */
         SPACE 2
DS05B1   DC    0H'0'
         LA    R3,DSI1(R4)         INCREMENT COUNT OF NUMBER CPUS.
         CS    R4,R3,ASCBCPUS      UPDATE COUNT
         BC    DSCC4,DS05B1        CHANGED.  GO TRY AGAIN
         SPACE 2
*/*DS05B2: P STORE WAIT ASCB ADDRESS INTO PSAANEW AND PSAAOLD */
         SPACE 2
DS05B2   DC    0H'0'
         ST    R8,PSAAOLD          SET PSAAOLD
         ST    R8,PSAANEW          SET PSAANEW
         SPACE 2
*/* P LOAD MASTER'S STOR */
         SPACE 2
         LCTL  R1,R1,PSASTOR       MASTER'S STOR.              @YM06905
         SPACE 2
*/* P STORE WAIT TCB ADDRESS INTO PSATNEW AND PSATOLD */
         SPACE 2
         ST    R5,PSATOLD          SET PSATOLD
         ST    R5,PSATNEW          SET PSATNEW
         SPACE 2
*/*DSLOCK14: S (,DS08B2) SETLOCK:RELEASE GLOBAL DISP LOCK */
         SPACE 2
DSLOCK14 DC    0H'0'
*        SETLOCK RELEASE,TYPE=DISP,RELATED=('ASCB QUEUE/GSPL/LSPL/PSAAN*
               EW',IEAVEDS0,(DSLOCK5,DSLOCK6,DSLOCK7,DSLOCK9,DSLOCK10,D*
               SLOCK12,DSLOCK13,DSLOCK22,DSLOCK3))
         L     RB,DSDISPLK         OBTAIN DISP LOCK ADDR       @YM03564
         SLR   RD,RD               ZERO A REGISTER             @YM03564
         ST    RD,DSL0(RB)         FREE LOCK VIA STORE ZEROS   @YM03564
         NI    PSAHLHI+DSL2,X'EF'  INDICATE DISPATCHER LOCK NOT HELD
DST066   DC    0H'0'               *** TEST LABEL ***
         SPACE
         B     DS08B2              GO TO RECURSE.              @ZA09433
         TITLE 'IEAVEDS0 - LSPL'
***********************************************************************
*                                                                     *
*  LOCAL SRB'S ON THE LOCAL SERVICE PRIORITY LIST                     *
*        R4 - HAS THE ADDRESS OF THE LOCAL SPL                        *
*                                                                     *
***********************************************************************
         SPACE 2
*/*DS061: S DSSAVE:SAVE STATUS OF PREVIOUS TASK */
         SPACE 2
DS061    DC    0H'0'
         BAL   RF,DSSAVE           SAVE STATUS OF PREVIOUS TASK
*   DSSAVE USES REGISTERS 0,1,2,3,14 AND 15.
         SPACE 2
*/*DSLOCK15: S SETLOCK:OBTAIN GLOBAL DISPATCHER LOCK */
         SPACE 2
DSLOCK15 DC    0H'0'
*        SETLOCK OBTAIN,TYPE=DISP,MODE=UNCOND,RELATED=('ASCB QUEUE/GSPL*
               /LSPL/PSAANEW',IEAVEDS0,(DSLOCK16,DSLOCK17))
         L     RD,AGSLDISP         OBTAIN DISPATCHER SPECIAL ENTRY PT
         BALR  RE,RD               LOCK MANAGER'S SPECIAL DISP ENTRY
         SPACE 2
*/*DS062: D (YES,DS06235,NO,) ARE ALL SRB'S STOPPED IN ASCB? */
         SPACE 2
DS062    DC    0H'0'
*        R4 HAS ADDRESS OF LOCAL SPL
         TM    ASCBFLG2,ASCBSNQS   ARE ALL SRB'S STOPPED?
         BO    DS06235             YES. GO TO RELEASE GLOBAL DISP LOCK.
         SPACE 2
*/* P SET UP CVT AND CSD ADDRESSING */
         SPACE 2
         L     R6,FLCCVT           CVT                         @YM03564
         USING CVT,R6                   ADDRESSING             @YM03564
         L     R5,CVTCSD           CSD ADDRESSING              @YM03564
         DROP  R6                                              @YM03564
         USING CSD,R5                                          @YM03564
         SPACE 2
*/*DS062A: P SET UP TO INDEX TO END OF LSPL */
         SPACE 2                                               @YM03564
DS062A   DC    0H'0'                                           @YM03564
         LA    R3,LSPLSIZE(R4)     END OF LSPL
         SPACE 2
*/*DS0621: P GET SRB ADDRESS */
         SPACE 2
DS0621   DC    0H'0'
         L     R2,DSL0(R4)         SRB ADDRESS
         SPACE 2
*/*DS0622: D (YES,DS0624,NO,DS0623) ANY SRB'S AT THIS SPL LEVEL? */
         SPACE 2
DS0622   DC    0H'0'
         LTR   R2,R2               ANY SRB'S
         BNZ   DS0624              YES.GO AROUND
         SPACE 2
*/*DS0623: P GET NEXT SPL ENTRY */
         SPACE 2
DS0623   DC    0H'0'
         LA    R4,DSL8(R4)         GET NEXT SPL ENTRY.
         SPACE 2
*/* D (NO,DS0621,YES,) END OF SPL? */
         SPACE 2
         CLR   R4,R3               END OF SPL?
         BNE   DS0621              NO. GO CHECK SRB'S.
         SPACE 2
*/*DS06235: S (,DS07) SETLOCK:(DSLOCK16) RELEASE GLOBAL DISPATCHER LOCK
*/**/
         SPACE 2
DS06235  DC    0H'0'
DSLOCK16 DC    0H'0'
*        SETLOCK RELEASE,TYPE=DISP,RELATED=('ASCB QUEUE/GSPL/LSPL/PSAAN*
               EW',IEAVEDS0,(DSLOCK5,DSLOCK6,DSLOCK7,DSLOCK9,DSLOCK10,D*
               SLOCK12,DSLOCK13,DSLOCK15,DSLOCK22,DSLOCK3))
         L     RB,DSDISPLK         OBTAIN DISP LOCK ADDR       @YM03564
         SLR   RD,RD               ZERO A REGISTER             @YM03564
         ST    RD,DSL0(RB)         FREE LOCK VIA STORE ZEROS   @YM03564
         NI    PSAHLHI+DSL2,X'EF'  INDICATE DISPATCHER LOCK NOT HELD
         B     DS07                GO TO CHECK THE LOCAL LOCK.
         SPACE 2
*/*DS0624: D (YES,DS0625,NO,) IS SRB NON QUIESC.? */
         SPACE 2
DS0624   DC    0H'0'
         CLI   SRBPRIOR,SRBPNONQ   IS SRB NON-QUIESCEABLE.
         BE    DS0625              YES. GO AROUND.
DST068   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* P GET COUNT OF NUMBER OF STATUS STOP Q SRB'S */
         SPACE 2
         LH    R1,ASCBSSRB         COUNT OF NUMBER OF LOCAL STATUS STOP
*                                       QUIESCEABLE SRB'S.
         SPACE 2
*/* D (YES,DS0623,NO,DS0625) IS COUNT GTR THAN ZERO? */
         SPACE 2
         LTR   R1,R1               IS COUNT GTR THAN ZERO.
         BNZ   DS0623              YES. GO GET NEXT SPL LEVEL.
         SPACE 2
*/*DS0625: P GET SRB'S CPU AFFINITY MASK */
         SPACE 2
DS0625   DC    0H'0'               ENTER TO TEST AFFINITY.
         LH    RB,SRBCPAFF         SRB'S AFFINITY MASK
         SPACE 2
*/* D (NO,DS0626,NO,) IS CPU AFFIN SPEC? */
         SPACE 2
         LTR   RB,RB               AFFINITY SPECIFIED?
         BZ    DS0626              NO. BYPASS AFFINITY CHECK.
DST070   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* P GET CPU'S AFFINITY MASK FROM PCCA */
         SPACE 2
         L     RC,PSAPCCAV         PCCA
         USING PCCA,RC                  ADDRESSING
         LH    RC,PCCACAFM         CPU'S AFFINITY MASK.
         DROP  RC
         SPACE 2
*/* D (NO,DS0628,YES,DS0626) CAN SRB RUN ON THIS CPU? */
         SPACE 2
         NR    RC,RB               CAN SRB RUN ON THIS CPU?
         BC    DSCC8,DS0628        NO. GO TO TEST FOR ANY CPU
         SPACE 2
*/*DS0626: D (YES,DS0627,NO,) IS THIS THE TOP SRB? */
         SPACE 2
DS0626   DC    0H'0'               ENTER TO DEQUEUE AN SRB.
         C     R2,DSL0(R4)         IS THIS THE TOP SRB
         BE    DS0627              YES. GO AROUND DEQUEUE FROM MIDDLE
DST071   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* P GET ADDRESS OF TOP SRB */
         SPACE 2
*  ENTER FOR NOT TOP SRB ON SPL QUEUE
         L     RE,DSL0(R4)         TOP SRB
         SPACE 2
*/*DS06261: P GET NEXT SRB */
         SPACE 2
DS06261  DC    0H'0'
         L     RF,SRBFLNK-SRBSECT(RE)  NEXT SRB.
         SPACE 2
*/* D (YES,DS06262,NO,) IS IT THE CURRENT SRB? */
         SPACE 2
         CLR   RF,R2               IS IT CURRENT?
         BE    DS06262             YES. RE HAS ADDRESS OF PREVIOUS
DST072   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* P (,DS06261) SET UP TO SCAN FOR NEXT SRB */
         SPACE 2
         LR    RE,RF               NO. SET UP TO SCAN FOR NEXT.
         B     DS06261             GO TO GET NEXT SRB
         SPACE 2
*/*DS06262: P CHAIN NEXT SRB TO PREVIOUS */
         SPACE 2
DS06262  DC    0H'0'
         L     RC,SRBFLNK          NEXT SRB FROM CURRENT
         ST    RC,SRBFLNK-SRBSECT(RE)  CHAIN UP TO PREVIOUS
         SPACE 2
*/* D (NO,DS06263,YES,) WAS CURRENT SRB LAST ONE ON QUEUE? */
         SPACE 2
         LTR   RC,RC               WAS CURRENT SRB LAST ONE  ON QUEUE.
         BNZ   DS06263             NO. DONE. GO TO CLEAR  SRBFLNK.
DST073   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* P (,DS063) DEQUEUED LAST SRB. STORE PREVIOUS INTO SPL LAST FIELD */
         SPACE 2
         ST    RE,DSL4(R4)         LAST SRB. STORE PREVIOUS INTO SPL.
         B     DS063               GO TO LOCAL SRB DISPATCHER.
         SPACE 2
*/*DS06263: P (,DS063) CLEAR SRBFLNK TO PREVENT ACCESS TO OTHER SRB'S
*/**/
         SPACE 2
DS06263  DC    0H'0'               ENTER FOR CLEAR OF SRBFLNK
         SR    R3,R3
         ST    R3,SRBFLNK          CLEAR SRBFLNK TO PREVENT ACCESS TO
*                                       OTHER SRB'S.
         B     DS063               GO TO LOCAL SRB DISPATCHER.
         SPACE
*  ENTER FOR TOP SRB ON SPL QUEUE.
         SPACE 2
*/*DS0627: P CHAIN NEXT SRB TO SPL */
         SPACE 2
DS0627   DC    0H'0'
         L     RC,SRBFLNK          FORWARD CHAIN POINTER.
         ST    RC,DSL0(R4)         RECHAIN TO SPL.
         SPACE 2
*/* D (NO,DS06263,YES,) IS THIS THE ONLY SRB ON SPL? */
         SPACE 2
         LTR   RC,RC               IS THIS THE ONLY SRB ON THE LSPL?
         BNZ   DS06263             NO. DON'T CLEAR PTR TO LAST IN LSPL.
DST074   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* P (,DS063) CLEAR SPL PTR TO LAST SRB */
         SPACE 2
         ST    RC,DSL4(R4)         CLEAR PTR TO LAST SRB.
*                                  SRBFLNK FIELD IS ALREADY ZERO.
         B     DS063               GO TO LOCAL SRB DISPATCHER.
         SPACE
*  ENTER FOR FURTHER CPU AFFINITY TESTS.
         SPACE 2
*/*DS0628: D (NO,DS0629,YES,) CAN SRB RUN ON ANY OTHER CPU? */
         SPACE 2
DS0628   DC    0H'0'
         LH    RC,CSDCPUAL         SYSTEM-WIDE CPU AFFINITY MASK.
         NR    RC,RB               CAN SRB RUN ON ANY OTHER CPU?
         BC    DSCC8,DS0629        NO. GO TO ABEND SRB/TASK.
DST075   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* P (,DS0622) GET NEXT SRB */
         SPACE 2
         L     R2,SRBFLNK          YES. GET NEXT SRB.
         B     DS0622              GO TO TEST DISPATCHABILITY.
         SPACE 2
*  ENTER FOR ABEND OF SRB/TASK WHOSE AFFINITY SPECIFICATION DOES NOT
*        MATCH ANY CPU CURRENTLY AVAILABLE TO RUN SRB'S.
         SPACE 2
*/*DS0629: D (NO,DS0626,YES,) IS THIS A SUSPENDED SRB? */
         SPACE 2
DS0629   DC    0H'0'
         L     RC,SRBRMTR          RMTR ADDRESS IF A SUSPENDED SRB
         L     RB,DSRMTR           GET COMMMON SUSPEND'S RMTR ADR
         CR    RB,RC               TEST FOR SUSPENDED SRB
         BNE   DS0626              NO. GO TO DISPATCH AND SET UP FOR
*                                       ABEND IN GLOBAL SRB DISPATCHER
         SPACE 2
*/* P GET ADDRESSABILITY TO CVT */
         SPACE 2
         L     RC,FLCCVT           CVT ADDRESS
         USING CVT,RC              CVT ADDRESSABILITY.
         SPACE 2
*/* P SET SRB PSW TO POINT TO SVC ABEND INSTRUCTION IN CVT */
         SPACE 2
         LA    RB,CVTQABST         ADDRESS OF SVC D INSTRUCTION.
         ST    RB,SSRBCPSW+DSL4    SET PSW TO ADDRESS OF SVC D.
         DROP  RC                  DROP CVT ADDRESSABILITY.
         SPACE 2
*/* P SET SRB'S REG 1 TO 072 ABEND CODE. */                    @ZA25275
         SPACE 2
         L     RB,DSABAFFN         072 ABEND CODE.
         ST    RB,SSRBGPRS+DSL4    STORE INTO REG 1 SLOT IN SSRBSAVE.
         SPACE 2                                               @ZA25275
*/* P (,DSO626) REMOVE SRB'S AFFN TO OFFLINE CPU FOR ABEND */  @ZA25275
         SPACE 2                                               @ZA25275
         SLR   RB,RB               ZERO A REGISTER.            @ZA25275
         STH   RB,SRBCPAFF         ZERO SRB'S INVALID AFFN.    @ZA25275
         B     DS0626              GO TO DISPATCH AND ABEND SRB.
         TITLE 'IEAVEDS0 - LOCAL (SUSPENDED) SRB'
***********************************************************************
*                                                                     *
*  LOCAL (SUSPENDED) SRB DISPATCHER                                   *
*        R2 - CONTAINS SRB ADDRESS                                    *
*        R6 - CONTAINS CSD ADDRESS                                    *
*                                                                     *
***********************************************************************
         SPACE 2
*/*DS063: P SET SRB MODE INDICATOR (LCCASRBM) */
         SPACE 2
DS063    DC    0H'0'               ENTER
         OI    LCCADSF2,LCCASRBM+LCCADSRW SET SRB MODE INDICATOR.
         ST    R2,LCCASPLJ             JOURNAL LOCAL SPL ENTRY
         SPACE 2
*/* D (YES,,NO,DS0331) IS THIS A SUSPENDED SRB? */
         SPACE 2
         L     R5,SRBRMTR          IF THIS SRB HAS AN SUSPENDED RMTR
         L     R1,DSRMTR               (SUSPENDED RMTR ADDR)
         CR    R1,R5                    ADDR IT IS A SUSPENDED SRB. IF
*                                       NOT, IT IS AN INITIAL DISPATCH.
         BNE   DS0331              GO TO GLOBAL SRB DISPATCH.
         SPACE 2
*  ENTER FOR DISPATCH OF A SUSPENDED SRB.
         SPACE 2
*/* P RESTORE THE FLOATING POINT REGISTERS */
         SPACE 2
         LD    R0,SSRBFPR0         *    RESTORE
         LD    R2,SSRBFPR2         *         FLOATING
         LD    R4,SSRBFPR4         *              POINT
         LD    R6,SSRBFPR6         *                   REGISTERS
         SPACE 2
*/* P RESTORE SRB'S FRR STACK */
         SPACE 2
         LA    R4,SSRBFRRS             ADDRESS OF SAVED STACK
         L     R5,FRRSCURR-FRRS(R4)    ADDR OF CURRENT ENTRY   @YM03564
         L     RD,FRRSELEN-FRRS(R4)    LENGTH OF AN ENTRY      @YM03564
         AR    R5,RD                   ADDRESS OF END OF STACK @YM03564
         L     RC,PSANSTK              ADDRESS OF NORMAL STACK
         SR    R5,RC                   LENGTH OF SAVED STACK   @YM03564
         LA    RD,DSL0(R5)             DUPLICATE LENGTH        @YM03564
         MVCL  RC,R4                   MOVE THE SAVED STACK
         SPACE 2
*/* P MOVE CPU AFFIN MASK AND PURGE ASID/TCB TO LCCA */
         SPACE 2
         MVC   LCCASRBF(DSL8),SRBFLC   MOVE SRB AFFINITY, PURGE ASID
*                                       AND PURGE TCB ADDR TO LCCA.
         SPACE 2
*/* P MOVE PSW TO LOW CORE */
         SPACE 2
         MVC   PSAPSWSV,SSRBCPSW   MOVE PSW FOR DISPATCH.
*/* D (NO,DS0631,YES,) DOES SRB HOLD LOCAL LOCK? */
         SPACE 2
         TM    SSRBFLG1,SSRBLLH    IS THE LOCAL LOCK HELD BY THIS SRB.
         BZ    DS0631              NO. GO AROUND LOCK RESTORE.
         SPACE 2
*/* P STORE CPUID INTO THE LOCAL LOCK */
         SPACE 2
         LH    R4,PSACPULA         CPU ID.
         ST    R4,ASCBLOCK         STORE INTO LOCAL LOCKWORD.
         SPACE 2
*/* P SET  LOCKS HELD INDICATOR TO LOCAL LOCK */
         SPACE 2
         OI    PSAHLHI+DSO3,DSLLHI     TURN ON LOCAL LK HELD INDICATOR
         SPACE 2
*/* D (NO,DS0631,YES,) IS THE CMS LOCK ALSO HELD? */
         SPACE 2
         TM    ASCBFLG1,ASCBCMSH   IS THE CMS LOCK ALSO HELD?
         BZ    DS0631              NO. GO AROUND CMS LOCK PROCESSING
         SPACE 2
*/* P SET LOCK HELD INDICATOR FOR CMS LOCK */
         SPACE 2
         OI    PSAHLHI+DSO3,DSCMSHI    TURN ON CMS LOCK HELD INDICATOR
         SPACE 2
*/* P TURN OFF CMS LOCK HELD BIT IN ASCB */
         SPACE 2
         NI    ASCBFLG1,DSXFF-ASCBCMSH  TURN OFF CMS LOCK HELD BIT.
         SPACE 2
*/*DS0631: P RESET DISPATCHER INDICATOR */
         SPACE 2
DS0631   DC    0H'0'
         NI    PSASUP1,DSXFF-PSADISP    RESET DISPATCHER INDICATOR.
         SPACE 2
*/* P ZERO THE SPL JOURNAL WORD */
         SPACE 2
         SR    R1,R1                   ZERO A REGISTER
         ST    R1,LCCASPLJ             ZERO THE JOURNAL SPL WORD
         SPACE 2
*/* P RESET FRR STACK TO NORMAL */
         SPACE 2
LSSRBPSW DC    0H'0'
         MVC   PSACSTK(DSL4),PSANSTK    RESET FRR STACK TO NORMAL.
         SPACE 2
*/*DSLOCK17: S SETLOCK:RELEASE GLOBAL DISPATCHER LOCK */
         SPACE 2
DSLOCK17 DC    0H'0'
*        SETLOCK RELEASE,TYPE=DISP,RELATED=('ASCB QUEUE/GSPL/LSPL/PSAAN*
               EW',IEAVEDS0,(DSLOCK5,DSLOCK6,DSLOCK7,DSLOCK9,DSLOCK10,D*
               SLOCK12,DSLOCK13,DSLOCK15,DSLOCK22,DSLOCK3)),DISABLED
         L     RB,DSDISPLK         OBTAIN DISP LOCK ADDR       @YM03564
         SLR   RD,RD               ZERO A REGISTER             @YM03564
         ST    RD,DSL0(RB)         FREE LOCK VIA STORE ZEROS   @YM03564
         NI    PSAHLHI+DSL2,X'EF'  INDICATE DISPATCHER LOCK NOT HELD
         SPACE 2
*/* P MOVE GENERAL PURPOSE REGISTERS TO CPU SAVE AREA */
         SPACE 2
         L     R5,LCCACPUS         CPU SAVE AREA VECTOR TABLE ADDRESS.
         USING WSAC,R5
         L     R5,WSACEDS0         DISPATCHER'S SAVE AREA ADDRESS.
         DROP  R5
         MVC   DSL0(DSLSAV,R5),SSRBGPRS SAVE SRB'S REGISTERS.
         SPACE 2
         SPACE 2
*/*DS0632: D (NO,DS0633,YES,) WAS SSRB GETMAINED? */
         SPACE 2
DS0632   DC    0H'0'
         TM    SSRBFLG1,SSRBMAIN   WAS SSRB GOTTEN FROM MAIN STORE?
         BZ    DS0633              NO. GO TO FREECELL.
         SPACE 2
*/*DSLOCK23: S SETLOCK:OBTAIN SALLOC LOCK */
         SPACE 2
DSLOCK23 DC    0H'0'
         SETLOCK OBTAIN,TYPE=SALLOC,MODE=UNCOND,RELATED=('MAIN STORAGE'*
               ,IEAVEDS0,(DSLOCK24))
         SPACE 2
*/* S FREEMAIN:FREEMAIN SSRB */
         SPACE 2
         LA    R0,SSRBLEN          SSRB LENGTH
         LR    R1,R2               SSRB ADDRESS
         SPACE
         FREEMAIN RC,SP=245,LV=(0),A=(1),BRANCH=(YES,GLOBAL)
*  REGISTERS 0-4 AND 14-15 HAVE BEEN DESTROYED.
         SPACE 2
*/*DSLOCK24: S (,DS0634) SETLOCK:RELEASE SALLOC LOCK */
         SPACE 2
DSLOCK24 DC    0H'0'
         SETLOCK RELEASE,TYPE=SALLOC,RELATED=('MAIN STORAGE',IEAVEDS0,(*
               DSLOCK23)),DISABLED                             @YM03564
         B     DS0634              GO TO STORE TOD CLOCK.
         SPACE 2
*/*DS0633: S FREECELL:FREE THE SRB AND SAVE AREA */
         SPACE 2
DS0633   DC    0H'0'
         L     R0,DSCELLID         SRB CELLPOOL ID.
         LR    R1,R2               SRB ADDRESS
         SPACE
         FREECELL CPID=(0),CELL=(1),SAVE=NO,BRANCH=YES
         SPACE
*  REGISTERS 0-4 AND 14-15 HAVE BEEN DESTROYED.
         SPACE
         SPACE 2
*/*DS0634: P STORE TOD CLOCK FOR JOB STEP TIMING */
         SPACE 2
DS0634   DC    0H'0'
         STCK  LCCADTOD            STORE TOD CLOCK FOR JOB STEP TIMING.
         SPACE 2
*/* D (NO,DS0635,YES,) IS TRACE ACTIVE? */
         SPACE 2
         L     RE,FLCCVT           CVT ADDRESS
         USING CVT,RE
         CLI   CVTTRACE+DSL1,DSTRACEM   IS TRACE ACTIVE?
         BNE   DS0635              NO. BYPASS.
         DROP  RE
         SPACE 2
*/* S TRSRB2:TRACE SRB ACTIVITY */
         SPACE 2
         LM    R0,R1,DSL0(R5)      RESTORE 0 AND 1 FOR TRACE.
         L     RA,DSTRSRB2         TRACE ENTRY POINT ADDRESS.
DST083A  DC    0H'0'               *** TEST LABEL ***
         BALR  RB,RA               GO TO TRACE.
LOADPSA3 DC    0H'0'               ***** FOR TSO TEST *****
         SPACE 2
*/*DS0635: S IEADISP1:GTF INTERFACE */
         SPACE 2
*  GTF INTERFACE
DS0635   DC    0H'0'
         SR    R0,R0               INDICATE SUSPENDED SRB TO GTF.
         HOOK  EID=IEADISP1,TYPE=P
         SPACE 2
*/* P RESTORE THE GENERAL PURPOSE REGISTERS */
         SPACE 2
         LM    R0,RF,DSL0(R5)      RESTORE SRB'S GENERAL PURPOSE REGS.
         SPACE 4
***********************************************************************
*                                                                     *
*              LOAD PSW TO DISPATCH A SUSPENDED SRB                   *
*                                                                     *
***********************************************************************
         SPACE 2
*/*SSRBPSW: R LOAD SRB'S PSW */
         SPACE 2
SSRBPSW  DC    0H'0'
         LPSW  PSAPSWSV            DISPATCH THE SUSPENDED SRB.
         TITLE 'IEAVEDS0 - INTERRUPTED LOCAL SUPERVISOR'
***********************************************************************
*                                                                     *
*  INTERRUPTED LOCAL SUPERVISOR                                       *
*        THIS SEQUENCE IS ENTERED TO RESTORE THE STATUS OF AN         *
*        INTERRUPTED LOCAL SUPERVISOR ROUTINE WHICH HAD BEEN PRE-     *
*        EMPTED FOR HIGHER PRIORITY WORK.  STATUS IS RESTORED FROM    *
*        THE INTERRUPT HANDLER SAVE AREA.                             *
*                                                                     *
*    ON ENTRY:                                                        *
*        THE LOCAL LOCK IS HELD BY THIS CPU (CPU ID WAS STORED INTO   *
*        THE LOCAL LOCKWORD PRIOR TO ENTRY TO THIS SEQUENCE).         *
*                                                                     *
***********************************************************************
         SPACE 2
*/*DS071: S DSSAVE:SAVE STATUS OF PREVIOUS TASK */
         SPACE 2
DS071    DC    0H'0'
         SPACE
         BAL   RF,DSSAVE           SAVE STATUS OF PREVIOUS TASK.
*   DSSAVE USES REGISTERS 0,1,2,3,14 AND 15.
         SPACE 2
*/* P GET ADDRESSABILITY TO IHSA */
         SPACE 2
         L     RC,ASCBASXB         ASXB
         USING ASXB,RC                  ADDRESSABILITY.
         L     RC,ASXBIHSA         IHSA ADDRESS
         DROP  RC                  DROP ASXB ADDRESSABILITY
         USING IHSA,RC             IHSA ADDRESSABILITY.
         SPACE 2
*/* P GET ADDRESSABILITY TO TCB */
         SPACE 2
         L     R5,IHSAOTCB         TCB ADDRESS
         SPACE 2
*/* D (NO,DS074,YES,) IS THERE A TCB? */
         SPACE 2
         LTR   R5,R5               IS THERE A TCB?
         BZ    DS074               NO. GO AROUND.
         SPACE 2
*/* P ESTABLISH ADDRESSABILITY TO PCCA */
         SPACE 2
         L     R6,PSAPCCAV         PCCA ADDRESS FROM PSA.
         USING PCCA,R6             PCCA ADDRESSABILITY.
         SPACE 2
*/* P GET CPU AFFINITY INDICATOR FROM THE TCB */
         SPACE 2
         USING TCB,R5              TCB ADDRESSABILITY
         LH    R4,TCBAFFN          CPU AFFINITY MASK
         SPACE 2
*/* D (NO,DS0724,YES,) IS CPU AFFINITY SPECIFIED? */
         SPACE 2
         C     R4,DSCPUAFF         IS CPU AFFINITY SPECIFIED?  @YM04737
         BE    DS0724              NO. CONTINUE.               @YM04737
         LTR   R4,R4               IS CPU AFFINITY SPECIFIED?
         BZ    DS0724              NO. CONTINUE.
         SPACE 2
*/* P GET CPU'S AFFINITY MASK */
         SPACE 2
         LH    RE,PCCACAFM         CPU'S AFFINITY MASK
         DROP  R6                      DROP PCCA ADDRESSABILITY@ZA32144
         SPACE 2
*/* D (YES,DS0724,NO,) DOES AFFINITY MATCH THIS CPU? */
         SPACE 2
         NR    RE,R4               TEST FOR MATCHING AFFINITY.
         BNZ   DS0724              AFFINITY TO THIS CPU. CONTINUE.
         SPACE 2
*/* P GET SYSTEM WIDE CPU ALIVES MASK */
         SPACE 2
         L     R3,FLCCVT               LOCATE THE CVT
         USING CVT,R3
         L     R1,CVTCSD               CSD MASK
         LH    R2,CSDCPUAL-CSD(R1)     CPU ALIVES MASK
         SPACE 2
*/* D (YES,DS0723,NO,) CAN TASK RUN ON ANY CPU? */
         SPACE 2
         NR    R2,R4                   CAN TASK RUN ON ANY CPU?
         BNZ   DS0723                  YES, BUT NOT THIS ONE,
*                                      RESTORE STATUS AND LOOK FOR
*                                      READY WORK
         SPACE 2
*/* P REMOVE AFFINITY IN ORDER TO DISP ABEND */
         SPACE 2
         STH   R2,TCBAFFN              REMOVE AFFINITY AND ABEND
         SPACE 2
*/* P SET R1 FOR 072 ABEND AND PSW TO SVC D */
         SPACE 2
         L     R1,DSABAFFN             072 ABEND CODE
         ST    R1,IHSAGPRS+DSL4        STORE INTO REG 1 SLOT IN IHSA
         LA    R2,CVTQABST             ADDRESS OF SVC D INSTR
         DROP  R3
         ST    R2,IHSACPSW+DSL4        SET PSW TO POINT TO SVC D
         SPACE 2
*/* P (,DS0724) CONTINUE WITH TASK DISPATCH */
         SPACE 2
         B     DS0724                  CONTINUE WITH DISPATCH
         SPACE 2
*/*DS0723: P RESTORE INTERRUPT CODE TO LOCAL LOCK */
         SPACE 2
DS0723   DC    0H'0'
         LH    R1,PSACPULA         LOGICAL CPU ADDRESS.
         L     R3,DSINTPID         INTERRUPT ID.
         CS    R1,R3,ASCBLOCK      RESTORE INTERRUPT ID.
         SPACE 2
*/*DSLOCK22: S SETLOCK:OBTAIN GLOBAL DISPATCHER LOCK */
         SPACE 2
DSLOCK22 DC    0H'0'
*        SETLOCK OBTAIN,TYPE=DISP,MODE=UNCOND,RELATED=('ASCB QUEUE/GSPL*
               /LSPL/PSAANEW',IEAVEDS0,(DSLOCK14,DSLOCK16,DSLOCK17,DSLO*
               CK18,DSLOCK19))
         L     RD,AGSLDISP         OBTAIN DISPATCHER SPECIAL ENTRY PT
         BALR  RE,RD               LOCK MANAGER'S SPECIAL DISP ENTRY
         SPACE 2
*/* P SET UP ADDRESSABILITY TO CVT AND CSD */
         SPACE 2
         L     R6,FLCCVT           CVT ADDRESS
         L     R5,CVTCSD-CVT(R6)   CSD ADDRESS
         SPACE 2
*/* P (,DS054) GET ADDRESS OF NEXT ASCB */
         SPACE 2
         L     R8,ASCBFWDP         GET ADDRESS OF NEXT ASCB
         B     DS054               GO TO MEMORY DISPATCHER.
         SPACE 2
*/*DS0724: P STORE CPUID INTO THE TCB */
         SPACE 2
DS0724   DC    0H'0'
         LH    R6,PSACPULA         CPU ID.
         STH   R6,TCBCCPVI         STORE INTO TCB.
         SPACE 2
*/*DS074: P RESTORE PSATNEW AND PSATOLD */
         SPACE 2
DS074    DC    0H'0'
         ST    R5,PSATNEW          RESTORE TCBNEW.
         ST    R5,PSATOLD          RESTORE TCBOLD.
         SPACE 2                                               @ZP60023
*/* P RESTORE SECONDARY ADDRESS SPACE  */                      @ZP60023
         SR    R4,R4                                           @ZP60023
         IC    R4,TCBPKF           GET TASK KEY                @ZP60023
         LH    R2,TCBRV326         GET SECONDARY ASN           @ZP60023
         L     R1,SETSANAD         GET ROUTINE ADDRESS         @ZP60023
         BALR  RF,R1               SET SECONDARY ASN           @ZP60023
DS0725   DC    0H'0'
         SPACE 2
*/* P RESTORE FLOATING POINT REGISTERS */
         SPACE 2
         LD    R0,IHSAFPR0         *     RESTORE
         LD    R2,IHSAFPR2         *          FLOATING
         LD    R4,IHSAFPR4         *               POINT
         LD    R6,IHSAFPR6         *                    REGISTERS
         SPACE 2
*/* P RESTORE LOCAL SUPERVISOR'S FRR STACK */
         SPACE 2
         LA    R2,IHSAFRRS             ADDRESS OF SAVED STACK
         L     R3,FRRSCURR-FRRS(R2)    ADDRESS OF CURRENT ENTRY
         L     R4,FRRSELEN-FRRS(R2)    LENGTH OF AN ENTRY      @YM03564
         AR    R3,R4               ADDRESS OF END OF STACK     @YM03564
         L     RA,PSANSTK          ADDRESS OF NORMAL STK       @YM03564
         SR    R3,RA               LENGTH OF SAVED STACK       @YM03564
         LA    RB,DSL0(R3)         DUPLICATE LENGTH            @YM03564
         MVCL  RA,R2               MOVED FOR SAVED NRM STACK   @YM03564
         SPACE 2                                               @YM03564
*/* D (NO,DS073,YES,) IS THE CMS LOCK ALSO HELD? */
         SPACE 2
         TM    ASCBFLG1,ASCBCMSH   IS THE CMS LOCK ALSO HELD?
         BZ    DS073               NO. GO AROUND.
DST085   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* P STORE CPU LOCKS HELD IND INTO HIGHEST LOCK HELD IND */
         SPACE 2
*  ENTER FOR CMS LOCK HELD
         OI    PSAHLHI+DSO3,DSCMSHI  TURN ON CMS & LOCAL LK
*                                      HELD INDICATORS
         SPACE 2
*/* P (,DS075) TURN OFF CMS LOCK HELD FLAG */
         SPACE 2
         NI    ASCBFLG1,DSXFF-ASCBCMSH  TURN OFF CMS LOCK HELD FLAG.
         SPACE
         SPACE 2
*/*DS073: P INCREMENT NO. OF CPUS IN THE ADDRESS SPACE */
         SPACE 2
DS073    DC    0H'0'
         L     R1,ASCBCPUS             OBTAIN COUNT OF ACTIVE CPUS
DS073LP  DC    0H'0'
         LR    R2,R1                   DUPLICATE THE COUNT
         LA    R2,DSI1(R2)             INCREMENT THE COUNT BY 1
         CS    R1,R2,ASCBCPUS          UPDATE THE COUNT VIA C&S
         BNZ   DS073LP                 COUNT HAS CHANGED, REPEAT
         SPACE 2
*/* P SET CPU LOCKS HELD IND INTO HIGH LOCK HELD IND */
         SPACE 2
         OI    PSAHLHI+DSO3,DSLLHI    TURN ON LOCAL LK HELD IND
         SPACE 2
*/*DS075: P (,DS082) STORE TOD CLOCK FOR JOB STEP TIMING */
         SPACE 2
DS075    DC    0H'0'
         STCK  LCCADTOD            STORE TOD CLOCK FOR JOB STEP TIMING.
         B     DS082               GO TO LOCAL SUPERVISOR DISPATCHER.
         DROP  RC                  DROP IHSA ADDRESSABILITY
         DROP  R5                  DROP TCB ADDRESSABILITY
         TITLE 'IEAVEDS0 - LOCAL SUPERVISOR DISPATCHER'
***********************************************************************
*                                                                     *
*  LOCAL SUPERVISOR DISPATCHER                                        *
*        THIS SEQUENCE IS ENTERED TO DISPATCH A PREEMPTED LOCAL       *
*        SUPERVISOR WHOSE STATUS HAS BEEN RESTORED IN THE SECTION     *
*        ENTITLED 'INTERRUPTED LOCAL SUPERVISOR' AND TO RE-           *
*        DISPATCH A LOCAL SUPERVISOR ROUTINE WHICH WAS INTERRUPTED    *
*        BUT NOT PREEMPTED.                                           *
*                                                                     *
***********************************************************************
         SPACE 2
*/*DS081: P GET ADDRESSABILITY TO THE IHSA */
         SPACE 2
DS081    DC    0H'0'
         L     RC,ASCBASXB         *
         USING ASXB,RC             *     INTERRUPT HANDLER SAVE AREA
         L     RC,ASXBIHSA         *          ADDRESSABILITY.
         DROP  RC                  *
         USING IHSA,RC             *
         SPACE 2
*/*DS082: P MOVE PSW TO LOW CORE */
         SPACE 2
DS082    DC    0H'0'
         MVC   PSAPSWSV(DSL8),IHSACPSW  MOVE PSW TO LOW CORE.
         SPACE 2
*/* D (NO,DS083,YES,) IS TRACE ACTIVE? */
         SPACE 2
         L     R5,FLCCVT           CVT ADDRESS
         USING CVT,R5              CVT ADDRESSING
         CLI   CVTTRACE+DSL1,DSTRACEM   IS TRACE ACTIVE?
         BNE   DS083               NO. BYPASS.
         DROP  R5                  DROP CVT ADDRESSING
         SPACE 2
*/* S TRDISP:TRACE LOCAL SUPERVISOR ACTIVITY */
         SPACE 2
         L     RA,DSTRDISP         TRACE ADDRESS
         LM    R0,R1,IHSAGPRS      LOAD 0 AND 1 FOR TRACE
         L     RF,IHSAGPRS+DSL60   LOAD 15 FOR TRACE
         BALR  RB,RA               GO TO TRACE
*/*DS083: S IEADISP2:GTF INTERFACE */
         SPACE 2
DS083    DC    0H'0'
         HOOK  EID=IEADISP2,TYPE=P      GO TO GTF
         SPACE 2
*/* P GET ADDRESSABILITY TO TCB */
         SPACE 2
         L     R5,PSATOLD          TCB ADDRESS FROM PSA        @ZA32144
         USING TCB,R5                  GET TCB ADDRESSABILITY  @ZA32144
         SPACE 2
*/* D (NO,DS07247,YES,) IS THERE A TCB? */
         SPACE 2
         LTR   R5,R5               IS IT ZERO (END OF TASK)    @ZA32144
         BZ    DS07247             NO THEN SKIP CPU TIMING     @ZA32144
         SPACE 2
*/* D (NO,DS07247,YES,) DOES TCB HAVE A TQE? */
         SPACE 2
         L     R2,TCBTME           TQE ADDRESS FROM THE TCB.   @ZA32144
         LTR   R2,R2               IS THE A TQE?               @ZA32144
         BNH   DS07247             NO. CONTINUE.               @ZA32144
         SPACE 2
*/* D (NO,DS07243,YES,) IS THE CPU TIMER ON THIS CPU BAD? */
         SPACE 2
         L     R6,PSAPCCAV             GET PCCA ADDRESS        @ZA32144
         USING PCCA,R6                 GET PCCA ADDRESSABILITY @ZA32144
         TM    PCCAINTE,PCCANUIN   IS THE CPU TIMER BAD?       @ZA32144
         BZ    DS07243             NO. GO TO SET CLOCK.        @ZA32144
         SPACE 2
*/* D (YES,DS07241,NO,) MUST TASK RUN ONLY ON THIS CPU? */
         SPACE 2
         L     R4,FLCCVT           CVT ADDRESS.                @ZA32144
         USING CVT,R4              CVT ADDRESSABILITY.         @ZA32144
         CLC   PCCACAFM(DSL2),TCBAFFN TEST FOR MATCHING AFF    @ZA32144
         BE    DS07241             YES. TCB MUST RUN ON THIS CPU. GO
*                                       TO ABEND TASK SINCE CLOCK IS
*                                       BAD ON THIS CPU.       @ZA32144
         SPACE 2
*/* D (YES,DS07247,NO,) ARE THERE ANY CPU TIMERS WORKING? */
         SPACE 2
         L     R3,CVTCSD           CSD ADDRESS.                @ZA32144
         USING CSD,R3              CSD ADDRESSABILITY.         @ZA32144
         L     R1,CSDGDINT         COUNT OF GOOD CPU TIMERS.   @ZA32144
         LTR   R1,R1               ARE THERE ANY?              @ZA32144
         BNZ   DS07247             YES. BYPASS CLOCK SETTING THIS
*                                       DISPATCH.              @ZA32144
         DROP  R3                  DROP CSD ADDRESSABILITY.    @ZA32144
         DROP  R6                  DROP PCCA ADDRESSABILITY.   @ZA32144
         DROP  R5                      DROP TCB ADDRESSABILITY @ZA32144
         SPACE 2
*/*DS07241: P SET REGISTER ONE TO 22F ABEND CODE. */
         SPACE 2
DS07241  DC    0H'0'                                           @ZA32144
         L     R1,DSABTIME         22F ABEND CODE.             @ZA32144
         ST    R1,IHSAGPRS+DSL4    R1 IN IHSA. LOADED AT DISP  @ZA32144
         SPACE 2
*/* P (,DS07247) SET PSW TO POINT TO ABEND INSTRUCTION IN CVT */
         SPACE 2
         LA    R1,CVTQABST         ADDRESS SVC D INSTRUCTION.  @ZA32144
         ST    R1,IHSACPSW+DSL4    SET PSW TO POINT TO SVC D.  @ZA32144
         B     DS07247             CONTINUE WITH DISPATCH.     @ZA32144
         DROP  R4                  DROP CVT ADDRESSABILITY.    @ZA32144
         SPACE 2
*/*DS07243: P RESET THE CPU INTERVAL TIMER. */
         SPACE 2
DS07243  DC    0H'0'                                           @ZA32144
         SPT   IHSACPUT            RESET CPU INTERVAL TIMER.   @ZA32144
DS07247  DC    0H'0'                                           @ZA32144
         SPACE 2
*/* P SET READY WORK DISPATCHED INDICATOR */
         SPACE 2
         OI    LCCADSF2,LCCADSRW       TURN ON READY WORK IND.
         SPACE 2
*/* P RESTORE THE GENERAL PURPOSE REGISTERS */
         SPACE 2
         LM    R0,RF,IHSAGPRS      RESTORE GENERAL PURPOSE REGISTERS.
         SPACE 2
*/* P RESET THE DISPATCHER INDICATOR */
         SPACE 2
         NI    PSASUP1,DSXFF-PSADISP    RESET DISPATCHER INDICATOR.
         SPACE 2
*/* P RESET CURRENT STACK POINTER TO NORMAL */
         SPACE 2
LLSPVPSW DC    0H'0'
         MVC   PSACSTK(DSL4),PSANSTK    RESTORE NORMAL STACK ADDRESS
         SPACE 2
***********************************************************************
*                                                                     *
*          LOAD PSW TO DISPATCH A LOCAL SUPERVISOR ROUTINE            *
*                                                                     *
***********************************************************************
         SPACE 2
*/*LSUPVPSW: R LOAD SUPERVISOR PSW */
         SPACE 2
LSUPVPSW DC    0H'0'
         LPSW  PSAPSWSV            DISPATCH THE LOCAL SUPERVISOR.
         SPACE 4
         DROP  RC                  DROP IHSA REGISTER
         TITLE 'IEAVEDS0 - TASK DISPATCHER'
***********************************************************************
*                                                                     *
*   TASK DISPATCHER                                                   *
*        THIS SEQUENCE IS ENTERED TO SEARCH FOR A READY TASK ON THE   *
*        TCB DISPATCHING QUEUE WITHIN THE ADDRESS SPACE.  THE TASK'S  *
*        STATUS IS RESTORED FROM THE TCB/RB AND THE TASK IS RE-       *
*        DISPATCHED.                                                  *
*                                                                     *
*        THE LOCAL LOCK IS HELD ON ENTRY TO THIS SECTION.             *
*                                                                     *
***********************************************************************
         SPACE 2
*/*DS09: D (NO,DS091,YES,) ANY ASYNCH EXITS? */
         SPACE 2
DS09     DC    0H'0'
         OI    LCCADSF2,LCCADSPL       INDICATE DISP OBTAINED LOCAL LK
         TM    ASCBFLG1,ASCBS3S    TEST FOR ASYNCHRONOUS EXITS
         BZ    DS091               NO.  CONTINUE.
         SPACE 2
*/* D (YES,DS091,NO,) ARE QUIESCE. SRB'S STOPPED? */
         SPACE 2
         SR    R1,R1               CLEAR R1
         CH    R1,ASCBSSRB         TEST FOR STOP QUIESCEABLE SRBS
         BNE   DS091               YES. BYPASS STAGE 3.
         SPACE 2
***********************************************************************
*                                                                     *
*  EXIT TO STAGE III EXIT EFFECTOR.                                   *
*                                                                     *
*  INTERFACE                                                          *
*        R7 - LCCA ADDRESS                                            *
*        R8 - ASCB ADDRESS                                            *
*        R9 - DISPATCHER BASE                                         *
*        R14 - RETURN ADDRESS                                         *
*        R15 - STAGE 3 EP                                             *
*        ALL OTHERS UNDEFINED AND MAY BE DESTROYED IN STAGE 3.        *
*                                                                     *
***********************************************************************
         SPACE
         SPACE 2
*/* S IEA0EF03:STAGE 3 EXIT EFFECTOR */
         SPACE 2
         L     RF,DS0EF03          STAGE 3 EXIT EFFECTOR ENTRY POINT
         BALR  RE,RF               GO TO STAGE 3 EE
         SPACE
*
*        REGISTERS 7, 8 AND 9 ARE RETURNED BY STAGE 3 EE
*
         SPACE
*  FALL THROUGH TO SCAN FOR READY TCB
         SPACE 2
*
*  BEGIN SCAN FOR TOP READY TASK.
*
         SPACE 2
*/*DS091: P GET ADDRESS OF TOP TCB ON ASCB DISP QUEUE */
         SPACE 2
DS091    DC    0H'0'
         L     R6,ASCBASXB         ADDRESS OF THE ASXB.
         USING ASXB,R6             ASXB ADDRESSABILITY.
         L     R6,ASXBFTCB         ADDRESS OF FIRST TCB.
         DROP  R6                  DROP ASXB ADDRESSABILITY.
         SPACE 2
*/* D (NO,DS0921,YES,) TEST FOR END OF TCB QUEUE */
         SPACE 2
         LTR   R6,R6               TEST FOR END OF TCB QUEUE.
         BNZ   DS0921              NO. CONTINUE.
         SPACE
*  EXIT FROM TASK DISPATCHER TO ADDRESS SPACE DISPATCHER
         SPACE 2
*/* D (NO,,YES,DSLOCK25) SUS Q EMPTY REL LK NO STLK */         @Z40FPXJ
*/*DS092: S SETLOCK:(DSLOCK2) RELEASE THE LOCAL LOCK */
         SPACE 2
DS092    DC    0H'0'
DSLOCK2  DC    0H'0'
         SLR   R2,R2               ZERO REG FOR CS             @Z40FPXJ
         SLR   R3,R3               ZERO REG FOR CS             @Z40FPXJ
         L     R4,ASCBLOCK         GET LOCKWORK FOR CS         @Z40FPXJ
         SLR   R5,R5               ZERO REG FOR CS             @Z40FPXJ
         CDS   R4,R2,ASCBLOCK      FREE LOCK IF Q EMPTY        @Z40FPXJ
         BZ    DSLOCK25            Q WAS EMPTY LOCK FREE       @Z40FPXJ
*        SETLOCK RELEASE,TYPE=LOCAL,RELATED=('TCB QUEUE',IEAVEDS0,(DSLO*
               CK1))               RELEASE THE LOCAL LOCK.
         L     RD,DSLLREL          LOCK MANAGER'S BASE REGISTER
         L     RB,DSLLRELD         DISPATCHER SPECIAL ENTRY    @YM03564
         BALR  RE,RB               ENTER L.M. AT SPECIAL ENTRY FOR DISP
DSLOCK25 DS    0H                                              @Z40FPXJ
         NI    PSAHLHI+3,DSXFF-DSLLHI                          @Z40FPXJ
         NI    LCCADSF2,DSXFF-LCCADSPL DISP RELEASED LOCAL LK
DST092   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/*DSLOCK25: S DSSAVE:SAVE STATUS OF PREEMPTED TASK */
         SPACE 2
         BAL   RF,DSSAVE           SAVE STATUS OF PREEMPTED TASK
*   DSSAVE USES REGISTERS 0,1,2,3,14 AND 15.
         SPACE 2
*/*DSLOCK3: S SETLOCK:OBTAIN GLOBAL DISPATCHER LOCK */
         SPACE 2
DSLOCK3  DC    0H'0'
*        SETLOCK OBTAIN,TYPE=DISP,MODE=UNCOND,RELATED=('ASCB QUEUE/GSPL*
               /LSPL/PSAANEW',IEAVEDS0,(DSLOCK14,DSLOCK16,DSLOCK17,DSLO*
               CK18,DSLOCK19))
         L     RD,AGSLDISP         OBTAIN DISPATCHER SPECIAL ENTRY PT
         BALR  RE,RD               LOCK MANAGER'S SPECIAL DISP ENTRY
DST093   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* D (YES,DS052,NO,) WAS MEMORY SWITCH REQUIRED? */
         SPACE 2
         L     R5,PSAANEW          TEST FOR MEMORY SWITCH      @YM02483
         C     R5,PSAAOLD          MEMORY SW IF NE             @YM02483
         BNE   DS052               START AT TOP OF QUEUE       @YM02483
         SPACE 2
*/* P SET UP ADDRESSABILITY TO THE CVT AND CSD */
         SPACE 2
         L     R6,FLCCVT           CVT ADDRESS
         USING CVT,R6              CVT ADDRESSABILITY
         L     R5,CVTCSD           CSD ADDRESS
         DROP  R6                  DROP CVT ADDRESS REGISTER
         SPACE 2
*/* P (,DS054) GET NEXT ASCB ADDRESS */
         SPACE 2
         L     R8,ASCBFWDP         GET NEXT ASCB.
         B     DS054               GO TO TEST IT'S DISPATCHABILITY IN
*                                       THE ADDRESS SPACE DISPATCHER.
         SPACE 2
         SPACE 2
*/* N CS WILL SET ACTIVE ON AND UPDATE CPU ID */               @Z40FPXJ
         SPACE 2
DS0921   DC    0H'0'               ENTER FOR RB WAITING TEST
         USING TCB,R6              TCB ADDRESSABILITY.
         L     R1,TCBXSCT          TCB ACT & CPU ADDR WORD     @Z40FPXJ
         LR    R2,R1               SECOND COPY OF WORD         @Z40FPXJ
         IC    R1,PSACPULA+1       GET CPU LOGICAL ADDR THIS   @Z40FPXJ
*                                  INST ASSUMES THAT THE CPU   @Z40FPXJ
*                                  ADDR WILL REMAIN 1 BYTE     @Z40FPXJ
*                                  IF IT CHANGES THIS INST     @Z40FPXJ
*                                  WILL HAVE TO CHANGE ALSO    @Z40FPXJ
         O     R1,ACTONMSK         TURN ON TCB ACTIVE BIT      @Z40FPXJ
         N     R2,ACTOFMSK         TURN OFF TCB ACTIVE BIT     @Z40FPXJ
         CS    R2,R1,TCBXSCT       CS ACT BIT ON IF NOT        @Z40FPXJ
*                                  ALREADY ON                  @Z40FPXJ
*/*DS0921: P GET ADDRESS OF TOP RB */
         L     R5,TCBRBP           LOAD ADDRESS OF TOP RB.
         BNE   DS0922
         USING RBSECT,R5           RB ADDRESSABILITY.
         SPACE 2
*/* D (NO,DS0922,YES,) IS RB WAITING? */
         SPACE 2
         CLI   RBWCF,DSX0          IS THE RB WAITING.
         BNE   DS09211             YES.  CANNOT DISPATCH
*/*DS0922: D (NO,DS093,YES,) IS TCB NON DISPTACH.? */
         LH    RD,TCBFLGS4        TEST TO SEE IF ANY PRIMARY NON-
*                                       DISPATCHABILITY BITS ARE SET.
         LTR   RD,RD               ANY BITS ON?                @YM03564
         BZ    DS0932              NO. DISPATCHABLE. CONTINUE. @YM03564
DS09211  NI    TCBXSCT1-TCB(R6),DSXFF-TCBACTIV ACTIVE=OFF      @Z40FPXJ
DST094   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/*DS0931: P GET ADDRESS OF NEXT TCB */
         SPACE 2
DS0931   DC    0H'0'
         L     R6,TCBTCB           RB IS WAITING. GET NEXT TCB.
         SPACE 2
*/* D (YES,DS092,NO,DS0921) IS THIS THE END OF TCB QUEUE? */
         SPACE 2
         LTR   R6,R6               IS THIS THE END OF TCB QUEUE?
         BNZ   DS0921              NO. GO TO TEST WAIT COUNT.
         B     DS092               END OF QUEUE. GO TO MEMORY DISP.
         SPACE 2
*/* D (NO,DS0931,YES,) IS IT A REDISPATCH? */
         SPACE 2
DS0922   DC    0H'0'               ENTER FOR DISPATCHABILITY TESTS.
         CLC   PSACPULA,TCBCCPVI   TCB ACTIVE ON THIS CPU?
         BNE   DS0931              NO
         C     R6,PSATOLD          COMPARE CHOSEN TCB AGAINST OLD.
         BNE   DS0931              NOT A RE-DISPATCH.          @YM07640
         CLI   RBWCF,DSX0          IS THE RB WAITING.
         BNE   DS0931              YES.  CANNOT DISPATCH
         LH    RD,TCBFLGS4        TEST TO SEE IF ANY PRIMARY NON-
*                                       DISPATCHABILITY BITS ARE SET.
         LTR   RD,RD               ANY BITS ON?                @YM03564
         BNZ   DS0931              NO. DISPATCHABLE. CONTINUE. @YM03564
DST095   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
DST096   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
DST097   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* D (NO,DS094,YES,) IO OR EXT INT CAUSED ENTRY? */           @Z40FPXJ
         SPACE 2
         L     R1,LCCAITOD         IS THIS RE-DISP A RESULT OF AN
*                                  IO OR EXT INTERRUPT. R1 NE ZERO
*                                  IF SO, MUST JST             @YM07640
         LTR   R1,R1               IS IT ZERO                  @YM07640
         BZ    DS094               YES, DON'T JST              @Z40FPXJ
         SPACE 2
*/* S           DSJST: CALCULATE JST FOR TCB */                @Z40FPXJ
*/* P SET TOD CLOCK FOR JOB STEP TIMING */                     @Z40FPXJ
*/*DS094: P (,DS095) MOVE RB OLD PSW TO LOW CORE */            @Z40FPXJ
         SPACE 2
         BAL   RE,DSJST            CALCULATE JST               @YM07640
         STCK  LCCADTOD            SET TOD CLOCK FOR JST       @Z40FPXJ
DS094    DS    0H                                              @Z40FPXJ
         MVC   PSAPSWSV(DSL8),RBOPSW MOVE RB OLD PSW TO L.C.   @Z40FPXJ
         LA    RE,DS095                EXIT ADDRESS FOR CPUTIME@ZA32144
         B     DSCPUTIM                GO PROCESS CPU TIMER    @ZA32144
         SPACE 2
*/*DS0932: P GET TCB'S AFFINITY MASK */
         SPACE 2
DS0932   DC    0H'0'
         LH    RC,TCBAFFN          TCB'S AFFINITY MASK.
         SPACE 2
*/* D (NO,DS09325,YES,) IS TCB AFFINITY SPECIFIED? */
         SPACE 2
         C     RC,DSCPUAFF         IS TCB AFFINITY SPECIFIED?  @YM04737
         BE    DS09325             NO. CONTINUE.               @YM04737
         LTR   RC,RC               IS TCB AFFINITY SPECIFIED?
         BZ    DS09325             NO. CONTINUE.
         SPACE 2
*/* P GET CPU'S AFFINTIY MASK */
         SPACE 2
         L     RE,PSAPCCAV         PCCA ADDRESS
         USING PCCA,RE             PCCA ADDRESSABILITY
         LH    RE,PCCACAFM         CPU'S AFFINITY MASK
         DROP  RE                  DROP PCCA ADDRESSABILITY
         SPACE 2
*/* D (YES,DS09325,NO,) DOES AFFINITY MATCH THIS CPU? */
         SPACE 2
         NR    RE,RC               TEST FOR MATCHING AFFINITY  @YM04737
         BNZ   DS09325             AFFINITY MATCH. CONTINUE WITH DISP
         SPACE 2
*/* P GET SYSTEM WIDE CPU ALIVES MASK */
         SPACE 2
         L     R3,FLCCVT               LOCATE THE CVT
         USING CVT,R3
         L     R1,CVTCSD               CSD MASK
         LH    R2,CSDCPUAL-CSD(R1)     CPU ALIVES MASK
         SPACE 2
*/* D (YES,DS092,NO,) CAN TASK RUN ON ANY CPU? */
         SPACE 2
         NR    R2,RC                   CAN TASK RUN ON ANY CPU?
         BZ    DS09322                 YES, BUT NOT THIS ONE,  @Z40FPXJ
*                                      RELEASE LOCAL LK AND LOOK FOR
*                                      READY WORK
         NI    TCBXSCT1-TCB(R6),DSXFF-TCBACTIV ACTIVE=OFF      @Z40FPXJ
         B     DS092                   LOOK FOR READY WORK     @Z40FPXJ
         SPACE 2
*/* P REMOVE AFFINITY IN ORDER TO DISP ABEND */
         SPACE 2
DS09322  DS    0H                                              @Z40FPXJ
         STH   R2,TCBAFFN              REMOVE AFFINITY AND ABEND
         SPACE 2
*/* P SET R1 FOR 072 ABEND AND PSW TO SVC D */
         SPACE 2
         L     R1,DSABAFFN             22F ABEND CODE
         ST    R1,TCBGRS1              STORE INTO REG 1 SLOT IN IHSA
         LA    R2,CVTQABST             ADDRESS OF SVC D INSTR
         DROP  R3
         ST    R2,RBOPSW+DSL4          SET PSW TO POINT TO SVC D
         SPACE 2
*/* P (,DS09325) CONTINUE WITH TASK DISPATCH */
         SPACE 2
         EJECT
*
*  A DISPATCHABLE TASK HAS BEEN CHOSEN - BEGIN TO RESTORE IT'S STATUS
*
         SPACE 2
*/*DS09325: D (NO,DS0933,YES,) PREEMPT ANOTHER TASK IN SAME MEMORY? */
         SPACE 2
DS09325  DC    0H'0'
         SR    R1,R1                                           @Z40FPXJ
         C     R1,PSATOLD          ARE WE PREEMPTING LWR PRTY  @Z40FPXJ
*                                       TASK WITHIN THIS ADDRESS SPACE.
         BE    DS0933              NO. CONTINUE.
DST097A  DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* S DSSAV1:SAVE TASK'S STATUS */
         SPACE 2
*  SAVE STATUS OF PREEMPTED TASK IN THE SAME ADDRESS SPACE
         BAL   RF,DSSAV1           GO TO SPECIAL SAVE STATUS ENTRY.
*   DSSAV1 USES REGISTERS 0,1,2,3,14 AND 15.
DS0933   DC    0H'0'
         SPACE 2
IEAVDSTC DS    0H                  ENTRY FOR TCTL              @Z40FPXJ
******** THIS ENTRY POINT IS FOR TCTL. TCTL HAS SELECTED       @Z40FPXJ
******** A TCB TO BE DISPATCHED AND HAS SET UP ALL REGS        @Z40FPXJ
******** FOR THE DISPATCHER. THE TCB HAS PASSED ALL TESTS      @Z40FPXJ
******** FOR DISPATCHABILITY. THIS IS ASSURED BY TCTL          @Z40FPXJ
         SPACE 2
*/*DS0933: P RESTORE THE FLOATING POINT REGISTERS */
         SPACE 2
*  RESTORE FLOATING POINT REGISTERS
         L     R3,DSPREFIX         TCB PREFIX DECREMENT VALUE.
         AR    R3,R6               TCB PREFIX ADDRESS.
         USING TCBFIX,R3
         LD    R0,TCBFRS0          LOAD
         LD    R2,TCBFRS2               FLOATING
         LD    R4,TCBFRS4                    POINT
         LD    R6,TCBFRS6                         REGISTERS.
         DROP  R3
         SPACE 2
*/* D (NO,DS0938,YES,) IS THERE A TQE? */
         SPACE 2
         LA    RE,DS0938               EXIT ADDRESS FOR CPUTIME@ZA32144
DSCPUTIM DS    0H                      BEGIN CPU TIME PROCESS  @ZA32144
         L     R4,TCBTME           ADDRESS OF TQE
         LTR   R4,R4               TEST FOR POSITIVE ADDRESS.
         BNPR  RE                      NO. CONTINUE            @ZA32144
         SPACE 2
*/* D (YES,DS0937,NO,) IS THE CPU TIMER GOOD? */
         SPACE 2
         L     R3,PSAPCCAV         PCCA ADDRESS FROM THE PSA.
         USING PCCA,R3             PCCA ADDRESSABILITY.
         TM    PCCAINTE,PCCANUIN   IS TIMER OK?
         BZ    DS0937              YES. GO TO SET TIMER.
         SPACE 2
*/* D (YES,DS0936,NO,) MUST TASK RUN ONLY ON THIS CPU? */
         SPACE 2
         L     R4,FLCCVT           CVT ADDRESS.
         USING CVT,R4              CVT ADDRESSABILITY.
         CLC   PCCACAFM(DSL2),TCBAFFN TEST FOR MATCHING AFFINITY MASKS
         BE    DS0936              YES. TCB HAS SPECIFIED AFFINITY TO
*                                       THIS CPU ONLY. GO TO ABEND TASK
*                                       SINCE THIS CPU'S TIMER IS BAD.
         DROP  R3                  DROP PCCA ADDRESSABILITY.
         SPACE 2
*/* D (YES,DS0938,NO,) ARE THERE ANY GOOD CPU TIMERS? */
         SPACE 2
         L     R3,CVTCSD           CSD ADDRESS.
         USING CSD,R3              CSD ADDRESSABILITY.
         L     R1,CSDGDINT         COUNT OF GOOD CPU TIMERS.
         LTR   R1,R1               ARE THERE ANY GOOD TIMERS?
         BNZR  RE                  YES. BYPASS SETTING TIMER   @ZA32144
*                                       THIS CPU THIS DISPATCH.
         DROP  R3                  DROP CSD ADDRESSABILITY.
         SPACE 2
*/*DS0936: P SET REG 1 TO 22F ABEND CODE */
         SPACE 2
DS0936   DC    0H'0'
         L     R1,DSABTIME         22F ABEND CODE.
         ST    R1,TCBGRS1          STORE INTO TCB - TO BE LOADED AT
*                                       DISPATCH.
         SPACE 2
*/* P (,DS0938) SET RBOPSW TO POINT TO SVC ABEND INSTRUCTION IN CVT */
         SPACE 2
         LA    R1,CVTQABST         ADDRESS OF SVC D INSTR IN CVT.
         ST    R1,RBOPSW+DSL4      STORE INTO RBOPSW.
         BR    RE                  EXIT AFFINITY CPU TIMER CHK @ZA32144
         DROP  R4                  DROP CVT ADDRESSABILITY.
         SPACE 2
*/*DS0937: P SET CPU INTERVAL TIMER */
         SPACE 2
DS0937   DC    0H'0'
*  STORE TQE TIME REMAINING INTO CPU INTERVAL TIMER.
         USING TQE,R4              TQE ADDRESSABILITY.
         SPT   TQEVAL              SET CPU INTERVAL TIMER.
         BR    RE                      EXIT FROM CPU TIME PROC @ZA32144
         DROP  R4
         SPACE 2
         SPACE 2
DS0938   DC    0H'0'
         SPACE 2
*/*DS0938: P SET PSATNEW AND PSATOLD TO THIS TCB'S ADDRESS */
         SPACE 2
         ST    R6,PSATNEW          SET PSATNEW AND PSATOLD TO THE
         ST    R6,PSATOLD               ADDRESS OF THIS TCB.
         SPACE 2                                               @ZP60023
*/* P RESTORE SECONDARY ADDRESS SPACE  */                      @ZP60023
         SR    R4,R4                                           @ZP60023
         IC    R4,TCBPKF           GET TASK KEY                @ZP60023
         LH    R2,TCBRV326         GET SECONDARY ASN           @ZP60023
         L     R1,SETSANAD         GET ROUTINE ADDRESS         @ZP60023
         BALR  RF,R1               SET SECONDARY ASN           @ZP60023
         SPACE 2
*/* P STORE TOD CLOCK FOR JOB STEP TIMING */
         SPACE 2
         STCK  LCCADTOD            SET TOD CLOCK FOR JOB STEP TIMING.
*  FALL THROUGH TO NEXT SECTION TO CONTINUE DISPATCH OF TASK.
*
         SPACE 2
*/* P MOVE RB OPSW TO LOW CORE */
         SPACE 2
         MVC   PSAPSWSV(DSL8),RBOPSW    MOVE RB OLD PSW TO LOW CORE
         SPACE 2
*/*DS0935: P (CHNG,DS0935,OK,) CS TO INCR NUMBER OF CPUS */    @Z40FPXJ
         SPACE 2                                               @ZA20174
         L     R1,ASCBCPUS         NUMB CPUS IN ADDRESS SPACE  @Z40FPXJ
DS0935   DS    0H                                              @Z40FPXJ
         LA    R3,DSI1(R1)         INCREMENT FOR THIS CPU.     @Z40FPXJ
         CS    R1,R3,ASCBCPUS      REPLACE UPDATED COUNT       @Z40FPXJ
         BC    DSCC4,DS0935        CHANGED. GO TRY AGAIN.      @Z40FPXJ
         SPACE 2                                               @ZA20174
*/* D (NO,DS095,YES,) WAS ENTRY FROM TCTL ? */                 @ZA18126
         SPACE 2                                               @ZA20174
         SETLOCK TEST,TYPE=LOCAL,BRANCH=(HELD,DS095)           @ZA18126
         SPACE 1                                               @ZA18126
*        DISPATCHER HAS BEEN ENTERED FROM IEAVETCL. BECAUSE    @ZA18126
*        OF AN INTERSECT BETWEEN TCTL AND STATUS THIS          @ZA18126
*        EVENT SEQUENCE MUST REMAIN IN ORDER:                  @ZA18126
*            1. INCREMENT ASCBCPUS                             @ZA18126
*            2. CLEAR CDAL OF TCTL BIT                         @ZA18126
         SPACE 2                                               @ZA18126
*/* P (,DS0955) TURN OFF CDALTCTL BIT */                       @ZA18126
         SPACE 2                                               @ZA20174
         L     R2,PSACDAL          THIS CPU'S CDAL ADDRESS     @ZA18126
         USING CDAL,R2             CDAL ADDRESSABILITY         @ZA18126
         NI    CDALDSP4,DSXFF-CDALTCTL TURN OFF TCTL BIT       @ZA18126
         B     DS0955              LOCAL LOCK NOT HELD - SKIP  @ZA18126
         DROP  R2                                              @ZA18126
         SPACE 2                                               @ZA18126
*/*DS095: D (NO,DSLOCK4,YES,) LCL LOCK SUSPEND Q EMPTY?*/      @ZA20174
*/* P (,DSLOCK45) RELEASE LOCAL LOCK NO SETLOCK*/              @ZA20174
         SPACE 2                                               @ZA20174
DS095    DS    0H                                              @Z40FPXJ
         SLR   R2,R2               ZERO REG FOR CS             @Z40FPXJ
         SLR   R3,R3               ZERO REG FOR CS             @Z40FPXJ
         L     R4,ASCBLOCK         GET LOCKWORD FOR CS         @Z40FPXJ
         SLR   R5,R5               ZERO REG FOR CS             @Z40FPXJ
         CDS   R4,R2,ASCBLOCK      FREE LK IF Q IS EMPTY       @Z40FPXJ
         BZ    DSLOCK45            Q EMPTY LOCK IS FREE        @Z40FPXJ
         SPACE 2                                               @ZA20174
*/*DSLOCK4: S SETLOCK:RELEASE LOCAL LOCK */
         SPACE 2
DSLOCK4  DS    0H                                              @Z40FPXJ
*        SETLOCK RELEASE,TYPE=LOCAL,RELATED=('TCB QUEUE',IEAVEDS0,(DSLO*
               CK1))
         L     RD,DSLLREL          LOCK MANAGER'S BASE REGISTER
         L     RB,DSLLRELD         DISPATCHER SPECIAL ENTRY    @YM03564
         BALR  RE,RB               ENTER L.M. AT SPECIAL ENTRY FOR DISP
DSLOCK45 DS    0H                                              @Z40FPXJ
         NI    PSAHLHI+3,DSXFF-DSLLHI                          @Z40FPXJ
         NI    LCCADSF2,DSXFF-LCCADSPL CLEAR DISP OBTAINED LOCAL LK
DST100   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/*DS0955: P CHECK FOR TRACE ACTIVE */                         @Z40FPXJ
*/*DSLOCK45: D (NO,DS096,YES,) IS TRACE ACTIVE? */
         SPACE 2
DS0955   DS    0H                                              @Z40FPXJ
         L     RB,FLCCVT           CVT ADDRESS.
         USING CVT,RB
         CLI   CVTTRACE+DSL1,DSTRACEM   IS TRACE ACTIVE?
         BNE   DS096               NO. BYPASS.
DST100A  DC    0H'0'               *** TEST LABEL ***
         DROP  RB
         SPACE 2
*/* S TRDISP:TRACE TCB ACTIVITY */
         SPACE 2
         L     RA,DSTRDISP         TCB TRACE ENTRY POINT.
         LM    R0,R1,TCBGRS0       RESET 0 AND 1 FOR TRACE
         L     RF,TCBGRS15         RESET 15 FOR TRACE
DST100B  DC    0H'0'               *** TEST LABEL ***
         BALR  RB,RA               GO TO TRACE OR BR11 RETURN.
DST101   DC    0H'0'               *** TEST LABEL ***
LOADPSA5 DC    0H'0'               ***** FOR TSO TEST *****
         SPACE 2
*/*DS096: S IEADISP3:GTF INTERFACE */
         SPACE 2
DS096    DC    0H'0'
         HOOK  EID=IEADISP3,TYPE=P   GO TO GTF THROUGH THE MC INSTR.
         SPACE 2
*/* P SET READY WORK DISPATCHED INDICATOR */
         SPACE 2
         OI    LCCADSF2,LCCADSRW       TURN ON READY WORK IND.
         SPACE 2
*/* P PURGE OLD NORMAL FRR STACK */
         SPACE 2
         SETFRR F,WRKREGS=(R1,R2)  PURGE THE NORMAL STACK
         SPACE 2
*/* P RELOAD THE GENERAL PURPOSE REGISTERS */
         SPACE 2
         LM    R0,RF,TCBGRS        RELOAD GENERAL PURPOSE REGISTERS
         DROP  R6                  DROP TCB BASE REGISTER.
         DROP  R5                  DROP RB ADDRESSABILITY.
         SPACE 2
*/* P RESET DISPATCHER INDICATOR */
         SPACE 2
         NI    PSASUP1,DSXFF-PSADISP-PSATCTL RESET DISP & TCTL @Z40FPXJ
         SPACE 2
*/* P RESET NORMAL STACK TO CURRENT */
         SPACE 2
LTASKPSW DC    0H'0'
         MVC   PSACSTK(DSL4),PSANSTK    RESET NORMAL STACK TO CURRENT.
         SPACE 2
***********************************************************************
*                                                                     *
*              LOAD PSW TO DISPATCH A TASK                            *
*                                                                     *
***********************************************************************
         SPACE 2
*/*TASKPSW: R LOAD TASK'S PSW */
         SPACE 2
TASKPSW  DC    0H'0'
DSTSKPSW DC    0H'0'
         LPSW  PSAPSWSV            DISPATCH THE TASK
         TITLE 'IEAVEDS0 - SAVE STATUS'
***********************************************************************
*                                                                     *
*    SAVE STATUS SUBROUTINE                                           *
*                                                                     *
*        THIS SUBROUTINE IS ENTERED TO SAVE THE STATUS OF A TASK      *
*        OR LOCAL SUPERVISOR ROUTINE WHICH IS BEING PREEMPTED FOR     *
*        HIGHER PRIORITY WORK.  STATUS SAVING OF THE SYSTEM WAIT      *
*        TASK IS ALSO DONE IN THIS SUBROUTINE.                        *
*                                                                     *
*        INPUT:                                                       *
*              R7 - LCCA ADDRESS                                      *
*              R8 - ASCB ADDRESS                                      *
*              R9 - BASE                                              *
*              R15 - RETURN ADDRESS                                   *
*        WORK:                                                        *
*              R0 - R3 - WORK REGS                                    *
*              R14 - USED AS RETURN REGISTER FROM JOB STEP TIMING     *
*              NO OTHER REGISTERS ARE USED IN THIS SEQUENCE.          *
*                                                                     *
***********************************************************************
         SPACE 2
*/*DSSAVE: D (YES,DSSAV2,NO,) IS LOCAL LOCK HELD? */
         SPACE 2
DSSAVE   DC    0H'0'
         SR    R1,R1
         SETLOCK TEST,TYPE=LOCAL,BRANCH=(HELD,DSSAV2)
         SPACE 2
*/* D (NO,DST106A,YES,) IS THERE A TCB? */
         SPACE 2
         C     R1,PSATOLD          TEST FOR A TCB
DST101A  DC    0H'0'               *** TEST LABEL ***
         BCR   DSCC8,RF            NONE. RETURN.
         SPACE
DST102   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* D (YES,DSSAV3,NO,) IS IT THE WAIT TASK? */
         SPACE 2
         C     R8,DSWASCB          TEST FOR THE WAIT TASK.
         BE    DSSAV3              YES. GO TO SPECIAL WAIT PROCESSING
DST103   DC    0H'0'               *** TEST LABEL ***
         EJECT
*
*  SAVE STATUS FOR A PREEMPTED TASK
*
         SPACE 2
*/*DSSAV1: P SAVE STATUS FOR A PREEMPTED TASK */
         SPACE 2
DSSAV1   DC    0H'0'
         SPACE
         L     R3,PSATOLD          TCB ADDRESS.
         USING TCB,R3              TCB ADDRESSING.
         SPACE 2
*/* P SAVE FLOATING POINT REGISTERS */
         SPACE 2
*  SAVE FLOATING POINT REGS
         L     R2,DSPREFIX         PREFIX VALUE
         AR    R2,R3               TCB PREFIX ADDRESSING.
         USING TCBFIX,R2           TCB PREFIX ADDRESSING.
         STD   R0,TCBFRS0          *  SAVE
         STD   R2,TCBFRS2          *    FLOATING
         STD   R4,TCBFRS4          *      POINT
         STD   R6,TCBFRS6          *        REGISTERS
         SPACE
         DROP  R2                  DROP TCB PREFIX REG.
         SPACE 2
*/* D (NO,DSSAV10,YES,) TEST FOR TQE */
         SPACE 2
         L     R2,TCBTME           TQE ADDRESS
         LTR   R2,R2               TEST FOR POSITIVE ADDRESS
         BNH   DSSAV10             NO. CONTINUE.
         SPACE 2
*/* D (NO,DSSAV10,YES,) IS CPU TIMER WORKING? */
         SPACE 2
         L     R1,PSAPCCAV         PCCA ADDRESS.
         USING PCCA,R1             PCCA ADDRESSABILITY.
         TM    PCCAINTE,PCCANUIN   IS THIS CPU'S TIMER OK?
         BO    DSSAV10             NO. BYPASS SAVING OF TIMER.
         DROP  R1                  DROP PCCA ADDRESSABILITY.
         SPACE 2
* SINCE THE INTERRUPT HANDLERS NOW STORE THE CPU TIMER AND SET THE CPU
* TIMER TO A HIGH VALUE, THE DISPATCHER NOW SHOULD ONLY STORE THE CPU
* TIMER WHEN THE REASON FOR THE TASK LOSING CONTROL IS NOT AN INTERRUPT
* NOR A SUSPENSION FOR A LOCK. E.G. THE TASK ISSUED WAIT OR THE TASK
* ISSUED ENQUEUE FOR A RESOURCE NOT IMMEDIATELY AVAILABLE      @ZA32144
         SPACE 2
*/* P SAVE CPU INTERVAL TIMER VALUE INTO TQE */
         SPACE 2
         USING TQE,R2              R2 HAS TQE ADDRESS
         L     R0,TQEVAL           GET LEFT HALF OF TQE VALUE  @ZA32144
         L     R1,TQEVAL+DSL4      AND RIGHT HALF FOR COMPARE  @ZA32144
         STPT  TQEVAL              SAVE TIMER VALUE
         C     R0,TQEVAL           IS TQE EQUAL TO CURRENT TIME@ZM49527
         BH    DSTIMEHI            TQE IS HIGH LEAVE CURRENT   @ZA32144
         BL    DSTORTQE            TQE IS LOW STORE IT BACK    @ZA32144
         CL    R1,TQEVAL+DSL4      IS TQE LOW SECOND HALF      @ZA32144
         BNL   DSTIMEHI            NOT LOW LEAVE CURRENT       @ZA32144
DSTORTQE ST    R0,TQEVAL           STORE LEFT HALF OF TQE VALUE@ZA32144
         ST    R1,TQEVAL+DSL4      AND RIGHT HALF FOR TASK TIME@ZA32144
         DROP  R2
         SPACE 2                                               @YM03564
*/* P RESET TIMER TO A HIGH VALUE */
         SPACE 2                                               @YM03564
DSTIMEHI SPT   DSHITIME            SET CPU TIMER TO HIGH VALUE @ZA32144
         SPACE 2
*/*DSSAV10: S DSJST:CALCULATE JOB STEP TIME */
         SPACE 2
DSSAV10  DC    0H'0'
         BAL   RE,DSJST            GO TO CALCULATE JOB STEP TIME.
*   DSJST USES REGISTERS 0,1,2,3 AND 14.
         SPACE 2
*/*DSSAV11: P (CHNG,DSSAV11,OK,) C & S TO CLEAR TCB ACTIVE BIT AND
*/*CPU ID*/                                                    @ZA20174
         SPACE 2
DST106   DC    0H'0'               *** TEST LABEL ***
         L     R3,PSATOLD              REEST TCB ADDR
         L     R0,TCBXSCT          GET TCB INTERSECT WORD      @ZA20174
DSSAV11  DC    0H'0'                                           @ZA20174
         LR    R2,R0               COPY VALUE FOR SWAP OP INIT @ZA20174
         N     R2,ACTCPVOF         CLEAR ACTIV/CCPVI IN SWAP OP@ZA20174
         CS    R0,R2,TCBXSCT       CLEAR ACTIV/CCPVI IN TCB    @ZA20174
         BC    DSCC4,DSSAV11       UPDATE FAILED, RETRY        @ZA20174
         DROP  R3                  DROP TCB BASE REGISTER.
         SPACE 2
*/*DSSAV12: P (CHNG,DSSAV12,OK,) C & S TO DECREMENT COUNT OF CPU'S IN
*/*ASCB */
         SPACE 2
         L     R3,ASCBCPUS         *
DSSAV12  DC    0H'0'               *
         LR    R2,R3               *  DECREMENT COUNT OF THE
         BCTR  R2,DSI0             *    NUMBER OF CPU'S ACTIVE
         CS    R3,R2,ASCBCPUS      *    IN THIS ADDRESS SPACE.
         BC    DSCC4,DSSAV12       *
         SPACE 2
*/*DSSAV13: P ZERO PSATNEW AND PSATOLD */                      @ZA20174
         SPACE 2
DSSAV13  DC    0H'0'                                           @ZA20174
         ST    R1,PSATNEW          ZERO OUT PSATNEW
         ST    R1,PSATOLD          ZERO OUT PSATOLD
         SPACE 2
*/*DST106A: R RETURN */
DST106A  DC    0H'0'               *** TEST LABEL ***
         BR    RF                  RETURN
         EJECT
*
*  SAVE LOCAL SUPERVISOR INFORMATION
*        R1 IS  ZERO ON ENTRY.
*
DSSAV2   DC    0H'0'
         SPACE 2
*/*DSSAV2: P GET IHSA ADDRESS */
         SPACE 2
         L     R3,ASCBASXB         ASXB ADDRESS
         USING ASXB,R3
         L     R3,ASXBIHSA         IHSA ADDRESS
         DROP  R3
         USING IHSA,R3
         SPACE 2
*/* P STORE FLOATING POINT REGISTERS */
         SPACE 2
         STD   R0,IHSAFPR0         *    STORE
         STD   R2,IHSAFPR2         *         FLOATING
         STD   R4,IHSAFPR4         *              POINT
         STD   R6,IHSAFPR6         *                   REGISTERS.
         SPACE 2
*/* P SAVE PSATNEW AND PSATOLD */
         SPACE 2
         L     R2,PSATNEW          *    STORE
         L     RE,PSATOLD          *         PSATNEW
         ST    R2,IHSANTCB         *              AND
         ST    RE,IHSAOTCB         *                   PSATOLD
         SPACE 2
*/* D (NO,DSSAV22,YES,) IS THERE A TCB? */
         SPACE 2
         LTR   RE,RE               TEST FOR TCB ADDRESS.
         BZ    DSSAV22             NO. BYPASS TIMER TESTS.
         SPACE 2
*/* D (NO,DSSAV22,YES,) IS THERE A TQE FOR THIS TCB? */
         SPACE 2
         USING TCB,RE              TCB ADDRESSABILITY.
         L     R2,TCBTME           TQE ADDRESS FROM TCB.
         LTR   R2,R2               IS THERE A TQE?
         BNH   DSSAV22             NO. BYPASS TIMER SETTING.
         DROP  RE                  DROP TCB ADDRESSABILITY.
         SPACE 2
*/* D (NO,DSSAV22,YES,) IS THIS CPU'S TIMER OK? */
         SPACE 2
         L     R1,PSAPCCAV         PCCA ADDRESS.
         USING PCCA,R1             PCCA ADDRESSABILITY.
         TM    PCCAINTE,PCCANUIN   IS THE CPU TIMER OK?
         BO    DSSAV22             NO. BYPASS TIMER SETTINGS.
         SPACE 2
* SINCE THE INTERRUPT HANDLERS NOW STORE THE CPU TIMER AND SET THE CPU
* TIMER TO A HIGH VALUE, THE DISPATCHER NOW SHOULD ONLY STORE THE CPU
* TIMER WHEN THE REASON FOR THE TASK LOSING CONTROL IS NOT AN INTERRUPT
* NOR A SUSPENSION FOR A LOCK. E.G. THE TASK ISSUED WAIT OR THE TASK
* ISSUED ENQUEUE FOR A RESOURCE NOT IMMEDIATELY AVAILABLE      @ZA32144
         SPACE 2
*/* P SAVE CPU INTERVAL TIMER INTO IHSA */
         SPACE 2
         L     R0,IHSACPUT         GET LEFT HALF OF IHSA VALUE @ZA32144
         L     R1,IHSACPUT+DSL4    AND RIGHT HALF FOR COMPARE  @ZA32144
         STPT  IHSACPUT            SAVE CPU INTERVAL TIMER VALUE
         C     R0,IHSACPUT         IHSA   EQUAL TO CURRENT TIME@ZM49527
         BH    DSBIGTIM            IHSA IS HIGH LEAVE CURRENT  @ZA32144
         BL    DSTORHSA            IHSA IS LOW STORE IT BACK   @ZA32144
         CL    R1,IHSACPUT+DSL4    IS IHSA LOW SECOND HALF     @ZA32144
         BNL   DSBIGTIM            NOT LOW LEAVE CURRENT       @ZA32144
DSTORHSA ST    R0,IHSACPUT         STORE LEFT HALF OF IHSA VAL @ZA32144
         ST    R1,IHSACPUT+DSL4    AND RIGHT HALF FOR TASK TIME@ZA32144
         SPACE 2                                               @YM03564
*/* P SET CPU TIMER TO HIGH VALUE */
         SPACE 2                                               @YM03564
DSBIGTIM DS    0H                                              @ZA32144
         SPT   DSHITIME            SET CPU INTERVAL TIMER TO X'7F---F'
         SPACE 2
*/*DSSAV22: P SAVE LOCAL SUPERVISOR'S FRR STACK */
         SPACE 2
DSSAV22  DC    0H'0'
         LR    R1,RF                   SAVE REG 15             @YM03564
         LA    R2,IHSAFRRS             LOCATE FRR SAVE AREA ADDR
         L     RE,PSANSTK          NORMAL STACK LOCATION       @YM03564
         L     R3,FRRSCURR-FRRS(RE) CURRENT ENTRY              @YM03564
         L     RF,FRRSELEN-FRRS(RE) LENGTH OF CURRENT ENTRY    @YM03564
         AR    R3,RF               ADDRESS OF LAST BYTE        @YM03564
         SR    R3,RE               LENGTH OF STACK TO SAVE     @YM03564
         LA    RF,DSL0(R3)         DUPLICATE LENGTH            @YM03564
         MVCL  R2,RE                   MOVE THE STACK TO SAVE AREA
         LR    RF,R1                   RESTORE R15
         SPACE 2
*/* S DSJST:CALCULATE JOB STEP TIME */
         SPACE 2
         BAL   RE,DSJST            GO TO CALCULATE JOB STEP TIME
*   DSJST USES REGISTERS 0,1,2,3 AND 14.
         SPACE
         SPACE 2
*/* P DECREMENT COUNT OF CPUS ACTIVE IN ADDR SPACE */
         SPACE 2
         L     R1,ASCBCPUS             OBTAIN CURRENT CPUS COUNT
DSSAV22A DC    0H'0'
         LR    R2,R1                   DUPLICATE THE COUNT
         BCTR  R2,DSL0                 DECREMENT THE COUNT
         CS    R1,R2,ASCBCPUS          UPDATE THE COUNT
         BNZ   DSSAV22A                REPEAT IF COUNT HAD CHANGED
*                                       GO TO CLEAR HLHI.
         SPACE 2
*/* D (NO,DSSAV20,YES,) IS CMS LOCK HELD? */
         SPACE 2
         TM    PSAHLHI+DSO3,DSCMSHI     IS THE CMS LOCK HELD?
         BZ    DSSAV20                 NO, CONTINUE.
DST108   DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* P SET CMS LOCK HELD BIT IN ASCB */
         SPACE 2
         OI    ASCBFLG1,ASCBCMSH   SET CMS LOCK HELD BIT IN THE ASCB
         SPACE 2
*/*DSSAV20: P STORE INTERRUPT ID INTO LOCAL LOCK */
         SPACE 2
DSSAV20  DC    0H'0'               ENTER TO CLEAR HLHI.
         L     R1,DSINTPID         YES. STORE INTERRUPT ID
         ST    R1,ASCBLOCK              INTO THE LOCAL LOCK.
         SPACE 2
*/* P CLEAR CMS AND LOCAL LOCK HELD INDICATORS */
         SPACE 2
         NI    PSAHLHI+DSO3,DSXFF-DSCMSHI-DSLLHI TURN OF CMS AND LOCAL
*                                      LOCK HELD INDICATORS
         SPACE 2
*/* P CLEAR PSATNEW AND PSATOLD FIELDS */
         SPACE 2
         LA    R1,DSL0                 ZERO R1
         ST    R1,PSATNEW          *    CLEAR PSANEW
         ST    R1,PSATOLD          *         AND PSAOLD
         SPACE 2
*/*DSSAV23: R RETURN */
         SPACE 2
DSSAV23  DC    0H'0'
         BR    RF                  RETURN.
         EJECT
*
*  WAIT STATE SAVE SECTION
*        R1 IS ZERO ON ENTRY TO THIS SEQUENCE
*
         SPACE 2
*/*DSSAV3: P (CHNG,DSSAV3,OK,) C & S TO DECREMENT COUNT OF CPU'S IN
*/*WAIT */
         SPACE 2
DSSAV3   DC    0H'0'
         L     R3,ASCBCPUS         *
         LR    R2,R3               *     DECREMENT COUNT OF THE NUMBER
         BCTR  R3,DSI0             *          OF CPUS DISPATCHED TO
DST110B  DC    0H'0'               *** TEST LABEL ***
         CS    R2,R3,ASCBCPUS      *          THE WAIT ADDRESS SPACE
         BC    DSCC4,DSSAV3        *
         SPACE 2
*/* P CLEAR PSATNEW AND PSATOLD */
         SPACE 2
DST111   DC    0H'0'               *** TEST LABEL ***
         ST    R1,PSATNEW          CLEAR PSATNEW
         ST    R1,PSATOLD          CLEAR PSATOLD
         ST    R1,LCCAITOD         CLEAR INT TOD
         SPACE
DST111A  DC    0H'0'               *** TEST LABEL ***
         SPACE 2
*/* R RETURN */
         SPACE 2
         BR    RF                  RETURN.
         TITLE 'IEAVEDS0 - JOB STEP TIMING'
***********************************************************************
*                                                                     *
*  JOB STEP TIMING SUBROUTINE                                         *
*        THIS SUBROUTINE IS ENTERED TO ACCUMULATE THE JOB STEP        *
*        TIME FOR THE CURRENT ADDRESS SPACE.                          *
*                                                                     *
*  DEPENDENCIES:  IEESTPRS AND DSS                                    *
*        IF CURRENT PSW IS BETWEEN IEAVEDS1 AND IEAVEDS2 BOTH MUST    *
*        UPDATE LCCADTOD AND (LCCAITOD,IF ANY VALUE IS PRESENT) BY    *
*        THE ELAPSED TOD AND RESET THE IC TO IEAVEDS1.                *
*                                                                     *
*  ENTRY REGISTERS:                                                   *
*        R7 - LCCA ADDRESS                                            *
*        R8 - ASCB ADDRESS                                            *
*        R9 - BASE REGISTER                                           *
*        RE - RETURN ADDRESS                                          *
*  WORK REGISTERS:                                                    *
*        R0 THRU R3                                                   *
*  NO OTHER REGISTERS ARE USED IN THIS SEQUENCE.                      *
*                                                                     *
***********************************************************************
         SPACE 2
*/*DSJST: D (BAD,DSJSTRTN,GOOD,) TEST FOR GOOD TOD CLOCK */
         SPACE 2
         ENTRY   DSJSTCSR
DSJSTCSR DC    0H'0'
         SPACE 2
*/* P ESTABLISH LOCAL ADDRESSABILITY */
         SPACE 2
         BALR  R9,R0               LOCAL ADDRESSABILITY
         USING *,R9
         SPACE 2
*/* P ESTABLISH MODULE ADDRESSABILITY */
         SPACE 2
         L     R9,DSBASEAD         DISPATCHER BASE ENTRY
         USING DSBASE,R9           ESTABLISH DISPATCHER ADDRESSABILITY
DSJST    DC    0H'0'
*                                                              @YM05197
         L     R1,PSAPCCAV         PCCA ADDRESS.
         USING PCCA,R1             PCCA ADDRESSABILITY.
         TM    PCCATODE,PCCANUTD   TEST FOR GOOD TOD CLOCK.
         BC    DSCC1,DSJSTCLR      BAD CLOCK. BYPASS JOB STEP TIMING.
         DROP  R1                  DROP PCCA ADDRESSABILITY.
*   FALL THROUGH ON GOOD TOD CLOCK TO DO JOB STEP TIMING.
IEAVEDS1  DC  0H'0'
         SPACE 2
*/* D (YES,DSJSTSRB,NO,) SRB MODE? */
         SPACE 2
         TM    LCCADSF2,LCCASRBM   SRB MODE?                   @YM07640
         BO    DSJSTSRB            SRB MODE                    @YM07640
         SPACE 2
*/* D (YES,DSJSTCLR,NO,) RCT TASK? */
         SPACE 2
         L     R1,ASCBASXB         ADDRESS THE ASXB            @YM07640
         L     R2,ASXBFTCB-ASXB(R1) OBTAIN RCT'S ADDRESS       @YM07640
         C     R2,PSATOLD          IS CURRENT TASK THE RCT?    @YM07640
         BE    DSJSTCLR            RCT, DO NOT TIME            @YM07640
         SPACE 2
*/* D (NO,DSJSTSTC,YES,) IS ENTRY FROM A FLIH? */
         SPACE 2
         L     R2,LCCAITOD         IS INTERRUPT TIME STORED?   @YM07640
         LTR   R2,R2               IF SO, R2 WILL HAVE A VALUE @YM07640
         BZ    DSJSTSTC            NO, GO STORE TOD            @YM07640
         L     R3,LCCAITOD+DSL4    OBTAIN FULL TOD VALUE       @YM07640
         SPACE 2
*/*DSJST01: P SUBTRACT TOD AT DISPATCH (LCCADTOD) FROM TOD NOW */
         SPACE 2
DSJST01  DC    0H'0'
*                                  LCCADTOD - TOD CLOCK AT DISPATCH.
         SL    R2,LCCADTOD         LEFT HALF VALUES.
         SL    R3,LCCADTOD+DSL4    RIGHT HALF VALUES.
         BC    DSCC11,DSJST02      BRANCH IF CARRY. COMPLEMENTED SMALL
DST112   DC    0H'0'               *** TEST LABEL ***
*                                       VALUE ADDED TO ASCBEWST.
         BCTR  R2,DSI0             DECREMENT HIGH ORDER VALUE.
         SPACE 2
*/*DSJST02: P ADD TO ACCUMULATED JOB STEP TIME (ASCBEJST) */
         SPACE 2
DSJST02  DC    0H'0'
         LM    R0,R1,ASCBEJST      ELAPSED JOB STEP TIME.
         ALR   R2,R0               LEFT HALF ELAPSED JOB STEP TIME.
         ALR   R3,R1               RIGHT HALF ELAPSED JOB STEP TIME.
         BC    DSCC12,DSJST03      BRANCH IF NO CARRY.
DST113   DC    0H'0'               *** TEST LABEL ***
         LA    R2,DSI1(R2)         INCREMENT HIGH ORDER VALUE.
         SPACE 2
*/*DSJST03: P (CHNG,DSJST01,OK,DSJSTRTN) C & S TO UPDATE ASCBEJST */
         SPACE 2
DSJST03  DC    0H'0'
         CDS   R0,R2,ASCBEJST      C&S NEW ELAPSED JOB STEP TIME.
         SPACE 2
*/*DSJSTRTN: D (YES,DSJSTCLR,NO,DSJST01) DID CDS UPDATE EJST? */
         SPACE 2
DSJSTRTN DC    0H'0'
         BC    DSCC8,DSJSTCLR      VALUE UPDATED - RETURN.     @YM07640
         L     R2,LCCAITOD         IS INTERRUPT TIME STORED?   @YM07640
         LTR   R2,R2               IF SO, R2 WILL HAVE A VALUE @YM07640
         BZ    DSJSTLDC            NO, GO STORE TOD            @YM07640
         L     R3,LCCAITOD+DSL4    OBTAIN FULL TOD VALUE       @YM07640
DST114   DC    0H'0'               *** TEST LABEL ***
         B     DSJST01             VALUE WAS CHANGED - TRY AGAIN.
         SPACE 2
*/*DSJSTSTC: P (,DSJST01) STORE TOD CLOCK INTO ASCBEWST */
         SPACE 2
DSJSTSTC DC    0H'0'
         STCK  ASCBEWST            TOD CLOCK VALUE NOW.        @YM07640
DSJSTLDC DC    0H'0'
         L     R2,ASCBEWST         OBTAIN TOD                  @YM07640
         L     R3,ASCBEWST+DSL4    OBTAIN TOD                  @YM07640
         B     DSJST01             CALCULATE ELASPED JST       @YM07640
         SPACE 3
***********************************************************************
*        DSJSTSRB - THIS ROUTINE CALCULATES JST FOR A SRB WHICH IS    *
*        ACCUMULATED SEPARATELY FROM JST FOR TASKS.                   *
***********************************************************************
         SPACE 2
*/*DSJSTSRB: P CALCULATE JST FOR A SRB */
         SPACE 2
DSJSTSRB DC    0H'0'
         STCK  ASCBEWST            STORE TOD                   @YM07640
         SPACE 2
*/*DSJST03A: P OBTAIN TOD */
         SPACE 2
DSJST03A DC    0H'0'
         L     R2,ASCBEWST         OBTAIN TOD                  @YM07640
         L     R3,ASCBEWST+DSL4    OBTAIN TOD                  @YM07640
         SL    R2,LCCADTOD         LEFT HALF VALUES.           @YM07640
         SL    R3,LCCADTOD+DSL4    RIGHT HALF VALUES.          @YM07640
         BC    DSCC11,DSJST03B     BRANCH IF CARRY. COMPLEMENTED SMALL
         BCTR  R2,DSI0             DECREMENT HIGH ORDER VALUE. @YM07640
         SPACE 2
*/*DSJST03B: P ADD TO ACCUMULATED JOB STEP TIME (ASCBSRBT) */
DSJST03B DC    0H'0'
         LM    R0,R1,ASCBSRBT      ELAPSED JOB STEP TIME.      @YM07640
         ALR   R2,R0               LEFT HALF ELAPSED JOB STEP TIME.
         ALR   R3,R1               RIGHT HALF ELAPSED JOB STEP TIME.
         BC    DSCC12,DSJST04      BRANCH IF NO CARRY.         @YM07640
DST115   DC    0H'0'               *** TEST LABEL ***          @YM07640
         LA    R2,DSI1(R2)         INCREMENT HIGH ORDER VALUE. @YM07640
         SPACE 2
*/*DSJST04: P (CHNG,DSJST01,OK,DSJSTRTS) C & S TO UPDATE ASCBEJST */
         SPACE 2
DSJST04  DC    0H'0'
         CDS   R0,R2,ASCBSRBT      C&S NEW ELAPSED JST         @YM07640
         SPACE 2
*/*DSJSTRTS: R RETURN */
         SPACE 2
DSJSTRTS DC    0H'0'
         BCR   DSCC8,RE            VALUE UPDATED - RETURN.     @YM07640
DST116   DC    0H'0'               *** TEST LABEL ***
         B     DSJST03A            VALUE CHANGED - TRY AGAIN.  @YM07640
IEAVEDS2  DC  0H'0'
         SPACE 2
*/*DSJSTCLR: R CLEAR ITOD AND RETURN */
DSJSTCLR DC    0H'0'
* THIS PROCESSING MUST BE OUTSIDE THE ENTRY POINTS IEAVEDS1 AND
* IEAVEDS2 DUE TO STOP RESTART SUBROUTINE (IEESTPRS) DEPENDIENCES.
         SLR   R1,R1               CLEAR R1                    @YM07640
         ST    R1,LCCAITOD         CLEAR ITOD                  @YM07640
         BR    RE                  RETURN TO CALLER            @YM07640
         TITLE 'IEAVEDS0 - VCONS/ADCONS'
***********************************************************************
*                                                                     *
*                       VCONS/ADCONS                                  *
*                                                                     *
***********************************************************************
DSGSMQ   DC    V(IEAGSMQ)          GLOBAL SERVICE MANAGER QUEUE
DSLSMQ   DC    V(IEALSMQ)          LOCAL SERVICE MANAGER QUEUE
DSGSPL   DC    V(IEAGSPL)          GLOBAL SERVICE PARAMETER LIST
DSWTCB   DC    V(IEAWTCB)          WAIT TCB
DSWASCB  DC    V(IEAWASCB)         WAIT ASCB
DSMASCB  DC    V(IEAMASCB)         MASTER'S ASCB
DSCMSLK  DC    V(CMSLOCK)          CMS LOCK
         SPACE
DSLLREL  DC    V(LLREL)            BASE ENTRY FOR LOCAL LOCK RELEASE
DSLLRELD DC    V(LRELDISP)         DISP ENTRY FOR LOCAL LOCK RELEASE
DSDISPLK DC    V(DISPLOCK)         DISP LOCKWORD ADDRESS       @YM03564
AGSLDISP DC    V(GSLSDISP)         DISP ENTRY FOR DISP LOCK OBTAIN
DSVESC1  DC    V(IEAVESC1)         GLOBAL SCHEDULE ENTRY POINT
DSVESC2  DC    V(IEAVESC2)         LOCAL SCHEDULE ENTRY POINT
DS0EF03  DC    V(IEA0EF03)         STAGE 3 EXIT EFFECTOR ENTRY POINT
DSRSPN   DC    V(IEAVRSPN)         TIMER RECOVERY SPIN ENTRY POINT
DSMS0    DC    V(IEAVEMS0)         MEMORY SWITCH ENTRY POINT
DSTRDISP DC    V(TRDISP)           TASK ENTRY TO TRACE
DSTRSRB1 DC    V(TRSRB1)           INITIAL SRB ENTRY TO TRACE
DSTRSRB2 DC    V(TRSRB2)           SUSPENDED SRB ENTRY TO TRACE
DSRMTR   DC    V(IEAVEFRE)         SUSPENDED SRB'S RMTR ADDR
         SPACE
SETSANAD DC    A(SETSASID)         DAS RESTORE ENTRY POINT     @ZP60023
DSBASEAD DC    A(DSBASE)           ADCON FOR DISPATCHER ADDRESSABILITY
         TITLE 'IEAVEDS0 - CONSTANTS'
***********************************************************************
*                                                                     *
*                           CONSTANTS                                 *
*                                                                     *
***********************************************************************
         SPACE
DSHITIME DS    0D                  HIGH VALUE FOR CPU INTERVAL TIMER.
         DC    X'7FFFFFFFFFFFFFFF' HIGH VALUE FOR CPU INTERVAL TIMER.
         SPACE
DSSRBPSW DC    0D'0'               LEFT HALF OF SRB PSW WITH EC MODE
         DC    B'00000111000011000000000000000000'    AND MCH BITS ON -
*                                       USED TO BUILD PSW ON INITIAL
*                                       SRB DISPATCH.
         SPACE
DSCPUAFF DS    0F
DSINTPID DS    0F                  LOCAL LOCK INTERRUPT ID.
         DC    X'FFFFFFFF'         LOCAL LOCK INTERRUPT ID.
         SPACE
DSFOUR   DC    F'4'                FOUR
         SPACE
DSPREFIX DC    A(-(TCB-TCBFRS))    TCB PREFIX DECREMENT VALUE
         SPACE
DSABTIME DS    0F                  22F ABEND CODE FOR TASKS USING CPU
         DC    X'8022F000'              TIMER WHICH HAS GONE BAD.
         SPACE
DSABAFFN DS    0F                  072 ABEND CODE FOR SRB'S WHICH HAVE
         DC    X'80072000'              SPECIFIED AFFINITY TO A CPU
*                                       WHICH HAS GONE OFFLINE.
         SPACE
DSWPSW   DC    X'070E000000000000' WAIT PSW                    @YM03464
         SPACE
DSCELLID DC    0F'0'               *     CELL POOL
         DC    C'SRB'              *            ID FOR
         DC    X'00'               *                  SUSPENDED SRB'S.
ACTONMSK DC    X'80000000'         TCBACTIV MASK CHECK         @Z40FPXJ
ACTOFMSK DC    X'7FFFFFFF'         TCBACTIV MASK OFF           @Z40FPXJ
ACTCPVOF DC    AL1(255-(TCBACTIV)),X'FF0000' TCBACTIV/TCBCCPVI MASK OFF
*                                                              @ZA20174
         EJECT
***********************************************************************
*                                                                     *
*  DISPATCH THE WAIT TASK                                             *
*        THIS SECTION IS ENTERED TO DISPATCH THE WAIT TASK AFTER A    *
*        SECOND SCAN HAS BEEN MADE OF THE DISPATCHING QUEUES.         *
*                                                                     *
***********************************************************************
         SPACE 2
*/*DS05C: P MOVE WAIT PSW TO LOW CORE */
         SPACE 2
DS05C    DC    0H'0'
         SPACE 2
         BALR  RC,R0                                           @ZP60023
         USING *,RC                LOCAL BASE                  @ZP60023
         SPACE 2
         MVC   PSAPSWSV(DSL8),DSWPSW   WAIT PSW TO LOW CORE.   @YM03464
         SPACE 2
*/* D (BAD,DS053,GOOD,) TEST FOR GOOD TOD CLOCK */
         SPACE 2
         L     R5,PSAPCCAV         ADDRESS OF PCCA.
         USING PCCA,R5             PCCA ADDRESSABILITY.
         TM    PCCATODE,PCCANUTD   TEST FOR BAD TOD CLOCK.
         BO    DS05C3              BAD. BYPASS TOD CLOCK SETTING.
         DROP  R5                  DROP PCCA ADDRESSABILITY.
         SPACE 2
*/* P STORE TOD CLOCK INTO THE LCCA */
         SPACE 2
         STCK  LCCADTOD            TIME OF DAY
         SPACE 2                                               @YM03564
*/* P INDICATE WORK DISPATCHED */
         SPACE 2                                               @YM03564
         OI    LCCADSF2,LCCADSRW   READY WORK DISPATCHED       @YM03564
         SPACE 2
*/*DS05C3: P GET ADDRESSABILITY TO CVT. */
         SPACE 2
DS05C3   DC    0H'0'
         L     R6,FLCCVT           CVT
         USING CVT,R6                   ADDRESSING.
         SPACE 2
*/* D (NO,DS05C5,YES,) IS TRACE ACTIVE? */
         SPACE 2
         CLI   CVTTRACE+DSL1,DSTRACEM   IS TRACE ACTIVE?
         BNE   DS05C5              NO. BYPASS.
         DROP  R6
         SPACE 2
*/* S TRDISP:TRACE ENTRY TO WAIT STATE */
         SPACE 2
         L     RA,DSTRDISP         TRACE ENTRY POINT.
         SLR   RF,RF               ZERO REGISTER 15 FOR TRACE  @YM03564
         SLR   R0,R0               ZERO REGISTER 0             @YM03564
         SLR   R1,R1               ZERO REGISTER 1             @YM03564
DST066A  DC    0H'0'               *** TEST LABEL ***
         BALR  RB,RA               GO TO TRACE
LOADPSA2 DC    0H'0'               ***** FOR TSO TEST *****
         SPACE 2
*/*DS05C5: S IEADISP3:MONITOR CALL TO GTF */
         SPACE 2
DS05C5   DC    0H'0'
         HOOK  EID=IEADISP3,TYPE=P GO TO GTF
         SPACE 2                                               @YM03564
*/* P PURGE THE NORMAL STACK */
         SPACE 2                                               @YM03564
         SETFRR F,WRKREGS=(R1,R2)                              @YM03564
         SPACE 2
         DROP  RC                  DROP LOCAL BASE             @ZP60023
         SPACE 2
*/* P CLEAR ALL REGISTERS TO ZERO */
         SPACE 2
         SLR   R0,R0               ZERO ALL REGISTERS          @YM03564
         SLR   R1,R1               ZERO REGISTER 1             @YM03564
         SLR   R2,R2               ZERO REGISTER 2             @YM03564
         SLR   R3,R3               ZERO REGISTER 3             @YM03564
         SLR   R4,R4               ZERO REGISTER 4             @YM03564
         SLR   R5,R5               ZERO REGISTER 5             @YM03564
         SLR   R6,R6               ZERO REGISTER 6             @YM03564
         SLR   R7,R7               ZERO REGISTER 7             @YM03564
         SLR   R8,R8               ZERO REGISTER 8             @YM03564
         SLR   R9,R9               ZERO REGISTER 9             @YM03564
         SLR   RA,RA               ZERO REGISTER 10            @YM03564
         SLR   RB,RB               ZERO REGISTER 11            @YM03564
         SLR   RC,RC               ZERO REGISTER 12            @YM03564
         SLR   RD,RD               ZERO REGISTER 13            @YM03564
         SLR   RE,RE               ZERO REGISTER 14            @YM03564
         SLR   RF,RF               ZERO REGISTER 15            @YM03564
         SPACE 2
*/* P RESET THE DISPATCHER INDICATOR */
         SPACE 2
         NI    PSASUP1,DSXFF-PSADISP    RESET DISPATCHER INDICATOR.
         SPACE 2
*/* P RESET FRR STACK POINTER TO NORMAL */
         SPACE 2
LWAITPSW DC    0H'0'
         MVC   PSACSTK(DSL4),PSANSTK    MAKE NORMAL STACK CURRENT.
         SPACE 2
***********************************************************************
*                                                                     *
*              LOAD PSW TO DISPATCH THE WAIT TASK                     *
*                                                                     *
***********************************************************************
         SPACE 2
*/*WAITPSW: R LOAD WAIT PSW */
         SPACE 2
WAITPSW  DC    0H'0'
         LPSW  PSAPSWSV            LOAD WAIT PSW.
         TITLE 'SETSASID - SET SECONDARY ADDRESS SPACE'        @ZP60023
************************************************************** @ZP60023
*                                                            * @ZP60023
*              RESTORE DUAL ADDRESS SPACE STATUS             * @ZP60023
*                                                            * @ZP60023
************************************************************** @ZP60023
         SPACE 2                                               @ZP60023
*    R1 = ENTRY POINT ADDRESS                                  @ZP60023
*    R2 = SECONDARY ASN                                        @ZP60023
*    R4 = TASK STORAGE KEY                                     @ZP60023
*    R8 = PRIMARY ASCB ADDRESS                                 @ZP60023
*    RF = RETURN POINT ADDRESS                                 @ZP60023
         SPACE 2                                               @ZP60023
         USING SETSASID,R1                                     @ZP60023
         SPACE 2                                               @ZP60023
*                                                              @ZP60023
*    DEACTIVATE DAS                                            @ZP60023
*                                                              @ZP60023
SETSASID SR    R3,R3               GET ZERO                    @ZP60023
         ST    R3,LCCACR0          SET ZERO                    @ZP60023
         LCTL  R4,R4,LCCACR0       RESET PRIMARY ASN           @ZP60023
         LCTL  R3,R3,LCCACR0       RESET SECONDARY ASN         @ZP60023
         LCTL  R7,R7,LCCACR0       RESET SECONDARY STO         @ZP60023
         STCTL R0,R0,LCCACR0       GET CURRENT CR0             @ZP60023
         NI    LCCACR0,X'FF'-X'0C' DEACTIVATE DAS              @ZP60023
         LCTL  R0,R0,LCCACR0       SET CURRENT CR0             @ZP60023
*                                                              @ZP60023
*    VALIDATE SECONDARY ASID                                   @ZP60023
*                                                              @ZP60023
         LTR   R2,R2               VALID ASID?                 @ZP60023
         BNPR  RF                  NO, DAS NOW RESET           @ZP60023
         LA    R3,1                GET ONE IN LOW BIT          @ZP60023
         SLL   R3,31               GET ONE IN HIGH BIT         @ZP60023
         SRL   R4,4                GET KEY IN LOW NIBBLE       @ZP60023
         SRL   R3,0(R4)            GET ONE IN TASK KEY BIT     @ZP60023
         L     R4,FLCCVT                                       @ZP60023
         L     R4,CVTASVT-CVT(,R4) GET ASVT ADDRESS            @ZP60023
         USING ASVT,R4                                         @ZP60023
         C     R2,ASVTMAXU         TOO BIG FOR THIS IPL?       @ZP60023
         BHR   RF                  YES, PRETEND NOT TO KNOW    @ZP60023
         OR    R3,R2               NO, COPY SECONDARY ASID     @ZP60023
         SLA   R2,2                GET SECONDARY ASN TIMES 4   @ZP60023
         L     R2,ASVTENTY-4(R2)   GET ASCB ADDRESS            @ZP60023
         DROP  R4                  (ASVT)                      @ZP60023
         LTR   R2,R2               ASID ASSIGNED?              @ZP60023
         BNPR  RF                  NO, USER ERROR SO GIVE UP   @ZP60023
         DROP  R8                  (ASCB)                      @ZP60023
*                                                              @ZP60023
*    VALIDATE SECONDARY ADDRESS SPACE                          @ZP60023
*                                                              @ZP60023
         USING ASCB,R2                                         @ZP60023
         TM    ASCBRCTF,ASCBOUT    SECONDARY ASID SWAPPED OUT? @ZP60023
         BOR   RF                  YES, USER ERROR SO GIVE UP  @ZP60023
*                                                              @ZP60023
*    SET SECONDARY PARTICULARS                                 @ZP60023
*                                                              @ZP60023
         ST    R3,LCCACR0                                      @ZP60023
         LCTL  R3,R3,LCCACR0       SET KEY MASK, SECONDARY ASN @ZP60023
         LCTL  R7,R7,ASCBSTOR      SET SECONDARY STO           @ZP60023
         DROP  R2                  (ASCB)                      @ZP60023
*                                                              @ZP60023
*    SET PRIMARY PARTICULARS                                   @ZP60023
*                                                              @ZP60023
         USING ASCB,R8                                         @ZP60023
         LH    R3,ASCBASID         GET PRIMARY ASN             @ZP60023
         ST    R3,LCCACR0                                      @ZP60023
         LCTL  R4,R4,LCCACR0       SET PRIMARY ASN             @ZP60023
*                                                              @ZP60023
*    ACTIVATE DAS                                              @ZP60023
*                                                              @ZP60023
         STCTL R0,R0,LCCACR0       GET CURRENT CR0             @ZP60023
         OI    LCCACR0,X'0C'       ACTIVATE DAS                @ZP60023
         LCTL  R0,R0,LCCACR0       SET CURRENT CR0             @ZP60023
         BR    RF                  RETURN TO CALLER            @ZP60023
         SPACE 2                                               @ZP60023
         DROP  R1                  (SETSASID)                  @ZP60023
         SPACE 2                                               @ZP60023
         DC    0D'0'               END OF CSECT                @ZP60023
         TITLE 'IEAVEDS0 - ASCB'
         IHAASCB
         TITLE 'IEAVEDS0 - ASXB'
         IHAASXB
         TITLE 'IEAVEDS0 - IHSA'
         IHAIHSA
         TITLE 'IEAVEDS0 - FLC/PSA'
         IHAPSA
         TITLE 'IEAVEDS0 - LCCA'
         IHALCCA
         TITLE 'IEAVEDS0 - PCCA'
         IHAPCCA
         TITLE 'IEAVEDS0 - SRB/SSRB'
         IHASSRB
         TITLE 'IEAVEDS0 - WSAVT(GLOBAL)'
         IHAWSAVT CLASS=GLOBAL,DSECT=YES
         TITLE 'IEAVEDS0 - WSAVT(CPU)'
         IHAWSAVT CLASS=CPU,DSECT=YES
         TITLE 'IEAVEDS0 - TCB'
         IKJTCB
         TITLE 'IEAVEDS0 - RB'
         IKJRB
         TITLE 'IEAVEDS0 - TQE'
         IHATQE
         TITLE 'IEAVEDS0 - CSD'
         IHACSD
         TITLE 'IEAVEDS0 - CDAL'                               @ZA18126
         CDAL                                                  @ZA18126
         TITLE 'IEAVEDS0 - GSPL/LSPL'
         IHASPL
         TITLE 'IEAVEDS0 - FRRS'
         IHAFRRS
         TITLE 'IEAVEDS0 - CVT'
         CVT   DSECT=YES,LIST=YES
         TITLE 'IEAVEDS0 - ASVT'
         IHAASVT DSECT=YES                                     @ZP60023
         TITLE 'IEAVEDS0 - END'
*/* END */
         END
/*
//STEP5   EXEC PGM=IEBGENER
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  *
  IDENTIFY IEAVEDS0('ZP60023')
/*
//SYSUT2   DD  DSN=&&SMPMCS,DISP=(MOD,PASS)
//SYSIN    DD  DUMMY
//STEP6   EXEC SMPREC
//SMPPTFIN DD  DSN=&&SMPMCS,DISP=(OLD,DELETE)
//SMPCNTL  DD  *
  RECEIVE SELECT(ZP60023).
/*
//STEP7   EXEC SMPAPP
//AMODGEN  DD  DSN=SYS1.AMODGEN,DISP=SHR
//SMPCNTL  DD  *
  APPLY SELECT(ZP60023) DIS(WRITE).
/*
//
