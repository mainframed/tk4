         TITLE 'IEFAB486 - OFFLINE/ALCDS ALLOCATION                    *
                        '
IEFAB486 CSECT ,                                                01S0001
@MAINENT DS    0H                                               01S0001
         USING *,@15                                            01S0001
         B     @PROLOG                                          01S0001
         DC    AL1(16)                                          01S0001
         DC    C'IEFAB486  76.342'                              01S0001
         DROP  @15
@PROLOG  STM   @14,@12,12(@13)                                  01S0001
         BALR  @12,0                                            01S0001
@PSTART  LA    @11,4095(,@12)                                   01S0001
         USING @PSTART,@12                                      01S0001
         USING @PSTART+4095,@11                                 01S0001
         L     @00,@SIZDATD                                     01S0001
         GSPACE   R,LV=(0)
         LR    @10,@01                                          01S0001
         USING @DATD,@10                                        01S0001
         ST    @13,@SA00001+4                                   01S0001
         LM    @00,@01,20(@13)                                  01S0001
         ST    @10,8(,@13)                                      01S0001
         LR    @13,@10                                          01S0001
         MVC   @PC00001(4),0(@01)                               01S0001
*SAVNOCOV = ZERO;                      /*INIT CODE SAVE AREA @ZA01569*/
         SLR   @15,@15                                          01S0065
         STH   @15,SAVNOCOV                                     01S0065
*IF UWAITSW = ON THEN                  /*CAN ALLOC WAIT FOR UNITS ?  */
         L     @15,@PC00001                                     01S0066
         L     @15,ALCWAPTR(,@15)                               01S0066
         L     @01,FMAPPTR(,@15)                                01S0066
         TM    UWAITSW(@01),B'00100000'                         01S0066
         BNO   @RF00066                                         01S0066
* DO;                                  /*YES, INDICATE IN ALG TABLES */
*    CVRALFLG = ON;                                             01S0068
         L     @02,ALGTABP(,@15)                                01S0068
         L     @01,ALGPARMP(,@02)                               01S0068
         OI    CVRALFLG(@01),B'01000000'                        01S0068
*/********************************************************************/
*/*                                                                  */
*/* SEGMENT NAME - ALGAPREP                                          */
*/*                                                                  */
*/* DESCRIPTIVE NAME - UPDATE ALG TABLE FOR WAIT-FOR-DEVICES         */
*/*                                                                  */
*/* FUNCTION -                                                       */
*/*     THIS ROUTINE UPDATES THE ALGORITHM REQUEST LIST ENTRIES      */
*/*     TO REFLECT THAT THE ALGORITHM CAN NOW CONSIDER DEVICES       */
*/*     THAT ARE ALLOCATED TO OTHER JOBS.                            */
*/*                                                                  */
*/*     REQUEST LIST ENTRIES, WHICH WERE NOT BEING PROCESSED BY THE  */
*/*     ALGORITHM BECAUSE THEY WERE ALLOCATED TO DEVICES             */
*/*     WHICH ARE ALLOCATED TO OTHER JOBS, NOW MARKED                */
*/*     "TO BE CONSIDERED" (CVRSKFLG=0) BECAUSE THE                  */
*/*     ALGORITHM COULD REARRANGE SUCH A REQUEST. THIS IS TRUE SINCE */
*/*     THE VOLUME WILL BE MOVABLE WHEN ALL OTHER JOBS ALLOCATED TO  */
*/*     THE UNIT HAVE UNALLOCATED.                                   */
*/*                                                                  */
*/*   OPERATION - (THE OPERATION IS DOCUMENTED BY THE CODE ITSELF)   */
*/*                                                                  */
*/* ENTRY - (INLINE SUBROUTINE)                                      */
*/*                                                                  */
*/*   PURPOSE - (SEE FUNCTION)                                       */
*/*                                                                  */
*/*   INPUT -                                                        */
*/*      ALGRQLTP - PTR TO ALGORITHM REQUEST LIST                    */
*/*                                                                  */
*/* EXIT - NORMAL - (INLINE SUBROUTINE)                              */
*/*                                                                  */
*/*   CONDITIONS - FUNCTION COMPLETED.                               */
*/*                                                                  */
*/*   OUTPUT                                                         */
*/*        CVRSKFLG - SET TO 0 FOR SOME ALGORITHM REQUESTS.          */
*/*                                                                  */
*/*   RETURN CODES - (NONE)                                          */
*/*                                                                  */
*/********************************************************************/
*AREQPTR = ALGRQLTP;                   /*POINT TO FIRST ALG REQ ENTRY*/
         L     AREQPTR,ALGRQLTP(,@02)                           02S0069
*DO AREQCTR = ONE TO CVRNREQ;          /*SCAN ALL ALG REQ LIST ENTRYS*/
         LA    AREQCTR,1                                        02S0070
         B     @DE00070                                         02S0070
@DL00070 DS    0H                                               02S0071
*  IF CVRSKFLG = ON                    /*IS THE REQ IGNORED BECAUSE..*/
*      & CVRWMOVE = ON                 /*..IT IS ''MOVABLE-IF-WAIT'' */
*      & CVRIGNOR = OFF                /*..AND NOT IGNORED FOR...    */
*      & CVRDUPLI = OFF THEN           /*..OTHER REASONS             */
         TM    CVRSKFLG(AREQPTR),B'10000001'                    02S0071
         BNO   @RF00071                                         02S0071
         TM    CVRIGNOR(AREQPTR),B'00000010'                    02S0071
         BNZ   @RF00071                                         02S0071
         TM    CVRDUPLI(AREQPTR),B'10000000'                    02S0071
         BNZ   @RF00071                                         02S0071
*    DO;                               /*YES, HAVE THE ALG CONSIDER  */
*      CVRSKFLG = OFF;                                          02S0073
         NI    CVRSKFLG(AREQPTR),B'01111111'                    02S0073
*    END;                                                       02S0074
*  ELSE;                               /*NOT 'MOVABLE-IF-WAIT' REQ   */
@RF00071 DS    0H                                               02S0076
*  AREQPTR = AREQPTR + LENGTH(CVRRQLST); /*POINT TO NEXT ALG REQ     */
         AH    AREQPTR,@CH01076                                 02S0076
*END;                                                           02S0077
         AH    AREQCTR,@CH00079                                 02S0077
@DE00070 L     @07,@PC00001                                     02S0077
         L     @07,ALCWAPTR(,@07)                               02S0077
         L     @07,ALGTABP(,@07)                                02S0077
         L     @07,ALGPARMP(,@07)                               02S0077
         CH    AREQCTR,CVRNREQ(,@07)                            02S0077
         BNH   @DL00070                                         02S0077
*  END;                                                         01S0078
*ELSE;                                 /*ALLOC CANT WAIT FOR UNITS   */
@RF00066 DS    0H                                               01S0080
*IF OFFDEVSW = ON THEN                 /*CAN ALLOC USE OFFLINE UNITS?*/
         L     @15,@PC00001                                     01S0080
         L     @15,ALCWAPTR(,@15)                               01S0080
         L     @01,FMAPPTR(,@15)                                01S0080
         TM    OFFDEVSW(@01),B'00000100'                        01S0080
         BNO   @RF00080                                         01S0080
*    CVROFFLG = ON;                    /*YES, INDICATE IN ALG TABLES */
         L     @01,ALGTABP(,@15)                                01S0081
         L     @01,ALGPARMP(,@01)                               01S0081
         OI    CVROFFLG(@01),B'00100000'                        01S0081
*ELSE;                                 /*ALLOC CANT USE OFFLINE UNITS*/
@RF00080 DS    0H                                               01S0083
*  CVRFCALL = ON;                      /*INDICATE 1ST CALL WITH DATA */
*  CVRAVFLG = ON;                      /*ALG CAN CONSIDER AVAILABLES */
         L     @04,@PC00001                                     01S0084
         L     @04,ALCWAPTR(,@04)                               01S0084
         L     @04,ALGTABP(,@04)                                01S0084
         L     @01,ALGPARMP(,@04)                               01S0084
         OI    CVRFCALL(@01),B'10010000'                        01S0084
*CALL IEFAB480(ALGPARMP);              /*TRY TO FIND SOLUTION VIA ALG*/
         ST    @04,@AL00001                                     01S0085
         L     @15,@CV00138                                     01S0085
         LA    @01,@AL00001                                     01S0085
         BALR  @14,@15                                          01S0085
*RTNCODE = REG15;                      /*SAVE THE RETURN CODE        */
         LR    RTNCODE,REG15                                    01S0086
*IF RTNCODE = SUCCESS THEN             /*ALL REQUESTS COVERED ?      */
         LTR   RTNCODE,RTNCODE                                  01S0087
         BNZ   @RF00087                                         01S0087
*  DO;                                 /*YES, PROCESS ..             */
*    CALL IEFAB474 (ALCWAPTR,FUNC474); /*TRY TO PUT REQS ON 1 GENERIC*/
         L     @07,@PC00001                                     01S0089
         ST    @07,@AL00001                                     01S0089
         LA    @07,@CB00103                                     01S0089
         ST    @07,@AL00001+4                                   01S0089
         L     @15,@CV00135                                     01S0089
         LA    @01,@AL00001                                     01S0089
         BALR  @14,@15                                          01S0089
*/********************************************************************/
*/*                                                                  */
*/* SEGMENT NAME - FORCMULT                                          */
*/*                                                                  */
*/* DESCRIPTIVE NAME - FORCE REQUESTS ONTO ONE GENERIC               */
*/*                                                                  */
*/* FUNCTION -                                                       */
*/*     THIS ROUTINE LOCATES ANY MULTI-UNIT/GENERIC GROUPS (SAME     */
*/*     SIOTAFID) WHICH HAVE NOT YET BEEN COVERED BY A SINGLE        */
*/*     GENERIC DEVICE. WHENEVER SUCH A MULTI-UNIT/GENERIC IS FOUND, */
*/*     THIS ROUTINE INVOKES SEGMENT 'TRYGENIC' ONCE FOR EACH        */
*/*     GENERIC ELIBLE TO THIS REQUEST UNTIL ONE GENERIC IS FOUND    */
*/*     (BY SEGMENT 'TRYGENIC') WHICH CAN SATISFY THE ENTIRE AFID    */
*/*     GROUP AND STILL MAINTAIN COVERAGE OF ALL OTHER REQS BY THE   */
*/*     ALGORITHM. IF A GENERIC IS FOUND TO SATISFY THE AFID GROUP,  */
*/*     MODULE 'IEFAB481' IS CALLED TO MAKE ALL OTHER GENERICS       */
*/*     INELIGIBLE TO THE REQUESTS WITH THAT AFID. IF NO GENERIC IS  */
*/*     FOUND WHICH CAN SATISFY AN AFID GROUP, THE ALLOCATION        */
*/*     IS FAILED AND AN "UNABLE-TO-ALLOCATE" STEP REASON CODE IS    */
*/*     SET.                                                         */
*/*                                                                  */
*/*   OPERATION - DOCUMENTED BY THE 'FUNCTION' SECTION ABOVE AND     */
*/*               BY THE CODE ITSELF.                                */
*/*                                                                  */
*/* ENTRY - (INLINE SUBROUTINE)                                      */
*/*                                                                  */
*/*   PURPOSE - (SEE FUNCTION)                                       */
*/*                                                                  */
*/*   INPUT -                                                        */
*/*     SIOT1P - PTR TO FIRST SIOT IN CHAIN                          */
*/*       SIOT FIELDS - SIOTAFID - NON-ZERO VALUE INDICATES THIS REQ */
*/*                                IS PART OF A MULTI-UNIT/GEN GROUP.*/
*/*                   - SIOTEDLP - PTR TO ELIGIBLE DEVICES LIST      */
*/*                   - SIOTNPTR - PTR TO NEXT SIOT                  */
*/*                                                                  */
*/* EXIT - NORMAL - (INLINE SUBROUTINE)                              */
*/*                                                                  */
*/*   CONDITIONS - ALL REQUESTS COVERED BY A SINGLE GENERIC          */
*/*                                                                  */
*/*   OUTPUT - ALL SIOTAFID FIELDS ZEROED                            */
*/*          - ALL BUT ONE GENERIC MARKED INELIGIBLE (BY IEFAB481)   */
*/*            IN THE EDL AND ALGORITHM GROUP LIST ENTRIES FOR       */
*/*            EACH MULTI-UNIT/GENERIC REQUEST.                      */
*/*                                                                  */
*/*   RETURN CODES - RTNCODE = 0                                     */
*/*                                                                  */
*/* EXIT - ERROR - (INLINE SUBROUTINE)                               */
*/*                                                                  */
*/*   CONDITIONS - SOME MULTI-UNIT REQS COULD NOT BE COVERED BY A    */
*/*                SINGLE GENERIC DEVICE TYPE.                       */
*/*                                                                  */
*/*   OUTPUT - REASON CODE, SAVNOCOV, SET TO 6               @ZA01569*/
*/*            ("UNABLE TO ALLOCATE").                       @ZA01569*/
*/*                                                                  */
*/*   RETURN CODES - RTNCODE = 4                                     */
*/*                                                                  */
*/********************************************************************/
*SIOTPTR = SIOT1P;                     /*POINT TO FIRST SIOT         */
         L     @04,@PC00001                                     02S0090
         L     @04,ALCWAPTR(,@04)                               02S0090
         L     SIOTPTR,SIOT1P(,@04)                             02S0090
*DO WHILE (SIOTPTR^=ZERO & RTNCODE=SUCCESS); /*SCAN ALL SIOTS        */
         B     @DE00091                                         02S0091
@DL00091 DS    0H                                               02S0092
*  IF SIOTAFID ^= ZERO THEN            /*MULTI-UNIT/GENERIC REQ ?    */
         LH    @07,SIOTAFID(,SIOTPTR)                           02S0092
         LTR   @07,@07                                          02S0092
         BZ    @RF00092                                         02S0092
*    DO;                               /*YES,TRY TO COVER WITH 1 GEN */
*      SAVEAFID = SIOTAFID;            /*COPY MUG AFFINITY ID        */
         LR    SAVEAFID,@07                                     02S0094
*      GENFNDSW = OFF;                 /*INDICATE GENERIC NOT FOUND  */
         NI    GENFNDSW,B'11011111'                             02S0095
*      EDLPTR = EDLFGENP;              /*POINT TO FIRST GEN IN EDL   */
         L     @09,SIOTEDLP(,SIOTPTR)                           02S0096
         L     EDLPTR,EDLFGENP(,@09)                            02S0096
*      DO GENCTR = ONE TO EDLGENNO     /*SCAN ALL GENERICS IN EDL    */
*          WHILE (RTNCODE = SUCCESS    /*UNTIL ONE GENERIC COVERS    */
*          & GENFNDSW = OFF);                                   02S0097
         LA    @09,1                                            02S0097
         B     @DE00097                                         02S0097
@DL00097 LTR   RTNCODE,RTNCODE                                  02S0097
         BNZ   @DC00097                                         02S0097
         TM    GENFNDSW,B'00100000'                             02S0097
         BNZ   @DC00097                                         02S0097
*        IF EINDEVTP = OFF THEN        /*IS THE GENERIC ELIGIBLE ?   */
         TM    EINDEVTP(EDLPTR),B'10000000'                     02S0098
         BNZ   @RF00098                                         02S0098
*          DO;                         /*YES,TRY TO COVER ENTIRE REQ */
*            SAVGENID = EDLDEVT;       /*SAVE THE GENERIC DEVICE TYPE*/
         MVC   SAVGENID(4),EDLDEVT(EDLPTR)                      02S0100
*/********************************************************************/
*/*                                                                  */
*/* SEGMENT NAME - TRYGENIC                                          */
*/*                                                                  */
*/* DESCRIPTIVE NAME - TRY TO COVER AFID GROUP WITH INPUT GENERIC    */
*/*                                                                  */
*/* FUNCTION -                                                       */
*/*     THIS ROUTINE DETERMINES IF THE AFID GROUP CAN BE COVERED     */
*/*     BY THE INPUT GENERIC DEVICE TYPE.                            */
*/*                                                                  */
*/*   OPERATION -                                                    */
*/*       SEGMENT 'MARKINEL' IS INVOKED TO MARK ALL THE ALGORITHM    */
*/*       GROUP LIST ENTRIES, EXCEPT FOR THE CHOSEN GENERIC, AS      */
*/*       INELIGIBLE FOR EACH OF THE REQUESTS IN THE AFID GROUP.     */
*/*       THE COVER ALGORITHM (IEFAB480) IS THEN INVOKED TO SEE IF   */
*/*       A TOTAL SOLUTION STILL EXISTS. IF A TOTAL SOLUTION IS      */
*/*       NOT STILL POSSIBLE THEN THE ALGORITHM GROUP LIST ENTRIES   */
*/*       JUST MARKED INELIGIBLE ARE MADE ELIGIBLE AGAIN SO THAT     */
*/*       THESE OTHER GENERICS CAN POSSIBLY BE TRIED NEXT AS         */
*/*       A SOLUTION FOR THIS AFID GROUP.                            */
*/*                                                                  */
*/* ENTRY - (INLINE SUBROUTINE)                                      */
*/*   PURPOSE - (SEE FUNCTION)                                       */
*/*                                                                  */
*/*   INPUT -                                                        */
*/*      ALGRARMP - PTR TO ALGORITHM INTERFACE TABLE                 */
*/*      SAVEAFID - ID OF MULTI-UNIT/GENERIC GROUP TO BE PROCESSED   */
*/*      SIOTPTR - PTR TO FIRST SIOT WITH THE AFID                   */
*/*        SVOLUNNO - NUMBER OF VOLUNIT ENTRIES FOR THE SIOT         */
*/*        SVOLUNAD - PTR TO FIRST VOLUNIT ENTRY FOR THE SIOT        */
*/*          VOLALGTP - PTR TO ALGORITHM REQ LIST ENTRY FOR THIS     */
*/*                     VOLUNIT ENTRY                                */
*/*                                                                  */
*/* EXIT - NORMAL - (INLINE SUBROUTINE)                              */
*/*                                                                  */
*/*   CONDITIONS - NO ERROR. INDICATOR SET TO SHOW WHETHER THIS      */
*/*                GENERIC CAN SATISFY THE AFID GROUP                */
*/*                                                                  */
*/*   OUTPUT - GENFNDSW - 0 INDICATES GENERIC CANNOT SATISFY THE     */
*/*                       AFID GROUP.                                */
*/*                     - 1 INDICATES GENERIC CAN SATISFY THE AFID   */
*/*                       GROUP.                                     */
*/*                                                                  */
*/*   RETURN CODES - RTNCODE 0                                       */
*/*                                                                  */
*/* EXIT - ERROR - (INLINE SUBROUTINE)                               */
*/*                                                                  */
*/*   CONDITIONS - GETMAIN ERROR                                     */
*/*                                                                  */
*/*   OUTPUT - STEP REASON CODE, REASONCD, SET TO 2                  */
*/*                                                                  */
*/*   RETURN CODES - RTNCODE = NON-ZERO                              */
*/*                                                                  */
*/********************************************************************/
*RFY INDMSIOT BASED (SPTR);                                     03S0101
*GENFNDSW = ON;                        /*ASSUME GENERIC WILL COVER   */
         OI    GENFNDSW,B'00100000'                             03S0102
*/********************************************************************/
*/*                                                                  */
*/* SEGMENT NAME - MARKINEL                                          */
*/*                                                                  */
*/* DESCRIPTIVE NAME - MARK GROUPS (TEMPORARILY) INELIGIBLE          */
*/*                                                                  */
*/* FUNCTION -                                                       */
*/*     GIVEN AN AFID AND A GENERIC DEVICE TYPE, THIS ROUTINE MARKS  */
*/*     THE ALGORITHM GROUP LIST ENTRIES FOR OTHER GENERICS AS       */
*/*     INELIGIBLE FOR ALL REQUESTS IN THE AFID GROUP.               */
*/*                                                                  */
*/*   OPERATION -                                                    */
*/*       .THE SIOT CHAIN IS SCANNED TO LOCATE EACH OF THE AFID REQS.*/
*/*       .THE EDL FOR EACH REQ IS SCANNED TO LOCATE THE GENERIC     */
*/*        DEVICE ENTRY (IF IT EXISTS).                              */
*/*       .IF THE GENERIC IS FOUND IN AN EDL THE ALG GROUP LIST      */
*/*        ENTRIES FOR EACH OF THE SIOT'S VU ENTRIES ARE SCANNED.    */
*/*        EACH SUCH ALG GROUP LIST ENTRY IS MARKED INELIGIBLE       */
*/*        (CVRGSKP=1, CVRFORCI=1) UNTIL THE FIRST GROUP ENTRY FOR   */
*/*        THE CHOSEN GENERIC IS HIT. THEN THE NEXT "N" ENTRIES ARE  */
*/*        NOT MARKED INELIGIBLE (WHERE "N" IS THE NUMBER OF GROUPS  */
*/*        IN THAT GENERIC'S EDL ENTRY).                             */
*/*                                                                  */
*/* ENTRY - (INLINE SUBROUTINE)                                      */
*/*                                                                  */
*/*   PURPOSE - (SEE FUNCTION)                                       */
*/*                                                                  */
*/*   INPUT -                                                        */
*/*       SIOTPTR - PTR TO FIRST SIOT WITH THE INPUT AFID            */
*/*       SAVEAFID - ID OF THE MULTI-UNIT/GENERIC GROUP TO PROCESS   */
*/*       SAVGENID - GENERIC DEVICE TYPE CHOSEN                      */
*/*       GENFNDSW - 1                                               */
*/*                                                                  */
*/* EXIT - NORMAL - (INLINE SUBROUTINE)                              */
*/*                                                                  */
*/*   CONDITIONS - FUNCTION COMPLETE.                                */
*/*                                                                  */
*/*   OUTPUT -                                                       */
*/*       GENFNDSW - 0 - INDICATES GENERIC CANNOT SATISFY THE AFID   */
*/*                      GROUP BECAUSE NOT ALL OF THE REQS WERE      */
*/*                      ELIGIBLE TO THAT GENERIC.                   */
*/*                - 1 - INDICATES ALL AFID REQS WERE ELIGIBLE TO    */
*/*                      THE GENERIC AND ALL OTHER GENERICS ARE NOW  */
*/*                      MARKED INELIGIBLE.                          */
*/*       ALGORITHM GROUP LIST ENTRY FIELDS (FOR OTHER GENERIC):     */
*/*           CVRGSKP=1 AND CVRFORCI=1.                              */
*/*                                                                  */
*/*   RETURN CODES - (NONE)                                          */
*/*                                                                  */
*/********************************************************************/
*SPTR = SIOTPTR;                       /*POINT TO FIRST SIOT OF AFID */
         ST    SIOTPTR,SPTR                                     04S0103
*DO WHILE (SPTR ^= ZERO                /*SCAN THE REST OF THE SIOTS  */
*    & GENFNDSW = ON);                                          04S0104
         B     @DE00104                                         04S0104
@DL00104 DS    0H                                               04S0105
*  IF SIOTAFID = SAVEAFID THEN         /*SIOT WITH THE SAME AFID ?   */
         L     @09,SPTR                                         04S0105
         CH    SAVEAFID,SIOTAFID(,@09)                          04S0105
         BNE   @RF00105                                         04S0105
*    DO;                               /*YES,ELIMINATE OTHER GENERICS*/
*      GENFNDSW = OFF;                 /*INDICATE GEN NOT FOUND YET  */
         NI    GENFNDSW,B'11011111'                             04S0107
*      EDLPTR = EDLFGENP;              /*POINT TO FIRST GEN IN EDL   */
         L     @09,SIOTEDLP(,@09)                               04S0108
         L     EDLPTR,EDLFGENP(,@09)                            04S0108
*      DO GENCTR=ONE TO EDLGENNO       /*SCAN ALL GENERICS IN EDL    */
*          WHILE GENFNDSW = OFF;                                04S0109
         LA    @09,1                                            04S0109
         B     @DE00109                                         04S0109
@DL00109 TM    GENFNDSW,B'00100000'                             04S0109
         BNZ   @DC00109                                         04S0109
*        IF EDLDEVT = SAVGENID THEN    /*IS THIS THE GENERIC CHOSEN? */
         CLC   EDLDEVT(4,EDLPTR),SAVGENID                       04S0110
         BNE   @RF00110                                         04S0110
*          DO;                         /*YES,ELIMINATE ALL OTHER GENS*/
*            GENFNDSW = ON;            /*INDICATE GENERIC WAS FOUND  */
         OI    GENFNDSW,B'00100000'                             04S0112
*            VUPTR = SVOLUNAD;         /*POINT TO FIRT VU ENTRY      */
         L     @09,SPTR                                         04S0113
         MVC   VUPTR(4),SVOLUNAD(@09)                           04S0113
*            DO VUCTR=ONE TO SVOLUNNO; /*SCAN ALL OF REQ'S VU ENTRIES*/
         LA    VUCTR,1                                          04S0114
         B     @DE00114                                         04S0114
@DL00114 DS    0H                                               04S0115
*              AGRPPTR  = VOLALGTP->CVRGRPPT; /*POINT TO FIRST GROUP */
         L     @09,VUPTR                                        04S0115
         L     @09,VOLALGTP(,@09)                               04S0115
         L     AGRPPTR,CVRGRPPT(,@09)                           04S0115
*              ECOUNT = ZERO;          /*INITIALIZE COUNT            */
         SLR   ECOUNT,ECOUNT                                    04S0116
*              DO GRPCTR=ONE TO VOLALGTP->CVRNGRP; /*SCAN ALL ALG
*                                        GROUP ENTRIES FOR THIS REQ  */
         LA    GRPCTR,1                                         04S0117
         B     @DE00117                                         04S0117
@DL00117 DS    0H                                               04S0118
*                IF EDLGRPTR->EDLGRID=CVRGRPID THEN /*FIRST GROUP IN
*                                        THE GENERIC CHOSEN          */
         L     @01,EDLGRPTR(,EDLPTR)                            04S0118
         L     @15,EDLGRID(,@01)                                04S0118
         CH    @15,CVRGRPID(,AGRPPTR)                           04S0118
         BNE   @RF00118                                         04S0118
*                  ECOUNT = EDLGRPNO;  /*YES,SET COUNT OF GRPS IN GEN*/
         L     ECOUNT,EDLGRPNO(,EDLPTR)                         04S0119
*                ELSE;                 /*NOT FIRST GRP IN GEN CHOSEN */
@RF00118 DS    0H                                               04S0121
*                IF ECOUNT > ZERO THEN /*IS GROUP IN GENERIC CHOSEN? */
         LTR   ECOUNT,ECOUNT                                    04S0121
         BNP   @RF00121                                         04S0121
*                  ECOUNT = ECOUNT - ONE; /*YES,DECREMENT COUNT      */
         BCTR  ECOUNT,0                                         04S0122
*                ELSE                  /*NOT CHOSEN GENERIC'S GROUP  */
*                  IF CVRGSKP = OFF THEN /*GROUP NOT YET MRKED  04S0123
*                                        INELIGIBLE          @Y30QPPA*/
         B     @RC00121                                         04S0123
@RF00121 TM    CVRGSKP(AGRPPTR),B'10000000'                     04S0123
         BNZ   @RF00123                                         04S0123
*                    DO;                                        04S0124
*                      CVRGSKP = ON;   /*MARK GROUP INELIGIBLE       */
*                      CVRFORCI = ON;  /*INDICATE WHY GRP ELIMINATED */
         OI    CVRGSKP(AGRPPTR),B'11000000'                     04S0126
*                    END;                                       04S0127
*                  ELSE;               /*                    @Y30QPPA*/
@RF00123 DS    0H                                               04S0129
*                AGRPPTR=AGRPPTR + LENGTH(CVRGPLST); /*PT TO NEXT GRP*/
@RC00121 AH    AGRPPTR,@CH00061                                 04S0129
*              END;                                             04S0130
         AH    GRPCTR,@CH00079                                  04S0130
@DE00117 L     @01,VUPTR                                        04S0130
         L     @01,VOLALGTP(,@01)                               04S0130
         CH    GRPCTR,CVRNGRP(,@01)                             04S0130
         BNH   @DL00117                                         04S0130
*              VUPTR=VUPTR+LENGTH(VOLUNTAB); /*POINT TO NEXT VU ENTRY*/
         LA    @09,28                                           04S0131
         AL    @09,VUPTR                                        04S0131
         ST    @09,VUPTR                                        04S0131
*            END;                                               04S0132
         AH    VUCTR,@CH00079                                   04S0132
@DE00114 L     @09,SPTR                                         04S0132
         CH    VUCTR,SVOLUNNO(,@09)                             04S0132
         BNH   @DL00114                                         04S0132
*          END;                                                 04S0133
*        ELSE;                         /*NOT THE GENERIC CHOSEN      */
@RF00110 DS    0H                                               04S0135
*          EDLPTR = EDLNXTNT;          /*PTR TO NEXT GEN IN THE EDL  */
         L     EDLPTR,EDLNXTNT(,EDLPTR)                         04S0135
*      END;                                                     04S0136
         LA    @09,1                                            04S0136
         AL    @09,GENCTR                                       04S0136
@DE00109 ST    @09,GENCTR                                       04S0136
         L     @07,SPTR                                         04S0136
         L     @07,SIOTEDLP(,@07)                               04S0136
         C     @09,EDLGENNO(,@07)                               04S0136
         BNH   @DL00109                                         04S0136
@DC00109 DS    0H                                               04S0137
*    END;                                                       04S0137
*  ELSE;                               /*NOT SIOT WITH SAME AFID     */
@RF00105 DS    0H                                               04S0139
*  SPTR = SIOTNPTR;                    /*POINT TO THE NEXT SIOT       *
         L     @09,SPTR                                         04S0139
         L     @09,SIOTNPTR(,@09)                               04S0139
         ST    @09,SPTR                                         04S0139
*END;                                                           04S0140
@DE00104 ICM   @09,15,SPTR                                      04S0140
         BZ    @DC00104                                         04S0140
         TM    GENFNDSW,B'00100000'                             04S0140
         BO    @DL00104                                         04S0140
@DC00104 DS    0H                                               04S0141
*IF GENFNDSW = ON  THEN                /*WAS GEN ELIGIBLE TO EACH REQ*/
         TM    GENFNDSW,B'00100000'                             03S0141
         BNO   @RF00141                                         03S0141
*  DO;                                 /*YES, TRY TO COVER VIA ALG   */
*    CALL IEFAB480 (ALGPARMP);         /*COVER ALGORITHM             */
         L     @09,@PC00001                                     03S0143
         L     @09,ALCWAPTR(,@09)                               03S0143
         L     @09,ALGTABP(,@09)                                03S0143
         ST    @09,@AL00001                                     03S0143
         L     @15,@CV00138                                     03S0143
         LA    @01,@AL00001                                     03S0143
         BALR  @14,@15                                          03S0143
*    RFY (REG15) RSTD;                                          03S0144
*    IF REG15 = ERROR480 THEN          /*GETMAIN ERROR ?             */
         CH    REG15,@CH00061                                   03S0145
         BNE   @RF00145                                         03S0145
*      DO;                             /*YES, INDICATE ..            */
*        RTNCODE = FAILURE;            /*SET ERROR RETURN CODE       */
         LA    RTNCODE,4                                        03S0147
*        REASONCD = GETMNERR;          /*SET GETMAIN REASON CODE     */
         L     @14,@PC00001                                     03S0148
         L     @14,ALCWAPTR(,@14)                               03S0148
         L     @14,FAILRSCP(,@14)                               03S0148
         MVC   REASONCD(2,@14),@CH00109                         03S0148
*      END;                                                     03S0149
*    ELSE                              /*NO GETMAIN ERROR            */
*      DO;                                                      03S0150
         B     @RC00145                                         03S0150
@RF00145 DS    0H                                               03S0151
*        IF REG15 = PARTALOC THEN      /*WERE ALL REQS COVERED BY ALG*/
         CH    REG15,@CH00055                                   03S0151
         BNE   @RF00151                                         03S0151
*          DO;                         /*NO, UPDATE ALG TABLES       */
*            GENFNDSW = OFF;           /*INDICATE GENERIC DIDNT COVER*/
         NI    GENFNDSW,B'11011111'                             03S0153
*            SPTR = SIOTPTR;           /*POINT TO FIRST SIOT OF AFID */
         ST    SIOTPTR,SPTR                                     03S0154
*            DO WHILE SPTR ^= ZERO;    /*SCAN THE REST OF THE SIOTS  */
         B     @DE00155                                         03S0155
@DL00155 DS    0H                                               03S0156
*              IF SIOTAFID = SAVEAFID THEN  /*PART OF THIS AFID GRP? */
         L     @14,SPTR                                         03S0156
         CH    SAVEAFID,SIOTAFID(,@14)                          03S0156
         BNE   @RF00156                                         03S0156
*                DO;                   /*YES,PROCESS...              */
*                  VUPTR = SVOLUNAD;   /*POINT TO FIRST VU ENTRY     */
         MVC   VUPTR(4),SVOLUNAD(@14)                           03S0158
*                  DO VUCTR=ONE TO SVOLUNNO; /*SCAN ALL VU'S FOR SIOT*/
         LA    VUCTR,1                                          03S0159
         B     @DE00159                                         03S0159
@DL00159 DS    0H                                               03S0160
*                    AGRPPTR= VOLALGTP->CVRGRPPT; /*POINT TO 1ST GRP */
         L     @14,VUPTR                                        03S0160
         L     @14,VOLALGTP(,@14)                               03S0160
         L     AGRPPTR,CVRGRPPT(,@14)                           03S0160
*                    DO GRPCTR=ONE TO VOLALGTP->CVRNGRP; /*SCAN ALL ALG
*                                        GROUP ENTRIES FOR REQUEST   */
         LA    GRPCTR,1                                         03S0161
         B     @DE00161                                         03S0161
@DL00161 DS    0H                                               03S0162
*                      IF CVRFORCI = ON THEN /*GROUP JUST ELIMINATED?*/
         TM    CVRFORCI(AGRPPTR),B'01000000'                    03S0162
         BNO   @RF00162                                         03S0162
*                        DO;           /*YES, HAVE ALG CONSIDER AGAIN*/
*                          CVRFORCI = OFF;                      03S0164
*                          CVRGSKP = OFF;                       03S0165
         NI    CVRFORCI(AGRPPTR),B'00111111'                    03S0165
*                        END;                                   03S0166
*                      ELSE;           /*GROUP WASN'T JUST ELIMINATED*/
@RF00162 DS    0H                                               03S0168
*                      AGRPPTR=AGRPPTR + LENGTH(CVRGPLST); /*POINT TO
*                                        NXT ALG GROUP LIST ENTRY    */
         AH    AGRPPTR,@CH00061                                 03S0168
*                    END;                                       03S0169
         AH    GRPCTR,@CH00079                                  03S0169
@DE00161 L     @14,VUPTR                                        03S0169
         L     @14,VOLALGTP(,@14)                               03S0169
         CH    GRPCTR,CVRNGRP(,@14)                             03S0169
         BNH   @DL00161                                         03S0169
*                    VUPTR = VUPTR + LENGTH(VOLUNTAB); /*POINT TO
*                                                    NEXT VU         */
         LA    @14,28                                           03S0170
         AL    @14,VUPTR                                        03S0170
         ST    @14,VUPTR                                        03S0170
*                  END;                                         03S0171
         AH    VUCTR,@CH00079                                   03S0171
@DE00159 L     @14,SPTR                                         03S0171
         CH    VUCTR,SVOLUNNO(,@14)                             03S0171
         BNH   @DL00159                                         03S0171
*                END;                                           03S0172
*              ELSE;                   /*NOT OF THIS AFID GROUP      */
@RF00156 DS    0H                                               03S0174
*              SPTR = SIOTNPTR;        /*POINT TO NEXT SIOT IN CHAIN */
         L     @14,SPTR                                         03S0174
         L     @14,SIOTNPTR(,@14)                               03S0174
         ST    @14,SPTR                                         03S0174
*            END;                                               03S0175
@DE00155 ICM   @14,15,SPTR                                      03S0175
         BNZ   @DL00155                                         03S0175
*          END;                                                 03S0176
*        ELSE;                         /*ALG FULLY COVERED REQUESTS  */
@RF00151 DS    0H                                               03S0178
*      END;                                                     03S0178
*    RFY (REG15) UNRSTD;                                        03S0179
@RC00145 DS    0H                                               03S0180
*  END;                                                         03S0180
*ELSE;                                 /*GEN NOT ELIGIBLE TO EACH REQ*/
@RF00141 DS    0H                                               03S0182
*RFY INDMSIOT BASED (SIOTPTR);                                  03S0182
*          END;                                                 02S0183
*        ELSE;                         /*GENERIC IS NOT ELIGIBLE     */
@RF00098 DS    0H                                               02S0185
*        EDLPTR = EDLNXTNT;            /*POINT TO NEXT GENERIC IN EDL*/
         L     EDLPTR,EDLNXTNT(,EDLPTR)                         02S0185
*      END;                                                     02S0186
         LA    @09,1                                            02S0186
         AL    @09,GENCTR                                       02S0186
@DE00097 ST    @09,GENCTR                                       02S0186
         L     @07,SIOTEDLP(,SIOTPTR)                           02S0186
         C     @09,EDLGENNO(,@07)                               02S0186
         BNH   @DL00097                                         02S0186
@DC00097 DS    0H                                               02S0187
*      IF RTNCODE=SUCCESS & GENFNDSW=OFF THEN /*WAS ONE GENERIC FOUND
*                                        TO COVER ENTIRE REQUEST ?   */
         LTR   RTNCODE,RTNCODE                                  02S0187
         BNZ   @RF00187                                         02S0187
         TM    GENFNDSW,B'00100000'                             02S0187
         BNZ   @RF00187                                         02S0187
*        DO;                           /*NO, INDICATE ERROR          */
*          RTNCODE = FAILURE;          /*SET ERROR RETURN CODE       */
         LA    RTNCODE,4                                        02S0189
*          SAVNOCOV = NOCOVER;         /*SET UNABLE-TO-ALLOC @ZA01569*/
         MVC   SAVNOCOV(2),@CH00111                             02S0190
*        END;                                                   02S0191
*      ELSE                            /*ONE GEN DID COVER,OR ERRORS */
*        DO;                                                    02S0192
         B     @RC00187                                         02S0192
@RF00187 DS    0H                                               02S0193
*          IF RTNCODE = SUCCESS THEN   /*ANY ERRORS ?                */
         LTR   RTNCODE,RTNCODE                                  02S0193
         BNZ   @RF00193                                         02S0193
*            DO;                       /*NO, BIND REQS TO GEN CHOSEN */
*              SPTR = SIOTPTR;         /*POINT TO FIRST SIOT OF AFID */
         ST    SIOTPTR,SPTR                                     02S0195
*              DO WHILE SPTR ^= ZERO;  /*SCAN THE REST OF THE SIOTS  */
         B     @DE00196                                         02S0196
@DL00196 DS    0H                                               02S0197
*                IF SPTR->SIOTAFID = SAVEAFID THEN /*SAME AFID ?     */
         L     @09,SPTR                                         02S0197
         CH    SAVEAFID,SIOTAFID(,@09)                          02S0197
         BNE   @RF00197                                         02S0197
*                  CALL IEFAB481 (SPTR,SAVGENID); /*BIND REQ TO GEN  */
         LA    @09,SPTR                                         02S0198
         ST    @09,@AL00001                                     02S0198
         LA    @09,SAVGENID                                     02S0198
         ST    @09,@AL00001+4                                   02S0198
         L     @15,@CV00139                                     02S0198
         LA    @01,@AL00001                                     02S0198
         BALR  @14,@15                                          02S0198
*                ELSE;                 /*SIOT DOES HAVE THE SAME AFID*/
@RF00197 DS    0H                                               02S0200
*                SPTR = SPTR->SIOTNPTR; /*POINT TO THE NEXT SIOT     */
         L     @09,SPTR                                         02S0200
         L     @09,SIOTNPTR(,@09)                               02S0200
         ST    @09,SPTR                                         02S0200
*              END;                                             02S0201
@DE00196 ICM   @09,15,SPTR                                      02S0201
         BNZ   @DL00196                                         02S0201
*            END;                                               02S0202
*          ELSE;                       /*ERROR                       */
@RF00193 DS    0H                                               02S0204
*        END;                                                   02S0204
*    END;                                                       02S0205
*  ELSE;                               /*NOT A MULTI-UNIT/GENERIC REQ*/
@RF00092 DS    0H                                               02S0207
*  SIOTPTR = SIOTNPTR;                 /*POINT TO THE NEXT SIOT      */
@RC00092 L     SIOTPTR,SIOTNPTR(,SIOTPTR)                       02S0207
*END;                                                           02S0208
@DE00091 SLR   @07,@07                                          02S0208
         CR    SIOTPTR,@07                                      02S0208
         BE    @DC00091                                         02S0208
         CR    RTNCODE,@07                                      02S0208
         BE    @DL00091                                         02S0208
@DC00091 DS    0H                                               02S0209
*    IF RTNCODE = SUCCESS THEN         /*ALL REQUEST STILL COVERED ? */
         LTR   RTNCODE,RTNCODE                                  01S0209
         BNZ   @RF00209                                         01S0209
*      DO;                             /*YES, CONTINUE ..            */
*/********************************************************************/
*/*                                                                  */
*/* SEGMENT NAME - REARANGE                                          */
*/*                                                                  */
*/* DESCRIPTIVE NAME - MARK REQS TO REARRANGE + CALL IEFAB477        */
*/*                                                                  */
*/* FUNCTION -                                                       */
*/*     THIS ROUTINE MARKS ALL THE VOLUNIT ENTRIES WHICH THE         */
*/*     ALGORITHM INTERFACE TABLES INDICATE MUST BE REARRANGED. THEN */
*/*     THIS ROUTINE CALLS MODULE IEFAB477 TO ACTUALLY UNALLOCATE    */
*/*     THESE VOLUNIT ENTRIES.                                       */
*/*                                                                  */
*/*   OPERATION -                                                    */
*/*       THE ALGORITHM REQUEST LIST ENTRIES ARE SCANNED TO LOCATE   */
*/*       EACH ENTRY WHICH HAS A GROUP LIST ENTRY WHICH MUST BE      */
*/*       UNALLOCATED (CVRGRPAL > CVRGALL). WHEN SUCH A REQUEST      */
*/*       LIST ENTRY IS FOUND, THE VOLUNIT TABLE IS SCANNED TO MARK  */
*/*       ALL VU ENTRIES WHICH ARE ALLOCATED TO THE SAME UNIT AS THE */
*/*       REQUEST THE ALGORITHM WANTS REARRANGED.                    */
*/*                                                                  */
*/* ENTRY - (INLINE SUBROUTINE)                                      */
*/*                                                                  */
*/*   PURPOSE - (SEE FUNCTION)                                       */
*/*                                                                  */
*/*   INPUT -                                                        */
*/*      ALCWAPTR - PTR TO THE ALLOCATION WORK AREA (ALCWA)          */
*/*        VOLUNPTR - PTR TO THE VOLUNIT TABLE                       */
*/*        VOLUNSZE - SIZE OF THE VOLUNIT TABLE                      */
*/*        ALGTABP - PTR TO THE ALGORITHM INTERFACE TABLES           */
*/*                                                                  */
*/* EXIT - NORMAL - (INLINE SUBROUTINE)                              */
*/*                                                                  */
*/*   CONDITIONS - VOLUNIT ENTRIES TO BE REARRANGED HAVE BEEN        */
*/*                SUCCESSFULLY UNALLOCATED.                         */
*/*                                                                  */
*/*   OUTPUT - NONE FROM THIS SEGMENT. SEE THE SPEC FOR MODULE       */
*/*            IEFAB477 FOR A DESCRIPTION OF ITS OUTPUT.             */
*/*                                                                  */
*/*   RETURN CODES - RTNCODE SET TO 0                                */
*/*                                                                  */
*/*                                                                  */
*/* EXIT - ERROR - (INLINE SUBROUTINE)                               */
*/*                                                                  */
*/*   CONDITIONS - GETMAIN ERROR BY IEFAB477                         */
*/*                                                                  */
*/*   OUTPUT - NONE FROM THIS SEGMENT. SEE THE SPEC FOR MODULE       */
*/*            IEFAB477 FOR A DESCRIPTION OF ITS OUTPUT.             */
*/*                                                                  */
*/*   RETURN CODES - RTNCODE SET TO 4                                */
*/*                                                                  */
*/********************************************************************/
*NEEDUNAL = OFF;                       /*ASSUME IEFAB477 NOT NEEDED  */
         NI    NEEDUNAL,B'10111111'                             02S0211
*AREQPTR = ALGRQLTP;                   /*POINT TO FIRST ALG REQUEST  */
         L     @04,@PC00001                                     02S0212
         L     @04,ALCWAPTR(,@04)                               02S0212
         L     @04,ALGTABP(,@04)                                02S0212
         L     AREQPTR,ALGRQLTP(,@04)                           02S0212
*DO AREQCTR = ONE TO CVRNREQ;          /*SCAN ALL THE ALG'S REQUESTS */
         LA    AREQCTR,1                                        02S0213
         B     @DE00213                                         02S0213
@DL00213 DS    0H                                               02S0214
*  IF CVRSKFLG = OFF                   /*IS THE ALGORITHM TO CONSIDER*/
*      & CVRALLCT > ZERO THEN          /*..AND ALREADY ALLOCATED ?   */
         TM    CVRSKFLG(AREQPTR),B'10000000'                    02S0214
         BNZ   @RF00214                                         02S0214
         ICM   @07,3,CVRALLCT(AREQPTR)                          02S0214
         BNP   @RF00214                                         02S0214
*    DO;                               /*YES, DETERMINE IF REARRANGE */
*      GRPFOUND = OFF;                 /*GROUP TO UNALLOC NOT FOUND  */
         NI    GRPFOUND,B'11101111'                             02S0216
*      AGRPPTR = CVRGRPPT;             /*POINT TO FIRST GROUP LIST NT*/
         L     AGRPPTR,CVRGRPPT(,AREQPTR)                       02S0217
*      DO AGRPCTR = ONE TO CVRNGRP     /*SCAN ALL GROUP LIST ENTRIES */
*          WHILE GRPFOUND = OFF;                                02S0218
         LA    AGRPCTR,1                                        02S0218
         B     @DE00218                                         02S0218
@DL00218 TM    GRPFOUND,B'00010000'                             02S0218
         BNZ   @DC00218                                         02S0218
*        IF CVRGRPAL > ZERO            /*MORE ALLOC'D THAN ALG COVER */
*           & CVRGALL < CVRGRPAL THEN                           02S0219
         SLR   @07,@07                                          02S0219
         LH    @15,CVRGRPAL(,AGRPPTR)                           02S0219
         CR    @15,@07                                          02S0219
         BNH   @RF00219                                         02S0219
         CH    @15,CVRGALL(,AGRPPTR)                            02S0219
         BNH   @RF00219                                         02S0219
*          DO;                         /*YES, MUST BE REARANGED      */
*            NEEDUNAL = ON;            /*INDICATE IEFAB477 NEEDED    */
*            GRPFOUND = ON;            /*INDICATE GROUP TO UNALLOC   */
         OI    NEEDUNAL,B'01010000'                             02S0222
*            CVRALLCT = ZERO;          /*ZERO COUNT ALLOC'D TO VU    */
         STH   @07,CVRALLCT(,AREQPTR)                           02S0223
*            CVRGCPTR->GRPEXCS=CVRGCPTR->GRPEXCS+CVRGRPAL; /*INCR
*                                        EXECS                       */
         L     @14,CVRGCPTR(,AGRPPTR)                           02S0224
         AH    @15,GRPEXCS(,@14)                                02S0224
         STH   @15,GRPEXCS(,@14)                                02S0224
*            CVRGRPAL = ZERO;          /*ZERO COUNT ALLOC'D FROM GRP */
         STH   @07,CVRGRPAL(,AGRPPTR)                           02S0225
*            VUPTR = VOLUNPTR;         /*POINT TO FIRST VU TABLE NTRY*/
         L     @07,@PC00001                                     02S0226
         L     @07,ALCWAPTR(,@07)                               02S0226
         MVC   VUPTR(4),VOLUNPTR(@07)                           02S0226
*            DO VUCTR=ONE TO VOLUNSZE/LENGTH(VOLUNTAB); /*SCAN ALL VU*/
         LA    VUCTR,1                                          02S0227
         B     @DE00227                                         02S0227
@DL00227 DS    0H                                               02S0228
*              IF VOLUNTID=CVRVUPTR->VOLUNTID  /*SAME UNIT ALLOCD?   */
*                  & VOLALOC = ON THEN                          02S0228
         L     @15,VUPTR                                        02S0228
         L     @01,CVRVUPTR(,AREQPTR)                           02S0228
         CLC   VOLUNTID(2,@15),VOLUNTID(@01)                    02S0228
         BNE   @RF00228                                         02S0228
         TM    VOLALOC(@15),B'10000000'                         02S0228
         BNO   @RF00228                                         02S0228
*                DO;                   /*YES,INDICATE VU TO BE UNALCD*/
*                  VUREALOC = ON;                               02S0230
         OI    VUREALOC(@15),B'01000000'                        02S0230
*                END;                                           02S0231
*              ELSE;                   /*NOT THE SAME UNIT           */
@RF00228 DS    0H                                               02S0233
*              VUPTR = VUPTR + LENGTH(VOLUNTAB); /*PT TO NEXT VU NTRY*/
         LA    @15,28                                           02S0233
         AL    @15,VUPTR                                        02S0233
         ST    @15,VUPTR                                        02S0233
*            END;                                               02S0234
         AH    VUCTR,@CH00079                                   02S0234
@DE00227 L     @15,@PC00001                                     02S0234
         L     @01,ALCWAPTR(,@15)                               02S0234
         L     @00,VOLUNSZE(,@01)                               02S0234
         SRDA  @00,32                                           02S0234
         D     @00,@CF01076                                     02S0234
         CR    VUCTR,@01                                        02S0234
         BNH   @DL00227                                         02S0234
*          END;                                                 02S0235
*        ELSE;                         /*NOT MORE ALLOC'D THAN COVER */
@RF00219 DS    0H                                               02S0237
*        AGRPPTR=AGRPPTR+LENGTH(CVRGPLST);/*PT TO NEXT GROUP LIST ENT*/
         AH    AGRPPTR,@CH00061                                 02S0237
*      END;                                                     02S0238
         AH    AGRPCTR,@CH00079                                 02S0238
@DE00218 CH    AGRPCTR,CVRNGRP(,AREQPTR)                        02S0238
         BNH   @DL00218                                         02S0238
@DC00218 DS    0H                                               02S0239
*    END;                                                       02S0239
*  ELSE;                               /*ALG REQ CANNOT BE REARRANGED*/
@RF00214 DS    0H                                               02S0241
*  AREQPTR = AREQPTR + LENGTH(CVRRQLST); /*POINT TO NEXT ALG REQUEST */
         AL    AREQPTR,@CF01076                                 02S0241
*END;                                                           02S0242
         AH    AREQCTR,@CH00079                                 02S0242
@DE00213 L     @07,@PC00001                                     02S0242
         L     @07,ALCWAPTR(,@07)                               02S0242
         L     @07,ALGTABP(,@07)                                02S0242
         L     @07,ALGPARMP(,@07)                               02S0242
         CH    AREQCTR,CVRNREQ(,@07)                            02S0242
         BNH   @DL00213                                         02S0242
*IF NEEDUNAL = ON THEN                 /*ANY REQS TO UNALLOC ?       */
         TM    NEEDUNAL,B'01000000'                             02S0243
         BNO   @RF00243                                         02S0243
*  DO;                                 /*YES, CALL IEFAB477          */
*    CALL IEFAB477 (ALCWAPTR,FUNC477); /*UNALLOC REQS TO BE REARANGED*/
         L     @04,@PC00001                                     02S0245
         ST    @04,@AL00001                                     02S0245
         LA    @04,@CB00103                                     02S0245
         ST    @04,@AL00001+4                                   02S0245
         L     @15,@CV00136                                     02S0245
         LA    @01,@AL00001                                     02S0245
         BALR  @14,@15                                          02S0245
*    RTNCODE = REG15;                  /*SAVE THE RETURN CODE        */
         LR    RTNCODE,REG15                                    02S0246
*  END;                                                         02S0247
*        IF RTNCODE = SUCCESS THEN     /*ANY ERRORS ?                */
@RF00243 LTR   RTNCODE,RTNCODE                                  01S0248
         BNZ   @RF00248                                         01S0248
*          DO;                         /*NO, CONTINUE ..             */
*/********************************************************************/
*/*                                                                  */
*/*                                                                  */
*/* SEGMENT NAME - ENDVALID                                          */
*/*                                                                  */
*/* DESCRIPTIVE NAME - VALIDITY-CHECK REMAINING REQUESTS             */
*/*                                                                  */
*/* FUNCTION -                                                       */
*/*     FOR EACH UNALLOCATED REQUEST THIS ROUTINE DETERMINES IF      */
*/*     THE VOLUME REQUESTED IS CURRENTLY MOUNTED. IF SO, IEFAB441   */
*/*     IS INVOKED TO MAKE THE FOLLOWING DETERMINATION               */
*/*       (1) IF THE VOLUME IS UNALLOCATED, THE OPERATOR IS          */
*/*           REQUESTED TO UNLOAD THE VOLUME.                        */
*/*       (2) IF THE VOLUME IS ALLOCATED, THE ADDRESS OF THE UNIT    */
*/*           WHERE THE VOLUME IS LOCATED IS SAVED (IN 'CVRWUCBP')   */
*/*           SO THIS ALLOCATION CAN WAIT FOR THE VOLUME TO          */
*/*           UNALLOCATE.                                            */
*/*       NOTE: SEE MODULE IEFAB441 FOR A DESCRIPTION OF POSSIBLE    */
*/*             ERROR CONDITIONS.                                    */
*/*                                                                  */
*/*   OPERATION -                                                    */
*/*   THIS SEGMENT SCANS THE VOLUNIT TABLE TO LOCATE REQUESTS WHICH  */
*/*   MUST BE VALIDITY-CHECKED. IEFAB441 IS INVOKED TO ACTUALLY DO   */
*/*   EACH VALIDITY CHECK (I.E. UNLOAD THE VOLUME IF FOUND AND NO    */
*/*   ERRORS ARE DETECTED).                                          */
*/*                                                                  */
*/*   VALIDITY-CHECK IS NECESSARY FOR ALL TAPE REQUESTS AND ANY      */
*/*   SPECIFIC VOLUME DA REQUESTS WHICH HAVE NOT ALREADY BEEN        */
*/*   VALIDITY CHECKED(I.E. CVRWUCBP=0).                             */
*/*                                                                  */
*/*   AS THE VU ENTRIES ARE SCANNED, THIS SEGMENT DETECTS REQS WHOSE */
*/*   DEMANDED UNITS ARE NOT AVAILABLE BY VUDMNDOF = 1               */
*/*   (IF THE UNIT IS OFFLINE) OR VUDMNDAL = 1 (IF THE UNIT IS       */
*/*   ALLOCATED) - THE 'CVRWUCBP' FIELD IS ZEROED FOR SUCH REQUESTS  */
*/*   SO THAT THIS CAN BE USED IF THE VOLUME FIELD REQUESTED         */
*/*   IS ALLOCATED TO ANOTHER UNIT.                                  */
*/*                                                                  */
*/* ENTRY - (INLINE SUBROUTINE)                                      */
*/*                                                                  */
*/*   PURPOSE - (SEE FUNCTION)                                       */
*/*                                                                  */
*/*   INPUT -                                                        */
*/*     ALCWAPTR - PTR TO ALLOCATION WORK AREA, WHICH CONTAINS       */
*/*       VOLUNPTR - PTR TO VOLUNIT TABLE                            */
*/*     RTNCODE - 0                                                  */
*/*                                                                  */
*/* EXIT - NORMAL - (INLINE SUBROUTINE)                              */
*/*                                                                  */
*/*   CONDITIONS - FUNCTION COMPLETED.                               */
*/*                                                                  */
*/*   OUTPUT -                                                       */
*/*     .NEEDED VOLUMES UNLOADED IF UNALLOCATED                      */
*/*     .CVRWUCBP FIELDS SET FOR ALLOCATED VOLUMES                   */
*/*                                                                  */
*/*   RETURN CODES - RTNCODE 0                                       */
*/*                                                                  */
*/* EXIT - ERROR - (INLINE SUBROUTINE)                               */
*/*                                                                  */
*/*   CONDITIONS + OUTPUT - (SEE MODULE IEFAB441)                    */
*/*                                                                  */
*/*   RETURN CODES - RTNCODE NON-ZERO                                */
*/*                                                                  */
*/* EXIT - ERROR - (INLINE SUBROUTINE)                       @ZA01569*/
*/*                                                                  */
*/*   CONDITIONS - ALGORITHM STILL UNABLE TO COVER           @ZA01569*/
*/*                ALL REQUESTS                              @ZA01569*/
*/*                                                                  */
*/*   OUTPUT - REASON CODE SAVE AREA , SAVNOCOV,             @ZA01569*/
*/*            SET TO 6 (UNABLE TO ALLOCATE)                 @ZA01569*/
*/*                                                                  */
*/*   RETURN CODES - RTNCODE NON-ZERO                        @ZA01569*/
*/*                                                                  */
*/* EXIT - ERROR - (INLINE SUBROUTINE)                               */
*/*                                                                  */
*/*   CONDITIONS - GETMAIN ERROR IN ALGORITHM (IEFAB480)             */
*/*                                                                  */
*/*   OUTPUT - REASONCD SET TO 2                                     */
*/*                                                                  */
*/*   RETURN CODES - RTNCODE NON-ZERO                                */
*/*                                                                  */
*/********************************************************************/
*DO MASKBYTE = ONE TO GMTENTLN;        /*INVERT MASK TO GET MASK OF
*                                        GROUPS LOCKED               */
         LA    MASKBYTE,1                                       02S0250
         B     @DE00250                                         02S0250
@DL00250 DS    0H                                               02S0251
*  NEEDMASK(MASKBYTE) = UNLKMASK(MASKBYTE) && ALLONES;          02S0251
         LA    @04,NEEDMASK-1(MASKBYTE)                         02S0251
         L     @03,@PC00001                                     02S0251
         L     @03,ALCWAPTR(,@03)                               02S0251
         L     @03,WMASKPTR(,@03)                               02S0251
         ALR   @03,MASKBYTE                                     02S0251
         BCTR  @03,0                                            02S0251
         MVC   0(1,@04),UNLKMASK(@03)                           02S0251
         XI    0(@04),X'FF'                                     02S0251
*END;                                                           02S0252
         AH    MASKBYTE,@CH00079                                02S0252
@DE00250 L     @04,@PC00001                                     02S0252
         L     @04,ALCWAPTR(,@04)                               02S0252
         L     @04,EDTABPTR(,@04)                               02S0252
         L     @04,EDTMSKTP(,@04)                               02S0252
         C     MASKBYTE,GMTENTLN(,@04)                          02S0252
         BNH   @DL00250                                         02S0252
*VUPTR = VOLUNPTR;                                              02S0253
         L     @04,@PC00001                                     02S0253
         L     @04,ALCWAPTR(,@04)                               02S0253
         MVC   VUPTR(4),VOLUNPTR(@04)                           02S0253
*DO VUCTR = ONE TO VOLUNSZE/LENGTH(VOLUNTAB) /*SCAN ALL VU ENTRIES   */
*    WHILE RTNCODE = SUCCESS & INDRETRY = OFF;                  02S0254
         LA    VUCTR,1                                          02S0254
         B     @DE00254                                         02S0254
@DL00254 SLR   @06,@06                                          02S0254
         CR    RTNCODE,@06                                      02S0254
         BNE   @DC00254                                         02S0254
         L     @04,@PC00001                                     02S0254
         L     @04,ALCWAPTR(,@04)                               02S0254
         TM    INDRETRY(@04),B'01000000'                        02S0254
         BNZ   @DC00254                                         02S0254
*  IF VUDNALOC=ON & VOLALGTP->CVRWUCBP^=ZERO /*DEMAND UNIT UNAVAIL ? */
*      & (VUDMNDOF=ON  VUDMNDAL=ON) THEN                       02S0255
         L     @04,VUPTR                                        02S0255
         TM    VUDNALOC(@04),B'00001000'                        02S0255
         BNO   @RF00255                                         02S0255
         L     @15,VOLALGTP(,@04)                               02S0255
         ICM   @14,3,CVRWUCBP(@15)                              02S0255
         BZ    @RF00255                                         02S0255
         TM    VUDMNDOF(@04),B'00110000'                        02S0255
         BZ    @RF00255                                         02S0255
*    DO;                               /*YES, ZERO PTR TO UCB        */
*      VOLALGTP->CVRWUCBP = ZERO;                               02S0257
         STH   @06,CVRWUCBP(,@15)                               02S0257
*    END;                                                       02S0258
*  ELSE;                               /*NOT UNAVAIL DEMANDED UNIT   */
@RF00255 DS    0H                                               02S0260
*    VUPTR = VUPTR + LENGTH(VOLUNTAB);                          02S0260
         LA    @06,28                                           02S0260
         AL    @06,VUPTR                                        02S0260
         ST    @06,VUPTR                                        02S0260
*END;                                                           02S0261
         AH    VUCTR,@CH00079                                   02S0261
@DE00254 L     @06,@PC00001                                     02S0261
         L     @06,ALCWAPTR(,@06)                               02S0261
         L     @00,VOLUNSZE(,@06)                               02S0261
         SRDA  @00,32                                           02S0261
         D     @00,@CF01076                                     02S0261
         CR    VUCTR,@01                                        02S0261
         BNH   @DL00254                                         02S0261
@DC00254 DS    0H                                               02S0262
*VUPTR = VOLUNPTR;                                              02S0262
         L     @04,@PC00001                                     02S0262
         L     @04,ALCWAPTR(,@04)                               02S0262
         MVC   VUPTR(4),VOLUNPTR(@04)                           02S0262
*DO VUCTR = ONE TO VOLUNSZE/LENGTH(VOLUNTAB) /*SCAN ALL VU ENTS      */
*    WHILE RTNCODE = SUCCESS & INDRETRY = OFF;                  02S0263
         LA    VUCTR,1                                          02S0263
         B     @DE00263                                         02S0263
@DL00263 LTR   RTNCODE,RTNCODE                                  02S0263
         BNZ   @DC00263                                         02S0263
         L     @06,@PC00001                                     02S0263
         L     @06,ALCWAPTR(,@06)                               02S0263
         TM    INDRETRY(@06),B'01000000'                        02S0263
         BNZ   @DC00263                                         02S0263
*  DOVALIDS = OFF;                     /*ASSUME NO VALIDITY CHECK    */
         NI    DOVALIDS,B'11111011'                             02S0264
*  IF VDEVREQD = ON THEN               /*DEVICE REQUIRED ?           */
         L     @06,VUPTR                                        02S0265
         TM    VDEVREQD(@06),B'00100000'                        02S0265
         BNO   @RF00265                                         02S0265
*    DO;                               /*YES, PROCESS ..             */
*      NDEVALID = OFF;                 /*ASSUME NO V-CHECK FOR NONREQ*/
         NI    NDEVALID,B'11110111'                             02S0267
*      IF VOLALOC=OFF & (VOLTAREQ=ON   /*IS A VALIDITY CHECK NEEDED? */
*           (VOLDAREQ=ON & VOLSPEC=ON)) THEN                   02S0268
         TM    VOLALOC(@06),B'10000000'                         02S0268
         BNZ   @RF00268                                         02S0268
         TM    VOLTAREQ(@06),B'10000000'                        02S0268
         BO    @RT00268                                         02S0268
         TM    VOLDAREQ(@06),B'00100000'                        02S0268
         BNO   @RF00268                                         02S0268
         TM    VOLSPEC(@06),B'00100000'                         02S0268
         BNO   @RF00268                                         02S0268
@RT00268 DS    0H                                               02S0269
*        DO;                           /*YES, PROCESS                */
*          NDEVALID = ON;              /*V-CHECK NOT-DEV-REQ'D ENTRYS*/
         OI    NDEVALID,B'00001000'                             02S0270
*          IF VOLALGTP->CVRWUCBP=ZERO THEN /*HAS V-CHECK BEEN DONE?  */
         L     @06,VUPTR                                        02S0271
         L     @06,VOLALGTP(,@06)                               02S0271
         ICM   @04,3,CVRWUCBP(@06)                              02S0271
         BNZ   @RF00271                                         02S0271
*            DOVALIDS = ON;            /*NO,DO VALIDITY CHECK        */
         OI    DOVALIDS,B'00000100'                             02S0272
*          ELSE;                       /*DON'T REPEAT VALIDITY-CHECK */
@RF00271 DS    0H                                               02S0274
*        END;                                                   02S0274
*      ELSE;                           /*VALIDITY-CHECK NOT NEEDED   */
@RF00268 DS    0H                                               02S0276
*    END;                                                       02S0276
*  ELSE                                /*NOT DEVICE-REQUIRED         */
*    DO;                                                        02S0277
         B     @RC00265                                         02S0277
@RF00265 DS    0H                                               02S0278
*      IF NDEVALID=ON & (VOLTAREQ=ON   /*IS A VALIDITY CHECK NEEDED? */
*           (VOLDAREQ=ON & VOLSPEC=ON)) THEN                   02S0278
         TM    NDEVALID,B'00001000'                             02S0278
         BNO   @RF00278                                         02S0278
         L     @06,VUPTR                                        02S0278
         TM    VOLTAREQ(@06),B'10000000'                        02S0278
         BO    @RT00278                                         02S0278
         TM    VOLDAREQ(@06),B'00100000'                        02S0278
         BNO   @RF00278                                         02S0278
         TM    VOLSPEC(@06),B'00100000'                         02S0278
         BNO   @RF00278                                         02S0278
@RT00278 DS    0H                                               02S0279
*        DO;                           /*YES, INDICATE               */
*          DOVALIDS = ON;                                       02S0280
         OI    DOVALIDS,B'00000100'                             02S0280
*        END;                                                   02S0281
*      ELSE;                           /*VALIDITY-CHECK NOT NEEDED   */
@RF00278 DS    0H                                               02S0283
*    END;                                                       02S0283
*  IF DOVALIDS = ON THEN               /*IS A VALIDITY-CHECK NEEDED? */
@RC00265 TM    DOVALIDS,B'00000100'                             02S0284
         BNO   @RF00284                                         02S0284
*    DO;                               /*YES,UNLOAD VOLUME IF FOUND  */
*      GENFNDSW = OFF;                 /*INITIALIZE SWITCH           */
         NI    GENFNDSW,B'11011111'                             02S0286
*      EDLPTR = VOLSIOTP->SIOTEDLP->EDLFGENP; /*PTR TO 1ST GEN IN DEL*/
         L     @06,VUPTR                                        02S0287
         L     @06,VOLSIOTP(,@06)                               02S0287
         L     @06,SIOTEDLP(,@06)                               02S0287
         L     EDLPTR,EDLFGENP(,@06)                            02S0287
*      DO WHILE GENFNDSW = OFF;        /*SCAN FOR ELIGIBLE GEN       */
         B     @DE00288                                         02S0288
@DL00288 DS    0H                                               02S0289
*        IF EINDEVTP = OFF THEN        /*IS GEN ELIGIBLE ?           */
         TM    EINDEVTP(EDLPTR),B'10000000'                     02S0289
         BNZ   @RF00289                                         02S0289
*          GENFNDSW = ON;              /*YES, END SCAN OF EDL        */
         OI    GENFNDSW,B'00100000'                             02S0290
*        ELSE                          /*GEN NOT ELIGIBLE            */
*          EDLPTR = EDLNXTNT;          /*POINT TO NEXT GEN           */
         B     @RC00289                                         02S0291
@RF00289 L     EDLPTR,EDLNXTNT(,EDLPTR)                         02S0291
*      END;                                                     02S0292
@RC00289 DS    0H                                               02S0292
@DE00288 TM    GENFNDSW,B'00100000'                             02S0292
         BZ    @DL00288                                         02S0292
*      CALL IEFAB441 (FUNC441,ALCWAPTR,VUPTR,ADDR(NEEDMASK),    02S0293
*                     EDLGRPTR->EDLLISTP->EDLUCBAD(1)->UCBTYP); 02S0293
         LA    @06,@CB00103                                     02S0293
         ST    @06,@AL00001                                     02S0293
         L     @06,@PC00001                                     02S0293
         ST    @06,@AL00001+4                                   02S0293
         LA    @06,VUPTR                                        02S0293
         ST    @06,@AL00001+8                                   02S0293
         LA    @06,NEEDMASK                                     02S0293
         ST    @06,@TF00001                                     02S0293
         LA    @06,@TF00001                                     02S0293
         ST    @06,@AL00001+12                                  02S0293
         L     @06,EDLGRPTR(,EDLPTR)                            02S0293
         L     @06,EDLLISTP(,@06)                               02S0293
         SLR   @04,@04                                          02S0293
         ICM   @04,3,EDLUCBAD(@06)                              02S0293
         LA    @06,UCBTYP(,@04)                                 02S0293
         ST    @06,@AL00001+16                                  02S0293
         L     @15,@CV00140                                     02S0293
         LA    @01,@AL00001                                     02S0293
         BALR  @14,@15                                          02S0293
*      RTNCODE = REG15;                                         02S0294
         LR    RTNCODE,REG15                                    02S0294
*    END;                                                       02S0295
*  ELSE;                               /*VALIDITY-CHECK NOT NEEDED   */
@RF00284 DS    0H                                               02S0297
*  VUPTR = VUPTR + LENGTH(VOLUNTAB);   /*POINT TO NEXT VU ENTRY      */
         LA    @06,28                                           02S0297
         AL    @06,VUPTR                                        02S0297
         ST    @06,VUPTR                                        02S0297
*END;                                                           02S0298
         AH    VUCTR,@CH00079                                   02S0298
@DE00263 L     @06,@PC00001                                     02S0298
         L     @06,ALCWAPTR(,@06)                               02S0298
         L     @00,VOLUNSZE(,@06)                               02S0298
         SRDA  @00,32                                           02S0298
         D     @00,@CF01076                                     02S0298
         CR    VUCTR,@01                                        02S0298
         BNH   @DL00263                                         02S0298
@DC00263 DS    0H                                               02S0299
*IF RTNCODE = SUCCESS THEN             /*ANY ERRORS                  */
         LTR   RTNCODE,RTNCODE                                  02S0299
         BNZ   @RF00299                                         02S0299
*  DO;                                 /*NO ERRORS                   */
*    CALL IEFAB480(ALGPARMP);          /*RECALL COVER ALG            */
         L     @04,@PC00001                                     02S0301
         L     @04,ALCWAPTR(,@04)                               02S0301
         L     @04,ALGTABP(,@04)                                02S0301
         ST    @04,@AL00001                                     02S0301
         L     @15,@CV00138                                     02S0301
         LA    @01,@AL00001                                     02S0301
         BALR  @14,@15                                          02S0301
*    RTNCODE = REG15;                  /*SAVE THE RETURN CODE        */
         LR    RTNCODE,REG15                                    02S0302
*    IF RTNCODE ^= SUCCESS THEN        /*ANY ERRORS ?                */
         LTR   RTNCODE,RTNCODE                                  02S0303
         BZ    @RF00303                                         02S0303
*      DO;                             /*YES,DETERMINE TYPE OF ERROR */
*        IF RTNCODE = PARTALOC THEN    /*NO SOLUTION ?               */
         CH    RTNCODE,@CH00055                                 02S0305
         BNE   @RF00305                                         02S0305
*          SAVNOCOV = NOCOVER;         /*YES, UNABLE TO ALLOC@ZA01569*/
         MVC   SAVNOCOV(2),@CH00111                             02S0306
*        ELSE                          /*GETMAIN ERROR               */
*          REASONCD = GETMNERR;        /*YES, SET REASON CODE        */
         B     @RC00305                                         02S0307
@RF00305 L     @04,@PC00001                                     02S0307
         L     @04,ALCWAPTR(,@04)                               02S0307
         L     @04,FAILRSCP(,@04)                               02S0307
         MVC   REASONCD(2,@04),@CH00109                         02S0307
*      END;                                                     02S0308
*    ELSE;                             /*NO ERRORS                   */
@RF00303 DS    0H                                               02S0310
*  END;                                                         02S0310
*ELSE;                                 /*VALIDITY CHECK ERRORS       */
@RF00299 DS    0H                                               02S0312
*            IF RTNCODE = SUCCESS & INDRETRY=OFF THEN /*ANY ERRORS ? */
@RC00299 LTR   RTNCODE,RTNCODE                                  01S0312
         BNZ   @RF00312                                         01S0312
         L     @04,@PC00001                                     01S0312
         L     @01,ALCWAPTR(,@04)                               01S0312
         TM    INDRETRY(@01),B'01000000'                        01S0312
         BNZ   @RF00312                                         01S0312
*              DO;                     /*NO, CONTINUE                */
*                CALL IEFAB478 (ALCWAPTR,FUNC478); /*ALOC TO AVAILIBL*/
         ST    @04,@AL00001                                     01S0314
         LA    @04,@CB00107                                     01S0314
         ST    @04,@AL00001+4                                   01S0314
         L     @15,@CV00137                                     01S0314
         LA    @01,@AL00001                                     01S0314
         BALR  @14,@15                                          01S0314
*                RTNCODE = REG15;      /*SAVE THE RETURN CODE        */
         LR    RTNCODE,REG15                                    01S0315
*                IF RTNCODE = SUCCESS & INDRETRY=OFF THEN /*ANY ERORS*/
         LTR   RTNCODE,RTNCODE                                  01S0316
         BNZ   @RF00316                                         01S0316
         L     @04,@PC00001                                     01S0316
         L     @04,ALCWAPTR(,@04)                               01S0316
         TM    INDRETRY(@04),B'01000000'                        01S0316
         BNZ   @RF00316                                         01S0316
*                  DO;                 /*NO, CONTINUE ..             */
*/********************************************************************/
*/*                                                                  */
*/* SEGMENT NAME - FREGROUP                                          */
*/*                                                                  */
*/* DESCRIPTIVE NAME - RELEASE GROUPS NO LONGER NEEDED               */
*/*                                                                  */
*/* FUNCTION -                                                       */
*/*     THIS ROUTINE RELEASES ANY DEVICE GROUPS NO LONGER NEEDED     */
*/*     BY THIS ALLOCATION. DEVICE GROUPS MAY BE NEEDED FOR THE      */
*/*     FOLLOWING REASONS:                                           */
*/*       (1) CONTAINS A SPECIFIC OFFLINE OR ALLOCATED UNIT WHICH    */
*/*           MUST BE ALLOCATED.                                     */
*/*       (2) CONTAINS AN ALLOCATED VOLUME WHICH IS NEEDED ELSEWHERE.*/
*/*       (3) CONTAINS A UNIT NEEDING A DA SCRATCH VOLUME MOUNTED.   */
*/*       (4) GROUPS WHICH THE ALGORITHM INDICATES MAY PARTICIPATE   */
*/*           IN AN ALLOCATION SOLUTION.                             */
*/*                                                                  */
*/*   OPERATION - (THE OPERATION IS DOCUMENTED BY THE CODE ITSELF)   */
*/*                                                                  */
*/* ENTRY - (INLINE SUBROUTINE)                                      */
*/*                                                                  */
*/*   INPUT -                                                        */
*/*      ALCWAPTR - PTR TO ALLOCATION WORK AREA, WHICH CONTAINS      */
*/*        VOLUNPTR - PTR TO VOLUNIT TABLE                           */
*/*        QMGRRBP  - PTR TO ALLOCATION Q-MGR REQUEST BLOCK          */
*/*        WORK3MP  - PTR TO MASK OF GROUPS VM&V NEEDS               */
*/*        WMASKPTR - PTR TO AREA FOR 'WAITMASK'                     */
*/*        WMASK2P  - PTR TO WORK AREA GROUP MASK                    */
*/*                                                                  */
*/* EXIT - NORMAL - (INLINE SUBROUTINE)                              */
*/*                                                                  */
*/*   CONDITIONS - FUNCTION COMPLETED.                               */
*/*                                                                  */
*/*   OUTPUT -                                                       */
*/*      .GROUPS NOT NEEDED HAVE BEEN RELEASED.                      */
*/*      .WAITMASK - MASK OF ALL GROUPS WHICH CONTAIN SPECIFIC,      */
*/*                  ALLOCATED UNITS OR VOLUMES WHICH MUST BE        */
*/*                  WAITED FOR.                                     */
*/*                                                                  */
*/*   RETURN CODES - (NONE)                                          */
*/*                                                                  */
*/* EXIT - ERROR - (NONE)                                            */
*/*                                                                  */
*/********************************************************************/
*NEEDMASK(ONE:GMTENTLN)=                                        02S0318
*  NEEDMASK(ONE:GMTENTLN) && NEEDMASK(ONE:GMTENTLN);/*          02S0318
*                                        ZERO MASK                   */
         L     @01,EDTABPTR(,@04)                               02S0318
         L     @01,EDTMSKTP(,@01)                               02S0318
         L     @05,GMTENTLN(,@01)                               02S0318
         BCTR  @05,0                                            02S0318
         EX    @05,@SX01098                                     02S0318
*KEEPMASK(ONE:GMTENTLN)=                                        02S0319
*  KEEPMASK(ONE:GMTENTLN) && KEEPMASK(ONE:GMTENTLN);            02S0319
         L     @01,WMASKPTR(,@04)                               02S0319
         EX    @05,@SX01100                                     02S0319
*VUPTR = VOLUNPTR;                     /*POINT TO FIRST VOLUNIT ENTRY*/
         MVC   VUPTR(4),VOLUNPTR(@04)                           02S0320
*DO VUCTR = ONE TO VOLUNSZE/LENGTH(VOLUNTAB); /*SCAN ALL VU ENTRIES  */
         LA    VUCTR,1                                          02S0321
         B     @DE00321                                         02S0321
@DL00321 DS    0H                                               02S0322
*  IF VUDMNDOF=ON  VUDMNDAL=ON THEN   /*SPECIFIC UNIT NOT AVAILABLE?*/
         L     @06,VUPTR                                        02S0322
         TM    VUDMNDOF(@06),B'00110000'                        02S0322
         BZ    @RF00322                                         02S0322
*    DO;                               /*YES, PROCESS                */
*      IF VOLSIOTP->SIOTDMND=ON THEN   /*DEMAND REQ ?                */
         L     @06,VOLSIOTP(,@06)                               02S0324
         TM    SIOTDMND(@06),B'10000000'                        02S0324
         BNO   @RF00324                                         02S0324
*        DO;                           /*YES, GET GROUP ID           */
*          THEGRPID=VOLSIOTP->SIOTEDLP->EDLFGENP->EDLGRPTR->EDLGRID;
         L     @06,SIOTEDLP(,@06)                               02S0326
         L     @06,EDLFGENP(,@06)                               02S0326
         L     @06,EDLGRPTR(,@06)                               02S0326
         L     THEGRPID,EDLGRID(,@06)                           02S0326
*          MASKPTR = ADDR(NEEDMASK);                            02S0327
         LA    @06,NEEDMASK                                     02S0327
         ST    @06,MASKPTR                                      02S0327
*          CALL TURNBIT1;              /*INDICATE GROUP IS NEEDED    */
         BAL   @14,TURNBIT1                                     02S0328
*          IF VUDMNDAL = ON THEN       /*IS UNIT NEEDED ALLOCATED ?  */
         L     @06,VUPTR                                        02S0329
         TM    VUDMNDAL(@06),B'00010000'                        02S0329
         BNO   @RF00329                                         02S0329
*            DO;                       /*YES,INDICATE GRP TO WAIT FOR*/
*              MASKPTR = ADDR(WAITMASK);                        02S0331
         L     @06,@PC00001                                     02S0331
         L     @06,ALCWAPTR(,@06)                               02S0331
         MVC   MASKPTR(4),WMASK2P(@06)                          02S0331
*              CALL TURNBIT1;                                   02S0332
         BAL   @14,TURNBIT1                                     02S0332
*            END;                                               02S0333
*          ELSE;                       /*UNIT NOT ALLOCATED          */
@RF00329 DS    0H                                               02S0335
*        END;                                                   02S0335
*      ELSE;                           /*NOT DEMAND REQ              */
@RF00324 DS    0H                                               02S0337
*    END;                                                       02S0337
*  ELSE                                /*NOT UNAVAILABLE SPECIFIC UCB*/
*    DO;                                                        02S0338
         B     @RC00322                                         02S0338
@RF00322 DS    0H                                               02S0339
*      IF VOLALOC = OFF & VDEVREQD = ON THEN /*IS THE REQ ALLOCATED? */
         L     @06,VUPTR                                        02S0339
         TM    VDEVREQD(@06),B'00100000'                        02S0339
         BNO   @RF00339                                         02S0339
         TM    VOLALOC(@06),B'10000000'                         02S0339
         BNZ   @RF00339                                         02S0339
*        DO;                           /*NO, PROCESS                 */
*          IF VOLALGTP->CVRSKFLG = OFF THEN /*CONSIDERED BY ALG?     */
         L     @06,VOLALGTP(,@06)                               02S0341
         TM    CVRSKFLG(@06),B'10000000'                        02S0341
         BNZ   @RF00341                                         02S0341
*            DO;                       /*YES, PROCESS                */
*              AGRPPTR=VOLALGTP->CVRGRPPT; /*POINT TO FIRST GROUP
*                                        ENTRY                       */
         L     AGRPPTR,CVRGRPPT(,@06)                           02S0343
*              DO AGRPCTR=ONE TO VOLALGTP->CVRNGRP; /*SCAN ALL GRP
*                                        ENTRIES                     */
         LA    AGRPCTR,1                                        02S0344
         B     @DE00344                                         02S0344
@DL00344 DS    0H                                               02S0345
*                IF CVRGSKP=OFF & CVRGALL => ZERO THEN   /*POSSIBLE
*                                        SOLUTION GROUP ?            */
         TM    CVRGSKP(AGRPPTR),B'10000000'                     02S0345
         BNZ   @RF00345                                         02S0345
         ICM   @06,3,CVRGALL(AGRPPTR)                           02S0345
         BM    @RF00345                                         02S0345
*                  DO;                 /*YES,INDICATE GROUP IS NEEDED*/
*                    THEGRPID = CVRGRPID;                       02S0347
         LH    THEGRPID,CVRGRPID(,AGRPPTR)                      02S0347
*                    MASKPTR = ADDR(NEEDMASK);                  02S0348
         LA    @06,NEEDMASK                                     02S0348
         ST    @06,MASKPTR                                      02S0348
*                    CALL TURNBIT1;                             02S0349
         BAL   @14,TURNBIT1                                     02S0349
*                    IF VOLALGTP->CVRWUCBP^=ZERO THEN /*VOL ALLOC'D? */
         L     @06,VUPTR                                        02S0350
         L     @06,VOLALGTP(,@06)                               02S0350
         ICM   @05,3,CVRWUCBP(@06)                              02S0350
         BZ    @RF00350                                         02S0350
*                      DO;             /*YES, INDICATE GROUP NEEDED  */
*                        MASKPTR = ADDR(KEEPMASK);              02S0352
         L     @06,@PC00001                                     02S0352
         L     @06,ALCWAPTR(,@06)                               02S0352
         MVC   MASKPTR(4),WMASKPTR(@06)                         02S0352
*                        CALL TURNBIT1;                         02S0353
         BAL   @14,TURNBIT1                                     02S0353
*                      END;                                     02S0354
*                    ELSE;             /*VOLUME NOT ALLOCATED        */
@RF00350 DS    0H                                               02S0356
*                  END;                                         02S0356
*                ELSE;                 /*NOT A POSSIBLE SOLUTION GRP */
@RF00345 DS    0H                                               02S0358
*                AGRPPTR=AGRPPTR+LENGTH(CVRGPLST);              02S0358
         AH    AGRPPTR,@CH00061                                 02S0358
*              END;                                             02S0359
         AH    AGRPCTR,@CH00079                                 02S0359
@DE00344 L     @06,VUPTR                                        02S0359
         L     @06,VOLALGTP(,@06)                               02S0359
         CH    AGRPCTR,CVRNGRP(,@06)                            02S0359
         BNH   @DL00344                                         02S0359
*          END;                                                 02S0360
*        ELSE                          /*REQ NOT CONSIDERED BY ALG   */
*          DO;                                                  02S0361
         B     @RC00341                                         02S0361
@RF00341 DS    0H                                               02S0362
*            IF VOLSIOTP->SIOTDMND=ON  /*DEMAND REQ                  */
*              & VOLALGTP->CVRWUCBP ^= ZERO THEN /*AND VOL ALLOCATED?*/
         L     @06,VUPTR                                        02S0362
         L     @15,VOLSIOTP(,@06)                               02S0362
         TM    SIOTDMND(@15),B'10000000'                        02S0362
         BNO   @RF00362                                         02S0362
         L     @06,VOLALGTP(,@06)                               02S0362
         ICM   @14,3,CVRWUCBP(@06)                              02S0362
         BZ    @RF00362                                         02S0362
*              DO;                     /*YES, GROUP IS NEEDED        */
*                THEGRPID = VOLSIOTP->SIOTEDLP->EDLFGENP        02S0364
*                 ->EDLGRPTR->EDLGRID;                          02S0364
         L     @06,SIOTEDLP(,@15)                               02S0364
         L     @06,EDLFGENP(,@06)                               02S0364
         L     @06,EDLGRPTR(,@06)                               02S0364
         L     THEGRPID,EDLGRID(,@06)                           02S0364
*                MASKPTR = ADDR(NEEDMASK);                      02S0365
         LA    @06,NEEDMASK                                     02S0365
         ST    @06,MASKPTR                                      02S0365
*                CALL TURNBIT1;                                 02S0366
         BAL   @14,TURNBIT1                                     02S0366
*                MASKPTR = ADDR(KEEPMASK);                      02S0367
         L     @06,@PC00001                                     02S0367
         L     @06,ALCWAPTR(,@06)                               02S0367
         MVC   MASKPTR(4),WMASKPTR(@06)                         02S0367
*                CALL TURNBIT1;                                 02S0368
         BAL   @14,TURNBIT1                                     02S0368
*              END;                                             02S0369
*            ELSE;                     /*NONDEMAND OR VOL NOT ALLOC'D*/
@RF00362 DS    0H                                               02S0371
*          END;                                                 02S0371
*        END;                                                   02S0372
*      ELSE;                           /*REQ IS ALLOCATED            */
@RF00339 DS    0H                                               02S0374
*    END;                                                       02S0374
@RC00339 DS    0H                                               02S0375
*  IF VOLALGTP^=ZERO & VOLALGTP->CVRWUCBP^=ZERO THEN  /*VOLUME-NEEDED
*                                        ALLOCATED ?   */       02S0375
@RC00322 L     @06,VUPTR                                        02S0375
         L     @06,VOLALGTP(,@06)                               02S0375
         LTR   @06,@06                                          02S0375
         BZ    @RF00375                                         02S0375
         SLR   @15,@15                                          02S0375
         ICM   @15,3,CVRWUCBP(@06)                              02S0375
         LTR   @15,@15                                          02S0375
         BZ    @RF00375                                         02S0375
*    DO;                                                        02S0376
*      UCBPTR = VOLALGTP->CVRWUCBP;    /*SAVE PTR TO UCB             */
         LR    UCBPTR,@15                                       02S0377
*/********************************************************************/
*/*                                                                  */
*/* SEGMENT NAME - FINDGRP                                           */
*/*                                                                  */
*/* DESCRIPTIVE NAME - DETERMINE GROUP ID OF UCB                     */
*/*                                                                  */
*/* FUNCTION -                                                       */
*/*     THIS ROUTINE DETERMINES THE GROUP ID OF A UCB                */
*/*                                                                  */
*/*   OPERATION - THE EDT GROUP ENTRIES ARE SCANNED TO LOCATE        */
*/*               THE UCB                                            */
*/*                                                                  */
*/* ENTRY - (INLINE SUBROUTINE)                                      */
*/*                                                                  */
*/*   PURPOSE - (SEE FUNCTION)                                       */
*/*                                                                  */
*/*   INPUT -                                                        */
*/*     ALCWAPTR - PTR TO THE ALLOCATION WORK AREA                   */
*/*       EDTABPTR - PTR TO THE SYSGEN'ED EDT                        */
*/*     UCBPTR - PTR TO THE UCB TO LOCATE                            */
*/*                                                                  */
*/* EXIT - NORMAL - (INLINE SUBROUTINE)                              */
*/*                                                                  */
*/*   CONDITIONS - UCB'S GROUP ID DETERMINED.                        */
*/*                                                                  */
*/*   OUTPUT -                                                       */
*/*     FNDGRPID - GROUP ID OF UCB                                   */
*/*                                                                  */
*/* EXIT - ERROR - (NONE)                                            */
*/*                                                                  */
*/********************************************************************/
*UCBFOUND = OFF;                       /*INDICATE UCB NOT LOCATED    */
         NI    UCBFOUND,B'11111110'                             03S0378
*GRPPTR = EDTGRPSP + LENGTH(GRPHDR);   /*LOCATE FIRST GROUP ENTRY    */
         L     @06,@PC00001                                     03S0379
         L     @06,ALCWAPTR(,@06)                               03S0379
         L     @06,EDTABPTR(,@06)                               03S0379
         LA    GRPPTR,8                                         03S0379
         AL    GRPPTR,EDTGRPSP(,@06)                            03S0379
*DO GRPCTR = ONE TO GRPENTNO           /*SCAN ALL GROUP ENTRIES      */
*    WHILE UCBFOUND = OFF;                                      03S0380
         LA    GRPCTR,1                                         03S0380
         B     @DE00380                                         03S0380
@DL00380 TM    UCBFOUND,B'00000001'                             03S0380
         BNZ   @DC00380                                         03S0380
*  DO UCBCTR = ONE TO GRPUCBNO         /*SCAN ALL UCBS IN GROUP      */
*      WHILE UCBFOUND = OFF;                                    03S0381
         LA    UCBCTR,1                                         03S0381
         B     @DE00381                                         03S0381
@DL00381 TM    UCBFOUND,B'00000001'                             03S0381
         BNZ   @DC00381                                         03S0381
*    IF IOSLUT(EUCBTPOS(UCBCTR)+ONE)=UCBPTR THEN /*UCB FOUND ?       */
         LR    @08,UCBCTR                                       03S0382
         ALR   @08,@08                                          03S0382
         L     @06,GRPUCBP(,GRPPTR)                             03S0382
         BCTR  @06,0                                            03S0382
         BCTR  @06,0                                            03S0382
         LH    @08,EUCBTPOS(@08,@06)                            03S0382
         ALR   @08,@08                                          03S0382
         L     @06,@PC00001                                     03S0382
         L     @06,ALCWAPTR(,@06)                               03S0382
         L     @06,IOSLUTP(,@06)                                03S0382
         ALR   @06,@08                                          03S0382
         SLR   @08,@08                                          03S0382
         ICM   @08,3,IOSLUT(@06)                                03S0382
         CR    UCBPTR,@08                                       03S0382
         BNE   @RF00382                                         03S0382
*      DO;                             /*YES, SAVE GROUP ID          */
*        UCBFOUND = ON;                                         03S0384
         OI    UCBFOUND,B'00000001'                             03S0384
*        FNDGRPID = GRPID;                                      03S0385
         MVC   FNDGRPID(4),GRPID(GRPPTR)                        03S0385
*      END;                                                     03S0386
*    ELSE;                             /*UCB NOT FOUND               */
@RF00382 DS    0H                                               03S0388
*  END;                                                         03S0388
         AH    UCBCTR,@CH00079                                  03S0388
@DE00381 C     UCBCTR,GRPUCBNO(,GRPPTR)                         03S0388
         BNH   @DL00381                                         03S0388
@DC00381 DS    0H                                               03S0389
*  GRPPTR = GRPPTR + GRPENTLN;         /*POINT TO NEXT GROUP ENTRY   */
         L     @08,@PC00001                                     03S0389
         L     @08,ALCWAPTR(,@08)                               03S0389
         L     @08,EDTABPTR(,@08)                               03S0389
         L     @08,EDTGRPSP(,@08)                               03S0389
         AL    GRPPTR,GRPENTLN(,@08)                            03S0389
*END;                                                           03S0390
         AH    GRPCTR,@CH00079                                  03S0390
@DE00380 L     @08,@PC00001                                     03S0390
         L     @08,ALCWAPTR(,@08)                               03S0390
         L     @08,EDTABPTR(,@08)                               03S0390
         L     @08,EDTGRPSP(,@08)                               03S0390
         C     GRPCTR,GRPENTNO(,@08)                            03S0390
         BNH   @DL00380                                         03S0390
@DC00380 DS    0H                                               03S0391
*      THEGRPID = FNDGRPID;            /*COPY GROUP ID FOUND         */
         L     THEGRPID,FNDGRPID                                02S0391
*      MASKPTR = ADDR(NEEDMASK);                                02S0392
         LA    @06,NEEDMASK                                     02S0392
         ST    @06,MASKPTR                                      02S0392
*      CALL TURNBIT1;                  /*INDICATE GROUP IS NEEDED    */
         BAL   @14,TURNBIT1                                     02S0393
*      MASKPTR = ADDR(WAITMASK);                                02S0394
         L     @06,@PC00001                                     02S0394
         L     @06,ALCWAPTR(,@06)                               02S0394
         MVC   MASKPTR(4),WMASK2P(@06)                          02S0394
*      CALL TURNBIT1;                  /*INDICATE TO WAIT FOR GROUP  */
         BAL   @14,TURNBIT1                                     02S0395
*    END;                                                       02S0396
*  ELSE;                               /*NOT ALLOCATED VOLUME        */
@RF00375 DS    0H                                               02S0398
*  VUPTR = VUPTR + LENGTH(VOLUNTAB);   /*POINT TO NEXT VOLUNIT ENTRY */
         LA    @06,28                                           02S0398
         AL    @06,VUPTR                                        02S0398
         ST    @06,VUPTR                                        02S0398
*END;                                                           02S0399
         AH    VUCTR,@CH00079                                   02S0399
@DE00321 L     @06,@PC00001                                     02S0399
         L     @06,ALCWAPTR(,@06)                               02S0399
         L     @00,VOLUNSZE(,@06)                               02S0399
         SRDA  @00,32                                           02S0399
         D     @00,@CF01076                                     02S0399
         CR    VUCTR,@01                                        02S0399
         BNH   @DL00321                                         02S0399
*NEEDMASK(ONE:GMTENTLN)=NEEDMASK(ONE:GMTENTLN)  VERIFYMK(ONE:GMTENTLN)
         L     @15,@PC00001                                     02S0400
         L     @15,ALCWAPTR(,@15)                               02S0400
         L     @01,EDTABPTR(,@15)                               02S0400
         L     @01,EDTMSKTP(,@01)                               02S0400
         L     @14,GMTENTLN(,@01)                               02S0400
         BCTR  @14,0                                            02S0400
         L     @01,WORK3MP(,@15)                                02S0400
         EX    @14,@SO01104                                     02S0400
*                                                   /*ADD VERIFY MASK*/
*DO MASKBYTE=ONE TO GMTENTLN;          /*INVERT TO MASK NOT NEEDED   */
         LA    MASKBYTE,1                                       02S0401
         B     @DE00401                                         02S0401
@DL00401 DS    0H                                               02S0402
*  NEEDMASK(MASKBYTE)=NEEDMASK(MASKBYTE) && ALLONES;            02S0402
         LA    @03,NEEDMASK-1(MASKBYTE)                         02S0402
         XI    0(@03),X'FF'                                     02S0402
*END;                                                           02S0403
         AH    MASKBYTE,@CH00079                                02S0403
@DE00401 L     @03,@PC00001                                     02S0403
         L     @03,ALCWAPTR(,@03)                               02S0403
         L     @03,EDTABPTR(,@03)                               02S0403
         L     @03,EDTMSKTP(,@03)                               02S0403
         C     MASKBYTE,GMTENTLN(,@03)                          02S0403
         BNH   @DL00401                                         02S0403
*QMGRRBP->AQMECODE = RLSEFUNC;         /*INDICATE TO RELEASE GROUPS  */
         L     @04,@PC00001                                     02S0404
         L     @04,ALCWAPTR(,@04)                               02S0404
         L     @15,QMGRRBP(,@04)                                02S0404
         MVC   AQMECODE(2,@15),@CH00075                         02S0404
*QMGRRBP->AQMMASKP = ADDR(NEEDMASK);   /*POINT TO MASK TO FREE       */
         LA    @14,NEEDMASK                                     02S0405
         ST    @14,AQMMASKP(,@15)                               02S0405
*CALL IEFAB4FA (QMGRRBP,EXITPRMP);     /*RELEASE GROUPS              */
         LA    @15,QMGRRBP(,@04)                                02S0406
         ST    @15,@AL00001                                     02S0406
         LA    @04,EXITPRMP(,@04)                               02S0406
         ST    @04,@AL00001+4                                   02S0406
         L     @15,@CV00134                                     02S0406
         LA    @01,@AL00001                                     02S0406
         BALR  @14,@15                                          02S0406
*RTNCODE = REG15;                      /*SAVE THE RETURN CODE        */
         LR    RTNCODE,REG15                                    02S0407
*                    IF TOTREQS > ZERO THEN /*ANY REQS TO ALLOC      */
         L     @04,@PC00001                                     01S0408
         L     @04,ALCWAPTR(,@04)                               01S0408
         ICM   @15,15,TOTREQS(@04)                              01S0408
         BNP   @RF00408                                         01S0408
*                      DO;             /*YES, INTERFACE WITH OPERATOR*/
*/********************************************************************/
*/*                                                                  */
*/* SEGMENT NAME - SETHANDL                                          */
*/*                                                                  */
*/* DESCRIPTIVE NAME - INDICATE REQS THAT CAN ALLOCATE TO AVAILABLE  */
*/*                    DEVICES                                       */
*/*                                                                  */
*/* FUNCTION - THIS ROUTINE MARKS AS PROCESSED (VURCVYPR=1) ANY      */
*/*            REQS WHICH COULD ALLOCATE TO AVAILABLE DEVICES        */
*/*            AS SOON AS THE VOLUME NEEDED IS UNALLOCATED FROM      */
*/*            WHERE IT IS CURRENTLY ALLOCATED (CVRWUCBP).           */
*/*                                                                  */
*/*            AT THE END OF THIS PROCESSING THE ALGORITHM IS        */
*/*            CALLED TO REDUCE THE ALGORITHM CHOICES DUE TO ANY     */
*/*            GROUPS ALREADY PICKED.                                */
*/*                                                                  */
*/*            THIS ROUTINE ALSO TURNS OFF 'VUDNALOC' FOR            */
*/*            REQUESTS WHOSE VOLUME IS ALLOCATED ELSEWHERE OR FOR   */
*/*            DEMAND REQUESTS WHOSE UNIT IS OFFLINE OR ALLOCATED.   */
*/*                                                                  */
*/*   OPERATION - (THE OPERATION IS DOCUMENTED BY THE CODE ITSELF)   */
*/*                                                                  */
*/* ENTRY - (INLINE SUBROUTINE)                                      */
*/*                                                                  */
*/*   PURPOSE - (SEE FUNCTION)                                       */
*/*                                                                  */
*/*   INPUT -                                                        */
*/*      ALCWAPTR - PTR TO THE ALLOCATION WORK AREA, WHICH CONTAINS  */
*/*        EDTABPTR - PTR TO THE EDT                                 */
*/*        IOSLUTP - PTR TO THE IOS UCB LOOKUP TABLE                 */
*/*        ALGTABP - PTR TO THE ALGORITHM INTERFACE TABLES           */
*/*        FAILRSCP - PTR TO THE STEP REASON CODE AREA               */
*/*                                                                  */
*/* EXIT - NORMAL - (INLINE SUBROUTINE)                              */
*/*                                                                  */
*/*   CONDITIONS - FUNCTION COMPLETED WITHOUT AN ERROR.              */
*/*                                                                  */
*/*   OUTPUT -                                                       */
*/*       VURVYPR=1 FOR REQS WHICH CAN ALLOCATE WHICH THEIR          */
*/*          REQUESTED VOLUME IS UNALLOCATED                         */
*/*       CVRGALL=1 FOR GROUP CHOSEN FOR A REQUEST WITH VURCVYPR=1   */
*/*       VUDNALOC = 0                                               */
*/*                                                                  */
*/*   RETURN CODES - RTNCODE = 0                                     */
*/*                                                                  */
*/* EXIT - ERROR - (INLINE SUBROUTINE)                               */
*/*                                                                  */
*/*   CONDITIONS - GETMAIN ERROR DETECTED BY IEFAB480                */
*/*                                                                  */
*/*   OUTPUT - STEP REASON CODE (REASONCD) SET TO 2                  */
*/*                                                                  */
*/*   RETURN CODES - RTNCODE = NON-ZERO                              */
*/*                                                                  */
*/********************************************************************/
*RFY GRPENTRY BASED (GROUPPTR);                                 02S0410
*CVRFCALL = OFF;                       /*INDICATE 'REDUCE' FUNCTION  */
         L     @04,ALGTABP(,@04)                                02S0411
         L     @01,ALGPARMP(,@04)                               02S0411
         NI    CVRFCALL(@01),B'11101111'                        02S0411
*CALL IEFAB480 (ALGPARMP);             /*REDUCE SOLUTIONS            */
         ST    @04,@AL00001                                     02S0412
         L     @15,@CV00138                                     02S0412
         LA    @01,@AL00001                                     02S0412
         BALR  @14,@15                                          02S0412
*RTNCODE = REG15;                      /*SAVE THE RETURN CODE        */
         LR    RTNCODE,REG15                                    02S0413
*IF RTNCODE ^= SUCCESS THEN            /*ANY ERRORS ?                */
         LTR   RTNCODE,RTNCODE                                  02S0414
         BZ    @RF00414                                         02S0414
*  REASONCD = GETMNERR;                /*YES,INDICATE GETMAIN ERROR  */
         L     @04,@PC00001                                     02S0415
         L     @04,ALCWAPTR(,@04)                               02S0415
         L     @04,FAILRSCP(,@04)                               02S0415
         MVC   REASONCD(2,@04),@CH00109                         02S0415
*ELSE;                                 /*NO ERRORS                   */
@RF00414 DS    0H                                               02S0417
*MASKPTR = ADDR(NEEDMASK);             /*POINT TO THE GRPS NOT NEEDED*/
         LA    @04,NEEDMASK                                     02S0417
         ST    @04,MASKPTR                                      02S0417
*DO GROUPNO=ONE TO EIGHT*GMTENTLN;     /*SCAN EACH GROUP             */
         LA    @04,1                                            02S0418
         B     @DE00418                                         02S0418
@DL00418 DS    0H                                               02S0419
*  CALL TESTBIT;                       /*TEST IF GROUP IS NEEDED     */
         BAL   @14,TESTBIT                                      02S0419
*  IF BITRTN = OFF THEN                                         02S0420
         TM    BITRTN,B'10000000'                               02S0420
         BNZ   @RF00420                                         02S0420
*    DO;                               /*GROUP IS NEEDED - PROCESS   */
*      GROUPPTR=EDTGRPSP+LENGTH(GRPHDR) /*LOCATE GROUP IN THE EDT    */
*          + LENGTH(GRPENTRY)*(GROUPNO-ONE);                    02S0422
         L     @06,@PC00001                                     02S0422
         L     @06,ALCWAPTR(,@06)                               02S0422
         L     @06,EDTABPTR(,@06)                               02S0422
         LA    GROUPPTR,8                                       02S0422
         AL    GROUPPTR,EDTGRPSP(,@06)                          02S0422
         L     @06,GROUPNO                                      02S0422
         BCTR  @06,0                                            02S0422
         MH    @06,@CH00033                                     02S0422
         ALR   GROUPPTR,@06                                     02S0422
*      AVAILCTR = ZERO;                /*INIT COUNT OF AVAILABLE DEVS*/
         SLR   AVAILCTR,AVAILCTR                                02S0423
*      DO UCBCTR = ONE TO GRPUCBNO;    /*SCAN ALL UCBS IN THE GROUP  */
         LA    UCBCTR,1                                         02S0424
         B     @DE00424                                         02S0424
@DL00424 DS    0H                                               02S0425
*        UCBPTR=IOSLUT(EUCBTPOS(UCBCTR)+1); /*GET ADDR OF THE UCB    */
         LR    @09,UCBCTR                                       02S0425
         ALR   @09,@09                                          02S0425
         L     @06,GRPUCBP(,GROUPPTR)                           02S0425
         BCTR  @06,0                                            02S0425
         BCTR  @06,0                                            02S0425
         LH    @09,EUCBTPOS(@09,@06)                            02S0425
         ALR   @09,@09                                          02S0425
         L     @06,@PC00001                                     02S0425
         L     @06,ALCWAPTR(,@06)                               02S0425
         L     @06,IOSLUTP(,@06)                                02S0425
         ALR   @06,@09                                          02S0425
         SLR   UCBPTR,UCBPTR                                    02S0425
         ICM   UCBPTR,3,IOSLUT(@06)                             02S0425
*        IF UCBNALOC = OFF                                      02S0426
*           & UCBONLI = ON                                      02S0426
*           & UCBALOC = OFF                                     02S0426
*           & (UCBSYSR = OFF                                    02S0426
*            (UCB3DACC = ON  UCB3TAPE = ON))                  02S0426
*           & (UCB3DACC = OFF  (UCBPRES = OFF                  02S0426
*           & UCBRESV = OFF)        /*                    @YM05583*/
*           (UCBPRES=ON & (UCBVOLI=NOVOLSER /*             @YM05583*/
*            UCBMOUNT=ON)))         /*                    @YM05583*/
*           & (UCB3TAPE = OFF  UCBRESV = OFF) THEN/*           02S0426
*                                        IS THE UCB AVAILABLE ?      */
         TM    UCBNALOC(UCBPTR),B'00000100'                     02S0426
         BNZ   @RF00426                                         02S0426
         TM    UCBONLI(UCBPTR),B'10000000'                      02S0426
         BNO   @RF00426                                         02S0426
         TM    UCBALOC(UCBPTR),B'00001000'                      02S0426
         BNZ   @RF00426                                         02S0426
         TM    UCBSYSR(UCBPTR),B'00000010'                      02S0426
         BZ    @GL00025                                         02S0426
         TM    UCB3DACC(UCBPTR),B'10100000'                     02S0426
         BZ    @RF00426                                         02S0426
@GL00025 TM    UCB3DACC(UCBPTR),B'00100000'                     02S0426
         BZ    @GL00024                                         02S0426
         TM    UCBPRES(UCBPTR),B'00100100'                      02S0426
         BZ    @GL00024                                         02S0426
         TM    UCBPRES(UCBPTR),B'00000100'                      02S0426
         BNO   @RF00426                                         02S0426
         CLC   UCBVOLI(6,UCBPTR),NOVOLSER                       02S0426
         BE    @GL00024                                         02S0426
         TM    UCBMOUNT(UCBPTR),B'10000000'                     02S0426
         BNO   @RF00426                                         02S0426
@GL00024 TM    UCB3TAPE(UCBPTR),B'10000000'                     02S0426
         BZ    @RT00426                                         02S0426
         TM    UCBRESV(UCBPTR),B'00100000'                      02S0426
         BNZ   @RF00426                                         02S0426
@RT00426 DS    0H                                               02S0427
*          DO;                         /*YES, SEE IF DEMANDED        */
*/********************************************************************/
*/*                                                                  */
*/* SEGMENT NAME - DMNDNEED                                          */
*/*                                                                  */
*/* DESCRIPTIVE NAME - TEST IF UCB IS DEMANDED                       */
*/*                                                                  */
*/* FUNCTION - THIS ROUTINE DETERMINES IF THE INPUT UCB IS           */
*/*            NEEDED BY A DEMAND REQUEST (E.G. UNIT=190).           */
*/*                                                                  */
*/*   OPERATION - THE SIOT CHAIN IS SCANNED TO LOCATE EACH           */
*/*               DEMAND REQUEST.                                    */
*/*                                                                  */
*/* ENTRY - (INLINE SUBROUTINE)                                      */
*/*                                                                  */
*/*   INPUT -                                                        */
*/*      SIOT1P - PTR TO THE FIRST SIOT IN THE CHAIN                 */
*/*        SIOTDMND - 1 FOR DEMAND REQUESTS                          */
*/*        SIOUCBAD - FOR DEMAND REQUEST, ADDRESS OF THE             */
*/*                   DEMANDED UCB                                   */
*/*        SIOTNPTR - PTR TO THE NEXT SIOT                           */
*/*      UCBPTR - PTR TO UCB                                         */
*/*                                                                  */
*/* EXIT - NORMAL - INLINE SUBROUTINE                                */
*/*                                                                  */
*/*   CONDITIONS - FUNCTION COMPLETED                                */
*/*                                                                  */
*/*   OUTPUT -                                                       */
*/*       USEUCB - 1 = NO DEMAND REQ NEEDS THIS UCB                  */
*/*              - 0 = A DEMAND REQ NEEDS THIS UCB                   */
*/*                                                                  */
*/********************************************************************/
*USEUCB = ON;                          /*ASSUME UCB NOT DEMANDED     */
         OI    USEUCB,B'00000010'                               03S0428
*RFY INDMSIOT BASED(SPTR);                                      03S0429
*SPTR = SIOT1P;                        /*POINT TO THE FIRST SIOT     */
         L     @09,@PC00001                                     03S0430
         L     @09,ALCWAPTR(,@09)                               03S0430
         MVC   SPTR(4),SIOT1P(@09)                              03S0430
*DO WHILE (SPTR ^= ZERO                /*SCAN ALL SIOTS ..           */
*    & USEUCB = ON);                   /*..UNTIL UCB FOUND DEMANDED  */
         B     @DE00431                                         03S0431
@DL00431 DS    0H                                               03S0432
*  IF SIOTDMND = ON                    /*DEMAND REQ FOR THIS UCB ?   */
*      & SIOUCBAD = UCBPTR THEN                                 03S0432
         L     @09,SPTR                                         03S0432
         TM    SIOTDMND(@09),B'10000000'                        03S0432
         BNO   @RF00432                                         03S0432
         SLR   @06,@06                                          03S0432
         ICM   @06,7,SIOUCBAD(@09)                              03S0432
         CR    UCBPTR,@06                                       03S0432
         BNE   @RF00432                                         03S0432
*    DO;                               /*YES,INDICATE UCB IS DEMANDED*/
*      USEUCB = OFF;                                            03S0434
         NI    USEUCB,B'11111101'                               03S0434
*    END;                                                       03S0435
*  ELSE;                               /*NOT DEMAND REQ FOR THIS UCB */
@RF00432 DS    0H                                               03S0437
*  SPTR = SIOTNPTR;                    /*POINT TO THE NEXT SIOT      */
         L     @09,SPTR                                         03S0437
         L     @09,SIOTNPTR(,@09)                               03S0437
         ST    @09,SPTR                                         03S0437
*END;                                                           03S0438
@DE00431 ICM   @09,15,SPTR                                      03S0438
         BZ    @DC00431                                         03S0438
         TM    USEUCB,B'00000010'                               03S0438
         BO    @DL00431                                         03S0438
@DC00431 DS    0H                                               03S0439
*RFY INDMSIOT BASED;                                            03S0439
*            IF USEUCB = ON THEN       /*UCB NOT DEMANDED            */
         TM    USEUCB,B'00000010'                               02S0440
         BNO   @RF00440                                         02S0440
*              AVAILCTR = AVAILCTR + ONE;  /*NO, INCREMENT COUNT OF
*                                        AVAIL                       */
         AH    AVAILCTR,@CH00079                                02S0441
*            ELSE;                     /*UCB DEMANDED                */
@RF00440 DS    0H                                               02S0443
*          END;                                                 02S0443
*        ELSE;                         /*UCB IS NOT AVAILABLE        */
@RF00426 DS    0H                                               02S0445
*      END;                                                     02S0445
         AH    UCBCTR,@CH00079                                  02S0445
@DE00424 C     UCBCTR,GRPUCBNO(,GROUPPTR)                       02S0445
         BNH   @DL00424                                         02S0445
*      AREQPTR = ALGRQLTP;             /*POINT TO FIRST ALG REQ ENTRY*/
         L     @09,@PC00001                                     02S0446
         L     @09,ALCWAPTR(,@09)                               02S0446
         L     @09,ALGTABP(,@09)                                02S0446
         L     AREQPTR,ALGRQLTP(,@09)                           02S0446
*      DO AREQCTR = ONE TO CVRNREQ     /*SCAN ALL ALG REQ LIST ENTRYS*/
*          WHILE (AVAILCTR > ZERO);                             02S0447
         LA    AREQCTR,1                                        02S0447
         B     @DE00447                                         02S0447
@DL00447 LTR   AVAILCTR,AVAILCTR                                02S0447
         BNP   @DC00447                                         02S0447
*        IF CVRWUCBP ^= ZERO           /*IS REQ WAITING FOR VOLUME.. */
*            & CVRVUPTR-> VOLALOC = OFF /*..STILL UNALLOCATED ..     */
*            & CVRVUPTR->VURCVYPR = OFF /*..NOT HANDLED BY RTN YET   */
*            & CVRSKFLG = OFF THEN     /*..AND CONSIDER BY THE ALG ? */
         ICM   @09,3,CVRWUCBP(AREQPTR)                          02S0448
         BZ    @RF00448                                         02S0448
         L     @09,CVRVUPTR(,AREQPTR)                           02S0448
         TM    VOLALOC(@09),B'10000000'                         02S0448
         BNZ   @RF00448                                         02S0448
         TM    VURCVYPR(@09),B'00000001'                        02S0448
         BNZ   @RF00448                                         02S0448
         TM    CVRSKFLG(AREQPTR),B'10000000'                    02S0448
         BNZ   @RF00448                                         02S0448
*          DO;                         /*YES, PROCESS                */
*            AGRPPTR = CVRGRPPT;       /*POINT TO FIRST GROUP LIST
*                                        ENTRY FOR THIS REQUEST      */
         L     AGRPPTR,CVRGRPPT(,AREQPTR)                       02S0450
*            DO GRPCTR=ONE TO CVRNGRP; /*SCAN ALL GROUP LIST ENTRIES */
         LA    GRPCTR,1                                         02S0451
         B     @DE00451                                         02S0451
@DL00451 DS    0H                                               02S0452
*              IF CVRGRPID = GRPID     /*SAME GROUP ID PICKED BY ALG */
*                  & CVRGALL => ZERO THEN /*..FOR THIS REQUEST ?     */
         LH    @02,CVRGRPID(,AGRPPTR)                           02S0452
         C     @02,GRPID(,GROUPPTR)                             02S0452
         BNE   @RF00452                                         02S0452
         ICM   @02,3,CVRGALL(AGRPPTR)                           02S0452
         BM    @RF00452                                         02S0452
*                DO;                   /*YES, PROCESS                */
*                  AVAILCTR=AVAILCTR-ONE; /*DECREMENT AVAILABLE UNITS*/
         BCTR  AVAILCTR,0                                       02S0454
*                  CVRGRPAL = ONE;     /*INDICATE ALLOC WILL USE GRP */
         LA    @02,1                                            02S0455
         STH   @02,CVRGRPAL(,AGRPPTR)                           02S0455
*                  CVRALLCT = ONE;     /*INDICATE REQ COVERED BY
*                                        CALLER                      */
         STH   @02,CVRALLCT(,AREQPTR)                           02S0456
*                  CVRVUPTR->VURCVYPR = ON; /*INDICATE REQ IS HANDLED*/
         L     @02,CVRVUPTR(,AREQPTR)                           02S0457
         OI    VURCVYPR(@02),B'00000001'                        02S0457
*                  CVRFCALL = OFF;     /*INDICATE 'REDUCE' FUNCTION  */
         L     @02,@PC00001                                     02S0458
         L     @02,ALCWAPTR(,@02)                               02S0458
         L     @02,ALGTABP(,@02)                                02S0458
         L     @01,ALGPARMP(,@02)                               02S0458
         NI    CVRFCALL(@01),B'11101111'                        02S0458
*                  CALL IEFAB480 (ALGPARMP); /*REDUCE SOLUTIONS      */
         ST    @02,@AL00001                                     02S0459
         L     @15,@CV00138                                     02S0459
         LA    @01,@AL00001                                     02S0459
         BALR  @14,@15                                          02S0459
*                  RTNCODE = REG15;    /*SAVE THE RETURN CODE        */
         LR    RTNCODE,REG15                                    02S0460
*                  IF RTNCODE ^= SUCCESS THEN /*ANY ERRORS ?         */
         LTR   RTNCODE,RTNCODE                                  02S0461
         BZ    @RF00461                                         02S0461
*                    REASONCD = GETMNERR; /*YES,INDICATE GETMAIN EROR*/
         L     @02,@PC00001                                     02S0462
         L     @02,ALCWAPTR(,@02)                               02S0462
         L     @02,FAILRSCP(,@02)                               02S0462
         MVC   REASONCD(2,@02),@CH00109                         02S0462
*                  ELSE;               /*NO ERRORS                   */
@RF00461 DS    0H                                               02S0464
*                END;                                           02S0464
*              ELSE;                   /*GROUP IN QUESTION NOT PICKED*/
@RF00452 DS    0H                                               02S0466
*              AGRPPTR=AGRPPTR+LENGTH(CVRGPLST); /*POINT TO NEXT GRP */
         AH    AGRPPTR,@CH00061                                 02S0466
*            END;                                               02S0467
         AH    GRPCTR,@CH00079                                  02S0467
@DE00451 CH    GRPCTR,CVRNGRP(,AREQPTR)                         02S0467
         BNH   @DL00451                                         02S0467
*          END;                                                 02S0468
*        ELSE;                         /*ALG REQ NOT TO PROCESS      */
@RF00448 DS    0H                                               02S0470
*        AREQPTR=AREQPTR+LENGTH(CVRRQLST); /*POINT TO NEXT REQ ENTRY */
         AL    AREQPTR,@CF01076                                 02S0470
*      END;                                                     02S0471
         AH    AREQCTR,@CH00079                                 02S0471
@DE00447 L     @09,@PC00001                                     02S0471
         L     @09,ALCWAPTR(,@09)                               02S0471
         L     @09,ALGTABP(,@09)                                02S0471
         L     @09,ALGPARMP(,@09)                               02S0471
         CH    AREQCTR,CVRNREQ(,@09)                            02S0471
         BNH   @DL00447                                         02S0471
@DC00447 DS    0H                                               02S0472
*    END;                                                       02S0472
*  ELSE;                               /*GROUP IS NOT NEEDED         */
@RF00420 DS    0H                                               02S0474
*END;                                                           02S0474
         LA    @04,1                                            02S0474
         AL    @04,GROUPNO                                      02S0474
@DE00418 ST    @04,GROUPNO                                      02S0474
         L     @15,@PC00001                                     02S0474
         L     @01,ALCWAPTR(,@15)                               02S0474
         L     @01,EDTABPTR(,@01)                               02S0474
         L     @01,EDTMSKTP(,@01)                               02S0474
         L     @15,GMTENTLN(,@01)                               02S0474
         SLA   @15,3                                            02S0474
         CR    @04,@15                                          02S0474
         BNH   @DL00418                                         02S0474
*VUPTR = VOLUNPTR;                     /*POINT TO FIRST VU ENTRY     */
         L     @04,@PC00001                                     02S0475
         L     @04,ALCWAPTR(,@04)                               02S0475
         MVC   VUPTR(4),VOLUNPTR(@04)                           02S0475
*DO VUCTR = ONE TO VOLUNSZE/LENGTH(VOLUNTAB); /*SCAN VU TABLE        */
         LA    VUCTR,1                                          02S0476
         B     @DE00476                                         02S0476
@DL00476 DS    0H                                               02S0477
*  IF (VOLALGTP ^= ZERO & VOLALGTP->CVRWUCBP ^= ZERO)           02S0477
*     VUDMNDOF = ON  VUDMNDAL = ON THEN                       02S0477
         L     @06,VUPTR                                        02S0477
         L     @06,VOLALGTP(,@06)                               02S0477
         LTR   @06,@06                                          02S0477
         BZ    @GL00040                                         02S0477
         ICM   @04,3,CVRWUCBP(@06)                              02S0477
         BNZ   @RT00477                                         02S0477
@GL00040 L     @06,VUPTR                                        02S0477
         TM    VUDMNDOF(@06),B'00110000'                        02S0477
         BZ    @RF00477                                         02S0477
@RT00477 DS    0H                                               02S0478
*    VUDNALOC = OFF;                   /*ALLOW REQ TO BE ALLOC'D     */
         L     @06,VUPTR                                        02S0478
         NI    VUDNALOC(@06),B'11110111'                        02S0478
*  ELSE;                                                        02S0479
@RF00477 DS    0H                                               02S0480
*  IF VOLSIOTP->SIOTDMND = ON                                   02S0480
*    & VOLALGTP ^= ZERO                                         02S0480
*    & VOLALGTP->CVRWUCBP ^= ZERO                               02S0480
*    & VUDMNDOF = OFF & VUDMNDAL = OFF THEN                     02S0480
         L     @06,VUPTR                                        02S0480
         L     @04,VOLSIOTP(,@06)                               02S0480
         TM    SIOTDMND(@04),B'10000000'                        02S0480
         BNO   @RF00480                                         02S0480
         L     @04,VOLALGTP(,@06)                               02S0480
         LTR   @04,@04                                          02S0480
         BZ    @RF00480                                         02S0480
         ICM   @15,3,CVRWUCBP(@04)                              02S0480
         BZ    @RF00480                                         02S0480
         TM    VUDMNDOF(@06),B'00110000'                        02S0480
         BNZ   @RF00480                                         02S0480
*    VURCVYPR=ON;                      /*MARK REQ PROCESSED          */
         OI    VURCVYPR(@06),B'00000001'                        02S0481
*  ELSE;                                                        02S0482
@RF00480 DS    0H                                               02S0483
*  VUPTR = VUPTR + LENGTH(VOLUNTAB);   /*POINT TO NEXT VU            */
         LA    @06,28                                           02S0483
         AL    @06,VUPTR                                        02S0483
         ST    @06,VUPTR                                        02S0483
*END;                                                           02S0484
         AH    VUCTR,@CH00079                                   02S0484
@DE00476 L     @06,@PC00001                                     02S0484
         L     @06,ALCWAPTR(,@06)                               02S0484
         L     @00,VOLUNSZE(,@06)                               02S0484
         SRDA  @00,32                                           02S0484
         D     @00,@CF01076                                     02S0484
         CR    VUCTR,@01                                        02S0484
         BNH   @DL00476                                         02S0484
*                        IF RTNCODE = SUCCESS THEN /*ANY ERRORS ?    */
         LTR   RTNCODE,RTNCODE                                  01S0485
         BNZ   @RF00485                                         01S0485
*                          DO;         /*NO, CONTINUE..              */
*                            CALL IEFAB487 (ALCWAPTR);/*RECOVERY OPR
*                                            EXCHANGE                */
         L     @04,@PC00001                                     01S0487
         ST    @04,@AL00001                                     01S0487
         L     @15,@CV00141                                     01S0487
         LA    @01,@AL00001                                     01S0487
         BALR  @14,@15                                          01S0487
*                            RTNCODE = REG15;/*SAVE THE RETURN CODE  */
         LR    RTNCODE,REG15                                    01S0488
*                          END;                                 01S0489
*                        ELSE;         /*ERROR                       */
@RF00485 DS    0H                                               01S0491
*                      END;                                     01S0491
*                    ELSE;             /*ALL REQS ALREADY ALLOC'D    */
@RF00408 DS    0H                                               01S0493
*                  END;                                         01S0493
*                ELSE;                 /*ERROR FROM IEFAB478         */
@RF00316 DS    0H                                               01S0495
*              END;                                             01S0495
*            ELSE;                     /*ERROR                       */
@RF00312 DS    0H                                               01S0497
*          END;                                                 01S0497
*        ELSE;                         /*ERROR UNALLOCATING          */
@RF00248 DS    0H                                               01S0499
*      END;                                                     01S0499
*    ELSE;                             /*REQS NOT COVERED BY 1 GEN   */
@RF00209 DS    0H                                               01S0501
*  END;                                                         01S0501
*ELSE                                  /*ALL REQS NOT COVERED BY ALG */
*  DO;                                                          01S0502
         B     @RC00087                                         01S0502
@RF00087 DS    0H                                               01S0503
*    IF RTNCODE = PARTALOC THEN        /*PARTIALLY COVERED ?         */
         CH    RTNCODE,@CH00055                                 01S0503
         BNE   @RF00503                                         01S0503
*        SAVNOCOV = NOCOVER;           /*YES, UNABLE-TO-ALOC @ZA01569*/
         MVC   SAVNOCOV(2),@CH00111                             01S0504
*    ELSE                              /*ERROR MUST BE GETMAIN       */
*        REASONCD = GETMNERR;          /*SET GETMAIN ERR REASON CODE */
         B     @RC00503                                         01S0505
@RF00503 L     @04,@PC00001                                     01S0505
         L     @04,ALCWAPTR(,@04)                               01S0505
         L     @04,FAILRSCP(,@04)                               01S0505
         MVC   REASONCD(2,@04),@CH00109                         01S0505
*  END;                                                         01S0506
@RC00503 DS    0H                                               01S0507
*IF SAVNOCOV = NOCOVER THEN            /*UNABLE TO ALLOCATE? @ZA01569*/
@RC00087 CLC   SAVNOCOV(2),@CH00111                             01S0507
         BNE   @RF00507                                         01S0507
*  DO;                                 /*YES -               @ZA01569*/
*    RFY VOLUNTAB BASED(CVRVUPTR);     /*ASSOCIATE VU ENTRY AND COVER
*                                        REQUEST LIST ENTRY  @ZA01569*/
*    RFY INDMSIOT BASED(VOLSIOTP);     /*ASSOCIATE VU ENTRY WITH
*                                        ITS SIOT            @ZA01569*/
*    AREQPTR = ALGRQLTP;               /*FIRST REQ LIST ENTRY@ZA01569*/
         L     @04,@PC00001                                     01S0511
         L     @04,ALCWAPTR(,@04)                               01S0511
         L     @04,ALGTABP(,@04)                                01S0511
         L     AREQPTR,ALGRQLTP(,@04)                           01S0511
*    RTNCODE = FAILURE;                /*INDICATE ERROR      @ZA01569*/
         LA    RTNCODE,4                                        01S0512
*    DO AREQCTR = ONE TO CVRNREQ;      /*SCAN ALL ENTRIES    @ZA01569*/
         LA    AREQCTR,1                                        01S0513
         B     @DE00513                                         01S0513
@DL00513 DS    0H                                               01S0514
*      IF VDEVREQD = ON &              /*REQ REQUIRES UNITS? @ZA01569*/
*         VOLALOC = OFF &              /*NOT ALLOCATED YET?  @ZA01569*/
*         CVRSKFLG = OFF &             /*ALG DID NOT SKIP?   @ZA01569*/
*         CVRNEED > ZERO THEN          /*ARE UNITS STILL REQUIRED
*                                        FOR THIS REQUEST?   @ZA01569*/
         L     @07,CVRVUPTR(,AREQPTR)                           01S0514
         TM    VDEVREQD(@07),B'00100000'                        01S0514
         BNO   @RF00514                                         01S0514
         TM    VOLALOC(@07),B'10000000'                         01S0514
         BNZ   @RF00514                                         01S0514
         TM    CVRSKFLG(AREQPTR),B'10000000'                    01S0514
         BNZ   @RF00514                                         01S0514
         ICM   @04,3,CVRNEED(AREQPTR)                           01S0514
         BNP   @RF00514                                         01S0514
*        DO;                           /*YES -               @ZA01569*/
*          SIOTRSNC = NOCOVER;         /*SET DD-RELATED CODE FOR
*                                        UNABLE TO ALLOCATE  @ZA01569*/
         L     @07,VOLSIOTP(,@07)                               01S0516
         MVC   SIOTRSNC(2,@07),@CH00111                         01S0516
*        END;                          /*                    @ZA01569*/
*      ELSE;                           /*                    @ZA01569*/
@RF00514 DS    0H                                               01S0519
*      AREQPTR = AREQPTR + LENGTH(CVRRQLST);/*PICK UP NEXT REQUEST
*                                        LIST ENTRY          @ZA01569*/
         AL    AREQPTR,@CF01076                                 01S0519
*    END;                              /*                    @ZA01569*/
         AH    AREQCTR,@CH00079                                 01S0520
@DE00513 L     @07,@PC00001                                     01S0520
         L     @07,ALCWAPTR(,@07)                               01S0520
         L     @07,ALGTABP(,@07)                                01S0520
         L     @07,ALGPARMP(,@07)                               01S0520
         CH    AREQCTR,CVRNREQ(,@07)                            01S0520
         BNH   @DL00513                                         01S0520
*    RFY VOLUNTAB BASED(VUPTR);        /*RESET BASE          @ZA01569*/
*    RFY INDMSIOT BASED(SIOTPTR);      /*RESET BASE          @ZA01569*/
*  END;                                /*                    @ZA01569*/
*RETURN CODE(RTNCODE);                 /*RETURN TO CALLER            */
@RF00507 L     @13,4(,@13)                                      01S0524
         L     @00,@SIZDATD                                     01S0524
         LR    @01,@10                                          01S0524
         FSPACE   R,LV=(0),A=(1)
         LR    @15,@05                                          01S0524
         L     @14,12(,@13)                                     01S0524
         LM    @00,@12,20(@13)                                  01S0524
         BR    @14                                              01S0524
*TURNBIT1: PROC;                                                02S0525
TURNBIT1 STM   @14,@12,12(@13)                                  02S0525
*/*******************************************************************/
*/*                                                                  */
*/* SEGMENT NAME - TURNBIT1                                          */
*/*                                                                  */
*/* DESCRIPTIVE NAME - TURN ON A BIT IN A GROUP MASK                 */
*/*                                                                  */
*/* FUNCTION -                                                       */
*/*     GIVEN A GROUP ID, THIS ROUTINE TURNS ON THE GROUP MASK       */
*/*     BIT ASSOCIATED WITH THAT GROUP ID.                           */
*/*                                                                  */
*/*   OPERATION - (THE OPERATION IS DOCUMENTED BY THE CODE ITSELF)   */
*/*                                                                  */
*/* ENTRY - TURNBIT1 (INTERNAL PROC)                                 */
*/*                                                                  */
*/*   PURPOSE - (SEE FUNCTION)                                       */
*/*                                                                  */
*/*   INPUT -                                                        */
*/*     THEGRPID - GROUP ID                                          */
*/*     MASKPTR - PTR TO THE GROUP MASK (GRPMSK)                     */
*/*                                                                  */
*/* EXIT - NORMAL - RETURN TO CALLER (INTERNAL PROC)                 */
*/*                                                                  */
*/*   CONDITIONS - BIT TURNED ON IN GROUP MASK                       */
*/*                                                                  */
*/*   OUTPUT -                                                       */
*/*      BIT TURNED ON IN GROUP MASK                                 */
*/*                                                                  */
*/*   RETURN CODES - (NONE)                                          */
*/*                                                                  */
*/* EXIT - ERROR - (NONE)                                            */
*/*                                                                  */
*/********************************************************************/
*GRMSKBYT = THEGRPID/LENGTH(GRPMSK);   /*CALCULATE BYTE IN GROUP MASK*/
         LA    @05,8                                            02S0526
         LR    @00,THEGRPID                                     02S0526
         SRDA  @00,32                                           02S0526
         DR    @00,@05                                          02S0526
         LR    GRMSKBYT,@01                                     02S0526
*GRMSKBIT = THEGRPID//LENGTH(GRPMSK);  /*CALCULATE BIT POSITION OF ID*/
         LR    @00,THEGRPID                                     02S0527
         SRDA  @00,32                                           02S0527
         D     @00,@CF00055                                     02S0527
         LR    GRMSKBIT,@00                                     02S0527
*IF GRMSKBIT = ZERO THEN               /*GROUP ID MULTIPLE OF 8  ?   */
         CH    GRMSKBIT,@CH00123                                02S0528
         BNE   @RF00528                                         02S0528
*  GRMSKBIT = LENGTH(GRPMSK);          /*YES, SET BIT POSITION = 8   */
         LR    GRMSKBIT,@05                                     02S0529
*ELSE                                  /*GROUP ID NOT MULTIPLE OF 8  */
*  GRMSKBYT = GRMSKBYT + ONE;          /*INCREMENT BYTE OF GROUP ID  */
         B     @RC00528                                         02S0530
@RF00528 LA    GRMSKBYT,1(,GRMSKBYT)                            02S0530
*GRPMSK(GRMSKBYT) =                    /*TURN ON BIT IN GROUP MASK   */
*    GRPMSK(GRMSKBYT)  MASKTAB(GRMSKBIT);                      02S0531
@RC00528 L     @05,MASKPTR                                      02S0531
         ALR   @05,GRMSKBYT                                     02S0531
         BCTR  @05,0                                            02S0531
         LA    @01,MASKTAB-1(GRMSKBIT)                          02S0531
         OC    GRPMSK(1,@05),0(@01)                             02S0531
*END TURNBIT1;                                                  02S0532
@EL00002 DS    0H                                               02S0532
@EF00002 DS    0H                                               02S0532
@ER00002 LM    @14,@12,12(@13)                                  02S0532
         BR    @14                                              02S0532
*TESTBIT: PROC;                                                 02S0533
TESTBIT  STM   @14,@12,@SA00003                                 02S0533
*/********************************************************************/
*/*                                                                  */
*/* SEGMENT NAME - TESTBIT                                           */
*/*                                                                  */
*/* DESCRIPTIVE NAME - TEST BIT IN GROUP MASK                        */
*/*                                                                  */
*/* FUNCTION -                                                       */
*/*      THIS SUBROUTINE DETERMINES IF A PARTICULAR BIT IN A         */
*/*      GROUP MASK IS ON OR OFF. THE GROUP MASK IS A VARIABLE       */
*/*      LENGTH BIT MASK POINTED TO BY MASKPTR . THE ONE-ORIGIN      */
*/*      INDEX OF THE BIT TO BE TESTED IS CONTAINED IN FIELD         */
*/*      GROUPNO.                                                    */
*/*                                                                  */
*/*   OPERATION -                                                    */
*/*      THIS SEGMENT GENERATES BAL INSTRUCTIONS                     */
*/*                                                                  */
*/*      ONE IS SUBTRACTED FROM THE GROUPNO TO PRODUCE A ZERO-ORIGIN */
*/*      INDEX. THE INDEX IS THEN DIVIDED BY EIGHT TO DETERMINE THE  */
*/*      BYTE (AND REMAINDER)  OF THE BIT BEING TESTED (IN A SRDL    */
*/*      INSTRUCTION, THE ODD REGISTER GETS THE BITS SHIFTED OUT OF  */
*/*      THE EVEN REGISTER). THE REMAINDER IS ALIGNED IN A REGISTER  */
*/*      AND IS USED TO INDICATE THE BIT POSITION IN THE BYTE. THIS  */
*/*      BIT POSITION IS USED IN A TEST-UNDER-MASK INSTRUCTION VIA   */
*/*      EXECUTE.                                                    */
*/*                                                                  */
*/*      EXAMPLE - IF GROUPNO = 10, THIS OPERATION WILL DETERMINE    */
*/*                THE BIT IS 1 BYTE AFTER THE BEGINNING OF THE      */
*/*                GROUP MASK AND IS THE SECOND BIT POSITION.        */
*/*                                                                  */
*/* ENTRY - THIS CODE IS AN INLINE SUBROUTINE WHICH IS ENTERED       */
*/*         AT THE TOP.                                              */
*/*                                                                  */
*/*   PURPOSE  -  TO DETERMINE IF A PARTICULAR BIT IN A GROUP        */
*/*               MASK IS ON OR OFF.                                 */
*/*                                                                  */
*/*   INPUT -                                                        */
*/*       MASKPTR - PTR TO GROUP MASK                                */
*/*       GROUPNO - 1-ORIGIN INDEX INTO MASK OF THE BIT TO BE TESTED */
*/*       BITRTN - BIT FOR RESULTS OF TEST TO BE RETURNED IN         */
*/*                                                                  */
*/* EXIT - NORMAL - THIS CODE IS AN INLINE SUBROUTINE WHICH          */
*/*                 EXITS FROM THE BOTTOM.                           */
*/*                                                                  */
*/*   CONDITION - BIT TESTED AND RESULTS INDICATED.                  */
*/*                                                                  */
*/*   OUTPUT -                                                       */
*/*       BITRTN - SET TO 1 IF BIT WAS ON                            */
*/*              - SET TO 0 IF BIT WAS OFF                           */
*/*                                                                  */
*/*   RETURN CODES - (NONE)                                          */
*/*                                                                  */
*/********************************************************************/
*BITRTN = OFFVALUE;                    /*ASSUME BIT IS OFF           */
         NI    BITRTN,B'01111111'                               02S0534
*RFY (EVENREG,ODDREG,MASKREG) RSTD;    /*RESTRICT USE OF REGS 3,4+5  */
*GEN REFS(EVENREG,GROUPNO,MASKPTR,ODDREG,MASKREG,TMINST)        02S0536
*    FLOWS(BITOFF);                                             02S0536
        L     EVENREG,GROUPNO         PUT BIT INDEX INTO REG
        BCTR  EVENREG,0               DECREMENT INDEX FOR ZERO ORIGIN
        SRDL  EVENREG,3               DIVIDE INDEX BY 8.SAVE REMAINDER
        A     EVENREG,MASKPTR         POINT TO CORRECT BYTE
        SRL   ODDREG,29               ALIGN REMAINDER IS REG
        LA    MASKREG,X'80'           INSERT 0-BIT MASK
        SRL   MASKREG,0(ODDREG)       POSITION MASK BIT
        EX    MASKREG,TMINST          TEST IF BIT IS ON
        BNO   BITOFF                  BRANCH IF BIT NOT ON
*RFY (EVENREG,ODDREG,MASKREG) UNRSTD;  /*UNRESTRICT REGS 3,4, AND 5  */
*BITRTN = ONVALUE;                     /*INDICATE BIT WAS ON         */
         OI    BITRTN,B'10000000'                               02S0538
*BITOFF:;                                                       02S0539
*RETURN;                                                        02S0540
@EL00003 DS    0H                                               02S0540
@EF00003 DS    0H                                               02S0540
@ER00003 LM    @14,@12,@SA00003                                 02S0540
         BR    @14                                              02S0540
*END TESTBIT;                                                   02S0541
         B     @EL00003                                         02S0541
*END IEFAB486                          /*END OF OFFLINE/ALCDS ALLOC  */
*/* THE FOLLOWING INCLUDE STATEMENTS WERE FOUND IN THIS PROGRAM.      *
*/*%INCLUDE SYSLIB  (A486SPEC)                                        *
*/*%INCLUDE SYSLIB  (A486DATA)                                        *
*/*%INCLUDE SYSLIB  (TBITDATA)                                        *
*/*%INCLUDE SYSLIB  (IEFZB421)                                        *
*/*%INCLUDE SYSLIB  (IEFZB422)                                        *
*/*%INCLUDE SYSLIB  (IEFZB423)                                        *
*/*%INCLUDE SYSLIB  (IEFZB425)                                        *
*/*%INCLUDE SYSLIB  (IEFZB426)                                        *
*/*%INCLUDE SYSLIB  (IEFZB427)                                        *
*/*%INCLUDE SYSLIB  (IEFZB428)                                        *
*/*%INCLUDE SYSLIB  (IEFZB431)                                        *
*/*%INCLUDE SYSLIB  (IEFASIOT)                                        *
*/*%INCLUDE SYSLIB  (IEFUCBOB)                                        *
*/*%INCLUDE SYSLIB  (ALGAPREP)                                        *
*/*%INCLUDE SYSLIB  (APRESPEC)                                        *
*/*%INCLUDE SYSLIB  (FORCMULT)                                        *
*/*%INCLUDE SYSLIB  (MULTSPEC)                                        *
*/*%INCLUDE SYSLIB  (TRYGENIC)                                        *
*/*%INCLUDE SYSLIB  (TRYGSPEC)                                        *
*/*%INCLUDE SYSLIB  (MARKINEL)                                        *
*/*%INCLUDE SYSLIB  (MARKSPEC)                                        *
*/*%INCLUDE SYSLIB  (REARANGE)                                        *
*/*%INCLUDE SYSLIB  (REARSPEC)                                        *
*/*%INCLUDE SYSLIB  (ENDVALID)                                        *
*/*%INCLUDE SYSLIB  (VENDSPEC)                                        *
*/*%INCLUDE SYSLIB  (FREGROUP)                                        *
*/*%INCLUDE SYSLIB  (FREGSPEC)                                        *
*/*%INCLUDE SYSLIB  (FINDGRP )                                        *
*/*%INCLUDE SYSLIB  (FGRPSPEC)                                        *
*/*%INCLUDE SYSLIB  (SETHANDL)                                        *
*/*%INCLUDE SYSLIB  (SHANSPEC)                                        *
*/*%INCLUDE SYSLIB  (DMNDNEED)                                        *
*/*%INCLUDE SYSLIB  (DNEDSPEC)                                        *
*/*%INCLUDE SYSLIB  (TURNBIT1)                                        *
*/*%INCLUDE SYSLIB  (TURNSPEC)                                        *
*/*%INCLUDE SYSLIB  (TESTBIT )                                        *
*/*%INCLUDE SYSLIB  (TBITSPEC)                                        *
*;                                                              01S0542
@DATA    DS    0H
@CH00123 DC    H'0'
@CH00079 DC    H'1'
@CH00109 DC    H'2'
@CH00075 DC    H'4'
@CH00111 DC    H'6'
@CH00033 DC    H'12'
@CH00061 DC    H'16'
@SX01098 XC    NEEDMASK(0),NEEDMASK
@SX01100 XC    KEEPMASK(0,@01),KEEPMASK(@01)
@SO01104 OC    NEEDMASK(0),VERIFYMK(@01)
@DATD    DSECT
         DS    0F
@SA00001 DS    18F
@PC00001 DS    1F
@SA00003 DS    15F
@AL00001 DS    5A
@TF00001 DS    F
IEFAB486 CSECT
         DS    0F
@CF00055 DC    F'8'
@CH00055 EQU   @CF00055+2
@CF01076 DC    F'28'
@CH01076 EQU   @CF01076+2
@DATD    DSECT
         DS    0D
MASKPTR  DS    A
SPTR     DS    A
VUPTR    DS    A
FNDGRPID DS    F
GENCTR   DS    F
GROUPNO  DS    F
EDTPTR   DS    A
LUVPTR   DS    A
GENPTR   DS    A
GRPTABP  DS    A
EDLGNTP  DS    A
EDLUCBLP DS    A
VMVREQBP DS    A
SAVNOCOV DS    H
NEEDMASK DS    CL240
SAVGENID DS    CL4
SWITCHES DS    BL1
         ORG   SWITCHES
BITRTN   DS    BL1
NEEDUNAL EQU   SWITCHES+0
GENFNDSW EQU   SWITCHES+0
GRPFOUND EQU   SWITCHES+0
NDEVALID EQU   SWITCHES+0
DOVALIDS EQU   SWITCHES+0
USEUCB   EQU   SWITCHES+0
UCBFOUND EQU   SWITCHES+0
         ORG   SWITCHES+1
IEFAB486 CSECT
         DS    0F
@SIZDATD DC    AL1(230)
         DC    AL3(@ENDDATD-@DATD)
@CV00134 DC    V(IEFAB4FA)
@CV00135 DC    V(IEFAB474)
@CV00136 DC    V(IEFAB477)
@CV00137 DC    V(IEFAB478)
@CV00138 DC    V(IEFAB480)
@CV00139 DC    V(IEFAB481)
@CV00140 DC    V(IEFAB441)
@CV00141 DC    V(IEFAB487)
         DS    0D
@CB00103 DC    B'00000000'
@CB00107 DC    B'00001000'
NOVOLSER DC    X'000000000000'
MASKTAB  DC    X'80'
         DC    X'40'
         DC    X'20'
         DC    X'10'
         DC    X'08'
         DC    X'04'
         DC    X'02'
         DC    X'01'
IEFAB486 CSECT
         DS   0H
PATCHLOC DC ((@DATA-@PSTART)/20)X'00'
IEFAB486 CSECT
TMINST  TM    0(EVENREG),0            TEST OF CORRECT BYTE. MASK=BIT
@DATD    DSECT
         ORG   *+1-(*-@DATD)/(*-@DATD) INSURE DSECT DATA
@ENDDATD EQU   *
IEFAB486 CSECT
@00      EQU   00                      EQUATES FOR REGISTERS 0-15
@01      EQU   01
@02      EQU   02
@03      EQU   03
@04      EQU   04
@05      EQU   05
@06      EQU   06
@07      EQU   07
@08      EQU   08
@09      EQU   09
@10      EQU   10
@11      EQU   11
@12      EQU   12
@13      EQU   13
@14      EQU   14
@15      EQU   15
VUCTR    EQU   @07
UCBCTR   EQU   @04
THEGRPID EQU   @03
SAVEAFID EQU   @08
RTNCODE  EQU   @05
MASKBYTE EQU   @02
GRPCTR   EQU   @09
GRMSKBYT EQU   @02
GRMSKBIT EQU   @04
ECOUNT   EQU   @02
AVAILCTR EQU   @07
AREQCTR  EQU   @06
AGRPCTR  EQU   @02
UCBPTR   EQU   @02
SIOTPTR  EQU   @06
GRPPTR   EQU   @03
GROUPPTR EQU   @08
EDLPTR   EQU   @03
AREQPTR  EQU   @03
AGRPPTR  EQU   @04
REG15    EQU   @15
EVENREG  EQU   @04
MASKREG  EQU   @03
ODDREG   EQU   @05
GRPMSK   EQU   0
IOSLUT   EQU   0
KEEPMASK EQU   0
REASONCD EQU   0
UNLKMASK EQU   0
VERIFYMK EQU   0
WAITMASK EQU   0
EDTHDR   EQU   0
EDTLUVSP EQU   EDTHDR
EDTGENSP EQU   EDTHDR+4
EDTGRPSP EQU   EDTHDR+8
EDTUCBSP EQU   EDTHDR+12
EDTMSKTP EQU   EDTHDR+16
LUVSECT  EQU   0
LUVHDR   EQU   LUVSECT
LUVENTRY EQU   0
LUVGMTP  EQU   LUVENTRY+12
LUVFLAGS EQU   LUVENTRY+24
GENSECT  EQU   0
GENHDR   EQU   GENSECT
GENENTRY EQU   0
GRPTRTAB EQU   0
GRPSECT  EQU   0
GRPHDR   EQU   GRPSECT
GRPENTNO EQU   GRPHDR
GRPENTLN EQU   GRPHDR+4
GRPENTRY EQU   0
GRPID    EQU   GRPENTRY
GRPUCBNO EQU   GRPENTRY+4
GRPUCBP  EQU   GRPENTRY+8
EUCBSECT EQU   0
EUCBHDR  EQU   EUCBSECT
EUCBENTY EQU   0
EUCBTPOS EQU   EUCBENTY
GRMSKTAB EQU   0
GMTHDR   EQU   GRMSKTAB
GMTENTLN EQU   GMTHDR+4
GMTENTRY EQU   0
IEFEDL   EQU   0
EDLHDR   EQU   IEFEDL
EDLGENNO EQU   EDLHDR+4
EDLFGENP EQU   EDLHDR+8
EDLUVFLG EQU   EDLHDR+16
EDLENTRY EQU   0
EDLNXTNT EQU   EDLENTRY
EDLDEVT  EQU   EDLENTRY+4
EDLGRPNO EQU   EDLENTRY+8
EDLGRPTR EQU   EDLENTRY+12
EDLDTFLG EQU   EDLENTRY+20
EINDEVTP EQU   EDLDTFLG
EDLGNTRY EQU   0
EDLLISTP EQU   EDLGNTRY+8
EDLGRID  EQU   EDLGNTRY+12
EDLGRFLG EQU   EDLGNTRY+16
EDLUCBL  EQU   0
EDLUCBAD EQU   EDLUCBL
EDLINDIC EQU   EDLUCBL+2
VOLUNTAB EQU   0
VOLSTAT  EQU   VOLUNTAB+6
VOLSTATA EQU   VOLSTAT
VOLSPEC  EQU   VOLSTATA
VOLSTATB EQU   VOLSTAT+1
VOLALOC  EQU   VOLSTATB
VDEVREQD EQU   VOLSTATB
VUDNALOC EQU   VOLSTATB
VOLSTATC EQU   VOLSTAT+2
VOLTAREQ EQU   VOLSTATC
VOLDAREQ EQU   VOLSTATC
VOLSTATD EQU   VOLSTAT+3
VUREALOC EQU   VOLSTATD
VUDMNDOF EQU   VOLSTATD
VUDMNDAL EQU   VOLSTATD
VURCVYPR EQU   VOLSTATD
VOLUNTID EQU   VOLUNTAB+10
VOLALGTP EQU   VOLUNTAB+12
VOLSIOTP EQU   VOLUNTAB+16
ALCWA    EQU   0
FMAPPTR  EQU   ALCWA+4
SIOT1P   EQU   ALCWA+8
IOSLUTP  EQU   ALCWA+16
FAILRSCP EQU   ALCWA+20
EDTABPTR EQU   ALCWA+24
CNTABLE  EQU   ALCWA+28
TOTREQS  EQU   CNTABLE+36
VOLUNPTR EQU   ALCWA+80
VOLUNSZE EQU   ALCWA+84
ALGTABP  EQU   ALCWA+88
QMGRRBP  EQU   ALCWA+108
INDICATE EQU   ALCWA+112
INDRETRY EQU   INDICATE
@NM00006 EQU   ALCWA+113
TIOTHDRP EQU   ALCWA+120
WMASKPTR EQU   ALCWA+128
WMASK2P  EQU   ALCWA+132
WORK3MP  EQU   ALCWA+136
EXITPRMP EQU   ALCWA+144
NAMES    EQU   0
ALGPTRS  EQU   0
ALGPARMP EQU   ALGPTRS
ALGRQLTP EQU   ALGPTRS+4
CVRPARM  EQU   0
CVRNREQ  EQU   CVRPARM+4
CVRFLG1  EQU   CVRPARM+8
CVRAVFLG EQU   CVRFLG1
CVRALFLG EQU   CVRFLG1
CVROFFLG EQU   CVRFLG1
CVRFCALL EQU   CVRFLG1
CVRRQLST EQU   0
CVRVUPTR EQU   CVRRQLST
CVRALLCT EQU   CVRRQLST+6
CVRNEED  EQU   CVRRQLST+8
CVRMIN   EQU   CVRRQLST+10
CVRFLG2  EQU   CVRRQLST+16
CVRSKFLG EQU   CVRFLG2
CVRIGNOR EQU   CVRFLG2
CVRWMOVE EQU   CVRFLG2
CVRDUPLI EQU   CVRFLG2+1
CVRNGRP  EQU   CVRRQLST+18
CVRGRPPT EQU   CVRRQLST+20
CVRWUCBP EQU   CVRRQLST+24
CVRGPLST EQU   0
CVRGCPTR EQU   CVRGPLST
CVRGRPID EQU   CVRGPLST+4
CVRGRPAL EQU   CVRGPLST+6
CVRGALL  EQU   CVRGPLST+8
CVRFLG3  EQU   CVRGPLST+12
CVRGSKP  EQU   CVRFLG3
CVRFORCI EQU   CVRFLG3
GRPCOUNT EQU   0
GRPEXCS  EQU   GRPCOUNT+8
AQMPARAM EQU   0
AQMECODE EQU   AQMPARAM
AQMMASKP EQU   AQMPARAM+4
AQMNORMP EQU   AQMPARAM+20
FUNCMAP  EQU   0
VOLMNTSW EQU   FUNCMAP
WRTMSGSW EQU   FUNCMAP
UWAITSW  EQU   FUNCMAP
VWAITSW  EQU   FUNCMAP
OFFDEVSW EQU   FUNCMAP
CCLMNTSW EQU   FUNCMAP
GENLOKSW EQU   FUNCMAP
HDRMSGSW EQU   FUNCMAP+1
MTRJOBSW EQU   FUNCMAP+1
NOTIOTNQ EQU   FUNCMAP+1
TRKMSW   EQU   FUNCMAP+1
WAITOKSW EQU   FUNCMAP+1
ASNMSW   EQU   FUNCMAP+1
VMVRQBLK EQU   0
VMVFNMAP EQU   VMVRQBLK
VMVOPTB1 EQU   VMVFNMAP
VMVOPTB2 EQU   VMVFNMAP+1
VMVOPTB3 EQU   VMVFNMAP+2
VMVMINFO EQU   VMVRQBLK+40
VMVACTON EQU   VMVMINFO
VMVUSER  EQU   VMVRQBLK+48
INDMSIOT EQU   0
SCTUSADD EQU   INDMSIOT+20
SIOTAFID EQU   INDMSIOT+26
SIOTBYT1 EQU   INDMSIOT+43
SIOTBYT3 EQU   INDMSIOT+46
SIOTTSTC EQU   INDMSIOT+47
SIOTBYT0 EQU   INDMSIOT+52
SCTSDISP EQU   INDMSIOT+55
SCTSBYT1 EQU   INDMSIOT+56
SCTSBYT2 EQU   INDMSIOT+57
SCTSBYT3 EQU   INDMSIOT+58
SCTSBYT4 EQU   INDMSIOT+59
SCTUTYPE EQU   INDMSIOT+60
SIOTDEVT EQU   SCTUTYPE
SIOUBYT3 EQU   SIOTDEVT+2
SIOUCBAD EQU   SCTUTYPE+5
SIOTALTD EQU   INDMSIOT+92
SIOTBYT2 EQU   INDMSIOT+103
SIOTDMND EQU   SIOTBYT2
SIOTRSNC EQU   INDMSIOT+130
SIOTEDLP EQU   INDMSIOT+136
SVOLUNAD EQU   INDMSIOT+140
SIOTNPTR EQU   INDMSIOT+152
SVOLUNNO EQU   INDMSIOT+168
UCB      EQU   0
UCBOB    EQU   0
UCBJBNR  EQU   UCBOB
UCBFL5   EQU   UCBOB+1
UCBAF    EQU   UCBFL5
UCBNALOC EQU   UCBFL5
UCBSTAT  EQU   UCBOB+3
UCBONLI  EQU   UCBSTAT
UCBRESV  EQU   UCBSTAT
UCBALOC  EQU   UCBSTAT
UCBPRES  EQU   UCBSTAT
UCBSYSR  EQU   UCBSTAT
UCBCHAN  EQU   UCBOB+4
UCBSFLS  EQU   UCBOB+6
UCBFLA   EQU   UCBSFLS
UCBFL1   EQU   UCBFLA
UCBBSY   EQU   UCBFL1
UCBNRY   EQU   UCBFL1
UCBPST   EQU   UCBFL1
UCBCUB   EQU   UCBFL1
UCBFLB   EQU   UCBSFLS+1
UCBCHM   EQU   UCBOB+8
UCBCHM1  EQU   UCBCHM
UCBPTH0  EQU   UCBCHM1
UCBPTH1  EQU   UCBCHM1
UCBWGT   EQU   UCBOB+12
UCBTYP   EQU   UCBOB+16
UCBTBYT1 EQU   UCBTYP
UCB1FEA5 EQU   UCBTBYT1
UCB1FEA6 EQU   UCBTBYT1
UCBTBYT2 EQU   UCBTYP+1
UCB2OPT2 EQU   UCBTBYT2
UCBDUDN1 EQU   UCB2OPT2
UCB2OPT3 EQU   UCBTBYT2
UCBDUDN2 EQU   UCB2OPT3
UCB2OPT4 EQU   UCBTBYT2
UCBRWTAU EQU   UCB2OPT4
UCB2OPT6 EQU   UCBTBYT2
UCB2OPT7 EQU   UCBTBYT2
UCBTBYT3 EQU   UCBTYP+2
UCBDVCLS EQU   UCBTBYT3
UCB3TAPE EQU   UCBDVCLS
UCB3DACC EQU   UCBDVCLS
UCBTBYT4 EQU   UCBTYP+3
UCBEXTPT EQU   UCBOB+20
UCBFLC   EQU   UCBEXTPT
UCBDEV   EQU   UCBOB+24
UCBCMEXT EQU   0
UCBATI   EQU   UCBCMEXT+3
@NM00040 EQU   UCBATI
UCBFLP1  EQU   UCBCMEXT+5
UCBMT    EQU   0
UCBOCR   EQU   0
UCB3540X EQU   0
UCBDKBYT EQU   UCB3540X+6
UCB3800X EQU   0
UCBOPTNS EQU   UCB3800X
UCBACTIV EQU   UCB3800X+3
UCBMDRBF EQU   UCB3800X+36
UCBUCS   EQU   0
UCBUCSOP EQU   UCBUCS+4
UCBFCBOP EQU   UCBUCS+5
UCBBGN   EQU   0
ALCWAPTR EQU   0
UCBOBS01 EQU   UCBDEV
UCBVOLI  EQU   UCBOBS01+4
UCBSTAB  EQU   UCBOBS01+10
UCBBSVL  EQU   UCBSTAB
UCBPRSRS EQU   UCBSTAB
UCBDMCT  EQU   UCBOBS01+11
UCBMOUNT EQU   UCBDMCT
UCBFL4   EQU   UCBOBS01+13
UCBOBS02 EQU   UCBDEV
UCBTFL1  EQU   UCBOBS02+19
UCBXTN   EQU   UCBOBS02+20
UCBVOPT  EQU   UCBXTN
UCBOBS03 EQU   UCBDEV
UCBXTADR EQU   UCBOBS03
UCBOBS04 EQU   UCBDEV
UCBBTA   EQU   UCBOBS04+12
UCBOBS06 EQU   UCBDEV
UCBAOF   EQU   UCBOBS06
UCBAOF1  EQU   UCBAOF
UCBAOF2  EQU   UCBAOF+1
@NM00039 EQU   UCBOBS06+3
UCBIRB   EQU   UCBOBS06+4
UCBGRAF  EQU   UCBIRB
UCBLDNCA EQU   UCBOBS06+8
UCBRDYQ  EQU   UCBLDNCA
UCBIRLN  EQU   UCBRDYQ
UCBLDNCB EQU   UCBRDYQ+1
UCBCTLNK EQU   UCBOBS06+12
UCBOBS07 EQU   UCBDEV
UCBOBS08 EQU   UCBDEV
UCBCTCAD EQU   UCBOBS08
UCBCTCF1 EQU   UCBOBS08+4
UCBOBS09 EQU   UCBDEV
         AGO   .@UNREFD                START UNREFERENCED COMPONENTS
UCBRV066 EQU   UCBOBS09+4
UCBIOSBA EQU   UCBOBS09
UCBRV042 EQU   UCBOBS08+5
UCBRV082 EQU   UCBCTCF1
UCBRV081 EQU   UCBCTCF1
UCBRV080 EQU   UCBCTCF1
UCBRV079 EQU   UCBCTCF1
UCBRV078 EQU   UCBCTCF1
UCBRV077 EQU   UCBCTCF1
UCBRV076 EQU   UCBCTCF1
UCBCTC80 EQU   UCBCTCF1
UCBCTCAL EQU   UCBCTCAD
UCBICNCB EQU   UCBOBS07+4
UCBRV040 EQU   UCBOBS07
UCBCTLNA EQU   UCBCTLNK+1
UCBRLN   EQU   UCBCTLNK
UCBRDYQA EQU   UCBLDNCB
UCBINRLN EQU   UCBIRLN
UCBIRBA  EQU   UCBIRB+1
UCBRV039 EQU   UCBGRAF
UCBDWNR  EQU   UCBGRAF
UCBRPND  EQU   UCBGRAF
UCBUPM   EQU   UCBGRAF
UCBBTAM  EQU   UCBGRAF
UCBDRNO  EQU   UCBGRAF
UCBDRO   EQU   UCBGRAF
UCBOIP   EQU   UCBGRAF
UCBATRCD EQU   @NM00039
UCBSKPFG EQU   @NM00039
UCBRIPND EQU   @NM00039
UCBRTIAC EQU   @NM00039
UCBRSV79 EQU   @NM00039
UCBRSV78 EQU   @NM00039
UCBRSV77 EQU   @NM00039
UCBOLTEP EQU   @NM00039
UCBATNCT EQU   UCBOBS06+2
UCBRSV76 EQU   UCBAOF2
UCBRSV75 EQU   UCBAOF2
UCBRSV74 EQU   UCBAOF2
UCBRSV73 EQU   UCBAOF2
UCBRSV72 EQU   UCBAOF2
UCBRSV71 EQU   UCBAOF2
UCBRSV70 EQU   UCBAOF2
UCBRSV69 EQU   UCBAOF2
UCBRSV68 EQU   UCBAOF1
UCBRSV67 EQU   UCBAOF1
UCBRSV66 EQU   UCBAOF1
UCBRSV65 EQU   UCBAOF1
UCBRSV64 EQU   UCBAOF1
UCBOFNL  EQU   UCBAOF1
UCBOFSP  EQU   UCBAOF1
UCBOFMCR EQU   UCBAOF1
UCBBTB   EQU   UCBBTA+1
UCBDI    EQU   UCBBTA
UCBSNS   EQU   UCBOBS04+8
UCBTEB   EQU   UCBOBS04+4
UCBGCB   EQU   UCBOBS04+3
UCBOPEN  EQU   UCBOBS04+2
UCBSTART EQU   UCBOBS04
UCBXTNB  EQU   UCBXTN+1
UCBRSV22 EQU   UCBVOPT
UCBRSV21 EQU   UCBVOPT
UCBRSV20 EQU   UCBVOPT
UCBESVE  EQU   UCBVOPT
UCBERPC  EQU   UCBVOPT
UCBESVC  EQU   UCBVOPT
UCBEVA   EQU   UCBVOPT
UCBESV   EQU   UCBVOPT
UCBRV009 EQU   UCBTFL1
UCBRV008 EQU   UCBTFL1
UCBRV007 EQU   UCBTFL1
UCBRV006 EQU   UCBTFL1
UCBRV005 EQU   UCBTFL1
UCBRV038 EQU   UCBTFL1
UCBNSLTP EQU   UCBTFL1
UCBNLTP  EQU   UCBTFL1
UCBRES1B EQU   UCBOBS02+18
UCBFSER  EQU   UCBOBS02+12
@NM00038 EQU   UCBOBS02+4
UCBFSEQ  EQU   UCBOBS02+2
UCBFSCT  EQU   UCBOBS02
UCBNEXP  EQU   UCBOBS01+20
UCBBASE  EQU   UCBOBS01+16
UCBRES1A EQU   UCBOBS01+15
UCBUSER  EQU   UCBOBS01+14
UCBFL47  EQU   UCBFL4
UCBFL46  EQU   UCBFL4
UCBFL45  EQU   UCBFL4
UCBRV065 EQU   UCBFL4
UCBDSS   EQU   UCBFL4
UCBRESVP EQU   UCBFL4
UCBWDAV  EQU   UCBFL4
UCBDAVV  EQU   UCBFL4
UCBSQC   EQU   UCBOBS01+12
UCBDATP  EQU   UCBOBS01+12
UCBDMC   EQU   UCBDMCT
UCBBNUL  EQU   UCBSTAB
UCBSHAR  EQU   UCBSTAB
UCBBSTR  EQU   UCBSTAB
UCBBPUB  EQU   UCBSTAB
UCBBPRV  EQU   UCBSTAB
UCBBALB  EQU   UCBPRSRS
UCBPGFL  EQU   UCBSTAB
UCBDVSHR EQU   UCBBSVL
UCBVTOC  EQU   UCBOBS01
UCBERADR EQU   UCBUCS+12
UCBFCBID EQU   UCBUCS+8
UCBERCNT EQU   UCBUCS+7
UCBRSV51 EQU   UCBUCS+6
UCBRSV50 EQU   UCBFCBOP
UCBRSV49 EQU   UCBFCBOP
UCBRSV48 EQU   UCBFCBOP
UCBRSV47 EQU   UCBFCBOP
UCBRSV46 EQU   UCBFCBOP
UCBRSV45 EQU   UCBFCBOP
UCBRSV44 EQU   UCBFCBOP
UCBFCBO1 EQU   UCBFCBOP
UCBUCSPE EQU   UCBUCSOP
UCBRSV43 EQU   UCBUCSOP
UCBRSV42 EQU   UCBUCSOP
UCBRSV41 EQU   UCBUCSOP
UCBRSV40 EQU   UCBUCSOP
UCBRSV39 EQU   UCBUCSOP
UCBUCSO2 EQU   UCBUCSOP
UCBUCSO1 EQU   UCBUCSOP
UCBUCSID EQU   UCBUCS
UCBMDRBA EQU   UCBMDRBF+1
UCBRV075 EQU   UCBMDRBF
UCBRV074 EQU   UCB3800X+32
UCBIMAGE EQU   UCB3800X+28
UCBFCBNM EQU   UCB3800X+24
UCBCHAR4 EQU   UCB3800X+20
UCBCHAR3 EQU   UCB3800X+16
UCBCHAR2 EQU   UCB3800X+12
UCBCHAR1 EQU   UCB3800X+8
UCBCGMID EQU   UCB3800X+4
UCBBRSTA EQU   UCBACTIV
UCBRV063 EQU   UCBACTIV
UCBRV062 EQU   UCBACTIV
UCBRV061 EQU   UCBACTIV
UCBRV060 EQU   UCBACTIV
UCBRV059 EQU   UCBACTIV
UCBRV058 EQU   UCBACTIV
UCBRV057 EQU   UCBACTIV
UCBRV050 EQU   UCB3800X+2
UCBCGMNO EQU   UCB3800X+1
UCBRV083 EQU   UCBOPTNS
UCBBRSTR EQU   UCBOPTNS
UCBRV056 EQU   UCBOPTNS
UCBRV055 EQU   UCBOPTNS
UCBRV054 EQU   UCBOPTNS
UCBRV053 EQU   UCBOPTNS
UCBRV052 EQU   UCBOPTNS
UCBRV051 EQU   UCBOPTNS
UCBRV073 EQU   UCB3540X+7
UCBRV072 EQU   UCBDKBYT
UCBRV071 EQU   UCBDKBYT
UCBRV070 EQU   UCBDKBYT
UCBRV069 EQU   UCBDKBYT
UCBRV068 EQU   UCBDKBYT
UCBRV067 EQU   UCBDKBYT
UCBVLVER EQU   UCBDKBYT
UCBDKAMX EQU   UCBDKBYT
UCBVLSER EQU   UCB3540X
UCBRDATA EQU   UCBOCR+4
UCBFRID  EQU   UCBOCR
UCBCLN   EQU   UCBMT+14
UCBERG   EQU   UCBMT+12
UCBMS    EQU   UCBMT+11
UCBNB    EQU   UCBMT+10
UCBPW    EQU   UCBMT+9
UCBPR    EQU   UCBMT+8
UCBSIO   EQU   UCBMT+6
UCBTW    EQU   UCBMT+5
UCBTR    EQU   UCBMT+4
UCBTWT   EQU   UCBMT+3
UCBTRT   EQU   UCBMT+2
UCBCTD   EQU   UCBMT
UCBWTOID EQU   UCBCMEXT+17
UCBRV043 EQU   UCBCMEXT+16
UCBASID  EQU   UCBCMEXT+14
UCBMFCNT EQU   UCBCMEXT+12
UCBPMSK  EQU   UCBCMEXT+10
UCBCCWOF EQU   UCBCMEXT+8
UCBRV041 EQU   UCBCMEXT+6
UCBRV036 EQU   UCBFLP1
UCBRV035 EQU   UCBFLP1
UCBERLOG EQU   UCBFLP1
UCBRV033 EQU   UCBFLP1
UCBRV032 EQU   UCBFLP1
UCBRV031 EQU   UCBFLP1
UCBSHRUP EQU   UCBFLP1
UCBNSRCH EQU   UCBFLP1
UCBSNSCT EQU   UCBCMEXT+4
UCBHPDV  EQU   @NM00040
UCBHALI  EQU   @NM00040
UCBRSV09 EQU   @NM00040
UCBRSV08 EQU   @NM00040
UCBRSV07 EQU   @NM00040
UCBRSV06 EQU   @NM00040
UCBRSV05 EQU   @NM00040
UCBRSV04 EQU   @NM00040
UCBDTI   EQU   UCBCMEXT+2
UCBSTI   EQU   UCBCMEXT+1
UCBETI   EQU   UCBCMEXT
UCBEXTP  EQU   UCBEXTPT+1
UCBDDRSW EQU   UCBFLC
UCBTICBT EQU   UCBFLC
UCBIVRR  EQU   UCBFLC
UCBIVRS  EQU   UCBFLC
UCBITF   EQU   UCBFLC
UCBUDE   EQU   UCBFLC
UCBWAA   EQU   UCBFLC
UCBATTP  EQU   UCBFLC
UCBUNTYP EQU   UCBTBYT4
UCBRSV11 EQU   UCBDVCLS
UCBRSV10 EQU   UCBDVCLS
UCB3CHAR EQU   UCBDVCLS
UCB3UREC EQU   UCBDVCLS
UCB3DISP EQU   UCBDVCLS
UCB3COMM EQU   UCBDVCLS
UCBDVPWR EQU   UCB2OPT7
UCBVLPWR EQU   UCB2OPT6
UCB2OPT5 EQU   UCBTBYT2
UCBRVDEV EQU   UCBRWTAU
UCBRPS   EQU   UCBDUDN2
UCBRR    EQU   UCBDUDN1
UCB2OPT1 EQU   UCBTBYT2
UCB2OPT0 EQU   UCBTBYT2
UCB1FEA7 EQU   UCBTBYT1
UCBD6250 EQU   UCB1FEA6
UCBD1600 EQU   UCB1FEA5
UCB1FEA4 EQU   UCBTBYT1
UCB1FEA3 EQU   UCBTBYT1
UCB1FEA2 EQU   UCBTBYT1
UCB1FEA1 EQU   UCBTBYT1
UCB1FEA0 EQU   UCBTBYT1
UCBNAME  EQU   UCBOB+13
UCBRV029 EQU   UCBWGT
UCBVHRSN EQU   UCBWGT
UCBVORSN EQU   UCBWGT
UCBMTPXP EQU   UCBWGT
UCBREW   EQU   UCBWGT
UCBPUB   EQU   UCBWGT
UCBOUT   EQU   UCBWGT
UCBIN    EQU   UCBWGT
UCBCPU   EQU   UCBOB+11
UCBLCI   EQU   UCBOB+10
UCBCNT   EQU   UCBOB+9
UCBRV017 EQU   UCBCHM1
UCBRV016 EQU   UCBCHM1
UCBRV015 EQU   UCBCHM1
UCBRV014 EQU   UCBCHM1
UCBSPB   EQU   UCBPTH1
UCBPPB   EQU   UCBPTH1
UCBSPA   EQU   UCBPTH0
UCBPPA   EQU   UCBPTH0
UCBSIGP  EQU   UCBFLB
UCBVALPH EQU   UCBFLB
UCBCRHSN EQU   UCBFLB
UCBCRHRV EQU   UCBFLB
UCBRESVH EQU   UCBFLB
UCBSPST  EQU   UCBFLB
UCBASNS  EQU   UCBFLB
UCBIORST EQU   UCBFLB
UCBQISCE EQU   UCBFL1
UCBACTV  EQU   UCBFL1
UCBSAP   EQU   UCBFL1
UCBNOTRC EQU   UCBCUB
UCBPSNS  EQU   UCBFL1
UCBUSING EQU   UCBPST
UCBNOTRD EQU   UCBNRY
UCBBUSYD EQU   UCBBSY
UCBUA    EQU   UCBCHAN+1
UCBCHA   EQU   UCBCHAN
UCBDADI  EQU   UCBSTAT
UCBUNLD  EQU   UCBSTAT
UCBCHGS  EQU   UCBSTAT
UCBID    EQU   UCBOB+2
UCBALTPH EQU   UCBFL5
UCBALTCU EQU   UCBFL5
UCBENVRD EQU   UCBFL5
UCBVSDR  EQU   UCBFL5
UCBSASK  EQU   UCBFL5
UCBAMV   EQU   UCBAF
UCBDCC   EQU   UCBFL5
UCBMONT  EQU   UCBJBNR
UCBRV011 EQU   UCBJBNR
UCBMMSGP EQU   UCBJBNR
UCBOLDSM EQU   UCBJBNR
UCBRV003 EQU   UCBJBNR
UCBDUC   EQU   UCBJBNR
UCBJES3  EQU   UCBJBNR
UCBVRDEV EQU   UCBJBNR
UCBCMSEG EQU   UCBOB
UCBPFXND EQU   UCB+512
UCBIOQ   EQU   UCB+508
UCBLOCK  EQU   UCB+504
UCBPXST  EQU   UCB+504
@NM00037 EQU   UCB
SIODDSNL EQU   INDMSIOT+173
SIOVDSNL EQU   INDMSIOT+172
SIOVDSNT EQU   INDMSIOT+170
SIOTVMVP EQU   INDMSIOT+164
SIOTJFX  EQU   INDMSIOT+160
SJFCBPTR EQU   INDMSIOT+156
SIOTETIO EQU   INDMSIOT+148
SIOTATE  EQU   INDMSIOT+144
SIOTEDLS EQU   INDMSIOT+132
SCTANAME EQU   INDMSIOT+122
@NM00036 EQU   INDMSIOT+108
SIOTSSNM EQU   INDMSIOT+104
@NM00035 EQU   SIOTBYT2
@NM00034 EQU   SIOTBYT2
SIOTCVOL EQU   SIOTBYT2
SIOTCNEW EQU   SIOTBYT2
SIOTCALC EQU   SIOTBYT2
SIOTGALL EQU   SIOTBYT2
SIOTDSPD EQU   SIOTBYT2
SIOTOPUC EQU   INDMSIOT+99
SIOTOUTR EQU   INDMSIOT+97
SIOTOUTC EQU   INDMSIOT+96
@NM00033 EQU   INDMSIOT+93
SIOTAUNC EQU   SIOTALTD
SIOTACAT EQU   SIOTALTD
SIOTADEL EQU   SIOTALTD
SIOTAKEP EQU   SIOTALTD
SIOTNPRV EQU   SIOTALTD
SIOJCATS EQU   SIOTALTD
@NM00032 EQU   SIOTALTD
@NM00031 EQU   SIOTALTD
@NM00030 EQU   INDMSIOT+91
SIOTNDSB EQU   INDMSIOT+88
@NM00029 EQU   INDMSIOT+84
SIOTDPCD EQU   INDMSIOT+82
@NM00028 EQU   INDMSIOT+81
SCTOUTPN EQU   INDMSIOT+80
SCTOUTNO EQU   INDMSIOT+76
SCTOUTNM EQU   INDMSIOT+68
SIOUCNVT EQU   SCTUTYPE+4
SIOUBYT4 EQU   SIOTDEVT+3
@NM00027 EQU   SIOUBYT3
SIO3UREC EQU   SIOUBYT3
SIO3DISP EQU   SIOUBYT3
SIO3DACC EQU   SIOUBYT3
SIO3COMM EQU   SIOUBYT3
SIO3TAPE EQU   SIOUBYT3
SIOUBYT2 EQU   SIOTDEVT+1
SIOUBYT1 EQU   SIOTDEVT
SIOTOMN  EQU   SCTSBYT4
SIOTIPDI EQU   SCTSBYT4
SIOTVAFF EQU   SCTSBYT4
SIOTSTEP EQU   SCTSBYT4
SIOTASCI EQU   SCTSBYT4
SIOTAFF  EQU   SCTSBYT4
SIOTGDGA EQU   SCTSBYT4
SCTSGDGS EQU   SCTSBYT4
SCTSOLD  EQU   SCTSBYT3
SCTSMOD  EQU   SCTSBYT3
SCTSNEW  EQU   SCTSBYT3
SCTSYSOU EQU   SCTSBYT3
SCTVREF  EQU   SCTSBYT3
SCTALCHK EQU   SCTSBYT3
SCTSYSNE EQU   SCTSBYT3
SCTDSNRF EQU   SCTSBYT3
SCTRECVD EQU   SCTSBYT2
SCTDEFER EQU   SCTSBYT2
SCTLABEL EQU   SCTSBYT2
SCTUNLBD EQU   SCTSBYT2
SCTJOBLB EQU   SCTSBYT2
SCTVOLAF EQU   SCTSBYT2
SIOTCATL EQU   SCTSBYT2
SIOCLUNL EQU   SCTSBYT2
SIOTJSCT EQU   SCTSBYT1
SCTUNAFF EQU   SCTSBYT1
SCTPARLM EQU   SCTSBYT1
SIOTQDSN EQU   SCTSBYT1
SIOTGDSN EQU   SCTSBYT1
SIOTCCAT EQU   SCTSBYT1
SCTSYSIN EQU   SCTSBYT1
SCTDUMMY EQU   SCTSBYT1
SIOTUNCT EQU   SCTSDISP
SIOTCTLG EQU   SCTSDISP
SIOTDLET EQU   SCTSDISP
SIOTKEEP EQU   SCTSDISP
SIOTPASS EQU   SCTSDISP
SIOTPRIV EQU   SCTSDISP
S3400DSP EQU   SCTSDISP
SIOTRETN EQU   SCTSDISP
SIOTVLCT EQU   INDMSIOT+54
SCTNMBUT EQU   INDMSIOT+53
SIOTRTRY EQU   SIOTBYT0
SIOTPUPV EQU   SIOTBYT0
SIOTNOPV EQU   SIOTBYT0
SIOTGIGN EQU   SIOTBYT0
SPVTAMSG EQU   SIOTBYT0
SIOTFUDA EQU   SIOTBYT0
SIOTDYAL EQU   SIOTBYT0
SIOTSSDS EQU   SIOTBYT0
SIOTGIID EQU   INDMSIOT+50
SCTVOLCT EQU   INDMSIOT+49
SCTSPOOL EQU   INDMSIOT+48
SIOTQNAM EQU   SIOTTSTC
SIOTDSNM EQU   SIOTTSTC
SIOTTRKM EQU   SIOTTSTC
@NM00026 EQU   SIOTTSTC
SIOTTERM EQU   SIOTTSTC
@NM00025 EQU   SIOTTSTC
@NM00024 EQU   SIOTBYT3
S3400OFF EQU   SIOTBYT3
SIOTJES3 EQU   SIOTBYT3
SIOCDEVT EQU   SIOTBYT3
SIOALIAS EQU   SIOTBYT3
SCTDDINO EQU   INDMSIOT+44
SIOTDDNT EQU   SIOTBYT1
SIOTALCD EQU   SIOTBYT1
SIODADSM EQU   SIOTBYT1
SIOTDADR EQU   SIOTBYT1
SIODUNAL EQU   SIOTBYT1
SIOVAMDS EQU   SIOTBYT1
SIOTHOLD EQU   SIOTBYT1
SIOTOCKP EQU   SIOTBYT1
SIOPSCNT EQU   INDMSIOT+42
SIOTREFN EQU   INDMSIOT+40
SIOTOTUN EQU   INDMSIOT+39
SIOTVRSB EQU   INDMSIOT+36
@NM00023 EQU   INDMSIOT+35
SCTPJFCB EQU   INDMSIOT+32
@NM00022 EQU   INDMSIOT+31
SCTPSIOT EQU   INDMSIOT+28
@NM00021 EQU   INDMSIOT+24
SIODSNTE EQU   INDMSIOT+22
SIOTUNAF EQU   SCTUSADD
SIOTDEST EQU   INDMSIOT+12
SCTDDNAM EQU   INDMSIOT+4
SIOTTYPE EQU   INDMSIOT+3
SIOTDSKA EQU   INDMSIOT
@NM00020 EQU   VMVUSER
VMVPROCD EQU   VMVUSER
VMVVUNTP EQU   VMVRQBLK+44
@NM00019 EQU   VMVMINFO+1
@NM00018 EQU   VMVACTON
VMVRTAIN EQU   VMVACTON
VMVDSMT  EQU   VMVACTON
VMVKEEP  EQU   VMVACTON
VMVRETCD EQU   VMVRQBLK+36
VMVJSNMP EQU   VMVRQBLK+32
VMVDSNMP EQU   VMVRQBLK+28
VMVJBNMP EQU   VMVRQBLK+24
VMVMVLSR EQU   VMVRQBLK+18
VMVUVLSR EQU   VMVRQBLK+12
VMVUCBP  EQU   VMVRQBLK+9
@NM00017 EQU   VMVRQBLK+8
VMVNREQP EQU   VMVRQBLK+4
VMVOPTB4 EQU   VMVFNMAP+3
@NM00016 EQU   VMVOPTB3
VMVNUMSG EQU   VMVOPTB3
VMVCUVOL EQU   VMVOPTB3
VMVDUPVL EQU   VMVOPTB3
VMVNSPVT EQU   VMVOPTB2
VMVNSLTP EQU   VMVOPTB2
VMVSLTAP EQU   VMVOPTB2
VMVNLTAP EQU   VMVOPTB2
VMVALTAP EQU   VMVOPTB2
VMVSTRG  EQU   VMVOPTB2
VMVPUBLC EQU   VMVOPTB2
VMVPRIVT EQU   VMVOPTB2
VMVVDEND EQU   VMVOPTB1
VMVVRLBL EQU   VMVOPTB1
VMVDWTOR EQU   VMVOPTB1
VMVMTMSG EQU   VMVOPTB1
VMVMOUNT EQU   VMVOPTB1
VMVREWND EQU   VMVOPTB1
VMVUCB   EQU   VMVOPTB1
VMVUNLOD EQU   VMVOPTB1
EXTRACAL EQU   FUNCMAP+1
ALCASDSN EQU   ASNMSW
ALCSUBWT EQU   WAITOKSW
ALCATRKM EQU   TRKMSW
ALCNOENQ EQU   NOTIOTNQ
ALCJOBNM EQU   MTRJOBSW
ALCHDMSG EQU   HDRMSGSW
@NM00015 EQU   FUNCMAP+1
ALCGENER EQU   GENLOKSW
ALCCANCL EQU   CCLMNTSW
ALCOFFDV EQU   OFFDEVSW
@NM00014 EQU   FUNCMAP
ALCWTVOL EQU   VWAITSW
ALCWTUNT EQU   UWAITSW
ALCMSGLV EQU   WRTMSGSW
ALCMOUNT EQU   VOLMNTSW
AQMQBPTR EQU   AQMPARAM+24
AQMPFLG  EQU   AQMNORMP
AQMCANCP EQU   AQMPARAM+16
AQMLENGT EQU   AQMPARAM+12
AQMASID  EQU   AQMPARAM+8
AQMQCODE EQU   AQMPARAM+2
GRPWPTR  EQU   GRPCOUNT+12
GRPIDENT EQU   GRPCOUNT+10
GRPTOTAL EQU   GRPCOUNT+6
GRPOFFLN EQU   GRPCOUNT+4
GRPALLCT EQU   GRPCOUNT+2
GRPAVAIL EQU   GRPCOUNT
@NM00013 EQU   CVRGPLST+13
@NM00012 EQU   CVRFLG3
CVRBOUND EQU   CVRGPLST+10
@NM00011 EQU   CVRRQLST+26
@NM00010 EQU   CVRFLG2+1
CVRMULTI EQU   CVRFLG2
CVRSCRTH EQU   CVRFLG2
CVRFULL  EQU   CVRFLG2
CVRREACH EQU   CVRFLG2
CVRRUSED EQU   CVRFLG2
CVRGNEXT EQU   CVRRQLST+12
CVRPTS   EQU   CVRMIN
CVRREQ1  EQU   CVRRQLST+4
@NM00009 EQU   CVRPARM+9
@NM00008 EQU   CVRFLG1
CVRGRPLK EQU   CVRPARM+6
CVRRQPTR EQU   CVRPARM
ALGGCNTP EQU   ALGPTRS+12
ALGGLSTP EQU   ALGPTRS+8
ALCPROCN EQU   NAMES+16
ALCSTEPN EQU   NAMES+8
ALCJOBN  EQU   NAMES
CANCELP  EQU   ALCWA+140
LGENLOCK EQU   ALCWA+124
TCBP     EQU   ALCWA+116
ALCWASID EQU   ALCWA+114
@NM00007 EQU   @NM00006
NODEVERR EQU   @NM00006
NEEDRCVY EQU   @NM00006
ALCWAREC EQU   @NM00006
WAITIGEN EQU   @NM00006
UNITRECS EQU   @NM00006
ALCWADUL EQU   INDICATE
ALCWISAM EQU   INDICATE
DSSUNIT  EQU   INDICATE
DSSTAPE  EQU   INDICATE
PRIVASUM EQU   INDICATE
INDREQU  EQU   INDICATE
INDWAIT  EQU   INDICATE
RIMTABCT EQU   ALCWA+104
RIMTABLN EQU   ALCWA+100
RIMTABP  EQU   ALCWA+96
ALGTABSZ EQU   ALCWA+92
@NM00005 EQU   ALCWA+78
LTUNITID EQU   ALCWA+76
TOTVOLUN EQU   CNTABLE+44
NUMREQS  EQU   CNTABLE+40
OTHEREQS EQU   CNTABLE+32
SUBSREQS EQU   CNTABLE+28
STRGREQS EQU   CNTABLE+24
PUBLREQS EQU   CNTABLE+20
PVTNREQS EQU   CNTABLE+16
SPECREQS EQU   CNTABLE+12
TPREQS   EQU   CNTABLE+8
VAMREQS  EQU   CNTABLE+4
DMYREQS  EQU   CNTABLE
JSCBPTR  EQU   ALCWA+12
WASIZE   EQU   ALCWA
VUGRID   EQU   VOLUNTAB+24
VUUCBP   EQU   VOLUNTAB+20
VUVLUNIQ EQU   VOLSTATD
VUDMUNIQ EQU   VOLSTATD
VUUNALSW EQU   VOLSTATD
VUMUGDON EQU   VOLSTATD
@NM00004 EQU   VOLSTATC
@NM00003 EQU   VOLSTATC
VURECVRY EQU   VOLSTATC
VOLURREQ EQU   VOLSTATC
VOLGRREQ EQU   VOLSTATC
VOLCOREQ EQU   VOLSTATC
VUAFFWRK EQU   VOLSTATB
VUVINELG EQU   VOLSTATB
VUDADSME EQU   VOLSTATB
VUPROCED EQU   VOLSTATB
VOLMNTD  EQU   VOLSTATB
VOLDEFER EQU   VOLSTATA
VUDADSM  EQU   VOLSTATA
VOLRESVE EQU   VOLSTATA
VOLNSHR  EQU   VOLSTATA
VOLSTG   EQU   VOLSTATA
VOLPRV   EQU   VOLSTATA
VOLPUB   EQU   VOLSTATA
VOLID    EQU   VOLUNTAB
EDLNOJES EQU   EDLINDIC
EDLVOLAF EQU   EDLINDIC
EDLENQ   EQU   EDLINDIC
EDLDADSM EQU   EDLINDIC
EDLALCD  EQU   EDLINDIC
EDLJINEL EQU   EDLGRFLG
EDLUCBNO EQU   EDLGNTRY+4
EDLNXGRP EQU   EDLGNTRY
@NM00002 EQU   EDLENTRY+18
EDLNSCNT EQU   EDLENTRY+16
EDLMGENS EQU   EDLUVFLG
EDLVAM   EQU   EDLUVFLG
EDLGMTP  EQU   EDLHDR+12
EDLLUV   EQU   EDLHDR
GRPMASK  EQU   GMTENTRY
GMTENTNO EQU   GMTHDR
EUCBENLN EQU   EUCBHDR+4
EUCBENNO EQU   EUCBHDR
GRPTR    EQU   GRPTRTAB
GENGRPTR EQU   GENENTRY+8
GENGRPNO EQU   GENENTRY+4
GENDEVT  EQU   GENENTRY
GENENTLN EQU   GENHDR+4
GENENTNO EQU   GENHDR
LUVAGMTP EQU   LUVENTRY+28
@NM00001 EQU   LUVFLAGS
LUVMGENS EQU   LUVFLAGS
LUVAGMSK EQU   LUVFLAGS
LUVVAM   EQU   LUVFLAGS
LUVGENP  EQU   LUVENTRY+20
LUVGENNO EQU   LUVENTRY+16
LUVALUE  EQU   LUVENTRY+8
UNITNAME EQU   LUVENTRY
LUVENTLN EQU   LUVHDR+4
LUVENTNO EQU   LUVHDR
.@UNREFD ANOP                          END UNREFERENCED COMPONENTS
@RC00187 EQU   @RC00092
@RC00303 EQU   @RC00299
@RC00341 EQU   @RC00339
BITOFF   EQU   @EL00003
@RC00305 EQU   @RC00303
@ENDDATA EQU   *
         END   IEFAB486,(C'PLS1334',0701,76342)
