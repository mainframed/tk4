         TITLE 'IKJEFP60 - IKJPARS2 INTERFACE AND INITIALIZATION'
*    GEN (EJECT);
         EJECT
*
* /********************************************************************
* /*                                                                  *
* /*  TITLE:   IKJPEF60  - IKJPARS2 LOAD MODULE                       *
* /*                                                                  *
* /*  STATUS:  CHANGE LEVEL - 000                                     *
* /*                                                                  *
* /*  FUNCTION:                                                       *
* /*                                                                  *
* /*    IKJPARS2 IS A SEPARATE LOAD MODULE OF THE IKJPARS             *
* /*  SERVICE ROUTINE IN TSO.  IKJPARS2 CONTROLS THE SYNTACTICAL      *
* /*  SCAN OF COBOL SYMBOLIC DEBUG COMMAND PARAMETERS.  SYNTAX        *
* /*  CHECKING IS PERFORMED, AND PROMPTING IS ACCOMPLISHED,           *
* /*  THROUGH INTERFACES WITH THE IKJPARS LOAD MODULE.  CONSISTENCY   *
* /*  IS MAINTAINED IN ALL EXTERNAL INTERFACES WITH THE TERMINAL      *
* /*  IN SO FAR AS PROMPTING IS CONCERNED.                            *
* /*    THE INTERFACE WITH THE CP IS THE SAME AS WITH IKJPARS.        *
* /*                                                                  *
* /*  ENTRY POINT:   IKJPARS2                                         *
* /*                                                                  *
* /*  INPUT:                                                          *
* /*                                                                  *
* /*    THE PAREMETER CONTROL LIST (PCL) IS CREATED BY THE CP         *
* /*  USING PARSE MACROS.  THE COBOL SYMBOLIC DEBUG COMMAND           *
* /*  SYNTAX IS DESCRIBED BY THREE MACROS:                            *
* /*                                                                  *
* /*      1)    IKJTERM  -  VARIABLES, CONSTANTS,  STATEMENTS         *
* /*                                                                  *
* /*      2)    IKJOPER  -  EXPRESSIONS                               *
* /*                                                                  *
* /*      3)    IKJRSVWD  -  RESERVED WORDS.                          *
* /*                                                                  *
* /*    EACH MACRO GENERATES AN ENTRY IN THE PCL, (PCE).              *
* /*  CONTROL IS PASSED TO IKJPARS2 BY THE IKJPARS LOAD MODULE        *
* /*  WHENEVER ONE OF THESE PCE TYPES IS ENCOUNTERED.                 *
* /*    IKJPARS2 INITIALIZATION INTERROGATES THE PCE TYPE AND         *
* /*  PASSES CONTROL TO ONE OF THREE SCAN ROUTINES TO HANDLE THE      *
* /*  PARTICULAR INPUT PARAMETER:                                     *
* /*                                                                  *
* /*      1) IKJOPER - IKJEFP50 CSECT                                 *
* /*      2) IKJRSVWD - IKJEFP40 CSECT                                *
* /*      3) IKJTERM - IKJEFP60 CSECT                                 *
* /*                                                                  *
* /*    THE PDL ADDRESS IS PLACED IN A 4 BYTE AREA PROVIDED AS INPUT  *
* /*  BY THE CP.                                                      *
* /*    THE INPUT BUFFER RECEIVED BY IKJPARS IS PASSED TO IKJPARS2    *
* /*  WITH POINTERS INITIALIZED TO THE COBOL COMMAND PARAMETER        *
* /*  TO BE SCANNED UNDER THE PCE.  A POINTER TO THE PCE TO CONTROL   *
* /*  THE SCAN IS ALSO PASSED TO IKJPARS2.                            *
* /*                                                                  *
* /*  OUTPUT:                                                         *
* /*                                                                  *
* /*    PARAMETER DESCRIPTOR LIST (PDL) POINTED TO BY THE ANSWER      *
* /*  PLACE.  THE PDL CONTAINS THE PDE'S BUILT BY IKJPARS2 WHILE      *
* /*  SCANNING THE INPUT COMMAND PARAMETERS.                          *
* /*    EACH PDE CORRESPONDS TO ONE PCE AND CONTAINS POINTER TO THE   *
* /*  INPUT PARAMETER, PLUS INDICATORS TO TYPE, LENGTH, ETC.  THE     *
* /*  PDE FULLY DESCRIBES THE INPUT PARAMETER TO THE CP.              *
* /*                                                                  *
* /*  EXTERNAL REFERENCES:                                            *
* /*                                                                  *
* /*    IKJPARS  -  SEVERAL SUBROUTINES IN THE PARSE SERVICE ROUTINE  *
* /*  ARE USED BY THE IKJPARS2 LOAD MODULE TO ACCOMPLISH THE SCAN,    *
* /*  PDL BUILD AND PROMPTING.  THESE ROUTINES ARE ENTERED THROUGH    *
* /*  THE COMMON IKJPARS2 INTERFACE ROUTINE - LINKRET.  ADDRESSES     *
* /*  WITHIN IKJPARS ARE OBTAINED FROM AN ADCON TABLE CREATED         *
* /*  IN IKJPARS.  INDICES INTO THE ADCON TABLE ARE PASSED TO         *
* /*  LINKRET FROM THE PARS2 ROUTINES TO CONTROL THE LINKAGE TO THE   *
* /*  PROPER SUBROUTINE.                                              *
* /*    MAINLINE IKJPARS INITIALIZATION IS ENTERED FIRST.  IF A       *
* /*  COBOL PCE IS ENCOUNTERED, THE IKJPARS2 LOAD MODULE IS BROUGHT   *
* /*  INTO CORE AND CONTROL PASSED TO IT.                             *
* /*    SUBROUTINES OF IKJPARS USED BY IKJPARS2 ARE:                  *
* /*                                                                  *
* /*      1) QSTR01 - QSTRING ROUTINE                                 *
* /*      2) PROMPTQ - PROMPT WITH 'ENTER ..' ROUTINE                 *
* /*      3) POSITXCB - ADD PDE TO PERMANENT PDL ROUTINE              *
* /*      4) SYSR1 - WRITE INVALID MESSAGE AND PROMPT WITH REENTER    *
* /*      5) SKIPB - SKIP BLANKS ROUTINE                              *
* /*      6) RANGE - DETERMINE IF RANGE ENTERED                       *
* /*      7) GENSCAN - PARAMETER SCAN ROUTINE                         *
* /*      8) TYPETEST - DETERMINE CHARACTER TYPE ROUTINE              *
* /*      9) TRANSQ - TRANSLATE TO UPPER CASE ROUTINE                 *
* /*      10) PSTRIMSG - WRITE OUT ENDING PAREN ASSUMED MESSAGE       *
* /*      11) LISTT - DETERMINE IF A LIST ENTERED                     *
* /*      12) STALOC - ALLOCATE STORAGE IN SUBPOOL 1 - PASSED BACK    *
* /*                   TO CP.                                         *
* /*      13) SCANF - POP THE STACK ROUTINE                           *
* /*      14) GETCORE - GET CORE WHICH WILL BE RELEASED BEFORE EXIT   *
* /*      15) NAMESKP3 - SKIP TO NEXT PCE ROUTINE                     *
* /*      17) CLEANUP - FREE CORE, DELETE MODULES AND EXIT            *
* /*      18) PUSHI - PUSH THE STACK ROUTINE                          *
* /*      19) PARS2ENT - ENTRY POINT FROM IKJPARS2 WHEN SUBROUTINE    *
* /*                     FUNCTIONS ARE REQUIRED.                      *
* /*      20) NEXTPCE - GOTO NEXT PCE ROUTINE                         *
* /*                                                                  *
* /*  EXITS NORMAL:                                                   *
* /*                                                                  *
* /*    REGISTER 15 CONTAINS A 00 RETURN CODE.                        *
* /*    ANSWER PLACE CONTAINS PDL ADDRESS.                            *
* /*                                                                  *
* /*  EXITS ERROR:                                                    *
* /*                                                                  *
* /*    REGISTER 15 CONTAINS A 24 RETURN CODE INDICATING AN ERROR     *
* /*  WAS DETECTED IN THE PARAMETERS PASSED TO THE IKJPARS2 LOAD      *
* /*  MODULE.                                                         *
* /*    ALL PRESENT RETURN CODES FROM IKJPARS MAY ALSO BE RETURNED    *
* /*  IF AN ERROR IS DETECTED BY IKJPARS OUTSIDE THE IKJPARS2 MODULE. *
* /*    THE ANSWER PLACE CONTAINS A X'FF000000' IF AN ERROR WAS       *
* /*  DETECTED.                                                       *
* /*                                                                  *
* /*  TABLES AND WORK AREAS:                                          *
* /*                                                                  *
* /*    MACRO IKJEFPWA IS USED TO DEFINE THE WORK AREA OBTAINED       *
* /*  BY IKJEFP00 DURING INITIALIZATION.  THIS MACRO HAS BEEN CHANGED *
* /*  IN RELEASE 21.6 TO CONTIAN NECESSARY FIELDS FOR IKJPARS2        *
* /*  PROCESSING.  THIS MACRO IS EXPANDED IN BOTH IKJPARS AND         *
* /*  IKJEFP20.                                                       *
* /*                                                                  *
* /*  ATTRIBUTES:                                                     *
* /*                                                                  *
* /*    REENTRANT                                                     *
* /*                                                                  *
* /*  CHARACTER CODE DEPENDENCY:                                      *
* /*                                                                  *
* /*    CLASS C.  THE OPERATION OF THIS PROGRAM IS DEPENDENT UPON     *
* /*  AN INTERNAL REPRESENTATION OF THE EXTERNAL CHARACTER SET        *
* /*  WHICH IS EQUIVALENT TO THE ONE USED AT ASSEMBLY TIME.  THE      *
* /*  CODING HAS BEEN DONE SO THAT REDEFINITION OF THE 'CHARACTER'    *
* /*  CONSTANTS, THROUGH MACRO VARIABLES, BY REASSEMBLY, WILL RESULT  *
* /*  IN A CORRECT PROGRAM FOR THE NEW DEFINITION.                    *
* /*                                                                  *
* /*  RELEASE 21.6 SUPPORT CODE: F00969                               *
* /*                                                                  *
* /********************************************************************
* /* A 328320-328380,329320-329360,400320-400360,458320-458388 A00996 *
* /* A 337220-337260,430420-430496                             A00996 *
* /* A 264420-264440,271920-271960,282510-282540,288220-288280 A00996 *
* /* A 295020,298520,304520,368820,381220,447220-447300,295020 A00996 *
* /* A 298520,304520,368820,381220,447220-447300,467920-467980 A00996 *
* /* A 521700,632720-633388,572126-572200                      A00996 *
* /* C 246524,247200,265420,295000,298500,304500,316700,348300 A00996 *
* /* C 337300-338400,363600,368800,381200,383500,454000-454300 A00996 *
* /* C 523300,536600-536800,538500,546600-546700               A00996 *
* /* C 337300-338400,342000                                    A00996 *
* /* D 247300-247400,287800-288200,383600-383700,523400        A00996 *
* /* D 326700-326800                                           A00996 *
* /* C 395100                                                   M4151 *
* /* C 129328-129385,522140-522319                              M4161 *
* /* A 370000 - 370080,387500                                  YM2849 *
* /* D 370000,387500 -387600                                   YM2849 *
*
*    GEN (EJECT);
         EJECT
*
* IKJPARS2:
*    PROC OPTIONS(DONTSAVE,CODEREG(2,3),NOSAVEAREA, REENTRANT);
         LCLA  &T,&SPN                                            0003
.@001    ANOP                                                     0003
IKJPARS2 CSECT ,                                                  0003
         BALR  @2,0                                               0003
@PSTART  DS    0H                                                 0003
         USING @PSTART+00000,@2                                   0003
         LA    @3,4095(0,@2)                                      0003
         USING @PSTART+04095,@3                                   0003
         L     @0,@SIZ001                                         0003
         GETMAIN  R,LV=(0)                                        0003
         LR    @C,@1                                              0003
         USING @DATD+00000,@C                                     0003
         XC    @TEMPS(@L),@TEMPS                                  0003
*
*    /*****************************************************************
*    /*                                                               *
*    /* MACRO VARIABLES                                               *
*    /*                                                               *
*    /*****************************************************************
*
*    GEN (SPACE);
         SPACE
         DS    0H
*    GEN (EJECT);
         EJECT
         DS    0H
*
*    /*****************************************************************
*    /*                                                               *
*    /* DECLARATIONS                                                  *
*    /*                                                               *
*    /*****************************************************************
*
*    DCL
*          R0 REG(0);                /* REGISTER 0 - WORK REG         *
*    DCL
*          R1 PTR(31)REG(1);         /* REGISTER 1 - WORK REGISTER    *
*    DCL
*          R2 REG(2);                /* BASE REGISTER                 *
*    DCL
*          R3 REG(3);                /* BASE REGISTER                 *
*    DCL
*          XINPUT REG(4) PTR(31);    /* POINTER IN COMMAND BUFFER     *
*    DCL
*          XINPUTB REG(5) PTR(31);   /* BACKUP POINTER                *
*    DCL
*          XPCE REG(6) PTR(31);      /* POINTER TO CURRENT PCE        *
*    DCL
*          R7 REG(7);                /* WORK REGISTER                 *
*    DCL
*          LINK1 REG(8);             /* LINKAGE REGISTER FOR PARSE
*                                       SUBROUTINES                   *
*    DCL
*          INDEX REG(8) PTR(31);     /* USED AS INDEX INTO SPECIAL
*                                       MESSAGE AREA                  *
*    DCL
*          LINK2 REG(9);             /* LINKAGE REGISTER FOR PARSE
*                                       SUBROUTINES                   *
*    DCL
*          R10 REG(10);              /* REGISTER 10 - WORK REG        *
*    DCL
*          PWAREG REG(11) PTR(31);   /* BASE REGISTER TO PERMANENT
*                                       WORK AREA                     *
*    DCL
*          OPCEPTR AUTOMATIC PTR(31); /* BASE FOR OPER PCE DSECT      *
*    DCL
*          RSVDRTN AUTOMATIC PTR(31); /* RETURN LOCATION FROM P40     *
* /*                                                           F41448 *
* DCL   1 PWORK BASED(PWAREG) BDY(DWORD),    /*                F41448 *
* /*                                                           F41448 *
*                                       /* PARSE PERMANENT WORKSPACE  *
* /*                                                           F41448 *
*         2 DUMMY1,                     /* USED TO FIND LEN OF CSWORK *
*           4 SAVE1(18) PTR(31),        /* SAVE AREA           F41448 *
*           4 ADDRSAVE(4) PTR(31),      /* SAVEAREA FOR ADDRESS RTN./-*
* /*                                      -IKJEFP03            Y30NQJN*
*           4 P20SAVE(4) PTR(31),       /* IKJEFP20 SAVE AREA  Y02666 *
*           4 INTEGER(8) PTR(31) BDY(DWORD),  /* P20 WORK AREA YM5578 *
*           4 PDWORD(2) PTR(31) BDY(DWORD), /* SCRATCH/SAVE/CONVERT*/
*             6 PDWORD1 CHAR(4),
*             6 PDWORD2 PTR(31),
*               8 PDWD CHAR(1),
* /*                                                           F41448 *
*           4 ENDINPUT PTR(31),         /* LAST INPUT CHAR. ADDRESS   *
* /*                                                           F41448 *
*                                       /*USED TO DETERMINE END OF DAT*
* /*                                                           F41448 *
* /* POINTER TO START OF DATA BEING SCANNED SET BY SKIPB SUBROUTINE   *
* /* ALSO LENGTH OF DATA FIELD. THESE AREAS MUST BE CONTIGUOUS F41448 *
* /*                                                           F41448 *
*           4 PPOINTR PTR(31),          /* LAST ENTITY START   F41448 *
*
*           4 PLENGTH FIXED(15),        /* LAST ENTITY LENGTH  F41448 *
* /*                                                           F41448 *
*           4 RETCODE PTR(8),           /* RETURN CODE AREA           *
* /*                                                           F41448 *
*         2 DUMMY2  BDY(DWORD),         /* TO PUT SUBRWORK ON DWRD BDY*
* /*                                                           F41448 *
*           3 SUBRWORK(2) PTR(31),      /*       SCRATCH/SAVE AREA    *
* /*                                                           F41448 *
*         2 XPDL PTR(31),               /* ADDRESS OF PDL             *
* /*                                                           F41448 *
*         2 TEMPSAVE PTR(31),           /*USED TO TEMPORARILY SAVE R1 *
* /*                                                           F41448 *
*                                       /*BEFORE LINKING TO TRANSLATE *
*                                       /* ROUTINE             F41448 *
*
* /*          PREMANENT WORKSPACE FLAGS                        F41448 *
*
*         2 PFLAGS BIT(8),              /* FIRST FLAG BYTE     F41448 *
* /*                                                           F41448 *
*           3 PFLIST BIT(1),            /* CURRENTLY PROCESSING LIST */
* /*                                                           F41448 *
*           3 PFDEFLT BIT(1),           /* INDICATES A DEFAULT TAKEN  *
* /*                                                           F41448 *
*           3 PFENDF BIT(1),            /* END OF INPUT AREA HAS BEEN *
*                                       /* REACHED             F41448 *
* /*                                                           F41448 *
*           3 ADREXP BIT(1),            /* INDICATE ADDRESS EXPRESSION*
* /*                                                           F41448 *
*           3 HEXBIT BIT(1),            /* ADDRESS EXPRESSION CONTAINS*
*                                       /* A HEX CHARACTER     F41448 *
* /*                                                           F41448 *
*           3 PFBYPAS BIT(1),           /* BYPASS MODE IS TO BE ESTAB*/
* /*                                                           F41448 *
*           3 PFNEW BIT(1),             /* USED BY ADDRESS ROUTINE TO *
* /*                                                           F41448 *
*                                       /* DENOTE A NEW VALID ADDRESS *
* /*                                                           F41448 *
*                                       /* ENTRYNAME (WITH OR WITHOUT *
* /*                                                           F41448 *
*                                       /* LOADNAME QUALIFICATION     *
* /*                                                           F41448 *
*           3 DECBIT BIT(1),            /* ADDR EXPRESSION IS DECIMAL *
* /*                                                           F41448 *
*         2 PFLAGS2 BIT(8),             /* SECOND FLAG BYTE           *
* /*                                                           F41448 *
*           3 PFSKPINV BIT(1),          /* VALIDITY CHECK ROUTINE     *
* /*                                                           F41448 *
*                                       /* REQUESTED A REENTER MESSAGE*
*                                       /* ONLY                F41448 *
* /*                                                           F41448 *
*           3 RNGEVAL1 BIT(1),          /* ADDRESS ROUTINE PROCESSED  *
*                                       /* FIRST VAL  OF RANGE F41448 *
*                                       /* PARAMETER           F41448 *
* /*                                                           F41448 *
*           3 ONERBIT BIT(1),           /* CONTROL BIT USED DURING    *
* /*                                                           F41448 *
*                                       /* SCAN BY ADDRESS ROUTINE    *
* /*                                                           F41448 *
*           3 TWORBIT BIT(1),           /* CONTROL BIT USED DURING    *
* /*                                                           F41448 *
*                                       /* SCAN BY ADDRESS ROUTINE    *
* /*                                                           F41448 *
*           3 RNGEVAL2 BIT(1),          /* ADDRESS ROUTINE PROCESSED  *
* /*                                                           F41448 *
*                                       /* SECOND VALUE OF RANGE      *
*                                       /* PARAMETER           F41448 *
* /*                                                           F41448 *
*           3 REGBIT BIT(1),            /* CONTROL BIT USED DURING    *
* /*                                                           F41448 *
*                                       /* SCAN BY ADDRESS ROUTINE    *
* /*                                                           F41448 *
*           3 FLTERBIT BIT(1),          /* CONTROL BIT USED DURING    *
* /*                                                           F41448 *
*                                       /* SCAN BY ADDRESS ROUTINE    *
* /*                                                           F41448 *
*           3 BREAKBIT BIT(1),          /* USED BY ADDRESS ROUTINE TO *
* /*                                                           F41448 *
*         2 PFLAGS3 BIT(8),             /* THIRD FLAG BYTE            *
*           3 PFSTPRMT BIT(1),          /* PROMPT FOR STRING   F41448 *
* /*                                                           F41448 *
*           3 PFONE BIT(1),             /* INDICATES AT LEAST ONE PDE *
*                                       /* HAS BEEN BUILT      F41448 *
* /*                                                           F41448 *
*           3 LOADBIT BIT(1),           /* CONTROL BIT USED BY ADDRESS*
* /*                                                           F41448 *
*                                       /* RTN DENOTING LOADNAME DATA *
* /*                                                           F41448 *
*           3 ENTRYBIT BIT(1),          /* CONTROL BIT USED BY ADDRESS*
* /*                                                           F41448 *
*                                       /* RTN DENOTING ENTRYNAME DATA*
* /*                                                           F41448 *
*           3 PFNULL BIT(1),            /* INDICATES A NULL LINE WAS  *
* /*                                                           F41448 *
*                                       /* ENTERED AFTER A PROMPT     *
* /*                                                           F41448 *
*           3 LPRNFND BIT(1),           /* USED TO INDICATE A LEFT    *
* /*                                                           F41448 *
*                                       /* PAREN WAS FND BY THE ERROR *
*                                       /* ROUTINE             F41448 *
* /*                                                           F41448 *
*           3 PFSPACE BIT(1),           /* USED TO INDICATE A  F41448 *
* /*                                                           F41448 *
*                                       /* POSITIONAL SPACE PARAMETER *
* /*                                                           F41448 *
*                                       /* WAS ENCOUNTERED SO THAT THE*
* /*                                                           F41448 *
*                                       /* SO THAT THE POSITIONAL     *
* /*                                                           F41448 *
*                                       /* STRING RTN KNOWS WHEN TO   *
*                                       /* END THE STRING      F41448 *
* /*                                                           F41448 *
*           3 PFMORE BIT(1),            /* USED TO INDICATE IF THE    *
* /*                                                           F41448 *
*                                       /* LEFT PAREN OF A SUBFIELD   *
* /*                                                           F41448 *
*                                       /* WAS ALSO USED AS THE LEFT  *
* /*                                                           F41448 *
*                                       /* PAREN OF THE LIST WITHIN   *
*                                       /* THE SUBFIELD        F41448 *
* /*                                                           F41448 *
*         2 PFLAGS4 BIT(8),             /* FOURTH FLAG BYTE           *
* /*                                                           F41448 *
*           3 PFENDLIM BIT(1),          /* INDICATES END DILIMETER FOR*
* /*                                                           F41448 *
*                                       /* SELF-DILIMITING STRING HAS *
*                                       /* BEEN FOUND          F41448 *
*           3 PFLSTEND BIT(1),          /* INDICATES LIST END  F41448 *
* /*                                                           F41448 *
*                                       /* DILIMETER HAS BEEN FOUND   *
* /*                                                           F41448 *
*           3 PFVCMSG BIT(1),           /* INDICATES A VALIDITY CHECK *
* /*                                                           F41448 *
*                                       /* ROUTINE HAS SUPPLIED A     *
*                                       /* SECOND LEVEL MESSAG F41448 *
* /*                                                           F41448 *
*           3 PFPDDATA BIT(1),          /* INDICATE PROCESSING PROMPT *
*                                       /* OR DEFAULT DATA     F41448 *
* /*                                                           F41448 *
*           3 PFSLASH BIT(1),           /* INDICATE DSNAME/USERID RTN *
* /*                                                           F41448 *
*                                       /* IS SCANNING FOR PASSWORD   *
* /*                                                           F41448 *
*           3 PFENDSET BIT(1),          /* INDICATES BACKUP POINTER   *
* /*                                                           F41448 *
*                                       /* FOR ENDINPUT HAS BEEN SET  *
* /*                                                           F41448 *
*           3 PFNOPOP BIT(1),           /* INDICATES STACK IS NOT TO  *
* /*                                                           F41448 *
*                                       /* BE POPPED IF ALL SEPARATORS*
*                                       /* IN PROMPT BUFFER    F41448 *
* /*                                                           F41448 *
*           3 CKRANGE BIT(1),           /* ADDR RTN SHOULD CHECK FOR  *
*                                       /* RANGE               F41448 *
* /*                                                           F41448 *
*         2 PFLAGS5 BIT(8),             /* FIFTH FLAG BYTE            *
* /*                                                           F41448 *
*           3 PFSQSTR BIT(1),           /* SPECIAL QSTRING HANDLING   *
*                                       /* DONE AT LEAST ONCE  F41448 *
* /*                                                           F41448 *
*           3 INVPRMPT BIT(1),          /* CHECK FOR INVALID MSG PRMT *
* /*                                                           F41448 *
*           3 SUBFLG BIT(1),           /*CHECK FOR SUBFIELD PROCESSING*
* /*                                                           F41448 *
*           3 INVFLG BIT(1),            /* CHECK FOR INVALID INPUT FOR
*                                          USER IN NOPROMPT MODE      *
* /*                                                           F41448 *
*           3 BYPASFLG BIT(1),           /*PREVIOUS PCE SPECIFIED BYPAS
*                                          OR PRINT INHIBIT MODE      *
* /*                                                           F41448 *
*           3 RD4 BIT(1),               /* RESERVED                   *
* /*                                                           F41448 *
*           3 RD5 BIT(1),               /* RESERVED                   *
* /*                                                           F41448 *
*           3 RD6 BIT(1),               /* RESERVED                   *
*
*         2 PFLAGS6 BIT(8),             /* SIXTH FLAG BYTE      Y01156*
*         2 PFLAGS7 BIT(8),             /* SEVENTH FLAG BYTE    Y02666*
*         2 PFLAGS8 BIT(8),             /* EIGHTH FLAG BYTE     Y02666*
* /*                                                           F41448 *
* /*        WORKSPACE NEEDED FOR STORAGE ALLOCATION SUBROUTINE        *
* /*                                                           F41448 *
*         2 STORANC CHAR(8),
*           4 PANCHOR PTR(31),          /* ANCHOR FOR STORAGE CHAIN   *
* /*                                                           F41448 *
*
* /*                                                           F41448 *
*           4 PANCHORT PTR(31),         /* INTERNAL MSS CHAIN FREE    *
* /*                                                           F41448 *
*                                       /*  Q ANCHOR                  *
*
* /*                                                           F41448 *
* /*   PARAMETER LIST FOR CONDITIONAL GETMAIN SUBROUTINE              *
*
* /*                                                           F41448 *
*         2 PGETLIST,
* /*                                                           F41448 *
*           5 PGETLNTH FIXED(31),       /* LENGTH REQUESTED           *
* /*                                                           F41448 *
*           5 PGETRADR PTR(31),         /* ADDR IN WHICH ALLOCATED    *
* /*                                                           F41448 *
*                                       /* SPACE ADDR IS PLACED       *
* /*                                                           F41448 *
*           5 PGETMDSP FIXED(15),       /* MODE AND SUBPOOL           *
*
* /*  THE FIRST INPUT PUSHDOWN STACK. IF THIS STACK FILLS UP A F41448 *
* /*  GETMAIN IS ISSUED FOR AN ADDITIONAL STACK. THIS PROCESS  F41448 *
* /*  CONTINUES INDEFINITELY.  THE STACKS ARE BACKWARD CHAINED F41448 *
* /*  WITH THE FIRST STACKS CHAIN WORD REMAINING ZERO.EACH NEW F41448 *
* /*  ENTRY IN THE STACK CONSISTS OF TWO WORDS.  THE FIRST IS  F41448 *
* /*  THE CONTENTS OF XINPUT,AND THE SECOND IS THE CONTENTS OF F41448 *
* /*  ENDINPUT.  THE NEXT FREE AREA IN THE STACK IS FOUND BY   F41448 *
* /*  USING PIPDLX AS AN INDEX INTO THE STACK.                 F41448 *
*
* /*                                                           F41448 *
*         2 PIPDLCUR PTR(31),           /* ADDRESS OF CURRENT INPUT   *
*                                       /* PUSHDOWN STACK      F41448 *
* /*                                                           F41448 *
*         2 PIPDLCHN PTR(31),           /* STORAGE CHAIN - SHOULD     *
*         2 NME(20) PTR(31),            /*FIRST INPUT PUSHDOWN F41448 *
*                                       /* STACK               F41448 *
* /*                                                           F41448 *
*         2 PIPDLX PTR(8),              /*INDEX TO NEXT FREE AREA IN  *
* /*                                                           F41448 *
*                                       /*CURRENT PUSHDOWN STACK      *
* /*                                                           F41448 *
*         2 PLINKSV1 PTR(31),           /*SAVE AREA FOR RETURN ADDRESS*
* /*                                                           F41448 *
*                                       /*OF LINK1 ROUTINES WHICH USE *
* /*                                                           F41448 *
*                                       /*LINK2 ROUTINES AS SUBRTNS   *
* /*                                                           F41448 *
*         2 INVPSAVE PTR(31),           /*BEGINNING ADDR OF PARM -USED*
*                                       /*IF PARM IS INVALID   F41448 *
* /*  ADDRESSES FOR KEYWORD SCANS                              F41448 *
* /*                                                           F41448 *
*         2 PKEYWDPS PTR(31),           /*PTR TO CURRENT NAME ENTRY   *
* /*                                                           F41448 *
*         2  PKEYWDPC PTR(31),          /*PTR TO CURRENT IKJKEYWD PCE *
* /*                                                           F41448 *
*         2 PKEYWDPX PTR(31),           /*TO SAVE IKJKEYWD PCE ADDR   *
* /*                                                           F41448 *
*         2 PKEYWDTB PTR(31),           /*PCL RESULT DURING KEYWORD   *
*                                       /*PROCESSING           F41448 *
* /*                                                           F41448 *
*         2 PKEYWDPM PTR(31),           /*SAVE AREA FOR PDE DURING    *
*                                       /*KEYWORD PROCESSING   F41448 *
*         2 PTABLEAD PTR(31),           /*START OF PCL ADDRESS F41448 *
*         2 PTABLEND PTR(31),           /*END OF PCL ADDRESS   F41448 *
* /*                                                           F41448 *
* /* THE FOLLOWING FIELDS ARE USED AS TEMPORARY POSITIONAL PDE.F41448 *
* /* THE FIELDS ARE MOVED FROM HERE TO THE ACTUAL PDE BY THE   F41448 *
* /* POSITIONAL EXIT ROUTINE. THE AREAS MUST BE CONTIGUOUS     F41448 *
* /*                                                           F41448 *
*         2 TEMPPDE,                    /* NAME OF TEMPORARY AREA     *
*           4 TEMPPDE2,                 /*LEN FOR NORMAL PARSE F41448 *
* /*                                                           F41448 *
*             7 TEMPFLD1,
*               9 DATAPTR1 PTR(31),     /*PTR TO STRING, PSTRING      *
* /*                                                           F41448 *
*                                       /*QSTRING,PASSWORD,DSNAME     *
*                                       /*LOADNAME, OR VALUE   F41448 *
*               9 DATALEN1 FIXED(15),   /*LENGTH OF ABOVE DATA F41448 *
*               9 DATAFLA1 BIT(8),      /*FLAG BYTE            F41448 *
*               9 DATAFLB1 BIT(8),      /*TYPE CODE FOR VALUE  F41448 *
* /*                                                           F41448 *
*             7 TEMPFLD2,
*               9 DATAPTR2 PTR(31),     /*PTR TO MEMBER OR ENTRY NAME *
*               9 DATALEN2 FIXED(15),   /*LENGTH OF ABOVE DATA F41448 *
*               9 DATAFLA2 BIT(8),      /*FLAG BYTE            F41448 *
*               9 DATAFLB2 BIT(8),      /*RESERVED BYTE        F41448 *
* /*                                                           F41448 *
*             7 TEMPFLD3,
*               9 DATAPTR3 PTR(31),     /*PTR TO PASSWORD OR ADDRESS  *
*               9 DATALEN3 FIXED(15),   /*LENGTH OF ABOVE DATA F41448 *
*               9 DATAFLA3 BIT(8),      /*FLAG BYTE            F41448 *
*               9 DATAFLB3 BIT(8),      /*RESERVED BYTE        F41448 *
* /*                                                           F41448 *
*               9 DATAFLG BIT(8),       /*REGISTER NOTATION FLAGS     *
*               9 DATASGN BIT(8),       /*SIGN OF FIRST VALUE  F41448 *
* /*                                                           F41448 *
*               9 DATAICT FIXED(15),    /*INDIRECT ADDRESSING COUNT   *
* /*                                                           F41448 *
*               9 DATAEXP PTR(31),      /*PTR TO NEXT EXPRESSION      *
*                                       /* VALUE PDE           F41448 *
*               9 DATAUSER FIXED(31),   /*USER WORD            F41448 *
* /*                                                           F41448 *
*           4 CBADD(11) PTR(31),        /*COBOL ADDITIONS TO PARSE    *
*                                       /*TEMPORARY PDE        F41448 *
* /*                                                           F41448 *
*         2 ENDBAKUP PTR(31),           /*BACKUP FOR ENDINPUT IF      *
*                                       /* PFSCANX FLAG IS ON  F41448 *
* /*                                                           F41448 *
*         2 PDELIM CHAR(1),             /*SELF-DEFINED DELIMETER      *
* /*                                                           F41448 *
*                                       /*STORED BY DELIMETER ROUTINE *
*         2 PPCOUNT PTR(8),             /*POSITIONAL DATA SIZE F41448 *
*         2 PPDESIZE PTR(8),            /*POSIITONAL PDE SIZE  F41448 *
* /*                                                           F41448 *
*         2 PERRCODE PTR(8),            /*INDEX TO RESCAN ADDR TABLE  *
*         2 PKEYWDVL FIXED(15),         /*TO SAVE VALUE DURING F41448 *
*                                       /* KEYWORD LOOKUP      F41448 *
* /*                                                           F41448 *
*         2 RNG2ADDR PTR(31),           /*ADDR OF 2ND PDE FOR A RANGE *
* /*                                                           F41448 *
*         2 SEGLIST(5) PTR(31),         /*LIST OF MESSAGE SEGMENTS    *
* /*                                                           F41448 *
*                                       /* FOR I/O SERVICE ROUTINES   *
* /*                                                           F41448 *
*         2 PREVPDEL PTR(31),           /*USED TO CONTAIN THE PREV-   *
* /*                                                           F41448 *
*                                       /*IOUS PDE ADDRESS SO THAT    *
* /*                                                           F41448 *
*                                       /*THE VALIDITY CHECK ROUTINE  *
* /*                                                           F41448 *
*                                       /*CAN FETCH IT WHEN A RETURN  *
* /*                                                           F41448 *
*                                       /*CODE OF 4 OR 8 IS RETURNED  *
*                                       /*TO IT BY THE USER    F41448 *
* /*                                                           F41448 *
*         2 VCEPARAM,                   /*VALIDITY CHECK EXIT PARAM-  *
*                                       /* ETERS               F41448 *
*           11 PDEADR PTR(31),          /*ADDRESS OF PDE JUST  F41448 *
*                                       /* CONSTRUCTED         F41448 *
* /*                                                           F41448 *
*           11 USERWORD FIXED(31),      /*USER DATA PASSED IN PARSE   *
* /*                                                           F41448 *
*                                       /* INPUT PARAMETER LIST       *
* /*                                                           F41448 *
*           11 VALMSG PTR(31),          /*ADDRESS OF SECOND LEVEL MSG *
*                                       /* FROM VALIDITY CHECK F41448 *
*           11 MSGCODE PTR(8),          /*OFFSET TO MSG ADDRES F41448 *
* /*  MESSAGE SEGMENT CONTAINING THE LAST PRIMARY MESSAGE ID.  F41448 *
* /*  THIS IS USED AS SEGMENT 1 OF HELP MESSAGES PASSED TO THE F41448 *
* /*  I/O SERVICE ROUTINES. IT INCLUDES THE FOUR BYTE HEADER   F41448 *
* /*  REQUIRED BY THE I/O ROUTINES, AND THE WORD 'ENTER'.      F41448 *
* /*                                                           F41448 *
*         2 PRIMSGID CHAR(20),          /* PRIMARY MESSAGE SEGMENT    *
* /*                                                           F41448 *
*         2 SAVLSLEN FIXED(15),         /* USED TO SAVE THE CORE SIZE *
* /*                                                           F41448 *
*                                       /* REQUESTED BY THE HELP      *
*                                       /* MESSAGE ROUTINE.    F41448 *
* /*                                                           F41448 *
*         2 PLUSSEG CHAR(5),            /* PLUS SIGN MESSAGE SEGMENT  *
* /*                                                           F41448 *
* /*                                                           F41448 *
* /*  SAVE AREAS FOR ADDRESSES OF I/O SERVICE ROUTINES 'LOADED' DURING*
* /*  INITIALIZATION                                           F41448 *
* /*                                                           F41448 *
* /*                                                                  *
*         2 PUTLPTR PTR(31),            /* NAME THE LIST              *
*         2 PUTGPTR PTR(31),            /* PTR TO IKJPTGT RTN F41448  *
* /*                                                           F41448 *
*         2 UPTADDR PTR(31),            /* FIRST WORD OF INPUT PARMS  *
* /*                                                           F41448 *
*         2 ECTADDR PTR(31),            /* SECOND WORD OF INPUT PARMS *
* /*                                                           F41448 *
*         2 ECBADDR PTR(31),            /* THIRD WORD OF INPUT PARMS  *
* /*                                                           F41448 *
*         2 * PTR(31),                  /* FOURTH WORD OF INPUT PARMS *
*
* /*                                                           F41448 *
*         2 OPEREND  PTR(31),           /* PTR TO LAST PCE UNDER OPER *
*
* /*                                                           F41448 *
*         2 RSVWDPCE  PTR(31),          /*  PTR TO PCE BEING USED BY  *
*                                       /* IKJRSVWD            F41448 *
*
* /*                                                           F41448 *
*         2 TERMXPCE  PTR(31),          /*  PTR TO MAJOR TERM         *
*
* /*                                                           F41448 *
*         2 OPERPCE  PTR(31),           /*  PTR TO CURRENT OPER PCE   *
*
* /*                                                           F41448 *
*         2 OPERSVE  PTR(31),           /*  PTR TO LEFT PAREN OF EXPR.*
*
*         2 RSVWDSV1  PTR(31),          /*  LINK REG. SAV AREA F41448 *
*
*         2 RSVWDSV2  PTR(31),          /* LINK REG. SAVE AREA F41448 *
*
*         2 CBLNKSV1  PTR(31),          /* LINK REG. SAVE AREA F41448 *
*
*         2 CBLNKSV2  PTR(31),          /* LINK REG. SAVE AREA F41448 *
*
* /*                                                           F41448 *
*         2 ENDNMPTR  PTR(31),          /* PTR TO END OF CURRENT      *
* /*                                                           F41448 *
*                                       /* DATANAME BEING SCANNED     *
*
* /*                                                           F41448 *
*         2 CHAINPTR  PTR(31),          /*PTR TO CHAIN WD FOR DATANAME*
*                                       /* QUALIFIER PDE'S     F41448 *
*
* /*                                                           F41448 *
*         2 PDEPTR  PTR(31),            /* PTR TO NEXT AVAIL. SPACE IN*
*                                       /* THE TEMPPDE         F41448 *
*
* /*                                                           F41448 *
*         2 AANC  PTR(31),              /* ANCHORS TO CONTROL THE     *
* /*                                                           F41448 *
*         2 TANC  PTR(31),              /* ALLOCATION OF DATANAME     *
* /*                                                           F41448 *
*         2 OANC  PTR(31),              /* QUALIFIER PDE'S - IN CORE  *
* /*                                                           F41448 *
*         2 ENDANC  PTR(31),            /* GOTTEN VIA STALOC ROUTINE  *
*
* /*                                                           F41448 *
*         2 PRMTPTR  PTR(31),           /* PTR TO START OF INVALID    *
* /*                                                           F41448 *
*                                       /* DATA FOR SPECIAL MSG.      *
*
* /*                                                           F41448 *
*         2 OPERLL  FIXED(15),          /*LEN OF PDE FLDS UNDER OPER  *
*
* /*                                                           F41448 *
*         2 MSGAREA BDY(BYTE),          /* PARMS PASSED TO PROMPT FOR *
* /*                                                           F41448 *
*                                       /* SPECIAL MSG. CONSTRUCTION  *
* /*                                                           F41448 *
*           7  MSGLEN  FIXED(15),       /* LENGTH OF FIRST SEGMENT    *
* /*                                                           F41448 *
*           7  MSGADDR PTR(31),         /* ADDR OF FIRST SEGMENT      *
*
* /*                                                           F41448 *
*         2 DIGITCT  PTR(8),            /* DIGIT COUNTER FOR STRINGS  *
*
* /*                                                           F41448 *
*         2 ELEMNCT  PTR(8),            /* NUMBER OF SUBSCRIPTS       *
*
* /*                                                           F41448 *
*         2 QUALCT  PTR(8),             /* NUMBER OF QUALIFIERS       *
*
*         2  CBFLAGS1 BIT(8),           /* FIRST FLAG BYT      F41448 *
* /*                                                           F41448 *
*            7  COBOLMOD BIT(1),        /* COBOL PROCESSING SWITCH    *
* /*                                                           F41448 *
*            7  OPERMODE BIT(1),        /* EXPRESSION PROCESSING SW   *
* /*                                                           F41448 *
*            7  SUBSMODE BIT(1),        /* TERM - SUBSCRIPT MODE SW   *
* /*                                                           F41448 *
*            7  NAMEREQD BIT(1),        /* TERM - DATANAME EXPECTED   *
* /*                                                           F41448 *
*            7  ERRORBIT BIT(1),        /* TERM - ERROR HAS OCCURED   *
* /*                                                           F41448 *
*            7  RSVDPRMT BIT(1),        /* RSVWD HAS BEEN PRMPTED FOR *
*            7  OPERPRMT BIT(1),        /* EXPRESSION HAS BEEN F41448 *
* /*                                                           F41448 *
*                                       /* PROMPTED FOR BY OPER       *
* /*                                                           F41448 *
*            7  RC16     BIT(1),        /* A 16 RETURN CODE HAS BEEN  *
* /*                                                           F41448 *
*                                       /* ENCOUNTERED FROM VALIDITY  *
*                                       /* CHECK ROUTINE       F41448 *
*
*         2  CBFLAGS2 BIT(8),           /* SECOND FLAG BYTE    F41448 *
* /*                                                           F41448 *
*            7  SPECMSG BIT(1),         /* SPECIAL MSG. FORMAT IS TO  *
* /*                                                           F41448 *
*                                       /* BE USED IN PROMPTING       *
* /*                                                           F41448 *
*            7  LFTPAREN BIT(1),        /* A LEFT PAREN IS TO BE      *
* /*                                                           F41448 *
*                                       /* ADDED TO SPECIAL MSG       *
* /*                                                           F41448 *
*            7  RHTPAREN BIT(1),        /* A RIGHT PAREN IS TO BE     *
* /*                                                           F41448 *
*                                       /* ADDED TO SPECIAL MSG. TEXT *
* /*                                                           F41448 *
*            7  CHAINTRM BIT(1),        /* A TERM CHAINED FROM AN     *
* /*                                                           F41448 *
*                                       /* OPER IS BEING PROCESSED    *
* /*                                                           F41448 *
*            7  PARS2IN BIT(1),         /* PARS2 HAS BEEN LOADED      *
* /*                                                           F41448 *
*            7  PRMTSCAN BIT(1),        /* USED BY TERM FOR PRMT DATA *
* /*                                                           F41448 *
*            7  BUFPOPED BIT(1),        /* RECURSION IN SCANF ROUTINE *
* /*                                                           F41448 *
*            7  RNGADDED BIT(1),        /* 1ST VALUE OF RNG ADDED     *
*
*         2  CBFLAGS3 BIT(8),           /* FLAG BYTE THREE     F41448 *
* /*                                                           F41448 *
*            7  FIRSTNAM BIT(1),        /* 1ST DN. OF VAR ENCOUNTERED *
* /*                                                           F41448 *
*            7 CTFOUND BIT(1),          /*BEGIN. OF CHNTRM SBSCRPT FND*
* /*                                                           F41448 *
*            7 BLNKFLAG BIT(1),         /* OPER PTING AT BLNK FOR     *
*                                       /* INVALID MSG. FORMAT F41448 *
*
* /*                                                           F41448 *
*         2  CBFLAGS4 BIT(8),           /* FLAG BYTE FOUR - RSVD      *
*
* /*                                                           F41448 *
*         2 TRANAREA CHAR(2) BDY(HWORD),/* TRANSLATE AREA FOR TERM    *
*
*         2 CORELEN FIXED(15),          /* RESERVED            F41448 *
*
* /*                                                           F41448 *
*         2 PARS2ADR PTR(31),           /* ADDR OF IKJPARS2 LOAD MOD  *
*
* /*                                                           F41448 *
*         2 VCONAD PTR(31),             /*ADDR OF VCON TAB IN IKJPARS *
*
* /*                                                           F41448 *
*         2 GOREGSV PTR(31),            /*RETURN ADDR FROM SUBROUTINE *
*
* /*                                                           F41448 *
*         2 TERMBASE PTR(31),           /*TERM BASE REG SAVE AREA     *
*
* /*                                                           F41448 *
*         2 OPERBASE PTR(31),           /*OPER BASE REG SAVE AREA     *
*
* /*                                                           F41448 *
*         2 BASE3SV  PTR(31),           /*SAVE AREA - PARSE BASE REG3 *
*
* /*                                                           F41448 *
*         2 BASE2SV  PTR(31),           /*SAVE AREA - PARSE BASE REG2 *
*
* /*                                                           F41448 *
*         2 BASE1SV  PTR(31),           /*SAVE AREA - PARSE BASE REG1 *
*
* /*                                                           F41448 *
*         2 RBASESV  PTR(31),           /*SAVE AREA - PARSE RBASE     *
*
* /*                                                           F41448 *
*         2 CBLRET PTR(31),             /* POINT TO RETURN TO IN THE  *
* /*                                                           F41448 *
*                                       /* NEW IKJPARS2 LOAD          *
* /*                                                           F41448 *
*                                       /* AFTER EXECUTION OF ANY     *
* /*                                                           F41448 *
*                                       /* SUBROUTINE IN IKJPARS      *
* /*                                                           F41448 *
*         2 COREADDR PTR(31),           /* ADDR OF CORE GOTTEN FOR MSG*
*
* /*                                                           F41448 *
*         2 AUTOBASE PTR(31),           /*SAVE AREA FOR DATAREG (BSL) *
*
* /*                                                           F41448 *
*         2 WORKSAVE(4) PTR(31),        /* WORKREG SAVE AREA -LINKAGE *
*
* /*                                                           F41448 *
*         2 PLINKSV2 PTR(31),           /* RETURN ADDR SAVE AREA FROM *
* /*                                                           F41448 *
*                                       /* VALIDITY CHECK AND CODE4   *
* /*                                                           F41448 *
*         2 KEYPTR PTR(31),             /* KEYWORD PTR          Y01156*
*         2 KEYLEN FIXED(15),           /* USER KEYWORD LENGTH  Y01156*
*         2 KEYBUF CHAR(37) BDY(HWORD), /* 2ND SEGMENT FOR SUBFIELD-
*                                          PROMPT               Y01156*
*          6 KEYBUFLN FIXED(15),        /* ENTIRE SEGMENT LENGTHY01156*
*          6 KEYBUFOF FIXED(15),        /* OFFSET IN PRIMARY MSGY01156*
*          6 KEYDATA CHAR(33);          /* USER ENTERED KEYWORD Y01156*
* /*  ALLOCATE SPACE IN WHICH TO MOVE THE L FORM OF THE I/O    F41448 *
* /*  SERVICE ROUTINE MACROS.                                  F41448 *
* /*                                                           F41448 *
* GENERATE DATA;
* /*  END OF IKJEFPWA                                          F41448 *
*    DCL
*          R12 REG(12);              /* WORK REG - REGISTER 12        *
*    DCL
*          R13 REG(13);              /* WORK REG - REGISTER 13        *
*    DCL
*          GOREG REG(14);            /* USED AS RETURN REGISTER WHEN
*                                       GO TO PARSE SUB- ROUTINES     *
*    DCL
*          R14 REG(14);              /* USED AS RETURN REGISTER       *
*    DCL
*          R15 REG(15);              /* SUBROUTINE ADDRESS LOADED HERE
*                                       BY PARS2 - RETURN CODE HERE
*                                       FROM IKJPARS                  *
*    DCL
*          INDEX1 PTR(31);           /* USED AS INDEX PTR INTO SPECIAL
*                                       MESSAGE AREA                  *
*
*    /*****************************************************************
*    /*                                                               *
*    /* LABEL FOR REFERENCING PCE TYPE TO DETERMINE WHETHER OPER, TERM*
*    /* OR RESERVED WORD PCE                                          *
*    /*                                                               *
*    /*****************************************************************
*
*    DCL
*          1 MASK BASED(XPCE),       /* LABEL FOR REFERENCING PCE TYPE
*                                       MASK IN FIRST BYTE OF         *
*            2 PCETYPE BIT(3),       /* PCE                           *
*            2 * BIT(5);
*
*    /*****************************************************************
*    /*                                                               *
*    /* IKJOPER PCE MAPPING                                           *
*    /*                                                               *
*    /*****************************************************************
*
*    DCL
*          1 OPCEFLD1 BASED(OPERPCE) BDY(BYTE), /* MAP FIRST FIXED
*                                       OPER FIELD                    *
*            2 OPCEBYT1 BIT (16),    /* FIRST BYTE OF INDICATORS      *
*              3 OPERMASK BIT(3),    /* INDICATES PCE TYPE            *
*              3 OPRMTI BIT(1),      /* PROMPT DATA SUPPLIED          *
*              3 ODLFTI BIT(1),      /* DEFAULT DATA SUPPLIED         *
*              3 * BIT(11),          /* NOT REFERENCED                *
*            2 OPCELNTH FIXED(15),   /* OPER PCE LENGTH               *
*            2 OPDEINDX FIXED(15),   /* OFFSET TO OPER PDE FROM START
*                                       OF PDL                        *
*            2 OPCEPTL FIXED(15),    /* PARAMETER TYPE FIELD LENGTH   *
*            2 * FIXED(15);          /* NOT REFERENCED                *
*
*    /*****************************************************************
*    /*                                                               *
*    /* MAP SECOND FIXED FIELD IN THE IKJOPER PCE                     *
*    /*                                                               *
*    /*****************************************************************
*
*    DCL
*          1 OPCEFLD2 BASED(OPCEPTR) BDY(BYTE), /* MAP SECOND FIXED
*                                       OPER FIELD                    *
*            2 RPCEINDX FIXED(15),   /* OFFSET TO RSVWD PCE FROM START
*                                       OF PDL                        *
*            2 T1PCEIDX FIXED(15),   /* OFFSET TO MINOR TERM1 PCE     *
*            2 T2PCEIDX FIXED(15),   /* OFFSET TO MINOR TERM2 PCE     *
*            2 T3PCEIDX FIXED(15),   /* OFFSET TO MINOR TERM3 PCE     *
*            2 * FIXED(15);          /* NOT REFERENCED                *
*
*    /*****************************************************************
*    /*                                                               *
*    /* NAME REFERENCING PDE SPACE UNDER THE OPER PDE                 *
*    /*                                                               *
*    /*****************************************************************
*
*    DCL
*          OPDE CHAR(256) BASED(INDEX);
*    DCL
*          ADDR1 FIXED(15);          /* INDEX INTO LINE SCANNING      *
*    DCL
*          LINKRET INTERNAL ENTRY LOCAL; /* SUBROUTINE TO PROVIDE
*                                       LINKAGE WITH IKJPARS          *
*    DCL
*          MSGSETUP INTERNAL ENTRY LOCAL; /* SUBROUTINE TO BUILD THE
*                                       SPECIAL MESSAGE REQUIRED BY
*                                       IKJPARS2                      *
*    DCL
*          VCONTAB(19) PTR(31) BASED(VCONAD); /* VCON TABLE FOR
*                                       RESOLVING                     *
*    DCL
*          DTANME (*) CHAR(1) BASED(MSGADDR); /* FIRST DATA NAME WHICH
*                                       IS INVALID - PINTED TO BY MSG
*                                       ADDR FIELD SET BY MACRO
*                                       PROCESSORS                    *
*    DCL
*          INVDATA (*) CHAR(1) BASED(INVPSAVE); /* DATA FOUND TO BE
*                                       INVALID MUST BE MOVED INTO THE
*                                       'INVALID...' MESSAGE          *
*
*    /*****************************************************************
*    /*                                                               *
*    /* POINTER TO NEXT LIST PDE FOR ELIMINATING LAST PDE FROM CHAIN  *
*    /*                                                               *
*    /*****************************************************************
*
*    DCL
*          LISTPTR PTR(31) BASED(PREVPDEL);
*
*    /*****************************************************************
*    /*                                                               *
*    /* NAME FOR REFERENCING THE COBOL TEMPORARY PDE AREA WHEN MUST   *
*    /* ERASE                                                         *
*    /*                                                               *
*    /*****************************************************************
*
*    DCL
*          CBLTEMP CHAR(LENGTH(TEMPPDE)) BASED(ADDR(TEMPPDE));
*    DCL
*          MSGAREA1 (*) CHAR(1) BASED(COREADDR); /* CORE GOTTEN TO
*                                       BUILD SPECIAL MESSAGE         *
*    DCL
*          MSGA (*) CHAR(1) BASED(INDEX1); /* ALSO USED AS MESSAGE
*                                       AREA                          *
*    DCL
*          TERM LABEL GENERATED;     /* LABEL FOR TERM PCE            *
*    DCL
*          OPERLD LABEL GENERATED;   /* LABEL FOR OPER PCE            *
*    DCL
*          RSVD LABEL GENERATED;     /* LABEL FOR RSVD WORD PCE       *
*    DCL
*          RTRNAD LABEL GENERATED;   /* ENTRY RETURN FROM IKJPARS     *
*
*    /*****************************************************************
*    /*                                                               *
*    /* GENERATE ENTRY CODE TO LOAD REQUIRED MACRO PROCESSOR ADDRESS  *
*    /*                                                               *
*    /*****************************************************************
*
*    RESPECIFY
*         (XPCE,
*          XINPUT,
*          XINPUTB,
*          PWAREG) RESTRICTED;
*    TERMBASE = R2;                  /* SAVE IKJPARS2 BASE            *
         ST    @2,620(0,@B)                                       0048
*    OPERBASE = R3;                  /* REGISTERS                     *
         ST    @3,624(0,@B)                                       0049
*    AUTOBASE = R12;                 /* SAVE BASE REGISTER TO AUTO-
*                                       MATIC STORAGE                 *
         ST    @C,652(0,@B)                                       0050
*    CBLRET = ADDR(RTRNAD);          /* SAVE RETURN ADDRESS FROM
*                                       IKJPARS IN THE WORK AREA      *
         LA    @F,RTRNAD                                          0051
         ST    @F,644(0,@B)                                       0051
*    IF PCETYPE = '110'B             /* IF THIS IS A TERM PCE GO      *
*      THEN
         TM    0(@6),B'11000000'                                  0052
         BC    12,@9FF                                            0051
         TM    0(@6),B'00100000'                                  0052
*      GOTO TERM;                    /* TO LOAD IKJEFP60 ADDRESS      *
         BC    10,TERM                                            0053
*    IF PCETYPE = '111'B             /* IF THIS IS AN OPER PCE GO     *
*      THEN
@9FE     EQU   *                                                  0054
@9FF     TM    0(@6),B'11100000'                                  0054
*      GOTO OPERLD;                  /* LOAD IKJEFP50 ADDRESS         *
         BC    01,OPERLD                                          0055
*    IF PCETYPE = '101'B             /* IF RESERVED WORD PCE GO       *
*      THEN
         TM    0(@6),B'10100000'                                  0056
         BC    12,@9FD                                            0055
         TM    0(@6),B'01000000'                                  0056
*      GOTO RSVD;                    /* LOAD IKJEFP40 ADDRES          *
         BC    10,RSVD                                            0057
*    GOTO ERROR;                     /* IF NONE OF COBOL PCE'S IT IS
*                                       AN ERROR                      *
         BC    15,ERROR                                           0058
*
*    /*****************************************************************
*    /*                                                               *
*    /* GENERATE CODE TO LOAD THE MACRO PROCESSOR ENTRY ADDRESS INTO  *
*    /* REGISTER 1 AND BRANCH TO THE REQUIRED ENTRY                   *
*    /*                                                               *
*    /*****************************************************************
*
*    GENERATE;
RSVD     L     R1,RSVDENT              RESERVED WORD MACRO PROCESSOR
         BR    R1                      GO TO RESERVED WORD
TERM     L     R1,TERMENT              LOAD TERM MACRO PROCESSOR
         BR    R1                      ADDRESS AND BRANCH
OPERLD   L     R1,OPERENT              LOAD OPER MACRO PROCESSOR
         BR    R1                      ADDRESS AND BRANCH
TERMENT  DC    A(IKJEFP60)             ENTRY - TERM MACRO PROCESSOR
RSVDENT  DC    A(IKJEFP40)             ENTRY - RESERVED WORD MACRO
*                                      PROCESSOR
OPERENT  DC    A(IKJEFP50)             ENTRY - OPER MACRO PROCESSOR
         EJECT
         DS    0H
*
*    /*****************************************************************
*    /*                                                               *
*    /* INTERNAL PROCEDURE - LINKRET THE MACRO PROCESSORS COME HERE TO*
*    /* GO TO PARSE TO USE A SUBROUTINE OF IKJPARS - IKJEFP00         *
*    /*                                                               *
*    /*****************************************************************
*
*
* LINKRET:
*    PROC OPTIONS(DONTSAVE,NOSAVEAREA);
@EL01    LR    @1,@C                                              0060
         L     @0,@SIZ001                                         0060
         FREEMAIN R,LV=(0),A=(1)                                  0060
         BCR   15,@E                                              0060
LINKRET  EQU   *                                                  0060
*
*    /*****************************************************************
*    /*                                                               *
*    /* RESTRICT REQUIRED REGISTERS                                   *
*    /*                                                               *
*    /*****************************************************************
*
*    RESPECIFY
*         (XPCE,
*          XINPUT,
*          XINPUTB,
*          PWAREG,
*          R7,
*          R1) RESTRICTED;
*
*    /*****************************************************************
*    /*                                                               *
*    /* GENERATE THE CODE TO HANDLE THE LINKAGE BETWEEN IKJPARS AND   *
*    /* IKJPARS2. THIS MUST BE DONE BECAUSE THE VALUES IN REGISTER 14 *
*    /* AND REGISTER 15 MUST REMAIN UNCHANGED.                        *
*    /*                                                               *
*    /*****************************************************************
*
*    GENERATE;                       /* SAVE WORK REGISTERS           *
         USING  PWORK,PWAREG           ESTABLIST PWORK ADDRESSABILITY
         STM    R7,R10,WORKSAVE        SAVE WORK REGISTERS
         DROP   PWAREG                 FREE BASE REGISTER
         DS    0H
*    BUFPOPED='0'B;                  /* SET CONTRL FOR POPSTCK RTN    *
         NI    600(@B),B'11111101'                                0063
*    INVPRMPT='0'B;                  /* TURN OFF INVALID PROMPT IND-
*                                       ICATOR FOR IKJPARS1           *
         NI    180(@B),B'10111111'                                0064
*    R15 = VCONTAB(R15);             /* LOAD THE REQUIRED IKJPARS
*                                       ROUTINE ADDRESS FROM THE VCON
*                                       TABLE - INDEX INTO THE TABLE
*                                       IS IN R15                     *
         LR    @8,@F                                              0065
         BCTR  @8,0                                               0065
         SLA   @8,2                                               0065
         L     @9,612(0,@B)        
         L     @F,0(@8,@9)                                        0065
*    GOREGSV=GOREG;                  /* STORE RETURN ADDRESS IN WORK
*                                       AREA                          *
         ST    @E,616(0,@B)                                       0066
*    GOREG=VCONTAB (18);             /* LOAD ENTRY PT INTO IKJPARS    *
         L     @8,612(0,@B)        
         L     @E,68(0,@8)                                        0067
*    RESPECIFY
*          R1 UNRESTRICTED;          /* RELEASE REGISTER 1            *
*    GENERATE;
         USING   PWORK,PWAREG          ADDRESSABILITY TO PWORK
         LR    R13,PWAREG              RESTORE IKJPARS' WORK AREA
*                                      BASE REGISTER
         L     R7,BASE3SV              RESTORE BASE REGISTERS
         LM    R10,R12,BASE2SV         RESTORE BASE REGS AND BASE
*                                      REGISTER TO RECURSIVE WORK
*                                      AREA
         BR    GOREG                   BRANCH TO IKJPARS ENTRY
RTRNAD   L     R14,GOREGSV             LAOD RETURN ADDRESS TO PROPER
*                                      ROUTINE IN IKJPARS2
         AR    R14,R15                 ADD RETURN CODE TO RETURN ADDR
         LM    7,10,WORKSAVE           RESTORE WORK REGISTERS
         BR    R14                     RETURN TO ROUTINE ADDRESS PLUS
*                                      RETURN CODE
         DROP PWAREG                   FREE BASE REG FOR WORKAREA
         EJECT
         DS    0H
*
*    /*****************************************************************
*    /*                                                               *
*    /* TESTING                                                       *
*    /*                                                               *
*    /*****************************************************************
*
*
* EL:
*    END LINKRET;                    /* END INTERFACE PROCEDURE       *
EL       EQU   *                                                  0070
@EL02    BCR   15,@E                                              0070
*
*    /*****************************************************************
*    /*                                                               *
*    /* INTERNAL PROCEDURE - MSGSETUP THIS ROUTINE PREPARES THE       *
*    /* 'INVALID - PARAMETER TYPE - INVALID DATA' MESSAGE BEFORE GOING*
*    /* TO IKJPARS TO WRITE IT TO THE TERMINAL. COBOL SUPPORT HAS A   *
*    /* SPECIAL MESSAGE FORMAT WHICH THIS ROUITNE HANDLES. CORE IS    *
*    /* GOTTEN FOR THE SPECIAL MESSAGE AND ALL THE INVALID DATA IS    *
*    /* MOVED INTO A CONTIGUOUS AREA SO THAT THE SPECIAL MESSAGE      *
*    /* APPEARS IDENTICAL TO ALL OTHER MESSAGES IKJPARS MUST HANDLE.  *
*    /* THE MESSAGE FORMAT IS THE FOLLOWING: 'INVALID PARMATER TYPE   *
*    /* DATA                                                          *
*    /*       ...DATA' THE ELLIPSES REPRESENT A NEW FUNCTION ADDED TO *
*    /* THE INVALID MESSAGE.                                          *
*    /*                                                               *
*    /*****************************************************************
*
*
* MSGSETUP:
*    PROC OPTIONS(DONTSAVE,NOSAVEAREA);
MSGSETUP EQU   *                                                  0071
*
*    /*****************************************************************
*    /*                                                               *
*    /* RESTRICT REQUIRED REGISTERS                                   *
*    /*                                                               *
*    /*****************************************************************
*
*    RESPECIFY
*         (XPCE,
*          XINPUT,
*          XINPUTB,
*          PWAREG,
*          INDEX) RESTRICTED;
*    PLINKSV2 = CBLNKSV2;            /* RETURN ADDRESS IN CASE OF AN
*                                       ERROR FROM VALIDITY CHECK MUST
*                                       BE SAVED. IKJPARS WILL RESTORE
*                                       ADDR. FROM PLINKSV2 IF AN
*                                       ERROR IS RETURNED FROM THE
*                                       V.C. EXIT                     *
         MVC   672(4,@B),552(@B)                                  0073
*
*    /*****************************************************************
*    /*                                                               *
*    /* CHECK TO SEE IF IT IS AN IKJTERM PCE                          *
*    /*                                                               *
*    /*****************************************************************
*
*    IF PCETYPE = '110'B THEN        /* IS IT AN IKJTERM              *
         TM    0(@6),B'11000000'                                  0074
         BC    12,@9FB                                            0073
         TM    0(@6),B'00100000'                                  0074
         BC    05,@9FA                                            0074
*      DO;                           /* IF IS , DO THE FOLLOWING
*                                       INITIALIZATION                *
*        TANC = AANC;                /* RESET CORE ANCHORS TO ERASE
*                                       ALL QUALIFIER PDE'S WHICH MAY
*                                       HAVE BEEN ADDED               *
         MVC   572(4,@B),568(@B)                                  0076
*        SEGLIST (5)= XPCE+7;            /* INITIALIZE MESSAGE PARM
*                                       FIELD FOR THE PUTLINE TO POINT
*                                       TO THE PARAMETER TYPE FIELD IN
*                                       THE PCE                       *
         LA    @F,7                                               0077
         AR    @F,@6                                              0077
         ST    @F,444(0,@B)                                       0077
*        GOTO MSGSET;                /* GO TO FORMAT THE MESSAGE      *
         BC    15,MSGSET                                          0078
*      END;
*
*    /*****************************************************************
*    /*                                                               *
*    /* DETERMINE IF THE PCETYPE IS AN OPER                           *
*    /*                                                               *
*    /*****************************************************************
*
*    IF PCETYPE = '111'B THEN        /* IF PCE TYPE IS AN OPER        *
@9FA     EQU   *                                                  0080
@9FB     TM    0(@6),B'11100000'                                  0080
         BC    12,@9F9                                            0080
*      DO;                           /* DO THE FOLLOWING INIDTIAL-
*                                       IZATION                       *
*        TANC=OANC;                  /* RESET CORE ANCHORS TO WIPE    *
         MVC   572(4,@B),576(@B)                                  0082
*        AANC = OANC;                /* OUT ANY QUALIFIER PDE'S       *
         MVC   568(4,@B),576(@B)                                  0083
*        INDEX = XPDL + OPDEINDX;    /* ADD OPER PDE OFFSET FROM THE
*                                       PCE TO THE BEGINNING OF THE
*                                       PDE TO GET OPER PDE ADDRESS   *
         L     @1,532(0,@B)        
         MVC   @TEMP2+2(2),4(@1)                                  0084
         LH    @8,@TEMP2+2                                        0084
         A     @8,168(0,@B)                                       0084
*
*        /*************************************************************
*        /*                                                           *
*        /* CLEAR THE PERMANENT PDE UNDER THE OPER PDE TO GET RID OF  *
*        /* ANY INFORMATION WHICH MAY HAVE BEEN FILLED IN UNDER THE   *
*        /* OPER                                                      *
*        /*                                                           *
*        /*************************************************************
*
*        OPDE (1:OPERLL) = OPDE(1:OPERLL)&&OPDE(1:OPERLL);
         LR    @E,@8                                              0085
         LH    @7,588(0,@B)                                       0085
         BCTR  @7,0                                               0085
         LR    @A,@8                                              0085
         EX    @7,@XC                                             0085
*        SEGLIST (5) = XPCE+6;          /* FILL IN PUTLINE PARAMETER
*                                       LIST WITH ADDR OF PARAMETER
*                                       TYPE FIELD IN THE PCE         *
         LA    @F,6                                               0086
         AR    @F,@6                                              0086
         ST    @F,444(0,@B)                                       0086
*        GOTO MSGSET;                /* GO TO FORMAT THE MESSAGE      *
         BC    15,MSGSET                                          0087
*      END;                          /* END OPER PCE PROCESSING       *
*
*    /*****************************************************************
*    /*                                                               *
*    /* DETERMINE IF PROCESSING UNDER A RESERVED WORD PCE             *
*    /*                                                               *
*    /*****************************************************************
*
*    IF PCETYPE = '101'B THEN        /* SEE IF PROCESSING A RESERVD   *
@9F9     TM    0(@6),B'10100000'                                  0089
         BC    12,@9F8                                            0088
         TM    0(@6),B'01000000'                                  0089
         BC    05,@9F7                                            0089
*      DO;                           /* WORD PCE                      *
*        SEGLIST (5)= XPCE+6;          /* POSITION TO PARAMETER TYPE
*                                       FIELD IN THE PCE              *
         LA    @F,6                                               0091
         AR    @F,@6                                              0091
         ST    @F,444(0,@B)                                       0091
*        GOTO MSGSET;                /* GO TO FORMAT THE MESSAGE      *
         BC    15,MSGSET                                          0092
*      END;                          /* END SPECIAL RESERVED WORD PCE
*                                       PROCESSING                    *
*
* ERROR:                             /* ERROR ENTRY                   *
*    RETCODE = 24;                   /* IF FALL THROUGH TO HERE.
*                                       MSGSETUP WAS ENTERED UNDER AN
*                                       INVALID PCE TYPE AND AN ERROR
*                                       RETURN MUST BE MADE           *
@9F7     EQU   *                                                  0094
@9F8     EQU   *                                                  0094
ERROR    MVI   154(@B),24                                         0094
*    R15 = 16;                       /* LOAD R15 WITH ADDRESS OF
*                                       CLEANUP ROUTINE IN IKJPARS    *
         LA    @F,16                                              0095
*    GOTO LINKRET;                   /* GO TO ROUTINE TO HANDLE
*                                       LINKAGE TO IKJPARS            *
         BC    15,LINKRET                                         0096
*
*    /*****************************************************************
*    /*                                                               *
*    /* ROUTINE TO FORMAT THE SPECIAL MESSAGE IF REQUIRED             *
*    /*                                                               *
*    /*****************************************************************
*
*
* MSGSET:
*    MSGCODE = 20;                   /* INDICATE INVALID MESSAGE TO BE
*                                       WRITTEN                       *
MSGSET   MVI   464(@B),20                                         0097
*    CBLTEMP = CBLTEMP && CBLTEMP;   /* CLEAR THE COBOL TEMPORARY PDE *
         XC    332(80,@B),332(@B)                                 0098
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF XINPUTB IS GREATER THAN THE END OF THE BUFFER, MUST SET IT *
*    /* EQUAL TO ENDINPUT SO WON'T GET GARBAGE IN THE ERROR MESSAGE   *
*    /*                                                               *
*    /*****************************************************************
*
*    IF BLNKFLAG ^= '1'B             /* IF OPER SAYS NOT PTING AT A   *
*      THEN                          /* BLANK OUT OF BUFFER THEN      *
         TM    601(@B),B'00100000'                                0099
         BC    01,@9F6                                            0099
*      IF XINPUTB>ENDINPUT           /* IF XINPUTB IS OFF THE         *
*        THEN                        /* BUFFER, RESET IT SO           *
         C     @5,144(0,@B)                                       0100
         BC    12,@9F5                                            0100
*        XINPUTB=ENDINPUT;           /* NO GARBAGE IN MESSAGE         *
         L     @5,144(0,@B)                                       0101
*    BLNKFLAG = '0'B;                /* RESET BLANK INDICATOR         *
@9F5     EQU   *                                                  0102
@9F6     NI    601(@B),B'11011111'                                0102
*    INDEX = XINPUTB - INVPSAVE;     /* GET LENGTH OF INVALID DATA    *
         L     @8,300(0,@B)                                       0103
         LCR   @8,@8                                              0103
         AR    @8,@5                                              0103
*    IF INDEX <= 0                   /* IF LENGTH IS ZERO OR LESS     *
*      THEN
         LTR   @8,@8                                              0104
*      GOTO ERROR;                   /* IT IS AN ERROR                *
         BC    12,ERROR                                           0105
*
*    /*****************************************************************
*    /*                                                               *
*    /* DETERMINE IF A SPECIAL MESSAGE IS REQUIRED                    *
*    /*                                                               *
*    /*****************************************************************
*
*    IF SPECMSG = '1'B THEN          /* IF SPECIAL MESSAGE, MUST DO
*                                       INITIALIZATION BEFORE GO TO
*                                       IKJPARS TO WRITE IT OUT       *
         TM    600(@B),B'10000000'                                0106
         BC    12,@9F4                                            0106
*      DO;                           /* DO SPECIAL MESSAGE PROCESS    *
*        RESPECIFY
*              R1 RESTRICTED;        /* RESTRICT R1 BECAUSE IKJPARS IS
*                                       DEPENDENT ON VALUES IN 1      *
*        XINPUTB = XINPUTB-INVPSAVE; /* GET LENGTH OF INVALID DATA
*                                       INTO XINPUTB                  *
         S     @5,300(0,@B)                                       0109
*        R1 = XINPUTB + 5 + MSGLEN;  /* GET TOTAL LENGTH OF CORE
*                                       REQUIRED IN WHICH TO BUILD THE
*                                       SPECIAL MESSAGE               *
         LH    @1,590(0,@B)                                       0110
         AH    @1,@D1                                             0110
         AR    @1,@5                                              0110
*        CORELEN = R1;               /* SAVE THE LENGTH OF THE GET-
*                                       MAIN FOR SUBSEQUEND FREEMAN   *
         STH   @1,606(0,@B)                                       0111
*        R15 = 14;                   /* LOAD THE ADDRESS OF THE
*                                       GETMAIN ROUTINE IN IKJPARS    *
         LA    @F,14                                              0112
*        CALL LINKRET;               /* GO TO PROCEDURE WHICH HANDLES
*                                       LINKAGES TO IKJPARS.          *
         BAL   @E,LINKRET                                         0113
*        COREADDR = SUBRWORK(1);     /* SAVE ADDR OF CORE GOTTEN FOR
*                                       SUBSEQUENT FREEMAIN           *
         MVC   648(4,@B),160(@B)                                  0114
*        INDEX1=SUBRWORK (1);        /* SET BASE FOR MSGA             *
         MVC   INDEX1(4),160(@B)                                  0115
*
*        /*************************************************************
*        /*                                                           *
*        /* DETERMINE IF IT IS NECESSARY TO INSERT A LEFT PARENTHESIS *
*        /* INTO THE SPECIAL MESSAGE BUFFER. THIS BIT IS SET BY THE   *
*        /* INDIVIDUAL MACRO PROCESSORS                               *
*        /*                                                           *
*        /*************************************************************
*
*        IF LFTPAREN = '1'B          /* IS LEFT PAREN REQUIRED        *
*          THEN
         TM    600(@B),B'01000000'                                0116
         BC    12,@9F3                                            0116
*          MSGAREA1 (1) = '(';       /* IF SO, INSERT LEFT PAREN      *
         L     @7,648(0,@B)        
         MVI   0(@7),C'('                                         0117
         BC    15,@9F2                                            0118
*        ELSE
*          MSGAREA1 (1) = ' ';       /* IF NOT, BLANK OUT FIRST BYTE
*                                       OF THE MESSAGE BUFFER         *
@9F3     L     @7,648(0,@B)        
         MVI   0(@7),C' '                                         0118
*        INDEX1=INDEX1+1;            /* INCREMENT MSGA BASE           *
@9F2     LA    @F,1                                               0119
         A     @F,INDEX1                                          0119
         ST    @F,INDEX1                                          0119
*
*        /*************************************************************
*        /*                                                           *
*        /* MOVE IN THE FIRST PART OF THE INVALID MESSAGE. THIS MOVES *
*        /* IN THE FIRST DATA NAME MOVE DATA INTO FIRST PART OF       *
*        /* MESSAGE AREA                                              *
*        /*                                                           *
*        /*************************************************************
*
*        DO INDEX=MSGLEN TO 1 BY -1; /* MOVE 1 CHARACTER AT A TIME
*                                       FROM THE END BACKWARDS        *
         LH    @F,590(0,@B)                                       0120
         LTR   @8,@F                                              0120
         BC    12,@DO9F0                                          0120
*          MSGA (INDEX) = DTANME(INDEX); /* 1 CHARACTER OF DATA FOR
*                                       SPECIFIED LENGTH              *
@DO9F1   LR    @7,@8                                              0121
         BCTR  @7,0                                               0121
         L     @9,592(0,@B)        
         LA    @E,0(@7,@9)                                        0121
         L     @9,INDEX1                                          0121
         LA    @A,0(@7,@9)                                        0121
         MVC   0(1,@A),0(@E)                                      0121
*        END;                        /* LENGTH OF FIRST DATA NAME     *
*        INDEX1 = INDEX1 + MSGLEN;   /* INCREASE ADDRESS INTO SPECIAL
*                                       MESSAGE LINE BY LENGTH OF DATA
*                                       JUST MOVED IN                 *
         BCT   @8,@DO9F1                                          0122
@DO9F0   LH    @F,590(0,@B)                                       0123
         A     @F,INDEX1                                          0123
         ST    @F,INDEX1                                          0123
*
*        /*************************************************************
*        /*                                                           *
*        /* MOVE IN ELLIPSES                                          *
*        /*                                                           *
*        /*************************************************************
*
*        DO INDEX=3 TO 1 BY -1;      /* MOVE IN ELLIPSES              *
         LA    @8,3                                               0124
*          MSGA (INDEX) = '.';       /* MOVE IN ELLIPSES - 3 PERIOD   *
@DO9ED   LR    @7,@8                                              0125
         BCTR  @7,0                                               0125
         L     @9,INDEX1                                          0125
         LA    @A,0(@7,@9)                                        0125
         MVI   0(@A),C'.'                                         0125
*        END;                        /* END MOVE                      *
*        INDEX1 = INDEX1+3;          /* INCREMENT MSGA ADDRESS PASSED
*                                       THE '...'                     *
         BCT   @8,@DO9ED                                          0126
         LA    @F,3                                               0127
         A     @F,INDEX1                                          0127
         ST    @F,INDEX1                                          0127
*
*        /*************************************************************
*        /*                                                           *
*        /* MOVE IN VARIABLE LENGTH DATA INTO SPECIAL MESSAGE AREA    *
*        /*                                                           *
*        /*************************************************************
*
*        DO INDEX=XINPUTB TO 1 BY -1; /* MOVE IN INVALID DATA         *
         LR    @8,@5                                              0128
         LTR   @8,@8                                              0128
         BC    12,@DO9E8                                          0128
*          MSGA (INDEX) = INVDATA(INDEX); /* MOVE IN VARIABLE LENGTH
*                                       INVALID DATA                  *
@DO9E9   LR    @7,@8                                              0129
         BCTR  @7,0                                               0129
         L     @9,300(0,@B)        
         LA    @E,0(@7,@9)                                        0129
         L     @9,INDEX1                                          0129
         LA    @A,0(@7,@9)                                        0129
         MVC   0(1,@A),0(@E)                                      0129
*        END;                        /* END VARIABLE LENGTH MOVE      *
*
*        /*************************************************************
*        /*                                                           *
*        /* DETERMINE IF A RIGHT PARENTHESIS MUST BE INCLUDED         *
*        /*                                                           *
*        /*************************************************************
*
*        IF RHTPAREN = '1'B THEN
         BCT   @8,@DO9E9                                          0130
@DO9E8   TM    600(@B),B'00100000'                                0131
         BC    12,@9E5                                            0131
*          MSGAREA1 (MSGLEN+XINPUTB+5) = ')';    /* MOVE IN RIGHT
*                                       PARENTHESIS                   *
         LR    @7,@5                                              0132
         AH    @7,590(0,@B)                                       0132
         BCTR  @7,0                                               0132
         L     @9,648(0,@B)        
         LA    @A,5(@7,@9)                                        0132
         MVI   0(@A),C')'                                         0132
         BC    15,@9E4                                            0133
*        ELSE
*          MSGAREA1 (MSGLEN+XINPUTB+5) = ' ';
@9E5     LR    @7,@5                                              0133
         AH    @7,590(0,@B)                                       0133
         BCTR  @7,0                                               0133
         L     @9,648(0,@B)        
         LA    @A,5(@7,@9)                                        0133
         MVI   0(@A),C' '                                         0133
*        INVPSAVE = SUBRWORK(1);     /* POINT INVPSAVE TO NEW BUFFER
*                                       SO IKJPARS WILL PICK UP
*                                       SPECIAL MESSAGE JUST BUILT    *
@9E4     MVC   300(4,@B),160(@B)                                  0134
*        PPOINTR = SUBRWORK(1);      /* SET PPOINTR = TO CORE ADDRESS
*                                       IN CASE GOING TO WRITE OUT
*                                       CLOSING PAREN ASSUMED MSAGE   *
         MVC   148(4,@B),160(@B)                                  0135
*        XINPUTB = SUBRWORK(1) + MSGLEN + /* POINT XINPUTB TO END FOR *
*              XINPUTB + 5;          /* SAME REASON - SO LENGTH WILL
*                                       BE FOR SPECIAL MESSAGE        *
         LA    @F,5                                               0136
         AR    @F,@5                                              0136
         AH    @F,590(0,@B)                                       0136
         A     @F,160(0,@B)                                       0136
         LR    @5,@F                                              0136
*      END;
*    R15 = 4;                        /* LOAD SUBROUTINE ADDRESS FOR
*                                       WRITING INVALID MESSAGE       *
@9F4     LA    @F,4                                               0138
*    CALL LINKRET;                   /* CALL INTERFACE ROUTINE        *
         BAL   @E,LINKRET                                         0139
*    IF SPECMSG = '1'B THEN          /* WAS A SPECIAL MESSAGE         *
         TM    600(@B),B'10000000'                                0140
         BC    12,@9E3                                            0140
*      DO;                           /* WRITTEN                       *
*        RESPECIFY
*              R1 RESTRICTED;        /* IF SO, MUST FREE CORE - NEED
*                                       REG1                          *
*
*        /*************************************************************
*        /*                                                           *
*        /* ISSUE FREEMAIN FOR CORE IN WHICH BUILT SPECIAL MESSAGE    *
*        /*                                                           *
*        /*************************************************************
*
*
* FREE:
*        GENERATE;
FREE     EQU   *                                                  0143
     USING   PWORK,PWAREG              ADDRESSABILITY TO PWORK
     L   R1,COREADDR                   RESTORE ADDRESS OF CORE
     LH  R0,CORELEN                    LOAD LENGTH INTO R0
     DROP   PWAREG                     FREE BASE REG FOR WORKAREA
     FREEMAIN R,LV=(0),A=(1)           FREE THE CORE
         DS    0H
*        RESPECIFY
*              R1 UNRESTRICTED;      /* RELEASE REGISTER 1            *
*      END;
*    LFTPAREN = '0'B;                /* TURN SPECIAL MESSAGE AND      *
@9E3     NI    600(@B),B'00011111'                                0146
*    RHTPAREN = '0'B;                /* FORMAT INDICATORS             *
*    SPECMSG = '0'B;                 /* OFF                           *
*    R14 = PLINKSV2;                 /* RESTORE RETURN REGISTER       *
         L     @E,672(0,@B)                                       0149
*    RETURN;                         /* MACRO PROCESSORS AND RETURN   *
*    END MSGSETUP;                   /* END MSGSET UP PROCEDURE       *
@EL03    BCR   15,@E                                              0151
*
*    /*****************************************************************
*    /*                                                               *
*    /* IKJOPER MACRO PROCESSING                                      *
*    /*                                                               *
*    /*****************************************************************
*
*
* IKJEFP50:                          /* ENTRY POINT                   *
*    PROC OPTIONS(NOSAVEAREA,        /* NO STANDARD LINKAGE           *
*          DONTSAVE);                /* NO STANDARD LINKAGE           *
IKJEFP50 EQU   *                                                  0152
*
*    /*****************************************************************
*    /*                                                               *
*    /* REGISTER DECLARES AND RESTRICTIONS                            *
*    /*                                                               *
*    /*****************************************************************
*
*    DCL
*          R4 REG(4) PTR(31);        /* REGISTER 4                    *
*    DCL
*          R5 REG(5) PTR(31);        /* REGISTER 5                    *
*    DCL
*          R6 REG(6) PTR(31);        /* REGISTER 6                    *
*    DCL
*          R8 REG(8) PTR(31);        /* REGISTER 8                    *
*    DCL
*          R9 REG(9) PTR(31);        /* REGISTER 9                    *
*    DCL
*          R11 REG(11) PTR(31);      /* REGISTER 11                   *
*    RESTRICT (R4,R5,R6);            /* KEEP SCAN PTRS INTACT         *
*    RESTRICT (PWAREG);              /* KEEP WORKAREA REFERENCE       *
*    RESTRICT (R8);                  /* COUNTER                       *
*
*    /*****************************************************************
*    /*                                                               *
*    /* DATA VARIABLES                                                *
*    /*                                                               *
*    /*****************************************************************
*
*    DCL
*          COMBUF CHAR(1) BASED(R4);     /* CHARACTER IN THE COMMAND
*                                       BUFFER POINTED TO BY XINPUT   *
*    DCL
*          COMBUFBV CHAR(256) BASED(R5);      /* CHARACTERS IN THE
*                                       COMMAND BUFFER POINTED TO BY
*                                       XINPUT                        *
*    DCL
*          COMBUFP CHAR(256) BASED(PPOINTR); /* CHARACTER IN THE
*                                       COMMAND BUFFER POINTED TO BY
*                                       PPOINTR                       *
*    DCL
*          COMBUFB CHAR(1) BASED (R5);      /* CHARACTER IN THE
*                                       COMMAND BUFFER POINTED TO BY
*                                       XINPUTB                       *
*    DCL
*          BLNK STATIC INTERNAL CHAR(1) INIT(' '); /* BLANK           *
*    DCL
*          P40PR LABEL LOCAL INTERNAL; /* RETURN AFTER PROMPTING      *
*    DCL
*          P50PR LABEL LOCAL INTERNAL; /* RETURN AFTER PROMPTING      *
*    DCL
*          IP LABEL LOCAL INTERNAL;  /* OPER INVALID MSG SET UP       *
*
*    /*****************************************************************
*    /*                                                               *
*    /* THE SAME PDE MAP IS USED TO REFERENCE ALL FOUR TYPES OF       *
*    /* IKJTERM PDE'S -CONSTANT,STATEMENT NUMBER,VARIBLE, AND PDE'S   *
*    /* FOR DATA NAME QUALIFIERS.                                     *
*    /*                                                               *
*    /*****************************************************************
*
*    DCL
*          1 PDEMPT BASED(PDEPTR),   /* MAP OF PDE                    *
*            2 DNAMEPTR PTR(31),     /* PTR TO DATA NAME              *
*              3 LNGTH1 PTR(8),      /* LENGTH OF DIGITS OR PGM.ID    *
*              3 LNGTH2 PTR(8),      /* LENGTH OF EXPONENT OR LINE#   *
*              3 LNGTH3 PTR(8),      /* LENGTH OF VERB NO.            *
*              3 RESVA CHAR(1),      /* RESERVE BYTE                  *
*            2 RESWDNUM PTR(15),     /* NUMBER OF RESERVE WORDS       *
*              3 LNGTH4 PTR(8),      /* LENGTH OF DATA NAME           *
*              3 RESV2 CHAR(1),      /* RESERVE BYTE                  *
*            2 FLAG1 BIT(8),         /* TYPE INDICATOR                *
*              3 PARMIND BIT(1),     /* PARAMETER PRESENT             *
*              3 CONST BIT(1),       /* TYPE EQUAL CONSTANT           *
*              3 VARIA BIT(1),       /* TYPE EQUAL VARIABLE           *
*              3 STATE BIT(1),       /* TYPE EQUAL STATEMENT NO.      *
*              3 FIXED BIT(1),       /* FIXED PTR. NUMERIC LITERAL    *
*              3 NONNUM BIT(1),      /* NON-NUMERIC LITERAL           *
*              3 FIGUR BIT(1),       /* FIGURATIVE CONSTANT           *
*              3 FLOAT BIT(1),       /* FLOATING PT.NUMERIC LITERAL   *
*            2 FLAG2 BIT(8),         /* SIGN INDICATOR                *
*              3 SIGN BIT(1),        /* SIGN IS PLUS OR MINUS         *
*              3 EXPSIGN BIT(1),     /* SIGN ON EXPONENT IS (+)OR(-)  *
*              3 DECPT BIT(1),       /* DECIMAL PTR INDICATOR         *
*              3 RESV3 BIT(5),       /* RESERVE BITS                  *
*            2 DATAPTRH PTR(32),     /* SPACE FOR LAST INDICATOR      *
*              3 DATAPTR PTR(31),    /* PTR TO STRING OF DIGITS OR PTR
*                                       TO PGM.ID OR PTR TO PDE FOR
*                                       NXT QUALIFIER                 *
*            2 DATAPTRA PTR(31),     /* PTR TO EXPONENT OR PTR TO LINE
*                                       NUMBER OR PTR TO PGM.ID NAME  *
*            2 DATAPTRB PTR(31),     /* PTR TO PERIOD OR PTR TO VERB
*                                       NUMBER                        *
*              3 LNGTH5 PTR(8),      /* LENGTH OF PGM.ID (VAR PDE)    *
*              3 NUMQUAL CHAR(1),    /* NUMBER OF QUALIFIERS-VAR PDE  *
*              3 NUMSUB CHAR(1),     /* NUMBER OF SUBCRIPTS-VAR PDE   *
*              3 RESV4 CHAR(1);      /* RESERVE BYTE (VAR PDE)        *
*
*    /*****************************************************************
*    /*                                                               *
*    /* IKJTERM PCE MAPPING                                           *
*    /*                                                               *
*    /*****************************************************************
*
*    DCL
*          1 PCEMPT BASED(R6),       /* MAP OF PCE                    *
*            2 PCEFLG1 BIT(16),      /* MESSAGE INDICATOR             *
*              3 TERPCE BIT(3),      /* IKJTERM PCE                   *
*              3 PROMPT BIT(1),      /* PROMPT SPECIFIED              *
*              3 DEFAULT BIT(1),     /* DEFAULT SPECIFIED             *
*              3 RESERV1 BIT(1),     /* RESERVE BIT                   *
*              3 HELP BIT(1),        /* HELP MESSAGE PROVIDED         *
*              3 VALCHK BIT(1),      /* VALIDITY CHECK EXIT           *
*              3 LIST BIT(1),        /* LIST SPECIFIED                *
*              3 ASIS BIT(1),        /* ASIS SPECIFIED                *
*              3 RANG BIT(1),        /* RANGE SPECIFIED               *
*              3 SUBSCRP BIT(1),     /* TERM MAY BE SUBSCRIPTED       *
*              3 RESVCHA BIT(1),     /* RESERVE WORD PCE CHAINED      *
*              3 RESERV2 BIT(3),     /* RESERVE BIT                   *
*            2 PCELNGTH CHAR(2),     /* HEX LENGTH OF THIS PCE        *
*            2 PDEOFST CHAR(2),      /* OFFSET IN PDL FOR PDE         *
*            2 PCEFLG2 BIT(8),       /* PCE TYPE OPERAND              *
*              3 STMT BIT(1),        /* TYPE EQUAL STATEMENT          *
*              3 VAR BIT(1),         /* TYPE EQUAL VARIBLE            *
*              3 CNST BIT(1),        /* TYPE EQUAL CONSTANT           *
*              3 ANY BIT(1),         /* TYPE EQUAL ANY                *
*              3 SUBSCPPT BIT(1),    /* TERM DESCRIBING A SUBSCRIPT   *
*              3 RESERV3 BIT(3),     /* RESERVE BITS                  *
*            2 TPTSL PTR(15) BDY(BYTE); /* LENGTH OF THE PARAMETER
*                                       TYPE SEGMENT                  *
*
*    /*****************************************************************
*    /*                                                               *
*    /* MAP THE SECOND FIXED FIELD IN THE IKJTERM PCE                 *
*    /*                                                               *
*    /*****************************************************************
*
*    DCL
*          TPODL BIT(8) BASED(R6);   /* LENGTH OF PROMPT DEFAULT
*                                       SEGMENT IN TERM PCE           *
*
*    /*****************************************************************
*    /*                                                               *
*    /* MAP THE THIRD FIXED FIELD IN THE IKJTERM PCE                  *
*    /*                                                               *
*    /*****************************************************************
*
*    DCL
*          RSVWDIDX FIXED(15) BASED(R6)   /* OFFSET TO CHAINED        *
*                BDY(BYTE);          /* RSVWD FROM TOP OF PDL         *
*
*    /*****************************************************************
*    /*                                                               *
*    /* IKJNAME PCE MAPPING                                           *
*    /*                                                               *
*    /*****************************************************************
*
*    DCL
*          1 NPCE1 BASED(R6) BDY(BYTE),   /* IKJNAME PCE              *
*            2 NPCE BIT(16),         /* MASK AND FLAG DATA AREA       *
*              3 NPCEMASK BIT(3),    /* MASK INDICATING TYPE PCE      *
*              3 * BIT(13),          /* NOT REFERENCED                *
*            2 NPCELNTH FIXED(15),   /* LENGTH OF PCE                 *
*            2 NAMELM1 PTR(8),       /* LENGTH OF NAME DATA -1        *
*            2 NAMEDATA CHAR(256);   /* FIRST CHAR OF NAME            *
*
*    /*****************************************************************
*    /*                                                               *
*    /* IKJRSVWD PCE MAPPING                                          *
*    /*                                                               *
*    /*****************************************************************
*
*    DCL
*          1 RPCEFLD BASED(R6)BDY(BYTE),   /* MAP RSVWD PCE           *
*            2 RPCEBYT1 BIT (16),    /* FIRST BYTE OF INDICATORS      *
*              3 RSVWMASK BIT(3),    /* INDICATES PCE TYPE            *
*              3 RPRMTI BIT(1),      /* PROMPT DATA SUPPLIED          *
*              3 RDFLTI BIT(1),      /* DEFAULT DATA SUPPLIED         *
*              3 * BIT(3),           /* NOT REFERENCED                *
*              3 RFCONST BIT(1),     /* FIGURATIVE CONSTANT IF ON     *
*              3 * BIT(7),           /* NOT REFERENCED                *
*            2 RPCELNTH FIXED(15),   /* RSVWD PCE LENGTH              *
*            2 RPDEINDX FIXED(15);   /* OFFSET TO RSVWD PDE FROM START
*                                       OF PDL                        *
*
*    /*****************************************************************
*    /*                                                               *
*    /* SAVE AREA FOR SPECIAL MESSAGE DATA --- THIS INFORMATION IS    *
*    /* USED TO PROMPT FOR AN EXPRESSION                              *
*    /*                                                               *
*    /*****************************************************************
*
*    DCL
*          1 OPERSPM AUTOMATIC,      /* MSGAREA SAVE                  *
*            2 OPERSPM1 FIXED(15),   /* SAVE TERM1 WORD1 LENGTH       *
*            2 OPERSPM2 FIXED(31);   /* SAVE ADDR TERM1 WORD1         *
*
*    /*****************************************************************
*    /*                                                               *
*    /* IKJOPER PDE AND IKJRSVWD PDE MAPPING                          *
*    /*                                                               *
*    /*****************************************************************
*
*    DCL
*          1 ORPDE BASED(ADDR(TEMPPDE)) BDY(BYTE), /* MAP OPER & RSVWD
*                                       PDE                           *
*            2 * CHAR(2),
*            2 RNAMENUM FIXED (15),  /* IKJNAME NUMBER                *
*            2 * CHAR(2),
*            2 ORPDEFLG BIT(8),      /* FLAG DATA                     *
*              3 ORFND BIT(1),       /* INDICATES THAT THE DATA
*                                       DESCRIBED BY THE PCE WAS FOUND*
*              3 ORPDERD2 BIT(7),    /* RESERVED FLAG AREA            *
*            2 ORPDERD3 CHAR(1);     /* RESERVED DATA AREA            *
*
*    /*****************************************************************
*    /*                                                               *
*    /* INITIATE IKJOPER MACRO PROCESSING                             *
*    /*                                                               *
*    /*****************************************************************
*
*    COBOLMOD = '1'B;                /* INDICATE THAT A COBOL SCAN IS
*                                       IN PROGRESS                   *
         OI    599(@B),B'11000000'                                0178
*    OPERMODE = '1'B;                /* INDICATE THAT A SCAN OF AN
*                                       EXPRESSION IS IN PROGRESS     *
*    OPERPRMT = '0'B;                /* TURN OFF INDICATOR FOR
*                                       EXPRESSION PROMPT RETURN
*                                       PROCESSING                    *
         NI    599(@B),B'11111101'                                0180
*    OANC = AANC;                    /* SAVE PTR TO TERM QUALIFIER PDE
*                                       CORE ON ENTRY - THE PTR WILL
*                                       BE RESET TO THIS VALUE IF THE
*                                       ENTIRE EXPRESSION IS FOUND TO
*                                       BE INVALID                    *
         MVC   576(4,@B),568(@B)                                  0181
*    OPERPCE = R6;                   /* SAVE PTR TO IKJOPER PCE       *
         ST    @6,532(0,@B)                                       0182
*    RESPECIFY
*         (R7,
*          R9) RESTRICTED;           /* KEEP TEMP WORKAREA            *
*    OPCEPTR = R6 + OPCEPTL + 6;     /* ESTABLISH ADDRESSABILITY FOR
*                                       THE OPCEFLD2 DSECT THAT MAPS
*                                       THE SECOND FIXED DATA AREA IN
*                                       THE OPER PCE                  *
         LA    @F,6                                               0184
         L     @1,532(0,@B)        
         MVC   @TEMP2+2(2),6(@1)                                  0184
         LH    @0,@TEMP2+2                                        0184
         AR    @F,@0                                              0184
         AR    @F,@6                                              0184
         ST    @F,OPCEPTR                                         0184
*    R7 = PTABLEAD;                  /* SET UP PTR TO TOP OF PCL      *
         L     @7,324(0,@B)                                       0185
*    R9 = R6;                        /* SAVE PCE PTR FOR 'OTERMCK'    *
         LR    @9,@6                                              0186
*    R6 = R7 + T1PCEIDX;             /* PLACE TERM1 PCE ADDR INXPCE   *
         LR    @1,@F                                              0187
         MVC   @TEMP2+2(2),2(@1)                                  0187
         LH    @6,@TEMP2+2                                        0187
         AR    @6,@7                                              0187
*    CALL TERMOCK;                   /* TERMINATE THE SCAN IF THE
*                                       FORMAT OF THE MINOR TERM PCE
*                                       IS INCORRECT                  *
         L     @F,@V1              ADDRESS OF TERMOCK             0188
         BALR  @E,@F                                              0188
*    R6 = R7 + RPCEINDX;             /* PLACE RSVWD PCE ADR IN XPCE   *
         L     @1,OPCEPTR                                         0189
         MVC   @TEMP2+2(2),0(@1)                                  0189
         LH    @6,@TEMP2+2                                        0189
         AR    @6,@7                                              0189
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF THE MINOR RSVWD PCE ADDRESS DOES NOT REFERENCE A RSVWD PCE *
*    /* THE SCAN IS TERMINATED                                        *
*    /*                                                               *
*    /*****************************************************************
*
*    IF RSVWMASK ^= '101'B           /* COMPARE THE RSVWD PCE TYPE    *
*      THEN
         TM    0(@6),B'10100000'                                  0190
         BC    12,@9E2                                            0189
         TM    0(@6),B'01000000'                                  0190
         BC    08,@9E1                                            0190
*      GOTO RTNCLNUP;                /* MASK TO THE PCE               *
         BC    15,RTNCLNUP                                        0191
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF THE FIGURATIVE CONSTANT INDICATOR BIT IS ON IN THE RSVWD   *
*    /* PCE DESCRIBING AN OPERATOR THE SCAN IS TERMINATED             *
*    /*                                                               *
*    /*****************************************************************
*
*      THEN
@9E1     TM    1(@6),B'10000000'                                  0192
*      GOTO RTNCLNUP;                /* BIT IS ON GOTO 'CLEANUP'      *
         BC    01,RTNCLNUP                                        0193
*
*    /*****************************************************************
*    /*                                                               *
*    /* THE RSVWD PCE ADDRESS MUST BE GREATER THAN THE FIRST OPERAND  *
*    /* ADDRESS.  THE FIRST OPERAND ADDRESS IS PLACED IN PRIOPPCE BY  *
*    /* TERMOCK.                                                      *
*    /*                                                               *
*    /*****************************************************************
*
*    IF R6 ^> R9                     /* IF XPCE NOT GREATER           *
*      THEN
         CR    @6,@9                                              0194
*      GOTO RTNCLNUP;                /* GOTO CLEANUP                  *
         BC    12,RTNCLNUP                                        0195
*    R9 = R6;                        /* PRIORPCE = ADDR RSVWD PCE     *
         LR    @9,@6                                              0196
*    R6 = R7 + T2PCEIDX;             /* PLACE TERM2 PCE ADR IN XPCE   *
         L     @1,OPCEPTR                                         0197
         MVC   @TEMP2+2(2),4(@1)                                  0197
         LH    @6,@TEMP2+2                                        0197
         AR    @6,@7                                              0197
*    CALL TERMOCK;                   /* TERMINATE THE SCAN IF THE
*                                       FORMAT OF THE MINOR TERM PCE
*                                       IS INCORRECT                  *
         L     @F,@V1              ADDRESS OF TERMOCK             0198
         BALR  @E,@F                                              0198
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF THERE IS A THIRD TERM PCE, TEST IT WITH TERMOCK            *
*    /*                                                               *
*    /*****************************************************************
*
*    IF T3PCEIDX ^= 0                /* IF THE TERM3 ADDRESS          *
*      THEN                          /* IN THE OPER PCE IS NOT        *
         SR    @F,@F                                              0199
         L     @1,OPCEPTR                                         0199
         MVC   @TEMP2+2(2),6(@1)                                  0199
         LH    @0,@TEMP2+2                                        0199
         CR    @F,@0                                              0199
         BC    08,@9E0                                            0199
*      DO;                           /* SET TO ZEROS,                 *
*                                    /* THERE IS AN OPTIONAL THIRD    *
*                                    /* TERM UNDER THE OPER PCE       *
*        R6 = R7 + T3PCEIDX;         /* XPCE = TERM3 PCE ADDR         *
         MVC   @TEMP2+2(2),6(@1)                                  0201
         LH    @6,@TEMP2+2                                        0201
         AR    @6,@7                                              0201
*        CALL TERMOCK;               /* TEST MINOR TERM PCE           *
         L     @F,@V1              ADDRESS OF TERMOCK             0202
         BALR  @E,@F                                              0202
*      END;
*    RESPECIFY
*         (R8) RESTRICTED;           /* RESTRICT TERMPORARY INDEX     *
*
*    /*****************************************************************
*    /*                                                               *
*    /* CALCULATE THE LENGTH OF THE LAST MINOR TERM PDE               *
*    /*                                                               *
*    /*****************************************************************
*
*    IF SUBSCRP = '1'B               /* IF PCE IS SUBSCRIPTABLE       *
*      THEN                          /* THEN SET I EQUAL TO           *
@9E0     TM    1(@6),B'00010000'                                  0205
         BC    12,@9DF                                            0205
*      DO;                           /* THE LENGTH OF A               *
*        R8 = 80;                    /* SUBSCRIPT PDE                 *
         LA    @8,80                                              0207
*        R9 = R9 + PCELNGTH;             /* UPDATE TO NEXT PCE        *
         MVC   @TEMP2+2(2),2(@6)                                  0208
         A     @9,@TEMP2                                          0208
*
*        /*************************************************************
*        /*                                                           *
*        /* THE PCE FOLLOWING A SUBSCRIPTABLE TERM MUST BE A TERM     *
*        /* PCE.                                                      *
*        /*                                                           *
*        /*************************************************************
*
*        IF R9 -> TERPCE ^= '110'B THEN         /* IS THE             *
         TM    0(@9),B'11000000'                                  0209
         BC    12,@9DE                                            0208
         TM    0(@9),B'00100000'                                  0209
         BC    08,@9DD                                            0209
*          GOTO RTNCLNUP;            /* PCE A TERM PCE                *
         BC    15,RTNCLNUP                                        0210
*
*        /*************************************************************
*        /*                                                           *
*        /* THE SUBSCRIPT TERM MUST HAVE THE SUBSCRIPT OPTION CODED   *
*        /*                                                           *
*        /*************************************************************
*
*        IF R9 -> SUBSCPPT = '0'B THEN       /* ISSUE  RETURN CODE
@9DD     TM    6(@9),B'00001000'                                  0211
*          GOTO RTNCLNUP;            /* AND TERMINATE SCAN IF 0       *
         BC    08,RTNCLNUP                                        0212
         BC    15,@9DC                                            0214
*      END;
*    ELSE
*      R8 = 20;                      /* SET I EQUAL LENGTH NON-
*                                       SUBSCRIPT PCE                 *
@9DF     LA    @8,20                                              0214
*    RESPECIFY
*         (R7) UNRESTRICTED;         /* FREE TEMP PTRS                *
@9DC     EQU   *                                                  0215
*
*    /*****************************************************************
*    /*                                                               *
*    /* CALCULATE THE LENGTH OF THE PDE STRUCTURE UNDER THE IKJOPER   *
*    /* PCE                                                           *
*    /*                                                               *
*    /*****************************************************************
*
*    RESPECIFY
*         (R7) RESTRICTED;           /* SET UP NEW TEMP AREA          *
*    R7 = PDEOFST + XPDL + R8;       /* PLACE END ADDR OF LAST TERM
*                                       PDE IN ENDTPDE                *
         LR    @7,@8                                              0217
         A     @7,168(0,@B)                                       0217
         MVC   @TEMP2+2(2),4(@6)                                  0217
         A     @7,@TEMP2                                          0217
*    OPERLL = R7 -(XPDL + OPDEINDX);      /* PLACE THE PDE STRUCTURE
*                                       LENGTH IN OPERLL              *
         L     @1,532(0,@B)        
         MVC   @TEMP2+2(2),4(@1)                                  0218
         LH    @F,@TEMP2+2                                        0218
         A     @F,168(0,@B)                                       0218
         LCR   @F,@F                                              0218
         AR    @F,@7                                              0218
         STH   @F,588(0,@B)                                       0218
*    OPEREND = R9;                   /* SAVE THE ADDR OF LAST MINOR
*                                       TERM PCE                      *
         ST    @9,520(0,@B)                                       0219
*    RESPECIFY
*         (R7,
*          R9) UNRESTRICTED;         /* RELEASE PTRS                  *
*    R15 = 5;                        /* PLACE THE ADDRESS OF THE      *
         LA    @F,5                                               0221
*                                    /* SKIPB ROUTINE IN LINKB        *
*
*    /*****************************************************************
*    /*                                                               *
*    /* SKIP OVER ANY SEPARATOR IN THE INPUT LINE VIA SKIPB RTN       *
*    /*                                                               *
*    /*****************************************************************
*
*    CALL LINKRET;                   /* PASS CONTROL TO SKIPB         *
         BAL   @E,LINKRET                                         0222
*    GOTO D1;                        /* SKIPB RETURN +0 - END OF      *
         BC    15,D1                                              0223
*                                    /* INPUT ENCOUNTERED --          *
*                                    /* PROMPT FOR MISSING VIA        *
*                                    /* 'PROMPTQ' ROUTINE             *
*
* PR:
*
*    /*****************************************************************
*    /*                                                               *
*    /* RECEIVE CONTROL AFTER DATA IS RETURNED FROM THE PROMPT FOR AN *
*    /* EXPRESSION                                                    *
*    /*                                                               *
*    /*****************************************************************
*
*    OPERSVE = R5;                   /* SKIPB RETURN +4 -             *
PR       ST    @5,536(0,@B)                                       0224
*                                    /* SAVE PTR TO START OF DATA     *
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF A LEFT PAREN IS NOT THE FIRST CHARACTER POINTED TO BY      *
*    /* XINPUT, PROCESS THE ENTRY AS A CHAINED TERM                   *
*    /*                                                               *
*    /*****************************************************************
*
*    IF COMBUFB ^= '('               /* IF THE CHARACTER POINTED      *
*      THEN                          /* TO BY XINPUTB IS NOT A        *
         CLI   0(@5),C'('                                         0225
         BC    08,@9DB                                            0225
*      DO;                           /* LEFT PARENTHESIS...           *
*        IF COMBUFB = ';' THEN       /* IF XINPUTB POINTS TO A        *
         CLI   0(@5),C';'                                         0227
*          GOTO I1;                  /* SEMICOLON, THE EXPRESSION     *
         BC    08,I1                                              0228
*                                    /* IS MISSING                    *
*        GOTO OPTTERM;               /* ELSE, PROCESS CHAINED TERM    *
         BC    15,OPTTERM                                         0229
*      END;
*
*    /*****************************************************************
*    /*                                                               *
*    /* THIS SECTION OF CODE CONTROLS THE SCAN OF THE INDIVIDUAL      *
*    /* ELEMENTS OF AN EXPRESSION                                     *
*    /*                                                               *
*    /*****************************************************************
*
*    R4 = R4 + 1;                    /* UP THE INPUT LINE PTR BY 1    *
@9DB     AH    @4,@D2                                             0231
*    CHAINTRM = '0'B;                /* TURN OF CHAINED TERM SWITCH   *
         NI    600(@B),B'11101111'                                0232
*    R6 = T1PCEIDX + PTABLEAD;       /* PLACE THE ADDRESS OF THE TERM1
*                                       PCE IN XPCE                   *
         L     @6,324(0,@B)                                       0233
         L     @1,OPCEPTR                                         0233
         MVC   @TEMP2+2(2),2(@1)                                  0233
         LH    @0,@TEMP2+2                                        0233
         AR    @6,@0                                              0233
*    CALL IKJEFP60;                  /* CALL THE TERM SCAN ROUTINE    *
         L     @F,@V2              ADDRESS OF IKJEFP60            0234
         BALR  @E,@F                                              0234
*    GOTO F1;                        /* ON +O RETURN PROMPT WITH
*                                       INVALID EXPRESSION MSG        *
         BC    15,F1                                              0235
*    OPERSPM1 = MSGLEN;              /* ON +4 RETURN SAVE THE TERM1   *
         MVC   OPERSPM(2),590(@B)                                 0236
*    OPERSPM2 = MSGADDR;             /* SPECIAL MSG DATA              *
         MVC   OPERSPM+4(4),592(@B)                               0237
*    PFNOPOP='0'B;                   /* ALLOW BUFFER POP        M0000 *
         NI    179(@B),B'11111101'                                0238
*    R6 = RPCEINDX + PTABLEAD;       /* XPCE = ADDR RSVWD PCE         *
         L     @6,324(0,@B)                                       0239
         L     @1,OPCEPTR                                         0239
         MVC   @TEMP2+2(2),0(@1)                                  0239
         LH    @0,@TEMP2+2                                        0239
         AR    @6,@0                                              0239
*    CALL IKJEFP40;                  /* CALL THE RSVWD SCAN RTN       *
         L     @F,@V3              ADDRESS OF IKJEFP40            0240
         BALR  @E,@F                                              0240
*    GOTO OSPMSG;                    /* ON +0 RETURN PROMPT WITH
*                                       INVALID EXPRESSION MSG        *
         BC    15,OSPMSG                                          0241
*    R6 = T2PCEIDX + PTABLEAD;       /* ON +4 RETURN PLACE THE ADDR OF
*                                       THE TERM2 PCE IN XPCE         *
         L     @6,324(0,@B)                                       0242
         L     @1,OPCEPTR                                         0242
         MVC   @TEMP2+2(2),4(@1)                                  0242
         LH    @0,@TEMP2+2                                        0242
         AR    @6,@0                                              0242
*    PFNOPOP = '0'B;                 /* ALLOW BUFFER TO BE POPED      *
         NI    179(@B),B'11111101'                                0243
*    R15 = 5;                        /* SKIP TO NEXT BUFFER IF AT THE
*                                       END OF A BUFFER               *
         LA    @F,5                                               0244
*    CALL LINKRET;                   /* GOTO PARS2                    *
         BAL   @E,LINKRET                                         0245
*    GEN (NOP  0);                   /* GOTO IKJEFP60 ON +0 & +4      *
         NOP  0
         DS    0H
*    CALL IKJEFP60;                  /* CALL THE TERM SCAN ROUTINE    *
         L     @F,@V2              ADDRESS OF IKJEFP60            0247
         BALR  @E,@F                                              0247
*    GOTO OSPMSG;                    /* ON +0 RETURN PROMPT WITH
*                                       INVALID EXPRESSION MSG        *
         BC    15,OSPMSG                                          0248
*    IF PFENDSET ='1'B               /* PFENDSET IS ON IF TERM        *
*      THEN                          /* POPPED TO LOWER BUFFER        *
         TM    179(@B),B'00000100'                                0249
         BC    12,@9DA                                            0249
*      DO;                           /* IF SO , SET OPERSVE =         *
*        OPERSVE = ENDBAKUP;         /* END OF BUFFER POPPED OFF      *
         MVC   536(4,@B),412(@B)                                  0251
*        GOTO SK;                    /* GO TO SKIP BLANKS       M4161 *
         BC    15,SK                                              0252
*      END;                          /* ROUTINE                 M4161 *
*    IF PFNOPOP = '1'B               /* PFENDSET NOT, ON CHECK  M4161 *
*      THEN                          /* PFNOPOP.  IF ON,        M4161 *
@9DA     TM    179(@B),B'00000010'                                0254
         BC    12,@9D9                                            0254
*      DO;                           /* SUBSCRIPT WAS PROCESSED M4161 *
*        OPERSVE=R4;                 /* SET BAKUP POINTER TO R4 M4161 *
         ST    @4,536(0,@B)                                       0256
*        PFNOPOP='0'B;               /* RESET PFNOPOP, SO WILL  M4161
*                                       POP TO LOWER  BUFFERS   M4161 *
         NI    179(@B),B'11111101'                                0257
         BC    15,@9D8                                            0259
*      END;                          /* END, PFNOPOP PROCESS    M4161 *
*    ELSE
*      OPERSVE = R4 +1;              /* THAT DID NOT CONTAIN PART     *
@9D9     LA    @F,1                                               0259
         AR    @F,@4                                              0259
         ST    @F,536(0,@B)                                       0259
*                                    /* OF A VARIABLE                 *
* SK: R15 = 5;                       /* LOAD ADDR SKIPB SUBROUTINE    *
@9D8     EQU   *                                                  0260
SK       LA    @F,5                                               0260
*    CALL LINKRET;                   /* GOTO SKIPB TO SKIP OVER
*                                       SEPARATORS BEFORE RHT PAREN   *
         BAL   @E,LINKRET                                         0261
*    GOTO A;                         /* ON +0 RETURN -E0F- GOTO A     *
         BC    15,A                                               0262
*
*    /*****************************************************************
*    /*                                                               *
*    /* TEST FOR A CLOSING RIGHT PARENTHESIS                          *
*    /*                                                               *
*    /*****************************************************************
*
*    IF COMBUFB ^= ')' THEN          /* ISSUE CLOSING PAREN ASSUMED   *
         CLI   0(@5),C')'                                         0263
*      GOTO A;                       /* MESSAGE IF NO RIGHT PAREN     *
         BC    07,A                                               0264
*    INVPSAVE = PRMTPTR;             /* SAVE PTR TO THE LAST WORD OF
*                                       OPERAND2 FOR VALIDITY CHECK
*                                       FAILURE PROMPTING             *
         MVC   300(4,@B),584(@B)                                  0265
*    R4 = R5;                        /* UPDATE XINPUT TO THE RIGHT
*                                       PAREN                         *
         LR    @4,@5                                              0266
*    GOTO B;                         /* PREPARE TO ADD PDE            *
         BC    15,B                                               0267
*
*    /*****************************************************************
*    /*                                                               *
*    /* THE OPTTERM SECTION OF CODE RECEIVES CONTROL WHEN THE DATA    *
*    /* REFERENCED BY THE INPUT LINE POINTER, XINPUT, DOES NOT START  *
*    /* WITH A RIGHT PARENTHESIS ON ENTRY, OR AFTER A PROMPT REPLY    *
*    /*                                                               *
*    /*****************************************************************
*
*
* OPTTERM:                           /* CHAINED TERM PROCESSING       *
*
*    /*****************************************************************
*    /*                                                               *
*    /* DETERMINE IF THE CHAIN OPTION IS CODED ON THE OPER MACRO      *
*    /*                                                               *
*    /*****************************************************************
*
*    IF T3PCEIDX = 0                 /* IF THE INDEX TO THE CHAINED   *
*      THEN                          /* TERM PCE IS ZERO THEN THE     *
OPTTERM  SR    @F,@F                                              0268
         L     @1,OPCEPTR                                         0268
         MVC   @TEMP2+2(2),6(@1)                                  0268
         LH    @0,@TEMP2+2                                        0268
         CR    @F,@0                                              0268
*      DO;                           /* DATA IN THE INPUT LINE        *
*        GOTO I1;                    /* MUST BE IN PARENTHESIS        *
         BC    08,I1                                              0270
*      END;                          /* BEFORE IT CAN BE PROCESSED    *
*                                    /* UNDER AN OPER PCE             *
*    R6 = PTABLEAD + T3PCEIDX;       /* PLACE THE ADDRESS OF THE
*                                       CHAINED TERM PCE IN XPCE      *
@9D7     L     @1,OPCEPTR                                         0272
         MVC   @TEMP2+2(2),6(@1)                                  0272
         LH    @6,@TEMP2+2                                        0272
         A     @6,324(0,@B)                                       0272
*    CHAINTRM = '1'B;                /* TURN ON CHAINED TERM
*                                       PROCESSING INDICATOR BIT      *
         OI    600(@B),B'00010000'                                0273
*    CALL IKJEFP60;                  /* SCAN THE INPUT LINE           *
         L     @F,@V2              ADDRESS OF IKJEFP60            0274
         BALR  @E,@F                                              0274
*
*    /*****************************************************************
*    /*                                                               *
*    /* RETURN ON +0 IF THE TERM PROCESSOR DID NOT SCAN A VALID TERM -*
*    /* RETURN ON +4 IF A VALID TERM WAS FOUND                        *
*    /*                                                               *
*    /*****************************************************************
*
*    GEN;
         BC     15,D1                   /* TERM +0 RETURN            */
         BC     15,B                    /* TERM +4 RETURN            */
         DS    0H
*
*    /*****************************************************************
*    /*                                                               *
*    /* THIS SECTION OF CODE RECEIVES CONTROL WHEN THE FIRST CHARACTER*
*    /* OF DATA IS INVALID.                                           *
*    /*                                                               *
*    /*****************************************************************
*
*
* I1:
*    IF OPERPRMT = '1'B              /* IF THE DATA WAS RETURNED      *
*      THEN                          /* IN THE PROMPT FOR AN          *
I1       TM    599(@B),B'00000010'                                0276
         BC    12,@9D6                                            0276
*      DO;                           /* EXPRESSION, THE FIRST
*                                       CHARACTER IS ALWAYS INVALID   *
*        INVPSAVE = OPERSVE;         /* POINT INVPSAVE TO THE START OF
*                                       THE INPUT LINE                *
         MVC   300(4,@B),536(@B)                                  0278
*        R4 = R5;                    /* INCREMENT TO FIRST CHARACTER  *
         LR    @4,@5                                              0279
*        R8 = 'FFFF'X;               /* NO-OP THE PAREN COUNTER
*                                       FOR THE END OF DATA SCAN      *
         L     @8,@X11                                            0280
*        GOTO A1I;                   /* GO TO THE SECTION OF CODE
*                                       WHICH SCANS TO THE END OF THE *
         BC    15,A1I                                             0281
*      END;                          /* INVALID DATA  ---
*                                       BEGIN SCAN AFTER FIRST CHAR   *
*
* D1:
*    R6 = OPERPCE;                   /* WHEN OPERPRMT IS SET TO ZERO,
*                                       POINT XPCE AT THE OPER PCE    *
@9D6     EQU   *                                                  0283
D1       L     @6,532(0,@B)                                       0283
*    R15 = 2;                        /* LOAD THE ADDRESS OF THE
*                                       PROMPTQ ROUTINE               *
         LA    @F,2                                               0284
*    CALL LINKRET;                   /* PASS CONTROL TO PROMPTQ       *
         BAL   @E,LINKRET                                         0285
*    GEN;                            /* GENERATE PROMPTQ RETURNS      *
         BC    15,P50PR                /* TEST FOR NEW DATA, +0 RTN  */
         BC    15,EP                   /* EXIT IF NO NEW DATA, +4 RTN*/
         DS    0H
*
*    /*****************************************************************
*    /*                                                               *
*    /* BUILD THE PARAMETERS NEEDED BY THE 'MSGSETUP' ROUTINE FOR     *
*    /* CONSTRUCTION OF THE SPECIAL MESSAGE.                          *
*    /*                                                               *
*    /*****************************************************************
*
*
* OVCERR:                            /* HANDLE VALIDITY CHECK ERRORS  *
*    RHTPAREN = '1'B;                /* TURN ON INDICATOR TO ADD RIGHT
*                                       PAREN TO PROMPT MSG           *
OVCERR   OI    600(@B),B'11100000'                                0287
*    LFTPAREN = '1'B;                /* ADD LEFT PAREN TO MSG         *
*    SPECMSG = '1'B;                 /* INDICATE MESSAGE TYPE         *
*    MSGLEN = OPERSPM1;              /* INDICATE TERM1 WORD1 LENGTH   *
         MVC   590(2,@B),OPERSPM                                  0290
*    MSGADDR = OPERSPM2;             /* INDICATE TERM1 WORD1 ADDR     *
         MVC   592(4,@B),OPERSPM+4                                0291
*    R4 = R4 +1;                     /* INCREMENT PAST RIGHT PAREN    *
         AH    @4,@D2                                             0292
*    GOTO WWW;                       /* SET UP FOR PROMPT             *
         BC    15,WWW                                             0293
*
*    /*****************************************************************
*    /*                                                               *
*    /* SET UP SPECIAL MESSAGE WHEN MISSING OPERAND1                  *
*    /*                                                               *
*    /*****************************************************************
*
*
* F1:
*    MSGADDR = OPERSVE;              /* SET UP PTR TO LEFT PAREN      *
F1       MVC   592(4,@B),536(@B)                                  0294
*    MSGLEN = 1;                     /* LEFT PAREN 1 CHAR LONG        *
         LA    @F,1                                               0295
         STH   @F,590(0,@B)                                       0295
*    GOTO F2;                        /* FINISH SET UP OF SPM MSG      *
         BC    15,F2                                              0296
*
* OSPMSG:                            /* SET UP SPECIAL MESSAGE WHEN
*                                       MISSING RSVWD OR OPERAND2     *
*    LFTPAREN = '1'B;                /* INSERT LEFT PAREN BEFORE
*                                       MSGAREA DATA                  *
OSPMSG   OI    600(@B),B'01000000'                                0297
*    MSGLEN = OPERSPM1;              /* MOVE PTRS TO FIRST ELEMENT    *
         MVC   590(2,@B),OPERSPM                                  0298
*    MSGADDR = OPERSPM2;             /* OF THE EXPRESSION INTO
*                                       'MSGSETUP' COMMUNICATION AREA *
         MVC   592(4,@B),OPERSPM+4                                0299
*
* F2:
*    SPECMSG = '1'B;                 /* INDICATE THAT A SPECIAL
*                                       MESSAGE FORMAT IS BEING USED  *
F2       OI    600(@B),B'10000000'                                0300
*    R15 = 5;                        /* SKIP OVER SEPARATORS          *
         LA    @F,5                                               0301
*    CALL LINKRET;                   /* GOTO PARS1                    *
         BAL   @E,LINKRET                                         0302
*    GEN (BC  15,T);                 /* GOTO T ON END OF INPUT        *
         BC  15,T
         DS    0H
*    INVPSAVE = R5;                  /* SET INVPSAVE = TO START OF
*                                       INVALID DATA ON +4 RTN        *
         ST    @5,300(0,@B)                                       0304
*    R4 = R5;                        /* SET XINPUT TO FIRST CHAR      *
         LR    @4,@5                                              0305
*    R8 = 1;                         /* INITIALIZE PAREN COUNTER TO
*                                       ONE ----- SCAN PICKS UP AFTER
*                                       THE LEFT PAREN                *
         LA    @8,1                                               0306
*
*    /*****************************************************************
*    /*                                                               *
*    /*     SCAN FOR CLOSING PAREN WHEN AN EXPRESSION IS INVALID      *
*    /*                                                               *
*    /* THE SCAN LOOP IS EXITED UNDER ONE OF THREE CIRCUMSTANCES:     *
*    /* (1) THE SCAN FINDS BALANCED LEFT & RIGHT PARENTHESIS          *
*    /* (2) THE SCAN REACHES END OF INPUT                             *
*    /* (3) A SEMICOLON IS ENCOUNTERED IN THE ORIGINAL INPUT BUFFER   *
*    /*                                                               *
*    /*****************************************************************
*
*
* R:                                 /* TEST THE CHARACTER POINTED TO
*                                       BY XINPUT FOR A RIGHT PAREN   *
*    IF COMBUF = ')'                 /* IF THE CHARACTER IN THE       *
*      THEN                          /* COMMAND BUFFER IS A           *
R        CLI   0(@4),C')'                                         0307
         BC    07,@9D5                                            0307
*      DO;                           /* RIGHT PAREN THEN              *
*        R8 = R8 - 1;                /* SUBTRACT ONE FROM THE PAREN
*                                       COUNT                         *
         BCTR  @8,0                                               0309
*
*        /*************************************************************
*        /*                                                           *
*        /* TEST THE PAREN COUNT FOR ZERO                             *
*        /*                                                           *
*        /*************************************************************
*
*        IF R8 > 0 THEN              /* A COUNT GREATER THAN ZERO     *
         LTR   @8,@8                                              0310
*          DO;                       /* MEANS THE RIGHT PAREN DOES    *
*            GOTO A1I;               /* NOT BALANCE THE OPENING       *
         BC    03,A1I                                             0312
*          END;                      /* LEFT PAREN - REPEAT LOOP      *
*        R4 = R4 + 1;                /* UP THE INPUT PTR PAST         *
@9D4     AH    @4,@D2                                             0314
*        GOTO WW;                    /* THE RIGHT PAREN & SET UP      *
         BC    15,WW                                              0315
*      END;                          /* REMAINING PARAMETERS          *
*
*    /*****************************************************************
*    /*                                                               *
*    /* TEST FOR LEFT PARENTHESIS                                     *
*    /*                                                               *
*    /*****************************************************************
*
*    IF COMBUF = '('                 /* IF XINPUT POINTS              *
*      THEN
@9D5     CLI   0(@4),C'('                                         0317
         BC    07,@9D3                                            0317
*      R8 = R8 + 1;                  /* TO A LEFT PAREN ADD 1 TO THE
*                                       PAREN COUNT                   *
         AH    @8,@D2                                             0318
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF IN THE ORIGINAL INPUT BUFFER, TREAT A SEMICOLON AS THOUGH  *
*    /* IT WERE END OF INPUT                                          *
*    /*                                                               *
*    /*****************************************************************
*
*    IF COMBUF = ';'                 /* IF A SEMICOLON IS             *
*      THEN                          /* FOUND IN THE                  *
@9D3     CLI   0(@4),C';'                                         0319
         BC    07,@9D2                                            0319
*      DO;                           /* INPUT BUFFER, END THE SCAN    *
*
*        /*************************************************************
*        /*                                                           *
*        /* TEST FOR A ZERO LENGTH INVALID DATA SEGMENT               *
*        /*                                                           *
*        /*************************************************************
*
*        IF INVPSAVE - R4 = 0
*          THEN
         LCR   @F,@4                                              0321
         A     @F,300(0,@B)                                       0321
         CH    @F,@D3                                             0321
*          GOTO T;                   /* GOTO 'T' IF SEMCOL FIRST CHAR *
         BC    08,T                                               0322
*          GOTO WW;                  /* TERMINATE INVALID DATA SCAN   *
         BC    15,WW                                              0323
*      END;
*
* A1I:
*    R4 = R4 + 1;                    /* ADD ONE TO THE INPUT PTR      *
@9D2     EQU   *                                                  0325
A1I      AH    @4,@D2                                             0325
*    IF R4 ^< ENDINPUT THEN          /* TERMINATE SCAN IF AT          *
         C     @4,144(0,@B)                                       0326
*      GOTO WW;                      /* ENDINPUT, ELSE...             *
         BC    10,WW                                              0327
*    GOTO R;                         /* CONTINUE THE PAREN SCAN       *
         BC    15,R                                               0328
*
* T:                                 /* SET UP ZERO LENGTH INVALID
*                                       DATA MESSAGE SEGMENT          *
*    BLNKFLAG = '1'B;                /* SIGNAL MSGSETUP THAT XINPUTB  *
T        OI    601(@B),B'00100000'                                0329
*                                    /* IS OUT OF BUFFER ON PURPOSE   *
*    INVPSAVE = ADDR(BLNK);          /* FOR THE INVALID DATA PORTION  *
         LA    @F,BLNK                                            0330
         ST    @F,300(0,@B)                                       0330
*    R5 = ADDR(BLNK) +1;             /* OF THE MESSAGE - SET UP THE   *
         LA    @5,BLNK+1                                          0331
*    GOTO W;                         /* REMAING PARAMETERS FOR THE    *
         BC    15,W                                               0332
*                                    /* MSGSETUP RTN AT W             *
*
*    /*****************************************************************
*    /*                                                               *
*    /* PROMPT WITH THE INVALID DATA                                  *
*    /*                                                               *
*    /*****************************************************************
*
*
* WW:
*    R5 = R4;                        /* SET UP XINPUTB TO POINT AT    *
WW       LR    @5,@4                                              0333
*                                    /* THE END OF THE INVALID DATA   *
*
* W:
*    R6 = OPERPCE;                   /* RESTORE THE PCE PTR TO THE
*                                       IKJOPER PCE                   *
W        L     @6,532(0,@B)                                       0334
*
* WWW:
*    PPCOUNT = 7;                    /* SET PPCOUNT TO THE LENGTH OF
*                                       THE OPER PDE -1               *
WWW      MVI   417(@B),7                                          0335
*    CBLNKSV2 = ADDR(P50PR);         /* PLACE THE RETURN ADDRESS IN
*                                       CBLNKSV2                      *
         LA    @F,P50PR                                           0336
         ST    @F,552(0,@B)                                       0336
*    CALL MSGSETUP;                  /* GOTO MSGSETUP TO FORMAT THE
*                                       SPECIAL MESSAGE PROMPT -
*                                       RETURN AFTER THE USER REPLIES
*                                       TO A PROMPT                   *
         BAL   @E,MSGSETUP                                        0337
*
*    /*****************************************************************
*    /*                                                               *
*    /* RECEIVE CONTROL AFTER A PROMPT FOR AN EXPRESSION              *
*    /*                                                               *
*    /*****************************************************************
*
*
* P50PR:                             /* RETURN FROM PROMPT            *
*
*    /*****************************************************************
*    /*                                                               *
*    /* PFNULL IS OFF IF DATA WAS RETURNED FROM THE PROMPT            *
*    /*                                                               *
*    /*****************************************************************
*
*    IF PFNULL = '1'B THEN           /* GOTO EXIT PROCESSING IF       *
P50PR    TM    178(@B),B'00001000'                                0338
         BC    12,@9D1                                            0338
*      DO;                           /* THERE IS                      *
*        PFNULL = '0'B;              /* NO PROMPT DATA RETURNED -     *
         NI    178(@B),B'11110111'                                0340
*        GOTO EP;                    /* ELSE -                        *
         BC    15,EP                                              0341
*      END;
*    OPERPRMT = '1'B;                /* ------ GOTO PROCESS THE       *
@9D1     OI    599(@B),B'00000010'                                0343
*    GOTO PR;                        /* PROMPT RETURN                 *
         BC    15,PR                                              0344
*
* A:
*    CBLNKSV1 = ADDR(B);             /* PLACE RETURN ADDRESS IN
*                                       CBLNKSV1                      *
A        LA    @F,B                                               0345
         ST    @F,548(0,@B)                                       0345
*    PPOINTR = PRMTPTR+1;            /* SET UP PTR TO LAST WORD OF THE
*                                       SECOND OPERAND                *
         LA    @F,1                                               0346
         A     @F,584(0,@B)                                       0346
         ST    @F,148(0,@B)                                       0346
*    R5 = OPERSVE;                   /* SET PTR TO END OF LAST WORD   *
         L     @5,536(0,@B)                                       0347
*    R15 = 10;                       /* LOAD ADDR PSTRIMSG ROUTINE    *
         LA    @F,10                                              0348
*    CALL LINKRET;                   /* GIVE CONTROL TO PSTRIMSG RTN
*                                       TO WRITE OUT THE CLOSING PAREN
*                                       ASSUMED MESSAGE               *
         BAL   @E,LINKRET                                         0349
*
* B:                                 /* FILL IN OPER TEMPORARY PDE    *
*    ORFND = '1'B;                   /* TURN ON BIT IN THE TEMP PDE TO
*                                       INDICATE THAT THE DATA
*                                       DESCRIBED UNDER THE OPER PCE
*                                       WAS FOUND                     *
B        OI    338(@B),B'10000000'                                0350
*    R6 = OPERPCE;                   /* RESTORE XPCE TO OPER PCE      *
         L     @6,532(0,@B)                                       0351
*    CHAINTRM = '0'B;                /* BIT INDICATING CHAIN TERM
*                                       PROCESSING MUST BE ZERO BEFORE
*                                       THE END OF OPER PROCESSING    *
         NI    600(@B),B'11101111'                                0352
*    RESPECIFY
*         (R1)RESTRICTED;            /* RESTRICT PTRS FOR USE BY
*                                       SUBROUTINE 'POSITXCB'         *
*    R1 = 7;                         /* PLACE LENGTH OF PDE -1 IN
*                                       COMMUNICATION REG FOR POSITXCB
*                                       RTN                           *
         LA    @1,7                                               0354
*    PLINKSV2 = ADDR(OVCERR);        /* OVCERR WILL RECEIVE CONTROL IF
*                                       THE VALIDITY CHECK ROUTINE
*                                       REJECTS THE EXPRESSION        *
         LA    @F,OVCERR                                          0355
         ST    @F,672(0,@B)                                       0355
*    R15 = 3;                        /* PLACE PTR TO SUBROUTINE
*                                       POSITXCB IN LINKAGE REG       *
         LA    @F,3                                               0356
*    CALL LINKRET;                   /* PASS CONTROL TO POSITXCB      *
         BAL   @E,LINKRET                                         0357
*    RESPECIFY
*         (R1) UNRESTRICTED;         /* PTR NO LONGER REQUIRED        *
*
*    /*****************************************************************
*    /*                                                               *
*    /* THE FOLLOWING SECTION PERFORMS NORMAL EXIT PROCESSING         *
*    /*                                                               *
*    /*****************************************************************
*
*
* EP:                                /* SET PTRS FOR NORMAL EXIT      *
*    R6 = OPEREND;                   /* PLACE THE ADDRESS OF THE LAST
*                                       MINOR TERM PCE IN XPCE        *
EP       L     @6,520(0,@B)                                       0359
*    OPERMODE = '0'B;                /* TURN OFF OPER MODE INDICATOR  *
         NI    599(@B),B'10111111'                                0360
*    GOTO RTNNSKP3;                  /* UPDATE TO NEXT PCE            *
         BC    15,RTNNSKP3                                        0361
*
*    /*****************************************************************
*    /*                                                               *
*    /* INITIATE IKJRSVWD MACRO PROCESSING                            *
*    /*                                                               *
*    /*****************************************************************
*
*
* IKJEFP40:                          /* ENTRY POINT RSVWD PROCESSOR   *
*    PROC OPTIONS(NOSAVEAREA,        /* IKJEFP40                      *
*          DONTSAVE);                /* NO STANDARD LINKAGE           *
@EL04    BCR   15,@E                                              0362
*    RESPECIFY
*         (R6,
*          R4,
*          R8,
*          R5) RESTRICTED;           /* SAVE PTRS                     *
*    RESPECIFY
*         (PWAREG,
*          R1) RESTRICTED;           /* SAVE PTRS                     *
*    RSVDRTN = R14;                  /* SAVE RETURN ADDR              *
IKJEFP40 ST    @E,RSVDRTN                                         0365
*    RSVWDSV2 = R6;                  /* SAVE PCE POINTER              *
         ST    @6,544(0,@B)                                       0366
*    RSVDPRMT = '0'B;                /* ZERO RSVD PROMPT BIT          *
         NI    599(@B),B'11111011'                                0367
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF XPCE POINTS TO A TERM PCE CALCULATE THE RSVWD PCE ADR      *
*    /*                                                               *
*    /*****************************************************************
*
*    IF TERPCE = '110'B THEN         /* IF XPCE POINTS TO A TERM      *
         TM    0(@6),B'11000000'                                  0368
         BC    12,@9D0                                            0367
         TM    0(@6),B'00100000'                                  0368
         BC    05,@9CF                                            0368
*      GOTO RCT;                     /* PCE ON ENTRY,                 *
         BC    15,RCT                                             0369
*                                    /* GOTO RCT AND UPDATE THE PCE
*                                       PTR TO THE CHAINED IKJRSVWD
*                                       PCE                           *
*
*    /*****************************************************************
*    /*                                                               *
*    /* CALL CLEANUP IF XPCE DOES NOT POINT TO A RSVWD PCE OR A TERM  *
*    /* PCE                                                           *
*    /*                                                               *
*    /*****************************************************************
*
*    IF RSVWMASK ^= '101'B THEN      /* IF XPCE DOES NOT POINT TO     *
@9CF     EQU   *                                                  0370
@9D0     TM    0(@6),B'10100000'                                  0370
         BC    12,@9CE                                            0369
         TM    0(@6),B'01000000'                                  0370
         BC    08,@9CD                                            0370
*      GOTO RTNCLNUP;                /* A RSVD PCE OR A TERM PCE ON
*                                       ENTRY, TERMINATE SCAN. GOTO
*                                       CLEANUP WITH THE RETURN CODE
*                                       IN RETCODE.                   *
         BC    15,RTNCLNUP                                        0371
*
*    /*****************************************************************
*    /*                                                               *
*    /* SKIP OVER RSVWD PCE, IF IT DESCRIBES A FIGURATIVE CONSTANT    *
*    /*                                                               *
*
*    IF RFCONST = '1'B THEN          /* IF THE RFCONST BIT IS ON,     *
@9CD     TM    1(@6),B'10000000'                                  0372
*      GOTO RTNNSKP3;                /* UPDATE THE PCE POINTR         *
         BC    01,RTNNSKP3                                        0373
*                                    /* TO THE NEXT PCE.   ROUTINE    *
*                                    /* NAMESKP3 PERFORMS             *
*                                    /* THIS FUNCTION AND THEN GIVES  *
*                                    /* CONTROL TO THE APPROPRIATE    *
*                                    /* PCE PROCESSOR.                *
*    COBOLMOD = '1'B;                /* INDICATE COBOL MODE           *
         OI    599(@B),B'10000000'                                0374
*    GOTO EE;                        /* INITIATE SCAN OF RSVWD        *
         BC    15,EE                                              0375
*
* RCT:
*    R6 = ADDR(RSVWDSV2 -> TPTSL)    /* UPDATE XPCE PAST THE TERM     *
*          + RSVWDSV2 -> TPTSL;      /* PCE'S FIRST VARIABLE LENGTH
*                                       FIELD TO BASE DSECT           *
RCT      L     @7,544(0,@B)        
         MVC   @TEMP2+2(2),7(@7)                                  0376
         LH    @F,@TEMP2+2                                        0376
         LA    @0,7(0,@7)                                         0376
         AR    @F,@0                                              0376
         LR    @6,@F                                              0376
*    IF RSVWDSV2 -> PROMPT = '1'B    /* IF PROMPT DATA PRESENT        *
*                                   /* OR                            *
*          RSVWDSV2 -> DEFAULT = '1'B /* IF DEFAULT DATA PRESENT      *
*      THEN                          /* THEN                          *
         TM    0(@7),B'00010000'                                  0377
         BC    01,@9CC                                            0377
         TM    0(@7),B'00001000'                                  0377
         BC    12,@9CB                                            0377
*      R8 = ADDR(TPODL) + TPODL + 2; /* SET UP DSECT BASE FOR NEXT
*                                       FIELD IN TERM PCE             *
@9CC     LA    @F,2                                               0378
         SR    @0,@0                                              0378
         IC    @0,0(0,@6)                                         0378
         AR    @F,@0                                              0378
         AR    @F,@6                                              0378
         LR    @8,@F                                              0378
         BC    15,@9CA                                            0379
*    ELSE                            /* ELSE                          *
*      R8 = R6;                      /* XPCE IS ALREADY POSITIONED    *
@9CB     LR    @8,@6                                              0379
*    IF RSVWDSV2 -> SUBSCRP = '1'B   /* IF SUBSCRPTS ALLOWED          *
*      THEN                          /* THEN                          *
@9CA     L     @7,544(0,@B)        
         TM    1(@7),B'00010000'                                  0380
         BC    12,@9C9                                            0380
*      R8 = R8 + 2;                  /* INCREMENT PAST SUBSC. OFFSET  *
         AH    @8,@D4                                             0381
*    R6 = PTABLEAD + R8 -> RSVWDIDX;  /* XPCE = RSVWD PCE ADDR        *
@9C9     MVC   @TEMP2+2(2),0(@8)                                  0382
         LH    @F,@TEMP2+2                                        0382
         A     @F,324(0,@B)                                       0382
         LR    @6,@F                                              0382
*
*    /*****************************************************************
*    /*                                                               *
*    /* CALL CLEANUP IF THE CHAINED PCE IS NOT A RSVWD PCE            *
*    /*                                                               *
*    /*****************************************************************
*
*    IF RSVWMASK ^= '101'B THEN      /* RETURN CODE IN RETCODE        *
         TM    0(@6),B'10100000'                                  0383
         BC    12,@9C8                                            0382
         TM    0(@6),B'01000000'                                  0383
         BC    08,@9C7                                            0383
*      GOTO RTNCLNUP;                /* IS RETURNED TO THE CP IF NO
*                                       CHAINED RSVWD PCE             *
         BC    15,RTNCLNUP                                        0384
*
*    /*****************************************************************
*    /*                                                               *
*    /* CALL CLEANUP IF THE CHAINED RSVWD PCE DOES NOT HAVE THE       *
*    /* FIGURATIME CONSTANT INDICATOR BIT ON                          *
*    /*                                                               *
*    /*****************************************************************
*    IF RFCONST = '0'B THEN          /* TERMINATE SCAN IF NOT AN      *
@9C7     TM    1(@6),B'10000000'                                  0385
*      GOTO RTNCLNUP;                /* RFCONST RSVWD PCE             *
         BC    08,RTNCLNUP                                        0386
*    RSVWDSV1 = R4;                  /* SAVE POINTER TO START OF DATA *
         ST    @4,540(0,@B)                                       0387
* EE:
*    RSVWDPCE = R6;                  /* SAVE RSVWD PCE ADDRESS        *
EE       ST    @6,524(0,@B)                                       0388
*    R15 = 5;                        /* PLACE THE ADDRESS OF THE SKIPB
*                                       ROUTINE IN LINKB              *
         LA    @F,5                                               0389
*    CALL LINKRET;                   /* GOTO SKIPB ROUTINE            *
         BAL   @E,LINKRET                                         0390
*    GOTO A1;                        /* ON +0 RETURN - PROMPT         *
         BC    15,A1                                              0391
*                                    /* ON +4 RETURN INITIATE SCAN    *
*    RESPECIFY
*         (R8,
*          R1) RESTRICTED;           /* SET UP TEMP AREAS             *
*
* E:
*    R8 = 0;                         /* ZERO LENGTH COUNTER           *
E        SR    @8,@8                                              0393
*    RSVWDSV1 = R4;                  /* SAVE PTR TO START OF DATA     *
         ST    @4,540(0,@B)                                       0394
*    R1 = '08'X;                     /* SET UP TYPE TEST MASK FOR
*                                       SEPARATOR CHARACTERS          *
         LA    @1,X'08'                                           0395
*
*    /*****************************************************************
*    /*                                                               *
*    /* INITIATE SCAN FOR RSVWD LENGTH                                *
*    /*                                                               *
*    /*****************************************************************
*
*
* SL:
*    R4 = R4 + 1;                    /* INCREMENT INPUT POINTER       *
SL       AH    @4,@D2                                             0396
*
*    /*****************************************************************
*    /*                                                               *
*    /* EXIT LOOP IF END OF INPUT IS REACHED                          *
*    /*                                                               *
*    /*****************************************************************
*
*    IF R4 ^< ENDINPUT THEN          /* IF THE END OF INPUT IS        *
         C     @4,144(0,@B)                                       0397
*      GOTO F;                       /* REACHED, I EQUALS RSVWD LENGTH*
         BC    10,F                                               0398
*    R15 = 8;                        /* PLACE ADDR OF TYPETEST ROUTINE
*                                       IN LINKB                      *
         LA    @F,8                                               0399
*
*    /*****************************************************************
*    /*                                                               *
*    /* EXIT THE LOOP IF XINPUT POINTS TO A BLANK, COMMA OR TAB       *
*    /*                                                               *
*    /*****************************************************************
*
*    CALL LINKRET;                   /* CALL TYPETEST ROUTINE         *
         BAL   @E,LINKRET                                         0400
*    GEN;                            /* GENERATE TYPETEST RETURNS     *
         BC     15,RPTEST              /* +0 RETURN - CONTINUE SCAN  */
         BC     15,OMODCK              /* +4 RETURN - EXIT LOOP      */
         DS    0H
*
*    /*****************************************************************
*    /*                                                               *
*    /* TERMINATE SCAN IF A RIGHT PAREN IS FOUND WHEN NOT ALLOWED     *
*    /*                                                               *
*    /*****************************************************************
*
*
* RPTEST:
*    IF COMBUF = ')'                 /* A RIGHT PAREN TERMINATES      *
*      THEN
RPTEST   CLI   0(@4),C')'                                         0402
         BC    07,@9C6                                            0402
*      DO;                           /* THE RSVWD SCAN                *
*        IF OPERMODE = '1'B THEN     /* WHEN PROCESSING EITHER        *
         TM    599(@B),B'01000000'                                0404
*          GOTO OMODCK2;             /* AN EXPRESSION,                *
         BC    01,OMODCK2                                         0405
*        IF SUBSMODE = '1'B         /* OR A FIGURATIVE               *
*              PFLIST = '1'B THEN    /* CONST WITHIN                  *
         TM    599(@B),B'00100000'                                0406
         BC    01,@9C5                                            0406
         TM    176(@B),B'10000000'                                0406
         BC    12,@9C4                                            0406
*          GOTO F;                   /* A LIST OR                     *
         BC    03,F                                               0407
*      END;                          /* SUBSCRIPT                     *
@9C4     EQU   *                                                  0408
*
*    /*****************************************************************
*    /*                                                               *
*    /* WHEN PROCESSING A MEMBER OF A RANGE, A COLON DELIMITS         *
*    /* THE SCAN FOR A FIGURATIVE CONSTANT                            *
*    /*                                                               *
*    /*****************************************************************
*
*    IF COMBUF = ':' &               /* A RANGE CAN ONLY BE           *
*          RSVWDPCE -> RFCONST = '1'B & /* ENTERED UNDER A TERM PCE   *
*          RSVWDSV2 -> RANG = '1'B THEN /* THAT IS NOT UNDER AN       *
@9C6     CLI   0(@4),C':'                                         0409
         BC    07,@9C3                                            0409
         L     @7,524(0,@B)        
         TM    1(@7),B'10000000'                                  0409
         BC    12,@9C2                                            0409
         L     @9,544(0,@B)        
         TM    1(@9),B'00100000'                                  0409
*      GOTO F;                       /* OPER PCE                      *
         BC    03,F                                               0410
*
*    /*****************************************************************
*    /*                                                               *
*    /*  TEST FOR A SEMICOLON                                         *
*    /*                                                               *
*    /*****************************************************************
*
*    IF COMBUF = ';'                 /* END THE SCAN IF A SEMICOLON   *
*      THEN
@9C1     EQU   *                                                  0411
@9C2     EQU   *                                                  0411
@9C3     EQU   *                                                  0411
         CLI   0(@4),C';'                                         0411
         BC    07,@9C0                                            0411
*      DO;                           /* IS ENCOUNTERED IN THE         *
*        IF RSVDPRMT = '0'B THEN     /* INITIAL INPUT BUFFER...       *
         TM    599(@B),B'00000100'                                0413
*          GOTO F;                   /* END THE SCAN IF A SEMICOLON   *
         BC    08,F                                               0414
*        IF OPERMODE = '0'B &        /* IS ENCOUNTERED IN A NON OPER  *
*              R8 ^= 0 THEN          /* MODE PROMPT REPLY ON OTHER    *
         TM    599(@B),B'01000000'                                0415
         BC    05,@9BF                                            0415
         LTR   @8,@8                                              0415
*          GOTO F2R;                 /* THE FIRST CHARACTER           *
         BC    07,F2R                                             0416
*      END;
@9BE     EQU   *                                                  0417
@9BF     EQU   *                                                  0417
*
* AI1:
*    R8 = R8 + 1;                    /* UP THE LENGTH COUNTER AND     *
@9C0     EQU   *                                                  0418
AI1      AH    @8,@D2                                             0418
*    GOTO SL;                        /* RETURN TO THE ENTRY POINT     *
         BC    15,SL                                              0419
*
*    /*****************************************************************
*    /*                                                               *
*    /* *************END OF LENGTH SCAN LOOP**********************    *
*    /* CHECK FOR ZERO LENGTH RSVWD                                   *
*    /*                                                               *
*    /*****************************************************************
*
*
* F:
*    IF R8 = 0                       /* WAS THE FIRST CHAR OF         *
*      THEN                          /* THE RSVWD A                   *
F        LTR   @8,@8                                              0420
         BC    07,@9BD                                            0420
*      DO;                           /* DELIMITER                     *
*
*        /*************************************************************
*        /*                                                           *
*        /* PROMPT FOR MISSING IF NOT RETURNED FROM RSVWD PROMPT      *
*        /*                                                           *
*        /*************************************************************
*
*        IF RSVDPRMT = '1'B          /* DATA RETURNED IN A PROMPT     *
*          THEN                      /* FOR A RSVWD IS INVALID        *
         TM    599(@B),B'00000100'                                0422
         BC    12,@9BC                                            0422
*          DO;                       /* UNLESS THERE IS A NAME MATCH  *
*
*            /*********************************************************
*            /*                                                       *
*            /* REJECT ENTIRE BUFFER IF RETURNED FROM PROMPT IN OPER  *
*            /* MODE                                                  *
*            /*                                                       *
*            /*********************************************************
*
*            IF OPERMODE = '1'B THEN /* PROMPT WITH THE ENTIRE        *
         TM    599(@B),B'01000000'                                0424
*              GOTO IPA;             /* BUFFER WHEN IN OPER MODE ---  *
         BC    01,IPA                                             0425
*            GOTO A1I;               /* ELSE, PROMPT WITH DATA UP TO  *
         BC    15,A1I                                             0426
*          END;                      /* FIRST VALID DELIMITER,        *
*                                    /* WHEN NO MATCH CAN             *
*                                    /* BE FOUND                      *
*        R4 = R4 -1;                 /* DECREMENT XINPUT FOR NEXT     *
@9BC     BCTR  @4,0                                               0428
*        GOTO A1;                    /* ROUTINES SKIPB CALL AND       *
         BC    15,A1                                              0429
*      END;                          /* ASSUME RSVWD IS MISSING       *
*
*    /*****************************************************************
*    /*                                                               *
*    /* WAS THE MAXIMUM LENGTH EXCEEDED IN THE SCAN                   *
*    /*                                                               *
*    /*****************************************************************
*
* F2R:
*    IF R8 > 256 THEN                /* ASSUME NAME DOESN'T MATCH     *
@9BD     EQU   *                                                  0431
F2R      CH    @8,@D5                                             0431
*      GOTO NOMATCH2;                /* IF MAX LENGTH EXCEEDED        *
         BC    02,NOMATCH2                                        0432
*    PLENGTH = R8;                   /* PLENGTH = RSVWD LENGTH        *
         STH   @8,152(0,@B)                                       0433
*
*    /*****************************************************************
*    /*                                                               *
*    /* DATA CAN'T BE TRANSLATED TO UPPER CASE IN THE COMMAND BUFFER  *
*    /* BEFORE AN IKJNAME MATCH IS FOUND                              *
*    /*                                                               *
*    /*****************************************************************
*
*    R1 =R8;                         /* PASS NUMBER OF BYTES NEEDED IN
*                                       R1                            *
         LR    @1,@8                                              0434
*    R15 = 14;                       /* LOAD ADR GETCORE ROUTINE      *
         LA    @F,14                                              0435
*    CALL LINKRET;                   /* OBTAIN WORK AREA FOR RSVWD'S  *
         BAL   @E,LINKRET                                         0436
*                                    /* TRANSLATION TO UPPER CASE     *
*    PPOINTR = R1;                   /* PLACE ADDR OF WORK AREA IN
*                                       PPOINTR                       *
         ST    @1,148(0,@B)                                       0437
*    R1 -> COMBUFP(1:R8) = COMBUFBV(1:R8);/*
*                                           COPY RSVWD                *
         LR    @E,@5                                              0438
         LR    @7,@8                                              0438
         BCTR  @7,0                                               0438
         LR    @A,@1                                              0438
         EX    @7,@MVC                                            0438
*
* RTQ:
*    R15 = 9;                        /* PLACE ADDR TRANSQ ROUTINE     *
RTQ      LA    @F,9                                               0439
*    CALL LINKRET;                   /* IN LINKB AND CALL TRANSQ      *
         BAL   @E,LINKRET                                         0440
*    R5 = PPOINTR;                   /* POINT XINPUTB TO THE UPPER
*                                       CASE COPY OF THE RSVWD        *
         L     @5,148(0,@B)                                       0441
*    PPOINTR = RSVWDSV1 + 1;         /* RESTORE PPOINTR TO ADDR OF
*                                       FIRST CHAR OF RSVWD           *
         LA    @F,1                                               0442
         A     @F,540(0,@B)                                       0442
         ST    @F,148(0,@B)                                       0442
*    R4 = R8 + PPOINTR;              /* POINT XINPUT PAST THE RSVWD   *
         L     @4,148(0,@B)                                       0443
         AR    @4,@8                                              0443
*    RESPECIFY
*         (R9) RESTRICTED;           /* SAVE IKJNAME COUNTER          *
*    R9 = 0;                         /* SET COUNTER TO ZERO           *
         SR    @9,@9                                              0445
*
*    /*****************************************************************
*    /*                                                               *
*    /* THIS LOOP COMPARES THE RSVWD IN THE BUFFER TO THE NAMES IN THE*
*    /* IKJNAME PCE'S                                                 *
*    /*                                                               *
*    /*****************************************************************
*
*
* NAMECK:
*    R6 = R6 + NPCELNTH;             /* UPDATE XPCE TO NEXT PCE       *
NAMECK   MVC   @TEMP2+2(2),2(@6)                                  0446
         AH    @6,@TEMP2+2                                        0446
*    R9 = R9 + 1;                    /* UPDATE IKJNAME # COUNTER      *
         AH    @9,@D2                                             0447
*
*    /*****************************************************************
*    /*                                                               *
*    /* EXIT WHEN ALL THE NAMES HAVE BEEN EXHAUSTED                   *
*    /*                                                               *
*    /*****************************************************************
*
*    IF NPCEMASK ^= '011'B THEN      /* GOTO NOMATCH WHEN XPCE NO     *
         TM    0(@6),B'01100000'                                  0448
         BC    12,@9BB                                            0447
         TM    0(@6),B'10000000'                                  0448
         BC    08,@9BA                                            0448
*      GOTO NOMATCH;                 /* LONGER POINTS TO A NAME PCE   *
         BC    07,NOMATCH                                         0449
*
*    /*****************************************************************
*    /*                                                               *
*    /* REPEAT LOOP IF NAME AND RSVWD LENGTHS DO NOT MATCH            *
*    /*                                                               *
*    /*****************************************************************
*
*    IF R8 ^= NAMELM1 +1 THEN        /* COMPARE RSVWD LENGTH TO       *
@9BA     LA    @F,1                                               0450
         SR    @0,@0                                              0450
         IC    @0,4(0,@6)                                         0450
         AR    @F,@0                                              0450
         CR    @F,@8                                              0450
*      GOTO NAMECK;                  /* NAME LENGTH                   *
         BC    07,NAMECK                                          0451
*
*    /*****************************************************************
*    /*                                                               *
*    /* REPEAT LOOP IF NAME AND UPPER CASE RSVWD DO NOT MATCH         *
*    /*                                                               *
*    /*****************************************************************
*
*    IF R5 -> COMBUFBV(1:R8) ^= NAMEDATA(1:R8) THEN    /* COMPARE
*                                       RSVWD TO                      *
         LA    @E,5(0,@6)                                         0452
         LR    @7,@8                                              0452
         BCTR  @7,0                                               0452
         LR    @A,@5                                              0452
         EX    @7,@CLC                                            0452
*      GOTO NAMECK;                  /* THE NAME                      *
         BC    07,NAMECK                                          0453
*
*    /*****************************************************************
*    /*                                                               *
*    /* *********END OF NAME COMPARE LOOP*************************    *
*    /* FREE CORE FOR UPPER CASE RSVWD COPY                           *
*    /*                                                               *
*    /*****************************************************************
*
*    CALL FREECORE;                  /* FREE RSVWD COPY AREA          *
         L     @F,@V4              ADDRESS OF FREECORE            0454
         BALR  @E,@F                                              0454
*
*    /*****************************************************************
*    /*                                                               *
*    /* RETURN TO IKJEFP60 IF A FIGURATIVE CONSTANT IS FOUND          *
*    /*                                                               *
*    /*****************************************************************
*
*    IF RSVWDPCE -> RFCONST = '1'B   /* THE RFCONST SWITCH IS ON      *
*      THEN                          /* ONLY IN A TERM CHAINED        *
         L     @7,524(0,@B)        
         TM    1(@7),B'10000000'                                  0455
         BC    12,@9B9                                            0455
*      DO;                           /* RSVWD PCE.                    *
*        PDEPTR -> RESWDNUM = R9;    /* PLACE NAME # IN TEMP PDE      *
         L     @7,564(0,@B)        
         STH   @9,4(0,@7)                                         0457
*        GOTO RTN4;                  /* RETURN ON LINK REG +4 WHEN    *
         BC    15,RTN4                                            0458
*      END;                          /* MATCH FOUND.                  *
*    R4 = R4 -1;                     /* DECREMENT FOR NEXT SUBRTN     *
@9B9     BCTR  @4,0                                               0460
*    R6 = RSVWDPCE;                  /* PLACE PTR TO RSVWD PCE IN XPCE*
         L     @6,524(0,@B)                                       0461
*
*    /*****************************************************************
*    /*                                                               *
*    /* FILL IN TEMPORARY RSVWD PDE                                   *
*    /*                                                               *
*    /*****************************************************************
*
*    RNAMENUM = R9;                  /* PLACE IKJNAME NUMBER IN
*                                       TEMPORARY PDE                 *
         ST    @9,@TEMP4                                          0462
         MVC   334(2,@B),@TEMP4+2                                 0462
*    ORFND = '1'B;                   /* INDICATE THAT MATCH WAS FOUND *
         OI    338(@B),B'10000000'                                0463
*    R5 = R4;                        /* UPDATE XINPUTB PAST RSVWD     *
         LR    @5,@4                                              0464
*    INVPSAVE = PPOINTR;             /* INVPSAVE = FIRST CHAR RSVWD   *
         MVC   300(4,@B),148(@B)                                  0465
*    R1 = 7;                         /* R1 = PDELENGTH -1             *
         LA    @1,7                                               0466
*    R15 = 3;                        /* LOAD ADDR POSITXCB ROUTINE    *
         LA    @F,3                                               0467
*    CALL LINKRET;                   /* GOTO ADD PERMANENT PDE VIA
*                                       POSITXCB ROUTINE              *
         BAL   @E,LINKRET                                         0468
*
*    /*****************************************************************
*    /*                                                               *
*    /* DETERMINE IDENTITY OF CALLING ROUTINE WHEN NOT IKJEFP60       *
*    /*                                                               *
*    /*****************************************************************
*
*    IF OPERMODE = '0'B THEN         /* GOTO NAMESKP3 IF CALLER       *
         TM    599(@B),B'01000000'                                0469
*      GOTO RTNNSKP3;                /* IS NOT IKJOPER PROCESSOR      *
         BC    08,RTNNSKP3                                        0470
*    GOTO RTN4;                      /* RETURN TO IKJOPER PROCESSOR   *
         BC    15,RTN4                                            0471
*
*    /*****************************************************************
*    /*                                                               *
*    /* RECEIVE CONTROL WHEN NO MATCH IS FOUND                        *
*    /*                                                               *
*    /*****************************************************************
*
*
* NOMATCH:
*    CALL FREECORE;                  /* FREE CORE USED FOR UPPER      *
NOMATCH  L     @F,@V4              ADDRESS OF FREECORE            0472
         BALR  @E,@F                                              0472
*                                    /* CASE RSVWD COPY               *
*
*    /*****************************************************************
*    /*                                                               *
*    /* SET UP PROMPT MESSAGE UNLESS A FIGURATIME CONSTANT IS BEING   *
*    /* PROCESSED UNDER A TERM PCE                                    *
*    /*                                                               *
*    /*****************************************************************
*
*
* NOMATCH2:
*    IF RSVWDPCE -> RFCONST = '1'B THEN /* RETURN TO IKJEFP50 IF      *
NOMATCH2 L     @7,524(0,@B)        
         TM    1(@7),B'10000000'                                  0473
*      GOTO RTN0;                    /* RFCONST BIT IS ON             *
         BC    01,RTN0                                            0474
*
*    /*****************************************************************
*    /*                                                               *
*    /* DETERMINE IF RSVWD IS INVALID WHEN NO MATCH IS FOUND          *
*    /*                                                               *
*    /*****************************************************************
*
*    IF RSVDPRMT = '1'B             /* RSVWD IS INVALID IF           *
*          OPERMODE = '1'B          /* IT IS A RSVWD PROMPT          *
*          RSVWDPCE -> RPRMTI = '1'B  /* REPLY, IF IN OPER MODE,     *
*          RSVWDPCE -> RDFLTI = '1'B THEN /* OR IF PROMPT-DEFAULT     *
         TM    599(@B),B'00000100'                                0475
         BC    01,@9B8                                            0475
         TM    599(@B),B'01000000'                                0475
         BC    01,@9B7                                            0475
         TM    0(@7),B'00010000'                                  0475
         BC    01,@9B6                                            0475
         TM    0(@7),B'00001000'                                  0475
         BC    12,@9B5                                            0475
*      GOTO IP;                      /* DATA IS PRESENT               *
         BC    03,IP                                              0476
*    R6 = RSVWDSV2;                  /* RESTORE XPCE TO ENTRY VALUE   *
@9B5     L     @6,544(0,@B)                                       0477
*    R4 = RSVWDSV1;                  /* POINT XINPUT TO CHAR BEFORE   *
         L     @4,540(0,@B)                                       0478
*    GOTO RTNNSKP3;                  /* RSVWD, THEN EXIT              *
         BC    15,RTNNSKP3                                        0479
*
*    /*****************************************************************
*    /*                                                               *
*    /* SET UP PARAMETERS WHEN PROMPTING WITH INVALID DATA            *
*    /*                                                               *
*    /*****************************************************************
*
*
* IPA:
*    R4 = ENDINPUT;                  /* PROMPT WITH REMAINDER         *
IPA      L     @4,144(0,@B)                                       0480
*                                    /* OF BUFFER                     *
*
* IP:
*    INVPSAVE = RSVWDSV1 + 1;        /* SET INVPSAVE TO FIRST CHAR    *
IP       LA    @F,1                                               0481
         A     @F,540(0,@B)                                       0481
         ST    @F,300(0,@B)                                       0481
*                                    /* OF INVALID DATA               *
*    PPCOUNT = 7;                    /* SET PPCOUNT = PDE LENGTH -1   *
         MVI   417(@B),7                                          0482
*    R6 = RSVWDPCE;                  /* SET PCE PTR TO RSVWD PCE      *
         L     @6,524(0,@B)                                       0483
*    R5 = R4;                        /* SET XINPUTB TO NEXT CHAR AFTER
*                                       INVALID DATA                  *
         LR    @5,@4                                              0484
*    CBLNKSV2 = ADDR(P40PR);         /* CBLNKSV2 = RETURN ADDR        *
         LA    @F,P40PR                                           0485
         ST    @F,552(0,@B)                                       0485
*    GOTO MSGSETUP;                  /* PROMPT                        *
         BC    15,MSGSETUP                                        0486
*
*    /*****************************************************************
*    /*                                                               *
*    /* PROMPT FOR MISSING DATA UNLESS PROCESSING A FIGURATIVE        *
*    /* CONSTANT                                                      *
*    /*                                                               *
*    /*****************************************************************
*
*
* A1:
*    IF RSVWDPCE -> RFCONST = '1'B THEN /* RETURN TO TERM             *
A1       L     @7,524(0,@B)        
         TM    1(@7),B'10000000'                                  0487
*      GOTO RTN0;                    /* PROCESSOR IF RSVWD PCE IS
*                                       CHAINED TO A TERM PCE         *
         BC    01,RTN0                                            0488
*    R6 = RSVWDPCE;                  /* PLACE PROMPT PCE IN XPCE      *
         L     @6,524(0,@B)                                       0489
*    R15 = 2;                        /* LOAD PROMPTQ RTN ADDR         *
         LA    @F,2                                               0490
*    CALL LINKRET;                   /* CALL PROMPTQ                  *
         BAL   @E,LINKRET                                         0491
*    GEN (BC 15,P40PR);              /* ON +0 RETURN -- DATA RETURNED *
         BC 15,P40PR
         DS    0H
*    GEN (BC 15,RPQRTN4);            /* ON +4 RETURN -- NO NEW DATA   *
         BC 15,RPQRTN4
         DS    0H
*
*    /*****************************************************************
*    /*                                                               *
*    /* RECEIVE CONTROL AFTER THE PROMPT REPLY                        *
*    /*                                                               *
*    /*****************************************************************
*
*
* P40PR:                             /* DETERMINE IF NEW DATA WAS
*                                       RETURNED FROM THE PROMPT      *
*    IF PFNULL = '0'B                /* IF DATA WAS RETURNED          *
*      THEN                          /* FROM THE PROMPT, SCAN THE     *
P40PR    TM    178(@B),B'00001000'                                0494
         BC    05,@9B4                                            0494
*      DO;                           /* NEW RSVWD DATA. SET           *
*        RSVDPRMT = '1'B;            /* RSVDPRMT TO INDITCATE THAT    *
         OI    599(@B),B'00000100'                                0496
*        GOTO E;                     /* THE DATA MUST BE INVALID      *
         BC    15,E                                               0497
*      END;                          /* IF NO MATCH IS FOUND          *
*    PFNULL = '0'B;                  /* TURN OFF NULL REPLY SWITCH    *
@9B4     NI    178(@B),B'11110111'                                0499
*
*    /*****************************************************************
*    /*                                                               *
*    /* DETERMINE CALLING ROUTINE AFTER A NULL PROMPT REPLY           *
*    /*                                                               *
*    /*****************************************************************
*
*
* RPQRTN4:
*    IF OPERMODE = '1'B THEN         /* RETURN TO OPER PROCESSOR      *
RPQRTN4  TM    599(@B),B'01000000'                                0500
*      GOTO RTNO0;                   /* IF IN OPER MODE. GIVE         *
         BC    01,RTNO0                                           0501
*    ELSE                            /* CONTROL TO NAMESKP3 IF        *
*      GOTO RTNNSKP3;                /* CALLED BY MAIN LINE PARSE     *
         BC    15,RTNNSKP3                                        0502
*
*    /*****************************************************************
*    /*                                                               *
*    /* CHECK FOR INVALID OPTIONAL DATA ON THE REPLY TO RSVWD         *
*    /* PROMPTING IN THE OPER MODE                                    *
*    /*                                                               *
*    /*****************************************************************
*
* OMODCK:
*    IF OPERMODE = '0'B THEN         /* OPTIONAL DATA IS INVALID      *
OMODCK   TM    599(@B),B'01000000'                                0503
*         GOTO F;                    /* ONLY WHEN IN OPER MODE        *
         BC    08,F                                               0504
*
*    /*****************************************************************
*    /*                                                               *
*    /* CHECK FOR INVALID OPTIONAL DATA ON THE PROMPT REPLY           *
*    /*                                                               *
*    /*****************************************************************
*
* OMODCK2:
*    IF RSVDPRMT = '0'B THEN         /* THE CHECK ONLY APPLIES TO     *
OMODCK2  TM    599(@B),B'00000100'                                0505
*      GOTO F;                       /* DATA RETURNED FROM A PROMPT   *
         BC    08,F                                               0506
*    PFNOPOP = '1'B;                 /* ENSURE THAT SKIPB DOES NOT POP
*                                       PROMPT BUFFER                 *
         OI    179(@B),B'00000010'                                0507
*    R15 = 5;                        /* LOAD ADDR SKIPB RTN           *
         LA    @F,5                                               0508
*    CALL LINKRET;                   /* CALL SKIPB TO SKIP OVER
*                                       SEPARATORS                    *
         BAL   @E,LINKRET                                         0509
*    GOTO NOPRMT;                    /* +0 RETURN-- NO OPTIONAL DATA
*                                       BEFORE END OF BUFFER          *
         BC    15,NOPRMT                                          0510
*    PFNOPOP = '0'B;                 /* +4 RETURN-- INVALID OPTIONAL
*                                       DATA FOUND                    *
         NI    179(@B),B'11111101'                                0511
*    GOTO IPA;                       /* PROMPT                        *
         BC    15,IPA                                             0512
*
* NOPRMT:
*    PFNOPOP = '0'B;                 /* ALLOW SKIPB TO POP BUFFER ON
*                                       FUTURE CALLS                  *
NOPRMT   NI    179(@B),B'11111101'                                0513
*    R5 = RSVWDSV1 + 1;              /* SET PTR TO RSVWD FIRST CHAR   *
         LA    @5,1                                               0514
         A     @5,540(0,@B)                                       0514
*    GOTO F;                         /* CONTINUE RSVWD SCAN           *
         BC    15,F                                               0515
*
*    /*****************************************************************
*    /*                                                               *
*    /* RETURN CONTROL TO THE CALLING ROUTINE                         *
*    /*                                                               *
*    /*****************************************************************
*
*
* RTN0:
*    R4 = RSVWDSV1;                  /* RESTORE XINPUT TO ENTRY VALUE *
RTN0     L     @4,540(0,@B)                                       0516
*
* RTNO0:
*    R8 = 0;                         /* RETURN ON +0                  *
RTNO0    SR    @8,@8                                              0517
*    GOTO RTNC;                      /* SKIP OVER +4 RETURN           *
         BC    15,RTNC                                            0518
*
* RTN4:
*    R8 = 4;                         /* RETURN ON +4                  *
RTN4     LA    @8,4                                               0519
*
* RTNC:
*    R6 = RSVWDSV2;                  /* RESTORE XPCE TO ENTRY VALUE   *
RTNC     L     @6,544(0,@B)                                       0520
*    R14 = RSVDRTN + R8;             /* LOAD RETURN ADDR              *
         LR    @E,@8                                              0521
         A     @E,RSVDRTN                                         0521
*    RETURN;                         /* RETURN TO CALLER              *
         BC    15,@EL05                                           0522
*
* RTNNSKP3:
*    COBOLMOD = '0'B;                /* LEAVE COBOL MODE              *
RTNNSKP3 NI    599(@B),B'01111111'                                0523
*    GEN (BAL   14,@EL01);           /* FREE AUTOMATIC STORAGE        *
         BAL   14,@EL01
         DS    0H
*    R15 = 15;                       /* LOAD ADDR NAMESKP3 ROUTINE    *
         LA    @F,15                                              0525
*    CALL LINKRET;                   /* GIVE CONTROL - NO RETURN      *
         BAL   @E,LINKRET                                         0526
*
* RTNCLNUP:
*    RETCODE = 24;                   /* PASS RETURN CODE FOR BAD PCE
*                                       BACK TO THE CP                *
RTNCLNUP MVI   154(@B),24                                         0527
*    GEN (BAL   14,@EL01);           /* FREE AUTOMATIC STORAGE        *
         BAL   14,@EL01
         DS    0H
*    R15 = 16;                       /* LOAD ADDR CLEANUP RTN         *
         LA    @F,16                                              0529
*    CALL LINKRET;                   /* TERMINATE SCAN AND GOTO
*                                       CLEANUP                       *
         BAL   @E,LINKRET                                         0530
*    END IKJEFP40;
@EL05    BCR   15,@E                                              0531
*
*    /*****************************************************************
*    /*                                                               *
*    /* FREE STORAGE OBTAINED BY THE GETCORE SUBROUTINE               *
*    /*                                                               *
*    /*****************************************************************
*
*
* FREECORE:                          /* ENTRY FREECORE                *
*    PROC OPTIONS(NOSAVEAREA,        /* NO STANDARD LINKAGE           *
*          DONTSAVE);                /* NO STANDARD LINKAGE           *
*    RESPECIFY
*         (R8,
*          R9,
*          R4,
*          R6,
*          R5,
*          PWAREG) RESTRICTED;       /* SAVE CRITICAL POINTERS        *
*    GOREGSV = R14;                  /* SAVE RETURN ADDR              *
FREECORE ST    @E,616(0,@B)                                       0534
*    GEN;                            /* FREE STORAGE                  *
           LR     R0,R8                /* R8 = I = # OF BYTES        */
           LR     R1,R5                /* R5 = XINPUTB = ADDR CORE   */
           FREEMAIN R,LV=(0),A=(1)     /* FREE CORE                  */
         DS    0H
*    R14 = GOREGSV;                  /* RESTORE RETURN ADDR           *
         L     @E,616(0,@B)                                       0536
*    END FREECORE;
@EL06    BCR   15,@E                                              0537
*
*    /*****************************************************************
*    /*                                                               *
*    /* THIS ROUTINE VALIDITY CHECKS THE STRUCTURE OF TERM PCE'S CODED*
*    /* UNDER THE OPER PCE                                            *
*    /*                                                               *
*    /*****************************************************************
*
*
* TERMOCK:
*    PROC OPTIONS(NOSAVEAREA,        /* ENTRY TERMOCK                 *
*          DONTSAVE);                /* NO STANDARD LINKAGE           *
*    RESPECIFY
*         (R6,
*          R4,
*          R5,
*          R7,
*          R9,
*          PWAREG) RESTRICTED;       /* SAVE POINTERS                 *
*    GOREGSV = R14;                  /* SAVE RETURN ADDR              *
TERMOCK  ST    @E,616(0,@B)                                       0540
*    IF TERPCE ^= '110'B             /* COMPARE THE TERM PCE TYPE     *
*      THEN
         TM    0(@6),B'11000000'                                  0541
         BC    12,@9B3                                            0540
         TM    0(@6),B'00100000'                                  0541
         BC    08,@9B2                                            0541
*      GOTO RTNCLNUP;                /* MASK TO THE MINOR TERM        *
         BC    15,RTNCLNUP                                        0542
*                                    /* PCE LOCATION - IF THERE IS    *
*                                    /* NO MATCH GOTO CLEANUP WITH    *
*                                    /* THE RETURN CODE IN RETCODE    *
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF THE MINOR TERM PCE HAS LIST OR RANGE SPECIFIED IT CAN NOT  *
*    /* BE CODED UNDER AN OPER PCE                                    *
*    /*                                                               *
*    /*****************************************************************
*
*    IF LIST = '1'B                 /* TEST THE LIST AND THE RANGE   *
*          RANG = '1'B               /* BITS IN THE MINOR TERM PCE    *
*      THEN
@9B2     TM    1(@6),B'10000000'                                  0543
         BC    01,@9B1                                            0543
         TM    1(@6),B'00100000'                                  0543
         BC    12,@9B0                                            0543
*      GOTO RTNCLNUP;                /* - IF THEY ARE ON GOTO THE     *
         BC    15,RTNCLNUP                                        0544
*                                    /* PARSE SUBROUTINE 'CLEANUP'    *
*                                    /* WHICH PASSES THE PCE ERROR    *
*                                    /* RETURN CODE -RETCODE- BACK    *
*                                    /* TO THE COMMAND PROCESS        *
*
*    /*****************************************************************
*    /*                                                               *
*    /* THE MINOR TERM PCE ADDRESS MUST BE LESS THAN THE PCE ADDRESS  *
*    /* FOUND IN 'PRIORPCE'                                           *
*    /*                                                               *
*    /*****************************************************************
*
*    IF R6 ^> R9                     /* COMPARE THE ADDRESS OF THE    *
*      THEN
@9B0     CR    @6,@9                                              0545
*      GOTO RTNCLNUP;                /* TERM PCE BEING TESTED WITH    *
         BC    12,RTNCLNUP                                        0546
*                                    /* THE PRIOR PCE - IF THE        *
*                                    /* CURRENT TERM IS NOT THE       *
*                                    /* GREATER GOTO 'CLEANUP'.       *
*    R9 = R6;                        /* UPDATE PRIORPCE BEFORE THE    *
         LR    @9,@6                                              0547
*    R14 = GOREGSV;                  /* RESTORE RETURN ADDR           *
         L     @E,616(0,@B)                                       0548
*    END TERMOCK;                    /* END OF PROCEDURE TERMOCK      *
@EL07    BCR   15,@E                                              0549
*    END IKJEFP50;
*
* IKJEFP60:                          /* TERM PROCESSOR                *
*    PROC OPTIONS(DONTSAVE,NOSAVEAREA); /* MAIN ENTRY POINT           *
IKJEFP60 EQU   *                                                  0551
*
*    /*****************************************************************
*    /*                                                               *
*    /* REGISTER DECLARES AND RESTRICTIONS                            *
*    /*                                                               *
*    /*****************************************************************
*
*    DCL
*          PARS2BAS REG(2) PTR(31);  /* TERM BASE REGISTER            *
*    DCL
*          OTHBASE REG(3) PTR(31);   /* OPER/RESVWD BASE REG          *
*    DCL
*          ADDCDE REG(15) PTR(31);   /* SUBROUTINE ADDR AND RET/CODE  *
*    RESTRICT (R4,R5);               /* KEEP COMMAND PTRS INTACT      *
*    RESTRICT (R6);                  /* KEEP PTR TO NEXT PCE          *
*    RESTRICT (PWAREG);              /* KEEP WORKAREA INTACT          *
*    RESTRICT (LINK2);               /* SAVE LINKAGE REG              *
*
*    /*****************************************************************
*    /*                                                               *
*    /* COMPILE TIME VARIBLES                                         *
*    /*                                                               *
*    /*****************************************************************
*
*
*    /*****************************************************************
*    /*                                                               *
*    /* TABLES AND WORKAREAS THE FOLLOWING AREA CONTAIN CONTROL INFO  *
*    /* FOR GENSCAN                                                   *
*    /*                                                               *
*    /*****************************************************************
*
*    DCL
*          1 WORKAR AUTO,            /* GENSCAN CONTROL OPTIONS       *
*            2 GOPTION CHAR(1),      /* SCAN OPTIONS                  *
*            2 GFIRST CHAR(1),       /* FIRST CHAR TYPE               *
*            2 GOTHER CHAR(1),       /* OTHER CHAR TYPE               *
*            2 GOMAX CHAR(1);        /* MAXIMUN SCAN LENGTH           *
*    DCL
*          1 WORKAR1 BASED(TANC),    /* AREA FOR QUALIFIER PDE        *
*            2 QNAMEPTR PTR(31),     /* PTR TO DATA NAME              *
*            2 QNGTH4 PTR(8),        /* LENGTH OF DATA NAME           *
*            2 QRESV CHAR(3),        /* RESERVE FIELD                 *
*            2 QATAPTRH PTR(32);     /* SPACE FOR LAST INDICATOR      *
*    DCL
*          PTRARE PTR(31) BASED(CHAINPTR); /* DSECT FOR CHAINPTR AREA *
*    DCL
*          COMBUFA CHAR(2) BASED(R4);     /* TWO BYTE COMMAND BUFFER  *
*    DCL
*          VCOMBF CHAR(1) BASED(R4-1);       /* PREV INPUT CHAR       *
*    DCL
*       CNSTTEMP CHAR(20) BASED(PDEPTR); /*PDE TO ZERO IF TYPE ANY    *
*
*    /*****************************************************************
*    /*                                                               *
*    /* MAP OF VARIABLE PDE                                           *
*    /*                                                               *
*    /*****************************************************************
*
*    DCL
*          1 VARIPDE BASED(ADDR(TEMPPDE)), /* PDE MAP                 *
*            2 * CHAR(18),           /* DUMMY AREA                    *
*            2 NUMSUB1 CHAR(1);      /* NUMBER OF SUBSCRIPTS          *
*    DCL
*          BUMP INTERNAL LABEL LOCAL; /* INTERNAL PROCDURE TO UPDATE
*                                       INPUT POINTER                 *
*
*    /*****************************************************************
*    /*                                                               *
*    /* THIS ROUTINE PERFORMS INITIALIZATION FUNCTIONS, INTERROGATES  *
*    /* THE PCE TYPE(CONST, STMT, VAR, OR ANY) AND BRANCHES TO THE    *
*    /* CORRESPONDING ROUTINE.                                        *
*    /*                                                               *
*    /*****************************************************************
*
*
* TERMBGN:
*    COBOLMOD='1'B;                  /* TURN ON COBOL SWITCH          *
TERMBGN  OI    599(@B),B'10000000'                                0567
*    PRMTSCAN='0'B;                  /* MISSING PARM PROMPTED FOR     *
         NI    600(@B),B'11111011'                                0568
*    PFENDSET='0'B;                  /* SET POP STACK SWITCH TO
*                                       CONTROL VARIABLE SCAN         *
         NI    179(@B),B'11111011'                                0569
*    PREVPDEL=0;                     /* LIST PTR TO ZERO              *
         SR    @F,@F                                              0570
         ST    @F,448(0,@B)                                       0570
*    RC16='0'B;                      /* TURN VALIDITY CHECK BIT OFF   *
         NI    599(@B),B'11111110'                                0571
*    PDEPTR=ADDR (TEMPPDE);          /* SET PDE PTR TO TEMPORARY PDE  *
         LA    @F,332(0,@B)                                       0572
         ST    @F,564(0,@B)                                       0572
*    CBLNKSV1=GOREG;                 /* SAVE RETURN ADDRESS           *
         ST    @E,548(0,@B)                                       0573
*    TERMXPCE=R6;                    /* SAVE CURRENT PCE POINTER      *
         ST    @6,528(0,@B)                                       0574
*    ADDCDE=5;                       /* ADDR OF SKIPB IN REG 15       *
         LA    @F,5                                               0575
*    CALL LINKRET;                   /* BRANCH TO PARSE2              *
         BAL   @E,LINKRET                                         0576
*    GOTO PROMPT01;                  /* BRANCH ON ZERO RETURN         *
         BC    15,PROMPT01                                        0577
*
*    /*****************************************************************
*    /*                                                               *
*    /* GENERATE BRANCH AROUND SETTING PRMTSCAN IF MORE               *
*    /*                                                               *
*    /*****************************************************************
*
*    GEN (BC   15,OPER);
         BC   15,OPER
         DS    0H
*
*    /*****************************************************************
*    /*                                                               *
*    /* TEST TO DETERMINE IF IKJOPER HAS BEEN ENTERED                 *
*    /*                                                               *
*    /*****************************************************************
*
*
* OPER1:
*    PRMTSCAN='1'B;                  /* RETURN HERE AFTER DATA
*                                       RETURNED FROM PROMPT - TURN
*                                       PRMTSCAN ON FOR INVALID       *
OPER1    OI    600(@B),B'00000100'                                0579
*
* OPER:
*    IF OPERMODE='1'B                /* IS THIS IN OPER MODE ?        *
*      THEN                          /* IF YES                        *
OPER     TM    599(@B),B'01000000'                                0580
         BC    12,@9AF                                            0580
*      DO;                           /* TEST FOR SUBSCRIPTS           *
*
*        /*************************************************************
*        /*                                                           *
*        /* TEST TO DETERMINE IF SUBSCRIPTS ARE ALLOWED               *
*        /*                                                           *
*        /*************************************************************
*
*
* PDESIZ:
*        IF SUBSCRP='1'B             /* ARE SUBSCRIPTS ALLOWED ?      *
*          THEN                      /* IF YES                        *
PDESIZ   TM    1(@6),B'00010000'                                  0582
         BC    12,@9AE                                            0582
*          DO;                       /* SET LENGTHS                   *
*            PPCOUNT=79;             /* DATA SIZE EQUAL 3 SUBSCRIPTS  *
         MVI   417(@B),79                                         0584
*            GOTO INVPSAV;           /* BRANCH TO UPDATE INPUT PTR    *
         BC    15,INVPSAV                                         0585
*          END;                      /* IF SUBSCRIPTS NOT ALLOWED     *
*        PPCOUNT=19;                 /* DATA SIZE EQUAL 1 SUBSCRIPT   *
@9AE     MVI   417(@B),19                                         0587
*
*        /*************************************************************
*        /*                                                           *
*        /* CHECK FOR RANGE PROCESSING                                *
*        /*                                                           *
*        /*************************************************************
*
*
* INVPSAV:
*        IF RNGEVAL1='1'B            /* TEST FOR FIRST VAL OF RANGE   *
*          THEN                      /* IF YES                        *
INVPSAV  TM    177(@B),B'01000000'                                0588
         BC    12,@9AD                                            0588
*          DO;                       /* SET UP FOR TYPETEST           *
*          IF R4=>ENDINPUT           /* IF XINPUT IS AT ENDINPUT
*                                                              A00996 *
*           THEN                     /* OR AT A SEMICOLON             *
         C     @4,144(0,@B)                                       0590
*            GOTO RANGERR1;          /* IS AN ERROR                   *
         BC    10,RANGERR1                                        0591
*          IF COMBUF=';'             /* IS IT A SEMI COLON            *
*           THEN                     /* IF SO IS AN                   *
         CLI   0(@4),C';'                                         0592
*            GOTO RANGERR1;          /* ERROR TOO                     *
         BC    08,RANGERR1                                        0593
*            ADDCDE=8;               /* ADDR OF TYPE TEST REG 15      *
         LA    @F,8                                               0594
*            R1='08'X;               /* BLK-TAB-COMMA MASK REG 1      *
         LA    @1,X'08'                                           0595
*            CALL LINKRET;           /* BRANCH TO PARSE2              *
         BAL   @E,LINKRET                                         0596
*            GOTO INVPSAV1;          /* BRANCH AROUND                 *
         BC    15,INVPSAV1                                        0597
* RANGERR1:
*            ERRORBIT='1'B;          /* SET ERROR BIT                 *
RANGERR1 OI    599(@B),B'00001000'                                0598
*            PFNOPOP='1'B;           /* PREVENT STACK POPPING         *
         OI    179(@B),B'00000010'                                0599
*            CALL TSTRNGE;           /* CHECK RANGE            A00996 *
         L     @F,@V5              ADDRESS OF TSTRNGE             0600
         BALR  @E,@F                                              0600
*            GOTO EXIT;              /* BRANCH FOR ERROR PROC         *
         BC    15,EXIT                                            0601
*          END;                      /* IF NOT RANGE PROCESSING       *
*
* INPUTUP:
*        R4=R4+1;                    /* PTR TO NEXT CHAR IN BUFFER    *
@9AD     EQU   *                                                  0603
INPUTUP  AH    @4,@D2                                             0603
*        INVPSAVE=R4;                /* RESET INVPSAVE TO BEG OF THIS
*                                       TERM                          *
         ST    @4,300(0,@B)                                       0604
*
*        /*************************************************************
*        /*                                                           *
*        /* IF THE ERROR BIT IS NOT ON, SET INVPSAVE AND PRMTPTR EQUAL*
*        /* TO XINPUT. RANGES ARE NOT ALLOWED WITHIN AN EXPRESSION.   *
*        /* THE ERRORBIT CANNOT BE ON UNLESS HAVE COME INTO           *
*        /* INITIALIZATION CODE AFTER SCANNING PART OF A RANGE, I.E., *
*        /* THE FIRST VALUE.                                          *
*        /*                                                           *
*        /*************************************************************
*
*
* INVPSAV1:                          /* IF ERROR BIT IS               *
*        IF ERRORBIT^='1'B           /* NOT ON,                       *
*          THEN                      /* WANT TO SET INVPSAVE AND      *
INVPSAV1 TM    599(@B),B'00001000'                                0605
         BC    01,@9AC                                            0605
*          DO;                       /* PRMTPTR                       *
*            PRMTPTR=R4;             /* BEGINNING OF VARIABLE         *
         ST    @4,584(0,@B)                                       0607
*          END;                      /* END SET OF POINTERS           *
*
*        /*************************************************************
*        /*                                                           *
*        /* DETERMINE PCE TYPE AND BRANCH TO SUBROUTINE               *
*        /*                                                           *
*        /*************************************************************
*
*
* PCETYPE1:
*        IF VAR='1'B                 /* IF TYPE EQUAL VARIABLE        *
*          THEN                      /* IF YES                        *
@9AC     EQU   *                                                  0609
PCETYPE1 TM    6(@6),B'01000000'                                  0609
*          GOTO IKJEFP6V;            /* BRANCH TO VARIABLE RTN        *
         BC    01,IKJEFP6V                                        0610
*
*        /*************************************************************
*        /*                                                           *
*        /* TEST FOR TYPE EQUAL STATEMENT NUMBER                      *
*        /*                                                           *
*        /*************************************************************
*
*        IF STMT='1'B                /* IF TYPE EQUAL STATEMENT NO.   *
*          THEN                      /* IF YES                        *
         TM    6(@6),B'10000000'                                  0611
*          GOTO IKJEFP6S;            /* BRANCH TO STATEMENT RTN       *
         BC    01,IKJEFP6S                                        0612
*
*        /*************************************************************
*        /*                                                           *
*        /* TEST FOR TYPE EQUAL CONSTANT                              *
*        /*                                                           *
*        /*************************************************************
*
*        IF CNST='1'B                /* IF TYPE EQUAL CONSTANT        *
*          THEN                      /* IF YES                        *
         TM    6(@6),B'00100000'                                  0613
*          GOTO SUBTEST;             /* BRANCH TO CONSTANT RTN        *
         BC    01,SUBTEST                                         0614
*
*        /*************************************************************
*        /*                                                           *
*        /* TEST FOR TYPE EQUAL ANY                                   *
*        /*                                                           *
*        /*************************************************************
*
*        IF ANY='1'B                 /* IF TYPE EQUAL ANY             *
*          THEN                      /* IF YES                        *
         TM    6(@6),B'00010000'                                  0615
*          GOTO SUBTEST;             /* BRANCH TO CONSTANT RTN        *
         BC    01,SUBTEST                                         0616
*      END;                          /* IF OPER MODE NOT SET          *
*    ADDCDE=11;                      /* ADDR OF LISTT IN REG 15       *
@9AF     LA    @F,11                                              0618
*    CALL LINKRET;                   /* BRANCH TO PARSE2              *
         BAL   @E,LINKRET                                         0619
*    GOTO VARCODE3;                  /* GOTO RESET PTRS SO WON'T MISS
*                                       END OF LIST                   *
         BC    15,VARCODE3                                        0620
*    GEN (BC  15,PDESIZ);            /* BRANCH TO SET PDE SIZE        *
         BC  15,PDESIZ
         DS    0H
*
* VARCODE3:                          /* MUST RESET XINPUTB SO         *
*    R5=PPOINTR+1;                   /* END OF LIST WILL NOT BE MISSED*
VARCODE3 LA    @5,1                                               0622
         A     @5,148(0,@B)                                       0622
*    GOTO VARCODE4;                  /* ISSUE INVALID MESSAGE         *
         BC    15,VARCODE4                                        0623
*
* PROMPT01:                          /* DETERMINE IF PARM OPTIONAL    *
*    ADDCDE=2;                       /* ADDR OF PROMPTQ IN REG 15     *
PROMPT01 LA    @F,2                                               0624
*    CALL LINKRET;                   /* BRANCH TO PARSE2              *
         BAL   @E,LINKRET                                         0625
*    GOTO OPER;                      /* TEST FOR OPER MODE            *
         BC    15,OPER                                            0626
*
*    /*****************************************************************
*    /*                                                               *
*    /* TEST TO DETERMINE IF IKJOPER HAS BEEN ENTERED                 *
*    /*                                                               *
*    /*****************************************************************
*
*
* NTRQEXT:
*    IF OPERMODE='1'B                /* IS THIS OPER MODE ?           *
*      THEN                          /* IF YES                        *
NTRQEXT  TM    599(@B),B'01000000'                                0627
         BC    12,@9AB                                            0627
*      DO;                           /* RETURN TO CALLER              *
*        GOREG=CBLNKSV1;             /* RESTORE REG 14                *
         L     @E,548(0,@B)                                       0629
*        RETURN;                     /* RETURN TO CALLER              *
         BC    15,@EL08                                           0630
*      END;                          /* IF OPERMODE NOT SET           *
*    GOTO UPDTPCE;                   /* EXIT TO UPDATE PCE            *
*
* OPERTEST:                          /* ENTRY AFTER PROMPT RESPONSE   *
*    R6=TERMXPCE;                    /* LOAD PRIMARY PCE              *
OPERTEST L     @6,528(0,@B)                                       0633
*
*    /*****************************************************************
*    /*                                                               *
*    /* DETERMINE IF PROCESSING PROMPT OR DEFAULT DATA                *
*    /*                                                               *
*    /*****************************************************************
*
*    PDEPTR=ADDR (TEMPPDE);          /* RESET PDEPTR FOR RANGE        *
         LA    @F,332(0,@B)                                       0634
         ST    @F,564(0,@B)                                       0634
*    IF PFNULL='1'B                  /* NULL LINE RETURNED ?          *
*      THEN                          /* IF YES                        *
         TM    178(@B),B'00001000'                                0635
         BC    12,@9AA                                            0635
*      DO;                           /* SET SWITCH OFF                *
*        PFNULL='0'B;                /* TURN SWITCH OFF               *
         NI    178(@B),B'11110111'                                0637
*        IF PFLIST='1'B              /* IF PROCESSING A LIST, MUST    *
*          THEN                      /* GO TO PROCESSOR TO EITHER     *
         TM    176(@B),B'10000000'                                0638
*          GOTO LISTEST;             /* CATCH NEXT ELEMENT OF THE LIST
*                                       OR THE END OF LIST            *
         BC    01,LISTEST                                         0639
*        GOTO NTRQEXT;               /* PICK UP NEXT PCE              *
         BC    15,NTRQEXT                                         0640
*      END;                          /* IF SWITCH NOT ON              *
*    GOTO OPER;                      /* TEST FOR OPER MODE            *
*
*    /*****************************************************************
*    /*                                                               *
*    /* THE STATEMENT PROCESSING ROUTINE IS ENTERED WHEN THE TYPE     *
*    /* PARAMETER IN THE CURRENT PCE IS STMT.                         *
*    /*                                                               *
*    /*****************************************************************
*
*
* IKJEFP6S:                          /* ENTRY FOR TYPE EQUAL STMT     *
*
*    /*****************************************************************
*    /*                                                               *
*    /* TEST FOR OPER MODE                                            *
*    /*                                                               *
*    /*****************************************************************
*
*    IF OPERMODE^='1'B               /* IS THIS OPER MODE ?           *
*      THEN                          /* IF NO                         *
IKJEFP6S TM    599(@B),B'01000000'                                0643
*      GOTO CONT;                    /* BRANCH AROUND                 *
         BC    12,CONT                                            0644
*
*    /*****************************************************************
*    /*                                                               *
*    /* TEST FOR CHAIN TERM                                           *
*    /*                                                               *
*    /*****************************************************************
*
*    IF CHAINTRM='1'B                /* CHAIN TERM BIT ON ?           *
*      THEN                          /* IF YES                        *
         TM    600(@B),B'00010000'                                0645
*      GOTO CONT;                    /* BRANCH AROUND                 *
*    GOTO COD24;                     /* BRANCH TO ISSUE ERROR MSG     *
         BC    14,COD24                                           0647
*
* CONT:
*    ADDCDE=8;                       /* ADDR OF TYPETEST IN REG 15    *
CONT     LA    @F,8                                               0648
*    R1='C0'X;                       /* ALPHA MASK IN REG 1           *
         LA    @1,X'C0'                                           0649
*    CALL LINKRET;                   /* BRANCH TO PARSE2              *
         BAL   @E,LINKRET                                         0650
*    GEN;                            /* RETURN BRANCHES               *
         BC  15,STRINPTR               BRANCH AROUND
         BC  15,STRPGMID               BRANCH TO STORE PGM ID
         DS    0H
*
* STRINPTR:                          /* STORE INPUT POINTER           *
*    DATAPTRA=R4;                    /* STOR INPUT PTR AS LINE NUMBER
*                                       PTR IN PDE                    *
STRINPTR L     @1,564(0,@B)        
         ST    @4,12(0,@1)                                        0652
*
* NUMCK1:
*    ADDCDE=8;                       /* ADDR OF TYPE TEST IN REG 15   *
NUMCK1   LA    @F,8                                               0653
*    R1='10'X;                       /* NUMERIC MASK IN REG 1         *
         LA    @1,X'10'                                           0654
*    CALL LINKRET;                   /* BRANCH TO PARSE2              *
         BAL   @E,LINKRET                                         0655
*    GOTO MAXLNGTH;                  /* CHECK LENGTH OF LINE NO.      *
         BC    15,MAXLNGTH                                        0656
* NUMCK2:                            /* BRANCH FROM PGMID      A00996
*                                       PROCESSING             A56846 *
*    DIGITCT=DIGITCT+1;              /* ADD ONE TO DATE COUNT         *
NUMCK2   LA    @F,1                                               0657
         SR    @0,@0                                              0657
         IC    @0,596(0,@B)                                       0657
         AR    @F,@0                                              0657
         STC   @F,596(0,@B)                                       0657
*    R4=R4+1;                        /* POINT TO NEXT CHAR IN BUFFER  *
         AH    @4,@D2                                             0658
*
*    /*****************************************************************
*    /*                                                               *
*    /* DETERMINE IF END OF BUFFER HAS BEEN REACHED                   *
*    /*                                                               *
*    /*****************************************************************
*
*    IF R4=>ENDINPUT                 /* IS THIS END OF INPUT BUFFER
*                                                              A00996 *
*      THEN                          /* IF YES                        *
         C     @4,144(0,@B)                                       0659
         BC    04,@9A9                                            0659
*      DO;                           /* CHECK LENGTH OF LINE NO.      *
*
*        /*************************************************************
*        /*                                                           *
*        /* TEST LINE NUMBER FOR GREATER THAN SIX NUMERIC DIGIT       *
*        /*                                                           *
*        /*************************************************************
*
*
* MAXLNGTH:
*        IF DIGITCT>6                /* LINE NO. GREATER THAN 6 ?     *
*          THEN                      /* IF YES                        *
MAXLNGTH CLI   596(@B),6                                          0661
*          GOTO SEPSCAN;             /* SCAN FOR A SEPARATOR          *
         BC    02,SEPSCAN                                         0662
*
*        /*************************************************************
*        /*                                                           *
*        /* DETERMINE IF THIS IS THE FIRST CHARACTER IN BUFFER        *
*        /*                                                           *
*        /*************************************************************
*
*        IF R4=INVPSAVE              /* FIRST CHAR IN INPUT BUFFER    *
*          THEN                      /* IF YES                        *
         C     @4,300(0,@B)                                       0663
         BC    07,@9A8                                            0663
*          DO;                       /* TEST FOR LIST PROCESSING      *
*
*            /*********************************************************
*            /*                                                       *
*            /* DETERMINE IF THIS PROCESSING IS FOR A LIST            *
*            /*                                                       *
*            /*********************************************************
*
*            IF PFLIST='1'B          /* IS THIS LIST PROCESSING       *
*              THEN                  /* IF YES                        *
         TM    176(@B),B'10000000'                                0665
*              GOTO SEPSCAN;         /* SCAN FOR A SEPARATOR          *
         BC    01,SEPSCAN                                         0666
*
*            /*********************************************************
*            /*                                                       *
*            /* DETERMINE IF PROCESSING FIRST VALUE OF RANGE          *
*            /*                                                       *
*            /*********************************************************
*
*            IF RNGEVAL1='1'B        /* IS THIS RANGE PROCESSING      *
*              THEN                  /* IF YES                        *
         TM    177(@B),B'01000000'                                0667
*              GOTO SEPSCAN;         /* SCAN FOR A SEPARATOR          *
         BC    01,SEPSCAN                                         0668
*            GOTO PROMPT05;          /* DETERMINE IF PARAMETER REQ    *
         BC    15,PROMPT05                                        0669
*          END;                      /* IF NOT FIRST CHAR OF BUFFER   *
*
*        /*************************************************************
*        /*                                                           *
*        /* DETERMINE IF THIS IS THE 1ST CHARACTER OF LINE NO.        *
*        /*                                                           *
*        /*************************************************************
*
*        IF R4=DATAPTRA              /* FIRST CHAR OF LINE NO. ?      *
*          THEN                      /* IF YES                        *
@9A8     L     @1,564(0,@B)        
         C     @4,12(0,@1)                                        0671
*          GOTO SEPSCAN;             /* SCAN FOR A SEPARATOR          *
         BC    08,SEPSCAN                                         0672
*        LNGTH2=DIGITCT;             /* STORE LINE NO. SIZE IN PDE    *
         MVC   1(1,@1),596(@B)                                    0673
*        DIGITCT=0;                  /* ZERO DATA COUNT               *
         MVI   596(@B),0                                          0674
*
*        /*************************************************************
*        /*                                                           *
*        /* CHECK INPUT LINE FOR PERIOD AFTER LINE NO.                *
*        /*                                                           *
*        /*************************************************************
*
*        IF R4=>ENDINPUT             /* IF AT END OF BUFFER    A00996 *
*          THEN                      /* GO TO END              A00996 *
         C     @4,144(0,@B)                                       0675
*           GOTO RANGECK;            /* OF STATEMENT           A00996
*                                       PROCESSING             A00996 *
         BC    10,RANGECK                                         0676
*        IF COMBUF='4B'X             /* PERIOD AFTER LINE NO.         *
*          THEN                      /* IF YES                        *
         CLI   0(@4),X'4B'                                        0677
*          GOTO BUMP1;               /* CHECK NEXT CHARACTER          *
         BC    08,BUMP1                                           0678
*        GOTO RANGECK;               /* SET UP RANGE PROCESSING       *
         BC    15,RANGECK                                         0679
*      END;                          /* IF END OF BUFFER NOT REACHED  *
*
*    /*****************************************************************
*    /*                                                               *
*    /* HAS THE END OF A STATEMENT BEEN REACHED ?                     *
*    /*                                                               *
*    /*****************************************************************
*
*    IF COMBUF=';'                   /* INPUT LINE EQUAL SEMICOLON    *
*      THEN                          /* IF YES                        *
@9A9     CLI   0(@4),C';'                                         0681
*      GOTO MAXLNGTH;                /* CHECK LENGTH OF LINE NO.      *
         BC    08,MAXLNGTH                                        0682
*    GOTO NUMCK1;                    /* TEST FOR NUMERIC CHARACTER    *
         BC    15,NUMCK1                                          0683
*    /*****************************************************************
*    /* THE STRPGMID ROUTINE SILL SCAN THE INPUT LINE TO ENSURE THAT  *
*    /* A PROGRAM ID PRECEEDS A LINE NUMBER.  THIS MUST BE DONE IN    *
*    /* ORDER TO ENSURE THAT THE PARAMETER IS INDEED A STATEMENT      *
*    /* NUMBER OR SHOULD BE PARSED ON THE NEXT PCE.  IF A VALID PGMID *
*    /* IS FOUND, FOLLOWED BY A NUMERIC, THE PARAMETER IS ASSUMED     *
*    /* TO BE A STATEMENT NUMBER.  IF THE INPUT LINE DOES NOT CONTAIN *
*    /* A PGMID.NUMERIC, THE PARAMETER (STATEMENT NUMBER) IS ASSUMED  *
*    /* MISSING AND THE PROMPT ROUTINE WILL BE ENTERED TO EITHER      *
*    /* PROMPT THE USER WITH THE "ENTER ..." MESSAGE OR IF NOT        *
*    /* REQUIRED, GO THE PROCESS THE PARAMETER ON THE NEXT PCE        *
*    /*****************************************************************
* STRPGMID:                          /* SCAN FOR VALID DATANAME       *
*    FIRSTNAM='0'B;                  /* INITIALIZE SWITCH USED IN SCAN*
STRPGMID NI    601(@B),B'01111111'                                0684
*    DIGITCT=DIGITCT+1;              /* INITIALIZE DIGITCOUNT - THE
*                                       FIRST CHAR WAS FOUND TO BE
*                                       ALPHABETIC                    *
         LA    @F,1                                               0685
         SR    @0,@0                                              0685
         IC    @0,596(0,@B)                                       0685
         AR    @F,@0                                              0685
         STC   @F,596(0,@B)                                       0685
* CHK:                               /* CHECK OTHER CHARS FOR VALIDITY*
*    R4=R4+1;                        /* UPDATE TO NEXT CHARACTER      *
CHK      AH    @4,@D2                                             0686
*    IF R4=>ENDINPUT                 /* IF AT END OF BUFFER, THIS     *
*      THEN                          /* IS NOT A STATEMENT NUMBER     *
         C     @4,144(0,@B)                                       0687
*        GOTO REJECT;                /* CONSIDER JUST LIKE INVALID
*                                       FIRST CHARACTER               *
         BC    10,REJECT                                          0688
*    IF COMBUF=';'                   /* IF INPUT POINTING TO SEMI     *
*      THEN                          /* TREAT JUST LIKE               *
         CLI   0(@4),C';'                                         0689
*        GOTO REJECT;                /* EOB                           *
         BC    08,REJECT                                          0690
*    IF FIRSTNAM='1'B                /* IF FIRST NAME SWITCH ON WE    *
*      THEN                          /* ARE LOOKING AT WHAT SHOULD    *
         TM    601(@B),B'10000000'                                0691
         BC    12,@9A7                                            0691
*        DO;                         /* BE A NUMERIC                  *
*          FIRSTNAM='0'B;            /* TURN CONTROL SWITCH OFF       *
         NI    601(@B),B'01111111'                                0693
*          GOTO NUMERCK;             /* GO MAKE SURE NUMERIC FOLLOWS  *
         BC    15,NUMERCK                                         0694
*        END;                        /* WHAT APPEARED TO BE A VALID
*                                       PGMID PART OF A STATEMENT
*                                       NUMBER - IF NOT NUMERIC, WILL
*                                       ASSUME STATEMENT NUMBER WAS
*                                       NOT ENTERED                   *
*    IF DIGITCT>8                    /* IF MORE THAN EIGHT CHARS      *
*      THEN                          /* SCANNED IS NOT A PGMID        *
@9A7     CLI   596(@B),8                                          0696
*        GOTO REJECT;                /* PORTION OF A STATEMENT NUMBER
*                                       CONSIDER THE STATEMENT NUMBER
*                                       NOT ENTERED                   *
         BC    02,REJECT                                          0697
*    ADDCDE=8;                       /* IF STILL IN PGMID SCAN GO     *
         LA    @F,8                                               0698
*    R1='D0'X;                       /* TO TYPETEST TO SEE IF VALID   *
         LA    @1,X'D0'                                           0699
*    CALL LINKRET;                   /* CHAR FOR A PGMID              *
         BAL   @E,LINKRET                                         0700
*    GOTO PERCHK;                    /* IF NOT VALID, CHECK FOR PERIOD*
         BC    15,PERCHK                                          0701
*    GEN;                            /* GENERATE PROPER BRANCHES      *
      BC  15,STRPGMID               IF VALID, CONTINUE CHECK
         DS    0H
* PERCHK:                            /* CHECK - MAKE SURE INVALID
*                                       CHAR IS A PERIOD              *
*    IF COMBUF^='4B'X                /* IF NOT PERIOD, IS NOT A VALID *
*      THEN                          /* PGMID, DONSIDER THE STATEMENT *
PERCHK   CLI   0(@4),X'4B'                                        0703
*        GOTO REJECT;                /* NUMBER MISSING                *
         BC    07,REJECT                                          0704
*    FIRSTNAM='1'B;                  /* INDICATE NUMERIC MUST FOLLOW  *
         OI    601(@B),B'10000000'                                0705
*    GOTO CHK;                       /* GO CHECK FOR VALID CHARACTER  *
         BC    15,CHK                                             0706
* NUMERCK:                           /* MAKE SURE NUMERIC AFER PGMID  *
*    R1='10'X;                       /* PLACE NUMERIC MASK IN R1      *
NUMERCK  LA    @1,X'10'                                           0707
*    ADDCDE=8;                       /* FOR TYPETEST                  *
         LA    @F,8                                               0708
*    CALL LINKRET;                   /* CHECK FOR NUMERIC             *
         BAL   @E,LINKRET                                         0709
*    GOTO REJECT;                    /* IF +0 - NOT NUMERIC - CONSIDER
*                                       THAT THE PARAMETER IS NOT
*                                       A STATEMENT NUMBER            *
         BC    15,REJECT                                          0710
*    DATAPTR=INVPSAVE;               /* IF NUMERIC, PARAMETER IS A
*                                       STATEMENT NUMBER - FILL IN
*                                       PDE WITH POINTER TO PGMID
*                                       PORTION OF STATEMENT NUMBER   *
         L     @1,564(0,@B)        
         MVC   8(4,@1),300(@B)                                    0711
*    LNGTH1=DIGITCT;                 /* FILL IN LENGTH OF PGMID       *
         MVC   0(1,@1),596(@B)                                    0712
*    DIGITCT=0;                      /* ZERO DIGIT COUNT              *
         MVI   596(@B),0                                          0713
*    DATAPTRA=R4;                    /* FILL IN POINTER TO LINE
*                                       NUMBER IN PDE                 *
         L     @1,564(0,@B)        
         ST    @4,12(0,@1)                                        0714
*    GOTO NUMCK2;                    /* GO TO SCAN REST OF STATEMENT
*                                       NUMBER BEGINNING WITH 2ND
*                                       CHAR OF LINE NUMBER           *
         BC    15,NUMCK2                                          0715
*  REJECT:                           /* PARAMETER NOT A VALID STATE-
*                                       MENT NUMBER - MUST PARSE ON
*                                       NEXT PCE                      *
*    FIRSTNAM='0'B;                  /* SET CONTROL SWITCH OFF        *
REJECT   NI    601(@B),B'01111111'                                0716
*    DIGITCT=0;                      /* REINITIALIZE ALL FIELDS USED  *
         MVI   596(@B),0                                          0717
*    R4=INVPSAVE;                    /* REINITIALIZE INPUT POINTER TO
*                                       BEGINNING OF PARAMETER SO WILL
*                                       GET PUSHED ON STACK           *
         L     @4,300(0,@B)                                       0718
*    GOTO MAXLNGTH;                  /* GO TO ROUTINE WHICH WILL GO
*                                       PROMPT WITH "ENTER.... IF THE
*                                       STATEMENT NUMBER IS REQUIRED  *
         BC    15,MAXLNGTH                                        0719
* SEPSCAN:
*    /*****************************************************************
*    /*                                                               *
*    /* DETERMINE IF END OF BUFFER HAS BEEN REACHED                   *
*    /*                                                               *
*    /*****************************************************************
*    IF R4=>ENDINPUT                 /* IS THIS END OF BUFFER  A00996 *
*      THEN                          /* IF YES, CHECK FOR      A00996 *
SEPSCAN  C     @4,144(0,@B)                                       0720
*        GOTO SEPFOUND;              /* LIST PROCESSING        A00996 *
         BC    10,SEPFOUND                                        0721
*    ADDCDE=8;                       /* ADDR OF TYPETEST IN REG 15    *
         LA    @F,8                                               0722
*    R1='08'X;                       /* SEPARATOR MASK IN REG 1       *
         LA    @1,X'08'                                           0723
*    CALL LINKRET;                   /* BRANCH TO PARSE2              *
         BAL   @E,LINKRET                                         0724
*    GEN;                            /* RETURN BRANCHES               *
         BC  15,CKEND                  CHECK FOR END OF BUFFER
         BC  15,SEPFOUND               CHECK FOR LIST PROCESSING
         DS    0H
*
*    /*****************************************************************
*    /*                                                               *
*    /* HAS THE END OF A STATEMENT BEEN REACHED ?                     *
*    /*                                                               *
*    /*****************************************************************
*
* CKEND:                             /* END OF STATEMENT       A00996 *
*    IF COMBUF=';'                   /* INPUT LINE EQUAL SEMICOLON    *
*      THEN                          /* IF YES                        *
CKEND    CLI   0(@4),C';'                                         0726
*      GOTO SEPFOUND;                /* CHECK FOR LIST PROCESSING     *
         BC    08,SEPFOUND                                        0727
*    R4=R4+1;                        /* POINT TO NEXT INPUT CHAR      *
         AH    @4,@D2                                             0728
*    GOTO SEPSCAN;                   /* BRANCH TO TYPE TEST           *
         BC    15,SEPSCAN                                         0729
*
* SEPFOUND:                          /* RESET INPUT POINTER           *
*    R5=R4;                          /* RESET INPUT POINTER           *
SEPFOUND LR    @5,@4                                              0730
*
*    /*****************************************************************
*    /*                                                               *
*    /* DETERMINE IF THIS PROCESSING IS FOR A LIST                    *
*    /*                                                               *
*    /*****************************************************************
*
*    IF PFLIST='1'B                  /* IS THIS LIST PROCESSING ?     *
*      THEN                          /* IF YES                        *
         TM    176(@B),B'10000000'                                0731
         BC    12,@9A6                                            0731
*
*        /*************************************************************
*        /*                                                           *
*        /* CHECK FOR END OF LIST EXPRESSION                          *
*        /*                                                           *
*        /*************************************************************
*
*        IF VCOMBF=')'               /* PREVIOUS CHAR EQUAL PAREN     *
*          THEN                      /* IF YES
*                                       SET XINPUTB TO CHAR AFTER     *
         LR    @1,@4                                              0732
         LR    @A,@1                                              0732
         BCTR  @A,0                                               0732
         CLI   0(@A),C')'                                         0732
         BC    07,@9A5                                            0732
*            R5=R5-1;                /* THE END OF STATEMENT          *
         BCTR  @5,0                                               0733
* ERREXIT:                           /* SET UP TO ISSUE        A00996 *
*    DIGITCT=0;                      /* SET DIGIT CT TO ZERO   A00996 *
@9A5     EQU   *                                                  0734
@9A6     EQU   *                                                  0734
ERREXIT  MVI   596(@B),0                                          0734
*    GOTO CODE4B;                    /* GO TO ISSUE PROMPT     A00996
*                                       MESSAGE                A00996 *
         BC    15,CODE4B                                          0735
*
* RANGECK:
*    CALL TSTRNGE;                   /* TEST FOR RANGE         A00996 *
RANGECK  L     @F,@V5              ADDRESS OF TSTRNGE             0736
         BALR  @E,@F                                              0736
*    GEN;                            /* RETURN BRANCHES               *
         BC  15,RANGCHK                CHECK FOR 6 PROCESSING
         BC  15,COMPDE01               SET PARM PRESENT BIT IN PDE
         DS    0H
*
*    /*****************************************************************
*    /*                                                               *
*    /* DETERMINE IF FIRST VALUE OF A RANGE HAS BEEN PROCESSED        *
*    /*                                                               *
*    /*****************************************************************
*
*
* RANGCHK:
*    IF RNGEVAL1='1'B                /* FIRST VALUE OF RANGE ?        *
*      THEN                          /* IF YES                        *
RANGCHK  TM    177(@B),B'01000000'                                0738
*      GOTO SEPSCAN;                 /* BRANCH, CHECK FOR SEPARATOR   *
         BC    01,SEPSCAN                                         0739
*
*    /*****************************************************************
*    /*                                                               *
*    /* DETERMINE IF SECOND VALUE OF RANGE HAS BEEN PROCESSED         *
*    /*                                                               *
*    /*****************************************************************
*
*    IF RNGEVAL2='1'B                /* SECOND VALUE OF RANGE ?       *
*      THEN                          /* IF YES                        *
         TM    177(@B),B'00001000'                                0740
         BC    12,@9A4                                            0740
*      DO;                           /* INDICATE PARAMETER PRESENT    *
*
* COMPDE01:
*        PARMIND='1'B;               /* SET PARM PRESENT BIT IN PDE   *
COMPDE01 L     @1,564(0,@B)        
         OI    6(@1),B'10010000'                                  0742
*        STATE='1'B;                 /* PDE TYPE EQUAL STATEMENT NO.  *
*        PPOINTR=INVPSAVE;           /* SET POINTER FOR TRANSLATION   *
         MVC   148(4,@B),300(@B)                                  0744
*        PLENGTH=R4-PPOINTR;         /* SET LENGTH OF DATA            *
         L     @F,148(0,@B)                                       0745
         LCR   @F,@F                                              0745
         AR    @F,@4                                              0745
         STH   @F,152(0,@B)                                       0745
*        ADDCDE=9;                   /* ADDR OF TRANSQ IN REG 15      *
         LA    @F,9                                               0746
*        R1=PPCOUNT;                 /* SET LENGTH IN REG 1           *
         SR    @1,@1                                              0747
         IC    @1,417(0,@B)                                       0747
*        CALL LINKRET;               /* BRANCH TO PARSE2              *
         BAL   @E,LINKRET                                         0748
*        GOTO VAREXIT;               /* EXIT VIA VARIABLE RTN         *
         BC    15,VAREXIT                                         0749
*      END;                          /* RANGE HAS NOT BEEN PROCESSED  *
*    ADDCDE=8;                       /* ADDR OF TYPE TEST IN REG 15   *
@9A4     LA    @F,8                                               0751
*    R1='08'X;                       /* BLANK-TAB-COMMA MASK IN REG1  *
         LA    @1,X'08'                                           0752
*    CALL LINKRET;                   /* BRANCH TO PARSE2              *
         BAL   @E,LINKRET                                         0753
*    GEN;                            /* BRANCH RETURNS                *
         BC  15,CHKSEM                 CHECK FOR SEMICOLON
         BC  15,COMPDE01               INDICATE PARAMETER PRESENT
         DS    0H
*
*    /*****************************************************************
*    /*                                                               *
*    /* HAS THE END OF A STATEMENT BEEN REACHED ?                     *
*    /*                                                               *
*    /*****************************************************************
*
*
* CHKSEM:
*    IF COMBUF=';'                   /* INPUT LINE EQUAL SEMICOLON    *
*      THEN                          /* IF YES                        *
CHKSEM   CLI   0(@4),C';'                                         0755
*      GOTO COMPDE01;                /* INDICATE PARAMETER PRESENT    *
         BC    08,COMPDE01                                        0756
*
*    /*****************************************************************
*    /*                                                               *
*    /* DETERMINE IF END OF BUFFER HAS BEEN REACHED                   *
*    /*                                                               *
*    /*****************************************************************
*
*    IF R4=>ENDINPUT                 /* IS THIS END OF INPUT BUFFER
*                                                              A00996 *
*      THEN                          /* IF YES                        *
         C     @4,144(0,@B)                                       0757
*      GOTO COMPDE01;                /* INDICATE PARAMETER PRESENT    *
         BC    10,COMPDE01                                        0758
*
*    /*****************************************************************
*    /*                                                               *
*    /* CHECK FOR END OF LIST EXPRESSION                              *
*    /*                                                               *
*    /*****************************************************************
*
*    IF COMBUF^=')'                  /* INPUT CHAR NOT EQUAL PAREN    *
*      THEN                          /* IF YES                        *
         CLI   0(@4),C')'                                         0759
*      GOTO SEPSCAN;                 /* CHECK FOR SEPARATOR           *
         BC    07,SEPSCAN                                         0760
*
*    /*****************************************************************
*    /*                                                               *
*    /* CHECK FOR LIST PROCESSING                                     *
*    /*                                                               *
*    /*****************************************************************
*
*    IF LIST^='1'B                   /* IF NOT LIST PROCESSING        *
*      THEN                          /* IF YES                        *
         TM    1(@6),B'10000000'                                  0761
*      GOTO SEPSCAN;                 /* CHECK FOR SEPARATOR           *
         BC    12,SEPSCAN                                         0762
*    R4=R4-1;                        /* POINT TO PREV INPUT CHAR      *
         BCTR  @4,0                                               0763
*    GOTO COMPDE01;                  /* INDICATE PARAMETER PRESENT    *
         BC    15,COMPDE01                                        0764
*
* BUMP1:
*    R4=R4+1;                        /* POINT TO NEXT INPUT CHAR      *
BUMP1    AH    @4,@D2                                             0765
*
*    /*****************************************************************
*    /*                                                               *
*    /* DETERMINE IF END OF BUFFER HAS BEEN REACHED                   *
*    /*                                                               *
*    /*****************************************************************
*
*    IF R4=>ENDINPUT                 /* IS THIS END OF INPUT BUFFER
*                                                              A00996 *
*      THEN                          /* IF YES                        *
         C     @4,144(0,@B)                                       0766
*      GOTO ERREXIT;                 /* BRANCH TO ISSUE PROMPT MSG    *
         BC    10,ERREXIT                                         0767
*
*    /*****************************************************************
*    /*                                                               *
*    /* HAS THE END OF A STATEMENT BEEN REACHED ?                     *
*    /*                                                               *
*    /*****************************************************************
*
*    IF COMBUF=';'                   /* INPUT LINE EQUAL SEMICOLON    *
*      THEN                          /* IF YES                        *
         CLI   0(@4),C';'                                         0768
*      GOTO ERREXIT;                 /* BRANCH TO ISSUE PROMPT MSG    *
         BC    08,ERREXIT                                         0769
*    ADDCDE=8;                       /* ADDR OF TYPE TEST IN REG 15   *
         LA    @F,8                                               0770
*    R1='10'X;                       /* NUMERIC MASK IN REG 1         *
         LA    @1,X'10'                                           0771
*    CALL LINKRET;                   /* BRANCH TO PARSE2              *
         BAL   @E,LINKRET                                         0772
*    GOTO SEPSCAN;                   /* CHECK FOR SEPARATOR           *
         BC    15,SEPSCAN                                         0773
*    DATAPTRB=R4;                    /* ADDR OF VERB IN PDE           *
         L     @1,564(0,@B)        
         ST    @4,16(0,@1)                                        0774
*    LNGTH3=1;                       /* LENGTH OF VERB IN PDE         *
         MVI   2(@1),1                                            0775
*    R4=R4+1;                        /* POINT TO NEXT INPUT CHAR      *
         AH    @4,@D2                                             0776
*    GOTO RANGECK;                   /* CHECK FOR RANGE PROCESSING    *
         BC    15,RANGECK                                         0777
*
* IKJEFP6C:                          /* CONSTANT PROCESSING           *
*
*    /*****************************************************************
*    /*                                                               *
*    /* THIS CONSTANT SUBROUTINE IS ENTERED WHENEVER THE PCE TYPE IS  *
*    /* 'CONST' OR 'ANY'. WHEN 'ANY'IS SPECIFIED, THE CONSTANT ROUTINE*
*    /* SCANS THE INPUT AS IF IT WERE A CONSTANT. IF A CONSTANT IS    *
*    /* FOUND, IT IS PROCESSED AS A CONSTANT. IF A VALID CONSTANT IS  *
*    /* NOT FOUND, IT IS PROCESSED AS A VARIABLE. ALL PROMPTING WILL  *
*    /* BE FOR A VARIABLE. DETERMINE IF IKJTERM IS PROCESSING A       *
*    /* SUBSCRIPT                                                     *
*    /*                                                               *
*    /*****************************************************************
*
*
* SUBTEST:
*    IF SUBSMODE='1'B                /* TERM PROCESSING A SUBSCRIPT   *
*      THEN                          /* IF YES                        *
IKJEFP6C EQU   *                                                  0778
SUBTEST  TM    599(@B),B'00100000'                                0778
         BC    12,@9A3                                            0778
*      DO;                           /* CHECK FOR ERROR MODE          *
*
*        /*************************************************************
*        /*                                                           *
*        /* DETERMINE IF IKJTERM HAS ENCOUNTERED AN ERROR             *
*        /*                                                           *
*        /*************************************************************
*
*        IF ERRORBIT='1'B            /* ERROR IN TERM PROCESSING?     *
*          THEN                      /* IF YES                        *
         TM    599(@B),B'00001000'                                0780
         BC    12,@9A2                                            0780
*          DO;                       /* CHECK FOR END OF BUFFER       *
*
*            /*********************************************************
*            /*                                                       *
*            /* DETERMINE IF END OF BUFFER HAS BEEN REACHED           *
*            /*                                                       *
*            /*********************************************************
*
*
* ENDTEST:
*            IF R4=>ENDINPUT         /* END OF INPUT BUFFER REACHED
*                                                              A00996 *
*              THEN                  /* IF YES                        *
ENDTEST  C     @4,144(0,@B)                                       0782
*              GOTO VERRBIT;         /* PROCESS AS AN ERROR           *
         BC    10,VERRBIT                                         0783
*
*            /*********************************************************
*            /*                                                       *
*            /* CHECK FOR THE END OF INPUT DATA                       *
*            /*                                                       *
*            /*********************************************************
*
*            IF COMBUF=';'           /* INPUT LINE EQUAL SEMICOLON    *
*              THEN                  /* IF YES                        *
         CLI   0(@4),C';'                                         0784
*              GOTO VERRBIT;         /* ISSUE PROMPT MSG              *
         BC    08,VERRBIT                                         0785
*
*            /*********************************************************
*            /*                                                       *
*            /* CHECK THE ELEMENT COUNT FOR MAXIMUM # SUBSCRIPTS      *
*            /*                                                       *
*            /*********************************************************
*
*
* SUBENDCK:
*            IF ELEMNCT=3            /* NUMBER SUBSCRIPTS EQUAL 3     *
*              THEN                  /* IF YES                        *
SUBENDCK CLI   597(@B),3                                          0786
         BC    07,@9A1                                            0786
*              DO;                   /* INDICATE TERM ERROR           *
*                ERRORBIT='1'B;      /* SET ERROR BIT ON              *
         OI    599(@B),B'00001000'                                0788
*                GOTO SUBERSCN;      /* RESET PDE POINTER             *
         BC    15,SUBERSCN                                        0789
*              END;                  /* NUMBER SUBSCRIPTS NOT = 3     *
*            PDEPTR=PDEPTR+20;       /* NEXT AVAILABLE SPACE IN PDE   *
@9A1     LA    @F,20                                              0791
         A     @F,564(0,@B)                                       0791
         ST    @F,564(0,@B)                                       0791
*            GOTO ALPHATST;          /* BRANCH TO TYPE TEST           *
         BC    15,ALPHATST                                        0792
*          END;                      /* IF ERROR BIT IS NOT ON        *
*        PRMTPTR=R4;                 /* SET SPECIAL MSG POINTER       *
@9A2     ST    @4,584(0,@B)                                       0794
*        GOTO ENDTEST;               /* CHECK FOR END OF BUFFER       *
         BC    15,ENDTEST                                         0795
*      END;
*
* STPDEPTR:                          /* SET PDEPTR TO TEMP PDE        *
*    PDEPTR=ADDR (TEMPPDE);          /* SET PDEPTR TO ADDR TEMPPDE    *
@9A3     EQU   *                                                  0797
STPDEPTR LA    @F,332(0,@B)                                       0797
         ST    @F,564(0,@B)                                       0797
*
* ALPHATST:                          /* CHECK FOR ALPHA CHAR          *
*    ADDCDE=8;                       /* ADDR OF TYPE TEST IN REG 15   *
ALPHATST LA    @F,8                                               0798
*    R1='C0'X;                       /* ALPHA MASK IN REG 1           *
         LA    @1,X'C0'                                           0799
*    CALL LINKRET;                   /* BRANCH TO PARS2               *
         BAL   @E,LINKRET                                         0800
*    GEN;                            /* RETURN BRANCHES               *
         BC  15,CHKQUOT                CHECK FOR '7D'X
         BC  15,RSVWDPC                CHECK FOR RESERVED WORD PCE
         DS    0H
*
*    /*****************************************************************
*    /*                                                               *
*    /* CHECK INPUT LINE FOR QUOTED STRING PROCESSING                 *
*    /*                                                               *
*    /*****************************************************************
*
*
* CHKQUOT:
*    IF COMBUF='7D'X                 /* INPUT LINE EQUAL QUOTE ?      *
*      THEN                          /* IF YES                        *
CHKQUOT  CLI   0(@4),X'7D'                                        0802
*      GOTO QSTRING1;                /* BRANCH TO QUOTED STRING RTN   *
         BC    08,QSTRING1                                        0803
*
*    /*****************************************************************
*    /*                                                               *
*    /* CHECK INPUT LINE FOR MINUS SIGN                               *
*    /*                                                               *
*    /*****************************************************************
*
*    IF COMBUF='-'                   /* INPUT CHAR EQUAL MINUS        *
*      THEN                          /* IF YES                        *
         CLI   0(@4),C'-'                                         0804
*      GOTO SETMINUS;                /* SET MINUS INDICATOR IN PDE    *
         BC    08,SETMINUS                                        0805
*    GOTO SETPLUS;                   /* SET PLUS INDICATOR IN PDE     *
         BC    15,SETPLUS                                         0806
*
*    /*****************************************************************
*    /*                                                               *
*    /* DETERMINE IF IKJTERM IS PROCESSING A SUBSCRIPT                *
*    /*                                                               *
*    /*****************************************************************
*
*
* SUBTST:
*    IF SUBSMODE='1'B                /* TERM PROCESSING A SUBSCRIPT   *
*      THEN                          /* IF YES                        *
SUBTST   TM    599(@B),B'00100000'                                0807
*      GOTO VERRBIT;                 /* SET ERROR BIT ON              *
         BC    01,VERRBIT                                         0808
*
* PCEUPDTE:                          /* UPDATE TO NEXT PCE            *
*    R6=R6+PCELNGTH;                 /* XPCE EQUL NEXT PCE            *
PCEUPDTE MVC   @TEMP2+2(2),2(@6)                                  0809
         A     @6,@TEMP2                                          0809
*    COBOLMOD='0'B;                  /* TURN OFF COBOL SWITCH         *
         NI    599(@B),B'01111111'                                0810
*    GEN (BAL  @E,@EL01);            /* ISSUE FREEMAIN                *
         BAL  @E,@EL01
         DS    0H
*    ADDCDE=19;                      /* RETRUN TO NEXTPCE SUBROUT- INE
*                                       IN PARSE                      *
         LA    @F,19                                              0812
*    CALL LINKRET;                   /* CALL RETURN ROUTINE           *
         BAL   @E,LINKRET                                         0813
*
* SETPLUS:                           /* SET PLUS INDICATOR IN PDE     *
*
*    /*****************************************************************
*    /*                                                               *
*    /* CHECK INPUT LINE FOR PLUS SIGN                                *
*    /*                                                               *
*    /*****************************************************************
*
*    IF COMBUF^='+'                  /* INPUT CHAR NOT EQUAL PLUS     *
*      THEN                          /* IF YES                        *
SETPLUS  CLI   0(@4),C'+'                                         0814
*      GOTO PERIODCK;                /* CHECK FOR PERIOD              *
         BC    07,PERIODCK                                        0815
*
* CBUMP02:
*    R4=R4+1;                        /* POINT TO NEXT INPUT CHAR      *
CBUMP02  AH    @4,@D2                                             0816
*
*    /*****************************************************************
*    /*                                                               *
*    /* CHECK FOR END OF INPUT DATA                                   *
*    /*                                                               *
*    /*****************************************************************
*
*    IF COMBUF=';'                   /* INPUT LINE EQUAL SEMICOLON    *
*      THEN                          /* IF YES                        *
         CLI   0(@4),C';'                                         0817
*      GOTO VERRBIT;                 /* ISSUE PROMPT MSG              *
         BC    08,VERRBIT                                         0818
*
*    /*****************************************************************
*    /*                                                               *
*    /* DETERMINE IF END OF BUFFER HAS BEEN REACHED                   *
*    /*                                                               *
*    /*****************************************************************
*
*    IF R4=>ENDINPUT                 /* END OF INPUT BUFFER ?  A00996 *
*      THEN                          /* IF YES                        *
         C     @4,144(0,@B)                                       0819
*      GOTO VERRBIT;                 /* ISSUE PROMPT MESSAGE          *
         BC    10,VERRBIT                                         0820
*    CONST='1'B;                     /* INDICATE A DEFINITE CONS- HAS
*                                       BEEN FOUND SO TERM WILL NOT BE
*                                       PROCESSED AS A VARIABLE       *
         L     @1,564(0,@B)        
         OI    6(@1),B'01000000'                                  0821
*
*    /*****************************************************************
*    /*                                                               *
*    /* CHECK INPUT LINE FOR A PERIOD                                 *
*    /*                                                               *
*    /*****************************************************************
*
*
* PERIODCK:                          /* SCAN INPUT CHAR FOR PERIOD    *
*    IF COMBUF='4B'X                 /* INPUT CHAR EQUAL PERIOD       *
*      THEN                          /* IF YES                        *
PERIODCK CLI   0(@4),X'4B'                                        0822
         BC    07,@9A0                                            0822
*       DO;                          /* STORE PTR TO STRING           *
*        DATAPTR=R4;                 /* PTR TO STRING                 *
         L     @1,564(0,@B)        
         ST    @4,8(0,@1)                                         0824
*        GOTO PPDSCAN;               /* STORE INPUT PTR IN PDE        *
         BC    15,PPDSCAN                                         0825
*       END;                         /* END PERIOD PROCESSING         *
*    ADDCDE=8;                       /* ADDR OF TYPE TEST IN REG 15   *
@9A0     LA    @F,8                                               0827
*    R1='10'X;                       /* NUMERIC MASK IN REG 1         *
         LA    @1,X'10'                                           0828
*    CALL LINKRET;                   /* BRANCH TO PARSE2              *
         BAL   @E,LINKRET                                         0829
*    GEN;                            /* RETURN BRANCHES               *
         BC  15,ZERTEMP                0 TEMP PDE
         BC  15,PREPDSCN               STROE DIGIT STRING PTR
         DS    0H
*
* ZERTEMP:                           /* ZERO TEMPORARY PDE            *
*    IF CONST='1'B                   /* IF A SIGN WAS ENCOUNTERED     *
*      THEN                          /* CANNOT PROCESS AS A VARIABL   *
ZERTEMP  L     @1,564(0,@B)        
         TM    6(@1),B'01000000'                                  0831
*      GOTO VERRBIT;                 /* AND IS AN ERROR               *
         BC    01,VERRBIT                                         0832
*    CNSTTEMP =                      /* ZERO CNSTTEMP                 *
*        CNSTTEMP && CNSTTEMP;       /* PDEPTR POINTS TO TEMP PDE     *
         XC    0(20,@1),0(@1)                                     0833
*
*    /*****************************************************************
*    /*                                                               *
*    /* TEST IF PCE TYPE EQUAL ANY                                    *
*    /*                                                               *
*    /*****************************************************************
*
*
* PARMTEST:                          /* TEST FOR TYPE EQUAL ANY       *
*    IF ANY = '1'B                   /* TYPE EQUAL ANY                *
*      THEN                          /* IF YES                        *
PARMTEST TM    6(@6),B'00010000'                                  0834
*      GOTO GOTOVAR;                 /* GOTO TO PREPARE FOR VARIABLE
*                                       PROCESSING                    *
         BC    01,GOTOVAR                                         0835
*
*    /*****************************************************************
*    /*                                                               *
*    /* DETERMINE IF CURRENTLY PROCESSING A LIST                      *
*    /*                                                               *
*    /*****************************************************************
*
*
* PROMPT05:                          /* TEST FOR LIST PROCESSING      *
*    IF PFLIST = '1'B                /* TEST LIST BIT IN PWA          *
*      THEN                          /* IF ON                         *
PROMPT05 TM    176(@B),B'10000000'                                0836
*      GOTO VERRBIT;                 /* SCAN TO END OF PARM           *
         BC    01,VERRBIT                                         0837
*
*    /*****************************************************************
*    /*                                                               *
*    /* DETERMINE IF IKJTERM IS PROCESSING A SUBSCRIPT                *
*    /*                                                               *
*    /*****************************************************************
*
*    IF SUBSMODE='1'B                /* TERM PROCESSING SUBSCRIPT     *
*      THEN                          /* IF YES                        *
         TM    599(@B),B'00100000'                                0838
*      GOTO VERRBIT;                 /* ERROR, FOUND END OF SUBSCRP   *
         BC    01,VERRBIT                                         0839
*
*    /*****************************************************************
*    /*                                                               *
*    /* CHECK FOR INVALID FIRST CHAR                                  *
*    /*                                                               *
*    /*****************************************************************
*
*    IF R4^=INVPSAVE                 /* INVALID FIRST CHAR ?          *
*      THEN                          /* IF NO                         *
         C     @4,300(0,@B)                                       0840
*      GOTO VERRBIT;                 /* SCAN FOR END OF PARM          *
         BC    07,VERRBIT                                         0841
*
*    /*****************************************************************
*    /*                                                               *
*    /* DETERMINE IF MISSING PROMPT MSG HAS BEEN ISSUED               *
*    /*                                                               *
*    /*****************************************************************
*
*    IF PRMTSCAN='1'B                /* MISSING PROMPT MSG ISSUED ?   *
*      THEN                          /* IF YES                        *
         TM    600(@B),B'00000100'                                0842
         BC    12,@99F                                            0842
*      DO;                           /* SCAN TILL END FOR ERROR MSG   *
*       R4=R4+1;                     /* START SCAN AFTER FIRST CHAR   *
         AH    @4,@D2                                             0844
*       GOTO VERRBIT;                /* ERROR GOTO END OF SUBSCRIPT   *
         BC    15,VERRBIT                                         0845
*      END;                          /* END INVALID PROCESSING        *
*    R4=R4-1;                        /* GET FIRST CHAR ON STACK       *
@99F     BCTR  @4,0                                               0847
*    ADDCDE=2;                       /* ADDR OF PROMPTQ IN REG 15     *
         LA    @F,2                                               0848
*    CALL LINKRET;                   /* BRANCH TO PARSE2              *
         BAL   @E,LINKRET                                         0849
*    GOTO STRPTR;                    /* STORE POINTER TO INPUT DATA   *
         BC    15,STRPTR                                          0850
*
*    /*****************************************************************
*    /*                                                               *
*    /* TEST TO DETERMINE IF IKJOPER HAS BEEN ENTERED                 *
*    /*                                                               *
*    /*****************************************************************
*
*    IF OPERMODE='1'B                /* IS THIS IN OPER MODE?         *
*      THEN                          /* IF UES                        *
         TM    599(@B),B'01000000'                                0851
*      GOTO VERRBIT;                 /* BRANCH TO ISSUE PROMPT MSG    *
         BC    01,VERRBIT                                         0852
*    GOTO PCEUPDTE;                  /* UPDATE TO NEXT PCE            *
         BC    15,PCEUPDTE                                        0853
*
* STRPTR:
*    PRMTSCAN='1'B;                  /* INDICATE PROMPT MSG ISSUED    *
STRPTR   OI    600(@B),B'00000100'                                0854
*    GOTO INPUTUP;                   /* PTR TO NEXT INPUT CHAR        *
         BC    15,INPUTUP                                         0855
*
* PPDSCAN:
*    IF DECPT='1'B                   /* IF ONE DECIMAL POINT HAS      *
*      THEN                          /* THEN A SECOND INDICATES A     *
PPDSCAN  L     @1,564(0,@B)        
         TM    7(@1),B'00100000'                                  0856
*      GOTO VERRBIT;                 /* INVALID CONSTANT              *
         BC    01,VERRBIT                                         0857
*    DATAPTRB=R4;                    /* STORE PTR TO PERIOD IN PDE    *
         ST    @4,16(0,@1)                                        0858
*    DECPT='1'B;                     /* SET DEC PTR FLAG IN PDE       *
         OI    7(@1),B'00100000'                                  0859
*
* CBUMP04:
*    R4=R4+1;                        /* POINT TO NEXT INPUT CHAR      *
CBUMP04  AH    @4,@D2                                             0860
*    IF R4=>ENDINPUT                 /* IF AT END OF BUFFER    A00996 *
*     THEN                           /* AFTER DEC. PT. IS AN   A00996 *
         C     @4,144(0,@B)                                       0861
*      GOTO VERRBIT;                 /* ERROR                  A00996 *
         BC    10,VERRBIT                                         0862
*
* CBUMP:
*    ADDCDE=8;                       /* USE TYPETEST TO DETERMINE     *
CBUMP    LA    @F,8                                               0863
*    R1='10'X;                       /* IF CHAR IS NUMERIC, IF NOT    *
         LA    @1,X'10'                                           0864
*    CALL LINKRET;                   /* MUST BE AN E OR THERE IS      *
         BAL   @E,LINKRET                                         0865
*    GOTO ETEST1;                    /* AN ERROR, GO TO CHECK FOR E   *
         BC    15,ETEST1                                          0866
*
* NUMER:
*    DIGITCT=DIGITCT+1;              /* IF WAS NUMERIC CHECK REST     *
NUMER    LA    @F,1                                               0867
         SR    @0,@0                                              0867
         IC    @0,596(0,@B)                                       0867
         AR    @F,@0                                              0867
         STC   @F,596(0,@B)                                       0867
*    R4=R4+1;                        /* UNTIL HIT NON NUMERIC         *
         AH    @4,@D2                                             0868
*    IF R4=>ENDINPUT                 /* IF AT END OF BUFFER    A00996 *
*     THEN                           /* GO TO PROCESS END      A00996 *
         C     @4,144(0,@B)                                       0869
*      GOTO MAXDIGIT;                /* OF CONSTANT            A00996 *
         BC    10,MAXDIGIT                                        0870
*    ADDCDE=8;                       /* USE TYPETEST TO CHECK FOR     *
         LA    @F,8                                               0871
*    R1='10'X;                       /* NUMERIC                       *
         LA    @1,X'10'                                           0872
*    CALL LINKRET;                   /* GO TO TYPETEST IN PARSE       *
         BAL   @E,LINKRET                                         0873
*    GOTO ETEST;                     /* IF NON NUMERIC GO TO ETEST TO
*                                       CHECK FOR E                   *
         BC    15,ETEST                                           0874
*    GEN (BC 15,NUMER);              /* IF NUMERIC, CHECK NEXT CHAR   *
         BC 15,NUMER
         DS    0H
*
* ETEST1:
*    IF COMBUF='E'                  /* MAKE SURE IS EITHER           *
*          COMBUF='85'X              /* A CAPITAL                     *
*      THEN                          /* E OR SMALL E SO KNOW NOT      *
ETEST1   CLI   0(@4),C'E'                                         0876
         BC    08,@99E                                            0876
         CLI   0(@4),X'85'                                        0876
         BC    07,@99D                                            0876
*      GOTO ETEST;                   /* AN ERROR                      *
         BC    08,ETEST                                           0877
*    ELSE                            /* IF NOT, KNOW ERROR IF NOT     *
*      GOTO VERRBIT;                 /* NUMERIC OR E FOLLOWING A
*                                       DECIMAL POINT                 *
         BC    15,VERRBIT                                         0878
*
*    /*****************************************************************
*    /*                                                               *
*    /* TEST FOR RESERVED WORD PCE CHAINED TO THIS TERM PCE           *
*    /*                                                               *
*    /*****************************************************************
*
*
* RSVWDPC:                           /* CHAINED RESERVED WORD PCE?    *
*    IF RESVCHA^='1'B                /* TEST RESERVED WRD BIT IN PCE  *
*      THEN                          /* IF NOT ON                     *
RSVWDPC  TM    1(@6),B'00001000'                                  0879
*      GOTO PARMTEST;                /* TEST FOR TYPE EQUAL ANY       *
         BC    12,PARMTEST                                        0880
*    R4=R4-1;                        /* PTR TO PREVIOUS INPUT CHAR    *
         BCTR  @4,0                                               0881
*    CALL IKJEFP40;                  /* BRANCH TO RESERVED WORD RTN   *
         BAL   @E,IKJEFP40                                        0882
*    GOTO TYPANY;                    /* TEST FOR TYPE EQUAL ANY       *
         BC    15,TYPANY                                          0883
*    FIGUR = '1'B;                   /* SET FIGURATIVE CONSTANT BIT   *
         L     @1,564(0,@B)        
         OI    6(@1),B'00000010'                                  0884
*    GOTO DATAEND;                   /* TEST FOR SUBSCRIPT MODE       *
         BC    15,DATAEND                                         0885
*
* TYPANY:
*    R4=R4+1;                        /* PTR TO NEXT INPUT CHAR        *
TYPANY   AH    @4,@D2                                             0886
*    GOTO PARMTEST;                  /* TEST FOR TYPE EQUAL ANY       *
         BC    15,PARMTEST                                        0887
*
* QSTRING1:                          /* TEST FOR QUAOTED STRING       *
*    ADDCDE=1;                       /* ADDR OF QSTRING IN REG 15     *
QSTRING1 LA    @F,1                                               0888
*    CALL LINKRET;                   /* BRANCH TO PARSE               *
         BAL   @E,LINKRET                                         0889
*    GOTO VERRBIT;                   /* SET ERROR BIT ONE             *
         BC    15,VERRBIT                                         0890
*
*    /*****************************************************************
*    /*                                                               *
*    /* CHECK THE LENGTH OF THE STRING DATA AGAINST MAXIMUM 120       *
*    /*                                                               *
*    /*****************************************************************
*
*    IF COMBUF='7D'X                 /* IF ENDINPUT FOLLOWS           *
*      THEN                          /* XINPUT LEFT AT ENDING QUOTE   *
         CLI   0(@4),X'7D'                                        0891
         BC    07,@99C                                            0891
*      R4=R4+1;                      /* INCREMENT TO NEXT CHAR        *
         AH    @4,@D2                                             0892
*    IF PLENGTH>120                  /* LENGTH OF DATA GREATER 120    *
*      THEN                          /* IF YES                        *
@99C     LA    @F,120                                             0893
         CH    @F,152(0,@B)                                       0893
*      GOTO VERRBIT;                 /* SET ERROR BIT ON              *
         BC    04,VERRBIT                                         0894
*    DATAPTR=PPOINTR;                /* STORE PTR TO DATA IN PDE      *
         L     @1,564(0,@B)        
         MVC   8(4,@1),148(@B)                                    0895
*    LNGTH1=PLENGTH;                 /* STORE LENGTH OF DATA IN PDE   *
         MVC   0(1,@1),153(@B)                                    0896
*    NONNUM='1'B;                    /* INDICATE NON-NUMERIC LITERL   *
         OI    6(@1),B'00000100'                                  0897
*    R5=R4;                          /* PTR TO CHAR TO BE TRNSLATED   *
         LR    @5,@4                                              0898
*    ADDCDE=9;                       /* ADDR TRANSLATE RTN IN R 15    *
         LA    @F,9                                               0899
*    CALL LINKRET;                   /* BRANCH TO PARSE               *
         BAL   @E,LINKRET                                         0900
*
*    /*****************************************************************
*    /*                                                               *
*    /* DETERMINE IF IKJTERM IS PROCESSING A SUBSCRIPT                *
*    /*                                                               *
*    /*****************************************************************
*
*
* DATAEND:
*    IF SUBSMODE = '1'B              /* TERM PROCESSING A SUBSCRIPT   *
*      THEN                          /* IF YES                        *
DATAEND  TM    599(@B),B'00100000'                                0901
*      GOTO ADELCT;                  /* BUMP SUBSCRIPT CTR BY ONE     *
         BC    01,ADELCT                                          0902
*
*    /*****************************************************************
*    /*                                                               *
*    /* CHECK FOR END OF LIST EXPRESSION                              *
*    /*                                                               *
*    /*****************************************************************
*
*    IF R4=>ENDINPUT                 /* IF AT END OF           A00996 *
*      THEN                          /* BUFFER, GO PROC-       A00996 *
         C     @4,144(0,@B)                                       0903
*        GOTO ADD;                   /* ESS END OF DATA        A00996 *
         BC    10,ADD                                             0904
*    IF COMBUF=')'                   /* INPUT CHAR NOT EQUAL ) A00996 *
*      THEN                          /* IF YES                 A00996 *
         CLI   0(@4),C')'                                         0905
*        GOTO LISTCK;                /* CHECK FOR LIST         A00996 *
         BC    08,LISTCK                                          0906
* ADD:                               /* MAKE SURE RANGE BITS   A00996 *
*    CALL TSTRNGE;                   /* PROCESS POSSIBLE RANGE A00996 *
ADD      L     @F,@V5              ADDRESS OF TSTRNGE             0907
         BALR  @E,@F                                              0907
*    GEN;                            /* GENERATE PROPER BRNCHS A00996 *
        BC  15,SEP                  /* NO RANGE, OR 2ND VALUE A00996
*                                      PROCESS END            A00996 */
         DS    0H
*    MSGADDR=PPOINTR;                /* SET UP SPECIAL MESSAGE A00996 *
         MVC   592(4,@B),148(@B)                                  0909
*    MSGLEN=R4-PPOINTR;              /* FIELDS IN CASE REQURED A00996 *
         L     @F,148(0,@B)                                       0910
         LCR   @F,@F                                              0910
         AR    @F,@4                                              0910
         STH   @F,590(0,@B)                                       0910
*    GOTO PDESIZE;                   /* FIRST VALUE OF RANGE   A00996 *
         BC    15,PDESIZE                                         0911
*
* SEP:
*    ADDCDE=8;                       /* ADDR OF TYPE TEST IN REG15    *
SEP      LA    @F,8                                               0912
*    R1='08'X;                       /* BLANK-TAB-COMMA MASK REG 1    *
         LA    @1,X'08'                                           0913
*    CALL LINKRET;                   /* BRANCH TO PARSE               *
         BAL   @E,LINKRET                                         0914
*    GOTO TESTCOL;                   /* BRANCH TO TEST OFR SEMICOLN   *
         BC    15,TESTCOL                                         0915
*
* PDESIZE:
*    CONST='1'B;                     /* PDE TYPE EQUAL CONSTANT       *
PDESIZE  L     @1,564(0,@B)        
         OI    6(@1),B'11000000'                                  0916
*    PARMIND='1'B;                   /* INDICATE PARAMETER PRESENT    *
*
* TESTERR:
*    GOTO EXIT;                      /* BRANCH TO EXIT IN VAR RTN     *
         BC    15,EXIT                                            0918
*
*    /*****************************************************************
*    /*                                                               *
*    /* CHECK FOR END OF INPUT DATA                                   *
*    /*                                                               *
*    /*****************************************************************
*
*
* TESTCOL:
*    IF COMBUF=';'                   /* INPUT LINE EQUAL SEMICOLON    *
*      THEN                          /* IF YES                        *
TESTCOL  CLI   0(@4),C';'                                         0919
*      GOTO PDESIZE;                 /* SET PDE TYPE EQUAL CONSTANT   *
         BC    08,PDESIZE                                         0920
*
*    /*****************************************************************
*    /*                                                               *
*    /* DETERMINE IF END OF BUFFER HAS BEEN REACHED                   *
*    /*                                                               *
*    /*****************************************************************
*
*    IF R4=>ENDINPUT                 /* TEST FOR END OF BUFFER A00996 *
*      THEN                          /* IF YES                        *
         C     @4,144(0,@B)                                       0921
*      GOTO PDESIZE;                 /* SET PCE TYPE EQUAL CONSTANT   *
         BC    10,PDESIZE                                         0922
*    ELSE                            /* IF NOT END OF INPUT, ERROR    *
*      GOTO VERRBIT;                 /* ERROR                         *
         BC    15,VERRBIT                                         0923
*
* ENDSUB:
*    IF PFENDSET='1'B                /* IF BUFFER HAS BEEN POPPED     *
*     THEN                           /* MUST RESET XINPUTB            *
ENDSUB   TM    179(@B),B'00000100'                                0924
         BC    12,@99B                                            0924
*     DO;                            /* TO END OF PREVIOUS            *
*      R5=ENDBAKUP;                  /* BUFFER                        *
         L     @5,412(0,@B)                                       0926
*      PFENDSET='0'B;                /* TURN OFF BUFFER POPPED        *
         NI    179(@B),B'11111011'                                0927
*     END;                           /* INDICATOR                     *
*    PPOINTR=INVPSAVE+1;             /* SET PTR FOR PSTRIMSG          *
@99B     LA    @F,1                                               0929
         A     @F,300(0,@B)                                       0929
         ST    @F,148(0,@B)                                       0929
*    ADDCDE=10;                      /* ISSUE MSG STATING ENDING )    *
         LA    @F,10                                              0930
*    CALL LINKRET;                   /* ASSUMED-EOB IN SUBSCRIPT      *
         BAL   @E,LINKRET                                         0931
*    R5=R4;                          /* RESET XINPUTB                 *
         LR    @5,@4                                              0932
*    GOTO VSUBENDK;                  /* PROCESS END OF SUBSCRIPT      *
         BC    15,VSUBENDK                                        0933
*
*    /*****************************************************************
*    /*                                                               *
*    /* DETERMINE IF FIRST VALUE OF A RANGE HAS BEEN PROCESSED        *
*    /*                                                               *
*    /*****************************************************************
*
*
* RANTST:
*    IF RNGEVAL1='1'B                /* FIRST VALUE OF RANGE?         *
*      THEN                          /* IF YES                        *
RANTST   TM    177(@B),B'01000000'                                0934
*      GOTO VERRBIT;                 /* SET ERROR BIT ON              *
         BC    01,VERRBIT                                         0935
*
*    /*****************************************************************
*    /*                                                               *
*    /* DETERMINE IF SECOND VALUE OFRANGE HAS BEEN PROCESSED          *
*    /*                                                               *
*    /*****************************************************************
*
*    IF RNGEVAL2='1'B                /* SECOND VALUE OF RANGE?        *
*      THEN                          /* IF YES                        *
         TM    177(@B),B'00001000'                                0936
*      GOTO PDESIZE;                 /* SET PDE TYPE EQUAL CONSTANT   *
         BC    01,PDESIZE                                         0937
*
* SETMINUS:                          /* INDICATE MINUS IN INPUT LINE  *
*    SIGN='1'B;                      /* SET MINUS INDICATOR IN PDE    *
SETMINUS L     @1,564(0,@B)        
         OI    7(@1),B'10000000'                                  0938
*    GOTO CBUMP02;                   /* CHECK FOR END OF INPUT DATA   *
         BC    15,CBUMP02                                         0939
*
* PREPDSCN:                          /* STORE ADDR OF DIGIT STRING    *
*    DATAPTR=R4;                     /* ADDR OF DIGIT STRING IN PDE   *
PREPDSCN L     @1,564(0,@B)        
         ST    @4,8(0,@1)                                         0940
*
* ADDCOUNT:                          /* UPDATE DIGIT STRING COUNTER   *
*    DIGITCT=DIGITCT+1;              /* ADD ONE TO DIGIT COUNTER      *
ADDCOUNT LA    @F,1                                               0941
         SR    @0,@0                                              0941
         IC    @0,596(0,@B)                                       0941
         AR    @F,@0                                              0941
         STC   @F,596(0,@B)                                       0941
*    R4=R4+1;                        /* PTR TO NEXT INPUT CHAR        *
         AH    @4,@D2                                             0942
*
*    /*****************************************************************
*    /*                                                               *
*    /* CHECK FOR END OF INPUT DATA                                   *
*    /*                                                               *
*    /*****************************************************************
*
*
* SEMCHK:
*    IF COMBUF=';'                   /* INPUT LINE EQUAL SEMICOLON    *
*      THEN                          /* IF YES                        *
SEMCHK   CLI   0(@4),C';'                                         0943
*      GOTO MAXDIGIT;                /* CHECK DIGIT STRING COUNTER    *
         BC    08,MAXDIGIT                                        0944
*
*    /*****************************************************************
*    /*                                                               *
*    /* DETERMINE IF END OF BUFFER HAS BEEN REACHED                   *
*    /*                                                               *
*    /*****************************************************************
*
*    IF R4=>ENDINPUT                 /* TEST FOR END OF BUFFER A00996 *
*      THEN                          /* IF YES                        *
         C     @4,144(0,@B)                                       0945
*      GOTO MAXDIGIT;                /* CHECK DIGIT STRING COUNTER    *
         BC    10,MAXDIGIT                                        0946
*    ADDCDE=8;                       /* ADDR OF TYPE TEST IN REG 15   *
         LA    @F,8                                               0947
*    R1='10'X;                       /* NUMERIC MASK IN REG 1         *
         LA    @1,X'10'                                           0948
*    CALL LINKRET;                   /* BRANCH TO PARSE2              *
         BAL   @E,LINKRET                                         0949
*    GEN;                            /* RETURN BRANCHES               *
         BC  15,PERCHK1                CHECK FOR '4B'X
         BC  15,ADDCOUNT               UPDATE STRING COUNTER
         DS    0H
*
*    /*****************************************************************
*    /*                                                               *
*    /* CHECK INPUT LINE FOR A PERIOD                                 *
*    /*                                                               *
*    /*****************************************************************
*
*
* PERCHK1:
*    IF COMBUF='4B'X                 /* INPUT CHAR EQUAL PERIOD       *
*      THEN                          /* IF YES                        *
PERCHK1  CLI   0(@4),X'4B'                                        0951
*      GOTO PPDSCAN;                 /* STORE PTR TO PERIOD           *
         BC    08,PPDSCAN                                         0952
*
* SEPTEST:
*    ADDCDE=8;                       /* ADDR OF TYPETEST IN REG 15    *
SEPTEST  LA    @F,8                                               0953
*    R1='08'X;                       /* BLANK=TAB-COMMA MASK          *
         LA    @1,X'08'                                           0954
*    CALL LINKRET;                   /* BRANCH TO PARSE2              *
         BAL   @E,LINKRET                                         0955
*    GEN;                            /* RETURN BRANCHES               *
         BC  15,LSTCHK                 CHECK FOR END EXPRESSION
         BC  15,MAXDIGIT               CHECK DIGIT STRING COUNTER
         DS    0H
*
*    /*****************************************************************
*    /*                                                               *
*    /* CHECK FOR END OF LIST EXPRESSION                              *
*    /*                                                               *
*    /*****************************************************************
*
*
* LSTCHK:
*    IF COMBUF=')'                   /* INPUT CHAR EQUAL PAREN        *
*      THEN                          /* IF YES                        *
LSTCHK   CLI   0(@4),C')'                                         0957
*      GOTO MAXDIGIT;                /* CHECK DIGIT STRING COUNTER    *
         BC    08,MAXDIGIT                                        0958
*
*    /*****************************************************************
*    /*                                                               *
*    /* CHECK INPUT LINE FOR END OF RANGE                             *
*    /*                                                               *
*    /*****************************************************************
*
*    IF COMBUF^=':'                  /* END OF RANGE?                 *
*      THEN                          /* IF NOT                        *
         CLI   0(@4),C':'                                         0959
*      GOTO VARTEST;                 /* CHECK FOR ALPHA CHAR          *
         BC    07,VARTEST                                         0960
*
*    /*****************************************************************
*    /*                                                               *
*    /* DETERMINE IF IKJTERM IS PROCESSING A SUBSCRIPT                *
*    /*                                                               *
*    /*****************************************************************
*
*    IF SUBSMODE='1'B                /* TERM PROCESSING A SUBSCRPT    *
*      THEN                          /* IF YES                        *
         TM    599(@B),B'00100000'                                0961
*      GOTO VERRBIT;                 /* SET ERROR BIT ON              *
         BC    01,VERRBIT                                         0962
*
*    /*****************************************************************
*    /*                                                               *
*    /* DETERMINE IF TOTAL NUMBER OF DIGITS HAS EXCEEDED 18           *
*    /*                                                               *
*    /*****************************************************************
*
*
* MAXDIGIT:                          /* TEST DIGIT COUNTER            *
*    IF DIGITCT>18                   /* DIGIT CTR GREATER THAN 18     *
*      THEN                          /* IF YES                        *
MAXDIGIT CLI   596(@B),18                                         0963
*      GOTO VERRBIT;                 /* SET ERROR BIT ON              *
         BC    02,VERRBIT                                         0964
*    LNGTH1=DIGITCT;                 /* LENGTH OF DIGIT DATA IN PDE   *
         L     @1,564(0,@B)        
         MVC   0(1,@1),596(@B)                                    0965
*    DIGITCT=0;                      /* ZERO DIGIT COUNTER            *
         MVI   596(@B),0                                          0966
*
* ENDPDE:
*    FIXED='1'B;                     /* INDICATE FIXED PTR LITERAL    *
ENDPDE   L     @1,564(0,@B)        
         OI    6(@1),B'00001000'                                  0967
*    GOTO DATAEND;                   /* TEST FOR SUBSCRIPT MODE       *
         BC    15,DATAEND                                         0968
*
* VARTEST:
*    ADDCDE=8;                       /* ADDR OF TYPE TEST IN REG15    *
VARTEST  LA    @F,8                                               0969
*    R1='C0'X;                       /* ALPHA MASK IN REG 1           *
         LA    @1,X'C0'                                           0970
*    CALL LINKRET;                   /* BRANCH TO PARSE               *
         BAL   @E,LINKRET                                         0971
*    GOTO ANYTEST;                   /* NOT ALPHA,CHECK FOR TYPE=ANY  *
         BC    15,ANYTEST                                         0972
*    /*                                                         YM2849*
*    GEN(BC 15,ETEST);               /*TEST FOR VALID ALPHA CHARACTER *
         BC 15,ETEST
         DS    0H
*    /*                                                         YM2849*
*
* ANYTEST:                           /* TYPE = ANY TEST         YM2849*
*    /*****************************************************************
*    /*                                                               *
*    /* TEST FOR PCE TYPE EQUAL ANY                                   *
*    /*                                                               *
*    /*****************************************************************
*
*    IF ANY^='1'B                    /* PCE TYPE EQUAL ANY?           *
*      THEN                          /* IF NOT                        *
ANYTEST  TM    6(@6),B'00010000'                                  0974
*      GOTO VERRBIT;                 /* SET ERROR BIT                 *
         BC    12,VERRBIT                                         0975
*
* GOTOVAR:
*    R4=PRMTPTR;                     /* RESET INPUT POINTER           *
GOTOVAR  L     @4,584(0,@B)                                       0976
*    R5=PRMTPTR;                     /* RESET BACKUP INPUT POINTER    *
         L     @5,584(0,@B)                                       0977
*    DIGITCT=0;                      /* RESET DIGIT COUNT             *
         MVI   596(@B),0                                          0978
*    IF SUBSMODE='1'B                /* IF IN SUBSMODE, MUST RESET    *
*      THEN                          /* SUBSCRIPT COUNT               *
         TM    599(@B),B'00100000'                                0979
         BC    12,@99A                                            0979
*      ELEMNCT=ELEMNCT+1;            /* INCREMENT SUBSCRPT COUNT      *
         LA    @F,1                                               0980
         SR    @0,@0                                              0980
         IC    @0,597(0,@B)                                       0980
         AR    @F,@0                                              0980
         STC   @F,597(0,@B)                                       0980
*    CNSTTEMP=                       /* ZERO CNSTTEMP                 *
*        CNSTTEMP && CNSTTEMP;       /* PDEPTR POINTS TO CNSTTEMP     *
@99A     L     @1,564(0,@B)        
         XC    0(20,@1),0(@1)                                     0981
*    GOTO IKJEFP6V;                  /* BRANCH TO VARIABLE RTN        *
         BC    15,IKJEFP6V                                        0982
*
*    /*****************************************************************
*    /*                                                               *
*    /* DETERMINE IF DATA TYPE EQUAL FLOATING POINT LITERAL           *
*    /*                                                               *
*    /*****************************************************************
*
*
* ETEST:
*    IF COMBUF='E'                   /* FLOATING PT LITERAL?          *
*      THEN                          /* IF YES                        *
ETEST    CLI   0(@4),C'E'                                         0983
         BC    07,@999                                            0983
*      DO;                           /* SET FLOATING PT FLAG IN PDE   *
*
* EFOUND:
*        FLOAT='1'B;                 /* SET FLOATING PT FLAG IN PDE   *
EFOUND   L     @1,564(0,@B)        
         OI    6(@1),B'00000001'                                  0985
*
*        /*************************************************************
*        /*                                                           *
*        /* DETERMINE IF FLOATING POINT LITERAL HAS EXCEEDED 16       *
*        /*                                                           *
*        /*************************************************************
*
*        IF DIGITCT>16               /* STRING EXCEEDED MAX LENGTH?   *
*          THEN                      /* IF YES                        *
         CLI   596(@B),16                                         0986
*          GOTO VERRBIT;             /* SET ERROR BIT                 *
         BC    02,VERRBIT                                         0987
*        LNGTH1=DIGITCT;             /* STORE LENGTH OF DATA IN PDE   *
         MVC   0(1,@1),596(@B)                                    0988
*        DIGITCT=0;                  /* ZERO DIGIT COUNTER            *
         MVI   596(@B),0                                          0989
*
*        /*************************************************************
*        /*                                                           *
*        /* IS DEC PTR FLAG SET IN PDE ?                              *
*        /*                                                           *
*        /*************************************************************
*
*        IF DECPT='0'B               /* DEC PTR FLAG SET ?            *
*          THEN                      /* IF NO                         *
         L     @1,564(0,@B)        
         TM    7(@1),B'00100000'                                  0990
*          GOTO VERRBIT;             /* SET ERROR BIT                 *
         BC    08,VERRBIT                                         0991
*        R4= R4+1;                   /* POINT TO NEXT INPUT CHAR      *
         AH    @4,@D2                                             0992
*
*        /*************************************************************
*        /*                                                           *
*        /* DETERMINE IF END OF BUFFER HAS BEEN REACHED               *
*        /*                                                           *
*        /*************************************************************
*
*        IF R4=>ENDINPUT             /* END OF BUFFER?         A00996 *
*          THEN                      /* IF YES                        *
         C     @4,144(0,@B)                                       0993
*          GOTO VERRBIT;             /* ISSUE PROMPT MSG              *
         BC    10,VERRBIT                                         0994
*
*        /*************************************************************
*        /*                                                           *
*        /* CHECK FOR AN END OF THE PARAMETER                         *
*        /*                                                           *
*        /*************************************************************
*
*        IF COMBUF=';'               /* A SEMICOLON DELIMITS PARM     *
*          THEN                      /* IF YES                        *
         CLI   0(@4),C';'                                         0995
*          GOTO VERRBIT;
         BC    08,VERRBIT                                         0996
*
*        /*************************************************************
*        /*                                                           *
*        /* PROMPT-INCOMPLETE PARAMETER CHECK THE SIGN OF THE EXPONENT*
*        /* INDICATED BY E IN PARM                                    *
*        /*                                                           *
*        /*************************************************************
*
*        IF COMBUF='-'               /* CHECK FIRST FOR A MINUS       *
*          THEN                      /* IF YES (MINUS)                *
         CLI   0(@4),C'-'                                         0997
*          GOTO MINUSEXP;            /* SET THE INDICATOR IN THEPDE   *
         BC    08,MINUSEXP                                        0998
*
*        /*************************************************************
*        /*                                                           *
*        /* IF THERE IS A PLUS SIGN IT MUST BE SKIPPED                *
*        /*                                                           *
*        /*************************************************************
*
*        IF COMBUF='+'               /* IS THERE A PLUS PRESENT       *
*          THEN                      /* IF YES                        *
         CLI   0(@4),C'+'                                         0999
*          GOTO CBUMP03;             /* SKIP OVER TO CONTINUE SCAN    *
         BC    08,CBUMP03                                         1000
*
* NUMCK:
*        ADDCDE=8;                   /* USE TYPETEST TO CHECK FOR A   *
NUMCK    LA    @F,8                                               1001
*        R1='10'X;                   /* NUMERIC CHARACTER AS THE      *
         LA    @1,X'10'                                           1002
*        CALL LINKRET;               /* EXPONENT                      *
         BAL   @E,LINKRET                                         1003
*        GOTO VERRBIT;               /* NO NUMERIC EXP IS AN ERROR    *
         BC    15,VERRBIT                                         1004
*        DATAPTRA=R4;                /* STORE PTR TO EXPONENT         *
         L     @1,564(0,@B)        
         ST    @4,12(0,@1)                                        1005
*
* ADCT01:
*        DIGITCT=DIGITCT+1;          /* KEEP A COUNT OF EXP LENGTH    *
ADCT01   LA    @F,1                                               1006
         SR    @0,@0                                              1006
         IC    @0,596(0,@B)                                       1006
         AR    @F,@0                                              1006
         STC   @F,596(0,@B)                                       1006
*        R4=R4+1;                    /* INCREMENT THE INPUT POINTER   *
         AH    @4,@D2                                             1007
*
*        /*************************************************************
*        /*                                                           *
*        /* CHECK FOR THE END OF THE INPUT BUFFER                     *
*        /*                                                           *
*        /*************************************************************
*
*        IF R4=>ENDINPUT             /* IS XINPUT AT END OF INPUT
*                                                              A00996 *
*          THEN                      /* IF YES,                       *
         C     @4,144(0,@B)                                       1008
*          GOTO VALEXP;              /* THE END OF PARM IS FOUND      *
         BC    10,VALEXP                                          1009
*        ADDCDE=8;                   /* IF NO CONTINUE THE SCAN       *
         LA    @F,8                                               1010
*        R1='10'X;                   /* IS THIS A NUMERIC CHARACTER   *
         LA    @1,X'10'                                           1011
*        CALL LINKRET;               /* USE TYPETEST TO CHECK         *
         BAL   @E,LINKRET                                         1012
*        GEN;                        /* RETURN BRANCHES               *
            BC  15,TSEP                IT IS NOT CHECK FOR DELIMITR
            BC  15,ADCT01              IT IS, CONTINUE THE SCAN
         DS    0H
*
* TSEP:
*        ADDCDE=8;                   /* USE TYPETEST TO CHECK FOR A   *
TSEP     LA    @F,8                                               1014
*        R1='08'X;                   /* VALID PARM SEPARATOR. IF NOT  *
         LA    @1,X'08'                                           1015
*        CALL LINKRET;               /* CHECK FOR PARM DELIMITER      *
         BAL   @E,LINKRET                                         1016
*        GEN;                        /* RETURN BRANCHES               *
            BC  15,PARTTST             NONE FOUND
            BC  15,VALEXP              A SEPARATOR WAS FOUND THUS
         DS    0H
*      END;                          /* THE END OF PARM ALSO FOUND    *
*
*    /*****************************************************************
*    /*                                                               *
*    /* MUST CONSIDER A LOWER CASE E                                  *
*    /*                                                               *
*    /*****************************************************************
*
*    IF COMBUF='85'X                 /* IS THIS A LOWER CASE E        *
*      THEN                          /* IF YES                        *
@999     CLI   0(@4),X'85'                                        1019
         BC    07,@998                                            1019
*      DO;                           /* CHECK FOR TRANSLATION         *
*
*        /*************************************************************
*        /*                                                           *
*        /* CHECK TO SEE IF UPPERCASE REQUESTED                       *
*        /*                                                           *
*        /*************************************************************
*
*        IF ASIS='0'B                /* IS UPPERCASE REQUESTED?       *
*          THEN                      /* IF YES                        *
         TM    1(@6),B'01000000'                                  1021
         BC    05,@997                                            1021
*          DO;                       /* TRANSLATE                     *
*
*            /*********************************************************
*            /*                                                       *
*            /* TEST FOR DEFAULT DATA PROCESSING                      *
*            /*                                                       *
*            /*********************************************************
*
*            IF PFDEFLT='1'B         /* TEST FOR DEFAULT DATA         *
*              THEN                  /* IF YES                        *
         TM    176(@B),B'01000000'                                1023
*              GOTO EFOUND;          /* SET FLOATING PTR FLAG IN PDE  *
         BC    01,EFOUND                                          1024
*            COMBUF=COMBUF' ';      /* TRANSLATE TO UPPERCASE        *
         OI    0(@4),C' '                                         1025
*          END;                      /* EXPONENT                      *
*        GOTO EFOUND;                /* IF NO TRANSLATION NEEDED      *
         BC    15,EFOUND                                          1027
*      END;                          /* RETURN TO PROCESS EXPONENT    *
*    ELSE                            /* IF NOT AN E, WE HAVE AN       *
*      GEN(BC 15,ANYTEST);           /* NOT VALID FOR CONSTANT  YM2849*
@998     EQU   *                                                  1029
         BC 15,ANYTEST
         DS    0H
*
*    /*****************************************************************
*    /*                                                               *
*    /* A LOGICAL END OF A CONSTANT HAS BEEN FOUND CHECKS FOR A VALID *
*    /* DELIMITER WILL NOW BE MADE                                    *
*    /*                                                               *
*    /*****************************************************************
*
*
* PARTTST:
*    IF COMBUF=')'                   /* A ) IS A VALID DELIMITER      *
*      THEN                          /* IF YES                        *
@996     EQU   *                                                  1030
PARTTST  CLI   0(@4),C')'                                         1030
*      GOTO VALEXP;                  /* PARM END HAS BEEN FOUND       *
         BC    08,VALEXP                                          1031
*    IF COMBUF^=':'                  /* A COLON INDICATES A RANGE     *
*      THEN                          /* IF NOT A COLON THE PARAMETR   *
         CLI   0(@4),C':'                                         1032
*      GOTO VERRBIT;                 /* IS INVALID,NO MORE DELIMITR   *
         BC    07,VERRBIT                                         1033
*
*    /*****************************************************************
*    /*                                                               *
*    /* A CHECK IS MADE FOR SUBSCRIPT MODE AS THERE MAY NOT BE A RANGE*
*    /* IN SUBSCRIPTS AND A COLON HAS BEEN FOUND. IF THE SUBSMODE BIT *
*    /* IS ON THE PARAMETER IS CONSIDERED INVALID                     *
*    /*                                                               *
*    /*****************************************************************
*
*    IF SUBSMODE='1'B                /* TEST THE SUBSCRIPT BIT        *
*      THEN                          /* IF ON                         *
         TM    599(@B),B'00100000'                                1034
*      GOTO VERRBIT;                 /* PROMPT FOR INVALID PARAMETER  *
         BC    01,VERRBIT                                         1035
*
*    /*****************************************************************
*    /*                                                               *
*    /* CHECK THE DIGITCT FOR LENGTH OF THE EXPONENT                  *
*    /*                                                               *
*    /*****************************************************************
*
*
* VALEXP:
*    IF DIGITCT>2                    /* TWO IS MAX FOR EXPONENT       *
*      THEN                          /* IF MAX IS EXCEEDED            *
VALEXP   CLI   596(@B),2                                          1036
*      GOTO VERRBIT;                 /* PROMPT                        *
         BC    02,VERRBIT                                         1037
*    LNGTH2=DIGITCT;                 /* STORE EXPONENT LENGTH IN PDE  *
         L     @1,564(0,@B)        
         MVC   1(1,@1),596(@B)                                    1038
*    DIGITCT=0;                      /* REINTIALIZE THE COUNTER       *
         MVI   596(@B),0                                          1039
*    GOTO DATAEND;                   /* ADD THE PDE TO THE PDL        *
         BC    15,DATAEND                                         1040
*
* MINUSEXP:                          /* SET THE MINUS ECPONENT BIT    *
*    EXPSIGN='1'B;                   /* IN THE PDE                    *
MINUSEXP L     @1,564(0,@B)        
         OI    7(@1),B'01000000'                                  1041
*
* CBUMP03:
*    R4=R4+1;                        /* INCREMENT XINPUT PAST MINUS   *
CBUMP03  AH    @4,@D2                                             1042
*
*    /*****************************************************************
*    /*                                                               *
*    /* AFTER INCREMENTING XINPUT A CHECK FOR END OF COMMAND OR END OF*
*    /* INPUT MUST BE MADE                                            *
*    /*                                                               *
*    /*****************************************************************
*
*    IF COMBUF=';'                   /* A SEMICOLON IS END OF CMD     *
*      THEN                          /* IF YES                        *
         CLI   0(@4),C';'                                         1043
*      GOTO VERRBIT;
         BC    08,VERRBIT                                         1044
*
*    /*****************************************************************
*    /*                                                               *
*    /* PROMPT-INCOMPLETE PARAMETER NOW CHECK FOR EOB                 *
*    /*                                                               *
*    /*****************************************************************
*
*    IF R4=>ENDINPUT                 /* DOES XINPUT EQUAL END INPUT
*                                                              A00996 *
*      THEN                          /* IF YES                        *
         C     @4,144(0,@B)                                       1045
*      GOTO VERRBIT;
         BC    10,VERRBIT                                         1046
*
*    /*****************************************************************
*    /*                                                               *
*    /* PROMPT-INCOMPLETE PARAMETER                                   *
*    /*                                                               *
*    /*****************************************************************
*
*    GOTO NUMCK;                     /* OTHERWISE CONTINUE THE SCAN   *
         BC    15,NUMCK                                           1047
*
*    /*****************************************************************
*    /*                                                               *
*    /* AFTER A ) HAS BEEN FOUND CHECK FOR LIST PROCESSING            *
*    /*                                                               *
*    /*****************************************************************
*
*
* LISTCK:
*    IF PFLIST='1'B                  /* PFLIST ON INDICATES LIST      *
*      THEN                          /* IF ON                         *
LISTCK   TM    176(@B),B'10000000'                                1048
         BC    12,@995                                            1048
*      DO;                           /* MUST DECREMENT XINPUT SO      *
*        CALL TSTRNGE;               /* PROCESS RANGE, ONLY    A00996
*                                       POSSIBLE RETURN +0            *
         L     @F,@V5              ADDRESS OF TSTRNGE             1050
         BALR  @E,@F                                              1050
*        R4=R4-1;                    /* DON'T MISS THE ENDING PAREN   *
         BCTR  @4,0                                               1051
*        GOTO PDESIZE;               /* GO TO NORMAL END              *
         BC    15,PDESIZE                                         1052
*      END;                          /* END LIST PROCESSING           *
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF PFLIST NOT ON ASSUME ) TO BE SUBSCRIPT DELIMITER           *
*    /*                                                               *
*    /*****************************************************************
*
*    IF OPERMODE='1'B                /* SUBSCRIPT CAN BE VALID FOR A  *
*      THEN                          /* CONSTANT ONLY IN OPER MODE    *
@995     TM    599(@B),B'01000000'                                1054
*      GOTO PDESIZE;                 /* IF OPERMOD ON-VALID-CONTINUE  *
         BC    01,PDESIZE                                         1055
*    GOTO VERRBIT;                   /* OTHERWISE ) IS INVALID PROMPT *
         BC    15,VERRBIT                                         1056
*
* ADELCT:
*    ELEMNCT=ELEMNCT+1;              /* ADD ONE TO THE SUBSCRIPT CT   *
ADELCT   LA    @F,1                                               1057
         SR    @0,@0                                              1057
         IC    @0,597(0,@B)                                       1057
         AR    @F,@0                                              1057
         STC   @F,597(0,@B)                                       1057
*    CONST='1'B;                     /* INDICATE A CONSTANT WAS FOUND
*                                       IN THE PDE                    *
         L     @1,564(0,@B)        
         OI    6(@1),B'11000000'                                  1058
*    PARMIND='1'B;                   /* SET PARM PRESENT BIT IN THE
*                                       PDE                           *
*    R4=R4-1;                        /* DECREMENT XINPUT FOR SKIPB    *
         BCTR  @4,0                                               1060
*    ADDCDE=5;                       /* SKIP ANY SEPARATORS PRIOR     *
         LA    @F,5                                               1061
*    CALL LINKRET;                   /* TO SCAN FOR NEXT SUBSCRIPT    *
         BAL   @E,LINKRET                                         1062
*    GOTO ENDSUB;                    /* NO MORE DATA IN BUFFER        *
         BC    15,ENDSUB                                          1063
*    R4=R4+1;                        /* CONTINUE THE SCAN             *
         AH    @4,@D2                                             1064
*
*    /*****************************************************************
*    /*                                                               *
*    /* CHECK FOR THE END OF THE SUBSCRIPTS                           *
*    /*                                                               *
*    /*****************************************************************
*
*    IF COMBUF=')'                   /* IS THIS A DELIMITING )        *
*      THEN                          /* IF YES                        *
         CLI   0(@4),C')'                                         1065
*      GOTO VSUBENDK;                /* PROCESS END OF SUBSCRIPTS     *
         BC    08,VSUBENDK                                        1066
*
*    /*****************************************************************
*    /*                                                               *
*    /* CHECK FOR A COMMAND DELIMITER                                 *
*    /*                                                               *
*    /*****************************************************************
*
*
* ENDCMDCK:                          /* CHECK FOR SEMICOLON           *
*    IF COMBUF=';'                   /* IS THERE A COMMAND DELIMITER  *
*      THEN                          /* IF YES                        *
ENDCMDCK CLI   0(@4),C';'                                         1067
         BC    07,@994                                            1067
*      DO;                           /* PTR TO PREVIOUS CHAR          *
*        R4=R4-1;                    /* PTR TO PREVIOUS CHAR          *
         BCTR  @4,0                                               1069
*        GOTO ENDSUB;                /* PROMPT-INVALID IN SUBSCRIPTS  *
         BC    15,ENDSUB                                          1070
*      END;                          /* IF NOT END OF BUFFER          *
*    ELSE                            /* IF VALID NEXT CHAR, PREPARE   *
*      DO;                           /* TO PROCESS NEXT SUBSCRIPT     *
*        PRMTPTR=R4;                 /* SET PRMTPTR SO IN CASE OF
*                                       ERROR, PROMPT WITH THE COR-
*                                       RECT SUBSCRIPT                *
@994     ST    @4,584(0,@B)                                       1073
*        GOTO SUBENDCK;              /* GO BACK TO PROCESS NEXT
*                                       SUBSCRIPT                     *
         BC    15,SUBENDCK                                        1074
*      END;                          /* RETURN TO SUBSCRIPT PROCESS   *
*
*    /*****************************************************************
*    /*                                                               *
*    /* TERM VARIABLE PROCESSING                                      *
*    /*                                                               *
*    /*****************************************************************
*
*
* IKJEFP6V:                          /* VARIABLE RTN ENTRY POINT      *
*    VARIA='1'B;                     /* SET VARIABLE BIT IN PDE       *
@993     EQU   *                                                  1076
IKJEFP6V L     @1,564(0,@B)        
         OI    6(@1),B'00100000'                                  1076
*    IF SUBSMODE='1'B                /* IF SUBSCRIPT MODE , DO        *
*      THEN                          /* NOT SET FIRST NAME SWITCH     *
         TM    599(@B),B'00100000'                                1077
*      GOTO SCAN;                    /* FOR MESSAGE SETUP             *
         BC    01,SCAN                                            1078
*    IF RNGEVAL1='1'B                /* IF SECOND VALUE OF RANGE      *
*      THEN                          /* DO NOT SET FIRST NAME         *
         TM    177(@B),B'01000000'                                1079
*      GOTO SCAN;                    /* SWITCH FOR MESSAGE            *
         BC    01,SCAN                                            1080
*    FIRSTNAM='1'B;                  /* SET FIRST NAME SWITCH SO THAT
*                                       FIELDS WILL BE INIT- IALIZED
*                                       FOR THE SPECIAL MESSAGE       *
         OI    601(@B),B'10000000'                                1081
*
* SCAN:
*    PPOINTR=R4;                     /* PPOINTR IS NOT INITIAL- IZED
*                                       BY GENSCAN IF INVALID FIRST
*                                       CHARACTER                     *
SCAN     ST    @4,148(0,@B)                                       1082
*    PDWORD (1)=ADDR(WORKAR);        /* ADDR OF CONTROL INFO IN PWA   *
         LA    @F,WORKAR                                          1083
         ST    @F,@TEMP4                                          1083
         MVC   136(4,@B),@TEMP4                                   1083
*    GOPTION='40'X;                  /* MAX IS SPECIFIED-GENSCAN      *
         MVI   WORKAR,X'40'                                       1084
*    GFIRST='01'X;                   /* MFIRST CHAR EQUAL ALPHA       *
         MVI   WORKAR+1,X'01'                                     1085
*    GOTHER='03'X;                   /* OTHER CHAR ALPHAMERIC         *
         MVI   WORKAR+2,X'03'                                     1086
*    GOMAX=8;                        /* MAXIMUM LENGTH EQUAL 8        *
         MVI   WORKAR+3,8                                         1087
*    ADDCDE=7;                       /* ADDR OF GENSCAN IN REG 15     *
         LA    @F,7                                               1088
*    R4=R4-1;                        /* TEST PREVIOUS CHAR            *
         BCTR  @4,0                                               1089
*    CALL LINKRET;                   /* BRANCH TO PARSE2              *
         BAL   @E,LINKRET                                         1090
*    GEN;                            /* RETURN BRANCHES               *
         BC  15,NOPGMID                INVALID FIRSR CHAR
         BC  15,NOPGMID                MAXIMUM LENGTH EXCEEDED
         BC  15,NOPGMID                EOB REACHED
         DS    0H
*
*    /*****************************************************************
*    /*                                                               *
*    /* CHECK INPUT LINE FOR VALID PGM. ID                            *
*    /*                                                               *
*    /*****************************************************************
*
*    IF COMBUF^='4B'X                /* PERIOD IN INPUT LINE?         *
*      THEN                          /* IF NO                         *
         CLI   0(@4),X'4B'                                        1092
*      GOTO NOPGMID;                 /* CHECK FOR DATA NAME           *
         BC    07,NOPGMID                                         1093
*
*    /*****************************************************************
*    /*                                                               *
*    /* DETERMINE IF TERM IS PROCESSING IN ERROR MODE                 *
*    /*                                                               *
*    /*****************************************************************
*
*    DATAPTRA=PPOINTR;               /* PTR TO PGM. ID IN PDE   M4151 *
         L     @1,564(0,@B)        
         MVC   12(4,@1),148(@B)                                   1094
*    PLENGTH=R4-PPOINTR;             /* LENGTH OF PGM.ID              *
         L     @F,148(0,@B)                                       1095
         LCR   @F,@F                                              1095
         AR    @F,@4                                              1095
         STH   @F,152(0,@B)                                       1095
*    LNGTH5=PLENGTH;                 /* LENGTH OF PGM.ID IN PDE       *
         L     @1,564(0,@B)        
         MVC   16(1,@1),153(@B)                                   1096
*    IF SUBSMODE='1'B                /* IF SUBSCRPT MODE              *
*      THEN                          /* MUST RESET PRMTPTR TO         *
         TM    599(@B),B'00100000'                                1097
         BC    12,@992                                            1097
*      PRMTPTR=PPOINTR;              /* BEGINNING FOR POSSIBLE
*                                       PROMPTING                     *
         MVC   584(4,@B),148(@B)                                  1098
*    IF FIRSTNAM^='1'B               /* IF ISN'T FIRST DATA           *
*      THEN                          /* NAME OF VARIABLE, DO          *
@992     TM    601(@B),B'10000000'                                1099
*      GOTO UPRCSE;                  /* NOT SET UP SPECIAL MESSAGE
*                                       FIELDS                        *
         BC    12,UPRCSE                                          1100
*    MSGADDR=PPOINTR;                /* IF IS FIRST DATA NAME         *
         MVC   592(4,@B),148(@B)                                  1101
*    MSGLEN=PLENGTH;                 /* SET UP MESSAGE FIELDS FOR
*                                       ERROR MESSAGE                 *
         MVC   590(2,@B),152(@B)                                  1102
*
* UPRCSE:
*    ADDCDE=9;                       /* ADDR OF TRANSQ IN REG 15      *
UPRCSE   LA    @F,9                                               1103
*    CALL LINKRET;                   /* BRANCH TO PARSE2              *
         BAL   @E,LINKRET                                         1104
*
* NAMEREQA:                          /* SET NAME REQUIRED BIT         *
*    NAMEREQD='1'B;                  /* SET NAME REQUIRED BIT IN PWA  *
NAMEREQA OI    599(@B),B'00010000'                                1105
*    R4=R4+1;                        /* PTR TO NEXT INPUT CHAR        *
         AH    @4,@D2                                             1106
*    PPOINTR=R4;                     /* SET PTR TO DATA NAME FOR SCAN *
         ST    @4,148(0,@B)                                       1107
*    GOTO NAMSCAN;                   /* CHECK FOR DATA NAME           *
         BC    15,NAMSCAN                                         1108
*
* NOPGMID:
*    R4=PPOINTR;                     /* UPDATE INPUT POINTERS         *
NOPGMID  L     @4,148(0,@B)                                       1109
*    R5=PPOINTR;                     /* UPDATE PTRS FOR GENSCAN       *
         L     @5,148(0,@B)                                       1110
*
* DNAMSCAN:                          /* PREPARE FOR GENSCAN           *
*
*    /*****************************************************************
*    /*                                                               *
*    /* DETERMINE IF TERM IS PROCESSING IN ERROR MODE                 *
*    /*                                                               *
*    /*****************************************************************
*
*    IF ERRORBIT='1'B                /* IKJTERM ERROR PROCESSING ?    *
*      THEN                          /* IF YES                        *
DNAMSCAN TM    599(@B),B'00001000'                                1111
*      GOTO NAMSCAN;                 /* CHECK FOR DATA NAME           *
         BC    01,NAMSCAN                                         1112
*    PRMTPTR=R4;                     /* SET UP FOR SPECIAL MSG        *
         ST    @4,584(0,@B)                                       1113
*
* NAMSCAN:
*    R1='D0'X;                       /* SET ALPHAMERIC MASK FOR       *
NAMSCAN  LA    @1,X'D0'                                           1114
*    ADDCDE=8;                       /* TYPETEST                      *
         LA    @F,8                                               1115
*    CALL LINKRET;                   /* GO TO TYPETEST FOR 1ST CHAR   *
         BAL   @E,LINKRET                                         1116
*    GOTO RSTPTRS;                   /* INVALID FIRST CHARACTER       *
         BC    15,RSTPTRS                                         1117
*
* LOOP:
*    DO R8 = 1 TO 30;                /* SCAN REST OF DATA NAME        *
LOOP     LA    @8,1                                               1118
*      R4 = R4+1;                    /* INCREMENT TO NEXT CHAR        *
@DO991   AH    @4,@D2                                             1119
*      R5 = R4;                      /* SET BACKUP POINTER            *
         LR    @5,@4                                              1120
*      IF R4=>ENDINPUT               /* IF AT END OF BUFFER    A00996 *
*        THEN                        /* THEN GO PROCESS        A00996 *
         C     @4,144(0,@B)                                       1121
*          GOTO SETPLNGH;            /* AS A DATANAME          A00996 *
         BC    10,SETPLNGH                                        1122
*      R1 = 'D0'X;                   /* SET ALPHAMERIC MASK FOR       *
         LA    @1,X'D0'                                           1123
*      ADDCDE = 8;                   /* TYPETEST TO CHECK OTHER       *
         LA    @F,8                                               1124
*      CALL LINKRET;                 /* CHARACTERS                    *
         BAL   @E,LINKRET                                         1125
*
*      /***************************************************************
*      /*                                                             *
*      /* GENERATE BRANCHES                                           *
*      /*                                                             *
*      /***************************************************************
*
*      GENERATE;
         BC    15,ERRORCHA             INVALID OTHER CHARACTER
         BC    15,CONTLOOP             IF VALID,CONTINUE SCAN
 DC      25F'0'
         DS    0H
*
* ERRORCHA:
*      IF COMBUF = '-'               /* HYPHEN IS ALSO A VALID CHAR   *
*        THEN
ERRORCHA CLI   0(@4),C'-'                                         1127
*        GOTO CONTLOOP;              /* EXCEPT FOR LAST CHAR          *
*      GOTO RESCAN;                  /* CHECK TO SEE IF VALID SEP-
*                                       ARATOR WAS FLAGGED AS INVAL-
*                                       ID OTHER CHARACTER            *
         BC    07,RESCAN                                          1129
*
* CONTLOOP:
*    END;                            /* END LOOP                      *
*
* MAXLNEXC:
*    GOTO VERRBIT;                   /* IF FALL THROUGH LOOP MAX
*                                       LENGTH FOR A DATA NAME WAS
*                                       EXCEEDED                      *
CONTLOOP AH    @8,@D2                                             1130
@DO990   CH    @8,@D6                                             1130
         BC    12,@DO991                                          1130
         BC    15,VERRBIT                                         1131
*
*    /*****************************************************************
*    /*                                                               *
*    /* SCAN THE INVALID OTHER CHARACTER TO MAKE SURE A VALID         *
*    /* DELIMITER IS THE INVALID OTHER CHARACTER. IF NOT, MUST PROCESS*
*    /* IN ERROR MODE                                                 *
*    /*                                                               *
*    /*****************************************************************
*
*
* RESCAN:
*    ADDCDE=8;                       /* CHECK TO SEE IF A SEPARATOR   *
RESCAN   LA    @F,8                                               1132
*    R1='08'X;                       /* IS THE INVALID CHAR           *
         LA    @1,X'08'                                           1133
*    CALL LINKRET;                   /* USE PARSE TYPETEST            *
         BAL   @E,LINKRET                                         1134
*    GEN;                            /* GENERATE BRANCHES +0 + +4     *
         BC   15,TPAR                  DELIMITER WAS NOT A SEPARATOR,
*                                      CHECK FOR OTHER VALID DELIMITERS
         BC   15,SETPLNGH              IF SEPARATOR, VALID - GO TO END
*                                      OF GOOD DATA NAME PROCESSING
         DS    0H
*
*
* TPAR:
*
*    /*****************************************************************
*    /*                                                               *
*    /* CHECK FOR END OF BUFFER WHICH IS VALID                        *
*    /*                                                               *
*    /*****************************************************************
*
*    IF R4=>ENDINPUT                 /* IS THIS END OF BUFFER? A00996 *
*      THEN                          /* IF SO GO PROCESS AS A         *
TPAR     C     @4,144(0,@B)                                       1136
*      GOTO SETPLNGH;                /* VALID DATA NAME               *
         BC    10,SETPLNGH                                        1137
*
*    /*****************************************************************
*    /*                                                               *
*    /* CHECK INPUT LINE FOR OTHER VALID SEPARATORS, OTHER THAN A     *
*    /* SEPARATOR. THESE ARE : ;, (, ), EOB OR ;                      *
*    /*                                                               *
*    /*****************************************************************
*
*    IF COMBUF='('                   /* INPUT LINE EQUAL LEFT PAREN   *
*      THEN                          /* THIS IS VALID GO TO PROCESS   *
         CLI   0(@4),C'('                                         1138
*      GOTO SETPLNGH;                /* END OF VALID DATA NAME        *
         BC    08,SETPLNGH                                        1139
*
*    /*****************************************************************
*    /*                                                               *
*    /* CHECK INPUT LINE FOR A RIGHT PAREN WHICH IS A VALID DELIMITER *
*    /*                                                               *
*    /*****************************************************************
*
*    IF COMBUF=')'                   /* IS THIS A RIGHT PAREN?        *
*      THEN                          /* IF YES, GO PROCESS AS A       *
         CLI   0(@4),C')'                                         1140
*      GOTO SETPLNGH;                /* VALID DATA NAME               *
         BC    08,SETPLNGH                                        1141
*
*
*    /*****************************************************************
*    /*                                                               *
*    /* CHECK FOR A COLON WHICH IS A VALID DELIMITER AND DELIMITS THE *
*    /* FIRST VALUE OF A RANGE                                        *
*    /*                                                               *
*    /*****************************************************************
*
*    IF COMBUF=':'                   /* IS THIS A COLON?              *
*      THEN                          /* IF YES, PROCESS AS A          *
         CLI   0(@4),C':'                                         1142
*      GOTO SETPLNGH;                /* VALID DATA NAME               *
         BC    08,SETPLNGH                                        1143
*
*    /*****************************************************************
*    /*                                                               *
*    /* CHECK FOR SEMICOLON. IF NOT A SEMICOLON WE HAVE AN INVALID    *
*    /* DELIMITER AND ERROR MODE MUST BE ENTERED                      *
*    /*                                                               *
*    /*****************************************************************
*
*    IF COMBUF^=';'                  /* IF NOT A SEMICOLON, MUST      *
*      THEN                          /* INCREMENT XINPUT FOR ERROR    *
         CLI   0(@4),C';'                                         1144
         BC    08,@98D                                            1144
*      DO;                           /* SCAN                          *
*        R4=R4+1;                    /* INCREMENT TO NEXT CHAR        *
         AH    @4,@D2                                             1146
*        GOTO VERRBIT;               /* GO TO ERROR PROCESSING        *
         BC    15,VERRBIT                                         1147
*      END;                          /* IF IS A SEMICOLON, FALL
*                                       THROUGH TO PROCESS VALID DATA
*                                       NAME                          *
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF COME TO HERE, HAVE FOUND A VALID DATA NAME FOLLOWED BY A   *
*    /* VALID DELIMITER. NOW MUST CHECK THE DATA NAME TO MAKE SURE IT *
*    /* CONTAINS AT LEAST ONE ALPHABETIC. IF NOT IT IS AN ERROR. IF   *
*    /* THE LAST CHAR IS A HYPHEN IT IS ALSO AN ERROR.                *
*    /*                                                               *
*    /*****************************************************************
*
*
* SETPLNGH:                          /* SAVE LENGTH OF DATA FOR PDE   *
*    PFENDSET='0'B;                  /* INDICATE GOOD DN AFTER STACK
*                                       POPPED                        *
@98D     EQU   *                                                  1149
SETPLNGH NI    179(@B),B'11111011'                                1149
*    PLENGTH=R4-PPOINTR;             /* LENGTH IN PLENGTH             *
         L     @F,148(0,@B)                                       1150
         LCR   @F,@F                                              1150
         AR    @F,@4                                              1150
         STH   @F,152(0,@B)                                       1150
*    R4=PPOINTR;                     /* RESET XINPUT TO BEGINNING OF
*                                       DATA NAME                     *
         L     @4,148(0,@B)                                       1151
*
* TSTLOOP:
*    ADDCDE=8;                       /* SET UP LOOP TO FIND AT        *
TSTLOOP  LA    @F,8                                               1152
*    R1='C0'X;                       /* LEAT ONE ALPHABETIC           *
         LA    @1,X'C0'                                           1153
*    CALL LINKRET;                   /* GO TO PARSE TYPETEST          *
         BAL   @E,LINKRET                                         1154
*
*    /*****************************************************************
*    /*                                                               *
*    /* GENERATE APPROPRIATE BRANCH +0 NOT ALPHA, +4 ALPHA            *
*    /*                                                               *
*    /*****************************************************************
*
*    GEN;
         BC   15,NOTALPHA              PROCESS NOT ALPHA - CONTINUE
*                                      LOOP
         BC   15,ALPHAFND              VALID DATA NAME CONTINUE SCAN
         DS    0H
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF AN ALPHA WAS NOT FOUND, CHECK TO DETERMINE IF HAVE SCANNED *
*    /* THE ENTIRE DATA NAME WITHOUT FINDING AN ALPHA. IF SO, IT IS   *
*    /* AND ERROR. IF NOT, CONTINUE ALPHA SCAN                        *
*    /*                                                               *
*    /*****************************************************************
*
*
* NOTALPHA:                          /* DETERMINE IF AT THE END OF    *
*    IF R4=PPOINTR+PLENGTH-1         /* THE DATA NAME, IF SO GO       *
*      THEN                          /* TO PROCESS AS AN              *
NOTALPHA LH    @F,@D7                                             1156
         AH    @F,152(0,@B)                                       1156
         A     @F,148(0,@B)                                       1156
         CR    @F,@4                                              1156
*      GOTO SETERBT2;                /* ERROR                         *
         BC    08,SETERBT2                                        1157
*    R4=R4+1;                        /* IF NOT AT END OF DATA NAME    *
         AH    @4,@D2                                             1158
*    GOTO TSTLOOP;                   /* CONTINUE SCAN WITH NEXT
*                                       CHARACTER                     *
         BC    15,TSTLOOP                                         1159
*
* ALPHAFND:                          /* IF AN ALPHA WAS FOUND         *
*    R4=R5-1;                        /* CHECK LAST CHAR OF DATA NAME
*                                       FOR NON-HYPHEN                *
ALPHAFND LH    @4,@D7                                             1160
         AR    @4,@5                                              1160
*
*    /*****************************************************************
*    /*                                                               *
*    /* IS THE LAST CHARACTER A HYPHEN. XINPUTB AT THIS POINT IS SET  *
*    /* TO ONE AFTER THE LAST CHARACTER. XINPUT IS POINT- AT THE LAST *
*    /* CHARACTER                                                     *
*    /*                                                               *
*    /*****************************************************************
*
*    IF COMBUF='-'                   /* IF THE LAST CHARACTER IS A    *
*      THEN                          /* HYPHEN THEN PROCESS REMAIN-   *
         CLI   0(@4),C'-'                                         1161
*      GOTO SETERBT2;                /* DER IN ERROR MODE             *
         BC    08,SETERBT2                                        1162
*
*    /*****************************************************************
*    /*                                                               *
*    /* NOW CHECK TO SEE IF IN ERROR MODE. IF IN ERROR MODE HAVE FOUND*
*    /* ERROR PREVIOUSLY AND WANT TO BYPASS FILLINT IN THE PDE        *
*    /*                                                               *
*    /*****************************************************************
*
*    IF ERRORBIT='1'B                /* IF THE ERROR FLAG IS ON       *
*      THEN                          /* GO TO PROCESS THE END OF      *
         TM    599(@B),B'00001000'                                1163
*      GOTO ENDSCAN;                 /* THE DATA NAME WITHOUT FILLING
*                                       IN THE PDE                    *
         BC    01,ENDSCAN                                         1164
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF THIS IS A QUALIFIER FOR THE ORIGINAL DATA NAME, MUST GO DO *
*    /* SPECIAL PROCESSING. CORE MUST BE GOTTEN IF REQUIRED AND THE   *
*    /* PDE FOR THE QUALIFIER MUST BE FILLED IN DIFFERENTLY THAN FOR  *
*    /* THE FIRST DATA NAME                                           *
*    /*                                                               *
*    /*****************************************************************
*
*    IF QUALCT^=0                    /* IF QUALIFIER COUNT IS NOT     *
*      THEN                          /* ZERO WE ARE PROCESSING        *
         CLI   598(@B),0                                          1165
*      GOTO CORETEST;                /* A QUALIFIER AND MUST DO
*                                       SPECIAL PROCESSING TO FILL IN
*                                       THE PDE                       *
         BC    07,CORETEST                                        1166
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF THIS IS A GOOD DATA NAME (FIRST) WE WILL FALL THROUGH TO   *
*    /* HERE TO ADD THE DATA NAME INFORMATION TO THE PDE              *
*    /*                                                               *
*    /*****************************************************************
*
*
* ADDNAME:
*    ADDCDE=9;                       /* THE DATA NAME MUST BE TRANS   *
ADDNAME  LA    @F,9                                               1167
*    CALL LINKRET;                   /* LATED TO UPPERCASE IF
*                                       SPECIFIED IN THE PDE          *
         BAL   @E,LINKRET                                         1168
*    DNAMEPTR=PPOINTR;               /* SET DATANAME PTR IN PDE       *
         L     @1,564(0,@B)        
         MVC   0(4,@1),148(@B)                                    1169
*    PARMIND='1'B;                   /* INDICATE PARM IS PRESENT      *
         OI    6(@1),B'10000000'                                  1170
*    LNGTH4=PLENGTH;                 /* STORE THE LENGTH OF THE DATA
*                                       NAME IN PDE                   *
         MVC   4(1,@1),153(@B)                                    1171
*    DATAPTRH='FF000000'X;           /* SET QUALIFIER POINTR TO
*                                       FF000000 TO INDICATE NO
*                                       QUALIFIERS HAVE BEEN ADDED UP
*                                       TO THIS TIME                  *
         MVC   8(4,@1),@X27                                       1172
*    CHAINPTR=ADDR (DATAPTR);        /* SAVE THE PTR TO THE QUALI-
*                                       FIIER PTR SO CAN FILL IN IF
*                                       QUALIFIER ENCOUNTERED         *
         LA    @F,8(0,@1)                                         1173
         ST    @F,560(0,@B)                                       1173
*    IF FIRSTNAM^='1'B               /* IF NOT FIRST DATA NAME OF     *
*      THEN                          /* VARIABLE, GO TO END OF        *
         TM    601(@B),B'10000000'                                1174
*      GOTO ENDSCAN;                 /* DATA NAME SCAN                *
         BC    12,ENDSCAN                                         1175
*    FIRSTNAM='0'B;                  /* IF ON, TURN OFF - FIRST DATA
*                                       NAME SCANNED                  *
         NI    601(@B),B'01111111'                                1176
*    IF LNGTH5 ^= 0                  /* IF NAMEREQD ON, PGMID         *
*      THEN                          /* PRECEEDED DATA NAME. MUST     *
         L     @1,564(0,@B)        
         CLI   16(@1),0                                           1177
         BC    08,@98C                                            1177
*      MSGLEN=LNGTH4+LNGTH5+1;       /* ADD PGMID LENGTH TO DATA NAME
*                                       LENGTH                        *
         LA    @F,1                                               1178
         SR    @0,@0                                              1178
         IC    @0,16(0,@1)                                        1178
         AR    @F,@0                                              1178
         IC    @0,4(0,@1)                                         1178
         AR    @F,@0                                              1178
         STH   @F,590(0,@B)                                       1178
         BC    15,@98B                                            1179
*    ELSE                            /* IF NO PGMID, FILL IN          *
*      DO;                           /* MESSAGE FIELDS WITH           *
*        MSGADDR=PPOINTR;            /* ADDRESS AND LENGTH            *
@98C     MVC   592(4,@B),148(@B)                                  1180
*        MSGLEN=PLENGTH;             /* OF DATA NAME JUST             *
         MVC   590(2,@B),152(@B)                                  1181
*      END;                          /* SCANNED                       *
*    GOTO ENDSCAN;                   /* GOTO PROCESS THE END OF THIS
*                                       DATA NAME AND CONTINUE THE
*                                       SCAN                          *
         BC    15,ENDSCAN                                         1183
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF COME TO SETERBT2, AN ERROR HAS BEEN FOUND WHILE PROCESSING *
*    /* THE DATA NAME. THE ERROR BIT MUST BE SET BEFORE CONTINUING THE*
*    /* SCAN TO FIND THE END OF THE TERM                              *
*    /*                                                               *
*    /*****************************************************************
*
*
* SETERBT2:                          /* SET THE ERROR MODE BIT AND    *
*    ERRORBIT='1'B;                  /* PFNOPOP TO PREVENT POPPING    *
SETERBT2 OI    599(@B),B'00001000'                                1184
*    PFNOPOP='1'B;                   /* PREVENT STACK POPPING         *
         OI    179(@B),B'00000010'                                1185
*
*    /*****************************************************************
*    /*                                                               *
*    /* THE END OF A GOOD DATA NAME HAS BEEN FOUND. SAVE THE END OF   *
*    /* THE DATA NAME IN CASE HAVE TO BACK UP, I.E., NO QUALIFIER OR  *
*    /* SUBSCRIPT FOLLOWS. ALSO DETERMINE THE TYPE OF DELIMITER WHICH *
*    /* FOLLOWS THE DATA NAME. THE DELIMITER WILL DETERMINE THE TYPE  *
*    /* OF PROCESSING. IF BLANKS FOLLOW, QUALIFIERS AND SUBSCRIPTS    *
*    /* MUST BE TESTED FOR. IF NO BLANKS, MUST BE A VALID DELIMITER,  *
*    /* I.E., ( ) ; EOB :                                             *
*    /*                                                               *
*    /*****************************************************************
*
*
* ENDSCAN:
*    ENDNMPTR=R4;                    /* SAVE THE END OF THE DATA NAME
*                                       IN CASE SOMETHING NOT
*                                       ASSOCIATED WITH THIS TERM PCE
*                                       FOLLOWS                       *
ENDSCAN  ST    @4,556(0,@B)                                       1186
*    CALL BUMP;                      /* INCREMENT SCAN PTR TO NEXT
*                                       NEXT CHARACTER                *
         BAL   @E,BUMP                                            1187
*
*    /*****************************************************************
*    /*                                                               *
*    /* BRANCH TO APPROPRIATE ROUTINE TO HANDLE TYPE OF DELIMITER     *
*    /* FOLLOWING DATA                                                *
*    /*                                                               *
*    /*****************************************************************
*
*    GEN;
         BC   15,ENDCK                 NO MORE DATA - EOB
         BC   15,MORDTA                MORE DATA AFTER DATA NAME
         BC   15,XINUP2                STACK HAS BEEN POPPED AND MORE
         DS    0H
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF IN SUBSCRIPT MODE AND NO ERROR MUST ISSUE 'ENDING PAREN    *
*    /* ASSUMED' MESSAGE THROUGH ROUTINE IS CONSTAND                  *
*    /*                                                               *
*    /*****************************************************************
*
*
* ENDCK:
*    IF PFENDSET='1'B                /* IF THE BUFFER HAS      A00996 *
*      THEN                          /* BEEN POPPED, MUST      A00996 *
ENDCK    TM    179(@B),B'00000100'                                1189
         BC    12,@98A                                            1189
*        DO;                         /* RESET BUFFER           A00996 *
*          ENDINPUT=ENDBAKUP;        /* POINTERS TO PREVIOUS   A00996 *
         MVC   144(4,@B),412(@B)                                  1191
*          R4=ENDNMPTR+1;            /* BUFFER AT END OF       A00996 *
         LA    @4,1                                               1192
         A     @4,556(0,@B)                                       1192
*          R5=ENDBAKUP;              /* VARIABLE JUST SCANNED  A00996 *
         L     @5,412(0,@B)                                       1193
*          PFENDSET='0'B;            /* RESET BUFFER POPPED    A00996 *
         NI    179(@B),B'11111011'                                1194
*        END;                        /* INDICATOR              A00996 *
*    IF SUBSMODE='1'B                /* IF IN SUBSCRIPT MODE, GO      *
*      THEN                          /* ISSUE 'ENDING PAREN           *
@98A     TM    599(@B),B'00100000'                                1196
*      GOTO ENDSUB;                  /* DO NOT HAVE TO ISSUE MESSAGE. *
         BC    01,ENDSUB                                          1197
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF FALL THROUGH MUST GO TO RANGE TO GET RNGEVAL2 TURNED ON IF *
*    /* PROCESSING THE 2ND VALUE OF A RANGE AND A VALID END DELIMITER *
*    /* HAS BEEN FOUND                                                *
*    /*                                                               *
*    /*****************************************************************
*
*
* RANGESET:                          /* GO TO RANGE, TO GET           *
*    CALL TSTRNGE;                   /* PROCESS RANGE, ONLY    A00996
*                                       POSSIBLE RETURN
*                                       IS +0 BECAUSE KNOW NOT
*                                       POINTING AT A COLON           *
RANGESET L     @F,@V5              ADDRESS OF TSTRNGE             1198
         BALR  @E,@F                                              1198
*
*    /*****************************************************************
*    /*                                                               *
*    /* THIS IS A COMMON EXIT ROUTINE WHICH DETERMINES THE PROCESSING *
*    /* ENVIRONMENT AT THE TIME OF ADDING THE PDE IF IN ERRORMODE, NO *
*    /* PDE PROCESSING IS NECESSARY.                                  *
*    /*                                                               *
*    /*****************************************************************
*
*
* EXIT:
*    IF ERRORBIT='1'B                /* IF ERRORMODE, GO DIRECTLY     *
*      THEN                          /* TO END PROCESSING. NO PDE     *
EXIT     TM    599(@B),B'00001000'                                1199
*      GOTO CODE4;                   /* PROCESSING                    *
         BC    01,CODE4                                           1200
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF THE NUMBER OF QUALIFIERS HAVE EXCEEDED 256, IT IS AN ERROR *
*    /*                                                               *
*    /*****************************************************************
*
*
* EXITA:
*    IF QUALCT=256                   /* IS QUALIFIER COUNT=> 256?     *
*      THEN                          /* IF YES, SET                   *
EXITA    LA    @F,256                                             1201
         SR    @0,@0                                              1201
         IC    @0,598(0,@B)                                       1201
         CR    @F,@0                                              1201
         BC    07,@989                                            1201
*      DO;                           /* THE ERRORBIT ON               *
*        ERRORBIT='1'B;              /* AND GO TO ERROR ROUTINE       *
         OI    599(@B),B'00001000'                                1203
*        PFNOPOP='1'B;               /* PREVENT STACK POPPING         *
         OI    179(@B),B'00000010'                                1204
*        GOTO PRMTEXT;               /* IN THE END PROCESSING RTN     *
         BC    15,PRMTEXT                                         1205
*      END;                          /* END ERROR PROCESSING FOR MORE
*                                       THAN 255 QUALIFIERS           *
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF NO ERROR, SPECIAL PROCESSING MUST BE DONE TO COMPLETE THE  *
*    /* PDE BEFORE GOING TO POSITXCB IN PARSE TO ADD THE PDE TO THE   *
*    /* PDL                                                           *
*    /*                                                               *
*    /*****************************************************************
*
*
* ZEROQLCT:                          /* ADD QUALIFIER COUNT IF        *
*                                    /* REQUIRED                      *
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF THE TERM IS NOT A VARIABLE DO NOT WANT TO ADD THE QUALIFIER*
*    /* COUNT                                                         *
*    /*                                                               *
*    /*****************************************************************
*
*    IF CONST='1'B                   /* IF PDE DESCRIBES A CONS-      *
*      THEN                          /* SKIP OVER ADDING              *
@989     EQU   *                                                  1207
ZEROQLCT L     @1,564(0,@B)        
         TM    6(@1),B'01000000'                                  1207
*      GOTO SKPQLST;                 /* QUALIFIER COUNT               *
         BC    01,SKPQLST                                         1208
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF STATEMENT PDE, SKIP ADDING QUALIFIER COUNT                 *
*    /*                                                               *
*    /*****************************************************************
*
*    IF STATE='1'B                   /* STATEMENT PDE?                *
*      THEN                          /* SKIP ADDING                   *
         TM    6(@1),B'00010000'                                  1209
*      GOTO SKPQLST;                 /* QUALIFIER COUNT               *
         BC    01,SKPQLST                                         1210
*    NUMQUAL=QUALCT;                 /* IF FALL THROUGH, IS A VAR-    *
         MVC   17(1,@1),598(@B)                                   1211
*    QUALCT=0;                       /* PDE. QUALIFIER COUNT MUST BE
*                                       ADDED AND THE COUNTER SET TO
*                                       ZERO                          *
         MVI   598(@B),0                                          1212
*    R6=TERMXPCE;                    /* RESET THE PCE PTR TO THE MAJOR
*                                       PCE IN CASE PROCES- UNDER A
*                                       SUBSCPCE                      *
         L     @6,528(0,@B)                                       1213
*
* SKPQLST:
*    PDEPTR=ADDR (TEMPPDE);          /* RESET THE PDE PTR TO THE THE
*                                       BEGINNING OF THE TEMP- ORARY
*                                       PDE FOR ADDING                *
SKPQLST  LA    @F,332(0,@B)                                       1214
         ST    @F,564(0,@B)                                       1214
*    IF OPERMODE^='1'B               /* IF OPERMODE NOT ON CONTINUE   *
*      THEN                          /* NORMAL PARSE AND DO NOT       *
         TM    599(@B),B'01000000'                                1215
*      GOTO VAREXIT;                 /* CHECK FOR MORE DATA           *
         BC    12,VAREXIT                                         1216
*    IF PRMTSCAN^='1'B               /* IF OPERMODE, BUT HAVE NOT     *
*      THEN                          /* PROMPTED PREVIOUSLY, DON'T    *
         TM    600(@B),B'00000100'                                1217
*      GOTO VAREXIT;                 /* FOR MORE DATA                 *
         BC    12,VAREXIT                                         1218
*    IF PFENDSET='1'B                /* IF HAVE SCANNED ENTIRE        *
*      THEN                          /* PROMPT BUFFER, PROMPT         *
         TM    179(@B),B'00000100'                                1219
*      GOTO VAREXIT;                 /* RESPONSE WAS GOOD             *
         BC    01,VAREXIT                                         1220
*    PFNOPOP='1'B;                   /* DON'T ALLOW STACK POPPING     *
         OI    179(@B),B'00000010'                                1221
*    ADDCDE=5;                       /* GO TO SKIPB TO SEE IF ADDIT   *
         LA    @F,5                                               1222
*    CALL LINKRET;                   /* DATA ENTERED ON PROMPT IN
*                                       OPERMODE. IF SO, ERROR        *
         BAL   @E,LINKRET                                         1223
*    GOTO VAREXIT;                   /* IF +0, NO MORE DATA - O.K.    *
         BC    15,VAREXIT                                         1224
*    ERRORBIT='1'B;                  /* +4, MORE DATA - ERROR         *
         OI    599(@B),B'00001000'                                1225
*    PFNOPOP='1'B;                   /* PREVENT STACK POPPING         *
         OI    179(@B),B'00000010'                                1226
*    GOTO CODE4;                     /* GO TO MESSAGE PROCESSOR       *
         BC    15,CODE4                                           1227
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF SKIPB HAS DETECTED THE END OF THE BUFFER, DO NOT WANT TO   *
*    /* SET XINPUTB = XINPUT FOR POSSIBLE ERROR FROM VALIDITY CHECK   *
*    /* EXIT. THIS WILL PREVENT LOSING THE END OF THE BUFFER          *
*    /*                                                               *
*    /*****************************************************************
*
*
* VAREXIT:
*    IF PFENDF^='1'B                 /* IF SKIPB DID NOT DETECT EOB   *
*      THEN                          /* THEN SET XINPUTB = XINPUT     *
VAREXIT  TM    176(@B),B'00100000'                                1228
         BC    01,@988                                            1228
*      R5=R4;                        /* FOR POSSIBLE ERROR MESSAGE    *
         LR    @5,@4                                              1229
*    GOTO CODE4;                     /* IN EITHER CASE GO TO END OF
*                                       TERM PROCESSING               *
         BC    15,CODE4                                           1230
*    GEN (EJECT);
         EJECT
         DS    0H
*
*    /*****************************************************************
*    /*                                                               *
*    /* THIS ROUTINE IS ENTERED IF MORE DATA WAS DETECTED AFTER A GOOD*
*    /* DATA NAME. TESTS MUST BE MADE TO SEE WHAT KIND OF DATA        *
*    /* FOLLOWS; SEPARATORS, OR DELIMITERS                            *
*    /*                                                               *
*    /*****************************************************************
*
*
* MORDTA:
*    ADDCDE=8;                       /* GO TO TYPETEST TO DETER-      *
MORDTA   LA    @F,8                                               1232
*    R1='08'X;                       /* IF SEPARATOR FOLLOWS          *
         LA    @1,X'08'                                           1233
*    CALL LINKRET;                   /* INTERFACE TO PARSE            *
         BAL   @E,LINKRET                                         1234
*    GEN;                            /* RETURN BRANCHES               *
         BC   15,GDNNBL                GO TO GOOD NAME NO BLANKS RTN
         DS    0H
*
*    /*****************************************************************
*    /*                                                               *
*    /* ROUTINE ENTERED IF SEPARATORS FOUND AFTER A GOOD DATA NAME    *
*    /*                                                               *
*    /*****************************************************************
*
*
* VSEPSKIP:                          /* SKIP THE FOLLOWING SEP-       *
*    ADDCDE=5;                       /* USING THE PARSE SKIPB         *
VSEPSKIP LA    @F,5                                               1236
*    CALL LINKRET;                   /* ROUTINE                       *
         BAL   @E,LINKRET                                         1237
*    GOTO ENDCK;                     /* IF NOT MORE DATA (+0 RET) GOTO
*                                       THE END OF DATA ROUTIN        *
         BC    15,ENDCK                                           1238
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF MORE DATA APPEARS AFTER THE SEPARATORS, MUST CHECK FOR     *
*    /* QUALIFIERS. QUALIFIERS ARE PRECEDED BY IN OR OF               *
*    /*                                                               *
*    /*****************************************************************
*
*
* XINUP2:
*    R4=R4+2;                        /* MSUT CHECK TO MAKE     A00996 *
XINUP2   AH    @4,@D4                                             1239
*    IF R4=>ENDINPUT                 /* SURE ENDINPUT IS NOT   A00996 *
*      THEN                          /* WITHIN NEXT TWO CHARS  A00996 *
         C     @4,144(0,@B)                                       1240
         BC    04,@987                                            1240
*        DO;                         /* SO DON'T REFERENCE     A00996 *
*          R4=R4-1;                  /* OUTSIDE OF PARSE2      A00996
*                                       REGION. POINT AT CHAR  A00996 *
         BCTR  @4,0                                               1242
*          GOTO ASIS1;               /* AND GO TO PROCESS AS   A00996 *
         BC    15,ASIS1                                           1243
*        END;                        /* DELIMITER              A00996 *
*    R4=R4-1;                        /* POINT AT FIRST CHAR    A00996 *
@987     BCTR  @4,0                                               1245
*    TRANAREA=COMBUFA;               /* MOVE TWO CHARACTERS FROM IN   *
         MVC   604(2,@B),0(@4)                                    1246
*    TRANAREA (1:2)=                 /* PUT OT WORD AREA TO TRANS-    *
*          TRANAREA(1:2)'  ';       /* LATE THEM TO UPPER CASE       *
         OC    604(2,@B),@C28                                     1247
*
*    /*****************************************************************
*    /*                                                               *
*    /* CHECK FOR QUALIFIER DELIMETER WORD - IN                       *
*    /*                                                               *
*    /*****************************************************************
*
*    IF TRANAREA^='IN'               /* CHECK TWO CHARACTERS FOR      *
*      THEN                          /* IN OR OF                      *
         CLC   604(2,@B),@C29                                     1248
         BC    08,@986                                            1248
*
*      /***************************************************************
*      /*                                                             *
*      /* IF NOT IN, CHECK FOR OF. IF NEITHER, GO TO THE ROUTINE TO   *
*      /* PROCESS DELIMITERS OTHER THAN IN OR OF FOLLOWING A DATA NAME*
*      /* WHICH HAS BLANKS FOLLOWING IT                               *
*      /*                                                             *
*      /***************************************************************
*
*      IF TRANAREA^='OF'             /* IF NOT IN, IS IT OF           *
*        THEN                        /* IF NEITHER, GO TO THE         *
         CLC   604(2,@B),@C30                                     1249
*        GOTO ASIS1;                 /* DELIMITER AFTER BLANKS RTN    *
         BC    07,ASIS1                                           1250
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF FALL THROUGH TO HERE AN IN OR OF WAS FOUND IN THE BUFFER.  *
*    /* SPECIAL PROCESSING FOR THE QUALIFIERS OF THIS DATA NAME MUST  *
*    /* BE DONE                                                       *
*    /*                                                               *
*    /*****************************************************************
*
*
* TRNSLATE:                          /* CHECK TO SEE IF UPPERCASE     *
*    IF ASIS='1'B                    /* IS REQUESTED IN THE PCE       *
*      THEN                          /* IF NOT (ASIS BIT ON), THEN    *
@986     EQU   *                                                  1251
TRNSLATE TM    1(@6),B'01000000'                                  1251
*      GOTO XINUP3;                  /* SKIP OVER TRANSLATION         *
         BC    01,XINUP3                                          1252
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF UPPERCASE REQUESTED, MOVE THE TWO BYTES FROM THE TRANAREA  *
*    /* BACK TO THE INPUT BUFFER                                      *
*    /*                                                               *
*    /*****************************************************************
*
*    IF PFDEFLT='1'B                 /* IF PROCESSING A DEFAULT       *
*      THEN                          /* IN THE PCE CANNOT CHANGE      *
         TM    176(@B),B'01000000'                                1253
*      GOTO XINUP3;                  /* THE DATA IN THE USER'S CORE
*                                       (THE PCE IS IN HIS PROGRAM    *
         BC    01,XINUP3                                          1254
*    COMBUF (1:2)=TRANAREA;          /* OTHERWISE, MOVE IN UPPER- CASE
*                                       DATA                          *
         MVC   0(2,@4),604(@B)                                    1255
*
*    /*****************************************************************
*    /*                                                               *
*    /* SKIP OVER THE IN OR OF AND SET UP FOR PROCESSING THE THE      *
*    /* QUALIFYING DATA NAME                                          *
*    /*                                                               *
*    /*****************************************************************
*
*
* XINUP3:
*    R4=R4+1;                        /* INCREMENT XINPUT PASSED       *
XINUP3   AH    @4,@D2                                             1256
*    CALL BUMP;                      /* THE IN OR OF                  *
         BAL   @E,BUMP                                            1257
*    GOTO SETER;                     /* IF BUMP RETURNS +0,    A00996
*                                       EOB WAS DETECTED       A00996
*                                       THIS IS AN ERROR AFTER A00996
*                                       IN OR OF               A00996 *
         BC    15,SETER                                           1258
*
*    /*****************************************************************
*    /*                                                               *
*    /* GENERATE BRANCHES FOR +4- MORE DATA, +8 - MORE DATA STACK     *
*    /* POPPED                                                        *
*    /*                                                               *
*    /*****************************************************************
*
*    GEN;
         BC   15,BLNKTEST              MORE DATA IN BUFFER
         BC   15,VSEPSK                STACK POPPED MORE DATA  A00996
         DS    0H
*
* BLNKTEST:                          /* DETERMINE IF SEP AFTER INOF   *
*    ADDCDE=8;                       /* IF BUMP RETURNS +4 , MUST
*                                       CHECK TO MAKE SURE SEP FOL-   *
BLNKTEST LA    @F,8                                               1260
*    R1='08'X;                       /* IN OR OF. IF NOT A SEP, THE IN
*                                       OR OF IS PART OF ANOTHER PCE
*                                       TERM AND WE MUST BACK UP AND
*                                       CONSIDER THE DATA NAME BEFORE
*                                       THE IN OR OF AS A VALID DATA
*                                       NAME                          *
         LA    @1,X'08'                                           1261
*    CALL LINKRET;                   /* GOT TO TYPETEST               *
         BAL   @E,LINKRET                                         1262
*    GEN;                            /* GENERATE RETURN BRANCHES      *
         BC   15,ENDNAME               NO SEPARATOR FOUND +0
         BC   15,VSEPSK1               IF SEPARATOR, SKIP THEM
         DS    0H
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF NO BLANKS FOLLOW THE IN OR OF, WE MUST BACK UP TO THE END  *
*    /* OF THE PREVIOUS GOOD DATA NAME. IF WE HAVE POPPED THE STACK TO*
*    /* REACH THE IN.. OF.., WE MUST PUSH THESE ON THE STACK FOR LATER*
*    /* PROCESSING SO THEY ARE NOT LOST                               *
*    /*                                                               *
*    /*****************************************************************
*
*
* ENDNAME:
*    IF SUBSMODE='1'B                /* IF IN SUBSCRIPT MODE   A00996 *
*      THEN                          /* RESET THE INPUT PTR    A00996 *
ENDNAME  TM    599(@B),B'00100000'                                1264
         BC    12,@985                                            1264
*        DO;                         /* TO PROCESS             A00996 *
*          R4=R4-2;                  /* RESET TO BEGINNING     A00996 *
         SH    @4,@D4                                             1266
*          GOTO ASIS1;               /* FINSH PROCESSING       A00996 *
         BC    15,ASIS1                                           1267
*        END;                        /* END                    A00996 *
*    IF PFENDSET='1'B                /* WAS THE PROMPT BUFFER POP-    *
*      THEN                          /* PED OFF THE STACK, IF SO      *
@985     TM    179(@B),B'00000100'                                1269
         BC    12,@984                                            1269
*      DO;                           /* THE IN. OF. MUST BE SAVED     *
*        R4=R4-3;                    /* BACK THE BUFFER PTR TO BEFORE
*                                       THE IN. OF.                   *
         SH    @4,@D8                                             1271
*        ADDCDE=17;                  /* PREPARE TO CALL PUSH THE      *
         LA    @F,17                                              1272
*        CALL LINKRET;               /* STACK ROUTINE IN PARSE        *
         BAL   @E,LINKRET                                         1273
*        ENDINPUT=ENDBAKUP;          /* ON RETURN, RESET THE EOB
*                                       INDICATOR TO THE END OF THE
*                                       PREVIOUS BUFFER BEFORE IT WAS
*                                       POPPED                        *
         MVC   144(4,@B),412(@B)                                  1274
*      END;                          /* END SPECIAL PROMPT BUFFER
*                                       PROCESSING                    *
*    R4=ENDNMPTR+1;                  /* IN EITHER CASE MUST RESET THE
*                                       INPUT BUFFER TO THE END OF THE
*                                       PREVIOUS DATA NAME            *
@984     LA    @4,1                                               1276
         A     @4,556(0,@B)                                       1276
*    GOTO ZEROQLCT;                  /* GOTO PROCESS THE END OF THE
*                                       DATA NAME AND FILL IN THE PDE
*                                       INFO REQUIRED                 *
         BC    15,ZEROQLCT                                        1277
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF SEPARATORS WERE DETECTED AFTER THE IN OR OF, SKIP THEM AND *
*    /* DETERMINE TYPE OF PROCESSING WHICH FOLLOWS                    *
*    /*                                                               *
*    /*****************************************************************
*
*
* VSEPSK1:
*    ADDCDE=5;                       /* SKIP THE FOLLOWING SEPS       *
VSEPSK1  LA    @F,5                                               1278
*    CALL LINKRET;                   /* THROUGH AKIPB RTN IN PARSE    *
         BAL   @E,LINKRET                                         1279
*    GOTO SETER;                     /* IF EOB OCCURS, THIS IS AN
*                                       ERROR, SINCE IN OR OF MUST BE
*                                       FOLLOWED BY A VALID DATA NAME *
         BC    15,SETER                                           1280
* VSEPSK:                            /* MORE DATA AFTER SEPS   A00996 *
*    R4=R4+1;                        /* IF MORE DATA, SET XINPUT TO
*                                       THE FIRST CHARACTER           *
VSEPSK   AH    @4,@D2                                             1281
*    NAMEREQD='1'B;                  /* INIDCATE THAT A GOOD DATA NAME
*                                       IS REQUIRED AT THIS POINT IN
*                                       THE BUFFER                    *
         OI    599(@B),B'00010000'                                1282
*    QUALCT=QUALCT+1;                /* ADD ONE TO THE QUALIFIER COUNT
*                                       - KNOW AT THIS TIME THAT THIS
*                                       MUST BE A QUALI- FIER         *
         LA    @F,1                                               1283
         SR    @0,@0                                              1283
         IC    @0,598(0,@B)                                       1283
         AR    @F,@0                                              1283
         STC   @F,598(0,@B)                                       1283
*    GOTO DNAMSCAN;                  /* GO TO SCAN THE QUALIFIER AS A
*                                       DATA NAME                     *
         BC    15,DNAMSCAN                                        1284
*
* SETER:
*    IF PFENDSET='1'B                /* IF BUFFER WAS POPPED          *
*      THEN                          /* MUST RESET BUFFER POINT       *
SETER    TM    179(@B),B'00000100'                                1285
         BC    12,@983                                            1285
*      DO;                           /* ERS, SO WILL BE CORRECT       *
*        R4=ENDBAKUP;                /* FOR MESSAGE. ENDBAKUP         *
         L     @4,412(0,@B)                                       1287
*        ENDINPUT=ENDBAKUP;          /* SET WHEN STACK POPPED         *
         MVC   144(4,@B),412(@B)                                  1288
*      END;                          /* END SPECIAL PROCESSING        *
*    ERRORBIT='1'B;                  /* IF NO DATA AFTER IN OR OF THIS
*                                       IS AN ERROR                   *
@983     OI    599(@B),B'00001000'                                1290
*    PFNOPOP='1'B;                   /* PREVENT STACK POPPING         *
         OI    179(@B),B'00000010'                                1291
*    R4=R4+1;                        /* SET XINPUT = EOB              *
         AH    @4,@D2                                             1292
*    GOTO CODE4;                     /* GO TO END PROCESSING          *
         BC    15,CODE4                                           1293
*    GEN (EJECT);
         EJECT
         DS    0H
*
*    /*****************************************************************
*    /*                                                               *
*    /* THIS ROUTINE IS ENTERED WHEN A GOOD DATA NAME IS FOUND AND THE*
*    /* DATA NAME IF FOLLOWED BY A DELIMITER OTHER THAN A SEPARATOR.  *
*    /* THE TYPE OF DELIMITER IS DETERMINED AND THE TYPE OF PROCESSING*
*    /* REQUIRED IS DETERMINED BY THE TYPE OF DELIMITER FOLLOWING THE *
*    /* DATA NAME. IF A ( FOLLOWS A GOOD DATA NAME WITH NO BLANKS     *
*    /* BETWEEN THE DATA NAME AND THE (, THE DATA AFTER THE LEFT PAREN*
*    /* IS AUTOMATICALLY CONSIDERED A SUBSCRIPT IF THE SUBSCRIPTABLE  *
*    /* OPTION IS IN THE TERM PCE. IF THERE IS NO SUBSCRIPTABLE       *
*    /* OPTION, THIS LEFT PAREN IS AN INVALID OTHER CHARACTER.        *
*    /*                                                               *
*    /*****************************************************************
*
*
* GDNNBL:
*    IF COMBUF='('                   /* IF THE DELIMITER IS A LEFT    *
*      THEN                          /* GOTO THE ROUTINE TO CHECK     *
GDNNBL   CLI   0(@4),C'('                                         1295
*      GOTO SUBSCK;                  /* THE VALIDITY OF A SUB- SCRIPT
*                                       FOLLOWING THIS DATA NAME      *
         BC    08,SUBSCK                                          1296
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF NOT A LEFT PAREN, CHECK FOR A SEMICOLON. IF A SEMICOLON, A *
*    /* CHECK MUST BE MADE FOR SUBSCRIPT AND ERROR MOCE FOR SPECIAL   *
*    /* PROCESSING IN CASE OF A ; WHILE PROCESSING A SUBSCRIPT. THE   *
*    /* 'ENDING PAREN ASSUMED' MESSAGE MUST BE WRITTEN UNLESS IN      *
*    /* ERRORMODE                                                     *
*    /*                                                               *
*    /*****************************************************************
*
*    IF COMBUF=';'                   /* IF SEMICOLON IN BUFFER,       *
*      THEN                          /* MUST DO SPECIAL CHECKING      *
         CLI   0(@4),C';'                                         1297
         BC    07,@982                                            1297
*      DO;                           /* IF SUBSCRIPT MODE AND NOT     *
*        IF SUBSMODE^='1'B           /* ERROR MODE MUST PROCESS       *
*          THEN                      /* END, BUT FIRST MUST ISSUE     *
         TM    599(@B),B'00100000'                                1299
*          GOTO RANGESET;            /* GET RANGE WITCHES SET         *
         BC    12,RANGESET                                        1300
*        IF ERRORBIT='1'B            /* IF SUBSCRIPT MODE      A00996 *
*          THEN                      /* AND ERROR MODE, DO NOT A00996 *
         TM    599(@B),B'00001000'                                1301
*            GOTO VSBEND1;           /* GO TO ISSUE RIGHT      A00996
*                                       PAREN ASSUMED MESSAGE  A00996 *
         BC    01,VSBEND1                                         1302
*        GOTO ENDCMDCK;              /* IF SUBSMODE ON, EXIT TO
*                                       ENDCMDCK LABEL IN CONSTANT    *
         BC    15,ENDCMDCK                                        1303
*      END;                          /* END TH PROCESSING FOR ; FOUND
*                                       IN BUFFER IMMEDIATELY
*                                       FOLLOWING THE DATA NAME       *
*
*    /*****************************************************************
*    /*                                                               *
*    /* MUST CHECK FOR REMAINING VALID DELIMITERS IF NOT A LEFT PAREN *
*    /* OR SEMICOLON                                                  *
*    /*                                                               *
*    /*****************************************************************
*
*
* RHTPARCK:                          /* CHECK FOR A RIGHT PAREN       *
*    IF COMBUF=')'                   /* IF A RIGHT PAREN, SPECIAL     *
*      THEN                          /* IS REQUIRED TO MAKE SURE      *
@982     EQU   *                                                  1305
RHTPARCK CLI   0(@4),C')'                                         1305
         BC    07,@981                                            1305
*      DO;                           /* THE RIGHT PAREN IS VALID      *
*
*        /*************************************************************
*        /*                                                           *
*        /* IF IN SUBSCRIPT MODE, GO TO ROUTINE TO PROCESS THE END OF *
*        /* THE SUBSCRIPT.                                            *
*        /*                                                           *
*        /*************************************************************
*
*        IF SUBSMODE='1'B            /* IF SUBSCRIPT MODE             *
*          THEN                      /* PROCESS END OF SUBSCRIPT      *
         TM    599(@B),B'00100000'                                1307
*          GOTO VSUBENDK;            /* THRU SUBENDCK RTN             *
         BC    01,VSUBENDK                                        1308
*
*        /*************************************************************
*        /*                                                           *
*        /* IF EITHER THE OPERMODE OR THE PFLIST BITS ARE ON THE RIGHT*
*        /* PAREN SIGNIFIES THE END OF THE EXPRESSION OR THE END OF   *
*        /* THE LIST                                                  *
*        /*                                                           *
*        /*************************************************************
*
*        IF OPERMODE='1'B            /* IF OPERMODE ON                *
*          THEN                      /* GOTO PROCESS THE END OF       *
         TM    599(@B),B'01000000'                                1309
*          GOTO EXIT;                /* THE DATA NAME AND FILL IN THE
*                                       PDE                           *
         BC    01,EXIT                                            1310
*
*        /*************************************************************
*        /*                                                           *
*        /* IF PFLIST ON GO TO END OF DATA NAME PROCESSING            *
*        /*                                                           *
*        /*************************************************************
*
*        IF PFLIST='1'B              /* IF PROCESSING A LIST, THE     *
*          THEN                      /* RIGHT PAREN IS A VALID        *
         TM    176(@B),B'10000000'                                1311
*          GOTO VRNGCK1;             /* DELIMITER                     *
         BC    01,VRNGCK1                                         1312
*        GOTO VERRBIT;               /* IF A RIGHT PAREN WAS FOUND AND
*                                       NEITHER OPERMODE, SUBS- CRIPT
*                                       MODE OR LIST MODE, IT IS AN
*                                       INVALID DELIMITER             *
         BC    15,VERRBIT                                         1313
*      END;                          /* END PROCESSING OF A RIGHT
*                                       PAREN IMMEDIATELY FOLLOWING A
*                                       DATA NAME                     *
*
*    /*****************************************************************
*    /*                                                               *
*    /* CHECK TO SEE IF DELIMITER IS A COLON. THIS IS THE ONLY        *
*    /* REMAINING VALID DELIMITER IMMEDIATELY FOLLOWING A DATA NAME   *
*    /*                                                               *
*    /*****************************************************************
*
*    IF COMBUF=':'                   /* IF DELIMTER IS A COLON GO     *
*      THEN                          /* GO TO RANGE TO SET SWITCHES   *
@981     CLI   0(@4),C':'                                         1315
*      GOTO VRNGCK1;                 /* GET RNGEVAL1 TURNED ON        *
         BC    08,VRNGCK1                                         1316
*    ELSE                            /* IF NOT COLON, NO MORE VALID   *
*      GOTO VERRBIT;                 /* DELIMITERS, GOTO ERROR RTN    *
         BC    15,VERRBIT                                         1317
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF DELIMITER WAS A LEFT PAREN MUST CHECK TO SEE IF PCE IS     *
*    /* SUBSCRIPTABLE. IF NOT, THE LEFT PAREN IS AN INVALID CHARACTER.*
*    /*                                                               *
*    /*****************************************************************
*
*
* SUBSCK:
*    IF SUBSCRP^='1'B                /* IF PCE IS NOT SUBSCRIPTABLE   *
*      THEN                          /* THE RIGHT PAREN IS INVALID    *
SUBSCK   TM    1(@6),B'00010000'                                  1318
         BC    01,@980                                            1318
*      DO;                           /* THE ERROBIT MUST BE SET ON    *
*        ERRORBIT='1'B;              /* AND EXIT TO THE RTN TO SCAN   *
         OI    599(@B),B'00001000'                                1320
*        PFNOPOP='1'B;               /* PREVENT STACK POPPING         *
         OI    179(@B),B'00000010'                                1321
*        GOTO XINUP;                 /* THE REST OF THE DATA IN       *
         BC    15,XINUP                                           1322
*      END;                          /* ERROR                         *
*    ADDCDE=5;                       /* IF SUBSCRIPTABLE, SKIP        *
@980     LA    @F,5                                               1324
*    PFNOPOP='1'B;                   /* SUBSCRIPT MUST BE ON ONE
*                                       BUFFER                        *
         OI    179(@B),B'00000010'                                1325
*    CALL LINKRET;                   /* INTERVENING BLANKS BEFORE
*                                       SUBSCRIPT                     *
         BAL   @E,LINKRET                                         1326
*    GOTO SETERR;                    /* IF NO DATA AFTER RHT PAREN IS
*                                       AN ERROR                      *
         BC    15,SETERR                                          1327
*    R4=R4+1;                        /* IF DATA, INCREMENT XINPUT TO
*                                       POINT TO THE FIRS CHAR        *
         AH    @4,@D2                                             1328
*    PFNOPOP='0'B;                   /* RESET PFNOPOP IF DATA FOUND   *
         NI    179(@B),B'11111101'                                1329
*    IF CHAINTRM='1'B                /* IF THIS IS A CHAINED          *
*      THEN                          /* TERM OFF AN OPER, THIS        *
         TM    600(@B),B'00010000'                                1330
*      GOTO SUBSCRPT;                /* IS DEFINITELY A SUBSCPT       *
         BC    01,SUBSCRPT                                        1331
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF THE ERRORBIT IS ON , GO TO THE ROUTINE TO SCAN FOR THE END *
*    /* OF THE SUBSCRIPT                                              *
*    /*                                                               *
*    /*****************************************************************
*
*    IF ERRORBIT='1'B                /* IF ERROR BIT ON, SET          *
*      THEN                          /* INDICATORS                    *
         TM    599(@B),B'00001000'                                1332
         BC    12,@97F                                            1332
*      DO;                           /* PROPERLY                      *
*        SUBSMODE='1'B;              /* SET SUBSMODE BIT TO CONTROL   *
         OI    599(@B),B'00100000'                                1334
*        GOTO SUBERSCN;              /* ERROR SCAN ROUTINE            *
         BC    15,SUBERSCN                                        1335
*      END;                          /* END ERROR PROCESSING          *
*    NUMQUAL=QUALCT;                 /* IF ALL O.K. ADD THE QUAL-     *
@97F     L     @1,564(0,@B)        
         MVC   17(1,@1),598(@B)                                   1337
*    QUALCT=0;                       /* IFIER COUNT TO THE PDE FOR THE
*                                       DATA NAME BEFORE THE SUBSCRIPT*
         MVI   598(@B),0                                          1338
*    NAMEREQD='0'B;                  /* TURN THE NAMEREQUIRED BIT OFF
*                                       - END OF QUALIFIER            *
         NI    599(@B),B'11101111'                                1339
*    GOTO SUBSCRPT;                  /* GOTO ROUTINE FOR SUBSCRIPT
*                                       PROCESSING                    *
         BC    15,SUBSCRPT                                        1340
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF NO DATA FOUND AFTER THE LEFT PAREN, IT IS AN ERROR         *
*    /*                                                               *
*    /*****************************************************************
*
*
* SETERR:
*    ERRORBIT='1'B;                  /* SET THE ERROR BIT             *
SETERR   OI    599(@B),B'00001000'                                1341
*    R4=R4+1;                        /* RESET XINPUT SO WON'T MISS THE
*                                       PAREN IN ERROR MESAGE         *
         AH    @4,@D2                                             1342
*    GOTO VRNGCK1;                   /* GO TO END ROUTINE WHICH WILL
*                                       ENSURE PROPER SETTING OF THE
*                                       RANGE SWITCHES                *
         BC    15,VRNGCK1                                         1343
*    GEN (EJECT);
         EJECT
         DS    0H
*
*    /*****************************************************************
*    /*                                                               *
*    /* THIS ROUTINE IS ENTERED IF BLANKS FOLLOWED A GOOD DATA NAME   *
*    /* AND OF OR IN DID NOT FOLLOW THE BLANKS. AGAIN THE DELIMITER   *
*    /* FOLLOWING THE BLANKS MUST BE CHECKED TO SEE IF INDEED IT IS   *
*    /* PART OF THE DATA NAME OR BELONGS TO THE NEXT PCE. SPECIAL     *
*    /* PROCESSING IS REQUIRED IF WE ARE PROCESSING A TERM CHAINED OFF*
*    /* AN OPER.                                                      *
*    /*                                                               *
*    /*****************************************************************
*
*
* ASIS1:
*    NAMEREQD='0'B;                  /* TURN NAMEREQD BIT OFF SINCE
*                                       FINISHED PROCESSING ANY
*                                       QUALIFIERS                    *
ASIS1    NI    599(@B),B'11101111'                                1345
*
*    /*****************************************************************
*    /*                                                               *
*    /* CHECK TO SEE IF DELIMITER IS A LEFT PARENTHESIS               *
*    /*                                                               *
*    /*****************************************************************
*
*    IF COMBUF^='('                  /* IS THIS A LEFT PAREN? IF      *
*      THEN                          /* NOT, GO TO CHECK FOR A        *
         CLI   0(@4),C'('                                         1346
*      GOTO RHTPRCK;                 /* RIGHT PAREN                   *
         BC    07,RHTPRCK                                         1347
*    RSVWDSV1=R4;                    /* IF RIGHT PAREN, SAVE THE
*                                       POINTER IN CASE HAVE TO RETURN
*                                       TO IT WHEN PUSH- ING THE STACK*
         ST    @4,540(0,@B)                                       1348
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF THE DELIMITER AFTER BLANKS IS A LEFT PAREN, SPECIAL CHECKS *
*    /* MUST BE MADE TO DETERMINE IF THIS IS A SUBSCRIPT FOLLOWING THE*
*    /* DATA NAME. IF WE ARE PROCESSING A TERM PCE CHAINED OFF OF AN  *
*    /* OPER PCE (CHAINTRM BIT ON) A VALIDITY CHECK EXIT MUST BE TAKEN*
*    /* TO DETERMINE IF THE DATA FOLLOWING THE DATA NAME IS A         *
*    /* SUBSCRIPT.                                                    *
*    /*                                                               *
*    /*****************************************************************
*
*    IF SUBSMODE='1'B                /* IF THE SUBSCRIPT BIT IS       *
*      THEN                          /* ALREADY ON WE HAVE ENCOUNT-   *
         TM    599(@B),B'00100000'                                1349
         BC    12,@97E                                            1349
*      DO;                           /* ERED A LEFT PAREN WITHIN
*                                       A SUBSCRIPT WHICH IS AN
*                                       ERROR                         *
*        IF PFENDSET='1'B            /* IF STACK JUST POPPED          *
*          THEN                      /* MUST RESET PRMTPTR SO DON'T   *
         TM    179(@B),B'00000100'                                1351
         BC    12,@97D                                            1351
*          PRMTPTR=R4;               /* PROMPT OVER 2 BUFFERS         *
         ST    @4,584(0,@B)                                       1352
*        ERRORBIT='1'B;              /* SET THE ERROR BIT             *
@97D     OI    599(@B),B'00001000'                                1353
*        GOTO SUBERSCN;              /* SCAN TILL THE END OF THE      *
         BC    15,SUBERSCN                                        1354
*      END;                          /* SUBSCRIPT FOR THE PROMPT
*                                       MESSAGE                       *
*
* SKIPBL3:
*    ADDCDE=5;                       /* SKIP THE BLANKS BETWEEN THE   *
@97E     EQU   *                                                  1356
SKIPBL3  LA    @F,5                                               1356
*    PFNOPOP='1'B;                   /* PREVENT STACK POPPING         *
         OI    179(@B),B'00000010'                                1357
*    CALL LINKRET;                   /* LFT PAREN AND SUBSCRIPT       *
         BAL   @E,LINKRET                                         1358
*    GOTO SUBSCPCK;                  /* IF ENDINPUT AFTER THE ( MUST
*                                       MAKE CHECKS TO DETERM- INE
*                                       TYPE OF PROCESSING TO FOLLOW  *
         BC    15,SUBSCPCK                                        1359
*    PFNOPOP='0'B;                   /* TURN NO STACK POPPING OFF     *
         NI    179(@B),B'11111101'                                1360
*    R4=R4+1;                        /* IF DATA FOLLOWS POINT TO THE
*                                       FIRST CHAR OF THE DATA        *
         AH    @4,@D2                                             1361
*    NUMQUAL=QUALCT;                 /* ADD THE QUALIFIER COUNT FOR
*                                       THE PREVIOUS DATA NAME TO THE
*                                       PDE                           *
         L     @1,564(0,@B)        
         MVC   17(1,@1),598(@B)                                   1362
*    QUALCT=0;                       /* CLEAR THE QUALIFIER COUNT     *
         MVI   598(@B),0                                          1363
*
*    /*****************************************************************
*    /*                                                               *
*    /* CHECK TO MAKE USRE THE TERM PCE IS SUBSCRIPTABLE. IF IT ISN'T *
*    /* THE BUFFER POINTER MUST BE RESET TO THE END OF THE PREVIOUS   *
*    /* DATA NAME SCANNED. THE LEFT PAREN AND DATA ENCOUNTERED IS     *
*    /* ASSOCIATED WITH THE NEXT PCE                                  *
*    /*                                                               *
*    /*****************************************************************
*
*    IF SUBSCRP='1'B                 /* IF THE SUBSCRIPTABLE BIT IS   *
*      THEN                          /* ON THEN GO TO CHECK IF WE     *
         TM    1(@6),B'00010000'                                  1364
*      GOTO CHNCK1;                  /* ARE PROCESSING A CHAINED TERM
*                                       OFF AN OPER                   *
         BC    01,CHNCK1                                          1365
*
* RESTXIN1:
*    IF PFENDSET='1'B                /* IF A PROMPT BUFFER HAS        *
*      THEN                          /* BEEN POPPED OFF THE STACK     *
RESTXIN1 TM    179(@B),B'00000100'                                1366
         BC    12,@97C                                            1366
*      DO;                           /* MUST RESET BUFFER POINTERS    *
*        R4=R4-1;                    /* RESET XINPUT                  *
         BCTR  @4,0                                               1368
*        ADDCDE=17;                  /* PUSH BUFFER POPPED BACK ON    *
         LA    @F,17                                              1369
*        CALL LINKRET;               /* STACK                         *
         BAL   @E,LINKRET                                         1370
*        ENDINPUT=ENDBAKUP;          /* RESET END OF BUFFER POINTER   *
         MVC   144(4,@B),412(@B)                                  1371
*      END;                          /* TO THAT BUFFER POPPED OFF     *
*    R4=ENDNMPTR+1;                  /* RESET XINPUT INTO PREVIOUS
*                                       BUFFER                        *
@97C     LA    @4,1                                               1373
         A     @4,556(0,@B)                                       1373
*    GOTO RANGESET;                  /* GO TO PROCESS THE END OF A
*                                       DATA NAME AND FILL IS REST OF
*                                       PDE                           *
         BC    15,RANGESET                                        1374
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF THE CHAINED TERM BIT IS ON, MUST ASSUME END OF THE DATA    *
*    /* NAME AND GO TO A VALIDITY CHECK EXIT TO DETERMINE IF THIS IS A*
*    /* SUBSCRIPT.                                                    *
*    /*                                                               *
*    /*****************************************************************
*
*
* CHNCK1:
*    IF CHAINTRM^='1'B               /* IF NOT A CHAINED TERM, GO     *
*      THEN                          /* TO SUBSCRIPT PROCESSING       *
CHNCK1   TM    600(@B),B'00010000'                                1375
*      GOTO SUBSCRPT;                /* ROUTINE                       *
         BC    12,SUBSCRPT                                        1376
*    CTFOUND='1'B;                   /* INDICATE SUBSCRPT FOUND AFTER
*                                       VARIABLE SO CAN DETERMINE
*                                       VALIDITY OF +4 RETURN FROM
*                                       V.C. EXIT                     *
         OI    601(@B),B'01000000'                                1377
*
* RESTXIN:
*    R4=RSVWDSV1;                    /* RESET XINPUT SO ( GETS SAVED  *
RESTXIN  L     @4,540(0,@B)                                       1378
*    GOTO RESTXIN1;                  /* GO TO RESTORE XINPUT AND
*                                       COMPLETE PDE                  *
         BC    15,RESTXIN1                                        1379
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF NO DATA FOLLOWED THE LEFT PAREN, CHECK TO SEE IF THE LEFT  *
*    /* PAREN SHOULD BE INCLUDED UNDER THIS PCE                       *
*    /*                                                               *
*    /*****************************************************************
*
*
* SUBSCPCK:                          /* CHECK SUBSCRIPTABLE BIT       *
*    PFNOPOP='0'B;                   /* TURN NO STACK POPPING OFF     *
SUBSCPCK NI    179(@B),B'11111101'                                1380
*    IF SUBSCRP^='1'B                /* IF PCE IS NOT SUBSCRIPTABLE   *
*      THEN                          /* RESTORE XINPUT AND DISRE-     *
         TM    1(@6),B'00010000'                                  1381
*      GOTO RESTXIN;                 /* LEFT PAREN                    *
         BC    12,RESTXIN                                         1382
*    ERRORBIT='1'B;                  /* IF IS SUBSCRIPTABLE, THE      *
         OI    599(@B),B'00001000'                                1383
*    PFNOPOP='1'B;                   /* LEFT PAREN WITH NO DATA       *
         OI    179(@B),B'00000010'                                1384
*    R4=R4+1;                        /* DON'T MISS PAREN IN MSG       *
         AH    @4,@D2                                             1385
*    GOTO CODE4;                     /* FOLLOWING IS AN ERROR         *
         BC    15,CODE4                                           1386
*    GEN (EJECT);
         EJECT
         DS    0H
*
*    /*****************************************************************
*    /*                                                               *
*    /* THE FOLLOWING ROUTINE PREPARES FOR THE PROCESSING OF A        *
*    /* SUBSCRIPT. SEVERAL ERROR CHECKS ARE MADE TO AVOID UNNECESSARY *
*    /* PROCESSING                                                    *
*    /*                                                               *
*    /*****************************************************************
*
*
* SUBSCRPT:                          /* SUBSCRIPT PROCESSING          *
*    IF SUBSMODE='1'B                /* IF ALREADY PROCESSING A       *
*      THEN                          /* SUBSCRIPT, THE LEFT PAREN     *
SUBSCRPT TM    599(@B),B'00100000'                                1388
         BC    12,@97B                                            1388
*      DO;                           /* FOUND IS INVALID              *
*        ERRORBIT='1'B;              /* INDICATE ERROR DETECTED       *
         OI    599(@B),B'00001000'                                1390
*        GOTO SUBERSCN;              /* GOTO SCAN TO THE END OF       *
         BC    15,SUBERSCN                                        1391
*      END;                          /* THE SUBSCRIPT                 *
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF THE ERRORBIT IS ALREADY ON, IT IS POSSIBLE TO GO TO THE    *
*    /* ROUTINE TO SCAN TO THE END OF THE SUBSCRIPT WITHOUT GOING     *
*    /* THROUGH INTERVENING PROCESSING                                *
*    /*                                                               *
*    /*****************************************************************
*
*    IF ERRORBIT='1'B                /* IF ALREADY IN ERROR MODE      *
*      THEN                          /* GOTO SCAN TO THE END OF       *
@97B     TM    599(@B),B'00001000'                                1393
*        GOTO SUBERSCN;              /* THE SUBSCRIPT                 *
         BC    01,SUBERSCN                                        1394
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF NO ERROR, PREPARE TO PROCESS SUBSCRIPT                     *
*    /*                                                               *
*    /*****************************************************************
*
*    SUBSMODE='1'B;                  /* INDICATE PROCESSING A
*                                       SUBSCRIPT                     *
         OI    599(@B),B'00100000'                                1395
*    R6=R6+PCELNGTH;                 /* UPDATE PCE PTR TO THE NEXT PCE*
         MVC   @TEMP2+2(2),2(@6)                                  1396
         A     @6,@TEMP2                                          1396
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF THE FOLLOWING PCE IS NOT A TERM PCE, WE HAVE INVALID       *
*    /* PARAMETERS SINCE A TERM PCE IS REQUIRED TO PROCESS THE        *
*    /* SUBSCRIPT. WE ALSO HAVE AN UNRECOVERABLE ERROR IF THE         *
*    /* FOLLOWING PCE IS A TERM BUT IS EITHER NOT A SUBSCRIPT TERM OR *
*    /* IS A STATEMENT TERM. EXIT IS MADE TO THE RTNCLNUP IN THE OPER *
*    /* PROCESSOR IF THIS TYPE OF ERROR IS DETECTED. A RETURN CODE OF *
*    /* 24 IS RETURNED TO THE CP                                      *
*    /*                                                               *
*    /*****************************************************************
*
*    IF TERPCE^='110'B               /* IF THE PCE IS NOT A TERM      *
*      THEN                          /* PCE WE HAVE INVALID           *
         TM    0(@6),B'11000000'                                  1397
         BC    12,@97A                                            1396
         TM    0(@6),B'00100000'                                  1397
         BC    08,@979                                            1397
*      GOTO COD24;                   /* PARAMETERS                    *
         BC    15,COD24                                           1398
*
*    /*****************************************************************
*    /*                                                               *
*    /* IS THE FOLLOWING TERM A SUBSCRIPT TERM PCE?                   *
*    /*                                                               *
*    /*****************************************************************
*
*    IF SUBSCPPT^='1'B               /* IF THIS IS NOT A SUBSCRIPT    *
@979     TM    6(@6),B'00001000'                                  1399
*      GOTO COD24;                   /* INVALID PARAMETERS            *
         BC    12,COD24                                           1400
*
*    /*****************************************************************
*    /*                                                               *
*    /* IS THE FOLLOWING TERM PCE INDICATE STATEMENT?                 *
*    /*                                                               *
*    /*****************************************************************
*
*    IF STMT^='1'B                   /* IF THE IS NOT A STATEMENT     *
*      THEN                          /* GOTO PROCESS DATA AS A        *
         TM    6(@6),B'10000000'                                  1401
*      GOTO ELCHECK;                 /* SUBSCRIPT                     *
         BC    12,ELCHECK                                         1402
*
* COD24:
*    CALL RTNCLNUP;                  /* IF FALL THROUGH, WE HAVE
*                                       INVALID PARAMETERS. EXIT
*                                       THROUGH OPER ROUTINE          *
COD24    BAL   @E,RTNCLNUP                                        1403
*    GEN (EJECT);
         EJECT
         DS    0H
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF COME INTO THIS ROUTINE, THE DATA NAME WAS FOLLOWED BY      *
*    /* BLANKS. THE DELIMITER AFTER THE BLANKS WAS NOT IN OR OF OR A  *
*    /* LEFT PARENTHESIS. A CHECK IS MADE HERE FOR A RIGHT PAREN WITH *
*    /* APPROPRIATE PROCESSING IF THE RIGHT PAREN IS ENCOUNTERED AFTER*
*    /* THE DATA NAME                                                 *
*    /*                                                               *
*    /*****************************************************************
*
*
* RHTPRCK:                           /* RIGHT PAREN CHECK             *
*    IF COMBUF^=')'                  /* IF THIS IS NOT A RIGHT        *
*      THEN                          /* PAREN, CONTINUE THE CHECK     *
RHTPRCK  CLI   0(@4),C')'                                         1405
*      GOTO STQULCT;                 /* OF THE DELIMITER              *
         BC    07,STQULCT                                         1406
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF THE DELIMITER IS A RIGHT PAREN, CHECKS MUST BE MADE TO     *
*    /* DETERMINE IF THE RIGHT PAREN IS A VALID DELIMITER AND TO      *
*    /* DETERMINE THE PROPER PROCESSING DEPENDING ON THE ENVIRONMENT  *
*    /* OF THE SCAN                                                   *
*    /*                                                               *
*    /*****************************************************************
*
*    IF SUBSMODE='1'B                /* IF SUBSCRIPT MODE THE RIGHT   *
*      THEN                          /* INDICATES THE END OF THE      *
         TM    599(@B),B'00100000'                                1407
*      GOTO VSUBENDK;                /* END OF THE SUBSCRIPT          *
         BC    01,VSUBENDK                                        1408
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF NOT SUBSCRIPT MODE, MAKE OTHER CHECKS TO DETERMINE WHAT THE*
*    /* RIGHT PARENTHESIS MEANS.                                      *
*    /*                                                               *
*    /*****************************************************************
*
*    IF OPERMODE='1'B                /* IF IN OPERMODE, THE RIGHT     *
*      THEN                          /* PAREN INDICATES THE END       *
         TM    599(@B),B'01000000'                                1409
*      GOTO EXIT;                    /* OF THE EXPRESSION             *
         BC    01,EXIT                                            1410
*
*    /*****************************************************************
*    /*                                                               *
*    /* DOES THE RIGHT PAREN INDICATE THE END OF A LIST IF A RIGHT    *
*    /* PAREN IS ENCOUNTERED AND NEITHER THE SUBSCRIPT MODE, OPER     *
*    /* MODE, OR PFLIST BITS ARE ON, THE RIGHT PAREN IS INVALID.      *
*    /*                                                               *
*    /*****************************************************************
*
*    IF PFLIST='1'B                  /* IF PROCESSING A LIST, GO      *
*      THEN                          /* TO END OF DATA NAME PROCES-   *
         TM    176(@B),B'10000000'                                1411
*      GOTO VRNGCK1;                 /* SING AND FILL IN PDE          *
         BC    01,VRNGCK1                                         1412
*    GOTO RESETXIN;                  /* IF FALL THROUGH ALL CHECKS THE
*                                       RIGHT PAREN IS AN ERROR       *
         BC    15,RESETXIN                                        1413
*    GEN (EJECT);
         EJECT
         DS    0H
*
*    /*****************************************************************
*    /*                                                               *
*    /* A RIGHT PAREN WAS NOT ENCOUNTERED. THE DATA NAME WAS FOLLOWED *
*    /* BY BLANKS. THE DATA FOLLOWING THE BLANKS WAS NOT IN OR OF, A  *
*    /* LEFT PAREN OR A RIGHT PAREN. THIS IDICATES THAT WE HAVE       *
*    /* REACHED THE END OF A DATA NAME. IF IN SUBSCRIPT MODE, THE DATA*
*    /* FOLLOWING IS ASSUMED TO BE A SUBSCRIPT.                       *
*    /*                                                               *
*    /*****************************************************************
*
*
* STQULCT:
*    IF SUBSMODE='1'B                /* IF IN SUBSCRIPT MODE,         *
*      THEN                          /* SET UP TO PROCESS THE         *
STQULCT  TM    599(@B),B'00100000'                                1415
         BC    12,@978                                            1415
*      DO;                           /* FOLLOWING DATA AS A           *
*        NUMQUAL=QUALCT;             /* SUBSCRIPT. ADD THE            *
         L     @1,564(0,@B)        
         MVC   17(1,@1),598(@B)                                   1417
*        QUALCT=0;                   /* QUALIFIER COUNT FOR THE
*                                       PREVIOUS DATA NAME            *
         MVI   598(@B),0                                          1418
*        GOTO ELCHECK;               /* GO TO DETERMINE TYPE OF
*                                       SUBSCRIPT PROCESSING -        *
         BC    15,ELCHECK                                         1419
*      END;                          /* CONSTANT OR VARIABLE          *
*
* RESETXIN:                          /* END OF DATA NAME              *
*    IF PFENDSET='1'B                /* IF PROMPT BUFFER POPPED       *
*      THEN                          /* OFF MUST RESET BUFFER PNTRS   *
@978     EQU   *                                                  1421
RESETXIN TM    179(@B),B'00000100'                                1421
         BC    12,@977                                            1421
*      DO;                           /* TO THE PROMPT BUFFER          *
*        R4=R4-1;                    /* SET XINPUT TO PUSH THIS BUFFER
*                                       BACK ON STACK                 *
         BCTR  @4,0                                               1423
*        ADDCDE=17;                  /* PUSH POPPED BUFFER BACK       *
         LA    @F,17                                              1424
*        CALL LINKRET;               /* ON STACK                      *
         BAL   @E,LINKRET                                         1425
*        ENDINPUT=ENDBAKUP;          /* RESET END OF BUFFER PTR       *
         MVC   144(4,@B),412(@B)                                  1426
*      END;                          /* END BUFFER PUSH               *
*    R4=ENDNMPTR+1;                  /* RESET XINPUT INTO PREV IOUS
*                                       BUFFER                        *
@977     LA    @4,1                                               1428
         A     @4,556(0,@B)                                       1428
*    GOTO VRNGCK1;                   /* GO TO RANGE TO DETERMINE
*                                       WHETHER RANGE PROCESSING IS
*                                       REQUIRED                      *
         BC    15,VRNGCK1                                         1429
*
*    /*****************************************************************
*    /*                                                               *
*    /* IT HAS BEEN DETERMINED THAT WE ARE PROCESSING A SUBSCRIPT     *
*    /* CHECKS ARE MADE TO DETERMINE WHETHER THE SUBSCRIPT IS A       *
*    /* CONSTANT , VARIABLE, OR ANY IS SPECIFIED IN THE PCE IF IN     *
*    /* ERRORMODE, THE ERROR SCAN FOR SUBSCRIPTS IS ENTERED. THIS     *
*    /* ROUTINE SCANS TO FIND THE CLOSING RIGHT PAREN OR THE END OF   *
*    /* THE BUFFER FOR THE ERROR MESSAGE                              *
*    /*                                                               *
*    /*****************************************************************
*
*
* ELCHECK:
*    IF ELEMNCT=3                    /* IF THE ELEMENT COUNT IS       *
*      THEN                          /* ALREADY THREE, THE NEXT       *
ELCHECK  CLI   597(@B),3                                          1430
         BC    07,@976                                            1430
*      DO;                           /* SUBSCRIPT IS IN ERROR ONLY 3
*                                       SUBSCRIPTS ALLOWED            *
*        PRMTPTR=R4;                 /* RESET PRMTPTR SO RIGHT
*                                       SUBSCRIPT ELEMENT IS IN ERROR
*                                       MESSAGE                       *
         ST    @4,584(0,@B)                                       1432
*        ERRORBIT='1'B;              /* INDICATE ERROR ENCOUNTERED    *
         OI    599(@B),B'00001000'                                1433
*        GOTO SUBERSCN;              /* SCAN TO THE END OF THE        *
         BC    15,SUBERSCN                                        1434
*      END;                          /* SUBSCRIPT                     *
*
*    /*****************************************************************
*    /*                                                               *
*    /* CHECK TO DETERMINE TYPE OF SUBSCRIPT                          *
*    /*                                                               *
*    /*****************************************************************
*
*    IF VAR='1'B                     /* DOES SUBSCRIPT PCE SPECIFY    *
*      THEN                          /* VARIABLE, IF SO               *
@976     TM    6(@6),B'01000000'                                  1436
         BC    12,@975                                            1436
*      DO;                           /* INCREMENT THE ELEMENT         *
*        ELEMNCT=ELEMNCT+1;          /* COUNT (SUBSCRIPT COUNT)       *
         LA    @F,1                                               1438
         SR    @0,@0                                              1438
         IC    @0,597(0,@B)                                       1438
         AR    @F,@0                                              1438
         STC   @F,597(0,@B)                                       1438
*        PDEPTR=PDEPTR+20;           /* POINT TO THE NEXT PDE
*                                       CORRESPONDING TO THIS
*                                       SUBSCRIPT PCE                 *
         LA    @F,20                                              1439
         A     @F,564(0,@B)                                       1439
         ST    @F,564(0,@B)                                       1439
*        GOTO IKJEFP6V;              /* SCAN THE SUBSCRIPT AS A       *
         BC    15,IKJEFP6V                                        1440
*      END;                          /* VARIABLE                      *
*    GOTO IKJEFP6C;                  /* OTHERWISE GO TO THE CONSTANT
*                                       ROUTINE TO CHECK TO SEE IF
*                                       SUBSCRIPT IS A CONSTANT       *
*
*    /*****************************************************************
*    /*                                                               *
*    /* THE FOLLOWING ROUTINE IS ENTERED IF AN ERROR HAS BEEN DETECTED*
*    /* WHILE IN SUBSCRIPT MODE. A SCAN IS DONE TO FIND THE ENDING    *
*    /* PAREN OR EOB                                                  *
*    /*                                                               *
*    /*****************************************************************
*
*
* SUBERSCN:
*    IF COMBUF=')'                   /* SCAN THE INPUT LINE           *
*      THEN                          /* UNTIL FIND THE ENDING RGHT    *
SUBERSCN CLI   0(@4),C')'                                         1443
*      GOTO VSUBENDK;                /* PAREN OR EOB                  *
         BC    08,VSUBENDK                                        1444
*    PFNOPOP='1'B;                   /* PREVENT STACK POPPING  A00996 *
         OI    179(@B),B'00000010'                                1445
*    CALL BUMP;                      /* IF NOT RIGHT PAREN CALL
*                                       ROUTINE TO UP XINPUT          *
         BAL   @E,BUMP                                            1446
*    GEN;                            /* GENERATE PROPER BRANCHES      *
         BC   15,VRNGCK1               EOB DETECTED
         BC   15,SUBERSCN              MORE DATA - CHECK FOR RT PAREN
         BC   15,VRNGCK1               STACK SHOULD NEVER BE POPPED
*        SINCE IN ERROR MODE AND PFNOPOP IS ON
         DS    0H
*
*    /*****************************************************************
*    /*                                                               *
*    /* THIS ROUTINE IS ENTERED WHEN THE ENDING PAREN FOR SUBSCRIPTS  *
*    /* IS ENCOUNTERED. THIS ROUTINE CAN BE ENTERED FROM THE CONSTANT *
*    /* PROCESSOR IF PROCESSING CONSTANT SUBSCRIPTS. THIS ROUTINE IS  *
*    /* ALSO ENTERED EVEN IF IN ERRORMODE WHEN THE END OF THE         *
*    /* SUBSCRIPT IS DETECTED.                                        *
*    /*                                                               *
*    /*****************************************************************
*
*
* VSUBENDK:                          /* END OF SUBSCRIPT ROUTINE      *
*    R4=R4+1;                        /* BUMP XINPUT PASSED THE ENDING
*                                       RIGHT PAREN                   *
VSUBENDK AH    @4,@D2                                             1448
* VSBEND1:                           /* NEW ENTRY LABEL        A00996 *
*    NUMSUB1=ELEMNCT;                /* SET THE SUBSCRIPT COUNT INTO
*                                       THE PDE BASED ON TEMPPDE      *
VSBEND1  MVC   350(1,@B),597(@B)                                  1449
*    ELEMNCT=0;                      /* CLEAR THE ELEMENT COUNT       *
         MVI   597(@B),0                                          1450
*    TEMPSAVE=R6;                    /* SAVE POINTER TO         M4161
*                                       SUBSCRIPT PCE           M4161 *
         ST    @6,172(0,@B)                                       1451
*    R6=TERMXPCE;                    /* RESET XPCE TO MAJOR     M4161
*                                       PCE FOR RANGE PROCESS   M4161 *
         L     @6,528(0,@B)                                       1452
*    CALL TSTRNGE;                   /* RANGE PROCESSING       A00996 *
         L     @F,@V5              ADDRESS OF TSTRNGE             1453
         BALR  @E,@F                                              1453
*    GOTO ZERORET;                   /* ON PLUS ZERO RETURN     M4161
*                                       CHECK ERROR CONDITIONS  M4161 *
         BC    15,ZERORET                                         1454
*    R6=TEMPSAVE;                    /* +4 - RESET PCE POINTER  M4161
*                                       TO SUBSCRIPT PCE FOR    M4161
*                                       FURTHER PROCESSING.     M4161 *
         L     @6,172(0,@B)                                       1455
*    GOTO VALRANGE;                  /* GOTO PROCESS VALID FIRSTM4161
*                                       VALUE OF A RANGE        M4161 *
         BC    15,VALRANGE                                        1456
* ZERORET:                           /* +0 RETURN FROM RANGE    M4161 *
*    R6=TEMPSAVE;                    /* RESET PCE POINTER TO    M4161
*                                       SUBSCRIPT PCE FOR       M4161
*                                       FURTHER PROCESSING      M4161 *
ZERORET  L     @6,172(0,@B)                                       1457
*    GOTO CKRNG;                     /* GOTO NO RANGE PROCESS   M4161 *
         BC    15,CKRNG                                           1458
*
*    /*****************************************************************
*    /*                                                               *
*    /* THE LOGICAL END OF A VARIABLE SCAN HAS BEEN REACHED THE RANGE *
*    /* ROUTINE IN PARSE IS ENTERED TO GET THE RANGE SWITCHES SET     *
*    /* PROPERLY FOR FURTHER PROCESSING                               *
*    /*                                                               *
*    /*****************************************************************
*
*
* VRNGCK1:
*    CALL TSTRNGE;                   /* RANGE PROCESSING       A00996 *
VRNGCK1  L     @F,@V5              ADDRESS OF TSTRNGE             1459
         BALR  @E,@F                                              1459
*    GOTO CKRNG;                     /* IF PLUS 0 RETURN BRANCH TO
*                                       VALID RETURN                  *
         BC    15,CKRNG                                           1460
*
* VALRANGE:                          /* VALID FIRST VALUE OF RANGE
*                                       ENCOUNTERED                   *
*
*    /*****************************************************************
*    /*                                                               *
*    /* TEST TO SEE IF PROCESSING IN ERRORMODE. IF IN ERROR MODE      *
*    /* BRANCH SO DON'T COMPLETE THE PDE                              *
*    /*                                                               *
*    /*****************************************************************
*
*    IF ERRORBIT='1'B                /* IF IN ERROR MODE              *
*      THEN                          /* BRANCH SO DON'T FILL IN       *
VALRANGE TM    599(@B),B'00001000'                                1461
*      GOTO INVPSAV;                 /* PDE BUT SCAN SECOND RANGE
*                                       VALUE                         *
         BC    01,INVPSAV                                         1462
*    ELSE                            /* IF GOOD TO THIS POINT, GO     *
*      GOTO EXITA;                   /* FILL IN PDE AND COMPLETE END
*                                       OF DATA NAME PROCESSING       *
         BC    15,EXITA                                           1463
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF RANGEVAL1 IS ON WITH A +0 RETURN THERE IS A RANGE ERROR    *
*    /*                                                               *
*    /*****************************************************************
*
*
* CKRNG:
*    IF RNGEVAL1^='1'B               /* IF RNGEVAL1 IS NOT ON         *
*      THEN                          /* THEN CONTINUE WITH NORMAL     *
CKRNG    TM    177(@B),B'01000000'                                1464
*      GOTO EXIT;                    /* END OF DATA NAME PROCESS      *
         BC    12,EXIT                                            1465
*
* RANGERR:
*    R4=R4+1;                        /* IF RNGEVAL1 ON ERROR          *
RANGERR  AH    @4,@D2                                             1466
*    GEN (EJECT);
         EJECT
         DS    0H
*
*    /*****************************************************************
*    /*                                                               *
*    /* THE VERRBIT ROUTINE IS ENTERED WHEN AN ERROR HAS BEEN DETECTED*
*    /* IN THE SCAN OF A DATA NAME. EACH SUCCEEDING CHARACTER MUST BE *
*    /* SCANNED TO DETERMINE THE END OF THE DATA NAME FOR THE ERROR   *
*    /* PROMPT MESSAGE. IF NO VALID DELIMITER IS DISCOVERED THE SCAN  *
*    /* CONTINUES UNTIL THE END OF THE BUFFER IS DETECTED.            *
*    /*                                                               *
*    /*****************************************************************
*
*
* VERRBIT:
*    ERRORBIT='1'B;                  /* INDICATE AN ERROR HAS BEEN
*                                       DETECTED                      *
VERRBIT  OI    599(@B),B'00001000'                                1468
*    PFNOPOP='1'B;                   /* PREVENT STACK POPPING         *
         OI    179(@B),B'00000010'                                1469
*    PFENDSET='0'B;                  /* INDICATE DN AFTER STACK POPPED*
         NI    179(@B),B'11111011'                                1470
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF PROCESSING A SUBSCRIPT, GO IMMEDIATELY TO SCAN ROUTINE TO  *
*    /* FIND THE END OF THE SUBSCRIPT.                                *
*    /*                                                               *
*    /*****************************************************************
*
*    IF SUBSMODE='1'B                /* IF IN SUBSCRIPT MODE,         *
*      THEN                          /* GO TO SCNA FOR ENDING         *
         TM    599(@B),B'00100000'                                1471
*      GOTO SUBERSCN;                /* GOTO SUBSCRPT ERROR           *
         BC    01,SUBERSCN                                        1472
*
* SPTST:
*    /*****************************************************************
*    /* SEE IF AT END OF BUFFER  - IF SO, IS THE END OF THE           *
*    /* ERROR DATA NAME                                               *
*    /*****************************************************************
*
*    IF R4=>ENDINPUT                 /* ERROR DATA FOLLOWED           *
*      THEN                          /* BY EOB, IF SO GO TO ERROR     *
SPTST    C     @4,144(0,@B)                                       1473
*        GOTO CODE4;                 /* ESIT TO PROMPT                *
         BC    10,CODE4                                           1474
*    ADDCDE=8;                       /* DETERMINE IF SEPARATOR        *
         LA    @F,8                                               1475
*    R1='08'X;                       /* FOLLOWS BAD DATA NAME         *
         LA    @1,X'08'                                           1476
*    CALL LINKRET;                   /* GO TO PARSE                   *
         BAL   @E,LINKRET                                         1477
*    GOTO TEND;                      /* IF NOT, CHECK FOR OTHER VALID
*                                       DELIMITERS                    *
         BC    15,TEND                                            1478
*    R4=R4-1;                        /* IF IS, SET XINPUT BACK TO     *
         BCTR  @4,0                                               1479
*    GOTO ENDSCAN;                   /* THE END OF THE PREVIOUS DATA
*                                       NAME AND CONTINUE SCAN TO
*                                       DETERMINE LOGICAL END OF THE
*                                       ERROR DATA                    *
         BC    15,ENDSCAN                                         1480
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF NOT A SEPARATOR, MAKE CHECKS FOR THE OTHER VALID DATA NAME *
*    /* DELIMITERS: ) EOB ; ( : THE ERROR PROCESSING WILL DEPEND ON   *
*    /* THE TYPE OF DELIMITER WHICH FOLLOWS THE DATA NAME IN ERROR. IF*
*    /* NO VALID DELIMITER IS FOUND, ASSUME THE CHARACTER IS INVALID  *
*    /* AND CONTINUE SCAN WITH NEXT CHAR IN THE BUFFER.               *
*    /*                                                               *
*    /*****************************************************************
*
*
* TEND:
*    IF COMBUF^=')'                  /* IF CHAR NOT A RIGHT           *
*      THEN                          /* CONTINUE SCAN FOR             *
TEND     CLI   0(@4),C')'                                         1481
*      GOTO EOBCK;                   /* VALID DELIMITER               *
         BC    07,EOBCK                                           1482
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF IS A RIGHT PAREN DETERMINE WHAT THIS RIGHT PAREN MEANS IN  *
*    /* TERMS OF THE ERROR SCAN                                       *
*    /*                                                               *
*    /*****************************************************************
*
*    IF PFLIST='1'B                  /* IF LIST PROCESSING, HAVE      *
*      THEN                          /* REACHED A LOGICAL END OF      *
         TM    176(@B),B'10000000'                                1483
*      GOTO XINUP6;                  /* ERROR SCAN                    *
         BC    01,XINUP6                                          1484
*
*    /*****************************************************************
*    /*                                                               *
*    /* DOES RIGHT PAREN SIGNIFY END OF AN EXPRESSION                 *
*    /*                                                               *
*    /*****************************************************************
*
*    IF OPERMODE='1'B                /* IF IN OPERMODE, HAVE          *
*      THEN                          /* REACHED A LOGICAL END OF      *
         TM    599(@B),B'01000000'                                1485
*      GOTO XINUP6;                  /* ERROR DATA                    *
*    GOTO XINUP;                     /* IF NEITHER OF ABOVE ENVIR-
*                                       ONMENTS (SUBSMODE CHECK MADE
*                                       EARLIER) THE RIGHT PAREN IS
*                                       JUST ANOTHER INVALID CHAR     *
         BC    14,XINUP                                           1487
*
* XINUP6:
*    R4=R4+1;                        /* BUMP PASSED THE RIGHT PAREN   *
XINUP6   AH    @4,@D2                                             1488
*    ADDCDE=8;                       /* CHECK TO SEE IF SEPARATOR
*                                       FOLLOWS RIGHT PAREN           *
         LA    @F,8                                               1489
*    R1='08'X;                       /* SET UP SEP MASK               *
         LA    @1,X'08'                                           1490
*    CALL LINKRET;                   /* GO TO TYPETEST IN PARSE       *
         BAL   @E,LINKRET                                         1491
*    GOTO EOBCK1;                    /* IF NOT SEPAR, CHECK TO SEE IF
*                                       VALID DELIMITER AFTER THE
*                                       RIGHT PAREN                   *
         BC    15,EOBCK1                                          1492
*
* BACKIN:
*    CALL TSTRNGE;                   /* GOTO RANGE PROCESSING  A00996
*                                       ONLY POSSIBLE RETURN   A00996
*                                       IS +0                  A00996 *
BACKIN   L     @F,@V5              ADDRESS OF TSTRNGE             1493
         BALR  @E,@F                                              1493
*    R4=R4-1;                        /* IF VALID DELIMITER AFTER THE
*                                       RIGHT PAREN, POINT XINPUT AT
*                                       IT AND GO TO THE EXIT ROUTINE
*                                       TO PROMPT                     *
         BCTR  @4,0                                               1494
*    GOTO CODE4;                     /* EXIT AND PROMPT               *
         BC    15,CODE4                                           1495
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF CHARACTER AFTER THE RIGHT PAREN IS EOB OR ; THIS IS ALSO   *
*    /* VALID. OTHERWISE THE RIGHT PAREN MUST BE CONSIDERED ANOTHER   *
*    /* INVALID CHARACTER.                                            *
*    /*                                                               *
*    /*****************************************************************
*
*
* EOBCK1:
*    IF R4=>ENDINPUT                 /* IS IT EOB?             A00996 *
*      THEN                          /* IF SO, VALID GO TO EXIT       *
EOBCK1   C     @4,144(0,@B)                                       1496
*      GOTO BACKIN;                  /* ERROR PROCESSING              *
         BC    10,BACKIN                                          1497
*
*    /*****************************************************************
*    /*                                                               *
*    /* IS IN A SEMICOLON                                             *
*    /*                                                               *
*    /*****************************************************************
*
*    IF COMBUF=';'                   /* SEMICOLON?                    *
*      THEN                          /* IF SO, VALID AND GOT TO       *
         CLI   0(@4),C';'                                         1498
*      GOTO BACKIN;                  /* ERROR EXIT PROCESSING         *
         BC    08,BACKIN                                          1499
*    GOTO XINUP;                     /* IF NOT A VALID DELIMITER AFTER
*                                       THE ), CONTINUE SCAN FOR END
*                                       OF ERROR DATA                 *
         BC    15,XINUP                                           1500
*
*    /*****************************************************************
*    /*                                                               *
*    /* IS ERROR DATA DELIMITED BY A ;                                *
*    /*                                                               *
*    /*****************************************************************
*
* EOBCK:                             /* CHECK FOR SEMI COLON   A00996 *
*    IF COMBUF=';'                   /* IF SEMICOLON, SCAN OF ERROR   *
*      THEN                          /* DATA COMPLETE. GO TO ERROR    *
EOBCK    CLI   0(@4),C';'                                         1501
*      GOTO CODE4;                   /* EXIT TO PROMPT                *
         BC    08,CODE4                                           1502
*
*    /*****************************************************************
*    /*                                                               *
*    /* DOES A LEFT PAREN FOLLOW DATA                                 *
*    /*                                                               *
*    /*****************************************************************
*
*    IF COMBUF='('                   /* IF IS LEFT PAREN, CHECK       *
*      THEN                          /* TO SEE IF PCE IS              *
         CLI   0(@4),C'('                                         1503
         BC    07,@974                                            1503
*      DO;                           /* SUBSCRIPTABLE                 *
*
*        /*************************************************************
*        /*                                                           *
*        /* IF PCE SUBSCRIPTABLE, GO TO THE SCAN ROUTINE TO FIND THE  *
*        /* END OF THE SUBSCRIPT. IF NOT SUBSCRIPTABLE, THE LEFT PAREN*
*        /* IS AN INVALID CHARACTER.                                  *
*        /*                                                           *
*        /*************************************************************
*
*        IF SUBSCRP='1'B             /* IF PCE SUBSCRIPTABLE          *
*          THEN                      /* GO TO THE SUBSCRIPT ERROR     *
         TM    1(@6),B'00010000'                                  1505
         BC    12,@973                                            1505
*          DO;                       /* SCAN ROUTINE                  *
*            SUBSMODE='1'B;          /* INDICATE PROCESSING A         *
         OI    599(@B),B'00100000'                                1507
*            GOTO SUBERSCN;          /* SUBSCRIPT AND GO TO ERROR     *
         BC    15,SUBERSCN                                        1508
*          END;                      /* SCAN ROUTINE                  *
*        ELSE                        /* IF PCE NOT SUBSCRIPTABLE      *
*          GOTO XINUP;               /* CONSIDER LEFT PAREN INVALID   *
*      END;                          /* END LEFT PAREN PROCESSING     *
@972     EQU   *                                                  1511
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF NOT SEPARATOR,RIGHT PAREN, ENDINPUT, ; , OR LEFT PAREN ONLY*
*    /* VALID DELIMITER LEFT IS A COLON. IF NOT COLON, IS JUST ANOTHER*
*    /* CHARACTER OF THE INVALID DATA NAME.                           *
*    /*                                                               *
*    /*****************************************************************
*
*    IF COMBUF^=':'                  /* IF NOT A COLON, CONTINUE      *
*      THEN                          /* SCAN OF ERROR DATA UNTIL      *
@974     CLI   0(@4),C':'                                         1512
*      GOTO XINUP;                   /* FIND VALID DELIMITER.         *
         BC    07,XINUP                                           1513
*
* RANGE1:
*    CALL TSTRNGE;                   /* GO PROCESS RANGE       A00996
*                                       IF REQUIRED            A00996 *
RANGE1   L     @F,@V5              ADDRESS OF TSTRNGE             1514
         BALR  @E,@F                                              1514
*    GEN;                            /* GENERATE PROPER BRANCHES      *
         BC   15,XINUP                 IF +0 RETURN AND ':'
*                                      IT IS AN ERROR
         BC   15,INVPSAV               IF +4, GO PROCESS 2ND
*                                      VALUE OF THE 6
         DS    0H
*
*
* XINUP:
*    R4=R4+1;                        /* INCREMENT TO NEXT CHAR CHAR IN
*                                       ERROR SCAN FOR VALID DELIMITER*
XINUP    AH    @4,@D2                                             1516
*    GOTO SPTST;                     /* CONTINUE SCAN                 *
         BC    15,SPTST                                           1517
*    GEN (EJECT);
         EJECT
         DS    0H
*
*    /*****************************************************************
*    /*                                                               *
*    /* THE CODE4 ROUTINE IS ENTERED WHEN THE SCAN OF THE VARIABLE IS *
*    /* COMPLETE EITHER FOR A GOOD DATA NAME OR FOR ONE IN WHICH AN   *
*    /* ERROR WAS DETECTED. ON ENTRY, XINPUTB POINTS TO THE CHARACTER *
*    /* AFTER THE END OF THE VARIABLE. PROCESSING IS DONE TO SET UP   *
*    /* THE MESSAGE FOR PROMPTING IF IN ERRORMODE OR TO PREPARE TO    *
*    /* ISSUE THE PROMPT IF THE VALIDITY CHECK EXIT RETURNS AN ERROR  *
*    /* INDICATOR. IF NOT IN ERRORMODE (AN ERROR WAS NOT DETECTED IN  *
*    /* THE VARIABLE SCAN), THE PDE IS COMPLETED FOR THE TERM AND AN  *
*    /* EXIT IS MADE TO THE POSITXCB ROUTINE IN PARSE TO ADD THE PDE  *
*    /* AND GO TO THE VALIDITY CHECK EXIT IF SPECIFIED.               *
*    /*                                                               *
*    /*****************************************************************
*
*
* CODE4:
*    IF SUBSMODE='1'B                /* IF FINISHED PROCESSING A      *
*      THEN                          /* SUBSCRIPT, RESET THE PDE      *
CODE4    TM    599(@B),B'00100000'                                1519
         BC    12,@971                                            1519
*      PDEPTR=ADDR (TEMPPDE);        /* PTR TO THE MAJOR TERM PDE     *
         LA    @F,332(0,@B)                                       1520
         ST    @F,564(0,@B)                                       1520
         BC    15,@970                                            1521
*    ELSE                            /* IF NOT SUBSMODE, SET THE      *
*      R6=TERMXPCE;                  /* THE PCE PTR TO THE MAJOR TERM
*                                       PCE. THIS CANNOT BE DONE IN
*                                       SUBSCRIPT MODE SINCE IF AN
*                                       ERROR HAS OCCURRED PROMPTING
*                                       MUST BE DONE FROM THE
*                                       SUBSCRIPT TERM PCE            *
@971     L     @6,528(0,@B)                                       1521
*
* PRMTEXT:
*    DIGITCT=0;                      /* RESET DIGIT COUNT IN CASE
*                                       CODE4 ENTERED FROM CONSTANT   *
@970     EQU   *                                                  1522
PRMTEXT  MVI   596(@B),0                                          1522
*
*    /*****************************************************************
*    /*                                                               *
*    /* THE FOLLOWING ROUTINE ESTABLISHES THE NEED TO SET UP A SPECIAL*
*    /* MESSAGE. IF THE PARM TYPE IS STATEMENT, A SPECIAL MESSAGE IS  *
*    /* NOT REQUIRED.                                                 *
*    /*                                                               *
*    /*****************************************************************
*
*    IF STMT='1'B                    /* IF PCE TYPE STATEMENT         *
*      THEN                          /* DO NOT PROCESSING TO SET      *
         TM    6(@6),B'10000000'                                  1523
*      GOTO RTNTEST;                 /* UP FOR SPECIAL MESSAGE        *
         BC    01,RTNTEST                                         1524
*
*    /*****************************************************************
*    /*                                                               *
*    /* THIS ROUTINE DETERMINES IF A SPECIAL MESSAGE IS REQUIRED. THE *
*    /* SPECIAL MESSAGE MUST BE SET UP SO AS NOT TO LOSE ANY DATA     *
*    /* WHICH HAS BEEN DETERMINED AS BEING INVALID. BECAUSE VARIABLES *
*    /* MAY HAVE IMBEDDED BLANKS WITHIN AN ENTIRE DATA NAME, IT IS    *
*    /* POSSIBLE FOR THE BUFFER TO BE POPPED DURING THE SCAN.         *
*    /* THEREFORE, IT IS NOT POSSIBLE TO PRINT OUT THE DATA NAME IN A *
*    /* CONTIGUOUS FORMAT. THUS A POINTER IS OBTAINED TO THE FIRST    *
*    /* PART OF THE DATA NAME AND TO THE PART WHICH IS IN ERROR. THE  *
*    /* POINTERS TO THE FIRST DATA NAME ARE OBTAINED FROM THE PDE; THE*
*    /* POINTER TO THE INVALID DATA IS OBTAINED FROM PRMTPTR WHICH HAS*
*    /* BEEN LEFT AT THE INVALID DATA FOUND IN THE BUFFER. THE SPECIAL*
*    /* MESSAGE IS FORMATTED BY THE MSGSETUP ROUTINE AND INCLUDES     *
*    /* ELLIPSES FOLLOWING THE THE FIRST DATA NAME, UP TO THE PART OF *
*    /* THE VARIABLE IN ERROR. EXAMPLE: A OF B IN * (1 2 3) PROMPT:   *
*    /* INVALID DATA NAME - A...* (1 2 3)                             *
*    /*                                                               *
*    /*****************************************************************
*
*    IF OPERMODE='1'B                /* IF PROCESSING AN EXPRESSION   *
*      THEN                          /* GO TO SET UP THE SPECIAL      *
         TM    599(@B),B'01000000'                                1525
         BC    12,@96F                                            1525
*      IF CONST='1'B                 /* IF IS A CONSTANT, JUST        *
*        THEN                        /* SET UP SPECIAL MESSAGE        *
         L     @1,564(0,@B)        
         TM    6(@1),B'01000000'                                  1526
*        GOTO SPECMSG2;              /* FIELDS FOR OPER               *
         BC    01,SPECMSG2                                        1527
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF THE TWO POINTERS - INVPSAVE AND PRMTPTR - ARE POINT- ING TO*
*    /* THE SAME CHARACTER IN THE BUFFER, THE DATA IN WAS DETECTED IN *
*    /* THE FIRST PART OF THE DATA NAME. A SPECIAL MESSAGE IS NOT     *
*    /* REQUIRED, BECAUSE THE BUFFER IS NOT POPPED IN WHILE PROCESSING*
*    /* IN ERROR MODE. ALTHOUGH THE SPECIAL MESSAGE AREAS ARE         *
*    /* INITIALIZED, THE SPECIAL MESSAGE BIT IS NOT TURNED ON.        *
*    /*                                                               *
*    /*****************************************************************
*
*
* SPECMG:
*    IF INVPSAVE^=PRMTPTR            /* IF SPECIAL MESSAGE REQUIRED   *
*      THEN                          /* THEN GO TO ROUTINE TO         *
@96F     EQU   *                                                  1528
SPECMG   L     @F,584(0,@B)                                       1528
         C     @F,300(0,@B)                                       1528
*      GOTO SPECMSG3;                /* OBTAIN POINTERS TO THE ERROR
*                                       DATA FROM THE PDE             *
         BC    07,SPECMSG3                                        1529
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF NO SPECIAL MESSAGE, SET UP MESSAGE AREAS FROM THE BUFFER   *
*    /* POINTERS - INVPSAVE AND XINPUT. INVPSAVE POINTS TO THE        *
*    /* BEGINNING OF THE DATA NAME. XINPUT POINTS TO THE CHARACTER    *
*    /* FOLLOWING THE VARIABLE.                                       *
*    /*                                                               *
*    /*****************************************************************
*
*
* SPECMSG2:
*    IF R4 = INVPSAVE                /* IF XINPUT POINTS TO THE       *
*      THEN                          /* FIRST CHAR OF THE DATA NAME,  *
SPECMSG2 C     @4,300(0,@B)                                       1530
         BC    07,@96E                                            1530
*      R4 = R4 +1;                   /* INCREMENT BY ONE              *
         AH    @4,@D2                                             1531
*                                    /* SET UP SPECIAL MESSAGE        *
*    IF PFENDSET='1'B                /* IF BUFFER POPPED              *
*      THEN MSGLEN=ENDBAKUP-INVPSAVE; /* USE ENDBAKUP FOR LENGTH      *
@96E     TM    179(@B),B'00000100'                                1532
         BC    12,@96D                                            1532
         L     @F,300(0,@B)                                       1533
         LCR   @F,@F                                              1533
         A     @F,412(0,@B)                                       1533
         STH   @F,590(0,@B)                                       1533
         BC    15,@96C                                            1534
*      ELSE MSGLEN=R4-INVPSAVE;      /* OTHERWISE USE XINPUT          *
@96D     L     @F,300(0,@B)                                       1534
         LCR   @F,@F                                              1534
         AR    @F,@4                                              1534
         STH   @F,590(0,@B)                                       1534
*    MSGADDR=INVPSAVE;               /* MSGADDR CONTAINS A POINTER TO
*                                       THE BEGINNING OF THE INVALID
*                                       DATA                          *
@96C     MVC   592(4,@B),300(@B)                                  1535
*    GOTO RTNTEST;                   /* BYPASS SETTING SPECIAL MSG BIT*
         BC    15,RTNTEST                                         1536
*
*    /*****************************************************************
*    /*                                                               *
*    /* SPECMSG3 ROUTINE SETS THE SPECIAL MESSAGE BIT ON. INVPSAVE IS *
*    /* INITIALIZED TO POINT TO THE BEGINNING OF THAT PART OF THE     *
*    /* VARIABLE WHICH WAS FIRST DETECTED AS BEING IN ERROR. THE      *
*    /* POINTER TO THE BEGINNING OF THE VARIABLE ENTERED IS OBTAINED  *
*    /* FROM THE PDE. THE POINTER TO THE CORRECT PDE, EITHER THE      *
*    /* TEMPORARY OR THE PERM- ANENT IS IN PDEPTR.                    *
*    /*                                                               *
*    /*****************************************************************
*
*
* SPECMSG3:                          /* SET UP SPECIAL MESSAGE        *
*    SPECMSG='1'B;                   /* INDICATE SPEC MSG REQUIRED    *
SPECMSG3 OI    600(@B),B'10000000'                                1537
*    IF RNGEVAL1='1'B                /* IF FIRST VALUE OF RANGE       *
*      THEN                          /* BEING PROCESSED, DO NOT       *
         TM    177(@B),B'01000000'                                1538
         BC    12,@96B                                            1538
*      IF ERRORBIT^='1'B             /* SET INVPSAVE =PRMTPTR         *
*        THEN                        /* UNLESS THE ERROR BIT          *
         TM    599(@B),B'00001000'                                1539
*        GOTO ADDPDE;                /* IS ON                         *
         BC    12,ADDPDE                                          1540
*    INVPSAVE=PRMTPTR;               /* SET INVPSAVE TO THE BEGIN-
*                                       NING OF THE DATA FOUND TO TO
*                                       BE IN ERROR. INVPSAVE IS USED
*                                       BY THE MSGSETUP RTN IN
*                                       FORMATTING A CONTIGUOUS LINE
*                                       OF INVALID DATA               *
@96B     MVC   300(4,@B),584(@B)                                  1541
*    GEN (EJECT);
         EJECT
         DS    0H
*
*    /*****************************************************************
*    /*                                                               *
*    /* THE EXIT ROUTINE DETERMINES IF THE SCAN WAS SUCCESSFUL OR NOT.*
*    /* (ERRORBIT ON IF ERROR FOUND) IF SUCCESSFUL, THE PDE IS ADDED  *
*    /* TO THE PDL THROUGH THE POSITXCB ROUTINE IN IKJEFP00. THE      *
*    /* RETURN FROM POSITXCB IS PROCESSED. IF RETURN IS ON +4, A      *
*    /* CHAINED TERM OFF AN OPER IS BEING PROCESSED AND A SUBSCRIPT   *
*    /* FOR THE VARIABLE FOLLOWS IN THE BUFFER. IF +0, PROCESSING IS  *
*    /* DONE TO PREPARE TO CONTINUE THE SCAN IN THE BUFFER, EITHER BY *
*    /* RETURNING TO PARSE AND PROCEEDING ON THE NEXT PCE IN THE PCL, *
*    /* RETURNING TO THE OPER PROCESSOR TO CONTINUE THE SCAN OF AN    *
*    /* EXPRESSION, OR RETURNING TO TERM INITIALIZATION TO SCAN THE   *
*    /* NEXT TERM OF A LIST. IF AN ERROR HAS BEEN DETECTED IN THE     *
*    /* SCAN, THE MSGSETUP ROUTINE IS CALLED TO FORMAT THE INVALID    *
*    /* MESSAGE AND TO EXIT TO IKJEFP00 TO PROMPT. THE PROMPT RESPONSE*
*    /* IS RETURNED AT THE LABEL 'OPERTEST'                           *
*    /*                                                               *
*    /*****************************************************************
*
*
* RTNTEST:
*    IF ERRORBIT^='1'B               /* IF NO ERROR IN SCAN           *
*      THEN                          /* GO TO ADD THE PDE TO          *
RTNTEST  TM    599(@B),B'00001000'                                1543
*      GOTO ADDPDE;                  /* THE PDL                       *
         BC    12,ADDPDE                                          1544
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF PROCESSING A PROMPT RESPONSE AND WE ARE IN OPER MODE THE   *
*    /* ENTIRE BUFFER CAN BE REJECTED AS INVALID. THIS IS POSSIBLE    *
*    /* BECAUSE IF THE USER IS PROMPTED FOR PART OF AN EXPRESSION, HE *
*    /* IS ALLOWED TO ENTER ONLY THAT PART OF THE EXPRESSION WHICH WAS*
*    /* IN ERROR. THUS ANYTHING ELSE IN THE BUFFER IS NOT SCANNED.    *
*    /*                                                               *
*    /*****************************************************************
*
*
* CODE4A:
*    IF OPERMODE^='1'B               /* IF NOT OPER, DO NOT SET       *
*      THEN                          /* ENTIRE BUFFER AS              *
CODE4A   TM    599(@B),B'01000000'                                1545
*      GOTO CODE4B;                  /* INVALID                       *
         BC    12,CODE4B                                          1546
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF IN OPER MODE BUT NOT PROCESSING A PROMPT RESPONSE, CANNOT  *
*    /* THROW OUT ENTIRE BUFFER                                       *
*    /*                                                               *
*    /*****************************************************************
*
*    IF PRMTSCAN^='1'B               /* IS THIS A PROMPT RESPONSE     *
*      THEN                          /* IF NOT, DO NOT SET ENTIRE     *
         TM    600(@B),B'00000100'                                1547
         BC    01,@96A                                            1547
*      DO;                           /* BUFFER AS INVALID             *
*        PRMTSCAN='1'B;              /* INDICATE HAVE PROMPTED ONCE   *
         OI    600(@B),B'00000100'                                1549
*        GOTO CODE4B;                /* GO WRITE OUT MESSAGE          *
         BC    15,CODE4B                                          1550
*      END;                          /* END SPECIAL OPER PROCESSNG    *
*
*    /*****************************************************************
*    /*                                                               *
*    /* TO SET ENTIRE BUFFER INVALID, SET XINPUT EQUAL TO ENDINPUT.   *
*    /*                                                               *
*    /*****************************************************************
*
*
* INVALPRM:
*    R4=ENDINPUT;                    /* SET XINPUT TO END OF BUFFER   *
@96A     EQU   *                                                  1552
INVALPRM L     @4,144(0,@B)                                       1552
*
*    /*****************************************************************
*    /*                                                               *
*    /* XINPUTB IS USED BY THE MSGSETUP ROUTINE AND THE PARSE PARSE   *
*    /* PROMPTING ROUTINE. XINPUTB IS SET EQUAL TO XINPUT XINPUT IS   *
*    /* EITHER LEFT AT THE CHARACTER AFTER THE END OF INVALID DATA    *
*    /* SCANNED OR IS SET TO THE END OF THE BUFFER IF SCANNING A      *
*    /* PROMPT RESPONSE IN OPER MODE                                  *
*    /*                                                               *
*    /*****************************************************************
*
*
* CODE4B:
*    R5=R4;                          /* POINT AT END OF INVALID DATA  *
CODE4B   LR    @5,@4                                              1553
*
* CODE4C:
*    ERRORBIT='0'B;                  /* TURN ERROR BIT OFF            *
CODE4C   NI    599(@B),B'11100111'                                1554
*    NAMEREQD='0'B;                  /* NAME REQUIRED OFF             *
*    PFNOPOP='0'B;                   /* ALLOW STACK POPPING           *
         NI    179(@B),B'11111101'                                1556
*    FIRSTNAM='0'B;                  /* TURN FIRSTNAM SWITCH OFF      *
         NI    601(@B),B'01111111'                                1557
*    QUALCT=0;                       /* REINITIALIZE QUALIFIER COUNT  *
         MVI   598(@B),0                                          1558
*    ELEMNCT=0;                      /* REININTIALIZE ELEMNT COUNT    *
         MVI   597(@B),0                                          1559
*    SUBSMODE='0'B;                  /* SET SUBSCRIPT MODE OFF        *
         NI    599(@B),B'11011111'                                1560
*    IF PFLIST='1'B                  /* IF PROCESSING A LIST          *
*      THEN                          /* MSUT CHECK TO SEE IF RANGE    *
         TM    176(@B),B'10000000'                                1561
         BC    12,@969                                            1561
*        DO;                         /* (FIRST HALF ADDED             *
*          IF RNGADDED='1'B          /* IF FIRST HALF ADDED,          *
*            THEN                    /* MUST SEE IF WAS AN ELEMENT    *
         TM    600(@B),B'00000001'                                1563
         BC    12,@968                                            1563
*              DO;                   /* OF THE LIST (NOT FIRST) OR    *
*                IF PREVPDEL=0       /* THE FIRST LIST ELEMENT. IF    *
*                  THEN              /* PREVPDEL IS ZERO, IS FIRST    *
         SR    @F,@F                                              1565
         C     @F,448(0,@B)                                       1565
*                    GOTO PTRNOTST;  /* ELEMENT AND CAN ERASE THE
*                                       PERMANENT PDE                 *
         BC    08,PTRNOTST                                        1566
*                LISTPTR='FF000000'X;/* IF OTHER THAN FIRST ELEMENT   *
         L     @1,448(0,@B)        
         MVC   0(4,@1),@X27                                       1567
*                RNGEVAL1='0'B;      /* MUST RESET LISTPTR TO ERASE
*                                                              A00996 *
         NI    177(@B),B'10110111'                                1568
*                RNGEVAL2='0'B;      /* LIST PDE WITH HALF THE RANGE
*                                       AND MUST TURN OFF RANGE
*                                       SWITCHES SO DON'T GET PERM
*                                       PDE ZEROED             A00996 *
*              END;                  /* END LIST/RANGE ADDED PROCESS  *
*        END;                        /* END SPECIAL LIST TESTS TO
*                                       PREVENT ERASING GOOD FIRST
*                                       LIST ELEMENT PDE
*                                       IN ALL CASES, REINITIALIZE
*                                       RANGE ADDED INDICATOR         *
@968     EQU   *                                                  1571
*
* PTRNOTST:                          /* SET SEITCHES FOR MESSAGE      *
*    RNGADDED='0'B;                  /* TURN RNGADDED OFF             *
@969     EQU   *                                                  1572
PTRNOTST NI    600(@B),B'11111110'                                1572
*    IF PFSKPINV='1'B                /* IF THE V.C. EXIT WROTE A00996 *
*      THEN                          /* INVALID MSG, DECRMNT   A00996 *
         TM    177(@B),B'10000000'                                1573
         BC    12,@967                                            1573
*        R4=R4-1;                    /* XINPUT SO WON'T MISS   A00996 *
         BCTR  @4,0                                               1574
*                                    /* NEXT CHAR IN BUFFER    A00996 *
* VARCODE4:                          /* SET UP TO GO ISSUE ERROR      *
*    CBLNKSV2=ADDR (OPERTEST);       /* MESSAGE. INITIALIZE RETURN
*                                       ADDRESS. THE TERM PROCESSOR
*                                       WILL BE ENTERED AT THIS POINT
*                                       FROM IKJEFP00 WHEN THE PROMPT
*                                       RESPONSE IS PICKED UP.        *
@967     EQU   *                                                  1575
VARCODE4 LA    @F,OPERTEST                                        1575
         ST    @F,552(0,@B)                                       1575
*    CALL MSGSETUP;                  /* FORMAT AND WRITE OUT THE
*                                       INVALID MESSAGE. RETURN IS AT
*                                       OPERTEST.                     *
         BAL   @E,MSGSETUP                                        1576
*    GEN (EJECT);
         EJECT
         DS    0H
*
*    /*****************************************************************
*    /*                                                               *
*    /* THE ADDPDE ROUTINE PREPARES TO GO TO IKJEFP00 TO ADD THE PDE  *
*    /* TO THE PDL THE RETURN FROM POSITXCB IS DIAGNOSED WITH PROPER  *
*    /* ACTION TAKEN IF PROCESSING A CHAINED TERM OFF AN OPER, A LIST,*
*    /* OR AN EXPRESSION IN OPER MODE.                                *
*    /*                                                               *
*    /*****************************************************************
*
*
* ADDPDE:
*    R6=TERMXPCE;                    /* IF PROCESSING A SUBSCRIPT MUST
*                                       RESET XPCE AT THIS POINT. LEFT
*                                       AT THE SUBSCRIPT PCE UNTIL NO
*                                       ERROR DETECTED                *
ADDPDE   L     @6,528(0,@B)                                       1578
*    IF R4=>ENDINPUT                 /* IF EOB, GO TO          A00996 *
*      THEN                          /* ADD THE PDE WITHOUT    A00996 *
         C     @4,144(0,@B)                                       1579
*        GOTO ADDPDE2;               /* FURTHER LIST CHECKING  A00996 *
         BC    10,ADDPDE2                                         1580
*    IF PFLIST^='1'B                 /* IF NOT PROCESSING A LIST      *
*      THEN                          /* DO NOT HAVE TO CHECK FOR      *
         TM    176(@B),B'10000000'                                1581
*      GOTO ADDPDE2;                 /* CLOSING PAREN                 *
         BC    12,ADDPDE2                                         1582
*    IF COMBUF=')'                   /* IF AT THE END OF A LIST       *
*      THEN                          /* MUST DECREMENT XINPUT SO      *
         CLI   0(@4),C')'                                         1583
         BC    07,@966                                            1583
*      R4=R4-1;                      /* POSITXCB WILL NOT MISS IT     *
         BCTR  @4,0                                               1584
*
* ADDPDE2:
*    PLINKSV2=ADDR (CODE4C);         /* IF AN ERROR IS DETECTED IN THE
*                                       VALIDITY CHECK EXIT, RETURN IS
*                                       TO CODE4C TO WRITE OUT THE
*                                       INVALID MESSAGE               *
@966     EQU   *                                                  1585
ADDPDE2  LA    @F,CODE4C                                          1585
         ST    @F,672(0,@B)                                       1585
*    FIRSTNAM='0'B;                  /* TURN FIRSTNAM SWITCH OFF      *
         NI    601(@B),B'01111111'                                1586
*    SUBSMODE='0'B;                  /* REINITIALIZE SUBSCRIPT AND    *
         NI    599(@B),B'11011111'                                1587
*    ELEMNCT=0;                      /* SUBSCRIPT COUNT INDICATORS    *
         MVI   597(@B),0                                          1588
*    R1=PPCOUNT;                     /* SET THE SIZE OF THE PDE TO BE
*                                       ADDED IN REG1 FOR POSITX      *
         SR    @1,@1                                              1589
         IC    @1,417(0,@B)                                       1589
*    ADDCDE=3;                       /* GOTO POSITX IN IKJEFP00 TO    *
         LA    @F,3                                               1590
*    CALL LINKRET;                   /* ADD THE PDE                   *
         BAL   @E,LINKRET                                         1591
*    GOTO SPECOF;                    /* IF RETURN +0, KNOW NOT
*                                       PROCESSING CHAINED TERM       *
         BC    15,SPECOF                                          1592
*    SPECMSG='0'B;                   /* +4 RETURN MEANS MUST CONTIN   *
         NI    600(@B),B'01111111'                                1593
*    IF CHAINTRM^='1'B               /* IF NOT PROCESSING A           *
*      THEN                          /* CHAINED TERM, RET. ON         *
         TM    600(@B),B'00010000'                                1594
*      GOTO RTNCLNUP;                /* +4 IS INVALID                 *
         BC    12,RTNCLNUP                                        1595
*    IF CTFOUND^='1'B                /* IF A SUBSCRIPT WAS NOT        *
*      THEN                          /* FOUND AFTER THE VARIABLE      *
         TM    601(@B),B'01000000'                                1596
*      GOTO CODE4B;                  /* THE VARIABLE IS INVALID       *
         BC    12,CODE4B                                          1597
*    ADDCDE=5;                       /* SKIP BLANKS TO THE            *
         LA    @F,5                                               1598
*    CALL LINKRET;                   /* SUBSCRIPT. RETURN IS +4
*                                       BECAUSE KNOW SOME DATA FOLLOWS*
         BAL   @E,LINKRET                                         1599
*    GEN (NOP 0 );                   /* NO +0 RETURN                  *
         NOP 0
         DS    0H
*    R4=R4+1;                        /* POINT AT LEFT PAREN           *
         AH    @4,@D2                                             1601
*    GOTO GDNNBL;                    /* PROCESS SUBSCRIPT             *
         BC    15,GDNNBL                                          1602
*
*    /*****************************************************************
*    /*                                                               *
*    /* DETERMINE PROCESSING REQUIRED AFTER ADDING THE PDE            *
*    /*                                                               *
*    /*****************************************************************
*
*
* SPECOF:
*    SPECMSG='0'B;                   /* TURN OFF SPECIAL MESSAGE
*                                       INDICATOR - NO LONGER NECES-
*                                       SARY                          *
SPECOF   NI    600(@B),B'01111111'                                1603
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF RNGEVAL1 IS ON, HAVE COMPLETED THE FIRST VALUE OF A RANGE. *
*    /* MUST RETURN TO THE BEGINNING OF THE TERM PROCESSOR TO SCAN THE*
*    /* SECOND RANGE VALUE                                            *
*    /*                                                               *
*    /*****************************************************************
*
*    IF RNGEVAL1='1'B                /* FIRST VALUE OF RANGE PRO-     *
*      THEN                          /* CESSED. IF SO                 *
         TM    177(@B),B'01000000'                                1604
         BC    12,@965                                            1604
*      DO;                           /* RESET THE PDE PTR TO THE      *
*        RNGADDED='1'B;              /* INDICATE 1ST HALF OF RANGE
*                                       ADDED                         *
         OI    600(@B),B'00000001'                                1606
*
* GOBACK:
*        PDEPTR=ADDR (TEMPPDE);      /* ADDR OF THE TEMPORARY PDE TO
*                                       ADD 2ND VALUE INFO            *
GOBACK   LA    @F,332(0,@B)                                       1607
         ST    @F,564(0,@B)                                       1607
*        GOTO INVPSAV;               /* RETURN TO BEGINNING OF        *
         BC    15,INVPSAV                                         1608
*      END;                          /* TERM                          *
*
*    /*****************************************************************
*    /*                                                               *
*    /* MUST INITIALIZE CORE ANCHORS SO QUALIFIER LEVELS WILL BE ADDED*
*    /* CORRECTLY.                                                    *
*    /*                                                               *
*    /*****************************************************************
*
*    AANC=TANC;                      /* ADD NEXT QUALIFIER LEVEL AFTER
*                                       LAST ADDED. TANCH POINTS TO
*                                       THE NEXT FREE PDE SPACE       *
@965     MVC   568(4,@B),572(@B)                                  1610
*    RNGADDED='0'B;                  /* IF PROCESSING RANGE, HAVE
*                                       SUCCESSFULLY ADED BOTH HALVES
*                                       OF THE RANGE                  *
         NI    600(@B),B'11111110'                                1611
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF IN OPERMODE, RETURN TO THE OPER PROCESSOR WITH INDICATION  *
*    /* PDE WAS ADDED - +4                                            *
*    /*                                                               *
*    /*****************************************************************
*
*    IF OPERMODE^='1'B               /* IF NOT OPERMODE, CONTINUE     *
*      THEN                          /* SPECIAL TESTS FOR LIST        *
         TM    599(@B),B'01000000'                                1612
*      GOTO LISTEST;                 /* LISTS ARE NOT POSSIBLE UNDER
*                                       AN OPER                       *
         BC    12,LISTEST                                         1613
*    GOREG=CBLNKSV1+4;               /* RETURN +4 TO INDICATE PDE WAS
*                                       ADDED                         *
         LA    @E,4                                               1614
         A     @E,548(0,@B)                                       1614
*    R4=R4-1;                        /* DECREMENT XINPUT FOR SKIPB IN
*                                       OPER PROCESSOR                *
         BCTR  @4,0                                               1615
*    RETURN;                         /* RETURN TO OPER                *
         BC    15,@EL08                                           1616
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF PROCESSING A LIST, RETURN MUST BE TO THE BEGINNING OF THE  *
*    /* TERM PROCESSOR. DO NOT WANT TO SCAN THE NEXT ELEMENT OF THE   *
*    /* LIST UNDER THE NEXT PCE BUT UNDER THE PRESENT TERM PCE.       *
*    /*                                                               *
*    /*****************************************************************
*
*
* LISTEST:
*    IF PFLIST^='1'B                 /* IF NO LIST,                   *
*      THEN                          /* CONTINUE WITH NORMAL EXIT     *
LISTEST  TM    176(@B),B'10000000'                                1617
*      GOTO END1;                    /* PROCESSING                    *
         BC    12,END1                                            1618
*    ADDCDE=5;                       /* SKIP BLANKS TO THE NEXT
*                                       ELEMENT OF THE LIST           *
         LA    @F,5                                               1619
*    CALL LINKRET;                   /* SKIPB IN PARSE                *
         BAL   @E,LINKRET                                         1620
*    GOTO UPDTPCE;                   /* IF EOB, MUST GO TO UPDATE TO
*                                       THE NEXT PCE                  *
         BC    15,UPDTPCE                                         1621
*    R4=R4+1;                        /* IF NOT EOB , CHECK NEXT NEXT
*                                       CHAR FOR SEMICOLON            *
         AH    @4,@D2                                             1622
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF SEMICOLON ENDS LIST, MUST GO TO UPDATE TO THE NEXTPCE      *
*    /*                                                               *
*    /*****************************************************************
*
*    IF COMBUF^=';'                  /* IF NOT A SEMICOLON            *
*      THEN                          /* DECREMENT XINPUT              *
         CLI   0(@4),C';'                                         1623
         BC    08,@964                                            1623
*      DO;                           /* AND CONTINUE LIST PROCES      *
*        R4=R4-1;                    /* DECREMENT BEFORE SEMCOL       *
         BCTR  @4,0                                               1625
*        GOTO GOBACK;                /* RETURN TO BEGINNING OF        *
         BC    15,GOBACK                                          1626
*      END;                          /* OF TERM                       *
*    R4=R4-1;                        /* DECREMENT BEFORE SEMCOL       *
@964     BCTR  @4,0                                               1628
*
*    /*****************************************************************
*    /*                                                               *
*    /* ISSUE ENDING PAREN ASSUMED MESSAGE                            *
*    /*                                                               *
*    /*****************************************************************
*
*
* MSGRTN:
*    GOTO UPDTPCE;                   /* GO TO UPDATE TO THE NEXT PCE  *
         BC    15,UPDTPCE                                         1629
*
*    /*****************************************************************
*    /*                                                               *
*    /* THIS IS NORMAL END PROCESSING. NO RANGE OR LIST OR NOT        *
*    /* OPERMODE. A CHECK MUST BE MADE FOR EOB OR SEMICOLON SO THE    *
*    /* STACK CAN BE POPPED IF NECESSARY.                             *
*    /*                                                               *
*    /*****************************************************************
*
*
* END1:
*    IF R4=>ENDINPUT                 /* IF AT END OF BUFFER    A00996 *
*      THEN                          /* GO TO END              A00996 *
END1     C     @4,144(0,@B)                                       1630
*        GOTO SKIPSCAN;              /* PROCESSING IMMEDIATELY A00996 *
         BC    10,SKIPSCAN                                        1631
*    IF COMBUF=';'                   /* IF NOT EOB, AND IS            *
*      THEN                          /* SEMICOLON, MUST DECREMENT     *
         CLI   0(@4),C';'                                         1632
         BC    07,@963                                            1632
*        R4=R4-1;                    /* XINPUT TO BEFORE SEMCOL
*                                       SO WON'T MISS IT IN SUCCEED-
*                                       ING SCANS                     *
         BCTR  @4,0                                               1633
* SKIPSCAN:
*    ADDCDE=5;                       /* IF EOB OR ANYTHING ELSE       *
@963     EQU   *                                                  1634
SKIPSCAN LA    @F,5                                               1634
*    CALL LINKRET;                   /* TRY TO POP THE STACK          *
         BAL   @E,LINKRET                                         1635
*    GEN (NOP  0);                   /* GO TO SAME PLACE WHETHER STACK
*                                       POPPED OR NOT                 *
         NOP  0
         DS    0H
*
*    /*****************************************************************
*    /*                                                               *
*    /* XPCE MSUT BE UPDATED PASSED THE SUBSCRIPT PCE IF ONE IS       *
*    /* PRESENT. ALL COBOL PROCESSING INDICATORS MUST BE OFF WHEN     *
*    /* RETURN TO PARSE TO PROCESS THE NEXT PCE                       *
*    /*                                                               *
*    /*****************************************************************
*
*
* UPDTPCE:
*    R6=R6+PCELNGTH;                 /* UPDATE TO NEXT PCE            *
UPDTPCE  MVC   @TEMP2+2(2),2(@6)                                  1637
         A     @6,@TEMP2                                          1637
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF NEXT PCE IS A TERM, DETERMINE IF IT IS A SUBSCRIPT PCE     *
*    /*                                                               *
*    /*****************************************************************
*
*    IF TERPCE='110'B                /* IF IS A TERM                  *
*      THEN                          /* CHECK FOR SUBSCRIPT TERM      *
         TM    0(@6),B'11000000'                                  1638
         BC    12,@962                                            1637
         TM    0(@6),B'00100000'                                  1638
         BC    05,@961                                            1638
*
*      /***************************************************************
*      /*                                                             *
*      /* IF IS A SUBSCRIPT PCE, UPDATE PASSED IT. IF NOT A SUBSCRIPT,*
*      /* RETURN TO PARSE                                             *
*      /*                                                             *
*      /***************************************************************
*
*      IF SUBSCPPT='1'B              /* IF SUBSCRIPT PCE              *
*        THEN                        /* THEN UPDATE PASSED            *
         TM    6(@6),B'00001000'                                  1639
*        GOTO UPDTPCE;               /* IT                            *
         BC    01,UPDTPCE                                         1640
*    PFLIST='0'B;                    /* TURN POSSIBLE LIST BIT OFF    *
@961     EQU   *                                                  1641
@962     NI    176(@B),B'01111111'                                1641
*    COBOLMOD='0'B;                  /* TURN COBOL PROCESSING
*                                       INDICATOR OFF                 *
         NI    599(@B),B'01111111'                                1642
*    ADDCDE=19;                      /* RETURN TO PARSE TO PROCESS    *
         LA    @F,19                                              1643
*    CALL LINKRET;                   /* NEXT PCE. RETURN WILL BE TO
*                                       THE PROPER PROCESSOR TO
*                                       PROCESS THE NEXT PCE          *
         BAL   @E,LINKRET                                         1644
*    GEN (EJECT);
         EJECT
         DS    0H
*
*    /*****************************************************************
*    /*                                                               *
*    /* THE RSTPRTS ROUTINE IS ENTERED WHEN AN INVALID FIRST CHARACTER*
*    /* IS FOUND IN SCANNING A DATA NAME. SEVERAL CHECKS MUST BE MADE *
*    /* TO DETERMINE IF THE "ENTER                                    *
*    /*       ......." MESSAGE SHOULD BE ISSUED THROUGH THE PROMPTQ0  *
*    /* ROUTINE IN PARSE. THE INVALID CHARACTER COULD HAVE BEEN       *
*    /* DETECTED WHILE SCANNING A LEVEL OF QUALIFICATION, A LIST      *
*    /* ELEMENT THE SECOND VALUE OF A RANGE, A SUBSCRIPT, OR WHILE    *
*    /* SCANNING AN EXPRESSION ELEMENT IN OPER MODE. IF THIS IS THE   *
*    /* CASE, THE VARIABLE MUST BE CONSIDERED INVALID AND NOT MISSING.*
*    /* IF THE INVALID FIRST CHARACTER IS FOUND AFTER WE HAVE ALREADY *
*    /* PROMPTED FOR THIS TERM ONCE AS MISSING - PRMTSCAN ON - IT IS  *
*    /* THEN CONSIDERED INVALID ALSO SINCE THE USER WAS PROMPTED FOR A*
*    /* SPECIFIC TERM. IF NONE OF THE ABOVE SITIUATIONS APPLY,        *
*    /* PROMPTQ0 IN IKJEFP00 IS ENTERED TO DETERMINE IF THE TERM IS   *
*    /* REQUIRED. IF IT IS, PROMPTQ0 ISSUES THE "ENTER...." MESSAGE.  *
*    /* IF NOT, PROMTPQ0 RETURNS ON +4.                               *
*    /*                                                               *
*    /*****************************************************************
*
*
* RSTPTRS:
*    R4=PPOINTR;                     /* RESTORE XINPUT TO BEGINNIN    *
RSTPTRS  L     @4,148(0,@B)                                       1646
*    R5=PPOINTR;                     /* OF VARIABLE. XINPUTB TOO      *
         L     @5,148(0,@B)                                       1647
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF PRMTSCAN IS NOT ON (HAVE NOT PROMPTED FOR THIS TERM AS     *
*    /* MISSING BEFORE) GO MAKE CHECKS FOR INVALID OR MISSING         *
*    /*                                                               *
*    /*****************************************************************
*
*    IF PRMTSCAN^='1'B               /* IF HAVEN'T ISSUED "ENTER..    *
*      THEN                          /* MESSAGE FOR THIS TERM         *
         TM    600(@B),B'00000100'                                1648
*      GOTO NAMEREQ;                 /* BEFORE CHECK TO SEE IF SHOULD
*                                       BE CONSIDERED INVAL- ID OR
*                                       MISSING                       *
         BC    12,NAMEREQ                                         1649
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF PRMTSCAN IS ON, TERM IS INVALID SINCE HAVE PROMPTED        *
*    /* SPECIFICALLY FOR A CORRECT TERM.                              *
*    /*                                                               *
*    /*****************************************************************
*
*    IF OPERMODE='1'B                /* IF IN OPER MODE               *
*      THEN                          /* MAY REJECT ENTIRE PROMPT      *
         TM    599(@B),B'01000000'                                1650
*      GOTO INVALPRM;                /* BUFFER AS INVALID             *
         BC    01,INVALPRM                                        1651
*    R4=R4+1;                        /* GO PASSED INVAL 1ST CHAR      *
         AH    @4,@D2                                             1652
*    GOTO VERRBIT;                   /* IF NOT OPER, MUST CONTINUE
*                                       NORMAL SCAN TO DETERMINE END
*                                       OF VARIABLE IN ERROR          *
         BC    15,VERRBIT                                         1653
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF NAMEREQD BIT ON, VARIABLE IS INVALID                       *
*    /*                                                               *
*    /*****************************************************************
*
*
* NAMEREQ:
*    IF NAMEREQD='1'B                /* IF NAMEREQD BIT ON            *
*      THEN                          /* GO TO SCAN TO END OF VARIA-   *
NAMEREQ  TM    599(@B),B'00010000'                                1654
*      GOTO VERRBIT;                 /* BLE FOR INVALID MESSAGE       *
         BC    01,VERRBIT                                         1655
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF OPERMODE BIT ON, VARIABLE IS INVALID                       *
*    /*                                                               *
*    /*****************************************************************
*
*    IF OPERMODE='1'B                /* IF OPERMODE ON, GO            *
*      THEN                          /* SCAN TO END OF VARIABLE       *
         TM    599(@B),B'01000000'                                1656
         BC    12,@960                                            1656
*      DO;                           /* FOR INVALID MESSAGE           *
*        IF COMBUF=';'               /* IF INVALID FIRST CHAR         *
*          THEN                      /* IS A SEMI COLON OR A          *
         CLI   0(@4),C';'                                         1658
*          GOTO PRMPT;               /* RIGHT PAREN, MUST             *
         BC    08,PRMPT                                           1659
*        IF COMBUF=')'               /* PROMPT FOR MISSING            *
*          THEN                      /* INSTEAD OF                    *
         CLI   0(@4),C')'                                         1660
*          GOTO PRMPT;               /* INVALID                       *
         BC    08,PRMPT                                           1661
*        R4=R4+1;                    /* PREVENT LENGTH OF ZERO        *
         AH    @4,@D2                                             1662
*        GOTO VERRBIT;               /* SCAN INVALID VARIABLE         *
         BC    15,VERRBIT                                         1663
*      END;                          /* END SPECIAL OPER PROCESS      *
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF PROCESSING A LIST, TERM CANNOT BE MISSING. MUST BE         *
*    /* CONSIDERED INVALID.                                           *
*    /*                                                               *
*    /*****************************************************************
*
*    IF PFLIST='1'B                  /* IF PROCESSING LIST, GO        *
*      THEN                          /* SCAN TO END OF VARIABLE       *
@960     TM    176(@B),B'10000000'                                1665
         BC    12,@95F                                            1665
*      DO;                           /* FOR INVALID MESSAGE           *
*        R4=R4+1;                    /* PREVENT LENGTH OF ZERO        *
         AH    @4,@D2                                             1667
*        GOTO VERRBIT;               /* SCAN TO END OF INVALID DATA   *
         BC    15,VERRBIT                                         1668
*      END;                          /* END SPECIAL LIST PROCES       *
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF ON 2ND VALUE OF RANGE, MUST BE CONSIDERED INVALID          *
*    /*                                                               *
*    /*****************************************************************
*
*    IF RNGEVAL1='1'B                /* 2ND VALUE OF RANGE, GO        *
*      THEN                          /* SCAN TO END OF VARIABLE       *
@95F     TM    177(@B),B'01000000'                                1670
*      GOTO VERRBIT;                 /* FOR INVALID MESSAGE           *
         BC    01,VERRBIT                                         1671
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF PROCESSING A SUBSCRIPT, ENTIRE VARIABLE IS INVALID         *
*    /*                                                               *
*    /*****************************************************************
*
*    IF SUBSMODE='1'B                /* SUBSCRIPT PROCESSING - GO     *
*      THEN                          /* SCAN TO END OF VARIABLE       *
         TM    599(@B),B'00100000'                                1672
*      GOTO VERRBIT;                 /* FOR INVALID MESSAGE           *
         BC    01,VERRBIT                                         1673
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF NONE OF THE PREVIOUS CONDITIONS WERE MET, THE INVALID FIRST*
*    /* CHARACTER DENOTES A MISSING PARAMETER FOR THIS PCE. PROMPTING *
*    /* WILL BE PERFORMED IN PROMPTQ0 - IKJEFP00 IF THE TERM IS       *
*    /* REQUIRED.                                                     *
*    /*                                                               *
*    /*****************************************************************
*
*
* PRMPT:
*    PRMTSCAN='1'B;                  /* INDICATE HAVE PROMPTED FOR
*                                       THIS TERM ONCE AS MISSING.
*                                       CANNOT BE MISSING AGAIN.
*                                       INVALID IF INVALID 1ST CHAR IN
*                                       PROMPT RESPONSE               *
PRMPT    OI    600(@B),B'00000100'                                1674
*    R4=R4-1;                        /* DECREMENT XINPUT SO WON'T MISS
*                                       ANY OF PRESENT DATA WHEN
*                                       PROMPTQ0 PUSHES THE STACK     *
         BCTR  @4,0                                               1675
*    VARIA = '0'B;                   /* TURN OFF VARIABLE BIT IN PDE  *
         L     @1,564(0,@B)        
         NI    6(@1),B'11011111'                                  1676
*    ADDCDE=2;                       /* ADDRESS OF PROMPT ROUTINE     *
         LA    @F,2                                               1677
*    CALL LINKRET;                   /* IN R15 - GO TO PROMPT         *
         BAL   @E,LINKRET                                         1678
*    GEN;                            /* GENERATE BRANCHES             *
         BC   15,INVPSAV               +0 - PARM REQUIRED AND PROMPT
*                                      DATA RETURNED
         BC   15,NTRQEXT               +4 - PARM NOT REQUIRED. RETURN
*                                      PARSE TO PROCESS PARM ENTERED
*                                      ON THE NEXT PCE
         DS    0H
*    GEN (EJECT);
         EJECT
         DS    0H
*
*    /*****************************************************************
*    /*                                                               *
*    /* THE FOLLOWING ROUTINE IS ENTERED IF A LEVEL OF QUALIFICA- ON A*
*    /* DATA NAME IS BEING PROCESSED. SINCE QUALIFIER PDES ARE CHAINED*
*    /* OFF THE MAIN PDE FOR THE DATA NAME, BLOCKS OF CORE ARE GOTTEN *
*    /* IN WHICH TO PLACE THE QUALIFIER PDE'S. THE STALOC ROUTINE IN  *
*    /* IKJEFP00 IS ENTERED TO GET THIS BLOCK OF CORE AND CHAIN IT TO *
*    /* THE CORE OF THE MAIN PDE. INTERNAL ANCHORS WITHIN THE         *
*    /* QUALIFIER CORE BLOCKS ARE MAINTAINED IN ORDER TO ENSURE THAT  *
*    /* THE QUALIFIER PDE'S ARE ADDED IN THE PROPER ORDER AND THAT THE*
*    /* RIGHT PDE'S ARE ERASED IN CASE OF AN ERROR. THE INTERNAL      *
*    /* ANCHORS ARE: OANC - FIRST QUALIFIER PDE ADDRESS ADDED WHEN    *
*    /* PROCESSING AN EXPRESSION AANC - FIRST QUALIFIER PDE ADDRESS   *
*    /* ADDED FOR A SINGLE VARIABLE TANC - ADDRESS AT WHICH TO ADD THE*
*    /* NEXT QUALIFIER PDE FOR A VARIABLE ENDANC - ENDING ADDRESS FOR *
*    /* ONE 248 BYTE BLOCK. THE END OF THE CURRENT QUALIFIER PDE BLOCK*
*    /* THE CHAINPTR SLWAYS POINTS TO THE POSITION IN THE QUALIFIER   *
*    /* PDE WHICH CONTAINS A PTR TO THE NEXT QUALIFIER PDE.           *
*    /*                                                               *
*    /*****************************************************************
*
*
* CORETEST:
*
*    /*****************************************************************
*    /*                                                               *
*    /* DETERMINE IF A NEW 248 BYTE BLOCK OF CORE IS REQUIRED         *
*    /*                                                               *
*    /*****************************************************************
*
*    IF TANC=ENDANC                  /* ARE WE AT THE END OF THE      *
*      THEN                          /* BLOCK OR IS THIS THE FIRST    *
CORETEST L     @F,580(0,@B)                                       1681
         C     @F,572(0,@B)                                       1681
*      GOTO GETCOR;                  /* QUALIFIER. IF SO GO GET CORE  *
         BC    08,GETCOR                                          1682
*
*    /*****************************************************************
*    /*                                                               *
*    /* DETERMINE IF AN ERROR HAS CAUSED AANC TO BE RESET TO A        *
*    /* PREVIOUS BLOCK OF CORE. IF SO, UPDATE AANC TO POINT TO THE    *
*    /* BEGINNING OF THE LAST BLOCK OF CORE GOTTEN. AANC COULD GET    *
*    /* RESET TO THE PREVIOUS BLOCK, IF THE PREVIOUD DATANAME         *
*    /* QUALIFIER SCAN CAUSED A NEW BLOCK OF CORE TO BE OBTAINED FOR  *
*    /* THE PDE'S ASSOCIATED WITH THE QUALIF- FIERS OF THE DATA NAME. *
*    /* IF A SUBSEQUENT ERROR OCCURED TANC WOULD HAVE BEEN RESET TO   *
*    /* AANC. SINCE AANC WAS LEFT WHERE THE FIRST QUALIFIER WAS ADDED,*
*    /* AANC WOULD REMAIN POINTING INTO THE FIRST BLOCK OF CORE.      *
*    /*                                                               *
*    /*****************************************************************
*
*    IF TANC=>ENDANC-240             /* TWO CHECKS ARE NECESSARY      *
*      THEN                          /* TO ENSURE AANC LIES WITHIN    *
         LH    @F,@D9                                             1683
         A     @F,580(0,@B)                                       1683
         C     @F,572(0,@B)                                       1683
         BC    02,@95E                                            1683
*      DO;                           /* THE PRESENT CORE BLOCK        *
*
*        /*************************************************************
*        /*                                                           *
*        /* IF AANC IS EQUAL TO OR GREATER THAN THE BEGINNING OF THE  *
*        /* CORE BLOCK ADDRESS AND LESS THAN THE ENDING ADDRESS, IT   *
*        /* LIES WITHIN THE PRESENT CORE BLOCK.                       *
*        /*                                                           *
*        /*************************************************************
*
*        IF TANC<ENDANC              /* IS AANC WITHIN CORE BLOCK     *
*          THEN                      /* IF SO GO TO ADD               *
         L     @F,580(0,@B)                                       1685
         C     @F,572(0,@B)                                       1685
*          GOTO ADDQUALF;            /* PRESENT QUALIFIER             *
         BC    02,ADDQUALF                                        1686
*      END;                          /* END ANCHOR CHAECKS            *
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF AANC DOES NOT LIE WITHIN PRESENT CORE BLOCK, MUST RESET    *
*    /* AANC TO THE BEGINNING OF THIS CORE BLOCK.                     *
*    /*                                                               *
*    /*****************************************************************
*
*
* NEWBLOCK:
*    AANC=ENDANC-240;                /* ADD QUALIFIER AT BEGINNING OF
*                                       THIS CORE BLOCK               *
@95E     EQU   *                                                  1688
NEWBLOCK LH    @F,@D9                                             1688
         A     @F,580(0,@B)                                       1688
         ST    @F,568(0,@B)                                       1688
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF OANC FOR AN EXPRESSION WAS EQUAL TO TANC, MUST RESET OANC  *
*    /* TO CORRESPOND TO THE NEW ADDRESS.                             *
*    /*                                                               *
*    /*****************************************************************
*
*    IF OANC=TANC                    /* ARE WE PROCESSING AN ESPRES-
*                                       S                             *
*      THEN                          /* SION. IF SO, SET              *
         L     @F,572(0,@B)                                       1689
         C     @F,576(0,@B)                                       1689
         BC    07,@95D                                            1689
*      OANC=AANC;                    /* OANC = TO NEW CORE BLOCK
*                                       ADDRESS                       *
         MVC   576(4,@B),568(@B)                                  1690
*    TANC=AANC;                      /* IN ALL CASES MUST INDICATE THE
*                                       NEXT QUALIFIER LEVEL IS ADDED
*                                       AT THE BEGINNING OF THIS CORE
*                                       BLOCK                         *
@95D     MVC   572(4,@B),568(@B)                                  1691
*    GOTO ADDQUALF;                  /* GO TO ADD QUALIFIER           *
         BC    15,ADDQUALF                                        1692
*
*    /*****************************************************************
*    /*                                                               *
*    /* A BLOCK OF CORE IS REQURIED FOR THE QUALIFIER PDE'S           *
*    /*                                                               *
*    /*****************************************************************
*
*
* GETCOR:
*    R1=248;                         /* CORE SIZE REQUIRED IN REG1    *
GETCOR   LA    @1,248                                             1693
*    ADDCDE=12;                      /* GO TO THE STALOC ROUTINE      *
         LA    @F,12                                              1694
*    CALL LINKRET;                   /* IN PARSE TO ACQUIRE CORE AND
*                                       CHAIN TO MAIN PDE CORE        *
         BAL   @E,LINKRET                                         1695
*    LINK2=R1;                       /* SAVE ADDRESS OF CORE GOTTEN IN
*                                       LINK2                         *
         LR    @9,@1                                              1696
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF THIS IS THE FIRST QUALIFIER CORE GOTTEN , I.E., AANC IS    *
*    /* ZERO, MUST INITIALIZE OANC TO ADDRESS OF CORE. IF NOT FIRST   *
*    /* BLOCK OF CORE, ONLY TANC AND ENDANC SHOULD BE INITIALIZED.    *
*    /* OANC AND AANC SHOULD BE LEFT WITHIN THE LAST BLOCK IN ORDER TO*
*    /* ERASE THE PROPER QUALIFIER PDE'S SHOULD AN ERROR OCCUR.       *
*    /*                                                               *
*    /*****************************************************************
*
*    IF AANC=0                       /* FIRST QUALIFIER CORE BLOCK?   *
*      THEN                          /* IF SO,                        *
         SR    @F,@F                                              1697
         C     @F,568(0,@B)                                       1697
         BC    07,@95C                                            1697
*      DO;                           /* INITIALIZE OANC AND AANC      *
*        OANC=LINK2+8;               /* SET OANC TO BEGINNING OF CORE.
*                                       FIRST EIGHT BYTES ARE CHAIN
*                                       INFO USED BY STALOC AND
*                                       FREEING CORE                  *
         LA    @F,8                                               1699
         AR    @F,@9                                              1699
         ST    @F,576(0,@B)                                       1699
*        AANC=OANC;                  /* AANC ALSO EQUAL TO FIRST PLACE
*                                       TO ADD PDE                    *
         MVC   568(4,@B),576(@B)                                  1700
*      END;                          /* END NEW CORE PROCESSING       *
*    TANC=LINK2+8;                   /* TANC ALWAYS SET TO ADDRESS OF
*                                       NEW CORE BLOCK - NEXT
*                                       QUALIFIER PDE ADDED HERE      *
@95C     LA    @F,8                                               1702
         AR    @F,@9                                              1702
         ST    @F,572(0,@B)                                       1702
*    ENDANC=LINK2+248;               /* SET ENDANC EQUAL TO THE
*                                       ADDRESS OF THE END OF THIS
*                                       CORE BLOCK                    *
         LA    @F,248                                             1703
         AR    @F,@9                                              1703
         ST    @F,580(0,@B)                                       1703
*
*    /*****************************************************************
*    /*                                                               *
*    /* CORE HAS BEEN INITIALIZED AT THIS POINT AND WE ARE READY TO   *
*    /* FILL IN THE QUALIFIER PDE.                                    *
*    /*                                                               *
*    /*****************************************************************
*
*
* ADDQUALF:
*    WORKAR1 (1:12)=                 /* CLEAR 12 BYTES FOR THE        *
*          WORKAR1(1:12)&&           /* THE NEXT QUALIFIER            *
*          WORKAR1(1:12);            /* PDE                           *
ADDQUALF L     @1,572(0,@B)        
         XC    0(12,@1),0(@1)                                     1704
*    ADDCDE=9;                       /* TRANSLATE THE QUALIFIER       *
         LA    @F,9                                               1705
*    CALL LINKRET;                   /* TO UPPERCASE IF REQUIRED      *
         BAL   @E,LINKRET                                         1706
*    QNAMEPTR=PPOINTR;               /* ADD PTR TO QUALIFIER TO PDE   *
         L     @1,572(0,@B)        
         MVC   0(4,@1),148(@B)                                    1707
*    QNGTH4=PLENGTH;                 /* ADD QUALIFIER LENGTH TO PDE   *
         MVC   4(1,@1),153(@B)                                    1708
*    QATAPTRH='FF000000'X;           /* SET CHAINPTR = FF000000 TO
*                                       INDICATE THIS IS THE LATEST
*                                       QUALIFIER ADDED               *
         MVC   8(4,@1),@X27                                       1709
*    PTRARE=TANC;                    /* SET PREVIOUS QUALIFIER PDE
*                                       CHAIN PTR EQUAL TO THE ADDRESS
*                                       OF THIS QUALIFIER PDE         *
         L     @7,560(0,@B)        
         MVC   0(4,@7),572(@B)                                    1710
*    CHAINPTR=TANC+8;                /* SET CHAINPTR EQUAL TO THIS
*                                       QUALIFIERS CHAIN POINTER      *
         LA    @F,8                                               1711
         A     @F,572(0,@B)                                       1711
         ST    @F,560(0,@B)                                       1711
*    TANC=TANC+12;                   /* INDICATE NEXT QUALIFIER SHOULD
*                                       BE ADDED 12 BYTES FURTHER IN
*                                       BLOCK OF CORE                 *
         LA    @F,12                                              1712
         A     @F,572(0,@B)                                       1712
         ST    @F,572(0,@B)                                       1712
*    GOTO ENDSCAN;                   /* CONTINUE SCAN OF DATANAME     *
         BC    15,ENDSCAN                                         1713
*    GEN (EJECT);
         EJECT
         DS    0H
*
*    /*****************************************************************
*    /*                                                               *
*    /* THIS INTERNAL PROCEDURE INCREMENTS THE BUFFER POINTER BY ONE. *
*    /* IF EOB IS REACHED, THE STACK IS POPPED IF POSSIBLE. IF THERE  *
*    /* IS NO MORE DATA IN THE BUFFER RETURN TO THE CALLER IS ON +4.  *
*    /* IF THERE IS MORE DATA IN BUFFER, RETURN IS ON +0.             *
*    /*                                                               *
*    /*****************************************************************
*
*
* BUMP:
*    PROC OPTIONS(DONTSAVE,NOSAVEAREA); /* INTERNAL SUBROUTINE        *
@EL08    BCR   15,@E                                              1715
*    RESTRICT (R4,R5);               /* RESTRICT BUFFER POINTERS      *
*    RESTRICT (R6);                  /* PCE POINTER                   *
*    RESTRICT (PWAREG);              /* WORK AREA POINTER             *
*    RESTRICT (LINK2);               /* LINKAGE REGISTER FOR RETURN   *
*    LINK2=GOREG;                    /* SAVE CALLERS RETURN ADDR      *
BUMP     LR    @9,@E                                              1720
*    R4=R4+1;                        /* INCREMENT XINPUT TO NEXT
*                                       CHARACTER                     *
         AH    @4,@D2                                             1721
*
*    /*****************************************************************
*    /*                                                               *
*    /* IF OFF THE END OF THIS BUFFER, TRY TO POP STACK               *
*    /*                                                               *
*    /*****************************************************************
*
*    IF R4=>ENDINPUT                 /* OFF EOB                       *
*      THEN                          /* IF SO, TRY                    *
         C     @4,144(0,@B)                                       1722
         BC    04,@95B                                            1722
*      DO;                           /* TO POP STACK                  *
*        ADDCDE=5;                   /* IF +4, SKIPB IN THE BUFFER    *
         LA    @F,5                                               1724
*        CALL LINKRET;               /* IF NOTHING ELSE IN BUFFER     *
         BAL   @E,LINKRET                                         1725
*        GOTO RESTORE;               /* RETURN +0                     *
         BC    15,RESTORE                                         1726
*        GOREG=LINK2;                /* IF +4 - MORE DATA - RTRN      *
         LR    @E,@9                                              1727
*        GOREG=GOREG+8;              /* +8 TO INDICATE STACK WAS      *
         AH    @E,@D10                                            1728
*        RETURN;                     /* POPPED ( SEPARATOR FOLLOWED   *
         BC    15,@EL09                                           1729
*      END;                          /* END EOB PROCESSING            *
*    IF COMBUF=';'                   /* IF XINPUT POINTS AT A         *
*      THEN                          /* SEMICOLON, WE ARE ALSO AT     *
@95B     CLI   0(@4),C';'                                         1731
         BC    07,@95A                                            1731
*      DO;                           /* THE END OF OUR BUFFER         *
*       R4=R4-1;                     /* DECREMENT FOR INCREMENT       *
         BCTR  @4,0                                               1733
*       GOTO RESTORE;                /* AT RESTORE                    *
         BC    15,RESTORE                                         1734
*      END;                          /* END SEMICOLON PROCESS         *
*    GOREG=LINK2;                    /* RESTORE CALLERS RETURN ADDRESS*
@95A     LR    @E,@9                                              1736
*    GOREG=GOREG+4;                  /* INDICATE MORE DATA IN BUFFER
*                                       BY RETURNING ON + 4           *
         AH    @E,@D11                                            1737
*    RETURN;                         /* RETURN TO CALLER              *
         BC    15,@EL09                                           1738
*
* RESTORE:
*    R4=R4+1;                        /* INCREMENT SO WON'T CATCH
*                                       LAST CHAR IN BUFFER           *
RESTORE  AH    @4,@D2                                             1739
*    GOREG=LINK2;                    /* RESTORE CALLER'S RETURN AD-   *
         LR    @E,@9                                              1740
*    RETURN;                         /* DRESS, RETURN ON A +0         *
*    END BUMP;                       /* TO INDICATE N OMORE DATA      *
@EL09    BCR   15,@E                                              1742
*
*    /*****************************************************************
*    /* THIS INTERNAL SUBROUTINE DOES RANGE PROCESSING.  IF XINPUT    *
*    /* IS POINTING AT THE END OF THE BUFFER, NO TEST OF THE CHAR     *
*    /* IS MADE BUT THE RANGE SWITCHES ARE SET CORRECTLY.  IF NOT     *
*    /* AT EOB, THE RANGE ROUTINE IN IKJPARS IS ENTERED TO TEST THE   *
*    /* INPUT CHARACTER AND SET THE RANGE SWITCHES CORRECTLY.  RETURN *
*    /* TO THE CALLER IS ON RETURN REGISTER +0 OR +4 DEPENDING ON THE *
*    /* RETURN FROM THE RANGE PROCESSOR IN IKJPARS.                   *
*    /*****************************************************************
*
* TSTRNGE:                           /* RANGE TESTING          A00996 *
*    PROC OPTIONS(DONTSAVE,NOSAVEAREA); /* INTERNAL SUBROUTINE A00996 *
*    RESTRICT (R4,R5,R6);            /* MUST RESTRICT          A00996 *
*    RESTRICT (PWAREG,LINK2);        /* CRITICAL REGISTERS     A00996 *
*    LINK2=GOREG;                    /* SAVE THE CALLERS       A00996
*                                       RETURN REGISTER        A00996 *
TSTRNGE  LR    @9,@E                                              1746
*    IF R4=>ENDINPUT                 /* IF AT END OF BUFFER    A00996 *
*      THEN                          /* MUST TEST RANGE SWITCH A00996 *
         C     @4,144(0,@B)                                       1747
         BC    04,@959                                            1747
*        DO;                         /* ES TO SET CORRECTLY    A00996 *
*          IF RNGEVAL1='1'B          /* IF FIRST VALUE OF RANGEA00996 *
*            THEN                    /* PROCESSED, MUST INDI-  A00996 *
         TM    177(@B),B'01000000'                                1749
         BC    12,@958                                            1749
*              DO;                   /* SECOND RANGE VALUE     A00996 *
*                RNGEVAL1='0'B;      /* SCAN COMPLETED.        A00996 *
         NI    177(@B),B'10111111'                                1751
*                RNGEVAL2='1'B;      /* SET SECOND RANGE       A00996 *
         OI    177(@B),B'00001000'                                1752
*              END;                  /* SWITCH ON              A00996 *
*          GOREG=LINK2;              /* IF NOT RANGE VALUE BUT A00996 *
@958     LR    @E,@9                                              1754
*          RETURN;                   /* END OF BUFFER, RETURN  A00996 *
         BC    15,@EL10                                           1755
*        END;                        /* +0 TO INDICATE NO      A00996
*                                       RANGE OR 2ND VALUE     A00996 *
*    ADDCDE=6;                       /* IF NOT EOB, MSUT GO TO A00996 *
@959     LA    @F,6                                               1757
*    CALL LINKRET;                   /* THE RANGE PROCESSOR IN A00996
*                                       IKJPARS TO TEST THE    A00996
*                                       INPUT CHAR AND SET     A00996
*                                       SWITCHES ACCORDINGLY   A00996 *
         BAL   @E,LINKRET                                         1758
*    GOTO ZERORNG;                   /* IF +0 RETURN, NO RANGE A00996
*                                       OR 2ND VALUE - RETURN  A00996
*                                       +0 TO CALLER           A00996 *
         BC    15,ZERORNG                                         1759
*    GOREG=LINK2;                    /* IF +4 RETURN, FIRST    A00996 *
         LR    @E,@9                                              1760
*    GOREG=GOREG+4;                  /* VALUE OF RANGE ENCOUN- A00996 *
         AH    @E,@D11                                            1761
*    RETURN;                         /* TERED - RETURN TO      A00996
*                                       CALLER +4              A00996 *
         BC    15,@EL10                                           1762
* ZERORNG:                           /* RETURN TO CALLER +0    A00996 *
*    GOREG=LINK2;                    /* RESTORE CALLER RETURN  A00996 *
ZERORNG  LR    @E,@9                                              1763
*    RETURN;                         /* ADDRESS - RETURN +0    A00996 *
* END TSTRNGE;                       /* END THE RANGE INTERNAL A00996
*                                       PROCEDURE              A00996 *
@EL10    BCR   15,@E                                              1765
* ENDTERM:
*    END IKJEFP60;                   /* END TERM PROCESSOR            *
**/*CSDPARSE: CHART IKJEFP50 COMBINED WITH IKJEFP40 */
**/* HEADER
**/*IKJEFP40 - IKJEFP50 */
**/*IKJEFP50: E  START */
**/* P TURN ON OPER AND COBOL MODE BITS */
**/* P ZERO OPER PROMPT BIT */
**/* P SET OANC = AANC */
**/* P  OPERPCE = XPCE */
**/* P PRIORPCE = XPCE */
**/* P XPCE = TERM1 PCE ADDR */
**/* S TERMOCK: TEST MINOR TERM1 PCE */
**/* P XPCE = ADDR MINOR RSVWD PCE */
**/* D (NO,RTNCLNUP,YES,) XPCE POINTS TO A RSVWD PCE */
**/* D (YES,RTNCLNUP,NO,) FIGURATIVE CONSTANT RSVWD PCE */
**/* D (NO,RTNCLNUP,YES,) RSVWD PCE ADDR GREATER THAN PRIORPCE */
**/* P PRIORPCE = XPCE */
**/* P XPCE = TERM2 PCE ADDR */
**/* S TERMOCK: TEST MINOR TERM2 PCE */
**/* D (NO,%ORSKP1,YES,) OPER PCE HAS A CHAINED TERM3 */
**/* P XPCE = ADDR TERM3 PCE */
**/* S TERMOCK: TEST MINOR TERM3 PCE */
**/*%ORSKP1: D (YES,%PEI,NO,) PRIORPCE TERM CAN HAVE SUBSCRIPT */
**/* P (,%PB)  I = 20 */
**/*%PEI: P I = 80  */
**/* P PRIORPCE = PRIORPCE + PCE LENGTH */
**/* D (YES,,NO,RTNCLNUP) PRIORPCE  POINTS TO A SUBSCRIPT TERM */
**/*%PB: P OPERLL = LAST MINOR TERM PDE ADDR +I MINUS OPER PDE ADDR */
**/* P STORE PRIORPCE IN OPEREND */
**/* S (+0,D1,+4,) SKIPB: +0 RETURN ON END OF INPUT */
**/*PR: P OPERSVE = XINPUTB */
**/* D (YES,%ABC,NO,)  XINPUTB -> LEFT PAREN */
**/* D (YES,I1,NO,OPTTERM) XINPUTB -> SEMICOLON */
**/*%ABC: P UP XINPUT POINTER BY ONE */
**/* P TURN OFF CHAINTRM BIT */
**/* P  XPCE = TERM1 PCE ADDR */
**/* S  (+4,,+0,F1) IKJEFP60: ADD TERM PDE */
**/* P SAVE MSGAREA DATA IN OPERSPM */
**/* P SET XPCE TO RSVWD PCE */
**/* S (+4,,+0,OSPMSG) IKJEFP40: ADD RSVWD PDE */
**/* P SET XPCE TO TERM2 PCE */
**/* P TURN OFF PFNOPOP */
**/* S SKIPB: RETURN TO OPER INPUT BUFFER  */
**/* S (+4,,+0,OSPMSG) IKJEFP60: ADD TERM PDE */
**/* D (YES,,NO,%OR060) PWA FLAG PFENDSET ON */
**/* P (,%OR070) OPERSVE = ENDBAKUP */
**/*%OR060: P OPERSVE = XINPUT +1 */
**/*%OR070: S (+0,A,+4,) SKIPB: SKIP SEPARATORS  IN BUFFER */
**/* D (YES,,NO,A) XINPUTB POINTS TO A RIGHT PAREN */
**/* P SET INVPSAVE = PRMTPTR */
**/* P (,B) XINPUT = XINPUTB */
**/*OPTTERM: D (NO,I1,YES,) CHAINED TERM PCE EXISTS */
**/* P SET XPCE TO CHAIN TERM PCE ADDR */
**/* P TURN ON CHAINTRM BIT */
**/* S (+4,B,+0,D1) IKJEFP60: ADD TERM PDE */
**/*I1: D (YES,,NO,D1) OPER PROMPT BIT ON */
**/* P SET INVPSAVE = OPERSVE */
**/* P XINPUT = XINPUTB */
**/* P (,A1I) I = 'FFFF'X */
**/*D1: P SET XPCE = OPERPCE */
**/* S  (+0,P50PR,+4,EP) PROMPTQ: PROMPT FOR MISSING DATA */
**/*OVCERR: P  TURN ON RIGHT PAREN INDICATOR FOR SPECIAL MESSAGE   */
**/* P TURN ON LEFT PAREN INDICATOR */
**/* P TURN ON SPECIAL MESSAGE INDICATOR */
**/* P MOVE OPERSPM DATA INTO MSGAREA */
**/* P (,WWW) XINPUT = XINPUT +1 */
**/*F1: P MSGADDR = OPERSVE   */
**/* P (,F2) MSGLEN = 1 */
**/*OSPMSG: P  SET LEFT PAREN BIT ON */
**/* P   MSGAREA = OPERSPM */
**/*F2: P SET SPECIAL MESSAGE BIT ON */
**/* S (+0,T,+4,) SKIPB: SKIP OVER SEPARATORS */
**/* P SET INVPSAVE = XINPUTB */
**/* P XINPUT = XINPUTB */
**/* P INITIALIZE PAREN COUNT TO ONE */
**/*R: D (YES,,NO,%LPCK) INPUT CHARACTER A RIGHT PAREN */
**/* P SUBTRACT ONE FROM PAREN COUNT */
**/*%CZERO: D (NO,,YES,A1I) PAREN COUNT GREATER THAN ZERO */
**/* P (,WW) XINPUT = XINPUT + 1 */
**/*%LPCK: D (YES,,NO,%OR020)  INPUT CHARACTER A LEFT PAREN */
**/* P  ADD ONE TO PAREN COUNT */
**/*%OR020: D (YES,,NO,A1I) XINPUT POINTS TO A SEMICOLON */
**/* D (YES,T,NO,WW) INVPSAVE - XINPUT = 0 */
**/*A1I: P XINPUT = XINPUT +1  */
**/* D (NO,R,YES,WW)  XINPUT NOT < ENDINPUT */
**/*T: P TURN ON BLNKFLAG */
**/* P INVPSAVE = ADDR(BLNK) */
**/* P (,W) XINPUTB = ADDR(BLNK) +1 */
**/*WW: P XINPUTB = XINPUT */
**/*W: P SET XPCE = OPERPCE */
**/*WWW: P PPCOUNT = OPER PDE LENGTH -1  */
**/* P CBLNKSV2 = ADDR(P50PR) */
**/* S MSGSETUP: PROMPT */
**/*P50PR: D (YES,%TPR,NO,) PFNULL OFF */
**/* P (,EP) TURN OFF PFNULL */
**/*%TPR: P (,PR) TURN ON OPER PROMPT BIT */
**/*A: P SET CBLNKSV1 TO ADDR(B) FOR RETURN */
**/* P PPOINTR = PRMTPTR +1 */
**/* P XINPUTB = OPERSVE */
**/* S PSTRIMSG: WRITE CLOSING PARENTHESIS ASSUMED MESSAGE */
**/*B: P FILL IN THE OPER PDE */
**/* P RESTORE XPCE FROM OPERPCE */
**/* P TURN OFF CHAINTRM BIT */
**/* P SET REGISTER 1 = PDE LENGTH -1 */
**/* P PLINKSV2 = ADDR(OVCERR) */
**/* S (NORM,,ERR,OVCERR) POSITXCB: ADD OPER PDE */
**/*EP: P SET XPCE = OPEREND */
**/* P (,RTNNSKP3) SET OPER MODE SWITCH OFF */
**/*IKJEFP40: E START */
**/* P SET RSVDRTN = LINKA */
**/* P  RSVWDSV2 = XPCE */
**/* P ZERO RSVDPRMT SWITCH */
**/* D (NO,,YES,RCT) XPCE -> TERM PCE */
**/* D (NO,RTNCLNUP,YES,)  XPCE -> RESERVE WORD PCE  */
**/* D (NO,RTNNSKP3,YES,) PDE ALLOCATED */
**/* P (,EE) SET COBOL SWITCH ON  */
**/*RCT: P PLACE CHAINED RSVWD PTR IN XPCE */
**/* D (YES,,NO,RTNCLNUP) XPCE POINTS TO A RSVWD PCE */
**/* D (YES,RTNCLNUP,NO,)  RSVWD PDE ALLOCATED */
**/* P RSVWDSV1 = XINPUT */
**/*EE: P RSVWDPCE = XPCE */
**/*  S (NO,A1,YES,) SKIPB: SKIP TO THE FIRST CHAR OF THE RSVWD */
**/*E: P SET LENGTH COUNT = ZERO */
**/* P  SAVE XINPUT IN RSVWDSV1 */
**/* P SET UP SEPARATOR MASK FOR TYPETEST */
**/*SL: P XINPUT = XINPUT +1 */
**/* D (YES,F,NO,) XINPUT NOT < ENDINPUT */
**/* S (+4,OMODCK,+0,) TYPETEST: XINPUT -> SEPARATOR IF +4 */
**/*RPTEST: D (YES,,NO,%CTEST) DOES XINPUT P0INT TO A RIGHT PAREN */
**/* D (YES,OMODCK2,NO,) OPERMODE */
**/* D (YES,F,NO,) SUBSMODE FLAG ON IN PWA */
**/* D (YES,F,NO,) PFLIST FLAG ON IN PWA */
**/*%CTEST: D (YES,,NO,%SCTEST) XINPUT POINTS TO A COLON */
**/* D (YES,,NO,%SCTEST) RFCONST FLAG ON IN RSVWD PCE */
**/* D (YES,F,NO,) RANG FLAG ON IN TERM PCE */
**/*%SCTEST: D (YES,,NO,AI1) XINPUT POINTS TO A SEMICOLON */
**/* D (YES,,NO,F) PWA RSVDPRMT FLAG ON */
**/* D (YES,AI1,NO,) PWA OPERMODE FLAG ON */
**/* D (NO,F2R,YES,) RSVWD LENGTH COUNT = ZERO */
**/*AI1: P (,SL) ADD ONE TO RSVWD LENGTH COUNT */
**/*F: D (YES,,NO,F2R) RSVWD LENGTH COUNT = 0 */
**/* D (YES,,NO,%OR050) PWA RSVDPRMT FLAG ON */
**/* D (YES,IPA,NO,A1I) PWA OPERMODE FLAG ON */
**/*%OR050: P (,A1) XINPUT = XINPUT -1 */
**/*F2R: D (YES,NOMATCH2,NO,) RSVWD LENGTH COUNT GREATER THAN 256 */
**/* P PLENGTH = ICOUNT */
**/* P REG1 = RSVWD LENGTH COUNT */
**/* S GETCORE: OBTAIN TEMPORARY WORK AREA */
**/* P PPOINTR = START OF WORK AREA = REG1 */
**/* P COPY RSVWD INTO WORK AREA */
**/*RTQ: S TRANSQ: TRANSLATE RSVWD COPY TO UPPER CASE */
**/* P XINPUTB = PPOINTR */
**/* P PPOINTR = RSVWDSV1 +1 */
**/* P XINPUT = RSVWD LENGTH COUNT + PPOINTR  */
**/* P NAME COUNT = ZERO */
**/*NAMECK: P UP XPCE PTR BY PCE LENGTH */
**/* P NAME COUNT = NAME COUNT +1 */
**/* D (YES,,NO,NOMATCH) XPCE POINTS TO IKJNAME PCE */
**/* D (YES,,NO,NAMECK) RSVWD LENGTH = NAME LENGTH  */
**/* D (YES,,NO,NAMECK) RSVWD MATCHES NAME */
**/* S FREECORE: FREE RSVWD COPY AREA */
**/* D (YES,,NO,%ADDPDE) RSVWD PCE RFCONST FLAG ON */
**/* P (,RTN4) PLACE NAME# IN PDE  INDICATED BY PDEPTR */
**/*%ADDPDE:  P XINPUT = XINPUT -1 */
**/* P RESTORE XPCE FROM RSVWDPCE */
**/* P FILL IN THE RSVWD PDE */
**/* P XINPUTB = XINPUT */
**/* P INVPSAVE = PPOINTR */
**/* P REGISTER ONE = PDE LENGTH -1 = 7 */
**/* S POSITXCB: ADD PDE */
**/* D (YES,RTN4,NO,RTNNSKP3) OPER MODE BIT ON */
**/*NOMATCH: S FREECORE: FREE RSVWD COPY AREA  */
**/*NOMATCH2: D (YES,RTN0,NO,) RSVWD PCE RFCONST FLAG ON */
**/* D (YES,IP,NO,) PWA RSVDPRMT FLAG ON */
**/* D (YES,IP,NO,) PWA OPERMODE FLAG ON */
**/* D (YES,IP,NO,) RSVWD PCE RPRMTI FLAG ON */
**/* D (YES,IP,NO,) RSVWD PCE RDFLTI FLAG ON */
**/* P XPCE = RSVWDPCE  */
**/* P (,RTNNSKP3) XINPUT = RSVWDSV1 */
**/*IPA: P XINPUT = ENDINPUT */
**/*IP: P INVPSAVE = RSVWDSV1 +1 */
**/* P PPCOUNT = LENGTH OF RSVWD PDE -1 = 7 */
**/* P RESTORE XPCE FROM RSVWDPCE */
**/* P XINPUTB = XINPUT */
**/* P CBLNKSV2 = ADDR(P40PR) */
**/* S (,P40PR) MSGSETUP: PICK UP PROMPT DATA */
**/*A1: D (YES,RTN0,NO,) RSVWD PCE RFCONST FLAG ON */
**/* P XPCE = RSVWDPCE */
**/* S (+0,P40PR,+4,RPQRTN4) PROMPTQ: PROMPT FOR MISSING DATA */
**/*P40PR: D (NO,%OM1,YES,) PWA PFNULL FLAG OFF */
**/* P (,E) SET RSVWD PROMPT BIT ON */
**/*%OM1: P TURN PWA PFNULL FLAG OFF */
**/*RPQRTN4: D (YES,RTNO0,NO,RTNNSKP3) PWA OPERMODE FLAG ON */
**/*OMODCK: D (YES,,NO,F) PWA OPERMODE FLAG ON */
**/*OMODCK2: D (NO,F,YES,) RSVWD PROMPT BIT ON */
**/* P TURN ON PWA PFNOPOP FLAG */
**/* S (+0,NOPRMT,+4,) SKIPB: SKIP TO END OF PROMPT BUFFER */
**/* P (,IPA) TURN OFF PWA PFNOPOP FLAG */
**/*NOPRMT: P TURN OFF PWA PFNOPOP FLAG */
**/* P (,F) XINPUTB = RSVWDSV1 +1 */
**/*RTN0: P XINPUT = RSVWDSV1 */
**/*RTNO0: P (,RTNC) I = 0 */
**/*RTN4: P I = 4 */
**/*RTNC: P XPCE = RSVWDSV2 */
**/* R RETURN ON ADDR IN CBLNKSV1 + I */
**/*RTNCLNUP: P SET RETCODE = 24 */
**/* S @EL01: FREE TEMP STORAGE */
**/* R ISSUE RETURN CODE 24 - GOTO CLEANUP */
**/*RTNNSKP3: P TURN OFF PWA COBOLMOD FLAG */
**/* S @EL01: FREE TEMP CORE */
**/* R RETURN TO NAMESKP3 IN IKJEFP00 */
**/* E FREECORE */
**/* P GOREGSV = LINKA */
**/* P REG0 = RSVWD LENGTH COUNT */
**/* P REG1 = XINPUTB */
**/* P ISSUE FREEMAIN */
**/* P LINKA = GOREGSV */
**/* R RETURN */
**/* E TERMOCK */
**/* P GOREGSV = LINKA */
**/* D (YES,,NO,RTNCLNUP) XPCE POINTS TO TERM PCE */
**/* D (NO,,YES,RTNCLNUP) LIST SPECIFIED IN TERM PCE */
**/* D (NO,,YES,RTNCLNUP) RANGE SPECIFIED IN TERM PCE */
**/* D (YES,,NO,RTNCLNUP) XPCE > PRIORPCE */
**/* P PRIORPCE = XPCE */
**/* P LINKA = GOREGSV */
**/* R RETURN TO CALLER */
**/*CSDPARSE: END */
**/*IKJEFP60: CHART  */
**/* HEADER
**/*SEPTEMBER 24,1971                                   PAGE #
**/*FLOWCHART FOR TERM PCE PROCESSING
**/*PARSE SUPPORT FOR COBOL SYMBOLIC DEBUG              SDD POK. */
**/*IKJEFP6I: E BEGIN TERM PROCESSING */
**/*INITIAL: P TURN PRMTSCAN OFF */
**/* P TURN ON THE COBOL SWITCH (COBOLMOD) */
**/* P TURN OFF RC16 BIT */
**/* P SET PREVPDEL AND PFENDSET TO ZERO */
**/* P SET PDEPTR TO THE TEMP PDE IN THE WORK AREA */
**/*SAVELNK1: P SAVE LINK1 IN CBLNKSV1 */
**/* P SAVE XPCE IN TERMXPCE */
**/* S SKIPB: SKIP OVER ANY SEPARATORS */
**/* COMMENT (1,15) LINK2 */
**/*SKRETURN: D (+0,PROMPT01,+4,OPER) DETERMINE RETURN TYPE */
**/*PROMPT01: S PROMPTQ0: DETERMINE IF THE PARM IS OPTIONAL */
**/* COMMENT (1,15) LINK1 */
**/*PROMPRN: D (+0,OPER,+4,NTRQEXIT) +4 NOTREQD +0 NEW DATA RTD */
**/*OPER1: P TURN PRMTSCAN ON */
**/* COMMENT (1,15) RETURN HERE */
**/* COMMENT (2,15) DATA RTRND */
**/* COMMENT (3,15) FRM PROMPT */
**/*OPER: D (YES,PDESIZ,NO,CKLIST) IS THIS IN OPER MODE?  */
**/*CKLIST: S LISTT: SET UP FOR LIST PROCESSING IF NEEDED */
**/* COMMENT (1,15) LINK1 */
**/* D (+0,CODE4,+4,) DETERMINE RETURN TYPE */
**/*PDESIZ: D (YES,LNGTH79,NO,) IS THE PCE SUBSCRIPT BIT ON ? */
**/* P SET PPCOUNT = 19 */
**/*INVPSAV: D (YES,CKBLNK,NO,INPUTUP) RANGEVAL1 ON? */
**/*CKBLNK: P SET UP FOR SEPARATOR CHECK - '09' MASK */
**/* S TYPETEST: */
**/* D (YES,,NO,INVPSAV1) SEPARATOR? */
**/* P SET ERROR BIT ON */
**/* P SET PFNOPOP ON */
**/* S RANGE: */
**/* COMMENT (1,15) RETURN WILL */
**/* COMMENT (2,15) ALWAYS BE 0 */
**/* P XINPUT = XINPUT + 1 */
**/* E () EXIT TO EXIT IN VARIABLE */
**/*INPUTUP: P XINPUT = XINPUT+1 */
**/*INVPSAV1: P INVPSAVE = XINPUT */
**/* P PRMTPTR = XINPUT */
**/*PCETYPE: D (STMT,STMTRTN,CNST,CONSTRTN,VAR,VARRTN,ANY,CONSTRTN)
**/*BRANCH ON THE PCE TYPE */
**/*NEXTPCE: R EXIT TO UPDTEPCE IN VARIABLE RTN */
**/*CODE4: R EXIT TO CODE4 IN VARIABLE RTN */
**/*LNGTH79: P (,INVPSAV) SET PPCOUNT = 79 */
**/*OPERTEST: E ENTRY FROM PRMT RETURN */
**/* P XPCE = TERMXPCE */
**/* D (NO,OPER,YES,) PFLAGS3 PFNULL ON? */
**/* P (,NTRQEXIT) TURN OFF PFNULL */
**/* COMMENT (1,15) NULL LINE */
**/* COMMENT (2,15) RETURNED */
**/*NTRQEXIT: D (YES,,NO,NEXTPCE) IS OPERMODE ON ? */
**/* P RESTORE LINK1 FROM CBLNKSV1 */
**/* R RETURN TO OPER ON LINK1+0 */
**/*IKJEFP60: END END OF THIS CHART */
**/*STATEMNT: CHART */
**/* HEADER
**/*SEPTEMBER 24,1971                       PAGE #
**/*FLOWCHART FOR STATEMENT SUBROUTINE
**/*PARSE SUPPORT FOR COBOL SYMBOLIC DEBUG  SDD POK */
**/*IKJEFP6I: E BEGIN STMT PROCESSING */
**/* D (YES,,NO,CONT) OPERMODE BIT ON? */
**/* D (YES,CONT,NO,) CHAINTRM BIT ON? */
**/* R () EXIT TO CODE24 IN VARIABLE */
**/*CONT: S TYPETEST: CHECK FOR ALPHA CHAR MASK= X'C0' (LINK1) */
**/* D (+4,STRPGMID,+0,STRINPTR) +4=ALPHA +0=NON ALPHA */
**/*STRINPTR: P STORE XINPUT AS THE LINE # PTR IN THE PDE */
**/* S TYPETEST: CHECK FOR A NUMERIC MASK= X'10' (LINK1) */
**/*NUMCK1: D (+4,ADDCTR1,+0,) +4=NUMERIC +0=NON NUMERIC */
**/*MAXLNGTH: D (YES,SEPSCAN,NO,) IS  DIGITCT > 6 ? */
**/* D (YES,LISTEST,NO,) XINPUT = INVPSAVE ?*/
**/* D (YES,SEPSCAN,NO,) XINPUT = LINE # PTR IN THE PDE ? */
**/*STRLINSZ: P STORE  DIGITCT AS THE LINE SIZE  IN THE PDE */
**/* P ZERO DIGITCT  */
**/* D (YES,BUMP1,NO,RANGECK) IS THIS A PERIOD ? */
**/*RANGECK: S RANGE: SET UP  RANGE PROCESSING IF PRESENT (LINK1)*/
**/* D (+0,,+4,COMPDE01) DETERMINE RETURN TYPE */
**/* D (YES,SEPSCAN,NO,) IS RANGVAL1 BIT ON ? */
**/* D (YES,COMPDE01,NO,SEPCK01) IS RANGVAL2 BIT ON ? */
**/*STRPGMID: P STORE XINPUT AS THE PGM ID PTR IN THE PDE */
**/*ADDCTR2: P ADD ONE TO  DIGITCT */
**/* P XINPUT = XINPUT+1 */
**/* D (YES,ERREXIT,NO,) IS THIS A ; ? */
**/* D (YES,ERREXIT,NO,) XINPUT = ENDINPUT ? */
**/* S TYPETEST: CHECK FOR ALPHAMERIC MASK=X'D0' LINK1 */
**/* D (+4,ADDCTR2,+0,) +4 = ALPHAMERIC +0=NON ALPHAMERIC */
**/* D (YES,SEPSCAN,NO,) IS  DIGITCT > 8 ? */
**/* D (YES,,NO,SEPSCAN) IS THIS A PERIOD ? */
**/* P STORE DIGITCT AS THE PGM ID LENGTH IN THE PDE  */
**/* P ZERO DIGITCT */
**/* P XINPUT = XINPUT+1 */
**/* D (YES,ERREXIT,NO,) IS THIS A ; ? */
**/* D (YES,ERREXIT,NO,STRINPTR) DOES XINPUT = ENDINPUT ? */
**/*ADDCTR1: P ADD ONE TO  DIGITCT */
**/* P XINPUT = XINPUT+1 */
**/* D (YES,MAXLNGTH,NO,) XINPUT = ENDINPUT ? */
**/* D (YES,MAXLNGTH,NO,NUMCK1) IS THIS A ; ? */
**/*BUMP1: P XINPUT = XINPUT+1 */
**/* D (YES,ERREXIT,NO,) IS THIS A ; ? */
**/* D (YES,ERREXIT,NO,) XINPUT = ENDINPUT ? */
**/* S TYPETEST: CHECK FOR NUMERIC MASK= X'10' (LINK1)*/
**/* D (+4,,+0,SEPSCAN) +4=NUMERIC +0=NON NUMERIC */
**/* P PDE VERB PTR = XINPUT ; PDE VERB LENGTH = 1 */
**/* P (,RANGECK) XINPUT = XINPUT+1 */
**/*SEPSCAN: S TYPETEST: CHECK FOR A SEPARATOR MASK= X'09' (LINK1)*/
**/* D (+4,SEPFOUND,+0,) +4=SEPARATOR +0=NON SEP */
**/* D (YES,SEPFOUND,NO,) DOES XINPUT = ENDINPUT */
**/* D (YES,SEPFOUND,NO,) IS THIS A ; ? */
**/* P (,SEPSCAN) XINPUT=XINPUT+1 */
**/*SEPFOUND: P XINPUTB = XINPUT */
**/* D (YES,,NO,ERREXIT) IS PFLIST BIT ON ? */
**/* D (YES,,NO,ERREXIT) IS XINPUT-1 = ) ? */
**/* P (,ERREXIT) XINPUTB = XINPUTB-1 */
**/*ERREXIT: P SET  DIGITCT TO ZERO */
**/* S CODE4B: PROMPT THRU CODE4B RTN IN VARIABLE */
**/* R () EXIT TO CODE4B */
**/*COMPDE01: P SET PARM BIT IN PDE ; SET STMT BIT IN PDE*/
**/* P R1 = PPCOUNT */
**/* P PPOINTR = INVPSAVE */
**/* P PLENGTH = XINPUT - PPOINTR */
**/* S TRANSQ: VIA R15  XLATE TO UPPER CASE IF REQD (LINK1)*/
**/* R EXIT VIA VARIABLE RTN AT EXIT1 */
**/*SEPCK01: S TYPETEST: CHECK FOR A SEPARATOR MASK= X'09' (LINK1)*/
**/* D (+4,COMPDE01,+0,) +4=SEPARATOR +0=NON SEP */
**/* D (YES,COMPDE01,NO,) IS THIS A ; ? */
**/* D (YES,COMPDE01,NO,) DOES XINPUT = ENDINPUT ? */
**/*PARNTEST: D (YES,,NO,SEPSCAN) IS THIS CHARACTER A ) ? */
**/* D (YES,,NO,SEPSCAN) IS THIS A LIST ? */
**/* P (,COMPDE01) XINPUT = XINPUT-1 */
**/* E BEGIN BUMP */
**/* P XINPUT = XINPUT+1 */
**/* D (YES,POPSTACK,NO,RETURN) IS XINPUT => ENDINPUT ? */
**/*PTRBUMP: P SET XINPUT = XINPUT+1 */
**/*RETURN: R RETURN ON LINK2 + 4  MORE DATA */
**/*POPSTACK: S SCANF: POP THE STACK IF MORE DATA (LINK1)*/
**/* D (+4,PTRBUMP,+0,) +4 = MORE DATA +0 = END */
**/* R RETURN ON LINK2 +0 NO MORE DATA */
**/*LISTEST: D (YES,SEPSCAN,NO,) IS THE PFLIST BIT ON ? */
**/* D (YES,SEPSCAN,NO,) IS THE RANGVAL1 BIT ON ? */
**/*PROMPT05: R EXIT TO PROMPT05 IN CONSTANT RTN */
**/*STATEMNT: END END OF THIS CHART */
**/*CONSTANT: CHART */
**/* HEADER
**/*SEPTEMBER 24,1971                       PAGE #
**/*FLOWCHART FOR CONSTANT PROCESSING
**/*PARSE SUPPORT FOR COBOL DEBUG           SDD POK */
**/*IKJEFP6C: E BEGIN CONSTANT PROCESSING */
**/*SUBTEST: D (YES,CBUMP01,NO,) IS SUBSMODE BIT ON ? */
**/*STPDEPTR: P SET PDEPTR TO THE TEMP PDE IN WORK AREA */
**/* P (,ENDTEST) PRMTPTR=XINPUT; */
**/*ALPHATST: S TYPETEST: CHECK FOR ALPHA MASK='C0' (LINK1)*/
**/* D (+4,RSVWDPC,+0,) +4=ALPHA +0=NON ALPHA */
**/*CHKQUOT: D (YES,QSTRING1,NO,) IS THE FIRST CHARACTER A QUOTE ? */
**/* D (YES,SETMINUS,NO,SETPLUS) IS THE FIRST CHARACTER A - ? */
**/*SUBTEST1: D (YES,CODE4,NO,) IS THIS SUBSMODE? */
**/*PCEUPDTE: P UPDATE  TO NEXT PCE */
**/* P TURN COBOLMOD SWITCH OFF */
**/* R () EXIT TO NEXTPCE ROUTINE */
**/*SETPLUS: P SET THE PLUS INDICATOR IN THE PDE */
**/* D (YES,CBUMP02,NO,) IS THE FIRST CHARACTER A + ? */
**/*PERIODCK: D (YES,PPDSCAN,NO,) IS THIS CHARACTER A PERIOD ? */
**/* S TYPETEST: CHECK FOR NUMERIC MASK= X'10' (LINK1)*/
**/* D (+4,PREPDSCN,+0,) +4=NUMERIC +0=NON NUMERIC */
**/*ZERTEMP: D (YES,CODE4,NO,) 'CONST' BIT ON IN PDE ? */
**/* P ZERO THE TEMP PDE POINTED TO BY PDEPTR */
**/*PARMTEST: D (YES,GOTOVAR,NO,PROMPT05) IS THE PARAMETER TYPE ANY? */
**/*PROMPT05: D (YES,CODE4,NO,)  IS THE PFLIST BIT ON ? */
**/* D (YES,CODE4,NO,) IS SUBSMODE BIT ON ? */
**/* D (NO,CODE4,YES,) DOES XINPUT = INVPSAVE? */
**/* D (YES,CODE4,NO,PROMPT) IS PRMTSCAN ON? */
**/* COMMENT (1,15) SCANNING A */
**/* COMMENT (2,15) PROMPT */
**/* COMMENT (3,15) RESPONSE? */
**/*PROMPT: S PROMPTQ0: IS PARAMETER REQUIRED ? (LINK1)*/
**/* D (REQ,STRPTR,NTRQ,) WAS THE CONSTANT REQUIRED ? */
**/*NTRQEXIT: D (YES,CODE4,NO,) IS OPERMODE BIT ON ? */
**/* P XINPUT = XINPUT-ONE */
**/*R () EXIT TO PCEUPDTE RTN IN VARIABLE */
**/*RSVWDPC: D (YES,,NO,PARMTEST) IS THERE A RESERVED WORD PCE ? */
**/* P XINPUT = XINPUT-1  FOR RSVWD PROCESSING */
**/* S RSVWD: PROCESS AS A RESERVED WORD LINK1*/
**/* D (YES,FIGCONST,NO,) WAS THERE A RESERVED WORD ? */
**/* P (,PARMTEST) XINPUT = XINPUT+1 */
**/*FIGCONST: P (,DATAEND) SET THE FIGURATIVE CONSTANT BIT */
**/*QSTRING1: S QSTRING: PROCESS AS A QUOTED STRING (LINK2) */
**/* D (YES,,NO,CODE4) WAS THERE A VALID QSTRING ? */
**/* D (YES,,NO,LNGTCHK) XINPUT LEFT AT ENDING QUOTE? */
**/* P XINPUT=XINPUT+ONE */
**/*LNGTCHK: D (YES,CODE4,NO,) WAS THE LENGTH > 120 ? */
**/* P STORE PPOINTR AS QSTRING PTR IN THE PDE */
**/* P STORE PLENGTH AS THE QSTRING LENGTH */
**/* P SET NON NUMERIC LITERAL BIT IN PDE */
**/* P SET  QSTRING BIT IN THE PDE */
**/* P XINPUTB = XINPUT USE 15 AS B REG */
**/* S (,DATAEND) TRANSQ: TRANSLATE TO UPPER CASE IF REQD (LINK1)*/
**/*PREPDSCN: P STORE XINPUT INTO THE PDE AS DIGIT STRING PTR */
**/*ADDCOUNT: P ADD ONE TO DIGITCT */
**/* P XINPUT = XINPUT+1 */
**/* D (YES,MAXDIGIT,NO,) IS THIS A ; ? */
**/* D (YES,MAXDIGIT,NO,) DOES XINPUT = ENDINPUT ? */
**/* S TYPETEST: CHECK FOR NUMERIC MASK = X'10' (LINK1) */
**/* D (+4,ADDCOUNT,+0,) +4 = NUMERIC +0 = NON NUMERIC */
**/* D (YES,PPDSCAN,NO,) IS THIS CHARACTER A PERIOD ? */
**/*SEPTEST: S TYPETEST: LINK1 - CHECK FOR A SEPARATOR - X'09' */
**/* D (YES,MAXDIGIT,NO,) +4 - SEPARATOR +0 - NON SEPARATOR */
**/*LSTCHK: D (YES,MAXDIGIT,NO,) IS THIS A ) ? */
**/* D (YES,,NO,VARTEST) IS THIS A : */
**/* D (YES,CODE4,NO,MAXDIGIT) IS SUBSMODE BIT ON? */
**/*MAXDIGIT: D (YES,CODE4,NO,) IS DIGITCT > 18 ? */
**/* P (,ENDPDE) STORE DIGITCT IN PDE  ZERO DIGITCT */
**/*VARTEST: S TYPETEST: CHECK FOR ALPHA MASK = X'C0' (LINK1)*/
**/* D (+4,,+0,CODE4) +4 ALPHA +0 NON ALPHA */
**/* D (YES,,NO,CODE4) TYPE = ANY ? */
**/*GOTOVAR: P XINPUT = PRMTPTR-1,  XINPUTB = PRMTPTR */
**/* P ADD 1 TO ELEMNCT */
**/* P ZERO THE PDE */
**/* R EXIT TO VARIABLE */
**/*CBUMP01: D (YES,ENDTEST,NO,) IS ERRORBIT ON? */
**/* P PRMTPTR = XINPUT */
**/*ENDTEST: D (YES,CODE4,NO,) DOES XINPUT = ENDINPUT ? */
**/* D (YES,CODE4,NO,) IS THIS A ; ? */
**/*SUBENDCK: D (YES,SETERBIT,NO,) IS THE ELEMNTCT = 3 ? */
**/* P (,ALPHATST) PDEPTR = PDEPTR+20 UPDATE TO NEXT PDE */
**/*SETERBIT: P  SET THE ERROR BIT, SET PFNOPOP */
**/* R () EXIT TO SUBERSCN IN VARIABLE */
**/*SETMINUS: P SET THE MINUS SIGN INDICATOR IN THE PDE */
**/*CBUMP02: P XINPUT = XINPUT+1 */
**/* D (YES,CODE4,NO,) IS THIS A ; ? */
**/* D (YES,CODE4,NO,) DOES XINPUT = ENDINPUT ? */
**/* P (,PERIODCK) SET 'CONST' BIT IN PDE */
**/*STRPTR: P TURN PRMTSCAN ON */
**/* R () EXIT TO INPUTUP */
**/* COMMENT (1,15) IN TERM */
**/* COMMENT (2,15) INITIALIZTN */
**/*PPDSCAN: P STORE XINPUT AS THE ADDRESS OF THE PERIOD IN THE PDE */
**/* D (YES,CODE4,NO,) DECPT FLAG ON IN PDE ? */
**/* P TURN ON DECPT FLAG (3RD BIT - FLAG2) */
**/*CBUMP04: P XINPUT = XINPUT+1 */
**/* D (YES,NUMER,NO,) NUMERIC ? */
**/* COMMENT (1,15) TYPETEST */
**/* COMMENT (2,15) MASK = '10' */
**/*ETEST1: D (NO,CODE4,YES,ETEST) CAP OR SMALL E ? */
**/*NUMER: P ADD 1 TO DIGITCT */
**/* P XINPUT = XINPUT + 1 */
**/* S TYPETEST: NUMERIC MASK = '10' */
**/* D (YES,NUMER,NO,) NUMERIC ? */
**/*ETEST: D (YES,,NO,%ENDTEST) IS THIS CHARACTER AN E ? */
**/*EFOUND: P SET FLOATING POINT FLAG IN PDE */
**/* D (YES,CODE4,NO,) IS THE DIGIT COUNT > 16 ? */
**/* P STORE DIGITCT AS LNGTH-1 IN THE PDE, ZERO DIGITCT */
**/* D (NO,CODE4,YES,) IS DEC PT FLAG ON IN TEMPPDE? */
**/* P XINPUT = XINPUT+1 */
**/* D (YES,CODE4,NO,) DOES XINPUT = ENDINPUT ? */
**/* D (YES,CODE4,NO,) IS THIS A ; ? */
**/* D (YES,MINUSEXP,NO,) IS THIS A MINUS SIGN ? */
**/* P SET THE PLUS EXPONENT BIT IN THE PDE */
**/* D (YES,CBUMP03,NO,) IS THIS A PLUS SIGN ? */
**/*NUMCK: S TYPETEST: CHECK FOR NUMERIC MASK = X'10' LINK1 */
**/* D (+4,,+0,CODE4) +4 NUMERIC, +0 NONNUMERIC */
**/* P (,ADCT01) STORE XINPUT AS PTR TO EXPONENT (+12 - DATAPTRA) */
**/*%ENDTEST: D (YES,,NO,SEMCHK) IS THIS A SMALL LETTER E ? */
**/* D (YES,,NO,EFOUND) IS UPPER CASE REQD ? */
**/* D (YES,EFOUND,NO,) IS PFDEFLT ON ? */
**/*SEMCHK: D (YES,MAXDIGIT,NO,) DOES XINPUT POINT TO A ; ? */
**/* D (YES,MAXDIGIT,NO,) XINPUT = ENDINPUT */
**/* S TYPETEST: CHECK FOR NUMERIC */
**/* D (+0,PERCHK,+4,ADDCOUNT) NUMERIC? */
**/*PERCHK: D (YES,PPDSCAN,NO,SEPTEST) XINPUT = PERIOD */
**/* P (,EFOUND) TRANSLATE TO UPPER CASE */
**/*MINUSEXP: P SET THE MINUS EXPONENT BIT */
**/*CBUMP03: P XINPUT = XINPUT+1 */
**/* D (YES,CODE4,NO,) IS THIS A ;? */
**/* D (YES,CODE4,NO,NUMCK) DOES XINPUT = ENDINPUT ? */
**/*ADCT01: P ADD ONE TO THE DIGIT COUNTER */
**/* P XINPUT = XINPUT+1 */
**/* D (YES,VALEXP,NO,) IS THIS A ; ? */
**/* D (YES,VALEXP,NO,) DOES XINPUT = ENDINPUT ? */
**/* S TYPETEST: CHECK FOR NUMERIC MASK = X'10' LINK1 */
**/* D (+4,ADCT01,+0,) +4 - NUMERIC +0 NON NUMERIC */
**/*TSEP: S TYPETEST: LINK1 CHECK FOR SEPARATOR MASK X '09' (LINK1)*/
**/* COMMENT (1,15) CHECK FOR */
**/* COMMENT (2,15) DELIMITER */
**/* D (+4,VALEXP,+0,) +4 SEPARATOR +0 NON SEPARATOR */
**/*PARTTST: D (YES,VALEXP,NO,) IS THIS A ) ? */
**/* D (YES,,NO,CODE4) IS THIS A : ? */
**/* D (YES,CODE4,NO,VALEXP) IS SUBSMODE BIT ON? */
**/*VALEXP: D (YES,CODE4,NO,) IS THE DIGIT COUNT > 2 ? */
**/* P ADD DIGITCT AS EXP LENGTH LNGTH-2 TO PDE*/
**/* P ZERO THE DIGITCT */
**/*DATAEND: D (YES,ADELCT,NO,) IS SUBSMODE BIT ON? */
**/* D (YES,LISTCK,NO,) IS THIS CHARACTER A ) ? */
**/* S RANGE: */
**/* D (+4,,+0,SEP) RETURN ? */
**/* P (,PDESIZE) SET UP MSGADDR + MSGLEN FOR SPEC MSG */
**/*SEP: S TYPETEST: CHECK FOR SEPARATOR MASK X'09' (LINK1) */
**/* D (+4,PDESIZE,+0,TESTCOL) +4 SEPARATOR +0 NON SEPARATOR */
**/* COMMENT (1,15) IS THIS A */
**/* COMMENT (2,15) SEP */
**/* COMMENT (3,15) OR EOB */
**/*TESTCOL: D (YES,PDESIZE,NO,) IS THIS A ; ? */
**/* D (YES,PDESIZE,NO,CODE4) DOES XINPUT = ENDINPUT? */
**/*LISTCK: D (YES,BACKXIN,NO,) IS THE PFLIST BIT ON ? */
**/* D (YES,PDESIZE,NO,CODE4) IS OPERMODE BIT ON? */
**/*BACKXIN: S RANGE: GET RANGE SWITCHES SET PROPERLY */
**/* P XINPUT = XINPUT - 1 */
**/*PDESIZE: P (,TESTERR) TURN ON CONST AND PARM PRESENT BITS IN PDE*/
**/*ADELCT: P ADD ONE TO ELEMNTCT */
**/* P SET CONST AND PARM PRESENT BITS IN PDE */
**/* P DECRIMENT XINPUT BY ONE FOR SKIPB */
**/* S SKIPB: SKIP OVER ANY SEPARATORS LINK2 */
**/* D (MORE,,END,ENDSUB) DETERMINE TYPE RETURN */
**/* COMMENT (1,15) +4 - MORE DATA */
**/* COMMENT (2,15) +0 - END OF BUFFER */
**/* P XINPUT = XINPUT+1 */
**/* D (YES,,NO,ENDCMDCK) IS THIS A ) ? */
**/*SUBEXIT: R EXIT TO VSUBENDCK IN VARIABLE RTN */
**/*ENDCMDCK: D (YES,,NO,SETPRMT) IS THIS A ; ? */
**/* P (,ENDSUB) XINPUT = XINPUT-1 */
**/*SETPRMT: P (,SUBENDCK) PRMTPTR = XINPUT */
**/*ENDPDE: P (,DATAEND)  SET FIXED PT LITRL BIT IN THE PDE?*/
**/*ENDSUB: P PPOINTR = INVPSAVE */
**/* S (,SUBEXIT) PSTRIMSG: PUT OUT ENDING ) ASSUMED MESSAGE LINK2*/
**/*TESTERR: R GO TO EXIT IN VARIABLE ROUTINE */
**/*CODE4: R () EXIT TO VERRBIT IN VARIABLE */
**/*CONSTANT: END END OF THIS CHART */
**/*VARIABLE: CHART (FMODE)*/
**/* HEADER
**/*JANUARY 10, 1971                           PAGE #
**/*FLOWCHART FOR VARIABLE SUBROUTINE
**/*PARSE SUPPORT FOR COBOL SYMBOLIC DEBUG SDD POK */
**/*IKJEFP6V:1A1 E BEGIN VARIABLE PROCESSING */
**/*TERMBEG:1B1 P SET VARIA BIT IN PDE */
**/*1B2 D (YES,SCAN,NO,) SUBSMODE ON? */
**/*1B3 D (NO,SCAN,YES,) RNGEVAL1 ON? */
**/*1B4 P FIRSTNAM='1'B */
**/*SCAN:1C2 P PPOINTR=XINPUT */
**/*1C1 S GENSCAN: ALPHA ALPHAMERIC - PGMID */
**/*1D1 D (YES,,NO,NOPGMID) RETURN AT +12? */
**/*1D2 D (YES,,NO,NOPGMID) IS CHAR A . ? */
**/*1D3 P PGMID PTR IN PDE = PPOINTR */
**/*1D4 P PLENGTH = XINPUT-PPOINTR */
**/*1D5 P PDELEN2 = PLENGTH */
**/*1E5 D (NO,FIRSTON,NO,) SUBSMODE ON? */
**/*1F5 P PRMTPTR = PPOINTR */
**/*FIRSTON:1G5 D (NO,TRANS,YES,) FIRSTNAM ON? */
**/*1H5 P MSGADDR=PPOINTR; MSGLEN = PLENGTH */
**/*1G4 S TRANSQ: TRANSLATE PGMID TO UPPERCASE */
**/*1E4 P SET NAMEREQD BIT ON */
**/*1E3 P XINPUT = XINPUT+1 */
**/*1E2 P  PPOINTR =XINPUT */
**/* COMMENT (1,15) PREPARE FOR */
**/* COMMENT (2,15) VARIABLE SCAN */
**/*1F2 P (,NAMSCAN) PRMTPTR=INVPSAVE */
**/*NOPGMID:1E1 P XINPUT = PPOINTR, XINPUTB=PPOINTR */
**/*DNAMSCAN:1F1 D (NO,,YES,NAMSCAN) ERRORBIT ON? */
**/*1G1 P PRMTPTR = XINPUT */
**/*NAMSCAN:1H1 S TYPETEST: ALPHAMERIC? */
**/*1J1 D (YES,RSTPTRS,NO,) INVALID 1ST CHAR? */
**/*LOOP:2A1 P LOOP LENGTH 1-30 */
**/*LXINUP:2B1 P XINPUT = XINPUT +1, XINPUTB=XINPUT */
**/*2C1 S TYPETEST: ALPHAMERIC? */
**/*2D1 D (YES,LXINUP,NO,) VALID OTHER CHAR? */
**/*ERRORCHA:2E1 D (YES,LXINUP,NO,) HYPHEN? */
**/*2F1 D (YES,VERRBIT,NO,) LOOP LENGTH > 30? */
**/*RESCAN:2A3 S TYPETEST: SEPARATOR? */
**/*2B3 D (YES,SETPLNGH,NO,) SEPARATOR? */
**/*TPAR:2C3 D (YES,SETPLNGH,NO,) COLON? */
**/*2D3 D (YES,SETPLNGH,NO,) ( ? */
**/*2E3 D (YES,SETPLNGH,NO,) ) ? */
**/*2F3 D (YES,SETPLNGH,NO,) XINPUT => ENDINPUT? */
**/*2G3 D (YES,SETPLNGH,NO,) ; ? */
**/*2H3 P (,VERRBIT) XINPUT = XINPUT + 1 */
**/*SETPLNGH:3A1 P PLENGTH = XINPUT - PPOINTR */
**/*3A2 P XINPUT = PPOINTR */
**/*TSTLOOP:3B2 S TYPETEST: ALPHA */
**/*3C2 D (NO,NOTALPHA,YES,ALPHAFND) ALPHA CHAR? */
**/*NOTALPHA:3C3 D (YES,SETERBT2,NO,) END OF ALPHA SEARCH? */
**/*3C4 P (,TSTLOOP) XINPUT = XINPUT + 1 */
**/*ALPHAFND:3D2 P XINPUT = XINPUTB - 1 */
**/*3E2 D (YES,SETERBT2,NO,) LAST CHAR HYPHEN? */
**/*3F2 D (YES,ENDSCAN,NO,) ERROR BIT ON? */
**/*3G2 D (NO,,YES,CORETEST) QUALCT NON ZERO? */
**/*ADDNAME:3H2 S TRANSQ: */
**/*3H1 P PDE NAME PTR = PPOINTR */
**/*3J1 P SET PARM PRES BIT IN PDE */
**/*3K1 P PDE LENG-1 = PLENGTH */
**/*3J2 P QUALIF NAME PRT = FF000000 */
**/*3J3 P CHAINPTR = ADDR ON QUALIFIER PDE PTR */
**/*3K3 D (NO,ENDSCAN,YES,) FIRSTNAM ON? */
**/*3K4 P FIRSTNAM='0' */
**/*3J4 D (NO,,YES,PGMID) NAMEREQD ON? */
**/*3J5 P (,ENDSCAN) MSGADDR=PPOINTR, MSGLEN=PLENGTH */
**/*PGMID:3H4 P (,ENDSCAN) MSGLEN=LENGTH OF PGMID+LENGTH OF DATANAME */
**/*SETERBT2:3E3 P SET ERROBIT SET PFNOPOP */
**/*ENDSCAN:3E4 P ENDNMPTR = XINPUT */
**/* COMMENT (1,15) SAVE END OF */
**/* COMMENT (2,15) DATA NAME */
**/*4A1 S BUMP: BUMP XINPUT BY 1 */
**/*4B1 D (MORE,,END,ENDCK) EOB ? */
**/*4A2 D (YES,XINUP2,NO,) WAS STACK POPPED? */
**/*MORDTA:4B2 S TYPETEST: SEPARATOR */
**/*4B3 D (NO,GDDNNBL,YES,) DELIM A SEPARATOR? */
**/* COMMENT (1,15) SEP AFTER DATA */
**/* COMMENT (2,15) NAME - SPECIAL */
**/* COMMENT (3,15) PROCESSING */
**/*VSEPSKIP:4C3 S SKIPB: */
**/*4D3 D (NO,XINUP2,YES,) END OF DATA? */
**/*ENDCK:4E1 D (NO,RANGESET,YES,) SUBSMODE? */
**/*4E2 R () EXIT TO ENDSUB IN CONSTANT */
**/*RANGESET:4F1 S RANGE: GET RNGEVAL2 ON IF REQUIRED */
**/*EXIT:4G1 D (YES,CODE4,NO,) ERROR BIT ON? */
**/*EXITA:4H1 D (YES,,NO,ZEROQLCT) QUALCT > 256? */
**/*4H2 P (,PRMTEXT) TURN ERROR BIT AND PFNOPOP ON */
**/*ZEROQLCT:5A1 D (YES,SKPQLST,NO,) IS THIS CONST OR STATE PDE? */
**/*5B1 P PDE QUALCT = QUALCT */
**/*5C1 P ZERO QUALCT */
**/*SETPCE:5D1 P SET PCE PTR TO MAJOR PCE */
**/*SKPQLST:5E1 P SET PDEPTR = ADDR OF TEMPDE */
**/*5F1 D (NO,VAREXITA,YES,) OPERMODE ON? */
**/*5G1 D (NO,VAREXITA,YES,) PRMTSCAN ON? */
**/*5G2 D (YES,VAREXITA,NO,) PFENDSET ON? */
**/*5G3 P PFNOPOP = '1' */
**/*5G4 S SKIPB: */
**/*5H4 D (NO,VAREXITA,YES,) MORE DATA? */
**/*5H5 P (,CODE4) ERRORBIT = '1' */
**/*VAREXITA:5H1 P R1 = PDE LENGTH */
**/*5J1 D (YES,CODE4,NO,) PFENDF ON? */
**/*5K1 P (,CODE4) XINPUTB = XINPUT */
**/*XINUP2:8A1 P XINPUT = XINPUT + 1 */
**/*8B1 P MOVE 2 BYTES TO TRANAREA */
**/*8B2 S TRANSQ: TRANSLATE TO UPPERCASE */
**/*8C1 D (NO,ASIS,YES,TRANSLAT) IN OR OF? */
**/*TRANSLAT:8D1 D (NO,XINUP3,YES,) UPPERCASE REQUESTED? */
**/*8E1 D (YES,XINUP3,NO,) PFDEFLT ON? */
**/*8F1 P MOVE UPPERCASE TO BUFFER */
**/*XINUP3:8G1 P XINPUT = XINPUT + 1 */
**/*8H1 S BUMP: INCREMENT XINPUT */
**/*8H2 D (YES,VSEPSK1,NO,) EOB? */
**/*BLNKTEST:8J2 S TYPETEST: SEPARATOR */
**/*8J3 D (YES,VSEPSK1,NO,) SEPARATOR? */
**/*ENDNAME:8J4 D (YES,,NO,RSTREXIN) PFENDSET ON? */
**/*8H5 P XINPUT = XINPUT - 3 */
**/*8J5 S PUSHI: PUSH IN OR OF... ON STACK */
**/*8K5 P ENDINPUT = ENDBAKUP */
**/* COMMENT (1,15) MUST SAVE IN.. */
**/* COMMENT (2,15) OR OF... */
**/*RSTREXIN:8K4 P (,ZEROQLCT) XINPUT = ENDNMPTR + 1 */
**/*VSEPSK1:8A3 S SKIPB: */
**/*8B3 D (YES,SETER,NO,) EOB ? */
**/*8C3 P XINPUT = XINPUT + 1 */
**/*8D3 P (,DNAMSCAN) SET NAMEREQD , ADD 1 TO QUALIF COUNT */
**/*SETER:8B4 D (YES,,NO,ERROR1) PFENDSET ON? */
**/*8B5 P XINPUT=ENDBAKUP; ENDINPUT=ENDBAKUP */
**/*ERROR1:8C4 P TURN ON ERRORBIT AND PFNOPOP */
**/*8C5 P (,CODE4) XINPUT=XINPUT+1*/
**/*GDDNNBL:6A1 D (YES,SUBSCK,NO,) DELIM A ( ? */
**/*6B1 D (YES,,NO,RHTPARCK) IS THIS A ; ? */
**/*6B2 D (NO,RANGESET,YES,) SUBSMODE ? */
**/*6B3 R () ENDCMDCK IN CONSTANT */
**/*RHTPARCK:6D1 D (NO,COLONCK,YES,) IS THIS A ) ? */
**/*6F1 D (YES,SUBENDCK,NO,) SUBSMODE ON ? */
**/*6G1 D (YES,EXIT,NO,) OPERMODE ON ? */
**/*6H1 D (YES,VRNGCK1,NO,VERRBIT) PFLIST BIT ON ? */
**/*COLONCK:6D2 D (YES,VRNGCK1,NO,VERRBIT) IS THIS A : ? */
**/*SUBSCK:7A1 D (YES,SKIPBL2,NO,) PCE SUBSCRIPTABLE ? */
**/*7A2 P (,XINUP) TURN ON ERRORBIT AND PFNOPOP*/
**/*SKIPBL2:7B1 S SKIPB: */
**/*7C1 D (YES,,NO,XINUP4) EOB ? */
**/*SETERR:7C2 P (,VRNGCK1) SET ERRORBIT - PFNOPOP */
**/*7C3 P (,VRNGCK1) XINPUT=XINPUT + ONE */
**/*XINUP4:7D1 P XINPUT = XINPUT + 1 */
**/*7D2 D (YES,SUBSCRPT,NO,) CHAINTRM BIT ON? */
**/*7E1 D (YES,,NO,NOERROR1) ERRORBIT ON? */
**/*7E2 P (,SUBERSCN) TURN SUBSMODE ON */
**/*NOERROR1:7F1 P ADD QUALIFIER COUNT TO PDE */
**/*7G1 P ZERO QUALCT */
**/*7H1 P (,SUBSCRPT) TURN NAMEREQD OFF */
**/*RSTPTRS:18A1 P XINPUT = PPOINTR, XINPUTB = PPOINTR */
**/*18A2 D (NO,FIRSTMIS,YES,) PRMPTSCAN ON? */
**/*18B2 D (YES,INVALPRM,NO,VERRBIT) OPERMODE ? */
**/*FIRSTMIS:18A3 D (YES,VERRBIT,NO,) NAMEREQD BIT ON ? */
**/*18B3 D (YES,VERRBIT,NO,) OPERMOD BIT ON? */
**/*18C3 D (YES,VERRBIT,NO,) PFLIST BIT ON? */
**/*18D3 D (YES,VERRBIT,NO,) RNGEVAL1 ON? */
**/*18E3 D (YES,VERRBIT,NO,) SUBSMODE ON? */
**/*18F3 P TURN PRMTSCAN ON */
**/*18G3 P XINPUT = XINPUT -1 */
**/*18H3 S PROMPTQ0: PROMT FOR MISSING PARM */
**/*18J3 D (NO,UPDTEPCE,YES,) PARM REQUIRED? */
**/*18K3 R () INVPSAVE IN TERM INIT */
**/*CORETEST:19A2 D (YES,GETCORE,NO,) TANC = ENDANC? */
**/*19B2 D (YES,,NO,NEWBLOCK) AANC => ENDANC-240? */
**/*19C2 D (YES,ADDQUALI,NO,) IS AANC < ENDANC? */
**/*NEWBLOCK:19D2 P AANC = ENDANC-240 */
**/*19E2 D (NO,TEQUALSA,YES,) OANC = TANC? */
**/*19F2 P OANC = AANC */
**/*TEQUALSA:19G2 P (,ADDQUALI) SET TANC = AANC */
**/*GETCORE:19A3 S STALOC: 248 BYTE R1 */
**/*19B3 D (YES,,NO,SETANCS) AANC=0  */
**/*19C3 P SET OANC = R1+8 */
**/*19D3 P AANC = R1 + 8 */
**/*SETANCS:19E3 P TANC = R1 + 8 ,ENDANC = R1 + 248 */
**/*ADDQUALI:19B1 P ZERO 12 BYTES FROM TANC */
**/*19C1 S TRANSQ: TRANSLATE NAME */
**/*19D1 P PDE DATA NAME PTR = PPOINTR */
**/*19E1 P PDE LEN-1 = PLENGTH */
**/*19F1 P NEXT QUALIF PTR = FF000000 */
**/*19G1 P ADDR PTD BY CHAINPTR = TANC */
**/*19H1 P CHAINPTR = TANC+8 */
**/*19J1 P (,ENDSCAN) TANC = TANC+12 */
**/*ASIS:9A1 P TURN OFF NAMEREQD */
**/*9B1 D (NO,RHTPRCK,YES,) IS THIS A ( ? */
**/*9C1 D (YES,,NO,SKIPBL3) SUBSMODE ON? */
**/*9C2 P (,SUBERSCN) SET ERRORBIT, PFNOPOP */
**/*SKIPBL3:9D1 S SKIPB: */
**/*9E1 D (NO,XINUP5,YES,) EOB ? */
**/*9E2 D (NO,RESTXIN1,YES,) SUBSCRIPTABLE OPTION IN PCE ? */
**/*9E3 P (,CODE4) SET ERRORBIT,PFNOPOP */
**/*XINUP5:9F1 P XINPUT = XINPUT + 1 */
**/*9G1 P ADD QUALIFIER COUNT OT PDE */
**/*9H1 P ZERO ZUALCT */
**/*9J1 D (NO,,YES,CHNCK1) SUBSCRIPTABLE OPTION IN PCE? */
**/*RESTXIN1:9J2 P XINPUT = ENDNMPTR + 1 */
**/*9J3 D (YES,CODE4,NO,VAREXITA) ERRORBIT ON? */
**/*CHNCK1:9K1 D (NO,SUBSCRPT,YES,) CHAINTRM BIT ON? */
**/*9K2 P (,RESTXIN1) STORE XINPUT IN RSVWDSV1 */
**/*SUBSCRPT:10A1 D (NO,CKERROR,YES,) SUBSMODE BIT ON? */
**/*10A2 P (,SUBERSCN) SET ERROBIT, PFNOPOP */
**/*CKERROR:10B1 D (YES,SUBERSCN,NO,) ERRORBIT ON? */
**/*10C1 P SET SUBSMODE ON */
**/*10D1 P UPDATE PCE TO SUBSCRIPT PCE */
**/*10E1 D (NO,CLNUPEXT,YES,) IS THIS A TERM PCE? */
**/*10F1 D (NO,CLNUPEXT,YES,) IS THIS A SUBSCRIPT PCE? */
**/*10G1 D (YES,,NO,ELCHECK) IS PARM TYPE STATEMENT? */
**/*CLNUPEXT:10F2 R () EXIT RTNCLNUP IN OPER */
**/*RHTPRCK:11A1 D (YES,SUBCTRL2,NO,SUBCTRL1) IS THIS A ) ? */
**/*SUBCTRL2:11B1 D (YES,SUBENDCK,NO,) SUBSMODE ON? */
**/*11C1 D (YES,EXIT,NO,) OPERMODE? */
**/*11D1 D (YES,EXIT,NO,VERRBIT) PFLIST ON? */
**/*SUBCTRL1:11A3 D (NO,,YES,ADDQLCT) SUBSMODE ON? */
**/*11A4 P (,VRNGCK1) XINPUT = ENDNMPTR + 1 */
**/*ADDQLCT:11B3 P PDE QUAL CT = QUALCT */
**/*11C3 P ZERO QLCOUNT */
**/*11D3 P SET NAME REQD BIT */
**/*ELCHECK:11E3 D (YES,ERROR4,NO,) ELEM CT = 3? */
**/*11F3 D (YES,UPELMCT,NO,) PCE PARM TYPE VARIABLE? */
**/*11F4 R () EXIT TO CONSTANT SUBSMODE */
**/*UPELMCT:11G3 P ADD ON TO ELEMNTCT */
**/*11H3 P (,TERMBEG) PDEPTR = PDETPR+20 */
**/*ERROR4:11E4 P (,SUBERSCN) SET ERROBIT + PFNOPOP */
**/*SUBERSCN:12A1 D (YES,SUBENDCK,NO,) IS THIS A )? */
**/*12B1 S BUMP: */
**/*12C1 D (+0,VRNGCK1,+4,SUBERSCN) EOB? */
**/*SUBENDCK:12A2 P XINPUT = XINPUT+ 1 */
**/*12A3 P PDE SUBS CT = ELEMNCT */
**/* COMMENT (1,15) IN PDE BASED */
**/* COMMENT (2,15) ON TEMPDE */
**/*12B3 P RESET ELEMNCT TO 0 */
**/*12C3 P NAMEREQD BIT OFF */
**/*VRNGCK1:12D3 S RANGE: CHECK FOR RANGE */
**/*12E3 D (+4,VALRANGE,+0,) RETURN */
**/*12F3 D (NO,EXIT,YES,) RNGEVAL1 ON? */
**/*RANGERR:12F4 P SET ERRORBIT AND PFNOPOP */
**/*12F5 R () INVPSAVE IN TERM INIT */
**/*VALRANGE:12E2 D (NO,EXITA,YES,TERMBEG) IS ERRORBIT ON? */
**/*VERRBIT:13A1 P TURN ON ERRORBIT AND PFNOPOP */
**/*13A2 D (YES,SUBERSCN,NO,) SUBSMODE ON? */
**/*SEPTEST:13A3 S TYPETEST: SEPARATOR */
**/*13B3 D (YES,,NO,RTPARCK2) SEPARATOR? */
**/*13B4 P (,ENDSCAN) XINPUT = XINPUT - 1 */
**/*RTPARCK2:13C3 D (YES,,NO,EOBCK) RIGHT PAREN? */
**/*13C4 D (YES,XINUP6,NO,) PFLIST ON? */
**/*13D4 D (YES,,NO,XINUP) OPERMODE ON? */
**/*XINUP6:13C5 P XINPUT = XINPUT + 1 */
**/*13D5 S TYPETEST: SEPARATOR */
**/*13E5 D (YES,XINBACK,NO,) SEPARATOR? */
**/*13F5 D (YES,XINBACK,NO,) ENDINPUT? */
**/*13G5 D (YES,XINBACK,NO,XINUP) ; ? */
**/*XINBACK:13F4 P (,CODE4) XINPUT = XINPUT - 1 */
**/*EOBCK:13D3 D (YES,CODE4,NO,) ENDINPUT? */
**/*13E3 D (YES,CODE4,NO,) ; ? */
**/*13F3 D (NO,COLCK1,YES,) LFT PAREN? */
**/*13F2 D (NO,XINUP,YES,) PCE SUBSCRIPTABLE? */
**/*13F1 P (,SUBERSCN) TURN ON SUBSMODE */
**/*COLCK1:13G3 D (YES,,NO,XINUP) COLON? */
**/*RANGE:13H3  S RANGE: */
**/*13J3 D (+4,,+0,ERRST) RETURN? */
**/*13J4 R () INVPSAVE IN TERM INIT */
**/*ERRST:13K3 P SET ERRORBIT AND PFNOPOP */
**/*XINUP:13G2 P (,SEPTEST) XINPUT = XINPUT + 1 */
**/*CODE4:14A2 D (NO,NOSUBS,YES,) SUBSMODE ON? */
**/*14A3 P (,PRMTEXT) RESET PDE PTR TO TEMPDE */
**/*NOSUBS:14B2 P SET PCE PTR TO MAJ PCE */
**/*PRMTEXT:14C2 P SET DIGIT CTR TO 0 */
**/*14D2 D (YES,RTNTEST,NO,) PARM TYPE STATEMENT? */
**/*14E2 D (NO,TEMPPDE,YES,) RNGEVAL2 ON? */
**/*14F2 D (NO,PERMPDE,YES,) PFLIST ON? */
**/*14G2 D (YES,PERMPDE,NO,) PREVPDEL 0 ? */
**/*14G1 P (,SPECMSG3) PDEPTR = ADDR PTD TO BY PREVPDEL */
**/*PERMPDE:14H2 P (,PRMTEST) SET PDE PTR TO PERMPDE */
**/*TEMPPDE:14E3 D (NO,OPERTST,YES,) TEMPPDE HAVE VARIA FLAG SET? */
**/*PRMTEST:14F3 D (NO,SPECMSG3,YES,SETMSGLN) INVPSAVE = PRMTPTR? */
**/*OPERTST:14E4 D (NO,RTNTEST,YES,) OPERMODE? */
**/*SETMSGLN:14F4 P MSGLEN = XINPUT - INVPSAVE */
**/*14G4 P (,RTNTEST) MSGADDR = INVPSAVE */
**/*SPECMSG3:15A1 P SET SPECMSG BIT */
**/*15B1 P INVPSAVE = PRMTPTR */
**/*15B2 D (YES,YESPGMID,NO,) PGMID IN PDE? */
**/*15B3 P MSGAREA LL = PDELEN-1 */
**/*15C3 P (,RTNTEST) MSGAREA ADDR = PDE NAME PTR */
**/*YESPGMID:15C2 P MSGAREA LL = L1 + L2 */
**/*15D2 P MSGAREA NAME = PGMID PTR */
**/*RTNTEST:15F2 D (YES,,NO,ADDPDE) ERRORBIT ON? */
**/*CODE4A:15G2 D (NO,CODE4B,YES,) OPERMODE BIT ON? */
**/*15G3 D (YES,INVALPRM,NO,CODE4B) PFPDDATA ON? */
**/*INVALPRM:15G4 P XINPUT = ENDINPUT */
**/*CODE4B:15H2 P XINPUTB = XINPUT */
**/*15H3 P TURN OFF ERRORBIT, NAMEREQD, PFNOPOP */
**/*15H4 P QUALCT = 0, ELEMENCT = 0, SUBSMODE = 0 */
**/*15J4 P CBLNKSV2 = ADDR(OPERTEST) */
**/*15K4 S MSGSETUP: WRITE OUT MESSAGE PROMPT */
**/*15K5 R () EXIT TO MSGSETUP RTN */
**/*ADDPDE:16A1 P SET PCE PTR TO MAJOR PCE */
**/*16B1 P PLINKSV2 = ADDR (CODE4C) */
**/*16B2 P SUBSMODE = 0, ELEMNTCT = 0 */
**/*16C1 S POSITXCB: ADD PDE TO PDL */
**/*16D1 D (+4,VALSUBCK,+0,SPECOFF) RETURN? */
**/*VALSUBCK:16D2 P TURN OFF SPECMSG BIT */
**/*16D3 P (,SUBSCRPT) XINPUT = RSVWDSV1 */
**/*SPECOFF:16E1 P TURN OFF SPECMSG BIT */
**/*16F1 D (YES,GOBACK,NO,) RNGEVAL1 ON? */
**/*16G1 P AANC = TANC, PFENDSET = 0 */
**/*16H1 D (NO,LISTEST,YES,) OPERMODE? */
**/*16J1 P RESTORE LINK2 */
**/*16K1 P XINPUT = XINPUT-1 */
**/*16K2 R () RETURN + 4 */
**/*LISTEST:16H2 D (YES,SKIPBL5,NO,) PFLIST ON? */
**/*END:17A1 D (YES,POPSTACK,NO,) XINPUT = EOB? */
**/*17B1 D (NO,POPSTACK,YES,) XINPUT = ; ? */
**/*17C1 P XINPUT = XINPUT - 1 */
**/*POPSTACK:17A2 S (,UPDTEPCE) SCANF: POP STACK IF POSSIBLE */
**/*SKIPBL5:17H3 S SKIPB: */
**/*17H4 D (YES,MISPAREN,NO,) END OF DATA? */
**/*17H5 D (YES,MISPAREN,NO,) XINPUT + 1 = ; ? */
**/*GOBACK:17F2 P PDEPTR = ADDR OF TEMPDE */
**/*17F3 R () INVPSAVE TERM INIT */
**/*MISPAREN:17J4 S PSTRIMSG: ENDING PAREN ASSUMED */
**/*UPDTEPCE:17A3 P UPDATE PCE TO NEXT PCE */
**/*17B3 D (NO,ENDSETOF,YES,) TERM PCE? */
**/*17C3 D (YES,UPDTEPCE,NO,) SUBSCRIPT PCE? */
**/*ENDSETOF:17B4 P PFENDSET = 0 */
**/*17C4 P TURN COBOLMOD OFF */
**/*17D4 R () NEXTPCE IN PARSE */
**/*VARIABLE: END */
*    END IKJPARS2                    /* END COBOL PROCESSOR           *
* /* THE FOLLOWING INCLUDE STATEMENTS WERE FOUND IN THIS PROGRAM.
* /*%INCLUDE SYSLIB  (IKJEFPWA)
* ;
@DATA1   EQU   *
@0       EQU   00                  EQUATES FOR REGISTERS 0-15
@1       EQU   01
@2       EQU   02
@3       EQU   03
@4       EQU   04
@5       EQU   05
@6       EQU   06
@7       EQU   07
@8       EQU   08
@9       EQU   09
@A       EQU   10
@B       EQU   11
@C       EQU   12
@D       EQU   13
@E       EQU   14
@F       EQU   15
@D1      DC    H'5'
@D2      DC    H'1'
@D3      DC    H'0'
@D4      DC    H'2'
@D5      DC    H'256'
@D6      DC    H'30'
@D7      DC    H'-1'
@D8      DC    H'3'
@D9      DC    H'-240'
@D10     DC    H'8'
@D11     DC    H'4'
@CLC     CLC   0(1,@A),0(@E)
@MVC     MVC   0(1,@A),0(@E)
@XC      XC    0(1,@A),0(@E)
@V1      DC    A(TERMOCK)
@V2      DC    A(IKJEFP60)
@V3      DC    A(IKJEFP40)
@V4      DC    A(FREECORE)
@V5      DC    A(TSTRNGE)
         DS    0F
@SIZ001  DC    AL1(&SPN)
         DC    AL3(@DATEND-@DATD)
         DS    0F
@X11     DC    X'0000FFFF'
@X27     DC    X'FF000000'
@C28     DC    C'  '
@C29     DC    C'IN'
@C30     DC    C'OF'
         DS    0D
@DATA    EQU   *
R0       EQU   00000000            FULLWORD INTEGER REGISTER
R1       EQU   00000001            FULLWORD POINTER REGISTER
R2       EQU   00000002            FULLWORD INTEGER REGISTER
R3       EQU   00000003            FULLWORD INTEGER REGISTER
XINPUT   EQU   00000004            FULLWORD POINTER REGISTER
XINPUTB  EQU   00000005            FULLWORD POINTER REGISTER
XPCE     EQU   00000006            FULLWORD POINTER REGISTER
R7       EQU   00000007            FULLWORD INTEGER REGISTER
LINK1    EQU   00000008            FULLWORD INTEGER REGISTER
INDEX    EQU   00000008            FULLWORD POINTER REGISTER
LINK2    EQU   00000009            FULLWORD INTEGER REGISTER
R10      EQU   00000010            FULLWORD INTEGER REGISTER
PWAREG   EQU   00000011            FULLWORD POINTER REGISTER
PWORK    EQU   00000000            719 BYTE(S) ON DWORD
DUMMY1   EQU   PWORK+00000000      155 BYTE(S) ON WORD
SAVE1    EQU   PWORK+00000000      18*FULLWORD POINTER
ADDRSAVE EQU   PWORK+00000072      4*FULLWORD POINTER
P20SAVE  EQU   PWORK+00000088      4*FULLWORD POINTER
INTEGER  EQU   PWORK+00000104      8*4  BYTE  POINTER
PDWORD   EQU   PWORK+00000136      2*4  BYTE  POINTER
PDWORD1  EQU   PWORK+00000136      4 BYTE(S)
PDWORD2  EQU   PWORK+00000140      4  BYTE  POINTER
PDWD     EQU   PWORK+00000140      1 BYTE(S)
ENDINPUT EQU   PWORK+00000144      FULLWORD POINTER
PPOINTR  EQU   PWORK+00000148      FULLWORD POINTER
PLENGTH  EQU   PWORK+00000152      HALFWORD INTEGER
RETCODE  EQU   PWORK+00000154      1  BYTE  POINTER
DUMMY2   EQU   PWORK+00000160      8 BYTE(S) ON DWORD
SUBRWORK EQU   PWORK+00000160      2*FULLWORD POINTER
XPDL     EQU   PWORK+00000168      FULLWORD POINTER
TEMPSAVE EQU   PWORK+00000172      FULLWORD POINTER
PFLAGS   EQU   PWORK+00000176      8 BIT(S)
PFLIST   EQU   PWORK+00000176      1 BIT(S)
PFDEFLT  EQU   PWORK+00000176      1 BIT(S)
PFENDF   EQU   PWORK+00000176      1 BIT(S)
ADREXP   EQU   PWORK+00000176      1 BIT(S)
HEXBIT   EQU   PWORK+00000176      1 BIT(S)
PFBYPAS  EQU   PWORK+00000176      1 BIT(S)
PFNEW    EQU   PWORK+00000176      1 BIT(S)
DECBIT   EQU   PWORK+00000176      1 BIT(S)
PFLAGS2  EQU   PWORK+00000177      8 BIT(S)
PFSKPINV EQU   PWORK+00000177      1 BIT(S)
RNGEVAL1 EQU   PWORK+00000177      1 BIT(S)
ONERBIT  EQU   PWORK+00000177      1 BIT(S)
TWORBIT  EQU   PWORK+00000177      1 BIT(S)
RNGEVAL2 EQU   PWORK+00000177      1 BIT(S)
REGBIT   EQU   PWORK+00000177      1 BIT(S)
FLTERBIT EQU   PWORK+00000177      1 BIT(S)
BREAKBIT EQU   PWORK+00000177      1 BIT(S)
PFLAGS3  EQU   PWORK+00000178      8 BIT(S)
PFSTPRMT EQU   PWORK+00000178      1 BIT(S)
PFONE    EQU   PWORK+00000178      1 BIT(S)
LOADBIT  EQU   PWORK+00000178      1 BIT(S)
ENTRYBIT EQU   PWORK+00000178      1 BIT(S)
PFNULL   EQU   PWORK+00000178      1 BIT(S)
LPRNFND  EQU   PWORK+00000178      1 BIT(S)
PFSPACE  EQU   PWORK+00000178      1 BIT(S)
PFMORE   EQU   PWORK+00000178      1 BIT(S)
PFLAGS4  EQU   PWORK+00000179      8 BIT(S)
PFENDLIM EQU   PWORK+00000179      1 BIT(S)
PFLSTEND EQU   PWORK+00000179      1 BIT(S)
PFVCMSG  EQU   PWORK+00000179      1 BIT(S)
PFPDDATA EQU   PWORK+00000179      1 BIT(S)
PFSLASH  EQU   PWORK+00000179      1 BIT(S)
PFENDSET EQU   PWORK+00000179      1 BIT(S)
PFNOPOP  EQU   PWORK+00000179      1 BIT(S)
CKRANGE  EQU   PWORK+00000179      1 BIT(S)
PFLAGS5  EQU   PWORK+00000180      8 BIT(S)
PFSQSTR  EQU   PWORK+00000180      1 BIT(S)
INVPRMPT EQU   PWORK+00000180      1 BIT(S)
SUBFLG   EQU   PWORK+00000180      1 BIT(S)
INVFLG   EQU   PWORK+00000180      1 BIT(S)
BYPASFLG EQU   PWORK+00000180      1 BIT(S)
RD4      EQU   PWORK+00000180      1 BIT(S)
RD5      EQU   PWORK+00000180      1 BIT(S)
RD6      EQU   PWORK+00000180      1 BIT(S)
PFLAGS6  EQU   PWORK+00000181      8 BIT(S)
PFLAGS7  EQU   PWORK+00000182      8 BIT(S)
PFLAGS8  EQU   PWORK+00000183      8 BIT(S)
STORANC  EQU   PWORK+00000184      8 BYTE(S)
PANCHOR  EQU   PWORK+00000184      4  BYTE  POINTER
PANCHORT EQU   PWORK+00000188      4  BYTE  POINTER
PGETLIST EQU   PWORK+00000192      10 BYTE(S) ON WORD
PGETLNTH EQU   PWORK+00000192      FULLWORD INTEGER
PGETRADR EQU   PWORK+00000196      FULLWORD POINTER
PGETMDSP EQU   PWORK+00000200      HALFWORD INTEGER
PIPDLCUR EQU   PWORK+00000204      FULLWORD POINTER
PIPDLCHN EQU   PWORK+00000208      FULLWORD POINTER
NME      EQU   PWORK+00000212      20*FULLWORD POINTER
PIPDLX   EQU   PWORK+00000292      1  BYTE  POINTER
PLINKSV1 EQU   PWORK+00000296      FULLWORD POINTER
INVPSAVE EQU   PWORK+00000300      FULLWORD POINTER
PKEYWDPS EQU   PWORK+00000304      FULLWORD POINTER
PKEYWDPC EQU   PWORK+00000308      FULLWORD POINTER
PKEYWDPX EQU   PWORK+00000312      FULLWORD POINTER
PKEYWDTB EQU   PWORK+00000316      FULLWORD POINTER
PKEYWDPM EQU   PWORK+00000320      FULLWORD POINTER
PTABLEAD EQU   PWORK+00000324      FULLWORD POINTER
PTABLEND EQU   PWORK+00000328      FULLWORD POINTER
TEMPPDE  EQU   PWORK+00000332      80 BYTE(S) ON WORD
TEMPPDE2 EQU   PWORK+00000332      36 BYTE(S) ON WORD
TEMPFLD1 EQU   PWORK+00000332      8 BYTE(S) ON WORD
DATAPTR1 EQU   PWORK+00000332      FULLWORD POINTER
DATALEN1 EQU   PWORK+00000336      HALFWORD INTEGER
DATAFLA1 EQU   PWORK+00000338      8 BIT(S)
DATAFLB1 EQU   PWORK+00000339      8 BIT(S)
TEMPFLD2 EQU   PWORK+00000340      8 BYTE(S) ON WORD
DATAPTR2 EQU   PWORK+00000340      FULLWORD POINTER
DATALEN2 EQU   PWORK+00000344      HALFWORD INTEGER
DATAFLA2 EQU   PWORK+00000346      8 BIT(S)
DATAFLB2 EQU   PWORK+00000347      8 BIT(S)
TEMPFLD3 EQU   PWORK+00000348      20 BYTE(S) ON WORD
DATAPTR3 EQU   PWORK+00000348      FULLWORD POINTER
DATALEN3 EQU   PWORK+00000352      HALFWORD INTEGER
DATAFLA3 EQU   PWORK+00000354      8 BIT(S)
DATAFLB3 EQU   PWORK+00000355      8 BIT(S)
DATAFLG  EQU   PWORK+00000356      8 BIT(S)
DATASGN  EQU   PWORK+00000357      8 BIT(S)
DATAICT  EQU   PWORK+00000358      HALFWORD INTEGER
DATAEXP  EQU   PWORK+00000360      FULLWORD POINTER
DATAUSER EQU   PWORK+00000364      FULLWORD INTEGER
CBADD    EQU   PWORK+00000368      11*FULLWORD POINTER
ENDBAKUP EQU   PWORK+00000412      FULLWORD POINTER
PDELIM   EQU   PWORK+00000416      1 BYTE(S)
PPCOUNT  EQU   PWORK+00000417      1  BYTE  POINTER
PPDESIZE EQU   PWORK+00000418      1  BYTE  POINTER
PERRCODE EQU   PWORK+00000419      1  BYTE  POINTER
PKEYWDVL EQU   PWORK+00000420      HALFWORD INTEGER
RNG2ADDR EQU   PWORK+00000424      FULLWORD POINTER
SEGLIST  EQU   PWORK+00000428      5*FULLWORD POINTER
PREVPDEL EQU   PWORK+00000448      FULLWORD POINTER
VCEPARAM EQU   PWORK+00000452      13 BYTE(S) ON WORD
PDEADR   EQU   PWORK+00000452      FULLWORD POINTER
USERWORD EQU   PWORK+00000456      FULLWORD INTEGER
VALMSG   EQU   PWORK+00000460      FULLWORD POINTER
MSGCODE  EQU   PWORK+00000464      1  BYTE  POINTER
PRIMSGID EQU   PWORK+00000465      20 BYTE(S)
SAVLSLEN EQU   PWORK+00000486      HALFWORD INTEGER
PLUSSEG  EQU   PWORK+00000488      5 BYTE(S)
PUTLPTR  EQU   PWORK+00000496      FULLWORD POINTER
PUTGPTR  EQU   PWORK+00000500      FULLWORD POINTER
UPTADDR  EQU   PWORK+00000504      FULLWORD POINTER
ECTADDR  EQU   PWORK+00000508      FULLWORD POINTER
ECBADDR  EQU   PWORK+00000512      FULLWORD POINTER
A00000   EQU   PWORK+00000516      FULLWORD POINTER
OPEREND  EQU   PWORK+00000520      FULLWORD POINTER
RSVWDPCE EQU   PWORK+00000524      FULLWORD POINTER
TERMXPCE EQU   PWORK+00000528      FULLWORD POINTER
OPERPCE  EQU   PWORK+00000532      FULLWORD POINTER
OPERSVE  EQU   PWORK+00000536      FULLWORD POINTER
RSVWDSV1 EQU   PWORK+00000540      FULLWORD POINTER
RSVWDSV2 EQU   PWORK+00000544      FULLWORD POINTER
CBLNKSV1 EQU   PWORK+00000548      FULLWORD POINTER
CBLNKSV2 EQU   PWORK+00000552      FULLWORD POINTER
ENDNMPTR EQU   PWORK+00000556      FULLWORD POINTER
CHAINPTR EQU   PWORK+00000560      FULLWORD POINTER
PDEPTR   EQU   PWORK+00000564      FULLWORD POINTER
AANC     EQU   PWORK+00000568      FULLWORD POINTER
TANC     EQU   PWORK+00000572      FULLWORD POINTER
OANC     EQU   PWORK+00000576      FULLWORD POINTER
ENDANC   EQU   PWORK+00000580      FULLWORD POINTER
PRMTPTR  EQU   PWORK+00000584      FULLWORD POINTER
OPERLL   EQU   PWORK+00000588      HALFWORD INTEGER
MSGAREA  EQU   PWORK+00000590      6 BYTE(S)
MSGLEN   EQU   PWORK+00000590      2  BYTE  INTEGER
MSGADDR  EQU   PWORK+00000592      4  BYTE  POINTER
DIGITCT  EQU   PWORK+00000596      1  BYTE  POINTER
ELEMNCT  EQU   PWORK+00000597      1  BYTE  POINTER
QUALCT   EQU   PWORK+00000598      1  BYTE  POINTER
CBFLAGS1 EQU   PWORK+00000599      8 BIT(S)
COBOLMOD EQU   PWORK+00000599      1 BIT(S)
OPERMODE EQU   PWORK+00000599      1 BIT(S)
SUBSMODE EQU   PWORK+00000599      1 BIT(S)
NAMEREQD EQU   PWORK+00000599      1 BIT(S)
ERRORBIT EQU   PWORK+00000599      1 BIT(S)
RSVDPRMT EQU   PWORK+00000599      1 BIT(S)
OPERPRMT EQU   PWORK+00000599      1 BIT(S)
RC16     EQU   PWORK+00000599      1 BIT(S)
CBFLAGS2 EQU   PWORK+00000600      8 BIT(S)
SPECMSG  EQU   PWORK+00000600      1 BIT(S)
LFTPAREN EQU   PWORK+00000600      1 BIT(S)
RHTPAREN EQU   PWORK+00000600      1 BIT(S)
CHAINTRM EQU   PWORK+00000600      1 BIT(S)
PARS2IN  EQU   PWORK+00000600      1 BIT(S)
PRMTSCAN EQU   PWORK+00000600      1 BIT(S)
BUFPOPED EQU   PWORK+00000600      1 BIT(S)
RNGADDED EQU   PWORK+00000600      1 BIT(S)
CBFLAGS3 EQU   PWORK+00000601      8 BIT(S)
FIRSTNAM EQU   PWORK+00000601      1 BIT(S)
CTFOUND  EQU   PWORK+00000601      1 BIT(S)
BLNKFLAG EQU   PWORK+00000601      1 BIT(S)
CBFLAGS4 EQU   PWORK+00000602      8 BIT(S)
TRANAREA EQU   PWORK+00000604      2 BYTE(S) ON HWORD
CORELEN  EQU   PWORK+00000606      HALFWORD INTEGER
PARS2ADR EQU   PWORK+00000608      FULLWORD POINTER
VCONAD   EQU   PWORK+00000612      FULLWORD POINTER
GOREGSV  EQU   PWORK+00000616      FULLWORD POINTER
TERMBASE EQU   PWORK+00000620      FULLWORD POINTER
OPERBASE EQU   PWORK+00000624      FULLWORD POINTER
BASE3SV  EQU   PWORK+00000628      FULLWORD POINTER
BASE2SV  EQU   PWORK+00000632      FULLWORD POINTER
BASE1SV  EQU   PWORK+00000636      FULLWORD POINTER
RBASESV  EQU   PWORK+00000640      FULLWORD POINTER
CBLRET   EQU   PWORK+00000644      FULLWORD POINTER
COREADDR EQU   PWORK+00000648      FULLWORD POINTER
AUTOBASE EQU   PWORK+00000652      FULLWORD POINTER
WORKSAVE EQU   PWORK+00000656      4*FULLWORD POINTER
PLINKSV2 EQU   PWORK+00000672      FULLWORD POINTER
KEYPTR   EQU   PWORK+00000676      FULLWORD POINTER
KEYLEN   EQU   PWORK+00000680      HALFWORD INTEGER
KEYBUF   EQU   PWORK+00000682      37 BYTE(S) ON HWORD
KEYBUFLN EQU   PWORK+00000682      HALFWORD INTEGER
KEYBUFOF EQU   PWORK+00000684      HALFWORD INTEGER
KEYDATA  EQU   PWORK+00000686      33 BYTE(S)
R12      EQU   00000012            FULLWORD INTEGER REGISTER
R13      EQU   00000013            FULLWORD INTEGER REGISTER
GOREG    EQU   00000014            FULLWORD INTEGER REGISTER
R14      EQU   00000014            FULLWORD INTEGER REGISTER
R15      EQU   00000015            FULLWORD INTEGER REGISTER
MASK     EQU   00000000            1 BYTE(S) ON WORD
PCETYPE  EQU   MASK+00000000       3 BIT(S)
A00001   EQU   MASK+00000000       5 BIT(S)
OPCEFLD1 EQU   00000000            10 BYTE(S)
OPCEBYT1 EQU   OPCEFLD1+00000000   16 BIT(S)
OPERMASK EQU   OPCEFLD1+00000000   3 BIT(S)
OPRMTI   EQU   OPCEFLD1+00000000   1 BIT(S)
ODLFTI   EQU   OPCEFLD1+00000000   1 BIT(S)
A00002   EQU   OPCEFLD1+00000000   11 BIT(S)
OPCELNTH EQU   OPCEFLD1+00000002   2  BYTE  INTEGER
OPDEINDX EQU   OPCEFLD1+00000004   2  BYTE  INTEGER
OPCEPTL  EQU   OPCEFLD1+00000006   2  BYTE  INTEGER
A00003   EQU   OPCEFLD1+00000008   2  BYTE  INTEGER
OPCEFLD2 EQU   00000000            10 BYTE(S)
RPCEINDX EQU   OPCEFLD2+00000000   2  BYTE  INTEGER
T1PCEIDX EQU   OPCEFLD2+00000002   2  BYTE  INTEGER
T2PCEIDX EQU   OPCEFLD2+00000004   2  BYTE  INTEGER
T3PCEIDX EQU   OPCEFLD2+00000006   2  BYTE  INTEGER
A00004   EQU   OPCEFLD2+00000008   2  BYTE  INTEGER
OPDE     EQU   00000000            256 BYTE(S)
VCONTAB  EQU   00000000            19*FULLWORD POINTER
DTANME   EQU   00000000            1 BYTE(S)
INVDATA  EQU   00000000            1 BYTE(S)
LISTPTR  EQU   00000000            FULLWORD POINTER
CBLTEMP  EQU   00000332            80 BYTE(S)
MSGAREA1 EQU   00000000            1 BYTE(S)
MSGA     EQU   00000000            1 BYTE(S)
R4       EQU   00000004            FULLWORD POINTER REGISTER
R5       EQU   00000005            FULLWORD POINTER REGISTER
R6       EQU   00000006            FULLWORD POINTER REGISTER
R8       EQU   00000008            FULLWORD POINTER REGISTER
R9       EQU   00000009            FULLWORD POINTER REGISTER
R11      EQU   00000011            FULLWORD POINTER REGISTER
COMBUF   EQU   00000000            1 BYTE(S)
COMBUFBV EQU   00000000            256 BYTE(S)
COMBUFP  EQU   00000000            256 BYTE(S)
COMBUFB  EQU   00000000            1 BYTE(S)
BLNK     EQU   *                   1 BYTE(S)
         DC    C' '
PDEMPT   EQU   00000000            20 BYTE(S) ON WORD
DNAMEPTR EQU   PDEMPT+00000000     FULLWORD POINTER
LNGTH1   EQU   PDEMPT+00000000     1  BYTE  POINTER
LNGTH2   EQU   PDEMPT+00000001     1  BYTE  POINTER
LNGTH3   EQU   PDEMPT+00000002     1  BYTE  POINTER
RESVA    EQU   PDEMPT+00000003     1 BYTE(S)
RESWDNUM EQU   PDEMPT+00000004     HALFWORD POINTER
LNGTH4   EQU   PDEMPT+00000004     1  BYTE  POINTER
RESV2    EQU   PDEMPT+00000005     1 BYTE(S)
FLAG1    EQU   PDEMPT+00000006     8 BIT(S)
PARMIND  EQU   PDEMPT+00000006     1 BIT(S)
CONST    EQU   PDEMPT+00000006     1 BIT(S)
VARIA    EQU   PDEMPT+00000006     1 BIT(S)
STATE    EQU   PDEMPT+00000006     1 BIT(S)
FIXED    EQU   PDEMPT+00000006     1 BIT(S)
NONNUM   EQU   PDEMPT+00000006     1 BIT(S)
FIGUR    EQU   PDEMPT+00000006     1 BIT(S)
FLOAT    EQU   PDEMPT+00000006     1 BIT(S)
FLAG2    EQU   PDEMPT+00000007     8 BIT(S)
SIGN     EQU   PDEMPT+00000007     1 BIT(S)
EXPSIGN  EQU   PDEMPT+00000007     1 BIT(S)
DECPT    EQU   PDEMPT+00000007     1 BIT(S)
RESV3    EQU   PDEMPT+00000007     5 BIT(S)
DATAPTRH EQU   PDEMPT+00000008     FULLWORD POINTER
DATAPTR  EQU   PDEMPT+00000008     FULLWORD POINTER
DATAPTRA EQU   PDEMPT+00000012     FULLWORD POINTER
DATAPTRB EQU   PDEMPT+00000016     FULLWORD POINTER
LNGTH5   EQU   PDEMPT+00000016     1  BYTE  POINTER
NUMQUAL  EQU   PDEMPT+00000017     1 BYTE(S)
NUMSUB   EQU   PDEMPT+00000018     1 BYTE(S)
RESV4    EQU   PDEMPT+00000019     1 BYTE(S)
PCEMPT   EQU   00000000            9 BYTE(S) ON WORD
PCEFLG1  EQU   PCEMPT+00000000     16 BIT(S)
TERPCE   EQU   PCEMPT+00000000     3 BIT(S)
PROMPT   EQU   PCEMPT+00000000     1 BIT(S)
DEFAULT  EQU   PCEMPT+00000000     1 BIT(S)
RESERV1  EQU   PCEMPT+00000000     1 BIT(S)
HELP     EQU   PCEMPT+00000000     1 BIT(S)
VALCHK   EQU   PCEMPT+00000000     1 BIT(S)
LIST     EQU   PCEMPT+00000001     1 BIT(S)
ASIS     EQU   PCEMPT+00000001     1 BIT(S)
RANG     EQU   PCEMPT+00000001     1 BIT(S)
SUBSCRP  EQU   PCEMPT+00000001     1 BIT(S)
RESVCHA  EQU   PCEMPT+00000001     1 BIT(S)
RESERV2  EQU   PCEMPT+00000001     3 BIT(S)
PCELNGTH EQU   PCEMPT+00000002     2 BYTE(S)
PDEOFST  EQU   PCEMPT+00000004     2 BYTE(S)
PCEFLG2  EQU   PCEMPT+00000006     8 BIT(S)
STMT     EQU   PCEMPT+00000006     1 BIT(S)
VAR      EQU   PCEMPT+00000006     1 BIT(S)
CNST     EQU   PCEMPT+00000006     1 BIT(S)
ANY      EQU   PCEMPT+00000006     1 BIT(S)
SUBSCPPT EQU   PCEMPT+00000006     1 BIT(S)
RESERV3  EQU   PCEMPT+00000006     3 BIT(S)
TPTSL    EQU   PCEMPT+00000007     2  BYTE  POINTER
TPODL    EQU   00000000            8 BIT(S) ON BYTE
RSVWDIDX EQU   00000000            2  BYTE  INTEGER
NPCE1    EQU   00000000            261 BYTE(S)
NPCE     EQU   NPCE1+00000000      16 BIT(S)
NPCEMASK EQU   NPCE1+00000000      3 BIT(S)
A00005   EQU   NPCE1+00000000      13 BIT(S)
NPCELNTH EQU   NPCE1+00000002      2  BYTE  INTEGER
NAMELM1  EQU   NPCE1+00000004      1  BYTE  POINTER
NAMEDATA EQU   NPCE1+00000005      256 BYTE(S)
RPCEFLD  EQU   00000000            6 BYTE(S)
RPCEBYT1 EQU   RPCEFLD+00000000    16 BIT(S)
RSVWMASK EQU   RPCEFLD+00000000    3 BIT(S)
RPRMTI   EQU   RPCEFLD+00000000    1 BIT(S)
RDFLTI   EQU   RPCEFLD+00000000    1 BIT(S)
A00006   EQU   RPCEFLD+00000000    3 BIT(S)
RFCONST  EQU   RPCEFLD+00000001    1 BIT(S)
A00007   EQU   RPCEFLD+00000001    7 BIT(S)
RPCELNTH EQU   RPCEFLD+00000002    2  BYTE  INTEGER
RPDEINDX EQU   RPCEFLD+00000004    2  BYTE  INTEGER
ORPDE    EQU   00000332            8 BYTE(S)
A00008   EQU   ORPDE+00000000      2 BYTE(S)
RNAMENUM EQU   ORPDE+00000002      2  BYTE  INTEGER
A00009   EQU   ORPDE+00000004      2 BYTE(S)
ORPDEFLG EQU   ORPDE+00000006      8 BIT(S)
ORFND    EQU   ORPDE+00000006      1 BIT(S)
ORPDERD2 EQU   ORPDE+00000006      7 BIT(S)
ORPDERD3 EQU   ORPDE+00000007      1 BYTE(S)
PARS2BAS EQU   00000002            FULLWORD POINTER REGISTER
OTHBASE  EQU   00000003            FULLWORD POINTER REGISTER
ADDCDE   EQU   00000015            FULLWORD POINTER REGISTER
WORKAR1  EQU   00000000            12 BYTE(S) ON WORD
QNAMEPTR EQU   WORKAR1+00000000    FULLWORD POINTER
QNGTH4   EQU   WORKAR1+00000004    1  BYTE  POINTER
QRESV    EQU   WORKAR1+00000005    3 BYTE(S)
QATAPTRH EQU   WORKAR1+00000008    FULLWORD POINTER
PTRARE   EQU   00000000            FULLWORD POINTER
COMBUFA  EQU   00000000            2 BYTE(S)
VCOMBF   EQU   00000001            1 BYTE(S)
CNSTTEMP EQU   00000000            20 BYTE(S)
VARIPDE  EQU   00000332            19 BYTE(S) ON WORD
A00010   EQU   VARIPDE+00000000    18 BYTE(S)
NUMSUB1  EQU   VARIPDE+00000018    1 BYTE(S)
         ORG   @DATA
         DS    00000001C
@L       EQU   2
@DATD    DSECT
OPCEPTR  EQU   @DATD+00000000      FULLWORD POINTER
RSVDRTN  EQU   @DATD+00000004      FULLWORD POINTER
INDEX1   EQU   @DATD+00000008      FULLWORD POINTER
ADDR1    EQU   @DATD+00000012      HALFWORD INTEGER
OPERSPM  EQU   @DATD+00000016      8 BYTE(S) ON WORD
OPERSPM1 EQU   OPERSPM+00000000    HALFWORD INTEGER
OPERSPM2 EQU   OPERSPM+00000004    FULLWORD INTEGER
WORKAR   EQU   @DATD+00000024      4 BYTE(S) ON WORD
GOPTION  EQU   WORKAR+00000000     1 BYTE(S)
GFIRST   EQU   WORKAR+00000001     1 BYTE(S)
GOTHER   EQU   WORKAR+00000002     1 BYTE(S)
GOMAX    EQU   WORKAR+00000003     1 BYTE(S)
         DS    00000028C
@TEMPS   DS    0F
@TEMP2   DC    F'0'
@TEMP4   DC    F'0'
         DS   0F
PUTLINE  PUTLINE ,MF=L                 * * * *                   F41448
         SPACE
PUTGET   PUTGET ,MF=L                  * * * *                   F41448
         SPACE
         DS    0D                      ALIGN FOR FREEMAIN OF RWORK
@DATD    DSECT
@DATEND  EQU   *
IKJPARS2 CSECT ,
@9FD     EQU   ERROR
@9FC     EQU   ERROR
@9E2     EQU   RTNCLNUP
@9DE     EQU   RTNCLNUP
@9CE     EQU   RTNCLNUP
@9C8     EQU   RTNCLNUP
@9C5     EQU   F
@9BB     EQU   NOMATCH
@9B8     EQU   IP
@9B7     EQU   IP
@9B6     EQU   IP
@9B3     EQU   RTNCLNUP
@9B1     EQU   RTNCLNUP
@9AB     EQU   UPDTPCE
@9AA     EQU   OPER
@99E     EQU   ETEST
@99D     EQU   VERRBIT
TESTERR  EQU   EXIT
@997     EQU   EFOUND
MAXLNEXC EQU   VERRBIT
@98B     EQU   ENDSCAN
@988     EQU   CODE4
@97A     EQU   COD24
@975     EQU   IKJEFP6C
@973     EQU   XINUP
MSGRTN   EQU   UPDTPCE
ENDTERM  EQU   @EL02
         END   IKJPARS2
