P00 TITLE 'I K J E F P 0 0  --  PARSE MAINLINE ROUTINE    DATE 9/7/73'
*                                                                     *
*                                                                     *
***********************************************************************
*                                                                     *
*            P R O L O G U E   FOR   I K J E F P 0 0                  *
*                                                                     *
*                   PARSE MAINLINE ROUTINE                            *
*                                                                     *
*MODULE NAME= IKJEFP00 - (IKJPARS - LOAD MODULE NAME)                 *
*                                                                     *
*DESCRIPTIVE NAME= PARSE                                              *
*                                                                     *
*COPYRIGHT= N/A                                                       *
*                                                                     *
*STATUS= REL. 04.0                                                    *
*                                                                     *
*        RELEASE 037 CHANGES                                          *
*A232550-232554                                              @ZA27204 *
*                                                                     *
*FUNCTION=                                                            *
*     -- PARSE IS A TSO SERVICE ROUTINE WHICH PROVIDES A CENTRALIZED, *
*        AND THEREFORE A GENERALIZED, PROGRAM TO SYNTAX CHECK TSO     *
*        COMMAND PARAMETERS.                                          *
*  OPERATION=                                                         *
*       PARSE USERS SPECIFY THE ACCEPTABLE COMMAND PARAMETERS'        *
*       SYNTAX BY THE USE OF PARSE MACROS WHICH PRODUCE A PARAMETER   *
*       CONTROL LIST (PCL).  PARSE USES THIS LIST TO BUILD THE        *
*       PARAMETER DESCRIPTOR LIST (PDL) WHICH DESCRIBES THE ACTUAL    *
*       USER ENTERED DATA.                                            *
*                                                                     *
*NOTES                                                                *
*  DEPENDENCIES=                                                      *
*    CHARACTER-CODE DEPENDENCIES=                                     *
*       -- CLASS C. THE OPERATION OF THIS PROGRAM                     *
*       IS DEPENDENT UPON AN INTERNAL REPRESENTATION OF THE EXTERNAL  *
*       CHARACTER SET WHICH IS EQUIVALENT TO THE ONE USED AT ASSEMBLY *
*       TIME. THE CODING HAS BEEN ARRANGED SO THAT REDEFINITION OF    *
*       'CHARACTER' CONSTANTS, BY REASSSEMBLY, WILL RESULT IN A       *
*       CORRECT PROGRAM FOR THE NEW DEFINITION.                       *
*  RESTRICTIONS=  NONE.                                               *
*  REGISTER-CONVENTIONS= IKJPARS                                      *
*  PATCH-LABEL= N/A                                                   *
*                                                                     *
*MODULE TYPE= MODULE.                                                 *
*  PROCESSOR= ASSEM                                                   *
*  MODULE SIZE= N/A                                                   *
*  ATTRIBUTES= REENTRANT, REFRESHABLE AND REUSABLE                    *
*                                                                     *
*ENTRY POINT=IKJPARS                                                  *
*  PURPOSE= MAIN ENTRY -- COMMAND PROCESSOR'S PARAMETERS PROCESSOR.   *
*  LINKAGE= STANDARD                                                  *
*  INPUT=                                                             *
*       --- REGISTER ONE POINTS TO THE PARSE PARAMETER LIST (IKJPPL)  *
*       WHICH CONTAINS THE FOLLOWING -                                *
*                                                                     *
*            ***************************************                  *
*            / PPLUPT - POINTER TO UPT             /                  *
*            / PPLECT - POINTER TO ECT             /                  *
*            / PPLECB - POINTER TO ECB             /                  *
*            / PPLPCL - POINTER TO PCL             /                  *
*            / PPLANS - POINTER TO ANSWER PLACE    /                  *
*            / PPLCBUF - POINTER TO COMMAND BUFFER /                  *
*            / PPLUWA - USER WORD                  /                  *
*            ***************************************                  *
*                                                                     *
*       THE ECB IS NOT USED BY PARSE, BUT IS PASSED ASIS IN THE       *
*        PARAMETER LIST TO THE I/O SERVICE ROUTINES.                  *
*                                                                     *
*       -- THE PARAMETER CONTROL LIST (PCL) IS CREATED BY THE CP      *
*       USING THE PARSE MACROS IKJPARMD, IKJPOSIT, IKJIDENT, IKJKEYWD,*
*       IKJNAME, IKJSUBF AND IKJENDP MACROS. EACH MACRO GENERATES ONE *
*       ENTRY IN THE PCL CALLED AN PARAMETER CONTROL ENTRY (PCE).     *
*       THE ANSWER PLACE IS A FOUR BYTE AREA PROVIDED BY THE CALLING  *
*       CP AS A LOCATION WHERE THE PARAMETER DESCRIPTION LIST (PDL)   *
*       ADDRESS IS PLACED.                                            *
*                                                                     *
*       THE COMMAND BUFFER IS OF THE FORM -                           *
*                                                                     *
*                   *******************************************       *
*       BUFFER:    /  LENGTH    /  OFFSET      /  TEXT       /        *
*                   *******************************************       *
*       OFFSET:     0            2              4                     *
*                                                                     *
*       THE LENGTH INCLUDES THE LENGTH OF THE LENGTH AND OFFSET FIELDS*
*       WITH THE BUFFER OFFSET POINTING TO THE LOCATION IN THE BUFFER *
*       WHERE PARSE IS TO BEGIN SCANNING. THE COMMAND SCAN SERVICE    *
*       ROUTINE PREVIOUSLY UPDATED THE OFFSET PAST THE COMMAND NAME.  *
*       THE USER WORD IS PASSED TO THE VALIDITY CHECK ROUTINE AND     *
*       WOULD NORMALLY CONTAIN THE ADDRESS OF A WORK AREA.            *
*                                                                     *
*  REGISTERS SAVED= ALL.                                              *
*  REGISTER USAGE=                                                    *
*  REGISTERS RESTORED= ALL.                                           *
*                                                                     *
*EXIT - NORMAL=  TO COMMAND PROCESSOR                                 *
*  CONDITIONS= WHEN ALL PARAMATERS HAVE BEEN SUCCESSFULLY PROCESSED.  *
*  OUTPUT=                                                            *
*       -- PARAMETER DESCRIPTION LIST (PDL) POINTED TO BY THE         *
*       ANSWER PLACE. THE PDL BEGINS WITH TWO WORDS OF STORAGE CHAINS *
*       WITH THE REMAINING FIELDS VARIABLE LENGTH DEPENDENT UPON THE  *
*       TYPE OF MACROS SELECTED FOR THE PCL.ONLY THE IKJPOSIT,IKJIDENT*
*       AND IKJKEYWD MACROS RESERVE SPACE IN THE PDL. EACH ENTRY IN   *
*       THE PDL IS CALLED A PARAMETER DESCRIPTION ENTRY (PDE).        *
*  RETURN CODES= REGISTER 15 CONTAINS ZERO (0).                       *
*                                                                     *
*EXIT - ERROR=                                                        *
*       -- REGISTER 15 CONTAINS A NON-ZERO RETURN CODE.               *
*  CONDITIONS= WHENEVER AN ERROR OR A REQUEST FOR INTERRUPTION OCCURS.*
*  OUTPUT=                                                            *
*       IN ADDITION TO THE ERROR RETURN CODES, THE PDL ADDRESS IN THE *
*       ANSWER PLACE IS SET TO X'FF000000'.                           *
*  RETURN CODES=                                                      *
*       -- REGISTER 15 CONTAINS A -                                   *
*                            04 RETURN CODE, UNABLE TO PROMPT         *
*                            08 RETURN CODE, PROCESSING INTERRUPTED BY*
*                               ATTENTION                             *
*                            12 RETURN CODE, INVALID PARAMETERS PASSED*
*                               TO PARSE FROM CP                      *
*                            16 RETURN CODE, NO SPACE AVAILABLE       *
*                            20 RETURN CODE, VALIDITY CHECK ROUTINE   *
*                               REQUESTED TERMINATION                 *
*                            24 - AN ERROR IN INPUT PARAMETERS        *
*                                 WAS DETECTED IN THE IKJPARS2        *
*                                 LOAD MODULE.                        *
*                            28 - A LINE DROP CONDITION WAS DETECTED  *
*                                 BY TPUT OR TGET WHICH CAUSED PUTLINE*
*                                 OR PUTGET TO SET RETURN CODES OF 24 *
*                                 AND 32, RESPECTIVELY.         Y02666*
*                                                                     *
*EXTERNAL REFERENCES=                                                 *
*  ROUTINES=                                                          *
*                     --  IKJEFP10 (PARSE MESSAGE MODULE)             *
*                         IKJEFP20 (PARSE GENERAL SCAN MODULE)        *
*                         IKJPUTL  (PUTLINE I/O SERVICE ROUTINE)      *
*                         IKJPTGT  (PUTGET I/O SERVICE ROUTINE)       *
*                         IKJPARS2 - SEPARATE LOAD MODULE TO          *
*                         COBOL SYMBOLIC DEBUG SCAN AND PROMPT.       *
*                         PCE TYPES HANDLED BY THE NEW LOAD           *
*                         MODULE ARE:                                 *
*                                      1) IKJOPER                     *
*                                      2) IKJTERM                     *
*                                      3) IKJRSVWD                    *
*  DATA AREAS=                                                        *
*       -- MACRO IKJEFPWA IS USED TO DEFINE THE WORK AREA             *
*       OBTAINED DURING INITIALIZATION BY IKJEFP00. IKJEFP20 ALSO     *
*       REFERENCES THIS AREA THROUGH THE USE OF THE IKJEFPWA MACRO.   *
*  CONTROL BLOCKS=                                                    *
*       ECT - U                                                       *
*       UPT - U                                                       *
*                                                                     *
*TABLES= IKJEFPWA - PARSE ROUTINE'S WORKAREA.                         *
*       USER PCE - U                                                  *
*       USER PDE - C, U, D                                            *
*                                                                     *
*MACROS=                                                              *
*       IKJEFPWA, FREEMAIN, GETMAIN, RETURN, SAVE, MODID, LOAD, DELETE*
*  SERIALIZATION= N/A                                                 *
*                                                                     *
*CHANGE ACTIVITY=                                                     *
*       APAR 16362 - DELETE LINE THAT UPDATED ENDINPUT POINTR @ZA16362*
*                                                                     *
*MESSAGES=                                                            *
*       IKJ56700A ENTER XXX                                           *
*       IKJ56701  MISSING XXX (+)                                     *
*       IKJ56702I INVALID, XXX, YYY                                   *
*       IKJ56703A REENTER(+)                                          *
*       IKJ56704I XXX AMBIGUOUS                                       *
*       IKJ56705  MISSING PASSWORD FOR XXX                            *
*       IKJ56706I ENDING QUOTE ASSUMED, XXX                           *
*       IKJ56707I RIGHT PARENTHESIS ASSUMED, XXX                      *
*       IKJ56708I INVALID CURRENT PASSWORD                    @Z40RPKQ*
*       IKJ56709I INVALID DATA SET NAME, YYY                          *
*       IKJ56710I INVALID USERID, YYY                                 *
*       IKJ56711I INVALID ADDRESS, YYY                                *
*       IKJ56712I INVALID KEYWORD, YYY                                *
*       IKJ56713I INVALID VALUE, YYY                                  *
*       IKJ56714A ENTER CURRENT PASSWORD                      @Z40RPKQ*
*       IKJ56715I INVALID STRING, YYY                                 *
*       IKJ56716I EXTRANEOUS INFORMATION - IGNORED, XXX               *
*       IKJ56717I INVALID XXX                                         *
*       IKJ56718A REENTER+                                            *
*       IKJ56719I INVALID JOBNAME, YYY                                *
*       IKJ56720I INVALID DDNAME, YYY                                 *
*       IKJ56721I INVALID NEW PASSWORD                        @Z40RPKQ*
*                                                                     *
*       IKJ56722I ENTER NEW PASSWORD                          @Z40RPKQ*
*                                                                     *
*ABEND CODES= N/A                                                     *
*                                                                     *
***********************************************************************
*                                                                     *
* RELEASE 20 SUPPORT CODE -- 20035                                    *
* RELEASE 1.6 SUPPORT CODE -- Y01156   (OCIP ITEMS)                   *
* RELEASE 2.0 SUPPORT CODE -- Y02666                                  *
* RELEASE 3.0 SUPPORT CODE -- Y30NQJN                                 *
* RELEASE 4.0 SUPPORT CODE -- Z40PQRD
* RELEASE 4.0 SUPPORT CODE TO FIX REL 3.0 APAR OZ04540--M4540
* RELEASE 4.0 SUPPORT CODE FOR SU11 AND SU13, ALSO TO FIX     @Z40RPKQ*
*             PTM VS43136                                     @Z40RPKQ*
*                                                                     *
***********************************************************************
*
IKJEFP00 CSECT
*
         EXTRN TRTAB,UPPERTAB,IKJEFP10,IKJEFP03 EXTERNAL REFERENCES
         ENTRY POSITX1,STALOC,GETCORE,QSTR01,POSITX,ILLADDR
         ENTRY RANGE,SKIPB,PROMPTQ,TYPETEST,LISTT
*                                                               Y30NQJN
         ENTRY IKJPARS                 ESTABLISH ENTRY POINT
IKJPARS  DS    0H                      FOR PARSE
*
R0       EQU   0                       SCRATCH/PARAMETER REGISTER --
*                                         MUST BE 0
R1       EQU   1                       SCRATCH/PARAMETER REGISTER --
*                                         MUST BE 1
R2       EQU   2                       GENERAL SCRATCH REGISTER
R3       EQU   3                       GENERAL SCRATCH REGISTER
XINPUT   EQU   4                       NEXT CHARACTER TO SCAN
XINPUTB  EQU   5                       LAST CHARACTER SCANNED USED TO
*                                         COMPUTE LENGTH OF SCANNED
*                                         DATA
R5       EQU   5                       USED AS REG. 5            Y02666
XPCE     EQU   6                       ALWAYS POINTS TO THE CURRENT PCE
BASE3    EQU   7                       ADDITIONAL BASE REGISTER FOR
*                                         FIRST CSECT
LINK2    EQU   8                       SECOND LEVEL LINKAGE REGISTER
*                                         FOR LINKAGE BETWEEN
*                                         SUBROUTINES
LINK1    EQU   9                       FIRST LEVEL LINKAGE REGISTER FOR
*                                         LINKAGE BETWEEN MAINLINE AND
*                                         SUBROUTINES
R9       EQU   9                       TEMPORARY WORK REGISTER   Y02666
BASE2    EQU   10                      BASE REGISTER FOR SECOND CSECT
BASE1    EQU   11                      MAINLINE BASE REGISTER
RBASE    EQU   12                      BASE REGISTER FOR CURRENT
*                                         RECURSIVE WORKSPACE
PBASE    EQU   13                      BASE REGISTER FOR PERMANENT
*                                         WORKSPACE -- MUST BE 13
R14      EQU   14                      SCRATCH/RETURN REGISTER -- MUST
*                                         BE 14
R15      EQU   15                      SCRATCH/CALL REGISTER -- MUST BE
*                                         15
         EJECT
*
* BIT PATTERNS USED TO TEST THE OPTIONS SELECTED BY THE USER AND
* REFLECTED IN VARIOUS BYTES IN THE PCE.
*
PCEFIDNT EQU   B'10000000'             BITS 0-2 - IKJIDENT PCE
PCEFPOST EQU   B'00100000'             BITS 0-2 - IKJPOSIT PCE
PCEFKYWD EQU   B'01000000'             BITS 0-2 - IKJKEYWD PCE
PCEFNAME EQU   B'01100000'             BITS 0-2 - IKJNAME PCE
PCEFSUEN EQU   B'00000000'             BITS 0-2 - IKJSUBF OR IKJENDP
*                                         PCE
PCEFPRPT EQU   B'00010000'             BIT 3  - PROMPT IS SPECIFIED
PCEFDFLT EQU   B'00001000'             BIT 4  - DEFAULT IS SPECIFIED
PCEFSUBF EQU   B'00000100'             BIT 5  - SUBFIELD IS SPECIFIED
PCEFHELP EQU   B'00000010'             BIT 6  - HELP IS SPECIFIED
PCEFVCHK EQU   B'00000001'             BIT 7  - VALIDITY CHECK EXIT IS
*                                         SPECIFIED
PCEFLIST EQU   B'10000000'             BIT 8  - LIST IS SPECIFIED
PCEFASIS EQU   B'01000000'             BIT 9  - NO TRANSLATION REQUIRED
PCEFRNGE EQU   B'00100000'             BIT 10 - RANGE IS SPECIFIED
PCEFINST EQU   B'00010000'             BIT 11 - INSERT IS SPECIFIED
PCEFQSTR EQU   B'00001000'             BIT 12 - SPECIAL STRING HANDLING
PCEFUID  EQU   B'00000100'             BIT 13 - PREFIX USERID TO
*                                      UNQUOTED DATA SET NAME    Y02666
PCEFVSER EQU   B'00000010'             BIT 14 - PROCESS VOLUME SERIAL
*                                          NAME (IKJPOSIT MACRO) Y02666
PCEFDDN  EQU   B'00000001'             BIT 15 - ISSUE DDNAME MESSAGE
*                                               (IKJPOSIT MACRO) Y02666
PCEFALS  EQU   B'00000010'             BIT 14 - ALIAS SPECIFIED  Y02666
*                                            (IKJIDENT MACRO)    Y02666
* IKJIDENT OPTIONS.
PCEFASTK EQU   B'10000000'             BIT 0  - ASTERISK IS ALLOWED
PCEFMAXL EQU   B'01000000'             BIT 1  - MAXLNTH IS SPECIFIED
PCEFPTBY EQU   B'00100000'             BIT 2  - USE PRINT INHIBIT MODE
*                                         WHEN PROMPTING
         SPACE
*
* RECURSIVE WORKSPACE FLAGS.
*
RFKYPRSE EQU   X'80'                   KEYWORDS HAVE BEEN PARSED ONCE
RFQDSNM  EQU   X'40'                   A QUOTED DSNAME IS BEING
*                                         PROCESSED
RFERASE  EQU   X'20'                   AN ERASE IS BEING PERFORMED
RFPRES   EQU   X'10'                   USED TO INDICATE A KEYWORD PCE
*                                         WAS ENCOUNTERED IN THE PCL,
*                                         IF OFF, AN EXTRANEOUS
*                                         INFORMATION MESSAGE IS
*                                         PRINTED INSTEAD OF AN
*                                         INVALID KEYWORD MESSAGE
RFKEYWDS EQU   X'08'                   THE NEXT RECURSION LEVEL IS FOR
*                                         A KEYWORD PARAMETER
RFMEMB   EQU   X'04'                   INDICATES A MEMBER NAME IS BEING
*                                         PROCESSED
RFNOTQ1  EQU   X'02'                   INDICATES THE FIRST QUALIFIER IS
*                                         NOT BEING PROCESSED
RFNOSKIP EQU   X'01'                   INDICATES BLANKS SHOULD NOT BE
*                                         SKIPPED AFTER A PROMPT
         EJECT
*
* PERMANENT WORKSPACE FLAGS.
*
* P F L A G S
PFLIST   EQU   X'80'                   CURRENTLY PROCESSING A LIST
PFDEFLT  EQU   X'40'                   INDICATES A DEFAULT TAKEN
PFENDF   EQU   X'20'                   END OF INPUT AREA HAS BEEN
*                                         REACHED
ADREXP   EQU   X'10'                   INDICATE ADDR EXPRESSION   M4789
HEXBIT   EQU   X'08'                   ADDRESS EXPRESSION CONTAINS
*                                         A HEX CHARACTER
PFBYPAS  EQU   X'04'                   BYPASS MODE IS TO BE ESTABLISHED
PFNEW    EQU   X'02'                   USED BY ADDRESS ROUTINE TO
*                                         DENOTE A NEW VALID ADDRESS
*                                         ENTRYNAME (WITH OR WITHOUT
*                                         LOADNAME QUALIFICATION)
DECBIT   EQU   X'01'                   ADDRESS EXPRESSION IS DECIMAL
* P F L A G S 2
PFSKPINV EQU   X'80'                   VALIDITY CHECK ROUTINE REQUESTED
*                                         A REENTER MESSAGE ONLY
RNGEVAL1 EQU   X'40'                   ADDRESS ROUTINE PROCESSED FIRST
*                                         VALUE OF RANGE PARAMETER
ONERBIT  EQU   X'20'                   CONTROL BIT USED DURING SCAN
*                                         BY ADDRESS ROUTINE
TWORBIT  EQU   X'10'                   CONTROL BIT USED DURING SCAN
*                                         BY ADDRESS ROUTINE
RNGEVAL2 EQU   X'08'                   ADDRESS ROUTINE PROCESSED
*                                         SECOND VALUE OF RANGE
*                                         PARAMETER
REGBIT   EQU   X'04'                   CONTROL BIT USED DURING SCAN
*                                         BY ADDRESS ROUTINE
FLTERBIT EQU   X'02'                   CONTROL BIT USED DURING SCAN
*                                         BY ADDRESS ROUTINE
BREAKBIT EQU   X'01'                   USED BY ADDRESS ROUTINE TO
*                                         DENOTE A BREAK CHARACTER IN
*                                         PARAMETER
* P F L A G S 3
PFSTPRMT EQU   X'80'                   PROMPT FOR STRING
PFONE    EQU   X'40'                   INDICATES AT LEAST ONE PDE
*                                         PDE HAS BEEN BUILT
LOADBIT  EQU   X'20'                   CONTROL BIT USED BY ADDRESS RTN
*                                         DENOTING LOADNAME DATA
ENTRYBIT EQU   X'10'                   CONTROL BIT USED BY ADDRESS RTN
*                                      DENOTING ENTRYNAME DATA
PFNULL   EQU   X'08'                   INDICATES A NULL LINE WAS
*                                        ENTERED AFTER A PROMPT
LPRNFND  EQU   X'04'                   USED TO INDICATE A LEFT PAREN
*                                         WAS FOUND BY THE ERROR RTN.
PFSPACE  EQU   X'02'                   USED TO INDICATE A POSITIONAL
*                                         SPACE PARAMETER WAS
*                                         ENCOUNTERED SO THAT THE
*                                         POSITIONAL STRING ROUTINE
*                                         KNOWS WHEN TO END THE STRING
PFMORE   EQU   X'01'                   USED TO INDICATE IF THE LEFT
*                                         PAREN OF A SUBFIELD WAS
*                                         ALSO USED AS THE LEFT PAREN
*                                         OF THE LIST WITHIN THE
*                                         SUBFIELD
* P F L A G S 4
PFENDLIM EQU   X'80'                   INDICATES END DELIMITER
*                                         FOR A SELF-DELIMITING STRING
*                                         HAS BEEN FOUND
PFLSTEND EQU   X'40'                   INDICATES LIST END DELIMITER
*                                         HAS BEEN FOUND
PFVCMSG  EQU   X'20'                   INDICATES A VALIDITY CHECK
*                                         ROUTINE HAS SUPPLIED A SECOND
*                                       LEVEL MESSAGE
PFPDDATA EQU   X'10'                   INDICATE PROCESSING PROMPT OR
*                                         DEFAULT DATA
PFSLASH  EQU   X'08'                   INDICATE DSNAME/USERID ROUTINE
*                                         IS SCANNING FOR PASSWORD
PFENDSET EQU   X'04'                   INDICATES BACKUP POINTER FOR
*                                         ENDINPUT HAS BEEN SET
PFNOPOP  EQU   X'02'                   INDICATES STACK IS NOT TO  M0911
*                                         BE POPPED IF ALL SEPARATORS
*                                         IN PROMPT BUFFER
CKRANGE  EQU   X'01'                   ADDR ROUTINE SHOULD CHECK  M4789
*                                         FOR RANGE
* P F L A G S 5
PFSQSTR  EQU   X'80'                   SPECIAL QSTRING HANDLING
*                                         DONE AT LEAST ONCE
INVPRMPT EQU   X'40'                   CHECK FOR INVALID MESSAGE PROMPT
*                                      THIS FLAG IS ALSO USED TO TEST
*                                      THE PROMPT FLAG IN THE UPT
*                                      TO INDICATE IF THE USER IS
*                                      IN NOPROMPT MODE OR NOT   Y05020
SUBFLG   EQU   X'20'                   INDICATE SUBFIELD IS BEING
*                                      PROCESSED                 Y01156
INVFLG   EQU   X'10'                   INVALID INPUT WAS FOUND FOR USER
*                                      IN NOPROMPT MODE          Y01156
BYPASFLG EQU   X'08'                   INDICATE BYPASS MODE FOR INVALID
*                                      BUFFER                    Y01156
RPRNFND  EQU   X'04'                   RIGHT PAREN FOUND FLAG    Y01156
         EJECT
PSWDFLG  EQU   X'02'                   INDICATE PASSWORD IS BEING
*                                      PROCESSED                 Y02666
DSNFLG   EQU   X'01'                   INDICATE DSNAME IS BEING
*                                      PROCESSED                 Y02666
* P F L A G S 6                                                  Y02666
ALIASFLG EQU   X'80'                   INDICATE AN ALIAS WAS FOUND
*                                                                Y02666
PSWDQFLG EQU   X'40'                   INDICATE QUOTED PASSWORD  Y02666
HEXFLG   EQU   X'20'                   HEXADECIMAL TYPE IN PROCESS
*                                                                Y02666
DECFLG   EQU   X'10'                   DECIMAL VALUE IN PROCESS  Y02666
BINFLG   EQU   X'08'                   BINARY INTEGER PROCESS    Y02666
CHARFLG  EQU   X'04'                   CHARACTER VALUE PROCESS   Y02666
NUMFLG   EQU   X'02'                   NUMERIC VALUE PROCESS     Y02666
PDEHEX   EQU   X'01'                   CONVERTED HEXADECIMAL VALUE
*                                                                Y02666
* P F L A G S 7                                                  Y02666
VOLSERF  EQU   X'80'                  INDICATE VOLUME SERIAL IN PROCESS
*                                                                Y02666
VALENDF  EQU   X'40'                   INDICATE END OF BUFFER NOT
*                                      REACHED,CHECK DELIMITR    Y02666
DSNAMEF  EQU   X'08'                   INDICATE TO DSNAME IN PROCESS
*                                      DURING VALIDITY CHECKING  Y02666
RPAREND  EQU   X'04'                   INDICATE END OF SUBFIELD FOR
*                                       ENDFIELD ROUTINE        Y30NQJN
         EJECT
PSW2SET  EQU   X'02'                   SET 4R TO NEW PASSWORD
*                                                              @ZR0RPKQ
*
* MESSAGE EQUATES.
*
MSG1     EQU   0                       ENTER 'PROMPT DATA'
MSG2     EQU   4                       MISSING 'PROMPT DATA'
MSG3     EQU   8                       REENTER
MSG4     EQU   12                      AMBIGUOUS
MSG5     EQU   16                      MISSING PASSWORD
MSG6     EQU   20                      INVALID 'PARAMETER TYPE'
MSG7     EQU   24                      END QUOTE ASSUMED
MSG8     EQU   28                      RIGHT PAREN ASSUMED
MSG9     EQU   32                      INVALID CURRENT PASSWORD
*                                                              @Z40RPKQ
MSG10    EQU   36                      INVALID DATA SET NAME
MSG11    EQU   40                      INVALID USERID
MSG12    EQU   44                      INVALID ADDRESS
MSG13    EQU   48                      INVALID KEYWORD
MSG14    EQU   52                      INVALID VALUE
MSG15    EQU   56                      ENTER CURRENT PASSWORD  @Z40RPKQ
MSG16    EQU   60                      INVALID STRING
MSG17    EQU   64                      EXTRANEOUS INFORMATION
MSG18    EQU   68                      INVALID
MSG3A    EQU   72                      REENTER+                  Y01156
MSG19    EQU   76                      INVALID JOBNAME           Y02666
MSG20    EQU   80                      INVALID DDNAME            Y02666
MSG21    EQU   84                      INVALID NEW PASSWORD    @Z40RPKQ
MSG22    EQU   88                      ENTER NEW PASSWORD      @Z40RPKQ
         SPACE
*
* MISCELLANEOUS EQUATES.
*
ZERO     EQU   0                       USED AS A ZERO
ONE      EQU   1                       USED AS A ONE
TWO      EQU   2                       USED AS A TWO
THREE    EQU   3                       USED AS A THREE
FOUR     EQU   4                       USED AS A FOUR
FIVE     EQU   5                       USED AS A FIVE
SIX      EQU   6                       USED AS A SIX
SEVEN    EQU   7                       USED AS A SEVEN
EIGHT    EQU   8                       USED AS A EIGHT
TWELVE   EQU   12                      USED AS A TWELVE
FIFTEEN  EQU   15                      USED AS A FIFTEEN
SIXTEEN  EQU   16                      USED AS A SIXTEEN
TWENTY   EQU   20                      USED AS A TWENTY
TWENTY3  EQU   23                      USED AS A TWENTY-THREE
TWENTY4  EQU   24                      USED AS A TWENTY-FOUR
TWENTY8  EQU   28                      USED AS A TWENTY-EIGHT
THIRTY2  EQU   32                      USED AS A THIRTY-TWO
THIRTY5  EQU   35                      USED AS A THIRTY-FIVE
THIRTY6  EQU   36                      USED AS A THRITY-SIX
NINETY2  EQU   92                      USED AS 92                F41448
WRKLEN   EQU   X'9C'                   LENGTH OF COBOL           F41448
*                                      PORTION OF WORKSPACE      F41448
H00      EQU   X'00'                   USED TO MAINPULATE FLAG BITS
HFF      EQU   X'FF'                   USED TO MAINPULATE FLAG BITS
HA0      EQU   X'A0'                   USED IN PCE CHECKING FOR  F41448
*                                      COBOL                     F41448
H80      EQU   X'80'                   USED BY ADDRESS RTN TO
*                                         MANIPULATE BITS
HE0      EQU   X'E0'                   USED TO OBTAIN TYPE INDICATOR
*                                         FROM PCE FLAG BYTE
H01      EQU   X'01'                   USED TO TEST FOR VALID VALIDITY
*                                         CHECK ROUTINE ADDRESS
H18      EQU   X'18'                   TEST FOR RSVD OR SUBSCRPT F41448
PRESENT  EQU   X'80'                   USED TO SET FLAGS
BKGRND   EQU   X'02'                   TEST BACKGROUND MODE      Y02666
QUOTED   EQU   X'40'                   USED TO SET FLAGS
LENMLLST EQU   20                      LENGTH OF MULTI-LEVEL ELEMENT
*                                         FOR HELP MESSAGES
SEMICOLN EQU   C';'                    SEMICOLON
COLON    EQU   C':'                    COLON
EQUALSN  EQU   C'='                    EQUAL SIGN                Y02666
INSPROC  EQU   X'02'                   PROCEDURE FLAG            Y02666
INSPROM  EQU   X'04'                   PROC PROMPT FLAG          Y02666
INSEXEC  EQU   X'08'                   EXEC COMMAND STACK ENTRY Z40PQRD
BKCHAR   EQU   C'_'                    BREAK CHARACTER
RIGHTPRN EQU   C')'                    RIGHT PARENTHESIS
LEFTPRN  EQU   C'('                    LEFT PARENTHESIS
BLNK     EQU   C' '                    BLANK
COMMA    EQU   C','                    COMMA
TABCHAR  EQU   X'05'                   HORIZONTAL TAB CHARACTER
NLCHAR   EQU   X'15'                   NEW LINE CHARACTER
QUOTE    EQU   C''''                   QUOTATION MARK
PERIOD   EQU   C'.'                    PERIOD
SLASH    EQU   C'/'                    SLASH
ASTERISK EQU   C'*'                    ASTERISK
PLUS     EQU   C'+'                    PLUS SIGN
EBCDIC0  EQU   C'0'                    CHARACTER 0
EBCDIC1  EQU   C'1'                    CHARACTER 1
EBCDIC2  EQU   C'2'                    CHARACTER 2
EBCDIC3  EQU   C'3'                    CHARACAER 3
EBCDIC4  EQU   C'4'                    CHARACTER 4
EBCDIC5  EQU   C'5'                    CHARACTER 5
EBCDIC6  EQU   C'6'                    CHARACTER 6
CC1      EQU   1                       CONDITION CODE ONE (BO)
CC4      EQU   4                       MIXED CONDITION CODE      F41448
CC9      EQU   9                       BRANCH ON NOT MIXED       F41448
CC5      EQU   5                       CONDITION CODE FIVE
CC7      EQU   7                       CONDITION CODE SEVEN (NZ OR NE)
CC8      EQU   8                       CONDITION CODE EIGHT (0 OR EQ)
CC10     EQU   10                      CONDITION CODE 10          M4540
IPDLMAXE EQU   10                      MAXIMUM INPUT STACKING DEPTH FOR
*                                         A INPUT PUSHDOWN STACK
DSNMAXLN EQU   44                      MAXIMUM LENGTH OF A DSNAME
DATAPRES EQU   X'80'                   PDE FLAG TO INDICATE DATA THERE
         SPACE
*
* EQUATES FOR POSITIONAL ADDRESS ROUTINE.
*
COUNTER  EQU   2                       USED TO CONTROL MAXIMUM SIZE
LEVELS   EQU   3                       USED TO CONTROL MAXIMUM SIZE
RELATIVE EQU   C'+'                    DENOTES AN ADDRESS EXPRESSION
MORE     EQU   RELATIVE
CHECK    EQU   1                       TO INTERFACE WITH TYPETEST RTN
PERCENT  EQU   C'%'                    DENOTES LEVELS OF INDIRECT
*                                         ADDRESSES
LESS     EQU   C'-'                    DENOTES AN ADDRESS EXPRESSION
PL1BIT   EQU   X'80'                   PL1 REQUIREMENT
LOCATPDE EQU   8                       USED TO LOCATE LAST EXPRESSION
*                                         VALUE ON CHAIN
D        EQU   C'D'                    USED TO TEST FOR DOUBLE
*                                         PRECISION
LOWD     EQU   X'84'                   LOWER CASE IS VALID
E        EQU   C'E'                    USED BY ADDRESS RTN TO CHECK
*                                         FOR SINGLE PRECISION
LOWE     EQU   X'85'                   LOWER CASE IS VALID
R        EQU   C'R'                    USED BY ADDRESS RTN TO CHECK
*                                         FOR GENERAL REGISTER
LOWR     EQU   X'99'                   LOWER CASE IS VALID
NNN      EQU   C'N'                    DENOTES DECIMAL AS OPPOSED TO
*                                         HEXIDECIMAL EXPRESSION VALUE
LOWNNN   EQU   X'95'                   LOWER CASE IS VALID
*                                         THE FOLLOWING SYMBOLIC LABELS
*                                         ARE USED WHEN REFERENCING AN
*                                         ADDRESS EXPRESSION PDE
ADDRDATA EQU   0                       POINTER TO ADDRESS STRING
ADDRLNTH EQU   4                       POINTER TO ADDRESS LENGTH
ADDRFLGS EQU   8                       INDICATES TYPE OF EXPRESSION
*                                         VALUE
ADDRSIGN EQU   9                       ARITHMETIC SIGN CHARACTER USED
*                                         BEFORE NEXT EXPRESSION VALUE
*                                         ZERO IF LAST VALUE TO CHAIN
ADDRCNT  EQU   10                      NUMBER OF LEVELS OF INDIRECT
*                                         ADDRESSING
ADDRPTR  EQU   12                      POINTER TO NEXT EXPRESSION
*                                         VALUE
TINYPDE  EQU   1                       R1(TINYPDE)USED AS POINTER TO
*                                         CORE GOTTEN FOR ADDRESS
*                                         EXPRESSION
HEXVALUE EQU   X'02'                   USED BY ADDRESS SUBROUTINE TO
*                                         DENOTE A HEXADECIMAL
*                                         EXPRESSION VALUE
DECVALUE EQU   X'04'                   USED BY ADDRESS SUBROUTINE TO
*                                         DENOTE A DECIMAL EXPRESSION
*                                         VALUE
SYMADR   EQU   X'80'                   SYMBOLIC ADDRESS FLAG
RELADR   EQU   X'40'                   RELATIVE ADDRESS FLAG
ABSADR   EQU   X'00'                   ABSOLUTE ADDRESS FLAG      M5957
REG      EQU   X'20'                   REGISTER NOTATION FLAG
DPFPR    EQU   X'10'                   USED TO DENOTE DOUBLE PRECISION
*                                         FLOATING POINT REGISTER
SPFPR    EQU   X'08'                   USED TO DENOTE SINGLE PRECISION
*                                         FLOATING POINT REGISTER
ENTRYNAM EQU   X'04'                   USED BY ADDRESS RTN TO DENOTE
*                                         A NON-QUALIFYING ENTRYNAME
*                                         (PRECEDED BY AN OPTIONAL
*                                         LOADNAME)
EMPTYFLG EQU   X'02'                   INITIAL SETTING OF DATAFLG -
*                                       NO ADDR TYPE YET IDENTIFIED
         SPACE
*
* OFFSETS FOR REQUIRED FIELDS IN MACROS.
*
PCEPCLLN EQU   0                       PCL LENGTH FIELD IN IKJPARM
PCEPDLLN EQU   2                       PDL LENGTH FIELD IN IKJPARM
PCEKYEND EQU   4                       IKJKEYWD OR END-OF-FIELD OFFSET
*                                         IN IKJPARM
PCEFLGB1 EQU   0                       FLAG BYTE 1
PCEFLGB2 EQU   1                       FLAG BYTE 2
PCELEN   EQU   2 - 3                   PCE LENGTH
PCEPDEO  EQU   4 - 5                   PDE OFFSET INTO PDL
PCEPOST  EQU   6                       TYPE OF POSITIONAL PARAMETER
PCENAML  EQU   4                       LENGTH OF NAME FOR IKJNAME
PCENAMN  EQU   5 - N                   NAME SPECIFIED
PCEOPT   EQU   6                       IKJIDENT OPTION BYTE
PCEFIRST EQU   7                       IKJIDENT FIRST CHARACTER FLAGS
PCEOTHER EQU   8                       IKJIDENT OTHER CHARACTER FLAGS
PCEPARMT EQU   9                       IKJIDENT PARAMETER TYPE SEGMENT
         SPACE
*
* MESSAGE OFFSETS TO BE INSERTED INTO CONSTRUCTED MESSAGE SEGMENTS.
*
OFFSET1  EQU   16                      OFFSET FOR ENTER
OFFSET2  EQU   37                      OFFSET FOR ENTER CURRENT
*                                     PASSWORD               @Z40RPKQ
OFFSET3  EQU   44                      OFFSET FOR EXTRANEOUS INFOR.
OFFSET4  EQU   37                      OFFSET FOR RIGHT PAREN ASSUMED
OFFSET5  EQU   32                      OFFSET FOR END QUOTE ASSUMED
OFFSET6  EQU   10                      OFFSET FOR AMBIGUOUS KEYWORD
OFFSET21 EQU   22                      OFFSET FOR REENTER-KEYWD Y01156
OFFSET22 EQU   33                      OFFSET FOR ENTER NEW PASSWORD
*                                                              @Z40RPKQ
         SPACE
*
* BIT SETTINGS USED BY TYPETEST FOR SYNTAX CHECKING CHARACTERS.
*
HEX      EQU   X'80'                   HEX CHARACTER
OLETTER  EQU   X'40'                   LETTER NOT A HEX LETTER
NATL     EQU   X'20'                   NATIONAL CHARACTER
NUMBER   EQU   X'10'                   NUMBER
SEPAR    EQU   X'08'                   SEPARATOR
NSEPDLIM EQU   X'04'                   DELIMITER, NOT A SEPARATOR
NDLIMSPC EQU   X'02'                   SPECIAL CHAR NOT A DELIM OR SEP
CMDDLIM  EQU   X'01'                   COMMAND NAME DELIMITER
INVALID  EQU   X'00'                   INVALID CHAR
ALPHA    EQU   HEX+OLETTER+NATL        ALPHABETIC CHARS
DLIMREQD EQU   SEPAR+NSEPDLIM          A END OF PARAMETER DELIMITER IS
*                                         REQUIRED
         SPACE
*
* PARSE RETURN CODES
*
RCSUCSFL EQU   0                       SUCCESSFUL COMPLETION
RCNOPRMT EQU   4                       COMMAND INCOMPLETE - UNABLE TO
*                                         PROMPT
RCATTN   EQU   8                       PROCESSING INTERRUPTED BY ATTN
RCERROR  EQU   12                      INVALID PARAMETERS
RCNOCORE EQU   16                      NO SPACE AVAILABLE
RCVCERR  EQU   20                      VALIDITY CHECK ROUTINE INDICATED
*                                         IT COULD NOT CONTINUE (E.G.,
*                                         GETMAIN FAILURE) AND WANTS
*                                         PARSE TO TERMINATE
*  RETURN CODE OF 24 IS USED BY IKJPARS2 LOAD MODULE                  *
RCLNDROP EQU   28                      LINE DROP RETURN CODE     Y02666
         EJECT
***********************************************************************
*                                                                     *
*                        MAIN CONTROL ROUTINE                         *
*                                                                     *
*   STORAGE IS OBTAINED FOR THE PERMANENT WORKSPACE, THE PDL AND THE  *
* RECURSIVE WORKSPACE. AFTER INITIALIZING THE WORKSPACE AREAS AND THE *
* NECESSARY REGISTERS, THE NEXT PCE TYPE IS ANALYZED AND A BRANCH IS  *
* TAKEN TO THE APPROPRIATE PROCESSOR.                                 *
*                                                                     *
***********************************************************************
*/*IKJEFP00: CHART */
*/* E START */
         SPACE
         SAVE  (14,12)                 SAVE CALLERS REGISTERS
         SPACE
         BALR  BASE1,ZERO              ESTABLISH ADDRESSABILITY
*/* P ESTABLISH ADDRESSABILITY FOR THREE CSECTS */
         USING *,BASE1                 TO FIRST CSECT
         MODID BRANCH=YES              FLAG                      Y01886
         SPACE
         L     BASE2,ADRCST1           ESTABLISH ADDRESSABILITY
         USING IKJEFP01,BASE2              TO SECOND CSECT
         SPACE  2
         L     BASE3,ADRCST2           ESTABLISH ADDRESSABILITY
         USING IKJEFP02,BASE3              TO THIRD CSECT
         SPACE
         LR    R3,R1                   SAVE INPUT PARAMETER LIST ADR.
         SPACE
*
* OBTAIN AND INITIALIZE PERMANENT AND FIRST RECURSIVE WORKSPACES.
*
*/* L ISSUE GETMAIN FOR PWORK AND RWORK */
         GETMAIN R,LV=WORKSZ+RWORKSZ  OBTAIN WORKSPACES
         SPACE
         LR    R2,PBASE                SAVE CALLER SAVERAREA ADDRESS
         LR    PBASE,R1                ESTABLISH PARSES SAVEAREA AND
*                                         INITIALIZE PERMANENT
*                                         WORKSPACE BASE REGISTER
         ST    R2,FOUR(PBASE)          BACK CHAIN TO CALLERS SAVEAREA
         ST    PBASE,EIGHT(R2)         FORWARD CHAIN TO PARSES SAVEAREA
         USING PWORK,PBASE             ESTABLISH ADDRESSABILTIY TO
*                                         PERMANENT WORKSPACE
         SPACE
*
* INITIALIZE THE FIRST MESSAGE SEGMENT OF THE HELP MESSAGES IN CASE THE
* FIRST MESSAGE ISSUED IS AN 'ENTER' MESSAGE BYPASSING THIS FUNCTION
* IN THE INFORMATIONAL MESSAGE SUBROUTINE (WRITER1). NO HELP MESSAGES
* ARE USED WITH THE 'ENTER PASSWORD FOR' MESSAGE.
*
*/* P INITIALIZE FIRST MESSAGE SEGMENT FOR 'ENTER' */
         L     R15,ADRMSGC             LOAD ADDRESS OF MESSAGE CSECT
         L     R15,MSG1(R15)           LOAD ADDRESS OF MESSAGE
         MVC   PRIMSGID(TWENTY),ZERO(R15) INITIALIZE THE FIRST
         MVI   PRIMSGID+ONE,TWENTY        SEGMENT OF HELP MESSAGES
         SPACE
*
* OBTAIN INPUT PARAMETERS.
*
*/* P SAVE INPUT PARAMETERS */
         L     XPCE,TWELVE(R3)         LOAD ADR OF PCL
         LA    XPCE,ZERO(XPCE)         CLEAR HIGH ORDER BYTE OF PCL
*                                         ADDRESS
         ST    XPCE,PTABLEAD           SAVE PCL ADDRESS
         L     XINPUT,TWENTY(R3)       LOAD ADR OF INPUT BUFFER TO SCAN
         LA    XINPUT,ZERO(XINPUT)     CLEAR HIGH ORDR BYTE OF INPUT
*                                         BUFFER ADDRESS
         MVC   USERWORD(L'USERWORD),TWENTY4(R3) MOVE USER WORD TO
*                                         VALIDITY CHECK EXIT
*                                         PARAMETER LIST
         MVC   SRPARAMS(TWELVE),ZERO(R3) MOVE UPT, ECT, ECB ADDRESSES
*                                         TO SERVICE ROUTINE PARM. LIST
         L     R3,SIXTEEN(R3)          LOAD ADR OF ANSWER PLACE
         LA    R3,ZERO(R3)             CLEAR HIGH ORDER BYTE OF ANSWER
*                                         PLACE ADDRESS
         SPACE
*
* INITIALIZE WORK AREAS AND SWITCHES.
*
*/* P INITIALIZE WORK AREAS AND SWITCHES */
         MVC   PUTLINE(LPLEND-LPUTLINE),LPUTLINE INITIALIZE PUTLINE AND
         MVC   PUTGET(LPGEND-LPUTGET),LPUTGET    PUTGET PARAMETERS
         MVI   PFLAGS,ZERO             CLEAR FLAG BYTE AREA
         MVC   PFLAGS+ONE(SEVEN),PFLAGS  CLEAR FLAG BYTES AREA   Y02666
         LA    R2,OPEREND              GET ADDR OF START OF      F41448
*                                      COBOL PERMANENT WORKSPACE F41448
         XC    ZERO(WRKLEN,R2),ZERO(R2) CLEAR COBOL WORK AREA    F41448
         XC    TEMPPDE(CBLTPDE),TEMPPDE CLEAR THE COBOL TEMPRARY F41448
*                                      PDE                       F41448
         MVI   RETCODE,RCSUCSFL        SET USERS RETURN CODE TO ZERO
         XC    PANCHOR(L'PANCHOR+L'PANCHORT),PANCHOR ZERO INTERNAL
*                                         STORAGE CHAINS
         XC    PIPDLCHN,PIPDLCHN       ZERO INPUT PUSHDOWN STACK
*                                         STORAGE CHAIN
         MVI   PIPDLX,ZERO             ZERO PUSHDOWN STACK INDEX
         LA    R0,PIPDLCHN             INITIALIZE CURRENT INPUT
         ST    R0,PIPDLCUR                PUSHDOWN STACK PTR
         LR    R2,XINPUT               COPY INPUT BUFFER ADDRESS
         MVC   PDWORD(TWO),ZERO(R2)    ALIGN LENGTH ON PROPER BOUNDARY
         AH    R2,PDWORD               ADD TOTAL BUFFER LENGTH TO START
*                                         ADDRESS TO GET END OF BUFFER
*                                         ADDRESS FOR FUTURE COMPARES
*/* P SAVE END OF BUFFER ADDRESS */
         ST    R2,ENDINPUT             SAVED TO FIND END OF BUFFER
         MVC   PDWORD(TWO),TWO(XINPUT) ALIGN OFFSET ON PROPER BOUNDARY
         LH    R1,PDWORD               SAVE FOR LATER CALCULATION
         LA    XINPUT,THREE(R1,XINPUT) POSITION SCAN POINTER JUST
*                                         BEFORE FIRST INPUT CHARACTER
         MVC   PDWORD(TWO),PCEPCLLN(XPCE) ALIGN PCL LENGTH ON PROPER
*                                         BOUNDARY
         LH    R2,PDWORD               LOAD THE PCL LENGTH
         AR    R2,XPCE                 ADD THE PCL START ADDRESS
         ST    R2,PTABLEND             SAVE POINTER TO BYTE PAST END OF
*                                         PCL
         MVC   PDWORD(TWO),PCEPDLLN(XPCE) ALIGN PDL LENGTH ON PROPER
*                                         BOUNDARY
         LH    R1,PDWORD               LOAD PDL LENGTH
*/* P POSITION SCAN POINTER TO BEFORE FIRST CHARACTER */
         LA    R2,PCEKYEND(XPCE)       SET UP A POINTER TO THE FIRST
*                                         KEYWORD PCE OFFSET OR THE
*                                         END-OF-FIELD PCE OFFSET TO BE
*                                         USED IN THE RECURSE ROUTINE
         SPACE
*
* OBTAIN STORAGE FOR PDL.
*
*/* S STALOC: GET STORAGE FOR PDL */
         XC    ZERO(FOUR,R3),ZERO(R3)  ZERO ANSWER PLACE IN CASE
*                                         GETMAIN FAILS --- CLEANUP
*                                         ROUTINE NEEDS TO KNOW IF PDL
*                                         OBTAINED FOR FREEMAIN
         SR    RBASE,RBASE             ZERO RBASE IN CASE GETMAIN FAILS
*                                      THE CLEANUP ROUTINE WONT TRY TO
*                                      FREE UP AN INVALID AREA   Y02666
         BAL   LINK2,STALOC            BRANCH TO STORAGE ALLOCATE RTN.
         SPACE
*                                      CORE ADDRESS RETURNED IN R1
         SH    R1,H8                   BACK UP OVER STORAGE CHAINS
         ST    R1,ZERO(R3)             STORE ADDRESS OF PDL IN ANSWER
*                                         PLACE
         ST    R1,XPDL                 SAVE ADDRESS OF PDL
         SPACE
*
         LA    R1,WORKSZ(PBASE)        INITIALIZE BASE REGISTER FOR
*                                         RECURSIVE WORKSPACE AS
*                                         THROUGH FOLLOWING GETMAIN WAS
*                                         ISSUED
         XR    RBASE,RBASE             SET CONDITION CODE TO ZERO
         B     RECURSEA                BRANCH TO INITIALIZE RECURSIVE
*                                         WORKSPACE - EVERTHING IS
*                                         SETUP AS RECURSIVE WORKSPACE
*                                         GETMAIN WAS ISSUED - PURPOSE
*                                         IS TO ELIMINATE ADDITIONAL
*                                         SVC
         SPACE
*
* BEGINNING NEW SUBFIELD, ALLOCATE AND INITIALIZE NEW RECURSIVE
* WORKSPACE.
*
*/* D (YES,,NO,RECURSEA) BEGINNING NEW SUBFIELD */
*/*RECURSE: P NEW RWORK SPACE ALLOCATION */
RECURSE  DS    0H                      NEW SUBFIELD WORKSPACE
*                                         ALLOCATION
         USING RWORK,RBASE             ESTABLISH BASE FOR WORKSPACE
         SPACE
         LA    R1,RWORKSZ              SET SIZE OF WORKAREA NEEDED AND
*                                         SET SUBPOOL TO 0
         LR    R3,LINK1                SAVE LINKAGE REGISTER
*/* S GETCORE: GET CORE FOR WORKSPACE */
         BAL   LINK1,GETCORE           LINK TO GETCORE TO DO
*                                         CONDITIONAL GETMAIN FOR SPACE
         SPACE
*                                      CORE ADDRESS RETURNED IN R1
         LR    LINK1,R3                RESTORE LINKAGE REGISTER
         TM    RFLAGS,RFERASE          SET CONDITION CODE FOR FLAG
*                                         SETTING THAT FOLLOWS
         SPACE
*
********
******** N O T E  - NO CONDITION CODE SETTING HERE UNTIL AFTER RFLAGS
********            HAS BEEN SET UP.
********
*
         SPACE
         DROP  RBASE                   PREPARE TO USE GETMAIN RETURNED
*                                         ADDRESS
         SPACE
RECURSEA DS    0H                      * * * *
*/*RECURSEA: D (YES,,NO,RECURSEB) IN ERASE MODE */
         USING RWORK,R1                USE GETMAIN AREA
         SPACE
         MVI   RFLAGS,ZERO             CLEAR FLAG BYTE TO ZERO
         BZ    *+EIGHT                 TEST ABOVE CONDITION CODE ---
*                                         SKIP FLAG SETTING IF ZERO
*/* P SET INDICATOR FOR ERASE MODE */
         SPACE
         OI    RFLAGS,RFERASE          CONTINUE IN ERASE MODE
*/*RECURSEB: P SET UP RETURN LINKAGE */
         ST    RBASE,RBASESV           SAVE LAST RWORK AREA ADDRESS
         ST    XPCE,RXPCESV            SAVE ADDRESS OF PCE TO RESUME AT
         ST    R2,RPCEAD               FOR USE IN FINDING KEYWORD
*                                         OFFSET
         ST    LINK1,RLINKSV           SAVE RETURN LINKAGE REGISTER
         DROP  R1                      DROP TEMPORARY BASE REGISTER
         SPACE
         LR    RBASE,R1                UPDATE RWORK BASE REGISTER
         USING RWORK,RBASE             SWITCH ASSEMBLER BACK TO RBASE
*/* P POINT TO FIRST PCE OR FIRST PCE IN SUBFIELD */
         SPACE
         LA    XPCE,TWO(R2)            BUMP PCE ADDRESS TO FIRST PCE OR
*                                         FIRST PCE IN SUBFIELD
         SPACE
*
* SELECT THE APPROPRIATE PCE PROCESSOR ROUTINE.
*
*/*NEXTPCE: D (YES,ENDFIELD,NO,) END-OF-FIELD PROCESSOR */
*/* D (YES,POSIT,NO,) POSITIONAL PROCESSOR */
*/* D (YES,KEYWD,NO,) KEYWD PROCESSOR */
*/* D (YES,NAMESKP,NO,) SKIP NAME PCE PROCESSOR */
*/* D (YES,PARS2CHK,NO,IDENT) IS THIS A DOBOL PCE? */
NEXTPCE  DS    0H                      SELECT MAIN PROCESSING ROUTINE
         NI    PFLAGS,HFF-PFDEFLT      CLEAR POSSIBLE DEFAULT TAKEN
*                                         FLAG
         TM    PFLAGS4,PFLSTEND        IS END OF SUBFIELD FOUND Y30NQJN
         BZ    NEXTOFF                 NO, CONTINUE             Y30NQJN
         OI    PFLAGS7,RPAREND         INDICATE END OF SUBFIELD Y30NQJN
NEXTOFF  DS    0H                                               Y30NQJN
         NI    PFLAGS4,HFF-PFSLASH-PFLSTEND-PFPDDATA-PFENDSET TURN OFF
*                                         POSSIBLE LIST END FLAG, SLASH
*                                         SCAN FLAG,PROMPT/DEFAULT FLAG
*                                         AND ENDBAKUP SET FLAG
         NI    PFLAGS5,HFF-INVPRMPT    RESET INVALID PROMPT FLAG A45352
         NI    PFLAGS7,HFF-DSNAMEF     END DSNAME VCE PROCESS    Y02666
         XR    R2,R2                   CLEAR WORK REGISTER TO ZERO
         IC    R2,PCEFLGB1(XPCE)       PICK UP TYPE INDICATOR FROM PCE
         N     R2,TYPEMASK             ISOLATE TYPE INDICATOR BITS
         SRL   R2,THREE                POSITION BITS FOR INDEXED BRANCH
         B     *+FOUR(R2)              BRANCH TO PCE PROCESSOR
*
MAINB    DS    0H                      USED FOR FUTURE COMPARANDS
*
ENDB     B     ENDFIELD                BRANCH TO END-OF-FIELD PROCESSOR
*
POSITBB  B     POSIT                   BRANCH TO POSITIONAL PROCESSOR
*
KEYWDB   B     KEYWDP                  BRANCH TO KEYWORD PROCESSOR
*
NAMEB    B     NAMESKP                 BRANCH TO SKIP NAME PCE PROCESS.
*
IDENTB   B     IDENT                   BRANCH TO IDENT PROCESSOR
RESERV   B     PARS2CHK                RESERVED WORD PCE         F41448
TERMB    B     PARS2CHK                TERM PCE                  F41448
OPRTR    EQU   *                       OPER PCE                  F41448
*/*PARS2CHK: D (YES,GOTOPRS2,NO,) HAS IKJPARS2 BEEN LOADED? */
PARS2CHK TM    CBFLAGS2,PARS2IN        HAS IKJPARS2 BEEN LOADED  F41448
         BO    GOTOPRS2                IF YES GO TO BRANCH TO    F41448
*                                      MACRO PROCESSOR           F41448
         LA    R2,QSTRINGA             IF FIRST TIME THROUGH,    F41448
*                                      INITIALIZE FOR IKJPARS2   F41448
         ST    R2,VCONAD               STORE VCON TABLE ADDRESS  F41448
*                                      IN WORK AREA              F41448
*/* P LOAD IKJPARS2 */
         LOAD  EP=IKJPARS2             LOAD IKJPARSW             F41448
         ST    R0,PARS2ADR             STORE ENTRY ADDRESS IN    F41448
*                                      WORK AREA                 F41448
         OI    CBFLAGS2,PARS2IN        INDICATE IKJPARS2 HAS     F41448
*                                      BEEN LOADED               F41448
*/* P SAVE IKJPARS BASE REGISTERS */
         ST    BASE3,BASE3SV           SAVE IKJPARS BASE         F41448
         STM   BASE2,RBASE,BASE2SV     REGISTERS                 F41448
*/*GOTOPRS2: P LOAD ENTRY POINT OF IKJPARS2 */
GOTOPRS2 L     R2,PARS2ADR             LOAD ENTRY POINT OF       F41448
*                                      IKJPARS2                  F41448
         LR    BASE1,PBASE             SET UP REGISTER 11 FOR    F41448
*                                      USE BY IKJPARS2 IN        F41448
*                                      ADDRESSING WORK AREA      F41448
*/* S () IKJPARS2: BRANCH TO COBOL PCE PROCESSOR */
         BR    R2                      BRANCH TO IKJPARS2        F41448
*****************************************************************F41448
*  THE FOLLOWING ROUTINE IS THE INTERFACR ROUTINE BETWEEN IKJPARS2    *
* AND IKJPARS.  ALL IKJPARS ROUTINES ARE ENTERED THGOUGH THIS    F41448
* CONTROLLER ROUTINE.                                            F41448
*****************************************************************F41448
         SPACE
*/*PARS2ENT: E ENTRY INTO PARSE FROM IKJPARS2 */
*/* P PREPARE TO TRANSFER CONTROL TO SUBROUTINE */
PARS2ENT LA    LINK1,RTRNAD            LOAD RETURN ADDRESS INTO  F41448
*                                      LINK1                     F41448
         LA    LINK2,RTRNAD            AND LINK2 AND STORE INTO  F41448
         ST    LINK2,CBLNKSV2          CBLNKSV2 SO THAT ANY      F41448
*                                      SUBROUTINE CALLED WILL    F41448
*                                      RETURN TO PROPER PLACE IF F41448
*                                      BEING CALLED BY THE COBOL F41448
*                                      MACRO SUPPORT             F41448
*/* R BRANCH TO APPROPRIATE SUBROUTINE */
         BR    R15                     BRANCH TO SUBROUTINE.     F41448
*                                      ADDRESS PLACED IN R15 BY  F41448
*                                      THE COBOL MACRO PROCES-   F41448
*                                      SORS BEFORE COMING TO     F41448
*                                      IKJPARS                   F41448
*/*RTRNAD: E RETURN FROM SUBROUTINE */
*/* P PRESERVE RET CODE +0, +4, +8, +12 */
RTRNAD   BAL   R15,RET1                RETURN ADDRESS FROM SUB-  F41448
*                                      ROUTINES IN ON +0, +4,    F41448
         BAL   R15,RET1                +8, OR +12.  THE SERIES   F41448
         BAL   R15,RET1                OF BAL'S AND THE SUBTRCT  F41448
         BAL   R15,RET1                PRESERVE THE RETURN       F41448
RET1     LA    R14,RTRNAD+4            GET ADDRESS IN R14 IN     F41448
*                                      ORDER TO PRESERVE RETURN  F41448
*                                      CODE                      F41448
         LA    R15,ZERO(R15)           ZERO HIGH ORDER BYTE FOR  F41448
*                                      SUBTRACT REGISTER         F41448
         SR    R15,R14                 PRESERVE RETURN CODE      F41448
*/* P RESTORE IKJPARS2 ENVIRONMENT */
         L     R14,CBLRET              LOAD ENTRY INTO IKJPARS2  F41448
*                                      FOR RETURN                F41448
         L     RBASE,AUTOBASE          RESTORE AUTOMATIC DATA    F41448
*                                      BASE REGISTER             F41448
         LM    R2,R3,TERMBASE          RESTORE IKJPARS2          F41448
*                                      ENVIRONMENT               F41448
         LR    BASE1,PBASE             WORK AREA BASE REG        F41448
*/* R () RETURN TO IKJPARS2 */
         BR    R14                     RETURN TO COBOL SUPPORT   F41448
*                                      MODULE                    F41448
         EJECT
***********************************************************************
*                                                                     *
*                    END-OF-FIELD ROUTINE                             *
*                                                                     *
*   THIS ROUTINE IS ENTERED FROM THE MAIN CONTROL ROUTINE WHEN AN     *
* IKJENDP OR AN IKJSUBF PCE IS ENCOUNTERED. IF A SUBFIELD IS BEING    *
* PROCESSED THE END OF THE SUBFIELD, A RIGHT PARENTHESIS, IS SEARCHED *
* FOR. IF NOT FOUND THE REMAINING PARAMETERS ARE CONSIDERED EXTRANEOUS*
* IF AN IKJKEYWD PCE WAS NEVER FOUND IN THE PCL OR INVALID KEYWORDS   *
* IF ONE WAS. IF THE END OF THE SUBFIELD WAS FOUND THE RECURSIVE      *
* WORKSPACE IS FREED.                                                 *
*   CONTROL IS THEN GIVEN TO THE EXIT ROUTINE IF NO MORE RECURSIVE    *
* WORKSPACES REMAIN OR TO THE KEYWD ROUTINE IF MORE REMAIN.           *
*                                                                     *
***********************************************************************
*/*ENDFIELD: D (YES,ENDFINDL,NO,) IN ERASE MODE */
         SPACE
ENDFIELD DS    0H                      END-OF-FIELD PROCESSOR
         TM    RFLAGS,RFERASE          ARE WE IN ERASE MODE
         BO    ENDFINDL                IF BIT ON YES --- SKIP SCANNING
*/*ENDFISCN: S SCANF: POP THE STACK IF POSSIBLE */
         SPACE
ENDFISCN DS    0H                      * * * *
         BAL   LINK1,SCANF             IF POSSIBLE, POP THE STACK
*
         NOP   ZERO                    +0 RETURN -NO MORE DATA - OK
*
*                                      +4 RETURN - MORE DATA
*/* S SKIPB: SKIP SEPARATORS */
         BAL   LINK2,SKIPB             BRANCH TO SKIP BLANKS SUBROUTINE
*
*/* D (YES,ENDFINDL,NO,) REACHED END OF INPUT */
         B     ENDFINDL                +0 RETURN - RIGHT PAREN
*
*                                      +4 RETURN - PPOINTR SET
*/* P INCREMENT SCAN POINTER */
         LA    XINPUT,ONE(XINPUT)      INCREMENT SCAN REGISTER
*/* D (YES,ENDFISMI,NO,) LAST LEVEL COMPLETE OR NO SUBFIELD */
         NC    RBASESV,RBASESV         WAS LAST LEVEL COMPLETE OR NO
*                                         SUBFIELD
         BZ    ENDFISMI                IF ZERO YES --- BRANCH
*/* D (YES,ENDFINDL,NO,ENDEXTRA) REACHED END OF INPUT */
         SPACE
         CLI   ZERO(XINPUT),RIGHTPRN   WAS A CLOSE PAREN FOUND
         BE    ENDFINDL                YES --- ALLOW IT TO BE SKIPPED
         SPACE
         CLI   ZERO(XINPUT),SEMICOLN   WAS END OF DATA SPECIFIED?Y02666
         BE    ENDFINDL                YES -- SKIP THE SEMICOLON Y02666
         TM    PFLAGS7,RPAREND         END OF SUBFIELD FOUND?   Y30NQJN
         BO    ENDFINDL                YES, CONTINUE END PROCESSY30NQJN
         B     ENDEXTRA                NO -- ERROR CONDITION -- BRANCH
*/*ENDFISMI: D (YES,,NO,ENDEXTRA) FIRST STACK IN CHAIN */
         SPACE
ENDFISMI DS    0H                      * * * *
         TM    PFLAGS5,RPRNFND         WAS RIGHT PAREN FOUND     Y01156
         BO    ENDFINDL                CONTINUE PROCESSING       Y01156
         L     R1,PIPDLCUR             LOAD PTR TO CURRENT STACK
         NC    ONE(THREE,R1),ONE(R1)   IS THIS FIRST STACK IN CHAIN
         BNZ   ENDEXTRA                IF NO BRANCH
*/* D (YES,,NO,ENDEXTRA) AT LAST LEVEL */
         SPACE
         CLI   PIPDLX,ZERO             DON'T ALLOW SEMICOLON EXCEPT AT
*                                         LAST LEVEL
         BNZ   ENDEXTRA                IF NOT --- BRANCH
*/* D (YES,,NO,ENDEXTRA) ENDING SEMICOLON */
         SPACE
         CLI   ZERO(XINPUT),SEMICOLN   IS IT THE ENDING SEMICOLON
         BNE   ENDEXTRA                NO -- ERROR CONDITION -- BRANCH
         SPACE
*
* FREE RECURSIVE WORKSPACE.
*
*/*ENDFINDL: L FREE RWORK AREA */
ENDFINDL DS    0H                      * * * *
         NI    PFLAGS5,HFF-RPRNFND     TURN OFF R. PAREN  FLAG   Y01156
         NI    PFLAGS7,HFF-RPAREND     TURN OFF SUBFIELD END FLGY30NQJN
         LR    R1,RBASE                INITIALIZE TEMPORARY BASE REG.
         SPACE
         DROP  RBASE                   DROP NORMAL BASE
         USING RWORK,R1                CREATE TEMPORARY BASE REGISTER
         SPACE
         L     XPCE,RXPCESV            RESTORE LAST PCE ADDRESS
         L     RBASE,RBASESV           RESTORE PREVIOUS RWORK BASE REG.
         L     LINK1,RLINKSV           RESTORE PREVIOUS LINKAGE REG.
         SPACE
         DROP  R1                      DROP TEMPORARY BASE REGISTER
         USING RWORK,RBASE             RE-ESTABLISH NORMAL BASE REG.
         SPACE
         FREEMAIN R,LV=RWORKSZ,A=(1)   RELEASE RWORK AREA
*/* D (YES,EXIT,NO,) LAST RECURSIVE WORKSPACE */
         SPACE
         LTR   RBASE,RBASE             WAS THAT THE LAST RECURSIVE
*                                         WORKSPACE
         BZ    EXIT                    YES IF ZERO --- BRANCH
         SPACE
         NI    PFLAGS3,HFF-PFMORE      CLEAR POSSIBLE 'WHAT TO DO WITH
*                                         RIGHT PAREN' FLAG
         NI    RFLAGS,HFF-RFKEYWDS     CLEAR CAUSE OF ENTRY FLAG
*/* R RETURN TO CALLER */
         BR    LINK1                   RETURN TO CALLER
         SPACE
*
* SOME DATA WAS LEFT IN THE INPUT BUFFER OR INSIDE OF A SUBFIELD BUT
* THE PCL WAS EXHAUSTED. SINCE RFLAGS IS ASSOCIATED WITH A SUBFIELD
* LEVEL THE MESSAGE TO BE ISSUED IS RELEVANT TO SUBFIELDS RATHER THAN
* TO THE ENTIRE BUFFER. IF NO SUBFIELDS WERE SPECIFIED IT CAN BE
* CONSIDERED AS SUBFIELD LEVEL ZERO. THE FLAG NEED NOT BE TURNED OFF
* SINCE WHEN THE END OF THE SUBFIELD IS FOUND THE RWORK AREA IS FREED.
*
* CHECK TO SEE IF AN 'INVALID KEYWORD' OR AN 'EXTRANEOUS
* INFORMATION' MESSAGE IS TO BE PRINTED. THE 'INVALID KEYWORD' MESSAGE
* IS WRITTEN INSTEAD OF THE 'EXTRANEOUS INFORMATION' MESSAGE IF AN
* IKJKEYWD PCE WAS ENCOUNTERED.
*
*/*ENDEXTRA: D (YES,ILLKEYWD,NO,) IKJEYWD PCE FOUND */
ENDEXTRA DS    0H                      * * * *
         TM    RFLAGS,RFPRES           WAS A IKJKEYWD PCE FOUND
         BO    ILLKEYWD                IF YES PRINT INVALID MESSAGE
*/* P COMPLETE LENGTH OF EXTRANEOUS DATA */
         SPACE
         LR    XINPUTB,XINPUT          SAVE BEGINNING OF EXTRA DATA
*                                         ADDRESS
         BCTR  XINPUT,ZERO             DECREMENT FOR NEXT INCREMENT
         SPACE
ENDEX1   DS    0H                      * * * *
         LA    XINPUT,ONE(XINPUT)      BUMP INPUT POINTER
         LR    R2,XINPUT               SAVE PTR FOR LATER SUBTRACTION
         C     XINPUT,ENDINPUT         END OF INPUT BUFFER
         BE    ENDEX2                  IF YES BRANCH
         SPACE
         NC    RBASESV,RBASESV         IS A SUBFIELD BEING PROCESSED
         BZ    ENDEX1                  IF NO REMAINDER OF BUFFER IS
*                                         EXTRANEOUS DATA
         SPACE
         CLI   ZERO(XINPUT),RIGHTPRN   END OF SUBFIELD
         BNE   ENDEX1                  IF NO BRANCH
         SPACE
ENDEX2   DS    0H                      * * * *
         SR    R2,XINPUTB              COMPUTE LENGTH OF EXTRA DATA
*/* S GETCORE: GET CORE FOR MESSAGE SEGMENT */
         LA    R1,FOUR(R2)             GET SIZE OF CORE FOR MESSAGE SEG
*                                         PLUS FOUR FOR HEADER
         BAL   LINK1,GETCORE           GET CORE FOR MESSAGE SEGMENT
         SPACE
*                                      CORE ADDRESS RETURNED IN R1
         ST    R1,SEGLIST+TWELVE       STORE ADDRESS IN LIST OF SEGMENT
         LA    R0,FOUR(R2)             GET SEGMENT SIZE
         STH   R0,ZERO(R1)             STORE SIZE IN SEGMENT
         MVI   TWO(R1),ZERO            SET FIRST BYTE OF OFFSET TO ZERO
         MVI   THREE(R1),OFFSET3       SET OFFSET TO LENGTH OF
*                                         'EXTRANEOUS INFORMATION' MSG
         LR    R15,XINPUTB             MOVE START OF DATA ADDRESS
         BCTR  R2,ZERO                 REDUCE LENGTH FOR 'EX'
         EX    R2,BUILDSEG             MOVE TEXT TO NEW SEGMENT
*/* P INDICATE 'EXTRANEOUS INFORMATION' MSG */
         MVI   MSGCODE,MSG17           INDICATE MESSAGE TO WRITE
*/* S WRITER1: WRITE THE MESSAGE */
         BAL   LINK1,WRITER1           WRITE THE MESSAGE
*/* D (YES,ENDFISCN) POP THE STACK UNTIL NO MORE DATA */
         SPACE
         BCT   XINPUT,ENDFISCN         POP STACK, IF POSSIBLE, UNTIL
*                                         ITS COMPLETELY FREE OF DATA
         EJECT
***********************************************************************
*                                                                     *
*                             EXIT ROUTINE                            *
*                                                                     *
*   THIS ROUTINE IS ENTERED FROM THE END-OF-FIELD ROUTINE WHEN THE    *
* ORIGINAL RECURSIVE WORKSPACE HAS BEEN FREED.                        *
*   IT IS ENTERED AT EXITNORM WHENEVER AN ABNORMAL TERMINATION OCCURS.*
*   IN THIS ROUTINE THE INPUT BUFFER OFFSET IS UPDATED, THE I/O       *
* ROUTINES ARE DELETED, THE PERMANENT WORKSPACE IS FREED AND CONTROL  *
* IS RETURNED TO PARSE'S CALLER WITH A RETURN CODE IN REGISTER 15.    *
*                                                                     *
***********************************************************************
*/*EXIT: P COMPUTE CURRENT OFFSET */
         SPACE
EXIT     DS    0H                      PARSE EXIT ROUTINE
         TM    PFLAGS5,INVFLG          IS AN INVALID BUFFER BEING
*                                      PROCESSED?                Y01156
         BO    CLEANUP                 YES, CLEANUP USER CORE    Y01156
         L     R2,FOUR(PBASE)          LOAD CALLERS SAVE AREA ADDRESS
         L     R2,TWENTY4(R2)          LOAD ORIGINAL INPUT PARAMETER
*                                         ADDRESS
         L     R3,TWENTY(R2)           LOAD ORIGINAL INPUT BUFFER ADR.
         LA    R3,ZERO(R3)             CLEAR HIGH ORDER BYTE
         MVC   PDWORD(TWO),ZERO(R3)    ALIGN ORIGINAL BUFFER LENGTH ON
*                                         PROPER BOUNDARY
         SR    XINPUT,R3               COMPUTE CURRENT OFFSET
         SH    XINPUT,H4               COMPUTE OFFSET TO SEMICOLON
         BM    EXITRST                 DOES NOT LIE WITHIN INPUT, RESET
*                                         TO ALL
         SPACE
         TM    PFLAGS,PFENDF           HAD WE RUN OFF THE END
         BO    EXITRST                 YES USE THIS OFFSET
         SPACE
         CH    XINPUT,PDWORD           SEE IF NEW OFFSET LIES WITHIN
*                                         INPUT BUFFER
         BL    EXITANS                 YES USE THIS OFFSET
*/*EXITRST: P REDUCE ORIGINAL BUFFER LENGTH BY LENGTH,OFFSET FIELDS */
         SPACE
EXITRST  DS    0H                      * * * *
         LH    XINPUT,PDWORD           GET ORIGINAL BUFFER LENGTH
         SH    XINPUT,H5               REDUCE BY SIZE OF LENGTH AND
*                                         OFFSET FIELDS
         SPACE
*
* UPDATE THE INPUT BUFFER OFFSET FIELD.
*
*/*EXITANS: P UPDATE OFFSET IN INPUT BUFFER */
EXITANS  DS    0H                      * * * *
         LA    XINPUT,ONE(XINPUT)      INCREMENT SCAN REGISTER TO NEXT
*                                         CHARACTER
         STH   XINPUT,PDWORD           STORE NEW OFFSET FOR MVC
         MVC   TWO(TWO,R3),PDWORD      UPDATE OFFSET IN INPUT BUFFER
         SPACE
*
* DELETE PUTLINE/PUTGET SERVICE ROUTINES.
*
*/*EXITNORM: L DELETE IKJPARS2 RTN. */
EXITNORM DS    0H                      ENTRY FROM CLEANUP
         SPACE
         TM    CBFLAGS2,PARS2IN        WAS IKJPARS2 LOADED BY THIS
*                                      CALL OF PARSE             Y02666
         BZ    PARS2INT                NO,BYPASS DELETE          Y02666
         DELETE EP=IKJPARS2            DELETE PARS2 LOAD MODULE  F41448
         SPACE
PARS2INT DS    0H                                                Y02666
         XR    LINK1,LINK1             ZERO WORK REGISTER
         TM    PFLAGS5,INVFLG          IS INVALID BUFFER BEING
*                                      PROCESSED?                Y01156
         BZ    EXITRC                  NO, CONTINUE PROCESSING   Y01156
         LA    LINK1,RCNOPRMT          YES,GET ERROR RETURN CODE Y01156
         B     EXITFREE                BYPASS SETTING OTHER RETURN CODE
*                                                                Y01156
EXITRC   DS    0H                                                Y01156
         IC    LINK1,RETCODE           LOAD THE RETURN CODE
EXITFREE DS    0H                                                Y01156
         LR    R1,PBASE                LOAD CORE ADDRESS FOR FREEMAIN
         L     PBASE,FOUR(PBASE)       RESTORE CALLERS SAVE AREA ADR.
         SPACE
         FREEMAIN R,LV=WORKSZ,A=(1)    RELEASE PERMANENT WORK AREA
*/* P LOAD THE RETURN CODE */
         SPACE
         LR    R15,LINK1               LOAD PROPER RETURN CODE REGISTER
*                                         FOR RETURN MACRO
*/* R EXIT FROM PARSE */
         SPACE
         RETURN (14,12),RC=(15)        EXIT FROM PARSE
         EJECT
***********************************************************************
*                                                                     *
*                         KEYWORD ROUTINE                             *
*                                                                     *
*   CONTROL IS OBTAINED FROM THE MAIN CONTROL ROUTINE. IF A KEYWORD   *
* PARAMETER IS CURRENTLY BEING PARSED CONTROL IS GIVEN TO THE KEYWORD *
* SCAN ROUTINE. OTHERWISE A DEFAULT IS PICKED UP, IF PROVIDED, AND    *
* SCANNED AS A NORMAL INPUT PARAMETER.                                *
*   CONTROL MAY BE PASSED TO THE MAIN CONTROL ROUTINE IF IN ERASE     *
* MODE OR A DEFAULT WAS NOT SUPPLIED.                                 *
*                                                                     *
***********************************************************************
*/*KEYWDP: P SET INDICATOR FOR IKJKEYWD PCE FOUND */
         SPACE
KEYWDP   DS    0H                      KEYWORD ROUTINE
         NI    PFLAGS5,HFF-SUBFLG      TURN OF SUBFIELD FLAG     Y01156
         OI    RFLAGS,RFPRES           INDICATE A IKJKEYWD PCE WAS
*                                         FOUND FOR A POSSIBLE MESSAGE
*                                         IN THE END-OF-FIELD ROUTINE
*/* D (YES,KEYWD,NO,) KEYWORD CURRENTLY BEING PARSED */
         TM    RFLAGS,RFKYPRSE+RFERASE IS KEYWORD PARSE REQUIRED
         BZ    KEYWD                   NO, GO TO PARSE THEN
         SPACE
         MVC   PDWORD(TWO),PCEPDEO(XPCE) ALIGN PDE OFFSET ON PROPER
*                                         BOUNDARY
         LH    R2,PDWORD               LOAD THE PDE OFFSET
         A     R2,XPDL                 GET TRUE ADDRESS OF PDE
*/* D (YES,KEYWDER1,NO,) PDE ALREADY FILLED IN */
         NC    ZERO(TWO,R2),ZERO(R2)   SEE IF PDE ALREADY FILLED
         BNZ   KEYWDER1                IF YES SEE IF ERASING
*/* D (YES,KEYWDPNX,NO,) IN ERASE MODE */
         SPACE
         TM    RFLAGS,RFERASE          NO DEFAULT IF ERASING
         BO    KEYWDPNX                GO TO FIRST NAME
*/* S PROMPTQ: CHECK FOR PROMPT/DEFAULT */
         SPACE
         BAL   LINK1,PROMPTQ           BRANCH TO PROMPT/DEFAULT ROUTINE
*
*/* D (YES,KEYWDPRC,NO,KEYWDPNX) NEW DATA RETURNED */
         B     KEYWDPRC                +0 RETURN - PROCESS NEW LINE
*
*                                      +4 RETURN - NO PROMPT OR DEFAULT
         B     KEYWDPNX                GET NEXT PCE
         SPACE
*
* SET UP TO SCAN NEW DATA.
*
*/*KEYWDPRC: P POINT TO NEW PCE FOR NEW INPUT BUFFER */
KEYWDPRC DS    0H                      * * * *
         L     XPCE,RPCEAD             REFETCH START OF SUBFIELD ADDR.
         MVC   PDWORD(TWO),ZERO(XPCE)  ALIGN OFFSET TO IKJKEYWD PCE ---
*                                         RTABLEAD POINTS TO THE
*                                         IKJSUBF PCE+1 --- ON PROPER
*                                         BOUNDARY
         L     XPCE,PTABLEAD           LOAD START OF PCL ADDRESS
         AH    XPCE,PDWORD             POINT TO NEW PCE FOR NEW INPUT
*                                         BUFFER
*/* D (,KEYWD) PARSE NEW KEYWORD */
         B     KEYWD                   BRANCH TO PARSE THE KEYWORD
*/*KEYWDER1: D (YES,,NO,KEYWDPNX) IN ERASE MODE */
         SPACE
KEYWDER1 DS    0H                      * * * *
         LA    R0,KEYWDER3             SET RETURN LINKAGE TO CONTINUE
         ST    R0,RLINKSV1             STORE IN CASE RECURSE
         SPACE
         TM    RFLAGS,RFERASE          IN ERASE MODE
         BZ    KEYWDPNX                NO --- BRANCH - PROCESS NORMALLY
         SPACE
*
* ENTRY POINT FROM THE KEYWORD SCAN SUBROUTINE WHEN A KEYWORD PDE
* WAS ALREADY FILLED IN AND MUST BE ERASED.
*
*/*KEYWDER4: P CLEAR KEYWORD NUMBER TO ZERO */
KEYWDER4 DS    0H                      * * * *
         LH    R3,ZERO(R2)             PICK UP KEYWORD NUMBER TO ERASE
*                                         R3 USED TO FIND CORRECT
*                                         IKJNAME PCE --- NAMESKP RTN
*                                         GETS CONTROL NEXT
         XC    ZERO(TWO,R2),ZERO(R2)   CLEAR OLD KEYWORD NUMBER TO ZERO
*/*KEYWDPNX: D (,NEXTPCE) GET NEXT PCE */
         SPACE
KEYWDPNX DS    0H                      * * * *
         BAL   LINK1,KEYWDX1           COMPUTE NEXT PCE ADDRESS
         SPACE
         B     NEXTPCE                 GET NEXT PCE
         EJECT
***********************************************************************
*                                                                     *
*                       SKIP KEYWORD PCE SUBROUTINE                   *
*                                                                     *
*   THE FUNCTION OF THIS ROUTINE IS TO SKIP OVER A KEYWORD PCE.       *
*        RETURN - LINK1                                               *
*                                                                     *
***********************************************************************
*/*KEYWDX1: E SKIP KEYWORD PCE ROUTINE */
*/*KEYWDX2: P ADD PCE ADDRESS TO LENGTH OF PDE */
         SPACE
KEYWDX1  DS    0H                      SKIP IKJKEYWD PCE SUBROUTINE
         ST    XPCE,PKEYWDPC           SAVE THE CURRENT PCE ADDRESS
         MVC   PDWORD(TWO),PCEPDEO(XPCE) ALIGN PDE OFFSET FIELD ON
*                                         PROPER BOUNDARY
         LH    R1,PDWORD               LOAD THE PDE LENGTH
         A     R1,XPDL                 GET TRUE ADDRESS OF PDE
         ST    R1,PKEYWDPS             SAVE ADDRESS FOR FUTURE USE IN
*                                         CASE OF A MATCH
         MVC   PDWORD(TWO),PCELEN(XPCE) ALIGN PCE LENGTH FIELD ON
*                                         PROPER BOUNDARY
         AH    XPCE,PDWORD             BUMP PTR TO NEXT PCE
*/* R RETURN TO CALLER */
         BR    LINK1                   RETURN TO CALLER
         EJECT
***********************************************************************
*                                                                     *
*                        SKIP IKJNAME PCE ROUTINE                     *
*                                                                     *
*   THIS ROUTINE IS ENTERED FROM THE MAIN CONTROL ROUTINE WHEN AN     *
* IKJNAME PCE IS ENCOUNTERED IN THE PCL. IF NOT IN KEYWORD ERASE MODE *
* THE NEXT PCE ADDRESS IS OBTAINED AND THE MAIN CONTROL ROUTINE GETS  *
* CONTROL. IF IN ERASE MODE, THE PCE OF THE CORRESPONDING IKJNAME     *
* SUBFIELD IS OBTAINED, IF ONE WAS SPECIFIED, AND ANOTHER RECURSIVE   *
* WORK AREA IS OBTAINED. SINCE A KEYWORD MAY HAVE A SUBFIELD WITH     *
* POSITIONAL PARAMETERS OR KEYWORDS IN IT THE SUBFIELD PDE MUST       *
* ALSO BE ERASED.                                                     *
*        ENTRY - IF ERASE MODE R3 CONTAINS NUMBER OF IKJNAME PCE      *
*                LOOKING FOR                                          *
*                                                                     *
***********************************************************************
*/*NAMESKP: D (YES,,NO,NAMESKP3) IN ERASE MODE */
         SPACE
NAMESKP  DS    0H                      SKIP IKJNAME PCE ROUTINE
         TM    RFLAGS,RFERASE          IN ERASE MODE
         BZ    NAMESKP3                NO --- NORMAL OPERATION - BRANCH
*/* D (YES,,NO,NAMESKP3) THIS THE IKJNAME PCE LOOKING FOR */
         SPACE
         BCT   R3,NAMESKP3             IF IN ERASE MODE - IS THIS THE
*                                         IKJNAME PCE LOOKING FOR
         SPACE
*                                      WHEN FALL THROUGH ANSWER YES
         SPACE
*
* SET UP TO ERASE ANY SUBFIELD INFORMATION THAT MAY BE IN THE PDL.
*
*/* D (YES,,NO,KEYWDER2) SUBFIELD SPECIFIED */
         TM    PCEFLGB1(XPCE),PCEFSUBF IS A SUBFIELD SPECIFIED
         BZ    KEYWDER2                NO LEAVE ERASE FOR THIS ONE
*/* P GET TRUE ADDRESS OF SUBFIELD PCE */
         SPACE
         XR    R2,R2                   CLEAR WORK REG TO ZERO
         IC    R2,PCENAML(XPCE)        PICK UP LENGTH - 1 OF NAME
         AR    R2,XPCE                 ADD PCE ADDRESS TO POINT PAST
*                                         NAME FIELD
         MVC   PDWORD(TWO),PCENAMN+ONE(R2) ALIGN SUBFIELD OFFSET ON
*                                         PROPER BOUNDARY
         LH    R2,PDWORD               LOAD SUBFIELD OFFSET
         A     R2,PTABLEAD             GET TRUE ADDRESS OF SUBFIELD PCE
*/* L GO TO RECURSE TO OBTAIN NEW RECURSIVE WORKSPACE */
         BAL   LINK1,RECURSE           OBTAIN NEW RECURSIVE WORKSPACE
*/*KEYWDER2: D (YES,,NO,KEYWDFNO) SUBFIELD HAS KEYWDS IN IT */
         SPACE
KEYWDER2 DS    0H                      * * * *
         L     R15,RLINKSV1            ON RETURN FROM RECURSE LEAVE
         BR    R15                        ERASE MODE FOR THIS KEYWORD
*/*KEYWDER3: P SET INFINITE COUNT IF STILL HIGH */
         SPACE
KEYWDER3 DS    0H                      * * * *
         SR    R3,R3                   SET INFINITE COUNT IF STILL HIGH
*/*NAMESKP3: D (,NEXTPCE) GET NEXT PCE */
         SPACE
NAMESKP3 DS    0H                      * * * *
         MVC   PDWORD(TWO),PCELEN(XPCE) ALIGN PCE LENGTH ON PROPER
*                                         BOUNDARY
         AH    XPCE,PDWORD             POINT TO NEXT PCE IN LIST
         B     NEXTPCE                 OBTAIN NEXT PCE
         EJECT
***********************************************************************
*                                                                     *
*                 SELECT POSITIONAL PARAMETER ROUTINE                 *
*                                                                     *
*   THE FOLLOWING ROUTINES PROCESS THE VARIOUS PARAMETERS DESCRIBED   *
* BY AN IKJPOSIT PCE. THE POSITIONAL PARAMETER TYPE IS USED IN THE    *
* SELECTION OF THE APPROPRIATE ROUTINE.                               *
*                                                                     *
***********************************************************************
*/*POSIT: D (YES,,NO,POSIT1) IN ERASE MODE */
         SPACE
POSIT    DS    0H                      SELECT POSITIONAL ROUTINE
         TM    RFLAGS,RFERASE          SHOULD SCANNING BE DONE
         BO    POSIT1                  NO IF IN ERASE MODE --- BRANCH
*/* S SCANF: POP THE STACK IF POSSIBLE */
         SPACE
         BAL   LINK1,SCANF             DROP LEVEL IN PUSH DOWN LIST IF
*                                         POSSIBLE
*
         NOP   ZERO                    +0 RETURN - NO INPUT DATA LEFT
*
*                                      +4 RETURN - DATA REMAINS IN
*                                         CURRENT BUFFER OR POP OCCURED
         SPACE
*
* SELECT THE POSITIONAL ROUTINE TO GET CONTROL. IF IN ERASE MODE R2
* SHOULD CONTAIN THE MASSAGED POSITIONAL TYPE BEFORE BRANCHING TO THE
* ERASE ROUTINE.
*
*/*POSIT1: P GET POSITIONAL TYPE BYTE */
POSIT1   DS    0H                      * * * *
         XR    R2,R2                   CLEAR WORK REG TO ZERO
         IC    R2,PCEPOST(XPCE)        PICK UP THE POSITIONAL TYPE BYTE
         SLL   R2,TWO                  MULTIPLY TYPE FLAG BY FOUR
*/* D (YES,POSITERS,NO,) IN ERASE MODE */
         TM    RFLAGS,RFERASE          ARE WE IN ERASE MODE
         BO    POSITERS                BRANCH TO POSITIONAL ERASE RTN.
         SPACE
         XC    TEMPPDE(LTPDE),TEMPPDE  ZERO TEMPORARY STORAGE AREA
*                                         FOR PDE
         B     *+FOUR(R2)              BRANCH INTO BRANCH TABLE
*
POSITB   DS    0H                      LABEL USED TO DETERMINE AT A
*                                         LATER TIME WHICH BRANCH
*                                         WAS TAKEN
*
*/* D (YES,INVPARMS,NO,) INVALID POSITIONAL TYPE */
*/* D (YES,DELIMITR,NO,) DELIMITER */
*/* D (YES,STRING,NO,) SELF-DELIMITING STRING */
*/* D (YES,VALUE,NO,) VALUE TYPE */
*/* D (YES,ADDRESS,NO,) ADDRESS */
*/* D (YES,PSTRING,NO,) PARENTHESIZED STRING */
*/* D (YES,USERID,NO,) USERID */
*/* D (YES,DSNAME,NO,) DSNAME */
*/* D (YES,DSNAME,NO,) ASTERISK FOR DSNAME */
*/* D (YES,QSTRING,NO,SPACE) QUOTED STRING - IF NOT, MUST BE SPACE */
         B     INVPARMS                TYPE 0  - NONEXISTENT TYPE
*
DELIMB   B     DELIMITR                TYPE 1  - DELIMITER
*
STRINB   B     STRING                  TYPE 2  - SELF-DELIMITING STRING
*
VALUEB   B     VALUE                   TYPE 3  - VALUE
*
ADDRB    B     ADDRESS                 TYPE 4  - ADDRESS
*
PSTRIB   B     PSTRING                 TYPE 5  - PARENTHESIZED STRING
*
USIDB    B     USERID                  TYPE 6  - USERID
*
DSNAMB   B     DSNAME                  TYPE 7  - DSNAME
*
DSTHIB   B     DSNAME                  TYPE 8  - * FOR DSNAME
*
QSTRIB   B     QSTRING                 TYPE 9  - QUOTED STRING
*
SPACEB   B     SPACE                   TYPE 10 - SPACE
*                                                                Y02666
JOBNAMB  B     JOBNAME                 TYPE 11 -  JOBNAME        Y02666
*                                                              @Z40RPKQ
UID2PSW  B     UID2PSWD                TYPE 12 - USERID WITH TWO
*                                      PASSWORDS               @Z40RPKQ
         EJECT
***********************************************************************
*                                                                     *
*               POSITIONAL DELIMITER ROUTINE                          *
*                                                                     *
*    THIS ROUTINE PROCESSES THE DELIMITER OF A SELF-DEFINED STRING.   *
* THE FOLLOWING ARE THE CHARACTERS WHICH MAY DELIMIT A SELF-DEFINED   *
* STRING - ANY ENTERABLE CHARACTER EXCEPT A DIGIT, LEFT PAREN,        *
* RIGHT PAREN, SEMICOLON, BLANK, COMMA, TAB, ASTERISK, OR NEW LINE    *
* CHARACTER.  IF THE FIRST NON-BLANK CHARACTER IS NOT A SUITABLE      *
* DELIMITER, THE STRING IS CONSIDERED MISSING.  A NEW LINE CHARACTER  *
* IS SAVED FOR POSSIBLE COMPARES FOR THE END OF THE STRING AND A      *
* FLAG IS SET TO INDICATE THE STRING SHOULD BE PROMPTED FOR WHEN A    *
* STRING PCE IS PROCESSED.  IF THE FIRST NON-BLANK CHARACTER IS A     *
* SUITABLE DELIMITER, IT IS SAVED FOR FUTURE COMPARES FOR THE END     *
* OF THE STRING.                                                      *
*                                                                     *
***********************************************************************
*/*DELIMITR: S SKIPB: SKIP SEPARATORS */
         SPACE
DELIMITR DS    0H                      DELIMITER ROUTINE
         BAL   LINK2,SKIPB             SKIP SEPARATORS TO DELIMITER
*
*/* D (YES,DELIMNL,NO,) REACHED END OF INPUT */
         B     DELIMNL                 +0 RETURN, REACHED END OF INPUT,
*                                         STRING IS MISSING
*
*                                      +4 RETURN, FOUND NON-SEPARATOR
*
         LA    XINPUT,ONE(XINPUT)      GET NEXT CHARACTER
*/* S TYPETEST: CHECK FOR LETTER OR SPECIAL CHARACTER */
         LA    R1,ALPHA+NDLIMSPC       IS DELIM A LETTER OR SPECIAL
         BAL   LINK1,TYPETEST             CHARACTER
*
*/* D (YES,,NO,DELIMNL1) DELIMITER IS LETTER OR SPECIAL CHARACTER */
         B     DELIMNL1                +0 RETURN - NO, INVALID DELIM,
*                                         THEN STRING IS MISSING
*
*                                      +4 RETURN - YES, BUT CHECK FOR
*                                         ASTERISK AND LEFT PAREN
*
*/* D (YES,DELIMNL1,NO,) DELIMITER IS AN ASTERISK */
         CLI   ZERO(XINPUT),ASTERISK   IS DELIM AN ASTERISK
         BE    DELIMNL1                YES, THEN DELIM IS INVALID AND
*                                         STRING IS MISSING
*/* D (YES,DELIMNL1,NO,) DELIMITER IS LEFT PAREN */
         SPACE
         CLI   ZERO(XINPUT),LEFTPRN    IS DELIM A LEFT PAREN
         BE    DELIMNL1                YES, THEN DELIM IS INVALID AND
*                                         STRING IS MISSING
*/* P SAVE DELIMITER FOR FINDING END OF STRING */
         SPACE
         MVC   PDELIM,ZERO(XINPUT)     SAVE THE DELIMITER FOR FUTURE
*                                         COMPARES FOR END OF STRING
         NI    PFLAGS3,HFF-PFSTPRMT    CLEAR POSSIBLE PROMPT-FOR-STRING
*                                         INDICATOR
         NI    PFLAGS4,HFF-PFENDLIM    CLEAR POSSIBLE END-DELIMITER
*                                       FOUND INDICATOR
*/* D (,POSITX3) EXIT */
         B     POSITX3                 EXIT
*/*DELIMNL1: P BACK UP SCAN POINTER */
         SPACE
DELIMNL1 DS    0H                      * * * *
         BCTR  XINPUT,ZERO             BACK UP INPUT POINTER
*/*DELIMNL: P SAVE NEW LINE CHARACTER */
         SPACE
DELIMNL  DS    0H                      * * * *
         MVI   PDELIM,NLCHAR           STORE NEW LINE CHARACTER FOR
*                                         COMPARES FOR END OF STRING
*                                         AFTER PROMPT OR DEFAULT
*/* P SET INDICATOR FOR PROMPT */
         OI    PFLAGS3,PFSTPRMT        SET PROMPT-FOR-STRING INDICATOR
*/* D (,POSITX3) EXIT ROUTINE */
         B     POSITX3                 EXIT
         EJECT
***********************************************************************
*                                                                     *
*            POSITIONAL SELF-DELIMITING STRING ROUTINE                *
*                                                                     *
*    THIS ROUTINE PROCESSES A STRING WHICH IS DELIMITED BY A SELF-    *
* DEFINED DELIMITER.  IT ASSUMES A DELIMITER PCE HAS ALREADY BEEN     *
* PROCESSED.  IF THE 'DELIMITER' WAS AN UNSUITABLE DELIMITER A FLAG   *
* WAS SET BY THE DELIMITER ROUTINE INDICATING THE STRING SHOULD BE    *
* PROMPTED FOR IF REQUIRED.  THE DATA RECEIVED FROM A PROMPT OR       *
* DEFAULT DOES NOT INCLUDE DELIMITERS.  THE END OF THE STRING IS      *
* FOUND WHEN THE SELF-DEFINED DELIMITER IS SCANNED OR THE END OF THE  *
* INPUT IS REACHED.  NULL STRINGS HAVE A POINTER SET AND A LENGTH     *
* OF ZERO.  IF THE STRING IS REQUIRED A NULL STRING MUST BE ENTERED   *
* AS TWO CONTIGUOUS SELF-DEFINED DELIMITERS.  IF A STRING IS NOT      *
* REQUIRED A NULL STRING MAY BE DELIMITED BY THE SELF-DEFINED         *
* DELIMITER OR BY THE END OF THE INPUT.                               *
*                                                                     *
***********************************************************************
*/*STRING: P DO NOT SKIP BLANKS AFTER A PROMPT */
*/* D (YES,,NO,STRINGN) DELIMITER IS A QUOTE */
*/* D (YES,,NO,STRINGN) SPECIAL STRING HANDLING REQUESTED */
*/* D (YES,,NO,QSTRING) FIRST TIME THROUGH */
*/* P BACK UP SCAN POINTER ONE PLACE */
*/* D (,QSTRING) TREAT AS QUOTED STRING */
*/*STRINGN: P TURN OFF FIRST TIME SWITCH FOR QSTRING */
         SPACE
STRING   DS    0H                      SELF-DELIMITING STRING ROUTINE
         CLI   PDELIM,QUOTE            IS DELIMITER A QUOTE      S21105
         BNE   STRINGN                 NO, CONTINUE              S21105
         TM    PCEFLGB2(XPCE),PCEFQSTR IS SPECIAL STRING HANDLING
*                                         REQUESTED              S21105
         BZ    STRINGN                 NO, CONTINUE              S21105
         TM    PFLAGS5,PFSQSTR         IS THIS THE FIRST TIME THROUGH
*                                                                S21105
         BZ    STRINGT                 YES, SET FLAG             S21105
         B     QSTRING                 NO, BRANCH TO PROCESS AS QSTRING
*                                                                S21105
STRINGT  OI    PFLAGS5,PFSQSTR         INDICATE SPECIAL HANDLING DONE
*                                         ONCE                   S21105
         BCT   XINPUT,QSTRING          BRANCH TO PROCESS AS QSTRING
*                                                                S21105
STRINGN  NI    PFLAGS5,HFF-PFSQSTR     TURN OFF SPECIAL HANDLING FLAG
*                                                                S21105
         OI    RFLAGS,RFNOSKIP         INDICATE BLANKS SHOULD NOT BE
*/* D (YES,,NO,STRINGST) PROMPT IS REQUIRED */
*/* S PROMPTQ: TEST FOR PROMPT/DEFAULT DATA */
*/* D (YES,STRBUMP,NO,POSITX2) DATA RETURNED */
*/*STRINGST: P INCREMENT SCAN POINTER */
*/* D (YES,,NO,STRPSET) REACHED END OF INPUT */
*/* S PROMPTQ: TEST FOR PROMPT/DEFAULT DATA */
*                                         SKIPPED AFTER A PROMPT
         TM    PFLAGS3,PFSTPRMT        IS STRING MISSING
         BZ    STRINGST                NO - GO SET POINTER
         SPACE
         BAL   LINK1,PROMPTQ           TEST FOR PROMPT OR DEFAULT
*
         B     STRBUMP                 +0 RETURN - RESCAN NEW DATA
*
         B     POSITX2                 +4 RETURN - NO DATA, TAKE NULL
*                                         PDE EXIT
         SPACE
STRINGST DS    0H                      * * * *
         LA    R2,ONE(XINPUT)          BUMP POINTER TO NEXT CHARACTER
         C     R2,ENDINPUT             IS PTR AT END OF INPUT
         BL    STRPSET                 NO, GO SET PPOINTER
         SPACE
         BAL   LINK1,PROMPTQ           YES, CHECK FOR PROMPT OR DEFAULT
*
*/* D (YES,STRBUMP,NO,) DATA RETURNED */
         B     STRBUMP                 +0 RETURN - RESCAN NEW DATA
*
*                                      +4 RETURN - NO DATA RETURNED,
*                                         PROCESS NULL STRING
*/* D (YES,,NO,POSITX2) END DELIMITER FOUND FOR PREVIOUS STRING */
         TM    PFLAGS4,PFENDLIM        WAS AN END DELIMITER FOUND
*                                         FOR A PREVIOUS STRING
         BZ    POSITX2                 NO, TAKE NO PDE EXIT
*                                       YES, PROCESS NULL STRING
*/*STRBUMP: P POINT TO NEXT CHARACTER */
         SPACE
STRBUMP  DS    0H                      * * * *
         LA    R2,ONE(XINPUT)          GET PTR TO NEXT CHARACTER
*/*STRPSET: P SET POINTER TO CHAR. AFTER SELF-DEFINED DELIMITER */
         SPACE
STRPSET  DS    0H                      * * * *
         ST    R2,PPOINTR              SET PPOINTR TO CHARACTER AFTER
*                                         SELF-DEFINED DELIMITER OR
*                                         FIRST CHARACTER OF DATA
*                                         RETURNED
         SPACE
*
* LOOP THROUGH STRING LOOKING FOR DELIMITER OR END OF INPUT.
*
*/*STRINRPT: P INCREMENT SCAN POINTER */
STRINRPT DS    0H                      * * * *
         LA    XINPUT,ONE(XINPUT)      BUMP SCAN PTR BY ONE
         LR    XINPUTB,XINPUT          SAVE PTR IN BACKUP REGISTER
*/* D (YES,STRINEND,NO,) REACHED END OF INPUT */
         C     XINPUT,ENDINPUT         END OF INPUT DATA
         BNL   STRINEND                YES BRANCH
*/* D (YES,STRINRPT,NO,) SPACE/STRING SEQUENCE */
         SPACE
         TM    PFLAGS3,PFSPACE         IS THIS A SPACE/STRING PARAMETER
*                                         SEQUENCE
         BO    STRINRPT                IF YES CONTINUE TO END OF BUFFER
*/* D (YES,,NO,STRINRPT) END OF SELF-DELIMITING STRING */
         SPACE
         CLC   PDELIM,ZERO(XINPUT)     END OF SELF-DELIMITING STRING
         BNE   STRINRPT                IF NO BRANCH
         OI    PFLAGS4,PFENDLIM        IF YES, TURN ON DELIMITER FOUND
*/* P SET INDICATOR FOR DELIMITER FOUND */
*                                         FLAG
*/*STRINEND: P COMPUTE AND SAVE LENGTH OF STRING */
         SPACE
STRINEND DS    0H                      ENTERED WHEN END OF STRING
         S     XINPUTB,PPOINTR         COMPUTE LENGTH OF STRING
         STH   XINPUTB,PLENGTH         STORE LENGTH
         NI    PFLAGS3,HFF-PFSPACE     TURN OFF POSSIBLE FLAG
*/* D (,POSITX1) EXIT */
         B     POSITX1                 EXIT - GET NEXT PCE
         EJECT
***********************************************************************
*                                                                     *
*                       POSITIONAL VALUE ROUTINE                      *
*                                                                     *
*    A VALUE CONSISTS OF A TYPE-CHARACTER FOLLOWED BY A STRING        *
* ENCLOSED IN QUOTES - X'STRING'.  THE TYPE-CHARACTER MUST BE AN      *
* ALPHABETIC OR NATIONAL CHARACTER.  THE STRING MAY CONSIST OF ANY    *
* COMBINATION OF CHARACTERS OF ANY LENGTH.  A LIST OF VALUES AND A    *
* RANGE OF VALUES ARE ALLOWED.  IF THE FIRST NON-BLANK CHARACTER IS   *
* NOT ALPHABETIC, THE VALUE IS CONSIDERED MISSING.  THE VALUE IS      *
* ALSO CONSIDERED MISSING IF THE CHARACTER AFTER THE TYPE-            *
* CHARACTER IS NOT A QUOTE.  THE TYPE-CHARACTER IS RAISED TO          *
* UPPER CASE.  THE STRING PORTION IS PROCESSED BY THE QSTRING         *
* ROUTINE.  IF THE ENDING QUOTE IS LEFT OFF, THE END OF THE           *
* BUFFER DELIMITS THE STRING.  A MESSAGE IS ISSUED TO INDICATE THIS   *
* SITUATION TO THE USER.                                              *
*                                                                     *
***********************************************************************
*/*VALUE: P SAVE PDE SIZE */
         SPACE
VALUE    DS    0H                      VALUE ROUTINE
         LA    R1,SEVEN                GET PDE SIZE-1
         STC   R1,PPCOUNT              SAVE
*/* D (YES,ILLVALU,NO,) INPUT ENDED AFTER LEFT PAREN WAS FOUND */
*/* S SKIPB: SKIP SEPARATORS */
         BAL   LINK2,SKIPB             BRANCH TO SKIP SEPARATORS
*
*/* D (YES,VALUEPRQ,NO,) REACHED END OF INPUT */
         B     VALUEPRQ                +0 RETURN - END OF INPUT DATA
*
*/* S LISTT: CHECK FOR A LIST */
         BAL   LINK1,LISTT             +4 RETURN - CHECK FOR A LIST
         SPACE
         B     ILLVALU                 +0 RETURN, INPUT ENDED AFTER
*                                         LEFT PAREN WAS FOUND, INVALID
*                                         PARM
         SPACE
*                                      +4 RETURN, NO LIST OR SCAN
*                                         POINTER ADJUSTED TO FIRST
*                                        PARM IN LIST
         SPACE
*
* ENTRY POINT TO RESCAN A VALUE AFTER PROMPTING.
*
*/*VALUERSC: P RESCAN VALUE AFTER PROMPTING */
VALUERSC DS    0H                      * * * *
         MVC   INVPSAVE,PPOINTR        SAVE PTR FOR INVALID MSG
*/*VAL2RSC: P SCAN POSSIBLE 2ND RANGE VALUE */
VAL2RSC  DS    0H                      ENTRY TO SCAN 2ND RANGE VALUE
         LA    XINPUT,ONE(XINPUT)      POINT TO NEXT INPUT CHARACTER
*/* S TYPETEST: TEST FOR VALID ALPHABETIC CHARACTER */
         LA    R1,ALPHA                TEST FOR ALPHABETIC
         BAL   LINK1,TYPETEST          CHARACTER
*/* D (YES,VALUPRQX,NO,) INVALID CHARACTER FOUND */
         SPACE
         B     VALUPRQX                +0 RETURN - INVALID, VALUE IS
*                                         MISSING
*
*                                      +4 RETURN - VALID CHARACTER
*/* P COPY TYPE FIELD TO TEMPORARY PDE */
         MVC   DATAFLB1(ONE),ZERO(XINPUT) COPY TYPE FIELD TO TEMP. PDE
         L     R15,AUPTAB              GET ADDRESS OF TRANSLATE TABLE
         TR    DATAFLB1(ONE),ZERO(R15)  RAISE TO UPPERCASE
         LA    XINPUT,ONE(XINPUT)      INCREMENT SCAN REGISTER
         LR    XINPUTB,XINPUT          SET BACKUP REGISTER
*/* D (YES,,NO,VALENTRY) REACHED END OF INPUT AFTER FIRST CHARACTER */
         C     XINPUT,ENDINPUT         END OF INPUT DATA
         BL    VALENTRY                NO - CONTINUE PROCESSING USING
*                                         QSTRING CODE
         BCTR  XINPUT,ZERO             YES - BACKUP AND TRY TO PROMPT
         SPACE
*
* BRANCH TO PROMPT/DEFAULT ROUTINE.
*
*/* VALUPRQX: P PREPARE TO PROMPT */
VALUPRQX DS    0H                      * * * *
         BCTR  XINPUT,ZERO             REDUCE SCAN PTR BY ONE
         SPACE
VALUEPRQ DS    0H                      * * * *
*/*VALUEPRQ: D (YES,ILLVALU,NO,) FIRST VALUE OF A RANGE WAS FOUND */
         TM    PFLAGS2,RNGEVAL1        WAS THE FIRST VALUE OF RANGE
*                                         FOUND
         BO    ILLVALU                 YES - INVALID VALUE --- BRANCH
*/* S PROMPTQ: TEST FOR PROMPT/DEFAULT DATA */
         SPACE
         BAL   LINK1,PROMPTQ           TEST FOR PROMPT OR DEFAULT
*
*/* D (YES,,NO,VALUERSC) NO PROMPT OR DEFAULT */
         B     VALUERSC                +0 RETURN - NEW DATA TO SCAN
*
*                                      +4 RETURN - NO PROMPT OR DEFAULT
*/* P CLEAR TYPE CODE FIELD */
         MVI   DATAFLB1,ZERO           CLEAR TYPE CODE FIELD
*/* D (,POSITX2) BRANCH TO NULL DATA EXIT */
         B     POSITX2                 BRANCH TO NULL DATA EXIT
         EJECT
***********************************************************************
*                                                                     *
*                       STORAGE ALLOCATION SUBROUTINE                 *
*                                                                     *
*   REGISTER RESTRICTIONS -                                           *
*                         R2 OR R3 CANNOT BE USED BY THIS ROUTINE     *
*                                                                     *
***********************************************************************
         SPACE
*/*STALOC: E STORAGE ALLOCATION SUBROUTINE */
STALOC   DS    0H                      STORAGE ALLOCATION SUBROUTINE
*/* P ROUND AMOUNT OF STORAGE REQUESTED TO 8 */
         LA    R1,SEVEN(R1)            ROUND AMOUNT OF STORAGE
         N     R1,EIGHTMAK                REQUESTED TO EIGHT
         LR    R0,R1                   SET LENGTH REQUIRED
*/* D (YES,STALOALX,NO,) MORE STORAGE REQUESTED THAN NORMAL */
         C     R0,MAXBLKSZ             MORE STORAGE REQUESTED THAN
*                                         NORMAL ALLOCATION
         BNL   STALOALX                YES GET NEW CORE
         SPACE
*/*STALOFST: P LOAD ADDR OF INTERNAL MAIN STORAGE SPACE ANCHOR */
STALOFST DS    0H                      * * * *
         LA    R15,PANCHORT            LOAD ADDRESS OF INTERNAL MAIN
*                                         STORAGE SPACE ANCHOR
         SPACE
*/*STALONXT: P LOAD NEXT ELEMENT ADDRESS */
STALONXT DS    0H                      * * * *
         LR    R1,R15                  SAVE BACKUP
         L     R15,ZERO(R15)           LOAD NEXT ELEMENT ADDRESS
*/* D (YES,,NO,STALOALO) ANY STORAGE LEFT */
         LTR   R15,R15                 ANY STORAGE LEFT
         BZ    STALOALO                IF NO ALLOCATE MORE
         SPACE
*/* D (YES,,NO,STALONXT) IS IT ENOUGH */
         C     R0,FOUR(R15)            IF YES IS IT ENOUGH
         BH    STALONXT                NO TRY NEXT ELEMENT
         SPACE
*/* D (YES,STALOSPL,NO,) IS IT EQUAL */
         BE    STALOSPL                EQUAL --- SPECIAL CHAINING
         SPACE
*/* P COMPUTE LEFTOVER AMOUNT SINCE THERE'S MORE THAN ENOUGH */
         LR    R14,R15                 MORE THAN ENOUGH --- COMPUTE
         AR    R14,R0                     LEFTOVER AMOUNT
         MVC   ZERO(FOUR,R14),ZERO(R15) RESET FORWARD CHAIN
         ST    R14,ZERO(R1)            SET NEW FORWARD CHAIN
         L     R1,FOUR(R15)            PICK UP LENGTH
         SR    R1,R0                   GET REMAINDER
         ST    R1,FOUR(R14)            STORE REMAINDER
         SPACE
*/*STALOXIT: P CLEAR OLD CHAINING INFO */
STALOXIT DS    0H                      * * * *
         LR    R1,R15                  GET RETURN ADDRESS
         XC    ZERO(EIGHT,R1),ZERO(R1) CLEAR OLD CHAINING INFO
*/* R RETURN TO CALLER */
         BR    LINK2                   RETURN TO CALLER
         SPACE
*/*STALOSPL: P COPY FORWARD CHAIN */
STALOSPL DS    0H                      * * * *
         MVC   ZERO(FOUR,R1),ZERO(R15) COPY FORWARD CHAIN
*/* D (,STALOXIT) EXIT */
         B     STALOXIT                EXIT TO CALLER
         SPACE
*/*STALOALO: P INDICATE 248 BYTE CHUNK */
STALOALO DS    0H                      * * * *
         L     R1,MAXBLKSZ             INDICATE NEED 248 BYTE CHUNK
         SPACE
*/*STALOALX: S GETCORE: GET CORE REQUESTED */
STALOALX DS    0H                      * * * *
         AL    R1,SPOVRHD              ADD SUBPOOL AND EIGHT BYTE
*                                         OVERHEAD FOR STORAGE CHAINS
         STM   R0,R1,PDWORD            SAVE REQUEST AND REQUIRED SIZES
         BAL   LINK1,GETCORE           LINK TO GETCORE TO DO
*                                         CONDITIONAL GETMAIN FOR SPACE
         SPACE
*                                      STORAGE ADDRESS RETURNED IN R1
         L     R15,PANCHOR             LOAD ADDRESS OF LAST AREA GOTTEN
*/* D (YES,STALOFRT,NO,) FIRST TIME THROUGH */
         LTR   R15,R15                 IS THIS THE FIRST TIME
         BZ    STALOFRT                IF YES BRANCH
         SPACE
*/* P FORWARD CHAIN GETMAIN AREAS */
         ST    R1,ZERO(R15)            FORWARD CHAIN GETMAIN AREAS
         SPACE
*/*STALOFRT: P INDICATE NEW AREA IS END OF CHAIN */
STALOFRT DS    0H                      * * * *
         MVC   ZERO(FOUR,R1),ENDCHAIN  INDICATE NEW AREA IS END OF
*                                         CHAIN
         MVC   FOUR(FOUR,R1),PDWORD+FOUR ADD SIZE TO STORAGE CHAINS
         NI    PDWORD+FOUR,ZERO        KILL SUBPOOL INDICATOR
         ST    R1,PANCHOR              STORE STORAGE ADDRESS
         LA    R1,EIGHT(R1)            BUMP PAST STORAGE CHAINS
         MVC   ZERO(FOUR,R1),PANCHORT  OTHER ANCHORS
         ST    R1,PANCHORT                ON OTHER CHAINS
         L     R15,PDWORD+FOUR         GET SIZE OF STORAGE REQUESTED
         SH    R15,H8                  REDUCE BY SIZE OF STORAGE CHAINS
         ST    R15,FOUR(R1)            STORE LENGTH AVAILABLE
*/* P COMPUTE AMOUNT OF CORE TO CLEAR */
         SH    R15,H8                  COMPUTE AMOUNT OF CORE TO CLEAR
         LA    R1,EIGHT(R1)            SET UP STARTING ADDRESS
         SPACE
*/*STALOCLR: P CLEAR THE STORAGE */
STALOCLR DS    0H                      * * * *
         BCTR  R15,ZERO                DECREMENT SIZE FOR EXECUTE
         EX    R15,CLEARXC             CLEAR THE STORAGE
         LR    R14,R15                 COPY LENGTH USED
         N     R14,CLEARMK1            MASK OFF HIGH PART TO GET LENGTH
*                                         USED
         LA    R1,ONE(R1,R14)          GET NEW START CLEAR ADDRESS
         N     R15,CLEARMK2            CLEAR LOWER PART FOR NEXT TRY
         BNZ   STALOCLR                CLEAR IT UNLESS DONE
         SPACE
*/* P GET LENGTH REQUESTED FOR GETMAIN */
         L     R0,PDWORD               GET LENGTH REQUESTED FOR GETMAIN
*/* D (,STALOFST) TRY AGAIN */
         B     STALOFST                TRY IT AGAIN
         EJECT
***********************************************************************
*                                                                     *
*               POSITIONAL PARENTHESIZED STRING ROUTINE               *
*                                                                     *
*   THIS ROUTINE IS USED TO SCAN A STRING OF DATA ENCLOSED BY A SET   *
* OF PARENTHESIS - (STRING). THE STRING CAN CONSIST OF ANY            *
* COMBINATION OF CHARACTERS, HOWEVER, IF IT INCLUDES PARENTHESIS THEY *
* MUST BE BALANCED.                                                   *
*   A PSTRING CAN NEVER BE SYNTACTICALLY INVALID (VALIDITY CHECK EXIT *
* ROUTINE CAN REQUEST THAT IT BE CONSIDERED INVALID) BUT IF THE       *
* NEXT ITEM IN THE BUFFER DOES NOT BEGIN WITH A LEFT PARENTHESIS THE  *
* PSTRING IS CONSIDERED TO BE MISSING. A PROMPT OR A DEFAULT MAY BE   *
* SPECIFIED FOR A PSTRING.                                            *
*   IF THE USER LEAVES THE RIGHT PARENTHESIS OFF, THE END OF THE      *
* BUFFER DELIMITS THE STRING. A MESSAGE IS ISSUED TO INDICATE THIS    *
* SITUATION TO THE USER.                                              *
*                                                                     *
***********************************************************************
*/*PSTRING: S SKIPB: SKIP SEPARATORS */
         SPACE
PSTRING  DS    0H                      PSTRING ROUTINE
         BAL   LINK2,SKIPB             SKIP SEPARATORS
*
*/* D (YES,,NO,PSTRIPRQ) DATA IN BUFFER */
         B     PSTRIPRQ                +0 RETURN - NO DATA - PROMPT
*
*                                      +4 RETURN - DATA TO SCAN -
*                                         XINPUT POINTS TO NONSEPARATOR
         TM    PFLAGS5,SUBFLG          PROCESSING SUBFIELD?      Y02666
         BZ    PSTRIRSC                DONOT ALLOW LIST          Y02666
*     PROCESS POSSIBLE LIST                                      Y02666
         BAL   LINK1,LISTT             PROCESS POSSIBLE LIST     Y02666
         B     ILLPSTR                 +0 RETURN-INVALID,PROCESS Y02666
*                                      +4 RETURN DETERMINE IF LIST IS
*                                      THE DUMMY ONE             Y02666
         LA    R0,LRPAREN+ONE          GET DUMMY LIST PTR        Y02666
         CR    R0,XINPUT               PROCESSING A DUMMY LIST   Y02666
         BE    PSTRIPRQ                YES, DATA MISSING-PROMPT  Y02666
         SPACE
*
* ENTRY POINT TO RESCAN NEW DATA FROM PROMPT OR DEFAULT.
*
*/*PSTRIRSC: P RESCAN NEW DATA FROM PROMPT/DEFAULT */
PSTRIRSC DS    0H                      * * * *
         MVC   INVPSAVE,PPOINTR        SAVE PTR FOR INVALID MSG
         LA    XINPUT,ONE(XINPUT)      BUMP SCAN PTR BY ONE
*/* D (YES,,NO,PSTRPRQX) NEXT CHARACTER IS LEFT PAREN */
         CLI   ZERO(XINPUT),LEFTPRN    IS NEXT CHARACTER LEFT PAREN.
         BNE   PSTRPRQX                NO - ERROR - PROMPT
         SPACE
         LA    R2,ONE(XINPUT)          YES - SET PPOINTR TO FIRST
         ST    R2,PPOINTR                 CHARACTER IN PSTRING
*/* P SET DEPTH METER FOR NUMBER OF PARENS FOUND */
         LA    R2,ONE                  SET DEPTH METER TO ONE
*/*PSTRISCN: P LOOK FOR END OF STRING */
         SPACE
PSTRISCN DS    0H                      LOOP LOOKING FOR END OF STRING
         LA    XINPUT,ONE(XINPUT)      BUMP SCAN PTR BY ONE
         LR    XINPUTB,XINPUT          LOAD BACKUP REGISTER
*/* D (YES,PSTRIMSG,NO,) REACHED END OF INPUT */
         C     XINPUT,ENDINPUT         IS THIS END OF INPUT DATA
         BNL   PSTRIMSG                IF YES BRANCH
*/* D (YES,,NO,PSTRINLP) ANOTHER LEFT PAREN FOUND */
         SPACE
         CLI   ZERO(XINPUT),LEFTPRN    IS IT ANOTHER LEFT PAREN
*/*PSTRINLP: D (YES,,NO,PSTRISCN) RIGHT PAREN FOUND */
         BNE   PSTRINLP                IF NO SKIP LEVEL INCREMENT
*/* P INCREMENT DEPTH METER */
         SPACE
         LA    R2,ONE(R2)              BUMP DEPTH METER BY ONE
         SPACE
PSTRINLP DS    0H                      * * * *
         CLI   ZERO(XINPUT),RIGHTPRN   IS IT A RIGHT PAREN
         BNE   PSTRISCN                NO - BRANCH
*/* P DECREMENT DEPTH METER */
*/* D (YES,,NO,PSTRISCN) DEPTH METER IS ZERO */
         SPACE
         BCT   R2,PSTRISCN             YES - DECREMENT LEVEL WHEN ZERO
*                                         FALL THROUGH
         SPACE
*
* END OF PSTRING FOUND.
*
*/* P COMPUTE AND SAVE LENGTH OF PSTRING */
         S     XINPUTB,PPOINTR         COMPUTE LENGTH OF PSTRING
         STH   XINPUTB,PLENGTH         STORE LENGTH
*/* D (,POSITX1) EXIT */
         B     POSITX1                 BRANCH TO EXIT ROUTINE
         SPACE
*
* SEE IF PSTRING REQUIRED OR DEFAULTED.
*
*/*PSTRPRQX: P PREPARE FOR PROMPT/DEFAULT */
PSTRPRQX DS    0H                      * * * *
         BCTR  XINPUT,ZERO             REDUCE SCAN POINTER BY ONE
*/*PSTRIPRQ: S PROMPTQ: TEST FOR PROMPT/DEFAULT DATA */
         SPACE
PSTRIPRQ DS    0H                      * * * *
         BAL   LINK1,PROMPTQ           TEST FOR PROMPT OR DEFAULT
*
*/* D (YES,PSTRIRSC,NO,POSITX2) NEW DATA RETURNED */
         B     PSTRIRSC                +0 RETURN - RESCAN NEW DATA
*
         B     POSITX2                 +4 RETURN - NOT REQUIRED AND NO
*                                         DEFAULT - EXIT
         SPACE
*
* ISSUE 'RIGHT PAREN ASSUMED' MESSAGE AND TREAT AS IF RIGHT PAREN
* FOUND.
*
*/*PSTRIMSG: P COMPUTE AND SAVE LENGTH OF PSTRING */
PSTRIMSG DS    0H                      END OF BUFFER FOUND
         S     XINPUTB,PPOINTR         COMPUTE LENGTH OF PSTRING
         STH   XINPUTB,PLENGTH         SAVE LENGTH
         LA    R1,FIVE(XINPUTB)        GET SIZE OF CORE FOR MESSAGE SEG
*                                         PLUS HEADER AND LEFT PAREN
*/* S GETCORE: GET CORE FOR MESSAGE SEGMENT */
         BAL   LINK1,GETCORE           GET CORE FOR MESSAGE SEGMENT
         SPACE
*                                      CORE ADDRESS RETURNED IN R1
         ST    R1,SEGLIST+TWELVE       STORE ADDRESS IN LIST OF SEGMENT
         LA    R0,FIVE(XINPUTB)        GET SIZE OF MESSAGE SEGMENT
         STH   R0,ZERO(R1)             STORE INTO SEGMENT
         MVI   TWO(R1),ZERO            SET FIRST BYTE OF OFFSET TO ZERO
         MVI   THREE(R1),OFFSET4       SET OFFSET TO LENGTH OF 'RIGHT
*                                         PAREN ASSUMED' MESSAGE
         L     R15,PPOINTR             LOAD START OF DATA ADDRESS
         BCTR  R15,ZERO                INCLUDE LEFT PAREN IN MESSAGE
         EX    XINPUTB,BUILDSEG        MOVE TEXT TO NEW SEGMENT
*/* P INDICATE 'RIGHT PAREN ASSUMED' MESSAGE */
         MVI   MSGCODE,MSG8            INDICATE MESSAGE TO WRITE
*/* S WRITE1: WRITE THE MESSAGE */
         BAL   LINK1,WRITER1           WRITE THE MESSAGE
*/* D (YES,,NO,PSTRET) PROCESSING COBOL PCE'S? */
         TM    CBFLAGS1,COBOLMOD       DID WE WRITE THE MESSAGE  F41448
*                                      WHILE PROCESSING COBOL    F41448
*                                      PCE'S?                    F41448
         BZ    PSTRET                  IF NOT, CONTINUE NORMAL   F41448
*/* P LOAD IKJPARS2 RETURN ADDRESS */
*/* R () EXIT TO IKJPARS2 */
         L     LINK2,CBLNKSV2          PARSE. IF IN COBOL MODE   F41448
*                                      LOAD RETURN ADDRESS       F41448
         BR    LINK2                   FROM CBLNKSV2 + RETURN    F41448
*/*PSTRET: D (,POSITX1) EXIT AS NORMAL */
         SPACE
PSTRET   B     POSITX1                 EXIT AS NORMAL
         EJECT
***********************************************************************
*                                                               Y30NQJN
***                                                                 ***
*              A    D    D    R    E    S    S                        *
*                                                                     *
*               THIS CODE SIMPLY GETS THE ADDRESS OF THE              *
*        ADDRESS PCE PROCESSOR, IKJEFP03, AND PASSES CONTROL TO IT.   *
***                                                                 ***
*                                                               Y30NQJN
ADDRESS  DS    0H                      LINK TO ADDRESS PCE PROCESSOR
         L     R15,ADDRP               GET PCE PROCESSOR POINTER
         BR    R15                     GO PROCESS THE ADDRESS
***                                                                 ***
*                                                                     *
*                                                                     *
***                                                                 ***
***********************************************************************
         EJECT
***********************************************************************
*                                                                     *
*
*                       FORCE PUSHDOWN STACK POP SUBROUTINE           *
*                                                                     *
*    REGISTER RESTRICTIONS -                                          *
*                          R3 CANNOT BE USED BY THIS ROUTINE          *
*                                                                     *
***********************************************************************
         SPACE
*/*SCANF: E STACK POP ROUTINE */
SCANF    DS    0H                      * * * *
*/*SCANF9: P POINT TO NEXT CHARACTER */
SCANFX   DS    0H                                                Y01156
         LA    R0,ONE(XINPUT)          POINT TO NEXT SCANX CHARACTER
         SPACE
*/*SCANF1: D (YES,SCANDLSN,NO,) REACHED END */
SCANF1   DS    0H                      * * * *
         C     R0,ENDINPUT             SEE IF SCANX OFF THE END
*/* R RETURN */
         BL    FOUR(LINK1)             NO, GOOD FOR USE - RETURN +4
         SPACE
*/*SCANDLSN: D (YES,SCANDSY,NO,) STACK IS TO BE POPPED */
SCANDLSN DS    0H                      * * * *
         TM    PFLAGS4,PFNOPOP         IS STACK TO BE POPPED      M0911
*/* R RETURN - DON'T POP */
         BNZ   ZERO(LINK1)             NO, DON'T POP              M0911
*/*SCANDSY: D (YES,SCANPOP,NO,) ANYTHING ON INPUT STACK */
         TM    DATAFLA3,PRESENT        TEST TO SEE IF NEW PASSWORD HAS
*                                      BEEN PROCESS            @Z40RPKQ
         BZ    CKSTACK                 NO - TEST TO SEE IF ANYTHING IS
*                                      ON INPUT STACK          @Z40RPKQ
         XC    PIPDLX,PIPDLX           INDICATE THAT NO PASSWORD IS ON
*                                      INPUT STACK             @Z40RPKQ
CKSTACK  DS    0H                      * * * *                 @Z40RPKQ
         CLI   PIPDLX,ZERO             ANYTHING ON INPUT STACK
         BNZ   SCANPOP                 YES - POP ONE LEVEL
         L     R1,PIPDLCUR             LOAD PTR TO CURRENT STACK
*/* D (YES,,NO,SCANPOP2) FIRST STACK IN CHAIN */
         NC    ONE(THREE,R1),ONE(R1)   IS THIS FIRST STACK IN CHAIN
         BNZ   SCANPOP2                IF NO BRANCH
         SPACE
         OI    PFLAGS,PFENDF           SET END-OF-FILE INDICATOR
         NI    PFLAGS4,HFF-PFSLASH     INDICATE SLASH SCAN       M3098
*                                         COMPLETE AND NO DECREMENT
*/*  R RETURN - ERROR +0 */
         BR    LINK1                   ERROR RETURN +0
         SPACE
*/*SCANPOP: D (NO,SCANPOP3,YES,) PROCESSING COBOL PCE'S? */
*/* D (YES,SCANF2,NO,SCANPOP4) HAS STACK BEEN POPPED ONCE? */
*/*SCANPOP3: D (YES,,NO,SCANF2) END OF INPUT ON PROMPT/DEFAULT DATA */
*/* D (YES,,NO,SCANF2) SCAN FOR POSSIBLE PASSWORD */
SCANPOP  DS    0H                      * * * *
         TM    CBFLAGS1,COBOLMOD       PROCESSING COBOL PCE'S    F41448
         BZ    SCANPOP3                NO-CONTINUE NORMAL PARSE  F41448
         TM    CBFLAGS2,BUFPOPED       HAS STACK BEEN POPPED     F41448
*                                      ONCE?                     F41448
         BZ    SCANPOP4                IF NOT, SET UP PFENDSET   F41448
         B     SCANF2                  IF YES, DON'T SET PFENDSETF41448
SCANPOP3 TM    PFLAGS4,PFPDDATA+PFSLASH  END OF INPUT ON PROMPT/DEFAULT
*                                         DATA OR IS SCAN FOR POSSIBLE
*                                         PASSWORD
         BZ    SCANF2                  NO, CONTINUE
         SPACE
*/*SCANPOP4: P INDICATE ENDINPUT BAKUP IS SET (PFENDSET) */
SCANPOP4 OI    PFLAGS4,PFENDSET        INDICATE ENDINPUT BAKUP IS SET
*/* P SAVE END OF PROMPT/DEFAULT DATA */
         MVC   ENDBAKUP,ENDINPUT       SAVE END OF PROMPT/DEFAULT DATA
*                                         FOR POSSIBLE INVALID MESSAGE
*/* P INDICATE SCAN COMPLETE FOR SLASH OR PROMPT/DEFAULT DATA */
         NI    PFLAGS4,HFF-PFPDDATA-PFSLASH INDICATE SCAN COMPLETE FOR
*                                         SLASH OR PROMPT/DEFAULT DATA
         SPACE
*/*SCANF2: P GET INDEX TO NEXT EMPTY SLOT IN STACK */
SCANF2   DS    0H                      * * * *
         NI    PFLAGS,HFF-PFENDF       TURN OFF POSSIBLE END OF FIELD
*                                         FLAG
         XR    R1,R1                   ZERO WORK REGISTER
         IC    R1,PIPDLX               GET INDEX TO NEXT EMPTY SLOT IN
*                                         PUSHDOWN STACK
         SH    R1,H8                   DECREMENT TO PREVIOUS LEVEL
         STC   R1,PIPDLX               REPLACE THE INDEX
         A     R1,PIPDLCUR             COMPUTE ADDRESS FOR RESTORE
         LA    R1,FOUR(R1)             ACCOUNT FOR CHAIN WORD
*/* P RESET POINTERS */
*
         MVC   ENDINPUT,FOUR(R1)       RESET END POINTER
         L     XINPUT,ZERO(R1)         RESET SCAN POINTER
         LR    R0,XINPUT               COPY SCAN POINTER FOR TEST AT
*                                         SCANF1
*/* D (NO,SCANF4,YES,) PROCESSING COBOL PCE'S? */
*/* P (,SCANF9) TURN BUFFER POPPED ONCE INDICATOR ON - BUFPOPED */
         TM    CBFLAGS1,COBOLMOD       PROCESSING COBOL PCE'S?   F41448
         BZ    SCANF                   NO-CONTINUE NORMAL PARSE  F41448
         OI    CBFLAGS2,BUFPOPED       IF COBOL, TURN BUFFER     F41448
*                                      POPPED FLAG ON            F41448
*/*SCANF4: D (,SCANF9) REPEAT END OF DATA TEST */
         B     SCANFX                  REPEAT END OF DATA TEST    M1647
         SPACE
*
* DROP BACK TO PREVIOUS STACK IN CHAIN.
*
*/*SCANPOP2: P DROP BACK TO PREVIOUS STACK */
SCANPOP2 DS    0H                      DROP BACK TO PREVIOUS STACK
         MVC   PIPDLCUR+ONE(L'PIPDLCUR-ONE),ONE(R1) RESET CURRENT STACK
*                                         PTR TO PREVIOUS STACK
         LA    R0,EIGHT*(IPDLMAXE)+FOUR LOAD STACK SIZE FOR FREEMAIN
         SPACE
*/* P ISSUE FREEMAIN TO FREE LAST INPUT STACK */
         FREEMAIN R,LV=(0),A=(1)       FREE LAST INPUT PUSHDOWN STACK
         SPACE
*/* P RESET STACK INDEX */
         MVI   PIPDLX,EIGHT*(IPDLMAXE) RESET PUSHDOWN STACK INDEX TO
*                                         INDICATE A FULL STACK
*/* D (,SCANPOP) POP THE STACK */
         B     SCANPOP
         EJECT
         SPACE
***********************************************************************
*                                                                     *
*                    POSITIONAL USERID ROUTINE                        *
*                                                                     *
***********************************************************************
*/*USERID: GET SIX FULLWORDS                                @Z40RPKQ */
UID2PSWD DS    0H                      * * * *                 @Z40RPKQ
         LA    R1,TWENTY3              GET PDE SIZE-1          @Z40RPKQ
         B     USIDCOM                 BRANCH TO COMMENT USERID ROUTINE
*                                                              @Z40RPKQ
         SPACE
*/*USERID: P GET PDE SIZE */
USERID   DS    0H                      USERID ROUTINE
         LA    R1,FIFTEEN              GET PDE SIZE-1
USIDCOM  DS    0H                      * * * *                 @Z40RPKQ
         STC   R1,PPCOUNT              SAVE
*/* S SKIPB: SKIP SEPARATORS */
         BAL   LINK2,SKIPB             SKIP SEPARATORS
*
*/* D (YES,,NO,USIDPRQ) DATA IN BUFFER TO SCAN */
         B     USIDPRQ                 +0 RETURN - NO DATA, TRY TO
*                                         PROMPT OR DEFAULT
*
*                                      +4 RETURN - DATA TO SCAN, XINPUT
*                                         POINTS TO A SEPARATOR
*
*/* S LISTT: TEST AND SET UP FOR LIST */
         BAL   LINK1,LISTT             TEST AND SET UP FOR LIST
*
*/* D (YES,ILLUSID,NO,) INPUT ENDED AFTER ( WAS FOUND */
         B     ILLUSID                 +0 RETURN - ERROR, INPUT ENDED
*                                         AFTER LEFT PAREN WAS FOUND
*
*                                      +4 RETURN - POSITIONED AT NEXT
*                                         ITEM IN LIST IF LIST PRESENT
         SPACE
* ENTRY POINT TO RESCAN NEW DATA FROM PROMPT OR DEFAULT
*
*/*USIDRSC: P SAVE PTR FOR INVALID MSG */
USIDRSC  DS    0H                      * * * *
         MVC   INVPSAVE,PPOINTR        SAVE PTR FOR INVALID MSG
         MVC   DATAPTR1,PPOINTR        SAVE ID POINTER
*/* P INDICATE PARAMETER PRESENT */
         OI    DATAFLA1,PRESENT        SET PARM-IS-PRESENT FLAG
*                                         (CLEARED LATER IF MISSING)
         LA    R1,USIDCNTL             GET ADDR OF GENSCAN CONTROL INFO
*                                         FOR AN ID
         ST    R1,PDWORD               SAVE FOR GENSCAN
         L     R15,AGENSCAN            GET ADDRESS OF GENSCAN ROUTINE
*/* P USE GENSCAN FOR SYNTAX CHECKING */
         BALR  LINK2,R15               USE GENSCAN FOR SYNTAX CHECKING
*
*/* D (YES,USIDPRQ,NO,) ID IS MISSING */
         BCT   XINPUT,USIDPRQ          +0 RETURN - ID IS MISSING,
*                                         BACKUP AND TRY TO PROMPT OR
*                                         DEFAULT
*
*/* D (YES,ILLUSID,NO,) ID TOO LONG */
         B     ILLUSID                 +4 RETURN - ILLEGAL ID, TOO LONG
*
*/* D (YES,USIDEND,NO,) ID ENDED AT END OF INPUT */
         B     USIDEND                 +8 RETURN - ID ENDED AT END OF
*                                         CURRENT INPUT, SKIP DELIMITER
*                                         CHECK
*
*                                      +12 RETURN - GOOD, CHECK DELIM
*
*/* P SAVE LENGTH OF ID */
         S     XINPUTB,PPOINTR         COMPUTE LENGTH OF ID
         STH   XINPUTB,DATALEN1        SAVE
         STH   XINPUTB,PLENGTH         SET UP FOR TRANSQ
         L     R15,ATRANSQ             GET ADDRESS OF EXTERNAL
*                                         TRANSLATE ROUTINE
*/* P TRANSLATE USERID TO UPPERCASE */
         BALR  LINK1,R15               TRANSLATE USERID TO UPPERCASE
         SPACE
PSW2PROC DS    0H                       * * * *                @Z40RPKQ
         LA    R15,ONE(XINPUT)         GET NEXT BYTE PTR         YM3610
         C     R15,ENDINPUT            IS AT THE END?            YM3610
         BC    CC10,UIDSEP             BYPASS COMMENT TEST        M4540
         CLC   ZERO(TWO,XINPUT),SLASHAST  A COMMENT DELIMITER?   Y02666
         BNE   UIDSEP                  NO CHECK FOR SLASH        Y02666
         BCT   XINPUT,USID02           YES, A VALID COMMENT      Y02666
*/* D (YES,USIDPSWD,NO,) DELIMITER IS A SLASH */
UIDSEP   DS    0H                                                Y02666
         CLI   ZERO(XINPUT),SLASH      IS DELIMITER A SLASH
         BE    USIDPSWD                YES, SCAN FOR PASSWORD
*
         LA    R1,SEPAR                SET UP TO TEST IF DELIM
*                                         IS A SEPARATOR
*/* S TYPETEST: CHECK IF DELIMITER IS A SEPARATOR */
         BAL   LINK1,TYPETEST          USE TYPETEST
*
*/* D (YES,USID02,NO,USID01) DELIMITER IS A SEPARATOR */
         B     USID01                  + 0 RETURN - NON-SEPARATOR, GO
*                                         CHECK FOR VALID DELIMITER
*
         B     USID02                  +4 RETURN - SEPARATOR, GO CHECK
*                                         FOR POSSIBLE PASSWORD
*/*USID01: S TYPETEST: CHECK FOR VALID DELIMITER */
USID01   DS    0H
         LA    R1,NSEPDLIM             SET UP TO TEST FOR DELIM
         BAL   LINK1,TYPETEST          USE TYPETEST
*/* D (YES,USIDXIT,NO,ILLUSID) VALID DELIMITER */
         B     ILLUSID                 +0 RETURN - INVALID DELIMITER,
*                                         THEN INVALID ID
         B     USIDXIT                 +4 RETURN - VALID DELIMITER,EXIT
*/*USID02: S SKIPB: SKIP SEPARATORS TO SLASH */
USID02   DS    0H
*
         BAL   LINK2,SKIPB             SKIP SEPARATORS TO SLASH
*
*/* D (YES,USIDXIT,NO,) REACHED END OF INPUT */
         B     USIDXIT                 +0 RETURN - END OF INPUT, EXIT
*
*                                      +4 RETURN - CONTINUE
*
*/* D (YES,,NO,USIDXIT) NEXT CHARACTER IS A SLASH */
         LA    XINPUT,ONE(XINPUT)      GET NEXT CHARACTER
         CLI   ZERO(XINPUT),SLASH      IS IT A SLASH
         BNE   USIDXIT                 NO, EXIT
*
*/*USIDPSWD: S SKIPB: SKIP SEPARATORS TO PASSWORD */
USIDPSWD DS    0H
         NI    PFLAGS5,HFF-INVPRMPT    USERID PROMPT END         Y02666
         BAL   LINK2,SKIPB             SKIP SEPARATORS TO PASSWORD
*/* D (YES,,NO,PSWDPRQ) DATA TO SCAN */
         B     PSWDPRQ                 +0 RETURN - END OF INPUT DO
*                                         BYPASS PROMPT FOR PASSWORD
*
*                                      +4 RETURN - DATA TO SCAN
*
* ENTRY POINT TO RESCAN NEW DATA FROM PROMPT FOR PASSWORD
*
*/*UIDPSRSC: D (YES,,NO,UDPSRSC1) NULL LINE WAS ENTERED */
UIDPSRSC DS    0H                      * * * *
         TM    PFLAGS3,PFNULL          WAS A NULL LINE ENTERED
         BZ    UDPSRSC1                NO, CONTINUE
*
*/* P TURN OFF NULL LINE FLAG */
         NI    PFLAGS3,HFF-PFNULL      YES-TURN OFF NULL LINE FLAG
*/* P CLEAR PASSWORD DATA */
         TM    DATAFLA3,PRESENT        TEST TO SEE IF NEW PASSWORD HAS
*                                       BEEN SET OR NOT        @Z40RPKQ
         BZ    CLRPASSD                IF NO, BRANCH TO CLEAR CURRENT
*                                      PASSWORD                @Z40RPKQ
         XC    DATAPTR3(SEVEN),DATAPTR3 CLEAR NEW PASSWORD DATA
*                                                              @Z40RPKQ
         B     UIDEXIT1                BRANCH TO EXIT          @Z40RPKQ
CLRPASSD DS    0H                      * * * *                 @Z40RPKQ
         XC    DATAPTR2(SEVEN),DATAPTR2 CLEAR PASSWORD DATA
*/* D (,UIDEXIT1) EXIT */
         B     UIDEXIT1                EXIT
*/*UDPSRSC1: P USE GENSCAN FOR SYNTAX CHECKING */
UDPSRSC1 DS    0H
         BAL   LINK2,SKIPB             GO TO SKIP BLANKS        1A45368
         B     PSWDPRQ                 +0 RETURN - PASSWORD IS MISSING
*                                      GO TO PROMPT FOR PASSWORD IN
*                                      - BYPASS MODE            1A45368
*                                      +4 RETURN OK             1A45368
         CLI   ONE(XINPUT),QUOTE       IS FIRST CHARACTER QUOTE? Y02666
         BE    UIDPWQTE                PROCESS AS QUOTED STRING  Y02666
         LA    R1,PWSYNTAX             GET ADDR OF GENSCAN CONTROL INFO
*                                         FOR A PASSWORD
         ST    R1,PDWORD               SAVE FOR GENSCAN
         L     R15,AGENSCAN            GET ADDRESS OF GENSCAN ROUTINE
         BALR  LINK2,R15               USE GENSCAN FOR SYNTAX CHECKING
*
*/* D (YES,PSWDPRQ,NO,) PASSWORD IS MISSING */
         BCT   XINPUT,PSWDPRQ          +0 RETURN - PASSWORD IS MISSING,
*                                         DO BYPASS PROMPT
*
*/* D (YES,ILLUIDPS,NO,) ILLEGAL PASSWORD */
         B     ILLUIDPS                +4 RETURN - ILLEGAL PASSWORD
*
*/* D (YES,PSWDEND,NO,) END OF PARAMETER IS ALSO END OF INPUT */
         B     PSWDEND                 +8 RETURN - GOOD, END OF PARM IS
*                                         ALSO END OF INPUT
*
*                                      +12 RETURN - GOOD, CHECK DELIM
*
         LA    R15,ONE(XINPUT)         IS AT END OF ENDINPUT?    YM3610
         C     R15,ENDINPUT            CHECK FOR END             YM3610
         BC    CC10,CKSLASH            BYPASS COMMENT TEST     @Z40RPKQ
         CLC   ZERO(TWO,XINPUT),SLASHAST  A COMMENT DELIMITER?   Y02666
         BE    PSWDEND                 YES,  A VALID DELIMITER   Y02666
CKSLASH  DS    0H                      * * * *                 @Z40RPKQ
         CLI   ZERO(XINPUT),SLASH      TEST FOR A SLASH AS A
*                                      DELIMITER               @Z40RPKQ
         BE    PSWDEND                 BRANCH TO COMPUTE
*                                      LENGTH FOR NEW PASSWORD @Z40RPKQ
*/* S TYPETEST: CHECK FOR VALID DELIMITER */
COMBYPS1 DS    0H                      CHECK FOR VALID DELIMITER YM3610
         LA    R1,DLIMREQD             CHECK FOR VALID DELIMITER
         BAL   LINK1,TYPETEST          * * * *
*
*/* D (YES,,NO,ILLUIDPS) DELIMITER IS VALID */
         B     ILLUIDPS                +0 RETURN - DELIMITER IS BAD
*
*                                      +4 RETURN - OK
*
* CONSTRUCT TEMPORARY PDE FOR PASSWORD PORTION OF ID
*
*/*PSWDEND: P COMPUTE LENGTH OF PASSWORD */
PSWDEND  DS    0H                      * * * *
         TM    DATAFLA2,PRESENT        TEST TO FIND OUT IF PASSWORD HAS
*                                                              @Z40RPKQ
         BO    PSW2END                 BEEN SET, IF TRUE COMPUTE LENGTH
*                                      OF SECOND PASSWORD      @Z40RPKQ
         MVC   DATAPTR2,PPOINTR        SAVE PASSWORD POINTER
         S     XINPUTB,PPOINTR         COMPUTE LENGTH
         STH   XINPUTB,DATALEN2        SAVE
         B     PSWEND                  GO TO TEST LENGTH OF PASSWORD
*                                                              @Z40RPKQ
*/* PSW2END: COMPUTE THE LENGTH OF SECOND PASSWORD */
PSW2END  DS    0H                      * * * *                 @Z40RPKQ
         MVC   DATAPTR3,PPOINTR        SAVE SECOND PASSWORD POINTER
*                                                              @Z40RPKQ
         S     XINPUTB,PPOINTR         COMPUTE LENGTH OF SECOND PASS-
*                                      WORD                    @Z40RPKQ
         STH   XINPUTB,DATALEN3        SAVE SECOND PASSWORD LENGTH
*                                                              @Z40RPKQ
*/* PSWEND: TEST THE LENGTH OF PASSWORD TO FIND OUT IF LENGTH */
*/*         IS VALID OR NOT */
PSWEND   DS    0H                                              @Z40RPKQ
         STH   XINPUTB,PLENGTH         SET UP FOR TRANSLATE
         CH    XINPUTB,DEC9            IS IT TOO LONG?           Y02666
         BNL   ILLUIDPS                YES, INVALID              Y02666
         L     R15,ATRANSQ             GET ADDRESS OF EXTERNAL
*                                         TRANSLATE ROUTINE
*/* P TRANSLATE PASSWORD TO UPPERCASE */
         BALR  LINK1,R15               TRANSLATE PASSWORD TO UPPERCASE
         SPACE
*/* P SET INDICATOR THAT PARM IS PRESENT */
*/* IF PASSWORD IS PRESENT GO TO SET THE SECOND PASSWORD */
         TM    DATAFLA2,PRESENT        TEST TO FIND OUT IF PASSWORD HAS
*                                                              @Z40RPKQ
         BO    PSW2PARM                BEEN SET OR NOT, IF SET GO TO
*                                      ROUTINE TO SET SECOND PASSWORD
*                                                              @Z40RPKQ
         OI    DATAFLA2,PRESENT        SET PARM-IS-PRESENT FLAG
         LA    R15,ONE(XINPUT)        MOVE THE POINTER TO THE NEX
*                                     CHARACTER                @Z40RPKQ
         C     R15,ENDINPUT           CKECK FOR END            @ZA27204
         BC    CC10,UIDEXIT1          THIS IS END OF PSWD      @ZA27204
         BAL   LINK2,SKIPB            SKIP TO SLASH OR OPERAND
*                                                              @Z40RPKQ
         B     ENDSLASH               +0, BRANCH TO TEST END OF PASS-
*                                         WORD PROCESSING      @Z40RPKQ
         B     CKPDESZ                +4, BRANCH TO FIND WHICH PDE-SZ
*                                         BEING USED           @Z40RPKQ
ENDSLASH DS    0H                     * * * *                  @Z40RPKQ
         CLI   ZERO(XINPUT),SLASH     IS A SLASH AT THE END OF PASS-
*                                     WORD                     @Z40RPKQ
         BE    CKPDESZ                YES, BRANCH TO CHECK PDE SIZE-1
*                                          BEING USED          @Z40RPKQ
         B     UIDEXIT1               IF THIS IS THE END OF PASSWORD
*                                     PROCESSING               @Z40RPKQ
CKPDESZ  DS    0H                     * * * *                  @Z40RPKQ
         TM    PPCOUNT,FIFTEEN        DETERMINE WHAT PDE SIZE-1 TO
*                                     BE USED                  @Z40RPKQ
         BO    USIDXIT                BRANCH TO BACK UP SCAN POINTER
*                                                              @Z40RPKQ
         B     PSW2PROC               BRANCH TO CHECK THE VALIDITY OF
*                                     THE SECOND PASSWORD      @Z40RPKQ
PSW2PARM DS    0H                                              @Z40RPKQ
         OI    DATAFLA3,PRESENT        SET SECOND PASSWORD TO
*                                      INDICATE IT IS PRESENT  @Z40RPKQ
*/*USIDXIT: P BACK UP SCAN POINTER */
USIDXIT  DS    0H                      * * * *
         BCTR  XINPUT,ZERO             BACK UP SCAN POINTER FOR LATER
         SPACE
*/* UIDEXIT1: P INDICATE TO MOVE FOUR WORDS OR SIX WORDS    @Z40RPKQ */
UIDEXIT1 DS    0H                      $ $ $ $
         TM    DATAFLA3,PRESENT        TEST TO SEE IF NEW PASSWORD HAS
*                                       BEEN SET OR NOT        @Z40RPKQ
         BZ    SET4WORD                IF NO, BRANCH TO SET PDE TO FOUR
*                                       FULLWORDS              @Z40RPKQ
         SPACE
*
         LA    R1,TWENTY3              TELL EXIT ROUTINE TO MOVE SIX
*                                         WORDS                @Z40RPKQ
         B     POSITX                   BRANCH TO POSITIONAL EXIT
*                                                              @Z40RPKQ
SET4WORD DS    0H                      * * * *                 @Z40RPKQ
         LA    R1,FIFTEEN              TELL EXIT ROUTINE TO MOVE FOUR
*                                       WORDS                  @Z40RPKQ
*/* D (,POSITX) TAKE POSITIONAL EXIT */
         B     POSITX                  TAKE POSITIONAL EXIT
         SPACE
*/*USIDEND: P SAVE LENGTH */
USIDEND  DS    0H                      * * * *
         S     XINPUTB,PPOINTR         COMPUTE LENGTH
         STH   XINPUTB,DATALEN1        SAVE
         STH   XINPUTB,PLENGTH         STORE LENGTH FOR TRANSLATION
         L     R15,ATRANSQ             GET ADDR OF TRANSLATE ROUTINE
*/* P TRANSLATE TO UPPERCASE */
         BALR  LINK1,R15               LINK TO IT
         SPACE
*/* P INDICATE SCAN STARTED FOR SLASH */
         OI    PFLAGS4,PFSLASH         INDICATE SCAN STARTED FOR SLASH
*/* S SCANF: TRY TO POP STACK */
         BAL   LINK1,SCANF             TRY TO POP STACK
         SPACE
*/* D (YES,,NO,USIDXIT) DATA RETURNED */
         B     USIDXIT                 +0 RETURN - NO MORE DATA, EXIT
         SPACE
*                                      +4 RETURN - MORE DATA OR BLANK
         SPACE
*/* D (YES,USIDPSWD,NO,) NEXT CHARACTER IS A SLASH */
         LA    XINPUT,ONE(XINPUT)      BUMP UP PTR
         CLI   ZERO(XINPUT),SLASH      IS NEXT CHARACTER A SLASH
         BE    USIDPSWD                YES, PROCESS PASSWORD
*/*  S TYPETEST: CHECK IF NEXT CHARACTER IS A SEPARATOR */
         LA    R1,SEPAR                NO - IS THE NEXT CHARACTER
         BAL   LINK1,TYPETEST          A SEPARATOR - USE TYPETEST
         SPACE
*/* D (YES,USID02,NO,USIDXIT) CHARACTER IS SEPARATOR */
         B     USIDXIT                 +0 RETURN - NO, EXIT
*
         B     USID02                  +4 RETURN - YES, GO SKIP BLANKS
*                                         AND PROCESS POSSIBLE PASSWORD
         SPACE
*/*PSWDPRQ: P LOAD POINTER TO AND LENGTH OF USERID */
PSWDPRQ  DS    0H                      * * * *
         TM    PFLAGS5,INVPRMPT        WAS PROMPTING DONE BEFORE A45352
*                                      FOR THIS PARAETER?        A45352
         BO    ILLUIDPS                YES,ISSUE INVALID MESSAGE A45352
         OI    PFLAGS5,INVPRMPT        NO, INDICATE FIRST PROMPT A45352
         L     R2,DATAPTR1             LOAD USERID POINTER
         LH    R1,DATALEN1             LOAD LENGTH OF USERID
         LR    R3,R1                   SAVE DATA LENGTH
         LA    R1,FOUR(R3)             GET SIZE OF CORE FOR MESSAGE SEG
*                                         PLUS FOUR FOR HEADER
*/* S GETCORE: GET CORE FOR MESSAGE SEGMENT */
         BAL   LINK1,GETCORE           GET CORE FOR MESSAGE SEGMENT
         SPACE
*                                      CORE ADDRESS RETURNED IN R1
*/* P MOVE MESSAGE TEXT */
         ST    R1,SEGLIST+TWELVE       STORE ADDRESS IN LIST OF SEGMENT
         LA    R0,FOUR(R3)             GET SIZE OF MESSAGE SEGMENT
         STH   R0,ZERO(R1)             STORE INTO SEGMENT
         MVI   TWO(R1),ZERO            SET FIRST BYTE OF OFFSET TO ZERO
         TM    DATAFLA2,PRESENT        TEST TO SEE IF CURRENT PASSWORD
*                                      HAS BEEN PROCESSED      @Z40RPKQ
        BO    SETXTLN2                IF YES, BRANCH TO SET OFFSET
*                                      INTO NEW PASSWORD MSG   @Z40RPKQ
         MVI   THREE(R1),OFFSET2       SET OFFSET INTO 'ENTER CURRENT
*                                      PASSWORD FOR' MESSAGE   @Z40RPKQ
         B     REDUCLN                 BRANCH TO REDUCE LENGTH @Z40RPKQ
SETXTLN2 DS    0H                      * * * *                 @Z40RPKQ
         MVI   THREE(R1),OFFSET22      SET OFFSET INTO 'ENTER NEW
*                                      PASSWORD FOR' MESSAGE   @Z40RPKQ
REDUCLN  DS    0H                      * * * *                 @Z40RPKQ
         BCTR  R3,ZERO                 REDUCE LENGTH FOR 'EX'
         LR    R15,R2                  LOAD START OF DATA ADDRESS
         EX    R3,BUILDSEG             MOVE TEXT TO NEW SEGMENT
         OI    PFLAGS,PFBYPAS          INDICATE BYPASS MODE REQUIRED
*/* P INDICATE MESSAGE TO WRITE */
         TM    DATAFLA2,PRESENT        TEST TO SEE IF CURRENT PASSWORD
*                                      HAS BEEN PROCESSED      @Z40RPKQ
         BO    ENTERNEW                 IF YES, BRANCH TO SET INDICATOR
*                                      MESSAGE TO WRITE        @Z40RPKQ
         MVI   MSGCODE,MSG15           INDICATE MESSAGE TO WRITE
         B     SEGMSG                  BRANCH TO INDICATE SEGMENT
*                                       MESSAGE                @Z40RPKQ
ENTERNEW DS    0H                       * * * *                @Z40RPKQ
         MVI   MSGCODE,MSG22            INDICATE MESSAGE TO WRITE
*                                                              @Z40RPKQ
SEGMSG  DS    0H                       * * * *                 @Z40RPKQ
         LA    R0,TWO                  INDICATE 2 SEGMENT MSG
*/* S WRITER2: ISSUE PROMPT MESSAGE */
         BAL   LINK1,WRITER2G          PROMPT IN BYPASS MODE
         SPACE
         B     UIDPSRSC                RESCAN NEW DATA
UIDPWQTE DS    0H                                                Y02666
         LA    R1,ONE(XINPUT)          GET INPUTER + ONE         Y02666
         C     R1,ENDINPUT             IS QUOTE AT END OF BUFFER Y02666
         BNL   PSWDPRQ                 YES, MISSING - PROMPT     Y02666
         OI    PFLAGS5,PSWDFLG         INDICATE PASSWORD BEING PROCESED
*                                                                Y02666
         OI    PFLAGS6,PSWDQFLG        INDICATE QUOTED PASSWORD  Y02666
         BAL   LINK2,QSTRIRSC          PROCESS AS QUOTED STRING  Y02666
         NI    PFLAGS5,HFF-PSWDFLG     INDICATE END OF PROCESS   Y02666
         B     PSWDEND                 CONTINUE PROCESSING       Y02666
         SPACE
*/*USIDPRQ: S PROMPTQ: PROMPT OR DEFAULT */
USIDPRQ  DS    0H                      ID IS MISSING
         NI    DATAFLA1,HFF-PRESENT    RESET USER ID PRESENT BIT A45368
*
         BAL   LINK1,PROMPTQ           PROMPT OR DEFAULT
*
*/* D (YES,USIDRSC,NO,UIDEXIT1) DATA RETURNED */
         B     USIDRSC                 +0 RETURN - NEW DATA TO SCAN
*
*                                      +4 RETURN - NO DATA RETURNED
*
         B     UIDEXIT1                EXIT
         EJECT
***********************************************************************
*                                                                     *
*                    POSITIONAL DSNAME ROUTINE                        *
*                    POSITIONAL JOBNAME ROUTINE                       *
*                                                                     *
***********************************************************************
JOBNAME  DS    0H                                                Y02666
         LA    R1,FIFTEEN              GET PDE SIZE - 1          Y02666
         B     DSJOB                   CONTINUE PROCESSING       Y02666
*/*DSNAME: P GET PDE SIZE */
DSNAME   DS    0H                      DSNAME ROUTINE
         LA    R1,TWENTY3              GET PDE SIZE-1
         OI    PFLAGS5,DSNFLG          INDICATE DSNAME IN PROCES Y02666
DSJOB    DS    0H                                                Y02666
         STC   R1,PPCOUNT              SAVE
*                                         (ALSO USED FOR DSTHING)
*/* S SKIPB: SKIP SEPARATORS */
         BAL   LINK2,SKIPB             SKIP BLANKS TO BEGINNING OF PARM
         SPACE
*/* D (YES,DSNAMPRQ,NO,) END OF CURRENT INPUT */
         B     DSNAMPRQ                +0 RETURN, END OF CURRENT INPUT,
*                                         TRY TO PROMPT OR DEFAULT FOR
*                                         PARAMETER
         SPACE
*                                      +4 RETURN, OK
         SPACE
*/* S LISTT: TEST AND SET UP FOR LIST */
         BAL   LINK1,LISTT             TEST AND SET UP FOR LIST
         SPACE
*/* D (YES,ILLDSN,NO,) INPUT ENDED AFTER LEFT PAREN WAS FOUND */
         B     ILLDSN                  +0 RETURN, INPUT ENDED AFTER
*                                         LEFT PAREN WAS FOUND, INVALID
*                                         PARM
         SPACE
*                                      +4 RETURN, OK
         SPACE
*
* ENTRY FOR RESCANNING NEW DATA AFTER PROMPT OR DEFAULT
*
*/*DSNAMRSC: D (YES,DSTHING1,NO,) PROCESSING DSTHING */
DSNAMRSC DS    0H                      * * * *
         TM    PFLAGS7,DSNAMEF         IS ENTRY FROM VCE ROUTINE Y02666
         BZ    DSNAMX                  NO,CONTINUE DSNAME PROCESSY02666
         OI    PFLAGS5,DSNFLG          INDICATE DSNAME PROCESSINGY02666
         NI    PFLAGS7,HFF-DSNAMEF     INDICATE VCE PROCESS END  Y02666
DSNAMX   DS    0H                                                Y02666
         MVC   INVPSAVE,PPOINTR        SAVE START OF PARM IN CASE IT IS
*                                         INVALID
         TM    PFLAGS5,DSNFLG          IS DSNAME BEING PROCESSED Y02666
         BZ    JOB01                   NO, PROCESS JOBNAME       Y02666
         CLI   PCEPOST(XPCE),(DSTHIB-POSITB)/FOUR PROCESSING DSTHING
         BE    DSTHING1                YES, SET UP FOR DSTHING
         SPACE
*/* P GET ADDR OF GENSCAN CONTROL INFO FOR DSNAME */
DSNCONTL DS    0H                                                Y02666
         LA    R1,DSNCNTL              GET ADDR OF GENSCAN CONTROL INFO
*                                         FOR DSNAME
*/* D (,DSN01) BRANCH */
         B     DSN01                   CONTINUE
JOB01    DS    0H                                                Y02666
         LA    R1,JOBNCNTL             GET JOBNAME CONTROL INFO  Y02666
         B     DSN01                   CONTINUE                  Y02666
         SPACE
*/*DSTHING1: P GET ADDR OF GENSCAN CONTROL INFO FOR DSTHING */
DSTHING1 LA    R1,DSTCNTL              GET ADDR OF GENSCAN CONTROL INFO
*                                         FOR DSTHING
         SPACE
*/*DSN01: P CLEAR FLAGS FOR DSNAME PROCESSING */
DSN01    DS    0H                      * * * *
         ST    R1,PDWORD               PUT ADDR OF GENSCAN CONTROL INFO
*                                         IN PDWORD
         NI    RFLAGS,HFF-RFQDSNM-RFMEMB-RFNOTQ1 CLEAR FLAGS FOR
*                                         DSNAME PROCESSING
         LA    XINPUT,ONE(XINPUT)      GET NEXT CHARACTER (SKIPB HAS
*                                         ALREADY CHECKED FOR END)
         LR    XINPUTB,XINPUT          SET LAST CHARACTER SCANNED
         TM    PFLAGS5,DSNFLG          PROCESSING DSNAME?        Y02666
         BZ    JOB02                   NO, PROCESSING JOBNAME    Y02666
*/* D (YES,DSNQUOTE,NO,) FIRST CHARACTER IS A QUOTE */
         CLI   ZERO(XINPUT),QUOTE      IS FIRST CHARACTER A QUOTE?
         BE    DSNQUOTE                YES, SET UP FOR QUOTED DSNAME
         SPACE
*/* D (YES,DSNMEMB,NO,) FIRST CHARACTER IS LEFT PAREN */
         CLI   ZERO(XINPUT),LEFTPRN    IS FIRST CHARACTER A LEFT PAREN
         BE    DSNMEMB                 YES, SET UP FOR MEMBER
         SPACE
JOB02    DS    0H                                                Y02666
         ST    XINPUT,DATAPTR1         SAVE PTR TO DSNAME/JOBNAMEY02666
*/* P INDICATE DSNAME IS PRESENT */
         OI    DATAFLA1,PRESENT        INDICATE DSNAME/JOBNAME IS
*                                      PRESENT                   Y02666
         SPACE
*/*DSNSCAN: P USE GENSCAN FOR SYNTAX CHECKING */
DSNSCAN  DS    0H                      * * * *
         TM    PCEFLGB2(XPCE),PCEFVSER IS VOLUME SERIAL POSSIBLE Y02666
         BZ    DSNSCN                  NO CONTINUE DSNAME        Y02666
         LA    R1,NUMBER               PREPARE TEST FOR NUMBER   Y02666
         BAL   LINK1,TYPETEST          TEST FIRST CHARACTER      Y02666
         B     DSNSCN                  FIRST CHAR. NOT NUMERIC   Y02666
         LA    R1,VOLSERC             +4 RETURN-GET VOL SER INFO Y02666
         ST    R1,PDWORD               RESET CONTROL INFO        Y02666
         OI    PFLAGS7,VOLSERF         INDICATE VOL. SER. IN PROCESS
*                                                                Y02666
DSNSCN   DS    0H                                                Y02666
         BCTR  XINPUT,ZERO             BACK UP INPUT FOR GENSCAN
         L     R15,AGENSCAN            GET ADDRESS OF GENSCAN ROUTINE
         BALR  LINK2,R15               USE GENSCAN FOR SYNTAX CHECKING
*
*                                      SCAN QUALIFIER/JOBNAME OR
*                                         MEMBER/JOBID ACCORDING TO
*                                         GENSCAN CONTROL INFO
*                                         PREVIOUSLY SET UP      Y02666
         SPACE
*/* D (YES,DSNMSNG,NO,) QUALIFIER OR MEMBER IS MISSING */
         BCT   XINPUT,DSNMSNG          +0 RETURN, QUALIFIER OR MEMBER
*                                                 IS MISSING
         SPACE
*/* D (YES,ILLDSN,NO,) QUALIFIER OR MEMBER IS ILLEGAL */
         B     ILLDSN                  +4 RETURN, QUALIFIER OR MEMBER
*                                                 IS ILLEGAL
         SPACE
*/* D (YES,DSNEND,NO,) QUALIFIER OR MEMBER DELIMITED BY END OF INPUT */
         B     DSNEND                  +8 RETURN, QUALIFIER OR MEMBER
*                                                 DELIMITED BY END OF
*                                                 CURRENT INPUT
         SPACE
*                                      +12 RETURN, GOOD  CHECK DELIM
         SPACE
*/* D (YES,DSNMEMDL,NO,) PROCESSING MEMBER */
         TM    RFLAGS,RFMEMB           IS A MEMBER BEING PROCESSED
         BO    DSNMEMDL                YES, GO CHECK MEMBER DELIMITER
         TM    PFLAGS5,DSNFLG          DSNAME IN PROCESS?        Y02666
         BZ    DSNENDNM                NO CHECK LENTH & DELIMITR Y02666
         SPACE
*/* D (YES,,NO,DSN02) FIRST QUALIFIER BEING PROCESSED */
         TM    RFLAGS,RFNOTQ1          IS THIS THE FIRST QUALIFIER
*                                         BEING PROCESSED
         BO    DSN02                   NO, CONTINUE
         SPACE
*/* P TURN ON NOT-FIRST-QUALIFIER INDICATOR */
         OI    RFLAGS,RFNOTQ1          YES, TURN ON NOT-FIRST-QUALIFIER
*                                         INDICATOR
         SPACE
*/*DSN02: D (YES,,NO,DSNENDNM) DELIMITER IS A PERIOD */
DSN02    DS    0H                      * * * *
         CLI   ZERO(XINPUT),PERIOD     IS DELIM A PERIOD
         BNE   DSNENDNM                NO, GO PROCESS END OF DSNAME
         SPACE
         TM    PFLAGS7,VOLSERF         IS VOL SER IN PROCESS?    Y02666
         BO    ILLDSN                  YES, QUALIFIER INVALID W/VOLSER
*                                                                Y02666
         LA    XINPUT,ONE(XINPUT)      GET NEXT CHARACTER
         LR    XINPUTB,XINPUT          SET LAST CHARACTER SCANNED
*/* D (YES,ILLDSN,NO,DSNSCAN) END OF CURRENT INPUT */
         C     XINPUT,ENDINPUT         AT END OF CURRENT INPUT
         BL    DSNSCAN                 NO, SCAN FOR NEXT QUALIFIER
         SPACE
         B     ILLDSN                  YES, INVALID (PERIOD CANNOT END
*                                         A DSNAME)
         SPACE
*/*DSN025: D (YES,,NO,DSN03) QUOTED DSNAME BEING PROCESSED */
DSN025   DS    0H                      * * * *
         TM    PFLAGS5,DSNFLG          DSNAME BEING PROCESSED?   Y02666
         BZ    DSN03                   NO, JOBNAME PROCESSING COMPLETE
*                                      CHECK DELIMITER           Y02666
         TM    RFLAGS,RFQDSNM          IS QUOTED DSNAME BEING PROCESSED
         BZ    DSN03                   NO, CONTINUE
         SPACE
*/* D (YES,,NO,ILLDSN) CHARACTER A QUOTE */
         CLI   ZERO(XINPUT),QUOTE      YES, CHECK FOR QUOTE
         BNE   ILLDSN                  NOT A QUOTE, INVALID PARM
         SPACE
         LA    XINPUT,ONE(XINPUT)      QUOTE FOUND, GET NEXT CHARACTER
         LR    XINPUTB,XINPUT          SET LAST CHARACTER SCANNED
*/* D (YES,,NO,DSN03) END OF CURRENT INPUT */
         C     XINPUT,ENDINPUT         AT END OF CURRENT INPUT
         BL    DSN03                   N0 - CONTINUE
*/*DSN026: P INDICATE SCAN STARTED FOR SLASH */
DSN026   DS    0H                      * * * *
         TM    PFLAGS5,DSNFLG          DSNAME PROCESSING?        Y02666
         BZ    DSN026A                 NO, BYPASS TEST FOR SLASH Y02666
         OI    PFLAGS4,PFSLASH         INDICATE SCAN STARTED FOR SLASH
         NI    PFLAGS5,HFF-INVPRMPT    INDICATE END DSNAME PROMPTY02666
         SPACE
*/* S SCANF: TRY TO POP STACK */
DSN026A  DS    0H                                                Y02666
         BAL   LINK1,SCANF             YES - TRY TO POP STACK
         SPACE
*/* D (YES,DSNEXIT,NO,) NO NEW DATA */
         B     DSNEXIT                 +0 RETURN - NO NEW DATA, EXIT
*
*                                      +4 RETURN - MORE DATA, CONTINUE
*
         LA    XINPUT,ONE(XINPUT)      BUMP PTR
*/* D (YES,DSNPS01,NO,) NEXT CHARACTER IS A SLASH */
         LA    R15,ONE(XINPUT)         GET NEXT CHARACTER PTR    YM3610
         C     R15,ENDINPUT            END OF INPUT?             YM3610
         BC    CC10,DSNSEP             BYPASS COMMENT CHECK       M4540
         CLC   ZERO(TWO,XINPUT),SLASHAST  A COMMENT DELIMITER?   Y02666
         BNE   DSNSEP                  NO, CHECK FOR SLASH       Y02666
         BCT   XINPUT,DSN04            YES, VALID DELIMITER      Y02666
DSNSEP   DS    0H                                                Y02666
         TM    PFLAGS5,DSNFLG          DSNAME PROCESSING?        Y02666
         BZ    DSNSEPA                 BYPASS SLASH RO PASSWORD TEST
*                                                                Y02666
         CLI   ZERO(XINPUT),SLASH      IS NEXT CHARACTER A SLASH
         BE    DSNPS01                 YES, PROCESS PASSWORD
DSNSEPA  DS    0H                                                Y02666
         LA    R1,SEPAR                NO - IS NEXT CHARACTER A
*/* S TYPETEST: CHECK IF CHARACTER IS SEPARATOR */
         BAL   LINK1,TYPETEST          SEPARATOR - USE TYPETEST
         SPACE
*/* D (YES,DSN04,NO,DSNEXIT) CHARACTER IS SEPARATOR */
         B     DSNEXIT                 +0 RETURN - NO, EXIT
         SPACE
         B     DSN04                   +4 RETURN - YES, GO SKIP BLANKS
*                                         AND PROCESS POSSIBLE PASSWORD
         SPACE
*/*DSN03: D (YES,DSNPSRSC,NO,) NEXT CHARACTER IS SLASH */
DSN03    DS    0H                      * * * *
         LA    R15,ONE(XINPUT)         GET NEXT CHARACTER        YM3610
         C     R15,ENDINPUT            AT END OF INPUT?          YM3610
         BC    CC10,DSN03A             YES,BYPASS COMMENT CHECK   M4540
         CLC   ZERO(TWO,XINPUT),SLASHAST  A COMMENT DELIMITER    Y02666
         BNE   DSN03A                  NO, CHECK FOR SLASH       Y02666
         BCT   XINPUT,DSN04            YES, A VALID DELIMITER    Y02666
DSN03A   DS    0H                                                Y02666
         TM    PFLAGS5,DSNFLG          IS DSNAME PROCESSING?     Y02666
         BZ    DSNSEPAR                CHECK JOB SEPARATOR       Y02666
         CLI   ZERO(XINPUT),SLASH      IS NEXT CHARACTER A SLASH
         BE    DSNPSRSC                YES, SCAN FOR PASSWORD
DSNSEPAR DS    0H                                                Y02666
         LA    R1,SEPAR                NO, SEE IF DELIMITER IS A
*                                         SEPARATOR
*/* S TYPETEST: CHECK IF DELIMITER IS SEPARATOR */
         BAL   LINK1,TYPETEST          USE TYPETEST
*/* D (YES,DSN04,NO,DSN031) VALID SEPARATOR */
         B     DSN031                  +0 RETURN_NON_SEPARATOR, CHECK
*                                        FOR VALID DELIMITER
         B     DSN04                   +4 RETURN- VALID SEPARATOR, SEE
*                                         IF SLASH IS PRESENT
*/*DSN031: S TYPETEST: CHECK FOR DELIMITER */
DSN031   DS    0H                       * * * *
         LA    R1,NSEPDLIM              SET UP TEST FOR DELIMITER
         BAL   LINK1,TYPETEST           USE TYPETEST
*/* D (YES,DSNEXIT,NO,ILLDSN) VALID DELIMITER */
         B     ILLDSN                   +0 RETURN INVALID DELIMITER,
*                                          DSNAME IS INVALID
         B     DSNEXIT                  +4 RETURN_ EXIT
         SPACE
*/*DSN04: S SKIPB: SKIP BLANKS TO SLASH */
DSN04    DS    0H                      * * * *
         TM    PFLAGS5,DSNFLG          DSNAME PROCESSING?
         BZ    DSNEXIT                 NO, PROCESS JOBNAME       Y02666
         BAL   LINK2,SKIPB             SKIP BLANKS TO SLASH
         SPACE
*/* D (YES,DSNEXIT1,NO,) REACHED END OF INPUT,SLASH MISSING */
         B     DSNEXIT1                +0 RETURN, REACHED END OF INPUT
*                                         SLASH MISSING, EXIT
*
*                                      +4 RETURN, 0K
         SPACE
         LA    XINPUT,ONE(XINPUT)      GET NEXT CHARACTR (SKIPB HAS
*                                         ALREADY CHECKED FOR END)
         LR    XINPUTB,XINPUT          SET LAST CHARACTER SCANNED
*/* D (YES,,NO,DSNEXIT) NEXT CHARACTER IS SLASH */
         CLI   ZERO(XINPUT),SLASH      IS CURRENT CHARACTER A SLASH
         BNE   DSNEXIT                 NO, SLASH MISSING, EXIT
         SPACE
         NI    PFLAGS5,HFF-INVPRMPT    END OF DSNAME PROMPT      Y02666
*
* ENTRY AFTER PROMPT FOR PASSWORD
*
*/*DSNPSRSC: D (YES,,NO,DSNPS01) NULL LINE WAS ENTERED */
DSNPSRSC DS    0H                      * * * *
         TM    PFLAGS3,PFNULL          WAS A NULL LINE ENTERED
         BZ    DSNPS01                 NO, CONTINUE
*/* P TURN OFF NULL LINE FLAG */
         NI     PFLAGS3,HFF-PFNULL     YES, TURN OFF NULL LINE FLAG
*/* P CLEAR PASSWORD DATA */
         XC    DATAPTR3(SEVEN),DATAPTR3 CLEAR PASSWORD DATA
*/* D (,DSNEXIT1) EXIT */
         B     DSNEXIT1                EXIT DSNAME PROCESSING
*/*DSNPS01: S SKIPB: SKIP BLANKS TO PASSWORD */
DSNPS01  DS    0H                      * * * *
         NI    PFLAGS5,HFF-DSNFLG      DSNAME PROCESS COMPLETE   Y02666
         OI    PFLAGS7,DSNAMEF         INDICATE DSNAME VCE PROCESS
*                                      BEGINS                    Y02666
         OI    PFLAGS5,PSWDFLG         INDICATE PASSWORD PROCESS Y02666
         BAL   LINK2,SKIPB             SKIP BLANKS TO PASSWD
         SPACE
*/* D (YES,DSNAMPWQ,NO,) REACHED END OF INPUT,PASSWORD MISSING */
         B     DSNAMPWQ                +0 RETURN, REACHED END OF INPUT
         SPACE
*                                         PASSWD MISSING, SET UP FOR
*                                         BYPASS PROMPT FOR PASSWORD
         SPACE
*                                      +4 RETURN, OK
         SPACE
         CLI   ONE(XINPUT),QUOTE       FIRST CHARACTER A QUOTE?  Y02666
         BE    DSNPWQTE                GO PROCESS QUOTED PASSWORDY02666
         LA    R1,PWSYNTAX             GET ADDR OF CONTROL INFO FOR
         ST    R1,PDWORD                  GENSCAN, SAVE
         L     R15,AGENSCAN            GET ADDRESS OF GENSCAN ROUTINE
*/* P USE GENSCAN FOR SYNTAX CHECKING */
         BALR  LINK2,R15               USE GENSCAN FOR SYNTAX CHECKING
*
*                                      SCAN PASSW0RD
         SPACE
*/* D (YES,DSNAMPWQ,NO,) PASSWORD MISSING */
         BCT   XINPUT,DSNAMPWQ         +0 RETURN,MISSING, BACK UP, SET
*                                         UP FOR BYPASS PROMPT
         SPACE
*/* D (YES,ILLDSNPS,NO,) INVALID PASSWORD */
         BCT   XINPUT,ILLDSNPS         +4 RETURN,TOO LONG, BACK UP
*                                         INPUT, PASSWORD IS INVALID
         SPACE
*/* D (YES,DSNPWEND,NO,) DELIMITER IS END OF INPUT */
         B     DSNPWEND                +8 RETURN, DELIMITER IS END,
*                                         SKIP DELIMITER TEST
         SPACE
*                                      +12 RETURN, CHECK DELIMITER
         SPACE
*/* S TYPETEST: TEST FOR VALID DELIMITER */
         LA    R15,ONE(XINPUT)         GET NEXT CHARACTER PTR    YM3610
         C     R15,ENDINPUT            END OF INPUT?             YM3610
         BC    CC10,COMBYPS2           BYPASS COMMENT CHECK       M4540
         CLC   ZERO(TWO,XINPUT),SLASHAST  A COMMENT DELIMITER?   Y02666
         BE    DSNPWEND                YES, A VALID DELIMITER    Y02666
COMBYPS2 DS    0H                      CHECK FOR DELIMITER       YM3610
         LA    R1,DLIMREQD             TEST FOR VALID DELIMITER
         BAL   LINK1,TYPETEST          USING TYPETEST
         SPACE
*/* D (YES,,NO,ILLDSNPS) VALID DELIMITER */
         B     ILLDSNPS                +0 RETURN, INVALID, PASSWORD IS
*                                         INVALID
         SPACE
*                                      +4 RETURN, GOOD DELIM
         SPACE
*/*DSNPWEND: P INDICATE PASSWORD IS PRESENT */
DSNPWEND DS    0H
         MVC   DATAPTR3(FOUR),PPOINTR  STORE PTR TO PASSWORD IN
*                                         DATA AREA
         OI    DATAFLA3,PRESENT        INDICATE PASSWORD IS PRESENT
*/* P COMPUTE LENGTH OF PASSWORD */
         S     XINPUTB,PPOINTR         COMPUTE LENGTH OF PASSWORD
         STH   XINPUTB,DATALEN3        STORE LENGTH IN DATA AREA
         STH   XINPUTB,PLENGTH         SET UP FOR TRANSLATE
         CH    XINPUTB,DEC9            IS PASSWORD TOO LONG?     Y02666
         BNL   ILLDSNPS                YES, INVALID              Y02666
         L     R15,ATRANSQ             GET ADDRESS OF TRANSLATE
*                                         ROUTINE
*/* P TRANSLATE TO UPPER CASE */
         BALR  LINK1,R15               TRANSLATE TO UPPER CASE
*/* D (,DSNEXIT) EXIT */
         B     DSNEXIT                 EXIT
         SPACE
*/*DSNMEMDL: D (YES,,NO,ILLDSN) DELIMITER IS RIGHT PAREN */
DSNMEMDL DS    0H                      CHECK MEMBER DELIMITER
         CLI   ZERO(XINPUT),RIGHTPRN   IS DELIM A RIGHT PAREN
         BNE   ILLDSN                  NO, INVALID PARM
         SPACE
*/* P COMPUTE LENGTH OF MEMBER */
         S     XINPUTB,DATAPTR2        COMPUTE LENGTH OF MEMBER
         STH   XINPUTB,DATALEN2        STORE IN DATA AREA
         MVC   PPOINTR(SIX),DATAPTR2   SET UP POINTERS FOR TRANSLATE
         L     R15,ATRANSQ             GET ADDRESS OF TRANSLATE
*                                         ROUTINE
*/* P TRANSLATE TO UPPERCASE */
         BALR  LINK1,R15               TRANSLATE TO UPPER CASE
         LA    XINPUT,ONE(XINPUT)      GET NEXT CHARACTER
         LR    XINPUTB,XINPUT          SET LAST CHARACTER SCANNED
*/* D (YES,,NO,DSN025) REACHED END OF INPUT */
         C     XINPUT,ENDINPUT         AT END OF CURRENT INPUT
         BL    DSN025                  NO, CHECK FOR QUOTE AS IN
*                                         QUOTED DSNAME
         SPACE
*/* D (YES,ILLDSN,NO,DSN026) DSNAME IS QUOTED */
         TM    RFLAGS,RFQDSNM          IS DSNAME QUOTED
         BO    ILLDSN                  YES, INVALID PARM
         SPACE
         B     DSN026                  NO - TRY TO POP STACK
         SPACE
*/*DSNQUOTE: P INDICATE QUOTED DSNAME BEING PROCESSED */
DSNQUOTE DS    0H                      SET UP FOR QUOTED DSNAME
         OI    RFLAGS,RFQDSNM          INDICATE A QUOTED DSNAME IS
*                                         BEING PROCESSED
         LA    XINPUT,ONE(XINPUT)      GET NEXT CHARACTER
         LR    XINPUTB,XINPUT          SET LAST CHARACTER SCANNED
*/* D (YES,ILLDSN,NO,) REACHED END OF INPUT */
         C     XINPUT,ENDINPUT         AT END OF INPUT
         BNL   ILLDSN                  YES, ILLEGAL DSNAME
         SPACE
*/* P SET PTR TO DSNAME IN DATA AREA */
         ST    XINPUT,PPOINTR          SET PTR TO BEGINNING OF PARM
         ST    XINPUT,DATAPTR1         SET PTR TO DSNAME IN DATA AREA
*/* P INDICATE QUOTED DSNAME IS PRESENT */
         OI    DATAFLA1,QUOTED+PRESENT INDICATE DSNAME IS PRESENT AND
*                                         QUOTED
*/* D (,DSNSCAN) SCAN FOR DSNAME QUALIFIER */
         B     DSNSCAN                 SCAN FOR DSNAME QUALIFIER
         SPACE
*/*DSNMEMB: P INDICATE PROCESSING MEMBER */
DSNMEMB  DS    0H                      SET UP FOR MEMBER/JOBID   Y02666
         TM    PFLAGS7,VOLSERF         IS A VOL SER IN PROCESS   Y02666
         BO    ILLDSN                  INVALID - MEMBER NOT ALLOWED
*                                         WITH A VOL SER         Y02666
         OI    RFLAGS,RFMEMB           INDICATE A MEMBER/JOBID IS BEING
*                                         PROCESSED              Y02666
         LA    XINPUT,ONE(XINPUT)      GET NEXT CHARACTER
         LR    XINPUTB,XINPUT          SET LAST CHARACTER SCANNED
*/* D (YES,ILLDSN,NO,) REACHED END OF INPUT */
         C     XINPUT,ENDINPUT         AT END OF INPUT
         BNL   ILLDSN                  YES, ILLEGAL DSNAME
         SPACE
*/* P SET PTR TO MEMBER NAME IN DATA AREA */
         ST    XINPUT,DATAPTR2         SET PTR TO MEMBER/JOBID NAME
*                                         IN DATA AREA           Y02666
*/* P INDICATE MEMBER IS PRESENT */
         OI    DATAFLA2,PRESENT        INDICATE MEMBER/JOBID IS PRESENT
*                                                                Y02666
*/* P GET GENSCAN CONTROL INFO FOR MEMBER NAME */
         LA    R1,MEMBCNTL             PUT ADDR OF GENSCAN CONTROL INFO
         ST    R1,PDWORD                  FOR MEMBER NAME IN PDWORD
*/* D (,DSNSCAN) SCAN FOR MEMBER NAME */
         B     DSNSCAN                 SCAN FOR MEMBERNAME/JOBID Y02666
         SPACE
*/*DSNMSNG: P ZERO TEMPORARY PDE */
DSNMSNG  DS    0H                      NEXT QUALIFIER OR MEMBER IS
*                                         MISSING
         XC    TEMPPDE(LTPDE),TEMPPDE  ZERO TEMPORARY PDE         M2379
*/* D (YES,DSNAMPRQ,NO,ILLDSN) PARM IS MISSING */
         TM    RFLAGS,RFMEMB+RFQDSNM+RFNOTQ1 THE PARM IS MISSING ONLY
*
* NOTE-  THE PARM IS MISSING ONLY IF THE FIRST QUALIFIER OF DSNAME
*        IS  BEING PROCESSED AND THE DSNAME IS NOT QUOTED.
*        OTHERWISE, THE PARM IS INVALID.
*
         BZ    DSNAMPRQ                PARM IS MISSING, PROMPT OR
*                                         DEFAULT
         SPACE
         B     ILLDSN                  PARM IS INVALID
DSNPWQTE DS    0H                                                Y02666
         LA    R1,ONE(XINPUT)          GET INPUT PTR +ONE        Y02666
         C     R1,ENDINPUT             IS QUOTE AT END OF BUFFER Y02666
         BNL   DSNAMPWQ                YES, MISSING - PROMPT     Y02666
         OI    PFLAGS6,PSWDQFLG        INDICATE QUOTED PASSWORD  Y02666
         BAL   LINK2,QSTRIRSC          PROCESS QUOTED STRING     Y02666
         B     DSNPWEND                CONTINUE                  Y02666
         SPACE
*/*DSNEND: D (YES,ILLDSN,NO,) PROCESSING MEMBER OR QUOTED DSNAME */
DSNEND   DS    0H                      DELIMITER IS END OF INPUT
         TM    RFLAGS,RFMEMB+RFQDSNM   IF MEMBER OR QUOTED DSNAME IS
         BNZ   ILLDSN                     BEING PROCESSED, THE PARM
*                                         IS INVALID
         SPACE
*/*DSNENDNM: P COMPUTE LENGTH OF DSNAME */
DSNENDNM DS    0H                      END OF DSNAME PROCESSING
         S     XINPUTB,DATAPTR1        COMPUTE LENGTH OF DSNAME
         TM    PFLAGS5,DSNFLG          DSNAME IN PROCESS?        Y02666
         BZ    DSJOBLEN                YES, CHECK FOR LENGTH     Y02666
         LA    R14,DSNMAXLN            GET MAX LENGTH OF DSNAME
*/* D (YES,ILLDSN,NO,) LENGTH GREATER THAN MAX */
         CR    XINPUTB,R14             IS LENGTH GREATER THAN 44
         BH    ILLDSN                  YES, PARM IS INVALID
         SPACE
         TM    DATAFLA1,QUOTED         IS DSNAME QUOTED?         Y02666
         BO    DSJOBLEN                OPTION NOT POSSIBLE       Y02666
         L     R1,DATAPTR1             GET DATA SET PTR          Y02666
         CLI   ZERO(R1),ASTERISK       IS IT ASTERISK?           Y02666
         BE    DSJOBLEN                YES, DO NOT PREFIX USERID Y02666
         TM    PCEFLGB2(XPCE),PCEFUID  IS OPTION SPECIFIED?      Y02666
         BZ    DSJOBLEN                NO,CONTINUE USUAL PROCESSING
*                                                                Y02666
         L     R15,UPTADDR             GET UPT PTR.              Y02666
         USING UPT,R15                 GET ADDRESSABILITY        Y02666
         SR    R1,R1                   CLEAR TEMPORARY WORK REG. Y02666
         IC    R1,UPTPREFL             GET USERID LENGTH         Y02666
         LTR   R1,R1                   IS LENGTH ZERO            Y02666
         BZ    DSJOBLEN                USERID NOT SPECIFIED      Y02666
         LA    R1,ONE(R1,XINPUTB)      GET TOTAL DSNAME LENGTH   Y02666
         CR    R1,R14                  IS LENGTH TOO GREAT       Y02666
         BH    ILLDSN                  YES, DSNAME IS INVALID    Y02666
         STH   R1,DATALEN1             SAVE LENGTH               Y02666
         O     R1,SUBPOOLN             INDICATE SUBPOOL 1        Y02666
         DROP  R15
         BAL   LINK2,STALOC            GET CORE FOR DSNAME       Y02666
         L     R15,UPTADDR             GET ECT PTR               Y02666
         USING UPT,R15
         IC    R2,UPTPREFL             GET USERID LENGTH         Y02666
         BCTR  R2,ZERO                 DECREMENT FOR EX. INSTR   Y02666
         LA    R3,UPTPREFX             SET USERID PTR            Y02666
         EX    R2,UIDMVC               MOVE USERID TO AREA       Y02666
         L     R3,DATAPTR1             GET DSNAME PTR            Y02666
         ST    R1,DATAPTR1             REPLACE WITH NEW ONE      Y02666
         LA    R1,ONE(R1,R2)           POINT TO BYTE PAST USERID Y02666
         MVI   ZERO(R1),PERIOD         MOVE IN PERIOD            Y02666
         LA    R1,ONE(R1)              UPDATE PAST PERIOD        Y02666
         LR    R2,XINPUTB              GET DSNAME LENGTH         Y02666
         BCTR  R2,ZERO                 DECREMENT FOR EX. INSTR.  Y02666
         EX    R2,UIDMVC               MOVE DSNAME IN BUFFER     Y02666
         DROP  R15
         B     DSTRANS                 PREPARE TO TRANSLATE      Y02666
DSJOBLEN DS    0H                                                Y02666
         STH   XINPUTB,DATALEN1        NO, SAVE LENGTH IN DATA AREA
DSTRANS  DS    0H                                                Y02666
         MVC   PPOINTR(SIX),DATAPTR1   SET UP POINTERS FOR TRANSLATE
         L     R15,ATRANSQ             GET ADDRESS OF TRANSLATE ROUTINE
*/* P TRANSLATE TO UPPER CASE */
         BALR  LINK1,R15               TRANSLATE TO UPPER CASE
*/* D (YES,DSN026,NO,) REACHED END OF INPUT */
         C     XINPUT,ENDINPUT         IS SCAN AT END OF INPUT
         BNL   DSN026                  YES - TRY TO POP STACK
*/* D (YES,DSNMEMB,NO,DSN025) CURRENT CHARACTER A LEFT PAREN */
         CLI   ZERO(XINPUT),LEFTPRN    IS CURRENT CHAR A LEFT PAREN
         BE    DSNMEMB                 YES, PROCESS MEMBER
         B     DSN025                  NO, CONTINUE DSNAME PROCESSING
         SPACE
*/*DSNEXIT: P BACK UP SCAN PTR */
DSNEXIT  DS    0H                      DSNAME EXIT
         BCTR  XINPUT,ZERO             BACK UP SCAN PTR FOR LATER
         SPACE
*/*DSNEXIT1: P INDICATE TO MOVE SIX WORDS */
DSNEXIT1 DS    0H                      EXIT WHEN BACK UP IS UNNECESSARY
         NI    PFLAGS7,HFF-VOLSERF     INDICATE END OF VOLSER PROCESS
*                                                                Y02666
         TM    PFLAGS5,DSNFLG          DSNAME PROCESSING?        Y02666
         BO    DSNEXIT3                JOBNAME EXIT              Y02666
         TM    PFLAGS5,PSWDFLG         PASSWORD PROCESSING?      Y02666
         BZ    JOBNEXIT                BYPASS DSNAME EXIT        Y02666
DSNEXIT3 DS    0H                                                Y02666
         NI    PFLAGS5,HFF-DSNFLG-PSWDFLG  DSNAME/PASSWORD PROCESSING
*                                                                Y02666
         OI    PFLAGS7,DSNAMEF         INDICATE DSNAME VCE PROCESS
*                                      BEGINS                    Y02666
         LA    R1,TWENTY3              TELL EXIT ROUTINE TO MOVE SIX
*                                         WORDS
*/* D (,POSITX) TAKE POSITIONAL EXIT */
         B     POSITX                  TAKE POSITIONAL EXIT
         SPACE
JOBNEXIT DS    0H                                                Y02666
         LA    R1,FIFTEEN              EXIT ROUTINE MOVE 4 WORDS Y02666
         B     POSITX                  TAKE POSITIONAL EXIT      Y02666
*/*DSNAMPRQ: S PROMPTQ: TYR TO PROMPT OR DEFAULT */
DSNAMPRQ DS    0H                      PARM IS MISSING.
         BAL   LINK1,PROMPTQ           TRY TO PROMPT OR DEFAULT
*                                         IF ANY
*
*/* D (YES,DSNAMRSC,NO,) DATA RETURNED */
         B     DSNAMRSC                +0 RETURN, NEW DATA, RESCAN IT
*
*                                      +4 RETURN, NO DATA RETURNED
*
*/* P CLEAR TEMPORARY PDE */
         XC    TEMPPDE(LTPDE),TEMPPDE  CLEAR TEMPORARY PDE
*/* D (,DSNEXIT1) EXIT */
         B     DSNEXIT1                EXIT
         SPACE
*/*DSNAMPWQ: P LOAD LENGTH OF DSNAME */
DSNAMPWQ DS    0H                      * * * *
         TM    PFLAGS5,INVPRMPT        WAS PROMPTING DONE BEFORE A45352
*                                      FOR THIS PARAMETER?       A45352
         BO    ILLDSNPS                YES,ISSUE INVALID MESSAGE A45352
         OI    PFLAGS5,INVPRMPT        NO, INDICATE FIRST PROMPT A45352
         L     R2,DATAPTR1             GET DSNAME POINTER
         LH    R1,DATALEN1             LOAD LENGTH OF DSNAME
*/* D (YES,DSNAMPWR,NO,) SEE IF SPECIFIED */
         LTR   R2,R2                   SEE IF SPECIFIED
         BNZ   DSNAMPWR                YES, GOOD
         SPACE
*/* P LOAD MEMBER NAME PTR AND LENGTH */
         L     R2,DATAPTR2             LOAD MEMBER NAME POINTER
         LH    R1,DATALEN2             LOAD LENGTH OF MEMBER NAME
         SPACE
*/*DSNAMPWR: S GETCORE: GET CORE FOR MESSAGE */
DSNAMPWR DS    0H                      * * * *
         LR    R3,R1                   SAVE DATA LENGTH
         LA    R1,FOUR(R3)             GET SIZE OF CORE FOR MESSAGE SEG
*                                         PLUS FOUR FOR HEADER
         BAL   LINK1,GETCORE           GET CORE FOR MESSAGE SEGMENT
         SPACE
*                                      CORE ADDRESS RETURNED IN R1
         ST    R1,SEGLIST+TWELVE       STORE ADDRESS IN LIST OF SEGMENT
         LA    R0,FOUR(R3)             GET SIZE OF MESSAGE SEGMENT
         STH   R0,ZERO(R1)             STORE INTO SEGMENT
         MVI   TWO(R1),ZERO            SET FIRST BYTE OF OFFSET TO ZERO
         MVI   THREE(R1),OFFSET2       SET OFFSET INTO 'ENTER PASSWORD
*                                          FOR' MESSAGE
         BCTR  R3,ZERO                 REDUCE LENGTH FOR 'EX'
         LR    R15,R2                  LOAD START OF DATA ADDRESS
*/* P MOVE MESSAGE TEXT TO SEGMENT */
         EX    R3,BUILDSEG             MOVE TEXT TO NEW SEGMENT
         OI    PFLAGS,PFBYPAS          INDICATE BYPASS MODE REQUIRED
*/* P INDICATE MESSAGE TO WRITE */
         MVI   MSGCODE,MSG15           INDICATE MESSAGE TO WRITE
         LA    R0,TWO                  INDICATE TWO SEGMENT MSG
*/* S WRITER2: PROMPT */
         BAL   LINK1,WRITER2G          PROMPT IN BYPASS MODE
         SPACE
*/* D (,DSNPSRSC) PROCESS PROMPT DATA */
         B     DSNPSRSC                PROCESS PROMPT DATA
         EJECT
***********************************************************************
*  ADDRESS OF NEXT CSECT
*
         SPACE
ADRCST1  DC    V(IKJEFP01)             ADDRESS OF SECOND CSECT
IKJEFP01 CSECT
***********************************************************************
         SPACE
***********************************************************************
*                                                                     *
*              POSITIONAL QUOTED STRING ROUTINE                       *
*                                                                     *
***********************************************************************
*/*QSTRING: S SKIPB: SKIP SEPARATORS */
         SPACE
QSTRING  DS    0H                      QSTRING ROUTINE
         BAL   LINK2,SKIPB             SKIP BLANKS TO BEGINNING OF PARM
*
*/* D (YES,QSTRPRQ1,NO,) REACHED END OF INPUT */
         B     QSTRPRQ1                +0 RETURN - END OF INPUT REACHED
*                                         PARM IS MISSING
*
*                                      +4 RETURN - BEGINNING OF PARM
*                                         IS ESTABLISHED
*
* ENTRY TO RESCAN NEW DATA FROM PROMPT OR DEFAULT
*
*/*QSTRIRSC: P SAVE PTR FOR INVALID MSG */
QSTRIRSC DS    0H                      * * * *
         MVC   INVPSAVE,PPOINTR        SAVE PTR FOR INVALID MSG
*/* P INCREMENT SCAN POINTER */
         LA    XINPUT,ONE(XINPUT)      INCREMENT SCAN REGISTER (SKIPB
*                                         HAS ALREADY SET XINPUTB AND
*                                         CHECKED FOR END OF INPUT)
         SPACE
*
* COMMON CODE FOR PARSING QSTRING AND VALUE STRING
*
*/*VALENTRY: D (YES,QSTR01,NO,) FIRST CHARACTER IS A QUOTE */
VALENTRY DS    0H                      * * * *
         CLI   ZERO(XINPUT),QUOTE      IS FIRST CHARACTER A QUOTE
         BE    QSTR01                  YES - CONTINUE
*/* D (YES,VALUPRQX,NO,QSTRPRQ) A VALUE IS BEING PROCESSED */
         SPACE
         CLI   PCEPOST(XPCE),(VALUEB-POSITB)/FOUR IS A VALUE BEING
*                                         PROCESSED
         BNE   QSTRPRQ                 NO - PROMPT FOR A QSTRING
         SPACE
         BCT   XINPUT,VALUPRQX         YES - BAKUP AND PROMPT FOR VALUE
         SPACE
QSTR01   DS    0H                      * * * *
*/*QSTR01: P STORE ADDRESS OF NEXT CHARACTER AS POINTER TO STRING */
         LA    R2,ONE(XINPUT)          STORE ADDRESS OF NEXT CHARACTER
         ST    R2,PPOINTR                 AS POINTER TO STRING
*/*QSTRLOOP: D (YES,QSMSGEND,NO,) AT END OF CURRENT LEVEL OF INPUT */
QSTRLOOP DS    0H
         SPACE
         LA    XINPUT,ONE(XINPUT)      INCREMENT SCAN TO NEXT CHARACTER
         LR    XINPUTB,XINPUT          SET LAST CHARACTER SCANNED REG
         C     XINPUT,ENDINPUT         IS SCAN AT END OF CURRENT LEVEL
*                                         OF INPUT
         BNL   QSMSGEND                YES, BRANCH TO ISSUE MSG AND
*                                         PROCESS END
*/* D (YES,,NO,QSTRLOOP) CURRENT CHARACTER IS A QUOTE */
         CLI   ZERO(XINPUT),QUOTE      IS CURRENT CHARACTER A QUOTE
         BNE   QSTRLOOP                NO, BRANCH TO SCAN NEXT CHAR
*
         LA    XINPUT,ONE(XINPUT)      INCREMENT SCAN TO NEXT CHARACTER
         LR    XINPUTB,XINPUT          SET LAST CHARACTER SCANNED
*/* D (YES,QSTREND,NO,) NEXT CHARACTER IS AT END OF INPUT */
         C     XINPUT,ENDINPUT         IS SCAN AT END OF CURRENT LEVEL
*                                         OF INPUT
         BNL   QSTREND                 YES, BRANCH TO PROCESS END
*/* D (YES,,NO,QNORMEND) CURRENT CHARACTER IS A QUOTE */
         SPACE
         CLI   ZERO(XINPUT),QUOTE      IS CURRENT CHARACTER A QUOTE
         BNE   QNORMEND                NO, BRANCH TO PROCESS END
*/* D (NO,POSITQS,YES,) PROCESSING COBOL PCE'S? */
         TM    CBFLAGS1,COBOLMOD       ARE WE PROCESSING COBOL   F41448
*                                      PCE'S?                    F41448
         BZ    POSITQS                 IF NOT, CONTINUE NORMALLY F41448
*/* P LOAD RETURN ADDRESS IN IKJPARS2 */
*/* E () EXIT TO IKJPARS2 */
         L     LINK2,CBLNKSV2          IF IN COBOL MODE, RETURN  F41448
         BR    LINK2                   COBOL PROCESSORS          F41448
*/*POSITQS: D (YES,QSTRLOOP,NO,) A VALUE IS BEING PROCESSED */
         SPACE
POSITQS  CLI   PCEPOST(XPCE),(VALUEB-POSITB)/FOUR IS A VALUE BEING
*                                         PROCESSED
         BE    QSTRLOOP                YES - DO NOT REMOVE SECOND QUOTE
         SPACE
*
* REMOVE SECOND QUOTE FROM BUFFER
*
*/* P REMOVE SECOND QUOTE FROM BUFFER */
         L     R2,ENDINPUT             COPY END OF INPUT ADDR
         SR    R2,XINPUT               COMPUTE LENGTH OF REMAINING
*                                         DATA IN CURRENT LEVEL OF
*                                         INPUT
MOVIT    DS    0H
         BCTR  R2,ZERO                 SUBTRACT ONE FOR EXECUTE INSTR.
         LA    R3,HFF                  SET WORK REGISTER TO 255  S21105
         NR    R3,R2                   GET TRUE LENGTH TO MOVE   S21105
         EX    R3,QSTRMVC              REMOVE SECOND QUOTE BY SHIFTING
*                                         REMAINDER OF BUFFER ONE TO
*                                         THE LEFT               S21105
         LA    XINPUT,ONE(R3,XINPUT)   INCREMENT SCAN POINTER    S21105
         XR    R2,R3                   MORE IN BUFFER TO MOVE    S21105
         BNZ   MOVIT                   YES, CALCULATE HOW MUCH   S21105
         BCTR  XINPUT,ZERO             COMPUTE ADDR OF LAST BYTE OF
*                                         BUFFER                 S21105
         MVI   ZERO(XINPUT),BLNK       REPLACE WITH A BLANK
         LR    XINPUT,XINPUTB          RESET XINPUT              S21105
         BCT   XINPUT,QSTRLOOP         BACK UP XINPUT TO
*                                         ACCOUNT FOR REMOVAL
*                                         OF THE QUOTE AND BRANCH
*                                         TO SCAN NEXT CHAR
*/* P ACCOUNT FOR REMOVAL OF QUOTE */
*/* D (,QSTRLOOP) SCAN NEXT CHARACTER */
         SPACE
*
* PROCESS END
*
*/*QNORMEND: D (YES,QSTREND1,NO,) PROCESSING COBOL PCE'S? */
*/* D (YES,,NO,QSTREND1) A VALUE IS BEING PROCESSED */
QNORMEND DS    0H                      * * * *
         TM    CBFLAGS1,COBOLMOD       PROCESSING COBOL PCE'S?   F41448
         BO    QSTREND1                IF YES, BRANCH AROUND     F41448
*                                      CHECKS                    F41448
         CLI   PCEPOST(XPCE),(VALUEB-POSITB)/FOUR IS A VALUE BEING
*                                         PROCESSED
         BNE   QSTREND1                NO - QSTRING, EXIT
*/* S RANGE: CHECK FOR POSSIBLE RANGE */
         BAL   LINK1,RANGE             CHECK FOR RANGE
*/* D (YES,QSTREND1,NO,) EITHER RANGE NOT ALLOWED,RANGE NOT PRESENT, OR
*/* 2ND VALUE OF RANGE */
         B     QSTREND1                +0 RETURN - RANGE NOT ALLOWED OR
*                                         RANGE NOT PRESENT OR
*                                         2ND VALUE OF RANGE
*/* P SET UP ADDRESS FOR SCAN OF 2ND VALUE */
         LA    LINK2,VAL2RSC           SET UP ADDR FOR SCAN OF 2ND VALU
*/* D (YES,QSTREND1) PROCESS END */
         B     QSTREND1                PROCESS END
*/*QSTREND: D (YES,,NO,QSTREND1) FIRST VALUE OF RANGE WAS ENTERED */
         SPACE
         SPACE
QSTREND  DS    0H                      * * * *
*/* D (YES,QSTREND1,NO,) PROCESSING COBOL PCE'S? */
*/* COMMENT (1,15) BYPASS RANGE CHECK */
         TM    CBFLAGS1,COBOLMOD       PROCESSING COBOL PCE'S?   F41448
         BO    QSTREND1                YES - BYPASS RANGE CHECK  F41448
*/* P TURN OFF 1ST VALUE FLAG AND TURN ON 2ND VALUE FLAG */
         TM    PFLAGS2,RNGEVAL1        WAS 1ST VALUE OF RANGE ENTERED
         BZ    QSTREND1                NO, CONTINUE
         NI    PFLAGS2,HFF-RNGEVAL1    YES, TURN OFF 1ST VALUE FLAG
         OI    PFLAGS2,RNGEVAL2        TURN ON 2ND VALUE FLAG
*/*QSTREND1: P COMPUTE AND SAVE LENGTH OF STRING EXCLUDING END QUOTE */
QSTREND1 DS    0H                      * * * *
         BCTR  XINPUTB,ZERO            BACKUP TO EXCLUDE END QUOTE FROM
*                                         LENGTH
         TM    PFLAGS5,PSWDFLG         IS PASSWORD IN PROCESS?   Y02666
         BO    QSPWEND                 RETURN TO CALLER          Y02666
         TM    PFLAGS6,CHARFLG         IS CHARACTER VALUE TYPE IN
*                                      PROCESS?                  Y02666
         BO    QSPWEND                 YES, RETURN TO IKJEFP20   Y02666
         S     XINPUTB,PPOINTR         COMPUTE LENGTH
         STH   XINPUTB,PLENGTH         SAVE
*/* D (NO,QSTEXIT,YES,) PROCESSING COBOL PCE'S? */
         TM    CBFLAGS1,COBOLMOD       PROCESSING COBOL PCE'S    F41448
         BZ    QSTEXIT                 NO -CONTINUE NORMAL PARSE F41448
*/*CBLRETQS: P LOAD RETURN ADDRESS INTO IKJPARS2 */
*/* R () RETURN TO IKJPARS2 ON +4 */
CBLRETQS L     LINK2,CBLNKSV2          LOAD RETURN REG FROM      F41448
*                                      COBOL SAVE AREA           F41448
         B     FOUR(LINK2)             RETURN +4                 F41448
*/*QSTEXIT: D (,POSITX1) EXIT */
QSTEXIT  BCT   XINPUT,POSITX1          EXIT
         SPACE
*
* TRY TO PROMPT OR DEFAULT FOR MISSING QSTRING
*
*/*QSTRPRQ: P PREPARE FOR PROMPT/DEFAULT */
QSTRPRQ  DS    0H                      NORMAL ENTRY
         BCTR  XINPUT,ZERO             BACK UP SCAN POINTR
*
*/*QSTRPRQ1: S PROMPTQ: TEST FOR PROMPT/DEFAULT DATA */
QSTRPRQ1 DS    0H                      ENTRY AFTER SKIPB
         BAL   LINK1,PROMPTQ           TEST FOR PROMPT OR DEFAULT
*
*/* D (YES,QSTRIRSC,NO,POSITX2) NEW DATA RETURN */
         B     QSTRIRSC                +0 RETURN - RESCAN NEW DATA
*
         B     POSITX2                 +4 RETURN - NO DATA, TAKE NULL
*                                         PDE EXIT
         SPACE
*
* ISSUE 'ENDING QUOTE ASSUMED' MESSAGE AND TREAT AS IF ENTERED.
*
QSMSGEND DS    0H                      * * * *
*/*QSMSGEND: P COMPUTE AND SAVE LENGTH OF STRING */
         S     XINPUTB,PPOINTR         COMPUTE LENGTH
         STH   XINPUTB,PLENGTH         SAVE LENGTH
         TM    PFLAGS5,PSWDFLG         PASSWORD IN PROCESS?      Y02666
         BZ    QSMSGEN1                NO, CONTINUE              Y02666
         LA    R1,PSWDMSG              SET UP FOR PASSWORD MSG   Y02666
         ST    R1,SEGLIST+TWELVE       STORE MSG PTR             Y02666
         B     QSMSG07                 GO PROCESS END QUOTE ASSUMED MSG
*                                      FOR PASSWORD              Y02666
QSMSGEN1 DS    0H                                                Y02666
         LA    R1,SIX(XINPUTB)         GET SIZE OF CORE FOR MESSAGE SEG
*                                         PLUS HEADER, LEFT QUOTE AND
*                                         POSSIBLE TYPE-CHARACTER
*/* S GETCORE: GET CORE FOR MESSAGE SEGMENT */
         BAL   LINK1,GETCORE           GET CORE FOR MESSAGE SEGMENT
         SPACE
*                                      CORE ADDRESS RETURNED IN R1
         ST    R1,SEGLIST+TWELVE       STORE ADDRESS IN LIST OF SEGMENT
         LA    R0,SIX(XINPUTB)         GET SIZE OF MESSAGE SEGMENT
         STH   R0,ZERO(R1)             STORE INTO SEGMENT
         MVI   TWO(R1),ZERO            SET FIRST BYTE OF OFFSET TO ZERO
         MVI   THREE(R1),OFFSET5       SET OFFSET TO LENGTH OF 'END
*                                         QUOTE ASSUMED' MESSAGE
         L     R15,PPOINTR             LOAD START OF DATA ADDRESS
         BCTR  R15,ZERO                INCLUDE BEGINNING QUOTE IN
*                                         SECOND SEGMENT
*/* D (YES,QSMSG01,NO,) PROCESSING COBOL PCE'S? */
*/* COMMENT (1,15) CONTINUE MESSGE */
*/* COMMENT (2,15) BUILD */
         TM    CBFLAGS1,COBOLMOD       PROCESSING COBOL PCE'S?   F41448
         BO    QSMSG01                 YES-CONTINUE MESSAGEBUILD F41448
*/* D (YES,,NO,QSMSG01) A VALUE IS BEING PROCESSED */
         CLI   PCEPOST(XPCE),(VALUEB-POSITB)/FOUR IS A VALUE BEING
*                                         PROCESSED
         BNE   QSMSG01                 IF NO CONTINUE
*/* P ALLOW FOR TYPE CHARACTER IN MESSAGE */
         SPACE
         BCTR  R15,ZERO                IF YES INCLUDE TYPE-CHARACTER
*                                         IN MESSAGE
         LA    XINPUTB,ONE(XINPUTB)    INCLUDE TYPE-CHARACTER IN LENGTH
*/*QSMSG01: P INDICATE 'ENDING QUOTE ASSUMED' MESSAGE */
         SPACE
QSMSG01  DS    0H                      * * * *
         LA    R14,FIVE(XINPUTB,R1)    GET ADDRESS OF POSSIBLE EXTRA
*                                         BUFFER CHARACTER
         MVI   ZERO(R14),BLNK          BLANK IT OUT
         EX    XINPUTB,BUILDSEG        MOVE TEXT TO NEW SEGMENT
QSMSG07  DS    0H                                                Y02666
         MVI   MSGCODE,MSG7            INDICATE MESSAGE TO WRITE
*/* S WRITER1: WRITE THE MESSAGE */
         BAL   LINK1,WRITER1           WRITE THE MESSAGE
         TM    PFLAGS5,PSWDFLG         PASSWORD IN PROCESS?      Y02666
         BZ    QMSG08                  CONTINUE PROCESSING       Y02666
QSMSGVT  DS    0H                                                Y02666
         L     XINPUT,ENDINPUT         RESET SCAN PTR            Y02666
         LR    XINPUTB,XINPUT          RESTORE BACKUP SCAN PTR   Y02666
QSPWEND  DS    0H                                                Y02666
         BR    LINK2                   RETURN TO PASSWORD CALLER Y02666
*/* D (YES,CBLRETQS,NO,) PROCESSING COBOL PCE'S? */
*/* COMMENT (1,15) RETURN TO */
*/* COMMENT (2,15) IKJPARS2 */
QMSG08   DS    0H                      Y02666
         TM    CBFLAGS1,COBOLMOD       PROCESSING COBOL PCE'S?   F41448
         BO    CBLRETQS                YES - RETURN TO THE       F41448
*                                      COBOL MACRO PROCESSORS    F41448
*/* D (YES,,NO,POSITX1) FIRST VALUE OF RANGE WAS ENTERED */
         SPACE
         TM    PFLAGS6,CHARFLG         IS CHARACTER VALUE TYPE IN
         BO    QSMSGVT                 YES, RETURN TO CALLER     Y02666
         TM    PFLAGS2,RNGEVAL1        WAS 1ST VALUE OF RANGE ENTERED
         BZ    POSITX1                 NO, CONTINUE
*/* P TURN OFF FIRST VALUE FLAG AND TURN ON SECOND VALUE FLAG */
         SPACE
         NI    PFLAGS2,HFF-RNGEVAL1    YES, TURN OFF VALUE 1 FLAG
         OI    PFLAGS2,RNGEVAL2        TURN ON VALUE 2 FLAG
*/* D (,POSITX1) BRANCH TO EXIT */
         B     POSITX1                 BRANCH TO POSITIONAL EXIT RTN.
         EJECT
***********************************************************************
*                                                                     *
*                    POSITIONAL SPACE ROUTINE                         *
*                                                                     *
*   THIS POSITIONAL PARAMETER IS INTENDED TO BE FOLLOWED BY A         *
* POSITIONAL SELF-DELIMITING STRING PARAMETER. THE TSO EDIT COMMAND   *
* PROCESSOR IS THE SOLE USER OF THIS FUNCTION. NO OPTIONS ARE         *
* AVAILABLE WITH THE SPACE PARAMETER. ALSO EDIT DOES NOT SUPPLY ANY   *
* OPTIONS WITH THE FOLLOWING STRING PARAMETER.                        *
*    SINCE THE COMMAND NAME HAS BEEN PREVIOUSLY DELIMITED BY A BLANK, *
* COMMA OR TAB CHARACTER THE SPACE PARAMETER DOES EXIST (NO ERROR     *
* CONDITION POSSIBLE). IF THE DELIMITER IS A TAB, THE TAB IS TO BE    *
* THE FIRST CHARACTER OF THE FOLLOWING STRING. THE END OF THE STRING  *
* IS DELIMITED BY THE END OF THE BUFFER.                              *
*                                                                     *
***********************************************************************
*/*SPACE: P INDICATE SPACE/STRING SEQUENCE FOR STRING RTN */
         SPACE
SPACE    DS    0H                      SPACE ROUTINE
         OI    PFLAGS3,PFSPACE         INDICATE THIS IS A SPACE/STRING
*                                         SEQUENCE FOR STRING ROUTINE
         LA    XINPUT,ONE(XINPUT)      INCREMENT SCAN POINTER
*/* D (YES,,NO,POSITX3) NEXT CHARACTER IS A TAB */
         CLI   ZERO(XINPUT),TABCHAR    IS NEXT CHARACTER A TAB
         BNE   POSITX3                 IF NO BRANCH
*/* D (,POSITX3) USE TAB CHARACTER AS FIRST CHARACTER OF STRING AND
*/*EXIT */
         SPACE
         BCT   XINPUT,POSITX3          USE TAB CHARACTER AS FIRST
*                                         CHARACTER OF STRING
         EJECT
***********************************************************************
*                                                                     *
*                  POSITIONAL PDE ERASE ROUTINE                       *
*                                                                     *
*   THIS ROUTINE DETERMINES THE LENGTH OF THE PDE TO BE ERASED AND    *
* THEN PROCEEDS TO ZERO IT OUT (ERASE).                               *
*   ERASE MODE IS ENTERED BY SETTING THE RFERASE FLAG IN THE RECURSIVE*
* WORKSPACE AREA (RFLAGS). ITS SET TO INDICATE THAT A DUPLICATE       *
* KEYWORD PARAMETER HAS BEEN FOUND IN THE INPUT BUFFER AND THE        *
* PREVIOUS KEYWORD AND ASSOCIATED SUBFIELD, IF ANY, MUST BE ERASED    *
* AND REPLACED WITH NEW DATA.                                         *
*   THE ROUTINE IS ENTERED FROM THE POSIT AND IDENT ROUTINES.         *
*        ENTRY - R2 POSITIONAL TYPE CODE                              *
*                                                                     *
***********************************************************************
*/*POSITERS: P STORE TYPE CODE */
         SPACE
POSITERS DS    0H                      POSITIONAL PDE ERASE ROUTINE
         STC   R2,PDWORD               STORE MASSAGED TYPE CODE
         LA    R2,TWENTY3              LOAD LENGTH-1 OF DSNAME AND
*                                         DSTHING PDE
*/* D (YES,POSITER1,NO,) PDE IS 6 WORDS LONG(DSNAME) */
*/* D (YES,POSITER1,NO,) PDE IS 6 WORDS LONG(DSTHING) */
         CLI   PDWORD,(DSNAMB-POSITB)  IS PDE 6 WORDS LONG - DSNAME
         BE    POSITER1                YES --- BRANCH
         SPACE
         CLI   PDWORD,(DSTHIB-POSITB)  IS PDE 6 WORDS LONG - DSTHING
         BE    POSITER1                YES --- BRANCH
         SPACE
         LA    R2,THIRTY5              LOAD LENGTH-1 OF ADDRESS PDE
         CLI   PDWORD,(ADDRB-POSITB)   IS PDE 9 WORDS LONG - ADDRESS
         BE    POSITER1                YES --- BRANCH
         SPACE
         LA    R2,FIFTEEN              LOAD LENGTH-1 OF USERID PDE
         CLI   PDWORD,(USIDB-POSITB)   IS PDE 4 WORDS LONG
         BE    POSITER1                YES --- BRANCH
         SPACE
         CLI   PDWORD,(JOBNAMB-POSITB) IS PDE 4 WORDS LONG
         BE    POSITER1                YES --- BRANCH
         SPACE
*
* IT MUST BE A TWO WORD PDE BEING ERASED.
*
*/*IDENTERS: P ERASE 2 WORD PDE(IDENT) */
IDENTERS DS    0H                      ENTRY FOR ERASING AN IDENT PDE
         LA    R2,SEVEN                LOAD LENGTH OF REMAINING PDES OR
*                                         LENGTH OF IDENT PDE
*/*POSITER1: D (YES,,NO,POSITER2) RANGE IS ALLOWED */
         SPACE
POSITER1 DS    0H                      * * * *
         TM    PCEFLGB2(XPCE),PCEFRNGE IS A RANGE ALLOWED
         BZ    POSITER2                IF NO BRANCH
*/* P DOUBLE SIZE OF PDE TO ERASE */
         SPACE
         LA    R2,ONE(R2,R2)           IF YES DOUBLE THE SIZE OF PDE
*                                         TO ERASE
*/*POSITER2: P GET TRUE ADDRESS OF PDE */
         SPACE
POSITER2 DS    0H                      * * * *
         MVC   PDWORD(TWO),PCEPDEO(XPCE) ALIGN THE PDE OFFSET ON PROPER
*                                         BOUNDARY
         LH    R3,PDWORD               LOAD THE PDE OFFSET
         A     R3,XPDL                 GET TRUE ADDRESS OF PDE
*/* P EXECUTE INSTRUCTION TO ERASE OLD INFORMATION FROM PDE */
         EX    R2,ERASEXC              ERASE OLD INFORMATION FROM PDE
*/* D (YES,,NO,POSITX3) LIST IS ALLOWED */
         TM    PCEFLGB2(XPCE),PCEFLIST IS A LIST ALLOWED
         BZ    POSITX3                 NO ERASE COMPLETE --- BRANCH
         SPACE
         AR    R2,R3                   GET PTR TO LIST CHAIN -1
*/* P INDICATE NO LIST PRESENT */
         MVC   ONE(L'ENDCHAIN,R2),ENDCHAIN INDICATE NO LIST PRESENT
*/* D (,POSITX3) EXIT */
         B     POSITX3                 ERASE COMPLETE --- BRANCH
         EJECT
***********************************************************************
*                                                                     *
*                       POSITIONAL EXIT ROUTINE                       *
*                                                                     *
*   THIS ROUTINE IS ENTERED BY THE IKJPOSIT AND IKJIDENT PARAMETER    *
* ROUTINES AT THE CONCLUSION OF THEIR PROCESSING. THE PDE IS FILLED   *
* IN, A VALIDITY CHECK EXIT IS TAKEN AND THE NEXT PCE ADDRESS IS      *
* CALCULATED.                                                         *
*                                                                     *
***********************************************************************
         SPACE
*/*POSITX2: P INDICATE NULL DATA WAS ACCEPTED */
POSITX2  DS    0H                      INDICATE NULL DATA WAS ACCEPTED
         XC    PPOINTR(L'PPOINTR+L'PLENGTH),PPOINTR ZERO PTR AND
*                                         LENGTH FIELDS
         SPACE
*
* ENTRY POINT FOR STRING, PSTRING, QSTRING AND VALUE ROUTINES. THE PDE
* LENGTH FOR THESE POSITIONAL TYPES IS TWO WORDS. ALSO THE DATA MAY
* HAVE TO BE TRANSLATED TO UPPERCASE.
*
*
*/*POSITX1: P TRANSLATE TO UPPERCASE */
POSITX1  DS    0H                      * * * *
         TM    PFLAGS6,PDEHEX+NUMFLG   WAS HEXADEXIMAL TYPE PROCESSED?
*                                                                Y02666
         BM    POSITHEX                YES, BYPASS TRANSLATE     Y02666
*
         L     R15,ATRANSQ             GET ADDRESS OF TRANSLATE
*                                         ROUTINE
         BALR  LINK1,R15               TRANSLATE TO UPPER CASE
         SPACE
*/* P MOVE PTR TO AND LENGTH OF DATA TO TEMP PDE */
*
POSITHEX DS    0H                                                Y02666
         MVC   DATAPTR1+ONE(L'DATAPTR1-ONE+L'DATALEN1),PPOINTR+ONE
*              MOVE PTR TO DATA AND LENGTH OF DATA TO TEMPORARY PDE
         SPACE
*
********
******** N O T E  - THE ABOVE INSTRUCTION ASSUMES PPOINTR AND PLENGTH
********            ARE CONTIGUOUS AND DATAPTR1 AND DATALEN1 ARE
********            CONTIGUOUS.
********
*
         SPACE
*/* D (YES,,NO,POSITX0) DATA IS PRESENT */
         NC    PPOINTR,PPOINTR         IS DATA PRESENT
         BZ    POSITX0                 IF NO BRANCH
         SPACE
*/* P INDICATE IN PDE DATA PRESENT */
         OI    DATAFLA1,DATAPRES       YES - INDICATE SO IN PDE
         TM    PFLAGS6,PDEHEX          IS DATA HEXADECIMAL?      Y02666
         BZ    POSITX0                 NO, CONTINUE PROCESSING   Y02666
         OI    DATAFLA1,PDEHEX         YES, INDICATE IN PDE      Y02666
         SPACE
*/*POSITX0: P INDICATE PDE TWO WORDS LONG */
POSITX0  DS    0H                      * * * *
         NI    PFLAGS6,HFF-PDEHEX-NUMFLG  RESET FLAGS            Y02666
         LA    R1,SEVEN                INDICATE PDE IS TWO WORDS LONG
         SPACE
*
* ENTRY POINT FOR ADDRESS, DSNAME AND USERID ROUTINES. THE PDE LENGTH
* IS IN R1. TRANSLATION TO UPPERCASE HAS ALREADY TAKEN PLACE.
*
*/*POSITX: P SAVE LENGTH OF DATA */
POSITXCB EQU   *                       ENTRY FROM COBOL SUPPORT  F41448
*                                      MODULE                    F41448
POSITX   DS    0H                      * * * *
         ST    LINK2,PLINKSV1          SAVE RETURN ADDR FOR
*                                         POSSIBLE 2ND RANGE VALUE
*/* D (NO,POSITXC,YES,) PROCESSING COBOL PCE'S? */
         TM    CBFLAGS1,COBOLMOD       PROCESSING COBOL PCE'S?   F41448
         BZ    POSITXC                 NO-CONTINUE NORMAL PARSE  F41448
*/* P STORE RETURN ADDRESS INTO IKJPARS2 */
         L     LINK2,CBLNKSV2          STORE CORRECT RETURN      F41448
         ST    LINK2,PLINKSV1          ADDRESS INTO PLINKSV1     F41448
*                                      FOR RET TO COBOL MODULE   F41448
*/*POSITXC: P SAVE PDESIZE */
POSITXC  STC   R1,PPCOUNT              SAVE LENGTH FOR FUTURE USE
         STC   R1,PPDESIZE             SAVE SIZE OF PDE-1
*/* D (YES,POSITX12,NO,) 2ND RANGE VALUE */
         TM    PFLAGS2,RNGEVAL2        IS THIS THE 2ND RANGE VALUE
         BO    POSITX12                YES, SPECIAL PROCESSING
         SPACE
*
* CALCULATE PDE ADDRESS.
*
         MVC   PDWORD(TWO),PCEPDEO(XPCE) ALIGN PDE OFFSET ON PROPER
*                                         BOUNDARY
         LH    R3,PDWORD               LOAD THE PDE OFFSET
*/* P GET TRUE ADDRESS OF PDE */
         A     R3,XPDL                 GET TRUE ADDRESS OF PDE
         ST    R3,PDEADR               STORE ADDR OF PDE IN PARM LIST
*                                         FOR POSSIBLE VALIDITY
*                                         CHECK EXIT
         XC    PREVPDEL,PREVPDEL       CLEAR PREVIOUS PDE POINTER ---
*                                         ITS USED AS A SWITCH IN THE
*                                         VALIDITY CHECK ROUTINE
         LA    R2,ONE(R1)              GET SIZE OF DATA
         AR    R2,R3                   OBTAIN ADDR OF POSSIBLE
*                                         2ND HALF OF PDE
         ST    R2,RNG2ADDR             SAVE FOR POSSIBLE 2ND
*                                         RANGE VALUE
*/* D (YES,,NO,POSITX55) RANGE SPACE ALOTTED IN PDE */
         TM    PCEFLGB2(XPCE),PCEFRNGE  IS RANGE SPACE ALOTTED IN PDE
         BZ    POSITX55                NO, CONTINUE
         SPACE
*/* P GET ACTUAL SIZE OF PDE */
         LA    R1,ONE(R1,R1)           YES, ADD LENGTH OF 2ND PDE TO
*                                         GET ACTUAL SIZE OF PDE-1
         STC   R1,PPDESIZE             SAVE
         SPACE
*/*POSITX55: D (YES,,NO,POSITX9A) PROCESSING A LIST */
POSITX55 DS    0H                      * * * *
         TM    PFLAGS,PFLIST           ARE WE PROCESSING A LIST
         BZ    POSITX9A                NO BIT ZERO --- BRANCH
         SPACE
*
* FIND LAST LIST ELEMENT ON LIST CHAIN. STORAGE FOR THE FIRST PDE IN
* A LIST IS OBTAINED BY THE INITIALIZATION ROUTINE.
*
*/*POSITX5: P INDICATE AT LEAST ONE PDE BUILT */
POSITX5  DS    0H                      * * * *
         OI    PFLAGS3,PFONE           INDICATE AT LEAST ONE PDE
*                                         HAS BEEN BUILT
*/* P GET PTR TO CHAIN PTR */
         LA    R15,ONE(R1,R3)          GET PTR TO CHAIN PTR
*/* D (YES,POSITXLE,NO,) FIRST ELEMENT OF LIST BEING STORED */
         EX    R1,POSITXNC             IS ACTUAL PDE EMPTY --- FIRST
*                                         ELEMENT OF LIST BEING STORED
         BZ    POSITXLE                YES IF ZERO --- BRANCH
         SPACE
*/* D (YES,POSITXCE,NO,) LAST PDE IN CHAIN */
         CLI   ZERO(R15),HFF           IS THIS THE LAST PDE IN CHAIN
         BE    POSITXCE                IF YES BRANCH
         SPACE
*/* P GET PTR TO NEXT CHAIN ELEMENT */
         L     R3,ZERO(R15)            FETCH PTR TO NEXT CHAIN ELEMENT
*/* D (,POSITX5) LOOP THROUGH CHAIN */
         B     POSITX5                 LOOP THROUGH CHAIN
         SPACE
*
* ALLOCATE NEW PDE FOR CHAIN.
*
*/*POSITXCE: P ZERO LAST ELEMENT IN CHAIN INDICATOR */
POSITXCE DS    0H                      * * * *
         MVI   ZERO(R15),ZERO          ZERO LAST ELEMENT IN CHAIN
*                                         INDICATOR
         LR    R3,R15                  SAVE CHAIN POINTER
         ST    R3,PREVPDEL             SAVE PREVIOUS PDE POINTER
*/* P INDICATE HOW MUCH CORE NEEDED */
         LA    R1,FIVE(R1)             INDICATE TO STORAGE ALLOCATION
*                                         ROUTINE HOW MUCH CORE NEEDED
*/* S STALOC: ALLOCATE STORAGE */
         BAL   LINK2,STALOC            ALLOCATE STORAGE
         SPACE
*                                      STORAGE ADDRESS RETURNED IN R1
*/* P FORWARD CHAIN ELEMENTS */
         ST    R1,ZERO(R3)             FORWARD CHAIN ELEMENTS
         LR    R3,R1                   SAVE NEW ELEMENT ADDRESS
         ST    R3,PDEADR               STORE ADDRESS OF NEW PDE FOR
*                                         POSSIBLE VALIDITY CHECK EXIT
         SR    R1,R1                   ZERO REG TO HOLD ONE BYTE LENGTH
         IC    R1,PPCOUNT              GET SIZE OF DATA -1
*/* P GET ACTUAL SIZE OF DATA */
         LA    R2,ONE(R1)              GET ACTUAL SIZE OF DATA
*/* P SAVE ADDR OF POSSIBLE 2ND HALF OF PDE */
         AR    R2,R3                   OBTAIN ADDR OF POSSIBLE
*                                         2ND HALF OF PDE
         ST    R2,RNG2ADDR             SAVE FOR POSSIBLE 2ND VALUE
         SR    R1,R1                   ZERO REG TO HOLD ONE BYTE LENGTH
         IC    R1,PPDESIZE             LOAD SIZE OF PDE-1
*/* P GET NEXT PDE PTR */
         LA    R15,ONE(R1,R3)          POINT TO NEXT PDE PTR
         SPACE
*/*POSITXLE: P SET LAST ELEMENT IN CHAIN INDICATOR */
POSITXLE DS    0H                      * * * *
         MVI   ZERO(R15),HFF           SET LAST ELEMENT IN CHAIN
*                                         INDICATOR
*/* D (YES,POSITX9,NO,) FIRST VALUE OF A RANGE */
         TM    PFLAGS2,RNGEVAL1        IS THIS THE 1ST VALUE OF A RANGE
         BO    POSITX9                 YES, EXIT
*
*/*POSITX13: S SKIPB: SKIP SEPARATORS */
POSITX13 DS    0H                      ENTRY FOR 2ND VALUE OF RANGE
         BAL   LINK2,SKIPB             SKIP BLANKS
*
*/* D (YES,POSITX9,NO,) LIST COMPLETE */
         B     POSITX9                 +0 RETURN - LIST COMPLETE
*
*/* P INCREMENT SCAN PTR */
         LA    XINPUT,ONE(XINPUT)      +4 RETURN - BUMP SCAN PTR
*/* D (YES,,NO,POSITX6) END OF LIST */
         CLI   ZERO(XINPUT),RIGHTPRN   IS THIS END OF LIST
         BNE   POSITX6                 IF NO BRANCH
         SPACE
*/* P INDICATE LIST END DELIMITER FOUND */
         OI    PFLAGS4,PFLSTEND        INDICATE LIST END DELIMITER  HAS
*                                         BEEN FOUND
         SPACE
*/*POSITX9: P MOVE DATA TO PDE */
POSITX9  DS    0H                      * * * *
         XR    R1,R1                   CLEAR WORK REG TO ZERO
         IC    R1,PPCOUNT              LOAD PDE LENGTH
         EX    R1,PDEXMV               MOVE DATA TO PDE
*/* D (YES,,NO,POSITX9B) FIRST VALUE OF RANGE BEING PROCESSED */
         TM    PFLAGS2,RNGEVAL1        IS THE FIRST VALUE OF A RANGE
*                                         BEING PROCESSED
         BZ    POSITX9B                NO - CONTINUE
         SPACE
         L     LINK2,PLINKSV1          RESTORE RETURN ADDR FOR RANGE 2
         XC    TEMPPDE(CBLTPDE),TEMPPDE ZERO TEMPORARY STORAGE AREA FOR
*                                         PDE                    F41448
*/* R RETURN TO CALLER */
         BR    LINK2                   YES, RETURN TO CALLER
         SPACE
*/*POSITX9B: D (YES,,NO,POSITX9C) LEFT PAREN USED AS BEGINNING OF SUBF
*/* AND LIST */
POSITX9B DS    0H                      * * * *
         TM    PFLAGS5,RPRNFND         WAS END OF LIST FOUND     Y02666
         BO    POSITX9C                NO, BRANCH                Y02666
         TM    PFLAGS3,PFMORE          WAS LEFT PAREN USED AS BEGINNING
*                                         OF SUBFIELD AND LIST BECAUSE
*                                         ONLY ONE PARAMETER WAS
*                                         POSSIBLE WITHIN THE SUBFIELD
         BZ    POSITX9C                IF NO BRANCH              Y02666
*/* D (YES,,NO,POSITX9C) THIS IS END OF FIELD */
POSITXAA DS    0H                                                Y02666
         TM    PFLAGS,PFENDF           IS THIS THE END OF FIELD
         BNZ   POSITX9C                NO, BRANCH
         SPACE
*/* P DECREMENT SCAN PTR */
         BCTR  XINPUT,ZERO             DECREMENT SCAN POINTER
         SPACE
*/*POSITX9C: D (,VCERTN) BRANCH TO VALIDITY CHECK EXIT RTN */
POSITX9C DS    0H                      * * * *
         TM    PFLAGS5,INVFLG                                    Y01156
         BO    POSITX4                                           Y01156
         BAL   LINK1,VCERTN            BRANCH TO VALIDITY CHECK EXIT
*                                         ROUTINE
         SPACE
*/*POSITX4: P INDICATE POSSIBLE LIST NOT BEING PROCESSED ANY MORE */
POSITX4  DS    0H                      * * * *
         NI    PFLAGS,HFF-PFLIST       INDICATE POSSIBLE LIST NOT BEING
*                                         PROCESSED ANY MORE
*/* D (,POSITX3) BUMP TO NEXT PCE */
         B     POSITX3                 BUMP TO NEXT PCE
         SPACE
*/*POSITX9A: D (YES,,NO,POSITX9) LIST SPECIFIED IN PCE */
POSITX9A DS    0H                      SET 'FF' IN PDE IF LIST WAS
*                                         SPECIFIED IN PCE BUT NOT
*                                         ENTERED
         TM    PCEFLGB2(XPCE),PCEFLIST IS LIST SPECIFIED IN PCE
         BZ    POSITX9                 NO - CONTINUE
         SPACE
         XR    R1,R1                   ZERO WORK REG
         IC    R1,PPDESIZE             GET LENGTH OF BASIC PDE -1
         LA    R1,ONE(R1,R3)           GET ADDR OF LIST PTR
*/* P INDICATE LIST NOT ENTERED */
         MVI   ZERO(R1),HFF            INDICATE LIST WAS NOT ENTERED
*/* D (,POSITX9) CONTINUE */
         B     POSITX9                 CONTINUE
         SPACE
*/*POSITX6: P MOVE DATA TO PDE */
POSITX6  DS    0H                      * * * *
         XR    R1,R1                   CLEAR WORK REG TO ZERO
         IC    R1,PPCOUNT              LOAD PDE LENGTH
         EX    R1,PDEXMV               MOVE DATA TO PDE
*/* D (YES,,NO,POSITX8) RIGHT PAREN FOUND */
         TM    PFLAGS4,PFLSTEND        RIGHT PAREN FOUND         M3333
         BZ    POSITX8                 NO, CONTINUE              M3333
*/* D (YES,POSITX7,NO,) THIS CHARACTER RIGHT PAREN */
         CLI   ONE(XINPUT),RIGHTPRN    CHARACTER A RIGHT PAREN   M3333
         BE    POSITX7                 YES CONTINUE              M3333
         TM    PFLAGS5,RPRNFND         WAS A RIGHT PAREN FOUND   Y02666
         BO    POSITX7                 YES, CONTINUE             Y02666
         SPACE
*/*POSITX8: P DECREMENT SCAN PTR BEFORE EXIT */
POSITX8  DS    0H                      * * * *
         BCTR  XINPUT,ZERO             DECREMENT SCAN PTR BEFORE EXIT
*                                         IN CASE A NON-ZERO RETURN
*                                         CODE IS RETURNED
*/*POSITX7: S VCERTN: BRANCH TO VALIDITY CHECK EXIT RTN */
POSITX7  DS    0H                      * * * *
         TM    PFLAGS5,INVFLG                                    Y01156
         BO    NEXTPOS                                           Y01156
         BAL   LINK1,VCERTN            BRANCH TO VALIDITY CHECK EXIT
*                                        ROUTINE
         SPACE
*/* D (YES,POSITX71,NO,) LIST END DELIMITER BEEN FOUND */
NEXTPOS  DS    0H                                                Y01156
         TM    PFLAGS4,PFLSTEND        HAS LIST END DELIMITER BEEN
*                                         FOUND
         BO    POSITX71                IF END OF LIST, CONTINUE  F41448
*                                      NORMAL PARSE              F41448
         TM    PFLAGS5,RPRNFND         WAS A RIGHT PAREN FOUND?  Y02666
         BO    POSITX71                YES,CONTINUE NORMAL PARSE Y02666
*
*/*NOTEND1: D (NO,NEXTPCE,YES,) PROCESSING COBOL PCE'S? */
NOTEND1  TM    CBFLAGS1,COBOLMOD       PROCESSING COBOL PCE'S?   F41448
*                                      IF COBOL MODE AND NOT END F41448
*                                      OF LIST, RETURN MUST BE   F41448
*                                      TO COBOL MACRO PROCESSORS F41448
         BZ    NEXTPCE                 IF NOT COBOL MODE, GO TO  F41448
*                                      PROCESS NEXT PCE          F41448
*/* P LOAD RETURN ADDRESS INTO IKJPARS2 */
*/* R () EXIT TO IKJPARS2 */
         L     LINK2,CBLNKSV2          IF IN COBOL MODE, RETURN  F41448
         BR    LINK2                   TO MACRO PROCESSOR AT     F41448
*                                      ADDRESS IN CBLNKSV2       F41448
         SPACE
*/*POSITX71: P TURN OFF POSSIBLE LIST FLAG */
POSITX71 NI    PFLAGS,HFF-PFLIST       YES, TURN OF POSSIBLE LIST FLAG
         SPACE
*
* END OF POSITIONAL PARAMETER PROCESSING --- POINT TO NEXT PCE AND
* RETURN TO MAIN CONTROL ROUTINE.
*
*/*POSITX3: P CLEAR POSSIBLE ONE-PDE AND NO-SKIP-AFTER-PROMPT FLAGS */
POSITX3  DS    0H                      * * * *
         NI    PFLAGS3,HFF-PFONE       CLEAR POSSIBLE ONE PDE FLAG
         NI    RFLAGS,HFF-RFNOSKIP     CLEAR POSSIBLE NO SKIP AFTER
*                                         PROMPT FLAG
*/* D (YES,,NO,POSITX31) PROCESSING COBOL PCE'S? */
         TM    CBFLAGS1,COBOLMOD       PROCESSING COBOL PCE'S    F41448
         BZ    POSITX31                NO-CONTINUE NORMAL PARSE  F41448
*/* P LOAD RETURN ADDRESS INTO IKJPARS2 */
*/* R () EXIT TO IKJPARS2 */
         L     LINK2,CBLNKSV2          IF IN COBOL MODE, RETURN  F41448
         BR    LINK2                   TO MACRO PROCESSORS TO    F41448
*                                      HANDLE THE END OF LIST    F41448
*                                      AND NEXTPCE PROCESSING    F41448
POSITX31 MVC   PDWORD(TWO),PCELEN(XPCE) ALIGN PCE LENGTH ON PROPER
*                                         BOUNDARY
         AH    XPCE,PDWORD             COMPUTE THE NEXT PCE ADDRESS
*/*POSITX31: D (,NEXTPCE) GET NEXT PCE ADDRESS */
         B     NEXTPCE                 CONTINUE PARSE OF INPUT
         SPACE
*/*POSITX12: P SAVE ACTUAL SIZE OF PDE */
POSITX12 DS    0H                      * * * *
         LA    R1,ONE(R1,R1)           GET ACTUAL SIZE OF PDE -1
         STC   R1,PPDESIZE             SAVE
*/* P PREPARE TO MOVE DATA INTO 2ND HALF OF PDE */
         L     R3,RNG2ADDR             SET UP TO MOVE DATA INTO
*                                         2ND HALF OF PDE
*/* P TURN OFF 2ND VALUE FLAG */
         NI    PFLAGS2,HFF-RNGEVAL2    TURN OFF VAL 2 FLAG
*/* D (YES,POSITX13,NO,POSITX9) LIST BEING PROCESSED */
         TM    PFLAGS,PFLIST           IS A LIST BEING PROCESSED
         BZ    POSITX9                 N0, MOVE DATA AND EXIT
         SPACE
         B     POSITX13                YES, CHECK FOR MORE DATA IN THE
*                                         LIST
         EJECT
*
* IDENT PCE ROUTINE
*
*/*IDENT: P GET SIZE OF PDE */
IDENT    DS    0H                      PROCESS IDENT-TYPE POSITIONAL
*                                         PARAMETERS
         LA    R1,SEVEN                GET SIZE OF PDE-1
         STC   R1,PPCOUNT              SAVE
*/* D (YES,IDENTERS,NO,) IN ERASE MODE */
         TM    RFLAGS,RFERASE          IS THE SCAN IN ERASE MODE
         BO    IDENTERS                YES, BRANCH TO ERASE THE PDE
*
*/* S SCANF: POP STACK IF POSSIBLE */
         BAL   LINK1,SCANF             IF POSSIBLE POP THE INPUT STACK
*                                         TO GET NEXT LEVEL OF DATA
*                                         BEFORE THE SCAN BEGINS
*
         NOP   ZERO                    +0 RETURN - NO INPUT DATA LEFT
*
*                                      +4 RETURN - DATA REMAINS IN
*                                         CURRENT LEVEL OR POP OCCURRED
*
         XC    DATAPTR1(LTPDE),DATAPTR1 ZERO TEMPORARY
*                                         STORAGE AREA FOR PDE
*
*/* S SKIPB: SKIP SEPARATORS */
         BAL   LINK2,SKIPB             SKIP BLANKS TO BEGINNING OF PARM
*
*/* D (YES,IDMSNG,NO,) END OF INPUT REACHED (PARM IS MISSING) */
         B     IDMSNG                  +0 RETURN - END OF INPUT REACHED
*                                         PARM IS MISSING
*
*                                      +4 RETURN - BEGINNING OF PARM
*                                         ESTABLISHED
*
*/* S LISTT: TEST AND SET UP FOR LIST */
         BAL   LINK1,LISTT             TEST AND SET UP FOR LIST
*                                         XINPUT POINTS TO NEXT ITEM IN
*                                         THE LIST IF LIST IS PRESENT
*/* D (YES,,NO,ILLIDENT) DATA IN LIST */
         B     ILLIDENT                RETURN +0, NO DATA IN LIST, ERR
*
*                                      RETURN +4, DATA TO SCAN
         LA    R0,LRPAREN+ONE          TEST FOR DUMMY SUBFIELD   Y02666
         CR    R0,XINPUT               IS IT DUMMY?              Y02666
         BE    IDMSNG                  YES, PARAMETER IS MISSING Y02666
         SPACE
*
* ENTRY POINT FOR RESCANNING NEW DATA
*
*/*IDENTRSC: P SAVE PTR FOR INVALID MSG */
IDENTRSC DS    0H                      * * * *
         MVC   INVPSAVE,PPOINTR        SAVE PTR FOR INVALID MSG
*/*IDRNG2SC: D (YES,ID00,NO,) MAX LENGTH SPECIFIED */
IDRNG2SC DS    0H                      ENTRY TO SCAN 2ND RANGE VALUE
         TM    PCEOPT(XPCE),PCEFMAXL   IS A MAX LENGTH SPECIFIED
         BNZ   ID00                    YES, CONTINUE
*
*/* P GET ADDR OF GENSCAN CONTROL INFO */
         LA    R3,PCEOPT(XPCE)         NO, GET ADDR OF GENSCAN CONTROL
*/* D (,ID005) BRANCH */
         B     ID005                      INFO
         SPACE
*/*ID00: P MOVE INFO FROM IDENT PCE TO WORK AREA */
ID00     MVC   PDWORD+FOUR(THREE),PCEOPT(XPCE) NO, MOVE OPTIONS, FIRST,
*                                         AND OTHER BYTES FROM IDENT
*                                         PCE TO WORK AREA
         MVC   PDWORD(TWO),PCEPARMT(XPCE) ALIGN PARAMETER TYPE LENGTH
*                                         ON PROPER BOUNDARY
         LH    R2,PDWORD               LOAD THE LENGTH
         LA    R2,PCEPARMT(R2,XPCE)    COMPUTE ADDRESS OF MAXLNTH
*/* P MAKE MAXLENGTH CONTIGUOUS TO TYPE FIELD IN WORK AREA */
         MVC   PDWORD+SEVEN(ONE),ZERO(R2) MAKE MAXLENGTH
*                                         CONTIGUOUS TO OTHER TYPE
*                                         FIELD IN WORK AREA
*/* P GET ADDR OF GENSCAN CONTROL INFO */
         LA    R3,PDWORD+FOUR          GET ADDR OF GENSCAN CONTROL INFO
         SPACE
*/*ID005: P USE GENSCAN FOR SYNTAX CHECKING */
ID005    DS    0H                      * * * *
         ST    R3,PDWORD               SAVE ADR OF GENSCAN CONTROL INFO
*                                         IN PDWORD
         L     R15,AGENSCAN            GET ADDRESS OF GENSCAN ROUTINE
         BALR  LINK2,R15               USE GENSCAN FOR SYNTAX CHECKING
*                                         THIS LINKAGE CLOBBERS R0,
*                                         R1, R2, R14 AND LINK1 AND
*                                         ALSO MODIFIES XINPUT, XINPUTB
*                                         PPOINTR
*
*/* D (YES,IDMSNG,NO,) PARAMETER MISSING */
         BCT   XINPUT,IDMSNG           +0 RETURN - MISSING, BACK UP
*
*/* D (YES,ILLIDENT,NO,) PARAMETER TOO LONG */
         BCT   XINPUT,ILLIDENT         +4 RETURN - TOO LONG, BACK UP
*                                         INPUT, PROCESS INVALID
*
*/* D (YES,IDEND,NO,) END OF INPUT IS DELIMITER */
         B     IDEND                   +8 RETURN - END IS DELIMITER
*
*                                      +12 RETURN - OK, CHECK DELIMITER
*/* S RANGE: CHECK FOR RANGE */
         BAL   LINK1,RANGE             CHECK FOR RANGE
*/* D (YES,,NO,IDGOOD1) FIRST VALUE OF RANGE */
         B     IDGOOD1                 +0 RETURN - RANGE NOT ALLOWED OR
*                                         RANGE NOT PRESENT OR
*                                         2ND VALUE OF RANGE
*                                      +4 RETURN - 1ST VALUE OF RANGE
*/* P LOAD ADDR OF 2ND VALUE SCAN */
         LA    LINK2,IDRNG2SC          LOAD ADDR OF 2ND VALUE SCAN
*/* D (,IDEND1) PROCESS END */
         B     IDEND1                  PROCESS END
         SPACE
*/*IDGOOD1: S TYPETEST: CHECK FOR DELIMITER CHARACTER */
IDGOOD1  DS    0H                      * * * *
*
         NI    PFLAGS6,HFF-CHARFLG     TURN OFF FLAG             Y02666
         LA    R15,ONE(XINPUT)         GET NEXT CHARACTER PTR    YM3610
         C     R15,ENDINPUT            END OF INPUT?             YM3610
         BC    CC10,COMBYPS3           BYPASS COMMENT CHECK       M4540
         CLC   ZERO(TWO,XINPUT),SLASHAST A COMMENT DELIMITER?    Y02666
         BE    IDEND1                  YES, A VALID DELIMITER    Y02666
COMBYPS3 DS    0H                      CHECK FOR DELIMITER       YM3610
         LA    R1,DLIMREQD             SET CHAR TYPE FOR DELIMITER TEST
         BAL   LINK1,TYPETEST          TEST
*
*/* D (YES,IDEND1,NO,ILLIDENT) GOOD DELIMITER */
         BCT   XINPUT,ILLIDENT         +0 RETURN - BAD
*
         B     IDEND1                  +4 RETURN - GOOD DELIMITER
         SPACE
*/*IDEND: D (YES,,NO,IDEND1) FIRST VALUE OF RANGE ENTERED */
IDEND    DS    0H                      * * * *
         TM    PFLAGS2,RNGEVAL1        WAS 1ST VALUE OF RANGE ENTERED
         BZ    IDEND1                  NO, CONTINUE
*/* P TURN OFF FIRST VALUE SWITCH */
         NI    PFLAGS2,HFF-RNGEVAL1    TURN OFF 1ST VALUE SWITCH
*/* P TURN ON 2ND VALUE SWITCH */
         OI    PFLAGS2,RNGEVAL2        TURN ON 2ND VALUE SWITCH
*/*IDEND1: P SAVE LENGTH */
IDEND1   DS    0H                      * * * *
         TM    PFLAGS6,NUMFLG+PDEHEX   INTEG OR HEX PROCESSED?   Y02666
         BM    IDEXIT                  YES,BYPASS LENGTH COMPUTE Y02666
         S     XINPUTB,PPOINTR         COMPUTE LENGTH
         STH   XINPUTB,PLENGTH         SAVE
*/* D (,POSITX1) EXIT */
IDEXIT   DS    0H                                                Y02666
         BCT   XINPUT,POSITX1          BACK UP, EXIT TYPE 1
         SPACE
*/*IDMSNG: D (YES,ILLIDENT,NO,) FIRST RANGE VALUE FOUND */
IDMSNG   DS    0H
         TM    PFLAGS2,RNGEVAL1        WAS THE 1ST RANGE VALUE FOUND
         BO    ILLIDENT                YES, THEN IT IS INVALID
*
*/* S PROMPTQ: TRY TO PROMPT OR DEFAULT */
         BAL   LINK1,PROMPTQ           TRY TO PROMPT OR DEFAULT
*
*/* D (YES,IDENTRSC,NO,POSITX2) NEW DATA TO SCAN */
         B     IDENTRSC                +0 RETURN - NEW DATA TO SCAN
*
         B     POSITX2                 +4 RETURN - NO DATA, TAKE NULL
*                                         PDE EXIT
         SPACE
*
         EJECT
***********************************************************************
*                                                                     *
*   THE POINTER TO THE FIRST KEYWORD PCE IS SAVED AND THE INPUT IS    *
* SCANNED FOR THE NEXT IDENTIFIER. THE PCL IS SEARCHED FOR A MATCHING *
* KEYWORD AS FOLLOWS -                                                *
*              1. A KEYWORD PCE RESETS THE NAME COUNTER TO ONE.       *
*              2. WHEN AN NAME PCE IS FOUND THE NAME IS COMPARED TO   *
*                 THE KEYWORD IN THE INPUT BUFFER. IF ITS NOT EQUAL   *
*                 THE NEXT PCE IS USED.                               *
*                                                                     *
*   EVENTUALLY, A MATCH IS FOUND AND THE NAME COUNTER IS STORED INTO  *
* THE PDE.                                                            *
*   IF A SUBFIELD IS NOT REQUIRED THE NEXT IDENTIFIER IS SCANNED. IF  *
* IT IS A TEST IS MADE TO SEE IF IT WAS ENTERED. IF IT WAS NOT, A     *
* DUMMY () PAIR IS PLACED INTO THE INPUT STACK FOR LATER SCANNING. IF *
* THE FIRST SUBFIELD PARAMETER IS A POSITIONAL LIST, THE SCAN POINTER *
* IS RESET SO THAT THE LEFT PARENTHESIS IS RESCANNED LATER FOR THE    *
* LIST.                                                               *
*                                                                     *
***********************************************************************
         SPACE
*/*KEYWD: P SET KEYWORD PARSED ONCE FLAG */
KEYWD    DS    0H                      PROCESS KEYWORD PARAMETERS
         ST    XPCE,RKEYSV             SAVE START OF KEYWORD PCL SECT.
         OI    RFLAGS,RFKYPRSE         SET PARSED ONCE FLAG
         SPACE
*
* SCAN FOR NEXT IDENTIFIER.
*
*/*KEYWDSCN: S SCANF: POP STACK IF POSSIBLE */
KEYWDSCN DS    0H                      * * * *
         BAL   LINK1,SCANF             IF POSSIBLE POP THE INPUT STACK
*                                         TO GET NEXT LEVEL OF DATA
*                                         BEFORE THE SCAN BEGINS
*
*/* D (YES,,NO,KEYWDXI2) DATA REMAINS */
         B     KEYWDXI2                +0 RETURN - NO INPUT DATA LEFT
*
*                                      +4 RETURN - DATA REMAINS IN
*                                         CURRENT LEVEL OR POP OCURRED
         SPACE
*/* S SKIPB: SKIP SEPARATORS */
         BAL   LINK2,SKIPB             SKIP BLANKS
*
*/* D (YES,,NO,KEYWDXI2) DATA LEFT TO SCAN */
         B     KEYWDXI2                +0 RETURN - NO DATA LEFT TO SCAN
*
*                                      +4 RETURN - SCAN NEXT CHARACTER
         LA    R1,KEYSYNTX             GET REQUIRED SYNTAX FOR A KEYWD
         ST    R1,PDWORD               SAVE FOR GENSCAN
         L     R15,AGENSCAN            GET ADDRESS OF GENSCAN ROUTINE
*/* P USE GENSCAN FOR SYNTAX CHECKING */
         BALR  LINK2,R15               USE GENSCAN FOR SYNTAX CHECKING
*
*                                      SYNTAX CHECK FOR A KEYWORD
*
*/* D (YES,KEYWDMIS,NO,) INVALID 1ST CHARACTER */
         B     KEYWDMIS                +0 RETURN - INVALID 1ST    M3337
*                                         CHAR, TEST FOR END OF   M3337
*                                         SUBFIELD OR SEMICOLON   M3337
*
*/* D (YES,ILLKEYWD,NO,) PARAMETER TOO LONG */
         BCT   XINPUT,ILLKEYWD         +4 RETURN - TOO LONG, BACKUP AND
*                                         PROCESS INVALID
*
*/* D (YES,KEYWDEND,NO,) END OF BUFFER IS DELIMITER */
         B     KEYWDEND                +8 RETURN - END IS DELIMITER
*
*                                      +12 RETURN - CHECK DELIMITER
         LA    R15,ONE(XINPUT)         GET NEXT CHARACTER PTR    YM3610
         C     R15,ENDINPUT            END OF INPUT?             YM3610
         BC    CC10,COMBYPS4           BYPASS COMMENT CHECK       M4540
         CLC   ZERO(TWO,XINPUT),SLASHAST TEST FOR COMMENT DELIM. Y02666
         BE    KEYWDEND                END OF KEYWORD            Y02666
*/* D (YES,KEYWDEND,NO,) IS DELIMITER LEFT PAREN FOR SUBFIELD */
COMBYPS4 DS    0H                      CHECK FOR LEFT PAREN      YM3610
         CLI   ZERO(XINPUT),LEFTPRN    IS THE DELIMITER A LEFT PAREN
*                                         FOR A SUBFIELD
         BE    KEYWDEND                YES - GOOD, GO COMPUTE LENGTH
         SPACE
         LA    R1,DLIMREQD             TEST FOR LEGAL END DELIMITER
*/* S TYPETEST: TEST FOR VALID END DELIMITER */
         BAL   LINK1,TYPETEST          * * * *
         SPACE
*/* D (YES,ILLKEYWD,NO,) INVALID DELIMITER */
         BCT   XINPUT,ILLKEYWD         +0 RETURN - ILLEGAL
         SPACE
*                                      +4 RETURN - GOOD DELIMITER
         SPACE
*/*KEYWDEND: P COMPUTE KEYWORD LENGTH */
KEYWDEND DS    0H
         S     XINPUTB,PPOINTR         COMPUTE KEYWORD LENGTH
         STH   XINPUTB,PLENGTH         SAVE LENGTH OF KEYWORD
         BCTR  XINPUT,ZERO             BACK UP INPUT POINTER BY ONE
         SPACE
*
* LOCATE THE IKJNAME PCE THAT CORRESPONDS TO THE ENTERED KEYWORD. IF
* A KEYWORD PCE IS FOUND THE NAME COUNTER IS RESET TO ONE. A NAME PCE
* CAUSES THE NAME IN THE PCE TO BE COMPARED TO THE ENTERED KEYWORD, IF
* UNEQUAL, GO TO THE NEXT PCE.
*
         L     R15,ATRANSQ             GET ADDRESS OF TRANSLATE
*                                         ROUTINE
*/* P TRANSLATE KEYWORD TO UPPER CASE IF NECESSARY */
         BALR  LINK1,R15               TRANSLATE THE KEYWORD TO UPPER
*                                         CASE IF NECESSARY
         SPACE
*/* P GET FIRST KEYWORD ENTRY */
         L     XPCE,RKEYSV             PICK UP FIRST KEYWORD ENTRY
         XR    R14,R14                 CLEAR MATCH COUNTER         P
         SPACE
*/*KEYWDTL2: P FIND KEYWROD PROCESSOR ROUTINE */
KEYWDTL2 DS    0H                      * * * *
         XR    R2,R2                   CLEAR WORK REGISTER TO ZERO
         IC    R2,PCEFLGB1(XPCE)       LOAD TYPE INDICATOR
         N     R2,TYPEMASK             ISOLATE TYPE INDICATOR BITS
         SRL   R2,THREE                POSITION BITS FOR INDEXED BRANCH
         B     *+FOUR(R2)              FIND KEYWORD PROCESSOR ROUTINE
*
*/* D (YES,KEYWDXIT,NO,) END-OF-FIELD */
         B     KEYWDXIT                END-OF-FIELD --- EXIT
*
*/* D (YES,KEYWDXIT,NO,) POSITIONAL */
         B     KEYWDXIT                POSITIONAL --- EXIT
*
*/* D (YES,KEYWDTL3,NO,) NEW KEYWORD SPECIFICATION */
         B     KEYWDTL3                NEW KEYWORD SPECIFICATION
*
*/* D (YES,KEYWDNAM,NO,) NAME PCE */
         B     KEYWDNAM                NAME PCE --- PROCESS IT
*
*/* D (YES,KEYWDXIT,NO,) IDENT */
         B     KEYWDXIT                IDENT PCE --- EXIT
         SPACE
*/*KEYWDNAM: P COMPARE KEYWORD ENTERED TO NAME PCE */
KEYWDNAM DS    0H                       * * * *
         XC    TEMPPDE(LTPDE),TEMPPDE  CLEAR WORK AREA
         SR    R1,R1                   CLEAR TEMP. WORK REGISTER Y02666
         IC    R1,PCENAML(XPCE)        LOAD LENGTH OF NAME-1 FROM NAME
*                                         PCE
         EX    R1,NAMEMVC              MOVE NAME TO WORK AREA
         LH    R2,PLENGTH              LOAD KEYWORD LENGTH FOR COMPARE
         BCTR  R2,ZERO                 REDUCE LENGTH FOR 'EX' INSTR.
         L     R1,PPOINTR              LOAD ADDRESS OF KEYWORD
         EX    R2,KEYWDCLC             COMPARE KEYWORD ENTERED TO NAME
*                                         PCE - KEYWORD LENGTH
*                                         MAXIMUM IS 31
*/* D (YES,KEYWDTL6,NO,) BRANCH IF EQUAL */
         BE    KEYWDTL6                IF EQUAL BRANCH
         TM    PCEFLGB2(XPCE),PCEFALS  WERE ALIASES SPECIFIED?   Y02666
         BZ    KEYWDTL5                NO, GET NEXT PCE          Y02666
         SR    R1,R1                   CLEAR TEMP. WORK REGISTER Y02666
         SR    R15,R15                 CLEAR TEMP. WORK REGISTER Y02666
         IC    R1,PCENAML(XPCE)        GET NAME LENGTH FIELD     Y02666
*  UPDATE PAST NAME FIELD                                        Y02666
         LA    R1,SIX(R1,XPCE)         NAME LENGTH IS ONE LESS THAN
*                                      ACTUAL LENGTH             Y02666
*  R1 NOW POINTS TO SUBFIELD OFFSET OR INSERT DATA OR ALIAS DATA Y02666
*  IT MUST BE DETERMINED WHICH ONE.                              Y02666
         TM    PCEFLGB1(XPCE),PCEFSUBF SUBFIELD SPECIFIED?       Y02666
         BZ    KEYWDA                  BYPASS FIELD UPDATE       Y02666
         LA    R1,TWO(R1)              UPDATE PAST PCE OFFSET    Y02666
KEYWDA   DS    0H                                                Y02666
         TM    PCEFLGB2(XPCE),PCEFINST INSERT SPECIFIED?         Y02666
         BZ    KEYWDC                  NO, BYPASS FIELD UPDATE   Y02666
         IC    R15,ZERO(R1)            PICK UP INSERT LENGTH     Y02666
         LA    R1,TWO(R1,R15)          BYPASS INSERT DATE        Y02666
         CLI   ZERO(R1),ZERO           COMPARE LENGTH TO ZERO    Y02666
         BZ    KEYWDTL5                YES, GET NEXT PCE         Y02666
KEYWDC   DS    0H                                                Y02666
         IC    R0,ZERO(R1)             GET TOTAL # OF ALIASES    Y02666
         L     R15,PPOINTR             GET INPUT POINTER         Y02666
         LA    R1,ONE(R1)              GET FIRST ALIAS POINTER   Y02666
         SR    R9,R9                   CLEAR TEMP. WORK REGISTER Y02666
ABCOMP   DS    0H                                                Y02666
         IC    R9,ZERO(R1)             GET LENGTH OF ALIAS       Y02666
         EX    R2,NAMECOMP             IS INPUT KEYWORD EQUAL?   Y02666
         BNE   KEYUPDAT                YES,PROCESS VALID KEYWORD Y02666
         OI    PFLAGS6,ALIASFLG        INDICATE ALIAS FOUND      Y02666
         B     KEYWDTL6                PROCESS VALID KEYWORD     Y02666
KEYUPDAT DS    0H                                                Y02666
         LA    R1,ONE(R1,R9)           GET NEXT ALIAS POINTER    Y02666
         BCT   R0,ABCOMP               DECREMENT ALIAS NUMBER AND
*                                      CONTINUE                  Y02666
*                                      IF NONE LEFT,GET NEXT PCE Y02666
         SPACE
*/*KEYWDTL5: P BUMP PTR TO NEXT PCE */
KEYWDTL5 DS    0H                      * * * *
         LA    R3,ONE(R3)              BUMP NAME COUNTER BY ONE
         MVC   PDWORD(TWO),PCELEN(XPCE) ALIGN PCE LENGTH FIELD ON
*                                         PROPER BOUNDARY
         AH    XPCE,PDWORD             BUMP PTR TO NEXT PCE
*/* D (,KEYWDTL2) GET NEXT PCE */
         B     KEYWDTL2                GET NEXT PCE
         SPACE
*/*KEYWDTL3: P SET NAME COUNTER TO ONE */
KEYWDTL3 DS    0H                      * * * *
         LA    R3,ONE                  SET NAME COUNTER TO ONE
*/* S KEYWDX1: SKIP THIS KEYWORD ENTRY */
         BAL   LINK1,KEYWDX1           SKIP THIS KEYWORD ENTRY
         SPACE
*/* D (,KEYWDTL2) GET NEXT PCE */
         B     KEYWDTL2                GET NEXT PCE
         SPACE
*
* A MATCH WAS FOUND, THE NAME COUNTER IS STORED INTO THE PDE AND A TEST
* IS MADE TO SEE IF A SUBFIELD MAY BE PRESENT. IF A SUBFIELD MAY BE
* SPECIFIED THE PROCESS IS REPEATED. IF A SUBFIELD WAS NOT SPECIFIED A
* DUMMY SET OF PARENTHESIS, (), IS PLACED ONTO THE INPUT STACK FOR
* LATER SCANNING. IF THE FIRST SUBFIELD PARAMETER IS A POSITIONAL LIST,
* THE SCAN POINTER IS RESET SO THAT THE LEFT PARENTHESIS IS RESCANNED
* LATER FOR THE LIST.
*
*/*KEYWDTL6: P COMPARE LENGTH OF NAME TO LENGTH OF KEYWORD ENTERED */
KEYWDTL6 DS    0H                      * * * *
         ST    XPCE,PKEYWDTB           SAVE TABLE POINTER FOR KEYWORD
         MVC   PKEYWDPM,PKEYWDPS       SAVE CURRENT NAME PCE POINTER
         MVC   PKEYWDPX,PKEYWDPC       SAVE CURRENT KEYWD PCE POINTER
         STH   R3,PKEYWDVL             SAVE NAME NUMBER
         TM    PFLAGS6,ALIASFLG        WAS ALIAS ENTERED         Y02666
         BO    KEYALS                  YES, COMPARE ITS LENTH    Y02666
         XR    R1,R1                   CLEAR FOR INSERT
         IC    R1,PCENAML(XPCE)        LOAD LENGTH OF NAME-1 FROM NAME
*                                         PCE
         CR    R1,R2                   COMPARE LENGTH-1 OF KEYWORD
*                                         ENTERED TO LENGTH-1 OF NAME
*                                         IN PCE
*/* D (YES,KEYWDFN1,NO,) LENGTHS EQUAL */
         BE    KEYWDFN1                IF EQUAL DO NOT CHECK FOR
*                                         AMBIGUITY
         SPACE
*/* D (,KEYWDTL5) CHECK FOR FURTHER MATCHES */
KEYMUPD  DS    0H                                                Y02666
         LA    R14,ONE(R14)            INDICATE MATCH FOUND       M2574
         B     KEYWDTL5                CHECK FOR FURTHER MATCHES
KEYALS   DS    0H                                                Y02666
         NI    PFLAGS6,HFF-ALIASFLG    TURN OFF ALIAS FLAG       Y02666
         BCTR  R9,ZERO                 DECREMENT LENGTH BY ONE   Y02666
         CR    R9,R2                   ARE TEH LENGTHS EQUAL     Y02666
         BE    KEYWDFN1                YES, COMPLETE PROCESS     Y02666
         B     KEYMUPD                 NO, UPDATE MATCH CTR.     Y02666
         SPACE
*/*KEYWDFNO: P STORE MATCH NUMBER IN PDE */
KEYWDFN0 DS    0H                      STORE MATCH NUMBER IN PDE
         NI    RFLAGS,HFF-RFERASE      CLEAR ERASE INDICATOR
         SPACE
*/*KEYWDFN1: P RESTORE PDE AND PCE POINTERS */
KEYWDFN1 DS    0H                      * * * *
         L     XPCE,PKEYWDTB           RESTORE PCE POINTER TO PLACE
*                                         WHEN FOUND
         L     R3,PKEYWDPM             RESTORE PDE POINTER ALSO
*                                         COMPUTED EARLIER
*/* D (YES,KEYWDRPT,NO,) PDE ALREADY FILLED IN */
         NC    ZERO(TWO,R3),ZERO(R3)   WAS PDE ALREADY FILLED IN
         BNZ   KEYWDRPT                YES --- BRANCH --- ERROR
         SPACE
         MVC   ZERO(TWO,R3),PKEYWDVL   STORE MATCH VALUE IN PDE
*/* D (YES,KEYWDSUB,NO,) IS SUBFIELD POSSIBLE */
         TM    PCEFLGB1(XPCE),PCEFSUBF IS A SUBFIELD POSSIBLE
         BO    KEYWDSUB                YES --- PROCESS SUBFIELD
         SPACE
*/*KEYWDINS: D (YES,,NO,KEYWDSCN) IS INSERT OPTION SPECIFIED */
KEYWDINS DS    0H                      CHECK FOR INSERT OPTION
         TM    PCEFLGB2(XPCE),PCEFINST IS INSERT OPTION SPECIFIED
         BZ    KEYWDSCN                NO --- GET NEXT KEYWORD
         SPACE
*/* S PUSHI: PUSH STACK FOR DATA */
         BAL   LINK1,PUSHI             PUSH STACK FOR DATA
*                                         DATA
         SPACE
         XR    R2,R2                   CLEAR WORK REG
*/* P GET LENGTH OF NAME IN PCE */
         IC    R2,PCENAML(XPCE)        GET LENGTH OF NAME IN PCE
         LA    R2,PCENAML+TWO(R2,XPCE)         BUMP PTR PAST NAME
*/* D (YES,,NO,KEYWDIN1) IS SUBFIELD SPECIFIED */
         TM    PCEFLGB1(XPCE),PCEFSUBF IS A SUBFIELD SPECIFIED
         BZ    KEYWDIN1                NO, ALREADY POSITIONED AT INSERT
*                                         DATA
         SPACE
*/* P BUMP PTR PAST OFFSET TO SUBFIELD */
         LA    R2,TWO(R2)              BUMP PTR PAST OFFSET TO SUBFLD
         SPACE
*/*KEYWDIN1: P POINT TO START OF INSERT DATA */
KEYWDIN1 DS    0H                      * * * *
         LA    XINPUT,ONE(R2)          POINT TO START OF INSERT DATA
         ST    XINPUT,PPOINTR          SAVE FOR LATER
         XR    R1,R1                   CLEAR WORK REG TO ZERO
*/* P LOAD LENGTH OF INSERT DATA */
         IC    R1,ZERO(R2)             LOAD LENGTH-1 OF INSERT DATA
         LA    R1,TWO(R1,R2)           GET PTR TO END OF INSERT DATA
*/* P POINT TO END OF INSERT DATA */
         ST    R1,ENDINPUT             SAVE END OF INSERT DATA
*/* D (,KEYWDSCN) GET NEXT KEYWORD */
         BCT   XINPUT,KEYWDSCN         REDUCE PTR AND GET NEXT KEYWORD
         SPACE
*/*KEYWDSUB: P SET UP FOR SUBFIELD */
KEYWDSUB DS    0H                      SET UP FOR SUBFIELD
         OI    PFLAGS5,SUBFLG          INDICATE SUBFIELD IS BEING
*                                      PROCESSED                 Y01156
         MVC   KEYLEN(TWO),PLENGTH     SAVE KEYWORD LENGTH FOR MESSAGE
*                                      FOR PROMPTING             Y01156
         MVC   KEYPTR(FOUR),PPOINTR    SAVE USER KEYWORD PTR     Y01156
         XR    R1,R1                   CLEAR WORK REGISTER TO ZERO
         IC    R1,PCENAML(XPCE)        LOAD LENGTH - 1 OF NAME
         AR    R1,XPCE                 POINT INTO IKJNAME PCE
         MVC   PDWORD(TWO),SIX(R1)     ALIGN SUBFIELD OFFSET ON PROPER
*                                         BOUNDARY
         LH    R3,PDWORD               LOAD THE SUBFIELD OFFSET
*/* P COMPUTE SUBFIELD ADDRESS */
         A     R3,PTABLEAD             COMPUTE REAL SUBFIELD ADDRESS
*
********
******** NOTE - R3 NOW POINTS TO SECOND BYTE OF IKJSUBF PCE
********
*
         BAL   LINK2,SKIPB             SKIP SEPARATORS           Y02666
         B     KEYWDFN2                END-OF INPUT,PROCESS      Y02666
         LA    XINPUT,ONE(XINPUT)      MORE DATA IN BUFFER
         LR    XINPUTB,XINPUT          SET BACKUP REGISTER
*/* D (YES,KEYWDRS1,NO,) CHARACTER IS LEFT PAREN */
         CLI   ZERO(XINPUT),LEFTPRN    IS CHARACTER A LEFT PARENTHESIS
         BE    KEYWDRS1                IF YES BRANCH
         SPACE
*/* D (YES,KEYWDFN2,NO,) END OF INPUT */
         BCTR  XINPUT,ZERO             REDUCE SCAN PTR BY ONE
         SPACE
*/* S PUSHI: PUSH INPUT STACK */
         BAL   LINK1,PUSHI             PUSH DOWN INPUT STACK
         SPACE
*/*KEYWDFN2: P POINT TO DUMMY () */
KEYWDFN2 DS    0H                      * * * *
         LA    XINPUT,LRPAREN          POINT TO DUMMY ()
         LA    R0,LRPAREN+L'LRPAREN    SET END OF INPUT POINTER
         ST    R0,ENDINPUT             SAVE POINTER
         SPACE
*/*KEYWDRS1: D (YES,KEYWDRS3,NO,) IKJPOSIT PCE */
KEYWDRS1 DS    0H                      * * * *
         MVC   PDWORD(ONE),TWO(R3)     MOVE FLAG BYTE ONE OF PCE
         NI    PDWORD,HE0              ISOLATE THE TYPE INDICATOR BITS
*                                         FOLLOWING SUBFIELD PCE TO
*                                         WORK AREA
         CLI   PDWORD,EIGHT*(POSITBB-MAINB) IS IT A IKJPOSIT PCE
         BE    KEYWDRS3                IF YES BRANCH
         SPACE
*/* D (YES,,NO,KEYWDRS2) IKJIDENT PCE */
         CLI   PDWORD,EIGHT*(IDENTB-MAINB) IS IT AN IKJIDENT PCE
         BNE   KEYWDRS2                IF NO BRANCH
         SPACE
*
* IF THE SUBFIELD CAN CONTAIN ONLY ONE PARAMETER AND THAT PARAMETER CAN
* BE A LIST THE PARENTHESIS OF THE SUBFIELD IS ALSO USED AS THE
* DELIMITERS OF THE LIST. FOR EXAMPLE, KEYWORD(ITEM1 ITEM2). A LIST OF
* THE FORM KEYWORD((ITEM1 ITEM2)), CAUSES THE MIDDLE SET OF
* PARENTHESIS TO BE PICKED UP AS INVALID ITEMS IN THE LIST.
* IF THE SUBFIELD CAN CONTAIN MORE THAN ONE PARAMETER AND THE FIRST
* PARAMETER CAN BE A LIST THE SUBFIELD PARENTHESIS ARE NOT USED AS THE
* DELIMITERS OF THE LIST. IN THIS CASE THE PARENTHESIS DELIMITING
* THE LIST MUST BE SPECIFIED. FOR EXAMPLE, KEYWORD((ITEM1 ITEM2) (ITEM1
* ITEM2)).
* IF THE FIRST PARAMETER CAN NOT BE A LIST THERE IS NO ADDITIONAL
* CONSIDERATION REQUIRED.
*
*/*KEYWDRS3: D (YES,,NO,KEYWDRS2) LIST IS SPECIFIED */
KEYWDRS3 DS    0H                      * * * *
         TM    THREE(R3),PCEFLIST      IS A LIST SPECIFIED
         BZ    KEYWDRS2                IF NO DON'T BACK UP
         SPACE
         SPACE
         MVC   PDWORD(TWO),PCELEN+TWO(R3) ALIGN PCE LENGTH ON PROPER
*                                         BOUNDARY
         SPACE
*
********
******** N O T E  - ABOVE MVC AND TM ARE DEPENDENT ON THE LENGTH OF THE
********            SUBFIELD PCE.
********
*
         SPACE
*/* P COMPUTE TRUE ADDRESS OF NEXT PCE */
         LH    R2,PDWORD               LOAD THE PCE LENGTH
         LA    R2,TWO(R3,R2)           OBTAIN TRUE ADDRESS OF NEXT PCE
         MVC   PDWORD(ONE),PCEFLGB1(R2) ISOLATE FLAG BYTE ONE
         NI    PDWORD,HE0              ISOLATE THE TYPE INDICATOR BITS
*/* D (YES,,NO,KEYWDRS2) IS IT AN END PCE */
         CLI   PDWORD,EIGHT*(ENDB-MAINB) IS IT AN END PCE
         BNE   KEYWDRS2                IF NO BRANCH
         SPACE
*/* P INDICATE LEFT PAREN USED AS DELIMITER OF SUBF AND LIST */
         OI    PFLAGS3,PFMORE          INDICATE LEFT PAREN USED AS
*                                         DELIMITER OF SUBFIELD AND
*                                         LIST
*/* P BACK UP OVER LEFT PAREN */
         BCTR  XINPUT,ZERO             BACK UP OVER LEFT PARENTHESIS
         SPACE
*/*KEYWDRS2: P INDICATE KEYWORD WITH SUBFIELD */
KEYWDRS2 DS    0H                      * * * *
         LR    R2,R3                   SET PCE PTR FOR RECURSE ROUTINE
*                                         XPCE WILL BE SET TO NEXT PCE
*                                         IN RECURSE ROUTINE
         OI    RFLAGS,RFKEYWDS         INDICATE KEYWORD WITH SUBFIELD
*/* S REUCRSE: PROCESS SUBFIELD */
         BAL   LINK1,RECURSE           PROCESS SUBFIELD
         SPACE
         NI    PFLAGS5,HFF-SUBFLG      TURN OFF SUBFIELD FLAG    Y01156
*/* D (,KEYWDINS) SCAN NEXT KEYWORD */
         B     KEYWDINS                SCAN NEXT KEYWORD
         SPACE
*/*KEYWDRPT: P GET ADDRESS FOR ERASE PDE */
KEYWDRPT DS    0H                      * * * *
         OI    RFLAGS,RFERASE          SET ERASE IN PROCESS FLAG
         LA    R0,KEYWDFN0             SET RETURN ADDRESS FROM ERASE TO
         ST    R0,RLINKSV1                BE ADDRESS FOR NEW KEYWORD
         LR    R2,R3                   PICK UP ADDRESS FOR ERASE PDE
         L     XPCE,PKEYWDPX           PICK UP PCE ADDRESS FOR IKJKEYWD
*/* D (,KEYWDER4) START ERASE */
         B     KEYWDER4                START ERASE
         SPACE
*/*KEYWDXIT: D (YES,ILLKEYWD,NO,) NO MATCHES FOUND */
KEYWDXIT DS    0H                      * * * *
*                                                                 M2574
         LA    R0,ONE                  GET NUMBER OF VALID MATCHES
         CR    R14,R0                  HOW MANY MATCHES FOUND     M2574
         BL    ILLKEYWD                NONE, INVALID KEYWORD      M2574
         SPACE
*/* D (YES,KEYWDAMB,NO,) MORE THAN ONE MATCH FOUND */
         BH    KEYWDAMB                MORE THAN ONE, AMBIGIOUS   M2574
         SPACE
*/* D (,KEYWDFN1) ONLY ONE - PROCESS IT */
         B     KEYWDFN1                ONE, PROCESS IT            M2574
         SPACE
*/*KEYWDXI2: P RESTORE ENTRY PCE ADDRESS */
KEYWDXI2 DS    0H                      * * * *
         L     XPCE,RKEYSV             RESTORE ENTRY PCE ADDRESS
*/* D (,NEXTPCE) GET NEXT PCE */
         B     NEXTPCE                 GET NEXT PCE.
         SPACE
*
* AN AMBIGOUS MESSAGE IS ISSUED IF MORE THAN ONE MATCH IS FOUND.
* THIS IS DONE USING THE SAME INVALID PROCESSING TO KEEP THE
* HANDLING OF INVALID DATA CONSISTENT.  SOME SPECIAL HANDLING IS DONE
* WITH REGARD TO THE MSG SEGMENTS SINCE THE FORMAT OF THE MSG IS
* DIFFERENT.
*
*/*KEYWDAMB: P INDICATE AMBIGUOUS MSG TO BE WRITTEN */
KEYWDAMB DS    0H                      * * * *
         MVI   MSGCODE,MSG4            INDICATE AN AMBIGUOUS MSG
*                                         SHOULD BE WRITTEN
*/* D (,ILLKAMB1) BRANCH TO ILLKEYWD PROCESSING */
         B     ILLKAMB1                BRANCH TO ILLKEYWD PROCESSING
         SPACE
*
* THE FIRST CHARACTER OF A KEYWORD IS INVALID. CHECK IF IT IS THE M3337
* CLOSING PAREN OF A SUBFIELD OR A SEMICOLON.  IF YES, EXIT THE   M3337
* KEYWORD SCANNING.  IF NO, PROCESS IT AS AN INVALID KEYWORD.     M3337
*
*/*KEYWDMIS: D (YES,KEYWDXI2,NO,) FIRST CHAR A SEMICOLON */
KEYWDMIS DS    0H                      * * * *
         LR    R1,XINPUT               SAVE XINPUT                M3337
         BCTR  XINPUT,ZERO             DECREMENT AS USUAL         M3337
         CLI   ZERO(R1),SEMICOLN       IS 1ST CHAR A SEMICOLON    M3337
         BE    KEYWDXI2                YES, END OF KEYWORD SCAN   M3337
*/* D (YES,,NO,ILLKEYWD) SUBFIELD BEING PROCESSED */
         NC    RBASESV,RBASESV         IS A SUBFIELD BEING        M3337
*                                         PROCESSED               M3337
         BZ    ILLKEYWD                NO, IT IS AN INVALID KEYWD M3337
*/* D (YES,KEYWDXI2,NO,ILLKEYWD) FIRST CHAR. A RIGHT PAREN */
         CLI   ZERO(R1),RIGHTPRN       IS 1ST CHAR A RT. PAREN    M3337
         BNE   ILLKEYWD                NO, IT IS AN INVALID KEYWD M3337
         B     KEYWDXI2                YES, IT IS THE CLOSING     M3337
*                                         PAREN OF A SUBFIELD     M3337
*                                         EXIT KEYWD SCAN         M3337
         SPACE
         EJECT
***********************************************************************
*                                                                     *
*                       PROMPT/DEFAULT SUBROUTINE                     *
*                                                                     *
*   DETERMINE IF A PROMPT OR DEFAULT WAS SPECIFIED BY THE CALLER, IF  *
* NOT, RETURN +4. IF A DEFAULT WAS SPECIFIED PREPARE TO TREAT IT AS   *
* IF IT WAS NEW DATA RECEIVED FROM A PROMPT.                          *
*   IF A PROMPT IS REQUIRED, THE PROMPT DATA IS ADDED TO THE 'ENTER'  *
* MESSAGE.                                                            *
*                                                                     *
***********************************************************************
         SPACE
*/*PROMPTQ: E PROMPT/DEFAULT ROUTINE */
*/*PROMPTZ: D (YES,,NO,PROMPTQ0) LIST IS BEING PROCESSED */
PROMPTQ  DS    0H                      PROMPT/DEFAULT ROUTINE
         TM    PFLAGS,PFLIST           IS A LIST BEING PROCESSED
         BZ    PROMPTQ0                NO, CONTINUE WITH PROMPT/DEFAULT
         SPACE
*/* P GET ADDRESS OF DUMMY () */
         LA    R0,LRPAREN+ONE          GET ADDRESS OF DUMMY ( )
*                                         INSERTED BY PARSE WHEN KEY-
*                                         WORD SPECIFYING SUBFIELD
*                                         ENTERED WITHOUT SUBFIELD AND
*                                         WHERE CURRENT SCAN PROCESSING
*                                         COULD BE
*/* D (YES,PROMPTQ0,NO,CODE4) PROCESSING THIS () */
         CR    R0,XINPUT               PROCESSING THIS ( )
         BE    PROMPTQ0                YES, PROMPT/DEFAULT IF CAN
         SPACE
         B     CODE4                   IF NO BRANCH - THE FIRST
*                                         CHARACTER OF CURRENT INPUT
*                                         PARAMETER MUST BE INVALID FOR
*                                         THE TYPE OF PARAMETER
*                                         PRESENTLY BEING CHECKED FOR.
*                                         IF A LIST IS BEING PROCESSED
*                                         THIS PARAMETER IS TREATED AS
*                                         AN INVALID PARAMETER, TO
*                                         AVOID A LOOP FROM OCCURING.
         SPACE
         SPACE
*/*PROMPTQ0: D (YES,PROMPTQY,NO,) PROMPT/DEFAULT IS SPECIFIED */
PROMPTQ0 DS    0H                      * * *
         TM    PCEFLGB1(XPCE),PCEFPRPT+PCEFDFLT IS PROMPT OR DEFAULT
*                                         SPECIFIED
*/* R RETURN +4 */
         BZ    FOUR(LINK1)             NO RETURN +4
         SPACE
         TM    PFLAGS5,INVPRMPT        HAS PROMPTING BEEN DONE   A45352
*                                      PREVIOUSLY  FOR THIS PARAMETER?
         BO    CODE4                   YES,PROMPT WITH INVALID MESSAGE
*                                                               A45352
*/*PROMPTQY: P SAVE RETURN ADDRESS */
         OI    PFLAGS5,INVPRMPT        INDICATE PROMPT FOR THIS PCE
*                                                               A45352
         ST    LINK1,PLINKSV1          SAVE RETURN ADDRESS
*/* S PUSHI: PUSH STACK TO GET NEW INPUT */
         BAL   LINK1,PUSHI             PUSH STACK TO RECEIVE NEW INPUT
         SPACE
*/*PROMPTQ1: P GET PCE TYPE INDICATORS */
PROMPTQ1 DS    0H                      ENTERED FROM WRITER2 ROUTINE TO
*                                         USE DEFAULT IN PLACE OF A
*                                         NULL LINE
*/* D (NO,PROMPTQ2,YES,) PROCESSING COBOL PCE'S? */
         TM    CBFLAGS1,COBOLMOD       PROCESSING COBOL PCE'S?   F41448
         BZ    PROMPTQ2                NO-CONTINUE NORMAL PARSE  F41448
*                                      IF IN COBOL MODE, SPECIAL F41448
*                                      CODE REQUIRED TO POSITION F41448
*                                      TO DEFAULT WITHIN THE     F41448
*                                      COBOL PCE'S               F41448
*/* D (YES,TERMPCE1,NO,) IS THE PCE TYPE A TERM PCE? */
         TM    PCEFLGB1(XPCE),HA0      IF PCETYPE IS MIXED HERE, F41448
*                                      MUST BE A TERM PCE        F41448
         BM    TERMPCE1                PCETYPES ARE AS FOLLOWS:  F41448
*                                      TERM - 110                F41448
*                                      OPER - 111                F41448
*                                      RESERVED WORD - 101       F41448
*/* P  OPER OR RESERVED WORD PCE - PARM TYPE FIELD AT OFFSET  +6 */
         MVC   PDWORD(TWO),SIX(XPCE)   IF OPER OR RESRVD WORD,   F41448
*                                      THE PARM TYPE FIELD IS AT F41448
*                                      OFFSET 6.                 F41448
         LH    R2,PDWORD               BUMP PASSED PARM TYPE     F41448
         LA    R2,SIX(R2)              FIELD                     F41448
*/* D (NO,CHKDEFLT,YES,) IS THIS AN OPER PCE? */
         TM    PCEFLGB1(XPCE),HE0      IF AN OPER PCE MUST BUMP  F41448
*                                      PASSED 8 BYTES OF OFFSET  F41448
*                                      FIELDS                    F41448
         BM    CHKDEFLT                IF MIXE, IS A RSVWD WORD  F41448
*/* P (,CHKDEFLT) BUMP PASSED 8 BYTES OF OFFSET FIELDS */
         LA    R2,EIGHT(R2)            BUMP PASSED OFFSET FIELDS F41448
         B     CHKDEFLT                BRANCH TO CHECK DEFAULT   F41448
*/*TERMPCE1: P TERM PCE - PARM TYPE FIELD AT OFFSET 7 */
*/* P (,CHKDEFLT) BUMP PASSED PARM TYPE FIELD IN TERM PCE */
TERMPCE1 MVC   PDWORD(TWO),SEVEN(XPCE) IF IS A TERM PCE, THE     F41448
*                                      PARM TYPE FIELD IS AT     F41448
*                                      OFFSET SEVEN              F41448
         LH    R2,PDWORD               BUMP PASSED PARM TYPE     F41448
         LA    R2,SEVEN(R2)            NOW POSITIONED AT DEFAULT F41448
         B     CHKDEFLT                BRANCH TO CHECK DEFAULT   F41448
PROMPTQ2 MVC   PDWORD(ONE),PCEFLGB1(XPCE) MOVE TYPE INDICATORS
         NI    PDWORD,HE0              ISOLATE PCE TYPE INDICATORS
*/*PROMPTQ2: D (YES,POSITPMT,NO,) IT IS AN IKJPOSIT PCE */
         CLI   PDWORD,EIGHT*(POSITBB-MAINB) IS IT AN IKJPOSIT PCE
         BE    POSITPMT                IF YES BRANCH
         SPACE
*/* D (YES,KEYWDPMT,NO,) IKJKEYWD PCE - IF NOT,MUST BE IKJIDENT */
         CLI   PDWORD,EIGHT*(KEYWDB-MAINB) IS IT AN IKJKEYWD PCE
         BE    KEYWDPMT                IF YES BRANCH
         SPACE
*                                      IT MUST BE AN IKJIDENT PCE
         MVC   PDWORD(TWO),PCEPARMT(XPCE) ALIGN PARAMETER TYPE LENGTH
*                                         ON PROPER BOUNDARY
         LH    R2,PDWORD               LOAD THE LENGTH
*/* P GET PTR TO PROMPT/DEFAULT DATA */
         LA    R2,PCEPARMT(R2)         LOAD PTR TO PROMPT/DEFAULT DATA
*/* D (YES,,NO,CHKDEFLT) MAXLNTH WAS SPECIFIED */
         TM    PCEOPT(XPCE),PCEFMAXL   WAS MAXLNTH SPECIFIED
         BZ    CHKDEFLT                IF NO BRANCH
         SPACE
*/* P ADD ADDITIONAL BYTE */
         LA    R2,ONE(R2)              IF YES ADD AN ADDITIONAL BYTE
*/* D (,CHKDEFLT) BRANCH TO MAIN STREAM */
         B     CHKDEFLT                BRANCH BACK TO MAIN STREAM
         SPACE
*/*KEYWDPMT: P LOAD PTR TO PROMPT/DEFAULT DATA */
KEYWDPMT DS    0H                      * * * *
         LA    R2,PCEPDEO+TWO          LOAD PTR TO PROMPT/DEFAULT DATA
*/* D (,CHKDEFLT) BRANCH TO MAIN STREAM */
         B     CHKDEFLT                BRANCH BACK TO MAIN STREAM
         SPACE
*/*POSITPMT: P LOAD PTR TO PROMPT/DEFAULT DATA */
POSITPMT DS    0H                      * * * *
         LA    R2,PCEPOST+ONE          LOAD PTR TO PROMPT/DEFAULT DATA
         SPACE
*/*CHKDEFLT: D (YES,,NO,PROMPT) DEFAULT WAS SPECIFIED */
CHKDEFLT DS    0H                      * * * *
         AR    R2,XPCE                 CALCULATE ACTUAL ADDRESS OF DATA
         TM    PCEFLGB1(XPCE),PCEFDFLT WAS A DEFAULT SPECIFIED
         BNO   PROMPT                  NO BRANCH TO PROMPT
*/* D (YES,INVPARMS,NO,PROMPDFL) ALREADY BEEN TAKEN */
         TM    PFLAGS,PFDEFLT          YES,HAS IT BEEN TAKED
         BZ    PROMPDFL                NO, BRANCH TO TAKE DEFAULT
         B     INVPARMS                YES,DEFAULT INVALID CLEANUP AND
*                                      EXIT
         SPACE
*
* ISSUE PROMPT MESSAGE 'ENTER XXX'.
*
*/*PROMPT: P GET LENGTH OF DATA */
PROMPT   DS    0H                      * * * *
         XR    R1,R1                   ZERO REG FOR LENGTH PICKUP
         IC    R1,ZERO(R2)             PICKUP LENGTH-1 OF PROMPT DATA
         LA    R1,FIVE(R1)             GET SIZE OF CORE FOR MESSAGE SEG
*                                         ONE PLUS FOUR FOR HEADER
         LR    R3,R1                   SAVE CALCULATED LENGTH
*/* S GETCORE: GET CORE FOR MESSAGE */
         BAL   LINK1,GETCORE           GET CORE FOR MESSAGE SEGMENT
         SPACE
*                                      CORE ADDRESS RETURNED IN R1
         ST    R1,SEGLIST+TWELVE       STORE ADDRESS IN LIST OF SEGMENT
         STH   R3,ZERO(R1)             STORE LENGTH INTO SEGMENT
         MVI   TWO(R1),ZERO            SET FIRST BYTE OF OFFSET TO ZERO
         MVI   THREE(R1),OFFSET1       SET OFFSET TO LENGTH OF 'ENTER'
*                                         MESSAGE
         SH    R3,H5                   REDUCE LENGTH FOR 'EX'
         LA    R15,ONE(R2)             GET START OF DATA ADDRESS
*/* P MOVE TEXT TO SEGMENT */
         EX    R3,BUILDSEG             MOVE TEXT TO NEW SEGMENT
         MVI   MSGCODE,MSG1            INDICATE MESSAGE TO PRINT
         L     R1,ADRMSGC              LOAD ADDRESS OF MESSAGE CSECT
         L     R1,MSG1(R1)             LOAD ADDRESS OF MESSAGE SEGMENT
         MVC   PRIMSGID+FOUR(EIGHT),FOUR(R1) SAVE PRIMARY MESSAGE ID
*                                         FOR HELP MESSAGES
*/* P INDICATE TWO SEGMENT MESSAGE */
         LA    R0,TWO                  INDICATE A TWO SEGMENT MESSAGE
         ST    R0,SEGLIST+FOUR         STORE SEGMENT NUMBER FOR PRIMARY
*                                         MESSAGE
*/* D (,WRITER2A) BRANCH TO PROMPT */
         B     WRITER2A                BRANCH TO PROMPT WITH A TWO
*                                         SEGMENT MESSAGE
         SPACE
*
* A DEFAULT WAS SPECIFIED.
*
*/*PROMPDFL: P INDICATE DEFAULT TAKEN */
PROMPDFL DS    0H                      * * * *
         OI    PFLAGS,PFDEFLT          INDICATE DEFAULT TAKEN
         OI    PFLAGS4,PFPDDATA        INDICATE DEFAULT DATA PICKED UP
*/* P POINT TO START AND END OF DEFAULT DATA */
         LA    XINPUT,ONE(R2)          POINT TO START OF DEFAULT TEXT
         ST    XINPUT,PPOINTR          SAVE FOR FUTURE USE
         LR    XINPUTB,XINPUT
         XR    R1,R1                   CLEAR WORK REG. TO ZERO
*/* P LOAD LENGTH OF DEFAULT DATA */
         IC    R1,ZERO(R2)             LOAD LENGTH OF DEFAULT TEXT - 1
         LA    R1,TWO(R1,R2)           GET PTR TO END OF DEFAULT DATA
         ST    R1,ENDINPUT             SAVE END OF DATA PTR
*/* D (,NOTENTER) BACK UP AND BRANCH */
         BCT   XINPUT,NOTENTER         BACK UP AND BRANCH
         EJECT
***********************************************************************
*                                                                     *
*                       SKIP BLANKS SUBROUTINE                        *
*                                                                     *
*   THE FUNCTION OF THIS ROUTINE IS TO SKIP BLANKS, COMMAS AND TABS IN*
* THE INPUT BUFFER.                                                   *
*   UPON ENTRY -                                                      *
*               XINPUT CONTAINS THE BUFFER ADDRESS                    *
*               LINK2 CONTAINS THE RETURN ADDRESS                     *
*   AN EXIT TO NSI +0 IS TAKEN IF THE END OF THE BUFFER HAS BEEN      *
* REACHED. A RETURN TO NSI +4 INDICATES THE XINPUT ADDRESS POINTS TO  *
* THE LAST SEPARATOR CHARACTER AND PPOINTR POINTS TO THE FIRST        *
* NON-SEPARATOR CHARACTER.                                            *
*                                                                     *
***********************************************************************
         SPACE
*/*SKIPB: E SKIP SEPARATORS SUBROUTINE */
*/*SKIPB2: P INCREMENT POINTER */
SKIPB    DS    0H                      SKIP SEPARATORS SUBROUTINE
         LA    XINPUT,ONE(XINPUT)      BUMP INPUT PTR BY ONE
         LR    XINPUTB,XINPUT          SET BACKUP REGISTER
*/* D (YES,,NO,SKIPB1) REACHED END OF INPUT */
         C     XINPUT,ENDINPUT         END OF INPUT
         BL    SKIPB1                  NO - BRANCH
         SPACE
*/* S SCANDLSN: TRY TO POP STACK */
SKIPBPOP DS    0H                                                Y02666
         BAL   LINK1,SCANDLSN          NO, TRY TO POP PUSHDOWN STACK
*
*/* D (YES,SKIPBX,NO,) END OF GROUP EXIT */
         B     SKIPBX                  +0 RETURN - END-OF-GROUP EXIT
*
         LA    XINPUT,ONE(XINPUT)      INCREMENT FOR DECREMENT    M3337
*/* D (NO,SKIPB1,YES,) PROCESSING COBOL PCE'S? */
         TM    CBFLAGS1,COBOLMOD       PROCESSING COBOL PCE'S?   F41448
         BZ    SKIPB1                  NO-CONTINUE NORMAL PARSE  F41448
*/* P SET XINPUTB = XINPUT IF IN COBOL MODE */
         LR    XINPUTB,XINPUT          IF YES, SET XINPUTB IN    F41448
*                                      CASE DATA IS NOT PRECEEDEDF41448
*                                      BY BLANKS - PARS2 DEPENDS F41448
*                                      ON SETTING OF XINPUTB     F41448
         SPACE
*/*SKIPB1: D (YES,SKIPB2,NO,) CHARACTER IS BLANK,COMMA OR TAB */
SKIPB1   DS    0H                      * * * *
         CLI   ZERO(XINPUT),BLNK       IS IT A BLANK
         BE    SKIPB                   IF YES REPEAT LOOP
         SPACE
         CLI   ZERO(XINPUT),COMMA      IS IT A COMMA
         BE    SKIPB                   IF YES REPEAT LOOP
         SPACE
         CLI   ZERO(XINPUT),TABCHAR    IS IT A TAB
         BE    SKIPB                   IF YES REPEAT LOOP
         LA    R15,ONE(XINPUT)         GET NEXT CHARACTER PTR    YM3610
         C     R15,ENDINPUT            END OF INPUT?             YM3610
         BC    CC10,COMBYPS5           BYPASS COMMENT TEST        M4540
         CLC   ZERO(TWO,XINPUT),SLASHAST IS THIS A COMMENT?      Y02666
         BE    SKIPCOMT                YES, PROCESS COMMENT      Y02666
         SPACE
*/* P STORE ADDRESS OF NON-SEPARATOR */
COMBYPS5 DS    0H                      SAVE INPUT PTR            YM3610
         ST    XINPUT,PPOINTR          STORE ADDRESS OF NON-SEPARATOR
*/* R BACK UP SCAN PTR BY ONE AND RETURN +4 */
         BCT   XINPUT,FOUR(LINK2)      BACK UP INPUT PTR BY ONE AND
*                                         RETURN TO NSI +4
         SPACE
*/*SKIPBX: P STORE ADDRESS */
SKIPBX   DS    0H                      * * * *
         ST    XINPUT,PPOINTR          STORE ADDRESS
*/* D (NO,DECEXIT,YES,) PROCESSING COBOL PCE'S? */
         TM    CBFLAGS1,COBOLMOD       PROCESSING COBOL PCE'S    F41448
         BZ    DECEXIT                 NO-CONTINUE NORMAL PARSE  F41448
*/* R () DO NOT DECREMENT SCAN PTR BEFORE RETURN TO IKJPARS2 */
         BR    LINK2                   IF YES, DO NOT DECREMENT  F41448
*                                      XINPUT A SECOND TIME      F41448
*/*DECEXIT: R BACK UP SCAN PTR BY ONE AND RETURN +0 */
DECEXIT  BCTR  XINPUT,LINK2            BACK UP INPUT PTR BY ONE AND
*                                         RETURN TO NSI +0
SKIPCOMT DS    0H                                                Y02666
         LA    XINPUT,TWO(XINPUT)      SKIP OVER SLASH ASTERISK  Y02666
SKIPB2   DS    0H                                                Y02666
         LA    R15,ONE(XINPUT)         GET NEXT CHARACTER PTR    YM3610
         C     R15,ENDINPUT            END OF INPUT?             YM3610
         BH    COMBYPS6                BYPASS COMMENT END TEST   YM3610
         CLC   ZERO(TWO,XINPUT),ASTSLASH COMMENT END DELIMITER?  Y02666
         BE    SKIPB3                  END COMMENT PROCESSING    Y02666
COMBYPS6 DS    0H                      UPDATE INPUT PTR          YM3610
         LA    XINPUT,ONE(XINPUT)      UPDATE TO NEXT CHARACTER  Y02666
         C     XINPUT,ENDINPUT         END OF BUFFER?            Y02666
         BNL   SKIPBPOP                YES,END COMMENT-POP STACK Y02666
         B     SKIPB2                  NO, CONTINUE SEARCH       Y02666
SKIPB3   DS    0H                                                Y02666
         LA    XINPUT,ONE(XINPUT)      UPDATE SCAN POINTER       Y02666
         B     SKIPB                   CONTINUE SCAN FOR SEPARATORS
*                                                                Y02666
         EJECT
***********************************************************************
*                                                                     *
*                       PUSH INPUT STACK SUBROUTINE                   *
*                                                                     *
*   IN THIS ROUTINE THE INPUT STACK IS PUSHED- THE CURRENT STATUS OF  *
* XINPUT AND ENDINPUT ARE SAVED IN THE STACK.                         *
*                                                                     *
***********************************************************************
         SPACE
*/*PUSHI: E PUSH INPUT STACK SUBROUTINE */
PUSHI    DS    0H                      PUSH INPUT STACK SUBROUTINE
*/* D (YES,,NO,PUSHIX) CURRENT STATUS IS TO BE SAVED */
         TM    PFLAGS,PFENDF           IS CURRENT STATUS TO BE SAVED
         BNZ   PUSHIX                  NO DON'T PUSH STACK THEN
         L     R15,UPTADDR             GET UPT PTR               Y02666
         TM    TWELVE(R15),INVPRMPT    IS NO PROMPT SPECIFIED?   Y02666
         BZ    PUSHON                  NO CONTINUE VALIDLY       Y02666
         TM    PFLAGS,PFLIST           YES,LIST PROCESSING,TOO   Y01156
         BZ    PUSHON                  NO, CONTINUE PROCESSING   Y01156
         BAL   LINK2,SKIPB             SKIP BLANKS               Y01156
         B     PUSHIX1                 END OF INPUT,RETURN       Y01156
         LA    XINPUT,ONE(XINPUT)      UPDATE FOR R. PAREN TEST  Y01156
         CLI   ZERO(XINPUT),RIGHTPRN   IS INPUT A RIGHT PAREN?   Y01156
         BE    PUSHON1                 NO, CONTINUE PROCESSING   Y01156
         BCT   XINPUT,PUSHON           DECREMENT AND BRANCH      Y01156
PUSHON1  DS    0H                                                Y01156
         TM    PFLAGS3,PFMORE          DOES R.PAREN TERMINATE LIST AND
*                                      SUBFIELD                  Y01156
         BZ    PUSHEY                  NO, DO NOT UPDATE         Y01156
         TM    PFLAGS,PFENDF           END OF INPUT FOUND        Y01156
         BNZ   PUSHEY                  YES DO NOT UPDATE         Y01156
         BCTR  XINPUT,ZERO             DECREMENT SCAN PTR        Y01156
PUSHEY   DS    0H                                                Y01156
         OI    PFLAGS5,RPRNFND         INDICATE R. PAREN FOUND   Y01156
         NI    PFLAGS,HFF-PFLIST       TURN OFF LIST INDICATOR   Y01156
         NI    PFLAGS3,HFF-PFMORE      TURN OFF L. PAREN INDICATOR
*                                                                Y01156
         SPACE
*/* D (YES,,NO,PUSHGET) ROOM LEFT IN CURRENT STACK */
PUSHON   DS    0H                                                Y01156
         CLI   PIPDLX,EIGHT*(IPDLMAXE) ANY ROOM IN CURRENT STACK
         BNL   PUSHGET                 NO - GET ANOTHER STACK
         SPACE
*
* PUSH THE INPUT PUSHDOWN STACK.
*
*/*PUSHIT: P PUSH THE STACK */
PUSHIT   DS    0H                      PUSH THE STACK
         XR    R15,R15                 ZERO WORK REGISTER
         IC    R15,PIPDLX              FETCH CURRENT AMOUNT OF INPUT
*                                         STACK USED
         LA    R1,EIGHT(R15)           BUMP INDEX FOR NEXT PUSH ATTEMPT
         STC   R1,PIPDLX               STORE THE NEW INDEX
         A     R15,PIPDLCUR            COMPUTE THE SAVE ADDRESS
         ST    XINPUT,FOUR(R15)        SAVE SCAN PTR IN STACK
         MVC   EIGHT(L'ENDINPUT,R15),ENDINPUT SAVE END OF SCAN PTR IN
*                                         STACK
         B     PUSHIX                                            Y01156
         SPACE
*/*PUSHIX: P CLEAR END OF FILE INDICATOR */
PUSHIX1  DS    0H                      * * * *                   Y01156
         NI    PFLAGS,HFF-PFLIST                                 Y01156
PUSHIX   DS    0H                      * * * *
         NI    PFLAGS,HFF-PFENDF       CLEAR END-OF-FILE INDICATOR
*/* R RETURN TO CALLER */
         BR    LINK1                   RETURN TO CALLER
         SPACE
*
* GET SPACE FOR ANOTHER INPUT PUSHDOWN STACK AND CHAIN IT TO THE
* PREVIOUS ONE.
*
*/*PUSHGET: S GETCORE: GET CORE FOR PUSHDOWN STACK */
PUSHGET  DS    0H                      GET ANOTHER PUSHDOWN STACK
         LA    R1,EIGHT*(IPDLMAXE)+FOUR LOAD AMOUNT OF CORE NEEDED
         LR    R3,LINK1                SAVE RETURN REGISTER
         BAL   LINK1,GETCORE           GET CORE FOR PUSHDOWN STACK
         SPACE
         LR    LINK1,R3                RESTORE RETURN REGISTER
         MVC   ONE(THREE,R1),PIPDLCUR+ONE BACKCHAIN THE NEW STACK
*/* P INDICATE NEW STACK IS NOW CURRENT ONE */
         ST    R1,PIPDLCUR             INDICATE NEW STACK IS NOW
*                                         THE CURRENT ONE
         MVI   PIPDLX,ZERO             RESET THE PUSHDOWN INDEX SO THAT
*                                         FIRST SPACE IS USED
*/* D (,PUSHIT) PUSH DOWN INTO NEW STACK */
         B     PUSHIT                  PUSH DOWN INTO NEW STACK
         EJECT
***********************************************************************
*                                                                     *
*                       SET UP TO PROCESS LIST SUBROUTINE             *
*                                                                     *
*   THIS ROUTINE DOES VARIOUS SET UP WORK TO PROCESS A LIST. THE      *
* RETURN ADDRESS IS IN LINK1.                                         *
*                                                                     *
***********************************************************************
         SPACE
*/*LISTT: E LIST SET UP SUBROUTINE */
LISTT    DS    0H                      LIST SET UP SUBROUTINE
*/* D (YES,LISTTY,NO,) LIST IS A LEGAL OPTION */
         TM    PCEFLGB2(XPCE),PCEFLIST IS A LIST A LEGAL OPTION
*/* R RETURN +4 */
         BZ    FOUR(LINK1)             IF NO RETURN +4
         SPACE
*/*LISTTY: D (YES,,NO,LISTTZ) ALREADY PROCESSING A LIST */
         TM    PFLAGS,PFLIST           ALREADY PROCESSING A LIST
*/* R RETURN +4 */
         BO    FOUR(LINK1)             IF YES, RETURN +4
         SPACE
*/*LISTTZ: P INCREMENT SCAN PTR */
         ST    LINK1,PLINKSV1          SAVE RETURN REGISTER
         LA    XINPUT,ONE(XINPUT)      INCREMENT SCAN PTR BY ONE
         LR    XINPUTB,XINPUT          SET BACKUP REGISTER
*/* D (YES,,NO,LISTX) THIS IS A LIST */
         CLI   ZERO(XINPUT),LEFTPRN    IS THIS A LIST
         BNE   LISTX                   NO RETURN
         SPACE
*/* S SKIPB: SKIP SEPARATORS AFTER ( */
         ST    XINPUT,INVPSAVE         YES - SAVE PTR TO PAREN
*                                         IN CASE IT IS INVALID
         BAL   LINK2,SKIPB             SKIP SEPARATORS
*
*/* D (YES,,NO,LISTERR) DATA RETURNED */
         B     LISTERR                 +0 RETURN - NO DATA IN LIST
         SPACE
*                                      +4 RETURN - DATA TO SCAN
         LA    XINPUT,ONE(XINPUT)      BUMP TO NEXT CHARACTER FOR LATER
*                                         DECREMENT
*/* P INDICATE PROCESSING A LIST */
         OI    PFLAGS,PFLIST           INDICATE PROCESSING A LIST
         SPACE
*/*LISTX: R REDUCE SCAN PTR BY ONE AND RETURN +4 */
LISTX    DS    0H                      * * * *
         L     LINK1,PLINKSV1          RESTORE RETURN ADDRESS
         BCT   XINPUT,FOUR(LINK1)      REDUCE SCAN PTR BY ONE AND
*                                         RETURN +4 TO CALLER
*/*LISTERR: P POINT TO INVALID PARAMETER */
LISTERR  DS    0H                      * * * *
         NI    PFLAGS3,HFF-PFMORE      TURN OFF FLAG WHICH INDICATES A
*                                      LEFT PAREN IS PRESENT     YM4036
         L     LINK1,PLINKSV1          RESTORE RETURN ADDRESS
         MVC   PPOINTR,INVPSAVE        SET PTR TO INVALID PARM
*/* R RETURN +0 */
         BR    LINK1                   RETURN +0 - ERROR
         EJECT
*        *                        **                                  *
*                                                                     *
*                             RANGE SUBROUTINE                        *
*                                                                     *
*                                                                     *
*        THIS ROUTINE DOES VARIOUS SET UP WORK TO PROCESS A RANGE.    *
*        A RETURN CODE OF +0 SPECIFIES THAT THE RANGE OPTION IS
*  1)NOT VALID, 2)VALID BUT AN ERROR CONDITION IS DETECTED,
*  3)VALID OPTION BUT NOT SPECIFIED, 4)VALID RANGE PARAMETER TO BE
*  CHECKED FOR VALID DELIMITER.
*        A +4 RETURN CODE DENTOES THE FIRST VALUE OF A RANGE PARAMETER
*  DETECTED
*  THE RETURN ADDRESS IS IN LINK1.                                    *
         SPACE
*/*RANGE: E RANGE SET UP ROUTINE */
RANGE    DS    0H                      RANGE SET UP ROUTINE
*/* D (YES,RANGEY,NO,) RANGE IS A LEGAL OPTION */
         TM    PCEFLGB2(XPCE),PCEFRNGE IS A RANGE A LEGAL OPTION
*/* R RETURN +0 */
         BCR   CC8,LINK1               IF NO, RETURN +0 (1)
         SPACE
*/*RANGEY: D (YES,,NO,VALUE1) A RANGE IS ALREADY BEING PROCESSED */
         TM    PFLAGS2,RNGEVAL1        ARE WE ALREADY PROCESSING A
*                                      RANGE PARAMETER
         BZ    VALUE1                  NO, BRANCH
*/*  D  (YES,RANGEZ,NO)  END OF BUFFER, DONT CHECK FOR COLON */  Y00971
         TM    PFLAGS,PFENDF           ARE WE AT END OF BUFFER   Y00971
         BO    RANGEZ                  YES, DONT CHECK FOR COLON Y00971
         SPACE
*/* D (YES,,NO,RANGEZ) THIS IS RANGE DELIMITER (:) */
         CLI   ZERO(XINPUT),COLON      IS THES A RANGE DELIMITER
*/* R RETURN +0 */
         BCR   CC8,LINK1               YES, ERROR, RETURN CODE OF +0(2)
         SPACE
*/*RANGEZ: P TURN ON BIT FOR SECOND VALUE OF RANGE */
RANGEZ   DS    0H                                                Y00971
         TM    PFLAGS7,VALENDF         SHOULD FLAGS BE SET       Y02666
         BO    RANGRC0                 NO, RETURN                Y02666
         NI    PFLAGS2,HFF-RNGEVAL1    TURN OFF CONTROL BIT FOR FIRST
*                                      VALUE OF RANGE PARAMETER
         OI    PFLAGS2,RNGEVAL2        TURN ON CONTROL BIT FOR SECOND
*                                      VALUE OF RANGE PARAMETER
*/* R RETURN +4 */
RANGRC0  DS    0H                                                Y02666
         BR    LINK1                   RETURN (4)
         SPACE
*/*VALUE1: D (YES,RANGEW,NO,) THIS IS RANGE DELIMITER (:) */
VALUE1   DS    0H                      * * * *
         CLI   ZERO(XINPUT),COLON      IS THIS A RANGE DELIMITER
*/* R RETURN +0 */
         BCR   CC7,LINK1               NO, BRANCH (3)
         SPACE
*/*RANGEW: P INDICATE PROCESSING A RANGE */
         TM    PFLAGS7,VALENDF         SHOUL FLAGS BE SET        Y02666
         BO    RANGRC4                 NO, RETURN                Y02666
         OI    PFLAGS2,RNGEVAL1        INDICATE PROCESSING A RANGE
         LA    XINPUT,ONE(XINPUT)      TEMPORARILY INCREMENT SCAN REG
*                                      DECREMENTED BEFORE EXITING
*/* R RETURN +4 */
RANGRC4  DS    0H                                                Y02666
         B     FOUR(LINK1)             RETURN +4
         EJECT
***********************************************************************
*                                                                     *
*               CONDITIONAL GETMAIN SUBROUTINE
*
*   A CONDITIONAL GETMAIN IS ISSUED FOR THE AMOUNT OF SPACE REQUESTED *
* FROM THE SUBPOOL INDICATED.  IF THE REQUESTED SPACE CANNOT BE       *
* ALLOCATED, A RETURN CODE OF 16 IS SET AND PROCESSING IS TERMINATED  *
* VIA CLEANUP.                                                        *
*                                                                     *
* ARG - R1=BYTE  0    SUBPOOL NUMBER                                  *
*          BYTES 1-3  NUMBER OF BYTES                                 *
*                                                                     *
* OUT - R1=ADDRESS OF ALLOCATED SPACE
*                                                                     *
* RETURN - LINK1                                                      *
*                                                                     *
* ERROR EXIT - CLEANUP                                                *
*                                                                     *
*   REGISTER RESTRICTIONS -                                           *
*                         R2 OR R3 CANNOT BE USED BY THIS ROUTINE     *
*                                                                     *
***********************************************************************
         SPACE
*/*GETCORE: E GET STORAGE ROUTINE */
GETCORE  DS    0H                      GET STORAGE ROUTINE
*/* P STORE LENGTH REQUESTED */
         ST    R1,PGETLNTH             PUT LENGTH REQUESTED IN GETMAIN
*                                         PARAMETER LIST
         MVC   PGETMDSP+ONE(ONE),PGETLNTH MOVE SUBPOOL FROM LENGTH WORD
*                                         TO GETMAIN PARM LIST
         NI    PGETLNTH,ZERO           CLEAR SUBPOOL INDICATOR FROM
*                                         LENGTH WORD
         LA    R1,PGETLIST             PUT ADDR OF GETMAIN PLIST IN R1
         SPACE
*/* P ISSUE GETMAIN */
         GETMAIN EC,A=SUBRWORK,MF=(E,(1)) ISSUE CONDITIONAL GETMAIN
         SPACE
*/* D (YES,,NO,GETERROR) STORAGE WAS ALLOCATED */
         LTR   R15,R15                 WAS STORAGE ALLOCATED
         BNZ   GETERROR                NO, PROCESS ERROR
         SPACE
*/* P SAVE ADDR OF AREA */
         L     R1,SUBRWORK             YES, PUT ADDR OF AREA IN R1
         LA    R1,ZERO(R1)             CLEAR HIGH ORDER BYTE
*/* R RETURN TO CALLER */
         BR    LINK1                   RETURN TO CALLER
         SPACE
*/*GETERROR: P SET RETURN CODE */
GETERROR DS    0H                      * * * *
         MVI   RETCODE,RCNOCORE        OTHERWISE - REPLACE
*/* D (,CLEANUP) GO CLEANUP */
         B     CLEANUP                 GO CLEANUP AND RETURN
         EJECT
***********************************************************************
*                                                                     *
*          CHARACTER TYPE TEST UTLITY ROUTINE                         *
*                                                                     *
*   THIS SUBROUTINE CHECKS THE CURRENT INPUT CHARACTER FOR THE        *
* CHARACTER TYPE GIVEN IN R1. IF THE SPECIFIED CHARACTER TYPE IS      *
* FOUND RETURN IS TO LINK1+4. OTHERWISE RETURN IS TO LINK1.           *
*                                                                     *
***********************************************************************
         SPACE
*/*TYPETEST: E CHARACTER TEST ROUTINE */
TYPETEST DS    0H                      CHARACTER TEST ROUTINE
         XR    R15,R15                 CLEAR WORK REG
*/* P USE CURRENT CHAR AS OFFSET INTO TABLE */
         IC    R15,ZERO(XINPUT)        USE CURRENT CHAR AS OFFSET INTO
*                                         TESTAB
         A     R15,ATRTAB              GET ADDRESS IN TABLE
*/* P EXECUTE TEST UNDER MASK FOR CHARACTER */
         EX    R1,TYPETM               EXECUTE TEST UNDER MASK OF
*                                         TYPEBYTE FOR CHAR
*                                         SPECIFICATION GIVEN IN R1
*/* D (YES,,NO,TESTA) TYPE MATCHES */
*/* R RETURN TO CALLER +4 */
*/*TESTA: R RETURN TO CALLER +0 */
         BC    CC5,FOUR(LINK1)         TYPE MATCHES, RETURN +4
         BR    LINK1                   TYPE DOESN'T MATCH,RETURN +0
         EJECT
***********************************************************************
*
* ADDRESS OF NEXT CSECT.
*
ADRCST2  DC    V(IKJEFP02)             ADDRESS OF THIRD CSECT
         SPACE
IKJEFP02 CSECT
***********************************************************************
         SPACE
***********************************************************************
*                                                                     *
*                       INFORMATIONAL MESSAGE SUBROUTINE              *
*                                                                     *
*   THIS ROUTINE USES PUTLINE TO WRITE INFORMATIONAL MESSAGES TO THE  *
* TERMINAL USER.                                                      *
*   UPON ENTRY THE ENTERED DATA TO BE INSERTED IN THE MESSAGE MUST BE *
* BUILT INTO A SEGMENT AND THE ADDRESS OF THE SEGMENT STORED INTO     *
* SEGLIST + EIGHT. THE RETURN ADDRESS MUST BE IN LINK1.               *
*                                                                     *
***********************************************************************
         SPACE
*/*WRITER1: E WRITE INFORMATIONAL MESSAGE */
WRITER1  DS    0H                      WRITE INFORMATIONAL MESSAGE
*/* P INDICATE NO HELP MESSAGES */
         MVC   SEGLIST(L'ENDCHAIN),ENDCHAIN INDICATE NO HELP MESSAGES
         SPACE
*/*WRITER1C: P INDICATE TWO SEGMENT MSG */
WRITER1C DS    0H                      * * * *
         LA    R15,TWO                 INDICATE ONLY TWO SEGMENT MSG
*/* D (YES,,NO,WRITER1A) INVALID IDENT MSG BEING WRITTEN */
         CLI   MSGCODE,MSG6            IS AN INVALID IDENT MSG BEING
*                                         WRITTEN
         BNE   WRITER1A                IF NO BRANCH
         SPACE
*/* P SWAP LAST TWO SEGMENTS */
         XC    SEGLIST+TWELVE(FOUR),SEGLIST+SIXTEEN SWAP THE LAST
         XC    SEGLIST+SIXTEEN(FOUR),SEGLIST+TWELVE TWO SEGMENT
         XC    SEGLIST+TWELVE(FOUR),SEGLIST+SIXTEEN ADDRESSES
*/* P INDICATE THREE SEGMENT MESSAGE */
         LA    R15,THREE               INDICATE A THREE SEGMENT MSG
*/* D (YES,WRITER1F,NO,) COBOL PCE'S - SKIP PRINT INHIBIT MODE CHECKS
*/**/
         TM    CBFLAGS1,COBOLMOD       PROCESSING COBOL PCE'S?   F41448
         BO    WRITER1F                YES, SKIP CHECKS FOR      F41448
*                                      PRINT INHIBIT MODE        F41448
*/* D (YES,,NO,WRITER1A) PRINT INHIBIT MODE DESIRED */
         TM    PFLAGS5,INVFLG          INVALID BUFFER BEING PROCESSED?
*                                                                Y01156
         BZ    WRITER1H                YES,BYPASS MODE REQUESTED?Y01156
         TM    PFLAGS5,BYPASFLG        BYPASS MODE FOR PREVIOUS PCE?
*                                                                Y01156
         BO    WRITER1J                                          Y01156
         B     WRITER1A                                          Y01156
WRITER1H DS    0H                                                Y01156
         TM    PCEOPT(XPCE),PCEFPTBY   PRINT INIBIT MODE DESIRED  M1564
         BZ    WRITER1A                NO,BRANCH                  M1564
*/* P INDICATE MESSAGE TO WRITE */
WRITER1J DS    0H                                                Y01156
         MVI   MSGCODE,MSG18           INCICATE MESSAGE TO WRITE  M1564
*/* P INDICATE TWO SEGMENT MESSAGE */
         LA    R15,TWO                 INDICATE TWO SEGMENT MSG   M1564
         B     WRITER1F                                           M1564
         SPACE
*/*WRITER1A: D (YES,WRITER1E,NO,) INVALID PASSWORD MSG BEING WRITTEN */
WRITER1A DS    0H                      * * * *
         CLI   MSGCODE,MSG9            IS AN INVALID PASSWORD MSG
*                                      BEING WRITTEN              M1564
         BE    WRITER1E                YES,BRANCH              @Z40RPKQ
         CLI   MSGCODE,MSG21           IS AN INVALID NEW PASSWORD
*                                      MESSAGE BEING WRITTEN   @Z40RPKQ
         BE    WRITER1E                YES,BRANCH                 M1564
*/*WRITER1F: P GET MESSAGE TO WRITE */
WRITER1F DS    0H
         NI    PFLAGS5,HFF-BYPASFLG    TURN OFF BYPASS MODE FLAG Y01156
         ST    R15,SEGLIST+FOUR        STORE SEGMENT NUMBER IN LIST
         IC    R15,MSGCODE             GET MESSAGE CODE
         L     R1,ADRMSGC              LOAD ADDRESS OF MESSAGE CSECT
         L     R15,ZERO(R15,R1)        POINT TO MESSAGE SEGMENT
         ST    R15,SEGLIST+EIGHT       STORE PROTOTYPE MESSAGE PTR IN
*                                         MESSAGE SEGMENT LIST
         MVC   PRIMSGID+FOUR(EIGHT),FOUR(R15) SAVE PRIMARY MESSAGE ID
*                                         FOR HELP MESSAGES
         SPACE
*/* P ISSUE PUTLINE TO WRITE MESSAGE */
         PUTLINE PARM=PUTLINE,OUTPUT=(SEGLIST,MULTLVL),                *
               MF=(E,SRPARAMS)         WRITE MESSAGE             Y02225
         SPACE
*/* D (,PLRCACT) TAKE ACTION ON PUTLINE RETURN CODE */
         B     PLRCACT                 TAKE APPROPRIATE ACTION FOR
*                                         PUTLINE RETURN CODE
         SPACE
*
* FREE SPACE OBTAINED FOR MESSAGE SEGMENT. THE EXECUTION OF THE
* FREEMAIN IS DEPENDENT ON THE RETURN CODE RETURNED FROM PUTLINE.
*
*/*WRITER1D: P LOAD ADDRESS OF MESSAGE SEGMENT */
WRITER1D DS    0H                      RETURN FROM RETURN CODE CHECKER
         TM    PFLAGS5,PSWDFLG         PASSWORD IN PROCESS?      Y02666
         BZ    WRITER1P                NO, CONTUNUE              Y02666
         BR    LINK1                   ELSE BYPASS FREEING MSG   Y02666
WRITER1P DS    0H                                                Y02666
         L     R1,SEGLIST+TWELVE       LOAD ADDRESS OF MESSAGE SEGMENT
*/* D (YES,WRITER1G,NO,) INVALID IDENT MSG WRITTEN */
         CLI   MSGCODE,MSG6            WAS AN INVALID IDENT MSG WRITTEN
         BE    WRITER1G                IF YES,BRANCH              M1564
*/* D (YES,,NO,WRITER1B) INVALID IDENT MSG IN BYPASS MODE */
         CLI   MSGCODE,MSG18           WAS INVALID IDENT MSG IN BYPASS
*                                      MODE WRITTEN               M1564
         BNE   WRITER1B                IF NO BRANCH               M1564
         SPACE
*/*WRITER1G: P LOAD ADDR OF CORE TO FREE */
WRITER1G L     R1,SEGLIST+SIXTEEN      IF YES LOAD ADR. OF CORE TO FREE
         SPACE
*/*WRITER1B: P LOAD LENGTH OF MSG SEGMENT */
WRITER1B DS    0H                      * * * *
         LH    R0,ZERO(R1)             LOAD LENGTH OF MESSAGE SEGMENT
         SPACE
*/* P FREE THE STORAGE */
         FREEMAIN R,LV=(0),A=(1)       FREE THE STORAGE
         SPACE
*/* R RETURN TO CALLER */
         BR    LINK1                   RETURN TO CALLING ROUTINE
*/*WRITER1E: P INDICATE ONE SEGMENT MSG */
WRITER1E LA    R15,ONE                 INDICATE ONE SEGMENT MSG   M1564
*/* D (,WRITER1F) CONTINUE */
         B     WRITER1F                                           M1564
         EJECT
***********************************************************************
*                                                                     *
*                       PROMPT MESSAGE SUBROUTINE                     *
*                                                                     *
*   THIS SUBROUTINE USES THE PUTGET I/O SERVICE ROUTINE TO PROMPT     *
* FOR ANY MISSING OR INVALID PARAMETERS. A MAJOR PORTION OF THIS      *
* SUBROUTINE IS DEVOTED TO THE HANDLING OF HELP MESSAGES. PARSE WILL  *
* PASS THE HELP MESSAGES SUPPLIED BY THE CP ON EITHER THE IKJIDENT    *
* OR IKJPOSIT MACROS ALONG WITH THE PRIMARY MESSAGE TO THE PUTGET     *
* I/O SERVICE ROUTINE. EXTENSIVE USE IS MADE OF THE TEXT INSERTION    *
* FEATURE OF THE I/O ROUTINES.                                        *
*   IF THE TERMINAL USER RESPONDED WITH A NULL LINE AND IF THE        *
* PARAMETER IS REQUIRED, PROMPTING CONTINUES UNTIL A PARAMETER IS     *
* ENTERED. IF NOT REQUIRED, AND A DEFAULT WAS SPECIFIED A EXIT TO     *
* THE PROMPTQ ROUTINE IS TAKEN AND THE DEFAULT IS RETURNED AS NEW     *
* DATA TO BE PARSED. IF NEITHER OF THE ABOVE, THE INPUT PUSHDOWN STACK*
* IS POPPED.                                                          *
*                                                                     *
***********************************************************************
         SPACE
*/*WRITER2: E PROMPT ROUTINE */
WRITER2  DS    0H                      PROMPT ROUTINE
*/* P INDICATE ONE WEGMENT MESSAGE */
         LA    R0,ONE                  INDICATE A ONE SEGMENT MESSAGE
         SPACE
*/*WRITER2G: P STORE SEGMENT NUMBER FOR PRIMARY MSG */
WRITER2G DS    0H                      ENTERED HERE WHEN OUTPUTING A
*                                         TWO SEGMENT MESSAGE - R0
*                                         CONTAINS SEGMENT NUMBER
         ST    R0,SEGLIST+FOUR         STORE SEGMENT NUMBER FOR PRIMARY
*                                         MESSAGE
         ST    LINK1,PLINKSV1          SAVE RETURN ADDRESS
*/* S PUSHI: PUSH INPUT STACK */
         BAL   LINK1,PUSHI             ADD TO INPUT STACK
         SPACE
*/*WRITER2A: P GET MESSAGE CODE */
WRITER2A DS    0H                      BRANCHED TO WHEN PROMPTING
*                                         WITH ENTER MESSAGE - SEGMENT
*                                         NUMBER STORED INTO SEGLIST +
*                                         FOUR BY CALLER
         XR    R15,R15                 CLEAR WORK REGISTER
         STH   R15,SAVLSLEN            CLEAR SAVE AREA FOR CORE SIZE
*                                         OBTAINED FOR HELP MESSAGES
         IC    R15,MSGCODE             GET MESSAGE CODE
         L     R1,ADRMSGC              LOAD ADDRESS OF MESSAGE CSECT
         L     R15,ZERO(R15,R1)        POINT TO MESSAGE SEGMENT
         ST    R15,SEGLIST+EIGHT       STORE PTR TO MESSAGE SEGMENT
         MVC   SEGLIST(L'ENDCHAIN),ENDCHAIN INDICATE NO HELP MESSAGES
         SPACE
*
* PASS ALONG SECOND LEVEL HELP MESSAGES IF USER HAD ANY.
*
*/* D (YES,,NO,WRITER2R) 2ND LEVEL MSG SUPPLIED BY VALIDITY CK */
         TM    PFLAGS4,PFVCMSG          HAS A SECOND LEVEL MESSAGE BEEN
*                                         SUPPLIED BY A VALIDITY CHECK
         BZ    WRITER2R                NO, CONTINUE PROCESSING
         SPACE
         LA    R1,ONE                  LOAD THE NUMBER OF SECOND LEVEL
*                                         MESSAGES AVAILABLE FROM A
*                                         VALIDITY CHECK ROUTINE
         L     R2,VALMSG               PICK UP ADDRESS OF MESSAGE SEG-
*                                         MENT FOR PUTGET
*/* D (,VCHELP) PROCESS MESSAGE */
         B     VCHELP                  PROCESS MESSAGE
         SPACE
*/*WRITER2R: D (YES,,NO,WRITER2B) USER SPECIFIED HELP MSGS */
WRITER2R DS    0H                      * * *
         TM    PCEFLGB1(XPCE),PCEFHELP DID THE USER SPECIFY HELP MSGS.
         BZ    WRITER2B                BIT ZERO IF NO --- BRANCH
*/* D (NO,WRITR2R1,YES,) PROCESSING COBOL PCE'S? */
         TM    CBFLAGS1,COBOLMOD       PROCESSING COBOL PCE'S?   F41448
         BZ    WRITR2R1                NO-CONTINUE NORMAL PARSE  F41448
*/* D (YES,TERMPCE,NO,) IS THIS A TERM PCE? */
*/* P OPER OR RESERVED WORD - PARM TYPE AT OFFSET 6 */
*/* P BUMP PASSED PARM TYPE FIELD */
         TM    PCEFLGB1(XPCE),HA0      IF MISED-KNOW IS A TERM   F41448
*                                      PCE. GO TO ROUTINE TO     F41448
*                                      POSITION TO TERM HELP     F41448
*                                      MESSAGES.                 F41448
         BM    TERMPCE                 GO TO ROUTINE TO POSIT-   F41448
*                                      ION TO TERM HELP MESSAGES F41448
         MVC   PDWORD(TWO),SIX(XPCE)   IF NOT A TERM, OPER AND   F41448
*                                      RESRVD WORD PARM TYPE AT  F41448
         LH    R15,PDWORD              LOAD FOR INCREMENTING     F41448
*/* D (YES,NOMAXL, NO,) IS THIS AN OPER - POSITIONED AT P/D DATA */
         LA    R15,SIX(R15)            BUMP PASSED THE PAREMETER F41448
*                                      TYPE FIELD IN THE PCE     F41448
         TM    PCEFLGB1(XPCE),HE0      IF ALL THESE BITS ON -    F41448
*                                      KNOW THIS IS AN OPER PCE  F41448
         BM    NOMAXL                  IF NOT, KNOW IS A RSVRD   F41448
*                                      WORD AND WE ARE POSIT-    F41448
*                                      IONED AT THE PROMPT/      F41448
*                                      DEFAULT DATA              F41448
*/* P (,NOMAXL) IF OPER - BUMP PASSED 8 BYTES OF OFFSET FIELDS */
         LA    R15,EIGHT(R15)          IF AN OPER, MUST BUMP     F41448
*                                      PASSED 8 BYTES OF OFFSETS F41448
         B     NOMAXL                  BRANCH TO PROMPT/DEFAULT  F41448
*                                      PROCESSING                F41448
*/*TERMPCE: P (,NOMAXL) IF TERM - BUMP PASSED PARM TYPE FIELD */
TERMPCE  MVC   PDWORD(TWO),SEVEN(XPCE) IF IS A TERM PCE, THE     F41448
*                                      PARM TYPE FIELD IS AT     F41448
*                                      OFFSET SEVEN              F41448
         LH    R15,PDWORD              ALLIGN FOR INCREMENTING   F41448
         LA    R15,SEVEN(R15)          INCREMENT PASSED THE PARM F41448
*                                      TYPE FIELDS - NOW POINT-  F41448
*                                      ING AT LENGTH OF PROMPT/  F41448
*                                      DEFAULT DATA              F41448
         B     NOMAXL                  GOTO ROUTINE TO BYPASS    F41448
*                                      THE PRMPT/DEFLT DATA      F41448
         SPACE
*/*WRITR2R1: D (YES,,NO,NOTREQ) IDENT PCE WITH PROMPT SPECIFIED */
WRITR2R1 TM    PCEFLGB1(XPCE),PCEFIDNT+PCEFPRPT IS THIS AN IKJIDENT PCE
*                                         WITH PROMPT SPECIFIED
         BZ    NOTREQ                  IF NO FORGET TESTS FOR PRINT
*                                         INHIBIT MODE
         SPACE
*/* D (YES,ALLOWHLP,NO,) PRINT INHIBIT MODE DESIRED */
         TM    PCEOPT(XPCE),PCEFPTBY   YES - ITS A REQUIRED PARAMETER
*                                         BEING PROMPTED FOR. IS PRINT
*                                         INHIBIT MODE DESIRED
         BO    ALLOWHLP                IF YES BRANCH - ALLOW HELP
*                                         MESSAGES
         SPACE
*/*NOTREQ: D (YES,WRITER2B,NO,) BYPASS MODE TO BE USED */
NOTREQ   DS    0H                      * * * *
         TM    PFLAGS,PFBYPAS          IS BYPASS MODE TO BE USED
         BO    WRITER2B                IF YES SKIP HELP MESSAGE SUPPORT
         SPACE
*/*ALLOWHLP: D (YES,POSITHLP,NO,) IKJPOSIT PCE */
ALLOWHLP DS    0H                      * * * *
         MVC   PDWORD(ONE),PCEFLGB1(XPCE) ISOLATE PCE TYPE INDICATORS
         NI    PDWORD,HE0              CLEAR OTHER BITS IN BYTE
         CLI   PDWORD,EIGHT*(POSITBB-MAINB) IS IT AN IKJPOSIT PCE
         BE    POSITHLP                IF YES BRANCH
         SPACE
*                                      IT MUST BE AN IKJIDENT PCE
*/* P MUST BE IKJIDENT - LOAD TYPE LENGTH */
         MVC   PDWORD(TWO),PCEPARMT(XPCE) ALIGN PARAMETER TYPE LENGTH
*                                         ON PROPER BOUNDARY
         LH    R15,PDWORD                 LOAD THE LENGTH
         LA    R15,PCEPARMT(R15)       BUMP PTR BY BASIC IKJIDENT SIZE
*/* D (YES,,NO,NOMAXL) MAXLNTH WAS SPECIFIED */
         TM    PCEOPT(XPCE),PCEFMAXL   WAS MAXLNTH SPECIFIED
         BZ    NOMAXL                  IF NO SKIP ADDING ITS LENGTH
         SPACE
*/* P ADD LENGTH TO TOTAL */
         LA    R15,ONE(R15)            IF YES ADD LENGTH TO TOTAL
         SPACE
*/*NOMAXL: D (YES,,NO,HAVEHELP) PROMPT/DEFAULT DATA SPECIFIED */
NOMAXL   DS    0H                      * * * *
         TM    PCEFLGB1(XPCE),PCEFPRPT+PCEFDFLT WAS PROMPT/DEFAULT DATA
*                                         SPECIFIED
         BZ    HAVEHELP                IF ZERO NO --- BRANCH
         SPACE
         XR    R14,R14                 CLEAR WORK REGISTER
*/* P LOAD LENGTH OF DATA */
         IC    R14,ZERO(R15,XPCE)      LOAD LENGTH - 1 OF DATA
         LA    R15,TWO(R15,R14)        BUMP TOTAL BY LENGTH
*/* D (,HAVEHELP) POSITIONED TO HELP MSGS */
         B     HAVEHELP                SHOULD BE POSITIONED TO HELP
*                                         MESSAGES NOW
         SPACE
*/*POSITHLP: D (,NOMAXL) CHECK FOR PROMPT/DEFAULT DATA */
POSITHLP DS    0H                      * * * *
         LA    R15,PCEPOST+ONE         BUMP PTR BY BASIC IKJPOSIT
*                                         LENGTH
         B     NOMAXL                  CHECK FOR PROMPT/DEFAULT DATA
         SPACE
*/*HAVEHELP: P GET NUMBER OF HELP MSGS */
HAVEHELP DS    0H                      AT THIS POINT R15 SHOULD BE
*                                         POSITIONED TO HELP MESSAGES
*/* D (NO,HELPCONT,YES,) PROCESSING COBOL PCE'S */
         TM    CBFLAGS1,COBOLMOD       PROCESSING COBOL PCE'S    F41448
         BZ    HELPCONT                IF NOT CONTINUE           F41448
*/* D (NO,HELPCONT, YES,) IS IT A TERM PCE? */
         TM    PCEFLGB1(XPCE),HA0      IF COBOL, IS IT A TERM    F41448
         BC    CC9,HELPCONT            IF NOT, CONTINUE          F41448
*/* D (NO,HELPCONT,YES,) IS RESVD WORD OR SUBSCRIPT SPECIFIED? */
         TM    PCEFLGB2(XPCE),H18      IS RESVD WORD OR SUBS-    F41448
*                                      SCRIPT SPECIFIED?         F41448
         BC    CC8,HELPCONT            IF NOT, CONTINUE          F41448
*/* P INCREMENT PASSED THE OFFSET FIELDS FOR RSVWD WRD OR SUBSCRPT */
         BC    CC4,UP2                 IF ONLY ONE SPCEDIFIED,   F41448
*                                      INCREMENT R15 BY TWO      F41448
         LA    R15,TWO(R15)            IF BOTH SPECIFIED, INC-   F41448
*                                      REMENT R15 BY FOUR        F41448
UP2      LA    R15,TWO(R15)            INCREMENT R15 BY TWO      F41448
HELPCONT XR    R1,R1                   CLEAR WORK REGISTER
         IC    R1,TWO(R15,XPCE)        LOAD NUMBER OF HELP MESSAGES
*/*HELPCONT: P GET TRUE ADDR OF PCE HELP DATA */
         LA    R2,THREE(R15,XPCE)      SAVE TRUE ADDRESS OF PCE
*                                         HELP DATA
         SPACE
*/*VCHELP: P VALID CHK SPCEIFIED 2ND LEVEL MSG */
VCHELP   DS    0H                      BRANCHED TO WHEN A VALIDITY
*                                         CHECK ROUTINE SPECIFIED A
*                                         SECOND LEVEL MESSAGE
         LR    R3,R1                   SAVE NUMBER OF HELP MESSAGES FOR
*                                         LOOP CONTROL
         MH    R1,LISTLEN              MULTIPLY NUMBER OF MESSAGES BY
*                                         AMOUNT OF STORAGE EACH MSG
*                                         WILL TAKE
         STH   R1,SAVLSLEN             SAVE CORE SIZE FOR FREEMAIN
*/* S GETCORE: GET STORAGE FOR MSGS */
         BAL   LINK1,GETCORE           BRANCH TO GET STORAGE ROUTINE
         SPACE
         ST    R1,SEGLIST              SAVE PTR TO OBTAINED CORE
         SPACE
*
* BUILD MULTI-LEVEL MESSAGE CHAIN IN THE OBTAINED CORE. THE FIRST WORD
* OF EACH ELEMENT POINTS TO THE NEXT ELEMENT, THE LAST ELEMENT POINTER
* CONTAINS X'FF000000'. THE SECOND WORD CONTAINS THE NUMBER OF SEGMENTS
* IN THE ELEMENT. THE THIRD WORD POINTS TO THE FIRST MESSAGE SEGMENT
* WHICH IS THE HELP MESSAGE ITSELF LOCATED IN THE PCE. THE LAST
* WORD POINTS TO THE SECOND MESSAGE SEGMENT WHICH IS THE WORD 'ENTER'
* WITH THE LAST PRIMARY MESSAGE ID AS A PREFIX.
* HELP MESSAGES ARE GENERATED BY THE IKJPOSIT AND IKJIDENT MACROS IN
* THE FOLLOWING FORM -
*
*              ********************************************
*              /  LENGTH     /  X'0000'    /   TEXT       /
*              ********************************************
*               0             2             4
*
* SINCE THE MESSAGE ID/MESSAGE SEGMENT SEGMENT CONTAIN AN OFFSET OF
* ZERO INSERTED BEFORE THE HELP MESSAGE SEGMENT. IF IT WERE NOT DONE
* IN THIS MANNER THE WORD 'ENTER' COULD NOT BE REPLACED WITH 'MISSING'
* IF THE USER WAS IN NO-PROMPT MODE.
*
*/*NEXTLIST: P STORE HELP MSG SEGMENT ADDR */
NEXTLIST DS    0H                      * * * *
         ST    R2,SIXTEEN(R1)            STORE THE HELP MESSAGE SEGMENT
*                                         ADDRESS - HELP MESSAGE
*                                         SEGMENTS ARE CONSTRUCTED BY
*                                         THE PARSE MACROS
         LA    R0,CRMESS               GET NLCHAR PTR            Y05020
         ST    R0,EIGHT(R1)            PLACE IN SEGMENT LIST     Y05020
*/* D (YES,,NO,WRITER2S) 2ND LEVEL MSG SUPPLIED BY VALID CHK */
         TM    PFLAGS4,PFVCMSG         HAS SECOND LEVEL MESSAGE BEEN
*                                         SUPPLIED BY VALIDITY EXIT
         BZ    WRITER2S                NO, CONTINUE
*/* P TURN OFF INDICATOR */
         LA    R0,TWO                  LOAD THE NUMBER OF SEGMENTS
         ST    R0,FOUR(R1)             STORE NUMBER IN ELEMENT
         ST    R2,TWELVE(R1)           PLACE VCE MSG IN LIST   Y05020
*/* D (,WRITER2T) CONTINUE */
         B     WRITER2T                CONTINUE
         SPACE
*/*WRITER2S: P LOAD FIRST SEGMENT ADDR */
WRITER2S DS    0H                      * * * *
         LA    R0,THREE                LOAD THE NUMBER OF SEGMENTS
         ST    R0,FOUR(R1)             STORE SEGMENT NUMBER IN ELEMENT
         LA    R0,PRIMSGID             LOAD FIRST SEGMENT ADDRESS
*/* P STORE IT IN ELEMENT */
         ST    R0,TWELVE(R1)           STORE IT IN ELEMENT
         LA    R0,LENMLLST(R1)         GET PTR TO NEXT ELEMENT
         ST    R0,ZERO(R1)             STORE PTR TO NEXT ELEMENT
         LR    R1,R0                   BUMP INDEX REGISTER TO NEXT
*                                         ELEMENT
         MVC   PDWORD(TWO),ZERO(R2)    ALIGN LENGTH OF CURRENT HELP
*                                         MESSAGE ON PROPER BOUNDARY
*/* P POINT TO NEXT HELP MSG IF ANY */
         AH    R2,PDWORD               BUMP PCE PTR TO NEXT HELP
*                                         MESSAGE IF ANY
*/* P REDUCE HELP MSG COUNT */
         BCT   R3,NEXTLIST             REDUCE HELP MESSAGE COUNT AND
*/* D (YES,,NO,NEXTLIST) LAST ONE */
*                                         BRANCH IF NOT LAST ONE --- IF
*                                         LAST ONE WAS PROCESSED FALL
*                                         THROUGH
         SPACE
         SH    R1,LISTLEN              REDUCE ELEMENT PTR TO POINT TO
*                                         LAST ELEMENT
         SPACE
*/*WRITER2T: P INDICATE END OF CHAIN */
WRITER2T DS    0H                      * * * *
         MVC   ZERO(L'ENDCHAIN,R1),ENDCHAIN INDICATE END OF CHAIN
         SPACE
*/*WRITER2B: D (YES,,NO,NOTIDPR) IKJIDENT PCE WITH PROMPT SPECIFIED */
WRITER2B DS    0H                      BRANCHED TO TO REISSUE PROMPT
*                                         MESSAGE OR BYPASS HELP MSGS.
*/* D (YES,NOTIDPR,NO,) IF COBOL MODE - NO TESTS FOR PRINT INHIBIT MODE
*/* */
         TM    CBFLAGS1,COBOLMOD       ARE WE PROCESSING COBOL   F41448
*                                      PCE'S?                    F41448
         BO    NOTIDPR                 IF YES, FORGET TESTS FOR  F41448
*                                      PRINT INHIBIT MODE - GO   F41448
*                                      DIRECTLY TO WRITE OUT     F41448
*                                      MESSAGE                   F41448
         TM    PCEFLGB1(XPCE),PCEFIDNT+PCEFPRPT IS THIS AN IKJIDENT PCE
*                                         WITH PROMPT SPECIFIED
         BZ    NOTIDPR                 IF NO FORGET TESTS FOR PRINT
*                                         INHIBIT MODE
         SPACE
*/* D (YES,BYPASS,NO,) PRINT INHIBIT MODE DESIRED */
         TM    PCEOPT(XPCE),PCEFPTBY   YES - ITS A REQUIRED PARAMETER
*                                         BEING PROMPTED FOR. IS PRINT
*                                         INHIBIT MODE DESIRED
         BO    BYPASS                  IF YES BRANCH - ALLOW HELP
         SPACE
*/* D (YES,BYPASS,NO,) BYPASS MODE TO BE USED */
         TM    PFLAGS,PFBYPAS          IS BYPASS MODE TO BE USED
         BO    BYPASS                  IF YES BRANCH
         SPACE
*/*NOTIDPR: P ISSUE PUTGET */
NOTIDPR  DS    0H                      * * * *
         TM    PFLAGS5,SUBFLG          SUBFIELD BEING PROCESSED? Y01156
         BZ    PUTGT                NO, PROMPT WITH TERMPUT=EDIT
*                                      OPTION                    Y01156
         CLI   MSGCODE,MSG3            IS REENTER MSG TO BE WRITTEN?
*                                                                Y01156
         BE    WRITEKEY                YES, PROMPT WITH ASIS OPTION
*                                                                Y01156
         CLI   MSGCODE,MSG3A           IS REENTER+ MSG TO BE WRITTEN?
*                                                                Y01156
         BE    WRITEKEY                YES, PROMPT WITH ASIS OPTION
*                                                                Y01156
PUTGT    DS    0H                                                Y01156
         NI    PFLAGS4,HFF-PFVCMSG     TURN OFF VCE MSG FLAG     Y05020
         PUTGET PARM=PUTGET,OUTPUT=(SEGLIST,MULTLVL),                  *
               TERMPUT=(EDIT),MF=(E,SRPARAMS) WRITE/READ FUNCTIONY02666
         SPACE
*/*WRITER2C: D (,PGRCACT) TAKE ACTION FOR PUTGET RETURN CODE */
WRITER2C DS    0H                      BRANCHED TO BY BYPASS ROUTINE
         B     PGRCACT                 TAKE APPROPRIATE ACTION FOR
*                                         PUTGET RETURN CODE
WRITEKEY DS    0H
         LA    R0,ONE                  GET NUMBER OF SEGMENTS    Y01156
         ST    R0,SEGLIST+FOUR         AND STORE                 Y01156
         TM    PFLAGS4,PFVCMSG         IS VCE MSG ENTERED?       Y05020
         BO    WRITEON                 YES, PROCESS              Y05020
         SR    R15,R15                 CLEAR                     Y05020
         IC    R15,MSGCODE             GET MSG INDEX             Y05020
         L     R2,ADRMSGC              GET MSG CSECT PTR         Y05020
         L     R15,ZERO(R15,R2)        GET MSG PTR               Y05020
         ST    R15,SEGLIST+EIGHT       STORE                     Y05020
WRITEON  DS    0H                                                Y05020
         NI    PFLAGS4,HFF-PFVCMSG     TURN OFF VCE MSG FLAG     Y05020
         L     R15,UPTADDR             GET UPT PTR               Y05020
         TM    TWELVE(R15),INVPRMPT    IS NO PROMPT SPECIFIED?   Y05020
         BO    MSNGMSG                 GO TO MISSING MSG RTN.    Y05020
         L     R15,ECTADDR             GET ECT PTR               Y02666
         USING ECT,R15                 ESTABLISH ADDRESSABILITY  Y02666
         TM    ECTSWS,ECTBKGRD         RUNNING IN BACKGROUND    Z40PQRD
         BZ    FOREGRND                NO, TEST FOR PROMPT      Z40PQRD
         L     R15,ECTIOWA             GET OUTPUT AREA PTR      Z40PQRD
         DROP  R15                     DROP ECT ADDRESSABILITY  Z40PQRD
         USING IOSRL,R15                                        Z40PQRD
         USING INSTACK,R14                                      Z40PQRD
         L     R14,IOSTELM             GET TOP ELEMENT OF STACK Z40PQRD
         DROP  R15                                              Z40PQRD
         TM    INSCODE,INSEXEC         PROCESSING CLIST         Z40PQRD
         BZ    MSNGMSG                 NO,THEN CANNOT PROMPT    Z40PQRD
         TM    INSCODE,INSPROM         IS PROMPT ALLOWED        Z40PQRD
         BO    WRITIT                  IF SO,PROMPT             Z40PQRD
         DROP  R14                                              Z40PQRD
FOREGRND DS    0H                      FOREGROUND PROCESSING    Z40PQRD
         USING ECT,R15                                          Z40PQRD
         L     R15,ECTIOWA             GET OUTPUT AREA PTR       Y02666
         DROP  R15
         USING IOSRL,R15
         USING INSTACK,R14
         L     R14,IOSTELM             GET TOP ELEMENT PTR       Y02666
         DROP  R15
         TM    INSCODE,INSPROC         INSTORAGE PROC?           Y02666
         BZ    WRITIT                  NO,PROMPT THE USER        Y02666
         TM    INSCODE,INSPROM         PROMPT IN CLIST?          Y02666
         BZ    MSNGMSG                 NO, BYPASS PROMPTING      Y02666
         DROP  R14
WRITIT   DS    0H                      CONTINUE MSG SETTUP       YM3610
         L     R2,SEGLIST              SAVE FIRST WORD OF SEGLISTY05020
         MVC   SEGLIST(L'ENDCHAIN),ENDCHAIN INDICATE NO HELP MSGSY05020
*
         PUTLINE PARM=PUTLINE,OUTPUT=(SEGLIST,MULTLVL),                *
               MF=(E,SRPARAMS)                                   Y02225
         ST    R2,SEGLIST              RESTORE SEGLIST           Y05020
         LTR   R15,R15                 IS RETURN CODE ZERO?      Y05020
         BNZ   PLRCACT                 NO, GO TEST RETURN CODE   Y05020
         LH    R14,KEYLEN              GET LENGTH OF USER KEYWD  Y01156
         LA    R14,SEVEN(R14)          ADD HEADER AND THREE BYTES FOR
*                                      NLCHAR AND COLON          Y01156
         STH   R14,KEYBUFLN            STORE BUFFER LENGTH       Y01156
         LA    R14,ZERO                GET KEYWORD OFFSET        Y05020
         STH   R14,KEYBUFOF            STORE OFFSET              Y01156
         L     R14,KEYPTR              GET PTR TO KEYWORD        Y01156
         LH    R1,KEYLEN               GET LENGTH                Y01156
         BCTR  R1,ZERO                 DECREMENT FOR EXECUTE IN. Y01156
         EX    R1,KEYWDMVC             MOVE DATA TO BUFFER       Y01156
         LA    R14,KEYDATA             GET PTR TO KEYDATA        Y01156
         MVI   ZERO(R14),BLNK          PLACE BLANK  IN BUFFER    Y05020
         AH    R14,KEYLEN              GET PTR TO BYTE BEYOND    Y01156
         MVI   ONE(R14),COLON          PUT COLON IN BUFFER       Y02666
         MVI   TWO(R14),BLNK           PLACE BLANK  IN BUFFER    Y05020
         LA    R0,KEYBUF               GET PTR TO KEYWORD BUFFER Y01156
         ST    R0,SEGLIST+EIGHT        AND STORE IN MESSAGE LIST Y01156
         PUTGET     PARM=PUTGET,OUTPUT=(SEGLIST,MULTLVL),              *
               TERMPUT=(ASIS),MF=(E,SRPARAMS)                    Y02225
         B     PGRCACT                  PROCESS THE RETURN CODE
*                                      FROM PUTGET               Y01156
         SPACE
*/*WRITER2J: D (YES,,NO,WRITER2K) 2ND VALUE OF RANGE BEING PROCESSED */
WRITER2J DS    0H                      * * * *
         SPACE
         TM    PFLAGS2,RNGEVAL2+RNGEVAL1 IS THE 2ND VALUE OF A RANGE
*                                         BEING PROCESSED
         BZ    WRITER2K                NO, CONTINUE
         SPACE
*
* ERASE POSSIBLE 1ST HALF OF RANGE ALREADY IN THE PDE.  RANGE IS
* ALLOWED ONLY FOR AN IDENT, ADDRESS, OR VALUE PCE.
*
         XR    R2,R2                   CLEAR WORK REGISTER
*/* P GET PDE SIZE FOR RANGE */
         IC    R2,PPCOUNT              GET PDE SIZE STORED BY
*                                         ROUTINES WHICH PROCESS
*                                         RANGES
         MVC   PDWORD(TWO),PCEPDEO(XPCE)  ALIGN PDE OFFSET ON PROPER
*                                         BOUNDARY
         LH    R3,PDWORD               LOAD THE PDE OFFSET
         A     R3,XPDL                 GET TRUE ADDRESS OF PDE
*/* P ERASE PDE */
         EX    R2,ERASEXC              ERASE THE PDE
         SPACE
*/*WRITER2K: P LOAD INPUT BUFFER RETURN ADDRESS */
WRITER2K DS    0H                      * * * *
         L     R3,PUTGET+TWELVE        LOAD INPUT BUFFER RETURN ADDRESS
         MVC   PDWORD(TWO),ZERO(R3)    ALIGN LENGTH OF DATA ON PROPER
*                                         BOUNDARY
*/* D (YES,,NO,PROMPGO) RESPONSE IS NULL */
         CLC   PDWORD(TWO),H4          IS THE RESPONSE NULL
         BH    PROMPGO                 IF NOT CONTINUE PROCESSING
         SPACE
*
* NULL RESPONSE --- FREE PUTGETS BUFFER AND DETERMINE WHAT TO
* RETURN TO CALLER.
*
         LR    R1,R3                   MOVE BUFFER ADDRESS
         LH    R0,PDWORD               LOAD BUFFER SIZE
         AL    R0,SUBPOOLN             ADD SUBPOOL NUMBER TO SIZE
         SPACE
*/* P ISSUE FREEMAIN TO FREE PUTGETS BUFFER */
         FREEMAIN R,LV=(0),A=(1)       FREE BUFFER
         SPACE
*/*WRITER2D: D (YES,WRITER2F,NO,) PROMPTING FOR PASSWORD */
WRITER2D DS    0H                      * * * *
*                                                                 M0911
         NI    PFLAGS4,HFF-PFNOPOP     TURN OFF POSSIBLE NOPOP FLAG
         TM    PFLAGS,PFBYPAS          PROMPTING FOR A PASSWORD
         BO    WRITER2F                IF YES BRANCH
         SPACE
*/* D (YES,YESLIST,NO,) PROCESSING LIST */
         TM    PFLAGS,PFLIST           IS A LIST BEING PROCESSED
         BO    YESLIST                 YES, CHECK FOR PROMPT/DEFAULT
*/* D (YES,YESLIST,NO,) COBOL PCE'S - GOTO TEST FOR PROMPT/DEFAULT */
         TM    CBFLAGS1,COBOLMOD       PROCESSING COBOL PCE'S    F41448
         BO    YESLIST                 IF YES, TEST FOR          F41448
*                                      PROMPT/DEFAULT            F41448
         SPACE
         MVC   PDWORD(ONE),PCEFLGB1(XPCE) MOVE TYPE INDICATORS
         NI    PDWORD,HE0              ISOLATE PCE TYPE INDICATORS
*/* D (YES,WRITER2E,NO,) IKJKEYWD PCE */
         CLI   PDWORD,EIGHT*(KEYWDB-MAINB) IS IT AN IKJKEYWD PCE
         BE    WRITER2E                YES, DO NOT TEST FOR DEFAULT
         SPACE
*/*YESLIST: D (YES,WRITER2B,NO,) PARAMETER IS REQUIRED */
YESLIST  DS    0H                      * * * *
         TM    PCEFLGB1(XPCE),PCEFPRPT IS THE PARAMETER REQUIRED
         BO    WRITER2B                IF YES BRANCH - REPEAT PROMPT
         SPACE
*/* D (YES,PROMPTQ1,NO,) IS THERE A DEFAULT */
         TM    PCEFLGB1(XPCE),PCEFDFLT DOES PARAMETER HAVE A DEFAULT
         BO    PROMPTQ1                IF YES PASS BACK DEFAULT
*/* D (YES,WRITER2F,NO,WRITER2E) PROCESSING COBOL PCE'S? */
*/* COMMENT (1,15) IF COBOL - GET */
*/* COMMENT (2,15) PFNULL ON */
         TM    CBFLAGS1,COBOLMOD       PROCESSING COBOL PCE'S?   F41448
         BO    WRITER2F                IF YES, SET PFNULL ON SO  F41448
*                                      WILL KNOW RECEIVED NULL   F41448
*                                      LINE FROM PROMPT          F41448
         SPACE
         B     WRITER2E                NO --- POP STACK
         SPACE
*/*WRITER2F: P INDICATE NULL LINE ENTERED */
WRITER2F DS    0H                      * * * *
         OI    PFLAGS3,PFNULL          INDICATE A NULL LINE WAS ENTERED
         SPACE
*/*WRITER2E: S SCANF: RE-POP THE STACK */
WRITER2E DS    0H                      * * * *
         BAL   LINK1,SCANDLSN          RE-POP STACK               M3337
*
         NOP   ZERO                    +0 RETURN
*
*                                      +4 RETURN
*/* D (YES,PROMPXIT,NO,) PROMPTING FOR  PASSWORD */
         TM    PFLAGS,PFBYPAS          PROMPTING FOR A PASSWORD
         BO    PROMPXIT                IF YES BRANCH --- EXIT
         SPACE
*/* D (YES,WRITER2H,NO,) PROCESSING LIST */
         TM    PFLAGS,PFLIST           IS A LIST BEING PROCESSED
         BO    WRITER2H                IF YES CHECK FOR MORE LIST DATA
*/* D (YES,WRITR2E1,NO,) PROCESSING COBOL PCE'S? */
*/* COMMENT (1,15) SKIP KEYWD */
*/* COMMENT (2,15) + ENDP TESTS */
         TM    CBFLAGS1,COBOLMOD       PROCESSING COBOL PCE'S?   F41448
         BO    WRITR2E1                IF YES, SKIP OVER TEST    F41448
*                                      FOR KEYWRD AND ENDP PCE'S F41448
         SPACE
         MVC   PDWORD(ONE),PCEFLGB1(XPCE) MOVE TYPE INDICATORS
         NI    PDWORD,HE0              ISOLATE PCE TYPE INDICATORS
*/* D (YES,PROMPXIT,NO,) IKJKEYWD PCE */
         CLI   PDWORD,EIGHT*(KEYWDB-MAINB) IS IT AN IKJKEYWD PCE
         BE    PROMPXIT                YES - EXIT
         SPACE
*/* D (YES,PROMPXIT,NO,) IKJENDP PCE */
         CLI   PDWORD,EIGHT*(ENDB-MAINB) IS IT AN IKJENDP PCE
         BE    PROMPXIT                IF YES EXIT
         SPACE
*/*WRITR2E1: D (YES,,NO,WRITER2L) LIST SPECIFIED IN PCE */
WRITR2E1 TM    PCEFLGB2(XPCE),PCEFLIST IS LIST SPECIFIED IN PCE
         BZ    WRITER2L                NO, EXIT NORMALLY
         SPACE
*/*WRITER2M: P STORE RETURN ADDRESS */
WRITER2M DS    0H                      * * * *
         LA    R0,POSITX               STORE POSITX -
         ST    R0,PLINKSV1             AS RETURN ADDRESS
*/* D (,PROMPXIT) EXIT */
         B     PROMPXIT                EXIT WRITER2
         SPACE
*/*WRITER2L:  P STORE RETURN ADDRESS */
WRITER2L DS    0H                      * * * *
         LA    R0,POSITX3              STORE POSITX3 -
         ST    R0,PLINKSV1             AS RETURN ADDRESS -
*/* D (,PROMPXIT) EXIT */
         B     PROMPXIT                AND EXIT.
         SPACE
*/*WRITER2H: S SKIPB: SKIP SEPARATORS */
WRITER2H DS    0H                      * * * *
         SPACE
         BAL   LINK2,SKIPB             SKIP SEPARATORS
*
*/* D (YES,,NO,WRITER2P) DATA TO SCAN */
         B     WRITER2P                +0 RETURN --- NO MORE DATA ---
*                                         BRANCH TO POSITIONAL EXIT RTN
*
*                                      +4 RETURN --- DATA TO SCAN
         LA    XINPUT,ONE(XINPUT)      BUMP INPUT POINTER
*/* D (YES,WRITER2P,NO,PROMPXIT) REACHED END OF THE LIST */
         CLI   ZERO(XINPUT),RIGHTPRN   IS THIS THE END OF THE LIST
         BE    WRITER2P                IF YES TAKE POSITIONAL EXIT
         SPACE
         BCT   XINPUT,PROMPXIT         NO --- DECREMENT POINTER -- EXIT
         SPACE
*/*WRITER2P: D (YES,WRITER2N,NO,) AT LEAST ONE PDE WAS BUILT */
WRITER2P DS    0H                      * * * *
         TM    PFLAGS3,PFONE           WAS AT LEAST ONE PDE BUILT
*                                                                M0911
         BO    WRITER2N                YES, THEN LIST PTR IS ALREADY
*                                         SET - TAKE POSIT EXIT
         SPACE
*/* P TURN OFF LIST PTR */
         NI    PFLAGS,HFF-PFLIST       TURN OFF LIST PTR
*/* D (,WRITER2M) GO TO SET UP LIST PTR */
         B     WRITER2M                NO, GO SET UP TO SET LIST PTR
         SPACE
*/*WRITER2N: D (YES,POSITX4,NO,) PROCESSING COBOL PCE'S? */
*/* D (YES,POSITX4,NO,) REACHED END OF INPUT */
WRITER2N DS    0H                      * * * *
         TM    CBFLAGS1,COBOLMOD       PROCESSING COBOL PCE'S?   F41448
         BO    POSITX4                 IF YES, DON'T DECREMENT   F41448
*                                      THE INPUT POINTER         F41448
         TM    PFLAGS,PFENDF           IS THIS THE END OF INPUT   M3337
         BNZ   POSITX4                 YES, DON'T DECREMENT       M3337
*/* P DECREMENT SCAN POINTER */
*/* D (,POSITX4) EXIT */
         BCT   XINPUT,POSITX4          DECREMENT BEFORE EXIT      M0911
         SPACE
*
* DATA OBTAINED FROM THE PROMPT - MOVE IT TO PARSES CORE SO USER CAN
* USE IT.
*
*/*PROMPGO: S STALOC: ALLOCATE SPACE TO COPY NEW DATA */
PROMPGO  DS    0H                      * * * *
         LA    R2,FOUR(R3)             GET PROMPT DATA PTR.      Y02666
         LH    R1,PDWORD               LOAD LENGTH OF RETURNED DATA
         SH    R1,H4                   TO ACCOUNT FOR HEADER
         LR    R3,R1                   SAVE LENGTH OF PROMPT DATAY02666
         BAL   LINK2,STALOC            ALLOCATE SPACE TO COPY NEW DATA
         SPACE
         LR    XINPUT,R1               SAVE PTR TO NEW DATA AREA
         LR    R5,R3                   SET LENGTH OF DATA        Y02666
         STM   R2,R5,P20SAVE           SAVE AROUND MOVE LONG     Y02666
         MVCL  XINPUT,R2               MOVE DATA TO NEW BUFFER   Y02666
         LM    R2,R5,P20SAVE           RESTORE REGS.             Y02666
         LA    R3,ZERO(XINPUT,R3)      GET END PTR.              Y02666
         ST    R3,ENDINPUT             SET END OF DATA PTR       Y02666
         BCTR  XINPUT,ZERO             REDUCE ONE FOR FUTURE SCANX
*/* P COPY NEW DATA TO PARSE STORAGE */
         SPACE
*
* FREE PUTGETS BUFFER.
*
         L     R1,PUTGET+TWELVE        RESTORE PUTGET BUFFER PTR Y02666
         LH    R0,PDWORD               COMPUTE BUFFER SIZE       Y02666
         AL    R0,SUBPOOLN             ADD SUBPOOL NUMBER TO SIZE
         SPACE
*/* P ISSUE FREEMAIN TO FREE PUTGETS BUFFER */
         FREEMAIN R,LV=(0),A=(1)       FREE BUFFER
         SPACE
*/* D (YES,,NO,PROMPXIT) SHOULD BLANKS BE SKIPPED */
         TM    RFLAGS,RFNOSKIP         SEE IF BLANKS SHOULD BE
*                                         SKIPPED IN THE NEW BUFFER
         BO    PROMPXIT                NO, (FLAG ON) - EXIT
         SPACE
*/* P INDICATE NOT TO POP STACK IF ALL BLANKS IN BUFFER */
         OI    PFLAGS4,PFNOPOP         DON'T POP STACK IF ALL     M0911
*                                         SEPARATORS IN PROMPT BUFFER
*/* S SKIPB: SKIP SEPARATORS */
         BAL   LINK2,SKIPB             SKIP BLANKS IN NEW BUFFER
         SPACE
*/* D (YES,WRITER2D,NO,) ALL SEPARATORS IN BUFFER */
         B     WRITER2D                +0 RETURN - ALL SEPARATERS -
*                                         REPROMPT
*
*                                      +4 RETURN - EXIT
         SPACE
         NI    PFLAGS4,HFF-PFNOPOP     TURN OFF NOPOP FLAG        M0911
*/* P INDICATE PROMPT DATA PICKED UP */
         OI    PFLAGS4,PFPDDATA        INDICATE PROMPT DATA PICKED UP
*
* RETURN TO CALLER AFTER FREEING CORE OBTAINED FOR HELP MESSAGES
* AND 'ENTER' MESSAGE IF PREVIOUSLY OBTAINED.
*
*/*PROMPXIT: D (YES,,NO,NOHELP) ANY HELP MSG STORAGE TO FREE */
PROMPXIT DS    0H                      EXIT FROM PUTGET ROUTINE
         NC    SAVLSLEN,SAVLSLEN       ANY HELP MESSAGE STORAGE TO FREE
         BZ    NOHELP                  IF NO BRANCH
         SPACE
         L     R1,SEGLIST              LOAD ADDRESS OF STORAGE
         LH    R0,SAVLSLEN             LOAD SIZE OF STORAGE OBTAINED
         SPACE
*/* P ISSUE FREEMAIN TO FREE THE STORAGE */
         FREEMAIN R,LV=(0),A=(1)       FREE THE STORAGE
         SPACE
*/*NOHELP: D (YES,YESENTER,NO,) 'ENTER' MSG WAS WRITTEN */
NOHELP   DS    0H                      * * * *
         CLI   MSGCODE,MSG1            WAS AN 'ENTER' MESSAGE WRITTEN
         BE    YESENTER                IF YES BRANCH
         SPACE
*/* D (YES,,NO,NOTENTER) 'ENTER PASSWORD' MSG WAS WRITTEN */
        TM    DATAFLA2,PRESENT         TEST TO SEE IF CURRENT PASSWORD
*                                      HAS BEEN PROCESSED      @Z40RPKQ
        BO    NEWITTEN                 IF YES, BRANCH TO COMPARE FOR
*                                      NEW PASSWORD 'ENTER' MESSAGE
*                                                              @Z40RPKQ
         CLI   MSGCODE,MSG15           WAS AN 'ENTER CURRENT
*                                      PASSWORD MESSAGE WRITTEN
*                                                              @Z40RPKQ
         B     YESNOTST                BRANCH TO CHECK IF MESSAGE BEEN
*                                      WRITTEN                 @Z40RPKQ
NEWITTEN DS    0H                      * * * *                 @Z40RPKQ
         CLI   MSGCODE,MSG22           WAS AN 'ENTER' FOR NEW PASSWORD
*                                      MESSAGE WRITTEN         @Z40RPKQ
YESNOTST DS    0H                      * * * *                 @Z40RPKQ
         BNE   NOTENTER                IF NO BRANCH
         SPACE
*/*YESENTER: P ISSUE FREEMAIN TO FREE THE STORAGE */
YESENTER DS    0H                      * * * *
         L     R1,SEGLIST+TWELVE       LOAD ADDRESS OF STORAGE
         LH    R0,ZERO(R1)             LOAD SIZE OF STORAGE OBTAINED
         SPACE
         FREEMAIN R,LV=(0),A=(1)       FREE THE STORAGE
         SPACE
*/*NOTENTER: P TURN OFF POSSIBLE FLAGS FOR BYPASS AND RANGE */
NOTENTER DS    0H                      * * * *
         NI    PFLAGS,HFF-PFBYPAS      CLEAR POSSIBLE BYPASS FLAG
         NI    PFLAGS2,HFF-RNGEVAL1-RNGEVAL2  TURN OFF POSSIBLE RANGE
*                                         FLAGS TO REMOVE POSSIBLE
*                                         INVALID DATA IN PDE
         L     LINK1,PLINKSV1          LOAD RETURN ADDRESS
         XR    R1,R1                   SET R1 TO BASIC PCE SIZE
         IC    R1,PPCOUNT              FOR POSSIBLE USE BY POSITX
*/* R RETURN +0 */
         BR    LINK1                   RETURN +0
         SPACE
*/*BYPASS: P ISSUE PUTGET */
BYPASS   DS    0H                      * * * *
         NI    PFLAGS4,HFF-PFVCMSG     TURN OFF VCE MSG FLAG     Y05020
         PUTGET PARM=PUTGET,OUTPUT=(SEGLIST,MULTLVL,PTBYPS),           *
               TERMPUT=(EDIT),MF=(E,SRPARAMS) WRITE/READ IN
*                                      BYPASS MODE               Y02225
         SPACE
*/* D (,PGRCACT) RETURN TO MAINLINE CODE */
         B     PGRCACT                 CHECK RETURN CODE         Y02666
         EJECT
*/*VCERTN: D (YES,VCERA,NO,) VALIDCHK EXIT WANTED */
VCERTN   DS    0H                      VALIDITY CHECK EXIT ROUTINE
         TM    PCEFLGB1(XPCE),PCEFVCHK IS A VALIDITY CHECK EXIT WANTED
         BO    VCERTN2                 IF SO CONTINUE NORMAL     F41448
*                                      PARSE                     F41448
*/*COBRET1: D (NO,VCRTN,YES,) PROCESSING COBOL PCE'S? */
COBRET1  TM    CBFLAGS1,COBOLMOD       IF NO V.C. EXIT, CHECK TO F41448
*                                      SEE IF PROCESSING COBOL   F41448
*                                      PCE'S                     F41448
         BCR   CC8,LINK1               NO - BIT ZERO - RETURN    F41448
*/*COBRET2: P CLEAR THE COBOL TEMPORARY PDE */
*/*VCRTN: R () RETURN */
COBRET2  XC    TEMPPDE(CBLTPDE),TEMPPDE IF IN COBOL MODE, CLEAR  F41448
*                                      THE TEMPORARY PDE         F41448
         BR    LINK1                   RETURN ON LINK1           F41448
         SPACE
*                                                                M3318
*/*VCERA: D (YES,VCERB,NO,) PDE CONTAINS DATA */
VCERTN2  MVI   DATAEXP,H00             CLEAR EXPRESSION ADDRESS FLAG
*                                         IN TEMPPDE IN CASE NO DATA IS
*                                         IN ADDRESS PDE
         NI  DATAFLG,HFF-EMPTYFLG      TURN EMPTY FLAG BIT OFF   A45355
         NC  TEMPPDE(LTPDE),TEMPPDE    DOES THE PDE CONTAIN DATA?
*/* R RETURN */
         BCR   CC8,LINK1               IF NO BRANCH
         SPACE
         OI  DATAFLG,EMPTYFLG          TURN EMPTY FLAG BIT ON    A45355
*/*VCERB: P GET ADDR OF VALIDITY CHECK ROUTINE */
         MVC   PDWORD(TWO),PCELEN(XPCE) ALIGN PCE LENGTH FIELD ON
*                                         PROPER BOUNDARY
         LH    R15,PDWORD              LOAD PCE LENGTH
         SH    R15,H3                  GET ADDRESS OF VALIDITY CHECK
         AR    R15,XPCE                   ROUTINE ADDRESS
         MVC   PDWORD+ONE(THREE),ZERO(R15) ALIGN ADDRESS ON PROPER
*                                         BOUNDARY
*/* D (YES,,NO,INVPARMS) VALID ADDRESS - ON HALFWD BOUNDARY */
         TM    PDWORD+THREE,H01        IS IT VALID ADDRESS - ON
*                                         HALFWORD BOUNDARY
         BO    INVPARMS                NO - BRANCH
         SPACE
         L     R15,PDWORD              LOAD ROUTINE ADDRESS
         MVC   VALMSG(L'ENDCHAIN),ENDCHAIN   CLEAR VALIDITY CHECK MES-
*                                         SAGE FIELD
         LA    R1,VCEPARAM             LOAD PARAMETER LIST ADDRESS
*/* P GO TO VALIDITY CHECK ROUTINE */
         BALR  R14,R15                 BRANCH TO VALIDITY CHECK ROUTINE
         SPACE
*/* D (YES,,NO,COBRET1) PROMPT IS REQUIRED */
         LTR   R15,R15                 IS A PROMPT REQUIRED
         BZ    COBRET1                 IF ZERO RETURN , GO TO    F41448
*                                      NORMAL RETRUN ROUTINE     F41448
*/* D (NO,VCERC,YES,) IS IT THE SPECIAL COBOL RET - 16? */
         CH    R15,H16                 IF NOT ZERO RETURN, CHECK F41448
*                                      TO SEE IF IT IS THE       F41448
*                                      SPECIAL COBOL RETURN      F41448
*                                      CODE = 16                 F41448
         BNE   VCERTN3                 IF NOT, CONTINUE PARSE    F41448
*/* D (YES,INVPARMS,NO,) HAVE WE RECEIVED A 16 RET BEFORE ON THIS PCE?
*/**/
         TM    CBFLAGS1,RC16           IF IS, HAVE WE GOTTEN     F41448
*                                      THIS RETURN BEFORE FOR    F41448
*                                      THIS DATA NAME            F41448
         BO    INVPARMS                IF SO, ERROR              F41448
*/* P TURN ON RET CODE 16 INDICATOR = RC16 FLAG */
         OI    CBFLAGS1,RC16           IF NOT, TURN ON RET CODE  F41448
*                                      16 INDICATOR              F41448
*/* D (NO,INVPARMS,YES,) ARE WE PROCESSING A CHAINED TERM OFF AN OPER?
*/**/
         TM    CBFLAGS2,CHAINTRM       IF RC = 16, IS THIS A     F41448
*                                      CHAINED TERM PCE OFF AN   F41448
*                                      OPER PCE,  IF NOT, A      F41448
         BZ    INVPARMS                R.C. OF 16 IS INVALID     F41448
*/* P LOAD RETURN ADDRESS INTO IKJPARS2 */
*/* R () RETURN TO IKJPARS2 ON +4 */
         L     LINK2,CBLNKSV2          IF THE RET CODE 16  IS    F41448
         B     FOUR(LINK2)             VALID, BRANCH BACK TO     F41448
*                                      COBOL PROCESSORS ON +4 TO F41448
*                                      INDICATE A 16 R.C. WAS    F41448
*                                      RECEIVED                  F41448
         SPACE
*/*VCERC: P ZERO THE PDE */
VCERTN3  XR    R1,R1                   CLEAR REG TO HOLD PDE LENGTH
         IC    R1,PPDESIZE             LOAD PDE LENGTH-1
         L     R3,PDEADR               LOAD R3 WITH PDEADR STORED BY
*                                         THE POSITIONAL EXIT ROUTINE
         EX    R1,ERASEXC              ZERO THE PDE - IT MUST BE
*                                         RECONSTRUCTED
*/* P MOVE V.C. ERROR RETURN ADDRESS FOR RETURN TO IKJPARS2 */
         MVC   GOREGSV(L'GOREGSV),PLINKSV2                       F41448
*                                      IF AN ERROR HAS BEEN RET- F41448
*                                      URNED BY THE V.C. EXIT,   F41448
*                                      THE ERROR RETURN ADDRESS  F41448
*                                      INTO THE COBOL MACRO PRO- F41448
*                                      CESSOR MUST BE STORED     F41448
*                                      INTO GOREGSV SO THAT      F41448
*                                      RETURN WILL BE AT THE     F41448
*                                      PROPER PLACE TO INDICATE  F41448
*                                      THAT THE V.C. EXIT RET-   F41448
*                                      URNED WITH AN ERROR       F41448
*/* D (YES,,NO,VCERTN1) PROCESSING A LIST */
         NC    PREVPDEL,PREVPDEL       IS A LIST BEING PROCESSED
         BZ    VCERTN1                 IF NO BRANCH
         SPACE
*/* P INDICATE LAST PDE PROCESSED WAS LAST ONE IN CHAIN */
         L     R14,PREVPDEL            LOAD THE PREVIOUS PDE ADDRESS
         MVC   ZERO(L'ENDCHAIN,R14),ENDCHAIN INDICATE THE LAST PDE
*                                         PROCESSED WAS THE LAST ONE IN
*                                         THE CHAIN
         SPACE
*/*VCERTN1: D (YES,CODE4,NO,) SHOULD INVALID MSG BE WRITTEN */
VCERTN1  DS    0H                      * * * *
         CH    R15,H4                  SHOULD AN INVALID MESSAGE BE
*                                         WRITTEN
         BE    CODE4X                  YES - FULL ERROR TREATMENT
         SPACE
*/* D (YES,VCERR,NO,) SHOULD PARSE QUIT */
         CH    R15,H12                 SHOULD PARSE QUIT
         BE    VCERR                   IF YES BRANCH
         SPACE
*/* D (YES,,NO,INVPARMS) SHOULD ONLY REENTER MSG BE WRITTEN */
         CH    R15,H8                  SHOULD ONLY REENTER MESSAGE BE
*                                         WRITTEN
         BNE   INVPARMS                IF NO ITS AN INVALID RETURN CODE
         SPACE
*/* P INDICATE TO PRINT ONLY REENTER MSG */
         OI    PFLAGS2,PFSKPINV        SET FLAG TO SKIP INVALID MESSAGE
*                                         AND PRINT ONLY REENTER
*                                         MESSAGE
CODE4X   DS    0H                                                Y02666
         L     R15,ADRMSGC             LOAD ADDRESS OF MESSAGE CSECT
         CLC   VALMSG,ENDCHAIN         HAS THE VALIDITY CHECK ROUTINE
*                                      SUPPLIED A HELP MESSAGE
         BNE   SETFLG                  YES, CONTINUE PROCESSING  Y01156
         SPACE
         TM    PCEFLGB1(XPCE),PCEFHELP DID USER SPECIFY HELP MSG.Y01156
         BO    SETMSG3A                YES, SET UP REENTER+ MSG. Y01156
SETMSG3  DS    0H                                                Y02666
         L     R15,MSG3(R15)           LOAD ADDRESS OF REENTER MESSAGE
         MVC   PRIMSGID+FOUR(EIGHT),FOUR(R15) SAVE MESSAGE ID FOR HELP
*                                         MESSAGES
         B     CODE4                   CONTINUE PROCESSING       Y01156
*/* D (YES,,NO,CODE4) HAS VALIDCHK RTN SUPPLIED HELP MSG */
*/* P INDICATE MSG IS PRESENT */
SETFLG   DS    0H                                                Y01156
         OI    PFLAGS4,PFVCMSG         YES, TURN ON FLAG TO INDICATE
*                                         A MESSAGE IS PRESENT
SETMSG3A DS    0H                                                Y01156
         TM    PFLAGS,PFBYPAS          IS BYPASS NEEDED?         Y02666
         BO    SETMSG3                 INDICATE NO HELP          Y02666
         L     R15,MSG3A(R15)          LOAD ADDRESS OF REENTER+
*                                      MESSAGE                   Y01156
         MVC   PRIMSGID+FOUR(EIGHT),FOUR(R15) SAVE MESSAGE ID FOR HELP
*                                         MESSAGES
         SPACE
*/*CODE4: D (NO,CODE41,YES,) PROCESSING COBOL PCE'S? */
*/* P CLEAR THE TEMPORARY PDE (COBOL) */
*/* R () RETURN TO IKJPARS2 */
*/*CODE41: D (YES,ILLIDENT,NO,) IKJIDENT PDE */
CODE4    DS    0H                      * * * *
         TM    CBFLAGS1,COBOLMOD       ARE WE PROCESSING COBOL   F41448
*                                      PCE'S?                    F41448
         BZ    CODE41                  IF NOT, CONTINUE PARSE    F41448
         XC    TEMPPDE(CBLTPDE),TEMPPDE IF IN COBOL MODE         F41448
*                                      CLEAR THE TEMP. PDE       F41448
         L     LINK1,CBLNKSV2          RETURN TO COBOL PROCESSRS F41448
*                                      WITH INDICATION THAT      F41448
         BR    LINK1                   V.C. RETURNED AN ERROR    F41448
*                                      INDICATION                F41448
CODE41   MVC   PDWORD(ONE),PCEFLGB1(XPCE) MOVE PCE TYPE INDICATORS
         NI    PDWORD,HE0              ISOLATE TYPE INDICATOR
         CLI   PDWORD,EIGHT*(IDENTB-MAINB) IS IT AN IKJIDENT PCE
         BE    ILLIDENT                YES -- PROCESS INVALID IDENT
         SPACE
         XR    R1,R1                   CLEAR R1                  Y02666
         IC    R1,PCEPOST(XPCE)        PICK UP TYPE OF POSITIONAL PCE
*                                         FROM PCE
         SLL   R1,TWO                  MULTIPLY IT BY FOUR
         B     *+FOUR(R1)              DETERMINE WHAT TYPE OF
*                                         POSITIONAL IT IS
*
*/* D (YES,INVPARMS,NO,) NON-EXISTENT TYPE PCE */
         B     INVPARMS                TYPE 0  - NONEXISTENT
*
*/* D (YES,INVPARMS,NO,) DELIMITER TYPE PCE */
         B     INVPARMS                TYPE 1  - DELIMITER
*
*/* D (YES,INVPARMS,NO,) SELF-DELIMITING STRING */
         B     INVPARMS                TYPE 2  - SELF-DELIMITING STRING
*
*/* D (YES,ILLVALU,NO,) VALUE TYPE PCE */
         B     ILLVALU                 TYPE 3  - VALUE
*
*/* D (YES,ILLADDR,NO,) ADDRESS TYPE PCE */
         B     ILLADDR                 TYPE 4  - ADDRESS
*
*/* D (YES,ILLPSTR,NO,) PARENTHESIZED STRING */
         B     ILLPSTR                 TYPE 5 - PARENTHESIZED STRING
*
*/* D (YES,ILLUSID,NO,) USERID TYPE PCE */
         B     ILLUSID                 TYPE 6 - USERID
*
*/* D (YES,ILLDSN,NO,) DSNAME TYPE PCE */
         B     ILLDSN                  TYPE 7  - DSNAME
*
*/* D (YES,ILLDSN,NO,) ASTERISK FOR DSNAME */
         B     ILLDSN                  TYPE 8  - * FOR DSNAME
*
*/* D (YES,ILLQSTR,NO,) QUOTED STRING TYPE PCE */
         B     ILLQSTR                 TYPE 9 - QUOTED STRING
         B     INVPARMS                TYPE 10 - SPACE(NOT USED) Y02666
         B     ILLJOBN                 TYPE 11 - JOBNAME         Y02666
         SPACE
*
********
******** N O T E  - ANY OF THE ABOVE BRANCHES TO INVPARMS MEANS THAT
********            AN UNSUPPORTED VALIDITY CHECK EXIT WAS TAKEN.
********
*
         EJECT
***********************************************************************
*                                                                     *
*                       ERROR HANDLING SUBROUTINE                     *
*                                                                     *
*   THIS ROUTINE WRITES THE 'INVALID' MESSAGE AND PROMPTS FOR THE     *
* CORRECT PARAMETER. IT ALSO CALCULATES THE LENGTH OF THE INVALID DATA*
* AND BUILDS THE APPROPRIATE MESSAGE SEGMENT.                         *
*   A RETURN IS MADE TO THE APPRIPRIATE RESCAN ROUTINE.               *
*                                                                     *
***********************************************************************
         SPACE
*
* INVALID DSNAME.
*
*/*ILLDSN: P INDICATE MESSAGE TO WRITE */
ILLDSN   DS    0H                      * * * *
         NI    PFLAGS7,HFF-VOLSERF     RESET VOL SER FLAG        Y02666
         MVI   PERRCODE,ZERO           SET INDEX VALUE FOR DSNAME
         TM    PFLAGS7,DSNAMEF         IS DSNAME PROCESSING?     Y02666
         BO    INVDSN                  YES, PROCESS AS INVALID   Y02666
         TM    PFLAGS5,DSNFLG          DSNAME IN PROCESS?        Y02666
         BZ    ILLJOBN                 PROCESS INVALID JOB NAME  Y02666
INVDSN   DS    0H                                                Y02666
         TM    PCEFLGB2(XPCE),PCEFDDN  IS DDNAME BEING PROCESSED?Y02666
         BO    DDNMSG                  SET DDNAME MSG            Y02666
         MVI   MSGCODE,MSG10           INDICATE MESSAGE TO WRITE
*/* D (,SYSR1) BRANCH TO ERROR HANDLER */
         B     SYSR1                   BRANCH TO ERROR HANDLER
DDNMSG   DS    0H                                                Y02666
         MVI   MSGCODE,MSG20           SET UP DDNAME MSG         Y02666
         B     SYSR1                   BRANCH TO ERROR HANDLER   Y02666
         SPACE
ILLJOBN  DS    0H                                                Y02666
         MVI   PERRCODE,ZERO           SET INDEX VALUE FOR JOBNAMY02666
         MVI   MSGCODE,MSG19           INDICATE MESSAGE TO WRITE Y02666
         B     SYSR1                   GO TO ERROR HANDLER       Y02666
*
* INVALID USERID
*
*/*ILLUSID: P INDICATE MESSAGE TO WRITE */
ILLUSID  DS    0H                      * * * *
         MVI   MSGCODE,MSG11           INDICATE MESSAGE TO WRITE
         MVI   PERRCODE,THIRTY6        SET INDEX VALUE FOR USERID
*/* D (,SYSR1) BRANCH TO ERROR HANDLER */
         B     SYSR1                   BRANCH TO ERROR HANDLER
         SPACE
*
* INVALID ADDRESS.
*
*/*ILLADDR: P INDICATE MESSAGE TO WRITE */
ILLADDR  DS    0H                      * * * *
         NI    PFLAGS,HFF-HEXBIT-DECBIT-PFNEW-ADREXP    *         M4789
         NI    PFLAGS2,H80             CLEARS ALL BUT BIT 0 IN PFLAGS2
         NI    PFLAGS3,HFF-ONERBIT-TWORBIT       *
         MVI   MSGCODE,MSG12           INDICATE MESSAGE TO WRITE
         MVI   PERRCODE,TWELVE         SET ERROR CODE FOR ADDRESS
*/* D (,SYSR1) BRANCH TO ERROR HANDLER */
         B     SYSR1                   BRANCH TO ERROR HANDLER
         SPACE
*
* INVALID VALUE.
*
*/*ILLVALU: P INDICATE MESSAGE TO WRITE */
ILLVALU  DS    0H                      * * * *
         MVI   MSGCODE,MSG14           INDICATE MESSAGE TO WRITE
         MVI   PERRCODE,SIXTEEN        SET INDEX VALUE FOR VALUE
*/* D (,SYSR1) BRANCH TO ERROR HANDLER */
         B     SYSR1                   BRANCH TO ERROR HANDLER
         SPACE
*
* INVALID IDENT.
*
*/*ILLIDENT: P INDICATE MESSAGE TO WRITE */
ILLIDENT DS    0H                      * * * *
         MVI   MSGCODE,MSG6            INDICATE MESSAGE TO WRITE
         MVI   PERRCODE,TWENTY4        SET INDEX VALUE FOR IDENT
         LA    R0,PCEPARMT(XPCE)       COMPUTE ADDRESS OF PARAMETER
*                                         TYPE MESSAGE SEGMENT IN PCE
         ST    R0,SEGLIST+SIXTEEN      STORE ADDRESS IN PARAMETER LIST
*                                         FOR PUTLINE
         NI    PFLAGS6,HFF-NUMFLG-PDEHEX   RESET FLAGS           Y02666
*/* D (,SYSR1) BRANCH TO ERROR HANDLER */
         B     SYSR1                   BRANCH TO ERROR HANDLER
         SPACE
*
* INVALID PASSWORD FOR A DSNAME.
*
*/*ILLDSNPS: P SET INDEX VALUE TO RESCAN DSNAME PASSWORD */
ILLDSNPS DS    0H                      * * * *
         MVI   PERRCODE,EIGHT          SET INDEX VALUE TO RESCAN
*                                         DSNAME PASSWORD
*/* D (,ILLPASWD) BRANCH */
         B     ILLPASWD                BRANCH
         SPACE
*
* INVALID PASSWORD FOR A USERID.
*
*/*ILLUIDPS: P SET INDEX VALUE TO RESCAN USERID PASSWORD */
ILLUIDPS DS    0H                      * * * *
         MVI   PERRCODE,THIRTY2        SET INDEX VALUE TO RESCAN
*                                         USERID PASSWORD
         TM    DATAFLA2,PRESENT        OFF IF ON CURRENT PSWD  @Z40RPKQ
         BO    ILLSPSWD                SET UP FOR NEW PSWD     @Z40RPKQ
         MVI   MSGCODE,MSG9            PROMPT MSG FOR CURRENT  @Z40RPKQ
*                                      PASSWORD                @Z40RPKQ
         B     PSWSCAN
ILLSPSWD MVI   MSGCODE,MSG21
PSWSCAN  LA    XINPUT,ONE(XINPUT)      INCREMENT PTR TO NEXT   @Z40RPKQ
*                                      CHARACTER IN CMD BUFFER @Z40RPKQ
         C     XINPUT,ENDINPUT         END OF BUFFER?          @Z40RPKQ
         BNL   PSWSCAN2                BRANCH IF AT END OF     @Z40RPKQ
         CLI   ZERO(XINPUT),SLASH      CURRENT CHAR A SLASH?   @Z40RPKQ
         BNE   PSWSCAN                 NO,CONTINUE SCAN        @Z40RPKQ
         LA    XINPUT,ONE(XINPUT)      MOVE INPUT PTR OVER ONE @Z40RPKQ
         NI    PFLAGS,HFF-PFENDF       TURN OFF END OF FILE FLG@Z40RPKQ
         OI    PFLAGS7,PSW2SET         TURN ON FILE FLAG TO INDICATE
*                                      THAT 4R IS POINTING TO NEW PASS
*                                      WORD                    @Z40RPKQ
PSWSCAN2 DS    0H                      * * * *                 @Z40RPKQ
         B     PROMBYPS                 SET UP BYPASS MODE     @Z40RPKQ
         SPACE
*/*ILLPASWD: P INDICATE MESSAGE TO WRITE */
ILLPASWD DS    0H                      * * * *
         MVI   MSGCODE,MSG9            INDICATE MESSAGE TO WRITE
*/* P INDICATE PROMPT IN BYPASS MODE */
PROMBYPS OI    PFLAGS,PFBYPAS          INDICATE PROMPTING TO BE DONE IN
*                                         BYPASS MODE          @Z40RPKQ
         MVC   DATAUSER,INVPSAVE       SAVE ERR PTR TO DSNAME OR USERID
         MVC   INVPSAVE,PPOINTR        REPLACE ERR PTR WITH PASSWD PTR
*/* D (,SYSR1) BRANCH TO ERROR HANDLER */
         B     SYSR1                   BRANCH TO ERROR HANDLER
         SPACE
*
* INVALID QUOTED STRING OR INVALID PARENTHESIZED STRING
*
*/*ILLPSTR: P SET INDEX VALUE FOR PSTRING */
ILLPSTR  DS    0H                      INVALID PSTRING
         MVI   PERRCODE,TWENTY         SET INDEX VALUE FOR PSTRING
*/* D (,ILLSTR1) BRANCH */
         B     ILLSTR1                 BRANCH
         SPACE
*/*ILLQSTR: P SET INDEX VALUE FOR QSTRING */
ILLQSTR  DS    0H                      INVALID QSTRING
         MVI   PERRCODE,TWENTY8        SET INDEX VALUE FOR QSTRING
         SPACE
*/*ILLSTR1: P INDICATE MESSAGE TO WRITE */
ILLSTR1  DS    0H                      * * * *
         MVI   MSGCODE,MSG16           INDICATE MESSAGE TO WRITE
         SPACE
*
* PREPARE POINTERS TO CREATE 2ND SEGMENT FOR 'INVALID STRING' MESSAGE.
* THIS MESSAGE IS ISSUED ONLY AT THE REQUEST OF A VALIDITY CHECKING
* ROUTINE.  COMMON CODE FOR PSTRING AND QSTRING.
*
*/* D (YES,JUSTPROM,NO,) VALIDCHK RTN SPECIFIED ONLY REENTER MSG */
         TM    PFLAGS2,PFSKPINV        DID THE VALIDITY CHECK ROUTINE
*                                         SPECIFY ONLY A REENTER MSG
         BO    JUSTPROM                YES IF BIT ON --- BRANCH
         B     SYSR1                   GO TO ERROR HANDLER       YM2356
         SPACE
*/*ILLSTR2: D (YES,ILLSTR3,NO,) STRING ENDS AT END OF INPUT */
ILLSTR2  DS    0H                      * * * *
         LH    XINPUTB,PLENGTH         GET LENGTH OF STRING
         LA    XINPUTB,ONE(XINPUTB)    INCREASE BY ONE TO INCLUDE
*                                         BEGINNING PUNCTUATION
         L     R3,INVPSAVE             LOAD POINTER TO STRING
         AR    R3,XINPUTB              COMPUTE ENDING ADDRESS OF STRING
         C     R3,ENDINPUT             DOES STRING END AT END OF INPUT
         BNL   ILLSTR3                 YES, CONTINUE NORMALLY
         SPACE
*/* P INCREASE LENGTH BY 1 TO INCLUDE ENDING DELIMITER */
         LA    XINPUTB,ONE(XINPUTB)    INCREASE LENGTH BY ONE TO
*                                         INCLUDE ENDING PUNCTUATION
*/* D (,ILLSTR3) CONTINUE NORMALLY */
*/*ILLKEYWD: P INDICATE MESSAGE TO WRITE */
         B     ILLSTR3                 CONTINUE NORMALLY
         SPACE
*
* INVALID KEYWORD.
*
ILLKEYWD DS    0H                      * * * *
         MVI   MSGCODE,MSG13           INDICATE MESSAGE TO WRITE
         SPACE
*
* ENTRY FOR AMBIGUOUS MESSAGE
*
*/*ILLKAMB1: P LOAD OFFSET TO KEYWORD OR END OF FIELD PCE */
ILLKAMB1 DS    0H                      * * * *
         MVI   PERRCODE,FOUR           SET INDEX VALUE FOR KEYWORD
         L     XPCE,RPCEAD             LOAD ADDRESS OF SUBFIELD PCE
         MVC   PDWORD(TWO),ZERO(XPCE)  ALIGN DATA ON PROPER BOUNDARY
         LH    XPCE,PDWORD             LOAD OFFSET TO KEYWORD OR
*                                         END-OF-FIELD PCE
         A     XPCE,PTABLEAD           OBTAIN TRUE PCE ADDRESS
         NI    RFLAGS,HFF-RFKYPRSE     CLEAR ALREADY PARSED FLAG
         MVC   INVPSAVE,PPOINTR        REPLACE WITH PTR TO KEYWORD
         SPACE
*
* CALCULATE LENGTH OF DATA ENTERED.
*
*/*SYSR1: D (YES,JUSTPROM,NO,) VALIDCHK RTN SPECIFY ONLY REENTER MSG */
SYSR1    DS    0H                      * * * *
         OI    PFLAGS5,INVPRMPT        INDICATE PROMPT FOR THIS PARAM
*                                                                A42352
         TM    PFLAGS6,PSWDQFLG        IS QUOTED PASSWORD?       Y02666
         BO    SYSR7                   YES, GO PROCESS           Y02666
         TM    PFLAGS2,PFSKPINV        DID THE VALIDITY CHECK ROUTINE
*                                         SPECIFY ONLY A REENTER MSG
         BO    JUSTPROM                YES IF BIT ON --- BRANCH
         SPACE
         TM    PFLAGS6,PSWDQFLG        QUOTED PASSWORD           Y02666
         BO    SYSR7                   YES, DONT ZERO LENGTH     Y02666
         XC    PLENGTH,PLENGTH         CLEAR LENGTH FIELD
*/* D (YES,SYSR4,NO,) PROCESSING COBOL PCE'S? */
*/* COMMENT (1,15) DO NOT TEST */
*/* COMMENT (2,15) PFENDSET */
SYSR7    DS    0H                                                Y02666
         TM    CBFLAGS1,COBOLMOD       PROCESSING COBOL PCE'S    F41448
         BO    SYSR4                   NO, CONTINUE PARSE        F41448
*/* D (YES,SYSR2,NO,) ENDBAKUP HAS BEEN SET */
         TM    PFLAGS4,PFENDSET        HAS ENDBAKUP BEEN SET
         BZ    SYSR2                   NO, CONTINUE
         SPACE
         LA    XINPUT,ONE(XINPUT)      INCREMENT SCAN POINTER    M0882
*/* S PUSHI: SAVE CURRENT LEVEL */
         BAL   LINK1,PUSHI             YES, SAVE CURRENT LEVEL
         SPACE
*/* P (,SYSR2) SAVE END OF DATA THAT IS INVALID */
******* THIS NEXT LINE WAS DELETED DUE TO APAR-16362********  @ZA16362
******** MVC   ENDINPUT,ENDBAKUP ***** GET END OF DATA THAT IS INVALID
************************************************************  @ZA16362
*/*SYSR4: P TURN PFENDSET OFF */
SYSR4    NI    PFLAGS4,HFF-PFENDSET    TURN OFF END SET FLAG     M0882
         SPACE
*/*SYSR2: P RESET SCAN PTR */
SYSR2    DS    0H                      * * * *
*/* D (YES,SYSRINDL,NO,) PROCESSING COBOL PCE'S? */
         TM    CBFLAGS1,COBOLMOD       PROCESSING COBOL PCE'S?   F41448
         BO    SYSR3                   YES, SKIP SCAN            F41448
         TM    PFLAGS7,PSW2SET        TEST TO SEE IF 4R HAS BEEN MOVE
*                                      BY ONE                  @Z40RPKQ
         BO    SYSR3                   YES, SKIP PAST DELIMITER@Z40RPKQ
         L     XINPUT,INVPSAVE         RESET SCAN PTR TO START OF
         TM    PFLAGS6,PSWDQFLG        QUOTED PASSWORD?          Y02666
*/* D (,SYSRSTR) START SCAN */
         BZ    SYSRISTR                START SCAN                Y02666
         LH    XINPUTB,PLENGTH         GET LENGTH OF STRING      Y02666
         LA    XINPUT,ONE(XINPUTB,XINPUT) GET END OF INPUT PTR   Y02666
         C     XINPUT,ENDINPUT         AT END OF INPUT?          Y02666
         BL    SYSDECR                 DECREMENT LENGTH          Y02666
         OI    PFLAGS,PFENDF           INDICATE END OF INPUT     Y02666
SYSDECR  DS    0H                                                Y02666
         NI    PFLAGS6,HFF-PSWDQFLG    TURN OFF QUOTED PSWD FLAG Y02666
         BCTR  XINPUT,ZERO             DECREMENT SCAN PTR        Y02666
         B     ILLSTR3                 GET CORE                  Y02666
         SPACE
*/*SYSRISCN: D (YES,,NO,SYSRSTR) REACHED END OF INPUT */
SYSRISCN DS    0H                      * * * *
         LA    XINPUT,ONE(XINPUT)      BUMP SCAN REGISTER BY ONE
         LR    XINPUTB,XINPUT          SET BACKUP REGISTER
         C     XINPUT,ENDINPUT         END OF INPUT
         BL    SYSRISTR                NO --- BRANCH
         SPACE
*/* P SET END OF FILE INDICATOR */
         OI    PFLAGS,PFENDF           SET END-OF-FILE INDICATOR SO
*                                         CURRENT STATUS OF SCAN WILL
*                                         NOT BE SAVED BEFORE PROMPT
*/* D (,SYSRINDL) BRANCH TO BUILD MSG SEGMENT */
         B     SYSRINDL                BRANCH TO BUILD MESSAGE SEGMENT
         SPACE
*/*SYSRSTR: D (YES,,NO,SYSRSTR1) CHARACTER IS LEFT PAREN */
SYSRISTR DS    0H                      * * * *
         CLI   ZERO(XINPUT),LEFTPRN    IS CHARACTER A LEFT PAREN
         BNE   SYSRSTR1                NO CONTINUE PROCESSING
         SPACE
*/* P INDICATE LEFT PAREN FOUND */
         OI    PFLAGS3,LPRNFND         YES - INDICATE A LEFT PAREN WAS
*                                         FOUND
         SPACE
*/*SYSRSTR1: S TYPETEST: CHECK IF CHARACTER IS DELIMITER */
SYSRSTR1 DS    0H                      * * * *
         LA    R1,DLIMREQD             SEE IF THE CHARACTER IS A
*                                         DELIMITER
         BAL   LINK1,TYPETEST          BRANCH TO CHARACTER TEST ROUTINE
*
*/* D (YES,,NO,SYSRISCN) CHARACTER IS DELIMITER */
         B     SYSCOMT                 +0 RETURN - NON DELIMITER Y02666
*                                      TEST FOR COMMENT DELIMITR Y02666
*                                      +4 RETURN - DELIMITER FOUND
*/* D (YES,,NO,SYSRINDL) DELIMITER IS RIGHT PAREN */
         CLI   ZERO(XINPUT),RIGHTPRN   IS DELIMITER A RIGHT PAREN
         BNE   SYSRINDL                NO CONITNUE PROCESSING
         SPACE
*/* D (YES,,NO,SYSRINDL) LEFT PAREN WAS FOUND */
         TM    PFLAGS3,LPRNFND         YES - WAS A LEFT PAREN FOUND
         BZ    SYSRINDL                NO - CONTINUE PROCESSING
         SPACE
*/* P TURN OFF LEFT PAREN FLAG */
         NI    PFLAGS3,HFF-LPRNFND     YES - TURN OFF LEFT PAREN FLAG
*/* D (,SYSRISCN) SKIP RIGHT PAREN */
         B     SYSRISCN                SKIP THE RIGHT PAREN
         SPACE
SYSCOMT  DS    0H                                                Y02666
         LA    R15,ONE(XINPUT)         GET NEXT CHARACTER PTR    YM3610
         C     R15,ENDINPUT            END OF INPUT?             YM3610
         BC    CC10,SYSRISCN           BYPASS COMMENT CHECK       M4540
         CLC   ZERO(TWO,XINPUT),SLASHAST COMMENT DELIMITER?      Y02666
         BNE   SYSRISCN                NO,CONTINUE.ELSE END SCAN Y02666
*
* BUILD MESSAGE SEGMENT FOR DATA-ENTERED
*
*/*SYSRINDL: P COMPUTE LENGTH OF ERROR FIELD */
SYSRINDL DS    0H                      * * * *
         NI    PFLAGS3,HFF-LPRNFND     TURN OFF POSSIBLE LEFT PAREN
*                                         FLAG
*                                      INVPSAVE POINTS TO START OF
*                                         ERROR FIELD
SYSR3    S     XINPUTB,INVPSAVE        COMPUTE LENGTH OF ERROR FIELD
*/* D (YES,SYSRISCN,NO,) IF LENGTH ZERO SKIP PAST DELIMITER */
         BZ    SYSRISCN                IF LENGTH ZERO SKIP PAST
*                                         DELIMITER
         SPACE
*/* P DECREMENT SCAN POINTER */
         BCTR  XINPUT,ZERO            DECREMENT SCAN POINTER     M2454
         SPACE
*/*ILLSTR3: S GETCORE: GET CORE FOR MESSAGE SEGMENT */
ILLSTR3  DS    0H                      ENTER HERE TO BUILD SEGMENT FOR
*                                         INVALID STRING MSG
         LA    R1,FOUR(XINPUTB)        GET SIZE OF CORE FOR MESSAGE SEG
*                                         PLUS FOUR FOR HEADER
         BAL   LINK1,GETCORE           GET CORE FOR MESSAGE SEGMENT
         SPACE
*                                      CORE ADDRESS RETURNED IN R1
         ST    R1,SEGLIST+TWELVE       STORE ADDRESS IN LIST OF SEGMENT
         LA    R0,FOUR(XINPUTB)        GET SIZE OF MESSAGE SEGMENT
         STH   R0,ZERO(R1)             STORE INTO SEGMENT
*/* D (YES,ILLKAMB2,NO,) AMBIGUOUS MSG BEING WRITTEN */
         CLI   MSGCODE,MSG4            IS AN AMBIGUOUS MSG BEING
*                                         WRITTEN
         BE    ILLKAMB2                YES, GO BUILD AMBIGUOUS SEGMENT
*
         XR    R15,R15                 CLEAR WORK INDEX REGISTER
         IC    R15,MSGCODE             INSERT MESSAGE INDEX
         L     R3,ADRMSGC              LOAD ADDRESS OF MESSAGE CSECT
         L     R15,ZERO(R15,R3)        LOAD ADDRESS OF MESSAGE
         LH    R15,ZERO(R15)           LOAD THE PROTOTYPE MESSAGE LEN.
         SH    R15,H4                  COMPENSATE FOR HEADER
*/* P STORE TRUE LENGTH OF MSG  */
         STH   R15,TWO(R1)             STORE TRUE LENGTH AS OFFSET FOR
*                                         NEW SEGMENT
*
* ENTRY FROM SETTING OF AMBIGUOUS MSG OFFSET.
*
*/*ILLKAMB3: P MOVE TEXT TO NEW SEGMENT */
ILLKAMB3 DS    0H                      * * * *
         L     R15,INVPSAVE            LOAD START OF DATA ADDRESS
         BCTR  XINPUTB,ZERO            DECREMENT FOR EXECUTE     YM2742
         EX    XINPUTB,BUILDSEG        MOVE TEXT TO NEW SEGMENT
*                                      MSGCODE SETUP PREVIOUSLY
*/* S WRITER1: BRANCH TO PUTLINE ROUTINE */
         BAL   LINK1,WRITER1           BRANCH TO PUTLINE ROUTINE
         SPACE
*/*JUSTPROM: D (YES,,NO,JUSTPRM2) INVALID PASSWORD MSG WRITTEN */
JUSTPROM DS    0H                      * * * *
         NI    PFLAGS2,HFF-PFSKPINV    SET POSSIBLE
*                                         FLAGS TO ZERO
         CLI   MSGCODE,MSG9            IS AN INVALID PASSWORD MSG BEING
*                                         WRITTEN
         BE    RESERRPT                IF YES, BRANCH TO RESTORE ERROR
*                                      POINTER                 @Z40RPKQ
         CLI   MSGCODE,MSG21           CHECK TO SEE IF AN INVALID PASS
*                                      WORD MESSAGE IS BEING WRITTEN
*                                                              @Z40RPKQ
         BNE   JUSTPRM2                IF NO BRANCH - ZERO TEMP PDE
         SPACE
*/* P RESTORE ERR PTR TO DSNAME OR USERID */
RESERRPT MVC   INVPSAVE,DATAUSER       RESTORE ERR PTR TO DSNAME OR
*                                         USERID FOR POSSIBLE INVALID
*                                      MSG FROM VALIDITY CHECK @Z40RPKQ
*/* D (,JUSTPRM1) BRANCH */
         B     JUSTPRM1                BRANCH - TEMPORARY PDE
*                                         CANNOT BE ZEROED BECAUSE
*                                         DATA GATHERED SO FAR IS
*                                         GOOD
         SPACE
*/*JUSTPRM2: P ZERO TEMPORARY PDE */
JUSTPRM2 DS    0H                      * * * *
         XC    TEMPPDE(LTPDE),TEMPPDE  ZERO THE TEMPORARY PDE
         SPACE
*/*JUSTPRM1: P INDICATE MSG TO PROMPT WITH */
JUSTPRM1 DS    0H                      * * * *
         TM    PCEFLGB1(XPCE),PCEFHELP HELP MESSAGES SPECIFIED   Y01156
         BO    SETHLP                  SKIP SETTING REENTER MSG. Y01156
BYPHELP  DS    0H                                                Y02666
         MVI   MSGCODE,MSG3            INDICATE MESSAGE TO PROMPT WITH
         B     VCECONT                 SKIP SETTING REENTER+ MSG Y01156
SETHLP   DS    0H                                                Y01156
         TM    PFLAGS,PFBYPAS          IS BYPASS MODE            Y02666
         BO    BYPHELP                 BYPASS HELP               Y02666
         MVI   MSGCODE,MSG3A           INDICATE REENTER+ MSG     Y01156
VCECONT  DS    0H                                                Y01156
*/* D (NO,JUSTPRM3,YES,) PROCESSING COBOL PCE'S? */
         TM    CBFLAGS1,COBOLMOD       PROCESSING COBOL PCE'S    F41448
         BZ    JUSTPRM3                NO, CONTINUE NORMAL PARSE F41448
*/* P LOAD RETURN ADDRESS SUPPLIED BY IKJPARS2 INTO LINK1 */
         L     LINK1,CBLNKSV2          IF IN COBOL MODE, LOAD    F41448
*                                      RETURN ADDRESS SUPPLIED   F41448
*                                      BY COBOL MODULE           F41448
*/* R () BRANCH TO WRITER2 */
         B     WRITER2                 BRANCH TO WRITER2 TO      F41448
*                                      WRITE MSG                 F41448
JUSTPRM3 XR    R1,R1                   CLEAR WORK REG TO ZERO
         IC    R1,PERRCODE             LOAD RESCAN INDEX VALUE
         L     LINK1,RETRNTAB(R1)      GET APPROPRIATE RESCAN ADDRESS
*/*JUSTPRM3: D (,WRITER2) PROMPT FOR NEW DATA */
         B     WRITER2                 PROMPT USER FOR NEW DATA
         SPACE
*
* SET OFFSET FOR AMBIGUOUS MESSAGE.
*
*/*ILLKAMB2: P SET OFFSET TO PLACE IN MSG TO INSERT TEXT */
ILLKAMB2 DS    0H                      * * * *
         MVI   TWO(R1),ZERO            SET FIRST BYTE OF OFFSET TO 0
         MVI   THREE(R1),OFFSET6       SET OFFSET TO PLACE IN MSG
*                                         TO INSERT TEXT
*/* D (,ILLKAMB3) RETURN TO MAINLINE CODE */
         B     ILLKAMB3                RETURN TO MAINLINE INVALID MSG
*                                         PROCESSING
         EJECT
***********************************************************************
*                                                                     *
*                   CLEANUP ROUTINE                                   *
* THIS ROUTINE IS ENTERED:                                            *
* WHEN AN UNRECOVERABLE ERROR OCCURS, WHEN THE PUTGET SERVICE ROUTINE *
* INDICATES THAT INPUT DATA IS MISSING OR IS INVALID FOR A USER IN    *
* NOPROMPT MODE (THIS INCLUDES THE BAKCGROUND USER), OR WHEN AN       *
* INPUT/OUTPUT SERVICE ROUTINE INDICATES AN ATTENTION HAS BEEN ISSUED *
* TO FREE THE VARIABLE RESOURCES OBTAINED DURING PROCESSING AND THEN  *
* BRANCHES TO THE NORMAL EXIT ROUTINE.                                *
*                                                                     *
***********************************************************************
*/*CLEANUP: P FREE CORE OBTAINED FOR INPUT PUSHDOWN STACK CHAIN */
         SPACE
*
* FREE CORE OBTAINED FOR INPUT PUSHDOWN STACK CHAIN.
*
CLEANUP  DS    0H                      ERROR CLEANUP ROUTINE
         L     R1,PIPDLCUR             LOAD THE CURRENT INPUT PUSHDOWN
*                                         STACK POINTER
         NC    ONE(THREE,R1),ONE(R1)   IS THE CHAIN WORD ZERO
         BZ    GETPDLAD                IF YES THERE ARE NO ADDITIONAL
*                                         STACKS --- BRANCH
         SPACE
         MVC   PIPDLCUR+ONE(L'PIPDLCUR-ONE),ONE(R1) SAVE PREVIOUS STACK
*                                         ADDRESS
         LA    R0,EIGHT*(IPDLMAXE)+FOUR LOAD STACK SIZE AND SUBPOOL
*                                         NUMBER FOR FREEMAIN
         SPACE
         FREEMAIN R,LV=(0),A=(1)       FREE INPUT PUSHDOWN STACK
         SPACE
         B     CLEANUP                 CONTINUE LOOP
         SPACE
*
* OBTAIN PDL ADDRESS AND RESET PDL POINTER.
*
*/*GETPDLAD: P OBTAIN PDL ADDR AND RESET PDL POINTER */
*/* D (YES,,NO,CLEANUP2) WAS A PDL EVER OBTAINED  */
GETPDLAD DS    0H                      GET PDL ADDRESS
         L     R2,FOUR(PBASE)          LOAD CALLERS SAVEAREA ADDR
         L     R2,TWENTY4(R2)          LOAD INPUT PARAMETERS ADDR
         L     R2,SIXTEEN(R2)          LOAD ANSWER PLACE ADDR
         L     R1,ZERO(R2)             LOAD PDL ADDR
         MVC   ZERO(L'ENDCHAIN,R2),ENDCHAIN INDICATE NO PDL EXISTS
         LTR   R1,R1                   WAS A PDL OBTAINED - MAY HAVE
*                                         FAILED TRYING TO GETMAIN
*                                         FOR THE PDL
         BZ    CLEANUP2                IF NO PDL BRANCH
         SPACE
*
* FREE CORE OBTAINED FOR PDL AND NEW DATA
*
*/*CLEANUP1: P FREE PDL CORE AND NEW DATA CORE */
CLEANUP1 DS    0H                      FREE SUBPOOL 1 CORE
         L     R3,ZERO(R1)             SAVE ADDR OF NEXT AREA TO FREE
         L     R0,FOUR(R1)             LOAD SUBPOOL NO. AND LENGTH INTO
*                                         R0
         SPACE
         FREEMAIN R,LV=(0),A=(1)       ISSUE FREEMAIN
         SPACE
         LA    R3,ZERO(R3)             CLEAR HIGH ORDER BYTE
         LTR   R1,R3                   COPY NEXT CORE ELEMENT ADDR
         BNZ   CLEANUP1                REPEAT IF NOT ZERO
         SPACE
*
* FREE RECURSIVE WORK SPACES
*
*/*CLEANUP2: P (,EXITNORM) FREE RECURSIVE WORK SPACES */
CLEANUP2 DS    0H                      * * * *
         LTR    RBASE,RBASE            CHECK IF ALREADY FREED    Y01156
         BZ    EXITNORM                IF YES, GO TO NORMAL EXIT
*                                         PROCEDURE              Y01156
CLEANUP3 DS    0H                                                Y01156
         L     R2,RBASESV              SEE IF THERE IS A PREVIOUS
         LTR   R2,R2                      RECURSIVE WORKSPACE
         BZ    EXITNORM                IF NO, GO TO NORMAL EXIT
*                                         PROCEDURE
         SPACE
         LR    R1,RBASE                IF YES, LOAD ADDR OF CURRENT
*                                         RECURSIVE WORKAREA
         SPACE
         FREEMAIN R,LV=RWORKSZ,A=(1)   ISSUE FREEMAIN
         SPACE
         LR    RBASE,R2                ESTABLISH NEW BASE REGISTER
         B     CLEANUP3                CONTINUE                  Y01156
         EJECT
***********************************************************************
*                                                                     *
* CHECK RETURN CODES FROM PUTLINE AND PUTGET.  SET PARSE RETURN       *
* CODES ACCORDINGLY.                                                  *
*                                                                     *
***********************************************************************
         SPACE
INVPARMS DS    0H                      * * * *
*/*INVPARMS: P (,CLEANUP) INDICATE PARSE RETURN CODE */
         MVI   RETCODE,RCERROR         INDICATE PARSE RETURN CODE
         B     CLEANUP                 CLEANUP AND EXIT
         SPACE
LINEDROP DS    0H                                                Y02666
         MVI   RETCODE,RCLNDROP        SET LIN DROP RETURN CODE  Y02666
         B     CLEANUP                 CLEANUP AND EXIT          Y02666
         SPACE
ATTNEXIT DS    0H                      * * * *
*/*ATTNEXIT: P (,CLEANUP) INDICATE PARSE RETURN CODE */
         MVI   RETCODE,RCATTN          INDICATE PARSE RETURN CODE
         B     CLEANUP                 CLEANUP AND EXIT
         SPACE
*
* VALIDITY CHECK EXIT ROUTINE INDICATED IT COULD NOT CONTINUE AND WANTS
* PARSE TO TERMINATE.
*
*/*VCERR: P (,CLEANUP) INDICATE PARSE RETURN CODE */
VCERR    DS    0H                      * * * *
         MVI   RETCODE,RCVCERR         INDICATE PARSE RETURN CODE
         B     CLEANUP                 CLEANUP AND EXIT
         SPACE
*
* THE FOLLOWING ACTIONS ARE TAKEN FOR THE VARIOUS RETURN CODES FROM
* PUTLINE
*
*/*PLRCACT: D (0,WRITER1D,4,ATTNEXIT,8,INVPARMS,12,INVPARMS,16,
*/*GETERROR,,INVPARMS)  IS PUTLINE RETURN CODE  */
PLRCACT  DS    0H                      * * * *
         LTR   R15,R15                 IS THE RETURN CODE 0
         BZ    WRITER1D                YES, SUCCESSFUL COMPLETION,
*                                         CONTINUE
         SPACE
         CH    R15,H4                  IS THE RETURN CODE FROM
*                                         PUTLINE 4
         BE    ATTNEXIT                YES, AN ATTENTION INTERRUPT
*                                         OCCURRED DURING PUTLINE
*                                         PROCESSING, GO SET PARSE
*                                         RETURN CODE AND EXIT
         SPACE
         CH    R15,H8                  IS THE RETURN CODE FROM
*                                         PUTLINE 8
         BE    INVPARMS                YES, 'NOWAIT' WAS SPECIFED TO
*                                         PUTLINE, THIS IS AN INVALID
*                                         RETURN CODE TO PARSE
*                                         GO SET PARSE RETURN CODE
*                                         AND EXIT
         SPACE
         CH    R15,H12                 IS THE RETURN CODE FROM
*                                         PUTLINE TWELVE
         BE    INVPARMS                YES, INVALID PARAMETERS WERE
*                                         PASSED TO PUTLINE, GO SET
*                                         PARSE RETURN CODE AND EXIT
         SPACE
         CH    R15,H16                 IS THE RETURN CODE FROM
*                                         PUTLINE SIXTEEN
         BE    GETERROR                YES, A CONDITIONAL GETMAIN WAS
*                                         ISSUED BY PUTLINE AND THERE
*                                         WAS NOT SUFFICIENT SPACE TO
*                                         SATISFY THE REQUEST, GO SET
*                                         PARSE RETURN CODE AND EXIT
*                                                                Y02666
         CH    R15,H20                 WAS LINE DROP CONDITION DETECTED
*                                                                Y02666
         BE    LINEDROP                INDICATE LINE DROP OCCURRED
*                                                                Y02666
         SPACE
         B     INVPARMS                NO, AN INVALID RETURN CODE WAS
*                                         RETURNED FROM PUTLINE, SET
*                                         PARSE RETURN CODE AND EXIT
         SPACE
*
* THE FOLLOWING ACTIONS ARE TAKEN FOR THE VARIOUS RETURN CODES FROM
* PUTGET.
*
*/*PGRCACT: D (0,WRITER2J,4,INVPARMS,8,ATTNEXIT,12,MSNGMSG,16,
*/*INVPARMS,20,INVPARMS,24,INVPARMS,28,GETERROR,,INVPARMS)
*/* IS PUTGET RETURN CODE   */
PGRCACT  DS    0H                      * * * *
         LTR   R15,R15                 IS THE RETURN CODE FROM PUTGET
*                                         ZERO
         BZ    WRITER2J                YES, SUCCESSFUL COMPLETION,
*                                         CONTINUE
         SPACE
         CH    R15,H4                  IS THE RETURN CODE FROM PUTGET
*                                         FOUR
         BE    INVPARMS                YES, INPUT LINE RETURNED IS NOT
*                                         FROM A TERMINAL, INVALID
*                                         RETURN CODE TO PARSE, GO SET
*                                         PSRSE RETURN CODE AND EXIT
         SPACE
         CH    R15,H8                  IS THE RETURN CODE FROM PUTGET
*                                         EIGHT
         BE    ATTNEXIT                YES, AN ATTENTION INTERRUPT
*                                         OCCURRED DURING THE EXECUTION
*                                         OF PUTGET, GO SET PARSE
*                                         RETURN CODE AND EXIT
         SPACE
         CH    R15,H12                 IS THE RETURN CODE FROM PURGET
*                                         TWELVE
         BE    MSNGMSG                 YES, NO INPUT LINE RETURNED
*                                         BECAUSE NO PROMPTING WAS
*                                         SPECIFIED, GO ISSUE MISSING
*                                         MESSAGE
         SPACE
         CH    R15,H16                 IS THE RETURN CODE FROM PUTGET
*                                         SIXTEEN
         BE    INVPARMS                YES, 'NOWAIT' WAS SPECIFIED,THIS
*                                         IS AN INVALID RETURN CODE
*                                         TO PARSE, GO SET PARSE RETURN
*                                         CODE AND EXIT
         SPACE
         CH    R15,H20                 IS THE RETURN CODE FROM PUTGET
*                                         TWENTY
         BE    INVPARMS                YES, 'NOWAIT' WAS SPECIFIED THIS
*                                         IS AN INVALID RETURN CODE
*                                         TO PARSE, GO SET PARSE RETURN
*                                         CODE AND EXIT
         SPACE
         CH    R15,H24                 IS THE RETURN CODE FROM PUTGET
*                                         TWENTY-FOUR
         BE    INVPARMS                YES, INVALID PARAMETERS WERE
*                                         PASSED TO PUTGET, GO SET
*                                         PARSE RETURN CODE AND EXIT
         SPACE
         CH    R15,H28                 IS THE RETURN CODE FROM PUTGET
*                                         TWENTY-EIGHT
         BE    GETERROR                YES, A CONDITIONAL GETMAIN WAS
*                                         ISSUED BY PUTGET AND THERE
*                                         WAS NOT SUFFICIENT SPACE TO
*                                         SATISFY THE REQUEST, GO SET
*                                         PARSE RETURN CODE AND EXIT
         CH    R15,H32                 LINE DROP DETECTED?       Y02666
         BE    LINEDROP                INDICATE LINE DROP        Y02666
         SPACE
         B     INVPARMS                NO AN INVALID RETURN CODE WAS
*                                         RETURNED FROM PUTGET, SET
*                                         PARSE RETURN CODE AND EXIT
         SPACE
         EJECT
***********************************************************************
*                                                                     *
*   THIS ROUTINE CONSTRUCTS THE MSG SEGMENTS TO WRITE A 'MISSING'     *
* MSG. IT IS ENTERED WHEN PROMPTING IS ATTEMPTED, BUT PUTGET          *
* INDICATES THE USER SPECIFIED NO PROMPT OR INPUT IS FROM A COMMAND   *
* PROCEDURE.  IF PUTGET WAS NOT ISSUING AN 'ENTER' MSG THE 'MISSING'  *
* MSG IS NOT SENT.  EXIT IS TO NEXTPCE.                               *
*                                                                     *
***********************************************************************
         SPACE
MSNGMSG  DS    0H                      WRITE 'MISSING' MSG SUBROUTINE
*/*MSNGMSG: D (YES,,NO,CLEANUP) DID PUTGET ISSUE 'ENTER' */
*/* P SET UP 'MISSING' OR 'MISSING PASSWORD' MSG INDEX */
         OI    PFLAGS5,INVFLG          INDICATE INVALID DATA WAS FOUND
*                                      OR NEEDED DATA IS MISSING Y01156
         TM    PCEOPT(XPCE),PCEFPTBY   TEST FOR BYPASS MODE BEFORE
*                                      UPDATING PCE PTR          Y01156
         BZ    SETRET                  DO NOT INDICATE,IF OFF    Y01156
         OI    PFLAGS5,BYPASFLG        INDICATE BYPASS MODE      Y01156
SETRET   DS    0H                                                Y01156
         NI    RFLAGS,HFF-RFNOSKIP                               Y01156
         NI    PFLAGS3,HFF-PFONE                                 Y01156
*      UPDATE  TO NEXT PCE                                       Y01156
         BAL   LINK1,SCANDLSN          RESET BUFFER-SCAN PTRS    Y01156
         NOP   ZERO                    +0 RETURN                 Y01156
         TM    PFLAGS,PFLIST           WHEN PROCESSING A LIST    Y01156
         BZ    MSNGNXT                 BYPASS PCE UPDATE         Y01156
         CLI   ONE(XINPUT),RIGHTPRN    IS END OF LIST FOUND?     Y02666
         BNE   MSNGRET                 BYPASS PCE UPDATE         Y02666
         NI    PFLAGS,HFF-PFLIST       INDICATE END OF LIST      Y02666
MSNGNXT  DS    0H                                                Y02666
         MVC   PDWORD(TWO),PCELEN(XPCE) ALIGN PCE LENGTH         Y01156
         AH    XPCE,PDWORD             ADD TO GET NEXT PCE PTR   Y01156
MSNGRET  DS   0H                                                 Y01156
         MVI   RETCODE,RCNOPRMT        INDICATE PARSE RETURN CODE
         LA    R14,MSG2                INDICATE MESSAGE TO WRITE
         CLI   MSGCODE,MSG1            WAS AN 'ENTER' MSG SENT TO
*                                         PUTGET
         BE    ISSUEMSG                YES - THEN 'MISSING' MSG SHOULD
*                                         BE ISSUED - BRANCH
         SPACE
         LA    R14,MSG5                INDICATE MESSAGE TO WRITE
         TM    DATAFLA2,PRESENT        TEST TO SEE IF CURRENT PASSWORD
*                                      HAS BEEN PROCESSED      @Z40RPKQ
         BO    NEWMSNG                 IF YES, BRANCH TO COMPARE FOR
*                                       MISSING NEW PASSWORD   @Z40RPKQ
         CLI   MSGCODE,MSG15           IS A MISSING CURRENT
*                                      PASSWORD BEING PROMPTED FOR
*                                                              @Z40RPKQ
         B    MSGMSNGN                BRANCH TO CHECK FOR END OF MISS
*                                     ING PASSWORD MESSAGE     @Z40RPKQ
NEWMSNG  DS    0H                      * * * *                 @Z40RPKQ
         CLI   MSGCODE,MSG22          IS A MISSING NEW PASSWORD BEING
*                                     PROMPTED FOR             @Z40RPKQ
MSGMSNGN DS    0H                     * * * *                  @Z40RPKQ
         BNE   MSNGEND                 IF NO BRANCH - NO FURTHER MSGS.
*                                                                Y01156
         SPACE
*
* EITHER AN 'ENTER' OR AN 'ENTER PASSWORD FOR' MESSAGE WAS TO BE
* OUTPUTTED, IN WHICH CASE, A 'MISSING' OR A 'MISSING PASSWORD FOR'
* MESSAGE WILL BE OUTPUTTED.
*
*/*ISSUEMSG: P FIND MSG AND MSG ATTRIBUTES IN MSG CSECT */
ISSUEMSG DS    0H                      * * * *
         STC   R14,MSGCODE             INDICATE MESSAGE TO WRITE
         L     R15,ADRMSGC             GET ADDR OF MSG CSECT
         L     R14,ZERO(R14,R15)       GET ADDRESS OF MESSAGE
         LH    R15,ZERO(R14)           LOAD PROTOTYPE MESSAGE LENGTH
         SH    R15,H4                  COMPENSATE FOR HEADER
         L     R1,SEGLIST+TWELVE       LOAD PTR TO SECOND SEGMENT
         STH   R15,TWO(R1)             MODIFY THE OFFSET IN SEGMENT TWO
*                                         TO CORRESPOND TO MISSING MSG
         MVC   PLUSSEG+TWO(TWO),TWO(R1) USE SAME OFFSET FOR PLUS
*                                         SEGMENT
         SPACE
*
* LOOP THROUGH THE HELP MESSAGE SEGMENT LISTS REPLACING THE 'ENTER'
* MESSAGE ADDRESS WITH THE 'MISSING' MESSAGE ADDRESS. THIS IS THE ONLY
* CASE WHERE A INFORMATIONAL MESSAGE MAY HAVE ASSOCIATED HELP MESSAGES.
*
*/* P REPLACE 'ENTER' MSG ADDR IN HELP SEGMENTS WITH 'MISSING' ADDR */
         LA    R1,SEGLIST              LOAD PTR TO FIRST SEGMENT LIST
         SPACE
MSNGLOOP DS    0H                      * * * *
         CLC   ZERO(L'ENDCHAIN,R1),ENDCHAIN IS THIS LAST LEVEL MESSAGE
         BE    MSNGEXIT                IF YES BRANCH
         SPACE
         L     R1,ZERO(R1)             IF NO - LOAD PTR TO NEXT LEVEL
         ST    R14,TWELVE(R1)          STORE ADDRESS OF 'MISSING' MSG.
         B     MSNGLOOP                CONTINUE THROUGH HELP MESSAGES
         SPACE
MSNGEXIT DS    0H                      * * * *
*/*MSNGEXIT: D (YES,,NO,WRITER1C) ANY HELP MESSAGES ? */
*/* P (,WRITER1A) FORMAT THE HELP MESSAGES  */
         TM    PFLAGS,PFENDF                                     Y01156
         BZ    SETNEXT                                           Y01156
         LA    LINK1,CLEANUP           SET RETURN FROM WRITER1 TO
         B     MSNGCONT                CONTINUE                  Y01156
SETNEXT  DS    0H                                                Y01156
         LA    LINK1,NEXTPCE           SET RETURN FROM WRITER1 TO
*                                         NEXTPCE ROUTINE        Y01156
MSNGCONT DS    0H                                                Y01156
         CLC   SEGLIST(L'ENDCHAIN),ENDCHAIN WERE THERE ANY HELP MSGS.
         BE    WRITER1C                IF NO BRANCH
         SPACE
         MVC   PLUSSEG(L'H5),H5        INDICATE SEGMENT LENGTH
         MVI   PLUSSEG+FOUR,PLUS       PUT THE PLUS IN THE SEGMENT
         LA    R0,PLUSSEG              GET ADDRESS OF PLUS MSG SEGMENT
         ST    R0,SEGLIST+SIXTEEN      STORE AS THIRD SEGMENT OF
*                                         INFORMATIONAL MESSAGE
         LA    R15,THREE               TELL WRITER1 THREE SEGMENT MSG
         B     WRITER1A                WRITE THE MESSAGE AND EXIT
MSNGEND  DS    0H                                                Y01156
         TM    PFLAGS,PFENDF                                     Y01156
         BO    CLEANUP                                           Y01156
         B     NEXTPCE                                           Y01156
*/*IKJEFP00: END */
         EJECT
***********************************************************************
*                                                                     *
*                                 CONSTANT AREA                       *
*                                                                     *
***********************************************************************
         SPACE
*
* THE FOLLOWING TWO FIELDS MUST BE CONTIGUOUS.
*
LRPAREN  DC    C'( )'                  FOR NULL SUBFIELD
SLASHAST DC    CL2'/*'                 BEGIN COMMENT DELIMITER   Y02666
ASTSLASH DC    CL2'*/'                 END COMMENT DELIMITER     Y02666
*
         SPACE
*
* VARIOUS NUMERIC QUANTITIES.
*
H0       DC    H'00'                   USED TO COMPARE ZERO      Y02666
H8       DC    H'8'                    LENGTH OF ENTRY IN PUSH DOWN
*                                         STACK
*
H4       DC    H'4'                    TO USE AS A FOUR
*
H3       DC    H'3'                    USED TO OBTAIN VALIDITY CHECK
*                                         ROUTINE ADDRESS FROM PCE
*
H5       DC    H'5'                    TO OBTAIN NEW BUFFER OFFSET IN
*                                         EXIT ROUTINE
H12      DC    H'12'                   USED TO TEST FOR A VALIDITY
*                                         CHECK EXIT RETURN CODE
*                                         OF TWELVE
H16      DC    H'16'                   USED TO TEST RETURN CODES
H20      DC    H'20'                   USED TO TEST RETURN CODES
H24      DC    H'24'                   USED TO TEST RETURN CODES
H28      DC    H'28'                   USED TO TEST RETURN CODES
H32      DC    H'32'                   USED TO TEST RETURN CODES Y02666
DEC7     DC    H'7'                    TYPES OF ADDRESSES
DEC9     DC    H'9'                    * * * *
DEC32    DC    H'32'                   * * * *
DATALEN  DC    H'200'                  LENGTH OF INVALID DATA PRINTED
TWO55    DC    H'255'                  MAX. LENGTH FOR EXECUTE INSTR.
TWO56    DC    H'256'                  EXCEDES MAXIMUM NUMBER OF LEVELS
*                                         OF INDIRECT ADDRESSING BY ONE
*
CRMESS   DS    0H                       NEW LINE CHARACTER MSG   Y05020
*
CRLEN    DC    H'6'                     LENGTH                   Y05020
*
CROFF    DC    H'0'                     OFFSET                   Y05020
*
CRMSG    DC    X'4015'                  NEW LINE CHARACTER       Y05020
         SPACE
PSWDMSG  DS    0H                      PASSWORD OFFSET MSG       Y02666
         DC    H'27'                                             Y02666
         DC    H'30'                                             Y02666
         DC    CL23' -- PASSWORD PROCESSING'                     Y02666
*
* USED TO OBTAIN CORE TO BUILD HELP MESSAGE SEGMENTS.
*
LISTLEN  DC    0H'0'                   HALFWORD BOUNDARY ALIGNMENT
         DC    AL2(LENMLLST)           LENGTH OF MULTI-LEVEL ELEMENT
*                                         USED FOR GETMAIN
         SPACE
*
* VARIOUS INSTRUCTIONS THAT ARE 'EX'.
*
KEYWDCLC CLC   ZERO(*-*,R1),TEMPPDE    USED TO COMPARE NAME IN
*                                         IKJNAME PCE TO BUFFER DATA
*
NAMECOMP CLC   ONE(*-*,R1),ZERO(R15)   COMPARE ALIAS TO USER ENTERED
*                                      KEYWORD                   Y02666
NAMEMVC  MVC   TEMPPDE(*-*),PCENAMN(XPCE) MOVE NAME FROM PCE TO
*                                         WORKAREA
*
IOBMVC2  MVC   ONE(*-*,XINPUT),FOUR(R3) TO COPY DATA RECEIVED FROM
*                                         PROMPT TO PARSE STORAGE
*
CLEARXC  XC    ZERO(*-*,R1),ZERO(R1)   TO CLEAR ALLOCATED STORAGE
*
BUILDSEG MVC   FOUR(*-*,R1),ZERO(R15)  TO BUILD A MESSAGE SEGMENT
*
ERASEXC  XC    ZERO(*-*,R3),ZERO(R3)   TO ERASE POSITIONAL PDE
*
PDEXMV   MVC   ZERO(*-*,R3),TEMPPDE    TO COPY DATA FROM TEMPORARY PDE
*                                         TO USERS PDE
*
POSITXNC NC    ZERO(*-*,R3),ZERO(R3)   TO TEST FOR END OF PDE CHAIN
*
TYPETM   TM    ZERO(R15),*-*           TEST FOR CHARACTER TYPE
*
QSTRMVC  MVC   ZERO(*-*,XINPUT),ONE(XINPUT) USED TO REMOVE SECOND QUOTE
*                                         FROM QSTRING
KEYWDMVC MVC   KEYDATA+ONE(*-*),ZERO(R14) MOVE USER KEYWORD      Y01156
UIDMVC   MVC   ZERO(*-*,R1),ZERO(R3)   MOVE DSNAME WITH USERID   Y02666
         SPACE
*
* VARIOUS BIT CONFIGURATIONS USED AS MASKS. THEY MUST BE ON FULL WORD
* BOUNDARIES
*
TYPEMASK DC    0A(0)                   ALIGN ON FULL WORD BOUNDARY
         DC    X'000000E0'             USED TO SELECT TYPE INDICATOR
*                                         FROM PCE
*
EIGHTMAK DC    X'FFFFFFF8'             USED TO ROUND TO EIGHT
*
CLEARMK1 DC    X'000000FF'             USED IN STORAGE ALLOCATION RTN.
*
CLEARMK2 DC    X'FFFFFF00'             USED TO MASK REMAINDER LESS
*                                         THAN 256
*
SUBPOOLN DC    AL1(1,0,0,0)            SUBPOOL NUMBER USED TO FREE
*                                         PUTGETS BUFFERS --- THIS
*                                         CONSTANT IS ALSO USED TO
*                                         SET THE SPECIAL FLAG IN
*                                         XINPUT BY THE INVALID RTN.
SPLNGTH  DC    X'01000010'             CORE USED FOR EXPRESSION VALUE
*                                         PDE'S
         SPACE
*
* SUBPOOL NUMBER AND CHAINING OVERHEAD FOR GETMAIN IN STORAGE
* ALLOCATION SUBROUTINE.
*
SPOVRHD  DC    0A(0)                   ALIGN ON FULL WORD BOUNDARY
         DC    AL1(1,0,0,8)            SUBPOOL NUMBER AND OVERHEAD
         SPACE
*
* TABLE OF ADDRESSES FOR RESCANNING AFTER AN INVALID MESSAGE AND A
* PROMPT. THE INDEX VALUE TO THE APPROPRIATE ADDRESS IS IN PERRCODE.
*
RETRNTAB DC    0A(0)                   ALIGN ON FULL WORD BOUNDARY
         DC    A(DSNAMRSC)             PERRCODE = 0  DSNAME
         DC    A(NEXTPCE)              PERRCODE = 4  KEYWORDS
         DC    A(DSNPSRSC)             PERRCODE = 8  DSNAME PASSWORDS
         DC    V(ADDRERSC)             PERRCODE = 12 ADDRESS
         DC    A(VALUERSC)             PERRCODE = 16 VALUE
         DC    A(PSTRIRSC)             PERRCODE = 20 PSTRING
         DC    A(IDENTRSC)             PERRCODE = 24 IDENT
         DC    A(QSTRIRSC)             PERRCODE = 28 QSTRING
         DC    A(UIDPSRSC)             PERRCODE = 32 USERID PASSWORDS
         DC    A(USIDRSC)              PERRCODE = 36 USERID
         SPACE
*  TABLE OF ADDRESSES USED BY COBOL ROUTINES TO ENTER PARSE      F41448
*  SUBROUTINES TO ACCOMPLISH SPECIFIC FUNCTIONS IN THE SCAN      F41448
*  AND PROMPTING UNDER COBOL SYMBOLIC DEBUG                      F41448
         SPACE
QSTRINGA DC    A(QSTR01)               QSTRING ROUTINE ADDRESS   F41448
         DC    A(PROMPTQ)              PROMPT ROUTINE            F41448
         DC    A(POSITXCB)             ADD PDE TO PERM PDE       F41448
         DC    A(SYSR1)                WRITE INVALID MESSAGE     F41448
         DC    A(SKIPB)                SKIP BLANKS               F41448
         DC    A(RANGE)                RANGE DETERMINER          F41448
         DC    V(GENSCAN)              SCAN STRING ROUTINE       F41448
         DC    A(TYPETEST)             DETERMINE CHARACTER TYPE  F41448
         DC    V(TRANSQ)               TRANSLATE TO UPPERCASE    F41448
         DC    A(PSTRIMSG)             ENDING PAREN ASSUMED      F41448
         DC    A(LISTT)                LIST PROCESSOR            F41448
         DC    A(STALOC)               ALLOCTE STORAGE IN SBPL 1 F41448
         DC    A(SCANF)                POP THE STACK             F41448
         DC    A(GETCORE)              GET CORE WHICH WILL BE    F41448
*                                      RELEASE BEFORE EXIT       F41448
         DC    A(NAMESKP3)             SKIP TO THE NEXT  PCE     F41448
         DC    A(CLEANUP)              FREE CORE, DELETE MODULES F41448
*                                      EXIT                      F41448
         DC    A(PUSHI)                PUSH THE STACK            F41448
         DC    A(PARS2ENT)             ENTRY POINT FROM IKJPARS2 F41448
*                                      WHEN SUBROUTINE FUNCTIONS F41448
*                                      REQUIRED                  F41448
         DC    A(NEXTPCE)              GOTO NEXT PCE ROUTINE     F41448
MAXBLKSZ DC    F'248'                  BLOCK SIZE FOR GETMAINS BY
*                                         STORAGE ALLOCATION ROUTINE
         SPACE
ADRMSGC  DC    A(IKJEFP10)             ADDRESS OF MESSAGE CSECT
ADPOSIT  DC    A(POSITX1)                                        Y02666
ADDRP    DC    A(IKJEFP03)             ADDRESS OF ADDRESS PCE PROCESSOR
*                                                               Y30NQJN
         SPACE
ENDCHAIN DC    XL4'FF000000'           LAST ELEMENT INDICATOR FOR
*                                         CHAINS CONSTRUCTED WITHIN
*                                         PROGRAM
         SPACE
*
* CONTROL INFORMATION FOR GENSCAN WHEN SCANNING FOR A DSNAME
* QUALIFIER, MEMBER NAME, OR COMMAND NAME.
*
DSNCNTL  EQU   *                       * * * *
JOBNCNTL EQU   *                       JOB NAME CONTROL DATA     Y02666
JOBIDCTL EQU   *                       JOB ID   CONTROL DATA     Y02666
MEMBCNTL EQU   *                       * * * *
         DC    X'40'                   ASTERISK NOT ALLOWED, MAXIMUM
*                                         LENGTH SPECIFIED
         DC    X'01'                   FIRST CHARACTER MUST BE
*                                         ALPHABETIC
         DC    X'03'                   OTHER CHARACTERS MUST BE
*                                         ALPHAMERIC
         DC    X'08'                   MAXIMUM LENGTH = 8
         SPACE
*
*
* CONTROL INFORMATION FOR GENSCAN WHEN SCANNING FOR A PASSWORD
*
*
PWSYNTAX EQU   *                       * * * *                   A45306
         DC    X'40'                   ASTERISK NOT ALLOWED, MAXIMUM
*                                         LENGTH SPECIFIED       A45306
*                                         LENGTH SPECIFIED       A45306
         DC    X'00'                   FIRST CHARACTER MUST BE   Y02666
*                                         ANY,ANY                Y02666
         DC    X'03'                  OTHER CHARACTERS MUST BE
*                                         ALPHAMERIC           @Z40RPKQ
         DC    X'08'                   MAXIMUM LENGTH = 8        A45306
         SPACE
*
* CONTROL INFORMATION FOR GENSCAN WHEN SCANNING FOR A USERID
*
USIDCNTL EQU   *                       * * * *
         DC    X'40'                   ASTERISK NOT ALLOWED, MAXIMUM
*                                         LENGTH SPECIFIED
         DC    X'01'                   FIRST CHARACTERS MUST BE
*                                         ALPHABETIC
         DC    X'03'                   OTHER CHARACTERS MUST BE
*                                         ALPHANUMERIC
         DC    X'07'                   MAXIMUM LENGTH = 7
         SPACE
*
*CONTROL INFORMATION FOR GENSCAN WHEN SCANNING FOR A VOLUME SERIAL NAME
*
VOLSERC  EQU   *                       * * * *                   Y02666
         DC    X'40'                   ASTERISK NOT ALLOWED, MAXIMUM
*                                         LENGTH SPECIFIED       Y02666
         DC    X'03'                   FIRST CHARACTERS MUST BE
*                                         ALPHANUMERIC           Y02666
         DC    X'03'                   OTHER CHARACTERS MUST BE
*                                         ALPHANUMERIC           Y02666
         DC    X'06'                   MAXIMUM LENGTH = 6        Y02666
         SPACE
*
* CONTROL INFORMATION FOR GENSCAN WHEN SCANNING FOR A DSTHING
*
DSTCNTL  EQU   *                       * * * *
         DC    X'C0'                   ASTERISK ALLOWED, MAXIMUM
*                                         LENGTH SPECIFIED
         DC    X'01'                   FIRST CHARACTER MUST BE
*                                         ALPHABETIC
         DC    X'03'                   OTHER CHARACTERS MUST BE
*                                         ALPHAMERIC
         DC    X'08'                   MAXIMUM LENGTH = 8
         SPACE
*
* CONTROL INFORMATION FOR GENSCAN WHEN SCANNING FOR A KEYWORD
*
KEYSYNTX EQU   *                       * * * *
         DC    X'40'                   ASTERISK NOT ALLOWED, MAXIMUM
*                                         LENGTH SPECIFIED
         DC    X'01'                   FIRST CHARACTER MUST BE
*                                         ALPHABETIC
         DC    X'03'                   OTHER CHARACTERS MUST BE
*                                         ALPHAMERIC
         DC    X'1F'                   MAXIMUM LENGTH = 31
         SPACE
*
* L FORM OF I/O SERVICE ROUTINE MACROS.
*
LPUTLINE PUTLINE ,MF=L                 * * * *
         SPACE
LPLEND   EQU   *                       USED TO GET LENGTH OF LPUTLINE
         SPACE
LPUTGET  PUTGET ,MF=L                  * * * *
         SPACE
LPGEND   EQU   *                       USED TO GET LENGTH OF LPUTGET
         SPACE
AGENSCAN DC    V(GENSCAN)              ADDRESS OF GENSCAN ROUTINE
*                                         CONTAINED IN IKJEFP20
ATRANSQ  DC    V(TRANSQ)               ADDRESS OF TRANSLATE ROUTINE
*                                         CONTAINED IN IKJEFP20
ATRTAB   DC    A(TRTAB)                ADDRESS OF TABLE USED BY
*                                         TYPETEST IN SYNTAX CHECKING
*                                         CONTAINED IN IKJEFP20
AUPTAB   DC    A(UPPERTAB)             ADDRESS OF TABLE USED TO
*                                         TRANSLATE DATA TO UPPERCASE
*                                         CONTAINED IN IKJEFP20
         EJECT
UPT      IKJUPT
         EJECT
ECT      IKJECT
         EJECT
PWORK    IKJEFPWA
         EJECT
***********************************************************************
*                                                                     *
*                            RECURSIVE WORKSPACE                      *
*                                                                     *
***********************************************************************
         SPACE
RWORK    DSECT
         SPACE
RPCEAD   DS    A                       ADDRESS OF SUBFIELD PCE
         SPACE
RBASESV  DS    A                       BACK CHAIN TO PREVIOUS RWORK
         SPACE
RXPCESV  DS    A                       RESUME PCE ADDRESS WHEN GO BACK
         SPACE
RLINKSV  DS    A                       RETURN ADDRESS FROM RECURSE
         SPACE
RKEYSV   DS    A                       STARTING KEYWORD ADDRESS
         SPACE
RLINKSV1 DS    A                       SAVE LINKAGE DURING ERASE
         SPACE
RFLAGS   DS    X                       FLAG BYTE
         SPACE
RWORKSZ  EQU   *-RWORK                 RECURSIVE WORKSPACE LENGTH
         EJECT
***********************************************************************
*
*    THE FOLLOWING DATA AREAS ARE USED IN ASSISTING IN DETERMINING WHEN
*    TO PROMPT THE USER FOR ADDITIONAL OR MISSING INFORMATION.   Y02666
*
***********************************************************************
IOSRL    DSECT
IOSTELM  DS    A                       TOP STACK ELEMENT PTR     Y02666
IOSBELM  DS    A                       BOTTOM ELEMENT PTR        Y02666
*
*
INSTACK  DSECT
INSCODE  DS    X                      INSTORAGE STACK FLAGS      Y02666
         END
