         TITLE 'IEECVFTG           CLEANUP MODULE'
IEECVFTG CSECT
*C138500,139000                                               MH Y01274
*C138500,153500,155000                                       MC SA52539
*C140000,144500                                              MC SA52721
*D170500                                                     MC SA52721
*/*IEECVFTG: CHART */
*/*%START: E (,BEGIN) IEECVFTG */
         SPACE 2
* THIS ROUTINE WAS CREATED FOR STATUS DISPLAY SUPPORT, LINE ITEM 21002,
*    OS RELEASE 21
         SPACE 2
* STATUS -- CHANGE LEVEL 0
*
* FUNCTION -- CLEANUP ROUTINE WHEN DEVICE CHANGES STATUS
*    1) DEVICE IS BEING CLOSED - FREES ALL MESSAGES ON QUEUE
*    2) DEVICE IS CHANGING USE TO
*       A) MESSAGE STREAM - FREES OUT OF LINE MESSAGES
*       B) STATUS DISPLAY - FREES INLINE AND OUT OF LINE MSGS
*       C) FULL CAPABILITY - FREES OUT OF LINE MESSAGES
*    3) DEVICE IS RECOVERING FROM AN ASYNCHRONOUS ERROR - FREES
*       OUT OF LINE MESSAGES, LEAVING ANY MONITOR GOING, AND
*       LEAVING AREA DEFINITION ALONE
*    4) WHENEVER OUT OF LINE MSGS ARE FREED, EXCEPT ON
*       ASYNCHRONOUS ERROR, ANY DYNAMIC DISPLAY IS STOPPED,
*       ANY GETMAINED SACB IS FREED, AND THE AREA DEFINITION IS
*       RESET TO SYSGEN VALUE
*
* ENTRY POINT -- IEECVFTG
*
* INPUT
*    1) REGISTER 1 - POINTER TO CXSA
*
* OUTPUT
*    1) REGISTER 1 - POINTER TO CXSA
*
* EXTERNAL REFERENCES -- FREEMAIN, SVC 34
*
* EXITS,NORMAL
*    1) IEECVET1 - PROCESSOR 1, IF HANDLING CLOSE
*    2) IEECVETC - ASYNCHRONOUS ERROR, IF HANDLING A CHANGE IN
*       STATUS OR AN ASYNCHRONOUS ERROR
*
* EXITS,ERROR
*    IEECVET1 - PROCESSOR 1
*
* TABLES/WORK AREAS
*    1) UNIT CONTROL MODULE (UCM)
*    2) TRANSIENT PORTION OF THE DISPLAY CONTROL MODULE (DCM)
*    3) RESIDENT PORTION OF THE DISPLAY CONTROL MODULE
*       (INCLUDING SCREEN AREA CONTROL BLOCKS - SACB'S)
*
* ATTRIBUTES -- REFRESHABLE, PRIVILEGED, TYPE 4 SVC
*    DISABLED WHEN DECREMENTING USE COUNTS OF MINOR WQE'S
*
* CHARACTER CODE DEPENDENCY -- THE OPERATION OF THIS MODULE DOES
*    NOT DEPEND ON A PARTICULAR INTERNAL REPRESENTATION OF THE
*    EXTERNAL CHARACTER SET
         EJECT
* REGISTER USAGE
X1PARM   EQU   1
XERTRN   EQU   14
XFBRANCH EQU   15
R0       EQU   0                   REG 0
R1       EQU   1                   REG 1
WORKR    EQU   1                   WORK REG
WORK2    EQU   2                   WORK REG
WORK3    EQU   3                   WORK REG
WORK4    EQU   4                   WORK REG
WORK1    EQU   5                   WORK REG
RDCMBASE EQU   6                   RESIDENT PORTION OF DCM BASE
SACBBASE EQU   7                   SCREEN AREA CONTROL BLOCK BASE
X7ASCB   EQU   7                   ASCB ADDRESS FOR FREEMAIN  MB YM4086
TDCMBASE EQU   8                   TRANSIENT PORTION OF DCM BASE
OUTQREG  EQU   9                   POINTER TO CONSOLE OUTPUT           X
                                        QUEUE ENTRY
UCMEBASE EQU   10                  UCM ENTRY BASE
WQEBASE  EQU   11                  WQE BASE
MYBASE   EQU   12                  BASE REG FOR THIS MODULE
CXSABASE EQU   13                  CXSA BASE
RETURNR  EQU   14                  RETURN REG
LINKR    EQU   14                  FIRST LEVEL LINK REG
LINK1    EQU   15                  SECOND LEVEL LINK REG
R15      EQU   15                  XCTL REG
         EJECT
*/*BEGIN: P ESTABLISH ADDRESSABILITY */
         SPACE
         BALR  MYBASE,E0           BASE
         USING *,MYBASE                 THIS MODULE
         B     BEGIN               BRANCH AROUND PATCH AREA
ICATCH   DC    C'IEECVFTG'         EYECATCHER AND FIELD MAINTENANCE
         DC    CL8'&SYSDATE',CL56' '
BEGIN    EQU   *
         LR    CXSABASE,R1         GET CXSA ADDRESS
         USING CXSA,CXSABASE       BASE CXSA
         L     UCMEBASE,CSAUCM     GET ADDRESS OF UCM ENTRY
         USING UCMLIST,UCMEBASE    BASE UCM ENTRY
         L     RDCMBASE,UCMXB      GET ADDRESS OF RESIDENT DCB
         USING DCMTSRT,RDCMBASE      BASE RESIDENT DCM
         L     TDCMBASE,DCMADTRN   GET ADDRESS OF TRANSIENT DCM
         USING DCMSTRT,TDCMBASE      BASE TRANSIENT DCM
         USING DCMACB,SACBBASE     BASE SACB'S
         USING WQE,WQEBASE         BASE WQE'S
         MVC   DCMTRACE(DCMTRLEN),DCMTRAC2 SHIFT OLD TRACE ENTRIES
         MVI   DCMTREN1,ID1        PUT CSECT ID INTO
         MVI   DCMTREN2,ID2        NEW TRACE ENTRY
         L     XFBRANCH,CSAXB      ADDRESS GETLOCK SUBROUTINE
         LR    X1PARM,CXSABASE     PASS CXSA ADDRESS IN REG 1
         BALR  XERTRN,XFBRANCH     OBTAIN LOCKS
         SPACE 3
* INITIALIZATION
         SPACE
         MVI   DCMUTILT,E0         ZERO OUT UTILITY BYTE
*    THE UTILITY BYTE IS USED AS FOLLOWS IN THIS MODULE:
*    DCMUTILA -- INDICATES FREE INLINE MESSAGES
*    DCMUTILC -- INTERRUPTS HAVE BEEN DISABLED
         EJECT
* TEST TYPE OF CLEAN-UP REQUIRED
* 1) OUT OF LINE MESSAGES ARE ALWAYS FREED
* 2) INLINE MESSAGES ARE FREED WHEN DEVICE IS CLOSING OR
*    CHANGING TO STATUS DISPLAY USE
         SPACE 2
TESTTYPE EQU   *
*/*TESTTYPE: D (YES,%INDFRIN,NO,TEST2) CLOSE IN PROGRESS */
         TM    DCMR3FLG,DCMCLPR    Q. CLOSE IN PROGRESS
         BNO   TEST2               NO, GO TO NEXT TEST
*/*%INDFRIN: P (,STOPMN) INDICATE FREE INLINE MESSAGES */
         OI    DCMUTILT,DCMUTILA   CLOSE - INDICATE FREE INLINE        X
                                        MESSAGES
         B     SACBSRCH            GO STOP ANY MONITOR
         SPACE
TEST2    EQU   *
*/*TEST2: D (YES,%TSTSD,NO,TEST3) STATUS SWITCH */
         TM    DCMCS,DCMCSO        Q. STATUS SWITCH
         BNO   TEST3               NO, GO TO NEXT TEST
*/*%TSTSD: D (YES,%INDFRIN,NO,STOPMN) TO STATUS DISPLAY */
         TM    UCMDISP,UCMDISPG    Q. TO STATUS DISPLAY
         BNO   SACBSRCH            NO, GO STOP ANY MONITOR
         OI    DCMUTILT,DCMUTILA   TO SD - INDICATE FREE INLINE        X
                                        MESSAGES
         B     SACBSRCH            GO STOP ANY MONITOR
         SPACE
TEST3    EQU   *
*/*TEST3: D (YES,SACBSRCH,NO,PROC1EXT) ASYNCHRONOUS ERROR */
         TM    DCMCOM2,DCMAE       Q. ASYNCHRONOUS ERROR
         BO    SACBSRCH            YES, GO SEARCH SACB'S
         SPACE
         B     PROC1EXT            NO, THIS CONDITION SHOULD
*                                       NEVER OCCUR - MODULE WAS
*                                       ENTERED WITHOUT REASON.
*                                       GO TO PROCESSOR 1
         EJECT
SACBSRCH EQU   *
* THE SACB'S ARE SEARCHED AND HANDLED AS FOLLOWS:
* 1) ANY WQE'S FOR OUT OF LINE DISPLAYS NOT COMPLETELY OUTPUT
*    ARE FREED
* 2) ALL SACB'S ARE CLEANED UP
* 3) EXCEPT ON HANDLING AN ASYNCHRONOUS ERROR
*    A) RESIDENT SACB'S ARE SET TO SYSGEN VALUES
*    B) ANY GETMAINED SACB'S ARE FREED
* 4) ON AN ASYNCHRONOUS ERROR
*    A) SET UP FOR ANY MONITOR TO CONTINUE
         SPACE
*    WORK REGISTERS ARE USED AS FOLLOWS DURING THE SACB SEARCH
*        WORKR TEMPORARY USE ONLY
*        WORK1 SAVES SACB PTR WHEN WORKING WITH GETMAINED SACB'S
*        WORK2 PREVIOUS SACB POINTER
*        WORK3 LINE COUNTER TO FIND TOP LINE OF AREA
*        WORK4 TEMPORARY USE ONLY
         SPACE 2
*/*SACBSRCH: P (,SACBLOOP) INITIALIZE FOR SACB SEARCH */
         LH    WORK3,DCMMSGAL      GET NO. OF LINES IN MSG AREA
         LA    WORK3,E1(WORK3)     INCREASE NO. OF LINES BY ONE
         SR    WORK2,WORK2         CLEAR WORK2
         SR    WORK1,WORK1         CLEAR WORK1
         L     SACBBASE,DCMADSDS   GET POINTER TO FIRST SACB
SACBLOOP EQU   *
*/*SACBLOOP: D (YES,%TSTDEF,NO,ENDSACBS) ANY MORE SACB'S */
         LTR   SACBBASE,SACBBASE   ANY MORE SACB'S
         BZ    ENDSACBS            NO, BRANCH OUT OF SACB SEARCH
*/*%TSTDEF: D (YES,AREADEF,NO,%TSTAE1) AREA DEFINED HERE */
         TM    DCMASACB,DCMAUSE    Q. AREA DEFINED HERE
         BO    AREADEF             YES, CLEAN UP SACB
*/*%TSTAE1: D (YES,ENDSACBS,NO,TSTGM) HANDLING ASYNCHRONOUS ERROR */
         TM    DCMCOM2,DCMAE       Q. ASYNCHRONOUS ERROR
         BO    ENDSACBS            YES, GET OUT OF SACB SEARCH
         B     TSTGM               NO, GO REINITIALIZE AREA TO         X
                                        SYSGEN DEFINITION
AREADEF  EQU   *
*/*AREADEF: P (,AFTFREE1) FREE ANY WQE'S FOR ANY DISPLAY IN THE AREA */
         L     WQEBASE,DCMATECB    STOP TRACK ECB             MB YM4086
         LTR   WQEBASE,WQEBASE     ANY ECB TO POST            MB YM4086
         BZ    NOPOST              NO, DONT POST              MB YM4086
         TM    E0(WQEBASE),X'40'   ALREADY POSTED             MB YM4086
         BZ    POST                NO, POST IT                MB YM4086
         XC    E1(E3,WQEBASE),E1(WQEBASE) ZERO COMPLETION CODE
         B     NOPOST              DONT POST                  MB YM4086
POST     SR    UCMEBASE,UCMEBASE   ZERO COMPLETION CODE       MB YM4086
         STM   MYBASE,CXSABASE,DCMDSAV SAVE REGS 12 AND 13    MB YM4086
         L     15,CVTPTR           BASE CVT                   MB YM4086
         USING CVTMAP,15
         L     15,CVT0PT01         POST ENTRY POINT           MB YM4086
         DROP  15
         BALR  14,15               POST TRACK ECB             MB YM4086
         LM    MYBASE,CXSABASE,DCMDSAV RESTORE REGS           MB YM4086
         L     UCMEBASE,CSAUCM     RESTORE UCME BASE          MB YM4086
NOPOST   EQU   *
         TM    DCMAFLG1,DCMADISP   Q. DISPLAY IN AREA
         BNO   AFTFREE1            NO, BRANCH AROUND FREEING
         TM    DCMAFLG2,DCMAMJFR   Q. IS MAJOR FREED
         BO    AFTFREE1            YES, BRANCH AROUND FREEING
         L     OUTQREG,DCMAMJWQ    GET OUTPUT QUEUE POINTER
         USING CQE,OUTQREG
         TM    DCMAFLG1,DCMADEND   Q. END OF DISPLAY ON SCREEN
         BNO   FINDNEXT            NO, GO FREE REMAINING MINORS
         LA    LINKR,AFTFREE1      YES, GO FREE MAJOR ONLY AND
         B     FREEMAJ                  RETURN TO AFTFREE1
         SPACE 2
FINDNEXT EQU   *
*    FIND NEXT MINOR TO BE OUTPUT
         TM    CQEFLAG,CQEATTOP    SHOULD MINOR SEARCH                 X
                                        BEGIN AT TOP OF CHAIN
         BNO   GETSAVD1            NO, GO GET MINOR PTR SAVED
         LA    LINKR,AFTFREE1      YES, GO FREE MAJOR AND MINORS
         B     FREEMINT                 AND RETURN TO AFTFREE1
         SPACE
GETSAVD1 EQU   *
         L     WQEBASE,DCMAMIN     GET MINOR POINTER SAVED
         TM    DCMAFLG2,DCMALMIN   Q. LAST MINOR OUTPUT SAVED
         BNO   TSTZERO1            NO, GO CHECK POINTER
         BAL   LINKR,GETNEXT       GET POINTER TO NEXT MINOR           X
                                        TO BE OUTPUT
         LA    LINKR,AFTFREE1      YES, GO FIND NEXT MINOR TO BE
         B     GETNEXT                  OUTPUT, FREE MAJOR AND         X
                                        MINORS, AND RETURN TO          X
                                        AFTFREE1
TSTZERO1 EQU   *
         LTR   WQEBASE,WQEBASE     Q. ANY POINTER SAVED
         BNZ   USESAVD1            YES, GO START FROM POINTER          X
                                        SAVED
         LA    LINKR,AFTFREE1      NO, GO FREE MAJOR, AND MINORS
         B     FREMLWTO                 IF ANY,  AND RETURN TO         X
                                        AFTFREE1
         SPACE
USESAVD1 EQU   *
         BAL   LINKR,FREEMIN       GO FREE MAJOR, AND MINORS           X
                                        STARTING FROM PTR SAVED
         EJECT
AFTFREE1 EQU   *
*/*AFTFREE1: D (YES,AECLEAN,NO,TSTGM) HANDLING ASYNCHRONOUS ERROR */
         TM    DCMCOM2,DCMAE       Q. ASYNCHRONOUS ERROR
         BO    AECLEAN             YES, CLEAN UP SACB, BUT LEAVE       X
                                        AREA DEFINITION ALONE
TSTGM    EQU   *
*/*TSTGM: D (YES,GMSACB,NO,RESSACB) GETMAINED SACB */
         TM    DCMASACB,DCMAGM     Q. GETMAINED SACB
         BO    GMSACB              YES, GO FREE SACB
         SPACE 2
RESSACB  EQU   *                   HANDLE RESIDENT SACB'S
* 1) IF MESSAGE STREAM CONSOLE, UNDEFINE ALL AREAS
* 2) OTHERWISE, REINITIALIZE SACB'S TO SYSGEN VALUES
*/*RESSACB: D (YES,UNDEFINE,NO,%INSACB) MESSAGE STREAM CONSOLE */
         TM    UCMDISP,UCMDISPF    Q. MESSAGE STREAM CONSOLE
         BO    UNDEFINE            YES, GO UNDEFINE AREA
*    REINITIALIZE SACB TO SYSGEN VALUES
*/*%INSACB: P (,%TSTTOP) REINITIALIZE SACB TO SYSGEN VALUES */
         LR    WORKR,SACBBASE      GET SACB ADDRESS
         SH    WORKR,DCMACB-HALFWORD  SUBTRACT LENGTH OF PREFIX        X
                                        TO GET PREFIX ADDRESS
         USING DCMPACB,WORKR       BASE PREFIX
         LH    WORK4,DCMPLN        GET SYSGEN'D AREA LENGTH
         STH   WORK4,DCMALN             STORE IN SACB
         DROP  WORKR
         OI    DCMASACB,DCMAUSE    INDICATE AREA DEFINED
         SR    WORK3,WORK4         CALCULATE TOP LINE OF AREA
         LTR   WORK3,WORK3         Q. IS TOP LINE ON SCREEN
         BNP   SHRINK              NO, GO SHRINK AREA
*/*%TSTTOP: D (YES,SHRINK,NO,NEXTSACB) TOTAL AREAS GREATER THAN MSG
*/*AREA SIZE  */
         STC   WORK3,DCMATOP       STORE TOP LINE NO IN SACB  MH Y01274
STORTOP  MVC   DCMTOPAR(E1),DCMAID SAVE AREA ID TO EVENTUALLY MH Y01274
*                                       HAVE ID OF TOP AREA
SAVESACB LR    WORK2,SACBBASE      SAVE SACB ADDRESS         MC SA52721
         XC    DCMAROW(DCMACBND-DCMAROW),DCMAROW  ZERO OUT SACB
         B     NEXTSACB            GO GET NEXT SACB
         SPACE
UNDEFINE EQU   *
*/*UNDEFINE: P (,NEXTSACB) INDICATE THIS SACB NOT IN USE */
         NI    DCMASACB,XFF-DCMAUSE  INDICATE THIS SACB NOT            X
                                        IN USE
         MVI   DCMTOPAR,E0         INDICATE NO AREAS DEFINED
         B     SAVESACB            GO SAVE SACB ADDR         MC SA52721
         SPACE 2
SHRINK   EQU   *
*/*SHRINK: P (,ENDSACBS) SHRINK TOP AREA */
* THE NEED FOR SHRINKING WOULD ARISE ONLY IF A CONSOLE HAS BEEN
* SYSGEN'D WITH USE=SD AND AREAS DEFINED FOR THE ENTIRE SCREEN
* AND IS NOW BEING VARY'D TO FC.  SINCE A MS MESSAGE AREA IS
* NEVER MORE THAN 4 LINES LARGER THAN A FC MESSAGE AREA, THIS
* CORRECTION CAN ALWAYS BE MADE BY EITHER SHRINKING OR
* UNDEFINING ONLY THE TOP AREA
         MVI   DCMATOP,E1          PUT TOP LINE AT TOP                 X
                                        OF MESSAGE AREA
         LA    WORKR,E1            CALCULATE AMOUNT OVER
         SR    WORKR,WORK3              MESSAGE AREA SIZE
*      WORK4 STILL CONTAINS THE SYSGENED LENGTH
         SR    WORK4,WORKR         CALCULATE NEW LENGTH
         STH   WORK4,DCMALN        STORE NEW LENGTH
         CLI   DCMALN+E1,E4        Q. IS LENGTH OK
         BNL   STORTOP             YES, GO TO SAVE TOP       MC SA52539
         NI    DCMASACB,XFF-DCMAUSE   UNDEFINE AREA SINCE              X
                                        LENGTH IS LESS THAN MINIMUM
         B     STORTOP             GO TO SAVE TOP            MC SA52539
         SPACE 2
GMSACB   EQU   *
*/*GMSACB: S (,%NXTSACB) FREEMAIN:FREE THE SACB */
         LTR   WORK1,WORK1         Q. FIRST GETMAINED SACB
         BNZ   FREESACB            NO, GO FREE SACB
         LTR   WORK2,WORK2         Q. ANY RESIDENT SACB'S
         BZ    NOAREAS             NO, GO INITIALIZE FOR NO AREAS
         XC    DCMACBNX-DCMACB(E4,WORK2),DCMACBNX-DCMACB(WORK2)        X
                                        ZERO OUT CHAIN FIELD OF        X
                                        LAST RESIDENT SACB
         B     FREESACB            GO FREE SACB
NOAREAS  EQU   *
         ST    WORK2,DCMADSDS      ZERO OUT POINTER TO FIRST           X
                                        SACB
         MVI   DCMTOPAR,E0         ZERO OUT TOP AREA DEFINED ID
FREESACB EQU   *
         L     WORK1,DCMACBNX      SAVE CHAIN FIELD
         ST    WORK3,DCMDSAV       SAVE LINE COUNTER          MB YM4086
         LR    X1PARM,SACBBASE     AREA TO FREE               MB YM4086
         L     XFBRANCH,CSACTLM    BASE UCM BASE PORTION      MB YM4086
         USING UCM,XFBRANCH        DECLARE ADDRESSABILITY     MB YM4086
         LA    R0,DCMACBSZ         SACB SIZE                  MB YM4086
         L     X7ASCB,UCMASCB      ASCB FOR FREEMAIN          MB YM4086
         L     WORK4,UCMPXA        ADDRESS TCB                MB YM4086
         DROP  XFBRANCH                                       MB YM4086
         FREEMAIN RC,SP=SP241,LV=(0),A=(1),BRANCH=YES
         L     WORK3,DCMDSAV       RESTORE LINE COUNTER       MB YM4086
*/*%NXTSACB: P (,SACBLOOP) GET POINTER TO NEXT SACB */
         LR    SACBBASE,WORK1      BASE NEXT SACB
         B     SACBLOOP            GO LOOK AT NEXT SACB
         SPACE 2
AECLEAN  EQU   *
*/*AECLEAN: P (,NEXTSACB) CLEAN UP THE SACB, SAVING THE MSG TYPE FLAGS
*/*FOR ANY MONITOR */
         XC    DCMAROW(DCMACBND-DCMAROW),DCMAROW  ZERO OUT SACB
         SPACE 2
NEXTSACB EQU   *
*/*NEXTSACB: P (,SACBLOOP) GET POINTER TO NEXT SACB */
         L     SACBBASE,DCMACBNX   GET PTR TO NEXT SACB
         B     SACBLOOP            GO LOOK AT NEXT SACB
         EJECT
ENDSACBS EQU   *
*/*ENDSACBS: P (,%TOPDS) REINITIALIZE POINTER TO END OF VIEWABLE MSG
*/*AREA */
         MVC   DCMWTBUF(E4),DCMWTINT  REINITIALIZE POINTER TO          X
                                             END OF VIEWABLE MSG AREA
*/*%TOPDS: P (,QSRCH) INDICATE NO DISPLAYS ON SCREEN */
         MVI   DCMTOPDS,E0         ZERO OUT ID OF TOP DISPLAY
         B     QSRCH               GO SEARCH CONSOLE Q
         EJECT
QSRCH    EQU   *
         SPACE
*    THE ENTIRE CONSOLE OUTPUT QUEUE IS SEARCHED.  ALL OUT OF
* LINE MLWTO'S IN PROGRESS HAVE ALREADY BEEN FREED BY THE
* SACBSRCH ROUTINE.  ANY OUT OF LINE MESSAGES STILL ON THE QUEUE
* ARE FREED.  IF INDICATED, INLINE MESSAGES ARE ALSO FREED.
         SPACE
*/*QSRCH: D (YES,ENTRYFND,NO,ENDOFQ) ANYTHING ON QUEUE */
         L     OUTQREG,UCMOUTQ     GET CONSOLE OUTPUT Q POINTER
         LTR   OUTQREG,OUTQREG     Q. ANYTHING ON QUEUE
         BZ    ENDOFQ              NO, GO HANDLE END OF Q
TESTLAST EQU   *
         TM    CQEFLAG,CQEENTR     Q. ENTRY
         BO    ENTRYFND            YES, GO LOOK AT ENTRY
         TM    CQEFLAG,CQEEOB      Q. END OF BLOCK
         BO    EOB                 YES, GO GET NEXT BLOCK
NXTENTRY EQU   *
*/*NXTENTRY: D (YES,ENTRYFND,NO,ENDOFQ) ANYTHING ELSE ON QUEUE */
         TM    CQEFLAG,CQEEOQ      Q. END OF QUEUE
         BO    ENDOFQ              YES, GO HANDLE END OF Q
         LA    OUTQREG,E4(OUTQREG) LOOK AT NEXT ENTRY
         B     TESTLAST            CHECK FOR LAST ENTRY
         SPACE
EOB      L     OUTQREG,CQEWQE      GET POINTER TO NEXT BLOCK
         B     TESTLAST            TEST NEXT CONSOLE Q ENTRY
         SPACE 2
ENDOFQ   EQU   *
*/*ENDOFQ: P TURN OFF OUT OF LINE OUTPUT PENDING FLAG */
         NI    UCMSDS5,XFF-UCMSDS5C  TURN OFF OUT OF LINE OUTPUT       X
                                        PENDING FLAG
*/*%TSTIN: D (YES,%OFFIN,NO,LEAVE1) WERE INLINE MESSAGES FREED */
         TM    DCMUTILT,DCMUTILA   Q. INLINE MESSAGES FREED
         BNO   LEAVE1              NO, LEAVE MODULE
*/*%OFFIN: P (,LEAVE1) TURN OFF INLINE OUTPUT PENDING FLAG */
         NI    UCMSDS5,XFF-UCMSDS5B  TURN OFF INLINE OUTPUT            X
                                        PENDING FLAG
LEAVE1   EQU   *
*/*LEAVE1: D (YES,LEAVE,NO,%OFFOP) IS ANY OUTPUT PENDING */
         TM    UCMSDS5,UCMSDS5B+UCMSDS5C  Q. IS EITHER OUTPUT          X
                                        PENDING FLAG ON
         BNZ   LEAVE               YES, EXIT
*/*%OFFOP: P (,LEAVE) TURN OFF OUTPUT PENDING FLAG */
         NI    UCMSTS,XFF-UCMPF    NO, TURN OFF OUTPUT PENDING
LEAVE   EQU   *
*/*LEAVE: D (YES,PROC1EXT,NO,AEEXT) CLOSE IN PROGRESS */
         TM    DCMR3FLG,DCMCLPR    Q. CLOSE IN PROGRESS
         BO    PROC1EXT            YES, GO TO PROCESSOR 1
         B     AEEXT               OTHERWISE EXIT TO ASYCHRONOUS       X
                                        ERROR ROUTINE
         EJECT
ENTRYFND EQU   *
*/*ENTRYFND: D (YES,,NO,REGWQE)   MLWTO */
         TM    CQEWQE,CQEMAJOR     Q. MLWTO
         BNO   REGWQE              NO, GO HANDLE REGULAR WQE
*/*%TST3: D (YES,,NO,INMLWTO) DESCRIPTOR CODES 8 AND 9 */
         L     WQEBASE,CQEWQE      GET POINTER TO MAJOR WQE
         TM    WMJMCS1,WMJMCS1A    Q. ROUTING OR DESCRIPTOR            X
                                        CODES PRESENT
         BNO   INMLWTO             NO, GO HANDLE INLINE MLWTO
         TM    WMJMDEC1,WMJMDECH   Q. DESCRIPTOR CODE 8
         BNO   INMLWTO             NO, GO HANDLE INLINE MLWTO
         TM    WMJMDEC2,WMJMDECI   Q. DESCRIPTOR CODE 9
         BNO   INMLWTO             NO, GO HANDLE INLINE MLWTO
*/*%TST4: D (YES,INMLWTO,NO,OUTMLWTO) TARGET AREA = Z */
         CLI   WMJMAREA,Z          Q. AREA ID=Z FOR MSG STREAM
         BE    INMLWTO             YES, GO HANDLE INLINE MLWTO
         SPACE 2
OUTMLWTO EQU   *
*/*OUTMLWTO: P (,NXTENTRY) FREE THE OUT OF LINE MLWTO */
         LA    LINKR,NXTENTRY      GO FREE MLWTO AND THEN LOOK
         B     FREMLWTO                 AT NEXT CONSOLE Q ENTRY
         SPACE 2
REGWQE   EQU   *
*/*REGWQE: D (YES,%FREEREG,NO,NXTENTRY) INLINE MSGS TO BE FREED */
         TM    DCMUTILT,DCMUTILA   Q. INLINE MSGS TO BE FREED
         BNO   NXTENTRY            NO, GO LOOK AT NEXT CONSOLE         X
                                        QUEUE ENTRY
*/*%FREEREG: P (,NXTENTRY) INDICATE WQE TO BE FREED */
         OI    UCMSTS,UCMTB        INDICATE DEQ WORK TO DO
         OI    CQEFLAG,CQEAVAIL    TURN ON PURGE BIT
         NI    CQEFLAG,XFF-CQEENTR TURN OFF ENTRY FLAG
         B     NXTENTRY            GET NEXT CONSOLE Q ENTRY
         SPACE 2
INMLWTO  EQU   *
*/*INMLWTO: D (YES,%TSTWRKG,NO,NXTENTRY) INLINE MSGS TO BE FREED */
         TM    DCMUTILT,DCMUTILA   Q. INLINE MSGS TO BE FREED
         BNO   NXTENTRY            NO, GO LOOK AT NEXT CONSOLE         X
                                        OUTPUT QUEUE ENTRY
*/*%TSTWRKG: D (YES,WORKIN,NO,%FREEINM) WORKING ON AN INLINE MLWTO */
         TM    UCMSTS,UCMTC        Q. WORKING ON AN INLINE MLWTO
         BO    WORKIN              YES, GO FREE WHAT IS NOT YET        X
                                        OUTPUT
*/*%FREEINM: P (,NXTENTRY) FREE INLINE MLWTO */
         LA    LINKR,NXTENTRY      GO FREE MLWTO AND THEN LOOK
         B     FREMLWTO                 AT NEXT CONSOLE Q ENTRY
         SPACE 2
WORKIN   EQU   *
*/*WORKIN: P (,%FREEIN1) INDICATE NOT WORKING ON AN INLINE MLWTO */
         NI    UCMSTS,XFF-UCMTC    TURN OFF WORKING ON MLWTO BIT
         NI    UCMSDS5,XFF-UCMSDS5A TURN OFF WAITING ON MLWTO
*    FIND NEXT MINOR TO BE OUTPUT
*/*%FREEIN1: P (,NXTENTRY) FREE REMAINDER OF INLINE MLWTO */
         LA    LINKR,NXTENTRY      SET UP TO RETURN TO LOOK AT         X
                                        NEXT CONSOLE Q ENTRY           X
                                        AFTER FREEING MLWTO
         TM    CQEFLAG,CQEATTOP    Q. SHOULD MINOR SEARCH              X
                                        BEGIN AT TOP OF CHAIN
         BO    FREEMINT            YES, GO FREE MINORS STARTING        X
                                   FROM TOP OF CHAIN
         SPACE
GETSAVD2 EQU   *
         L     WQEBASE,UCMMLAST    GET POINTER TO LAST MINOR           X
                                        OUTPUT
         LTR   WQEBASE,WQEBASE     Q. ANY MINORS OUTPUT YET
         BZ    FREMLWTO            NO, GO FREE MLWTO
         B     GETNEXT             GO FIND NEXT MINOR TO BE            X
                                        OUTPUT, FREE MAJOR AND         X
                                        MINORS
         EJECT
* THE FOLLOWING ROUTINE FREES MLWTO'S.  THERE ARE MANY ENTRY
* POINTS, DEPENDING ON THE TYPE OF MLWTO TO BE FREED.  ALL
* EVENTUALLY END UP AT FREEMAJ TO FREE THE MAJOR WQE AFTER ALL
* MINORS, IF ANY, ARE FREED.  RETURN IS VIA REGISTER LINKR.
         SPACE 2
GETNEXT  EQU   *
*    CHECK TO SEE IF LAST MINOR OUTPUT IS STILL ON QUEUE
         LR    WORKR,WQEBASE       SAVE POINTER TO LAST MINOR          X
                                        OUTPUT
         L     WQEBASE,CQEWQE      GET POINTER TO MAJOR
         L     WQEBASE,WMJMMIN     GET POINTER TO FIRST MINOR
LOOKNEXT EQU   *
         LA    WQEBASE,E0(WQEBASE) CLEAR HIGH ORDER BYTE
         LTR   WQEBASE,WQEBASE     Q. END OF MINOR QUEUE
         BNZ   CHKEQ               NO, BRANCH TO SEE IF EQUAL TO       X
                                        LAST MINOR OUTPUT
         B     FREEMINT            GO FREE MINORS FROM TOP OF          X
                                        QUEUE SINCE LAST MINOR         X
                                        OUTPUT IS NO LONGER ON Q
CHKEQ    EQU   *
         CR    WORKR,WQEBASE       Q. MINOR POINTER EQUAL TO           X
                                        LAST MINOR OUTPUT
         BE    LASTONQ             YES, LAST OUTPUT IS STILL ON        X
                                        QUEUE - GO GET ITS CHAIN       X
                                        FIELD
         L     WQEBASE,WMNMNX1-E1  NO, GO LOOK AT
         B     LOOKNEXT                 NEXT MINOR ON QUEUE
LASTONQ  EQU   *
*    LAST MINOR IS STILL ON QUEUE -- CONTINUE FROM THERE
         L     WQEBASE,WMNMNX1-E1  GET CHAIN FIELD OF LAST MINOR       X
                                        OUTPUT
         LA    WQEBASE,E0(WQEBASE)  CLEAR HIGH ORDER BYTE
         B     FREEMIN             GO FREE MAJOR AND MINOR WQE'S
         SPACE 3
FREMLWTO EQU   *
*    FREE MLWTO MAJOR AND MINOR WQE'S
         L     WQEBASE,E0(OUTQREG) BASE MAJOR WQE
         TM    WMJMMLW,WMJMMLWH    Q. NULL MINOR ON QUEUE
         BO    FREEMAJ
         SPACE
FREEMINT EQU   *
*    FREE MINORS STARTING AT TOP OF CHAIN
         L     WQEBASE,CQEWQE      BASE MAJOR WQE
         L     WQEBASE,WMJMMIN     GET POINTER TO FIRST MINOR
         NI    CQEFLAG,XFF-CQEATTOP TURN OFF TOP OF CHAIN              X
                                        FLAG
         SPACE
FREEMIN  EQU   *
*    FREE MINORS STARTING WITH MINOR POINTED TO BY WQEBASE
         LTR   WQEBASE,WQEBASE     Q. ANY MINORS TO FREE
         BZ    FREEMAJ             NO, GO FREE MAJOR
         SPACE
FREEONE  EQU   *
         SR    WORKR,WORKR         CLEAR REG
         IC    WORKR,WMNMUC1       GET USE COUNT FROM MINOR
         BCTR  WORKR,E0            DECREMENT USE COUNT BY ONE
         STC   WORKR,WMNMUC1       STORE NEW USE COUNT
         L     WQEBASE,WMNMNX1-E1  GET ADDRESS OF NEXT MINOR
         LA    WQEBASE,E0(WQEBASE) CLEAR HIGH ORDER BYTE
         LTR   WQEBASE,WQEBASE     Q. MORE MINORS ON QUEUE
         BNZ   FREEONE             YES, GO FREE ANOTHER MINOR
         SPACE 3
FREEMAJ  EQU   *
         OI    CQEFLAG,CQEAVAIL    INDICATE MAJOR NO LONGER            X
                                        NEEDED BY THIS CONSOLE
         NI    CQEFLAG,XFF-CQEENTR TURN OFF ENTRY FLAG
         OI    UCMSTS,UCMTB        INDICATE DEQ WORK NEEDED
         BR    LINKR
         EJECT
*                             EXITS
         SPACE 2
PROC1EXT EQU   *
*/*PROC1EXT: R IEECVET1 PROCESSOR 1 */
         L     XFBRANCH,DCMNPROC   LOAD PROC 1 ADDRESS
         B     XCTL                EXIT TO IEECVET1
         SPACE 2
AEEXT    EQU   *
*/*AEEXT: R IEECVETC ASYNCHRONOUS ERROR */
         L     XFBRANCH,DCMNERRO   LOAD ASYNCH ERROR ADDRESS
XCTL     EQU   *
         L     X1PARM,DCMCXSVE     RESTORE CXSA ADDRESS
         BR    XFBRANCH            EXIT  ADDRESS ALREADY SET
         EJECT
***********************************************************************
*                                                                     *
*                             EQUATES                                 *
*                                                                     *
***********************************************************************
         SPACE 2
ID1      EQU   C'F'                1ST CHARACTER OF CSECT ID
ID2      EQU   C'G'                2ND CHARACTER OF CSECT ID
E0       EQU   0                   NUMBER
E1       EQU   1                   NUMBER
E2       EQU   2                   NUMBER
E3       EQU   3                   NUMBER
E4       EQU   4                   NUMBER
Z        EQU   C'Z'                MSG AREA ID
XFF      EQU   X'FF'               TO TURN OFF BITS
SP241    EQU   241                 GETMAINED SACB SUBPOOL
HALFWORD EQU   2                   BYTES IN HALFWORD
         EJECT
         CVT   DSECT=YES
         EJECT
         IHACTM CQE
         EJECT
         IHACTM  CXSA
         EJECT
         IEECUCM FORMAT=NEW
         EJECT
         IHAWQE  DSECT=YES
         EJECT
         IEERDCM
         EJECT
         IEETDCM
*/*IEECVFTG: END */
         END
