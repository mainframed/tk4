         TITLE '       IEAVLK02 COMMENTARY'
* /* START OF SPECIFICATIONS ****
*
*01*  MODULE-NAME = IEAVLK02
*
*01*  DESCRIPTIVE-NAME = PROGRAM MANAGER RESOURSE MANAGEMENT ROUNTINES
*
*01*  COPYRIGHT = NONE
*
*01*  STATUS = VERSION 1
*
*01*  FUNCTION = CLEANS UP CDE AND ANY ASSOCIATED CORE AT EXIT, DELETE,
*     ABEND, AND EOT.
*
*01*   NOTES = THE FOLLOWING IS A DESCRIPTION OF THE DEPENDENCIES,
*      CONVENTIONS, AND FUNCTIONS OF IEAVLK02
*
*02*     DEPENDENCIES = THE LOCAL LOCK MUST BE HELD ON ENTRY TO ALL
*        THREE ENTRY POINTS.
*
*03*        CHARACTER-CODE-DEPENDENCIES = NONE
*
*02*     RESTRICTIONS = NONE
*
*02*     REGISTER-CONVENTIONS = THE REGISTER CONVENTIONS USED BY
*        IEAVLK02 ARE DESCRIBED UNDER THE TOPIC REGISTER EQUATES.
*
*02*     PATCH-LABEL = THIS MODULE IS RESIDENT NUCLEUS, AND HAS NO
*        PATCH SPACE.
*
*01*  MODULE-TYPE = MODULE
*
*02*     PROCESSOR = ASSEMBLER
*
*02*     MODULE-SIZE = 1108 BYTES
*
*02*     ATTRIBUTES = REENTERABLE
*
*01*  ENTRY-POINT = CDHKEEP
*
*02*     PURPOSE = THIS ENTRY WILL RELEASE THE MODULE, EXTENT LIST,
*        MAJOR CDE AND ASSOCIATED MINORS AS REQUIRED.
*
*02*     LINKAGE = BRANCH ENTERED - BALR 14,15
*        ENTERED BY DELETE SERVICE ROUTINE
*        ENTERED BY PROGRAM MANAGER EXIT RESOURCE MANAGER (IEAVLK02)
*
*02*     INPUT = PSW ENABLED, KEY 0, SUPERVISOR STATE, LOCAL LOCK HELD
*        REGISTERS ARE
*        4 - CURRENT OR TERMINATING TCB ADDRESS
*        11 - MAJOR CDE
*        12 - TERMINATING CDE ADDRESS
*        14 - RETURN ADDRESS
*
*02*     OUTPUT = NONE
*
*02*     REGISTERS-SAVED = NONE
*        REGISTERS 5, 11-13 ARE UNCHANGED BY THIS ROUTINE
*        ALL OTHER REGISTERS ARE MODIFIED
*
*02*     REGISTER-USAGE = SEE REGISTER USAGE AT BEGINNING OF ROUTINE
*
*01*  ENTRY-POINT = IEAPPGMX
*
*02*     PURPOSE = THIS ROUTINE FREES PROGRAM MANAGER RESOURCES AT
*        EXIT AND DETERMINES IF A TASK TERMINATION IS IN PROGRESS AND
*        IF SO, FREES ANY LLE'S LEFT ON THE TCBLLE QUEUE, THEIR
*        ASSOCIATED CDE'S AND ITS ASSOCIATED CORE.
*
*02*     LINKAGE = BRANCH ENTERED BY EXIT (SVC 3) ROUTINE
*
*02*     INPUT = PSW ENABLED, KEY 0,SUPERVISOR STATE, LOCAL LOCK HELD
*        REGISTERS ARE:
*        REGISTER 5 - TERMINATING RB
*        REGISTER 13 - CALLERS SAVE AREA
*        REGISTER 14 - RETURN ADDRESS
*
*02*     OUTPUT = NONE
*
*02*     REGISTERS-SAVED = ALL REGISTERS ARE RETURNED TO THE CALLER
*        EXCEPT 15 WHICH CONTAINS A RETURN CODE
*
*02*     REGISTER-USAGE = SEE PROLOGUE AT BEGINNING OF ROUTINE
*
*01*  ENTRY-POINT = IEAPPGMA
*
*02*     PURPOSE = THIS ROUTINE IS ENTERED TO REMOVE PARTIALLY LOADED
*        PROGRAMS DURING ABEND PROCESSING. THIS ROUTINE IS ENTERED
*        PRIOR TO DUMP (IF REQUESTED) OF CORE.
*
*02*     LINKAGE = BRANCH ENTERED BY RTM2 VIA BR 14,15
*
*02*     INPUT = PSW ENABLED, KEY 0, SUPERVISOR STATE, LOCAL LOCK HELD
*        REGISTERS ARE:
*        REGISTER 1 - POINTER TO PARAMETER LIST POINTER
*        REGISTER 13 - CALLERS SAVE AREA
*        REGISTER 14 - RETURN ADDRESS
*
*02*     OUTPUT = NONE
*
*02*     REGISTERS-SAVED = CALLERS REGISTERS WILL BE RETURNED EXCEPT 15
*        WHICH WILL CONTAIN A RETURN CODE.
*
*02*     REGISTER-USAGE = SEE PROLOGUE AT BEGINNING OF ROUTINE
*
*01*  EXIT-NORMAL = CDHKEEP
*
*02*     CONDITIONS = RETURN VIA BR 14 TO CALLER.  CDE AND ASSOCIATED
*        CORE HAS BEEN FREED.
*
*02*     OUTPUT = REGISTER 5, 11-13 REMAIN AS ON ENTRY.
*        ALL OTHER REGISTERS ARE UNPREDICTABLE
*
*02*     RETURN-CODES = NONE
*
*01*  EXIT-NORMAL = IEAPPGMX
*
*02*     CONDITIONS = RETURN VIA BR 14 TO CALLER (SVC 3).  PROGRAM
*        MANAGER RESOURCES HAVE BEEN FREED.
*
*02*     OUTPUT = REGISTER 15 CONTAINS A RETURN CODE.
*        ALL OTHER REGISTERS ARE RETURNED TO CALLER
*
*02*     RETURN-CODES = RETURN CODE 0 = SUCCESSFUL
*                       RETURN CODE 4 = FAILED
*        THE ONLY CALLER OF THIS ROUTINE IS SVC 3.
*
*01*  EXIT-NORMAL = IEAPPGMA
*
*02*     CONDITIONS = RETURN VIA BR 14 TO CALLER.  PARTIALLY LOADED
*        PROGRAMS HAVE BEEN DEQUEUED AND POSSIBLY FREED.
*
*02*     OUTPUT = REGISTER 15 CONTAINS A RETURN CODE
*        ALL OTHER REGISTERS ARE RETURNED TO THE CALLER. (RTM2)
*
*02*     RETURN-CODES = RETURN CODE 0 = SUCCESSFULL
*                       RETURN CODE 4 = FAILED
*        THE ONLY CALLER OF THIS ROUTINE IS ABEND (RTM2)
*
*01*  EXTERNAL-REFERENCES =
*        IEAQCS02 - TO RESTART REQUESTS FOR PARTIALLY LOADED ROUTINES
*        IEAQCS03 - TO RESTART REQUESTS FOR SERIALLY REUSABLE ROUTINES
*          WHICH BECAUSE OF EXIT ARE NOW AVAILABLE
*        FRRPGMX - RECOVERY ROUTINE ADDRESS
*
*02*     ROUTINES =
*        FREEMAIN - TO RELEASE CDE, EXTENT LIST, FETCH WORK AREA,
*        MODULES, LLE
*        POST W/O ECB - TO CAUSE A WAITING RB TO BE MADE READY FOR
*        EITHER REUSABLE ROUTINES WHICH ARE NOW AVAILABLE OR
*        NOT-IN-CORE MODULES WHEN THE REQUESTING TASK IS IN ABEND
*        STATE.
*
*02*     DATA-AREAS = NO DATA SETS ARE USED BY THIS MODULE
*        A WORKAREA IS PASSED TO IEAVPGMA AS INPUT. THE FORMAT OF THE
*        WORKAREA CAN BE FOUND IN THE PROLOGUE FOR THAT ROUTINE.
*
*02*     CONTROL-BLOCKS = LLE,CDE,CVT,RB,TCB,SDWA
*
*01*  TABLES = NONE
*
*01*  MACROS = SETFRR, SETLOCK, GETMAIN, FREEMAIN,
*
*02*    SERIALIZATION = LOCAL LOCK HELD THROUGHOUT PROCESS, CMS LOCK
*       OBTAINED FOR LPA QUEUE MANIPULATION
*
*01*  CHANGE-ACTIVITY = MODULE WRITTEN FOR SUPPORT CODE Y02758
*        @YM06819 - 2/15/74
*        @ZA02733 - RELEASE 2
*        @ZA03243 @ZA03534 @ZA09239 - RELEASE 3
*        @ZA03631 @ZA04838 - RELEASE 4
*
*01*  MESSAGES = NONE
*
*01*  ABEND-CODES = NONE
*
**** END OF SPECIFICATIONS ***/
         EJECT
         SPACE 2
*/*IEAVLK02: CHART */
*/* HEADER
*/* PROGRAM MANAGER
*/*                                                    SECTION 3.1.11
*/* RESOURCE MANAGEMENT ROUTINES
*/*                                                    PAGE # */
         SPACE 2
IEAVLK02 CSECT                         CSECT NAME **** SINGLE CSECT
         MODID BR=NO
*        ENTRY STATEMENTS
         ENTRY CDHKEEP                 ENTRY TO FREE RESOURCES
         ENTRY IEAPPGMA                ENTRY TO REMOVE NIC PROG.
         ENTRY IEAPPGMX                ENTRY FROM EXIT
         ENTRY CDSSNOP                 ENTRY OF DSS HOOK
         ENTRY FINIS                   RETRY ENTRY FOR FRR
         ENTRY EOTCHK                  RETRY ENTRY FOR FRR
         SPACE 1
         EXTRN FRRPGMX                 ENTRY IN LK03 OF RECOVERY RTN.
         TITLE '               IEAVLK02 REGISTER EQUATES'
*        REGISTER EQUATES
R0       EQU   0                       STANDARD EQUATE
WKREG0   EQU   R0                      GENERAL WORK REGISTER
LNG      EQU   R0                      LENGTH FOR FREEMAIN
R1       EQU   1                       STANDARD EQUATE
WKREG1   EQU   R1                      GENERAL WORK REGISTER
PARMREG  EQU   R1                      INPUT PARAMETER REGISTER
ADDR     EQU   R1                      ADDRESS FOR FREEMAIN
R2       EQU   2                       STANDARD EQUATE
WKREG2   EQU   R2                      GENERAL WORK REGISTER
*                                      REGISTER 3 EQUATES
R3       EQU   3                       STANDARD EQUATE
CVTREG   EQU   R3                      REGISTER 3 POINTS TO CVT
LASTCDER EQU   R3                      LAST CDE REMOVED        @ZA04838
*                                      REGISTER 4 EQUATES
R4       EQU   4                       CROSS REFERENCE EQUATE
TCBREG   EQU   R4                      REGISTER 4 POINTS TO THE TCB
*                                      REGISTER 5 EQUATES
R5       EQU   5                       CROSS REFERENCE EQUATE
RBREG    EQU   R5                      POINTER TO THE RB
*                                      REGISTER 6 EQUATES
R6       EQU   6                       CROSS REFERENCE EQUATES
*                                      REGISTER 7 EQUATES
R7       EQU   7                       CROSS REFERENCE EQUATES
ASCBREG  EQU   R7                      POINTER TO THE ASCB
*                                      REGISTER 8 EQUATES
R8       EQU   8                       CROSS REFERENCE EQUATES
BASEREG  EQU   R8                      BASE REGISTER FOR IEAVLK02
*                                      REGISTER 9 EQUATES
R9       EQU   9                       CROSS REFERENCE EQUATES
XLREG    EQU   R9                      POINTER TO THE EXTENT LIST
NEXT     EQU   R9                      USED FOR LOOP IN RB FIND
*                                      ROUTINE IN PGMA
*                                      REGISTER 10 EQUATES
R10      EQU   10                      CROSS REFERENCE EQUATES
*                                      REGISTER 11 EQUATES
R11      EQU   11                      CROSS REFERENCE EQUATES
CDEMAJR  EQU   R11                     POINTER TO THE MAJOR CDE
*                                      REGISTER 12 EQUATES
R12      EQU   12                      CROSS REFERENCE EQUATES
CDEREG   EQU   R12                     POINTER TO CURRENT CDE
*                                      REGISTER 13 EQUATES
R13      EQU   13                      CROSS REFERENCE EQUATES
SAVEREG  EQU   R13                     SAVE AREA REGISTER
*                                      REGISTER 14 EQUATES
R14      EQU   14                      CROSS REFERENCE EQUATES
RETURN   EQU   R14                     RETURN REGISTER FOR ENTRY POINTS
*                                      REGISTER 15 EQUATES
R15      EQU   15                      CROSS REFERENCE EQUATES
         TITLE '              IEAVLK02 CHARACTER AND HEX MASK EQUATES'
ZERO     EQU   0                       SYMB DISPL TO BEG OF FIELD
NULL     EQU   0                       USED IN ADDRESSIBILITY BALR
N0       EQU   0                       CONSTANT OF ZERO
WORD1    EQU   0                       FIRST WORD OF LIST
N1       EQU   1                       CONSTANT
N2       EQU   2                       USED TO MULTIPLY BY 4 IN SHIFT
ADDL     EQU   3                       SIZE OF ADDRESS
RH       EQU   4                       RIGHT HALF OF PSW
N4       EQU   4                       CONSTANT TO PICK UP NEXT IN LIST
WORD     EQU   4                       SIZE OF ONE WORD
WORD2    EQU   4                       SECOND WORD OF LIST
NOTZERO  EQU   7                       NOT EQUAL COMPARES
MASK     EQU   7                       ICM 3 ADDR BYTES IN REG @YA00094
EQUAL    EQU   8                       EQUAL COMPARES
N8       EQU   8                       NUMERIC VALUE FOR RETURN CODE
WORD3    EQU   8                       THIRD WORD OF LIST
WORD4    EQU   12                      FOURTH WORD OF LIST
WORD5    EQU   20                      FIFTH WORD OF LIST
N24      EQU   24                      USED FOR 3 BYTE SHIFT
Q250     EQU   250                     SUBPOOL 250 (USER 0)
Q251     EQU   251                     SUBPOOL 251 (JPA)
Q252     EQU   252                     SUBPOOL 252
FETWKSIZ EQU   X'604'                    SIZE OF FETCH WORK AREA
MAX      EQU   X'FF'                   MAXIMUM VALUE
         EJECT
*        MODULE USING STATEMENTS
         USING PSA,0                   ADDRESSES LOW CORE
         USING CVT,CVTREG              POINTER TO THE CVT
         USING TCB,TCBREG              POINTER TO THE TCB
         USING RBSECT,RBREG            POINTER TO THE RB
         USING CDENTRY,CDEMAJR         POINTER TO THE CDE
         TITLE '        IEAVLK02 - IEAPPGMA ROUTINE'
         SPACE 2
*/* E IEAPPGMA */
*/* P SET UP ADDRESSIBILITY */
         SPACE 2
IEAPPGMA DS    0H                      ABEND INTERFACE
         STM   R14,R12,WORD4(R13)      SAVE ABEND REGISTERS
         BALR  BASEREG,NULL            SET UP ADDRESSIBILITY
         USING *,BASEREG               TELL ASSEMBLER
MODENT   DS    0H                      MOD. ENTRY POINT FOR ADDRESSING
         SPACE 2
*/* P GET POINTER TO PARAMETER LIST */
         SPACE 2
         L     PARMREG,ZERO(PARMREG)   GET POINTER TO PARM LIST
         USING RMPL,PARMREG            TELL ASSEMBLER ADDRESS
         SPACE 2
*/* P ESTABLISH AND INITIALIZE WORK AREA */
         SPACE 2
         L     R10,RMPLRMWA            GET MY WORK AREA ADDR.
         ST    R13,ZERO(R10)           SAVE ABEND SAVE AREA ADDR.
         LR    SAVEREG,PARMREG         SAVE PARM. LIST ADDR.
         DROP  PARMREG                 RESET ADDRESSIBILITY
         USING RMPL,SAVEREG            TO SAVE REGISTER
         SPACE 2
*/* P SET UP STANDARD REGISTERS R4=TCB, R7=ASCB, R12=CDE */
         SPACE 2
         L     TCBREG,RMPLTCBA         GET ABENDING TCB
         L     ASCBREG,RMPLASCB        GET ASCB FOR THE TCB
         L     WKREG2,TCBJSTCB         GET JOBSTEP TCB FOR ABEND
         SPACE 2
*/* P SAVE TCB JOB PACK QUEUE POINTER IN WORK AREA */
         SPACE 2
         LA    WKREG2,TCBJPQ-TCB(WKREG2)   GET JPQ POINTER
         ST    WKREG2,WORD2(R10)       SAVE JPQ POINTER
         SPACE 2
*/* D (NO,NORETRY,YES,) RTM PROCESSING FOR RECOVERY RETRY*/
         SPACE 2
         TM    RMPLFLG1,RMPLRCOV       RTM IN RETRY PROCESS    @YA00094
         BZ    NORETRY                 NO- CONTINUE ABEND TERM @YA00094
         SPACE 2
*/* P OBTAIN PROGRAM MANAGER SVRB ADDR FROM RMPL               */
*/* P OBTAIN POINTER TO CDE */
*/* D (NO,PGMAEND,YES,) DOES CDE EXIST */
         SPACE 2
         L     RBREG,RMPLRBPA          OBTAIN PM SVRB ADDR     @YA00094
         SR    CDEMAJR,CDEMAJR         CLEAR REG FOR INSERT    @YA00094
         ICM   CDEMAJR,MASK,RBCDE1     DOES CDE EXIST          @YA00094
         BZ    PGMAEND                 NO - RETURN             @YA00094
         SPACE 2
*/* D (NO,NOFETWK,YES,) HAS FETCH W.A. BEEN OBTAINED*/
         SPACE 2
         SR    R6,R6                   CLEAR REG FOR INSERT    @YA00094
         ICM   R6,MASK,RBCSWRKA        FETCH WORK AREA OBTAIND @YA00094
         BZ    NOFETWK                 NO - BYPASS FREEMAIN    @YA00094
         SPACE 2
*/* L FREEMAIN: FREE FETCH WORK AREA FROM SP253 (LSQA)*/
*/* P ZERO FETCH WORK AREA ADDRESS IN RBXSA */
         SPACE 2
         FREEMAIN RU,LV=FETWKSIZ,SP=253,A=(6),BRANCH=YES       @YA00094
         SR    R15,R15                 INSURE ZEROES IN R15    @YA00094
         ST    R15,RBCSWORK            CLEAR PTR TO FETCH W.A. @YA00094
         SPACE 2
*/*NOFETWK: P SAVE POINTER TO FIRST RB USING CDE (FROM CDRRBP)*/
*/* D (NO,LOCSVRB,YES,) PROG MGR SVRB TOP OF WAIT QUEUE */
*/* D (YES,DEQSVRB,NO,) WAITING FOR FOR MODULE (CDNIC=1)*/
         SPACE 2
NOFETWK  L     WKREG1,CDRRBP           SAVE PTR FOR LATER USE  @YA00094
         CLC   CDRRBP+1(3),RMPLRBPA+1  INPUT SVRB TOP OF QUEUE @YA00094
         BNE   LOCSVRB                 NO - SETUP TO DEQU SVRB @YA00094
         TM    CDATTR,CDNIC            IS IT ALSO ON NIC QUEUE @YA00094
         BO    DEQSVRB                 YES - DEQ&POST ALL      @YA00094
*                                      WAITING SVRB'S          @YA00094
         SPACE 2
*        PROCESS THE SERIAL REUS WAIT QUEUE
         SPACE 2
*/* P DECREMENT CDE USE COUNT BY ONE */
         SPACE 2
         LH    R6,CDUSE                GET CDE USE COUNT       @YA00094
         BCTR  R6,NULL                 DECREMENT COUNT BY 1    @YA00094
         STH   R6,CDUSE                AND STORE BACK IN CDE   @YA00094
         SPACE 2
*/* D (NO,USENOT0,YES,) USE COUNT = 0 */
         SPACE 2
         LTR   R6,R6                   USE COUNT = 0           @YA00094
         BNZ   USENOT0                 NO - DO NOT FREE CDE    @YA00094
         SPACE 2
*/* S (,PGMAEND) CDDESTRY: REMOVE CDE AND ASSOC CORE */
         SPACE 2
         BAL   R6,CDDESTRY             FREE CDE AND ASSOC CORE @YA00094
         B     PGMAEND                 RETURN TO CALLER        @YA00094
         SPACE 2
*/*USENOT0: P SAVE ADDRESS OF NEXT WAITING RB */
         SPACE 2
USENOT0  SR    WKREG1,WKREG1           CLEAR REG FOR INSERT    @YA00094
         ICM   WKREG1,MASK,RBPGMQ1     GET NEXT RB PTR         @YA00094
         SPACE 2
*/* P (,POSTNEXT) DEQUE THIS SVRB FR0M CDRBP AND CHAIN NEXT TO HEAD */
         SPACE 2
         ST    WKREG1,CDRRBP           PUT NEXT RB AT QUE HEAD @YA00094
         B     POSTNEXT                POST NXT WAITNG SVRB    @YA00094
         SPACE 2
*/*LOCSVRB: D (NO,PGMAEND,YES,) ANY RB'S WAITNG FOR THIS MOD */
         SPACE 2
LOCSVRB  LTR   WKREG1,WKREG1           ANY RB'S WAITING        @YA00094
         BZ    PGMAEND                 NO - RETURN             @YA00094
         SPACE 2
*/*P GET NEXT WAITNG SVRB */
*/* D (NO,LOCSVRB,YES,) THIS SVRB EQ INPUT SVRB */
         SPACE 2
         L     RBREG,RBPGMQ-RBSECT(WKREG1) GET NXT RB ON Q     @YA00094
         C     RBREG,RMPLRBPA          THIS RB EQ INPUT RB     @YA00094
         BE    CHECKNIC                DEQUEUE THIS SVRB       @YA00094
         LR    WKREG1,RBREG            POINT TO NEXT RB        @YA00094
         B     LOCSVRB                 LOCATE INPUT SVRB ON    @YA00094
*                                      THIS QUEUE              @YA00094
         SPACE 2
*/*CHECKNIC: P CLEAR ADDR PORTION OF RBOPSW FOR RTM */
*/* D (NO,TCBDEQUE,YES,) MODULE IN CORE */
*/* P (,TCBDEQUE) MOD IS SER REUS - DECREMENT USE COUNT IN CDE*/
         SPACE 2
CHECKNIC XC    RBOPSW+RH(4),RBOPSW+RH  CLEAR RBOPSW+4 FOR RTM  @YA00094
         TM    CDATTR,CDNIC            MODULE IN STORAGE       @YA00094
         BO    TCBDEQUE                NO - DEQUE THE SVRB     @YA00094
*                                      YES - DECREMENT USE     @YA00094
*                                      COUNT OF SER REUS MOD   @YA00094
         LH    R6,CDUSE                GET CDE USE COUNT       @YA00094
         BCTR  R6,NULL                 DECREMENT USE COUNT     @YA00094
         STH   R6,CDUSE                AND STORE BACK IN CDE   @YA00094
         B     TCBDEQUE                DEQUEUE THE SVRB        @YA00094
         SPACE 2
*/*POSTNEXT: P CLEAR WAIT QUEUE POINTER IN SVRB */
         SPACE 2
POSTNEXT XC    RBPGMQ1(3),RBPGMQ1      CLEAR QUEUE POINTER     @YA00094
         SPACE 2
*/* P PUT ADDRESS OF PGM MGR ENTRY IEAQCS03 IN RBOPSW */
         SPACE 2
         L     R6,AIEAQCS3             GET ENTRY IN PROG MGR   @YA00094
         ST    R6,RBOPSW+RH-RBSECT(WKREG1) ST IN WAITNG RBOPSW @YA00094
         SPACE 2
*/* P SET UP FOR POST W/O ECB */
         SPACE 2
         LR    R10,WKREG1              ADDR OF RB TO BE POST'D @YA00094
         SR    R11,R11                 RB IN THIS ADDR SPACE   @YA00094
         L     CVTREG,CVTPTR           GET CVTPTR              @YA00094
         L     R15,CVT0PT01            GET ADDRESS OF POST RTN @YA00094
         SPACE 2
*/* L POST W/0 ECB - POST WAITING RB */
         SPACE 2
         BALR  RETURN,R15              BRANCH TO POST W/O ECB  @YA00094
         SPACE 2
*/* P (,PGMAEND) RETURN TO CALLER */
         SPACE 2
         B     PGMAEND                 RETURN TO CALLER        @YA00094
         SPACE 2
*/*NORETRY: P GET FIRST CDE ON TCBJPQ */
         SPACE 2
NORETRY  L     CDEMAJR,N0(WKREG2)      GET JPA QUEUE POINTER   @YA00094
         LA    CDEMAJR,0(CDEMAJR)      CLEAR HIGH ORDER BYTE
*
*  DO UNTIL END OF QUEUE OR MAJOR NIC FOUND
*
         SPACE 2
*/*MINLOOP: D (NO,PGMAEND,YES,) ANY CDE'S LEFT ON TCBJPQ */
         SPACE 2
MINLOOP  LTR   CDEMAJR,CDEMAJR         ANY CDE'S
         BZ    PGMAEND                 NO- TERMINATE
         SPACE 2
*/* D (YES,NEXTCDE,NO,) CURRENT CDE A MINOR? */
         SPACE 2
         TM    CDATTR,CDMIN            CDE A MINOR
         BO    NEXTCDE                 YES- GET NEXT CDE
         SPACE 2
*/* D (NO,TCBTEST,YES,) MAJOR CDE IN CORE? */
         SPACE 2
         TM    CDATTR,CDNIC            MAJOR CDE IN CORE
         BO    TCBTEST                 NO- GO TEST TCB = ABENDING TCB
         SPACE 2
*/* D (YES,NEXTCDE,NO,) MAJOR CDE RENT. ? */
*/* D (YES,SKIPPRB,NO,) MAJOR CDE SER REUS? */
*/*NEXTCDE: P SAVE PREVIOUS CDE ADDRESS */
         SPACE 2
         TM    CDATTR,CDREN            MAJOR CDE REN ?         @ZA03631
         BO    NEXTCDE                 YES- GET NEXT CDE       @ZA03631
         TM    CDATTR,CDSER            MAJOR CDE REUS?         @ZA03631
         BO    SKIPPRB                 YES- SKIP FIRST PRB     @ZA03631
NEXTCDE  ST    CDEMAJR,WORD2(R10)      SAVE PREVIOUS CDE
         SPACE 2
*/* P (,MINLOOP) GET NEXT CDE (NEW CURRENT) */
         SPACE 2
         L     CDEMAJR,CDCHAIN         GET NEXT CDE ON JPQ
         B     MINLOOP                 CONT. SEARCH
*
*  IF CDE IS NOT IN CORE THEN DO:
*
         SPACE 2
*/*TCBTEST: P GET FIRST RB FROM TCB (R5=TCBRBP(R4)) */
*/* P GET FIRST RB FROM CDE (R1=CDRRBP(R11)) */                @ZA03534
         SPACE 2
TCBTEST  EQU   *
         LA    WKREG1,1                THESE INSTRS. GET LEFT- @ZA09239
         SLL   WKREG1,31               MOST BIT ON IN REG 11   @ZA09239
         OR    CDEMAJR,WKREG1          TO IND. NO RETRY PATH   @ZA09239
         L     RBREG,TCBRBP            GET FIRST RB FROM TCB   @ZA03534
         L     WKREG1,CDRRBP           GET FIRST RB FROM CDE   @ZA03534
         SPACE 2
*/*RBCOMP: D (YES,DEQSVRB,NO,) DOES RB FROM CDE = THIS RB FROM TCB */
         SPACE 2
RBCOMP   CLM   RBREG,MASK,CDRRBP+N1    DOES THE RB FROM THE    @ZA03534
*                                      CDE MATCH A RB ON THE   @ZA03534
*                                      TCB CHAIN?              @ZA03534
         BE    DEQSVRB                 YES- GO DEQUE THE SVRB  @ZA03534
         SPACE 2
*/* D (YES,CONTSRCH,NO,) THIS RB POINT TO THE TCB? */
         SPACE 2
         TM    RBSTAB2,RBTCBNXT        THIS RB POINT TO TCB?   @ZA03534
         BO    CONTSRCH                YES- GO TO CONTINUE     @ZA03534
*                                      SEARCH WITH NEXT RB ON  @ZA03534
*                                      RBPGMQ                  @ZA03534
         SPACE 2
*/* P (,RBCOMP) GET NEXT RB (R5=RBLINK(R5)) */
         SPACE 2
         L     RBREG,RBLINK            GET NEXT RB             @ZA03534
         B     RBCOMP                  GO COMPARE WITH CDRRBP  @ZA03534
         SPACE 2
*/*DEQSVRB: P SET CDE USE COUNT TO ZERO */
*/* P CLEAR CDE POINTER IN SVRB AND MARK SVRB AS TYPE 2 FOR ABEND */
         SPACE 2
DEQSVRB  SR    WKREG1,WKREG1           CLEAR REG FOR STORAGE
         STH   WKREG1,CDUSE            SET CDE USE COUNT TO ZERO
         STCM  WKREG1,MASK,RBCDE1      CLEAR CDE POINTER       @ZA03243
         NI    RBSTAB1,MAX-RBTRSVRB    INSURE SVRB RESIDENT      M04161
         SPACE 2
*/* P CLEAR RB QUEUE HEAD POINTER */
         SPACE 2
         ST    WKREG1,CDRRBP           CLEAR QUEUE HEAD
*
*        DEQUEUE WAITING RB'S AND ALLOW TO RESTART
*
         SPACE 2
*/* P SAVE VOLITAL REGISTERS IN WORK AREA (R10-14) */
         SPACE 2
         L     WKREG1,RMPLRMWA         GET MY SAVE AREA
         STM   R10,R14,WORD3(WKREG1)   SAVE VOLITAL REGS
         SPACE 2
*/*CARRYON: P GET RB ON WAIT QUEUE */
         SPACE 2
CARRYON  L     NEXT,RBPGMQ             GET NEXT RB ON WAIT QUEUE
         SPACE 2
*/* D (NO,DQEND,YES,) ANY RB'S ON WAIT QUEUE? */
         SPACE 2
         LTR   NEXT,NEXT               ANY RB'S WAITING
         BZ    DQEND                   NO- GO TO END
         SPACE 2
*/* P CLEAR THE RB QUEUE FIELD */
         SPACE 2
         XC    RBPGMQ+N1(ADDL),RBPGMQ+N1  CLEAR RB QUEUE POINTER
         SPACE 2
*/* P PUT ADDRESS OF PGM. MGR. ENTRY IEAQCS02 IN RESUME PSW FIELD */
*/* P CLEAR CDE FIELD AND INSURE SVRB MARKED RESIDENT */
         SPACE 2
         LR    RBREG,NEXT              SET FOR NEXT LOOP
         MVC   RBOPSW+RH(WORD),AIEAQCS2   PUT PGM.MGR. ADDR. IN PSW
         XC    RBCDE1(3),RBCDE1        CLEAR CDE POINTER
         NI    RBSTAB1,MAX-RBTRSVRB    INSURE SVRB MARKED RESIDENT
         SPACE 2
*/* P SET UP INPUT TO POST W/O ECB */
         SPACE 2
         LR    R10,RBREG               INPUT TO POST-10=RB TO BE POSTED
         SR    R11,R11                 0 INDICATES THIS ADDRESS SPACE
         L     CVTREG,CVTPTR           GET CVT POINTER
         L     R15,CVT0PT01            GET POST ENTRY POINT
         SPACE 2
*/* L POST W/O ECB-- POST THE WAITING RB */
         SPACE 2
         BALR  RETURN,R15              GO TO POST W/O ECB
         SPACE 2
*/* P (,CARRYON) CLEAR CDE POINTER IN RB */
         SPACE 2
         XC    RBCDE+N1(ADDL),RBCDE+N1   CLEAR RB CDE POINTER
         B     CARRYON                 LOOP TO GET NEXT RB
         SPACE 2
*/*DQEND: P RESTORE VOLITAL REGISTERS */
         SPACE 2
DQEND    L     WKREG1,RMPLRMWA         GET MY WORK AREA
         LM    R10,R14,WORD3(WKREG1)   RESTORE VOLITAL REGS
*
*        GO TO CDDESTRY TO REMOVE CDE AND ASSOCIATED CORE
*
         SPACE 2
*/* S (,TSTNXTCD) CDDESTRY:REMOVE CDE AND ASSOC. SPACE */
         SPACE 2
         BAL   R6,CDDESTRY             GO REMOVE CDE AND ASSOC. CORE
         B     TSTNXTCD                GET NEXT CDE ON QUEUE AND
*                                      REPEAT PROCESS
*
*  END DO GROUP
*  ELSE DO
*
         SPACE 2
*/*SKIPPRB: P GET FIRST PRB FROM CDE */
*/* D (NO,NEXTCDE,YES,) RB EXIST? (CDRRBP NOT ZERO)*/
*/*CONTSRCH: P SAVE CURRENT CDE POINTER IN WORK AREA */
         SPACE 2
SKIPPRB  L     WKREG1,CDRRBP           GET FIRST PRB FROM CDE  @ZA03631
         LTR   WKREG1,WKREG1           RB EXIST?               @ZA03631
         BZ    NEXTCDE                 NO- GET NEXT CDE        @ZA03631
CONTSRCH DS    0H
         L     R15,RMPLRMWA            GET WORK AREA
         ST    CDEMAJR,WORD2(R15)      SAVE CURRENT CDE POINTER
         SPACE 2
*/*CNTSRCHI: P GET NEXT RB ON CDE QUEUE */
         SPACE 2
CNTSRCHI L     RBREG,RBPGMQ-RBSECT(WKREG1)   GET NEXT RB ON QUEUE
         SPACE 2
*/* D (NO,TSTNXTCD,YES,) ANY MORE RB'S ON WAIT QUEUE? */
         SPACE 2
         LTR   RBREG,RBREG             ANY MORE RB'S ON WAIT QUEUE
         BZ    TSTNXTCD                NO- GET NEXT CDE AND CONT.
         SPACE 2
*/* D (YES,TCBDEQUE,NO,) THIS TCB THE ABENDING TCB? */
         SPACE 2
         CLM   TCBREG,MASK,RBOPSW+5    THIS TCB ABENDING
         BE    TCBDEQUE                YES-DECHAIN IT
         SPACE 2
*/* P (,CNTSRCHI) GET NEXT RB ON CDE/RB QUEUE */
         SPACE 2
         LR    WKREG1,RBREG            GET NEXT RB ON QUEUE
         B     CNTSRCHI                REPEAT FOR NEXT RB ON WAIT QUEUE
*        UNCHAIN WAITING RB
         SPACE 2
*/*TCBDEQUE: P DEQUEUE WAITING RB AND ZERO POINTER */
*/* P CLEAR CDE POINTER AND INSURE SVRB MARKED RESIDENT FOR ABEND */
*/* D (YES,TSTNXTCD,NO,) IS CDE RENT?*/
*/* D (NO,TSTNXTCD,YES,) IS CDE REUS?*/
*/* P DECREMENT THE USE COUNT IN THE CDE */
         SPACE 2
TCBDEQUE MVC   RBPGMQ+N1-RBSECT(ADDL,WKREG1),RBPGMQ+N1 UNHOOK RB
         XC    RBPGMQ(WORD),RBPGMQ     CLEAR THE WAIT QUE PTR  @ZA03534
         XC    RBCDE1(3),RBCDE1        CLEAR CDE POINTER         M04161
         NI    RBSTAB1,MAX-RBTRSVRB    INSURE SVRB RESIDENT      M04161
         TM    CDATTR,CDREN            IS CDE RENT?            @ZA03631
         BO    TSTNXTCD                YES- GO FOR NEXT CDE    @ZA03631
         TM    CDATTR,CDSER            IS CDE REUS?            @ZA03631
         BZ    TSTNXTCD                NO- GO FOR NEXT CDE     @ZA03631
         LH    R6,CDUSE                GET CDE USE COUNT AND   @ZA03631
         BCTR  R6,NULL                 DECREMENT BY ONE        @ZA03631
         STH   R6,CDUSE                                        @ZA03631
*
*  END OF ELSE DO
*
         SPACE 2
*/*TSTNXTCD: D (YES,PGMAEND,NO,) RTM PROCESSING FOR RECOV. RETRY */
*/* P RESET STANDARD REGISTERS */
         SPACE 2
TSTNXTCD TM    RMPLFLG1,RMPLRCOV       RTM IN RETRY            @YA00094
         BO    PGMAEND                 YES-RESOURCE MGR CMPLETE@YA00094
         SPACE 2
         DS    0H
         L     R4,RMPLTCBA             RESET TCB ADDRESS
         L     R7,RMPLASCB             RESET ASCB ADDRESS
         L     WKREG1,RMPLRMWA         GET MY WORKAREA
         SPACE 2
*/* P (,MINLOOP) GET PREVIOUS AND CURRENT CDE ADDRESSES */
         SPACE 2
         L     CDEREG,WORD2(WKREG1)    GET PREVIOUS CDE
         L     CDEMAJR,CDCHAIN-CDENTRY(CDEREG)  GET NEXT(CURRENT) CDE
         B     MINLOOP                 PROCESS NEXT CDE
*
*  LAST CDE ON JPQ HAS BEEN PROCESSED
*
         SPACE 2
*/*PGMAEND: P RE-ESTABLISH CALLERS REGISTERS */
         SPACE 2
PGMAEND  L     WKREG1,RMPLRMWA         GET MY WORKAREA
         L     R13,ZERO(WKREG1)        GET CALLERS SAVEAREA ADDR.
         LM    R14,R12,WORD4(R13)      RESTORE CALLERS REGS.
         SPACE 2
*/* P SET RETURN CODE = ZERO */
         SPACE 2
         SR    R15,R15                 SET 0 RETURN CODE
         SPACE 2
*/* R RETURN R14 */
         SPACE 2
         BR    RETURN                   RETURN TO CALLER
         DROP  SAVEREG                 DONT NEED PGMA PARM LIST
         TITLE '         IEAVLK02 - IEAPPGMX ROUTINE'
         SPACE 2
*/* E IEAPPGMX */
*/* P ESTABLISH ADDRESSIBILITY */
         SPACE 2
IEAPPGMX DS    0H                      EXIT INTERFACE
         STM   R14,R12,WORD4(R13)      SAVE CALLERS REGISTERS
         BALR  BASEREG,NULL            SET UP ADDRESSIBILITY
         USING *,BASEREG               TELL ASSEMBLER
         L     BASEREG,AMODENT         GET POINTER TO FRONT OF MOD.
         USING MODENT,BASEREG          TELL ASSEMBLER
         SPACE 2
*/* L SETFRR-- ESTABLISH RECOVERY ROUTINE */
         SPACE 2
         SETFRR A,FRRAD=FRREXIT,WRKREGS=(2,3),PARMAD=(2) SET RECOVERY
         ST    BASEREG,N4(R2)          PUT BASEADDRESS IN PARM AREA
         ST    R13,N0(R2)              PUT CALLERS REG SAVE IN PARMLST
         LR    R13,R2                  MOVE PARMLIST POINTER   @ZA02733
         L     CVTREG,CVTPTR           RESET CVT ADDRESS         M01976
         SPACE 1
*        DECREMENT CDE USE COUNT FOR EXITING MODULE AND FREE CORE
*        AS REQUIRED.
         SPACE 2
*/*P GET CDE ADDRESS FROM EXITING RB */
         SPACE 2
         L     CDEREG,RBCDE            GET EXITING CDE
         LA    CDEREG,0(CDEREG)        CLEAR HIGH ORDER BYTE
         SPACE 2
*/* D (NO,EOTCHK,YES,) CDE EXIST FOR THIS REQUEST? */
         SPACE 2
         LTR   CDEREG,CDEREG           Q. CDE EXIST FOR THIS REQUEST
         BZ    EOTCHK                  A. NO- CHECK FOR END OF TASK
         SPACE 2
*/*GETMAJOR: D (NO,MAJREQ,YES,) EXITING REQUEST FOR MAJOR CDE */
         SPACE 2
GETMAJOR LR    CDEMAJR,CDEREG          PUT CURRENT IN MAJOR REG.
         TM    CDATTR-CDENTRY(CDEREG),CDMIN  Q. EXITING CDE A MINOR
         BZ    MAJREQ                  A. NO- MAJOR REG SET UP ALREADY
         SPACE 2
*/* P GET MAJOR CDE FOR EXITING REQUEST */
         SPACE 2
         L     CDEMAJR,CDXLMJP-CDENTRY(CDEREG)   GET MAJOR CDE
         SPACE 2
*/*MAJREQ: D (NO,JPQMOD,YES,) CDE ON LPA QUEUE? */
*/* P SAVE REGS 11 - 13 IN FRR PARM LIST AREA */
*/* L SETLOCK-- GET CMS LOCK */
*/* P RESTORE REGS 11 - 13 FROM FRR PARM. LIST */
*/*JPQMOD: P DECREMENT CDE USE COUNT BY ONE */
         SPACE 2
MAJREQ   TM    CDATTR,CDNIP            CDE IN LPA TEST          @Y04990
         BZ    JPQMOD                  NO- SKIP CMS LOCK OBTAIN @Y04990
         STM   R11,R13,N8(R2)          SAVE REGS OVER SETLOCK   @Y04990
         SETLOCK OBTAIN,TYPE=CMS,MODE=UNCOND,                   @Y04990X
               RELATED=(IEAVLK02,CDHKEEP,EXITSRCH)              @Y04990
         LM    R11,R13,N8(R2)          RESTORE REGS             @Y04990
JPQMOD   LH    WKREG1,CDUSE            GET CDE USE COUNT
         BCTR  WKREG1,NULL             DECREMENT COUNT BY ONE
         STH   WKREG1,CDUSE            AND PUT IT BACK IN THE CDE
*
*    IF ANY RB'S WAITING FOR THIS CDE
*
         SPACE 2
*/* P GET ADDRESS OF ANY WAITING RB'S */
         SPACE 2
         L     WKREG1,RBPGMQ           GET PGM. REQUEST QUEUE
         LA    WKREG1,0(WKREG1)        CLEAR HIGH ORDER BYTE
         SPACE 2
*/* P PUT WAITING RB'S ADDRESS IN CDE */
         SPACE 2
         ST    WKREG1,CDRRBP           PUT QUEUE FIELD IN CDE
         SPACE 2
*/* D (NO,CLEARCDE,YES,) RB'S WAITING TO USE THIS REUS. MOD? */
         SPACE 2
         LTR   WKREG1,WKREG1           Q. REQ. OUTSTANDING FOR THIS CDE
         BZ    CLEARCDE                A. NO- GO TO CDHKEEP
*
*     THEN DO:
*
         SPACE 2
*/* P PUT ADDRES OF PGM. MGR. ENTRY IEAQCS03 IN RESUME PSW */
         SPACE 2
         L     WKREG2,AIEAQCS3         GET ENTRY IN PGM. MGR.
         ST    WKREG2,RBOPSW+RH-RBSECT(WKREG1)  PUT IN WAITING RB OPSW
         SPACE 2
*/* P SET UP FOR POST W/O ECB */
         SPACE 2
         LR    WKREG2,R13              SAVE SAVE AREA ADDR. OVER POST
         LR    R10,WKREG1              ADDRESS OF RB TO BE POSTED
         SR    R11,R11                 INDICATE RB IN THIS ADDR. SPACE
         L     R15,CVT0PT01            GET ADDRESS OF POST RTN.
         SPACE 2
*/* L (,EOTCHK) POST W/O ECB-- POST THE WAITING RB */
         SPACE 2
         BALR  RETURN,R15              GO TO POST W/O ECB
         LR    R13,WKREG2              RESTORE REG. SAVED OVER POST
         B     EOTCHK                  RETURN TO CALLER
*
*     END DO GROUP
*     ELSE DO:
*
         SPACE 2
*/*CLEARCDE: S CKHKEEPI:FREE CDE AND ANY ASSOC. STORAGE */
         SPACE 2
CLEARCDE BAL   RETURN,CDHKEEPI         GO TO CDHKEEP TO FREE
*                                      CDE AND ANY CORE NECESSARY
*  NOTE: REGISTERS 3,4,5,7,11,12 ARE ALREADY SET FOR ENTRY
*
*     IF THIS IS THE LAST RB ON TCB QUEUE (EOT)
*
         SPACE 2
*/*EOTCHK: P TURN PROGRESS BYTE ZERO ON IN THE FRR PARM LIST*/ @ZA02733
*/* D (NO,FINIS,YES,) IS THIS AN END-OF-TASK REQUEST? */
         SPACE 2
EOTCHK   MVI   FRRPLCK0-FRRPLIST(R13),N1 SET PARM LIST PROGRES @ZA02733
*                                      BYTE ON                 @ZA02733
         TM    RBSTAB2,RBTCBNXT        Q. TCB NEXT INDIC. EOT
         BZ    FINIS                   A. NO- RETURN TO CALLER
*
*  THEN DO:                 /*  EOT WORK       */
*
         SPACE 2
*/* P GET ADDRESS OF LLE QUEUE FROM TCB */
         SPACE 2
         L     WKREG2,TCBLLS           GET LLE QUEUE POINTER
         SPACE 2
*/* D (NO,FINIS,YES,) ANY LLE'S TO FREE? */
         SPACE 2
         LTR   WKREG2,WKREG2           ANY LLES TO FREE
         BZ    FINIS                   NO- RETURN TO CALLER
         USING LLE,WKREG2              SET UP ADDRESSING
*
*  DO WHILE LLE'S EXITS
*
         SPACE 2
*/*LLELOOP: P GET CDE FOR THIS LLE */
         SPACE 2
LLELOOP  L     CDEREG,LLECDPT          GET CDE FOR THIS LOAD
         SPACE 2
*/* D (YES,MAJLOAD,NO,) THIS CDE A MAJOR CDE? */
         SPACE 2
         LR    CDEMAJR,CDEREG          SET MAJOR CDE UP ALSO
         TM    CDATTR-CDENTRY(CDEREG),CDMIN  Q. THIS CDE A MINOR
         BZ    MAJLOAD                 A. NO- MAJOR ALREADY SET
         SPACE 2
*/* P GET MAJOR CDE */
         SPACE 2
         L     CDEMAJR,CDXLMJP-CDENTRY(CDEREG)  GET MAJOR CDE
         SPACE 2
*/*MAJLOAD: D (NO,JPQMOD1,YES,) CDE ON LPA QUEUE? */
*/* P SAVE R11 - R13 IN REGS 1,5, AND 15 */
*/* L SETLOCK-- GET CMS LOCK */
*/* P RESTORE R11 - R13 FROM SAVE REGS */
*/*JPQMOD1: P DECREMENT CDE USE COUNT BY LLE USE COUNT */
         SPACE 2
MAJLOAD  TM    CDATTR,CDNIP            CDE ON LPA TEST
         BZ    JPQMOD1                 NO- SKIP GETTING CMS LOCK Y04990
         LR    R1,R11                  SAVE R13                 @Y04990
         LR    R5,R12                  SAVE R12                 @Y04990
         LR    R15,R13                 SAVE R13                 @Y04990
         SETLOCK OBTAIN,TYPE=CMS,MODE=UNCOND,                   @Y04990X
               RELATED=(IEAVLK02,CDHKEEP,EXITSRCH)              @Y04990
         LR    R11,R1                  RESTORE R11              @Y04990
         LR    R12,R5                  RESTORE R12              @Y04990
         LR    R13,R15                 RESTORE R13              @Y04990
JPQMOD1  LH    WKREG1,CDUSE            GET CDE USE COUNT
         SH    WKREG1,LLECOUNT         SUBTRACT THE LLE USE COUNT
         STH   WKREG1,CDUSE            RETURN COUNT TO CDE
         SPACE 2
*/* P SAVE LLE ADDRESS OVER INTERFACE */
         SPACE 2
         LR    RBREG,WKREG2            SAVE LLE OVER INTERFACE
         SPACE 2
*/* S CDHKEEPI:FREE CDE AND ASSOC. STORAGE */
         SPACE 2
         BAL   RETURN,CDHKEEPI         GO TO HOUSEKEEPING RTN.
         SPACE 2
*/* P GET NEXT LLE ON QUEUE */
         SPACE 2
         L     WKREG2,LLECHN-LLE(RBREG)   GET NEXT LLE ON CHAIN
         SPACE 2
*/* P INSURE ASCB IN R7 FOR FREEMAIN */
         SPACE 2
         L     ASCBREG,PSAAOLD         GET CURRENT ASCB ADDR.
         SPACE 2
*/* L FREEMAIN-- FREE THE CURRENT LLE (SP255) */
         SPACE 2
         FREEMAIN  RC,A=(RBREG),LV=LLESIZE,SP=255,BRANCH=YES FREE LLE
         SPACE 2
*/* D (YES,LLELOOP,NO,) ANY MORE LLE'S ON QUEUE? */
         SPACE 2
         LTR   WKREG2,WKREG2           Q. MORE LLE'S
         BNZ   LLELOOP                 A. YES, PROCESS NEXT
         SPACE 2
*/* P GET TERMINATING TCB ADDRESS */
         SPACE 2
         L     TCBREG,PSATOLD          GET TCB ADDRESS
         SPACE 2
*/* P CLEAR THE LLE QUEUE HEADER FIELD IN THE TCB */
         SPACE 2
         ST    WKREG2,TCBLLS           CLEAR LLE POINTER IN TCB
         DROP  WKREG2
*  END DO GROUP
*  ELSE:
*  END ELSE DO GROUP:
         SPACE 2
*/*FINIS: P RESTORE CALLERS SAVE AREA ADDRESS */               @ZA02733
*/* L SETFRR-- REMOVE FRR FROM STACK */
         SPACE 2
FINIS    L     R13,N0(R13)             RESTORE SAVE AREA PTR   @ZA02733
         SETFRR D,WRKREGS=(2,3)        REMOVE RECOVERY RTN
         SPACE 2
*/* P RESTORE CALLERS REGISTERS */
         SPACE 2
         LM    R14,R12,WORD4(R13)      RESTORE CALLERS REGS
         SPACE 2
*/* P SET RETURN CODE = ZERO */
         SPACE 2
         SR    R15,R15                 INDICATE COMPLETE SUCCESSFULLY
         SPACE 2
*/* R RETURN R14 */
         SPACE 2
         BR    RETURN                  RETURN TO CALLER
         TITLE '             IEAVLK02 - CDHKEEP ROUTINE'
         SPACE 2
*/* E CDHKEEP */
*/* P ESTABLISH ADDRESSIBILITY */
         SPACE 2
CDHKEEP  BALR  BASEREG,NULL            SET UP ADDRESSIBILITY
         USING *,BASEREG
         L     BASEREG,AMODENT         GET POINTER TO FRONT OF MOD.
         USING MODENT,BASEREG          TELL ASSEMBLER
         SPACE 2
*/*CDHKEEPI: P SAVE RETURN ADDRESS IN UNUSED REGISTER */
         SPACE 2
CDHKEEPI LR    R6,RETURN               SAVE RETURN REGISTER
         SPACE 2
*/* P TURN ON NOT FUNCTIONAL FLAG IN CDE */
         SPACE 2
         OI    CDATTR,CDNFN            SET NOT FUNCTIONAL FLAG
*                                      LOAD/BRANCH COULD CAUSE FLAG NOT
*                                      SET IN PROGRAM MANAGER
         SPACE 2
*/* P CLEAR HIGH ORDER BYTES OF CDE REGISTERS */
         SPACE 2
         LA    R12,N0(R12)             CLEAR HIGH ORDER BYTE OF CDE
         LA    CDEMAJR,N0(CDEMAJR)     CLEAR HIGH BYTE
         SPACE 2
*/*P GET CDE USE COUNT */
         SPACE 2
         LH    WKREG1,CDUSE            GET USE COUNT
         SPACE 2
*/* D (NO,ERROR,YES,) USE COUNT = ZERO? */
         SPACE 2
         LTR   WKREG1,WKREG1           Q. USE COUNT ZERO.
         BNZ   ERROR                   A. NO-RETURN.            @Y04990
         SPACE 2
*/* D (YES,LPAONLY,NO,) MODULE IN LPA? */
         SPACE 2
         TM    CDATTR,CDNIP            Q. IS MODULE IN CVTQLPAQ
         BO    LPAONLY                 A. YES-SEARCH ONLY LPA AND
*                                      DO NOT FREE MODULES
         SPACE 2
*/*CDDESTRY: P GET EXTENT LIST ADDRESS */
         SPACE 2
CDDESTRY L     XLREG,CDXLMJP           GET XLTLIST POINTER
         USING XTLST,XLREG             POINTER TO EXTENT LIST
         LA    XLREG,ZERO(XLREG)       CLEAR HIGH ORDER BYTE
         SPACE 2
*/* D (YES,,NO,ORDERCDQ) IS THERE AN EXTENT LIST? */
         SPACE 2
         LTR   XLREG,XLREG             Q. IS THERE AN EXTENT LIST
         BZ    ORDERCDQ                A. NO- DO NOT TRY TO FREE IT
         SPACE 2
*/*  P GET LENGTH OF MODULE FROM XL */
         SPACE 2
         L     WKREG2,XTLMSBLA         GET LENGTH OF MODULE
         LA    WKREG2,ZERO(WKREG2)     CLEAR HIGH ORDER BYTE
         SPACE 2
*/* P GET ADDRESS TO BE FREED FROM XL */
         SPACE 2
         L     WKREG1,XTLMSBAA         GET ADDRESS TO BE FREED
         SPACE 2
*/* D (NO,ORDERCDQ,YES,) IS EXTENT LIST COMPLETE? */
         SPACE 2
         LTR   WKREG1,WKREG1           Q. IS EXTENT LIST COMPLETE
*                                      (IF MODULE NIC LIST MAY NOT BE)
         BZ    ORDERCDQ                A. NO- DO NOT TRY TO FREE MOD.
         SPACE 2
*/* D (NO,NOTSPZ,YES,) SUBPOOL 0 MODULE? */
         SPACE 2
         TM    CDATTR2,CDSPZ           Q. SUBPOOL 0 MODULE
         BZ    NOTSPZ                  A. NO- TRY JPA
         SPACE 1
*  SPECIAL CODE TO FREE MULTIPLE EXTENTS FOR OS LOADER SUPPORT
         SPACE 1
*/* P GET NUMBER OF ENTRIES IN XL */
         SPACE 2
         L     R10,XTLNRFAC            GET NUMBER OF ENTRIES
         SPACE 2
*/* P CALCULATE ADDRESS OF ADDRESS FIELDS */
         SPACE 2
         LA    R2,XTLMSBLA             GET ADDRESS OF SIZE
         DROP  XLREG                   DONT NEED XTLST ANY LONGER
         LR    R9,R2                   SET UP FOR ADDRESS FIELD
         SLL   R10,N2                  MULTIPLY BY FOUR          M03270
         AR    R9,R10                  ADDR. IN R9               M03270
         SRL   R10,N2                  RESET TO COUNT OF ENTRIES M03270
         L     ASCBREG,PSAAOLD         GET ASCB FOR FREEMAIN
         SPACE 2
*/* FREE: L FREEMAIN-- FREE SEGMENT OF MODULE FROM SUBPOOL 0 */
         SPACE 2
FREE     L     LNG,N0(R2)              GET ACTUAL LENGTH
         L     ADDR,N0(R9)             GET ACTUAL ADDRESS
         FREEMAIN RC,LV=(R0),A=(R1),SP=Q250,BRANCH=YES  FREE EXTENT
         SPACE 2
*/* P CALCULATE NEXT LENGTH AND ADDRESS FIELDS */
         SPACE 2
         LA    R2,N4(R2)               GET NEXT LENGTH
         LA    R9,N4(R9)               GET NEXT ADDRESS
         SPACE 2
*/* P DECREMENT NO. OF EXTENTS TO GO BY ONE */
*/* D (YES,FREE,NO,CDSSNOP) ANY MORE EXTENTS? */
         SPACE 2
         BCT   R10,FREE                IF MORE EXTENTS, FREE ONE M03270
         B     CDSSNOP                 GO FREE MODULE
         SPACE 2
*/*NOTSPZ: D (YES,,NO,LPAMOD) MODULE IN SP251? */
         SPACE 2
NOTSPZ   TM    CDATTR,CDJPA            Q. MODULE IN 251
         BZ    LPAMOD                  A. NO-SET TO 252
         SPACE 2
*/* P (,FREEMOD) SET SUBPOOL FOR FREEMAIN TO 251 */
         SPACE 2
         LA    WKREG0,Q251             A. YES- SET SUBPOOL TO 251
         B     FREEMOD                 GO FREE MODULE
         SPACE 2
*/*LPAMOD: P SET SUBPOOL FOR FREEMAIN TO 252 */
         SPACE 2
LPAMOD   LA    WKREG0,Q252             SET SUBPOOL FOR FREE TO 252
         SPACE 2
*/*FREEMOD: L FREEMAIN-- FREE MODULE */
         SPACE 2
FREEMOD  EQU   *
         LTR   CDEMAJR,CDEMAJR         TEST LEFT-MOST BIT FOR @ZA09239
         BNM   NOTRM                   RESOURCE MANAGER ENTRY @ZA09239
         L     R7,TCBJSTCB             IF YES, SET TCBEOTFM   @ZA09239
         OI    276(R7),X'80'           IN JOB STEP TCB        @ZA09239
NOTRM    L     ASCBREG,PSAAOLD         GET ASCB FOR GETMAIN   @ZA09239
*
*   FREE MODULE BEING DELETED OR WHICH ISSUED EXIT.
*   MODULE LENGTH AND ADDRESS IS OBTAINED FROM THE EXTENT LIST
*   MODULE SUBPOOL IS DETERMAINED FROM CDE ATTRIBUTES
*
         FREEMAIN RC,LV=(WKREG2),A=(WKREG1),SP=(WKREG0),BRANCH=YES
*
         L     R7,TCBJSTCB             GET POINTER TO JSTCB   @ZA09239
         TM    276(R7),X'80'           TCBEOTFM TURNED ON?    @ZA09239
         BZ    NOEOTFM                 NO. LEAVE IT ALONE.    @ZA09239
         LTR   CDEMAJR,CDEMAJR         TURNED ON BY ME?       @ZA09239
         BNM   NOEOTFM                 NO. LEAVE IT ALONE     @ZA09239
         XI    276(R7),X'80'           YES. TURN IT OFF       @ZA09239
NOEOTFM  L     ASCBREG,PSAAOLD         RESTORE REG 7          @ZA09239
         SPACE 2
*/*CDSSNOP: P DSS HOOK */
         SPACE 2
CDSSNOP  BCR   NULL,NULL               DSS HOOK AFTER MODULE IS FREED
*
         SPACE 2
*/*ORDERCDQ: P GET JOB PACK QUEUE HEADER FROM JSTCB */
         SPACE 2
ORDERCDQ LA    CDEMAJR,0(CDEMAJR)      CLEAR HIGH ORDER BYTE  @ZA09239
         L     WKREG1,TCBJSTCB         GET JOB STEP TCB
         LA    WKREG1,TCBJPQ-TCB(WKREG1)  GET JOB PACK QUEUE POINTER
         SPACE 2
*/* S (FND,,NOTF,GETOUT) CDESRCH:SEARCH JPQ FOR MODULE */
         SPACE 2
         BAL   RETURN,CDESRCH          TEST IF CDE IS ON JPQ
         B     GETOUT                  WAS NOT ON JPQ
         SPACE 2
*/* S (,EXITSRCH) REMOVAL:DEQUEUE CDE */
         SPACE 2
         BAL   RETURN,REMOVAL          MOD FOUND, GO DEQUEUE IT
         B     EXITSRCH                GO TO COMMON TERMINATION CODE
         SPACE 2
*/*LPAONLY: P INITIALIZE REGISTERS FOR LPA SERACH */
         SPACE 2
LPAONLY  DS    0H                      SEARCHES LPA FOR MODULE
         L     CVTREG,CVTPTR           INSURE CVT IN PROPER REG.
         L     WKREG1,CVTQLPAQ         GET LPAQ POINTER
         SPACE 2
*/* S (FND,,NOTF,ERROR) CDESRCH:SEARCH LPA QUEUE FOR MODULE */
         SPACE 2
         BAL   RETURN,CDESRCH          SEARCH LPAQ
         B     ERROR                   IS NOT FOUND ON ANY QUEUE
         SPACE 2
*/* S REMOVAL:DEQUEUE CDE */
         SPACE 2
         BAL   RETURN,REMOVAL          REMOVE MAJOR AND MINORS FROM QUE
         SPACE 2
*/* P SAVE VOLITAL REGISTERS OVER SETLOCK */
         SPACE 2
         LR    WKREG1,CDEREG           SAVE REGISTER OVER SETLOCK
         LR    WKREG0,CDEMAJR          SAVE MAJOR CDE OVER SETLOCK
         LR    WKREG2,SAVEREG          SAVE SAVE AREA OVER SETLOCK
         SPACE 2
*/* L SETLOCK-- RELEASE CMS LOCK */
         SPACE 2
         SETLOCK RELEASE,TYPE=CMS,RELATED=LPAONLY ROUTINE
         SPACE 2
*/* P RESTORE VOLITAL REGISTERS */
         SPACE 2
         LR    CDEREG,WKREG1           RESTORE SAVED REGISTER
         LR    CDEMAJR,WKREG0          RESTORE MAJOR CDE POINTER
         LR    SAVEREG,WKREG2          RESTORE SAVE AREA POINTER
         SPACE 2
*/*EXITSRCH: P GET EXTENT LIST (XL) */
         SPACE 2
EXITSRCH DS    0H                      FREES EXTENT LIST, CDE
         L     WKREG1,CDXLMJP          GET EXTENT LIST
         LA    WKREG1,0(WKREG1)        CLEAR HIGH BYTE IN CASE
*                                      FETCH SET IT ON
         SPACE 2
*/* D (NO,CDDMLP,YES,) EXTENT LIST EXIST? */
         SPACE 2
         LTR   WKREG1,WKREG1           Q. EXTENT LIST EXIST
         BZ    CDDMLP                  A. NO- DO NOT TRY TO FREE IT
         SPACE 2
*/* P GET LENGTH OF EXTENT LIST AND ASCB ADDRESS FOR FREEMAIN */
         SPACE 2
         L     ASCBREG,PSAAOLD         GET ASCB FOR FREEMAIN
         L     WKREG0,XTLLNTH-XTLST(WKREG1) GET LENGTH OF EXTENT LIST
         SPACE 2
*/* L FREEMAIN-- FREE EXTENT LIST FROM SP255 */
         SPACE 2
         FREEMAIN RC,LV=(WKREG0),A=(WKREG1),SP=255,BRANCH=YES
         SPACE 2
*/*CDDMLP: P GET ASCB ADDRESS FOR FREEMAIN */
         SPACE 2
CDDMLP   L     ASCBREG,PSAAOLD         GET ASCB FOR FREEMAIN
         SPACE 2
*/*CDDMLP1: P GET ADDRESS OF NEXT CDE TO BE FREED (N+1) */
         SPACE 2
CDDMLP1  L     WKREG2,CDCHAIN          GET NEXT CDE TO BE FREED
         SPACE 2
*/* L FREEMAIN-- FREE CDE FROM SUBPOOL 255 (LSQA) */
*/* P NOTE: IF REQ'ST FROM SP255 AND ADDR. IS IN SP245, FREE IS
*/* FROM SQA(245) */
         SPACE 2
         FREEMAIN RU,LV=CDESIZE,A=(CDEMAJR),SP=255,BRANCH=YES
         SPACE 2
*/* D (YES,,NO,GETOUT) ANY MORE CDE'S TO BE FREED? */
         SPACE 2
         LTR   WKREG2,WKREG2           Q. ANY MORE CDE'S
         BZ    GETOUT                  A. NO-FINISH
         SPACE 2
*/* P (,CDDMLP1) GET NEXT CDE TO FREE IN WORK REG */
         SPACE 2
         LR    CDEMAJR,WKREG2          SET UP TO FREE NEXT MINOR
         B     CDDMLP1                 LOOP
         SPACE 2
*/*GETOUT: P RESET RETURN REGISTER */
         SPACE 2
GETOUT   LR    RETURN,R6               RESTORE RETURN REGISTER
         SPACE 2
*/* R RETURN R14 */
         SPACE 2
         BR    RETURN                  EXIT
         TITLE '          IEAVLK02 - CKHKEEP SUBROUTINES'
*   NAME - CDESRCH
*
*   PURPOSE - THIS SUBROUTINE SEARCHES THE JPQ OR LPQ FOR A SPECIFIED
*        CDE.  WHEN FOUND, CONTROL IS RETURNED TO R14+4. IF NOT FOUND,
*        CONTROL IS RETURNED TO R14+0.
*
*   INPUT - R1 = ADDRESS OF QUEUE TO BE SEARCHED
*        R11 = ADDR. OF MAJOR CDE REQUESTED
*        R14 = RETURN ADDRESS (MUST BE BRANCH TABLE)
*
*   OUTPUT - R2 = CDE REQUESTED
*        R1  = ADDRESS OF PREVIOUS CDE ON QUEUE
*        ALL OTHER REGISTERS REMAIN AS ON ENTRY
         SPACE  2
*/*CDESRCH: E CDESRCH */
*/* P GET NEXT CDE */
         SPACE 2
CDESRCH  DS    0H                      SEARCH CDE QUEUE FOR ADDRESS
         L     WKREG2,CDCHAIN-CDENTRY(WKREG1) GET NEXT CDE
         LA    WKREG2,N0(WKREG2)       CLEAR HIGH BYTE
         SPACE 2
*/* D (YES,%RET1,NO,) DOES THIS CDE = SUBJ CDE? */
         SPACE 2
         CR    WKREG2,CDEMAJR          DOES CDE ON QUEUE = SUBJECT CDE
         BC    EQUAL,N4(RETURN)        YES- RETURN TO CALLER
         SPACE 2
*/* D (YES,%RET2,NO,) END OF QUEUE? */
         SPACE 2
         LTR   WKREG2,WKREG2           Q. IS THIS END OF QUEUE
         BCR   EQUAL,RETURN            A. YES-RETURN TO CALLER
         SPACE 2
*/* P (,CDESRCH) SET UP LOOP REGISTER */
         SPACE 2
         LR    WKREG1,WKREG2           UP POINTER TO NEXT CDE
         B     CDESRCH                 A. NO- CONTINUE SEARCH
         SPACE 2
*/*%RET1: R RETURN R14 +4 */
*/*%RET2: R RETURN R14 */
         SPACE 2
         EJECT
*   NAME - REMOVAL
*
*   PURPOSE - THIS ROUTINE REMOVES A GIVEN CDE AND ITS MINORS FROM A
*        CDE QUEUE
*
*   INPUT - R1 = ADDRESS OF THE PREVIOUS CDE TO THE ONE BEING REMOVED
*        R2  = ADDRESS OF THE MAJOR CDE TO BE REMOVED
*        R14 = RETURN ADDRESS
*
*   OUTPUT - R3 = ADDRESS OF LAST CDE REMOVED FROM QUEUE
*            R2 = 0
*        ALL OTHER REGISTERS ARE UNCHANGED
         SPACE  2
*/*REMOVAL: E REMOVAL */
         SPACE 2
REMOVAL  DS    0H                      DEQUEUES CDE MAJOR AND ITS
*                                      ASSOCIATED MINORS
         SPACE 2
*/* P SAVE CURRENT CDE (R3=R2) */
*/* P GET NEXT CDE (R2=CDCHAIN(R2)) */
         SPACE 2
         LR    LASTCDER,WKREG2         SAVE CURRENT CDE TO 0   @ZA04838
*                                      OUT CDCHAIN OF LAST     @ZA04838
*                                      CDE REMOVED             @ZA04838
         L     WKREG2,CDCHAIN-CDENTRY(WKREG2)  BEGIN SEARCH FOR END
         SPACE 2
*/* D (YES,OCNT,NO,) END OF CDE QUEUE? */
         SPACE 2
         LTR   WKREG2,WKREG2           OF MINOR QUEUE
         BZ    OCNT                    GO DEQUEUE
         SPACE 2
*/* D (YES,REMOVAL,NO,) IS CDE A MINOR? */
         SPACE 2
         TM    CDATTR-CDENTRY(WKREG2),CDMIN Q. MINOR ENTRY
         BO    REMOVAL                 A. YES- CONTINUE SEARCH
         SPACE 2
*/*OCNT: P UPDATE THE CDE QUEUE BY REMOVING MAJOR AND ASSOCIATED MINORS
*/* */
*/* P ZERO CDCHAIN OF LAST CDE REMOVED */
         SPACE 2
OCNT     ST    WKREG2,CDCHAIN-CDENTRY(WKREG1) UPDATE THE QUEUE BY
*                                      REMOVING MAJOR AND ALL MINORS
         SR    WKREG2,WKREG2           ZERO FOWARD POINTER     @ZA04838
         ST    WKREG2,CDCHAIN-CDENTRY(LASTCDER) OF THE LAST    @ZA04838
*                                      CDE DEQUEUED FOR        @ZA04838
*                                      CDHKEEPI FREEING CDES   @ZA04838
         SPACE 2
*/* R RETURN TO CALLER */
         SPACE 2
         BR    RETURN                  RETURN TO CALLER
         SPACE 5
*/*ERROR: P SAVE REG 13 OVER INTERFACE */
         SPACE 2
ERROR    DS    0F
         LR    WKREG1,SAVEREG          SAVE R13 OVER SETLOCK
         SPACE 2
*/* L SETLOCK-- RELEASE CMS LOCK */
         SPACE 2
         SETLOCK RELEASE,TYPE=CMS,RELATED=LPAONLY ROUTINE
         SPACE 2
*/* P RESTORE REG 13 */
         SPACE 2
         LR    SAVEREG,WKREG1          RESTORE SAVE AREA REGISTER
         SPACE 2
*/* P (,GETOUT) SET RETURN CODE = 4 */
         SPACE 2
         LA    R15,N4                  ERROR RETURN CODE
         B     GETOUT                  *****  ERROR *****
         SPACE 2
*/* FOOTING
*/*
*/*  */
*/*IEAVLK02: END */
         TITLE '       IEAVLK02   GENERAL MODULE EQUATES AND CONSTANTS'
AMODENT  DC    A(MODENT)               USED FOR BASE VALUE
AIEAQCS2 DC    V(IEAQCS02)             ENTRY TO PGM. MGR. FOR RESTART
AIEAQCS3 DC    V(IEAQCS03)             ENTRY TO PGM. MGR.
FRREXIT  DC    A(FRRPGMX)              RECOVERY ROUTINE ADDRESS
         EJECT
FRRPLIST DSECT                         FRR PARM LIST           @ZA02733
FRRPLWD0 DS    0F                      WORD ZERO               @ZA02733
FRRPLSAV DS    F                       SAVE AREA ADDRESS       @ZA02733
FRRPLWD1 DS    0F                      WORD ONE                @ZA02733
FRRPLBAS DS    F                       IEAVLK02 BASE ADDRESS   @ZA02733
FRRPLWD2 DS    0F                      WORD TWO                @ZA02733
FRRPLR11 DS    F                       GR11 SAVE AREA          @ZA02733
FRRPLWD3 DS    0F                      WORD THREE              @ZA02733
FRRPLR12 DS    F                       GR12 SAVE AREA          @ZA02733
FRRPLWD4 DS    0F                      WORD FOUR               @ZA02733
FRRPLR13 DS    F                       GR13 SAVE AREA          @ZA02733
FRRPLWD5 DS    0F                      WORD FIVE               @ZA02733
FRRPLCHK DS    0F                      PROGRESS CHECK WORD     @ZA02733
FRRPLCK0 DS    B                       EOTCHK CHECK POINT      @ZA02733
FRRPLCK1 DS    B                       RESERVED                @ZA02733
FRRPLCK2 DS    B                       RESERVED                @ZA02733
FRRPLCK3 DS    B                       RESERVED                @ZA02733
         TITLE '       IEAVLK02 MAPPING MACROS'
         IHACDE
CDEEND   EQU   *
CDESIZE  EQU   CDEEND-CDENTRY          SIZE OF CDE
         EJECT
         CVT   DSECT=YES,PREFIX=NO
         EJECT
         IHAPSA
         EJECT
         IHAFRRS
         EJECT
         IHALLE
LLEND    EQU   *
LLESIZE  EQU   LLEND-LLE               SIZE OF LLE
         EJECT
         IHARB
*******************************************************************
*
*                REQUEST BLOCK ADDITIONAL LABELS INTERNAL
*
******************************************************************
         ORG   RBEXSAVE                MAPPED INTO THE RBEXSAVE AREA
RBCSEXSA EQU   *                       CONTENTS SUPERVISOR USAGE OF
*                                      RB EXTENDED SAVE AREA FOR
*                                      REENTRANT DATA AREA
RBCSNAME DS    CL8                     ENTRY POINT NAME CALLER PASSED
RBCSDE   DS    0A                      ADDRESS OF DE SAVE AREA
         DS    C                       BYTE RESERVED
RBCSDEA  DS    AL3                     3 BYTE ADDRESS
RBCSERRA DS    F                       ADDRESS OF ERROR ROUTINE
RBCSFLG1 DS    B                       FLAG BYTE
RBCSGSF  EQU   X'80'                   GOOD SEARCH INDICATOR
*                                      ON MEANS IEAVVMSR WAS
*                                      SUCCESSFUL USED ONLY
*                                      IEAVLK01
RBCSSYSR EQU   X'40'                   SYSTEM REQUEST FLAG
RBCSPARM EQU   X'20'                   PARMATER CHECKING IN PROGRESS
RBCSERIN EQU   X'10'                   ERROR RETURN WAS REQUESTED
RBCSABEN EQU   X'08'                   ISSUE 906 ABEND
RBCSA306 EQU   X'04'                   ISSUE 306 ABEND
RBCSDCB  EQU   X'02'                   DCB SPECIFIED ON INPUT
RBCSFLG2 DS    B                       RESERVED FLAGS
RBCSFLG3 DS    B                       RESERVED FLAGS
RBCSFLG4 DS    B                       RESERVED FLAGS
RBCSWORK DS    0A                      ADDRESS OF BLDL FETCH W.A.
         DS    C                       RESERVED BYTE
RBCSWRKA DS    AL3                     3 BYTE ADDRESS
RBCSLLE  DS    0A                      ADDRESS OF LLE DURING LOAD
         DS    C                       RESERVED BYTE
RBCSLLEA DS    AL3                     3 BYTE ADDRESS
RBCSFRRA DS    F                       SAVE AREA FOR RECOVERY RTN.
*                                      PARM LIST
RBCSGR15 DS    F                       SAVE AREA FOR REGS 15 TO 1
RBCSGR0  DS    F                       OVER MODESET MACRO
RBCSGR1  DS    F                       INTERFACE
RBCSRESV DS    2F                      RESERVED FOR FUTURE EXPANSION
         EJECT
         IHARMPL
         EJECT
         IKJTCB
         EJECT
         IHAXTLST
         END
