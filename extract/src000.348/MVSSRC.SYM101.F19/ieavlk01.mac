         TITLE 'IEAVLK01 COMMENTARY'
* /* START OF SPECIFICATIONS ****
*
*01*  MODULE-NAME = IEAVLK01
*
*01*  DESCRIPTIVE-NAME = BLDL/FETCH/DSS/TESTRAN INTERFACES
*              MODULE 2 OF 4
*
*01*  COPYRIGHT = NONE
*
*01*  STATUS = VERSION 2
*
*01*  FUNCTION = THIS MODULE DOES THE FOLLOWING
*
*        1. CONTROL THE ORDER OF QUEUE AND LIBRARY SEARCHES
*
*        2. INTERFACE WITH BLDL SERVICE ROUTINE (svc ENTRY)
*
*        3. INTERFACE WITH PROGRAM FETCH SERVICE ROUTINE
*                  (BRANCH ENTRY)
*
*        4. PROVIDE A SWITCH FOR DSS (ENTRY DSS06)
*
*        5. PROVIDE AN INTERFACE FOR TESTRAN (VIA SVC 61)
*
*        6. PROCESS ALIAS PDS ENTRIES SO THAT MAJOR NAME MODULES
*            THAT ARE IN CORE WILL BE REUSED, OR FETCHED
*
*        ORDER OF SEARCHES:
*              NO PDS ENTRY PASSED BY USER
*        (SR.NON-DE1) 1. JOB PACK AREA (IN IEAVLK00)
*        (SR.NON-DE2) 2. IF DCB PASSED SPECIFIC LIBRARY IS SEARCHED
*                         VIA BLDL
*        (SR.NON-DE3) 3. IF DCB=0 JOB LIBRARIES ARE SEARCHED VIA BLDL
*        (SR.NON-DE4) 4. ACTIVE LINK PACK AREA QUEUE (IN IEAVLK00)
*        (SR.NON-DE6) 5. PAGEABLE LPA LPDE DIRECTORY
*        (SR.NON-DE7) 6. LINK LIBRARY
*
*              PDS PASSED BY USER (DE-FORM)
*        (SR.DE1)     1. JOB PACK AREA (IN IEAVLK00)
*        (SR.DE2)     2. IF DE IS FOR LINK LIBRARY OR SVC LIBRARY
*                         THE LPAQ IS SEARCHED, THEN STEP 3.
*                         IS DONE. OTHERWISE SKIP TO STEP 4
*        (SR.DE3)     3. THE LPDES ARE SEARCHED
*        (SR.DE4)     4. IF DCB SUPPLIED FETCH MODULE FROM LIBRARY
*        (SR.DE5)     5. IF NO DCB, USE Z-BYTE TO LOCATE LIBRARY
*
*02*     OPERATION = RECOVERY IS HANDLER BY AN FRR WHICH IS
*        RESIDENT IN THE NUCLEUS IN MODULE IEAVLK03
*
*01*   NOTES = THE FOLLOWING IS A DESCRIPTION OF THE DEPENDENCIES AND
*      CONVENTIONS
*
*02*     DEPENDENCIES = NONE
*
*02*     RESTRICTIONS = NONE
*
*02*     REGISTER-CONVENTIONS = THE REGISTER CONVENTIONS USED BY
*        IEAVLK01 ARE DESCRIBED UNDER THE TOPIC 'GENERAL REGISTER
*        EQUATES'.
*
*02*     PATCH-LABEL = THIS MODULE IS RESIDENT NUCLEUS, AND HAS NO
*        PATCH SPACE.
*
*01*  MODULE-TYPE = MODULE
*
*02*     PROCESSOR = ASSEMBLER
*
*02*     MODULE-SIZE = 2324 BYTES, X'914'
*
*02*     ATTRIBUTES = NUCLEUS
*            REENTERABLE
*            SUPERVISOR MODE
*
*01*  ENTRY-POINT = IEAVLK01
*
*02*     PURPOSE = SEARCH DCB'S AS REQUIRED, BEGIN SEARCH FOR LPAQ IF
*        NECESSARY
*
*02*     LINKAGE = IEAVLK01 IS BRANCH ENTERED BY IEAVLK00
*
*02*     INPUT = FROM IEAVLK00
*
*        REGISTERS
*              R0 - LEFT HALF OF NAME
*              R1 - RIGHT HALF OF NAME
*              R4 - TCB ADDRESS
*              R5 - SVRB ADDRESS
*              R6 - BASE (IEAVLK01)
*              R8 - ADDRESS OF LAST CDE QUEUE SEARCHED
*              R9 - ADDRESS OF NAME
*              R10- DCB ADDRESS
*              OTHER REGISTERS NOT USED
*              SVRB EXSAVE FULLY INITIALIZED
*
*02*     OUTPUT = NONE
*
*02*     REGISTERS-SAVED = NONE
*
*01*  ENTRY-POINT = DSS06
*
*02*     PURPOSE = SWITCH (NOP) USED TO ALLOW DSS TO RECORD
*        INFORMATION AFTER EACH MODULE IS FETCHED. - NOT PART OF NORMAL
*        MODULE FLOW
*
*02*     LINKAGE = THE NOP IS CHANGED TO AN UNCONDITIONAL BRANCH TO DSS
*        BY THE DSS INITIALIZATION ROUTINE WHEN DSS BECOMES ACTIVE.
*        THIS ENTRY IS USED ONLY BY DSS.
*
*02*     INPUT = SEE MINI-PROLOGUE BEFORE DSS NOP INSTRUCTION
*
*02*     OUTPUT = NONE
*
*01*  EXIT-NORMAL
*
*02*     CONDITIONS = TO CDCONTRL (TO SEARCH LPAQ)
*
*02*     OUTPUT = REGISTERS
*              R3,4,5 - CVT,TCB,SVRB
*              R6     - BASE FOR IEAVLK00
*              R8     - CDE QUEUE ORIGIN TO SEARCH
*              R9     - ADDRESS OF NAME
*              R10    - DCB ADDRESS
*              OTHER REGISTERS NOT USED
*              SVRB EXSAVE FULLY INITIALIZED
*
*02*     RETURN-CODES = NONE
*
*01*  EXIT-NORMAL
*
*02*     CONDITIONS = TO CDEMERGE (TO EXIT TO FOUND MODULE)
*
*02*     OUTPUT = REGISTERS
*              R3,4,5 - CVT,TCB,SVRB
*              R6     - BASE FOR IEAVLK00
*              R11    - REQUESTED CDE
*              R12    - MAJOR CDE FOR REQUEST
*              OTHER REGISTERS NOT USED
*              SVRB EXSAVE FULLY INITIALIZED
*
*02*     RETURN-CODES = NONE
*
*01*  EXIT-NORMAL
*
*02*     CONDITIONS = TO CDQUECTL (TO QUEUE AN ALIAS REQUEST BEING
*        FETCHED UNDER MAJOR NAME)
*
*02*     OUTPUT = REGISTERS
*              R3,4,5 - CVT,TCB,SVRB
*              R6     - BASE FOR IEAVLK00
*              R8     - CDE QUEUE ORIGIN TO SEARCH
*              R9     - ADDRESS OF NAME
*              R10    - DCB ADDRESS
*              R11    - CDE FOR REQUEST
*              R12    - MAJOR CDE FOR REQUEST
*              OTHER REGISTERS NOT USED
*              SVRB EXSAVE FULLY INITIALIZED
*
*02*     RETURN-CODES = NONE
*
*01*  EXIT-NORMAL
*
*02*     CONDITIONS = TO PLUSCONT (TO CHECK USABILITY OF FOUND MAJOR)
*
*02*     OUTPUT = REGISTERS
*              R0     - LEFT HALF OF NAME
*              R1     - RIGHT HALF OF NAME
*              R3,4,5 - CVT,TCB,SVRB
*              R6     - BASE FOR IEAVLK00
*              R8     - ADDRESS OF CDE QUEUE
*              R9     - ADDRESS OF NAME
*              R10    - DCB ADDRESS
*              R11    - CDE FOR REQUEST
*              R12    - MAJOR CDE FOR REQUEST
*              OTHER REGISTERS NOT USED
*              SVRB EXSAVE FULLY INITIALIZED
*
*02*     RETURN-CODES = NONE
*
*01*  EXIT-ERROR = ABNDSET
*
*02*     CONDITIONS = TO ISSUE THE FOLLOWING ABENDS
*              106 - FETCH ERROR- R15=E - ADDRESS ERROR
*                                    =F - I/O ERROR
*              306 - AN AUTHORIZED ROUTINE ATTEMPTED TO USE
*                       NON-AUTHORIZED LIBRARY MODULE.
*              406 - LOADABLE ONLY MODULE ON NON-LOAD REQUEST
*              706 - NON-EXECUTABLE MODULE FLAGGED BY LINKAGE EDITOR
*              806 - BLDL ERROR - R15=4 MODULE NOT FOUND
*                                    =8 I/O ERROR
*                                    =C NOT FOUND IN LPAQ OR LPDES
*                                    =10 DCB FOR BLDL NOT OPEN @ZA18512
*
*02*     OUTPUT = REGISTERS
*              R13 - ABEND CODE (1,3,4,7, OR 8)
*              R15 - REASON CODE IF 106, 306, OR 806 ABEND
*              OTHER REGISTERS NOT USED
*              SVRB EXSAVE FULLY INITIALIZED
*
*02*     RETURN-CODES = NONE
*
*01*  EXTERNAL-REFERENCES = THE FOLLOWING EXTERNAL REFERENCES ARE MADE
*
*02*     ROUTINES =
*        1. IEAQCS04 - START OF RETURN ADDRESS TABLE IN IEAVLK00
*        2. IEAQCS02 - RESTART ADDRESS FOR NOT IN CORE QUEUED MODULES
*        3. LINKDCB  - LINK LIBRARY OPENED DCB
*        4. SVCDCB   - SVC LIBRARY OPENED DCB
*        5. IEWMSEPT - BRANCH ENTRY TO FETCH
*        6. IEAQLPAQ - LINK PACK QUEUE ORIGIN
*        7. POST W/O ECB - RESTART NIC REQUESTS
*
*02*     DATA-AREAS = THE FOLLOWING DATA AREAS ARE USED BY IEAVLK01
*              1. DE SAVE AREA- CONTAINS THE DIRECTORY ENTRY, IN LSQA
*              2. FETCH/PGM. MGR. WORK AREA- CONTAINS FETCH IOB,
*                 INTERFACE INFORMATION, AND THE BLDL ENTRY
*
*02*     CONTROL-BLOCKS = THE FOLLOWING CONTROL BLOCKS ARE USED
*        1. CDE (C)  - CONTENTS DIRECTORY ENTRY
*        2. PDS (R)  - PARTITIONED DATA SET DIRECTORY ENTRY
*        3. TCB (R)  - TASK CONTROL BLOCK
*        4. RB  (R)  - REQUEST BLOCK (MODULE)
*        5. CVT (R)  - COMMUNICATIONS VECTOR TABLE
*        6. LPDE (R) - LINK PACK DIRECTORY ENTRY
*        7. PSA (R)  - OBTAIN LOW CORE ADDRESSES (TCB,ASCB)
*        8. IHAFRRS (R) - RECPVERU STACK
*        9. ASCB (R) - ADDRESS SPACE CONTROL BLOCK
*       10. ASXB (R) - ADDRESS SPACE EXTENTION
*
*01*  TABLES = NONE
*
*01*  MACROS = MACROS USED ARE
*              BLDL,CVT,FREEMAIN,GETMAIN,IEZBITS,IEZDEB,IEZJSCB,
*              IHAASCB,IHACDE,IHAFETWK,IHAFRRS,IHALPDS,
*              IHAPSA,IHARB,IKJTCB,MODID,SETFRR,SETLOCK,TESTAUTH
*
*02*    SERIALIZATION = THE CMS LOCK IS OBTAINED TO DO LPAQ SEARCH. THE
*       LOCAL LOCK IS FREED AND REOBTAINED FOR SVC INTERFACES AND FOR
*       FETCH.
*
*01*  CHANGE-ACTIVITY = SUPPORT CODE FOR RELEASE 2 = Y02758
*                       OZ03829 OZ03896 - RELEASE 4
*                       OZ07512 OZ08130
*                       OZ10834
*                       OZ12661 - SEE LABEL JSCBOFF
*                       OZ18512 - CHECK FOR OPEN DCB BEFORE ISSUING THE
*                                 BLDL SVC (SVC 12)            @ZA18512
*                       OZ20311 - FREE CDE(S) AND EXTENT LIST IF ERRET
*                                 WAS SPECIFIED                @ZA20311
*                       OZ24461 - CONTINUE SEARCH IF AN AUTHORIZED COPY
*                                 OF A MODULE IS REQUIRED AND AN
*                                 UNAUTHORIZED COPY IS FOUND UNTIL
*                                 LINKLIB HAS BEEN SEARCHED OR AN
*                                 AUTHORIZED COPY IS FOUND BY MOVING
*                                 JSCBOFF ROUTINE UP TO DEFOUND ROUTINE
*                                 IMMEDIATELY AFTER THE BLDL  @ZA24461
*                       OZ24951 - CHECK RESET APF WHEN ATTACH IS NOT A
*                                 JOBSTEP ATTACH               @ZA24951
*                       OZ26977 - REINITIALIZE POINTER TO FETCH WA
*                                 AFTER CALL TO IEWFETCH       @ZA26977
*                       OZ28734 - IF DE OPTION SPECIFIED ON REQUEST AND
*                                 REQUESTOR IS AUTHORIZED BUT LIBRARY
*                                 SPECIFIED OR DEFAULTED IS NOT AUTHOR
*                                 IZED ABEND 306-C WILL RESULT @ZA28734
*                       OZ28886 - RESTORE THE POINTER TO THE WORK AREA
*                                 BEFORE LOADING THE ABEND AND REASON
*                                 CODE REGISTERS.              @ZA28886
*                       OZ26582 - CHECK IF DE FORM OF MACRO IS USED
*                                 AND, IF SO, CHECK IF UNAUTHORIZED
*                                 USER REFERENCING AUTHORIZED LIBRARY;
*                                 IF SO, ISSUE BLDL            @ZA26582
*                       OZ28494 - PERFORM DEBCHECK TO VERIFY THE DCB
*                                 ADDRESS IS VALID             @ZA28494
*                       OZ30995 - IF ATTACH WITH THE DE OPTION WAS
*                                 ISSUED, LOCATE THE MOTHER TCB THAT
*                                 WAS RUNNING WHEN THE BLDL WHICH
*                                 CREATED THE DE WAS ISSUED, SO THAT
*                                 THE PROPER DCB CAN BE FOUND  @ZA30995
*
*01*  MESSAGES = NONE
*
*01*  ABEND-CODES = SEE ERROR EXIT FOR ABENDS ISSUED IN IEAVLK01
*
**** END OF SPECIFICATIONS ***/
         EJECT
*/*IEAVLK01: CHART (AMODE,AREF) */
*/* HEADER
*/* PROGRAM MANAGER SEARCH
*/*                                                   SECTION 3.1.11
*/* SEQUENCE AND FETCH ROUTINES
*/*                                                   PAGE # */
*/* E IEAVLK01 */
         SPACE 2
IEAVLK01 CSECT                         CSECT NAME  **** SINGLE CSECT
         USING *,BASEREG               ADDRESSABILITY PASSED BY VLK00
         MODID BR=YES                   SET MODULE IDENTIFIER
         TITLE  '            IEAVLK01  EXTERNAL REFERENCES'
         ENTRY DSS06                   DSS HOOK ENTRY
         EXTRN IEAQCS04                POINTS TO ADDRESS LIST IN VLK00
         EXTRN IEAQCS02                RESUME ADDRESS IN VLK00
         EXTRN LINKDCB                 DCB FOR LINK LIBRARY
         EXTRN SVCDCB                  DCB FOR SVC LIBRARY
         EXTRN IEWMSEPT                PROGRAM FETCH ENTRY POINT
         EXTRN IEAQLPAQ                LPAQ QUEUE ORIGIN
         EXTRN FRRPGMMG                PGM. MGR RECOVERY RTN
         TITLE 'IEAVLK01 GENERAL REGISTER EQUATES'
*                                      EQUATES FOR REGISTER 0
R0       EQU   0                       CROSS REFERENCE EQUATE
GR0      EQU   R0                      GENERAL USE REGISTER 0
ZREG     EQU   R0                      LIBRARY COUNT FOR DCB=0 CASE
*                                      REGISTER 1 EQUATES
R1       EQU   1                       CROSS REFERENCE EQUATE
TASKREG  EQU   R1                      POINTS TO A TCB MOTHER
WKREG1   EQU   R1                      GENERAL WORK REGISTER
GR1      EQU   R1                      GENERAL WORK REGISTER
TASKLVL  EQU   R1                      TASK LEVEL TCB ADDRESS
*                                      REGISTER 2 EQUATES
R2       EQU   2                       CROSS REFERENCE EQUATE
WKREG2   EQU   R2                      GENERAL WORK REGISTER
SAVETCB  EQU   R2                      TSO SAVE TCB REG
*                                      REGISTER 3 EQUATES
R3       EQU   3                       CROSS REFERENCE EQUATE
COMREG   EQU   R3                      RELOCATE SUBROUTINE RETURN REG
CVTREG   EQU   R3                      POINTS TO CVT
*                                      REGISTER 4 EQUATES
R4       EQU   4                       CROSS REFERENCE EQUATE
TCBREG   EQU   R4                      POINTS TO TCB
*                                      REGISTER 5 EQUATES
R5       EQU   5                       CROSS REFERENCE EQUATE
RBREG    EQU   R5                      POINTS TO SVRB OF CONTENTS
*                                      REGISTER 6 EQUATES
R6       EQU   6                       CROSS REFERENCE EQUATE
BASEREG  EQU   R6                      BASEREG FOR THIS MODULE
*                                      REGISTER 7 EQUATES
R7       EQU   7                       CROSS REFERENCE EQUATE
GR7      EQU   R7                      FETCH INTERFACE REGISTER
AREAREG  EQU   R7                      POINTS TO BLDL-FETCH WORK AREA
ASCBREG  EQU   R7                      ASCB REG FOR GETMAIN/FREEMAIN
*                                      REGISTER 8 EQUATES
R8       EQU   8                       CROSS REFERENCE EQUATE
DEBREG   EQU   R8                      DEB POINTER FROM DEBCHK @ZA28494
TABREG   EQU   R8                      QUEUE POINTER FOR SEARCHES
*                                      REGISTER 9 EQUATES
R9       EQU   9                       CROSS REFERENCE EQUATE
LPDIREG  EQU   R9                      MAJOR LPDE POINTER
GR9      EQU   R9                      BLDL INTERFACE REGISTER
NAMEREG  EQU   R9                      NAME IS POINTED TO BY THIS REG
LAST     EQU   R9                      RB POINTER DURING DQLOAD
*                                      REGISTER 10 EQUATES
R10      EQU   10                      CROSS REFERENCE EQUATE
NEXT     EQU   R10                     POINTS TO RB DURING DQLOAD
GR10     EQU   R10                     BLDL INTERFACE REGISTER
DCBREG   EQU   R10                     POINTS TO DCB FOR LIB TO SEARCH
*                                      REGISTER 11 EQUATES
R11      EQU   11                      MAINLAND WORK REGISTER
GR11     EQU   R11                     TASK SWITCH INTERFACE REGISTER
CDEREG   EQU   R11                     CDE FOR REQUESTED NAME
*                                      REGISTER 12 EQUATES
R12      EQU   12                      CROSS REFERENCE EQUATE
GR12     EQU   R12                     GENERAL WORK REGISTER
CDIREG   EQU   R12                     POINTS TO MAJOR CDE FOR REQUEST
*                                      REGISTER 13 EQUATES
R13      EQU   13                      CROSS REFERENCE EQUATE
RETURND  EQU   R13                     SUBROUTINE RETURN REGISTER
GR13     EQU   R13                     GENERAL WORK REGISTER
*                                      REGISTER 14 EQUATES
R14      EQU   14                      CROSS REFERENCE EQUATE
RETURN   EQU   R14                     SUBROUTINE RETURN REGISTER
GR14     EQU   R14                     GENERAL WORK REGISTER
SUBREG1  EQU   R14                     GENERAL WORK REGISTER
*                                      REGISTER 15 EQUATES
R15      EQU   15                      CROSS REFERENCE EQUATE
GR15     EQU   R15                     GENERAL WORK REGISTER
SUBREG2  EQU   R15                     GENERAL WORK REGISTER
         TITLE 'IEAVLK01 FLAG AND MASK EQUATES'
TLIBIND  EQU   X'87'                   INDICATES TASKLIB PROCESSING
MASK     EQU   X'07'                   3 BYTE ICM/STCM/CLM MASK
MASK4    EQU   X'0F'                   4 BYTE ICM/STCM/CLM MASK
MAX      EQU   X'FF'                   LARGEST ONE BYTE NUMBER
DEBAD    EQU   X'2C'                      OFFSET OF DEB INTO DCB
         TITLE 'IEAVLK01 GENERAL NUMBER VALUE EQUATES'
N0       EQU   0                       USED FOR ZERO OFFSETS
ZERO     EQU   R0                      USED FOR ZERO OFFSETS
N1       EQU   1                       USED TO INCREMENT VALUES
APFLN    EQU   1                       APF LENGTH CON        @ZA08130
N2       EQU   2                       USED TO INCREMENT ABEND VALUE
N3       EQU   3                       USED TO INCREMENT ERROR VALUES
ADDL     EQU   3                       MAXIMUM LENTGH OF AOS ADDRESSES
N4       EQU   4                       USED TO INCREMENT VALUES
WORD     EQU   4                       USED TO INCREMENT VALUES
OLD      EQU   4                       OLD TCB SLOT IN NEW/OLD SLOTS
FOUR     EQU   4                       OFFSET IN EXTENT LIST
*                                      TO NUMBER OF EXTENTS
NAME     EQU   8                       LENGTH OF AOS NAMES
N8       EQU   8                       USED AS NUMBER VALUE
EIGHT    EQU   8                       USED AS NUMBER VALUE
EQZER    EQU   8                       USED TO TEST CONDITION CODES
N12      EQU   12                      OFFSET INTO EXTENT LIST
BADRETCD EQU   12                      USED TO ISSUE RETURN CODE OF 12
DONTBLDL EQU   16                      INDICATE DCB NOT OPEN   @ZA18512
XTLSTSIZ EQU   16                      SIZE OF 1 ENTRY EXTENT LIST
TTSAVE   EQU   61                      TESTRAN SVC NUMBER
SPNONREN EQU   251                     SUBPOOL FOR NON-RENTRENT MODULES
SPRENT   EQU   252                     SUBPOOL FOR REENTRENT MODULES
         TITLE '           IEAVLK01  BLDL FETCH'
         USING PSA,0                   ADDRESSIBILITY FOR LOW CORE
         USING TCB,TCBREG              REG.4  CONTAINS  TCB ADDRESS
         USING RBSECT,RBREG            REG.5  CONTAINS  RB  ADDRESS
         USING WKAREA,AREAREG          REG.7  CONTAINS  WORK AREA ADDR
         USING CDENTRY,CDEREG          REG.11 CONTAINS  CDENTRY ADDRESS
         USING CDENTRYJ,CDIREG         REG.12 CONTAINS  CDENTRY ADDRESS
         USING ADDRTAB,GR15            ADRESS TABLE DSECT IN VLK00
         EJECT
*        THE FOLLOWING CODE, IN CONJUNCTION WITH CDTSLPA, SATMAR, AND
*        DEMISSED, CONTROLS THE ORDER OF SEARCHES FOR THE CDE QUEUES
*        AND LIBRARIES. PLEASE REFER TO THE ORDER OF SEARCHES IN THE
*        PROLOGUE.  THIS SECTION OF CODE IS ENTERED AFTER STEPS
*        (SR.NON-DE1,4, OR 5) OR (SR.DE 1,2, OR 3) DEPENDING ON WHETHER
*        OR NOT A DE WAS PASSED BY THE USER.
*              FLOW:
*
*        A. CHECK IF (SR.NON-DE4) OR (SR.DE2) HAS BEEN DONE.  IF NOT,
*            GO TO CDTSLPA FOR FURTHER TESTING.
*        B. CHECK IF THIS IS A TIME SHARING TASK. IF YES, DO STEP C.
*            OTHERWISE DO STEP D.
*        C. (SR.NON-DE5),(SR.DE3) SET R8 TO  ADDRESS TSCVTLPA, THEN
*            EXIT TO CDCONTRL (IEAVLK00) TO SEARCH TSLPA.
*        D. CHECK IF LPDE DIRECTORY HAS BEEN BUILT.  IF NOT, DO STEP
*            E. OTHERWISE DO STEP F.
*        E. (SR.NON-DE7),(SR.DE5,6) SEARCH LINK LIBRARY VIA SATMAR
*        F. (SR.NON-DE6),(SR.DE4) SEARCH LPDES. IF FOUND GO TO
*            DETOLPAQ AFTER PAGING IN LPDES AND CHECKING FOR 406 ABEND.
*            IF NOT FOUND DO STEP E.
*
*        REGISTER USAGE
*        R0 - LEFT HALF OF NAME (INPUT)
*             ALTERED (OUTPUT)
*        R1 - RIGHT HALF OF NAME (INPUT)
*        R2 - LPDE ADDRESS (OUTPUT, STEP F)
*        R3 - CVT ADDRESS (OUTPUT)
*        R4,5-TCB,SVRB ADDRESSES (INPUT)
*        R6 - BASE (IEAVLK01)
*        R8 - ALTERED
*        R9 - ADDRESS OF NAME (INPUT)
*        R10- DCB REGISTER (INPUT)
*        OTHER REGISTERS CHANGED, OR NOT USED
*        SVRB EXSAVE FULLY INITIALIZED
         SPACE 2
*/* P SET R3= ADDRESS OF CVT */
         SPACE 2
         L     CVTREG,CVTPTR           GET ADDRESS CVT
         USING CVT,CVTREG              ADDRESS THE CVT
         SPACE 2
*/* D (NO,CDTSLPA,YES,) ALPAQ BEEN SRCH'D YET (R8= PTR TO ALPAQ HDR)*/
         SPACE 2
         C     TABREG,IEAQLCTA         Q. HAS LPACQ BEEN SEARCHED
         BNE   CDTSLPA                 NO-TEST LPA
         SPACE 2
*/*CHKLPDES: D (NO,SATMAR,YES,) LPA DIRECTORY BEEN BUILT (CVTDICOM
*/*=1)*/
         SPACE 2
CHKLPDES TM    CVTLPDIA,CVTDICOM       HAS DIRECTORY BEEN BUILT
         BZ    SATMAR                  IF NOT, DO NOT SEARCH
         SPACE 2
*/* P SAVE R6 IN R2 AND R9 IN R15*/
         SPACE 2
         LR    WKREG2,BASEREG          SAVE GR6 OVER INTERFACE
         LR    R15,NAMEREG             SAVE GR9 OVER INTERFACE
         SPACE 2
*/* P INSURE GOOD SEARCH INDICATOR IS OFF (SET RBCSGSF =0)*/
         SPACE 2
         NI    RBCSFLG1,MAX-RBCSGSF    TURN GOOD SEARCH FLAG OFF
         SPACE 2
*/* L (NOTF,%XSKP,FND,)IEAVVMSR-- SEARCH PAGED LINKPACK DIRECTORY */
*/* P TURN ON GOOD SEARCH INDICATOR (SET RBCSGSF =1)*/
*/* %XSKP: P RESTORE R6 FROM R2 AND R9 FROM R15*/
         SPACE 2
         L     BASEREG,CVTLPDSR        PICK UP SEARCH ROUTINE ADDR
         BALR  RETURN,BASEREG          SEARCH LPDE DIRECTORY
         OI    RBCSFLG1,RBCSGSF        TURN ON GOOD SEARCH FLAG IF
*                                      RETURN ON R14 + 0
         LR    BASEREG,WKREG2          RESET ADDRESSABILITY FOR VLK01
         LR    NAMEREG,R15             RESET NAME REGISTER
         SPACE 2
*/*LPDSBLE: D (NO,SATMAR,YES,) LPDE FOUND (RBCSGSF =1)*/
         SPACE 2
LPDSBLE  EQU   *                       LPDE PREFIXING ROUTINE
         TM    RBCSFLG1,RBCSGSF        IF SEARCH FAILED, GO TO
         BZ    SATMAR                  LIBRARY SEARCH
         SPACE 2
*/* P SET R2= RQSTD LPDE ADDRESS (SET R2=R0)*/
         SPACE 2
         LR    WKREG2,R0               PUT LPDE ADDRESS IN USABLE REG
         USING LPDE,WKREG2             ADDRESS THE LPDE
         SPACE 2
*/*LPDTST: D (NO,DETOLPAQ,YES,) LOAD ONLY MODULE? (LPDENLR =0)*/
         SPACE 2
LPDTST   EQU   *                       TEST THE ATTRIBUTES OF THE LPDE
         TM    LPDEATTR,LPDENLR        Q. IS THIS A LOAD ONLY MODULE
         BO    DETOLPAQ                NO- MODULE CAN BE USED
         SPACE 2
*/* D (YES,DETOLPAQ,NO,) LOAD REQUEST? (RBCDLOAD =1)*/
         SPACE 2
         TM    RBCDFLGS,LOAD           Q. IS LOAD REQUEST IN PROGRESS
         BO    DETOLPAQ                YES- MODULE CAN BE USED
         SPACE 2
*/* P (,ERRRTN) SET ABEND REGISTER (R13) TO 4 FOR 406 ABEND*/
         SPACE 2
         LA    R13,4                 SET FOR ERROR CODE 406    @YA01851
         B     ERRRTN                GO SET UP CODE AND ABEND  @YA01851
         EJECT
*        DETOLPAQ IS ENTERED WHEN AN LPDE HAS BEEN FOUND FOR A REQUEST.
*        FIRST THE LPDE IS CHECKED FOR BEING A MINOR. IF THE LPDE IS
*        NOT A MINOR, A MAJOR CDE IS CREATED, QUEUED TO THE LPAQ, AND
*        AN EXTENT LIST IS BUILT TO DESCRIBE THE MODULE.  THE ROUTINE
*        THEN EXITS TO CDEMERGE IN IEAVLK00.
*        IF THE LPDE WAS A MINOR, THE LPAQ IS SEARCHED FOR THE MAJOR
*        CDE.  IF IT IS FOUND, A MINOR CDE IS CREATED, AND QUEUED
*        BEHIND THE MAJOR, AND EXIT IS AGAIN TO CDEMERGE.
*        IF THE CDE WAS NOT FOUND, THE LPDES ARE SEARCHED FOR THE
*        MAJOR LPDE. IF IT IS FOUND, THE MAJOR AND MINOR CDES ARE
*        CREATED, IN ADDITION TO THE EXTENT LIST, AND ARE QUEUED TO THE
*        LPAQ. EXIT IS AGAIN TO CDEMERGE.
*        IF THE MAJOR CDE OR LPDE ARE NOT FOUND, AN 806 ABEND IS ISSUED
*        VIA ABNDSET IN IEAVLK00.
*        REGISTERS ON ENTRY
*        R2,3,4,5,6 - LPDE,CVT,TCB,SVRB, BASE (IEAVLK01)
*        OTHER REGISTERS NOT REFERENCED.
*        SVRB EXSAVE FULLY INITIALIZED.
*        CMS LOCK HELD ON ENTRY
         SPACE 2
*/*DETOLPAQ: P SET R7= ASCB ADDR FOR GETMAIN (SET R7= PSAAOLD)*/
         SPACE 2
DETOLPAQ EQU   *
         USING LPDEJ,LPDIREG           ADDRESS MAJOR LPDE
         USING LPDE,WKREG2             USE REG 2 TO ADDRESS LPDE
         L     ASCBREG,PSAAOLD         GET ASCB ADDRESS FOR GETMAIN
         SPACE 2
*/* D (YES,MINORIT,NO,) RQSTD LPDE A MINOR? (LPDEMIN =1)*/
         SPACE 2
         TM    LPDEATTR,LPDEMIN        IF MINOR LPDE,GO TO FIND MAJOR
         BO    MINORIT                 CDE OR LPDE
         SPACE 2
*/* P SET LPDIREG = ADDR MAJOR LPDE (SET R9 = R2)*/
         SPACE 2
         LR    LPDIREG,WKREG2          SET UP MAJOR LPDE REG.
         SPACE 2
*/*CREATMAJ: L GETMAIN (BR ENTRY)-- GET A CDE AND EXTENT LIST FROM
*/*SP245 */
         SPACE 2
CREATMAJ LA    R0,CDXLIN               GET SPACE FOR MAJOR CDE
         GETMAIN RU,LV=(0),SP=245,BRANCH=YES GET CDE AND EXTENT LIST
         SPACE 2
*/* P set cderEG = NEW CDE ADDR (R11=R1)*/
*/* P SET CDIREG (R12) = R11*/
*/* P INITIALIZE NEW XL (WORD 0) TO 16 (SIZE OF XL)*/
*/* P INITIALIZE NEW XL (WORDS 2 & 3) FROM LPDEXTLN & LPDEXTAD*/
         SPACE 2
         LR    CDEREG,WKREG1           PUT CDE ADDR. IN USABLE REG.
         LR    CDIREG,CDEREG           SET UP MAJOR CDE REG.
         LA    WKREG1,LPDCDE(WKREG1)   CALCULATE ADDR. OF XTLST
         MVC   N8(N8,WKREG1),LDXTLTHJ  INITIALIZE XTLST
         LA    R0,XTLSTSIZ             SIZE=16
         ST    R0,N0(WKREG1)           STORE INTO NEW XLIST
         LA    R0,N1                   XTENTS=1
         ST    R0,FOUR(WKREG1)         STORE INTO NEW XLIST
         SPACE 2
*/* P COPY LPDE (VIA R9) INTO NEW CDE*/
*/* P SET CDXLMJP OF NEW CDE = XL ADDR*/
         SPACE 2
         MVC   CDENTRYJ(LPDCDE),LPDEJ  MOVE CDE FIELDS IN
         ST    WKREG1,CDXLMJPJ         STORE ADDR. OF XTLST IN CDE
         SPACE 2
*/* P CHAIN CDE TO TOP OF ALPA QUEUE */
         SPACE 2
         L     CVTREG,CVTPTR           GET ADDRESS OF CVT
         L     WKREG1,CVTQLPAQ         GET POINTER TO CDE
         MVC   CDCHAINJ(WORD),N0(WKREG1) CREATE FORWARD POINTER
         ST    CDIREG,N0(WKREG1)       SET UP QUEUE POINTER
         SPACE 2
*/* D (YES,MINORCA,NO,CDMRGRET) RQSTD LPDE A MINOR (LPDEMIN =1)*/
         SPACE 2
         TM    LPDEATTR,LPDEMIN        TEST FOR MAJOR OR MINOR
         BO    MINORCA                 IF MINOR, GO TO MINOR PROCESSING
         B     CDMRGRET                LEAVE
         SPACE 2
*/*MINORCR: P SET CDIREG = MAJOR CDE ADDR (SET R12 = R11)*/
         SPACE 2
MINORCR  LR    CDIREG,CDEREG           PUT ADDR. OF MAJOR INTO REG
         SPACE 2
*/*MINORCA: L GETMAIN (BR ENTRY)-- GET MINOR CDE FROM SP 245 */
         SPACE 2
MINORCA  EQU   *                       GET SPACE FOR CDE
         GETMAIN RU,LV=CDESIZE,SP=245,BRANCH=YES  IN SQA
         SPACE 2
*/* P SET CDEREG = ADDR OF NEW MINOR CDE (SET R11=R1)*/
*/* P COPY LPDE (VIA R2) INTO NEW CDE*/
         SPACE 2
         LR    CDEREG,WKREG1           PUT CDE ADDR. IN USABLE REG.
         MVC   CDENTRY(LPDCDE),LPDE    INITIALIZE CDE
         SPACE 2
*/* P (,CDMRGRET) CHAIN MINOR BEHIND ITS MAJOR CDE  */
         SPACE 2
         MVC   CDCHAIN(WORD),CDCHAINJ  CHAIN CDE TO NEXT
         ST    CDEREG,CDCHAINJ         CHAIN MAJOR TO MINOR
         ST    CDIREG,CDXLMJP          ADDR OF MAJOR IN MINOR
         B     CDMRGRET                LEAVE
         SPACE 2
*/*MINORIT: P SET R8= ADDR OF ALPAQ HEADER*/
*/* P SET R9 = ADDR OF MAJOR NAME (SET R9= ADDR OF LPDEXTLN)*/
*/* L (FND,MINORCR,NOTF,) IEAQCDSR-- SEARCH LPAQ FOR MAJOR CDE*/
         SPACE 2
MINORIT  LA    NAMEREG,LPDEXTLN        SEARCH LPAQ FIRST
         L     CVTREG,CVTPTR           GET CVT ADDRESS
         L     TABREG,CVTQLPAQ         FOR MAJOR  CDE
         L     RETURN,CVTQCDSR         PICK UP CDSEARCH ADDR
         BALR  RETURN,RETURN           SEARCH THE QUEUE FOR
*                                      MAJOR
         B     MINORCR                 IF FOUND,CREATE MINOR
         SPACE 2
*/* P INSURE GOOD SEARCH INDICATOR IS OFF (SET RBCSGSF =0)*/
         SPACE 2
         NI    RBCSFLG1,MAX-RBCSGSF    TURN OFF GOOD SEARCH FLAG
         SPACE 2
*/* L (FND,,NOTF,%NOTFOND) IEAVVMSR-- SEARCH LPDE'S FOR MAJOR */
         SPACE 2
         L     BASEREG,CVTLPDSR        PICK UP SEARCH RTN ADDR
         BALR  RETURN,BASEREG          SEARCH THE LPDES FOR MAJOR
         DROP  BASEREG                 BASE IS LOST OVER IEAVVMSR
         USING *,RETURN                ESTABLISH TEMPORARY ADDR
         SPACE 2
*/* P SET GOOD SEARCH INDICATOR ON (SET RBCSGSF =1)*/
         SPACE 2
         OI    RBCSFLG1,RBCSGSF        TURN ON GOOD FLAG IF RETURN +0
         SPACE 2
*/*%NOTFOND: P RESET BASEREG (R6) DESTROYED BY IEAVVMSR */
         SPACE 2
         L     BASEREG,LINKBASE        RESET ADDRESSABILITY
         DROP  RETURN                  DROP TEMPORARY BASE
         USING IEAVLK01,BASEREG        ESTABLISH REGULAR BASE
         SPACE 2
*/* D (YES,COMPLETE,NO,) MODULE FOUND (GOOD-SRCH IND. ON)? */
*/* COMMENT (2,15) 806 ABEND IF*/
*/* COMMENT (3,15) NOT FOUND*/
         SPACE 2
         TM    RBCSFLG1,RBCSGSF        TEST FOR GOOD RETURN
         BO    COMPLETE                IF GOOD CREATE MAJOR,MINOR CDE
*                                      OTHERWISE 806 ABEND
         SPACE 2
*/* P  SET ABEND REGISTER (R13) TO 8 FOR 806 ABEND*/
*/* P  (,ERRRTN) SET R15 TO REASON CODE C*/
         SPACE 2
         LA    R13,8                   SET ABEND CODE TO 8     @YA01851
         LA    R15,BADRETCD            SET REASON CODE TO C
         B     ERRRTN                  GET ABEND CODE AND ABEND
         SPACE 2
*/*COMPLETE: P (,CREATMAJ) SET LPDIREG = MAJOR LPDE ADDR (SET R9=R0)*/
         SPACE 2
COMPLETE LR    LPDIREG,R0              SAVE MAJOR ADDRESS
         B     CREATMAJ                CREATE MAJOR CDE
         EJECT
*        CDTSLPA IS A ROUTINE WHICH CONTROLS THE FLOW BETWEEN THE
*        VARIOUS SEARCHES. THE ROUTINE FLOW IS AS FOLLOWS:
*
*        A. CHECK IF (SR.NON-DE5) OR (SR.DE3) WAS DONE. IF YES, GO TO
*            CHKLPDES TO SEARCH LPA DIRECTORY. IF NO, DO B.
*        B. CHECK IF STEP C. DONE. IF YES GO TO SATMAR TO DO
*            (SR.NON-DE7) OR (SR.DE5,6). OTHERWISE DO STEP C.
*        C. SET DCB REGISTER POSITIVE. IF DCB REGISTER IS ZERO, DO STEP
*            D. OTHERWISE DO STEP H.
*        D. (SR.NON-DE3),(SR.DE5,6) SET UP JOB LIBRARY DCB. THEN DO
*            STEP E.
*        E. IF NOT DE FORM, DO STEP F. OTHERWISE DO STEP G.
*        F. (SR.NON-DE2,3) SEARCH THE JOB LIBRARIES VIA BLDL.
*        G. IF Z-BYTE ZERO, USE JOB LIBRARY DCB. OTHERWISE USE Z-BYTE
*            AS INDEX TO DO FETCH (SR.DE5,6)
*        H. (SR.DE2) IF DCB FOR SVCLIB OR LINKLIB, SET UP TO SEARCH
*            LPAQ.(SET LINKLIB DCB IN R10, R8= ADDRESS OF LPAQ, AND
*            EXIT TO CDCONTRL (IEAVLK00)). OTHERWISE DO STEP E.
*
*        REGISTER USAGE:
*
*        R0,1  - CHANGED
*        R3,4,5- CVT,TCB,SVRB (INPUT)
*        R6    - BASE (IEAVLK01) (INPUT)
*        R8    - ADDRESS OF QUEUE (INPUT)
*        R9    - ADDRESS OF NAME (INPUT)
*        R10   - DCB ADDRESS (INPUT)
*        OTHER REGISTERS NOT REFERENCED
*        SVRB EXSAVE FULLY INITIALIZED
         SPACE 1
         DROP  WKREG2                  DROP LPDE USAGE
         DROP  LPDIREG                 DROP LPDE USAGE
         DROP  CVTREG                  DROP CVT USAGE
         SPACE 2
*/*CDTSLPA: D (YES,SATMAR,NO,) DCB CHECKING DONE (SIGN DCBREG=+)*/
         SPACE 2
CDTSLPA  EQU   *
         LTR   DCBREG,DCBREG           HAS DCB CHECKING BEEN DONE
         BP    SATMAR                  A= YES , TAKE BRANCH
         SPACE 2
*/* P  SET DCB REG=+ TO INDICATE DCB CHECKING DONE AND NOT TASKLIB
*/*SEARCH*/
*/* D (YES,GETJLB,NO,) IS DCBREG (R10) ZERO*/
         SPACE 2
         LPR   DCBREG,DCBREG           SET REGISTER POSITIVE INDICATING
*                                      DCB CHECKING HAS BEEN DONE
         BE    GETJLB                  IF REGISTER IS ZERO LOAD JOBLIB
         SPACE 2
*/* D (YES,CDFIL,NO,) DCB FOR SVCLIB? */
         SPACE 2
         C     DCBREG,SVCDCBA          Q.IS THIS SVCLIB DCB
         BE    CDFIL                   A=YES TAKE BRANCH
         SPACE 2
*/* D (NO,CITADE,YES,) DCB FOR LINKLIB? */
         SPACE 2
         C     DCBREG,LINKDCBA         Q.IS THIS LINKLIB DCB
         BNE   CITADE                  A=NO  TAKE BRANCH
         SPACE 2
*/*CDFILIN: P SET DCBREG= LINKLIB DCB ADDRESS */
         SPACE 2
CDFILIN  L     DCBREG,LINKDCBA         LOAD LINKLIB DCB ADDRESS.
         SPACE 2
*/*CDFIL: P PREPARE TO SEARCH THE LPAQ (SET R8= ALPAQ HDR)*/
         SPACE 2
CDFIL    L     TABREG,IEAQLCTA         LOAD LPACQ ADDRESS
         SPACE 2
*/* L SETLOCK-- GET CMS LOCK FOR LPA SEARCH */
         SPACE 2
         SETLOCK  OBTAIN,TYPE=CMS,MODE=UNCOND,                         x
               RELATED=('FREED BY EXIT PROLOG OR BEFORE LINKLIB BLDL')
         SPACE 2
*/*CDCONTRC: P SET BASEREG (R6) FOR MODULE IEAVLK00*/
*/* R RETURN TO CDCONTRL IN IEAVLK00*/
         SPACE 2
CDCONTRC L     GR15,TABLEADD           GET TABLE ADDRESS
         L     BASEREG,CDLKBASE        RESET VLK00 BASE
         L     GR15,CDCONTRL           BEGIN AT SEARCH ROUTINE
         BR    GR15                    GO TO MAIN ROUTINE
         SPACE 2
*/*GETJLB: P SET DCBREG = ADDR OF JOBLIB DCB VIA TCBJLB*/
         SPACE 2
GETJLB   L     DCBREG,TCBJLB           LOAD JOBLIB DCB ADDRESS
         SPACE 2
*/* P COMPLEMENT DCBREG TO INDICATE TASKLIB SEARCH*/
*/* D (NO,CDFILIN,YES,) ANY JOBLIB DCB (DCBREG NOT 0)*/
         SPACE 2
         LNR   DCBREG,DCBREG           Q. JOBLIB DCB EQUAL ZERO
         BE    CDFILIN                 A= YES , TAKE BRANCH
         SPACE 2
*/*CITADE: P GET DIRECTORY ENTRY ADDR FROM RBCSDE*/
*/* D (YES,,NO,SATMAR) DE FORM OF MACRO USED (RBCSDE NOT 0)*/
         SPACE 2
CITADE   ICM   R15,MASK,RBCSDEA        Q. IS DE FORM OF MACRO GIVEN
         BZ    SATMAR                  A= NO  TAKE BRANCH
         SPACE 2
*/* P SET R1= TCB ADDR (SET R1=R4)*/
*/* D (YES,SATMAR,NO,) NULL DCB? (Z-BYTE =0)*/
         SPACE 2
         USING PDS2-DESAVEDE+DESAVE,R15 ADDRESS PDS SAVED
         LR    TASKREG,TCBREG          GET ADDR OF REQUESTOR'S TASK
         TM    DEZBYTE,MAX             Q. - NULL DCB
         BZ    SATMAR                  A. - YES, TAKE BRANCH
         TM    RBCDFLGS,RBCDATCH       ATTACH REQUEST?         @ZA30995
         BZ    MPATCH                  BRANCH IF NOT           @ZA30995
         L     TASKREG,TCBMOTH(,TASKREG) GET ADDRESS OF MOTHER @ZA30995
MPATCH   EQU   *                                               @ZA30995
         SPACE 1
*              THE NEXT FOUR INSTRUCTIONS PERTAIN TO THE SPECIAL FLAG
*              SET BY BLDL TO DISTINGUISH THE JOBLIB FROM LINKLIB WHERE
*              A NULL DCB HAS BEEN PROVIDED IN THE BLDL MACRO. SEE CPS
*              FOR DETAILS OF BYTE'Z' OF LIST ENTRY.
         SPACE 2
*/* P SET R0= Z-BYTE COUNT */
*/* P DECREMENT COUNT BY ONE IN R0 */
*/* D (YES,CDFILIN,NO,LIBLOOP) COUNT ZERO? */
*/* COMMENT (1,1) NOTE: A Z-BYTE*/
*/* COMMENT (2,1) OF 1 INDICATES*/
*/* COMMENT (3,1) LINKLIB*/
         SPACE 2
         SR    ZREG,ZREG               INITIALIZE COUNT TO ZERO
         IC    ZREG,DEZBYTE            GET LIB COUNT SUPPLIED BY BLDL
         BCT   ZREG,LIBLOOP            Q.COUNT = 0, IMPLIES DE FOUND
*                                      ON SYS1.LINKLIB
         B     CDFILIN                 YES.SEARCH LPAQ AND LINKLIB
         SPACE 2
*/*LIBLOOP: P SET R10= TASKLIB ADDR (R10= TCBJLB OF TCB VIA R1)*/
*/* P SET R1= MOTHER TCB ADDR (SET R1= TCBMOTH OF TCB VIA R1)*/
*/* P DECREMENT COUNT BY ONE IN R0 */
*/* D (YES,,NO,LIBLOOP) COUNT ZERO? */
         SPACE 2
LIBLOOP  L     DCBREG,TASKLIB(TASKREG) GET TASKLIB DCB ADDR
         L     TASKREG,TCBMOTH(TASKREG) GET ADDR OF MOTHER TASK
         BCT   ZREG,LIBLOOP            LOOP
         DROP  R15                     DROP PDS USAGE
         EJECT
*        INITIALIZATION FOR BLDL AND FETCH.
*
*        A. A TEST IS MADE TO SEE IF A BLDL FETCH WORK AREA EXISTS. IF
*            YES, ADD CDE TO JPAQ AND DO C. OTHERWISE DO B.
*        B. GET A CDE AND QUEUE TO JPAQ. THEN GET A BLDL FETCH WORK
*            AREA, AND INITIALIZE THE CDE, WORK AREA, AND SVRB FIELDS,
*            THEN GO TO C.
*        C. IF ALIAS REQUEST, GO TO ALIASRCH. OTHERWISE DO STEP D.
*        D. PICK UP DEB ADDRESS AND, IF NIP IS NOT PROCESSING OR THE
*            DCB IS NOT SVCLIB OR LINKLIB, DO DEBCHECK TO VERIFY THE
*            DEB.                                              @ZA28494
*        E. CHECK FOR DE PASSED BY THE USER.  IF NOT, DO BLDL.  IF
*            DE WAS PASSED, CHECK IF USER IS AUTHORIZED OR, IF NOT,
*            CHECK IF LIBRARY IS UNAUTHORIZED.  IF EITHER CHECK IS
*            SUCCESSFUL, SKIP BLDL.                            @ZA26582
*
*        REGISTER USAGE:
*        R0,R1   - CHANGED
*        R3,4,5  - CVT,TCB,SVRB (INPUT)
*        R6      - BASE (IEAVLK01)
*        R7      - ADDRESS OF BLDL FETCH WORK AREA (OUTPUT)
*        R8      - DEB ADDRESS (OUTPUT)                        @ZA28494
*        R10     - DCB ADDRESS (INPUT)
*        R11     - CDE FOR REQUEST (OUTPUT)
*        R13,14,15-CHANGED
*        OTHER REGISTERS NOT REFERENCED
*        SVRB EXSAVE FULLY INITIALIZED
         SPACE 2
*/*SATMAR: D (YES,PRESET,NO,) CDE & WORK AREA ACQUIRED YET (RBCSWORK
*/*NT 0)*/
         SPACE 2
SATMAR   L     AREAREG,RBCSWORK        Q.HAVE THE CDE AND WORK AREA
         LTR   AREAREG,AREAREG         BEEN ACQUIRED
         BNZ   PRESET                  YES.BRANCH
         SPACE 2
*/* L GETMAIN-- GET A CDE FROM LSQA (SP255) */
*/* P SET CDEREG = ADDR OF NEW CDE (SET R11=R1)*/
*/* P CLEAR THE NEW CDE*/
*/* P SET CDNAME = REQUESTED NAME VIA R9*/
*/* P INITIALIZE CDE WITH ATTR. NIC, JPA, REN, SER, NLR*/
         SPACE 2
         L     ASCBREG,PSAAOLD         GET ADDRESS OF ASCB OF GM
         GETMAIN RU,LV=CDESIZE,SP=255,BRANCH=YES
         LR    CDEREG,R1               SET UP CDEREG FOR USING VALUE
         XC    CDCHAIN(CDESIZE),CDCHAIN      ZERO THE CDE
         MVC   CDNAME(NAME),ZERO(NAMEREG) INITIALIZE  CDNAME
         MVI   CDATTR,CDNIC+CDJPA+CDREN+CDSER+CDNLR INITIALIZE CDATTR
         SPACE 2
*/* S CDEADD: PUT CDE ONTOP OF JPAQ, SET CDRRBP & RBCDE1*/
         SPACE 2
         BAL   SUBREG1,CDEADD          ADD CDENTRY TO LIST
         SPACE 2
*/* L GETMAIN-- GET WORK AREA FROM SP 253 (LSQA) */
*/* P SET AREAREG = ADDR OF FETWK (SET R7=R1)*/
         SPACE 2
         GETMAIN RU,LV=WKSIZE,SP=253,BRANCH=YES
         LR    AREAREG,R1              SET WORK AREA REGISTER AS USING
         SPACE 2
*/* P CLEAR PM WORK AREA AND BLDL AREA IN FETWK*/
*/* P SET WKPREFX= 0001003C (NO OF ENTRIES AND SIZE OF ENTRY)*/
*/* P SET WKNAME= RQSTD NAME FROM CDNAME*/
*/* P SET BLDL AREA = DE SAVE AREA IF DE SPECIFIED.*/
*/* P SET WKCDADDR= CDE ADDR (SET WKCDADDR= CDEREG)*/
         SPACE 2
         XC    WKPGMMGR(WKEND-WKPGMMGR),WKPGMMGR   CLEAR WORKAREA
         MVC   WKPREFX(WORD),BLDLMASK  MOVE IN 4 BYTE PREFIX
         SPACE 1
*        THE FIRST 8 BYTES OF THE DIRECTORY ENTRY ARE THE NAME
         SPACE 1
         MVC   WKNAME(NAME),CDNAME     MOVE NAME
         L     R15,RBCSDE              TEST FOR DE FORM
         LTR   R15,R15                 OF MACRO
         BZ    NOTDEFRM                IF NOT DE DONT MOVE DE IN
         USING DESAVE,R15              POINT TO DE SAVE AREA
         MVC   WKNAME(DEMAX),DESAVEDE  MOVE DE TO WORK AREA
NOTDEFRM EQU   *                       CONTINUE INITIALIZATION OF WA
         ST    CDEREG,WKCDADDR         SAVE THE CDE ADDR
         SPACE 2
*/* P SET RBCSWORK = ADDR OF FETWK (SET RBCSWORK = R7)*/
         SPACE 2
         ST    AREAREG,RBCSWORK        SAVE WORK AREA ADDRESS IN RB.
*                                      EXTENDED SAVE AREA.
         SPACE 2
*/* D (NO,SETOUT,YES,) TASKLIB SEARCH IN PROCESS (SIGN DCBREG =-) */
         SPACE 2
         LTR   DCBREG,DCBREG           Q. TASKLIB SEARCH IN PROCESS
         BP    SETOUT                  NO.BRANCH
         SPACE 2
*/* P SET DCBREG POSITIVE*/
*/* P NOW INDICATE TASKLIB SEARCH BY SETTING WKFLAG= X'87'*/
*/* P SAVE TCB ADDR (SET WKTCBSE=R4)*/
*/* P (,SETOUT) SAVE DCB ADDR (SET WKDCBSE=R10)*/
         SPACE 2
         MVI   FLAG,TLIBIND            YES.SET TASKLIB INDICATOR
         LPR   DCBREG,DCBREG           INSURE DCB ADDR IS POSITIVE
         ST    TCBREG,WKTCBSE          INIT TCB ADDR. IN WORKAREA
         ST    DCBREG,WKDCBSE          INIT DCB ADDR. IN WORKAREA
         B     SETOUT                  CONTINUE
         SPACE 2
*/*PRESET: P SET CDEREG = CDE ADDR (SET R11= WKCDADDR)*/
*/* S CDEADD: PUT CDE ONTOP OF JPAQ, SET CDRRBP & RBCDE1*/
         SPACE 2
PRESET   L     CDEREG,WKCDADDR         LOAD ADDR OF CDENTRY
         BAL   SUBREG1,CDEADD          ADD CDENTRY TO JPAQ
         SPACE 2
*/*SETOUT: D (YES,ALIASRCH,NO,) CDMIN = 1?*/
         SPACE 2
SETOUT   EQU   *                       CHECK FOR ALIAS
         TM    CDATTR,CDMIN            Q. IS ALIAS HANDLING CURRENT
         BO    ALIASRCH                A=YES, TAKE BRANCH
         SPACE 2
         USING IHADCB,DCBREG                                   @ZA28494
         ICM   GR1,MASK,DCBDEBA        GET THE DEB ADDRESS     @ZA28494
         L     CVTREG,CVTPTR           GET CVT ADDRESS         @ZA28494
         USING CVT,CVTREG                                      @ZA28494
         TM    CVTOPTA,CVTNIP          IS NIP PROCESSING?      @ZA28494
         BO    CHECKDE                 BRANCH IF YES           @ZA28494
         C     DCBREG,SVCDCBA          SVCLIB DCB?             @ZA28494
         BE    CHECKDE                 BRANCH IF YES           @ZA28494
         C     DCBREG,LINKDCBA         LINKLIB DCB?            @ZA28494
         BE    CHECKDE                 BRANCH IF YES           @ZA28494
         TM    DCBOFLGS,DCBOFOPN       IS DCB OPEN?            @ZA28494
         BZ    BADDCB                  BRANCH IF NOT           @ZA28494
         STM   R10,R11,WKREGIS         SAVE REGISTERS          @ZA28494
         USING DEBBASIC,GR1                                    @ZA28494
         ICM   GR10,MASK,DEBTCBB       GET DEB TCB             @ZA28494
         DROP  GR1                                             @ZA28494
         CR    GR10,TCBREG             SAME AS CURRENT TCB?    @ZA28494
         BE    CHKDEB                  BRANCH IF YES           @ZA28494
         SPACE 2                                               @ZA28494
*        LOCATE THE PROPER TCB IF CURRENT IS NOT THE ONE       @ZA28494
         SPACE 1                                               @ZA28494
*        FIRST SEARCH BACKWARD CHAIN OF TCBS                   @ZA28494
         L     R8,TCBBACK              POINT TO PREVIOUS TCB   @ZA28494
         DROP  TCBREG                                          @ZA28494
         USING TCB,R8                                          @ZA28494
TCBLPBK  EQU   *                                               @ZA28494
         LTR   R8,R8                   IS THERE A PREVIOUS?    @ZA28494
         BZ    CKTCBTCB                BRANCH IF NOT           @ZA28494
         CR    R10,R8                  IS THIS THE TCB WANTED? @ZA28494
         BE    CHKDEB                  BRANCH IF YES           @ZA28494
         L     R8,TCBBACK              GET NEXT TCB            @ZA28494
         B     TCBLPBK                 AND CHECK IT            @ZA28494
         DROP  R8                                              @ZA28494
         USING TCB,TCBREG                                      @ZA28494
*        NOW SEARCH FORWARD CHAIN OF TCBS                      @ZA28494
CKTCBTCB EQU   *                                               @ZA28494
         L     R8,TCBTCB               POINT TO NEXT TCB       @ZA28494
         DROP  TCBREG                                          @ZA28494
         USING TCB,R8                                          @ZA28494
TCBLPTCB EQU   *                                               @ZA28494
         LTR   R8,R8                   IS THERE A TCB?         @ZA28494
         BZ    BADDCB                  BRANCH IF NOT           @ZA28494
         CR    R8,R10                  IS THIS THE TCB WANTED? @ZA28494
         BE    CHKDEB                  BRANCH IF YES           @ZA28494
         L     R8,TCBTCB               GET NEXT TCB            @ZA28494
         B     TCBLPTCB                AND CHECK IT            @ZA28494
         DROP  R8                                              @ZA28494
         USING TCB,TCBREG                                      @ZA28494
CHKDEB   EQU   *                                               @ZA28494
         L     R15,CVTEXT2             GET ADDRESS OF CVT EXT  @ZA28494
         USING CVTXTNT2,R15                                    @ZA28494
         L     R15,CVTDEBVR            GET ADDRESS OF DEBCHK   @ZA28494
         DROP  R15                                             @ZA28494
         BALR  R14,R15                 BRANCH TO DEBCHK RTN    @ZA28494
         B     RELOAD                  GOOD RETURN FROM DEBCHK @ZA28494
RELOAD   EQU   *                                               @ZA28494
         LM    R10,R11,WKREGIS         RESTORE REGISTERS       @ZA28494
         LTR   R15,R15                 ERROR IN DEBCHECK?      @ZA28494
         BNZ   BADDCB                  BRANCH IF YES           @ZA28494
CHECKDE  EQU   *                                               @ZA28494
         LR    DEBREG,R1               SAVE ADDRESS OF DEB     @ZA28494
         USING DEBBASIC,DEBREG                                 @ZA28494
         SPACE 2
         L     R15,RBCSDE              Q. IS DE FORM OF MACRO GIVEN
         LTR   R15,R15                 ON REQUEST
         BZ    DOBLDL                  BRANCH IF NOT           @ZA26582
         TM    CVTOPTA,CVTNIP          IS NIP PROCESSING?      @ZA26582
         BO    DEFOUND                 BRANCH IF YES           @ZA26582
         TM    RBCSFLG1,RBCSSYSR       IS USER KEY/STATE AUTH? @ZA26582
         BO    DEFOUND                 BRANCH IF YES           @ZA26582
         TESTAUTH FCTN=1,BRANCH=YES    CHECK AUTHORIZATION     @ZA26582
         LTR   R15,R15                 IS THE USER AUTHORIZED? @ZA26582
         BZ    DEFOUND                 BRANCH IF YES           @ZA26582
         C     DCBREG,SVCDCBA          SVCLIB DCB?             @ZA26582
         BE    DOBLDL                  BRANCH IF YES           @ZA26582
         C     DCBREG,LINKDCBA         LINKLIB DCB?            @ZA26582
         BE    DOBLDL                  BRANCH IF YES           @ZA26582
         TM    DEBFLGS1,DEBAPFIN       IS THE LIB AUTH?        @ZA26582
         BZ    DEFOUND                 BRANCH IF NOT           @ZA26582
         DROP  DCBREG                                          @ZA26582
         EJECT 1
*FOLLOWING IS THE ROUTINE THAT SETS UP THE INTERFACE  WITH  BLDL
*SERVICE ROUTINE.  THIS ROUTINE ESTABLISHES THE PROPER INTERFACE
*REGISTERS, RESTORES ITS OWN REGISTERS, AND TESTS THE BLDL RETURN CODE.
*
*        REGISTER USAGE:
*              R0-  BLDL LIST (INPUT TO BLDL)
*              R1-  DCB ADDRESS (INPUT TO BLDL)
*              R14- RETURN ADDRESS (INPUT TO BLDL)
*              R15- RETURN CODE OF 0,4,0R 8 (OUTPUT FROM BLDL)
         SPACE 2
*/* P SET REGISTERS FOR BLDL (R0=BLDL LIST,R1=DCB ADDR.) */
*/* P SAVE R11 AND R12 IN WKREGIS*/
         SPACE 2
DOBLDL   EQU   *                                               @ZA26582
         LA    GR0,WKBLDE              SUPPLY THE LIST ADDRESS ,LIST
*                                      BEGINS WITH A 1 WORD PREFIX
         LR    GR1,DCBREG              SUPPLY THE DCB ADDRESS,DCB
*                                      ADDRESS IS NEVER ZERO.
         STM  R11,R12,WKREGIS          SAVE VITAL REGISTERS
         SPACE 2
*/* L SETFRR-- REMOVE RECOVERY ROUTINE FROM STACK */
         SPACE 2
         SETFRR D,WRKREGS=(11,12)                               PTM0180
         SPACE 2
*/* P ZERO POINTER TO RECOVERY PARM. AREA (SET RBCSFRRA =0) */
         SPACE 2
         SR    R11,R11                 CLEAR REG. FOR ZEROING
         ST    R11,RBCSFRRA            PARM. LIST AREA
         SPACE 2
*/* L SETLOCK-- RELEASE CMS LOCK IF HELD */
         SPACE 2
         SETLOCK  RELEASE,TYPE=CMS,RELATED=('MUST BE FREED OVER SVC')
         SPACE 2
*/* L SETLOCK-- RELEASE LOCAL LOCK */
         SPACE 2
         SETLOCK  RELEASE,TYPE=LOCAL,RELATED=('MUST BE FREED OVER SVC')
         SPACE 2
*/* P RESTORE R11 AND R12 FROM WKREGIS*/
         SPACE 2
         LM    R11,R12,WKREGIS          RESTORE REGS SAVED OVER SETLOCK
         SPACE 2
*/* L BLDL (SVC 18)-- GET PDS ENTRY FOR MODULE */
*/* COMMENT (2,1) BLDL INPUT--*/
*/* COMMENT (3,1) R0=WKPREFX PTR*/
*/* COMMENT (4,1) R1=DCB PTR*/
ISSUBLDL BLDL  (1),(0)                 GET PDS ENTRY
         SPACE 1
*                            BLDL RETURNS WITH A CODE SET IN GR15
*                          1.GR15 = 0  SUCCESSFUL COMPLETION,THE
*                            DIRECTORY ENTRY ACQUIRED IS SIGNIFICANT.
*                          2.GR15 = 4  THE NAME COULD NOT BE FOUND ON
*                                      THE LIBRARY ADDRESSED BY DCB.
*                          3.GR15 = 8  A PERMANENT I/O ERROR DETECTED
*                                      IN ATTEMPTING OPERATION.
         SPACE 2
*/* P SAVE R11 AND R12 IN WKREGIS*/
*/* L SETLOCK-- GET LOCAL LOCK */
         SPACE 2
NOBLDL   STM R11,R12,WKREGIS           SAVE VOLITAL REGSITERS
         SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,                        x
               RELATED=('FREED OVER BLDL, NOW REOBTAINED')
         SPACE 2
*/* L SETFRR-- ESTABLISH RECOVERY ROUTINE */
*/* P SET RBCSFRRA= ADDR FRR PARM LIST*/
*/* P SET 1ST WORD OF PARM LIST = ADDR OF PM SVRB*/
         SPACE 2
         SETFRR A,FRRAD=FRRPGM,WRKREGS=(11,12),PARMAD=(13)
         ST    RBREG,N0(R13)           SAVE RB ADDRESS
         ST    R13,RBCSFRRA            SAVE FRR PARM. ADDRESS
         SPACE 2
*/* P RESTORE R11 AND R12 FROM WKREGIS*/
*/* D (FND,DEFOUND,NOTF,DEMISSED,IOER,ERRBLDL) TEST RETURN CODE IN
*/*R15*/
*/* COMMENT (1,1) RET CODES ARE-*/
*/* COMMENT (2,1) 0 IF DE FOUND*/
*/* COMMENT (3,1) 4 IF DE NOT FND*/
*/* COMMENT (4,1) 8 IF I/O ERROR*/
         SPACE 2
         LM    R11,R12,WKREGIS         RESTORE VOLITAL REGSITERS
         SR    R13,R13                 CLEAR R13 FOR ABEND
         B     *+N4(GR15)              TEST RETURN CODE  0,4,8
         B     DEFOUND                 BLDL CODE = 0
         B     DEMISSED                BLDL CODE = 4
         B     ERRBLDL                 BLDL ERROR = 806
         EJECT
* THIS SUBROUTINE WILL PROVIDE TASKLIB DCB ADDRESS TO BLDL,
* STARTING WITH THE REQUESTOR'S TCB JOBLIB DCB FIELD.
* IT WILL STEP UP THE MOTHER-QUEUE UNTIL THE MODULE HAS
* BEEN FOUND OR ALL TASKLIBS HAVE BEEN SEARCHED.
*
*        REGISTER USAGE
*              R1 - MOTHER TCB WORK REG (OUTPUT)
*              R6 - BASE REGISTER (IEAVLK01)
*              R7 - BLDL FETCH WORK AREA (INPUT)
*              R10- DCB ADDRESS (INPUT)
*              OTHER REGISTERS NOT REFERENCED
         SPACE 2
*/*DEMISSED: D (YES,ERRBLDL,NO,) LINKLIB SRCH'D YET (DCBREG = PTR TO
*/*LNKLIB DCB)*/
         SPACE 2
DEMISSED EQU   *                                               @ZA26582
         ICM   R3,MASK,RBCSDE          DE FORM OF MACRO?       @ZA26582
         BNZ   ERRBLDL                 BRANCH IF YES, ERROR    @ZA26582
         C     DCBREG,LINKDCBA         LINKLIB SEARCHED YET?   @ZA26582
         BNE   SEARCH                  NO THEN CONTINUE SEARCH @ZA24461
         TM    RBCSFLG1,RBCSA306       306 ABEND INDICATOR SET @ZA24461
         BZ    ERRBLDL                 NO NORMAL 806 ABEND     @ZA24461
         SR    R13,R13                 CLEAR ABEND REGISTER    @ZA24461
         LA    R15,BADRETCD            SET REASON CODE = 12    @ZA24461
         B     ERRSYSR                 ISSUE 306 ABEND         @ZA24461
SEARCH   DS    0H                      CONTINUE SEARCH LABEL   @ZA24461
         SPACE 2
*/* S RETHRED:DEQUEUE CDE FROM JPAQ */
         SPACE 2
         BAL   R13,RETHRED             DEQUEUE CDE FROM JPAQ
         SPACE 2
*/* D (NO,NOTSLIB1,YES,) TASKLIB SEARCH IN PROCESS (WKFLAG= 87)*/
         SPACE 2
         CLI   FLAG,TLIBIND            TASKLIB SEARCH IN PROCESS
         BNE   NOTSLIB1                NO.BRANCH
         SPACE 2
*/* P SET R1= TCB ADDR FOR TASKLIB JUST SEARCHED (R1= WKTCBSE)*/
         SPACE 2
         L     R1,WKTCBSE              GET TCB FOR LIB JUST SEARC
         SPACE 2
*/*STEPUP: D (YES,CDFILIN,NO,) JS TCB HANDLED YET (R1=JS TCB ADDR)*/
*/* P SET R1= ADDRESS OF MOTHER TCB VIA TCBMOTH*/
         SPACE 2
STEPUP   C     R1,TCBJSTCB             Q.JOB STEP TCB HANDLED
         BE    CDFILIN                 YES SEARCH LPAQ
         L     R1,TCBMOTH(R1)          STEP UP TCB CHAIN
         SPACE 1
*  SINCE THE DCB ADDRESS IS PROPOGATED DOWNWARD, A ZERO ADDRESS
*    MEANS THAT THERE ARE NO MORE LIBS TO SEARCH.
         SPACE 2
*/* P SET DCBREG = TASKLIB DCB OF NEW TCB (R10= TCBJLB)*/
*/* D (YES,CDFILIN,NO,) DCB FIELD = 0? (R10=0) */
         SPACE 2
         ICM   DCBREG,MASK4,TCBJLBDI(R1) TEST FOR ZERO ADDR AND PICK
*                                      UP NEXT DCB POINTER
         BZ    CDFILIN                 NONE LEFT TO CHECK
         SPACE 2
*/* D (YES,STEPUP,NO,) DCB ALREADY CHECKED (R10= WKDCBSE) */
         SPACE 2
         C     DCBREG,WKDCBSE          SAME AS LAST ONE DONE
         BE    STEPUP                  IF SO GET NEXT
         SPACE 2
*/* P SAVE TCB ADDR IN WKTCBSE (SET WKTCBSE = R10)*/
*/* P (,SATMAR) SAVE DCB ADDR IN WKDCBSE (SET WKDCBSE = R10)*/
         SPACE 2
         ST    R1,WKTCBSE              SAVE FOR NEXT PASS
         ST    DCBREG,WKDCBSE          SAVE FOR NEXT PASS
         B     SATMAR                  NO-SEARCH NEW LIB
         SPACE 2
*/*NOTSLIB1: D (NO,CDFILIN,YES,) DCB FOR SVCLIB? */
         SPACE 2
NOTSLIB1 C     DCBREG,SVCDCBA          Q. SVCLIB DCB ADDR IN USE
*                                      IF SO, THE LPAQ HAS
*                                      ALREADY BEEN SEARCHED
         BNE   CDFILIN                 NO.GO TO SEARCH LPA
         SPACE 2
*/* P (,SATMAR) GET ADDRESS OF LINKLIB DCB FOR NEXT SEARCH */
         SPACE 2
         L     DCBREG,LINKDCBA         PREPARE TO SEARCH LINKLIB
         B     SATMAR                  GO TO  BLDL
         EJECT
*THIS ROUTINE EXAMINES THE DE EXTRACTED BY BLDL FOR ABNORMAL CONDITIONS
*AND IF NONE EXIST WILL SET ATTRIBUTES IN THE CDENTRY AS INDICATED IN
*THE  DE. THE FOLLOWINGS FLAGS ARE TESTED IN  THIS SECTION
*              BYTE    (CBYTE) - BIT INDICATING ALIAS DIRECTORY ENTRY.
*              BYTE    (DEATTR)- BIT INDICATING REENTRABLE LOAD MODULE
*                                BIT INDICATING SERIALLY REUSABLE MOD.
*                                BIT INDICATING 'LOAD'ABLE ONLY MODULE
*                                BIT INDICATING EXECUTABLE LOAD MODULE
*        REGISTER USAGE
*              R5 - SVRB ADDRESS (INPUT)
*              R6 - BASE (IEAVLK01)
*              R7 - BLDL FETCH WORK AREA (INPUT)
*              R8 - DEB ADDRESS (INPUT)                        @ZA28494
*              R11- CDE FOR REQUEST (INPUT)
*              R13- ZEROED (OUTPUT)
*              OTHER REGISTERS NOT USED
*/*DEFOUND: P CLEAR ABEND REGISTER (REG 13) */
*/* D (YES,,NO,ERRXCUTE) MODULE EXECUTABLE? */
*/* COMMENT (2,15) 706 ABEND IF*/
*/* COMMENT (3,15) NOT EXEC.*/
         SPACE 2
DEFOUND  EQU   *                       TEST DE ATTRIBUTES ROUTINE
         SR    R13,R13                 CLEAR ABEND REGISTER
         TM    WKATTR,DEXCUT           Q. IS MODULE EXECUTABLE
         BZ    ERRXCUTE                A=NO  GET READY TO ABEND
         TM    CVTOPTA,CVTNIP          IS NIP PROCESSING       @ZA24461
         BO    USEDEFND                YES USE THIS COPY       @ZA24461
         TM    RBCDFLGS,RBCDATCH       ATTACH REQUEST?         @ZA24461
         BZ    CHEKAUTH                NO CHECK AUTHORIZATION  @ZA24461
         CLM   TCBREG,MASK,TCBJSTCB+N1 JOBSTEP ATTACH REQUEST  @ZA24461
         BNE   CHEKSAPF                NO CHECK RESET APF?     @ZA24951
         TM    TCBPKF,X'80'            TCB IN KEY 0-7?         @ZA24461
         BZ    CHECKLIB                YES CHECK LIB AUTH      @ZA24461
         TM    TCBFLGS3,X'80'          TCB TO RUN SUPVR STATE? @ZA24461
         BO    CHECKLIB                YES CHECK LIB AUTH      @ZA24461
         B     USEDEFND                NO USE THIS COPY        @ZA24461
CHEKSAPF TM    RBCSFLG1,RBCRSAPF       RESET APF REQUEST?      @ZA24951
         BO    USEDEFND                YES USE THIS COPY       @ZA24461
CHEKAUTH DS    0H                      CHECK USERS AUTHORITY   @ZA24461
         TM    RBCSFLG1,RBCSSYSR       IS USER KEY/STATE AUTH  @ZA24461
         BO    CHECKLIB                YES THEN CHECK THE LIB  @ZA24461
         TESTAUTH FCTN=1,BRANCH=YES    NO CHECK JSCB AUTH      @ZA24461
         LTR   R15,R15                 IS USER JSCB AUTHORIZED @ZA24461
         BNZ   USEDEFND                NO USE THIS COPY        @ZA24461
CHECKLIB DS    0H                      CHECK LIBRARY AUTH      @ZA24461
         C     DCBREG,SVCDCBA          SVCLIB DCB?             @ZA28494
         BE    USEDEFND                BRANCH IF YES           @ZA28494
         C     DCBREG,LINKDCBA         LINKLIB DCB?            @ZA28494
         BE    USEDEFND                BRANCH IF YES           @ZA28494
         USING IHADCB,DCBREG           SET DCB ADDRESSABILITY  @ZA24461
         CLM   DEBREG,MASK,DCBDEBA     DEB ADDRESSES THE SAME? @ZA28494
         BE    GOODDCB                 YES THEN DCB IS GOOD    @ZA24461
BADDCB   EQU   *                                               @ZA26582
         SR    R13,R13                 NO GET READY TO ABEND   @ZA24461
         LA    R15,DONTBLDL            SET REASON CODE TO 10   @ZA24461
         B     ERRBLDL                 ISSUE THE 806 ABEND     @ZA24461
GOODDCB  TM    DEBFLGS1,DEBAPFIN       IS THE LIB AUTHORIZED   @ZA24461
         BO    USEDEFND                YES USE THIS COPY       @ZA24461
         DROP  DCBREG                  DROP DCB ADDRESSABILITY @ZA24461
         DROP  DEBREG                  DROP DEB ADDRESSABILITY @ZA24461
         L     WKREG2,RBCSDE           GET DE SAVE ADDRESS     @ZA28734
         LTR   WKREG2,WKREG2           IS DE FORM SPECIFIED    @ZA28734
         BZ    CONSERCH                NO CONTINUE THE SEARCH  @ZA28734
         SR    R13,R13                 CLEAR ABEND REGISTER    @ZA28734
         LA    R15,BADRETCD            SET UP FOR 306-C ABEND  @ZA28734
         B     ERRSYSR                 ABEND AUTHORIZED USER THAT SPEC
*                                      IFIED DE OPTION FOR AN UNAUTHOR
*                                      IZED LIBRARY            @ZA28734
CONSERCH DS     0H                     CONTINUE SEARCHING LIBS @ZA28734
         OI    RBCSFLG1,RBCSA306       SET 306 ABEND INDICATOR @ZA24461
         B     DEMISSED                GO CONTINUE SEARCH      @ZA24461
USEDEFND NI    RBCSFLG1,MAX-RBCSA306   RESET 306 INDICATOR     @ZA24461
         SPACE 2
*/* D (YES,,NO,NOVLY) MODULE IN OVERLAY FORM? */
*/* P SET OVERLAY BIT IN CDE (SET CDOLY=1) */
         SPACE 2
         TM    WKATTR,DEOVLY           Q.MODULE IN OVERLAY FORM
         BZ    NOVLY                   NO.DON'T SET CDE FLAG
         OI    CDATTR2,CDOLY           SET BIT INDICATING OVERLAY
         SPACE 2
*/*NOVLY: D (NO,NOLOLY,YES,) MODULE LOAD-ONLY? */
*/* P SET LOADABLE ONLY FLAG IN CDE (SET CDNLR =1) */
         SPACE 2
NOVLY    TM    WKATTR,DELODY           Q. IS MODULE LOADABLE ONLY
         BZ    NOLOLY                  A= NO  TAKE BRANCH
         NI    CDATTR,MAX-CDNLR        SET LOADABLE ONLY FLAG IN CDE
         SPACE 2
*/* D (NO,ERRLONLY,YES,) IS THIS A LOAD REQUEST? */
*/* COMMENT (2,15) 406 ADEND*/
*/* COMMENT (3,15) IF NOT LOAD*/
         SPACE 2
         TM    RBCDFLGS,LOAD           Q. IS THIS A LOAD MACRO REQUEST
         BZ    ERRLONLY                A=NO  GET READY TO ABEND
         SPACE 2
*/*NOLOLY: D (RENT,REENDE,REUS,SERIAL,NRUS,) TEST MODULE REUSABILITY */
*/* P SET REUSABLE BIT OFF IN CDE (SET CDSER =0)*/
*/*SERIAL: P SET RENTRANT BIT OFF IN CDE (SET CDREN =0)*/
         SPACE 2
NOLOLY   TM    WKATTR,PDS2RENT+PDS2REUS Q. IS MOD REENTERABLE OR
*                                      OR SERIALLY REUSABLE
         BO    REENDE                  A= REENTRABLE LEAVE SER+REN SET
         BM    SERIAL                  A= SERIALLY REUSE LEAVE SER SET
         NI    CDATTR,MAX-CDSER        A= NOT REUSABLE RESET REN+SER
SERIAL   NI    CDATTR,MAX-CDREN        A= SER. REUSABLE RESET REN
         SPACE 2
*/*REENDE: D (NO,PGMFETCH,YES,) IS THIS AN ALIAS DE ENTRY? */
         SPACE 2
REENDE   TM    WKCBYTE,DEALIAS         Q. IS AN ALIAS DE ENTRY GIVEN
         BZ    PGMFETCH                A= NO, TAKE BRANCH
         SPACE 2
*/* D (NO,PGMFETCH,YES,) IS MOD. RENT OR REUS? */
         SPACE 2
         TM    WKATTR,PDS2RENT+PDS2REUS Q. IS MOD EITHER REEN-
*                                      TRABLE OR SERIALLY REUSABLE
*                                      INDICATING PRESCENCE OF ALIAS.
         BZ    PGMFETCH                A = NO, GET NEW COPY
*                                      A = YES, PROCESS AS ALIAS
         EJECT
*THIS SECTION OF CODE PROCESSES A BLDL ENTRY THAT IS FLAGGED AS AN
*ALIAS. THE MEMBER NAME IS SEARCHED UPON IN THE  CDENTRY QUEUES -
*IF IT IS FOUND  THE ALIAS ENTRY IS RELOCATED AND A CDENTRY IS BUILT
*THAT IS ASSOCIATED WITH THE FOUND ENTRY ON A MAJOR / MINOR BASIS.
*IF THE MEMBER NAME IS NOT FOUND A CDENTRY IS BUILT FOR THE  MEMBER
*NAME ALSO. WHEN THE MODULE IS FETCHED IT WILL HAVE TWO CDENTRIES, ONE
*FOR THE MEMBER NAME (MAJOR ENTRY) AND ONE FOR THE ALIAS NAME (MINOR ).
*
*        REGISTER USAGE
*        R0,1  - ALTERED
*        R3,4,5- CVT,TCB,SVRB (INPUT)
*        R6    - BASE (IEAVLK01)
*        R7    - BLDL FETCH WORK AREA (INPUT)
*        R8,9  - ALTERED
*        R10   - DCB ADDRESS (INPUT)
*        R11   - CDE REQUESTED (INPUT) ALTERED (OUTPUT)
*        R12   - ALTERED
*        R14,15- ALTERED
*        OTHER REGISTERS NOT REFERENCED
         SPACE 2
*/*ALIAS1: D (NO,NOSCAT,YES,) MODULE LINKED WITH SCATTER */
         SPACE 2
ALIAS1   EQU   *                       SET DE UP IN A CONSISTENT
*                                      PATTERN REGARDLESS OF WHETHER
*                                      IT CONTAINS SCATTER INFO.
         TM    WKATTR,DESCAT           THE ALIAS NAME RESIDES IN
*                                      EITHER OF TWO PLACES DEPENDING
*                                      ON WHETHER SCATTER INFO IS
*                                      PRESENT.
         BZ    NOSCAT                  IF IN SCATTER DE+ 43 IS ALIAS
         SPACE 2
*/* P (,SCATFORM) SET WKMAINEP & WKMAINAM = MAJOR EP & NAME FROM DE*/
         SPACE 2
         MVC   WKMAINEP+N1(PDSS02LN),WKENTSC MOVE IN SCATTER EP AND NM
         B     SCATFORM                SKIP NEXT MOVE
         SPACE 2
*/*NOSCAT: P SET WKMAINEP & WKMAINAM = MAJOR EP & NAME FROM DIFFERENT
*/*PLACE IN DE*/
         SPACE 2
NOSCAT   EQU   *
         MVC   WKMAINEP+N1(PDSS02LN),WKENTBK MOVE IN EP AND NM
         SPACE 2
*/*SCATFORM: P PUT UNRELOCATED MINOR ENTRY POINT FROM WKENTPT INTO
*/*CDENTPT*/
*/* P INDICATE MINOR CDE (SET CDMIN=1) */
         SPACE 2
SCATFORM EQU   *                       NAME AND ENTRY POINT NOW IN
*                                      SAME LOCATION REGARDLESS OF DE
*                                      ATTRIBUTES
         SR    WKREG2,WKREG2           CLEAR HIGH ORDER BYTE
         ICM   WKREG2,MASK,WKENTPT     GET UNRELOCATED EP
         ST    WKREG2,CDENTPT          PUT UNRELOCATED EP IN CDE
         OI    CDATTR,CDMIN            SET MINOR FLAG IN ALIAS CDE
         ST    DEBREG,WKREGIS+N12      SAVE DEB ADDRESS        @ZA28494
         SPACE 2
*/*ALIASRCH: P SET UP SEARCH FOR MAJOR NAME R8=JPAQ HDR PTR R9=WKMAINAM
*/* PTR*/
         SPACE 2
ALIASRCH LA    NAMEREG,WKMAINAM        SET UP SEARCH FOR MEMBER NAME.
         L     TABREG,TCBJSTCB         SET JPAQ ORIGIN ADDRESS
         LA    TABREG,TCBJPQ-TCB(N0,TABREG) SET QUEUE ADDRESS
         L     CVTREG,CVTPTR           GET CVT ADDRESS
         USING CVT,CVTREG              ADDRESSABILITY ON CVT
         SPACE 2
*/* L (FND,MAINLANX,NOTF,) IEAQCDSR-- SEARCH JPQ FOR MAJOR NAME */
         SPACE 2
         L     RETURN,CVTQCDSR         PICK UP CDSEARCH ADDRESS
         BALR  RETURN,RETURN           SEARCH THE  CDE QUEUE
*                                      FOR MEMBER NAME.
         B     MAINLANX                IF MAIN NAME IS IN CONTENTS
*                                      DIRECTORY, BRANCH TO ROUTINE TO
*                                      COMPLETE ALIAS REQUEST.
         SPACE 2
*/* D (YES,LPASRCH,NO,) LINKLIB DCB IN USE (DCBREG = PTR LINKLIB DCB)*/
         SPACE 2
         C     DCBREG,LINKDCBA         Q.IS LINKLIB IN USE
         BE    LPASRCH                 YES.SEARCH LINK PACK AREA
         SPACE 2
*/* D (NO,CREATCDE,YES,) SVCLIB DCB IN USE (DCBREG = PTR SVCLIB DCB)*/
         SPACE 2
         C     DCBREG,SVCDCBA          Q.IS SVCLIB IN USE
         BNE   CREATCDE                NO.GET ANOTHER CDE
         SPACE 2
*/*LPASRCH: P SAVE R11 THRU R13 IN WKREGIS*/
*/* L SETLOCK-- GET CMS LOCK FOR LPA SEARCH */
*/* P RESTORE R11 THRU R13 FROM WKREGIS*/
         SPACE 2
LPASRCH  EQU   *                       SEARCH THE LPAQ
         STM   R11,R13,WKREGIS         SAVE VOLATILE REGS      @ZA28494
         SETLOCK OBTAIN,TYPE=CMS,MODE=UNCOND,                          x
               RELATED=('WILL BE FREED AT CREATCD1 OR EXIT PROLOG')
         LM    R11,R13,WKREGIS         RESTORE VOLATILE REGS   @ZA28494
         SPACE 2
*/* P SET R8= ADDR OF ALPAQ HEADER*/
         SPACE 2
         L     TABREG,IEAQLCTA         GET ADDRESS OF LPACQ ORIGIN
         SPACE 2
*/* L (FND,MAINLANX,NOTF,) IEAQCDSR-- SEARCH ALPAQ FOR MAJOR NAME */
         SPACE 2
         L     RETURN,CVTQCDSR         PICK UP CDSEARCH ADDRESS
         BALR  RETURN,RETURN           SEARCH THE QUEUE
         B     MAINLANX                FOUND - BRANCH TO MAIN ROUTINE
         SPACE 2
*/*CREATCD1: P SAVE R11 THRU R13 IN WKREGIS*/
*/* L SETLOCK-- RELEASE CMS LOCK */
*/* P RESTORE R11 THRU R13 FROM WKREGIS*/
         SPACE 2
CREATCD1 STM   R11,R13,WKREGIS         SAVE VOLATILE REGS      @ZA28494
         SETLOCK RELEASE,TYPE=CMS,RELATED=('LK01,OBTAINED AT LPASRCH')
         LM    R11,R13,WKREGIS         RESTORE VOLATILE REGS   @ZA28494
         SPACE 2
*/*CREATCDE: L GETMAIN (BR ENTRY) -- GET CDE FROM SUBPOOL 255 (LSQA) */
*/* P SET CDIREG = ADDR OF CDE VIA RBCDE1*/
         SPACE 2
CREATCDE EQU   *                       BUILD THE CDE
         L     ASCBREG,PSAAOLD         GET ASCB ADDRESS FOR GETMAIN
         GETMAIN RU,LV=CDESIZE,SP=255,BRANCH=YES  GET CDE
         L     CDIREG,RBCDFLGS         RESET CDIREG TO MINOR
         SPACE 1
*        WE WILL USE NEW CDE AS MINOR, AND OLD CDE AS MAJOR. THIS
*        SIMPILFIES CHAINING.  MINOR INFORMATION IS MOVED TO NEW
*        SPACE, AND OLD MINOR IS CHANGED INTO A MAJOR.
         SPACE 1
*/* P SET CDEREG= ADDR OF NEW CDE (SET R11=R1)*/
*/* COMMENT (2,1) USE NEW CDE AS*/
*/* COMMENT (3,1) MINOR AND OLD*/
*/* COMMENT (4,1) CDE AS MAJOR.*/
*/* P COPY OLD CDE (VIA R12) INTO NEW CDE (VIA R11)*/
*/* P SET CDCHAIN OF OLD CDE = ADDR OF NEW CDE*/
         SPACE 2
         LR    CDEREG,R1               SET NEW CDE = ALIAS = MINOR
         MVC   N0(CDESIZE,CDEREG),N0(CDIREG) PUT ALIAS IN MINOR LOC.
         ST    CDEREG,CDCHAINJ         POINT OLD CDE TO NEW CDE
         SPACE 2
*/* P SET CDNAME OF OLD CDE = MAJOR NAME IN WKMAINAM*/
         SPACE 2
         L     AREAREG,RBCSWORK        GET ADDRESS OF FETCH WORKAREA
         MVC   CDNAMEJ(NAME),WKMAINAM  INSERT MAJOR NAME IN CDE
         SPACE 2
*/* P MARK OLD CDE AS A MAJOR (SET CDMIN =0) */
*/* P SET CDXLMJP OF NEW CDE = ADDR OF OLD CDE*/
*/* P SET RBCDE1 OF PM SVRB = ADDR OF NEW CDE (RQSTD CDE)*/
         SPACE 2
         NI    CDATTRJ,MAX-CDMIN       RESET MIN FLAG IN MAJOR
         LA    CDIREG,N0(CDIREG)       CLEAR HIGH ORDER BYTE
         ST    CDIREG,CDXLMJP          POINT MINOR BACK TO MAJOR
         MVC   RBCDEA(ADDL),CDCHAINJ+N1   RE-INITIALIZE RBCDE
         SPACE 2
*/* P INDICATE 2 CDES OBTAINED (SET RBCSTWO =1)*/
*/* P (,PGMFETCH) SET R11=R12 FOR FETCH*/
         SPACE 2
         OI    RBCSFLG1,RBCSTWO        INDICATE 2 CDES         @YA01851
         LR    CDEREG,CDIREG           SET FOR FETCH  ON MINOR
*                                      MAJOR CDE REG WILL BE SET BY
*                                      RERIG AFTER PGMFETCH.
         L     DEBREG,WKREGIS+N12      RESTORE DEB ADDRESS     @ZA28494
         B     PGMFETCH                GO TO FETCH
         SPACE 2
*/*MAINLANX: D (NO,MAINLAND,YES,) SYSTEM REQUEST? (RBCSSYSR =1)*/
         SPACE 2
MAINLANX TM    RBCSFLG1,RBCSSYSR   Q. THIS A SYSTEM REQUEST
         BZ    MAINLAND            A. NO-CONTINUE
         SPACE 2
*/* D (YES,MAINLAND,NO,CREATCD1) MODULE FROM AUTH LIB (CDSYSLIB =1)*/
         SPACE 2
         TM    CDATTR2,CDSYSLIB     Q. THIS A SYSTEM LIBRARY MODULE
         BO    MAINLAND            YES- CONTINUE
         B     CREATCD1            NO- USE THIS MODULE
         EJECT
*THIS ROUTINE  OPERATES UPON AN ALIAS CDENTRY WHERE MAIN CDENTRY HAS
*BEEN FOUND TO BE IN STORAGE. OF PRIME CONCERN IS THE EXTENT LIST WHICH
*IS USED TO RELOCATE THE ALIAS ENTRY POINT. IF THE MAIN CDENTRY HAS ITS
*NIC FLAG SET INDICATING IT IS NOT IN CORE ,THE ALIAS REQUEST MUST BE
*QUEUED PENDING THE SUCCESSFUL FETCHING OF THE MAIN NAME.
*
*        REGISTER USAGE
*        R0,1  - ALTERED
*        R2    - ALTERED
*        R3    - ALTERED
*        R4    - TCB (INPUT)
*        R5    - SVRB (INPUT)
*        R6    - BASE (IEAVLK01)
*        R7    - BLDL FETCH WORK AREA (INPUT)
*        R9    - ADDRESS OF NAME (OUTPUT)
*        R11,12,13,14,15- ALTERED
*        OTHER REGISTERS NOT REFERENCED
         SPACE 1
*/*MAINLAND: P RESET MAJOR CDE POINTER (SET R12=R11)*/
*/* P RESET REQUESTED CDE POINTER (SET R11= RBCDE1)*/
*/* P RESET NAMEREG (SET R9= RBCSNAME)*/
         SPACE 2
MAINLAND LR    CDIREG,CDEREG           MAJOR CDE   ADDRESSED BY CDIREG
         L     CDEREG,RBCDFLGS         MINOR CDE   ADDRESSED BY CDEREG
         LA    NAMEREG,RBCSNAME        RESET MINOR NAME PTR
         SPACE 2
*/* P RINITIALIZE MAJOR POINTER IN MINOR CDE SET CDXLMJP= R12)*/
         SPACE 2
         LA    CDIREG,N0(CDIREG)       CLEAR HIGH ORDER BYTE
         ST    CDIREG,CDXLMJP          INITIALIZE CDXLMJP
         SPACE 2
*/* S RETHRED:UNHOOK ALIAS FROM JPACQ  */
*/* P RESTORE R12 FROM CDXLMJP OF RQSTD CDE*/
         SPACE 2
         BAL   R13,RETHRED             UNHOOK CDE FROM LIST
         L     CDIREG,CDXLMJP          RELOAD CDIREG
         SPACE 2
*/* D (NO,NONLPA,YES,) MAJOR LOADED BY NIP? (CDNIP =1) */
         SPACE 2
         TM    CDATTRJ,CDNIP           FIXED LPA MOD LOADED BY NIP
         BZ    NONLPA                  NO-BR AROUND LPA PROCESSING
         SPACE 2
*/*GETSOCDE: L GETMAIN (BR ENTRY)-- GET CDE FROM SUBPOOL 245 (SQA) */
         SPACE 2
GETSOCDE EQU   *                       GET CDE
         L     ASCBREG,PSAAOLD         GET ASCB FOR GETMAIN
         GETMAIN RU,LV=CDESIZE,SP=245,BRANCH=YES
         SPACE 2
*/* P COPY REQUESTED CDE (IN LSQA) TO NEW SQA CDE */
         SPACE 2
         MVC   ZERO(CDESIZE,R1),ZERO(R11) MVE CDE FR LSQS TO SQS/TSC
         SPACE 2
*/* P SET CDJPA=0 AND CDNIP=1 IN NEW CDE*/
*/* P SET CDEREG= ADDR OF NEW CDE (SET R11=R1)*/
*/* P PREPARE FOR FREEMAIN:  SET R2= CDE TO BE FREED AND CLEAR HIGH
*/*ORDER  BYTE*/
         SPACE 2
         LA    WKREG2,N0(R11)          ADDRESS TO BE FREED       M00883
         NI    CDATTR-CDENTRY(R1),MAX-CDJPA TURN OFF JPA MOD.BIT M00883
         OI    CDATTR-CDENTRY(R1),CDNIP     SET LPA INDICATOR    M00883
         LR    R11,R1                  SAVE NEW CDE ADDR. OVER FREEMAIN
         SPACE 2
*/* L FREEMAIN (BR ENTRY) -- FREE LSQA CDE (SUBPOOL 255) */
         SPACE 2
         FREEMAIN RU,SP=255,LV=CDESIZE,A=(WKREG2),BRANCH=YES
         SPACE 2
*/* P SET RBCDE1 = ADDR OF NEW CDE (RBCDE1 = R11)*/
*/* P SET WKCDADDR = ADDR OF NEW CDE*/
         SPACE 2
         STCM  R11,MASK,RBCDE1         SAVE PTR TO NEW CDE IN RB
         L     AREAREG,RBCSWORK        GET FETCH WORKAREA
         ST    R11,WKCDADDR            UPDATE CDE ADDR IN THE
*                                      FETCH/BLDL WORK AREA
         SPACE 2
*/*NONLPA: P CHAIN MINOR CDE IN QUEUE BEHIND MAJOR */
         SPACE 2
NONLPA   EQU   *                       CHAIN CDE
         L     WKREG2,CDCHAINJ         GET CHAIN FOR MAJOR
         ST    WKREG2,CDCHAIN          AND PUT IT IN THE MINOR
         MVC   CDCHAINJ+N1(ADDL),RBCDEA MOVE POINTER TO MIN INTO MAJOR
         SPACE 2
*/* D (YES,RESOLVE,NO,) MAJOR NAME IN STORAGE? (CDNIC=0)*/
         SPACE 2
         TM    CDATTRJ,CDNIC           Q.IS MAIN NAME IN STORAGE
         BZ    RESOLVE                 A=YES, TAKE BRANCH
         SPACE 2
*/* P SET BASEREG (R6) FOR IEAVLK00*/
*/*R RETURN TO CDQUECTL IN IEAVLK00*/
*/* COMMENT (1,1) CDQUECTL WILL*/
*/* COMMENT (2,1) QUEUE THIS RQST*/
*/* COMMENT (3,1) ONTO THE NIC*/
*/* COMMENT (4,1) QUEUE OF THE*/
*/* COMMENT (5,1) MAJOR CDE*/
         SPACE 2
         L     GR15,TABLEADD           POINT TO ADDRESS LIST
         USING ADDRTAB,GR15            USE ADDRESS LIST
         L     BASEREG,CDLKBASE        SET UP VLK00 ADDRESSABILITY
         L     GR15,CDQUECTL           POINT TO CDQUECTL IN VLK00
         BR    GR15                    GO THERE
         SPACE 1
*                             IF LOAD MODULE IS IN MAIN STORAGE, AND
*                             ALIAS TO IT HAS BEEN  REQUESTED THIS
*                             SECTION IS ENTERED.
         SPACE 1
*/*RESOLVE: P SET R14= UNRELOCATED ENTRY POINT (SET R14= WKENTPT)*/
*/* S RELOCATE: SET R14= RELOCATED ENTRY POINT*/
         SPACE 2
RESOLVE  DS    0H
         L     SUBREG1,WKENTPT-N1      LOAD ABSOLUTE ENTRY POINT
         BAL   COMREG,RELOCATE         RELOCATE ENTRY POINT
         SPACE 2
*/* P SET NOT-IN-CORE BIT OFF IN REQUESTED CDE */
*/* P STORE RELOCATED ENTRY POINT IN REQUESTED CDE (CDENTPT= R14)*/
         SPACE 2
         NI    CDATTR,MAX-CDNIC        RESET NIC BIT
         ST    SUBREG1,CDENTPT         STORE RELOCATED ENTRY POINT
         SPACE 2
*/* P SET BASEREG (R6) FOR IEAVLK00*/
*/* R RETURN TO PLUSCONT IN IEAVLK00*/
*/* COMMENT (1,1) PLUSCONT WILL*/
*/* COMMENT (2,1) CONTINUE WITH*/
*/* COMMENT (3,1) THE ALLOCATION*/
*/* COMMENT (4,1) OF THE CDE*/
         SPACE 2
         L     GR15,TABLEADD           POINT TO ADDRESS LIST IN VLK00
         L     BASEREG,CDLKBASE        SET UP VLK00 ADDRESSABILITY
         L     GR15,PLUSCONT           POINT TO PLUSCONT
         LR    R14,R15                 SET LOOP REGISTER FOR MAINLINE
         BR    GR15                    GO TO IT
         EJECT
*INTERFACE WITH PROGRAM FETCH IS SET UP. THE FOLLOWING IS REQUIRED
*        R5   - SVRB ADDRESS                                     YM8234
*        R6   - BASE (IEAVLK01)
*        R7   - DCB ADDRESS
*        R8   - DEB ADDRESS (INPUT)
*        R9   - 0
*        R10  - SPID (EITHER 251 OR 252)
*        R12  - RELOCATED ENTRY POINT PASSED  BACK
*        R13  - WORK AREA
*        R14  - RETURN REG
*        R15  - RETURN CODE
*        MODE UPON ENTRY IS FULLY ENABLED.
*FETCH WILL BUILD AN EXTENT LIST FOR WHICH CORE IS GOTTEN FROM SP=252
*A FLAG SET IN THE HI ORDER BYTE OF THE WORD WILL INDICATE THAT  FETCH
*HAS BUILT  THE EXTENT LIST AND IS REQUESTING MAIN STORAGE FOR  THE
*MODULE. THIS STORAGE WILL HAVE TO BE FREED IN CASE OF  ABEND IN FETCH.
         SPACE 1
*/*PGMFETCH: P SET R9= ADDR OF CDE (VIA R11) IN COMP FORM FOR FETCH*/
*/* P SAVE DCB ADDRESS  (R10) IN WKDCBSE*/
         SPACE 2
PGMFETCH EQU   *                       INTERFACE TO FETCH
         LA    CDEREG,ZERO(CDEREG)     CLEAR HIGH ORDER BYTE
         LNR   GR9,CDEREG              COMP R9 AS INPUT TO FETCH
         ST    DCBREG,WKDCBSE          SAVE DCB ADDRESS IN W.A.
         SPACE 2
*/* D (NO,DEBCHKON,YES,) SYSTEM REQUEST? (RBCSSYSR =1) */
*/* P SUPPRESS DEB CHECK BY SETTING FLAG WKSYSREQ ON IN FETCH W.A.*/
         SPACE 2
         TM    RBCSFLG1,RBCSSYSR       Q. IS THIS A SYSTEM REQUEST
         BZ    DEBCHKON                A. NO-LET FETCH TO DO DEB CHECK
         OI    WKFLG1,WKSYSREQ         A. YES- SURPRESS FETCH DEB CHECK
         SPACE 2
*/*DEBCHKON: P SET R7 = DCB ADDR (R7=R10)*/
*/* P SET SUBPOOL ID = 251 (SET R10=251)*/
         SPACE 2
DEBCHKON LR    GR7,DCBREG              SAVE DCB ADDRESS
         LA    GR10,SPNONREN           SET SUBPOOL ID = 251
         SPACE 2
*/* D (NO,KETCHIT,YES,) MODULE RENTRANT? (CDREN VIA R11 =1) */
         SPACE 2
         TM    CDATTR,CDREN            Q. IS MODULE REENTRABLE
         BZ    KETCHIT                 A=NO, TAKE BRANCH
         SPACE 2
*/* D (NO,KETCHIT,YES,) AUTH LIB BIT ON (DEBAPFIN =1)*/
         SPACE 2
         USING DEBBASIC,DEBREG                                 @ZA28494
         TM    DEBFLGS1,DEBAPFIN       IS DEB AUTHORIZED?      @ZA28494
         BZ    KETCHIT                 NOT AUTH. - USE SP 251
         DROP  DEBREG                                          @ZA28494
         SPACE 2
*/* D (NO,FETCHIT,YES,) IS TSO TEST IN PROCESS? (TCBTCP =1) */
         SPACE 2
         TM    TCBTRN,TCBTCP           IS TEST BIT ON.
         BZ    FETCHIT                 NO BRANCH USE SUBPOOL 252
         SPACE 2
*/*D (NO,KETCHIT,YES,) SYSTEM REQUEST (RBCSSYSR =1) */
         SPACE 2
         TM    RBCSFLG1,RBCSSYSR       Q. IS THIS A SYSTEM REQ.
         BZ    KETCHIT                 Q. NO- USE SP 251
         SPACE 2
*/*FETCHIT: P SET SUBPOOL ID = 252 (SET R10=252)*/
*/* P TURN OFF JPA INDICATOR IN RQSTD CDE (SET CDJPA=0)*/
         SPACE 2
FETCHIT  LA    GR10,SPRENT             SET SUBPOOL ID = 252
         NI    CDATTR,MAX-CDJPA        RESET JPA BIT IN CDENTRY
         SPACE 2
*/*KETCHIT: L SETFRR-- REMOVE RECOVERY ROUTINE FROM STACK */
*/* P CLEAR FRR PARM LIST PTR (SET RBCSFRRA = 0)*/
         SPACE 2
KETCHIT  EQU   *
         SETFRR D,WRKREGS=(11,12)
         SR    R11,R11                 CLEAR REG. TO ZERO PARM.
         ST    R11,RBCSFRRA            LIST ADDR.
         SPACE 2
*/* L SETLOCK-- FREE CMS LOCK OBTAINED BEFORE LPA SEARCH */
         SPACE 2
         SETLOCK RELEASE,TYPE=CMS,RELATED=('FREED OVER FETCH')
         SPACE 2
*/* L SETLOCK-- FREE LOCAL LOCK */
         SPACE 2
         SETLOCK  RELEASE,TYPE=LOCAL,RELATED=('FREED OVER FETCH')
         SPACE 2
*/* P SET R3= ADDR CVT & R13= FETWK ADDR FOR FETCH*/
*/* $ */
*/* COMMENT (5,1) FETCH INPUT--*/
*/* COMMENT (6,1) R5= SVRB ADDR*/
*/* COMMENT (7,1) R7=DCB ADDR*/
*/* COMMENT (8,1) R9=COMP CDE AD*/
*/* COMMENT (9,1) R10=SUBPOOL ID*/
*/* COMMENT (10,1) R13=FETWK ADDR*/
*/* COMMENT (11,1) R14=RET ADDR*/
*/* COMMENT (12,1) R15=FETCH EP*/
*/* L IEWMSEPT-- CAUSE FETCH TO BRING MODULE INTO STORAGE */
         SPACE 2
         L     CVTREG,CVTPTR           GET CVT ADDRESS           MDC196
         L     GR13,RBCSWORK           GET FETCH WORKAREA
*                                                                YM8234
         L     GR15,CVTFETCH           R15-ENTRY POINT TO FETCH  MDC196
         BALR  GR14,GR15               GO TO PROGRAM FETCH
         SPACE 2
*/* P RE-ESTABLISH BASEREG (R6) */
         SPACE 2
         BALR  BASEREG,ZERO            ESTABLISH  BASE ADDRESSABILITY
         USING *,BASEREG               TEMPORARY BASE
         L     BASEREG,LINKBASE        SET UP PERMANENT BASE VALUE
         USING IEAVLK01,BASEREG        SET BASE
         SPACE 2
*/* P CLEAR ABEND REGISTER (R13) */
*/* D (YES,,NO,FETCHOK) ANY ERRORS DURING FETCH? (R15 NOT 0)*/
*/* COMMENT (2,15) 106 ABEND IF*/
*/* COMMENT (3,15) FETCH ERROR*/
*/* S RERIG: SET ENVIRN INCL. FRR & LOCAL LOCK*/
*/* P (,ERRFETCH) SET ABEND REGISTER R13 TO ZERO*/
         SPACE 2
         SR    R13,R13                 ZERO REG 13 FOR ERROR ROUTINE
         LTR   GR15,GR15               Q. ANY ERRORS IN FETCHING
         BZ    FETCHOK                 TO FETCHOK IF NO        @YA01851
         BAL   SUBREG1,RERIG           RESTORE REGS & LOC LOCK @YA01851
         L     AREAREG,RBCSWORK        LOAD FETCH WA ADDR      @ZA26977
         SR    R13,R13                 CLEAR ABEND REGISTER    @YA01851
         B     ERRFETCH                FETCH ERROR = 106       @YA01851
         SPACE 2
*/* FETCHOK: P SAVE ENTRY POINT RETURNED BY FETCH (R15=R12)*/
*/* S RERIG:RESTORE REGS DESTROYED BY FETCH */
*/* P PUT RELOCATED ENTRY POINT IN RQSTD CDE (CDENTPT= R15)*/
         SPACE 2
FETCHOK  LA  SUBREG2,N0(GR12)      SAVE E.P. RETURNED BY FETCH @YA01851
         BAL   SUBREG1,RERIG           ROUTINE TO RESTORE REGS
         ST    SUBREG2,CDENTPT         STORE RELOCATED ENTRY POINT
         SPACE 1
*        APF CHECKING FOR FETCHED MODULE.  MODULE WILL BE AUTHORIZED IF
*        IT CAN PASS RIGID QUALIFICATIONS.
*/* P SET R1= ADDR OF MAJOR CDE (R1=R12)*/
*/* P SET AREAREG= ADDR FETWK (R7= RBCSWORK)*/
         SPACE 2
         LR    R1,CDIREG               GET MAJOR ADDRESS
         L     AREAREG,RBCSWORK        LOAD FETCH WA ADDR
         SPACE 2
*/*APFOFF: P TURN OFF AUTHORIZATION FLAG (CDAUTH) IN CDE VIA R1*/
*/* P GET NEXT CDE (SET R1= CDCHAIN OF RB VIA R1)*/
*/* D (YES,ALLDONE,NO,) END OF CDE QUEUE? (R1=0)*/
*/* D (YES,APFOFF,NO,) IS CDE A MINOR? (CDMIN=1)*/
         SPACE 2
APFOFF   EQU   *                       TURN OFF APF IN MAJOR AND MINORS
         NI    CDATTR2-CDENTRY(R1),MAX-CDAUTH TURN OF AUTHORIZATION
         ICM   R1,MASK,CDCHAIN+N1-CDENTRY(R1) GET NEXT CDE
         BZ    ALLDONE                 IF END OF QUEUE, LEAVE LOOP
         TM    CDATTR-CDENTRY(R1),CDMIN IS CDE A MONOR
         BO    APFOFF                  YES, TURN OFF BIT
*                                      END OF LOOP WHEN NEXT MAJOR
         SPACE 2
*/*ALLDONE: P RESET CVT POINTER IN CVTREG  (R3) */
*/* D (NO,JSCBOFF,YES,) LIBRARY AUTHORIZED? (WKAUTH=1)*/
*/* COMMENT (1,1) WKAUTH BIT IS*/
*/* COMMENT (2,1) SET BY FETCH*/
*/* COMMENT (3,1) VIA A DEB BIT*/
         SPACE 2
ALLDONE  EQU   *                       END OF BIT OFF LOOP
         USING CVT,CVTREG              SET ADDRESSABLE
         L     CVTREG,CVTPTR           RESET CVT REGISTER
         TM    WKFLG1,WKAUTH           Q. LIB AUTHORIZED
         BZ    DSS06                   NO - CONTINUE           @ZA24461
         SPACE 2
*/* D (NO,SETAUTHL,YES,) IS MOD. REENTRANT? (CDREN =1)*/
         SPACE 2
         TM    CDATTRJ,CDREN           Q. IS MODULE REENTRABLE
         BZ    SETAUTHL                NO - SET AUTH. LIB INDIC.
         SPACE 2
*/* D (NO,SETAUTHL,YES,) MODULE IN JPA? (CDJPA =1)*/
         SPACE 2
         TM    CDATTRJ,CDJPA           Q. JPA MOD CAN NOT BE AUTH.
         BZ    SETAUTHL                LIB. IN ANY CASE.
         SPACE 2
*  IF REENT. AND SP 251, A DESCREPENCY EXISTS.  IF TEST IS IN CONTROL
*  TURN OFF INDICATOR AND CONTINUE.  IF NOT ISSUE A 306 ABEND.
*/* D (NO,,YES,DSS06) TSO TEST IN CONTROL? (TCBTCP =1)*/
*/* P CLEAR ABEND REGISTER (R13)*/
*/* P (,ERRSYSR) SET RETURN CODE = X'0C' IN R15*/
         SPACE 2
         TM    TCBTRN,TCBTCP            Q. TEST IN CONTROL
         BO    DSS06                    A. YES- CONTINUE
         SR    R13,R13                  CLEAR ABEND REG
         LA    R15,N12                  SET REASON CODE
         B     ERRSYSR                  ISSUE ABEND
         SPACE 2
*/*SETAUTHL: P SET AUTH LIB INDICATOR (CDSYSLIB) IN MAJOR CDE */
         SPACE 2
SETAUTHL OI    CDATTR2J,CDSYSLIB       INDICATE LIBRARY AUTH. IN MAJOR
         SPACE 2
*/*APF02 D (NO,DSS06,YES,) AOS LINKEDIT? (PDSAOSLE =1) */
         SPACE 2
APF02    DS    0H                      CHECK PDS AUTHORIZATION
         USING PDS2-WKNAME+WKAREA,AREAREG POINT TO PDS IN FETCH W.A.
         TM    PDS2FTB1,PDSAOSLE       IS IT AOS LINK EDIT
         BNO   DSS06                   NO, CANT AUTHORIZE
         SPACE 2
*/* D (NO,DSS06,YES,) LINKEDITED WITH APF ATTR (PDSAPFLG =1)*/
         SPACE 2
         TM    PDS2FTB1,PDSAPFLG       CHECK FOR APF INFO
         BZ    DSS06                   IF NONE, CANT AUTHORIZE
         SPACE 2
*/* P GET END OF BASIC PDS SECTION */
         SPACE 2
         LA    R14,PDSBCEND            POINT TO APF IF COMMON SECTION
*                                      ONLY. WILL ADD OFFSETS FOR EACH
*                                      ADDITIONAL SECTION PRESENT
         SPACE 2
*/* D (NO,APF05,YES,) SCATTER INFO. IN PDS (PDS2SCTR =1)*/
*/* P ADD LENGTH OF SCATTER SECTION OF PDS */
         SPACE 2
         TM    PDS2ATR,PDS2SCTR        CHECK FOR SCATTER SECTION
         BNO   APF05                   IF NONE, SKIP ADD
         LA    R14,PDSS01LN(R14)       ADDD SCATTER SIZE
         SPACE 2
*/*APF05: D (NO,APF06,YES,) LINKEDITED WITH ALIAS (PDS2ALIS =1)*/
*/* P ADD LENGTH OF ALIAS SECTION OF PDS */
         SPACE 2
APF05    EQU   *                       SKIP SCATTER LABEL
         TM    PDS2INDC,PDS2ALIS       CHECK FOR ALIAS SECTION
         BNO   APF06                   IF NONE, SKIP ADD
         LA    R14,PDSS02LN(R14)       ADD ALIAS LENGTH
         SPACE 2
*/*APF06: D (NO,APF08,YES,) ANY SSI INFO (PDS2SSI =1)*/
*/* P ROUND UP TO HALFWORD ALIGNMENT AND ADD SSI SIZE */
         SPACE 2
APF06    EQU   *                       ALIAS SKIP LABEL
         TM    PDS2FTB1,PDS2SSI        CHECK FOR SSI
         BNO   APF08                   IF NONE, SKIP ADD
         LA    R14,N1(R14)             ROUND UP TO HALFWORD
         N     R14,APFROUND            BOUNDARY ALIGNMENT
         LA    R14,PDSS03LN(R14)       ADD SSI SIZE
         SPACE 2
*/*APF08: P GET APF INFORMATION FROM PDS */
*/* D (NO,DSS06,YES,) MODULE AUTHORIZED (PDSAPF =1)*/
*/* P SET R1= CDE ADDR (R1=R12)*/
         SPACE 2
APF08    EQU   *                       SKIP SSI LABEL
         OC    PDSAPFAC-PDSAPF(APFLN,R14),PDSAPFAC-PDSAPF(R14) @ZA08130
*                                      TEST APF FLAGS FOR ZERO @ZA08130
         BZ    DSS06                   NOT AUTHORIZED, SKIP SETTINGS
         LR    R1,CDIREG               GET MAJOR CDE
         SPACE 2
*/*APFON: P SET AUTH. IND. ON IN CDE VIA R1 (CDAUTH =1)*/
*/* P SET R1= NEXT CDE (R1= CDCHAIN OF RB VIA R1)*/
*/* D (YES,DSS06,NO,) END-OF-QUEUE? (R1=0) */
*/* D (NO,DSS06,YES,APFON) CDE A MINOR? (CDMIN =1) */
         SPACE 2
APFON    EQU   *                       SET ALL CDES AUTHORIZED
         OI    CDATTR2-CDENTRY(R1),CDAUTH TURN ON AUTH BIT
         ICM   R1,MASK,CDCHAIN+N1-CDENTRY(R1) GET NEXT CDE ADDR
         BZ    DSS06                   NONE LEFT, LEAVE
         TM    CDATTR-CDENTRY(R1),CDMIN IF THIS IS A MINOR CDE
         BO    APFON                   SET IT AUTHORIZED
         DROP  AREAREG                 DROP PDS
         USING WKAREA,AREAREG          RESET WORKAREA ADDRESSING
         EJECT
* THE FOLLOWING INSTRUCTION IS THE INTERFACE TO DSS FROM CONTENTS
*  SUPERVISION.  THE REGISTERS MUST BE SET UP AS FOLLOWS -
*  REGISTER  4 = ADDRESS OF TCB
*  REGISTER 11 = ADDRESS OF MINOR CDE IF ONE EXISTS,ELSE MAJOR CDE
*  REGISTER 12 = ADDRESS OF MAJOR CDE
         SPACE 2
*/*DSS06: L DSS-- IF DSS ACTIVE GIVE IT CONTROL */
*/* $ */
*/* COMMENT (6,3) DSS INTERFACE---*/
*/* COMMENT (7,3) R4=TCB ADDR*/
*/* COMMENT (8,3) R11=MINOR CDE ADDR*/
*/* COMMENT (9,3) R12=MAJOR CDE ADDR*/
DSS06     BCR    N0,N0                   RESERVED
         SPACE 1
*  TEST IF ISSUER IS AN SVRB.IF IT IS THEN BYPASS TESTING
*  BIT IN THE TCB FOR USING TESTRAN. IF ISSUER IS NOT AN SVRB,
*  THEN TEST BIT IN TCB FOR TEST COMMAND. IF TEST BIT IS ON,
*  TESTRAN IS TO BE USED WHETHER OR NOT THE TEST ATTRIBUTE IS
*  INDICATED IN THE DIRECTORY.
*/* D (YES,CKTESTON,NO,) RB POINT TO TCB ? */
*/* P SET R1= ADDR OF CALLING RB (VIA RBLINK OF PM SVRB)*/
*/* D (YES,OKLAHOME,NO,) CALLER AN SVRB? */
         SPACE 2
         TM    RBSTAB2-RBSECT(RBREG),RBTCBNXT  RBPOINT TO TCB  @ZA03829
         BO    CKTESTON                YES-CHECK FOR TSO TEST  @ZA03829
         L     R1,RBLINKZ(RBREG)       GET RB LINK FIELD
         TM    RBSTABZ(R1),RBFTSVRB    IS ISSUER AN SVRB
         BO    OKLAHOME                YES BYPASS TESTING BIT IN TCB
         SPACE 2
*/*CKTESTON: D (YES,TESTON,NO,) IS TSO TEST IN CONTROL? (TCBTCP=1)*/
         SPACE 2
CKTESTON TM    TCBTRN,TCBTCP           IS TEST BIT ON
         BO    TESTON                  IF ON SKIP DE CHECKING
*/* D (YES,OKLAHOME,NO,) IS IT NIP? */
         USING CVT,CVTREG              SET ADDRESSABILITY    @ZA07512
         L     CVTREG,CVTPTR           RESET CVT REGISTER    @ZA07512
         TM    CVTOPTA-CVT(CVTREG),CVTNIP IS IT NIP?         @ZA07512
         BO    OKLAHOME                YES-SKIP TSO TEST SVC @ZA07512
         SPACE 2
*/* D (NO,OKLAHOME,YES,) MOD LKED WITH TEST OPTION? (PDS2TEST =1)*/
         SPACE 2
         TM    WKATTR,PDS2TEST         IS DE MARKED TEST
         BNO   OKLAHOME                IF NOT SKIP TESTRAN
         SPACE 1
***********************************************************************
*/*TESTON: L SETFRR-- REMOVE RECOVERY ROUTINE BEFORE SVC */
*/* P CLEAR FRR PARM LIST PTR (SET RBCSFRRA =0)*/
         SPACE 2
TESTON   EQU   *                       INTERFACE WITH TESTRAN
         LR    R1,R12                  SAVE CDE ADDR.
         SETFRR D,WRKREGS=(11,12)
         SR    R11,R11                 CLEAR REG. FOR ZEROING
         ST    R11,RBCSFRRA            PARM. LIST AREA
         SPACE 2
*/* L SETLOCK-- FREE LOCAL LOCK BEFORE SVC */
         SPACE 2
         SETLOCK  RELEASE,TYPE=LOCAL,RELATED=('FREED OVER SVC 61')
         SPACE 2
*/* P SET R1 (VIA WKDCBSE) =COMP DCB ADDR FOR TEST SVC */
*/* $ */
*/* COMMENT (5,3) TSO INTERFACE---*/
*/* COMMENT (6,3) R1=COMP DCB ADDR*/
*/* COMMENT (7,3) R3=CVT ADDR*/
*/* COMMENT (8,3) R4=TCB ADDR*/
*/* COMMENT (9,3) R5=SVRB ADDR*/
*/* COMMENT (10,3) SVRB+X'74'=FETWK ADDR*/
*/* COMMENT (11,3) WKCDADDR=RQSTD CDE ADDR*/
*/* COMMENT (12,3) WKNAME=RQSTD NAME*/
*/* L SVC 61 (TEST)-- CALL TSO TEST SVC */
         SPACE 2
         L     R1,WKDCBSE              PICK UP DCB ADDR FROM FETCH WORK
*                                      AREA . DCB ADDR IS IN IOB .
*        IKJEGS6A CNTSUP,PARAM=(1)    CALL SVC 61-TSO TEST
         LNR   R1,R1
         SVC   TTSAVE                  CALL TEST SVC
         SPACE 2
*/* S RERIG:SET ENVIRONMENT INCL. FRR AND LOCAL LOCK */
         SPACE 2
         BAL   SUBREG1,RERIG           RELOAD REGS 11 & 12
         SPACE 2
*/*OKLAHOME: P TURN NIC (NOT-IN-CORE) BIT OFF IN MAJOR CDE */
*/* D (YES,ISLOAD,NO,) REQUEST FOR LOAD? (RBCDLOAD =1) */
*/* P SET NOT-FUNCTIONAL FLAG IN RQSTD CDE */
         SPACE 2
OKLAHOME NI    CDATTRJ,MAX-CDNIC       RESET NIC FLAG IN MAJOR.
         TM    RBCDFLGS,LOAD           LOAD REQUEST.
         BO    ISLOAD                  BYPASS SETT'G NFN IF YES.
         OI    CDATTR,CDNFN            SET NFN FLAG.
         SPACE 2
*/*ISLOAD: D (NO,CDFOLDUP,YES,) ALIAS REQUEST? (CDMIN =1 IN RQSTD
*/*CDE)*/
         SPACE 2
ISLOAD   TM    CDATTR,CDMIN            TEST  IF ALIAS HANDLING CURRENT
         BNO   CDFOLDUP                NO, BRANCH
         EJECT
*THE FUNCTION OF THE FOLLOWING ROUTINE IS TO  COMPLETE THE CDENTRY
*CREATED FOR THE MAIN NAME OF THE MODULE JUST FETCHED. THE ENTRY POINT
*TO THE  MAIN NAME MUST BE RELOCATED AND THE NOT IN CORE (NIC) FLAG
*RESET TO ZERO.
*
* IF A REQUEST IS MADE FOR A MODULE BY A MINOR NAME, AND THE
* MODULE MUST BE BROUGHT INTO CORE, THE MINOR ENTRY POINT IS
* RELOCATED BY FETCH.  THE RLC BIT IS TURNED ON IN THE CDATTR2
* FIELD.  THIS BIT IS NOT TURNED ON IF QLK RELOCATES THE MINOR
* ENTRY POINT IN THE CDFOLDUP SUBROUTINE.
* THE CDFOLDUP ROUTINE RELOCATES MINOR ENTRY POINTS IF THE
* MODULE WAS INITIALLY REQUESTED BY A DIFFERENT NAME.
*
*        REGISTER USAGE
*        R3 - ALTERED
*        R6 - BASE (IEAVLK01)
*        R7 - BLDL FETCH WORK AREA (INPUT)
*        R11- REQUESTED CDE (INPUT)
*        R12- MAJOR CDE (INPUT)
*        R14- ALTERED
*        OTHER REGISTERS NOT REFERENCED
         SPACE 1
*/* P SET R14= MAJOR ENTRY POINT */
*/* S RELOCATE:RELOCATE THE ENTRY POINT (R14= WKMAINEP)*/
*/* P PUT RELOCATED ENTRY POINT IN MAJOR CDE FIELD CDENTPT */
*/* P SET NIC (NOT-IN-CORE) BIT OFF IN RQSTD CDE */
*/* P SET RELOCATED ENTRY POINT BIT (CDRLC) ON IN RQSTD CDE */
         SPACE 2
         L     SUBREG1,WKMAINEP        LOAD ENTRY POINT OF MAIN NAME
         BAL   COMREG,RELOCATE         GO TO ROUTINE TO CALCULATE
*                                      RELOCATED ENTRY POINT ADDRESS.
         ST    SUBREG1,CDENTPTJ        STORE RELOCATED ENTRY POINT
*                                      IN CDENTRY
         NI    CDATTR,MAX-CDNIC        RESET NIC FLAG IN MINOR CDE
         OI    CDATTR2,CDRLC           SET FLAG TO INDICATE RELOCATED
*                                      MINOR BY FETCH.
         EJECT
* RELOCATE ENTRY POINTS OF QUEUED MINORS.
* A MODULE IS REQUESTED BY A MINOR NAME.  THE MAJOR NAME IS
* FOUND TO BE IN CORE BUT THE REQUESTOR IS WAITING ON I/O.
* THE REQUESTOR OF THE MINOR NAME IS QUEUED UP.  WHEN THE MAJOR
* REQUESTOR REGAINS CONTROL, THE QUEUED MINOR CDE ENTRY POINTS
* ARE RELOCATED HERE, AND THE QUEUED REQUESTORS ARE DEQUEUED
* UNDER THE DQLOAD SUBROUTINE.
*
*        REGISTER USAGE
*        R1   - CHANGED
*        R3   - CHANGED
*        R5   - SVRB (INPUT)
*        R6   - BASE (IEAVLK01)
*        R9,10- CHANGED
*        R12  - MAJOR CDE (INPUT)
*        R15  - ALTERED
*        OTHER REGISTERS NOT REFERENCED
         SPACE 1
*/*CDFOLDUP: P SET R1= MAJOR CDE ADDR (R1=R12) */
         SPACE 2
CDFOLDUP DS    0H                      QUEUED MINORS
         DROP  CDEREG                  RESET CDE BASE
         USING CDENTRY,R1              RESET CDE BASE
         LR    R1,R12                  LOAD MAJ CDE IN REG 1.
         SPACE 2
*/*CD02: P SET R1= NEXT CDE ON QUEUE (R1= CDCHAIN OF CDE VIA R1)*/
*/* D (YES,CD01,NO,) END OF QUEUE? (R1=0) */
         SPACE 2
CD02     DS    0H                      RELOCATE LOOP
         L     R1,CDCHAIN              GET NEXT CDE ON QUEUE.
         LTR   R1,R1                   TEST OF END OF QUEUE
*                                      Q. END OF QUEUE.
         BZ    CD01                    BR IF YES.
         SPACE 2
*/* D (NO,CD01,YES,) MINOR CDE? (CDMIN =1) */
         SPACE 2
         TM    CDATTR,CDMIN            Q. IS CDE A MIN.
         BZ    CD01                    BR IF NOT.
         SPACE 2
*/* D (YES,CD02,NO,) MINOR RELOCATED BY FETCH? (CDRLC =1)*/
         SPACE 2
         TM    CDATTR2,CDRLC           Q.MINOR EP RELOC. BY FETCH
         BO    CD02                    BR IF YES.
         SPACE 2
*/* P SET R14= UN-RELOCATED ENTRY POINT FROM CDENTPT*/
*/* S RELOCATE:RELOCATE THE ENTRY POINT */
*/* P TURN NIC (NOT-IN-CORE) BIT OFF IN CDE */
*/* P (,CD02) PUT RELOCATED ENTRY POINT IN CDE (CDENTPT = R14) */
         SPACE 2
         L     R14,CDENTPT             GET UNRELOCATED E.P.
         BAL   COMREG,RELOCATE         TO RELOCATE EP.
         NI    CDATTR,MAX-CDNIC        RESET NIC FLAG IN MINOR CDE.
         ST    R14,CDENTPT             SET RELOCATED EP IN MIN CDE.
         B     CD02                    LOOP TO PROCESS ALL MINORS
         DROP  R1                      RESET CDE BASE
         USING CDENTRY,CDEREG          RESET CDE BASE
         SPACE 2
*/*CD01: P CLEAR QUEUE HEAD FIELD (CDRRBP) OF MAJOR CDE*/
*/* P INITIALIZE R9 FOR DQLOAD (R9=ADDR. OF SVRB) */
*/* S DQLOAD:DEQUEUE ANY WAITING REQUESTS */
         SPACE 2
CD01     DS    0H                      END OF CDES
         SR    WKREG2,WKREG2           ZERO TO INITIALIZE A FIELD
         ST    WKREG2,CDRBPJ           ZERO OUT QUEUE HEAD
*                                      PRIOR TO DQLOAD
         LR    GR9,RBREG               SET REGISTER FOR DQLOAD
         BAL   SUBREG2,DQLOAD          GO DEQUEUE ALL REQUESTERS
         SPACE 2
*/*CDMRGRET: P SET BASEREG (R6) FOR IEAVLK00 */
*/* R RETURN TO CDMERGE IN IEAVLK00 */
         SPACE 2
CDMRGRET L     GR15,TABLEADD           POINT TO ADDRESS TABLE
         USING ADDRTAB,GR15            ADDRESSABILITY ON ADDRESS LIST
         L     BASEREG,CDLKBASE        SET UO VLK00 ADDRESSABILITY
         L     GR15,CDEMERGE           POINT TO CDEMERGE
         BR    GR15                    GO TO CDEMERGE IN VLK00
         EJECT
*****  DQLOAD SUBROUTINE  *************************************
*
* THIS SECTION IS EXECUTED AFTER A MODULE HAS BEEN FETCHED . IT WILL
* CHECK IF A QUEUE HAS FORMED WHILE THE MODULE WAS BEING FETCHED, AND
* IF SO WILL EMPTY THE QUEUE BY MAKING ALL RB'S READY AND STORE INTO
* THE RBOPSW LOCATION THE ADDRESS OF CDCONTRL. A TEST OF PRIORITIES
* IS MADE TO DETERMINE IF ANY QUEUE'D RB HAS A TASK PRIORITY HIGHER
* THAN THE CURRENT, IF SO CONTROL WILL SUBSEQUENTLY BE RELINQUISHED
* TO THE HIGHER PRIORITY TASK.
*
* DQLOAD GETS INFORMATION STORED INTO THE CDE BY THE CDQUECTL
* SUBROUTINE.
*
* NOTE - IT IS THE RESPONSIBILITY OF THE CALLER OF THIS
*        SUBROUTINE TO ZERO OUT THE QUEUE HEAD OF THE WAIT
*        QUEUE. THE QUEUE STARTS AT THE CDE (CDRBP FIELD).
*
*        REGISTER USAGE
*        R3  - CVT OR LEFT AS ON INPUT (OUTPUT)
*        R5  - SVRB (INPUT)
*        R6  - BASE (IEAVLK01)
*        R9  - INPUT RB (ALTERED ON OUTPUT)
*        R10 - ALTERED
*        R11 - REQUESTED CDE (INPUT)
*        R14 - ALTERED
*        R15 - RETURN ADDRESS (INPUT)
*        OTHER REGISTERS NOT REFERENCED
         SPACE 1
*/*DQLOAD: E DQLOAD */
*/* P SAVE CDE ADDRESS (R11) IN RBCSGR0 */
*/* P SAVE CALLERS RETURN ADDRESS (R15) IN RBCSR15 */
*/* CARRYON: P GET ADDR OF RB TO BE DEQUEUED (R10= RBPGMQ OF RB VIA R9)
*/* */
*/* D (YES,,NO,PACOUT) ANY RBS TO BE DEQUEUED (R10 NOT 0)*/
         SPACE 2
DQLOAD   ST    CDEREG,RBCSGR0          PRESERVE CDE ADDR OVER INTERFACE
         ST    R15,RBCSGR15            SAVE RETURN ADDR.
CARRYON  ICM   NEXT,MASK4,RBPGMQZ(LAST) LAST = ADDR OF INPUT RB
*                                      TO BE DEQUEUED
*                                      Q. ANY RB'S Q'D OFF INPUT RB
         BZ    PACOUT                  A= NO  TAKE BRANCH
         SPACE 2
*/* P CLEAR RBPGMQ FIELD OF RB VIA R9 */
*/* P SET R9=R10*/
*/* P PUT ADDRESS OF RESTART ROUTINE (IEAQCS02) IN RESUME PSW OF RB VIA
*/* R9 */
*/* P INITIALIZE FOR POST W/O ECB- R10=RB ADDR, R11=0, R14= RETURN
*/*ADDR*/
         SPACE 2
         XC    RBPGMQ1Z(ADDL,LAST),RBPGMQ1Z(LAST) A= YES CLEAR RBPGMQ
         LR    LAST,NEXT               SAVE REG 10 OVER ROUTINE
         MVC   RBOPSWZR(WORD,LAST),CONTRLA SET UP ADDR IN PSW
         SR    GR11,GR11               INDICATE PRESENT ADDRESS SPACE
         SPACE 2
*/* L POST W/O ECB (BR ENTRY)-- POST THE WAITING RB */
         SPACE 2
         L     CVTREG,CVTPTR           INSURE CVT IN REG.
         L     R15,CVT0PT01            GET ADDRESS OF POST
         BALR  R14,R15                 GO TO POST W/O ECB
         SPACE 2
*/* P (,CARRYON) CLEAR CDE POINTER IN POSTED RB (SET RBCDE1 =0)*/
         SPACE 2
         XC    RBCDEAZ(ADDL,LAST),RBCDEAZ(LAST)  ZERO RBCDE
         B     CARRYON                 RETRY TEST FOR MORE
*                                      RB'S ON THE QUEUE
         SPACE 2
*/*PACOUT: P RESTORE CDE REGISTER (R11) FROM RBCSGR0*/
*/* P RESTORE CALLERS RETURN ADDRESS (R15) FROM RBCSGR15*/
*/* R RETURN TO CALLER VIA R15*/
         SPACE 2
PACOUT   L     CDEREG,RBCSGR0          RESTORE CDEREG
         L     R15,RBCSGR15            RESTORE RETURN ADDRESS
         BR    SUBREG2                 RETURN
         EJECT
*REGISTERS 4,5,11,12, ARE INITIALIZED IN THIS ROUTINE TO
*              4 = TCB
*              5 = RB         THIS ROUTINE IS USED TO RESTORE REGISTERS
*              11= MINOR CDE  THAT ARE CHANGED OVER  BLDL AND FETCH
*              12= MAJOR CDE
*              6 = BASE (IEAVLK01)
*              2,13= ALTERED
*              14= RETURN REGISTER (INPUT)
*              OTHER REGISTERS NOT USED
         SPACE 1
*/*RERIG: E RERIG */
*/* P SET TCBREG (R4) =ADDR OF TCB VIA PSATOLD*/
*/* P SET RBREG (R5) = ADDR OF SVRB VIA TCBRBP*/
         SPACE 2
RERIG    L     TCBREG,PSATOLD          LOAD ADDRESS OF CURRENT TCB
         L     RBREG,TCBRBP            LOAD ADDRESS OF CURRENT RB
         SPACE 2
*/* P SAVE RETURN ADDRESS (SET R2=R14)*/
*/* L SETLOCK-- GET LOCAL LOCK */
         SPACE 2
         LR    WKREG2,SUBREG1          SAVE RETURN REGISTER
         SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,                        x
               RELATED=('OBTAINS LOCK AFTER FETCH OR SVC 61')
         SPACE 2
*/* L SETFRR-- ESTABLISH RECOVERY ROUTINE */
*/* P SET RBCSFRRA = ADDR OF FRR PARM LIST*/
*/* P SET 1ST WORD OF FRR PARM LIST = PM SVRB ADDR*/
*/* P RESTORE RETURN ADDRESS (SET R14=R2)*/
         SPACE 2
         SETFRR A,FRRAD=FRRPGM,WRKREGS=(11,12),PARMAD=(13)
         ST    R13,RBCSFRRA            SAVE PARM. LIST ADDRESS
         ST    RBREG,N0(R13)           SAVE CURRENT RB (SVRB)
         LR    SUBREG1,WKREG2          RESTORE RETURN REGSITER
         SPACE 2
*/* P SET CDEREG = ADDR OF RQSTD CDE (R11= RBCDE1)*/
*/* P SET CDIREG = ADDR OF RQSTED CDE (R12=R11)*/
*/* D (YES,,NO,%XOUT) RQSTD CDE A MINOR (CDMIN =1)*/
*/* P SET R12= ADDR OF MAJOR CDE VIA CDXLMJP OF MINOR*/
*/* %XOUT: R RETURN TO CALLER */
         SPACE 2
         L     CDEREG,RBCDFLGS         PICK UP CDENTRY ADDRESS
         LA    CDEREG,N0(CDEREG)       CLEAR CDE FLAGS
         LR    CDIREG,CDEREG           SET MAJOR EQUAL MINOR
         TM    CDATTR,CDMIN            Q.IS AN ALIAS REQUEST CURRENT
         BCR   EQZER,SUBREG1           A=NO, RETURN
         L     CDIREG,CDXLMJP          PICK UP MAJOR CDE ADDRESS
         BR    SUBREG1                 RETURN
         EJECT
*RELOCATE SUBROUTINE TAKES AN ENTRY POINT  TO A MODULE THAT HAS PREVIOU
*SLY BEEN FETCHED AND ADDS A RELOCATION  FACTOR TO PRODUCE A RELOCATED
*ENTRY POINT.
*
*        REGISTER USAGE
*        R3  - RETURN REGISTER (INPUT)
*        R12 - MAJOR CDE (INPUT)
*        R14 - ENTRY POINT (UNRELOCATED ON INPUT,
*                             RELOCATED ON OUTPUT)
*        R15 - ALTERED
*        OTHER REGISTERS NOT REFERENCED
         SPACE 1
*/*RELOCATE: E RELOCATE */
*/* P GET EXTENT LIST ADDRESS FROM CDXLMJP OF MAJOR*/
*/* P SET R14= RELOCATED EP (R14= UNRELOCATD EP + LOAD ADDR IN XL*/
*/* R RETURN TO CALLER VIA R3 */
         SPACE 2
RELOCATE EQU   *
         L     SUBREG2,CDXLMJPJ        PICK UP XTLIST ADDRESS
         LA    SUBREG1,N0(SUBREG1)     ZERO HI ORDER BYTE
         A     SUBREG1,N12(SUBREG2)    ADD RELOCATION FACTOR TO ADDR
         BR    COMREG                  RETURN
         EJECT
*THIS ROUTINE ADDS THE CDENTRY ADDRESSED BY CDEREG TO THE CONTROL QUEUE
*ADDRESSED BY TABREG. THE ADDITION IS DONE IN A PUSH-DOWN  FASHION.
*
*        REGISTER USAGE
*        R4,5 - TCB,SVRB (INPUT)
*        R8   - ALTERED
*        R11  - INPUT CDE
*        R14  - RETURN ADDRESS (INPUT)
*        OTHER REGISTERS NOT REFERENCED
         SPACE 1
*/*CDEADD: E CDEADD */
*/* P SET R8= JOB STEP TCB ADDR FROM TCBJSTCB*/
*/* P CHAIN CURRENT 1ST CDE BEHIND NEW CDE (SET CDCHAIN = TCBJPA)*/
*/* P PUT NEW CDE POINTER INTO TCBJPA*/
*/* P SET RBCDE1 = ADDR OF NEW CDE*/
*/* P SET CDRRBP OF NEW CDE = ADDR OF PM SVRB*/
*/* R RETURN TO CALLER VIA R14 */
         SPACE 2
CDEADD   EQU   *
         L     TABREG,TCBJSTCB         LOAD JOB STEP TCB ADDR.
         MVC   CDCHAIN+N1(ADDL),TCBJSEZ+N1(TABREG) INITIALIZE CDCHAIN
         STCM  CDEREG,MASK,TCBJSEZ+N1(TABREG) MOVE IN LISTORG CDE ADDR.
         STCM  CDEREG,MASK,RBCDEA      MOVE INTO RB CDE ADDRESS
         ST    RBREG,CDRRBP            INITIALIZE CDRBP
         BR    SUBREG1                 RETURN
         EJECT
*
*        REGISTER USAGE
*        R0,1,2 - ALTERED
*        R4     - TCB (INPUT)
*        R6     - BASE(IEAVLK01)
*        R11-   - INPUT CDE
*        R13,14,15- ALTERED
*        OTHER REGISTERS NOT REFERENCED
*
         SPACE 1
*/*RETHRED: E RETHRED */
*/* P SET R1= ADDR OF JPAQ HEADER*/
*/*STARLITE: P SET R2= ADDR OF 1ST/NEXT CDE*/
*/* D (NO,THREDEND,YES,) ARE THERE MORE CDES ? */
*/* D (YES,THREDOUT,NO,STARLITE) IS THIS THE CDE TO UNHOOK? */
RETHRED  L     WKREG1,TCBJSTCB         LOAD ADDR OF JOB STEP TCB
         LA    WKREG1,TCBJSEZ(WKREG1)  PICK UP LIST ORG OF JPACQ
STARLITE SR    WKREG2,WKREG2          CLEAR WORK REG           @ZA03896
         ICM   WKREG2,MASK,N1(WKREG1)  GET NEXT CDE            @ZA03896
         BZ    THREDEND                NO RETURN TO CALLER     @ZA03896
         CLM   CDEREG,MASK,N1(WKREG1)  Q. IS THE THE CDE TO UNHOOK
         BE    THREDOUT                A=YES, TAKE  BRANCH
         LR    WKREG1,WKREG2           GO TO NEXT CDE
         B     STARLITE                CONTINUE IN LOOP
         SPACE 2
*/*THREDOUT: P UNHOOK CDE FROM JPA QUEUE */
*/* P SAVE R9 IN R0 & R10 IN R1*/
*/* P ZERO RB WAITING QUEUE HEADER (SET CDRRBP =0) */
*/* P SET R9= ADDR OF PM SVRB FOR DQLOAD*/
*/* S DQLOAD:DEQUEUE ALL WAITING RB'S */
*/* P RESTORE R9 FROM R0 AND R10 FROM R1*/
*/* THREDEND: R RETURN TO CALLER VIA R13 */
         SPACE 2
THREDOUT MVC   N1(ADDL,WKREG1),N1(WKREG2) UNHOOK CDE FROM JPACQ
         LR    R0,NAMEREG              SAVE NAMRREG
         LR    R1,DCBREG               SAVE DCBREG
         SR    WKREG2,WKREG2           ZERO TO INITIALIZE A FIELD
         ST    WKREG2,CDRRBP           ZERO QUEUE HEAD BEFORE
*                                      GOING TO DQLOAD
         LR    NAMEREG,RBREG           SET INPUT TO DQLOAD
         BAL   SUBREG2,DQLOAD          DQ ANY Q'D REQUESTS
         LR    DCBREG,R1               RESTORE DCBREG
         LR    NAMEREG,R0              RESTORE NAMEREG
THREDEND BR    R13                     RETURN
         EJECT
*
*        REGISTER USAGE
*        R13 - ABEND CODE (ZERO ON INPUT)
*        R15 - REASON CODE IF 106 OR 806 ABEND
*        R6  - BASE ADDRESS
*        OTHER REGISTERS NOT REFERENCED
         SPACE 1
*/*ERRBLDL: P ADD 1 TO R13  MAKES 806 ABEND CODE */
*/*ERRXCUTE: P ADD 3 TO R13  MAKES 706 ABEND CODE */
*/*ERRLONLY: P ADD 1 TO R13  MAKES 406 ABEND CODE */
*/*ERRSYSR: P ADD 2 TO R13  MAKES 306 ABEND CODE */
*/*ERRFETCH: P ADD 1 TO R13  MAKES 106 ABEND */
*/* D (YES,,NO,ERRRTN) ERRET SPECIFIED (RBCSERIN =1)*/
*/* P SAVE REGS R13 AND R15 IN R7 AND R8*/
*/* S RETHRED: DEQUEUE RQSTD CDE FROM JPAQ*/
*/* D (YES,,NO,ERRDQDON) WERE 2 CDES GOTTEN (RBCSTWO =1)*/
*/* P SET R11= ADDR OF 2ND (MAJOR) CDE (SET R11=R12)*/
*/* S RETHRED: DEQUEUE MAJOR CDE FROM JPAQ*/
*/*ERRDQDON: P (,ERRRTN) RESTORE R13 AND R15 FROM R7 AND R8*/
*/*ERRRTN: P SET BASEREG (R6) FOR MODULE IEAVLK00*/
*/* R RETURN TO ABNDSET IN IEAVLK00 */
ERRBLDL  LA    R13,N1(R13)             CODE = 806
ERRXCUTE LA    R13,N3(R13)             CODE = 706
ERRLONLY LA    R13,N1(R13)             CODE = 406
ERRSYSR  LA    R13,N2(R13)             CODE = 306
ERRFETCH LA    R13,N1(R13)             CODE = 106
         TM    RBCSFLG1,RBCSERIN       ERROR RETURN REQUESTED  @YA01851
         BZ    ERRRTN                  SKIP CLEANUP IF NO      @YA01851
         TM    CDATTR,CDNIP            IS IT LPA/MLPA MODULE   @ZA20311
         BO    ERRRTN                  YES THEN WONT RETHRED   @ZA20311
         STM   R13,R15,WKREGIS         SAVE ABEND/REASON CODES @ZA20311
         BAL   R13,RETHRED             DEQUE REQUESTED CDE     @YA01851
         L     R7,PSAAOLD              ASCB ADDR FOR FREEMAIN  @ZA20311
         TM    CDATTR,CDMIN            IS IT A MINOR CDE       @ZA20311
         BZ    FREEXLST                NO FREE XLST AND MAJOR  @ZA20311
         FREEMAIN RU,LV=CDESIZE,SP=255,A=(R11),BRANCH=YES      @ZA20311
         TM    RBCSFLG1,RBCSTWO        WAS THERE 2 NEW CDES    @YA01851
         BZ    ERRDQDON                TO ERRDQDON IF NO       @YA01851
         LR    R11,R12                 SET R11 TO NEW MAJOR    @YA01851
         BAL   R13,RETHRED             DEQUEUE NEW MAJOR CDE   @YA01851
FREEXLST SR    R1,R1                   CLEAR REGISTER FOR ICM  @ZA20311
         ICM   R1,MASK,CDXLMJP+N1      GET XLIST ADDRESS       @ZA20311
         BZ    FREECDE                 NO THEN FREE THE CDE    @ZA20311
         USING XTLST,R1                SET UP ADDRESSABILITY   @ZA20311
         L     R0,XTLLNTH              GET XLIST SIZE          @ZA20311
         DROP  R1                      RELEASE THE REGISTER    @ZA20311
         FREEMAIN RU,LV=(R0),SP=255,A=(R1),BRANCH=YES          @ZA20311
FREECDE  DS    0H                      LABEL FOR BRANCH        @ZA20311
         FREEMAIN RU,LV=CDESIZE,SP=255,A=(R11),BRANCH=YES      @ZA20311
ERRDQDON L     AREAREG,RBCSWORK        RESTORE WORKREG FOR LM  @ZA28886
         LM    R13,R15,WKREGIS         RESET ABEND/REASON CODES@ZA28886
ERRRTN   L     RETURN,TABLEADD         GET ADDR LIST IN VLK00  @YA01851
         DROP  GR15                    MUST NOT USE REG 15 FOR TABLE
*                                      BECAUSE IT CONTAINS REASON CODE
         USING ADDRTAB,RETURN          SET UP ADDRESSABILITY TO VLK00
         L     BASEREG,CDLKBASE        SET UP VLK00 ADDRESSABILITY
         L     RETURN,ABNDSET          POINT TO ABNDSET
         BR    RETURN                  GO TO IT
         SPACE 2
*/* FOOTING
*/*
*/*  */
*/*IEAVLK01: END END SECOND OF TWO MODULES */
         EJECT
*
*                                      EXECUTED INSTRUCTION
*
TESTAPF  OC    PDSAPFAC-PDSAPF(ZERO,R14),PDSAPFAC-PDSAPF(R14) TEST APF
*
*                                      ADDRESS CONSTANTS
*
TABLEADD DC    A(IEAQCS04)             POINTS TO ADDRESS TABLE
LINKBASE DC    A(IEAVLK01)             USED TO SET CORRECT BASE
*                                      FOR ADDRESSIBILITY
IEAQLCTA DC    A(IEAQLPAQ)             ADDRESS OF LINK PACK AREA
*                                      CONTROL QUEUE . ALSO IN CVT
SVCDCBA  DC    A(SVCDCB)               ADDRESS OF SVC LIB DCB
LINKDCBA DC    A(LINKDCB)              ADDRESS OF LINK LIB DCB
CONTRLA  DC    A(IEAQCS02)             ADDRESS OF LINK MAINLINE
*
*                                      MASKS AND CONSTANTS
*
APFROUND DC    X'FFFFFFFE'             ROUND TO HALFWORD AND-MASK
BLDLMASK DC    X'0001003C'             USED FOR BLDL WORK MASK
FRRPGM   DC    A(FRRPGMMG)             ADDRESS OF RECOVERY FOR PGM.MGR.
         EJECT
ADDRTAB  DSECT MAPS ADRESS LIST IN IEAVLK00
CDLKBASE DS    A                       BASE VALUE
CDCONTRL DS    A                       QUEUE SEARCHES
CDEMERGE DS    A                       FINAL PROCESSING
CDQUECTL DS    A                       QUEUED REQUEST
PLUSCONT DS    A                       TEST CDE ATTRIBUTES
ABNDSET  DS    A                       ISSUE ABENDS
         EJECT
         IHACDE
CDEEND   EQU   *
CDESIZE  EQU   CDEEND-CDENTRY          SIZE OF CDE
CDATTR2Z EQU   CDATTR2-CDENTRY         OFFSET TO ATTRIBUTES
CDXLIN   EQU   CDESIZE+XTLSTSIZ        CDE AND EXTENT LIST SIZE
         EJECT
CDENTRYJ DSECT
         DS    (CDESIZE)C
CDATTRJ  EQU   CDENTRYJ+CDATTR-CDENTRY  MAJOR CDE DSECT
CDCHAINJ EQU   CDENTRYJ+CDCHAIN-CDENTRY  TO INCREASE
CDRBPJ   EQU   CDENTRYJ+CDRRBP-CDENTRY       OF THE
CDNAMEJ  EQU   CDENTRYJ+CDNAME-CDENTRY        CODE
CDUSEJ   EQU   CDENTRYJ+CDUSE-CDENTRY          WHILE MAINTAINING
CDENTPTJ EQU   CDENTRYJ+CDENTPT-CDENTRY        DEPENDANCY
CDATTR2J EQU   CDENTRYJ+CDATTR2-CDENTRY         ON THE
CDXLMJPJ EQU   CDENTRYJ+CDXLMJP-CDENTRY         MACRO
         EJECT
         IHAXTLST                      EXTENT LIST MAPPING     @ZA20311
         EJECT                                                 @ZA20311
         IHADCB                       DCB MAPPING MACRO       @ZA18512
         EJECT                                                @ZA18512
         IEZDEB
         EJECT
         IHAFETWK
         EJECT
         IHAFRRS
         EJECT
         IHALPDE
LPDEEND  EQU   *                       END OF LPDE DSECT
LPDCDE   EQU   CDESIZE                 LPDE CDE LENGTH
LPDEJ    DSECT
         DS    (LPDEEND-LPDE)C
LDATTRJ  EQU   LPDEJ+CDATTR-CDENTRY    MAJOR LPDE DSECT
LDCHAINJ EQU   LPDEJ+CDCHAIN-CDENTRY  TO INCREASE
LDRBPJ   EQU   LPDEJ+CDRRBP-CDENTRY       OF THE
LDNAMEJ  EQU   LPDEJ+CDNAME-CDENTRY        CODE
LDUSEJ   EQU   LPDEJ+CDUSE-CDENTRY          WHILE MAINTAINING
LDENTPTJ EQU   LPDEJ+CDENTPT-CDENTRY        DEPENDANCY
LDATTR2J EQU   LPDEJ+CDATTR2-CDENTRY         ON THE
LDXLMJPJ EQU   LPDEJ+CDXLMJP-CDENTRY         MACRO
LDXTLTHJ EQU   LPDEJ+LPDEXTLN-LPDE
LDXLEPTJ EQU   LPDEJ+LPDEXTAD-LPDE
         EJECT
         IHARB
***********************************************************************
*                                                                     *
*                  REQUEST BLOCK ADDITIONAL LABELS INTERNAL           *
*                                                                     *
***********************************************************************
         ORG   RBEXSAVE                MAPPED INTO RBEXSAVE
RBCSEXSA EQU   *                       PROGRAM MANAGER USAGE OF
*                                      RB EXTENDED SAVE AREA FOR
*                                      REENTRANT DATA AREA
RBCSNAME DS    CL8                     ENTRY POINT NAME CALLER PASSED
RBCSDE   DS    0A                      ADDRESS OF DE SAVE AREA
         DS    C                       BYTE RESERVED
RBCSDEA  DS    AL3                     3 BYTE ADDRESS
RBCSERRA DS    F                       ADDRESS OF ERROR ROUTINE
RBCSFLG1 DS    B                       FLAG BYTE
RBCSGSF  EQU   X'80'                   GOOD SEARCH INDICATOR
*                                      ON MEANS IEAVVMSR WAS
*                                      SUCCESSFUL USED ONLY
*                                      IN IEAVLK01
RBCSSYSR EQU   X'40'                   SYSTEM REQUEST FLAG
RBCSPARM EQU   X'20'                   PARMATER CHECKING IN PROGRESS
RBCSERIN EQU   X'10'                   ERROR RETURN WAS REQUESTED
RBCSABEN EQU   X'08'                   ISSUE 906 ABEND
RBCSA306 EQU   X'04'                   ISSUE 306 ABEND
RBCSTWO  EQU   X'02'                   TWO NEW CDES            @YA01851
RBCRSAPF EQU   X'01'                   RESET APF AUTH          @WAB
RBCSFLG2 DS    B                       RESERVED FLAGS
RBCSFLG3 DS    B                       RESERVED FLAGS
RBCSFLG4 DS    B                       RESERVED FLAGS
RBCSWORK DS    0A                      ADDRESS OF BLDL FETCH W.A.
         DS    C                       RESERVED BYTE
RBCSWRKA DS    AL3                     3 BYTE ADDRESS
RBCSLLE  DS    0A                      ADDRESS OF LLE DURING LOAD
         DS    C                       RESERVED BYTE
RBCSLLEA DS    AL3                     3 BYTE ADDRESS
RBCSFRRA DS    F                       SAVE AREA FOR RECOVERY RTN.
*                                      PARM LIST
RBCSGR15 DS    F                       SAVE AREA FOR REGS 15 TO 1
RBCSGR0  DS    F                       OVER MODESET MACRO
RBCSGR1  DS    F                       INTERFACE
RBCSRESV DS    2F                      3 WORDS OF 12 IN WORK SAVE AREA
*                                      RESERVED FOR FUTURE EXPANSION
PRBSIZ   EQU   PRBEND-RBSECT           SIZE OF A PRB
*        FLAG SETTINGS FOR RBCDFLGS
LOAD     EQU   RBCDLOAD                ENTRY BY SVC LOAD
XCTL     EQU   RBCDXCTL                ENTRY BY SVC XCTL
SYNC     EQU   RBCDSYNC                ENTRY BY SVC SYNC
NODE     EQU   RBCDNODE                DO NOT GET A DE SAVE AREA FLAG
PRBPREF  EQU   RBPRFXND-RBPRFXST       LENGTH OF RB PREFIX
RBXXDSP  EQU   RBOPSW+4                USED FOR DISP PRIO IN CTL
RBCDEA   EQU   RBCDFLGS+1              EXTRA OFFSET
RBLINKA  EQU   RBWCF+1                 EXTRA OFFSET
         SPACE 3
*  THE FOLLOWING CODE WAS ADDED FOR AOS2 TO MAKE ALL CODE
*   DEPENDANT ON THE RB DSECT SUPPLIED BY THE OFFICIAL MACRO
*    THE ORIGINAL EQUATES FOR THE NAMES WERE DELETED
*     AND THE PRB DSECT CHANGED
         SPACE 3
RBSTABZ  EQU   RBSTAB-RBSECT           ALTERNATE
RBCDEZ   EQU   RBCDFLGS-RBSECT         ALTERNATE
RBOPSWZ  EQU   RBOPSW-RBSECT           ALTERNATE
RBPGMQZ  EQU   RBPGMQ-RBSECT           ALTERNATE
RBLINKZ  EQU   RBWCF-RBSECT            ALTERNATE
RBWCFZ   EQU   RBWCF-RBSECT            ALTERNATE
RBCDEAZ  EQU   RBCDFLGS-RBSECT+1       CDE ADDRESS IN RB
RBXXDSPZ EQU   RBOPSWZ+4               USED FOR DISP PRIO
RBLINKAZ EQU   RBWCF-RBSECT+1          ALTERNATE
RBOPSWZR EQU   RBOPSWZ+4               ALTERNATE
RBSTAB2Z EQU   RBSTAB2-RBSECT          ALTERNATE
RBPGMQ1Z EQU   RBPGMQ1-RBSECT          ALTERNATE
         EJECT
***********************************************************************
*                                                                     *
*              PDS DIRECTORY ENTRY                                    *
*                                                                     *
***********************************************************************
         IHAPDS
DEMAX    EQU   PDSBCLN+PDSS01LN+PDSS02LN+PDSS03LN+PDSS04LN MAX DE SIZE
         EJECT
DESAVE   DSECT                         MAPPING OF DE SAVE AREA
DESAVESZ DS    F                       SAVE AREA FOR DE SIZE
DESAVEDE DS    15F                     60 BYTES DE SAVE AREA
         EJECT
***********************************************************************
*                                                                     *
*                    TASK CONTROL BLOCK                               *
*                                                                     *
***********************************************************************
         IKJTCB
TCBJLBDI EQU   TCBJLB-TCB          DISPLACEMENT IN TCB OF DCB ADR.
TCBMOTH  EQU   TCBOTC-TCB          DISPLACEMENT IN TCB OF MOTHER
TCBJSEZ  EQU   TCBJPQ-TCB          OFFSET TO JPAQ
TASKLIB  EQU   TCBJLB-TCB          TASKLIB DCB FIELD IN TCB
TASKSTEP EQU   TCBJSTCA-TCB            EQUATE FOR JSTCB
         EJECT
         IEZJSCB
         EJECT
         CVT   DSECT=YES,PREFIX=NO
         EJECT
         IHAASCB
         EJECT
         IHAPSA
         END
