         TITLE  '           IEAVLK00 COMMENTARY'
* /* START OF SPECIFICATIONS ****
*
*01*  MODULE-NAME = IEAVLK00 ( VS2 )
*
*01*  DESCRIPTIVE-NAME = PROGRAM MANAGER MODULE 1 OF 4
*
*01*  COPYRIGHT = NONE
*
*01*  STATUS = VERSION 2
*
*01*  CHANGE-ACTIVITY = YO27758, YO2753, ZA02572, ZA02730 - RELEASE2
*                       RELEASE 3 - ZA10799
*                       OZ16851 - SEE LABEL LOXLBLD            @ZA16851
*                       OZ17747 - SEE LABELS NOWTP AND BRANCHOU@ZA17747
*                       OZ17747 - SEE LABEL FREEWORK           @ZA17747
*                       OZ20311 - GET AND FREE LOCAL LOCK      @ZA20311
*                       OZ18512 - ALLOW FOR TWO BYTE EBCDIC REASON
*                                 CODE IN MESSAGE              @ZA18512
*                       OZ28684 - RESTORE REASON CODE AFTER FREEMAINS
*                                 ARE DONE FOR THE ERRET OPTION@ZA28684
*
*01*  FUNCTION = THIS MODULE CONTAINS THE DESCRIPTION AND CODE FOR
*              LINK   SVC 6   ENTER AT IGC006
*              XCTL   SVC 7   ENTER AT IGC007
*              LOAD   SVC 8   ENTER AT IGC008
*              DELETE SVC 9   ENTER AT IGC009
*              SYNCH  SVC 12  ENTER AT IGC012
*        THE SERVICE ROUTINES ABOVE RECEIVE CONTROL FROM THE SVC FIRST
*        LEVEL INTERRUPT HANDLER. EACH ROUTINE IS ENTERED WITH THE
*        LOCAL LOCK, AND
*        HOLDS THE LOCAL LOCK IN MOST SECTIONS OF CODE IN THIS MODULE.
*
*        ADDITIONAL CODE IS INCLUDED TO
*              PERFORM LINK FUNCTION FOR ATTACH.
*                                      ENTER AT IEAQCS01
*              RESTART A REQUEST THROUGH LINK.
*                                      ENTER AT IEAQCS02 (CDCONTRL)
*              START THE NEXT REQUEST ON A SERIALLY REUSABLE PROGRAM
*                                      ENTER AT IEAQCS03 (CDEPILOG)
*              INTERFACE WITH BLDL AND FETCH
*                                      BRANCH TO IEAVLK01
*
*01*  NOTES = THE FOLLOWING IS A DESCRIPTION OF THE DEPENDENCIES,
*     CONVENTIONS, AND FUNCTIONS OF IEAVLK00
*
*02*    CHARACTER-CODE-DEPENDENCIES = IEAVLK00 IS EBCDIC CHARACTER CODE
*       DEPENDENT. INSTRUCTIONS WITH DEPENDENCIES ARE PRECEDED WITH THE
*       FOLLOWING COMMENT.
*
*           THE NEXT INSTRUCTION IS EBCDIC CHARACTER CODE DEPENDENT.
*
*02*    DEPENDENCIES = NONE
*
*02*    PERFORMANCE = THE FOLLOWING IS A FUNCTIONAL DESCRIPTION OF
*       IGC006.  REFERENCES TO IEAVLK01  ARE INCLUDED TO CLARIFY THE
*       ORDER OF SEARCHES.  PLEASE REFER TO THE SPECIFICATIONS IN
*       IEAVLK01 FOR ADDITIONAL INFORMATION.
*
*        1. VALIDITY CHECK RESOURCES (ENTRY POINT NAME, PARAMETER
*           LISTS, ETC.) PRIOR TO MAIN LINE PROCESSING
*        2. PERFORM THE LINKAGE TO THE MODULE WHOSE ENTRY POINT NAME
*           HAS BEEN SPECIFIED IN THE MACRO INSTRUCTION.
*        3. IN PERFORMING THE LINKAGE A SPECIFIC ORDER IS FOLLOWED
*           IN SEARCHING FOR AND DETERMINING THE LOAD MODULE TO
*           WHICH LINKAGE IS DESIRED.
*              A. THE CONTENTS DIRECTORY ENTRIES (CDES) FOR LOAD
*                 MODULES CONTAINED IN THE JOB PACK AREA ARE
*                 SEARCHED FOR AN ENTRY CONTAINING THE SPECIFIED
*                 ENTRY POINT NAME (IN IEAVLK00).
*              B. IF THE DCB OPERAND WAS WRITTEN IN THE MACRO
*                 INSTRUCTION, THE SPECIFIED LIBRARY IS SEARCHED
*                 ( IN IEAVLK01).
*              C. IF THE DCB OPERAND WAS OMITTED IN THE MACRO
*                 INSTRUCTION, THE JOB LIBRARIES FOR ASCENDING
*                 ORIGINATING TCB'S (IF JOB LIBS EXIST) ARE SEARCHED
*                 UNTIL THE JOBSTEP TCB'S JOBLIB IS SEARCHED (IN
*                 IEAVLK01)
*              D. THE CONTENTS DIRECTORY ENTRIES FOR LOAD MODULES
*                 CONTAINED IN THE ACTIVE LINK PACK AREA ARE SEARCHED
*                 FOR AN ENTRY CONTAINING THE SPECIFIED ENTRY POINT
*                 NAME, VIA CDSEARCH IN IEAVLK00.
*              E. THE PAGEABLE LINK PACK AREA IS SEARCHED VIA
*                 IEAVVMSR IN IEAVLK00.
*              F. THE LINK LIBRARY IS SEARCHED IN IEAVLK01.
*
*        IF THE DE OPERAND, INSTEAD OF THE EP OR EPLOC OPERAND WAS
*        SPECIFIED IN THE MACRO INSTRUCTION, THE CONTENTS DIRECTORY
*        AND THE LIBRARIES ARE SEARCHED AS FOLLOWS.
*
*              A. THE CONTENTS DIRECTORY ENTRIES FOR LOAD MODULES
*                 CONTAINED IN THE JOB PACK AREA ARE SEARCHED, VIA
*                 CDSERACH IN IEAVLK00.
*              B. IF THE SPECIFIED DIRECTORY ENTRY IS FOR A LOAD
*                 MODULE CONTAINED IN THE LINK LIBRARY, THE CONTENTS
*                 DIRECTORY ENTRIES FOR THE ACTIVE LINK PACK AREA
*                 ARE SEARCHED IN IEAVLK00.
*              C. THE PAGEABLE LINK PACK AREA IS SEARCHED IN IEAVLK01
*              D. IF THE DCB OPERAND WAS WRITTEN THE LOAD MODULE IS
*                 FETCHED FROM THE LIBRARY IT SPECIFIES, IN IEAVLK01.
*              E. IF THE DCB OPERAND WAS OMITTED, THE 'Z-BYTE' IN THE
*                 DIRECTORY ENTRY WILL INDICATE WHETHER THE JOBLIB,
*                 LINKLIB, OR TASKLIB DCB SHOULD BE USED TO FETCH THE
*                 MODULE (IN IEAVLK01).
*
*        4. IN PERFORMING THE LINKAGE THE FOLLOWING WILL OCCUR:
*
*              A PROGRAM REQUEST BLOCK (PRB) WILL BE CREATED.
*                THE FOLLOWING FIELDS WILL BE SET
*                   RBSIZE   - NUMBER OF DOUBLE WORDS
*                   RBTCBNXT - SET IN RB WHICH POINTS TO THE TCB
*                   RBFDYN   - SET TO 1, RB IS DYNAMIC, AND SO CAN
*                              BE FREED UPON EXIT.
*                   RBCDE    - POINTER TO THE CONTENTS DIRECTORY
*                              ENTRY.
*                   RBOPSW   - SYSTEM MASK, PROTECTION KEY, PROBLEM
*                              STATE, PROGRAM MASK, ALL ARE PROP-
*                              OGATED FROM THE PREVIOUS LINKAGE
*                              FOR LINK, LOAD, AND XCTL. FOR ATTACH
*                              KEY AND STATE ARE TCB DEFINED, ALL
*                              MASKS ARE SET ENABLED.
*                   RBPGMQ   - WILL CONTAIN A QUEUE POINTER, FOR
*                              SERIALLY REUSABLE ROUTINES.
*                   RBWCF    - ZERO WAIT COUNT
*                   RBLINK   - CHAIN FIELD THROUGH WHICH THE RBS ARE
*                              QUEUED TO THE TCB. IF RBTCBNXT IS 1,
*                              THIS IS THE TCB ADDRESS.
*
*           A CONTENTS DIRECTORY ENTRY WILL BE CREATED IF THE
*           REQUIRED LOAD MODULE WAS NOT IN VIRTUAL STORAGE, OR DID
*           NOT HAVE REUSABLE ATTRIBUTES, OR WAS FOUND IN THE LPA
*           DIRECTORY.
*
*           WHEN A LOAD MODULE IS LOADED INTO VIRTUAL STORAGE AN
*           ENTRY POINT NAME IS PLACED IN THE CONTENTS DIRECTORY, AND
*           ITS ATTRIBUTES ARE EXAMINED. OF INTEREST ARE THE
*           FOLLOWING ATTRIBUTES:
*              REUSABILITY - TO ESTABLISH HOW SUBSEQUENT REQUESTS FOR
*                 THE SAME MODULE MAY BE SATISFIED.
*              LIBRARY SOURCE - TO DETECT LINK LIBRARY MODULES THAT
*                 ARE REENTERABLE, AND USE THEM ACROSS JOB STEPS.
*              IN TEST - DETECT A MODULE RUNNING UNDER TESTRAN.
*              ALIAS - DETECT THAT A MODULE HAS MORE THAN ONE ENTRY
*                 NAME, AND POSSIBLY MORE THAN ONE ENTRY POINT.
*                 AVOID HAVING THIS TYPE OF MODULE MORE THAN ONCE
*                 IF POSSIBLE.
*
*        5. FETCHING MODULES INTO ONE OF THE TWO PACK AREAS WILL BE
*           DONE ACCORDING TO ATTRIBUTES. REENTRANT MODULES FROM
*           VARIOUS LIBRARIES WILL HAVE BEEN PLACED IN THE PAGEABLE
*           LINK PACK AREA BY NIP. (NUCLEUS INITIALIZATION.)
*           ALL OTHERS WILL BE PLACED INTO VARIOUS JOB PACK AREAS
*           BY IEAVLK01.
*              ANY ADDITION TO THE ACTIVE LINK PACK AREA WILL BE
*              REFLECTED IN THE LINK PACK AREA CONTROL QUEUE, WHICH IS
*              A COLLECTION OF CONTENTS DIRECTORY ENTRIES DESCRIBING
*              ALL ACTIVE,MODIFIED, AND FIXED LOAD MODULES IN THE LINK
*              PACK AREA. THE ADDRESS OF BOTH THE LPA QUEUE AND THE
*              PAGED LINK PACK DIRECTORY ARE FOUND IN THE CVT.
*              ANY ADDITIONS TO THE JOB PACK AREA WILL BE REFLECTED
*              IN A JOB PACK AREA CONTROL QUEUE, WHICH IS A
*              COLLECTION OF CONTENTS DIRECTORY ENTRIES DESCRIBING
*              ALL LOAD MODULES IN THE JOB PACK AREA FOR A JOB STEP.
*              THE ORIGIN FOR A JPAQ IS A JOB STEP TCB.
*
*        6. SHARING OF LOAD MODULES IN ACCORDANCE WITH REUSABILITY
*           ATTRIBUTES IS ACCOMPLISHED IN THE FOLLOWING MANNER:
*
*              REENTERABLE FROM LINK PACK AREA - A SINGLE COPY OF
*                 A LOAD MODULE CAN BE USED BY ALL JOB STEPS IN
*                 THE SYSTEM.
*
*              REENTERABLE FROM THE JOB PACK AREA - A SINGLE COPY
*                 IN THE JOB PACK AREA MAY BE USED BY ALL STEPS
*                 WITHIN THE JOB STEP.
*
*              SERIAL REUSABLE FROM ANYWHERE - A SINGLE COPY WILL
*                 RESIDE IN THE JOB PACK AREA, AND MAY BE USED BY ALL
*                 TASKS OF THE JOBSTEP.  THE USE OF THE MODULE IS
*                 SERIALIZED BY QUEUING THE REQUESTS BY PRIORITY.
*
*              NOT REUSABLE FROM ANYWHERE - EVERY LINKAGE WILL FETCH
*                 A NEW COPY OF THE MODULE INTO THE JOB PACK AREA.
*
*        7. FOR TSO MODULES IN TEST, THE TTSAVE MODULE WILL BE
*              INVOKED VIA AN SVC CALL IN IEAVLK01.
*
*02*    RESTRICTIONS = NONE
*
*02*    REGISTER-CONVENTIONS = THE REGISTER CONVENTIONS USED BY
*       IEAVLK00 ARE DESCRIBED UNDER THE TOPIC REGISTER EQUATES.
*
*02*    PATCH-LABEL = THIS MODULE IS RESIDENT NUCLEUS, AND HAS NO PATCH
*       SPACE.
*
*01*  MODULE-TYPE = MODULE
*
*02*    PROCESSOR = ASSEMBLER
*
*02*    MODULE-SIZE = 3250 BYTES
*
*02*    ATTRIBUTES = REENTERABLE
*
*01*  ENTRY = IGC006
*
*02*    PURPOSE = LINK SVC ENTRY, FUNCTION AS IN NOTES ABOVE.
*
*02*    LINKAGE = SVC
*
*02*    INPUT = PSW ENABLED, SUPERVISOR STATE, PROTECT KEY OF ZERO
*       LOCKS HELD: LOCAL
*       REGISTERS ARE:
*              3  - CVT ADDRESS
*              4  - CURRENT TCB ADDRESS
*              5  - CURRENT RB ADDRESS
*              15  - ADDRESS OF PARAMETER LIST IN FOLLOWING FORMAT:
*                     AL1(FLAG)        FLAG IS X'80' FOR DE FORM,
*                                      IS X'00' FOR EP AND EPLOC.
*                     AL3(ADDR1)       ADDRESS OF ENTRY POINT NAME,
*                                      OR DE, FLAG DENOTES WHICH.
*                     AL1(FLAG)        FLAG IS X'80' IF PARAMETER
*                                      LIST IS EXTENDED TO A THIRD
*                                      WORD,  IS X'00' IF PARAMETER
*                                      LIST IS ONLY TWO WORDS.
*                     AL3(ADDR2)       ADDRESS OF DCB. IS ZERO IF
*                                      NO DCB WAS SPECIFIED.
*                                      FIRST BYTE IS IGNORED, NOW
*                                      UNSUPPORTED LCS OPTION BYTE.
*                     AL4(ADDR3)       ADDRESS OF ERRET ROUTINE.
*                   OTHER REGISTERS IRRELEVANT
*
*02*    OUTPUT = LINKAGE ASSISTED.
*        REGISTERS ARE:
*              14 - RETURN ADDRESS (POINTS TO AN SVC 3 )
*              15 - ENTRY POINT ADDRESS LINKED TO
*              0  - CHANGED
*                   OTHER REGISTERS ARE TRANSPARENT
*
*02*    EXIT-NORMAL = TO ROUTINE TO BE LINKED TO VIA EXIT PROLOGUE
*        OR - TO WAIT IF REQUEST WAS QUEUED
*        OR - TO MODULE IEAVLK01 TO PERFORM BLDL - FETCH INTERFACES
*             FOR A MODULE NOT FOUND DURING CDSEARCH OR NOT REUSABLE
*             WHEN TESTED IN CDALLOC.
*
*02*    EXIT-ERROR = TO ABEND WITH CODES AS FOLLOWS
*        106 - ISSUED BY IEAVLK01 FOR FETCH ERROR
*              REGISTER 15 HAS   E - AN INVALID ADDRESS WAS DETECTED
*                                F - I/O ERROR OCCURED
*        206 - PARAMETER LIST ERROR DETECTED BY IEAVLK00
*              REGISTER 15 HAS   1 - LIST ADDRESS ERROR
*                                2 - NAME/DE ADDRESS ERROR
*                                3 - DE SIZE EROOR
*        306 - AUTHORIZED ROUTINE ATTEMPTED TO USE A NON-AUTHORIZED
*              LIBRARY MODULE.
*        406 - ISSUED BY IEAVLK00 AND IEAVLK01 TO INDICATE THAT AN
*              ATTACH, XCTL,OR LINK WAS ISSUED TO A LOADABLE ONLY
*              MODULE.
*        706 - ISSUED BY IEAVLK01 TO INDICATE THAT A MODULE WAS
*              MARKED NOT EXECUTABLE BY THE LINKAGE EDITOR.
*        806 - MODULE NOT FOUND BY IEAVLK00 OR IEAVLK01
*              REGISTER 15 HAS   4 - MODULE NOT IN SPECIFIED PDS
*                                8 - I/O ERROR DURING BLDL
*                               12 - MODULE NOT IN LPA OR LPA
*                                        DIRECTORY
*                              16 - DCB FOR BLDL NOT OPEN     @ZA18512
*        906 - ISSUED BY IEAVLK00 TO INDICATE THAT A LLE COUNT
*              OR A CDE COUNT EXCEEDED X'7FFF'.
*        A06 - ISSUED BY IEAVLK00 TO INDICATE THAT AN INTERLOCK
*              WAS DETECTED IN THE USE OF A SERIALLY REUSABLE MODULE
*
*01*  ENTRY = IGC007
*
*02*    PURPOSE = XCTL SERVICE ROUTINE
*        1. PERFORM THE LINKAGE TO THE LOAD MODULE SPECIFIED. THE
*           MODULE GIVEN CONTROL EXECUTES AT THE SAME LEVEL OF
*           CONTROL AS THE MODULE ISSUING THE XCTL MACRO INSTRUCTION
*        2. THE ORDER OF SEARCH OF LISTS AND LIBRARIES IS THE SAME AS
*           FOR IGC006.
*        3. THE PRB AND CDENTRY ARE CREATED AND UPDATED AS FOR IGC006.
*        4. FETCHING AND PACKING IS DONE AS FOR LINK.
*        5. CHANGE THE RB ADDRESS IN THE STAE CONTROL BLOCK
*           IS DONE BY THE TASK RECOVERY RESOURCE MANAGER (TRRM).
*        6. FOR TYPE 4 SVC'S THE CURRENT SVRB WILL BE RECLAIMED DURING
*           PROCESSING.
*
*02*    LINKAGE = SVC
*
*02*    INPUT = PSW ENABLED, SUPERVISOR STATE, PROTECT KEY OF ZERO
*       LOCKS HELD: LOCAL
*        REGISTERS ARE:
*              3  - CVT ADDRESS
*              4  - CURRENT TCB ADDRESS
*              5  - CURRENT RB ADDRESS
*             15  - ADDRESS OF PARAMETER LIST IN FOLLOWING FORMAT:
*                     AL1(FLAG)        FLAG IS X'80' FOR DE FORM,
*                                      IS X'00' FOR EP AND EPLOC.
*                     AL3(ADDR1)       ADDRESS OF ENTRY POINT NAME,
*                                      OR DE, FLAG DENOTES WHICH.
*                     AL4(ADDR2)       ADDRESS OF DCB. IS ZERO IF
*                                      NO DCB WAS SPECIFIED.
*                                      FIRST BYTE IS IGNORED, NOW
*                                      UNSUPPORTED LCS OPTION BYTE.
*                   OTHER REGISTERS IRRELEVANT
*
*02*    OUTPUT = SAME AS IGC006
*
*02*    EXIT-NORMAL = SAME AS IGC006
*
*02*    EXIT-ERROR = SAME AS IGC006
*
*01*  ENTRY = IGC008
*
*02*    PURPOSE = SVC LOAD ENTRY POINT
*        1. ACQUIRE A SPECIFIED LOAD MODULE AND RETAIN THE MODULE FOR
*           USE BY THE TASK ISSUING THE LOAD.
*        2. SEARCHES AS IN IGC006.
*        3. DURING THE TIME THAT A MODULE IS RETAINED BY THE REQUESTING
*           TASK, THE TASK IS SAID TO BE RESPONSIBLE FOR THE MODULE.
*           A TWELVE BYTE LOAD LIST ELEMENT IS CREATED FOR EACH MODULE
*           RETAINED BY A TASK. THIS LOAD LIST ELEMENT WILL POINT TO
*           THE CDE DESCRIBING THE MODULE.
*        4. A MODULE THAT IS LOADED WILL CAUSE THE USE COUNT IN THE
*           CDE TO BE INCREMENTED. THE COUNT IN THE CDE IS THE TOTAL
*           USE FOR THE MODULE, IN ALL TASKS OF ALL JOBSTEPS.
*        5. A RESPONSIBILITY COUNT IS ALSO KEPT IN THE LLE, WHICH IS
*           INCREMENTED BY LOAD, AND DECREMENTED BY DELETE.  WHEN
*           A MODULE HAS A USE COUNT OF ZERO IN THE LLE, THE LLE IS
*           FREED.  WHEN THE CDE COUNT GOES TO ZERO, THE CDE AND ALL
*           STORAGE ALLOCATED TO THE MODULE IS FREED.
*        6. A SYSTEM RESPONSIBILITY COUNT IS ALSO MAINTAINED IN THE
*           LEE AND IS INCREMENTED ON SYSTEM LOADS AND DECREMENTED ON
*           SYSTEM DELETION.  THE RESPONSIBILITY COUNT MUST ALWAYS BE
*           GREATER THAN OR EQUAL TO THE SYSTEM USE COUNT.
*        7. A LOAD REQUEST IN DISTINCTION TO A LINK REQUEST IS NOT
*           QUEUED FOR A SERIALLY REUSABLE MODULE.  THE ENTRY POINT
*           IS RETURNED EVEN IF THE MODULE IS IN USE.
*        8. FETCHING IS HANDLED AS FOR IGC006.
*
*02*    LINKAGE = SVC
*
*02*    INPUT = PSW AS FOR IGC006
*        REGISTERS ARE AS FOLLOWS:
*              0  - ADDRESS OF ENTRY POINT NAME OR
*                   ADDRESS OF DE IN COMPLEMENTED FORM.
*              1  - DCB ADDRESS OR ZERO.
*                   THE HIGH ORDER BIT IS A FLAG WITH THE FOLLOWING
*                   MEANING:
*                   X'80' - RETURN REQUESTED ON ERROR CONDITION
*                   X'00' - ABEND ON ERROR CONDITION
*              3  - ADDRESS OF CVT
*              4  - ADDRESS OF CURRENT TCB
*              5  - ADDRESS OF CURRENT RB
*                   OTHER REGISTERS IRRELEVANT
*
*02*    OUTPUT = REGISTERS ARE AS FOLLOWS:
*              0  - ADDRESS OF LOAD MODULE REQUESTED.
*              1  - HIGH ORDER BYTE CONTAINS AUTHORIZATION CODE
*                   LOW ORDER 3 BYTES CONTAIN SIZE OF MODULE IN
*                   DOUBLE WORDS.
*
*02*    EXIT-NORMAL = RETURN TO CALLER VIA EXIT PROLOGUE
*
*02*    EXIT-ERROR = SAME AS FOR IGC006
*
*01*  ENTRY = IGC009
*
*02*    PURPOSE = SVC DELETE ENTRY POINT
*        2. LOCATE THE NAMED MODULE. IF IT IS FOUND ON THE LOAD LIST
*           DECREMENT THE LOAD COUNT BY 1.  AND, IF SYSTEM REQUEST
*           DECREMENT THE SYSTEM RESPONSIBILITY COUNT BY 1.
*           IF THE COUNT REACHES ZERO FREE THE LLE.  IF THE MODULE
*           IS NOT FOUND RETURN TO THE CALLER WITH A CODE OF 4 IN
*           REGISTER 15.
*        3. DECREMENT THE USE COUNT IN THE CDE IF THE MODULE WAS
*           FOUND.  IF THE COUNT GOES TO
*           ZERO, FORCE THE PURGING OF THE MODULE VIA CDE HOUSEKEEPING
*           ROUTINE.
*
*02*    LINKAGE = SVC
*
*02*    INPUT = PSW AS FOR IGC006
*        REGISTERS ARE AS FOLLOWS:
*              0  - ADDRESS OF ENTRY POINT NAME OR
*                   ADDRESS OF DE IN COMPLEMENTED FORM.
*              1  - DCB ADDRESS OR ZERO.
*              3  - ADDRESS OF CVT
*              4  - ADDRESS OF CURRENT TCB
*              5  - ADDRESS OF CURRENT RB
*                   OTHER REGISTERS IRRELEVANT
*
*02*    OUTPUT = REGISTERS ARE SET AS FOLLOWS:
*              15 - SET TO 0 IF MODULE FOUND
*                   SET TO 4 IF MODULE NOT FOUND
*                   OTHER REGISTERS PRESERVED
*
*02*    EXIT-NORMAL = TO USER WITH EXIT CODES AS ABOVE
*
*02*    EXIT-ERROR = NONE
*
*01*  ENTRY = IGC012
*
*02*    PURPOSE = SVC SYNCH ENTRY POINT
*        1. PROVIDE A SUPERVISOR ROUTINE THE ABILITY TO TAKE A
*           SYNCHRONOUS EXIT TO A USER SUBROUTINE.
*        2. AVOID USING LINK TO ELIMINATE CDES.
*        3. ALLOW THE SUPERVISOR ROUTINE THE ABILITY TO REGAIN
*           CONTROL IN SUPERVISOR MODE, AFTER THE EXIT ROUTINE
*           COMPLETES IN PROBLEM PROGRAM MODE.
*        4. ALLOW STAE THE ABILITY TO SCHEDULE A SYNCHRONOUS EXIT
*           ROUTINE IN PRIVILEDGED MODE.
*
*02*    LINKAGE = SVC
*
*02*    INPUT = REGISTERS ARE AS FOLLOWS:
*              15 - ENTRY POINT TO GET CONTROL
*              3  - ADDRESS OF CVT
*              4  - ADDRESS OF TCB
*              5  - ADDRESS OF RB
*                   OTHER REGISTERS IRRELEVANT
*
*02*    OUTPUT = REGISTERS AS FOLLOWS :
*              14 - ADDRESS OF AN SVC EXIT
*              15 - UNCHANGED (ENTRY POINT)
*                   OTHER REGISTERS UNCHANGED
*
*02*    EXIT-NORMAL = TO ENTRY POINT PASSED IN REGISTER 15 VIA SVC EXIT
*
*02*    EXIT-ERROR = NONE
*
*01*  ENTRY = IEAQCS01
*
*02*    PURPOSE = LINK SERVICE FOR ATTACH
*
*02*    LINKAGE = BRANCH
*
*02*    INPUT =
*
*        PSW = ENABLED, KEY 0, SUPERVISOR STATE
*        LOCKS HELD = NONE
*        GR0 - ADDRESS OF REQUESTED MODULE NAME OR PDS DE
*              (COMPLEMENTED)
*        GR1 - ADDRESS OF DCB
*        GR3 - ADDRESS OF CVT
*        GR4 - ADDRESS OF TCB
*        GR5 - ADDRESS OF SVRB
*        GR2,6-15 ARE IRRELEVANT
*        THE MODULE NAME ON EP OR EPLOC OPERANDS WILL BE THE FIRST
*        WORD OF THE RBXSA (RB EXTENDED SAVE AREA).  ON DE OPERANDS,
*        ATTACH WILL GETMAIN A SAVE AREA FROM SUBPOOL 255 FOR THE
*        LENGTH OF THE BLDL ENTRY PLUS 4.  THE SIZE OF THE BLDL ENTRY
*        IS PLACED IN THE FIRST WORD AND THE BLDL ENTRY FOLLOWS.
*        REGISTER 0 POINTS TO EITHER THE GOTTEN DE SAVE AREA OF THE
*        RBXSA.  SEE INPUTS.
*        THE NINTH (9TH) BYTE OF THE RBXSA WILL CONTAIN A CODE AS
*        FOLLOWS:
*              X'80' - THE CALLER OF ATTACH IS AN AUTHORIZED ROUTINE.
*              X'00' - THE CALLER OF ATTACH IS AN UNAUTHORIZED ROUTINE.
*        THE REGISTERS TO BE PASSED TO THE ATTACHEE ARE STORED IN THE
*        SVRB REGISTER SAVE AREA.  R13 WILL BE SET BY ATTACH TO A USER
*        REGISTER SAVE AREA.  R14 AND R15 ARE IRRELEVENT SINCE THEY
*        WILL BE SET BY PROGRAM MANAGER.
*02*    OUTPUT = SAME AS IGC006
*
*02*    EXIT-NORMAL = SAME AS IGC006
*
*02*    EXIT-ERROR = SAME AS IGC006
*
*01*  ENTRY = IEAQCS02
*
*02*    PURPOSE = RESTART A QUEUED REQUEST THROUGH MAINLINE LINK
*
*02*    LINKAGE = BRANCH
*
*02*    INPUT = REGISTERS AND FIELDS AS FOLLOWS
*              3  - CVT ADDRESS
*              4  - TCB ADDRESS
*              5  - RB ADDRESS
*              6  - BASE ADDRESS
*              8  - CDE QUEUE TO SEARCH
*              9  - ADDRESS OF NAME REQUESTED
*              10 - ADDRESS OF DCB OR ZERO
*                   OTHER REGISTERS NOT USED
*                   SVRB EXTENDED SAVE AREA FULLY INITIALIZED
*
*02*    OUTPUT = SAME AS IGC006
*
*02*    EXIT-NORMAL = SAME AS IGC006
*
*02*    EXIT-ERROR = SAME AS IGC006
*
*01*  ENTRY = IEAQCS03
*
*02*    PURPOSE = RESTART A QUEUED SERIAL REUSABLE REQUEST
*
*02*    LINKAGE = BRANCH
*
*02*    INPUT = SAME AS IEAQCS02, AND ALSO:
*              11 - ADDRESS OF REQUESTED CDE
*              12 - ADDRESS OF MAJOR CDE
*                   NOTE - REGS 11 AND 12 ARE EQUAL IF THE REQUEST WAS
*                          FOR A MAJOR NAME
*
*02*    OUTPUT = SAME AS IGC006
*
*02*    EXIT-NORMAL = SAME AS IGC006
*
*02*    EXIT-ERROR = SAME AS IGC006
*
*01*  ENTRY = IEAVVMSR
*
*02*    PURPOSE = TO SEARCH THE PAGEABLE LPA DIRECTORY FOR AN LPDE
*       REPRESENTING THE REQUESTED MODULE
*
*02*    LINKAGE = BALR
*
*02*    INPUT = REGISTERS AS FOLLOWS
*              0  - LEFT HALF OF NAME
*              1  - RIGHT HALF OF NAME
*              3  - CVT ADDRESS
*              14 - RETURN ADDRESS
*
*02*    OUTPUT = REGISTERS AS FOLLOWS
*              0  - LPDE ADDRESS IF FOUND
*              6  - ALTERED
*              8  - ALTERED
*              9  - ALTERED
*                   OTHER REGISTERS NOT USED
*
*02*    EXIT-NORMAL = RETURN IS ON REGISTER 14 + 0 IF LPDE WAS FOUND.
*       RETURN IS ON REGISTER 14 + 4 IF LPDE WAS NOT FOUND.
*
*02*    EXIT-ERROR = NONE
*
*01*  ENTRY = IEAQCDSR
*
*02*    PURPOSE = TO SEARCH A CDE QUEUE FOR A REQUESTED NAME
*
*02*    LINKAGE = BALR
*
*02*    INPUT = REGISTERS AS FOLLOWS
*              8  - ADDRESS OF POINTER TO FIRST CDE ON THE QUEUE
*              9  - ADDRESS OF NAME
*              14 - RETURN ADDRESS
*
*02*    OUTPUT = REGISTERS AS FOLLOWS
*              0  - LEFT HALF OF NAME
*              1  - RIGHT HALF OF NAME
*              11 - CDE ADDRESS OR ZERO
*              15 - ALTERED
*                   OTHER REGISTERS NOT REFERENCED
*
*02*    EXIT-NORMAL = RETURN IS ON REGISTER 14 + 0 IF CDE WAS FOUND.
*       RETURN IS ON REGISTER 14 + 4 IF CDE WAS NOT FOUND.
*
*02*    EXIT-ERROR = NONE
*
*01*  ENTRY = IEAQCS04
*
*02*    PURPOSE = ENTRY ADDRESS WHICH IS THE START OF THE LIST OF
*       ADDRESSES WHICH IEAVLK01 USES TO RETURN TO IEAVLK00.
*
*02*    LINKAGE = NONE - THIS IS AN EXTERNAL REFERENCE WHICH IS NOT
*       EXECUTABLE
*
*02*    INPUT = NONE
*
*02*    OUTPUT = NONE
*
*02*    EXIT-NORMAL = NONE
*
*02*    EXIT-ERROR = NONE
*
*01*  ENTRY = CDLKBASE
*
*02*    PURPOSE = ADDRESS WHICH IS USED TO RESET THE BASE ADDRESS FOR
*       IEAVLK00 ON RETURN FROM IEAVLK01
*
*02*    LINKAGE = NONE. THIS IS A NON-EXECUTABLE ENTRY
*
*02*    INPUT = NONE
*
*02*    OUTPUT = NONE
*
*02*    EXIT-NORMAL = NONE
*
*02*    EXIT-ERROR = NONE
*
*01*  ENTRY = CDCONTRL
*
*02*    PURPOSE = TO SEARCH THE LPAQ
*
*02*    LINKAGE = BRANCH
*
*02*    INPUT = REGISTERS AS FOLLOWS
*              3  - CVT ADDRESS
*              4  - TCB ADDRESS
*              5  - RB ADDRESS
*              6  - BASE ADDRESS
*              8  - QUEUE ORIGIN TO SEARCH
*              9  - ADDRESS OF NAME
*              10 - DCB ADDRESS
*                   OTHER REGISTERS NOT REFERENCED
*                   SVRB EXTENDED SAVE AREA FULLY INITIALIZED
*
*02*    OUTPUT = SAME AS IGC006
*
*02*    EXIT-NORMAL = SAME AS IGC006
*
*02*    EXIT-ERROR = SAME AS IGC006
*
*01*  ENTRY = CDEMERGE
*
*02*    PURPOSE = TO CLEAN UP BEFORE EXITING FROM IEAVLK00
*
*02*    LINKAGE = BRANCH
*
*02*    INPUT = REGISTERS AS FOLLOWS
*              3  - CVT ADDRESS
*              4  - TCB ADDRESS
*              5  - RB ADDRESS
*              6  - BASE ADDRESS
*              11 - REQUESTED CDE
*              12 - MAJOR CDE
*                   OTHER REGISTERS NOT REFERENCED
*                   SVRB EXSAVE FULLY INITIALIZED
*
*02*    OUTPUT = SAME AS IGC006
*
*02*    EXIT-NORMAL = SAME AS IGC006
*
*02*    EXIT-ERROR = SAME AS IGC006
*
*01*  ENTRY = CDQUECTL
*
*02*    PURPOSE = QUEUE AN ALIAS PDS REQUEST FOR IEAVLK01
*
*02*    LINKAGE = BRANCH
*
*02*    INPUT = REGISTERS AS FOLLOWS
*              3  - ADDRESS OF CVT
*              4  - TCB ADDRESS
*              5  - RB ADDRESS
*              6  - BASE ADDRESS
*              9  - ADDRESS OF REQUESTED NAME
*              10 - DCB ADDRESS
*              11 - REQUESTED CDE
*              12 - MAJOR CDE
*                   OTHER REGISTERS NOT REFERENCED
*                   SVRB EXSAVE FULLY INITIALIZED
*
*02*    OUTPUT = SAME AS IGC006
*
*02*    EXIT-NORMAL = SAME AS IGC006
*
*02*    EXIT-ERROR = SAME AS IGC006
*
*01*  ENTRY = PLUSCONT
*
*02*    PURPOSE = TO CHECK THE USABILITY OF A FOUND MAJOR FROM IEAVLK01
*
*02*    LINKAGE = BRANCH
*
*02*    INPUT = REGISTERS AS FOLLOWS
*              0  - LEFT HALF OF NAME
*              1  - RIGHT HALF OF NAME
*              3  - CVT ADDRESS
*              4  - TCB ADDRESS
*              5  - RB ADDRESS
*              6  - BASE ADDRESS
*              8  - ADDRESS OF LAST CDE QUEUE SEARCHED
*              9  - ADDRESS OF REQUESTED NAME
*              10 - DCB ADDRESS
*              11 - ADDRESS OF REQUESTED CDE
*              12 - ADDRESS OF MAJOR CDE
*                   OTHER REGISTERS NOT REFERENCED
*                   SVRB EXSAVE FULLY INITIALIZED
*
*02*    OUTPUT = SAME AS IGC006
*
*02*    EXIT-NORMAL = SAME AS IGC006
*
*02*    EXIT-ERROR = SAME AS IGC006
*
*01*  ENTRY = ABNDSET
*
*02*    PURPOSE = TO COMPLETE PROCESSING FOR 106,306,406,706,AND 806
*       ABENDS
*       ISSUED FOR IEAVLK01
*
*02*    LINKAGE = BRANCH
*
*02*    INPUT = REGISTERS AS FOLLOWS
*              6  - BASE ADDRESS
*              13 - ABEND CODE OF (1,3,4,7, OR 8)
*              15 - REASON CODE IF 106  806 ABEND 106,306, OR 806
*                   SVRB EXSAVE FULLY INITIALIZED
*
*02*    OUTPUT = REGISTERS AS FOLLOWS
*              0  - TCB ADDRESS
*              1  - ABEND CODE
*
*02*    EXIT-NORMAL = TO ABEND VIA SVC 13
*
*02*    EXIT-ERROR = NONE
*
*01*  EXTERNAL-REFERENCES = THE FOLLOWING EXTERNAL REFERENCES ARE MADE:
*
*02*    ROUTINES = CDHKEEP,IEAVLK01,WAIT W/O ECB,VALIDITY CHECK
*
*02*    DATA-SETS = NONE
*
*02*    DATA-AREA = IEATCBP,IEAQLCT,IEAVVMDI,BLDL/FETCH WORK AREA,DE
*       SAVE AREA, ABEND MESSAGE BUFFER
*
*01*  TABLES = NONE
*
*01*  MACROS = ABEND,FREEMAIN,GETMAIN,IEZBITS,MODID,
*     IHAMB,IHACDE,IHALPDE,IHALLE,IHARB,IHAPDS
*     IEFTIOT1,IKJTCB,IEZJSCB,CVT,IHAFRRS,SETLOCK,SETFRR,IHAPSA,
*     IHAASCB,IHAASXB,IHAFETWK,TESTAUTH,WTO,MODESET
*
**** END OF SPECIFICATIONS ***/
         TITLE  '            IEAVLK00    EXTERNAL REFERENCES'
         SPACE 2
*/*IEAVLK00: CHART PROGRAM MANAGER SERVICE ROUTINES */
*/* HEADER
*/*
*/*
*/*
*/*                                                   SECTION 3.1.11
*/*PROGRAM MANAGER SERVICE ROUTINES
*/*                                                   PAGE # */
         SPACE 2
IEAVLK00 CSECT                         CSECT NAME  **** SINGLE CSECT
         MODID BR=NO
         ENTRY IGC006                  SVC LINK ENTRY POINT
         ENTRY IGC007                  SVC XCTL ENTRY POINT
         ENTRY IGC008                  SVC LOAD ENTRY POINT
         ENTRY IGC009                  SVC DELETE ENTRY POINT
         ENTRY IGC012                  SVC SYNCH ENTRY POINT
         ENTRY CDEPILOG                SVC EXIT BRANCHES HERE TO
*                                      RESTART A QUEUED REQUEST FOR
*                                      A SERIALLY REUSABLE MODULE
         ENTRY IEAQCDSR                ENTRY TO CDE SEARCH ROUTINE
         ENTRY IEAQCS01                ATTACH  ROUTINE  ENTRY TO LINK
         ENTRY IEAQCS02                CDCONTRL ENTRY POINT
         ENTRY IEAQCS03                CDEPILOG ENTRY POINT
         ENTRY IEAVVMSR                LPDE SEARCH ROUTINE
         ENTRY IEAQCS04                POINTS TO ADDRESS LIST FOR VLK01
         ENTRY SYNCR                   ADDR OF FRR ROUTINE RETRY M01978
         EXTRN IEAQLPAQ                ADDRESS OF LINK PACK AREA QUEUE
*                                      HEAD POINTER.
         EXTRN CDHKEEP                 ROUTINE TO FREE CDES
         EXTRN IEAVLK01                BLDL FETCH INTERFACE MODULE
         EXTRN FRRPGMMG                RECOVERY ROUTINE FOR PGM.MGR.
         TITLE 'IEAVLK00 REGISTER EQUATES'
*                                      EQUATES FOR REGISTER 0
R0       EQU   0                       LM/STM AND INTERFACES
NAMELEFT EQU   R0                      LEFT HALF OF NAME FOR SEARCHES
LPDEADDR EQU   R0                      LPDE ADDR RETURNED BY IEAVVMSR
WKREG0   EQU   R0                      GENERAL WORK REGISTER
*                                      EQUATES FOR REGISTER 1
R1       EQU   1                       LM/STM AND INTERFACES
NAMERGT  EQU   R1                      RIGHT HALF OF NAME FOR SEARCHES
WKREG1   EQU   R1                      GENERAL WORK REGISTER
*                                      EQUATES FOR REGISTER 2
R2       EQU   2                       CROSS REFERENCE EQUATE
WKREG2   EQU   R2                      GENERAL WORK REGISTER
OLDRB    EQU   R2                      POINTER TO THE OLD PRB FOR XCTL
*                                      EQUATES FOR REGISTER 3
R3       EQU   3                       CROSS REFERENCE EQUATE
COMREG   EQU   R3                      LOAD FINAL PROCESSING REG
CVTREG   EQU   R3                      REGISTER 3 POINTS TO CVT
*                                      EQUATES FOR REGISTER 4
R4       EQU   4                       CROSS REFERENCE EQUATE
TCBREG   EQU   R4                      REGISTER 4 POINTS TO TCB
*                                      EQUATES FOR REGISTER 5
R5       EQU   5                       CROSS REFERENCE EQUATE
RBREG    EQU   R5                      REGISTER 5 POINTS TO THE RB
*                                      REGISTER 6 EQUATES
R6       EQU   6                       CROSS REFERENCE EQUATE
BASEREG  EQU   R6                      BASE REGISTER FOR IEAVLK00
*                                      REGISTER 7 EQUATES
R7       EQU   7                       PARAMETER TO IEA0VL02
AREAREG  EQU   R7                      POINTS TO BLDL FETCH WORK AREA
DESVREG  EQU   R7                      POINTS TO DE SAVE AREA
ASCBREG  EQU   7                       POINTS TO THE CURRENT ASCB
*                                      DURING PREFIXING ROUTINES
*                                      REGISTER 8 EQUATES
R8       EQU   8                       IEA0VL02 BASE REGISTER
LPDEREG  EQU   R8                      MUST BE EVEN FOR DIVIDE
HASHREG  EQU   LPDEREG+1               USED TO HASH LPDE ADDRESS
*                                      IN IEAVVMSR
DESZREG  EQU   R8                      CONTAINS DE SIZE WHILE PREFIXING
TAXRB    EQU   R8                      POINTS TO RB THAT WAS GOTTEN
TABREG   EQU   R8                      POINTS TO QUE THAT WAS SEARCHED
PRBREG   EQU   R8                      POINTS TO GOTTEN RB
NEWRB    EQU   R8                      NEW RB FOR XCTL
*                                      REGISTER 9 EQUATES
R9       EQU   9                       RETURN REGISTER FOR IEA0VL02
NAMEREG  EQU   R9                      POINTS TO NAME OR DE
*                                      REGISTER 10 EQUATES
R10      EQU   10                      RETURN CODE FOR IEA0VL02
PIEREG   EQU   R10                     POINTS TO PIE
DCBREG   EQU   R10                     POINT TO DCB DURING SEARCHES
REASON   EQU   R10                     CONTAINS REASON CODE IN ABEND
*                                      REGISTER 11 EQUATES
R11      EQU   11                      INPUT ADDRESS FOR LXREFER
TIOTPTR  EQU   R11                     DURING ABEND POINTS TO TIOT
CDEREG   EQU   R11                     POINTS TO CDE FOR REQUEST
*                                      REGISTER 12 EQUATES
R12      EQU   12                      CROSS REFERENCE EQUATE
R12PARM  EQU   R12                     PARAMETER LIST ADDR IN PREFIX
CDIREG   EQU   R12                     POINTS TO MAJOR CDE FOR REQUEST
*                                      REGISTER 13 EQUATES
R13      EQU   13                      GENERAL WORK REGISTER
ABCODE   EQU   R13                     CONTAINS ABEND CODE
RETURND  EQU   R13                     RETURN REGISTER INTERNAL SUBRTNS
LDLREG   EQU   R13                     POINTS TO LLE DURING LOAD
RJJRET   EQU   R13                     CDHKEEP RETURN REGISTER
PICAREG  EQU   R13                     POINTS TO PICA
*                                      REGISTER 14 EQUATES
R14      EQU   14                      GENERAL WORK REGISTER
RETURN   EQU   R14                     RETURN REGISTER INTERNAL SUBRTNS
GR14     EQU   R14                     GENERAL WORK REGISTER
SUBREG1  EQU   R14                     GENERAL WORK REGISTER
*                                      REGISTER 15 EQUATES
R15      EQU   15                      GENERAL WORK REGISTER
GR15     EQU   R15                     GENERAL WORK REGISTER
SUBREG2  EQU   R15                     GENERAL WORK REGISTER
         TITLE 'IEAVLK00 CHARACTER AND HEX MASK EQUATES'
REF      EQU   X'01'                   SET RB WAIT COUNT TO 1 IN
*                                      CDQUECTL
*
* THE FOLLOWING TWO EQUATES ARE EBCDIC CHARACTER CODE DEPENDENT
*
BLANK    EQU   C' '                    CHARACTER BLANK FOR MESSAGES
CHARZERO EQU   C'0'                    CHARACTER ZERO TESTED DURING WTP
*                                      PROCESSING
MASK1    EQU   X'01'                   COMPARE ONE BYTE IN REG
BYTE2    EQU   X'02'                   INSERTS IN SECOND BYTE OF A REG
MASKOFF  EQU   X'04'                   DAT ACTIVE NOT IO OR EXT
MASK     EQU   X'07'                   ICM/STCM 3 ADDR BYTES IN REG
MASK4    EQU   X'0F'                   ICM/STCM 4 BYTE ADDR IN REG
X0F      EQU   X'0F'                   MAX. VALUE CONTAINED IN 4 BITS
X1F      EQU   X'1F'                   MAX.VALUE CONTAINED IN 5 BITS
XFE      EQU   X'FE'                   PRIVILEGED MODE OPERATION
MAX      EQU   X'FF'                   MAX. VALUE CONTAINED IN 1 BYTE
REF1BYTE EQU   X'11'                   PUT 1 BYTE INTO REG1
REF9BTE4 EQU   X'9F'                   PUT 4 BYTES INTO REGISTER 9
*                                      WITH EXECUTED ICM MASK
REFABTE4 EQU   X'AF'                   PUT 4 BYTES INTO REGISTER 10
*                                      WITH EXECUTED ICM MASK
MASK8    EQU   X'08'                   BYTE 0 OF REG IN ICM
AUTHBYTE EQU   X'08'                   APF FLAG IN BYTE 0 OF REG 1
CANTFIX  EQU   X'24'                   MODULE PERMANENTLY NON-FIXABLE
*                                      RETURN FROM PAGE FIX SVC
X40      EQU   X'40'                    ATTACH WITH RESET APF   @WAB
X80      EQU   X'80'                   ATTACH AUTHORIZATION BIT
         TITLE 'IEAVLK00 GENERAL NUMBER VALUE EQUATES'
ZERO     EQU   0
SYMBEGIN EQU   0                       SYMB DISPL TO BEG OF FIELD
N0       EQU   0                       USED FOR ZERO OFFSETS
NEW      EQU   0                       NEW TCB SLOT POINTER
N1       EQU   1                       USED TO INCREMENT VALUES
PRIO     EQU   1                       LENGTH OF DISP PRIORITY STORED
ADD1     EQU   1                       USED TO INCREMENT THE USE COUNT
ONE      EQU   1                       REASON CODE VALUE
TWO      EQU   2                       REASON CODE VALUE
N2       EQU   2                       USED TO INCREMENT ERROR VALUES
N3       EQU   3                       USED TO INCREMENT ERROR VALUES
ADDL     EQU   3                       MAXIMUM LENTGH OF AOS ADDRESSES
EXIT     EQU   3                       USED TO RETURN TO CALLING RTN.
THREE    EQU   3                       REASON CODE AND MVC CONSTANT
*                                      FOR 206 ABEND PROCESSING
OLD      EQU   4                       OLD TCB SLOT POINTER
N4       EQU   4                       USED TO INCREMENT VALUES
WORD     EQU   4                       USED TO INCREMENT VALUES
STILLDIS EQU   4                       RETURN IF LXREFER DIDNT ENABLE
FOUR     EQU   4                       RETURN CODE OR OFFSET TO DCB
*                                      ADDRESS IN PARAMETER LIST
NAMERT   EQU   4                       RIGHT HALF OF NAME EQUATE
NOGOOD   EQU   4                       RETURN ON R+4 IF A SEARCH FAILS
PSWBASE  EQU   4                       PSW LENGTH LESS ADDR. FIELD
FIVE     EQU   5                       UNPACK SIZE FOR 206 ABENDS
NOTEQ    EQU   7                       NOT EQUAL COMPARES
N7       EQU   7                       LENGTH OF NAME-1
NAME     EQU   8                       LENGTH OF AOS NAMES
NAMELTH  EQU   NAME-1                  PREFIX NAME LENGTH VALUE
N8       EQU   8                       USED AS NUMBER VALUE
EQZER    EQU   8                       USED TO TEST CONDITION CODES
EIGHT    EQU   8                       TRANSLATE SIZE FOR 206 ABENDS
XLENGTH  EQU   8                       OFFSET TO LENGTH FIELD IN XLIST
UNPKSIZE EQU   9                       UNPACK SIZE FOR 206 ABENDS
BADRETCD EQU   12                      USED TO ISSUE RETURN CODE OF 12
XSTART   EQU   12                      OFFSET TO ADDR FIELD IN XLIST
PRBCLR   EQU   12                      USED TO CLEAR IRB/XCTL RBS P2020
N20      EQU   20                      USED TO POSITION ABEND CODE
         TITLE '           IEAVLK00  LINK - SVC 6'
         USING PSA,0                   ADDRESSIBILITY TO PSA
         USING CVT,CVTREG              REG.3 CONTAINS CVT ADDRESS
         USING TCB,TCBREG              REG.4  CONTAINS  TCB ADDRESS
         USING RBSECT,RBREG            REG.5  CONTAINS  RB  ADDRESS
         USING WKAREA,AREAREG          REG.6  CONTAINS  WORK AREA ADDR
         USING CDLKBASE,BASEREG        REG.7  CONTAINS  BASE ADDRESS
         USING PRB,PRBREG              REG 8  CONTAINS  PRB ADDRESS
         USING CDENTRY,CDEREG          REG.11 CONTAINS  CDENTRY ADDRESS
         USING CDENTRYJ,CDIREG         REG.12 CONTAINS  CDENTRY ADDRESS
         SPACE 2
*/*IGCOO6: E ENTRY LINK */
         SPACE 2
IGC006   DS    0H                      ENTRY POINT TO LINK FROM
*                                      SVC SLIH
         SPACE 2
*/* P ESTABLISH ADDRESSABILITY */
         SPACE 2
         BALR  BASEREG,ZERO            SET UP BASE ADDRESS
         SPACE 2
*/*CDLKBASE: L SETFRR-- SET UP RECOVERY */
         SPACE 2
CDLKBASE DS    0H                      LINK BASE
         SETFRR A,PARMAD=(R8),WRKREGS=(R11,R12),FRRAD=FRRPGM
         ST    R8,RBCSFRRA             SAVE PARM LIST ADDRESS
         ST    RBREG,N0(R8)            PUT SVRB IN PARM LIST
         SPACE 2
*/* P INDICATE PROG MGR SVRB FOR RTM */
         SPACE 2
         OI    RBSTAB1,RBPMSVRB        THIS IS PROG MGR SVRB.  @YA00094
*                                      USED BY RTM TO INVOKE THE
*                                      ABEND RESOURCE MGR DURING
*                                      RECOVERY RETRY.
         SPACE 2
*/* S LXPREFIX:SET UP REG 9, REG 10 AND EXSAVE */
         SPACE 2
         BAL   RETURND,LXPREFIX        INITIALIZE R9,R10, AND EXSAVE
         SPACE 2
*/*CDADVANS: P PREPARE POINTERS TO SEARCH JOB PACK QUEUE */
         SPACE 2
CDADVANS L     TABREG,TCBJSTCB         LOAD ADDR. OF INITIATED TCB
         LA    TABREG,TCBJSEZ(TABREG)  ESTABLISH ADDR. OF JPAQ
         SPACE 1
*BRANCH TABLE SET UP TO CHECK IF THE NAME REQUESTED IS IN THE LIST
*ADDRESSED BY TABREG, AND IF SO WHAT ARE ITS USABILITY CONDITIONS
         SPACE 2
*/*CDCONTRL: S (0,PLUSCONT,+4,CDSETUP1) CDSEARCH:CAUSE SEARCH OF A CDE
*/*QUEUE */
         SPACE 2
CDCONTRL EQU   *                       SEARCH JPAQ,LPAQ, OR TSOLPAQ
         BAL   SUBREG1,CDSEARCH        SEARCH CDES FOR EIGHT
*                                      BYTE NAME ADDRESSED BY NAMEREG
         SPACE 1
*        CDSEARCH WILL ASSUME A BRANCH TABLE AS FOLLOWS
*              B    ADDR1  - 8 BYTE NAME FOUND
*              B    ADDR2  - 8 BYTE NAME NOT FOUND
*        THE BRANCH TABLE OVERLAPS WITH THAT REQUIRED BY CDALLOC
         SPACE 2
*/*PLUSCONT: S (0,CDSETUP1,4,CDEMERGE,8,CONTSRCH,12,%CDMPUP,16,
*/*CDQUECTL) CDALLOC:TEST AVAILABILITY OF MODULE FOUND */
         SPACE 2
PLUSCONT BAL   SUBREG2,CDALLOC         GO TO CDALLOC .NAME FOUND
         SPACE 1
*        CDALLOC ASSUMES BRANCH TABLE ,  SEE FORMAT IN DSECT CDALLOC
         B     CDSETUP1                NOT FOUND - ISSUE BLDL
         B     CDEMERGE                ALLOCATE  SUCCESSFUL
         B     CONTSRCH                NOT REUSABLE - FIND ANOTHER COPY
         SPACE 2
*/*%CDMPUP: S CDMOPUP:CLEAR WORK AREAS */
         SPACE 2
         BAL   RETURND,CDMOPUP         QUEUE REQUEST - CLEAN WORK AREA
*                                      AFTER CDMOPUP DROP THROUGH TO
*                                      CDQUECTL
         SPACE 1
*        FIFTH RETURN FROM CDALLOC IS FOR MODULE BEING FETCHED, QUEUE
*        THE REQUEST.  CDMOPUP IS NOT USED BECAUSE THE ATTRIBUTES OF
*        THE MODULE BEING FETCHED HAVE NOT BEEN TESTED, AND IF IT CAN
*        NOT BE REUSED, ANOTHER FETCH WILL BE DONE. THEREFORE THE WORK
*        AREAS ARE RETAINED UNTIL AFTER THE FETCH, WHEN THE ATTRIBUTES
*        ARE TESTED.
         EJECT
*        THE REQUEST IS QUEUED USING THE LAST 4 BYTES OF THE RBOPSW
*        FIELD IN THE SVRB THAT THE CONTENTS SUPERVISOR RUNS UNDER.
*        THE RBOPSW FIELD CAN BE USED BECAUSE THE RESUME ADDRESS
*        IS RESET WHEN THE RB IS DEQUEUED.  THE FIRST BYTE IS USED
*        TO SAVE THE DISPATCHING PRIORITY FROM THE TCB OF THE CURRENT
*        TASK, AND THE REMAINING 3 BYTES ARE USED TO SAVE THE TCB
*        ADDRESS.  THE QUEUE ORIGIN FOR ALL THE SVRBS WAITING FOR A
*        PARTICULAR MODULE IS THE CDRRBP FIELD OF THE MAJOR CDE FOR
*        THE REQUEST.  THE QUEUE IS SINGLE STRANDED, FORWARD CHAINED,
*        AND IN DISPATCHING PRIORITY ORDER, QUEUED ON RBPGMQ FIELD.
*        BEFORE EACH SVRB ON THE QUEUE IS CHECKED FOR THE INSERTION
*        POINT OF THE NEW SVRB, ITS TCB IS LOCATED BY RUNNING DOWN THE
*        RBLINK FIELDS UNTIL THE RB WITH THE RBTCBNXT FLAG IS FOUND.
*        THE TCB ADDRESS IS THEN COMPARED WITH THE CURRENT TCB ADDRESS
*        TO DETERMINE IF AN INTERLOCK SITUATION EXISTS.  IF THE TCB
*        ADDRESSES ARE EQUAL, AN A06 ABEND IS ISSUED, SINCE THE SAME
*        TASK HAS REQUESTED THE SAME MODULE TWICE WITHOUT GETTING
*        CONTROL OF IT.
*        AFTER CDQUECTL HAS QUEUED THE CURRENT SVRB, IT INSURES THAT A
*        TASK SWITCH WILL OCCUR, SETS THE SVRB TO WAIT, AND EXITS VIA
*        THE DISPATCHER.  WHEN DQLOAD IN IEAVLK01 IS ENTERED (QUEUED
*        FETCH), ALL WAITING SVRBS WILL BE MADE READY TO REENTER
*        CONTENTS SUPERVISOR AT IEAQCS02, WHEN THEIR TASKS ARE NEXT
*        DISPATCHED.  FOR QUEUED SERIAL REUSABLE MODULES, EXIT SETS
*        THE TASK TO REENTER AT IEAQCS03, ONE-AT-A-TIME, AS THE
*        MODULE BECOMES AVAILABLE.
*
         SPACE 2
*/*CDQUECTL: P PUT TCB PRIORITY IN RBOPSW */
*/* P PUT TCB ADDRESS IN RB EXTENDED SAVE AREA */
*/* P PUT MAJOR CDE ADDRESS IN SVRB */
         SPACE 2
CDQUECTL MVC   RBXXDSP(PRIO),TCBDSP    SET DISPATCHING PRIORITY IN RB
         STCM  TCBREG,MASK,RBOPSWA+N1  STORE TCB ADDR IN RB
         STCM  CDIREG,MASK,RBCDE1      PUT ADDR OF MAJOR IN RB
         L     WKREG1,CDRBPZ(CDIREG)   START DOWN QUEUE OFF MAJOR
         SPACE 2
*/*OSILATE: P GET FIRST ELEMENT ON RB QUEUE (RBPGMQ) */
         SPACE 2
OSILATE  LR    WKREG2,WKREG1           INITIALIZE NEXT RB POINTER
         SPACE 2
*/*OSCULATE: D (YES,CHECKTCB,NO,) IS USER'S TCB HUNG OFF THIS RB? */
*/* P (,OSCULATE) GET NEXT RB ON LIST */
         SPACE 2
OSCULATE TM    RBSTAB2Z(WKREG1),RBTCBNXT  Q. DOES THIS RB POINT TO TCB
         BO    CHECKTCB                A. YES- TAKE BRANCH
         L     WKREG1,RBLINKZ(WKREG1)  A. NO- GO TO NEXT RB
         B     OSCULATE                LOOP-FIND RB THAT POINTS TO TCB
         SPACE 2
*/*CHECKTCB: D (NO,QUECONT,YES,) TCB ADDR IN SVRB = CURRENT TCB? */
         SPACE 2
CHECKTCB CLC   RBOPSWA+N1(ADDL),RBLINKAZ(WKREG1)  COMPARE TCB ADDR'S
         BNE   QUECONT                 NO.CONTINUE THE QUEUEING
         SPACE 2
*/* D (NO,QUEEND,YES,) PARTIALLY LOADED PROGRAM? */
*/* P CLEAR CDE POINTER IN RB */
         SPACE 2
         TM    CDATTRJ,CDNIC           Q.PARTIALLY LOADED PROG.
         BNO   QUEEND                  NO.CONTINUE
         XC    RBCDE1(ADDL),RBCDE1     CLEAR CDE POINTER
*                                      CDE WILL BE FREED BY ABEND
         SPACE 2
*/*QUEEND: P SET ABEND REGISTER TO 0 */
*/* S () ERRLOCK:ISSUE A06 ABEND */
         SPACE 2
QUEEND   EQU   *                       ABEND A06 SITUATION
         SR    R13,R13                 ZERO OUT GR13 FOR ERROR ROUTINE
         B     ERRLOCK                 ISSUE ABEND (A06)
         SPACE 2
*/*QUECONT: P (=0,CUEIT,GT 0,) GET NEXT ELEMENT ON RB QUEUE */
         SPACE 2
QUECONT  EQU   *                       CHECK FOR SVRB INSERTION
         L     WKREG1,RBPGMQZ(WKREG2)  PICK UP NEXT RB ON QUEUE
         LTR   WKREG1,WKREG1           Q. CAN INSERT BE MADE HERE
         BZ    CUEIT                   A=YES INSERT RB ON QUEUE
         SPACE 2
*/* D (NO,OSILATE,YES,) CURRENT PRIORITY LT TEST PRIORITY */
         SPACE 2
         CLC   RBXXDSPZ(PRIO,WKREG1),RBXXDSP Q. IS PRIORITY OF RB HI'ER
         BNL   OSILATE                 A=YES INSERT RB ON QUEUE
         SPACE 2
*/*CUEIT: P PUT CURRENT SVRB ON QUEUE */
*/* P PUT CURRENT REGISTERS IN TCB */
         SPACE 2
CUEIT    ST    WKREG1,RBPGMQ           CHAIN FOUND SVRB TO NEW
         ST    RBREG,RBPGMQZ(WKREG2)   CHAIN NEW TO NEXT
         STM   R0,R15,TCBGRS           SAVE REGS IN TCB
         SPACE 2
*/* P SET UP FOR WAIT WITHOUT ECB */
*/* P NOTE: R0=WAIT CNT(1) R5=RB(CURRENT) R15=WAIT EP LOCAL LOCK HELD
*/**/
*/* L () WAIT-- IEAQCS02 */
         SPACE 2
         LA    R0,N1                   SET UP WAIT COUNT
         SR    R1,R1                   ASCB INDICATOR SET
         L     CVTREG,CVTPTR           GET CVT POINTER           M01585
         L     SUBREG2,CVTVWAIT        LOAD ADDRESS OF WAIT RTN PTM1585
         BR    SUBREG2                 GO TO WAIT               PTM1585
         TITLE  '              IEAVLK00 XCTL - SVC 7'
         SPACE 2
*/*IGC007: E XCTL */
*/* P ESTABLISH ADDRESSABILITY */
         SPACE 2
IGC007   DS    0H                      ENTRY TO SVC XCTL FROM SVC SLIH
         BALR  BASEREG,ZERO            SET UP BASE
         USING *,BASEREG
         L     BASEREG,LINKBASE        SET UP ADDRESSING FROM
         USING CDLKBASE,BASEREG        START OF SVC LINK
         USING CVT,CVTREG              SET ADDRESSIBILITY TO CVT
         SPACE 2
*/* L SETFRR-- SET UP RECOVERY ROUTINE */
         SPACE 2
         SETFRR A,PARMAD=(R8),WRKREGS=(R11,R12),FRRAD=FRRPGM
         SPACE 2
*/* P INITIALIZE RECOVERY PARAMETERS */
         SPACE 2
         ST    R8,RBCSFRRA             SAVE PARM LIST ADDRESS
         ST    RBREG,N0(R8)            PUT SVRB IN PARM LIST
         SPACE 2
*/* P GET CALLER'S RB ADDRESS FROM RBCHAIN FIELD */
*/* D (NO,NOTSVRB,YES,) IS CALLER AN SVRB? */
         SPACE 2
         L     WKREG2,RBWCF            GET REQUESTOR'S RB ADDR.
         TM    RBSTABZ(WKREG2),RBFTSVRB Q. REG'R AN SVRB
         BNO   NOTSVRB                 A. NO- CONTINUE
*
*     INPUTS TO TRRM ARE AS FOLLOWS FOR SVRB:
*        R0,1 = ADDRESS OF CALLERS SVRB
*        R4   = ADDRESS OF CURRENT TCB (SET BY INTERRUPT HANDLER)
*        R13  = ADDRESS OF A REGISTER SAVE AREA
*        R14  = RETURN ADDRESS
*        R15  = TRRM ENTRY POINT (FROM CVTSCBP)
*   THE LOCAL LOCK MUST BE HELD AND NOT FREED OVER INTERFACE.
*   XCTL IS ENTERED WITH THE LOCAL LOCK.
*
         SPACE 2
*/* P INITIALIZE NAME POINTER AND ADDRESS REGISTER */
         SPACE 2
         L     R15,N0(R15)             GET ADDRESS OF MOD. NAME PTM0180
         MVC   RBCSNAME(N8),N0(R15)    PUT MODULE NAME IN SVRB
         LA    NAMEREG,RBCSNAME        GET ADDRESS OF NAME
         USING ASCB,ASCBREG            GET ADDRESSABILITY TO ASCB
         SPACE 2
*/* P INITIALIZE FOR TRRM ROUTINE */
*/* L TRRM-- UPDATE ANY SCB'S FOR THIS RB */
         SPACE 2
         L     R13,ASCBASXB            GET ASXB ADDRESS
         USING ASXB,R13                GET ADDRESSIBILITY TO ASXB
         LA    R13,ASXBFLSA            GET LOCAL LOCK REG SAVE AREA
         DROP  R13                     RELEASE ASXB
         LR    WKREG0,WKREG2           SET BOTH INPUT REGISTERS 0 AND 1
         LR    WKREG1,WKREG2           TO ADDRESS OF THE REQ'R SVRB
         L     SUBREG2,CVTSCBP         GET ADDRESS OF TRRM ROUTINE
         BALR  RETURN,SUBREG2          GO TO TRRM
         DROP  ASCBREG                 RELEASE ASCB
*
*        THE FOLLOWING CODE BEGINS THE SEARCH FOR THE REQUESTED MODULE
*
         SPACE 2
*/* L SETLOCK-- OBTAIN CMS LOCK FOR LPA SEARCH */
         SPACE 2
         SETLOCK  OBTAIN,TYPE=CMS,MODE=UNCOND,RELATED=('IEAVLK01')
         SPACE 2
*/* P SET GOOD SEARCH INDICATOR OFF */
*/* S (+0,,+4,%GOOD) CDSEARCH:SEARCH LPAQ FOR MODULE */
         SPACE 2
         L     TAXRB,IEAQLCTA          GET START OF ACTIVE LPAQ
         NI    RBCSFLG1,MAX-RBCSGSF    INSURE GOOD SEARCH IND. IS OFF
         BAL   RETURN,CDSEARCH         TEST IF MODULE IS ON LPA
         SPACE 2
*/* P SET GOOD SEARCH INDICATOR ON */
         SPACE 2
         OI    RBCSFLG1,RBCSGSF        SET GOOD SEARCH FLAG
         STM   R11,R12,RBCSGR15        SAVE VOLITAL REGS
         SPACE 2
*/*%GOOD: L SETLOCK-- FREE CMS LOCK */
         SPACE 2
         SETLOCK RELEASE,TYPE=CMS,RELATED=('FREE CMS AFTER LPA SEARCH')
         SPACE 2
*/* D (NO,PLPASRCH,YES,) MODULE FOUND? */
*/* P (,EXITIT) MARK SVRB RESIDENT */
         SPACE 2
         LM    R11,R12,RBCSGR15        RESTORE VOLISTAL REGS
         TM    RBCSFLG1,RBCSGSF        Q. SEARCH SUCCESSFUL
         BZ    PLPASRCH                A. NO- SEARCH PLPA
         NI    RBSTAB1Z(OLDRB),MAX-RBTRSVRB MARK RB AS RESIDENT SVRB
         B     EXITIT                  GO DO TERMINATION PROCESSING
*
*        THIS CODE SEARCHES THE PLPA FOR THE MODULE
*
         SPACE 2
*/*PLPASRCH: D (YES,,NO,%ERROR) HAS LPDE BEEN BUILT? */
*/* S (+0,FOUNDEM,+4,) SRCHDIRC:SEARCH PAGED LPA DIRECTORY */
         SPACE 2
PLPASRCH DS    0H                      CHECKS THE PLPA FOR MODULE
         SR    R13,R13                 PREPARE FOR ABEND CONDITION BY
         LA    R15,BADRETCD            SETTING REASON CODE=X'0C'
         TM    CVTLPDIA,CVTDICOM       TEST IF LPDE HAS BEEN BUILT
         BZ    ERRBLDL                 IF NOT, ISSUE ABEND
         LM    R0,R1,N0(NAMEREG)       PUT NAME IN REGISTERS 0,1
         BAL   RETURN,SRCHDIRC         GO SEARCH PLPA
         B     FOUNDEM                 FOUND- PREPARE FOR TERMINATION
         SPACE 2
*/*%ERROR: P SET ABEND REG=0 SET RETURN CODE=12 */
*/* S () ERRBLDL:ISSUE 806 ABEND */
         SPACE 2
         SR    R13,R13                 NOT FOUND- PREPARE FOR ABEND BY
         LA    R15,BADRETCD            SETTING REASON CODE=X'0C'
         B     ERRBLDL                 AND ISSUING AN ABEND
         SPACE 2
*/*FOUNDEM: P SET SVRB TRANSIENT */
         SPACE 2
FOUNDEM  LR    CDEREG,WKREG0           TREAT LPDE LIKE A CDE
         OI    RBSTAB1Z(OLDRB),RBTRSVRB SET TO PAGEABLE SVRB
         SPACE 2
*/*EXITIT: P SET R15 WITH ENTRY POINT ADDRESS */
*/* P PUT ENTRY POINT ADDRESS IN RESUME PSW OF SVRB */
*/* P PUT CDE (OR LPDE) ADDRESS IN SVRB */
         SPACE 2
EXITIT   DS    0H                      TERMINTION PROCESSING
         USING CDENTRY,CDEREG          SET ADDRESS OF CDE
         L     R15,CDENTPT             GET MODULE ENTRY POINT
         ST    R15,RBOPSW-RBSECT+N4(WKREG2)  STORE ENTRY IN REQ'R RB
         STCM  CDEREG,MASK,RBCDE1Z(WKREG2)  STORE ADDR. OF CDE OR LPDE
*                                      IN REQUESTOR'S SVRB
         SPACE 2
*/* L SETFRR-- REMOVE RECOVERY ROUTINE */
         SPACE 2
         SETFRR D,WRKREGS=(R1,R2)      REMOVE RECOVERY RTN
         SPACE 2
*/* P RESTORE REGS 0 AND 1 FROM SVRB SAVE AREA */
*/* R BRANCH EXIT PROLOGUE */
         SPACE 2
         LM    R0,R1,RBGRSAVE          RESET XCTL INPUT REGISTERS
         L     RETURN,CVTEXPRO         GET ADDRESS OF THE EXIT PROLOG
         BR    RETURN                  EXIT
*
*        NON-SVRB PROCESSING BEGINS HERE
*
         SPACE 2
*/*NOTSVRB: S LXPREFIX:VALIDITY CHECK INPUT */
*/* P INDICATE PROG MGR SVRB FOR RTM */
*/* P RESET CALLERS RB ADDRESS */
         SPACE 2
NOTSVRB  OI    RBSTAB1,RBPMSVRB        THIS IS PROG MGR SVRB.  @YA00094
*                                      USED BY RTM TO INVOKE THE
*                                      ABEND RESOURCE MGR DURING
*                                      RECOVERY RETRY.
         BAL   RETURND,LXPREFIX        VALIDITY CHECK INPUT PARAMETERS
         L     WKREG2,RBWCF            GET REQUESTOR'S RB ADDR.   P1585
*                                      AND INIT. WORK REGS. AND AREAS
         SPACE 2
*/* P SET UP FOR GETMAIN */
*/* L GETMAIN-- GET PRB FROM SUBPOOL 255 */
         SPACE 2
         L     ASCBREG,PSAAOLD         GET ASCB ADDRESS FOR GETMAIN
*     REGISTER 4= TCB, R7= ASCB,LOCAL LOCK MUST BE HELD
         GETMAIN  RU,LV=PRBSIZE,SP=255,BRANCH=YES  GET A PRB
         SPACE 2
*/* P CLEAR PREFIX AREA */
         SPACE 2
         XC    N0(PRBPREF,R1),N0(R1)   CLEAR THE PREFIX AREA
         LA    PRBREG,PRBPREF(R1)      GET POINTER TO RB BASE
*  INITIALIZE THE NEW RB
         SPACE 2
*/* P COPY OLD PRB CONTENT TO NEW PRB */
*/* P NOTE: ATTRIBUTES FROM OLD IN NEW: ATTN, TCBNXT, LASTRB, RBTYPE */
*/* P NOTE: THIS PUTS THE PROPER REGISTERS IN CURRENT PRB FOR ASIR
*/* PROCESSING */
*/* P NOTE: AND SETS CHAIN POINTER TO NEXT OLDER RB OR TCB */
         SPACE 2
         MVC   PRBSTART(PRBSIZ),RBSECTZ(OLDRB) COPY OLD RB TO NEW RB
         SPACE 2
*/* P CLEAR CDE POINTER IN NEW PRB */
         SPACE 2
         SR    R1,R1                   CLEAR REG FOR STORE
         ST    R1,PRBFLGS              ZERO CDE POINTER IN NEW PRB
         ST    R1,PRBPGMQ              CLEAR SER.REUS RBQUE FIELD M2444
*  SET UP FOR TRRM FOR PRB
*/* P SET UP FOR TRRM */
*/* L TRRM-- UPDATE ANY SCB'S */
         SPACE 2
         LR    R0,OLDRB                PUT ADDRESS OF OLD RB IN R0
         LR    R1,NEWRB                PUT ADDRESS OF NEW RB IN R1
         USING ASCB,ASCBREG            GET ADDRESSABILITY TO ASCB
         L     R13,ASCBASXB            GET ASXB ADDRESS
         USING ASXB,R13                GET ADDRESSIBILITY TO ASXB
         LA    R13,ASXBFLSA            GET LOCAL LOCK REG. SAVE AREA
         DROP  R13                     RELEASE ASXB
         L     CVTREG,CVTPTR           GET CVT ADDRESS
         L     R15,CVTSCBP             GET ADDRESS OF TRRM ROUTINE
         BALR  RETURN,R15              GO TO UPDATE ANY SCB'S
         DROP  ASCBREG                 RELEASE ASCB
*  UPDATE THE RB CHAIN FIELD
         SPACE 2
*/* P INDICATE XCTL IN PROCESS */
         SPACE 2
         OI    RBCDFLGS,XCTL           INDICATE XCTL IN PROGRESS
         SPACE 2
*/* D (YES,IRBPROC,NO,) IS THE REQUESTER AN IRB? */
         SPACE 2
         TM    RBSTABZ(OLDRB),RBFTSVRB  TEST CALLERS RB FOR IRB
         BNZ   IRBPROC                 IRB-BRANCH TO PROCESS AS IRB
*
*        THIS CODE IS ONLY FOR PRB'S WHICH ISSUE XCTL
*  NEW RB ALREADY POINTS TO NEXT OLDER DUE TO RB INITIALIZATION
*
         SPACE 2
*/* P POINT OLD PRB TO SVRB */
*/* P POINT SVRB TO NEW RB */
*/* P POINT TCB TO OLD RB */
*/* P TURN OFF LAST RB FLAG */
*/* P SET SVRB RESUME PSW TO IEAQCS02 */
         SPACE 2
         ST    RBREG,RBLINKZ(OLDRB)    POINT OLD RB TO SVRB
         ST    NEWRB,RBWCF             POINT SVRB TO NEW RB
         ST    OLDRB,TCBRBP            POINT TCB TO OLD RB
         NI    RBSTAB2Z(OLDRB),MAX-RBTCBNXT INSURE NOT EOT PROCESSING
         LA    WKREG1,IEAQCS02         GET RETURN POINT IN PROGRAM
         ST    WKREG1,RBOPSWA          MANAGER AND PUT IN SVRB PSW
         SPACE 2
*/* L SETFRR-- REMOVE RECOVERY ROUTINE */
         SPACE 2
         SETFRR D,WRKREGS=(R11,R12)     REMOVE RECOVERY RTN.
         SPACE 2
*/* L SETLOCK-- FREE LOCAL LOCK */
         SPACE 2
         SETLOCK RELEASE,TYPE=LOCAL,RELATED=FREE LOCK TO ISSUE SVC
         SPACE 2
*/* L EXIT-- VIA SVC 3 TO FREE OLD PRB */
         SPACE 2
         SVC   EXIT                    EXIT XCTL RESUMES AT IEAQCS02
*
*        CONTROL RETURNS HERE AFTER EXIT OF CALLER PRB
*
         SPACE 2
*/*IEAQCS02: E IEAQCS02 */
*/* L SETLOCK-- OBTAIN LOCAL LOCK */
         SPACE 2
IEAQCS02 DS    0H                      FETCH RESTARTS BEGIN HERE, TOO.
         SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,RELATED=NO GET LOCAL
         SPACE 2
*/* L SETFRR-- SET UP RECOVERY ROUTINE */
         SPACE 2
         SETFRR A,FRRAD=FRRPGM,WRKREGS=(R1,R15),PARMAD=(R8)
         SPACE 2
*/* P (,CDADVANS) INITIALIZE RECOVERY PARAMETERS */
         SPACE 2
         ST    RBREG,N0(R8)            SAVE MY SVRB ADDR.
         ST    R8,RBCSFRRA             SAVE PARM LIST ADDRESS
         B     CDADVANS                PROCESS AS LINK
*
*        THIS CODE IS ONLY FOR IRB'S WHICH ISSUE XCTL
*
         SPACE 2
*/*IRBPROC: P SET IRB OLD PSW TO SVC 3 */
*/* P MAKE NEW RB RECOGNIZABLE AS PRB */
*/* P POINT NEW RB TO IRB */
*/* P CLEAR 12 BYTE AREA IN NEW PRB */
         SPACE 2
IRBPROC  DS    0H                      IRB PROCESSING
         LA    WKREG1,CVTEXIT          IRB PROCDDEURE FOR XCTL IS
         ST    WKREG1,RBOPSWZ+N4(OLDRB)  TO PUT ADDRESS OF SVC 3
*                                      IN REQ'R PSW
         XC    N0(PRBCLR,NEWRB),N0(NEWRB) CLEAR FIRST 12 BYTES    M3550
         SPACE 2
*/* P (,CDADVANS) POINT SVRB TO NEW PRB */
         SPACE 2
         MVI   RBSIZ1+N1(NEWRB),PRBWDLEN INSERT PRB SIZE
         NI    RBSTABZ(NEWRB),PRBX     MARK RB AS PRB
         OI    RBSTAB2Z(NEWRB),RBFDYN  INSURE CORE FREED ON EXIT  M3550
         ST    OLDRB,RBLINKZ(NEWRB)    POINT NEW RB TO IRB
         ST    NEWRB,RBWCF             POINT SVRB TO NEW RB
         B     CDADVANS                SEARCH FOR REQUESTED MODULE
         TITLE '               IEAVLK00 LOAD SVC - 8'
         SPACE 2
*/*IGC008: E LOAD */
*/* P SET UP ADDRESSABILITY */
         SPACE 2
IGC008   DS    0H                      SVC LOAD ENTRY POINT
         BALR  BASEREG,ZERO            SET UP BASE ADDRESSABILITY
         USING *,BASEREG               ON LOAD ENTRY
         L     BASEREG,LINKBASE        RESET BASE TO VALUE LINK BASE
         USING CDLKBASE,BASEREG        FOR COMMON CODE
         USING LLE,LDLREG              R13 ADDRESSES THE LLE
         SPACE 2
*/* L SETFRR-- SET UP RECOVERY ROUTINE */
         SPACE 2
         SETFRR A,PARMAD=(R8),WRKREGS=(R11,R12),FRRAD=FRRPGM
         SPACE 2
*/* P INITIALIZE RECOVERY PARAMETERS */
         SPACE 2
         ST    R8,RBCSFRRA             SAVE PARM LIST ADDRESS
         ST    RBREG,N0(R8)            SAVE SVRB IN PARM LIST
         SPACE 2
*/* P INDICATE PROG MGR SVRB FOR RTM */
         SPACE 2
         OI    RBSTAB1,RBPMSVRB        THIS IS PROG MGR SVRB.  @YA00094
*                                      USED BY RTM TO INVOKE THE
*                                      ABEND RESOURCE MGR DURING
*                                      RECOVERY RETRY.
         SPACE 2
*/* P INDICATE REQUEST FOR LOAD IN VLKSVRB */
*/* S DALPRFIX:SET UP RB EXTENDED SAVE AREA */
*/* P GET POINTER TO JOB PACK AREA */
         SPACE 2
         OI    RBCDFLGS,LOAD           INDICATE ENTRY BY LOAD MACRO.
         BAL   RETURND,DALPRFIX        SET UP REGS 9,10, AND EXSAVE
         L     TABREG,TCBJSTCB         GET JOB STEP TCB
         LA    TABREG,TCBJSEZ(TABREG)  GET POINTER TO JPAQ
         SPACE 2
*/* S (+0,ALOCLLE2,+4,CDCONTRL) CDLLSRCH:SEARCH LLE QUEUE FOR MODULE */
         SPACE 2
         BAL   SUBREG2,CDLLSRCH        SEARCH THE LOAD LIST QUEUE
         SPACE 2
*/*ALOCLLE2: S (+0,CDCONTRL,+4,LLEFOUND,+8,CONTLLSR,+16,CDQUECTL)
*/*CDALLOC:DETERMINE AVAILABILITY OF MODULE */
         SPACE 2
ALOCLLE2 BAL   SUBREG2,CDALLOC         IF FOUND ALLOCATE
         B     CDCONTRL                NO SUCCESSFUL ALLOC
         B     LLEFOUND                SAVE LLE IN EXSA OF SVRB
         B     CONTLLSR                CONTINUE SEARCH
         NOP   N0(N0,N0)               THIS RET SHOUDL NOT BE ENTERED
         B     CDQUECTL                QUEUE RB UNTIL MOD IF FETCHED.
         SPACE 2
*/*CONTLLSR: S (+0,ALOCLLE2,+4,CDCONTRL) CDLLSRCH:CONTINUE LLE SEARCH
*/**/
         SPACE 2
CONTLLSR LR    R1,R13                  PUT BEGIN LLE IN R1
         LA    SUBREG2,ALOCLLE2        PUT RETURN ADDRESS IN REG
         B     CDLLCONT                CONTINUE CONTINUE SEARCH
         SPACE 2
*/*LLEFOUND: P SAVE LLE ADDRESS IN RB EXTENDED SAVE AREA */
*/* D (YES,,NO,CDEMERGE) WAS MODULE LOADED BY NIP? */
*/* P SAVE VOLITAL REGSITERS ACROSS INTERFACE */
*/* L SETLOCK-- OBTAIN CMS LOCK */
*/* P (,CDEMERGE) RESTORE VOLITAL REGSITERS */
         SPACE 2
LLEFOUND ST    LDLREG,RBCSLLE          SAVE LLE IN EXSA OF SVRB
         TM    CDATTRJ,CDNIP           LOADED BY NIP             M01907
         BZ    CDEMERGE                NO,CONTINUE               M01907
         STM   R11,R12,RBCSGR0         SAVE VOLITAL REGISTERS    M01907
         SETLOCK OBTAIN,TYPE=CMS,MODE=UNCOND,                   M01907 X
               RELATED=('FREED BY EXIT PROLOGUE') GET CMS LOCK   M01907
         LM    R11,R12,RBCSGR0         RESTORE VOLIATL REGISTERS M01907
         B     CDEMERGE                COMPLETE REQUEST
         EJECT
*        THIS IS THE LOAD FINAL PROCESSING ROUTINE.  THE LLE IS EITHER
*        FOUND DURING THE LLE SEARCH, OR IS CREATED HERE (WITH COUNT
*        SET TO ZERO).  NEXT THE RESPONSIBILITY COUNT IS CHECKED FOR
*        THE MAXIMUM VALUE (7FFF). IF MAX VALUE WAS REACHED, 906 ABEND
*        IS GENERATED.  OTHERWISE THE COUNT IS INCREMENTED BY ONE, R15
*        IS SET TO ZERO, R0 IS SET TO THE REQUESTED ENTRY POINT,
*        R1 IS SET TO THE SIZE OF THE MODULE IN DOUBLE WORDS, AND THE
*        THE HIGH ORDER BYTE OF REGISTER 1 IS SET TO INDICATE THE APF
*        STATUS OF THE LOADED MODULE.  RETURN TO THE USER IS MADE VIA
*        A BRANCH TO THE EXIT PROLOGUE.
*        REGISTERS AT ENTRY
*              R3,4,5-  CVT,TCB,SVRB
*              R6    - BASE (IEAVLK00)
*              R11   - REQUESTED CDE
*              R12   - MAJOR CDE FOR REQUEST
*              OTHER REGISTERS NOT REFERENCED
*              SVRB EXSAVE FULLY INITIALIZED.
         SPACE 2
*/*CDLDRET: P GET ADDR OF LLE FROM RB EXTENDED SAVE AREA */
         SPACE 2
CDLDRET  DS    0H                      FOAD FINAL PROCESSING
         L     LDLREG,RBCSLLE          GET LLE
         SPACE 2
*/* D (YES,LOLITA,NO,) WAS LLE FOUND? */
         SPACE 2
         LTR   LDLREG,LDLREG           DOES LLE EXIST
         BNZ   LOLITA                  YES DO NOT GET ONE
         SPACE 2
*/* L GETMAIN--  GET LLE FROM LSQA */
         SPACE 2
         L     ASCBREG,PSAAOLD         GET ASCB ADDRESS FOR GM
         GETMAIN RU,LV=LLESIZE,SP=255,BRANCH=YES  GET LLE FROM 255
         SPACE 2
*/* P INITIALIZE AND CHAIN LLE TO TOP OF LLE QUEUE */
         SPACE 2
         LR    LDLREG,R1               SET LLE BASE REGISTER
         L     WKREG1,TCBLLS           FIND LLE QUEUE ORIGIN
         ST    LDLREG,TCBLLS           MAKE THIS LLE FIRST LLE
         ST    WKREG1,LLECHN           POINT NEW LLE TO NEXT LLE
         LA    CDEREG,0(CDEREG)        CLEAR HIGH BYTE
         SPACE 2
*/* P POINT LLE TO MINOR CDE (OR MAJOR IF NO MINOR) */
         SPACE 2
         ST    CDEREG,LLECDPT          POINT LLE TO CDE
         SR    WKREG1,WKREG1           CLEAR REG TO INITIALIZE COUNTS
         STH   WKREG1,LLECOUNT         SET TOTAL COUNT TO ZERO
         STH   WKREG1,LLESYSCT         SET SYSTEM COUNT TO ZERO
         SPACE 2
*/*LOLITA: D (NO,LOLIT,YES,) LLE RESPONS COUNT = MAX? */
         SPACE 2
LOLITA   CLC   LLECOUNT(N2),MAXIM      IS LLECOUNT MAXIMUM
         BNE   LOLIT                   IF NOT CONTIMUE AT LOLIT
         SPACE 2
*/* P INITIALIZE ABEND CODE = 0 */
*/* P DECREMENT MAJOR CDE USE COUNT BY 1 */
*/* S () ERRCONT:GIVE ABEND CODE 906 */
         SPACE 2
         SR    R13,R13                 OTHERWISE ABEND 906
         LH    WKREG1,CDUSEJ           PICK UP FIRST BYTE
         BCTR  WKREG1,N0               DECREMENT COUNT BY ONE
         STH   WKREG1,CDUSEJ           PUT COUNT BACK IN CDE
         B     ERRCOUNT                GO TO ABEND
         SPACE 2
*/*LOLIT: P INCREMENT LLE TOTAL RESPONSIBILITY BY 1 */
         SPACE 2
LOLIT    LH    WKREG1,LLECOUNT         PICK UP USE COUNT
         LA    WKREG1,N1(WKREG1)       INCREMENT BY ONE
         STH   WKREG1,LLECOUNT         STORE THE NEW COUNT
         SPACE 2
*/* D (NO,LOXLBLD,YES,) IS THIS A SYSTEM REQUEST? */
         SPACE 2
         TM    RBCSFLG1,RBCSSYSR       SYSTEM REQUEST
         BZ    LOXLBLD                 NO- GET EP AND LNG FOR EXIT
         SPACE 2
*/* P INCREMENT SYSTEM RESPONSIBILITY COUNT IN LLE BY 1 */
         SPACE 2
         LH    WKREG1,LLESYSCT         LOAD LLE SYSTEM USE COUNT
         LA    WKREG1,N1(WKREG1)       INCREMENT BY ONE
         STH   WKREG1,LLESYSCT         STORE NEW LLE SYSTEM USE COUNT
         SPACE 2
*/*LOXLBLD: P SET RETURN CODE = 0 */
*/* P GET ADDRESS OF EXTENT LIST */
*/* P GET NUMBER OF EXTENTS FROM XL */
         SPACE 2
LOXLBLD  DS    0H
         SR    R15,R15                 CLEAR RETURN CODE REGISTER
         SR    WKREG1,WKREG1           CLEAR REGISTER FOR LOOP @ZA16851
         L     WKREG2,CDXLMJPJ         GET XTLST ADDRESS
         LTR   WKREG2,WKREG2           DOES XTLST EXIST?       @ZA16851
         BZ    NOXL                    NO.SKIP MOD LENGTH CALC @ZA16851
         L     COMREG,N4(WKREG2)       GET NUMBER OF EXTENTS
         SPACE 2
*/*ADDLOOP: P CALCULATE MODULE LENGTH */
*/* P REDUCE LENGTH TO NO. OF DWDS IN R1 */
         SPACE 2
ADDLOOP  AL    WKREG1,N8(WKREG2)       ADD NEXT LENGTH
         LA    WKREG2,N4(WKREG2)       POINT TO NEXT LENGTH
         BCT   COMREG,ADDLOOP          IF ANOTHER EXTENT, ADD IT
*                                      OTHERWISE DROP THROUGH
         LA    WKREG1,MASK(WKREG1)     ROUND UP TO NEXT BOUNDARY
         SRL   WKREG1,N3               CONVERT SIZE TO DOUBLE WORDS
         SPACE 2
*/* P SET R0 = ENTRY POINT OF MODULE (FROM MINOR CDE) */
         SPACE 2
NOXL     DS    0H                                              @ZA16851
         L     COMREG,CDENTPT          GET ENTRY POINT FROM CDE
         LA    R0,N0(COMREG)           SET RETURN REG AND CLEAR BYTE
         SPACE
*        LOAD APF INCIDATOR SETTING.  PUT AUTHORIZATION INTO REGISTER
*        1, HIGH ORDER BYTE.
         SPACE
         TM    CDATTR2,CDAUTH          IS MAJOR AUTHORIZED
         BNO   NOLDAUTH                SKIP FLAG SETTING
         ICM   R1,AUTHBYTE,AUTHON      SET APF FLAG
         SPACE 2
*/*NOLDAUTH: L SETFRR-- REMOVE RECOVERY ROUTINE */
         SPACE 2
NOLDAUTH DS    0H                      FLAG SKIP LABEL
         SETFRR D,WRKREGS=(R11,R12)    REMOVE RECOVERY RTN.
         SPACE 2
*/* P GET ADDRESS OF EXIT PROLOGUE IN R14 */
*/* R RETURN BR 14 */
         SPACE 2
         L     CVTREG,CVTPTR           GET CVT ADDRESS
         L     R14,CVTEXPRO            GET EXIT ADDR.
         BR    R14                     EXIT TO ISSUER OF LOAD SVC
         TITLE '               IEAVLK00 DELETE - SVC 9'
         SPACE 2
*/*IGC009: E DELETE */
*/* P ESTABLISH ADDRESSABILITY */
         SPACE 2
IGC009   DS    0H                      DELETE ENTRY POINT
         BALR  BASEREG,ZERO            SET UP BASE ADDRESS
         USING *,BASEREG               SET UP TEMPORARY BASE
         L     BASEREG,LINKBASE        SET UP ADDRESSABILITY OVER
         USING CDLKBASE,BASEREG        ENTIRE MODULE.
         SPACE 2
*/* L SETFRR-- SET UP RECOVERY ROUTINE */
*/* P INITIALIZE FRR PARAMETERS */
         SPACE 2
         SETFRR A,PARMAD=(R8),WRKREGS=(R11,R12),FRRAD=FRRPGM
         ST    R8,RBCSFRRA             SAVE PARM LIST ADDRESS
         ST    RBREG,N0(R8)            SAVE SVRB ADDR. IN PARM LIST
         SPACE 2
*/* P INSURE EP FORM (DE NOT ACCEPTED) */
*/* S DALPRFIX:INITIALIZE RB EXTENDED SA */
         SPACE 2
         ICM   R0,MASK8,CLRBYTE        CLEAR BYTE FOR PREFIX ROUTINE
*                                      NO DE FORM POSSIBLE
         SR    R1,R1                   NO DCB ADDR POSSIBLE
         BAL   RETURND,DALPRFIX        SET UP R9,R10 AND EXSAVE
         SPACE 2
*/* S CDLLSRCH:SEARCH LLE QUEUE */
         SPACE 2
*        DELETE WILL SEARCH THE LOAD LIST FOR THE MODULE TO BE DELETED.
*        IF THE MODULE IS NOT ON THE LOAD LIST, A CODE OF 4 IS
*        RETURNED IN REG. 15. A CODE OF 8 IS RETURNED IN REG. 15 IF
*        THE MODULE TO BE DELETED WAS NOT LOADED BY THE USER ROUTINE.
*        IF THE DELETE IS SUCCESSFUL A CODE OF 0 IS RETURNED IN
*        REGISTER 15.
*        CDLLSRCH WILL RETURN TO EITHER OF TWO LOCATIONS
*              IF MODULE IS FOUND  - BRANCH ON SUBREG2
*              IF MODULE NOT FOUND - BRANCH ON SUBREG2+4
         SPACE 1
         BAL   SUBREG2,CDLLSRCH        SEARCH LOAD LIST OFF TCB
         SPACE 2
*/*%CDLLS: D (YES,LLFOUND,NO,) LLE FOUND? */
         SPACE 2
         B     LLFOUND                 MDOULE FOUND
         SPACE 2
*/* L () EXIT-- PROLOGUE RC=4 */
         SPACE 2
         LA    R15,FOUR                MODULE NOT FOUND
         B     DELETXIT                EXIT FROM DELETE
         SPACE 2
*/*LLFOUND: D (NO,CDNON01,YES,) CDE A MINOR? */
*/* P GET MAJOR */
         SPACE 2
LLFOUND  DS    0H                      LLE EXISTS
         TM    CDATTR,CDMIN            IF MINOR PICK UP MAJOR
         BNO   CDNON01                 SKIP PICK UP IF MAJOR
         L     CDEREG,CDXLMJP          PICK UP MAJOR ADDRESS
         SPACE 2
*/*CDNON01: D (NO,PPREQ,YES,) SYSTEM REQUEST? */
         SPACE 2
CDNON01  TM    RBCSFLG1,RBCSSYSR       Q. SYSTEM REQUEST
         BZ    PPREQ                   A. NO CONTINUE DELETE FOR USER
         SPACE 2
*/* D (NO,TSTOK,YES,) SYSTEM COUNT = 0? */
         SPACE 2
         LH    WKREG2,LLESYSCT         GET SYSTEM COUNT
         LTR   WKREG2,WKREG2           SYSTEM LLE USE COUNT ZERO
         BNZ   TSTOK                   A. NO-DELETE THIS MODULE
         SPACE 2
*/*RETRYLLE: S (,%CDLLS) CDLLCONT:CONTINUE SEARCH */
         SPACE 2
RETRYLLE LR    R1,LDLREG               A. NO- SET SEARCH TO BEGIN WITH
*                                      THIS MODULE
         B     CDLLCONT                CONTINUE SEARCH
         SPACE 2
*/*PPREQ: D (NO,RETRYLLE,YES,DELNORM) TOTAL USE COUNT GT SYSTEM USE
*/*COUNT? */
         SPACE 2
PPREQ    CLC   LLECOUNT,LLESYSCT       TEST TOTAL COUNT > SYSTEM COUNT
         BNH   RETRYLLE                GET ANOTHER LLE
         B     DELNORM                 CONTINUE NORMAL DELETE
         SPACE 2
*/*TSTOK: P DECREMENT SYSTEM USE COUNT */
         SPACE 2
TSTOK    BCTR  WKREG2,N0               DECREMENT BY ONE
         STH   WKREG2,LLESYSCT         STORE SYSTEM COUNT
         SPACE 2
*/*DELNORM: P DECREMENT LLE COUNT BY ONE */
*/* D (NO,LLNON0,YES,) LLE USE COUNT = 0? */
         SPACE 2
DELNORM  LH    WKREG2,LLECOUNT         GET USE COUNT
         BCT   WKREG2,LLNON0           IF NOT 0, FREE LLE
         SPACE 2
*/* P DEQUEUE LLE */
         SPACE 2
         MVC   N0(WORD,WKREG1),LLECHN  REMOVE ELEMENT FROM LIST
         L     AREAREG,PSAAOLD         GET ASCB FOR FREEMAIN
         SPACE 2
*/* L (,MAJOR) FREEMAIN-- FREE LLE */
         SPACE 2
         FREEMAIN RU,SP=255,A=(LDLREG),LV=LLESIZE,BRANCH=YES FREE LLE
         B     MAJOR                   SKIP STORING- LLE WAS FREED
         SPACE 2
*/*LLNON0: P STORE NEW LLE USE COUNT */
         SPACE 2
LLNON0   STH   WKREG2,LLECOUNT         SAVE NEW COUNT
         SPACE 2
*/*MAJOR: D (NO,JPQMOD,YES,) CDE ON LPA QUEUE? */
*/* P SAVE R11 - R13 IN RB EXTENDED SAVE AREA */
*/* L SETLOCK-- GET CMS LOCK */
*/* P RESTORE R11 - R13 */
         SPACE 2
MAJOR    TM    CDATTR,CDNIP            CDE ON LPAQ TEST
         BZ    JPQMOD                  NO-SKIP GETTING CMS LOCK @Y04990
         STM R11,R13,RBCSGR15          SAVE VOLITAL REGISTERS   @Y04990
         SETLOCK OBTAIN,TYPE=CMS,MODE=UNCOND,                   @Y04990x
               RELATED=('IEAVLK02,CDHKEEP,EXITSRCH OR EXITPROLOGUE')
         LM    R11,R13,RBCSGR15        RESOTRE VOLITAL REGS     @Y04990
         SPACE 2
*/*JPQMOD: P DECREMENT CDE USE COUNT */
*/* D (NO,CDNON0,YES,) CDE USE COUNT = 0? */
         SPACE 2
JPQMOD   DS    0H                      DECREMENT CDE COUNT
         LH    WKREG2,CDUSE            PICK UP USE COUNT IN CDENTRY
         BCTR  WKREG2,N0               DECREMENT COUNT BY ONE
         STH   WKREG2,CDUSE            SAVE NEW CDUSE COUNT
         LTR   WKREG2,WKREG2           Q. USE COUNT ZERO
         BNZ   CDNON0                  A. NO- GIVE NORMAL RETURN
         SPACE 2
*/* S CDHKEEP:FREE CDE AND MINORS */
         SPACE 2
         L     GR15,HKPADDR            SET UP ENTRY POINT ADDRESS
         BALR  RETURN,GR15             BRANCH TO CDHKEEP,RET REG SET
         SPACE 2
*/*CDNON0: P SET RETURN CODE IN REG 15 = 0 */
         SPACE 2
CDNON0   DS    0H                      DELETE EXIT SUCCESSFUL
         SR    R15,R15                 INDICATE DELETE SUCCESSFUL
         SPACE 2
*/*DELETXIT: P GET EXIT PROLOGUE ENTRY POINT */
         SPACE 2
DELETXIT DS    0H                      EXIT FROM DELETE          PTM023
         L     CVTREG,CVTPTR           GET CVT ADDRESS
         L     RETURN,CVTEXPRO         GET ADDRESS OF EXIT PROLOGUE
         SPACE 2
*/* L SETFRR-- REMOVE RECOVERY ROUTINE */
*/* R RETURN VIA BR 14 */
         SPACE 2
         SETFRR D,WRKREGS=(R1,R2)      REMOVE RECOVERY RTN.
         LM    R0,R1,RBGRS0            PASS PARAMETERS TO USER
         BR    RETURN                  GO TO EXIT PROLOGUE
         TITLE '               IEAVLK00 SYNCH - SVC 12'
         SPACE 2
*/*IGC012: E SYNCH */
*/* P SET UP ADDRESSABILITY */
         SPACE 2
IGC012   DS    0H                      SVC SYNCH ENTRY
         BALR  BASEREG,ZERO            SET UP ADDRESSIBILITY
         USING *,BASEREG               TEMPORARY BASE FOR NEXT INST.
         L     BASEREG,LINKBASE        PICK UP PERMANENT BASE
         USING CDLKBASE,BASEREG        SET ADDRESSABILITY
         SPACE 2
*/* L SETFRR-- SET UP RECOVERY ROUTINE */
*/* P INITIALIZE RECOVERY PARAMETERS */
         SPACE 2
         SETFRR A,PARMAD=(R8),WRKREGS=(R11,R12),FRRAD=FRRPGM
         ST    R8,RBCSFRRA             SAVE PARM LIST ADDRESS
         ST    RBREG,N0(R8)            PUT SVRB ADDR IN PARMLIST M01978
         SPACE 2
*/* P MOVE ENTRY POINT ADDRESS FROM R15 TO R14 */
*/* P (,THRUX) INDICATE IN CDFLGS THE REQUEST IS SYNCH */
         SPACE 2
         LR    SUBREG1,R15             PUT ENTRY ADDRESS IN REGISTER
*                                      EXPECTED BY THRUX
         OI    RBCDFLGS,SYNC           SET FLAG IN RBCDFLGS INDICATING
*                                      ENTRY TO MAINLINE BY SYNCH
         B     THRUX                   CONTINUE SYNCH PROCESSING
*                                      IN COMMON CODE
         TITLE '               IEAVLK00 ATTACH INTERFACE ENTRY'
* ENTRY POINT FOR ATTACH
* ENTRY CONDITIONS
*           R0 = ADDRESS OF PN OR DE
*           R0 = IS COMPLIMENTED IF DE
*           R1 = ADDRESS OF CDE
*           R3 = ADDRESS OF CVT
*           R4 = ADDRESS OF TCB
*           R5 = ADDRESS OF PGM. MGR. SVRB
*          ON ENTRY THE PSW IS FULLY ENABLE, PRIVILEGED, KEY 0,
*          NO LOCKS ARE HELD ON ENTRY
         SPACE  2
*/*IEAQCS01: E ATTACH */
         SPACE 2
IEAQCS01 DS    0H                      ENTRY POINT FOR ATTACH
         SPACE 2
*/* P SET UP ADDRESSIBILITY */
         SPACE 2
         BALR  BASEREG,ZERO            SET UP TEMPORARY BASE
         USING *,BASEREG               USED TO GET NORMAL BASE
         L     BASEREG,LINKBASE        SET UP PERMANENT BASE
         USING CDLKBASE,BASEREG        SET ADDRESSABILITY
         SPACE 2
*/* P TURN ON ATTACH FLAG IN RBCDE FIELD */
         SPACE 2
         OI    RBCDFLGS,RBCSATT        SET ATTACH BIT ON IN RB
         SPACE 2
*/* P INDICATE PROG MGR SVRB FOR RTM */
         SPACE 2
         OI    RBSTAB1,RBPMSVRB        THIS IS PROG MGR SVRB.  @YA00094
*                                      USED BY RTM TO INVOKE THE
*                                      ABEND RESOURCE MGR DURING
*                                      RECOVERY RETRY.
         SPACE 2
*/* L SETLOCK-- OBTAIN LOCAL LOCK */
         SPACE 2
         SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,RELATED=EXIT
         SPACE 2
*/* L SETFRR-- INITIALIZE RECOVERY ROUTINE */
*/* P CLEAR WORK FIELDS IN RB EXTENDED SAVE AREA */
*/* P INITIALIZE RECOVERY PARAMENTERS */
         SPACE 2
         SETFRR A,PARMAD=(R8),WRKREGS=(R11,R12),FRRAD=FRRPGM
         XC    RBCSERRA(CLRSIZE+EIGHT),RBCSERRA CLEAR WORK AREA  @WAB
         ST    R8,RBCSFRRA             SAVE PARM LIST ADDRESS
         ST    RBREG,N0(R8)             SAVE SVRB ADDR. IN PARM LIST
         SPACE 2
*/* P INITIALIZE NAME AND DCB REGISTERS */
         SPACE 2
         LPR   NAMEREG,R0              GET UNCOMPLIMENTED NAME ADDRES
         LA    DCBREG,N0(R1)           SET UP COMMON DCB REG.
         LNR   DCBREG,DCBREG           SET NEG. - DCB NOT CHKED  M04728
         SR    R1,R1                   PREPARE FOR TYPE STORAGE
         SPACE 2
*/* D (NO,EPFRM,YES,) DE FORM OF ATTACH? */
         SPACE 2
         LTR   R0,R0                   Q. DE FORM REQUEST
         BNM   EPFRM                   A. NO- USE EP FORM
         SPACE 2
*/* P PUT NAME AND DE POINTER IN RBXSA */
         SPACE 2
         MVC   RBCSNAME(EIGHT),N4(NAMEREG) PUT NAME IN XSA
         LR    R1,NAMEREG              SAVE ADDRESS OF DE
         LA    NAMEREG,RBCSNAME        POINT NAME REG. TO XSA NAME
         SPACE 2
*/*EPFRM: D (NO,AUTHOFF,YES,) ATTACH CALLER AUTHORIZED? */
*/* P INDICATE AUTHORIZED CALLER IN RBXSA */
         SPACE 2
EPFRM    TM    RBCSDE,X80              Q. ATTACH CALLER AUTHORIZED
         BZ    AUTHOFF                 A. NO- SKIP BIT SETTING
         OI    RBCSFLG1,RBCSSYSR       A. YES- INDICATE FOR FUTURE USE
         SPACE 2
*/* D (NO,AUTHOFF,YES,) ATTACH WITH RESET APF? */
*/* P INDICATE ATTACH WITH RESET (RBCRSAPF=1) */
         SPACE 2
         TM    RBCSDE,X40               ATTACH WITH RESET APF?  @WAB
         BZ    AUTHOFF                  NO-SKIP SETTING BIT     @WAB
         OI    RBCSFLG1,RBCRSAPF        YES-INDICATE FOR FUTURE @WAB
         SPACE 2
*/*AUTHOFF: P (,CDADVANS) COMPLETE RBXSA INITIALIZATION */
         SPACE 2
AUTHOFF  ST    R1,RBCSDE               STORE DE ADDRESS IN XSA
         B     CDADVANS                GO TO LINK MAINLINE
         TITLE '               IEAVLK00 COMMON SUBROUTINES'
*        CDEMERGE COMPLETES PROCESSING FOR LINK,XCTL,LOAD,AND ATTACH.
*        THE WORK AREAS FOR BLDL/FETCH, AND THE DE SAVE SAVES ARE FREED
*        IF PRESENT, THE RESPONSIBILITY COUNT IS INCREMENTED, AND
*        CONTROL PASSES TO CDEPILOG TO PASS CONTROL TO THE NEXT LEVEL
*        OF CONTROL (LINK,XCTL,ATTACH), OR TO CDLDREG FOR FINAL LOAD
*        PROCESSING.
*        REGISTERS ON ENTRY
*              R3,4,5 - CVT,TCB,SVRB
*              R6     - BASE REGISTER
*              R11    - REQUESTED CDE
*              R12    - MAJOR CDE FOR REQUEST
*              OTHER REGISTERS ARE NOT REFERENCED.
*              SVRB EXSAVE FULLY INITIALIZED.
         SPACE 2
*/*CDEMERGE: S CDMOPUP:GO FREE WORK AREAS */
         SPACE 2
CDEMERGE DS    0H
         BAL   RETURND,CDMOPUP         GO FREE WORK AREAS
         SPACE 2
*/* D (YES,CDLDRET,NO,) LOAD REQUEST? */
         SPACE 2
         TM    RBCDFLGS,LOAD           Q. IS A LOAD IN PROCESS
         BO    CDLDRET                 YES-GO DO SPECIAL WORK FOR LOAD
         SPACE
*        APF TEST. IF ATTACHED JOB STEP, AND CDE IS AUTHORIZED, THE
*        BIT IN THE JSCB WILL BE SET TO INDICATE AUTHORIZATION.
         SPACE 2
*/* D (NO,CDEPILOG,YES,) ATTACH REQUEST? */
         SPACE 2
         TM    RBCDFLGS,RBCSATT        Q. IS ATTACH IN PROCESS
         BNO   CDEPILOG                NO - GO TO CDEPILOG
         SPACE 2
*/* D (YES,TSTCDAUT,NO,) JOB STEP ATTACH? */
         SPACE 2
         CLM   TCBREG,MASK,TCBJSTCA    Q. IS IT A JOB STEP ATTACH
         BE    TSTCDAUT                YES GOTO TEST CDE AUTH  @WAB
         SPACE 2
*/* D (NO,CDEPILOG,YES,) ATTACH WITH RESET APF? */
         SPACE 2
         TM    RBCSFLG1,RBCRSAPF        IS ATTACH W/ RESET APF @WAB
         BNO   CDEPILOG                 NO - GO TO RETURN      @WAB
         SPACE 2
*/* L TESTAUTH -- TEST CALLERS APF AUTHORIZATION */
         SPACE 2
         TESTAUTH FCTN=1,BRANCH=YES     CALLER  AUTHORIZED ?   @WAB
         SPACE 2
*/* P RESET CVT POINTER IN CVT REG (R3) */
         SPACE 2
         L     CVTREG,CVTPTR            RESET CVT REGISTER     @WAB
         USING CVT,CVTREG               SET ADDRESSABILITY     @WAB
         SPACE 2
*/* D (NO,TSTCDAUT,YES,) CALLER APF AUTHORIZED ? */
         SPACE 2
         LTR   R15,R15                  CALLER APF AUTHORIZED  @WAB
         BNZ   TSTCDAUT                 NO - TEST CD AUTH      @WAB
         SPACE 2
*/* P (,ABNDSET) INDICATE 306-C ABEND */
         SPACE 2
         SR    R13,R13                  ZERO ABEND CODE REG    @WAB
         LA    R15,BADRETCD             INDICATE RC=X'0C'      @WAB
         OI    RBCSFLG1,RBCSA306        INDICATE 306 ABEND     @WAB
         B     ABNDSET                  GO PROCESS ABEND       @WAB
         SPACE 2
*/*TSTCDAUT: D (NO,CDEPILOG,YES,) CDE AUTHORIZED? */
         SPACE 2
TSTCDAUT TM    CDATTR2,CDAUTH          IS REQUEST AUTHORIZED
         BNO   CDEPILOG                NO SKIP BIT SETTING
         SPACE 2
*/* P (,CDEPILOG) SET JSCB AUTHORIZATION BIT */
         SPACE 2
         L     R15,TCBJSCB             GET JSCB ADDRESS
         LA    R15,N0(R15)             CLEAR HIGH ORDER BYTE
         LTR   R15,R15                 Q. DOES JSCB EXIST
         BZ    CDEPILOG                A. NO- SKIP BIT SETTING
         USING IEZJSCB,R15             SET ADDRESSABILITY
         OI    JSCBOPTS,JSCBAUTH       AUTHORIZE THE JOB STEP
         B     CDEPILOG                GO TO CDEPILOG          @YM08356
         EJECT
*THIS SECTION OF CODE DOES THE FOLLOWING
*
*        1.CREATES THE 'PRB' IN WHICH THE LINKAGE TO AND OPERATION
*          OF A PROGRAM IS RECORDED. HERE THE FOLLOWING IS DONE
*
*              A.USING GETMAIN, 96 BYTES ARE OBTAINED FOR A PRB.
*                THE FIRST 96 BYTES OF THE SVRB ARE DUPLICATED IN THE
*                NEWLY CREATED PRB.
*
*              B.THE SIZE FIELD WILL BE SET TO 13, INDICATING 13
*                DOUBLE WORDS.
*
*              C.THE PRB IS QUEUED BEHIND THE SVRB SO EXIT WILL
*                FREE UP THE SVRB. THE ENTRY POINT OF THE MODULE
*                IS STORED INTO THE RIGHT HALF OF THE PRB'S PSW.
*
*              D.THE RBCDE FIELD IS SET TO POINT TO A CDENTRY, IN SYNCH
*                THE FIELD IS SET TO ZERO.
*
*              E.THE PRB IS MARKED AS A PRB (CURRENTLY REFLECTS SVRB)
*
*              F.A PSW IS STRUCTURED WHICH PROPOGATES THE LEFT 5 BYTES
*               FROM THE PREVIOUS LEVEL OF CONTROL(INDICATED BY AN RB).
*                IF THIS IS THE ONLY CONTROL LEVEL OF THIS TASK,THE
*                SYSTEM MASK IS SET ENABLED,AS IS THE PROGRAM MASK. THE
*                OPERATING STATE (PROBLEM OR SUPERVISOR) AND THE
*                PROTECTION KEY ARE SET ACCORDING TO THEIR VALUES
*                IN THE TCB.  FOR SVC SYNCH THE PSW WILL BE STRUCTURED
*                WITH ALL MASKS ENABLED, ALWAYS IN THE PROBLEM PROGRAM
*                STATE, AND WITH A PROTECTION KEY VALUE ACQUIRED FROM
*                THE TCB.
*
*        2.REGISTERS ARE SET UP AS FOLLOWS
*              A.REGISTER 14 CONTAINS THE ADDRESS OF AN SVC 3
*                INSTRUCTION IN THE CVT.
*              B.REGISTER 15 CONTAINS THE ENTRY POINT OF THE
*                MODULE TO GAIN CONTROL.
*              C.REGISTER 0 MAY BE ALTERED FROM THE TIME THE SVC
*                WAS ISSUED (THIS IS THE CASE WITH XCTL).
*              D.REGISTERS 0 AND 1 ARE ALTERED BY THE LOAD USER
*                MACRO. XCTL AND LINK MAINTAIN REGISTER 1 INTACT.
*              E.REGISTERS 2-13 ARE THE SAME AS WHEN THE SVC WAS
*                ISSUED.
*
*        3.EXIT MOVES REGISTERS 2-24 INTO THE TCB AND FREES THE SVRB.
*          REGISTERS 0,1, AND 15 ARE PUT INTO THE TCB
*          CONTAINING THE VALUES AT THE TIME THE EXIT PROLOGUE
*          WAS ISSUED IN IEAVLK00.
*
*        4.THE DISPATCHER WILL LATER DO A LOADPSW FROM THE
*          NEWLY CREATED PRB TO GIVE CONTROL TO THE MODULE.
         SPACE 2
*/*IEAQCS03: E ENTRY IEAQCS03 */
         SPACE 2
IEAQCS03 DS    0H                      FINAL LINK,XCTL,ATTACH PROCESS
         SPACE 2
*/*          L SETLOCK-- OBTAIN LOCAL LOCK */
*/*          L SETFRR-- INITIALIZE RECOVERY ROUTINE */
         SPACE 2
         LR    R7,R11                  SAVE R11 ACROSS SETLOCK @YM08356
         LR    R1,R12                  SAVE R12 ACROSS SETLOCK @YM08356
         SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,RELATED=NO      @YM08356
         LR    R11,R7                  RESTORE R11             @YM08356
         LR    R12,R1                  RESTORE R12             @YM08356
         SETFRR A,FRRAD=FRRPGM,WRKREGS=(R1,R15),PARMAD=(R13)   @YM08356
         ST    RBREG,N0(R13)           SAVE SVRB PTR FOR FRR   @YM08356
         ST    R13,RBCSFRRA            SAVE FRR PARM AREA      @YM08356
         SPACE 2
*/*CDEPILOG: P GET ENTRY POINT ADDRESS */
*/* P SET NFN (NOT FUNCTION ALIVE) BIT */
CDEPILOG L     SUBREG1,CDENTPT         PICK UP ENTRY POINT ADDRESS.
         OI    CDATTR,CDNFN            SET NFN .. IF PROGRAM
*                                      IS REENTRABLE OR SERIALLY
*                                      REUSABLE, BIT IS INSIGNIFICANT
         SPACE 2
*/* D (YES,XCTLEXIT,NO,) XCTL REQUEST? */
         SPACE 2
         TM    RBCDFLGS,XCTL           XCTL REQUESTED GO TO
         BO    XCTLEXIT                DO SPECIAL XCTL EXIT PROCESSING
         SPACE
*        THE FOLLOWING SECTION OF CODE GETS 96 BYTES OF MAIN STORAGE TO
*        CREATE AND INITIALIZE A PRB. A PSW IS BUILT WHICH WILL BE
*        LOADED BY THE DISPATCHER TO ENTER THE ROUTINE REQUESTED. AN
*        EXIT IS TAKEN WHICH CAUSES THE SVRB TO BE FREED UP, AND
*        CONTROL TO BE GIVEN TO THE PRB WHICH WAS JOST CREATED.
         SPACE 2
*/*THRUX: P SET UP FOR GETMAIN */
*/* L GETMAIN-- BRANCH MACRO 160 BYTE PRB FROM 255 */
         SPACE 2
THRUX    DS    0H                      SYNCH FINAL PROCESS ENTRY
         L     ASCBREG,PSAAOLD         GET ASCB ADDRESS
         LR    PRBREG,GR14             SAVE EP ADDRESS
         GETMAIN RU,LV=PRBSIZE,SP=255,BRANCH=YES GET PRB AREA
         LA    GR14,N0(PRBREG)         RESTORE SAVED REG. AND
*                                      CLEAR HIGH BYTE FOR STORE
         SPACE 2
*/* P CLEAR PREFIX AREA */
*/* P GET START OF BASE PRB */
         SPACE 2
         XC    ZERO(PRBPREF,R1),ZERO(R1) CLEAR PRB PREFIX AREA
         LA    PRBREG,PRBPREF(R1)      ADD PREFIX SIZE TO ADDRESS
*                                      FOR PRB START
         SPACE
*        INITIALIZATION OF PRB
         SPACE 2
*/* P MOVE 96 BYTES FROM SVRB TO PRB */
*/* P NOTE: THIS SETS REGS AT TIME OF SVC IN PRB REG SAVE AREA FOR TRRM
*/* */
*/* P SET PRB SIZE TO 13 DOUBLE WORDS */
*/* P QUEUE PRB BEHIND SVRB */
*/* P INSURE TCBNEXT IS OFF IN OLD ATTN OFF IN NEW */
*/* P MAKE NEW RB TYPE = PRB */
         SPACE 2
         MVC   PRBSTART(PRBSIZ),RBSECT MOVE 96 BYTES FROM SVRB TO PRB
*                                      FIRST BYTE OF SIZE ZERO
         MVI   PRBSIZE1+N1,PRBWDLEN     SET SIZE=13 DBL WORDS
         ST    PRBREG,RBWCF            POINT SVRB TO PRB, WHEN EXIT IS
*                                      TAKEN BY SVRB PRB IS STARTED.
         NI    RBSTAB2,MAX-RBTCBNXT    GUARENTEE TCBNXT FLAG OFF IN OLD
         NI    PRBSTAB2,MAX-RBATTN     GUARENTEE ATTN BIT OFF IN NEW
         NI    PRBSTAB,PRBX            MAKE NEW RB RECOGNIZABLE AS PRB
         SPACE
*        INITIALIZE PSW WITHIN PRB FOR ENTRY TO ROUTINE
         SPACE 2
*/* P PUT ENTRY POINT IN RBOPSW */
*/* P PUT PREFORMATTED PSW IN LEFT HALF RBOPSW */
         SPACE 2
         ST    SUBREG1,PRBOPSW+WORD    STORE ENTRY POINT IN PSW
         MVC   PRBOPSW(PSWBASE),FRAMPSW MOVE 5 FORMATTED BYTES TO PSW
         STNSM PRBOPSW,MAX             SET MASK FIELD OF PSW
         SPACE 2
*/* D (YES,SYNCTEST,NO,) SYNCH REQUEST? */
         SPACE 2
         TM    RBCDFLGS,SYNC           Q.TEST TYPE OF SVC REQUEST
         BO    SYNCTEST                IF SVC SYNCH, TAKE BRANCH
         SPACE 2
*/* P PUT CDE ADDRESS IN PRB */
*/* P INITIALIZE PRBFLGS TO 0 */
*/* P PUT PRB ADDRESS IN CDE */
         SPACE 2
         ST    CDEREG,PRBFLGS          OTHERWISE  STORE CDENTRY ADDR IN
*                                      PRB.
         MVI   PRBFLGS,ZERO            INITIALIZE FLAGS TO ZERO
         ST    PRBREG,CDRBPJ           STORE PRB ADDR IN CDE
         SPACE 2
*/* D (YES,PSWSET,NO,) DOES PREVIOUS RB POINT TO TCB? */
         SPACE 2
         L     WKREG1,PRBWCF           PICK UP ADDR OF PREV. CTL LEVEL
         CR    TCBREG,WKREG1           Q. DOEA RB POINT TO TCB
         BE    PSWSET                  A.=YES,TAKE BRANCH
         SPACE 2
*/* P (,SYNCR) PUT OLD RBOPSW IN NEW */
         SPACE 2
         MVC   PRBOPSW(PSWBASE),RBOPSWZ(WKREG1) MOVE IN OLD PSW FLAGS
         B     SYNCR                   CONTINUE PROCESSING
         SPACE 2
*/*PSWSET: D (NO,SYNCROUT,YES,) TASK PRIVILEGED? */
*/* P TURN ON PRIVILIGED MODE */
         SPACE 2
PSWSET   TM    TCBFLGS3,TCBFSM         Q. DOES TASK OPERATE PRIVILEGED
         BZ    SYNCROUT                A=NO, TAKE BRANCH
         NI    PRBOPSW+N1,XFE          PRIVIVEGED MODE OPERATION
         SPACE 2
*/*SYNCROUT: P SET TCB KEY IN PSW */
         SPACE 2
SYNCROUT OC    PRBOPSW+N1(N1),TCBPKF   SET PROTECT KEY VALUE FROM TCB
         SPACE 2
*/*PICAMASK: D (NO,SYNCR,YES,) PIE EXIST? */
         SPACE 2
PICAMASK DS    0H                      TEST FOR PIE/PICA
         SR    PIEREG,PIEREG           CLEAR PIE REG BEFORE TEST M01978
         ICM   PIEREG,MASK,TCBPIE+N1   PICK UP PIE ADDRESS
         BZ    SYNCR                   IF NO PIE, EXIT
         SPACE 2
*/* P SET PARAMETER CHECK FLAG */
*/* P GET ADDR OF PIE ADDR */
*/* P GET ADDR OF PICA FROM PIE */
         SPACE 2
         OI    RBCSFLG1,RBCSPARM       TURN ON PARM CHECK FLAG   M01978
         L     PIEREG,N0(PIEREG)       GET POINTER TO PIE
         LTR   PIEREG,PIEREG           Q. PIE PRESENT
         BZ    SYNCR                   A. NO- FINISH PROCESSING
         L     PICAREG,N0(PIEREG)      GET PICA ADDRESS
         SPACE 2
*/* D (NO,SYNCR,YES,) PICA EXIST? */
         SPACE 2
         LTR   PICAREG,PICAREG         Q. PICA PRESENT
         BZ    SYNCR                   A. NO- FINISH PROCESSING
         SPACE 2
*/*PICAMOVE: P PUT PGM MASK IN PRB FROM PICA */
         SPACE 2
PICAMOVE MVC   PRBOPSW+N2(N1),ZERO(PICAREG) A. YES-MOVE IN PROGRAM MASK
         NI    PRBOPSW+N2,MASK4        CLEAR VOID HALF OF MASK   M00349
         SPACE 2
*/*SYNCR: P GET CALLER'S ENTRY POINT IN REG 15 */
*/* P TURN OFF PARM CHECK FLAG */
*/* P STORE ADDRESS OF SVC 3 IN REG 14 */
*/* P LOAD REG 0 AND REG 1 FROM RBGRSAV */
         SPACE 2
SYNCR    LR    R15,SUBREG1             SET R15 TO THE ENTRY POINT ADDR
         NI    RBCSFLG1,MAX-RBCSPARM   TURN OFF PARM CHECK FLAG  M01978
         L     CVTREG,CVTPTR           GET ADDRESS OF CVT
         USING CVT,CVTREG              SET ADDRESSIBILITY
         LA    R14,CVTEXIT             GET ADDR OF EXIT INSTRUCTION
         ST    R14,RBGRS14             PLACE IN SVRB R14 SLOT
         LM    R0,R1,RBGRSAVE          RESTORE REGS 0 AND 1
         SPACE 2
*/*SVCEXIT: P GET ADDR OF SVC EXIT PROLOGUE IN REG 14 */
*/* L SETFRR-- REMOVE RECOVERY ROUTINE */
*/* R EXIT VIA BR 14 */
         SPACE 2
SVCEXIT  L     R14,CVTEXPRO            GET ADDR OF EXIT PROLOGUE
         SETFRR D,WRKREGS=(R7,R8)      REMOVE RECOVERY RTN.
         BR    R14                     EXIT
         SPACE 2
*/*SYNCTEST: D (NO,SYNCROUT,YES,) ASIR REQUESTOR? */
*/* P TURN OFF ASIR BIT IN TCB */
         SPACE 2
SYNCTEST TM    TCBSTAB,TCBSYNCH        Q. STAE REQUEST
         BZ    SYNCROUT                A=NO TAKE BRANCH
         NI    TCBSTAB,MAX-TCBSYNCH    TURN OFF STAE-SUP BIT
         SPACE 2
*/* D (NO,PPMODE,YES,) REQUESTOR IN SUPER MODE? */
*/* P SET SUPERVISOR MODE BIT */
         SPACE 2
         TM    TCBNSTAE,TCBPPSUP       SUPERVISOR REQUEST
         BZ    PPMODE                  NO- LEAVE IN PROBLEM MDOE
         NI    PRBOPSW+N1,XFE          YES-TURN OFF PSW PROB. MODE BIT
         SPACE 2
*/*PPMODE: P (,PICAMASK) SET KEY IN PSW FROM TCB (TCBSCBKY) */
         SPACE 2
PPMODE   OC    PRBOPSW+N1(N1),TCBSCBKY PUT REQUESTED KEY IN PSW
         B     PICAMASK                CONTINUE
         SPACE 2
*/*XCTLEXIT: P PUT ENTRY POINT IN PRB RBOPSW */
*/* P PUT CDE ADDRESS IN PRB */
*/* P (,SYNCR) PUT RB ADDRESS IN CDE */
         SPACE 2
XCTLEXIT L     PRBREG,RBWCF            GET NEW PRB
         ST    SUBREG1,PRBOPSW+WORD    STORE ENTRY POINT IN PSW
         LA    CDEREG,N0(CDEREG)       CLEAR HIGH ORDER BYTE OF CDE
         LR    R15,R14                 PUT EP ADDRESS IN OUTPUT REG
         ST    CDEREG,PRBFLGS          PUT CDE POINTER IN PRB
         ST    PRBREG,CDRBPJ           STORE RB POINTER IN CDE
         B     SYNCR                   TERMINATE XCTL PROCESSING
         SPACE
*        AS A RESULT OF ISSUEING EXIT THE SVRB WILL BE FREE UP AND
*        CONTROL IS GIVEN TO THE PREVIOUS PRB. THE ROUTINE IS ENTERED
*        AS FOLLOWS - R0 = ZERO
*              R1 = SAME AS WHEN SVC ISSUED
*              R2-13 SAME AS WHEN SVC ISSUED
*              R14 = ADDRESS OF AN SVC EXIT INSTRUCTION
*              R15 = ENTRY POINT ADDRESS
         EJECT
*        THIS ROUTINE INITIALIZES R9 TO THE ADDRESS OF THE REQUESTED
*        NAME, R10 TO THE ADDRESS OF THE DCB PASSED, AND INITIALIZED
*        ALL FIELDS IN THE SVRB EXTENDED SAVE AREA.  IF A DE WAS
*        PASSED BY THE USER, IT IS SAVED IN A NON-PAGEABLE AREA
*        OBTAINED VIA GETMAIN.  DALPRFIX EXPECTS INPUT IN REGISTERS 0
*        AND 1, WHILE LXPREFIX EXPECTS INPUT PASSED IN A PARAMETER LIST
*        WHOSE ADDRESS IS IN REGISTER 15. REGISTERS 4,5,6 AND 13 ARE
*        PRESERVED OVER THE ROUTINE. ALL OTHER REGISTERS ARE CHANGED.
*        206 ABENDS ARE ISSUED FOR RECOGNIZABLE ERRORS. (SEE LINK
*        PROLOGUE FOR CONDITIONS)
*    CHANGES FOR PTM VS01651 IN PREFIX ROUTINES
*
         SPACE 2
*/*LXPREFIX: E LXPREFIX */
*/* P TURN ON PARAMETER CHECK FLAG IN RBCSFLG1 */
*/* P PUT INPUT PARAMETER LIST IN WORK REGISTER */
         SPACE 2
LXPREFIX DS    0H
         USING PDS2,NAMEREG            SET ADDRESSABILITY ON DE
         OI    RBCSFLG1,RBCSPARM       TURN ON PARM CHECK FLAG
         LR    R12PARM,R15             POINT PARM REG TO PARM LIST FOR
         SPACE 2
*/* L TESTAUTH-- GET CALLER'S AUTHORIZATION */
         SPACE 2
         TESTAUTH KEY=YES,STATE=YES,BRANCH=YES GET STATUS OF CALLER
         SPACE 2
*/* D (NO,USERKEY,YES,) CALLER AUTHORIZED? */
         SPACE 2
         LTR   R15,R15                 Q. CALLER AUTHORIZED
         BNZ   USERKEY                 A. NO - VALIDITY CHECK INPUT
         SPACE 2
*/* P (,LISTCHK) SET AUTHORIZED CALLER FLAG */
         SPACE 2
         OI    RBCSFLG1,RBCSSYSR       A. YES- TURN ON SYSTEM REQUEST
         B     LISTCHK                 GET PARAMENTER IN REGS
         SPACE 2
*/*USERKEY: P PUT A REASON CODE OF 1 IN REG. 15 */
*/* L MODESET-- GO TO USER KEY */
         SPACE 2
USERKEY  LA    R15,N1                  SET REASON CODE
         MODESET EXTKEY=TCB,WORKREG=2  GO TO TCB KEY
         SPACE 2
*/*LISTCHK: P PUT EP/DE ADDRESS IN REG 9 (NAMEREG) */
         SPACE 2
LISTCHK  L     NAMEREG,N0(R12PARM)     GET NAME OR DE
         SPACE 2
*/* P PUT DCB ADDRESS IN REG 10 (DCBREG) */
         SPACE 2
         L     DCBREG,FOUR(R12PARM)    PUT DCB ADDR IN REG
         SPACE 2
*/* D (NO,LXPRFIX0,YES,) THERE IS A THIRD PARAMETER? */
         SPACE 2
         LTR   DCBREG,DCBREG           Q. IS THERE A THIRD PARM.
         BNM   LXPRFIX0                A. NO- CONTINUE
         SPACE 2
*/* P GET ERROR RETURN ADDRESS IN WORK REG */
*/* L MODESET-- RETURN TO KEY 0 */
*/* P STORE ERROR RETURN ADDRESS IN RBXSA */
*/* P (,LXPRFIX0) TURN ON RETURN REQ'D BIT IN RBCSFLG1 */
         SPACE 2
         L     WKREG1,EIGHT(R12PARM)   A. YES- GET ERROR ADDRESS
         MODESET EXTKEY=SUPR           RETURN TO SUPERVISOR KEY
         ST    WKREG1,RBCSERRA         SAVE IT IN XSA
         OI    RBCSFLG1,RBCSERIN       TURN ON RETURN REQUESTED FLAG
         B     LXPRFIX0                CONTINUE
         SPACE 2
*/*DALPRFIX: E DALPRFIX */
*/* P TURN ON PARAM. CHECK FLAG IN RBCSFLG1 */
*/* P GET ADDR OF NAME IN REG 9 FROM REG 0 */
*/* P SET REG 9 NEGATIVE IF DE FORM */
         SPACE 2
DALPRFIX DS    0H                      PARAMETER PREFIXING
         OI    RBCSFLG1,RBCSPARM       TURN ON PARM CHECK FLAG
         LPR   NAMEREG,R0              GET DE-NAME INTO PROPER REG
*                                      PASSED IN COMPLEMENTED FORM
         LA    NAMEREG,ZERO(NAMEREG)   CLEAR FLAG BYTE IN NAMEREG
         N     R0,HIBYTE               CLEAR ADDRESS PART OF REG
         OR    NAMEREG,R0              PUT FLAGS IN PROPER REG
         SR    R12PARM,R12PARM         INDICATE PARAMETERS PASSED IN
*                                      REGISTERS AND NOT IN LIST
         SPACE 2
*/* P GET ADDR OF DCB IN REG 10 FROM REG 1 */
*/* D (NO,LXPRTEST,YES,) IS RETURN REQUESTED? */
         SPACE 2
         LA    DCBREG,N0(R1)           PUT DCB IN PROPER REG
         LTR   R1,R1                   Q. RETURN REQUESTED
         BNM   LXPRTEST                A. NO- CONTINUE
         SPACE 2
*/* P TURN ON RETURN REQ'D BIT IN RBCSFLG1 */
         SPACE 2
         OI    RBCSFLG1,RBCSERIN       A. YES- TURN ON RET. REQUEST FLG
         SPACE 2
*/*LXPRTEST: L TESTAUTH-- GET CALLER'S AUTHORIZATION */
         SPACE 2
LXPRTEST TESTAUTH KEY=YES,STATE=YES,BRANCH=YES GET STATUS OF CALLER
         SPACE 2
*/* D (NO,LXPRFIX0,YES,) CALLER AUTHORIZED? */
         SPACE 2
         LTR   R15,R15                 Q. CALLER AUTHORIZED
         BNZ   LXPRFIX0                A. NO - VALIDITY CHECK INPUT
         SPACE 2
*/* P  SET AUTHORIZED CALLER FLAG */
         SPACE 2
         OI    RBCSFLG1,RBCSSYSR       A. YES- TURN ON SYSTEM REQUEST
*                                      FLAG
         SPACE 2
*/*LXPRFIX0: L MODESET-- INSURE KEY 0 PRECESSING */
*/* P COMPLEMENT DCB ADDR IN REG 10 TO INDICATE DCB NOT
*/*CHECKED */
         SPACE 2
LXPRFIX0 DS    0H                      COMMON CODE FOR BOTH TYPES OF
*                                      PASSED PARAMETERS
         MODESET EXTKEY=SUPR           INSURE SYSTEM KEY
         LA    DCBREG,ZERO(DCBREG)     CLEAR HIGH ORDER BYTE OF ADDR
         LNR   DCBREG,DCBREG           INDICATE DCB NOT YET CHECKED
         SPACE 2
*/* P SET DE SAVE AREA ADDRESS = 0 */
         SPACE 2
         SR    DESZREG,DESZREG         INDICATE DE SIZE NOT CALCULATED
         SR    DESVREG,DESVREG         INDICATE DE SAVE AREA NOT YET
*                                      OBTAINED
         SPACE 2
*/* D (YES,DECHK,NO,) IS THIS A SYSTEM REQUEST? */
         SPACE 2
         TM    RBCSFLG1,RBCSSYSR       THIS A SYSTEM REQUEST
         BO    DECHK                   YES- GO TO DECHK
         SPACE 2
*/* P SET REASON CODE TO 2 */
*/* L MODESET-- GO TO USER KEY */
*/* P ACCESS USER DATA TO DETERMINE IF OWNED BY USER */
*/* L MODESET-- RETURN TO KEY 0 */
         SPACE 2
         LA    R15,N2                  SET REASON CODE
         MODESET EXTKEY=TCB,WORKREG=2  GO TO USER KEY
         LM    R0,R1,N0(NAMEREG)       ACCESS USER DATA
         MODESET EXTKEY=SUPR           RETURN TO KEY 0
         SPACE 2
*/*DECHK: D (NO,LXPRFIX6,YES,) DE SPECIFIED? */
         SPACE 2
DECHK    LTR   NAMEREG,NAMEREG         CHECK FOR DE FORM
         BNM   LXPRFIX6                IF NOT DE TO TO FINAL PREFIX
*                                      PROCESSING
         SPACE 2
*/* P GET LENGTH OF DE IN HALFWORDS */
*/* P DOUBLE LENGTH TO OBTAIN NUMBER OF BYTES */
*/* P ADD LENGTH OF BASIC SECTION */
         SPACE 2
         LA    ASCBREG,X1F             PREPARE TO GET LENGTH OF DE
         IC    DESZREG,PDS2INDC        GET BYTE CONTAINING LENGTH
         NR    DESZREG,ASCBREG         CLEAR THE HIGH 3 BITS
         LA    DESZREG,PDS2USRD-PDS2(DESZREG,DESZREG)  DOUBLE SIZE
*                                      (WAS HALF WORDS-NOW BYTES) AND
*                                      ADD BASIC SIZE
         SPACE 2                                               @OZ02572
*/* P SET REASON CODE TO 3 IN R15 - IN CASE OF 206 ABEND */    @OZ02572
         SPACE 2                                               @OZ02572
         LA    R15,THREE               SET REASON CODE         @OZ02572
         SPACE 2
*/* D (YES,DELENCK,NO,) SYSTEM REQUEST? */                     @OZ02572
         SPACE 2
         TM    RBCSFLG1,RBCSSYSR       Q. SYSTEM REQUEST
         BO    DELENCK                 A. YES- NO VALIDITY CK  @OZ02572
         SPACE 2
*/* L MODESET-- GO TO USER KEY */
*/* P ACCESS FIRST WORD OF USER DATA */
*/* P ACCESS LAST WORD OF USER DATA */
*/* L MODESET-- RETURN TO KEY 0 */
         SPACE 2
         MODESET EXTKEY=TCB,WORKREG=2  GO TO USER KEY
         L     R1,N0(NAMEREG)          ACCESS FIRST WORD
         LR    R2,R9                   SET UP TO CALCULATE
         AR    R2,R8                   LENGTH OF END OF ENTRY
         BCTR  R2,N0                   SUBTRACT ONE TO CHECK
*                                      USER CORE ONLY
         IC    R1,N0(R2)               ACCESS LAST WORD
         MODESET EXTKEY=SUPR           RETURN TO KEY 0
         SPACE 2                                               @OZ02572
*/*DELENCK: D (YES,GETDSAV,NO,) DE TOTAL LENGTH LE 60 BYTES?*/ @OZ02572
*/* P SET ABEND CODE REG(R13) TO ZERO */                       @OZ02572
*/* P (,ERRPARM) GO TO PROCESS 206 ABEND */                    @OZ02572
         SPACE 2                                               @OZ02572
DELENCK  LA    R7,DESIZE-FOUR          GET MAX DE LENGTH       @OZ02572
         CR    R8,R7                   CHECK USER'S LENGTH     @OZ02572
*                                      AGAINST MAX DE LENGTH   @OZ02572
         BNH   GETDSAV                 LENGTH OK- GET SAVEAREA @OZ02572
         LR    R8,R7                   SET LENGTH OF DE TO MAX @ZA10799
         SPACE 2
*/*GETDSAV: L GETMAIN-- GET 64 BYTE MAX DE SAVE AREA FROM SP=255 */
         SPACE 2
GETDSAV  L     ASCBREG,PSAAOLD         GET ASCB FOR GM
         GETMAIN RU,LV=DESIZE,SP=255,BRANCH=YES  GET SAVE AREA FOR DE
         LA    DESVREG,N0(R1)          INITIALIZE POINTER TO DE SAVE
*                                      AREA AND PROVIDE
         USING DESAVE,DESVREG          ADDRESSABILITY
         SPACE 2
*/* P MOVE DE TO DE SAVE AREA+4 (SECOND WORD) */
*/* P PUT DE LENGTH IN FIRST WORD OF DE SAVE */
         SPACE 2
         BCTR  DESZREG,ZERO            CORRECT FOR EXECUTE
         EX    DESZREG,MOVEDE          MOVE THE DE INTO THE SAVE AREA
         ST    DESZREG,DESAVESZ        SAVE THE SIZE OF THE DE
         SPACE 2
*/*LXPRFIX6: P MOVE NAME TO RBXSA AND POINT REG 9 TO THIS NAME */
         SPACE 2
LXPRFIX6 DS    0H                      FINAL PREFIX PROCESSING
         LA    R15,TWO                 SET REASON CODE FOR FAILURE
         MVC   RBCSNAME(NAME),ZERO(NAMEREG) MOVE NAME INTO EXSA
         LA    NAMEREG,RBCSNAME        SET UP NAME POINTER, NOT LONGER
*                                      CONTAINS DE FLAG, MUST USE
*                                      DE SAVE AREA POINTER IN EXSA
*                                      TO DETERMINE IF DE EXISTS
         SPACE 2
*/* P INITIALIZE REMAINING FIELD OF XSA TO 0 */
*/* P PUT ADDRESS OF DESAVE AREA IN XSA */
*/* P CLEAR PARAMETER CHECK FLAG */
*/* R RETURN VIA BR 13 */
         SPACE 2
         XC    RBCSWORK(CLRSIZE),RBCSWORK CLEAR ALL OTHER FIELDS AND
*                                      FLAGS TO ZERO
         ST    DESVREG,RBCSDE          SAVE DE SAVE AREA ADDRESS IN XSA
         NI    RBCSFLG1,MAX-RBCSPARM   TURN OFF PARM CHECK FLAG
         BR    RETURND                 RETURN TO CALLER
*        THE NEXT INSTRUCTION IS EXECUTED BY DALPRFIX
MOVEDE   MVC   DESAVEDE(ZERO),PDS2     MOVE DE TO SAVE AREA
         EJECT
*        SUBROUTINE CDSEARCH SEARCHES A CDE QUEUE FOR A PARTICULAR
*        MODULE NAME.  A CDE ADDRESS IS RETURNED, IF FOUND.  A BRANCH
*        TABLE RETURN IS UTILIZED BASED ON FOUND OR NOT FOUND.
*        REGISTERS USEAGE
*              R0 - SET TO LEFT HALF OF NAME (OUTPUT)
*              R1 - SET TO RIGHT HALF OF NAME (OUTPUT)
*              R8 - ADDRESS OF CDE QUEUE TO SEARCH (INPUT)
*              R9 - ADDRESS OF NAME TO SEARCH FOR (INPUT)
*              R11- ADDRESS OF FOUND CDE, OR 0 (OUTPUT)
*              R14- RETURN ADDRESS (INPUT)
*              R15- MODIFIED BY CDSEARCH
*              ALL OTHER REGISTERS NOT REFERENCED.
*
*        RETURN ON R14 + 0 IS SUCCESSFUL   - MODULE FOUND
*        RETURN ON R14 + 4 IS UNSUCCESSFUL - MODULE NOT FOUND.
*
         SPACE 2
*/* E IEAQCDSR/ CDSEARCH */
*/* P GET ADDRESS OF FIRST CDE FROM LIST SPECIFIED */
*/* P PUT INPUT NAME IN WORK REGS */
*/*CONTSRCH: P GET FIRST /NEXT CDE */
*/* D (YES,%RET4,NO,) END OF CDE QUEUE? */
*/* D (YES,,NO,CONTSRCH) FIRST HALF OF NAMES EQUAL? */
         SPACE 2
IEAQCDSR DS    0H                      EXTERNAL ENTRY FOR CDSEARCH
CDSEARCH LR    CDEREG,TABREG           START SEARCH FROM LIST ORIGIN
*                                      OF CONTROL QUEUE SPECIFIED
         LM    WKREG0,WKREG1,SYMBEGIN(NAMEREG) LOAD NAME INTO REGS
         SPACE
*        LOOP STARTS HERE
         SPACE
CONTSRCH BALR  SUBREG2,ZERO            SET UP LOOP ADDR
         L     CDEREG,CDCHAIN          LOAD CDEREG,TEST FOR ZERO
         LTR   CDEREG,CDEREG           END OF CHAIN
         BZ    WORD(SUBREG1)           A= YES TAKE BAD EXIT
         C     WKREG0,CDNAME           Q. IS FIRST HALF OF NAME EQUAL
         BCR   NOTEQ,SUBREG2           A= NO, TAKE BRANCH
         SPACE
*        ONLY IF THE FIRST HALF OF THE NAMES ARE EQUAL WILL
*        WE ENTER THIS
*/* D (YES,,NO,CONTSRCH) SECOND HALF OF NAMES EQUAL? */
         SPACE 2
         C     WKREG1,CDNAME+FOUR      Q. IS 2ND HALF EQUAL
         BCR   NOTEQ,SUBREG2           A= NO, TAKE BRANCH
         BR    SUBREG1                 BOTH NAMES EQUAL, RETURN SUCC.
         SPACE 2
*/* R RETURN REG 14+0 */
*/*%RET4: R RETURN REG 14+4 */
         EJECT
*        CDALLOC IS A SUBROUTINE OF LINK AND LOAD WHICH INTERROGATES
*        THE ATTRIBUTES OF A CDE (FOUND BY CDSEARCH), AND THE SVRB
*        FOR THE REQUEST.  RETURN IS MADE TO SEVEN DIRRERENT POINTS
*        DEPENDING ON THE SETTINGS FOUND.  A BRANCH TABLE IS SET UP
*        FOR FIVE OF THE RETURNS, THE OTHER TWO EXITS BEING A BRANCH
*        TO IEAVLK01, AND TO THE ABEND EXIT ROUTINE.  THE SEVEN EXITS
*        AND THEIR CONDITIONS ARE
*              1.RETURN ON R15 + 0: MODULE CANNOT BE REUSED.
*                   BECAUSE THIS IS A LOAD REQUEST (RBCDLOAD=1),
*                        MODULE IS IN CORE (CDNIC=0),
*                        THE MODULE IS LOADABLE ONLY (CDNLR=0),
*                        THE MODULE IS NOT REUSABLE (CDREN=0,CDSER=0)
*
*              2.RETURN ON R15 +4: MODULE CAN BE USED NOW
*                   A.BECAUSE MODULE IN CORE (CDNIP=0),
*                        MODULE REUSABLE (CDREN=0,CDSER=1),
*                        MODULE NOT LOADABLE ONLY (CDNLR=1),
*                        THIS IS A LOAD REQUEST (RBCDLOAD=1)
*                   B.BECAUSE MODULE IN CORE (CDNIC=0),
*                        MODULE REENTRANT (CDREN=1,CDSER=1),
*                        MODULE NOT LOAD ONLY (CDNLR=1)
*                   C.BECAUSE MODULE IS IN CORE (CDNIC=0),
*                        MODULE IS REUSABLE (CDREN=0,CDSER=1),
*                        MODULE IS NOT LOADABLE ONLY (CDNLR=1),
*                        THIS IS NOT LOAD REQUEST (RBCDLOAD=0),
*                        MODULE NOT IS USE (CDRRBP=0)
*                   D.BECAUSE MODULE IS IN CORE (CDNIC=0),
*                        MODULE IS LOADABLE ONLY (CDNLR=0),
*                        THIS IS LOAD REQUEST (RBCDLOAD=1),
*                        MODULE IS REENTRANT OR REUSABLE (CDSER=1)
*                   E.BECAUSE MODULE IS IN CORE (CDNIC=0),
*                        MODULE IS NOT REUSABLE (CDREG=0,CDSER=0),
*                        MODULE IS NOT LOADABLE ONLY (CDNLR=1),
*                        THIS IS A LOAD REQUEST (RBCDLOAD=1),
*                        LOADED BY AOS LOADER (CDSQA=1),
*                        USE COUNT=0 (CDUSE=0)
*                   F.BECAUSE MODULE IS IN CORE (CDNIC=0),
*                        MODULE IS NOT REUSABLE (CDREG=0,CDSER=0),
*                        MODULE IS NOT LOADABLE ONLY (CDNLR=1),
*                        MODULE IS NOT USED (CDNFN=0),
*                        THIS IS NOT A LOAD REQUEST (RBCDLOAD=0)
*
*              3. REUTN ON R15 +8: MODULE CANNOT BE USED
*                   BECAUSE MODULE IS IN CORE (CDNIC=0),
*                        MODULE IS NOT REUSABLE (CDREN=0,CDSER=0),
*                        MODULE WAS USED (CDNFN=1),
*                        THIS IS NOT A LOAD REQUEST (RBCDLOAD=0)
*
*              4. RETURN ON R15 + 12: SERIAL REUSABLE BUT IN USE
*                   BECAUSE MODULE IN CORE (CDNIC=0),
*                        MODULE REUSABLE (CDREN=0,CDSER=1),
*                        NOT LOADABLE ONLY (CDNLR=1),
*                        NOT LOAD (RBCDLOAD=0),
*                        IN USE (CDRRBP NOT ZERO)
*
*              5. RETURN ON R15 + 16: MODULE IN FETCH
*                   BECAUSE CDNIC=1.
*
*              6. CDSETUP1 - ISSUE BLDL/FETCH
*                   A.BECAUSE MODULE IN CORE (CDNIC=0),
*                        MODULE NOT REUSABLE (CDREN=0,CDSER=0),
*                        MODULE NOT LOADABLE ONLY (CDNLR=1),
*                        THIS IS LOAD REQUEST (RBCDLOAD=1),
*                        THIS IS NOT AOS LOADER (CDSPZ=0)
*                   B.BECAUSE MODULE IS IN CORE (CDNIC=0),
*                        MODULE IS NOT REUSABLE (CDREN=0,CDSER=0),
*                        MODULE IS NOT LOADABLE ONLY (CDNLR=1),
*                        THIS IS LOAD REQUEST (RBCDLOAD+1),
*                        MODULE LOADED BY OSLOADER (CDSPZ=1),
*                        MODULE WAS USED (CDUSE NOT ZERO)
*
*              7. ABEND 406: NOT LOAD FOR A LOADABLE ONLY MODULE.
*
*        REGISTER USAGE
*              R5 - SVRB (INPUT)
*              R6 - BASE ADDRESS (INPUT)
*              R11- CDE FOR REQUEST (INPUT)
*              R12- MAJOR CDE (OUTPUT)
*              R13- ZEROED FOR 406 ABEND (OUTPUT)
*              R15- RETURN REGISTER (INPUT) - POINTS TO A BRANCH TABLE
*              R0,1- WORK REGISTERS, BUT ARE PRESERVED ON RETURN R15+8
*              OTHER REGISTERS NOT REFERENCED
*
*              CDNFN BIT IS SET FOR FIRST USE ON NON REUSABLE MODULE.
         SPACE
         USING ALLOC,SUBREG2           BRANCH TABLE ADDRESSABILITY
         SPACE 2
*/*CDALLOC: E CDALLOC */
*/* P SET ADDR OF MAJOR CDE (REG 12) = INPUT CDE (REG 11) */
*/* D (NO,MINSKIP,YES,) IS INPUT CDE A MINOR? */
*/* P GET ADDRESS OF MAJOR FROM MINOR */
         SPACE 2
CDALLOC  LR    CDIREG,CDEREG           THE ATTRIBUTES OF THE MAJOR
*                                      ENTRY ARE NEEDED,LOAD MAJOR.
         TM    CDATTR,CDMIN            Q. IS THIS CDENTRY A MINOR
         BZ    MINSKIP                 A= NO, TAKE BRANCH
         L     CDIREG,CDXLMJP          IF YES LOAD ADDRESS OF MAJOR
         SPACE 2
*/*MINSKIP: D (NO,%CONT,YES,) IS MAJOR BEING LOADED NOW? */
*/* R RETURN VIA REG 15+16 */
         SPACE 2
MINSKIP  TM    CDATTRJ,CDNIC           Q. IS THE LOAD MODULE IN MAIN
*                                      STORAGE, BIT IS SET WHILE FETCH
*                                      OF MODULE TAKES PLACE.
         BO    RETURN5                 RET5 NO, MODULE NOT IN,BRANCH
         SPACE 2
*/*%CONT: D (NO,TSTATTR,YES,) IS THIS A SYSTEM REQUEST? */
         SPACE 2
         TM    RBCSFLG1,RBCSSYSR       Q. IS THIS A SYSTEM REQUEST
         BZ    TSTATTR                 A. NO- CONTINUE
         SPACE 2
*/* D (NO,TSTLIB,YES,)  IS THIS AN ATTACH REQUEST? */
         SPACE 2
         TM    RBCDFLGS,RBCSATT        Q. ATTACH REQUEST
         BZ    TSTLIB                  A. NO- TEST LIB AUTH    @WAB
         SPACE 2
*/* D (YES,TSTATTR,NO,) IS ATTACH WITH RESET APF? */
         SPACE 2
         TM    RBCSFLG1,RBCRSAPF       Q. RESET APF?           @WAB
         BNZ   TSTATTR                 A. YES - CONTINUE       @WAB
         SPACE 2
*/*TSTLIB: D (YES,TSTATTR,NO,) IS MAJOR FROM A SYSTEM LIBRARY? */
         SPACE 2
TSTLIB   TM    CDATTR2J,CDSYSLIB       Q. THIS AN AUTH. LIB MODULE
         BNZ   TSTATTR                 A. YES- CONTINUE
         SPACE 2
*/* P SET RBCSSXSA BIT IN XSA (POSSIBLE 306 ABEND) */
*/* R RETURN VIA REG 15+8 */
         SPACE 2
         OI    RBCSFLG1,RBCSA306       TURN ON 306 ABEND FLAG
         B     RETURN3                 A. NO-RET3 MOD. NOT USABLE
         SPACE 2
*/*TSTATTR: D (NO,%CONT2,YES,) CURRENT CDE RENT. & NON-LOAD ONLY? */
*/* R RETURN VIA REG 15+4 */
         SPACE 2
TSTATTR  TM    CDATTR,CDREN+CDNLR      Q. IS MODULE REENTRABLE AND
*                                      UNRESTRICTED BY LOAD-ONLY ATTR.
         BO    RETURN2                 A=YES, TAKE BRANCH
         SPACE 2
*/*%CONT2: D (YES,REUSEPGM,NO,) MINOR SERIALLY REUS & NON-LOAD ONLY? */
*/* D (YES,LOADONLY,NO,) MODULE LOAD ONLY? */
         SPACE 2
         TM    CDATTR,CDSER+CDNLR      Q. IS MODULE SERRIALLY REUSABLE
*                                      UNRESTRICTED BY LOAD-ONLY ATTR
         BO    REUSEPGM                A= YES, TAKE BRANCH
         TM    CDATTR,CDNLR            Q. IS MODULE LOAD - ONLY
         BZ    LOADONLY                A.=YES, TAKE BRANCH
         SPACE
*        IF FLAG IS ZERO LOADABLE ONLY IN INDICATED.
*        MODULE IS NOT REUSABLE,CON ONLY BE ALLOCATED IF LOAD MACRO
*        NOT ISSUED AND NOT PREVIOUSLY USED.
         SPACE
         SPACE 2
*/* D (YES,NOBACKUP,NO,) LOAD REQUEST? */
         SPACE 2
         TM    RBCDFLGS,LOAD           Q. IS A LOAD REQUEST PROCESSING
         BO    NOBACKUP                YES - BRANCH
         SPACE 2
*/* D (NO,%CONT3,YES,) HAS MODULE BEEN USED? */
*/* R RETURN VIA REG 15+8 */
         SPACE 2
         TM    CDATTR,CDNFN            Q. HAS THE MODULE BEEN USED
*                                      BY A PREVIOUS REQUEST
         BO    RETURN3                 RET3 A=YES, TAKE BRANCH
         SPACE 2
*/*%CONT3: P SET MODULE USED FLAG IN MINOR (NFN) */
*/* R RETURN REG 15+4 */
         SPACE 2
         OI    CDATTR,CDNFN            SET PREVIOUSLY USED FLAG
         B     RETURN2                 RET2 SET FLAG AND BRANCH
         SPACE 2
*/*NOBACKUP: D (NO,CDSETUP1,YES,) PROGRAM PUT IN BY LOADER? */
         SPACE 2
NOBACKUP DS    0H                      LOADABLE ONLY LOAD REQUEST
         TM    CDATTR2,CDSPZ           Q. PGM PUT IN BY LOADER
         BNO   CDSETUP1                NO. GET NEW COPY
         SPACE 2
*/* D (NO,CDSETUP1,YES,) CDUSE = 0? */
*/* R RETURN VIA REG 15 +4 */
         SPACE 2
         CLC   CDUSE,ZEROUSE           Q. USE COUNT EQUAL ZERO
         BNZ   CDSETUP1                NO. TRY TO GET NEW COPY
         BZ    RETURN2                 ALLOW THE LOAD - ALLOC SUC.
         SPACE 2
*/*CDSETUP1: P GET ADDRESS OF IEAVLK01 */
*/* S () CDSETUP:GO SEARCH NEXT CDE QUEUE */
         SPACE 2
CDSETUP1 L     BASEREG,VLK01VCN        GET SECOND MOD ADDRESS
         BR    BASEREG                 GO TO SECOND LOAD
         SPACE 2
*/*REUSEPGM: D (NO,%CONT5,YES,%CONT4) REQUEST FOR LOAD? */
*/*%CONT4: R RETURN VIA REG 15+4 */
         SPACE 2
REUSEPGM TM    RBCDFLGS,LOAD           Q. IS THIS A LOAD REQUEST
         BO    RETURN2                 A=YES, NO TEST OF USE REQUIRED
*                                      REQUEST CAN BE FULFILLED
*                                      LOAD RB POINTER FROM CDENTRY
*                                      AND CHECK IF ZERO.
         SPACE 2
*/*%CONT5: P (0,%CONT4,GT 0,) GET ADDRESS OF RB USING MAJOR CDE */
*/* R RETURN REG 15+12 */
         SPACE 2
         ICM   WKREG1,MASK,CDRBPJ+N1   Q. IS RBPOINTER ZERO
         BNE   RETURN4                 RET4 A=NO, TAKE BRANCH
         B     RETURN2                 RET2 RETURN SUCCESSFUL ALLOC
         SPACE 2
*/*LOADONLY: P SAVE ADDRESS OF LLE */
*/* P INITIALIZE ABEND CODE = 0 */
         SPACE 2
LOADONLY DS    0H                      LOADABLE ONLY MODULE PROCESS
         LR    R0,R13                  SAVE REG 13
         SR    R13,R13                 ZERO REG 13 FOR ERROR ROUTINE
         SPACE 2
*/* P NOTE: ONLY LOAD REQUESTORS CAN HAVE ACCESS TO LOAD ONLY MODULES
*/**/
*/* D (YES,%CONT6,NO,) REQUEST FOR LOAD? */
*/* S () ERRLONLY:ISSUE 406 ABEND */
         SPACE 2
         TM    RBCDFLGS,LOAD           IS THIS A LOAD REQUEST
         BZ    ERRLONLY                A = NO TAKE BRANCH, ERROR =406
         SPACE 2
*/*%CONT6: P RESTORE LLE */
         SPACE 2
         LR    R13,R0                  RESTORE REG 13
         SPACE 2
*/* P NOTE: LOAD CANNOT ALLOCATE ALREADY LOADED NON-REUSABLE PROGRAMS
*/**/
*/* D (NO,%CONT7,YES,) MINOR REENTRANT OR REUSABLE? */
*/* R RETURN REG 15+4 */
         SPACE 2
         TM    CDATTR,CDREN+CDSER      Q. IS MODULE REN OR SER
         BNZ   RETURN2                 RET2 A= EITHER REN OR SER
         SPACE 2
*/*%CONT7: R RETURN REG 15+0 */
         SPACE 2
         BR    SUBREG2                 RET 1 ALLOCATE NOT SUCCESSFUL
         DROP  SUBREG2                 DROP ALLOC DSECT
         EJECT
*        CDMOPUP IS CALLED TO PERFORM THE FOLLOWING
*              1. TEST CDUSE FOR MAXIMUM VALUE (7FFF), IF
*                 EXCEEDED, SET SWITCH TO ABEND IN STEP 6.
*              2. INCREMENT CDUSE BY 1 AND, IF SYSTEM REQUEST
*                 INCREMENT CDSYSUSE BY 1.
*              3. FREE THE CDE POINTED TO BY THE BLDL/FETCH WORK
*                 AREA, IF ANY, IF IT IS NOT BEING USED (IF IT IS NOT
*                 THE CDE FOR THE REQUEST (REG 11), OR THE MAJOR CDE
*                 (REG 12).
*              4. FREE THE BLDL/FETCH WORK AREA, IF ONE EXISTS, AND
*                 ZERO THE RBCSWORK FIELD.
*              5. FREE THE DE SAVE AREA, IF ONE EXISTS, AND ZERO
*                 THE RBCSDE FIELD.
*              6. TEST FOR 906 ABEND CONDITION. IF ABEND SWITCH IS SET
*                 ISSUE 906 ABEND, OTHERWISE RETURN ON REGISTER 13.
*
*        REGISTER USABE
*              R0,1,2 - ALTERED
*              R5   - SVRB (INPUT)
*              R6   - BASE REGISTER (INPUT)
*              R7   - POINTS TO BLDL FETCH W.A. (OUTPUT)
*              R11  - REQUESTED CDE (INPUT)
*              R12  - MAJOR CDE  (INPUT)
*              R13  - RETURN ADDRESS (INPUT),ZEROED IF ABEND (OUTPUT)
*              R14,15- ALTERED
*              OTHER REGISTERS NOT REFERENCED
*              SVRB EXSAVE FULLY INITIALIZED
         SPACE
         SPACE 2
*/*CDMOPUP: E CDMOPUP */
*/* D (NO,INCOUNT,YES,) CDUSE COUNT = MAXIMUM? */
         SPACE 2
CDMOPUP  DS    0H                      CLEANUP WORK AREA ROUTINE
         CLC   CDUSEJ(N2),MAXIM        Q. IS USE FIELD MAXIMUML
         BNE   INCOUNT                 NO. INCREMENT COUNT FILEDS
         SPACE 2
*/* P (,FREEWORK) SET ABEND INDICATOR */
         SPACE 2
         OI    RBCSFLG1,RBCSABEN       YES. SET ABEND SWITCH
         B     FREEWORK                AND FREE RESOURCES
         SPACE
*        INCREMENT COUNT IN CDENTRY, CDUSE IS INCREMENTED ONLY HERE.
         SPACE 2
*/*INCOUNT: P INCREMENT CDE USE COUNT BY ONE */
         SPACE 2
INCOUNT  DS    0H
         LH    WKREG1,CDUSEJ           LOAD COUNT IN CDE
         LA    WKREG1,ADD1(WKREG1)     INCREMENT COUNT
         STH   WKREG1,CDUSEJ           RESTORE NEW COUNT IN CDE
         SPACE 2
*/*FREEWORK: P PUT CURRENT ASCB IN REG 7 FOR FREEMAIN */
*/* P (=0,DESATEST,GT 0,) GET WORK AREA ADDRESS */
         SPACE 2
FREEWORK DS    0H                      CHECK IF WORK AREA TO FREE
         L     AREAREG,PSAAOLD         GET ADDR. OF ASCB
         USING WKAREA,WKREG2           PROVIDE ADDRESSABILITY TO BLDL-
*                                      FETCH WORK AREA
         SR    WKREG2,WKREG2           CLEAR REG FOR INSERT      PTM883
         ICM   WKREG2,MASK,RBCSWRKA    Q. WORK AREA GOTTEN
         BZ    DESATEST                NO, CHECK DE SAVE AREA
         SPACE 2
*/* D (YES,RINGO,NO,) CDE BEING USED? */
         SPACE 2
         CLM   CDEREG,MASK,WKCDADDR+N1 Q. IS CDE BEING USED
         BE    RINGO                   A=YES, TAKE BRANCH
         SPACE 2
*/* D (YES,RINGO,NO,) MAJOR CDE BEING USED?? */
         SPACE 2
         CLM   CDIREG,MASK,WKCDADDR+N1 Q. IS CDE USED FOR MAJOR
         BE    RINGO                   A= YES, TAKE BRANCH
         SPACE 2
*/* P GET CDE ADDRESS FROM WORK AREA */
*/* L FREEMAIN-- FREE CDE FROM SP=255 (LSQA) */
         SPACE 2
         SR    R1,R1                   CLEAR REGISTER FOR ICM  @ZA17747
         ICM   R1,MASK,WKCDADDR+N1     PICKUP ADDR OF CDE      @ZA17747
         BZ    RINGO                   IF ACQUIRED CDE IS ZERO @ZA17747
         FREEMAIN RU,LV=CDESIZE,A=(1),SP=255,BRANCH=YES FREE CDE
         SR    R1,R1                   CLEAR REG                @M07600
         STCM  R1,MASK,RBCDE1          CLEAR RBCDE FIELD        @M07600
         SPACE 2
*/*RINGO: L FREEMAIN-- FREE FETCH WORK AREA FROM SP=253 (LSQA) */
*/* P ZERO WORK AREA ADDRESS IN RBXSA */
         SPACE 2
RINGO    DS    0H                      FREE THE WORK AREA
         FREEMAIN RU,LV=WKSIZE,SP=253,A=(2),BRANCH=YES
         ST    R15,RBCSWORK            CLEAR WORK AREA ADDR
*                                      R15 HAS CODE OF ZERO FROM FREE
         DROP  WKREG2
         SPACE 2
*/*DESATEST: P  GET DESAVE AREA ADDRESS FROM RBXSA */
*/* D (YES,,NO,ABENDTST) DOES DE SAVE AREA EXIST */
         SPACE 2
DESATEST DS    0H                      CHECK FOR DE SAVE AREA
         L     R1,RBCSDE               PICK UP DE SAVE AREA ADDR
         LTR   R1,R1                   TEST IF DE SAVE AREA EXITS
         BZ    ABENDTST                IF NONE, GO TO CHECK FOR ABEND
         SPACE 2
*/* L FREEMAIN-- FREE DE SAVE AREA FROM SP=255 */
*/* P ZERO DESAVE AREA ADDRESS IN RBXSA */
         SPACE 2
         FREEMAIN RU,LV=DESIZE,SP=255,A=(1),BRANCH=YES
         ST    R15,RBCSDE              CLEAR DE SAVE AREA ADDR.
*                                      R15 HAS CODE OF ZERO FROM FREE
         SPACE 2
*/*ABENDTST: P RESTORE CVT POINTER DESTROYED BY FREEMAIN */
*/* D (NO,,YES,%CONT8) ABEND INDICATOR ON? */
*/* R RETURN VIA REG 13 */
         SPACE 2
ABENDTST DS    0H                      TEST FOR 906 ABEND
         L     CVTREG,CVTPTR           RESTORE ADDR. OF CVT
         TM    RBCSFLG1,RBCSABEN       Q. ABEND 906
         BCR   EQZER,RETURND           NO, RETURN
         SPACE 2
*/*%CONT8: P ZERO ABEND REGISTER (REG 13) */
*/* S () ERRCOUNT:ISSUE 906 ABEND */
         SPACE 2
         SR    R13,R13                 ZERO REG FOR ABEND ROUTINE
         B     ERRCOUNT                TO ABEND 906.
         EJECT
*        CDLLSRCH IS A SUBROUTINE OF LOAD AND DELETE WHICH, GIVEN
*        A NAME AS INPUT, SEARCHES THE LLE QUEUE CHAINED FROM THE
*        TCB FOR A CDE WITH THE SAME NAME.  IF AN LLE IS FOUND,
*        RETURN IS ON R15 + 0. IF AN LLE IS NOT FOUND, RETURN IS
*        ON R15 + 4.
*
*        REGISTER USABE
*              R1  - ADDRESS OF PREVIOUS LLE IF LLE WAS FOUND (OUTPUT)
*                     THIS LLE POINTS TO THE LLE IN R13
*              R2  - CHANGED
*              R4  - TCB (INPUT)
*              R9  - ADDRESS OF NAME (INPUT)
*              R11 - ADDRESS OF CDE IF COUND (OUTPUT)
*              R12 - ADDRESS OF CDE IF FOUND (OUTPUT)
*              R13 - ADDRESS OF LLE IF FOUND (OUTPUT)
*              R15 - RETURN ADDRESS (INPUT)
*              OTHER REGISTERS NOT REFERENCED.
         SPACE 2
*/*CDLLSRCH: E CDLLSRCH */
*/* P GET ADDRESS OF LLE QUEUE HEADER IN CALLER'S TCB */
         SPACE 2
CDLLSRCH LA    WKREG1,TCBLLS           PICK UP LOAD LIST START ADDR.
         SPACE 2
*/*CDLLCONT: P NOTE: THIS IS AN ALTERNATE ENTRY TO  CONTINUE THE LLE
*/*SEARCH */
*/* P SET UP LOOP POINTER TO SPEED SEARCH */
         SPACE 2
CDLLCONT BALR  WKREG2,ZERO             ESTABLISH LOOP START ADDR
         SPACE 2
*/*%LDLREG: P (=0,,GT 0,%CONT9) GET NEXT LLE ADDRESS */
*/* R RETURN REG 15+4 */
         SPACE 2
         ICM   LDLREG,MASK4,N0(WKREG1) PICK UP LLE ADDRESS
*                                      Q. IS LLE ADDR = 0
         BZ    N4(SUBREG2)             A= YES, RETURN REG 15 + 4
         SPACE 2
*/*%CONT9: P GET ADDRESS OF CDE FROM LLE */
*/* D (NO,%CONTA,YES,) NAME IN CDE = REQUESTED NAME? */
*/* R RETURN REG 15+0 */
         SPACE 2
         L     CDIREG,LLECDPT          PICK UP ADDR OF CDE FROM LLE
         CLC   CDNAMEJ(NAME),N0(NAMEREG) Q. ARE NAMES EQUAL
         LR    CDEREG,CDIREG           INITIALIZE MINOR REG
         BCR   EQZER,SUBREG2           A= YES RETURN
         SPACE 2
*/*%CONTA: P (,%LDLREG) SET THIS LLE AS PREVIOUS LLE */
         SPACE 2
         LR    WKREG1,LDLREG           PICK UP NEXT ADDR OF LLE AND
         BR    WKREG2                  BRANCH TO LOOP START
         DROP  LDLREG                  LAST USE OF LLE
         EJECT
*        IEAVVMSR (SRCHDIRC) IS THE FIXED LINK PACK DIRECTORY SEARCH
*        ROUTINE. IT IS USED TO MINIMIZE THE SIZE OF THE ACTIVE LPAQ
*        WHILE PROVIDING RAPID ACCESS TO ALL LPA (PAGEABLE) MODULES.
*        A MODULES LPDE IS LOACATED BY EXCLUSIVE ORING THE FIRST FOUR
*        BYTES OF THE NAME WITH THE LAST FOUR BYTES.  THE RESULT IS
*        DIVIDED BY THE DIRECTORY SIZE, AND THE REMAINDER IS USED AS
*        AN INDEX.  THIS INDEX IS MULTIPLIED BY THE LPDE SIZE (40), AND
*        ADDED TO THE DIRECTORY ORIGIN.  THIS LOCATES AN LPDE QUEUE
*        WHICH WILL CONTAIN THE MODULE NAME (IF IT EXISTS).  THE LPDE
*        QUEUE THUS FOUND IS THEM SEARCHED IN A SIMILAR MAMMER TO THE
*        CDE QUEUE SEARCH (CDSEARCH).  A RETURN ON R14 + 0 MEANS THAT
*        THE LPDE WAS FOUND. OTHERWISE RETURN IS TO R14 + 4.  A USER
*        OF IEAVVMSR MUST INSURE THAT THE CVTDIRST BIT IS ON (=1)
*        BEFORE ENTERING IEAVVMSR, SINCE THIS BIT TELLS IF NIP HAS
*        BUILT THE LPDE DIRECTORY YET.
*        REGISTER USABE
*              R0  - LEFT HALF OF NAME (INPUT)
*                      LPDE ADDRESS, IF FOUND (OUTPUT), ELSE, UNCHANGED
*              R1  - RIGHT HALF OF NAME (INPUT)
*              R3  - ADDRESS OF CVT (INPUT)
*              R6  - SET TO BASE (OUTPUT) INPUT IF SRCHDIRC ENTRY
*              R8,9- ALTERED
*              R14 - RETURN ADDRESS (INPUT)
*              OTHER REGISTERS NOT USED
         SPACE 2
*/*IEAVVMSR: E IEAVVMSR */
*/* P ESTABLISH BASE ADDRESS (CDLKBASE) */
         SPACE 2
IEAVVMSR DS    0H                      LPA DIRECTORY SEARCH
         USING CVT,CVTREG              ADDRESSABILITY TO CVT
         BALR  BASEREG,ZERO            SET UP ADDRESSABILITY
         USING *,BASEREG               INITIALIZATION FOR EXTERNAL CALL
         L     BASEREG,LINKBASE        PICK UP BASE VALUE
         USING CDLKBASE,BASEREG        ESTABLISH ADDRESSABILITY
         SPACE 2
*/*SRCHDIRC: P NOTE: THIS IS AN ALTERNATE ENTRY TO CONTINUE THE SEARCH
*/**/
*/* P EXCLUSIVE OR FIRST AND SECOND HALF ON NAME */
*/* P DIVIDE RESULT BY VALUE IN CVTVMDI */
*/* P MULTIPLY REMAINDER BY LPDE SIZE */
*/* P ADD PRODUCT TO LPA DIRECTORY BASE ADDRESS */
         SPACE 2
SRCHDIRC DS    0H                      ENTRY FOR IEAVLK USERS
         USING LPDE,LPDEREG            ADDRESSABILITY FOR LPDES
         SR    LPDEREG,LPDEREG         CLEAR REG FOR DIVISION
         LR    HASHREG,NAMELEFT        LEFT HALF OF NAME IN WORK REG.
         XR    HASHREG,NAMERGT         HASH WITH RIGHT HALF
         D     LPDEREG,CVTVVMDI        DIVIDE BY DIRECTORY SIZE
         LA    HASHREG,LPDESIZE        GET MULTIPLIER
         MR    LPDEREG,LPDEREG         MULT. BY SIZE OF LPDE
         LR    LPDEREG,HASHREG         MOVE RESULT TO USABLE REG.
         A     LPDEREG,CVTDIRST        ADD START OF DIRECTORY ADDR
         SPACE 2
*/*CHEKNEXT: P COMPARE LPDENAME WITH FIRST HALF OF NAME */
*/* D (NO,NEXTLPDE,YES,) EQUAL? */
         SPACE 2
CHEKNEXT C     NAMELEFT,LPDENAME       IF FIRST HALVES NOT EQUAL,
         BNE   NEXTLPDE                GET NEXT LPDE ON CHAIN
         SPACE 2
*/* P COMPARE LPDENAME+4 WITH SECOND HALF OF NAME */
*/* D (NO,NEXTLPDE,YES,DONIT) EQUAL? */
         SPACE 2
         C     NAMERGT,LPDENAME+NAMERT IF BOTH EQUAT,
         BE    DONIT                   LPDE IS FOUND, BRANCH OUT
         SPACE 2
*/*NEXTLPDE: P GET ADDRESS OF NEXT LPDE */
*/* D (NO,CHEKNEXT,YES,) CHAIN POINTER = 0? */
*/* R RETURN REG 14+4 */
         SPACE 2
NEXTLPDE DS    0H                      GET NEXT LPDE TO TEST
         L     LPDEREG,LPDECHN         GET NEXT LPDE ADDRESS
         LTR   LPDEREG,LPDEREG         TEST FOR END OF QUEUE
         BNZ   CHEKNEXT                IF NONZERO, CHECK NAME
         B     NOGOOD(RETURN)          OTHERWISE, NOT FOUND RETURN
         SPACE 2
*/*DONIT: P LOAD LPDE ADDRESS INTO REG 0 */
*/* R RETURN VIA REG 14 */
         SPACE 2
DONIT    LR    LPDEADDR,LPDEREG        PUT LPDE ADDRESS IN REG. 0
         BR    RETURN                  RETURN GOOD
         EJECT
*        ERRORTAB IS THE INTERFACE TO ABEND.  IT IS ENTERED WHENEVER
*        AN ABEND SITUATION HAS BEEN DETECTED BY THE PROGRAM MANAGER.
*        THE VARIOUS ENTRY POINTS ARE USED TO GENERATE THE
*        PARTICULAR ABEND CODES.  UPON ENTRY, THE ENVIRONMENTAL
*        REGISTERS 3,4, AND 5 ARE INITIALIZED, AND A TEST IS MADE FOR
*        NIP IN PROCESS.  IF NIP IS IN PROCESS, THE ABEND CODE IS
*        GENERATED INTO R1, AND THE TCB ADDRESS IS PUT INTO REGISTER 0
*        WITH AN ABEND SVC BEING ISSUED.  OTHERWISE A MESSAGE IS
*        WRITTEN (WTP) TO THE PROGRAMMER INDICATING THE TYPE OF ERROR
*        TAT HAS OCCURED.  A BUFFER IS OBTAINED CONDITIONALLY FROM
*        SUBPOOL 253.  IF THE GETMAIN CANNOT BE DONE, THE WTP IS
*        BYPASSED.  IN THIS WAY A GETMAIN ABEND IS AVOIDED.  THE FORMAT
*        OF THE MESSAGES IS GIVEN IN THE DSECTS AT THE END OF THIS
*        ROUTINE.  THE NECESSARY INFORMATION IS LOCATED IN THE CVT,
*        TCB,SVRB (EXSAVE), THE TIOT, AND IN THE REGISTERS UPON ENTRY.
*        THE WTO MESSAGE PROCESSING IS EBCDIC DEPENDENT
*        REGISTER USAGE
*              R0  - TCB ADDRESS (OUTPUT)
*              R1  - ABEND CODE (OUTPUT)
*              R3  - CVT ADDRESS (OUTPUT)
*              R4  - TCB ADDRESS (OUTPUT)
*              R5  - SVRB ADDRESS (OUTPUT)
*              R6  - BASE REGISTER (INPUT)
*              R8  - DE SIZE IF 206 ABEND (INPUT)
*              R9  - ANDE/DE POINTER IF 206 ABEND (INPUT)
*              R10 - REASON CODE SAVE REG (OUTPUT)
*              R11 - TIOT ADDRESS (OUTPUT)
*              R12 - PARAMETER LIST PASSED (IF 206 ABEND)
*              R13 - ZERO (INPUT) ABEND CODE (OUTPUT)
*              R14 - WORK REGISTER (OUTPUT)
*              R15 - REASON CODE (INPUT AND OUTPUT)
*              OTHER REGISTERS NOT REFERENCED
*              SVRB EXSAVE FULLY INITIALIZED EXCEPT IF 206 ABEND
         SPACE 2
*/*ERRTAB: E ENTRY ERRTAB */
         SPACE 2
ERRORTAB DS    0H                      ABEND CODE TABLE
*/*ERRLOCK: P CODE+1 (A06) */
*/*ERRCOUNT: P CODE+1 (906) */
*/*ERRBLDL: P CODE+2 (806) */
*/*ERRFIX: P CODE+2 (606) (OBSOLETE) */
*/*ERRONLY: P CODE+2 (406) */
*/*ERRPARM: P CODE+2 (206) */
ERRLOCK  LA    R13,N1(R13)             CODE = A06
ERRCOUNT LA    R13,N1(R13)             CODE = 906
ERRBLDL  LA    R13,N2(R13)             CODE = 806
ERRFIX   LA    R13,N2(R13)             CODE = 606
ERRLONLY LA    R13,N2(R13)             CODE = 406
ERRPARM  LA    R13,N2(R13)             CODE = 206
         SPACE 2
*/*ABNDSET:S SETFRR:REMOVE RECOVERY ROUTINE */
         SPACE 2
ABNDSET  DS    0H                      ENTRY FROM IEAVLK01 SAME INPUT
         SETFRR D,WRKREGS=(R3,R4)      RELEASE RECOVERY
         SPACE 2
*/* P SET UP ADDRESSABILITY */
         SPACE 2
         L     CVTREG,CVTPTR           PICK UP CVT ADDRESS
         USING CVT,CVTREG              ADDRESSABILITY ON CVT
         L     TCBREG,CVTTCBP          PICK UP NEW OLD SLOTS
         L     TCBREG,OLD(TCBREG)      PICK UP TCB ADDRESS
         L     RBREG,TCBRBP            PICK UP CONTENTS SVRB
         SPACE 2
*/* D (NO,CVTCHEK,YES,) SHOULD ABEND BE 306? */
         SPACE 2
         LR    REASON,R15              PICK UP REASON CODE FROM
*                                      PARAMETER REG
         TM    RBCSFLG1,RBCSA306       Q. ABEND SHOULD BE 306
         BZ    CVTCHEK                 A. NO- CONTINUE
         SPACE 2
*/* P SET ABEND CODE TO 306 */
         SPACE 2
         LA    ABCODE,THREE            A. YES- SET CODE TO 3 FOR ABEND
         SPACE 2
*/*CVTCHEK: D (YES,NOWTP,NO,) NIP IN PROGRESS? */
         SPACE 2
CVTCHEK  DS    0H                      LABEL TO BRANCH
         TM    CVTOPTA,CVTNIP          IF NIP IN PROCESS SKIP WTP
         BO    NOWTP                   ABEND DIRECTLY
         SPACE 2
*/* P SAVE PARM LIST POINTER(R12) IN R1 FOR 206 ABEND */       @ZA02730
*/* L SETLOCK-- FREE ALL LOCKS */
*/* P RESTORE THE PARM LIST POINTER(R12) FROM R1 */            @ZA02730
         SPACE 2
         LR    R1,R12                  SAVE PARM LIST POINTER  @ZA02730
         LR    CVTREG,R13              SAVE REG 13 OVER SETLOCK
         SETLOCK  RELEASE,TYPE=CMS,RELATED=FREE ALL LOCKS
         SETLOCK  RELEASE,TYPE=LOCAL,RELATED=HELD (ONLY LOACAL AND CMS)
         LR    R12,R1                  RESTORE PARM LIST PTR   @ZA02730
         LR    R13,CVTREG              RESET ABEND CODE TO VOLITAL REG
         L     CVTREG,CVTPTR           RESTORE CVT TO USING REG
         SPACE 2
*/* L GETMAIN-- GET WTP BUFFER */
         SPACE 2
         GETMAIN EC,LV=MESSZE,A=RBCSGR15,SP=253,MF=(E,RBCSGR0)
*                                      ELEMENT FORM,CONDITIONAL
*                                      GETMAIN FOR MESSAGE BUFFER IN
*                                      SP 253, LIST TO BE BUILT IN
*                                      GR15-1 SAVE AREA IN SVRB EXSA
         LTR   R15,R15                 IF GETMAIN FAILED
         BNZ   NOWTP                   DONT DO WTP.  PREVENTS ABENDING
*                                      POOR FELLOW FOR NO SPACE WHILE
*                                      WE ARE ABENDING HIM FOR MESSING
*                                      UP PROGRAM MANAGER
         SPACE 2
*/* P PRIME WTP BUFFER */
         SPACE 2
         L     R1,RBCSGR15             PICK UP BUFFER ADDRESS
         USING MGEN,R1                 GENERAL MESSAGE DSECT
         MVC   MGEN(MESSZE),MESSAGE    INITIALIZE BUFFER WITH SKELETON
*                                      MESSAGE
         L     TIOTPTR,TCBTIO          GET TIOT ADDRESS FROM TCB
         USING TIOT1,TIOTPTR           ADDRESSABILITY ON TIOT
         MVC   MGENJOBN(NAME),TIOCNJOB MOVE JOB NAME TO MESSAGE
         MVC   MGENSTEP(NAME),TIOCSTEP MOVE STEP NAME TO MESSAGE
         DROP  TIOTPTR                 DROP ADDRESSABILITY FOR TIOT
         SPACE 2
*/* D (YES,CODE206,NO,) 206 ABEND? */
         SPACE 2
         CLM   ABCODE,MASK1,BYTETWO    IF 206 ABEND
         BE    CODE206                 DO SPECIAL MESSAGE PROCESS
         SPACE 2
*/* P PUT MODULE NAME IN MESSAGE */
         SPACE 2
         MVC   MGENNAME(NAME),RBCSNAME MOVE MODULE NAME TO MESSAGE
         SPACE 2
*/* D (YES,RESUME,NO,) 106 ABEND? */
         SPACE 2
         CLM   ABCODE,MASK1,BYTEONE    IF 106 ABEND
         BE    RESUME                  AVOID ZERO REASON CODE
         SPACE 2
*/* D (YES,RESUME,NO,) 806 ABEND? */
         SPACE 2
         CLM   ABCODE,MASK1,BYTEEIGH   IF 806 ABEND
         BE    RESUME                  AVOID ZERO REASON CODE
         SPACE 2
*/* D (YES,RESUME,NO,) 306 ABEND? */
         SPACE 2
         CLM   ABCODE,MASK1,BYTETHRE   IF 306 ABEND
         BE    RESUME                  AVOID ZERO REASON CODE
         SPACE 2
*/* P FOR ALL OTHER ABEND TYPES, ZERO OUT REASON CODE */
         SPACE 2
         SR    REASON,REASON           ZERO OUT REASON CODE
         SPACE 2
*/*RESUME: P CONVERT ABEND REASON CODE TO EBCDIC */
         SPACE 2
RESUME   DS    0H                      FORMAT CODES
*
* THE FOLLOWING INSTRUCTION IS EBCDIC CHARACTER CODE DEPENDENT
*
         IC    R14,TRANTAB(ABCODE)     PICK UP EBCDIC CODE
         STC   R14,MGENABID            MOVE TO BYTE IN MESSAGE
*                                      TO CREATE ABEND CODE
*
* THE FOLLOWING INSTRUCTION IS EBCDIC CHARACTER CODE DEPENDENT
*
         LTR   REASON,REASON           IS REASON CODE ZERO     @ZA18512
         BNZ   REASCODE                NO PROCESS GOOD REASON  @ZA18512
         MVI   MGENDASH,BLANK          YES BLANK OUT THE DASH  @ZA18512
         B     WTPITNOW                GO WRITE THE MESSAGE    @ZA18512
REASCODE STC   REASON,MGENREAS+1       STORE REASON CODE       @ZA18512
         UNPK  MGENREAS(THREE),MGENREAS+1(TWO)   UNPACK CODE   @ZA18512
         TR    MGENREAS(TWO),TRANTAB-X'F0' MAKE IT PRINTABLE   @ZA18512
         CLI   MGENREAS,X'F0'          LEADING ZERO IN CODE    @ZA18512
         BNE   REASBLNK                NO THEN LEAVE IT ALONE  @ZA18512
         MVI   MGENREAS,BLANK          MAKE IT BLANK IN MSG    @ZA18512
REASBLNK MVI   MGENREAS+2,BLANK        FIX BLANK IN FIELD      @ZA18512
         SPACE 2
*/*WTPITNOW: L WTO-- WTP OPTION */
         SPACE 2
WTPITNOW DS    0H                      READY TO WTO
         WTO   MF=(E,(1))              WRITE MESSAGE TO PROGRAMMER
         FREEMAIN RU,LV=MESSZE,A=RBCSGR15,SP=253 FREE MSG BUFF @ZA20311
         SPACE 2
*/*NOWTP: P SET UP REGISTERS FOR ABEND */
         SPACE 2
NOWTP    DS    0H
         LR    R15,REASON              RESTORE REASON CODE
         SLL   ABCODE,N8               PUT ABEND CODE IN RIGHT BITS
         O     ABCODE,ANOMALY          PUT IN 06
         SPACE 2
*/* D (YES,BRANCHOU,NO,) RETURN REQUESTED? */
         SPACE 2
         TM    RBCSFLG1,RBCSERIN       Q. ERROR RETURN REQ.
         BO    BRANCHOU                A. YES - BRANCH TO EXIT
         SPACE 2
*/*ABEND: L () ABEND-- TERMINATE TASK */
         SPACE 2
ABEND    ABEND (ABCODE),DUMP,,SYSTEM   ISSUE ABEND SVC
         SPACE 2
*/*CODE206: P (,RESUME) SET UP SPECIAL MESSAGE FOR 206 ABEND */
         SPACE 2
CODE206  DS    0H                      206 ABEND SPECIAL MESSAGE
         MVC   M206ZIPS(THREE),ZIPBLK  PUT IN 00 AND A BLANK
         MVC   M206PARM(TOEND),M206BLK0 BLANK OUT REST OF MESSAGE
         MVC   M206MID(N3),MSG807I     SET MESSAGE TO 206 ID
         ST    R12PARM,RBCSGR15        STORE PARM LIST POINTER
         UNPK  M206PARM(UNPKSIZE),RBCSGR15(FIVE)  FORMAT INTO MSG
*
* THE FOLLOWING INSTRUCTION IS EBCDIC CHARACTER CODE DEPENDENT
*
         TR    M206PARM(EIGHT),TRANTAB-X'F0' TRANSLATE TO EBCDIC
         MVI   M206BLK1,BLANK          RESET BLANK
         CLM   REASON,MASK1,BYTEONE    IF REASON CODE 1
         BE    RESUME                  END OF 206 PROCESS HERE
         ST    R9,RBCSGR15             STORE EP/DE ADDRESS     @ZA02730
         UNPK  M206NMDE(UNPKSIZE),RBCSGR15(FIVE)               @ZA02730
*                                      FORMAT INTO MESSAGE     @ZA02730
*                                                              @ZA02730
* THE FOLLOWING INSTRUCTION IS EBCDIC CHARACTER CODE DEPENDENT @ZA02730
*                                                              @ZA02730
         TR    M206NMDE(EIGHT),TRANTAB-X'F0'                   @ZA02730
*                                      TRANSLATE TO EBCDIC     @ZA02730
         MVI   M206BLK2,BLANK          RESET BLANK             @ZA02730
         CLM   REASON,MASK1,BYTETWO    IF REASON CODE 2,THEN   @ZA02730
         BE    RESUME                  END OF 206 PROCESS HERE @ZA02730
         ST    DESZREG,RBCSGR15        STORE DE SIZE CALCULATED
         UNPK  M206DES(UNPKSIZE),RBCSGR15(FIVE)  FORMAT INTO MSG
*
* THE FOLLOWING INSTRUCTION IS EBCDIC CHARACTER CODE DEPENDENT
*
         TR    M206DES(EIGHT),TRANTAB-X'F0'  TRANSLATE TO EBCDIC
         MVI   M206BLK3,BLANK          RESET BLANK
         B     RESUME                  END OF 206 SPECIAL PROCESS
         SPACE 2
*/*BRANCHOU: D (YES,ABEND,NO,) XCTL REQUEST? */
         SPACE 2
BRANCHOU TM    RBCDFLGS,XCTL           Q. XCTL REQUEST
         BO    ABEND                   A. YES - NO ERROR RET. ALLOWED
         SPACE 2
*/* D (YES,ABEND,NO,) 206 ABEND? */
         SPACE 2
         CL    ABCODE,A206             Q. 206 ABEND
         BE    ABEND                   A. YES - NO RETURN ALLOWED
         TM    RBCSFLG1,RBCSABEN       Q. ABEND 906            @ZA17747
         BO    FREEDONE                                        @ZA17747
         LR    R8,ABCODE               SAVE ABCODE ACROSS FREE @ZA17747
         SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,RELATED=NO      @ZA20311
         L     AREAREG,PSAAOLD         GET ASCB ADDR IN REG 7  @ZA20311
         SR    WKREG2,WKREG2           CLEAR REG2 FOR ICM      @ZA20311
         ICM   WKREG2,MASK,RBCSWRKA    IS THERE A WORK AREA    @ZA20311
         BZ    CHECKDE                 NO - CHECK FOR DE SAVE  @ZA20311
         BAL   RETURND,RINGO           YES - GO FREE WORK AREA @ZA20311
         B     RELSLOCK                GO RELEASE LOCAL LOCK   @ZA20311
CHECKDE  BAL   RETURND,DESATEST        GO HANDLE DE SAVE       @ZA20311
RELSLOCK SETLOCK RELEASE,TYPE=LOCAL,RELATED=HELD               @ZA20311
         LR    ABCODE,R8               RESTORE THE ABEND REG   @ZA20311
FREEDONE DS    0H                                              @ZA17747
         SPACE 2
*/* P  SET ABEND CODE IN REG 1 */
         SPACE 2
         L     CVTREG,CVTPTR           GET ADDRESS OF CVT
         LR    R1,ABCODE               PUT ABEND CODE IN R0
         LR    R15,REASON              RESTORE REASON CODE     @ZA28684
         LTR   R15,R15                 DOES R15 CONTAIN REASON CODE
         BNE   LOADTEST                YES - USE ONE SET
         LA    R15,N4                  SET A RETURN CODE NE 0
         SPACE 2
*/* D (NO,,YES,ERREXIT) REQUEST FOR LOAD? */
         SPACE 2
LOADTEST TM    RBCDFLGS,LOAD           Q. LOAD REQUEST
         BO    ERREXIT                 A. YES - EXIT
         SPACE 2
*/*LINKEXIT: P (,SYNCR) PUT ERROR EXIT ADDRESS IN OPSW FROM RBCSERRA */
         SPACE 2
LINKEXIT L     PRBREG,RBWCF            GET CALLERS RB
         L     R0,RBGRSAVE             RESTORE CALLERS REG 0
         L     SUBREG2,RBCSERRA        GET ERR. RET. ADDR.
         LA    SUBREG2,N0(SUBREG2)     CLEAR HIGH BYTE           M02638
         ST    SUBREG2,RBOPSWZ+WORD(PRBREG) PUT IN CALLERS RB
         LA    R14,CVTEXIT             GET ADDRESS OF EXIT INSTRUCTION
         ST    R14,RBGRS14             PLACE IN SVRB R14 SLOT
         SPACE 2
*/*ERREXIT: R EXIT PROLOG */
         SPACE 2
ERREXIT  DS    0H
         L     R14,CVTEXPRO            GET ADDR OF EXIT PROLOGUE
         BR    R14                     EXITTO CALLER
         SPACE 2
*/* FOOTING
*/*
*/* */
*/*IEAVLK00: END END ONE OF TWO MODULES  */
         SPACE 2
         DROP  R1                      END OF WTP USAGE
         EJECT
*
*                                      ADDRESSING CONSTANTS
*
IEAQCS04 DS    0F                      ADDRESS LIST FOR VLK01
*                                      THE FOLLOWING 6 CONSTANTS MUST
*                                      NOT BE MOVED OR CODE INSERTED
LINKBASE DC    A(CDLKBASE)             USED TO SET CORRECT BASE
*                                      FOR ADDRESSIBILITY
         DC    A(CDCONTRL)             POINT TO CDCONTRL
         DC    A(CDEMERGE)             POINT TO CDEMERGE
         DC    A(CDQUECTL)             POINT TO CDQUECTL
         DC    A(PLUSCONT)             POINT TO PLUSCONT
         DC    A(ABNDSET)              POINT TO ABENDSET
VLK01VCN DC    A(IEAVLK01)             POINT TO SECOND LOAD
IEAQLCTA DC    A(IEAQLPAQ)             ADDRESS OF LINK PACK AREA
*                                      CONTROL QUEUE . ALSO IN CVT
HKPADDR  DC    A(CDHKEEP)              ADDRESS OF TASK MST.HKEEP RTN.
FRRPGM   DC    A(FRRPGMMG)             ADDRESS OF FRR FOR PGM. MGR.
*
*                                      GENERAL MASKS
*
A206     DC    X'00000206'             INDICATED 206 ABEND
MAXIM    DC    X'7FFF'                 MAXIMUM USE COUNTS
ZEROUSE  DC    X'0000'                 ZERO USE COUNT FIELD TEST
ANOMALY  DS    0F                      ABEND FORMATTING CONSTANT
         DC    X'00000006'             MASK WITH SVC NO. AND DUMP FLAG
APFROUND DC    X'FFFFFFFE'             ROUND TO HALFWORD AND MASK
HIBYTE   DC    X'FF'                   ABEND FLAG FOR CDMOPUP
CLRBYTE  DC    X'000000'               3 BYTES OF HIBYTE ALSO USED
*                                      TO SET HIGH ORDER BYTE OF REG 0
BYTEONE  DC    X'01'                   ONE BYTE FOR COMPARE
BYTETWO  DC    X'02'                   ONE BYTE FOR COMPARE
BYTETHRE DC    X'03'                   ONE BYTE FOR COMPARE
BYTEEIGH DC    X'08'                   ONE BYTE FOR COMPARE
AUTHON   DC    X'01'                   AUTHORIZATION FLAG
LLEONE   DC    X'0001'                 ONE IN LLE
*
* THE FOLLOWING CONSTANT IS EBCDIC CHARACTER CODE DEPENDENT
*
ZIPBLK   DC    C'00 '                  ZERO AND BLANK OVERLAY  @ZA02730
*                                      FOR 206 ABEND MESSAGE   @ZA02730
*
* THE FOLLOWING CONSTANT IS EBCDIC CHARACTER CODE DEPENDENT
*
MSG807I  DC    C'807'                  MESSAGE ID FOR 206 ABENDS
*                                      IT OVERLAYS THE 703 IN THE WTO
FRAMPSW  DC    X'000D000000'           PROBLEM STATE, ENABLED
MESSAGE  WTO   'IEA703I  06-                     MODULE ACCESSED       X
                       ',MF=L,ROUTCDE=11,DESC=6                @ZA18512
ENDOMES  EQU   *                       ABEND MESSAGE END
MESSZE   EQU   ENDOMES-MESSAGE         SIZE OF MESSAGE TO MOVE
*
* THE FOLLWOING TABLE IS EBCDIC CHARACTER CODE DEPENDENT
*
TRANTAB  DC    C'0123456789ABCDEF'     TRANSLATE TABLE TO EBCDIC
         EJECT
ALLOC    DSECT
*                  THE CDALLOC SUBROUTINE USES A BRANCH TABLE TO
*                  DISTINGUISH THE RESULTS OF ITS ACTION.  A BRANCH
*                  TABLE OF THE FOLLOWING NATURE IS EXPECTED
RETURN1  B     0   AN AVAILABLE COPY CANNOT BE FOUND IN QUEUE SEARCHES
*                  PROCEED WITH OPERATION TO FETCH A COPY.
RETURN2  B     0   AN AVAILABLE COPY HAS BEEN FOUND -PROCEED TO
*                  COMPLETE REQUEST.
RETURN3  B     0   A COPY OF A PROGRAM THAT IS NOT REUSABLE HAS BEEN
*                  FOUND, IT MAY NOT BE USED AGAIN.
RETURN4  B     0   THE REQUEST MUST BE QUEUED.  THE LOAD MODULE IS
*                  SERIALLY REUSABLE AND IS CURRENTLY BEING USED.
RETURN5  B     0   A REQUEST MSUT BE QUEUED PENDING THE AVAILIBILITY
*                  OF THE LOAD MODULE.  THE MODULE IS BEING LOADED.
         EJECT
         IHAMB MESSAGE BUFFER DSECT
         EJECT
MGEN     DSECT OTHER THAN 206 ABEND MESSAGE
         DS    CL4                     ALWAYS WTO INTERNAL CODES
         DS    CL7                     ALWAYS IEA703I
         DS    C                       ALWAYS BLANK
MGENABID DS    C                       VARIABLE ABEND NUMBER
         DS    CL2                     ALWAYS 06
MGENDASH DS    C                       DASK OR BLANK
MGENREAS DS    CL2                     REASON CODE OR BLANK    @ZA18512
         DS    C                       ALWAYS BLANK
MGENJOBN DS    CL8                     JOB NAME
         DS    C                       ALWAYS BLANK
MGENSTEP DS    CL8                     STEP NAME
         DS    C                       ALWAYS BLANK
         DS    CL15                    ALWAYS MODULE ACCESSED
         DS    C                       ALWAYS BLANK
MGENNAME DS    CL8                     MODULE NAME
         DS    CL6                     BLANK PADDING TO MANK BOTH
*                                      MESSAGES THE SAME SIZE
         SPACE 3
         ORG   MGEN                    206 SPECIAL MESSAGE
M206     EQU   *
         DS    CL4                     ALWAYS WTO INTERNAL CODES
         DS    CL3                     ALWAYS IEA
M206MID  DS    CL3                     708 ID FOR 206 MESSAGE
         DS    C                       ALWAYS I
         DS    C                       ALWAYS BLANK
M206ABID DS    C                       VARIABLE ABEND NUMBER (2)
         DS    CL2                     ALWAYS 06
M206DASH DS    C                       DASH OR BLANK
M206REAS DS    CL2                     REASON CODE OR BLANK    @ZA18512
         DS    C                       ALWAYS BLANK
M206JOBN DS    CL8                     JOB NAME
         DS    C                       ALWAYS BLANK
M206STEP DS    CL8                     STEP NAME
         DS    C                       ALWAYS BLANK
M206ZIPS DS    CL2                     ALWAYS 00
M206BLK0 DS    C                       ALWAYS BLANK
M206PARM DS    CL8                     PARAMETER LIST POINTER
M206BLK1 DS    C                       ALWAYS BLANK
M206NMDE DS    CL8                     NAME OR DE POINTER
M206BLK2 DS    C                       ALWAYS BLANK
M206DES  DS    CL8                     EXPECTED DE SIZE
M206BLK3 DS    C                       ALWAYS BLANK
M206END  EQU   *                       END OF MESSAGE FOR BLNAKING SIZE
TOEND    EQU   M206END-M206PARM        LENGTH OF MESSAGE TO BLANK IF
*                                      206 ABEND
         EJECT
         IHAASCB
         EJECT
         IHAASXB
         EJECT
         IHACDE
CDEEND   EQU   *
CDESIZE  EQU   CDEEND-CDENTRY          SIZE OF CDE
CDRBPZ   EQU   CDRRBP-CDENTRY          OFFSET TO RB POINTER
         EJECT
CDENTRYJ DSECT
         DS    (CDESIZE)C               CDE EQUATES
CDATTRJ  EQU   CDENTRYJ+CDATTR-CDENTRY  MAJOR CDE DSECT
CDCHAINJ EQU   CDENTRYJ+CDCHAIN-CDENTRY    TO INCREASE
CDRBPJ   EQU   CDENTRYJ+CDRRBP-CDENTRY         READABILITY
CDNAMEJ  EQU   CDENTRYJ+CDNAME-CDENTRY           OF THE CODE
CDUSEJ   EQU   CDENTRYJ+CDUSE-CDENTRY                WHILE
CDENTPTJ EQU   CDENTRYJ+CDENTPT-CDENTRY                MAINTAINING
CDATTR2J EQU   CDENTRYJ+CDATTR2-CDENTRY                  DEPENDANCY
CDXLMJPJ EQU   CDENTRYJ+CDXLMJP-CDENTRY               ON THE MACRO
         EJECT
DESAVE   DSECT                         MAPPING OF DE SAVE AREA
DESAVESZ DS    F                       SAVE AREA FOR DE SIZE
DESAVEDE DS    15F                     60 BYTE DE SAVE AREA
DESAVEND EQU   *                       END OF DE SAVE AREA
DESIZE   EQU   DESAVEND-DESAVE         SIZE OF SAVE AREA
         EJECT
***********************************************************************
*                                                                     *
*              COMMUNICATIONS VECTOR TABLE                            *
*                                                                     *
***********************************************************************
         CVT   DSECT=YES,PREFIX=NO
         EJECT
         IHAFETWK
         EJECT
         IHAFRRS
         EJECT
         IHAPSA
         EJECT
         IEZJSCB
         EJECT
         IHALLE
LLEND    EQU   *
LLESIZE  EQU   LLEND-LLE               SIZE OF LLE
         EJECT
         IHALPDE
LPDEEND  EQU   *                       END OF LPDE
LPDESIZE EQU   LPDEEND-LPDE            LENGTH OF LPDE
         EJECT
         IHAPDS
SIZEDECM EQU   PDSBCLN-1               EXECUTED PDS BASIC SIZE
DECOMSZ  EQU   SIZEDECM-NAMELTH        BASIC SIZE MINUS NAME LENGTH
         EJECT
         IHARB
***********************************************************************
*                                                                     *
*                  REQUEST BLOCK ADDITIONAL LABELS INTERNAL           *
*                                                                     *
***********************************************************************
         ORG   RBEXSAVE                MAPPED INTO RBEXSAVE AREA
RBCSEXSA EQU   *                       PROGRAM MANAGER USAGE OF
*                                      RB EXTENDED SAVE AREA FOR
*                                      REENTRANT DATA AREA
RBCSNAME DS    CL8                     ENTRY POINT NAME CALLER PASSED
RBCSDE   DS    0A                      ADDRESS OF DE SAVE AREA
         DS    C                       RESERVED BYTE ALWAYS ZERO
RBCSDEA  DS    AL3                     3 BYTE ADDRESS
RBCSERRA DS    F                       ADDRESS OF ERROR ROUTINE
RBCSFLG1 DS    B                       BLAG BYTE
RBCSGSF  EQU   X'80'                   GOOD SEARCH INDICATOR
*                                      ON MEANS IEAVVMSR OR CDSEARCH
*                                      WAS SUCCESSFUL
*                                      USED ONLY IN IEAVLK01 FOR
*                                      ADDRESSABILITY PROBLEMS
RBCSSYSR EQU   X'40'                   SYSTEM REQUEST FLAG
RBCSPARM EQU   X'20'                   PARAMETER CHECK FLAG
RBCSERIN EQU   X'10'                   ERROR RETURN REQUESTED
RBCSABEN EQU   X'08'                   ISSUE 906 ABEND
RBCSA306 EQU   X'04'                   ISSUE 306 ABEND
RBCRSAPF EQU   X'01'                   ATTACH WITH RESET APF   @WAB
RBCSFLG2 DS    B                       FLAG BYTE RESERVED
RBCSFLG3 DS    B                       FLAG BYTE RESERVED
RBCSFLG4 DS    B                       FLAG BYTE RESERVED
RBCSWORK DS    0A                      ADDRESS OF BLDL FETCH W.A.
         DS    C                       RESERVED BYTE ALWAYS ZERO
RBCSWRKA DS    AL3                     3 BYTE ADDRESS
RBCSLLE  DS    0A                      ADDRESS OF LLE DURING LOAD
         DS    C                       RESERVED BYTE ALWAYS ZERO
RBCSLLEA DS    AL3                     3 BYTE ADDRESS
RBCSFRRA DS    F                       SAVE AREA FOR PARM LIST USED
*                                      BE PGM MGR RECOVERY RTN.
RBCSGR15 DS    F                       SAVE AREA FOR REG 15 TO 1
RBCSGR0  DS    F                       AND USED AS PARAMETER
RBCSGR1  DS    F                       LIST FOR SVC'S
RBCSRESV DS    1F                      1 WORD OF 12 WORK SAVE AREA
*                                      RESERVED FOR FUTURE EXPANSION
RBCSEND  EQU   *                       END OF CS SECTION
CLRSIZE  EQU   RBCSEND-RBCSWORK        SIZE OF AREA TO ZERO
PRBX     EQU   RBFTPRB                 DENOTES A PRB
SVRB     EQU   RBFTSVRB                FIRST TWO BITS IN RBSTAB
*                                      INDICATE SVRB
PRBSIZ   EQU   PRBEND-RBSECT           SIZE OF A PRB
PRBSIZE  EQU   PRBLEN                  TOTAL SIZE (PRB + PREFIX)
*        FLAG SETTINGS FOR RBCDFLGS
LOAD     EQU   RBCDLOAD                ENTRY BY SVC LOAD
XCTL     EQU   RBCDXCTL                ENTRY BY SVC XCTL
SYNC     EQU   RBCDSYNC                ENTRY BY SVC SYNC
RBCSATT  EQU   RBCDATCH                ENTRY BY ATTACH
PRBPREF  EQU   RBPRFXND-RBPRFXST       LENGTH OF RB PREFIX
RBXXDSP  EQU   RBOPSW+4                USED FOR DISP PRIO IN CTL
RBOPSWA  EQU   RBOPSW+4                ADDRESS FIELD OF PSW
PRBWDLEN EQU   (PRBLEN+7)/8            LENGTH OF PRB IN DOUBLE WORDS
         SPACE 3
*        THE FOLLOWING CODE WAS ADDED FOR AOS2 TO MAKE ALL CODE
*         DEPENDANT OF THE RB DSECT SUPPLIED BY THE OFFICIAL MACRO
*          THE ORIGINAL EQUATES FOR THE NAMES WERE DELETED
*           AND THE PRB DSECT CHANGED
         SPACE 3
RBSECTZ  EQU   RBSECT-RBSECT           SET BASE OFFSET
RBSIZ1   EQU   RBSIZE-RBSECT           SIZE OF PRB FOR XCTL
RBSTABZ  EQU   RBSTAB-RBSECT           EXTRA LABEL
RBSTAB1Z EQU   RBSTAB1-RBSECT          EXTRA LABEL
RBCDEZ   EQU   RBCDFLGS-RBSECT         EXTRA LABEL
RBOPSWZ  EQU   RBOPSW-RBSECT           EXTRA LABEL
RBPGMQZ  EQU   RBPGMQ-RBSECT           EXTRA LABEL
RBLINKZ  EQU   RBWCF-RBSECT            EXTRA LABEL
RBWCFZ   EQU   RBWCF-RBSECT            EXTRA LABEL
RBCDE1Z  EQU   RBCDFLGS-RBSECT+1       CDE ADDRESS IN RB
RBXXDSPZ EQU   RBOPSWZ+4               USED FOR DISP PRIO
RBLINKAZ EQU   RBWCF-RBSECT+1          EXTRA LABEL
RBOPSW5Z EQU   RBOPSWZ+5               SAVE AREA FOR TCB ADDRESS
RBSTAB2Z EQU   RBSTAB2-RBSECT          EXTRA LABEL
RBPGMQ1Z EQU   RBPGMQ1-RBSECT          EXTRA LABEL
         SPACE 3
PRB      DSECT
PRBSTART DS    (PRBSIZ)C               USED TO DESCRIBE A PRB
PRBSTAB  EQU   PRB+RBSTAB-RBSECT       EXTRA LABEL
PRBSTAB2 EQU   PRB+RBSTAB2-RBSECT      PRB EQUATE FOR RBSTAB2
PRBFLGS  EQU   PRB+RBCDFLGS-RBSECT     EXTRA LABEL
PRBCDE   EQU   PRBFLGS+1               EXTRA LABEL
PRBOPSW  EQU   PRB+RBOPSW-RBSECT       EXTRA LABEL
PRBPGMQ  EQU   PRB+RBPGMQ-RBSECT       EXTRA LABEL
PRBWCF   EQU   PRB+RBWCF-RBSECT        EXTRA LABEL
PRBLINK  EQU   PRBWCF+1                EXTRA LABEL
PRBSIZE1 EQU   PRB+RBSIZE-RBSECT       EQUATE FOR 2 BYTE SIZE
         EJECT
***********************************************************************
*                                                                     *
*              TASK CONTROL BLOCK                                     *
*                                                                     *
***********************************************************************
         IKJTCB
TCBJLBDI EQU   TCBJLB-TCB              DISPLACEMENT IN TCB OF DCB ADR.
TCBMOTH  EQU   TCBOTC-TCB              DISPLACEMENT IN TCB OF MOTHER
TCBJSEZ  EQU   TCBJPQ-TCB              DISPLACEMENT TO JPAQ
         EJECT
         IEFTIOT1
         END
