         TITLE 'IGC041       IDENTIFY COMMENTARY'
* /* START OF SPECIFICATIONS ****
*
*01*  MODULE-NAME = IEAVID00
*
*02*     CSECT-NAME = IGC041
*
*01*  DESCRIPTIVE-NAME = IDENTIFY
*
*01*  COPYRIGHT = NONE
*
*01*  STATUS = Y02758 CHANGE LEVEL, VERSION 2
*
*01*  FUNCTION = TWO FOLD
*      A. TO IDENTIFY AN EMBEDED ENTRY TO THE SYSTEM
*
*        SEARCHES THE CDE QUEUES(JPAQ AND LPAQ) FOR THE AREA FROM WHICH
*        THE CURRENT RB'S PROGRAM MODULE COMES. IF THE IDENTIFIED NAME
*        IS FOUND TO BE PREEXISTENT, AN EXCEPTION CODE IS RETURNED TO
*        THE CALLER (SEE CPS FOR CODES). IF THE NAME IS NEW, THE
*        EXTENT LIST OF THE CURRENT RB'S CDE IS USED TO DETERMINE
*        WHETHER THE ENTRY POINT SPECIFIED AS THE SECOND OPERAND OF
*        THE IDENTIFY MACRO FALLS WITHIN THE CURRENT MODULE. IF NOT,
*        THE LOAD LIST (ORIGIN IS TCBLLS) OF THE CURRENT TASK IS
*        SEARCHED USING THE CDE POINTER IN EACH LLE TO LOCATE AND
*        EXAMINE ASSOCIATED EXTENT LISTS TO DETERMINE IF THE ENTRY
*        POINT IS WITHIN ANY MODULE LOADED BY THE CURRENT TASK. IF
*        THE ENTRY POINT CANNOT BE ASSOCIATED WITH A MODULE, AN
*        EXCEPTION CODE IS RETURNED.
*
*      B. TO IDENTIFY TO THE SYSTEM A SINGLE COPY MODULE LOADED
*        IN SUBPOOL 0
*
*        AN EXCEPTION CODE IS RETURNED IF
*           1. THE PARAMETER LIST HAS INVALID ENTRIES
*           2. THE ENTRY POINT NAME IS PREEXISTENT ON THE LPAQ OR THE
*           CALLER'S JPAQ CDE QUEUES
*           3. THE ENTRY POINT IS NOT WITHIN THE MODULE'S EXTENTS.
*         OTHERWISE A NEW CDE, FLAGGED NOT LOADABLE ONLY, IN
*         SUBPOOL ZERO, AND EXTENT LIST BUILT AND A ZERO USE COUNT, IS
*         QUEUED ON THE CALLER'S JPAQ.
*
*02*     OPERATION = THIS MODULE IS PROTECTED BY AN FRR RECOVERY
*        ROUTINE (FRRSVC41) WHICH VERIFIES THE APPROPRIATE CDE QUEUE
*        AND CAUSES RETRY TO A ROUTINE WHICH WILL RETURN CONTROL TO
*        THE CALLER WITH A RETURN CODE OF X'24' - UNEXPECTED SYSTEM
*        ERROR, REQUEST NOT COMPLETED.
*
*01*   NOTES = THE FOLLOWING IS A DESCRIPTION OF THE DEPENDENCIES,
*      CONVENTIONS, AND FUNCTIONS OF IEAVID00
*
*02*     DEPENDENCIES = THIS SVC ROUTINE MUST BE ENTERED WITH THE LOCAL
*        LOCK
*
*03*        CHARACTER-CODE-DEPENDENCIES = NONE
*
*02*     RESTRICTIONS = NONE
*
*02*     REGISTER-CONVENTIONS = THE REGISTER CONVENTIONS USED BY
*        IEAVID00 ARE DESCRIBED UNDER THE TOPIC REGISTER EQUATES.
*
*02*     PATCH-LABEL = ZAPSPACE (IN USE)
*
*01*  MODULE-TYPE = MODULE
*
*02*     PROCESSOR = ASSEMBLER
*
*02*     MODULE-SIZE = 1000 BYTES
*
*02*     ATTRIBUTES = PAGED-LPA, REENTERABLE, SUPERVISOR MODE, ENABLED,
*        TYPE 3 SVC
*
*01*  ENTRY-POINT = IGC041
*
*02*     PURPOSE = MAIN ENTRY TO IDENTIFY FUNCTION
*
*02*     LINKAGE = ENTERED FROM THE SVC INTERUP HANDLER
*
*02*     INPUT = PSW IS ENABLED, IN SUPERVISOR STATE, KEY 0, AND
*              AND HOLDS THE LOCAL LOCK ON ENTRY.
*              REGISTERS-
*              0- ADDR OF SYMBOLIC NAME OR PARAMETER LIST.
*              1- ADDR OF ENTRY POINT OR ZERO.
*              3- CVT ADDR
*              4- CURRENT TCB
*              5- CURRENT RB
*              14-RETURN ADDRESS
*              2,6-13,15- IRRELEVANT.
*
*02*     OUTPUT = NONE
*
*02*     REGISTERS-SAVED = NONE - REGISTERS SAVED BY INTERRUPT HANDLER
*        IN SVRB
*
*01*  ENTRY-POINT = FRRSVC41
*
*02*     PURPOSE = INSURE CDE QUEUES ARE NOT DAMAGED BY SYSTEM ERROR
*        AND PREVENT ABEND IF POSSIBLE BY RETURNING TO A ROUTINE WHICH
*        WILL SET A RETURN CODE OF X'24'
*
*02*     LINKAGE = BRANCH ENTERED BY RTM1 WHEN ERROR IS DETECTED
*
*02*     INPUT = REGISTERS ARE:
*            R1  = ADDRESS OF SDWA
*            R14 = RETURN ADDRESS
*
*02*     OUTPUT = NONE
*
*02*     REGISTERS-SAVED = NONE
*
*02*     REGISTER-USAGE = SEE PROLOGUE BEFORE RECOVERY ROUTINE
*
*01*  EXIT-NORMAL = IGC041
*
*02*     CONDITIONS = RETURN TO CALLER VIA BRANCH TO EXIT PROLOGUE
*
*02*     OUTPUT = PSW SAME AS UPON ENTRY
*            REGISTERS ARE:
*            R0-14 = UNCHANGED
*            R15   = RETURN CODE
*
*02*     RETURN-CODES = SEE PROLOGUE
*
*01*  EXIT-NORMAL = FRRSVC41
*
*02*     CONDITIONS = RETURN TO RTM1 VIA BR14 TO CAUSE RETRY IN
*        IEAVID00 WHICH WILL IN TURN CAUSE THE CALLERS TO RECEIVE
*        CONTROL WITH A RETURN CODE OF X'24' IN REGISTER 15
*
*02*     OUTPUT = REGISTERS ARE:
*            R0-13 = UNPREDICTABLE
*            R14   = RETURN ADDRESS
*
*02*     RETURN-CODES = SDWA CONTAINS THE FOLLOWING CODES:
*            0 - CONTINUE WITH TERMINATION
*            4 - RETRY AT ERROR EXIT IN IEAVID00
*
*01*  EXIT-ERROR = NONE
*
*02*     CONDITIONS = NONE
*
*02*     OUTPUT = NONE
*
*02*     RETURN-CODES = NONE
*
*01*  EXTERNAL-REFERENCES = IEAQCDSR
*
*02*     ROUTINES = GETMAIN - GET CDE
*            EXIT PROLOGUE - TO RELINQUISH CONTROL
*
*02*     DATA-AREAS = NO I/O IS DONE IN THIS MODULE, NO DATASETS OPENED
*        OR CLOSED
*
*02*     CONTROL-BLOCKS = AS FOLLOWS:
*      EMBEDED ENTRY POINT FUNCTION
*        CVT-
*              CVTQLPAQ- NOT ALTERED
*        TCB-
*              TCBJSTCB- NOT ALTERED
*              TCBJPA-   NOT ALTERED
*              TCBLLS-   NOT ALTERED
*        RB-
*              RBLINK-   NOT ALTERED
*              RBSTAB-   NOT ALTERED
*              RBCDE -   NOT ALTERED
*        CDE-
*              CDATTR-   ALTERED
*              CDNAME-   NOT ALTERED
*              CDCHAIN-  ALTERED
*              CDENTPT-  ALTERED
*              CDXLMJP-  ALTERED
*        LLE-
*              LLCHAIN-  NOT ALTERED
*              LLCDPTR-  NOT ALTERED
*        EXTENT LIST-
*              NOT ALTERED
*      SUBPOOL ZERO MODULE FUNCTION
*        CVT-
*              CVTMZ00
*              CVTLPAQ
*        TCB-
*              TCBMSS
*              TCBPKF
*              TCBJPAQ
*              TCBJSTCB-  ALTERED
*        RB-
*              RBSTAB
*              RBCDE
*              RBLINK
*        CDE-
*              CDATTR
*              CDNAME
*              CDCHAIN
*              CDXLMJP
*          NEW CDE IS BUILT
*
*        EXTENT LIST- NEW ONE IS BUILT
*
*01*  TABLES = MAJOR REQUEST INPUT PARAMETER LIST IS AS FOLLOWS:
*             *******************************************
*             *0       ENTRY POINT ADDRESS              *
*             ******                               ******
*             *4       ENTRY                            *
*             ***            POINT                    ***
*             *8                   NAME                 *
*             *******    START OF EXTENT LIST     *******
*             *12      LENGTH OF EXTENT LIST            *
*             ******                               ******
*             *16      NUMBER OF EXTENTS                *
*             *****                                ******
*             *20      LENGTH OF 1ST EXTENT             *
*             ******                               ******
*             *                                         *
*
*             *                                         *
*             ******                               ******
*             *'80'X * LENGTH OF LAST EXTENT            *
*             ******                               ******
*             *        ADDRESS OF 1ST EXTENT            *
*             ******                               ******
*             *                                         *
*
*             *                                         *
*             ******                               ******
*             *        ADDRESS OF LAST EXTENT           *
*             *******************************************
*
*01*  MACROS = GETMAIN,SETFRR,TESTAUTH,SETRP,RECORD,
*              CVT,IEZBITS,IHACDE,IHAFRRS,IHALLE,IHAPSA,IHARB,
*              IHASDWA,IKJTCB,MODID,SETLOCK
*
*02*    SERIALIZATION = THE LOCAL LOCK IS HELD ON ENTRY AND THE CMS
*       LOCK IS OBTAINED AND FREED DURING LPA QUEUE SEARCH AND
*       MANIPULATION
*
*01*  CHANGE-ACTIVITY = Y02758
*                       OZ17842 - SEE NEAR LABEL RECRDLPA     @ZA17842
*                       OZ20978 - NEAR LABEL LEGALEP CHANGE TO ONLY
*                                 BUILD MAJOR ON JOB PACK QUEUE FOR
*                                 MODULES LOADED BY NIP        @ZA20978
*                       OZ28584 - CHECK THAT AN ADDRESS GIVEN FOR
*                                 A NAME FOR A MINOR CDE IS NOT
*                                 IN FETCH-PROTECT STORAGE     @ZA28584
*                       OZ26744 - CHECK FOR RBCDE=0 IN CALLER'S
*                                 PRB                          @ZA26744
*                       OZ26745 - CHECK IF CDE CONTAINS AN EXTENT
*                                 LIST ADDRESS OR A MAJOR CDE
*                                 ADDRESS                      @ZA26745
*                       OZ26742 - CHECK THAT AN ADDRESS GIVEN FOR
*                                 A LIST FOR A MAJOR CDE IS NOT
*                                 IN FETCH-PROTECTED STORAGE   @ZA26742
*
*
*01*  MESSAGES = IEA959I - SYSTEM ERROR REQUIRED LPA QUEUE TO BE
*     TRUNCATED AND FIXED LPA MODULE CONTRIL MAY BE LOST
*     IDENTIFY THAT MODULE (WHERE POSSIBLE).;
*
*01*  ABEND-CODES = NONE
*
**** END OF SPECIFICATIONS ***/
         TITLE 'IGC041       IDENTIFY'
     SPACE 2
*/*IEAVID00: CHART IDENTIFY */
*/* HEADER
*/*
*/*
*/*
*/*                                                 SECTION 3.1.8.4
*/* IDENTIFY
*/*                                                 PAGE # */
         SPACE 2
*/*IGC041: E ENTRY FROM SLIH */
         SPACE 2
IGC041   START 0                       IDENTIFY SVC SERVICE
         SPACE 2
*/* P SET BASE IN REG 6 */
         SPACE 2
         BALR  BASEREG,N0              SET UP BASE ADDRESS
         USING *,BASEREG               REG 13 CONTAINS BASE ADDRESS
         MODID BR=YES                  CSECT IDENTIFIER
         USING PSA,0                   ADDRESSABILITY TO PSA
         SPACE 2
*/* P REG 3= CVT ADR REG 4= TCB ADR REG 5= RB ADR REG 12= CD ENTRY*/
         SPACE 2
         USING CVT,CVTREG              REG  3 CONTAINS CVT ADDRESS
         USING TCB,TCBREG              REG  4 CONTAINS TCB ADDRESS
         USING RBSECT,RBREG            REG  5 CONTAINS RB ADDRESS
         USING CDENTRY,CDEREG          REG 12 CONTAINS CD ENTRY ADDRESS
         SPACE 2
*/* P SET FRR STACK */
         SPACE 2
         LA    R13,FRRSVC41            GET FRR ADDRESS
         SETFRR A,FRRAD=(13),WRKREGS=(11,12),PARMAD=(10)
         USING PARMAD,R10                                      @ZA26742
         ST    RBREG,PARMSVRB          SAVE SVRB ADDRESS       @ZA26742
         ST    BASEREG,PARMBASE        PUT IDENTIFY BASE       @ZA26742
         MVI   PARMFLAG,N0             CLEAR FLAG BYTE         @ZA26742
         DROP  R10                                             @ZA26742
         SPACE 2
*/* P GET CALLER'S RB ADDRESS */
         SPACE 2
         L     RBREG,RBWCF             LOAD ADDR OF NEXT RB ON CHAIN
         SPACE 2
*/* D (YES,YESPRB,NO,) RB A PRB? */
         SPACE 2
         TM    RBSTAB,RBPRBF           IS RB A PRB I.E.=00XX XXXX
         BZ    YESPRB                  YES, CONTINUE
         SPACE 2
*/* P SET ERROR CODE = 16 IN REG 15 */
         SPACE 2
         LA    CODEREG,CODENPRB        NO, LOAD RB-NOT-PRB CODE
         SPACE 2
*/* R RETURN VIA BR 14 */
         SPACE 2
         B     EXIT1                   RETURN
         SPACE 2
*/*YESPRB: P GET ADDR OF CDE FOR MODULE ISSUING IDENTIFY */
         SPACE 2
YESPRB   L     CDEREG,RBCDFLGS         LOAD ADDR CD ENTRY
         LA    CDEREG,0(,CDEREG)       CLEAR HIGH ORDER BYTE   @ZA26744
         LTR   CDEREG,CDEREG           CDE ADDR ZERO?          @ZA26744
         BNZ   CDMINTST                BRANCH IF NOT           @ZA26744
         LA    CODEREG,CODENGEP        SET ERROR CODE          @ZA26744
         L     R11,TCBLLS              POINT TO FIRST LLE      @ZA26744
         LA    R11,0(,R11)             CLEAR HIGH ORDER BYTE   @ZA26744
         LTR   R11,R11                 IS THERE ONE?           @ZA26744
         BZ    EXIT1                   BR IF LOAD LIST EMPTY   @ZA26744
         USING LLE,R11                                         @ZA26744
         L     CDEREG,LLECDPT          GET CDE FOR FIRST LLE   @ZA26744
         DROP  R11                                             @ZA26744
         SPACE 2
*/* D (NO,TESTR1,YES,) CDE A MINOR? */
         SPACE 2
CDMINTST EQU   *                                               @ZA26744
         TM    CDATTR,CDMIN            IS IDENTIFIER A MINOR
         BZ    TESTR1                  NO, BRANCH AROUND LOADING MAJOR
         SPACE 2
*/* P GET ADDR OF MAJOR FROM MINOR */
         SPACE 2
         L     CDEREG,CDXLMJP          YES, LOAD ADDR MAJOR ENTRY
         SPACE 2
*/*TESTR1: P GET IDENTIFY SVRB AND CLEAR EXTENDED SAVE AREA */
         SPACE 2
TESTR1   DS    0H                      TEST FOR AOS LOADER
         L     RBREG,TCBRBP            GET IDENTIFY SVRB
         XC    RBEXSAVE(N20),RBEXSAVE  CLEAR EXTENDED SAVE AREA
         SPACE 2
*/* P SET UP INPUT R9 = R0 R10 = R1 */
         SPACE 2
         LR    R13,R10                 SAVE FRR PARM ADDRESS   @ZA28584
         LR    PNREG,INREG1            PUT ENTRY POINT IN WORK REG
         LR    X2,INREG2               PUT NAME OR LIST IN WORKING REG
         SPACE 2
*/* D (YES,MAJORCDE,NO,) REQUEST TO CREATE A MAJOR? */
         SPACE 2
         LTR   INREG1,INREG1           IS MAJOR CDE REQUESTED
         BZ    MAJORCDE                YES, BRANCH
         SPACE 2
         USING PARMAD,R13                                      @ZA26742
         MVI   PARMFLAG,PARMFTCH       INDICATE FETCH PROTECT  @ZA26742
         MODESET EXTKEY=RBT234,WORKREG=2 GET INTO USER KEY     @ZA28584
         IC    R2,N0(,R9)              ADDRESS FIRST BYTE      @ZA28584
         IC    R2,N7(,R9)              ADDRESS LAST BYTE       @ZA28584
         MODESET EXTKEY=ZERO           RETURN TO ZERO KEY      @ZA28584
         MVI   PARMFLAG,N0             REMOVE FETCH INDICATOR  @ZA26742
         DROP  R13                                             @ZA26742
         SPACE 2                                               @ZA28584
*/* S NOMIN:CHECK FOR DUP NAME */
         SPACE 2
         BAL   RETREG,NOMIN            CHECK FOR DUP NAME
         SPACE 2
*/*USUAL: P GET ADDR OF LLE QUEUE HEADER IN TCB */
         SPACE 2
USUAL    DS    0H                      RETURN IF NAME NOT FOUND
         LA    TLLSREG,TCBLLS          LOAD TCBLLS ADDR
         SPACE 2
*/* S XLINST:CHECK IF EPA INVALID CDE */
         SPACE 2
         BAL   RETREG,XLINST           CHECK ENTRY POINT PASSED
         SPACE 2
*/*LEGALEP: D (NO,GETCDE,YES,) MAJOR FROM AUTHORIZED LIBRARY? */
         SPACE 2
LEGALEP  DS    0H                      RETURN IF GOOD ENTRY POINT
         LA    XLREG,N1                SET AUTH SWITCH         @ZA20978
         L     ASCBREG,PSAAOLD         GET ASCB ADDRESS FOR GETMAIN
         TM    CDATTR2,CDSYSLIB        Q. MODULE FROM A SYSTEM LIBRARY
         BZ    GETCDE                  A. NO- GET APPROPRIATE CDE
         SPACE 2
*/* S TESTAUTH:TEST AUTH OF CALLER */
         SPACE 2
         TESTAUTH KEY=YES,STATE=YES,FCTN=1,BRANCH=YES TEST AUTH. OF
*                                      CALLER
         SPACE 2
*/* D (YES,GETCDE,NO,) IS CALLER AUTHORIZED? */
         SPACE 2
         LTR   CODEREG,CODEREG         Q. CALLER AUTHORIZED
         BZ    GETCDE                  YES- GET APPROPRIATE CDE
         SR    XLREG,XLREG             SET UNAUTH SWITCH       @ZA20978
         TM    CDATTR,CDNIP            MODULE LOADED BY NIP?   @ZA20978
         BZ    GETLSQS                 NO THEN MINOR CDE       @ZA20978
         SPACE 2
*/* S GETMAIN:GET CDE FOR LPA FROM LSQA (SP=255) */
         SPACE 2
*  SPECIAL CODE FOR NON-AUTHORIZED CALLER'S WHO DO IDENTIFY TO
*      AUTHORIZED LIBRARIES
         SPACE 2
         GETMAIN RU,SP=255,LV=CDESIZE,BRANCH=YES  GET LSQA CDE
         SPACE 2
*/* P CLEAR GOTTEN AREA AND PUT EPA IN CDE */
*/* P NOTE: THERE IS NO XL FOR THIS MODULE */
*/* P NOTE: SYSTEM LIBRARY AND MODULE AUTHORIZATION TURNED OFF */
         SPACE 2
         DROP  CDEREG
         USING CDENTRY,WKREG1
         XC    CDENTRY(CDESIZE),CDENTRY CLEAR GOTTEN AREA
         ST    X2,CDENTPT              PUT SPECIFIED ENTRY IN CDE
         SPACE 2
*/* P PUT NAME IN MINOR */
         SPACE 2
         MVC   CDNAME(NAME),N0(PNREG)  PUT GIVEN NAME IN CDE
         SPACE 2
*/* P SET USE COUNT = 0 */                                       @M7644
         SPACE 2
         SR    WKREG2,WKREG2           SET UP FOR USE COUNT      @M7644
         STH   WKREG2,CDUSE            SET USE COUNT = 0         @M7644
         SPACE 2
*/* P COPY ATTRIBUTES FROM MAJOR */
         SPACE 2
         MVC   CDATTR(N1),CDATTR-CDENTRY(CDEREG)  COPY IN ATTRIBUTES
         NI    CDATTR,MAX-CDNIP-CDNIC-CDMIN-CDNFN TURN OFF       @M7644
*                                      NECESSARY BITS
         OI    CDATTR,CDJPA            AND TURN ON JPA BIT
         TM    CDATTR2-CDENTRY(CDEREG),CDOLY  MAJOR IN OVERLAY
         BZ    CHAINCDE                NO- DON'T SET IN MINOR
         OI    CDATTR2,CDOLY           SET OVERLAY BIT
         SPACE 2
*/*CHAINCDE: P (,RETURN) CHAIN CDE TO TOP OF JPQ */
         SPACE 2
CHAINCDE L     WKREG2,TCBJSTCB         GET JOBSTEP TCB
         LA    WKREG2,TCBJPQ-TCB(WKREG2) GET JPQ FIELD
         MVC   CDCHAIN(N4),N0(WKREG2)  CHAIN CDE TO TOP
         ST    WKREG1,N0(WKREG2)       OF JPQ
         B     RETURN                  RETURN TO CALLER
         DROP  WKREG1
         USING CDENTRY,CDEREG          RESET ADDRESSING TO MAJOR
         SPACE 2
*/*GETCDE: D (NO,GETLSQS,YES,) MAJOR CDE IN LPAQ? */
         SPACE 2
GETCDE   DS    0H                      DETERMINE TYPE OF CDE
         TM    CDATTR,CDNIP            IS MAJOR ENTRY IN LPAQ
         BZ    GETLSQS                 NO - GET MINOR FROM LSQS
         SPACE 2
*/*S SETLOCK:GET CMS LOCK FOR LPA CHANGE */
         SPACE 2
         STM   R11,R12,RBEXSAVE+N4     SAVE VOLITAL REGS
         SETLOCK OBTAIN,TYPE=CMS,MODE=UNCOND,RELATED=EXIT GET CMS
         LM    R11,R12,RBEXSAVE+N4     RESTORE VOLITAL REGS
         SPACE 2
*/* S (,CDESETUP) GETMAIN:GET CDE FOR LPA FROM SQA (SP=245) */
         SPACE 2
         GETMAIN RU,SP=245,LV=CDESIZE,BRANCH=YES GET SQA CDE
         B     CDESETUP                INITIALIZE CDE
         SPACE 2
*/*GETLSQS: S GETMAIN:GET CDE FROM LSQS (SP=255) */
         SPACE 2
GETLSQS  GETMAIN RU,SP=255,LV=CDESIZE,BRANCH=YES GET LSQS CDE
         SPACE 2
*/*CDESETUP: P PUT EPA AND SET CDUSE IN MINOR TO 0 */
         SPACE 2
CDESETUP DS    0H
         DROP  CDEREG                  CHANGE CDE PTRS
         USING CDENTRY,INREG2          CHANGE CD ENTRY REGISTER TEMP
         XC    CDENTRY(CDESIZE),CDENTRY   CLEAR CDE AREA OBTAINED
         ST    X2,CDENTPT              INITIALIZE CDENTPT
         SPACE 2
*/* P PUT MAJOR POINTER IN MINOR */
         SPACE 2
         LA    CDEREG,N0(CDEREG)       ZERO HIGH BYTE OF MAJOR CDE ADDR
         ST    CDEREG,CDXLMJP          INITIALIZE CDXLMJP
         SPACE 2
*/* P PUT NAME IN MINOR */
         SPACE 2
         MVC   CDNAME(NAME),N0(PNREG)  STORE PROGNAMES
         SPACE 2
*/* P SET MINOR MIN,REN,SER,NLR */
         SPACE 2
         MVI   CDATTR,CDMIN+CDREN+CDSER+CDNLR  SET FLAGS IN CDENTRY
         SPACE 2
*/* D (NO,NOTAPF,YES,) IS MAJOR CDE AUTHORIZED? */
         LTR   XLREG,XLREG             SHOULD AUTH BE COPIED   @ZA20978
         BZ    NOTAPF                  NO USER WAS NOT AUTH    @ZA20978
         SPACE 2
         TM    CDATTR2-CDENTRY(CDEREG),CDAUTH CHECK AUTHORITY
         BNO   NOTAPF                  IF NOT AUTHORIZED SKIP BIT SET
         SPACE 2
*/* P SET AUTHORIZED BIT IN MINOR */
         SPACE 2
         OI    CDATTR2,CDAUTH          SET AUTHORIZED MINOR
         SPACE 2
*/*NOTAPF: D (NO,CDMEADD,YES,) NIP ON IN MAJOR? */
         SPACE 2
NOTAPF   EQU   *                       APF CHECKING DONE
         TM    CDATTR-CDENTRY(CDEREG),CDNIP IS NIP ATTR OF MAJOR CDE.
         BZ    CDMEADD                 NO, DON'T SET ATTR IN MINOR
         SPACE 2
*/* P SET NIP BIT IN MINOR */
         SPACE 2
         OI    CDATTR,CDNIP            SET NIP ATTR IN MINOR.
         DROP  INREG2                  REESTABLISH BASE
         USING CDENTRY,CDEREG          TO CD MAJOR ENTRY
         SPACE 2
*/*CDMEADD: P POINT MINOR TO NEXT OFF MAJOR */
         SPACE 2
*  CDMEADD INPUT = MAJOR CDE ADDR IN CDEREG, MINOR CDE ADDR IN INREG2
         SPACE 1
CDMEADD  MVC   CDCHAIN-CDENTRY(N4,INREG2),CDCHAIN ADDR OF MAJ IN MIN.
         SPACE 2
*/* P POINT MAJOR TO MINOR */
         SPACE 2
         ST    INREG2,CDCHAIN          CHAIN MINOR TO QUEUE
         SPACE 2
*/*RETURN: P (,EXIT1) SET RETURN CODE REG 15 = 0 */
         SPACE 2
RETURN   EQU   *                       NORMAL RETURN
         SR    CODEREG,CODEREG         NORMAL COMPLETION CODE IS ZERO
         B     EXIT1                   RETURN
         TITLE 'IGC041 - IDENTIFY - AOS LOADER MAJOR CDE FUNCTION'
*  THIS SECTION OF CODE IS USED BY AOS LOADER TO CREATE A MAJOR CDE.
         SPACE 2
*/*MAJORCDE: P SAVE PARM LIST ADDRESS */
*/* P SET RETURN CODE (R15) = 24 */
         SPACE 2
         USING PARMAD,R13                                      @ZA26742
         USING IDLIST,X2                                       @ZA26742
MAJORCDE DS    0H
         OI    PARMFLAG,PARMFTCH       INDICATE FETCH PROTECT  @ZA26742
*                                      IF FRR ENTERED          @ZA26742
         MODESET EXTKEY=RBT234,WORKREG=2  GET IN CALLER KEY    @ZA26742
         IC    R2,IDENTRY              ADDRESS FIRST BYTE      @ZA26742
         LA    R2,IDXLNTH              POINT TO LENGTH OF LIST @ZA26742
         LA    R15,MAXLNTH             INSERT X'FFF' IN R15    @ZA26742
         LA    R15,N1(,R15)            INCREASE TO 1000        @ZA26742
         L     XLREG,IDXLNTH           SAVE LENGTH OF LIST     @ZA26742
*                                      XLREG MUST BE PRSERVED  @ZA26742
*                                      THROUGH XLMULT8         @ZA26742
         AR    R2,XLREG                ADD LENGTH OF LIST      @ZA26742
         BCTR  R2,0                    POINT TO LAST BYTE      @ZA26742
CHKBYTE  EQU   *                                               @ZA26742
         IC    R14,0(,R2)              ADDRESS LAST BYTE       @ZA26742
         SR    R2,R15                  DECREASE BY A PAGE      @ZA26742
         CR    R2,X2                   CHECKED ALL OF LIST?    @ZA26742
         BH    CHKBYTE                 BRANCH IF NOT           @ZA26742
         MODESET EXTKEY=ZERO           GET BACK TO KEY ZERO    @ZA26742
         MVI   PARMFLAG,N0             REMOVE FETCH PROT IND   @ZA26742
         SPACE 2                                               @ZA26742
         SLL   INREG2,N30              IS PARM LIST ON
         LA    CODEREG,ILIST           SET RETURN CODE IN CASE OF ERROR
         SPACE 2
*/* D (NO,EXIT1,YES,) LIST ON FULL WORD BOUNDARY? */
         SPACE 2
         LTR   INREG2,INREG2           WORD BOUNDARY
         BNZ   EXIT1                   NO, BRANCH
         SPACE 2
*/* D (NO,EXIT1,YES,) XL ADDRESS POSITIVE? */
         SPACE 2
         LTR   XLREG,XLREG             IS EXTENT LENGTH POS?   @ZA26742
         BNP   EXIT1                   NO, RETURN              @ZA26742
         SPACE 2
*/* P SET UP TO GET CDE AND XL IN LSQA */
         SPACE 2
         LA    WKREG1,CDESIZE          GET SIZE OF CDE
         AR    WKREG1,XLREG            ADD EXLIST LIST SIZE    @ZA26742
         L     ASCBREG,PSAAOLD         GET ASCB FOR GETMAIN
         SPACE 2
*/* S GETMAIN:GET CDE,XL FROM LSQA VIA BR */
         SPACE 2
         GETMAIN RU,SP=255,LV=(INREG2),BRANCH=YES GET CDE, XL FROM LSQA
         SPACE 2                                               @ZA26742
         ST    R1,PARMGETM             SAVE AREA ADDRESS       @ZA26742
         STH   XLREG,PARMGETL          SAVE LENGTH OF XL       @ZA26742
         OI    PARMFLAG,PARMGTMN       INDICATE GETMAIN AREA   @ZA26742
         DROP  R13                                             @ZA26742
         DROP  CDEREG                  CHANGE CDE BASE
         DROP  X2                                              @ZA26742
         USING CDENTRY,X2              CHANGE CDE BASE         @ZA26742
         LR    PNREG,X2                SAVE INPUT LIST TEMP    @ZA26742
         LR    X2,WKREG1               GET ADDRESS OF CDE      @ZA26742
         LR    WKREG1,PNREG            GET ADDRESS OF INPUT    @ZA26742
         USING IDLIST,WKREG1                                   @ZA26742
         SPACE 2
*/* P CLEAR NEW CDE */
*/* P PUT ENTRY POINT NAME IN CDE */
         SPACE 2
         XC    CDENTRY(CDESIZE),CDENTRY  CLEAR CDE               M01967
         MVC   CDNAME(N8),IDNAME       MOVE IN EP NAME         @ZA26742
         SPACE 2
*/* P PUT ENTRY POINT ADDRESS IN CDE */
         SPACE 2
         MVC   CDENTPT(N4),IDENTRY     MOVE IN EP ADDRESS      @ZA26742
         SPACE 2
*/* P INITIALIZE XL FIELDS IN CDE */
         SPACE 2
         USING XTLST,PNREG                                     @ZA26742
         LA    PNREG,CDEEND            LOCATE XTENT LIST AT END OF CDE
         SPACE 2
*/* P SET SPZ (SUBPOOL 0) AND XLE IN CDE */
         SPACE 2
         ST    PNREG,CDXLMJP           STORE EXTENT LIST ADDR IN CDE
         MVI   CDATTR2,CDSPZ+CDXLE     SET UP 2ND ATTRIBUTE FIELD
         SPACE 2
*/* P MOVE XL FROM PARM LIST TO XL IN CDE */
         SPACE 2
         LR    R15,XLREG               GET LENGTH OF EXTENT    @ZA26742
         LR    CVTREG,R15              PUT LENGTH IN R3        @ZA26742
         LA    WKREG2,CDEEND           POINT TO START OF EXTNT @ZA26742
         LA    R14,IDXLNTH             POINT TO EXTENT LIST    @ZA26742
         MVCL  WKREG2,R14              MOVE LIST INTO SP 255   @ZA26742
         L     CVTREG,CVTPTR           RESTORE CVT POINTER     @ZA26742
         SPACE 2                                               @ZA26742
*/* D (NO,EXIT1,YES,) IS FIRST BYTE A CHARACTER? */
         SPACE 2
         LA    CODEREG,ILIST           RESTORE ERROR CODE      @ZA26742
         L     WKREG2,CDENTPT          GET ENTRY POINT VALUE   @ZA26742
         LTR   WKREG2,WKREG2           IS ENTRY POINT VALID?   @ZA26742
         BNP   STXLREG                 BRANCH IF NOT           @ZA26742
         SPACE 2
*/* P SET RETURN CODE (R15) = 28 */
         SPACE 2
         LA    CODEREG,IPARM           SET PARM ERROR RETURN CODE
         SPACE 2                                               @ZA26742
         C     XLREG,XTLLNTH           CORRECT LENGTH?         @ZA26742
         BE    XLMULT8                 BRANCH IF YES           @ZA26742
STXLREG  EQU   *                                               @ZA26742
         ST    XLREG,XTLLNTH           STORE LENGTH IN LIST    @ZA26742
         B     EXITFREE                BRANCH TO FREE ROUTINE  @ZA26742
         SPACE 2
*/* D (NO,EXIT1,YES,) XL A MULTIPLE OF 8? */
         SPACE 2
XLMULT8  EQU   *                                               @ZA26742
         SLL   XLREG,N29               SHIFT OFF 29 BITS       @ZA26742
         LTR   XLREG,XLREG             DOUBLE WORD BOUNDARY?   @ZA26742
         BNZ   EXITFREE                NO, RETURN              @ZA26742
         SPACE 2
*/* P GET NUMBER OF EXTENTS FROM XL IN PARM LIST */
         SPACE 2
         L     WKREG5,XTLNRFAC         GET NUMBER OF EXTENTS   @ZA26742
         LTR   XLREG,WKREG5            IS NUM OF EXTENTS ZERO?
         BZ    NAMETEST                NO EXTENTS, TEST FOR DUP NAME
         LR    WKREG1,XLREG            GET NUMBER OF EXTENTS   @ZA26742
         LA    WKREG1,N1(,WKREG1)      ADD ONE FOR HEADER      @ZA26742
         SLL   WKREG1,N3               MULTIPLY BY 8           @ZA26742
         C     WKREG1,XTLLNTH          ARE LENGTHS EQUAL?      @ZA26742
         BNE   EXITFREE                BRANCH IF NOT           @ZA26742
         SLL   XLREG,N2                CAL. DISPL. TO EXTENT ADDR
         LA    WKREG1,XTLMSBLA(XLREG)  LOCATE 1ST EXTENT ADDR  @ZA26742
         SPACE 2
*/*CONTEST: P GET ADDRESS OF EXTENT */
         SPACE 2
CONTEST  DS    0H                      GO TO TEST
         L     WKREG2,N0(WKREG1)       LOCATE NEXT EXTENT
         SPACE 2
*/* D (NO,EXIT1,YES,) IS EXTENT ON DOUBLE WORD BOUNDARY? */
         SPACE 2
         SLL   WKREG2,N29              ON DOUBLE WORD
         LTR   WKREG2,WKREG2           BOUNDARY
         BNZ   EXITFREE                NO                      @ZA26742
         SPACE 2
*/*NXEXT: P GET ADDRESS OF NEXT ADDR AND LENGTH LIST ENTRY */
         SPACE 2
NXEXT    DS    0H                      TEST NEXT EXTENT
         LA    WKREG1,N4(WKREG1)       LOCATE NEXT EXTENT ADDR
         SPACE 2
*/* P (GT 0,CONTEST,=0,) DECREMENT NO EXTENTS BY 1 */
         SPACE 2
         BCT   WKREG5,CONTEST          HAS LAST EXTENT BEEN TESTED
         SPACE 2
*/*NAMETEST: P GET ADDRESS OF ENTRY POINT NAME IN R9 */
         SPACE 2
NAMETEST DS    0H                      TEST NAME PASSED
         LA    WKREG2,XTLLNTH          SAVE ADDRESS OF LIST    @ZA26742
         DROP  PNREG                                           @ZA26742
         LA    PNREG,CDNAME            POINT TO NAME           @ZA26742
         SPACE 2
*/* S NOMIN:FIND CDE ON JPA ON LPA */
         SPACE 2
         BAL   RETREG,NOMINA           IS THE NAME A DUPLICATE
         SPACE 2
*/* P GET ADDRESS OF EXTENT LIST */
         SPACE 2
         LR    XLREG,WKREG2            GET ADDRESS OF LIST     @ZA26742
         SPACE 2
*/* P INDICATE NO LLEQ SEARCH */
         SPACE 2
         LA    TLLSREG,ZERO            INDICATE ONLY ONE LIST TO TEST
         SPACE 2
*/* P SAVE ADDRESS OF PARM LIST */
         SPACE 2
         LR    SAVEREG,X2              SAVE INPUT PARM
         SPACE 2
*/* P GET ENTRY POINT ADDR FOR TEST */
         SPACE 2
         L     X2,CDENTPT              POINT TO ENTRY POINT    @ZA26742
         SPACE 2
*/* S CDEPTEST:IN EPA IN THIS EXTENT */
         SPACE 2
         BAL   RETREG,CDEPTEST         IS ENTRY POINT IN EXTENT
         SPACE 2
*/* P RESTORE PARM LIST ADDRESS */
         SPACE 2
         LR    X2,SAVEREG              RESET INPUT PARM
         SPACE 2
*/* P ENQUEUE CDE FIRST OFF JOBSTEP CDE QUE */
         SPACE 2
         L     PNREG,TCBJSTCB          LOCATE JOB STEP TCB
         DROP  TCBREG                  CHANGE TCB ADDRESSING
         USING TCB,PNREG               CHANGE TCB ADDRESSING
         MVC   CDCHAIN+N1(N3),TCBJPQ+N1  MOVE LAST CDE INTO NEW CDE
         ST    X2,TCBJPQ               QUEUE NEW CDE ON TCB    @ZA26742
         SPACE 2
*/* P (,RETURN) SET CDE NLR */
         SPACE 2
         MVI   CDATTR,CDNLR            SET 1ST ATTRIBUTE FIELD
         B     RETURN                  SET ZERO CODE AND RETURN
         DROP  PNREG                   SWITCH TCB BASE
         USING TCB,TCBREG              SWITCH TCB REG
         DROP  INREG2                  CHANGE CDE ADDRESSING
         USING CDENTRY,CDEREG          RESET TO CDE REGISTER
         TITLE 'IGC041 - IDENTIFY - SUBROUTINES'
*        NOMIN SEARCHES  THE JPAQ AND LPAQ FOR A DUPLICATE
*        TO THE NAME PASSED ON ENTRY.  IF A DUPLICATE NAME IS FOUND, AN
*        ERROR CODE IS PASSED BACK TO THE USER. OTHERWISE RETURN IS TO
*        ADDRESS IS REGISTER 7.
*        REGISTER USAGE
*        R0,1  - ALTERED
*        R3,4  - CVT,TCB (INPUT)
*        R6    - BASE REGISTER (INPUT)
*        R8    - ALTERED
*        R11,13- ALTERED
*        R12   - SET TO NAME ADDRESS (OUTPUT)
*        R14   - RETURN ADDRESS (INPUT)
*        R15   - ALTERED
*        OTHER REGISTERS NOT REFERENCED
         SPACE 1
         SPACE 2
*/*NOMIN: E ENTRY NOMIN */
*/* P SET QUEUE POINTER (RB) TO JPQ OF JSTCB */
*/* P NOTE: CDE NAME HAS ALREADY BEEN PLACED IN REG 9 */
         SPACE 2
NOMIN    EQU   *                                               @ZA26742
         N     RETREG,ZEROMASK         CLEAR HIGH BIT          @ZA26742
         B     NOMIN1                  JOIN MAINLINE PROCESS   @ZA26742
NOMINA   EQU   *                                               @ZA26742
         O     RETREG,MINMASK          INDICATE NOMINA ENTRY   @ZA26742
NOMIN1   EQU   *                                               @ZA26742
         L     WKREG4,TCBJSTCB         LOAD PTR TO JOB STEP TC @ZA26742
         LA    WKREG4,TCBJPQ-TCB(N0,WKREG4) LOAD PTR TO 1ST CDE.
         LR    SAVEREG,RETREG          SAVE RETURN ADDRESS
         SPACE 2
*/* P GET ADDRESS OF IEAQCDSR FROM CVT */
         SPACE 2
         L     CODEREG,CVTQCDSR        GET SEARCH ROUTINE ADDRESS
         SPACE 2
*/* S IEAQCDSR:SEARCH JPQ FOR MODULE */
         SPACE 2
         BALR  RETREG,CODEREG          SEARCH CDE QUEUE
         SPACE 2
*/* D (YES,UNUSUAL,NO,) MODULE FOUND? */
         SPACE 2
         B     UNUSUAL                 IF FOUND,BRANCH
         SPACE 2
*/*SRCHLPA: S SETLOCK:GET CMS LOCK */
         SPACE 2
SRCHLPA  EQU   *                       LPAQ SEARCH
         STM   R11,R14,RBEXSAVE+N4      SAVE VOLITAL REGS
         SETLOCK OBTAIN,TYPE=CMS,MODE=UNCOND,RELATED=BETWEEN-SRCHPLA
*                                  UNUSUAL CMS LOCK REQUIRED FOR LPA
         SPACE 2
*/* P GET ADDRESS OF IEAQCDSR FROM CVT */
         SPACE 2
         L     WKREG4,CVTQLPAQ         LOAD PTR TO FIRST CDE IN LPA
         L     CODEREG,CVTQCDSR        GET SEARCH ROUTINE ADDRESS
         SPACE 2
*/* S IEAQCDSR:SEARCH LPA FOR MODULE */
         SPACE 2
         BALR  RETREG,CODEREG          TRY LPA SEARCH
         OI    RBEXSAVE,NAMEFND         SET DUPLICATE NAME INDICATOR
         ST    R11,RBEXSAVE+N4         SAVE CDE POINTER
         SPACE 2
*/* S SETLOCK: FREE CMS LOCK */
         SPACE 2
         SETLOCK RELEASE,TYPE=CMS,RELATED=SRCHPLAP CMS NO LONGER NEEDED
         LM    R11,R14,RBEXSAVE+N4      RESTORE VOLITAL REGS
         SPACE 2
*/* D (YES,UNUSUAL,NO,) MODULE FOUND? */
         SPACE 2
         TM    RBEXSAVE,NAMEFND         TEST IF NAME FOUND
         BO    UNUSUAL                 IF SO, BRANCH
         SPACE 2
*/* R RETURN VIA R14 */
         SPACE 2
         LR    RETREG,SAVEREG          RESET RETURN REGISTER
         BR    RETREG                  RETURN TO CALLER SUCCESSFUL
         SPACE 2
*/*UNUSUAL: D (YES,UNNECODE,NO,) CDE A MINOR? */
         SPACE 2
UNUSUAL  EQU   *                       ERROR ON NAME SEARCH
         TM    CDATTR-CDENTRY(R11),CDMIN IS FOUND CDE A MINOR.
         BO    UNNECODE                YES
         SPACE 2
*/* P (,EXIT1) SET RETURN CODE = 8 */
         SPACE 2
         LA    CODEREG,CODEANEQ        NO, LOAD MULTIPLE-NAME CODE
         LTR   SAVEREG,SAVEREG         ENTRY FROM NOMINA?      @ZA26742
         BM    EXITFREE                BRANCH IF YES           @ZA26742
         B     EXIT1                   RETURN
         SPACE 2
*/*UNNECODE: P SET RETURN CODE = 4 */
         SPACE 2
UNNECODE LA    CODEREG,CODEUN          LOAD UNNECESSARY-IDENTIFY CODE
         SPACE 2
*/* P GET EPA FROM MINOR CDE */
         SPACE 2
         L     WKREG2,CDENTPTZ(R11)    LOAD ENTRY PT FROM FOUND CDE
         SPACE 2
*/* D (YES,EXIT1,NO,) ENTRY POINT ADDR MATCH? */
         SPACE 2
         LA    WKREG2,N0(WKREG2)       ZERO HIGH ORDER BYTE
         CR    WKREG2,X2               ARE ENTRY POINTS EQUAL.
         BE    EXITTEST                YES, CODE ALREADY LOADED. RETURN
         SPACE 2
*/* P SET RETURN CODE = 20 */
         SPACE 2
         LA    CODEREG,CODEBADM        NO, LOAD BAD-MINOR CODE
EXITTEST EQU   *                                               @ZA26742
         LTR   SAVEREG,SAVEREG         ENTRY FROM NOMINA?      @ZA26742
         BNM   EXIT1                   BRANCH IF NOT           @ZA26742
EXITFREE EQU   *                                               @ZA26742
         L     ASCBREG,PSAAOLD         GET ASCB FOR FREEMAIN   @ZA26742
         LA    R1,CDESIZE              GET SIZE OF CDE         @ZA26742
         A     R1,CDESIZE(X2)          ADD SIZE OF XL          @ZA26742
         LR    WKREG2,CODEREG          SAVE RETURN CODE        @ZA26742
         FREEMAIN RU,LV=(R1),A=(X2),SP=255,BRANCH=YES          @ZA26742
         LR    CODEREG,WKREG2          RESTORE RETURN CODE     @ZA26742
         SPACE 2
*/*EXIT1: S SETFRR:RESTORE STACK */
         SPACE 2
EXIT1    DS    0H                       RETURN
         SETFRR D,WRKREGS=(3,4)         FREE FRR
         SPACE 2
*/* P GET ADDRESS OF EXIT PROLOG IN R14 */
         SPACE 2
         L     CVTREG,CVTPTR           GET POINTER TO CVT
         L     R14,CVTEXPRO            GET ADDRESS OF EXIT PROLOG
         SPACE 2
*/* R RETURN VIA R14 */
         SPACE 2
         BR    R14                     EXIT
         EJECT
*        FOR MINOR CDE, THIS ROUTINE CHECKS IF THE ENTRY POINT PASSED
*        IS WITHIN THE BOUNDS OF THE MODULE WHICH ISSUED THE IDENTIFY
*        OR WITHIN ANY MODULE ON THE LOAD LIST FOR ITS TASK.  THE
*        ROUTINE EITHER RETURNS SUCCESSFULLY, OR GIVES A ERROR CODE
*        TO THE IDENTIFYING MODULE.
*        FOR MAJOR CDE, THE INPUT IS PRESET FOR ONLY A SINGLE EXTENT
*        LIST CHECK. THE LOAD LIST POINTER IS SET TO POINT TO A FULL
*        WORD FIELD OF ZEROS, AND THE SUBROUTINE IS ENTERED AT
*        CDEPTEST INSTEAD OF XLINST.
*
*        REGISTER USAGE
*        R2,4,5,7,8 - MODIFIED
*        R6  - BASE
*        R9  - TCBLLS ADDRESS (INPUT)
*        R10 - ADDRESS OF ENTRY POINT (INPUT)
*        R11 - MODIFIED
*        R12 - MAJOR CDE ADDRESS (INPUT/OUTPUT)
*        R14 - RETURN REGISTER (INPUT)
*        OTHER REGISTERS NOT REFERENCED
         SPACE 1
         SPACE 2
*/*XLINST: E XLINST/CDEPTEST ENTRY */
*/* P GET ADDRESS OF XL FOR MAJOR CDE */
         SPACE 2
         USING LLE,TLLSREG             TEMP USE TLLSREG FOR LLE
XLINST   EQU   *                                               @ZA26745
         L     XLREG,CDXLMJP           LOAD EXTENT LIST ADDR   @ZA26745
         LA    XLREG,0(,XLREG)         CLEAR HIGH ORDER BYTE   @ZA26745
         LTR   XLREG,XLREG             IS THERE AN ADDRESS?    @ZA26745
         BZ    NGENTPT                 SKIP CDE IF ZERO        @ZA26745
         SPACE 1
* VALID ENTRY POINT TEST  INPUT-EXTENT LIST IN XLREG,ENTPT IN X2
         SPACE 2
*/*CDEPTEST: P GET NUMBER OF EXTENTS FROM XL */
         SPACE 2
CDEPTEST L     WKREG1,N4(XLREG)        LOAD NUMBER OF BLOCKS
         SPACE 2
*/* P GET ADDRESS OF ADDRESS LIST */
         SPACE 2
         LA    WKREG5,N8(XLREG)        LOAD ADDR OF LENGTH LIST
         SPACE 2
*/* P GET ADDR OF LENGTH LIST */
         SPACE 2
         LR    WKREG2,WKREG1           LOAD NO. BLOCKS INTO TEMP. REG
         SLL   WKREG2,N2               MULTIPLY BY FOUR
         AR    WKREG2,WKREG5           ADD LENGTH LIST ADDR TO GET ADDR
         SPACE 2
*/*EPCHECK: P GET ADDRESS OF THIS EXTENT */
         SPACE 2
EPCHECK  L     WKREG3,N0(WKREG2)       LOAD ADDRESS (LOWER BOUND)
         SPACE 2
*/* D (YES,EPLAST,NO,) IS EP LT EXTENT LIST START? */
         SPACE 2
         CR    X2,WKREG3               IS ENTRY POINT BELOW LOWER BOUND
         BL    EPLAST                  YES
         SPACE 2
*/* P GET UPPER BOUND OF EXTENT LIST */
         SPACE 2
         L     WKREG4,N0(WKREG5)       LOAD LENGTH OF NEXT SECTION
         LA    WKREG4,N0(WKREG4)       ZERO HI ORDER FLAG
         SPACE 2
*/* D (YES,EPLAST,NO,) IS EP GT UPPER BOUND? */
*/* R RETURN VIA R15 */
         SPACE 2
         AR    WKREG3,WKREG4           COMPUTE UPPER BOUND
         CR    X2,WKREG3               IS ENTRY POINT ABOVE UPPER BOUND
         BCR   N4,RETREG               NO, WITHIN BOUNDS- RETURN LEGAL
         SPACE 2
*/*EPLAST: P (=0,NGENTPT,GT 0,) DECREMENT NUMBER OF EXTENTS BY 1 */
         SPACE 2
EPLAST   BCT   WKREG1,EPNEXT           IF LAST ENTRY NOT DONE GO EPNEXT
         B     NGENTPT                 OTHERWISE RETURN NOT LEGAL
         SPACE 2
*/*EPNEXT: P (,EPCHECK) GET ADDR OF NEXT ADDR AND LENGTH LIST ENTRY */
         SPACE 2
EPNEXT   LA    WKREG5,N4(WKREG5)       INCREMENT TO NEXT LENGTH
         LA    WKREG2,N4(WKREG2)       INCREMENT TO NEXT ADDRESS
         B     EPCHECK                 CONTINUE EPTEST
         SPACE 2
*/*NGENTPT: P GET ADDR OF FIRST/NEXT LLE OF CHAIN */
         SPACE 2
NGENTPT  EQU   *                                               @ZA26742
         LA    WKREG1,ZERO             POINT TO ADDRESS ZERO   @ZA26742
         CR    WKREG1,TLLSREG          ADDRESSES THE SAME?     @ZA26742
         BNE   NGENTPT1                BRANCH IF NOT           @ZA26742
         LA    CODEREG,CODENGEP        SET ERROR CODE          @ZA26742
         LR    X2,SAVEREG              POINT TO GOTTEN AREA    @ZA26742
         B     EXITFREE                FREE AREA AND RETURN    @ZA26742
NGENTPT1 EQU   *                                               @ZA26742
         L     TLLSREG,LLECHN          LOAD 1ST LL ELEM FROM TCBLLS
*                                      ** OR LLCHAIN FIELD
         LA    TLLSREG,N0(TLLSREG)     ZERO HIGH ORDER BYTE
         SPACE 2
*/* D (NO,NOTZERO,YES,) IS ADDR = 0? */
         SPACE 2
         LTR   TLLSREG,TLLSREG         IS TCBLLS OR LLCHAIN ZERO
         SPACE 1
*NOTE* LLCHAINA MUST BE 0 OTHERWISE ABOVE INSTS CANNOT BE USED FOR THE
*      DOUBLE-FOLD PURPOSE THEY NOW ARE. IT IS USED TO LOAD TCBLLS AND
*      LL CHAIN PTR.
         SPACE 1
         BNE   NOTZERO                 NO- PROCESS CDE/LLE ENTRIES
         SPACE 2
*/* P (,EXIT1) SET RETURN CODE (R15) = 12 */
         SPACE 2
         LA    CODEREG,CODENGEP        LOAD ENTRY-PT-INVALID ERROR CODE
         B     EXIT1                   RETURN
         SPACE 2
*/*NOTZERO: P GET ADDR OF CDE FROM LLE */
         SPACE 2
NOTZERO  L     CDEREG,LLECDPT          LOAD ADDR CDE FROM LL ELEM
         SPACE 2
*/* D (NO,XLINST,YES,) IS CDE A MINOR? */
         SPACE 2
         TM    CDATTR,CDMIN            IS IDENTIFIER A MINOR
         BZ    XLINST                  NO, GO TO CDEPTEST AND COLLECT
         SPACE 2
*/* P (,XLINST) GET ADDRESS OF MAJOR FROM MINOR */
         SPACE 2
         L     CDEREG,CDXLMJP          YES,LOAD MAJOR CD ENTRY
         B     XLINST                  GO TO CDEPTEST DONT COLLECT $200
         DROP  TLLSREG                 STOP LLE ADDRESSABLITY
         TITLE '         IGC041 - IDENTIFY - RETRY ENTRY'
*   SVC41 RETRY ROUTINE
*        CAUSES CONTROL TO BE RETURNED TO ISSUER OF SVC WITH REGISTER
*        15 CONTAINING X'24' - UNEXPECTED SYSTEM ERROR, REQUEST NOT
*        COMPLETED. SUPPORT CODE FOR RECOVERY IS Y02753          Y02753
*  INPUT - REG. 6 = BASE FOR MODULE IEAVID00
SVC41RTY DS    0H                      RETRY ROUTINE             Y02753
         LA    CODEREG,CODSYSER        PUT ERR CODE 24 IN REG 15 Y02753
         B     EXIT1                   GO FREE FRR AND EXIT      Y02753
         EJECT 1                                               @ZA28584
*  FETCH PROTECT RETRY ROUTINE                                 @ZA28584
*              CAUSES CONTROL TO BE RETURNED TO ISSUER OF SVC  @ZA28584
*              WITH REGISTER 15 CONTAINING X'28' - ADDRESS OF  @ZA28584
*              NAME IS FETCH PROTECTED                         @ZA28584
FETRTY   EQU   *                                               @ZA28584
         LA    CODEREG,CODEFET         PUT ERR CODE 28 IN 15   @ZA28584
         B     EXIT1                   GO FREE FRR AND EXIT    @ZA28584
         EJECT 1                                               @ZA26742
*   SVC41 RETRY ROUTINE                                        @ZA26742
*        CAUSES CONTROL TO BE RETURNED TO ISSUER FO SVC WITH   @ZA26742
*        REGISTER 15 CONTAINING X'24' - UNEXPECTED SYSTEM      @ZA26742
*        ERROR, REQUEST NOT COMPLETED.  THIS ROUTINE ALSO      @ZA26742
*        FREES UP AREA THAT WAS ALLOCATED FOR THE CDE AND XL.  @ZA26742
SVC41FRE EQU   *                                               @ZA26742
         LA    CODEREG,CODEFET         PUT ERR CODE 24 IN REG  @ZA26742
         B     EXITFREE                GO FREE AREA AND FRR    @ZA26742
         TITLE 'IGC041 - FRR ROUTINE'
*/* E FRRSVC41 */
*/* P SET UP ADDRESSABILITY */
         SPACE 2
FRRSVC41 DS    0H
         BALR  R6,N0                   SET UP ADDRESSABILITY     Y02753
         USING *,R6                    TELL ASSEMBLER            Y02753
         SPACE 2
*/* P PSAVE CALLERS RETURN ADDRESS IN R10 */
         SPACE 2
         LR    R12,R14                 SAVE RETURN ADDRESS     @ZA26742
         SPACE 2
*/* P PUT SDWA ADDRESS IN WKREG (R8) */
         SPACE 2
         LR    SDWAREG,R1              PUT SDWA IN PROTECTED REG Y02753
         USING SDWA,SDWAREG            TELL ASSEMBLER            Y02753
         SPACE 2
*/* L SETRP-- CAUSE ERROR TO BE RECORDED */
         SPACE 2
         SETRP RECORD=YES,WKAREA=(SDWAREG),RECPARM=SVC41ERR SET UP FOR
*                                      RECORDING                 Y02753
         SPACE 2
*/* P GET ABENDING ASID COMPARE FLAG FROM SDWA */
*/* D (YES,,NO,SVC41PRC) ABEND IN SAME MEMORY AS CURRENT? */
         SPACE 2
         LH    WKREG2,SDWAFMID         GET ASID OF CURRENT       Y02753
         LTR   WKREG2,WKREG2           TEST IF SAME ADDR. SPACE  Y02753
         BNZ   SVC41PRC                NO- RETURN TO CALLER      Y02753
         SPACE 2                                               @ZA28584
         USING PARMAD,R1                                       @ZA26742
         L     R9,FETRET               GET ADDRESS OF RETURN   @ZA28584
         L     R1,SDWAPARM             GET PARM ADDRESS        @ZA26742
         CLI   PARMFLAG,PARMFTCH       IS THIS FETCH PROTECT?  @ZA26742
         BE    SVC41RP                 BRANCH IF YES           @ZA28584
         SPACE 2
*/* P SET ENVIRONMENT REGISTERS 3=CVT, R=TCB, 5=RB, 7=ASCB */
         SPACE 2
         L     TCBREG,PSATOLD          GET CURRENT TCB           Y02753
         L     RBREG,N0(R8)            GET PARM LIST ADDRESS     Y02753
         L     RBREG,N0(RBREG)         GET SVRB ADDR. FROM PARM. Y02753
         L     R7,PSAAOLD              GET ASCB ADDRESS          Y02753
         L     CVTREG,CVTPTR           GET CVT POINTER         @ZA26742
         SPACE 2                                               @ZA26742
*/* P GET ADDRESS OF REG SAVE AREA (16 WORDS) */
*/* S CDEQVER:VERIFY APPROPRIATE CDE QUEUE */
         SPACE 2
         LA    R13,SDWASRSV            GET A REG. SAVE AREA      Y02753
         BAL   R14,CDEQVER             VERIFY PROPER CDE QUEUE   Y02753
         SPACE 2
*/*SVC41PRC: P PUT IDENTIFY BASE ADDRESS IN SDWA RETRY REGS */
         SPACE 2
SVC41PRC DS    0H                      RETURN TO CALLER          Y02753
         L     R1,SDWAPARM             GET PARM LIST           @ZA26742
         L     R9,PARMBASE             GET IDENTIFY BASE ADDR  @ZA26742
         ST    R9,SDWASR06             PUT IN RETRY REGS IN SDWA Y02753
         SPACE 2
*/* L SETRP-- CAUSE RETRY AT SVC41RET */
         SPACE 2
         L     R9,SVC41RET             GET RETRY ADDRESS         Y02753
         TM    PARMFLAG,PARMGTMN       WAS AREA ALLOCATED?     @ZA26742
         BZ    SVC41RP                 BRANCH IF NOT           @ZA26742
         L     R9,FREERTY              GET ADDRESS OF ROUTINE  @ZA26742
         L     R10,PARMGETM            GET ADDRESS OF AREA     @ZA26742
         ST    R10,SDWASR10            SAVE IN SDWA RETRY REGS @ZA26742
         LH    WKREG1,PARMGETL         GET LENGTH OF AREA      @ZA26742
         ST    WKREG1,CDESIZE(,R10)    STORE LENGTH IN XL      @ZA26742
SVC41RP  EQU   *                                               @ZA28584
         SETRP RETADDR=(R9),RETREGS=YES,RC=4,WKAREA=(R8)         Y02753
         SPACE 2
*/* P RESTORE CALLERS RETURN ADDRESS */
*/* R RETURN TO CALLER VIA BR14 */
         SPACE 2
         LR    R14,R12                 RESTORE RETURN ADDRESS  @ZA26742
         BR    R14                     RETURN TO RTM             Y02753
         DROP  R1                                              @ZA26742
         EJECT
*  CDE QUEUE VERIFY ROUTINE
*   PURPOSE:  TO DETERMINE IF THE JPQ OR THE LPA WAS BEING MODIFIED AT
*        THE TIME OF THE ERROR AND VERIFY THE ELEMENTS ON THAT QUEUE
*        ARE VALID.
*
*   INPUT:
*        R8 = ADDRESS OF SDWA
*        R3-4,7 = ENVIRONMENT REGISTERS
*        R13 = ADDRESS OF 16 WORD SAVE AREA
*        R14 = RETURN ADDRESS
*        R15 = ENTRY POINT
*
*   OUTPUT:
*        R0-2,8-9,11-12,15 - MODIFIED
*        R3-5,7,10,13-14 - UNCHANGED
*
         SPACE 1
*/* E CDEQVER */
*/* P SAVE CALLERS REGISTERS 0-15 IN R13 SAVE AREA */
*/* P SET UP ADDRESSABILITY */
         SPACE 2
CDEQVER  DS    0H                      VERIFIES CDE QUEUE        Y02753
         STM   R0,R15,N0(R13)          SAVE CALLERS REGS         Y02753
         BALR  R6,N0                   SET UP ADDRESSABILITY     Y02753
         USING *,R6                    TELL ASSEMBLER            Y02753
         SPACE 2
*/* L GETMAIN-- GET QUEUE VERIFY WORK AREA AND PARM LIST */
         SPACE 2
         GETMAIN RC,BRANCH=YES,LV=QVRSIZE,SP=253  GET QV WKAREA  Y02753
         SPACE 2
*/* D (NO,,YES,CDECHEK) GETMAIN SUCCESSFUL? */
*/* P (,CDEQEXIT) SET RETURN CODE IN REGISTER 15=0 */
         SPACE 2
         LTR   R15,R15                 GETMAIN SUCCESSFUL?       Y02753
         BZ    CDECHEK                 YES- INITIALIZE           Y02753
         SR    R15,R15                 SET 0 RETURN              Y02753
         B     NOFREE                  GO TO RETURN CODE         Y02753
         SPACE 2
*/*CDECHEK: P CLEAR PARAMENTER WORK AREA */
         SPACE 2
CDECHEK  XC    N0(QVPLSIZE,R1),N0(R1)  CLEAR PARM AREA
         USING QVPL,R1                 SET ADDRESSING TO PARM AR Y02753
         SPACE 2
*/* P PUT CDE ELEMENT VERIFICATION ROUTINE ADDRESS IN QVPL */
         SPACE 2
         L     CVTREG,CVTPTR           RESET CVT ADDRESS         Y02753
         LA    WKREG2,CDEVER           GET CDE ELEMENT VER. RTN. Y02753
         ST    WKREG2,QVPLEVR          PUT IN PARM LIST          Y02753
         SPACE 2
*/* P PUT ADDRESS OF SDWA VARIABLE RECORDING AREA IN QVPL */
         SPACE 2
         LA    WKREG2,SDWARA           GET RECORD AREA ADDR.     Y02753
         ST    WKREG2,QVPLODA          SAVE IN PARM LIST.        Y02753
         SPACE 2
*/* P PUT ADDRESS OF A WORKAREA FOR QUEUE VERIFIER IN QVPL */
         SPACE 2
         LA    WKREG2,QVPLSIZE(R1)     CALCULATE ADDR. OF WKAREA Y02753
         ST    WKREG2,QVPLWKA          STORE IN PARM LIST.       Y02753
         SPACE 2
*/* P SAVE CALLERS REGSITER SAVE AREA ADDRESS    */
*/* P GET A REGISTER SAVE AREA FOR QUEUE VERIFY ROUTINE  */
*/* P PUT SDWA ADDRESS IN R0   */
         LR    R10,R13                 SAVE CALLERS REG SAVE     Y02753
         LA    R13,QVPLSIZE+QVPLWASZ(R1) GET QV REG SAVE AREA    Y02753
         LR    R0,R8                   PUT SDWA ADDR. IN R0      Y02753
*                                      Q.V. ROUTINE
         SPACE 2
*/* L (HELD,LPAVER,NO,) SETLOCK-- TEST IF CMS LOCK IS HELD */
         SPACE 2
         SETLOCK TEST,TYPE=CMS,BRANCH=(HELD,LPAVER)  LOCKS HELD  Y02753
         SPACE 2
*/* P PUT JPQ ERROR LABEL IN RECORDING AREA */
*/* P INCREMENT AMOUNT USED COUNT BY MSG LENGTH (10 BYTES) */
         SPACE 2
         LA    WKREG2,SDWAVRA          GET RECORDING AREA ADDR.  Y02753
         MVC   N0(MSGLEN,WKREG2),JPQERR PUT MSG IN RECORDING ARE Y02753
         LA    WKREG2,MSGLEN           GET LENGTH OF HEADER AND  Y02753
         STC   WKREG2,SDWAURAL         STORE IN USED COUNT       Y02753
         SPACE 2
*/* P PUT ADDRESS OF JPQ HEADER (TCBJPQ FROM JSTCB) IN QVPL */
         SPACE 2
         L     WKREG2,TCBJSTCB         GET JSTCB                 Y02753
         LA    WKREG2,TCBJPQ-TCB(WKREG2) GET JPQ ADDR.           Y02753
         ST    WKREG2,QVPLHDR          SAVE IN HEADER FIELD      Y02753
         SPACE 2
*/* L IEAQVER-- VERIFY SINGLE THREADED/ HEADER ONLY QUEUE */
         SPACE 2
         L     R15,CVTQV1            GET ADDR. OF QUEUE VER RTN. Y02753
         BALR  R14,R15                 GO TO QUEUE VER. RTN.     Y02753
         SPACE 2
*/* P GET REASON CODE IN REGISTER WITHOUT INDICATORS */
*/* D (YES,CDEQEXIT,NO,) ANY ERRORS FOUND? */
         SPACE 2
         SLL   R15,N24                 SHIFT REASON CODE         Y02753
         LTR   R15,R15                 ANY ERRORS                Y02753
         BNZ   CDEQEXIT                YES-CAUSE WTO BEFORE EXIT Y02753
         SPACE 2
*/* P (,CDEQEXIT) CLEAR USED PORTION OF RECORDING AREA IN SDWA */
         SPACE 2
         SR    WKREG2,WKREG2           CLEAR REG, PUT ZERO USED  Y02753
         STC   WKREG2,SDWAURAL         CNT IN SDWA RECORDING ARE Y02753
         B     CDEQEXIT                RETURN TO CALLLER         Y02753
         SPACE 2
*/*LPAVER: P PUT LPQ ERROR LABEL IN RECORDING AREA OF SDWA */
         SPACE 2
LPAVER   LA    WKREG2,SDWAVRA          GET RECORDING AREA ADDR.  Y02753
         MVC   N0(MSGLEN,WKREG2),LPQERR  PUT MSG IN RECORDING AR Y02753
         SPACE 2
*/* P INCREMENT AMOUNT USED COUNT BY MSG LENGTH (10 BYTES) */
         SPACE 2
         LA    WKREG2,MSGLEN           GET LENGTH OF HEADER AND  Y02753
         STC   WKREG2,SDWAURAL         STORE IN USED COUNT       Y02753
         SPACE 2
*/* P PUT ADDRESS OF LPA QUEUE HEADER IN QVPL (IEAQLPAQ) */
         SPACE 2
         L     WKREG2,CVTQLPAQ         GET LPA QUEUE HEADER      Y02753
         ST    WKREG2,QVPLHDR          SAVE IN PARM AREA         Y02753
         SPACE 2
*/* L IEAVQVER-- VERIFY SINGLE THREADED/ HEADER ONLY QUEUE */
         SPACE 2
         L     R15,CVTQV1              GET ADDR. OF QUEUE RTN.   Y02753
         BALR  R14,R15                 QUEUE VER. RTN.           Y02753
         SPACE 2
*/* P GET REASON CODE IN REGISTER WITHOUT INDICATORS */
*/* D (YES,RECRDLPA,NO,) ANY ERRORS FOUND? */
*/* P (,CDEQEXIT) ZERO COUNT USED IN RECORDING AREA IN SDWA */
         SPACE 2
         SLL   R15,N24                 SHIFT REASON CODE         Y02753
         LTR   R15,R15                 ANY ERRORS                Y02753
         BNZ   RECRDLPA                YES-CAUSE WTO BEFORE EXIT Y02753
         SR    WKREG2,WKREG2           CLEAR REG, PUT ZERO USED  Y02753
         STC   WKREG2,SDWAURAL         CNT IN SDWA RECORDING ARE Y02753
         B     CDEQEXIT                END                       Y02753
         SPACE 2
*/*RECRDLPA: P SAVE QVPL ADDRESS OVER RECORD INTERFACE */
*/* P GET REGISTER SAVE AREA FOR RECORD */
*/* L RECORD-- CAUSE ASYNCROUS WTO WITH MESSAGE IEA959I */
*/* P RESTORE QVPL ADDRESS INTO R1 */
         SPACE 2
RECRDLPA LR    WKREG2,R1               SAVE QVPL ADDR. OVER REC. Y02753
         LA    R13,QVPLSIZE+QVPLWASZ(R1)   REG SAVE AREA ADDRESS Y02753
*                                    '(R1)' ADDED TO LINE FOR  @ZA17842
         RECORD TYPE=WTO,RCVRY=SETFRR,DATAADR=IEA959,LENGTH=MSGLNTH,   *
               BUFFER=YES                                        Y02753
         LR    R1,WKREG2               RESTORE QVPL AREA ADDRESS Y02753
         SPACE 2
*/*CDEQEXIT: L FREEMAIN-- FREE QUEUE VERIFIER WORK SPACE AND PARM LIST
*/**/
*/* P RESTORE CALLERS REGISTER SAVE AREA ADDR. FROM R10 */
*/* P RESTORE CALLERS REGISTERS */
*/* R RETURN TO CALLER VIA BR14 */
         SPACE 2
CDEQEXIT FREEMAIN RC,LV=QVRSIZE,A=(1),BRANCH=YES FREE QVPL, ETC. Y02753
         LR    R13,R10                 RESTORE CALLERS SAVE REGS Y02753
NOFREE   EQU   *                                               @ZA26742
         LM    R0,R14,N0(R13)          RESTORE CALLERS REGS      Y02753
         BR    R14                     RETURN TO CALLER          Y02753
         DROP  R6
         EJECT
*  CDE ELEMENT VERIFICATION ROUTINE
*    PURPOSE: TO VERIFY THAT THE ELEMENT PASSED AS INPUT IS A CDE
*
*    INPUT:
*        R0  = ADDRESS OF ELEMENT TO BE VERIFIED
*        R1  = ADDRESS OF SDWA
*        R14 = RETURN ADDRESS
*        R15 = ENTRY POINT ADDRESS
*
*    OUTPUT:
*        R15 = RETURN CODE
*          0 = VALID
*          4 = INVALID (REMOVE ELEMENT)
*          8 = INVALID (TRUNCATE QUEUE)
*        R0,1,8-13 = UNCHANGED
*        R2-7 = UNPREDICTABLE
*
         SPACE 1
*/* E CDEVER */
*/* P SET UP ADDRESSABILITY */
         SPACE 2
CDEVER   DS    0H                      CDE ELEMENT VERIFIER      Y02753
         BALR  R6,N0                   SET UP ADDRESSIBILITY     Y02753
         USING *,R6                    TELL ASSEMBLER            Y02753
         SPACE 2
*/* P SAVE CALLERS RETURN ADDRESS IN R7 */
         SPACE 2
         LR    R7,R14                  SAVE CALLERS RETURN ADDR. Y02753
         SPACE 2
*/* P INITIALIZE FOR ADDR. VERIFY RTN. R0= ELEM SIZE, R1= SDWA, R2=
*/*ELEMENT */
         SPACE 2
         LR    R2,R0                   PUT SDWA IN USABLE REG    Y02753
         LA    R0,CDESIZE              GET SIZE OF ELEMENT       Y02753
         SPACE 2
*/* L IEAVADVER-- VERIFY CDE ADDRESS */
         SPACE 2
         L     R3,CVTPTR               GET ADDRESS OF CVT       @Y04971
         L     R15,CVTADV              GET ADDRESS VERIFIER RTN. Y02753
         BALR  R14,R15                 GO TO ADDR. VER. RTN.     Y02753
         SPACE 2
*/* D (YES,MINTST,NO,) ADDRESS VALID? */
*/* P (,CDEERET) SET RETURN CODE = 8 TO TRUNCATE QUEUE */
         SPACE 2
         LTR   R15,R15                 ADDRESS VALID             Y02753
         BZ    MINTST                  YES- CHECK ELEMENT        Y02753
         LA    R15,N8                  NO- TRUNCATE QUEUE        Y02753
         B     CDEERET                 RETURN TO CALLER          Y02753
         USING CDENTRY,R2              ADDRESSING FOR CDE        Y02753
         SPACE 2
*/*MINTST: P PUT SAME CDE ADDRESS IN WKREG 3 */
*/* D (NO,SPTST,YES,) CDE A MINOR? */
         SPACE 2
MINTST   LR    R3,R2                   GET MAJOR IN REG 3        Y02753
         TM    CDATTR,CDMIN            TEST MINOR CDE            Y02753
         BZ    SPTST                   NO-GO TO NEXT TEST        Y02753
         SPACE 2
*/* P GET MAJOR CDE ADDRESS FROM XTLST FIELD */
*/* D (YES,LPAQMOD,NO,) MODULE LOADED BY NIP */
         SPACE 2
         L     WKREG3,CDXLMJP          GET MAJOR CDE             Y02753
         TM    CDATTR,CDNIP            TEST-MODULE LOADED BY NIP Y02753
         BO    LPAQMOD                 YES- SEARCH LPA ONLY      Y02753
         SPACE 2
*/* P (,RUNQ) GET POINTER TO JPQ HEAD */
         SPACE 2
         L     TCBREG,PSATOLD          GET CURRENT TCB           Y02753
         L     TCBREG,TCBJSTCB         GET JOBSTEP TCB           Y02753
         LA    TCBREG,TCBJPQ           GET JPQ FROM JSTCB        Y02753
         B     RUNQ                    TEST FOR MODULE ON QUEUE  Y02753
         SPACE 2
*/*LPAQMOD: P GET POINTER TO LPAQ HEAD */
         SPACE 2
LPAQMOD  L     R4,CVTPTR               GET CVT ADDRESS           Y02753
         L     R4,CVTQLPAQ-CVT(R4)     GET LPA QUEUE HEADER      Y02753
         SPACE 2
*/*RUNQ: D (YES,SPTST,NO,) CURRENT CDE= MAJOR CDE? */
         SPACE 2
RUNQ     CR    R3,R4                   TEST CURRENT=MAJOR        Y02753
         BE    SPTST                   IF EQUAL, DO NEXT TEST    Y02753
         SPACE 2
*/* D (YES,ERRQRUN,NO,) CURRENT CDE=SUBJECT CDE? */
         SPACE 2
         CR    R2,R4                   TEST CURRENT=SUBJECT CDE  Y02753
         BNE   ERRQRUN                 IF NOT EQUAL-END WITH ERR Y02753
         SPACE 2
*/* P (,RUNQ) GET NEXT CDE ON QUEUE */
         SPACE 2
         L     R4,N0(R4)               GET NEXT CDE              Y02753
         B     RUNQ                    LOOP TO CHECK TOTAL QUEUE Y02753
         SPACE 2
*/*ERRQRUN: P (,CDEERET) SET RETURN CODE = 8 TO CAUSE TRUNCATION OF CDE
*/* QUEUE */
         SPACE 2
ERRQRUN  LA    R15,N8                  QUEUE TO BE TRUNCATED     Y02753
         B     CDEERET                 RETURN TO CALLER          Y02753
         SPACE 2
*/*SPTST: D (YES,CDEERET,NO,) MAJOR CDE LOADED BY OS LOADER */
         SPACE 2
SPTST    TM    CDATTR2-CDENTRY(R3),CDSPZ TEST MAJOR FOR SP0      Y02753
         BO    CDEERET                 IF SP0 RETURN TO CALLER   Y02753
         SPACE 2
*/* P GET ADDRESS OF EXTENT LIST FROM MAJOR CDE */
*/* D (YES,CDEERET,NO,) FIRST 9 BYTES OF XTLST CORRECT? */
         SPACE 2
         L     R4,CDXLMJP-CDENTRY(R3)  GET EXTENT LIST ADDR.     Y02753
         CLC   N0(N9,R4),XLSTHEAD      TEST FOR XTLST FORMAT     Y02753
         BE    CDEERET                 IF XTLST RETURN TO CALLER Y02753
         SPACE 2
*/* P SET RETURN CODE= 8 TO CAUSE TRUNCATION OF CDE QUEUE */
*/* D (YES,CDEERET,NO,) REQUEST FOR A MAJOR? */
         SPACE 2
         LA    R15,N8                  CAUSE QUE TO BE TRUNCATED Y02753
         CR    R2,R3                   Q. REQUEST FOR MAJOR CDE  Y02753
         BE    CDEERET                 YES- SKIP ZERO OF CHAIN   Y02753
         SPACE 2
*/* P SET MAJOR AS LAST BY ZEROING CHAIN FIELD */
*/* P INDICATE NO EXTENT LIST AND SET ATTR. TO NON-REUS */
         SPACE 2
         SR    WKREG2,WKREG2           CLEAR REG FOR ZERO STORES Y02753
         ST    WKREG2,CDCHAIN-CDENTRY(R3) SET MAJOR AS LAST      Y02753
         ST    WKREG2,CDXLMJP-CDENTRY(R3) SET XTLST PTR TO ZERO  Y02753
         STC   WKREG2,CDATTR-CDENTRY(R3)  SET MAJOR NON-REUS     Y02753
         SPACE 2
*/*CDEERET: P RESTORE CALLERS RETURN REGISTER */
*/* R RETURN TO CALLER VIA BR14 */
         SPACE 2
CDEERET  LR    R14,R7                  RESTORE CALLERS RET REG   Y02753
         BR    R14                     RETURN TO CALLER          Y02753
         DROP  R2                      RELEASE CDE
         DROP  R6                      RELEASE BASE
         SPACE 2
*/* FOOTING
*/*
*/* */
*/*IEAVID00: END IDENTIFY */
         SPACE 2
         TITLE 'IGC041 - IDENTIFY - CONSTANTS, EQUATES, AND MAPS'
***********************************************************************
ZERO     DC    A(0)                    MASK FOR CLEARING FIELDS
XLSTHEAD DC    F'16'                   LENGTH OF 16              Y02753
         DC    F'1'                    COUNT OF 1 BLOCK          Y02753
         DC    X'80'                   END-OF-LIST INDICATOR     Y02753
IEA959   WTO   'IEA959I  ERROR CAUSED ACTIVE LPA TO BE TRUNCATED, MODUL*
               E CONTROL MAY BE LOST',MF=L,ROUTCDE=2,DESC=4      @M7603
MSGEND   EQU   *                       END OF MSG TO OPERATOR
MSGLNTH  EQU   MSGEND-IEA959           LENGTH OF TOTAL MSG AND CODES
SVC41ERR DC    CL8'IEAVID00'           MODULE NAME               Y02753
         DC    CL8'IEAVID00'           CSECT NAME                Y02753
         DC    CL8'FRRSVC41'           RECOVERY ROUTINE          Y02753
SVC41RET DC    A(SVC41RTY)             RETRY ADDRESS FOR ERROR
FREERTY  DC    A(SVC41FRE)             RETRY ADDRESS FOR       @ZA26742
*                                      FREEING AREA AFTER ERR  @ZA26742
FETRET   DC    A(FETRTY)               RETRY ADDRESS FOR FETCH @ZA28584
*                                      PROTECT ERROR           @ZA28584
MINMASK  DC    XL4'80000000'           HIGH BIT  MASK          @ZA26742
ZEROMASK DC    XL4'7FFFFFFF'           ZERO HIGH BIT MASK      @ZA26742
JPQERR   DC    CL10'JPQ ERROR '        ERROR LABEL
JPQEND   EQU   *
LPQERR   DC    CL10'LPA ERROR '        ERROR LABEL
LPAEND   EQU   *
ZAPSPACE DS    20F                     AREA FOR TEMPORARY FIXES
         EJECT
**********************************************************************
R0       EQU   0                       CROSS REFERENCE EQUATE
INREG1   EQU   R0                      INPUT REG WITH ADDR OF PROGNAME
R1       EQU   1                       CROSS REFERENCE EQUATE
INREG2   EQU   R1                      INPUT REG WITH ENTRY POINT
WKREG1   EQU   R1                      WORK REGISTER
R2       EQU   2                       CROSS REFERENCE EQUATE
WKREG2   EQU   R2                      WORK REGISTER
R3       EQU   3                       CROSS REFERENCE EQUATE
CVTREG   EQU   R3                      INPUT REG WITH CVT ADDR
WKREG3   EQU   R3                      WORK RETISTER
R4       EQU   4                       CROSS REFERENCE EQUATE
TCBREG   EQU   R4                      INPUT REG WITH TCB ADDR
R5       EQU   5                       CROSS REFERENCE EQUATE
RBREG    EQU   R5                      INPUT REG WITH RB ADDR
R6       EQU   6                       CROSS REFERENCE EQUATE
BASEREG  EQU   R6                      BASE REG
R7       EQU   7                       CROSS REFERENCE EQUATE
WKREG5   EQU   R7                      WORK REG 1
ASCBREG  EQU   R7                      CONTAINS ASCB FOR GETMAIN
R8       EQU   8                       CROSS REFERENCE EQUATE
WKREG4   EQU   R8                      WKREG 4
XLREG    EQU   R8                      EXTENT LIST REGISTER (TEMP)
SDWAREG  EQU   R8                      ADDRESS OF SDWA
R9       EQU   9                       CROSS REFERENCE EQUATE
PNREG    EQU   R9                      WORKING REG FOR INPUT REG 1
ROURETRG EQU   R9                      WORK REGISTER
R10      EQU   10                      CROSS REFERENCE EQUATE
X2       EQU   R10                     CONTAINS INPUT IN REG 1
R11      EQU   11                      CROSS REFERENCE EQUATE
TLLSREG  EQU   R11                     TEMP. LLE POINTER
R12      EQU   12                      CROSS REFERENCE EQUATE
CDEREG   EQU   R12                     CD ENTRY ADDR
R13      EQU   13                      CROSS REFERENCE EQUATE
SAVEREG  EQU   R13                     SAVE AREA REGISTER
R14      EQU   14                      CROSS REFERENCE EQUATE
RETREG   EQU   R14                     RETURN REG
R15      EQU   15                      CROSS REFERENCE EQUATE
CODEREG  EQU   R15                     OUTPUT REG
         EJECT
********************************************************************
CODEUN   EQU   X'04'             UNNECESSARY-IDENTIFY CODE
CODEANEQ EQU   X'08'             MULTIPLE-NAME-FOUND - ERROR CODE
CODENGEP EQU   X'0C'             ENTRY-POINT-INVALID - ERROR CODE
CODENPRB EQU   X'10'             RB NOT PRB - ERROR CODE
CODEBADM EQU   X'14'             MINOR-FOUND,EP'S-NOT-EQ - ERROR CODE
ILIST    EQU   X'18'             INVALID INPUT LIST - ERROR
IPARM    EQU   X'1C'             INVALID INPUT PARM. - ERROR
CODSYSER EQU   X'24'             UNEXPECTED SYSTEM ERROR
CODEFET  EQU   X'28'             FETCH-PROTECTED STORAGE       @ZA28584
         EJECT
N0       EQU   0                  EQUATE FOR ZERO
N1       EQU   1                  EQUATE FOR 1
N2       EQU   2                  USED TO SHIFT IN MULTIPLY AOS
N3       EQU   3                  EQUATE FOR 3 BYTES
N4       EQU   4                  EQUATE FOR 4 BYTES
N7       EQU   7                  3 BYTE MASK
N8       EQU   8                  OFFSET INTO EXLIST
NAME     EQU   8                  MAX. LENGTH OF AOS NAMES
EQUAL    EQU   8                  USED TO TEST CONDITION CODES
N9       EQU   9                  LENGTH OF BASE OF XTLST
MSGLEN   EQU   10                      LENGTH OF ERROR MESSAGES
N12      EQU   12                 OFFSET IN XLIST
EXTLST   EQU   12                 OFFSET TO THE LENGTH OF LIST
EXTLSTB  EQU   EXTLST-1           OFFSET TO THE LENGTH OF LIST
N15      EQU   15                 OFFSET INTO AOS LOADER LIST
N16      EQU   16                 XLIST OFFSET
N20      EQU   20                 XLIST OFFSET
N24      EQU   24                 USED FOR 3 BYTE SHIFT
N29      EQU   29                 PARM LIST OFFSET
N30      EQU   30                 PARM LIST OFFSET
N256     EQU   256                     LENGTH OF MAX. MOVE     @ZA26742
REGSAVE  EQU   72                 LENGTH OF REGISTER SAVE AREA
HIBIT    EQU   X'80'              CHECK ALPA CHAR
NAMEFND  EQU   X'80'              NAME FOUND- DUPLICATE REQ.
MAX      EQU   X'FF'              MAXIMUM VALUE FOR 1 BYTE
MAXLNTH  EQU   X'FFF'                  MAXIMUM VALUE FOR LA    @ZA26742
         EJECT                                                 @ZA26742
************************************************************** @ZA26742
*        DSECT FOR IDENTIFY LIST                               @ZA26742
************************************************************** @ZA26742
         SPACE 2                                               @ZA26742
IDLIST   DSECT                                                 @ZA26742
IDENTRY  DS    F                       ENTRY POINT ADDRESS     @ZA26742
IDNAME   DS    CL8                     8-BYTE NAME             @ZA26742
*                                                              @ZA26742
*        THE FOLLOWING DESCRIBES EITHER A BLOCK LOAD OR A      @ZA26742
*        SCATTER LOAD EXTENT LIST.  A BLOCK LOAD HAS BUT ONE   @ZA26742
*        EXTENT, A SCATTER LOAD COULD HAVE MULTIPLE EXTENTS.   @ZA26742
*                                                              @ZA26742
IDXLNTH  DS    F                       LENGTH OF EXTENT LIST   @ZA26742
*                                      (X'10' FOR BLOCK LOAD)  @ZA26742
IDXNUM   DS    F                       NUMBER OF EXTENTS       @ZA26742
*                                      (1 FOR BLOCK LOAD)      @ZA26742
IDXTNT   DS    0F                      START OF EXTENT LIST    @ZA26742
*        EACH WORD CONSISTS OF A FLAG BYTE AND A 3 BYTE EXTENT @ZA26742
*        LENGTH - A X'80' IN THE FLAG BYTE INDICATES THE LAST  @ZA26742
*        EXTENT.  A START ADDRESS FOR EACH EXTENT FOLLOWS THE  @ZA26742
*        LAST  EXTENT LENGTH WORD.                             @ZA26742
         EJECT
************************************************************** @ZA26742
*        DSECT FOR FRR PARAMETER                               @ZA26742
************************************************************** @ZA26742
         SPACE 2                                               @ZA26742
PARMAD   DSECT                                                 @ZA26742
PARMSVRB DS    F                       SVRB ADDRESS            @ZA26742
PARMBASE DS    F                       BASE ADDRESS OF ID00    @ZA26742
PARMGETM DS    F                       GETMAIN AREA ADDRESS    @ZA26742
PARMGETL DS    H                       GETMAIN LENGTH          @ZA26742
PARMFLAG DS    B                       FLAG BYTE               @ZA26742
PARMFTCH EQU   X'04'                   FETCH PROTECT FLAG      @ZA26742
PARMGTMN EQU   X'02'                   INDICATE AREA ALLOC     @ZA26742
         EJECT 1                                               @ZA26742
********************************************************************
         IHACDE
CDEEND   EQU   *                       END OF CDE MAP
CDENTPTZ EQU   CDENTPT-CDENTRY         EQUATE FOR ENTRY POINT
CDESIZE  EQU   CDEEND-CDENTRY          SIZE OF CDE
         EJECT
********************************************************************
         CVT   DSECT=YES,PREFIX=NO
         EJECT
*********************************************************************
         IHAFRRS
         EJECT
********************************************************************
         IHALLE
         EJECT
********************************************************************
         IHAXTLST
         EJECT
********************************************************************
         IHAPSA
         EJECT
********************************************************************
         IHAQVPL
QVRSIZE  EQU   QVPLSIZE+QVPLWASZ+REGSAVE   SIZE NEEDED FOR QV RTN.
********************************************************************
         IHARB
RBPRBF   EQU   RBFTP                   TEST FOR PRB TYPE
         EJECT
*********************************************************************
         IHASDWA
         EJECT
********************************************************************
         IKJTCB
         END
CLR8291 DUPLICATE ENTRY FOR SEQUENCE # 004891
CLR8291 DUPLICATE ENTRY FOR SEQUENCE # 004894
CLR8291 DUPLICATE ENTRY FOR SEQUENCE # 004897
