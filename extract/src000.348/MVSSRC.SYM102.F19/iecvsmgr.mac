SMGR     TITLE 'IECVSMGR - IOS STORAGE MANAGER'
IECVSMGR CSECT
         ENTRY IECVCPRM
         ENTRY IECVSMFR
         ENTRY IECVSHDR
         ENTRY IECVSEVR
         ENTRY IECVSCOM
         ENTRY IECVBCOM
         ENTRY HEAD160
         ENTRY IECVSCNT
*
***********************************************************
*
* MODULE NAME = IECVSMGR
*
* DESCRIPTIVE-NAME - IOS STORAGE MANAGER
*
* COPYRIGHT - NONE
*
* STATUS - CHANGE LEVEL  *** REWRITE VS2PJ/3.7- SU5 ***        @Z40FPLG
*        ** THIS MODULE IS REWRITTEN FOR PERFORMANCE &         @Z40FPLG
*           RELIABILITY **                                     @Z40FPLG
*
* FUNCTION - THE FUNCTION OF THIS MODULE IS TWOFOLD.
*            FIRST THE MODULE MANAGES AND SUPPLIES STORAGE
*            WHICH IOS COMPONENTS USE IN PROCESSING.
*            SECOND THE MODULE INITIALIZES ITS OWN
*            STORAGE POOLS AT SYSTEM IPL TIME BY MEANS
*            OF A NIP0 INTERFACE.
*
*      1) STORAGE MANAGEMENT IS SUPPLIED TO IOS TO
*         MANAGE POOLS OF THREE DIFFERENT BLOCK SIZES
*         (12, 40, AND 160 BYTES). THESE BLOCKS ARE
*         USED BY VARIOUS IOS COMPONENTS IN PERFORMING
*         THE I/O FUNCTION. INTERFACES ARE SUPPLIED TO
*         BOTH ACQUIRE AND FREE BLOCKS.
*
*      2) STORAGE PRIMING IS SUPPLIED TO ALLOW THE
*         PRIMING OF THE STORAGE MANAGEMENT BUFFERS.
*         THIS FUNCTION IS SUPPLIED TO INSURE STORAGE
*         POOLS ARE PRIMED BEFORE IOS ATTEMPTS TO USE
*         THE STORAGE MANAGER.
*
* NOTES = NONE
*
*    DEPENDENCIES = IECIOSCN/IECIOSAM MUST TURN ON IOQALOC BIT @Z40FPLG
*                   AFTER GETTING 12 BYTE BLOCK & LEAVE IT ON  @Z40FPLG
*                   BEFORE FREEING IT                          @Z40FPLG
*
*    RESTRICTIONS = NONE
*
*    REGISTER CONVENTIONS = SEE EQUATES
*
*    PATCH LABEL = IOSPATCH - SMGR USES IOS PATCH AREA
*
* MODULE TYPE = I/O CONTROL
*
*    PROCESSER = ASSEMBLER XF
*
*    MODULE SIZE = 4888 DECIMAL BYTES
*
*    ATTRIBUTES = SUPERVISOR STATE, KEY 0, RESIDENT, DAT ON
*
* ENTRY POINTS = IECVSMGR - NORMAL PROCESSING
*              FROM IOS COMPONENTS REQUESTING OR FREEING STORAGE
*              WHERE REGISTER 15 CONTAINS THE ADDRESS OF
*              IECVSMGR AND ENTRY IS TO:
*
*              IECVSMGR+0  - GETBLOCK FOR 160 BYTE BLOCK
*              IECVSMGR+4  - FREEBLOCK FOR 160 BYTE BLOCK
*              IECVSMGR+8  - PURGE/FREE (RECOVER IOS RESOURCES)
*              IECVSMGR+12 - GETBLOCK 12 BYTE BLOCK
*              IECVSMGR+16 - FREEBLOCK 12 BYTE BLOCK
*              IECVSMGR+20 - GETBLOCK 40 BYTE BLOCK
*              IECVSMGR+24 -FREEBLOCK 40 BYTE BLOCK
*
*          IECVCPRM - FOR STORAGE INITIALIZATION
*              FROM NIP0 TO INITIALIZE STORAGE POOLS AT ENTRY
*              POINT IECVCPRM.
*
*           IECVSMFR - FUNCTIONAL RECOVERY ROUTINE
*
*           IECVSEVR - ELEMENT VERIFICATION CALLED BY QUEUE VERIFY
*
*           IECVBCOM - BRANCH ENTRY TO COMPRESS 160 BYTE BLOCKS
*
*           IECVSCOM - IOS SRB ENTR TO COMPRESS
*
*
*    PURPOSE = SEE FUNCTION
*
*    LINKAGE = NORMAL 14,15
*
*    INPUT = GETBLOCK - 12 BYTE
*                 REG 13 - EITHER A 14 WORD SAVE AREA OR ZERO
*                          (IF ZERO THE LCCA SAVE AREA FOR IOS IS
*                           USED)
*                 REGISTERS 0,1,10,11,12 ARE DESTROYED
*              *NOTE* THIS ENTRY ONLY CALLED BY IECIOSCN
*            * IOQALOC IN IOQFLB MUST BE TURNED ON BY CALLER **
*            GETBLOCK -40
*                 REG 13 - A 15 WORD SAVE AREA
*                 REG 11
*                   BITS 16-31 CONTAINS ASID OF REQUESTOR
*                 REGISTERS DESTROYED NONE
*            GETBLOCK - 160
*                 REG 11
*                   BITS 0-3 COUNT OF NO. OF BLKS REQUESTED
*                   BITS 4-7 ZERO
*                   BITS 8-23 ASID OF REQUESTOR
*                   BITS 24-31  00100000 - 160 BYTE BLK
*            ***WARNING*** COUNT OF BLOCKS REQUESTED IS NOT
*                   CHECKED FOR ZERO FOR PERFORMANCE REASONS
*                ***ZERO WOULD CAUSE SQA TO BE EXHAUSTED***
*                 REG 13 - 14 WORD SAVE AREA
*                 REGISTERS DESTROYED - NONE
*              FREEBLOCK - 12 BYTES
*                 REG 1 - ADDRESS OF BLK TO BE FREED
*                 REGISTERS DESTROYED - 0,1,10,11,12
*            * IOQALOC MUST BE LEFT ON OR BLK WILL BE REJECTED *
*              FREEBLOCK -40 BYTE
*                  REG 1 - ADDRESS OF BLOCK TO BE FREED
*                  REGISTERS DESTROYED NONE
*              FREEBLOCK - 160 BYTE
*                   REG 1 - ADDRESS OF BLK TO BE FREED
*                     IF MULTIPLE BLK FREED, LINK PTR OF LAST
*                     BLOCK MUST BE ZERO
*                 REG 11
*                   BITS 0-23 ZERO
*                   BITS 24-31  00100000 - 160 BYTE BLK
*                 REG 13 - 14 WORD SAVE AREA
*                 REGISTERS DESTROYED - NONE
*              PURGE/FREE
*                 REG 11 - ASID OF BLOCKS TO BE FREED IN LOW
*                          ORDER 2 BYTES
*                 REG 13 - 16 (THE FIRST WORD OF THIS WORD SAVE AREA
*                              POINTS TO A 14 WORD SAVE AREA)
*             COMPRESS -
*               IECVBCOM  (BRANCH ENTRY)
*                  REG 13 - 16 WORD SAVE AREA
*               IECVSCOM  (SRB ENTRY SCHEDULED BY IOS)
*                   STD SRB ENTRY SCHEDULED WITH AN IOS 160 BYTE BLK
*
*    OUTPUT = GETBLOCK - 12 BYTE
*                 REG 11 - ADDRESS OF THE 12 BYTE BLOCK
*                          *NOTE* OFFSET 5 (IOQFLB), IOQALLOC
*                           MUST BE LEFT ON
*             GETBLOCK - 40/160 BYTE
*                 REG 11 - ADDRESS OF BLOCK OR FIRST BLOCK IN
*                          CHAIN IF MORE THAN ONE REQUESTED
*                          (CHAINED BY FIRST WORD; DELIMITER 0)
*               IECVBCOM -
*                 REG 15 RTN CODE 0 IF PAGE(S) FREED
*                        RTN CODE 4 IF NO PAGES FREED
*
*    EXIT NORMAL = RETURN TO CALLER
*
*    EXIT ERROR = NONE
*
* EXTERNAL REFERENCES = GETMAIN/FREEMAIN (BRANCH ENTRY)
*                       SETLOCK FOR IOSYNCH AND SALLOC LOCKS
*
*    ROUTINES = GETMAIN/FREEMAIN
*
*    DATA SETS = NONE
*
*    DATA AREAS = NONE
*
* TABLES = BLOCK TYPE HEADER
*           PAGE TYPE HEADER
*
* MACROS = SETFRR, SETLOCK, GETMAIN, FREEMAIN
*
* CHANGE ACTIVITY = NONE
*
***********************************************************
*
         EJECT
*
***********************************************************
*        REGISTER EQUATES
***********************************************************
*
REG0     EQU   0                       COMP AND SWAP AND WORK REG
BLKREGLK EQU   1
REG2     EQU   2                       REGISTER 2
IRTREG   EQU   3                       IRT PTR FOR TRK 12 BYTE REQ
FRRAREA  EQU   4                       FRR TRACK AREA REG
CHAINREG EQU   5                       CHAIN REG FOR MULT REQ
CNTREG1  EQU   6                       COMP AND SWAP REG
BLKREG1  EQU   7                       COMP AND SWAP REG
HDRREG   EQU   8                       HEADER POINTER
INTREG1  EQU   9                       INTERNAL LINK REG
CNTREG   EQU   10
BLKREG   EQU   11
PGREG    EQU   12                      POINTER TO PAGE
SAVEREG  EQU   13                      SAVE AREA POINTER
RETREG   EQU   14                      RETURN REG
BASEREG  EQU   15                      BASE REGISTER
         EJECT
*
***********************************************************
*        DATA EQUATES
***********************************************************
*
SAV      EQU   12                      SAVE DISP
REG4     EQU   4                       REG 4
REG5     EQU   5                       REG 5
HDRLEN   EQU   16                      LEN OF HDR ENT
NOHDRTYP EQU   3                       NO OF HEADERS
LO24     EQU   24                      EQUATE FOR REG SHIFT
LO20     EQU   20                      EQUATE FOR REG SHIFT
LO8      EQU   8                       EQUATE FOR REG SHIFT
LO30     EQU   30                      EQUATE FOR REG SHIFT
FOUR     EQU   4                       FOUR
PREFIXLN EQU   8                       LEN OF ASID PREFIX
ASIDDISP EQU   10                      DISP TO ASID IN FRR AREA
FORTYIND EQU   16                      FORTY BYTE IND
ONE60IND EQU   32                      160 BYTE IND
LKBYTE   EQU   8                       LOCK BYTE IN FRR AREA
SYNCH    EQU   X'80'                   IOSYNCH INDICATOR
SALLOC   EQU   X'40'                   SALLOC INDICATOR
IRTNALCK EQU   X'F7'                   AND MASK FOR SALLOC OFF
LOW28    EQU   28                      SHIFT LEFT DISP
HI4      EQU   4                       SHIFT RIGHT DISP
ZERO     EQU   0                       DISP AND DATA
ONE      EQU   1                       DISP AND DATA
TWO      EQU   2                       DISP AND DATA
SAVDSP   EQU   0                       DISP INTO SAVE AREA TO STORE
BLK12LEN EQU   12                      LENGTH OF 12 BYTE BLOCK
EQUAL    EQU   8                       EQUAL AND ZERO BRANCH MASK
R12DISP  EQU   48                      DISP TO R 12 IN SAVE
THREE    EQU   3                       CONSTANT 3
MDLBT    EQU   X'10'                   MIDDLE BLOCK INDICATOR PASSED
*                                      IN REGISTER 11
TWTY8    EQU   28                      CONSTANT 28
SIXTEEN  EQU   16                      CONSTANT 16
THRTY2   EQU   32                      CONSTANT 32
FF       EQU   255                     MASK VALUE FOR 'NI'
BITS3    EQU   B'0011'             MASK FOR CLM INSTRUCTIONS   @ZM30148
L16      EQU   16
COMPFAIL EQU   13           INTERNAL FLG TO INDICATE COMPRESS FAILED
RECRD    EQU   X'C0D'              ABEND CODE TO RECORD & RETRY
         EJECT
*
***********************************************************
*        PAGE HEADER DISPLACEMENTS
*        THE PAGE HEADER HAS THE FOLLOWING FORMAT:
*
*        BLK CNT     BLK CHAIN   FLAGS BLK/PG  PAGE CHAIN
*        0..........4...........8.....A......C...........
*        I          I           I     I      I          I
*        ................................................
***********************************************************
*
PGCNT    EQU   0                       DISP OF BLK CNT IN PG HDR
PGBLK    EQU   4                       BLK PTR IN PG HDR
PGFLGS   EQU   8                       PAGE DESCRIPTOR FLAGS
PGINIT   EQU   X'80'                   INITIAL PAGE INDICATOR
LASTINIT EQU   X'40'                   LAST INITIAL PAGE
MAXCNT   EQU   10                      MAX CNT BLK/PG DISP IN PG HDR
PGCHN    EQU   12                      PAGE CHAIN DISP WITHIN HEADER
PGHD     EQU   X'20'                   LEN OF PAGE HEADER
PGHD12   EQU   X'10'                   LEN OF PAGE HEAD, 12 BYTE BLKS
PGSIZE   EQU   2048                SIZE OF 2K PAGE FOR 12BYTE BLKS
PGSZ4K   EQU   4095                4K-1 FOR STORAGE CHECK VALIDATION
PGID     EQU   X'10'                   OFFSET TO EBCDIC ID
LASTBLK  EQU   PGID+12             OFFSET TO WORD USED BY COMPRESS
*        TO KEEP TRACK OF LAST BLOCK IN TEMPORARY CHAIN IN PAGE
*        NOTE  WILL OVERLAY LAST WORD OF EYE CATCHER
         EJECT
*
************************************************************
*        POOL HEADER DISPLACEMENTS
*        THE FOLLOWING IS THE POOL HEADER LAYOUT:
*        IE. THESE ARE THE HEADERS FOR THE PAGE CHAINS
*
*        BLKS/  BLK  FLAGS & RES PAGE  PAGE   PAGE CHAIN
*        PAGE   LEN              TOL   CNT
*        0....2.....4...........8.....A......C...........
*    12  I    I     I           I     I      I          I
*        ................................................
*    40  I    I     I           I     I      I          I
*        ................................................
*   160  I    I     I           I     I      I          I
*        ................................................
************************************************************
BLKCNT   EQU   0                       BLKS/PAGE
BLKLEN   EQU   2                       BLK LEN
HDRRES   EQU   4                       DISP OF RES BYTES IN HDR YM01932
PTOLE    EQU   8                       MIN NO PGS FOR POOL DISP PG HDR
PTOLE4   EQU   24                      MIN NO PGS FOR POOL MIDDLE
NOPGS    EQU   10                      PG CNT DISP IN POOL HDR
*  PGCHN MAY ALSO BE USED TO REFRENCE THE PAGE PTR FROM POOL HDR
*         BLOCK DISPLACEMENTS
BLKLINK  EQU   0                       BLOCK LINK AREA
         SPACE 2
*   EQUATES DESCRIBING POOL SIZES,TOLERANCES,ETC.
         SPACE 2
SMLBP    EQU   169                      BLKS/PAGE - SMALL BLOCKS
SMLBL    EQU   12                       BLK/LEN - SMALL BLOCKS
SMLPTOL  EQU   1                        PAGE TOLERANCE - SMALL
MDLBP    EQU   84                       BLKS/PAGE - MIDDLE BLOCKS
MDLBL    EQU   48                       BLK/LEN - MIDDLE BLOCKS
MDLPTOL  EQU   1                        PAGE TOLERANCE - MIDDLE
LRGBP    EQU   24                       BLKS/PAGE - LARGE BLOCKS
LRGBL    EQU   168                      BLK/LEN - LARGE BLOCKS
LRGPTOL  EQU   2                        PAGE TOLERANCE - LARGE
         EJECT
         USING IECVSMGR,BASEREG
         USING PSA,REG0
         USING FRRSMGR,FRRAREA                                 @ZA12704
*
********************
*        BRANCH TABLE
********************
*
         B     GETBLK                  GET NORMAL BLOCK
         B     FREEBLK                 FREE NORMAL BLOCK
         B     PRGFREE                 PURGE-FREE (OUT OF MEM)
         B     GETBLK0                 GET 12 BYTE BLK
         B     FRBLK0                  FREE 12 BYTE BLK
         B     GETBLK4                 GET 40 BYTE BLOCK
         B     FRBLK4                  FREE 40 BYTE BLOCK
SMGRHDRS DC    A(IECVSHDR)         POINTER TO STORAGE HEADERS  @ZA12704
         SPACE 4
         DC    CL8'IECVSMGR'           STORAGE DUMP ID         @ZA08447
         DC    C'&SYSDATE'                                     @ZA08447
         TITLE 'IECVSMGR - GETBLOCK 12 BYTE BLOCKS'
*
************************************************************
*        THIS ROUTINE PASSES A 12 BYTE BLOCK OF STORAGE TO
*        THE CALLER OF STORAGE MANAGER. THE 12 BYTE FREE QUEUE
*        IS CHECKED FOR A FREE BLOCK. IF THERE ARE NONE A NEW 2K
*        PAGE OF BLOCKS IS GOTTEN AND FORMATTED, AND THE BLOCKS
*        PUT ON THE FREE QUEUE. THE CALLER MUST TURN ON THE IOQALOC
*        FLAG IMMEDIATELY AFTER RECEIVING THE BLOCK AND THE FLAG
*        MUST BE LEFT ON FOR VALIDITY CHECKING WHEN BLOCK IS
*        FREED. TO JUST TURN THE FLAG ON BEFORE FREEING DEFEATS
*        THE PURPOSE OF THIS CHECK.
***********************************************************
*
         SPACE 5
*
********************
*        ATTEMPT TO GET A BLOCK OFF FREE QUEUE (ANCHOR12)
********************
*
*  THE NEXT 2 INSTR REPLACE LM FOR PERFORMANCE,MUST REMAIN IN ORDER.
GETBLK0  L     CNTREG,CNT12        GET FREE CNT + SYNCH CNT 12BYTE
         L     BLKREG,ANCHOR12     TOP FREE 12 BYTE BLOCK
GETBLK0B LTR   BLKREG,BLKREG       ANY FREE 12 BYTE BLOCKS ?
         BZ    GETCORE0            GO GET ANOTHER 2K PAGE
         LR    REG0,CNTREG         TO UPDATE COUNT
         AL    REG0,DECCNT         DECREMENT FREE COUNT, INCREMENT
*                                  SYNCH COUNT
         L     BLKREGLK,BLKLINK(BLKREG) LOAD NEXT BLK IN CHAIN
         CDS   CNTREG,REG0,HEAD12  ATTEMPT TO TAKE OFF QUEUE
         BNE   GETBLK0B            SWAP FAILED, TRY AGAIN
         SPACE
         BR    RETREG              RETURN TO CALLER
         SPACE 5
GETCORE0 LTR   SAVEREG,SAVEREG         DID CALLER SUPPLY SAVE AREA
         BNZ   SAVE130                 YES - GO TO SAVE REGS
*
********************
*        NO - FIND LCCA SAVE AREA
********************
*
         L     SAVEREG,PSALCCAV(REG0)  LOAD PCCA ADDR FROM PSA
         USING LCCA,SAVEREG
         L     SAVEREG,LCCACPUS        GET PTR TO SAVE AREA VECT TAB
         DROP  SAVEREG
         USING WSAC,SAVEREG
         L     SAVEREG,WSACIOS         LOAD IOS SAVE AREA ADDR
         DROP  SAVEREG
SAVE130  STM   REG2,RETREG,ZERO(SAVEREG) SAVE REGS
         LR    CNTREG,IRTREG           LOAD IRT PTR TO TRACK
         USING LCCA,CNTREG
         LR    BLKREG1,SAVEREG         SAVE SAVE AREA PTR
SETLOCK0 SETLOCK OBTAIN,TYPE=SALLOC,MODE=UNCOND,RELATED=(GETMAIN,IECVSM*
               GR(R1))
*
********************
*        SET PRINT IN IRT
********************
*
         OI    IRTFLA,IRTALCK          SET SALLOC HELD
         LR    HDRREG,BASEREG          SAVE BASE ACCROSS GETMAIN
         GETMAIN RU,LV=2048,SP=245,BRANCH=(YES,GLOBAL),KEY=0
         LR    BASEREG,HDRREG          RESTORE BASE REG
R1       SETLOCK RELEASE,TYPE=SALLOC,DISABLED,RELATED=(GETMAIN,IECVSMGR*
               (SETLOCK0))
*
********************
*        RESET IRT PRINT AND FORMAT THE PAGE
********************
*
         NI    IRTFLA,IRTNALCK         SET SALLOC SURRENDERED
         DROP  CNTREG
         LM    REG2,RETREG,ZERO(BLKREG1) RESTORE REGS
         LR    PGREG,BLKREGLK          LOAD NEW PAGE PTR
STORFMT0 LH    CNTREG,BLKCNT0          LOAD COUNT INFO
         ST    CNTREG,PGCNT(,PGREG)    STORE BLK CNT IN PG HDR
         ST    CNTREG,LO8(,PGREG)      STORE MAX CNT IN PG HDR
         LA    BLKREG,PGHD12(,PGREG)   ADDR OF FIRST BLK
         ST    BLKREG,PGBLK(,PGREG)    STORE FIRST BLK PTR
         BCTR  CNTREG,0                DECREMENT COUNT FOR LOOP
BLKCHNR0 LA    BLKREGLK,BLK12LEN(,BLKREG) PTR TO NEXT BLK
         ST    BLKREGLK,BLKLINK(,BLKREG)  CHAIN THIS TO NEXT
         LR    BLKREG,BLKREGLK         UP TO NEXT BLK
         BCT   CNTREG,BLKCHNR0         CONTINUE TO CHAIN
         ST    CNTREG,BLKLINK(,BLKREG)  ZERO LAST BLK CHAIN FIELD
UPHDR0   LM    CNTREG,BLKREG,HEADER0+PTOLE    PREPARE TO PUSH DOWN
UPHDR01  LA    REG0,ONE(,CNTREG)       UP PAGE COUNT
         ST    BLKREG,PGCHN(,PGREG)    CHAIN OLD PAGES TO NEW
         LR    BLKREGLK,PGREG          SAVE PTR TO FIRST PAGE
         CDS   CNTREG,REG0,HEADER0+PTOLE  ATTEMPT TO SWAP
         BE    CHAIN12        PUT NEW CHAIN OF FREE BLOCK ON QUE
         B     UPHDR01                 TRY SWAP AGAIN
         EJECT
*
********
*        CHAIN FREE BLOCKS ON FREE QUEUE
********
CHAIN12  L     BLKREGLK,PGBLK(,PGREG)   GET TO OF CHAIN TO ADD
         LR    PGREG,BLKREG   SAVE POINTER TO LAST BLOCK ON PAGE
         LM    CNTREG,BLKREG,HEAD12     GET CNT + QUE PTR FOR CDS
CHAIN12A ST    BLKREG,BLKLINK(,PGREG)      PUT OLD HEAD IN NEW TAIL
         LR    REG0,CNTREG             GET CURRENT COUNT
         AL    REG0,ADD12CHN           UPDATE SYNCH + FREE COUNT
         CDS   CNTREG,REG0,HEAD12      ATTEMPT TO SWAP
         BNE   CHAIN12A                SWAP FAILED TRY AGAIN
         SPACE
         B     GETBLK0                 GO TRY TO TAKE OFF BLOCK
         TITLE 'IECVSMGR - FREEBLOCK 12 BYTE BLOCKS'
*
************************************************************
*        THIS ROUTINE FREES 12 BYTE BLOCKS OF STORAGE ACQUIRED
*        BY GETBLOCK. IF THE BLOCK DOES NOT HAVE THE IOQALOC FLAG
*        ON, A 'C0D' ABEND IS ISSUED FROM WHICH THE FRR WILL RETURN
*        TO THE CALLER. THIS IS DONE TO PREVENT BLOCKS FROM BEING
*        FREED TWICE AND TO PREVENT INVALID BLOCKS FROM BEING PUT
*        ON THE 12 BYTE FREE QUEUE. IF THE BLOCK IS VALID, IT IS
*        PLACED ON THE FREE QUEUE BY CDS + SYNCH COUNT TO SERIALIZE
*        *NOTE IGC0001F CALLS ENABLED*
************************************************************
*
         SPACE 5
FRBLK0   TM    IOQFLB-IOQ(BLKREGLK),IOQALOC   TEST FOR ALLOCATED BLK
         BNO   ERR12               NOT ALLOCATED,SCHEDULE DUMP
         NI    IOQFLB-IOQ(BLKREGLK),FF-IOQALOC    TURN OFF FLAG
         L     CNTREG,CNT12        GET SYNCH CNT + FREE CNT
         L     BLKREG,ANCHOR12     GET FREE QUEUE ANCHOR
FRBLK0A  LR    REG0,CNTREG         GET CURRENT COUNT
         AL    REG0,UNIQUEC1       ADD 1 TO BOTH SYNCH + FREE CNT
         ST    BLKREG,BLKLINK(,BLKREGLK)  STORE OLD QUE IN NEW FREE BLK
         CDS   CNTREG,REG0,HEAD12  TRY TO PUT BLK BACK ON
         BER   RETREG              OK, RETURN TO CALLED
         B     FRBLK0A             FAILED, TRY AGAIN
         EJECT
ERR12    EQU   *                   INVALID IOQ DETECTED
         STM   REG0,BLKREGLK,FRRDUMMY   REGS DESTROYED BY ABEND
*                                       JUST USED FOR DEBUGGING
         ABEND RECRD,,,SYSTEM      CAUSE FRR TO GET CONTROL
         TITLE 'IECVSMGR - GETBLOCK 40 BYTE BLOCK'
*
****************************************************
*
*        THIS ROUTINE PASSES A 40 BYTE BLOCK OF STORAGE TO
*        THE CALLER OF STORAGE MANAGER.THE ASID OF THE
*        MEMORY REQUESTING THE STORAGE IS INPUT TO STORAGE
*        MANAGER IN A PARAMETER REGISTER. IF THE FREE QUEUE IS
*        EMPTY, A 4K PAGE OF SP 245 IS GOTTEN, FORMATTED AND THE
*        BLOCKS PUT ON THE 40 BYTE FREE QUEUE (ANCHOR40). AS A BLK
*        IS ALLOCATED THE ASID IS STORED IN THE 8 BYTE PREFIX
*        WHICH PRECEDES EACH 40 BYTE BLOCK
*        INPUT IS: ASID IN LOW ORDER 2 BYTES OF REG11 (BLKREG)
*        OUTPUT IS: ADDR OF BLOCK IN REG11
*        THE 8 BYTE PREFIX CONTAINS ASID IN BYTES 0-1, ALLOC FLG X'75'
*            IN BYTE 3, BYTES 4-7 HAVE A PTR TO PAGE THAT THE BLOCK
*            CAME FROM USED TO VALIDITY CHECK THE BLOCK
*****************************************************
*
         SPACE 5
GETBLK4  STM  REG0,RETREG,ZERO(SAVEREG)     SAVE REGS 0-14
*        REGS 8-14 SAVE FOR FRR OTHERWISE NOT USED MAIN PATH
         LR    CHAINREG,BLKREG         SAVE ASID
         SLL   CHAINREG,SIXTEEN    MOVE TO BYTES 0&1
GETBLK4A L     CNTREG1,CNT40       GET SYNCH + FREE COUNT
         L     BLKREG1,ANCHOR40    GET 40 BYTE BLOCK QUE HEAD
GETBLK4B EQU   *                                               @ZA04542
         LTR   BLKREG1,BLKREG1     ANY BLOCKS ON FREE QUEUE    @ZA04542
         BZ    GETPG40             OUT OF BLOCKS, GET ANOTHER PAGE
         LR    REG0,CNTREG1        GET OLD COUNT
         AL    REG0,DECCNT         DECREMENT FREE CNT, INCREMNT SYNCH
         L     BLKREGLK,BLKLINK(,BLKREG1)  GET NEXT BLK IN CHAIN
         CDS   CNTREG1,REG0,HEAD40
         BNE   GETBLK4B            COMPARE FAILED, RETRY
         LR    BLKREG,BLKREG1      SET RETURN PARM
         S     BLKREG1,FEIGHT      GET FRONT OF PREFIX
         CLI   ALLOCFLG(BLKREG1),FREE40    CHECK FOR VALID FREE
         BNE   ERR40G              GO SCHEDULE SDUMP
         O     CHAINREG,ALLOCW     TURN ON ALLOCATED FLAGS
         ST    CHAINREG,ASIDPRE(,BLKREG1)   STORE ASID AND ALLOC FLAG
         LM    REG0,BLKREG1,ZERO(SAVEREG)   RESTORE 0-7
         BR    RETREG
*
*
         EJECT
GETPG40  EQU   *                   OUT OF PAGES OF 40 BYTE BLOCKS
         STM   HDRREG,RETREG,THRTY2(SAVEREG) SAVE 8-14 (REST OF REGS)
         L     CNTREG,PSALCCAV         POINT AT LCCA
         USING LCCA,CNTREG             INDICATE LCCA ADDRESSIBILITY
         OI   IRTFLA,IRTALCK           SET SALLOC HELD
         LR   HDRREG,SAVEREG           SAVE SAVE AREA REG
SETLOCK4 SETLOCK OBTAIN,TYPE=SALLOC,MODE=UNCOND,RELATED=(GETMAIN,IECVSM*
               GR(SETLOCK5))
         LR   CNTREG1,BASEREG          SAVE BASE ACROSS GETMAIN
         GETMAIN RU,LV=4096,SP=245,BRANCH=(YES,GLOBAL),KEY=0
         LR   BASEREG,CNTREG1          RESTORE BASE REG
SETLOCK5 SETLOCK RELEASE,TYPE=SALLOC,RELATED=(GETMAIN,IECVSMGR(SETLOCK4*
               ))
         LR   SAVEREG,HDRREG           RESTORE SAVE AREA POINTER
         NI   IRTFLA,IRTNALCK          SALLOC NOT HELD
         DROP CNTREG
         LR    PGREG,BLKREGLK          NEW PAGE POINTER
         LH    CNTREG,BLKCNT4          LOAD COUNT INFO
         LH   BLKREG1,BLK4LEN          LOAD LENGTH OF BLOCK
         ST    CNTREG,PGCNT(,PGREG)     STORE BLK CNT IN PAGE HEADER
         ST    CNTREG,LO8(,PGREG)       STORE MAX CNT IN PAGE HEADER
         MVC   PGID(L16,PGREG),PGID40   INIT TO VALIDITY CHECK BLKS
         LA    BLKREG,PGHDPRE(,PGREG)   ADR BEYOND HEADER + PREFIX
         ST    BLKREG,PGBLK(,PGREG)     SET FIRST BLOCK POINTER
         LR    CNTREG1,BLKREG           GET BLOCK TO BACK UP FROM
         S     CNTREG1,FEIGHT           BACK UP EIGHT TO BLOCK PREFIX
         L     REG0,FREE40FW            GET FREE BLOCK FLAG
         BCTR  CNTREG,0                 INSURE OF STOPPING AT LAST
BLKCHNR4 LA    BLKREGLK,ZERO(BLKREG1,BLKREG) FIND ADDR OF NEXT BLOCK
         ST    PGREG,PREFXPGE(,CNTREG1)   PT  PREFX TO PAGE BLK FROM
         ST    REG0,ASIDPRE(,CNTREG1)        SET NEXT FREE FLAG
         ST    BLKREGLK,BLKLINK(,BLKREG)  STORE CHAIN
         LA    CNTREG1,ZERO(BLKREG1,CNTREG1)   GET NEXT PREFIX
         LR    BLKREG,BLKREGLK          GET NEXT
         BCT   CNTREG,BLKCHNR4          CONTINUE IF MORE
         ST    CNTREG,BLKLINK(,BLKREG)  SET LAST IN CHAIN TO ZERO
         ST    REG0,ASIDPRE(,CNTREG1)   SET LAST FREE FLAG
         ST    PGREG,PREFXPGE(,CNTREG1)  PT TO PAGE BLK IS FROM
         LR    BLKREG1,BLKREG           SAVE PTR TO LAST ON NEW CHAIN
UPHDR4   LM    CNTREG,BLKREG,HEADER0+PTOLE4  PREPARE TO PUSH DOWN
UPHDR4A  LA    REG0,ONE(,CNTREG)        UP PAGE COUNT
         ST    BLKREG,PGCHN(,PGREG)     CHAIN OLD PAGES TO NEW
         LR    BLKREGLK,PGREG           SAVE POINTER TO NEW PAGES
         CDS   CNTREG,REG0,HEADER0+PTOLE4  ATTEMPT TO COMPARE + SWAP
         BE    CHAIN40                  WORKED, GO CHAIN NEW BLOCKS
         B     UPHDR4A                  FAILED, TRY AGAIN
*
CHAIN40  L     BLKREGLK,PGBLK(,PGREG)   GET TOP OF NEW CHAIN
         LM    CNTREG,BLKREG,HEAD40     GET OLD CNT AND QUEUE TOP
CHAIN40A LR    REG0,CNTREG              GET CNT TO INCREMENT
         AL    REG0,PGCNT(,PGREG)  ADD NUMBER OF BLOCKS ON PAGE
         AL    REG0,SYNCHCNT       ADD SYNCH COUNT
         ST    BLKREG,BLKLINK(,BLKREG1) STORE OLD TOP INTO NEW TAIL
         CDS   CNTREG,REG0,HEAD40       TRY TO ADD NEW CHAIN
         BNE   CHAIN40A                 SWAP FAILED, TRY AGAIN
         LM    HDRREG,RETREG,THRTY2(SAVEREG) RESTORE 8-14
         B     GETBLK4A                 GO TAKE OFF A BLOCK
         TITLE 'IECVSMGR FREEBLOCK 40 BYTE BLOCK'
*
************************************************************
*        THIS ROUTINE FREES 40 BYTE BLOCK OF STORAGE ACQUIRED
*        BY GETBLOCK(40). THE BLOCK IS PUT ON THE FREE QUEUE IF
*        THE PROPER ALLOCATED FLAG IS ON. IF THE BLOCK DOES NOT PASS
*        THE VALIDITY TEST A 'C0D' ABEND IS ISSUED FROM WHICH THE
*        FRR SHOULD RECOVER. A SDUMP IS ISSUED IF A DUMP DATA SET
*        EXISTS.
************************************************************
*
         SPACE 5
FRBLK4   STM   REG0,RETREG,ZERO(SAVEREG) SAVE REGS 0,14
         L     CHAINREG,FREE40FW
FRBLK4C  LR    INTREG1,BLKREGLK        BLOCK TO BE FREED
         S     INTREG1,FEIGHT          POSITION TO PREFIX
         CLI   ASIDPRE+ALLOCFLG(INTREG1),ALLOC40  TEST ALLOCATED
         BNE   ERR40F
         ST    CHAINREG,ASIDPRE(,INTREG1)
         L     CNTREG,CNT40        GET SYNCH + FREE COUNT
         L     BLKREG,ANCHOR40     GET 40 BYTE BLOCK QUE HEAD
* NOTE THE LM INSTR WAS REPLACED BY 2 LOADS FOR PERFMNCE, KEEP IN ORDER
FRBLK4D  LR    REG0,CNTREG         GET OLD COUNT
         ST    BLKREG,BLKLINK(BLKREGLK) PUSH DOWN BLOCK
         AL    REG0,UNIQUEC1       INCREMENT UNIQUE COUNT      @ZA03644
         CDS   CNTREG,REG0,HEAD40  PUT NEW BLOCK ON QUEUE
         BNE   FRBLK4D                 TRY AGAIN
EXIT40   LM    REG0,PGREG,ZERO(SAVEREG) RESTORE REGS 0-12
         BR    RETREG                  RETURN
*
*
*
         EJECT
ERR40G   EQU   *                   ERROR IN GET 40
         SLR   BLKREGLK,BLKREGLK   INDICATE GET 40
         B     ERR40
ERR40F   EQU   *                   ERROR DETECTED IN FREE 40
         LA    BLKREGLK,TWO        NON ZERO MEANS FREE 40
ERR40    EQU   *                   ERROR IN THE FREE OF 40 BYTE BLK
         L     REG2,SMGRFRRA       GET FRR ADDR
         SETFRR A,PARMAD=(FRRAREA),FRRAD=(2),WRKREGS=(3,6) ING
         OI    FRRFLA,FRRMED+FRRDEL     SET MED REQ + DEL IN FRR
         LTR   BLKREGLK,BLKREGLK   SEE IF GET OR FREE
         BNZ   ERR40A              NO, LEAVE AS FREE
         OI    FRRFLA,FRRGET       INDICATE GET REQUEST
ERR40A   EQU   *
         STM   SAVEREG,RETREG,FRRSVA    SAVE FOR RETRY
         ABEND RECRD,,,SYSTEM      CAUSE FRR TO GET CONTROL
         TITLE 'IECVSMGR - GETBLOCK 160 BYTE BLOCKS'
*
************************************************************
*        THIS ROUTINE ALLOCATES 160 BYTE BLOCKS OF STORAGE
*        THE NUMBER OF BLOCKS REQUESTED, THE ASID OF THE MEMORY
*        REQUESTING THE STORAGE AND THE SIZE BLOCK REQUESTED
*        (160) IS INPUT TO STORAGE MANAGER IN A PARAMETER
*        REGISTER. IF MORE THEN ONE BLOCK IS REQUESTED THE BLOCKS
*        ARE CHAINED IN THE FIRST WORD. IF THE 160 BYTE BLOCK
*        FREE QUEUE IS EMPTY, A NEW 4K PAGE IS GOTTEN, FORMATTED
*        AND ADDED TO THE FREE QUEUE.
*        AS EACH BLOCK IS ALLOCATED THE ASID OF THE REQUESTOR
*        IS STORED IN THE 8 BYTE PREFIX WHICH PRECEEDS EACH
*        160 BYTE BLOCK.
*        BEFORE A BLOCK IS GIVEN OUT, IT IS CHECKED TO SEE IF IT
*        IS MARKED FREE. IF NOT AN 'C0D' ABEND IS ISSUED, AN SDUMP
*        AND RECORD ISSUED, AND THE FREE QUE ZEROED. THE FRR WILL
*        RETRY BY GETTING A NEW QUEUE. AS EACH BLOCK IS ALLOCATED
*        A X'76' IS PUT IN 4TH BYTE OF THE PREFIX FOR CHECKING ON
*        FREE. WHEN GETTING ANOTHER 4K PAGE
*        THE ROUTINE OPERATES UNDER THE IOSYNCH LOCK TO AVOID
*        POSSIBLE DESTRUCTIVE INTERSECTION WITH OTHER CPU(S).
************************************************************
*
         SPACE 5
*
********************
*        SET UP FOR INITIAL PASS
********************
*
GETBLK   STM   REG0,PGREG,ZERO(SAVEREG) SAVE REGS
         L     REG2,SMGRFRRA           LOAD STORAGE MGR FRR ADDR
         SETFRR A,PARMAD=(FRRAREA),FRRAD=(2),WRKREGS=(3,6)
         OI    FRRFLA,FRRGET           SET GET BLOCK REQUEST
         ST    SAVEREG,FRRSVA      SAVE REG13 FOR FRR
         ST    RETREG,FRRSVB       SAVE REG14 FOR FRR
* NOTE  2 ST INSTR FASTER THAN STM, R13 R14 ONLY RELOADED BY FRR
* AND  GETPG, OTHERWISE NOT USED
GETBLKA  SLR   CHAINREG,CHAINREG       CLEAR BLK CHAIN REG
         LR    CNTREG,BLKREG           COPY OPTION INFO
         SRDL  CNTREG,LO8              SHIFT BLK TYPE INTO REG
         STH   CNTREG,FRRASID          SAVE ASID
         SRL   CNTREG,LO20             SHIFT OUT ASID GET CNT
         SRL   BLKREG,LO24             SHIFT OUT RESIDUAL
         SPACE 5
GBHDCHN  L     CNTREG1,CNT160      GET SYNCH + FREE CNT OF 160BYTE BLKS
         L     BLKREG1,ANCHR160    GET TOP BLOCK ON THE FREE QUEUE
GB160B   LTR   BLKREG1,BLKREG1     ANY FREE BLOCKS?
         BZ    GETPG               GO SET UP TO GET A PAGE
*
********************
*        THIS SECTION DOES THE ACTUAL REMOVAL OF BLOCKS FROM
*        THE FREE BLOCK CHAIN. THIS IS DONE WITH COMPARE AND
*        AND SWAP LOGIC .
********************
*
BLKGET   LR    REG0,CNTREG1        TRANSFER BLOCK COUNT        @ZM30148
         AL    REG0,DECCNT         DECREMENT FREE CNT, INC. SYNCH CNT
         L     BLKREGLK,BLKLINK(,BLKREG1) GET NEXT BLK IN CHAIN
         CDS   CNTREG1,REG0,HEAD160     TRY TO TAKE BLK OFF QUEUE
         BNE   GB160B              FAILED, TRY AGAIN
         ST    CHAINREG,BLKLINK(BLKREG1) CHAIN BLOCKS IF NEEDED
         LR    CHAINREG,BLKREG1        UPDATE CHAIN POINTER
         S     BLKREG1,FEIGHT          POSITION IN FRONT OF PREFIX
         CLI   ALLOCFLG(BLKREG1),FREE160     TEST THAT NOT ALLOCATED
         BNE   ERR160                        GO TAKE A PICTURE
         L     PGREG,FRRASID       PUT 1/2 WRD ASID IN HIGH 2 BYTES
         IC    PGREG,ALLC160B      TURN ON ALLOCATE FLAG
         ST    PGREG,ASIDPRE(,BLKREG1)  SET ASID AND ALLOC FLAG
         BCT   CNTREG,GBHDCHN          GET ANOTHER BLK IF NEEDED
         LR    BLKREG,CHAINREG         LOAD FOR RETURN
         SETFRR D,WRKREGS=(2,1)
         LM    REG0,CNTREG,SAVDSP(SAVEREG)  RESTORE 0-10
         L     PGREG,R12DISP(SAVEREG)  RELOAD 12
         BR    RETREG                  RETURN
         EJECT
GETPG    EQU   *
         STM   SAVEREG,RETREG,FRRSVA    SAVE R13-R14
         LA    HDRREG,PAG160HD     GET HEAD OF PAGE CHAIN
         L     BLKREG,IOSADDR      GET IOSYNCH LOCK ADDR
PG160LKG SETLOCK  OBTAIN,TYPE=IOSYNCH,MODE=COND,ADDR=(11),RELATED=(SMGR*
               POOL,IECVSMGR(PG160LKF,FRLK,GCBSY))
         LTR   SAVEREG,SAVEREG     CHECK IF I GOT THE LOCK
         BNZ   RGBHDCHN            LOCK HELD, SEE IF BLOCKS RETURNED
         SPACE
GOTLOCKU OI    FRRFLA,FRRSYNCH     INDICATE SYNCH LOCK HELD
         L     BLKREG1,ANCHR160    IS FREE QUE STILL ZERO
         N     BLKREG1,TESTZERO    IF SO SKIP TESTS
         BZ    PG160GM             YES, GET ANOTHER PAGE
         L     CNTREG1,CNT160      GET THE COUNT AGAIN
         N     CNTREG1,HIGH2OFF    TURN OFF 2 HIGH ORDER BYTES
         C     CNTREG1,MIN160      IF NO. STILL LOW, GO GET PAGE
         BH    PG160LKF            BLOCKS RETURNED, GO FREE LOCK
PG160GM  BAL   INTREG1,GETCORE     GET ANOTHER PAGE
*  ON RETURN  PGREG CONTAINS PAGE ADDR & BLKREG LAST BLOCK ON PAGE
*
         MVC   PGID(L16,PGREG),PGID160  INIT TO VALIDITY CHECK BLKS
*        NOW PUT THIS CHAIN OF BLOCKS FROM NEW PAGE ONTO FREE QUEUE
         LM    CNTREG1,BLKREG1,HEAD160  GET CNTS & FREE QUE HEAD
         L     BLKREGLK,PGBLK(,PGREG)   GET TOP BLOCK NEW PAGE
PG160CDS LR    REG0,CNTREG1        COPY CNT REG
         AL    REG0,ADCHN160       ADD NO. BLKS/PAGE + SYNCH COUNT
         ST    BLKREG1,BLKLINK(,BLKREG)  PUT OLD TOP IN LAST OF CHAIN
         CDS   CNTREG1,REG0,HEAD160     TRY TO PUT NEW CHAIN ON QUE
         BNE   PG160CDS                 FAILED, TRY AGAIN
         SPACE
         L     BLKREG,IOSADDR      SYNCH LOCK ADDR
PG160LKF SETLOCK RELEASE,TYPE=IOSYNCH,ADDR=(11),RELATED=(SMGRPOOL,IECVS*
               MGR(PG160LKG))
         NI    FRRFLA,FF-FRRSYNCH  TURN OFF FLAG
RTNGBLK  LM    SAVEREG,RETREG,FRRSVA    RESTORE R13-R14
         SPACE
         B     GBHDCHN             GO TRY TO GET BLOCK AGAIN
         SPACE
RGBHDCHN L     RETREG,FRRWRK       GET COUNT OF ATEMPTS AT LCK @ZM41373
* NOTE FRRWRK ALSO USED BY FRR - ON A RETRY MAY BE INVALID CNT @ZM41373
* BUT THIS IS OK - ONLY WILL CAUSE UNCONDITIONAL SETLOCK       @ZM41373
         LA    RETREG,ONE(,RETREG) ADD ONE TO COUNT            @ZM41373
         ST    RETREG,FRRWRK       SAVE (TEMP) FOR NXT PASS    @ZM41373
         C     RETREG,MAXSLL       COMPARE WITH MAX FOR LOOP   @ZM41373
*                                  ON IOSYNCH LOCK, IF TOO MANY@ZM41373
*                                  GET LOCK UNCOND TO OPEN     @ZM41373
*                                  WINDOW (EG MAY BE ACR)      @ZM41373
         BL    RTNGBLK             RETRY GETBLK, NOT 2 MANY    @ZM41373
         SPACE
*  HAVE LOOPED TOO MANY TIMES REQUEST LOCK UNCOND              @ZM41373
PG160LKU SETLOCK  OBTAIN,TYPE=IOSYNCH,MODE=UNCOND,ADDR=(11),RELATED=(SM*
               GRPOOL,IECVSMGR(PG160LKF))                      @ZM41373
         SPACE
         B     GOTLOCKU            GOT THE LOCK, GET THE PAGE  @ZM41373
         SPACE 6
ERR160   EQU   *                   THIS ROUTINE HANDLES INVALID REQUEST
         ABEND RECRD,,,SYSTEM      CAUSE FRR TO GET CONTROL
         TITLE 'IECVSMGR - FREEBLOCK 160 BYTE BLOCKS'
*
************************************************************
*        THIS ROUTINE FREES 160 BYTE BLOCKS ACQUIRED BY GETBLOCK.
*        SINGLE OR MULTIPLE BLOCKS MAY BE FREED BUT THE LINK PTR
*        OF THE LAST BLOCK MUST BE ZERO. REG1 POINTS TO THE 1ST
*        BLOCK OF THE INPUT CHAIN. THE PREFIX OF EACH BLOCK IS
*        VALIDITY CHECKED. IF ANY BLOCK ON THE CHAIN TO BE FREED
*        IS INVALID, ALL BLOCKS ARE THROWN AWAY, A 'C0D' ABEND IS
*        ISSUED TO RECORD AND ISSUE AN S DUMP IF DUMP DATA SET EXISTS.
*        RETRY SHOULD RETURN TO THE CALLER WITHOUT RETURNING THE
*        BLOCKS TO THE FREE QUEUE.
************************************************************
*
FREEBLK  STM   REG0,PGREG,ZERO(SAVEREG) SAVE REGS
         L     REG2,SMGRFRRA           GET FRR ADDR
         SETFRR A,PARMAD=(FRRAREA),FRRAD=(2),WRKREGS=(3,5)
         ST    SAVEREG,FRRSVA      SAVE REG13 FOR FRR
         ST    RETREG,FRRSVB       SAVE REG14 FOR FRR
* NOTE  2 ST INSTRS FASTER THAN STM & REG13-REG14 ONLY RELOADED
*  BY FRR
PURGBLK  SR    CNTREG,CNTREG       ZERO REG TO COUNT BLOCKS
         L     INTREG1,PGID160     INITIALIZE REG TO TEST BLOCK
         EJECT
***************************************************************
*        SCAN THE LIST OF BLOCKS TO BE FREED, VALIDITY CHECK
*        THEM, IF VALID, CHAIN ALL TO FREE QUEUE IN ONE CDS
*        OPERATION
***************************************************************
         L     HDRREG,FREE160W          LOAD WORD TO ZERO ASID & SET
FREE160A LR    BLKREG,BLKREGLK     GET 1ST BLOCK, BUT KEEP BLKREGLK
FREE160B L     CHAINREG,BLKLINK(,BLKREG)     GET NXT BLK IF ONE
         S     BLKREG,FEIGHT            BACK UP TO PREFIX
         CLI   ALLOCFLG(BLKREG),ALLOC160  IS THIS BLOCK ALLOCATED
         BNE   ERR160                     NO, DONT FREE AGAIN
         L     PGREG,PREFXPGE(,BLKREG)    GET PAGE BLOCK CAME FROM
         CL    INTREG1,PGID(,PGREG)       DOES PAGE HAVE VALID ID
         BNE   ERR160                     NO, GO TAKE PICTURE,BAD BLCK
         ST    HDRREG,ASIDPRE(,BLKREG)    SET FREE FLG + ZERO ASID
         AL    CNTREG,UNIQUEC1            ADD 1 FOR SYN CNT + FREE CNT
         LTR   CHAINREG,CHAINREG          ANY MORE BLOCKS ?
         BZ    ENQ160                     END OF NEW CHAIN, GO ENQ
         LR    BLKREG,CHAINREG     CHECK NEXT BLK IN CHAIN
         B     FREE160B            LOOP BACK + REPEAT CHECKS
         EJECT
*********
*   PUT CHAIN OF BLOCKS TO BE FREED, AT HEAD OF FREE QUEUE
*********
*        BLKREG SHOULD POINT TO LAST BLOCK PREFIX THAT IS BEING ADDED
ENQ160   L     CNTREG1,CNT160      GET SYNCH + FREE CNT
ENQ160A  L     BLKREG1,ANCHR160    GET FREE QUE ANCHOR
*  NOTE  2 LOADS DONE FOR PERFORMANCE, KEEP IN ABOVE ORDER
ENQ160B  LR    REG0,CNTREG1        GET CURRENT COUNT
         AR    REG0,CNTREG         ADD CHANGE IN SYNCH CNT + FREE CNT
         ST    BLKREG1,PREFIXLN+BLKLINK(,BLKREG)  STORE OLD HEAD
*                                                IN TAIL OF NEW CHAIN
         CDS   CNTREG1,REG0,HEAD160     TRY TO PUT CHAIN ON
         BNE   ENQ160B             LOOP AGAIN
         SPACE 5
         SPACE 5
*
********************
*        SET UP FOR RETURN (RESTORE REGISTERS).
********************
*
FBRET0   EQU   *
         SETFRR D,WRKREGS=(1,2)
         LM    REG0,PGREG,SAVDSP(SAVEREG) RESTORE 0-12
         BR    RETREG                  RETURN
         TITLE 'IECVSMGR - GET AND FORMAT PAGE FOR 40/160 BYTE BLOCKS'
*
************************************************************
*        THIS ROUTINE GETS AND FORMATS 4K PAGES OF SQA STORAGE
*        AS THEY ARE NEEDED BY STORAGE MANAGER. EACH PAGE IS
*        FORMATTED INTO 24 160BYTE BLOCKS WITH 8 BYTE HEADERS.
*        THE BLOCKS ARE MARKED AS BEING FREE, THE PAGE IS
*        CHAINED TO THE CHAIN OF 160 BYTE BLOCK PAGES AND THE
*        CHAIN OF BLOCKS IS CHAINED TO THE FREE QUEUE
*
*        THIS ROUTINE IS CALLED BY IECVPRM (STORAGE PRIMER) AT
*        IPL TIME AND BY GET 160 BYTE BLOCK ROUTINE AS ADDITIONAL
*        STORAGE IS NEEDED. GET 160 ENTERS THIS ROUTINE WITH
*        IOSYNCH LOCK TO SERIALIZE AGAINST COMPRESS & PURGE &
*        GET 160 ITSELF
***********************************************************
*
GET160PG EQU   *              COME HERE TO GET PAGES OF 160BYT BLOCKS
GET40PG  EQU   *              ALSO TO GET PAGES OF 40 BYTE AT NIP TIME
GETCORE  SETLOCK OBTAIN,TYPE=SALLOC,MODE=UNCOND,RELATED=(GETMAIN,IECVSM*
               GR(R5))
         OI    FRRFLA,FRRALLOC         SET SALLOC INDICATOR
         LR    BLKREG1,BASEREG         SAVE 15 ACROSS GM
         LR    REG2,FRRAREA            SAVE FRR SAVE AREA
         GETMAIN RU,LV=4096,SP=245,BRANCH=(YES,GLOBAL),KEY=0
         LR    BASEREG,BLKREG1         RESTORE REG 15
         LR    FRRAREA,REG2            RESET FRR SAVE AREA PTR
         SETLOCK RELEASE,TYPE=SALLOC,RELATED=(GETMAIN,IECVSMGR(GETCORE)*
               )
         NI    FRRFLA,FF-FRRALLOC      RESET LOCK INDICATOR
         LR    PGREG,BLKREGLK          GET PAGE ADDRESS
         SPACE 5
*
********************
*        THIS SECTION FORMATS THE GOTTEN STORAGE.
********************
*
COREFMT  LH    CNTREG1,BLKCNT(HDRREG)  LOAD CNT AND NO. OF
*                                      BLKS/PAGE FROM HEADER
         LH    BLKREG1,BLKLEN(HDRREG)  LOAD BLOCK LENGTH
         ST    CNTREG1,PGCNT(PGREG)    STORE BLKS/PG IN NOW CNT
         ST    CNTREG1,PGFLGS(PGREG)   STORE BLKS/PG IN MAX CNT
         LA    BLKREG,PGHD(PGREG)      UP BEYOND PG HEADER
         LR    REG2,BLKREG         GET CURRENT BLOCK PREFIX
         L     REG0,FREE160W       INITIALIZE PREFIX (40 & 160 BLK)
         LA    BLKREG,PREFIXLN(BLKREG) PAST PREFIX
         ST    BLKREG,PGBLK(PGREG)     SET FIRST BLK PTR
         BCTR  CNTREG1,0               SET TO STOP AT LAST
BLKCHNR  LA    BLKREGLK,ZERO(BLKREG1,BLKREG) FIND ADDR OF NEXT BLK
         ST    REG0,ASIDPRE(,REG2) SET FREE FLG, ZERO ID
         ST    PGREG,PREFXPGE(,REG2)    PT PREFIX TO PAGE BLK IS FROM
         LA    REG2,ZERO(BLKREG1,REG2)     GET NEXT PREFIX
         ST    BLKREGLK,BLKLINK(,BLKREG)  STORE TO CHAIN
         LR    BLKREG,BLKREGLK         UP BLK PTR
         BCT   CNTREG1,BLKCHNR         CONT CHAINING BLKS
         ST    CNTREG1,BLKLINK(BLKREG)  SET LAST BLK PTR 0
*    BLKREG HAS PTR TO LAST BLOCK THIS PAGE, NEEDED LATER
         ST    REG0,ASIDPRE(,REG2)      SET FREE FLG IN LAST BLOCK
         ST    PGREG,PREFXPGE(,REG2)    PREFX PTS TO PAGE BLK IS FROM
         SPACE 5
*
********************
*        THIS SECTION UPDATES THE BLOCK TYPE HEADER TO REFLECT
*        THE NEW PAGE AND UPDATES THE PAGE QUEUE.
********************
*
UPHDR    L     BLKREG1,PGCHN(HDRREG)   LOAD FIRST PAGE ADDR
         SLR   CNTREG1,CNTREG1         CLEAR REG FOR COMP
         LTR   BLKREG1,BLKREG1         ANY PAGES IN POOL
         BP    UPHDR1                  YES - START DOWN CHAIN
*                                       ZERO = 1ST TIME INIT.
*                                       MINUS= FRR RESTRUCTURE
         LR    BLKREG1,HDRREG          SET TO PUT IN HEADER
         B     UPHDR2                  CHAIN IT IN
UPHDR1   C     CNTREG1,PGCHN(BLKREG1)  IS THIS LAST PAGE
         BE    UPHDR2                  YES - ATTACH HERE
         L     BLKREG1,PGCHN(BLKREG1)  UP TO NEXT PAGE
         B     UPHDR1                  CHECK THIS AS LAST
UPHDR2   ST    PGREG,PGCHN(BLKREG1)    CHAIN AS LAST
         ST    CNTREG1,PGCHN(PGREG)    STORE DELIMITER
         LH    CNTREG1,NOPGS(HDRREG)   LOAD PAGE COUNT
         LA    CNTREG1,ONE(CNTREG1)    ADD ONE TO PAGE CNT
         STH   CNTREG1,NOPGS(HDRREG)   UPDATE HEADER
         LR    BLKREGLK,PGREG          GET PAGE PTR FOR INIT MARK
         BR    INTREG1                  RETURN AFTER  FREELOCK
         EJECT
GET12PG  EQU   *                   GET INITIAL PAGE OF 12BYTE BLKS
INIT12   SETLOCK OBTAIN,TYPE=SALLOC,MODE=UNCOND,RELATED=(GETMAIN,IECVSM*
               GR(RELE12))
         OI    FRRFLA,FRRALLOC     SET SALLOC INDICATOR FOR FRR
         LR    BLKREG1,BASEREG
         LR    REG2,FRRAREA
         GETMAIN RU,LV=2048,SP=245,BRANCH=(YES,GLOBAL),KEY=0
         LR    BASEREG,BLKREG1
         LR    FRRAREA,REG2
RELE12   SETLOCK RELEASE,TYPE=SALLOC,RELATED=(GETMAIN,IECVSMGR(INIT12))
         NI FRRFLA,FF-FRRALLOC     TURN OFF LOCK INDICATOR
         LR    PGREG,BLKREGLK
*
**********
*   FORMAT 2K PAGE INTO 12 BYTE BLOCKS
**********
*
         LH    CNTREG1,BLKCNT(,HDRREG)  LOAD CNT AND NO. OF
*                                       BLKS/PAGE FROM HEADER
         LH    BLKREG1,BLKLEN(,HDRREG)  LOAD BLOCK LENGTH
         ST    CNTREG1,PGCNT(,PGREG)    STORE BLKS/PG IN CURRNT CNT
         ST    CNTREG1,PGFLGS(,PGREG)   STORE BLKS/PG IN MAX CNT
         LA    BLKREG,PGHD12(,PGREG)    UP TO START OF BLOCKS
         ST    BLKREG,PGBLK(,PGREG)     SET FIRST BLK PTR IN PAGE HD
         NI    IOQFLB-IOQ(BLKREG),ZERO   INITIALIZE TO UNALLOCATED
         BCTR  CNTREG1,0                ADJUST CNTR TO STOP AT LAST
BLKCHN12 LA    BLKREGLK,ZERO(BLKREG1,BLKREG) GET NEXT BLOCK
         NI    IOQFLB-IOQ(BLKREGLK),ZERO SET UNALLOCATED
         ST    BLKREGLK,BLKLINK(,BLKREG)  STORE IN CHAIN
         LR    BLKREG,BLKREGLK          UP BLOCK PTR
         BCT   CNTREG1,BLKCHN12         DEC COUNT, TILL END
         ST    CNTREG1,BLKLINK(,BLKREG)   SET LAST BLK PTR ZERO
         SPACE
*
***********
*    PUT THIS PAGE ON THE CHAIN OF PAGES
***********
*
* NOTE THIS CODE ASSUMES ONLY ONE PAGE OF 12 BYTE BLOCKS
         SLR   CNTREG1,CNTREG1     ZERO REG TO INDICATE LAST PAGE
         ST    PGREG,PGCHN(,HDRREG)     PUT PAGE ON PAGE CHAIN
         ST    CNTREG1,PGCHN(,PGREG)    INDICATE LAST
         LA    CNTREG1,ONE(,CNTREG1)    INDICATE ONE PAGE
         STH   CNTREG1,NOPGS(,HDRREG)   STORE PAGE COUNT
*
*  PUT SAME 12 BYTE BLOCKS ON FREE QUEUE
*
         LH    CNTREG1,BLKCNT(,HDRREG)  THIS IS NO. OFF FREE BLKS
         ST    CNTREG1,CNT12
         L     BLKREG,PGBLK(,PGREG)     1ST BLOCK ON PAGE IS 1ST ON Q
         ST    BLKREG,ANCHOR12          INIT 12BYTE FREE QUEUE
         L     BLKREG,IOSADDR      GET IOSYNCH LOCK ADDRESS
         LR    BLKREGLK,PGREG      GET PAGE PTR FOR INIT MARK
         BR    INTREG1                  RETURN
         SPACE 2
         SPACE 3
         TITLE 'IECVSMGR - PURGE/FREE 40/160 BYTE BLOCKS'
*
************************************************************
*        THIS ROUTINE PERFORMS A PURGE FUNCTION ON 40 AND 160
*        BYTE STORAGE MANAGER POOLS BY FREEING BLOCKS WITH A
*        SPECIFIED ASID IN THE BLOCK PREFIX. THE FUNCTION IS CALLED
*        BY PURGE (SVC16) IN THE EVENT OF AN OUT OF CORE ABEND
*        OR MEMORY TERMINATION FOR OTHER REASONS. THIS ROUTINE
*        ALLOWS THE RECOVERY OF IOS STORAGE RESOURCES HELD BY
*        THE FAILING MEMORY. THE IOSYNCH LOCK IS HELD THROUGHOUT
*        THE SEARCH EXCEPT WHEN A BLOCK IS FOUND. THIS IS TO
*        REMOVE THE POSSIBILITY OF FREEBLOCK CAUSING A PAGE TO
*        BE FREED WHILE PURGE/FREE IS CHECKING THE BLOCKS ON THAT
*        PAGE. THE SEARCH IS ALWAYS RESUMED AT THE TOP OF THE
*        PAGE CHAIN AFTER A BLOCK IS FREED IN CASE THAT FREEBLOCK
*        CAUSED THE PAGE UNDER INSPECTION TO BE FREED.
*        A SEQUENTIAL SEARCH OF ALL 40 AND 160 BYTE POOL PAGES
*        IS CARRIED OUT.
************************************************************
*
PRGFREE  STM   RETREG,PGREG,FOUR(SAVEREG)    SAVE REGS 14-12
         LR    CHAINREG,SAVEREG        SAVE SAVE REG
         LR    REG2,BLKREG             SAVE ASID FOR PURGE
         LA    BLKREG,FORTYIND     SET 40 BYTE BLOCK SCAN
POOL40   LA    HDRREG,PAGE40HD     START SCAN OF 40 BYTE BLK PAGES
         LH    INTREG1,BLKLEN(,HDRREG)  GET BLOCK LNTH
         SPACE
FRSTRT40 L     PGREG,PGCHN(,HDRREG)   LOAD 1ST PAGE OF 40'S
         LA    PGREG,0(PGREG)         ZERO HIGH ORDER BYTE
         LTR   PGREG,PGREG            TEST FOR ZERO
         BZ    PRG160                 ZERO, MAYBE FRR RESTRUCTURE
         SPACE
PGSTRT40 LA    BLKREG1,PGHD(PGREG)    LOAD 1ST BLK ON PAGE
         LH    CNTREG1,BLKCNT(HDRREG)  NO. OF BLKS PER PAGE
COMP40   CH    REG2,ZERO(,BLKREG1)      CHECK ASID OF BLOCK
         BE    FRECAL40                 YES FREE BLOCK
BACKFFRE LA    BLKREG1,ZERO(INTREG1,BLKREG1)    UP TO NEXT BLK
         BCT   CNTREG1,COMP40           TRY NEXT BLK IF ANY
         SPACE
         L     PGREG,PGCHN(PGREG)       UP TO NEXT PAGE
         LA    PGREG,0(PGREG)           ZERO HIGH ORDER BYTE
         LTR   PGREG,PGREG              ANY MORE PAGES ?
         BNZ   PGSTRT40                 YES- TRY NEXT PAGE
         SPACE
*  OUT OF 40 BYTE BLK PAGES, NOW TRY 160 BYTE BLK
PRG160   L     BLKREG,IOSADDR
O4       SETLOCK OBTAIN,TYPE=IOSYNCH,ADDR=(11),MODE=UNCOND,RELATED=(SMG*
               RPOOL,IECVSMGR(PRGFIN,FREECALL))
FRSTRT   L     BLKREG,SMGRFRRA
         SETFRR A,PARMAD=(FRRAREA),FRRAD=(11),WRKREGS=(6,7)
         OI    FRRFLA,FRRSYNCH
         OI    FRRFLB,FRRPURG
         ST    CHAINREG,FRRSVA          SAVE SA PTR IN FRR
         LA    BLKREG,ONE60IND     SET FLG FOR 160 BYTE BLOCKS
POOLSTRT LA    HDRREG,PAG160HD     START SCAN OF PAGES FOR 160 BYT BLKS
         LH    INTREG1,BLKLEN(HDRREG)   GET BLOCK LENGTH
         L     PGREG,PGCHN(HDRREG)     LOAD FIRST PAGE FOR THIS TYPE
         LA    PGREG,0(PGREG)          ZERO HIGH ORDER BYTE
         LTR   PGREG,PGREG             TEST FOR ZERO
         BZ    PRGFIN                  NO PAGES MAYBE FRR IN CONTROL
PGSTART  LA    BLKREG1,PGHD(PGREG)     LOAD FIRST BLK ON PAGE
         LH    CNTREG1,BLKCNT(HDRREG)  NO. OF BLKS PER PAGE
COMPASID CH    REG2,ZERO(BLKREG1)      ASID EQUAL               @YM2911
         BE    FREECALL                YES - FREE BLK
COMP1    LA    BLKREG1,ZERO(INTREG1,BLKREG1) UP TO NEXT BLK
         BCT   CNTREG1,COMPASID        TRY NEXT BLK IF ANY
         L     PGREG,PGCHN(PGREG)      UP TO NEXT PAGE
         LA    PGREG,0(PGREG)          ZERO HIGH ORDER BYTE    @ZA04542
         LTR   PGREG,PGREG             MORE PAGES
         BNZ   PGSTART                 YES - TRY NEXT PAGE
         SPACE 5
*
********************
*        TERMINATION ROUTINE FOR PURGE/FREE
********************
*
PRGFIN   L     BLKREG,IOSADDR          LOAD SYNCH LOCK ADDRESS
         SETLOCK RELEASE,TYPE=IOSYNCH,ADDR=(11),RELATED=(SMGRPOOL,IECVS*
               MGR(O4,O5))
         LR    SAVEREG,CHAINREG        RESTORE SAVE REG
PRGDEL   SETFRR D,WRKREGS=(6,7)
         LM    RETREG,PGREG,FOUR(SAVEREG) RESTORE REGS 14-12
         BR    RETREG                  RETURN TO CALLER
         EJECT
*
************************************************************
*        THIS SECTION ISSUES A CALL TO FREE 40 BYTE BLK
*        WHOSE ASID MATCHES THAT PASSED BY PURGE
************************************************************
*
FRECAL40 LA    BLKREGLK,PREFIXLN(BLKREG1)    PAST PREFIX TO BLK
         L     SAVEREG,ZERO(,CHAINREG)  LOAD SECDY SAVE ADDR
         SR    RETREG,RETREG       CLEAR REG
         ST    RETREG,BLKLINK(,BLKREGLK)  ZERO CHAIN POINTER
         SPACE
         BAL   RETREG,FRBLK4       CALL FREE 40 BYTE BLK
         SPACE
         B     BACKFFRE            GO BACK & CONTINUE SCAN
         SPACE
         SPACE 5
*
*******************
*        THIS SECTION ISSUES A CALL TO FREEBLOCK TO FREE A BLOCK
*        WHOSE ASID MATCHES THAT PASSED BY PURGE. UPON RETURN
*        THE SEARCH IS STARTED AT THE FIRST PAGE OF THIS BLOCK TYPE.
********************
*
FREECALL LA    BLKREGLK,PREFIXLN(,BLKREG1)  PAST PREFIX WITH PTR
         L     SAVEREG,ZERO(CHAINREG)  LOAD SECDY SAVE ADDR     YM01872
         SR    RETREG,RETREG           CLEAR REGISTER           @YM7224
         ST    RETREG,BLKLINK(,BLKREGLK) ZERO CHAIN POINTER     @YM7224
FR160    STM   REG0,PGREG,ZERO(SAVEREG)  BYPASS SAVE IN FREEBLK
         BAL   RETREG,PURGBLK      FREE THIS BLOCK
         SPACE
         LR    REG0,BLKREG         SAVE TYPE INDICATOR
         L     BLKREG,IOSADDR      LOAD IOSYNCH LOCK ADDR
         SETLOCK  RELEASE,TYPE=IOSYNCH,ADDR=(11),RELATED=(SMGRPOOL,IECV*
               SMGR(04,05))
         SETLOCK OBTAIN,TYPE=IOSYNCH,MODE=UNCOND,ADDR=(11),RELATED=(SMG*
               RPOOL,IECVSMGR(PRGFIN,FREECALL))
         LR    BLKREG,REG0         RESET TYPE INDICATOR
         B     FRSTRT                  RESTART SEARCH AT FIRST PAGE
         TITLE 'IECVSMGR - STORAGE INITIALIZATION MODULE'
*
************************************************************
*        THIS ROUTINE IS CALLED BY NIP0 AND IS RESPONSIBLE FOR
*        INITIALIZING THE STORAGE MANAGER POOLS TO THEIR TOLERANCE
*        LEVEL. THE  GETCORE FUNCTION IS INVOKED TO ALLOCATE AND
*        FORMAT THE SPECIFIED NUMBER OF PAGES ON A ONCE PER
*        PAGE BASIS. THE PAGE TOLERANCE SPECIFIED IN THE HEADER
*        FOR EACH BLOCK TYPE INDICATES HOW MANY PAGES ARE TO BE
*        ALLOCATED FOR EACH BLOCK TYPE.
*        WHEN THE POOLS HAVE BEEN INITIALIZED CONTROL IS RETURNED
*        TO NIP0.
************************************************************
*
         USING *,15
IECVCPRM STM   RETREG,PGREG,SAV(SAVEREG)  SAVE REGISTERS
         L     BASEREG,CMAD            LOAD IECVSMGR ADDR
         USING IECVSMGR,BASEREG
         ST    SAVEREG,SAVEWORD        SAVE SAVEREG
*
*        GET NIP PAGE OF 12 BYTE BLOCKS
*
         OI    PSASUP3,PSAIOSUP        SET IOS SUPER BIT ON TO @ZA03849
*                                       ENSURE LOCK-MGR DOESN'T@ZA03849
*                                       ENABLE FOR INTERRUPTS  @ZA03849
         LA    HDRREG,PAGE12HD         GET PAGE CHAIN HEAD FOR 12 BYTE
         LA    FRRAREA,FRRDUMMY        LOAD DUMMY TRACK AREA
COREP0   LH    CNTREG,PTOLE(,HDRREG)   LOAD PAGE TOLERANCE
COREP1   BAL   INTREG1,GET12PG         GO TO GET 12 BYTE BLOCK PAGE
         MVI   PGFLGS(PGREG),PGINIT
         BCT   CNTREG,COREP1           COREP1 LOOP TO FILL HDR
         OI    PGFLGS(PGREG),LASTINIT  SET AS LAST INIT PAGE
*
*        GET NIP PAGE OF 40 BYTE BLOCKS
*
         LA    HDRREG,PAGE40HD     GET PAGE CHAIN HEAD FOR 40B TE
         LH    CNTREG,PTOLE(,HDRREG)    GET COUNT OF PAGES
COREP2   BAL   INTREG1,GET40PG          GET PAGE OF 40BYTE BLOCKS
         MVI   PGFLGS(BLKREGLK),PGINIT  SET AS INITIAL PAGE
*  BLKREG  SHOULD STILL POINT TO LAST NEW BLOCK ON FREE CHAIN
         MVC   PGID(L16,BLKREGLK),PGID40 MOVE ID INTO PAGE HEAD
         L     CNTREG1,CNT40       GET 40 BYTE BLOCK CNT
         LA    CNTREG1,MDLBP(,CNTREG1) INCREMENT FREE CNT NO.BLKS/PAGE
         ST    CNTREG1,CNT40           UPDATE CNT
         L     CNTREG1,ANCHOR40         GET CURRENT 40 BYTE ANCHOR
         ST    CNTREG1,BLKLINK(,BLKREG)    PUT CURRENT CHAIN AT TAIL
         L     CNTREG1,PGBLK(,BLKREGLK) PUT QUE TOP OF NEW PAGE ON TOP
         ST    CNTREG1,ANCHOR40         PUT BLOCKS ON FREE QUE
         BCT   CNTREG,COREP2            LOOP TO GET ALL PAGES
         OI    PGFLGS(BLKREGLK),LASTINIT SET AS LAST INITIAL PAGE
*
*        GET NIP PAGES FOR 160 BYTE BLOCKS
*
         LA    HDRREG,PAG160HD     GET PAGE CHAIN HEAD 160 BLOCKS
         LH    CNTREG,PTOLE(,HDRREG)    GET COUNT OF PAGES
COREP3   BAL   INTREG1,GET160PG         GO GET PAGE OF 160 BYT BLKS
*********
*   CHAIN BLOCKS FROM NEW PAGE TO FREE QUEUE
*********
*
*  NOTE  BLKREG SHOULD STILL POINT TO LAST BLOCK ON ADDED CHAIN
         MVC   PGID(L16,BLKREGLK),PGID160  MOVE EBCDIC
         L     CNTREG1,CNT160      GET CURREN FREE COUNT
         LA    CNTREG1,LRGBP(,CNTREG1)  INCREMENT NO. BLKS/PAGE
         ST    CNTREG1,CNT160      UPDATE COUNT
         L     CNTREG1,ANCHR160    GET CURRENT QUEUE ANCHOR
         ST    CNTREG1,BLKLINK(,BLKREG)   PUT IN TAIL OF CHAIN ADDED
         L     CNTREG1,PGBLK(,BLKREGLK)  GET TOP OF NEW CHAIN
         ST    CNTREG1,ANCHR160         PUT IT IN QUEUE ANCHOR
         MVI   PGFLGS(BLKREGLK),PGINIT   SET AS A NIP PAGE
         BCT   CNTREG,COREP3            LOOP TO GET ALL PAGES
         OI    PGFLGS(BLKREGLK),LASTINIT SET AS LAST INITIAL PAGE
         NI    PSASUP3,X'FF'-PSAIOSUP  SET IOS SUPER BIT OFF   @ZA03849
         L     SAVEREG,SAVEWORD        RELOAD SAVEREG
         LM    RETREG,PGREG,SAV(SAVEREG) RESTORE REGS
         BR  RETREG                    RETURN TO NIP 0
         SPACE
         TITLE 'IECVSMGR - FRR   '
****************************************************************
*                                                              *
*   IOS STORAGE  MANAGEMENT RECOVERY ROUTINE                   *
*                                                              *
*        THIS FRR PROTECTS AND TRIES TO RECOVER STORAGE POOLS  *
*        USED BY COMPONENTS OF THE I/O SUPERVISOR. FUNCTIONS   *
*        INCLUDE QUEUE VERIFICATION (ALLOCATED STORAGE PAGES   *
*        & PAGE CHAIN), REPLACE THE FREE QUEUES IF IN DOUBT    *
*        FRAMES AND FREE BLOCK CHAINS WITHIN THE 2K FRAMES)    *
*        AND QUEUE RESTRUCTURING.                              *
*                                                              *
*   ENTRY - IECVSMFR FROM -                                    *
*              1.) RTM FOR INITIAL ERROR DETECTION OR          *
*                  PERCOLATION.                                *
*              2.) IECIOSCN (IECIOSAM) WHEN AN ERROR HAS       *
*                  OCCURRED DURING A REQUEST TO GET OR FREE    *
*                  A SMALL BLOCK (IECVSMGR RUNS WITH PROTECTION*
*                  OF IOS'S FRR FOR SMALL BLOCK REQUESTS)      *
*                                                              *
*   INPUT - REG 0  200 BYTE WORK AREA ADDRESS                  *
*         - REG 1   SDWA ADDRESS                               *
*         - REG14  RTM RETURN ADDRESS                          *
*                                                              *
*           NOTE - WHEN ENTERED FROM THE IECIOSCN FRR, THE FRR *
*                  WORKAREA PASSED VIA SDWAPARM IS CONSTRAINED *
*                  TO MEET THE USAGE OF THIS FRR - SEE FRR     *
*                  WORKAREA DSECT FOR CRITICAL FIELDS          *
*                                                              *
*   EXITS - TO RTM VIA REGISTER 14                             *
*                                                              *
*   CALLS - SYSTEM QUEUE VERIFICATION ROUTINE - QVA            *
*                                                              *
****************************************************************
         USING SDWA,IRTREG
IECVSMFR BALR  BASEREG,0               TEMPORARY BASE ADDRESS
         USING *,BASEREG
         L     BASEREG,CMAD            IECVSMGR ENTRY ADDRESSABILITY
         USING IECVSMGR,BASEREG
         LR    IRTREG,BLKREGLK         SDWA ADDRESS
         L     FRRAREA,SDWAPARM        LOAD FRR WORKAREA ADDRESS
         LR    CHAINREG,REG0           LOAD FRR EXTENDED WORK AREA
         ST    CHAINREG,FRRWRK         SAVE IN PRIMARY WORK AREA
         USING QVPL,CHAINREG
         ST    IRTREG,QFRRSDWA         BACK CHAIN SDWA
         ST    RETREG,FRRRTM           SAVE RTM RETURN ADDRESS
         MVI   SDWAURAL,ZERO           LENGTH OF VARIABLE DATA
         TM    SDWAMCHD,SDWAACR        ACR ENTRY
         BO    SMGFR020                BRANCH YES, SKIP DUMP
         EJECT
***                                                          ***
*   ISSUE ASYNCHRONOUS SVC DUMP IS 4K BUFFER IS AVAILABLE      *
***                                                          ***
         SPACE 1
         L     PGREG,CVTPTR            CVT ADDRESS
         USING CVT,PGREG
         L     BLKREG,CVTSDBF          SDUMP 4K BUFFER ADDR AND LOCK
         LTR   REG0,BLKREG             IS IT ALREADY HELD
         BNP   SMGFR020                BRANCH YES,SKIP DUMP
         O     REG0,BUFLOCK            SET CS REG
         CS    BLKREG,REG0,CVTSDBF     COMPARE AND SWAP FOR BUFFER
         BNE   SMGFR020                * AVAILABILITY. BRANCH NO
         DROP  PGREG
         USING SDBUF,BLKREG
         LA    PGREG,SDBDATA           BUFFER DATA ADDRESS
         ST    PGREG,SDBDATAD          STORE IN DATA AREA
         MVC   SDBPHDR,HEADER0         MOVE SMGR POOL HEADERS
         MVC   SDBFHDR,HEAD12          MOVE FREE QUEUE HEADER
         LA    PGREG,SDBDL             DATA LENGTH
         STH   PGREG,SDBDLN            STORE IN DATA HEADER
         XC    SDBLAST,SDBLAST         ZERO NEXT DATA HEADER
         LA    SAVEREG,QVSAVE          SAVE AREA FOR SDUMP
         DROP  CHAINREG
         LR    PGREG,BASEREG           SAVE BASE ACROSS SDUMP
         TM    FRRFLA,FRRFAIL          RETRY RECURSION
         BZ    SMGFR045                NO
         L     RETREG,PSALCCAV
         USING LCCA,RETREG
         TM    IRTFLA,IRTALCK          ALLOCATION - SQA EXHAUSTED
         BNZ   SMGFR048                YES
         TM    FRRFLA,FRRALLOC         ALLOCATION - SQA EXHAUSTED
         BNZ   SMGFR048                YES
         DROP  RETREG
SMGFR045 EQU   *
         SPACE 1
         SDUMP HDR='IOS-IECVSMGR ERROR',SDATA=(SQA,TRT),QUIESCE=NO,    *
               BRANCH=YES,ASID=MSASID,BUFFER=YES,LIST=CMAD
         SPACE 1
         LR    BASEREG,PGREG           RESTORE BASE REGISTER
         B     SMGFR020
SMGFR048 EQU   *
         SDUMP HDR='IOS-SMGR SQA EXHAUSTED',SDATA=(SQA,TRT),QUIESCE=NO,*
               BRANCH=YES,ASID=MSASID,BUFFER=YES,LIST=CMAD
         LR    BASEREG,PGREG           RESTORE BASE REGISTER
         EJECT
SMGFR020 EQU   *                       CHECK ENTRY TYPE
         SPACE 1
***                                                          ***
*   DETERMINE IF SMGR ENTERED BY IOS FOR SMALL BLK GET/FREE. IF*
*   SO,INDICATE IN FRRWRK AREA AND INSURE IOS RETRY REGISTERS *
***                                                          ***
         SPACE 1
         L     SAVEREG,FRRSVA          LOAD CALLER'S SAVEAREA
         L     PGREG,PSALCCAV          GET LCCA
         USING LCCA,PGREG
         TM    IRTFLB,IRTSMGR+IRT12GT  IOS IN CONTROL(IECIOSCN)
         BZ    SMGFR080                BRANCH NO - NOT SMALL BLK CALL
         BM    SMGFR050                BRANCH YES - SMALL BLK FREE
         OI    FRRFLA,FRRGET           INDICATE SMALL BLK GET
*
********
*        PROBLEM WITH 12 BYTE GET
*        ASSUME 12 BYTE FREE QUEUE IS BAD & ZERO IT
********
*
         SR    REG0,REG0           ZERO REG
         SR    BLKREGLK,BLKREGLK   ZERO REG
         LM    CNTREG1,BLKREG1,HEAD12   GET CURRENT QUE HEAD
SMGFR052 CDS   CNTREG1,REG0,HEAD12      SWAP TO ZERO
         BNE   SMGFR052
         SPACE
SMGFR050 OI    FRRFLA,FRRSML           INDICATE SMALL BLK
         TM    IRTFLA,IRTALCK          IS SALLOC LOCK HELD
         BZ    SMGFR055                BRANCH NO
         OI    FRRFLA,FRRALLOC         YES, TRANSFER INDICATOR TO FRR
         NI    IRTFLA,IRTNALCK         * WORK AREA
SMGFR055 TM    SDWAERRC,SDWAPERC       THIS FRR PERCOLATED TO
         BZ    SMGFR090                BRANCH NO, USE INTERRUPT REGS
         L     PGREG,LCCACPUS          LOCATE IOS DISABLED SAVEAREA
         USING WSAC,PGREG
         L     SAVEREG,WSACIOS         * AND RESTORE REGS FOR RETRY
         MVC   SDWASR02(SDWASR15-SDWASR02),ZERO(SAVEREG) *
         B     SMGFR090                GO INSURE RETRY BASE
         SPACE 1
***                                                          ***
*   SET UP REGISTERS IN SDWA FOR POSSIBLE RETRY                *
***                                                          ***
         SPACE 1
SMGFR080 EQU   *                       SET UP REGS
*
********
         MVC   SDWAMODN,SMGRNAME   MODULE NAME TO SDWA
*        IF GET REQUEST 40, OR 160, ZERO QUEUE HEAD
         SR    REG0,REG0           ZERO REG
         SR    BLKREGLK,BLKREGLK   ZERO REG
         TM    FRRFLA,FRRGET       GET REQUEST?
         BNO   SMGFR084            NO, GO ON
         TM    FRRFLA,FRRMED       IS IT A 40 BYTE GET?
         BNO   SMGFR082            MUST BE 160
         SPACE
         LM    CNTREG1,BLKREG1,HEAD40        GET CURRENT HEAD 40 QUE
SMGFR081 CDS   CNTREG1,REG0,HEAD40           SWAP IN ZERO
         BNE   SMGFR081                      TRY AGAIN
         B     SMGFR084                 GO ON
         SPACE
SMGFR082 LM    CNTREG1,BLKREG1,HEAD160  GET CURRENT HEAD 160 QUEUE
SMGFR083 CDS   CNTREG1,REG0,HEAD160     SWAP IN ZERO
         BNE   SMGFR083                 TRY AGAIN
         SPACE
SMGFR084 EQU   *
         L     PGREG,PSALCCAV          GET LCCA
         USING LCCA,PGREG
         TM    IRTFLA,IRTALCK          IS SALLOC LOCK HELD
         BZ    SMGFR085                NO
         OI    FRRFLA,FRRALLOC         TRANSFER INDICATOR TO FRR
         NI    IRTFLA,IRTNALCK
         DROP  PGREG
SMGFR085 EQU   *
         MVC   SDWASR00(SDWASR14-SDWASR00),ZERO(SAVEREG)
         ST    FRRAREA,SDWASR04
SMGFR090 ST    BASEREG,SDWASR15        SET RETRY BASE ADDRESS
         SETRP RECORD=YES,RC=0,WKAREA=(IRTREG)
         LA    REG0,IECVSMFR           RETRY ADDRESS IF IN 2ND FRR
         SPACE
         TM    FRRFLA,FRRFAIL          AS THERE IS A 1ST LEVEL FAILURE
         BO    SMGFR100                BRANCH YES, TO PERCOLATE
         TM    FRRFLA,FRRCURS          RETRY RECURSION
         BZ    SMGFR200                BRANCH NO
         BAL   BLKREG,SMGFR800        GO HANDLE LOCK DISPOSITION
         B     SMGFR120                +0 RETURN IMPLIES NOT FORCED
*                                      * PERCOLATION
SMGFR100 EQU   *                                + 4 RTN IMPLIES
*                                      * MUST PERCOLATE
         TM    FRRFLA,FRRSML           SMALL BLOCK REQUEST
*                                      IMPLIES IOS IN CONTROL
         BZ   SMGFR105                 BRANCH NO
         SPACE 1
*   INSURE IRT FLAGS WHICH MAY HAVE BEEN SET BY IOS ARE OFF
         SPACE 1
         L     PGREG,PSALCCAV          LCCA ADDRESS FOR IRT ADDRESSING
         USING LCCA,PGREG
         NI    IRTFLA,FF-IRTULCK-IRTLLCK-IRTSLCK-IRTCLCK-IRTALCK-IRTIOQ*
               A-IRTSLISN
         NI    IRTFLB,FF-IRTSMGR-IRT12GT
         NI    PSASUP3,FF-PSAIOSUP     TURN OFF SUPER           @YM8326
         DROP  PGREG
SMGFR105 L     RETREG,FRRRTM           RESTORE RTM RETURN ADDRESS
SMGFR110 EQU   *                                               @ZA08447
         LR    REG0,CHAINREG           RESTORE 200B WA ADDR    @ZA08447
         BR    RETREG                  RETURN TO CALLER        @ZA08447
         SPACE 1
*   RETRY RECURSION FAILURE - NOT FORCED PERCOLATION - RETRY TO
*   SIMPLE EXIT UNLESS GET REQUEST WHICH MUST PERCOLATE
         SPACE 1
SMGFR120 TM    FRRFLA,FRRGET           GET REQUEST
         BO    SMGFR100                BRANCH YES - PERCOLATE
SMGFR122 LA    REG0,SMGFR700           RETRY ADDRESS FOR FREE NORMAL
         TM    FRRFLA,FRRSML           SMALL BLOCK FREE
         BZ    SMGFR130                BRANCH NO
         LA    REG0,SMGFR110           RETRY ADDRESS - SMALL BLK FREE
         SPACE 1
SMGFR130 SETRP RETADDR=(0),RETREGS=YES,RECORD=YES,RC=4,WKAREA=(IRTREG)
         SPACE 1
         B     SMGFR105                GO TO COMMON RTM RETURN
         EJECT
SMGFR200 OI    FRRFLA,FRRCURS          SET RECURSION INDICATOR
         SPACE 1
*   SET SECONDARY FRR
         SPACE 1
         L     REG0,SMGRFRRA           FRR ADDRESS
         SETFRR A,PARMAD=(PGREG),FRRAD=(REG0),WRKREGS=(PGREG,BLKREG)
         SPACE 1
         MVC   ZERO(FRRSLEN,PGREG),FRRSMGR  COPY FRR WORK AREA @ZA12704
         OI    FRRFLA-FRRSMGR(PGREG),FRRFAIL  SET 1ST LVL FAIL @ZA12704
*                                      FLAG IN 2ND LEVEL FRR WRKAREA
         TM    FRRFLA,FRRALLOC         SALLOC LOCK HELD
         BZ    SMGFR220                BRANCH NO
         SPACE 1
*   FREE SALLOC LOCK
         SPACE 1
         SETLOCK RELEASE,TYPE=SALLOC,DISABLED,RELATED=(GETMAIN,IECVSMGR*
               (FRR))
         NI    FRRFLA,FF-FRRALLOC      INDICATE SALLOC NOT HELD
SMGFR220 EQU   *                       CHECK LOCK GET
         TM    FRRFLA,FRRSML           IF SMALL BLOCK, DO NOT GET
         BO    SMGFR230                * IOSYNCH LOCK
         TM    FRRFLA,FRRMED           MIDDLE BLK REQ
         BO    SMGFR230                DO NOT SET IOSYNCH
*   160 BYTE PROBLEM, SERIALIZE FOR GET 160 OR COMPRESS             NEW
         TM    FRRFLA,FRRSYNCH     SUNCH LOCK HELD?                 NEW
         BO    SMGFR230            YES, DONT BOTHER                 NEW
         SPACE
         L     BLKREG,IOSADDR         GET SYNCH LOCK ADDRESS
         SETLOCK OBTAIN,TYPE=IOSYNCH,MODE=UNCOND,ADDR=(11),RELATED=(SMG*
               RPOOL,IECVSMGR(FRR))
         OI    FRRFLA,FRRSYNCH         INDICATE IOSYNCH LOCK HELD
SMGFR230 L     BLKREG,SMLVAL          HDR VERIFICATION VALUES -SMALL
         LA    HDRREG,HEADER0          POOL HEADER - SMALL BLOCKS
         TM    FRRFLA,FRRSML           SMALL BLOCK REQUEST
         BO    SMGFR240                BRANCH YES
         L     BLKREG,MDLVAL          VERIFICATION VALUES - MIDDLE
         LA    HDRREG,FORTYIND(HDRREG) POOL HEADER - MIDDLE
         TM    FRRFLA,FRRMED           MIDDLE BLK REQ
         BO    SMGFR240                BRANCH YES
         L     BLKREG,LRGVAL          VALUES FOR LARGE BLOCKS
         LA    HDRREG,FORTYIND(HDRREG) POOL HEADER - LARGE
SMGFR240 ST    HDRREG,FRRHDR       SAVE POOL HEADER
         EJECT
***                                                          ***
*   VERIFY THE POOL HEADER - IF BAD, START OVER WITH NEW       *
*   PAGES. IF GOOD, VERIFY THE PAGE CHAINS VIA SYSTEM QVA      *
***                                                          ***
         SPACE 1
         LR    PGREG,BLKREG           SAVE VERIFICATION VALUES
         EX    BLKREG,SMGFREX1        CHECK THE PAGE TOLERANCE
         BNE   SMGFR300                BRANCH NOT EQUAL
         SRL   BLKREG,LO8
         EX    BLKREG,SMGFREX2        CHECK THE BLOCK LENGTH
         BNE   SMGFR300                BRANCH NOT EQUAL
         SRL   BLKREG,LO8
         CH    BLKREG,BLKCNT(HDRREG)  CHECK MAXIMUM BLK COUNT
         BNE   SMGFR300                BRANCH NOT EQUAL
         XC    HDRRES(FOUR,HDRREG),HDRRES(HDRREG) CLEAR HDR FLAGS
*                                                               YM01932
***                                                         ***
*   INITIALIZE PARAMETERS FOR INTERFACE TO SYSTEM QUEUE VERIF.*
***                                                         ***
         L     BLKREGLK,FRRWRK         QVA PARAMETER LIST
         USING QVPL,BLKREGLK
         XC    QVPL(QVPLSIZE),QVPL     ZERO QVA PARAMETER LIST
         LA    PGREG,QVWORKS           QVA WORK AREA
         ST    PGREG,QVPLWKA           STORE ADDR IN QVPL
         LA    PGREG,SMGFREVR          ELEMENT VERIFICATION RTN ADDR
         ST    PGREG,QVPLEVR           STORE IN QVPL
         LA    PGREG,SDWAVRAL          OUTPUT DATA RECORDING AREA
         ST    PGREG,QVPLODA           STORE IN QVPL
         LA    PGREG,PGCHN(HDRREG)     ADDR OF PAGE CHAIN TO BE VERIF.
         ST    PGREG,QVPLHDR
         MVI   QVPLFPTR+ONE,PGCHN      OFFSET IN PAGE OF CHAIN PTR
         LA    SAVEREG,QVSAVE          SAVE AREA FOR QVA
         LR    REG0,IRTREG             PASS RTCA TO ELEMENT VERIFIER
         LR    PGREG,BASEREG           SAVE 15 ACROSS INTERFACE
         L     BASEREG,CVTPTR
         L     BASEREG,CVTQV1-CVT(BASEREG) GET QVA ENTRY
         BALR  RETREG,BASEREG          GO TO QVA
         LR    RETREG,BASEREG          SAVE RETURN CODE
         LR    BASEREG,PGREG           RESTORE BASE
         CLM   RETREG,ONE,F0           RETURN CODE = 0
         BE    SMGFR330                YES, GET OUT
         B     SMGFR330            ASSUME QVA FIXED CHAIN, DONT ADD ON
         DROP  BLKREGLK
***
*   POOL HEADER IS INVALID - CLEAR THE HEADER,
*   RETRY A GET REQUEST, A COMPRESS AT THE NEXT APPROPRIATE POINT
*   EXIT A PURGE/FREE OR FREE REQUEST.
***
SMGFR300 MVC   SDWAVRA(HEADEND),HEADER0 MOVE POOL HDR'S TO SDWA
         MVI   SDWAURAL,HEADEND        LENGTH OF POOL HEADERS
         XC    ZERO(PGID,HDRREG),ZERO(HDRREG) ZERO THE HEADER
         MVI   PGCHN(HDRREG),FF        MAKE PAGE CHAIN PTR NEGATIVE
*  TO INDICATE FRR RESTRUCTURE
         STC   PGREG,PTOLE+ONE(HDRREG) RESET PAGE TOLERANCE
         SRL   PGREG,LO8
         STC   PGREG,BLKLEN+ONE(HDRREG) RESET BLOCK LENGTH
         SRL   PGREG,LO8
         STH   PGREG,BLKCNT(HDRREG)     RESET BLOCK COUNT
SMGFR330 BAL   BLKREG,SMGFR800        GO DETERMINE LOCK DISPOSITION
         B     SMGFR340                +0 RETURN - OK TO RETRY
         B     SMGFR100                FORCED PERCOLATION
SMGFR340 SETFRR D,WRKREGS=(2,1)                                @YM05136
         TM    FRRFLA,FRRGET           GET BLOCK REQUEST
         BZ    SMGFR122                BRANCH NO - RETRY TO EXIT
         LA    REG0,SMGFR770           RETRY FOR SMALL BLK      YM03007
         TM    FRRFLA,FRRSML           SMALL BLOCK REQUEST
         BO    SMGFR130                BRANCH YES
         LA    REG0,SMGFR700           RETRY FOR MIDDLE/LARGE
         B     SMGFR130            RETURN TO RTM VIA SETRP RETRY
         EJECT
***                                                          ***
*   ERROR RETRY SUBROUTINE. ENTERED BY RTM VIA RETRY REQUEST   *
*   FROM IECVSMGR FUNCTIONAL RECOVERY ROUTINE.                 *
*                                                              *
*   FUNCTION  -  ESTABLISH ADDRESSABILITY                      *
*                FREE IOSYNCH LOCK IF HELD                     *
*                BRANCH TO APPROPRIATE ROUTINE -               *
*                 SMALL BLOCK GET - GETBLK0                    *
*                 SMALL BLOCK FREE - RETURN TO CALLER          *
*                  ( RETRY ENTRY IS SMGFR110)                  *
*                 MIDLLE/LARGE BLOCK GET - GETBLKA             *
*                 MIDDLE/LARGE BLOCK FREE - FBRET0             *
*                 COMPRESS          -COMPNOGO,COMPSTP2,COMPFLD      NEW
*                             & COMPFINI
*                                                              *
*   INPUT  -  ESTABLISHED BY FRR                               *
*         - REG15 = SMGFR700 ADDRESS - MIDDLE/LARGE, COMPRESS  *    NEW
*                   = SMGFR770 - SMALL                         *
*                                                              *
****************************************************************
***                                                          ***
SMGFR700 EQU   *                       RETRY INTERFACE
         USING *,BASEREG                                        YM03007
         L     BASEREG,CMAD            LOAD MODULE BASE ADDRESS YM03007
         USING IECVSMGR,BASEREG                                 YM03007
         TM    FRRFLB,FRRSCOM+FRRBCOM   IS COMPRESS IN PROGRESS     NEW
         BM    SMGFR790                 YES, GO HANDLE              NEW
         TM    FRRFLA,FRRMED       IS THIS A MED REQUEST?
         BZ    SMGFR740            TEST FOR LARGE
         TM    FRRFLA,FRRGET       IS IT A GET MIDDLE REQ      @ZA12704
         BNO   SMGFR745            NO GO HANDLE FREE 40
* RETRY GET 40, FREE QUE ZEROED, REGS LOADED, GO BACK AND TRY AGAIN
         TM    FRRFLA,FRRDEL       DID GET 40 SET THIS FRR
         BZ    GETBLK4             NO, GO RETRY GET 40, REGS SET
         SETFRR D,WRKREGS=(1,2)    YES, DELETE BEFORE RETRY
         LM    REG0,FRRAREA,ZERO(SAVEREG)  REST REGS SET
         B     GETBLK4             RETRY GET 40   (REGS SET)
* RETRY FREE 40, JUST RELOAD REGS AND GO BACK TO CALLER
SMGFR745 TM    FRRFLA,FRRDEL       DID FREE 40 SET FRR
         BZ    EXIT40              RETRY BY RETURNING TO CALLER
         SETFRR D,WRKREGS=(1,2)
*        LM    REG0,FRRAREA,ZERO(SAVEREG)  REST OF REGS OK
         B     EXIT40              RETRY FREE BY RETURNING
* RETRY GET & FREE 160
SMGFR740 TM    FRRFLA,FRRSYNCH         IS SYNCH LOCK HELD
         BZ    SMGFR750                BRANCH NO
         LR    REG2,BLKREG            SAVE INPUT REGISTER
         L     BLKREG,IOSADDR         LOAD SYNCH LOCK ADDRESS
         SETLOCK RELEASE,TYPE=IOSYNCH,ADDR=(11),                       *
               RELATED=(SMGRPOOL,IECVSMGR(FRR))
         NI    FRRFLA,FF-FRRSYNCH      RESET LOCK HELD INDICATOR
         LR    BLKREG,REG2            RESTORE INPUT REGISTER
SMGFR750 LM    SAVEREG,RETREG,FRRSVA     RELOAD R13-R14
         TM    FRRFLA,FRRGET       IS IT A GET 160
         BO    GETBLKA             YES, RETRY GET
         TM    FRRFLB,FRRPURG      IS IT A PURGE/FREE ENTRY?
         BO    PRGDEL              EXIT PURGE FREE
*  ONLY  REG  4, 13, & 15 ARE NOW VALID FOR PURGE FREE
         B     FBRET0              NO, RETRY FREE 160
         SPACE 2
SMGFR770 EQU   *                       CHECK LOCKS              YM03007
         USING *,BASEREG                                        YM03007
         L     BASEREG,CMAD            LOAD MODULE BASE ADDRESS YM03007
         USING IECVSMGR,BASEREG                                 YM03007
         B     GETBLK0                 RETRY SMALL BLOCK GET    YM03007
*
*        HANDLE RETRY FOR COMPRESS                                  NEW
*
SMGFR790 TM    FRRFLB,FRRCFLK      DID WE GET TO COMPFLK
         BZ    SMGFR791            YES, DELET FRR & EXIT
         L     BLKREGLK,CFINIAD    GET ADDR OF COMPFINI FOR RETRY
         LA    BASEREG,CONSTANT    GET BASE FOR COMPRESS
         BR    BLKREGLK            RETRY AT COMPFINI
         SPACE
SMGFR791 TM    FRRFLB,FRRCSTP2     NO, AS FAR AS COMPSTP2 ?
         BZ    SMGFR792            YES, FREE SYNCH LOCK & FREE PAGES
         L     BLKREGLK,CFLKA      GET ADDR OF COMPFLK
         LA    BASEREG,CONSTANT    GET COMPRESS BASE
         BR    BLKREGLK            GO TO COMPFLK
SMGFR792 TM    FRRFLB,FRRDFREE     NO, AS FAR AS COMPLOOP
         BZ    SMGF0793            YES, SEE IF CAN RECHAIN BLKS
         L     BLKREGLK,CSTP2A     GET ADDR OF COMPSTP2
         LA    BASEREG,CONSTANT    GET COMPRESS BASE
         BR    BLKREGLK            RETRY AT COMPSTP2
SMGF0793 LM    CNTREG,BLKREG,HEAD160    PREPARE TO ZERO FREE QUE
         SR    BLKREGLK,BLKREGLK        ZERO REG
SMGFR793 LR    REG0,CNTREG              GET COUNT
         AL    REG0,SYNCHCNT            ADD 1 TO SYNCH CNT
         N     REG0,LOWZOFF             ZERO FREE CNT
         CDS   CNTREG,REG0,HEAD160      SWAP IN ZERO
         BNE   SMGFR793                 SWAP FAILED TRY AGAIN
         L     BLKREGLK,NOTRYA     GET ADDR OF COMNOTRY
         LA    BASEREG,CONSTANT    GET COMPRESS BASE
         BR    BLKREGLK            RETRY AT COMNOTRY
         EJECT
***                                                          ***
*   SUBROUTINE TO DETERMINE IF SALLOC AND/OR IOSYNCH LOCK HELD,*
*   REQUEST RTM TO FREE THE LOCKS IF HELD, AND DETERMINE IF    *
*   PERCOLATION IS NECESSARY - FORCES REASONS ARE ACR, WRONG   *
*   MEMORY, OR PSW RESTART.                                    *
***                                                          ***
         SPACE 2
SMGFR800 TM    FRRFLA,FRRALLOC         SALLOC LOCK HELD
         BZ    SMGFR850                BRANCH NO
         OI    SDWAACF3,SDWASALL       INDICATE FREE SALLOC IN SDWA
SMGFR850 TM    FRRFLA,FRRSYNCH         IOSYNCH LOCK HELD
         BZ    SMGFR870                BRANCH NO
         OI    SDWAACF3,SDWAIPRG       INDICATE FREE SYNCH IN SDWA
         MVC   SDWAIPLW,IOSADDR        MOVE SYNCH LOCK ADDR TO SDWA
SMGFR870 MVC   SDWAMODN,SMGRNAME       MODULE NAME TO SDWA
         LH    PGREG,SDWAFMID          GET MEMORY ID
         LTR   PGREG,PGREG             IS IT ZERO
         BNZ   FOUR(BLKREG)           BRANCH NO - MUST PERCOLATE
         TM    SDWAMCHD,SDWAACR        ACR ENTRY
         BO    FOUR(BLKREG)           BRANCH YES - MUST PERCOLATE
         TM    SDWAERRA,SDWARKEY       PSW RESTART
         BO    FOUR(BLKREG)           BRANCH YES, MUST PERCOLATE
         BR    BLKREG                 RETURN TO CALLER, RETRY OK
         DROP  IRTREG                                         @YM04210
         EJECT
****************************************************************
*
*   ELEMENT VERIFICATION ROUTINE - THIS ROUTINE RECEIVES CONTRL*
*   FROM THE SYSTEM QUEUE VERIFICATION ROUTINE TO VERIFY THE   *
*   QUEUE ELEMENT NEXT TO BE PROCESSED BY QVA. VERIFICATION    *
*   CONSISTS OF DETERMINING IF THE ELEMENT IS ADDRESSABLE,FALLS*
*   WITHIN THE RANGE OF STORAGE FAILURES,                      *
*   AND IF THE PAGE HEADER INFORMATION IS CONSISTENT.          *
*   THE ROUTINE IS ALSO USED AS AN IOQ VERIFIER BY THE IOS FRR *
*   WHEN VERIFYING A LOGICAL CHANNEL QUEUE. IN THIS CASE, THE  *
*   VERIFICATION CONSISTS OF STORAGE FAILURE CHECKS, ADDRESS-  *
*   ABILITY, IF THE IOQ RESIDES WITHIN THE SMALL BLOCK STORAGE *
*   POOL, AND IF THE IOQ DATA IS CONSISTENT.                   *
*                                                              *
*                                                              *
*   INPUT  -  R0  =  ADDRESS OF ELEMENT                        *
*             R1  =  ADDRESS OF SDWA                           *
*             R14 =  RETURN ADDRESS OF QVA                     *
*             R15 =  ENTRY ADDRESS                             *
*             R2-R7 = USED AS WORK REGS AND NOT RESTORED       *
*                                                              *
*   OUTPUT -  RETURN CODE IN REG15                             *
*               0  =  ELEMENT VALID                            *
*               4  =  ADDRESSABLE BUT INVALID                  *
*               8  =  NOT ADDRESSABLE                          *
*                                                              *
****************************************************************
         SPACE 2
IECVSEVR EQU   *                       COMMON EVR RTN
* NOTE PGSIZE=2K BUT IS USED HERE TO CHECK BOTH 2K & 4K PAGES
         SPACE
         USING *,BASEREG
SMGFREVR L     BASEREG,CMAD            COMMON BASE ADDRESS
         USING IECVSMGR,BASEREG
         USING SDWA,BLKREGLK                                   @YM04210
         LR    REG2,REG0               TRANSFER ELEMENT TO REG2
         LRA   FRRAREA,ZERO(REG2)      CHECK IF VALID ADDRESS  @YM02497
         BNZ   SMGFR980                BRANCH NO - NOT ADDRESSABLE
         L     FRRAREA,SDWAPARM        GET FRR AREA
         L     IRTREG,FRRHDR           GET HEADER OR LCH INDICATOR
         TM    SDWAERRA,SDWAMCHK       MACHINE CHECK OCCUR
         BZ    SMGFR920                BRANCH NO
         TM    SDWAMCHS,SDWASRVL       STORAGE CHECK INDICATED
         BZ    SMGFR920                BRANCH NO
         LA    CHAINREG,PGSZ4K(REG2)   CHECK FOR 2K OR 4K PAGE
         TM    FRRFLB,FRRIOS           IS ENTRY DUE TO IOS LCH VERIFY
         BZ    SMGFR900                BRANCH NO - GOOD GUESS
         LA    CHAINREG,SMLBL(REG2)    NO,CHANGE UPPER BNDRY FOR IOQ
         EJECT
***                                                           ***
*   CHECK IF ELEMENT FALLS WITHIN STORAGE CHECK RANGE           *
***                                                           ***
SMGFR900 C     REG2,SDWASCKB           LOWER BNDRY BELOW RANGE
         BH    SMGFR910                BRANCH NO
         C     CHAINREG,SDWASCKB       UPPER BNDRY BELOW RANGE
         BL    SMGFR920                BRANCH YES, ELEMENT OK
         B     SMGFR980                NO - BAD STORAGE
SMGFR910 C     REG2,SDWASCKE           LOWER BNDRY ABOVE RANGE
         BNH   SMGFR980                BRANCH NO - BAD ELEMENT
***                                                           ***
*   VERIFY ELEMENT LOCATION, CONTENTS, AND CHAINS               *
***                                                           ***
SMGFR920 TM    FRRFLB,FRRIOS           LCH OR SMGR VERIFICATION
         BO    SMGFR960                BRANCH IF LCH
         LRA   BLKREG1,PGSIZE-1(REG2)  UPPER BOUNDARY OK
         BNZ   SMGFR980                BRANCH NO - NOT ADDRESSABLE
         LH    CHAINREG,BLKCNT(IRTREG) GET BLKS/PAGE FROM HDR
         CH    CHAINREG,MAXCNT(REG2)   CHECK MAXCNT FIELD IN PAGE
         BNE   SMGFR990                * HEADER - BRANCH NOT EQUAL
         SLR   BLKREG1,BLKREG1     PREP BEFORE ICM INSTRS      @ZM30148
         ICM   BLKREG1,BITS3,PGCNT+2(REG2) GET CURRENT FREE    @ZM30148
*                                  BLOCK COUNT                 @ZM30148
         CR    CHAINREG,BLKREG1        * MUST BE LESS OR EQ TO MAX
         BL    SMGFR990                * BRANCH - BAD DATA
SMGFR940 SLR   BASEREG,BASEREG         RETURN CODE = ZERO
         BR    RETREG                  RETURN TO QVA
         EJECT
***                                                           ***
*   VERIFY THE IOQ - MUST BE WITHIN SMALL BLK POOL              *
***                                                           ***
SMGFR960 LA    IRTREG,HEADER0          GET SMALL BLOCK HEADER
SMGFR965 L     IRTREG,PGCHN(IRTREG)    GET NEXT PAGE IF ANY
         LTR   IRTREG,IRTREG           DOES PAGE EXIST
         BZ    SMGFR990                BRANCH NO - IOQ NOT VALID
         LA    BLKREG1,PGSIZE(IRTREG)  UPPER BOUNDARY OF PAGE
         CR    REG2,IRTREG             *
         BL    SMGFR965                * CHECK IF IOQ WITHIN THIS
         CR    REG2,BLKREG1            * PAGE
         BH    SMGFR965                *
         B     SMGFR940                IOQ VALID
         SPACE 2
***                                                           ***
*   RETURN TO QVA - ERROR DETECTED                              *
***                                                           ***
SMGFR980 LA    BASEREG,LO8             RETURN CODE 8 = NOT ADDRESS-
         BR    RETREG                  * ABLE
SMGFR990 LA    BASEREG,FOUR            RETURN CODE 4 = ADDRESSABLE
         BR    RETREG                  * BUT BAD ELEMENT
         TITLE 'IECVSMGR - CONSTANTS AND MISCELLANEOUS DATA'
************************************************************
*        THE FOLLOWING ARE CONSTANTS USED BY STORAGE MANAGER
*        IN ITS OPERATION.
************************************************************
CONSTANT DS    0F           USED BY COMPRESS TO ADDRESS CONSTANTS
F0       DC    F'0'                    FULLWORD ZERO
FEIGHT   DC    F'8'                    EIGHT FOR SUBTRACT
HZERO    DC    H'0'                    ZERO FOR CLEARING
FORTYI   DC    H'16'                   FORTY BYTE INDICATOR
         DS    0F
SYNCHCNT DC    X'00010000'
UNIQUECT DC    X'00010000'         UNIQUE COUNT FOR CS INSTRS  @ZM30148
UNIQUEC1 DC    X'00010001'         UNIQUE CT FOR FREE BLKS ONLY@ZA03644
ADD12CHN DS    0F
         DC    X'0001'             TO INCREMENT SYNCH CNT
         DC    Y(SMLBP)            BLKS/PAGE FOR 2K PAGE OF 12 BYTE
ADCHN160 DS    0F
         DC    X'0001'             TO INCREMENT SYNCH CNT
         DC    Y(LRGBP)            BLKS/PAGE FOR 4K PAGE 160 BYTE
DECCNT   DC    X'0000FFFF'         CNT TO DECREMEN FREE CNT, AND
*                                  INCREMENT SYNCH COUNT
HIGH2OFF DC    X'0000FFFF'
LOWZOFF  DC    X'FFFF0000'              USED TO N OFF LOW 2 ORDER BYTS
MAXSLL   DC    F'255'         AN ARBITRARY NO. TO LOOP ON A    @ZM41373
MIN160   DC    F'6'                MIN NO. BLKS AT TEST FOR MORE PAGES
TESTZERO DC    X'00FFFFFF'         TO TEST FOR ZERO BLK PTR
*                             COND. SETLOCK BEFORE UNCOND REQ  @ZM41373
         SPACE 2
*******************
*        ADCONS FOR ADDRESSES AND LOCKS
*******************
CMAD     DC    A(IECVSMGR)             ADDRESS OF CORE MGT START
         DC    X'80'                   LAST LIST ENTRY
         DC    AL3(IECVSMND)           END OF IECVSMGR
IOSADDR  DC    V(IOCSYNCH)             ADDR OF IOSYNCH LOCK
SMGRFRRA DC    V(IECVSMFR)             SMGR FRR ADDR
CFINIAD  DC    A(COMPFINI)         FOR FRR TO RETRY AT COMPFINI
CFLKA    DC    A(COMPFLK)          FOR FRR
CSTP2A   DC    A(COMPSTP2)         FOR FRR
NOTRYA   DC    A(COMNOTRY)         FOR FRR
         SPACE 2
*******************
*        SAVE AREA AND DUMMY FRR TRACK AREA
*******************
SAVEWORD DC    F'0'                    SAVE FOR SAVEREG
FRRDUMMY DC    6F'0'                   DUMMY FRR AREA
         EJECT
         DS    0F
PGID160  DC    CL16'160BYTE IOS SMGR'  ID FOR 160BYTE PAGE HEAD
PGID40   DC    CL16'40 BYTE IOS SMGR'  ID FOR 40 BYTE BLK PAGE
*
************************************************************
*        THIS CONSTANT AREA IS THE BLOCK HEADERS.
************************************************************
*
HEADER0  DS    0D                      FIRST HDR
IECVSHDR EQU   *                       BLOCK HEADER
PAGE12HD EQU   *                   HEAD OF PAGE CHAIN FOR 12BYTE BLOCKS
         DC    Y(SMLBP)                BLKS/PAGE
         DC    Y(SMLBL)                BLK LENGTH
         DC    X'00000000'             FLAGS AND RES
         DC    Y(SMLPTOL)              PAGE TOLERANCE
         DC    X'0000'                 CURRENT PAGES
         DC    F'0'                    PAGE CHAIN ANCHOR
PAGE40HD EQU   *                   HEAD OF PAGE CHAIN FOR 40BYTE BLOCKS
         DC    Y(MDLBP)                BLKS/PAGE
         DC    Y(MDLBL)                BLK LENGTH
         DC    X'00000000'             FLAGS AND RES
         DC    Y(MDLPTOL)              PAGE TOLERANCE
         DC    X'0000'                 CURRENT PAGES
         DC    F'0'                    PAGE CHAIN ANCHOR
PAG160HD EQU   *                   HEAD OF PAGE CHAIN FOR 160BYT BLKS
         DC    Y(LRGBP)                BLKS/PAGE
         DC    Y(LRGBL)                BLK LENGTH
         DC    X'00000000'             FLAGS AND RES
         DC    Y(LRGPTOL)              PAGE TOLERANCE
         DC    X'0000'                 CURRENT PAGES
         DC    F'0'                    PAGE CHAIN ANCHOR
         SPACE 2
HEADEND  EQU   *-HEADER0               LENGTH OF HEADERS
HEADPG0  EQU   HEADER0+12              PAGE PTR IN FIRST HDR
BLKCNT0  EQU   HEADER0                 ADDR OF BKL/PG CNT FOR
*                                      FIRST BLOCK TYPE
BLK0LEN  EQU   HEADER0+2               ADDR OF LENGTH FOR THE
*                                      FIRST BLOCK TYPE
PTOLE0   EQU   HEADER0+8               ADDRESS OF MIN NO OF
*                                      PAGES FOR THIS BLOCK TYPE
HEADPG40 EQU   HEADER0+28              PAGE POINTER TO 40 BLK HEAD
BLKCNT4  EQU   HEADER0+16              ADR OF BLK/PG CNT FOR 40 BLK
BLK4LEN  EQU   HEADER0+18              ADR OF LEN FOR THIS BLK TYPE
*
PGHDPRE  EQU   PGHD+PREFIXLN           LENGTH OF PAGE HEADER PLUS PF
         EJECT
*
*********
*  FREE QUEUE OF 12 BYTE BLOCKS
*********
*
         SPACE
ALLOC12  EQU   X'08'               THIS 12 BYTE BLOCK IS ALLOCATED
HEAD12   DS    0D                  HEAD OF 12BYTE BLOCK FREE QUEUE
CNT12    DC    F'0'                SYNC COUNT & FREE COUNT
ANCHOR12 DC    F'0'                FREE QUEUE ANCHOR OF 12BYTE BLOCKS
********
*  FREE QUEUE OF 40 BYTE BLOCKS
********
HEAD40   DS    0D             HEAD OF 40 BYTE FREE QUEUE
CNT40    DC    F'0'           SYNCH CNT + FREE COUNT 2 BYTES EACH
ANCHOR40 DC    F'0'           FREE QUEUE ANCHOR
********
*  FREE QUEUE OF 160 BYTE BLOCKS
********
*
HEAD160  DS    0D             HEAD OF 160 BYTE BLOCK FREE QUEUE
CNT160   DC    F'0'           2BYTE SYNCH CNT + 2BYTE FREE COUNT
ANCHR160 DC    F'0'           160BYTE FREE QUEUE ANCHOR
FHDLNTH  EQU   *-HEAD12       LNTH OF FREE QUEUE
FCNT160  EQU   CNT160+2       FREE CNT HALF OF CNT160
         EJECT
*
* THE FOLLOWING EQUATES DESCRIBE THE 8 BYTE PREFIX FOR 40 & 160 BLOCKS
*
ASIDPRE  EQU   0           OFFSET, ASID THAT BLOCK BELONGS TO (2 BYTES)
ALLOCFLG EQU   3           OFFSET, BLOCK IS MARKED ALLOCATE OR FREE
ALLOC40  EQU   X'75'               ALLOCATED 40 BYTE FLAG
ALLOC160 EQU   X'76'               ALLOCATED 160 BYTE FLAG
FREE40   EQU   X'17'               FLAG MARKED FREE 40 BYTE
FREE160  EQU   X'17'               FLAG MARKED FREE 160 BYTE
PREFXPGE EQU   4           OFFSET, PAGE FROM WHICH THIS BLOCK CAME
*
         DS    0F
*
INITCOMP DC    X'FFFFFFFF'        INDICATE COMPRESS IN PROGRESS
*MOVED INTO PGFREEHD TILL REPLACED BY A PAGE TO FREEMAIN
*
PGFREEHD DC    F'0'             ON COMPRESS, PAGES CHAINED TO BE FREED
*                               NOTE, IF NONZERO INDICATES COMPRESS
*                               IN PROGRESS
ALLOCW   DC    X'00000075'         USED TO TURN ON ALLOC40
FREE40FW DC    X'00000017'         USED TO TURN ON FREE40
FREE160W DC    X'00000017'         USED TO ZERO ASID & MARK FREE
BRNCHENT DC    F'17'               IND BRANCH ENTRY TO COMPRESS
CMIN160  DC    A(LRGBP+12)         MIN OF BLOCKS BEFOR COMPRESS
N160BP   DC    A(LRGBP)            FULL WORD NO. OF BLOCKS/PAGE
MINPGES  DC    A(LRGPTOL+1)             MIN # OF PAGES BEFOR COMPRESS
ALLC160B DC    X'76'               ANOTHER WAY TO SET 160 ALLOCATED
IECVSCNT EQU   CNT160         TO BE USED AS AN ENTRY POINT
*                             KNOWN TO PURGE (TO CHECK COUNT)
         EJECT
***                                                           ***
*   CONSTANTS FOR RECOVERY PROCESSING                           *
***                                                           ***
         SPACE 1
         DS    0F
SMLVAL   DC    Y(SMLBP),AL1(SMLBL),AL1(SMLPTOL)   * TABLE
MDLVAL   DC    Y(MDLBP),AL1(MDLBL),AL1(MDLPTOL)   * VERIFICATION
LRGVAL   DC    Y(LRGBP),AL1(LRGBL),AL1(LRGPTOL)   * VALUES
         SPACE 1
BUFLOCK  DC    X'80000000'             SDUMP BUFFER LOCK MASK
SMGRNAME DC    CL8'IECVSMGR'           MODULE NAME
         DC    CL8' UZ07319'           PTF NUMBER FOR 805      @ZA12704
         SPACE 1
*   EXECUTED INSTRUCTIONS FOR PAGE VERIFICTION
         SPACE 1
SMGFREX1 CLI   PTOLE+ONE(HDRREG),ZERO  VERIFY PAGE TOLERANCE
SMGFREX2 CLI   BLKLEN+ONE(HDRREG),ZERO VERIFY BLOCK LENGTH
MSASID   DC    X'0001'                 MASTER SCHEDULER ASID
         DC    2C'IECVSMGR PATCH  '    PATCH AREA              @ZA08447
         SPACE 4
SMGREND  EQU   *                       END OF IECVSMGR CSECT
IECVSMND EQU   *                       SMGR END
         TITLE 'SMGR COMPRESS ROUTINE'
*****************************************************************
*                                                               *
*        COMPRESS ROUTINE:                                      *
*        THIS ROUTINE ATTEMPTS TO FREE UP PAGES WHICH ARE       *
*        NOT BEING USED                                         *
*                                                               *
*****************************************************************
*
         SPACE
IECVSCOM BALR  BASEREG,0           TEMP BASE ADDR, SRB ENTRY
         USING *,BASEREG
         L     BASEREG,COMPBASE    CONSTANT AREA ADDRESSABLE
         USING CONSTANT,BASEREG
* PUT SRB WE ARE RUNNING UNDER BACK ON FREE QUE
         LR    HDRREG,REG0         PUT SRB ADDR IN HDRREG
         S     HDRREG,FEIGHT       POINT TO PREFIX
         CLI   ALLOCFLG(HDRREG),ALLOC160     IS IT ALLOCATED
         BNE   ERRCOMP             INDICATE ERROR
         L     BLKREG,FREE160W     GET ZERO ASID & FREE FLG
         ST    BLKREG,ASIDPRE(,HDRREG)  SET ZERO ASID & FREE FLG
         LM    CNTREG,BLKREG,HEAD160    GET CURRENT
         LR    BLKREG1,REG0             GET ADDR OF BLK TO FREE
INITFREE LR    CNTREG1,CNTREG           SET OLD COUNT
         AL    CNTREG1,UNIQUEC1         ADD 1 TO FREE & SYNC CNTS
         ST    BLKREG,BLKLINK(,BLKREG1) PUT OLD HEAD IN THIS LINK
         CDS   CNTREG,CNTREG1,HEAD160   PUT BLOCK BACK ON FREE QUE
         BNE   INITFREE                 SWAP FAILED
         SR    REG2,REG2           INDICATE SRB ENTRY
         B     COMTEST1            GO TO COMMON CODE
IECVBCOM BALR  BASEREG,0               TEMP BASE ADDR, BRANCH ENTRY
         USING *,BASEREG
         L     BASEREG,COMPBASE        CONSTANT AREA  ADDRESSABLE
         USING CONSTANT,BASEREG
         SPACE
         STM   REG0,RETREG,ZERO(SAVEREG)      SAVE 0-14
         L     REG2,BRNCHENT            INDICATE BRANCH ENTERED
         LA    REG0,FOUR               SET INIT RTN CODE TO NO PAGES
*                                      FREED
COMTEST1 SR    HDRREG,HDRREG      CHECK IF COMPRESS IN PROGRESS
         L     CNTREG1,INITCOMP    TO INDICATE COMPRESS IN PROGRESS
         CS    HDRREG,CNTREG1,PGFREEHD  SWAP IN FF'S TO SERIALIZE
         BNE   COMPEX2            COMPRESS ALREADY IN PROGRESS
         LA    HDRREG,PAG160HD          GET HEAD OF 160 BYTE BLOCKS
         LH    CNTREG1,NOPGS(,HDRREG)   GET NO. OF PAGES
         C     CNTREG1,MINPGES          IF NOT A MINIMUM NO. OF PAGES
         BL    COMPEXIT                 DONT BOTHER
         LH   CNTREG,FCNT160    :GET 160 BYTE BLOCK FREE COUNT
         C     CNTREG,CMIN160     CHECK FOR MIN. NO. OF BLOCKS
         BH    COMPTRY            MORE THAN MIN, TRY COMPRESS
         B     COMPEXIT           RETURN FROM BRANCH ENTRY
         EJECT
COMPTRY  EQU   *                  GET SYNCH LOCK & TRY COMPRESS
         L     IRTREG,SMGRFRRA    LOAD STORAGE MGR FRR ADDR
         SETFRR A,PARMAD=(FRRAREA),FRRAD=(IRTREG),WRKREGS=(5,6)
         SPACE
         STM   SAVEREG,RETREG,FRRSVA   SAVE REGS 13-14
         L     BLKREG,IOSADDR     GET IOSYNCH LOCK ADDR
         SETLOCK OBTAIN,TYPE=IOSYNCH,MODE=UNCOND,ADDR=(11),RELATED=(SMG*
               RPOOL,IECVSMGR(COMPLKF))
         SPACE
         OI    FRRFLA,FRRSYNCH    INDICATE IOSYNCH LOCK HELD
         SPACE
         C     REG2,BRNCHENT      WAS THIS A BRANCH ENTRY?
         BE    COMPT01            YES, SET BIT IN FRRFLB
         OI    FRRFLB,FRRSCOM     NO,INDICATE SRB ENTERED
         B     COMPT05            BRANCH AROUND
COMPT01  OI    FRRFLB,FRRBCOM     INDICATE BRANCH ENTERED
COMPT05  EQU   *                  CHECK IF SHOULD STILL COMPRESS
         LH    CNTREG,FCNT160     GET 160 BYTE BLOCK FREE COUNT
         C     CNTREG,CMIN160     CHECK IF STILL WORTH TRYING
         BH    COMPRESS           ENOUGH BLOCKS, TRY COMPRESS
         LA    BLKREGLK,COMPFAIL  SET NO PAGES FREED
         B     COMNOTRY           GO FREE THE SYNCH LOCK
         SPACE
*****************************************************************
*        TRY TO COMPRESS OUR USE OF STORAGE BY SORTING BACK
*        THE 160 BYTE BLOCKS TO THE PAGE THEY CAME FROM
*****************************************************************
*
COMPRESS EQU   *
*        INTIALIZE FREE COUNTS IN PAGES OF CORRESPONDING BLOCKS
         LA    HDRREG,PAG160HD    GET HEAD OF 160 CHAIN
         SR    REG0,REG0          ZERO REG TO INITIALIZE CNT IN PAGES
         L     PGREG,PGCHN(,HDRREG)    GET 1ST PAGE
COMPINIT LA    PGREG,0(PGREG)     ZERO HIGH ORDER BYTE
         LTR   PGREG,PGREG        END OF CHAIN ?
         BZ    COMPSORT           GO SORT BLOCKS TO PAGES
         L     HDRREG,PGID160           GET CHECK VALUE
         CL    HDRREG,PGID(,PGREG)      CHECK IF VALID PAGE
         BNE   ERRCOMP                  ISSUE C0D ABEND SHLD NOT OCR
         ST    REG0,PGCNT(,PGREG)       ZERO CNT OF BLOCKS IN PAGE
         ST    REG0,PGBLK(,PGREG)       ZERO PTR TO FREE BLKS IN PAGE
         ST    REG0,LASTBLK(,PGREG)     ZERO PTR USED TO SAV LAST BLK
         L     PGREG,PGCHN(,PGREG)     GET NEXT PAGE IN CHAIN
         B     COMPINIT           INIT NEXT PAGE
         SPACE
COMPSORT EQU   *                  SORT BLOCKS TO PAGES THEY CAME FROM
         SR    BLKREGLK,BLKREGLK  ZERO FOR 160 ANCHOR
         LM    CNTREG,BLKREG,HEAD160   GET CURRENT CNT & ANCHOR
COMP001  LR    REG0,CNTREG         GET CURRENT FREE COUNT
         AL    REG0,SYNCHCNT       ADD 1 TO SYNCH COUNT
         N     REG0,LOWZOFF        ZERO FREE COUNT PART
         CDS   CNTREG,REG0,HEAD160     TRY TO TAKE OFF WHOLE QUEUE
         BNE   COMP001            FAILED, TRY AGAIN
*
********
         SPACE
*        NOW HAVE REMOVED WHOLE FREE QUEUE & ZEROED FREE & SYNCH CNTS
*        BLKREG POINTS TO TOP OF QUEUE
*        NOW PROCEED TO PUT NIP BLOCKS ON FREE QUEUE,
*        QUEUE NON-NIP BLOCKS OFF RESPECTIVE PAGE HEADERS
*********
*
         OI    FRRFLB,FRRDFREE     INDICATE TO FRR WE GOT THIS FAR
         LA    BLKREG,0(BLKREG)    ZERO HIGH BYTE
         LTR   BLKREG,BLKREG       IS IT ZERO?
         BZ    COMNOTRY            NO BLOCKS ON FREE QUE
COMPLOOP L     CHAINREG,BLKLINK(,BLKREG)  GET NEXT BLOCK IN CHAIN
         ST    REG0,BLKLINK(,BLKREG)   ZERO LINK PTR OF BLK
         LR    HDRREG,BLKREG           GET BLOCK PREFIX
         S     HDRREG,FEIGHT      MINUS 8 PTS TO PREFIX
         CLI   ALLOCFLG(HDRREG),FREE160  MAKE SURE MARKED FREE
         BNE   ERRCOMP            INDICATE ERROR IN COMPRESS
         L     PGREG,PREFXPGE(,HDRREG)  GET PAGE BLOCK CAME FROM
         L     REG2,PGID160            MAKE SURE PAGE OF 160S
         C     REG2,PGID(,PGREG)       DOES PAGE SEEM VALID
         BNE   ERRCOMP            GO INDICATE ERROR
         TM    PGFLGS(PGREG),PGINIT   IS THIS A NIP PAGE?
         BNO   COMSORT1                SORT BLOCK TO PAGE IT CAME FROM
*
********
* FOR BLOCKS FROM NIP PAGES, CDS THE BLOCK BACK TO THE FREE QUEUE
********
*
         LM    CNTREG1,BLKREG1,HEAD160  GET CURRENT CNT & ANCHOR
COMP005  LR    CNTREG,CNTREG1          COPY CNTS TO UPDATE
         AL    CNTREG,UNIQUEC1         ADD 1 TO SYNCH & FREE CNTS
         ST    BLKREG1,BLKLINK(,BLKREG)
         CDS   CNTREG1,CNTREG,HEAD160   TRY TO PUT NIP BLOCK BACK ON Q
         BNE   COMP005                 CDS FAILED, TRY AGAIN
         SPACE
         LA    CHAINREG,0(,CHAINREG)   ZERO HIGH ORDER BYTE
         LTR   CHAINREG,CHAINREG       TEST FOR END OF CHAIN
         BZ    COMPSTP2       END OF CHAIN, GO REQUE NON-NIP BLOCKS
         LR    BLKREG,CHAINREG         GET NEXT BLOCK
         B     COMPLOOP                GO SORT IT
         EJECT
*****************************************************************
*        PUT THE BLOCK ON A CHAIN OF THE PAGE IT CAME FROM
*        CDS NOT NEEDED BECAUSE BLOCKS ARE NOT ON FREE Q AND
*        IOSYNCH LOCK HELD
*************************************************************
*
COMSORT1 EQU   *
         L     BLKREG1,PGBLK(,PGREG)   GET TOP OF CHAIN IN PAGE
         LTR   BLKREG1,BLKREG1     IS THIS 1ST TIME THIS PAGE?
         BNZ   COMSORT2                 NO GO ON
         ST    BLKREG,LASTBLK(,PGREG)   YES, THIS WILL BE LAST ON QUE
COMSORT2 ST    BLKREG1,BLKLINK(,BLKREG)   PUCH DOWN STACK
         ST    BLKREG,PGBLK(,PGREG)    PUT NEW BLOCK ADDR IN PAGE HEAD
         L     CNTREG1,PGCNT(,PGREG)   GET CNT OF FREE BLOCKS IN PAGE
         LA    CNTREG1,ONE(,CNTREG1)   ADD ONE TO CNT OF BLOCKS
         ST CNTREG1,PGCNT(,PGREG)      UPDATE CNT IN PAGE HEADER
         LA    CHAINREG,0(,CHAINREG)   ZERO HIGH ORDER BYTE
         LTR   CHAINREG,CHAINREG       TEST FOR END OF CHAIN
         BZ    COMPSTP2       END OF CHAIN, GO REQUE NON-NIP BLOCKS
         LR    BLKREG,CHAINREG     NOT END, GET NEXT BLOCK
         B     COMPLOOP                 GO SORT IT
*
****************************************************************
*        NOW ALL NIP BLOCKS HAVE BEEN RETURNED TO THE FREE QUEUE
*        AND ALL NON-NIP BLOCKS HAVE BEEN QUEUED TO THE PAGE THEY
*        CAME FORM
*        THE PAGES THAT CANNOT BE FREEMAINED WILL BE RETURNED TO
*        THE FREE QUEUE
*        PAGES THAT CAN BE FREEMAINED WILL BE RECHAINED FOR LATER
******************************************************************
*
COMPSTP2 EQU   *                  STEP 2 OF COMPRESS, RETURN PAGES
         OI    FRRFLB,FRRCSTP2     INDICATE TO FRR WE GOT THIS FAR
         LA    CHAINREG,PAG160HD       GET HEAD OF PAGE CHAIN
         LR    REG2,CHAINREG            INIT REG2 INCASE NO PAGES
         L     CHAINREG,PGCHN(,CHAINREG)  GET 1ST PAGE ON CHAIN
STP2001  LTR   CHAINREG,CHAINREG  ANY PAGES?
         BZ    COMPFLK            THERE ARE NO PAGES TO COMPRESS
         TM    PGFLGS(CHAINREG),PGINIT   IF NOT A NIP PAGE GO ON
         BZ    STP2005            NON NIP PAGE, SEE IF CAN FREE
         LR    REG2,CHAINREG      SAVE LAST NIP PAGE
         L     CHAINREG,PGCHN(,CHAINREG)  CHECK NEXT PAGE
         B     STP2001                 FOR AN NON NIP PAGE
         EJECT
*        CHAINREG NOW HAS 1ST NON NIP PAGE
*
STP2005  LR    PGREG,REG2         SAVE PREVIOUS PAGE 1ST PASS
STP2010  L     CNTREG1,PGCNT(,CHAINREG)   GET COUNT OF FREE BLOCKS
         C     CNTREG1,N160BP          ARE ALL BLOCKS IN PAGE FREE?
         BE    FREEPG01           YES PUT PAGE ON CHAIN TO FREEMAIN
         BH    ERRCOMP            SHOULD NOT HAPPEN
         LR    PGREG,CHAINREG           UPDATE PREV PAGE PTR
         L     CHAINREG,PGCHN(,CHAINREG)   GET NEXT PAGE IF ANY
         LA    CHAINREG,0(CHAINREG)    ZERO HIGH ORDER BYTE
         LTR CHAINREG,CHAINREG         ANY MORE PAGES?
         BZ    RELINK                  NO GO RELINK FREE BLOCKS
         B     STP2010                 CHECK NEXT PAGE
*
***************************************************************
*        COME HERE TO CHAIN PAGES FOR FREEMAIN
***************************************************************
*
FREEPG01 EQU   *                  QUEUE SERIALIZED BY SYSCH LOCK
         LR    INTREG1,CHAINREG    SAVE PAGE PTR
         L     CHAINREG,PGCHN(,CHAINREG)   SAVE NEXT PAGE PTR
         L     HDRREG,PGFREEHD    GET HEAD OF QUE OF PAGES TO FREE
         ST    HDRREG,PGCHN(,INTREG1)   PUT HEAD IN LINK OF NEW
         ST    INTREG1,PGFREEHD         PUT NEW PTR IN HEAD PTR
         LA    HDRREG,PAG160HD     GET HEAD OF PAGE CHAIN
         LH    CNTREG1,NOPGS(HDRREG)    GET CNT OF PAGES
         BCTR  CNTREG1,0                DECREMENT COUNT
         STH   CNTREG1,NOPGS(HDRREG)    UPDATE CURRENT COUNT
         LA    CHAINREG,0(CHAINREG)    ZERO HIGH ORDER BYTE
         ST    CHAINREG,PGCHN(,PGREG)  PUT NEXT IN LINK OF LAST PAGE
         LTR   CHAINREG,CHAINREG  ANY MORE PAGES?
         BZ    RELINK             NO, GO RELINK NON FREEABLE BLOCKS
         B     STP2010            YES, GO CHECK NEXT PAGE
         EJECT
*
*******************************************************************
*        RECHAIN ALL BLOCKS THAT CAN'T BE FREEMAINED
*        AND PUT THEM BACK ON THE FREE QUEUE
*******************************************************************
*
RELINK   EQU   *                  REG2 HAS LAST NIP PAGE
         LR    PGREG,REG2         START WITH LAST NIP PAGE
RELINK01 L     PGREG,PGCHN(,PGREG) GET 1ST NON NIP PAGE WITH FREE BLKS
         LA    PGREG,0(PGREG)     ZERO HIGH ORDER BYTE
         LTR   PGREG,PGREG        SEE IF ANY NON NIP PAGES LEFT
         BZ    COMPFLK            MUST BE DONE, FREE SYNCH LOCK
         L     BLKREG,PGBLK(,PGREG)    GET 1ST BLOCK ON PAGE IF ANY
         LTR   BLKREG,BLKREG      ANY FREE BLOCKS?
         BZ    RELINK01           NO TRY NEXT PAGE
         LR    REG2,BLKREG  SAVE 1ST BLK FROM 1ST PAGE WITH BLKS
         SPACE
         SR    CNTREG1,CNTREG1    INITIALIZE CNTREG1
RELINK03 L     CNTREG,PGCNT(,PGREG)    GET CNT TO ADD FOR THIS PAGE
         AR    CNTREG1,CNTREG      ADD NO. OF FREE BLKS ON PAGE
         L     BLKREG1,LASTBLK(,PGREG)  GET LAST ON CHAIN, THIS PAGE
         SPACE
*    BLKREG1 PTS TO LAST BLK, PREVIOUS PAGE
*    NOW FIND 1ST BLOCK NEXT PAGE TO STORE IN LINK PTR
*
RELINK10 L     PGREG,PGCHN(,PGREG)     GET NEXT PAGE
         LA    PGREG,0(PGREG)          ZERO HIGH ORDER BYTE
         LTR   PGREG,PGREG             ANY MORE PAGES?
         BZ    RECHAIN1                NO, GO RECHAIN TO FREE QUEUE
         L     BLKREG,PGBLK(,PGREG)    GET 1ST BLOCK ON THIS PAGE
         LA    BLKREG,0(BLKREG)        ZERO HIGH ORDER BYTE
         LTR   BLKREG,BLKREG           ANY BLOCKS THIS PAGE?
         BZ    RELINK10                NO TRY NEXT PAGE
         SPACE
         ST    BLKREG,BLKLINK(,BLKREG1) STORE THIS PTR IN LAST OF
*                                      PREVIOUS PAGE
         B     RELINK03                GO UPDATE CNT & REPEAT LOOP
         SPACE
*
*******************************************************************
*        NOW RECHAIN THE FREE BLOCKS TO THE FREE QUEUE
*        REG2 SHOULD NOW POINT TO THE
*        1ST BLOCK OF THIS CHAIN, BLKREG1 SHOULD POINT TO THE
*        LAST BLOCK OF THIS CHAIN, CNTREG1 HAS NUM. OF BLOCKS
*        TO RETURN
*******************************************************************
*
RECHAIN1 EQU   *                  TRY TO RECHAIN TO THE FREE QUEUE
         LR    BLKREGLK,REG2    :GET 1ST BLOCK OF CHAIN TO ADD
         LM    CNTREG,BLKREG,HEAD160   GET CURRENT CNT & ANCHOR
RECHAIN5 LR    REG0,CNTREG             SAVE NUMBER OF BLOCKS
         AR    REG0,CNTREG1            ADD NUM. OF BLOCKS BEING CHAINED
         AL    REG0,UNIQUECT           ADD 1 TO SYNCH COUNT
         ST    BLKREG,BLKLINK(,BLKREG1)  STORE OLD HEAD IN LAST BLOCK
         CDS   CNTREG,REG0,HEAD160     TRY TO PUT CHAIN ON QUEUE
         BNE   RECHAIN5                CDS FAILED, TRY AGAIN
         SPACE
*  NOW FREE IOSYNCH LOCK TO OPEN WINDOW FOR GET BLOCK ROUTINE
COMPFLK  EQU   *                  FREE LOCK CHECK IF COMPRESS WORKED
         L     BLKREG,IOSADDR     GET IOSYNCH LOCK ADDR
         SETLOCK RELEASE,TYPE=IOSYNCH,ADDR=(11),RELATED=(SMGRPOOL,IECVS*
               MGR(COMPTRY))
         NI    FRRFLA,FF-FRRSYNCH      INDICATE SYNCH LOCK NOT HELD
         OI    FRRFLB,FRRCFLK      INDICATE TO FRR WE GOT THIS FAR
         SPACE
*        NOW TEST IF ANY PAGES TO FREEMAIN
         L     BLKREGLK,PGFREEHD  GET HEAD OF CHAIN FOR FREEMAIN
         C     BLKREGLK,INITCOMP  HAS ANY PAGES BEEN PUT ON QUEUE?
         BE    COMNOTRY           INDICATE COMPRESS DID NOT HELP
         LTR   BLKREGLK,BLKREGLK  TEST FOR ZERO, SHOULD NOT OCCUR
         BZ    ERRCOMP            NOTHING TO FREE
         SPACE
COMPFREE L     HDRREG,PGCHN(,BLKREGLK)  GET NEXT PAGE IF ANY
         ST    HDRREG,PGFREEHD    UPDATE FREEPAGE HEAD
         SPACE
         SETLOCK OBTAIN,TYPE=SALLOC,MODE=UNCOND,RELATED=(GETMAIN,IECVSM*
               GR(COMFREE))
         SPACE
         OI    FRRFLA,FRRALLOC    INDICATE SALLOC HELD
*  NOW FREEMAIN THIS PAGE POINTED TO BY BLKREGLK
         LR    CNTREG,BASEREG     SAVE REG 15 ACROSS GM
         LR    REG2,FRRAREA       SAVE FRR AREA PTR
         FREEMAIN  RU,LV=4096,SP=245,BRANCH=(YES,GLOBAL),A=(1)
         SPACE
         LR    BASEREG,CNTREG     RESTORE REG15
         LR    FRRAREA,REG2       RESTORE FRR AREA PTR
         SPACE
         SETLOCK RELEASE,TYPE=SALLOC,RELATED=(GETMAIN,IECVSMGR(COMPFREE*
               ))
         SPACE
         NI    FRRFLA,FF-FRRALLOC      INDICATE SALLOC LOCK NOT HELD
         C     HDRREG,INITCOMP         ANY MORE PAGES?
         BE    COMPGOOD           NO, RETURN TO CALLER
         LTR   HDRREG,HDRREG      CHECK FOR ZERO, SHOULD NOT HAPPEN
         BZ    ERRCOMP            NOTHING TO FREE
         LR    BLKREGLK,HDRREG    YES, GO FREEMAIN THIS PAGE
         B     COMPFREE           LOOP FOR NEXT PAGE
COMPGOOD SLR   REG0,REG0           INDICATE PAGE(S) FREED
         B     COMPFINI            AND EXIT
         SPACE
COMNOTRY EQU   *                   COMPRESS NOT TRIED, FREE LOCK
         LA    REG0,FOUR           SET RETURN CODE NO PAGES FREED
         SPACE
COMPFINI EQU   *              INDICATE PAGE FREED, DELETE FRR, RTN
         TM    FRRFLA,FRRSYNCH     IS SYNCH LOCK HELD
         BZ    COMPDFRR            NO, SKIP FREE
         L     BLKREG,IOSADDR  GET THE IOSYNCH LOCK ADDR
         SETLOCK RELEASE,TYPE=IOSYNCH,ADDR=(11),RELATED=(SMGRPOOL,IECVS*
               MGR(COMPTRY))
         NI    FRRFLA,FF-FRRSYNCH    INDICATE SYNCH LOCK NOT HELD
         SPACE
COMPDFRR EQU   *          DELETE FRR CHECK FOR BRANCH ENTRY
         LM    SAVEREG,RETREG,FRRSVA    RELOAD 13 & 14
         SR    REG2,REG2        INIT REG2
         TM    FRRFLB,FRRBCOM     WAS COMPRESS BRANCH ENTERED?
         BZ    COMPFRRD           NO,SRB ENTERED
         L     REG2,BRNCHENT      YES, INDICATE BRANCH ENTERED
         SPACE
COMPFRRD SETFRR D,WRKREGS=(3,4)
COMPEXIT SR    CNTREG,CNTREG       ZERO TO ALLOW FUTURE COMPRESS
         L     PGREG,PGFREEHD      GET TO INDICATE COMPRESS DONE
         CS    PGREG,CNTREG,PGFREEHD   SWAP BACK ZERO TO IND FREE
         SPACE
COMPEX2  C     REG2,BRNCHENT      WERE WE BRANCH ENTERED
         BE    COMPBRTN           YES GO RESTORE REGS & SET RC
         SPACE
         BR    RETREG             NO, RETURN TO DISPATCHER
         SPACE
COMPBRTN EQU   *                  RETURN FORM BRANCH ENTRY
         LR    BASEREG,REG0      PUT RETURN CODE IN REG 15
         LM    REG0,RETREG,ZERO(SAVEREG)   RELOAD CALLERS REGS
         BR    RETREG
         SPACE
ERRCOMP  EQU   *
         LR    REG2,BLKREGLK       SAVE REG1 ACROSS ABEND
         ABEND RECRD,,,SYSTEM     CAUSE FRR TO GET CONTROL
         SPACE 2
COMPBASE DC    A(CONSTANT)        TO BECOME ADDRESSABLE TO CONSTANTS
         TITLE 'IECVSMGR - INVOKED DSECTS'
         EJECT                                                 @ZA12704
         IHAFRRS                                               @ZA12704
         EJECT                                                 @ZA12704
         IECDSFRR                                              @ZA12704
         SPACE 1                                               @ZA12704
* NOTE FRRWRK IS USED IN BOTH GET160 & FRR AS A TEMP WA        @ZM41373
* THERE IS NO PROBLEM WITH THIS - ON A RETRY GET160 MAY GET    @ZM41373
* IOSYNCH LOCK UNC WITH SLIGHT & TEMP PERFORMANCE DEGREDATION  @ZM41373
         EJECT
****************************************************************
*                                                              *
*    DSECT OF 200 BYTE WORK AREA EXTENSION USED BY THE FRR.    *
*    THIS WORKAREA IS PASSED IN REGISTER 0 UPON ENTRANCE       *
*    TO THE FRR.                                               *
*                                                              *
****************************************************************
         IHAQVPL
         SPACE 4
QVWORKS  DS    XL(QVPLWASZ)            WORK AREA FOR QVA
QVSAVE   DS    18F                     SAVE AREA FOR CALLED ROUTINES
QFRRSDWA DS    F                       SDWA BACK POINTER
***                                                          ***
***   REMAINDER OF 200 BYTE WORKAREA NOT USED                ***
***                                                          ***
         EJECT
         CVT   LIST=NO,DSECT=YES                               @ZA12704
         EJECT                                                 @ZA12704
         IECDIOQ                                               @ZA12704
         EJECT                                                 @ZA12704
         IHAPSA                                                @ZA12704
         EJECT                                                 @ZA12704
         IHALCCA                                               @ZA12704
         EJECT                                                 @ZA12704
         IECDIRT                                               @ZA12704
         EJECT                                                 @ZA12704
         IHAWSAVT CLASS=CPU,DSECT=YES
         EJECT
         IHAWSAVT CLASS=GLOBAL,DSECT=YES
         EJECT
         IHASDWA
         EJECT
***                                                           ***
*   DSECT DESCRIBES USAGE OF SVC DUMP 4K BUFFER                 *
***                                                           ***
         SPACE 2
SDBUF    DSECT
SDBDATAD DS    A                       DATA ADDRESS
SDBDLN   DS    H                       DATA LENGTH
SDBDATA  EQU   *                       DATA BEGIN
         DS    0D
SDBPHDR  DS    XL(HEADEND)             STORAGE POOL HEADERS
SDBFHDR  DS    XL(FHDLNTH)             FREE QUEUE HEADERS
SDBDL    EQU   *-SDBDATA               LENGTH OF DATA
SDBLAST  DS    XL6                     END OF DATA INDICATOR(ZEROS)
         END
