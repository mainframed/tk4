         TITLE 'IKJEFA12 - ACCOUNT/ADD SUBCOMMAND (AUGMENT MODE        *
                        '
IKJEFA12 CSECT ,                                                   0001
@MAINENT DS    0H                                                  0001
         USING *,@15                                               0001
         B     @PROLOG                                             0001
         DC    AL1(16)                                             0001
         DC    C'IKJEFA12  73.360'                                 0001
         DROP  @15
@PROLOG  STM   @14,@12,12(@13)                                     0001
         BALR  @12,0                                               0001
@PSTART  DS    0H                                                  0001
         USING @PSTART,@12                                         0001
         L     @00,@SIZDATD                                        0001
         GETMAIN R,LV=(0)
         LR    @11,@01                                             0001
         USING @DATD,@11                                           0001
         ST    @13,@SA00001+4                                      0001
         LM    @00,@01,20(@13)                                     0001
         ST    @11,8(,@13)                                         0001
         LR    @13,@11                                             0001
*          COMMPTR=R1;                  /* GET POINTER TO COMMON     */
         LR    COMMPTR,R1                                          0022
*          RFY R1 UNRSTD;               /* RELEASE REGISTER 1        */
*          SWITCHES='0'B;               /* CLEAR SWITCHES            */
         MVI   SWITCHES,B'00000000'                                0024
*          STOWLIST=STOWLIST&&STOWLIST; /* CLEAR STOW LIST           */
         XC    STOWLIST(14),STOWLIST                               0025
*          STOWC='01'X;                 /* INDICATE ONE DATA HALFWORD*/
         MVI   STOWC,X'01'                                         0026
*          /* MOVE L-FORMS OF O/S MACROS INTO DYNAMIC STORAGE        */
*          DYNLFORM(1:INLINLNG)=INLINLFM(1:INLINLNG);              0027
         L     @10,INLINLNG                                        0027
         BCTR  @10,0                                               0027
         EX    @10,@SM00322                                        0027
*          OUTLNDS=OUTLNDS&&OUTLNDS;    /* CLEAR OUTPUT LINE       0028
*                                          DESCRIPTORS FOR PUTLINE   */
         XC    OUTLNDS(40),OUTLNDS                                 0028
*          OUT1LINK=ADDR(OUTLD2);       /* INITIALIZE LINKAGE FOR  0029
*                                          2 MESSAGE LEVELS          */
         LA    @10,OUTLD2                                          0029
         ST    @10,OUT1LINK                                        0029
*          MSGBASE=ADDR(MSGTABLE);      /* BASE PTR FOR MSG PTR TABLE*/
         L     MSGBASE,@CV00118                                    0030
*          GEN (USING IHADCB,DCBREG)    /* ESTABLISH DCB ADDRESSABLTY*/
*            REFS(DCBREG);                                         0031
         USING IHADCB,DCBREG
*          RFY (DCBREG) RSTD;           /* RESERVE REG. FOR DCB BASE */
*          DCBREG=ADDR(BPAMDCB);        /* LOAD DCB POINTER          */
         LA    DCBREG,BPAMDCB                                      0033
*          /* OPEN THE UADS FOR UPDATE MODE                          */
*          GEN (OPEN  ((DCBREG),(UPDAT)),MF=(E,DYNOPLST))          0034
*            REFS(DCBREG,DYNOPLST);                                0034
         OPEN  ((DCBREG),(UPDAT)),MF=(E,DYNOPLST)
*          /* CHECK FOR A SUCCESSFUL OPEN                            */
*          IF DCBOFLGS(4)='0'B                                     0035
*            THEN                       /* OPEN FAILED               */
         TM    DCBOFLGS,B'00010000'                                0035
         BNZ   @RF00035                                            0035
*              DO;                                                 0036
*                /* SET PARAMETERS FOR PUTLINE MESSAGE               */
*                OUT1SCNT='01'X;        /* 1ST LEVEL MSG SEG COUNT =1*/
         MVI   OUT1SCNT,X'01'                                      0037
*                OUT1SEG1=ADDMSG(8);    /* ADDR OF UADS NO GOOD MSG  */
         L     @10,ADDMSG+28(,MSGBASE)                             0038
         ST    @10,OUT1SEG1                                        0038
*                OUT2SCNT='01'X;        /* 2ND LEVEL MSG SEG COUNT =1*/
         MVI   OUT2SCNT,X'01'                                      0039
*                OUT2SEG1=ADDMSG(9);    /* 2ND LVL = 'CANNOT OPEN'   */
         L     @10,ADDMSG+32(,MSGBASE)                             0040
         ST    @10,OUT2SEG1                                        0040
*                GOTO ERRMSG;           /* GO PUT OUT MESSAGE & LEAVE*/
         B     ERRMSG                                              0041
*              END;                                                0042
*          RFY (DCBREG) UNRSTD;         /* RELEASE REG. FOR DCB BASE */
@RF00035 DS    0H                                                  0044
*          /**********************************************************/
*          /* SCAN THE DATA KEYWORD SUBFIELD PDES FOR DUPLICATE      */
*          /* ENTRIES WITHIN LIST ON EACH LEVEL.                     */
*          /**********************************************************/
*          /* SCAN EACH DATA SUBFIELD LEVEL (I.E., PASSWORDS,        */
*          /* ACCOUNT NUMBERS, PROC NAMES) WITH ONE ITERATION        */
*          DO LEVLPTR=DATASUBP          /* BEGINNING OF SUBFIELD     */
*             BY LNDAPDE                /* INCREMENT BY PDE SIZE     */
*             TO DATASUBP+(2*LNDAPDE);  /* LAST BYTE OF SUBFIELD     */
         L     LEVLPTR,DATASUBP(,COMMPTR)                          0044
         B     @DE00044                                            0044
@DL00044 DS    0H                                                  0045
*            ARGPDPTR=LEVLPTR;          /* FIRST PDE IN A LIST       */
         LR    ARGPDPTR,LEVLPTR                                    0045
*            /* IS THIS ARGUMENT LAST IN THE CHAIN ?                 */
*            DO WHILE ARGPDPTR^=0 &     /* LOOP TILL LINK PTR = 0    */
*             ARGPDPTR->DATACHN^=0;                                0046
         B     @DE00046                                            0046
@DL00046 DS    0H                                                  0047
*              ARGPTR=ARGPDPTR->DATAPTR;/* ARGUMENT FOR SCAN FOR   0047
*                                          DUPLICATES                */
         L     ARGPTR,DATAPTR(,ARGPDPTR)                           0047
*              PREPDPTR=ARGPDPTR;       /* SAVE INITIAL PTR AS     0048
*                                          'PREVIOUS' PDE PTR        */
         LR    PREPDPTR,ARGPDPTR                                   0048
*              CURPDPTR=ARGPDPTR->DATACHN; /* INITIALIZE 'CURRENT' 0049
*                                             ITEM PDE PTR           */
         SLR   CURPDPTR,CURPDPTR                                   0049
         ICM   CURPDPTR,7,DATACHN(ARGPDPTR)                        0049
*              /* TOP OF SCAN FOR ONE ARGUMENT                       */
*              DO WHILE CURPDPTR^=0;    /* LOOP TILL LINK POINTER = 0*/
         B     @DE00050                                            0050
@DL00050 DS    0H                                                  0051
*                CURRPTR=DATAPTR;       /* COMPARAND FOR COMPARE     */
         L     CURRPTR,DATAPTR(,CURPDPTR)                          0051
*                /* DOES 'ARGUMENT' = 'CURRENT' ?                    */
*                IF ARGPDPTR->DATALNTH=DATALNTH /* IF LENGTH IS EQUAL*/
*                    &ARGPTR->DATAITEM(1:DATALNTH)                 0052
*                    =DATAITEM(1:DATALNTH) /* AND TEXT IS EQUAL      */
*                  THEN                 /* A DUPLICATE IS FOUND      */
         LH    @10,DATALNTH(,CURPDPTR)                             0052
         CH    @10,DATALNTH(,ARGPDPTR)                             0052
         BNE   @RF00052                                            0052
         LR    @15,@10                                             0052
         BCTR  @15,0                                               0052
         EX    @15,@SC00324                                        0052
         BNE   @RF00052                                            0052
*                    DO;                                           0053
*                      PREPDPTR->DATACHN=DATACHN; /* REMOVE 'CURRENT'
*                                                    ITEM            */
         MVC   DATACHN(3,PREPDPTR),DATACHN(CURPDPTR)               0054
*                      /* SET PARAMETERS FOR PUTLINE MESSAGE         */
*                      OUT1LINK=0;      /* INDICATE NO 2ND LEVEL     */
         SLR   @14,@14                                             0055
         ST    @14,OUT1LINK                                        0055
*                      OUT1SCNT='02'X;  /* 1ST LVL SEG COUNT =2      */
         MVI   OUT1SCNT,X'02'                                      0056
*                      OUT1SEG1=ADDMSG(15); /* 'DUPLICATE ITEM XXXX
*                                              IGNORED'              */
         L     @14,ADDMSG+56(,MSGBASE)                             0057
         ST    @14,OUT1SEG1                                        0057
*                      INSTLN=DATALNTH+4; /* DATA SEGMT LENGTH       */
         AH    @10,@CH00073                                        0058
         STH   @10,INSTLN                                          0058
*                      INSTOF=25;       /* OFFSET FOR INSERTION      */
         MVC   INSTOF(2),@CH00247                                  0059
*                      INSTTX(1:DATALNTH)=DATAITEM; /* TEXT          */
         EX    @15,@SM00326                                        0060
*                      OUT1SEG2=ADDR(INSTSEG); /* 2ND SEG PTR        */
         LA    @10,INSTSEG                                         0061
         ST    @10,OUT1SEG2                                        0061
*                      CALL INFOMSG;    /* GO PUT OUT MSG            */
         BAL   @14,INFOMSG                                         0062
*                    END;                                          0063
*                      ELSE                                        0064
*                        PREPDPTR=CURPDPTR;   /* MAKE 'CURRENT' PDE
*                                                  'PREVIOUS'        */
         B     @RC00052                                            0064
@RF00052 LR    PREPDPTR,CURPDPTR                                   0064
*                    /* CONTROL RETURNED HERE FROM MESSAGE HANDLER   */
*                    CURPDPTR=DATACHN; /* UPDT 'CURRENT' PTR         */
@RC00052 SLR   @10,@10                                             0065
         ICM   @10,7,DATACHN(CURPDPTR)                             0065
         LR    CURPDPTR,@10                                        0065
*              END;                     /* END OF SCAN FOR ONE ITEM  */
@DE00050 LTR   CURPDPTR,CURPDPTR                                   0066
         BNZ   @DL00050                                            0066
*                    ARGPDPTR=ARGPDPTR->DATACHN; /* BUMP ARGUMENT PDE*/
         SLR   @10,@10                                             0067
         ICM   @10,7,DATACHN(ARGPDPTR)                             0067
         LR    ARGPDPTR,@10                                        0067
*            END;                       /* END OF SCANS FOR ONE    0068
*                                          DATA SUBFIELD LEVEL       */
@DE00046 LTR   ARGPDPTR,ARGPDPTR                                   0068
         BZ    @DC00046                                            0068
         ICM   @10,7,DATACHN(ARGPDPTR)                             0068
         BNZ   @DL00046                                            0068
@DC00046 DS    0H                                                  0069
*          END;                         /* LOOP FOR ANOTHER LEVL     */
         AL    LEVLPTR,LNDAPDE                                     0069
@DE00044 L     @10,LNDAPDE                                         0069
         ALR   @10,@10                                             0069
         AL    @10,DATASUBP(,COMMPTR)                              0069
         CR    LEVLPTR,@10                                         0069
         BNH   @DL00044                                            0069
*          ACIODCBA=ADDR(BPAMDCB);      /* POINT TO UPDATE DCB       */
         L     @10,ACIOPTR(,COMMPTR)                               0070
         LA    @15,BPAMDCB                                         0070
         STCM  @15,7,ACIODCBA(@10)                                 0070
*          /* SEE IF THE USERID IS AN '*'                            */
*          IF USRID(1)='*'                                         0071
*            THEN                       /* USERID='*' MEANS 'ADD DATA-
*                                          LIST TO ALL USERIDS'.     */
         L     @01,NODEPLAD(,COMMPTR)                              0071
         CLI   USRID(@01),C'*'                                     0071
         BNE   @RF00071                                            0071
*              /* OPEN THE UADS FOR BSAM INPUT AND SET THE READ      */
*              /* SUBROUTINE PARAMETER LIST FOR DIRECTORY OPERATIONS */
*              DO;                                                 0072
*                ACIODRCT=ADDR(DIRWAREA); /* POINT TO DIRECTORY WORK
*                                            AREA                    */
         LA    @15,DIRWAREA                                        0073
         ST    @15,ACIODRCT(,@10)                                  0073
*                DIRDCB=BSAMDCB;        /* MOVE MODEL DCB INTO WKAREA*/
         MVC   DIRDCB(88),BSAMDCB                                  0074
*                DIRMNSW='1'B;          /* INDICATE DIRECTORY WORK 0075
*                                          AREA GOTTEN IN STATUS SWS */
         OI    DIRMNSW,B'01000000'                                 0075
*                /* OPEN THE DCB FOR INPUT                           */
*                RFY (DCBREG) RSTD;     /* RESERVE REG. FOR DCB BASE */
*                DCBREG=ADDR(DIRDCB);   /* SET ADDR OF BSAM DCB      */
         LA    DCBREG,DIRDCB                                       0077
*                /* ISSUE OS/360 OPEN MACRO                          */
*                GEN (OPEN  ((DCBREG),(INPUT)),MF=(E,DYNOPLST))    0078
*                  REFS(DCBREG,DYNOPLST);                          0078
         OPEN  ((DCBREG),(INPUT)),MF=(E,DYNOPLST)
*                /* CHECK FOR SUCCESSFUL OPEN                        */
*                IF DCBOFLGS(4)='0'B                               0079
*                  THEN                 /* OPEN FAILED               */
         TM    DCBOFLGS,B'00010000'                                0079
         BNZ   @RF00079                                            0079
*                    DO;                                           0080
*                      /* SET PARAMETERS FOR PUTLINE MESSAGE         */
*                      OUT1SCNT='01'X;  /* 1ST LEVEL MSG SEG COUNT =1*/
         MVI   OUT1SCNT,X'01'                                      0081
*                      OUT1SEG1=ADDMSG(8); /* PTR TO UADS NO GOOD MSG*/
         L     @10,ADDMSG+28(,MSGBASE)                             0082
         ST    @10,OUT1SEG1                                        0082
*                      OUT2SCNT='01'X;  /* 2ND LEVEL MSG SEG COUNT =1*/
         MVI   OUT2SCNT,X'01'                                      0083
*                      OUT2SEG1=ADDMSG(9); /* 2ND LVL = 'CANNOT OPEN'*/
         L     @10,ADDMSG+32(,MSGBASE)                             0084
         ST    @10,OUT2SEG1                                        0084
*                      GOTO ERRMSG;     /* GO PUT OUT MESSAGE & LEAVE*/
         B     ERRMSG                                              0085
*                    END;                                          0086
*                RFY (DCBREG) UNRSTD;   /* RELEASE REG. FOR DCB BASE */
@RF00079 DS    0H                                                  0088
*RDDIRECT:       /* CTL. PASSED HERE TO READ DIRECTORY BLOCK ONLY    */
*                ACIOFLGS='00110100'B;  /* SET I/O SUBROUTINE FLAGS FOR
*                                          A) LOGICAL MEMBER I/O REQ'D
*                                          B) ACIOMPTR = MEMBERNAME PTR
*                                          C) ACIODRCT=PTR TO WORK AREA
*                                          D) BUFFER FOR ONE EXTRA BLK
*                                          E) READ DIRECTORY ONLY    */
RDDIRECT L     @10,ACIOPTR(,COMMPTR)                               0088
         MVI   ACIOFLGS(@10),B'00110100'                           0088
*                CALL READ;             /* GO TO CALL IKJEFA51       */
         BAL   @14,READ                                            0089
*                ACIOFL06='0'B;         /* TURN OFF 'DIRECTORY ONLY' */
         L     @10,ACIOPTR(,COMMPTR)                               0090
         NI    ACIOFL06(@10),B'11111011'                           0090
*                ACIOMPTR=ADDR(DIRENTRX); /* POINT TO FIRST USERID   */
         LA    @15,DIRENTRX                                        0091
         ST    @15,ACIOMPTR(,@10)                                  0091
*                BLDLNAME=DIRMNAME;     /* SAVE USERID IN CASE     0092
*                                          OF ERROR                  */
         L     @10,BLDLPTR(,COMMPTR)                               0092
         MVC   BLDLNAME(8,@10),DIRMNAME(@15)                       0092
*              END;                                                0093
*            ELSE                       /* THE USERID WAS SPECIFIED  */
*              DO;                                                 0094
         B     @RC00071                                            0094
@RF00071 DS    0H                                                  0095
*              RFY R0 RSTD;             /* RESTRICT REGISTER 0       */
*              R0=BLDLPTR;              /* LOAD BLDL PARAMETER REG   */
         L     R0,BLDLPTR(,COMMPTR)                                0096
*              /* DO A 'BLDL' ON THE UADS DIRECTORY TO FIND USERID   */
*              GEN (BLDL  BPAMDCB,(R0))                            0097
*                REFS(BPAMDCB,R0);                                 0097
         BLDL  BPAMDCB,(R0)
*              RFY R0 UNRSTD;           /* RELEASE REGISTER 0        */
*              RFY R15 RSTD;            /* RESTRICT RETURN CODE REG  */
*              RETNCODE=R15;            /* SAVE RETURN CODE          */
         LR    RETNCODE,R15                                        0100
*              RFY R15 UNRSTD;          /* RELEASE RETURN CODE REG   */
*              /* MAKE CERTAIN THE USERID ALREADY EXISTS IN THE UADS */
*              IF RETNCODE^=0                                      0102
*                THEN                   /* USERID NOT FOUND          */
         SLR   @10,@10                                             0102
         CR    RETNCODE,@10                                        0102
         BE    @RF00102                                            0102
*                  /* ASCERTAIN EXACT CAUSE                          */
*                  IF RETNCODE=4                                   0103
*                    THEN               /* MISSING USERID            */
         LA    @07,4                                               0103
         CR    RETNCODE,@07                                        0103
         BNE   @RF00103                                            0103
*                      DO;                                         0104
*                      /* SET PARAMETERS FOR PUTLINE MESSAGE         */
*                      OUT1LINK=0;      /* INDICATE NO 2ND LEVEL MSG */
         ST    @10,OUT1LINK                                        0105
*                      OUT1SCNT='03'X;  /* 1ST LEVEL MSG SEG COUNT =3*/
         MVI   OUT1SCNT,X'03'                                      0106
*                      OUT1SEG1=ADDMSG(17);/* ADD OF MISSING ITEM MSG*/
         L     @10,ADDMSG+64(,MSGBASE)                             0107
         ST    @10,OUT1SEG1                                        0107
*                      OUT1SEG2=ADDMSG(20);/* ADDR OF 'USERID' PREFIX*/
         L     @10,ADDMSG+76(,MSGBASE)                             0108
         ST    @10,OUT1SEG2                                        0108
*                      USRIDLN=USRLEN+4;/* USERID SEGMENT LENGTH     */
         L     @10,NODEPLAD(,COMMPTR)                              0109
         SLR   @05,@05                                             0109
         IC    @05,USRLEN(,@10)                                    0109
         ALR   @07,@05                                             0109
         STH   @07,USRIDLN                                         0109
*                      USRIDOF=10;      /* OFFSET FOR TEXT INSERTION */
         MVC   USRIDOF(2),@CH00258                                 0110
*                      USRIDI=USRID;    /* USERID FROM NODELIST TABLE*/
         MVC   USRIDI(8),USRID(@10)                                0111
*                      OUT1SEG3=ADDR(USRIDSEG);/* USERID SEGMENT ADDR*/
         LA    @10,USRIDSEG                                        0112
         ST    @10,OUT1SEG3                                        0112
*                      GOTO ERRMSG;     /* GO PUT OUT MESSAGE & LEAVE*/
         B     ERRMSG                                              0113
*                      END;                                        0114
*                    ELSE               /* A PERMANENT I/O ERROR   0115
*                                          OCCURRED WHEN BLDL ATTEMPTED
*                                          TO SEARCH THE DIRECTORY.  */
*                      DO;                                         0115
@RF00103 DS    0H                                                  0116
*                      /* SET PARAMETERS FOR PUTLINE MESSAGE         */
*                      OUT1SCNT='01'X;  /* 1ST LEVEL MSG SEG COUNT =1*/
         MVI   OUT1SCNT,X'01'                                      0116
*                      OUT1SEG1=ADDMSG(8);/* ADDR OF UADS NO GOOD MSG*/
         L     @10,ADDMSG+28(,MSGBASE)                             0117
         ST    @10,OUT1SEG1                                        0117
*                      OUT2SCNT='01'X;  /* 2ND LEVEL MSG SEG COUNT =1*/
         MVI   OUT2SCNT,X'01'                                      0118
*                      OUT2SEG1=ADDMSG(10);/* 2ND LVL = 'BLDL I/O ERR*/
         L     @10,ADDMSG+36(,MSGBASE)                             0119
         ST    @10,OUT2SEG1                                        0119
*                      GOTO ERRMSG;     /* GO PUT OUT MESSAGE & LEAVE*/
         B     ERRMSG                                              0120
*                      END;                                        0121
*                  ACIOFLGS='01010000'B;/* SET FLAGS TO INDICATE   0122
*                                          A) LOGICAL MEMBER I/O REQ'D
*                                          B) ACIOMPTR = BLDL ENTRY PTR
*                                          C) ACIODRCT NOT PERTINENT
*                                          D) BUFFR FOR 1 EXTRA BLOCK*/
@RF00102 L     @10,ACIOPTR(,COMMPTR)                               0122
         MVI   ACIOFLGS(@10),B'01010000'                           0122
*                  ACIOMPTR=BLDLPTR;    /* PTR TO BLDL ENTRY         */
         L     @15,BLDLPTR(,COMMPTR)                               0123
         ST    @15,ACIOMPTR(,@10)                                  0123
*              END;                                                0124
*USERLOOP: /* CTL. RETURNED HERE UPON COMPLETION OF THE PROCESSING   */
*          /* FOR ONE USERID TO READ THE NEXT ONE                    */
*          /* BUILD USERID SEGMENT FOR MESSAGES JUST IN CASE ...     */
*          /* SCAN FOR & DELETE TRAILING BLANKS                      */
*          USERLNTH=8;                  /* INIT USERID LENGTH TO MAX */
@RC00071 DS    0H                                                  0125
USERLOOP MVI   USERLNTH,X'08'                                      0125
*          DO WHILE BLDLNAME(USERLNTH)=' ';/* LOOP TILL NON-BLANK    */
         B     @DE00126                                            0126
@DL00126 DS    0H                                                  0127
*            USERLNTH=USERLNTH-1;       /* DECREMENT LENGTH OF SEG   */
         SLR   @10,@10                                             0127
         IC    @10,USERLNTH                                        0127
         BCTR  @10,0                                               0127
         STC   @10,USERLNTH                                        0127
*          END;                                                    0128
@DE00126 SLR   @10,@10                                             0128
         IC    @10,USERLNTH                                        0128
         L     @15,BLDLPTR(,COMMPTR)                               0128
         ALR   @10,@15                                             0128
         CLI   BLDLNAME-1(@10),C' '                                0128
         BE    @DL00126                                            0128
*          USERLNTH=USERLNTH-1;         /* DECREMENT PAST INDEX      */
         SLR   @10,@10                                             0129
         IC    @10,USERLNTH                                        0129
         BCTR  @10,0                                               0129
         STC   @10,USERLNTH                                        0129
*          USERNAME=BLDLNAME(1:USERLNTH);/* SAVE NAME FOR ENQUEUE    */
         MVI   USERNAME+1,C' '                                     0130
         MVC   USERNAME+2(5),USERNAME+1                            0130
         LR    @14,@10                                             0130
         BCTR  @14,0                                               0130
         EX    @14,@SM00330                                        0130
*          USRIDI=USERNAME(1:USERLNTH); /* SAVE NAME FOR MESSAGE     */
         MVI   USRIDI+1,C' '                                       0131
         MVC   USRIDI+2(6),USRIDI+1                                0131
         EX    @14,@SM00332                                        0131
*          USRIDLN=USERLNTH+4;          /* SET LENGTH OF MSG SEG     */
         AH    @10,@CH00073                                        0132
         STH   @10,USRIDLN                                         0132
*          /*** INSERTION OFFSET IS SET WHEN MESSAGE IS BUILT      ***/
*          /* FETCH A USER ENTRY FROM THE UADS                       */
*          CALL READ;                   /* INVOKE READ PGM - IKJEFA51*/
         BAL   @14,READ                                            0133
*          READMNSW='1'B;               /* INDICATE THAT AN INPUT BUFR
*                                          AND A BLDL CHAIN EXISTS 0134
*                                          IN THE STATUS SWITCHES    */
         OI    READMNSW(COMMPTR),B'00000010'                       0134
*          HEDBPTR=ACIOBUFR;            /* ESTABLISH USER ENTRY    0135
*                                          ADDRESSABILITY            */
         L     @10,ACIOPTR(,COMMPTR)                               0135
         SLR   HEDBPTR,HEDBPTR                                     0135
         ICM   HEDBPTR,7,ACIOBUFR(@10)                             0135
*          /* IF SIZE WAS SPECIFIED AND IT IS GREATER THAN MAXSIZE 0136
*             SET RSIZSW SO THAT IKJEFA13 WILL OVERRIDE THE SIZE   0136
*             VALUE WITH THE MAXSIZE VALUE.                          */
*          IF SIZEH^='0'B               /* THEN, SEE IF THE 'SIZE' 0136
*                                          KEYWORD WAS SUPPLIED      */
*            & UADSMAXC^=0              /* IS MAXIMUM SIZE SPECIFIED?*/
*             & SIZEH>UADSMAXC          /* DOES SIZE EXCEED MAXSIZE? */
*                THEN                   /* YES,                      */
         SLR   @10,@10                                             0136
         ICM   @10,3,SIZEH(COMMPTR)                                0136
         LTR   @10,@10                                             0136
         BZ    @RF00136                                            0136
         SLR   @10,@10                                             0136
         ICM   @10,3,UADSMAXC(HEDBPTR)                             0136
         LTR   @10,@10                                             0136
         BZ    @RF00136                                            0136
         CLC   SIZEH(2,COMMPTR),UADSMAXC(HEDBPTR)                  0136
         BNH   @RF00136                                            0136
*                  RSIZSW='1'B;         /* SET 'EXCESSIVE SIZE' SWTCH*/
         OI    RSIZSW(COMMPTR),B'00010000'                         0137
*          /**********************************************************/
*          /* CONTROL PASSES HERE TO IKJEFA13 WHERE THE NODE         */
*          /* SPECIFIED BY THE NODELIST IS LOCATED (FINDNODE ROUTINE)*/
*          /* AND THE ITEM(S) IN THE DATA SUBFIELD ARE ADDED (ADDER).*/
*          /* IF IKJEFA13 SUCCEEDS, CONTROL WILL BE RETURNED TO THIS */
*          /* POINT.  IF A GETMAIN FAILS, CONTROL WILL BE RETURNED TO*/
*          /* 'RDGETERR'.  IF 'FINDNODE' FAILS TO FIND THE NODE(S),  */
*          /* OR 'ADDER' FINDS A DUPLICATE ITEM, CONTROL WILL RETURN */
*          /* TO 'ADDERCLN'.                                         */
*          /**********************************************************/
*          RFY R1 RSTD;                 /* RESTRICT PARAMETER POINTER*/
@RF00136 DS    0H                                                  0139
*          R1=COMMPTR;                  /* POINT TO COMMUNICATION ARE*/
         LR    R1,COMMPTR                                          0139
*          CALL IKJEFA13;               /* GO DO THE WORK            */
         L     @15,@CV00077                                        0140
         BALR  @14,@15                                             0140
*          RFY R1 UNRSTD;               /* RELEASE PARAMETER POINTER */
*          /**********************************************************/
*          /* AT THIS POINT, THE USERID HAS BEEN COMPLETELY UPDATED  */
*          /* IN THE MAIN STORAGE BUFFER.                            */
*          /**********************************************************/
*          /* CHECK FOR USER ATTENTION INTERRUPT BEFORE WRITE OPNS   */
*          IF ATTENTN='1'B                                         0142
*            THEN                       /* USER WANTS ATTENTION      */
         L     @10,ECBPTR(,COMMPTR)                                0142
         TM    ATTENTN(@10),B'01000000'                            0142
         BO    @RT00142                                            0142
*              GO TO CLEANUP1;          /* STOP -GO DIRECTLY TO CLNUP*/
*          /* NOW, ENQ ON THE USERID BEFORE WRITING INTO THE UADS    */
*          /* ISSUE OS/360 ENQ MACRO ON THE USERID AS A MINOR NAME   */
*          GEN (ENQ   (,MINNAME),,MF=(E,DYNNQLST))                 0144
*            REFS(DYNNQLST,MAJNAME,MINNAME);                       0144
         ENQ   (,MINNAME),,MF=(E,DYNNQLST)
*          RFY R15 RSTD;                /* RESTRICT RETURN CODE REG  */
*          ENQRCPTR=R15;                /* SAVE RETURN CODE PTR      */
         LR    ENQRCPTR,R15                                        0146
*          RFY R15 UNRSTD;              /* RELEASE RETURN CODE REG   */
*          /* CHECK RETURN CODE                                      */
*          IF ENQRCPTR^=0                                          0148
*            THEN                       /* ENQ EXCEPTION             */
         LTR   ENQRCPTR,ENQRCPTR                                   0148
         BZ    @RF00148                                            0148
*              DO;                                                 0149
*                /****************************************************/
*                /* ACTION TAKEN HERE TO RELEASE THE READ ROUTINE'S  */
*                /* BUFFER AND PUT OUT A MESSAGE INDICATING THAT THIS*/
*                /* USERID IS IN USE.                                */
*                /****************************************************/
*                ACIOFL05='0'B;         /* MAKE CERTAIN THAT NO    0150
*                                          WRITING TAKES PLACE       */
         L     @10,ACIOPTR(,COMMPTR)                               0150
         NI    ACIOFL05(@10),B'11110111'                           0150
*                CALL WRITE;            /* SCRATCH READ ROUTINE STG  */
         BAL   @14,WRITE                                           0151
*                READMNSW='0'B;         /* INDICATE READ ROUTINE   0152
*                                          STORAGE HAS BEEN FREED    */
         NI    READMNSW(COMMPTR),B'11111101'                       0152
*                /* ANALYZE RETURN CODE FURTHER                      */
*                IF ENQRTCD=4                                      0153
*                  THEN                 /* USERID IS ENQUEUED        */
         CLI   ENQRTCD+3(ENQRCPTR),4                               0153
         BNE   @RF00153                                            0153
*                    DO;                                           0154
*                    OUT1LINK=0;        /* INDICATE NO 2ND LEVEL MSG */
         SLR   @10,@10                                             0155
         ST    @10,OUT1LINK                                        0155
*                    OUT1SCNT='02'X;    /* 1ST LEVEL MSG SEG COUNT =2*/
         MVI   OUT1SCNT,X'02'                                      0156
*                    OUT1SEG1=ADDMSG(18);/* ADDR OF 'USER IN USE' MSG*/
         L     @10,ADDMSG+68(,MSGBASE)                             0157
         ST    @10,OUT1SEG1                                        0157
*                    USRIDOF=35;        /* OFFSET FOR USERID INSERTN */
         MVC   USRIDOF(2),@CH00266                                 0158
*                    OUT1SEG2=ADDR(USRIDSEG); /* 2ND SEGMENT = USERID*/
         LA    @10,USRIDSEG                                        0159
         ST    @10,OUT1SEG2                                        0159
*                    CALL INFOMSG;      /* GO PUT OUT MSG            */
         BAL   @14,INFOMSG                                         0160
*                    GOTO ADDERCLN;     /* GO TO CLEANUP & RETURN    */
         B     ADDERCLN                                            0161
*                    END;                                          0162
*                  ELSE                 /* PROGRAM MALFUNCTION       */
*                    DO;                                           0163
@RF00153 DS    0H                                                  0164
*                    RETNCODE=ENQRTCD;  /* GET ENQUEUE RETURN CODE   */
         SLR   RETNCODE,RETNCODE                                   0164
         IC    RETNCODE,ENQRTCD+3(,ENQRCPTR)                       0164
*                    OUT2SEG2=ADDMSG(37); /* ADDR OF 'ENQ' PREFIX    */
         L     @10,ADDMSG+144(,MSGBASE)                            0165
         ST    @10,OUT2SEG2                                        0165
*                    GOTO CMDSYSER;     /* GO PUT OUT MESSAGE & LEAVE*/
         B     CMDSYSER                                            0166
*                    END;                                          0167
*              END;                                                0168
*          USRENQSW='1'B;               /* INDICATE THAT ENQ WAS DONE*/
@RF00148 OI    USRENQSW,B'00010000'                                0169
*          /* NOW, SEE IF A NEW UADS MEMBER NEEDS TO BE WRITTEN      */
*          IF XBLKUSED='1'B                                        0170
*            THEN                       /* EXTRA BLOCK USED -WRITE IT*/
         TM    XBLKUSED(COMMPTR),B'00000001'                       0170
         BNO   @RF00170                                            0170
*              DO;                                                 0171
*              RFY (DCBREG) RSTD;       /* RESERVE REG. FOR DCB BASE */
*                DCBREG=DCBPTR;         /* POINT TO 'OUTPUT' DCB     */
         L     DCBREG,DCBPTR(,COMMPTR)                             0173
*                /* IS THE DCB FOR 'OUTPUT' OPEN ?                   */
*                IF DCBOFLGS(4)='0'B                               0174
*                  THEN                 /* 'OUTPUT' DCB NOT YET OPEND*/
         TM    DCBOFLGS,B'00010000'                                0174
         BNZ   @RF00174                                            0174
*                    DO;                                           0175
*                      /* ISSUE OS/360 OPEN MACRO                    */
*                      GEN (OPEN  ((DCBREG),(OUTPUT)),MF=(E,DYNOPLST))
*                        REFS(DCBREG,DYNOPLST);                    0176
         OPEN  ((DCBREG),(OUTPUT)),MF=(E,DYNOPLST)
*                      /* CHECK FOR SUCCESSFUL OPEN                  */
*                      IF DCBOFLGS(4)='0'B                         0177
*                        THEN           /* OPEN FAILED               */
         TM    DCBOFLGS,B'00010000'                                0177
         BNZ   @RF00177                                            0177
*                          DO;                                     0178
*                            /* SET PARAMETERS FOR PUTLINE MESSAGE   */
*                            OUT1SCNT='01'X; /* 1ST LVL SEG COUNT = 1*/
         MVI   OUT1SCNT,X'01'                                      0179
*                            OUT1SEG1=ADDMSG(8); /* UADS NO GOOD MSG */
         L     @10,ADDMSG+28(,MSGBASE)                             0180
         ST    @10,OUT1SEG1                                        0180
*                            OUT2SCNT='01'X; /* 2ND LVL SEG COUNT = 1*/
         MVI   OUT2SCNT,X'01'                                      0181
*                            OUT2SEG1=ADDMSG(9); /* 'CANNOT OPEN' MSG*/
         L     @10,ADDMSG+32(,MSGBASE)                             0182
         ST    @10,OUT2SEG1                                        0182
*                            GOTO ERRMSG;/* GO PUT OUT MSG & LEAVE   */
         B     ERRMSG                                              0183
*                          END;                                    0184
*                    END;                                          0185
@RF00177 DS    0H                                                  0186
*                /* PREPARE ALTERNATE PARAMETER LIST FOR WRITE ROUTNE*/
*                HEDBPTR=ACIONMBR*UADSBLNG+HEDBPTR; /* RESET BLK BASE*/
@RF00174 L     @10,ACIOPTR(,COMMPTR)                               0186
         SLR   @07,@07                                             0186
         IC    @07,ACIONMBR(,@10)                                  0186
         MH    @07,UADSBLNG(,HEDBPTR)                              0186
         ALR   HEDBPTR,@07                                         0186
*                ACIOALTL=ACIOPARM;     /* INITIALIZE ALTERNATE      */
         MVC   ACIOALTL(24),ACIOPARM(@10)                          0187
*                ACIOPTRS=ACIOPTR;      /* SAVE ACIOPTR              */
         LR    ACIOPTRS,@10                                        0188
*                ACIOPTR=ADDR(ACIOALTL);/* USE ALTERNATE PARMLIST    */
         LA    @10,ACIOALTL                                        0189
         ST    @10,ACIOPTR(,COMMPTR)                               0189
*                ACIOFLGS='10001000'B;  /* SET FLAGS TO INDICATE   0190
*                                          A) SINGLE PHYSICAL MEMBR I/O
*                                          B) WRITE OP'N REQUESTED   */
         MVI   ACIOFLGS(@10),B'10001000'                           0190
*                ACIODCBA=DCBREG;       /* UADS 'OUTPUT' DCB ADDR    */
         STCM  DCBREG,7,ACIODCBA(@10)                              0191
*                ACIOMPTR=ADDR(UADSUSER); /* USER NAME RIGHT FROM HDR*/
         LA    @07,UADSUSER(,HEDBPTR)                              0192
         ST    @07,ACIOMPTR(,@10)                                  0192
*                ACIOLINK=0;            /* NO BLDL CHAIN ELEMENT     */
         SLR   @07,@07                                             0193
         ST    @07,ACIOLINK(,@10)                                  0193
*                ACIONMBR=1;            /* NO. OF MEMBERS = ONE      */
         MVI   ACIONMBR(@10),X'01'                                 0194
*                ACIOBUFR=HEDBPTR;      /* ADDRESS OF OUTPUT BLOCK   */
         STCM  HEDBPTR,7,ACIOBUFR(@10)                             0195
*                CALL WRITE;            /* INVOKE WRITE PGM -IKJEFA52*/
         BAL   @14,WRITE                                           0196
*                ACIOPTR=ACIOPTRS;      /* RESTORE PTR TO I/O PARM   */
         ST    ACIOPTRS,ACIOPTR(,COMMPTR)                          0197
*                /* NEXT, STOW NEW MEMBER NAME IN UADS DIRECTORY     */
*                STOWNAME=UADSUSER;     /* MEMBERNAME =(USERID+INDEX)*/
         MVC   STOWNAME(8),UADSUSER(HEDBPTR)                       0198
*                /* ISSUE OS/360 STOW MACRO ('A'=ADD NEW ENTRY)      */
*                GEN (STOW  (DCBREG),STOWLIST,A)                   0199
*                  REFS(DCBREG,STOWLIST);                          0199
         STOW  (DCBREG),STOWLIST,A
*                RFY R15 RSTD;          /* RESTRICT REGISTER 15      */
*                RETNCODE=R15;          /* SAVE RETURN CODE          */
         LR    RETNCODE,R15                                        0201
*                RFY R15 UNRSTD;        /* RELEASE REGISTER 15       */
*                /* CHECK RETURN CODE                                */
*                IF RETNCODE^=0                                    0203
*                  THEN                 /* STOW FAILED               */
         LTR   RETNCODE,RETNCODE                                   0203
         BNZ   @RT00203                                            0203
*                    GO TO STOWERR;     /* GO ANALYZE FAILURE        */
*                STOWSW='1'B;           /* SIGNAL THAT STOW WAS DONE */
         OI    STOWSW,B'00100000'                                  0205
*                DCBREG=ADDR(BPAMDCB);  /* RESET PTR TO UPDATE DCB   */
         LA    DCBREG,BPAMDCB                                      0206
*                RFY DCBREG UNRSTD;     /* GIVE REGS. BACK TO COMPILR*/
*              END;                     /* NEW MEMBER/BLOCK CREATED  */
*          /* NOW, WRITE THE OLD MEMBER/BLOCK(S) BACK TO THE UADS    */
*          ACIOFL05='1'B;               /* REQUEST WRITE OPERATION   */
@RF00170 L     @10,ACIOPTR(,COMMPTR)                               0209
         OI    ACIOFL05(@10),B'00001000'                           0209
*          CALL WRITE;                  /* INVOKE WRITE PGM -IKJEFA52*/
         BAL   @14,WRITE                                           0210
*          READMNSW='0'B;               /* INDICATE READ ROUTINE   0211
*                                          STORAGE HAS BEEN FREED    */
         NI    READMNSW(COMMPTR),B'11111101'                       0211
*          ADDEDSW='1'B;                /* INDICATE THAT ADD HAS   0212
*                                          ACCOMPLISHED SOMETHING    */
         OI    ADDEDSW,B'10000000'                                 0212
*          /* DEQ THE USERID                                         */
*          GEN (DEQ   (,MINNAME),,MF=(E,DYNDQLST))                 0213
*            REFS(DYNDQLST,MAJNAME,MINNAME);                       0213
         DEQ   (,MINNAME),,MF=(E,DYNDQLST)
*          USRENQSW='0'B;               /* INDICATE THAT USERID DEQ'D*/
         NI    USRENQSW,B'11101111'                                0214
*          /* CHECK FOR 'EXCESSIVE SIZE' CONDITION                   */
*          IF RSIZSW='1'B                                          0215
*            THEN                       /* 'SIZE' EXCEEDED 'MAXSIZE' */
         TM    RSIZSW(COMMPTR),B'00010000'                         0215
         BNO   @RF00215                                            0215
*              DO;                                                 0216
*                RSIZSW='0'B;           /* RESET 'EXCESSIVE SIZE' SW */
         NI    RSIZSW(COMMPTR),B'11101111'                         0217
*                /* PUT OUT A MESSAGE TO THE TERMINAL USER AT THIS   */
*                /* TIME INFORMING HIM THAT SIZE EXCEEDED MAXSIZE    */
*                OUT1LINK=0;            /* INDICATE NO 2ND LEVEL MSG */
         SLR   @10,@10                                             0218
         ST    @10,OUT1LINK                                        0218
*                OUT1SCNT='03'X;        /* 1ST LEVEL MSG SEG COUNT =3*/
         MVI   OUT1SCNT,X'03'                                      0219
*                OUT1SEG1=ADDMSG(27);   /* ADDR OF 'SIZE > MAXSIZE'  */
         L     @10,ADDMSG+104(,MSGBASE)                            0220
         ST    @10,OUT1SEG1                                        0220
*                INSTLN=SIZEL+4;        /* LENGTH OF SIZE SEGMENT    */
         LH    @10,SIZEL(,COMMPTR)                                 0221
         LA    @15,4                                               0221
         ALR   @15,@10                                             0221
         STH   @15,INSTLN                                          0221
*                INSTOF=22;             /* OFFSET FOR TEXT INSERTION */
         MVC   INSTOF(2),@CH00272                                  0222
*                INSTTX(1:SIZEL)=SIZED; /* TEXT (SIZE)               */
         BCTR  @10,0                                               0223
         EX    @10,@SM00342                                        0223
*                OUT1SEG2=ADDR(INSTSEG);/* ADDR OF 'SIZE' SEGMENT    */
         LA    @10,INSTSEG                                         0224
         ST    @10,OUT1SEG2                                        0224
*                USRIDOF=55;            /* OFFSET FOR USERID INSERTN */
         MVC   USRIDOF(2),@CH00273                                 0225
*                OUT1SEG3=ADDR(USRIDSEG); /* ADDR OF USERID SEGMENT  */
         LA    @10,USRIDSEG                                        0226
         ST    @10,OUT1SEG3                                        0226
*                CALL INFOMSG;          /* GO PUT OUT MSG            */
         BAL   @14,INFOMSG                                         0227
*              END;                                                0228
*ADDERCLN: /**********************************************************/
*          /* CTL. PASSED OR DROPPED HERE TO CHECK FOR MORE USERS    */
*          /* CTL. IS RETURNED HERE FROM IKJEFA13 IF THE NODE(S)     */
*          /* SPECIFIED IN THE NODELIST WAS(WERE) NOT FOUND OR IF THE*/
*          /* FIRST LEVEL IN THE DATA SUBFIELD ALREADY EXISTED UNDER */
*          /* THE SPECIFIED NODE.                                    */
*          /**********************************************************/
*          /* ADD PROCESSING IS NOW COMPLETE FOR THIS USERID         */
*          /* SHOULD WE LOOK FOR MORE ?                              */
*          IF USRID(1)='*'                                         0229
*            THEN                       /* MORE USERS MAY BE IN UADS */
@RF00215 DS    0H                                                  0229
ADDERCLN L     @10,NODEPLAD(,COMMPTR)                              0229
         CLI   USRID(@10),C'*'                                     0229
         BNE   @RF00229                                            0229
*              DO;                                                 0230
*USERLEND:     /* CTL. PASSED OR DROPPED HERE TO SAVE NEXT USERID    */
*              /* AND, IF NECESSARY, RESTORE THE I/O PARAMETER LIST  */
*              /* FIRST, SEE IF RESTORATION IS NEEDED                */
*              IF ACIOFL04='0'B                                    0231
*                THEN                   /* A READ RETRY WAS DONE     */
USERLEND L     @10,ACIOPTR(,COMMPTR)                               0231
         TM    ACIOFL04(@10),B'00010000'                           0231
         BNZ   @RF00231                                            0231
*                  DO;                                             0232
*                  ACIOMPTR=ACIOSAVE;   /* RESET TO NEXT USERID      */
         L     @15,ACIOSAVE                                        0233
         ST    @15,ACIOMPTR(,@10)                                  0233
*                  ACIOFLGS=ACIOSAFL;   /* RESTORE FLAGS             */
         MVC   ACIOFLGS(1,@10),ACIOSAFL                            0234
*                  END;                                            0235
*              XBLKUSED='0'B;           /* REINITIALIZE TO 'NOT USED'*/
@RF00231 NI    XBLKUSED(COMMPTR),B'11111110'                       0236
*              BLDLNAME=DIRMNAME;       /* SAVE NEW USERID IN CASE 0237
*                                          OF ERROR                  */
         L     @10,BLDLPTR(,COMMPTR)                               0237
         L     @01,ACIOPTR(,COMMPTR)                               0237
         L     @15,ACIOMPTR(,@01)                                  0237
         MVC   BLDLNAME(8,@10),DIRMNAME(@15)                       0237
*              /* WAS A NEW MEMBERNAME STOWED IN THE DIRECTORY ?     */
*              IF STOWSW='1'B                                      0238
*                THEN                 /* CURRENT DIRECTORY BLOCK IS
*                                          OBSOLETE - MUST UPDATE IT */
         TM    STOWSW,B'00100000'                                  0238
         BNO   @RF00238                                            0238
*                  /* NEXT USERID MAY HAVE BEEN RELOCATED (BY STOW)  */
*                  /* IN THE NEXT DIRECTORY BLOCK.  ALL THREE OF     */
*                  /* THE FOLLOWING CONDITIONS MUST BE MET FOR THIS  */
*                  /* TO HAPPEN.                                     */
*                  IF ACIOMPTR+LENGTH(DIRENTRY)+                   0239
*                   (DIRC&'00011111'B)*2>=                         0239
*                   ADDR(DIRBLOCK)+DIRBLEXT&                       0239
*                   LENGTH(DIRBLOCK)-DIRBLEXT<                     0239
*                   LENGTH(STOWLIST)&                              0239
*                   STOWNAME<BLDLNAME                              0239
*                    THEN               /* NEXT USERID IS NOW IN BEGIN-
*                                          NING OF NEXT DIRECTORY BLK*/
         LA    @14,14                                              0239
         LR    @09,@15                                             0239
         ALR   @09,@14                                             0239
         LA    @08,31                                              0239
         SLR   @07,@07                                             0239
         IC    @07,DIRC(,@15)                                      0239
         NR    @08,@07                                             0239
         ALR   @08,@08                                             0239
         ALR   @09,@08                                             0239
         LH    @08,DIRBLEXT                                        0239
         LA    @15,DIRBLOCK                                        0239
         ALR   @15,@08                                             0239
         CR    @09,@15                                             0239
         BL    @RF00239                                            0239
         LCR   @08,@08                                             0239
         AH    @08,@CH00226                                        0239
         CR    @08,@14                                             0239
         BNL   @RF00239                                            0239
         CLC   STOWNAME(8),BLDLNAME(@10)                           0239
         BNL   @RF00239                                            0239
*                      DO;                                         0240
*                      STOWSW='0'B;     /* RESET STOW SWITCH         */
         NI    STOWSW,B'11011111'                                  0241
*                      GO TO RDDIRECT;  /* READ NEXT DIRECTORY BLOCK
*                                             AND CONTINUE OPERATIONS*/
         B     RDDIRECT                                            0242
*                      END;                                        0243
*                    ELSE               /* NEED TO REREAD CURRENT BLK*/
*                      DO;                                         0244
@RF00239 DS    0H                                                  0245
*                      /* ISSUE BACKSPACE MACRO TO REPOSITION        */
*                      GEN (BSP   DIRDCB)                          0245
*                        REFS(DIRDCB);                             0245
         BSP   DIRDCB
*                      RFY R15 RSTD;    /* RESTRICT RETURN CODE REG. */
*                      RETNCODE=R15;    /* SAVE RETURN CODE          */
         LR    RETNCODE,R15                                        0247
*                      RFY R15 UNRSTD;  /* RELEASE RETURN CODE REG.  */
*                      /* CHECK RETURN CODE                          */
*                      IF RETNCODE^=0                              0249
*                        THEN           /* BSP FAILED                */
         LTR   RETNCODE,RETNCODE                                   0249
         BZ    @RF00249                                            0249
*                          DO;                                     0250
*                          /* SET PARAMETERS FOR PUTLINE MSG         */
*                          OUT1SCNT='01'X; /* 1ST LVL = 1 SEGMT      */
         MVI   OUT1SCNT,X'01'                                      0251
*                          OUT1SEG1=ADDMSG(8); /* UADS NO GOOD       */
         L     @10,ADDMSG+28(,MSGBASE)                             0252
         ST    @10,OUT1SEG1                                        0252
*                          OUT2SCNT='02'X;/* 2ND LEVEL MSG SEG COUNT */
         MVI   OUT2SCNT,X'02'                                      0253
*                          OUT2SEG1=ADDMSG(14); /* BACKSP ERROR      */
         L     @10,ADDMSG+52(,MSGBASE)                             0254
         ST    @10,OUT2SEG1                                        0254
*                          CVD (RETNCODE,DECRTCD);/* CONVERT THE CODE
*                                                    TO  DECIMAL     */
         CVD   RETNCODE,DECRTCD                                    0255
*                          UNPK (BCDRTNCD,DECRTCD(7:8));           0256
         UNPK  BCDRTNCD(2),DECRTCD+6(2)                            0256
*                          ERRRTNLN=6;  /* SET SEGMENT LENGTH        */
         MVC   ERRRTNLN(2),@CH00047                                0257
*                          ERRRTNOF=30; /* SET SEGMENT OFFSET        */
         MVC   ERRRTNOF(2),@CH00281                                0258
*                          OUT2SEG2=ADDR(ERRRTNSG);/* 3RD SEG ADR    */
         LA    @10,ERRRTNSG                                        0259
         ST    @10,OUT2SEG2                                        0259
*                          SIGN=SIGN'F0'X;/* RESET THE SIGN FIELD   */
         OI    SIGN,X'F0'                                          0260
*                          GOTO ERRMSG; /* GO PUT OUT MSG & LEAVE    */
         B     ERRMSG                                              0261
*                          END;                                    0262
*                      ACIOFL06='1'B;   /* PREPARE FOR READ DIRECTORY
*                                            BLOCK ONLY              */
@RF00249 L     @10,ACIOPTR(,COMMPTR)                               0263
         OI    ACIOFL06(@10),B'00000100'                           0263
*                      CALL READ;       /* INVOKE READ SUBROUTINE    */
         BAL   @14,READ                                            0264
*                      ACIOFL06='0'B;   /* TURN OFF 'DIRECTORY ONLY  */
         L     @10,ACIOPTR(,COMMPTR)                               0265
         NI    ACIOFL06(@10),B'11111011'                           0265
*                      /* DOES MEMBER NAME PTR NEED TO BE BUMPED     */
*                      IF STOWNAME<BLDLNAME                        0266
*                        THEN           /* YES - NEXT USERID WAS BMPD*/
         L     @01,BLDLPTR(,COMMPTR)                               0266
         CLC   STOWNAME(8),BLDLNAME(@01)                           0266
         BNL   @RF00266                                            0266
*                          /* STEP PTR BY LENGTH OF NEW ENTRY        */
*                          ACIOMPTR=ACIOMPTR+LENGTH(DIRENTRY);     0267
         LA    @15,14                                              0267
         AL    @15,ACIOMPTR(,@10)                                  0267
         ST    @15,ACIOMPTR(,@10)                                  0267
*                      STOWSW='0'B;     /* RESET STOW SWITCH         */
@RF00266 NI    STOWSW,B'11011111'                                  0268
*                      END;                                        0269
*              GO TO USERLOOP;          /* LOOP TO PROCESS NEXT USER */
         B     USERLOOP                                            0270
*              END;                                                0271
*FINDTEST: /**********************************************************/
*          /* CTL. PASSED OR DROPPED HERE TO SEE IF                  */
*          /* THE ADD PROCESSOR FOUND ANY NODES TO AUGMENT.          */
*          /**********************************************************/
*          IF NONODESW='0'B & FINDEXSW='1'B                        0272
*            THEN                       /* NEVER FOUND ANY NODES AND
*                                          FINDNODE ROUTINE HAS BEEN
*                                          EXECUTED                  */
@RF00229 DS    0H                                                  0272
FINDTEST TM    FINDEXSW(COMMPTR),B'00000100'                       0272
         BNO   @RF00272                                            0272
         TM    NONODESW(COMMPTR),B'00001000'                       0272
         BNZ   @RF00272                                            0272
*              DO;                                                 0273
*                /* SET PARAMETERS FOR PUTLINE MESSAGE               */
*                OUT1LINK=0;            /* INDICATE NO 2ND LEVEL MSG */
         SLR   @10,@10                                             0274
         ST    @10,OUT1LINK                                        0274
*                OUT1SCNT='03'X;        /* 1ST LEVEL MSG SEG COUNT =3*/
         MVI   OUT1SCNT,X'03'                                      0275
*                OUT1SEG1=ADDMSG(17);   /* ADDR OF MISSING ITEM MSG  */
         L     @10,ADDMSG+64(,MSGBASE)                             0276
         ST    @10,OUT1SEG1                                        0276
*                INSTOF=10;             /* OFFSET FOR TEXT INSERTION */
         MVC   INSTOF(2),@CH00258                                  0277
*                OUT1SEG3=ADDR(INSTSEG);/* POINT TO INSERT SEGMENT   */
         LA    @10,INSTSEG                                         0278
         ST    @10,OUT1SEG3                                        0278
*                /* CHECK FOR ACCOUNT NUMBER                         */
*                IF NUMOFLVL=3                                     0279
*                  THEN                 /* LAST NODE ITEM WAS ACCT NO*/
         CLI   NUMOFLVL(COMMPTR),3                                 0279
         BNE   @RF00279                                            0279
*                    /* MAKE SURE IT'S NOT AN '*'                    */
*                    IF ACCTNO(1:2)^='* '                          0280
*                      THEN             /* ACCT NUMBER NOT AN '*'    */
         L     @10,NODEPLAD(,COMMPTR)                              0280
         CLC   ACCTNO(2,@10),@CC00285                              0280
         BE    @RF00280                                            0280
*                        DO;            /* BUILD ACCT-MISSING MSG    */
*                        OUT1SEG2=ADDMSG(22);/* 'ACCOUNT NUMBER' PRE */
         L     @15,ADDMSG+84(,MSGBASE)                             0282
         ST    @15,OUT1SEG2                                        0282
*                        INSTLN=ACTLEN+4;/* LENGTH OF ACCT NO SEG    */
         LA    @05,4                                               0283
         SLR   @15,@15                                             0283
         IC    @15,ACTLEN(,@10)                                    0283
         ALR   @05,@15                                             0283
         STH   @05,INSTLN                                          0283
*                        INSTTX=ACCTNO; /* ACCTNO FROM NODELIST TABLE*/
         MVC   INSTTX(40),ACCTNO(@10)                              0284
*                        GOTO ERRMSG;   /* GO PUT OUT MESSAGE & LEAVE*/
         B     ERRMSG                                              0285
*                        END;                                      0286
*                /* MAKE SURE PASSWORD IS NOT AN '*'                 */
*                IF PASSWD(1)^='*'                                 0287
*                  THEN                 /* ENTRIES SEARCHED          */
@RF00280 DS    0H                                                  0287
@RF00279 L     @10,NODEPLAD(,COMMPTR)                              0287
         CLI   PASSWD(@10),C'*'                                    0287
         BE    @RF00287                                            0287
*                    DO;                                           0288
*                    OUT1SEG2=ADDMSG(21); /* 'PASSWORD' PREFIX       */
         L     @15,ADDMSG+80(,MSGBASE)                             0289
         ST    @15,OUT1SEG2                                        0289
*                    INSTLN=12;         /* LENGTH OF PASSWORD SEGMENT*/
         MVC   INSTLN(2),@CH00055                                  0290
*                    INSTTX(1:8)=PASSWD;/* PASSWD FROM NODELIST TABLE*/
         MVC   INSTTX(8),PASSWD(@10)                               0291
*                    GOTO ERRMSG;       /* GO PUT OUT MESSAGE & LEAVE*/
         B     ERRMSG                                              0292
*                    END;                                          0293
*              END;                                                0294
@RF00287 DS    0H                                                  0295
*          /* SEE IF ANY USEFUL WORK HAS BEEN ACCOMPLISHED           */
*          IF ADDEDSW='1'B                                         0295
*            THEN                       /* YES - SOMETHING USEFUL DON*/
@RF00272 TM    ADDEDSW,B'10000000'                                 0295
         BNO   @RF00295                                            0295
*              DO;                                                 0296
*                /* PUT OUT MESSAGE SAYING ADD HAS COMPLETED         */
*                OUT1LINK=0;            /* INDICATE NO 2ND LEVEL MSG */
         SLR   @10,@10                                             0297
         ST    @10,OUT1LINK                                        0297
*                OUT1SCNT='01'X;        /* 1ST LEVEL MSG SEG COUNT =1*/
         MVI   OUT1SCNT,X'01'                                      0298
*                OUT1SEG1=ADDMSG(1);    /* PTR TO 'ADDED' MESSAGE    */
         L     @10,ADDMSG(,MSGBASE)                                0299
         ST    @10,OUT1SEG1                                        0299
*                CALL INFOMSG;          /* GO PUT OUT MSG            */
         BAL   @14,INFOMSG                                         0300
*              END;                                                0301
*            ELSE                       /* NO WORK ACCOMPLISHED      */
*              ERRFLG = '1'B;           /* TURN ON ERROR FLAG        */
         B     @RC00295                                            0302
@RF00295 OI    ERRFLG(COMMPTR),B'01000000'                         0302
*          GOTO CLEANUP1;               /* GO TO CLEANUP & RETURN    */
         B     CLEANUP1                                            0303
*CMDSYSER: /**********************************************************/
*          /* CONTROL PASSED HERE ON AN UNUSUAL RETURN CODE FROM A   */
*          /* SERVICE ROUTINE                                        */
*          /**********************************************************/
*          OUT1SCNT='01'X;              /* 1ST LEVEL MSG SEG COUNT =1*/
CMDSYSER MVI   OUT1SCNT,X'01'                                      0304
*          OUT1SEG1=ADDMSG(5);          /* ADDR OF 'CMD SYSTM ERROR' */
         L     @10,ADDMSG+16(,MSGBASE)                             0305
         ST    @10,OUT1SEG1                                        0305
*          OUT2SCNT='03'X;              /* 2ND LEVEL MSG SEG COUNT =3*/
         MVI   OUT2SCNT,X'03'                                      0306
*          OUT2SEG1=ADDMSG(6);          /* BASE SEGMT= 'ERROR CODE'  */
         L     @10,ADDMSG+20(,MSGBASE)                             0307
         ST    @10,OUT2SEG1                                        0307
*          CVD (RETNCODE,DECRTCD);      /* CONVERT THE RETURN CODE TO
*                                          DECIMAL                   */
         CVD   RETNCODE,DECRTCD                                    0308
*          UNPK (BCDRTNCD,DECRTCD(7:8));/*UNPACK IT INTO THE MESSAGE */
         UNPK  BCDRTNCD(2),DECRTCD+6(2)                            0309
*          ERRRTNLN=6;                  /* SET SEGMENT LENGTH        */
         MVC   ERRRTNLN(2),@CH00047                                0310
*          ERRRTNOF=22;                 /* SET SEGMENT OFFSET        */
         MVC   ERRRTNOF(2),@CH00272                                0311
*          OUT2SEG3=ADDR(ERRRTNSG);     /* 3RD SEG ADR TO OUT LN DESC*/
         LA    @10,ERRRTNSG                                        0312
         ST    @10,OUT2SEG3                                        0312
*          SIGN=SIGN'F0'X;             /* RESET THE SIGN FIELD      */
         OI    SIGN,X'F0'                                          0313
*          /* GO TO ERROR TERMINATION                                */
*ERRMSG:   /**********************************************************/
*          /* ERRMSG: CONTROL PASSED HERE TO OUTPUT AN ERROR MESSAGE */
*          /* AND SET THE ERROR FLAG                                 */
*          /**********************************************************/
*          ERRFLG='1'B;                 /* TURN ON ERROR FLAG        */
ERRMSG   OI    ERRFLG(COMMPTR),B'01000000'                         0314
*          RFY R1 RSTD;                 /* RESTRICT PARAMETER POINTER*/
*          R1=IOPLPTR;                  /* PARAMETER LIST ADDR TO R1 */
         L     @10,IOPLPTR(,COMMPTR)                               0316
         LR    R1,@10                                              0316
*          PTPBOPUT=ADDR(OUTLNDS);      /* POINT TO LINE DESCRIPTOR  */
         L     @10,PTPBPTR(,@10)                                   0317
         LA    @07,OUTLNDS                                         0317
         ST    @07,PTPBOPUT(,@10)                                  0317
*          /* ISSUE OS/360 PUTLINE MACRO TO WRITE THE MESSAGE        */
*          GEN (PUTLINE ,MF=(E,(1)))                               0318
*            REFS(R1);                                             0318
         PUTLINE ,MF=(E,(1))
*          RFY R1 UNRSTD;               /* RELEASE PARAMETER POINTER */
*          RFY R15 RSTD;                /* RESTRICT RETURN CODE REG  */
*          RETNCODE=R15;                /* SAVE RETURN CODE          */
         LR    RETNCODE,R15                                        0321
*          RFY R15 UNRSTD;              /* RELEASE RETURN CODE REG   */
*          IF RETNCODE^=0               /* WAS PUTLINE SUCCESSFUL    */
*            THEN                       /* NO,                       */
         LTR   RETNCODE,RETNCODE                                   0323
         BZ    @RF00323                                            0323
*              PUTERR='1'B;             /* TURN ON PUTLINE ERROR FLAG*/
         OI    PUTERR(COMMPTR),B'00100000'                         0324
*CLEANUP1: /**********************************************************/
*          /* CTL. PASSED OR DROPPED HERE TO CLEAN UP AND EXIT       */
*          /* IS THERE A READ SUBROUTINE BUFFER TO BE RELEASED ?     */
*          /**********************************************************/
*          IF READMNSW='1'B                                        0325
*            THEN                       /* YES - USE WRITE TO FREE IT*/
@RF00323 DS    0H                                                  0325
CLEANUP1 TM    READMNSW(COMMPTR),B'00000010'                       0325
         BNO   @RF00325                                            0325
*              DO;                                                 0326
*                ACIOFL05='0'B;         /* MAKE CERTAIN THAT NO    0327
*                                          WRITING TAKES PLACE       */
         L     @10,ACIOPTR(,COMMPTR)                               0327
         NI    ACIOFL05(@10),B'11110111'                           0327
*                CALL WRITE;            /* SCRATCH READ ROUTINE STG  */
         BAL   @14,WRITE                                           0328
*                READMNSW='0'B;         /* RESET READ WKAREA GOTTEN  */
         NI    READMNSW(COMMPTR),B'11111101'                       0329
*              END;                                                0330
*          RFY (DCBREG) RSTD;           /* RESERVE REG. FOR DCB BASE */
@RF00325 DS    0H                                                  0332
*          DCBREG=ADDR(BPAMDCB);        /* POINT TO UPDAT MODE DCB   */
         LA    DCBREG,BPAMDCB                                      0332
*          /* IS THE BPAM 'UPDAT' MODE DCB OPEN ?                    */
*          IF DCBOFLGS(4)='1'B                                     0333
*            THEN                       /* YES - UPDAT DCB OPEN      */
         TM    DCBOFLGS,B'00010000'                                0333
         BNO   @RF00333                                            0333
*              /* ISSUE OS/360 CLOSE MACRO TO CLOSE IT               */
*              GEN (CLOSE ((DCBREG),REREAD),MF=(E,DYNOPLST))       0334
*                REFS(DCBREG,DYNOPLST);                            0334
         CLOSE ((DCBREG),REREAD),MF=(E,DYNOPLST)
*          /* IS THERE A DIRECTORY WORK AREA TO BE CHECKED ?         */
*          IF DIRMNSW='1'B                                         0335
*            THEN                       /* DIRECTORY WORK AREA EXISTS*/
@RF00333 TM    DIRMNSW,B'01000000'                                 0335
         BNO   @RF00335                                            0335
*              DO;                                                 0336
*              DCBREG=ADDR(DIRDCB);     /* POINT TO DIRECTORY DCB    */
         LA    DCBREG,DIRDCB                                       0337
*              /* IS THE BSAM (DIRECTORY) DCB OPEN ?                 */
*              IF DCBOFLGS(4)='1'B                                 0338
*                THEN                   /* YES - BSAM DCB OPEN       */
         TM    DCBOFLGS,B'00010000'                                0338
         BNO   @RF00338                                            0338
*                  /* ISSUE OS/360 CLOSE MACRO TO CLOSE IT           */
*                  GEN (CLOSE ((DCBREG),REREAD),MF=(E,DYNOPLST))   0339
*                    REFS(DCBREG,DYNOPLST);                        0339
         CLOSE ((DCBREG),REREAD),MF=(E,DYNOPLST)
*                RFY (DCBREG) UNRSTD;   /* GIVE REG. BACK TO COMPILER*/
@RF00338 DS    0H                                                  0341
*              END;                                                0341
*          /* IS THE USERID ENQ'D ON ?                               */
*          IF USRENQSW='1'B                                        0342
*            THEN                       /* YES - USERID ENQ'D ON     */
@RF00335 TM    USRENQSW,B'00010000'                                0342
         BNO   @RF00342                                            0342
*              DO;                                                 0343
*              GEN (DEQ   (,MINNAME),,MF=(E,DYNDQLST))             0344
*                REFS(MAJNAME,MINNAME);                            0344
         DEQ   (,MINNAME),,MF=(E,DYNDQLST)
*              USRENQSW='0'B;           /* SIGNAL THAT USERID IS DEQD*/
         NI    USRENQSW,B'11101111'                                0345
*              END;                                                0346
*           RETURN;                     /* RETURN TO IKJEFA10        */
@EL00001 L     @13,4(,@13)                                         0347
@EF00001 L     @00,@SIZDATD                                        0347
         LR    @01,@11                                             0347
         FREEMAIN R,LV=(0),A=(1)
@ER00001 LM    @14,@12,12(@13)                                     0347
         BR    @14                                                 0347
*STOWERR:  /**********************************************************/
*          /* CONTROL PASSED HERE ON A NON-ZERO RETURN CODE FROM STOW*/
*          /**********************************************************/
*          OUT1SCNT='01'X;              /* 1ST LEVEL MSG SEG COUNT =1*/
STOWERR  MVI   OUT1SCNT,X'01'                                      0348
*          OUT1SEG1=ADDMSG(8);          /* ADDR OF UADS NO GOOD MSG  */
         L     @10,ADDMSG+28(,MSGBASE)                             0349
         ST    @10,OUT1SEG1                                        0349
*          OUT2SCNT='01'X;              /* ASSUME 1 SEGMT TO 2ND LVL */
         MVI   OUT2SCNT,X'01'                                      0350
*          /* IS THE DIRECTORY FULL ?                                */
*          IF RETNCODE=12                                          0351
*            THEN                       /* YES - DIRECTORY FULL      */
         CH    RETNCODE,@CH00055                                   0351
         BNE   @RF00351                                            0351
*              OUT2SEG1=ADDMSG(13);     /* ADDR OF 'NO DIRECTRY SPACE*/
         L     @10,ADDMSG+48(,MSGBASE)                             0352
         ST    @10,OUT2SEG1                                        0352
*            ELSE                                                  0353
*              IF RETNCODE=4                                       0353
*                THEN                   /* RETURN IS DUPLICATE USERID *
         B     @RC00351                                            0353
@RF00351 CH    RETNCODE,@CH00073                                   0353
         BNE   @RF00353                                            0353
*                  DO;                                             0354
*                  OUT1SEG1=ADDMSG(5);  /* CHANGE 1ST LEVEL TO 'COMMAND
*                                          SYSTEM ERROR'             */
         L     @10,ADDMSG+16(,MSGBASE)                             0355
         ST    @10,OUT1SEG1                                        0355
*                  OUT2SCNT='02'X;      /* 2ND LEVEL MSG SEG COUNT =2*/
         MVI   OUT2SCNT,X'02'                                      0356
*                  OUT2SEG1=ADDMSG(7);  /* ADDR OF 'DUPLICATE USERID'*/
         L     @10,ADDMSG+24(,MSGBASE)                             0357
         ST    @10,OUT2SEG1                                        0357
*                  USRIDLN=12;          /* SET LENGTH OF SEGMENT     */
         MVC   USRIDLN(2),@CH00055                                 0358
*                  USRIDOF=27;          /* OFFSET FOR INSERTION      */
         MVC   USRIDOF(2),@CH00271                                 0359
*                  USRIDI=STOWNAME;     /* GET MEMBER NAME           */
         MVC   USRIDI(8),STOWNAME                                  0360
*                  OUT2SEG2=ADDR(USRIDSEG); /* USERID SEGMENT ADDR   */
         LA    @10,USRIDSEG                                        0361
         ST    @10,OUT2SEG2                                        0361
*                  END;                                            0362
*          /* WAS THE RETURN CODE 'I/O ERROR' (16) OR GREATER ?      */
*          IF RETNCODE>12                                          0363
*            THEN                       /* YES - STOW I/O ERROR      */
@RF00353 DS    0H                                                  0363
@RC00351 CH    RETNCODE,@CH00055                                   0363
         BNH   @RF00363                                            0363
*                OUT2SEG1=ADDMSG(11);   /* ADDR OF 'STOW I/O ERROR'  */
         L     @10,ADDMSG+40(,MSGBASE)                             0364
         ST    @10,OUT2SEG1                                        0364
*          GOTO ERRMSG;                 /* GO PUT OUT MESSAGE & LEAVE*/
         B     ERRMSG                                              0365
*READERR:  /**********************************************************/
*          /* CONTROL PASSED HERE ON A READ ROUTINE ERROR            */
*          /**********************************************************/
*          /* CHECK FOR DIRECTORY 'END-OF-FILE' INDICATION           */
*          IF READRTCD=24                                          0366
*            THEN                       /* 'END-OF-FILE' IN DIRECTORY*/
READERR  L     @10,READRTCD                                        0366
         CH    @10,@CH00062                                        0366
         BE    @RT00366                                            0366
*              GO TO FINDTEST;          /* GO CK FOR USEFUL WORK DONE*/
*          /* WAS IT A BLDL I/O ERROR ?                              */
*          IF READRTCD=8                                           0368
*            THEN                       /* BLDL I/O ERROR            */
         CH    @10,@CH00040                                        0368
         BNE   @RF00368                                            0368
*              DO;                                                 0369
*                /* SET PARAMETERS FOR PUTLINE MESSAGE               */
*                OUT1SCNT='01'X;        /* 1ST LEVEL MSG SEG COUNT =1*/
         MVI   OUT1SCNT,X'01'                                      0370
*                OUT1SEG1=ADDMSG(8);    /* ADDR OF UADS NO GOOD MSG  */
         L     @10,ADDMSG+28(,MSGBASE)                             0371
         ST    @10,OUT1SEG1                                        0371
*                OUT2SCNT='01'X;        /* 2ND LEVEL MSG SEG COUNT =1*/
         MVI   OUT2SCNT,X'01'                                      0372
*                OUT2SEG1=ADDMSG(10);   /* 2ND LEVEL = 'BLDL I/O ERR'*/
         L     @10,ADDMSG+36(,MSGBASE)                             0373
         ST    @10,OUT2SEG1                                        0373
*                GOTO ERRMSG;           /* GO PUT OUT MESSAGE & LEAVE*/
         B     ERRMSG                                              0374
*              END;                                                0375
*          /* WAS IT AN 'INSUFFICIENT SPACE' PROBLEM ?               */
*          IF READRTCD=12                                          0376
*            THEN                       /* READ HAD A GETMAIN FAILURE*/
@RF00368 CLC   READRTCD(4),@CF00055                                0376
         BNE   @RF00376                                            0376
*              /* CTL. PASSED HERE TO ATTEMPT RECOVERY FROM GETMAIN  */
*              /* FAILURES IN AUGMENT MODE BY REDUCING READ REQUEST  */
*RDGETERR:     DO;                                                 0377
RDGETERR DS    0H                                                  0378
*              /* SET PARAMETERS FOR PUTLINE MESSAGE                 */
*              OUT1LINK=0;              /* INDICATE NO 2ND LEVEL MSG */
         SLR   @10,@10                                             0378
         ST    @10,OUT1LINK                                        0378
*              OUT1SEG1=ADDMSG(2);      /* PTR TO 'NO SPACE' MSG     */
         L     @15,ADDMSG+4(,MSGBASE)                              0379
         ST    @15,OUT1SEG1                                        0379
*              IF ACIOLINK=0            /* DID BLDL WORK?            */
*                THEN                   /* NO,                       */
         L     @01,ACIOPTR(,COMMPTR)                               0380
         C     @10,ACIOLINK(,@01)                                  0380
         BNE   @RF00380                                            0380
*                  DO;                                             0381
*                  OUT1SCNT='02'X;      /* 1ST LEVEL MSG SEG COUNT=2 */
         MVI   OUT1SCNT,X'02'                                      0382
*                  OUT1SEG2=ADDMSG(4);  /* 2ND SEGMT='FOR USERID     */
         L     @10,ADDMSG+12(,MSGBASE)                             0383
         ST    @10,OUT1SEG2                                        0383
*                  GOTO ERRMSG;         /* GO PUT OUT MESSAGE & LEAVE*/
         B     ERRMSG                                              0384
*                  END;                                            0385
*              OUT1SCNT='03'X;          /* 1ST LEVEL MSG SEG COUNT=3 */
@RF00380 MVI   OUT1SCNT,X'03'                                      0386
*              OUT1SEG2=ADDMSG(4);      /* 2ND SEGMT='FOR USERID     */
         L     @10,ADDMSG+12(,MSGBASE)                             0387
         ST    @10,OUT1SEG2                                        0387
*              USRIDOF=37;              /* OFFSET FOR USERID INSERTN */
         MVC   USRIDOF(2),@CH00267                                 0388
*              OUT1SEG3=ADDR(USRIDSEG); /* 3RD SEG = USERID          */
         LA    @10,USRIDSEG                                        0389
         ST    @10,OUT1SEG3                                        0389
*              IF USRID(1)^='*'         /* WAS USERID SPECIFIED?     */
*                THEN                   /* YES - USERID IS SPECIFIC  */
         L     @10,NODEPLAD(,COMMPTR)                              0390
         CLI   USRID(@10),C'*'                                     0390
         BE    @RF00390                                            0390
*                  IF ACIOFL04='0'B     /* WAS EXTRA BLOCK REQUESTED?*/
*                    THEN               /* NO - REQUEST ALREADY    0391
*                                          MINIMIZED                 */
         L     @10,ACIOPTR(,COMMPTR)                               0391
         TM    ACIOFL04(@10),B'00010000'                           0391
         BZ    @RT00391                                            0391
*                      GOTO ERRMSG;     /* GO PUT OUT MESSAGE & LEAVE*/
*                    ELSE               /* YES - GETMAIN REQUEST CAN
*                                          BE REDUCED                */
*                      DO;                                         0393
*                      ACIOFL04='0'B;   /* TURN OFF EXTRA BLK REQ FLG*/
         NI    ACIOFL04(@10),B'11101111'                           0394
*                      GO TO USERLOOP;  /* LOOP TO RETRY READ        */
         B     USERLOOP                                            0395
*                      END;                                        0396
*                ELSE                   /* USERID = '*'              */
*                  IF ACIOFL04='0'B     /* WAS EXTRA BLOCK REQUESTED?*/
*                    THEN               /* NO - REQUEST MINIMIZED    */
@RF00390 L     @10,ACIOPTR(,COMMPTR)                               0397
         TM    ACIOFL04(@10),B'00010000'                           0397
         BNZ   @RF00397                                            0397
*                      DO;                                         0398
*                      CALL INFOMSG;    /* GO PUT OUT MSG            */
         BAL   @14,INFOMSG                                         0399
*                      GOTO USERLEND;   /* GO TO SCAN NEXT ITEM      */
         B     USERLEND                                            0400
*                      END;                                        0401
*                    ELSE               /* EXTRA BLOCK REQUESTED - 0402
*                                          GETMAIN REQ CAN BE REDUCED*/
*                      DO;                                         0402
@RF00397 DS    0H                                                  0403
*                      ACIOSAVE=ACIOMPTR;   /* SAVE MARKER TO NEXT 0403
*                                              USERID                */
         L     @10,ACIOPTR(,COMMPTR)                               0403
         L     @15,ACIOMPTR(,@10)                                  0403
         ST    @15,ACIOSAVE                                        0403
*                      ACIOSAFL=ACIOFLGS;   /* ALSO SAVE FLAGS       */
         MVC   ACIOSAFL(1),ACIOFLGS(@10)                           0404
*                      ACIOMPTR=ADDR(BLDLNAME); /* POINT TO SAVED  0405
*                                                    CURRENT USERID  */
         L     @01,BLDLPTR(,COMMPTR)                               0405
         LA    @15,BLDLNAME(,@01)                                  0405
         ST    @15,ACIOMPTR(,@10)                                  0405
*                      ACIOFLGS='00'X;   /* SET SUBR FLAGS FOR:    0406
*                                           A) LOGICAL MEMBER I/O  0406
*                                           B) 2ND WORD=MEMBERNAME PTR
*                                           C) 3RD WORD NOT USED   0406
*                                           D) NO EXTRA BLOCK        */
         MVI   ACIOFLGS(@10),X'00'                                 0406
*                      GO TO USERLOOP;  /* BRANCH TO TOP TO RETRY    */
         B     USERLOOP                                            0407
*                      END;                                        0408
*              END;                                                0409
*          ERRFLG='1'B;                 /* TURN ON ERROR FLAG        */
@RF00376 OI    ERRFLG(COMMPTR),B'01000000'                         0410
*          /* MESSAGE ALREADY PUT OUT FOR I/O ERROR BY READ ROUTINE? */
*          IF READRTCD=20                                          0411
*            THEN                       /* YES,                      */
         L     @10,READRTCD                                        0411
         CH    @10,@CH00257                                        0411
         BE    @RT00411                                            0411
*              GOTO CLEANUP1;           /* GO CLEAN UP AND EXIT      */
*          /* MUST BE ERROR CODE 28 OR INVALID CODE                  */
*          /* SET PARAMETERS FOR PUTLINE MESSAGE                     */
*          RETNCODE=READRTCD;           /* GET READ RETURN CODE      */
         LR    RETNCODE,@10                                        0413
*          OUT2SEG2=ADDMSG(25);         /* ADDR OF 'READ' PREFIX     */
         L     @10,ADDMSG+96(,MSGBASE)                             0414
         ST    @10,OUT2SEG2                                        0414
*          GOTO CMDSYSER;               /* GO PUT OUT MESSAGE & LEAVE*/
         B     CMDSYSER                                            0415
*INFOMSG:  /**********************************************************/
*          /* CTL. PASSED HERE TO OUTPUT AN INFORMATIONAL MESSAGE    */
*          /**********************************************************/
*          PROC;                                                   0416
INFOMSG  STM   @14,@12,@SA00002                                    0416
*          RFY R1 RSTD;                 /* RESTRICT PARAMETER POINTER*/
*          R1=IOPLPTR;                  /* PARAMETER LIST ADDR TO R1 */
         L     @10,IOPLPTR(,COMMPTR)                               0418
         LR    R1,@10                                              0418
*          PTPBOPUT=ADDR(OUTLNDS);      /* POINT TO LINE DESCRIPTOR  */
         L     @10,PTPBPTR(,@10)                                   0419
         LA    @07,OUTLNDS                                         0419
         ST    @07,PTPBOPUT(,@10)                                  0419
*          /* ISSUE OS/360 PUTLINE MACRO TO WRITE THE MESSAGE        */
*          GEN (PUTLINE ,MF=(E,(1)))                               0420
*            REFS(R1);                                             0420
         PUTLINE ,MF=(E,(1))
*          RFY R1 UNRSTD;               /* RELEASE PARAMETER POINTER */
*          RFY R15 RSTD;                /* RESTRICT RETURN CODE REG  */
*          RETNCODE=R15;                /* SAVE RETURN CODE          */
         LR    RETNCODE,R15                                        0423
*          RFY R15 UNRSTD;              /* RELEASE RETURN CODE REG   */
*          /* CHECK RETURN CODE                                      */
*          IF RETNCODE^=0                                          0425
*            THEN                       /* PUTLINE EXCEPTION         */
         LTR   RETNCODE,RETNCODE                                   0425
         BZ    @RF00425                                            0425
*               DO;                                                0426
*                 ERRFLG='1'B;          /* TURN ON ERROR FLAG        */
*                 PUTERR='1'B;          /* TURN ON PUTLINE ERROR FLAG*/
         OI    ERRFLG(COMMPTR),B'01100000'                         0428
*                 RETURN TO CLEANUP1;   /* GO TO TERMINATION         */
         LA    @14,CLEANUP1                                        0429
         LM    @15,@12,@SA00002+4                                  0429
         BR    @14                                                 0429
*               END;                                               0430
*          OUT1LINK=ADDR(OUTLD2);       /* RE-INITIALIZE LINKAGE TO
*                                          ASSUME 2 MESSAGE LEVELS   */
@RF00425 LA    @10,OUTLD2                                          0431
         ST    @10,OUT1LINK                                        0431
*          END INFOMSG;                                            0432
@EL00002 DS    0H                                                  0432
@EF00002 DS    0H                                                  0432
@ER00002 LM    @14,@12,@SA00002                                    0432
         BR    @14                                                 0432
*READ:     /**********************************************************/
*          /* CTL. PASSED HERE TO CALL THE ACCOUNT/READ ROUTINE      */
*          /**********************************************************/
*          PROC;                                                   0433
READ     STM   @14,@12,@SA00003                                    0433
*          RFY R1 RSTD;                 /* RESTRICT PARAMETER POINTER*/
*          R1=ACIOPTR;                  /* PARAMETER LIST ADDR TO R1 */
         L     R1,ACIOPTR(,COMMPTR)                                0435
*          CALL IKJEFA51;               /* INVOKE READ PGM - IKJEFA51*/
         L     @15,@CV00078                                        0436
         BALR  @14,@15                                             0436
*          RFY R1 UNRSTD;               /* RELEASE PARAMETER POINTER */
*          RFY R15 RSTD;                /* RESTRICT RETURN CODE REG. */
*          IF R15^=0                    /* CHECK RETURN CODE         */
*            THEN                       /* READ I/O ERROR            */
         LTR   R15,R15                                             0439
         BZ    @RF00439                                            0439
*              DO;                                                 0440
*              READRTCD=R15;            /* SAVE RETURN CODE          */
         ST    R15,READRTCD                                        0441
*              RETURN TO READERR;       /* GO TO HANDLE AND EXIT     */
         LA    @14,READERR                                         0442
         LM    @15,@12,@SA00003+4                                  0442
         BR    @14                                                 0442
*              END;                                                0443
*          RFY R15 UNRSTD;              /* RELEASE RETURN CODE REG.  */
*          END READ;                                               0445
@EL00003 DS    0H                                                  0445
@EF00003 DS    0H                                                  0445
@ER00003 LM    @14,@12,@SA00003                                    0445
         BR    @14                                                 0445
*WRITE:    /**********************************************************/
*          /* CTL. PASSED HERE TO CALL THE ACCOUNT/WRITE ROUTINE     */
*          /**********************************************************/
*          PROC;                                                   0446
WRITE    STM   @14,@12,@SA00004                                    0446
*          RFY R1 RSTD;                 /* RESTRICT PARAMETER POINTER*/
*          R1=ACIOPTR;                  /* PARAMETER BLK ADDR TO R1  */
         L     R1,ACIOPTR(,COMMPTR)                                0448
*          CALL IKJEFA52;               /* INVOKE WRITE PGM -IKJEFA52*/
         L     @15,@CV00079                                        0449
         BALR  @14,@15                                             0449
*          RFY R1 UNRSTD;               /* RELEASE PARAMETER POINTER */
*          RFY R15 RSTD;                /* RESTRICT RETURN CODE REG  */
*          RETNCODE=R15;                /* SAVE RETURN CODE          */
         LR    RETNCODE,R15                                        0452
*          RFY R15 UNRSTD;              /* RELEASE RETURN CODE REG   */
*          /* CHECK RETURN CODE                                      */
*          IF RETNCODE^=0                                          0454
*            THEN                       /* WRITE ROUTINE FAILED      */
         LTR   RETNCODE,RETNCODE                                   0454
         BZ    @RF00454                                            0454
*               DO;                                                0455
*                 ERRFLG='1'B;          /* TURN ON ERROR FLAG        */
         OI    ERRFLG(COMMPTR),B'01000000'                         0456
*                 RETURN TO CLEANUP1;   /* GO TO TERMINATION         */
         LA    @14,CLEANUP1                                        0457
         LM    @15,@12,@SA00004+4                                  0457
         BR    @14                                                 0457
*               END;                                               0458
*          END WRITE;                                              0459
@EL00004 DS    0H                                                  0459
@EF00004 DS    0H                                                  0459
@ER00004 LM    @14,@12,@SA00004                                    0459
         BR    @14                                                 0459
*          END IKJEFA12                                            0460
*/* THE FOLLOWING INCLUDE STATEMENTS WERE FOUND IN THIS PROGRAM.      *
*/*%INCLUDE SYSLIB  (IKJEFUAD)                                        *
*/*%INCLUDE SYSLIB  (IKJIOPL )                                        *
*/*%INCLUDE SYSLIB  (IKJPTPB )                                        *
*;                                                                 0460
@DATA    DS    0H
@CH00073 DC    H'4'
@CH00047 DC    H'6'
@CH00040 DC    H'8'
@CH00258 DC    H'10'
@CH00257 DC    H'20'
@CH00272 DC    H'22'
@CH00062 DC    H'24'
@CH00247 DC    H'25'
@CH00271 DC    H'27'
@CH00281 DC    H'30'
@CH00266 DC    H'35'
@CH00267 DC    H'37'
@CH00273 DC    H'55'
@CH00226 DC    H'256'
@SM00322 MVC   DYNLFORM(0),INLINLFM
@SC00324 CLC   DATAITEM(0,ARGPTR),DATAITEM(CURRPTR)
@SM00326 MVC   INSTTX(0),DATAITEM(CURRPTR)
@SM00330 MVC   USERNAME(0),BLDLNAME(@15)
@SM00332 MVC   USRIDI(0),USERNAME
@SM00342 MVC   INSTTX(0),SIZED(COMMPTR)
@DATD    DSECT
         DS    0F
@SA00001 DS    18F
@SA00002 DS    15F
@SA00004 DS    0F
@SA00003 DS    0F
         DS    15F
IKJEFA12 CSECT
         DS    0F
@CF00055 DC    F'12'
@CH00055 EQU   @CF00055+2
@DATD    DSECT
         DS    0D
ACIOSAVE DS    A
OUTLNDS  DS    CL40
         ORG   OUTLNDS
@NM00010 DS    CL20
         ORG   @NM00010
OUT1LINK DS    AL4
@NM00011 DS    CL3
OUT1SCNT DS    CL1
OUT1SEG1 DS    AL4
OUT1SEG2 DS    AL4
OUT1SEG3 DS    AL4
         ORG   OUTLNDS+20
OUTLD2   DS    CL20
         ORG   OUTLD2
@NM00012 DS    AL4
@NM00013 DS    CL3
OUT2SCNT DS    CL1
OUT2SEG1 DS    AL4
OUT2SEG2 DS    AL4
OUT2SEG3 DS    AL4
         ORG   OUTLNDS+40
         DS    CL4
DECRTCD  DS    CL8
ERRRTNSG DS    CL6
         ORG   ERRRTNSG
ERRRTNLN DS    FL2
ERRRTNOF DS    FL2
BCDRTNCD DS    CL2
         ORG   BCDRTNCD
@NM00014 DS    CL1
SIGN     DS    BL1
         ORG   ERRRTNSG+6
USRIDSEG DS    CL12
         ORG   USRIDSEG
USRIDLN  DS    FL2
USRIDOF  DS    FL2
USRIDI   DS    CL8
         ORG   USRIDSEG+12
INSTSEG  DS    CL44
         ORG   INSTSEG
INSTLN   DS    FL2
INSTOF   DS    FL2
INSTTX   DS    CL40
         ORG   INSTSEG+44
ACIOSAFL DS    BL1
         DS    CL1
ACIOALTL DS    CL24
DIRWAREA DS    CL344
         ORG   DIRWAREA
DIRDCB   DS    CL88
DIRBLOCK DS    CL256
         ORG   DIRBLOCK
DIRBLEXT DS    FL2
DIRENTRX DS    CL254
         ORG   DIRWAREA+344
STOWLIST DS    CL14
         ORG   STOWLIST
STOWNAME DS    CL8
@NM00027 DS    CL3
STOWC    DS    CL1
@NM00028 DS    CL2
         ORG   STOWLIST+14
         DS    CL2
@NM00029 DS    CL4
         ORG   @NM00029
READRTCD DS    FL4
         ORG   @NM00029+4
SWITCHES DS    CL1
         ORG   SWITCHES
ADDEDSW  DS    BL1
DIRMNSW  EQU   SWITCHES+0
STOWSW   EQU   SWITCHES+0
USRENQSW EQU   SWITCHES+0
         ORG   SWITCHES+1
MINNAME  DS    CL8
         ORG   MINNAME
USERLNTH DS    FL1
USERNAME DS    CL7
         ORG   MINNAME+8
IKJEFA12 CSECT
         DS    0F
@SIZDATD DC    AL1(1)
         DC    AL3(@ENDDATD-@DATD)
@CV00077 DC    V(IKJEFA13)
@CV00078 DC    V(IKJEFA51)
@CV00079 DC    V(IKJEFA52)
@CV00118 DC    V(MSGTABLE)
         DS    0D
LNDAPDE  DC    AL4(12)
@CC00285 DC    C'* '
MAJNAME  DC    CL8'SYSIKJUA'
@DATD    DSECT
IKJEFA12 CSECT
INLINLFM DS    0F
         DCB   DSORG=PO,DDNAME=SYSUADS,MACRF=(R,W),OPTCD=W,NCP=10
         DEQ   (MAJNAME,,,SYSTEM),RET=HAVE,MF=L
         ENQ   (MAJNAME,,E,,SYSTEM),RET=USE,MF=L
         OPEN  (,),MF=L                    DCB & OPTION SET BY E FORM
INLINLNG DC    A(*-INLINLFM)               LENGTH OF L-FORM MACROS
BSAMDCB  DCB   DSORG=PS,DDNAME=SYSUADS,MACRF=(R),BLKSIZE=256,RECFM=F
         DCBD  DSORG=PO,DEVD=DA           DATA CONTROL BLOCK MAPPING
@DATD    DSECT
DYNLFORM DS    0F
BPAMDCB  DCB   DSORG=PO,DDNAME=SYSUADS,MACRF=(R,W),OPTCD=W,NCP=10
DYNDQLST DEQ  (,,,),RET=HAVE,MF=L         WILL BE INIT'D FROM INLINLFM
DYNNQLST ENQ  (,,,,),RET=USE,MF=L         WILL BE INIT'D FROM INLINLFM
DYNOPLST OPEN  (,),MF=L                   WILL BE INIT'D FROM INLINLFM
IKJEFA12 CSECT
         DS   0H
PATCHLOC DC ((@DATA-@PSTART)/20)X'00'
@DATD    DSECT
         ORG   *+1-(*-@DATD)/(*-@DATD) INSURE DSECT DATA
@ENDDATD EQU   *
IKJEFA12 CSECT
@00      EQU   00                      EQUATES FOR REGISTERS 0-15
@01      EQU   01
@02      EQU   02
@03      EQU   03
@04      EQU   04
@05      EQU   05
@06      EQU   06
@07      EQU   07
@08      EQU   08
@09      EQU   09
@10      EQU   10
@11      EQU   11
@12      EQU   12
@13      EQU   13
@14      EQU   14
@15      EQU   15
CURRPTR  EQU   @08
CURPDPTR EQU   @02
ARGPTR   EQU   @09
ARGPDPTR EQU   @03
PREPDPTR EQU   @07
LEVLPTR  EQU   @06
RETNCODE EQU   @06
ENQRCPTR EQU   @02
ACIOPTRS EQU   @03
MSGBASE  EQU   @05
COMMPTR  EQU   @04
HEDBPTR  EQU   @06
R0       EQU   @00
R1       EQU   @01
DCBREG   EQU   @02
R15      EQU   @15
         ENTRY ADDERCLN
         ENTRY RDGETERR
DHED     EQU   0
UADSMHDR EQU   DHED
UADSBLNG EQU   UADSMHDR
UADSUSER EQU   UADSMHDR+4
UADSBN01 EQU   UADSMHDR+12
UADSMAXC EQU   UADSMHDR+14
UADSATTR EQU   DHED+16
IOPL     EQU   0
IOPLIOPB EQU   IOPL+12
PTPB     EQU   0
PTPBOPUT EQU   PTPB+4
COMMON   EQU   0
ACIOPTR  EQU   COMMON
BLDLPTR  EQU   COMMON+4
DATASUBP EQU   COMMON+8
DCBPTR   EQU   COMMON+12
ECBPTR   EQU   COMMON+16
IOPLPTR  EQU   COMMON+20
NODEPLAD EQU   COMMON+24
SIZEH    EQU   COMMON+28
SIZEL    EQU   COMMON+30
SIZED    EQU   COMMON+32
NUMOFLVL EQU   COMMON+45
ERRFLG   EQU   COMMON+46
PUTERR   EQU   COMMON+46
RSIZSW   EQU   COMMON+46
NONODESW EQU   COMMON+46
FINDEXSW EQU   COMMON+46
READMNSW EQU   COMMON+46
XBLKUSED EQU   COMMON+46
ACCTECB  EQU   0
ATTENTN  EQU   ACCTECB
NLSTTAB  EQU   0
USRLEN   EQU   NLSTTAB
USRID    EQU   NLSTTAB+1
PASSWD   EQU   NLSTTAB+9
ACTLEN   EQU   NLSTTAB+17
ACCTNO   EQU   NLSTTAB+18
ADDMSG   EQU   0
@NM00015 EQU   0
BLDLNAME EQU   @NM00015+4
ACIOPARM EQU   0
ACIOFLGS EQU   ACIOPARM
ACIOFL04 EQU   ACIOFLGS
ACIOFL05 EQU   ACIOFLGS
ACIOFL06 EQU   ACIOFLGS
ACIODCBA EQU   ACIOPARM+1
ACIOMPTR EQU   ACIOPARM+4
ACIODRCT EQU   ACIOPARM+8
ACIOLINK EQU   ACIOPARM+12
ACIONMBR EQU   ACIOPARM+16
ACIOBUFR EQU   ACIOPARM+17
@NM00023 EQU   ACIOPARM+20
DIRENTRY EQU   0
DIRMNAME EQU   DIRENTRY
DIRC     EQU   DIRENTRY+11
ENQRTCD  EQU   0
DATAPDE  EQU   0
DATAPTR  EQU   DATAPDE
DATALNTH EQU   DATAPDE+4
DATACHN  EQU   DATAPDE+9
DATAITEM EQU   0
PTPBPTR  EQU   IOPLIOPB
         AGO   .@UNREFD                START UNREFERENCED COMPONENTS
@NM00031 EQU   DATAPDE+8
@NM00030 EQU   DATAPDE+6
@NM00026 EQU   DIRENTRY+12
@NM00025 EQU   DIRENTRY+8
@NM00024 EQU   @NM00023
@NM00022 EQU   ACIOFLGS
@NM00021 EQU   ACIOFLGS
@NM00020 EQU   ACIOFLGS
@NM00019 EQU   ACIOFLGS
@NM00018 EQU   ACIOFLGS
@NM00017 EQU   @NM00015+2
@NM00016 EQU   @NM00015
@NM00009 EQU   NLSTTAB+58
@NM00008 EQU   ACCTECB
@NM00007 EQU   COMMON+46
@NM00006 EQU   COMMON+37
PTPBFLN  EQU   PTPB+8
@NM00005 EQU   PTPB
IOPLECB  EQU   IOPL+8
IOPLECT  EQU   IOPL+4
IOPLUPT  EQU   IOPL
@NM00004 EQU   DHED+40
UADSDEST EQU   DHED+32
UADSPERP EQU   DHED+28
UADSPWD1 EQU   DHED+24
UADSUPTP EQU   DHED+20
UADSINST EQU   DHED+18
@NM00003 EQU   UADSATTR
USATR03  EQU   UADSATTR
USATR02  EQU   UADSATTR
USATR01  EQU   UADSATTR
USATR00  EQU   UADSATTR
@NM00002 EQU   UADSBN01+1
UADSEXPF EQU   UADSBN01+1
UADSNUSP EQU   UADSBN01+1
@NM00001 EQU   UADSBN01
UADSFSQP EQU   UADSMHDR+2
.@UNREFD ANOP                          END UNREFERENCED COMPONENTS
@RT00142 EQU   CLEANUP1
@RT00203 EQU   STOWERR
@RF00238 EQU   USERLOOP
@RC00295 EQU   CLEANUP1
@RF00342 EQU   @EL00001
@RF00363 EQU   ERRMSG
@RT00366 EQU   FINDTEST
@RT00391 EQU   ERRMSG
@RT00411 EQU   CLEANUP1
@RF00439 EQU   @EL00003
@RF00454 EQU   @EL00004
@PB00004 EQU   @EL00001
@PB00003 EQU   @PB00004
@PB00002 EQU   @PB00003
@ENDDATA EQU   *
         END   IKJEFA12
