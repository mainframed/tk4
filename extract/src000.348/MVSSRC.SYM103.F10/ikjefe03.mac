         TITLE ' IKJEFE03 - EXEC PROCESSING MODULE'
* GEN(TITLE  'IKJEFE03 - EXEC PROCESSING MODULE');
         TITLE  'IKJEFE03 - EXEC PROCESSING MODULE'
* IKJEFE03: PROC(DUMPARM)
*                 OPTIONS (DONTSAVE(1,15),CODEREG(9,11),REENTRANT);
         LCLA  &T,&SPN                                            0002
.@001    ANOP                                                     0002
IKJEFE03 CSECT ,                                                  0002
         ST    @E,12(0,@D)                                        0002
         ST    @0,20(0,@D)                                        0002
         STM   @2,@C,28(@D)                                       0002
         BALR  @9,0                                               0002
@PSTART  DS    0H                                                 0002
         USING @PSTART+00000,@9                                   0002
         LA    @B,4095(0,@9)                                      0002
         USING @PSTART+04095,@B                                   0002
         LR    @C,@1                                              0002
         L     @0,@SIZ001                                         0002
         GETMAIN  R,LV=(0)                                        0002
         XR    @C,@1                                              0002
         XR    @1,@C                                              0002
         XR    @C,@1                                              0002
         USING @DATD+00000,@C                                     0002
         L     @0,20(0,@D)                                        0002
         XC    @TEMPS(@L),@TEMPS                                  0002
         ST    @D,@SAV001+4                                       0002
         LA    @F,@SAV001                                         0002
         ST    @F,8(0,@D)                                         0002
         LR    @D,@F                                              0002
* /********************************************************************
* /*                                                                  *
* /*  STATUS:                                                         *
* /*     CHANGE LEVEL 000                                             *
* /*    A200700,371100-371180,836100,836200,681600              YM2699*
* /*    A843100-843200,843600,843940,642800,643100              YM2699*
* /*    A645200,645700,680100-680460,680700,681200              YM2699*
* /*    A461100-463585,490100-490300,518100-518400              Y02676*
* /*    C841000-843500,642500,645000,645500,646500              Y02676*
* /*    C647500,680500,6810,,682500                             Y02676*
* /*    D643000,681500                                          Y02676*
* /*    A490600,518600                                          Y02676*
* /*    C490500,518500                                          Y02676*
* /*    C127000,127500,156500                                   Y01676*
* /*    A156600-156700,474600,371200                            Y01676*
* /*    A555520-555800                                          A42619*
* /*                                                            20035 *
* /*                                                                  *
* /*  FUNCTION:                                                       *
* /*     THIS MODULE FIRST CHECKS THE E01 SWITCHES TO DETERMINE       *
* /*     IF IT WAS CALLED TO PERFORM A GETMAIN, FREEMAIN, OR READ     *
* /*     FOR ONE OF THE OTHER EXEC MODULES. IF THIS IS THE CASE,      *
* /*     A POINTER IS SET TO THE ADDRESS IN E03 TO WHICH CONTROL      *
* /*     SHOULD BE RETURNED AFTER THE FUNCTION IS PERFORMED, AND      *
* /*     A BRANCH IS MADE TO THE APPROPRIATE AREA IN THIS MODULE      *
* /*     (THESE AREAS ARE DESCRIBED LATER).                           *
* /*                                                                  *
* /*     NEXT, IF THERE WAS A PROC STATEMENT, THE INPUT RECORD        *
* /*     IS SCANNED UNTIL AN AMPERSAND IS FOUND. IF NONE IS           *
* /*     FOUND (OR IF THERE WAS NO PROC STATEMENT), INDICATORS        *
* /*     ARE SET TO INDICATE THIS, AND THE ROUTINE WHICH MOVES        *
* /*     THE DATA INTO SUBPOOL 78 IS ENTERED. IF AN AMPERSAND WAS     *
* /*     FOUND, A CHECK IS MADE TO FIND IF IT WAS THE FIRST OF        *
* /*     A DOUBLE AMPERSAND. IF THIS IS THE CASE, THE INDICATORS      *
* /*     ARE SET SUCH THAT ONE AMPERSAND WILL BE MOVED TO SUBPOOL     *
* /*     78 IN PLACE OF THE TWO IN THE PROCEDURE. IF THE              *
* /*     AMPERSAND WAS NOT ONE OF TWO CONSECUTIVE AMPERSANDS, THE     *
* /*     SEARCH ROUTINE IS ENTERED.                                   *
* /*                                                                  *
* /*     THE SEARCH ROUTINE STEPS THROUGH ALL THE ELEMENTS OF         *
* /*     ATAB COMPARING EACH SYMBOLIC PARAMETER IN ATAB TO THE        *
* /*     ONE ENCOUNTERED AFTER THE AMPERSAND. IF NO MATCH IS FOUND,   *
* /*     THE NON-EXECUTABLE SWITCH IS TURNED ON, THE MESSAGE          *
* /*     MODULE IS LINKED TO IN ORDER TO PUT A MESSAGE TO THE         *
* /*     TERMINAL, AND A BRANCH IS MADE TO THE MOVE ROUTINE.          *
* /*     IF THE SYMBOLIC PARAMETER WAS DEFINED IN ATAB, THE           *
* /*     VALUE LOCATER ROUTINE IS ENTERED. THIS ROUTINE OBTAINS       *
* /*     THE LENGTH AND ADDRESS OF THE VALUE TO BE SUBSTITUTED        *
* /*     FOR THE OCCURRENCE OF THE PARAMETER.                         *
* /*                                                                  *
* /*     NEXT, THE MOVE ROUTINE IS ENTERED. THIS ROUTINE FIRST        *
* /*     CHECKS IF THE PROC HAS BEEN MARKED NON-EXECUTABLE.           *
* /*     IF IT IS BEEN SO MARKED, THE MOVE ROUTINE IS SKIPPED.        *
* /*     OTHERWISE, TWO MOVES ARE MADE. IN THE FIRST, ANY PORTION     *
* /*     OF THE INPUT LINE BEFORE THE AMPERSAND WHICH HAS NOT         *
* /*     BEEN MOVED ALREADY IS MOVED TO SUBPOOL 78. THE VALUE         *
* /*     FOR THE SYMBOLIC PARAMETER IS MOVED INTO SUBPOOL             *
* /*     78 CORE.                                                     *
* /*                                                                  *
* /*     AFTER THIS, THE UPDATE ROUTINE IS ENTERED. THIS ROUTINE      *
* /*     UPDATES ALL THE POINTERS ASSOCIATED WITH THE INPUT           *
* /*     RECORD, INITIATING A READ IF NECESSARY, AND RECYCLES TO      *
* /*     THE SCAN ROUTINE.                                            *
* /*                                                                  *
* /*     THE FOLLOWING ARE OPEN SUBROUTINES WHICH PERFORM SER-        *
* /*     VICES FOR OTHER MODULES AND FOR ROUTINES IN THIS MODULE.     *
* /*                                                                  *
* /*     READ ROUTINE - PASSES INPUT RECORD ADDRESS TO THE            *
* /*     CALLER AND PERFORMS A BSAM READ WHEN NECESSARY.              *
* /*                                                                  *
* /*     GETMAIN ROUTINE - PERFORMS CONDITIONAL GETMAINS.             *
* /*                                                                  *
* /*     FREEMAIN ROUTINE - PERFORMS FREEMAINS.                       *
* /*                                                                  *
* /*     EOD ROUTINE - END OF DATA ROUTINE. ENTERED WHEN END OF DATA  *
* /*     IS ENCOUNTERED ON THE INPUT DATA SET. A CHECK IS MADE        *
* /*     TO FIND IF THE PROC IN SP78 IS CONTIGUOUS. IF IT IS NOT,     *
* /*     A GETMAIN IS PERFORMED FOR THE TOTAL SIZE OF THE PROC, AND   *
* /*     THE NON-CONTIGUOUS PROC IS COPIED INTO THE NEWLY OBTAINED    *
* /*     CORE SO THAT IT IS NOW CONTIGUOUS. IF THE PROC WAS ALREADY   *
* /*     CONTIGUOUS, WE FREE ANY EXCESS CORE IN SP78 WHICH WE MAY     *
* /*     HAVE GOTTEN. IN EITHER CASE RETURN IS MADE TO E01.           *
* /*                                                                  *
* /*     SYNAD ROUTINE - THIS ROUTINE IS ENTERED WHEN AN I/O          *
* /*     ERROR HAS OCCURRED. THE MESSAGE MODULE IS LINKED TO          *
* /*     IN ORDER TO PUT OUT A MESSAGE TO THE TERMINAL. THEN THE      *
* /*     THE NON-EXECUTABLE SWITCH IS SET ON, AND RETURN IS MADE      *
* /*     TO E01 TO TERMINATE.                                         *
* /*                                                                  *
* /*  ENTRY POINTS:                                                   *
* /*     IKJEFE03 - ONLY ENTRY POINT. REASON FOR BEING CALLED         *
* /*     IS DETERMINED FROM THE SWITCHES IN E01DATDF.                 *
* /*                                                                  *
* /*  INPUT:                                                          *
* /*     REGISTER 1 POINTS TO E01DATDF WHICH IS A STRUCTURE USED BY   *
* /*     ALL FOUR MODULES (E01,E02,E03,E04) FOR COMMUNICATION.        *
* /*     (SEE 'TABLES/WORK-AREAS' FOR DESCRIPTIONN)
* /*                                                                  *
* /*  OUTPUT:                                                         *
* /*     IF CALLED FOR A FREEMAIN - NONE                              *
* /*     IF CALLED FOR A GETMAIN  - ADDGMN IS THE ADDRESS OF THE CORE *
* /*                                GOTTEN (SEE 'TABLES/WORK-AREAS')  *
* /*                              - AMTGMN IS THE AMOUNT OF CORE THAT *
* /*                                WAS OBTAINED ('TABLES/WORKAREAS') *
* /*     IF CALLED FOR A READ     - LINPTR1 CONTAINS THE ADDRESS OF   *
* /*                                THE INPUT RCD                     *
* /*                                (SEE 'TABLES/WORKAREAS')          *
* /*     IF CALLED FOR MOVING PROC TO SP78 -                          *
* /*                                SP78ADDR CONTAINS THE ADDRESS OF  *
* /*                                THE SP78 CORE                     *
* /*                                (SEE 'TABLES/WORKAREAS')          *
* /*                              - SP78LNGT CONTAINS THE LENGTH OF   *
* /*                                THE SP78 CORE                     *
* /*                                (SEE 'TABLES/WORK-AREAS')         *
* /*                                                                  *
* /*  EXTERNAL REFERENCES:                                            *
* /*     TABLES, ATAB AND FTAB, ARE REFERENCED                        *
* /*     BUT NOT ALTERED. (NOTE TABLES/WORKAREAS BELOW)               *
* /*                                                                  *
* /*     EO1DATDF - IS A STRUCTURE USED BY ALL FOUR MODULES.          *
* /*                                                                  *
* /*     BSAM - USED TO READ THE DATA SET CONTAINING THE PROCEDURE    *
* /*                                                                  *
* /*  EXITS, NORMAL:                                                  *
* /*     ALL EXITS ARE RETURNS TO THE CALLER.  SWITCHES SET IN        *
* /*     E01DATDF INDICATE STATUS OF FUNCTION REQUESTED.              *
* /*                                                                  *
* /*  EXITS, ERROR:                                                   *
* /*     ERROR EXITS ARE THE SAME AS NORMAL EXITS. EXCEPT FOR         *
* /*     DIFFERENT SWITCH SETTINGS.                                   *
* /*                                                                  *
* /* TABLES/WORK AREAS:                                               *
* /*    ATAB   (DOUBLE WORD BOUNDARY)                                 *
* /*      ×---------------------------------------------------------× *
* /*   +0 ×ADDRESS OF PREVIOUS BLOCK OF ATAB                        × *
* /*      ×---------------------------------------------------------× *
* /*   +4 ×ADDRESS OF NEXT BLOCK OF ATAB                            × *
* /*      ×---------------------------------------------------------× *
* /*   +8 ×LENGTH OF THIS BLOCK (IN BYTES)                          × *
* /*      ×---------------------------------------------------------× *
* /*   +12×     E                                                   × *
* /*      ×            L                                            × *
* /*      ×                   E                                     × *
* /*      ×                          M                              × *
* /*      ×                                 E                       × *
* /*      ×                                        N                × *
* /*      ×                                               T         × *
* /*      ×                                                      S  × *
* /*      ×---------------------------------------------------------× *
* /*                                                                  *
* /*    ATAB ELEMENT (BYTE BOUNDARY)                                  *
* /*      ×---------------------------------------------------------× *
* /*      ×FOR KEYWORD WITH VALUE AND POSITIONAL PARAMETERS THIS    × *
* /*      ×IS A PTR TO THE CORRESPONDING FTAB ELEMENT               × *
* /*      ×FOR KEYWORD W/O VALUE PARAMETERS A ZERO INDICATES THE    × *
* /*      ×KEYWORD WAS NOT PRESENT ON THE INVOCATION STATEMENT, AND × *
* /*   +0 ×A ONE INDICATES THAT IT WAS PRESENT.                     × *
* /*      ×---------------------------------------------------------× *
* /*   +4 ×FLAG BYTE       ×LENGTH                        ×SYMBOLIC × *
* /*      ×---------------------------------------------------------× *
* /*      ×PARAMETER NAME                                           × *
* /*      ×---------------------------------------------------------× *
* /*         WHERE: FLAG BYTE IS-                                     *
* /*                    BIT 0=1 IF THIS IS A KEYWORD WITH VALUE       *
* /*                    BIT 1=1 IF THIS IS A KEYWORD W/O VALUE        *
* /*                    BIT 2=1 IF THIS IS THE LAST ELMT IN THIS      *
* /*                            BLOCK OF ATAB                         *
* /*                LENGTH BYTE IS-                                   *
* /*                    LENGTH IN BYTES OF THE SYMBOLIC PARAMETER     *
* /*                    NAME WHICH FOLLOWS                            *
* /*                                                                  *
* /*    FTAB   (WORD BOUNDARY)                                        *
* /*      ×---------------------------------------------------------× *
* /*   +0 ×ADDRESS OF PREVIOUS BLOCK OF FTAB                        × *
* /*      ×---------------------------------------------------------× *
* /*   +4 ×ADDRESS OF NEXT BLOCK OF FTAB                            × *
* /*      ×---------------------------------------------------------× *
* /*   +8 ×TOTAL LENGTH OF THIS BLOCK  ×NUMBER OF BYTES IN USE      × *
* /*      ×---------------------------------------------------------× *
* /*   +12×     E                                                   × *
* /*      ×            L                                            × *
* /*      ×                   E                                     × *
* /*      ×                          M                              × *
* /*      ×                                   E                     × *
* /*      ×                                            N            × *
* /*      ×                                                  T      × *
* /*      ×                                                        S× *
* /*      ×---------------------------------------------------------× *
* /*                                                                  *
* /*    FTAB ELEMENT (BYTE BOUNDARY)                                  *
* /*      ×---------------------------------------------------------× *
* /*   +0 ×LENGTH OF THE SYMBOLIC PARAMETER VALUE WHICH FOLLOWS     × *
* /*      ×---------------------------------------------------------× *
* /*      ×VALUE ASSOCIATED WITH A SYMBOLIC PARAMETER NAME IN ATAB  × *
* /*      ×---------------------------------------------------------× *
* /*                                                                  *
* /*    E01DATDF (DOUBLE WORD BOUNDARY)                               *
* /*      ×---------------------------------------------------------× *
* /*   +0 ×DCB FOR DATA SET CONTAINING COMMAND PROCEDURE            × *
* /*      ×---------------------------------------------------------× *
* /*   +88×POINTER USED FOR INDIRECT ADDRESSING                     × *
* /*      ×---------------------------------------------------------× *
* /*   +92×POINTER USED FOR INDIRECT ADDRESSING                     × *
* /*      ×---------------------------------------------------------× *
* /*   +96×NAME OF PDS MEMBER WHICH CONTAINS THE PROC               × *
* /*      ×---------------------------------------------------------× *
* /*  +104×DECB FOR THE READ MACRO                                  × *
* /*      ×---------------------------------------------------------× *
* /*  +124×POINTER TO INPUT RECORD FROM PROC                        × *
* /*      ×---------------------------------------------------------× *
* /*  +128×NO. OF BYTES ON INPUT RCD WHICH HAVE NOT BEEN PROCESSED  × *
* /*      ×---------------------------------------------------------× *
* /*  +132×NO. OF POSITIONAL PARAMETERS FOUND ON THE PROC STATEMENT × *
* /*      ×---------------------------------------------------------× *
* /*  +136×WORK AREA - ALSO USED TO PASS ADDRESS OF CORE TO BE FREED× *
* /*      ×  BY MODULE E03                                          × *
* /*      ×---------------------------------------------------------× *
* /*  +140×MINIMUM AMOUNT OF CORE NEEDED FROM A GETMAIN             × *
* /*      ×---------------------------------------------------------× *
* /*  +144×MAXIMUM AMOUNT OF CORE NEEDED FROM A GETMAIN             × *
* /*      ×---------------------------------------------------------× *
* /*  +148×ADDRESS OF CORE OBTAINED VIA GETMAIN                     × *
* /*      ×---------------------------------------------------------× *
* /*  +152×AMOUNT OF CORE OBTAINED VIA GETMAIN                      × *
* /*      ×---------------------------------------------------------× *
* /*  +156×ADDRESS OF SUBPOOL 78 CORE WHICH BELONGS TO US           × *
* /*      ×---------------------------------------------------------× *
* /*  +160×LENGTH OF SUBPOOL 78 CORE WHICH BELONGS TO US            × *
* /*      ×---------------------------------------------------------× *
* /*  +164×WORK AREA                                                × *
* /*      ×---------------------------------------------------------× *
* /*  +168×NO. OF POSITIONAL PARMS SPECIFIED ON THE PROC STMT       × *
* /*      ×---------------------------------------------------------× *
* /*  +172×POINTER TO CURRENT BLOCK OF ATAB                         × *
* /*      ×---------------------------------------------------------× *
* /*  +176×POINTER TO CURRENT ELEMENT OF ATAB                       × *
* /*      ×---------------------------------------------------------× *
* /*  +180×POINTER TO CURRENT BLOCK OF FTAB                         × *
* /*      ×---------------------------------------------------------× *
* /*  +184×POINTER TO CURRENT ELEMENT OF FTAB                       × *
* /*      ×---------------------------------------------------------× *
* /*  +188×NO. OF BYTES IN VALUE PART OF KEYWORD WITH VALUE         × *
* /*      ×---------------------------------------------------------× *
* /*  +192×NO. OF KEYWORD W/O VALUE PARMS DEFINED IN PROC STMT      × *
* /*      ×---------------------------------------------------------× *
* /*  +194×NO. OF KEYWORD WITH VALUE PARMS DEFINED IN PROC STMT     × *
* /*      ×---------------------------------------------------------× *
* /*  +196×TOTAL BYTES IN ALL KEYWORD W/O VALUE PARMS               × *
* /*      ×---------------------------------------------------------× *
* /*  +198×TOTAL BYTES IN ALL KEYWORD WITH VALUE PARMS              × *
* /*      ×---------------------------------------------------------× *
* /*  +200×WORK AREA                                                × *
* /*      ×---------------------------------------------------------× *
* /*  +202×SWITCHES                                                 × *
* /*      × BIT 0  - SET TO ONE WHEN PROCESSING IMPLICIT EXEC       × *
* /*      × BIT 1  - SET TO ONE WHEN E03 IS CALLED TO READ FIRST    × *
* /*      ×          LINE OF PROC                                   × *
* /*      × BIT 2  - SET TO ONE IF PROCEDURE HAS NO PROC STATEMENT  × *
* /*      × BIT 3  - SET TO ONE IF NO PROC STMT AND FIRST LINE OF   × *
* /*      ×          PROC IS NOT EMPTY                              × *
* /*      × BIT 4  - SET TO ONE WHEN AN ABEND HAS OCCURRED          × *
* /*      × BIT 5  - SET TO ONE WHEN THE PROMPT OPTION WAS    Y01676× *
* /*      ×          SPECIFIED ON THE INVOCATION STATEMENT    Y01676× *
* /*      × BIT 6  - SET TO ONE WHEN E03 IS CALLED TO READ A RCD    × *
* /*      ×          OTHER THAN THE FIRST                           × *
* /*      × BIT 7  - SET TO ONE IF RECORD FORMAT IS VARIABLE        × *
* /*      × BIT 8  - TERMINATION SWITCH (SET TO ONE IF PROC IS      × *
* /*      ×          NON-EXECUTABLE)                                × *
* /*      × BIT 9  - SET TO ONE IF E03 HAS BEEN CALLED FOR A GETMAIN× *
* /*      × BIT 10 - SET TO ONE WHEN DATA SET IS NULL               × *
* /*      × BIT 11 - SET TO ONE WHEN CORE HAS BEEN OBTAINED FROM    × *
* /*      ×          SUBPOOL 78                                     × *
* /*      × BIT 12 - SET TO ONE WHEN E03 HAS BEEN CALLED TO DO A    × *
* /*      ×          FREEMAIN                                       × *
* /*      × BIT 13 - UNUSED                                         × *
* /*      × BIT 14 - SET TO ONE WHEN THE MINIMUM AMOUNT OF CORE     × *
* /*      ×          NEEDED COULD NOT BE OBTAINED                   × *
* /*      × BIT 15 - SET TO ONE WHEN THE LIST OPTION WAS SPECIFIED  × *
* /*      ×          ON THE INVOCATION STATEMENT                    × *
* /*      ×---------------------------------------------------------× *
* /*  +204×WORK AREA                                                × *
* /*      ×---------------------------------------------------------× *
* /*  +216×POINTER TO CURRENT ATAB ELEMENT - 1                      × *
* /*      ×---------------------------------------------------------× *
* /*  +220×POINTER TO FTAB ELEMENT - 1                              × *
* /*      ×---------------------------------------------------------× *
* /*  +224×POINTER TO FIRST INPUT BUFFER                            × *
* /*      ×---------------------------------------------------------× *
* /*  +228×POINTER TO SECOND INPUT BUFFER                           × *
* /*      ×---------------------------------------------------------× *
* /*  +232×POINTER TO CMD PROCESSOR PARAMETER LIST                  × *
* /*      ×---------------------------------------------------------× *
* /*  +236×PARAMETERS TO BE PASSED TO STAE EXIT ROUTINE             × *
* /*      ×---------------------------------------------------------× *
* /*  +248×POINTER TO PARSE CONTROL LIST                            × *
* /*      ×---------------------------------------------------------× *
* /*  +252×STORAGE FOR SERVICE ROUTINE CONTROL BLOCK                × *
* /*      ×---------------------------------------------------------× *
* /*  +276×ECB FOR SERVICE ROUTINES                                 × *
* /*      ×---------------------------------------------------------× *
* /*  +280×AREA FOR HOLDING RETURN CODES INTERNAL TO EXEC           × *
* /*      ×---------------------------------------------------------× *
* /*  +284×POINTER TO FIRST BLOCK OF ATAB                           × *
* /*      ×---------------------------------------------------------× *
* /*  +288×END OF CURRENT INPUT BLOCK + 1                           × *
* /*      ×---------------------------------------------------------× *
* /*  +292×POINTER TO START OF RECORD CURRENTLY BEING PROCESSED     × *
* /*      ×---------------------------------------------------------× *
* /*  +296×LENGTH OF DYNAMIC PORTION OF MSG TO BE PUT TO TERMINAL   × *
* /*      ×---------------------------------------------------------× *
* /*  +297×ADDRESS OF DYNAMIC PORTION OF MSG TO BE PUT TO TERMINAL  × *
* /*      ×---------------------------------------------------------× *
* /*  +300×ID NUMBER OF FIRST LEVEL MSG TO BE PUT TO TERMINAL       × *
* /*      ×---------------------------------------------------------× *
* /*  +302×ID NUMBER OF SECOND LEVEL MSG TO BE PUT TO TERMINAL      × *
* /*      ×---------------------------------------------------------× *
* /*  +304×POINTER TO THE PARSE DESCRIPTOR LIST                     × *
* /*      ×---------------------------------------------------------× *
* /*  +308×AREA FOR SAVING THE ORIGINAL LENGTH OF THE COMMAND BUFFER× *
* /*      ×---------------------------------------------------------× *
* /*  +310×TOTAL BYTES IN ALL POSITIONAL PARAMETERS           Y01676× *
* /*      ×---------------------------------------------------Y01676× *
* /*  +312××                                                    Y01676*
* /*                                                                  *
* /*                                                                  *
* /*  ATTRIBUTES:                                                     *
* /*     REENTRANT                                                    *
* /*                                                                  *
* /*  NOTES:                                                          *
* /*     CONSTANTS BEGIN WITH THE LETTERS 'KON' FOLLOWED BY THE       *
* /*     VALUE OF THE CONSTANT IF IT IS EITHER A DECIMAL OR EBCDIC    *
* /*     CONSTANT.  IF IT IS A HEX CONSTANT, THE 'KON' IS FOLLOWED    *
* /*     BY 'X' AND THE VALUE OF THE CONSTANT.                        *
* /*     CHARACTER CODE DEPENDENCIES --                               *
* /*        MODULE WAS ASSEMBLED USING EBCDIC CHARACTER CODE.         *
* /*        MODULE MUST BE MODIFIED IF A DIFFERENT CHARACTER SET      *
* /*        IS USED.                                                  *
* /*        DEPENDENCIES EXIST FOR THE FOLLOWING CHARACTERISITICS OF  *
* /*        EBCDIC:                                                   *
* /*          1.HORIZONTAL TAB IS X'05'.                              *
* /*        STATEMENTS WHICH CONTAIN THESE DEPENDENCIES WILL HAVE     *
* /*        ASTERISKS IN THEIR COMMENT FIELDS.                        *
* /*                                                                  *
* /********************************************************************
* /********************************************************************
*
*         GEN;
&SPN     SETA  1
         DS    0H
*         DCL  DUMPARM  FIXED(31);
*         DCL   R0   REG(0)    PTR(31);       /* REGISTER 0           *
*         DCL   R1   REG(1)    PTR(31);       /* REGISTER 1           *
*         DCL   R2   REG(2)    PTR(31);       /* REGISTER 2           *
*         DCL   R3   REG(3)    PTR(31);       /* REGISTER 3           *
*         DCL   R4   REG(4)    PTR(31);       /* REGISTER 4           *
*         DCL   R5   REG(5)    PTR(31);       /* REGISTER 5           *
*         DCL   R6   REG(6)    PTR(31);       /* REGISTER 6           *
*         DCL   R15 REG(15)    PTR(31);       /* REGISTER 15          *
*  /*
*                         THE FOLLOWING IS A DSECT OF
*                         VARIABLES DEFINED IN IKJEFE01
*                         AND USED BY IKJEFE03
*                                                                     *
*         DCL   KON0      FIXED(15) STATIC INIT(0);/* CONSTANT        *
*         DCL   KON1      FIXED(15) STATIC INIT(1);/* CONSTANT        *
*         DCL   KON2      FIXED(15) STATIC INIT(2);/* CONSTANT        *
*         DCL   KON3      FIXED(15) STATIC INIT(3);/* CONSTANT        *
*         DCL   KON4      FIXED(15) STATIC INIT(4);/* CONSTANT        *
*         DCL   KON5      FIXED(15) STATIC INIT(5);/* CONSTANT        *
*         DCL   KON7      FIXED(15) STATIC INIT(7);/* CONSTANT        *
*         DCL   KON8       FIXED(15) STATIC INIT(8);/* CONSTANT       *
*         DCL   KON11      FIXED(15) STATIC INIT(11);
*                                                  /* CONSTANT        *
*         DCL   KON12      FIXED(15) STATIC INIT(12);
*                                                  /* CONSTANT        *
*         DCL   KON13      FIXED(15) STATIC INIT(13);
*                                                  /* CONSTANT        *
*         DCL   KON14      FIXED(15) STATIC INIT(14);
*                                                  /* CONSTANT        *
*         DCL   KON15      FIXED(15) STATIC INIT(15);
*                                                  /* CONSTANT        *
*         DCL   KON16      FIXED(15) STATIC INIT(16);
*                                                  /* CONSTANT        *
*         DCL   KON50      FIXED(15) STATIC INIT(50);
*                                                  /* CONSTANT        *
*         DCL   KON78      FIXED(15) STATIC INIT(78);
*                                                  /* CONSTANT        *
*         DCL   KON82      FIXED(15) STATIC INIT(82);
*                                                  /* CONSTANT        *
*         DCL   KON256       FIXED(15) STATIC INIT(256);
*                                                  /* CONSTANT        *
*
*          /* THE FOLLOWING CONSTANT IS USED AS THE AMOUNT OF STORAGE *
*          /* TO BE OBTAINED FROM SUBPOOL 78 FOR STACKING THE         *
*          /* PROCEDURE. IT SET TO 1992 SINCE THE TMP AND I/O SERVICE *
*          /* ROUTINES INITIALLY GET 56 BYTES. THUS OUR GETMAIN WILL  *
*          /* NOT REQUIRE THAT AN ADDITIONAL 2K BLOCK                 *
*          /* BE ALLOTED TO SUBPOOL 78. IF THE AMOUNT WHICH THE TMP   *
*          /* OR I/O SERVICE ROUTINES GET INCREASES - THIS CONSTANT   *
*          /* SHOULD BE DECREASED BY AN EQUAL AMOUNT.                 *
*         DCL   KON1992      FIXED(15) STATIC INIT(1992);
*                                                  /* CONSTANT        *
*         DCL 1 KONSTRUC  STATIC,             /* HEXADECIMAL CONSTANTS*
*               2 KONX00  CHAR(1)  INIT('00'X),    /* CONSTANT        *
*               2 KONX20  CHAR(1)  INIT('20'X),    /* CONSTANT        *
*               2 KONXFF  CHAR(1)  INIT('FF'X),    /* CONSTANT        *
*               2 KON7FFC CHAR(2)  INIT('7FFC'X);  /* CONSTANT  YM2699*
*         DCL 1  E01DATDF BDY(DWORD)  BASED(R6),   /* MAJOR STRUCTURE *
*                                             /*   USED BY ALL FOUR   *
*                                             /*   MODULES            *
*                2 DCBAR     CHAR(88)  BDY(DWORD),
*                                                  /* LIVE DCB AREA   *
*
*                2 ADPTR1    PTR(31),              /* PTR USED FOR
*                                                       INDIRECT ADDRS*
*                2 ADPTR2    PTR(31),              /* FOR INDIRECT
*                                                       ADDRESSING    *
*                2 MMNAMAR   BDY(WORD) CHAR(8),
*                                                  /* MEMBER NAME     *
*                2  RDECB   BDY(WORD) CHAR(20),
*                                                  /* STORAGE FOR DECB*
*                  3 *        CHAR(6),        /* FILLER               *
*                  3 DECLNGTH FIXED(15),      /* LENGTH OF BLOCK READ *
*                  3 *        CHAR(8),        /* FILLER               *
*                  3 DECIOBPT PTR(31),        /* POINTER TO THE IOB   *
*                2 LINPTR1   PTR(31),         /* ADDR OF INPUT        *
*                2 EOLCNT    FIXED(31),       /* BYTES REMAINING
*                                                  IN LINE            *
*                2 POSCNT    FIXED(31),       /* NUMBER OF POSITIONAL
*                                                  PARAMETERS FOUND   *
*                2 TSTLNG    FIXED(31),       /* WORK AREA - USED FOR *
*                  3 TSTLNGC   CHAR(4),       /* ALIGNING TABLE ENTRY *
*                2 GMNMIN    FIXED(31),       /* MINIMUM AMOUNT OF CORE
*                                                 TO BE GOTTEN        *
*                2 GMNMAX    FIXED(31),      /* MAXIMUM AMOUNT OF CORE
*                                                 TO BE GOTTEN        *
*                2 ADDGMN    PTR(31),        /* ADDRESS OF GOTTEN CORE*
*                2 AMTGMN    FIXED(31),      /* AMOUNT OF CORE GOTTEN *
*                2 SP78ADDR  PTR(31),        /* PTR TO SUBPOOL78 CORE *
*                2 SP78LNGT  PTR(31),        /* LENGTH OF SUBPOOL78
*                                                 CORE                *
*                2 RDXCNV  FIXED(31),        /* WORK AREA FOR
*                  3  *     CHAR(3),              CONVERTING BASE     *
*                  3  DDIG   CHAR(1),        /* OF NO. PARMS          *
*                2 POSSPC    FIXED(31),      /* NUMBER OF POSITIONAL
*                                                 PARAMERS SPECIFIED  *
*                2 ATABIND   PTR(31),        /*  PTR TO START OF
*                                                  CURRENT BLOCK OF
*                                                  ATAB               *
*                2 ATABCUR   PTR(31),        /*  PTR TO CURRENT
*                                                  ELEMENT OF ATAB    *
*                2 FTABIND   PTR(31),        /*  PTR TO START OF
*                                                  CURRENT BLOCK OF
*                                                  FTAB               *
*                2 FTABCUR   PTR(31),         /* PTR TO CURRENT
*                                                  ELEMENT OF ATAB    *
*                2 VALCNT    FIXED(31),       /* NUMBER OF BYTES IN
*                                                  VALUE OF KEYWORD
*                                                  WITH VALUE         *
*                2 KWOCNT    FIXED(15),       /* NUMBER OF KWRD W/O
*                                                  VALUE PARMS        *
*                2 KWWCNT    FIXED(15),       /* NUMBER OF KWRD WITH
*                                                  VALUE PARMS        *
*                2 KWOBYT    FIXED(15),       /* SIZE OF KWRD W/O
*                                                  VALUE PARMS        *
*                2 KWWBYT    FIXED(15),       /* SIZE OF KWRD W/O
*                                                  VALUE PARMS        *
*                2 CNVA   FIXED(15),          /*WORKAREA FOR UNALIGNED*
*                  3 CNVC   CHAR(2),          /* ARITHMETIC ITEMS     *
*                2 E01BINSW BDY(HWORD),       /* BINARY SWITCHES      *
*                  3 E01SW1 BIT(1),           /* SWITCH 1             *
*                                             /* SET TO ONE WHEN
*                                                   PROCESSING
*                                                   IMPLICIT EXEC     *
*                  3 E01SW2 BIT(1),            /* SWITCH 2            *
*                                              /* SET TO ONE WHEN
*                                                   IKJEFE03 IS CALL-
*                                                   ED TO READ 1ST
*                                                   LINE              *
*                  3 E01SW3 BIT(1),            /* SWITCH 3            *
*                                              /* SET TO ONE IF THE
*                                                   PROCEDURE DOES
*                                                    NOT HAVE A PROC
*                                                    STATEMENT        *
*                  3 E01SW4 BIT(1),             /* SWITCH 4           *
*                                               /* SET TO ONE IF 1ST
*                                                    LINE IS NOT EMPTY
*                                                                     *
*                  3 E01SW5 BIT(1),             /* SWITCH 5           *
*                                               /* SET TO ONE ON AN
*                                                    ABEND            *
*                  3 E01SW6 BIT(1),             /* SWITCH 6           *
*                                               /* SET TO ONE WHEN
*                                                    THE PROMPT OPTION
*                                                    WAS SPECIFIED ON
*                                                      THE INVOCATION
*                                                    STATEMENT        *
*                  3 E01SW7 BIT(1),              /* SWITCH 7          *
*                                                /* SET TO ONE WHEN
*                                                    IKJEFE03 IS CALL-
*                                                    ED TO READ LINE
*                                                    OTHER THAN 1ST   *
*                  3 E01SW8 BIT(1),              /* SWITCH 8          *
*                                                /* SET TO ONE IF RCD
*                                                    FMT IS VARIABLE  *
*                  3 E01SW9 BIT(1),              /* SWITCH 9          *
*                                                /* SET TO ONE IF PROC
*                                                     CANNOT BE EXECUT-
*                                                     ED              *
*                  3 E01SW10 BIT(1),             /* SWITCH 10         *
*                                                /* SET TO ONE WHEN
*                                                     IKFEFE03 HAS BEEN
*                                                     CALLED TO DO A
*                                                     GETMAIN         *
*                  3 E01SW11 BIT(1),             /* SWITCH 11         *
*                                                /* SET TO ONE WHEN
*                                                     DATA SET HAS BEEN
*                                                     CLOSED          *
*                  3 E01SW12 BIT(1),             /* SWITCH 12         *
*                                                /* SET TO ONE WHEN
*                                                     CORE HAS BEEN
*                                                     OBTAINED FROM SP
*                                                     78              *
*                  3 E01SW13 BIT(1),             /* SWITCH 13         *
*                                                /* SET TO ONE WHEN
*                                                     IKFEFE03 HAS BEEN
*                                                     CALLED TO DO A
*                                                     FREEMAIN        *
*                  3 E01SW14 BIT(1),             /* SWITCH 14         *
*                                                /* SET TO ONE WHEN
*                                                     SP78 OVFLOW HAS
*                                                     CAUSED SP0 TO BE
*                                                     OBTAINED        *
*                  3 E01SW15 BIT(1),             /* SET TO ONE WHEN
*                                                     THE  MINIMUM AMT
*                                                     OF CORE COULD NOT
*                                                     BE GOTTEN       *
*                  3 E01SW16 BIT(1),             /* SWITCH 16         *
*                2 REGSAV(3) FIXED(31),          /* SAVE AREA         *
*                2 LATAB   PTR(31),              /* PTR TO PREVIOUS ATA
*                                                ELEMENT              *
*                2 LFTAB   PTR(31),           /* PTR TO PREVIOUS FTAB
*                                                ELEMENT              *
*                2 BFAPTR  FIXED(31),         /* POINTER TO INPUT BFR *
*                2 BFBPTR  PTR(31),           /* POINTER TO INPUT BFR *
*                2 CPPLPTR   PTR(31),         /* ADDRESS OF CPPL      *
*                2 STPRM(3)  FIXED(31),
*                2 PPLPTR PTR(31),            /* POINTER TO CONTROL   *
*                2 CBCOR CHAR(24),            /* STORAGE FOR SERVICE
*                                                  ROUTINE CONTROL BLCK
*                                                  BLOCK FOR SERVICE
*                                                  ROUTINES FOR LIST  *
*                2 SRECB  FIXED(31),          /* SERV ROUT ECB        *
*                2 RETCDAR   FIXED(31),       /* AREA FOR RETURN
*                                                  CODE               *
*                2 ABLK1     PTR(31),         /* PTR TO FIRST BLOCK
*                                                  OF ATAB            *
*                2 EOB       PTR(31),         /* END OF CURRENT INPUT
*                                                  BLOCK + 1          *
*                2 RCDST     PTR(31),         /* PTR TO START OF CUR-
*                                                  RENT RECORD        *
*                2 VARSGLNG  CHAR(1),         /* LENGTH OF VARIABLE
*                                                  PART OF MSG TO BE
*                                                  PUT OUT            *
*                2 VARSGADR  PTR(24),         /* ADDRESS OF VARIABLE
*                                                  PART OF MSG TO BE
*                                                  PUT OUT            *
*         2 VARSGLN2  CHAR(1),                /*  LENGTH OF VARIABLE  *
*                                             /*    PART OF MSG TO BE *
*                                             /*    PUT OUT           *
*                2 VARSGAD2  PTR(24),         /*  ADDRESS OF VARIABLE *
*                                             /*    PART OF MSG TO BE *
*                                             /*    PUT OUT           *
*                2 LVL1NO    FIXED(15),       /* NUMBER OF FIRST LEVEL*
*                                             /*   MESSAGE            *
*                2 LVL2NO    FIXED(15),       /*NUMBER OF SECOND LEVEL*
*                                             /*    MESSAGE           *
*                2 PDLPTR    PTR(31),         /* POINTER TO THE PARSE *
*                                             /*   DESCRIPTOR LIST    *
*               2 DRDNPTR BDY(WORD),          /* AREA FOR DSNAME      *
*                 3 DSNARLNG FIXED(15),       /* LENGTH OF DSNAME     *
*                   4 DSNARLCH CHAR(2),       /*                      *
*                 3 DSNAMAR  CHAR(44),        /* DSNAME               *
*                2 CBUFLSAV  FIXED(15),       /* SAVE AREA FOR CMD BFR*
*                 3 CBUFLSAC CHAR(2);         /*    LENGTH            *
** /* *************************************************************** *
** /* THE COMMAND PROCESSOR PARAMETER LIST (CPPL) IS A LIST OF        *
** /* ADDRESSES PASSED FROM THE TMP TO THE CP VIA REGISTER 1          *
** /* *************************************************************** *
** DECLARE
**   1 CPPL BASED(CPPLPTR),
**    2 CPPLCBUF PTR(31),             /* PTR TO COMMAND BUFFER        *
**    2 CPPLUPT  PTR(31),             /* PTR TO UPT                   *
**    2 CPPLPSCB PTR(31),             /* PTR TO PSCB                  *
**    2 CPPLECT  PTR(31);             /* PTR TO ECT                   *
**
*         DCL   CBUFPTR   PTR(31) BASED(ADDR(CPPLCBUF));
*         DCL 1 CBUF BASED(CBUFPTR),          /* NAME OF TABLE        *
*               2 CBUFLNG PTR(16),            /* TOTAL LENGTH OF CBUF *
*               2 CBUFOFF PTR(16),            /* CURRENT DATA FIELD   *
*                                             /*   OFFSET             *
*               2 CBUFDATA CHAR(1);           /* VAR LENGTH DATA FIELD*
*         DCL   1 DCBD    BDY(DWORD) BASED(ADDR(DCBAR)),
*                                             /* DSECT -DCBFIELDS     *
*                 2  *        CHAR(26),       /* FILL                 *
*                 2 DCBDSORG  CHAR(2),        /* DS ORGANIZATION      *
*                 2  *        CHAR(5),        /* FILL                 *
*                 2 DCBEODAD  PTR(24),        /* END DATA EXIT        *
*                 2 DCBRECFM  CHAR(1),        /* RECORD FMT           *
*                    3 DCBRCFF   BIT(1),      /* FIXED LENGTH BIT     *
*                    3 DCBRCFV   BIT(1),      /* VAR LENGTH BIT       *
*                 2 DCBEXLST  PTR(24),        /* OPEN TIME EXIT       *
*                 2 DCBDDNAM  CHAR(8),        /* DDNAME               *
*                 2 DCBOFLGS  CHAR(1),        /* OPEN FLAGS           *
*                 2  *        CHAR(1),        /* FILL                 *
*                 2 DCBMACR   CHAR(2),        /* MACRO TYPE           *
*                 2  *        CHAR(10),       /* FILL                 *
*                 2 DCBBLKSI  FIXED(15),      /* BLOCKSIZE            *
*                 2  *        CHAR(18),        /* FILL                *
*                 2 DCBLRECL  FIXED(15),       /* RECORD SIZE         *
*                 2  *        CHAR(4);         /* FILL                *
*         DCL   E03PRT05   LABEL   LOCAL   EXTERNAL;
*         DCL   E03SYN05   LABEL   LOCAL   EXTERNAL;
*  /*
*                         FOLLOWING ARE THE DSECTS OF
*                         ATAB AND FTAB
*                                                                     *
*         DCL   1 ATAB      BDY(WORD)  BASED(ATABIND),
*                                             /* ARGUMENT TABLE       *
*                 2 ATABLST    PTR(31),       /* PTR TO PREVIOUS BLOCK
*                                                ZERO IF NONE PREVIOUS*
*                 2 ATABNXT    PTR(31),       /* PTR TO NEXT BLOCK -
*                                                ZERO IF THIS IS LAST *
*                 2 ATABLNG    FIXED(31);     /* LENGTH OF THIS BLOCK *
*         DCL   1 FTAB      BDY(WORD)  BASED(FTABIND),
*                                             /* FUNCTION TABLE       *
*                 2 FTABLST    PTR(31),       /* PTR TO PREVIOUS BLOCK
*                                                ZERO IF NONE PREVIOUS*
*                 2 FTABNXT    PTR(31),       /* PTR TO NEXT BLOCK -
*                                                ZERO IF THIS IS LAST *
*                 2 FTABLNG    FIXED(15),     /* LENGTH OF THIS BLOCK *
*                 2 FTABDLNG   FIXED(15);     /* NUMBER OF BYTES OF
*                                                  THIS BLOCK WHICH
*                                                  ARE IN USE         *
*
*         DCL   1 ATABELMT  BDY(WORD)  BASED(FTABCUR),
*                                             /* ARGUMENT ELEMENT     *
*                 2 FTABPTR    CHAR(4),       /* PTR TO CORRESPONDING
*                                                  FTAB ELEMENT       *
*                 2 ATABFLGS   CHAR(1),       /* FLAGS FOR ATAB
*                                                BIT 0 = KWRD W. VALUE
*                                                BIT 1 = KWRD WO VALUE
*                                                BIT 2 = LAST ENTRY   *
*                 2 ATABELNC   CHAR(2),       /* LENGTH OF SYMBOLIC
*                                                 PARAMETER           *
*                 2 ATABDAT    CHAR(256);     /* SYMBOLIC PARAMETER   *
*         DCL   1 FTABELMT  BDY(WORD)  BASED(FTABCUR),
*                                             /* FUNCTION ELEMENT     *
*                 2 FTABELNG   CHAR(4),       /* LENGTH OF THIS VALUE *
*                 2 FTABDAT    CHAR(256);     /* VALUE FOR CORRESPONDIN
*                                                  SYMBOLIC PARAMETER *
* /*                      FOLLOWING ARE VARIABLES USED
*                         FOR PROCESSING INPUT                        *
*         DCL   OFFSET    PTR(31);            /* PTR TO PORTION OF
*                                                 INPUT RECORD WHICH
*                                                 IS BEING PROCESSED  *
*         DCL   INPLIN    CHAR(32767)  BASED(OFFSET);
*                                             /* DSECT OF INPUT       *
*         DCL   RCDLNG    CHAR(2)      BASED(RCDST);
*         DCL   RCDLNGA   FIXED(15)           /* PTR TO LENGTH OF RCD *
*                         BASED(BFBPTR);      /*   FOR VARIABLE FMT   *
*         DCL   REMCHAR   FIXED(15);          /* NUMBER OF BYTES NOT
*                                                  YET PROCESSED IN
*                                                  THE INPUT RCD      *
*         DCL   REMCHARC  CHAR(2)             /* NUMBER OF BYTES NOT  *
*                 BASED(ADDR(REMCHAR));       /*   YET PROCESSED IN THE
*                                                  INPUT RCD          *
*         DCL   LINENO    CHAR(8);           /* HOLD AREA FOR LINE
*                                                 NUMBER              *
*         DCL   1 IOB  BDY(WORD)  BASED(DECIOBPT), /* INPUT - OUTPUT
*                                                     BLOCK           *
*                 2 *          CHAR(14),      /* FILLER               *
*                 2 CSWCNT     FIXED(15);     /* RESIDUAL BYTE COUNT
*                                                 FROM LAST READ      *
*  /*
*                         FOLLOWING ARE VARIABLES USED
*                         FOR PROCESSING OUTPUT
*                                                                     *
*         DCL   AVL78     FIXED(15);          /* NUMBER OF BYTES OF
*                                                  CURRENT SP78 CORE
*                                                  NOT IN USE         *
*         DCL   PRMSTR    PTR(31);            /* PTR TO FIRST BLOCK OF
*                                                  SP78 CORE          *
*         DCL   PROCIND   PTR(31);            /* PTR TO START OF RCD
*                                                  BEING CREATED IN
*                                                  SP78               *
*         DCL   PROCUR    PTR(31);            /* PTR TO PORTION OF RCD
*                                                  CURRENTLY BEING
*                                                  PROCESSED          *
*         DCL   PROCDAT   CHAR(32767)  BASED(PROCUR);
*                                             /* DSECT OF OUTPUT RCD  *
*         DCL   PROCRCL   CHAR(2)      BASED(PROCIND);
*                                             /* RCD LENGTH INDICATOR *
*         DCL   PROCRCLF  FIXED(15)    BASED(PROCIND);  /* REDEF OF
*                                                RCD LENGTH     YM2699*
*         DCL   PROCRES   BIT(16)      BASED(PROCIND + 2);
*                                             /* TWO BYTES OF ZERO
*                                                  AFTER LRECL TO SEEM
*                                                  COMPATIBLE WITH DM *
*         DCL   PROCNXT   PTR(31)      BASED(ADDGMN);
*                                             /* PTR TO NEXT BLOCK OF
*                                                  SP78 CORE - ZERO IF
*                                                  THIS BLOCK IS LAST *
*         DCL   PROCSZE   FIXED(31)    BASED(ADDGMN + 4);
*                                             /* SIZE OF THIS BLOCK OF
*  /*
*                         FOLLOWING ARE VARIABLES USED
*                         FOR PROCESSING IN GENERAL
*                                                                     *
*         DCL   1 E03BINSW     BDY(BYTE),     /* BINARY SWITCHES      *
*                 2 E03SW1     BIT(1),        /* SET TO ONE WHEN THE
*                                                  LOGICAL LINE IS
*                                                  CONTINUED BETWEEN
*                                                  RECORDS            *
*                 2 E03SW2     BIT(1),        /* SET TO ONE IF CURRENT
*                                                  PARM IS KWRD WO
*                                                  VALUE              *
*                 2 E03SW3     BIT(1),        /* SET TO ONE WE HAVE
*                                                  MORE THAN ONE BLOCK
*                                                  OF SP78 CORE       *
*                 2 E03SW4     BIT(1),        /* SET TO ONE AFTER
*                                                  LIST FORMS OF
*                                                  GETMAIN - FREEMAIN
*                                                  HAVE BEEN MOVED TO
*                                                  GOTTEN CORE        *
*                 2 E03SW5   BIT(1),          /* SET TO ONE IF        *
*                   3 CONTPLUS   BIT(1),      /* PLUS SIGN CONTINUATION
*                                                HAS BEEN REQUESTED   *
*                 2 E03SW6   BIT(1),          /* SET TO ONE IF A      *
*                   3 ENDDLM   BIT(1),        /* A COMMENT IS CONTINUED
*                                                ACROSS INPUT RECORDS *
*                 2 E03SW7   BIT(1),          /* SET TO ONE IF THE    *
*                   3 NULLINE   BIT(1),       /* CONTINUATION RECORD
*                                                IS BLANK OR CONTAINS
*                                                COMMENTS ONLY        *
*                 2 *          BIT(1);        /* FILLER               *
*         DCL   TEMP01    FIXED(31);          /* TEMPORARY WORK AREA
*                                                  USED FOR HOLDING
*                                                  STARTING OFFSET OF *
*
*         DCL   TEMP02    FIXED(31);          /* TEMPORARY WORK AREA
*                                                  USED FOR HOLDING END
*                                                  OFFSET  OF SYMBOLIC
*                                                  PARMS              *
*         DCL   TEMP03    FIXED(31);          /* TEMPORARY WORK AREA
*                                                  USED FOR LOOP CONTRO
*                                                  FINDING IF WE NEED
*                                                  MORE SP78 CORE AND
*                                                  HOLDING PARM LENGTH*
*         DCL   TEMP04    FIXED(31);          /* TEMPORARY WORK AREA
*                                                  USED FOR HOLDING THE
*                                                  LENGTH OF PARM'S
*                                                  VALUE AND IN GETTING
*                                                  ADDITIONAL SP78
*                                                  CORE               *
*         DCL                                                 /*Y02993*
*               1  TEMP05    FIXED(31),                       /*Y02993*
*                 2  TEMPC05  CHAR(4);        /* TEMPORARY WORK AREA
*                                                  USED IN OBTAINING
*                                                  ADDITIONAL SP78 CORE
*                                                  AND FOR READING
*                                                  RCDS         Y02993*
*         DCL   CURBLK  PTR(31);              /* ADDRESS OF THE CURRENT
*                                                SP78 CLIST AREA USED
*                                                WHEN CLIST RECORDS ARE
*                                                SPANNED ACROSS SP78
*                                                BLOCKS         YM2699*
*         DCL                                 /* USED TO        YM2699*
*              1  RECSIZE  FIXED(31),         /* CALCULATE THE  YM2699*
*                2 RECSIZEC CHAR(4);          /* TOTAL SP78 CLIST RECOR
*                                                SIZE           YM2699*
*         DCL   I   FIXED(31);                /* INDEX COUNTER  Y01676*
*         DCL   INDAD1    LABEL  BASED(ADPTR1);/* LABEL USED FOR
*                                                  INDIRECT ADDRESSING*
*         DCL   TRTAB(256)  CHAR(1)           /* TABLE USED BY TRANS- *
*                         INIT((80)'00'X,'&',(175)'00'X);
*                                             /*   LATE AND TEST TO
*                                                  FIND AMPERSANDS    *
*          DCL   1 TCHAR     CHAR(5)  STATIC, /* CHARACTERS USED FOR  *
*                 2 KBLNK  CHAR(1)   INIT(' '),   /* FINDING THE END  *
*                 2 KCOM   CHAR(1)   INIT(','),   /* OF A SYMBOLIC    *
*                 2 KTAB   CHAR(1)   INIT('05'X), /********************
*                 2 KAMP   CHAR(1)   INIT('&'),   /* PARAMETER        *
*                 2 KPERD  CHAR(1)   INIT('.');
*         DCL   KCONT     CHAR(1)  INIT('-')  STATIC;
*         DCL   KCONTP     CHAR(1) INIT('+') STATIC;
*                                             /* CONTINUATION CHARS   *
*         DCL   KONSLAST   CHAR(2) INIT('/*') STATIC;
*         DCL   KONASTSL   CHAR(2) INIT('*/') STATIC;
*         DCL   E03CNT05  LABEL;              /* STATEMENT LABEL      *
*         DCL   E03CNT10  LABEL;              /* STATEMENT LABEL      *
*         DCL   E03CNT20  LABEL;              /* STATEMENT LABEL      *
*         DCL   E03CNT25  LABEL;              /* STATEMENT LABEL      *
*         DCL   E03ITO10  LABEL;              /* STATEMENT LABEL      *
*         DCL   E03ITO20  LABEL;              /* STATEMENT LABEL      *
*         DCL   E03UAR10  LABEL;              /* STATEMENT LABEL      *
*         DCL   E03PRT15  LABEL;              /* STATEMENT LABEL      *
*         DCL   E03PRT20  LABEL;              /* STATEMENT LABEL      *
*         DCL   E03PRT25  LABEL;              /* STATEMENT LABEL      *
*         DCL   E03PRT35  LABEL;              /* STATEMENT LABEL      *
*         DCL   E03OAB15  LABEL;              /* STATEMENT LABEL      *
*         DCL   E03PRT40  LABEL;              /* STATEMENT LABEL      *
*         DCL   E03PRT30  LABEL;              /* STATEMENT LABEL      *
*         DCL   AAGETM   CHAR(256)  GEND;
*         DCL   AAFREM   CHAR(256)  GEND;
*         /************************************************************
*         /*              FOLLOWING IS THE RUNNING CODE               *
*         /*              FOR THE MODULE                              *
*         /************************************************************
*         RESTRICT     (R2,R3,R4,R5,R6);
*         R6  = R1;                           /* SET POINTER TO DATA
*                                                IN MODULE IKJEFE01   *
         LR    @6,@1                                              0095
*
*         /************************************************************
*         /*              FOLLOWING CODE DETERMINES THE               *
*         /*              PURPOSE FOR WHICH THE MODULE                *
*         /*              WAS CALLED AND IF CALLED FOR A              *
*         /*              GETMAIN, FREEMAIN OR READ IT                *
*         /*              SETS APROPRIATE VARIABLES AND               *
*         /*              BRANCHES TO APROPRIATE ROUTINE              *
*         /*              BRANCHES TO APROPRIATE ROUTINE              *
*         /************************************************************
*         IF  E01SW2 = '1'B × E01SW7 = '1'B   /* IF MODULE WAS CALLED *
*           THEN                              /* PERFORM A READ - SET *
         TM    202(@6),B'01000000'                                0096
         BC    01,@9FF                                            0096
         TM    202(@6),B'00000010'                                0096
         BC    12,@9FE                                            0096
*             DO;                             /* THE RETURN ADDRESS   *
*               E03BINSW  = KONX00;           /* INITIALIZE SWITCHES  *
@9FF     MVC   E03BINSW(1),KONSTRUC                               0098
*               TEMP01 = ADPTR1;
         MVC   TEMP01(4),88(@6)                                   0099
*               ADPTR1 = ADDR(E03CNT05);      /* FOR READ AND ENTER   *
         LA    @F,E03CNT05                                        0100
         ST    @F,88(0,@6)                                        0100
*               GOTO E03IMR05;                /* READ ROUTINE         *
         BC    15,E03IMR05                                        0101
*             END;
*         IF  E01SW10 = '1'B                  /* IF CALLED TO EXECUTE *
*           THEN                              /*   GETMAIN            *
@9FE     TM    203(@6),B'01000000'                                0103
         BC    12,@9FD                                            0103
*             DO;
*               GEN(MVC   AAGETM,DDGETM);     /*   SET RETURN         *
         MVC   AAGETM,DDGETM
         DS    0H
*               ADPTR1 = ADDR(E03CNT10);      /*   ADDRESS AND GO TO  *
         LA    @F,E03CNT10                                        0106
         ST    @F,88(0,@6)                                        0106
*               GOTO E03GMN05;                /*   GETMAIN ROUTINE    *
         BC    15,E03GMN05                                        0107
*             END;                            /* ELSE                 *
*         IF  E01SW13 = '1'B                  /* IF CALLED TO EXECUTE *
*           THEN                              /*   FREEMAIN           *
@9FD     TM    203(@6),B'00001000'                                0109
         BC    12,@9FC                                            0109
*             DO;                             /*   SET RETURN         *
*               GEN(MVC   AAFREM,DDFREM);
         MVC   AAFREM,DDFREM
         DS    0H
*               ADPTR1 = ADDR(E03CNT10);      /*   ADDRESS AND GO TO  *
         LA    @F,E03CNT10                                        0112
         ST    @F,88(0,@6)                                        0112
*               R2  = ADDR(TSTLNG);           /* SET PTR TO BLOCK GO  *
         LA    @2,136(0,@6)                                       0113
*               GOTO E03FMN05;                /*   TO FREEMAIN        *
         BC    15,E03FMN05                                        0114
*             END;                            /* ELSE                 *
*         GOTO  E03CNT15;                     /* MODULE WAS CALLED TO
*                                                PROCESS A PROCEDURE  *
* E03CNT05: LINPTR1 = RCDST;                  /* RETURN POINT FOR READ
*                                                POINT TO RCD JUST    *
E03CNT05 MVC   124(4,@6),292(@6)                                  0117
*         ADPTR1 = TEMP01;                    /*   READ               *
         MVC   88(4,@6),TEMP01                                    0118
* E03CNT10: RETURN;                           /* RETURN POINT FOR
*                                                GETMAIN AND
*                                                FREEMAIN RETURNS TO
*                                                CALLING MODULE       *
         BC    15,@EL01                                           0119
*
*         /************************************************************
*         /*              FOLLOWING CODE PREPARES FOR                 *
*         /*            PROCESSING A CMD PROCEDURE BY                 *
*         /*              READING A RCD IF NECESSARY,                 *
*         /*              DOING A GETMAIN IF NECESSARY                *
*         /*              AND INITIALIZING VARIABLES                  *
*         /************************************************************
* E03CNT15: E03BINSW  = KONX00;               /* INITIALIZE SWITCHES  *
E03CNT15 MVC   E03BINSW(1),KONSTRUC                               0120
*         GEN;
         MVC   AAGETM,DDGETM                 /* MOVING LIST FORM     */
         MVC   AAFREM,DDFREM                 /*   TO DYNAMIC CORE    */
         DS    0H
*         IF E01SW3 = '0'B × E01SW4 = '0'B    /* IF THERE WAS A PROC  *
*           THEN                              /*   STATEMENT OR THE   *
         TM    202(@6),B'00100000'                                0122
         BC    08,@9FB                                            0122
         TM    202(@6),B'00010000'                                0122
         BC    05,@9FA                                            0122
*             DO;                             /*   FIRST LINE OF      *
*               ADPTR1 = ADDR(E03CNT20);      /*   PROCDURE WAS       *
@9FB     LA    @F,E03CNT20                                        0124
         ST    @F,88(0,@6)                                        0124
*               GOTO E03IMR05;                /*   EMPTY- SET RETURN  *
         BC    15,E03IMR05                                        0125
*             END;                            /*   ADDRESS AND GOTO
*                                                  READ A RCD         *
* E03CNT20:                                   /* RETURN POINT         *
*         IF  E01SW8 = '1'B                   /* IF RCD FMT IS        *
*           THEN                              /*   VARIABLE           *
@9FA     EQU   *                                                  0127
E03CNT20 TM    202(@6),B'00000001'                                0127
         BC    12,@9F9                                            0127
*             DO;                             /*   ALIGN RCD LENGTH   *
*               CNVC = RCDLNG;                /*   INDICATOR AND      *
         L     @7,292(0,@6)        
         MVC   200(2,@6),0(@7)                                    0129
*               GMNMIN = CNVA + KON16;        /*   AND CALCULATE LEAST*
         LH    @F,KON16                                           0130
         AH    @F,200(0,@6)                                       0130
         ST    @F,140(0,@6)                                       0130
         BC    15,@9F8                                            0132
*             END;                            /*   AMT OF CORE NEEDED *
*           ELSE                              /* IF RCD FMT IS FIXED  *
*             GMNMIN = DCBLRECL + KON16;      /*   USE DCB RCD LENGTH
*                                                  FOR CALCULATING THE
*                                                  GETMAIN MINIMUM    *
@9F9     LH    @F,KON16                                           0132
         AH    @F,82(0,@6)                                        0132
         ST    @F,140(0,@6)                                       0132
*         IF  E01SW9 = '1'B                   /* IF PROC IS NOT EXEC- *
*           THEN                              /*   UTABLE BYPASS      *
@9F8     TM    203(@6),B'10000000'                                0133
*             GOTO E03SPL05;                  /*   GETMAIN            *
         BC    01,E03SPL05                                        0134
*         R4  = KON78;                        /* SET SUBPOOL INDICATOR*
         LH    @4,KON78                                           0135
*
*         /* NOTE- SEE COMMENT ON KON1992 FOR AN EXPLANATION OF THE   *
*         /*       DEPENDENCY OF THIS CONSTANT ON THE TMP AND I/O     *
*         /*       SERVICE ROUTINES                                   *
*         GMNMAX  = KON1992;                  /* SET NEW GETMAIN MAX  *
         LH    @F,KON1992                                         0136
         ST    @F,144(0,@6)                                       0136
*         ADPTR1  = ADDR(E03CNT25);           /* SET RETURN ADDRESS   *
         LA    @F,E03CNT25                                        0137
         ST    @F,88(0,@6)                                        0137
*         GOTO  E03GMN05;                     /* GO TO GETMAIN      */
         BC    15,E03GMN05                                        0138
* E03CNT25: SP78ADDR = ADDGMN;                /* SAVE STORAGE ADDRESS *
E03CNT25 MVC   156(4,@6),148(@6)                                  0139
*         SP78LNGT  = AMTGMN;                 /* SAVE AMOUNT OF CORE  *
         MVC   160(4,@6),152(@6)                                  0140
*         E01SW12  = '1'B;                    /* INDICATE WE HAVE SP78
*                                                STORAGE OBTAINED     *
         OI    203(@6),B'00010000'                                0141
*         AVL78  = AMTGMN - KON8 - KON16;     /* SAVE AMOUNT WHICH CAN
*                                                BE USED FOR PROCEDURE*
         LH    @F,KON16                                           0142
         LCR   @F,@F                                              0142
         SH    @F,KON8                                            0142
         A     @F,152(0,@6)                                       0142
         STH   @F,AVL78                                           0142
*         PROCIND  = ADDGMN + KON8 + KON16;   /* SAVE ADDR OF OUTPUT  *
         LH    @F,KON16                                           0143
         AH    @F,KON8                                            0143
         A     @F,148(0,@6)                                       0143
         ST    @F,PROCIND                                         0143
*         PROCUR  = PROCIND + KON4;           /* RCD AND OUTPUT DATA  *
         LH    @F,KON4                                            0144
         A     @F,PROCIND                                         0144
         ST    @F,PROCUR                                          0144
*         PRMSTR  = ADDGMN;                   /* SAVE ADDR OF FIRST
*                                                BLOCK OF SP78 CORE   *
         MVC   PRMSTR(4),148(@6)                                  0145
*         PROCNXT  = KON0;                    /* INDICATE NO BLOCK
*                                                FOLLOWING            *
         LH    @F,KON0                                            0146
         L     @7,148(0,@6)        
         ST    @F,0(0,@7)                                         0146
*         PROCSZE  = AMTGMN;                  /* SAVE SIZE OF BLOCK   *
         MVC   4(4,@7),152(@6)                                    0147
*
*         /************************************************************
*         /*              FOLLOWING CODE PREPARES FOR THE             *
*         /*              MOVING OF ONE LINE OF THE PROC              *
*         /*              TO SP78 CORE WITH SUBSTITUTION              *
*         /*              OF SYMBOLIC PARM VALUES                     *
*         /************************************************************
* E03SPL05: IF E01SW8 = '1'B                  /* IF RECORD FORMAT IS  *
*             THEN                            /*   VARIABLE           *
E03SPL05 TM    202(@6),B'00000001'                                0148
         BC    12,@9F7                                            0148
*               DO;                           /*   SET REMAINING CHAR-*
*                 REMCHARC = RCDLNG;          /*  ACTER TO RCD LENGTH *
         L     @7,292(0,@6)        
         MVC   REMCHARC(2),0(@7)                                  0150
*                 REMCHAR  = REMCHAR - KON12; /*  MINUS 4 FOR LENGTH  *
         LH    @F,REMCHAR                                         0151
         SH    @F,KON12                                           0151
         STH   @F,REMCHAR                                         0151
*                 OFFSET  = RCDST + KON12;    /*  INDIATOR AND 8 FOR  *
         LH    @F,KON12                                           0152
         A     @F,292(0,@6)                                       0152
         ST    @F,OFFSET                                          0152
         BC    15,@9F6                                            0154
*               END;                          /*  LINE NUMBERS- OFFSET*
*             ELSE                            /*  = FIRST BYTE OF DATA*
*               DO;                           /* IF RECORD FORMAT IS  *
*                 REMCHAR = DCBLRECL - KON8;  /*  FIXED REMAINING     *
@9F7     LH    @F,KON8                                            0155
         LCR   @F,@F                                              0155
         AH    @F,82(0,@6)                                        0155
         STH   @F,REMCHAR                                         0155
*                 OFFSET  = RCDST;            /*  CHARACTERS = RCD    *
         MVC   OFFSET(4),292(@6)                                  0156
*                                             /*  LENGTH MINUS 8 FOR
*                                                 LINE NUMBERS- OFFSET
*                                                 FIRST BYTE OF DATA  *
*                 DO I = REMCHAR TO 1 BY -1;  /* REMOVE BLANKS  Y02676*
         LH    @F,REMCHAR                                         0157
         BC    15,@DO9F4                                          0157
*                                             /* FROM END OF    Y02676*
*                   IF INPLIN(I) ^= KBLNK     /* FIXED BLOCK    Y02676*
*                     THEN                    /* RECORDS AND    Y02676*
@DO9F5   L     @7,I                                               0158
         L     @8,OFFSET                                          0158
         LA    @A,0(@7,@8)                                        0158
         BCTR  @A,0                                               0158
         CLC   0(1,@A),TCHAR                                      0158
         BC    08,@9F1                                            0158
*                       DO;                   /* SET NEW LINE   Y02676*
*                         REMCHAR = I;        /* LENGTH         Y02676*
         MVC   REMCHAR(2),I+2                                     0160
*                         GO TO E03SPL06;                     /*Y02676*
         BC    15,E03SPL06                                        0161
*                       END;                                  /*Y02676*
*                 END;                                        /*Y02676*
*
*                 IF CONTPLUS = '1'B          /* WHEN THE CON-  Y02676*
*                   THEN                      /* TINUATION LINE Y02676*
@9F1     L     @F,I                                               0163
         BCTR  @F,0                                               0163
@DO9F4   ST    @F,I                                               0163
         CH    @F,@D1                                             0163
         BC    10,@DO9F5                                          0163
         TM    E03BINSW,B'00001000'                               0164
         BC    12,@9F0                                            0164
*                     DO;                     /* FOR PLUS SIGN  Y02676*
*                       CONTPLUS = '0'B;      /* PROCESSING IS  Y02676*
         NI    E03BINSW,B'01110011'                               0166
*                       ENDDLM = '0'B;        /* NULL THEN      Y02676*
*                       E03SW1 = '0'B;        /* RESET CONTINUATION AND
*                                                ENDING DELIMITER NEEDE
*                                                SWITCHES AND   Y02676*
*                       ADPTR1 = ADDR(E03UAR10); /* GO GET THE  Y02676*
         LA    @F,E03UAR10                                        0169
         ST    @F,88(0,@6)                                        0169
*                       GO TO E03IMR05;       /* NEXT RECORD    Y02676*
         BC    15,E03IMR05                                        0170
*                     END;                                    /*Y02676*
*                 GO TO E03SPL25;             /* IF THE PREVIOUS LINE
*                                                WAS NOT CONTINUED WITH
*                                                A PLUS SIGN THEN BYPAS
*                                                THE & SEARCH   Y02676*
*               END;                                          /*Y02676*
*
* E03SPL06:                                   /* WHEN THE       Y02676*
*         IF CONTPLUS = '1'B                  /* PREVIOUS LINE  Y02676*
*           THEN                              /* WAS CONTINUED  Y02676*
@9F6     EQU   *                                                  0174
E03SPL06 TM    E03BINSW,B'00001000'                               0174
         BC    12,@9EF                                            0174
*             DO;                             /* WITH A PLUS    Y02676*
*               CONTPLUS = '0'B;              /* THEN WE MUST REMOVE AL
*                                                LEADING SEPERATORS AND
*                                                COMMENTS       Y02676*
         NI    E03BINSW,B'11110111'                               0176
*               I = KON1;                     /* INIT INDEX VAR Y02676*
         LH    @F,KON1                                            0177
         ST    @F,I                                               0177
* E03PLSTR:     IF ENDDLM = '1'B              /* IF A COMMENT   Y02676*
*                 THEN                        /* WAS CONTINUED FROM THE
*                                                PREVIOUS RECORD THEN
*                                                RESUME SCAN    Y02676*
E03PLSTR TM    E03BINSW,B'00000100'                               0178
         BC    12,@9EE                                            0178
*                   DO;                       /* FOR ASTERISK   Y02676*
*                     ENDDLM = '0'B;          /* SLASH          Y02676*
         NI    E03BINSW,B'11111011'                               0180
*                     GO TO E03SPL08;                         /*Y02676*
         BC    15,E03SPL08                                        0181
*                   END;                                      /*Y02676*
*
*
*               IF I <= REMCHAR               /* MAKE SURE THERE IS AT
*                                                LEAST ONE CHARACTER
*                                                IN THE INPUT RECORD
*                                                BEFORE STARTING SCAN
*                                                               Y02676*
*                 THEN                                        /*Y02676*
@9EE     LH    @F,REMCHAR                                         0183
         C     @F,I                                               0183
         BC    04,@9ED                                            0183
*                   DO I = I TO REMCHAR;      /* REMOVE         Y02676*
         L     @F,I                                               0184
         BC    15,@DO9EB                                          0184
*                     IF INPLIN(I) ^= KBLNK & /* SEPERATORS     Y02676*
*                        INPLIN(I) ^= KCOM  & /* FROM  THE      Y02676*
*                        INPLIN(I) ^= KTAB    /* CONTINUATION   Y02676*
*                       THEN                  /* RECORD         Y02676*
@DO9EC   L     @7,I                                               0185
         L     @8,OFFSET                                          0185
         LA    @A,0(@7,@8)                                        0185
         BCTR  @A,0                                               0185
         CLC   0(1,@A),TCHAR                                      0185
         BC    08,@9E8                                            0185
         CLC   0(1,@A),TCHAR+1                                    0185
         BC    08,@9E7                                            0185
         CLC   0(1,@A),TCHAR+2                                    0185
*                         GO TO E03SPL07;                     /*Y02676*
         BC    07,E03SPL07                                        0186
*                   END;                                      /*Y02676*
@9E6     EQU   *                                                  0187
@9E7     EQU   *                                                  0187
*               E03SW1 = '0'B;                /* WHEN THE RECORD IS NUL
*                                                RESET CONT INDICATOR
*                                                SET RETURN POINT TO
*                                                COMPLETE THE PROC
*                                                RECORD ALREADY IN SP
*                                                78 AND GO GET THE
*                                                NEXT RECORD    Y02676*
@9E8     L     @F,I                                               0187
         AH    @F,@D1                                             0187
@DO9EB   ST    @F,I                                               0187
         CH    @F,REMCHAR                                         0187
         BC    12,@DO9EC                                          0187
@9ED     NI    E03BINSW,B'01111111'                               0188
*               ADPTR1 = ADDR(E03UAR10);                      /*Y02676*
         LA    @F,E03UAR10                                        0189
         ST    @F,88(0,@6)                                        0189
*               GO TO E03IMR05;                               /*Y02676*
         BC    15,E03IMR05                                        0190
*
* E03SPL07:                                   /* IF THERE IS    Y02676*
*               IF I = REMCHAR ×              /* ONE CHAR LEFT  Y02676*
*                  INPLIN(I:I+1) ^= KONSLAST  /* OR THERE IS NO SLASH
*                                                ASTERISK FIRST WE
*                                                MUST BYPASS FURTHER
*                                                COMMENT CHECKS Y02676*
*                 THEN                                        /*Y02676*
E03SPL07 LH    @F,REMCHAR                                         0191
         C     @F,I                                               0191
         BC    08,@9E5                                            0191
         L     @7,I                                               0191
         L     @8,OFFSET                                          0191
         LA    @A,0(@7,@8)                                        0191
         BCTR  @A,0                                               0191
         CLC   0(2,@A),KONSLAST                                   0191
         BC    08,@9E4                                            0191
*                   DO;                                       /*Y02676*
*                     IF I = REMCHAR &        /* IF THERE IS    Y02676*
*                        INPLIN(I) = KCONT ×  /* ONLY ONE CHAR  Y02676*
*                        INPLIN(I) = KCONTP   /* LEFT AND IT IS A
*                                                CONTINUATION CHAR THEN
*                                                SET INDICATOR AND
*                                                RETURN POINT TO PREVEN
*                                                MOVING THE RECORD TO
*                                                SUBPOOL 78     Y02676*
*                       THEN                                  /*Y02676*
@9E5     LH    @F,REMCHAR                                         0193
         C     @F,I                                               0193
         BC    07,@9E3                                            0193
         L     @7,I                                               0193
         L     @8,OFFSET                                          0193
         LA    @A,0(@7,@8)                                        0193
         BCTR  @A,0                                               0193
         CLC   0(1,@A),KCONT                                      0193
         BC    08,@9E2                                            0193
@9E3     L     @7,I                                               0193
         L     @8,OFFSET                                          0193
         LA    @A,0(@7,@8)                                        0193
         BCTR  @A,0                                               0193
         CLC   0(1,@A),KCONTP                                     0193
         BC    07,@9E1                                            0193
*                         DO;                                 /*Y02676*
*                           CONTPLUS = '1'B;                  /*Y02676*
@9E2     OI    E03BINSW,B'00001000'                               0195
*                           ADPTR1 = ADDR(E03SPL05);          /*Y02676*
         LA    @F,E03SPL05                                        0196
         ST    @F,88(0,@6)                                        0196
*                           GO TO E03IMR05;                   /*Y02676*
         BC    15,E03IMR05                                        0197
*                         END;                                /*Y02676*
*
*                     OFFSET = I - KON1 + OFFSET; /* OTHERWISE  Y02676*
@9E1     L     @F,OFFSET                                          0199
         SH    @F,KON1                                            0199
         A     @F,I                                               0199
         ST    @F,OFFSET                                          0199
*                     REMCHAR = REMCHAR - I + KON1; /* ADJUST   Y02676*
         LH    @F,KON1                                            0200
         S     @F,I                                               0200
         AH    @F,REMCHAR                                         0200
         STH   @F,REMCHAR                                         0200
*                     GO TO E03SPL10;         /* RECORD START AND LENGT
*                                                GO PROCESS NORMALLY
*                                                               Y02676*
         BC    15,E03SPL10                                        0201
*                   END;                                      /*Y02676*
*
*               I = KON2 + I;                 /* UPDATE INDEX PAST THE
*                                                SLASH ASTERISK Y02676*
@9E4     L     @F,I                                               0203
         AH    @F,KON2                                            0203
         ST    @F,I                                               0203
* E03SPL08:
*               IF I < REMCHAR                /* MAKE SURE THERE IS
*                                                ENOUGH CHARACTERS FOR
*                                                THE ASTERISK SLASH
*                                                CHECK          Y02676*
*                 THEN
E03SPL08 LH    @F,REMCHAR                                         0204
         C     @F,I                                               0204
         BC    12,@9E0                                            0204
*                   DO I = I TO REMCHAR - 1;  /* SCAN FOR       Y02676*
         L     @F,I                                               0205
         ST    @F,I                                               0205
@DO9DF   LH    @F,REMCHAR                                         0205
         BCTR  @F,0                                               0205
         C     @F,I                                               0205
         BC    04,@DO9DC                                          0205
         BC    15,@DO9DD                                          0205
@DO9DE   LA    @F,1                                               0205
         A     @F,I                                               0205
         ST    @F,I                                               0205
         BC    15,@DO9DF                                          0205
*                     IF INPLIN(I:I+1) = KONASTSL /* ASTERISK   Y02676*
*                       THEN                  /* SLASH          Y02676*
@DO9DD   L     @7,I                                               0206
         L     @8,OFFSET                                          0206
         LA    @A,0(@7,@8)                                        0206
         BCTR  @A,0                                               0206
         CLC   0(2,@A),KONASTSL                                   0206
         BC    07,@9DB                                            0206
*                         DO;                                 /*Y02676*
*                           I = KON2 + I;     /* IF FOUND GO    Y02676*
         L     @F,I                                               0208
         AH    @F,KON2                                            0208
         ST    @F,I                                               0208
*                           GO TO E03PLSTR;   /* LOOK FOR MORE  Y02676*
         BC    15,E03PLSTR                                        0209
*                         END;                                /*Y02676*
*                   END;                                      /*Y02676*
*
*              IF INPLIN(REMCHAR) = KCONT ×   /* IF COMMENT IS  Y02676*
*                 INPLIN(REMCHAR) = KCONTP    /* CONTINUED SET INDICATO
*                                                AND RETURN POINT TO
*                                                PREVENT MOVING TO
*                                                SUBPOOL 78     Y02676*
*                THEN
@DO9DC   EQU   *                                                  0211
@9E0     EQU   *                                                  0212
         LH    @7,REMCHAR                                         0212
         L     @8,OFFSET                                          0212
         LA    @A,0(@7,@8)                                        0212
         BCTR  @A,0                                               0212
         CLC   0(1,@A),KCONT                                      0212
         BC    08,@9DA                                            0212
         CLC   0(1,@A),KCONTP                                     0212
         BC    07,@9D9                                            0212
*                  DO;                                        /*Y02676*
*                    ENDDLM = '1'B;                           /*Y02676*
@9DA     OI    E03BINSW,B'00001100'                               0214
*                    CONTPLUS = '1'B;                         /*Y02676*
*                    ADPTR1 = ADDR(E03SPL05);                 /*Y02676*
         LA    @F,E03SPL05                                        0216
         ST    @F,88(0,@6)                                        0216
         BC    15,@9D8                                            0218
*                  END;                                       /*Y02676*
*                ELSE                         /* OTHERWISE TURN OFF
*                                                CONTINUATION INDICATOR
*                                                AND SET THE RETURN
*                                                POINT TO COMPLETE THE
*                                                RECORD ALREADY IN
*                                                SUBPOOL 78     Y02676*
*                  DO;                                        /*Y02676*
*                    E03SW1 = '0'B;                           /*Y02676*
@9D9     NI    E03BINSW,B'01111111'                               0219
*                    ADPTR1 = ADDR(E03UAR10);                 /*Y02676*
         LA    @F,E03UAR10                                        0220
         ST    @F,88(0,@6)                                        0220
*                  END;                                       /*Y02676*
* E03SPL09:
*              GO TO E03IMR05;                /* EITHER CASE ALWAYS GET
*                                                NEXT RECORD   Y02676*/
         BC    15,E03IMR05                                        0222
*            END;                                            /*Y02676*/
*         /************************************************************
*         /*              FOLLOWING SECTION OF CODE DOES              *
*         /*              A SCAN OF THE INPUT LINE TO                 *
*         /*              FIND ANY SYMBOLIC PARAMETERS                *
*         /*              CONTAINED THEREIN                           *
*         /************************************************************
* E03SPL10: IF E01SW3 = '1'B                  /* IF THERE WAS NO PROC *
*             THEN                            /*  STMT- BYPASS SEARCH *
@9EF     EQU   *                                                  0224
E03SPL10 TM    202(@6),B'00100000'                                0224
*               GOTO E03SPL25;                /*  FOR SYMBOLIC PARMS  *
         BC    01,E03SPL25                                        0225
*         R2  = REMCHAR;                      /* SET REG2 TO NUMBER OF
*                                                BYTES LEFT IN INPUT
*                                                LINE                 *
         LH    @2,REMCHAR                                         0226
*         R3  = OFFSET;                       /* SET REG3 TO STARTING
*                                                ADDR FOR SEARCH      *
         L     @3,OFFSET                                          0227
* E03SPL15: R2 = R2 - KON1;                   /* REDUCE BY ONE THE
*                                                NUMBER OF BYTES TO
*                                                BE SCANNED FOR TRANS
*                                                AND TEST INSTRUCTION *
E03SPL15 SH    @2,KON1                                            0228
*         IF  R2 < KON0                       /*  IF ENTIRE LINE HAS  *
*           THEN                              /*  BEEN SCANNED GO TO  *
         CH    @2,KON0                                            0229
*             GOTO E03SPL25;                  /*  MOVE LINE TO SP78   *
         BC    04,E03SPL25                                        0230
*         R1 = KON0;                          /* RE-INIT R1     Y01676*
         LH    @1,KON0                                            0231
*         GEN;
         EX    R2,TRTINST          EXECUTE TRANSLATE AND TEST INSTRUCT
         BNZ   E03SPL30            IF AMPERSAND FOUND EXIT LOOP
         DS    0H
*         R3  = R3 + (R2 // KON256) + KON1;   /* UPDATE ADDRESS AT
*                                                WHICH SCAN STARTS    *
         LR    @E,@2                                              0233
         SRDA  @E,32                                              0233
         LH    @0,KON256                                          0233
         DR    @E,@0                                              0233
         AR    @E,@3                                              0233
         AH    @E,KON1                                            0233
         LR    @3,@E                                              0233
*         R2  = (R2 / KON256) * KON256;       /* ELIMINATE LOW EIGHT
*                                                BITS WHICH ARE THE
*                                                NUMBER OF BYTES
*                                                JUST SCANNED         *
         LR    @E,@2                                              0234
         SRDA  @E,32                                              0234
         LH    @0,KON256                                          0234
         DR    @E,@0                                              0234
         MH    @F,KON256                                          0234
         LR    @2,@F                                              0234
*         GOTO  E03SPL15;                     /* LOOP TO SCAN NEXT 256
*                                                BYTES                *
         BC    15,E03SPL15                                        0235
*
*         /***********************************************************/
*         /*              THE FOLLOWING CODE IS EXECUTED             */
*         /*              WHEN THE REMAINING PORTION OF              */
*         /*              THE LINE SCANNED DID NOT CONT-             */
*         /*              AIN AN & (SYMBOLIC PARM) - IT              */
*         /*              SETS INDICATORS FOR MOVING THE             */
*         /*              LINE TO SP78 CORE WITHOUT                  */
*         /*              SEARCHING SYMBOLIC PARM TABLES             */
*         /***********************************************************/
* E03SPL25: TEMP01 = REMCHAR;                 /* SET START OF SYMBOLIC
*                                                PARM TO END PARM
*                                                TO 1 PAST END OF
*                                                RECORD TO BYPASS
*                                                SEARCH FOR PARM      *
E03SPL25 LH    @F,REMCHAR                                         0236
         ST    @F,TEMP01                                          0236
*         IF INPLIN(TEMP01) = KCONTP          /* IS LINE        Y02676*
*           THEN                              /*  CONTINUED     Y02676*
         LR    @7,@F                                              0237
         L     @8,OFFSET                                          0237
         LA    @A,0(@7,@8)                                        0237
         BCTR  @A,0                                               0237
         CLC   0(1,@A),KCONTP                                     0237
         BC    07,@9D7                                            0237
*             CONTPLUS = '1'B;                /* WITH PLUS      Y02676*
         OI    E03BINSW,B'00001000'                               0238
*         IF  INPLIN(TEMP01)  = KCONT ×       /* IF LINE IS TO BE     *
*             CONTPLUS = '1'B                 /* CONTINUED      Y02676*
*           THEN                              /*   THEN               *
@9D7     LA    @A,0(@7,@8)                                        0239
         BCTR  @A,0                                               0239
         CLC   0(1,@A),KCONT                                      0239
         BC    08,@9D6                                            0239
         TM    E03BINSW,B'00001000'                               0239
         BC    12,@9D5                                            0239
*             DO;                             /* SET THE CONTINUATION *
*               E03SW1 = '1'B;                /*   SWITCH ON          *
@9D6     OI    E03BINSW,B'10000000'                               0241
*               REMCHAR = REMCHAR - KON1;     /* REDUCES REMAINING    *
         LH    @F,REMCHAR                                         0242
         SH    @F,KON1                                            0242
         STH   @F,REMCHAR                                         0242
         BC    15,@9D4                                            0244
*             END;                            /*   CHAR CNT TO AVOID  *
*           ELSE                              /*   PROCESSING DASH    *
*             TEMP01 = TEMP01 + KON1;         /* SET TEMP01 TO 1 PAST
*                                                END OF RECORD
*                                                CONTINUATION CHAR    *
@9D5     LH    @F,KON1                                            0244
         A     @F,TEMP01                                          0244
         ST    @F,TEMP01                                          0244
*         GOTO  E03PVL10;                     /* START MOVING DATA    *
         BC    15,E03PVL10                                        0245
*
*         /************************************************************
*         /*              FOLLOWING CODE DETERMINES                   *
*         /*              WHETHER THE & IS FOR A                      *
*         /*              SYMBOLIC PARM OR IS TO REMAIN               *
*         /*              IN PROC, SETS PROPER INDICATORS             *
*         /*              AND BRANCHES TO SYMBOLIC PARM               *
*         /*              DEFINITION ROUTINE, MOVE ROUT-              *
*         /*              INE OR ERROR ROUTINE                        *
*         /************************************************************
* E03SPL30: TEMP01 = R1 + KON1 - OFFSET;      /* SET TEMP01 = LOCATION
*                                                OF & RELATIVE TO
*                                                START OF SCAN        *
E03SPL30 L     @F,OFFSET                                          0246
         LCR   @F,@F                                              0246
         AH    @F,KON1                                            0246
         AR    @F,@1                                              0246
         ST    @F,TEMP01                                          0246
*         IF  INPLIN(TEMP01 + KON1) = KAMP    /* IF THIS IS AN && THEN*
*           THEN                              /*  ALTER TEMP01 SO THAT*
         LH    @7,KON1                                            0247
         A     @7,TEMP01                                          0247
         L     @8,OFFSET                                          0247
         LA    @A,0(@7,@8)                                        0247
         BCTR  @A,0                                               0247
         CLC   0(1,@A),TCHAR+3                                    0247
         BC    07,@9D3                                            0247
*             DO;                             /*FIRST & WILL STAY IN  *
*               TEMP01 = TEMP01 + KON1;       /*  PROC- AND GO TO MOVE*
         LH    @F,KON1                                            0249
         A     @F,TEMP01                                          0249
         ST    @F,TEMP01                                          0249
*               GOTO E03PVL10;                /*  ROUTINE             *
         BC    15,E03PVL10                                        0250
*             END;
*
*         /************************************************************
*         /*              FOLLOWING CODE DETERMINES THE               *
*         /*              LENGTH OF THE SYMBOLIC PARM,                *
*         /*              FINDS WHETHER THE LINE IS                   *
*         /*              CONTINUED AND EXITS TO THE                  *
*         /*              ROUTINE WHICH SEARCHES PARM                 *
*         /*              TABLES                                      *
*         /************************************************************
*         DO  TEMP02 = TEMP01 + KON1 TO REMCHAR;
@9D3     LH    @F,KON1                                            0252
         A     @F,TEMP01                                          0252
         BC    15,@DO9D1                                          0252
*                                             /* SCAN FOR END OF      *
*           DO TEMP03 = KON1 TO KON5;         /*  SYMBOLIC PARM TO END*
@DO9D2   LH    @F,KON1                                            0253
         BC    15,@DO9CD                                          0253
*             IF INPLIN(TEMP02) = TCHAR(TEMP03)/* OF INPUT LINE- WHEN *
*               THEN                          /*  END IS FOUND GOTO   *
@DO9CE   L     @7,TEMP03                                          0254
         LA    @E,TCHAR-1(@7)                                     0254
         L     @8,TEMP02                                          0254
         L     @7,OFFSET                                          0254
         LA    @A,0(@8,@7)                                        0254
         BCTR  @A,0                                               0254
         CLC   0(1,@A),0(@E)                                      0254
*                 GOTO E03PDL05;              /*  SEARCH ROUTINE      *
         BC    08,E03PDL05                                        0255
*           END;
*         END;
         L     @F,TEMP03                                          0256
         AH    @F,@D1                                             0256
@DO9CD   ST    @F,TEMP03                                          0256
         CH    @F,KON5                                            0256
         BC    12,@DO9CE                                          0256
*
*         IF INPLIN(TEMP02 - KON1) = KCONTP   /* IS LINE        Y02676*
*           THEN                              /* CONTINUED      Y02676*
         L     @F,TEMP02                                          0257
         AH    @F,@D1                                             0257
@DO9D1   ST    @F,TEMP02                                          0257
         CH    @F,REMCHAR                                         0257
         BC    12,@DO9D2                                          0257
         LH    @7,KON1                                            0258
         LCR   @7,@7                                              0258
         A     @7,TEMP02                                          0258
         L     @8,OFFSET                                          0258
         LA    @A,0(@7,@8)                                        0258
         BCTR  @A,0                                               0258
         CLC   0(1,@A),KCONTP                                     0258
         BC    07,@9CA                                            0258
*             CONTPLUS = '1'B;                /* WITH A PLUS    Y02676*
         OI    E03BINSW,B'00001000'                               0259
*
*         IF  INPLIN(TEMP02 - KON1) = KCONT × /* IF LINE IS TO BE     *
*             CONTPLUS = '1'B                 /* CONTINUED      Y02676*
*           THEN                              /* SET THE              *
@9CA     LH    @7,KON1                                            0260
         LCR   @7,@7                                              0260
         A     @7,TEMP02                                          0260
         LA    @A,0(@7,@8)                                        0260
         BCTR  @A,0                                               0260
         CLC   0(1,@A),KCONT                                      0260
         BC    08,@9C9                                            0260
         TM    E03BINSW,B'00001000'                               0260
         BC    12,@9C8                                            0260
*             DO;                             /*  CONTINUATION        *
*               E03SW1 = '1'B;                /*  SWITCH ON ALTER THE *
@9C9     OI    E03BINSW,B'10000000'                               0262
*               REMCHAR = REMCHAR - KON1;     /*  REMAINING CHAR COUNT*
         LH    @F,REMCHAR                                         0263
         SH    @F,KON1                                            0263
         STH   @F,REMCHAR                                         0263
*               TEMP02 = TEMP02 - KON1;       /*  AND END OF PARM PTR *
         L     @F,TEMP02                                          0264
         SH    @F,KON1                                            0264
         ST    @F,TEMP02                                          0264
*             END;                            /*  TO SKIP CONTINUATION
*                                                 CHARACTER AND ENTER
*                                                 SEARCH ROUTINE      *
*
*         /************************************************************
*         /*              FOLLOWING IS THE SEARCH                     *
*         /*              ROUTINE- IT SEARCHES ATAB FOR               *
*         /*              THE SYMBOLIC PARAMATER AND                  *
*         /*              EXITS TO THE VALUE LOCATOR                  *
*         /*              ROUTINE IF A MATCH IS FOUND OR              *
*         /*              TO THE MOVE ROUTINE IF THERE                *
*         /*              IS NO MATCH                                 *
*         /************************************************************
* E03PDL05: R4 = ABLK1;                       /* SET REG4 POINTING TO
*                                                1ST BLOCK OF ATAB    *
@9C8     EQU   *                                                  0266
E03PDL05 L     @4,284(0,@6)                                       0266
*         R5  = R4 + KON12;                   /* SET REG5 POINTING TO
*                                                CURRENT ELEMENT      *
         LH    @5,KON12                                           0267
         AR    @5,@4                                              0267
*         TEMP03  = TEMP02 - TEMP01 - KON1;   /* SET TEMP03 TO LNGTH
*                                                OF PARM              *
         LH    @F,KON1                                            0268
         LCR   @F,@F                                              0268
         S     @F,TEMP01                                          0268
         A     @F,TEMP02                                          0268
         ST    @F,TEMP03                                          0268
*         IF  TEMP03 = KON0                   /* IF THERE WAS ONLY AN *
*           THEN                              /*  AMPERSAND,SET PARM  *
         LH    @F,KON0                                            0269
         C     @F,TEMP03                                          0269
         BC    07,@9C7                                            0269
*             DO;                             /*  VALUE LENGTH TO ZERO*
*               TEMP04 = KON0;                /*  AND EXIT TO ROUTINE *
         ST    @F,TEMP04                                          0271
*               GOTO E03ITO05;                /*  WHICH MOVES RCD AND *
         BC    15,E03ITO05                                        0272
*             END;                            /*  VALUE TO SP78 AREA  *
* E03PDL10: IF ATABIND = KON0                 /* IF THERE WERE NO PARMS
*             THEN                            /*  IT IS AN ERROR SO   *
@9C7     EQU   *                                                  0274
E03PDL10 LH    @F,KON0                                            0274
         C     @F,172(0,@6)                                       0274
*              GOTO E03PDL15;                 /*  GO TO PUT MSG       *
         BC    08,E03PDL15                                        0275
*         CNVC = R5 -> ATABELNC;              /* ALIGN LENGTH OF THIS
*                                                ATAB ELEMENT         *
         MVC   200(2,@6),5(@5)                                    0276
*         IF  TEMP03 = CNVA                   /* IF ELMT LENGTH =     *
*           THEN                              /*  PARM LENGTH AND     *
         LH    @F,200(0,@6)                                       0277
         C     @F,TEMP03                                          0277
         BC    07,@9C6                                            0277
*             IF R5 -> ATABDAT(1:CNVA) = INPLIN(TEMP01+1:TEMP02-1)
*               THEN                          /*  ELMT = PARM - GO TO *
         LA    @7,1                                               0278
         A     @7,TEMP01                                          0278
         L     @8,OFFSET                                          0278
         LA    @E,0(@7,@8)                                        0278
         BCTR  @E,0                                               0278
         LH    @7,200(0,@6)                                       0278
         BCTR  @7,0                                               0278
         LA    @A,7(0,@5)                                         0278
         EX    @7,@CLC                                            0278
*                 GOTO E03PVL05;              /*  ROUTINE TO LOCATE
*                                                 PARM'S VALUE        *
         BC    08,E03PVL05                                        0279
*         IF  (R5 -> ATABFLGS & KONX20) ^= KONX20
*                                             /* IF THIS IS NOT END   *
*           THEN                              /*  OF ATAB BLOCK UPDATE*
@9C6     MVC   @CTEMP2(1),KONSTRUC+1                              0280
         NC    @CTEMP2(1),4(@5)                                   0280
         CLC   @CTEMP2(1),KONSTRUC+1                              0280
         BC    08,@9C5                                            0280
*             DO;                             /*  TO NEXT ELMT AND    *
*               R5 = R5 + CNVA + KON7;        /*  START COMPARE FOR   *
         LH    @F,KON7                                            0282
         AH    @F,200(0,@6)                                       0282
         AR    @5,@F                                              0282
*               GOTO E03PDL10;                /*  IT                  *
         BC    15,E03PDL10                                        0283
*             END;                            /* OTHERWISE            *
*         IF  R4 -> ATABNXT ^= KON0           /* IF LAST ATAB BLOCK   *
*           THEN                              /*  HAS NOT BEEN REACHED*
@9C5     LH    @F,KON0                                            0285
         C     @F,4(0,@4)                                         0285
         BC    08,@9C4                                            0285
*             DO;                             /*  UPDATE TO NEXT BLOCK*
*               R4 = R4 -> ATABNXT;           /*  AND START COMPARING *
         L     @4,4(0,@4)                                         0287
*               R5 = R4 + KON12;              /*  WITH ITS FIRST ELMT *
         LH    @5,KON12                                           0288
         AR    @5,@4                                              0288
*               GOTO E03PDL10;
         BC    15,E03PDL10                                        0289
*             END;                            /* OTHERWISE- SINCE LAST*
* E03PDL15: E01SW9 = '1'B;                    /*  BLOCK HAS BEEN PROC-*
@9C4     EQU   *                                                  0291
E03PDL15 OI    203(@6),B'10000000'                                0291
*         ADPTR1 = ADDR(E03ITO05);            /* SET RETURN ADDR      *
         LA    @F,E03ITO05                                        0292
         ST    @F,88(0,@6)                                        0292
*         LVL1NO = KON13;                     /* SET 1ST LEVEL MSG    *
         MVC   304(2,@6),KON13                                    0293
*         LVL2NO = KON0;                      /* SET 2ND LEVEL MSG    *
         MVC   306(2,@6),KON0                                     0294
*         VARSGADR = OFFSET + TEMP01;         /* SET PTR TO VARIABLE  *
         L     @F,TEMP01                                          0295
         A     @F,OFFSET                                          0295
         ST    @F,@TEMP4                                          0295
         MVC   297(3,@6),@TEMP4+1                                 0295
*         CNVA  = TEMP03 + KON4;              /* PORTION OF MSG       *
         LH    @F,KON4                                            0296
         A     @F,TEMP03                                          0296
         STH   @F,200(0,@6)                                       0296
*         /*                                                    A42619*
*         IF CNVA ^< KON256                   /* IF TOO LARGE FOR ONE *
*           THEN                              /* BYTE           A42619*
         LH    @F,KON256                                          0297
         CH    @F,200(0,@6)                                       0297
         BC    02,@9C3                                            0297
*             CNVA = KON256 - KON1;           /* REDUCE IT      A42619*
         SH    @F,KON1                                            0298
         STH   @F,200(0,@6)                                       0298
*         VARSGLNG  = CNVC(2);                /* SET LENGTH           *
@9C3     MVC   296(1,@6),201(@6)                                  0299
*         GOTO E03MML05;                      /* GO TO MESSAGE MOD    *
         BC    15,E03MML05                                        0300
*
*         /***********************************************************/
*         /*              FOLLOWING IS THE VALUE LOCATOR             */
*         /*              ROUTINE WHICH DETERMINES THE               */
*         /*              SIZE AND LOCATION OF THE VALUE             */
*         /*              ASSOCIATED WITH THE SPECIFIED              */
*         /*              PARAMETER - EXIT IS MADE TO                */
*         /*              THE MOVE ROUTINE                           */
*         /***********************************************************/
* E03PVL05: TSTLNGC = R5 -> FTABPTR;          /* ALIGN PTR TO FTAB    *
E03PVL05 MVC   136(4,@6),0(@5)                                    0301
*         IF  TSTLNG = KON0                   /* IF IT WAS A KWRD W/O *
*           THEN                              /*   VALUE WHICH WAS NOT*
         LH    @F,KON0                                            0302
         C     @F,136(0,@6)                                       0302
         BC    07,@9C2                                            0302
*             DO;                             /*   SPECIFIED - SET    *
*               TEMP04 = KON0;                /*   LENGTH = ZERO AND  *
         ST    @F,TEMP04                                          0304
*               GOTO E03ITO05;                /* GO TO START MOVE     *
         BC    15,E03ITO05                                        0305
*             END;
*         IF  TSTLNG = KON1                   /* IF ZERO IT           *
*           THEN                              /*  MEANS A KWRD W/O    *
@9C2     LH    @F,KON1                                            0307
         C     @F,136(0,@6)                                       0307
         BC    07,@9C1                                            0307
*             DO;                             /*  VALUE WHICH WAS NOT *
*               TEMP04 = CNVA;                /*  SO SET KWRD W/O VAL *
         LH    @F,200(0,@6)                                       0309
         ST    @F,TEMP04                                          0309
*               ATABCUR = R5 + KON7;          /*  SWITCH SET LENGTH OF*
         LH    @F,KON7                                            0310
         AR    @F,@5                                              0310
         ST    @F,176(0,@6)                                       0310
*               GOTO E03ITO05;                /*  VALUE = LENGTH OF   *
         BC    15,E03ITO05                                        0311
*             END;                            /*  KWRD AND GOTO MOVE  *
*         R4  = TSTLNG;                       /* OTHERWISE SET LENGTH *
@9C1     L     @4,136(0,@6)                                       0313
*         CNVC  = R4 -> FTABELNG(3:4);        /*  OF VALUE = FTAB ELMT*
         MVC   200(2,@6),2(@4)                                    0314
*         TEMP04  = CNVA;                     /*  LENGTH AND GOTO     *
         LH    @F,200(0,@6)                                       0315
         ST    @F,TEMP04                                          0315
*         ATABCUR  = R4 + KON4;               /*   MOVE ROUTINE       *
         LH    @F,KON4                                            0316
         AR    @F,@4                                              0316
         ST    @F,176(0,@6)                                       0316
*         GOTO  E03ITO05;
         BC    15,E03ITO05                                        0317
*         /************************************************************
*         /*              FOLLOWING CODE IS ENTERED WHEN              *
*         /*              THE AMPERSAND DID NOT INDICATE              *
*         /*              A SYMBOLIC PARAMETER - IT SETS              *
*         /*              VARIABLES TO INDICATE THAT                  *
*         /*              VALUE IS NULL AND THEN MOVE                 *
*         /*              ROUTINE IS ENTERED                          *
*         /************************************************************
* E03PVL10: TEMP04 = KON0;                    /* SET VALUE LENGTH = 0 *
E03PVL10 LH    @F,KON0                                            0318
         ST    @F,TEMP04                                          0318
*         TEMP02  = TEMP01 + KON1;            /* SET END OF PARM PTR
*                                                TO SHOW ONLY &       *
         LH    @F,KON1                                            0319
         A     @F,TEMP01                                          0319
         ST    @F,TEMP02                                          0319
*
*         /************************************************************
*         /*              FOLLOWING IS THE MOVE ROUTINE-              *
*         /*               IF PREVIOUS ERRORS HAVE NOT                *
*         /*               PRECLUDED EXECUTION THIS                   *
*         /*               ROUTINE MOVES A PORTION OF                 *
*         /*               THE INPUT LINE AND THE PARM                *
*         /*               VALUE TO SP78 USING THE                    *
*         /*               GENERALIZED MOVE ROUTINE                   *
*         /************************************************************
* E03ITO05:IF E01SW9 = '1'B                   /* IF EXECUTION OF THE  *
*            THEN                              /*  PROC IS NOT POSSIBLE
E03ITO05 TM    203(@6),B'10000000'                                0320
*              GOTO E03UAR05;                 /*  BYPASS THE MOVE     *
         BC    01,E03UAR05                                        0321
*         TEMP03  = TEMP01 - KON1 + TEMP04;   /* SET TEMP03 TO TOTAL
*                                                BYTES TO BE MOVED    *
         L     @F,TEMP04                                          0322
         SH    @F,KON1                                            0322
         A     @F,TEMP01                                          0322
         ST    @F,TEMP03                                          0322
*         IF PROCIND = PROCUR - KON4          /* IF THIS IS START OF  *
*           THEN                              /*  RCD ADD FOUR FOR THE*
         L     @F,PROCUR                                          0323
         SH    @F,KON4                                            0323
         C     @F,PROCIND                                         0323
         BC    07,@9C0                                            0323
*             CNVA = KON4;                    /*  RCD LNGTH INDICATOR *
         MVC   200(2,@6),KON4                                     0324
         BC    15,@9BF                                            0325
*           ELSE
*             CNVA = KON0;
@9C0     MVC   200(2,@6),KON0                                     0325
*         TEMP01 = TEMP01 - KON1;
@9BF     L     @F,TEMP01                                          0326
         SH    @F,KON1                                            0326
         ST    @F,TEMP01                                          0326
*         IF  AVL78 <  TEMP03 + CNVA          /* IF THERE IS NOT SUF- *
*           THEN                              /* FICIENT ROOM FOR MOVE*
         LH    @F,200(0,@6)                                       0327
         A     @F,TEMP03                                          0327
         CH    @F,AVL78                                           0327
         BC    12,@9BE                                            0327
*             DO;                             /*  SET GETMAIN MINIMUM *
*               GMNMIN = TEMP03 + KON8 + CNVA;/*  AND SET RETURN ADDR-*
         LH    @F,200(0,@6)                                       0329
         AH    @F,KON8                                            0329
         A     @F,TEMP03                                          0329
         ST    @F,140(0,@6)                                       0329
*               GOTO  E03OAB05;               /* GO TO   GETMAIN      *
         BC    15,E03OAB05                                        0330
*             END;
* E03ITO10: AVL78 = AVL78 - TEMP03 - CNVA;    /* REDUCE AMT AVAIL IN
*                                                SP78 BY AMT TO BE
*                                                MOVED -
*                                                SET VARIABLES FOR
*                                                GENERALIZED MOVE RTN *
@9BE     EQU   *                                                  0332
E03ITO10 LH    @F,200(0,@6)                                       0332
         LCR   @F,@F                                              0332
         S     @F,TEMP03                                          0332
         AH    @F,AVL78                                           0332
         STH   @F,AVL78                                           0332
*         R3  = TEMP03;                       /* R3 = AMT TO BE MOVED *
         L     @3,TEMP03                                          0333
*         R4  = PROCUR;                       /* R4 = AREA TO BE MOVED
*                                                INTO                 *
         L     @4,PROCUR                                          0334
*         R5  = OFFSET;                       /* R5 = AREA TO BE MOVED
*                                                FROM                 *
         L     @5,OFFSET                                          0335
*         ADPTR1  = ADDR(E03ITO15);           /* SET RETURN ADDRESS   *
         LA    @F,E03ITO15                                        0336
         ST    @F,88(0,@6)                                        0336
*         GOTO  E03GMV05;                     /* GO TO MOVE           *
         BC    15,E03GMV05                                        0337
* E03ITO15: PROCUR = PROCUR + TEMP01;         /* UPDATE SP78 RCD ADDR *
E03ITO15 L     @F,TEMP01                                          0338
         A     @F,PROCUR                                          0338
         ST    @F,PROCUR                                          0338
*         IF  TEMP04 = KON0                   /* IF IT IS A NULL VALUE*
*           THEN                              /*  FOR THE PARM -      *
         LH    @F,KON0                                            0339
         C     @F,TEMP04                                          0339
*             GOTO E03UAR05;                  /* BYPASS MOVE - ELSE
*                                                SET VARIABLES FOR
*                                                GENERALIZED MOVE RTN *
         BC    08,E03UAR05                                        0340
*         R3  = TEMP04;                       /* R3 = AMT TO BE MOVED *
         L     @3,TEMP04                                          0341
*         R4  = PROCUR;                       /* R4 = AREA TO BE MOVED
*                                                INTO                 *
         L     @4,PROCUR                                          0342
*         R5  = ATABCUR;                      /* R5 = AREA TO BE MOVED
*                                                FROM                 *
         L     @5,176(0,@6)                                       0343
*         ADPTR1  = ADDR(E03ITO20);           /* SET RETURN ADDR      *
         LA    @F,E03ITO20                                        0344
         ST    @F,88(0,@6)                                        0344
*         GOTO  E03GMV05;                     /* PERFORM MOVE         *
         BC    15,E03GMV05                                        0345
* E03ITO20: PROCUR = PROCUR + TEMP04;         /* UPDATE SP78 RCD ADDR *
E03ITO20 L     @F,TEMP04                                          0346
         A     @F,PROCUR                                          0346
         ST    @F,PROCUR                                          0346
*
*         /************************************************************
*         /*              FOLLOWING IS UPDATE ROUTTINE-               *
*         /*              IT UPDATES ALL NECESSARY                    *
*         /*              POINTERS, INITIATES A READ IF               *
*         /*              NECESSARY AND BRANCHES TO CON-              *
*         /*              TINUE PROCESSING THE PROCEDURE              *
*         /************************************************************
* E03UAR05: OFFSET = OFFSET + TEMP02 - KON1;  /* UPDATE POINTER TO
*                                                INPUT LINE           *
E03UAR05 LH    @F,KON1                                            0347
         LCR   @F,@F                                              0347
         A     @F,TEMP02                                          0347
         A     @F,OFFSET                                          0347
         ST    @F,OFFSET                                          0347
*         REMCHAR  = REMCHAR - TEMP02 + KON1; /* UPDATE NUMBER OF
*                                                REMAINING BYTES      *
         LH    @F,KON1                                            0348
         S     @F,TEMP02                                          0348
         AH    @F,REMCHAR                                         0348
         STH   @F,REMCHAR                                         0348
*         IF  REMCHAR ^> KON0                 /* IF THE END OF THE    *
*           THEN                              /*  LINE HAS BEEN       *
         LH    @F,KON0                                            0349
         CH    @F,REMCHAR                                         0349
         BC    04,@9BD                                            0349
*             DO;                             /*  REACHED             *
*               IF E01SW8 = '1'B              /* IF RECFM IS VARIABLE *
*                 THEN                        /* GET THE LINE NUMBER  *
         TM    202(@6),B'00000001'                                0351
         BC    12,@9BC                                            0351
*                   LINENO = RCDST -> INPLIN(5:12); /* FROM THE FRONT *
         L     @7,292(0,@6)        
         MVC   LINENO(8),4(@7)                                    0352
         BC    15,@9BB                                            0353
*                 ELSE                        /* THE RECORD OTHERWISE *
*                   DO;                       /* IT WILL BE IN THE    *
*                     OFFSET = OFFSET - KON1; /* LAST EIGHT BYTES OF  *
@9BC     L     @F,OFFSET                                          0354
         SH    @F,KON1                                            0354
         ST    @F,OFFSET                                          0354
*                     LINENO = INPLIN(1:8);   /* THE RECORD           *
         LR    @7,@F                                              0355
         MVC   LINENO(8),0(@7)                                    0355
*                   END;
*               ADPTR1 = ADDR(E03UAR10);      /*   GO TO OBTAIN       *
@9BB     LA    @F,E03UAR10                                        0357
         ST    @F,88(0,@6)                                        0357
*               GOTO E03IMR05;                /*  NEXT INPUT LINE     *
         BC    15,E03IMR05                                        0358
*             END;
*         IF  INPLIN(1) ^= KPERD              /* IF CHAR IS NOT       *
*           THEN                              /*  PERIOD GO  TO CONT  *
@9BD     L     @7,OFFSET                                          0360
         CLC   0(1,@7),TCHAR+4                                    0360
*             GOTO E03SPL10;                  /*  SCANNING THE LINE   *
         BC    07,E03SPL10                                        0361
*         R4  = OFFSET - KON1;                /* ELSE SET R4 TO PREV  *
         LH    @4,KON1                                            0362
         LCR   @4,@4                                              0362
         A     @4,OFFSET                                          0362
*         IF  R4 -> INPLIN(1) ^= KAMP         /*  IOUS CHAR -IF IT WAS*
*           THEN                              /*  A SYMB PARM DO NOT  *
         CLC   0(1,@4),TCHAR+3                                    0363
         BC    08,@9BA                                            0363
*             DO;
*               OFFSET = OFFSET + KON1;       /*  MOVE THE PERIOD     *
         LH    @F,KON1                                            0365
         A     @F,OFFSET                                          0365
         ST    @F,OFFSET                                          0365
*               REMCHAR = REMCHAR - KON1;     /*  MOVED SO RESET PTR  *
         LH    @F,REMCHAR                                         0366
         SH    @F,KON1                                            0366
         STH   @F,REMCHAR                                         0366
*
*             END;
*         GOTO  E03SPL10;                     /* GO TO CONTINUE SCAN
*                                                OF INPUT LINE        *
         BC    15,E03SPL10                                        0368
* E03UAR10: IF E03SW1 ^= '1'B                 /* IF NEW LINE IS NOT   *
*             THEN                            /*  LOGICAL EXTENSION   *
E03UAR10 TM    E03BINSW,B'10000000'                               0369
         BC    01,@9B9                                            0369
*               DO;                           /*  OF PREVIOUS LINE-   *
*                 IF E03SW2 = '1'B            /* IF RECORD CONT OVER  *
*                   THEN                      /*  SP78 BLOCKS SET LNG *
         TM    E03BINSW,B'01000000'                               0371
         BC    12,@9B8                                            0371
*                     DO;                     /* OF PART IN PREV BLK  *
*                                             /* ADD LGN OF     YM2699*
*                       RECSIZE = PROCUR - ADDGMN - KON8 + RECSIZE;
         L     @F,RECSIZE                                         0373
         SH    @F,KON8                                            0373
         S     @F,148(0,@6)                                       0373
         A     @F,PROCUR                                          0373
         ST    @F,RECSIZE                                         0373
*                                             /*  IN PART       YM2699*
*                       E03SW2 = '0'B;        /*  CUR BLK - RESET SW  *
         NI    E03BINSW,B'10111111'                               0374
         BC    15,@9B7                                            0376
*                     END;                    /*  FOR CONT BLK        *
*                   ELSE
*                     RECSIZE = PROCUR - PROCIND; /* OBTAIN RCD
*                                                   LENGTH      YM2699*
@9B8     L     @F,PROCUR                                          0376
         S     @F,PROCIND                                         0376
         ST    @F,RECSIZE                                         0376
*                 PROCRCL = RECSIZEC(3:4);    /*  STORE IT IN THE
*                                                 RCD           YM2699*
@9B7     L     @7,PROCIND                                         0377
         MVC   0(2,@7),RECSIZE+2                                  0377
*                 PROCRES = ''B;              /*  ZERO RSVD BYTES     *
         XC    2(2,@7),2(@7)                                      0378
*                 IF RECSIZE > KON7FFC        /* IF OUTPUT RCD  YM2699*
*                   THEN                      /*   LENGTH EXCEED LIMIT*
         MVC   @TEMP2+2(2),KONSTRUC+3                             0379
         L     @F,@TEMP2                                          0379
         C     @F,RECSIZE                                         0379
         BC    10,@9B6                                            0379
*                     DO;                     /*   OF 32,768    YM2699*
*                       E01SW9 = '1'B;        /* SET TERMINATION SW   *
         OI    203(@6),B'10000000'                                0381
*                       LVL1NO = KON15;       /* SET FIRST LEVEL MSG  *
         MVC   304(2,@6),KON15                                    0382
*                       LVL2NO = KON0;        /* SET SECOND LEVEL MSG *
         MVC   306(2,@6),KON0                                     0383
*                       ADPTR1 = ADDR(E03PRT30);   /* SET RETURN ADDR *
         LA    @F,E03PRT30                                        0384
         ST    @F,88(0,@6)                                        0384
*                       VARSGADR = ADDR(LINENO);/*POINT TO LINE NUMBER
         LA    @F,LINENO                                          0385
         ST    @F,@TEMP4                                          0385
         MVC   297(3,@6),@TEMP4+1                                 0385
*                       CNVA = KON12;         /*  TO BE PLACED IN MSG *
         MVC   200(2,@6),KON12                                    0386
*                       VARSGLNG = CNVC(2);   /*  AND INDICATE LENGTH *
         MVC   296(1,@6),201(@6)                                  0387
*                       GO TO E03MML05;       /* GO TO MESSAGE MODULE *
         BC    15,E03MML05                                        0388
*                     END;
*                 PROCIND = PROCUR;           /*  UPDATE START OF RCD *
@9B6     MVC   PROCIND(4),PROCUR                                  0390
*                 PROCUR  = PROCIND + KON4;   /*   PTR AND CURRENT RCD*
         LH    @F,KON4                                            0391
         A     @F,PROCIND                                         0391
         ST    @F,PROCUR                                          0391
         BC    15,@9B5                                            0393
*               END;                          /*   PTR                *
*             ELSE                            /* ELSE RESET THE       *
*               E03SW1 = '0'B;                /*  CONTINUATION SWITCH *
@9B9     NI    E03BINSW,B'01111111'                               0393
*         GOTO  E03SPL05;                     /* GO TO START PROCESS-
*                                                ING THIS LINE        *
         BC    15,E03SPL05                                        0394
*
*         /************************************************************
*         /*              FOLLOWING IS THE END OF DATA                *
*         /*              EXIT- IF THE IN CORE PROCEDURE              *
*         /*              IS NOT CONTIGUOUS IT IS MERGED              *
*         /*              INTO ONE CONTGUOUS BLOCK, ANY               *
*         /*              UNUSED SP78 CORE IS FREED AND               *
*         /*              EXIT IS MADE TO IKJEFE01                    *
*         /************************************************************
* E03PRT05:IF E03SW1 = '1'B                   /* IF RECORD WAS TO BE  *
*            THEN                             /*  CONTINUED           *
E03PRT05 TM    E03BINSW,B'10000000'                               0395
         BC    12,@9B4                                            0395
*              DO;
*                E03SW1 = '0'B;               /* SET SWITCHES         *
         NI    E03BINSW,B'01111111'                               0397
*                E01SW9 = '1'B;
         OI    203(@6),B'10000000'                                0398
*                LVL1NO = KON12;              /* SET 1ST LEVEL MSG    *
         MVC   304(2,@6),KON12                                    0399
*                LVL2NO = KON0;               /* SET 2ND LEVEL MSG    *
         MVC   306(2,@6),KON0                                     0400
*                ADPTR1 = ADDR(E03PRT05);     /* SET RETURN ADDR      *
         LA    @F,E03PRT05                                        0401
         ST    @F,88(0,@6)                                        0401
*                VARSGLNG = KONX00;
         MVC   296(1,@6),KONSTRUC                                 0402
*                GOTO E03MML05;               /*  ERROR ROUTINE       *
         BC    15,E03MML05                                        0403
*              END;
*         IF E01SW12 = '0'B                   /* IF CORE HASN'T BEEN  *
*           THEN                              /*   GOTTEN FROM SP78   *
@9B4     TM    203(@6),B'00010000'                                0405
*             GOTO E03PRT30;                  /* THEN GO TO RETURN    *
         BC    08,E03PRT30                                        0406
*         IF E03SW2 = '1'B                    /* IF RECORD WAS  YM2699*
*           THEN                              /* SPANNED ACROSS YM2699*
         TM    E03BINSW,B'01000000'                               0407
         BC    12,@9B3                                            0407
*             DO;                             /* SP78 RECORDS THEN ADD
*                                                TO KNOWN LEN   YM2699*
*               RECSIZE = PROCUR - ADDGMN - KON8 + RECSIZE;
         L     @F,RECSIZE                                         0409
         SH    @F,KON8                                            0409
         S     @F,148(0,@6)                                       0409
         A     @F,PROCUR                                          0409
         ST    @F,RECSIZE                                         0409
*               E03SW2 = '0'B;                /* RESET SW       YM2699*
         NI    E03BINSW,B'10111111'                               0410
         BC    15,@9B2                                            0412
*             END;                                            /*YM2699*
*           ELSE
*             RECSIZE = PROCUR - PROCIND;     /* OBTAIN RCD
*                                                LENGTH         YM2699*
@9B3     L     @F,PROCUR                                          0412
         S     @F,PROCIND                                         0412
         ST    @F,RECSIZE                                         0412
*         PROCRCL  = RECSIZEC(3:4);           /* STORE IN THE
*                                                RECORD         YM2699*
@9B2     L     @7,PROCIND                                         0413
         MVC   0(2,@7),RECSIZE+2                                  0413
*         IF RECSIZE > KON7FFC                /* IF OUTPUT RCD  YM2699*
*           THEN                              /*   LENGTH EXCEED LIMIT*
         MVC   @TEMP2+2(2),KONSTRUC+3                             0414
         L     @F,@TEMP2                                          0414
         C     @F,RECSIZE                                         0414
         BC    10,@9B1                                            0414
*             DO;                             /*   OF 32,768    YM2699*
*               E01SW9 = '1'B;                /* SET TERMINATION SW   *
         OI    203(@6),B'10000000'                                0416
*               LVL1NO = KON15;               /* SET FIRST LEVEL MSG  *
         MVC   304(2,@6),KON15                                    0417
*               LVL2NO = KON0;                /* SET SECOND LEVEL MSG *
         MVC   306(2,@6),KON0                                     0418
*               ADPTR1 = ADDR(E03PRT30);      /* SET RETURN ADDR FROM *
         LA    @F,E03PRT30                                        0419
         ST    @F,88(0,@6)                                        0419
*               VARSGADR = ADDR(LINENO);        /*POINT TO LINE NUMBER
         LA    @F,LINENO                                          0420
         ST    @F,@TEMP4                                          0420
         MVC   297(3,@6),@TEMP4+1                                 0420
*               CNVA = KON12;                 /*  TO BE PLACED IN MSG *
         MVC   200(2,@6),KON12                                    0421
*               VARSGLNG = CNVC(2);           /*  AND INDICATE LENGTH *
         MVC   296(1,@6),201(@6)                                  0422
*               GO TO E03MML05;               /* GO TO MESSAGE MODULE *
         BC    15,E03MML05                                        0423
*             END;
*         PROCRES  = ''B;                     /* ZERO RESVD BYTES     *
@9B1     L     @7,PROCIND                                         0425
         XC    2(2,@7),2(@7)                                      0425
*         IF  E03SW3 ^= '1'B × E01SW9 = '1'B  /* IF IN CORE PROC IS   *
*           THEN                              /*  ALREADY CONTIGUOUS  *
         TM    E03BINSW,B'00100000'                               0426
         BC    12,@9B0                                            0426
         TM    203(@6),B'10000000'                                0426
         BC    12,@9AF                                            0426
*             GOTO E03PRT30;                  /*  BYPASS MERGE        *
         BC    03,E03PRT30                                        0427
*           ELSE
*             GOTO E03PRT35;
         BC    15,E03PRT35                                        0428
* E03PRT07: R2  = PRMSTR;                     /* SAVE START ADDR OF
*                                                FIRST BLOCK          *
E03PRT07 L     @2,PRMSTR                                          0429
*         GMNMIN  = KON0;                     /* INITIALIZE FOR COMP-
*                                                UTATION OF AMT OF
*                                                CORE NEEDED          *
         LH    @F,KON0                                            0430
         ST    @F,140(0,@6)                                       0430
* E03PRT10: GMNMIN = GMNMIN + R2 -> PROCSZE - KON8;
E03PRT10 LH    @F,KON8                                            0431
         LCR   @F,@F                                              0431
         A     @F,4(0,@2)                                         0431
         A     @F,140(0,@6)                                       0431
         ST    @F,140(0,@6)                                       0431
*                                             /* ADD SIZE OF THIS
*                                                BLOCK OF PROC        *
*         IF  R2 -> PROCNXT ^= KON0           /* IF THIS IS NOT THE   *
*           THEN                              /*  LAST BLOCK          *
         LH    @F,KON0                                            0432
         C     @F,0(0,@2)                                         0432
         BC    08,@9AE                                            0432
*             DO;                             /*  UPDATE TO NEXT      *
*               R2 = R2 -> PROCNXT;           /*  BLOCK AND RECYCLE   *
         L     @2,0(0,@2)                                         0434
*               GOTO E03PRT10;                /*  TO ADD IT'S SIZE    *
         BC    15,E03PRT10                                        0435
*             END;                            /*  TO AMT NEEDED       *
*         OFFSET = R2;
@9AE     ST    @2,OFFSET                                          0437
*         GMNMAX  = GMNMIN;                   /* SET MAX AMT OF CORE
*                                                TO BE OBTAINED       *
         MVC   144(4,@6),140(@6)                                  0438
*         R4  = KON78;                        /* SET SUBPOOL INDICATOR*
         LH    @4,KON78                                           0439
*         ADPTR1  = ADDR(E03PRT15);           /* SET RETURN ADDRESS   *
         LA    @F,E03PRT15                                        0440
         ST    @F,88(0,@6)                                        0440
*         GOTO  E03GMN05;                     /* GO TO   GETMAIN      *
         BC    15,E03GMN05                                        0441
* E03PRT15: R4 = ADDGMN;                      /* R4 = AREA TO BE MOVED
*                                                TO                   *
E03PRT15 L     @4,148(0,@6)                                       0442
*         R5  = PRMSTR + KON8;                /* R5 = AREA TO BE MOVED
*                                                FROM                 *
         LH    @5,KON8                                            0443
         A     @5,PRMSTR                                          0443
*         OFFSET -> PROCNXT = R4;             /*  SET PTR TO NEW BLOCK*
         L     @7,OFFSET                                          0444
         ST    @4,0(0,@7)                                         0444
*         R3  = PRMSTR;                       /* SET R3 POINTING TO
*                                                PROCSZE              *
         L     @3,PRMSTR                                          0445
*         R3  = R3 -> PROCSZE - KON8;         /* R3 = AMOUNT TO BE
*                                                MOVED                *
         LH    @F,KON8                                            0446
         LCR   @F,@F                                              0446
         A     @F,4(0,@3)                                         0446
         LR    @3,@F                                              0446
*         ADPTR1  = ADDR(E03PRT20);           /* SET RETURN ADDRESS   *
         LA    @F,E03PRT20                                        0447
         ST    @F,88(0,@6)                                        0447
*         GOTO E03GMV05;                      /* MOVE OLD BLOCK INTO
*                                                NEW ONE              *
         BC    15,E03GMV05                                        0448
* E03PRT20: ;
*         TSTLNG  = PRMSTR;                   /* SET ADDRESS OF CORE  *
E03PRT20 MVC   136(4,@6),PRMSTR                                   0450
*         R2  = ADDR(TSTLNG);                 /*   TO BE FREED        *
         LA    @2,136(0,@6)                                       0451
*         R5  = PRMSTR -> PROCNXT;            /* SET R5 POINTING TO   *
         L     @7,PRMSTR                                          0452
         L     @5,0(0,@7)                                         0452
*         PRMSTR = R5;                        /*  NEXT BLOCK          *
         ST    @5,PRMSTR                                          0453
*         TEMP04  = R4;                       /* SAVE ADDR OF FREE
*                                                PORTION OF  CONTIG-
*                                                UOUS BLOCK           *
         ST    @4,TEMP04                                          0454
*         R3  = R3 + KON8;                    /* ACCOUNT FOR SIZE AND
*                                                CHAIN PTR IN AMT TO
*                                                BE FREED             *
         AH    @3,KON8                                            0455
*         R4  = KON78;                        /* SET SUBPOOL INDICATOR*
         LH    @4,KON78                                           0456
*         ADPTR1  = ADDR(E03PRT25);           /* SET RETURN ADDRESS   *
         LA    @F,E03PRT25                                        0457
         ST    @F,88(0,@6)                                        0457
*         GOTO E03FMN05;                      /* GO TO   FREEMAIN     *
         BC    15,E03FMN05                                        0458
* E03PRT25: IF R5 ^= ADDGMN                   /* IF LAST BLOCK HAS    *
*             THEN                            /*  NOT BEEN            *
E03PRT25 C     @5,148(0,@6)                                       0459
         BC    08,@9AD                                            0459
*               DO;                           /*  PROCESSED -  SET    *
*                 R3 = R5 -> PROCSZE - KON8;  /*  R3 = AMT TO BE MOVED*
         LH    @F,KON8                                            0461
         LCR   @F,@F                                              0461
         A     @F,4(0,@5)                                         0461
         LR    @3,@F                                              0461
*                 R5 = R5 + KON8;             /*  R5 = AREA TO BE
*                                                 MOVED FROM          *
         AH    @5,KON8                                            0462
*                 R4 = TEMP04;                /*  R4 = AREA TO BE
*                                                 MOVED TO            *
         L     @4,TEMP04                                          0463
*                 ADPTR1  = ADDR(E03PRT20);   /* SET RETURN ADDRESS   *
         LA    @F,E03PRT20                                        0464
         ST    @F,88(0,@6)                                        0464
*                 GOTO E03GMV05;              /* GO TO   MOVE         *
         BC    15,E03GMV05                                        0465
*               END;                          /*                      *
*         SP78ADDR  = ADDGMN;                 /* STORE ADDR OF PROC   *
@9AD     MVC   156(4,@6),148(@6)                                  0467
*         SP78LNGT  = GMNMIN;                 /* STORE LENGTH OF BLOCK*
         MVC   160(4,@6),140(@6)                                  0468
*         RETURN;                             /* RETURN TO IKJEFE01   *
         BC    15,@EL01                                           0469
* E03PRT30: IF E01SW12 = '0'B                 /* IF THE EOD READ WAS  *
*             THEN                            /*   FOR IKJEFE01 - SET *
E03PRT30 TM    203(@6),B'00010000'                                0470
         BC    05,@9AC                                            0470
*               DO;                           /*   POINTER TO ZERO    *
*                 LINPTR1 = KON0;             /*   AND RETURN         *
         LH    @F,KON0                                            0472
         ST    @F,124(0,@6)                                       0472
*                 ADPTR1 = TEMP01;
         MVC   88(4,@6),TEMP01                                    0473
*                 RETURN;
         BC    15,@EL01                                           0474
*               END;
*         IF E01SW9 = '1'B                    /* IF PROC CAN'T BE     *
*           THEN                              /* EXECUTED THEN RETURN *
@9AC     TM    203(@6),B'10000000'                                0476
*             RETURN;
         BC    03,@EL01                                           0477
*         R3  = KON8;                         /* SET R3 = AMT OF CORE
*                                                TO BE FREED          *
@9AB     LH    @3,KON8                                            0478
*         TSTLNG  = ADDGMN;                   /* SET ADDRESS OF CORE  *
         MVC   136(4,@6),148(@6)                                  0479
*         R2  = ADDR(TSTLNG);                 /*   TO BE FREED
*                                                  CORE TO BE FREED   *
         LA    @2,136(0,@6)                                       0480
*         R4  = KON78;                        /* SET SUBPOOL INDICATOR*
         LH    @4,KON78                                           0481
*         ADPTR1  = ADDR(E03PRT35);           /* SET RETURN ADDRESS   *
         LA    @F,E03PRT35                                        0482
         ST    @F,88(0,@6)                                        0482
*         AMTGMN = AMTGMN - KON8;             /* ADJUST LENGTH OF SP78
         LH    @F,KON8                                            0483
         LCR   @F,@F                                              0483
         A     @F,152(0,@6)                                       0483
         ST    @F,152(0,@6)                                       0483
*         ADDGMN = ADDGMN + KON8;             /* ADJUST ADDR OF SP78  *
         LH    @F,KON8                                            0484
         A     @F,148(0,@6)                                       0484
         ST    @F,148(0,@6)                                       0484
*         GOTO E03FMN05;                      /* GO TO   FREEMAIN     *
         BC    15,E03FMN05                                        0485
* E03PRT35: R2 = PROCUR + KON7;               /* ROUND END OF PROC    *
E03PRT35 LH    @2,KON7                                            0486
         A     @2,PROCUR                                          0486
*         GEN;                                /*   ADDRESS TO MULTIPLE*
         SRL   R2,3                          /*   OF 8 WHICH IS      */
         SLL   R2,3                          /*   GREATER OR EQUAL TO*/
         DS    0H
*         R3 = ADDGMN + AMTGMN - R2;          /* SET AMT OF CORE      *
         LCR   @3,@2                                              0488
         A     @3,152(0,@6)                                       0488
         A     @3,148(0,@6)                                       0488
*         TSTLNG = R2;                        /* SET ADDR OF CORE TO  *
         ST    @2,136(0,@6)                                       0489
*         R2 = ADDR(TSTLNG);                  /* BE FREED             *
         LA    @2,136(0,@6)                                       0490
*         R4 = KON78;                         /* SET SUBPOOL INDICATOR*
         LH    @4,KON78                                           0491
*         IF E03SW3 = '1'B                    /* IF PROC HAS NO PROC  *
*           THEN                              /* STATEMENT            *
         TM    E03BINSW,B'00100000'                               0492
         BC    12,@9AA                                            0492
*             DO;
*               PROCSZE = PROCUR - ADDGMN;    /* SET SIZE OF PROC     *
         L     @F,148(0,@6)                                       0494
         LCR   @F,@F                                              0494
         A     @F,PROCUR                                          0494
         L     @7,148(0,@6)        
         ST    @F,4(0,@7)                                         0494
*               ADPTR1 = ADDR(E03PRT07);      /* SET RETURN ADDR      *
         LA    @F,E03PRT07                                        0495
         ST    @F,88(0,@6)                                        0495
         BC    15,@9A9                                            0497
*             END;
*           ELSE
*             ADPTR1  = ADDR(E03PRT40);       /* SET RETURN ADDRESS   *
@9AA     LA    @F,E03PRT40                                        0497
         ST    @F,88(0,@6)                                        0497
*         GOTO  E03FMN05;                     /* GO TO   FREEMAIN     *
         BC    15,E03FMN05                                        0498
* E03PRT40: SP78ADDR = ADDGMN;                /* SAVE ADDR OF PROC    *
E03PRT40 MVC   156(4,@6),148(@6)                                  0499
*         SP78LNGT  = PROCUR - SP78ADDR;      /* SAVE LENGTH OF PROC  *
         L     @F,156(0,@6)                                       0500
         LCR   @F,@F                                              0500
         A     @F,PROCUR                                          0500
         ST    @F,160(0,@6)                                       0500
*         AMTGMN = SP78LNGT;                  /* SAVE LENGTH OF STACK *
         MVC   152(4,@6),160(@6)                                  0501
*         RETURN;                             /* RETURN TO CALLER     *
         BC    15,@EL01                                           0502
*
*         /************************************************************
*         /*              FOLLOWING IS THE GETMAIN ROUTINE-           *
*         /*              IT PERFORMS GETMAINS FOR THE                *
*         /*              CALLER AND RETURNS- INTER-                  *
*         /*              FACE IS PROVIDE VIA VARIABLES               *
*         /*              IN IKJEFE01                                 *
*         /************************************************************
* E03GMN05:R2 = ADDR(GMNMIN);                 /* SET PTR TO INPUTS    *
E03GMN05 LA    @2,140(0,@6)                                       0503
*         R3  = ADDR(ADDGMN);                 /* SET PTR TO OUTPUTS   *
         LA    @3,148(0,@6)                                       0504
*         GEN(GETMAIN VC,LA=(R2),A=(R3),SP=(R4),MF=(E,AAGETM));
         GETMAIN VC,LA=(R2),A=(R3),SP=(R4),MF=(E,AAGETM)
         DS    0H
*         IF  R15 = 0                         /* IF SUCCESSFUL -      *
*           THEN                              /*  RETURN TO CALLER    *
         LTR   @F,@F                                              0506
*             GOTO INDAD1;
         L     @7,88(0,@6)         
         BCR   08,@7                                              0507
*         E01SW9  = '1'B;                     /* SET ERROR SWITCH     *
         OI    203(@6),B'10000010'                                0508
*         E01SW15  = '1'B;                    /* INDICATE THAT MINIMUM
*                                                COULD NOT BE GOTTEN  *
*         LVL1NO = KON11;                     /* SET 1ST LEVEL MSG    *
         MVC   304(2,@6),KON11                                    0510
*         LVL2NO = KON0;                      /* SET 2ND LEVEL MSG    *
         MVC   306(2,@6),KON0                                     0511
*         VARSGLNG = KONX00;
         MVC   296(1,@6),KONSTRUC                                 0512
*         ADPTR1 = ADDR(E03PRT40);           /* SET RETURN ADDR      */
         LA    @F,E03PRT40                                        0513
         ST    @F,88(0,@6)                                        0513
*         GOTO E03MML05;                       /* GO TO MSG ROUTINE
         BC    15,E03MML05                                        0514
*
*         /***********************************************************/
*         /*              FOLLOWING IS THE FREEMAIN                  */
*         /*              ROUTINE-  IF PERFORMS                      */
*         /*              FREEMAINS FOR THE CALLER                   */
*         /*              AND RETURNS- INTERFACE IS                  */
*         /*              PROVIDED VIA REGISTERS                     */
*         /*              2,3 AND 4                                  */
*         /***********************************************************/
* E03FMN05: GEN(FREEMAIN E,LV=(R3),A=(R2),SP=(R4),MF=(E,AAFREM));
E03FMN05 FREEMAIN E,LV=(R3),A=(R2),SP=(R4),MF=(E,AAFREM)
         DS    0H
*         GOTO  INDAD1;                       /* RETURN TO CALLER     *
         L     @7,88(0,@6)         
         BCR   15,@7                                              0516
*
*         /************************************************************
*         /*              FOLLOWING IS THE READ ROUTINE               *
*         /*              -  IT DEBLOCKS A RECORD AND                 *
*         /*              PASSES ITS ADDRESS TO THE                   *
*         /*              CALLER AND READS IN NEW                     *
*         /*              BLOCKS AS NECESSARY                         *
*         /************************************************************
* E03IMR05: IF E01SW2 = '1'B                  /* IF THIS IS THE FIRST *
*             THEN                            /*  READ                *
E03IMR05 TM    202(@6),B'01000000'                                0517
         BC    12,@9A8                                            0517
*               DO;
*                 R2 = ADDR(RDECB);           /* SAVE DECB ADDR       *
         LA    @2,104(0,@6)                                       0519
*                 GOTO E03IMR15;              /* TO DO                *
         BC    15,E03IMR15                                        0520
*               END;                          /* INITIALIZATION       *
*         IF  E01SW8 = '0'B                   /* IF RCD FMT IS FIXED  *
*           THEN                              /*  UPDATE TO NEXT RCD  *
@9A8     TM    202(@6),B'00000001'                                0522
         BC    05,@9A7                                            0522
*             RCDST = RCDST + DCBLRECL;       /*  BY RCD LENGTH IN DCB*
         LH    @F,82(0,@6)                                        0523
         A     @F,292(0,@6)                                       0523
         ST    @F,292(0,@6)                                       0523
         BC    15,@9A6                                            0524
*           ELSE                              /* IF RCD FMT IS VAR.   *
*             DO;                             /*  UPDATE TO NEXT RCD  *
*               CNVC = RCDLNG;                /*  BY THE RCD LENGTH   *
@9A7     L     @7,292(0,@6)        
         MVC   200(2,@6),0(@7)                                    0525
*               RCDST = RCDST + CNVA;         /*  INDICATOR IN THE    *
         LH    @F,200(0,@6)                                       0526
         A     @F,292(0,@6)                                       0526
         ST    @F,292(0,@6)                                       0526
*             END;                            /*  LAST  RCD           *
*         IF  RCDST ^= EOB                    /* IF THE END OF BLOCK  *
*           THEN                              /*  HAS NOT BEEN REACHED*
@9A6     L     @F,288(0,@6)                                       0528
         C     @F,292(0,@6)                                       0528
*             GOTO INDAD1;                    /*  RETURN TO CALLER    *
         L     @7,88(0,@6)         
         BCR   07,@7                                              0529
* E03IMR10:R2 = ADDR(RDECB);                  /* SET REG2 POINTING TO
*                                                THE DCB              *
E03IMR10 LA    @2,104(0,@6)                                       0530
*         GEN(CHECK ((R2)));                  /* WAIT FOR COMPLETION
*                                                OF PREVIOUS READ     *
         CHECK ((R2))
         DS    0H
*         TEMP05  = BFAPTR;                   /* SAVE ADDRESS OF BFR
*                                                JUST READ INTO       *
         MVC   TEMP05(4),224(@6)                                  0532
*         BFAPTR  = BFBPTR;                   /* SET FOR READ INTO
*                                                BUFFER               *
         MVC   224(4,@6),228(@6)                                  0533
*         BFBPTR  = TEMP05;                   /* SET PTR TO FULL
*                                                BUFFER               *
         MVC   228(4,@6),TEMP05                                   0534
*         IF  E01SW8 = '1'B                   /* IF RECORD FORMAT IS  *
*           THEN                              /*  VARIABLE -  END OF  *
         TM    202(@6),B'00000001'                                0535
         BC    12,@9A5                                            0535
*             DO;                             /*  BLOCK = START +     *
*               EOB = BFBPTR + RCDLNGA;       /*  BLOCK LNGTH INDIC.- *
         L     @7,228(0,@6)        
         LH    @F,0(0,@7)                                         0537
         A     @F,228(0,@6)                                       0537
         ST    @F,288(0,@6)                                       0537
*               RCDST = BFBPTR + KON4;        /* START OF RECORD IS   *
         LH    @F,KON4                                            0538
         A     @F,228(0,@6)                                       0538
         ST    @F,292(0,@6)                                       0538
         BC    15,@9A4                                            0540
*             END;                            /*  JUST AFTER BLOCK    *
*           ELSE                              /*  LENGTH INDICATOR    *
*             DO;                             /* IF RCD FMT IS FIXED  *
*               EOB  = DCBBLKSI - CSWCNT + BFBPTR;   /* THEN
*                                                END OF BLOCK = START *
@9A5     L     @F,228(0,@6)                                       0541
         L     @7,120(0,@6)        
         SH    @F,14(0,@7)                                        0541
         AH    @F,62(0,@6)                                        0541
         ST    @F,288(0,@6)                                       0541
*               RCDST = BFBPTR;               /*  + NUMBER OF BYTES   *
         MVC   292(4,@6),228(@6)                                  0542
*             END;                            /*  READ-  START OF RCD
*                                                 = START OF BLOCK    *
* E03IMR15: R3 = ADDR(DCBAR);                 /* SET R3 POINTING TO
*                                                THE DCB              *
@9A4     EQU   *                                                  0544
E03IMR15 LR    @3,@6                                              0544
*         R4  = BFAPTR;                       /* SET REG4 POINTING TO
*                                                AREA TO BE READ INTO *
         L     @4,224(0,@6)                                       0545
*         GEN;                                /* ISSUE THE READ FOR   *
         READ  (R2),SF,(R3),(R4),MF=E        /*   THE NEXT BUFFER    */
         DS    0H
*         IF  E01SW2 = '1'B                   /* IF THAT WAS THE FIRST*
*           THEN                              /*   READ -RESET SWITCH *
         TM    202(@6),B'01000000'                                0547
         BC    12,@9A3                                            0547
*             DO;                             /*   AND RECYCLE TO     *
*               E01SW2 = '0'B;                /*   WAIT FOR COMPLETION*
         NI    202(@6),B'10111111'                                0549
*               GOTO E03IMR10;                /*   AND ISSUE NEXT READ*
         BC    15,E03IMR10                                        0550
*             END;
*         GOTO  INDAD1;                       /* RETURN TO CALLER     *
@9A3     L     @7,88(0,@6)         
         BCR   15,@7                                              0552
*         /************************************************************
*         /*              FOLLOWING IS THE GENERALIZED                *
*         /*              MOVE ROUTINE -  IT MOVES THE                *
*         /*              NUMBER OF BYTES SPECIFIED IN                *
*         /*              REG3 FROM THE AREA SPECIFIED                *
*         /*              IN REG5 TO THE AREA SPECIFIED               *
*         /*              IN REG4                                     *
*         /************************************************************
* E03GMV05: DO R2 = KON256 TO R3 BY KON256;   /* MOVE DATA IN 256 BYTE
*                                                BLOCKS               *
E03GMV05 LH    @2,KON256                                          0553
         BC    15,@DO9A1                                          0553
*             R4  -> PROCDAT(1:256) = R5 -> PROCDAT(1:256);
@DO9A2   MVC   0(256,@4),0(@5)                                    0554
*                                             /* MOVE ONE BLOCK       *
*             R4  = R4 + KON256;              /* UPDATE               *
         AH    @4,KON256                                          0555
*             R5  = R5 + KON256;              /*   POINTERS           *
         AH    @5,KON256                                          0556
*           END;
*         R2 = R3 + KON256 - R2;              /* SET REG2 = NUMBER OF
*                                                BYTES NOT MOVED      *
         AH    @2,KON256                                          0557
@DO9A1   CR    @2,@3                                              0557
         BC    12,@DO9A2                                          0557
         LCR   @2,@2                                              0558
         AH    @2,KON256                                          0558
         AR    @2,@3                                              0558
*         IF  R2 ^= KON0                      /* IF ALL BYTES WERE NOT*
*           THEN                              /* MOVED, MOVE ALL LEFT *
         CH    @2,KON0                                            0559
         BC    08,@99E                                            0559
*             R4 -> PROCDAT(1:R2) = R5 -> PROCDAT(1:R2);
         LR    @E,@5                                              0560
         LR    @7,@2                                              0560
         BCTR  @7,0                                               0560
         LR    @A,@4                                              0560
         EX    @7,@MVC                                            0560
*         R4 = R4 + R2;
@99E     EQU   *                                                  0561
         AR    @4,@2                                              0561
*         GOTO  INDAD1;                            /* RETURN TO CALLER*
         L     @7,88(0,@6)         
         BCR   15,@7                                              0562
*
*         /************************************************************
*         /*              THE FOLLOWING IS THE CODE                   *
*         /*              WHICH OBTAINS ADDITIONAL                    *
*         /*              BLOCKS OF SP78 STORAGE FOR A                *
*         /*              PROCEDURE WHICH HAS OVERFLOWED              *
*         /*              THE INITIAL BLOCK                           *
*         /************************************************************
* E03OAB05: R4  = KON78;                      /* SET SUBPOOL INDICATOR*
E03OAB05 LH    @4,KON78                                           0563
*         IF AVL78 < KON8                     /* IF THERE ARE NOT EIGHT
*           THEN                              /* UNUSED BYTES BYPASS  *
         LH    @F,KON8                                            0564
         CH    @F,AVL78                                           0564
*             GOTO E03OAB10;                  /* THE FREEMAIN         *
         BC    02,E03OAB10                                        0565
*         IF PROCIND = PROCUR - KON4          /* IF THIS IS START OF  *
*           THEN                              /* RCD SET START OF CALC*
         L     @F,PROCUR                                          0566
         SH    @F,KON4                                            0566
         C     @F,PROCIND                                         0566
         BC    07,@99D                                            0566
*             TSTLNG = PROCIND;               /* AT PROCIND           *
         MVC   136(4,@6),PROCIND                                  0567
         BC    15,@99C                                            0568
*           ELSE                              /* ELSE START CALC AT   *
*             TSTLNG = PROCUR;                /* PROCUR               *
@99D     MVC   136(4,@6),PROCUR                                   0568
*         R3 = TSTLNG + KON7;                 /* SET REG3 ABOVE DOUBLE
*                                                WORD BDY >= END OF
*                                                DATA IN LAST BLOCK   *
@99C     LH    @3,KON7                                            0569
         A     @3,136(0,@6)                                       0569
*         GEN;                                /* RESET REG3           *
         SRL   R3,3                          /*   TO DOUBLE WORD BDY */
         SLL   R3,3                          /*   L= ITSELF          */
         DS    0H
*         TSTLNG  = R3;                       /* SET ADDR OF CORE TO  *
         ST    @3,136(0,@6)                                       0571
*         R2  = ADDR(TSTLNG);                 /* BE FREED             *
         LA    @2,136(0,@6)                                       0572
*         R3  = AVL78 - KON7;                 /* SET AMT TO BE FREED  *
         LH    @3,KON7                                            0573
         LCR   @3,@3                                              0573
         AH    @3,AVL78                                           0573
*         ADPTR1 = ADDR(E03OAB10);            /* SET RETURN ADDRESS   *
         LA    @F,E03OAB10                                        0574
         ST    @F,88(0,@6)                                        0574
*         GOTO  E03FMN05;                     /* GO TO   FREEMAIN     *
         BC    15,E03FMN05                                        0575
* E03OAB10: PROCSZE = PROCSZE - AVL78;        /* UPDATE SIZE OF LAST
*                                                BLOCK                *
E03OAB10 LH    @F,AVL78                                           0576
         LCR   @F,@F                                              0576
         L     @7,148(0,@6)        
         A     @F,4(0,@7)                                         0576
         ST    @F,4(0,@7)                                         0576
*         TEMP05  = ADDGMN;                   /* SAVE THE ADDRESS OF
*                                                LAST BLOCK           *
         MVC   TEMP05(4),148(@6)                                  0577
*         ADPTR1  = ADDR(E03OAB15);           /* SET RETURN ADDRESS   *
         LA    @F,E03OAB15                                        0578
         ST    @F,88(0,@6)                                        0578
*         GOTO  E03GMN05;                     /* GO TO   GETMAIN      *
         BC    15,E03GMN05                                        0579
* E03OAB15: E03SW3  = '1'B;                   /* SET MULTIPLE BLOCK   *
E03OAB15 OI    E03BINSW,B'00100000'                               0580
*         E01SW14 = '1'B;                     /*   SWITCH ON          *
         OI    203(@6),B'00000100'                                0581
*         R4  = TEMP05;                       /* REG4 POINTS TO LAST
*                                                BLOCK                *
         L     @4,TEMP05                                          0582
*         CURBLK = R4;                        /* SAVE ADDR OF CURRENT
*                                                BLOCK          YM2699*
         ST    @4,CURBLK                                          0583
*         R4  -> PROCNXT = ADDGMN;            /* SET FORWARD POINTER
*                                                IN OLD BLOCK         *
         MVC   0(4,@4),148(@6)                                    0584
*         IF PROCUR = PROCIND + KON4          /* IF THIS IS FIRST ELE-*
*           THEN                              /* MENT IN THIS BLOCK   *
         LH    @F,KON4                                            0585
         A     @F,PROCIND                                         0585
         C     @F,PROCUR                                          0585
         BC    07,@99B                                            0585
*             DO;
*               PROCIND  = ADDGMN + KON8;     /* SET START OF OUTPUT
*                                                RCD INDICATOR        *
         LH    @F,KON8                                            0587
         A     @F,148(0,@6)                                       0587
         ST    @F,PROCIND                                         0587
*               PROCUR  = PROCIND + KON4;     /* SET CURRENT OUTPUT   *
         LH    @F,KON4                                            0588
         A     @F,PROCIND                                         0588
         ST    @F,PROCUR                                          0588
         BC    15,@99A                                            0590
*             END;                            /*   RCD LOCATION PTR   *
*           ELSE                              /* THE ITEM IS    YM2699*
*             DO;                             /* SPLIT OVER AT LEAST TW
*                                                BLOCKS         YM2699*
*               IF E03SW2 = '1'B              /* IF RECORD      YM2699*
*                 THEN                        /* ALREADY SPANNED JUST
*                                                ADD ON TO KNOWN
*                                                TOTAL          YM2699*
@99B     TM    E03BINSW,B'01000000'                               0591
         BC    12,@999                                            0591
*                   RECSIZE = PROCUR - CURBLK - KON8 + RECSIZE;
         L     @F,RECSIZE                                         0592
         SH    @F,KON8                                            0592
         S     @F,CURBLK                                          0592
         A     @F,PROCUR                                          0592
         ST    @F,RECSIZE                                         0592
         BC    15,@998                                            0593
*                 ELSE                        /* IF THIS IS     YM2699*
*                   DO;                       /* FIRST TIME FOR THIS
*                                                RECORD THEN INITIALIZE
*                                                THE RECORD LEN YM2699*
*                     RECSIZE = PROCUR - PROCIND;             /*YM2699*
@999     L     @F,PROCUR                                          0594
         S     @F,PROCIND                                         0594
         ST    @F,RECSIZE                                         0594
*                     E03SW2 = '1'B;                          /*YM2699*
         OI    E03BINSW,B'01000000'                               0595
*                   END;                                      /*YM2699*
*
*                 PROCUR = ADDGMN + KON8;     /* UPDATE TO NEW  BLOCK
*                                                               YM2699*
@998     LH    @F,KON8                                            0597
         A     @F,148(0,@6)                                       0597
         ST    @F,PROCUR                                          0597
*             END;
*         AVL78 = AMTGMN - KON8;              /* SET BYTES AVAILABLE =
*                                                SIZE OF NEW BLOCK MINU
*                                                8 FOR PROCSZE AND
*                                                PROCNXT              *
@99A     LH    @F,KON8                                            0599
         LCR   @F,@F                                              0599
         A     @F,152(0,@6)                                       0599
         STH   @F,AVL78                                           0599
*         PROCNXT  = KON0;                    /* INDICATE THERE ARE NO
*                                                BLOCKS AFTER THIS    *
         LH    @F,KON0                                            0600
         L     @7,148(0,@6)        
         ST    @F,0(0,@7)                                         0600
*         PROCSZE  = AMTGMN;                  /* SET SIZE OF THIS
*                                                BLOCK                *
         MVC   4(4,@7),152(@6)                                    0601
*         GOTO  E03ITO10;                     /* GO BACK TO MAINLINE  *
         BC    15,E03ITO10                                        0602
* E03SYN05:  ;                                /* SYNAD EXIT ROUTINE   *
*         GEN(SYNADAF ACSMETH=BSAM,PARM1=(R1),PARM2=(R0));
E03SYN05 SYNADAF ACSMETH=BSAM,PARM1=(R1),PARM2=(R0)
         DS    0H
*         R4 = R1;                            /* SAVE ADDR OF MESSAGE *
         LR    @4,@1                                              0605
*         R1 = R6;                            /* REG 1 POINTS TO PARMS*
         LR    @1,@6                                              0606
*         CNVA = KON82;                       /* SET LENGTH OF MSG    *
         MVC   200(2,@6),KON82                                    0607
*         VARSGLNG = DSNARLNG + KON4;         /* 1ST LVL VARIABLE LNG *
         LH    @F,KON4                                            0608
         AH    @F,312(0,@6)                                       0608
         STC   @F,296(0,@6)                                       0608
*         VARSGADR = ADDR(DSNAMAR);           /* 1ST LVL VARIABLE PART*
         LA    @F,314(0,@6)                                       0609
         ST    @F,@TEMP4                                          0609
         MVC   297(3,@6),@TEMP4+1                                 0609
*         VARSGLN2 = CNVC(2);                 /* IND LVL VARIABLE LNG *
         MVC   300(1,@6),201(@6)                                  0610
*         VARSGAD2 = R4 + KON50;              /* 2ND LVL VARIABLE PART*
         LH    @F,KON50                                           0611
         AR    @F,@4                                              0611
         ST    @F,@TEMP4                                          0611
         MVC   301(3,@6),@TEMP4+1                                 0611
*         LVL1NO = KON3;                      /* NUMBER OF 1ST LVL MSG*
         MVC   304(2,@6),KON3                                     0612
*         LVL2NO = KON2;                      /* NUMBER OF 2ND LLV MSG*
         MVC   306(2,@6),KON2                                     0613
*         GEN;
         LINK  EP=IKJEFE04         LINK TO MESSAGE MODULE
         SYNADRLS                  RELEASE SYNADAF WORK AREAS
         DS    0H
*         E01SW9 = '1'B;                      /*SET TERMINATION SWITCH*
         OI    203(@6),B'10000000'                                0615
*         RETURN;                             /* RETURN TO CONTROL MOD*
         BC    15,@EL01                                           0616
* E03MML05:     VARSGLN2 = KONX00;
E03MML05 MVC   300(1,@6),KONSTRUC                                 0617
*         R1  = R6;
         LR    @1,@6                                              0618
*         GEN(LINK  EP=IKJEFE04);             /* GO TO MSG SENDER     *
         LINK  EP=IKJEFE04
         DS    0H
*         GOTO INDAD1;                        /* RETURN TO CALL PLACE *
         L     @7,88(0,@6)         
         BCR   15,@7                                              0620
* TRTINST: GEN(TRT   0(0,R3),TRTAB       MODEL TRANS. & TEST INSTRUCT);
TRTINST  TRT   0(0,R3),TRTAB       MODEL TRANS. & TEST INSTRUCT
         DS    0H
*                                             /* TRANSLATE AND TEST   *
*                                             /* INSTRUCTION EXECUTED *
*                                             /* IN SEARCH OF SYMBOLIC*
*                                             /* PARAMETERS           *
*         GEN;
SGET      EQU   *
DDGETM   GETMAIN VC,MF=L
EGET      EQU   *
SFRE      EQU   *
DDFREM   FREEMAIN E,MF=L
EFRE      EQU   *
         DS    0H
*         GENERATE DATA;
*         END
* /* THE FOLLOWING INCLUDE STATEMENTS WERE FOUND IN THIS PROGRAM.
* /*%INCLUDE SYSLIB  (IKJCPPL )
* ;
@EL01    L     @D,4(0,@D)                                         0624
         LR    @1,@C                                              0624
         L     @0,@SIZ001                                         0624
         FREEMAIN R,LV=(0),A=(1)                                  0624
         L     @E,12(0,@D)                                        0624
         L     @0,20(0,@D)                                        0624
         LM    @2,@C,28(@D)                                       0624
         BCR   15,@E                                              0624
@DATA1   EQU   *
@0       EQU   00                  EQUATES FOR REGISTERS 0-15
@1       EQU   01
@2       EQU   02
@3       EQU   03
@4       EQU   04
@5       EQU   05
@6       EQU   06
@7       EQU   07
@8       EQU   08
@9       EQU   09
@A       EQU   10
@B       EQU   11
@C       EQU   12
@D       EQU   13
@E       EQU   14
@F       EQU   15
@D1      DC    H'1'
@CLC     CLC   0(1,@A),0(@E)
@MVC     MVC   0(1,@A),0(@E)
         DS    0F
@SIZ001  DC    AL1(&SPN)
         DC    AL3(@DATEND-@DATD)
         DS    0F
         DS    0D
@DATA    EQU   *
DUMPARM  EQU   00000000            FULLWORD INTEGER
R0       EQU   00000000            FULLWORD POINTER REGISTER
R1       EQU   00000001            FULLWORD POINTER REGISTER
R2       EQU   00000002            FULLWORD POINTER REGISTER
R3       EQU   00000003            FULLWORD POINTER REGISTER
R4       EQU   00000004            FULLWORD POINTER REGISTER
R5       EQU   00000005            FULLWORD POINTER REGISTER
R6       EQU   00000006            FULLWORD POINTER REGISTER
R15      EQU   00000015            FULLWORD POINTER REGISTER
KON0     EQU   *                   HALFWORD INTEGER
         DC    FL2'0'
KON1     EQU   *                   HALFWORD INTEGER
         DC    FL2'1'
KON2     EQU   *                   HALFWORD INTEGER
         DC    FL2'2'
KON3     EQU   *                   HALFWORD INTEGER
         DC    FL2'3'
KON4     EQU   *                   HALFWORD INTEGER
         DC    FL2'4'
KON5     EQU   *                   HALFWORD INTEGER
         DC    FL2'5'
KON7     EQU   *                   HALFWORD INTEGER
         DC    FL2'7'
KON8     EQU   *                   HALFWORD INTEGER
         DC    FL2'8'
KON11    EQU   *                   HALFWORD INTEGER
         DC    FL2'11'
KON12    EQU   *                   HALFWORD INTEGER
         DC    FL2'12'
KON13    EQU   *                   HALFWORD INTEGER
         DC    FL2'13'
KON14    EQU   *                   HALFWORD INTEGER
         DC    FL2'14'
KON15    EQU   *                   HALFWORD INTEGER
         DC    FL2'15'
KON16    EQU   *                   HALFWORD INTEGER
         DC    FL2'16'
KON50    EQU   *                   HALFWORD INTEGER
         DC    FL2'50'
KON78    EQU   *                   HALFWORD INTEGER
         DC    FL2'78'
KON82    EQU   *                   HALFWORD INTEGER
         DC    FL2'82'
KON256   EQU   *                   HALFWORD INTEGER
         DC    FL2'256'
KON1992  EQU   *                   HALFWORD INTEGER
         DC    FL2'1992'
KONSTRUC EQU   @DATA+00000040      5 BYTE(S) ON WORD
         ORG   KONSTRUC+00000000
KONX00   EQU   *                   1 BYTE(S)
         DC    X'00'
KONX20   EQU   *                   1 BYTE(S)
         DC    X'20'
KONXFF   EQU   *                   1 BYTE(S)
         DC    X'FF'
KON7FFC  EQU   *                   2 BYTE(S)
         DC    X'7FFC'
E01DATDF EQU   00000000            360 BYTE(S) ON DWORD
DCBAR    EQU   E01DATDF+00000000   88 BYTE(S) ON DWORD
ADPTR1   EQU   E01DATDF+00000088   FULLWORD POINTER
ADPTR2   EQU   E01DATDF+00000092   FULLWORD POINTER
MMNAMAR  EQU   E01DATDF+00000096   8 BYTE(S) ON WORD
RDECB    EQU   E01DATDF+00000104   20 BYTE(S) ON WORD
A00000   EQU   E01DATDF+00000104   6 BYTE(S)
DECLNGTH EQU   E01DATDF+00000110   HALFWORD INTEGER
A00001   EQU   E01DATDF+00000112   8 BYTE(S)
DECIOBPT EQU   E01DATDF+00000120   FULLWORD POINTER
LINPTR1  EQU   E01DATDF+00000124   FULLWORD POINTER
EOLCNT   EQU   E01DATDF+00000128   FULLWORD INTEGER
POSCNT   EQU   E01DATDF+00000132   FULLWORD INTEGER
TSTLNG   EQU   E01DATDF+00000136   FULLWORD INTEGER
TSTLNGC  EQU   E01DATDF+00000136   4 BYTE(S)
GMNMIN   EQU   E01DATDF+00000140   FULLWORD INTEGER
GMNMAX   EQU   E01DATDF+00000144   FULLWORD INTEGER
ADDGMN   EQU   E01DATDF+00000148   FULLWORD POINTER
AMTGMN   EQU   E01DATDF+00000152   FULLWORD INTEGER
SP78ADDR EQU   E01DATDF+00000156   FULLWORD POINTER
SP78LNGT EQU   E01DATDF+00000160   FULLWORD POINTER
RDXCNV   EQU   E01DATDF+00000164   FULLWORD INTEGER
DDIG     EQU   E01DATDF+00000164   1 BYTE(S)
POSSPC   EQU   E01DATDF+00000168   FULLWORD INTEGER
ATABIND  EQU   E01DATDF+00000172   FULLWORD POINTER
ATABCUR  EQU   E01DATDF+00000176   FULLWORD POINTER
FTABIND  EQU   E01DATDF+00000180   FULLWORD POINTER
FTABCUR  EQU   E01DATDF+00000184   FULLWORD POINTER
VALCNT   EQU   E01DATDF+00000188   FULLWORD INTEGER
KWOCNT   EQU   E01DATDF+00000192   HALFWORD INTEGER
KWWCNT   EQU   E01DATDF+00000194   HALFWORD INTEGER
KWOBYT   EQU   E01DATDF+00000196   HALFWORD INTEGER
KWWBYT   EQU   E01DATDF+00000198   HALFWORD INTEGER
CNVA     EQU   E01DATDF+00000200   HALFWORD INTEGER
CNVC     EQU   E01DATDF+00000200   2 BYTE(S)
E01BINSW EQU   E01DATDF+00000202   2 BYTE(S) ON HWORD
E01SW1   EQU   E01DATDF+00000202   1 BIT(S)
E01SW2   EQU   E01DATDF+00000202   1 BIT(S)
E01SW3   EQU   E01DATDF+00000202   1 BIT(S)
E01SW4   EQU   E01DATDF+00000202   1 BIT(S)
E01SW5   EQU   E01DATDF+00000202   1 BIT(S)
E01SW6   EQU   E01DATDF+00000202   1 BIT(S)
E01SW7   EQU   E01DATDF+00000202   1 BIT(S)
E01SW8   EQU   E01DATDF+00000202   1 BIT(S)
E01SW9   EQU   E01DATDF+00000203   1 BIT(S)
E01SW10  EQU   E01DATDF+00000203   1 BIT(S)
E01SW11  EQU   E01DATDF+00000203   1 BIT(S)
E01SW12  EQU   E01DATDF+00000203   1 BIT(S)
E01SW13  EQU   E01DATDF+00000203   1 BIT(S)
E01SW14  EQU   E01DATDF+00000203   1 BIT(S)
E01SW15  EQU   E01DATDF+00000203   1 BIT(S)
E01SW16  EQU   E01DATDF+00000203   1 BIT(S)
REGSAV   EQU   E01DATDF+00000204   3*FULLWORD INTEGER
LATAB    EQU   E01DATDF+00000216   FULLWORD POINTER
LFTAB    EQU   E01DATDF+00000220   FULLWORD POINTER
BFAPTR   EQU   E01DATDF+00000224   FULLWORD INTEGER
BFBPTR   EQU   E01DATDF+00000228   FULLWORD POINTER
CPPLPTR  EQU   E01DATDF+00000232   FULLWORD POINTER
STPRM    EQU   E01DATDF+00000236   3*FULLWORD INTEGER
PPLPTR   EQU   E01DATDF+00000248   FULLWORD POINTER
CBCOR    EQU   E01DATDF+00000252   24 BYTE(S)
SRECB    EQU   E01DATDF+00000276   FULLWORD INTEGER
RETCDAR  EQU   E01DATDF+00000280   FULLWORD INTEGER
ABLK1    EQU   E01DATDF+00000284   FULLWORD POINTER
EOB      EQU   E01DATDF+00000288   FULLWORD POINTER
RCDST    EQU   E01DATDF+00000292   FULLWORD POINTER
VARSGLNG EQU   E01DATDF+00000296   1 BYTE(S)
VARSGADR EQU   E01DATDF+00000297   3  BYTE  POINTER ON WORD+1
VARSGLN2 EQU   E01DATDF+00000300   1 BYTE(S)
VARSGAD2 EQU   E01DATDF+00000301   3  BYTE  POINTER ON WORD+1
LVL1NO   EQU   E01DATDF+00000304   HALFWORD INTEGER
LVL2NO   EQU   E01DATDF+00000306   HALFWORD INTEGER
PDLPTR   EQU   E01DATDF+00000308   FULLWORD POINTER
DRDNPTR  EQU   E01DATDF+00000312   46 BYTE(S) ON WORD
DSNARLNG EQU   E01DATDF+00000312   HALFWORD INTEGER
DSNARLCH EQU   E01DATDF+00000312   2 BYTE(S)
DSNAMAR  EQU   E01DATDF+00000314   44 BYTE(S)
CBUFLSAV EQU   E01DATDF+00000358   HALFWORD INTEGER
CBUFLSAC EQU   E01DATDF+00000358   2 BYTE(S)
CPPL     EQU   00000000            16 BYTE(S) ON WORD
CPPLCBUF EQU   CPPL+00000000       FULLWORD POINTER
CPPLUPT  EQU   CPPL+00000004       FULLWORD POINTER
CPPLPSCB EQU   CPPL+00000008       FULLWORD POINTER
CPPLECT  EQU   CPPL+00000012       FULLWORD POINTER
CBUFPTR  EQU   00000000            FULLWORD POINTER
CBUF     EQU   00000000            5 BYTE(S) ON WORD
CBUFLNG  EQU   CBUF+00000000       HALFWORD POINTER
CBUFOFF  EQU   CBUF+00000002       HALFWORD POINTER
CBUFDATA EQU   CBUF+00000004       1 BYTE(S)
DCBD     EQU   00000000            88 BYTE(S) ON DWORD
A00002   EQU   DCBD+00000000       26 BYTE(S)
DCBDSORG EQU   DCBD+00000026       2 BYTE(S)
A00003   EQU   DCBD+00000028       5 BYTE(S)
DCBEODAD EQU   DCBD+00000033       3  BYTE  POINTER ON WORD+1
DCBRECFM EQU   DCBD+00000036       1 BYTE(S)
DCBRCFF  EQU   DCBD+00000036       1 BIT(S)
DCBRCFV  EQU   DCBD+00000036       1 BIT(S)
DCBEXLST EQU   DCBD+00000037       3  BYTE  POINTER ON WORD+1
DCBDDNAM EQU   DCBD+00000040       8 BYTE(S)
DCBOFLGS EQU   DCBD+00000048       1 BYTE(S)
A00004   EQU   DCBD+00000049       1 BYTE(S)
DCBMACR  EQU   DCBD+00000050       2 BYTE(S)
A00005   EQU   DCBD+00000052       10 BYTE(S)
DCBBLKSI EQU   DCBD+00000062       HALFWORD INTEGER
A00006   EQU   DCBD+00000064       18 BYTE(S)
DCBLRECL EQU   DCBD+00000082       HALFWORD INTEGER
A00007   EQU   DCBD+00000084       4 BYTE(S)
         ENTRY E03PRT05
         ENTRY E03SYN05
ATAB     EQU   00000000            12 BYTE(S) ON WORD
ATABLST  EQU   ATAB+00000000       FULLWORD POINTER
ATABNXT  EQU   ATAB+00000004       FULLWORD POINTER
ATABLNG  EQU   ATAB+00000008       FULLWORD INTEGER
FTAB     EQU   00000000            12 BYTE(S) ON WORD
FTABLST  EQU   FTAB+00000000       FULLWORD POINTER
FTABNXT  EQU   FTAB+00000004       FULLWORD POINTER
FTABLNG  EQU   FTAB+00000008       HALFWORD INTEGER
FTABDLNG EQU   FTAB+00000010       HALFWORD INTEGER
ATABELMT EQU   00000000            263 BYTE(S) ON WORD
FTABPTR  EQU   ATABELMT+00000000   4 BYTE(S)
ATABFLGS EQU   ATABELMT+00000004   1 BYTE(S)
ATABELNC EQU   ATABELMT+00000005   2 BYTE(S)
ATABDAT  EQU   ATABELMT+00000007   256 BYTE(S)
FTABELMT EQU   00000000            260 BYTE(S) ON WORD
FTABELNG EQU   FTABELMT+00000000   4 BYTE(S)
FTABDAT  EQU   FTABELMT+00000004   256 BYTE(S)
INPLIN   EQU   00000000            32767 BYTE(S)
RCDLNG   EQU   00000000            2 BYTE(S)
RCDLNGA  EQU   00000000            HALFWORD INTEGER
IOB      EQU   00000000            16 BYTE(S) ON WORD
A00008   EQU   IOB+00000000        14 BYTE(S)
CSWCNT   EQU   IOB+00000014        HALFWORD INTEGER
PROCDAT  EQU   00000000            32767 BYTE(S)
PROCRCL  EQU   00000000            2 BYTE(S)
PROCRCLF EQU   00000000            HALFWORD INTEGER
PROCRES  EQU   00000002            16 BIT(S) ON BYTE
PROCNXT  EQU   00000000            FULLWORD POINTER
PROCSZE  EQU   00000004            FULLWORD INTEGER
TRTAB    EQU   *                   256*1 BYTE(S)
         DC    00080X'00'
         DC    C'&&'
         DC    00175X'00'
TCHAR    EQU   @DATA+00000301      5 BYTE(S)
KBLNK    EQU   *                   1 BYTE(S)
         DC    C' '
KCOM     EQU   *                   1 BYTE(S)
         DC    C','
KTAB     EQU   *                   1 BYTE(S)
         DC    X'05'
KAMP     EQU   *                   1 BYTE(S)
         DC    C'&&'
KPERD    EQU   *                   1 BYTE(S)
         DC    C'.'
KCONT    EQU   *                   1 BYTE(S)
         DC    C'-'
KCONTP   EQU   *                   1 BYTE(S)
         DC    C'+'
KONSLAST EQU   *                   2 BYTE(S)
         DC    C'/*'
KONASTSL EQU   *                   2 BYTE(S)
         DC    C'*/'
         ORG   @DATA
         DS    00000312C
@L       EQU   2
@DATD    DSECT
@SAV001  EQU   @DATD+00000000      72 BYTE(S) ON WORD
OFFSET   EQU   @DATD+00000072      FULLWORD POINTER
REMCHAR  EQU   @DATD+00000076      HALFWORD INTEGER
REMCHARC EQU   @DATD+00000076      2 BYTE(S)
LINENO   EQU   @DATD+00000078      8 BYTE(S)
AVL78    EQU   @DATD+00000086      HALFWORD INTEGER
PRMSTR   EQU   @DATD+00000088      FULLWORD POINTER
PROCIND  EQU   @DATD+00000092      FULLWORD POINTER
PROCUR   EQU   @DATD+00000096      FULLWORD POINTER
E03BINSW EQU   @DATD+00000100      1 BYTE(S)
E03SW1   EQU   E03BINSW+00000000   1 BIT(S)
E03SW2   EQU   E03BINSW+00000000   1 BIT(S)
E03SW3   EQU   E03BINSW+00000000   1 BIT(S)
E03SW4   EQU   E03BINSW+00000000   1 BIT(S)
E03SW5   EQU   E03BINSW+00000000   1 BIT(S)
CONTPLUS EQU   E03BINSW+00000000   1 BIT(S)
E03SW6   EQU   E03BINSW+00000000   1 BIT(S)
ENDDLM   EQU   E03BINSW+00000000   1 BIT(S)
E03SW7   EQU   E03BINSW+00000000   1 BIT(S)
NULLINE  EQU   E03BINSW+00000000   1 BIT(S)
A00009   EQU   E03BINSW+00000000   1 BIT(S)
TEMP01   EQU   @DATD+00000104      FULLWORD INTEGER
TEMP02   EQU   @DATD+00000108      FULLWORD INTEGER
TEMP03   EQU   @DATD+00000112      FULLWORD INTEGER
TEMP04   EQU   @DATD+00000116      FULLWORD INTEGER
TEMP05   EQU   @DATD+00000120      FULLWORD INTEGER
TEMPC05  EQU   TEMP05+00000000     4 BYTE(S)
CURBLK   EQU   @DATD+00000124      FULLWORD POINTER
RECSIZE  EQU   @DATD+00000128      FULLWORD INTEGER
RECSIZEC EQU   RECSIZE+00000000    4 BYTE(S)
I        EQU   @DATD+00000132      FULLWORD INTEGER
         DS    00000140C
@TEMPS   DS    0F
@TEMP2   DC    F'0'
@TEMP4   DC    F'0'
@CTEMP2  DS    CL001
         CNOP  0,4
AAGETM    DS    CL(EGET-SGET)
         CNOP  0,4
AAFREM    DS    CL(EFRE-SFRE)
@DATD    DSECT
@DATEND  EQU   *
IKJEFE03 CSECT ,
@9FC     EQU   E03CNT15
E03CNT10 EQU   @EL01
@9F0     EQU   E03SPL25
@9DB     EQU   @DO9DE
E03SPL09 EQU   E03IMR05
@9D8     EQU   E03IMR05
@9D4     EQU   E03PVL10
@9BA     EQU   E03SPL10
@9B5     EQU   E03SPL05
@9B0     EQU   E03PRT30
@9AF     EQU   E03PRT35
@9A9     EQU   E03FMN05
         END
