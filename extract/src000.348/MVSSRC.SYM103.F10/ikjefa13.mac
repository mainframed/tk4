         TITLE 'IKJEFA13 - ACCOUNT/ADD SUBCOMMAND (AUGMENT MODULE 2)   *
                       '
IKJEFA13 CSECT ,                                                   0001
@MAINENT DS    0H                                                  0001
         USING *,@15                                               0001
         B     @PROLOG                                             0001
         DC    AL1(16)                                             0001
         DC    C'IKJEFA13  73.209'                                 0001
         DROP  @15
@PROLOG  STM   @14,@12,12(@13)                                     0001
         BALR  @12,0                                               0001
@PSTART  DS    0H                                                  0001
         USING @PSTART,@12                                         0001
         L     @00,@SIZDATD                                        0001
         GETMAIN R,LV=(0)
         LR    @11,@01                                             0001
         USING @DATD,@11                                           0001
         ST    @13,@SA00001+4                                      0001
         LM    @00,@01,20(@13)                                     0001
         ST    @11,8(,@13)                                         0001
         LR    @13,@11                                             0001
*          COMMPTR=R1;                  /* GET POINTER TO COMMON     */
         LR    COMMPTR,R1                                          0029
*          RFY R1 UNRSTD;               /* RELEASE REGISTER 1        */
*          FNOUTPTR=0;                  /* CLEAR PTR TO SKIP FREEMAIN*/
         SLR   @09,@09                                             0031
         ST    @09,FNOUTPTR                                        0031
*          /* MOVE L-FORMS OF O/S MACROS INTO DYNAMIC STORAGE        */
*          DYNLFORM(1:INLINLNG)=INLINLFM(1:INLINLNG);              0032
         L     @09,INLINLNG                                        0032
         BCTR  @09,0                                               0032
         EX    @09,@SM00413                                        0032
*          OUTLNDS=OUTLNDS&&OUTLNDS;    /* CLEAR OUTPUT LINE       0033
*                                          DESCRIPTORS FOR PUTLINE   */
         XC    OUTLNDS(52),OUTLNDS                                 0033
*          OUT1LINK=ADDR(OUTLD2);       /* INITIALIZE LINKAGE FOR  0034
*                                          2 MESSAGE LEVELS          */
         LA    @09,OUTLD2                                          0034
         ST    @09,OUT1LINK                                        0034
*          MSGBASE=ADDR(MSGTABLE);      /* BASE FOR MSG PTR TABLE    */
         L     MSGBASE,@CV00111                                    0035
*          /* BUILD USERID SEGMENT FOR MESSAGES JUST IN CASE ...     */
*          /* SCAN FOR & DELETE TRAILING BLANKS                      */
*          USRIDLN=LENGTH(USRIDSEG);    /* INIT USERID LENGTH TO MAX */
         MVC   USRIDLN(2),@CH00055                                 0036
*          DO WHILE BLDLLIST(USRIDLN)=' '; /* LOOP TILL NON-BLANK    */
         B     @DE00037                                            0037
@DL00037 DS    0H                                                  0038
*            USRIDLN=USRIDLN-1;         /* DECREMENT LENGTH OF SEGMEN*/
         LH    @09,USRIDLN                                         0038
         BCTR  @09,0                                               0038
         STH   @09,USRIDLN                                         0038
*          END;                                                    0039
@DE00037 LH    @09,USRIDLN                                         0039
         L     @15,BLDLPTR(,COMMPTR)                               0039
         ALR   @09,@15                                             0039
         AL    @09,@CF00344                                        0039
         CLI   BLDLLIST(@09),C' '                                  0039
         BE    @DL00037                                            0039
*          USRIDLN=USRIDLN-1;           /* DECREMENT PAST INDEX      */
         LH    @09,USRIDLN                                         0040
         BCTR  @09,0                                               0040
         STH   @09,USRIDLN                                         0040
*          USRIDI=BLDLNAME;             /* USERID FROM SAVE SLOT     */
         MVC   USRIDI(8),BLDLNAME(@15)                             0041
*          /*** INSERTION OFFSET IS SET WHEN MESSAGE IS BUILT      ***/
*          HEDBPTR=ACIOBUFR;            /* ESTABLISH USER ADDRESSBLTY*/
         L     @09,ACIOPTR(,COMMPTR)                               0042
         SLR   HEDBPTR,HEDBPTR                                     0042
         ICM   HEDBPTR,7,ACIOBUFR(@09)                             0042
*          N=NUMOFLVL;                  /* SET WORK COUNTER TO NUMBER
*                                          OF LEVELS IN THE NODELIST */
         SLR   N,N                                                 0043
         IC    N,NUMOFLVL(,COMMPTR)                                0043
*          IF RSIZSW='1'B               /* IS SIZE > MAXSIZE?        */
*            THEN                       /* YES,                      */
         TM    RSIZSW(COMMPTR),B'00010000'                         0044
         BNO   @RF00044                                            0044
*              PSIZE=UADSMAXC;          /* USE MAXSIZE               */
         SLR   @09,@09                                             0045
         ICM   @09,3,UADSMAXC(HEDBPTR)                             0045
         STH   @09,PSIZE                                           0045
*            ELSE                       /* NO,                       */
*              PSIZE=SIZEH;             /* USE SPECIFIED SIZE        */
         B     @RC00044                                            0046
@RF00044 SLR   @09,@09                                             0046
         ICM   @09,3,SIZEH(COMMPTR)                                0046
         STH   @09,PSIZE                                           0046
*          /**********************************************************/
*          /* THIS SECTION SEARCHES FOR THE 'LOWEST' LEVEL IN THE    */
*          /* NODELIST = *.  THE NUMBER OF NODES AT THAT LEVEL REPRE-*/
*          /* SENTS AN UPPER BOUND TO THE NUMBER OF NODES TO WHICH   */
*          /* THE DATALIST MUST BE ADDED.                            */
*          /**********************************************************/
*          NUMOFNDS=1;                  /* INITIALIZE NUMBER OF NODES*/
@RC00044 LA    NUMOFNDS,1                                          0047
*          UADSNPTR=ADDR(UADSPWD1);     /* INITIALIZE NODE BASE AS IF
*                                          OFFSET TO INITIAL PASSWORD
*                                          NODE WERE PART OF A     0048
*                                          STANDARD NODE BLOCK       */
         LA    UADSNPTR,UADSPWD1(,HEDBPTR)                         0048
*          IF ACCTNO(1:2)='* '          /* IS THE ACCTNO AN ASTERISK?*/
*            THEN                       /* YES -                     */
         L     @09,NODELADR(,COMMPTR)                              0049
         CLC   ACCTNO(2,@09),@CC00312                              0049
         BNE   @RF00049                                            0049
*              DO;                                                 0050
*                /* CHAIN DOWN TO ACCOUNT NUMBER LEVEL OF USER MEMBER*/
*                UADSNPTR=UADSNNEX+HEDBPTR;/* POINT TO FIRST PASSWORD*/
         SLR   @09,@09                                             0051
         ICM   @09,7,UADSNNEX(UADSNPTR)                            0051
         AR    @09,HEDBPTR                                         0051
         LR    UADSNPTR,@09                                        0051
*                UADSNPTR=UADSNSUB+HEDBPTR;/* POINT TO FIRST ACCTNO. */
         LR    @09,HEDBPTR                                         0052
         A     @09,UADSNSUB(,UADSNPTR)                             0052
         LR    UADSNPTR,@09                                        0052
*                /* COUNT THE NODES ON THE ACCOUNT NUMBER LEVEL      */
*                DO WHILE UADSNNEX^=0;    /* LOOP TILL NO MORE NODES */
         B     @DE00053                                            0053
@DL00053 DS    0H                                                  0054
*                  NUMOFNDS=NUMOFNDS+1;   /* COUNT ONE               */
         AH    NUMOFNDS,@CH00032                                   0054
*                  UADSNPTR=UADSNNEX+                              0055
*                     HEDBPTR;          /* STEP SIDEWAYS TO NEXT NODE*/
         SLR   @09,@09                                             0055
         ICM   @09,7,UADSNNEX(UADSNPTR)                            0055
         AR    @09,HEDBPTR                                         0055
         LR    UADSNPTR,@09                                        0055
*                END;                                              0056
@DE00053 ICM   @09,7,UADSNNEX(UADSNPTR)                            0056
         BNZ   @DL00053                                            0056
*              END;                                                0057
*            ELSE                                                  0058
*              IF PASSWD(1:2)='* '      /* IS THE PASSWD AN ASTERISK?*/
*                THEN                   /* YES -                     */
         B     @RC00049                                            0058
@RF00049 L     @09,NODELADR(,COMMPTR)                              0058
         CLC   PASSWD(2,@09),@CC00312                              0058
         BNE   @RF00058                                            0058
*                  /* COUNT THE NODES ON THE PASSWORD LEVEL          */
*                  DO WHILE UADSNNEX^=0;/* LOOP TILL NO MORE NODES   */
         B     @DE00059                                            0059
@DL00059 DS    0H                                                  0060
*                    NUMOFNDS=NUMOFNDS+1;/* COUNT ONE                */
         AH    NUMOFNDS,@CH00032                                   0060
*                    UADSNPTR=UADSNNEX+                            0061
*                      HEDBPTR;         /* STEP SIDEWAYS TO NEXT NODE*/
         SLR   @09,@09                                             0061
         ICM   @09,7,UADSNNEX(UADSNPTR)                            0061
         AR    @09,HEDBPTR                                         0061
         LR    UADSNPTR,@09                                        0061
*                  END;                                            0062
@DE00059 ICM   @09,7,UADSNNEX(UADSNPTR)                            0062
         BNZ   @DL00059                                            0062
*          /* NUMOFNDS NOW = THE NUMBER OF NODES AT LEVEL N.         */
*          RFY R0 RSTD;                 /* RESERVE REGS. FOR GETMAIN */
@RF00058 DS    0H                                                  0063
@RC00049 DS    0H                                                  0064
*          /* CALCULATE AMOUNT OF WORKING STORAGE NEEDED BY FINDNODE */
*          R0=4*(NUMOFNDS+N);           /* MAY BE MORE THAN NECESSARY*/
         LR    R0,NUMOFNDS                                         0064
         AR    R0,N                                                0064
         SLA   R0,2                                                0064
*          FNOUTLNG=R0;                 /* SAVE LENGTH FOR FREEMAIN  */
         ST    R0,FNOUTLNG                                         0065
*          /* ISSUE GETMAIN TO OBTAIN FINDNODE WORKING STORAGE       */
*          GEN (GETMAIN EC,LV=(R0),A=FNOUTPTR,MF=(E,DYNGTLST))     0066
*            REFS(DYNGTLST) SETS(FNOUTPTR);                        0066
         GETMAIN EC,LV=(R0),A=FNOUTPTR,MF=(E,DYNGTLST)
*          RFY R0 UNRSTD;               /* GIVE BACK REGISTER        */
*          RFY R15 RSTD;                /* RESTRICT RETURN CODE REG  */
*          RETNCODE=R15;                /* SAVE RETURN CODE          */
         LR    RETNCODE,R15                                        0069
*          RFY R15 UNRSTD;              /* RELEASE RETURN CODE REG   */
*          /* CHECK RETURN CODE                                      */
*          IF RETNCODE^=0                                          0071
*            THEN                       /* GETMAIN FAILED            */
         SLR   @09,@09                                             0071
         CR    RETNCODE,@09                                        0071
         BNE   @RT00071                                            0071
*              GOTO NOSPACE;            /* SCRATCH READ ROUTINE STG  */
*          FINDPTR=FNOUTPTR;            /* INITIALIZE FINDNODE OUTPUT
*                                          LIST INDEX                */
         L     @04,FNOUTPTR                                        0073
         LR    FINDPTR,@04                                         0073
*          MARKMARK=FNOUTPTR+FNOUTLNG-4;/* POINT TO LAST WORD        */
         L     @15,FNOUTLNG                                        0074
         LR    MARKMARK,@04                                        0074
         AR    MARKMARK,@15                                        0074
         SH    MARKMARK,@CH00108                                   0074
*          /* SET UP TO CLEAR THE WORK AREA TO ZEROES                */
*          RFY (R0,R1,R15) RSTD;        /* RESTRICT WORK REGISTERS   */
*          R0=FNOUTPTR;                 /* GET TO ADDRESS            */
         LR    R0,@04                                              0076
*          R1=FNOUTLNG;                 /* LOAD R1 WITH LENGTH       */
         L     @14,FNOUTLNG                                        0077
         LR    R1,@14                                              0077
*          R15=0;                       /* LOAD R15 WITH 0 LENGTH    */
         SLR   @04,@04                                             0078
         LR    R15,@04                                             0078
*          GEN (MVCL  R0,R14)           /* CLEAR GOTTEN CORE         */
*            REFS(R0,R1,R15);                                      0079
         MVCL  R0,R14
*          RFY (R0,R1,R15) UNRSTD;      /* RELEASE WORK REGISTERS    */
*          /* BEGIN SEARCH FOR NODE(S) SPECIFIED BY NODELIST OPERAND */
*          MARKFLAG(1)='1'B;            /* TURN ON 'BOTTOM-OF-LIST'
*                                          INDICATOR                 */
         OI    MARKFLAG(MARKMARK),B'10000000'                      0081
*          MARKER=UADSPWD1+HEDBPTR;     /* INITIALIZE TO ADDRESS OF
*                                          FIRST PASSWORD NODE       */
         LR    @04,HEDBPTR                                         0082
         A     @04,UADSPWD1(,HEDBPTR)                              0082
         STCM  @04,7,MARKER(MARKMARK)                              0082
*          NODEPDE=NODEPDE&&NODEPDE;    /* CLEAR DUMMY PDE           */
         XC    NODEPDE(14),NODEPDE                                 0083
*          LSCANPTR=ADDR(SCANLIST);     /* LATSCAN PARM LIST BASE PTR*/
         LA    LSCANPTR,SCANLIST                                   0084
*          /* SEE IF THE PASSWORD IS IN THE NODELIST                 */
*          IF PASSWD(1)='00'X                                      0085
*            THEN                       /* ITEM NOT IN NODELIST      */
         L     @15,NODELADR(,COMMPTR)                              0085
         CLI   PASSWD(@15),X'00'                                   0085
         BE    @RT00085                                            0085
*              GO TO MRKRTST1;          /* END-OF-ROUTINE            */
*          /* IS THE NODELIST PASSWORD AN '*' ?                      */
*          IF PASSWD(1:2)='* '                                     0087
*            THEN                       /* THIS LEVEL IS NON-SPECIFIC*/
         CLC   PASSWD(2,@15),@CC00312                              0087
         BE    @RT00087                                            0087
*              GO TO ANODETST;          /* GO LOOK FOR ACCT NUMBER   */
*          PASSWDP=ADDR(PASSWD);        /* GET ADDRESS OF PASSWORD   */
         LA    @03,PASSWD(,@15)                                    0089
         ST    @03,PASSWDP                                         0089
*          PWLEN1=8;                    /* GET LENGTH OF PASSWORD    */
         MVC   PWLEN1(2),@CH00040                                  0090
*          /* BUILD PARAMETER LIST FOR 'LATSCAN' SUBROUTINE          */
*          SCANTYPE=1;                  /* INIT SCANTYPE FOR PASSWORD*/
         MVI   SCANTYPE(LSCANPTR),X'01'                            0091
*          SCANPDE=ADDR(PASSWDP);       /* POINT TO PASSWORD PDE     */
         LA    @03,PASSWDP                                         0092
         STCM  @03,7,SCANPDE(LSCANPTR)                             0092
*          SCANFLGS='00'X;              /* SCAN LOCAL LATERAL CHAIN  */
         MVI   SCANFLGS(LSCANPTR),X'00'                            0093
*          SCANBEGN=MARKER;             /* BEGINNING OF SCAN         */
         STCM  @04,7,SCANBEGN(LSCANPTR)                            0094
*          CALL IKJLSCAN;               /* CALL 'LATSCAN' SUBROUTINE */
         BAL   @14,IKJLSCAN                                        0095
*          /* CHECK RETURN CODE - DID WE FIND THE NODELIST PASSWORD  */
*          IF SCANRTCD^=0                                          0096
*            THEN                       /* NO - NODE ITEM NOT FOUND  */
         LTR   SCANRTCD,SCANRTCD                                   0096
         BNZ   @RT00096                                            0096
*              GOTO NONODE;             /* GO TO ERROR TERMINATION   */
*          MARKER=SCANANSR->UADSNSUB+   /* MOVE MARKER TO LOWER LEVEL*/
*             HEDBPTR;                                             0098
         L     @04,SCANANSR(,LSCANPTR)                             0098
         LR    @15,HEDBPTR                                         0098
         A     @15,UADSNSUB(,@04)                                  0098
         STCM  @15,7,MARKER(MARKMARK)                              0098
*          /* SEE IF THE ACCOUNT NUMBER LEVEL IS IN THE NODELIST     */
*          IF ACCTNO(1)='00'X                                      0099
*            THEN                       /* ITEM NOT IN NODELIST      */
         L     @04,NODELADR(,COMMPTR)                              0099
         CLI   ACCTNO(@04),X'00'                                   0099
         BE    @RT00099                                            0099
*              GO TO MRKRTST1;          /* END-OF-ROUTINE            */
*          IF ACCTNO(1:2)='* '                                     0101
*            THEN                       /* THIS LEVEL IS NON-SPECIFIC*/
         CLC   ACCTNO(2,@04),@CC00312                              0101
         BNE   @RF00101                                            0101
*              DO;                                                 0102
*              /* ALL NODES ON THIS LEVEL QUALIFIED FOR AUGMENTATION.
*                 LOOP TILL THIS NODE THE LAST ONE IN LOCAL LATERAL
*                 CHAIN.                                             */
*              DO WHILE MARKFLAG(1)='1'B;                          0103
         B     @DE00103                                            0103
@DL00103 DS    0H                                                  0104
*                FOUNDNDE=MARKER->UADSNSUB+ /* PUT NODE ADDRESS IN   */
*                   HEDBPTR;            /*   FINDNODE OUTPUT LIST    */
         SLR   @04,@04                                             0104
         ICM   @04,7,MARKER(MARKMARK)                              0104
         LR    @15,HEDBPTR                                         0104
         A     @15,UADSNSUB(,@04)                                  0104
         STCM  @15,7,FOUNDNDE(FINDPTR)                             0104
*                FINDPTR=FINDPTR+4;     /* STEP TO NEXT WORD IN    0105
*                                          FINDNODE OUTPUT LIST      */
         AH    FINDPTR,@CH00108                                    0105
*                IF MARKER->UADSNFLG='1'B/* IS THIS THE END OF CHAIN?*/
*                  THEN                 /* YES,                      */
         TM    UADSNFLG(@04),B'10000000'                           0106
         BNO   @RF00106                                            0106
*                    MARKFLAG(1)='0'B;  /* TERMINATE LOOP            */
         NI    MARKFLAG(MARKMARK),B'01111111'                      0107
*                MARKER=MARKER->UADSNNEX+ /* STEP MARKER TO NEXT NODE*/
*                   HEDBPTR;            /*   ON THE SAME LEVEL       */
@RF00106 SLR   @04,@04                                             0108
         ICM   @04,7,MARKER(MARKMARK)                              0108
         SLR   @15,@15                                             0108
         ICM   @15,7,UADSNNEX(@04)                                 0108
         AR    @15,HEDBPTR                                         0108
         STCM  @15,7,MARKER(MARKMARK)                              0108
*                END;                                              0109
@DE00103 TM    MARKFLAG(MARKMARK),B'10000000'                      0109
         BO    @DL00103                                            0109
*              GOTO NONODE;                                        0110
         B     NONODE                                              0110
*              END;                                                0111
*          ACCTNOP=ADDR(ACCTNO);        /* GET ADDRESS OF ACCT NUMBER*/
@RF00101 L     @04,NODELADR(,COMMPTR)                              0112
         LA    @03,ACCTNO(,@04)                                    0112
         ST    @03,ACCTNOP                                         0112
*          ACTLEN1=ACTLEN;              /* GET LENGTH OF ACCT NUMBER */
         SLR   @03,@03                                             0113
         IC    @03,ACTLEN(,@04)                                    0113
         STH   @03,ACTLEN1                                         0113
*          /* BUILD PARAMETER LIST FOR 'LATSCAN' SUBROUTINE          */
*          SCANTYPE=2;                  /* INIT SCANTYPE FOR ACCTNO  */
         MVI   SCANTYPE(LSCANPTR),X'02'                            0114
*          SCANPDE=ADDR(ACCTNOP);       /* POINT TO ACCT NUM PDE     */
         LA    @04,ACCTNOP                                         0115
         STCM  @04,7,SCANPDE(LSCANPTR)                             0115
*          SCANFLGS='00'X;              /* SCAN LOCAL LATERAL CHAIN  */
         MVI   SCANFLGS(LSCANPTR),X'00'                            0116
*          SCANBEGN=MARKER;             /* BEGINNING OF SCAN         */
         MVC   SCANBEGN(3,LSCANPTR),MARKER(MARKMARK)               0117
*          CALL IKJLSCAN;               /* CALL 'LATSCAN' SUBROUTINE */
         BAL   @14,IKJLSCAN                                        0118
*          /* CHECK RETURN CODE - DID WE FIND THIS NODELIST ITEM     */
*          IF SCANRTCD^=0                                          0119
*            THEN                       /* NO - NODE ITEM NOT FOUND  */
         LTR   SCANRTCD,SCANRTCD                                   0119
         BNZ   @RT00119                                            0119
*              GOTO NONODE;             /* GO TO ERROR TERMINATION   */
*          MARKER=SCANANSR->UADSNSUB+                              0121
*             HEDBPTR;                  /* MOVE MARKER TO LOWER LEVEL*/
         L     @04,SCANANSR(,LSCANPTR)                             0121
         LR    @15,HEDBPTR                                         0121
         A     @15,UADSNSUB(,@04)                                  0121
         STCM  @15,7,MARKER(MARKMARK)                              0121
*          GOTO MRKRTST1;                                          0122
         B     MRKRTST1                                            0122
*ANODETST: /* THE NODELIST PASSWORD WAS AN ASTERISK. CHECK THE ACCOUNT
*             NUMBER                                                 */
*          IF ACCTNO(1)='00'X           /* WAS THE ACCTNO SPECIFIED? */
*            THEN                       /* ITEM NOT IN NODELIST      */
ANODETST L     @04,NODELADR(,COMMPTR)                              0123
         CLI   ACCTNO(@04),X'00'                                   0123
         BE    @RT00123                                            0123
*              GOTO ALLNODES;           /* ALL PASSWDS ARE QUALIFIED */
*          MARKER=MARKER->UADSNSUB+                                0125
*             HEDBPTR;                  /* MOVE MARKER TO ACTNO LEVEL*/
         SLR   @01,@01                                             0125
         ICM   @01,7,MARKER(MARKMARK)                              0125
         LR    @00,HEDBPTR                                         0125
         A     @00,UADSNSUB(,@01)                                  0125
         STCM  @00,7,MARKER(MARKMARK)                              0125
*          IF ACCTNO(1:2)='* '                                     0126
*            THEN                       /* THIS LEVEL IS NON-SPECIFIC*/
         CLC   ACCTNO(2,@04),@CC00312                              0126
         BE    @RT00126                                            0126
*              GOTO ALLNODES;           /* ALL ACCOUNT NUMBERS ARE 0127
*                                          QUALIFIED                 */
*          ACCTNOP=ADDR(ACCTNO);        /* GET ADDRESS OF ACCT NUMBER*/
         LA    @15,ACCTNO(,@04)                                    0128
         ST    @15,ACCTNOP                                         0128
*          ACTLEN1=ACTLEN;              /* GET LENGTH OF ACCT NUMBER */
         SLR   @15,@15                                             0129
         IC    @15,ACTLEN(,@04)                                    0129
         STH   @15,ACTLEN1                                         0129
*          /* BUILD PARAMETER LIST FOR 'LATSCAN' SUBROUTINE          */
*          SCANTYPE=2;                  /* INCREMENT SCAN TYPE INDEX */
         MVI   SCANTYPE(LSCANPTR),X'02'                            0130
*          SCANPDE=ADDR(ACCTNOP);       /* POINT TO ACCT NUMBER PDE  */
         LA    @04,ACCTNOP                                         0131
         STCM  @04,7,SCANPDE(LSCANPTR)                             0131
*          SCANFLGS='80'X;              /* SCAN TOTAL LATERAL CHAIN  */
         MVI   SCANFLGS(LSCANPTR),X'80'                            0132
*          DO WHILE MARKER^=HEDBPTR;    /* LOOP FOR ALL PASSWORDS    */
         B     @DE00133                                            0133
@DL00133 DS    0H                                                  0134
*            SCANBEGN=MARKER;           /* BEGINNING OF SCAN         */
         MVC   SCANBEGN(3,LSCANPTR),MARKER(MARKMARK)               0134
*            CALL IKJLSCAN;             /* CALL 'LATSCAN' SUBROUTINE */
         BAL   @14,IKJLSCAN                                        0135
*            /* CHECK RETURN CODE - DID WE FIND THIS NODELIST ITEM   */
*            IF SCANRTCD^=0                                        0136
*              THEN                     /* NO - NODE ITEM NOT FOUND  */
         LTR   SCANRTCD,SCANRTCD                                   0136
         BNZ   @RT00136                                            0136
*                GOTO NONODE;           /* GO TO ERROR TERMINATION   */
*            FOUNDNDE=SCANANSR->        /* PUT NODE ADDRESS IN       */
*               UADSNSUB+HEDBPTR;       /*   FINDNODE OUTPUT LIST    */
         L     @04,SCANANSR(,LSCANPTR)                             0138
         LR    @15,HEDBPTR                                         0138
         A     @15,UADSNSUB(,@04)                                  0138
         STCM  @15,7,FOUNDNDE(FINDPTR)                             0138
*            FINDPTR=FINDPTR+4;         /* STEP TO NEXT WORD IN    0139
*                                          FINDNODE OUTPUT LIST      */
         AH    FINDPTR,@CH00108                                    0139
*            MARKER=SCANANSR->          /* STEP MARKER TO NEXT NODE  */
*               UADSNNEX+HEDBPTR;       /*   ON THE SAME LEVEL       */
         SLR   @15,@15                                             0140
         ICM   @15,7,UADSNNEX(@04)                                 0140
         AR    @15,HEDBPTR                                         0140
         STCM  @15,7,MARKER(MARKMARK)                              0140
*            END;                                                  0141
@DE00133 SLR   @04,@04                                             0141
         ICM   @04,7,MARKER(MARKMARK)                              0141
         CR    HEDBPTR,@04                                         0141
         BNE   @DL00133                                            0141
*          GOTO NONODE;                                            0142
         B     NONODE                                              0142
*ALLNODES: /* CTL. PASSED HERE WHEN ALL NODES ON THIS LEVEL QUALIFIED
*             FOR AUGMENTATION.                                      */
*          /* LOOP TILL THIS NODE THE LAST ONE IN TOTAL LATERAL CHAIN*/
*          DO WHILE MARKER^=HEDBPTR;                               0143
ALLNODES B     @DE00143                                            0143
@DL00143 DS    0H                                                  0144
*            FOUNDNDE=MARKER->UADSNSUB+ /* PUT NODE ADDRESS IN       */
*               HEDBPTR;                /*   FINDNODE OUTPUT LIST    */
         SLR   @04,@04                                             0144
         ICM   @04,7,MARKER(MARKMARK)                              0144
         LR    @15,HEDBPTR                                         0144
         A     @15,UADSNSUB(,@04)                                  0144
         STCM  @15,7,FOUNDNDE(FINDPTR)                             0144
*            FINDPTR=FINDPTR+4;         /* STEP TO NEXT WORD IN    0145
*                                          FINDNODE OUTPUT LIST      */
         AH    FINDPTR,@CH00108                                    0145
*            MARKER=MARKER->UADSNNEX+   /* STEP MARKER TO NEXT NODE  */
*               HEDBPTR;                /*   ON THE SAME LEVEL       */
         SLR   @15,@15                                             0146
         ICM   @15,7,UADSNNEX(@04)                                 0146
         AR    @15,HEDBPTR                                         0146
         STCM  @15,7,MARKER(MARKMARK)                              0146
*            END;                                                  0147
@DE00143 SLR   @04,@04                                             0147
         ICM   @04,7,MARKER(MARKMARK)                              0147
         CR    HEDBPTR,@04                                         0147
         BNE   @DL00143                                            0147
*          GOTO NONODE;                                            0148
         B     NONODE                                              0148
*MRKRTST1: /* CTL. PASSED HERE FROM 'PARMTEST' UPON EXHAUSTION OF THE*/
*          /* ITEMS IN THE NODELIST.                                 */
*          FOUNDNDE=MARKER;             /* MARKER CONTAINS SOUGHT NDE*/
MRKRTST1 MVC   FOUNDNDE(3,FINDPTR),MARKER(MARKMARK)                0149
*          FNOEOLST='1'B;               /* SET END-OF-LIST FLAG      */
         OI    FNOEOLST(FINDPTR),B'10000000'                       0150
*          NONODESW='1'B;               /* SET 'NO-NODES-FOUND'    0151
*                                          INDICATOR OFF (ONE)       */
*          FINDEXSW='1'B;               /* INDICATE FINDNODE ROUTINE
*                                          HAS BEEN EXECUTED         */
         OI    NONODESW(COMMPTR),B'00001100'                       0152
*          GO TO ADDER;                 /* GO TO 'ADDER' ROUTINE     */
         B     ADDER                                               0153
*NONODE:   /* CTL PASSED HERE TO SEE IF ANY NODES WERE FOUND         */
*          /* IS THE OUTPUT LIST EMPTY ?                             */
*          IF FINDPTR=FNOUTPTR                                     0154
*            THEN                       /* NO NODE ADDRESSES EVER PUT
*                                          IN OUTPUT LIST            */
NONODE   C     FINDPTR,FNOUTPTR                                    0154
         BNE   @RF00154                                            0154
*              DO;                                                 0155
*                /****************************************************/
*                /* ACTION TAKEN HERE TO RELEASE THE READ ROUTINE'S  */
*                /* BUFFER AND BYPASS THE 'ADDER' ROUTINE            */
*                /****************************************************/
*                CALL WRITE;            /* SCRATCH READ ROUTINE'S STG*/
         BAL   @14,WRITE                                           0156
*                FINDEXSW='1'B;         /* INDICATE FINDNODE ROUTINE
*                                          HAS BEEN EXECUTED         */
         OI    FINDEXSW(COMMPTR),B'00000100'                       0157
*                GOTO ERREXIT;          /* BYPASS 'ADDER'            */
         B     ERREXIT                                             0158
*              END;                                                0159
*          FINDPTR=FINDPTR-4;           /* STEP BACK TO LAST USED PTR*/
@RF00154 SH    FINDPTR,@CH00108                                    0160
*          FNOEOLST='1'B;               /* SET END-OF-LIST FLAG      */
         OI    FNOEOLST(FINDPTR),B'10000000'                       0161
*          NONODESW='1'B;               /* SET 'NO-NODES-FOUND'    0162
*                                          INDICATOR OFF (ONE)       */
*          FINDEXSW='1'B;               /* INDICATE FINDNODE ROUTINE
*                                          HAS BEEN EXECUTED         */
         OI    NONODESW(COMMPTR),B'00001100'                       0163
*ADDER:    /* CTL. PASSED OR DROPPED TO HERE TO ADD THE 'DATALIST'   */
*          /* ITEMS TO EACH CHAIN LISTED IN THE FINDNODE OUTPUT LIST */
*          ADDWKAR=ADDWKAR&&ADDWKAR;    /* CLEAR ADDER WORK AREA     */
ADDER    XC    ADDWKAR(36),ADDWKAR                                 0164
*          MARKMARK=ADDR(ADDWKAR);      /* INITIALIZE MARKER OF    0165
*                                          MARKERS                   */
         LA    MARKMARK,ADDWKAR                                    0165
*          SETFLAG='1'B;                /* SET END-OF-LIST FLAG      */
         OI    SETFLAG(MARKMARK),B'10000000'                       0166
*          FINDPTR=FNOUTPTR;            /* POINT TO 1ST OUTPUT NODE  */
         L     FINDPTR,FNOUTPTR                                    0167
*          SPACMPTR=HEDBPTR;            /* ADDR OF USER ENTRY BUFFER */
         ST    HEDBPTR,SPACMPTR                                    0168
*          SPACMCNT=ACIONMBR;           /* NO. OF MEMBER BLKS IN BUFR*/
         L     @04,ACIOPTR(,COMMPTR)                               0169
         SLR   @15,@15                                             0169
         IC    @15,ACIONMBR(,@04)                                  0169
         STH   @15,SPACMCNT                                        0169
*ADDRBEGN: /* BEGIN ADDING ITEMS SPECIFIED BY 'DATA' KEYWORD SUBFIELD*/
*          MARKER1=DATASUBP;            /* POINT TO FIRST DATA PDE   */
ADDRBEGN MVC   MARKER1(3,MARKMARK),DATASUBP+1(COMMPTR)             0170
*          SCANTYPE=1;                  /* INITIALIZE SCAN TYPE INDEX*/
         MVI   SCANTYPE(LSCANPTR),X'01'                            0171
*          /* IS THIS DATA ITEM IN THE DATALIST ?                    */
*          DO WHILE DATAADR=0;                                     0172
         B     @DE00172                                            0172
@DL00172 DS    0H                                                  0173
*            MARKER1=MARKER1+12;        /* STEP 'MARKER1' TO NEXT PDE*/
         LA    @04,12                                              0173
         SLR   @15,@15                                             0173
         ICM   @15,7,MARKER1(MARKMARK)                             0173
         AR    @04,@15                                             0173
         STCM  @04,7,MARKER1(MARKMARK)                             0173
*            SCANTYPE=SCANTYPE+1;       /* INCREMENT SCAN TYPE INDEX */
         LA    @04,1                                               0174
         SLR   @15,@15                                             0174
         IC    @15,SCANTYPE(,LSCANPTR)                             0174
         AR    @04,@15                                             0174
         STC   @04,SCANTYPE(,LSCANPTR)                             0174
*          END;                                                    0175
@DE00172 SLR   @04,@04                                             0175
         ICM   @04,7,MARKER1(MARKMARK)                             0175
         L     @04,DATAADR(,@04)                                   0175
         LTR   @04,@04                                             0175
         BZ    @DL00172                                            0175
*          /* IS THIS DATALIST ITEM AN '*' ?                         */
*          /* MAKE CERTAIN THIS LEVEL IN THIS USER IS UNSUPPORTED    */
*          DO WHILE DATAITEM(1:2)='* ';                            0176
         B     @DE00176                                            0176
@DL00176 DS    0H                                                  0177
*            IF FOUNDNDE->UADSNDAT^=0                              0177
*              THEN                 /* INFORMATION PTR EXISTS        */
         SLR   @04,@04                                             0177
         ICM   @04,7,FOUNDNDE(FINDPTR)                             0177
         L     @04,UADSNDAT(,@04)                                  0177
         LTR   @04,@04                                             0177
         BZ    @RF00177                                            0177
*                DO;                                               0178
*ASTKERR:        /****************************************************/
*                /* ACTION TAKEN HERE TO RELEASE THE READ ROUTINE'S  */
*                /* BUFFER AND PUT OUT A MESSAGE INDICATING THAT     */
*                /* THE '*' IN THE DATA SUBFLD IS INCOMPATIBLE       */
*                /* WITH THE CURRENT USERID.                         */
*                /****************************************************/
*                CALL WRITE;            /* SCRATCH READ ROUTINE STG  */
ASTKERR  BAL   @14,WRITE                                           0179
*                /* SET PARAMETERS FOR PUTLINE MESSAGE               */
*                OUT1LINK=0;            /* INDICATE NO 2ND LEVEL MSG */
         SLR   @09,@09                                             0180
         ST    @09,OUT1LINK                                        0180
*                OUT1SCNT='03'X;        /* 1ST LEVEL MSG SEG COUNT =3*/
         MVI   OUT1SCNT,X'03'                                      0181
*                OUT1SEG1=ADDMSG(29);   /* PTR TO 'LEVEL REQUIRED'   */
         L     @09,ADDMSG+112(,MSGBASE)                            0182
         ST    @09,OUT1SEG1                                        0182
*                USRIDOF=35;            /* OFFSET FOR USERID INSERTN */
         MVC   USRIDOF(2),@CH00334                                 0183
*                OUT1SEG2=ADDR(USRIDSEG);/* 2ND SEGMT = USERID       */
         LA    @09,USRIDSEG                                        0184
         ST    @09,OUT1SEG2                                        0184
*                /* WHICH LEVEL IS SUPPORTED AND NOT SPECIFIED?      */
*                IF SCANTYPE=1                                     0185
*                  THEN                 /* PASSWORD LEVEL SUPPORTED  */
         CLI   SCANTYPE(LSCANPTR),1                                0185
         BNE   @RF00185                                            0185
*                    OUT1SEG3=ADDMSG(30); /* 3RD SEG='PASSWORDS      */
         L     @09,ADDMSG+116(,MSGBASE)                            0186
         ST    @09,OUT1SEG3                                        0186
*                  ELSE                 /* MUST BE ACCOUNT NUMBERS   */
*                    OUT1SEG3=ADDMSG(31);/* 3RD SEG='ACCTNMBRS'      */
         B     @RC00185                                            0187
@RF00185 L     @09,ADDMSG+120(,MSGBASE)                            0187
         ST    @09,OUT1SEG3                                        0187
*                GOTO INFOMSG;          /* GO PUT OUT MESSAGE & LEAVE*/
         B     INFOMSG                                             0188
*                END;                                              0189
*              ELSE                     /* LEVEL IS NOT SUPPORTED    */
*                DO;                                               0190
@RF00177 DS    0H                                                  0191
*                MARKER1=MARKER1+12;    /* BUMP 'MARKER1' TO NEXT PDE*/
         LA    @04,12                                              0191
         SLR   @15,@15                                             0191
         ICM   @15,7,MARKER1(MARKMARK)                             0191
         AR    @04,@15                                             0191
         STCM  @04,7,MARKER1(MARKMARK)                             0191
*                SCANTYPE=SCANTYPE+1;   /* INCREMENT SCAN TYPE INDEX */
         LA    @04,1                                               0192
         SLR   @15,@15                                             0192
         IC    @15,SCANTYPE(,LSCANPTR)                             0192
         AR    @04,@15                                             0192
         STC   @04,SCANTYPE(,LSCANPTR)                             0192
*                FOUNDNDE=FOUNDNDE ->   /* MOVE STARTING POINT DOWN  */
*                  UADSNSUB+HEDBPTR;    /* ONE LEVEL                 */
         SLR   @04,@04                                             0193
         ICM   @04,7,FOUNDNDE(FINDPTR)                             0193
         LR    @15,HEDBPTR                                         0193
         A     @15,UADSNSUB(,@04)                                  0193
         STCM  @15,7,FOUNDNDE(FINDPTR)                             0193
*                END;                                              0194
*            END;                                                  0195
@DE00176 SLR   @04,@04                                             0195
         ICM   @04,7,MARKER1(MARKMARK)                             0195
         L     @04,DATAADR(,@04)                                   0195
         CLC   DATAITEM(2,@04),@CC00312                            0195
         BE    @DL00176                                            0195
*DUPLSCAN:       /* CTL. PASSED OR DROPPED HERE TO MAKE CERTAIN THE  */
*                /* DATALIST ITEM IS NOT DUPLICATED IN THE UADS USER */
*                /* INDEX STRUCTURE                                  */
*                SCANPDE=MARKER1;       /* POINT TO SEARCH ARG. PDE  */
DUPLSCAN MVC   SCANPDE(3,LSCANPTR),MARKER1(MARKMARK)               0196
*                SCANFLGS='00'X;        /* REQUEST LOCAL LAT'L SCAN  */
         MVI   SCANFLGS(LSCANPTR),X'00'                            0197
*                SCANBEGN=FOUNDNDE;     /* ADDR OF 1ST NODE IN CHAIN
*                                          TO BE SCANNED             */
         MVC   SCANBEGN(3,LSCANPTR),FOUNDNDE(FINDPTR)              0198
*                CALL IKJLSCAN;         /* CALL 'LATSCAN' SUBROUTINE */
         BAL   @14,IKJLSCAN                                        0199
*                /* CHECK RETURN CODE - WAS THIS DATALIST ITEM       */
*                /* ALREADY IN THE UADS UNDER THE SUBJECT NODE LEVEL */
*                IF SCANRTCD^=4                                    0200
*                  THEN                 /* DUPLICATE OR NON-SUPPORT  */
         CH    SCANRTCD,@CH00108                                   0200
         BNE   @RT00200                                            0200
*                    GOTO SCANERR;                                 0201
*          MARKER2=SCANANSR;            /* SAVE NODE ADDR RETURNED 0202
*                                          BY 'LATSCAN' SUBROUTINE   */
         L     @04,SCANANSR(,LSCANPTR)                             0202
         ST    @04,MARKER2(,MARKMARK)                              0202
*ADDNODE:  /* CTL. PASSED OR DROPPED HERE TO BUILD A NEW NODE        */
*          SPACLNTH=LENGTH(UADSNODE);   /* REQUEST SPACE FOR A NODE  */
ADDNODE  MVC   SPACLNTH(2),@CH00055                                0203
*          CALL GETSPACE;               /* GET SPACE IN MEMBER BLOCK */
         BAL   @14,GETSPACE                                        0204
*          MARKER3=SPACOFST;            /* SAVE 'OFFSET' TO        0205
*                                          SPACE FOR NEW NODE        */
         L     @04,SPACOFST                                        0205
         ST    @04,MARKER3(,MARKMARK)                              0205
*          UADSNPTR=MARKER3+HEDBPTR;    /* LOAD NODE BLOCK BASE PTR  */
         AR    @04,HEDBPTR                                         0206
         LR    UADSNPTR,@04                                        0206
*          /* IS THIS DATA ITEM AN '*'                               */
*          IF DATAITEM(1:2)='* '                                   0207
*            THEN                       /* YES - DATA ITEM IS AN '*' */
         SLR   @04,@04                                             0207
         ICM   @04,7,MARKER1(MARKMARK)                             0207
         L     @04,DATAADR(,@04)                                   0207
         CLC   DATAITEM(2,@04),@CC00312                            0207
         BNE   @RF00207                                            0207
*              /* SEE IF THIS NODE LEVEL FOR THIS USER IS UNSUPPORTED*/
*              IF MARKER2->UADSNDAT^=0                             0208
*                THEN                   /* INFORMATION PTR EXISTS    */
         L     @04,MARKER2(,MARKMARK)                              0208
         L     @04,UADSNDAT(,@04)                                  0208
         LTR   @04,@04                                             0208
         BNZ   @RT00208                                            0208
*                  GO TO ASTKERR;       /* GO SET 'INCOMPATIBLE' MSG */
*                ELSE                   /* 0 INFO PTR MATCHES '*'    */
*                  GO TO LATLINK;       /* GO TO BYPASS INFO. SCAN   */
         B     LATLINK                                             0210
*          SCANPDE=MARKER1;             /* PREPARE 'LATSCAN' PARMLIST*/
@RF00207 MVC   SCANPDE(3,LSCANPTR),MARKER1(MARKMARK)               0211
*          SCANFLGS='80'X;              /* REQUEST TOTAL LAT'L SCAN  */
         MVI   SCANFLGS(LSCANPTR),X'80'                            0212
*          SCANBEGN=UADSPWD1+HEDBPTR;   /* START SCAN PARAMETER AT 0213
*                                          PASSWORD LEVEL            */
         LR    @04,HEDBPTR                                         0213
         A     @04,UADSPWD1(,HEDBPTR)                              0213
         STCM  @04,7,SCANBEGN(LSCANPTR)                            0213
*          /* CYCLE DOWN TO LEVEL INDICATED BY 'SCANTYPE'            */
*          DO LOOPCNT=SCANTYPE-1 TO 1 BY -1; /* OPTIMUM CTLS         */
         SLR   LOOPCNT,LOOPCNT                                     0214
         IC    LOOPCNT,SCANTYPE(,LSCANPTR)                         0214
         BCTR  LOOPCNT,0                                           0214
         B     @DE00214                                            0214
@DL00214 DS    0H                                                  0215
*            SCANBEGN=SCANBEGN->UADSNSUB+HEDBPTR; /* STEP DOWN SCAN
*                                                    STARTING POINT  */
         SLR   @04,@04                                             0215
         ICM   @04,7,SCANBEGN(LSCANPTR)                            0215
         LR    @15,HEDBPTR                                         0215
         A     @15,UADSNSUB(,@04)                                  0215
         STCM  @15,7,SCANBEGN(LSCANPTR)                            0215
*          END;                         /* SCANBEGN WILL POINT TO THE
*                                          'LEFTMOST' NODE ON SCANTYPE
*                                          LEVEL WHEN LOOP IS DONE   */
         BCTR  LOOPCNT,0                                           0216
@DE00214 LTR   LOOPCNT,LOOPCNT                                     0216
         BP    @DL00214                                            0216
*          /* CTL. RETURNED HERE TO RECALL 'LATSCAN' IF PROCNAME     */
*          /* SUBFIELDS DO NOT MATCH                                 */
*          CALL IKJLSCAN;               /* INVOKE 'LATSCAN'          */
         BAL   @14,IKJLSCAN                                        0217
*          /* CHECK RETURN CODE                                      */
*          IF SCANRTCD=4                                           0218
*            THEN                       /* NO DUPLICATE INFO FOUND   */
         CH    SCANRTCD,@CH00108                                   0218
         BE    @RT00218                                            0218
*              GO TO ADDINFO;           /* GO TO BUILD AN INFO FIELD */
*          /* EXAMINE RETURN CODE FURTHER                            */
*          IF SCANRTCD^=0                                          0220
*            THEN                       /* LEVEL NOT SUPPORTED       */
         LTR   SCANRTCD,SCANRTCD                                   0220
         BNZ   @RT00220                                            0220
*              GO TO SCANERR;           /* GO SET 'INCOMPATIBLE' MSG */
*          /* IS THIS A PROCEDURE NAME DATA ITEM                     */
*          IF SCANTYPE^=3                                          0222
*            THEN                       /* NO - NOT A PROCEDURE NAME */
         CLI   SCANTYPE(LSCANPTR),3                                0222
         BE    @RF00222                                            0222
*              DO;                      /* UTILIZE EXISTING INFO BLOCK
*                                          FOR THIS DATA ITEM        */
*              UADSNDAT=SCANANSR->UADSNDAT;/* OFFSET TO INFO FIELD INTO
*                                             NEW NODE'S OFFSET FIELD*/
         L     @04,SCANANSR(,LSCANPTR)                             0224
         L     @04,UADSNDAT(,@04)                                  0224
         ST    @04,UADSNDAT(,UADSNPTR)                             0224
*              GO TO COUNTUSE;          /* GO COUNT THIS USE         */
         B     COUNTUSE                                            0225
*              END;                                                0226
*          /* AT THIS POINT THE ITEM IS IDENTIFIED AS A PROCEDURE    */
*          /* MUST CHECK TWO OTHER FIELDS BEFORE CONFIRMING DUPLICATE*/
*          DO WHILE SCANRTCD=0;         /* LOOP FOR ALL = PROCEDURES */
@RF00222 B     @DE00227                                            0227
@DL00227 DS    0H                                                  0228
*            UADSRPTR=SCANANSR->                                   0228
*               UADSNDAT+HEDBPTR;       /* POINT TO PROC DATA FIELD  */
         L     @04,SCANANSR(,LSCANPTR)                             0228
         L     @04,UADSNDAT(,@04)                                  0228
         LR    UADSRPTR,HEDBPTR                                    0228
         AR    UADSRPTR,@04                                        0228
*            /* COMPARE INPUT DATA TO EXISTING DATA                  */
*            IF UNITN=UADSUNAM          /* ARE UNIT NAMES            */
*              & PSIZE=UADSRSIZ         /*  AND SIZE VALUES EQUAL?   */
*              THEN                     /* YES,                      */
         CLC   UNITN(8,COMMPTR),UADSUNAM(UADSRPTR)                 0229
         BNE   @RF00229                                            0229
         CLC   PSIZE(2),UADSRSIZ(UADSRPTR)                         0229
         BNE   @RF00229                                            0229
*                DO;                    /* UTILIZE EXISTING INFO BLOCK
*                                          FOR THIS DATA ITEM        */
*                UADSNDAT=SCANANSR->    /* OFFSET TO INFO FIELD INTO */
*                 UADSNDAT;             /*    NEW NODE'S OFFSET FIELD*/
         ST    @04,UADSNDAT(,UADSNPTR)                             0231
*                GO TO COUNTUSE;        /* GO COUNT THIS USE         */
         B     COUNTUSE                                            0232
*                END;                                              0233
*            SCANBEGN=SCANANSR->        /* POINT TO NEXT NODE        */
*               UADSNNEX+HEDBPTR;                                  0234
@RF00229 L     @04,SCANANSR(,LSCANPTR)                             0234
         SLR   @02,@02                                             0234
         ICM   @02,7,UADSNNEX(@04)                                 0234
         LR    @04,HEDBPTR                                         0234
         AR    @04,@02                                             0234
         STCM  @04,7,SCANBEGN(LSCANPTR)                            0234
*            IF SCANANSR->UADSNNEX=0    /* IS THERE ANOTHER OFFSET?  */
*              THEN                     /* NO,                       */
         LTR   @02,@02                                             0235
         BZ    @RT00235                                            0235
*                GO TO ADDINFO;         /* GO TO BUILD AN INFO FIELD */
*            /* RECALL THE LATERAL SCAN SUBROUTINE TO CONTINUE     0237
*               DUPLICATE SEARCH WITH NEXT NODE                      */
*            CALL IKJLSCAN;             /* INVOKE 'LATSCAN'          */
         BAL   @14,IKJLSCAN                                        0237
*          END;                                                    0238
@DE00227 LTR   SCANRTCD,SCANRTCD                                   0238
         BZ    @DL00227                                            0238
*ADDINFO:  /* CTL. PASSED HERE TO BUILD AN INFORMATION BLOCK         */
*          SPACLNTH=DTABLNTH(SCANTYPE); /* BLOCK LENGTH FROM       0239
*                                          DATA ATTRIBUTE TABLE      */
ADDINFO  SLR   @04,@04                                             0239
         IC    @04,SCANTYPE(,LSCANPTR)                             0239
         SLA   @04,2                                               0239
         LA    @02,DTATBL                                          0239
         LA    @01,0(@04,@02)                                      0239
         AL    @01,@CF00418                                        0239
         SLR   @00,@00                                             0239
         IC    @00,DTABLNTH-1(,@01)                                0239
         STH   @00,SPACLNTH                                        0239
*          /* IS THERE A VARIABLE LENGTH INCREMENT TO BE ADDED       */
*          IF DTAFLGS(SCANTYPE,1)='1'B                             0240
*            THEN                       /* VARIABLE-LENGTH INFO. FLD */
         ALR   @02,@04                                             0240
         AL    @02,@CF00419                                        0240
         TM    DTAFLGS(@02),B'10000000'                            0240
         BNO   @RF00240                                            0240
*              SPACLNTH=SPACLNTH+DATALNTH; /* INCREMENT BY LENGTH  0241
*                                             FROM PDE               */
         SLR   @04,@04                                             0241
         ICM   @04,7,MARKER1(MARKMARK)                             0241
         AH    @00,DATALNTH(,@04)                                  0241
         STH   @00,SPACLNTH                                        0241
*          CALL GETSPACE;               /* GET SPACE IN MEMBER BLOCK */
@RF00240 BAL   @14,GETSPACE                                        0242
*          UADSNDAT=SPACOFST;           /* OFFSET TO DATA FIELD    0243
*                                          TO NODE SLOT              */
         L     @04,SPACOFST                                        0243
         ST    @04,UADSNDAT(,UADSNPTR)                             0243
*          DATAPTR=UADSNDAT+HEDBPTR+DTAOFFST(SCANTYPE); /* POINT TO
*                                                          INFO FIELD*/
         AR    @04,HEDBPTR                                         0244
         SLR   @15,@15                                             0244
         IC    @15,SCANTYPE(,LSCANPTR)                             0244
         SLA   @15,2                                               0244
         LA    @14,DTATBL                                          0244
         LA    @01,0(@15,@14)                                      0244
         AL    @01,@CF00420                                        0244
         SLR   DATAPTR,DATAPTR                                     0244
         IC    DATAPTR,DTAOFFST-2(,@01)                            0244
         AR    @04,DATAPTR                                         0244
         LR    DATAPTR,@04                                         0244
*          /* CHECK AGAIN FOR VARIABLE LENGTH BLOCK TYPE             */
*          IF DTAFLGS(SCANTYPE,1)='1'B                             0245
*            THEN                       /* VARIABLE LENGTH INFO FIELD*/
         ALR   @14,@15                                             0245
         AL    @14,@CF00419                                        0245
         TM    DTAFLGS(@14),B'10000000'                            0245
         BNO   @RF00245                                            0245
*              DO;                                                 0246
*                VLNTHLNG=DATALNTH;     /* VARIABLE LENGTH INDICATOR
*                                          FROM LENGTH FIELD IN PDE  */
         SLR   @04,@04                                             0247
         ICM   @04,7,MARKER1(MARKMARK)                             0247
         LH    @15,DATALNTH(,@04)                                  0247
         STC   @15,VLNTHLNG(,DATAPTR)                              0247
*                DATAPTR=DATAPTR+1;     /* BUMP PTR PAST V-LNTH BYTE */
         AH    DATAPTR,@CH00032                                    0248
*                DATAPTR->DATAITEM(1:DATALNTH)=DATAITEM; /* MOVE DATA*/
         BCTR  @15,0                                               0249
         L     @04,DATAADR(,@04)                                   0249
         EX    @15,@SM00421                                        0249
*              END;                                                0250
*            ELSE                       /* DATA LNGTH IS EIGHT CHARS */
*              DATAPTR->DATAITEM=                                  0251
*                 DATAITEM(1:DATALNTH); /* GET DATA FROM PDE LIST    */
         B     @RC00245                                            0251
@RF00245 MVI   DATAITEM+1(DATAPTR),C' '                            0251
         MVC   DATAITEM+2(6,DATAPTR),DATAITEM+1(DATAPTR)           0251
         SLR   @04,@04                                             0251
         ICM   @04,7,MARKER1(MARKMARK)                             0251
         LH    @15,DATALNTH(,@04)                                  0251
         BCTR  @15,0                                               0251
         L     @04,DATAADR(,@04)                                   0251
         EX    @15,@SM00421                                        0251
*          /* NOW, SEE IF SIZE AND UNIT PARAMETERS NEED TO BE STORED */
*          IF SCANTYPE=3                                           0252
*            THEN                       /* YES THIS IS PROCNAME LEVEL*/
@RC00245 CLI   SCANTYPE(LSCANPTR),3                                0252
         BNE   @RF00252                                            0252
*              DO;                                                 0253
*              UADSRPTR=UADSNDAT+                                  0254
*                  HEDBPTR;             /* PROCEDURE INFO FIELD BASE */
         LR    UADSRPTR,HEDBPTR                                    0254
         A     UADSRPTR,UADSNDAT(,UADSNPTR)                        0254
*              UADSRSIZ=PSIZE;          /* SIZE VALUE SET UP IN    0255
*                                          IKJEFA55                  */
         SLR   @04,@04                                             0255
         ICM   @04,3,PSIZE                                         0255
         STH   @04,UADSRSIZ(,UADSRPTR)                             0255
*              UADSUNAM=UNITN;          /* UNITNAME TO INFO FLD      */
         MVC   UADSUNAM(8,UADSRPTR),UNITN(COMMPTR)                 0256
*              END;                                                0257
*COUNTUSE: /* CTL. PASSED OR DROPPED HERE TO INCREMENT INFO USE COUNT*/
*          COUNTPTR=UADSNDAT+HEDBPTR;   /* BASE OF INFO FIELD        */
@RF00252 DS    0H                                                  0258
COUNTUSE LR    COUNTPTR,HEDBPTR                                    0258
         A     COUNTPTR,UADSNDAT(,UADSNPTR)                        0258
*          /* MAKE CERTAIN THAT USE COUNT WILL NOT OVERFLOW          */
*          IF USECOUNT>=255                                        0259
*            THEN                       /* COUNTER FILLED TO CAPACITY*/
         CLI   USECOUNT(COUNTPTR),255                              0259
         BL    @RF00259                                            0259
*              DO;                                                 0260
*                /****************************************************/
*                /* RELEASE READ ROUTINE BUFFER AND PUT OUT A MESSAGE*/
*                /* INDICATING THAT USE COUNTER IS EXHAUSTED         */
*                /****************************************************/
*                CALL WRITE;            /* SCRATCH READ ROUTINE STG  */
         BAL   @14,WRITE                                           0261
*                /* SET PARAMETERS FOR PUTLINE MESSAGE               */
*                OUT1SCNT='02'X;        /* 1ST LEVEL MSG SEG COUNT =2*/
         MVI   OUT1SCNT,X'02'                                      0262
*                OUT1SEG1=ADDMSG(32);   /* ADDR OF 'UNABLE TO ADD'   */
         L     @09,ADDMSG+124(,MSGBASE)                            0263
         ST    @09,OUT1SEG1                                        0263
*                USRIDOF=35;            /* OFFSET FOR USERID INSERTN */
         MVC   USRIDOF(2),@CH00334                                 0264
*                OUT1SEG2=ADDR(USRIDSEG); /* ADDR OF USERID SEGMENT  */
         LA    @09,USRIDSEG                                        0265
         ST    @09,OUT1SEG2                                        0265
*                OUT2SCNT='04'X;        /* 2ND LEVEL MSG SEG COUNT =4*/
         MVI   OUT2SCNT,X'04'                                      0266
*                OUT2SEG1=ADDMSG(39);   /* ADDR OF 'COUNTER EXHAUSTED*/
         L     @09,ADDMSG+152(,MSGBASE)                            0267
         ST    @09,OUT2SEG1                                        0267
*                USERSEG2=USRIDSEG;     /* INITIALIZE ADD'L SEGMENT  */
         MVC   USERSEG2(11),USRIDSEG                               0268
*                USRSG2OF=59;           /* OFFSET FOR 2ND LVL INSERTN*/
         MVC   USRSG2OF(2),@CH00354                                0269
*                INSTOF=10;             /* OFFSET FOR TEXT INSERTION */
         MVC   INSTOF(2),@CH00355                                  0270
*                OUT2SEG3=ADDR(INSTSEG); /* ADDR OF INSERT SEGMENT   */
         LA    @09,INSTSEG                                         0271
         ST    @09,OUT2SEG3                                        0271
*                OUT2SEG4=ADDR(USERSEG2); /* ADDR OF ADD'L USER SEGMT*/
         LA    @09,USERSEG2                                        0272
         ST    @09,OUT2SEG4                                        0272
*                /* IS THIS THE ACCOUNT NUMBER LEVEL ?               */
*                IF SCANTYPE=2                                     0273
*                  THEN                 /* ACCOUNT NUMBER LEVEL      */
         CLI   SCANTYPE(LSCANPTR),2                                0273
         BNE   @RF00273                                            0273
*                    DO;                                           0274
*                      OUT2SEG2=ADDMSG(22); /* 'ACCOUNT NUMBER' PREFX*/
         L     @09,ADDMSG+84(,MSGBASE)                             0275
         ST    @09,OUT2SEG2                                        0275
*                      INSTLN=DATALNTH+4; /* LENGTH OF ACCT NMBR SEGM*/
         SLR   @10,@10                                             0276
         ICM   @10,7,MARKER1(MARKMARK)                             0276
         LH    @09,DATALNTH(,@10)                                  0276
         LA    @04,4                                               0276
         AR    @04,@09                                             0276
         STH   @04,INSTLN                                          0276
*                      INSTTX(1:DATALNTH)=                         0277
*                        DATAITEM;      /* ACCT NMBR VIA PARSE PDE   */
         BCTR  @09,0                                               0277
         L     @10,DATAADR(,@10)                                   0277
         EX    @09,@SM00423                                        0277
*                    END;                                          0278
*                  ELSE                 /* MUST BE PROCNAME LEVEL    */
*                    DO;                                           0279
         B     @RC00273                                            0279
@RF00273 DS    0H                                                  0280
*                      OUT2SEG2=ADDMSG(23); /* PTR TO 'PROCNAME' PRFX*/
         L     @09,ADDMSG+88(,MSGBASE)                             0280
         ST    @09,OUT2SEG2                                        0280
*                      INSTLN=DATALNTH+4; /* LENGTH OF PROCNAME SEGMT*/
         SLR   @10,@10                                             0281
         ICM   @10,7,MARKER1(MARKMARK)                             0281
         LH    @09,DATALNTH(,@10)                                  0281
         LA    @04,4                                               0281
         AR    @04,@09                                             0281
         STH   @04,INSTLN                                          0281
*                      INSTTX(1:DATALNTH)=                         0282
*                        DATAITEM;      /* PROC NAME VIA PARSE PDE   */
         BCTR  @09,0                                               0282
         L     @10,DATAADR(,@10)                                   0282
         EX    @09,@SM00423                                        0282
*                    END;                                          0283
*                GOTO INFOMSG;          /* GO PUT OUT MESSAGE & LEAVE*/
         B     INFOMSG                                             0284
*              END;                                                0285
*          USECOUNT=USECOUNT+1;         /* COUNT ONE                 */
@RF00259 LA    @04,1                                               0286
         SLR   @15,@15                                             0286
         IC    @15,USECOUNT(,COUNTPTR)                             0286
         AR    @04,@15                                             0286
         STC   @04,USECOUNT(,COUNTPTR)                             0286
*LATLINK:  /* CTL. PASSED OR DROPPED HERE TO LINK NEW NODE TO TREE   */
*          UADSNWD1=MARKER2->UADSNWD1;  /* COPY LATERAL OFFSET FROM
*                                          'OLD' NODE TO 'NEW' ONE   */
LATLINK  L     @04,MARKER2(,MARKMARK)                              0287
         L     @02,UADSNWD1(,@04)                                  0287
         ST    @02,UADSNWD1(,UADSNPTR)                             0287
*          MARKER2->UADSNWD1=MARKER3;   /* OFFSET TO NEW NODE TO LAT'L
*                                          OFFSET SLOT OF 'OLD' NODE */
         L     @15,MARKER3(,MARKMARK)                              0288
         ST    @15,UADSNWD1(,@04)                                  0288
*          /* IS THE DATA ITEM THE FIRST ONE IN A PDE CHAIN ?        */
*          IF MARKER1=12*(SCANTYPE-1)+DATASUBP /* PDE = 1ST (OR    0289
*                                                       ONLY) FOR THIS
*                                                       OPERAND      */
*               &SETFLAG^='1'B          /* THIS IS NOT THE HIGHEST 0289
*                                          LEVEL BEING ADDED TO ('HIGH'
*                                          BEING 'TOWARDS USERID')   */
*            THEN                       /* VERTICAL OFFSET FLD OF NODE
*                                          ABOVE MUST BE FILLED IN   */
         LA    @14,12                                              0289
         SLR   @01,@01                                             0289
         IC    @01,SCANTYPE(,LSCANPTR)                             0289
         BCTR  @01,0                                               0289
         MR    @00,@14                                             0289
         A     @01,DATASUBP(,COMMPTR)                              0289
         SLR   @00,@00                                             0289
         ICM   @00,7,MARKER1(MARKMARK)                             0289
         CR    @01,@00                                             0289
         BNE   @RF00289                                            0289
         TM    SETFLAG(MARKMARK),B'10000000'                       0289
         BO    @RF00289                                            0289
*              DO;                                                 0290
*                RFY R1 RSTD;           /* RESTRICT R1 FOR WORK REG  */
*                R1=MARKMARK-12;        /* USE R1 AS TEMPORARY BASE  */
         LCR   @14,@14                                             0292
         AR    @14,MARKMARK                                        0292
         LR    R1,@14                                              0292
*                R1=R1->MARKER3+HEDBPTR; /* ESTABLISH BASE FOR HIGHER
*                                           NEW NODE                 */
         LR    @00,HEDBPTR                                         0293
         A     @00,MARKER3(,R1)                                    0293
         LR    R1,@00                                              0293
*                R1->UADSNSUB=MARKER3;  /* OFFSET OF NEW NODE TO   0294
*                                           OFFSET FIELD OF 'FATHER' */
         ST    @15,UADSNSUB(,R1)                                   0294
*                MARKER2->UADSNFLG='1'B; /* MARKER2 LOCATES END OF 0295
*                                           PREVIOUS LATERAL CHAIN   */
         OI    UADSNFLG(@04),B'10000000'                           0295
*              END;                                                0296
*                                       /* CONTINUE - EITHER PDE NOT
*                                          1ST IN CHAIN OR THIS IS THE
*                                          TOP OF THE 'AUGMENT' TREE */
*                                                                  0297
*          /* CTL. PASSED OR DROPPED HERE TO TEST FOR LAST PDE       */
*          IF SCANTYPE=3                                           0297
*            THEN                       /* NO MORE LEVELS            */
@RF00289 CLI   SCANTYPE(LSCANPTR),3                                0297
         BE    @RT00297                                            0297
*              GO TO CHAINTST;          /* GO SEE IF THIS IS LAST  0298
*                                          PDE IN THE CHAIN          */
*          R1=MARKMARK;                 /* SAVE 'MARKMARK' TEMPORARLY*/
         LR    R1,MARKMARK                                         0299
*          MARKMARK=MARKMARK+12;        /* BUMP TO NEXT SET OF MARKRS*/
         LA    @04,12                                              0300
         AR    MARKMARK,@04                                        0300
*          MARKER1=12*SCANTYPE+DATASUBP;/* SET NEW MARKER1 TO      0301
*                                                 NEXT PDE IN PDL    */
         SLR   @15,@15                                             0301
         IC    @15,SCANTYPE(,LSCANPTR)                             0301
         LR    @03,@04                                             0301
         MR    @02,@15                                             0301
         A     @03,DATASUBP(,COMMPTR)                              0301
         STCM  @03,7,MARKER1(MARKMARK)                             0301
*          SCANTYPE=SCANTYPE+1;         /* INCREMENT SCAN TYPE INDEX */
         AH    @15,@CH00032                                        0302
         STC   @15,SCANTYPE(,LSCANPTR)                             0302
*          R1=R1->MARKER2->UADSNSUB+HEDBPTR; /* PICK UP OFFSET TO NEXT
*                                               LOWER LEVEL FROM NODE
*                                               POINTED TO BY OLD  0303
*                                               MARKER2              */
         L     @04,MARKER2(,R1)                                    0303
         LR    @00,HEDBPTR                                         0303
         A     @00,UADSNSUB(,@04)                                  0303
         LR    R1,@00                                              0303
*          /* SEE IF LOWER LEVEL NODE IS LAST IN A LOCAL LAT'L CHAIN */
*          DO WHILE R1->UADSNFLG^='1'B;                            0304
         B     @DE00304                                            0304
@DL00304 DS    0H                                                  0305
*            R1=R1->UADSNNEX+HEDBPTR;   /* MOVE TO NEXT LAT'L        */
         SLR   @04,@04                                             0305
         ICM   @04,7,UADSNNEX(R1)                                  0305
         AR    @04,HEDBPTR                                         0305
         LR    R1,@04                                              0305
*          END;                                                    0306
@DE00304 TM    UADSNFLG(R1),B'10000000'                            0306
         BNO   @DL00304                                            0306
*          MARKER2=R1;                  /* SAVE THIS NODE IN MARKER2 */
         ST    R1,MARKER2(,MARKMARK)                               0307
*          GO TO ADDNODE;               /* LOOP TO ADD NEXT DATA ITEM*/
         B     ADDNODE                                             0308
*          RFY R1 UNRSTD;               /* RELEASE WORK REGISTER     */
*CHAINTST: /**********************************************************/
*          /* SCAN PDE CHAIN TO DETERMINE IF ANY MORE ITEMS HAHE     */
*          /* BEEN SPECIFIED.                                        */
*          /**********************************************************/
*          IF DATACHN^=0                                           0310
*            THEN                       /* PDE NOT LAST IN CHAIN     */
CHAINTST SLR   @04,@04                                             0310
         ICM   @04,7,MARKER1(MARKMARK)                             0310
         ICM   @15,7,DATACHN(@04)                                  0310
         BZ    @RF00310                                            0310
*              DO;                                                 0311
*                MARKER1=DATACHN;       /* BUMP MARKER1 TO NEXT PDE  */
         SLR   @15,@15                                             0312
         ICM   @15,7,DATACHN(@04)                                  0312
         STCM  @15,7,MARKER1(MARKMARK)                             0312
*                /* IS THIS THE HIGHEST LEVEL BEING AUGMENTED        */
*                IF SETFLAG='1'B                                   0313
*                  THEN                 /* YES - USING 1ST MARKER SET*/
         TM    SETFLAG(MARKMARK),B'10000000'                       0313
         BO    @RT00313                                            0313
*                    GO TO DUPLSCAN;    /* GO CHECK FOR A DUPLICATE  */
*                MARKER2=MARKER3+HEDBPTR; /* NEW NODE BECOMES OLD ONE*/
         LR    @04,HEDBPTR                                         0315
         A     @04,MARKER3(,MARKMARK)                              0315
         ST    @04,MARKER2(,MARKMARK)                              0315
*                GO TO ADDNODE;         /* LOOP TO ADD NEXT DATA ITEM*/
         B     ADDNODE                                             0316
*              END;                                                0317
*          /* IS THIS THE HIGHEST LEVEL BEING AUGMENTED              */
*          IF SETFLAG^='1'B                                        0318
*            THEN                       /* NO - NOT HIGHEST LEVEL    */
@RF00310 TM    SETFLAG(MARKMARK),B'10000000'                       0318
         BO    @RF00318                                            0318
*              DO;                                                 0319
*                MARKMARK=MARKMARK-12;  /* RESET 'MARKMARK' TO PREVIOUS
*                                          SET OF MARKERS            */
         SH    MARKMARK,@CH00055                                   0320
*                SCANTYPE=SCANTYPE-1;   /* DECREMENT SCAN TYPE INDEX */
         SLR   @04,@04                                             0321
         IC    @04,SCANTYPE(,LSCANPTR)                             0321
         BCTR  @04,0                                               0321
         STC   @04,SCANTYPE(,LSCANPTR)                             0321
*                GO TO CHAINTST;        /* LOOP TO SEE IF CHAIN ABOVE
*                                          IS EXHAUSTED              */
         B     CHAINTST                                            0322
*              END;                                                0323
*          /* MORE NODES IN THE FINDNODE OUTPUT LIST ?               */
*          IF FNOEOLST^='1'B                                       0324
*            THEN                       /* MORE AUGMENTING TO DO     */
@RF00318 TM    FNOEOLST(FINDPTR),B'10000000'                       0324
         BO    @RF00324                                            0324
*              DO;                                                 0325
*                FINDPTR=FINDPTR+4;     /* BUMP LIST INDEX           */
         AH    FINDPTR,@CH00108                                    0326
*                GO TO ADDRBEGN;        /* GO START ALL OVER AGAIN   */
         B     ADDRBEGN                                            0327
*              END;                                                0328
*          /* IS THERE A FINDNODE WORK AREA TO BE FREED ?            */
*          IF FNOUTPTR^=0                                          0329
*            THEN                       /* YES - MUST ISSUE FREEMAIN */
@RF00324 L     @10,FNOUTPTR                                        0329
         LTR   @10,@10                                             0329
         BZ    @RF00329                                            0329
*              DO;                                                 0330
*              /* ISSUE FREEMAIN                                     */
*              GEN (FREEMAIN V,A=FNOUTPTR,MF=(E,DYNFRLST))         0331
*                REFS(FNOUTPTR,DYNFRLST);                          0331
         FREEMAIN V,A=FNOUTPTR,MF=(E,DYNFRLST)
*              FNOUTPTR=0;              /* INDICATE CORE FREED       */
         SLR   @10,@10                                             0332
         ST    @10,FNOUTPTR                                        0332
*              END;                                                0333
*          RETURN;                      /* RETURN TO IKJEFA12        */
@EL00001 L     @13,4(,@13)                                         0334
@EF00001 L     @00,@SIZDATD                                        0334
         LR    @01,@11                                             0334
         FREEMAIN R,LV=(0),A=(1)
@ER00001 LM    @14,@12,12(@13)                                     0334
         BR    @14                                                 0334
*/* END OF IKJEFA13 - RETURN TO IKJEFA12 TO WRITE NEW USER.          */
*SCANERR:  /**********************************************************/
*          /* BEGIN CLEAN UP BY RELEASING READ ROUTINE'S BUFFER      */
*          /* STORAGE AND SETTING LINKAGE TO 'ADDERCLN' AFTER        */
*          /* MESSAGE.                                               */
*          /**********************************************************/
*          CALL WRITE;                  /* SCRATCH READ ROUTINE STG  */
SCANERR  BAL   @14,WRITE                                           0335
*          OUT1LINK=0;                  /* INDICATE NO 2ND LEVEL MSG */
         SLR   @09,@09                                             0336
         ST    @09,OUT1LINK                                        0336
*          /* ANALYZE SCAN ROUTINE RETURN CODE TO SET PARAMETER      */
*          /* FOR THE APPROPRIATE MESSAGE                            */
*          IF SCANRTCD=0                                           0337
*            THEN                       /* DUPLICATE ITEM IN THE UADS*/
         CR    SCANRTCD,@09                                        0337
         BE    @RT00337                                            0337
*              GO TO DUPLMSG;           /* GO SET UP FOR 'DUPLICATE' */
*          OUT1SCNT='03'X;              /* 1ST LEVEL MSG SEG COUNT =3*/
         MVI   OUT1SCNT,X'03'                                      0339
*          OUT1SEG1=ADDMSG(28);         /* PTR TO 'LEVEL UNSUPPORTED'*/
         L     @09,ADDMSG+108(,MSGBASE)                            0340
         ST    @09,OUT1SEG1                                        0340
*          USRIDOF=35;                  /* OFFSET FOR USERID INSERTN */
         MVC   USRIDOF(2),@CH00334                                 0341
*          OUT1SEG2=ADDR(USRIDSEG);     /* 2ND SEGMT = USERID        */
         LA    @09,USRIDSEG                                        0342
         ST    @09,OUT1SEG2                                        0342
*          /* WHICH LEVEL IS UNSUPPORTED ?                           */
*          IF SCANTYPE=1                                           0343
*            THEN                       /* PASSWORDS UNSUPPORTED     */
         CLI   SCANTYPE(LSCANPTR),1                                0343
         BNE   @RF00343                                            0343
*              OUT1SEG3=ADDMSG(30);     /* 3RD SEGMT = 'PASSWORDS'   */
         L     @09,ADDMSG+116(,MSGBASE)                            0344
         ST    @09,OUT1SEG3                                        0344
*            ELSE                       /* ACCOUNT IS UNSUPPORTED    */
*              OUT1SEG3=ADDMSG(31);     /* 3RD SEGMT = 'ACCT NMBRS'  */
         B     @RC00343                                            0345
@RF00343 L     @09,ADDMSG+120(,MSGBASE)                            0345
         ST    @09,OUT1SEG3                                        0345
*          GOTO INFOMSG;                /* GO PUT OUT MESSAGE & LEAVE*/
         B     INFOMSG                                             0346
*DUPLMSG:  /* CTL. PASSED HERE TO SET 'DUPLICATE ITEM' MESSAGE       */
*          OUT1SCNT='05'X;              /* 1ST LEVEL MSG SEG COUNT =5*/
DUPLMSG  MVI   OUT1SCNT,X'05'                                      0347
*          OUT1SEG1=ADDMSG(19);         /* PTR TO 'ALREADY EXISTS'   */
         L     @09,ADDMSG+72(,MSGBASE)                             0348
         ST    @09,OUT1SEG1                                        0348
*          OUT1SEG3=ADDR(INSTSEG);      /* POINT TO INSERT SEGMENT   */
         LA    @09,INSTSEG                                         0349
         ST    @09,OUT1SEG3                                        0349
*          INSTLN=DATALNTH+4;           /* LENGTH OF INSERT SEGMENT  */
         SLR   @09,@09                                             0350
         ICM   @09,7,MARKER1(MARKMARK)                             0350
         LH    @07,DATALNTH(,@09)                                  0350
         LA    @04,4                                               0350
         AR    @04,@07                                             0350
         STH   @04,INSTLN                                          0350
*          INSTOF=10;                   /* OFFSET FOR TEXT INSERTION */
         MVC   INSTOF(2),@CH00355                                  0351
*          INSTTX(1:DATALNTH)=          /* DATA ITEM VIA PARSE PDE   */
*            DATAITEM;                                             0352
         BCTR  @07,0                                               0352
         L     @09,DATAADR(,@09)                                   0352
         EX    @07,@SM00425                                        0352
*          OUT1SEG4=ADDMSG(38);         /* ADDR OF 'UNDER USERID' SEG*/
         L     @09,ADDMSG+148(,MSGBASE)                            0353
         ST    @09,OUT1SEG4                                        0353
*          USRIDOF=25;                  /* OFFSET FOR USERID INSERTN */
         MVC   USRIDOF(2),@CH00368                                 0354
*          OUT1SEG5=ADDR(USRIDSEG);     /* ADDR OF USERID SEGMENT    */
         LA    @09,USRIDSEG                                        0355
         ST    @09,OUT1SEG5                                        0355
*          /* IS IT A PASSWORD DUPLICATE ?                           */
*          IF SCANTYPE=1                                           0356
*            THEN                       /* PASSWORD DUPLICATED       */
         CLI   SCANTYPE(LSCANPTR),1                                0356
         BNE   @RF00356                                            0356
*              OUT1SEG2=ADDMSG(21);     /* PTR TO 'PASSWORD' PREFIX  */
         L     @09,ADDMSG+80(,MSGBASE)                             0357
         ST    @09,OUT1SEG2                                        0357
*          /* IS IT AN ACCOUNT NUMBER DUPLICATE ?                    */
*          IF SCANTYPE=2                                           0358
*            THEN                       /* ACCOUNT NUMBER DUPLICATED */
@RF00356 CLI   SCANTYPE(LSCANPTR),2                                0358
         BNE   @RF00358                                            0358
*              OUT1SEG2=ADDMSG(22);     /* 'ACCOUNT NUMBER' PREFIX   */
         L     @09,ADDMSG+84(,MSGBASE)                             0359
         ST    @09,OUT1SEG2                                        0359
*          IF SCANTYPE=3                                           0360
*            THEN                       /* MUST BE A PROCNAME DUPLICT*/
@RF00358 CLI   SCANTYPE(LSCANPTR),3                                0360
         BNE   @RF00360                                            0360
*              OUT1SEG2=ADDMSG(23);     /* PTR TO 'PROCNAME' PREFIX  */
         L     @09,ADDMSG+88(,MSGBASE)                             0361
         ST    @09,OUT1SEG2                                        0361
*          /* FALL THRU TO ISSUE ERROR MESSAGE                       */
*INFOMSG:  /**********************************************************/
*          /* INFOMSG: CONTROL PASSED HERE TO OUTPUT AN ERROR        */
*          /* MESSAGE AND RETURN TO IKJEFA12(ADDERCLN).              */
*          /**********************************************************/
*          RFY R1 RSTD;                 /* RESTRICT PARAMETER POINTER*/
@RF00360 DS    0H                                                  0362
INFOMSG  DS    0H                                                  0363
*          R1=IOPLPTR;                  /* PARAMETER LIST ADDR TO R1 */
         L     @10,IOPLPTR(,COMMPTR)                               0363
         LR    R1,@10                                              0363
*          PTPBOPUT=ADDR(OUTLNDS);      /* POINT TO LINE DESCRIPTOR  */
         L     @10,PTPBPTR(,@10)                                   0364
         LA    @09,OUTLNDS                                         0364
         ST    @09,PTPBOPUT(,@10)                                  0364
*          /* ISSUE OS/360 PUTLINE MACRO TO WRITE THE MESSAGE        */
*          GEN (PUTLINE ,MF=(E,(1)))                               0365
*            REFS(R1);                                             0365
         PUTLINE ,MF=(E,(1))
*          RFY R1 UNRSTD;               /* RELEASE PARAMETER POINTER */
*          RFY R15 RSTD;                /* RESTRICT RETURN CODE REG  */
*          RETNCODE=R15;                /* SAVE RETURN CODE          */
         LR    RETNCODE,R15                                        0368
*          RFY R15 UNRSTD;              /* RELEASE RETURN CODE REG   */
*          IF RETNCODE^=0               /* WAS PUTLINE SUCCESSFUL    */
*            THEN                       /* NO,                       */
         LTR   RETNCODE,RETNCODE                                   0370
         BZ    @RF00370                                            0370
*              PUTERR='1'B;             /* TURN ON PUTLINE ERROR FLAG*/
         OI    PUTERR(COMMPTR),B'00100000'                         0371
*ERREXIT:  /* IS THERE A FINDNODE WORK AREA TO BE FREED ?            */
*          IF FNOUTPTR^=0                                          0372
*            THEN                       /* YES - MUST ISSUE FREEMAIN */
@RF00370 DS    0H                                                  0372
ERREXIT  L     @10,FNOUTPTR                                        0372
         LTR   @10,@10                                             0372
         BZ    @RF00372                                            0372
*              /* ISSUE FREEMAIN                                     */
*              GEN (FREEMAIN V,A=FNOUTPTR,MF=(E,DYNFRLST))         0373
*                REFS(FNOUTPTR,DYNFRLST);                          0373
         FREEMAIN V,A=FNOUTPTR,MF=(E,DYNFRLST)
*          RETURN TO ADDERCLN;                                     0374
@RF00372 L     @13,4(,@13)                                         0374
         L     @00,@SIZDATD                                        0374
         LR    @01,@11                                             0374
         FREEMAIN R,LV=(0),A=(1)
         L     @14,@CV00115                                        0374
         LM    @15,@12,16(@13)                                     0374
         BR    @14                                                 0374
*NOSPACE:  /**********************************************************/
*          /* NOSPACE: CONTROL PASSED HERE TO CALL WRITE AND RETURN  */
*          /* TO IKJEFA12.                                           */
*          /**********************************************************/
*          CALL WRITE;                  /* FREE READ ROUTINE STORAGE */
NOSPACE  BAL   @14,WRITE                                           0375
*          /* IS THERE A FINDNODE WORK AREA TO BE FREED ?            */
*          IF FNOUTPTR^=0                                          0376
*            THEN                       /* YES - MUST ISSUE FREEMAIN */
         L     @10,FNOUTPTR                                        0376
         LTR   @10,@10                                             0376
         BZ    @RF00376                                            0376
*              /* ISSUE FREEMAIN                                     */
*              GEN (FREEMAIN V,A=FNOUTPTR,MF=(E,DYNFRLST))         0377
*                REFS(FNOUTPTR,DYNFRLST);                          0377
         FREEMAIN V,A=FNOUTPTR,MF=(E,DYNFRLST)
*          RETURN TO RDGETERR;          /* TREAT AS A READ ROUTINE 0378
*                                          GETMAIN FAILURE           */
@RF00376 L     @13,4(,@13)                                         0378
         L     @00,@SIZDATD                                        0378
         LR    @01,@11                                             0378
         FREEMAIN R,LV=(0),A=(1)
         L     @14,@CV00114                                        0378
         LM    @15,@12,16(@13)                                     0378
         BR    @14                                                 0378
*WRITE:    /**********************************************************/
*          /* WRITE: THIS ROUTINE CALLS IKJEFA52 TO FREE THE STORAGE */
*          /*   ACQUIRED BY THE READ ROUTINE (IKJEFA51).             */
*          /**********************************************************/
*          PROC;                                                   0379
WRITE    STM   @14,@12,@SA00002                                    0379
*          ACIOFL05='0'B;               /* MAKE CERTAIN NO WRITING 0380
*                                          TAKES PLACE               */
         L     @10,ACIOPTR(,COMMPTR)                               0380
         NI    ACIOFL05(@10),B'11110111'                           0380
*          RFY R1 RSTD;                 /* RESTRICT PARAMETER POINTER*/
*          R1=ACIOPTR;                  /* PARAMETER BLK ADDR TO R1  */
         LR    R1,@10                                              0382
*          CALL IKJEFA52;               /* INVOKE WRITE PGM -IKJEFA52*/
         L     @15,@CV00112                                        0383
         BALR  @14,@15                                             0383
*          RFY R1 UNRSTD;               /* RELEASE PARAMETER POINTER */
*          RFY R15 RSTD;                /* RESTRICT RETURN CODE REG  */
*          RETNCODE=R15;                /* SAVE RETURN CODE          */
         LR    RETNCODE,R15                                        0386
*          RFY R15 UNRSTD;              /* RELEASE RETURN CODE REG   */
*          /* CHECK RETURN CODE                                      */
*          IF RETNCODE^=0                                          0388
*            THEN                       /* WRITE ROUTINE FAILED      */
         LTR   RETNCODE,RETNCODE                                   0388
         BZ    @RF00388                                            0388
*               ERRFLG='1'B;            /* TURN ON ERROR FLAG        */
         OI    ERRFLG(COMMPTR),B'01000000'                         0389
*          READMNSW='0'B;               /* INDICATE THAT READ ROUTINE
*                                          STORAGE HAS BEEN RELEASED */
@RF00388 NI    READMNSW(COMMPTR),B'11111101'                       0390
*          END WRITE;                                              0391
@EL00002 DS    0H                                                  0391
@EF00002 DS    0H                                                  0391
@ER00002 LM    @14,@12,@SA00002                                    0391
         BR    @14                                                 0391
*GETSPACE: /**********************************************************/
*          /* GETSPACE: THIS ROUTINE CALLS IKJEFA53 TO OBTAIN SPACE  */
*          /*   IN A MEMBER BLOCK                                    */
*          /**********************************************************/
*          PROC;                                                   0392
GETSPACE STM   @14,@06,@SA00003                                    0392
         STM   @08,@12,@SA00003+36                                 0392
*          RFY R1 RSTD;                 /* RESTRICT PARAMETER REG    */
*RETRY:    R1=ADDR(SPACEPB);            /* ADDR OF PARAMETER BLOCK   */
RETRY    LA    R1,SPACEPB                                          0394
*          CALL IKJEFA53;               /* INVOKE GETSPACE MODULE    */
         L     @15,@CV00113                                        0395
         BALR  @14,@15                                             0395
*          RFY R1 UNRSTD;               /* RELEASE PARAMETER REG     */
*          RFY R15 RSTD;                /* RESTRICT RETURN CODE REG  */
*          RETNCODE=R15;                /* SAVE RETURN CODE          */
         LR    RETNCODE,R15                                        0398
*          RFY R15 UNRSTD;              /* RELEASE RETURN CODE REG   */
*          /* CHECK RETURN CODE                                      */
*          IF RETNCODE<8                                           0400
*            THEN                       /* SPACE AVAILABLE           */
         CH    RETNCODE,@CH00040                                   0400
         BL    @RT00400                                            0400
*              RETURN;                                             0401
*          /* SEE IF THE EXTRA BLOCK IS AVAILABLE                    */
*          IF ACIOFL04='0'BXBLKUSED='1'B                          0402
*            THEN                       /* EXTRA BLOCK NOT AVAILABLE */
         L     @09,ACIOPTR(,COMMPTR)                               0402
         TM    ACIOFL04(@09),B'00010000'                           0402
         BZ    @RT00402                                            0402
         TM    XBLKUSED(COMMPTR),B'00000001'                       0402
         BNO   @RF00402                                            0402
@RT00402 DS    0H                                                  0403
*              DO;                                                 0403
*                /* ACTION TAKEN HERE TO RELEASE THE READ ROUTINE  0404
*                   BUFFER AND PUT OUT A MESSAGE INDICATING THAT   0404
*                   WORKING STORAGE HAS BEEN EXHAUSTED IN          0404
*                   ATTEMPTING TO SATISFY THE ADD COMMAND.         0404
*                   DECIDE WHICH MESSAGE TO WRITE - IF BLOCK       0404
*                   WAS NOT AVAILABLE, SAY 'NO SPACE'                */
*                IF ACIOFL04='0'B                                  0404
*                  THEN                 /* NO EXTRA BLOCK THERE      */
         L     @09,ACIOPTR(,COMMPTR)                               0404
         TM    ACIOFL04(@09),B'00010000'                           0404
         BNZ   @RF00404                                            0404
*                    RETURN TO NOSPACE; /* TREAT AS A READ ROUTINE 0405
*                                           GETMAIN FAILURE          */
         LA    @14,NOSPACE                                         0405
         LM    @15,@06,@SA00003+4                                  0405
         LM    @08,@12,@SA00003+36                                 0405
         BR    @14                                                 0405
*                CALL WRITE;            /* SCRATCH READ ROUTINE STG  */
@RF00404 BAL   @14,WRITE                                           0406
*                /* SET PARAMETERS FOR PUTLINE MESSAGE               */
*                OUT1SCNT='02'X;        /* 1ST LEVEL MSG SEG COUNT =2*/
         MVI   OUT1SCNT,X'02'                                      0407
*                OUT1SEG1=ADDMSG(32);   /* ADDR OF 'UNABLE TO ADD'   */
         L     @09,ADDMSG+124(,MSGBASE)                            0408
         ST    @09,OUT1SEG1                                        0408
*                USRIDOF=35;            /* OFFSET FOR USERID INSERTN */
         MVC   USRIDOF(2),@CH00334                                 0409
*                OUT1SEG2=ADDR(USRIDSEG); /* ADDR OF USERID SEGMT    */
         LA    @09,USRIDSEG                                        0410
         ST    @09,OUT1SEG2                                        0410
*                OUT2SCNT='02'X;        /* 2ND LEVEL MSG SEG COUNT =1*/
         MVI   OUT2SCNT,X'02'                                      0411
*                OUT2SEG1=ADDMSG(33);   /* 2ND LVL = 'SIMPLER FORM'  */
         L     @09,ADDMSG+128(,MSGBASE)                            0412
         ST    @09,OUT2SEG1                                        0412
*                USERSEG2=USRIDSEG;     /* INITIALIZE ADD'L SEGMENT  */
         MVC   USERSEG2(11),USRIDSEG                               0413
*                USRSG2OF=53;           /* OFFSET FOR 2ND LVL INSERTN*/
         MVC   USRSG2OF(2),@CH00382                                0414
*                OUT2SEG2=ADDR(USERSEG2); /* ADDR OF ADD'L USRSEG    */
         LA    @10,USERSEG2                                        0415
         ST    @10,OUT2SEG2                                        0415
*                RETURN TO INFOMSG;     /* GO PUT OUT MESSAGE & LEAVE*/
         LA    @14,INFOMSG                                         0416
         LM    @15,@06,@SA00003+4                                  0416
         LM    @08,@12,@SA00003+36                                 0416
         BR    @14                                                 0416
*              END;                                                0417
*          /* INITIALIZE THE EXTRA BLOCK ACQUIRED BY THE READ      0418
*             SUBROUTINE.                                          0418
*             FIRST, MAKE SURE THAT 9 EXTENSIONS HAVE NOT BEEN USED  */
*          IF ACIONMBR>9                                           0418
*            THEN                       /* TOO MANY EXTENSIONS       */
@RF00402 L     @09,ACIOPTR(,COMMPTR)                               0418
         CLI   ACIONMBR(@09),9                                     0418
         BNH   @RF00418                                            0418
*              DO;                                                 0419
*                /* RELEASE READ ROUTINE BUFFER AND PUT OUT A MESSAGE
*                   INDICATING THAT EXTENSION BLOCKS ARE EXHAUSTED   */
*                CALL WRITE;            /* SCRATCH READ ROUTINE STG  */
         BAL   @14,WRITE                                           0420
*                /* SET PARAMETERS FOR PUTLINE MESSAGE               */
*                OUT1SCNT='02'X;        /* 1ST LEVEL MSG SEG COUNT =2*/
         MVI   OUT1SCNT,X'02'                                      0421
*                OUT1SEG1=ADDMSG(32);   /* ADDR OF 'UNABLE TO ADD'   */
         L     @09,ADDMSG+124(,MSGBASE)                            0422
         ST    @09,OUT1SEG1                                        0422
*                USRIDOF=35;            /* OFFSET FOR USERID INSERTN */
         MVC   USRIDOF(2),@CH00334                                 0423
*                OUT1SEG2=ADDR(USRIDSEG); /* ADDR OF USERID SEGMENT  */
         LA    @09,USRIDSEG                                        0424
         ST    @09,OUT1SEG2                                        0424
*                OUT2SCNT='02'X;        /* 2ND LEVEL MSG SEG COUNT =2*/
         MVI   OUT2SCNT,X'02'                                      0425
*                OUT2SEG1=ADDMSG(34);   /* ADDR OF 'EXTENSNS EXHAUSTD*/
         L     @09,ADDMSG+132(,MSGBASE)                            0426
         ST    @09,OUT2SEG1                                        0426
*                USERSEG2=USRIDSEG;     /* INITIALIZE ADD'L SEGMENT  */
         MVC   USERSEG2(11),USRIDSEG                               0427
*                USRSG2OF=48;           /* OFFSET FOR 2ND LVL INSERTN*/
         MVC   USRSG2OF(2),@CH00385                                0428
*                OUT2SEG2=ADDR(USERSEG2); /* ADDR OF ADD'L USER SEGMT*/
         LA    @10,USERSEG2                                        0429
         ST    @10,OUT2SEG2                                        0429
*                RETURN TO INFOMSG;     /* GO PUT OUT MESSAGE & LEAVE*/
         LA    @14,INFOMSG                                         0430
         LM    @15,@06,@SA00003+4                                  0430
         LM    @08,@12,@SA00003+36                                 0430
         BR    @14                                                 0430
*              END;                                                0431
*          HEDBPTR=ACIONMBR*UADSBLNG+ACIOBUFR;/* POINT TO EXTRA BLOCK*/
@RF00418 L     @09,ACIOPTR(,COMMPTR)                               0432
         SLR   @06,@06                                             0432
         IC    @06,ACIONMBR(,@09)                                  0432
         LR    @04,@06                                             0432
         MH    @04,UADSBLNG(,HEDBPTR)                              0432
         SLR   @15,@15                                             0432
         ICM   @15,7,ACIOBUFR(@09)                                 0432
         AR    @04,@15                                             0432
         LR    HEDBPTR,@04                                         0432
*          DHED=DHED&&DHED;             /* CLEAR HEADER PORTION      */
         XC    DHED(64,HEDBPTR),DHED(HEDBPTR)                      0433
*          UADSBLNG=ACIOBUFR->UADSBLNG; /* MEMBER BLOCK LENGTH       */
         LH    @09,UADSBLNG(,@15)                                  0434
         STH   @09,UADSBLNG(,HEDBPTR)                              0434
*          UADSFSQP=LENGTH(UADSMHDR);   /* OFFSET TO FSQE            */
         MVC   UADSFSQP(2,HEDBPTR),@CH00042                        0435
*          UADSUSER=BLDLNAME;           /* START WITH BASE MEMBER NAM*/
         L     @09,BLDLPTR(,COMMPTR)                               0436
         MVC   UADSUSER(8,HEDBPTR),BLDLNAME(@09)                   0436
*          DHED(USRIDLN+1)=ACIONMBR'0';/* POINT TO INDEX BYTE     0437
*                                           POSITION & MAKE IT EBCDIC*/
         LH    @09,USRIDLN                                         0437
         O     @06,@CF00386                                        0437
         STC   @06,DHED(@09,HEDBPTR)                               0437
*          FSQEPTR=HEDBPTR+UADSFSQP;    /* BASE FOR FREE SP Q ELEMENT*/
         LH    @09,UADSFSQP(,HEDBPTR)                              0438
         LR    FSQEPTR,HEDBPTR                                     0438
         AR    FSQEPTR,@09                                         0438
*          FSQELNTH=UADSBLNG-UADSFSQP;  /* LENGTH OF FREE AREA = TOTAL
*                                          BLOCK LNTH - HDR LENGTH   */
         LCR   @09,@09                                             0439
         AH    @09,UADSBLNG(,HEDBPTR)                              0439
         STH   @09,FSQELNTH(,FSQEPTR)                              0439
*          FSQELBIT(7:8)='00'B;         /* TRUNCATED TO MULTIPLE OF 4*/
         LA    @06,1                                               0440
         LR    @04,FSQEPTR                                         0440
         AR    @04,@06                                             0440
         NI    FSQELBIT(@04),B'11111100'                           0440
*          FSQENEXT=0;                  /* THIS IS THE ONLY FSQE   0441
*                                          ON THE CHAIN              */
         SLR   @04,@04                                             0441
         STH   @04,FSQENEXT(,FSQEPTR)                              0441
*          HEDBPTR=ACIOBUFR;            /* RESTORE BASE PTR          */
         LR    HEDBPTR,@15                                         0442
*          SPACMCNT=SPACMCNT+1;         /* INCREMENT GETSPACE COUNT
*                                          OF MEMBER BLOCKS          */
         AH    @06,SPACMCNT                                        0443
         STH   @06,SPACMCNT                                        0443
*          XBLKUSED='1'B;               /* SIGNAL 'EXTRA BLOCK USED' */
         OI    XBLKUSED(COMMPTR),B'00000001'                       0444
*          /* SET UP TO CLEAR THE WORK AREA TO ZEROES                */
*          RFY (R0,R1,R15) RSTD;        /* RESTRICT WORK REGISTERS   */
*          R0=FSQEPTR+4;                /* GET TO ADDRESS            */
         LA    @14,4                                               0446
         LR    R0,FSQEPTR                                          0446
         AR    R0,@14                                              0446
*          R1=FSQELNTH-4;               /* LOAD R1 WITH LENGTH       */
         SR    @09,@14                                             0447
         LR    R1,@09                                              0447
*          R15=0;                       /* LOAD R15 WITH 0 LENGTH    */
         LR    R15,@04                                             0448
*          GEN (MVCL  R0,R14)           /* CLEAR GOTTEN CORE         */
*            REFS(R0,R1,R15);                                      0449
         MVCL  R0,R14
*          RFY (R0,R1,R15) UNRSTD;      /* RELEASE WORK REGISTERS    */
*          GOTO RETRY;                  /* RETRY GETSPACE            */
         B     RETRY                                               0451
*          END GETSPACE;                                           0452
@EL00003 DS    0H                                                  0452
@EF00003 DS    0H                                                  0452
@ER00003 LM    @14,@06,@SA00003                                    0452
         LM    @08,@12,@SA00003+36                                 0452
         BR    @14                                                 0452
*IKJLSCAN: /**********************************************************/
*          /* IKJLSCAN - 'LATSCAN' SUBROUTINE -                      */
*          /*    SCANS THE INFORMATION FIELDS ON A GIVEN LEVEL IN THE*/
*          /*    UADS FOR AN INFORMATION ITEM WHICH MATCHES A GIVEN  */
*          /*    INPUT ITEM FROM THE PDL.                            */
*          /*                                                        */
*          /* IKJLSCAN IS ENTERED FROM 'FINDNODE' OR 'ADDER' WITH    */
*          /*    LSCANPTR POINTING TO A PARAMETER BLOCK:             */
*          /*                                                        */
*          /*         +0 ********************************            */
*          /*            *       *                      *            */
*          /*            * TYPE  *     PDE ADDRESS      *            */
*          /*            *       *                      *            */
*          /*         +4 ********************************            */
*          /*            *       *                      *            */
*          /*            * FLAGS * BEGINNING NODE ADDR  *            */
*          /*            *       *                      *            */
*          /*         +8 ********************************            */
*          /*            *                              *            */
*          /*            *        LATSCAN ANSWER        *            */
*          /*            *                              *            */
*          /*            ********************************            */
*          /*                                                        */
*          /*    WHERE -                                             */
*          /*       TYPE     = AN INDEX TO A DATA ATTRIBUTE TABLE    */
*          /*                  CONTAINING LENGTH AND OFFSET INFO.    */
*          /*                   '01'X  = PASSWORD                    */
*          /*                   '02'X  = ACCOUNT NUMBER              */
*          /*                   '03'X  = PROCEDURE NAME              */
*          /*       PDE ADDR = ADDR OF PARSE PDE LOCATING INPUT      */
*          /*                  SCAN ARGUMENT                         */
*          /*       FLAGS      DEFINED AS FOLLOWS:                   */
*          /*                   BIT 0 = 0  'LOCAL' LATERAL SCAN      */
*          /*                         = 1  'TOTAL' LATERAL SCAN      */
*          /*                   BIT 2-7 UNUSED                       */
*          /*       BEGINNING NODE ADDR =                            */
*          /*                  ADDR OF NODE WHERE SCAN IS TO START   */
*          /*       LATSCAN ANSWER (SUPPLIED BY LATSCAN ROUTINE) =   */
*          /*                  ADDR OF NODE REPRESENTING MATCHING    */
*          /*                  INFO                                  */
*          /*                               -OR-                     */
*          /*                  ADDR OF LAST NODE IN SCANNED CHAIN    */
*          /*                                                        */
*          /* TABLES, WORK AREAS -                                   */
*          /*    DTATBL - DATA ITEM ATTRIBUTE TABLE                  */
*          /*                                                        */
*          /* IKJLSCAN RETURNS TO ITS CALLER WITH A RETURN CODE IN   */
*          /*    SCANRTCD AS FOLLOWS:                                */
*          /*       0 - INFORMATION FOUND, ANSWER CONTAINS NODE ADDR */
*          /*       4 - INFORMATION NOT FOUND, ANSWER POINTS TO LAST */
*          /*             NODE IN SCANNED CHAIN                      */
*          /*       8 - LEVEL NOT SUPPORTED FOR THIS USER            */
*          /*             (ANSWER PTR UNALTERED)                     */
*          /**********************************************************/
*          PROC;                                                   0453
IKJLSCAN STM   @14,@01,12(@13)                                     0453
         STM   @03,@12,32(@13)                                     0453
*          /* FIRST, SEE IF THIS LEVEL IS SUPPORTED                  */
*          IF SCANBEGN->UADSNDAT=0                                 0454
*            THEN                       /* INFO OFFSET = 0 MEANS   0454
*                                          NON-SUPPORT               */
         SLR   @10,@10                                             0454
         ICM   @10,7,SCANBEGN(LSCANPTR)                            0454
         L     @10,UADSNDAT(,@10)                                  0454
         LTR   @10,@10                                             0454
         BNZ   @RF00454                                            0454
*              DO;                                                 0455
*              SCANRTCD=8;              /* INDICATE 'NON-SUPPORT'    */
         LA    SCANRTCD,8                                          0456
*              RETURN;                  /* RETURN TO CALLER          */
@EL00004 DS    0H                                                  0457
@EF00004 DS    0H                                                  0457
@ER00004 LM    @14,@01,12(@13)                                     0457
         LM    @03,@12,32(@13)                                     0457
         BR    @14                                                 0457
*              END;                                                0458
*          RELFACTR=HEDBPTR+DTAOFFST(SCANTYPE); /* COMPUTE RELOCATION
*                                                  FACTOR FOR DATA   */
@RF00454 SLR   @10,@10                                             0459
         IC    @10,SCANTYPE(,LSCANPTR)                             0459
         SLA   @10,2                                               0459
         LA    @15,DTATBL                                          0459
         LR    RELFACTR,HEDBPTR                                    0459
         LA    @01,0(@10,@15)                                      0459
         AL    @01,@CF00420                                        0459
         SLR   @00,@00                                             0459
         IC    @00,DTAOFFST-2(,@01)                                0459
         AR    RELFACTR,@00                                        0459
*          NODEPTR=SCANBEGN;            /* INITIALIZE PTR TO 1ST NODE*/
         SLR   NODEPTR,NODEPTR                                     0460
         ICM   NODEPTR,7,SCANBEGN(LSCANPTR)                        0460
*          DATAPTR=NODEPTR->UADSNDAT+RELFACTR; /* POINT TO DATA FIELD*/
         LR    DATAPTR,RELFACTR                                    0461
         A     DATAPTR,UADSNDAT(,NODEPTR)                          0461
*          ARGUMENT=INFOFLD(1:PDDATLNG);/* PAD ARGUMENT WITH BLANKS  */
         MVI   ARGUMENT+1,C' '                                     0462
         MVC   ARGUMENT+2(38),ARGUMENT+1                           0462
         SLR   @14,@14                                             0462
         ICM   @14,7,SCANPDE(LSCANPTR)                             0462
         LH    @09,PDDATLNG(,@14)                                  0462
         BCTR  @09,0                                               0462
         L     @01,PDDATPTR(,@14)                                  0462
         EX    @09,@SM00433                                        0462
*          COMPLNTH=DTALNTH(SCANTYPE);  /* SET COMPARE LENGTH FROM 0463
*                                          ATTRIBUTE TABLE           */
         AL    @15,@CF00344                                        0463
         SLR   COMPLNTH,COMPLNTH                                   0463
         IC    COMPLNTH,DTALNTH-3(@10,@15)                         0463
*LSCMPARE: /* SEE IF A LENGTH COMPARISON IS NECESSARY                */
*          IF DTAFLGS(SCANTYPE,1)='1'B                             0464
*            THEN                       /* DATA LENGTH IS VARIABLE   */
LSCMPARE SLR   @10,@10                                             0464
         IC    @10,SCANTYPE(,LSCANPTR)                             0464
         SLA   @10,2                                               0464
         LA    @15,DTATBL                                          0464
         ALR   @15,@10                                             0464
         AL    @15,@CF00419                                        0464
         TM    DTAFLGS(@15),B'10000000'                            0464
         BNO   @RF00464                                            0464
*              /* SEE IF THE LENGTHS ARE EQUAL                       */
*              IF PDDATLNG^=VLNTHLNG                               0465
*                THEN                   /* LENGTHS UNEQUAL - NO MATCH*/
         SLR   @10,@10                                             0465
         ICM   @10,7,SCANPDE(LSCANPTR)                             0465
         SLR   @15,@15                                             0465
         IC    @15,VLNTHLNG(,DATAPTR)                              0465
         CH    @15,PDDATLNG(,@10)                                  0465
         BNE   @RT00465                                            0465
*                  GO TO NOMATCH;       /* GO SEE IF MORE NODES EXIST*/
*                ELSE                   /* LENGTHS MATCH-CLR TO COMPR*/
*                  DO;                                             0467
*                    COMPLNTH=VLNTHLNG; /* PICK UP VARIABLE LENGTH   */
         LR    COMPLNTH,@15                                        0468
*                    DATAPTR=DATAPTR+1; /* STEP PTR PAST LENGTH BYTE */
         AH    DATAPTR,@CH00032                                    0469
*                  END;                                            0470
*          /* SEE IF WE HAVE A MATCH                                 */
*          IF ARGUMENT(1:COMPLNTH)=UADSFLD(1:COMPLNTH)             0471
*            THEN                       /* WE FOUND DATA SOUGHT FOR  */
@RF00464 LR    @10,COMPLNTH                                        0471
         BCTR  @10,0                                               0471
         EX    @10,@SC00435                                        0471
         BNE   @RF00471                                            0471
*              DO;                                                 0472
*              SCANRTCD=0;              /* INDICATE ITEM FOUND       */
         SLR   SCANRTCD,SCANRTCD                                   0473
*              GOTO SETANSR;            /* GO PLUG IN SCAN ANSR      */
         B     SETANSR                                             0474
*              END;                                                0475
*NOMATCH:  /* CHECK FOR END OF LOCAL LATERAL CHAIN                   */
*          IF NODEPTR->UADSNFLG='0'B                               0476
*            THEN                       /* THIS IS NOT THE LAST NODE */
@RF00471 DS    0H                                                  0476
NOMATCH  TM    UADSNFLG(NODEPTR),B'10000000'                       0476
         BZ    @RT00476                                            0476
*              GO TO NODUPDAT;          /* GO UPDATE NODEPTR TO NEXT */
*          /* CHECK FOR A LOCAL SCAN REQUEST                         */
*          IF SCANFLGS(1)^='0'B                                    0478
*            THEN                       /* A TOTAL SCAN REQUESTED    */
         TM    SCANFLGS(LSCANPTR),B'10000000'                      0478
         BZ    @RF00478                                            0478
*              DO;                                                 0479
*              /* CHECK FOR END OF TOTAL LATERAL CHAIN               */
*              IF NODEPTR->UADSNNEX^=0                             0480
*                THEN                   /* THIS IS NOT THE LAST NODE */
         ICM   @10,7,UADSNNEX(NODEPTR)                             0480
         BZ    @RF00480                                            0480
*NODUPDAT:         /* CTL. PASSED OR DROPPED HERE TO UPDATE 'NODEPTR'*/
*                  DO;                                             0481
NODUPDAT DS    0H                                                  0482
*                  NODEPTR=NODEPTR->UADSNNEX+HEDBPTR; /* PT. TO NEXT */
         SLR   @10,@10                                             0482
         ICM   @10,7,UADSNNEX(NODEPTR)                             0482
         AR    @10,HEDBPTR                                         0482
         LR    NODEPTR,@10                                         0482
*                  DATAPTR=NODEPTR->UADSNDAT+RELFACTR; /* PT. TO DATA*/
         LR    DATAPTR,RELFACTR                                    0483
         A     DATAPTR,UADSNDAT(,NODEPTR)                          0483
*                  GO TO LSCMPARE;      /* GO BACK TO SCAN SOME MORE */
         B     LSCMPARE                                            0484
*                  END;                                            0485
*              END;                                                0486
@RF00480 DS    0H                                                  0487
*          /* CTL. PASSED OR DROPPED HERE TO INDICATE 'NOT-FOUND' RC */
*          SCANRTCD=4;                  /* INDICATE ITEM NOT FOUND   */
@RF00478 LA    SCANRTCD,4                                          0487
*SETANSR:  /* SET POINTER TO NODE IN ANSWER SLOT IN PARAMETER LIST   */
*          SCANANSR=NODEPTR;            /* STORE IN WORD 3           */
SETANSR  ST    NODEPTR,SCANANSR(,LSCANPTR)                         0488
*          END IKJLSCAN;                /* END OF 'LATSCAN' SUBR     */
         B     @EL00004                                            0489
*          END IKJEFA13                                            0490
*/* THE FOLLOWING INCLUDE STATEMENTS WERE FOUND IN THIS PROGRAM.      *
*/*%INCLUDE SYSLIB  (IKJEFUAD)                                        *
*/*%INCLUDE SYSLIB  (IKJIOPL )                                        *
*/*%INCLUDE SYSLIB  (IKJPTPB )                                        *
*;                                                                 0490
         B     @EL00001                                            0490
@DATA    DS    0H
@CH00032 DC    H'1'
@CH00108 DC    H'4'
@CH00040 DC    H'8'
@CH00355 DC    H'10'
@CH00055 DC    H'12'
@CH00042 DC    H'16'
@CH00368 DC    H'25'
@CH00334 DC    H'35'
@CH00385 DC    H'48'
@CH00382 DC    H'53'
@CH00354 DC    H'59'
@SM00413 MVC   DYNLFORM(0),INLINLFM
@SM00421 MVC   DATAITEM(0,DATAPTR),DATAITEM(@04)
@SM00423 MVC   INSTTX(0),DATAITEM(@10)
@SM00425 MVC   INSTTX(0),DATAITEM(@09)
@SM00433 MVC   ARGUMENT(0),INFOFLD(@01)
@SC00435 CLC   ARGUMENT(0),UADSFLD(DATAPTR)
@DATD    DSECT
         DS    0F
@SA00001 DS    18F
@SA00003 DS    14F
@SA00002 DS    0F
         DS    15F
IKJEFA13 CSECT
         DS    0F
@CF00419 DC    F'-4'
@CF00418 DC    F'-3'
@CF00420 DC    F'-2'
@CF00344 DC    F'-1'
@CF00386 DC    XL3'0'
         DC    C'0'
@DATD    DSECT
         DS    0D
UADSPPTR DS    A
UADSAPTR DS    A
PSIZE    DS    H
         DS    CL2
OUTLNDS  DS    CL52
         ORG   OUTLNDS
@NM00016 DS    CL28
         ORG   @NM00016
OUT1LINK DS    AL4
@NM00017 DS    CL3
OUT1SCNT DS    CL1
OUT1SEG1 DS    AL4
OUT1SEG2 DS    AL4
OUT1SEG3 DS    AL4
OUT1SEG4 DS    AL4
OUT1SEG5 DS    AL4
         ORG   OUTLNDS+28
OUTLD2   DS    CL24
         ORG   OUTLD2
@NM00018 DS    AL4
@NM00019 DS    CL3
OUT2SCNT DS    CL1
OUT2SEG1 DS    AL4
OUT2SEG2 DS    AL4
OUT2SEG3 DS    AL4
OUT2SEG4 DS    AL4
         ORG   OUTLNDS+52
USRIDSEG DS    CL12
         ORG   USRIDSEG
USRIDLN  DS    FL2
USRIDOF  DS    FL2
USRIDI   DS    CL8
         ORG   USRIDSEG+12
USERSEG2 DS    CL11
         ORG   USERSEG2
@NM00020 DS    FL2
USRSG2OF DS    FL2
@NM00021 DS    CL7
         ORG   USERSEG2+11
         DS    CL1
INSTSEG  DS    CL44
         ORG   INSTSEG
INSTLN   DS    FL2
INSTOF   DS    FL2
INSTTX   DS    CL40
         ORG   INSTSEG+44
SPACEPB  DS    CL12
         ORG   SPACEPB
@NM00024 DS    CL8
         ORG   @NM00024
SPACMPTR DS    AL4
SPACMCNT DS    FL2
SPACLNTH DS    FL2
         ORG   SPACEPB+8
@NM00025 DS    CL4
         ORG   @NM00025
SPACOFST DS    AL4
         ORG   SPACEPB+12
SCANLIST DS    CL12
@NM00041 DS    CL8
         ORG   @NM00041
FNOUTPTR DS    AL4
FNOUTLNG DS    FL4
         ORG   @NM00041+8
ADDWKAR  DS    CL36
NODEPDE  DS    CL14
         ORG   NODEPDE
PASSWDP  DS    AL4
PWLEN1   DS    AL2
@NM00049 DS    BL2
ACCTNOP  DS    AL4
ACTLEN1  DS    AL2
         ORG   NODEPDE+14
ARGUMENT DS    CL40
IKJEFA13 CSECT
         DS    0F
@SIZDATD DC    AL1(1)
         DC    AL3(@ENDDATD-@DATD)
@CV00111 DC    V(MSGTABLE)
@CV00112 DC    V(IKJEFA52)
@CV00113 DC    V(IKJEFA53)
@CV00114 DC    V(RDGETERR)
@CV00115 DC    V(ADDERCLN)
         DS    0D
@CC00312 DC    C'* '
DTATBL   DS    CL12
         ORG   DTATBL
@NM00053 DS    CL4
         ORG   @NM00053
@NM00054 DC    X'00'
@NM00055 DC    AL1(12)
@NM00056 DC    AL1(4)
@NM00057 DC    AL1(8)
         ORG   DTATBL+4
@NM00058 DS    CL4
         ORG   @NM00058
@NM00059 DC    X'80'
         ORG   @NM00059
@NM00060 DS    BL1
         ORG   @NM00058+1
@NM00061 DC    AL1(45)
@NM00062 DC    AL1(44)
@NM00063 DS    AL1
         ORG   DTATBL+8
@NM00064 DS    CL4
         ORG   @NM00064
@NM00065 DC    X'00'
@NM00066 DC    AL1(24)
@NM00067 DC    AL1(4)
@NM00068 DC    AL1(8)
         ORG   DTATBL+12
@DATD    DSECT
IKJEFA13 CSECT
INLINLFM DS    0F
         FREEMAIN V,SP=1,MF=L             LENGTH AND ADD. SET BY E
         GETMAIN EC,SP=1,MF=L             LENGTH & ANS PTR SET BY E
INLINLNG DC    A(*-INLINLFM)              LENGTH OF L-FORM LIST
@DATD    DSECT
DYNLFORM DS    0F
DYNFRLST FREEMAIN V,SP=1,MF=L             WILL BE INIT'D FROM INLINLFM
DYNGTLST GETMAIN EC,MF=L                  WILL BE INIT'D FROM INLINLFM
IKJEFA13 CSECT
         DS   0H
PATCHLOC DC ((@DATA-@PSTART)/20)X'00'
@DATD    DSECT
         ORG   *+1-(*-@DATD)/(*-@DATD) INSURE DSECT DATA
@ENDDATD EQU   *
IKJEFA13 CSECT
@00      EQU   00                      EQUATES FOR REGISTERS 0-15
@01      EQU   01
@02      EQU   02
@03      EQU   03
@04      EQU   04
@05      EQU   05
@06      EQU   06
@07      EQU   07
@08      EQU   08
@09      EQU   09
@10      EQU   10
@11      EQU   11
@12      EQU   12
@13      EQU   13
@14      EQU   14
@15      EQU   15
DATAPTR  EQU   @02
COMPLNTH EQU   @04
RELFACTR EQU   @05
NODEPTR  EQU   @03
COUNTPTR EQU   @02
FINDPTR  EQU   @09
MARKMARK EQU   @05
NUMOFNDS EQU   @02
N        EQU   @05
LOOPCNT  EQU   @02
RETNCODE EQU   @02
SCANRTCD EQU   @02
LSCANPTR EQU   @06
MSGBASE  EQU   @10
COMMPTR  EQU   @08
FSQEPTR  EQU   @05
UADSRPTR EQU   @02
UADSNPTR EQU   @03
HEDBPTR  EQU   @07
R0       EQU   @00
R1       EQU   @01
R15      EQU   @15
R14      EQU   @14
DHED     EQU   0
UADSMHDR EQU   DHED
UADSBLNG EQU   UADSMHDR
UADSFSQP EQU   UADSMHDR+2
UADSUSER EQU   UADSMHDR+4
UADSBN01 EQU   UADSMHDR+12
UADSMAXC EQU   UADSMHDR+14
UADSATTR EQU   DHED+16
UADSPWD1 EQU   DHED+24
UADSNODE EQU   0
UADSNWD1 EQU   UADSNODE
UADSNFLG EQU   UADSNWD1
UADSNNEX EQU   UADSNWD1+1
UADSNSUB EQU   UADSNODE+4
UADSNDAT EQU   UADSNODE+8
DPOBD    EQU   0
DNOBD    EQU   0
DROBD    EQU   0
UADSRSIZ EQU   DROBD+14
UADSUNAM EQU   DROBD+16
UADSFSQE EQU   0
FSQELNTH EQU   UADSFSQE
FSQENEXT EQU   UADSFSQE+2
IOPL     EQU   0
IOPLIOPB EQU   IOPL+12
PTPB     EQU   0
PTPBOPUT EQU   PTPB+4
COMMON   EQU   0
ACIOPTR  EQU   COMMON
BLDLPTR  EQU   COMMON+4
DATASUBP EQU   COMMON+8
IOPLPTR  EQU   COMMON+20
NODELADR EQU   COMMON+24
SIZEH    EQU   COMMON+28
UNITN    EQU   COMMON+37
NUMOFLVL EQU   COMMON+45
ERRFLG   EQU   COMMON+46
PUTERR   EQU   COMMON+46
RSIZSW   EQU   COMMON+46
NONODESW EQU   COMMON+46
FINDEXSW EQU   COMMON+46
READMNSW EQU   COMMON+46
XBLKUSED EQU   COMMON+46
ADDMSG   EQU   0
BLDLLIST EQU   0
BLDLNAME EQU   BLDLLIST+4
@NM00026 EQU   0
@NM00027 EQU   @NM00026
ACIOFL04 EQU   @NM00027
ACIOFL05 EQU   @NM00027
ACIONMBR EQU   @NM00026+16
ACIOBUFR EQU   @NM00026+17
@NM00038 EQU   @NM00026+20
LSCANBLK EQU   0
SCANTYPE EQU   LSCANBLK
SCANPDE  EQU   LSCANBLK+1
SCANFLGS EQU   LSCANBLK+4
SCANBEGN EQU   LSCANBLK+5
SCANANSR EQU   LSCANBLK+8
FSQELBIT EQU   0
@NM00040 EQU   0
MARKFLAG EQU   @NM00040
MARKER   EQU   @NM00040+1
@NM00042 EQU   0
FNOEOLST EQU   @NM00042
FOUNDNDE EQU   @NM00042+1
@NM00044 EQU   0
SETFLAG  EQU   @NM00044
MARKER1  EQU   @NM00044+1
MARKER2  EQU   @NM00044+4
MARKER3  EQU   @NM00044+8
@NM00046 EQU   0
DATAADR  EQU   @NM00046
DATALNTH EQU   @NM00046+4
DATACHN  EQU   @NM00046+9
DATAITEM EQU   0
USECOUNT EQU   0
NLSTTAB  EQU   0
PASSWD   EQU   NLSTTAB+9
ACTLEN   EQU   NLSTTAB+17
ACCTNO   EQU   NLSTTAB+18
@NM00069 EQU   0
DTAFLGS  EQU   @NM00069
DTABLNTH EQU   @NM00069+1
DTAOFFST EQU   @NM00069+2
DTALNTH  EQU   @NM00069+3
VLNTHLNG EQU   0
UADSFLD  EQU   0
@NM00070 EQU   0
PDDATPTR EQU   @NM00070
PDDATLNG EQU   @NM00070+4
INFOFLD  EQU   0
PTPBPTR  EQU   IOPLIOPB
         AGO   .@UNREFD                START UNREFERENCED COMPONENTS
@NM00071 EQU   @NM00070+6
@NM00052 EQU   NLSTTAB+58
@NM00051 EQU   NLSTTAB+1
@NM00050 EQU   NLSTTAB
@NM00048 EQU   @NM00046+8
@NM00047 EQU   @NM00046+6
@NM00045 EQU   @NM00044
@NM00043 EQU   @NM00042
@NM00039 EQU   @NM00038
@NM00037 EQU   @NM00026+12
@NM00036 EQU   @NM00026+8
@NM00035 EQU   @NM00026+4
@NM00034 EQU   @NM00026+1
@NM00033 EQU   @NM00027
@NM00032 EQU   @NM00027
@NM00031 EQU   @NM00027
@NM00030 EQU   @NM00027
@NM00029 EQU   @NM00027
@NM00028 EQU   @NM00027
@NM00023 EQU   BLDLLIST+2
@NM00022 EQU   BLDLLIST
@NM00015 EQU   COMMON+46
@NM00014 EQU   COMMON+32
@NM00013 EQU   COMMON+30
@NM00012 EQU   COMMON+16
@NM00011 EQU   COMMON+12
PTPBFLN  EQU   PTPB+8
@NM00010 EQU   PTPB
IOPLECB  EQU   IOPL+8
IOPLECT  EQU   IOPL+4
IOPLUPT  EQU   IOPL
@NM00009 EQU   DROBD+12
UADSRNAM EQU   DROBD+4
@NM00008 EQU   DROBD+1
UADSRCTR EQU   DROBD
UADSANUM EQU   DNOBD+45
UADSALEN EQU   DNOBD+44
UADSADRF EQU   DNOBD+4
@NM00007 EQU   DNOBD+1
UADSACTR EQU   DNOBD
UADSPPWD EQU   DPOBD+4
@NM00006 EQU   DPOBD+1
UADSPCTR EQU   DPOBD
@NM00005 EQU   UADSNWD1
@NM00004 EQU   DHED+40
UADSDEST EQU   DHED+32
UADSPERP EQU   DHED+28
UADSUPTP EQU   DHED+20
UADSINST EQU   DHED+18
@NM00003 EQU   UADSATTR
USATR03  EQU   UADSATTR
USATR02  EQU   UADSATTR
USATR01  EQU   UADSATTR
USATR00  EQU   UADSATTR
@NM00002 EQU   UADSBN01+1
UADSEXPF EQU   UADSBN01+1
UADSNUSP EQU   UADSBN01+1
@NM00001 EQU   UADSBN01
.@UNREFD ANOP                          END UNREFERENCED COMPONENTS
@RT00071 EQU   NOSPACE
@RT00085 EQU   MRKRTST1
@RT00087 EQU   ANODETST
@RT00096 EQU   NONODE
@RT00099 EQU   MRKRTST1
@RT00119 EQU   NONODE
@RT00123 EQU   ALLNODES
@RT00126 EQU   ALLNODES
@RT00136 EQU   NONODE
@RC00185 EQU   INFOMSG
@RT00200 EQU   SCANERR
@RT00208 EQU   ASTKERR
@RF00208 EQU   LATLINK
@RT00218 EQU   ADDINFO
@RT00220 EQU   SCANERR
@RT00235 EQU   ADDINFO
@RC00273 EQU   INFOMSG
@RT00297 EQU   CHAINTST
@RT00313 EQU   DUPLSCAN
@RF00329 EQU   @EL00001
@RT00337 EQU   DUPLMSG
@RC00343 EQU   INFOMSG
@RT00400 EQU   @EL00003
@RT00465 EQU   NOMATCH
@RT00476 EQU   NODUPDAT
@PB00004 EQU   @EL00001
@PB00003 EQU   @PB00004
@PB00002 EQU   @PB00003
@ENDDATA EQU   *
         END   IKJEFA13
