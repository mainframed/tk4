         TITLE ' IKJEFE04 - EXEC MESSAGE MODULE'
* GEN(TITLE  'IKJEFE04 - EXEC MESSAGE MODULE');
         TITLE  'IKJEFE04 - EXEC MESSAGE MODULE'
* IKJEFE04: PROC (DUMPARM) OPTIONS (DONTSAVE(1,15),REENTRANT);
         LCLA  &T,&SPN                                            0002
.@001    ANOP                                                     0002
IKJEFE04 CSECT ,                                                  0002
         ST    @E,12(0,@D)                                        0002
         ST    @0,20(0,@D)                                        0002
         STM   @2,@C,28(@D)                                       0002
         BALR  @B,0                                               0002
@PSTART  DS    0H                                                 0002
         USING @PSTART+00000,@B                                   0002
         LR    @C,@1                                              0002
         L     @0,@SIZ001                                         0002
         GETMAIN  R,LV=(0)                                        0002
         XR    @C,@1                                              0002
         XR    @1,@C                                              0002
         XR    @C,@1                                              0002
         USING @DATD+00000,@C                                     0002
         L     @0,20(0,@D)                                        0002
         XC    @TEMPS(@L),@TEMPS                                  0002
         ST    @D,@SAV001+4                                       0002
         LA    @F,@SAV001                                         0002
         ST    @F,8(0,@D)                                         0002
         LR    @D,@F                                              0002
* /********************************************************************
* /*                                                                  *
* /*  STATUS --                                                       *
* /*     CHANGE LEVEL 000                                             *
* /*    D305000-355500,245000-245500,247000-249000              Y01676*
* /*    D243000-243500,257500,259500,261500-265000              Y01676*
* /*    C097000,200000,368500                                   Y01676*
* /*    A304000-304500,097100-097200,200100-200200              Y01676*
* /*    A253600,253700,368600                                   Y01676*
* /*                                                            20035 *
* /*                                                                  *
* /*  FUNCTION --                                                     *
* /*     MODULE IKJEFE04 IS INVOKED BY ONE OF THE OTHER MODULES       *
* /*     OF EXEC TO INVOKE THE PUTLINE SERVICE ROUTINE TO PUT A       *
* /*     MESSAGE TO THE TERMINAL.                                     *
* /*                                                                  *
* /*     UPON ENTRY TO E04 A CHECK IS MADE TO DETERMINE IF THERE      *
* /*     IS A DYNAMIC PORTION OF THE MESSAGE. IF THERE IS, THE        *
* /*     SEGMENT COUNT FIELD OF THE PUTLINE PARM BLOCK IS SET TO      *
* /*     TWO. OTHERWISE THE SEGMENT COUNT IS SET TO ONE. A CHECK      *
* /*     IS MADE TO SEE IF THERE ARE TO BE TWO LEVELS OF MESSAGES.    *
* /*     IF THERE ARE THE PUTLINE PARM BLOCK IS SET TO INDICATE       *
* /*     THIS. THEN IF THERE IS A DYNAMIC PORTION IT IS MOVED TO      *
* /*     A WORK AREA WHOSE ADDRESS AND OFFSET ARE JOINED IN THE       *
* /*     PUTLINE PARM BLOCK. THE TOTAL LENGTH OF THE FIRST LEVEL      *
* /*     MESSAGE IS THEN EXAMINED TO FIND IF IT EXCEEDS 256 BYTES.    *
* /*     IF IT DOES THE DYNAMIC PORTION IS TRUNCATED SO THAT THE      *
* /*     LENGTH WILL BE 256 CHARACTERS.                               *
* /*                                                                  *
* /*     NEXT THE ADDRESS OF THE SECOND LEVEL MESSAGE, IF ANY, IS     *
* /*     PLACED IN THE PUTLINE PARM BLOCK. THE PUTLINE SERVICE        *
* /*     ROUTINE IS THEN LINKED TO. ON RETURN FROM THE SERVICE        *
* /*     ROUTINE WE EXAMINE REG15 TO FIND IF AN ERROR OCCURRED.       *
* /*     IF ONE HAS OCCURRED AN ERROR CODE IS SET IN RETCDAR IN       *
* /*     IN E01DATDF(SEE 'TABLES/WORK-AREAS').                        *
* /*     IN EITHER CASE RETURN IS MADE TO THE MODULE                  *
* /*     WHICH CALLED US.                                             *
* /*                                                                  *
* /*  ENTRY POINTS --                                                 *
* /*     IKJEFE04 - ONLY ENTRY POINT.                                 *
* /*                                                                  *
* /*  INPUT --                                                        *
* /*     REGISTER ONE CONTAINS A POINTER TO THE STRUCTURE E01DATDF.   *
* /*     (SEE 'TABLES/WORK-AREAS')                                    *
* /*                                                                  *
* /*  OUTPUT --                                                       *
* /*     RETCDAR(A FIELD IN E01DATDF) IS SET TO 16 IF PUTLINE WAS     *
* /*     UNABLE TO PUT OUT THE LINE.                                  *
* /*                                                                  *
* /*  EXTERNAL REFERENCES --                                          *
* /*     THE STRUCTURE E01DATDF IS USED BY ALL FOUR MODULES FOR COM-  *
* /*     MUNICATION.                                                  *
* /*     PUTLINE IS AN I/O SERVICE ROUTINE CALLED TO WRITE A          *
* /*     MESSAGE TO THE TERMINAL.                                     *
* /*                                                                  *
* /*  EXITS, NORMAL --                                                *
* /*     ALL EXITS ARE RETURNS TO THE CALLER.  RETURN CODES ARE DES-  *
* /*     CRIBED UNDER OUTPUT.                                         *
* /*                                                                  *
* /*  EXITS, ERROR --                                                 *
* /*     SAME AS NORMAL EXITS WITH ERROR INDICATION SET IN RETURN     *
* /*     CODE.                                                        *
* /*                                                                  *
* /*  TABLES/WORKAREAS --                                             *
* /*     M1TAB - A TABLE CONTAINING ALL THE FIRST LEVEL MESSAGES TO   *
* /*             BE SENT TO THE TERMINAL.                             *
* /*     M2TAB - A TABLE CONTAINING ALL THE SECOND LEVEL MESSAGES TO  *
* /*             BE SENT TO THE TERMINAL.                             *
* /*     ADTAB1 - TABLE OF ADDRESSES OF FIRST LEVEL MESSAGES.         *
* /*     ADTAB2 - TABLE OF ADDRESSES OF SECOND LEVEL MESSAGES.        *
* /*                                                                  *
* /*    E01DATDF (DOUBLE WORD BOUNDARY)                               *
* /*      ×---------------------------------------------------------× *
* /*   +0 ×DCB FOR DATA SET CONTAINING COMMAND PROCEDURE            × *
* /*      ×---------------------------------------------------------× *
* /*   +88×POINTER USED FOR INDIRECT ADDRESSING                     × *
* /*      ×---------------------------------------------------------× *
* /*   +92×POINTER USED FOR INDIRECT ADDRESSING                     × *
* /*      ×---------------------------------------------------------× *
* /*   +96×NAME OF PDS MEMBER WHICH CONTAINS THE PROC               × *
* /*      ×---------------------------------------------------------× *
* /*  +104×DECB FOR THE READ MACRO                                  × *
* /*      ×---------------------------------------------------------× *
* /*  +124×POINTER TO INPUT RECORD FROM PROC                        × *
* /*      ×---------------------------------------------------------× *
* /*  +128×NO. OF BYTES ON INPUT RCD WHICH HAVE NOT BEEN PROCESSED  × *
* /*      ×---------------------------------------------------------× *
* /*  +132×NO. OF POSITIONAL PARAMETERS FOUND ON THE PROC STATEMENT × *
* /*      ×---------------------------------------------------------× *
* /*  +136×WORK AREA - ALSO USED TO PASS ADDRESS OF CORE TO BE FREED× *
* /*      ×  BY MODULE E03                                          × *
* /*      ×---------------------------------------------------------× *
* /*  +140×MINIMUM AMOUNT OF CORE NEEDED FROM A GETMAIN             × *
* /*      ×---------------------------------------------------------× *
* /*  +144×MAXIMUM AMOUNT OF CORE NEEDED FROM A GETMAIN             × *
* /*      ×---------------------------------------------------------× *
* /*  +148×ADDRESS OF CORE OBTAINED VIA GETMAIN                     × *
* /*      ×---------------------------------------------------------× *
* /*  +152×AMOUNT OF CORE OBTAINED VIA GETMAIN                      × *
* /*      ×---------------------------------------------------------× *
* /*  +156×ADDRESS OF SUBPOOL 78 CORE WHICH BELONGS TO US           × *
* /*      ×---------------------------------------------------------× *
* /*  +160×LENGTH OF SUBPOOL 78 CORE WHICH BELONGS TO US            × *
* /*      ×---------------------------------------------------------× *
* /*  +164×WORK AREA                                                × *
* /*      ×---------------------------------------------------------× *
* /*  +168×NO. OF POSITIONAL PARMS SPECIFIED ON THE PROC STMT       × *
* /*      ×---------------------------------------------------------× *
* /*  +172×POINTER TO CURRENT BLOCK OF ATAB                         × *
* /*      ×---------------------------------------------------------× *
* /*  +176×POINTER TO CURRENT ELEMENT OF ATAB                       × *
* /*      ×---------------------------------------------------------× *
* /*  +180×POINTER TO CURRENT BLOCK OF FTAB                         × *
* /*      ×---------------------------------------------------------× *
* /*  +184×POINTER TO CURRENT ELEMENT OF FTAB                       × *
* /*      ×---------------------------------------------------------× *
* /*  +188×NO. OF BYTES IN VALUE PART OF KEYWORD WITH VALUE         × *
* /*      ×---------------------------------------------------------× *
* /*  +192×NO. OF KEYWORD W/O VALUE PARMS DEFINED IN PROC STMT      × *
* /*      ×---------------------------------------------------------× *
* /*  +194×NO. OF KEYWORD WITH VALUE PARMS DEFINED IN PROC STMT     × *
* /*      ×---------------------------------------------------------× *
* /*  +196×TOTAL BYTES IN ALL KEYWORD W/O VALUE PARMS               × *
* /*      ×---------------------------------------------------------× *
* /*  +198×TOTAL BYTES IN ALL KEYWORD WITH VALUE PARMS              × *
* /*      ×---------------------------------------------------------× *
* /*  +200×WORK AREA                                                × *
* /*      ×---------------------------------------------------------× *
* /*  +202×SWITCHES                                                 × *
* /*      ×  BIT 0 - SET TO ONE WHEN PROCEESING IMPLICIT EXEC       × *
* /*      ×  BIT 1 - SET TO ONE WHEN E03 IS CALLED TO READ FIRST    × *
* /*      ×          LINE OF PROC                                   × *
* /*      × BIT 2 -  SET TO ONE IF PROCEDURE HAS NO PROC STATEMENT  × *
* /*      × BIT 3  - SET TO ONE IF NO PROC STMT AND FIRST LINE OF   × *
* /*      ×          PROC IS NOT EMPTY                              × *
* /*      × BIT 4 - SET TO ONE WHEN AN ABEND HAS OCCURRED           × *
* /*      × BIT 5 - SET TO ONE WHEN THE PROMPT OPTION WAS           × *
* /*      ×         SPECIFIED ON THE INVOCATION STATEMENT           × *
* /*      × BIT 6 - SET TO ONE WHEN E03 IS CALLED TO READ A RCD     × *
* /*      ×         OTHER THAN THE FIRST                            × *
* /*      × BIT 7 - SET TO ONE IF RECORD FORMAT IS VARIABLE         × *
* /*      × BIT 8 - TERMINATION SWITCH (SET TO ONE IF PROC IS       × *
* /*      ×         NON-EXECUTABLE)                                 × *
* /*      × BIT 9 - SET TO ONE IF E03 HAS BEEN CALLED FOR A GETMAIN × *
* /*      × BIT 10 - SET TO ONE WHEN DATA SET  IS NULL              × *
* /*      × BIT 11 - SET TO ONE WHEN CORE HAS BEEN OBTAINED FROM    × *
* /*      ×          SUBPOOL 78                                     × *
* /*      × BIT 12 - SET TO ONE WHEN E03 HAS BEEN CALLED TO DO A    × *
* /*      ×          FREEMAIN                                       × *
* /*      × BIT 13 - UNUSED                                         × *
* /*      × BIT 14 - SET TO ONE WHEN THE MINIMUM AMOUNT OF CORE     × *
* /*      ×          NEEDED COULD NOT BE OBTAINED                   × *
* /*      × BIT 15 - SET TO ONE WHEN THE LIST OPTION WAS SPECIFIED  × *
* /*      ×          ON THE INVOCATION STATEMENT                    × *
* /*      ×---------------------------------------------------------× *
* /*  +204×WORK AREA                                                × *
* /*      ×---------------------------------------------------------× *
* /*  +216×POINTER TO CURRENT ATAB ELEMENT - 1                      × *
* /*      ×---------------------------------------------------------× *
* /*  +220×POINTER TO FTAB ELEMENT - 1                              × *
* /*      ×---------------------------------------------------------× *
* /*  +224×POINTER TO FIRST INPUT BUFFER                            × *
* /*      ×---------------------------------------------------------× *
* /*  +228×POINTER TO SECOND INPUT BUFFER                           × *
* /*      ×---------------------------------------------------------× *
* /*  +232×POINTER TO CMD PROCESSOR PARAMETER LIST                  × *
* /*      ×---------------------------------------------------------× *
* /*  +236×PARAMETERS TO BE PASSED TO STAE EXIT ROUTINE             × *
* /*      ×---------------------------------------------------------× *
* /*  +248×POINTER TO PARSE CONTROL LIST                            × *
* /*      ×---------------------------------------------------------× *
* /*  +252×STORAGE FOR SERVICE ROUTINE CONTROL BLOCK                × *
* /*      ×---------------------------------------------------------× *
* /*  +276×ECB FOR SERVICE ROUTINES                                 × *
* /*      ×---------------------------------------------------------× *
* /*  +280×AREA FOR HOLDING RETURN CODES INTERNAL TO EXEC           × *
* /*      ×---------------------------------------------------------× *
* /*  +284×POINTER TO FIRST BLOCK OF ATAB                           × *
* /*      ×---------------------------------------------------------× *
* /*  +288×END OF CURRENT INPUT BLOCK + 1                           × *
* /*      ×---------------------------------------------------------× *
* /*  +292×POINTER TO START OF RECORD CURRENTLY BEING PROCESSED     × *
* /*      ×---------------------------------------------------------× *
* /*  +296×LENGTH OF DYNAMIC PORTION OF MSG TO BE PUT TO TERMINAL   × *
* /*      ×---------------------------------------------------------× *
* /*  +297×ADDRESS OF DYNAMIC PORTION OF MSG TO BE PUT TO TERMINAL  × *
* /*      ×---------------------------------------------------------× *
* /*  +300×NUMBER OF FIRST LEVEL MSG TO BE PUT TO TERMINAL          × *
* /*      ×---------------------------------------------------------× *
* /*  +302×NUMBER OF SECOND LEVEL MSG TO BE PUT TO TERMINAL         × *
* /*      ×---------------------------------------------------------× *
* /*  +304×POINTER TO THE PARSE DESCRIPTOR LIST                     × *
* /*      ×---------------------------------------------------------× *
* /*  +308×AREA FOR SAVING THE ORIGINAL LENGTH OF THE COMMAND BUFFER× *
* /*      ×---------------------------------------------------------× *
* /*  +310×TOTAL BYTES IN ALL POSITIONAL PARAMETERS                 × *
* /*      ×---------------------------------------------------------× *
* /*  +312××                                                          *
* /*                                                                  *
* /*  ATTRIBUTES --                                                   *
* /*     REENTRANT                                                    *
* /*                                                                  *
* /*  NOTES --                                                        *
* /*     CONSTANTS BEGIN WITH THE LETTERS 'KON' FOLLOWED BY THE VALUE *
* /*     OF THE CONSTANT IF IT IS EITHER A DECIMAL OR EBCDIC CONSTANT *
* /*     IF IT IS A HEX CONSTANT THE 'KON' IS FOLLOWED BY 'X' AND     *
* /*     THEN THE VALUE OF THE CONSTANT.                              *
* /*     CHARACTER CODE DEPENDENCIES --                               *
* /*        MODULE WAS ASSEMBLED USING EBCIDIC CHARACTER CODE.        *
* /*        MODULE MUST BE MODIFIED IF A DIFFERENT CHARACTER          *
* /*        SET IS USED. DEPENDENCIES EXIST FOR FOLLOWING             *
* /*        CHARACTERISTICS OF EBCIDIC:                               *
* /*           1.ZONED DECIMALS HAVE 'F'X IN THE HIGH ORDER           *
* /*                  HALF BYTE                                       *
* /*           2.CONVERSION FROM 'FA'X-'FF'X TO 'A'-'F' CAN BE        *
* /*                  EFFECTED VIA SUBTRACTION OF 57.                 *
* /*        STATEMENTS WHICH CONTAIN THESE DEPENDENCIES WILL HAVE     *
* /*        ASTERISKS IN THEIR COMMENT FIELDS.                        *
* /********************************************************************
*         GEN;
&SPN     SETA  1
         DS    0H
*         DCL   DUMPARM        FIXED(31);      /* DUMMY PARM DECLARED *
*                                              /* SO BSL WILL NOT USE *
*                                              /*  REGISTER 1         *
*         DCL   R1   REG(1)    PTR(31);        /*  REGISTER 1         *
*         DCL   R2   REG(2)    PTR(31);        /*  REGISTER 2         *
*         DCL   R3   REG(3)    PTR(31);        /*  REGISTER 3         *
*          DCL   R5   REG(5)    PTR(31);      /*   REGISTER 5         *
*         DCL   R6   REG(6)    PTR(31);        /*  REGISTER 6         *
*         DCL   R15  REG(15)   PTR(31);        /*  REGISTER 15        *
*         DCL 1  E01DATDF  BDY(DWORD)         /* MAJOR STRUCTURE OF   *
*                            BASED(R6),       /*   USED BY ALL FOUR   *
*                                             /*   MODULES            *
*                2 DCBAR     CHAR(88)  BDY(DWORD),
*                                                  /* LIVE DCB AREA   *
*
*                2 ADPTR1    PTR(31),              /* PTR USED FOR
*                                                      INDIRECT ADDRS *
*                2 ADPTR2    PTR(31),               /* FOR INDIRECT
*                                                         ADDRESSING  *
*                2 MMNAMAR   BDY(WORD) CHAR(8),
*                                                  /* MEMBER NAME     *
*                2  RDECB   BDY(WORD) CHAR(20),
*                                                  /* STORAGE FOR DECB*
*                   3 *        CHAR(6),        /* FILLER              *
*                   3 DECLNGTH FIXED(15),      /* LENGTH OF BLOCK READ*
*                   3 *        CHAR(8),        /* FILLER              *
*                   3 DECIOBPT PTR(31),        /* POINTER TO THE IOB  *
*                2 LINPTR1   PTR(31),              /* ADDR OF INPUT   *
*                2 EOLCNT    FIXED(31),            /* BYTES REMAINING
*                                                       IN   LINE     *
*                2 POSCNT    FIXED(31),      /* NUMBER OF POSITIONAL
*                                                PARAMETERS FOUND     *
*                2 TSTLNG    FIXED(31),      /* WORK AREA - USED FOR */
*                  3 TSTLNGC   CHAR(4),       /*  ALIGNING TABLE ENTRY*
*                2 GMNMIN    FIXED(31),      /* MINIMUM AMOUNT OF CORE
*                                                 TO BE GOTTEN        *
*                2 GMNMAX    FIXED(31),      /* MAXIMUM AMOUNT OF CORE
*                                                 TO BE GOTTEN        *
*                2 ADDGMN    PTR(31),        /* ADDRESS OF GOTTEN CORE*
*                2 AMTGMN    FIXED(31),      /*  AMOUNT OF CORE GOTTEN*
*                2 SP78ADDR  PTR(31),        /* PTR TO SUBPOOL78 CORE*/
*                2 SP78LNGT  PTR(31),        /* LENGTH OF SUBPOOL78  */
*                                            /*   CORE               */
*                2 RDXCNV  FIXED(31),        /* WORK AREA FOR        */
*                  3  *              CHAR(3),      /*  CONVERTING BASE*
*                  3  DDIG           CHAR(1),      /* OF NO. PARMS    *
*                2 POSSPC    FIXED(31),      /* NUMBER OF POSITIONAL
*                                                  PARAMERS SPECIFIED *
*                2 ATABIND   PTR(31),        /*  PTR TO START OF
*                                                      CURRENT BLOCK OF
*                                                      ATAB           *
*                2 ATABCUR   PTR(31),        /*  PTR TO CURRENT
*                                                      ELEMENT OF ATAB*
*                2 FTABIND   PTR(31),        /*  PTR TO START OF
*                                                     CURRENT BLOCK OF
*                                                     FTAB            *
*                2 FTABCUR   PTR(31),        /*  PTR TO CURRENT
*                                                     ELEMENT OF ATAB *
*                2 VALCNT    FIXED(31),      /*     NUMBER OF BYTES IN
*                                                     VALUE OF KEYWORD
*                                                     WITH VALUE      *
*                2 KWOCNT    FIXED(15),       /* NUMBER OF KWRD W/O   *
*                                             /*   VALUE PARMS        *
*                2 KWWCNT    FIXED(15),       /* NUMBER OF KWRD WITH  *
*                                             /*   VALUE PARMS        *
*                2 KWOBYT    FIXED(15),       /*   SIZE OF KWRD W/O   *
*                                             /*   VALUE PARMS        *
*                2 KWWBYT    FIXED(15),       /*   SIZE OF KWRD W/O   *
*                                             /*   VALUE PARMS        *
*                2 CNVA   FIXED(15),          /*WORKAREA FOR UNALIGNED*
*                  3 CNVC   CHAR(2),          /*  ARITHMETIC ITEMS    *
*                2 E01BINSW BDY(HWORD),       /*  BINARY SWITCHES     *
*                  3 E01SW1 BIT(1),           /* SWITCH 1             *
*                                             /* SET TO ONE WHEN
*                                                      PROCESSING
*                                                       IMPLICIT EXEC *
*                  3 E01SW2 BIT(1),            /* SWITCH 2            *
*                                              /* SET TO ONE WHEN
*                                                      IKJEFE03 IS CALL
*                                                       ED TO READ 1ST
*                                                        LINE         *
*                  3 E01SW3 BIT(1),             /* SWITCH 3           *
*                                               /*SET TO ONE IF THE
*                                                     PROCEDURE DOES
*                                                      NOT HAVE A PROC
*                                                       STATEMENT     *
*                  3 E01SW4 BIT(1),              /* SWITCH 4          *
*                                                /*SET TO ONE IF 1ST
*                                                     LINE IS NOT EMPTY
*                                                                     *
*                  3 E01SW5 BIT(1),              /* SWITCH 5          *
*                                                /*SET TO ONE ON AN
*                                                     ABEND           *
*                  3 E01SW6 BIT(1),              /* SWITCH 6          *
*                                                /*SET TO ONE WHEN
*                                                     THE PROMPT OPTION
*                                                      WAS SPECIFIED ON
*                                                      THE INVOCATION
*                                                       STATEMENT     *
*                  3 E01SW7 BIT(1),              /* SWITCH 7          *
*                                                /*SET TO ONE WHEN
*                                                   IKJEFE03 IS CALL-
*                                                      ED TO READ LINE
*                                                       OTHER THAN 1ST*
*                  3 E01SW8 BIT(1),              /* SWITCH 8          *
*                                                /*SET TO ONE IF RCD
*                                                     FMT IS VARIABLE *
*                  3 E01SW9 BIT(1),              /* SWITCH 9          *
*                                                /*SET TO ONE IF PROC
*                                                     CANNOT BE EXECUT-
*                                                      ED             *
*                  3 E01SW10 BIT(1),             /* SWITCH 10         *
*                                                /* SET TO ONE WHEN
*                                                     IKFEFE03 HAS BEEN
*                                                     CALLED TO DO A
*                                                     GETMAIN         *
*                  3 E01SW11 BIT(1),             /* SWITCH 11         *
*                                                /*SET TO ONE WHEN
*                                                     DATA SET HAS BEEN
*                                                        CLOSED       *
*                  3 E01SW12 BIT(1),             /* SWITCH 12         *
*                                                /*SET TO ONE WHEN
*                                                     CORE HAS BEEN
*                                                      OBTAINED FROM SP
*                                                       78            *
*                  3 E01SW13 BIT(1),             /* SWITCH 13         *
*                                                /* SET TO ONE WHEN
*                                                     IKFEFE03 HAS BEEN
*                                                     CALLED TO DO A
*                                                     FREEMAIN        *
*                  3 E01SW14 BIT(1),             /* SWITCH 14         *
*                                                /*SET TO ONE WHEN
*                                                     SP78 OVFLOW HAS
*                                                      CAUSED SP0 TO BE
*                                                        OBTAINED     *
*                  3 E01SW15 BIT(1),          /* SET TO ONE WHEN THE  *
*                                             /* MINIMUM AMT OF CORE  *
*                                             /*   COULD NOT BE GOTTEN*
*                  3 E01SW16 BIT(1),             /* SWITCH 16         *
*                2 REGSAV(3) FIXED(31),          /* SAVE AREA         *
*                2 LATAB   PTR(31),              /* PTR TO PREVIOUS ATA
*                                                ELEMENT              *
*                2 LFTAB   PTR(31),           /* PTR TO PREVIOUS FTAB
*                                                ELEMENT              *
*                2 BFAPTR  FIXED(31),         /* POINTER TO INPUT BFR *
*                2 BFBPTR  PTR(31),           /* POINTER TO INPUT BFR *
*                2 CPPLPTR   PTR(31),         /*  ADDRESS OF CPPL     *
*                2 STPRM(3)  FIXED(31),
*                2 PPLPTR PTR(31),            /* POINTER TO CONTROL   *
*                2 CBCOR CHAR(24),            /* STORAGE FOR SERVICE  *
*                                             /*  ROUTINE CONTROL BLCK*
*                                             /*   BLOCK FOR SERVICE  *
*                                             /*   ROUTINES           *
*                                             /*     TOR LIST         *
*                2 SRECB  FIXED(31),          /*   SERV ROUT ECB      *
*                2 RETCDAR   FIXED(31),       /*    AREA FOR RETURN   *
*                                             /*      CODE            *
*               2 ABLK1     PTR(31),         /* PTR TO FIRST BLOCK    *
*                                            /*   OF ATAB            */
*                2 EOB       PTR(31),         /* END OF CURRENT INPUT *
*                                             /*   BLOCK + 1          *
*                2 RCDST     PTR(31),         /* PTR TO START OF CUR- *
*                                             /*   RENT RECORD        *
*                2 VARSGLNG  CHAR(1),         /* LENGTH OF VARIABLE   *
*                2 VARSGADR  PTR(24),         /* ADDRESS OF VARIABLE  *
*                2 VARSGLN2  CHAR(1),         /*  LENGTH OF VARIABLE  *
*                                             /*    PART OF MSG TO BE *
*                                             /*    PUT OUT           *
*                2 VARSGAD2  PTR(24),         /*  ADDRESS OF VARIABLE *
*                                             /*    PART OF MSG TO BE *
*                                             /*    PUT OUT           *
*                2 LVL1NO    FIXED(15),       /* NUMBER OF FIRST LEVEL*
*                                             /*   MESSAGE            *
*                2 LVL2NO    FIXED(15),       /*NUMBER OF SECOND LEVEL*
*                                             /*    MESSAGE           *
*                2 PDLPTR    PTR(31),         /* POINTER TO THE PARSE *
*                                             /*   DESCRIPTOR LIST    *
*               2 DRDNPTR BDY(WORD),          /* AREA FOR DSNAME      *
*                 3 DSNARLNG FIXED(15),       /* LENGTH OF DSNAME     *
*                   4 DSNARLCH CHAR(2),       /*                      *
*                 3 DSNAMAR  CHAR(44),        /* DSNAME               *
*                2 CBUFLSAV  FIXED(15),       /* SAVE AREA FOR CMD BFR*
*                 3 CBUFLSAC CHAR(2),         /*    LENGTH      Y01676*
*               2 POSBYT FIXED(15);           /* SIZE OF POSITIONAL
*                                                PARAMETERS     Y01676*
*         DCL   PTLNBLCK  CHAR(32)  BDY(WORD);/* AREA FOR PUTLINE     *
*                                             /*   PARAMETER BLOCK    *
*         DCL   PBPTR   PTR(31);              /* POINTER TO PUTLINE   *
*                                             /*   PARAMETER BLOCK    *
*         DCL   1   MSGCHN   BDY(WORD)   BASED(PBPTR),
*                                             /* MAPPING OF PUTLINE   *
*                                             /*   PARAMETER BLOCK    *
*                 2 NXTLVLAD  PTR(31),        /* CONTAINS ADDRESS OF  *
*                                             /*  2ND LEVEL OF CHAIN  *
*                 2 SEGCNT    FIXED(31),      /* NUMBER OF SEGMENTS IN*
*                                             /*   THIS LEVEL         *
*                 2 SEG1ADR   PTR(31),        /* ADDRESS OF 1ST       *
*                                             /*   SEGMENT            *
*                 2 SEG2ADR   PTR(31),        /* ADDRESS OF 2ND       *
*                 2 SEG3ADR   PTR(31);        /* ADDRESS OF 3RD       *
*         DCL   ADTABPTR  PTR(31);            /* POINTER USED IN      *
*                                             /*  REFERENCING THE     *
*                                             /*   ADDRESS TABLES     *
*         DCL   1   ADTABDUM BDY(WORD)   BASED(ADTABPTR),
*                                             /* MAPPING OF AN ELEMENT*
*                                             /*   OF AN ADDRESS TABLE*
*                 2 MSGN02    CHAR(1),        /* NUMBER OF THE ENTRY  *
*                                             /*  IN THE TABLE OF 2ND *
*                                             /*  LEVEL MSGS WHICH IS *
*                                             /*  THE FIRST POSSIBLE  *
*                                             /*  FOR THIS 1ST LEVEL  *
*                                             /*  MESSAGE             *
*                 2 MSGPTR    PTR(24);        /* ADDRESS OF THE       *
*                                             /*  MESSAGE FOR THIS    *
*                                             /*   ENTRY              *
*         DCL   DYNMSG1 CHAR(260);            /* 1ST LEVEL DYN SGMT   *
*         DCL   DYNMSG2 CHAR(260) BDY(DWORD); /* 2ND LEVEL DYN SGMT   *
*         DCL   DYNMSGPT  PTR(31);            /* PTR TO DYN MSG AREA  *
*         DCL   1 DYNMSGAR BASED(DYNMSGPT),   /* AREA USED FOR HOLDING*
*                                             /*  THE DYNAMIC SEGMENT *
*                                             /*  OF THE MESSAGE      *
*                 2 DYNLNG    FIXED(15),      /* LENGTH OF THE SEGMENT*
*                   3 DYNLNGC1    CHAR(1),    /*REDEFINITION OF LENGTH*
*                   3 DYNLNGC2    CHAR(1),    /*   FOR ALIGNMENT      *
*                 2 DYNOFF    FIXED(15),      /* OFFSET OF THE SEGMENT*
*
*                   3 DYNOFFCH    CHAR(2),    /* REDEFINITION AS CHARS*
*                 2 DYNTXT    CHAR(256);      /* STORAGE FOR THE      *
*                                             /*   ACTUAL TEXT        *
*         DCL   1 MSGTXDUM      BASED(SEG1ADR),
*                                             /* MAPPING OF A MESSAGE *
*                                             /*   SEGMENT            *
*                 2 MSGTXLNG  CHAR(2),        /* LENGTH OF THE SEGMENT*
*                 2 *         CHAR(2),        /* OFFSET OF THE SEGMENT*
*                 2 MSGTX     CHAR(1);        /* DUMMY OF TEXT        *
*         DCL   1 MAXMSGLN  FIXED(15)   AUTO, /* WORK AREA FOR CALC.  *
*                 2 MAXMSGCH  CHAR(2);        /*  MAX SIZE OF DYNAMIC *
*                                             /*  PORTION OF MESSAGE  *
*         DCL   1 HOLNG     FIXED(15)   AUTO, /* WORK AREA FOR CALC.  *
*                 2 HOLNGC    CHAR(2);        /*  OFFSETS  OF DYNAMIC *
*                                             /*  PORTION OF MESSAGE  *
*         DCL   1 KONFF0  FIXED(31)  STATIC,  /* CONSTANT USED IN PUT-*
*                 2 KONFFC  CHAR(4)           /*  LINE PARM BLOCK     *
*                              INIT('FF000000'X);
*         DCL   VARSEG    CHAR(256)  BASED(VARSGADR);
*                                             /* DSECT OF DYNAMIC PART*
*                                             /*  OF MSG AS PASSED TO *
*                                             /*  THIS MODULE         *
*         DCL   DAPLPTR   PTR(31)   BASED(ADDR(PPLPTR));
*                                             /* POINTER TO THE SERVICE
*                                                ROUTINE PARM BLOCK   *
** /* *************************************************************** *
** /* THE DYNAMIC ALLOCATION INTERFACE ROUTINE (DAIR) PARAMETER LIST  *
** /* (DAPL) IS A LIST OF ADDRESSES PASSED FROM THE INVOKER TO DAIR   *
** /* VIA REGISTER 1                                                  *
** /* *************************************************************** *
** DECLARE
**   1 DAPL      BASED(DAPLPTR),
**
**
**
**
**
**
**
**
**
**
**    2 DAPLUPT  PTR(31),             /* PTR TO UPT                   *
**    2 DAPLECT  PTR(31),             /* PTR TO ECT                   *
**    2 DAPLECB  PTR(31),             /* PTR TO CP'S ECB              *
**    2 DAPLPSCB PTR(31),             /* PTR TO PSCB                  *
**    2 DAPLDAPB PTR(31);             /* PTR TO DAIR PARAMETER BLOCK  *
*         DCL   DAPB0PTR  PTR(31)   BASED(ADDR(DAPLDAPB));
*                                             /* POINTER TO DAIR PARM
*                                                BLOCK                *
** DECLARE
**   1 DAPB08    BASED(DAPB0PTR),
** /* *************************************************************** *
** /* S OPERATION CODE CAUSES ALLOCATION OF A DATA SET. IT CAN ALLOC. *
** /* HER A NEW OR OLD SET.                                           *
** /* *************************************************************** *
**    2 DA08CD   CHAR(2),             /* DAIR ENTRY CODE              *
**    2 DA08FLG  CHAR(2),            /* FUNCTIONS PERFORMED WHEN
**                                       RETURN CODE= 0               *
**     3 DA08FPE  BIT(1),             /* FUNCT PERFORMED BUT ERROR
**                                       INDICATED BY RETCD           *
**     3 *        BIT(1),             /* RESERVED                     *
**     3 *        BIT(1),             /* RESERVED                     *
**     3 *        BIT(1),             /* RESERVED                     *
**     3 *        BIT(1),             /* RESERVED                     *
**     3 *        BIT(1),             /* RESERVED                     *
**     3 *        BIT(1),             /* RESERVED                     *
**     3 *        BIT(1),             /* RESERVED                     *
**    2 DA08DARC FIXED(15),           /*DYN  ALLOC                    *
**    2 DA08CTRC FIXED(15),           /* CATALOG RETURN CODE          *
**    2 DA08PDSN PTR(31),             /* POINTER TO DSNAME TO BE
**                                       SEARCHED IN DSE              *
**    2 DA08DDN  CHAR(8),             /* DDNAME TO BE SEARCHED IN DSE *
**    2 DA08UNIT CHAR(8),             /* UNITNAME REQUESTED           *
**    2 DA08SER  CHAR(8),             /* VOLUME SERIAL NUMBER-PADDED
**                                       W/BLANKS                     *
**    2 DA08BLK  CHAR(4),             /* DATA SET                     *
**    2 DA08PQTY CHAR(4),             /* PRIMARY SPACE QUANTITY       *
**    2 DA08SQTY CHAR(4),             /* SECONDARY SPACE QUANTITY     *
**    2 DA08DQTY CHAR(4),             /* DIRECTORY BLOCK QUANTITY     *
**    2 DA08MNM  CHAR(8),             /* MEMBER NAME                  *
**    2 DA08PSWD CHAR(8),             /* PASSWORD                     *
**    2 DA08DSP1 CHAR(1),             /* DATA SET STATUS FLGS(IF=0
**                                       OLD ASSUMED)                 *
**     3 *        BIT(1),             /* RESERVED                     *
**     3 *        BIT(1),             /* RESERVED                     *
**     3 *        BIT(1),             /* RESERVED                     *
**     3 *        BIT(1),             /* RESERVED                     *
**     3 DA08SHR  BIT(1),             /* DATA SET IS SHR              *
**     3 DA08NEW  BIT(1),             /* DATA SET IS NEW              *
**     3 DA08MOD  BIT(1),             /* DATA SET IS MOD              *
**     3 DA08OLD  BIT(1),             /* DATA SET IS OLD              *
**    2 DA08DPS2 CHAR(1),             /* DATA SET DISPOSITION(IF=0
**                                       KEEP ASSUMED)                *
**     3 *        BIT(1),             /* RESERVED                     *
**     3 *        BIT(1),             /* RESERVED                     *
**     3 *        BIT(1),             /* RESERVED                     *
**     3 *        BIT(1),             /* RESERVED                     *
**     3 DA08KEEP BIT(1),             /* DS DISP IS KEEP              *
**     3 DA08DEL  BIT(1),             /* DS DISP IS DELETE            *
**     3 DA08CAT  BIT(1),             /* DS DISP IS CATLG             *
**     3 DA08UCAT BIT(1),             /* DS DISP IS UNCATALOG         *
**    2 DA08DPS3 CHAR(1),             /* DATA SET CONDITIONAL
**                                       DISPOSITION                  *
**     3 *        BIT(1),             /* RESERVED                     *
**     3 *        BIT(1),             /* RESERVED                     *
**     3 *        BIT(1),             /* RESERVED                     *
**     3 *        BIT(1),             /* RESERVED                     *
**     3 DA08KEP  BIT(1),             /* DS DISP OF KEEP DESIRED      *
**     3 DA08DELE  BIT(1),
**     3 DA08CATL  BIT(1),
**     3 DA08UNCT  BIT(1),
**    2 DA08CTL  CHAR(1),             /* FLAGS TO CONTROL ACTIONS
**                                       TAKEN BY DAIR                *
**     3  DA08TRKS  BIT(1),             /*SPACE UNITS REQUESTED       *
**     3  DA08ABKL  BIT(1),
**     3  DA08UID  BIT(1),
**     3  DA08RLSE BIT(1),
**     3  DA08PERM BIT(1),
**     3  DA08DMMY BIT(1),
**     3  DA08ATRL BIT(1),              /*ATTR LIST SUPPLIED    C99236*
**     3  *  BIT(1),                    /*                      C99236*
**    2 *        CHAR(3),             /* RESERVED                     *
**    2 DA08DSO  CHAR(1),             /* DSORG                  C99236*
**    2 DA08ALN  CHAR(8);             /* ATTR-LIST-NAME         C99236*
**
*         DCL   KON0      FIXED(15)   STATIC  INIT(0);
*                                             /* CONSTANT OF ZERO     *
*         DCL   KON1      FIXED(15)   STATIC  INIT(1);
*                                             /* CONSTANT OF ONE      *
*         DCL   KON2      FIXED(15)   STATIC  INIT(2);
*                                             /* CONSTANT OF TWO      *
*          DCL   KON3      FIXED(15)   STATIC  INIT(3);
*                                             /* CONSTANT OF 3        *
*         DCL   KON4      FIXED(15)   STATIC  INIT(4);
*                                             /* CONSTANT OF FOUR     *
*          DCL   KON5      FIXED(15)   STATIC  INIT(5);
*                                             /* CONSTANT OF 5        *
*         DCL   KON8      FIXED(15)   STATIC  INIT(8);
*                                             /* CONSTANT OF ONE      *
*         DCL   KON12      FIXED(15)   STATIC  INIT(12);
*                                             /* CONSTANT OF TWELVE   *
*         DCL   KON16     FIXED(15)   STATIC  INIT(16);
*                                             /* CONSTANT OF SIXTEEN  *
*         DCL   KON20     FIXED(15)   STATIC  INIT(20);
*                                             /* CONSTANT OF TWENTY
*         DCL   KON21     FIXED(15)   STATIC  INIT(21);
*                                             /* CONSTANT OF SIXTEEN  *
*         DCL   KON24     FIXED(15)   STATIC  INIT(24);
*                                             /* CONSTANT OF 24       *
*         DCL   KON25     FIXED(15)   STATIC  INIT(25);
*                                             /* CONSTANT OF 25       *
*         DCL   KON27     FIXED(15)   STATIC  INIT(27); /* CONSTANT
*                                                OF  DECIMAL 27 Y01676*
*         DCL   KON57  FIXED(15)  STATIC  INIT(57);
*         DCL   KON256    FIXED(15)   STATIC  INIT(256);
*                                             /* CONSTANT OF 256      *
*         DCL   KONX00    CHAR(2)     STATIC  INIT('0000'X);
*                                             /* CONSTANT OF ZERO     *
*         DCL   KONX06    CHAR(1)     STATIC  INIT('06'X);
*                                             /* CONSTANT OF SIX      *
*         DCL   KONXF0    CHAR(1)     STATIC  INIT('F0'X);
*                                             /* CONSTANT OF HEX F0   *
*         DCL   KONXF9    CHAR(1)     STATIC  INIT('F9'X);
*                                             /* CONSTANT OF HEX F9   *
*         DCL   APLN  GEND  CHAR(256);        /* PUTLINE PARM LIST    *
*      DCL IKJEFE06  ENTRY;
*      DCL ADTAB1 NONLOCAL EXTERNAL;
*      DCL ADTAB2 NONLOCAL EXTERNAL;
*         /************************************************************
*         /*                                                          *
*         /*                   RUNNING CODE                           *
*         /*                                                          *
*         /************************************************************
**/*IKJEFE04: CHART */
**/*HEADER
**/*IKJEFE04
**/*                                                                  *
**/*START: E START */
* /********************************************************************
* /********************************************************************
**/* D (YES,,NO,%D2) DOES MESSAGE HAVE VARIABLE PART? */
**/* P (,%D3) SET SEGMENT COUNT = 2 */
**/*%D2: P SET SEGMENT COUNT = 1 */
**/*%D3:  P SET NEXT LEVEL ADDR IF MORE THAN ONE LEVEL MSG */
**/* D (YES,,NO,E04PBS10:RT) DOES MSG HAVE DYNAMIC TERMS? */
**/* P MOVE DYNAMIC PORTION OF MESSAGE TO OUTPUT AREA */
**/*E04PBS05: P TRUNCATE DYNAMIC PART OF MESSAGE IF LINE LENGTH > MAX
**/*ALLOWED*/
* /********************************************************************
*
*         /************************************************************
*         /*               THE FOLLOWING CODE SETS UP POINTERS        *
*         /************************************************************
*         RESTRICT  (R6);
*         DYNMSGPT = ADDR(DYNMSG1);           /* SET ADDR FOR 1ST LVL *
         LA    @F,DYNMSG1                                         0055
         ST    @F,DYNMSGPT                                        0055
*         R6  = R1;                           /* SET REG6 POINTING TO
*                                                NON-LOCAL DATA       *
         LR    @6,@1                                              0056
* E04MDR05:  ;
*         IF LVL1NO = KON24                   /* CHECK IF THIS IS THE *
*           THEN                              /* SYSTEM ERROR MESSAGE *
E04MDR05 LH    @F,KON24                                           0058
         CH    @F,304(0,@6)                                       0058
         BC    07,@9FF                                            0058
*             DO;                             /* IF SO - INDICATE THE *
*               VARSGLN2 = KONX06;            /* DYNAMIC PORTION'S    *
         MVC   300(1,@6),KONX06                                   0060
*               VARSGAD2 = ADDR(CNVA);        /* LENGTH AND ADDRESS   *
         LA    @F,200(0,@6)                                       0061
         ST    @F,@TEMP4                                          0061
         MVC   301(3,@6),@TEMP4+1                                 0061
*               VARSGLNG = KONX00;            /* NO 1ST LVL VAR PART  *
         MVC   296(1,@6),KONX00                                   0062
*               GOTO E04MIS10;                /* AND GO TO CONVERT THE*
         BC    15,E04MIS10                                        0063
*             END;                            /* RET. CODE TO EBCIDIC *
*         IF LVL1NO ^= KON0  &                /* IF THE MESSAGE SHOULD*
*            LVL1NO ^= KON20 &                /* NOT HAVE THE MEMBER  *
*            LVL1NO ^= KON21                  /* NAME INSERTED INTO   *
*           THEN                              /* ITS TEXT THEN BYPASS *
@9FF     LH    @F,KON0                                            0065
         CH    @F,304(0,@6)                                       0065
         BC    08,@9FE                                            0065
         LH    @F,KON20                                           0065
         CH    @F,304(0,@6)                                       0065
         BC    08,@9FD                                            0065
         LH    @F,KON21                                           0065
         CH    @F,304(0,@6)                                       0065
*             GOTO E04MDR10;                  /* CODE FOR DOING SO    *
         BC    07,E04MDR10                                        0066
*         VARSGADR = ADDR(MMNAMAR);           /* SAVE ADDRESS OF MEM. *
@9FC     EQU   *                                                  0067
@9FD     EQU   *                                                  0067
@9FE     LA    @F,96(0,@6)                                        0067
         ST    @F,@TEMP4                                          0067
         MVC   297(3,@6),@TEMP4+1                                 0067
*         VARSGLNG = '0C'X;                   /* NAME AND LENGTH      *
         MVI   296(@6),X'0C'                                      0068
*         IF LVL1NO ^= KON0                   /* IF THERE SHOULD ALSO *
*           THEN                              /* BE A DATA SET NAME   *
         LH    @F,KON0                                            0069
         CH    @F,304(0,@6)                                       0069
         BC    08,@9FB                                            0069
*             DO;                             /* IN THE MESSAGE SAVE  *
*               VARSGAD2 = ADDR(DSNAMAR);     /* ITS ADDRESS AND      *
         LA    @F,314(0,@6)                                       0071
         ST    @F,@TEMP4                                          0071
         MVC   301(3,@6),@TEMP4+1                                 0071
*               VARSGLN2 = DSNARLNG + KON4;   /* LENGTH               *
         LH    @F,KON4                                            0072
         AH    @F,312(0,@6)                                       0072
         STC   @F,300(0,@6)                                       0072
*             END;
*         GOTO E04PBS02;                      /* BYPASS MSG. NUMBER
*                                                DETERMINATION CODE   *
         BC    15,E04PBS02                                        0074
* E04MDR10:   ;
*         IF LVL1NO ^< KON5 & LVL1NO ^= KON25 /* IF MESSAGE NO. HAS   *
*           THEN                              /* ALREADY BEEN FINALLY *
E04MDR10 LH    @F,KON5                                            0076
         CH    @F,304(0,@6)                                       0076
         BC    02,@9FA                                            0076
         LH    @F,KON25                                           0076
         CH    @F,304(0,@6)                                       0076
*             GOTO E04PBS02;                  /* DETERMINED - BYPASS
*                                                THE MESSAGE NUMBER
*                                                DETERMINATION CODE   *
         BC    07,E04PBS02                                        0077
*         IF LVL1NO = KON2 ×                  /* IF THIS IS A MESSAGE *
*            LVL1NO = KON3                    /* CONCERNING DATA SET  *
*           THEN                              /* PROCESSING AND IT IS *
@9F9     EQU   *                                                  0078
@9FA     LH    @F,KON2                                            0078
         CH    @F,304(0,@6)                                       0078
         BC    08,@9F8                                            0078
         LH    @F,KON3                                            0078
         CH    @F,304(0,@6)                                       0078
         BC    07,@9F7                                            0078
*             IF E01SW1 = '1'B                /* AN IMPLICIT EXEC THEN*
*               THEN                          /* ALTER THE NUMBER OF  *
@9F8     TM    202(@6),B'10000000'                                0079
         BC    12,@9F6                                            0079
*                 DO;                         /* THE MESSAGE SO THAT  *
*                   LVL1NO = LVL1NO + KON20;  /* 'FILE' WILL BE       *
         LH    @F,KON20                                           0081
         AH    @F,304(0,@6)                                       0081
         STH   @F,304(0,@6)                                       0081
*                   VARSGLNG = KONX00;        /*(NO 1ST LVL VAR PART) *
         MVC   296(1,@6),KONX00                                   0082
*                   GOTO E04PBS02;            /* PRINTED AND BYPASS   *
         BC    15,E04PBS02                                        0083
*                 END;                        /* MSG. NO. DETERMINATION
*                                                CODE                 *
*         VARSGADR = ADDR(DSNAMAR);           /* POINT TO DSNAME TO BE*
@9F6     EQU   *                                                  0085
@9F7     LA    @F,314(0,@6)                                       0085
         ST    @F,@TEMP4                                          0085
         MVC   297(3,@6),@TEMP4+1                                 0085
*         VARSGLNG = DSNARLNG + KON4;         /* INSERTED AND SAVE IT'S
*                                                LENGTH               *
         LH    @F,KON4                                            0086
         AH    @F,312(0,@6)                                       0086
         STC   @F,296(0,@6)                                       0086
*         GO TO E04PBS02;                     /* BYPASS DECIMAL CONV. *
         BC    15,E04PBS02                                        0087
* E04MIS10:           ;
*          RESTRICT (R2);
*          R2 = CNVA;                         /* PUT NO. TO BE CONVERTE
*                                                INTO REG. 2          *
E04MIS10 LH    @2,200(0,@6)                                       0090
*          GEN;
          CVD   R2,DYNMSG2          CHANGE RADIX TO 10
          UNPK  DYNMSG2+4(2),DYNMSG2+6(2)  CHANGE TO ZONED DEC.
         DS    0H
*          DYNMSG2(6) = DYNMSG2(6) × KONXF0;  /************************
         OC    DYNMSG2+5(1),KONXF0                                0092
*          VARSGAD2 = ADDR(DYNMSG2) + KON4;
         LH    @F,KON4                                            0093
         LA    @0,DYNMSG2                                         0093
         AR    @F,@0                                              0093
         ST    @F,@TEMP4                                          0093
         MVC   301(3,@6),@TEMP4+1                                 0093
*          RELEASE (R2,R5);
*         /************************************************************
*         /*              THE FOLLOWING CODE INITIALIZES              *
*         /*              THE PUTLINE PARAMETER BLOCK FOR             *
*         /*              THE FIRST LEVEL MESSAGE                     *
*         /*              IT ALSO DETERMINES WHICH SECOND             *
*         /*              LEVEL MSG SHOULD BE PUT OUT IF THE          *
*         /*              CAUSE OF THE MSG IS ALLOCATION FAILURE      *
*         /************************************************************
* E04PBS02: PBPTR = ADDR(PTLNBLCK);           /* INITIALIZE PTR TO
*                                                PUTLINE PARM BLOCK   *
E04PBS02 LA    @F,PTLNBLCK                                        0095
         ST    @F,PBPTR                                           0095
*         IF  VARSGLNG = KONX00               /* IF THERE IS NO VAR-  *
*           THEN                              /*  PORTION - SET NO. OF*
         CLC   296(1,@6),KONX00                                   0096
         BC    07,@9F5                                            0096
*             SEGCNT = KON1;                  /*  SEGMENTS TO 1       *
         LH    @F,KON1                                            0097
         L     @7,PBPTR                                           0097
         ST    @F,4(0,@7)                                         0097
         BC    15,@9F4                                            0098
*           ELSE                              /*  OTHERWISE CHECK IF  *
*             IF LVL1NO = KON20 ×             /*  THIS IS A MESSAGE   *
*                LVL1NO = KON21 ×             /*  WHICH HAS TWO Y01676*
*                LVL1NO = KON27               /* DYNAMIC        Y01676*
*               THEN                          /*  PORTIONS IN 1ST LVL *
@9F5     LH    @F,KON20                                           0098
         CH    @F,304(0,@6)                                       0098
         BC    08,@9F3                                            0098
         LH    @F,KON21                                           0098
         CH    @F,304(0,@6)                                       0098
         BC    08,@9F2                                            0098
         LH    @F,KON27                                           0098
         CH    @F,304(0,@6)                                       0098
         BC    07,@9F1                                            0098
*                 SEGCNT = KON3;              /*  IF SO SET COUNT = 3 *
@9F2     EQU   *                                                  0099
@9F3     LH    @F,KON3                                            0099
         L     @7,PBPTR                                           0099
         ST    @F,4(0,@7)                                         0099
         BC    15,@9F0                                            0100
*               ELSE                          /*  OTHERWISE SET THE   *
*                 SEGCNT = KON2;              /*   COUNT TO 2         *
@9F1     LH    @F,KON2                                            0100
         L     @7,PBPTR                                           0100
         ST    @F,4(0,@7)                                         0100
*         IF  LVL2NO ^= KON0                  /* IF THERE IS A SECOND *
*           THEN                              /*  LEVEL MSG SET SECOND*
@9F0     EQU   *                                                  0101
@9F4     LH    @F,KON0                                            0101
         CH    @F,306(0,@6)                                       0101
         BC    08,@9EF                                            0101
*             DO;                             /*  LEVEL PTR IN PARM   *
*               NXTLVLAD = ADDR(PTLNBLCK) + KON8 + KON4 * SEGCNT;
         L     @7,PBPTR                                           0103
         L     @E,4(0,@7)                                         0103
         MH    @E,KON4                                            0103
         AH    @E,KON8                                            0103
         LA    @0,PTLNBLCK                                        0103
         AR    @E,@0                                              0103
         ST    @E,0(0,@7)                                         0103
*                                             /*  LEVEL PTR IN PARM
*                                                 BLOCK               *
*               IF VARSGLN2 = KONX00          /* IF THERE IS NO VARIA-*
*                 THEN                        /* ABLE PORTION - SET # *
         CLC   300(1,@6),KONX00                                   0104
         BC    07,@9EE                                            0104
*                   NXTLVLAD -> SEGCNT = KON1;
         LH    @F,KON1                                            0105
         L     @8,PBPTR                                           0105
         L     @8,0(0,@8)          MSGCHN                         0105
         ST    @F,4(0,@8)                                         0105
         BC    15,@9ED                                            0106
*                 ELSE                        /* OF SEGMNTS TO 1; ELSE*
*                   NXTLVLAD -> SEGCNT = KON2;
@9EE     LH    @F,KON2                                            0106
         L     @8,PBPTR                                           0106
         L     @8,0(0,@8)          MSGCHN                         0106
         ST    @F,4(0,@8)                                         0106
*             END;                            /* NO. OF SEGNENTS TO 2 *
         BC    15,@9EC                                            0108
*           ELSE                              /* OTHERWISE SET PTR TO *
*             NXTLVLAD = KONFF0;              /*  INDICATE NO MORE
*                                                 LEVELS              *
@9EF     L     @7,PBPTR                                           0108
         MVC   0(4,@7),KONFF0                                     0108
*         ADTABPTR  = ADDR(ADTAB1) + KON4 * LVL1NO;
@9EC     LH    @E,304(0,@6)                                       0109
         MH    @E,KON4                                            0109
         L     @7,@A1              ADDRESS OF ADTAB1              0109
         AR    @E,@7                                              0109
         ST    @E,ADTABPTR                                        0109
*                                             /* INITIALIZE PTR TO THE
*                                                PROPER ENTRY IN THE
*                                                LVL 1 ADDRESS TABLE  *
*         SEG1ADR  = MSGPTR;                  /* PUT ADDRESS OF MSG IN
*                                                PARM BLOCK           *
         L     @8,ADTABPTR                                        0110
         L     @9,PBPTR                                           0110
         MVC   9(3,@9),1(@8)                                      0110
         MVI   8(@9),X'00'                                        0110
*         IF  SEGCNT = KON1                   /* IF THERE IS NO DYNAM-*
*           THEN                              /*  IC PORTION - BYPASS *
         LH    @F,KON1                                            0111
         C     @F,4(0,@9)                                         0111
*             GOTO E04PBS10;                  /*  CODE FOR SEGMENT 2  *
         BC    08,E04PBS10                                        0112
* E04PBS03:  ;
*         SEG2ADR  = ADDR(DYNMSGAR);          /* PUT ADDRESS OF AREA
*                                                WHICH WILL CONTAIN
*                                                DYNAMIC PORTION INTO
*                                                PARM BLOCK           *
E04PBS03 L     @7,DYNMSGPT                                        0114
         L     @8,PBPTR                                           0114
         ST    @7,12(0,@8)                                        0114
*         DYNLNG  = KON0;                     /* CLEAR LENGTH FIELD   *
         MVC   0(2,@7),KON0                                       0115
*         DYNLNGC2  = VARSGLNG;               /* INSERT LENGTH OF DYN
*                                                AMIC PORTION         *
         MVC   1(1,@7),296(@6)                                    0116
*         DYNTXT(1:DYNLNG)  = VARSEG;         /* MOVE TEXT TO OUR AREA*
         L     @9,296(0,@6)        
         LR    @E,@9                                              0117
         LH    @4,0(0,@7)                                         0117
         BCTR  @4,0                                               0117
         LA    @A,4(0,@7)                                         0117
         EX    @4,@MVC                                            0117
*         HOLNGC = MSGTXLNG;                  /* ALIGN LENGTH OF MSG. *
         L     @4,PBPTR                                           0118
         L     @4,8(0,@4)          MSGCHN                         0118
         MVC   HOLNG(2),0(@4)                                     0118
*         DYNOFF = KON0;                      /* INITIALIZE OFFSET    *
         MVC   2(2,@7),KON0                                       0119
*         DYNOFFCH(2) = MSGTX(HOLNG - 3);     /* SET OFFSET TO START
*                                                THIS SEGMENT         *
         LH    @5,@D1                                             0120
         AH    @5,HOLNG                                           0120
         LA    @E,3(@5,@4)                                        0120
         MVC   3(1,@7),0(@E)                                      0120
*         IF SEGCNT ^= KON3                   /* IF THIS MSG DOES NOT *
*           THEN                              /* HAVE THREE SEGMENTS  *
         LH    @F,KON3                                            0121
         C     @F,4(0,@8)                                         0121
*             GOTO E04PBS05;                  /* BYPASS THIS CODE     *
         BC    07,E04PBS05                                        0122
*         DYNMSGPT = ADDR(DYNMSG2);           /* INITIALIZE PTR TO
*                                                DYNAMIC HOLD AREA    *
         LA    @F,DYNMSG2                                         0123
         ST    @F,DYNMSGPT                                        0123
*         SEG3ADR = ADDR(DYNMSGAR);           /* STORE POINTER IN
*                                                PUTLINE PARM BLOCK   *
         LR    @7,@F                                              0124
         ST    @7,16(0,@8)                                        0124
*         DYNLNG = KON0;                      /* CLEAR LENGTH FIELD   *
         MVC   0(2,@7),KON0                                       0125
*         DYNLNGC2 = VARSGLN2;                /* INSERT LENGTH OF
*                                                DYNAMIC PORTION      *
         MVC   1(1,@7),300(@6)                                    0126
*         DYNTXT(1:DYNLNG) = VARSGAD2 -> VARSEG;
         L     @4,300(0,@6)        
         LR    @E,@4                                              0127
         LH    @2,0(0,@7)                                         0127
         BCTR  @2,0                                               0127
         LA    @A,4(0,@7)                                         0127
         EX    @2,@MVC                                            0127
*                                             /* MOVE TEXT TO OUR AREA*
*         DYNOFF = KON0;                      /* CLEAR OFFSET FIELD   *
         MVC   2(2,@7),KON0                                       0128
*         DYNOFFCH(2) = MSGTX(HOLNG - 2);     /* AND STORE OFFSET     *
         LH    @2,@D2                                             0129
         AH    @2,HOLNG                                           0129
         L     @3,PBPTR                                           0129
         L     @3,8(0,@3)          MSGCHN                         0129
         LA    @E,3(@2,@3)                                        0129
         MVC   3(1,@7),0(@E)                                      0129
* E04PBS05:   ;
*         MAXMSGLN = KON256 - HOLNG;          /* FIND MAX LENGTH DYNAM
*                                                PART OF MSG CAN BE   *
E04PBS05 LH    @F,KON256                                          0131
         SH    @F,HOLNG                                           0131
         STH   @F,MAXMSGLN                                        0131
*         IF SEGCNT = KON3                    /* IF MSG HAS THREE     *
*           THEN                              /* SEGMENTS THEN MUST   *
         LH    @F,KON3                                            0132
         L     @7,PBPTR                                           0132
         C     @F,4(0,@7)                                         0132
         BC    07,@9EB                                            0132
*              DO;                            /* ALIGN LENGTH OF 3RD  *
*                HOLNGC = SEG3ADR -> MSGTXLNG;/* SEGMENT AND INCLUDE  *
         L     @8,PBPTR                                           0134
         L     @8,16(0,@8)         MSGCHN                         0134
         MVC   HOLNG(2),0(@8)                                     0134
*                MAXMSGLN = MAXMSGLN - HOLNG; /* THE LENGTH OF THE 3RD
*                                                SEGMENT IN THE CALC-
*                                                ULATIONS             *
         LH    @F,MAXMSGLN                                        0135
         SH    @F,HOLNG                                           0135
         STH   @F,MAXMSGLN                                        0135
*              END;
*         HOLNGC = SEG2ADR -> MSGTXLNG;       /* ALIGN LENGTH OF 2ND
*                                                SEGMENT              *
@9EB     L     @7,PBPTR                                           0137
         L     @7,12(0,@7)         MSGCHN                         0137
         MVC   HOLNG(2),0(@7)                                     0137
*         IF SEGCNT > KON1 &                  /* IF THERE IS A DYNAMIC*
*           HOLNG > MAXMSGLN                  /*  PART AND ITS LENGTH *
*           THEN                              /*  IS GREATER THAN     *
         LH    @F,KON1                                            0138
         L     @8,PBPTR                                           0138
         C     @F,4(0,@8)                                         0138
         BC    10,@9EA                                            0138
         LH    @F,MAXMSGLN                                        0138
         CH    @F,HOLNG                                           0138
         BC    10,@9E9                                            0138
*             SEG2ADR -> MSGTXLNG = MAXMSGCH; /*  ALLOWABLE  - RESET
*                                                 LENGTH TO MAX
*                                                 ALLOWED             *
         MVC   0(2,@7),MAXMSGLN                                   0139
* /********************************************************************
**/*E04PBS10: D (YES,,NO,E04PLL10:LL) IS THERE A 2ND LEVEL MESSAGE? */
**/* P INITIALIZE PUTLINE PARM BLOCK FOR 2ND LEVEL MSG */
* /********************************************************************
*
*         /************************************************************
*         /*              THE FOLLOWING CODE INITIALIZES              *
*         /*              THE PUTLINE PARAMETER BLOCK FOR             *
*         /*              THE SECOND LEVEL MESSAGE                    *
*         /************************************************************
* E04PBS10: IF NXTLVLAD < KON0                /* IF A SECOND LEVEL MSG*
*             THEN                            /*  WAS NOT CALLED FOR  *
@9E9     EQU   *                                                  0140
@9EA     EQU   *                                                  0140
E04PBS10 LH    @F,KON0                                            0140
         L     @7,PBPTR                                           0140
         C     @F,0(0,@7)                                         0140
*               GOTO E04PLL10;                /*  BYPASS CODE FOR IT  *
         BC    02,E04PLL10                                        0141
*         NXTLVLAD  -> NXTLVLAD = KONFF0;     /* INDICATE THAT THERE
*                                                ARE NO FURTHER
*                                                LEVELS               *
         L     @8,PBPTR                                           0142
         L     @8,0(0,@8)          MSGCHN                         0142
         MVC   0(4,@8),KONFF0                                     0142
*         CNVA  = KON0;                       /* CLEAR ALIGNMENT AREA *
         MVC   200(2,@6),KON0                                     0143
*         CNVC(2)  = MSGN02;                  /* ALIGN INDICATOR OF
*                                                START OF POSSIBLE
*                                                2ND LEVEL MESSAGES   *
         L     @9,ADTABPTR                                        0144
         MVC   201(1,@6),0(@9)                                    0144
*         ADTABPTR  = ADDR(ADTAB2) + KON4 * CNVA;
         LH    @E,200(0,@6)                                       0145
         MH    @E,KON4                                            0145
         L     @4,@A2              ADDRESS OF ADTAB2              0145
         AR    @E,@4                                              0145
         ST    @E,ADTABPTR                                        0145
*                                             /* SET PTR TO ENTRY FOR
*                                                1ST POSSIBLE 2ND
*                                                LEVEL MESSAGE        *
*         ADTABPTR  = ADTABPTR + KON4 * (LVL2NO - KON1);
         LH    @F,KON1                                            0146
         LCR   @F,@F                                              0146
         AH    @F,306(0,@6)                                       0146
         MH    @F,KON4                                            0146
         A     @F,ADTABPTR                                        0146
         ST    @F,ADTABPTR                                        0146
*                                             /* SET PTR TO PROPER
*                                                ENTRY FOR 2ND LEVEL
*                                                MESSAGE              *
*         NXTLVLAD  -> SEG1ADR = MSGPTR;      /* PLACE ADDRESS OF MSG
*                                                INTO PARM BLOCK      *
         LR    @5,@F                                              0147
         MVC   9(3,@8),1(@5)                                      0147
         MVI   8(@8),X'00'                                        0147
*         IF NXTLVLAD -> SEGCNT = KON2        /* IF THERE IS VARIABLE *
*           THEN                              /* PORTION IN 2ND LEVEL,*
         LH    @F,KON2                                            0148
         C     @F,4(0,@8)                                         0148
         BC    07,@9E8                                            0148
*             DO;                             /* CHANGE ADDRS FOR DY- *
*               PBPTR = NXTLVLAD;             /* NAMIC PORTION IN SRT *
         MVC   PBPTR(4),0(@7)                                     0150
*               VARSGADR = VARSGAD2;          /* TURES AND GO TO RECYC*
         MVC   297(3,@6),301(@6)                                  0151
*               VARSGLNG = VARSGLN2;          /* LE TO SET UP SAME AS *
         MVC   296(1,@6),300(@6)                                  0152
*               DYNMSGPT = ADDR(DYNMSG2);     /* FIRST LEVEL VARIABLE *
         LA    @F,DYNMSG2                                         0153
         ST    @F,DYNMSGPT                                        0153
*               GO TO E04PBS03;               /* PORTION              *
         BC    15,E04PBS03                                        0154
*             END;
* /********************************************************************
**/*E04PLL10: S PUTLINE: SET POINTERS AND PUT OUT INFORMATION */
**/* D (NO,%D11:BT,YES,%D1:RT) WAS PUTLINE SUCCESSFUL ? */
**/*%D11: P SET ERROR RETURN CODE */
**/*%D1: R RETURN */
* /********************************************************************
*
*         /************************************************************
*         /*              THE FOLLOWING CODE SETS UP                  *
*         /*              THE LINKAGE FOR AND INVOKES                 *
*         /*              PUTLINE                                     *
*         /************************************************************
* E04PLL10: ;
@9E8     EQU   *                                                  0156
*         GEN(  MVC   APLN,LPLN           MOVE LIST TO GOTTEN CORE);
E04PLL10   MVC   APLN,LPLN           MOVE LIST TO GOTTEN CORE
         DS    0H
*         RESTRICT  (R2,R3);
*         R2  = ADDR(APLN);                   /* REG2 POINTS TO LIST
*                                                FORM OF PUTLINE      *
         LA    @2,APLN                                            0159
*         R3  = ADDR(PTLNBLCK);               /* REG3 POINTS TO OUTPUT
*                                                MESSAGE BLOCK        *
         LA    @3,PTLNBLCK                                        0160
*         R1  = PPLPTR;                       /* REG1 POINTS TO
*                                                SERVICE ROUTINE
*                                                CONTROL BLOCK        *
         L     @1,248(0,@6)                                       0161
*         GEN( PUTLINE  PARM=(R2),OUTPUT=((R3),MULTLVL),MF=(E,(1)));
          PUTLINE  PARM=(R2),OUTPUT=((R3),MULTLVL),MF=(E,(1))
         DS    0H
*                                             /* EXECUTE FORM OF
*                                                PUTLINE              *
*         RELEASE  (R2,R3);
*         IF  R15 ^= KON0                     /* IF THE PUTLINE WAS   *
*           THEN                              /*   UNSUCCESSFUL AND   *
         CH    @F,KON0                                            0164
         BC    08,@9E7                                            0164
*             IF RETCDAR ^= KON12             /*   IF A DRASTIC ERROR *
*               THEN                          /*   HAS NOT ALREADY    *
         LH    @F,KON12                                           0165
         C     @F,280(0,@6)                                       0165
         BC    08,@9E6                                            0165
*                 RETCDAR = KON16;            /*   OCCURRED INDICATE
*                                                  THE PUTLINE ERROR  *
         LH    @F,KON16                                           0166
         ST    @F,280(0,@6)                                       0166
**/*IKJEFE04: END */
*         RETURN;                             /* RETURN TO CALLER     *
         BC    15,@EL01                                           0167
*         GEN;
SPLL      EQU   *
LPLN      PUTLINE MF=L              GO TO PUT OUT LINE
EPLL      EQU   *
         DS    0H
*         GENERATE DATA;
*         END
* /* THE FOLLOWING INCLUDE STATEMENTS WERE FOUND IN THIS PROGRAM.
* /*%INCLUDE SYSLIB  (IKJDAPL )
* /*%INCLUDE SYSLIB  (IKJDAP08)
* ;
@EL01    L     @D,4(0,@D)                                         0170
         LR    @1,@C                                              0170
         L     @0,@SIZ001                                         0170
         FREEMAIN R,LV=(0),A=(1)                                  0170
         L     @E,12(0,@D)                                        0170
         L     @0,20(0,@D)                                        0170
         LM    @2,@C,28(@D)                                       0170
         BCR   15,@E                                              0170
@DATA1   EQU   *
@0       EQU   00                  EQUATES FOR REGISTERS 0-15
@1       EQU   01
@2       EQU   02
@3       EQU   03
@4       EQU   04
@5       EQU   05
@6       EQU   06
@7       EQU   07
@8       EQU   08
@9       EQU   09
@A       EQU   10
@B       EQU   11
@C       EQU   12
@D       EQU   13
@E       EQU   14
@F       EQU   15
@D1      DC    H'-3'
@D2      DC    H'-2'
@MVC     MVC   0(1,@A),0(@E)
@A1      DC    A(ADTAB1)
@A2      DC    A(ADTAB2)
         DS    0F
@SIZ001  DC    AL1(&SPN)
         DC    AL3(@DATEND-@DATD)
         DS    0F
         DS    0D
@DATA    EQU   *
DUMPARM  EQU   00000000            FULLWORD INTEGER
R1       EQU   00000001            FULLWORD POINTER REGISTER
R2       EQU   00000002            FULLWORD POINTER REGISTER
R3       EQU   00000003            FULLWORD POINTER REGISTER
R5       EQU   00000005            FULLWORD POINTER REGISTER
R6       EQU   00000006            FULLWORD POINTER REGISTER
R15      EQU   00000015            FULLWORD POINTER REGISTER
E01DATDF EQU   00000000            362 BYTE(S) ON DWORD
DCBAR    EQU   E01DATDF+00000000   88 BYTE(S) ON DWORD
ADPTR1   EQU   E01DATDF+00000088   FULLWORD POINTER
ADPTR2   EQU   E01DATDF+00000092   FULLWORD POINTER
MMNAMAR  EQU   E01DATDF+00000096   8 BYTE(S) ON WORD
RDECB    EQU   E01DATDF+00000104   20 BYTE(S) ON WORD
A00000   EQU   E01DATDF+00000104   6 BYTE(S)
DECLNGTH EQU   E01DATDF+00000110   HALFWORD INTEGER
A00001   EQU   E01DATDF+00000112   8 BYTE(S)
DECIOBPT EQU   E01DATDF+00000120   FULLWORD POINTER
LINPTR1  EQU   E01DATDF+00000124   FULLWORD POINTER
EOLCNT   EQU   E01DATDF+00000128   FULLWORD INTEGER
POSCNT   EQU   E01DATDF+00000132   FULLWORD INTEGER
TSTLNG   EQU   E01DATDF+00000136   FULLWORD INTEGER
TSTLNGC  EQU   E01DATDF+00000136   4 BYTE(S)
GMNMIN   EQU   E01DATDF+00000140   FULLWORD INTEGER
GMNMAX   EQU   E01DATDF+00000144   FULLWORD INTEGER
ADDGMN   EQU   E01DATDF+00000148   FULLWORD POINTER
AMTGMN   EQU   E01DATDF+00000152   FULLWORD INTEGER
SP78ADDR EQU   E01DATDF+00000156   FULLWORD POINTER
SP78LNGT EQU   E01DATDF+00000160   FULLWORD POINTER
RDXCNV   EQU   E01DATDF+00000164   FULLWORD INTEGER
A00002   EQU   E01DATDF+00000164   3 BYTE(S)
DDIG     EQU   E01DATDF+00000167   1 BYTE(S)
POSSPC   EQU   E01DATDF+00000168   FULLWORD INTEGER
ATABIND  EQU   E01DATDF+00000172   FULLWORD POINTER
ATABCUR  EQU   E01DATDF+00000176   FULLWORD POINTER
FTABIND  EQU   E01DATDF+00000180   FULLWORD POINTER
FTABCUR  EQU   E01DATDF+00000184   FULLWORD POINTER
VALCNT   EQU   E01DATDF+00000188   FULLWORD INTEGER
KWOCNT   EQU   E01DATDF+00000192   HALFWORD INTEGER
KWWCNT   EQU   E01DATDF+00000194   HALFWORD INTEGER
KWOBYT   EQU   E01DATDF+00000196   HALFWORD INTEGER
KWWBYT   EQU   E01DATDF+00000198   HALFWORD INTEGER
CNVA     EQU   E01DATDF+00000200   HALFWORD INTEGER
CNVC     EQU   E01DATDF+00000200   2 BYTE(S)
E01BINSW EQU   E01DATDF+00000202   2 BYTE(S) ON HWORD
E01SW1   EQU   E01DATDF+00000202   1 BIT(S)
E01SW2   EQU   E01DATDF+00000202   1 BIT(S)
E01SW3   EQU   E01DATDF+00000202   1 BIT(S)
E01SW4   EQU   E01DATDF+00000202   1 BIT(S)
E01SW5   EQU   E01DATDF+00000202   1 BIT(S)
E01SW6   EQU   E01DATDF+00000202   1 BIT(S)
E01SW7   EQU   E01DATDF+00000202   1 BIT(S)
E01SW8   EQU   E01DATDF+00000202   1 BIT(S)
E01SW9   EQU   E01DATDF+00000203   1 BIT(S)
E01SW10  EQU   E01DATDF+00000203   1 BIT(S)
E01SW11  EQU   E01DATDF+00000203   1 BIT(S)
E01SW12  EQU   E01DATDF+00000203   1 BIT(S)
E01SW13  EQU   E01DATDF+00000203   1 BIT(S)
E01SW14  EQU   E01DATDF+00000203   1 BIT(S)
E01SW15  EQU   E01DATDF+00000203   1 BIT(S)
E01SW16  EQU   E01DATDF+00000203   1 BIT(S)
REGSAV   EQU   E01DATDF+00000204   3*FULLWORD INTEGER
LATAB    EQU   E01DATDF+00000216   FULLWORD POINTER
LFTAB    EQU   E01DATDF+00000220   FULLWORD POINTER
BFAPTR   EQU   E01DATDF+00000224   FULLWORD INTEGER
BFBPTR   EQU   E01DATDF+00000228   FULLWORD POINTER
CPPLPTR  EQU   E01DATDF+00000232   FULLWORD POINTER
STPRM    EQU   E01DATDF+00000236   3*FULLWORD INTEGER
PPLPTR   EQU   E01DATDF+00000248   FULLWORD POINTER
CBCOR    EQU   E01DATDF+00000252   24 BYTE(S)
SRECB    EQU   E01DATDF+00000276   FULLWORD INTEGER
RETCDAR  EQU   E01DATDF+00000280   FULLWORD INTEGER
ABLK1    EQU   E01DATDF+00000284   FULLWORD POINTER
EOB      EQU   E01DATDF+00000288   FULLWORD POINTER
RCDST    EQU   E01DATDF+00000292   FULLWORD POINTER
VARSGLNG EQU   E01DATDF+00000296   1 BYTE(S)
VARSGADR EQU   E01DATDF+00000297   3  BYTE  POINTER ON WORD+1
VARSGLN2 EQU   E01DATDF+00000300   1 BYTE(S)
VARSGAD2 EQU   E01DATDF+00000301   3  BYTE  POINTER ON WORD+1
LVL1NO   EQU   E01DATDF+00000304   HALFWORD INTEGER
LVL2NO   EQU   E01DATDF+00000306   HALFWORD INTEGER
PDLPTR   EQU   E01DATDF+00000308   FULLWORD POINTER
DRDNPTR  EQU   E01DATDF+00000312   46 BYTE(S) ON WORD
DSNARLNG EQU   E01DATDF+00000312   HALFWORD INTEGER
DSNARLCH EQU   E01DATDF+00000312   2 BYTE(S)
DSNAMAR  EQU   E01DATDF+00000314   44 BYTE(S)
CBUFLSAV EQU   E01DATDF+00000358   HALFWORD INTEGER
CBUFLSAC EQU   E01DATDF+00000358   2 BYTE(S)
POSBYT   EQU   E01DATDF+00000360   HALFWORD INTEGER
MSGCHN   EQU   00000000            20 BYTE(S) ON WORD
NXTLVLAD EQU   MSGCHN+00000000     FULLWORD POINTER
SEGCNT   EQU   MSGCHN+00000004     FULLWORD INTEGER
SEG1ADR  EQU   MSGCHN+00000008     FULLWORD POINTER
SEG2ADR  EQU   MSGCHN+00000012     FULLWORD POINTER
SEG3ADR  EQU   MSGCHN+00000016     FULLWORD POINTER
ADTABDUM EQU   00000000            4 BYTE(S) ON WORD
MSGN02   EQU   ADTABDUM+00000000   1 BYTE(S)
MSGPTR   EQU   ADTABDUM+00000001   3  BYTE  POINTER ON WORD+1
DYNMSGAR EQU   00000000            260 BYTE(S) ON WORD
DYNLNG   EQU   DYNMSGAR+00000000   HALFWORD INTEGER
DYNLNGC1 EQU   DYNMSGAR+00000000   1 BYTE(S)
DYNLNGC2 EQU   DYNMSGAR+00000001   1 BYTE(S)
DYNOFF   EQU   DYNMSGAR+00000002   HALFWORD INTEGER
DYNOFFCH EQU   DYNMSGAR+00000002   2 BYTE(S)
DYNTXT   EQU   DYNMSGAR+00000004   256 BYTE(S)
MSGTXDUM EQU   00000000            5 BYTE(S) ON WORD
MSGTXLNG EQU   MSGTXDUM+00000000   2 BYTE(S)
A00003   EQU   MSGTXDUM+00000002   2 BYTE(S)
MSGTX    EQU   MSGTXDUM+00000004   1 BYTE(S)
KONFF0   EQU   @DATA+00000000      FULLWORD INTEGER
KONFFC   EQU   *                   4 BYTE(S)
         DC    X'FF000000'
VARSEG   EQU   00000000            256 BYTE(S)
DAPLPTR  EQU   00000248            FULLWORD POINTER
DAPL     EQU   00000000            20 BYTE(S) ON WORD
DAPLUPT  EQU   DAPL+00000000       FULLWORD POINTER
DAPLECT  EQU   DAPL+00000004       FULLWORD POINTER
DAPLECB  EQU   DAPL+00000008       FULLWORD POINTER
DAPLPSCB EQU   DAPL+00000012       FULLWORD POINTER
DAPLDAPB EQU   DAPL+00000016       FULLWORD POINTER
DAPB0PTR EQU   00000016            FULLWORD POINTER
DAPB08   EQU   00000000            84 BYTE(S) ON WORD
DA08CD   EQU   DAPB08+00000000     2 BYTE(S)
DA08FLG  EQU   DAPB08+00000002     2 BYTE(S)
DA08FPE  EQU   DAPB08+00000002     1 BIT(S)
A00004   EQU   DAPB08+00000002     1 BIT(S)
A00005   EQU   DAPB08+00000002     1 BIT(S)
A00006   EQU   DAPB08+00000002     1 BIT(S)
A00007   EQU   DAPB08+00000002     1 BIT(S)
A00008   EQU   DAPB08+00000002     1 BIT(S)
A00009   EQU   DAPB08+00000002     1 BIT(S)
A00010   EQU   DAPB08+00000002     1 BIT(S)
DA08DARC EQU   DAPB08+00000004     HALFWORD INTEGER
DA08CTRC EQU   DAPB08+00000006     HALFWORD INTEGER
DA08PDSN EQU   DAPB08+00000008     FULLWORD POINTER
DA08DDN  EQU   DAPB08+00000012     8 BYTE(S)
DA08UNIT EQU   DAPB08+00000020     8 BYTE(S)
DA08SER  EQU   DAPB08+00000028     8 BYTE(S)
DA08BLK  EQU   DAPB08+00000036     4 BYTE(S)
DA08PQTY EQU   DAPB08+00000040     4 BYTE(S)
DA08SQTY EQU   DAPB08+00000044     4 BYTE(S)
DA08DQTY EQU   DAPB08+00000048     4 BYTE(S)
DA08MNM  EQU   DAPB08+00000052     8 BYTE(S)
DA08PSWD EQU   DAPB08+00000060     8 BYTE(S)
DA08DSP1 EQU   DAPB08+00000068     1 BYTE(S)
A00011   EQU   DAPB08+00000068     1 BIT(S)
A00012   EQU   DAPB08+00000068     1 BIT(S)
A00013   EQU   DAPB08+00000068     1 BIT(S)
A00014   EQU   DAPB08+00000068     1 BIT(S)
DA08SHR  EQU   DAPB08+00000068     1 BIT(S)
DA08NEW  EQU   DAPB08+00000068     1 BIT(S)
DA08MOD  EQU   DAPB08+00000068     1 BIT(S)
DA08OLD  EQU   DAPB08+00000068     1 BIT(S)
DA08DPS2 EQU   DAPB08+00000069     1 BYTE(S)
A00015   EQU   DAPB08+00000069     1 BIT(S)
A00016   EQU   DAPB08+00000069     1 BIT(S)
A00017   EQU   DAPB08+00000069     1 BIT(S)
A00018   EQU   DAPB08+00000069     1 BIT(S)
DA08KEEP EQU   DAPB08+00000069     1 BIT(S)
DA08DEL  EQU   DAPB08+00000069     1 BIT(S)
DA08CAT  EQU   DAPB08+00000069     1 BIT(S)
DA08UCAT EQU   DAPB08+00000069     1 BIT(S)
DA08DPS3 EQU   DAPB08+00000070     1 BYTE(S)
A00019   EQU   DAPB08+00000070     1 BIT(S)
A00020   EQU   DAPB08+00000070     1 BIT(S)
A00021   EQU   DAPB08+00000070     1 BIT(S)
A00022   EQU   DAPB08+00000070     1 BIT(S)
DA08KEP  EQU   DAPB08+00000070     1 BIT(S)
DA08DELE EQU   DAPB08+00000070     1 BIT(S)
DA08CATL EQU   DAPB08+00000070     1 BIT(S)
DA08UNCT EQU   DAPB08+00000070     1 BIT(S)
DA08CTL  EQU   DAPB08+00000071     1 BYTE(S)
DA08TRKS EQU   DAPB08+00000071     1 BIT(S)
DA08ABKL EQU   DAPB08+00000071     1 BIT(S)
DA08UID  EQU   DAPB08+00000071     1 BIT(S)
DA08RLSE EQU   DAPB08+00000071     1 BIT(S)
DA08PERM EQU   DAPB08+00000071     1 BIT(S)
DA08DMMY EQU   DAPB08+00000071     1 BIT(S)
DA08ATRL EQU   DAPB08+00000071     1 BIT(S)
A00023   EQU   DAPB08+00000071     1 BIT(S)
A00024   EQU   DAPB08+00000072     3 BYTE(S)
DA08DSO  EQU   DAPB08+00000075     1 BYTE(S)
DA08ALN  EQU   DAPB08+00000076     8 BYTE(S)
KON0     EQU   *                   HALFWORD INTEGER
         DC    FL2'0'
KON1     EQU   *                   HALFWORD INTEGER
         DC    FL2'1'
KON2     EQU   *                   HALFWORD INTEGER
         DC    FL2'2'
KON3     EQU   *                   HALFWORD INTEGER
         DC    FL2'3'
KON4     EQU   *                   HALFWORD INTEGER
         DC    FL2'4'
KON5     EQU   *                   HALFWORD INTEGER
         DC    FL2'5'
KON8     EQU   *                   HALFWORD INTEGER
         DC    FL2'8'
KON12    EQU   *                   HALFWORD INTEGER
         DC    FL2'12'
KON16    EQU   *                   HALFWORD INTEGER
         DC    FL2'16'
KON20    EQU   *                   HALFWORD INTEGER
         DC    FL2'20'
KON21    EQU   *                   HALFWORD INTEGER
         DC    FL2'21'
KON24    EQU   *                   HALFWORD INTEGER
         DC    FL2'24'
KON25    EQU   *                   HALFWORD INTEGER
         DC    FL2'25'
KON27    EQU   *                   HALFWORD INTEGER
         DC    FL2'27'
KON57    EQU   *                   HALFWORD INTEGER
         DC    FL2'57'
KON256   EQU   *                   HALFWORD INTEGER
         DC    FL2'256'
KONX00   EQU   *                   2 BYTE(S)
         DC    X'0000'
KONX06   EQU   *                   1 BYTE(S)
         DC    X'06'
KONXF0   EQU   *                   1 BYTE(S)
         DC    X'F0'
KONXF9   EQU   *                   1 BYTE(S)
         DC    X'F9'
         EXTRN ADTAB1
         EXTRN ADTAB2
         ORG   @DATA
         DS    00000041C
@L       EQU   1
@DATD    DSECT
@SAV001  EQU   @DATD+00000000      72 BYTE(S) ON WORD
PTLNBLCK EQU   @DATD+00000072      32 BYTE(S) ON WORD
PBPTR    EQU   @DATD+00000104      FULLWORD POINTER
ADTABPTR EQU   @DATD+00000108      FULLWORD POINTER
DYNMSG1  EQU   @DATD+00000112      260 BYTE(S)
DYNMSG2  EQU   @DATD+00000376      260 BYTE(S) ON DWORD
DYNMSGPT EQU   @DATD+00000636      FULLWORD POINTER
MAXMSGLN EQU   @DATD+00000640      HALFWORD INTEGER
MAXMSGCH EQU   MAXMSGLN+00000000   2 BYTE(S)
HOLNG    EQU   @DATD+00000642      HALFWORD INTEGER
HOLNGC   EQU   HOLNG+00000000      2 BYTE(S)
         DS    00000644C
@TEMPS   DS    0F
@TEMP4   DC    F'0'
         CNOP  0,4
APLN      DS    CL(EPLL-SPLL)
@DATD    DSECT
@DATEND  EQU   *
IKJEFE04 CSECT ,
@9FB     EQU   E04PBS02
@9ED     EQU   @9EC
@9E7     EQU   @EL01
@9E6     EQU   @EL01
         END
