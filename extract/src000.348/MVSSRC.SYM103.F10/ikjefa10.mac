         TITLE 'IKJEFA10 - ACCOUNT/ADD SUBCOMMAND (PARSE/CREATE ROUTINE*
               E)       '
IKJEFA10 CSECT ,                                                   0001
@MAINENT DS    0H                                                  0001
         USING *,@15                                               0001
         B     @PROLOG                                             0001
         DC    AL1(16)                                             0001
         DC    C'IKJEFA10  78.174'                                 0001
         DROP  @15
@PROLOG  STM   @14,@12,12(@13)                                     0001
         BALR  @12,0                                               0001
@PSTART  DS    0H                                                  0001
         USING @PSTART,@12                                         0001
         L     @00,@SIZDATD                                        0001
         GETMAIN  R,LV=(0)
         LR    @11,@01                                             0001
         USING @DATD,@11                                           0001
         ST    @13,@SA00001+4                                      0001
         LM    @00,@01,20(@13)                                     0001
         ST    @11,8(,@13)                                         0001
         LR    @13,@11                                             0001
*          ACCTPLP=R1;                  /* INITIALIZE PTR TO ACCOUNT
*                                          PARAMETER LIST            */
         LR    ACCTPLP,R1                                          0039
*          RFY R1 UNRSTD;               /* RELEASE PARAMETER POINTER */
*          COMMON=COMMON&&COMMON;       /* CLEAR COMMUNICATIONS AREA */
         XC    COMMON(47),COMMON                                   0041
*          PERFGRP=PERFGRP&&PERFGRP;    /* CLEAR PERF GROUP AREA   0042
*                                                              Y02678*/
         XC    PERFGRP(32),PERFGRP                                 0042
*          GETPTRS=GETPTRS&&GETPTRS;    /* CLEAR GETMAIN POINTERS    */
         XC    GETPTRS(20),GETPTRS                                 0043
*          STOWLIST=STOWLIST&&STOWLIST; /* CLEAR STOW LIST           */
         XC    STOWLIST(14),STOWLIST                               0044
*          /* MOVE L-FORMS OF O/S MACROS INTO DYNAMIC STORAGE        */
*          DYNLFORM(1:INLINLNG)=INLINLFM(1:INLINLNG);              0045
         L     @10,INLINLNG                                        0045
         BCTR  @10,0                                               0045
         EX    @10,@SM00453                                        0045
*          ACIOPTR=ADDR(ACIOPARM);      /* BASE FOR I/O SUBROUTINE   */
         LA    @10,ACIOPARM                                        0046
         ST    @10,ACIOPTR                                         0046
*          ACIOPARM=ACIOPARM&&ACIOPARM; /* CLEAR I/O PARM AREA       */
         XC    ACIOPARM(24),ACIOPARM                               0047
*          STOWC='01'X;                 /* INDICATE ONE DATA HALFWORD*/
         MVI   STOWC,X'01'                                         0048
*          BLDLPTR=ADDR(BLDLLIST);      /* NAME FOR BLDL PARAM LIST  */
         LA    @10,BLDLLIST                                        0049
         ST    @10,BLDLPTR                                         0049
*          DCBPTR=ADDR(DYNUADCB);       /* PTR TO UADS BPAM DCB      */
         LA    @10,DYNUADCB                                        0050
         ST    @10,DCBPTR                                          0050
*          ECBPTR=ACCTECBP;             /* POINT TO ACCOUNT'S ECB    */
         L     @05,ACCTECBP(,ACCTPLP)                              0051
         ST    @05,ECBPTR                                          0051
*          IOPLPTR=ADDR(PUTLLIST);      /* PTR TO PUTLINE PARAM LIST */
         LA    @05,PUTLLIST                                        0052
         ST    @05,IOPLPTR                                         0052
*          NODELADR=ADDR(NLSTTAB);      /* POINT TO NODELIST TABLE   */
         LA    @15,NLSTTAB                                         0053
         ST    @15,NODELADR                                        0053
*          MSGBASE=ADDR(MSGTABLE);      /* BASE FOR ADD MESSAGES     */
         L     MSGBASE,@CV00213                                    0054
*          PUTLLIST(1:12)=ACCTPL;       /* FIRST THREE WORDS FROM  0055
*                                          ACCOUNT PARAMETER LIST    */
         MVC   PUTLLIST(12),ACCTPL(ACCTPLP)                        0055
*          PTPBPTR=ADDR(DYNPTLST);      /* POINT TO PUTLINE PARM BLK */
         LA    @15,DYNPTLST                                        0056
         ST    @15,PTPBPTR(,@05)                                   0056
*          PTPBOPUT=ADDR(OUTLNDS);      /* POINT TO OUTPUT LINE DESC.*/
         LA    @05,OUTLNDS                                         0057
         ST    @05,PTPBOPUT(,@15)                                  0057
*          OUTLNDS=OUTLNDS&&OUTLNDS;    /* CLEAR OUTPUT LINE       0058
*                                          DESCRIPTORS FOR PUTLINE   */
         XC    OUTLNDS(40),OUTLNDS                                 0058
*          OUT1LINK=ADDR(OUTLD2);       /* INITIALIZE LINKAGE FOR  0059
*                                          2 MESSAGE LEVELS          */
         LA    @05,OUTLD2                                          0059
         ST    @05,OUT1LINK                                        0059
*          /* BUILD PARAMETER BLOCK FOR IKJEFA52 - WRITE SUBROUTINE  */
*          ACIOFLGS='10001000'B;        /* SET FLAGS TO INDICATE   0060
*                                          A) SINGLE PHYSICAL MEMBR I/O
*                                          B) WRITE OP'N REQUESTED   */
         MVI   ACIOFLGS,B'10001000'                                0060
*          ACIODCBA=ADDR(DYNUADCB);     /* UADS DCB ADDRESS          */
         STCM  @10,7,ACIODCBA                                      0061
*          ACIOLINK=0;                  /* NO BLDL CHAIN ELEMENT     */
         SLR   @10,@10                                             0062
         ST    @10,ACIOLINK                                        0062
*          ACIONMBR=1;                  /* NO. OF MEMBERS = ONE      */
         MVI   ACIONMBR,X'01'                                      0063
*          ACIOPUTL=ACCTPLP;            /* PTR TO ACCOUNT PARM LIST  */
         ST    ACCTPLP,ACIOPUTL                                    0064
*          ACIOMSGN='6';                /* ADD MSG NMBR FOR I/O MSG  */
         MVI   ACIOMSGN,C'6'                                       0065
*          /* INITIALIZE PARSE PARAMETER CONTROL LIST (PCL) FR. MODEL*/
*          /* PCL MUST BE MOVED INTO DYNAMIC STORAGE SINCE IT WILL BE*/
*          /* MODIFIED IN THE NODELIST VALIDITY CK EXIT RTNE-NLSTEXIT*/
*          RFY R0 RSTD;                 /* RESERVE REG. FOR GETMAIN  */
*          R0=PCLLNGTH;                 /* SET LENGTH = PCL SIZE     */
         L     @10,PCLMODAD                                        0067
         LH    R0,PCLLNGTH(,@10)                                   0067
*          PLENGTH=R0;                  /* SAVE LENGTH FOR FREEMAIN  */
         ST    R0,PLENGTH                                          0068
*          /* USE OS/360 GETMAIN MACRO TO OBTAIN WORK AREA.          */
*          GEN (GETMAIN EC,LV=(R0),A=PCLPTR,MF=(E,DYNGTLST))       0069
*            SETS(PCLPTR) REFS(R0,DYNGTLST);                       0069
         GETMAIN EC,LV=(R0),A=PCLPTR,MF=(E,DYNGTLST)
*          RFY R15 RSTD;                /* RESTRICT RETURN CODE REG  */
*          RETNCODE=R15;                /* SAVE GETMAIN RETURN CODE  */
         LR    RETNCODE,R15                                        0071
*          RFY R15 UNRSTD;              /* RELEASE RETURN CODE REG   */
*          /* CHECK RETURN CODE                                      */
*          IF RETNCODE^=0                                          0073
*            THEN                       /* GETMAIN FAILED            */
         LTR   RETNCODE,RETNCODE                                   0073
         BNZ   @RT00073                                            0073
*              GO TO GETMERR;           /* GO PUT OUT MESSAGE & LEAVE*/
*          RFY (R1,R14,R15) RSTD;       /* RESTRICT WORK REGISTERS   */
*          R0=PCLPTR;                   /* GET TO ADDRESS            */
         L     R0,PCLPTR                                           0076
*          R1=PLENGTH;                  /* LOAD R1 WITH LENGTH       */
         L     @10,PLENGTH                                         0077
         LR    R1,@10                                              0077
*          R14=PCLMODAD;                /* GET FROM ADDRESS          */
         L     R14,PCLMODAD                                        0078
*          R15=PLENGTH;                 /* LOAD R15 WITH LENGTH      */
         LR    R15,@10                                             0079
*          GEN (MVCL  R0,R14)           /* MOVE PCL TO GOTTEN CORE   */
*            REFS(R0,R1,R14,R15);                                  0080
         MVCL  R0,R14
*          RFY (R0,R1,R14,R15) UNRSTD;  /* RELEASE WORK REGISTERS    */
*          PPLPTR=ADDR(PARSLIST);       /* ESTABLISH PPL ADDRESSABLTY*/
         LA    @10,PARSLIST                                        0082
         ST    @10,PPLPTR                                          0082
*          EXITADD=ADDR(NLSTEXIT);      /* POINT TO ADD'S EXIT       */
         LA    @15,NLSTEXIT                                        0083
         ST    @15,EXITADD                                         0083
*          NODEPTR=ADDR(NLSTTAB);       /* POINT TO THE NODELIST TAB */
         LA    @15,NLSTTAB                                         0084
         ST    @15,NODEPTR                                         0084
*          PERFPTR=ADDR(PERFGRP);       /* POINT TO AREA FOR PERF GRP*/
         LA    @15,PERFGRP                                         0085
         ST    @15,PERFPTR                                         0085
*          CMDIND=1;                    /* INDICATE ADD CMD NODELIST */
         MVI   CMDIND,X'01'                                        0086
*          RFY R13 RSTD;                /* RESTRICT SAVE AREA POINTER*/
*          SAVARAD=R13;                 /* POINT TO ADD'S SAVE AREA  */
         ST    R13,SAVARAD                                         0088
*          /* INITIALIZE PARSE PARAMETER LIST                        */
*          PARSLIST(1:12)=ACCTPL;       /* FIRST THREE WORDS FROM  0089
*                                          ACCOUNT PARAMETER LIST    */
         MVC   PARSLIST(12),ACCTPL(ACCTPLP)                        0089
*          PPLPCL=ADDR(PARSMACS);       /* ADDRESS OF DYNAMIC PCL    */
         L     @15,PCLPTR                                          0090
         ST    @15,PPLPCL(,@10)                                    0090
*          PPLANS=ADDR(ADDPDLAD);       /* ADDPDLAD WILL CONTAIN   0091
*                                          ADDRESS OF PDL AFTER PARSE
*                                          EXECUTES                  */
         LA    @15,ADDPDLAD                                        0091
         ST    @15,PPLANS(,@10)                                    0091
*          PPLCBUF=CMDBUFAD;            /* ADDR OF ADD COMMAND BUFFER*/
         L     @15,CMDBUFAD(,ACCTPLP)                              0092
         ST    @15,PPLCBUF(,@10)                                   0092
*          PPLUWA=ADDR(VCHKPL);         /* ADDRESS OF EXIT ROUTINE 0093
*                                          PARAMETER LIST            */
         LA    @15,VCHKPL                                          0093
         ST    @15,PPLUWA(,@10)                                    0093
*          /*  LINK TO PARSE SERVICE ROUTINE                         */
*          GEN (LINK  EP=IKJPARS,MF=(E,PARSLIST))                  0094
*            FLOWS(NLSTEXIT) REFS(PARSLIST);                       0094
         LINK  EP=IKJPARS,MF=(E,PARSLIST)
*          RFY R15 RSTD;                /* RESTRICT RETURN CODE REG  */
*          RETNCODE=R15;                /* SAVE RETURN CODE          */
         LR    RETNCODE,R15                                        0096
*          RFY R15 UNRSTD;              /* RELEASE RETURN CODE REG   */
*          /* CHECK RETURN CODE FOR SUCCESSFUL COMPLETION.  IF PARSE */
*          /* HAS NOT SUCCEEDED, CALL 'PARSERR' TO ANALYZE ERROR.    */
*          IF RETNCODE^=0                                          0098
*            THEN                       /* PARSE FAILED              */
         LTR   RETNCODE,RETNCODE                                   0098
         BZ    @RF00098                                            0098
*              DO;                                                 0099
*              ERRFLG='1'B;             /* TURN ON ERROR FLAG        */
         OI    ERRFLG,B'01000000'                                  0100
*              IF RETNCODE=20                                      0101
*                THEN                   /* 20 = VAL CK FAILURE       */
         C     RETNCODE,@CF00070                                   0101
         BNE   @RF00101                                            0101
*                  RETNCODE=EXITRTCD;   /* GET RET CODE FROM EXIT    */
         L     RETNCODE,EXITRTCD                                   0102
*              IF RETNCODE=4×RETNCODE=8                            0103
*                THEN                   /* 4 = UNABLE TO PROMPT,   0103
*                                          8 = ATTENTION,            */
@RF00101 C     RETNCODE,@CF00049                                   0103
         BE    @RT00103                                            0103
         C     RETNCODE,@CF00040                                   0103
         BE    @RT00103                                            0103
*                  GOTO CLEANUP0;       /* NO MSG. - JUST GO CLEAN UP*/
*              /* WAS IT AN 'INSUFFICIENT SPACE' PROBLEM ?           */
*              IF RETNCODE=16                                      0105
*                THEN                   /* YES - GETMAIN FAILURE     */
         C     RETNCODE,@CF00042                                   0105
         BNE   @RF00105                                            0105
*                  DO;                                             0106
*                  OUT1LINK=0;          /* INDICATE NO 2ND LEVEL MSG */
         SLR   @10,@10                                             0107
         ST    @10,OUT1LINK                                        0107
*                  OUT1SCNT='02'X;      /* 1ST LEVEL MSG SEG COUNT =2*/
         MVI   OUT1SCNT,X'02'                                      0108
*                  OUT1SEG1=ADDMSG(2);  /* ADDR OF 'NO SPACE' MESSAGE*/
         L     @10,ADDMSG+4(,MSGBASE)                              0109
         ST    @10,OUT1SEG1                                        0109
*                  OUT1SEG2=ADDMSG(3);  /* 2ND SEGMT='EXECUTE COMMAND*/
         L     @10,ADDMSG+8(,MSGBASE)                              0110
         ST    @10,OUT1SEG2                                        0110
*                  GOTO ERRMSG;         /* GO TO ERROR TERMINATION   */
         B     ERRMSG                                              0111
*                  END;                                            0112
*              /* MUST BE COMPLETION CODE 12 OR CODE > 20            */
*              OUT2SEG2=ADDMSG(35);     /* 2ND SEGMT = 'PARSE '      */
@RF00105 L     @10,ADDMSG+136(,MSGBASE)                            0113
         ST    @10,OUT2SEG2                                        0113
*              GOTO CMDSYSER;           /* GO TO PUT OUT 'COMMAND  0114
*                                          STSTEM ERROR MESSAGE'   0114
*                                          AND TERMINATE             */
         B     CMDSYSER                                            0114
*              END;                                                0115
*          /* BUILD USERID SEGMENT FOR MESSAGES JUST IN CASE ...     */
*          USRIDLN=USRLEN+4;            /* USERID SEGMENT LENGTH     */
@RF00098 SLR   @10,@10                                             0116
         IC    @10,USRLEN                                          0116
         LA    @10,4(,@10)                                         0116
         STH   @10,USRIDLN                                         0116
*          USERID=USRID;                /* USERID FROM PARSE PDE     */
         MVC   USERID(7),USRID                                     0117
*          /* ENQ ON THE DATA SET ('OPENUADS' = MINOR NAME)          */
*          GEN (ENQ   ,RET=NONE,MF=(E,DYNNQLST))                   0118
*            REFS(MAJNAME,MINNAME,DYNNQLST);                       0118
         ENQ   ,RET=NONE,MF=(E,DYNNQLST)
*          ENQSW='1'B;                  /* INDICATE THAT THE UADS IS
*                                          ENQ'D UPON                */
         OI    ENQSW,B'10000000'                                   0119
*          /* INITIALIZE ELEMENTS OF BLDL LIST BEFORE AUGMENT/CREATE */
*          /* DECISION WHICH FOLLOWS.                                */
*          NUMOFENT=1;                  /* ONE ENTRY                 */
         MVC   NUMOFENT(2),@CH00032                                0120
*          ENTLNGTH=LENGTH(BLDLENTY);   /* LENGTH = FOURTEEN BYTES   */
         MVC   ENTLNGTH(2),@CH00257                                0121
*          BLDLNAME=USRID;              /* NAME FROM 'NODELIST'      */
         MVC   BLDLNAME(8),USRID                                   0122
*          BLDLNAME(USRLEN+1)='0';      /* INDICATES BASE MEMBER     */
         SLR   @10,@10                                             0123
         IC    @10,USRLEN                                          0123
         LA    @01,BLDLNAME(@10)                                   0123
         MVI   0(@01),C'0'                                         0123
*          /* CHECK FOR USER ATTENTION INTERRUPT BEFORE CONTINUING   */
*          IF ATTENTN='1'B                                         0124
*            THEN                       /* USER WANTS ATTENTION      */
         L     @10,ACCTECBP(,ACCTPLP)                              0124
         TM    ATTENTN(@10),B'01000000'                            0124
         BO    @RT00124                                            0124
*              GO TO CLEANUP0;          /* STOP -GO DIRECTLY TO CLNUP*/
*          /* MUST NOW DETERMINE WHETHER THIS COMMAND IS INTENDED TO */
*          /* CREATE A NEW USER ENTRY OR MERELY AUGMENT AN OLD ONE.  */
*          /* IF A DATALIST IS PRESENT, THIS IS 'AUGMENT' MODE.      */
*          IF DATAKEY(16)='1'B                                     0126
*            THEN                       /* 'DATA' KEYWORD IN COMMAND */
         L     @10,ADDPDLAD                                        0126
         TM    DATAKEY+1(@10),B'00000001'                          0126
         BNO   @RF00126                                            0126
*              DO;                                                 0127
*              NUMOFLVL=NUMOFLV;        /* SET NUMBER OF ITEMS IN  0128
*                                          NODELIST                  */
         IC    @06,NUMOFLV                                         0128
         STC   @06,NUMOFLVL                                        0128
*              DATASUBP=ADDR(DATASUBF); /* POINT TO DATA SUBFIELD PDE*/
         LA    @06,DATASUBF(,@10)                                  0129
         ST    @06,DATASUBP                                        0129
*              /* THEN, SEE IF THE 'SIZE' KEYWORD WAS SUPPLIED       */
*              IF SIZEKEY(16)='1'B                                 0130
*                THEN                   /* YES 'SIZE' SUPPLIED       */
         TM    SIZEKEY+1(@10),B'00000001'                          0130
         BNO   @RF00130                                            0130
*                  DO;                                             0131
*                  SIZED=SIZE;          /* PUT SIZE VALUE IN COMMON1 */
         L     @06,SIZNOADR(,@10)                                  0132
         MVC   SIZED(5),SIZE(@06)                                  0132
*                  SIZEL=SIZNOLNG;      /* PUT SIZE LENGTH IN COMMON */
         LH    @06,SIZNOLNG(,@10)                                  0133
         STH   @06,SIZEL                                           0133
*                  SIZEH=SIZEHEX;       /* PUT HEX SIZE IN COMMON    */
         LH    @10,SIZEHEX(,@10)                                   0134
         N     @10,@CF00457                                        0134
         STH   @10,SIZEH                                           0134
*                  END;                                            0135
*              /* THEN, SEE IF UNIT NAME PARAMETER WAS SPECIFIED     */
*              IF UNITKEY(16)='1'B                                 0136
*                THEN                   /* YES 'UNIT' SUPPLIED       */
@RF00130 L     @10,ADDPDLAD                                        0136
         TM    UNITKEY+1(@10),B'00000001'                          0136
         BNO   @RF00136                                            0136
*                  DO;                                             0137
*                  UNITN=UNITNAME       /* PUT UNIT VALUE IN COMMON1 */
*                    (1:UNITNLNG);                                 0138
         MVI   UNITN+1,C' '                                        0138
         MVC   UNITN+2(6),UNITN+1                                  0138
         LH    @06,UNITNLNG(,@10)                                  0138
         BCTR  @06,0                                               0138
         L     @10,UNITNADR(,@10)                                  0138
         EX    @06,@SM00458                                        0138
*                  END;                                            0139
*                ELSE                                              0140
*                  UNITN='        ';    /* INIT UNIT NAME TO BLANKS  */
         B     @RC00136                                            0140
@RF00136 MVC   UNITN(8),@CC00401                                   0140
*              RFY R1 RSTD;             /* RESTRICT PARAMETER POINTER*/
@RC00136 DS    0H                                                  0142
*              R1=ADDR(COMMON);         /* INITIALIZE PTR TO ADD'S 0142
*                                          COMMUNICATION AREA        */
         LA    R1,COMMON                                           0142
*              CALL IKJEFA12;           /* CALL 'ADD-AUGMENT'        */
         L     @15,@CV00157                                        0143
         BALR  @14,@15                                             0143
*              RFY R1 UNRSTD;           /* RELEASE PARAMETER POINTER */
*              GOTO CLEANUP0;           /* ON RETURN FROM IKJEFA12 THE
*                                          AUGMENT PROCESSING HAS BEEN
*                                          COMPLETED                 */
         B     CLEANUP0                                            0145
*              END;                                                0146
*          /**********************************************************/
*          /* THIS IS AN 'ADD-CREATE' COMMAND.  THIS SECTION ACTS    */
*          /* WITH THE UNDERSTANDING THAT THE USERID SPECIFIED IN THE*/
*          /* NODELIST DOES NOT ALREADY EXIST IN THE UADS.  IF THE   */
*          /* USERID ALREADY EXISTS, THE TERMINAL USER WILL BE SO    */
*          /* INFORMED AND RETURN WILL BE MADE TO ACCOUNT.           */
*          /**********************************************************/
*          GEN (USING IHADCB,R2)        /* ADDRESSABILITY FOR DCB    */
*            REFS(R2);                                             0147
@RF00126 DS    0H                                                  0147
         USING IHADCB,R2
*          RFY R2 RSTD;                 /* RESERVE REG FOR DCB BASE  */
*          R2=ADDR(DYNUADCB);           /* LOAD DCB POINTER          */
         LA    R2,DYNUADCB                                         0149
*          /* OPEN THE UADS FOR OUTPUT                               */
*          GEN (OPEN  ((R2),(OUTPUT)),MF=(E,DYNOPLST))             0150
*            REFS(R2,DYNOPLST);                                    0150
         OPEN  ((R2),(OUTPUT)),MF=(E,DYNOPLST)
*          /* CHECK FOR SUCCESSFUL OPEN                              */
*          IF DCBOFLGS(4)='0'B          /* OPEN FAILED               */
*            THEN                                                  0151
         TM    DCBOFLGS,B'00010000'                                0151
         BNZ   @RF00151                                            0151
*              DO;                      /* SET PARAMETERS FOR PUTLINE*/
*                OUT1SCNT='01'X;        /* 1ST LEVEL MSG SEG COUNT =1*/
         MVI   OUT1SCNT,X'01'                                      0153
*                OUT1SEG1=ADDMSG(8);    /* ADDR OF UADS NO GOOD MSG  */
         L     @10,ADDMSG+28(,MSGBASE)                             0154
         ST    @10,OUT1SEG1                                        0154
*                OUT2SCNT='01'X;        /* 2ND LEVEL MSG SEG COUNT =1*/
         MVI   OUT2SCNT,X'01'                                      0155
*                OUT2SEG1=ADDMSG(9);    /* 2ND LVL = 'CANNOT OPEN'   */
         L     @10,ADDMSG+32(,MSGBASE)                             0156
         ST    @10,OUT2SEG1                                        0156
*                GOTO ERRMSG;           /* ISSUE ERROR MSG AND QUIT  */
         B     ERRMSG                                              0157
*              END;                                                0158
*          IF DCBBLKSI=0                /* WAS BLOCK SIZE SPECIFIED? */
*            THEN                       /* NO,                       */
@RF00151 LH    @10,DCBBLKSI                                        0159
         LTR   @10,@10                                             0159
         BNZ   @RF00159                                            0159
*              DO;                      /* SET PARAMETERS FOR PUTLINE*/
*                OUT1SCNT='01'X;        /* 1ST LEVEL MSG SEG COUNT =1*/
         MVI   OUT1SCNT,X'01'                                      0161
*                OUT1SEG1=ADDMSG(8);    /* ADDR OF UADS NO GOOD MSG  */
         L     @10,ADDMSG+28(,MSGBASE)                             0162
         ST    @10,OUT1SEG1                                        0162
*                OUT2SCNT='01'X;        /* 2ND LEVEL MSG SEG COUNT =1*/
         MVI   OUT2SCNT,X'01'                                      0163
*                OUT2SEG1=ADDMSG(12);   /* 2ND LVL='BLKSIZE TOO SMALL*/
         L     @10,ADDMSG+44(,MSGBASE)                             0164
         ST    @10,OUT2SEG1                                        0164
*                GOTO ERRMSG;           /* GO TO ERROR TERMINATION   */
         B     ERRMSG                                              0165
*              END;                                                0166
*          WKAREALN=DCBBLKSI;           /* SAVE LENGTH FOR FREEMAIN  */
@RF00159 LH    @10,DCBBLKSI                                        0167
         ST    @10,WKAREALN                                        0167
*          /* DO A 'BLDL' ON THE UADS DIRECTORY TO LOOK UP USERID    */
*          GEN (BLDL  (R2),BLDLLIST)                               0168
*            REFS(R2,BLDLLIST);                                    0168
         BLDL  (R2),BLDLLIST
*          RFY R2 UNRSTD;               /* RELEASE DCB BASE REGISTER */
*          RFY R15 RSTD;                /* RESTRICT RETURN CODE REG  */
*          RETNCODE=R15;                /* SAVE RETURN CODE          */
         LR    RETNCODE,R15                                        0171
*          RFY R15 UNRSTD;              /* RELEASE RETURN CODE REG   */
*          /* MAKE CERTAIN THE USERID DOES NOT EXIST IN THE UADS     */
*          IF RETNCODE^=4                                          0173
*            THEN                       /* UNDESIRABLE RETURN CODE   */
         C     RETNCODE,@CF00049                                   0173
         BE    @RF00173                                            0173
*              DO;                      /* ASCERTAIN EXACT CAUSE     */
*                IF RETNCODE=0          /* USERID ALLREADY IN THE UAD*/
*                  THEN                                            0175
         LTR   RETNCODE,RETNCODE                                   0175
         BNZ   @RF00175                                            0175
*                    DO;                /* SET PARAMETERS FOR PUTLINE*/
*                      OUT1SCNT='03'X;  /* 1ST LEVEL MSG SEG COUNT =3*/
         MVI   OUT1SCNT,X'03'                                      0177
*                      OUT1SEG1=ADDMSG(19); /* ADDR OF 'EXISTS' MSG  */
         L     @10,ADDMSG+72(,MSGBASE)                             0178
         ST    @10,OUT1SEG1                                        0178
*                      OUT1SEG2=ADDMSG(20); /* ADDR OF 'USERID' PREF */
         L     @10,ADDMSG+76(,MSGBASE)                             0179
         ST    @10,OUT1SEG2                                        0179
*                      USRIDOF=10;      /* OFFSET FOR INSERTION      */
         MVC   USRIDOF(2),@CH00059                                 0180
*                      OUT1SEG3=ADDR(USRIDSEG); /* USERID SEG ADDR   */
         LA    @10,USRIDSEG                                        0181
         ST    @10,OUT1SEG3                                        0181
*                      GOTO ERRMSG;     /* ISSUE ERROR MSG AND QUIT  */
         B     ERRMSG                                              0182
*                    END;                                          0183
*                IF RETNCODE=8          /* DID AN I/O ERROR OCCURR   */
*                  THEN                 /* YES,                      */
@RF00175 C     RETNCODE,@CF00040                                   0184
         BNE   @RF00184                                            0184
*                    DO;                /* SET PARAMETERS FOR PUTLINE*/
*                      OUT1SCNT='01'X;  /* 1ST LEVEL MSG SEG COUNT =1*/
         MVI   OUT1SCNT,X'01'                                      0186
*                      OUT1SEG1=ADDMSG(8); /* ADDR OF UADS NO GD MSG */
         L     @10,ADDMSG+28(,MSGBASE)                             0187
         ST    @10,OUT1SEG1                                        0187
*                      OUT2SCNT='01'X;  /* 2ND LEVEL MSG SEG COUNT =1*/
         MVI   OUT2SCNT,X'01'                                      0188
*                      OUT2SEG1=ADDMSG(10); /* 2ND LVL='BLDL I/O ERR'*/
         L     @10,ADDMSG+36(,MSGBASE)                             0189
         ST    @10,OUT2SEG1                                        0189
*                      GOTO ERRMSG;     /* ISSUE ERROR MSG AND QUIT  */
         B     ERRMSG                                              0190
*                    END;                                          0191
*                /* AN INVALID RETURN CODE WAS RETURNED FROM BLDL    */
*                OUT2SEG2=ADDMSG(36);   /* 2ND. SEGMENT=BLDL         */
@RF00184 L     @10,ADDMSG+140(,MSGBASE)                            0192
         ST    @10,OUT2SEG2                                        0192
*                GO TO CMDSYSER;       /*GO TO PUT OUT 'COMMAND SYSTEM
*                                       ERROR MESSAGE' & LEAVE       */
         B     CMDSYSER                                            0193
*              END;                                                0194
*          /* NEXT, GET MAIN STORAGE IN WHICH TO BUILD A NEW USER    */
*          /* MEMBER BLOCK                                           */
*          RFY R0 RSTD;                 /* RESERVE REG. FOR GETMAIN  */
@RF00173 DS    0H                                                  0196
*          R0=WKAREALN;                 /* SET LENGTH = UADS BLKSIZE */
         L     R0,WKAREALN                                         0196
*          /* USE OS/360 GETMAIN MACRO TO OBTAIN WORK AREA.          */
*          GEN (GETMAIN EC,LV=(R0),A=WKAREAAD,MF=(E,DYNGTLST))     0197
*            REFS(R0,DYNGTLST) SETS(WKAREAAD);                     0197
         GETMAIN EC,LV=(R0),A=WKAREAAD,MF=(E,DYNGTLST)
*          RFY R15 RSTD;                /* RESTRICT RETURN CODE REG  */
*          RETNCODE=R15;                /* SAVE GETMAIN RETURN CODE  */
         LR    RETNCODE,R15                                        0199
*          RFY R15 UNRSTD;              /* RELEASE RETURN CODE REG   */
*          /* CHECK RETURN CODE                                      */
*          IF RETNCODE^=0                                          0201
*            THEN                       /* GETMAIN FAILED            */
         LTR   RETNCODE,RETNCODE                                   0201
         BNZ   @RT00201                                            0201
*              GO TO GETMERR;           /* GO PUT OUT MESSAGE & LEAVE*/
*          HEDBPTR=WKAREAAD;            /* INITIALIZE HEADER BASE PTR*/
         L     @10,WKAREAAD                                        0203
         LR    HEDBPTR,@10                                         0203
*          RFY (R1,R15) RSTD;           /* RESTRICT WORK REGISTERS   */
*          R0=WKAREAAD;                 /* GET TO ADDRESS            */
         LR    R0,@10                                              0205
*          R1=WKAREALN;                 /* LOAD R1 WITH LENGTH       */
         L     R1,WKAREALN                                         0206
*          R15=0;                       /* LOAD R15 WITH 0 LENGTH    */
         SLR   R15,R15                                             0207
*          GEN (MVCL  R0,R14)           /* CLEAR GOTTEN CORE         */
*            REFS(R0,R1,R15);                                      0208
         MVCL  R0,R14
*          RFY (R0,R1,R15) UNRSTD;      /* RELEASE WORK REGISTERS    */
*          /* INITIALIZE HEADER QUANTITIES - HEDBPTR IS BASE PTR     */
*          UADSBLNG=WKAREALN;           /* BLK LENGTH FR DCB TO BUFFR*/
         L     @10,WKAREALN                                        0210
         STH   @10,UADSBLNG(,HEDBPTR)                              0210
*          UADSFSQP=LENGTH(DHED);       /* PTR TO 1ST FSQE INITIALIZED
*                                          TO FIRST BYTE AFTER HEADER*/
         MVC   UADSFSQP(2,HEDBPTR),@CH00447                        0211
*          UADSUSER=BLDLNAME;           /* MEMBER NAME FROM BLDL LIST*/
         MVC   UADSUSER(8,HEDBPTR),BLDLNAME                        0212
*          UADSEXPF='1'B;               /* INDICATE THIS USER HAS  0213
*                                          EXPANDED HEADER     Y02678*/
         OI    UADSEXPF(HEDBPTR),B'01000000'                       0213
*          /* CHECK FOR A MAXIMUM REGION SIZE PARAMETER              */
*          IF MAXSZKEY(16)='1'B         /* WAS MAXSIZE SPECIFIED?    */
*            THEN                       /* YES,                      */
         L     @10,ADDPDLAD                                        0214
         TM    MAXSZKEY+1(@10),B'00000001'                         0214
         BNO   @RF00214                                            0214
*              UADSMAXC=MAXSZHEX;       /* SAVE BINARY VALUE         */
         LH    @10,MAXSZHEX(,@10)                                  0215
         N     @10,@CF00457                                        0215
         STH   @10,UADSMAXC(,HEDBPTR)                              0215
*          /* SET USER ATTRIBUTES                                    */
*          /* CHECK FOR OPERATOR CAPABILITY ATTRIBUTE                */
*          IF OPERKEY(16)='1'B                                     0216
*            THEN                       /* 'OPER' WAS SPECIFIED      */
@RF00214 L     @10,ADDPDLAD                                        0216
         TM    OPERKEY+1(@10),B'00000001'                          0216
         BNO   @RF00216                                            0216
*              USATR00='1'B;            /* INDICATE THAT THIS USER MAY
*                                          USE THE OPERATOR COMMANDS */
         OI    USATR00(HEDBPTR),B'10000000'                        0217
*          /* CHECK FOR ACCOUNT CAPABILITY ATTRIBUTE                 */
*          IF ACCTKEY(16)='1'B                                     0218
*            THEN                       /* 'ACCT' WAS SPECIFIED      */
@RF00216 L     @10,ADDPDLAD                                        0218
         TM    ACCTKEY+1(@10),B'00000001'                          0218
         BNO   @RF00218                                            0218
*              USATR01='1'B;            /* INDICATE THAT THIS USER MAY
*                                          USE THE ACCOUNT COMMANDS  */
         OI    USATR01(HEDBPTR),B'01000000'                        0219
*          /* CHECK FOR SUBMIT CAPABILITY ATTRIBUTE                  */
*          IF JCLKEY(16)='1'B                                      0220
*            THEN                       /* 'JCL' WAS SPECIFIED       */
@RF00218 L     @10,ADDPDLAD                                        0220
         TM    JCLKEY+1(@10),B'00000001'                           0220
         BNO   @RF00220                                            0220
*              USATR02='1'B;            /* INDICATE THAT THIS USER MAY
*                                          USE THE SUBMIT COMMAND    */
         OI    USATR02(HEDBPTR),B'00100000'                        0221
*          /* CHECK FOR MOUNT CAPABILITY ATTRIBUTE             Y02678*/
*          IF MONTKEY(16)='1'B                                     0222
*            THEN                       /* 'MOUNT' WAS SPECIFIED     */
@RF00220 L     @10,ADDPDLAD                                        0222
         TM    MONTKEY+1(@10),B'00000001'                          0222
         BNO   @RF00222                                            0222
*              USATR03='1'B;            /* INDICATE THAT THIS USER MAY
*                                          USE THE MOUNT CAPABILITY
*                                                              Y02678*/
         OI    USATR03(HEDBPTR),B'00010000'                        0223
*          IF USERKEY(16)='1'B          /* WAS USERDATA SPECIFIED?   */
*            THEN                       /* YES,                      */
@RF00222 L     @10,ADDPDLAD                                        0224
         TM    USERKEY+1(@10),B'00000001'                          0224
         BNO   @RF00224                                            0224
*              UADSINST=USDAHEX;        /* MOVE USERDATA INTO HEADER */
         MVC   UADSINST(2,HEDBPTR),USDAHEX(@10)                    0225
*          IF DESTKEY(16)='1'B          /* WAS DESTINATION SPECIFIED?*/
*            THEN                       /* YES,                      */
@RF00224 L     @10,ADDPDLAD                                        0226
         TM    DESTKEY+1(@10),B'00000001'                          0226
         BNO   @RF00226                                            0226
*              UADSDEST=DEST(1:DESTLNG);/* MOVE DESTINATION INTO   0227
*                                          HEADER              Y02678*/
         MVI   UADSDEST+1(HEDBPTR),C' '                            0227
         MVC   UADSDEST+2(6,HEDBPTR),UADSDEST+1(HEDBPTR)           0227
         LH    @05,DESTLNG(,@10)                                   0227
         BCTR  @05,0                                               0227
         L     @10,DESTADR(,@10)                                   0227
         EX    @05,@SM00462                                        0227
*          /* INITIALIZE FIRST FSQE IN WORD FOLLOWING HDR            */
*          FSQEPTR=HEDBPTR+LENGTH(DHED);/* INITIALIZE FSQE BASE PTR  */
@RF00226 LA    @10,64                                              0228
         LR    FSQEPTR,HEDBPTR                                     0228
         ALR   FSQEPTR,@10                                         0228
*          FSQELNTH=UADSBLNG-           /* LENGTH OF FREE AREA =     */
*            LENGTH(DHED);              /* TOTAL BLK LNGTH-HDR LNGTH */
         LCR   @10,@10                                             0229
         AH    @10,UADSBLNG(,HEDBPTR)                              0229
         STH   @10,FSQELNTH(,FSQEPTR)                              0229
*          FSQELBIT(7:8)='00'B;         /* TRUNCATED TO MULTIPLE OF 4*/
         NI    FSQELBIT(FSQEPTR),B'11111100'                       0230
*          FSQENEXT=0;                  /* THIS IS THE ONLY FSQE   0231
*                                          ON THE CHAIN              */
         SLR   @10,@10                                             0231
         STH   @10,FSQENEXT(,FSQEPTR)                              0231
*          SPACMPTR=HEDBPTR;            /* ADDRESS OF MEMBER BLOCK   */
         ST    HEDBPTR,SPACMPTR                                    0232
*          SPACMCNT=1;                  /* INDICATE ONE MEMBER BLOCK
*                                          IN MAIN STORAGE BUFFER    */
         MVC   SPACMCNT(2),@CH00032                                0233
*          SPACLNTH=LENGTH(UPT);        /* REQUEST FOR 16-BYTE AREA  */
         MVC   SPACLNTH(2),@CH00078                                0234
*          CALL GETSPACE;               /* CALL GETSPACE TO ACQUIRE
*                                          SPACE IN THE MEMBER BLOCK
*                                          FOR THE UPT               */
         BAL   @14,GETSPACE                                        0235
*          UADSUPTP=SPACOFST;           /* OFFSET FROM USER HDR ORIGN*/
         L     @10,SPACOFST                                        0236
         ST    @10,UADSUPTP(,HEDBPTR)                              0236
*          UPTPTR=HEDBPTR+SPACOFST;     /* POINT TO UADS UPT        1*/
         ALR   @10,HEDBPTR                                         0237
         LR    UPTPTR,@10                                          0237
*          UPTPREFX=USRID(1:7);         /* INSERT USERID            1*/
         MVC   UPTPREFX(7,UPTPTR),USRID                            0238
*          UPTPREFL=USRLEN;             /* INSERT LENGTH OF USERID  1*/
         IC    @10,USRLEN                                          0239
         STC   @10,UPTPREFL(,UPTPTR)                               0239
*          IF PERFKEY(16)='1'B          /* WAS PERF GROUP SPECIFIED? */
*            THEN                       /* YES,                      */
         L     @10,ADDPDLAD                                        0240
         TM    PERFKEY+1(@10),B'00000001'                          0240
         BNO   @RF00240                                            0240
*              DO;                      /* PUT PERF GROUPS IN MEMBER
*                                                              Y02678*/
*              SPACLNTH=32;             /* REQUEST FOR 256-BIT AREA
*                                                              Y02678*/
         MVC   SPACLNTH(2),@CH00301                                0242
*              CALL GETSPACE;           /* CALL GETSPACE TO ACQUIRE
*                                          SPACE IN THE MEMBER BLOCK
*                                          FOR THE PERF GROUPS Y02678*/
         BAL   @14,GETSPACE                                        0243
*              UADSPERP=SPACOFST;       /* POINT TO UADS PERF GROUP
*                                                              Y02678*/
         L     @10,SPACOFST                                        0244
         ST    @10,UADSPERP(,HEDBPTR)                              0244
*              PERFPTR=HEDBPTR+SPACOFST;/* REUSE PTR TO REFERENCE  0245
*                                          MEMBER BLOCK        Y02678*/
         ALR   @10,HEDBPTR                                         0245
         ST    @10,PERFPTR                                         0245
*              UADSPERG=PERFGRP;        /* MOVE PERF GROUP TO MEMBER
*                                          BLOCK               Y02678*/
         MVC   UADSPERG(32,@10),PERFGRP                            0246
*              END;                                                0247
*          /* NEXT INITIALIZE LOOP CONTROLS FOR BUILDING A USER      */
*          /* TREE OF NODES.                                         */
*          MARKMARK=ADDR(UADSPWD1)-4;   /* SET 'MARKMARK' AS IF OFFSET
*                                          TO INITIAL PASSWORD NODE
*                                          WERE PART OF A STD NODE BL*/
@RF00240 LA    MARKMARK,UADSPWD1(,HEDBPTR)                         0248
         SL    MARKMARK,@CF00049                                   0248
*          /* THE FOLLOWING DO GROUP CREATES THE NODES AND DATA FLDS */
*          /* SPECIFIED IN THE ADD COMMAND, ONE ITERATION CONSTRUCTS */
*          /* ONE NODE PLUS, IF APPLICABLE, ONE DATA FIELD.          */
*          DO LOOPCNT=NUMOFLV-1         /* GROUP WILL BE EXECUTED FOR
*                                          EACH LEVEL IN THE UADS.   */
*             BY -1 TO 1;               /* OPTIMUM LOOP CONTROLS     */
         SLR   LOOPCNT,LOOPCNT                                     0249
         IC    LOOPCNT,NUMOFLV                                     0249
         BCTR  LOOPCNT,0                                           0249
         B     @DE00249                                            0249
@DL00249 DS    0H                                                  0250
*            SPACLNTH=LENGTH(UADSNODE); /* SET GETSPACE REQUEST FOR
*                                          A NODE.                   */
         MVC   SPACLNTH(2),@CH00388                                0250
*            CALL GETSPACE;             /* CALL GETSPACE TO ACQUIRE
*                                          SPACE IN THE MEMBER BLOCK */
         BAL   @14,GETSPACE                                        0251
*            MARKMARK->UADSNSUB=SPACOFST; /* COMPUTE NEW NODE OFFSET */
         L     @10,SPACOFST                                        0252
         ST    @10,UADSNSUB(,MARKMARK)                             0252
*            UADSNPTR=MARKMARK->UADSNSUB+HEDBPTR; /* SET NEW NODE PTR*/
         ALR   @10,HEDBPTR                                         0253
         LR    UADSNPTR,@10                                        0253
*            UADSNFLG='1'B;             /* SET END-OF-LOCAL-LATERAL
*                                          CHAIN FLAG                */
         OI    UADSNFLG(UADSNPTR),B'10000000'                      0254
*            IF LOOPCNT=1               /* IS THIS THE PROCEDURE NAME*/
*              THEN                     /* YES,                      */
         C     LOOPCNT,@CF00032                                    0255
         BNE   @RF00255                                            0255
*                DO;                                               0256
*                SPACLNTH=24;           /* LENGTH OF PROCEDURE FIELD */
         MVC   SPACLNTH(2),@CH00078                                0257
*                CALL GETSPACE;         /* CALL GETSPACE TO ACQUIRE
*                                          SPACE IN THE MEMBER BLOCK */
         BAL   @14,GETSPACE                                        0258
*                UADSNDAT=SPACOFST;     /* OFFSET TO DATA FLD      0259
*                                          TO NODE SLOT              */
         L     @10,SPACOFST                                        0259
         ST    @10,UADSNDAT(,UADSNPTR)                             0259
*                UADSRPTR=UADSNDAT+HEDBPTR; /* SET PROCNAME INFO BASE*/
         ALR   @10,HEDBPTR                                         0260
         LR    UADSRPTR,@10                                        0260
*                UADSRNAM=PROCNM;       /* PROCNAME VIA PARSE PDE    */
         MVC   UADSRNAM(8,UADSRPTR),PROCNM                         0261
*                UADSUNAM='        ';   /* INITIALIZE UNITNAME=BLANKS*/
         MVC   UADSUNAM(8,UADSRPTR),@CC00401                       0262
*                /* THEN, SEE IF UNIT NAME PARAMETER WAS SPECIFIED   */
*                IF UNITKEY(16)='1'B                               0263
*                  THEN                 /* UNIT PARAMETER SPECIFIED  */
         L     @10,ADDPDLAD                                        0263
         TM    UNITKEY+1(@10),B'00000001'                          0263
         BNO   @RF00263                                            0263
*                    UADSUNAM(1:UNITNLNG)=/* MOVE UNIT NAME TO PROC  */
*                       UNITNAME;       /*    INFO FIELD             */
         LH    @15,UNITNLNG(,@10)                                  0264
         BCTR  @15,0                                               0264
         L     @10,UNITNADR(,@10)                                  0264
         EX    @15,@SM00465                                        0264
*                UADSRCTR=1;            /* SET CTR = 1 USE OF FIELD  */
@RF00263 MVI   UADSRCTR(UADSRPTR),X'01'                            0265
*                RSIZSW='0'B;           /* INITIALIZE 'EXCESSIVE SIZE'
*                                          SWITCH TO 'OFF' SETTING   */
         NI    RSIZSW,B'11101111'                                  0266
*                /* THEN, SEE IF THE 'SIZE' KEYWORD WAS SUPPLIED     */
*                IF SIZEKEY(16)='0'B                               0267
*                  THEN                 /* NO 'SIZE' SUPPLIED        */
         L     @10,ADDPDLAD                                        0267
         TM    SIZEKEY+1(@10),B'00000001'                          0267
         BZ    @RT00267                                            0267
*                    GO TO LOOPEND;     /* DEFAULT=0                 */
*                UADSRSIZ=SIZEHEX;      /* SAVE BINARY VALUE         */
         LH    @10,SIZEHEX(,@10)                                   0269
         N     @10,@CF00457                                        0269
         STH   @10,UADSRSIZ(,UADSRPTR)                             0269
*                /* SEE IF 'UADSRSIZ' HAS TO BE CHECKED FOR MAX LIMIT*/
*                IF UADSMAXC=0                                     0270
*                  THEN                 /* NO LIMIT TO MAXIMUM SIZE  */
         LH    @10,UADSMAXC(,HEDBPTR)                              0270
         N     @10,@CF00457                                        0270
         LTR   @10,@10                                             0270
         BZ    @RT00270                                            0270
*                    GO TO LOOPEND;     /* LEAVE NOW - NO CHECK NEEDD*/
*                /* MAKE CERTAIN 'UADSRSIZ' DOESN'T EXCEED 'UADSMAXC'*/
*                IF UADSMAXC<UADSRSIZ                              0272
*                  THEN                 /* 'SIZE' VALUE TOO LARGE    */
         CLC   UADSMAXC(2,HEDBPTR),UADSRSIZ(UADSRPTR)              0272
         BNL   @RF00272                                            0272
*                    DO;                                           0273
*                      UADSRSIZ=UADSMAXC;/* OVERRIDE WITH 'UADSMAXC' */
         LH    @10,UADSMAXC(,HEDBPTR)                              0274
         N     @10,@CF00457                                        0274
         STH   @10,UADSRSIZ(,UADSRPTR)                             0274
*                      RSIZSW='1'B;     /* SIGNAL FOR EXCESSIVE SIZE
*                                          MESSAGE                   */
         OI    RSIZSW,B'00010000'                                  0275
*                    END;                                          0276
*                END;                                              0277
*              ELSE                                                0278
*            IF LOOPCNT=2               /*IS THIS THE ACCOUNT NO.    */
*              THEN                     /* YES,                      */
         B     @RC00255                                            0278
@RF00255 C     LOOPCNT,@CF00100                                    0278
         BNE   @RF00278                                            0278
*                DO;                                               0279
*                IF ACCTNO(1:2)='* '    /* CHECK FOR '*'             */
*                  THEN                 /* AN '*' WAS SPECIFIED      */
         CLC   ACCTNO(2),@CC00409                                  0280
         BE    @RT00280                                            0280
*                    GO TO LOOPEND;     /* GO TO BUMP PTRS AND LOOP  */
*                SPACLNTH=ACTLEN+45;    /* LENGTH OF ACCT. NO. FIELD */
         SLR   @10,@10                                             0282
         IC    @10,ACTLEN                                          0282
         LA    @10,45(,@10)                                        0282
         STH   @10,SPACLNTH                                        0282
*                CALL GETSPACE;         /* CALL GETSPACE TO ACQUIRE
*                                          SPACE IN THE MEMBER BLOCK */
         BAL   @14,GETSPACE                                        0283
*                UADSNDAT=SPACOFST;     /* OFFSET TO DATA FLD      0284
*                                          TO NODE SLOT              */
         L     @10,SPACOFST                                        0284
         ST    @10,UADSNDAT(,UADSNPTR)                             0284
*                UADSAPTR=UADSNDAT+HEDBPTR; /* SET ACCT NO. INFO BASE*/
         ALR   @10,HEDBPTR                                         0285
         LR    UADSAPTR,@10                                        0285
*                UADSALEN=ACTLEN;       /* ACCT NO. LENGTH FROM PDE  */
         SLR   @10,@10                                             0286
         IC    @10,ACTLEN                                          0286
         STC   @10,UADSALEN(,UADSAPTR)                             0286
*                UADSANUM(1:ACTLEN)=    /* ACCT NO. FROM NODELIST TAB*/
*                   ACCTNO;                                        0287
         BCTR  @10,0                                               0287
         EX    @10,@SM00468                                        0287
*                UADSACTR=1;            /* SET CTR = 1 USE OF FIELD  */
         MVI   UADSACTR(UADSAPTR),X'01'                            0288
*                END;                                              0289
*              ELSE                                                0290
*                DO;                                               0290
         B     @RC00278                                            0290
@RF00278 DS    0H                                                  0291
*                IF PASSWD(1:2)='* '    /* CHECK FOR '*'             */
*                  THEN                 /* AN '*' WAS SPECIFIED      */
         CLC   PASSWD(2),@CC00409                                  0291
         BE    @RT00291                                            0291
*                    GO TO LOOPEND;     /* GO TO BUMP PTRS AND LOOP  */
*                SPACLNTH=12;           /* LENGTH OF PASSWORD FIELD  */
         MVC   SPACLNTH(2),@CH00388                                0293
*                CALL GETSPACE;         /* CALL GETSPACE TO ACQUIRE
*                                          SPACE IN THE MEMBER BLOCK */
         BAL   @14,GETSPACE                                        0294
*                UADSNDAT=SPACOFST;     /* OFFSET TO DATA FLD      0295
*                                          TO NODE SLOT              */
         L     @10,SPACOFST                                        0295
         ST    @10,UADSNDAT(,UADSNPTR)                             0295
*                UADSPPTR=UADSNDAT+HEDBPTR; /* SET PASSWORD INFO BASE*/
         ALR   @10,HEDBPTR                                         0296
         LR    UADSPPTR,@10                                        0296
*                UADSPPWD=PASSWD;       /* PASSWORD VIA PDE          */
         MVC   UADSPPWD(8,UADSPPTR),PASSWD                         0297
*                UADSPCTR=1;            /* SET CTR = 1 USE OF FIELD  */
         MVI   UADSPCTR(UADSPPTR),X'01'                            0298
*                END;                                              0299
*LOOPEND:    /* BUMP LOCATING POINTERS TO NEXT DATA ITEM             */
*            MARKMARK=UADSNPTR;         /* NEW NODE BECOMES OLD      */
@RC00278 DS    0H                                                  0300
@RC00255 DS    0H                                                  0300
LOOPEND  LR    MARKMARK,UADSNPTR                                   0300
*          END;                         /* END OF ITERATIVE DO-GROUP -
*                                          RETURN TO TOP FOR THE NEXT
*                                          LOWER LEVEL IN THE UADS.  */
         BCTR  LOOPCNT,0                                           0301
@DE00249 LTR   LOOPCNT,LOOPCNT                                     0301
         BP    @DL00249                                            0301
*          /**********************************************************/
*          /* AT THIS POINT, A COMPLETE USER ENTRY EXISTS IN THE WORK*/
*          /* AREA IN MAIN STORAGE - ALL THAT REMAINS IS TO WRITE THE*/
*          /* AREA OUT TO THE UADS AS A NEW MEMBER AND CLOSE THE UADS*/
*          /**********************************************************/
*          /* CHECK FOR USER ATTENTION INTERRUPT BEFORE WRITE OPNS   */
*          IF ATTENTN='1'B                                         0302
*            THEN                       /* USER WANTS ATTENTION      */
         L     @10,ACCTECBP(,ACCTPLP)                              0302
         TM    ATTENTN(@10),B'01000000'                            0302
         BO    @RT00302                                            0302
*              GO TO CLEANUP0;          /* STOP -GO DIRECTLY TO CLNUP*/
*          /* COMPLETE PARAMETER BLOCK FOR IKJEFA52- WRITE SUBROUTINE*/
*          ACIOMPTR=ADDR(UADSUSER);     /* USER NAME RIGHT FROM HEADR*/
         LA    @10,UADSUSER(,HEDBPTR)                              0304
         ST    @10,ACIOMPTR                                        0304
*          ACIOBUFR=HEDBPTR;            /* ADDRESS OF OUTPUT BUFFER  */
         STCM  HEDBPTR,7,ACIOBUFR                                  0305
*          RFY R1 RSTD;                 /* RESTRICT PARAMETER POINTER*/
*          R1=ACIOPTR;                  /* INITIALIZE PTR TO READ/WRITE
*                                          PARAMETER LIST            */
         L     R1,ACIOPTR                                          0307
*          CALL IKJEFA52;               /* INVOKE WRITE PGM -IKJEFA52*/
         L     @15,@CV00158                                        0308
         BALR  @14,@15                                             0308
*          RFY R1 UNRSTD;               /* RELEASE PARAMETER POINTER */
*          RFY R15 RSTD;                /* RESTRICT RETURN CODE REG  */
*          RETNCODE=R15;                /* SAVE RETURN CODE          */
         LR    RETNCODE,R15                                        0311
*          RFY R15 UNRSTD;              /* RELEASE RETURN CODE REG   */
*          /* CHECK RETURN CODE                                      */
*          IF RETNCODE^=0                                          0313
*            THEN                       /* WRITE ROUTINE FAILED      */
         LTR   RETNCODE,RETNCODE                                   0313
         BZ    @RF00313                                            0313
*              DO;                                                 0314
*                ERRFLG='1'B;           /* TURN ON ERROR FLAG        */
         OI    ERRFLG,B'01000000'                                  0315
*                GO TO CLEANUP0;        /* MSG. ALREADY PUT OUT -  0316
*                                          JUST CLEAN UP AND LEAVE   */
         B     CLEANUP0                                            0316
*              END;                                                0317
*          /* NOW, STOW NEW USERID IN UADS DIRECTORY                 */
*          STOWNAME=BLDLNAME;           /* MEMBER NAME FROM BLDL LIST*/
@RF00313 MVC   STOWNAME(8),BLDLNAME                                0318
*          RFY R2 RSTD;                 /* RESTRICT DCB PTR          */
*          R2=ADDR(DYNUADCB);           /* POINT TO OUTPUT DCB       */
         LA    R2,DYNUADCB                                         0320
*          /* ISSUE OS/360 STOW MACRO TO CREATE A NEW DIRECTORY ENTRY*/
*          GEN (STOW  (R2),STOWLIST,A)  /* 'A' MEANS ADD NEW ENTRY   */
*            REFS(R2,STOWLIST);                                    0321
         STOW  (R2),STOWLIST,A
*          RFY R2 UNRSTD;               /* RELEASE DCB BASE REGISTER */
*          RFY R15 RSTD;                /* RESTRICT RETURN CODE REG  */
*          RETNCODE=R15;                /* SAVE RETURN CODE          */
         LR    RETNCODE,R15                                        0324
*          RFY R15 UNRSTD;              /* RELEASE RETURN CODE REG   */
*          /* CHECK RETURN CODE                                      */
*          IF RETNCODE^=0                                          0326
*            THEN                       /* STOW FAILED               */
         LTR   RETNCODE,RETNCODE                                   0326
         BNZ   @RT00326                                            0326
*              GO TO STOWERR;           /* GO ANALYZE FAILURE        */
*          /* BUILD RETURN PARAMETER LIST FOR ACCOUNT                */
*          /* FIRST, GET DYNAMIC STORAGE FOR RETURN PARAMETER TO ACCT*/
*          GEN (GETMAIN EC,LV=16,A=UIDLAD,MF=(E,DYNGTLST))         0328
*            SETS(UIDLAD) REFS(DYNGTLST);                          0328
         GETMAIN EC,LV=16,A=UIDLAD,MF=(E,DYNGTLST)
*          RFY R15 RSTD;                /* RESTRICT RETURN CODE REG  */
*          RETNCODE=R15;                /* SAVE RETURN CODE          */
         LR    RETNCODE,R15                                        0330
*          RFY R15 UNRSTD;              /* RELEASE RETURN CODE REG   */
*          /* CHECK RETURN CODE                                      */
*          IF RETNCODE^=0                                          0332
*            THEN                       /* GETMAIN FAILED            */
         SLR   @10,@10                                             0332
         CR    RETNCODE,@10                                        0332
         BNE   @RT00332                                            0332
*              GO TO GETMERR;           /* GO PUT OUT MESSAGE & LEAVE*/
*          UIDLPTR=UIDLAD;              /* MOVE PTR TO ACCT PARMLIST */
         L     @15,UIDLAD                                          0334
         ST    @15,UIDLPTR(,ACCTPLP)                               0334
*          UIDLNEX=0;                   /* ZERO CHAIN ELEMENT        */
         ST    @10,UIDLNEX(,@15)                                   0335
*          UIDLSWS='8000'X;             /* SET SWITCH INDICATING   0336
*                                          'ADD' USERID              */
         MVC   UIDLSWS(2,@15),@CB00413                             0336
*          UIDLCT=1;                    /* INDICATE ONLY ONE USERID  */
         MVC   UIDLCT(2,@15),@CH00032                              0337
*          UIDUSER(1)=USERID;           /* USERID FROM MSG. SEGMENT  */
         MVI   UIDUSER+7(@15),C' '                                 0338
         MVC   UIDUSER(7,@15),USERID                               0338
*          /* CHECK FOR 'EXCESSIVE SIZE' CONDITION                   */
*          IF RSIZSW='1'B                                          0339
*            THEN                       /* 'SIZE' EXCEEDED 'MAXSIZE' */
         TM    RSIZSW,B'00010000'                                  0339
         BNO   @RF00339                                            0339
*              DO;                                                 0340
*                /* PUT OUT A MESSAGE TO THE TERMINAL USER AT THIS   */
*                /* TIME INFORMING HIM THAT SIZE EXCEEDED MAXSIZE    */
*                OUT1LINK=0;            /* INDICATE NO 2ND LEVEL MSG */
         ST    @10,OUT1LINK                                        0341
*                OUT1SCNT='03'X;        /* 1ST LEVEL MSG SEG COUNT =3*/
         MVI   OUT1SCNT,X'03'                                      0342
*                OUT1SEG1=ADDMSG(27);   /* ADDR OF 'SIZE > MAXSIZE'  */
         L     @10,ADDMSG+104(,MSGBASE)                            0343
         ST    @10,OUT1SEG1                                        0343
*                SIZLN=SIZNOLNG+4;      /* LENGTH OF SIZE SEGMENT    */
         L     @10,ADDPDLAD                                        0344
         LH    @01,SIZNOLNG(,@10)                                  0344
         LA    @01,4(,@01)                                         0344
         STH   @01,SIZLN                                           0344
*                SIZOF=22;              /* OFFSET FOR TEXT INSERTION */
         MVC   SIZOF(2),@CH00415                                   0345
*                SIZ=SIZE;              /* TEXT (SIZE)               */
         L     @10,SIZNOADR(,@10)                                  0346
         MVC   SIZ(5),SIZE(@10)                                    0346
*                OUT1SEG2=ADDR(SIZSEG); /* ADDR OF 'SIZE' SEGMENT    */
         LA    @10,SIZSEG                                          0347
         ST    @10,OUT1SEG2                                        0347
*                USRIDOF=55;            /* OFFSET FOR USERID INSERTN */
         MVC   USRIDOF(2),@CH00416                                 0348
*                OUT1SEG3=ADDR(USRIDSEG); /* ADDR OF USERID SEGMENT  */
         LA    @10,USRIDSEG                                        0349
         ST    @10,OUT1SEG3                                        0349
*                CALL INFOMSG;          /* GO PUT OUT MSG AND RETURN */
         BAL   @14,INFOMSG                                         0350
*              END;                                                0351
*          OUT1LINK=0;                  /* INDICATE NO 2ND LEVEL MSG */
@RF00339 SLR   @10,@10                                             0352
         ST    @10,OUT1LINK                                        0352
*          OUT1SCNT='01'X;              /* 1ST LEVEL MSG SEG COUNT =1*/
         MVI   OUT1SCNT,X'01'                                      0353
*          OUT1SEG1=ADDMSG(1);          /* PTR TO 'ADDED' MESSAGE    */
         L     @10,ADDMSG(,MSGBASE)                                0354
         ST    @10,OUT1SEG1                                        0354
*          CALL INFOMSG;                /* REPORT SUCCESS TO TERMINAL*/
         BAL   @14,INFOMSG                                         0355
*          GOTO CLEANUP0;                                          0356
         B     CLEANUP0                                            0356
*ERRMSG:   /**********************************************************/
*          /* ERRMSG: CONTROL PASSED HERE TO OUTPUT AN ERROR MESSAGE */
*          /* AND SET THE ERROR FLAG                                 */
*          /**********************************************************/
*          ERRFLG='1'B;                 /* TURN ON ERROR FLAG        */
ERRMSG   OI    ERRFLG,B'01000000'                                  0357
*          /* ISSUE OS/360 PUTLINE MACRO TO WRITE THE MESSAGE        */
*          GEN (PUTLINE ,MF=(E,PUTLLIST))                          0358
*            REFS(PUTLLIST);                                       0358
         PUTLINE ,MF=(E,PUTLLIST)
*          RFY R15 RSTD;                /* RESTRICT RETURN CODE REG  */
*          RETNCODE=R15;                /* SAVE RETURN CODE          */
         LR    RETNCODE,R15                                        0360
*          RFY R15 UNRSTD;              /* RELEASE RETURN CODE REG   */
*          IF RETNCODE^=0               /* WAS PUTLINE SUCCESSFUL    */
*            THEN                       /* NO,                       */
         LTR   RETNCODE,RETNCODE                                   0362
         BZ    @RF00362                                            0362
*              PUTERR='1'B;             /* TURN ON PUTLINE ERROR FLAG*/
         OI    PUTERR,B'00100000'                                  0363
*CLEANUP0: /**********************************************************/
*          /* CTL. PASSED OR DROPPED HERE TO EXIT                    */
*          /**********************************************************/
*          /* RELEASE PARSE'S PDL                                    */
*          GEN (IKJRLSA ADDPDLAD)       /* ISSUE TSO MAC TO FREE PDL */
*            REFS(ADDPDLAD);                                       0364
@RF00362 DS    0H                                                  0364
CLEANUP0 IKJRLSA ADDPDLAD
*          /* IS THERE A PARSE PCL WORK AREA TO BE FREED ?           */
*          IF PCLPTR^=0                                            0365
*            THEN                       /* YES - MUST ISSUE FREEMAIN */
         L     @10,PCLPTR                                          0365
         LTR   @10,@10                                             0365
         BZ    @RF00365                                            0365
*              /* ISSUE OS/360 FREEMAIN                              */
*              GEN (FREEMAIN V,A=PCLPTR,MF=(E,DYNFRLST))           0366
*                REFS(PCLPTR,DYNFRLST);                            0366
         FREEMAIN V,A=PCLPTR,MF=(E,DYNFRLST)
*          /* IS THERE A 'CREATE' MODE WORK AREA TO RELEASE ?        */
*          IF WKAREAAD^=0                                          0367
*            THEN                       /* YES - MUST ISSUE FREEMAIN */
@RF00365 L     @10,WKAREAAD                                        0367
         LTR   @10,@10                                             0367
         BZ    @RF00367                                            0367
*              /* ISSUE OS/360 FREEMAIN                              */
*              GEN (FREEMAIN V,A=WKAREAAD,MF=(E,DYNFRLST))         0368
*                 REFS(WKAREAAD,WKAREAAD,DYNFRLST);                0368
         FREEMAIN V,A=WKAREAAD,MF=(E,DYNFRLST)
*          /* IS THE UADS 'OUTPUT' DCB OPEN ?                        */
*          RFY (R2) RSTD;               /* RESERVE REG. FOR DCB BASE */
@RF00367 DS    0H                                                  0370
*          R2=ADDR(DYNUADCB);           /* GET ADDRESS OF OUTPUT DCB */
         LA    R2,DYNUADCB                                         0370
*          IF DCBOFLGS(4)='1'B                                     0371
*            THEN                       /* YES - CLOSE IT            */
         TM    DCBOFLGS,B'00010000'                                0371
         BNO   @RF00371                                            0371
*              DO;                                                 0372
*              GEN (CLOSE ((R2),REREAD),MF=(E,DYNOPLST))           0373
*                REFS(R2,DYNOPLST);                                0373
         CLOSE ((R2),REREAD),MF=(E,DYNOPLST)
*              END;                                                0374
*          RFY (R2) UNRSTD;             /* RELEASE DCB BASE REGISTER */
@RF00371 DS    0H                                                  0376
*          /* IS THE UADS ENQ'D UPON?                                */
*          IF ENQSW='1'B                                           0376
*            THEN                       /* YES - DEQ                 */
         TM    ENQSW,B'10000000'                                   0376
         BNO   @RF00376                                            0376
*              DO;                                                 0377
*              /* ISSUE OS/360 DEQ MACRO TO FREE 'SYSIKJUA' RESOURCE */
*              GEN (DEQ   ,RET=NONE,MF=(E,DYNNQLST))               0378
*                REFS(MAJNAME,MINNAME,DYNNQLST);                   0378
         DEQ   ,RET=NONE,MF=(E,DYNNQLST)
*              ENQSW='0'B;              /* RESET ENQ STATUS SWITCH   */
         NI    ENQSW,B'01111111'                                   0379
*              END;                                                0380
*          IF ERRFLG='1'B               /* HAS AN ERROR OCCURRED?    */
*            THEN                                                  0381
@RF00376 TM    ERRFLG,B'01000000'                                  0381
         BNO   @RF00381                                            0381
*              ACCTECB='40FFFFFF'X;     /* SIGNAL EXCEPTION TO ACCT  */
         L     @10,ACCTECBP(,ACCTPLP)                              0382
         MVC   ACCTECB(4,@10),@CF00420                             0382
*          RETURN;                      /* RETURN TO CALLER          */
@EL00001 L     @13,4(,@13)                                         0383
@EF00001 L     @00,@SIZDATD                                        0383
         LR    @01,@11                                             0383
         FREEMAIN R,LV=(0),A=(1)
@ER00001 LM    @14,@12,12(@13)                                     0383
         BR    @14                                                 0383
*GETMERR:  /**********************************************************/
*          /* CONTROL PASSED HERE ON A GETMAIN FAILURE               */
*          /**********************************************************/
*          /* SET PARAMETERS FOR PUTLINE MESSAGE                     */
*          OUT1LINK=0;                  /* INDICATE NO 2ND LEVEL MSG */
GETMERR  SLR   @10,@10                                             0384
         ST    @10,OUT1LINK                                        0384
*          OUT1SCNT='02'X;              /* 1ST LEVEL MSG SEG COUNT =2*/
         MVI   OUT1SCNT,X'02'                                      0385
*          OUT1SEG1=ADDMSG(2);          /* ADDR OF 'NO SPACE' MESSAGE*/
         L     @10,ADDMSG+4(,MSGBASE)                              0386
         ST    @10,OUT1SEG1                                        0386
*          OUT1SEG2=ADDMSG(3);          /* 2ND SEGMT='EXECUTE COMMAND*/
         L     @10,ADDMSG+8(,MSGBASE)                              0387
         ST    @10,OUT1SEG2                                        0387
*          GOTO ERRMSG;                 /* GO TO ERROR TERMINATION   */
         B     ERRMSG                                              0388
*STOWERR:  /**********************************************************/
*          /* CONTROL PASSED HERE ON A NON-ZERO RETURN CODE FROM STOW*/
*          /**********************************************************/
*          OUT1SCNT='01'X;              /* 1ST LEVEL MSG SEG COUNT =1*/
STOWERR  MVI   OUT1SCNT,X'01'                                      0389
*          OUT1SEG1=ADDMSG(8);          /* ADDR OF UADS NO GOOD MSG  */
         L     @10,ADDMSG+28(,MSGBASE)                             0390
         ST    @10,OUT1SEG1                                        0390
*          OUT2SCNT='01'X;              /* ASSUME 1 SEGMT TO 2ND LVL */
         MVI   OUT2SCNT,X'01'                                      0391
*          /* IS THE DIRECTORY FULL ?                                */
*          IF RETNCODE=12                                          0392
*            THEN                       /* YES - DIRECTORY FULL      */
         C     RETNCODE,@CF00388                                   0392
         BNE   @RF00392                                            0392
*              DO;                                                 0393
*                OUT2SEG1=ADDMSG(13);   /* ADDR OF 'NO DIRECTRY SPACE*/
         L     @10,ADDMSG+48(,MSGBASE)                             0394
         ST    @10,OUT2SEG1                                        0394
*                GOTO ERRMSG;           /* GO TO ERROR TERMINATION   */
         B     ERRMSG                                              0395
*              END;                                                0396
*          /* WAS THE RETURN CODE 'I/O ERROR' (16)                   */
*          IF RETNCODE=16                                          0397
*            THEN                       /* YES - STOW I/O ERROR      */
@RF00392 C     RETNCODE,@CF00042                                   0397
         BNE   @RF00397                                            0397
*              DO;                                                 0398
*                OUT2SEG1=ADDMSG(11);   /* ADDR OF 'STOW I/O ERROR'  */
         L     @10,ADDMSG+40(,MSGBASE)                             0399
         ST    @10,OUT2SEG1                                        0399
*                GOTO ERRMSG;           /* GO TO ERROR TERMINATION   */
         B     ERRMSG                                              0400
*              END;                                                0401
*          /* RETURN MUST BE INVALID RETURN CODE                     */
*          OUT2SEG2=ADDMSG(41);         /* ADDR OF 'STOW' PREFIX     */
@RF00397 L     @10,ADDMSG+160(,MSGBASE)                            0402
         ST    @10,OUT2SEG2                                        0402
*          /* GO PUT OUT 'COMMAND SYSTEM ERROR' MESSAGE & TERMINATE  */
*CMDSYSER: /**********************************************************/
*          /* CONTROL PASSED HERE ON AN UNUSUAL RETURN CODE FROM A   */
*          /* SERVICE ROUTINE                                        */
*          /**********************************************************/
*          OUT1SCNT='01'X;              /* 1ST LEVEL MSG SEG COUNT =1*/
CMDSYSER MVI   OUT1SCNT,X'01'                                      0403
*          OUT1SEG1=ADDMSG(5);          /* ADDR OF 'CMD SYSTM ERROR' */
         L     @10,ADDMSG+16(,MSGBASE)                             0404
         ST    @10,OUT1SEG1                                        0404
*          OUT2SCNT='03'X;              /* 2ND LEVEL MSG SEG COUNT =3*/
         MVI   OUT2SCNT,X'03'                                      0405
*          OUT2SEG1=ADDMSG(6);          /* BASE SEGMT= 'ERROR CODE'  */
         L     @10,ADDMSG+20(,MSGBASE)                             0406
         ST    @10,OUT2SEG1                                        0406
*          CVD (RETNCODE,DECRTCD);      /* CONVERT THE RETURN CODE TO
*                                          DECIMAL                   */
         CVD   RETNCODE,DECRTCD                                    0407
*          UNPK (BCDRTNCD,DECRTCD(7:8));/*UNPACK IT INTO THE MESSAGE */
         UNPK  BCDRTNCD(2),DECRTCD+6(2)                            0408
*          ERRRTNLN=6;                  /* SET SEGMENT LENGTH        */
         MVC   ERRRTNLN(2),@CH00426                                0409
*          ERRRTNOF=22;                 /* SET SEGMENT OFFSET        */
         MVC   ERRRTNOF(2),@CH00415                                0410
*          OUT2SEG3=ADDR(ERRRTNSG);     /* 3RD SEG ADR TO OUT LN DESC*/
         LA    @10,ERRRTNSG                                        0411
         ST    @10,OUT2SEG3                                        0411
*          SIGN=SIGN×'F0'X;             /* RESET THE SIGN FIELD      */
         OI    SIGN,X'F0'                                          0412
*          GOTO ERRMSG;                 /* GO TO ERROR TERMINATION   */
         B     ERRMSG                                              0413
*GETSPACE: /**********************************************************/
*          /* GETSPACE: CALL GETSPACE ROUTINE TO ACQUIRE SPACE FOR   */
*          /* THE UADS UPT IMAGE                                     */
*          /**********************************************************/
*          PROC;                                                   0414
         B     @EL00001                                            0414
GETSPACE STM   @14,@12,@SA00002                                    0414
*          RFY R1 RSTD;                 /* RESTRICT PARAMETER POINTER*/
*          R1=ADDR(SPACPARM);           /* INITIALIZE PTR TO GETSPACE
*                                          PARAMETER LIST            */
         LA    R1,SPACPARM                                         0416
*          CALL IKJEFA53;               /* CALL GETSPACE MODULE      */
         L     @15,@CV00159                                        0417
         BALR  @14,@15                                             0417
*          RFY R1 UNRSTD;               /* RELEASE PARAMETER POINTER */
*          RFY R15 RSTD;                /* RESTRICT RETURN CODE REG  */
*          RETNCODE=R15;                /* SAVE RETURN CODE          */
         LR    RETNCODE,R15                                        0420
*          RFY R15 UNRSTD;              /* RELEASE RETURN CODE REG   */
*          /* CHECK RETURN CODE                                      */
*          IF RETNCODE>=8                                          0422
*            THEN                       /* NO SPACE AVAILABLE        */
         C     RETNCODE,@CF00040                                   0422
         BL    @RF00422                                            0422
*              DO;                      /* SET PARAMETERS FOR PUTLINE*/
*                OUT1SCNT='01'X;        /* 1ST LEVEL MSG SEG COUNT =1*/
         MVI   OUT1SCNT,X'01'                                      0424
*                OUT1SEG1=ADDMSG(8);    /* ADDR OF UADS NO GOOD MSG  */
         L     @10,ADDMSG+28(,MSGBASE)                             0425
         ST    @10,OUT1SEG1                                        0425
*                OUT2SCNT='01'X;        /* 2ND LEVEL MSG SEG COUNT =1*/
         MVI   OUT2SCNT,X'01'                                      0426
*                OUT2SEG1=ADDMSG(12);   /* 2ND LVL='BLKSIZE TOO SMALL*/
         L     @10,ADDMSG+44(,MSGBASE)                             0427
         ST    @10,OUT2SEG1                                        0427
*                RETURN TO ERRMSG;      /* GO TO ERROR TERMINATION   */
         LA    @14,ERRMSG                                          0428
         LM    @15,@12,@SA00002+4                                  0428
         BR    @14                                                 0428
*              END;                                                0429
*          END GETSPACE;                                           0430
@EL00002 DS    0H                                                  0430
@EF00002 DS    0H                                                  0430
@ER00002 LM    @14,@12,@SA00002                                    0430
         BR    @14                                                 0430
*INFOMSG:  /**********************************************************/
*          /* INFOMSG: CONTROL PASSED HERE TO OUTPUT AN INFORMATIONAL*/
*          /* DIAGNOSTIC MESSAGE                                     */
*          /**********************************************************/
*          PROC;                                                   0431
INFOMSG  STM   @14,@12,@SA00003                                    0431
*          /* ISSUE OS/360 PUTLINE MACRO TO WRITE THE MESSAGE        */
*          GEN (PUTLINE ,MF=(E,PUTLLIST))                          0432
*            REFS(PUTLLIST);                                       0432
         PUTLINE ,MF=(E,PUTLLIST)
*          RFY R15 RSTD;                /* RESTRICT RETURN CODE REG  */
*          RETNCODE=R15;                /* SAVE RETURN CODE          */
         LR    RETNCODE,R15                                        0434
*          RFY R15 UNRSTD;              /* RELEASE RETURN CODE REG   */
*          IF RETNCODE^=0               /* WAS PUTLINE SUCCESSFUL    */
*            THEN                       /* NO,                       */
         LTR   RETNCODE,RETNCODE                                   0436
         BZ    @RF00436                                            0436
*               DO;                                                0437
*                 ERRFLG='1'B;          /* TURN ON ERROR FLAG        */
*                 PUTERR='1'B;          /* TURN ON PUTLINE ERROR FLAG*/
         OI    ERRFLG,B'01100000'                                  0439
*               END;                                               0440
*          OUT1LINK=ADDR(OUTLD2);       /* RE-INITIALIZE LINKAGE TO
*                                          ASSUME 2 MESSAGE LEVELS   */
@RF00436 LA    @10,OUTLD2                                          0441
         ST    @10,OUT1LINK                                        0441
*          END INFOMSG;                                            0442
@EL00003 DS    0H                                                  0442
@EF00003 DS    0H                                                  0442
@ER00003 LM    @14,@12,@SA00003                                    0442
         BR    @14                                                 0442
*NLSTEXIT: /**********************************************************/
*          /* NLSTEXIT: CONTROL PASSED HERE FROM IKJEFA55 TO ALLOW   */
*          /* MODIFICATION OF THE PARSE PCL DEPENDING ON THE NUMBER  */
*          /* OF ITEMS IN THE NODELIST                               */
*          /**********************************************************/
*          PROC OPTIONS(NOSAVEAREA);                               0443
NLSTEXIT STM   @14,@12,12(@13)                                     0443
*          /* FIX UP ADDRESSABILITY                                  */
*          RFY (R1,R2,R13) RSTD;                                   0444
*          R2 = R1;                     /* GET SAVE AREA PTR         */
         LR    R2,R1                                               0445
*          GEN (LM  R2,R12,28(R2));     /* RESTORE REGISTERS         */
         LM  R2,R12,28(R2)
*          SAVE13 = R13;                /* SAVE IKJEFA55 SAVEAREA PTR*/
         LR    SAVE13,R13                                          0447
*          R13 = R1;                    /* SET SAVE AREA PTR         */
         LR    R13,R1                                              0448
*          RFY (R1,R2) UNRSTD;                                     0449
*          RETCODE=0;                   /* INDICATE NODELIST OK      */
         SLR   RETCODE,RETCODE                                     0450
*          IF NUMOFLV=4                 /* IS THIS A CREATE COMMAND? */
*            THEN                       /* YES,                      */
         CLI   NUMOFLV,4                                           0451
         BNE   @RF00451                                            0451
*              DO;                                                 0452
*              /*******************************************************
*              CONTROL DROPS TO HERE IF ALL NODE LEVELS ARE PRESENT
*              THE NODELIST.  THIS MEANS THAT A DATALIST IS NOT    0453
*              EXPECTED AND THEREFORE, PARSE IS MADE TO IGNORE THE 0453
*              DATA KEYWORD BY INCREASING THE PCE LENGTH OF THE PCE
*              PRECEDING THE IKJKEYWD PCE FOR 'DATA' SO THAT PARSE 0453
*              SKIPS OVER THE 'DATA' PCES (1 FOR IKJKEYWD & 1 FOR  0453
*              IKJNAME).                                           0453
*              *******************************************************/
*              /* MAKE SURE THE USERID IS NOT = '*'                  */
*              IF USRID(1)='*'                                     0453
*                THEN                   /* TOO BAD - USERID=* IS   0453
*                                          INVALID IN CREATE MODE    */
         CLI   USRID,C'*'                                          0453
         BNE   @RF00453                                            0453
*                  DO;                                             0454
*                  RETCODE=8;           /* TELL PARSE TO JUST PROMPT */
         LA    RETCODE,8                                           0455
*                  /* SET PARAMETERS FOR PARSE SECOND LEVEL MESSAGE  */
*                  OUT1LINK=0;          /* INDICATE NO 2ND LEVEL MSG */
         SLR   @10,@10                                             0456
         ST    @10,OUT1LINK                                        0456
*                  OUT1SCNT='01'X;      /* 1ST LEVEL MSG SEG COUNT =1*/
         MVI   OUT1SCNT,X'01'                                      0457
*                  OUT1SEG1=ADDMSG(26); /* ADDR OF INVALID NODELIST  */
         L     @10,ADDMSG+100(,MSGBASE)                            0458
         ST    @10,OUT1SEG1                                        0458
*                  CALL INFOMSG;        /* REPORT SUCCESS TO TERMINAL*/
         BAL   @14,INFOMSG                                         0459
*                  END;                                            0460
*                ELSE                                              0461
*                  DO;                                             0461
         B     @RC00453                                            0461
@RF00453 DS    0H                                                  0462
*                  PCEPTR=ADDR(PARSMACS)/* POINT TO NOLIM PCE        */
*                   +NOLIMLNO;                                     0462
         LH    PCEPTR,NOLIMLNO                                     0462
         AL    PCEPTR,PCLPTR                                       0462
*                  PCELNG=CREATLNG;     /* INCREASE 'NOLIM' NAME PCE
*                                          LENGTH TO ENCOMPASS     0463
*                                          DATA PCES                 */
         LH    @10,CREATLNG                                        0463
         STH   @10,PCELNG(,PCEPTR)                                 0463
*                  END;                                            0464
*              END;                                                0465
*          ELSE                                                    0466
*            DO;                                                   0466
         B     @RC00451                                            0466
@RF00451 DS    0H                                                  0467
*            /*******************************************************
*            CONTROL DROPS TO HERE IF NO GAPS WERE DISCOVERED.     0467
*            NUMOFLVL CONTAINS THE NUMBER OF ITEMS (< 4) FOUND IN  0467
*            THE NODELIST.  THIS INDICATES AUGMENT MODE.  THEREFORE,
*            THE PCE LENGTH OF THE PCE PRECEDING THE CREATE MODE   0467
*            KEYWORD PCES (OPER, ACCT, JCL, MAXSIZE, ETC.) IS INCREASED
*            TO CAUSE PARSE TO SKIP OVER THESE KEYWORDS.           0467
*            *********************************************************/
*            PCEPTR=ADDR(PARSMACS)+UNITLNGO;/* POINT TO UNIT PCE   0467
*                                              LENGTH                */
         L     @10,PCLPTR                                          0467
         LH    PCEPTR,UNITLNGO                                     0467
         ALR   PCEPTR,@10                                          0467
*            PCELNG=AUGMTLNG;            /* INCREASE 'UNIT' NAME PCE
*                                          LENGTH TO ENCOMPASS     0468
*                                          CREATE KEYWORD PCES       */
         LH    @05,AUGMTLNG                                        0468
         STH   @05,PCELNG(,PCEPTR)                                 0468
*            /* THEN, THE DATA SUBFIELD MUST BE ALTERED TO PARSE FOR */
*            /* A NUMBER OF ITEMS EQUAL TO 4-NUMOFLVL STARTING FROM  */
*            /* THE LAST ITEM.                                       */
*            PCEPTR=ADDR(PARSMACS)+DATSUBFO;/* POINT TO DATA SUBFIELD
*                                              OFFSET                */
         AH    @10,DATSUBFO                                        0469
         LR    PCEPTR,@10                                          0469
*            IF NUMOFLV=3                                          0470
*              THEN                                                0470
         CLI   NUMOFLV,3                                           0470
         BNE   @RF00470                                            0470
*                PCELNG=ONEITMOF;       /* SUBFIELD OFFSET TO      0471
*                                          PROCEDURE NAME ONLY       */
         LH    @10,ONEITMOF                                        0471
         STH   @10,PCELNG(,PCEPTR)                                 0471
*              ELSE                                                0472
*                IF NUMOFLV=2                                      0472
*                  THEN                                            0472
         B     @RC00470                                            0472
@RF00470 CLI   NUMOFLV,2                                           0472
         BNE   @RF00472                                            0472
*                    PCELNG=TWOITMOF;   /* SUBFIELD OFFSET TO JUST 0473
*                                          ACCTNMBR & PROCNAME PCES  */
         LH    @10,TWOITMOF                                        0473
         STH   @10,PCELNG(,PCEPTR)                                 0473
*            END;                                                  0474
@RF00472 DS    0H                                                  0474
@RC00470 DS    0H                                                  0475
*          R13=SAVE13;                  /* RESTORE IKJEFA55'S SAVE AREA
*                                          POINTER                   */
@RC00451 LR    R13,SAVE13                                          0475
*          RETURN CODE(RETCODE);                                   0476
         LR    @15,RETCODE                                         0476
         L     @14,12(,@13)                                        0476
         LM    @00,@12,20(@13)                                     0476
         BR    @14                                                 0476
*          END NLSTEXIT;                                           0477
*          END IKJEFA10                                            0478
*/* THE FOLLOWING INCLUDE STATEMENTS WERE FOUND IN THIS PROGRAM.      *
*/*%INCLUDE SYSLIB  (IKJEFUAD)                                        *
*/*%INCLUDE SYSLIB  (IKJEFUDL)                                        *
*/*%INCLUDE SYSLIB  (IKJIOPL )                                        *
*/*%INCLUDE SYSLIB  (IKJPPL  )                                        *
*/*%INCLUDE SYSLIB  (IKJPTPB )                                        *
*/*%INCLUDE SYSLIB  (IKJUPT  )                                        *
*;                                                                 0478
@DATA    DS    0H
@CH00426 DC    H'6'
@CH00059 DC    H'10'
@CH00257 DC    H'14'
@CH00415 DC    H'22'
@CH00078 DC    H'24'
@CH00301 DC    H'32'
@CH00416 DC    H'55'
@CH00447 DC    H'64'
@SM00453 MVC   DYNLFORM(0),INLINLFM
@SM00458 MVC   UNITN(0),UNITNAME(@10)
@SM00462 MVC   UADSDEST(0,HEDBPTR),DEST(@10)
@SM00465 MVC   UADSUNAM(0,UADSRPTR),UNITNAME(@10)
@SM00468 MVC   UADSANUM(0,UADSAPTR),ACCTNO
@DATD    DSECT
         DS    0F
@SA00001 DS    18F
@SA00003 DS    15F
@SA00002 DS    0F
         DS    15F
IKJEFA10 CSECT
         DS    0F
@CF00032 DC    F'1'
@CH00032 EQU   @CF00032+2
@CF00100 DC    F'2'
@CF00049 DC    F'4'
@CF00040 DC    F'8'
@CF00388 DC    F'12'
@CH00388 EQU   @CF00388+2
@CF00042 DC    F'16'
@CF00070 DC    F'20'
@CF00420 DC    XL4'40FFFFFF'
@CF00457 DC    XL4'0000FFFF'
@DATD    DSECT
         DS    0D
ADDPDLAD DS    A
VCHKPL   DS    CL26
         ORG   VCHKPL
EXITADD  DS    AL4
EXITRTCD DS    AL4
NODEPTR  DS    AL4
PERFPTR  DS    AL4
PPLPTR   DS    AL4
SAVARAD  DS    AL4
CMDIND   DS    FL1
NUMOFLV  DS    FL1
         ORG   VCHKPL+26
NLSTTAB  DS    CL66
         ORG   NLSTTAB
USRLEN   DS    FL1
USRID    DS    CL8
PASSWD   DS    CL8
ACTLEN   DS    FL1
ACCTNO   DS    CL40
PROCNM   DS    CL8
         ORG   NLSTTAB+66
COMMON   DS    CL47
         ORG   COMMON
ACIOPTR  DS    AL4
BLDLPTR  DS    AL4
DATASUBP DS    AL4
DCBPTR   DS    AL4
ECBPTR   DS    AL4
IOPLPTR  DS    AL4
NODELADR DS    AL4
SIZEH    DS    FL2
SIZEL    DS    FL2
SIZED    DS    CL5
UNITN    DS    CL8
NUMOFLVL DS    FL1
ENQSW    DS    BL1
ERRFLG   EQU   COMMON+46
PUTERR   EQU   COMMON+46
RSIZSW   EQU   COMMON+46
@NM00017 EQU   COMMON+46
@NM00018 EQU   COMMON+46
@NM00019 EQU   COMMON+46
@NM00020 EQU   COMMON+46
         ORG   COMMON+47
         DS    CL1
PUTLLIST DS    CL16
OUTLNDS  DS    CL40
         ORG   OUTLNDS
OUT1LINK DS    AL4
@NM00021 DS    CL3
OUT1SCNT DS    CL1
OUT1SEG1 DS    AL4
OUT1SEG2 DS    AL4
OUT1SEG3 DS    AL4
OUTLD2   DS    CL20
         ORG   OUTLD2
@NM00022 DS    AL4
@NM00023 DS    CL3
OUT2SCNT DS    CL1
OUT2SEG1 DS    AL4
OUT2SEG2 DS    AL4
OUT2SEG3 DS    AL4
         ORG   OUTLNDS+40
DECRTCD  DS    CL8
ERRRTNSG DS    CL6
         ORG   ERRRTNSG
ERRRTNLN DS    FL2
ERRRTNOF DS    FL2
BCDRTNCD DS    CL2
         ORG   BCDRTNCD
@NM00024 DS    CL1
SIGN     DS    BL1
         ORG   ERRRTNSG+6
USRIDSEG DS    CL11
         ORG   USRIDSEG
USRIDLN  DS    FL2
USRIDOF  DS    FL2
USERID   DS    CL7
         ORG   USRIDSEG+11
         DS    CL1
SIZSEG   DS    CL9
         ORG   SIZSEG
SIZLN    DS    FL2
SIZOF    DS    FL2
SIZ      DS    CL5
         ORG   SIZSEG+9
         DS    CL1
GETPTRS  DS    CL20
         ORG   GETPTRS
PCLPTR   DS    AL4
PLENGTH  DS    FL4
UIDLAD   DS    AL4
WKAREAAD DS    AL4
WKAREALN DS    FL4
         ORG   GETPTRS+20
BLDLLIST DS    CL18
         ORG   BLDLLIST
NUMOFENT DS    FL2
ENTLNGTH DS    FL2
BLDLENTY DS    CL14
         ORG   BLDLENTY
BLDLNAME DS    CL8
         ORG   BLDLLIST+18
         DS    CL2
ACIOPARM DS    CL24
         ORG   ACIOPARM
ACIOFLGS DS    BL1
         ORG   ACIOFLGS
@NM00025 DS    BL1
@NM00026 EQU   ACIOFLGS+0
@NM00027 EQU   ACIOFLGS+0
@NM00028 EQU   ACIOFLGS+0
@NM00029 EQU   ACIOFLGS+0
@NM00030 EQU   ACIOFLGS+0
@NM00031 EQU   ACIOFLGS+0
@NM00032 EQU   ACIOFLGS+0
         ORG   ACIOPARM+1
ACIODCBA DS    AL3
ACIOMPTR DS    AL4
@NM00033 DS    AL4
ACIOLINK DS    AL4
ACIONMBR DS    FL1
ACIOBUFR DS    AL3
ACIOPUTL DS    AL4
         ORG   ACIOPUTL
ACIOMSGN DS    CL1
         ORG   ACIOPARM+24
STOWLIST DS    CL14
         ORG   STOWLIST
STOWNAME DS    CL8
@NM00034 DS    CL3
STOWC    DS    CL1
@NM00035 DS    CL2
         ORG   STOWLIST+14
         DS    CL2
SPACPARM DS    CL12
         ORG   SPACPARM
@NM00036 DS    CL8
         ORG   @NM00036
SPACMPTR DS    AL4
SPACMCNT DS    FL2
SPACLNTH DS    FL2
         ORG   SPACPARM+8
@NM00037 DS    CL4
         ORG   @NM00037
SPACOFST DS    AL4
         ORG   SPACPARM+12
PERFGRP  DS    CL32
PARSLIST DS    CL28
IKJEFA10 CSECT
         DS    0F
@SIZDATD DC    AL1(1)
         DC    AL3(@ENDDATD-@DATD)
@CV00157 DC    V(IKJEFA12)
@CV00158 DC    V(IKJEFA52)
@CV00159 DC    V(IKJEFA53)
@CV00213 DC    V(MSGTABLE)
         DS    0D
PCLMODAD DC    AL4(PCLMODEL)
CREATLNG DC    AL2(SIZEPCE-NOLIMPCE)
AUGMTLNG DC    AL2(AUGMPCE-UNITPCE)
ONEITMOF DC    AL2(PROCPCE-PCLSTART-2)
TWOITMOF DC    AL2(ACCTPCE-PCLSTART-2)
UNITLNGO DC    AL2(UNITPCE-PCLSTART+2)
NOLIMLNO DC    AL2(NOLIMPCE-PCLSTART+2)
DATSUBFO DC    AL2(SIZEPCE-PCLSTART-2)
@CC00401 DC    C'        '
@CC00409 DC    C'* '
@CB00413 DC    X'8000'
MAJNAME  DC    CL8'SYSIKJUA'
MINNAME  DC    CL8'OPENUADS'
@DATD    DSECT
IKJEFA10 CSECT
         EXTRN IKJEFA55                 ADDR OF PARSE VALIDCK EXIT
         EXTRN ACCTEXTR                 ADDR OF PARSE VALIDCK EXIT
         EXTRN PASSEXTR                 ADDR OF PARSE VALIDCK EXIT
         EXTRN PROCEXTR                 ADDR OF PARSE VALIDCK EXIT
         EXTRN SIZEEXIT                 ADDR OF PARSE VALIDCK EXIT
         EXTRN USDAEXIT                 ADDR OF PARSE VALIDCK EXIT
         EXTRN PERFEXIT                 ADDR OF PARSE VALIDCK EXIT
PCLMODEL CSECT
PCLSTART EQU   *
PCLMODEL IKJPARM  DSECT=ADDPDLD
NODEPDE  IKJPOSIT PSTRING,PROMPT='(NODELIST)',VALIDCK=IKJEFA55,        *
               HELP=('NODELIST - FORMAT IS (USERID / PASSWORD / ACCOUNT*
                NUMBER / PROCEDURE NAME)')
SIZEPDE  IKJKEYWD
         IKJNAME  'SIZE',SUBFLD=SIZESUB
UNITPDE  IKJKEYWD
UNITPCE  EQU   *                   ** THIS STATEMENT MUST PRECEDE      *
                                   ** 'UNITPDE' GROUP BECAUSE THE PCE  *
                                   ** LENGTH OF 'UNIT' MAY BE MODIFIED
*                                  ** TO OVERLAP CREATE MODE PDES
         IKJNAME  'UNIT',SUBFLD=UNITSUB
OPERPDE  IKJKEYWD DEFAULT='NOOPER'
         IKJNAME  'OPER'
         IKJNAME  'NOOPER'
ACCTPDE  IKJKEYWD DEFAULT='NOACCT'
         IKJNAME  'ACCT'
         IKJNAME  'NOACCT'
JCLPDE   IKJKEYWD DEFAULT='NOJCL'
         IKJNAME  'JCL'
         IKJNAME  'NOJCL'
MONTPDE  IKJKEYWD DEFAULT='NOMOUNT'
         IKJNAME  'MOUNT'
         IKJNAME  'NOMOUNT'
USERPDE  IKJKEYWD
         IKJNAME  'USERDATA',SUBFLD=USERSUB
DESTPDE  IKJKEYWD DEFAULT='NODEST'
         IKJNAME  'DESTINATION',SUBFLD=DESTSUB
         IKJNAME  'NODEST'
PERFPDE  IKJKEYWD DEFAULT='NOPERFORM'
         IKJNAME  'PERFORM',SUBFLD=PERFSUB
         IKJNAME  'NOPERFORM'
MAXSZPDE IKJKEYWD DEFAULT='NOLIM'
         IKJNAME  'MAXSIZE',SUBFLD=MAXSUB
NOLIMPCE EQU   *                   ** THIS STATEMENT MUST PRECEDE      *
                                   ** 'NOLIMPDE' GROUP BECAUSE THE PCE *
                                   ** LENGTH OF 'NOLIM' MAY BE MODIFIED
*                                  ** TO OVERLAP 'DATAPDE' BY NLSTEXIT
         IKJNAME  'NOLIM'
AUGMPCE  EQU   *
DATAPDE  IKJKEYWD DEFAULT='DATA'
         IKJNAME  'DATA',SUBFLD=DATALIST
SIZEPCE  EQU   *
SIZESUB  IKJSUBF
SIZNO    IKJIDENT 'SIZE VALUE',MAXLNTH=5,FIRST=NUMERIC,OTHER=NUMERIC,  *
               PROMPT='REGION SIZE FOR PROCEDURE(S)',                  *
               HELP=('A NUMBER LESS THAN 65535'),VALIDCK=SIZEEXIT
UNITSUB  IKJSUBF
UNITNAM  IKJIDENT 'UNIT NAME',MAXLNTH=8,FIRST=ALPHANUM,                *
               HELP=('AN EIGHT CHARACTER DEVICE GROUP GENERIC NAME'),  *
               OTHER=ALPHANUM,PROMPT='DEVICE GROUP GENERIC NAME'
USERSUB  IKJSUBF
USERNAM  IKJIDENT 'INSTALLATION DATA',MAXLNTH=4,FIRST=ALPHANUM,        *
               OTHER=ALPHANUM,VALIDCK=USDAEXIT,                        *
               HELP=('FOUR EBCDIC CHARACTERS REPRESENTING HEX DIGITS'),*
               PROMPT='INSTALLATION DATA'
DESTSUB  IKJSUBF
DESTNAM  IKJIDENT 'DESTINATION',MAXLNTH=7,FIRST=ALPHA,                 *
               OTHER=ALPHANUM,PROMPT='DESTINATION NAME',               *
               HELP=('A SEVEN CHARACTER USERID DESTINATION')
PERFSUB  IKJSUBF
PERFNAM  IKJIDENT 'PERFORMANCE GROUP',LIST,MAXLNTH=3,FIRST=NUMERIC,    *
               OTHER=NUMERIC,VALIDCK=PERFEXIT,                         *
               PROMPT='PERFORMANCE GROUP(S)',                          *
               HELP=('A LIST OF NUMBERS BETWEEN 1 AND 255')
MAXSUB   IKJSUBF
MAXSZ    IKJIDENT 'MAXSIZE VALUE',MAXLNTH=5,FIRST=NUMERIC,             *
               OTHER=NUMERIC,                                          *
               PROMPT='MAXIMUM REGION SIZE FOR THIS USERID',           *
               HELP=('A NUMBER LESS THAN 65535'),VALIDCK=SIZEEXIT
DATALIST IKJSUBF
PASSD    IKJIDENT 'DATALIST-PASSWORD',LIST,MAXLNTH=8,                  *
               FIRST=ANY,OTHER=ALPHANUM,VALIDCK=PASSEXTR,              *
               PROMPT='DATALIST-PASSWORD'
ACCTPCE  EQU   *
ACCTD    IKJIDENT 'DATALIST-ACCOUNT NUMBER',LIST,                      *
               MAXLNTH=40,FIRST=ANY,OTHER=ANY,VALIDCK=ACCTEXTR,        *
               PROMPT='DATALIST-ACCOUNT NUMBER'
PROCPCE  EQU   *
PROCD    IKJIDENT 'DATALIST-PROCEDURE NAME',LIST,MAXLNTH=8,            *
               FIRST=ANY,OTHER=ALPHANUM,VALIDCK=PROCEXTR,              *
               PROMPT='DATALIST-PROCEDURE NAME'
         IKJENDP
@DATD    DSECT
IKJEFA10 CSECT
INLINLFM DS    0F
         DCB   DSORG=PO,DDNAME=SYSUADS,MACRF=(W),RECFM=FB,OPTCD=W
         ENQ   (MAJNAME,MINNAME,E,8,SYSTEM),MF=L
         FREEMAIN V,SP=1,MF=L              LENGTH & ADD SET BY E
         GETMAIN EC,SP=1,MF=L              LENGTH & ANS PTR SET BY E
         OPEN  (,),MF=L                    DCB & OPTION SET BY E FORM
         PUTLINE ,OUTPUT=(0,TERM,MULTLVL,INFOR),MF=L
INLINLNG DC    A(*-INLINLFM)              LENGTH OF L-FORM MACROS
@DATD    DSECT
DYNLFORM DS    0F
DYNUADCB DCB   DSORG=PO,DDNAME=SYSUADS,MACRF=(W)
DYNNQLST ENQ   (MAJNAME,,,,),MF=L         WILL BE INIT'D FROM INLINENQ
DYNFRLST FREEMAIN V,SP=1,MF=L             LENGTH & ADD SET BY E
DYNGTLST GETMAIN EC,SP=1,MF=L             WILL BE INIT'D FROM INLINGTM
DYNOPLST OPEN  (,),MF=L                   WILL BE INIT'D FROM INLINOPN
DYNPTLST PUTLINE ,MF=L                    WILL BE INIT'D FROM INLINPTL
         DCBD  DSORG=PO,DEVD=DA           DATA CONTROL BLOCK MAPPING
IKJEFA10 CSECT
         DS   0H
PATCHLOC DC ((@DATA-@PSTART)/20)X'00'
@DATD    DSECT
         ORG   *+1-(*-@DATD)/(*-@DATD) INSURE DSECT DATA
@ENDDATD EQU   *
IKJEFA10 CSECT
@00      EQU   00                      EQUATES FOR REGISTERS 0-15
@01      EQU   01
@02      EQU   02
@03      EQU   03
@04      EQU   04
@05      EQU   05
@06      EQU   06
@07      EQU   07
@08      EQU   08
@09      EQU   09
@10      EQU   10
@11      EQU   11
@12      EQU   12
@13      EQU   13
@14      EQU   14
@15      EQU   15
PCEPTR   EQU   @02
SAVE13   EQU   @04
MARKMARK EQU   @02
LOOPCNT  EQU   @05
RETNCODE EQU   @04
RETCODE  EQU   @03
MSGBASE  EQU   @06
ACCTPLP  EQU   @07
UPTPTR   EQU   @02
FSQEPTR  EQU   @02
UADSRPTR EQU   @02
UADSAPTR EQU   @02
UADSPPTR EQU   @02
UADSNPTR EQU   @03
HEDBPTR  EQU   @04
R0       EQU   @00
R1       EQU   @01
R2       EQU   @02
R13      EQU   @13
R14      EQU   @14
R15      EQU   @15
R12      EQU   @12
DHED     EQU   0
UADSMHDR EQU   DHED
UADSBLNG EQU   UADSMHDR
UADSFSQP EQU   UADSMHDR+2
UADSUSER EQU   UADSMHDR+4
UADSBN01 EQU   UADSMHDR+12
UADSEXPF EQU   UADSBN01+1
UADSMAXC EQU   UADSMHDR+14
UADSATTR EQU   DHED+16
USATR00  EQU   UADSATTR
USATR01  EQU   UADSATTR
USATR02  EQU   UADSATTR
USATR03  EQU   UADSATTR
UADSINST EQU   DHED+18
UADSUPTP EQU   DHED+20
UADSPWD1 EQU   DHED+24
UADSPERP EQU   DHED+28
UADSDEST EQU   DHED+32
UADSNODE EQU   0
UADSNWD1 EQU   UADSNODE
UADSNFLG EQU   UADSNWD1
UADSNSUB EQU   UADSNODE+4
UADSNDAT EQU   UADSNODE+8
DPOBD    EQU   0
UADSPCTR EQU   DPOBD
UADSPPWD EQU   DPOBD+4
DNOBD    EQU   0
UADSACTR EQU   DNOBD
UADSALEN EQU   DNOBD+44
UADSANUM EQU   DNOBD+45
DROBD    EQU   0
UADSRCTR EQU   DROBD
UADSRNAM EQU   DROBD+4
UADSRSIZ EQU   DROBD+14
UADSUNAM EQU   DROBD+16
UADSFSQE EQU   0
FSQELNTH EQU   UADSFSQE
FSQENEXT EQU   UADSFSQE+2
DUIDL    EQU   0
UIDLNEX  EQU   DUIDL
UIDLSWS  EQU   DUIDL+4
UIDLCT   EQU   DUIDL+6
UIDUSER  EQU   DUIDL+8
IOPL     EQU   0
IOPLIOPB EQU   IOPL+12
PPL      EQU   0
PPLPCL   EQU   PPL+12
PPLANS   EQU   PPL+16
PPLCBUF  EQU   PPL+20
PPLUWA   EQU   PPL+24
PTPB     EQU   0
PTPBOPUT EQU   PTPB+4
UPT      EQU   0
UPTSWS   EQU   UPT+12
UPTPREFX EQU   UPT+16
UPTPREFL EQU   UPT+23
ACCTPL   EQU   0
ACCTECBP EQU   ACCTPL+8
CMDBUFAD EQU   ACCTPL+12
UIDLPTR  EQU   ACCTPL+16
ACCTECB  EQU   0
ATTENTN  EQU   ACCTECB
ADDMSG   EQU   0
UADSPERG EQU   0
ADDPDL   EQU   0
SIZEKEY  EQU   ADDPDL+16
UNITKEY  EQU   ADDPDL+18
OPERKEY  EQU   ADDPDL+20
ACCTKEY  EQU   ADDPDL+22
JCLKEY   EQU   ADDPDL+24
MONTKEY  EQU   ADDPDL+26
USERKEY  EQU   ADDPDL+28
DESTKEY  EQU   ADDPDL+30
PERFKEY  EQU   ADDPDL+32
MAXSZKEY EQU   ADDPDL+34
DATAKEY  EQU   ADDPDL+36
@NM00041 EQU   ADDPDL+40
SIZNOADR EQU   @NM00041
SIZNOLNG EQU   @NM00041+4
SIZEHEX  EQU   @NM00041+6
@NM00042 EQU   ADDPDL+48
UNITNADR EQU   @NM00042
UNITNLNG EQU   @NM00042+4
@NM00044 EQU   ADDPDL+56
USDAHEX  EQU   @NM00044+6
@NM00047 EQU   ADDPDL+64
DESTADR  EQU   @NM00047
DESTLNG  EQU   @NM00047+4
@NM00049 EQU   ADDPDL+72
@NM00054 EQU   ADDPDL+84
MAXSZHEX EQU   @NM00054+6
DATASUBF EQU   ADDPDL+92
DEST     EQU   0
SIZE     EQU   0
UNITNAME EQU   0
PCLLNGTH EQU   0
PARSMACS EQU   0
PCELNG   EQU   0
PTPBPTR  EQU   IOPLIOPB
FSQELBIT EQU   FSQELNTH+1
         AGO   .@UNREFD                START UNREFERENCED COMPONENTS
@NM00056 EQU   @NM00054+4
@NM00055 EQU   @NM00054
@NM00053 EQU   @NM00049+8
@NM00052 EQU   @NM00049+6
@NM00051 EQU   @NM00049+4
@NM00050 EQU   @NM00049
@NM00048 EQU   @NM00047+6
@NM00046 EQU   @NM00044+4
@NM00045 EQU   @NM00044
@NM00043 EQU   @NM00042+6
@NM00040 EQU   ADDPDL+38
@NM00039 EQU   ADDPDL+8
@NM00038 EQU   ADDPDL
@NM00016 EQU   ACCTECB
@NM00015 EQU   ACCTPL
@NM00014 EQU   UPT+15
UPTLDEL  EQU   UPT+14
UPTCDEL  EQU   UPT+13
UPTWTP   EQU   UPTSWS
UPTMODE  EQU   UPTSWS
UPTALD   EQU   UPTSWS
UPTPAUS  EQU   UPTSWS
UPTNCOM  EQU   UPTSWS
UPTMID   EQU   UPTSWS
UPTNPRM  EQU   UPTSWS
UPTRCVR  EQU   UPTSWS
UPTUSER  EQU   UPT+2
@NM00013 EQU   UPT
PTPBFLN  EQU   PTPB+8
@NM00012 EQU   PTPB
PPLECB   EQU   PPL+8
PPLECT   EQU   PPL+4
PPLUPT   EQU   PPL
IOPLECB  EQU   IOPL+8
IOPLECT  EQU   IOPL+4
IOPLUPT  EQU   IOPL
@NM00011 EQU   UIDLSWS
UIDCHG   EQU   UIDLSWS
UIDDEL   EQU   UIDLSWS
UIDADD   EQU   UIDLSWS
@NM00010 EQU   DROBD+12
@NM00009 EQU   DROBD+1
UADSADRF EQU   DNOBD+4
@NM00008 EQU   DNOBD+1
@NM00007 EQU   DPOBD+1
UADSNNEX EQU   UADSNWD1+1
@NM00006 EQU   UADSNWD1
@NM00005 EQU   DHED+44
UADSSOUT EQU   DHED+43
UADSSUBM EQU   DHED+42
UADSSUBC EQU   DHED+41
UADSSUBH EQU   DHED+40
@NM00004 EQU   UADSATTR
USATR04  EQU   UADSATTR
@NM00003 EQU   UADSATTR
@NM00002 EQU   UADSBN01+1
UADSXUSD EQU   UADSBN01+1
UADSXBLK EQU   UADSBN01+1
UADSNUSP EQU   UADSBN01+1
@NM00001 EQU   UADSBN01
.@UNREFD ANOP                          END UNREFERENCED COMPONENTS
@RT00073 EQU   GETMERR
@RT00103 EQU   CLEANUP0
@RT00124 EQU   CLEANUP0
@RT00201 EQU   GETMERR
@RT00267 EQU   LOOPEND
@RT00270 EQU   LOOPEND
@RF00272 EQU   @RC00255
@RT00280 EQU   LOOPEND
@RT00291 EQU   LOOPEND
@RT00302 EQU   CLEANUP0
@RT00326 EQU   STOWERR
@RT00332 EQU   GETMERR
@RF00381 EQU   @EL00001
@RF00422 EQU   @EL00002
@RC00453 EQU   @RC00451
@ENDDATA EQU   *
         END   IKJEFA10,(C'PLS0952',0701,78174)
