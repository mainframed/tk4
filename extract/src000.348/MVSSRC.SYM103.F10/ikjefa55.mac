         TITLE 'IKJEFA55 - ACCOUNT / PARSE VALIDITY CHECK EXIT ROUTINES*
               S        '
IKJEFA55 CSECT ,                                                   0001
@MAINENT DS    0H                                                  0001
         USING *,@15                                               0001
         B     @PROLOG                                             0001
         DC    AL2(@EP00001-@MAINENT)
         DC    AL1(16)                                             0001
         DC    C'IKJEFA55  77.012'                                 0001
ACCTEXTR DS    0H                                                  0001
         USING *,@15                                               0001
         B     @PROLOG                                             0001
         DC    AL2(@EP00152-ACCTEXTR)
         ENTRY ACCTEXTR
PASSEXTR DS    0H                                                  0001
         USING *,@15                                               0001
         B     @PROLOG                                             0001
         DC    AL2(@EP00164-PASSEXTR)
         ENTRY PASSEXTR
PROCEXTR DS    0H                                                  0001
         USING *,@15                                               0001
         B     @PROLOG                                             0001
         DC    AL2(@EP00175-PROCEXTR)
         ENTRY PROCEXTR
USIDEXTR DS    0H                                                  0001
         USING *,@15                                               0001
         B     @PROLOG                                             0001
         DC    AL2(@EP00184-USIDEXTR)
         ENTRY USIDEXTR
SIZEEXIT DS    0H                                                  0001
         USING *,@15                                               0001
         B     @PROLOG                                             0001
         DC    AL2(@EP00299-SIZEEXIT)
         ENTRY SIZEEXIT
USDAEXIT DS    0H                                                  0001
         USING *,@15                                               0001
         B     @PROLOG                                             0001
         DC    AL2(@EP00316-USDAEXIT)
         ENTRY USDAEXIT
PERFEXIT DS    0H                                                  0001
         USING *,@15                                               0001
         B     @PROLOG                                             0001
         DC    AL2(@EP00331-PERFEXIT)
         ENTRY PERFEXIT
         DROP  @15
@PROLOG  STM   @14,@12,12(@13)                                     0001
         BALR  @12,0                                               0001
@PSTART  DS    0H                                                  0001
         USING @PSTART,@12                                         0001
         L     @00,@SIZDATD                                        0001
         GETMAIN  R,LV=(0)
         LR    @11,@01                                             0001
         USING @DATD,@11                                           0001
         ST    @13,@SA00001+4                                      0001
         LM    @15,@01,16(@13)                                     0001
         ST    @11,8(,@13)                                         0001
         LR    @13,@11                                             0001
         AH    @15,4(,@15)                                         0001
         BR    @15                                                 0001
@EP00001 DS    0H                                                  0002
*          PARSPTR=R1;                /* INITIALIZE PTR TO PARSE   0025
*                                        PARAMETER LIST              */
         LR    PARSPTR,R1                                          0025
*          RFY R1 UNRSTD;             /* RELEASE PARAMETER POINTER   */
*          FREEPTRS=FREEPTRS&&FREEPTRS;/* CLEAR FREEMAIN POINTERS    */
         XC    FREEPTRS(20),FREEPTRS                               0027
*          /* MOVE L-FORMS OF O/S MACROS INTO DYNAMIC STORAGE        */
*          DYNLFORM(1:INLINLNG) = INLINLFM(1:INLINLNG);            0028
         L     @15,INLINLNG                                        0028
         BCTR  @15,0                                               0028
         EX    @15,@SM00261                                        0028
*          SWITCHS = SWITCHS&&SWITCHS;/* CLEAR LOGIC SWITCHES        */
         XC    SWITCHS(1),SWITCHS                                  0029
*          VCHKPTR = USERWORD;        /* SAVE POINTER TO COMM AREA   */
         L     VCHKPTR,USERWORD(,PARSPTR)                          0030
*          NLSTTAB=NLSTTAB&&NLSTTAB;  /* CLEAR NODELIST TABLE        */
         L     @01,NODEPTR(,VCHKPTR)                               0031
         XC    NLSTTAB(66,@01),NLSTTAB(@01)                        0031
*          EXITRTCD = 0;              /* INITIALIZE RETURN CODE TO 0 */
         SLR   @15,@15                                             0032
         ST    @15,EXITRTCD(,VCHKPTR)                              0032
*          RETNCODE=0;                /* TELL PARSE NODELIST IS O K  */
         SLR   RETNCODE,RETNCODE                                   0033
*          NUMOFLVL=0;                /* INITIALIZE COUNTER TO ZERO  */
         SLR   NUMOFLVL,NUMOFLVL                                   0034
*          /* OBTAIN DYNAMIC STORAGE FOR PARSE PARAMETER CONTROL LIST*/
*          RFY R0 RSTD;               /* RESTRICT GETMAIN LENGTH REG */
*          R0 = PCLLNGTH;             /* SET LENGTH FOR GETMAIN      */
         L     @01,NDPCLPTR                                        0036
         LH    R0,PCLLNGTH(,@01)                                   0036
*          PLENGTH=R0;                /* SAVE PCL LENGTH FOR FREEMAIN*/
         ST    R0,PLENGTH                                          0037
*          GEN (GETMAIN EC,LV=(R0),A=PCLPTR,MF=(E,DYNGTLST))       0038
*            SETS(PCLPTR) REFS(DYNGTLST,R0);                       0038
         GETMAIN EC,LV=(R0),A=PCLPTR,MF=(E,DYNGTLST)
*          /* INITIALIZE THE PARSE PCL FROM THE MODEL.             0039
*             PCL MUST BE MOVED INTO DYNAMIC STORAGE SINCE IT      0039
*             WILL BE MODIFIED.                                      */
*          RFY (R1,R14,R15) RSTD;     /* RESTRICT WORK REGISTERS     */
*          R0=PCLPTR;                 /* GET TO ADDRESS              */
         L     R0,PCLPTR                                           0040
*          R1=PLENGTH;                /* LOAD R1 WITH LENGTH         */
         L     @05,PLENGTH                                         0041
         LR    R1,@05                                              0041
*          R14=NDPCLPTR;              /* GET FROM ADDRESS            */
         L     R14,NDPCLPTR                                        0042
*          R15=PLENGTH;               /* LOAD R15 WITH LENGTH        */
         LR    R15,@05                                             0043
*          GEN (MVCL  R0,R14)         /* MOVE PCL TO GOTTEN CORE     */
*            REFS(R0,R1,R14,R15);                                  0044
         MVCL  R0,R14
*          RFY (R0,R1,R14,R15) UNRSTD;/* RELEASE WORK REGISTERS      */
*          PCEPTR = PCLPTR+PASSLNG;   /* POINT TO PASSWORD PCE       */
         L     @15,PCLPTR                                          0046
         LH    PCEPTR,PASSLNG                                      0046
         ALR   PCEPTR,@15                                          0046
*          PCLFLAGS = PCLFLAGS&'EF'X; /* MAKE PASSWORD OPTIONAL      */
         LA    @14,239                                             0047
         SLR   @05,@05                                             0047
         IC    @05,PCLFLAGS(,PCEPTR)                               0047
         NR    @05,@14                                             0047
         STC   @05,PCLFLAGS(,PCEPTR)                               0047
*          PCEPTR = PCLPTR+ACCTLNG;   /* POINT TO ACCTNMBR PCE       */
         LH    PCEPTR,ACCTLNG                                      0048
         ALR   PCEPTR,@15                                          0048
*          PCLFLAGS = PCLFLAGS&'EF'X; /* MAKE ACCTNMBR OPTIONAL      */
         SLR   @05,@05                                             0049
         IC    @05,PCLFLAGS(,PCEPTR)                               0049
         NR    @05,@14                                             0049
         STC   @05,PCLFLAGS(,PCEPTR)                               0049
*          PCEPTR = PCLPTR+PROCLNG;   /* POINT TO PROCEDURE PCE      */
         LH    @05,PROCLNG                                         0050
         LR    @04,@15                                             0050
         ALR   @04,@05                                             0050
         LR    PCEPTR,@04                                          0050
*          PCLFLAGS = PCLFLAGS&'EF'X; /* MAKE PROCEDURE OPTIONAL     */
         SLR   @03,@03                                             0051
         IC    @03,PCLFLAGS(,PCEPTR)                               0051
         NR    @14,@03                                             0051
         STC   @14,PCLFLAGS(,PCEPTR)                               0051
*          IF CMDIND = 3              /* IS THIS A DELETE SUBCOMMAND?*/
*            THEN                     /* YES,                        */
         CLI   CMDIND(VCHKPTR),3                                   0052
         BNE   @RF00052                                            0052
*              DO;                                                 0053
*              PCEPTR = PCLPTR+PROCLNG;/* POINT TO PROC PCE          */
         LR    PCEPTR,@04                                          0054
*              PCLFLAGS = 0;          /* SET END OF PCL INDICATOR    */
         MVI   PCLFLAGS(PCEPTR),X'00'                              0055
*              PCLENDO = PROCLNG;     /* SET END OFFSET TO FOLLOW  0056
*                                        ACCTPCE                     */
         STH   @05,PCLENDO+2(,@15)                                 0056
*              END;                                                0057
*          /* OBTAIN DYNAMIC STORAGE FOR A 'BUFFER' FOR THE NODELIST */
*          RFY R0 RSTD;               /* RESERVE REG. FOR GETMAIN    */
@RF00052 DS    0H                                                  0059
*          R0=PDELEN+4;               /* LENGTH OF NODELIST + HEADR  */
         L     @09,PDEPTR(,PARSPTR)                                0059
         LA    R0,4                                                0059
         AH    R0,PDELEN(,@09)                                     0059
*          NDBUFLN=R0;                /* SAVE LENGTH FOR FREEMAIN    */
         ST    R0,NDBUFLN                                          0060
*          /* ISSUE OS/360 GETMAIN MACRO FOR A 'BUFFER'              */
*          GEN (GETMAIN EC,LV=(R0),A=NDBUFPTR,MF=(E,DYNGTLST))     0061
*            SETS(NDBUFPTR) REFS(DYNGTLST,R0);                     0061
         GETMAIN EC,LV=(R0),A=NDBUFPTR,MF=(E,DYNGTLST)
*          NDBUFLNG=NDBUFLN;          /* FILL IN BUFFER HEADER       */
         L     @09,NDBUFLN                                         0062
         L     @01,NDBUFPTR                                        0062
         STH   @09,NDBUFLNG(,@01)                                  0062
*          NDBFOFST=0;                /* SET OFFSET TO DATA ORIGIN   */
         SLR   @15,@15                                             0063
         STH   @15,NDBFOFST(,@01)                                  0063
*          /* MOVE NODELIST P-STRING INTO MAKESHIFT 'BUFFER'         */
*          RFY (R1,R14,R15) RSTD;     /* RESTRICT WORK REGISTERS     */
*          R0=NDBUFPTR+4;             /* GET TO ADDRESS              */
         L     @05,NDBUFPTR                                        0065
         LA    @04,4                                               0065
         ALR   @05,@04                                             0065
         LR    R0,@05                                              0065
*          R1=NDBUFLN-4;              /* LOAD R1 WITH LENGTH         */
         SLR   @09,@04                                             0066
         LR    R1,@09                                              0066
*          R14=PDEADD;                /* GET FROM ADDRESS            */
         L     @05,PDEPTR(,PARSPTR)                                0067
         L     R14,PDEADD(,@05)                                    0067
*          R15=NDBUFLN-4;             /* LOAD R15 WITH LENGTH        */
         LR    R15,@09                                             0068
*          GEN (MVCL  R0,R14)         /* MOVE PCL TO GOTTEN CORE     */
*            REFS(R0,R1,R14,R15);                                  0069
         MVCL  R0,R14
*          RFY (R0,R1,R14,R15) UNRSTD;/* RELEASE WORK REGISTERS      */
*          /* BUILD PARSE PARAMETER LIST (PPL) FOR NESTED PARSE      */
*          NDPRSLST(1:12)=PPLPTRA->PPL;/* FIRST THREE WORDS FROM   0071
*                                        SUBCOMMAND PPL              */
         L     @09,PPLPTRA(,VCHKPTR)                               0071
         MVC   NDPRSLST(12),PPL(@09)                               0071
*          PPLPTR=ADDR(NDPRSLST);     /* ESTABLISH PPL ADDRESSABLTY  */
         LA    PPLPTR,NDPRSLST                                     0072
*          PPLPCL=PCLPTR;             /* ADDRESS OF NODELIST PCL     */
         L     @09,PCLPTR                                          0073
         ST    @09,PPLPCL(,PPLPTR)                                 0073
*          PPLANS=ADDR(NDANSPL);      /* NODEPLAD WILL POINT TO    0074
*                                        NODELIST PDL AFTER PARSE    */
         LA    @09,NDANSPL                                         0074
         ST    @09,PPLANS(,PPLPTR)                                 0074
*          PPLCBUF=NDBUFPTR;          /* ADDR OF NODELIST 'BUFFER'   */
         L     @09,NDBUFPTR                                        0075
         ST    @09,PPLCBUF(,PPLPTR)                                0075
*          RFY R13 RSTD;                                           0076
*          PPLUWA=R13;                /* PASS ALONG ADDR OF MAINLINE
*                                        REG SAVE AREA SO THAT     0077
*                                        VALIDITY CHECK EXIT ROUTINES
*                                        CAN RESTORE ADDRESSABILITY  */
         ST    R13,PPLUWA(,PPLPTR)                                 0077
*          RFY R13 UNRSTD;                                         0078
*          PASSSW='0'B;               /* INITIALIZE PASSWORD STATUS
*                                        SWITCH TO SIGNAL 'PASSWORD
*                                        EXIT ROUTINE NOT EXECUTING  */
         NI    PASSSW,B'10111111'                                  0079
*          /* LINK TO PARSE ROUTINE                                  */
*          GEN (LINK  EP=IKJPARS,MF=(E,NDPRSLST))                  0080
*            FLOWS(USIDEXIT,PASSEXIT,ACCTEXIT,PROCEXIT) REFS(NDPRSLST);
         LINK  EP=IKJPARS,MF=(E,NDPRSLST)
*          RFY R15 RSTD;              /* RESTRICT RETURN CODE REG    */
*          PARSRTCD=R15;              /* SAVE RETURN CODE            */
         LR    PARSRTCD,R15                                        0082
*          RFY R15 UNRSTD;            /* RELEASE RETURN CODE REG     */
*          /* CHECK RETURN CODE                                      */
*          IF PARSRTCD^=0                                          0084
*            THEN                     /* PARSE EXCEPTION             */
         LTR   PARSRTCD,PARSRTCD                                   0084
         BZ    @RF00084                                            0084
*                DO;                                               0085
*                IF PARSRTCD^=20      /* DID IKJDEXIT SAVE THE     0086
*                                        RETURN CODE?                */
*                  THEN               /* NO,                         */
         C     PARSRTCD,@CF00187                                   0086
         BE    @RF00086                                            0086
*                    EXITRTCD=PARSRTCD; /* SAVE THE RETURN CODE      */
         ST    PARSRTCD,EXITRTCD(,VCHKPTR)                         0087
*                RETNCODE=12;         /* TELL PARSE TO QUIT          */
@RF00086 LA    RETNCODE,12                                         0088
*                GOTO NDCLNUP;        /* GO TO ERROR TERMINATION     */
         B     NDCLNUP                                             0089
*                END;                                              0090
*          /* NOW, COUNT THE ITEMS FOUND BY PARSE IN THE NODELIST    */
*          PDLPTR=NODEPLAD+8;         /* INITIALIZE PTR TO PDL       */
@RF00084 LA    PDLPTR,8                                            0091
         L     @09,NODEPLAD-1                                      0091
         LA    @09,0(,@09)                                         0091
         ALR   PDLPTR,@09                                          0091
*          /* LOOK AT PDE FLAGS TO ASCERTAIN PRESENCE OF NODE        */
*          IF PDLFLG(1)='0'B          /* WAS USERID SPECIFIED?       */
*            THEN                     /* NO,                         */
         TM    PDLFLG(PDLPTR),B'10000000'                          0092
         BNZ   @RF00092                                            0092
*              DO;                                                 0093
*              RETNCODE=4;            /* TELL PARSE TO PROMPT        */
         LA    RETNCODE,4                                          0094
*              GOTO NDCLNUP;          /* GO TO ERROR TERMINATION     */
         B     NDCLNUP                                             0095
*              END;                                                0096
*          USRID=NODEITEM(1:PDLLEN);  /* PUT USERID IN NODELIST TAB  */
@RF00092 L     @09,NODEPTR(,VCHKPTR)                               0097
         MVI   USRID+1(@09),C' '                                   0097
         MVC   USRID+2(6,@09),USRID+1(@09)                         0097
         LH    @06,PDLLEN(,PDLPTR)                                 0097
         LR    @03,@06                                             0097
         BCTR  @03,0                                               0097
         L     @01,PDLADD(,PDLPTR)                                 0097
         EX    @03,@SM00264                                        0097
*          USRLEN=PDLLEN;             /* PUT USERID LENGTH INTO TAB  */
         STC   @06,USRLEN(,@09)                                    0098
*          NUMOFLVL=NUMOFLVL+1;       /* COUNT THIS NODE LEVEL       */
         LA    @06,1                                               0099
         ALR   NUMOFLVL,@06                                        0099
*          PDLPTR=PDLPTR+8;           /* STEP TO NEXT NODE-ITEM      */
         LA    @03,8                                               0100
         ALR   PDLPTR,@03                                          0100
*          IF PDLFLG(1)='0'B          /* WAS PASSWD SPECIFIED?       */
*            THEN                     /* NO,                         */
         TM    PDLFLG(PDLPTR),B'10000000'                          0101
         BZ    @RT00101                                            0101
*              GOTO EXIT;             /* GO CHECK FOR CALLERS EXIT   */
*          PASSWD=NODEITEM(1:PDLLEN); /* PUT PASSWD IN NODELIST TAB  */
         MVI   PASSWD+1(@09),C' '                                  0103
         MVC   PASSWD+2(6,@09),PASSWD+1(@09)                       0103
         LH    @15,PDLLEN(,PDLPTR)                                 0103
         BCTR  @15,0                                               0103
         L     @01,PDLADD(,PDLPTR)                                 0103
         EX    @15,@SM00266                                        0103
*          NUMOFLVL=NUMOFLVL+1;       /* COUNT THIS NODE LEVEL       */
         ALR   NUMOFLVL,@06                                        0104
*          PDLPTR=PDLPTR+8;           /* STEP TO NEXT NODE-ITEM      */
         ALR   PDLPTR,@03                                          0105
*          IF PDLFLG(1)='0'B          /* WAS ACCTNO SPECIFIED?       */
*            THEN                     /* NO,                         */
         TM    PDLFLG(PDLPTR),B'10000000'                          0106
         BZ    @RT00106                                            0106
*              GOTO EXIT;             /* GO CHECK FOR CALLERS EXIT   */
*          ACCTNO=NODEITEM(1:PDLLEN); /* PUT ACCTNO IN NODELIST TAB  */
         MVI   ACCTNO+1(@09),C' '                                  0108
         MVC   ACCTNO+2(38,@09),ACCTNO+1(@09)                      0108
         LH    @15,PDLLEN(,PDLPTR)                                 0108
         LR    @14,@15                                             0108
         BCTR  @14,0                                               0108
         L     @01,PDLADD(,PDLPTR)                                 0108
         EX    @14,@SM00268                                        0108
*          ACTLEN=PDLLEN;             /* PUT ACCTNO LENGTH INTO TAB  */
         STC   @15,ACTLEN(,@09)                                    0109
*          NUMOFLVL=NUMOFLVL+1;       /* COUNT THIS NODE LEVEL       */
         ALR   NUMOFLVL,@06                                        0110
*          PDLPTR=PDLPTR+8;           /* STEP TO NEXT NODE-ITEM      */
         ALR   PDLPTR,@03                                          0111
*          IF PDLFLG(1)='0'B          /* WAS PROCNM SPECIFIED?       */
*            THEN                     /* NO,                         */
         TM    PDLFLG(PDLPTR),B'10000000'                          0112
         BZ    @RT00112                                            0112
*              GOTO EXIT;             /* GO CHECK FOR CALLERS EXIT   */
*          PROCNM=NODEITEM(1:PDLLEN); /* PUT PROCNM IN NODELIST TAB  */
         MVI   PROCNM+1(@09),C' '                                  0114
         MVC   PROCNM+2(6,@09),PROCNM+1(@09)                       0114
         LH    @03,PDLLEN(,PDLPTR)                                 0114
         BCTR  @03,0                                               0114
         L     @01,PDLADD(,PDLPTR)                                 0114
         EX    @03,@SM00270                                        0114
*          NUMOFLVL=NUMOFLVL+1;       /* COUNT THIS NODE LEVEL       */
         ALR   NUMOFLVL,@06                                        0115
*EXIT:     NUMOFLV=NUMOFLVL;          /* SET NODE LEVEL COUNTER      */
EXIT     STC   NUMOFLVL,NUMOFLV(,VCHKPTR)                          0116
*          IF EXITADD^=0              /* IS AN EXIT SPECIFIED?       */
*            THEN                     /* YES,                        */
         L     @10,EXITADD(,VCHKPTR)                               0117
         LTR   @10,@10                                             0117
         BZ    @RF00117                                            0117
*              DO;                                                 0118
*              RFY R1 RSTD;           /* RESTRICT REGISTERS          */
*              R1=SAVARAD;            /* POINT TO SUBCOMMAND SAVE  0120
*                                          AREA                      */
         L     R1,SAVARAD(,VCHKPTR)                                0120
*              CALL SUBEXIT;          /* GO TO THE EXIT              */
         LR    @15,@10                                             0121
         BALR  @14,@15                                             0121
*              RFY R1 UNRSTD;         /* RELEASE REGISTERS           */
*              RFY R15 RSTD;                                       0123
*              RETNCODE=R15;          /* SET EXIT'S RETURN CODE      */
         LR    RETNCODE,R15                                        0124
*              RFY R15 UNRSTD;                                     0125
*              END;                                                0126
*NDCLNUP:  /* CTL. PASSED OR DROPPED HERE TO CLEAN UP                */
*          RFY R1 RSTD;               /* RESTRICT PDL POINTER REG    */
@RF00117 DS    0H                                                  0127
NDCLNUP  DS    0H                                                  0128
*          R1=ADDR(NDANSPL);          /* ADDRESS PDL POINTER @ZA16396*/
         LA    R1,NDANSPL                                          0128
*          CALL PARSREL;              /* GO TO FREE PDL AREA         */
         BAL   @14,PARSREL                                         0129
*          RFY R1 UNRSTD;             /* RELEASE PDL POINTER REG     */
*          /* WAS A PCL 'BUFFER' ACQUIRED ?                          */
*          IF PCLPTR^=NDPCLPTR                                     0131
*            THEN                     /* MUST FREEMAIN THE BUFFER    */
         CLC   PCLPTR(4),NDPCLPTR                                  0131
         BE    @RF00131                                            0131
*              DO;                                                 0132
*                RFY R0 RSTD;         /* RESTRICT PARM REGISTER      */
*                R0=PLENGTH;          /* BUFFER LENGTH TO PARM REG   */
         L     R0,PLENGTH                                          0134
*                /* ISSUE OS/360 FREEMAIN MACRO TO RELEASE BUFFER    */
*                GEN (FREEMAIN V,A=PCLPTR,MF=(E,DYNFRLST))         0135
*                  REFS(DYNFRLST,PCLPTR,PLENGTH);                  0135
         FREEMAIN V,A=PCLPTR,MF=(E,DYNFRLST)
*                RFY R0 UNRSTD;       /* RELEASE PARM REGISTER       */
*              END;                                                0137
*          /* WAS A NODELIST 'BUFFER' ACQUIRED ?                     */
*          IF NDBUFPTR^=0                                          0138
*            THEN                     /* MUST FREEMAIN THE BUFFER    */
@RF00131 L     @10,NDBUFPTR                                        0138
         LTR   @10,@10                                             0138
         BZ    @RF00138                                            0138
*              DO;                                                 0139
*                RFY R0 RSTD;         /* RESTRICT PARM REGISTER      */
*                R0=NDBUFLNG;         /* BUFFER LENGTH TO PARM REG   */
         LH    R0,NDBUFLNG(,@10)                                   0141
*                /* ISSUE OS/360 FREEMAIN MACRO TO RELEASE BUFFER    */
*                GEN (FREEMAIN V,A=NDBUFPTR,MF=(E,DYNFRLST))       0142
*                  REFS(DYNFRLST,NDBUFLN,NDBUFPTR);                0142
         FREEMAIN V,A=NDBUFPTR,MF=(E,DYNFRLST)
*                RFY R0 UNRSTD;       /* RELEASE PARM REGISTER       */
*              END;                                                0144
*          RETURN CODE(RETNCODE);                                  0145
@RF00138 L     @13,4(,@13)                                         0145
         L     @00,@SIZDATD                                        0145
         LR    @01,@11                                             0145
         FREEMAIN R,LV=(0),A=(1)
         LR    @15,@08                                             0145
         L     @14,12(,@13)                                        0145
         LM    @00,@12,20(@13)                                     0145
         BR    @14                                                 0145
*          /* PARSREL: ROUTINE TO RELEASE PARSE PDL AREA             */
*PARSREL:  PROC;                                                   0146
PARSREL  STM   @14,@12,@SA00002                                    0146
*          RFY R1 RSTD;              /* RESTRICT WORK REGISTER       */
*          IF R1 ^= 0                /* IS THERE A PDL POINTER?      */
*            THEN                    /* YES,                         */
         LTR   R1,R1                                               0148
         BZ    @RF00148                                            0148
*              GEN (IKJRLSA (R1))    /* ISSUE TSO MACRO TO FREE PDL  */
*                REFS(R1);                                         0149
         IKJRLSA (R1)
*          RFY R1 UNRSTD;            /* RELEASE WORK REGISTER        */
*          END PARSREL;                                            0151
@EL00002 DS    0H                                                  0151
@EF00002 DS    0H                                                  0151
@ER00002 LM    @14,@12,@SA00002                                    0151
         BR    @14                                                 0151
*ACCTEXTR: /* EXTERNAL ENTRY POINT TO CHECK THE VALIDITY OF AN ACCOUNT
*             NUMBER.                                                */
*          ENTRY;                                                  0152
@EP00152 DS    0H                                                  0153
*          RFY R1 RSTD;               /* RESTRICT PARAMETER POINTER  */
*          PARSPTR=R1;                /* PTR TO PARSE PARM LIST      */
         LR    PARSPTR,R1                                          0154
*          RFY R1 UNRSTD;             /* RELEASE PARAMETER POINTER   */
*          VCHKPTR = USERWORD;        /* SAVE POINTER TO COMM AREA   */
         L     VCHKPTR,USERWORD(,PARSPTR)                          0156
*          IF CMDIND^=1               /* IF THIS ISNT AN ADD COMMAND */
*           & PDELEN=1                /* AND LENGTH EQUAL ONE        */
*           & PDECHAR='*'             /* AND IT IS AN ASTERISK       */
*            THEN                     /* YES                         */
         CLI   CMDIND(VCHKPTR),1                                   0157
         BE    @RF00157                                            0157
         L     @10,PDEPTR(,PARSPTR)                                0157
         CLC   PDELEN(2,@10),@CH00032                              0157
         BNE   @RF00157                                            0157
         L     @10,PDEADD(,@10)                                    0157
         CLI   PDECHAR(@10),C'*'                                   0157
         BNE   @RF00157                                            0157
*              RETURN CODE(4);        /* TELL PARSE TO PROMPT        */
         L     @13,4(,@13)                                         0158
         L     @00,@SIZDATD                                        0158
         LR    @01,@11                                             0158
         FREEMAIN R,LV=(0),A=(1)
         LA    @15,4                                               0158
         L     @14,12(,@13)                                        0158
         LM    @00,@12,20(@13)                                     0158
         BR    @14                                                 0158
*          /* SCAN FOR AN APOSTROPHE TO END OF CHARACTER STRING      */
*          DO BYTEPTR=PDELEN TO 1 BY -1;                           0159
@RF00157 L     @10,PDEPTR(,PARSPTR)                                0159
         LH    BYTEPTR,PDELEN(,@10)                                0159
         B     @DE00159                                            0159
@DL00159 DS    0H                                                  0160
*            IF PDECHAR(BYTEPTR)='''' /* IS THIS CHAR AN APOSTROPHE  */
*              THEN                   /* YES - ACCOUNT NUMBER NG     */
         L     @10,PDEPTR(,PARSPTR)                                0160
         L     @10,PDEADD(,@10)                                    0160
         ALR   @10,BYTEPTR                                         0160
         BCTR  @10,0                                               0160
         CLI   PDECHAR(@10),C''''                                  0160
         BNE   @RF00160                                            0160
*                RETURN CODE(4);      /* TELL PARSE TO PROMPT        */
         L     @13,4(,@13)                                         0161
         L     @00,@SIZDATD                                        0161
         LR    @01,@11                                             0161
         FREEMAIN R,LV=(0),A=(1)
         LA    @15,4                                               0161
         L     @14,12(,@13)                                        0161
         LM    @00,@12,20(@13)                                     0161
         BR    @14                                                 0161
*          END;                       /* REPEAT TIL LNGTH GOES TO 0  */
@RF00160 BCTR  BYTEPTR,0                                           0162
@DE00159 LTR   BYTEPTR,BYTEPTR                                     0162
         BP    @DL00159                                            0162
*          RETURN CODE(0);            /* AND RETURN TO PARSE         */
         L     @13,4(,@13)                                         0163
         L     @00,@SIZDATD                                        0163
         LR    @01,@11                                             0163
         FREEMAIN R,LV=(0),A=(1)
         SLR   @15,@15                                             0163
         L     @14,12(,@13)                                        0163
         LM    @00,@12,20(@13)                                     0163
         BR    @14                                                 0163
*PASSEXTR: /* EXTERNAL ENTRY POINT TO CHECK THE VALIDITY OF A      0164
*             PASSWORD.                                              */
*          ENTRY;                                                  0164
@EP00164 DS    0H                                                  0165
*          RFY R1 RSTD;               /* RESTRICT PARAMETER POINTER  */
*          PARSPTR=R1;                /* PTR TO PARSE PARM LIST      */
         LR    PARSPTR,R1                                          0166
*          RFY R1 UNRSTD;             /* RELEASE PARAMETER POINTER   */
*          VCHKPTR = USERWORD;        /* SAVE POINTER TO COMM AREA   */
         L     VCHKPTR,USERWORD(,PARSPTR)                          0168
*          IF CMDIND^=1               /* IF THIS ISNT AN ADD COMMAND */
*           & PDELEN=1                /* AND LENGTH EQUAL ONE        */
*           & PDECHAR='*'             /* AND IT IS AN ASTERISK       */
*            THEN                     /* YES                         */
         CLI   CMDIND(VCHKPTR),1                                   0169
         BE    @RF00169                                            0169
         L     @10,PDEPTR(,PARSPTR)                                0169
         CLC   PDELEN(2,@10),@CH00032                              0169
         BNE   @RF00169                                            0169
         L     @10,PDEADD(,@10)                                    0169
         CLI   PDECHAR(@10),C'*'                                   0169
         BNE   @RF00169                                            0169
*              RETURN CODE(4);        /* TELL PARSE TO PROMPT        */
         L     @13,4(,@13)                                         0170
         L     @00,@SIZDATD                                        0170
         LR    @01,@11                                             0170
         FREEMAIN R,LV=(0),A=(1)
         LA    @15,4                                               0170
         L     @14,12(,@13)                                        0170
         LM    @00,@12,20(@13)                                     0170
         BR    @14                                                 0170
*          PASSSW='1'B;               /* SIGNAL THAT 'PASSEXTR' IS 0171
*                                        IN CONTROL                  */
@RF00169 OI    PASSSW,B'01000000'                                  0171
*          CALL IKJDEXIT;             /* DROP INTO ID EXIT ROUTINE   */
         BAL   @14,IKJDEXIT                                        0172
*          PASSSW='0'B;               /* RESET PASSWORD SWITCH       */
         NI    PASSSW,B'10111111'                                  0173
*          RETURN CODE(RETNCODE);     /* RETURN TO PARSE             */
         L     @13,4(,@13)                                         0174
         L     @00,@SIZDATD                                        0174
         LR    @01,@11                                             0174
         FREEMAIN R,LV=(0),A=(1)
         LR    @15,@08                                             0174
         L     @14,12(,@13)                                        0174
         LM    @00,@12,20(@13)                                     0174
         BR    @14                                                 0174
*PROCEXTR: /* EXTERNAL ENTRY POINT TO CHECK THE VALIDITY OF A      0175
*             PROCEDURE NAME.                                        */
*          ENTRY;                                                  0175
@EP00175 DS    0H                                                  0176
*          RFY R1 RSTD;               /* RESTRICT PARAMETER POINTER  */
*          PARSPTR=R1;                /* PTR TO PARSE PARM LIST      */
         LR    PARSPTR,R1                                          0177
*          RFY R1 UNRSTD;             /* RELEASE PARAMETER POINTER   */
*          VCHKPTR = USERWORD;        /* SAVE POINTER TO COMM AREA   */
         L     VCHKPTR,USERWORD(,PARSPTR)                          0179
*          IF PDELEN=1                /* IF LENGTH EQUAL ONE         */
*           & PDECHAR='*'             /* AND IT IS AN ASTERISK       */
*            THEN                     /* YES                         */
         L     @10,PDEPTR(,PARSPTR)                                0180
         CLC   PDELEN(2,@10),@CH00032                              0180
         BNE   @RF00180                                            0180
         L     @10,PDEADD(,@10)                                    0180
         CLI   PDECHAR(@10),C'*'                                   0180
         BNE   @RF00180                                            0180
*              RETURN CODE(4);        /* TELL PARSE TO PROMPT        */
         L     @13,4(,@13)                                         0181
         L     @00,@SIZDATD                                        0181
         LR    @01,@11                                             0181
         FREEMAIN R,LV=(0),A=(1)
         LA    @15,4                                               0181
         L     @14,12(,@13)                                        0181
         LM    @00,@12,20(@13)                                     0181
         BR    @14                                                 0181
*          CALL IKJDEXIT;             /* DROP INTO ID EXIT ROUTINE   */
@RF00180 BAL   @14,IKJDEXIT                                        0182
*          RETURN CODE(RETNCODE);     /* RETURN TO PARSE             */
         L     @13,4(,@13)                                         0183
         L     @00,@SIZDATD                                        0183
         LR    @01,@11                                             0183
         FREEMAIN R,LV=(0),A=(1)
         LR    @15,@08                                             0183
         L     @14,12(,@13)                                        0183
         LM    @00,@12,20(@13)                                     0183
         BR    @14                                                 0183
*USIDEXTR: /* EXTERNAL ENTRY POINT TO CHECK THE VALIDITY OF A USERID.*/
*          ENTRY;                                                  0184
@EP00184 DS    0H                                                  0185
*          RFY R1 RSTD;               /* RESTRICT PARAMETER POINTER  */
*          PARSPTR=R1;                /* PTR TO PARSE PARM LIST      */
         LR    PARSPTR,R1                                          0186
*          RFY R1 UNRSTD;             /* RELEASE PARAMETER POINTER   */
*          VCHKPTR = USERWORD;        /* SAVE POINTER TO COMM AREA   */
         L     VCHKPTR,USERWORD(,PARSPTR)                          0188
*          IF PDELEN=1                /* IF LENGTH EQUAL ONE         */
*           & PDECHAR='*'             /* AND IT IS AN ASTERISK       */
*            THEN                     /* YES                         */
         L     @10,PDEPTR(,PARSPTR)                                0189
         CLC   PDELEN(2,@10),@CH00032                              0189
         BNE   @RF00189                                            0189
         L     @10,PDEADD(,@10)                                    0189
         CLI   PDECHAR(@10),C'*'                                   0189
         BNE   @RF00189                                            0189
*              RETURN CODE(4);        /* TELL PARSE TO PROMPT        */
         L     @13,4(,@13)                                         0190
         L     @00,@SIZDATD                                        0190
         LR    @01,@11                                             0190
         FREEMAIN R,LV=(0),A=(1)
         LA    @15,4                                               0190
         L     @14,12(,@13)                                        0190
         LM    @00,@12,20(@13)                                     0190
         BR    @14                                                 0190
*          CALL IKJDEXIT;             /* DROP INTO ID EXIT ROUTINE   */
@RF00189 BAL   @14,IKJDEXIT                                        0191
*          RETURN CODE(RETNCODE);     /* RETURN TO PARSE             */
         L     @13,4(,@13)                                         0192
         L     @00,@SIZDATD                                        0192
         LR    @01,@11                                             0192
         FREEMAIN R,LV=(0),A=(1)
         LR    @15,@08                                             0192
         L     @14,12(,@13)                                        0192
         LM    @00,@12,20(@13)                                     0192
         BR    @14                                                 0192
*USIDEXIT: /* ENTRY POINT FOR FIRST-CHARACTER VALIDITY CHECK EXIT  0193
*             ROUTINE                                                */
*          PROC OPTIONS(NOSAVEAREA);                               0193
USIDEXIT STM   @14,@12,12(@13)                                     0193
*          /* FIX UP ADDRESSABILITY                                  */
*          RFY (R1,R2,R13) RSTD;      /* RESTRICT REGISTERS          */
*          R2=SAVEARP;                /* GET PTR TO SAVE AREA        */
         L     R2,SAVEARP+4(,R1)                                   0195
*          GEN (LM  R2,R12,28(R2));   /* RESTORE REGISTERS           */
         LM  R2,R12,28(R2)
*          EXITSAVE(2)=R13;           /* SAVE PARSE SAVE AREA PTR    */
         ST    R13,EXITSAVE+4                                      0197
*          R13=ADDR(EXITSAVE);        /* POINT TO SAVE AREA          */
         LA    R13,EXITSAVE                                        0198
*          USIDSW='1'B;               /* SIGNAL THAT 'USIDEXIT' IS 0199
*                                        IN CONTROL                  */
         OI    USIDSW,B'10000000'                                  0199
*          CALL IKJDEXIT;             /* DROP INTO ID EXIT ROUTINE   */
         BAL   @14,IKJDEXIT                                        0200
*          USIDSW='0'B;               /* RESET USERID SWITCH         */
         NI    USIDSW,B'01111111'                                  0201
*          R13=EXITSAVE(2);           /* RESTORE PARSE SAVE AREA PTR */
         L     R13,EXITSAVE+4                                      0202
*          RFY (R1,R2) UNRSTD;        /* RELEASE REGISTERS           */
*          RETURN CODE(RETNCODE);     /* RETURN TO PARSE             */
         LR    @15,RETNCODE                                        0204
         L     @14,12(,@13)                                        0204
         LM    @00,@12,20(@13)                                     0204
         BR    @14                                                 0204
*          END USIDEXIT;                                           0205
*          /* ENTRY POINT FOR PASSWORD VALIDITY CHECK EXIT RTNE TO 0206
*             FIX UP ADDRESSABILITY                                  */
*PASSEXIT: PROC OPTIONS(NOSAVEAREA);                               0206
PASSEXIT STM   @14,@12,12(@13)                                     0206
*          RFY (R1,R2,R13) RSTD;      /* RESTRICT REGISTERS          */
*          R2=SAVEARP;                /* GET PTR TO SAVE AREA        */
         L     R2,SAVEARP+4(,R1)                                   0208
*          GEN (LM  R2,R12,28(R2));   /* RESTORE REGISTERS           */
         LM  R2,R12,28(R2)
*          EXITSAVE(2)=R13;           /* SAVE PARSE SAVE AREA PTR    */
         ST    R13,EXITSAVE+4                                      0210
*          R13=ADDR(EXITSAVE);        /* POINT TO SAVE AREA          */
         LA    R13,EXITSAVE                                        0211
*          PASSSW='1'B;               /* SIGNAL THAT 'PASSEXIT' IS 0212
*                                        IN CONTROL                  */
         OI    PASSSW,B'01000000'                                  0212
*          PCEPTR = PCLPTR+PASSLNG;   /* POINT TO PASSWORD PCE       */
         LH    PCEPTR,PASSLNG                                      0213
         AL    PCEPTR,PCLPTR                                       0213
*          PCLFLAGS = PCLFLAGS×'10'X; /* MAKE PASSWORD REQUIRED      */
         LA    @10,16                                              0214
         SLR   @08,@08                                             0214
         IC    @08,PCLFLAGS(,PCEPTR)                               0214
         OR    @10,@08                                             0214
         STC   @10,PCLFLAGS(,PCEPTR)                               0214
*          RFY PARSLST BASED(R1);     /* RESET PARS PARM LIST PTRS   */
*          IF PDELEN > 8              /* IS THE LENGTH INVALID?      */
*            THEN                     /* YES,                        */
         L     @10,PDEPTR(,R1)                                     0216
         LH    @10,PDELEN(,@10)                                    0216
         C     @10,@CF00066                                        0216
         BNH   @RF00216                                            0216
*              RETNCODE = 4;          /* TELL PARSE TO PROMPT        */
         LA    RETNCODE,4                                          0217
*            ELSE                     /* THE LENGTH IS VALID         */
*              CALL IKJDEXIT;         /* DROP INTO ID EXIT ROUTINE   */
         B     @RC00216                                            0218
@RF00216 BAL   @14,IKJDEXIT                                        0218
*          PASSSW='0'B;               /* RESET PASSWORD SWITCH       */
@RC00216 NI    PASSSW,B'10111111'                                  0219
*          R13=EXITSAVE(2);           /* RESTORE PARSE SAVE AREA PTR */
         L     R13,EXITSAVE+4                                      0220
*          RFY PARSLST BASED(PARSPTR);/* RESET PARSE PARM LIST PTR   */
*          RFY (R1,R2) UNRSTD;        /* RELEASE REGISTERS           */
*          RETURN CODE(RETNCODE);     /* RETURN TO PARSE             */
         LR    @15,RETNCODE                                        0223
         L     @14,12(,@13)                                        0223
         LM    @00,@12,20(@13)                                     0223
         BR    @14                                                 0223
*          END PASSEXIT;                                           0224
*     /* THE ACCOUNT NUMBER VALIDITY CHECK EXIT ROUTINE EXAMINES ALL */
*     /* ACCOUNT NUMBER OPERANDS ENTERED IN ACCOUNT SUBCOMMANDS FOR  */
*     /* APOSTROPHES.  ACCOUNT NUMBERS CONTAINING APOSTROPHES ARE    */
*     /* REJECTED BECAUSE ACCOUNT NUMBERS WHICH ARE ENTERED INTO THE */
*     /* UADS MAY BE USED BY THE LOGON COMMAND PROCESSOR IN CREATING */
*     /* JOB CARD IMAGES FOR THE READER/INTERPRETER.  THE LOGON      */
*     /* PROCESSOR WILL ENCLOSE THE ACCOUNT NUMBER IN APOSTROPHES TO */
*     /* GAIN ACCEPTANCE BY THE READER/INTERPRETER OF OTHER SPECIAL  */
*     /* CHARACTERS WHICH ARE PERMITTED IN ACCOUNT NUMBERS.  EMBEDDED*/
*     /* APOSTROPHES MUST THEREFORE BE SCREENED OUT.                 */
*     /***************************************************************/
*ACCTEXIT: PROC OPTIONS(NOSAVEAREA);                               0225
ACCTEXIT STM   @14,@12,12(@13)                                     0225
*          /* FIX UP ADDRESSABILITY                                  */
*          RFY (R1,R2) RSTD;          /* RESTRICT REGISTERS          */
*          R2=SAVEARP;                /* GET PTR TO SAVE AREA        */
         L     R2,SAVEARP+4(,R1)                                   0227
*          GEN (LM  R2,R12,28(R2));   /* RESTORE REGISTERS           */
         LM  R2,R12,28(R2)
*          RETNCODE=0;                                             0229
         SLR   RETNCODE,RETNCODE                                   0229
*          PCEPTR = PCLPTR+ACCTLNG;   /* POINT TO ACCTNMBR PCE       */
         LH    PCEPTR,ACCTLNG                                      0230
         AL    PCEPTR,PCLPTR                                       0230
*          PCLFLAGS = PCLFLAGS×'10'X; /* MAKE ACCTNMBR REQUIRED      */
         LA    @10,16                                              0231
         SLR   @03,@03                                             0231
         IC    @03,PCLFLAGS(,PCEPTR)                               0231
         OR    @10,@03                                             0231
         STC   @10,PCLFLAGS(,PCEPTR)                               0231
*          RFY PARSLST BASED(R1);     /* RESET PARS PARM LIST PTRS   */
*          IF PDELEN > 40             /* IS THE LENGTH INVALID?      */
*            THEN                     /* YES,                        */
         L     @10,PDEPTR(,R1)                                     0233
         LH    @10,PDELEN(,@10)                                    0233
         C     @10,@CF00118                                        0233
         BNH   @RF00233                                            0233
*              RETNCODE = 4;          /* TELL PARSE TO PROMPT        */
         LA    RETNCODE,4                                          0234
*            ELSE                     /* THE LENGTH IS VALID         */
*              /* SCAN FOR AN APOSTROPHE TO END OF CHARACTER STRING  */
*              DO BYTEPTR=PDELEN TO 1 BY -1;                       0235
         B     @RC00233                                            0235
@RF00233 L     @10,PDEPTR(,R1)                                     0235
         LH    BYTEPTR,PDELEN(,@10)                                0235
         B     @DE00235                                            0235
@DL00235 DS    0H                                                  0236
*                IF PDECHAR(BYTEPTR)='''' /* IS CHAR AN APOSTROPHE?  */
*                  THEN               /* YES - ACCOUNT NUMBER NG     */
         L     @10,PDEPTR(,R1)                                     0236
         L     @10,PDEADD(,@10)                                    0236
         ALR   @10,BYTEPTR                                         0236
         BCTR  @10,0                                               0236
         CLI   PDECHAR(@10),C''''                                  0236
         BNE   @RF00236                                            0236
*                    RETNCODE=4;      /* TELL PARSE TO PROMPT        */
         LA    RETNCODE,4                                          0237
*              END;                   /* REPEAT TIL LNGTH GOES TO 0  */
@RF00236 BCTR  BYTEPTR,0                                           0238
@DE00235 LTR   BYTEPTR,BYTEPTR                                     0238
         BP    @DL00235                                            0238
*          RETURN CODE(RETNCODE);     /* AND RETURN TO PARSE         */
@RC00233 LR    @15,RETNCODE                                        0239
         L     @14,12(,@13)                                        0239
         LM    @00,@12,20(@13)                                     0239
         BR    @14                                                 0239
*          RFY PARSLST BASED(PARSPTR);/* RESET PARSE PARM LIST PTR   */
*          END ACCTEXIT;                                           0241
*          /* ENTRY POINT FOR PROCEDURE NAME VALIDITY CHECK EXIT   0242
*             ROUTINE                                                */
*PROCEXIT: PROC OPTIONS(NOSAVEAREA);                               0242
PROCEXIT STM   @14,@12,12(@13)                                     0242
*        /* FIX UP ADDRESSABILITY                                    */
*          RFY (R1,R2) RSTD;          /* RESTRICT REGISTERS          */
*          R2=SAVEARP;                /* GET PTR TO SAVE AREA        */
         L     R2,SAVEARP+4(,R1)                                   0244
*          GEN (LM  R2,R12,28(R2));   /* RESTORE REGISTERS           */
         LM  R2,R12,28(R2)
*          EXITSAVE(2)=R13;           /* SAVE PARSE SAVE AREA PTR    */
         ST    R13,EXITSAVE+4                                      0246
*          R13=ADDR(EXITSAVE);        /* POINT TO SAVE AREA          */
         LA    R13,EXITSAVE                                        0247
*          PROCSW='1'B;               /* SIGNAL THAT 'PROCEXIT' IS 0248
*                                        IN CONTROL                  */
         OI    PROCSW,B'00100000'                                  0248
*          PCEPTR = PCLPTR+PROCLNG;   /* POINT TO PROCEDURE PCE      */
         LH    PCEPTR,PROCLNG                                      0249
         AL    PCEPTR,PCLPTR                                       0249
*          PCLFLAGS = PCLFLAGS×'10'X; /* MAKE PROCEDURE REQUIRED     */
         LA    @10,16                                              0250
         SLR   @08,@08                                             0250
         IC    @08,PCLFLAGS(,PCEPTR)                               0250
         OR    @10,@08                                             0250
         STC   @10,PCLFLAGS(,PCEPTR)                               0250
*          RFY PARSLST BASED(R1);     /* RESET PARS PARM LIST PTRS   */
*          IF PDELEN > 8              /* IS THE LENGTH INVALID?      */
*            THEN                     /* YES,                        */
         L     @10,PDEPTR(,R1)                                     0252
         LH    @10,PDELEN(,@10)                                    0252
         C     @10,@CF00066                                        0252
         BNH   @RF00252                                            0252
*              RETNCODE = 4;          /* TELL PARSE TO PROMPT        */
         LA    RETNCODE,4                                          0253
*            ELSE                     /* THE LENGTH IS VALID         */
*              CALL IKJDEXIT;         /* DROP INTO ID EXIT ROUTINE   */
         B     @RC00252                                            0254
@RF00252 BAL   @14,IKJDEXIT                                        0254
*          PROCSW='0'B;               /* RESET PROCEDURE SWITCH      */
@RC00252 NI    PROCSW,B'11011111'                                  0255
*          R13=EXITSAVE(2);           /* RESTORE PARSE SAVE AREA PTR */
         L     R13,EXITSAVE+4                                      0256
*          RFY PARSLST BASED(PARSPTR);/* RESET PARSE PARM LIST PTR   */
*          RFY (R1,R2) UNRSTD;        /* RELEASE REGISTERS           */
*          RETURN CODE(RETNCODE);     /* RETURN TO PARSE             */
         LR    @15,RETNCODE                                        0259
         L     @14,12(,@13)                                        0259
         LM    @00,@12,20(@13)                                     0259
         BR    @14                                                 0259
*          END PROCEXIT;                                           0260
*          /**********************************************************/
*          /* IKJDEXIT:FIRST-CHARACTER VALIDITY CHECK EXIT ROUTINE - */
*          /*   .USED WITH THE USERID, PASSWORD, AND PROCEDURE NAME  */
*          /*    DEFINITIONS.                                        */
*          /*   .VALIDATES THE FIRST CHARACTER OF EACH OF THE ABOVE  */
*          /*    VIA A NESTED CALL TO PARSE.                         */
*          /*   .THE 'IKJIDENT' DEFINITIONS GIVEN TO PARSE FOR EACH  */
*          /*    OF THE ABOVE SPECIFY 'FIRST=ANY' FOR THE FIRST      */
*          /*    CHARACTER CRITERION.  THIS ROUTINE DETERMINES       */
*          /*    WHETHER THE FIRST CHARACTER IS ALPHA OR NOT BY      */
*          /*    RE-PARSING EACH ITEM BY ITSELF WITH TWO 'IKJIDENTS':*/
*          /*    THE FIRST SPECIFYING 'FIRST=ALPHA', AND THE SECOND, */
*          /*    'FIRST=ANY'.                                        */
*          /*   .IF THE FIRST CHARACTER IS ALPHA, THE ITEM SHOWS UP  */
*          /*    UNDER THE FIRST 'IKJIDENT' AND IS ACCEPTED BY THIS  */
*          /*    EXIT ROUTINE.                                       */
*          /*   .IF THE FIRST CHARACTER IS NOT ALPHA, THE ITEM SHOWS */
*          /*    UP UNDER THE SECOND 'IKJIDENT' AND IS REJECTED BY   */
*          /*    THIS ROUTINE.                                       */
*          /*                                                        */
*          /* IDEXIT IS ENTERED FROM PARSE WITH REG. 1 POINTING TO   */
*          /*    TWO WORDS CONTAINING THE PARAMETER'S PDE ADDRESS    */
*          /*    AND THE USER WORD PASSED IN THE INPUT PARAMETER LIST*/
*          /*    (PPL) RESPECTIVELY.                                 */
*          /*                                                        */
*          /* IDEXIT RETURNS TO PARSE WITH A RETURN CODE IN REG. 15  */
*          /*    AS FOLLOWS:                                         */
*          /*        0 - PARAMETER IS VALID (1ST CHARACTER = ALPHA)  */
*          /*        4 - PARAMETER INVALID - ISSUE MSG AND PROMPT    */
*          /*        8 - PARAMETER INVALID - JUST PROMPT             */
*          /*       12 - ERROR IN EXIT ROUTINE - FLUSH CMD & CLEANUP */
*          /**********************************************************/
*IKJDEXIT: PROC;                                                   0261
IKJDEXIT STM   @14,@07,@SA00007                                    0261
         STM   @09,@12,@SA00007+40                                 0261
*          RFY R1 RSTD;               /* RESTRICT PARAMETER POINTER  */
*          RFY PARSLST BASED(PARSPTR2);/* RESET PARS PARM LIST PTRS  */
*          PARSPTR2=R1;               /* INITIALIZE PTR TO PARSE   0264
*                                        PARAMETER LIST              */
         LR    PARSPTR2,R1                                         0264
*          RFY R1 UNRSTD;             /* RELEASE PARAMETER POINTER   */
*          /* CONSTRUCT ONE ITEM 'BUFFER' FOR PARSE                  */
*          IDBUFLNG=PDELEN+4;         /* LENGTH INCLUDES 4-BYTE HDR  */
         L     @10,PDEPTR(,PARSPTR2)                               0266
         LH    @03,PDELEN(,@10)                                    0266
         LA    @01,4(,@03)                                         0266
         STH   @01,IDBUFLNG                                        0266
*          IDBFOFST=0;                /* OFFSET TO DATA ORIGIN       */
         SLR   @15,@15                                             0267
         STH   @15,IDBFOFST                                        0267
*          IDID(1:PDELEN)=PDECHARS;   /* MOVE ITEM FROM CMD BUFFER 0268
*                                        VIA PDE                     */
         BCTR  @03,0                                               0268
         L     @10,PDEADD(,@10)                                    0268
         EX    @03,@SM00277                                        0268
*          /* BUILD PARSE PARAMETER LIST (PPL) FOR NESTED PARSE      */
*          IDPRSLST(1:12)=PPLPTRA->PPL;/* FIRST THREE WORDS FROM   0269
*                                        SUBCOMMAND PPL              */
         L     @10,PPLPTRA(,VCHKPTR)                               0269
         MVC   IDPRSLST(12),PPL(@10)                               0269
*          PPLPTR=ADDR(IDPRSLST);     /* ESTABLISH PPL ADDRESSABLTY  */
         LA    PPLPTR,IDPRSLST                                     0270
*          PPLANS=ADDR(IDANSPL);      /* IDPDLAD WILL POINT TO     0271
*                                        PARAMETER DESCRIPTOR LIST 0271
*                                        (PDL) AFTER PARSE           */
         LA    @10,IDANSPL                                         0271
         ST    @10,PPLANS(,PPLPTR)                                 0271
*          PPLCBUF=ADDR(IDBUFFER);    /* PTR TO IDENTIFIER 'BUFFER'  */
         LA    @10,IDBUFFER                                        0272
         ST    @10,PPLCBUF(,PPLPTR)                                0272
*          IF USIDSW = '1'B           /* IS THIS A USERID?           */
*            THEN                     /* YES,                        */
         TM    USIDSW,B'10000000'                                  0273
         BNO   @RF00273                                            0273
*              PPLPCL = IDPCLPTR;     /* USE USERID PCE              */
         L     @10,IDPCLPTR                                        0274
         ST    @10,PPLPCL(,PPLPTR)                                 0274
*            ELSE                     /* NO,                         */
*              IF PASSSW = '1'B       /* IS THIS A PASSWORD?         */
*                THEN                 /* YES,                        */
         B     @RC00273                                            0275
@RF00273 TM    PASSSW,B'01000000'                                  0275
         BNO   @RF00275                                            0275
*                  PPLPCL = PAPCLPTR; /* USE PASSWORD PCE            */
         L     @10,PAPCLPTR                                        0276
         ST    @10,PPLPCL(,PPLPTR)                                 0276
*                ELSE                 /* THIS IS A PROCEDURE         */
*                  IF CMDIND = 1      /* IS THIS AN ADD COMMAND      */
*                    THEN             /* YES,                        */
         B     @RC00275                                            0277
@RF00275 CLI   CMDIND(VCHKPTR),1                                   0277
         BNE   @RF00277                                            0277
*                      PPLPCL = R1PCLPTR;/* USE ADD'S PROC PCE       */
         L     @10,R1PCLPTR                                        0278
         ST    @10,PPLPCL(,PPLPTR)                                 0278
*                    ELSE             /* NO,                         */
*                      PPLPCL = R2PCLPTR;/* USE '*' PROC PCE         */
         B     @RC00277                                            0279
@RF00277 L     @10,R2PCLPTR                                        0279
         ST    @10,PPLPCL(,PPLPTR)                                 0279
*          /* LINK TO PARSE ROUTINE                                  */
*          GEN (LINK  EP=IKJPARS,MF=(E,IDPRSLST))                  0280
*            REFS(IDPRSLST);                                       0280
@RC00277 DS    0H                                                  0280
@RC00275 DS    0H                                                  0280
@RC00273 DS    0H                                                  0280
         LINK  EP=IKJPARS,MF=(E,IDPRSLST)
*          RFY R15 RSTD;              /* RESTRICT RETURN CODE REG    */
*          PARSRTCD=R15;              /* SAVE RETURN CODE            */
         LR    PARSRTCD,R15                                        0282
*          RFY R15 UNRSTD;            /* RELEASE RETURN CODE REG     */
*          /* CHECK RETURN CODE                                      */
*          IF PARSRTCD^=0                                          0284
*            THEN                     /* PARSE EXCEPTION             */
         LTR   PARSRTCD,PARSRTCD                                   0284
         BZ    @RF00284                                            0284
*              DO;                                                 0285
*                EXITRTCD=PARSRTCD;   /* SAVE PARSE RETURN CODE      */
         ST    PARSRTCD,EXITRTCD(,VCHKPTR)                         0286
*                RETNCODE=12;         /* SIGNAL FOR PARSE TO QUIT    */
         LA    RETNCODE,12                                         0287
*                GOTO EXITEND;                                     0288
         B     EXITEND                                             0288
*              END;                                                0289
*          /* NOW, SEE IF THE FIRST ITEM IS PRESENT IN THE PDL       */
*          IF IDALFAFL(1)='1'B                                     0290
*            THEN                     /* PARAMETER IS VALID          */
@RF00284 L     @10,IDPDLAD-1                                       0290
         TM    IDALFAFL(@10),B'10000000'                           0290
         BNO   @RF00290                                            0290
*              RETNCODE=0;            /* SIGNAL 'PARAM OK' TO PARSE  */
         SLR   RETNCODE,RETNCODE                                   0291
*            ELSE                     /* PARAMETER IN NOT VALID      */
*              RETNCODE=4;            /* SIGNAL PARSE TO PROMPT      */
         B     @RC00290                                            0292
@RF00290 LA    RETNCODE,4                                          0292
*          /* MUST ISSUE 'IKJRLSA' MACRO NOW TO FREE PARSE PDL       */
*          RFY R1 RSTD;               /* RESTRICT PDL POINTER REG    */
@RC00290 DS    0H                                                  0294
*EXITEND:  R1=ADDR(IDANSPL);          /* ADDRESS PDL POINTER @ZA16396*/
EXITEND  LA    R1,IDANSPL                                          0294
*          CALL PARSREL;              /* GO TO FREE PDL AREA         */
         BAL   @14,PARSREL                                         0295
*          RFY R1 UNRSTD;             /* RELEASE PDL POINTER REG     */
*          RFY PARSLST BASED(PARSPTR);/* RESET PARSE PARM LIST PTR   */
*          END IKJDEXIT;                                           0298
@EL00007 DS    0H                                                  0298
@EF00007 DS    0H                                                  0298
@ER00007 LM    @14,@07,@SA00007                                    0298
         LM    @09,@12,@SA00007+40                                 0298
         BR    @14                                                 0298
*          /**********************************************************/
*          /* SIZEXIT: REGION SIZE VALIDITY CHECK EXIT ROUTINE -     */
*          /*   .CONVERTS THE VALUE TO BINARY                        */
*          /*   .MAKES CERTAIN THE VALUE IS LESS THAN 64K-1 (65,535) */
*          /*    WHICH IS THE CAPACITY OF AN HALF-WORD               */
*          /*   .IF THE VALUE IS LARGER THAN 64K-1, PARSE IS TOLD TO */
*          /*    PROMPT FOR A NEW VALUE.                             */
*          /*                                                        */
*          /* SIZEXIT IS ENTERED FROM PARSE WITH REG. 1 POINTING TO  */
*          /*    TWO WORDS CONTAINING:                               */
*          /*        WORD1 - THE ADDR OF THE 'SIZE' OR 'MAXSIZE' PDE */
*          /*        WORD2 - THE USER WORD PASSED IN THE PARM. LIST  */
*          /*                                                        */
*          /* SIZEXIT RETURNS TO PARSE WITH A RETURN CODE IN REG. 15 */
*          /*    AS FOLLOWS:                                         */
*          /*        0 - PARAMETER (SIZE-VALUE) IS VALID             */
*          /*        4 - PARAMETER INVALID - ISSUE MSG AND PROMPT    */
*          /*        8 - PARAMETER INVALID - JUST PROMPT (NOT USED)  */
*          /**********************************************************/
*SIZEEXIT: ENTRY;                                                  0299
@EP00299 DS    0H                                                  0300
*          /* HOUSEKEEPING                                           */
*          RFY (R1,R2) RSTD;          /* RESERVE REG. FOR PACK LNTH  */
*          PARSPTR=R1;                /* SAVE POINTER FROM PARSE     */
         LR    PARSPTR,R1                                          0301
*          R1=PDEADD;                 /* POINT TO UNPACKED VALUE     */
         L     @10,PDEPTR(,PARSPTR)                                0302
         L     R1,PDEADD(,@10)                                     0302
*          R2=PDELEN-1;               /* GET LENGTH OF VALUE         */
         LH    R2,PDELEN(,@10)                                     0303
         BCTR  R2,0                                                0303
*          /* PACK VALUE AND CONVERT TO BINARY                       */
*          GEN (EX    R2,PACKER)      /* PACK VALUE TO DECSIZE       */
*            SETS(DECSIZE) REFS(PACKER,R1,R2);                     0304
         EX    R2,PACKER
*          RFY R2 UNRSTD;             /* GIVE BACK REGISTER          */
*          CVB (R1,DECSIZE);          /* CONVERT DECSIZE TO BINARY   */
         CVB   R1,DECSIZE                                          0306
*          /* ROUND UP TO AN EVEN NUMBER (COMPATIBLE WITH JCL)       */
*          R1=R1+1;                   /* ADD ONE                     */
         AL    R1,@CF00032                                         0307
*          R1=R1&'FFFFFFFE'X;         /* TURN OFF LOW ORDER BIT      */
         N     R1,@CF00243                                         0308
*          /* MAKE SURE THAT THE VALUE IS LESS THAN 64K-1            */
*          IF R1<65535                                             0309
*            THEN                     /* IT WILL FIT IN AN HALFWORD  */
         C     R1,@CF00244                                         0309
         BNL   @RF00309                                            0309
*              DO;                                                 0310
*              PDEFLG=R1;             /* MOVE BINARY VALUE INTO PDE  */
         L     @10,PDEPTR(,PARSPTR)                                0311
         STH   R1,PDEFLG(,@10)                                     0311
*              RETURN CODE(0);        /* GO TO RETURN TO PARSE       */
         L     @13,4(,@13)                                         0312
         L     @00,@SIZDATD                                        0312
         LR    @01,@11                                             0312
         FREEMAIN R,LV=(0),A=(1)
         SLR   @15,@15                                             0312
         L     @14,12(,@13)                                        0312
         LM    @00,@12,20(@13)                                     0312
         BR    @14                                                 0312
*              END;                                                0313
*            ELSE                                                  0314
*              RETURN CODE(4);        /* SIGNAL TO PARSE TO PROMPT   */
@RF00309 L     @13,4(,@13)                                         0314
         L     @00,@SIZDATD                                        0314
         LR    @01,@11                                             0314
         FREEMAIN R,LV=(0),A=(1)
         LA    @15,4                                               0314
         L     @14,12(,@13)                                        0314
         LM    @00,@12,20(@13)                                     0314
         BR    @14                                                 0314
*          RFY R1 UNRSTD;                                          0315
*          /**********************************************************/
*          /* USERDATA VALIDITY CHECK EXIT ROUTINE -                 */
*          /*   .MAKES CERTAIN THE VALUE IS THE EBCDIC               */
*          /*    REPRESENTATION OF A HEX CHARACTER                   */
*          /*    WHICH IS THE CAPACITY OF AN HALF-WORD               */
*          /*   .IF THE VALUE IS NOT HEX, PARSE IS TOLD TO           */
*          /*    PROMPT FOR A NEW VALUE.                             */
*          /*                                                        */
*          /* USDAEXIT IS ENTERED FROM PARSE WITH REG. 1 POINTING TO */
*          /*    TWO WORDS CONTAINING:                               */
*          /*        WORD1 - THE ADDR OF THE 'USERDATA' PDE          */
*          /*        WORD2 - THE USER WORD PASSED IN THE PARM. LIST  */
*          /*                                                        */
*          /* USEREXIT RETURNS TO PARSE WITH A RETURN CODE IN REG. 15*/
*          /*    AS FOLLOWS:                                         */
*          /*        0 - PARAMETER (USERDATA) IS VALID               */
*          /*        4 - PARAMETER INVALID - ISSUE MSG AND PROMPT    */
*          /*        8 - PARAMETER INVALID - JUST PROMPT (NOT USED)  */
*          /**********************************************************/
*USDAEXIT: ENTRY;                                                  0316
@EP00316 DS    0H                                                  0317
*          /* HOUSEKEEPING                                           */
*          RFY R1 RSTD;               /* RESERVE PARAMETER LIST RGS  */
*          PARSPTR=R1;                /* SAVE POINTER FROM PARSE     */
         LR    PARSPTR,R1                                          0318
*          IF PDELEN^=4               /* IS THE LENGTH = 4           */
*            THEN                     /* NO,                         */
         L     @10,PDEPTR(,PARSPTR)                                0319
         CLC   PDELEN(2,@10),@CH00081                              0319
         BE    @RF00319                                            0319
*              RETURN CODE(4);        /* TELL PARSE TO PROMPT        */
         L     @13,4(,@13)                                         0320
         L     @00,@SIZDATD                                        0320
         LR    @01,@11                                             0320
         FREEMAIN R,LV=(0),A=(1)
         LA    @15,4                                               0320
         L     @14,12(,@13)                                        0320
         LM    @00,@12,20(@13)                                     0320
         BR    @14                                                 0320
*          DO BYTEPTR=4 TO 1 BY -1;   /* CHECK EACH CHAR             */
@RF00319 LA    BYTEPTR,4                                           0321
@DL00321 DS    0H                                                  0322
*            IF PDECHAR(BYTEPTR)>'C0'X/* IS THE VALUE A THRU F       */
*             &PDECHAR(BYTEPTR)<'C7'X                              0322
*              THEN                   /* YES,                        */
         L     @10,PDEPTR(,PARSPTR)                                0322
         L     @10,PDEADD(,@10)                                    0322
         LR    @07,@10                                             0322
         ALR   @07,BYTEPTR                                         0322
         BCTR  @07,0                                               0322
         CLI   PDECHAR(@07),X'C0'                                  0322
         BNH   @RF00322                                            0322
         LR    @07,@10                                             0322
         ALR   @07,BYTEPTR                                         0322
         BCTR  @07,0                                               0322
         CLI   PDECHAR(@07),X'C7'                                  0322
         BNL   @RF00322                                            0322
*                HEXCHAR(BYTEPTR)=    /* ADD X'39' TO MAKE IT HEX    */
*                  PDECHAR(BYTEPTR)+57;                            0323
         LA    @07,57                                              0323
         BCTR  @10,0                                               0323
         SLR   @02,@02                                             0323
         IC    @02,PDECHAR(BYTEPTR,@10)                            0323
         ALR   @07,@02                                             0323
         STC   @07,HEXCHAR-1(BYTEPTR)                              0323
*              ELSE                   /* IS THE VALUE LESS THAN 0    */
*                IF PDECHAR(BYTEPTR)<'F0'X                         0324
*                  THEN               /* YES,                        */
         B     @RC00322                                            0324
@RF00322 L     @10,PDEPTR(,PARSPTR)                                0324
         L     @10,PDEADD(,@10)                                    0324
         ALR   @10,BYTEPTR                                         0324
         BCTR  @10,0                                               0324
         CLI   PDECHAR(@10),X'F0'                                  0324
         BNL   @RF00324                                            0324
*                    RETURN CODE(4);  /* VALUE IS INVALID            */
         L     @13,4(,@13)                                         0325
         L     @00,@SIZDATD                                        0325
         LR    @01,@11                                             0325
         FREEMAIN R,LV=(0),A=(1)
         LA    @15,4                                               0325
         L     @14,12(,@13)                                        0325
         LM    @00,@12,20(@13)                                     0325
         BR    @14                                                 0325
*                  ELSE               /* NO,                         */
*                    HEXCHAR(BYTEPTR)=/* MOVE THE NUMBER             */
*                      PDECHAR(BYTEPTR);                           0326
@RF00324 LA    @10,HEXCHAR-1(BYTEPTR)                              0326
         L     @07,PDEPTR(,PARSPTR)                                0326
         L     @07,PDEADD(,@07)                                    0326
         ALR   @07,BYTEPTR                                         0326
         BCTR  @07,0                                               0326
         MVC   0(1,@10),PDECHAR(@07)                               0326
*          END;                                                    0327
@RC00322 BCTR  BYTEPTR,0                                           0327
         LTR   BYTEPTR,BYTEPTR                                     0327
         BP    @DL00321                                            0327
*          PACK (DECSIZE,HEXCHAR);    /* PACK VALUE                  */
         PACK  DECSIZE(8),HEXCHAR(5)                               0328
*          PDEFLG=DECSIZE(6:7);       /* MOVE USERDATA INTO PDE      */
         L     @10,PDEPTR(,PARSPTR)                                0329
         MVC   PDEFLG(2,@10),DECSIZE+5                             0329
*          RETURN CODE(0);            /* RETURN TO PARSE             */
         L     @13,4(,@13)                                         0330
         L     @00,@SIZDATD                                        0330
         LR    @01,@11                                             0330
         FREEMAIN R,LV=(0),A=(1)
         SLR   @15,@15                                             0330
         L     @14,12(,@13)                                        0330
         LM    @00,@12,20(@13)                                     0330
         BR    @14                                                 0330
*          /**********************************************************/
*          /* PERFEXIT: PERFORMANCE GROUP VALIDITY CHECK EXIT ROUTINE*/
*          /*   .CONVERTS THE VALUE TO BINARY                        */
*          /*   .MAKES CERTAIN THE VALUE IS LESS THAN 255            */
*          /*   .INSURES THAT NOT GROUP IS SPECIFIED MORE THAN ONCE. */
*          /*   .INSERTS THE GROUP NUMBER IN A RELATIVE POSITION     */
*          /*      WITHIN A STRING OF 255 BITS.                      */
*          /*                                                        */
*          /* PERFEXIT IS ENTERED FROM PARSE WITH REG. 1 POINTING TO */
*          /*    TWO WORDS CONTAINING:                               */
*          /*        WORD1 - THE ADDR OF ONE OF THE GROUP NUMBERS    */
*          /*        SPECIFIED BY THE USER                           */
*          /*        WORD2 - THE USER WORD PASSED IN THE PARM. LIST  */
*          /*                                                        */
*          /* PERFEXIT RETURNS TO PARSE WITH A RETURN CODE IN REG. 15*/
*          /*    AS FOLLOWS:                                         */
*          /*        0 - PARAMETER (GROUP-VALUE) IS VALID            */
*          /*        4 - PARAMETER INVALID - ISSUE MSG AND PROMPT    */
*          /*        8 - PARAMETER INVALID - JUST PROMPT (NOT USED)  */
*          /**********************************************************/
*PERFEXIT: ENTRY;                                                  0331
@EP00331 DS    0H                                                  0332
*          /* HOUSEKEEPING                                     Y02678*/
*          RFY (R1,R2) RSTD;          /* RESERVE REG. FOR PACK LNTH
*                                                              Y02678*/
*          PARSPTR=R1;                /* SAVE POINTER FROM PARSE   0333
*                                                              Y02678*/
         LR    PARSPTR,R1                                          0333
*          R1=PDEADD;                 /* POINT TO UNPACKED VALUE   0334
*                                                              Y02678*/
         L     @10,PDEPTR(,PARSPTR)                                0334
         L     R1,PDEADD(,@10)                                     0334
*          R2=PDELEN-1;               /* GET SIZE LENGTH FROM PDE  0335
*                                                              Y02678*/
         LH    R2,PDELEN(,@10)                                     0335
         BCTR  R2,0                                                0335
*          RFY VCHKPL BASED(USERWORD);/* RESPECIFY COMM AREA PTR   0336
*                                                              Y02678*/
*          /* PACK VALUE AND CONVERT TO BINARY                 Y02678*/
*          GEN (EX    R2,PACKER)      /* PACK VALUE TO DECSIZE Y02678*/
*            SETS(DECSIZE) REFS(PACKER,R1,R2);                     0337
         EX    R2,PACKER
*          RFY R2 UNRSTD;             /* GIVE BACK REGISTER    Y02678*/
*          CVB (R1,DECSIZE);          /* CONVERT DECSIZE TO BINARY 0339
*                                                              Y02678*/
         CVB   R1,DECSIZE                                          0339
*          IF R1= 0                   /* MAKE SURE THAT THE VALUE IS */
*           × R1>'FF'X                /* NOT ZERO AND LESS THAN 255  */
*            THEN                     /* GROUP NUMBER IS INVALID     */
         LTR   R1,R1                                               0340
         BZ    @RT00340                                            0340
         C     R1,@CF00259                                         0340
         BNH   @RF00340                                            0340
@RT00340 DS    0H                                                  0341
*              RETURN CODE(4);        /* SIGNAL TO PARSE TO PROMPT 0341
*                                                              Y02678*/
         L     @13,4(,@13)                                         0341
         L     @00,@SIZDATD                                        0341
         LR    @01,@11                                             0341
         FREEMAIN R,LV=(0),A=(1)
         LA    @15,4                                               0341
         L     @14,12(,@13)                                        0341
         LM    @00,@12,20(@13)                                     0341
         BR    @14                                                 0341
*          VALUE=R1;                  /* SAVE VALUE            Y02678*/
@RF00340 LR    VALUE,R1                                            0342
*          BYTEAD=VALUE/8;            /* GET BYTE POS. IN STRING   0343
*                                                              Y02678*/
         LR    BYTEAD,VALUE                                        0343
         SRL   BYTEAD,3                                            0343
*          BITAD=VALUE//8;            /* GET BIT POS. IN BYTE  Y02678*/
         LR    @08,VALUE                                           0344
         SRDA  @08,32                                              0344
         D     @08,@CF00066                                        0344
         LR    BITAD,@08                                           0344
*          IF BITAD=0                 /* IS VALUE A MULTIPLE OF 8?   */
*            THEN                     /* YES,                        */
         C     BITAD,@CF00178                                      0345
         BNE   @RF00345                                            0345
*              R1=1;                  /* SET LOW ORDER BIT IN      0346
*                                        REG 1                 Y02678*/
         LA    R1,1                                                0346
*            ELSE                     /* NO,                         */
*              DO;                                                 0347
         B     @RC00345                                            0347
@RF00345 DS    0H                                                  0348
*              BYTEAD=BYTEAD+1;       /* REFERENCE NEXT BYTE         */
         LA    BYTEAD,1(,BYTEAD)                                   0348
*              R1='80'X;              /* SET HIGH ORDER BIT IN     0349
*                                        REG 1                 Y02678*/
         LA    R1,128                                              0349
*              DO WHILE BITAD^=1;     /* POSITION BIT IN R1    Y02678*/
         B     @DE00350                                            0350
@DL00350 DS    0H                                                  0351
*                R1=R1/2;             /* SHIFT BIT TO RIGHT    Y02678*/
         SRL   R1,1                                                0351
*                BITAD=BITAD-1;       /* DECREMENT BIT POSITIONY02678*/
         BCTR  BITAD,0                                             0352
*                END;                                              0353
@DE00350 C     BITAD,@CF00032                                      0353
         BNE   @DL00350                                            0353
*              END;                                                0354
*          TESTBYTE=STRING(BYTEAD);   /* GET EXISTING BYTE FROM PERF
*                                        GROUP                 Y02678*/
@RC00345 L     @10,USERWORD(,PARSPTR)                              0355
         L     @10,PERFPTR(,@10)                                   0355
         BCTR  @10,0                                               0355
         SLR   TESTBYTE,TESTBYTE                                   0355
         IC    TESTBYTE,STRING(BYTEAD,@10)                         0355
*          TESTBIT=TESTBYTE&R1;       /* SEE IF THIS BIT IS ON Y02678*/
         LR    @10,TESTBYTE                                        0356
         NR    @10,R1                                              0356
         STC   @10,TESTBIT                                         0356
*          IF TESTBIT ^=0             /* WAS BIT ALREADY ON?   Y02678*/
*            THEN                     /* YES, GROUP WAS SPECIFIED  0357
*                                                              Y02678*/
         CLI   TESTBIT,0                                           0357
         BE    @RF00357                                            0357
*              RETURN CODE(4);        /* SIGNAL TO PARSE TO PROMPT 0358
*                                                              Y02678*/
         L     @13,4(,@13)                                         0358
         L     @00,@SIZDATD                                        0358
         LR    @01,@11                                             0358
         FREEMAIN R,LV=(0),A=(1)
         LA    @15,4                                               0358
         L     @14,12(,@13)                                        0358
         LM    @00,@12,20(@13)                                     0358
         BR    @14                                                 0358
*          TESTBYTE=TESTBYTE×R1;      /* TURN THIS BIT ON      Y02678*/
@RF00357 OR    TESTBYTE,R1                                         0359
*          STRING(BYTEAD)=TESTBYTE;   /* STORE BYTE INTO PERF GROUP
*                                                              Y02678*/
         L     @10,USERWORD(,PARSPTR)                              0360
         L     @10,PERFPTR(,@10)                                   0360
         BCTR  @10,0                                               0360
         STC   TESTBYTE,STRING(BYTEAD,@10)                         0360
*          RETURN CODE(0);            /* TELL PARSE VALUE IS O K   0361
*                                                              Y02678*/
         L     @13,4(,@13)                                         0361
         L     @00,@SIZDATD                                        0361
         LR    @01,@11                                             0361
         FREEMAIN R,LV=(0),A=(1)
         SLR   @15,@15                                             0361
         L     @14,12(,@13)                                        0361
         LM    @00,@12,20(@13)                                     0361
         BR    @14                                                 0361
*          RFY R1 UNRSTD;                                          0362
*          END IKJEFA55                                            0363
*/* THE FOLLOWING INCLUDE STATEMENTS WERE FOUND IN THIS PROGRAM.      *
*/*%INCLUDE SYSLIB  (IKJPPL  )                                        *
*;                                                                 0363
@DATA    DS    0H
@CH00081 DC    H'4'
@SM00261 MVC   DYNLFORM(0),INLINLFM
@SM00264 MVC   USRID(0,@09),NODEITEM(@01)
@SM00266 MVC   PASSWD(0,@09),NODEITEM(@01)
@SM00268 MVC   ACCTNO(0,@09),NODEITEM(@01)
@SM00270 MVC   PROCNM(0,@09),NODEITEM(@01)
@SM00277 MVC   IDID(0),PDECHARS(@10)
@DATD    DSECT
         DS    0F
@SA00001 DS    18F
@SA00002 DS    15F
@SA00007 DS    14F
IKJEFA55 CSECT
         DS    0F
@CF00178 DC    F'0'
@CF00032 DC    F'1'
@CH00032 EQU   @CF00032+2
@CF00066 DC    F'8'
@CF00187 DC    F'20'
@CF00118 DC    F'40'
@CF00244 DC    F'65535'
@CF00243 DC    XL4'FFFFFFFE'
@CF00259 DC    XL4'FF'
@DATD    DSECT
         DS    0D
IDANSPL  DS    AL4
         ORG   IDANSPL
@NM00006 DS    BL1
IDPDLAD  DS    AL3
         ORG   IDANSPL+4
HEXCHAR  DS    CL5
         DS    CL3
NDPRSLST DS    CL28
FREEPTRS DS    CL20
         ORG   FREEPTRS
NDANSPL  DS    AL4
         ORG   NDANSPL
@NM00003 DS    BL1
NODEPLAD DS    AL3
         ORG   FREEPTRS+4
NDBUFPTR DS    AL4
NDBUFLN  DS    FL4
PCLPTR   DS    AL4
PLENGTH  DS    FL4
         ORG   FREEPTRS+20
SWITCHS  DS    CL1
         ORG   SWITCHS
USIDSW   DS    BL1
PASSSW   EQU   SWITCHS+0
PROCSW   EQU   SWITCHS+0
         ORG   SWITCHS+1
         DS    CL3
DECSIZE  DS    CL8
IDPRSLST DS    CL28
IDBUFFER DS    CL12
         ORG   IDBUFFER
IDBUFLNG DS    FL2
IDBFOFST DS    AL2
IDID     DS    CL8
         ORG   IDBUFFER+12
TESTBIT  DS    BL1
         DS    CL3
EXITSAVE DS    18F
IKJEFA55 CSECT
         DS    0F
@SIZDATD DC    AL1(1)
         DC    AL3(@ENDDATD-@DATD)
         DS    0D
IDPCLPTR DC    AL4(USIDPARS)
PAPCLPTR DC    AL4(PASSPARS)
R1PCLPTR DC    AL4(PROCPAR1)
R2PCLPTR DC    AL4(PROCPAR2)
NDPCLPTR DC    AL4(NODEPARS)
PASSLNG  DC    AL2(PASSPCE-PCLSTART)
ACCTLNG  DC    AL2(ACCTPCE-PCLSTART)
PROCLNG  DC    AL2(PROCPCE-PCLSTART)
@DATD    DSECT
IKJEFA55 CSECT
NODEPARS CSECT
PCLSTART EQU   *
NODEPARS IKJPARM
USERA    IKJIDENT 'NODELIST-USERID',MAXLNTH=7,FIRST=ANY,OTHER=ANY,     *
               PROMPT='NODELIST-USERID',VALIDCK=USIDEXIT
PASSPCE  EQU   *
PASSA    IKJIDENT 'NODELIST-PASSWORD',FIRST=ANY,OTHER=ANY,             *
               PROMPT='NODELIST-PASSWORD',VALIDCK=PASSEXIT
ACCTPCE  EQU   *
ACCTA    IKJIDENT 'NODELIST-ACCOUNT NUMBER',FIRST=ANY,OTHER=ANY,       *
               PROMPT='NODELIST-ACCOUNT NUMBER',VALIDCK=ACCTEXIT
PROCPCE  EQU   *
PROCA    IKJIDENT 'NODELIST-PROCEDURE NAME',FIRST=ANY,OTHER=ANY,       *
               PROMPT='NODELIST-PROCEDURE NAME',VALIDCK=PROCEXIT
         IKJENDP
USIDPARS IKJPARM DSECT=USIDPDLD
USIDENT1 IKJIDENT 'USERID',ASTERISK,FIRST=ALPHA,OTHER=ALPHANUM
UDIDENT2 IKJIDENT 'DUM',FIRST=ANY,OTHER=ANY
         IKJENDP
PASSPARS IKJPARM DSECT=PASSPDLD
PASSENT1 IKJIDENT 'PASSWORD',ASTERISK,FIRST=ALPHANUM,OTHER=ALPHANUM
PASSENT2 IKJIDENT 'DUM',FIRST=ANY,OTHER=ANY
         IKJENDP
PROCPAR1 IKJPARM DSECT=PROCPDL1
PROCENT1 IKJIDENT 'PROCEDURE NAME',FIRST=ALPHA,OTHER=ALPHANUM
PROCENT2 IKJIDENT 'DUM',FIRST=ANY,OTHER=ANY
         IKJENDP
PROCPAR2 IKJPARM DSECT=PROCPDL2
PROCENT3 IKJIDENT 'PROCEDURE NAME',ASTERISK,FIRST=ALPHA,OTHER=ALPHANUM
PROCENT4 IKJIDENT 'DUM',FIRST=ANY,OTHER=ANY
         IKJENDP
@DATD    DSECT
IKJEFA55 CSECT
INLINLFM DS    0F
         FREEMAIN V,SP=1,MF=L             LENGTH & ADD SET BY E
         GETMAIN EC,SP=1,MF=L             LENGTH & ANS PTR SET BY E
INLINLNG DC    A(*-INLINLFM)              LENGTH OF L-FORM MACROS
PACKER   PACK  DECSIZE(8),0(0,R1)         MODEL PACK INSTRUCTION
@DATD    DSECT
DYNLFORM DS    0F
DYNFRLST FREEMAIN V,SP=1,MF=L             LENGTH & ADD SET BY E
DYNGTLST GETMAIN EC,SP=1,MF=L             WILL BE INIT'D FROM INLINGTM
IKJEFA55 CSECT
         DS   0H
PATCHLOC DC ((@DATA-@PSTART)/20)X'00'
@DATD    DSECT
         ORG   *+1-(*-@DATD)/(*-@DATD) INSURE DSECT DATA
@ENDDATD EQU   *
IKJEFA55 CSECT
@00      EQU   00                      EQUATES FOR REGISTERS 0-15
@01      EQU   01
@02      EQU   02
@03      EQU   03
@04      EQU   04
@05      EQU   05
@06      EQU   06
@07      EQU   07
@08      EQU   08
@09      EQU   09
@10      EQU   10
@11      EQU   11
@12      EQU   12
@13      EQU   13
@14      EQU   14
@15      EQU   15
PCEPTR   EQU   @09
VALUE    EQU   @04
TESTBYTE EQU   @02
BITAD    EQU   @02
BYTEAD   EQU   @03
PDLPTR   EQU   @02
NUMOFLVL EQU   @10
PARSRTCD EQU   @02
RETNCODE EQU   @08
PARSPTR2 EQU   @02
BYTEPTR  EQU   @03
PARSPTR  EQU   @06
VCHKPTR  EQU   @07
PPLPTR   EQU   @06
R0       EQU   @00
R1       EQU   @01
R2       EQU   @02
R13      EQU   @13
R14      EQU   @14
R15      EQU   @15
R12      EQU   @12
PPL      EQU   0
PPLPCL   EQU   PPL+12
PPLANS   EQU   PPL+16
PPLCBUF  EQU   PPL+20
PPLUWA   EQU   PPL+24
VCHKPL   EQU   0
EXITADD  EQU   VCHKPL
EXITRTCD EQU   VCHKPL+4
NODEPTR  EQU   VCHKPL+8
PERFPTR  EQU   VCHKPL+12
PPLPTRA  EQU   VCHKPL+16
SAVARAD  EQU   VCHKPL+20
CMDIND   EQU   VCHKPL+24
NUMOFLV  EQU   VCHKPL+25
SUBEXIT  EQU   0
PARSLST  EQU   0
PDEPTR   EQU   PARSLST
USERWORD EQU   PARSLST+4
@NM00002 EQU   0
PDEADD   EQU   @NM00002
PDELEN   EQU   @NM00002+4
PDEFLG   EQU   @NM00002+6
SAVEARP  EQU   0
PDECHARS EQU   0
@NM00004 EQU   0
NDBUFLNG EQU   @NM00004
NDBFOFST EQU   @NM00004+2
@NM00005 EQU   0
PDLADD   EQU   @NM00005
PDLLEN   EQU   @NM00005+4
PDLFLG   EQU   @NM00005+6
NODEITEM EQU   0
NLSTTAB  EQU   0
USRLEN   EQU   NLSTTAB
USRID    EQU   NLSTTAB+1
PASSWD   EQU   NLSTTAB+9
ACTLEN   EQU   NLSTTAB+17
ACCTNO   EQU   NLSTTAB+18
PROCNM   EQU   NLSTTAB+58
@NM00007 EQU   0
IDALFAFL EQU   @NM00007+14
STRING   EQU   0
PCLLNGTH EQU   0
PCLENDO  EQU   0
PCLFLAGS EQU   0
PDECHAR  EQU   PDECHARS
         AGO   .@UNREFD                START UNREFERENCED COMPONENTS
@NM00010 EQU   @NM00007+12
@NM00009 EQU   @NM00007+8
@NM00008 EQU   @NM00007
@NM00001 EQU   PARSLST+8
PPLECB   EQU   PPL+8
PPLECT   EQU   PPL+4
PPLUPT   EQU   PPL
.@UNREFD ANOP                          END UNREFERENCED COMPONENTS
@RT00101 EQU   EXIT
@RT00106 EQU   EXIT
@RT00112 EQU   EXIT
@RF00148 EQU   @EL00002
@ENDDATA EQU   *
         END   IKJEFA55,(C'PLS1137',0701,77012)
