         TITLE 'IKJEFA40  --  LIST COMMAND PROCESSOR                   *
                        '
IKJEFA40 CSECT ,                                                   0001
@MAINENT DS    0H                                                  0001
         USING *,@15                                               0001
         B     @PROLOG                                             0001
         DC    AL1(16)                                             0001
         DC    C'IKJEFA40  74.046'                                 0001
         DROP  @15
@PROLOG  STM   @14,@12,12(@13)                                     0001
         BALR  @12,0                                               0001
@PSTART  DS    0H                                                  0001
         USING @PSTART,@12                                         0001
         L     @00,@SIZDATD                                        0001
         GETMAIN R,LV=(0)
         LR    @11,@01                                             0001
         USING @DATD,@11                                           0001
         ST    @13,@SA00001+4                                      0001
         LM    @00,@01,20(@13)                                     0001
         ST    @11,8(,@13)                                         0001
         LR    @13,@11                                             0001
*         ACCTPLP = R1;               /* ASSIGN THE ADDRESS OF THE 0030
*                                        INPUT PARAMETER LIST        */
         ST    R1,ACCTPLP                                          0030
*         RFY R1 UNRSTD;              /* RESTRICT PARM LIST REGISTER */
*         /* ASSIGN GENERATED PARAMETER BLOCKS TO DYNAMIC STORAGE    */
*         CPLS(1:MCPLNG) = MCPLS(1:MCPLNG);                        0032
         L     @10,MCPLNG                                          0032
         BCTR  @10,0                                               0032
         EX    @10,@SM00243                                        0032
*         GEN (USING IHADCB,R2)       /* ADDRESSABILITY FOR LABELS   */
*           REFS(R2);                                              0033
         USING IHADCB,R2
*         ACIOPARM = ACIOPARM&&ACIOPARM;/* CLEAR READ/WRITE PARM BLK */
         XC    ACIOPARM(24),ACIOPARM                               0034
*         ACIODRCT = ADDR(DIRYWA);    /* SET PTR TO DIRECTORY W/A    */
         LA    @10,DIRYWA                                          0035
         ST    @10,ACIODRCT                                        0035
*         ACIOPUTL = ACCTPLP;         /* SET PTR TO ACCOUNT PARMLIST */
         L     @10,ACCTPLP                                         0036
         ST    @10,ACIOPUTL                                        0036
*         MSGID = '9';                /* SET LIST MSG ID - READ ISSUES
*                                        I/O ERROR MESSAGES          */
         MVI   MSGID,C'9'                                          0037
*         UADSDCB = UADSBLK;          /* INIT DYNAMIC DCB BLK - BSAM */
         MVC   UADSDCB(88),UADSBLK                                 0038
*         /* BUILD THE PARAMETER LIST FOR 'PUTLINE'                  */
*         IOPLPTR = ADDR(PLPLIST);    /* POINT TO PUTLILE PB         */
         LA    IOPLPTR,PLPLIST                                     0039
*         PLPLIST(1:12) = ACCTPL(1:12);/* ADDR OF THE UPT, ECT & ECB */
         MVC   PLPLIST(12),ACCTPL(@10)                             0040
*         IOPLIOPB = ADDR(PBLOK);     /* ADDR OF THE PARM BLOCK    0041
*                                        THE PUTLINE SERVICE RTNE    */
         LA    @07,PBLOK                                           0041
         ST    @07,IOPLIOPB(,IOPLPTR)                              0041
*         INSRTO1 = 10;               /* INIT SEGMENT OFFSET         */
         MVC   INSRTO1(2),@CH00141                                 0042
*         OUTAPTR = ADDR(OUTPAREA);   /* SET PTR TO START OF OUTPUT
*                                        LINE                        */
         LA    OUTAPTR,OUTPAREA                                    0043
*         INDIC = '0'B;               /* INITIALIZE CONTROL FLAGS    */
         MVI   INDIC,B'00000000'                                   0044
*         /* DETERMINE WHETHER THE INPUT COMMAND IS LIST OR LISTIDS. */
*         /* IF LISTIDS, BRANCH TO THE SECTION LABELED 'LISTIDS'.    */
*         IF UIDLPTR ^= 0             /* WAS 'LISTIDS' SPECIFIED?    */
*           THEN                      /* YES,                        */
         SLR   @07,@07                                             0045
         C     @07,UIDLPTR(,@10)                                   0045
         BNE   @RT00045                                            0045
*             GOTO LISTIDS;           /* BRANCH TO LISTIDS SECTION   */
*         /***********************************************************/
*         /*                                                         */
*         /*            PARSING OF THE INPUT COMMAND                 */
*         /*                                                         */
*         /***********************************************************/
*         PPLPTR = ADDR(PARSLIST);    /* PPL ADDRESSABILITY          */
         LA    @05,PARSLIST                                        0047
         ST    @05,PPLPTR                                          0047
*         EXITADD = 0;                /* SET PTR FOR NO EXIT         */
         ST    @07,EXITADD                                         0048
*         SAVARAD = 0;                /* SET PTR FOR NO SAVE AREA    */
         ST    @07,SAVARAD                                         0049
*         NODEPTR = ADDR(NLSTTAB);    /* POINT TO ANSWER PLACE       */
         LA    @15,NLSTTAB                                         0050
         ST    @15,NODEPTR                                         0050
*         CMDIND = 4;                 /* INDICATE LIST COMMAND - NO
*                                        MODIFICATION                */
         MVI   CMDIND,X'04'                                        0051
*         /* BUILD PARSE PARAMETER LIST (PPL).                       */
*         PARSLIST(1:12) = ACCTPL(1:12);/* ADDR OF THE UPT, ECT & ECB*/
         MVC   PARSLIST(12),ACCTPL(@10)                            0052
*         PPLPCL = PCLMDLAD;          /* ADDR OF THE PCL             */
         L     @15,PCLMDLAD                                        0053
         ST    @15,PPLPCL(,@05)                                    0053
*         PPLANS = ADDR(LSTPDLAD);    /* CHNPDLAD WILL CONTAIN ADDR
*                                        OF PDL AFTER PARSE          */
         LA    @15,LSTPDLAD                                        0054
         ST    @15,PPLANS(,@05)                                    0054
*         PPLCBUF = BUFPTR;           /* PTR TO CHANGE CMND  BUFFER  */
         L     @10,BUFPTR(,@10)                                    0055
         ST    @10,PPLCBUF(,@05)                                   0055
*         PPLUWA = ADDR(VCHKPL);      /* ADDR OF THE PARAMETER  LIST
*                                        FOR IKJEFA55                */
         LA    @10,VCHKPL                                          0056
         ST    @10,PPLUWA(,@05)                                    0056
*         /* LINK TO THE PARSE SERVICE ROUTINE.                      */
*         GEN (LINK  EP=IKJPARS,MF=(E,PARSLIST))                   0057
*           REFS(PARSLIST);                                        0057
         LINK  EP=IKJPARS,MF=(E,PARSLIST)
*         RFY R15 RSTD;               /* RESTRICT RETURN CODE REG    */
*         RTNCODE = R15;              /* SAVE THE RETURN CODE        */
         LR    RTNCODE,R15                                         0059
*         RFY R15 UNRSTD;             /* RELEASE RETURN CODE REG     */
*         /* CHECK THE PARSE RETURN CODE.                            */
*         IF RTNCODE = 0              /* PARSE SUCCESSFUL?           */
*           THEN                      /* YES,                        */
         LTR   RTNCODE,RTNCODE                                     0061
         BZ    @RT00061                                            0061
*             GOTO PRSOK;             /* CONTINUE NORMALLY           */
*         /* ERROR DURING VALIDITY CHECK RTNE?                       */
*         IF RTNCODE = 20                                          0063
*           THEN                      /* YES,                        */
         CH    RTNCODE,@CH00192                                    0063
         BNE   @RF00063                                            0063
*             RTNCODE = EXITRTCD;     /* TRANSFER CODE & CONTINUE  0064
*                                        CHECKING                    */
         L     RTNCODE,EXITRTCD                                    0064
*         /* ATTENTION EXIT?                                         */
*         IF RTNCODE = 8                                           0065
*           THEN                      /* YES,                        */
@RF00063 CH    RTNCODE,@CH00073                                    0065
         BE    @RT00065                                            0065
*             GOTO ACCTRET;           /* GO CLEAN UP & RETURN        */
*         /* GETMAIN FAILURE?                                        */
*         IF RTNCODE = 16                                          0067
*           THEN                      /* YES,                        */
         CH    RTNCODE,@CH00194                                    0067
         BNE   @RF00067                                            0067
*             DO;                                                  0068
*               MSGNO = 2;            /* SET ERROR MSG NUMBER        */
         LA    MSGNO,2                                             0069
*               GOTO TMSGA;           /* GO ISSUE THE MESSAGE        */
         B     TMSGA                                               0070
*             END;                                                 0071
*         /* UNABLE TO PROMPT?                                       */
*         IF RTNCODE = 4                                           0072
*           THEN                      /* YES,                        */
@RF00067 CH    RTNCODE,@CH00139                                    0072
         BE    @RT00072                                            0072
*             GOTO ACCTRET;           /* GO CLEAN UP & RETURN        */
*           ELSE                      /* NO, INVALID PARAMETERS      */
*             DO;                                                  0074
*               MSGNO = 12;           /* SET ERROR MSG NUMBER        */
         LA    MSGNO,12                                            0075
*               GOTO MLMSG;           /* GO CONSTRUCT THE MSG        */
         B     MLMSG                                               0076
*             END;                                                 0077
*PRSOK:   /* COMPLETE THE NODELIST CONTROL TABLE BUILT BY THE        */
*         /* VALIDITY CHECK ROUTINE (IKJEFA43). FOR ANY LEVEL NOT    */
*         /* SPECIFIED IN THE NODELIST OF THE INPUT COMMAND (NEITHER */
*         /* '*' NOR SPECIFIC NAME), INSERT AN '*' INTO THE TABLE.   */
*         /* ENTRY IN THE PROCNAME POSITION OF THE NODELIST?         */
*         IF NUMOFLV < 4                                           0078
*           THEN                      /* NO,                         */
PRSOK    CLI   NUMOFLV,4                                           0078
         BNL   @RF00078                                            0078
*             PROCNM = '*';           /* INSERT '*' FOR PROCNAME     */
         MVI   PROCNM+1,C' '                                       0079
         MVC   PROCNM+2(6),PROCNM+1                                0079
         MVI   PROCNM,C'*'                                         0079
*         /* ENTRY IN THE ACCTNMBR POSITION OF THE NODELIST?         */
*         IF NUMOFLV < 3                                           0080
*           THEN                      /* NO,                         */
@RF00078 CLI   NUMOFLV,3                                           0080
         BNL   @RF00080                                            0080
*             ACCTNO = '*';           /* INSERT '*' FOR ACCTNMBR     */
         MVI   ACCTNO+1,C' '                                       0081
         MVC   ACCTNO+2(38),ACCTNO+1                               0081
         MVI   ACCTNO,C'*'                                         0081
*         /* ENTRY IN THE PASSWORD POSITION OF THE NODELIST?         */
*         IF NUMOFLV < 2                                           0082
*           THEN                      /* NO,                         */
@RF00080 CLI   NUMOFLV,2                                           0082
         BNL   @RF00082                                            0082
*             PASSWD = '*';           /* INSERT '*' FOR PASSWORD     */
         MVI   PASSWD+1,C' '                                       0083
         MVC   PASSWD+2(6),PASSWD+1                                0083
         MVI   PASSWD,C'*'                                         0083
*         /* ENQUEUE ON THE UADS DATA SET                            */
*         GEN (ENQ  MF=(E,UADENQ))                                 0084
*           REFS(MAJNAME,MINNAME,UADENQ);                          0084
@RF00082 DS    0H                                                  0084
         ENQ  MF=(E,UADENQ)
*         ENQSW = '1'B;               /* SET SWITCH FOR DEQUEUE      */
         OI    ENQSW,B'10000000'                                   0085
*         /* IF THE NODELIST USERID IS '*', THE BSAM DCB MUST BE     */
*         /* OPENED FOR DIRECTORY READING.                           */
*         IF USRID(1) = '*'           /* USERID = '*'?               */
*           THEN                      /* YES,                        */
         CLI   USRID,C'*'                                          0086
         BNE   @RF00086                                            0086
*             DO;                                                  0087
*             ACIODRCT = ADDR(DIRYWA);/* SET PTR TO DIRECTORY W/A    */
         LA    @10,DIRYWA                                          0088
         ST    @10,ACIODRCT                                        0088
*             RFY R2 RSTD;            /* RESTRICT DCB BASE REGISTER  */
*             R2 = ADDR(UADSDCB);     /* LOAD ADDR OF DCB INTO REG2  */
         LA    R2,UADSDCB                                          0090
*             GEN (OPEN  ((R2)),MF=(E,OPENDIR))                    0091
*               REFS(OPENDIR,R2);                                  0091
         OPEN  ((R2)),MF=(E,OPENDIR)
*             /* IF OPEN WAS NOT SUCCESSFUL, ISSUE AN ERROR MESSAGE
*                AND RETURN TO ACCOUNT.                              */
*             IF DCBOFLG = '0'B       /* WAS 'OPEN' SUCCESSFUL?      */
*               THEN                  /* NO,                         */
         TM    DCBOFLG,B'00010000'                                 0092
         BNZ   @RF00092                                            0092
*                 DO;                                              0093
*                 MSGNO = 8;          /* SET ERROR MSG NUMBER        */
         LA    MSGNO,8                                             0094
*                 GOTO TMSGA;         /* GO CONSTRUCT THE MESSAGE    */
         B     TMSGA                                               0095
*                 END;                                             0096
*             RFY R2 UNRSTD;          /* RELEASE DCB BASE REGISTER   */
@RF00092 DS    0H                                                  0098
*             END;                                                 0098
*         /* BUILD THE LIST CONTROL TABLE.                           */
*         NODELADR = ADDR(NLSTTAB);   /* PTR TO THE NODELIST TABLE   */
@RF00086 LA    @10,NLSTTAB                                         0099
         ST    @10,NODELADR                                        0099
*         RWPLADR = ADDR(ACIOPARM);   /* PTR TO READ/WRITE PARMLIST  */
         LA    @10,ACIOPARM                                        0100
         ST    @10,RWPLADR                                         0100
*         /* BEFORE PASSING CONTROL TO IKJEFA42, CHECK THE ATTENTION */
*         /* EXIT BIT IN THE ECB.                                    */
*         IF ATTENTN = '1'B                                        0101
*           THEN                      /* THE EXIT BIT IS ON,         */
         L     @10,ACCTPLP                                         0101
         L     @10,ACCTECBP(,@10)                                  0101
         TM    ATTENTN(@10),B'01000000'                            0101
         BO    @RT00101                                            0101
*             GOTO ACCTRET;           /* GO CLEAN UP & RETURN        */
*         /***********************************************************/
*         /*                                                         */
*         /* PASS CONTROL TO THE LIST FORMATTING ROUTINE. IT WILL    */
*         /* EXTRACT THE REQUIRED DATA FROM THE UADS, FORMAT IT &    */
*         /* PUT IT OUT TO THE TERMINAL.                             */
*         /*                                                         */
*         /***********************************************************/
*         RFY R1 RSTD;                /* RESTRICT PARAMETER REG      */
*         R1 = ADDR(CTAB);            /* IKJEFA42 EXPECTS THE ADDR OF
*                                        THE LIST CONTROLTAB IN REG1 */
         LA    R1,CTAB                                             0104
*         CALL IKJEFA42;                                           0105
         L     @15,@CV00050                                        0105
         BALR  @14,@15                                             0105
*         RFY R1 UNRSTD;              /* RELEASE PARAMETER REG       */
*         RFY R15 RSTD;               /* RESTRICT ENTRY POINT REG    */
*         RTNCODE = R15;              /* ASSIGN THE RETURN CODE      */
         LR    RTNCODE,R15                                         0108
*         RFY R15 UNRSTD;             /* RELEASE RETURN CODE REG     */
*         /* CHECK WHETHER THE ECB WAS POSTED BY THE ATTENTION EXIT  */
*         /* RTNE WHILE IKJEFA42 WAS IN CONTROL.                     */
*         IF ATTENTN = '1'B                                        0110
*           THEN                      /* THE EXIT BIT IS ON,         */
         L     @10,ACCTPLP                                         0110
         L     @10,ACCTECBP(,@10)                                  0110
         TM    ATTENTN(@10),B'01000000'                            0110
         BO    @RT00110                                            0110
*             GOTO ACCTRET;           /* GO CLEAN UP & RETURN        */
*         /* ON RETURN FROM IKJEFA42, CHECK THE MESSAGE NUMBER IN    */
*         /* THE LIST CONTROL TABLE. 0 MEANS SUCCESSFUL COMPLETION.  */
*         /* ANY OTHER NUMBER CORRESPONDS TO AN ERROR MESSAGE TO BE  */
*         /* PUT OUT BY THIS RTNE.                                   */
*         IF MSGNMBR = 0              /* WAS IKJEFA42 SUCCESSFUL?    */
*           THEN                      /* YES,                        */
         L     @10,MSGNMBR                                         0112
         LTR   @10,@10                                             0112
         BZ    @RT00112                                            0112
*             GOTO MODEMSG;           /* GO ISSUE MODE MSG: 'LISTED' */
*         /* CHECK THE ERROR CODE & PREPARE TO ISSUE THE APPROPRIATE */
*         /* MESSAGE TO THE TERMINAL.                                */
*         /* MSGNMBR = 20 MEANS THAT THE READ RTNE, IKJEFA51, ISSUED */
*         /* AN I/O ERROR MESSAGE.                                   */
*         /* MSGNMBR = 30 MEANS THAT THERE WAS NOT ENOUGH WORKING    */
*         /* STORAGE FOR ANY USERID TREE - NO DATA WAS PUT OUT.      */
*         /* A MESSAGE FOR EACH USERID WAS ISSUED BY IKJEFA42.       */
*         IF MSGNMBR = 20             /* I/O ERRMSG HAS BEEN ISSUED  */
*          × MSGNMBR = 30             /* NO DATA WAS PUT OUT,        */
*           THEN                                                   0114
         CH    @10,@CH00192                                        0114
         BE    @RT00114                                            0114
         CH    @10,@CH00201                                        0114
         BE    @RT00114                                            0114
*             GOTO ACCTRET;           /* GO CLEAN UP & RETURN        */
*         MSGNO = MSGNMBR;            /* SET THE ERROR MSG NUMBER    */
         LR    MSGNO,@10                                           0116
*         IF MSGNO = 2                /* GETMAIN FAILURE?            */
*          × MSGNO = 8                /* UNABLE TO OPEN UADS         */
*          × MSGNO = 9                /* BLDL I/O ERROR              */
*           THEN                      /* YES,                        */
         CH    MSGNO,@CH00059                                      0117
         BE    @RT00117                                            0117
         CH    MSGNO,@CH00073                                      0117
         BE    @RT00117                                            0117
         CH    MSGNO,@CH00202                                      0117
         BE    @RT00117                                            0117
*             GOTO TMSGA;             /* GO ISSUE THE MESSAGE        */
*         IF MSGNO = 4                /* SPECIFIED USERID NOT FOUND? */
*           THEN                      /* YES,                        */
         CH    MSGNO,@CH00139                                      0119
         BE    @RT00119                                            0119
*             GOTO MPREP1;            /* GO CONSTRUCT THE MESSAGE    */
*         IF MSGNO = 13               /* PUTLINE ERROR?              */
*          × MSGNO = 14               /* READ ERROR W/O MSG          */
*           THEN                      /* YES,                        */
         CH    MSGNO,@CH00204                                      0121
         BE    @RT00121                                            0121
         CH    MSGNO,@CH00205                                      0121
         BE    @RT00121                                            0121
*             GOTO MLMSG;             /* GO CONSTRUCT THE MESSAGE    */
*         CALL MSGFNDR;               /* GO CALCULATE MSG ADDR       */
         BAL   @14,MSGFNDR                                         0123
*         SEGPTR13 = ADDR(INSRT1);    /* POINT TO INSERT SEGMENT     */
         LA    @10,INSRT1                                          0124
         ST    @10,SEGPTR13                                        0124
*         INSRTL1 = 12;               /* SET LENGTH OF SEGMENT       */
         MVC   INSRTL1(2),@CH00187                                 0125
*         IF MSGNO = 5                /* SPECIFIED PASSWORD NOT FOUND*/
*           THEN                      /* YES,                        */
         CH    MSGNO,@CH00207                                      0126
         BNE   @RF00126                                            0126
*             INSRTT1(1:8) = PASSWD;  /* INSERT THE PASSWORD         */
         MVC   INSRTT1(8),PASSWD                                   0127
*           ELSE                                                   0128
*             IF MSGNO = 6            /* SPECIFIED ACCTNMBR NOT FOUND*/
*               THEN                  /* YES,                        */
         B     @RC00126                                            0128
@RF00126 CH    MSGNO,@CH00142                                      0128
         BNE   @RF00128                                            0128
*                 DO;                                              0129
*                 INSRTL1 = ACTLEN+4; /* SET LENGTH OF SEGMENT       */
         SLR   @10,@10                                             0130
         IC    @10,ACTLEN                                          0130
         LA    @15,4                                               0130
         ALR   @15,@10                                             0130
         STH   @15,INSRTL1                                         0130
*                 INSRTT1 = ACCTNO(1:ACTLEN);/* INSERT THE ACCT NUM  */
         MVI   INSRTT1+1,C' '                                      0131
         MVC   INSRTT1+2(38),INSRTT1+1                             0131
         BCTR  @10,0                                               0131
         EX    @10,@SM00246                                        0131
*                 END;                                             0132
*               ELSE                                               0133
*                 INSRTT1(1:8) = PROCNM;  /* INSERT THE PROC NAME    */
         B     @RC00128                                            0133
@RF00128 MVC   INSRTT1(8),PROCNM                                   0133
*         /* GO TO PUT OUT THE ERROR MESSAGE                         */
*         GOTO PUTMSG;                /* GO TO ISSUE THE MESSAGE     */
         B     PUTMSG                                              0134
*LISTIDS: /***********************************************************/
*         /*                                                         */
*         /* THE USER HAS ENTERED THE 'LISTIDS' SUBCOMMAND, ASKING   */
*         /* FOR A LIST OF ALL USERIDS IN THE UADS DIRECTORY. NO     */
*         /* DATA HAS TO BE EXTRACTED FROM THE UADS.                 */
*         /*                                                         */
*         /***********************************************************/
*         UIDLPTR = 0;                /* RESET COMMAND INDICATOR     */
LISTIDS  L     @10,ACCTPLP                                         0135
         SLR   @07,@07                                             0135
         ST    @07,UIDLPTR(,@10)                                   0135
*         /* ENQUEUE ON THE UADS DATA SET                            */
*         GEN (ENQ  MF=(E,UADENQ))                                 0136
*           REFS(MAJNAME,MINNAME,UADENQ);                          0136
         ENQ  MF=(E,UADENQ)
*         ENQSW = '1'B;               /* SET SWITCH FOR DEQUEUE      */
         OI    ENQSW,B'10000000'                                   0137
*         RFY R2 RSTD;                /* RESTRICT DCB BASE REGISTER  */
*         R2 = ADDR(UADSDCB);         /* LOAD ADDR OF DCB INTO REG2  */
         LA    R2,UADSDCB                                          0139
*         GEN (OPEN  ((R2)),MF=(E,OPENDIR))                        0140
*           REFS(OPENDIR,R2);                                      0140
         OPEN  ((R2)),MF=(E,OPENDIR)
*         /* IF OPEN WAS NOT SUCCESSFUL, ISSUE AN ERROR MESSAGE &    */
*         /* RETURN TO ACCOUNT.                                      */
*         IF DCBOFLG = '0'B           /* WAS 'OPEN' SUCCESSFUL?      */
*           THEN                      /* NO,                         */
         TM    DCBOFLG,B'00010000'                                 0141
         BNZ   @RF00141                                            0141
*             DO;                                                  0142
*               MSGNO = 8;            /* SET ERROR MSG NUMBER        */
         LA    MSGNO,8                                             0143
*               GOTO TMSGA;           /* GO CONSTRUCT THE MESSAGE    */
         B     TMSGA                                               0144
*             END;                                                 0145
*         RFY R2 UNRSTD;              /* RLLEASE DCB BASE REGISTER   */
@RF00141 DS    0H                                                  0147
*         USCNT = 0;                  /* SET COUNT OF USERIDS TO 0   */
         SLR   USCNT,USCNT                                         0147
*         /* BUILD THE PARAMETER LIST FOR READ, IKJEFA51.            */
*         ACIOFLGS = '24'X;           /* TURN ON FLAGS 3 & 6 - READ A
*                                        DIRECTORY BLOCK ONLY        */
         MVI   ACIOFLGS,X'24'                                      0148
*READLVL: /* BEFORE READING A BLOCK FROM THE DIRECTORY, CHECK THE    */
*         /* ATTENTION EXIT BIT IN THE ECB. IF IT IS ON, TERMINATE   */
*         /* LIST AND RETURN TO ACCOUNT.                             */
*         IF ATTENTN = '1'B                                        0149
*           THEN                      /* THE EXIT BIT IS ON,         */
READLVL  L     @10,ACCTPLP                                         0149
         L     @10,ACCTECBP(,@10)                                  0149
         TM    ATTENTN(@10),B'01000000'                            0149
         BO    @RT00149                                            0149
*             GOTO ACCTRET;           /* GO CLEAN UP & RETURN        */
*         RFY R1 RSTD;                /* RESTRICT PARAMETER REG      */
*         R1 = ADDR(ACIOPARM);        /* SET PTR TO READ PARMLIST    */
         LA    R1,ACIOPARM                                         0152
*         CALL IKJEFA51;              /* THE READ RTNE WILL READ ONE
*                                        BLOCK INTO DIRECTORY W/A    */
         L     @15,@CV00051                                        0153
         BALR  @14,@15                                             0153
*         RFY R1 UNRSTD;              /* RELEASE PARAMETER REG       */
*         RFY R15 RSTD;               /* RESTRICT RETURN CODE REG    */
*         RTNCODE = R15;              /* SAVE THE RETURN CODE        */
         LR    RTNCODE,R15                                         0156
*         RFY R15 UNRSTD;             /* RELEASE RETURN CODE REG     */
*         IF RTNCODE ^= 0             /* READ SUCCESSFUL?            */
*           THEN                      /* NO,                         */
         LTR   RTNCODE,RTNCODE                                     0158
         BZ    @RF00158                                            0158
*             DO;                                                  0159
*             IF RTNCODE = 20         /* I/O ERROR, MSG ISSUED       */
*               THEN                  /* YES,                        */
         CH    RTNCODE,@CH00192                                    0160
         BE    @RT00160                                            0160
*                 GOTO ACCTRET;       /* GO CLEAN UP & RETURN        */
*               ELSE                                               0162
*                 MSGNO = 14;         /* READ ERROR                  */
         LA    MSGNO,14                                            0162
*                 GOTO MLMSG;         /* GO CONSTRUCT THE MESSAGE    */
         B     MLMSG                                               0163
*             END;                                                 0164
*         /* ONE DIRECTORY BLOCK IS NOW IN THE WORK AREA             */
*         MEMPTR = ADDR(DIRYBLK)+2;   /* SET BASE PTR FOR 1ST ENTRY  */
@RF00158 LA    MEMPTR,DIRYBLK                                      0165
         AH    MEMPTR,@CH00059                                     0165
*LNGFNDR: /* THIS LOOP WILL CALCULATE THE LENGTH OF THE USERID BY    */
*         /* FINDING THE 1ST NON-BLANK CHARACTER, STARTING FROM THE  */
*         /* RIGHT. THAT CHARACTER IS THE EXTENT NUMBER & IS NOT     */
*         /* INCLUDED IN THE LENGTH.                                 */
*         USRLEN = 8;                 /* SET STARTING LENGTH         */
LNGFNDR  MVI   USRLEN,X'08'                                        0166
*         DO WHILE MEMNAME(USRLEN)    /* SCAN FOR BLANKS             */
*          = ' ';                                                  0167
         B     @DE00167                                            0167
@DL00167 DS    0H                                                  0168
*           USRLEN = USRLEN-1;        /* DECREMENT LENGTH OF USERID  */
         SLR   @10,@10                                             0168
         IC    @10,USRLEN                                          0168
         BCTR  @10,0                                               0168
         STC   @10,USRLEN                                          0168
*           END;                                                   0169
@DE00167 SLR   @10,@10                                             0169
         IC    @10,USRLEN                                          0169
         ALR   @10,MEMPTR                                          0169
         AL    @10,@CF00248                                        0169
         CLI   MEMNAME(@10),C' '                                   0169
         BE    @DL00167                                            0169
*         /* CHECK THE 1ST NON-BLANK CHARACTER. IF IT IS '0', THEN   */
*         /* THIS IS A BASE MEMBER & WILL BE PUT INTO THE OUTPUT     */
*         /* LINE. IF NOT, THEN IT IS EITHER AN EXTENSION OF THE     */
*         /* PREVIOUS MEMBER OR THE END OF THE DIRECTORY.            */
*         IF MEMNAME(USRLEN) = '0'    /* BASE MEMBER?                */
*           THEN                      /* YES,                        */
         SLR   @10,@10                                             0170
         IC    @10,USRLEN                                          0170
         ALR   @10,MEMPTR                                          0170
         AL    @10,@CF00248                                        0170
         CLI   MEMNAME(@10),C'0'                                   0170
         BNE   @RF00170                                            0170
*             DO;                                                  0171
*             USRLEN = USRLEN-1;      /* DECREMENT PAST INDEX        */
         SLR   @10,@10                                             0172
         IC    @10,USRLEN                                          0172
         BCTR  @10,0                                               0172
         STC   @10,USRLEN                                          0172
*             GOTO FORMAT;            /* GO PUT IT INTO THE OUTPLINE */
         B     FORMAT                                              0173
*             END;                                                 0174
*         /* IS IT THE END OF THE DIRECTORY (ALL BINARY ONES)?       */
*         IF MEMNAME =                /* END OF DIRECTORY?           */
*           'FFFFFFFFFFFFFFFF'X                                    0175
*           THEN                      /* YES,                        */
@RF00170 CLC   MEMNAME(8,MEMPTR),@CB00218                          0175
         BNE   @RF00175                                            0175
*             /* CHECK WHETHER ANY USERIDS ARE LEFT IN THE OUTPUT    */
*             /* LINE.                                               */
*             IF USCNT > 0            /* ANY USERIDS LEFT?           */
*               THEN                  /* YES,                        */
         LTR   USCNT,USCNT                                         0176
         BNP   @RF00176                                            0176
*                 DO;                                              0177
*                   EODFLG = '1'B;    /* 1- END OF DIRECTORY, NO MORE
*                                        USERIDS TO BE EXTRACTED     */
         OI    EODFLG,B'01000000'                                  0178
*                   GOTO PUTLN;       /* PUT OUT REMAINING USERIDS   */
         B     PUTLN                                               0179
*                 END;                                             0180
*               ELSE                  /* NO, ALL USERIDS HAVE BEEN 0181
*                                        PUT OUT                     */
*                 GOTO MODEMSG;       /* ISSUE MODE MESSAGE          */
*NEXTMEM: /* REFERENCE THE NEXT MEMBER ENTRY BY INCREMENTING THE     */
*         /* BASE POINTER BY THE CONSTANT LENGTH OF AN ENTRY AND THE */
*         /* NUMBER OF USER HALF-WORDS CONTAINED IN BLOKC.           */
*         MEMPTR = MEMPTR+12+(BLOKC&'00011111'B)*2;                0182
@RF00175 DS    0H                                                  0182
NEXTMEM  LA    @10,12                                              0182
         ALR   @10,MEMPTR                                          0182
         LA    @07,31                                              0182
         SLR   @04,@04                                             0182
         IC    @04,BLOKC(,MEMPTR)                                  0182
         NR    @07,@04                                             0182
         ALR   @07,@07                                             0182
         ALR   @10,@07                                             0182
         LR    MEMPTR,@10                                          0182
*         /* CHECK FOR END OF BLOCK BY COMPARING THE BASE POINTER    */
*         /* TO THE ADDR OF THE BLOCK PLUS THE NUMBER OF BYTES USED  */
*         /* ON THE BLOCK.                                           */
*         IF MEMPTR >= ADDR(DIRYBLK)+NUMBYTES                      0183
*           THEN                      /* YES, END OF BLOCK,          */
         LA    @10,DIRYBLK                                         0183
         SLR   @07,@07                                             0183
         ICM   @07,3,NUMBYTES                                      0183
         ALR   @10,@07                                             0183
         CR    MEMPTR,@10                                          0183
         BNL   @RT00183                                            0183
*             GOTO READLVL;           /* GO READ THE NEXT BLOCK      */
*           ELSE                      /* NO,                         */
*             GOTO LNGFNDR;           /* GO CALCULATE THE LENGTH     */
         B     LNGFNDR                                             0185
*FORMAT:  /* PUT THE USERID INTO THE OUTPUT LINE.                    */
*         USERIDS = MEMNAME(1:USRLEN);                             0186
FORMAT   MVI   USERIDS+7(OUTAPTR),C' '                             0186
         MVC   USERIDS+8(8,OUTAPTR),USERIDS+7(OUTAPTR)             0186
         SLR   @10,@10                                             0186
         IC    @10,USRLEN                                          0186
         BCTR  @10,0                                               0186
         EX    @10,@SM00250                                        0186
*         OUTAPTR = OUTAPTR+10;       /* POINT TO THE NEXT USERID  0187
*                                        POSITION IN THE OUTPUT LINE */
         LA    @10,10                                              0187
         ALR   OUTAPTR,@10                                         0187
*         USCNT = USCNT+1;            /* INCREMENT THE USERID COUNT  */
         AH    USCNT,@CH00032                                      0188
*         /* IF THE OUTPUT LINE IS FULL, SEND IT TO THE TERMINAL.    */
*         IF USCNT < 10               /* OUTPUT LINE FULL?           */
*           THEN                      /* NO,                         */
         CR    USCNT,@10                                           0189
         BL    @RT00189                                            0189
*             GOTO NEXTMEM;           /* CONTINUE WITH NEXT ENTRY    */
*                                                                  0190
*PUTLN:   /* PREPARE TO CALL THE PUTLINE SERVICE ROUTINE TO PUT      */
*         /* ONE LINE OF USERIDS OUT TO THE TERMINAL.                */
*         INDENT = '  ';              /* INDENTATION                 */
PUTLN    LA    @10,4                                               0191
         LA    @02,OUTPAREA                                        0191
         LR    @15,@02                                             0191
         ALR   @15,@10                                             0191
         MVC   INDENT(2,@15),@CC00225                              0191
*         NULBYTE = 0;                                             0192
         SLR   @15,@15                                             0192
         STH   @15,NULBYTE+2(,@02)                                 0192
*         LINLEN = 4+(USCNT*10);      /* LENGTH OF LINE IS THE NUMBER
*                                        OF USERIDS * 10 PLUS THE  0193
*                                        FOUR-BYTE HEADER            */
         LR    @15,USCNT                                           0193
         MH    @15,@CH00141                                        0193
         ALR   @15,@10                                             0193
         STH   @15,LINLEN(,@02)                                    0193
*         GEN (PUTLINE  OUTPUT=(OUTPAREA,,,DATA),MF=(E,PLPLIST))   0194
*           REFS(OUTPAREA,PLPLIST);                                0194
         PUTLINE  OUTPUT=(OUTPAREA,,,DATA),MF=(E,PLPLIST)
*         /* CHECK THE PUTLINE RETURN CODE.                          */
*         RFY R15 RSTD;               /* RESTRICT RETURN CODE REG    */
*         RTNCODE = R15;              /* SAVE THE RETURN CODE        */
         LR    RTNCODE,R15                                         0196
*         RFY R15 UNRSTD;             /* RELEASE RETURN CODE REG     */
*         IF RTNCODE ^= 0             /* WAS PUTLINE SUCCESSFUL?     */
*           THEN                      /* NO,                         */
         SLR   @10,@10                                             0198
         CR    RTNCODE,@10                                         0198
         BNE   @RT00198                                            0198
*             GOTO CHKPTL;            /* GO CHECK THE ERROR CODE     */
*         /* ARE THERE MORE USERIDS TO BE PUT OUT? IF YES, GO BACK   */
*         /* AND BUILD THE NEXT OUTPUT LINE.                         */
*         IF EODFLG = '1'B            /* END OF DIRECTORY?           */
*           THEN                      /* YES,                        */
         TM    EODFLG,B'01000000'                                  0200
         BO    @RT00200                                            0200
*             GOTO MODEMSG;           /* ISSUE MODE MSG & RETURN     */
*         USCNT = 0;                  /* SET COUNT BACK TO 0         */
         LR    USCNT,@10                                           0202
*         OUTAPTR = ADDR(OUTPAREA);   /* RESET PTR TO 1ST POSITION   */
         LA    OUTAPTR,OUTPAREA                                    0203
*         GOTO NEXTMEM;               /* CONTINUE WITH NEXT ENTRY    */
         B     NEXTMEM                                             0204
*         /***********************************************************/
*         /*                                                         */
*         /*                 HANDLING OF MESSAGES                    */
*         /*                                                         */
*         /***********************************************************/
*MODEMSG: /* LIST OR LISTIDS HAS COMPLETED SUCCESSFULLY.             */
*         POSTFLG = '1'B;             /* DO NOT POST THE ACCOUNT ECB */
MODEMSG  OI    POSTFLG,B'00100000'                                 0205
*         MSGNO =1;                   /* SET MESSAGE NUMBER          */
         LA    MSGNO,1                                             0206
*TMSGA:   /* CONTROL PASSED HERE FOR NON-INSERTION MESSAGES          */
*         CALL MSGFNDR;               /* GO CALCULATE MSG ADDR       */
TMSGA    BAL   @14,MSGFNDR                                         0207
*         GOTO PUTMSG;                /* GO ISSUE THE MSG            */
         B     PUTMSG                                              0208
*MLMSG:   /* CONTROL PASSED HERE FOR RETURN CODE MESSAGES.           */
*         CALL MSGFNDR;               /* GO CALCULATE MSG ADDR       */
MLMSG    BAL   @14,MSGFNDR                                         0209
*         CVD (RTNCODE,DECRTCD);      /* CONVERT CODE TO DECIMAL     */
         CVD   RTNCODE,DECRTCD                                     0210
*         UNPK (INSRTT1(1:2),DECRTCD(6:8));/* UNPACK INTO MSG.       */
         UNPK  INSRTT1(2),DECRTCD+5(3)                             0211
*         INSRTL1 = 6;                /* SET LENGTH OF SEGMENT       */
         MVC   INSRTL1(2),@CH00142                                 0212
*         INSRTT1(2) = INSRTT1(2)×'F0'X; /* REMOVE SIGN              */
         OI    INSRTT1+1,X'F0'                                     0213
*         SEGPTR23 = ADDR(INSRT1);    /* SET PTR TO ACTIVE INSERT    */
         LA    @10,INSRT1                                          0214
         ST    @10,SEGPTR23                                        0214
*         GOTO PUTMSG;                /* GO ISSUE THE MESSAGE        */
         B     PUTMSG                                              0215
*MPREP1:  /* CONTROL IS PASSED TO APPROPRIATE PARTS OF THIS SECTION  */
*         /* TO COMPLETE THE CONSTRUCTION OF INSERTION-TYPE MESSAGES */
*         CALL MSGFNDR;               /* GO CALCULATE THE MSG ADDR   */
MPREP1   BAL   @14,MSGFNDR                                         0216
*         /* INITIALIZE THE USERID INSERT SEGMENT.                   */
*         INSRTL1 = USRLEN+4;         /* LENGTH OF MSG SEGMENT       */
         SLR   @10,@10                                             0217
         IC    @10,USRLEN                                          0217
         LA    @15,4                                               0217
         ALR   @15,@10                                             0217
         STH   @15,INSRTL1                                         0217
*         INSRTT1 = USRID(1:USRLEN);  /* INSERT THE USERID           */
         MVI   INSRTT1+1,C' '                                      0218
         MVC   INSRTT1+2(38),INSRTT1+1                             0218
         BCTR  @10,0                                               0218
         EX    @10,@SM00253                                        0218
*         SEGPTR13 = ADDR(INSRT1);    /* SET PTR TO ACTIVE INSERT    */
         LA    @10,INSRT1                                          0219
         ST    @10,SEGPTR13                                        0219
*PUTMSG:  /* PREPARE TO CALL THE PUTLINE SERVICE ROUTINE.            */
*         GEN (PUTLINE OUTPUT=(AMSGHDR1,,MULTLVL),MF=(E,PLPLIST))  0220
*           REFS(AMSGHDR1,PLPLIST);                                0220
PUTMSG   PUTLINE OUTPUT=(AMSGHDR1,,MULTLVL),MF=(E,PLPLIST)
*         RFY R15 RSTD;               /* RESTRICT ENTRY POINT REG    */
*         RTNCODE = R15;              /* ASSIGN THE RETURN CODE      */
         LR    RTNCODE,R15                                         0222
*         RFY R15 UNRSTD;             /* RELEASE RETURN CODE REG     */
*         /* CHECK THE PUTLINE RETURN CODE.                          */
*         IF RTNCODE ^= 0             /* SUCCESSFUL?                 */
*           THEN                      /* NO,                         */
         LTR   RTNCODE,RTNCODE                                     0224
         BZ    @RF00224                                            0224
*             DO;                                                  0225
*CHKPTL:      IF RTNCODE = 4          /* ATTENTION INTERRUPT?        */
*                × PUTLFLG = '1'B     /* OR SECOND ATTEMPT TO PUT OUT
*                                        A MESSAGE?                  */
*               THEN                  /* YES, ONE OF THE ABOVE       */
CHKPTL   CH    RTNCODE,@CH00139                                    0226
         BE    @RT00226                                            0226
         TM    PUTLFLG,B'00010000'                                 0226
         BO    @RT00226                                            0226
*                 GOTO ACCTRET;       /* RETURN TO ACCOUNT           */
*             PUTLFLG = '1'B;         /* SET FLAG - ONE ATTEMPT HAS
*                                        BEEN MADE TO PUT OUT A MSG  */
*             POSTFLG = '0'B;         /* AN ERROR OCCURRED - THE ECB
*                                        WILL BE POSTED              */
         OI    PUTLFLG,B'00010000'                                 0229
         NI    POSTFLG,B'11011111'                                 0229
*             IF RTNCODE = 16         /* GETMAIN FAILURE?            */
*               THEN                  /* YES,                        */
         CH    RTNCODE,@CH00194                                    0230
         BNE   @RF00230                                            0230
*                 DO;                                              0231
*                 MSGNO = 2;          /* SET ERROR MSG NUMBER        */
         LA    MSGNO,2                                             0232
*                 GOTO TMSGA;         /* GO ISSUE THE MESSAGE        */
         B     TMSGA                                               0233
*                 END;                                             0234
*               ELSE                  /* NO, RTNCODE = 12            */
*                 DO;                                              0235
@RF00230 DS    0H                                                  0236
*                 MSGNO = 13;         /* SET MSG NUMBER              */
         LA    MSGNO,13                                            0236
*                 GOTO MLMSG;         /* GO CONSTRUCT THE MSG        */
         B     MLMSG                                               0237
*                 END;                                             0238
*             END;                                                 0239
*ACCTRET: /***********************************************************/
*         /*                                                         */
*         /*        PERFORM THE NECESSARY CLEANUP AND                */
*         /*        RETURN TO THE ACCOUNT COMMAND PROCESSOR          */
*         /*                                                         */
*         /***********************************************************/
*         /* DEQUEUE FROM THE UADS DATA SET                          */
*         IF ENQSW = '1'B             /* IS THE UADS ENQUEUED?       */
*           THEN                      /* YES,                        */
@RF00224 DS    0H                                                  0240
ACCTRET  TM    ENQSW,B'10000000'                                   0240
         BNO   @RF00240                                            0240
*             GEN (DEQ   ,MF=(E,UADDEQ))/* DEQ FROM THE UADS.        */
*               REFS(MAJNAME,MINNAME,UADDEQ);                      0241
         DEQ   ,MF=(E,UADDEQ)
*         RFY R2 RSTD;                /* RESTRICT DCB BASE REGISTER  */
@RF00240 DS    0H                                                  0243
*         /* CHECK THE OPEN FLAG IN THE UADS DCB. IF THE DIRECTORY IS*/
*         /* OPEN (FLAG=1), THE 'CLOSE' MACRO WILL BE ISSUED.        */
*         R2 = ADDR(UADSDCB);         /* LOAD ADDR OF DCB INTO REG2  */
         LA    R2,UADSDCB                                          0243
*         IF DCBOFLG = '1'B           /* IS THE UADS DCB OPEN?       */
*           THEN                      /* YES,                        */
         TM    DCBOFLG,B'00010000'                                 0244
         BNO   @RF00244                                            0244
*             GEN (CLOSE ((R2)),MF=(E,CLOSDIR))                    0245
*               REFS(CLOSDIR,R2);                                  0245
         CLOSE ((R2)),MF=(E,CLOSDIR)
*         RFY R2 UNRSTD;              /* RELEASE DCB BASE REGISTER   */
@RF00244 DS    0H                                                  0247
*         /* IF LIST OR LISTIDS WERE UNSUCCESSFUL, POST THE ECB TO   */
*         /* SIGNAL TO ACCOUNT TO ISSUE THE 'ACCOUNT' MESSAGE.       */
*         IF POSTFLG = '0'B                                        0247
*           THEN                                                   0247
         TM    POSTFLG,B'00100000'                                 0247
         BNZ   @RF00247                                            0247
*             ACCTECB = '40FFFFFF'X;  /* POST ACCOUNT'S ECB WITH ERRO*/
         L     @10,ACCTPLP                                         0248
         L     @10,ACCTECBP(,@10)                                  0248
         MVC   ACCTECB(4,@10),@CF00238                             0248
*/* LIST HAS COMPLETED PROCESSING -- RETURN TO ACCOUNT.              */
*         RETURN;                                                  0249
@EL00001 L     @13,4(,@13)                                         0249
@EF00001 L     @00,@SIZDATD                                        0249
         LR    @01,@11                                             0249
         FREEMAIN R,LV=(0),A=(1)
@ER00001 LM    @14,@12,12(@13)                                     0249
         BR    @14                                                 0249
*         /***********************************************************/
*         /* THIS SUBROUTINE CALCULATES THE ADDRESS OF A MESSAGE IN  */
*         /* THE CHANGE MESSAGE CSECT IKJEFA21.                      */
*         /***********************************************************/
*MSGFNDR: PROC;                                                    0250
MSGFNDR  STM   @14,@12,12(@13)                                     0250
*         MSGFIND = (MSGNO*2)-2       /* CALCULATE ADDR OF OFFSET TO */
*           +ADDR(LSTMSG);            /* MSG IN THE MSG CSECT        */
         LR    MSGFIND,MSGNO                                       0251
         ALR   MSGFIND,MSGFIND                                     0251
         BCTR  MSGFIND,0                                           0251
         BCTR  MSGFIND,0                                           0251
         L     @10,@CV00049                                        0251
         ALR   MSGFIND,@10                                         0251
*         MSGPTR = MOFFSET+ADDR(LSTMSG);/* CALCULATE ADDR OF MSG   0252
*                                          HEADER IN THE MSG CSECT   */
         L     MSGPTR,@CV00049                                     0252
         AH    MSGPTR,MOFFSET(,MSGFIND)                            0252
*         MINDX = (SGNO1*4)+8;        /* NUMBER OF BYTES IN MSGHEADR */
         LA    @10,8                                               0253
         L     MINDX,SGNO1(,MSGPTR)                                0253
         SLA   MINDX,2                                             0253
         ALR   MINDX,@10                                           0253
*         AMSGHDR1(1:MINDX) =         /* TRANSFER MSG HEADER TO..    */
*           PTRMASK1;                 /* ..DYNAMIC HEADER AREA       */
         LR    @05,MINDX                                           0254
         BCTR  @05,0                                               0254
         EX    @05,@SM00255                                        0254
*         /* IF THIS IS NOT A MULTI-LEVEL MESSAGE, THEN BYPASS THE   */
*         /* MESSAGE HEADER TRANSFER.                                */
*         IF NXTLADR1 ^= '0'B                                      0255
*           THEN                      /* YES, MULTI-LEVEL MSG        */
         L     @15,NXTLADR1(,MSGPTR)                               0255
         LTR   @15,@15                                             0255
         BZ    @RF00255                                            0255
*             DO;                                                  0256
*             SEGPTR10 = ADDR(AMSGHDR2);/* POINT TO 2ND LEVEL        */
         LA    @05,AMSGHDR2                                        0257
         ST    @05,SEGPTR10                                        0257
*             MINDX = (SGNO2*4)+8;    /* NUMBER OF BYTES IN MSGHEADR */
         L     MINDX,SGNO2(,@15)                                   0258
         SLA   MINDX,2                                             0258
         ALR   MINDX,@10                                           0258
*             AMSGHDR2(1:MINDX) =     /* TRANSFER MSG HEADER TO..    */
*               PTRMASK2;             /* ..DYNAMIC HEADER AREA       */
         LR    @10,MINDX                                           0259
         BCTR  @10,0                                               0259
         EX    @10,@SM00257                                        0259
*             END;                                                 0260
*         END MSGFNDR;                /* RETURN TO POINT OF CALL     */
@EL00002 DS    0H                                                  0261
@EF00002 DS    0H                                                  0261
@ER00002 LM    @14,@12,12(@13)                                     0261
         BR    @14                                                 0261
*         END IKJEFA40                                             0262
*/* THE FOLLOWING INCLUDE STATEMENTS WERE FOUND IN THIS PROGRAM.      *
*/*%INCLUDE SYSLIB  (IKJIOPL )                                        *
*/*%INCLUDE SYSLIB  (IKJPPL  )                                        *
*;                                                                 0262
@DATA    DS    0H
@CH00032 DC    H'1'
@CH00059 DC    H'2'
@CH00139 DC    H'4'
@CH00207 DC    H'5'
@CH00142 DC    H'6'
@CH00073 DC    H'8'
@CH00202 DC    H'9'
@CH00141 DC    H'10'
@CH00187 DC    H'12'
@CH00204 DC    H'13'
@CH00205 DC    H'14'
@CH00194 DC    H'16'
@CH00192 DC    H'20'
@CH00201 DC    H'30'
@SM00243 MVC   CPLS(0),MCPLS
@SM00246 MVC   INSRTT1(0),ACCTNO
@SM00250 MVC   USERIDS+6(0,OUTAPTR),MEMNAME(MEMPTR)
@SM00253 MVC   INSRTT1(0),USRID
@SM00255 MVC   AMSGHDR1(0),PTRMASK1(MSGPTR)
@SM00257 MVC   AMSGHDR2(0),PTRMASK2(@15)
@DATD    DSECT
         DS    0F
@SA00001 DS    18F
IKJEFA40 CSECT
         DS    0F
@CF00248 DC    F'-1'
@CF00238 DC    XL4'40FFFFFF'
@DATD    DSECT
         DS    0D
LSTPDLAD DS    A
VCHKPL   DS    CL26
         ORG   VCHKPL
EXITADD  DS    AL4
EXITRTCD DS    AL4
NODEPTR  DS    AL4
@NM00003 DS    AL4
PPLPTR   DS    AL4
SAVARAD  DS    AL4
CMDIND   DS    FL1
NUMOFLV  DS    FL1
         ORG   VCHKPL+26
         DS    CL2
CTAB     DS    CL16
         ORG   CTAB
ACCTPLP  DS    AL4
NODELADR DS    AL4
RWPLADR  DS    AL4
MSGNMBR  DS    AL4
         ORG   CTAB+16
ACIOPARM DS    CL24
         ORG   ACIOPARM
@NM00004 DS    AL4
         ORG   @NM00004
ACIOFLGS DS    CL1
         ORG   ACIOFLGS
@NM00005 DS    BL1
@NM00006 EQU   ACIOFLGS+0
@NM00007 EQU   ACIOFLGS+0
@NM00008 EQU   ACIOFLGS+0
@NM00009 EQU   ACIOFLGS+0
         ORG   @NM00004+1
ACIODCBA DS    AL3
         ORG   ACIOPARM+4
@NM00010 DS    AL4
ACIODRCT DS    AL4
@NM00011 DS    AL4
@NM00012 DS    AL4
ACIOPUTL DS    AL4
         ORG   ACIOPUTL
MSGID    DS    CL1
         ORG   ACIOPARM+24
PARSLIST DS    CL28
NLSTTAB  DS    CL66
         ORG   NLSTTAB
USRLEN   DS    FL1
USRID    DS    CL8
PASSWD   DS    CL8
ACTLEN   DS    FL1
ACCTNO   DS    CL40
PROCNM   DS    CL8
         ORG   NLSTTAB+66
INDIC    DS    CL1
         ORG   INDIC
ENQSW    DS    BL1
EODFLG   EQU   INDIC+0
POSTFLG  EQU   INDIC+0
PUTLFLG  EQU   INDIC+0
         ORG   INDIC+1
         DS    CL1
DIRYWA   DS    CL344
         ORG   DIRYWA
UADSDCB  DS    CL88
DIRYBLK  DS    CL256
         ORG   DIRYBLK
NUMBYTES DS    CL2
         ORG   DIRYWA+344
OUTPAREA DS    CL110
PLPLIST  DS    CL16
         DS    CL2
AMSGHDR1 DS    CL32
         ORG   AMSGHDR1
SEGPTR10 DS    AL4
@NM00016 DS    3A
SEGPTR13 DS    AL4
@NM00017 DS    3A
         ORG   AMSGHDR1+32
AMSGHDR2 DS    CL32
         ORG   AMSGHDR2
@NM00018 DS    AL4
@NM00019 DS    3A
SEGPTR23 DS    AL4
@NM00020 DS    3A
         ORG   AMSGHDR2+32
INSRT1   DS    CL44
         ORG   INSRT1
INSRTL1  DS    AL2
INSRTO1  DS    AL2
INSRTT1  DS    CL40
         ORG   INSRT1+44
         DS    CL4
DECRTCD  DS    CL8
IKJEFA40 CSECT
         DS    0F
@SIZDATD DC    AL1(1)
         DC    AL3(@ENDDATD-@DATD)
@CV00049 DC    V(LSTMSG)
@CV00050 DC    V(IKJEFA42)
@CV00051 DC    V(IKJEFA51)
@CV00052 DC    V(IKJEFA55)
         DS    0D
PCLMDLAD DC    AL4(PCLMODEL)
@CC00225 DC    C'  '
@CB00218 DC    X'FFFFFFFFFFFFFFFF'
MAJNAME  DC    CL8'SYSIKJUA'
MINNAME  DC    CL8'OPENUADS'
@DATD    DSECT
IKJEFA40 CSECT
PCLMODEL IKJPARM  DSECT=LISTPDLD
NODEPDE  IKJPOSIT PSTRING,PROMPT='(NODELIST)',VALIDCK=IKJEFA55
         IKJENDP
         EXTRN IKJEFA55
MCPLS    DS   0D
         CLOSE (,REREAD),MF=L
         DEQ   (MAJNAME,MINNAME,8,SYSTEM),RET=HAVE,MF=L
         ENQ   (MAJNAME,MINNAME,S,8,SYSTEM),RET=HAVE,MF=L
         OPEN  (,INPUT),MF=L
         PUTLINE OUTPUT=(0,TERM,MULTLVL,INFOR),MF=L
MCPLNG   DC    A(*-MCPLS)               LENGTH OF MODEL PARAMETER LIST
UADSBLK  DCB   DDNAME=SYSUADS,BLKSIZE=256,DSORG=PS,MACRF=(R),RECFM=F
         DCBD  DSORG=(PS),DEVD=(DA)
@DATD    DSECT                          REESTABLISH AUTOMATIC DSECT
CPLS     DS    0D
CLOSDIR  CLOSE (,REREAD),MF=L
UADDEQ   DEQ   (MAJNAME,MINNAME,8,SYSTEM),RET=HAVE,MF=L
UADENQ   ENQ   (MAJNAME,MINNAME,S,8,SYSTEM),RET=HAVE,MF=L
OPENDIR  OPEN  (,INPUT),MF=L
PBLOK    PUTLINE OUTPUT=(0,TERM,MULTLVL,INFOR),MF=L
IKJEFA40 CSECT
         DS   0H
PATCHLOC DC ((@DATA-@PSTART)/20)X'00'
@DATD    DSECT
         ORG   *+1-(*-@DATD)/(*-@DATD) INSURE DSECT DATA
@ENDDATD EQU   *
IKJEFA40 CSECT
@00      EQU   00                      EQUATES FOR REGISTERS 0-15
@01      EQU   01
@02      EQU   02
@03      EQU   03
@04      EQU   04
@05      EQU   05
@06      EQU   06
@07      EQU   07
@08      EQU   08
@09      EQU   09
@10      EQU   10
@11      EQU   11
@12      EQU   12
@13      EQU   13
@14      EQU   14
@15      EQU   15
MINDX    EQU   @04
MSGNO    EQU   @03
MSGPTR   EQU   @02
MSGFIND  EQU   @04
USCNT    EQU   @05
OUTAPTR  EQU   @06
MEMPTR   EQU   @03
RTNCODE  EQU   @04
IOPLPTR  EQU   @03
R1       EQU   @01
R2       EQU   @02
R15      EQU   @15
IOPL     EQU   0
IOPLIOPB EQU   IOPL+12
PPL      EQU   0
PPLPCL   EQU   PPL+12
PPLANS   EQU   PPL+16
PPLCBUF  EQU   PPL+20
PPLUWA   EQU   PPL+24
ACCTPL   EQU   0
ACCTECBP EQU   ACCTPL+8
BUFPTR   EQU   ACCTPL+12
UIDLPTR  EQU   ACCTPL+16
ACCTECB  EQU   0
ATTENTN  EQU   ACCTECB
@NM00013 EQU   0
MEMNAME  EQU   @NM00013
BLOKC    EQU   @NM00013+11
LINLEN   EQU   0
NULBYTE  EQU   0
INDENT   EQU   0
USERIDS  EQU   0
MOFFSET  EQU   0
PTRMASK1 EQU   0
NXTLADR1 EQU   PTRMASK1
SGNO1    EQU   PTRMASK1+4
PTRMASK2 EQU   0
SGNO2    EQU   PTRMASK2+4
DCBOFLG  EQU   DCBOFLGS
         AGO   .@UNREFD                START UNREFERENCED COMPONENTS
@NM00021 EQU   DCBOFLGS
@NM00015 EQU   PTRMASK2
@NM00014 EQU   @NM00013+8
@NM00002 EQU   ACCTECB
@NM00001 EQU   ACCTPL
PPLECB   EQU   PPL+8
PPLECT   EQU   PPL+4
PPLUPT   EQU   PPL
IOPLECB  EQU   IOPL+8
IOPLECT  EQU   IOPL+4
IOPLUPT  EQU   IOPL
.@UNREFD ANOP                          END UNREFERENCED COMPONENTS
@RT00045 EQU   LISTIDS
@RT00061 EQU   PRSOK
@RT00065 EQU   ACCTRET
@RT00072 EQU   ACCTRET
@RT00101 EQU   ACCTRET
@RT00110 EQU   ACCTRET
@RT00112 EQU   MODEMSG
@RT00114 EQU   ACCTRET
@RT00117 EQU   TMSGA
@RT00119 EQU   MPREP1
@RT00121 EQU   MLMSG
@RC00128 EQU   PUTMSG
@RC00126 EQU   PUTMSG
@RT00149 EQU   ACCTRET
@RT00160 EQU   ACCTRET
@RF00176 EQU   MODEMSG
@RT00183 EQU   READLVL
@RF00183 EQU   LNGFNDR
@RT00189 EQU   NEXTMEM
@RT00198 EQU   CHKPTL
@RT00200 EQU   MODEMSG
@RT00226 EQU   ACCTRET
@RF00247 EQU   @EL00001
@RF00255 EQU   @EL00002
@PB00002 EQU   @EL00001
@ENDDATA EQU   *
         END   IKJEFA40
