         TITLE 'IKJEGASN, ''ASSIGN'' SUBCOMMAND OF TEST'
         COPY   IKJEGSIO
         EJECT
         MACRO
         VALUPDE
***********************************************************************
*                                                                     *
*        MAPPING DSECT FOR PDES FOR VALUES                            *
*                                                                     *
*        STATUS -- VERSION NO. 01 - RELEASE NO. 01                    *
*                                                                     *
*        CHANGE LEVEL -- 00 - DATE 03/09/72                           *
*                                                                     *
***********************************************************************
VALUPDE  DSECT
VALUPTR  DS    F -                      POINTER TO CHARACTER STRING,
*                                       FIRST BYTE AFTER QUOTE
VALULNH  DS    H -                      LENGTH OF CHARACTER STRING,
*                                       EXCLUDING QUOTES
VALUFLG  DS    XL1 -                    FLAG
VALUBIT  EQU   B'10000000' -            BIT ON MEANS VALUE PRESENT
VALUTYPE DS    CL1 -                    TYPE CHARACTER (CHARACTER
*                                       PRECEDING QUOTE)
VALUCHAI DS    F -                      ADDRESS OF NEXT VALUE
*                                       PDE ON CHAIN
VALUPDL  EQU   *-VALUPDE -              LENGTH OF VALUE PDE
         MEND
         EJECT
***********************************************************************
*                                                                     *
* STATUS--                                                            *
*    CHANGE LEVEL 00, VERSION NUMBER 02, OS/VS2 (5/17/73)             *
*                                                                     *
* FUNCTION--                                                          *
*    IKJEGASN WILL REPLACE THE CONTENTS OF USER DESIGNATED            *
*    AREAS OF CORE STORAGE OR REGISTERS WITH VALUES SPECIFIED         *
*    BY THE USER.  CORE STORAGE AREAS ARE PATCHED BY A MVC            *
*    INSTRUCTION AND REGISTER CONTENTS ARE MODIFIED BY ISSUING        *
*    A SUPERVISOR CALL (SVC 97)  WITH THE IKJEGS9G MACRO.             *
*                                                                     *
*    CONTROL IS RECEIVED WHEN IKJEGPCH ISSUES A BRANCH INSTRUCTION    *
*    IKJEGASN MUST DETERMINE WHAT TYPE OF DATA THE USER HAS           *
*    SPECIFIED AS AN OPERAND.  IF NECESSARY, IKJEGASN WILL            *
*    BRANCH TO IKJEGCVT TO CONVERT DATA STRINGS TO REQUESTED FORMAT.  *
*                                                                     *
*    THE DATA IS MOVED INTO THE ADDRESS SPCEFIED BY THE USER.         *
*    HOWEVER, IF THE ADDRESS IS A REGISTER, THE ASSIGNED VALUE        *
*    IS PLACED INTO THE REGISTER BY IKJEGS9G(SVC97).                  *
*                                                                     *
*    A RETURN CODE IS SET IN REGISTER 15 AND CONTROL IS RETURNED      *
*    TO IKJEGMNL BY BRANCHING ON REGISTER 14.                         *
*                                                                     *
* ENTRY POINTS--                                                      *
*         IKJEGASN  MAIN ENTRY POINT, ENTERED FROM IKJEGPCH BY AN XCTL*
*                                                                     *
* INPUT--                                                             *
*    PCHWORK   THE ASSIGNMENT COMMAND WORKAREA INITIALIZED BY         *
*    MODULE IKJEGPCH AND CONTAINING THE FIRST OR ONLY VALUE PDE AND   *
*    THE NECESSARY VARIABLES TO PERFORM THE PATCH.                    *
*    REGISTER NINE POINTS TO THE TCOMTAB                              *
*                                                                     *
* OUTPUT--                                                            *
*    THE CONVERTED VALUE IN THE REQUESTED CORE STORAGE LOCATION OR    *
*    REGISTER.                                                        *
*    REGISTER FIFTEEN CONTAINS A RETURN CODE                          *
*                                                                     *
* EXTERNAL REFERENCES--                                               *
*         IKJEGCVT FOR CONVERSION OF ADDRESSES TO BINARY AND VALUES TO*
*         THE MACHINE FORMAT OF THE TYPE SPECIFIED.                   *
*         IKJEGI0 FOR OUTPUTTING MESSAGES.                           *
*                                                                     *
* EXITS, NORMAL--                                                     *
*         BRANCH REGISTER 14 RETURNING TO CALLER WITH A CONDITION CODE*
*         OF ZERO FOR SUCCESSFUL COMPLETION OR DIAGNOSTIC ERROR AND A *
*         RETURN CODE OF SIXTEEN (16) IF AN ATTENTION HAS BEEN        *
*         SCHEDULED.                                                  *
*                                                                     *
* EXITS, ERROR--                                                      *
*         BRANCH REGISTER 14 RETURNING TO CALLER WITH A CONDITION CODE*
*         OF TWENTY (20) FROM THE STAE RETRY ROUTINE AFTER AN ABEND,  *
*        OF 24 INDICATING THE ESTAE MACRO FAILED, 16 AN ATTN.         *
*                                                                     *
* TABLES/WORK AREAS --                                                *
*    1 TCOMTAB, POINTED AT BY REG 9 IS THE TEST COMMUNICATIONS TABLE  *
*    2 PCHWORK, A DESECT WHICH DESCRIBES PART OF THE COMMON WORKING   *
*    CORE MAINTAINED BY TEST AND POINTED AT BY 'WORKAREA' IN TCOMTAB. *
*    3 PARAMETER DESCRIPTOR LIST (PDL) PREPARED BY IKJPARSE TO        *
*    DESCRIBE THE VARIOUS FIELDS OF THE PARSED SUBCOMMAND             *
*                                                                     *
* ATTRIBUTES--                                                        *
*    REENTRANT, REFRESHABLE, PROBLEM PROGRAM.                         *
*                                                                     *
* CHARACTER CODE DEPENDENCY--                                         *
*    OPERATION OF THIS MODULE REQUIRES AND DEPENDS ON THE BIT         *
*    PATTERNS AND BINARY VALUES OF THE EBCDIC CHARACTER SET.          *
*    THE DEPENDENCY IS IN TABLE 'PCHTRTBL'. OTHER PORTIONS OF         *
*    THE MODULE REQUIRE ONLY REASSEMBLY FOR CHANGE OF CODE.           *
*                                                                     *
* NOTES--                                                             *
*    THIS MODULE REQUIRES THE STANDARD INSTRUCTION SET.               *
*                                                                     *
***********************************************************************
IKJEGASN CSECT
         SPACE
* REGISTER EQUATES.
         SPACE
R0       EQU   0                   REGISTER EQUATE
R1       EQU   1                   PARAMETER REGISTER
R2       EQU   2                   REGISTER EQUATE
R3       EQU   3                   REGISTER EQUATE
R4       EQU   4                   REGISTER EQUATE
R5       EQU   5                   REGISTER EQUATE
R6       EQU   6                   REGISTER EQUATE
R7       EQU   7                   REGISTER EQUATE
R8       EQU   8                   REGISTER EQUATE
R9       EQU   9                   BASE REG FOR TCOMTAB, COMM. DSECT
R10      EQU   10                  INTERNAL LINK REG FOR THIS MODULE
R11      EQU   11                  BASE REG FOR THIS PROGRAM.
R12      EQU   12                  *
R13      EQU   13                  PTR TO CURRENT SAVE AREA.
R14      EQU   14
R15      EQU   15
         SPACE 2
*  DATA EQUATES FOR OPERANDS OF IMMEDIATE TYPE INSTRUCTIONS.
         SPACE
NULL     EQU   0                   USED FOR BALR R,0 AND BCTR R,0.
ZERO     EQU   0
ONE      EQU   1                   SYMBOLIC FOR THE NUMBER 1
THREE    EQU   3                   SYMBOLIC FOR THE QUANTITY '3'
FOUR     EQU   4
EIGHT    EQU   8
SIXTEEN  EQU   16
TWENTY   EQU   20                  VALUE FOR COMPARE
B1       EQU   1                   USED AS A SHIFT VALUE TO DIVIDE BY 2
PLUS     EQU   C'+'                USED IN IMMEDIATE OPERANDS
MINUS    EQU   C'-'                USED IN IMMEDIATE OPERANDS
QUOTE    EQU   C''''               USED FOR SCANNING CHAR STRINGS.
ODD      EQU   X'01'               FOR TESTING WHETHER AN ADDR IS ODD.
R10OFF   EQU   60                  OFFSET INTO SAVE AREA FOR R10
M2OFFSET EQU   80                  OFFSET INTO BUFFER FOR 2ND LEVEL MSG
LL00IDL  EQU   14                  LENGTH OF LL00 AND ID FLDS OF MSG
CGRPLEN  EQU   64                  QUANTITY OF CHAR DATA FOR ONE GROUP
         SPACE
FOREPTR  EQU   8                   OFFSET TO FOREWARD PTR IN SAVE AREA
BACKPTR  EQU   4                   OFFSET TO BACKWARD PTR IN SAVE AREA
CONLNTH  EQU   0                   OFFSET INTO CONVERT OUTPUT FOR LNTH
CONDATA  EQU   1                   OFFSET INTO CONVERT OUTPUT FOR DATA
         SPACE
LOTOHI   EQU   24                  SHIFT VALUE TO GET LOW BYTE TO HIGH
LOGONBIT EQU   X'40'               FOR TESTING AND ECB FOR LOGON POSTED
DWBDY    EQU   B'00000111'         USED TO TEST ADDRS FOR DBL WRD BDY.
FWBDY    EQU   B'00000011'                                FULL
HWBDY    EQU   B'00000001'                                HALF
ASNFIRST EQU   B'00010000'         FIRST TIME SWITCH FOR ASSIGN
         SPACE
HEXFF    EQU   X'FF'
ATTNBIT  EQU   B'01000000'
         SPACE
*  THE FOLLOWING TABLE CONTAINS THE INTERNAL ASSEMBLER TYPE CODES.
         SPACE
CHARCODE EQU   X'00'               TYPE ATTRIBUTE =CHAR
HEXCODE  EQU   X'04'                ''     ''     =HEXADECIMAL
BINCODE  EQU   X'08'                ''     ''     =BINARY
HCODE    EQU   X'14'                ''     ''       ''   '', HALFWORD
ECODE    EQU   X'18'                ''     ''     =FLT PT, FULLWORD
PACKCODE EQU   X'30'                ''     ''     =PACKED DECIMAL
ZONECODE EQU   X'34'                ''     ''     =ZONED DECIMAL
         SPACE
*  SYMBOLIC OFFSETS INTO THE MESSAGE CSECT FOR VARIOUS MESSAGE
         SPACE
MSG101   EQU   101                 INVALID ADDRESS+
MSG280   EQU   280                 **** WORD BOUNDRY REQUIRED
INST2    EQU   2                   SECOND FIXED INSERT (HALF)
INST3    EQU   3                   THIRD FIXED INSERT (FULL)
INST4    EQU   4                   FOURTH FIXED INSERT (DOUBLE)
MSG011   EQU   11                  LENGTH ERROR FOR VALUE BEGINNING--
MSG213   EQU   213                 DATA LENGTH EXCEEDS REGISTER
MSG012   EQU   12                  DATA TYPE ERROR FOR VALUE BEGINNING
MSG214   EQU   214                 INVALID DATA TYPES ARE X OR E
MSG215   EQU   215                 INVALID DATA TYPES ARE X OR D
MSG013   EQU   13                  DATA AREA CONTAINED BREAKPOINTS
MSG216   EQU   216                 BREAKPOINTS WERE DEACTIVATED---
MSG014   EQU   14                  UNABLE TO MODIFY CONTAINS OF REG
MSG283   EQU   283                 SVC97 NONZERO RETURN CODE
         EJECT
         TITLE 'IKJEGASN, ''ASSIGN'' SUBCOMMAND OF TEST, INITIALIZE'
***********************************************************************
*                                                                     *
*  BEGIN WITH ESTABLISHING ADDRABILITY, NOTE WE DO NOT STORE REGS     *
*  AS WE ARE ONLY BRANCH ENTERED. R13 WAS NOT BACKED UP...            *
*                                                                     *
***********************************************************************
         LR    R11,R15             PICK UP ENTRY POINT ADDR FOR BASE
         USING IKJEGASN,R11
         USING TCOMTAB,R9
*        CROSS CHAINNING OF REGISTER SAVE AREAS IS CORRECT.....
         SPACE
         STM   R10,R12,R10OFF(R13) SAVE BASE IN CASE OF ABEND
         SPACE
         L     R10,WORKAREA        GET PTR TO WORKING CORE
         USING TSTCWORK,R10
         LA    R10,CWORKCMD        SET UP BASE OF SUB-CMD WORK CORE
         USING PCHWORK,R10
         MVI   ASNFLGS1,ZERO       INITIALIZE LOCAL FLAGS
         SPACE
***********************************************************************
*                                                                     *
*  AT THIS POINT, INITIALIZATION IS COMPLETE. THE PCHWORK DSECT HAS   *
*  BEEN SET UP BY IKJEGPCH AND PROCESSING MAY BEGIN.                  *
*        NEXT, TEST FOR THE 3 SPECIAL TYPES OF C, X, AND Z. IF NONE   *
*        OF THESE, FALL THROUGH AND GO TO CONVERT.                    *
***********************************************************************
PCH020   EQU   *
         LA    R8,VPDE
         USING VALUPDE,R8
         CLI   VALUTYPE,HEXCODE    IS THE TYPE HEX
         BE    XTYPE               IF HEX, BRANCH
         CLI   VALUTYPE,CHARCODE   IS THE TYPE CHARACTER
         BE    CTYPE               IF CHARACTER, BRANCH
         CLI   VALUTYPE,ZONECODE   IS THE TYPE ZONED DECIMAL
         BE    ZTYPE               IF ZONED, BRANCH
         SPACE
*  TYPE WAS NOT ONE OF THE SPECIAL 3.  NEXT GO CONVERT THE VALUE.
*  REGISTERS MUST BE SET UP AS FOLLOWS.
*        0     SET TO ZERO TO SHOW CONVERT TO BINARY
*        1     POSITIVE ADDR OF THE VALUE PDE
*        14    LINK REGISTER
*        15    ENTRY POINT OF CONVERT ROUTINE
         SPACE
         SR    R0,R0               REG 0 TO ZERO
         LA    R1,VPDE             REG 1 = ADDR OF VALUE PDE
         L     R15,TSTCONVT        GET ADDR OF CONVERT ROUTINE
         SPACE
         BALR  R14,R15             GO CONVERT A VALUE
         LTR   R15,R15             IS RETURN CODE ZERO
         BNZ   CVTRC               IF NON ZERO, BRANCH
         SPACE
         IC    R15,VALUTYPE        GET INPUT FORMAT TYPE
* PLEASE NOTE THAT A BRANCH TABLE HAS BEEN USED IN LIEU OF NUMEROUS   *
* TESTS FOR INPUT FORMAT TYPE.                                        *
         B     TYPEBTBL(R15)       GO TO PROPER ADDRESS ANALYSIS RTN
         SPACE
         ORG   *-BINCODE           ELIMINATE SPACE FOR C AND X CODES
TYPEBTBL EQU   *
         ORG   *+BINCODE           RESET LOCATION CTR FOR BRANCH TABLE
         B     BTYPE               CODE X'08' FOR BINARY
         B     XTYPE               CODE X'0C' THIS CODE NOT USED.
         B     FTYPE               CODE X'10' FOR FULLWORD FIXED PT
         B     HTYPE               CODE X'14' FOR HALFWORD FIXED PT
         B     ETYPE               CODE X'18' FOR SHORT FLT PT
         B     DTYPE               CODE X'1C' FOR LONG FLT PT
         B     AQTYPE              CODE X'20' FOR A AND Q ADDR CNSTNTS
         B     YTYPE               CODE X'24' FOR Y ADDR CONSTANTS
         B     STYPE               CODE X'28' FOR S ADDR CONSTANTS
         B     VTYPE               CODE X'2C' FOR V ADDR CONSTANTS
         B     PTYPE               CODE X'30' FOR PACKED DECIMAL
         TITLE 'IKJEGASN, ''ASSIGN'' SUBCOMMAND OF TEST, MAIN PROCESS'
PCH038   EQU   *
BTYPE    EQU   *
PTYPE    EQU   *
         TM    A1TYPE,GENR+SFPR+LFPR   IS ADDRESS TYPE REGISTER
         BNZ   REGADDR             IF ADDR IS REG TYPE, BRANCH
PCH040   EQU   *
         SR    R2,R2               CLEAR REG 2
         L     R1,CONAREA          GET PTR TO DATA AREA
         IC    R2,CONLNTH(R1)      GET LNTH OF DATA TO BE MOVED
         BAL   R14,PCHMOVE         GO TO MOVE DATA ROUTINE
PCH044   EQU   *
         TM    VALUCHAI,HEXFF      IS THERE ANOTHER VALUE TO PROCESS
         BO    PCHRET1             IF NO MORE VALUES, BRANCH
         L     R3,A1               GET LAST OUTPUT ADDR
         LA    R3,ONE(R2,R3)       INCRE OUTPUT ADDR BY LAST DATA LNTH
         ST    R3,A1
         SPACE
*  IF MORE VALUES, RESET AND GO BACK FOR NEXT
         SPACE
PCH046   EQU   *
         L     R4,VALUCHAI         GET ADDR OF NEXT VALUE PDE
         MVC   VPDE(VALUPDL),ZERO(R4)  MOVE NEXT VALUE PDE TO DSECT
         OI    TSTFLGS1,PCHLSTVL   TURN ON THE LIST OF VALUES SW
         B     PCH020              GO BACK THROUGH PROCESS
         SPACE
*  TURN OFF SWITCHES USED BY PATCH.
         SPACE
PCHRET1  EQU   *
         L     R15,PCHRETCD        PICK UP PRESET RETURN CODE.
PCHRET1A DS    0H                  RETURN WITH WHAT IS IN R15
         NI    TSTFLGS1,HEXFF-PCHLSTVL-TSTFIRST
         NI    ASNFLGS1,HEXFF-ASNFIRST   TURN OFF SWITCH
         LR    R2,R15              SAVE THE RETURN CODE
         ESTAE 0                   REMOVE THE ESTAE
         NI    TSTFLGS4,HEXFF-TSTRERTN  TURN OFF RERTY SW.
         LR    R15,R2              RESTORE THE RETURN CODE
         L     R13,BACKPTR(R13)    GET ADDR OF PREVIOUS SAVE AREA.
         RETURN  (14,12),T,RC=(15) RETURN TO THE CALLER
         SPACE
CVTRC    EQU   *
         CH    R15,HSIXTEEN        IS THE RETURN CODE 16
         BE    PCHCC16             IF RC=16, BRANCH TO RC=16 RTN.
         B     PCHRET1             OTHERWISE, BRANCH TO WRAPUP RTN.
         SPACE
PCHCC16  EQU   *
         LA    R15,SIXTEEN         SETUP A RETURN CODE OF 16.
         ST    R15,PCHRETCD        STORE RETURN CODE IN RC FIELD.
         B     PCHRET1             GO RETURN TO CALLER
         EJECT
***********************************************************************
*                                                                     *
*  THE ADDRESS HAS NOW BEEN DETERMINED TO BE A CORE TYPE AND THE DATA *
*  HAS BEEN CONVERTED TO ITS PROPER CORE FORMAT. THE FOLLOWING CODE   *
*  WILL--                                                             *
*                                                                     *
*        1. INITIALIZE THE REGISTERS TO MOVE THE DATA TO ITS PROPER   *
*           LOCATION.                                                 *
*        2. TEST FOR AN ATTENTION POSTED.                             *
*        3. TEST FOR  A SCHEDULED LOGOFF.                             *
*        4. REMOVE ANY BREAKPOINT SVC'S FROM THE TARGET AREA          *
*        5. MOVE THE DATA TO THE REQUESTED LOCATION USING AN EX INSTR *
*
*        AT ENTRY,  R1  POINTS TO THE INPUT DATA ADDR MINUS ONE (1).  *
*                   R2  CONTAINS THE LENGTH OF DATA TO BE MOVED       *
*                   R14 CONTAINS THE RETURN ADDRESS.                  *
*                   A1  CONTAINS THE OUTPUT AREA ADDRESS              *
*                                                                     *
***********************************************************************
PCHMOVE  EQU   *
         LR    R7,R14              SAVE REG 14
         BCTR  R2,NULL             DECREMENT LNTH FOR THE MVC INSTR
         SPACE
         L     R3,ECBTMPA          PICKUP ADDR OF ATTENTION ECB.
         TM    ZERO(R3),ATTNBIT    IS AN ATTENTION POSTED
         BO    PCHCC16             BRANCH IF AN ATTENTION WAS POSTED
         L     R3,ECBLOG           GET PTR TO THE LOGON/LOGOFF ECB
         TM    ZERO(R3),LOGONBIT   IS LOGOFF SCHEDULED
         BO    PCHCC16             IF LOGOFF SCHEDULED, BRANCH
         BAL   R14,ASNBPT          GO REMOVE BREAKPTS AND BRK ELEMENTS
         LTR   R15,R15             TEST RETURN CODE FROM BRK-PT RTN
         BNZ   CVTRC               IF RETURN CODE IS NON-ZERO, BRANCH
         L     R15,A1              GET A PTR TO THE OUTPUT AREA.
         EX    R2,DATAMVC1         MOVE DATA TO REQUESTED LOCATION.
         ENTRY PCHABND1            THIS AN ELEMENT OF PCH ABEND TABLE
PCHABND1 EQU   *                   MARK ADDRESS OF POTENTIAL ABEND
         SPACE
         LR    R14,R7              RESTORE REG 14
         BR    R14                 RETURN TO CALLER
         EJECT
***********************************************************************
*                                                                     *
*  THE FOLLOWING ROUTINE PROCESSES DATA STRINGS FOR ZONED TYPE VALUES *
*  THE ROUTINE PROCESSES THE STRINGS AS FOLLOWS.                      *
*        1. DETERMINE WHETHER A SIGN WAS SPECIFIED AND SET UP TO USE  *
*           IT.  ADJUST DATA LENGTH AND PTR IF NECESSARY.             *
*        2. MOVE DATA TO CONAREA AND RETURN TO MAIN ROUTINE.          *
*                                                                     *
***********************************************************************
         SPACE
ZTYPE    EQU   *
         LA    R4,NEGZONE          SET UP PTR TO A NEGATIVE ZONE.
         LH    R2,VALULNH          GET THE LENGTH OF DATA STRING
         L     R15,VALUPTR         GET ADDR OF START OF DATA STRING
         CLI   ZERO(R15),MINUS     DOES STRING BEGIN WITH A MINUS SIGN
         BE    SIGN                IF SO, GO ADJUST PTRS FOR SIGN.
         LA    R4,POSZONE          RESET PTR TO A POSITIVE ZONE
         CLI   ZERO(R15),PLUS      DOES STRING BEGIN WITH A PLUS SIGN
         BNE   NOSIGN              IF NOT, SKIP SETUP FOR SIGN.
SIGN     EQU   *
         LA    R15,ONE(R15)        INCRE DATA PTR PAST SIGN.
         BCTR  R2,NULL             DECREMENT LENGTH BY 1 FOR SIGN
         SPACE
NOSIGN   EQU   *
         L     R1,CONAREA          GET ADDR OF CONVERT WORK AREA.
         STC   R2,CONLNTH(R1)      SET LENGTH OF CONVERTED CONSTANT
         BCTR  R2,NULL             REDUCE LENGTH FOR MVC INSTR.
         EX    R2,DATAMVC2         MOVE DATA TO CONAREA.
         LA    R1,CONDATA(R2,R1)   INCREMENT PTR TO LAST BYTE OF CON.
         MVZ   ZERO(ONE,R1),ZERO(R4)   MOVE CORRECT ZONE (SIGN) TO CON.
         B     PCH038              GO PERFORM PATCH
         EJECT
***********************************************************************
*                                                                     *
*  THIS ROUTINE CHECKS BOUNDARY ALIGNMENT AND ADDRESS TYPE FOR        *
*  FULLWORD TYPE CONSTANTS (A, E, F, Q, AND V).                       *
*                                                                     *
***********************************************************************
         SPACE
AQTYPE   EQU   *
ETYPE    EQU   *
FTYPE    EQU   *
VTYPE    EQU   *
         TM    A1TYPE,SFPR         IS ADDR SINGLE PREC FLT PT REG
         BO    ETYP10              IF YES, GO CHECK THAT TYPE IS 'E'
         TM    A1TYPE,LFPR         IS ADDR DBL PREC FLT PT REG
         BO    DTYPE20             IF YES, GO TO ERR RTN.
         TM    A1TYPE,GENR         IS ADDR A GENERAL REGISTER
         BNO   BDYFWTST            IF NOT, GO CHECK BDY FOR CORE PATCH
REGINCRF EQU   *
         MVC   ADDRINCR,GRDATA     CONSTANTS FOR GEN REGS TO TEST AREA
         L     R1,CONAREA          ADDR OF CONVERT AREA
         L     R2,A1               GPR TO BE PATCHED INTO R2
         LA    R8,CONDATA(R1)      INCR DATA PTR PAST LENGTH BYTE
         MVC   REGDATA,0(R8)       PLACE PATCH VALUE IN FULLWORD
         L     R8,REGDATA          AND THEN INTO REGISTER EIGHT
         L     R7,PPTCB            TARGET TCB ADDR FOR SVC97
         BAL   R14,ATNCHK          CHECK FOR ATN OR LOGOFF IN PROGRESS
         IKJEGS9G GPR,TCBADDR=(R7),VALUE=(R8),REGNO=(R2),MF=(E,ASNSVCL)
CHKSVC   EQU   *
         LTR   R15,R15             TEST SVC RETURN CODE
         LA    R8,VPDE             INSURE ADDRESSABILITY TO VALUE PDE
         BNZ   SVCMSG              BRANCH NONZERO
         TM    VALUCHAI,HEXFF      ARE THERE MORE VALUES TO PROCESS
         BO    PCHRET1             IF NO MORE VALUES, BRANCH
         L     R2,A1               GET REGISTER NUMBER JUST PATCHED
         AH    R2,ADDRINCR         ADD  THE ADDR INCREMENT
         CH    R2,MAXRADDR         IS UPDATED REG  NO. GREATER THAN MAX
         ST    R2,A1               SAVE UPDATED ADDR, ANTICIPATING OK
         BNH   PCH046              IF REG NO. NOT GT MAX, BRANCH
         SR    R2,R2               OTHER WISE, RESET ADDR TO ZERO
         ST    R2,A1               SAVE RESET REG ADDRESS
         B     PCH046              GO PROCESS NEXT VALUE
         SPACE
ETYP10   EQU   *
         TM    VALUTYPE,ECODE      IS DATA TYPE 'E'
         BO    REGINCRE            IF 'E', BRANCH
ETYP20   EQU   *
         LA    R2,MSG012           R2= MSG NO. 12
         LA    R3,MSG214           R3= SECOND LEVEL 214
         B     MSGOUTV             OUTPUT INDICATED MSG (VPDE INSERT)
         EJECT
***********************************************************************
*                                                                     *
*  THE FOLLOWING CODE TESTS FOR AN ATTENTION                          *
*                                                                     *
***********************************************************************
         SPACE
ATNCHK   EQU   *
         L     R3,ECBTMPA          GET ADDR OF ATTENTION ECB.
         TM    ZERO(R3),ATTNBIT    IS AN ATTENTION POSTED
         BO    PCHCC16             IF YES, GO TO CLEANUP ROUTINE.
         L     R3,ECBLOG           GET PTR TO LOGON ECB
         TM    ZERO(R3),LOGONBIT   IS LOGOFF SCHEDULED
         BO    PCHCC16             IF YES, BRANCH
         BR    R14                 RETURN
         SPACE
SVCMSG   EQU   *
         LA    R2,SIXTEEN          IS THE SVC RETURN CODE 16 OR ABOVE.
         CR    R15,R2              R15 GREATER THAN 16?
         BH    PCHRET1A            EXIT TO MNL.
         LA    R2,MSG014           R2= FIRST LEVEL MSG NO 14
         LA    R3,MSG283           R3= SECOND LEVEL MSG NO 283
         B     MSGOUT              OUTPUT THE MSG NO INSERT
         EJECT
BDYFWTST EQU   *
         TM    A1+THREE,FWBDY      TEST IF ADDRESS IS A FULL WORD BDY
         BZ    PCH040              IF BOUNDARY OK, BRANCH
         TM    TSTFLGS1,PCHLSTVL   IS VALUE PART OF A LIST OF VALUES
         BZ    FBDYERR             IF ADDR BDY IS WRONG, GO TO ERR RTN.
         SPACE
***********************************************************************
*                                                                     *
*  IF VALUE IS PART OF A LIST OF VALUES, ROUND ADDR UP TO NEXT FULL   *
*  BOUNDARY BY ADDING 3 THEN ROUNDING DOWN TO AN ADDR THAT ENDS WITH  *
*  TWO BINARY ZERO'S.                                                 *
*                                                                     *
***********************************************************************
         SPACE
         L     R15,A1              GET CURRENT ADDRESS
         AL    R15,FTHREE          ADD 3 TO INCRE TO OR PAST NXT F BDY
         ST    R15,A1              REPLACE ADDRESS
         NI    A1+THREE,HEXFF-FWBDY  ROUND ADDR DOWN TO EXACT BDY
         B     PCH040              GO PATCH A CORE LOCATION
         SPACE 2
DTYPE    EQU   *
         TM    A1TYPE,LFPR         IS ADDR DBL PRECISION FLT PT REG
         BO    REGINCRD            IF YES, GO SET UP CORRECT CONSTANTS
         TM    A1TYPE,GENR+SFPR    IS ADDR A 4 BYTE REG TYPE
         BNZ   LENERR              IF 4 BYTE REG TYPE, BRANCH
         TM    A1+THREE,DWBDY      IS OUTPUT ADDR ON A DBL WORD BDY
         BZ    PCH040              IF DBL WORD BDY, BRANCH
         SPACE
         TM    TSTFLGS1,PCHLSTVL   IS THIS VALUE PART OF A LIST.
         BZ    DBDYERR             IF NOT, BRANCH TO ERROR ROUTINE.
         L     R15,A1              GET ADDR TO BE ROUNDED
         AL    R15,FSEVEN          INCRE IT TO OR PAST NXT DBL WORD BDY
         ST    R15,A1              REPLACE ORIGINAL ADDRESS
         NI    A1+THREE,HEXFF-DWBDY  ROUND ADDR DOWN TO EXACT BDY
         B     PCH040              GO PATCH AREA OF CORE
         SPACE
DTYPE20  EQU   *
         LA    R2,MSG012           R2= FIRST LEVEL MSG NO 12
         LA    R3,MSG215           R3= SECOND LEVEL MSG NO 215
         B     MSGOUTV             OUTPT THE MSG (VPDE INSERT)
         SPACE 2
REGADDR  EQU   *
         L     R3,CONAREA          GET ADDR OF CONVERT OUTPUT AREA
         USING CONAREA1,R3
         SR    R2,R2               CLEAR REG AND
         IC    R2,CONLNTH+CONAREA1 GET LENGTH OF CONVERTED DATA
         TM    A1TYPE,LFPR         IS ADDR DBL PRECISION FLT PT REG
         BO    REGADDR1            IF REG ADDR IS 'D' TYPE, BRANCH
         CH    R2,HFOUR            COMPARE CONSTANT LENGTH TO 4.
         BE    REGADDR2            IF EQUAL, GO DETERMINE REG TYPE
         BH    LENERR              IF HIGH, GO TO ERROR ROUTINE.
         LCR   R2,R2               MAKE LENGTH NEGATIVE.
         L     R4,CONDATA+CONAREA1  GET LEFT JUSTIFIED CONSTANT
         AH    R2,HFOUR            SUBTRACT LENGTH FROM 4.
         SLL   R2,THREE            MULTIPLY LENGTH BY 8 TO GET BIT LNTH
         SRL   R4,ZERO(R2)         RIGHT JUSTIFY CONSTANT.
         ST    R4,CONDATA+CONAREA1 STORE RIGHT JUSTIFIED CONSTANT
         MVI   CONLNTH+CONAREA1,FOUR  STORE LENGTH IN LNTH FIELD
REGADDR2 EQU   *
         TM    A1TYPE,GENR         IS REG TYPE GENERAL REGISTER
         BO    REGINCRF            IF GENERAL REG, BRANCH
         CLI   VALUTYPE,HEXCODE    IS THE DATA TYPE HEX
         BE    REGINCRE            IF HEX, BRANCH
         B     ETYP20              IF NOT, GO TO ERROR MSG ROUTINE
         SPACE
REGADDR1 EQU   *
         CLI   VALUTYPE,HEXCODE    IS THE DATA TYPE HEX
         BNE   DTYPE20             IF NOT, BRANCH TO ERROR MSG RTN
         CH    R2,HEIGHT               COMPARE LENGTH TO 8.
         BE    REGINCRD                IF 8, GO TO REG PATCH ROUTINE.
         BH    LENERR                  IF GREATER THAN 8, GO TO ERROR.
         SPACE
*  IF ADDR IS FOR A DBL PRECISION FLOATING PT REG AND LENGTH IS LESS
*     THAN 8, RIGHT JUSTIFY THE CONSTANT AND PAD WITH ZEROS.
         SPACE
         LCR   R2,R2               MAKE CONSTANT LENGTH NEGATIVE,
         LM    R4,R5,CONDATA+CONAREA1  PICK UP THE CONVERTED DATA
         SPACE
*  THE NEXT INSTRUCTION EFFECTIVELY SUBSTRACTS THE LENGTH FROM 8.
         SPACE
         AH    R2,HEIGHT           ADD NEG LENGTH TO PLUS 8.
         SLL   R2,THREE            MULTIPLY NEG LNTH BY 8 FOR BIT LNTH
         SRDL  R4,ZERO(R2)         RIGHT JUSTIFY THE CONSTANT
         STM   R4,R5,CONDATA+CONAREA1  JUSTIFIED/PADDED DATA TO CONAREA
         MVI   ZERO(R3),EIGHT      SET LENGTH FIELD TO 8.
REGINCRD EQU   *
         DROP  R3                  FREE BASE USED FOR CVT OUTPUT AREA
         MVC   ADDRINCR,FPRDATA
         L     R1,CONAREA          ADDRESS OF CONVERT AREA
         L     R2,A1               FPR REGISTER TO BE PATCHED INTO R2
         LA    R8,CONDATA(R1)      INCR DATA PTR PAST LENGTH BYTE
         L     R7,PPTCB            TARGET TCB ADDR FOR SVC97
         BAL   R14,ATNCHK          CHECK FOR ATN OR LOGOFF IN PROGRESS
         IKJEGS9G FPR,TCBADDR=(R7),VALUE=(R8),REGNO=(R2),MF=(E,ASNSVCL)
         B     CHKSVC              CHECK RETURN CODE FROM SVC97
         SPACE
REGINCRE EQU   *
         OI    A1+THREE,ODD        MAKE REG NUMBER ODD FOR 'E' TYPE
         B     REGINCRD            GO TO REG PATCH ROUTINE
         EJECT
***********************************************************************
*                                                                     *
*  HEX PATCH ROUTINE, DATA IS CONVERTED TO HEX BY IKJEGCVT 4 BYTES    *
*  AT A TIME. THE LAST OR ONLY FIELD MAY BE LESS THAN 4 BYTES.        *
*                                                                     *
***********************************************************************
         SPACE
XTYPE    EQU   *
         MVC   DUMMYPDE(VALUPDL),VPDE  COPY THE PDE FOR MODIFICATION
         LH    R2,VALULNH          GET LNTH OF INPUT STRING
         L     R15,VALUPTR         GET PTR TO INPUT STRING
         LR    R4,R2               SAVE THE LENGTH OF THE STRING.
         BCTR  R2,NULL             REDUCE LENGTH FOR TR INSTR.
         EX    R2,PCHTR            TRANSLATE TO UPPER CASE.
         LA    R2,EIGHT            SET LIMIT FOR FIELD LENGTH
         CR    R4,R2               IS INPUT LENGTH GREATER THAN 8
         BNH   XTYPE04             IF NOT GREATER THAN 8, BRANCH
         STH   R2,DUMMYPDE+(VALULNH-VALUPDE)  IF GT 8, CNVT 8 AT TIME
         SPACE
*  INITIALIZE TO CONVERT A VALUE TO HEX.
         SPACE
XTYPE04  EQU   *
         L     R2,DUMMYPDE+(VALUPTR-VALUPDE)  PICK UP PTR TO DATA
         LA    R5,HOLDAREA+ONE     R5=ADDR OF TEMPORARY HOLDING AREA
         SR    R0,R0               R0=0
         LA    R1,DUMMYPDE         SET PTR TO VALUE PDE FOR CONVERT
HEXCVT   EQU   *
         L     R15,TSTCONVT        R15=ADDR OF CONVERT ROUTINE
         BALR  R14,R15             GO TO CONVERT RTN
         LTR    R15,R15            TEST RETURN CODE FROM IKJEGCVT
         BNZ   CVTRC               IF NON-ZERO, GO ANALYZE
         L     R15,CONAREA         PICK OF ADDR OF CONVET OUTPUT AREA
         USING CONAREA1,R15
         LH    R3,DUMMYPDE+(VALULNH-VALUPDE)  GET LNTH OF INPUT
         L     R14,CONAREA1+CONDATA  PICK UP CONVERTED DATA
         DROP  R15
         ST    R14,ZERO(R5)        SAVE IT TEMPORARILY IN HOLD AREA
         SPACE
***********************************************************************
*  IF THERE ARE MORE THAN 8 BYTES OF INPUT, ADJUST THE POINTERS AND   *
*   CONTINUE IN THIS LOOP UNTIL ALL DATA HAS BEEN PROCESSED.          *
***********************************************************************
         SPACE
         SR    R4,R3               DECREMENT AMT TO CONVERT BY AMT DONE
         BZ    XTYPE08             WHEN ALL BYTES ARE CONVERTED, BRANCH
         AR    R2,R3               INCREMENT PTR TO INPUT DATA FOR NEXT
         ST    R2,DUMMYPDE+(VALUPTR-VALUPDE)  UPDATED ADDR IN VALUPDE
         LA    R5,FOUR(R5)         INCREMENT CUR HOLD AREA PTR
         CH    R4,HEIGHT           IS REMAINDER LESS THAN 8.
         BNL   HEXCVT              IF MORE TO CONVERT, BRANCH
         STH   R4,DUMMYPDE+(VALULNH-VALUPDE)  STORE RMNG LNTH IN PDE
         B     HEXCVT              GO CONVERT REMAINING DATA
REGHEX   EQU   *
         CH    R3,HEIGHT           IS LENGTH OF CONVERTED DATA GT 8.
         BNL   LENERR              IF 8 OR GREATER, GO TO ERROR RTN
         LM    R14,R15,HOLDAREA+ONE  PICK UP CONVERTED DATA
         SRDL  R14,FOUR            RIGHT JUSTIFY CONSTANT
         STM   R14,R15,HOLDAREA+ONE  PLACE DATA BACK INTO HOLDING AREA
         L     R15,CONAREA         GET ADDR OF CONVERT OUTPUT AREA
         LA    R3,ONE(R3)          INCRMENT LENGTH OF OUTPUT DATA
         B     NOTODD              GO TO COMMON HEX PREP ROUTINE.
         SPACE
***********************************************************************
*                                                                     *
*  THE FOLLOWING ROUTINE IS ENTERED WHEN ALL INPUT BYTES HAVE BEEN    *
*  CONVERTED TO HEX.                                                  *
*  AT ENTRY, REG 5 POINTS TO THE NEXT AREA OF HOLDAREA                *
*            REG 14 CONTAINS THE LAST CONVERTED BYTES                 *
*            REG 15 POINTS TO THE CONVERT AREA                        *
*                                                                     *
***********************************************************************
         SPACE
XTYPE08  EQU   *
         LH    R3,VALULNH          GET TOTAL LNTH OF INPUT STRING
         SRL   R3,B1               DIVIDE LNTH BY 2, DISCARD REMAINDER
         TM    VALULNH+ONE,ODD     IS LNTH AN ODD NUMBER OF BYTES
         BZ    NOTODD              IF NOT, BRANCH
         SLL   R14,FOUR            ELIMINATE LEADIN HALF BYTE 0
         ST    R14,ZERO(R5)        STORE LAST DATA AFTER ADJUSTMENT
         TM    A1TYPE,GENR+SFPR+LFPR   IS ADDRESS REG TYPE
         BNZ   REGHEX              IF NOT, TRULY REG, BRANCH
         L     R2,A1               GET RECIEVING ADDRESS
         LA    R2,ZERO(R3,R2)      POINT TO LAST BYTE OF TARGET AREA
         LA    R5,HOLDAREA+ONE     PICK UP ADDR OF HOLDING AREA
         LA    R4,ZERO(R3,R5)      POINT TO LAST BYTE IN HOLDING AREA
         SPACE
*  IF THE NUMBER OF HEX CHARACTERS SUPPLIED IS ODD, GET ONE HEX DIGIT
*     FROM THE LAST BYTE OF THE TARGET AREA TO FILL OUT THE LAST BYTE
*         OF PATCH DATA.
         SPACE
         MVN   ZERO(ONE,R4),ZERO(R2)   MOVE IN 2ND HALF.
         LA    R3,ONE(R3)          INCREMENT COUNT FOR DATA
NOTODD   EQU   *
         L     R15,CONAREA         GET PTR TO CONVERT OUTPUT AREA
         USING CONAREA1,R15
         STC   R3,CONAREA1         STORE DATA COUNT IN CONVERT LEN FLD
         BCTR  R3,NULL             DECREMENT COUNT FOR MVC INSTR
         EX    R3,DATAMVC3         MOVE DATA FROM HOLD TO CONVERT AREA
         B     PCH038              GO PROCESS DATA.
         DROP  R15
         EJECT
***********************************************************************
*                                                                     *
*  THE FOLLOWING ROUTINE HANDLES THE TWO BYTE CONSTANTS SUCH AS H, S, *
*  AND Y.  THE ROUTINE FIRST CHECKS WHETHER THE ADDRESS IS REGISTER OR*
*  CORE. FOR CORE TYPES THE BOUNDARY ALIGNMENT IS CHECKED AND FOR     *
*  LISTS OF VALUES, ADJUSTED TO A HALF WORD BOUNDARY.  FOR REGISTER   *
*  ADDRESSES, A FURTHER CHECK IS MADE TO SEE IF THE CONSTANT TYPE IS  *
*  'H'.FOR H TYPE CONSTANTS, THE DATA IS EXTENDED TO FULLWORD SIZE TO *
*  ACCOUNT FOR THE SIGN. S OR Y TYPE CONSTANTS ARE HANDLED AS BYTE    *
*  CONSTANTS.  FLOATING POINT REGISTER ADDRESSES ARE INVALID.         *
*                                                                     *
***********************************************************************
         SPACE
HTYPE    EQU   *
STYPE    EQU   *
YTYPE    EQU   *
         TM    A1TYPE,SFPR         IS ADDRESS A SHORT FLT PT REG TYPE
         BO    ETYP20              IF YES, BRANCH TO ERROR RTN.
         TM    A1TYPE,LFPR         IS ADDRESS A LONG FLT PT REG TYPE
         BO    DTYPE20             IF YES, BRANCH
         TM    A1TYPE,GENR         IS ADDRESS A GENERAL REGISTER TYPE
         BO    HREGADDR            IF GENERAL REGISTER TYPE, BRANCH
         TM    A1+THREE,HWBDY      IS ADDRESS ON A HALFWORD BDY
         BZ    PCH040              IF HALF WORD BDY, BRANCH
         TM    TSTFLGS1,PCHLSTVL   IF DATA PART OF A LIST OF VALUES
         BNO   HBDYERR             IF NOT, GO TO ERROR TRN
         SPACE
*  ADDR HAS BEEN FOUND TO BE A BYTE BDY, AND DATA PART OF A LIST OF   *
*  VALUES.  THE ADDRESS MUST BE ROUNDED UP TO THE NEXT HALFWORD BDY.  *
         SPACE
         L     R15,A1              GET CURRENT ADDRESS
         AL    R15,FONE            INCREMENT ADDR TO NEXT HALFWORD BDY
         ST    R15,A1              SAVE UPDATED ADDR
         B     PCH040              GO DO PATCH
         SPACE 2
HREGADDR EQU   *
         CLI   VALUTYPE,HCODE      IS THE CONSTANT TYPE 'H'
         BNE   REGADDR             IF NOT, BRANCH TO BYTE TYPE RTN.
         L     R3,CONAREA          PICK UP ADDR OF CONVERT OUTPUT AREA
         USING CONAREA1,R3
         LH    R4,CONAREA1+ONE     LOAD 2 BYTE CONSTANT INTO 4 BYTE REG
         ST    R4,CONAREA1+ONE     STORE EXTENDED CONSTANT BACK.
         MVI   ZERO(R3),FOUR       SET CONSTANTS LENGTH TO 4.
         B     REGINCRF            GO PROCESS AS A FULLWORD CONSTANT.
         DROP  R3
         EJECT
***********************************************************************
*  ROUTINE TO HANDLE CHARACTER TYPE DATA.                             *
*        THIS DATA HAS NO MAXIMUM LENGTH RESTRICTION, AND IF THE INPUT*
*        DATA STRING IS LONGER THAN 64 BYTES, IT MUST BE PROCESSED    *
*        IN GROUPS OF 63 OR 64 CHARACTERS AT A TIME. THE GROUP SIZE   *
*        VARIES TO ALLOW EACH STRING BEING PROCESSED TO CONTAIN ONLY  *
*        PAIRS OF SINGLE QUOTES--- SINCE SINGLE QUOTES ARE A SPECIAL  *
*        CASE.                                                        *
***********************************************************************
CTYPE    EQU   *
         L     R2,VALUPTR          PTR TO INPUT STRING
         LH    R3,VALULNH          LNTH OF INPUT STRING
CTYPE04  EQU   *
         LA    R4,CGRPLEN          SET UP MAX QUANTITY FOR 1 PASS
         STH   R3,A1L              SAVE ORIGINAL OR REMAINING LENGTH
         CR    R3,R4               IS LENGTH OF DATA STRING GT MAX
         BNH   CTYPE20             IF LENGTH NOT GT MAX, BRANCH
         LR    R3,R4               SET CURRENT LENGTH TO MAX
         STH   R3,VALULNH          SAVE LNTH TO BE USED FOR THIS GROUP
         LA    R5,ZERO(R2,R3)      SET UP PTR TO 1ST BYTE OF NXT GROUP
         CLI   ZERO(R5),QUOTE      IS THAT CHARACTER A SINGLE QUOTE
         BNE   CTYPE20             IF NOT, BRANCH
         BCTR  R5,NULL             BACK UP PTR TO LAST BYTE OF THIS GRP
         CLI   ZERO(R5),QUOTE      IS THIS CHARACTER A QUOTE
         BNE   CTYPE20             IF NOT, BRANCH
         SPACE
*  IF QUOTES EXTEND ACROSS GROUPS, THE FOLLOWING CODE ADJUSTS THE
*     GROUP LENGTH AS NECESSARY TO INSURE THE GROUP TO BE PROCESSED
*        CONTAINS ONLY PAIRED SINGLQUOTES. (NO. OF QUOTES/GRP NOT ODD)
         SPACE
         LR    R5,R2               GET PTR TO START OF DATA STRING
         SR    R15,R15             INITIALZE QUOTE COUNTER TO ZERO
CTYPE08  EQU   *
         CLI   ZERO(R5),QUOTE      IS THIS DATA CHAR A QUOTE
         BNE   CTYPE12             IF NOT, BRANCH
         LA    R15,ONE(R15)        IF CHAR WAS A QUOTE, INCRE COUNTER
CTYPE12  EQU   *
         LA    R5,ONE(R5)          INCRE DATA STRING PTR TO NXT CHAR
         BCT   R4,CTYPE08          IF MORE CHARACTERS TO CHECK, BRANCH
         LA    R4,ONE              MAKE A MASK TO ISOLATE LOW ORDER BIT
         NR    R4,R15              ISOLATE LOW ORDER BIT OF QUOTE COUNT
         SR    R3,R4               SUBTRACT 1 FROM LNTH IF COUNT ODD
         STH   R3,VALULNH          STORE ADJUSTED LENGTH IN PDE
         B     CTYPE20             BO PROCESS THIS GROUP
         EJECT
***********************************************************************
*                                                                     *
*  THE FOLLOWING ROUTINE SCANS CHARACTER CONSTANTS FOR SINGLE QUOTES. *
*  USERS MUST SPECIFY TWO SINGLE QUOTES FOR EACH ONE DESIRED IN THE   *
*  OUTPUT. THIS ROUTINE SQUEEZES OUT THE EXTRA QUOTES AND MOVES THE   *
*  PROCESSED CONSTANT TO THE TEMPORARY HOLD AREA. THE CONVERT AREA IS *
*  NOT USED BECAUSE THE CONSTANT AFTER PROCESSING MAY BE UP TO 64     *
*  BYTES LONG. IN THIS ROUTINE, REGS ARE USED AS FOLLOWS--            *
*        R1    POINTS TO NEXT AVAILABLE BYTE IN HOLDARA.              *
*        R2    POINTS TO THE NEXT INPUT BYTE TO BE TESTED.            *
*        R3    CONTIANS VALUE LENGTH, IT IS DECREMENTED 1 FOR EACH '' *
*        R4    CONAINS INCREMENT FOR BXLE INSTR                       *
*        R5    CONTAINS COMPAREND FOR BYLE INSTR (PTR TO END OF INPUT *
*        R14   USED TO CALCULATE NUMBER OF BYTES SCANED               *
*        R15   POINTS TO BEGINNING BYTE OF CURRENT SCAN.              *
*                                                                     *
***********************************************************************
         SPACE
CTYPE20  EQU   *
         L     R1,CONAREA          GET PTR TO CONVERTED DATA AREA
         LA    R5,ZERO(R3,R2)      SET UP BXLE COMPAREND AS INPUT ADDR
         LA    R4,ONE              SET BXLE INSTR INCRE
         SR    R5,R4                   + LENGTH OF DATA - 1.
         LR    R15,R2              SAVE STARTING POINT IN STRING.
         SPACE
CLOOP    EQU   *
         CLI   ZERO(R2),QUOTE      IS THIS CHARACTER A SINGLE QUOTE
         BE    QUOTEFND            BRANCH IF CHAR=QUOTE
CLOOP1   EQU   *
         BXLE  R2,R4,CLOOP         INCRE STRING PTR, LOOP IF MORE TO DO
         SPACE
         LR    R14,R2              CALCULATE NUMBER OF BYTES SCANNED
         SR    R14,R15                 AS CUR STRING PTR - BEGIN PTR.
         BZ    DONE                IS RESULT IS 0, BRANCH AROUND MVC.
         BCTR  R14,NULL            DECRE COUNT FOR MVC INSTR
         EX    R14,DATAMVC2        MOVE REMAINING DATA TO HOLDAREA
DONE     EQU   *
         L     R1,CONAREA          GET PTR TO CONVERTED DATA AREA
         STC   R3,CONLNTH(R1)      STORE LNTH IN CONVERTED DATA AREA
         SPACE
*  SETUP TO DO PATCH BY DETERMINING WHETHER ADDRESS IS REG OR CORE
         TM    A1TYPE,GENR+SFPR+LFPR   IS ADDRESS TYPE REGISTER
         LR    R5,R3               GET ADJUSTED DATA LNTH OF LAST PATCH
         BNZ   REGADDR             IF REGISTER TYPE, BRANCH
         LR    R2,R3               SET UP LENGTH FOR  THE PCHMOVE RTN
         BAL   R14,PCHMOVE         GO MOVE DATA
         LH    R3,A1L              GET REMAINING LNTH OF DATA STRING
         SH    R3,VALULNH          SUBTRACT THE LNTH JUST PROCESSED
         BZ    PCH044              IF ALL DATA PROCESSED, BRANCH
         SPACE
*  UPDATE THE INPUT AND OUTPUT POINTERS FOR THE DATA ALREADY USED.
         SPACE
         L     R2,VALUPTR          GET CURRENT OUTPUT ADDRESS
         L     R4,A1               GET CURRENT OUTPUT ADDRESS
         AH    R2,VALULNH          INCRE PTR PAST DATA PROCESSED
         AR    R4,R5               ADD LNTH OF AREA JUST PATCHED
         ST    R2,VALUPTR          SAVE UPDATED DATA ADDR IN VALUE PDE
         STH   R3,VALULNH          SAVE UPDATED LNTH IN VALUE PDE
         ST    R4,A1               STORE UPDATED OUTPUT ADDRESS
         B     CTYPE04             GO BACK AND PROCESS MORE OF STRING
         SPACE
***********************************************************************
*                                                                     *
*  THIS ROUTINE IS ENTERED WHEN THE CHARACTER SCAN ROUTINE FINDS A    *
*  SINGLE QUOTE. IT MOVES THE SCANNED DATA TO HOLDAREA, ADJUSTS THE   *
*  NECESSARY PTRS, AND DECREMENTS THE VALUES LENGTH BY 1.             *
*                                                                     *
***********************************************************************
         SPACE
QUOTEFND EQU   *
         LR    R14,R2              CALCULATE NUMBER OF BYTES SCANNED
         SR    R14,R15                 AS CUR STRING PTR - BEGIN PTR.
         EX    R14,DATAMVC2        MOVE SCANNED DATA TO CUR HOLD POS.
         BCTR  R3,NULL             DECREMENT VALUES LENGTH BY 1.
         AR    R2,R4               INCREMENT STRING PTR PAST QUOTE.
         LA    R1,ONE(R14,R1)      INCREMENT CUR HOLD AREA PTR
         LA    R15,ONE(R2)         RESET BEGIN PTR TO ENXT BYTE TO SCAN
         B     CLOOP1              GO BACK TO SCAN LOOP AT BXLE INSTR.
         EJECT
***********************************************************************
*                                                                     *
*    THIS SECTION OF CODE CONTAINS ALL THE CALLS TO IKJEGIO
*                                                                     *
***********************************************************************
         SPACE
MSGOUT   DS    0H                  OUTPUT SINGLE MSG NO INSERT
         XC    TSTIOPRM(L'TSTIOPRM),TSTIOPRM  CLEAR IO PARM AREA
         IKJEGSIO MSG,FIRST=(R2),SECOND=(R3),ID=ASN03,MF=(E,TSTIOPRM)
         B     RETABLE(R15)        CHECK IO RETUNR CODES
         SPACE
MSGOUTV  DS    0H                  OUTPTU MSG WITH VPDE INSERT (R8)
         XC    TSTIOPRM(L'TSTIOPRM),TSTIOPRM CLEAR IO PARM AREA
         IKJEGSIO MSG,FIRST=(R2),SECOND=(R3),INST11=(VPDE,(R8)),       *
               ID=ASN03,MF=(E,TSTIOPRM)   INVOKE IO
         B     RETABLE(R15)        CHECK IO RETURN CODES
         SPACE
MSGOUTAI DS    0H                  MSG APDE INSERT + STATIC INSERT
         XC    TSTIOPRM(L'TSTIOPRM),TSTIOPRM CLEAR IO PARM AREA
         IKJEGSIO MSG,FIRST=(R2),SECOND=(R3),INST11=(APDE,APDEADDR),   *
               INST21=(NUM,(R4)),ID=ASN03,MF=(E,TSTIOPRM) INVOKE IO
         B     RETABLE(R15)        CHECK IO RETURN CODES
         SPACE
RETABLE  DS    0H                  RETURN CODE CHECK TABLE
         B     RETMNL00            RETURN TO MNL WITH ZERO IO=0
         B     RETMNL00            RETURN TO MNL WITH ZERO IO=4
         B     RETMNL00            RETURN TO MNL WITH ZERO IO=8
         B     RETMNL00            RETURN TO MNL WITH ZERO IO=12
         B     PCHRET1A            RETURN TO MNL WITH R C IO=16
         B     PCHRET1A            RETURN TO MNL WITH R C IO=20
         B     PCHRET1A            RETURN TO MNL WITH R C IO=24
         SPACE
RETMNL00 DS    0H                  RETURN TO MNL WITH A ZERO
         XC    PCHRETCD(L'PCHRETCD),PCHRETCD CLEAR RETURN CODE
         B     PCHRET1             RETURN TO MNL WITH ZERO
         EJECT
HBDYERR  EQU   *
         LA    R4,INST2            R4= INSERT NO 2 (HALF)
         B     SETMSGA             OUTPUT THE MESSAGE
         SPACE
FBDYERR  EQU   *
         LA    R4,INST3            R4= INSERT NO 3 (FULL)
         B     SETMSGA             OUTPUT THE MESSAGE
         SPACE
DBDYERR  EQU   *
         LA    R4,INST4            R4= INSERT NO 4 (DOUBLE)
         SPACE
SETMSGA  DS    0H                  SET MSG NO'S.
         LA    R2,MSG101           R2= FIRST LEVEL MSG NO 101
         LA    R3,MSG280           R3= SECOND LEVEL MSG NO 280
         B     MSGOUTAI            OUTPUT THE MESSAGE
         SPACE
LENERR   EQU   *
         LA    R2,MSG011           R2= FIRST LEVEL MSG NO 11
         LA    R3,MSG213           R3= SECOND LEVEL MSG NO 213
         B     MSGOUTV             OUTPUT MSG WITH VPDE INSERT (R8)
         SPACE
         EJECT
***********************************************************************
*                                                                     *
*  THIS CLOSED SUBROUTINE CALLS THE BRK ELEMENT SRCH ROUTINE TO CHECK *
*  BREAK POINTS BY SEARCHING THE BREAK ELEMENT QUEUE FOR ADDRESSES    *
*  WHICH FALL WITHIN THE AREA ABOUT TO BE PATCHED.                    *
*  WHEN A BREAK POINT IS FOUND WITHIN THE TARGET AREA, THE ORIGINAL   *
*  DATA IS MOVED FROM THE BREAK ELEMENT BACK TO ITS ORIGINAL LOCATION *
*  OVERLAYING THE BREAK POINT SVC. THE BREAK ELEMENT IS REMOVED       *
*  AND A SWITCH IS SET INDICATING A MESSAGE MUST BE ISSUED            *
*  TO TELL THE USER THAT BREAKPOINTS HAVE BEEN OVERLAYED.             *
*                                                                     *
*  INPUT  A1=START ADDRESS OF THE TARGET AREA                         *
*         R2 CONTAINS THE LENGTH OF THE PATCH DATA                    *
*         R1 CONTAINS THE ADDRESS OF THE INPUT PATCH DATA             *
*  OUTPUT R15 CONTAINS A RETURN CODE OF ZERO, OR THE ERROR RETURN     *
*             CODE FROM IKJEGIO OR IKJEGSRH.                          *
*                                                                     *
***********************************************************************
ASNBPT   EQU   *
         SAVE  (14,12)             STANDARD SAVE
         L     R15,REGSAVE3        PTR TO 2ND SUB-CMD SAVE AREA
         ST    R15,FOREPTR(ZERO,R13)   FORWARD AND
         ST    R13,BACKPTR(ZERO,R15)       BACKWARD CHAIN SAVE AREAS
         LR    R13,R15             ESTABLISH NEW SAVE AREA
         SR    R15,R15             PRESET RETURN CODE TO ZERO
         L     R3,A1               GET START ADDR OF AREA TO PATCH
         LA    R4,ZERO(R2,R3)      CALCULATE DATA END ADDRESS
         LA    R3,ZERO(R3)         CLEAR HIGH ORDER BYTE
         LA    R1,ASNSVCL          ADDRESS OF PARAMETER LIST
         LA    R2,EIGHT            INDICATE SEARCH OF RANGE
         STM   R2,R4,0(R1)         STORE INTO PARAMETER LIST
         L     R15,TSTSRHRT        ADDRESS OF BREAKPOINT PROCESSOR
         BALR  R14,R15             BRANCH AND PROCESS BREAKPOINTS
         LTR   R15,R15             TEST RETURN CODE FROM BRKPT ROUTINE
         BZ    ASNBPT10            BRANCH IF BRKPTS FOUND AND REMOVED
         CH    R15,HEIGHT          IS RETURN CODE TWELVE
         BH    ASNBPT20            BRANCH IF SRH ENTERED STAE RETRY
         LA    R15,ZERO            TRY PATCH EVEN THO BRKPT NOT FOUND
         B     ASNBPT30            RETURN TO MAIN LINE OF CODE
ASNBPT10 TM    ASNFLGS1,ASNFIRST   HAS MESSAGE BEEN ISSUED
         BZ    ASNBPT50            IF NOT, PLEASE DO SO
         B     ASNBPT30            OTHERWISE, RETURN TO CALLER
ASNBPT20 LA    R15,TWENTY          TELL IKJEGMNL SOMETHINGS AMISS
         ST    R15,PCHRETCD        SAVE RETURN CODE
ASNBPT30 EQU   *
         L     R13,BACKPTR(ZERO,R13)   GET CALLERS SAVE AREA ADDR
         RETURN (14,12),RC=(15)    RETURN TO CALLER
         SPACE
***********************************************************************
*  IF A BREAK POINT IS FOUND IN THE RANGE, THE FOLLOWING CODE
*  WILL CALL IO MODULE TO NOTIFY USER THAT BREAKPOINT HAS BEEN RMVD.
***********************************************************************
         SPACE
ASNBPT50 EQU   *
         XC    TSTIOPRM(L'TSTIOPRM),TSTIOPRM CLEAR IO PARM AREA
         LA    R2,MSG013           R2 = FIRST LEVEL MSG NO 13
         LA    R3,MSG216           R3 = SECOND LEVEL MSG NO.
         IKJEGSIO MSG,FIRST=(R2),SECOND=(R3),ID=ASN03,MF=(E,TSTIOPRM)
         LTR   R15,R15             TEST RC FROM IKJEGIO
         BNZ   ASNBPT30            IF RETURN CODE NON-ZERO, BRANCH
         OI    ASNFLGS1,ASNFIRST   INDICATE MSG HAS BEEN ISSUED
         B     ASNBPT30            RETURN TO CALLING ROUTINE
         EJECT
DATAMVC1 MVC   ZERO(NULL,R15),ONE(R1)  MOVES DATA TO USER CORE
DATAMVC2 MVC   ONE(ZERO,R1),ZERO(R15)  MOVES DATA INTO CONAREA
DATAMVC3 MVC   ONE(ZERO,R15),HOLDAREA+ONE MOVES DATA FROM HOLD
****                               AERA TO CONAREA
PCHTR    TR    ZERO(ZERO,R15),PCHTRTBL  FOR TRANSLATION TO UPPER CASE
         SPACE
NEGZONE  DC    Z'-1'               BYTE WITH NEGATIVE ZONE FIELD.
POSZONE  DC    Z'+1'               BYTE WITH POSITIVE ZONE FIELD.
         SPACE 2
FONE     DC    F'1'                FOR ROUNDING HALFWORD ADDRS
FTHREE   DC    F'3'                *            FULLWORD
FSEVEN   DC    F'7'                *            DBL WORD
         SPACE
HFOUR    DC    H'4'                CONSTANT 4 HALF WORD
HEIGHT   DC    H'8'                CONSTANT 8 HALF WORD
HSIXTEEN DC    H'16'               CONSTANT 16 HALF WORD
         SPACE
GRDATA   DS    0F
GRINCR   DC    H'1'                INCRE VALUE FOR GEN REG ADDRS
GRLIM    DC    H'15'               MAX GEN REG ADDR
         SPACE
FPRDATA  DS    0F
FPRINCR  DC    H'2'                INCRE VALUE FOR FL PT REGS.
         SPACE
         EJECT
PCHTRTBL DC    256AL1(*-PCHTRTBL)  LOWER TO UPPER CASE TR TABLE
         ORG   PCHTRTBL+C'A'-X'40' SET LOCATION CTR TO LOWER CASE 'A'
         DC    (C'Z'-C'A'+1)AL1(*-PCHTRTBL+X'40')  DEFINES UPPER CASE
         ORG
SUPERZAP DC    50C'Z'              MAINTENANCE AREA
         EJECT
*
*        FOLLOWING IS A MAP OF THE WORK AREA USED BY THE PATCH MODULES
*
PCHWORK  DSECT
PPCL     DS    7F                  SPACE FOR PARSE PARM LIST
         SPACE
ADDRINCR DS    F                   FULLWORD TO HOLD CONSTANTS FOR REGS
MAXRADDR EQU   ADDRINCR+2          OFFSET FOR MAX REG NUMBER
PCHRETCD DS    F                   HOLDS CURRENT RETURN CODE
VPDE     DS    3F                  HOLDS CURRENT COPY OF THE VALUE PDE
A1       DS    F                   HLODS CURRENT ADDR TO BE PATCHED
DUMMYPDE DS    3F                  RESERVE SPACE FOR COPY OF VALUE PDE.
A1L      DS    H                   HOLDS CURRENT STRING LNTH FOR 'C'
A1TYPE   DS    X                   CONTAINS TYPE ASSOCIATED WITH VALUE
         DS    AL3                 RESERVED
         DS    XL1                 RESERVED
         DS    0D
         ORG   *-1                 POSITION FOR LENGTH BYTE OF HOLDAREA
CONAREA1 DS    XL41                USED FOR ADDRESSING PURPOSES ONLY.
         ORG   CONAREA1            RE-USE SPACE FOR ACTUAL HOLDAREA
HOLDAREA DS    XL65                TEMP HOLD AREA FOR DATA CONVERSION
MSGPLIST DS    2F                  PARM LIST FOR CALLING IKJEGIO1.
TYPESAVE DS    C                   FOR SAVING USER SUPPLIED TYPE CODE
REGDATA  DS    F                   PATCH VALUE TO BE PLACED IN REGISTER
ASNSVCL  DS    3F                  FOR SVC97 & IKJEGSRH PARAMETER LIST
APDEADDR DS    F                   ADDR OF THE ADDR PDE
ASNFLGS1 DS    X                   FLAGS FOR EXCLUSIVE USE OF ASSIGN
LPCHWORK EQU   *-PCHWORK           LENGTH OF TOTAL DSECT.
         EJECT
         VALUPDE
         EJECT
         BRKELEM
         SPACE 3
         TSTCWORK                  EXPAND TEST'S CORE MAPPING DSECT
         EJECT
         TCOMTAB
         EJECT
         IKJPARMA                  EXPAND THE ADDR PDE MAPPING DSECT
         EJECT
CVT      DSECT
         CVT
         EJECT
         IKJTCB
         END
