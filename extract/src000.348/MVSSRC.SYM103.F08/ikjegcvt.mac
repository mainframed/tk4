CVT      TITLE ' * MVM * IKJEGCVT THE CONVERSION ROUTINE OF TEST'
         COPY IKJEGSIO
IKJEGCVT CSECT
*C59800                                        ZA09259,ZA10462,ZA07138
*D60600                                                        ZA07138
*A047397,047398                                                  YM0568
*A530420,530500                                                 YA00086
*A047130                                                       @ZA11823
*C047140                                                       @ZA11823
*C50040000                                                     @ZA11367
*A50042000-50050000                                            @ZA11367
*A159182                                                       @ZA28933
*****************************  PROLOGUE  ******************************
* STATUS  CHANGE LEVEL  00, VERSION NUMBER 01, OS/VS2                 *
*                                                                     *
* FUNCTION                                                            *
*    THIS MODULE IS A UTILITY PROGRAM USED BY THE 'TEST' PACKAGE      *
*    OF THE TIME SHARING OPTION (TSO) FOR AOS/370 MVT.  IT IS         *
*    CALLED BY VARIOUS TEST ROUTINES TO PERFORM DATA TRANSLATION      *
*    TO/FROM BINARY FROM/TO A PRINTABLE FORMAT.  THIS ROUTINE IS      *
*    ABLE TO CONVERT TO BINARY FROM THE FOLLOWING PRINTABLE FOR-      *
*    MATS- A, B, D, E, F, H, P, S, X, AND Y.  IN ADDITION, IT IS      *
*    ABLE TO CONVERT FROM BINARY TO THE FOLLOWING PRINTABLE FOR-      *
*    MATS- A, D, E, F, H, I, P, S, X, AND Y.                          *
*                                                                     *
* ENTRY POINTS                                                        *
*                                                                     *
*    IKJEGCVT-ENTRY POINT FOR ADDRESS AND VALUE CONVERSIONS.          *
*                                                                     *
*    IKJEGCOP-ENTRY POINT FOR THE OPCODE TABLE.                       *
*                                                                     *
* INPUT                                                               *
*    GENERAL PURPOSE REGISTER ZERO                                    *
*         IF NEGATIVE, INDICATES CONVERSION TO PRINTABLE FORMAT.      *
*         IF POSITIVE, INDICATES CONVERSION TO BINARY FORMAT.         *
*    GENERAL PURPOSE REGISTER ONE POINTS TO A PARSE-LIKE PARAME-      *
*    TER DESCRIPTOR LIST (PDL) CONTAINING AN ADDRESS OR A VALUE       *
*    PARSE-LIKE DESCRIPTOR ENTRY (PDE)                                *
*         IF NEGATIVE, INDICATES AN ADDRESS CONVERSION.               *
*         IF POSITIVE, INDICATES A VALUE CONVERSION.                  *
*                                                                     *
* OUTPUT                                                              *
*    FOR ADDRESS CONVERSION                                           *
*         1).  BINARY TO PRINTABLE CONVERSION OUTPUT IS RETURNED      *
*              IN CONAREA.                                            *
*         2).  PRINTABLE TO BINARY CONVERSION OUTPUT IS RETURNED      *
*              IN THE USER WORD OF THE ADDRESS PDE.                   *
*    FOR VALUE CONVERSION                                             *
*         THIS ROUTINE PLACES IN A SECTION OF CORE, POINTED TO        *
*         TO BY 'CONAREA' IN THE TEST COMMUNICATION TABLE (TCOMTAB)   *
*         THE FOLLOWING                                               *
*         1).  LENGTH OF CONVERTED OUTPUT.  (FIRST BYTE).             *
*         2).  ACTUAL CONVERTED OUTPUT.  (REMAINING BYTES).           *
*                                                                     *
* EXTERNAL REFERENCES                                                 *
*                                                                     *
*    IKJEGSYM - THE CONVERT ROUTINE CALLS UPON IKJEGSYM TO PER-       *
*    *          FORM RESOLUTION FOR ALL SYMBOLIC ADDRESSES AS         *
*    *          WELL AS FOR THE SYMBOLIC PART OF ADDRESS EXPRES-      *
*    *          SIONS.  IT EXPECTS IKJEGSYM TO SET THE FIRST BYTE     *
*    *          OF THE USER WORD OF THE ADDRESS PDE TO X'80' AND      *
*    *          TO SET THE REMAINING THREE BYTES TO POINT TO A        *
*    *          SYMBOL INFORMATION BLOCK (SYMINFO) WHOSE FIRST        *
*    *          WORD CONTAINS THE BINARY REPRESENTATION OF THE        *
*    *          ADDRESS.                                              *
*                                                                     *
*    IKJEGIO  - I/O IS CALLED TO WRITE DIAGNOSTIC MESSAGES;   IT      *
*    *          IS INVOKED VIA THE IKJEGSIO MACRO.                    *
*                                                                     *
*    ESTAE    - ESTABLISH ABEND RECOVERY EXIT ROUTINE (IKJEGSTA)      *
*                                                                     *
* EXITS, NORMAL                                                       *
*    RETURN VIA GENERAL PURPOSE REGISTER FOURTEEN.                    *
*    RETURN CODE ZERO IN GENERAL PURPOSE REGISTER FIFTEEN.            *
*                                                                     *
* RETURN CODES                                                        *
*    00 - SUCCESSFULLY COMPLETED CONVERSION.                          *
*    04 - UNABLE TO CONVERT A VALUE.                                  *
*    16 - ATTENTION HAS BEEN SCHEDULED.                               *
*    20 - ESTAE EXIT ROUTINE HAS INTERCEPTED A SCHEDULED ABEND.       *
*    24 - COULD NOT ISSUE ESTAE.                                      *
*                                                                     *
* EXITS, ERROR                                                        *
*    RETURN VIA GENERAL PURPOSE REGISTER FOURTEEN.                    *
*    RETURN CODE FOUR (4) - UNABLE TO CONVERT VALUE.                  *
*    RETURN CODE SIXTEEN (16) - ATTENTION IN EFFECT.                  *
*                                                                     *
* TABLES/WORK AREAS                                                   *
*    TCOMTAB - TEST TABLE AND WORKAREA                                *
*                                                                     *
* ATTRIBUTES                                                          *
*    REENTRANT, REFRESHABLE                                           *
*                                                                     *
* CHARACTER CODE DEPENDENCY --                                        *
*    RE-ASSEMBLY IS REQUIRED FOR CHANGE OF CODE                       *
*                                                                     *
* NOTES                                                               *
* CHANGE-ACTIVITY -
*                APAR OZ07138 FIXES A PROBLEM WITH FETCHING AND
*                STORING REGISTERS IN THE INCORRECT RB WHEN AN
*                ASYNCHRONOUS EXIT CAUSES AN IRB TO BE CHAINED ON
*                THE TCB/RB QUEUE.  THE FIX IS BEFORE LABEL REGPK.
*                THE SVC 97 SVRB WILL BE POINTED TO OUT OF TCOMTAB
*                AT LABEL ECBPP+1.
*                APAR OZ09259 - SAME AS ABOVE.
*                APAR OZ10462 - SAME AS ABOVE.
*                APAR OZ11823 - CORRECT EXIT ROUTINE SPECIFICATION
*                FOR ESTAE MACRO.
*                                                                     *
***********************************************************************
         EJECT
R0       EQU   0                       ********************************
R1       EQU   1                       *                              *
R2       EQU   2                       *        REGISTERS             *
R3       EQU   3                       *                              *
R4       EQU   4                       *         EQUATES              *
R5       EQU   5                       *                              *
R6       EQU   6                       *                              *
R7       EQU   7                       *                              *
R8       EQU   8                       *                              *
R9       EQU   9                       *         REGISTERS            *
R10      EQU   10                      *                              *
R11      EQU   11                      *         EQUATES              *
R12      EQU   12                      *                              *
R13      EQU   13                      *                              *
R14      EQU   14                      *                              *
R15      EQU   15                      ********************************
@0       EQU   0
@4       EQU   4
@6       EQU   6
@12      EQU   12
@16      EQU   16
@20      EQU   20
@24      EQU   24
@60      EQU   60
BASEDISP EQU   2
EXPPLUS  EQU   C'+'
B7       EQU   X'B7'                   FOR ALPHABETIC CONVERSION
F0       EQU   X'F0'                   FOR NUMERIC CONVERSIONS
ZERO     EQU   0                       ZERO
ONE      EQU   1                       ONE
TWO      EQU   2                       TWO
THREE    EQU   3                       THREE
FOUR     EQU   4                       FOUR
FIVE     EQU   5                       FIVE
SIX      EQU   6                       SIX
SEVEN    EQU   7                       SEVEN
EIGHT    EQU   8                       EIGHT
NINE     EQU   9                       NINE
TEN      EQU   10                      TEN
ELEVEN   EQU   11                      ELEVEN
ONE2     EQU   12                      TWELVE
HEXFF    EQU   X'FF'                   HEX FF
HEX00    EQU   X'00'                   HEX 00
HEX40    EQU   X'40'                   HEX 40
HEX80    EQU   X'80'                   HEX 80
HEXC0    EQU   X'C0'                   HEX C0
HEXF0    EQU   X'F0'                   HEX F0
HEX04    EQU   X'04'                   HEX 04
HEX0F    EQU   X'0F'                   HEX 0F
HEX08    EQU   X'08'                   HEX 08
HEX01    EQU   X'01'                   HEX 01
HEX13    EQU   X'13'                   HEX 13
HEX0C    EQU   X'0C'                   HEX 0C
EXP      EQU   X'FF'                   HEX FF
ONE3     EQU   13                      DEC 13
ONE1     EQU   11                      DEC 11
ONE4     EQU   14                      DEC 14
ONE5     EQU   15                      DEC 15
ONE6     EQU   16                      DEC 16
ONE9     EQU   19                      DEC 19
EXPIND   EQU   10
TWO4     EQU   24                      DEC 24
TWO3     EQU   23                      DEC 23
TWO6     EQU   26                      DEC 26
ONE7     EQU   17                      DEC 17
NOFZONE  EQU   34
TWO7     EQU   27                      DEC 27
TWO8     EQU   28                      DEC 28
THREE2   EQU   32                      DEC 32
FORTY    EQU   40                      DEC 40
*        GENERAL CONSTANTS USED BY THE CONVERT MODULES
VALLEN   EQU   5                       FIVE
STARTER  EQU   X'21'                   HEX 21
LENSYM   EQU   8                       MAXIMUM LEN FOR SYMBLES.
PACKSIGN EQU   25                      DEC 25
OUTLEN   EQU   X'70'                   HEX 70
WORK2    EQU   16                      DEC 16
WORK3    EQU   26                      DEC 26
FIXED    EQU   47                      OFFSET TO END OF ZONED DATA.
WORK4    EQU   8                       EIGHT
WORK5    EQU   18                      DEC 18
FDECSTAR EQU   44                      DEC 44
OPTAB4   EQU   4                       DEC 4
NEGBYTE  EQU   X'FF'                   HEX FF
HION     EQU   X'80'                   HEX 80
*        NON NUMERIC CONSTANTS
SIGNNEG  EQU   C'-'                    MINUS SIGN
PLUSSIGN EQU   C'+'                    PLUS SIGN
BLANK    EQU   C' '                    BLANK
AZERO    EQU   C'0'                    CHAR ZERO
PLUS     EQU   C'+'                    CHAR PLUS
MINUS    EQU   C'-'                    CHAR MINUS
CLOSE    EQU   C')'                    CLOSE PREN
OPEN     EQU   C'('                    OPEN PREN
COMMA    EQU   C','                    COMMA
PERIOD   EQU   C'.'                    PERIOD
*        MORE NUMERIC CONSTANTS TO BE USED BY THE CONVERT MODULE
OPSSVAL  EQU   X'20'                   HEX 20
OPRRVAL  EQU   X'04'                   HEX 04
OPSIVAL  EQU   X'1C'                   HEX 1C
OPRSVAL  EQU   X'0C'                   HEX 0C
LEN7     EQU   X'07'                   HEX 07
GENMASK  EQU   X'20'                   HEX 20
DOBMASK  EQU   X'10'                   HEX 10
SINMASK  EQU   X'08'                   HEX 08
BADPK    EQU   X'09'                   HEX 09
LOWORDER EQU   28                      DEC 28
TCBGRS   EQU   32                      DEC 32
TWO0     EQU   20                      DEC 20
SYMCK    EQU   X'80'                   HEX 80
VALCK    EQU   X'80'                   HEX 80
SIGNF    EQU   X'0F'                   HEX 0F
RSIGN    EQU   C'R'                    CHAR R
PLUSBIT  EQU   X'01'                   HEX 01
PLUSBITS EQU   X'0F'                   HEX 0F
ODDLEN   EQU   X'01'                   HEX 01
HCODE    EQU   X'14'                   HEX 14
HEX      EQU   X'02'                   HEX 02
F1       EQU   X'01'                   HEX 01
STCTLM   EQU   X'B6'                   OP CODE FOR STCTL.
STNSMM   EQU   X'AC'                   OP CODE FOR STNSM 370-R.
STOSMM   EQU   X'AD'                   OP CODE FOR STOSM 370 R.
SIOFOP   EQU   X'9C'                   OP CODE FOR SIO AND SIOF.
SRPOP    EQU   X'F0'                   OP CODE FOR SRP.
B2       EQU   X'B2'                   FIRST BYTES FOR 370 2 BYTE
*                                      OP CODES.
CHARS    EQU   C'S'
CHARF    EQU   C'F'
YCODE    EQU   X'24'
FIXCOUNT EQU   31                      LOOP COUNT FOR FIXDEC.
FEXPPDE  EQU   16
SIGNIT   EQU   25                      LOC OF SIGN BYTE OF PACK DATA.
PKLEN    EQU   X'70'
REGIN    EQU   3
RDSIGN   EQU   C'D'
RESIGN   EQU   C'E'
PACKANS  EQU   16                      ANSWER PLACE OFFSET FOR PACK.
PACKWORK EQU   26                      OFFSET FOR UPDATED PACK VALUE.
         EJECT
         TITLE '* AOS * IKJEGCVT ADDRESS AND VALUE ROUTING ROUTINE.'
         ENTRY IKJEGBL1
CVTBEGIN SAVE  (14,12),,*
         LR    R12,R15                 R12=ADDR OF BEGINNING OF CSECT.
         USING CVTBEGIN,R12            CSECT ADDRESSABILITY.
         USING TCOMTAB,R9              TCOMTAB ADDRESSABILITY.
         L     R15,REGSAVE4            R15=ADDR OF MODULE SAVE AREA.
         ST    R13,FOUR(R15)           SAVE ADDR OF CALLER SAVE AREA.
         ST    R15,EIGHT(R13)          ADDR IN CALLER SAVE AREA.
         LR    R13,R15                 R13=ADDR OF MODULE SAVE AREA.
         SPACE
***********************************************************************
*                                                                     *
*        THE FOLLOWING INSTRUCTIONS ESTABLISH ESTAE SUPPORT FOR CVT   *
*                                                                     *
***********************************************************************
         L     R3,WORKAREA        POINT TO CVT WORKAREA
         XC    @0(ESTAELN,R3),@0(R3)  CLEAR AREA FOR ESTAE EXPANSION
         L     R15,TSTSTAE        GET ESTAE ROUTINE ADDRESS    @ZA11823
         ESTAE (R15),CT,PARAM=LIST,RECORD=YES,MF=(E,(R3))      @ZA11823
         LTR   R15,R15            WAS 'ESTAE' ACCEPTED
         BZ    RESTORE1           IF R15=0, 'ESTAE' WAS ACCEPTED
         STC   R15,TSTESTRC       PLACE ESTAE RC IN TCOM TABLE
         LA    R15,@24            SET RETURN CODE TO DECIMAL 24
         B     AFTERSCB           GO RETURN
         SPACE
***********************************************************************
*                                                                     *
*        THE FOLLOWING INSTRUCTIONS ROUTE CONTROL TO THE PROPER       *
*        CONVERSION AREA, ADDRESS OR EXPRESSION VALUE.                *
*                                                                     *
***********************************************************************
         SPACE
RESTORE1 L     R15,REGSAVE4       R15=ADDR OF MODULE SAVE AREA
         L     R1,FOUR(R15)       GET ADDR OF CALLER'S SAVE AREA
         L     R0,@20(R1)         RESTORE R0                     YM0568
         L     R1,@24(R1)         RESTORE R1                     YM0568
         LTR   R1,R1                   Q.AN ADDRESS CONVERSION.
         BP    VALCVT                  R1 IS POSITIVE, VALUE CONVERSION
         SPACE
***********************************************************************
* THE FOLLOWING INSTRUCTIONS DETERMINE IF THE ADDRESS CONVERSION IS   *
* TO BE TO OR FROM BINARY.                                            *
***********************************************************************
         SPACE
         L     R3,WORKAREA             R3=ADDRESS OF WORKAREA.
         LCR   R1,R1                   R1=ADDRESS POSITIVE.
         LR    R8,R1                   R8=ADDRESS OF PDE.
         USING IKJPARMA,R8             PDE ADDRESSABILITY.
         LTR   R0,R0                   Q.CONVERSION TO BINARY.
         BM    FROMBIN                 RO IS NEG CVT FROM BINARY.
         TITLE 'IKJEGCVT ADDRESS VALIDITY CHECKING ROUTINE.'
TOBIN    EQU   *
         SPACE
***********************************************************************
*                                                                     *
*        THE FOLLOWING INSTRUCTIONS CONVERT AN ADDRESS FROM           *
*        PRINTABLE CHARACTERS TO THEIR BINARY FORMAT.                 *
*                                                                     *
***********************************************************************
         SPACE
* THE TEST UNDER MASK ROUTES CONTROL TO THE PROPER CONVERSION CODE.   *
         SPACE
         TM    PDEFLG4,ABSCOMPL        Q.IS ADDR ABSOLUTE.
         BZ    NOENTRY                 YES,CONVERT AN ABSOLUTE ADDR.
         TM    PDEFLG4,SYMADDR         Q.IS ADDR SYMBOLIC.
         BO    SYMFOUND                YES,CONVERT A SYMBOLIC ADDR.
         TM    PDEFLG4,RELADDR         Q.IS ADDR A RELATIVE.
         BO    RELFOUND                YES,CONVERT A RELATIVE ADDR.
         TM    PDEFLG4,CTONLY          Q.ONLY ENTRYNAME SPECIFIED.
         BO    ENTNAME                 YES,GET ADDR OF ENTRYNAME.
         SPACE
***********************************************************************
* THIS SECTION OF CODE CONVERTS A REGISTER FROM ITS PRINTABLE FORMAT  *
* TO ITS BINARY FORMAT.  IF THE REGISTER IS A GENERAL PURPOSE         *
* REGISTER AND IS INDIRECTED, THE VALUE POINTED TO BY THE INDIRECT    *
* WILL BE CONVERTED TO BINARY AND RETURNED IN THE USERWORD.           *
***********************************************************************
         SPACE
         LH    R4,PDELEN3              R4=LENGTH OF INPUT.
         LA    R5,PKLEN                R5=LENGTH OF PACKED DATA.
         BCTR  R4,ZERO                 R4=EXECUTE LENGTH.
         OR    R4,R5                   R4=L1 & L2.
         L     R2,PDEADRPT             R2=ADDR OF INPUT.
         EX    R4,REGPK                REG NOW PACKED DATA.
         CVB   R4,ZERO(R3)             R4=BINARY VALUE OF REG.
         ST    R4,ZERO(R3)             BINARY NOW IN WORKAREA.
         SPACE
* CHECK  TO DETERMINE IF INDIRECT ADDRESSING HAS BEEN SPECIFIED.      *
         SPACE
         LH    R7,PDEINDCT             R7=INDIRECT VALUE.
         CH    R7,ZEROS                Q.IS INDIRECT SPECIFIED.
         BE    EXPVAL                  NO,CHECK FOR MORE EXP VALUES.
         SPACE
***********************************************************************
* THE FOLLOWING INSTRUCTIONS LOCATE THE REGISTER SPECIFIED IN THE     *
* PROBLEM PROGRAM TCB TO GET THE CONTENT OF THE REGISTER.             *
***********************************************************************
         SPACE
         L     R5,ECBPP                R5=ADDR OF 9G SVRB      @ZA07138
*                                                              @ZA09259
*                                                              @ZA10462
         SR    R6,R6                   R6=0.
         IC    R6,THREE(R3)            R6=REGISTER NUMBER IN BINARY.
         SLL   R6,TWO                  R6=REGISTER OFFSET VALUE.
         L     R5,TCBGRS(R6,R5)        R5=CONTENT OF REGISTER IN PPTCB.
         LA    R5,ZERO(R5)             CLEAR HIGH ORDER BYTE.
         ST    R5,ZERO(R3)             CONTENT OF REG NOW IN WORKAREA.
         BCT   R7,NEXTADDR             GET NEXT ADDR.
         B     EXPVAL                  CHECK FOR INDIRECTING.
REGPK    PACK  ZERO(ONE,R3),ZERO(ONE,R2) INPUT NOW PACKED DECIMAL.
         SPACE
***********************************************************************
* THIS SECTION OF CODE CONVERTS A RELATIVE ADDRESS FROM ITS PRINT-    *
* ABLE FORMAT TO ITS BINARY FORMAT.  TO GET THE REQUIRED ADDRESS      *
* THE BINARY VALUE OF THE RELATIVE IS ADDED TO PPLOAD IF AN ENTRYNAME *
* WAS NOT SPECIFIED.  IF AN ENTRYNAME IS SPECIFIED CONTROL IS PASSED  *
* TO SYM TO RESOLVE THE ABSOLUTE ADDRESS OF THE ENTRYNAME.  THE       *
* RELATIVE VALUE IS THEN ADDED TO THE ABSOLUTE ADDRESS.               *
***********************************************************************
         SPACE
RELFOUND EQU   *
         TM    PDEFLG2,CTNAMFLG        Q.ENTRYNAME SPECIFIED.
         BNO   NOENTRY                 NO,SKIP LINK TO SYM.
         NI    PDEFLG3,(HEXFF-AFLG)    TURN OFF PARAMETER SWITCH.
         BAL   R10,SYMLINK             GO CALL IKJEGSYM.
         OI    PDEFLG3,AFLG            TURN PARAMETER SWITCH ON.
         LTR   R15,R15                 Q.ENTRYNAME FOUND.
         BNZ   RETURN                  RETURN TO CALLER.
         NI    PDEFLG3,(HEXFF-AFLG)    TURN OFF PARAMETER SWITCH.
NOENTRY  EQU   *
         SPACE
***********************************************************************
* THIS AREA OF CODE CONVERTS RELATIVE AND ABSOLUTE INPUT CHARACTERS   *
* TO BINARY VIA THE HEXBIN VALUE CONVERSION ROUTINE.                  *
***********************************************************************
         SPACE
         LA    R1,PDEADRPT             R1=ADDR OF VALUE TYPE PDE.
         BAL   R14,HEXBIN              LINK TO HEX TO BINARY ROUTINE.
         L     R2,CONAREA              R2=ADDRESS OF CONAREA.
         SR    R4,R4                   R4=0.
         IC    R4,ZERO(R2)             R4=LENGTH OF RELATIVE.
         LA    R2,ONE(R2)              R2=OUTPUT STRING ADDRESS.
         L     R2,ZERO(R2)             R2=OUTPUT STRING.
         LA    R5,FOUR                 R5=4.
         SR    R5,R4                   R5=NUMBER OF NONE VALID DIGITS.
         SLL   R5,THREE                R5=NUMBER OF BITS TO SHIFT.
         SRL   R2,ZERO(R5)             RELATIVE NOW RIGHT JUSTIFIED.
         ST    R2,ZERO(R3)             RELATIVE NOW IN WORKAREA.
         TM    PDEFLG4,ABSCOMPL        Q.ABSOLUTE SPECIFIED.
         BZ    INDIRECK                YES,CHECK FOR INDIRECKS.
         TM    PDEFLG3,AFLG            Q.ABSOLUTE ADDRESS IN USERWORD.
         BO    INFOSKIP                NO,GET PPLOAD.
         LA    R7,PDEUSER              R7=QUALIFIED BASE ADDRESS.
         OI    PDEFLG3,AFLG            TURN PARAMETER SWITCH ON.
         B     PPSKIP                  SKIP PPLOAD CODE.
INFOSKIP EQU   *
         LA    R7,PPLOAD               R7=ADDR OF CURRENT BASE FOR REL.
PPSKIP   EQU   *
         MVC   FOUR(FOUR,R3),ZERO(R7)  MOVE CURRENT BASE INTO WORKAREA.
         L     R7,FOUR(R3)             R7=CURRENT BASE FOR RELATIVE.
         AL    R7,ZERO(R3)             R7=ABSOLUTE ADDRESS IN BINARY.
         ST    R7,ZERO(R3)             MOVE ABSOLTE ADDRESS TO WORKAREA
         SPACE
***********************************************************************
* THE FOLLOWING CODE WILL DETERMINE IF INDIRECTING WAS SPECIFIED. IF  *
* INDIRECTING IS SPECIFIED THE VALUE POINTED TO BY THE INDIRECT WILL  *
* BE PROCESSED.                                                       *
***********************************************************************
         SPACE
INDIRECK EQU   *
         LH    R7,PDEINDCT             R7=INDIRECT COUNT.
         LTR   R7,R7                   Q.IS INDIRECTING REQUESTED.
         BZ    EXPVAL                  NO,CHECK FOR EXPRESSION VALUES.
         NI    PDEFLG5,HEXFF-PURESYM   TURN OFF SYMINFO SWITCH.
NEXTADDR EQU   *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        BAL TO AN ADDRESS VALIDITY CHECK R3 = ADDR TO BE CHECKED   *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         BAL   R10,ADDRVCK             IS THE ADDR VALID
         L     R6,ZERO(R3)             R6=ADDR OF NEXT VALUE.
         MVC   ZERO(FOUR,R3),ZERO(R6)  NEW VALUE NOW IN WORKAREA.
         MVI   ZERO(R3),ZERO           CLEAR HIGH ORDER BYTE.
         BCT   R7,NEXTADDR             DECREMENT INDIRECT COUNT.
         SPACE
***********************************************************************
* THE FOLLOWING INSTRUCTIONS CHECK FOR AN ADDRESS EXPRESSION VALUE.   *
* IF AN ADDRESS EXPRESSION IS INDICATED IT IS CONVERTED TO BINARY AND *
* ADDED TO THE ADDRESS ALREADY CALCULATED.                            *
***********************************************************************
         SPACE
EXPVAL   EQU   *
         CLI   PDEEXPTR,EXP            Q.EXPRESSION SPECIFIED.
         BE    SKIPEXP                 NO,SKIP CODE TO TURN OFF SWITCH.
         NI    PDEFLG5,HEXFF-PURESYM   TURN OFF SYMINFO SWITCH.
SKIPEXP  EQU   *
         L     R1,PDEEXPTR             R1=PT TO EXPRESSION PDE
         MVC   WORK4(ONE,R3),PDESIGN   SAVE EXPRESSION SIGN.
MOREVAL  EQU   *
         LTR   R1,R1                   Q.MORE ADDRESS EXPRESSIONS.
         BM    CORECK                  NO,CHECK MAXIMUM CORE SIZE.
         SPACE
***********************************************************************
* THE FOLLOWING INSTRUCTION DETERMINE IF THE VALUE IS HEX OR DECML.   *
***********************************************************************
         SPACE
         TM    EIGHT(R1),HEX           Q.IS THE VALUE A HEX VALUE.
         BO    HEXVAL                  YES,CONVERT THE VALUE TO BINARY.
         SPACE
* THIS AREA OF CODE CONVERTS A DECML VALUE TO BINARY BY A LINK TO     *
* FIXBIN(DECIMAL TO BINARY) ROUTINE.                                  *
         SPACE
         SR    R5,R5                   R5=0,FOR FIXBIN ROUTINE.
         L     R0,ZERO(R3)             R0=ADDRESS.
         BAL   R14,FAQVBIN             LINK TO FIXBIN CONVERT ROUTINE.
         SPACE
***********************************************************************
* THE FOLLOWING CODE ALTERS THE BINARY ADDRESS ALREADY COMPUTED WITH  *
* THE RESULTS OF THE BINARY VALUE RETURNED FROM THE CONVERSION        *
* ROUTINE.                                                            *
***********************************************************************
         SPACE
         L     R2,CONAREA              R2=ADDR OF CONAREA.
         LA    R2,ONE(R2)              R2=PT TO OUTPUT FROM FAQVBIN.
         L     R4,ZERO(R2)             R4=VALUE RETURNED BY FAQVBIN.
TESTSIGN EQU   *
         CLI   WORK4(R3),EXPPLUS       Q.EXPRESSION VALUE SIGN POSITIVE
         BE    PLUSEXP                 YES,ADD VALUE TO ADDRESS.
***********************************************************************
* THE FOLLOWING INSTRUCTIONS SUBTRACT FROM THE BINARY ADDRESS THE     *
* BINARY VALUE RETURNED FROM THE CONVERSION ROUTINE.                  *
***********************************************************************
         SPACE
         SR    R0,R4                   R4=ALTERED ADDRESS.
MOVEALT  EQU   *
         ST    R0,ZERO(R3)             ALTERED ADDRESS NOW IN WORKAREA.
         LH    R7,EXPIND(R1)           R7=EXP INDIRECT COUNT.
         LTR   R7,R7                   Q.IS INDIRECTING REQUESTED.
         BZ    NEXTEXP                 NO,CHECK NEXT EXP VALUE.
EXPADDR  EQU   *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        BAL TO AN ADDRESS VALIDITY CHECK R3 = ADDR TO BE CHECKED   *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         BAL   R10,ADDRVCK             IS THE ADDR VALID
         MVC   PDEUSER+ONE(THREE),ONE(R3) ADDR NOW IN USERWORD.
         SPACE
         L     R6,ZERO(R3)             R6=ADDR OF NEXT VALUE.
         MVC   ONE(THREE,R3),ONE(R6)   NEW VALUE NOW IN WORKAREA.
         BCT   R7,EXPADDR              DECREMENT INDIRECT COUNT.
NEXTEXP  EQU   *
         MVC   WORK4(ONE,R3),NINE(R1)  SAVE SIGN OF EXPRESSION.
         L     R1,ONE2(R1)             R1=NEXT EXP ADDRESS.
         B     MOREVAL                 CHECK FOR MORE EXP.
         SPACE
***********************************************************************
* THE FOLLOWING INSTRUCTION ADDS TO THE BINARY ADDRESS THE BINARY     *
* VALUE  RETURNED FROM THE VALUE CONVERSION ROUTINE.                  *
***********************************************************************
         SPACE
PLUSEXP  EQU   *
         AR    R0,R4                   R4=ALTERED ADDRESS.
         B     MOVEALT                 MOVE ALTERED ADDR INTO WORKAREA.
         SPACE
***********************************************************************
* THIS AREA OF CODE CONVERTS A HEX VALUE TO TO BINARY BY USING THE    *
* HEX TO BINARY VALUE CONVERSION ROUTINE.                             *
***********************************************************************
         SPACE
HEXVAL   EQU   *
         L     R0,ZERO(R3)             R0=ADDRESS VALUE.
         BAL   R14,HEXBIN              CONVERT HEX TO BINARY.
         L     R2,CONAREA              R2=ADDR OF OUTPUT AREA.
         MVC   ZERO(FOUR,R3),ONE(R2)   BINARY VALUE NOW IN WORKAREA.
         L     R4,ZERO(R3)             R4=BINARY VALUE.
         SR    R6,R6                   R6=0
         IC    R6,ZERO(R2)             R6=LENGTH OF BINARY VALUE.
         LA    R7,FOUR                 R7=4.
         SR    R7,R6                   R7=4-LENGTH OF BINARY.
         SLL   R7,THREE                R7=R7X8.
         SRL   R4,ZERO(R7)             R4=VALUE RIGHT JUSTIFIED.
         B     TESTSIGN                CHECK FOR + OR - SIGN.
         SPACE
***********************************************************************
* THE FOLLOWING INSTRUCTIONS CONVERTS A SYMBOLIC ADDRESS FROM         *
* PRINTABLE CHARACTERS TO IT BINARY VALUE.  THIS CONVERSION IS DONE   *
* BY USING THE SYMBOLIC CONVERSION OF IKJEGSYM.                       *
***********************************************************************
         SPACE
SYMFOUND EQU   *
         SPACE
* CHECK LENGTH FOR MORE THAN 8 BYTES.                                 *
         SPACE
         CLI   PDELEN3+ONE,LENSYM      Q.IS SYMBOL GT 8 CHARACTERS.
         BH    SYMERROR                YES,WRITE ERROR MESSAGE.
         BAL   R10,SYMLINK             GO CALL IKJEGSYM.
         LTR   R15,R15                 Q.IS THE RC=0.
         BNZ   RETURN                  RETURN TO CALLER.
         SPACE
***********************************************************************
* THIS SECTION OF CODE GET THE BINARY ADDRESS FROM IKJEGSYM AND MOVES *
* IT INTO THE ADDRESS SAVE AREA.                                      *
***********************************************************************
         SPACE
         L     R2,PDEUSER              R2=ADDRESS OF SYMINFO.
         MVC   ZERO(FOUR,R3),ZERO(R2)  BINARY ADDRESS NOW IN WORKAREA.
         B     INDIRECK                CHECK FOR INDIRECKS.
         SPACE
***********************************************************************
* THIS SECTION OF CODE PUTS OUT AN ERROR MESSAGE INDICATING THAT THE  *
* LENGTH OF THE SYMBOLIC IS GREATER THAN EIGHT CHARACTERS.            *
***********************************************************************
         SPACE
SYMERROR EQU   *
         LA    R4,MSG001               R4=ADDR OF MSG ID PARM LIST.
         B     RITERROR                WRITE ERROR MSG.
         SPACE
***********************************************************************
* THIS SECTION OF CODE CHECKS TO DETERMINE IF THE ADDRESS COMPUTED IS *
* WITHIN THE MAXIMUM STORAGE AREA.                                    *
***********************************************************************
         SPACE
CORECK   EQU   *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        BAL TO AN ADDRESS VALIDITY CHECK R3 = ADDR TO BE CHECKED   *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         BAL   R10,ADDRVCK             IS THE ADDR VALID
         TM    PDEUSER,PDESIB          Q.ADDRES OF SYM INFO NEEDED.
         BO    NOCORECK                YES,SKIP CORE CHECK.
         MVC   PDEUSER+ONE(THREE),ONE(R3) ADDR NOW IN USERWORD.
         SPACE
NOCORECK EQU   *
         SR    R15,R15                 RC=0.
         SPACE
***********************************************************************
* THIS SECTION CHECKS TO DETERMINE IF A RANGE OF ADDRESSES HAVE BEEN  *
* REQUESTED.  A CHECK IS MADE FIRST TO DETERMINE IF A RANGE IS        *
* POSSIBLE.  THE NEXT CHECK WILL DETERMINE IF A RANGE WAS SPEDIFIED.  *
* THE FIRST WORD OF THE SECOND PDL IS TESTED FOR ZEROES, WHICH        *
* INDICATES THAT THE RANGE WAS NOT SPECIFIED.                         *
***********************************************************************
         SPACE
         TM    TSTFLGS1,RANGESW        Q.IS A RANGE POSSIBLE.
         BZ    RETURN                  NO,RETURN
         SPACE
* A RANGE IS POSSIBLE.  TURN SWITCH OFF AND CHECK FOR A RANGE.        *
         SPACE
         NI    TSTFLGS1,HEXFF-RANGESW  TURN RANGE SWITCH OFF.
         LA    R1,PDECHAIN             R1=ADDRESS OF SECOND PDL.
         NC    ZERO(TWO8,R1),ZERO(R1)  Q.RANGE SPECIFIED.
         BZ    RETURN                  NO,RETURN
         LR    R8,R1                   BUMP ADDRESSABILITY.
         B     TOBIN                   CONVERT 2ND ADDRESS.
         SPACE
***********************************************************************
* THE FOLLOW INSTRUCTION ANALYZE THE NON-ZERO RETURN CODE TO          *
* DETERMINE WHY THE CONVERSION FAILED.  THE RETURN CODE PASSED        *
* TO THE CALLING ROUTINE WILL REFLECT THE RESMIT OF THE ANALYSIS.     *
***********************************************************************
         SPACE
         LA    R15,FOUR                SET RETURN CODE=4.
         B     RETURN                  RETURN TO CALLER.
         SPACE
***********************************************************************
*   THE NEXT SECTION OF CODE VARIFIES AN ADDRESS PASSED IN R3
*   IT INVOKES SVC 97, (IKJEGS9G)
***********************************************************************
         SPACE
ADDRVCK  DS    0H                      CHECK OUT THE ADDRESS
         SPACE
         L     R6,PPTCB                R6= ADDR OF THE PROBLEM PROG TCB
         USING CVTWORK,R3              EST ADDR'IBILITY TO WORK AREA
         ST    R1,NUM4                 SAVE THE CONTENTS OF R1
         L     R2,ZERO(R3)             R2= ADDR TO BE CHECKED
         LA    R2,ZERO(R2)             ZERO HIGH ORDER BYTE
         IKJEGS9G ADDRCHK,TCBADDR=(R6),VALUE=(R2),MF=(E,NUM3)
         L     R1,NUM4                 RESTORE THE CONTENTS OF REG1
         LTR   R15,R15                 IS THE ADDRESS VALID
         BNZ   OUTCORE                 NO THE ADDRESS IS OUT OF REGION
         OI    PDEFLG5,PDEWRITE        SWITCH ON THE WRITE FLAG IN PDE
         DROP  R3                      RELEASE ADDR'IBILITY TO WORKAREA
         BR    R10                     RETURN TO CALLER VALID ADDRESS
         SPACE
ENTNAME  EQU   *
         LA    R10,ENDLINK             R14=CALLER ADDRESS.
         SPACE
*********************************************************************
*        THIS SUBROUTINE DOES THE LINK TO SYM. REGISTER 1 POINTS TO *
*        THE PDE ON ENTRY                                           *
*********************************************************************
         SPACE
SYMLINK  DS    0H                      LINK TO IKJEGSYM
         LINK  EP=IKJEGSYM,MF=(E,(1)),ERRET=ERRET2 LINK WITHOUT BLDL
IKJEGBL1 EQU   *
SMTSYM1  DS    0H                      SMT TESTCASE LABEL
*                                       LINK TO SYM FAILED
*                                       TESTCASE ID  TTSTC120
*                                       TESTCASE ID  TEQU5300
         BR    R10                     RETURN TO CALLER.
*
*
ERRET2   LR    R0,R1              PUT ABEND CODE IN REG0
         LA    R2,@6              GET 'LINK' SVC NUMBER
         B     SVCERR1            GO ISSUE MESSAGES
ENDLINK  EQU   *
         LTR   R15,R15                 Q.RC=0.
         BNZ   RETURN                  RETURN TO CALLER.
         TM    PDEFLG5,PDESIB          IS THIS A SIB POINTER
         BO    ENDLK2                  YES THEREFORE CHECK THAT ADDR
         MVC   ZERO(FOUR,R3),PDEUSER   ADDR TO BE CHECKED IN WORKA
         B     ENDLK3                  CHECK ADDR
ENDLK2   DS    0H                      CHECK THE ADDR IN SIB BLK
         L     R6,PDEUSER              R6= ADDR OF THE SIB BLK
         MVC   ZERO(FOUR,R3),ZERO(R6)  ADDR TO BE CHECKED TO WORKA
ENDLK3   DS    0H                      GO TO THE VALIDITY CHECKER
         BAL   R10,ADDRVCK             IS THE ADDR VALID
         B     NOCORECK                CHECK FOR RANGE.
         SPACE
***********************************************************************
*                                                                     *
*        THE FOLLOWING INSTRUCTIONS CONVERTS AN ADDRESS FROM          *
*        ITS BINARY FORMAT TO ITS PRINTABLE FORMAT.                   *
*                                                                     *
         SPACE
FROMBIN  EQU   *
         SPACE
* THE TEST UNDER MASK ROUTES CONTROL TO THE PROPER CONVERSION CODE.   *
         SPACE
         TM    PDEFLG4,ABSCOMPL        Q.IS BINARY TO BE ABSOLUTE ADDR.
         BZ    BINABT                  YES,CONVERT TO ABSOLUTE ADDR.
         TM    PDEFLG4,RELADDR         Q.IS BINARY TO BE A REL ADDR.
         BO    BINREL                  YES,CONVERT TO RELATIVE ADDR.
         SPACE
***********************************************************************
* THIS SECTION OF CODE CONVERTS BINARY TO REGISTER NOTATION. IF THE   *
* REGISTER IS A GENERAL PURPOSE REGISTER IT PRINTABLE VALUE WILL      *
* HAVE CHARACTER  -R-    FOLLOWING IT. IF IT IS A FLOATING POINT      *
* REGISTER THE LETTER -D- OR -E- WILL FOLLOW DEPENDING IF IT IS A     *
* SINGLE OR DOUBLE PRECISION.                                         *
***********************************************************************
         SPACE
         L     R5,PDEADRPT             R5=ADDR OF INPUT STRING.
         SR    R6,R6                   R6=0.
         IC    R6,REGIN(R5)            R6=ADDR STRING.
         CVD   R6,ZERO(R3)             REGISTER NOW PACKED DECIMAL.
         OI    SEVEN(R3),SIGNF         CHANGE SIGN TO X'F'.
         UNPK  ZERO(TWO,R3),SIX(TWO,R3) REGISTER NOW IN PRINTABLE FORM.
         SPACE
***********************************************************************
* THE FOLLOWING INSTRUCTION WHICH TYPE OF REGISTER HAS BEEN SPECIFIED *
* AND BRANCHES TO TO PROPER CODE TO MOVE IN THE PROPER LETTERS(R,RE,  *
* OR RD).                                                             *
***********************************************************************
         SPACE
         L     R2,CONAREA              R2=ADDRESS OF OUTPUT AREA.
         MVC   ONE(TWO,R2),ZERO(R3)    MOVE ADDR INTO OUTPUT AREA
         SR    R15,R15                 RC=0.
         MVI   ZERO(R2),THREE          MOVE LENGTH INTO CONAREA.
         TM    PDEFLG4,DOBMASK         Q.IS REGISTER DOUBLE PRECISION.
         BO    RDMOVE                  YES,MOVE IN D.
         TM    PDEFLG4,SINMASK         Q.IS REGISTER SINGLE PRECISION.
         BO    REMOVE                  YES,MOVE IN E.
         SPACE
***********************************************************************
* THE FOLLOWING WILL ALTER THE REG VALUE BY HAVING A (R) FOLLOWING    *
* IT.                                                                 *
***********************************************************************
         SPACE
         MVI   THREE(R2),RSIGN         APPEND -R- TO END OF OUTPUT.
         CLI   ONE(R2),F0              Q.IS FIRST BYTE A HEX -F0-.
         BNE   RETURN                  NO,RETURN TO CALLER.
         MVI   ONE(R2),BLANK           BLANK NOW IN FIRST BYTE.
         B     RETURN                  RETURN TO CALLER.
         SPACE
***********************************************************************
* THIS SECTION OF CODE ALTERS THE REGISTER VALUE BY APPENDING A (RD)  *
* TO THE END OF IT AND MOVE THE OUTPUT INTO CONVAREA.                 *
***********************************************************************
         SPACE
RDMOVE   EQU   *
         MVC   ONE(ONE,R2),ONE(R3)     REG NUMBER NOW IN CONAREA.
         MVI   TWO(R2),RDSIGN          MOVE D TO RIGHT OF OUTPUT.
         MVI   ZERO(R2),TWO            MOVE LENGTH INTO CONAREA.
         B     RETURN                  RETURN TO CALLER.
***********************************************************************
* THIS SECTION FO CODE ALTERS THE REGISTER VALUE BY PPPENDING A "RE"  *
* TO THE END OF IT AND MOVES THE OUTPUT INTO CONAREA.
***********************************************************************
         SPACE
REMOVE   EQU   *
         MVC   ONE(ONE,R2),ONE(R3)     MOVE REGISTER INTO CONAREA.
         MVI   TWO(R2),RESIGN          MOVE R TO RIGHT OF OUTPUT.
         MVI   ZERO(R2),TWO            MOVE LENGTH INTO CONAREA.
         B     RETURN                  RETURN TO CALLER.
         SPACE
***********************************************************************
* THIS SECTION OF CODE CONVERTS BINARY TO IT ABSOLUTE FORMAT. THE     *
* OUTPUT IS STORED IN CONAREA.                                        *
***********************************************************************
         SPACE
BINABT   EQU   *
         LA    R7,ZERO                 R7=0.
         L     R2,PDEADRPT             R2=ADDRESS OF INPUT STRING.
         LA    R6,SIX                  R6=LENGTH,6.
         MVC   ZERO(FOUR,R3),ZERO(R2)  INPUT NOW IN WORKAREA.
         L     R5,ZERO(R3)             R5=INPUT STRING.
         SLL   R5,EIGHT                ISOLATE LOW ORDER 3 BYTES.
         L     R2,CONAREA              R2=ADDR OF CONAREA.
         LA    R0,NINE                 R0=9.
NEXTBITS EQU   *
         SR    R4,R4                   R4=0.
         SLDL  R4,FOUR                 ISOLATE 4 BITS.
         CR    R4,R0                   Q.ARE BITS GT 9.
         BH    ADDRHI                  YES.
         SPACE
* THE 4 BITS ARE NUMERIC. MAKE PRINTABLE BY ADDING X'F0'.             *
         SPACE
         LA    R4,F0(R4)               R4=PRINTABLE BYTE.
BYTEMOVE EQU   *
         STC   R4,ONE(R2)              PUT BYTE INTO CONAREA.
         LA    R2,ONE(R2)              R2=ADDR OF NEXT OUTPUT AREA.
         LA    R7,ONE(R7)              INCREMENT BYTE COUNTER.
         CR    R7,R6                   Q.ARE THERE MORE BITS.
         BNE   NEXTBITS                YES,GET NEXT 4 BITS.
         L     R2,CONAREA              R2=ADDRESS OF CONAREA.
         MVI   ZERO(R2),LEN7           MOVE LENGTH INTO CONAREA.
         MVI   SEVEN(R2),PERIOD        APPEND -.- TO END OF OUTPUT.
         SR    R15,R15                 SET RC=0.
         B     RETURN                  RETURN TO CALLER.
         SPACE
* THE 4 BITS AREA ALPHABETIC. CONVERT PRINTABLE BY ADDING X'B7'.      *
         SPACE
ADDRHI   EQU   *
         LA    R4,B7(R4)               R4=PRINTABLE BYTE.
         B     BYTEMOVE                MOVE BYTE OF OUTPUT TO CONAREA.
         SPACE
***********************************************************************
* THIS SECTION OF CODE CONVERTS BINARY TO A RELATIVE ADDRESS. THE     *
* OUTPUT IS STORED IN CONAREA                                         *
***********************************************************************
         SPACE
BINREL   EQU   *
         TM    PDEFLG2,CTNAMFLG        Q.IS QUALIFY SPECIFIED.
         BZ    GETPP                   NO,GET ADDRESS FROM PPLOAD.
         L     R2,PPTEMP               R2=BASE FOR RELATIVES.
BASEMOVE EQU   *
         L     R4,PDEADRPT             R4=ADDRESS OF INPUT STRING.
         MVC   ZERO(FOUR,R3),ZERO(R4)  GET INPUT STRING.
         L     R4,ZERO(R3)             R4=INPUT STRING.
         SR    R4,R2                   R4=REALTIVE VALUE IN BINARY.
         ST    R4,ONE6(R3)             PUT INPUT INTO FAKE PDE.
         LA    R4,ONE6(R3)             R4=ADDRESS OF INPUT VALUE.
         ST    R4,EIGHT(R3)            ADDRESS IN FAKE VALUE PDE.
         LA    R5,FOUR                 R5=A LENGTH OF FOUR.
         STH   R5,ONE2(R3)             MOVE LENGTH INTO PDE.
         LA    R1,EIGHT(R3)            R1=ADDRESS OF FAKE PDE.
         BAL   R14,BINHEX              LINK TO BINHEX RT.
         L     R2,CONAREA              R2=ADDRESS OF CONAREA.
         LA    R2,ONE(R2)              R2=ADDRESS OF OUTPUT STRING.
         LA    R5,SEVEN                R5=7.
F0CHECK  EQU   *
         CLI   ZERO(R2),F0             Q.IS BYTE FIRST VALID CHAR.
         BNE   ONEF0                   YES,FORMAT OUTPUT.
         LA    R2,ONE(R2)              ADVANCE POINTER.
         BCT   R5,F0CHECK              CHECK LAST DITIT.
ONEF0    EQU   *
         EX    R5,RELMOVE              MOVE REL INTO WORKAREA.
         L     R2,CONAREA              R2=ADDRESS OF CONAREA.
         MVI   ZERO(R2),BLANK          BLANK IN FIRST BYTE OF CONAREA.
         MVC   ONE(FIVE,R2),ZERO(R2)   CONAREA NOW HAS SIX BLANKS.
         MVI   ZERO(R2),SEVEN          LENGTH NOW IN CONAREA.
         LA    R6,SIX                  R6=6.
         SR    R6,R5                   R6=OFFSET IN CONAREA.
         LA    R2,ONE(R6,R2)           R2=ADDR OF OUTPUT LOCATION.
         EX    R5,REL4MAT              MOVE OUTPUT INTO CONAREA.
         BCTR  R2,ZERO                 R2=ADDR OF BYTE BEFORE 1ST DIGIT
         MVI   ZERO(R2),PLUS           PRECEDE OUTPUT WITH A PLUS SIGN.
         SR    R15,R15                 RC=0.
         B     RETURN                  RETURN TO CALLER.
RELMOVE  MVC   ZERO(ONE,R3),ZERO(R2)   MOVE REL INTO WORKAREA.
REL4MAT  MVC   ZERO(ONE,R2),ZERO(R3)   MOVE REL OUTPUT INTO CONAREA.
OUTCORE  EQU   *
         LA    R2,EIGHT                CHECK FOR RETURN CODE FOUR
         CR    R15,R2                  RC=8 FROM SVC97?
         BNL   OUTCORE2                CONTINUE WITH ERROR MSG
         NI    PDEFLG5,HEXFF-PDEWRITE  TURN OFF THE PDE WRITE SW
         BR    R10                     RETURN & CONTINUE ADDR MAYBE OK
OUTCORE2 DS    0H                      CONTINUE WITH ERROR MESSAGE
         LA    R4,MSG002               R4=ADDR OF MSG ID LIST.
RITERROR EQU   *
ERRORPK  EQU   *
         L     R6,@4(R4)              GET SECOND LEVEL MSG ID
         L     R4,@0(R4)              GET 1ST LEVEL MSG ID
         XC   TSTIOPRM(L'TSTIOPRM),TSTIOPRM  CLEAR REMOTE LIST AREA
         LTR   R6,R6                  DOES SECOND LEVEL EXIST
         BZ    MACRO2                 NO - USE SECOND FORM OF IO MACRO
*                                     WE MUST BE ISSUING MSG003
         IKJEGSIO MSG,FIRST=(R4),INST11=(APDE,(R8)),SECOND=(R6),       *
               ID=CVT09,MF=(E,TSTIOPRM)
CHECKIO  SR    R4,R4                   CLEAR REG 4
         LA    R4,@12(R4)             PREPARE TO CHECK FOR RC > 12
         CR    R15,R4                  IS RC > 12
         BH    RETURN                  IF SO, RETURN
         LA    R15,FOUR                R15=RC OF 4.
         B     RETURN                  RESTORE CALLER REGISTERS.
MACRO2   IKJEGSIO MSG,FIRST=(R4),ID=CVT09,MF=(E,TSTIOPRM)
         B     CHECKIO                GO CHECK IO RETURN CODE
GETPP    EQU   *
         L     R2,PPLOAD               R2=CURRENT BASE FOR RELATIVES.
         B     BASEMOVE                MOVE IN INPUT STRING.
SVCERR1  LR    R3,R1              SET ABEND CODE FOR ABENDREG
         LR    R4,R15             SET RETURN CODE
         XC    TSTOIPRM(L'TSTOIPRM),TSTOIPRM CLEAR REMOTE PARM LIST
         LTR   R0,R0              IS THERE AN ABEND CODE FOR ABENDREG
         BZ    SVCERR2            IF R0=0, USE SVCERR2 FORM OF IO-MACRO
*
         IKJEGSIO SVCERR,SVC=(R2),RC=(R4),ABENDRG=(R3),MF=(E,TSTOIPRM),*
               ID=CVT09,INST11=(NUM,I0034)
         LA    R14,RETURN         INDICATE THAT SCB MUST BE REMOVED
         B     SVCRET             GO SET PROPER RETURN CODE
*
SVCERR2  IKJEGSIO SVCERR,SVC=(R2),RC=(R4),MF=(E,TSTOIPRM),             *
               ID=CVT09
         LA    R14,AFTERSCB     INDICATE THAT NO SCB IS TO BE REMOVED
*
SVCRET   SR    R1,R1              CLEAR REG1
         LA    R1,@12(R1)         PUT 12 IN REG 1
         CR    R15,R1             COMPARE RETURN CODE FROM IO WITH 12
         BNH   SETRC         IF R15 NOT > DEC 12, PASS RC TO CALLER
         BR    R14                PASS RETURN CODE TO CALLER
SETRC    SR    R15,R15            CLEAR R15 FOR RETURN CODE
         LA    R15,FOUR(R15)      SET RETURN = 4
         BR    R14                GO RESTORE REG'S AND RETURN TO CALLER
*
RETRY    SR    R9,R9              SET REG 9 TO ZERO
         L     R9,@16(R9)         POINT TO COM VECTOR TABLE
         L     R9,@0(R9)          POINT TO TASK CNTRL BLCK POINTERS
         L     R9,@4(R9)          POINT TO CURRENT TCB
         L     R9,@20(R9)         POINT TO THE TCOMTAB
         NI    TSTFLGS4,HEXFF-TSTRERTN   TURN OFF RETRY INDICATOR
         NI    TSTFLGS4,HEXFF-TSTVALCK   TURN OFF VALIDITY INDICATOR
         LA    R15,@20            INDICATE RETRY ROUTINE ENTERED
         L     R12,TSTCONVT       LOAD BASE REG                @ZA28933
         B     RETURN
*
ABENDTAB DS    0F
         DC    X'63'              LINK FAILED INSERT FOR ABEND MSG
         DC    AL3(SMTSYM1)
         DC    X'FF'
*
MSG001   DC    F'101'             MESSAGE M0101 (INVALID ADDRESS)
         DC    F'281'             MESSAGE M0281 (EXCEEDS EIGHT)
MSG002   DC    F'101'             MESSAGE M0101 (INVALID ADDRESS)
         DC    F'218'             MESSAGE M0217 (PROTECTED CORE)
MSG003   DC    F'23'              MESSAGE M0101 (INVALID ADDRESS)
         DC    F'000'    NO 2ND LEVEL MESSAGE PRESENT
LIST     IKJEGSPL RTRY=RETRY,ABNTB=ABENDTAB,MODNM=IKJEGCVT,            *
               TNM=CONVERT
         TITLE 'IKJEGCVT VALUE CONVERSION ROUTINE.'
***********************************************************************
* THE FOLLOWING INSTRUCTION DETRRMINE IF THE VALUE CONVERSION IS TO   *
* BE TO OR FROM BINARY.                                               *
***********************************************************************
         SPACE
YHCODE   EQU   *
         LA    R5,ONE                  R5=1. INDICATES H OR Y SPECIFIED
         B     NOTHORY                 BRANCH TO PROPER RTN.
         SPACE
VALCVT   EQU   *
         LTR   R0,R0                   Q.IS THE CONVERSION TO BINARY.
         BM    FROMBI                  NO,CONVERT VALUE TO PRINTABLE.
         SPACE
***********************************************************************
* THE FOLLOWING INSTRUCTIONS CONVERTS A VALUE FROM PRINTABLE     *
* CHARACTERS TO ITS BINARY FORMAT.                                    *
***********************************************************************
         SPACE
         SR    R5,R5                   R5=O. NOT H OR Y SWITCH.
         CLI   SEVEN(R1),HCODE         Q.H SPECIFIED.
         BE    YHCODE                  YES,SET H OR Y SWITCH.
         CLI   SEVEN(R1),YCODE         Q.Y SPECIFIED.
         BE    YHCODE                  YES,SET H OR Y SWITCH.
         SPACE
***********************************************************************
* THE FOLLOWING BRANCH ROUTINE ROUTES CONTROL TO THE DIFFERENT TYPES  *
* OF CONVERSIONS.                                                     *
***********************************************************************
         SPACE
NOTHORY  EQU   *
         SR    R6,R6                   R6=0.
         IC    R6,SEVEN(R1)            R6=TYPE CODE IN HEX.
         L     R15,ACONLST(R6)         R15=ADDRESS OF CVT RTN.
         BALR  R14,R15                 GOTO PROPER CONVERT RTN.
         USING BASEADDR,R14            R14=TEMP BASE REGISTER.
BASEADDR EQU   *
         L     R12,CVTBASE             R12=ADDR OF IKJEGCVT.
         DROP  R14                     R14 NO LONGER BASE REGISTER.
RETURN   EQU   *
         LR    R2,R15                  PRESERVE REG 15
         ESTAE 0                       REMOVE 'SCB'
         LR    R15,R2                  RESTORE REG15
AFTERSCB L     R13,FOUR(R13)           R13=ADDR OF CALLER SAVE AREA.
         RETURN (14,12),,RC=(15)       RESTORE CALLERS REGISTERS.
         SPACE
BINBIN   EQU   *
         SPACE
***********************************************************************
*                                                                     *
*        THIS ROUTINE CONVERTS PRINTABLE BYTES OF THE BINARY        *
*        FORMAT INTO ITS ONE BIT BINARY VALUE.                        *
*                                                                     *
***********************************************************************
         SPACE
         SR    R8,R8                   R8=0.
         IC    R8,VALLEN(R1)           R8=LENGTH OF INPUT.
         LA    R0,EIGHT                R0=8.
         SR    R7,R7                   R7=0.
         SR    R6,R6                   R6=0.
         L     R2,CONAREA              R2=ADDRESS OF OUTPUT AREA.
         LA    R2,ONE(R2)              R2=OUTPUT AREA PLUS 1.
         L     R3,ZERO(R1)             R3=ADDRESS OF INPUT STRING.
         SR    R1,R1                   R1=0.
INIT     EQU   *
         LA    R5,ONE                  R5=1
         LCR   R5,R5                   R5=32 BINARY ONES.
         SR    R4,R4                   R4=0.
NEXTBYTE TM    ZERO(R3),F1             Q.IS THE BYTE A ONE.
         BO    AONE                    YES,MOVE IN AN ON BIT.
         SLL   R4,ONE                  MOVE IN A ZERO.
         B     SKIPONE                 SKIP ONES ROUTINE.
AONE     EQU   *
         SLDL  R4,ONE                  MOVE IN ONE ON BIT.
SKIPONE  EQU   *
         LA    R3,ONE(R3)              INCREMENT INPUT ADDRESS.
         LA    R6,ONE(R6)              INCREMENT SAVE BYTE COUNTER.
         LA    R7,ONE(R7)              INCREMENT BYTE COUNTER.
         CLR   R0,R7                   BYTE COUNT=8.
         BNE   NOT8                    NO,COMPARE SAVE COUNT TO LENGHT.
         SR    R7,R7                   RE-INITIATE BYTE COUNT.
         STC   R4,ZERO(R2)             MOVE BYTE INTO CONAREA.
         LA    R1,ONE(R1)              INCREMENT LENGTH COUNTER.
         LA    R2,ONE(R2)              INCREMENT CONAREA POINTER
NOT8     CLR   R6,R8                   LENGTH=SAVE,BYTE COUNT.
         BE    BYTESEND                MOVE BYTE INTO CONAREA.
         LTR   R7,R7                   BYTE COUNT=0.
         BZ    INIT                    YES,CHECK NEXT EIGHT BYTES.
         B     NEXTBYTE                GET NEXT BYTE.
BYTESEND EQU   *
         LTR   R7,R7                   BYTE COUNT=0.
         BZ    NOOUT                   YES,OUTPUT IS IN OUTPUT AREA.
         LA    R8,EIGHT                R8=8.
         SR    R8,R7                   R7=NUMBER OF LEADING ZEROS.
         SLL   R4,ZERO(R8)             LEFT JUSTIFY OUTPUT
         STC   R4,ZERO(R2)             MOVE OUTPUT INTO CONAREA.
         LA    R1,ONE(R1)              R1=LENGTH OF OUTPUT PLUS 1.
NOOUT    EQU   *
         L     R2,CONAREA              R2=ADDRESS OF OUTPUT AREA.
         STC   R1,ZERO(R2)             PUT OUTPUT LENGTH INTO CONAREA.
         SR    R15,R15                 SET RC=0.
         BR    R14                     RETURN TO CALLER.
PKBIN    EQU   *
         SPACE
***********************************************************************
*                                                                     *
*        THIS ROUTINE CONVERTS PRINTABLE CHARACTERS TO PACKED         *
*        DECIMAL.                                                     *
*                                                                     *
***********************************************************************
         SPACE
         L     R2,CONAREA              R2=ADDR OF OUTPUT AREA.
         L     R4,WORKAREA             R4=ADDRESS OF WORKAREA.
         LH    R6,FOUR(R1)             R6=LENGTH OF INPUT.
         L     R3,ZERO(R1)             R3=ADDRESS OF INPUT STRING.
         LR    R8,R3                   R8=ADDR OF INPUT STRING.
         SPACE
*        THIS SECTION OF CODE CHECKS FOR A SIGN.                      *
         SPACE
         CLI   ZERO(R3),SIGNNEG        Q.IS SIGN NEGATIVE.
         BE    ADDADDR                 YES.
         CLI   ZERO(R3),PLUSSIGN       Q.IS SIGN POSITIVE.
         BNE   NOSIGN                  YES.
ADDADDR  LA    R3,ONE(R3)              R3=ADDRESS OF INPUT MINUS SIGN.
         BCTR  R6,ZERO                 DECREMENT LENGTH.
NOSIGN   EQU   *
         CLI   FIVE(R1),ONE6           Q.LENGTH GT 16.
         BH    PKLG                    YES.
         SPACE
***********************************************************************
*                                                                     *
*        THIS SECTION OF CODE CONVERTS TO PACK THE VALUE LESS THAN    *
*        SEVENTEEN BYTES.                                             *
*                                                                     *
***********************************************************************
         SPACE
         LR    R7,R6                   R7=LENGTH OF INPUT.
         SRL   R6,ONE                  R6=LENGTH DIVIDED BY 2.
         SLL   R6,FOUR                 R6=L1
         BCTR  R7,ZERO                 R7=EXECUTE INPUT LENGTH.
         OR    R6,R7                   R6=L1 AND L2.
         EX    R6,PACK4                INPUT STRING IS NOW PACKED DEC.
         SRL   R6,FOUR                 ISOLATE LENGTH OF OUTPUT.
         LA    R6,ONE(R6)              R6=EXACT LENGTH OF PACKED DEC.
         STC   R6,ZERO(R2)             MOVE LENGTH INTO CONAREA.
         LA    R3,ZERO(R6,R4)          R3=ADDRESS OF LAST OUTPUT BYTE.
         BCTR  R3,ZERO                 *
         CLI   ZERO(R8),SIGNNEG        Q.INPUT NEGATIVE.
         BNE   NO                      NO,MOVE IN POSITIVE SIGN.
         MVN   ZERO(ONE,R3),OFFSETD    MOVE IN NEG SIGN.
PKMOVE   EX    R6,OUTPUT               MOVE OUTPUT INTO CONAREA.
PKBEND   SR    R15,R15                 SET RETURN CODE.
         BR    R14                     RETURN TO CALLING ROUTINE.
NO       EQU   *
         MVN   ZERO(ONE,R3),OFFSETC    MOVE IN POSITIVE SIGN.
         B     PKMOVE                  MOVE OUTPUT INTO CONAREA.
PACK4    PACK  ZERO(ONE,R4),ZERO(ONE,R3)   INPUT NOW PACK DATA.
PKLG     EQU   *
         STC   R6,ZERO(R4)             LENGTH NOW IN WORKAREA.
         TM    ZERO(R4),ODDLEN         Q.LENGTH ODD.
         BO    LNODD                   YES,CONVERT ODD NUMBER OF BYTES.
         SPACE
***********************************************************************
*                                                                     *
*        THIS SECTION OF CODE CONVERTS AN EVEN NUMBER OF PRINTABLE    *
*        CHARACTERS TO PACKED DECIMAL.                                *
*                                                                     *
***********************************************************************
         SPACE
         PACK   ONE(NINE,R2),ZERO(ONE6,R3)  PACK FIRST 16 BYTES
         LA    R7,ONE6                 R7=16.
         SR    R6,R7                   R6=LENGTH MINUS 16.
         LR    R7,R6                   R7=R6.
         SRL   R6,ONE                  R6=LENGTH DIVIDED BY 2.
         BCTR  R7,ZERO                 R7=LENGTH FOR EXECUTE.
         SLL   R7,TWO8                 R7=LENGTH HIGH ORDER 4 BITS.
         SLDL  R6,FOUR                 R6=L1 AND L2 FOR EXECUTE.
         EX    R6,PACK2                PACK 2ND HALF OF INPUT STRING.
         SRL   R6,FOUR                 R6=LENGTH OUT PACKED DECIMAL.
         LA    R4,ZERO(R6,R4)          R4=ADDRESS OF SIGN BYTE.
         CLI   ZERO(R8),SIGNNEG        Q.SIGN NEGATIVE.
         BNE   NO2                     NO,MOVE POSITIVE SIGN.
         MVN   ZERO(ONE,R4),OFFSETD    MOVE IN NEG SIGN.
MOVEZ    L     R4,WORKAREA             R4=ADDRESS OF WORKAREA.
         MVZ   ZERO(ONE,R4),NINE(R2)   MOVE ZONE BITS OF 1ST PACKED DEC
         EX    R6,OUTPUT2              MOVE 2ND PACKED INTO CONAREA.
         LA    R10,TEN(R6)             TOTAL LENGTH OF OUTPUT.
         STC   R10,ZERO(R2)            MOVE LENGTH INTO CONAREA.
         B     PKBEND                  SET RETURN CODE TO 0.
LNODD    EQU   *
         SPACE
***********************************************************************
*                                                                     *
*        THIS  AREA OF CODE CONVERTS AN ODD NUMBER OF PRINTABLE       *
*        CHARACTERS TO PACKED DECIMAL.                                *
*                                                                     *
***********************************************************************
         SPACE
         PACK  ZERO(NINE,R4),ZERO(ONE6,R3) INPUT=PACKED DECIMAL FORMAT.
         XC    NINE(TWO,R4),NINE(R4)   ADD TWO BYTES OF ZEROS TO INPUT.
         NI    EIGHT(R4),AZERO         ALTER SIGN TO ZERO.
         MVO   ZERO(TEN,R4),ZERO(NINE,R4) SHIFT PACKED DEC 4 BITS.
         LA    R4,ONE(R4)              R4=ADDR OF PACKED DECIMAL.
         LA    R7,ONE6                 R7=169.
         SR    R6,R7                   R6=LENGTH MINUS 16.
         LR    R7,R6                   R7=LENGTH MINUS 16.
         SRL   R6,ONE                  R6=LENGTH DIVIDED BY 2.
         BCTR  R7,ZERO                 R7=LENGTH DIVIDED BY 2 MINUS 1.
         SLL   R7,TWO8                 R7=LENGTH IN HIGH ORDER BYTE
         SLDL  R6,FOUR                 R6=L1 AND L2 FOR EXECUTE.
         EX    R6,PACK3                PACK 2ND HALF OF INPUT STRING.
         SRL   R6,FOUR                 R6=LENGTH OF PACKED DECIMAL.
         LA    R4,EIGHT(R6,R4)         R4=ADDR OF SIGN BYTE.
         CLI   ZERO(R8),SIGNNEG        Q.SIGN NEGATIVE.
         BNE   POSITIVE                NO,MOVE POSITIVE SIGN.
         MVN   ZERO(ONE,R4),OFFSETD    MOVE IN NEG SIGN.
TLENGTH  LA    R6,NINE(R6)             R6=LENGTH OF OUTPUT
         STC   R6,ZERO(R2)             MOVE LENGTH INTO CONAREA.
         BCTR  R6,ZERO                 R6=LENGTH FOR EXECUTE.
         L     R4,WORKAREA             R4=ADDRESS OF WORKAREA.
         LA    R4,ONE(R4)              R4=ACTURAL ADDRESS OF INPUT
         B     PKMOVE                  MOVE OUTPUT INTO CONAREA.
POSITIVE EQU   *
         MVN   ZERO(ONE,R4),OFFSETC    MOVE IN POSITIVE SIGN.
         B     TLENGTH                 GET LENGTH OF THE OUTPUT.
PACK3    PACK  EIGHT(ONE,R4),ONE6(ONE,R3)  PACK 2ND HALF OF INPUT.
OUTPUT   MVC   ONE(ONE,R2),ZERO(R4)    MOVE OUTPUT INTO CONAREA.
PACK2    PACK  ZERO(ONE,R4),ONE6(ONE,R3) PACK 2ND HALF OF STRING.
OUTPUT2  MVC   NINE(ONE,R2),ZERO(R4)   MOVE 2ND HALF INTO CONAREA.
NO2      EQU   *
         MVN   ZERO(ONE,R4),OFFSETC    MOVEINNEG SIGN.
         B     MOVEZ                   CONTINUE PROCESSING.
HEXBIN   EQU   *
         SPACE
***********************************************************************
* THE FOLLOWING LINES OF CODE CONVERTS HEXADECIMAL BYTES TO BINARY.   *
* THIS ROUTINE CANNOT USE REGISTER 8, BECAUSE THE ADDRESS CONVERSION  *
* ROUTINE USES THIS ROUTINE AND REGISTER 8 IS THE PDE ADDRESSABILITY  *
* REGISTER.                                                           *
***********************************************************************
         SPACE
         L     R2,CONAREA              R2=CONVERT OUTPUT AREA ADDR.
         LH    R4,FOUR(R1)             R4=LENGTH OF INPUT.
         LR    R5,R4                   R5=LENGTH TO EXECUTE-TRANSLATE.
         BCTR  R5,ZERO                 DECREMENT LENGTH.
         L     R6,ZERO(R1)             R6=ADDRESS OF INPUT STRING.
         L     R3,WORKAREA             R3=ADDR OF TEMP. STORAGE
         EX    R5,SAFEMOVE             MOVE STRING INTO TEMP STORE
         LR    R6,R3                   R6=NEW STRING ADDR
         EX    R5,TRSLATE              TRANSLATE STRING
         LR    R10,R4                  R10=HEX LENGTH
         LA    R10,ONE(R10)            R10=LENGTH PLUS 1
         SRL   R10,ONE                 R10=LENGTH OF BINARY
         STC   R10,ZERO(R2)            STORE LENGTH FOR RETURN
         SLL   R10,FOUR                L1 TO HIGH END OF BYTE
         OR    R10,R4                  R10=L1 AND L2
         EX    R10,PACK                CONVERT TO BINARY
         SR    R15,R15                 RETURN CODE=0.
         BR    R14                     RETURN
TRSLATE  TR    ZERO(ONE,R6),TRTABLE    ALTER PRINTABLES FOR CVT.
SAFEMOVE MVC   ZERO(ONE,R3),ZERO(R6)   INPUT NOW IN WORKAREA.
PACK     PACK  ONE(ONE,R2),ZERO(ONE,R6) INPUT NOW IN BINARY FORMAT.
         ORG   *-193                   BYPASS ZEROES IN TABLE.
TRTABLE  EQU   *
         ORG   *+193                   RESET TABLE TO CORRECT IC.
         DC    X'FAFBFCFDFEFF'         *   TRANSLATE   TABLE          *
         DC    41X'00'                 *         FOR                  *
         DC    X'F0F1F2F3F4'           *    PRINTABLE HEXADECIMAL     *
         DC    X'F5F6F7F8F9'           *  TO BINARY ROUTINE.          *
         DC    C'ABCDEF'               *                              *
         DS    0H                      RESET TO HALFWORD BOUNDARY.
         SPACE
***********************************************************************
* THIS ROUTINE CONVERTS F,A,Q, AND V TYPE ADDRESSES TO BINARY.        *
* (R8 CAN NOT BE USE IN THIS ROUTINE.)                                *
***********************************************************************
         SPACE
FAQVBIN  EQU   *
         LA    R7,ONE                  SET SWITCH.
         L     R3,WORKAREA             R3=ADDR OF WORKAREA.
         LH    R2,FOUR(R1)             R2=PACK COUNT.
         BCTR  R2,ZERO                 *
         L     R4,ZERO(R1)             R4=ADDR OF INPUT STRING.
         CLI   ZERO(R4),SIGNNEG        Q.VALUE NEGATIVE.
         BE    NEGATIVE                YES,FLIP SWITCH NEGATIVE.
         CLI   ZERO(R4),PLUSSIGN       Q.PLUS SIGN ENTERED.
         BNE   NOSIGN2                 NO,DO NOT ACCOUNT FOR SIGN.
SIGN     EQU   *
         LA    R4,ONE(R4)              INCREASE ADDR TO BYPASS SIGN.
         BCTR  R2,ZERO                 R2=1 LESS BECAUSE OF SIGN.
         B     NOSIGN2                 SKIP COMPLEMENT CODE.
NEGATIVE EQU   *
         LCR   R7,R7                   FLIP SWITCH NEGATIVE.
         B     SIGN                    ALTER LENGTH.
NOSIGN2  EQU   *
         O     R2,ORREG                R2=L1 AND L2.
         EX    R2,PACK1                CONVERT STRING TO PACKED DEC.
         LTR   R7,R7                   VALUE NEGATIVE
         BH    POSIT                   NO,SKIP COMPLEMENT.
         MVN   SEVEN(ONE,R3),NEGSIGN   MAKE SIGN NEGATIVE.
POSIT    EQU   *
         CVB   R4,ZERO(R3)             CONVERT INPUT TO BINARY.
         L     R2,CONAREA              R2=ADDR OF OUTPUT AREA.
         LA    R2,ONE(R2)              R2=BYPASS LENGTH FIELD.
         SR    R15,R15                 RETURN CODE=0.
         LTR   R5,R5                   Q.H OR Y TYPE SPECIFIED.
         BNZ   HORY                    YES,MOVE ONLY HALFWORD.
         ST    R4,ZERO(R2)             MOVE VALUE INTO OUTPUT AREA.
         BCTR  R2,ZERO                 R2=ADDR OF LENGTH BYTE.
         MVI   ZERO(R2),FOUR           MOVE LENGTH INTO OUTPUT AREA.
         BR    R14                     RETURN.
HORY     EQU   *
         STH   R4,ZERO(R2)             MOVE VALUE INTO OUTPUT AREA.
         BCTR  R2,ZERO                 R2=ADDR OF LENGTH BYTE.
         MVI   ZERO(R2),TWO            LENGTH NOW IN OUTPUT AREA.
         BR    R14                     RETURN TO CALLER.
PACK1    PACK  ZERO(ONE,R3),ZERO(ONE,R4) INPUT NOW PACKED DECIMAL.
         SPACE
**********************************************************************
*        THE FOLLOWING INSTRUCTIONS WILL CONVERT PRINTABLE CHARACTERS *
*        TO BINARY IN THE SCON FORMAT.                                *
***********************************************************************
         SPACE
SCONBIN  EQU   *
         L     R6,WORKAREA             R6=ADDR OF WORKAREA.
         L     R3,ZERO(R1)             R3=ADDR OF INPUT STRING.
         LH    R2,FOUR(R1)             R2=LENGTH OF INPUT.
         BCTR  R2,ZERO                 R2=EXECUTE LENGTH.
         EX    R2,SCONMOVE             MOVE INPUT INTO WORKAREA.
         LR    R3,R6                   R3=ADDR OF WORKAREA.
FINDOPEN EQU   *
         LA    R3,ONE(R3)              R3=ADDR OF NEXT BYTE.
         CLI   ZERO(R3),OPEN           Q.OPEN PARENTHESIS FOUND.
         BNE   FINDOPEN                NO,CHECK NEXT BYTE.
         LR    R7,R3                   R7=ADDR OF OPEN PARENTHESIS.
         SR    R7,R6                   R7=LENGHT OF DISP.
         CLI   TWO(R3),CLOSE           Q.CLOSE PARENTHESIS FOUND.
         BNE   PACKTWO                 NO,PACK TWO BYTES.
         PACK  EIGHT(EIGHT,R6),ONE(ONE,R3) REGISTER NOW PACK DATA.
BINREG   EQU   *
         CVB   R5,EIGHT(R6)            REG NOW BINARY DATA.
         SLL   R5,ONE2                 REG IN HI ORDER OF SECOND BYTE.
         SPACE
* THE FOLLOWING LINES OF CODE CONVERTS THE DISP TO BINARY             *
         SPACE
         BCTR  R7,ZERO                 R7=EXECUTE LENGTH.
         LA    R8,OUTLEN               R8=OUTPUT LENGTH.
         OR    R7,R8                   R7=LENGTH1 AND LENGTH2.
         EX    R7,PACKDATA             PACK THE ZONE DISP DATA.
         CVB   R8,EIGHT(R6)            DISP NOW BINARY DATA.
         OR    R5,R8                   R5=SCON IN BINARY.
         L     R2,CONAREA              R2=ADDR OF CONAREA.
         MVI   ZERO(R2),TWO            LENGTH NOW IN CONAREA.
         LA    R2,ONE(R2)              R2=ADDR ONE PASS CONAREA.
         STH   R5,ZERO(R2)             SCON IN CONAREA.
         SR    R15,R15                 RC=0.
         BR    R14                     RETURN.
PACKTWO  EQU   *
         PACK  EIGHT(EIGHT,R6),ONE(TWO,R3) REGISTER NOW PACK DATA.
         B     BINREG                  CONVERT REGISTER TO BINARY.
SCONMOVE MVC   ZERO(ONE,R6),ZERO(R3)   INPUT NOW IN WORKAREA.
PACKDATA PACK  EIGHT(ONE,R6),ZERO(ONE,R6) DISP NOW PACK DATA.
         SPACE
***********************************************************************
* THE FOLLOWING INSTRUCTIONS CONVERTS A VALUE FROM BINARY TO ITS      *
* PRINTABLE FORMAT.                                                   *
***********************************************************************
         SPACE
HYCODE   EQU   *
         LA    R5,ONE                  R5=1,INDICATES H OR Y SPECIFIED.
         B     NOHORY                  GET TYPE CODE.
FROMBI   EQU   *
         SR    R5,R5                   R5=0. NOT H OR Y SWITCH.
         CLI   SEVEN(R1),HCODE         Q.H SPECIFIED.
         BE    HYCODE                  YES,SET H OR Y SWITCH.
         CLI   SEVEN(R1),YCODE         Q.Y CODE SPECIFIED.
         BE    HYCODE                  YES,SET H OR Y SWITCH.
NOHORY   EQU   *
         SR    R6,R6                   R6=0
         IC    R6,SEVEN(R1)            R6=TYPE CODE IN HEX.
         L     R15,ACONLST2(R6)        R15=ADDRESS OF CVT RTN.
         BALR  R14,R15                 GOTO PROPER CVT RTN.
         USING ADDRBASE,R14            R14=TEMP BASE REGISTER.
ADDRBASE EQU   *
         L     R12,CVTBASE             R12=ADDR OF IKJEGCVT.
         DROP  R14                     R14,NO LONGER BASE REGISTER.
         B     RETURN                  RETURN TO CALLER.
         SPACE
BINPK    EQU   *
         SPACE
***********************************************************************
*                                                                     *
*        THIS ROUTINE CONVERTS PACKED DECIMAL DATA TO PRINTABLE       *
*        CHARACTERS.                                                  *
*                                                                     *
***********************************************************************
         SPACE
         LA    R8,BADPK                R8=HEX -09-.
         SR    R6,R6                   R6=0.
         L     R3,ZERO(R1)             R3=ADDRESS OF INPUT STRING.
         LH    R4,FOUR(R1)             R4=LENGTH OF INPUT.
         LR    R5,R3                   R5=ADDRESS OF INPUT STRING.
         LR    R2,R4                   R2=LENGTH OF INPUT.
NEXTPK   EQU   *
         BCT   R2,BYTECK               CHECK FOR VALID PK DATA.
         IC    R6,ZERO(R5)             R5=LAST BYTE.
         SRDL  R6,FOUR                 RISOLATE HIGH ORDER 4 BITS.
         CLR   R6,R8                   Q.IS HITH ORDER 4 BITS VALID.
         BH    PKERROR                 NO,WRITE ERROR MESSAGE.
         SRL   R7,LOWORDER             LOW ORDER 4 BITS ISOLATED.
         CLR   R7,R8                   Q.LOW ORDER 4 BITS VALID.
         BNH   PKERROR                 NO,WRITE ERROR MESSAGE.
         B     SKIPPKCK                SKIP PACK VALIDITY CHECK.
BYTECK   EQU   *
         IC    R6,ZERO(R5)             R6=BYTE OF PACKED DATA.
         SRDL  R6,FOUR                 ISOLATE HIGH ORDER 4 BITS.
         CLR   R6,R8                   Q.HIGH ORDER 4 BITS VALID.
         BH    PKERROR                 NO,WRITE ERROR MESSAGE.
         SRL   R7,LOWORDER             LOW ORDER 4 BITS ISOLATED.
         CLR   R7,R8                   Q.LOW ORDER 4 BITS VALID.
         BH    PKERROR                 NO,WRITE ERROR MESSAGE.
         LA    R5,ONE(R5)              R5=ADDR OF NEXT BYTE.
         B     NEXTPK                  GET NEXT BYTE.
SKIPPKCK EQU   *
         LA    R6,ZERO(R4,R3)          R6=ADDR OF LAST BYTE OF INPUT.
         BCTR  R6,ZERO                 *
         L     R2,WORKAREA             R2=ADDRESS OF WORKAREA.
         LA    R5,ZERO(R4,R2)          R5=ADDRESS OF SIGN BYTE.
         BCTR  R5,ZERO                 *
         BCTR  R4,ZERO                 R4=EXECUTE LENGTH.
         EX    R4,MOVEPK               MOVE INPUT INTO WORKAREA.
         LA    R4,ONE(R4)              R4=CORRECT LENGTH.
         OI    ZERO(R5),SIGNF          ALTER SIGN TO X'F'
         LA    R5,ONE(R4,R2)           R5=ADDRESS OF EDIT OUTPUT AREA.
         MVC   ZERO(THREE2,R5),PATTERN MOVE PATTERN INTO WORKAREA.
         SLL   R4,ONE                  R4=LENGTH TIMES 2.
         BCTR  R4,ZERO                 R4=LENGTH MINUS ONE.
         LR    R7,R4                   R7=NEW LENGTH.
         BCTR  R7,ZERO                 R7=NEW LENGTH MINUS 1.
         LA    R1,ZERO(R5,R7)          R1=ADDR OF LAST BYTE OF OUTPUT.
         LR    R7,R1                   R7=ADDR OF LAST BYTE OF OUTPUT.
         EX    R4,ZONEPK               INPUT NOW ZONE DECIMAL.
         CLI   ZERO(R1),BLANK          Q.IS LAST CHARACTER A BLANK.
         BNE   NOBLANK                 NO,SKIP MOVE IN ZERO CODE.
         MVI   ZERO(R1),AZERO          MOVE IN A CHARACTER -0-.
NOBLANK  EQU   *
         L     R2,CONAREA              R2=ADDR OF CONAREA.
         TM    ZERO(R6),PLUSBIT        LOW ORDER BIT OF BYTE ON.
         BZ    ITSPLUS                 NO,THE STRING IS POSITIVE
         TM    ZERO(R6),PLUSBITS       Q.IS SIGN NEGATIVE.
         BO    ITSPLUS                 NO,IT MUST BE POSITIVE.
         BCTR  R1,ZERO                 R1=ADDR OF SIGN LOCATION.
         MVI   ZERO(R1),SIGNNEG        PUT SIGN IN OUTPUT AREA.
PUTOUT   EQU   *
         LA    R7,ONE(R7)              R7=END OF ZONED DATA ADDR.
         SR    R7,R1                   R7=LENGTH OF ZONED DATA.
         EX    R7,MOVEOUT              MOVE OUTPUT INTO OUTPUT AREA.
         LA    R7,ONE(R7)              R4=LENGTH OF OUTPUT.
         STC   R7,ZERO(R2)             LENGTH OF OUTPUT NOW IN CONAREA.
         SR    R15,R15                 SET RETURN CODE TO 0.
         BR    R14                     RETURN
ITSPLUS  EQU   *
         BCTR  R1,ZERO                 R1=ADDR OF SIGN LOCATION.
         MVI   ZERO(R1),PLUSSIGN       PUT PLUS SIGN IN OUT PUT AREA.
         B     PUTOUT                  MOVE OUTPUT INTO CONAREA.
ZONEPK   EDMK  ZERO(ONE,R5),ZERO(R2)   STRING NOW PRINTABLE CHARACTERS.
MOVEPK   MVC   ZERO(ONE,R2),ZERO(R3)   MOVE INPUT INTO WORKAREA.
MOVEOUT  MVC   ONE(ONE,R2),ZERO(R1)    MOVE OUTPUT INTO OUTPUT AREA.
PKERROR  EQU   *
         LA    R4,MSG003               R4=ADDR OF MSG PARM LIST.
         B     ERRORPK                 WRITE ERROR MESSAGE.
BINAQVY  EQU   *
         SPACE
***********************************************************************
*                                                                     *
*        THIS ROUTINE CONVERTS A,Q,V, AND Y TYPE CONSTANTS FROM       *
*        BINARY TO PRINTABLE CHARACTERS.  WHEN THE TYPE OS H OR Y,    *
*        REGISTER 5 MUST CONTAIN A VALUE GREATER THAN ZERO('0')       *
*        OTHERWISE REGISTER 5 WILL BE ZERO.                           *
*                                                                     *
***********************************************************************
         SPACE
         L     R2,CONAREA              R2=ADDRESS OF CONAREA.
         LH    R4,FOUR(R1)             R4=LENGTH OF INPUT.
         L     R1,ZERO(R1)             R1=ADDRESS OF INPUT STRING.
         L     R10,WORKAREA            R10=ADDRESS OF WORKAREA.
         BCTR  R4,ZERO                 R4=EXECUTE LENGTH.
         EX    R4,AQVYMOVE             MOVE INPUT INTO WORKAREA.
         L     R1,ZERO(R10)            R1=INPUT STRING.
         LA    R5,THREE                R5=3.
         SR    R5,R4                   R5=LENGTH MINUS 3.
         M     R4,FULL8                R5=NUMBER OF BITS TO SHIFT.
         SRL   R1,ZERO(R5)             INPUT RIGHT JUSTIFIED.
         N     R1,MASKSIGN             TURN HIGH ORDER BIT OFF.
         CVD   R1,ZERO(R10)            STRING NOW PACK DECIMAL.
         OI    SEVEN(R10),SIGNF        ALTER SIGN TO HEX F.
         UNPK  EIGHT(ONE5,R10),ZERO(EIGHT,R10) ZONED DECIMAL DATA.
         LA    R1,TWO3(R10)            R1=END OF OUTPUT ADDR.
         LA    R5,ONE4                 R5=14.
         LA    R10,EIGHT(R10)          R10=PTR TO OUTPUT DATA.
BUMP     CLI   ZERO(R10),AZERO         Q.VALID DATA FOUND.
         BNE   NOBUMP                  YES,COMPUTE LENGTH OF OUTPUT.
         LA    R10,ONE(R10)            BUMP PTR TO OUTPUT.
         BCT   R5,BUMP                 ALL OUTPUT TESTED FOR A ZERO.
NOBUMP   EQU   *
         SR    R1,R10                  R1=LENGTH OF OUTPUT.
         STC   R1,ZERO(R2)             LENGTH NOW IN CONAREA.
         BCTR  R1,ZERO                 R1=EXECUTE LENGTH.
         EX    R1,MOVE2                OUTPUT NOW IN CONAREA.
         SR    R15,R15                 RC=0.
         BR    R14                     RETURN TO CALLER.
MOVE2    MVC   ONE(ONE,R2),ZERO(R10)   MOVE OUTPUT TO CONAREA.
AQVYMOVE MVC   ZERO(ONE,R10),ZERO(R1)  INPUT NOW IN WORKAREA.
         SPACE
BINFDEC  EQU   *
         SPACE
***********************************************************************
*                                                                     *
*        THIS ROUTINE CONVERTS BINARY TO FIXED DECIMAL PRINTABLE.     *
*                                                                     *
***********************************************************************
         SPACE
         L     R2,CONAREA              R2=ADDR OF OUTPUT AREA.
         SR    R8,R8                   INITIALIZE GT SWITCH.
         LH    R6,FOUR(R1)             R6=LENGTH OF INPUT STRING.
         L     R3,ZERO(R1)             R3=ADDR OF INPUT STRING.
         L     R4,WORKAREA             R4=ADDR OF WORKAREA.
         MVI   ONE(R2),PLUSSIGN        PUT PLUS SIGN INTO OUTPUT AREA.
         SPACE
*        IS THE LENGTH OF THE BINARY VALUE GREATER THAN 4 BYTES.      *
         SPACE
         CL    R6,FIXLEN               Q.LENGTH GT 4 BYTES.
         BH    GREATER                 YES,CONVERT FIRST 4 BYTES.
         SPACE
***********************************************************************
*                                                                     *
*        THIS SECTION CONVERT ONLY FOUR BYTES OF BINARY DIGITS TO     *
*        ITS PRINTABLE FORM.                                          *
*                                                                     *
***********************************************************************
         SPACE
         BCTR  R6,ZERO                 R6=EXECUTE LENGTH.
         EX    R6,MOVEIN               INPUT NOW IN WORKAREA.
         LA    R6,ONE(R6)              R6=CORRECT LENGTH.
         L     R1,ZERO(R4)             R1=INPUT STRING.
         MVI   ONE(R2),PLUSSIGN        PUT PLUS SIGN INTO OUTPUT AREA.
         LA    R0,EIGHT                R0=EIGHT.
         LA    R5,FOUR                 R5=4.
         SR    R5,R6                   R5=4 MINUS LENGTH.
         LTR   R5,R5                   Q.IS LENGTH 4.
         BZ    NOSRL                   YES,SKIP RIGHT JUSTIFY.
         MR    R4,R0                   R4=SHIFT FACTOR.
         SRA   R1,ZERO(R5)             RIGHT JUSTIFY INPUT.
NOSRL    EQU   *
         LTR   R1,R1                   Q.IS VALUE NON-NEGATIVE.
         BNM   NONNEG                  YES,SKIP COMPLEMENT ROUTINE.
         SPACE
*        THIS AREA COMPLEMENTS THE NEGATIVE BINARY VALUE.             *
         SPACE
         LCR   R1,R1                   R1,NOW POSITIVE FOR CONVERT.
         MVI   ONE(R2),SIGNNEG         MOVE IN NEG SIGN.
         SPACE
NONNEG   EQU   *
         L     R3,WORKAREA             R3=ADDRESS OF WORKAREA.
         CVD   R1,ZERO(R3)             STRING IS NOW PACKED DECIMAL.
         LTR   R8,R8                   Q.LENGTH GT 4 BYTES.
         BZ    SKIP1                   NO,SKIP ADD ROUTINE
         SPACE
***********************************************************************
*                                                                     *
*        THIS SECTION ADDS THE REMAINDER OF THE INPUT STRING          *
*        (PACKED DECIMAL) TO THE ALREADY COMPUTED PACKED BYTES        *
*        OF THE STRING AND CONVERTS THE STRING TO ZONED DECIMAL.      *
*                                                                     *
***********************************************************************
         SPACE
         LTR   R7,R7                   Q.IS ADD ONE SWITCH ON.
         BZ    NOTON                   NO,DO NOT ADD ONE.
         AP    PACKANS(TEN,R3),PACKONE YES,ADD ONE.
NOTON    EQU   *
         AP    PACKANS(TEN,R3),ZERO(EIGHT,R3) ADD 2ND WORD TO 1ST WORD.
         MVN   PACKSIGN(ONE,R3),MASKSIGN   SET SIGN BITS TO HEX F.
         MVC   WORK3(TWO0,R3),PATTERN  PUT PATTERN INTO WORKAREA.
         MVI   FDECSTAR(R3),STARTER    STARTER CHAR NOW IN WORKAREA.
         LA    R1,FDECSTAR+ONE(R3)     R1=ADDR OF LAST BYTE.
         EDMK  WORK3(TWO0,R3),PACKANS(R3)  BLANK OUT LEADING ZEROS.
         LA    R4,FIXED(R3)            R4=END OF ZONED DATA.
         SR    R4,R1                   R4=NUMBER OF OUTPUT DIGITS.
         STC   R4,ZERO(R2)             LENGTH NOW IN OUTPUT AREA.
         BCTR  R4,ZERO                 R4=EXECUTE LENGTH
         BCTR  R4,ZERO                 R4=EXECUTE LENGTH.
         LR    R3,R1                   R3=ADDR OF SIGNIFICANCE BYTES.
         EX    R4,MOVE                 MOVE OUTPUT INTO CONAREA.
         SR    R15,R15                 R15=RC 0.
         BR    R14                     RETURN
         SPACE
SKIP1    EQU   *
         SPACE
***********************************************************************
*                                                                     *
*        THIS SECTION OF CODE CONVERTS FROM PACKED DECIMAL TO         *
*        ZONED THE INPUT WITH A LENGTH OF FOUR OR LESS.               *
*                                                                     *
***********************************************************************
         SPACE
         LA    R1,NOFZONE-TWO(R3)      R1=ADDR FOR STARTER CHAR.
         MVC   WORK5(ONE7,R3),PATTERN  PUT PATTERN INTO WORKAREA.
         MVI   ZERO(R1),STARTER        STARTER CHAR NOW IN PATTERN.
         LA    R1,ONE(R1)              R1=ADDR OF LAST BYTE.
         EDMK  WORK5(ONE6,R3),ZERO(R3) INPUT NOW ZONED DECIMAL.
         LR    R0,R3                   R0=ADDR OF WORKAREA.
         LR    R3,R1                   R3=ADDRESS OF ZONED DECIMAL.
         LA    R6,NOFZONE              R6=END OF ZONE DECIMAL.
         AR    R6,R0                   R6=END OF OUTPUT.
         SR    R6,R1                   R6=LENGTH OF OUTPUT.
         EX    R6,MOVE                 MOVE OUTPUT INTO CONAREA.
         LA    R6,ONE(R6)              R6=LENGTH OF OUTPUT.
         STC   R6,ZERO(R2)             MOVE LENGTH INTO CONAREA.
         SR    R15,R15                 R15=RC 0.
         BR    R14                     RETURN
GREATER  EQU   *
         SPACE
***********************************************************************
*                                                                     *
*        THIA AREA OF CODE CONVERTS A BINARY VALUE TO PACKED DECIMAL  *
*        WHOSE LENGTH IS GREATER THAN FOUR BYTES.  ONLY THE HIGH      *
*        ORDER FOUR BYTES ARE PACKED.                                 *
*                                                                     *
***********************************************************************
         SPACE
         XC    ZERO(EIGHT,R4),ZERO(R4) INPUT AREA NOW CLEARED.
         SR    R7,R7                   R7=0.
         LA    R1,SEVEN                R2=7.
         BCTR  R6,ZERO                 R6=EXECUTE LENGTH.
         SR    R1,R6                   R2=NUMBER OF LEADING ZEROES.
         LA    R4,ZERO(R1,R4)          NEW ADDR OF WORKAREA.
         EX    R6,MOVEIN               MOVE INPUT INTO WORKAREA.
         L     R3,WORKAREA             R3=ADDR OF WORKAREA.
         TM    ZERO(R4),VALCK          Q.IS INPUT NEGATIVE.
         BZ    NOTNEG                  NO,DO NOT COMPLEMENT.
         MVI   ONE(R2),SIGNNEG         MOVE IN NEG SIGN.
         MVI   EIGHT(R4),NEGBYTE       SET AN AREA
         MVC   NINE(SEVEN,R4),EIGHT(R4)            TO 2 WORDS OF ONES.
         XC    EIGHT(EIGHT,R3),ZERO(R3) FLIP BITS POSITIVE.
         LA    R3,EIGHT(R3)            R3=ADDR OF INPUT.
         LA    R7,ONE                  R7=1,INDICATE NEG & GT 4 BYTES.
NOTNEG   EQU   *
         SPACE
***********************************************************************
*                                                                     *
*        THE FOLLOWING CODE CALCULATES THE VALUE OF THE HIGH ORDER    *
*        BYTES OF THE INPUT STRING THAT EXCEEDS FOUR BYTES.           *
*                                                                     *
***********************************************************************
         SPACE
         L     R4,WORKAREA             R4=ADDR OF WORKAREA.
         L     R5,ZERO(R3)             R5=INPUT STRING.
         LA    R2,ONE                  R2=1.
         MVC   PACKWORK(TEN,R4),PACKVAL INITIAL VALUE IN PACK WORKAREA.
         XC    PACKANS(TEN,R4),PACKANS(R4) ZERO OUT PACK ANSWER PLACE.
         LA    R6,FIXCOUNT             R6=31,LOOP COUNT.
         LR    R1,R2                   R1=1.
         OI     SIGNIT(R4),SIGNF       PACK SIGN NOW X'F'.
NEXTBIT  EQU   *
         NR    R2,R5                   SET UP TEST REGISTER.
         BZ    NOTON2                  NO,JUST ADVANCE PACK VALUE.
         AP    PACKANS(TEN,R4),PACKWORK(TEN,R4) COMPUTE PACK VALUE.
NOTON2   EQU   *
         AP    PACKWORK(TEN,R4),PACKWORK(TEN,R4) UPDATE PACK VALUE.
         AR    R1,R1                   UPDATE BIT INDICATOR.
         LR    R2,R1                   R2=BIT INDICATOR.
         BCT   R6,NEXTBIT              IF MORE BITS TEST NEXT ONE.
         SPACE
***********************************************************************
*                                                                     *
*        THE FOLLOWING CODE CHECK THE HIGH ORDER BIT OF THE SECOND    *
*        WORD OF THE INPUT STRING TO DETERMINE IF IT IS ON. IF IT IS  *
*        ON IT WILL BE TURNED OFF AND THE VALUE OF IT WILL BE ADDED   *
*        TO THE FINAL VALUE. NO PROCESSING WILL BE DONE TO REFLECT    *
*        THE BIT BEINGING OFF.                                        *
*                                                                     *
***********************************************************************
         SPACE
         L     R2,CONAREA              R2=ADDR OF OUTPUT AREA.
         LA    R8,ONE                  SET GT SWITCH = GT 4 BYTES.
         L     R1,FOUR(R3)             R1=2ND WORK OF INPUT STRING.
         TM    FOUR(R3),HION           Q.HI ORDER BIT ON.
         BNO   NONNEG                  NO, BIT IS OFF.
         SLL   R1,ONE                  DROP HI ORDER BIT.
         SRL   R1,ONE                  ISOLATE REMAINDER OF BITS.
         AP    PACKANS(TEN,R4),LASTPACK  COMPUTE PACKED VALUE.
         B     NONNEG                  CONTINUE PROCESSING.
MOVE     MVC   TWO(ONE,R2),ZERO(R3)    MOVE OUTPUT INTO CONAREA.
MOVEIN   MVC   ZERO(ONE,R4),ZERO(R3)   MOVE INPUT INTO WORKAREA.
BINHEX   EQU   *
         SPACE
***********************************************************************
* THIS ROUTINE CONVERTS BINARY TO PRINTABLE HEXADECIMAL.              *
***********************************************************************
         SPACE
         L     R3,WORKAREA             R3=ADDRESS OF WORKAREA.
         LR    R4,R3                   R4=ADDRESS OF WORKAREA.
         L     R2,CONAREA              R2=OUTPUT AREA ADDRESS.
         LA    R2,ONE(R2)              ADVANCE PASS LENGTH AREA.
         LH    R10,FOUR(R1)            R10=LENGTH OF INPUT.
         BCTR  R10,ZERO                R10=EXECUTE LENGTH.
         L     R1,ZERO(R1)             R1=ADDRESS OF INPUT STRING.
         EX    R10,BHMOVE              MOVE INPUT TO EVEN BOUNDARY.
         LA    R10,ONE(R10)            R10=ACTUAL LENGTH OF INPUT.
         SLL   R10,ONE                 R10=LENGTH OF OUTPUT.
         SR    R1,R1                   CLEAR LENGTH COUNTER.
NEXTWORD EQU   *
         L     R7,ZERO(R4)             GET A WORD OF INPUT.
         SR    R5,R5                   CLEAR COUNTER.
MOREBITS EQU   *
         SR    R6,R6                   CLEAR WORK REGISTER.
         SLDL  R6,FOUR                 MOVE J BITS INTO WORK REG.
         CL    R6,FULLNINE             Q.BITS GT 9.
         BH    GREAT                   YES,CONVERT TO ALPHABETIC.
         LA    R6,F0(R6)               CONVERT TO HEX VALUE.
NEXT     EQU   *
         STC   R6,ZERO(R2)             MOVE TO CONAREA.
         LA    R2,ONE(R2)              INCREMENT CONAREA POINTER.
         LA    R5,ONE(R5)              INCREMENT INPUT COUNTER.
         LA    R1,ONE(R1)              INCREMENT LENGTH COUNTER.
         BCT   R10,BHEXGO              Q.MORE INPUT.
BHEXEND  EQU   *
         L     R2,CONAREA              R2=ADDRESS OF OUTPUT AREA.
         STC   R1,ZERO(R2)             PUT LENGTH INTO  CONAGRA.
         SR    R15,R15                 RC=0.
         BR  R14                       RETURN TO CALLER.
BHEXGO   EQU   *
         CL    R5,FULL8                Q.ANOTHER WORD NEEDED.
         BE    ADVANCE                 YES,INCREMENT R4 4 BYTES.
         B     MOREBITS                GET NEXT 4 BITS.
ADVANCE  EQU   *
         LA    R4,FOUR(R4)             R4=NEXT FOUR BYTES ADDRESS.
         B     NEXTWORD                GET NEW WORD.
GREAT    EQU   *
         LA    R6,B7(R6)               CONVERT TO HEX VALUE.
         B     NEXT                    MOVE BYTE TO CONAREA.
BHMOVE   MVC   ZERO(ONE,R4),ZERO(R1)   MOVE INPUT TO EVEN BOUNDARY.
         EJECT
***********************************************************************
* THE FOLLOWING IS A GROUP OF CONSTANTS USED BY THE CSECT'S
***********************************************************************
         SPACE
FIXLEN   DC    F'4'                    FULL WORD 4.
FULLNINE DC    F'9'                    FULL WORD 9.
FULL8    DC    F'8'                    FULL WORD 8.
MASKSIGN DC    X'7FFFFFFF'             USED TO TURN OFF HIGH ORDER BIT.
PACKONE  DC    PL10'1'                 PACKED DECIMAL 1.
ZEROS    DC    X'0000'                 HALFWORD OF DECIMAL ZEROES.
OFFSETC  DC    X'FC'                   NUMERIC C FOR PACK SIGN.
OFFSETD  DC    X'FD'                   NUMERIC D FOR PACK SIGN.
PATTERN  DC    X'40'                   PATTERN FIELD FOR THE EDIT
         DC    31X'20'                 AND MARK INSTRUCTION.
NEGSIGN  DC    P'-1'                   PACKED DECIMAL -1.
         DS    0F
ORREG    DC    X'00000070'             OUTPUT LENGTH FOR EXECUTE.
COMPFLD  DC    X'FFFFFFFF'             FULL WORD OF ONES.
         DS    0X
PACKVAL  DC    PL10'4294967296'        PACK DECIMAL VALUE FOR FIXDEC.
LASTPACK DC    PL10'2147483648'        *
BKPLUS   DC    C' +'                   MSG PLUS SIGN.
SMTSYM2  DC    C'SYM'                  CONSTANT NAME FOR BLDL
*                                       SMT TESTCASE LABEL
*                                       LINK TO SYM FAILED
*                                       TESTCASE ID  TTSTC120
*                                       TESTCASE ID  TEQU5300
SUPERZAP DC    50CL1'Z'                SUPERZAP PATCHING AREA
         DS     0F
LINKLST  LINK  SF=L                    LIST FORM OF LINK.
LINKLSTL EQU   *-LINKLST               LENGTH OF LIST FORM OF LINK.
ESTAELST ESTAE MF=L                    LIST FORM OF THE ESTAE MACRO
ESTAELN  EQU   *-ESTAELST              LENGTH OF ESTAE MACRO EXPANSION
         TITLE 'IKJEGCVT CONVERT BRANCH TABLE.'
***********************************************************************
* THE FOLLOWING LIST OF ADCONS AND VCONS ROUTES CONTROL TO THE PROPER *
* PRINTABLE TO BINARY CONVERSION ROUTINE.  THE VCONS ROUTE CONTROL TO *
* THE 2ND CSECT OF CONVERT WHICH CONTAINS THE INSTRUCTION AND FLOATING*
* POINT CONVERSIONS.                                                  *
***********************************************************************
         SPACE
ACONLST  EQU   *
         DC    A(RETURN)               CODE X'00' FOR CHAR.
         DC    A(HEXBIN)               CODE X'04' FOR HEX.
         DC    A(BINBIN)               CODE X'08' FOR BINARY.
         DC    A(RETURN)               CODE X'0C' FOR INST FROM BIN.
         DC    A(FAQVBIN)              CODE X'10' FOR FULLWORD FIXED PT
         DC    A(FAQVBIN)              CODE X'14' FOR HALFWORD FIXED PT
         DC    V(IKJEGFTB)             CODE X'18' FOR SHORT FLT PT.
         DC    V(IKJEGFTB)             CODE X'1C' FOR LONG FLT PT.
         DC    A(FAQVBIN)              CODE X'20' FOR A AND Q ADDRESS.
         DC    A(FAQVBIN)              CODE X'24' FOR Y ADDR CONSTANTS.
         DC    A(SCONBIN)              CODE X'28' FOR S ADDR CONSTANTS.
         DC    A(FAQVBIN)              CODE X'2C' FOR V ADDR CONSTANTS.
         DC    A(PKBIN)                CODE X'30' FOR PACKED DECIMAL.
         DC    A(RETURN)               CODE X'34' FOR ZONED DECIMAL.
         DC    A(RETURN)               CODE X'38' FOR EXTENDED FLT PT.
         SPACE
***********************************************************************
* THE FOLLOWING LIST OF ADCONS AND VCONS ROUTES CONTROL TO THE PROPER *
* BINARY TO PRINTABLE CONVERSION ROUTINE.  THE VCONS ROUTES CONTROL TO*
* THE 2ND CSECT OF CONVERT WHICH CONTAINS THE INSTRUCTION AND FLOATING*
* POINT CONVERSIONS.                                                  *
***********************************************************************
         SPACE
ACONLST2 EQU   *
         DC    A(RETURN)               CODE X'00' FOR CHAR.
         DC    A(BINHEX)               CODE X'04' FOR HEXADECIMAL.
         DC    A(RETURN)               CODE X'08' FOR BINARY.
         DC    V(IKJEGIST)             CODE X'0C' FOR INSTRUCTION.
         DC    A(BINFDEC)              CODE X'10' FOR FULLWORD FIXED PT
         DC    A(BINFDEC)              CODE X'14' FOR HALFWORD FIXED PT
         DC    V(IKJEGBFT)             CODE X'18' FOR SHORT FLT PT.
         DC    V(IKJEGBFT)             CODE X'1C' FOR LONG FLT PT.
         DC    A(BINAQVY)              CODE X'20' FOR A AND Q ADDRESS.
         DC    A(BINAQVY)              CODE X'24' FOR Y ADDR CONSTANTS.
         DC    V(IKJEGBIS)             CODE X'28' FOR S ADDR CONSTANTS.
         DC    A(BINAQVY)              CODE X'2C' FOR V ADDR CONSTANTS.
         DC    A(BINPK)                CODE X'30' FOR V ADDR CONSTANTS.
         DC    A(RETURN)               CODE X'34' FOR ZONED DECIMAL.
         DC    A(RETURN)               CODE X'38' FOR EXTENDED FLT PT.
CVTBASE  DC    A(CVTBEGIN)             ADDR OF IKJEGCVT.
         TITLE 'IKJEGCVT INSTRUCTION CONVERSION ROUTINE.'
IKJEGCVX   CSECT
         SPACE
***********************************************************************
*                                                                     *
* THIS CSECT IS AN EXTENTION OF THE CONVERT ROUTINE.  THE INSTRUCTION *
* CONVERSIONS FROM BINARY TO PRINTABLE CHARACTERS ARE FOUND IN THIS   *
* CSECT.                                                              *
*                                                                     *
***********************************************************************
         SPACE
         ENTRY IKJEGIST
         ENTRY IKJEGBIS
         SPACE
***********************************************************************
* THE FOLLOWING INSTRUCTIONS CONVERT AN INSTRUCTION IN STORAGE FROM   *
* ITS BINARY VALUE TO ITS PRINTABLE FORMAT.  A VALIDITY CHECK  IS     *
* TAKEN TO DETERMINE IF THE OP CODE IS VALID.  IF THE OP CODE IS IN-  *
* VALID AN ERROR MESSAGE IS PRINTED DESCRIBING THE CONDITION.         *
***********************************************************************
         SPACE
IKJEGIST EQU   *
         LR    R12,R15                 R12=ADDRESS OF IKJEGCVX.
         USING IKJEGCVX,R12            IKJEGCVX ADDRESSABILITY.
         USING TCOMTAB,R9              TCOMTAB ADDRESSABILITY.
         L     R3,ZERO(R1)             R3=PT TO THE INPUT STRING.
         SR    R5,R5                   R5=ZERO.
         L     R7,WORKAREA             R7=ADRESS OF WORKAREA.
         USING CVTWORK,R7              USE R7 TO ADDRESS WORKAREA.
         L     R2,CONAREA              R2=ADDR OF THE OUTPUT AREA
         MVI   CODE370,HEX00           CLEAR 370 FLAG INITIALLY.
         CLI   ZERO(R3),B2             Q.IS OP CODE TWO BYTES.
         BNE   ONEBYTOP                NO,GET OP CODE.
         CLI   ONE(R3),HEX13           YES,Q.IS 2 BYTE CODE VALID.
         BH    NOOPCODE                NO,ERROR MESSAGE.
         IC    R5,ONE(R3)              R5=SECOND OP CODE BYTE.
         LA    R8,SIX                  R2= X'6' (IE OP TABLE INCREMT)
         MR    R4,R8                   R5=INDEX FACTOR TO GET MNENOMIC
         L     R6,TSTOPCD2             R6=ADDR OF 2 BYTE OPCODE TABLE
         LA    R6,ZERO(R5,R6)          R6=ADDR OF OPCODE
         MVC   ONE(FIVE,R2),ZERO(R6)   PUT PRINTABLE OPCODE IN CONAREA
         LA    R8,FIVE                 R8=INDEX FOR OPCODE TABLE BRANCH
MVONEBK  EQU   *                       INSERT 1 BLANK FOLLOWING OPCODE
         MVI   SIX(R2),BLANK           FOLLOW OPCODE WITH ONE BLANK
         B     OPBRANCH                FIND THE OPCODE TYPE
ONEBYTOP EQU   *
         CLI   ZERO(R3),STCTLM         Q.IS OP CODE STCTL-5 CHARS.
         BE    SETCODE5                NO
         CLI   ZERO(R3),STNSMM         Q.IS OP CODE STNSM-5 CHARS.
         BE    SETCODE5                NO
         CLI   ZERO(R3),STOSMM         Q.IS OP CODE STOSM-5 CHARS.
         BNE   COMMONOP                NO, TRY OPCODE TABLE FOR 360
SETCODE5 EQU   *
         OI    CODE370,CHAR5           FLAG INDICATING 5 CHAR OPCODE
COMMONOP EQU   *
         IC    R5,ZERO(R3)             R5=THE OP CODE IN BINARY.
         LA    R8,FIVE                 R2=HEX 5.
         MR    R4,R8                   R5=INDEX FACTOR TO GET MNEMONIC.
         L     R6,OPCODTAB             R6=ADDR OF OPCODETAB.
         LA    R6,ZERO(R5,R6)          R6=ADDRESS OF OPCODE.
         LA    R8,FOUR                 R8=INDEX TO OPCODE TYPE FIELD
         TM    CODE370,CHAR5           Q.IS MNEUMONIC 5 CHARS.
         BNO   MOVEMNEU                NO,MOVE 4 CHARS FROM TABLE.
         MVI   ONE(R2),CHARS           YES,MOVE IN FIRST S CHAR.
         MVC   TWO(FOUR,R2),ZERO(R6)   INSERT REMAINING 4-BYT OF OPCODE
         B     MVONEBK                 INSERT THE BLANK
MOVEMNEU EQU   *
         MVC   ONE(FOUR,R2),ZERO(R6)   PRINTABLE OP CODE IN CONAREA.
         CLI   ZERO(R3),SIOFOP         Q.IS OP CODE X'9C' (SIOF OR SIO)
         BNE   MVBLANK                 NO,MOVE BLANK PAST MNEUMONIC.
         TM    ONE(R3),HEX01           YES.Q.IS OP CODE SIOF.
         BNO   MVBLANK                 NOT SIOF. MOVE BLANK.
         MVI   FOUR(R2),CHARF          IS SIOF. ADD F TO MNEUMONIC.
MVBLANK  EQU   *
         MVC   FIVE(TWO,R2),BLANKS     MOVE IN BLANK PASS MNEMONIC.
         DROP  R7                      DROP ADDRESSABILITY TO WORKAREA
         SPACE
***********************************************************************
* THE FOLLOWING INSTRUCTION FINDS THE PROPER INDEX VALUE FOR THE      *
* BRANCH TABLE.  THE BRANCH TABLE ROUTES CONTROL TO THE PROPER FORMAT *
* ROUTINE.                                                            *
***********************************************************************
         SPACE
OPBRANCH EQU   *
         LA    R2,SEVEN(R2)            R2=UPDATED OUTPUT POINTER.
         SR    R4,R4                   R4=ZERO.
         IC    R4,ZERO(R8,R6)          R4=INDEX VALUE TO ROUTINE.
         B     INSTBRTB(R4)            BRANCH TO REQUIRED ROUTINE.
         SPACE
* THE FOLLOWING TABLE ROUTES CONTROL TO THE PROPER FORMAT ROUTINE.    *
         SPACE
INSTBRTB EQU   *
         B     NOOPCODE                THE OP CODE IS INVALID,ERROR MSG
         B     OPRR                    OP=RR FORMAT.
         B     OPRR                    OP=RR FORMAT WITH 1 REGISTER.
         B     OPRS                    OP=RS FORMAT.
         B     OPRS                    OP=RS FORMAT ONE REGISTER.
         B     OPSVC                   OP=SVC.
         B     OPSI                    OP=SI FORMAT.
         B     OPSI                    OP=SI WITHOUT THE IMMEDIATE.
         B     OPSS                    OP=SS WITH ONE LENGTH.
         B     OPSS                    OP=SS WITH TWO LENGTH.
         B     OPRX                    OP=RX FORMAT.
         SPACE
***********************************************************************
* THE FOLLOWING INSTRUCTIONS CONVERTS AND FORMAT THE RR INSTRUCTIONS  *
* WITH BOTH OPERANDS IN THE OPERAND FIELD.                            *
***********************************************************************
         SPACE
OPRR     EQU   *
         LA    R8,ELEVEN               R8=LENGTH OF OUTPUT
         LA    R7,TWO                  R7=2.
         LA    R5,OPRRVAL              R5=HEX 4.
         CR    R4,R5                   Q.RR FORMAT WITH ONE REGISTER.
         BE    OP1R                    NO,SKIP 1 REGISTER SWITCH SET.
         LA    R7,ONE                  SET ONE REGISTER SWITCH.
         LA    R8,EIGHT                SET LENGTH FOR ONE REGISTER.
OP1R     EQU   *
         IC    R4,ONE(R3)              R4=OPERANDS R1 AND R2.
         SRDL  R4,EIGHT                R5=R1 AND R2 IN HIGH ORDER BYTE.
         L     R6,WORKAREA             R6=ADDRESS OF WORKAREA.
GET1OR2  EQU   *
         SR    R4,R4                   R4=0.
         SLDL  R4,FOUR                 ISOLATE NEXT 4 BITS OP OPERAND
         CVD   R4,ZERO(R6)             REGISTER NOW DECIMAL.
         OI    SEVEN(R6),SIGNF         SIGN NOW HEX F.
         UNPK  ZERO(THREE,R6),SIX(TWO,R6) R1 NOW ZONED DECIMAL.
         CLI   ONE(R6),F0              Q.IS REGISTER 1 OR 2 DIGITS.
         BNE   TWODIGIT                REGISTER IS TWO DIGITS.
         BCTR  R8,ZERO                 R8=CORRECTED LENGTH.
         MVC   ZERO(ONE,R2),TWO(R6)    REGISTER NOW IN OUTPUT AREA.
         LA    R2,ONE(R2)              UPDATE OUTPUT POINTER.
GETCOMMA EQU   *
         MVI   ZERO(R2),COMMA          SEPERATE OPERANDS.
         LA    R2,ONE(R2)              UPDATE OUTPUT POINTER.
         BCT   R7,GET1OR2              Q.IS R2 COMPLETED.
         L     R2,CONAREA              YES,FIND LENGTH AREA.
         STC   R8,ZERO(R2)             LENGTH NOW IN CONAREA.
         SR    R15,R15                 RC=0.
         BR    R14                     RETURN
TWODIGIT EQU   *
         MVC   ZERO(TWO,R2),ONE(R6)    REGISTER NOW IN OUTPUT AREA.
         LA    R2,TWO(R2)              UPDATE OUTPUT POINTER.
         B     GETCOMMA                GET A COMMA.
         SPACE
***********************************************************************
* THE FOLLOWING INSTRUCTIONS CONVERT AND FORMAT THE RS INSTRUCTION    *
* TYPE R1 AND R3 OPERAND FIELD.                                       *
***********************************************************************
         SPACE
OPRS     EQU   *
         LA    R8,SIX                  R8=LENG OF MNEMONIC AND A BLANK.
         LA    R7,TWO                  R7=2.
         LA    R5,OPRSVAL              R5=HEX 0C.
         CR    R4,R5                   Q.FORMAT 1 OR 2 REGISTERS.
         BE    RS2R                    2 REGISTERS,SKIP 1 SET.
         LA    R7,ONE                  R7=1.
RS2R     EQU   *
         IC    R4,ONE(R3)              R4=OPERANDS R1 AND R2.
         SRDL  R4,EIGHT                R5=R1 AND R3 IN HI ORDER BYTE.
         L     R6,WORKAREA             R6=ADDRESS OF WORKAREA.
         USING CVTWORK,R6              USE R6 TO ADRESS WORKAREA.
GET1OR3  EQU   *
         SR    R4,R4                   R4=0.
         SLDL  R4,FOUR                 ISOLATE NEXT 4 BITS.
         CVD   R4,ZERO(R6)             REGISTER NOW DECIMAL.
         OI    SEVEN(R6),SIGNF         SIGN NOW HEX F.
         UNPK  ZERO(THREE,R6),SIX(TWO,R6) R1 NOW ZONED DECIMAL.
         CLI   ONE(R6),F0              Q.IS REGISTER 1 OR 2 DIGITS.
         BNE   TWOVAL                  R IS TWO DIGITS.
         LA    R8,ONE(R8)              R8=LENGTH PLUS 1.
         MVC   ZERO(ONE,R2),TWO(R6)    REGISTER NOW IN OUTPUT AREA.
         LA    R2,ONE(R2)              UPDATE OUTPUT AREA.
PUTCOMMA EQU   *
         MVI   ZERO(R2),COMMA          SEPERATE OPERANDS.
         LA    R2,ONE(R2)              UPDATE OUTPUT POINTER.
         LA    R8,ONE(R8)              R8=LENGTH PLUS 1.
         BCT   R7,GET1OR3              Q.IS REG COMPLETED.
         SPACE
***********************************************************************
* THE FOLLOWING LINES OF CODE CONVERTS THE STORAGE OPERAND OF THE RS  *
* INSTRUCTION FORMAT.                                                 *
***********************************************************************
         SPACE
         MVC   ZERO(TWO,R6),TWO(R3)    INPUT NOW IN WORKAREA.
         SR    R4,R4                   R4=0.
         L     R5,ZERO(R6)             R5=STORAGE OPERAND
         SLDL  R4,FOUR                 R4=BASE REGISTER.
         SRL   R5,TWO0                 R5=DISPLACEMENT
         CVD   R5,ZERO(R6)             DISP NOW PACKED DECIMAL.
         MVC   EIGHT(SIX,R6),PATTERN2  MOVE PATTERN INTO WORKAREA.
         OI    SEVEN(R6),SIGNF         SIGN NOW HEX F.
         LA    R1,ONE3(R6)             R1=ADDR OF LAST BYTE.
         EDMK  EIGHT(SIX,R6),FIVE(R6)  DISP NOW ZONED DECIMAL.
         LA    R7,ONE4(R6)             R7=END OF ZONED DECIMAL.
         SR    R7,R1                   R7=LENGTH OF ZONED DECIMAL.
         LA    R8,ZERO(R7,R8)          R8=LENGTH PLUS DISP LENGTH.
         BCTR  R7,ZERO                 R6=EXECUTE LENGTH.
         EX    R7,DISPMOVE             MOVE DISP TO CONAREA.
         LA    R2,ONE(R7,R2)           UPDATE OUTPUT POINTER.
         MVI   ZERO(R2),OPEN           MOVE IN OPEN PARENTHESIS.
         SPACE
***********************************************************************
* THIS SECTION OF CODE CONVERT THE BASE REGISTER OF THE STORAGE       *
* OPERAND AND MOVE IT INTO THE OUTPUT AREA.                           *
***********************************************************************
         SPACE
         CVD   R4,ZERO(R6)             REGISTER NOW PACKED DECIMAL.
         OI    SEVEN(R6),SIGNF         SIGN NOW HEX F.
         UNPK  ZERO(THREE,R6),SIX(TWO,R6) BASE NOW ZONED DECIMAL.
         CLI   ONE(R6),F0              Q.BASE 1 OR 2 DIGITS.
         BNE   TWOBASE                 BASE IS TWO DIGITS.
         LA    R8,ONE(R8)              R8=LENGTH NOW INCLUDES BASE.
         MVC   ONE(ONE,R2),TWO(R6)     BASE NOW IN OUTPUT AREA.
         LA    R2,TWO(R2)              UPDATE OUTPUT POINTER
ENDBASE  EQU   *
         MVI   ZERO(R2),CLOSE          MOVE IN A CLOSE PARENTHESIS.
         LA    R8,TWO(R8)              R8=LENGTH PLUS 2.
         L     R2,CONAREA              R2=OUTPUT AREA ADDRESS.
         STC   R8,ZERO(R2)             LENGTH NOW IN CONAREA.
         SR    R15,R15                 RC=0.
         BR    R14                     RETURN.
         DROP  R6                      DROP ADRESSABILITY TO WORKAREA
DISPMOVE MVC   ZERO(ONE,R2),ZERO(R1)   MOVE DISP INTO CONAREA.
TWOBASE  EQU   *
         LA    R8,TWO(R8)              INCREMENT LENGTH FOR 2 DIGITS.
         MVC   ONE(TWO,R2),ONE(R6)     BASE NOW IN OUTPUT AREA.
         LA    R2,THREE(R2)            UPDATE OUTPUT POINTER.
         B     ENDBASE                 GET CLOSE PARENTHESIS.
TWOVAL   EQU   *
         LA    R8,TWO(R8)              R8=LENGTH PLUS 2.
         MVC   ZERO(TWO,R2),ONE(R6)    R NOW IN OUTPUT AREA.
         LA    R2,TWO(R2)              UPDATE OUTPUT POINTER.
         B     PUTCOMMA                GET COMMA.
         SPACE
***********************************************************************
* THE FOLLOWING INSTRUCTIONS CONVERTS A SVC INSTRUCTION TO ITS        *
* PRINTABLE FORMAT.                                                   *
***********************************************************************
         SPACE
OPSVC    EQU   *
         SR    R4,R4                   R4=0.
         IC    R4,ONE(R3)              R4=IMMEDIATE FIELD.
         L     R6,WORKAREA             R6=ADDRESS OF WORKAREA.
         CVD   R4,ZERO(R6)             I FIELD NOW PACKED DECIMAL.
         OI    SEVEN(R6),SIGNF         SIGN NOW HEX F.
         LA    R1,ONE3(R6)             R1=ADDR OF LAST BYTE.
         MVC   EIGHT(SEVEN,R6),PATTERN2  MOVE IN PATTERN.
         EDMK  EIGHT(SIX,R6),FIVE(R6)  I FIELD NOW ZONED DECIMAL.
         LA    R7,ONE4(R6)             R7=END OF ZONED DECIMAL.
         SR    R7,R1                   R7=LENGTH OF SIGNIFICANT DIGITS.
         LA    R8,SIX(R7)              R8=LENGTH OF OUTPUT.
         BCTR  R7,ZERO                 R7=EXECTUE LENGTH.
         EX    R7,SVCMOVE              MOVE I FIELD INTO CONAREA.
         L     R2,CONAREA              R2=CONAREA ADDRESS.
         STC   R8,ZERO(R2)             LENGTH NOW IN CONAREA.
         SR    R15,R15                 RC=0.
         BR    R14                     RETURN TO CALLER.
SVCMOVE  MVC   ZERO(ONE,R2),ZERO(R1)   MOVE I FIELD INTO CONAREA.
         SPACE
***********************************************************************
* THE FOLLOWING INSTRUCTIONS CONVERTS A SI INSTRUCTION TO PRINTABLE   *
* CHARACTERS AND FORMAT IT IN ITS MACHINE INSTRUCTION FORMAT.         *
***********************************************************************
         SPACE
OPSI     EQU   *
         LR    R0,R4                   SAVE INDEX VALUE
         L     R6,WORKAREA             R6=ADDRESS OF WORKAREA.
         USING CVTWORK,R6              USE R6 TO ADDRESS WORKAREA
         MVC   ZERO(TWO,R6),TWO(R3)    STORAGE OPERAND NOW IN WORKAREA.
         SR    R4,R4                   R4=0.
         L     R5,ZERO(R6)             R5=STORAGE OPERAND.
         SLDL  R4,FOUR                 R4=BASE REGISTER.
         SRL   R5,TWO0                 R5=DISPLACEMENT.
         CVD   R5,ZERO(R6)             DISP NOW PACKED DECIMAL.
         MVC   EIGHT(SIX,R6),PATTERN2  MOVE PATTERN INTO WORKAREA.
         OI    SEVEN(R6),SIGNF         SIGN NOW HEX F.
         LA    R1,ONE3(R6)             R1=ADDR OF LAST BYTE.
         EDMK  EIGHT(SIX,R6),FIVE(R6)  DISP NOW ZONED DECIMAL.
         LA    R7,ONE4(R6)             R7=END OF ZONED DECIMAL.
         SR    R7,R1                   R7=LENGTH OF ZONED DECIMAL.
         LA    R8,SIX(R7)              R8=LENGTH PLUS DISP.
         BCTR  R7,ZERO                 R7=EXECUTE LENGTH.
         EX    R7,DISPMOVE             MOVE DISP TO CONAREA
         LA    R2,ONE(R7,R2)           UPDATE OUTPUT POINTER.
         MVI   ZERO(R2),OPEN           MOVE OPEN PARENTHESIS TO CONAREA
         SPACE
***********************************************************************
* THIS SECTION OF CODE CONVERT THE BASE REGISTER OF THE STORAGE       *
* OPERAND AND MOVE IT INTO THE OUTPUT AREA.                           *
***********************************************************************
         SPACE
         CVD   R4,ZERO(R6)             REGISTER NOW PACKED DECIMAL.
         OI    SEVEN(R6),SIGNF         SIGN HEX F.
         UNPK  ZERO(THREE,R6),SIX(TWO,R6) BASE NOW ZONED DECIMAL.
         CLI   ONE(R6),F0              Q.BASE 1 OR 2 DIGITS.
         BNE   SIBASE2                 BASE IS TWO DIGITS.
         LA    R8,ONE(R8)              R8=LENGTH NOW INCLUDES BASE.
         MVC   ONE(ONE,R2),TWO(R6)     BASE NOW IN OUTPUT AREA.
         LA    R2,TWO(R2)              UPDATE OUTPUT POINTER.
ENDISP   EQU   *
         MVI   ZERO(R2),CLOSE          MOVE IN A CLOSE PARENTHESIS.
         LA    R8,TWO(R8)              R8=LENGTH + 2.
         SPACE
* CHECK TO DETERMINE IF A SCON IS BEING CONVERTED TO PRINTABLE.       *
         SPACE
         LTR   R0,R0                   Q.SCON PROCESSING.
         BZ    SCON                    YES,FINISH SCON CONVERSION.
* CHECK TO DETERMINE IF THE FORMAT REQUESTED IS WITH OR WITHOUT AN    *
* IMMEDIATE FIELD.                                                    *
         SPACE
         LA    R1,OPSIVAL              R1='14'.
         CLR   R1,R0                   Q.IMMEDIATE FIELD REQUESTED.
         BNE   IMMED                   YES,GET IMMEDIATE FIELD.
         B     ENDOPSI                 END FORMAT AND RETURN.
         DROP  R6                      DROP ADDRESSABILITY TO WORKAREA
         SPACE
***********************************************************************
* THE FOLLOWING INSTRUCTIONS CONVERT THE IMMEDIATE FIELD TO PRINTABLE *
* CHARACTERS AND MOVE THEM TO THE OUTPUT AREA.                        *
***********************************************************************
         SPACE
IMMED    EQU   *
         LA    R1,TWO
         SR    R4,R4                   R4=0
         IC    R4,ONE(R3)              R4=IMMEDIATE FIELD.
         SRDL  R4,FOUR                 ISOLATE FIRST 4 BITS.
         LA    R7,NINE                 R7=9.
NEXT4I   EQU   *
         CLR   R4,R7                   Q-4 BITS GT 9.
         BH    SIHI                    YES,CONVERT TO ALPHABETIC.
         LA    R4,F0(R4)               R4=4 BIT NOW PRINTABLE.
MOVEI    STC   R4,ZERO(R6)             MOVE BYTE INTO WORKAREA.
         LA    R6,ONE(R6)              R6=ADDR ONE PASS WORKAREA.
         SR    R4,R4                   CLEAR REG4.
         SLDL  R4,FOUR                 ISOLATE NEXT FOUR BITS.
         BCT   R1,NEXT4I               IF R1=0,CONTINUE,ELSE CVT NEXT 4
         MVC   ONE(SIX,R2),HEXI        MOVE INTO CONAREA THE I PATTERN.
         L     R6,WORKAREA             R6=ADDRESS OF WORKAREA.
         MVC   FOUR(TWO,R2),ZERO(R6)   MOVE IMMEDIATE DATA INTO CONAREA
         LA    R8,SIX(R8)              LENGTH NOW=OUTPUT LENGTH.
         B     ENDOPSI                 GO SET RETURN CODE.
SIBASE2  EQU   *
         LA    R8,TWO(R8)              R8=LENGTH + 2 FOR 2 BASE DIGITS.
         MVC   ONE(TWO,R2),ONE(R6)     BASE NOW IN OUTPUT AREA.
         LA    R2,THREE(R2)            UPDATE OUTPUT POINTER.
         B     ENDISP                  GET CLOSE PARENTHESIS.
* MOVE LENGTH INTO CONAREA,GET RETURN CODE=O AND RETURN TO CALLER.    *
ENDOPSI  EQU   *
         L     R2,CONAREA              R2=ADDRESS OF CONAREA.
         STC   R8,ZERO(R2)             LENGTH NOW IN CONAREA.
         SR    R15,R15                 RC=0.
         BR    R14                     RETURN TO CALLER.
* CONVERT THE ALPHABETIC HEX VALUES TO PRINTABLE CHARACTERS.          *
SIHI     EQU   *
         LA    R4,B7(R4)               R4=4 BITS NOW PRINTABLE.
         B     MOVEI                   GET IMMEDIATE FIELD.
         SPACE
***********************************************************************
* THE FOLLOWING INSTRUCTIONS CONVERTS THE STORAGE OPERANDS OF THE     *
* SS INSTRUCTION TO ITS PRINTABLE FORM.                               *
***********************************************************************
         SPACE
OPSS     EQU   *
         LR    R0,R4                   SAVE INDEX FACTOR.
         LA    R8,SIX                  R8=LENGTH OF MNEMONIC + 0.
         LA    R10,TWO                 R10=2.
         L     R6,WORKAREA             R6=ADDRESS OF THE WORKAREA AREA.
         USING CVTWORK,R6              USE R6 TO ADDRESS WORKAREA
         CLI   ZERO(R3),SRPOP          Q.IS OP CODE SRP.
         BNE   GETB2D2                 NO,GET B1D1.
         OI    CODE370,SSIMM           YES,TURN ON SS,L1,I3 FLAG.
GETB2D2  EQU   *
         MVC   ZERO(TWO,R6),TWO(R3)    MOVE STORAGE OPERAND TO WORKAREA
         L     R4,ZERO(R6)             R0=STORAGE OPERANDS.
         SRL   R4,ONE6                 ISOLATE FIRST OPERAND.
         SRDL  R4,ONE2                 R4=BASE REGISTER.
         SRL   R5,TWO0                 R5=DISPLACEMENT.
         CVD   R5,ZERO(R6)             DISP NOW PACKED DECIMAL.
         MVC   EIGHT(SIX,R6),PATTERN2  MOVE PATTERN INTO WORKAREA.
         OI    SEVEN(R6),SIGNF         SIGN NOW X'F'.
         LA    R1,ONE3(R6)             R1=ADDR OF LAST BYTE.
         EDMK  EIGHT(SIX,R6),FIVE(R6)  DISP NOW ZONED DECIMAL.
         LA    R7,ONE4(R6)             R7=END OF ZONED DECIMAL.
         SR    R7,R1                   LENGTH OF DISP.
         LA    R8,ONE(R7,R8)           R8=NEW LENGTH.
         BCTR  R7,ZERO                 R7=EXECUTE LENGTH.
         EX    R7,DISPMOVE             MOVE DISP TO CONAREA.
         LA    R2,ONE(R7,R2)           UPDATE OUTPUT POINTER.
         MVI   ZERO(R2),OPEN           MOVE IN OPEN PARENTHESIS.
         LA    R2,ONE(R2)              UPDATE OUTPUT POINTER.
         LA    R7,ONE                  R7=1.
         CLR   R10,R7                  Q.IS THIS THE CVT FOR B2D2
         BE    CVTB2D2                 YES,CONVERT B2D2.
         SR    R4,R4                   R4=0.
         IC    R4,ONE(R3)              R4=LENGTH FIELD OF THE INST.
         LA    R7,OPSSVAL              R7=TYPE FORMAT INDICATOR.
         CLR   R7,R0                   Q.IS LENGTH L1 & L2.
         BNE   SSL2                    YES,IS L1 & L2.
         TM    CODE370,SSIMM           NO.Q.IS IT L1 & I3.
         BNO   SSL1                    NO,ONLY L1.
         SPACE
* CONVERT LENGTH FIELD TO REFLECT A L1 & L2 LENGTH FIELD.             *
         SPACE
SSL2     EQU   *
         SRDL  R4,FOUR                 R4=L1.
SSL1     EQU   *
         LA    R4,ONE(R4)              R4=CORRECT LENGTH TO BE CONVERT.
         CVD   R4,ZERO(R6)             LENGTH NOW PACKED DECIMAL.
         MVC   EIGHT(FOUR,R6),PATTERN2 LENGTH NOW ZONED DECIMAL.
         OI    SEVEN(R6),SIGNF         SIGN NOW X'F'.
         EDMK  EIGHT(FOUR,R6),SIX(R6)  LENGTH NOW ZONED DECIMAL.
         LA    R7,ONE2(R6)             R7=END OF ZONED DECIMAL.
         SR    R7,R1                   R7=LENGTH OF LENGTH.
         LA    R8,ZERO(R7,R8)          R8=UPDATED LENGTH.
         BCTR  R7,ZERO                 R7=EXECUTE LENGTH.
         EX    R7,DISPMOVE             MOVE LENGTH INTO CONAREA.
         LA    R2,ONE(R7,R2)           UPDATE OUTPUT POINTER.
         MVI   ZERO(R2),COMMA          SEPERATE LENGTH & BASE.
         LA    R8,ONE(R8)              UPDATE OUTPUT COUNTER.
         LA    R2,ONE(R2)              UPDATE OUTPUT POINTER.
NOLENGTH EQU   *
         SR    R4,R4                   R4=0.
         IC    R4,TWO(R3)              R4=BASE + GARBAGE.
         SRL   R4,FOUR                 ISOLATE BASE.
         CVD   R4,ZERO(R6)             REGISTER NOW DECIMAL.
         OI    SEVEN(R6),SIGNF         SIGN NOW X'F'.
         UNPK  ZERO(THREE,R6),SIX(TWO,R6) BASE NOW ZONED DECIMAL.
         CLI   ONE(R6),F0              Q.IS BASE 1 OR 2 DIGITS.
         BNE   SSBASE2                 BASE IS 2 DIGITS.
         LA    R8,ONE(R8)              R8=LENGTH + NEXT OPERAND FIELD.
         MVC   ZERO(ONE,R2),TWO(R6)    REGISTER NOW IN OUTPUT AREA.
         LA    R2,ONE(R2)              UPDATE OUTPUT POINTER.
SSCOMMA  EQU   *
         MVI   ZERO(R2),CLOSE          MOVE IN CLOSE PARENTHESIS.
         MVI   ONE(R2),COMMA           SEPERATE OPERANDS.
         LA    R2,TWO(R2)              UPDATE OUTPUT POINTER.
         LA    R8,TWO(R8)              UPDATE OUTPUT COUNTER.
         LA    R3,TWO(R3)              R3=ADDR OF B1D1.
         BCT   R10,GETB2D2             IF BEDE IS COMPLETED RETURN.
         BCTR  R8,ZERO                 R8=CORRECT LENGTH.
         TM    CODE370,SSIMM           Q.IS IT SS,L1 & I3.
         BNO   SSRETURN                NO.FINISH UP AND RETURN.
         LA    R8,ONE(R8)              UPDATE OUTPUT CTR FOR COMMA.
         S     R3,THREEWD              R3=INPUT POINTER TO L1 & I3.
         SR    R4,R4                   CLEAR R4.
         IC    R4,ZERO(R3)             R4= L1 & I3 IN BINARY.
         SLL   R4,TWO8                 CLEAR OUT L1.
         SRL   R4,TWO8                 ISOLATE I3.
         CVD   R4,ZERO(R6)             I3 NOW DECIMAL.
         UNPK  ZERO(THREE,R6),SIX(TWO,R6) I3 NOW ZONED DECIMAL.
         OI    TWO(R6),HEXF0           SIGN NOW HEX F.
         CLI   ONE(R6),F0              Q.IS I3 1 OR 2 DIGITS.
         BNE   ITWODIG                 I3 IS 2 DIGITS.
         LA    R8,ONE(R8)              UPDATE OUTPUT LENGTH 1 DIGIT.
         MVC   ZERO(ONE,R2),TWO(R6)    I3 NOW IN OUTPUT AREA.
         B     SSRETURN                FINISH UP AND RETURN.
ITWODIG  EQU   *
         LA    R8,TWO(R8)              UPDATE OUTPUT PTR 2 DIGITS.
         MVC   ZERO(TWO,R2),ONE(R6)    I3 NOW IN OUTPUT AREA.
SSRETURN EQU   *
         L     R2,CONAREA              R2=ADDR OF OUTPUTAREA.
         STC   R8,ZERO(R2)             LENGTH NOW IN OUTPUT AREA.
         SR    R15,R15                 RC=0.
         BR    R14                     RETURN TO CALLER.
CVTB2D2  EQU   *
         LA    R7,OPSSVAL              R7=X'00'.
         CR    R0,R7                   Q.IS LENGTH L1 OR L1 AND L2.
         BE    NOLENGTH                LENGTH IS L1 ONLY.
         SR    R4,R4                   R4=0.
         BCTR  R3,ZERO                 R3=PTR TO LENGTH FIELD.
         IC    R4,ZERO(R3)             R4=LENGTH FIELD.
         SLL   R4,TWO8                 CLEAR OUT L1.
         SRL   R4,TWO8                 ISOLATE L2.
         LA    R3,ONE(R3)              ADVANCE INPUT POINTER.
         B     SSL1                    CONVERT L2.
SSBASE2  EQU   *
         MVC   ZERO(TWO,R2),ONE(R6)    REGISTER NOW IN OUTPUT AREA.
         LA    R2,TWO(R2)              R2=UPDATED OUTPUT PTR.
         LA    R8,TWO(R8)              UPDATE LENGTH COUNTER.
         B     SSCOMMA                 MOVE IN A COMMA.
OPRX     EQU   *
         DROP  R6                      DROP ADDRESSABILITY TO WORKAREA
         SPACE
***********************************************************************
* THE FOLLOWING INSTRUCTIONS CONVERTS AND FORMATS THE RX INSTRUCTIONS *
***********************************************************************
         SPACE
         LA    R8,SIX                  R8=LENGTH OF MNEMONIC + A BLANK.
         SR    R0,R0                   R8=LENGTH OF MNEMONIC+A BLANK.
         LA    R7,ONE                  R7=ONE.
         IC    R4,ONE(R3)              R4=R1 & X2 FIELDS.
         SRDL  R4,EIGHT                R5=R1&X2 IN HIGH ORDER BYTE.
         L     R6,WORKAREA             R6=ADDR OF WORKAREA.
B2ORX2   EQU   *
         SR    R4,R4                   R4=0.
         SLDL  R4,FOUR                 ISOLATE NEXT 4 BITS OF OPERAND.
         CVD   R4,ZERO(R6)             REGISTER NOW DECIMAL.
         OI    SEVEN(R6),SIGNF         SIGN NOW X'F'.
         UNPK  ZERO(THREE,R6),SIX(TWO,R6) R1 NOW ZONED DECIMAL.
         CLI   ONE(R6),F0              Q.IS REGISTER 1 OR 2 DIGITS.
         BNE   TWOCHAR                 REGISTER IS 2 CHARACTERS.
         LA    R8,ONE(R8)              R8=LENGTH + NEXT OPERAND FIELD.
         MVC   ZERO(ONE,R2),TWO(R6)    REGISTER NOW IN OUTPUT AREA.
         LA    R2,ONE(R2)              UPDATE OUTPUT POINTER.
COMMAGET EQU   *
         MVI   ZERO(R2),COMMA          SEPERATE OPERAND FIELDS.
         LA    R2,ONE(R2)              UPDATE OUTPUT POINTER.
         LA    R8,ONE(R8)              R8=LENGTH OF OUTPUT SO FAR.
         BCT   R7,B2ORX2               IF 7=2 CONBERT B2.
         LTR   R0,R0                   Q.B2 FIELD COMPLETED.
         BNZ   CLOSERX                 YES,CLOSE RX ROUTINE.
         LH    R4,BASEDISP(R3)         R4=BASE + DISP.
         SLL   R4,TWO0                 DROP BASE REG.
         SRL   R4,TWO0                 ISOLATE DISP.
         CVD   R4,ZERO(R6)             DISP NOW PACKED DECIMAL.
         MVC   EIGHT(SIX,R6),PATTERN2  MOVE PATTERN INTO WORKAREA.
         OI    SEVEN(R6),SIGNF         SIGN NOW X'F'.
         LA    R1,ONE3(R6)             R1=ADDR OF LAST BYTE.
         EDMK  EIGHT(SIX,R6),FIVE(R6)  DISP NOW ZONED DECIMAL.
         LA    R7,ONE4(R6)             R7=END OF ZONED DECIMAL.
         SR    R7,R1                   R7=LENGTH OF ZONED DECIMAL.
         LA    R8,ONE(R7,R8)           R8=LENGTH + DISP LENGTH.
         BCTR  R7,ZERO                 R7=EXECUTE LENGTH.
         EX    R7,DISPMOVE             MOVE DISP TO CONAREA.
         LA    R2,ONE(R7,R2)           UPDATE OUTPUT POINTER.
         MVI   ZERO(R2),OPEN           MOVE IN C'('.
         LA    R2,ONE(R2)              UPDATE OUTPUT PTR.
*        CONVERT AND FORMAT THE INDEX AND BASE REGISTER               *
         SR    R10,R10                 R10=0.
         LA    R7,TWO                  R7=2.
         IC    R10,BASEDISP(R3)        R6=BASE + DISP.
         SLL   R10,TWO0                MOVE BASE TO HI ORDER.
         OR    R5,R10                  R5=X2 AND B2.
         LA    R0,ONE                  R0=1,INDICATES DISP COMPLETED.
         B     B2ORX2                  FORMAT X2 & BE FIELD.
CLOSERX  EQU   *
         BCTR  R2,ZERO                 R2=PTR TO PARENTHESIS FIELD.
         MVI   ZERO(R2),CLOSE          MOVE CLOSE PARENTHESIS IN.
         L     R2,CONAREA              R2=ADDR OF OUTPUT AREA.
         STC   R8,ZERO(R2)             LENGTH OF OUTPUT NOW IN CONAREA.
         SR    R15,R15                 RETURN CODE =0.
         BR    R14                     RETURN
TWOCHAR  EQU   *
         MVC   ZERO(TWO,R2),ONE(R6)    REGISTER NOW IN OUTPUT AREA.
         LA    R2,TWO(R2)              UPDATE OUTPUT POINTER.
         LA    R8,TWO(R8)              R8=LENGTH + NEXT OPERAND FIELD.
         B     COMMAGET                GO MOVE IN COMMA.
***********************************************************************
* THIS SECTION OF CODE CONVERTS BINARY INPUT TO ITS PRINTABLE SCON    *
* FORMAT (DISP(BASE)).                                                *
***********************************************************************
IKJEGBIS EQU   *
         DROP  R12                     GET NEW BASE REGISTER.
         USING *,R15                   R15 IS NEW BASE REGISTER.
         L     R12,BASECON             R12=ADDRESS OF IKJEGCV2.
         DROP  R15                     GET NEW BASE REGISTER.
         USING IKJEGCVX,R12            IKJEGCVX ADDRESSABILITY.
         USING TCOMTAB,R9              TCOMTAB ADDRESSABILITY.
         SR    R4,R4                   R4=0.
         L     R3,ZERO(R1)             R3=ADDR OF INPUT STRING.
         L     R2,CONAREA              R2=ADDR OF OUTPUT AREA.
         LA    R2,ONE(R2)              R2=ADDR ONE PASS LENGTH BYTE.
         BCTR  R3,ZERO                 R3=INPUT PTR-1.
         BCTR  R3,ZERO                 R3=INPUT PTR-2.
         B     OPSI                    CONVERT DISP(BASE).
SCON     EQU   *
         LA    R5,SIX                  R5=6.
         SR    R8,R5                   R8=SCON LENGTH.
         L     R2,CONAREA              R2=ADDR OF CONAREA.
         STC   R8,ZERO(R2)             MOVE LENGTH INTO CONAREA.
         SR    R15,R15                 R15=0.
         BR    R14                     RETURN TO CALLER.
BASECON  DC    A(IKJEGCVX)             ADDR OF IKJEGCVX.
NOOPCODE EQU   *
         LA    R15,FOUR                RC=4.
         BR    R14                     RETURN.
         DS    0F
HEXI     DC    C',X''  '''             IMMEDIATE PATTERN.
PATTERN2 DC    X'40'                   ********************************
         DC    3X'20'                  * PATTERN FIELD FOR THE EDIT   *
         DC    X'21'                   * AND MARK INSTRUCTION.        *
         DC    5X'20'                  ********************************
BLANKS   DC    C'  '                   STRING OF TWO BLANKS
THREEWD  DC    F'3'                    THREE
         EJECT
         TITLE 'IKJEGCVT PRINTABLE OPCODES TABLE.'
***********************************************************************
* THIS CSECT CONTAINS THE TABLE PRINTABLE OPCODES WITH THEIR          *
* RESPECTIVE INSTRUCTION FORMAT CODES.                                *
***********************************************************************
         SPACE
IKJEGCOP  CSECT
         DC    4XL5'00'                CODE=00,INVALID OP CODE.
         DC    C'SPM '                 SPM OP CODE.
         DC    X'08'                   CODE=08,RR FORMAT-1 OPERAND.
         DC    C'BALR'                 BALR OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'BCTR'                 BCTR OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'BCR '                 BCR OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'SSK '                 SSK OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'ISK '                 ISK OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'SVC '                 SVC INSTRUCTION.
         DC    X'14'                   CODE=10,RR FORMAT-1 OPERAND.
         DC    2XL5'00'                CODE=00,INVALID OP CODE.
         DC    C'BASR'                 BASR OP CODE.  370 R.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'MVCL'                 MVCL OP CODE.  370.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'CLCL'                 CLCL OP CODE.  370.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'LPR '                 LPR OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'LNR '                 LNR OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'LTR '                 LTR OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'LCR '                 LCR OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'NR  '                 NR OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'CLR '                 CLR OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'OR  '                 OR OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'XR  '                 XR OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'LR  '                 LR OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'CR  '                 CR OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'AR  '                 AR OP CODE.
         DC    X'04'                   CODEV04,RR FORMAT-2 OPERANDS.
         DC    C'SR  '                 SR OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'MR  '                 MR OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'DR  '                 DR OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'ALR '                 ALR OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'SLR '                 SLR OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'LPDR'                 LPDR OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'LNDR'                 LNDR OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'LTDR'                 LTDR OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'LCDR'                 LCDR OF CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'HDR '                 HDR OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'LRDR'                 LRDR OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'MXR '                 MXR OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'MXDR'                 MXDR OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'LDR '                 LDR OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'CDR '                 CDR OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'ADR '                 ADR OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'SDR '                 SDR OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERADS.
         DC    C'MDR '                 MDR OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'DDR '                 DDR OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'AWR '                 AWR OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'SWR '                 SWR OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'LPER'                 LPER OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'LNER'                 LNER OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'LTER'                 LTER OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'LCER'                 LCER OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'HER '                 HER OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'LRER'                 LRER OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'AXR '                 AXR OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'SXR '                 SXR OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'LER '                 LER OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'CER '                 CER OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'AER '                 AER OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'SER '                 SER OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'MER '                 MER OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'DER '                 DER OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'AUR '                 AUR OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'SUR '                 SUR OP CODE.
         DC    X'04'                   CODE=04,RR FORMAT-2 OPERANDS.
         DC    C'STH '                 STH OP CODE.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    C'LA  '                 LA OP CODE.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    C'STC '                 STC OP CODE.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    C'IC  '                 IC  OP CODE.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    C'EX  '                 EX OP CODE.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    C'BAL '                 BAL OP CODE.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    C'BCT '                 BCT OP CODE.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    C'BC  '                 BC OP CODE.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    C'LH  '                 LH OP CODE.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    C'CH  '                 CH OP CODE.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    C'AH  '                 AH OP CODE.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    C'SH  '                 SH OP CODE.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    C'MH  '                 MH OP CODE.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    C'BAS '                 BAS OP CODE. 370 R.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    C'CVD '                 CVD OP CODE.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    C'CVB '                 CVB OP CODE
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    C'ST  '                 ST OP CODE.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    3XL5'00'                CODE=00,INVALID OP CODE.
         DC    C'N   '                 N OP CODE.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    C'CL  '                 CL OP CODE.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    C'O   '                 O OP CODE.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    C'X   '                 X OP CODE.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    C'L   '                 L OP CODE
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    C'C   '                 C OP CODE.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    C'A   '                 A OP CODE.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    C'S   '                 S OP CODE.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    C'M   '                 M OP CODE.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    C'D   '                 D OP CODE.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    C'AL  '                 AL OP CODE.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    C'SL  '                 SL OP CODE.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    C'STD '                 STD OP CODE.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    6XL5'00'                CODE=00,INVALID OP CODE.
         DC    C'MXD '                 MXD OP CODE.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    C'LD  '                 LD OP CODE.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    C'CD  '                 CD OP CODE.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    C'AD  '                 AD OP CODE.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    C'SD  '                 SD OP CODE.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    C'MD  '                 MD OP CODE.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    C'DD  '                 DD OP CODE.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    C'AW  '                 AW OP CODE.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    C'SW  '                 SW OP CODE.
         DC    X'28'                   CODE=28,RX OP CODE.
         DC    C'STE '                 STE OP CODE.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    7XL5'00'                CODE=00,INVALID OP CODE.
         DC    C'LE  '                 LE OP CODE.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    C'CE  '                 CE OP CODE.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    C'AE  '                 AE OP CODE.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    C'SE  '                 SE OP CODE.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    C'ME  '                 ME OP CODE.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    C'DE  '                 DE OP CODE.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    C'AU  '                 AU OP CODE.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    C'SU  '                 SU OP CODE.
         DC    X'28'                   CODE=28,RX FORMAT.
         DC    C'SSM '                 SSM OP CODE.
         DC    X'1C'                   CODE=1C,SI FORMAT WITHOUT THE I.
         DC    XL5'00'                 CODE=00 INVALID OP CODE.
         DC    C'LPSW'                 LPSW OP CODE.
         DC    X'1C'                   CODE=1C,SI FORMAT WITHOUT THE I.
         DC    C'DIAG'                 DIAGNOSE INSTRUCTION.
         DC    X'18'                   CODE=18,DIAGNOSE FOR CE.
         DC    C'WRD '                 WRD OP CODE.
         DC    X'18'                   CODE=18,5I FORMAT.
         DC    C'RDD '                 RDD OP CODE.
         DC    X'18'                   CODE=18,SI FORMAT.
         DC    C'BXH '                 BXH OP CODE.
         DC    X'0C'                   CODE=0C,RS FORMAT.
         DC    C'BXLE'                 BXLE OP CODE.
         DC    X'0C'                   CODE=0C,RS FORMAT.
         DC    C'SRL '                 SRL OP CODE.
         DC    X'10'                   CODE=10,RS FORMAT WITH 1 R.
         DC    C'SLL '                 SLL OP CODE.
         DC    X'10'                   CODE=10,RS FORMAT WITH 1 R.
         DC    C'SRA '                 SRA OP CODE.
         DC    X'10'                   CODE=10,RS FORMAT WITH 1 R.
         DC    C'SLA '                 SLA OP CODE.
         DC    X'10'                   CODE=10,RS FORMAT WITH 1 R.
         DC    C'SRDL'                 SRDL OP CODE.
         DC    X'10'                   CODE=10,RS FORMAT WITH 1 R.
         DC    C'SLDL'                 SLDL OP CODE.
         DC    X'10'                   CODE=10,RS FORMAT WITH 1 R.
         DC    C'SRDA'                 SRDA OP CODE.
         DC    X'10'                   CODE=10,RS FORMAT WITH 1 R.
         DC    C'SLDA'                 SLDA OP CODE.
         DC    X'10'                   CODE=10,RS FORMAT WITH 1 R.
         DC    C'STM '                 STM OP CODE.
         DC    X'0C'                   CODE=0C,RS FORMAT.
         DC    C'TM  '                 TM OP CODE.
         DC    X'18'                   CODE=1C,SI FORMAT.
         DC    C'MVI '                 MVI OP CODE.
         DC    X'18'                   CODE=1C,SI FORMAT.
         DC    C'TS  '                 TS OP CODE.
         DC    X'1C'                   CODE=1C,SI FORMAT WITHOUT THE I.
         DC    C'NI  '                 NI OP CODE.
         DC    X'18'                   CODE=18,SI FORMAT.
         DC    C'CLI '                 CLI OP CODE.
         DC    X'18'                   CODE=18,SI FORMAT.
         DC    C'OI  '                 OI OP CODE.
         DC    X'18'                   CODE=18,SI FORMAT.
         DC    C'XI  '                 XI OP CODE.
         DC    X'18'                   CODE=18,SI FORMAT.
         DC    C'LM  '                 LM OP CODE.
         DC    X'0C'                   CODE=0C,RS FORMAT.
         DC    3XL5'00'                CODE=00,INVALID OP CODE.
         DC    C'SIO '                 SIO OP CODE.
         DC    X'1C'                   CODE=1C,SI FORMAT WITHOUT THE I.
         DC    C'TIO '                 TIO OP CODE.
         DC    X'1C'                   CODE=1C,SI FORMAT WITHOUT THE I.
         DC    C'HIO '                 HIO OP CODE.
         DC    X'1C'                   CODE=1C,SI FORMAT WITHOUT THE I.
         DC    C'TCH '                 TCH OP CODE.
         DC    X'1C'                   CODE=1C,SI FORMAT WITHOUT THE I.
         DC    12XL5'00'               CODE=00,INVALID OP CODES.
         DC    C'TNSM'                 STNSM OP CODE. 370 R
         DC    X'18'                   CODE=18,SI FORMAT
         DC    C'TOSM'                 STOSM OP CODE. 370 R
         DC    X'18'                   CODE=18,SI FORMAT
         DC    C'SIGP'                 SIGP OP CODE. 370 R
         DC    X'0C'                   CODE=0C,RS FORMAT
         DC    C'MC  '                 MC OP CODE. 370
         DC    X'18'                   CODE=18,SI FORMAT
         DC    1XL5'00'                CODE=00,INVALID OP CODES.
         DC    C'LRA '                 LRA OP CODE. 370 R
         DC    X'28'                   CODE=28,RX FORMAT
         DC    4XL5'00'                CODE=00,INVALID OP CODES.
         DC    C'TCTL'                 STCTL OP CODE. 370
         DC    X'0C'                   CODE=0C,RS FORMAT
         DC    C'LCTL'                 LCTL OP CODE. 370.
         DC    X'0C'                   CODE=0C,RS FORMAT.
         DC    2XL5'00'                CODE=00,INVALID OP CODES@ZA11367
         DC    C'CS  '                 CS OP CODE. 370.        @ZA11367
         DC    X'0C'                   CODE=0C,RS FORMAT.      @ZA11367
         DC    C'CDS '                 CDS OP CODE. 370.       @ZA11367
         DC    X'0C'                   CODE=0C,RS FORMAT.      @ZA11367
         DC    XL5'00'                 CODE=00,INVALID OP CODE.@ZA11367
         DC    C'CLM '                 CLM OP CODE. 370.
         DC    X'0C'                   CODE=0C,R1,M3.
         DC    C'STCM'                 STCM OP CODE. 370.
         DC    X'0C'                   CODE=0C,R1,M3.
         DC    C'ICM '                 ICM OP CODE. 370.
         DC    X'0C'                   CODE=0C,R1,M3.
         DC    17XL5'00'               CODE=00,INVALID OP CODES.
         DC    C'MVN '                 MVN OP CODE.
         DC    X'20'                   CODE=20,SS FORMAT L1.
         DC    C'MVC '                 MVC OP CODE.
         DC    X'20'                   CODE=20,SS FORMAT L1.
         DC    C'MVZ '                 MVZ OP CODE.
         DC    X'20'                   CODE=20,SS FORMAT L1.
         DC    C'NC  '                 NC OP CODE.
         DC    X'20'                   CODE=20,SS FORMAT L1.
         DC    C'CLC '                 CLC OP CODE.
         DC    X'20'                   CODE=20,SS FORAMT L1.
         DC    C'OC  '                 OC OP CODE.
         DC    X'20'                   CODE=20,SS FORMAT L1.
         DC    C'XC  '                 XC OP CODE.
         DC    X'20'                   CODE=20,SS FORMAT L1.
         DC    4XL5'00'                CODE=00,INVALID OP CODE.
         DC    C'TR  '                 TR OP CODE.
         DC    X'20'                   CODE=20,SS FORMAT L1.
         DC    C'TRT '                 TRT OP CODE.
         DC    X'20'                   CODE=20,SS FORMAT L1.
         DC    C'ED  '                 ED OP CODE.
         DC    X'20'                   CODE=20,SS FORMAT L1.
         DC    C'EDMK'                 EDMK OP CODE.
         DC    X'20'                   CODE=20,SS FORMAT L1.
         DC    16XL5'00'               CODE=00,INVALID OP CODE.
         DC    C'SRP '                  SRP OP CODE. 370.
         DC    X'20'                   CODE=20 SS FORMAT L1 WITH I.
         DC    C'MVO '                 MVO OP CODE.
         DC    X'24'                   CODE=24,SS FORMAT L1 & L2.
         DC    C'PACK'                 PACK OP OCDE.
         DC    X'24'                   CODE=24,SS FORMAT L1 & L2.
         DC    C'UNPK'                 UNPK OP CODE.
         DC    X'24'                   CODE=24,SS FORMAT L1 & L2.
         DC    4XL5'00'                CODE=00,INVALID OP CODE.
         DC    C'ZAP '                 ZAP OP CODE.
         DC    X'24'                   CODE=24,SS FORMAT L1 & L2.
         DC    C'CP  '                 CP OP CODE.
         DC    X'24'                   CODE=24,SS FORMAT L1 & L2.
         DC    C'AP  '                 AP OP CODE.
         DC    X'24'                   CODE=24,SS FORMAT L1 & L2.
         DC    C'SP  '                 SP OP CODE.
         DC    X'24'                   CODE=24,SS FORMAT L1 & L2.
         DC    C'MP  '                 MP OP CODE.
         DC    X'24'                   CODE=24,SS FORMAT L1 & L2.
         DC    C'DP  '                 DP OP CODE.
         DC    X'24'                   CODE=24,SS FORMAT L1 & L2.
         DC    2XL5'00'                CODE=00,INVALID OP CODE.
OPTABLN  EQU   *-IKJEGCOP              LENGTH OF ONE BYTE OP TABLE
         EJECT
***********************************************************************
* BEGINNING OF 370 TWO BYTE OP CODE TABLE. EACH OP CODE BEGINS WITH   *
* ONE BYTE OF B2 AND THEN ANOTHER UNIQUE SECOND BYTE. THIS TABLE      *
* INCLUDES ONLY UP TO THE RRB OP CODE (370-R B213) AND CAN BE         *
* EXPANDED IN THE FUTURE IF NECESSARY.                                *
***********************************************************************
         SPACE
IKJEGCD2 CSECT
         DC    2XL6'00'                CODE=00,INVALID OP CODES.
         DC    C'STIDP'                STIDP OP CODE. 370.
         DC    X'1C'                   CODE=1C,SI FORMAT WITHOUT I.
         DC    C'STIDC'                STIDC OP CODE. 370.
         DC    X'1C'                   CODE=1C,SI FORMAT WITHOUT I.
         DC    C'SCK  '                SCKC OP CODE. 370.
         DC    X'1C'                   CODE=1C,SI FORMAT WITHOUT I.
         DC    C'STCK '                SCKC OP CODE. 370.
         DC    X'1C'                   CODE=1C,SI FORMAT WITHOUT I.
         DC    C'SCKC '                SCKC OP CODE. 370-R
         DC    X'1C'                   CODE=1C,SI FORMAT WITHOUT I.
         DC    C'STCKC'                STCKC OP CODE. 370-R
         DC    X'1C'                   CODE=1C,SI FORMAT WITHOUT I.
         DC    C'SPT  '                SPT OP CODE. 370-R
         DC    X'1C'                   CODE=1C,SI FORMAT WITHOUT I.
         DC    C'STPT '                STPT OP CODE. 370-R
         DC    X'1C'                   CODE=1C,SI FORMAT WITHOUT I.
         DC    3XL6'00'                00 OP CODE. INVALID
         DC    C'PTLB '                PTLB OP CODE. 370-R
         DC    X'1C'                   CODE=1C,SI FORMAT WITHOUT I.
         DC    2XL6'00'                00 OP CODE. INVALID
         DC    C'SPX  '                SPX OP CODE. 370-R
         DC    X'1C'                   CODE=1C,SI FORMAT WITHOUT I.
         DC    C'STPX '                STPX OP CODE. 370-R
         DC    X'1C'                   CODE=1C,SI FORMAT WITHOUT I.
         DC    C'STAP '                STAP OP CODE. 370-R
         DC    X'1C'                   CODE=1C,SI FORMAT WITHOUT I.
         DC    C'RRB  '                RRB OP CODE. 370-R
         DC    X'1C'                   CODE=1C,SI FORMAT WITHOUT I.
OPCD2LN  EQU   *-IKJEGCD2              LENGTH OF 370 (B2) OP TABLE
         EJECT
         TITLE 'IKJEGCVT' CVT MESSAGE CSECT.
IKJEGFLT CSECT
         SPACE
***********************************************************************
*                                                                     *
* THIS CSECT IS AN EXTENSION OF THE CONVERT ROUTINE(IKJEGCVT).  THE   *
* FOLLOWING LINES OF CODE IN THIS CSECT WILL CONVERT THE FLOATING     *
* POINT DATA.                                                         *
***********************************************************************
         SPACE
REMAIN   EQU   X'01'                   HEX 01
AONE1    EQU   X'F1'                   HEX F1
AFIVE    EQU   C'5'                    CHARACTER 5
DOBLEND  EQU   24                      END OF DOUBLE ZONED DECIMAL.
ADJUST37 EQU   37                      DEC 37
OFFSET39 EQU   39                      DEC 39
HEX85    EQU   X'85'                   HEX 85
HEX10    EQU   X'10'                   HEX 10
HEX1C    EQU   X'1C'                   HEX 1C
OFFSET40 EQU   40                      DEC 40
FIVE3    EQU   53                      DEC 53
FIVE4    EQU   54                      DEC 54
HEX20    EQU   X'20'                   HEX 20
SIX4     EQU   64                      DEC 64
ONE8     EQU   18                      DEC 18
         ENTRY IKJEGFTB
         ENTRY IKJEGBFT
         SPACE
***********************************************************************
*                                                                     *
* THE FOLLOWING INSTRUCTIONS CONVERT A FLOATING POINT BINARY VALUE    *
* TO ITS PRINTABLE FORMAT.                                            *
*                                                                     *
***********************************************************************
         SPACE
IKJEGBFT EQU   *
         LR    R12,R15                 R12= ADDRESS OF IKJEGFLT.
         USING IKJEGFLT,R12            IKJEGFLT ADDRESSABILITY.
         L     R3,WORKAREA             R3=ADDRESS OF WORKAREA.
         USING CVTWORK,R3              WORKAREA ADDRESSABILITY.
         LH    R6,FOUR(R1)             R6=LENGTH OF INPUT.
         LR    R0,R6                   SAVE LENGTH OF INPUT.
         L     R1,ZERO(R1)             R1=ADDRESS OF INPUT STRING.
         XC    FLTINPUT,FLTINPUT       CLEAR INPUT AREA OF GARBAGE.
         BCTR  R6,ZERO                 R6=EXECUTE LENGTH.
         BCTR  R6,ZERO                 *
         LTR   R6,R6                   Q.SKIP MOVE INSTRUCTION.
         BM    SKIPMOVE                YES,SKIP MOVE INSTRUCTION.
         EX    R6,FLTMOVE              MOVE INPUT INTO WORKAREA.
SKIPMOVE EQU   *
         LM    R4,R5,FLTINPUT          INPUT NOW IN WORK REGISTERS.
         IC    R7,ZERO(R1)             R7=CHARACTERISTICS.
         N     R7,SIGNOFF              TURN OFF FRACTION SIGN.
         LTR   R6,R6                   Q.EXP ONLY SPECIFIED.
         BM    EXPONLY                 YES,CONVERT EXPONENT.
         LTR   R4,R4                   Q.ZERO FRACTION SPECIFIED.
         BNZ   NONZERO                 NO - GO GET EXPONENT.    YA00086
         LTR   R5,R5                   Q.ZERO FRACTION          YA00086
*                                      SPECIED.
         BZ    ZEROFRAC                YES, PASS A ZERO.
NONZERO  DS    0H
         SH    R7,FLTCHAR              DECIMAL POINT NOW 6 DIGITS TO
*                                      RIGHT AND EXP VALUE DETERMINE.
         LTR   R5,R5                   Q.IS THIS SINGLE PRECISION.
         BNZ   FLTLONG                 NO,CONVERT LONG PRECISION.
         SPACE
***********************************************************************
* THIS SECTION OF CODE WILL CONVERT THE FRACTION OF A SINGLE          *
* PRECISION FLOATING POINT BINARY TO ZONED DECIMAL                    *
***********************************************************************
         SPACE
         CVD   R4,PACKAREA             FRACTION NOW CONVERTED TO PACKED
         OI    PACKAREA+SEVEN,SIGNF    DECIMAL.
         UNPK  FLTSTG(ONE5),PACKAREA   FRACTION NOW ZONED DECIMAL
         LA    R6,FLTSTG+ONE5          R6=ADDR OF END OF ZONED DEC.
SUPPRESS EQU   *
* THE FOLLOWING INSTRUCTIONS SUPPRESSES LEADING ZEROES.               *
         SPACE
         LA    R8,FLTSTG               R8=ADDR OF ZONED DATA.
FLTLOOP  EQU   *
         CLI   ZERO(R8),F0             SUPPRESS INSIGNIFICANT LEADING
         BNE   SIGFOUND                ZEROES.
         LA    R8,ONE(R8)              GET NEXT DIGIT.
         B     FLTLOOP                 CHECK NEXT DIGIT.
SIGFOUND EQU   *
         SR    R2,R2                   R0=0
         SR    R6,R8                   R6=LENGTH OF SIGNIFICANT DATA.
         STH   R6,FLTLEN               LENGTH NOW IN SAVE AREA.
         LTR   R7,R7                   Q.WHICH TYPE OF CVT IS NEEDED.
         BP    FLTADD                  DECIMAL ADD TO ITSELF.
         BM    FLTDIV                  DIVISION BY TWO.
         EX    R6,ZONEMOVE             LEFT JUSTIFY ZONED DATA.
        LA     R8,FLTSTG
        LA     R8,ZERO(R6,R8)
         B     CHAR                    COMPUTE EXP VALUE.
FLTADD   EQU   *
         SPACE
***********************************************************************
*                                                                     *
* THE FOLLOWING INSTRUCTIONS CONVERT THE ZONED DECIMAL FRACTION TO ITS*
* PROPER INTEGER FORM.                                                *
*                                                                     *
***********************************************************************
         SPACE
         LA    R5,FLTSTG+OFFSET40      MANTISSA RIGHT ALIGNED.
         SLL   R7,TWO                  MULTIPLY EXP BY FOUR.
         SR    R5,R6                   R5=PTR TO NEW WORKAREA.
         BCTR  R6,ZERO                 R6=EXECUTE LENGTH.
         EX    R6,ALIGNMVC             MOVE FRACTION FOR ADDITION.
         LH    R6,FLTLEN               R6=LENGTH OF FRACTION.
FLTSIM   EQU   *
         LA    R8,FLTSTG+OFFSET39      SET UP TO BEGIN ADD.
         SR    R5,R5                   R5=0
ADDNEXT  IC    R4,ZERO(R8)             R4=BYTE TO BE CONVERTED.
         N     R4,FLTCLEAR             R4=4 BIT VALUE.
         AR    R4,R4                   ADD DIGIT TO ITSELF.
         AR    R4,R5                   ADD PREVIOUS CARRY.
         LA    R5,ONE                  R5=CARRY VALUE.
         SH    R4,FLT10                IS THERE A CARRY.
         BNM   ACARRY                  YES.
         AH    R4,FLT10                RESTORE VALUE.
         SR    R5,R5                   CLEAR CARRY VALUE.
ACARRY   EQU   *
         LA    R4,F0(R4)               CONVERT VALUE TO PRINTABLE.
         STC   R4,ZERO(R8)             SAVE THE RESULTS.
         BCTR  R8,ZERO                 ADJUST POINTER.
         BCT   R6,ADDNEXT              ADD NEXT BYTE.
         LH    R6,FLTLEN               R6=LENGTH.
         LTR   R5,R5                   Q.IS THERE A CARRY.
         BZ    LASTZERO                NO,DO NOT MOVE IN A 1.
         MVI   ZERO(R8),AONE1          MOVE IN A PRINTABLE 1.
         BCTR  R8,ZERO                 POINT TO NEXT BYTE.
         AR    R6,R5                   UPDATE NUMBER OF DIGITS.
         STH   R6,FLTLEN               SAVE LENGTH.
         LA    R5,FLTSTG               R5=ADDR OF WORK AREA.
         CR    R5,R8                   ANY TRUNCATION NEEDED.
         BE    TRUNCATE                YES.
LASTZERO BCT   R7,FLTSIM               NO.
         LA    R8,ONE(R8)              ADJUST ZONE DECIMAL POINTER.
         EX    R6,ZONEMOVE             ADJUST ZONED DECIMAL.
         LA    R8,FLTSTG               R8=ADDR OF ZONE DECIMAL.
         CH    R6,FLT17                Q.ZONE DECIMAL TOO LONG.
         BL    NOTLONG                 NO,SKIP LENGTH CORRECTION.
         LA    R8,ONE7(R8)             INCREMENT BY 17
         MVI   FLTLEN+ONE,ONE7         NEW LENGTH IN LENGTH FIELD.
         B     CHAR                    GO CONVERT CHARACTERISTICS.
NOTLONG  EQU   *
         LA    R8,ZERO(R6,R8)          R8=PTR TO END OF ZONED DATA.
         B     CHAR                    GO CONVERT CHARACTERISTICS.
TRUNCATE EQU   *
         SH    R6,FLTDEC2              CORRECT LENGTH FOR TRUNCATION.
         STH   R6,FLTLEN               NEW LNG IN LNG SAVE AREA.
         SH    R2,FLTDEC2
         LA    R8,FLTSTG+ADJUST37      RIGHT ADJUST THE NUMBER
FBYTEMVC MVC   TWO(ONE,R8),ZERO(R8)    IN WORK AREA.
         BCTR  R8,ZERO                 ALTER POINTER TO NEXT TYTE.
         BCT   R6,FBYTEMVC             GET NEXT BYTE.
         LH    R6,FLTLEN               R6=NEW LENGTH.
         CH    R7,HALFONE              Q.LAST MULTIPLY.
         BNE   NOTLAST                 NO,DO NOT ALTER POINTER.
         LA    R8,TWO(R8)              R8=PT TO SIGNIFICANT DIGITS.
NOTLAST  EQU   *
         B     LASTZERO                CHECK FOR MORE VALUES TO ADD.
FLTDIV   EQU   *
         SPACE
***********************************************************************
*                                                                     *
* THE FOLLOWING LINES OF CODE CONVERTS THE ZONED DECIMAL MANTISSA TO  *
* ITS PROPER ZONED DECIMAL MANTISSA.                                  *
*                                                                     *
***********************************************************************
         SPACE
         LPR   R7,R7                   R7,NOW POSITIVE.
         SLL   R7,TWO                  MULTIPLY BY FOUR.
         BCTR  R6,ZERO                 R6=LENGTH OF ZONED DECIMAL.
         EX    R6,ZONEMOVE             LEFT JUSTIFY ZONED DECIMAL.
SCALE    LH    R6,FLTLEN               LENGTH NOW IN REGISTER.
         SR    R5,R5                   R5=ZERO.
         LA    R8,FLTSTG               R8=POINTER TO ZONED DECIMAL.
         CLI   ZERO(R8),AZERO          CHECK TO SUPPRESS LEADING ZEROS.
         BNE   NEXTDIV                 BRANCH PROCESS DIGIT.
         BCTR  R6,ZERO                 DECREMENT LENGTH.
         STH   R6,FLTLEN               SAVE CORRECT LENGTH.
         BCTR  R6,ZERO                 R6=EXECUTE LENGTH.
         EX    R6,ZONEJUST             LEFT JUSTIFY THE SIGNIF.DIGITS.
         SR    R5,R5                   R5=ZERO.
         LA    R6,ONE(R6)              R6=CORRECT LENGTH.
NEXTDIV  EQU   *
         IC    R4,ZERO(R8)             SIMULATE DIVISION BY TWO.
         N     R4,FLTCLEAR             R4=4 BIT VALUE.
         SRL   R4,ONE                  R4=VALUE DIVIDED BY TWO.
         AR    R4,R5                   COMBINE THE PARTIAL QUOTIENT.
         LA    R4,F0(R4)               VALUE NOW PRINTABLE CHARACTER.
         SR    R5,R5                   R5=ZERO.
         TM    ZERO(R8),REMAIN         CHECK FOR REMAINDER.
         BZ    SKIPCARY                SKIP CARRY FLAG SET.
         LA    R5,FIVE                 R5=5,CARRY FLAG.
SKIPCARY EQU   *
         STC   R4,ZERO(R8)             MOVE NEW VALUE IN STRING.
         LA    R8,ONE(R8)              UPDATE STRING POINTER.
         BCT   R6,NEXTDIV              BRANCH TO PROCESS NEXT DIGIT.
         LH    R6,FLTLEN               R6=CORRECT LENGTH.
         LTR   R5,R5                   ANY FINAL PARTIAL QUOTIENT.
         BZ    NOFINAL                 NO,SKIP FINAL ADJUSTMENT.
         CH    R6,FLT20                Q.FINAL PARTIAL QUOTIENT.
         BNL   ADJUSTIT                YES,ADJUST RESULTS.
         MVI   ZERO(R8),AFIVE          MOVE IN A CHARACTER FIVE.
         LA    R2,ONE(R2)              INCREMENT POINTER.
         LA    R6,ONE(R6)
         STH   R6,FLTLEN               SAVE LENGTH.
JUSTEND  EQU   *
         LA    R8,ONE(R8)              UPDATE POINTER.
NOFINAL  EQU   *
         BCT   R7,SCALE                BRANCH IF SCALING IS NOT ZERO.
CHAR     EQU   *
***********************************************************************
*                                                                     *
* THE FOLLOWING LINES OF CODE CALCULATE THE NUMBER OF SIGNIFICANT     *
* DIGITS AND ROUND OFF THE SIGNIFICANTS.                              *
*                                                                     *
***********************************************************************
         SPACE
         CLI   FLTSTG,AZERO            Q.AN ZERO.
         BNE   NOZERO                  NO,CONTINUE PROCESSING.
         BCTR  R8,ZERO                 DECREMENT R8 BY ONE
         LH    R6,FLTLEN               R6= LENGTH
         BCTR  R6,ZERO                 ALSO DECREMENT LENGTH BY ONE
         STH   R6,FLTLEN               RESTORE THE LENGTH
         EX    R6,MOVEFLT              LEFT JUSTIFY ZONE DECIMAL.
NOZERO   EQU   *
         LR    R4,R0                   R4=LENGTH OF INPUT.
         BCTR  R4,ZERO                 R4=FRACTION LENGTH.
         LR    R5,R4                   R5=FRACTION LENGTH.
         SLL   R4,ONE                  ********************************
         LA    R5,ONE(R5)              * CALCULATE THE NUMBER OF      *
         SRL   R5,ONE                  * SIGNIFICANT DIGITS.          *
         AR    R4,R5                   ********************************
         CH    R4,FLT17                Q.LENGTH GREATER THAN 16.
         BL    NOALTER                 NO,DO NOT ALTER LENGTH.
         BCTR  R4,ZERO                 R4=CORRECT SIGNIFICANT LENGTH.
NOALTER  EQU   *
         CH    R4,FLTLEN               Q.SIGNIFICANT GREATER THAN LENG.
         BH    ENDSIGNF                NO,SKIP SIGNIFICANT ALTER.
         LR    R0,R4                   R0=NUMBER OF SIGNIFICANT DIGITS.
         LA    R5,ONE                  R5=1.
         NR    R5,R4                   Q.LENGTH ODD.
         BM    SKIPSHIF                YES,DO NOT SHIFT.
         BCTR  R4,ZERO                 SET UP EVEN SIGNIFICANT.
SKIPSHIF EQU   *
         SRL   R4,ONE                  CALCULATE NUMBER OF OUTPUT BUTES
         LA    R4,ONE(R4)              FOR PACK INSTRUCTION.
         CH    R0,FLT17                Q.INPUT 17 BYTES.
         BE    SIMPACK                 YES,SIMULATE PACK INSTRUCTION.
         LR    R5,R0                   R5=NUMBER OF SIGNIFICANT DIGITS.
         BCTR  R5,ZERO                 R5=EXECUTE LENGTH.
         SLL   R4,FOUR                 R4=LENGTH IN HIGH OFDER 4 BITS.
         OR    R5,R4                   R5=LENGTH 1 AND LENGTH 2.
         EX    R5,ROUNDPK              PACK SIGNIFICANT DIGITS.
         SRL   R5,FOUR                 CLEAR LENGTH 2.
         SLL   R5,FOUR                 *
         EX    R5,ADD5                 ADD 5 TO SIGNIFICANT DIGITS.
         LR    R4,R0                   R4=LENGTH OF SIGNIFICANT DIGITS.
         BCTR  R4,ZERO                 R4=EXECUTE LENGTH.
         SLL   R4,FOUR                 R4=LENGTH 1 IN HIGH ORDER 4 BITS
         SRL   R5,FOUR                 R5=LENGTH 2 IN LOW ORDER.
         LA    R7,ONE                  R7=1,FOR EVEN ODD CHECK.
         NR    R7,R0                   Q.SIGNIFICANTS ODD.
         BM    ODDSIGNF                YES,CHECK FOR CARRY.
         CLI   FLTINPUT,HEX9           Q.IS THERE A CARRY.
         BNH   NOEXPJST                NO,DO NOT ADJUST.
ANEXPJST EQU   *
         BCTR  R2,ZERO                 ACCOUNT FOR EXPONENT.
         LA    R4,ONE6(R4)              ACCOUNT FOR CARRY DIGIT.
NOEXPJST EQU   *
         OR    R5,R4                   R5=LENGTH 1 AND 2.
         EX    R5,UNPKSIG              UNPACK SIGNIFICANT DIGITS.
ENDSIG   EQU   *
         LR    R8,R0                   R8=NUMBER OF SIGNIFICANT DIGITS.
         STH   R8,FLTLEN               CORRECT LENGTH IN SAVE AREA.
         LA    R5,FLTSTG               R5=ADDR OF SIGNIFICANT DIGITS.
         LA    R8,ZERO(R5,R8)          R8=PTR TO END OF SIGNIFICANTS.
         BCTR  R8,ZERO                 POINT TO LAST BYTE.
         OI    ZERO(R8),HEXF0          ALTER SIGN TO PRINTABLE.
         LA    R8,ONE(R8)              R8=PTR TO END OF SIGNIFICANTS.
         B     ENDSIGNF                CALCULATE EXPONENT.
ODDSIGNF EQU   *
         CLI   FLTINPUT,HEX00          Q.IS THERE A CARRY.
         BE    NOEXPJST                NO,DO NOT ADJUST.
         B     ANEXPJST                YES,ACCOUNT FOR EXPONENT.
         SPACE
***********************************************************************
*                                                                     *
* THIS AREA OF CODE PACKS AN AREA 17 BYTES IN LENGTH AND ROUNDS THE   *
* VALUE.                                                              *
*                                                                     *
***********************************************************************
         SPACE
SIMPACK  EQU   *
         PACK  FLTINPUT(NINE),FLTSTG(ONE6) PACK FIRST 15 BYTES.
         PACK  FLTINPUT+EIGHT(TWO),FLTSTG+ONE5(THREE) NEXT THREE.
         OI    FLTINPUT+NINE,SIGNF     SIGN ALTERED FOR ADD.
         MVC   FLTSTG(ONE9),FLTPATTN   PATTERN NOW IN WORKAREA.
         AP    FLTINPUT(TEN),PACK5(ONE) ROUND VALUE.
         CLI   FLTINPUT,HEX9           Q.IS THERE A CARRY.
         BNH   NOJSTEXP                NO,DO NOT ADJUST.
         BCTR  R2,ZERO                 ACCOUNT FOR EXPONENT.
NOJSTEXP EQU   *
         ED    FLTSTG(TWO0),FLTINPUT   SIGNIFICANTS NOW ZONED DECIMAL.
         LA    R8,FLTSTG               R8=POINTER TO FLTSTG.
FINDNO0  EQU   *
         CLI   ZERO(R8),AZERO          Q.NON-ZERO FOUND.
         BNE   JUSTSNFT                YES,LEFT JUSTIFY.
         LA    R8,ONE(R8)              POINT TO NEXT BYTE.
         B     FINDNO0                 GET NEXT BYTE.
JUSTSNFT EQU   *
         MVC   FLTSTG(ONE7),ZERO(R8)   LEFT JUSTIFY VALUE.
         B     ENDSIG                  END SIGNIFICANTS.
ENDSIGNF EQU   *
         SR    R6,R2                   R6=EXPONENT VALUE.
         MVC   ZERO(FIVE,R8),EXPCHAR   EXPONENT PATTERN IN STRING.
         LTR   R6,R6                   IS EXPONENT NEGATIVE.
         BNM   SKIPNEG                 SKIP NEGATIVE SIGN MOVE.
         MVI   TWO(R8),SIGNNEG         NEGATIVE SIGN NOW IN STRING.
SKIPNEG  EQU   *
         CVD   R6,PACKAREA             EXPONENT NOW PACKED DECIMAL.
         OI    PACKAREA+SEVEN,SIGNF    SIGN NOW X'F'.
         UNPK  THREE(TWO,R8),PACKAREA+SIX(TWO) EXPONENT NOW IN STRING.
         CLI   THREE(R8),AZERO         IS FIRST CHARACTER A ZERO.
         BNE   BLKSKIP                 NO,DO NOT MOVE IN A BLANK.
         MVI   THREE(R8),BLANK         FIRST CHARACTER NOW A BLANK.
BLKSKIP  EQU   *
         LA    R8,FLTSTG-TWO           R8=ADDRESS FOR MANTISSA SIGN.
         MVC   ZERO(TWO,R8),FRACSIGN   FRACTION + SIGN NOW IN STRING.
         TM    ZERO(R1),HION           IS FRACTION NEGATIVE.
         BZ    PLUSFRAC                NO,DO NOT MOVE IN NEGATIVE SIGN.
         MVI   ZERO(R8),MINUS          MINUS SIGN NOW IN STRING.
PLUSFRAC EQU   *
         L     R2,CONAREA              R2=ADDRESS OF OUTPUT AREA.
         LH    R6,FLTLEN               R6=LENGTH OF MANTISSA.
         LA    R6,SEVEN(R6)            R6=LENGTH OF OUTPUT STRING.
         STC   R6,ZERO(R2)             LENGTH OF OUTPUT NOW IN CONAREA.
         BCTR  R6,ZERO                 R6=EXECUTE LENGTH.
         EX    R6,OUTMVC               MOVE STRING INTO OUTPUT AREA.
ENDFLT   SR    R15,R15                 R15=ZERO.
         BR    R14                     RETURN TO CALLER.
***********************************************************************
*                                                                     *
* THE FOLLOWING LINES OF CODE CALCULATE THE EXPONENT AND MOVE IT'S    *
* PRINTABLE REPRESENTATION INTO CONAREA.                              *
*                                                                     *
***********************************************************************
         SPACE
EXPONLY  EQU   *
         L     R2,CONAREA              R2=ADDR OF CONAREA.
         SH    R7,FLT64                R7=EXPONENT IN BINARY.
         MVC   ONE(FOUR,R2),EXPCHAR+ONE EXPONENT SIGN NOW IN CONAREA.
         LTR   R7,R7                   Q.EXPONENT NEGATIVE.
         BNM   PLUSEXP2                NO,SKIP COMPLEMENT.
         MVI   TWO(R2),MINUS           NEGATIVE SIGN NOW IN CONAREA.
PLUSEXP2 EQU   *
         CVD   R7,PACKAREA             EXP NOW PACKED DECIMAL.
         OI    PACKAREA+SEVEN,SIGNF    SIGN NOW X'F'.
         UNPK  FLTSTG(TWO),PACKAREA+SIX(TWO) EXP NOW ZONED DECIMAL.
         CLI   FLTSTG,F0               Q.FIRST CHAR A ZERO.
         BNE   NOF0                    NO,DO NOT MOVE IN BLANK.
         MVI   FLTSTG,BLANK            BLANK NOW IN EXP FIELD.
NOF0     EQU   *
         MVC   THREE(TWO,R2),FLTSTG    EXP NOW IN CONAREA.
         MVI   ZERO(R2),FOUR           LENGTH NOW IN CONAREA.
         B     ENDFLT                  SET RETURN CODE & RETURN.
***********************************************************************
*                                                                     *
* THIS SECTION OF CODE MOVES INTO CONAREA(OUTPUT AREA) THE OUTPUT FOR *
* A FRACTION ZERO.                                                    *
*                                                                     *
***********************************************************************
         SPACE
ZEROFRAC EQU   *
         L     R2,CONAREA              R2=ADDRESS OF OUTPUT AREA.
         MVC   ZERO(THREE,R2),FLPTZERO PRINTABLE +0 NOW IN CONAREA.
         B     ENDFLT                  GO,SET RETURN CODE & RETURN.
***********************************************************************
*                                                                     *
* THE FOLLOWING INSTRUCTIONS CONVERT THE FRACTION OF A DOUBLE         *
* PRECISION FLOATING POINT BINARY TO ZONED DECIMAL.                   *
*                                                                     *
***********************************************************************
FLTLONG  EQU   *
         SH    R7,DOBLFLT              MOVE DEC PT 8 MORE DIGITS RIGHT.
         D     R4,CVTVAL               ALTER FRACTION FOR CONVERSION.
         CVD   R5,PACKAREA             FRACTION NOW BEING CONVERTED TO
         OI    PACKAREA+SEVEN,SIGNF    PACKED DECIMAL.
         UNPK  FLTSTG(ONE5),PACKAREA   PARTIAL CONVERT OF FRACTION.
         CVD   R4,PACKAREA             REMAINDER OF FRACTION NOW BEING
         OI    PACKAREA+SEVEN,SIGNF    CONVERTED TO PACK DECIMAL.
         UNPK  REMDATA(NINE),PACKAREA  REMIANDER OF FRACTION CONVERTED.
         LA    R6,FLTSTG+DOBLEND       R6=ADDRESS OF END OF ZONED DEC.
         B     SUPPRESS                GO SUPPRESS LEADING ZEROES.
ADJUSTIT EQU   *
         BCTR  R8,ZERO                 R8=PTR TO LAST BYTE.
         IC    R4,ZERO(R8)
         TM    ZERO(R8),HEX9           Q.IS IT EQUAL TO NINE.
         BO    ADJUST2                 YES
         LA    R4,ONE(R4)              CARRY NEXT TO LAST BYTE ONE.
         STC   R4,ZERO(R8)             MOVE BYTE INTO STRING.
         B     JUSTEND                 CHECK SCALING.
ADJUST2  EQU   *
         BCTR  R6,ZERO                 DECREMENT LENGTH.
         BCTR  R2,ZERO                 DECREMENT EXPONENT.
         STH   R6,FLTLEN               SAVE LENGTH.
         B     ADJUSTIT                GET NEXT BYTE.
         EJECT
***********************************************************************
*                                                                     *
* THE FOLLOWING INSTRUCTIONS CONVERT PRINTABLE DATA IN STANDARD OR    *
* SCIENTIFIC NOTATION TO ITS SINGLE OR DOUBLE PRECISION FLOATING      *
* POINT REPRESENTATION.                                               *
*                                                                     *
***********************************************************************
IKJEGFTB EQU   *
         DROP  R12                     GET NEW BASE REGISTER
         USING *,R15                   ESTABLISH ADDRESSABILITY
         L     R12,FLTCON              R12=ADDRESS OF IKJEGFLT
         DROP  R15                     GET NEW BASE REGISTER
         USING IKJEGFLT,R12            IKJEGFLT ADDRESSABILITY
         USING TCOMTAB,R9              TCOMTAB ADDRESSABILITY
         L     R3,WORKAREA             GET WORK SPACE
         USING CVTWORK,R3              ESTABLISH ADDRESSABILITY
         XC    ZERO(SIX4,R3),ZERO(R3)  CLEAR OUT WORK AREA
         STC   R6,TYPE                 STORE TYPE CODE E OR D
         LH    R4,FOUR(R1)             LOAD LENGTH OF INPUT STRING
         EJECT
***********************************************************************
* THE FOLLOWING CODE SCANS THE INPUT STRING SAVING THE COEFFICIENT    *
* SIGN, THE EXPONENT SIGN, THE ADDRESS OF THE COEFFICIENT AND THE     *
* EXPONENT.                                                           *
***********************************************************************
         SPACE
         LA    R6,FRACSGN              POINT TO LOCATION FOR COEFF SIGN
         LA    R2,SCAN1                R2= ADDR OF SCAN1
         L     R7,ZERO(R1)             POINT TO INPUT STRING
         MVI   EXPSIGN,PLUS            DEFAULT EXPONENT TO POSITIVE
         SR    R5,R5                   DEFAULT EXPONENT TO ZERO
SCAN0    CLI   ZERO(R7),MINUS          IS COEFFICIENT NEGATIVE
         BE    STORSIG1                IF YES BRANCH
         CLI   ZERO(R7),PLUS           IS COEFFICIENT POSITIVE
         BE    STORSIG1                IF YES BRANCH
         MVI   ZERO(R6),PLUS           DEFAULT TO POSITIVE
         BR    R2                      BRANCH TO SCAN1 OR SCANDONE
STORSIG1 MVC   ZERO(ONE,R6),ZERO(R7)
         LA    R7,ONE(R7)              POINT TO CHARACTER BEYOND SIGN
         BCTR  R4,R2                   BRANCH TO SCAN1 OR SCANDONE
SCAN1    SR    R8,R8                   INITLZ DIGIT COUNT OF COEFF
         LR    R1,R7                   SAVE ADDRESS OF COEFFICIENT
SCAN2    CLI   ZERO(R7),RESIGN         IS THE CHARACTER AN 'E'
         BE    EFOUND                  IF YES BRANCH
         CLI   ZERO(R7),HEX85          LOWER CASE E
         BE    EFOUND                  IF YES BRANCH
         LA    R8,ONE(R8)              ADD ONE TO COEFF DIGIT COUNT
         LA    R7,ONE(R7)              POINT TO NEXT CHARACTER
         BCT   R4,SCAN2                BRANCH AND DECREMENT STRING LN
         B     NUMCHECK                IF STRING LENGTH ZERO BRANCH
EFOUND   LA    R7,ONE(R7)              POINT TO NEXT CHARACTER
         LA    R6,EXPSIGN              POINT TO LOCATION FOR EXP SIGN
         BCTR  R4,R0                   DECREMENT STRING LENGTH
         BAL   R2,SCAN0                CHECK FOR EXPONENT SIGN
         BCTR  R4,R0                   DECREMENT STRING LENGTH
         EX    R4,PACKE                PACK THE EXPONENT
         CVB   R5,NUM4                 CONVERT THE EXPONENT TO BINARY
         EJECT
***********************************************************************
* THE FOLLOWING CODE CHECKS FOR AN INPUT OF ZERO AND THEN BRANCHES TO *
* THE PROPER CODE TO PACK THE INPUT NUMBER DEPENDING ON WHETHER IT IS *
* AN INTEGER, A PROPER FRACTION, OR AN IMPROPER FRACTION.             *
***********************************************************************
         SPACE
NUMCHECK L     R2,CONAREA              POINT TO OUTPUT AREA
         XC    ZERO(THREE2,R2),ZERO(R2) CLEAR IT OUT
         LA    R15,RETURN1             SAVE IN OTHERWISE USELESS REG
         MVI   NUM1,AZERO              MOVE IN CHARACTER ZERO
         MVC   NUM1+ONE(TWO6),NUM1     SPREAD IT ALONG
         BCTR  R8,R0                   DECREMENT COEFF DIGIT CNT FOR EX
         EX    R8,CLC1                 IS COEFFICIENT ZERO
         BCR   EIGHT,R15               IF YES GO TO RETURN1
         LA    R8,ONE(R8)              RESTORE COEFFICIENT DIGIT COUNT
CLI      CLI   ZERO(R1),HEXF0          IS THERE A HIGH ORDER ZERO
         BNE   CLICLI                  IF NO BRANCH
         BCTR  R8,R0                   DECREMENT DIGIT COUNT
         LA    R1,ONE(R1)              POINT PAST ZERO
         B     CLI                     CHECK NEXT CHARACTER
CLICLI   EQU   *
         CLI   EXPSIGN,PLUS            IS NUMBER AN INTEGER
         BE    INTEGER                 IF YES NUMBER IS PURE INTEGER
         CH    R5,HALFZERO             CHECK FOR XXXXE-0 INPUT
         BE    INTEGER                 IF SO NUMBER IS REALLY INTEGER
         CR    R8,R5                   IS NUMBER PURE FRACTION
         BNH   FRACTION                IF YES BRANCH
         OI    FLAG,HEXC0              INDICATE MIXED
         LR    R10,R8                  SAVE COEFFICIENT DIGIT COUNT
         SR    R10,R5                  NUMBER OF DIGITS IN INTEGER PART
         BCTR  R10,R0                  DECREMENT FOR EX
         XC    NUM1(TWO7),NUM1         CLEAR NUM1
         EX    R10,PACKA               PACK THE INTEGER INTO NUM1
         LA    R10,ONE(R10)            RESTORE REGISTER 10
         AR    R1,R10                  POINT PAST INTEGER PART OF COEFF
         LR    R8,R5                   SAVE R5=EXPONENT
         LR    R6,R1                   POINT TO FRACTION COEFFICIENT
CLI2     CLI   ZERO(R6),HEXF0          DO COMPARE
         BNE   LR8                     IF NO GET OUT
         LA    R6,ONE(R6)              POINT TO NEXT CHARACTER
         BCT   R8,CLI2                 HAVE WE FINISHED CHECKING
         NI    FLAG,HEXFF-HEX80        IF YES THERE IS NO FRACTION PART
LR8      LR    R8,R5                   R8= R5 FOR SHIFT
         SRL   R8,ONE                  REMOVE LOW BIT
         LR    R4,R8                   SAVE CURRENT FRACTION
         SLL   R8,FOUR                 SHIFT BACK BY FOUR
         AR    R8,R5                   ADD R8, R5 TO GET FRACTIONAL PT
         BCTR  R8,R0                   R8=EXECUTE LENGTH.
         EX    R8,PACKB                PACK FRACTION PART OF USER NUMB
         LA    R4,NUM3+TWO(R4)         POINT TO END OF PACKED FRACTION
         MVN   ZERO(ONE,R4),HALFZERO
         LA    R4,ONE                  R4=1.
         NR    R4,R5                   IS EXPONENT EVEN OR ODD
         BNZ   MIXED2                  IF EVEN BRANCH
         MVO   NUM3(ONE6),NUM3(ONE6)
MIXED2   MVN   NUM3+ONE5(ONE),PACK10+ONE
         B     PACKDONE                PACKING IS DONE, BRANCH OUT
INTEGER  EQU   *
         OI    FLAG,HEX40              INDICATE INTEGER
         LR    R10,R8                  SAVE R8=COEFFICIENT DIGIT COUNT
         AR    R10,R5                  ADD EXPONENT TO GET FULL SIZE
         BCTR  R8,R0                   DECREMENT FOR MOVE
         C     R10,TWENTY7             HOW LONG IS INTEGER
         BNL   LEFTADJ                 IF LONGER THAN BUFFER LFT ADJ IT
         LA    R6,NUM3+ONE1
         SR    R6,R10                  ALTER INTEGER POINTER.
         EX    R8,MOVEA                RIGHT ADJUST INTEGER .
         B     PACKINT                 PACK THE INTEGER
LEFTADJ  EX    R8,MOVE1                LEFT ADJUST INTEGER.
PACKINT  PACK  NUM2+TWO(EIGHT),NUM1(ONE5)
         PACK  NUM2+NINE(SEVEN),NUM1+ONE4(ONE3)
         B     PACKDONE                PACKING IS DONE, GET OUT
*        THE NUMBER IS A PURE FRACTION SETUP FOR HANDLING IT
FRACTION EQU   *                       NUMBER IS A PURE FRACTION
         OI    FLAG,HEX80              TURN ON FRACTION FLAG
         MVI   NUM2,AZERO              MOVE IN CHARACTER ZERO
         MVC   NUM2+ONE(FIVE3),NUM2    SPREAD IT ALONG
         LA    R0,FIVE4                NUMBER OF DIGITS FOR MULTIPLYING
         CR    R5,R0                   HOW MANY DIGITS IN FRACTION
         BNH   LESS55                  IF 54 OR LESS BRANCH
         S     R5,TWENTY7              SUBRACT 27
         OI    FLAG,HEX04              FLAG TO INDICITE NOT FULL FRACT
         CR    R5,R0                   IS FRACTION STILL TOO LARGE
         BNH   LESS55                  IF SMALL ENOUGH BRANCH
         S     R5,TWENTY7              MAKE NUMBER SMALL ENOUGH
         OI    FLAG,HEX08              SET FLAG TO INDICATE FAKING
LESS55   LA    R6,NUM2(R5)             PACK THE FRACTION
         SR    R6,R8                   ALTER FRACTION POINTER.
         BCTR  R8,R0                   R8=EXECUTE LENGTH.
         EX    R8,MOVEA                LEFT ADJUST FRACTION.
         PACK  NUM4(EIGHT),NUM3+SEVEN(ONE5)       PACK
         PACK  NUM3+EIGHT(EIGHT),NUM1+ONE1(ONE1)  PACK
         MVN   NUM3+ONE5(ONE),NUM3+SIX            MOVE NUMERIC
         PACK  NUM3(EIGHT),NUM2+ONE2(ONE5)        PACK
         PACK  NUM1+EIGHT(EIGHT),NUM2(ONE1)       PACK
         MVN   NUM1+ONE5(ONE),NUM2+ONE1           MOVE NUMERIC
         MVC   NUM2(THREE2),NUM1+EIGHT            MOVE CHARACTER
         XC    NUM3(TWO4),NUM3                    AND (CLEAR)
         MVN   NUM4+SEVEN(ONE),PACK10+ONE         MOVE NUMERIC
         B     INTGREND                GO TO FRACTION PROCESSING PART
         EJECT
***********************************************************************
*                                                                     *
* THIS CODE IS REACHED WHEN PACKING AND FORMATTING ARE COMPLETED      *
* FOR INTEGER OR MIXED DATA.  IT SETS UP AND BEGINS CONVERSION OF     *
* THE INTEGER PORTION TO FLOATING POINT REPRESENTATION.               *
*                                                                     *
***********************************************************************
         SPACE
PACKDONE EQU   *                       PACKING IS DONE
         SR    R5,R5                   INITIALIZE DIVISION COUNTER
         LA    R4,THREE2(R2)           POINT TO LOC FOR FRACT MANTISSA
         LA    R1,DIVIDE               SAVE ADDRESS IN UNUSED REG.
         LA    R8,MORENUM7             SAVE ADDRESS IN UNUSED REG.
DIVIDE   DP    NUM2(ONE6),TWO56(TWO)   DIVIDE TO OBTAIN HEX DIGITS
         LA    R5,TWO(R5)              INC BY 2 FOR EACH DIVISION BY 16
         MVC   NUM4+SIX(TWO),NUM2+ONE4
         ZAP   NUM2(ONE6),NUM2(ONE4)   RIGHT ADJUST QUOTIENT
         C     R10,TWENTY7             FULL INTEGER INVOLVED IN DIVISIN
         BH    MORENUM1                NO.
         CVB   R0,NUM4                 YES CONTINUE
         STC   R0,ZERO(R4)             STORE HEX DIGIT PAIR OUTPUT AREA
         BCTR  R4,R0                   POINT 1 BYTE LEFT FOR NEXT TIME
         EJECT
***********************************************************************
*                                                                     *
* THE FOLLOWING CODE IS EXECUTED IF THE FULL INTEGER IS BEING INVOLVED*
* IN DIVISION AND CALCULATION OF THE EQUIVALENT HEX REPRESENTATION. IT*
* DECREMENTS THE INTEGER DIGIT COUNTER (R10) AND IF PROCESSING IS NOT *
* DONE RETURNS TO DIVIDE THE INTEGER AGAIN.                           *
*                                                                     *
***********************************************************************
         LA    R6,THREE                R6= 3
         CR    R10,R6                  HOW BIG WAS DIGIT COUNT
         BL    INTGRND1                IF 1 OR 2 WE ARE DONE DIVIDING
         LA    R7,NUM2+ONE6
         LR    R6,R10                  SAVE R10
         SRL   R6,ONE                  COMPUTE COUNT IN BYTES
         SR    R7,R6                   POINT TO FRONT OF QUOTIENT
         BCTR  R10,R0                  DECREMENT DIGIT COUNT
         BCTR  R10,R0                  DECREMENT DIGIT COUNT
         LA    R6,ONE                  TO CHECK R10 FOR EVEN OR ODD
         NR    R6,R10                  TO CHECK R10 FOR EVEN OR ODD
         BZ    ZEROFOX                 IF R10 IS EVEN BRANCH
         TM    ZERO(R7),HEXF0          CHECK FOR HIGH ORDER ZERO
         BCR   SEVEN,R1                BRANCH IF NONE TO DIVIDE
         B     BCTR                    GO DECREMENT DIVISION COUNTER.
ZEROFOX  TM    ZERO(R7),HEX0F          IS NEXT DIGIT ZERO ALSO
         BCR   SEVEN,R1                BRANCH IF NONE TO DIVIDE
BCTR     BCTR  R10,R1                  DECR INTEGER LENGTH AND REDIVIDE
         B     INTGRND1                GO PROCESS FRACTION PART.
         EJECT
***********************************************************************
*                                                                     *
* THE FOLLOWING CODE IS EXECUTED IF THE FULL INTEGER PART WAS NOT     *
* INVOLVED IN DIVISION. IT RECALCULATES THE INTEGER DIGIT COUNT AND   *
* FORMATS THE DIVIDEND FOR THE NEXT DIVISION.                         *
*                                                                     *
***********************************************************************
         SPACE
MORENUM1 EQU   *
         S     R10,TWENTY7
         MP    NUM2(ONE6),PACK10(TWO)   SHIFT LEFT ONE DIGIT
         BCT   R10,MORENUM2            IF NOT ZERO CONTINUE SHIFTING
         TM    NUM2+TWO,HEX0F          IS FIRSTT OUT
         BZ    MORENUM6                IF YES BRANCH
         BR    R8                      IF NO GO TO MORENUM7
MORENUM2 MP    NUM2(ONE6),PACK10(TWO)   SHIFT LEFT ONE DIGIT
         TM    NUM2+TWO,HEXF0
         BCR   SEVEN,R8                DIGIT NOT ZERO BRANCH MORENUM7
         BCT   R10,MORENUM4            OTHERWISE DECREMENT DIGIT COUNT
         BR    R8                      IF DIGIT COUNT IS ZERO BRANCH
MORENUM4 MP    NUM2(ONE6),PACK10(TWO)  MULTIPLY TO SHIFT OUT ZERO
         BR    R8                      BRANCH TO MORENUM7
MORENUM6 BCTR  R10,R0                  DECREMENT INTEGER COUNTER
MORENUM7 BCTR  R10,R0                  DECREMENT INTEGER COUNTER
         A     R10,TWENTY7             RESTORE FULL INTEGER DIGIT CNTER
         BR    R1                      GO BACK TO DIVIDE
         EJECT
***********************************************************************
*                                                                     *
* THE FOLLOWING CODE IS REACHED WHEN THE INTEGER PROCESSING IS        *
* COMPLETE. IT WILL PROCESS THE FRACTION IF ANY.                      *
*                                                                     *
***********************************************************************
         SPACE
INTGRND1 EQU   *                       INTEGER PART CONVTED TO FLOAT PT
         LR    R8,R5                   LOAD DIGIT COUNT
         SRL   R8,ONE                  COMPUTE BYTE COUNT
         BCTR  R8,R0                   DECREMENT FOR MOVE
         EX    R8,MOVEB                LFT ADJUST FRACT PART IN CONAREA
         TM    TWO(R2),HEXF0           IS FIRST DIGIT ZERO
         BNZ   INTGRND2                IF NO, OKAY AND BRANCH
         BCTR  R5,R0                   SUBRACT FROM DIGIT CNT (AND EXP)
         MVO   TWO(EIGHT,R2),TWO(EIGHT,R2)   SHIFT THE MANTISSA
         MVN   NINE(ONE,R2),HALFZERO    PUT IN A ZERO
INTGRND2 EQU   *
         STC   R5,NUM5                 SAVE FOR POSSIBLE USE LATER
         LA    R10,HEX40               LOAD BASE FOR EXPONENT
         CLI   FRACSGN,PLUS            IS NUMBER POSITIVE
         BE    PLUS3                   IF YES BRANCH
         LA    R10,HEX80(R10)          OTHERWISE CHANGE THE BASE
PLUS3    AR    R10,R5                  COMPUTE THE EXPONENT
         STC   R10,ONE(R2)             SAVE IT
         TM    FLAG,HEX80              WAS THERE A FRACTION PART
         BCR   EIGHT,R15               IF NO GO TO RETURN1
INTGREND LA    R4,ONE3(R2)             POINT TO FRACTION MANTISSA
         LA    R8,EIGHT                NUMBER OF SIGNIFICANT DIGITS
         SR    R5,R5                   MULTIPLICATION COUNTER
         SR    R7,R7                   CLEAR OUT A REGISTER
         TM    FLAG,HEX40              WAS THERE AN INTEGER PART
         BZ    MULTIPLY                IF NO START WORKING ON FRACTION
         MVC   NUM2(ONE6),NUM3         SETUP AREA FOR FRACT CONVERSION
         MVN   NUM1+ONE5(ONE),PACK10+ONE
MULTIPLY MP    NUM2(ONE6),TWO56(TWO)
         MP    NUM1(ONE6),TWO56(TWO)
         MVO   NUM1(TWO),NUM1(TWO)     SHIFT LEFT TO MAKE ROOM FOR SIGN
         MVN   NUM1+ONE(ONE),PACK10+ONE
         AP    NUM2(ONE6),NUM1(TWO)     ADD TO LOW ORDER PART OF NUM2
         STH   R7,NUM1                 CLEAR OUT HIGH TWO BYTES
         CLC   NUM2(TWO),HALFZERO      IS OVERFLOW ZERO
         BE    NEXTCHK1                IF YES BRANCH
         TM    FLAG,HEX0C              IS EITHER FAKING FLAG STILL ON
         BZ    NEXTCHK4                IF NO BRANCH
         BM    NEXTCHK8                IF ONLY ONE ON BRANCH
         NI    FLAG,(HEXFF-HEX08)      TURN OFF ONE FAKING FLAG
NEXTCHK9 MVC   NUM1(ONE6),NUM2         SHIFT STUFF TO LOW ORDER BUFFER
         XC    NUM2(ONE6),NUM2         CLEAR OUT HIGH ORDER BUFFER
         MVO   NUM2+ONE4(TWO),NUM1(TWO)
         MVN   NUM2+ONE5(ONE),PACK10+ONE
         STH   R7,NUM1                 SAVE R7 IN NUM1
NEXTCHKB LA    R5,TWO(R5)              INCREMENT MULTIPLY COUNTER
         B     MULTIPLY                GO DO IT AGAIN
NEXTCHK8 NI    FLAG,(HEXFF-HEX04)      TURN OFF REMAINING FAKING FLAG
         B     NEXTCHK9                GO TO COMMON FAKING PART
NEXTCHK1 TM    FLAG,HEX20              ARE WE COMPUTING SIGNIFIC DIGITS
         BZ    NEXTCHKB                IF NO BRANCH
NEXTCHK4 OI    FLAG,HEX20              INDICATE SIGNIFIC DIGIT FIGURING
         MVO   NUM4+SIX(TWO),NUM2(TWO)  MOVE INTO CLEAN AREA
         STH   R7,NUM2                 CLEAR OUT HIGH TWO BYTES
         CVB   R0,NUM4                 CONVERT TO TWO HEX DIGITS
         STC   R0,ZERO(R4)             SAVE THEM
         LA    R4,ONE(R4)              POINT 1 BYTE RIGHT FOR NEXT PAIR
         BCT   R8,MULTIPLY             IF LESS THAN EIGHT BYTES BRANCH
         LA    R4,ONE3(R2)             POINT TO BEGINNING OF MANTISSA
         TM    ZERO(R4),HEXF0          IS THERE A HIGH ORDER ZERO
         BNZ   FRACDONE                IF NO BRANCH
         MVO   ZERO(EIGHT,R4),ZERO(EIGHT,R4)
         LA    R5,ONE(R5)              ADD TO THE MULTIPLY COUNTER
         EJECT
***********************************************************************
*                                                                     *
* THE FOLLOWING CODE IS REACHED WHEN THE MANTISSA PORTION OF THE      *
* FLOATING POINT RESULT HAS BEEN CALCULATED. IT WILL CALCULATE THE    *
* CHARACTERISTIC OR ALIGN THE MANTISSA PORTION OF THE FRACTION IF THE *
* USER ENTERED NUMBER WAS A FRACTION OR MIXED INTEGER AND FRACTION    *
*                                                                     *
***********************************************************************
FRACDONE EQU   *
         LA    R2,ONE(R2)              POINT PAST THE LENGTH FIELD
         LA    R10,HEX40               LOAD BASE FOR EXPONENT
         STC   R5,NUM7                 SAVE MULTIPLICATION COUNTER
         SR    R10,R5                  FIGURE THE EXPONENT
         CLI   FRACSGN,PLUS            IS NUMBER POSITIVE
         BE    PLUS1                   IF POSITIVE BRANCH
         LA    R10,HEX80(R10)          INDICATE NEGATIVE NUMBER
PLUS1    TM    FLAG,HEX40              WAS THERE AN INTEGER PART
         BNZ   INTNFRAC                IF YES BRANCH
         STC   R10,ZERO(R2)            SAVE THE EXPONENT
         MVC   ONE(EIGHT,R2),ONE2(R2)
         BCTR  R2,R15                  RESTORE R2 AND GO TO RETURN1
INTNFRAC SR    R10,R10                 CLEAR OUT A REGISTER
         SR    R1,R1                   CLEAR OUT A REGISTER
         IC    R10,NUM7                LOAD FRACTION MULTIPLY COUNT
         IC    R1,NUM5                 LOAD INTEGER DIVISION COUNT
*        OBTAIN THE NUMBER OF DIGITS PLACES TO SHIFT TO ALIGN NUMBER
         LA    R1,TWO(R1,R10)          R1= NUMBER OF DIGIT PLACES
         LM    R4,R5,ONE2(R2)          LOAD R4, R5 FROM CONAREA
         LM    R6,R7,ONE6(R2)          LOAD R6, R7 FROM CONAREA
         LA    R0,SIX4                 R0= 64 USED FOR COMPARE
         SLL   R1,TWO                  MULTIPLY R1 BY 4
         CR    R1,R0                   IS SHIFT MORE THAN 64 BITS
         BNL   SHIFT64                 IF YES BRANCH
         SRL   R0,ONE                  R0= 32 USED FOR COMPARE
         CR    R1,R0                   IS SHIFT MORE THAN 32 BITS
         BNL   SHIFT32                 IF YES BRANCH
         SRDL  R4,ZERO(R1)
         SRDL  R6,ZERO(R1)
         A     R4,ZERO(R2)             ADD R4 WITH CONAREA
         A     R5,FOUR(R2)             ADD R5 WITH CONAREA
         A     R7,EIGHT(R2)            ADD R7 WITH CONAREA
         LR    R6,R7                   R6 = CREATED SUM IN R7
         STM   R4,R6,ZERO(R2)          STORE R4, R5, R6 IN CONAREA
         BCTR  R2,R15                  RESTORE R2 AND GO TO RETURN1
SHIFT32  SR    R1,R0                   SHIFT 32 BITS (OR MORE)
         SRDL  R4,ZERO(R1)
         A     R4,FOUR(R2)             ADD R4 WITH CONAERA
         A     R5,EIGHT(R2)            ADD R5 WITH CONAERA
         STM   R4,R5,FOUR(R2)          STORE R4, R5 IN CONAREA
         BCTR  R2,R15                  RESTORE R2 AND GO TO RETURN1
SHIFT64  SRDL  R4,ZERO(R1)             SHIFT OF 64 BITS
         A     R4,EIGHT(R2)            ADD R4 WITH CONAREA
         ST    R4,EIGHT(R2)            STORE R4 IN CONAREA
BCTR2    BCTR  R2,R0                   DECREMENT BY ONE
***********************************************************************
* THE FOLLOWING CODE COMPUTES THE OUTPUT LENGTH EITHER FOUR OR EIGHT  *
* BYTES AND SAVES THE LENGTH IN CONAREA FOR IKJEGPCH. IT THEN CHECKS  *
* THE FLOATING POINT REPRESENTATION AND ROUNDS IT IF NECESSARY.       *
* FINALLY IT CHECKS THE HIGH ORDER MANTISSA BYTE FOR ZERO             *
***********************************************************************
         SPACE
RETURN1  MVI   ZERO(R2),HEX08          SET LENGTH TO 8
         LA    R15,ENDFLT              POINT TO ENDFLT
         CLI   TYPE,HEX1C              DOUBLE OR SINGLE PRECISION
         BE    LNGROUND                IF DOUBLE BRANCH
         MVI   ZERO(R2),HEX04          SET LENGTH TO 4
*        THIS GROUP OF CODE ROUNDS THE RESULTS
         LA    R2,ONE(R2)              POINT PAST LENGTH FIELD
         CLI   FOUR(R2),HEX80          IS IT NECESSARY TO CHANGE OUTPUT
         BCR   FOUR,R15                NO ROUNDING NECESSARY TO ENDFLT
         L     R4,ZERO(R2)             LOAD RESULT
         LA    R5,ONE                  R5 = ONE
         AR    R4,R5                   ADD ONE
         ST    R4,ZERO(R2)             STORE RESULT
         B     FINALCK                 CHECK FOR 0 HIGH ORDER MANTISSA
LNGROUND EQU   *
         LA    R2,ONE(R2)              POINT PAST LENGTH FIELD
         CLI   EIGHT(R2),HEX80         IS IT NECESSARY TO CHANGE OUTPUT
         BCR   FOUR,R15                NO ROUNDING NECESSARY TO ENDFLT
         LD    R2,ZERO(R2)             LOAD INTO FLOATING PT REGISTER
         XC    ONE(SEVEN,R2),ONE(R2)   CLEAR OUT FRACTION
         MVI   SEVEN(R2),HEX01         MOVE IN ONE
         AW    R2,ZERO(R2)             ADD TO ROUND
         STD   R2,ZERO(R2)             REPLACE RESULT
FINALCK  CLI   ONE(R2),HEX00
         BCR   SEVEN,R15               IF NOT ZERO GO TO ENDFLT
         MVI   ONE(R2),HEX10
         BR    R15                     GO TO ENDFLT
         EJECT
***********************************************************************
* THE FOLLOWING IS A GROUP OF DESECT USED BY THE CSECT'S
***********************************************************************
         TITLE 'IKJEGCVT PDE DSECT.'
         IKJPARMA
         TITLE 'IKJEGCVT TEST COMMUNICATION TABLE.'
         TCOMTAB
CVTWORK  DSECT
         SPACE
***********************************************************************
*                                                                     *
* THIS DSECT MAPS A SECTION OF THE WORKAREA POINTED TO BY 'WORKAREA'  *
* IN TCOMTAB.                                                         *
*                                                                     *
***********************************************************************
         SPACE
FLTINPUT DS    D                       LOCATION FOR FLTPT INPUT STRING.
PACKAREA DS    D                       LOCATION FOR PACKED DEC CONSTANT
FLTSTG   DS    5D                      FLOATING PT WORKAREA.
FLTLEN   DS    H                       SAVE LENGTH AREA.
         ORG   *-58                    POINT TO BEGINNING OF WORK AREA
NUM2     DS    4F                      WORK SPACE FOR CONVERSION
NUM1     DS    4F                      ***
NUM3     DS    4F                      ***
NUM4     DS    2F                      AREA FOR CVB OF EXPONENT
FRACSGN  DS    CL1                     SIGN OF USER ENTERED FRACTION
EXPSIGN  DS    CL1                     SIGN OF USER ENTERED EXPONENT
FLAG     DS    CL1                     USED TO INDICATE NUMBER TYPE
EXPON    DS    CL1                     USER ENTERED EXPONENT OR ZERO
NUM7     DS    CL1                     ***
NUM5     DS    CL1                     ***
COEFF    DS    CL1                     COEFFICIENT DIGIT COUNT
TYPE     DS    CL1                     DOUBLE OR SINGLE PRECISION
         ORG   *-1                     BACK UP ONE BYTE
CODE370  DS    X                       370 OP CODE FLAG.
CHAR5    EQU   X'01'                   MNEUMONIC IS 5 CHARS.
SSIMM    EQU   X'02'                   SS FORMAT,L1 & I3.
IKJEGFLT CSECT
FLTMOVE  MVC   FLTINPUT+ONE(ONE),ONE(R1) FRACTION NOW IN WORKAREA.
MOVEFLT  MVC   FLTSTG(ONE),FLTSTG+ONE  LEFT JUSTIFY ZONE DECIMAL.
ALIGNMVC MVC   ZERO(ONE,R5),ZERO(R8)   FRACTION NOW MOVED FOR ADD.
ZONEMOVE MVC   FLTSTG(ONE),ZERO(R8)    ZONED DECIMAL NOW LEFT JUSTIVIED
ZONEJUST MVC   ZERO(ONE,R8),ONE(R8)    INPUT NOW LEFT JUSTIFIED.
OUTMVC   MVC   ONE(ONE,R2),FLTSTG-TWO  MOVE STRING INTO OUTPUT AREA
PACKA    PACK  NUM2(ONE6),ZERO(ZERO,R1)
PACKB    PACK  NUM3+TWO(ZERO),ZERO(ZERO,R1)
PACKE    PACK  NUM4+SIX(TWO),ZERO(ZERO,R7)
CLC1     CLC   ZERO(ZERO,R1),NUM1
MOVE1    MVC   NUM1(ZERO),ZERO(R1)
MOVEA    MVC   ZERO(ZERO,R6),ZERO(R1)
MOVEB    MVC   TWO(ZERO,R2),ONE(R4)
ROUNDPK  PACK  FLTINPUT(ONE),FLTSTG(ONE) SIGNIFICANT DIGITS NOW PACKED.
ADD5     AP    FLTINPUT(ONE),PACK5(ONE) ROUND VALUE.
UNPKSIG  UNPK  FLTSTG(ONE),FLTINPUT(ONE) SIGNIFICANT DIGITS NOW ZONED.
         DS    0F
SIGNOFF  DC    X'0000007F'             VALUE TO CLEAR HIGH ORDER.
FLTCON   DC    A(IKJEGFLT)             ADDR OF FLOATING POINT ROUTINE.
CVTVAL   DC    X'3B9ACA00'             10**9 USED TO CONVERT FIXED DEC.
FLTCLEAR DC    X'0000000F'             FULL WORD 15
DOBLFLT  DC    X'0008'                 HALFWORD 8 FOR CHARACTERISTICS.
FLT20    DC    H'20'                   HALFWORD 20.
PACK10   DC    PL2'10'                 PACKED 10
TWO56    DC    PL2'256'                PACKED 256
HALFZERO DC    H'0'                    HALFWORD ZERO
FLT17    DC    H'17'                   HALFWORD 179
HALFONE  DC    H'1'                    HALFWORD 1.
TWENTY7  DC    F'27'                   FULLWORD 27
FLTDEC2  DC    H'2'                    FIXED DECIMAL 2 FOR FLOATING PT.
FLTCHAR  DC    X'0046'                 FLOATING PT CHARACTERISTIC + 6
FLT64    DC    H'64'                   HALF WORD 64.
FLT10    DC    H'10'                   HALF WORD 10.
EXPCHAR  DC    C' E+  '                EXPONENT PATTERN.
FLPTZERO DC    X'02'                   OUTPUT FOR ZERO VALUE.
         DC    C'+0'                   *
FRACSIGN DC    C'+.'                   FRACTION SIGN PATTERN.
FLTPATTN DC    C'0'                    PATTERN FOR EDIT INSTRUCTION.
         DC    18X'20'                 *
PACK5    DC    P'5'                    PACKED 5
REMDATA  EQU   FLTSTG+15               LOC FOR REMAINDER OF FLT PT.
HEX9     EQU   X'09'                   A HEX 9.
         END
