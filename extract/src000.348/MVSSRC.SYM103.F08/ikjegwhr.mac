         TITLE 'IKJEGWHR, ''WHERE'' SUBCOMMAND OF TEST'
*C55300,65600,69400,75000                                      @YM07131
*D143200,144000,148000,160000-162400                           @ZA07138
*C144800,147200                                                @ZA07138
***********************************************************************
*                                                                     *
* STATUS -- CHANGE LEVEL 000   VERSION NO. 02  OS/VS2                 *
*                                                                     *
* FUNCTION -- THIS SUBCOMMAND RESULTS IN THE QUALIFICATION (ABSOLUTE  *
*    ADDRESS) FOR THE SPECIFIED ADDRESS BEING DISPLAYED AT THE        *
*    TERMINAL. IF NO ADDRESS IS ENTERED THE INSTRUCTION COUNTER OF THE*
*    CURRENT PROBLEM PROGRAM IS DISPLAYED. IF AN ADDRESS IS AN        *
*    UNQUALIFIED SYMBOLIC OR RELATIVE, THE CURRENT INPLICIT           *
*    QUALIFICATION IS DISPLAYED. IF THE ADDRESS IS ABSOLUTE ADDRESS,  *
*    OR AN ADDRESS EXPRESSION, AN ATTEMPT IS MADE TO LOCATE THE       *
*    ADDRESS WITHIN THE SUBTASK CONTENTS STRUCTURE. IF THE ADDRESS IS *
*    FOUND TO FALL WITHIN THE STORAGE EXTENT OF ANY PROGRAM ASSIGNED  *
*    TO THE PROBLEM PROGRAM TASK OR ANY OF ITS SUBTASKS, THE LOCATION *
*    WITHIN THE PROGRAM OF THE SPECIFIED ADDRESS IS DISPLAYED AT THE  *
*    TERMINAL. IT IS IDENTIFIED BY LOAD MODULE NAME, ENTRYNAME (IF    *
*    THE CESD IS AVAILABLE) AND DISPLACEMENT FROM THE BEGINNING OF    *
*    THE LOWEST LEVEL OF QUALIFICATION AVAILABLE. IF MORE THAN ONE    *
*    TASK EXISTS ON THE SUB-TASK QUEUE, THE TCB ADDRESS IS ALSO       *
*    DISPLAYED. IF LOADNAME.ENTRYNAME IS SPECIFIED THE ABSOLUTE       *
*    ADDRESS OF THE SPECIFIED LOAD MODULE ENTRY POINT IS DISPLAYED.   *
*    ENTRYNAME MAY HAVE BEEN OMITTED, IN WHICH CASE THE BEGINNING     *
*    ADDRESS AT WHICH THE LOAD MODULE IS LOADED IS DISPLAYED. IF MORE *
*    THEN ONE TASK EXISTS ON THE SUBTASK QUEUE, THE TCB ADDRESS IS    *
*    ALSO DISPLAYED. IF AN IDENTICAL LOAD MODULE EXISTS ON ANOTHER    *
*    SUBTASK, THE SAME INFORMATION IS DISPLAYED AS ABOVE FOR THE      *
*    SECOND OCCURRENCE OF THE MODULE.                                 *
*                                                                     *
* ENTRY POINTS --                                                     *
*         IKJEGWHR -- INITIAL ENTRY POINT.                            *
*         ADDRVLCK -- VALIDITY CHECK ROUTINE.                         *
*                                                                     *
* INPUT -- IS IS EXPECTED THAT REGISTER 9 POINTS TO TCOMTAB UPON      *
*    ENTRY TO IKJEGWHR. TCOMTAB IS THE COMMUNICATIONS AREA FROM       *
*    WHICH ALL NEEDED INFORMATION MAY BE ACCESSED.                    *
*                                                                     *
* OUTPUT -- DATA MESSAGES CONTAINING PERTINENT INFORMATION, I.E.,     *
*    ABSOLUTE QUALIFICATION, OFFSET, LOADNAME, CSECTNAME AND TCB      *
*    ADDRESS, ARE PRINTED ON THE TERMINAL LISTING.                    *
*                                                                     *
* EXTERNAL REFERENCES --                                              *
*         IKJPARS IS ENTERED TO CHECK SYNTAX OF WHERE SUBCOMMANDS. IN *
*         ADDITION, MUCH OF THE ADDRESS PROCESSING IS DONE WHILE IN   *
*         IKJPARS.                                                    *
*                                                                     *
*         IKJEGCVT IS ENTERED TO CONVERT THE USER SUPPLIED ADDRESS    *
*         TO HEXIDECIMAL                                              *
*                                                                     *
*         IKJEGSYM IS ENTERED FIRST TO ACCESS A CSECT NAME IN THE     *
*         INDICATED LOADNAME, AND SECOND TO SEARCH THE SYMBOL TABLE   *
*         FOR A GIVEN LOADNAME.CSECT.                                 *
*                                                                     *
*         IKJEGIO IS CALLED TO PRINT INDICATED MESSAGES.              *
*                                                                     *
* EXITS, NORMAL -- WHEN ALL ADDRESS PROCESSING IS COMPLETED, IKJEGWHR *
*         RETURNS TO MAINLINE.                                        *
*                                                                     *
* EXITS, ERROR  --                                                    *
*         NONE                                                        *
*                                                                     *
* TABLES/WORK AREAS -- THE WORKAREA POINTER PROVIDED IN TCOMTAB IS    *
*    THE ONLY WORKAREA USED.                                          *
*                                                                     *
* ATTRIBUTES -- REFRESHABLE AND REENTRANT                             *
*                                                                     *
* CHARACTER CODE DEPENDENCY --                                        *
*                                                                     *
* NOTES -- IBM STANDARD LINKAGE CONVENTIONS WERE USED.                *
*                                                                     *
* CHANGE-ACTIVITY --                                                  *
*                 APAR OZ07138 - CHANGES TO USE A POINTER TO THE      *
*                 BREAKPOINT SVRB IN TCOMTAB WHEN LOOKING FOR THE     *
*                 PSW FOR THE PROBLEM PROGRAM. THE POINTER IS AT      *
*                 ECBPP+1.                                            *
*                                                                     *
***********************************************************************
         EJECT
         COPY  IKJEGSIO
         EJECT
IKJEGWHR CSECT
         ENTRY IKJEGVLC       ENTRY POINT FOR VALIDITY CHECK
         USING TCOMTAB,R9     OF ADDRESS. ESTABLISH TCOMTAB
         SAVE (14,12)         ADDRESSIBILITY. SAVE REGISTERS
************************************************************
**                                                        **
** AFTER REGISTERS HAVE BEEN SAVED THE ADDRESS OF A       **
** SAVE AREA IS OBTAINED FROM TCOMTAB. FORWARD AND BACK   **
** WARD CHAINING IS ACCOMPLISHED. THE ADDRESS OF THE PCL  **
** (PARAMETER CONTROL LIST) IS PLACED INTO A REGISTER TO  **
** BE PUT WITHIN THE PARAMETER LIST TO BE PASSED TO PARSE.**
** THE PARAMETER LIST WILL BE BUILT IN THE WORKAREA WHOSE **
** ADDRESS IS GOTTEN FROM TCOMTAB. PARMLIST  ADDRESS IS   **
** ALSO GOTTEN FROM TCOMTAB. PARMLIST CONTAINS UPT, ECT   **
** AND CHECK ELEMENTS OF THE PARAMETER LIST. ADDRESS OF   **
** MY SAVE AREA IS ALSO PLACED INTO THE LIST. THE COMPLETE**
** LIST IS PASSED TO THE PARSING ROUTINE VIA REG 1 AND    **
** THE LINK MACRO                                         **
************************************************************
         LR    R12,R15        RESTORE R12 TO BEGINNING ADDR
         USING IKJEGWHR,R12   USE ENTERING ADDRESS FOR ADDRESSING
         L     R2,REGSAVE2    GET ADDR OF MY SAVE AREA FROM TCOMTAB
*                             ADDRESS OBTAINED FROM TCOMTAB
         ST    R13,@4(@0,R2)  STORE CALLERS SAVE AREA ADDR
         ST    R2,@8(R13)     STORE MY SAVE IN CALLERS
         LR    R13,R2         PLACE ADDR OF MY SAVEAREA INTO
*                             REG13
         L      R10,WORKAREA  ACCESS WORKAREA ADDR FROM TCOMTAB
         MVC   CWORKCMD-TSTCWORK(ENDLIST,R10),LISTSTAE STAE IN WORKAREA
         LA    R1,CWORKCMD-TSTCWORK(R10)  PARAMETER TO STAE
         L     R2,TSTSTAE     ADDR OF STAE EXIT ROUTINE
         ST    R12,@68(R13)   SAVE BASE REGISTER
         ESTAE (R2),PARAM=LISTESTA,RECORD=YES,MF=(E,(R1))  ISSUE ESTAE
         LTR   R15,R15        TEST STAE RETURN CODE
SMTSTAE  DS    0H             TEST CASE TWHR2700
         BZ    ESTAEOK        BRANCH IF ESTAE ISSUED IS OK
         STC   R15,TSTESTRC   STORE RET. CODE IN TCOMTAB
         LA    R15,@24        SEND RC=24 TO MAINLINE
         B     RETS           BRANCH TO RETURN
ESTAEOK  EQU   *              ESTAE WAS ISSUED
         TM    TSTFLGS3,NOPARMS TEST FOR PARM FIELD WITH WHERE
         BO    A0009          IF ON, SKIP PARSE AND PROCESS IC
         EJECT
         L     R4,PARSELST    LOAD PARSE TABLE ADDR INTO REG4
         L     R1,WORKAREA    LOAD WORKAREA ADDR FROM TCOMTAB
         LA     R1,PPLSAVE-TSTCWORK(R1) ACCESS COMMAND PORTION
         USING PPL,R1         ESTABLISH PPL ADDRESSABILITY
         MVC   PPLUPT(@4),TSTUPT PTR TO UPT FOR PARSE
         MVC   PPLECT(@4),TSTECT PTR TO ECT FOR PARSE
         MVC   PPLECB(@4),TSTCPECB PTR TO CP ECB FOR PARSE
         ST    R4,PPLPCL      PTR TO PCL FOR PARSE
         ST    R13,PPLUWA     PTR TO MY SAVE AREA FOR PARSE
         LA    R4,TSTANSPL    ACCESS ADDR OF ANSWER PLACE
         ST    R4,PPLANS      PTR TO ANSWER PLACE FOR PARSE
         MVC   PPLCBUF(@4),INBUF PTR TO COMMAND BUFFER
         DROP  R1             DROP PPL ADDRESSABILITY
         LA    R4,I0040       IKJPARS INSERT
         LINK  EP=IKJPARS,ERRET=LINKFL1
BLOW1    DS    0X              STAE ENTRY POINT
SMTPARS  DS    0H             TEST CASE TWHR2600
         BAL   R14,CHKCDE     TO TEST PARSE RETURN CODE
         EJECT
         L     R2,TSTANSPL    ACCESS PDE POINTER
         USING IKJPARMD,R2    ESTABLISH PDL ADDRESSABILITY
         LA    R2,GETADDR     ACCESS ADDR OF PDE
         DROP  R2             DROP PDL ADDRESSABILITY
         USING IKJPARMA,R2    ESTABLISH PDE ADDRESSABILITY
         L     R3,PDEUSER     ACCESS USER WORD
         LTR   R3,R3          TEST IF NO PARAMETERS ENTERED
*                             (ONLY APPLIES IF NULL RETURN IS USED
*                             DURING REENTER MODE)
         BNZ   A0008          BYPASS PUTTING OUT IC
         TM    PDEFLG4,ABSADDR+SYMADDR TEST FOR ABSOLUTE 0
         BZ    A0009          TO PUT OUT IC
A0008    EQU    *             EQUATE LABEL TO THIS ADDRESS
         XR    R15,R15        ZERO OUT R15 FOR RETURN CODE
         DROP  R2
         EJECT
RET      DS    0X
         LR    R2,R15         SAVE RET CODE OVER ESTAE
         ESTAE 0              REMOVE ESTAE REQUEST
         LR    R15,R2         RESTORE RETURN CODE
         NI    TSTFLGS4,HEXFF-TSTRERTN  SHUT OFF RETRY FLAG
RETS     DS    0X             RETURN TO MAINLINE
         L     R13,@4(R13)
         RETURN (14,12),RC=(15) RETURN TO MAINLINE
         EJECT
CHKCDE   DS    0X
         B     *+@4(R15)      BRANCH ACCORDING TO CODE
         BR    R14            RETURN CODE = 0
         BR    R14            FOR ALIGNMENT PURPOSES
         B     RETCDE4        RETURN CODE = 4
         B     RETCDE8        RETURN CODE = 8
         B     RETCDE12       RETURN CODE = 12
         B     RETCDE16       RETURN CODE = 16
         B     RETCDE20       RETURN CODE = 20
         EJECT
A0009    DS    0X              EQUATE LABEL TO ADDRESS
*************************************************************
**AT THIS POINT WE ASSUME NO SUB-COMMANDS HAVE BEEN ENTERED**
**AND WILL RETURN TO THE TERMINAL THE CURRENT INSTRUCTION  **
**COUNTER ADDRESS.                                         **
*************************************************************
         L     R4,ECBPP       GET ADDRESS OF SVC 97 REQUEST BLK@ZA07138
         USING RBSECT,R4      USE REG4 TO ADDRESS RB
         L     R4,RBLINK      GET ADDRESS OF PROBLEM PROG PRB  @ZA07138
         L     R2,RBOPSW+@4   LOAD RESUME PSW
         BAL   R14,CONVERT    BRANCH TO CONVERT ROUTINE
         L     R1,OUTBUF      PLACE POINTER TO OUTPUT AREA IN R1
         EX    R10,ICMVC      PUT CONVERTED IC IN BUFFER
         LA    R3,@6(R10)     CREATE LENGTH COUNT
         STH   R3,@0(R1)      PLACE LENGTH FIELD INTO FIRST WORD
         LA    R10,@5(R10,R1) UPDATE BUFFER POINTER
         MVI   @0(R10),DOT    PERIOD TO INDICATE ABSOLUTE ADDRESS
         XC    TSTIOPRM,TSTIOPRM  CLEAR PARAMETER AREA
         LR    R4,R1          REG 4=PTR TO DATA
         IKJEGSIO DATA,DATAPTR=(R4),ID=WHR32,MF=(E,TSTIOPRM)
         NI    TSTFLGS2,HEXFF-TADDROUT TURN OFF MSG PUT TO TERM SW
         B     COMMON         GO CHECK RET CODE FROM IO
ICMVC    MVC   @4(@1,R1),@0(R2)  MOVE EBCDIC ADDRESS INTO OUTPU T
         DROP  R4
RETCDE4  DS    0X
         OI    TSTFLGS4,TSTFLUSH TELL MNLINE TO FLUSH STACK
         B     A0008          RETURN TO MNLINE WITH ZERO
RETCDE12 DS    0X
         LA    R2,M0104       MSG-WHERE FAILED, CMMND SYS ERR
         LA    R3,M0277       MSG-PARSE ERROR CODE 12
         BAL   R6,MSG2        GO OUTPUT THE MESSAGES
         B     COMMON         CHECK RET CODES, RETURN
RETCDE16 DS    0X
         LA    R2,M0103       MSG-NOT ENOUGH CORE
         LA    R3,@0          NO SECOND LEVEL MESSAGE
         BAL   R6,MSG1        GO OUTPUT THE MESSAGES
         B     COMMON         CHECK RET CODES, RETURN
RETCDE20 DS    0X
         L     R8,WORKAREA    ACCESS PTR TO WORKAREA
         L     R15,CODESAVE-TSTCWORK(R8) ACCESS STORED RETURN CODE
         LA    R14,@16        FOR RETURN CODE COMPARISON
         CR    R15,R14        TEST RETURN CODE
         BE    RET            IF EQUAL RETURN 16 TO MNLINE
         BH    SEND20         OHTERWISE SEND 20 TO MNLINE
         XR    R15,R15        SEND 0 IF LESS THAN 16
         B     RET            RETURN TO MNLINE
SEND20   DS    0X
         LA    R15,@20        RETURN CODE TO MAINLINE
         B     RET            RETURN TO MNLINE
RETCDE8  DS    0X
         LA    R15,@16        RETURN CODE TO MNLINE
         B     RET            RETURN TO MNLINE
COMMON   DS    0X
         L     R2,WORKAREA    ACCESS WORKAREA PTR
         CH    R15,ATTNCODE   COMPARE RET CODE TO 16
         BNL   RET            RET CODE NOT LESS THAN 16
         B     A0008          RETURN TO MNLINE WITH ZERO
         EJECT
RETRY    DS    0X
         L     R2,@16         ACCESS PTR TO CVT
         USING CVT,R2         ESTABLISH CVT ADDRESSABILITY
         L     R3,CVTTCBP     ACCESS TCB PTR
         L     R3,@4(R3)      ACCESS CURRENT TCB PTR
         USING TCB,R3         ESTABLISH TCB ADDRESSABILITY
         L     R9,TCBTRN      PTR TO TCOMTAB
         L     R13,REGSAVE2   ACCESS SAVE AREA
         L     R12,@68(R13)   ACCESS BASE REGISTER
         DROP  R2             DROP CVT ADDRESSABILITY
         DROP  R3             DROP TCB ADDRESSABILITY
         NI    TSTFLGS2,HEXFF-TADDROUT-TOFFDEF  TURN OFF FLAGS
         NI    TSTFLGS1,HEXFF-TSTFIRST TURN OF FLAG
         LA    R15,@20        RETURN CODE OF 20 TO MAINLINE
         B     RET            RETURN CONVENTIONS
         EJECT
************************************************************
** PARSE WILL LINK TO THIS ADDRESS SO THAT WE MAY         **
**VALIDITY CHECK THE ADDRESS ENTERED THRU THE TERMINAL    **
** WE WILL TRY USING IKJEGCVT AND IKJEGSYM PLUS ACTUALLY  **
** LOOKING FOR THE ADDRESS WITHIN THE CONTROL BLOCKS      **
** STRUCTRUE TO CHECK WHETHER THE ADDRESS IS VALID        **
** INVALID ADDRESSES ARE FLAGGED AS SUCH AND ASKED TO BE  **
** REENTERED.                                             **
************************************************************
IKJEGVLC DS    0X
         SAVE  (14,12)        SAVE REGISTERS             ***
         DROP  R12            DROP R12 AS BASE REGISTER    *
         USING IKJEGVLC,R15   ESTABLISH E.P. ADDRESSABILITY* ESTABLISH
         L     R2,@4(R1)      ACCESS MY REGISTER SAVEAREA  *
         LM    R3,R12,@32(R2) RESTORE REGISTERS 3 THRU 12  *ADDRSABLITY
         USING IKJEGWHR,R12   ESTABLISH ADDRESSABILITY     *
         DROP  R15            DROP R15 AS BASE REGISTER  ***
*                                                        ***
         L     R2,REGSAVE3    ACCESS MY SAVE AREA ADDRESS  * STANDARD
         ST    R13,@4(R2)     SAVE CALLERS SAVEAREA        *
         ST    R2,@8(R13)     STORE MY SAVE IN CALLERS     * LINKAGE
         LR    R13,R2         MY SAVE AREA INTO R13        *
*                                                        ***CONVENTIONS
         SR    R14,R14        CLEAR REG 14
         L     R4,OUTBUF      ACCESS POINTER TO OUTBUF
         ST    R14,@0(R4)     CLEAR 1ST WORD OF OUTBUF
         OI    TSTFLGS4,TSTVALCK  INDICATE VALIDITY ROUTINE
         NI    TSTFLGS2,HEXDF-TADDROUT TURN OFF MSG PUT TO TERM SW
*                                       AND INIT LOAD LIST INDICATOR
         L     R2,WORKAREA    ACCESS PTR TO WORKAREA
         LA    R3,@8(R1)      CREATE PTR TO PARSE 3RD WORD
         ST    R3,MSGADDR-TSTCWORK(R2) FUTURE PTR TO 2ND LEVEL MSG
*
         L     R7,@0(R1)      ACCESS PDE ADDRESS
         USING IKJPARMA,R7    ESTABLISH PDE ADDRESSABILITY
         TM    PDEFLG4,GENR   TEST FOR REGISTER NOTATION
         BNO   FLTREG         BRANCH FOR FURTHER VALIDITY CHECK
         LH    R3,PDEINDCT    ACCESS INDIRECT COUNT
         LTR   R3,R3          IF 0, THEN INVALID REGISTER SPECIFICATION
         BNZ   FLTREG         BRANCH FOR FURTHER VALIDITY CHECK
         B     BADADDR        BRANCH TO OUTPUT ERROR MESSAGES
FLTREG   DS    0X
         TM    PDEFLG4,LFPR+SFPR TEST FOR FLOATING POINT REGISTER
         BZ    PROCESS        IF NOT SPECIFIED, PROCESS ADDRESS STING
BADADDR  DS    0X             OUTPUT ERROR MESSAGES
         LA    R2,M0101       MSG-INVALID ADDRESS
         LA    R3,M0274       MSG-REG NOT. MUST BE INDRT GEN REG
         LR    R4,R7          ADDRESS PDE
         B     MSG3           GO OUTPUT THE MESSAGES
PROCESS  DS    0X
         L     R3,WORKAREA              ***
         LA    R3,PDESAVE-TSTCWORK(R3)    * SAVE PDE IN WORKAREA
         MVC   @0(@25,R3),@0(R7)        ***
*                                                          ***
         TM    PDEFLG2,CTNAMFLG TEST IF CSECT NAME SPECIFIED *
         BO    QUALSYM        IF SPECIFIED, BRANCH           * TEST FOR
         L     R3,PDEEXPTR    ACCESS ADDRESS OF ADDR EXP     *
         LA    R3,@0(R3)      ZERO HI ORDER BYTE             *
         LTR   R3,R3          TEST FOR ADDR EXP              *
         BNZ   ADDRPROC       IF ADDR EXP, BRANCH            *
         TM    PDEFLG3,AFLG   TEST FOR ADDR STRING           *QUALIFIED
         BNO   ADDRPROC       IF NOT SPECIFIED, BRANCH       * SYMBOL
         TM    PDEFLG4,SYMADDR TEST FOR SYMBOLIC ADDR        *
         BNO   ADDRPROC       IF NOT SYMBOL, BRANCH        ***
         B     SYMBOL         BRANCH IF IT IS A SYMBOL
SYMBOL   DS    0X
         MVC   PDELDNAM(@6),PDEADRPT SYMBOL AND LEN INTO LDNAME
         L     R1,TSTTCB      ACCESS TEST'S TCB
         L     R2,WORKAREA    ACCESS WORKAREA PTR
         LA    R1,@0(R1)      CLEAR HI ORDER BYTE
         ST    R1,TCBCHAI-TSTCWORK(R2) STORE MOTHER TCB
GOCDE    DS    0X
         BAL R14,TCBCHAIN     BRANCH TO GET TCB ON CHAIN
         LTR   R1,R1          TEST FOR END OF TCB CHAIN
         BZ    ENDTCB         BRANCH IF END OF CHAIN
         USING TCB,R1         ESTABLISH TCB ADDRESSABILITY
         TM    TCBFLGS5,TCBFC TEST IF TCB TERMINATED
         BO    GOCDE          IF TERMINATED, GET NEXT TCB ON CHAIN
         DROP  R1             DROP ADDRESSABILITY TO TCB
         BAL   R14,CDESRCH    SEARCH CDE FOR LOADNAME MATCH
         LTR   R0,R0          TEST IF LOADNAME MATCH FOUND
         BZ    GOCDE          IF NOT GET NEXT TCB
         ST    R0,PDEUSER     IF FOUND, STORE LOCATED AT ADDR
         OI    TSTFLGS2,TADDROUT INDICATE MATCH FOUND (MSG OUTPUT)
         BAL   R14,LDNMSG     TO BUILD AND OUTPUT MSG
         L     R1,TCBSAVE-TSTCWORK(R8) ACCESS STORED TCB
         LTR   R11,R11        IS THERE A RETURN ADDRESS INDICATED
         BZ    GOCDE          GET NEXT TCB
         BR    R11            TO CONTINUE PROCESSING THE PRESENT TCB
ENDTCB   DS    0X
         XR    R15,R15        INDICATE ZERO RETURN CODE
         TM    TSTFLGS2,TADDROUT WAS ANY LOADNAME MATCH FOUND
         BO    GOHOME         IF SO, RETURN TO PARSE
         L     R2,WORKAREA    OTHERWISE, ACCESS WORKAREA PTR
         MVC   PDELDNAM(@25),PDESAVE-TSTCWORK(R2) RESTORE PDE
         B     ADDRPROC       BRANCH TO FURTHER SEARCH
QUALSYM  DS    0X
         TM    PDEFLG1,LDNAMFLG TEST IF LOADNAME IS WITH CSECT NAME
         BO    ADDRPROC       IF SO PROCESS ADDRESS
         L     R3,WORKAREA    ACCESS WORKAREA POINTER
         MVC   CURLD-TSTCWORK(@8,R3),TSTCURLD MOVE CURRENT LOADNAME
         LA    R4,@8          INITIALIZE REG WITH MAX LEN 8
         LA    R5,CURLD-TSTCWORK(R3) CREATE PTR TO LOADNAME
         ST    R5,PDELDNAM    STORE PTR IN PDE
         LA    R5,@7(R5)      UPDATE PTR TO END OF LOADNAME
CHKBLNK  DS    0X                                       *****
         CLI   @0(R5),BLANK   TEST LAST CHAR FOR BLANK     * REMOVE
         BNE   STLEN          IF NOT BLANK, BRANCH         *  BLANK
         BCTR  R4,R0          DECREMENT LENGTH COUNTER     * PADDING
         BCTR  R5,R0          DECREMENT PTR TO LOADNAME    *  IF ANY
         B     CHKBLNK        TO TEST FOR BLANK        *****
STLEN    DS    0X
         STH   R4,PDELEN1     STORE CALCULATED LENGTH IN PDE
         B     ADDRPROC       TO PROCESS ADDR
ADDRPROC DS    0X                                    ***
         LA    R0,@4          MAKE R0 POSITIVE        *
         LR    R1,R7          ACCESS ADDR OF PDE      *
         LCR   R1,R1          INDICATOR TO TSTCONVT   * CONVERT ADDRESS
         NI    TSTFLGS3,HEXFF-SYMMESG INDICATE PRINT  *
         L     R15,TSTCONVT   ACCESS ADDR OF TSTCONVT *
         BALR  R14,R15        BRANCH TO CONVERT     ***
         BAL   R14,CODECHK    TO TEST RETURN CODE
*
         L     R2,PDEUSER     ADDR FROM TSTCONVT
         LA    R2,@0(R2)      CLEAR HI ORDER BYTE
         TM    PDEFLG5,PDESIB IF ADDR IS NOT SYMBOLIC
         BZ    GOXLST         ...THEN BRANCH
         L     R2,@0(R2)      ...ELSE GET ADDR FROM SIB
         LA    R2,0(R2)       ZERO HIGH ORDER BYTE
         B     GOXLST         TO SEARCH XTENT LIST
         EJECT
***********************************************************************
*                                                                     *
* THIS CODE ACCESS EACH TCB AND PASSES ITS ADDR IN REGISTER 1 TO CODE *
* WHICH SEACHES THE EXTENT LISTS FOR THE SAME ADDRESS IN PDEUSER. WHEN*
* THE ADDRESS IS FOUND, THE CORRESPONDING LOADNAME IS RETURNED IN R0  *
* IF NOT SUCCESSFUL, R0 WILL CONTAIN ZEROES.                          *
*                                                                     *
***********************************************************************
GOXLST   DS    0X
         ST    R2,PDEUSER     PUT ACTUAL ADDR IN PDEUSER
         L     R3,WORKAREA    ACCESS WORKAREA ADDR
         ST    R2,USERSAVE-TSTCWORK(R3) SAVE ORIG CONVERTED ADDR
         L     R1,TSTTCB      ACCESS TEST TCB
         LA    R1,@0(R1)      CLEAR HI ORDER BYTE
         ST    R1,TCBCHAI-TSTCWORK(R3) STORE MOTHER TCB IN WORKAREA
NXTCB    DS    0X
         BAL   R14,TCBCHAIN   TO GET NEXT TCB ON CHAIN
         LTR   R1,R1          ANOTHER TCB FOUND
         BZ    ENDCHAIN       NO, END XLST SEARCH
         USING TCB,R1         ESTABLISH TCB ADDRESSABILITY
         TM    TCBFLGS5,TCBFC TEST IF TCB TERMINATED
         BO    NXTCB          IF TERMINATED, GET NEXT TCB
         DROP  R1             DROP TCB ADDRESSABILITY
         BAL   R14,XLSTSRCH   YES,SEARCH XLST
         LTR   R0,R0          XLST SEARCH SUCCESSFUL
         BZ    NXTCB          GET NEXT TCB
         TM    PDEFLG1,LDNAMFLG TEST IF USER ENTERED LDNAM
         BO    GETCTN         IF SO, DO NOT ALTER PDE
         LR    R2,R0          ACCESS PTR TO LOADNAME
         LA    R2,@7(R2)      CREATE PTR TO END OF LOAD NAME
         LA    R8,@8          MAX LENGTH OF LOADNAME
BLNKOFF  DS    0X                                       ****
         CLI   @0(R2),BLANK   TEST FOR BLANK              * REMOVE
         BNE   MVCPROG        NO BLANK, BRANCH            *  BLANK
         BCTR  R8,R0          DECREMENT LENGTH COUNTER    * PADDING
         BCTR  R2,R0          DECREMENT PTR TO LOADNAME   *  IF ANY
         B     BLNKOFF        TO TEST FOR BLANK        ****
PNAMVC   MVC   @0(@1,R6),@0(R2)
TRYALIAS DS    0X              REPLACE LDNAM WITH ALIAS
         LA    R8,@8          MAX LENGTH OF ALIAS NAME
         L     R6,WORKAREA    ACCESS WORKAREA PTR
         LA    R2,ALIASAVE-TSTCWORK(R6) ACCESS PTR TO ALIAS SAVE
         TM    TSTFLGS1,TSTFIRST  HAVE WE ALREADY TRIED ALIAS
         BO    NOCTN          IF SO, BRANCH
         OI    TSTFLGS1,TSTFIRST  SET FLAG TO INDICATE TRYING ALIAS
         LR    R0,R2          SAVE PTR TO ALIAS NAME
         CLI   @0(R2),BLANK   TEST IF ALIAS EXISTS
         BE    NOCTN          GO TO RECOVERY ROUTINE
         LA    R2,@7(R2)      CREATE PTR TO END OF ALIAS NAME
         B     BLNKOFF        TO REMOVE BLANK PADDING
NOCTN    DS    0X              RECOVERY ROUTINE IF CSECT NAME NOT FOUND
         NI    TSTFLGS1,HEXFF-TSTFIRST TURN FLAG OFF
         STH   R8,PDELEN2       ST LENGTH OF 8
         MVI   @0(R2),BLANK     PUT BLANK IN ALIASAVE
         MVC   @1(@7,R2),@0(R2) SPREAD BLANKS THROUGH ALIASAVE @ZA00920
         ST    R2,PDECTNAM      STORE PTR TO BLANKS AS CSECT NAME PTR
         NI    TSTFLGS3,HEXFF-SYMMESG TURN OF SUPPRESS MSG FLAG
         MVC   OFFSET2-TSTCWORK(@4,R6),OFFSET-TSTCWORK(R6) MOVE OFFSET
         B     RECOVER          RESUME RECOVERY PROCESS
MVCPROG  DS    0X
         OI    PDEFLG1,LDNAMFLG  TURN ON LOADNAME FLAG
         STH   R8,PDELEN1     STORE LOADNAME LENGTH
         BCTR  R8,R0          DECREMENT FOR EX
         L     R6,WORKAREA    ACCESS WORKAREA PTR
         LA    R6,LOADNAME-TSTCWORK(R6) CREATE PTR TO LOADNAME AREA
         ST    R6,PDELDNAM    ST PTR IN PDE
         LR    R2,R0          ACCESS LOADNAME PTR
         EX    R8,PNAMVC      TO MOVE INTO WORKAREA
GETCTN   DS    0X
         MVI   PDEFLG2,HEX00  INDICATE CSECT NAME NOT PRESENT
*
         LA    R2,@4          LENGTH OF OFFSET (ADDR STRING)
         STH   R2,PDELEN3     STORE IN PDE LENGTH POINTER
         L     R6,WORKAREA    ACCESS WORKAREA PTR
         LA    R2,OFFSET-TSTCWORK(R6) ACCESS GROSS OFFSET
         ST    R2,PDEADRPT    STORE OFFSET PTR IN PDE
         OI    PDEFLG3,AFLG   TURN ON ADDRESS STRING INDICATOR
         MVI   PDEFLG4,RELADDR TURN ON RELADDR FLAG AND TURN OFF OTHERS
         OI    TSTFLGS3,SYMMESG  INDICATE TO SUPPRESS MSG
         LA    R1,IKJPARMA
         BAL   R11,LINKSYM    LINK TO IKJEGSYM TO GET CSECT NAME
         BAL   R14,CODECHK2   TEST SYM RETURN CODE
         L     R6,WORKAREA    REINITIALIZE WORKAREA PTR
         XC    PDEADRPT(@7),PDEADRPT CLEAR ADDR PTR, LENGTH AND FLAGS
         LH    R2,PDELEN2     ACCESS LENGTH OF CSECT NAME
         BCTR  R2,R0          DECREMENT FOR EXECUTE
         L     R1,PDECTNAM    ACCESS PTR TO CSECT NAME
         EX    R2,CSECTMVC    MOVE CSECT NAME TO MY WORKAREA
         LA    R2,CSECTNAM-TSTCWORK(R6) CREATE PTR TO CSECT NAME
         ST    R2,PDECTNAM    STORE PTR IN PDE
         NI    TSTFLGS3,HEXFF-SYMMESG TURN OFF SUPPRESS MSG FLAG
         LA    R1,IKJPARMA
         BAL   R11,LINKSYM    LINK TO SYM FOR CSECT LOCATION
         BAL   R14,CODECHK2   TEST SYM RETURN CODE
         L     R6,WORKAREA    REINITIALIZE WORKAREA PTR
         L     R2,TSTWHR      ACCESS LOADED AT ADDRESS FROM IKJEGSYM
         L     R3,PDEUSER     CSECT LOCATION
         SR    R3,R2          OFFSET OF CSECT FROM LOADED AT ADDR
         L     R4,OFFSET-TSTCWORK(R6) ACCESS SAVED GROSS OFFSET
         SR    R4,R3          CALCULATE OFFSET INTO CSECT
         ST    R4,OFFSET2-TSTCWORK(R6) STORE OFFSET IN WORKAREA
RECOVER  DS    0X              ENTER HERE IF CSECT NAME WAS NOT FOUND
         L     R1,TSTTCB      ACCESS TCB ADDRESS
         LA    R1,@0(R1)      CLEAR HI ORDER BYTE
         ST    R1,TCBCHAI-TSTCWORK(R6) SAVE MOTHER TCB
GOTCB1   DS    0X
         BAL   R14,TCBCHAIN   GET NEXT TCB ON CHAIN
         XR    R15,R15        INDICATE ZERO RETURN CODE
         LTR   R1,R1          TEST FOR END OF TCB CHAIN
         BZ    GOHOME         BRANCH IF END OF CHAIN
         USING TCB,R1         ESTABLISH TCB ADDRESSABILITY
         TM    TCBFLGS5,TCBFC TEST IF TCB TERMINATED
         BO    GOTCB1         IF TERMINATED, GET NEXT TCB
         DROP  R1             DROP TCB ADDRESSABILITY
         BAL   R14,CDESRCH    TO SEARCH CDE FOR LOADNAME MATCH
         LTR   R0,R0          TEST IF MATCH WAS FOUND
         BZ    GOTCB1         TO GET NEXT TCB ON CHAIN
         L     R6,OFFSET-TSTCWORK(R8)  ACCESS GROSS OFFSET
         AR    R6,R0          LOAD ADDR + GROSS OFFSET = ASOLUTE ADDR
         LA    R6,@0(R6)      CLEAR HI ORDER BYTE
         LA    R10,PDESAVE-TSTCWORK(R8) ACCESS ADDR OF ORIGINAL PDE
         TM    @14(R10),CTNAMFLG TEST IF CSECT NAME PRESENT
         BNO   TPRINT         TO PRINT MSG
GOPRNT   DS    0X
         ST    R6,PDEUSER     STORE ABSOLUTE ADDR IN PDEUSER
         BAL   R14,OFFMSG     BRANCH TO PRINT MESSAGE
         L     R1,TCBSAVE-TSTCWORK(R8) ACCESS CURRENT TCB
         LTR   R11,R11        TEST FOR RETURN ADDRESS FROM CDESRCH
         BZ    GOTCB1         IF NONE, GET NEXT TCB
         BR    R11            OTHERWISE BRANCH BACK TO CDESRCH
TPRINT   DS    0X
         L     R10,USERSAVE-TSTCWORK(R8) ACCESS ORIG CONVERTED ADDR
         CR    R6,R10         DOES ORIG ADDR = CALCULATED ADDR
         BE    GOPRNT         IF SO, PRINT MSG
         LTR   R11,R11        OTHERWISE CHECK FOR CDESRCH RETURN ADDR
         BZ    GOTCB1         IF NONE, GET NEXT TCB
         BR    R11            OTHERWISE, BRANCH INTO CDESRCH
ENDCHAIN DS    0X
         BAL   R14,REGMSG     TO PUT OUT DIAGNOSTIC  MSG
         XR    R15,R15        INDICATE ZERO RETURN CODE
         B     GOHOME         RETURN TO PARSE
*
LINKSYM  DS    0X
NOBLDL   LA    R4,I0085       IKJEGSYM INSERT
         LINK  EP=IKJEGSYM,ERRET=LINKFL2  LINK TO SYM
BLOW2    DS    0X
BLOW3    DS    0X              STAE RESUME ADDRESS
SMTSYM02 DS    0X             TEST CASE TTSTC120
         BR    R11            RETURN IN LINE
         EJECT
***********************************************************************
* THIS CODE SEARCHES THE EXTENT LISTS ON THE TCB PASSED IN REG 1      *
* FOR THE ADDRESS IN PDEUSER.  THE LOADED AT ADDRESS IS USED TO       *
* ASSOCIATE AN ADDRESS WITH A LOADNAME. A POINTER TO THE LOADNAME     *
* IS RETURNED IN REG 0, AND A GROSS OFFSET (PDEUSER-LOADED AT         *
* ADDRESS) IS STORED IN WORKAREA.                                     *
***********************************************************************
XLSTSRCH DS    0X
         XR    R0,R0          INIT R0 TO INDICATE CTN NOT FOUND
         L     R8,WORKAREA    ACCESS WORKAREA POINTER
         LA    R8,ALIASAVE-TSTCWORK(R8) ACCESS PTR TO ALIAS SAVE AREA
         MVI   @0(R8),BLANK   TO BLANK OUT ALIAS SAVE
         MVC   @1(@7,R8),@0(R8)  INITIALIZE ALIAS SAVE
         USING TCB,R1         ESTABLISH TCB ADDRESSABILITY
         L     R2,TCBRBP      ACCESS RB PTR
         USING RBSECT,R2      ESTABLISH RB ADDRESSABILITY
RBLOOP   DS    0X
         TM    RBSTAB,HEXC0   TEST IF PRB
         BNZ   NXTRB          IF NOT, GET NEXT RB
         L     R3,RBCDE       IF SO, ACCESS CDE PTR
         LA    R3,@0(R3)      CLEAR HI ORDER BYTE
         LTR   R3,R3          PTR EQUAL ZERO
         BZ    NXTRB          IF SO, SKIP THIS CDE
CDELOOP  DS    0X
         USING CDENTRY,R3     ESTABLISH CDE ADDRESSABILITY
         TM    CDATTR,CDMIN   CHECK FOR ALIAS (MINOR CDE)      @YM07131
         BNO   CONTCDE        IF NOT ALIAS, GET XLST PTR
         L     R8,WORKAREA    ACCESS WORKAREA POINTER
         MVC   ALIASAVE-TSTCWORK(@8,R8),CDNAME SAVE ALIAS IN WORKAREA
         L     R3,CDXLMJP     ACCESS MAJOR CDE
         LA    R3,@0(R3)      CLEAR HI ORDER BYTE
CONTCDE  DS    0X
         L     R5,CDXLMJP     ACCESS XLST PTR
         USING XTLST,R5       ESTABLISH XLST ADDRESSABILITY
         TM    CDATTR2,HEX80  TEST FOR OBJECT
         L     R6,XTLMSBAA    ACCESS LOADED AT ADDRESS
         BNO   GETLOC         CONTINUE PROCESSING
         LA    R15,@2         FOR FUTURE COMPARISON
         CL    R15,XTLNRFAC   DETERMINE IF TWO ENTRIES
         BNE   GETLOC         CONTINUE PROCESSING
         L     R6,XTLMSBAA+@4    ACCESS LOADED AT ADDRESS
GETLOC   DS    0X
         LA    R6,@0(R6)      CLEAR HI ORDER BYTE
         L     R11,XTLMSBLA   ACCESS LENGTH OF CSECT
         LA    R11,@0(R6,R11) CREATE END ADDR FOR CSECT
         L     R8,PDEUSER     ACCESS ADDR IN PDEUSER
         CLR   R6,R8          PDEUSER G.T. THIS LOADED AT ADDR
         BH    XLSTLOOP       IF NOT GET NEXT CDE
         CLR   R11,R8         PDEUSER L.T. CSECT END ADDR
         BNH   XLSTLOOP       IF NOT, GET NEXT CDE
         SLR   R8,R6          COMPUTE OFFSET
         L     R2,WORKAREA    ACCESS WORKAREA PTR
         ST    R8,OFFSET-TSTCWORK(R2) STORE GROSS OFFSET
         LA    R0,CDNAME      RETURN PTR TO LOADNAME
RETHOME  DS    0X
         NI    TSTFLGS2,HEXDF TURN OFF LOAD LIST INDICATOR
         BR    R14            RETURN AND GET ANOTHER TCB
XLSTLOOP DS    0X
         TM    TSTFLGS2,TOFFDEF ARE WE USING LOAD LIST CDE'S
         BO    GOLLE          IF SO, GET NEXT LLE
NXTRB    DS    0X
         L     R2,RBLINK      OTHERWISE ACCESS NEXT RB
         LA    R2,@0(R2)      CLEAR HI ORDER BYTE
         CR    R1,R2          DOES RBLINK POINT TO TCB
         BNE   RBLOOP         IF NOT, PROCESS THIS RB
         L     R2,TCBLLS      OTHERWISE, ACCESS LOAD LIST PTR
         OI    TSTFLGS2,TOFFDEF INDICATE USING LOAD LIST, NOT RB
         DROP  R2
         USING LLE,R2         ESTABLISH LOAD LIST ADDRESSABILITY
LLELOOP  DS    0X
         LA    R2,@0(R2)      CLEAR HI ORDER BYTE
         LTR   R2,R2          TEST FOR END OF LOAD LIST
         BZ    RETHOME        IF END OF LOAD LIST, BRANCH
         L     R3,LLECDPT     OTHERWISE, GET CDE PTR
         LA    R3,@0(R3)      CLEAR HI ORDER BYTE
         LTR   R3,R3          PTR EQUAL ZERO
         BZ    XLSTLOOP       IF SO, SKIP THIS CDE
         B     CDELOOP        TO PROCESS NEXT CDE
GOLLE    DS    0X
         L     R2,LLECHN      ACCESS PTR TO NEXT LLE
         B     LLELOOP        TO PROCESS LLE
         DROP  R1
         DROP  R2
         DROP  R3
         DROP  R5
         EJECT
***********************************************************************
* THIS CODE SEARCHES THE TCB PASSED IN REG1 FOR THE LOADNAME INDICATED*
* IN PDELDNAM. WHEN THE LOADNAME IS FOUND, THE LOADED AT ADDRESS IS   *
* PASSED BACK IN REG0. IF NOT FOUND, REG0 CONTAINS ZEROES. IF R11     *
* IS ZERO THE NEXT TCB TO BE SEARCHED SHOULD BE RETURNED IN REG1. IF  *
* REG11 HAS AN ADDR THEN THE CALLER SHOULD BRANCH ON REG11 SO THAT    *
* THE REST OF THE CDE'S ON THE PRESENT TCB CAN BE SEARCHED.           *
***********************************************************************
CDESRCH  DS    0X              REG1 POINTS TO TCB- REG7 POINTS TO PDE
         L     R8,WORKAREA    ACCESS WORKAREA
         ST    R14,RETURN-TSTCWORK(R8) SAVE RETURN ADDR
         XR    R0,R0          INIT R0 TO INDICATE LO
         XR    R11,R11        ZERO POSSIBLE RETURN ADDR
         USING TCB,R1         ESTABLISH TCB ADDRESSABILITY
         L     R3,TCBRBP      ACCESS RB POINTER
         USING RBSECT,R3      ESTABLISH RB ADDRESSABILITY
RBPROC   DS    0X
         LA    R3,@0(R3)      ZERO HI ORDER BYTE
         CR    R1,R3          DOES RBLINK POINT TO TCB
         BE    INITLLE        IF SO,USE LLE CDE
         TM    RBSTAB,HEXC0   TEST IF PRB
         BNZ   NEXTRB         IF NOT, GET NEXT RB IN CHAIN
         L     R5,RBCDE       ACCESS ADDR OF CDE
         LA    R5,0(R5)       CLEAR HI ORDER BYTE
         LTR   R5,R5          DOES PTR EQUAL ZERO
         BZ    NEXTRB         IF SO, SKIP THIS CDE
USECDE   DS    0X
         USING CDENTRY,R5     ESTABLISH CDE ADDRESSABILITY
CDEPROC  DS    0X
         LA    R8,CDNAME      ACCESS ADDR OF LOADNAME
         LA    R8,@7(R8)      UPDATE TO END OF LOADNAME
         LA    R6,@8          INITIALIZE LENGTH COUNTER
REMBLNK  DS    0X
         CLI   @0(R8),BLANK   TEST FOR BLANK PADDING
         BNE   COMPLEN        ALL PADDING REMOVED
         BCTR  R8,R0          DECREMENT POINTER
         BCTR  R6,R0          DECREMENT COUNTER
         B     REMBLNK        TEST FOR BLANK PADDING LOOP
COMPLEN  DS    0X
         LH    R15,PDELEN1    ACCESS LENGTH OF LOADNAME IN PDE
         CLR   R15,R6         ARE LOADNAME LENGTHS EQUAL
         BNE   NOCOMP         IF NOT, DO NOT COMPARE LOADNAMES
         BCTR  R6,R0          DECREMENT FOR EXECUTE
         L     R8,PDELDNAM    ACCESS PTR TO LOADNAME
         EX    R6,LDNCOMPR    TO COMPARE FOR LOADNAME MATCH
         BE    CHKDUP         IF = CHECK IF ITS A DUPLICATE
NOCOMP   DS    0X
         TM    CDATTR,CDMIN   CHECK FOR ALIAS (MINOR CDE)      @YM07131
         BNO   NEXTRB         IF NOT ALIAS, BRANCH
         L     R5,CDXLMJP     ACCESS MAJOR CDE
         LA    R5,@0(R5)      CLEAR HI ORDER BYTE
         B     CDEPROC        PROCESS MINOR CDE
LDNCOMPR CLC   @0(@1,R8),CDNAME  COMPARE LOADNAMES
NEXTRB   DS    0X
         TM    TSTFLGS2,TOFFDEF TEST IF SEARCHING LOAD LIST CDE
         BO    GETLLE         IF SO, GET NEXT LLE
         L     R3,RBLINK      OTHERWISE ACESS NEXT RB
         B     RBPROC         PROCESS RB
INITLLE  DS    0X             GET CDE POINTER FROM LLE
         L     R3,TCBLLS      OTHERWISE, ACCESS ADDR OF LOADLIST
         OI    TSTFLGS2,TOFFDEF INDICATE USING LOAD LIST, NOT RB
         DROP  R3
USELLE   DS    0X
         USING LLE,R3         ESTABLISH LOAD LIST ADDRESSABILITY
         LA    R3,@0(R3)      ZERO HI ORDER BYTE
         LTR   R3,R3          END OF LOAD LIST
         BZ    RETCALL        IF SO, RETURN TO CALLER
         L     R5,LLECDPT     ACCESS PTR TO CDE
         LA    R5,0(R5)       CLEAR HI ORDER BYTE
         LTR   R5,R5          DOES PTR EQUAL ZERO
         BZ    GETLLE         IF SO, SKIP THIS CDE
         B     USECDE         BRANCH TO PROCESS CDE
GETLLE   DS    0X
         L     R3,LLECHN      ACCESS PTR TO NEXT LLE
         B     USELLE         TO PROCESS LLE
         DROP  R3
RETCALL  DS    0X
         NI    TSTFLGS2,HEXDF TURN OFF LOAD LIST INDICATOR
         L     R8,WORKAREA    ACCESS WORKAREA
         L     R14,RETURN-TSTCWORK(R8) ACCESS RETURN ADDRESS
         BR    R14            RETURN TO CALLER
CHKDUP   DS    0X
         L     R8,WORKAREA    ACCESS WORKAREA PTR
         ST    R5,CDESAVE-TSTCWORK(R8)  STORE CDE ADDRESS
         ST    R1,TCBSAVE-TSTCWORK(R8)  STORE TCB ADDRESS
         LA    R3,@0(R3)                CLEAR HI ORDER BYTE
         ST    R3,RBSAVE-TSTCWORK(R8)   STORE RB ADDRESS
         TM    CDATTR,CDMIN   TEST IF ALIAS (MINOR CDE)        @YM07131
         BNO   CONTDUP        BRANCH IF NOT ALIAS
         L     R5,CDXLMJP     ACCESS MAJOR CDE
         LA    R5,@0(R5)      CLEAR HI ORDER BYTE
CONTDUP  DS    0X
         L     R4,CDXLMJP     ACCESS POINTER TO XTENT LIST
         USING XTLST,R4       ESTABLISH XTENT LIST ADDRESSABILITY
         TM    CDATTR2,HEX80  TEST FOR OBJECT
         L     R0,XTLMSBAA    ACCESS LOADED AT ADDRESS
         BNO   GETLOC2        CONTINUE PROCESSING
         LA    R15,@2         FOR FUTURE COMPARISON
         CL    R15,XTLNRFAC   DETERMINE IF TWO ENTRIES
         BNE   GETLOC2        CONTINUE PROCESSING
         L     R0,XTLMSBAA+@4  ACCESS LOADED AT ADDRESS
         DROP  R4
GETLOC2  DS    0X
         ST    R0,LOADSAVE-TSTCWORK(R8) STORE LOADED AT ADDRESS
         BAL   R10,CDESRCH2   TO TEST FOR DUPLICATE LOADNAMES
         LTR   R0,R0          TEST IF DUPLICATE FOUND
         BZ    NEXTRB         IF DUPLICATE, BRANCH TO CONTINUE CHAIN
         L     R14,RETURN-TSTCWORK(R8) RELOAD RETURN ADDRESS
         BALR  R11,R14        TO TELL CALLER TO PUT OUT MSG
         XR    R0,R0          INITIALIZE REGISTER 0
         L     R8,WORKAREA    ACCESS WORKAREA ADDRESS
         L     R3,RBSAVE-TSTCWORK(R8)  RESTORE RB POINTER
         L     R1,TCBSAVE-TSTCWORK(R8) RESTORE TCB POINTER
         B     NEXTRB         CONTINUE PROCESSING CHAIN
CDESRCH2 DS    0X
         L     R3,TCBRBP      ACCESS FIRST RB ON CHAIN
         USING RBSECT,R3      ESTABLISH RB ADDRESSABILITY
RBPROC2  DS    0X
         LA    R3,@0(R3)      CLEAR HI ORDER BYTE
         CR    R1,R3          DOES RB POINT TO TCB
         BE    INITLLE2       ACCESS LOAD LIST
         TM    RBSTAB,HEXC0   TEST IF PRB
         BNZ   NEXTRB2        IF NOT, GET NEXT RB
         L     R5,RBCDE       ACCESS POINTER TO CDE
         LA    R5,0(R5)       CLEAR HI ORDER BYTE
         LTR   R5,R5          DOES PTR EQUAL ZERO
         BZ    NEXTRB2        IF SO, SKIP THIS CDE
USECDE2  DS    0X
         L     R6,CDESAVE-TSTCWORK(R8) ACCESS STORED CDE
         CR    R5,R6          COMPARE CDE POINTERS
         BNE   TSTMJCDE       GET NEXT RB
         L     R6,RBSAVE-TSTCWORK(R8) ACCESS STORED RB OR LLE
         LA    R6,@0(R6)      CLEAR HI ORDER BYTE
         CR    R6,R3          COMPARE RB OR LLE
         BCR   @8,R10         IF EQUAL, DUPLICATE SEARCH ENDED
         XR    R0,R0          INDICATE DUPLICATE - DO NOT PRINT MSG
         LR    R3,R6          RESTORE ORIGINAL RB OR LLE
         BR    R10            CONTINUE PROCESSING
NEXTRB2  DS    0X
         CLI   RBSAVE-TSTCWORK(R8),HEX80 TEST IF SEARCHING LOAD LIST
         BE    GETLLE2        IF SO, GET NEXT LLE
         L     R3,RBLINK      IF NOT, GET NEXT RB
         B     RBPROC2        PROCESS RB
TSTMJCDE DS    0X
         TM    CDATTR,CDMIN   CHECK FOR ALIAS (MINOR CDE)      @YM07131
         BNO   NEXTRB2        GET NEXT RB
         L     R5,CDXLMJP     ACCESS MAJOR CDE
         LA    R5,@0(R5)      CLEAR HI ORDER BYTE
         B     USECDE2        PROCESS MAJOR CDE
INITLLE2 DS    0X
         L     R3,TCBLLS      OTHERWISE, ACCESS LOAD LIST PTR
         MVI   RBSAVE-TSTCWORK(R8),HEX80 TURN ON LLE INDICATOR
USELLE2  DS    0X
         USING LLE,R3         ESTABLISH LLE ADDRESSABILITY
         LA    R3,@0(R3)      CLEAR HI ORDER BYTE
         LTR   R3,R3          * THIS SITUATION SHOULD *
         BCR   @8,R10         *   NEVER HAPPEN        *
         L     R5,LLECDPT     ACCESS CDE PTR
         LA    R5,@0(R5)      CLEAR HI ORDER BYTE
         B     USECDE2        IF NOT, PROCESS CDE
GETLLE2  DS    0X
         L     R3,LLECHN      ACCESS NEXT LLE
         B     USELLE2        PROCESS LLE
         DROP  R1
         DROP  R3
         DROP  R5
         EJECT
***********************************************************************
* THIS ROUTINE EXPECTS A TCB POINTER IN R1 AND THE ORIGINAL TCB MOTHER*
* STORED IN TCBCHAI IN WORKAREA  IT USES A MOTHER-DAUGHTER-SISTER     *
* CHAIN SEARCH AND RETURNS THE NEXT TCB IN R1. IF END OF CHAIN, R1=0  *
***********************************************************************
TCBCHAIN DS    0X
         LR    R2,R1          PUT TCB ADDRESS IN R2
         L     R1,TCBLTC-TCB(R2) ACCESS DAUGHTER TASK PTR
         LA    R1,@0(R1)      CLEAR HI ORDER BYTE
         LTR   R1,R1          TEST IF DAUGHTER EXISTS
         BCR   @2,R14         IF NOT ZERO, RETURN TCB IN R1
SISTER   DS    0X
         L     R1,TCBNTC-TCB(R2) IF NO DAUGHTER, GET SISTER
         LA    R1,@0(R1)      CLEAR HI ORDER BYTE
         LTR   R1,R1          TEST IF SISTER EXISTS
         BCR   @2,R14         IF NOT ZERO, RETURN TCB IN R1
         L     R2,TCBOTC-TCB(R2) IF NO SISTER, GET MOTHER
         LA    R2,@0(R2)      CLEAR HI ORDER BYTE
         L     R11,WORKAREA   ACCESS WORKAREA PTR
         L     R11,TCBCHAI-TSTCWORK(R11) ACCESS MOTHER TCB
         CR    R2,R11         DOES MOTHER = TEST TASK
         BNE   SISTER         IF NOT GET MOTHER'S SISTER
         XR    R1,R1          INDICATE END OF TCB CHAIN
         BR    R14            RETURN TCB ADDR TO CALLER
         EJECT
***********************************************************************
*                          MESSAGE TEXT                               *
* ......LOCATED AT +... IN ..............UNDER TCB LOCATED AT.......  *
***********************************************************************
OFFMSG   DS    0X
         LR    R3,R14         SAVE RETURN ADDRESS
         L     R4,OUTBUF      POINTER TO OUTBUF
         XR    R2,R2          ZERO REGISTER TWO
         STH   R2,@2(R4)     ZERO UNUSED FIELD
         LA    R2,@81         ACCESS LENGTH OF MSG
         STH   R2,@0(R4)      CONSTANT MSG LENGTH = 81
         LA    R4,@4(R4)      POINTER TO ACTUAL MSG DATA
         MVI   @0(R4),BLANK   PUT BLANK IN MSG BUFFER
         MVC   @1(@77,R4),@0(R4)  BLANK OUT MSG BUFFER
         USING IKJPARMA,R7    ESTABLISH PDE ADDRESSABILITY
         L     R2,PDEUSER     ACCESS ABSOLUTE ADDRESS
         BAL   R14,CONVERT    TO CONVERT ADDRESS TO PRINTABLE EBCDIC
         EX    R10,ADDRMVC    PUT CONVERTED ADDRESS IN BUFFER
         LA    R10,@2(R10,R4) UPDATE BUFFER POINTER
         MVI   @0(R10),DOT    PUT PERIOD AFTER ABSOLUTE ADDRESS
         LA    R2,MDATA1      ACCESS PTR TO 'LOCATED AT'
         MVC   @8(@12,R4),@0(R2) PUT 'LOCATED AT' IN MSG BUFFER
         MVI   @20(R4),HEX4E  PUT PLUS SIGN BEFORE OFFSET
         L     R2,WORKAREA    ACCESS WORKAREA PTR
         L     R2,OFFSET2-TSTCWORK(R2) ACCESS CALCULATED OFFSET
         BAL   R14,CONVERT    TO CONVERT OFFSET TO PRINTABLE EBCDIC
         EX    R10,OFFMVC     PUT CONVERTED OFFSET IN BUFFER
         LA    R2,MDATA2      ACCESS 'IN'
         MVC   @28(@2,R4),@9(R2) PUT 'IN' INTO MSG BUFFER
         LH    R2,PDELEN1     ACCESS LENGTH OF LOADNAME
         BCTR  R2,R0          DECREMENT FOR EXECUTE
         L     R5,PDELDNAM    ACCESS PTR TO LOADNAME
         EX    R2,LDNMVC      TO MOVE LOADNAME INTO MESSAGE
         MVI   @39(R4),DOT    PUT PERIOD TO INDICATE ABSOLUTE ADDR
         LH    R2,PDELEN2     ACCESS LENGTH OF CSECTNAME
         BCTR  R2,R0          DECREMENT FOR EXECUTE
         L     R5,PDECTNAM    ACCESS PTR TO CSECT NAME
         EX    R2,CTNMVC      TO MOVE CSECTNAME INTO MESSAGE
         LA    R2,MDATA3      ACCESS 'UNDER TCB'
         MVC   @48(@22,R4),@0(R2) PUT 'UNDER TCB' IN MSG BUFFER
         LR    R2,R1          ACCESS TCB ADDR
         BAL   R14,CONVERT    TO CONVERT TCB ADDRESS
         EX    R10,TCBMVC     PUT CONVERTED TCB ADDRESS IN BUFFER
         LA    R10,@71(R10,R4) UPDATE BUFFER POINTER
         MVI   @0(R10),DOT    PUT PERIOD AFTER TCB ADDRESS
         L     R1,OUTBUF      ACCESS PTR TO OUTPUT BUFFER
         BAL   R14,PUTMSG     TO BRANCH TO IO
         BR    R3             RETURN TO CALLER
ADDRMVC  MVC   @1(@1,R4),@0(R2) PUT CONVERTED ADDRESS IN MSG BUFFER
OFFMVC   MVC   @21(@1,R4),@0(R2) PUT CONVERTED OFFSET INTO MSG BUFFER
TCBMVC   MVC   @70(@1,R4),@0(R2) PUT CONVERTED ADDR INTO MSG BUFFER
***********************************************************************
*                          MESSAGE TEXT                               *
*  .......LOCATED IN................UNDER TCB LOCATED AT.......       *
***********************************************************************
LDNMSG   DS    0X
         LR    R3,R14         SAVE RETURN ADDRESS
         L     R4,OUTBUF      ACCESS PTR TO OUTPUT BUFFER
         XR    R2,R2          ZERO REGISTER TWO
         STH   R2,@2(R4)      ZERO UNUSED FIELD
         LA    R2,@71         ACCESS LENGTH OF MSG
         STH   R2,@0(R4)      CONSTANT MSG LENGTH =71
         LA    R4,@4(R4)      POINTER TO ACTUAL MSG DATA
         MVI   @0(R4),BLANK   PUT BLANK IN MSG BUFFER
         MVC   @1(@67,R4),@0(R4)  BLANK OUT MSG BUFFER
         USING IKJPARMA,R7    ESTABLISH PDE ADDRESSABILITY
         LH    R2,PDELEN1     ACCESS LENGTH OF LOADNAME
         BCTR  R2,R0          DECREMENT FOR EXECUTE
         L     R5,PDELDNAM    ACCESS PTR TO LOADNAME
         EX    R2,LDNMVC2     TO MOVE LOADNAME INTO MSG
         TM    PDEFLG2,CTNAMFLG TEST IF CSECT NAME SPECIFIED
         BNO   CONTMSG        DO NOT PUT IN CSECT NAME
         MVI   @9(R4),DOT     PUT PERIOD BETWEEN LOADNAME-CSECTNAME
         LH    R2,PDELEN2     ACCESS LENGTH OF CSECTNAME
         BCTR  R2,R0          DECREMENT FOR EXECUTE
         L     R5,PDECTNAM    ACCESS PTR TO CSECT NAME
         EX    R2,CTNMVC2     TO MOVE CSECT NAME INTO MSG
         LA    R4,@9(R4)      UPDATE FOR POINTER UNIFORMITY
CONTMSG  DS    0X
         LA    R2,MDATA1      ACCESS 'LOCATED AT'
         MVC    @9(@12,R4),@0(R2) PUT'LOCATED AT' IN MSG BUFFER
         L     R2,PDEUSER     ACCESS ABSOLUTE ADDRESS
         BAL   R14,CONVERT    TO CONVERT ADDRESS TO PRINTABLE EBCDIC
         EX    R10,A2MVC      PUT CONVERTED ADDRESS IN BUFFER
         LA    R10,@22(R10,R4) UPDATE BUFFER POINTER
         MVI   @0(R10),DOT    PUT PERIOD AFTER ABSOLUTE ADDRESS
         LA    R2,MDATA3      ACCESS 'UNDER TCB'
         MVC   @28(@22,R4),@0(R2) PUT'UNDER TCB' IN MSG BUFFER
         LR    R2,R1          ACCESS TCB ADDRESS
         BAL   R14,CONVERT    TO CONVERT TCB ADDRESS
         EX    R10,T2MVC      PUT CONVERTED TCB ADDRESS IN BUFFER
         LA    R10,@51(R10,R4) UPDATE BUFFER POINTER
         MVI   @0(R10),DOT    PUT PERIOD AFTER TCB ADDRESS
         L     R1,OUTBUF      ACCESS ADDR OF OUTPUT BUFFER
         BAL   R14,PUTMSG     TO BRANCH TO IO
         BR    R3             RETURN TO CALLER
A2MVC    MVC   @21(@1,R4),@0(R2) PUT CONVERTED ADDRESS IN MSG BUFFER
T2MVC    MVC   @50(@1,R4),@0(R2) PUT CONVERTE ADDR INTO MSG BUFFER
***********************************************************************
*                          MESSAGE TEXT                               *
*                   'NOT WITHIN ANY PROGRAM EXTENT'                   *
***********************************************************************
REGMSG   DS    0X
         LR    R3,R14         SAVE RETURN ADDRESS
         L     R4,OUTBUF      POINTER TO OUTBUF
         XR    R2,R2          ZERO REGISTER TWO
         STH   R2,@2(R4)      ZERO UNUSED FIELD
         LA    R4,@4(R4)      POINTER TO ACTUAL MSG DATA
         MVI   @0(R4),BLANK   PUT BLANK IN MSG BUFFER
         MVC   @1(@48,R4),@0(R4)  BLANK OUT MSG BUFFER
         USING IKJPARMA,R7    ESTABLISH PDE ADDRESSABILITY
         L     R2,PDEUSER     ACCESS ABSOLUTE ADDRESS
         BAL   R14,CONVERT    TO CONVERT ADDRESS TO PRINTABLE EBCDIC
         EX    R10,A3MVC      PUT CONVERTED ADDRESS IN BUFFER
         LA    R4,@2(R10,R4)  UPDATE BUFFER POINTER
         LA    R5,@38         BASE LENGTH OF MESSAGE
         LA    R5,@1(R10,R5)  ADD VARIABLE LENGTH TO BASE LENGTH
         MVI   @0(R4),DOT     PUT PERIOD AFTER ABSOLUTE ADDRESS
         LA    R1,@2(R4)      CREATE PTR TO BUFFER FOR TSTADDR
         LR    R0,R7          PTR TO PDE FOR TSTADDR
         L     R15,TSTADDR    ACCESS ADDR OF TSTADDR
         BALR  R14,R15        BRANCH TO TSTADDR
         LR    R10,R0         ACCESS LENGTH OF ADDR STRING
         LA    R5,@0(R10,R5)  ADD VARIABLE LENGTH TO CURRENT MSG LENGTH
         L     R10,OUTBUF     ACCESS ADDR OF OUTBUF
         STH   R5,@0(R10)     STORE MSG LENGTH IN OUTBUF
         LA    R4,@1(R1)      CREATE POINTER TO NEXT AVAILABLE SPACE
         LA    R2,MDATA4      ACCESS MSG DATA
         MVC   @0(@30,R4),@0(R2) PUT DATA IN MSG BUFFER
         L     R1,OUTBUF      ACCESS ADDRESS OF OUTBUF
         BAL   R14,PUTMSG     TO BRANCH TO IO
         BR    R3             RETURN TO CALLER
A3MVC    MVC   @1(@1,R4),@0(R2) PUT CONVERTED ADDRESS IN MSG BUFFER
PUTMSG   DS    0X             TO BRANCH TO IO
PUTC     DS    0X
         LR    R2,R14         SAVE RETURN ADDRESS
         LR    R4,R1          REG 4 = PTR TO DATA
         XC    TSTIOPRM,TSTIOPRM  CLEAR PARAMETER AREA
         IKJEGSIO DATA,DATAPTR=(R4),ID=WHR32,MF=(E,TSTIOPRM)
         CH    R15,ATTNCODE   IS RET CODE LESS 16
         BNL   PARS12         NO, GO SAVE RET CODE
         BR    R2             YES, RETURN TO CALLER
PARS12   EQU   *              RETURN TO PARSE WITH 12
         L     R14,WORKAREA   ACCESS WORKAREA PTR
         ST    R15,CODESAVE-TSTCWORK(R14)
         LA    R15,@12        IN CASE RET CODE IS 16
         B     GOHOME         RETURN TO PARSE WITH 12
CONVERT  DS    0X              TO CONVERT TO PRINTABLE EBCDIC
         L     R5,WORKAREA    ACCESS ADDR OF WORKAREA
         LA    R5,CWORKCMD-TSTCWORK(R5) ACCESS COMMAND PORTION
         ST    R2,@12(R5)     STORE ADDR TO BE CONVERTED
         UNPK  @0(@7,R5),@13(@4,R5) UNPACK ADDRESS
         TR    @0(@6,R5),TRTAB-@240 CONVERT TO EBCDIC
         LR    R2,R5          PUT ADDR OF CONVERTED STRING IN R2
         LA    R10,@5         INITIALIZE LENGTH COUNTER
REMZ     DS    0X              THIS LOOP WILL REMOVE LEADING ZEROES
         CLI   @0(R2),ZERO    TEST FOR LEADING ZERO
         BCR   @7,R14         IF NOT ZERO RETURN TO CALLER
         LA    R2,@1(R2)      INCREMENT ADDRESS POINTER
         BCT   R10,REMZ       DECREMENT COUNTER AND BRANCH IF NOT ZERO
         BR    R14            RETURN TO CALLER IF COUNTER = ZERO
         EJECT
GOHOME   DS    0X
         NI    TSTFLGS4,HEXFF-TSTVALCK  SHUT OFF VALIDITY FLAG
         L     R4,OUTBUF      ACCESS POINTER TO OUTBUF
         L     R4,@0(R4)      ACCESS 1ST WORD OF OUTBUF
         LTR   R4,R4          IS THERE A SECOND LEVEL MSG
         BZ    PARSRET        NO, RETURN TO PARSE
         L     R8,WORKAREA    ACCESS WORKAREA
         L     R11,MSGADDR-TSTCWORK(R8) ACCESS PTR TO PARSE PARMLIST
         MVC   @0(@4,R11),OUTBUF GIVE IT TO PARSE
PARSRET  EQU   *              RETURN TO PARSE
         L     R2,WORKAREA    ACCESS WORKAREA ADDR
         MVC   @0(@25,R7),PDESAVE-TSTCWORK(R2) RESTORE ORIGINAL PDE
         L     R13,@4(R13)    ACCESS CALLER'S SAVE AREA
         RETURN (14,12),RC=(15) RETURN TO PARSE
         EJECT
CODECHK  DS    0X             CHECK RETURN CODE FROM CONVERT
         B     BTAB(R15)      BRANCH ACCORDING TO RETURN CODE
BTAB     BR    R14            IF RETURN CODE = 0
         BR    R14            FOR ALIGNMENT PURPOSES
         B     CONVMSG        IF RETURN CODE = 4
         B     CONVMSG        IF RETURN CODE = 8
         B     CONVMSG        IF RETURN CODE = 12
         B     SYMSTAE        IF RETURN CODE = 16
         B     CONVMSG        IF RETURN CODE = 20
CODECHK2 DS    0X             CHECK RETURN CODE FROM SYM
         B     BTAB2(R15)     BRANCH ACCORDING TO RETURN CODE
BTAB2    BR    R14            IF RETURN CODE = 0
         BR    R14            FOR ALIGNMENT PURPOSES
         B     TRYALIAS       IF RETURN CODE = 4
         B     TRYALIAS       IF RETURN CODE = 8
         B     CONVMSG        IF RETURN CODE = 12
         B     SYMSTAE        IF RETURN CODE = 16
         B     SYMSTAE        IF RETURN CODE = 20
CONVMSG  DS    0X             ENTER HERE FOR RETURN CODE 8
         LA    R15,@8         SET RETURN CODE TO 8
         B     GOHOME         RETURN TO PARSE
SYMSTAE  DS    0X              ENTER HERE IF RETURN CODE = 20
         L     R8,WORKAREA    ACCESS PTR TO WORKAREA
         ST    R15,CODESAVE-TSTCWORK(R8) STORE RETURN CODE
         LA    R15,@12        SET RETURN CODE TO PARSE
         B     GOHOME         RETURN TO PARSE
         EJECT
* THE FOLLOWING ARE MESSAGE OUTPUTTING ROUTINES.
MSG1     XC    TSTIOPRM,TSTIOPRM CLEAR PARAMETER AREA
         IKJEGSIO MSG,FIRST=(R2),SECOND=(R3),ID=WHR32,                 *
               MF=(E,TSTIOPRM)  CALL IO
         BR    R6             RETURN TO CALLER
         SPACE
MSG2     XC    TSTIOPRM,TSTIOPRM  CLEAR PARAMETER AREA
         IKJEGSIO MSG,FIRST=(R2),INST11=(NUM,I0016),SECOND=(R3),       *
               ID=WHR32,MF=(E,TSTIOPRM)  CALL IO
         BR    R6             RETURN TO CALLER
         SPACE
MSG3     XC    TSTIOPRM,TSTIOPRM  CLEAR PARAMETER AREA
         IKJEGSIO MSG,FIRST=(R2),INST11=(APDE,(R4)),SECOND=(R3),       *
               ID=WHR32,MF=(E,TSTIOPRM)  CALL IO
         CH    R15,ATTNCODE   IS RET CODE LESS 16
         BNL   PARS12         NO, RETURN WITH 12
         LA    R15,@8         YES, RC=8 (RE-ENTER)
         B     GOHOME         RETURN TO PARSE
         SPACE
LINKFL1  BAL   R5,LINKFAIL    PUT OUT ERR MSG
         CH    R15,ATTNCODE   IS RET CODE LESS THAN 16
         BNL   RET            NO,SEND RC BACK TO MAINLINE
         B     A0008          YES, SET RC=0, RETURN
         SPACE
LINKFL2  BAL   R5,LINKFAIL    PUT OUT ERR MSG
         CH    R15,ATTNCODE   IS RET CODE LESS THAN 16
         BNL   PARS12         NO, SET RC=12 FOR PARSE
         LA    R15,@8         YES, SET RC=8
         B     GOHOME         RETURN TO PARSE
         SPACE
LINKFAIL LR    R3,R1          ABEND CODE TO REG 3
         LR    R2,R15         RET CODE TO REG 2
         XC    TSTIOPRM,TSTIOPRM CLEAR PARAMETER AREA
         IKJEGSIO SVCERR,SVC=6,ABENDRG=(R3),RC=(R2),                   *
               INST11=(NUM,(R4)),ID=WHR32,MF=(E,TSTIOPRM) CALL IO
         BR    R5             RETURN TO CALLER
         SPACE
LISTESTA IKJEGSPL RTRY=RETRY,ABNTB=STAETAB,MODNM=IKJEGWHR,             *
               TNM=WHERE      BUILD ESTAE PARAMETER LIST
         TITLE 'IKJEGWHR, ''WHERE'' SUBCOMMAND, MACROS AND CONSTANTS'
PARSELST DC    V(IKJEGPRS)    ADDRESS OF PARAMETER PASSED TO PARSE
IKJEGPRS IKJPARM
GETADDR  IKJPOSIT   ADDRESS,VALIDCK=IKJEGVLC
*                             MACRO USED TO CHECK ADDRESS
         IKJENDP
         SPACE 5
LDNMVC2  MVC   @1(@1,R4),@0(R5) PUT LOADNAME IN MSG BUFFER
CTNMVC2  MVC   @10(@1,R4),@0(R5) PUT CSECT NAME IN MSG BUFFER
LDNMVC   MVC   @31(@1,R4),@0(R5) PUT LOADNAME IN MSG BUFFER
CTNMVC   MVC   @40(@1,R4),@0(R5) PUT CSECT NAME IN MSG BUFFER
MOVNAME  MVC   @0(@1,R1),@0(R3) MOVE NAME FROM PDE TO WORKAREA
MOVDISPL MVC   @30(@1,R1),@1(R10)  MOVE OFFSET TO OUTPUT
INVLD    MVC   @0(@1,R2),@0(R11) MSG DATA INTO OUTPUT BUFFER
CSECTMVC MVC   CSECTNAM-TSTCWORK(@1,R6),@0(R1) MOVE CSECT NAME
         SPACE 5
TRTAB    DC    C'0123456789ABCDEF' TRANSLATE TABLE
MDATA1   DC    C' LOCATED AT ' MSG DATA
MDATA2   DC    C' LOCATED IN ' MSG DATA
MDATA3   DC    C' UNDER TCB LOCATED AT ' MSG DATA
MDATA4   DC    C'NOT WITHIN ANY PROGRAM EXTENT ' MSG DATA
ADDRSIZE DC    X'000B0000'    SIZE OF ADDRESS
ATTNCODE DC    H'16'          ATTENTION RET CODE
CONSTANT DC    50C'Z'         ZAP AREA
         SPACE 5
************************************************************
*                                                          *
*                    EQUATES                               *
*                                                          *
************************************************************
ZERO     EQU   C'0'
HEX11    EQU   X'11'
HEX10    EQU   X'10'
HEX04    EQU   X'04'
HEX80    EQU   X'80'
HEXDF    EQU   X'DF'
HEXFF    EQU   X'FF'
HEX4E    EQU   X'4E'
HEX00    EQU   X'00'
HEXC0    EQU   X'C0'
BLANK    EQU   X'40'
TTCBPKF  EQU   28
DOT      EQU   X'4B'
@0       EQU   0
@1       EQU   1
@2       EQU   2
@3       EQU   3
@4       EQU   4
@5       EQU   5
@6       EQU   6
@7       EQU   7
@8       EQU   8
@9       EQU   9
@10      EQU   10
@12      EQU   12
@13      EQU   13
@14      EQU   14
@16      EQU   16
@18      EQU   18
@20      EQU   20
@21      EQU   21
@22      EQU   22
@24      EQU   24
@25      EQU   25
@27      EQU   27
@28      EQU   28
@30      EQU   30
@31      EQU   31
@32      EQU   32
@36      EQU   36
@38      EQU   38
@39      EQU   39
@40      EQU   40
@41      EQU   41
@44      EQU   44
@48      EQU   48
@49      EQU   49
@50      EQU   50
@51      EQU   51
@52      EQU   52
@53      EQU   53
@56      EQU   56
@57      EQU   57
@58      EQU   58
@60      EQU   60
@64      EQU   64
@67      EQU   67
@68      EQU   68
@70      EQU   70
@71      EQU   71
@76      EQU   76
@77      EQU   77
@81      EQU   81
@92      EQU   92
@96      EQU   96
@240     EQU   240
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
* THE FOLLOWING ARE 1ST LEVEL MESSAGE NO. EQUATES.
M0101    EQU   101            INVALID ADDRESS ...
M0103    EQU   103            NOT ENOUGH MAIN STORAGE
M0104    EQU   104            WHERE FAILED, CMMND SYS ERR
* THE FOLLOWING ARE 2ND LEVEL MESSAGE NO. EQUATES.
M0274    EQU   274            REG NOT. MUST BE INDRT GEN REG
M0277    EQU   277            PARSE ERROR CODE 12
* THE FOLLOWING ARE CONSTANT MESSAGE INSERTS.
I0016    EQU   16             WHERE
I0040    EQU   40             IKJPARS
I0085    EQU   85             IKJEGSYM
I0099    EQU   99             BLOW CODES FOR ABENDTABLE
         EJECT
STAETAB  DS    0F             TO ALIGN TO FULL WORD BOUNDRY
         DC    AL1(I0099)     STAE ABEND CODE FOR SYM LINK
         DC    AL3(BLOW1)     RESUME ADDR FOR STAE
         DC    AL1(I0099)     STAE ABEND CODE FOR SYM LINK
         DC    AL3(BLOW2)     RESUME ADDR FOR STAE
         DC    AL1(I0099)     STAE ABEND CODE FOR SYM LINK
         DC    AL3(BLOW3)     RESUME ADDR FOR STAE
         DC    X'FF'          INDICATE END OF TABLE
         DS    0F
LISTSTAE ESTAE MF=L           LIST FORM OF ESTAE
ENDLIST  EQU   *-LISTSTAE
SUBPOOL  EQU   *
         DC    AL1(0)         SUBPOOL NUMBER
         DC    AL3(104)       WORKAREA LENGTH IN BYTES
ARETRY   DC    AL3(RETRY)     ADDR OF STAE RETRY RTN
SYM      DC    C'SYM'         FOR BLDL ENTRY TO SYM
SMTSYM01 DS    0C             TEST CASE TTSTC120
LINKF    LINK  SF=L           LIST FORM FOR LINK
LINKL    EQU   *-LINKF        LENGTH OF LIST FORM OF LINK
        EJECT
*                                                          *
*         TEST COMMUNICATION TABLE DSECT                   *
*                                                          *
************************************************************
TCOMTAB TCOMTAB              MACRO THAT GENERATES TCOMTAB DSECT
        EJECT
************************************************************
*                                                          *
*              EXTENT BLOCK DSECT                          *
*                                                          *
************************************************************
         IHAXTLST
         EJECT
         IKJPPL
         EJECT
TCBDSECT IKJTCB             TCB DSECT
         EJECT
         IHACDE
         EJECT
         IKJRB
         EJECT
************************************************************
*                                                          *
*             ADDRESS PDE CREATED BY PARSE                 *
*                                                          *
************************************************************
         IKJPARMA
         EJECT
CVT      DSECT               CVT DSECT
         CVT
         EJECT
         IHALLE
         EJECT
         TSTCWORK
MYWORK   ORG   CWORKCMD       ORGANIZATION OF THIS MODULE WORKAREA
MYBUFFER DS    7A             THIS MODULE WORK BUFFER
ALIASAVE DS    2A             ALIA SAVE AREA
CSECTNAM DS    2A             CSECTNAMES
PPLSAVE  DS    7A             SAVE AREA
CODESAVE DS    1A             RETURN CODE SAVE AREA
PDESAVE  DS    7A             SAVE AREA
CURLD    DS    2A             CURRENT LOAD NAME
LOADNAME DS    2A             LOAD NAME
LOADSAVE DS    1A             SAVE AREA
USERSAVE DS    1A             USER SAVE
TCBCHAI  DS    1A             TCB CHAIN ADDRESS
TCBSAVE  DS    1A             TCB SAVE AREA
RBSAVE   DS    1A             RB SAVE AREA
CDESAVE  DS    1A             CDESAVE AREA
OFFSET2  DS    1A             OFFSET  VARIABLE
OFFSET   DS    1A             OFFSET  VARIABLE
MSGADDR  DS    1A             MSSG POINTER
MSGHOLD  DS    1A             MSSG HOLDING AREA
MSGHOLD2 DS    1A             MSSG HOLDING AREA
RETURN   DS    1A             RETURN ADDRESS SAVE AREA
          END
