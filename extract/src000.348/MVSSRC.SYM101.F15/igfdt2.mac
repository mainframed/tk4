         TITLE 'IGFDT2 - TAPE POSITIONING MODULE                       *
                        '
IGFDT2   CSECT ,                                                   0001
@MAINENT DS    0H                                                  0001
         USING *,@15                                               0001
         B     @PROLOG                                             0001
         DC    AL1(16)                                             0001
         DC    C'IGFDT2    77.109'                                 0001
         DROP  @15
@PROLOG  STM   @14,@12,12(@13)                                     0001
         BALR  @08,0                                               0001
@PSTART  DS    0H                                                  0001
         USING @PSTART,@08                                         0001
         L     @00,@SIZDATD                                        0001
         GETMAIN  R,LV=(0)
         LR    @09,@01                                             0001
         USING @DATD,@09                                           0001
         ST    @13,@SA00001+4                                      0001
         LM    @00,@01,20(@13)                                     0001
         ST    @09,8(,@13)                                         0001
         LR    @13,@09                                             0001
*                                      VERSION                       */
*   DO;                             /* ?IGFDERR INIT                 */
*                                                                  0116
*     /***************************************************************/
*     /*                                                             */
*     /* IGFDERR - INITIALIZE RECOVERY ENVIRONMENT                   */
*     /*                                                             */
*     /***************************************************************/
*                                                                  0117
*     DERPLIST=DERPLIST&&DERPLIST;  /* CLEAR PARAMETER LIST          */
         XC    DERPLIST(48),DERPLIST                               0117
*     DERFUNK=DERINIT;              /* INDICATE INIT FUNCTION        */
         MVI   DERFUNK,X'01'                                       0118
*     DERREC=ADDR(DERRECPM);        /* POINT TO REC PARMS            */
         LA    @14,DERRECPM                                        0119
         ST    @14,DERREC                                          0119
*     DERSPEC=ADDR(IGFDT2S);        /* POINT TO SPECIAL EXIT         */
         LA    @14,IGFDT2S                                         0120
         ST    @14,DERSPEC                                         0120
*     DERRETRY=ADDR(IGFDT2R);       /* POINT TO RETRY ROUTINE        */
         LA    @14,IGFDT2R                                         0121
         ST    @14,DERRETRY                                        0121
*     GEN SETS(DERDATD)(MVC DERDATD,@SIZDATD);/* SET UP SPN, SIZE    */
         MVC DERDATD,@SIZDATD
*     DERTAPE='1'B;                 /* INDICATE RESOURCE HELD        */
         OI    DERTAPE,B'10000000'                                 0123
*     DERPFX=DERRMASK;              /* SET UP RUB MASK               */
         MVC   DERPFX(2),@CB00670                                  0124
*     DERRCODE=CODEBASE;            /* SAVE CODEREG                  */
         ST    CODEBASE,DERRCODE                                   0125
*     DERRDATA=DATABASE;            /* SAVE DATAREG                  */
         ST    DATABASE,DERRDATA                                   0126
*     DERRDDR=DDRPTR;               /* SAVE DDRCOM POINTER           */
         ST    DDRPTR,DERRDDR                                      0127
*     DERRSAVE=SAVEPTR;             /* SAVE REGISTER 13              */
         ST    SAVEPTR,DERRSAVE                                    0128
*     CALL IGFDE0(DERPLIST);        /* ISSUE ESTAE                   */
         LA    @14,DERPLIST                                        0129
         ST    @14,@AL00001                                        0129
         L     @15,@CV00605                                        0129
         LA    @01,@AL00001                                        0129
         BALR  @14,@15                                             0129
*   END;                            /* ?IGFDERR INIT ESTAE         0130
*                                      ESTABLISHED                   */
*   DERLRC=0;                       /* SET LOCAL RETURN CODE TO 0    */
         MVI   DERLRC,X'00'                                        0131
*   MOUNTSWH='1'B;                  /* SET MOUNT REQUIRED            */
*   VERIFSWH='1'B;                  /* SET VERIFY LOOP CONTROL       */
         OI    MOUNTSWH,B'11000000'                                0133
*   LABLKCNT=0;                     /* ZERO LABEL BLOCK COUNT        */
         SLR   LABLKCNT,LABLKCNT                                   0134
*   WRVOLCNT=0;                     /* ZERO WRONG VOLUME COUNT       */
         SLR   WRVOLCNT,WRVOLCNT                                   0135
*   BLOCKCNT=DDRUBCNT;              /* USER BLOCK COUNT      @YM04069*/
         L     BLOCKCNT,DDRUBCNT(,DDRPTR)                          0136
*   FILECNT=UCBFSCT;                /* PHYSICAL FILE COUNT   @ZA18577*/
         L     @14,UCBPTR(,DDRPTR)                                 0137
         LH    FILECNT,UCBFSCT(,@14)                               0137
*   IOBUFFER=IOBUFFER&&IOBUFFER;    /* ZERO BUFFER                   */
         L     @14,DDRIBUF(,DDRPTR)                                0138
         XC    IOBUFFER(80,@14),IOBUFFER(@14)                      0138
*   IF DDRLNOP='0'B THEN            /* NOP LABEL?                    */
         TM    DDRLNOP(DDRPTR),B'00000001'                         0139
         BNZ   @RF00139                                            0139
*     DO;                           /* NO- CONTINIE PROCESSING       */
*       IF DDRLNL='1'B THEN         /* NO LABEL?                     */
         TM    DDRLNL(DDRPTR),B'00100000'                          0141
         BNO   @RF00141                                            0141
*         CALL DT2NL;               /* YES-CALL NO LABEL ROUTINE     */
         BAL   @14,DT2NL                                           0142
*       ELSE                        /* NOT NO LABEL                  */
*         IF DDRLSD='1'B×DDRLAL='1'B THEN/* STANDARD OR ANSI LABEL?  */
         B     @RC00141                                            0143
@RF00141 TM    DDRLSD(DDRPTR),B'10001000'                          0143
         BZ    @RF00143                                            0143
*           CALL DT2SLAL;           /* YES- CALL SL AND AL ROUTINE   */
         BAL   @14,DT2SLAL                                         0144
*         ELSE                      /* NOT STANDARD OR ANSI LABEL    */
*           CALL DT2NSL;            /* NSL ROUTINE                   */
         B     @RC00143                                            0145
@RF00143 BAL   @14,DT2NSL                                          0145
*     END;                                                         0146
*   ELSE                                                           0147
*     ;                             /* YES - A NOP LABEL             */
*                                                                  0147
@RF00139 DS    0H                                                  0148
*   /*****************************************************************/
*   /*                                                               */
*   /* THIS IS THE COMMON EXIT ROUTINE FOR THIS MODULE               */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0148
*IGFDT2R:                                                          0148
*   ;                                                              0148
@RC00139 DS    0H                                                  0148
IGFDT2R  DS    0H                                                  0149
*   DO;                             /* ?IGFDERR CANCEL               */
*                                                                  0149
*     /***************************************************************/
*     /*                                                             */
*     /* IGFDERR - CANCEL RECOVERY ENVIRONMENT                       */
*     /*                                                             */
*     /***************************************************************/
*                                                                  0150
*     DERFUNK=DERCANC;              /* INDICATE CANCEL               */
         MVI   DERFUNK,X'02'                                       0150
*     CALL IGFDE0(DERPLIST);        /* CANCEL ESTAE                  */
         LA    @14,DERPLIST                                        0151
         ST    @14,@AL00001                                        0151
         L     @15,@CV00605                                        0151
         LA    @01,@AL00001                                        0151
         BALR  @14,@15                                             0151
*   END;                            /* ?IGFDERR CANCEL ESTAE CANCEL  */
*   RETURN CODE(DERLRC);            /* RETURN TO CALLER              */
         SLR   @12,@12                                             0153
         IC    @12,DERLRC                                          0153
         L     @13,4(,@13)                                         0153
         L     @00,@SIZDATD                                        0153
         LR    @01,@09                                             0153
         FREEMAIN R,LV=(0),A=(1)
         LR    @15,@12                                             0153
         L     @14,12(,@13)                                        0153
         LM    @00,@12,20(@13)                                     0153
         BR    @14                                                 0153
*                                                                  0154
*   /*****************************************************************/
*   /*                                                               */
*   /* NO LABEL SUBROUTINE                                           */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0154
*DT2NL:                                                            0154
*   PROC;                           /* THIS SUBROUTINE MOUNTS AND  0154
*                                      POSITIONS THE TAPE AND NO   0154
*                                      VOLUME VERIFICATION IS      0154
*                                      NECESSARY                     */
DT2NL    STM   @14,@12,@SA00002                                    0154
*   DDRIOF1=DDRNOP;                 /* SET NOP COMMAND FLAG  @YM04069*/
         MVI   DDRIOF1(DDRPTR),X'03'                               0155
*   CALL DT2MOUNT;                  /* MOUNT TAPE            @YM04069*/
         BAL   @14,DT2MOUNT                                        0156
*   IF DERLRC=0 THEN                /* RETURN CODE ZERO ?    @YM04069*/
         CLI   DERLRC,0                                            0157
         BNE   @RF00157                                            0157
*     CALL DT2DATA;                 /* YES- POSITION TAPE    @YM04069*/
         BAL   @14,DT2DATA                                         0158
*   RETURN;                         /* RETURN TO CALLER              */
@EL00002 DS    0H                                                  0159
@EF00002 DS    0H                                                  0159
@ER00002 LM    @14,@12,@SA00002                                    0159
         BR    @14                                                 0159
*   END DT2NL;                                                     0160
         B     @EL00002                                            0160
*                                                                  0161
*   /*****************************************************************/
*   /*                                                               */
*   /* STANDARD AND ANSI LABEL SUBROUTINE                            */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0161
*DT2SLAL:                                                          0161
*   PROC;                           /* ENTRY POINT                   */
DT2SLAL  STM   @14,@12,@SA00003                                    0161
*   DO WHILE(VERIFSWH='1'B);        /* IS LABEL VERIFICATION       0162
*                                      COMPLETE?                     */
         B     @DE00162                                            0162
@DL00162 DS    0H                                                  0163
*/*   NO - SWITCH IS ON                                              */
*                                                                  0163
*     DDRIOF1=DDRREAD;              /* SET READ OPERATION FLAG       */
         MVI   DDRIOF1(DDRPTR),X'02'                               0163
*     DDRIBUFL=LENGTH(IOBUFFER);    /* BUFFER LENGTH OF 80           */
         MVC   DDRIBUFL(2,DDRPTR),@CH00599                         0164
*     CALL DT2MOUNT;                /* MOUNT TAPE                    */
         BAL   @14,DT2MOUNT                                        0165
*     IF DERLRC^=0 THEN             /* NON-ZERO RETURN CODE ?        */
         CLI   DERLRC,0                                            0166
         BE    @RF00166                                            0166
*       VERIFSWH='0'B;              /* YES - ERROR CONDITION         */
         NI    VERIFSWH,B'10111111'                                0167
*     ELSE                          /* NO -ZERO RETURN CODE          */
*       DO;                                                        0168
         B     @RC00166                                            0168
@RF00166 DS    0H                                                  0169
*         IF DDRLAL='1'B THEN       /* ANSI LABEL ?                  */
         TM    DDRLAL(DDRPTR),B'10000000'                          0169
         BNO   @RF00169                                            0169
*           DO;                     /* YES - AN ANSI LABEL           */
*             XLATEADD=ADDR(IOBUFFER);/* LABEL BUFFER ADDRESS        */
         L     @14,DDRIBUF(,DDRPTR)                                0171
         ST    @14,XLATEADD                                        0171
*             GEN REFS(XLATEADD);                                  0172
             XLATE XLATEADD,10,TO=E
*             YES-THE LABEL IS ANSI.  THE FIRST 10 BYTES OF THE
*             LABEL ARE TRANSLATED TO EBCDIC.
*           END;                                                   0173
*         ELSE                                                     0174
*           ;                       /* NO - NOT AN ANSI LABEL        */
@RF00169 DS    0H                                                  0175
*         IF VOLLABIN='VOL1'&VOLSERNO=DDRTOUCB->UCBVOLI THEN/* VOL 0175
*                                      LABEL CORRECT ?               */
         L     @14,DDRIBUF(,DDRPTR)                                0175
         CLC   VOLLABIN(4,@14),@CC00688                            0175
         BNE   @RF00175                                            0175
         L     @12,DDRTOUCB(,DDRPTR)                               0175
         CLC   VOLSERNO(6,@14),UCBVOLI(@12)                        0175
         BNE   @RF00175                                            0175
*           VERIFSWH='0'B;          /* YES - LABEL IS CORRECT        */
         NI    VERIFSWH,B'10111111'                                0176
*         ELSE                      /* NO - LABEL IS INCORRECT       */
*           CALL DT2WRONG;          /* REWIND THE TAPE AND ISSUE THE
*                                      WRONG VOLUME MESSAGE          */
         B     @RC00175                                            0177
@RF00175 BAL   @14,DT2WRONG                                        0177
*       END;                                                       0178
@RC00175 DS    0H                                                  0179
*   END;                            /* END OF DO LOOP                */
@RC00166 DS    0H                                                  0179
@DE00162 TM    VERIFSWH,B'01000000'                                0179
         BO    @DL00162                                            0179
*/*   LABEL VERIFICATION IS COMPLETE                                 */
*                                                                  0180
*   IF DERLRC=0 THEN                /* IS LOCAL RETURN CODE ZERO ?   */
         CLI   DERLRC,0                                            0180
         BNE   @RF00180                                            0180
*     CALL DT2DATA;                 /* YES- POSITION DATA AND FILE   */
         BAL   @14,DT2DATA                                         0181
*   ELSE                                                           0182
*     ;                             /* NON-ZERO RETURN CODE          */
@RF00180 DS    0H                                                  0183
*   RETURN;                         /* RETURN TO CALLER              */
@EL00003 DS    0H                                                  0183
@EF00003 DS    0H                                                  0183
@ER00003 LM    @14,@12,@SA00003                                    0183
         BR    @14                                                 0183
*   END DT2SLAL;                                                   0184
*                                                                  0185
*   /*****************************************************************/
*   /*                                                               */
*   /* NON-STANDARD LABEL SUBROUTINE                                 */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0185
*DT2NSL:                                                           0185
*   PROC;                           /* ENTRY POINT                   */
DT2NSL   STM   @14,@12,@SA00004                                    0185
*   DERLRC=0;                       /* SET LOCAL RETURN CODE TO ZERO */
         MVI   DERLRC,X'00'                                        0186
*   DO WHILE(VERIFSWH='1'B);        /* IS VOL VERIFICATION COMPLETE ?*/
         B     @DE00187                                            0187
@DL00187 DS    0H                                                  0188
*/*   VOL VERIFY NOT COMPLETE - SWITCH IS ON                         */
*                                                                  0188
*     IF MOUNTSWH='1'B THEN         /* IS MOUNT SWITCH ON ?          */
         TM    MOUNTSWH,B'10000000'                                0188
         BNO   @RF00188                                            0188
*       DO;                         /* YES                           */
*         MOUNTSWH='0'B;            /* CLEAR MOUNT SWITCH            */
         NI    MOUNTSWH,B'01111111'                                0190
*         DDRIOF1=DDRREAD;          /* SET READ OPERATION FLAG       */
         MVI   DDRIOF1(DDRPTR),X'02'                               0191
*         DDRIBUFL=LENGTH(IOBUFFER);/* BUFFER LENGTH IS 80 BYTES     */
         MVC   DDRIBUFL(2,DDRPTR),@CH00599                         0192
*         CALL DT2MOUNT;            /* MOUNT TAPE                    */
         BAL   @14,DT2MOUNT                                        0193
*       END;                                                       0194
*     ELSE                                                         0195
*       ;                           /* NO - MOUNT NOT REQUIRED       */
@RF00188 DS    0H                                                  0196
*     IF DERLRC^=0 THEN             /* LOCAL RETURN CODE IS ZERO ?   */
         CLI   DERLRC,0                                            0196
         BE    @RF00196                                            0196
*       VERIFSWH='0'B;              /* NO - CLEAR VERIFY SWITCH      */
         NI    VERIFSWH,B'10111111'                                0197
*     ELSE                          /* YES - ZERO RETURN CODE        */
*       DO;                                                        0198
         B     @RC00196                                            0198
@RF00196 DS    0H                                                  0199
*         SVC85SWH='1'B;            /* SET SVC 85 SWITCH             */
         OI    SVC85SWH,B'00100000'                                0199
*         R1=DDRPTR;                /* DDRCOM ADDRESS IN REG 1       */
         LR    R1,DDRPTR                                           0200
*         SVC(85);                  /* USER EXIT TO NSLREPOS         */
         SVC   85                                                  0201
*         SVC85SWH='0'B;            /* CLEAR SVC 85 SWITCH           */
         NI    SVC85SWH,B'11011111'                                0202
*         IF RTNCODE//4=0&RTNCODE>=0&RTNCODE<=20 THEN/* VALID RETURN
*                                      CODE ?                        */
         SLR   @14,@14                                             0203
         LR    @02,RTNCODE                                         0203
         SRDA  @02,32                                              0203
         D     @02,@CF00134                                        0203
         CR    @02,@14                                             0203
         BNE   @RF00203                                            0203
         CR    RTNCODE,@14                                         0203
         BL    @RF00203                                            0203
         C     RTNCODE,@CF00694                                    0203
         BH    @RF00203                                            0203
*           DO;                     /* YES - (0,4,8,12,16,20)        */
*             SUBPTR=DT2SUBS(RTNCODE/4+1);/* SELECT SUBROUTINE       */
         LR    @02,RTNCODE                                         0205
         SRDA  @02,32                                              0205
         D     @02,@CF00134                                        0205
         SLA   @03,2                                               0205
         L     SUBPTR,DT2SUBS(@03)                                 0205
*             CALL DT2SUB;          /* ENTER CORRECT SUBROUTINE      */
         LR    @15,SUBPTR                                          0206
         BALR  @14,@15                                             0206
*           END;                                                   0207
*         ELSE                                                     0208
*           DO;                     /* INVALID RETURN CODE           */
         B     @RC00203                                            0208
@RF00203 DS    0H                                                  0209
*             CALL DT2UNLD;         /* REWIND AND UNLOAD TAPE        */
         BAL   @14,DT2UNLD                                         0209
*             DDRTER1=DDRTIU;       /* INVALID USER EXIT             */
         MVI   DDRTER1(DDRPTR),X'06'                               0210
*             DERLRC=12;            /* SET LOCAL RETURN CODE         */
         MVI   DERLRC,X'0C'                                        0211
*             VERIFSWH='0'B;        /* CLEAR VERIFY SWITCH           */
         NI    VERIFSWH,B'10111111'                                0212
*           END;                                                   0213
*       END;                                                       0214
@RC00203 DS    0H                                                  0215
*   END;                            /* END OF DO LOOP                */
@RC00196 DS    0H                                                  0215
@DE00187 TM    VERIFSWH,B'01000000'                                0215
         BO    @DL00187                                            0215
*   IF DERLRC=0 THEN                /* IS RETURN CODE ZERO ?         */
         CLI   DERLRC,0                                            0216
         BNE   @RF00216                                            0216
*     DO;                           /* YES - ZERO RETURN CODE        */
*       IF BLOCKCNT>0&FILECNT^>0 THEN/* RECALCULATE TAPE POSITION ?  */
         SLR   @14,@14                                             0218
         CR    BLOCKCNT,@14                                        0218
         BNH   @RF00218                                            0218
         CR    FILECNT,@14                                         0218
         BH    @RF00218                                            0218
*         BLOCKCNT=MAX(BLOCKCNT-LABLKCNT,0);/* YES-CHANGE BLOCKCNT   */
         LR    @12,BLOCKCNT                                        0219
         SLR   @12,LABLKCNT                                        0219
         CR    @12,@14                                             0219
         BNL   *+6
         LR    @12,@14                                             0219
         LR    BLOCKCNT,@12                                        0219
*       ELSE                                                       0220
*         ;                         /* NO - DO NOT CHANGE BLOCKCOUNT */
@RF00218 DS    0H                                                  0221
*       CALL DT2DATA;               /* POSITION DATA AND FILE        */
         BAL   @14,DT2DATA                                         0221
*     END;                                                         0222
*   ELSE                                                           0223
*     ;                             /* RETURN CODE IS NON-ZERO, THE
*                                      TAPE POSITION IS NOT CHANGED  */
@RF00216 DS    0H                                                  0224
*   RETURN;                         /* RETURN TO CALLER              */
@EL00004 DS    0H                                                  0224
@EF00004 DS    0H                                                  0224
@ER00004 LM    @14,@12,@SA00004                                    0224
         BR    @14                                                 0224
*   END DT2NSL;                                                    0225
*                                                                  0226
*   /*****************************************************************/
*   /*                                                               */
*   /* I/O ERROR SUBROUTINE                                          */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0226
*DT2IOERR:                                                         0226
*   PROC;                           /* THIS SUBROUTINE IS ENTERED  0226
*                                      WHEN AN I/O ERROR OCCURS    0226
*                                      DURING THE TAPE POSITIONING   */
DT2IOERR STM   @14,@05,@SA00005                                    0226
         STM   @07,@12,@SA00005+32                                 0226
*   VERIFSWH='0'B;                  /* CLEAR VERIFY SWITCH           */
         NI    VERIFSWH,B'10111111'                                0227
*   CALL DT2UNLD;                   /* REWIND AND UNLOAD TAPE        */
         BAL   @14,DT2UNLD                                         0228
*   DERLRC=4;                       /* SET LOCAL RETURN CODE         */
         MVI   DERLRC,X'04'                                        0229
*   RETURN;                         /* RETURN TO CALLER              */
@EL00005 DS    0H                                                  0230
@EF00005 DS    0H                                                  0230
@ER00005 LM    @14,@05,@SA00005                                    0230
         LM    @07,@12,@SA00005+32                                 0230
         BR    @14                                                 0230
*   END DT2IOERR;                                                  0231
*                                                                  0232
*   /*****************************************************************/
*   /*                                                               */
*   /* DATA AND FILE POSITIONING SUBROUTINE                          */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0232
*DT2DATA:                                                          0232
*   PROC;                           /* THIS SUBROUTINE RECEIVES    0232
*                                      CONTROL FROM DT2NL- AFTER TAPE
*                                      HAS BEEN MOUNTED AND FROM   0232
*                                      DT2SLAL OR DT2NSL - AFTER   0232
*                                      LABEL HAS BEEN VERIFIED. THIS
*                                      ROUTINE WILL FORWARD SPACE THE
*                                      TAPE USING SKIP FILE COMMANDS
*                                      AND THEN READ THRU THE RECORDS
*                                      IN THE FILE UP TO THE FAILING
*                                      OR LAST RECORD.               */
DT2DATA  STM   @14,@12,@SA00006                                    0232
*   IF FILECNT^=0 THEN              /* IS FILE POSITIONING NECESSARY
*                                      ?                             */
         LTR   FILECNT,FILECNT                                     0233
         BZ    @RF00233                                            0233
*     DO;                           /* YES                           */
*       DDRIOF1=DDRFSF;             /* SET FORWARD SPACE FILE COMMAND
*                                      FLAG                          */
         MVI   DDRIOF1(DDRPTR),X'3F'                               0235
*       DDRIOF2=0;                  /* CLEAR BYTE                    */
         MVI   DDRIOF2(DDRPTR),X'00'                               0236
*       DDRICNT='1'B;               /* SET MULTIPLE COUNT INDICATOR  */
*       DDRITAKE='1'B;              /* SET CONTROL INDICATOR         */
         OI    DDRICNT(DDRPTR),B'01001000'                         0238
*       DDRCOUNT=FILECNT;           /* I/O REPEAT COUNT              */
         ST    FILECNT,DDRCOUNT(,DDRPTR)                           0239
*       CALL IGFDM1;                /* SKIP FILES                    */
         L     @15,@CV00608                                        0240
         BALR  @14,@15                                             0240
*       DERLRC=RTNCODE;             /* SET LOCAL RETURN CODE         */
         STC   RTNCODE,DERLRC                                      0241
*     END;                                                         0242
*   ELSE                                                           0243
*     ;                                                            0243
@RF00233 DS    0H                                                  0244
*   IF DERLRC=0 THEN                /* IS RETURN CODE ZERO ?         */
         CLI   DERLRC,0                                            0244
         BNE   @RF00244                                            0244
*     IF BLOCKCNT^=0 THEN           /* YES - IS BLOCKCOUNT ZERO ?    */
         SLR   @14,@14                                             0245
         CR    BLOCKCNT,@14                                        0245
         BE    @RF00245                                            0245
*       DO;                         /* NO - BLOCKCOUNT IS NON-ZERO   */
*         IF BLOCKCNT<0 THEN        /* YES - IS BLOCKCOUNT NEGATIVE ?*/
         CR    BLOCKCNT,@14                                        0247
         BNL   @RF00247                                            0247
*           DO;                     /* YES - WITH A NEGATIVE       0248
*                                      BLOCKCOUNT, THE TAPE HAS BEEN
*                                      SPACED ONE FILE BEYOND THE  0248
*                                      REQUIRED POINT                */
*             DDRIOF1=DDRBSF;       /* SET BACKSPACE FILE COMMAND  0249
*                                      FLAG                          */
         MVI   DDRIOF1(DDRPTR),X'2F'                               0249
*             DDRIOF2=0;            /* CLEAR BYTE                    */
         MVI   DDRIOF2(DDRPTR),X'00'                               0250
*             DDRITAKE='1'B;        /* SET CONTROL INDICATOR         */
         OI    DDRITAKE(DDRPTR),B'01000000'                        0251
*             CALL IGFDM1;          /* BACKSPACE FILE                */
         L     @15,@CV00608                                        0252
         BALR  @14,@15                                             0252
*             DERLRC=RTNCODE;       /* SET LOCAL RETURN CODE         */
         STC   RTNCODE,DERLRC                                      0253
*             DDRIOF1=DDRRDBK;      /* SET READ BACKWARDS COMMAND  0254
*                                      FLAG                          */
         MVI   DDRIOF1(DDRPTR),X'0C'                               0254
*           END;                                                   0255
*         ELSE                      /* NO - POSITIVE BLOCKCOUNT      */
*           DDRIOF1=DDRREAD;        /* SET READ COMMAND FLAG         */
         B     @RC00247                                            0256
@RF00247 MVI   DDRIOF1(DDRPTR),X'02'                               0256
*         IF DERLRC=0 THEN          /* IS RETURN CODE ZERO ?         */
@RC00247 CLI   DERLRC,0                                            0257
         BNE   @RF00257                                            0257
*           DO;                     /* YES                           */
*             DDRIOF2=0;            /* CLEAR BYTE                    */
         MVI   DDRIOF2(DDRPTR),X'00'                               0259
*             DDRITAKE='1'B;        /* SET CONTROL INDICATOR         */
*             DDRICNT='1'B;         /* SET MULTIPLE COUNT INDICATOR  */
         OI    DDRITAKE(DDRPTR),B'01001000'                        0261
*             DDRIBUFL=NOTNOISE;    /* SET BUFFER LENGTH             */
         MVC   DDRIBUFL(2,DDRPTR),@CH00621                         0262
*             DDRCOUNT=BLOCKCNT;    /* I/O REPEAT COUNT              */
         ST    BLOCKCNT,DDRCOUNT(,DDRPTR)                          0263
*             CALL IGFDM1;          /* READ OR READ BACKWARDS        */
         L     @15,@CV00608                                        0264
         BALR  @14,@15                                             0264
*             DERLRC=RTNCODE;       /* SET LOCAL RETURN CODE         */
         STC   RTNCODE,DERLRC                                      0265
*           END;                                                   0266
*         ELSE                                                     0267
*           ;                       /* NO - RETURN CODE IS NON-ZERO  */
@RF00257 DS    0H                                                  0268
*       END;                                                       0268
*     ELSE                                                         0269
*       ;                           /* YES - BLOCKCOUNT IS ZERO      */
@RF00245 DS    0H                                                  0270
*   ELSE                                                           0270
*     ;                             /* NO - RETURN CODE IS NON-ZERO  */
@RF00244 DS    0H                                                  0271
*   IF DERLRC^=0 THEN               /* IS RETURN CODE ZERO ?         */
         CLI   DERLRC,0                                            0271
         BE    @RF00271                                            0271
*     CALL DT2IOERR;                /* NO - I/O ERROR                */
         BAL   @14,DT2IOERR                                        0272
*   ELSE                                                           0273
*     ;                             /* YES-RETURN CODE IS ZERO       */
@RF00271 DS    0H                                                  0274
*   RETURN;                         /* RETURN TO CALLER              */
@EL00006 DS    0H                                                  0274
@EF00006 DS    0H                                                  0274
@ER00006 LM    @14,@12,@SA00006                                    0274
         BR    @14                                                 0274
*   END DT2DATA;                                                   0275
*                                                                  0276
*   /*****************************************************************/
*   /*                                                               */
*   /* MOUNT SUBROUTINE                                              */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0276
*DT2MOUNT:                                                         0276
*   PROC;                           /* THIS SUBROUTINE IS CALLED VIA
*                                      DT2NL,DT2SLAL, AND DT2NSL WHEN
*                                      A TAPE MOUNT IS REQUIRED      */
DT2MOUNT STM   @14,@03,@SA00007                                    0276
         STM   @07,@12,@SA00007+24                                 0276
*   DDRIOF2=0;                      /* CLEAR BYTE                    */
         MVI   DDRIOF2(DDRPTR),X'00'                               0277
*   DDRITAKE='1'B;                  /* SET CONTROL INDICATOR         */
*   DDRIMNT='1'B;                   /* SET MOUNT INDICATOR           */
         OI    DDRITAKE(DDRPTR),B'01010000'                        0279
*   CALL IGFDM1;                    /* ISSUE I/O COMMAND             */
         L     @15,@CV00608                                        0280
         BALR  @14,@15                                             0280
*   IF RTNCODE=0 THEN               /* IS RETURN CODE ZERO ?         */
         LTR   RTNCODE,RTNCODE                                     0281
         BNZ   @RF00281                                            0281
*     DO;                           /* YES - RETURN IS ZERO          */
*       DDRINV2=DDRVUS;             /* VALIDATE USER                 */
         MVI   DDRINV2(DDRPTR),X'03'                               0283
*       CALL IGFDT1;                /* CHECK USER STILL ACTIVE       */
         L     @15,@CV00607                                        0284
         BALR  @14,@15                                             0284
*       IF^(RTNCODE=0&DDRTOUCB->UCBVOLI^=ZERO6) THEN               0285
         LTR   RTNCODE,RTNCODE                                     0285
         BNZ   @RT00285                                            0285
         L     @14,DDRTOUCB(,DDRPTR)                               0285
         CLC   UCBVOLI(6,@14),@CB00624                             0285
         BNE   @RF00285                                            0285
@RT00285 DS    0H                                                  0286
*         DO;                       /* RETURN CODE IS NON-ZERO AND/OR
*                                      THE VOLUME SERIAL NUMBER IS 0286
*                                      ZERO                          */
*           CALL DT2UNLD;           /* REWIND AND UNLOAD             */
         BAL   @14,DT2UNLD                                         0287
*           DDRTER1=DDRTNF;         /* NO USER FOUND                 */
         MVI   DDRTER1(DDRPTR),X'01'                               0288
*           DERLRC=12;              /* SET LOCAL RETURN CODE         */
         MVI   DERLRC,X'0C'                                        0289
*         END;                                                     0290
*       ELSE                        /* RETURN CODE IS ZERO AND VOLUME
*                                      SERIAL NUMBER IS NON-ZERO     */
*         DO;                       /*                       @YM04069*/
         B     @RC00285                                            0291
@RF00285 DS    0H                                                  0292
*           BLOCKCNT=DDRUBCNT;      /* RE-INIT BLOCK COUNT FOR USER
*                                      OPERATOR SWAP BECAUSE T1 CAN
*                                      CHANGE THE COUNT      @YM04069*/
         L     BLOCKCNT,DDRUBCNT(,DDRPTR)                          0292
*           IF DDRLNL='1'B THEN     /* NO LABEL ?            @YM04069*/
         TM    DDRLNL(DDRPTR),B'00100000'                          0293
         BNO   @RF00293                                            0293
*             IF BLOCKCNT<0 THEN    /* NEGATIVE BLOCKCOUNT ? --    0294
*                                                            @YM04069
*                                      OCCURS DURING A READ BACKWARDS
*                                      OPERATION                     */
         SLR   @14,@14                                             0294
         CR    BLOCKCNT,@14                                        0294
         BNL   @RF00294                                            0294
*               FILECNT=MAX(FILECNT-1,0)+1;/* YES- CALCULATE THE   0295
*                                      FILECOUNT WHICH MUST BE     0295
*                                      POSITIVE              @YM04069*/
         LR    @12,FILECNT                                         0295
         BCTR  @12,0                                               0295
         CR    @12,@14                                             0295
         BNL   *+6
         LR    @12,@14                                             0295
         AL    @12,@CF00051                                        0295
         LR    FILECNT,@12                                         0295
*             ELSE                                                 0296
*               FILECNT=MAX(FILECNT-1,0);/* POSITIVE BLOCKCOUNT    0296
*                                                            @YM04069*/
         B     @RC00294                                            0296
@RF00294 LR    @14,FILECNT                                         0296
         BCTR  @14,0                                               0296
         SLR   @12,@12                                             0296
         CR    @14,@12                                             0296
         BNL   *+6
         LR    @14,@12                                             0296
         LR    FILECNT,@14                                         0296
*           ELSE                    /* NOT NO LABEL          @YM04069*/
*             IF DDRLSD='1'B×DDRLAL='1'B THEN/* STANDARD OR ANSI   0297
*                                      LABEL ?               @YM04069*/
         B     @RC00293                                            0297
@RF00293 TM    DDRLSD(DDRPTR),B'10001000'                          0297
         BZ    @RF00297                                            0297
*               IF BLOCKCNT<0 THEN  /* NEGATIVE BLOCKCOUNT ? @YM04069*/
         LTR   BLOCKCNT,BLOCKCNT                                   0298
         BNM   @RF00298                                            0298
*                 FILECNT=3*MAX(FILECNT,1)-1;/* YES - CALCULATE    0299
*                                      FILECOUNT                     */
         LA    @14,1                                               0299
         CR    @14,FILECNT                                         0299
         BNL   *+6
         LR    @14,FILECNT                                         0299
         MH    @14,@CH00132                                        0299
         BCTR  @14,0                                               0299
         LR    FILECNT,@14                                         0299
*               ELSE                                               0300
*                 FILECNT=3*MAX(FILECNT,1)-2;/* POSITIVE BLOCKCNT  0300
*                                                            @YM04069*/
         B     @RC00298                                            0300
@RF00298 LA    @14,1                                               0300
         CR    @14,FILECNT                                         0300
         BNL   *+6
         LR    @14,FILECNT                                         0300
         MH    @14,@CH00132                                        0300
         BCTR  @14,0                                               0300
         BCTR  @14,0                                               0300
         LR    FILECNT,@14                                         0300
*             ELSE                  /* NOT STANDARD OR ANSI LABEL  0301
*                                                            @YM04069*/
*               IF DDRLNSL='1'B THEN/* NSL LABEL ?           @YM04069*/
         B     @RC00297                                            0301
@RF00297 TM    DDRLNSL(DDRPTR),B'00010000'                         0301
         BNO   @RF00301                                            0301
*                 IF BLOCKCNT<0 THEN/* NEGATIVE BLOCKCOUNT ? --    0302
*                                                            @YM04069
*                                      OCCURS DURING A READ BACKWARDS
*                                      OPERATION                     */
         SLR   @14,@14                                             0302
         CR    BLOCKCNT,@14                                        0302
         BNL   @RF00302                                            0302
*                   FILECNT=MAX(FILECNT-1,0)+1;/* YES- CALCULATE THE
*                                      FILECOUNT WHICH MUST BE     0303
*                                      POSITIVE              @YM04069*/
         LR    @12,FILECNT                                         0303
         BCTR  @12,0                                               0303
         CR    @12,@14                                             0303
         BNL   *+6
         LR    @12,@14                                             0303
         AL    @12,@CF00051                                        0303
         LR    FILECNT,@12                                         0303
*                 ELSE                                             0304
*                   FILECNT=MAX(FILECNT-1,0);/* POSITIVE BLOCKCOUNT
*                                                            @YM04069*/
         B     @RC00302                                            0304
@RF00302 LR    @14,FILECNT                                         0304
         BCTR  @14,0                                               0304
         SLR   @12,@12                                             0304
         CR    @14,@12                                             0304
         BNL   *+6
         LR    @14,@12                                             0304
         LR    FILECNT,@14                                         0304
*         END;                      /*                       @YM04069*/
*     END;                          /*                       @YM04069*/
*   ELSE                            /* NO - RETURN CODE IS NON-ZERO  */
*     CALL DT2IOERR;                /* I/O ERROR                     */
         B     @RC00281                                            0307
@RF00281 BAL   @14,DT2IOERR                                        0307
*   RETURN;                         /* RETURN TO CALLER              */
@EL00007 DS    0H                                                  0308
@EF00007 DS    0H                                                  0308
@ER00007 LM    @14,@03,@SA00007                                    0308
         LM    @07,@12,@SA00007+24                                 0308
         BR    @14                                                 0308
*   END DT2MOUNT;                                                  0309
         B     @EL00007                                            0309
*                                                                  0310
*   /*****************************************************************/
*   /*                                                               */
*   /* WRONG VOLUME SUBROUTINE                                       */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0310
*DT2WRONG:                                                         0310
*   PROC;                           /* THIS SUBROUTINE REWINDS AND 0310
*                                      UNLOADS THE WRONG VOLUME AND
*                                      ISSUES IGF511A MESSAGE. THIS
*                                      ROUTINE IS CALLED BY DT2SLAL
*                                      AND DT2NSL.                   */
DT2WRONG STM   @14,@05,@SA00008                                    0310
         STM   @08,@12,@SA00008+32                                 0310
*   WRVOLCNT=WRVOLCNT+1;            /* INCREMENT COUNT               */
         LA    WRVOLCNT,1(,WRVOLCNT)                               0311
*   LABLKCNT=0;                     /* CLEAR LABEL BLOCKCOUNT        */
         SLR   LABLKCNT,LABLKCNT                                   0312
*   CALL DT2UNLD;                   /* REWIND AND UNLOAD             */
         BAL   @14,DT2UNLD                                         0313
*   DO;                             /* ?IGFDMSG MSG(IGF511A)CODE(TO-C
*                                      UA,VOL-SER,LABEL-TYPE,VOL-SEQ)
*                                      RETRY(2)                      */
*                                                                  0314
*     /***************************************************************/
*     /*                                                             */
*     /* IGFDMSG - INVOKE THE DDR/MIH MESSAGE WRITER                 */
*     /*                                                             */
*     /***************************************************************/
*                                                                  0315
*     DDRMSGCD=DDRM511A;            /* SET UP MSG CODE               */
         MVI   DDRMSGCD(DDRPTR),X'08'                              0315
*     DDRMSGPN=4;                   /* SET UP NO. OF SUBST. CODES    */
         MVI   DDRMSGPN(DDRPTR),X'04'                              0316
*     DDRMSGPC(1)=DDRPTO;           /* SET SUBSTITUTION CODE 1       */
         MVI   DDRMSGPC(DDRPTR),X'03'                              0317
*     DDRMSGPC(2)=DDRPVL;           /* SET SUBSTITUTION CODE 2       */
         MVI   DDRMSGPC+1(DDRPTR),X'04'                            0318
*     DDRMSGPC(3)=DDRPLT;           /* SET SUBSTITUTION CODE 3       */
         MVI   DDRMSGPC+2(DDRPTR),X'05'                            0319
*     DDRMSGPC(4)=DDRPSN;           /* SET SUBSTITUTION CODE 4       */
         MVI   DDRMSGPC+3(DDRPTR),X'06'                            0320
*     RTNCODE=12;                   /* INDICATE MESSAGE NOT DONE YET */
         LA    RTNCODE,12                                          0321
*     DO DDRRETRY=1 TO 2 WHILE(RTNCODE=12);/* LOOP UNTIL MSG DONE    */
         LA    @14,1                                               0322
         STC   @14,DDRRETRY(,DDRPTR)                               0322
@DL00322 C     RTNCODE,@CF00621                                    0322
         BNE   @DC00322                                            0322
*       CALL IGFDM0;                /* OUTPUT MESSAGE                */
         L     @15,@CV00609                                        0323
         BALR  @14,@15                                             0323
*     END;                          /* END OF RETRY LOOP             */
         LA    @14,1                                               0324
         SLR   @12,@12                                             0324
         IC    @12,DDRRETRY(,DDRPTR)                               0324
         ALR   @14,@12                                             0324
         STC   @14,DDRRETRY(,DDRPTR)                               0324
         C     @14,@CF00080                                        0324
         BNH   @DL00322                                            0324
@DC00322 DS    0H                                                  0325
*   END;                            /* ?IGFDMSG MSG(IGF511A)CODE(TO-C
*                                      UA,VOL-SER,LABEL-TYPE,VOL-SEQ)
*                                      RETRY(2) WRONG VOLUME MESSAGE */
*   DDRTER1=0;                      /* IGNORE ALL ERRORS             */
         MVI   DDRTER1(DDRPTR),X'00'                               0326
*   IF WRVOLCNT<5 THEN              /* WRONG VOLUME LOOP ?           */
         C     WRVOLCNT,@CF00417                                   0327
         BNL   @RF00327                                            0327
*     MOUNTSWH='1'B;                /* NO - MOUNT SEQUENCE IS TO BE
*                                      RE-ISSUED                     */
         OI    MOUNTSWH,B'10000000'                                0328
*   ELSE                            /* YES - THE VOL VERIFICATION  0329
*                                      PROCESS IS IN A LOOP          */
*     DO;                                                          0329
         B     @RC00327                                            0329
@RF00327 DS    0H                                                  0330
*       VERIFSWH='0'B;              /* TERMINATE LABEL PROCESSING    */
         NI    VERIFSWH,B'10111111'                                0330
*       DERLRC=8;                   /* SET LOCAL RETURN CODE TO CAUSE
*                                      IGFDT0 TO RECYCLE THE SWAP    */
         MVI   DERLRC,X'08'                                        0331
*     END;                                                         0332
*   RETURN;                         /* RETURN TO CALLER              */
@EL00008 DS    0H                                                  0333
@EF00008 DS    0H                                                  0333
@ER00008 LM    @14,@05,@SA00008                                    0333
         LM    @08,@12,@SA00008+32                                 0333
         BR    @14                                                 0333
*   END DT2WRONG;                                                  0334
         B     @EL00008                                            0334
*                                                                  0335
*   /*****************************************************************/
*   /*                                                               */
*   /* REWIND AND UNLOAD SUBROUTINE                                  */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0335
*DT2UNLD:                                                          0335
*   PROC;                           /* THIS SUBROUTINE IS CALLED WHEN
*                                      THE TAPE IS TO BE REWOUND AND
*                                      UNLOADED FOR AN ERROR, WRONG
*                                      VOLUME, OR UNEXPECTED       0335
*                                      TERMINATION .                 */
DT2UNLD  STM   @14,@05,@SA00009                                    0335
         STM   @07,@12,@SA00009+32                                 0335
*   LABLKCNT=0;                     /* ZERO LABEL BLOCKCOUNT         */
         SLR   LABLKCNT,LABLKCNT                                   0336
*   DDRIOF1=DDRRUN;                 /* SET REWIND AND UNLOAD FLAG    */
         MVI   DDRIOF1(DDRPTR),X'0F'                               0337
*   DDRIOF2=0;                      /* CLEAR BYTE                    */
         MVI   DDRIOF2(DDRPTR),X'00'                               0338
*   DDRWHICH='1'B;                  /* I/O TO BE PERFORMED           */
*   DDRITAKE='1'B;                  /* SET CONTROL INDICATOR         */
         OI    DDRWHICH(DDRPTR),B'11000000'                        0340
*   CALL IGFDM1;                    /* REWIND AND UNLOAD             */
         L     @15,@CV00608                                        0341
         BALR  @14,@15                                             0341
*   DDRTER1=0;                      /* IGNORE ERRORS                 */
         MVI   DDRTER1(DDRPTR),X'00'                               0342
*   RETURN;                         /* RETURN TO CALLER              */
@EL00009 DS    0H                                                  0343
@EF00009 DS    0H                                                  0343
@ER00009 LM    @14,@05,@SA00009                                    0343
         LM    @07,@12,@SA00009+32                                 0343
         BR    @14                                                 0343
*   END DT2UNLD;                                                   0344
*                                                                  0345
*   /*****************************************************************/
*   /*                                                               */
*   /* NSL CODE 0 POSITIONING SUBROUTINE                             */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0345
*DT2NSL0:                                                          0345
*   PROC;                           /* THIS SUBROUTINE IS ENTERED  0345
*                                      WHEN THE USER HAS A LABEL IN
*                                      THE FORMAT -                0345
*                                      L1×L2×...×LN×TM×D1×D2×...×DM×
*                                      WITH A RETURN CODE=0 FROM   0345
*                                      NSLREPOS, DDR IS TO ISSUE A 0345
*                                      SKIP FILE COMMAND PRIOR TO  0345
*                                      POSITIONING THE TAPE.         */
DT2NSL0  STM   @14,@03,12(@13)                                     0345
         ST    @05,40(,@13)                                        0345
         STM   @07,@12,48(@13)                                     0345
*   VERIFSWH='0'B;                  /* CLEAR LABEL VERIFICATION      */
         NI    VERIFSWH,B'10111111'                                0346
*   LABLKCNT='0'B;                  /* CLEAR LABEL BLOCKCOUNT        */
         SLR   LABLKCNT,LABLKCNT                                   0347
*   FILECNT=FILECNT+1;              /* INCREMENT COUNT               */
         AL    FILECNT,@CF00051                                    0348
*   RETURN;                         /* RETURN TO CALLER              */
@EL00010 DS    0H                                                  0349
@EF00010 DS    0H                                                  0349
@ER00010 LM    @14,@03,12(@13)                                     0349
         L     @05,40(,@13)                                        0349
         LM    @07,@12,48(@13)                                     0349
         BR    @14                                                 0349
*   END DT2NSL0;                                                   0350
*                                                                  0351
*   /*****************************************************************/
*   /*                                                               */
*   /* NSL CODE 4 POSITIONING SUBROUTINE                             */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0351
*DT2NSL4:                                                          0351
*   PROC;                           /* THIS SUBROUTINE IS ENTERED  0351
*                                      WHEN A FURTHER LABEL IS NEEDED
*                                      BY NSLREPOS IN THE FORMAT - 0351
*                                      L1×L2×L3×...×LN× THIS MEANS 0351
*                                      THAT THE LOGICAL LABEL IS   0351
*                                      SPREAD OVER MORE THAN THE   0351
*                                      PHYSICAL LABEL                */
DT2NSL4  STM   @14,@05,@SA00011                                    0351
         STM   @07,@12,@SA00011+32                                 0351
*   LABLKCNT=LABLKCNT+1;            /* INCREMENT COUNT               */
         AL    LABLKCNT,@CF00051                                   0352
*   DDRIOF1=DDRREAD;                /* SET READ FLAG                 */
         MVI   DDRIOF1(DDRPTR),X'02'                               0353
*   DDRIOF2=0;                      /* CLEAR BYTE                    */
         MVI   DDRIOF2(DDRPTR),X'00'                               0354
*   DDRITAKE='1'B;                  /* SET CONTROL INDICATOR         */
*   DDRILAB='1'B;                   /* SET LABEL PROCESSING FLAG     */
         OI    DDRITAKE(DDRPTR),B'01100000'                        0356
*   DDRIBUFL=LENGTH(IOBUFFER);      /* BUFFER LENGTH                 */
         MVC   DDRIBUFL(2,DDRPTR),@CH00599                         0357
*   IOBUFFER=IOBUFFER&&IOBUFFER;    /* ZERO BUFFER                   */
         L     @14,DDRIBUF(,DDRPTR)                                0358
         XC    IOBUFFER(80,@14),IOBUFFER(@14)                      0358
*   CALL IGFDM1;                    /* READ ANOTHER LABEL            */
         L     @15,@CV00608                                        0359
         BALR  @14,@15                                             0359
*   IF RTNCODE^=0 THEN              /* IS RETURN CODE ZERO ?         */
         LTR   RTNCODE,RTNCODE                                     0360
         BZ    @RF00360                                            0360
*     CALL DT2IOERR;                /* NO - I/O ERROR                */
         BAL   @14,DT2IOERR                                        0361
*   ELSE                                                           0362
*     ;                             /* YES - RETURN CODE IS ZERO     */
@RF00360 DS    0H                                                  0363
*   RETURN;                         /* RETURN TO CALLER              */
@EL00011 DS    0H                                                  0363
@EF00011 DS    0H                                                  0363
@ER00011 LM    @14,@05,@SA00011                                    0363
         LM    @07,@12,@SA00011+32                                 0363
         BR    @14                                                 0363
*   END DT2NSL4;                                                   0364
*                                                                  0365
*   /*****************************************************************/
*   /*                                                               */
*   /* NSL CODE 12 POSITIONING SUBROUTINE                            */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0365
*DT2NSL12:                                                         0365
*   PROC;                           /* THIS SUBROUTINE IS ENTERED  0365
*                                      WHEN LABEL POSITIONING IS   0365
*                                      COMPLETE WITH THE FOLLOWING 0365
*                                      FORMAT -                    0365
*                                      L1×L2×L3×...×LN×D1×D2×...×DM×
*                                      NO TAPEMARK BETWEEN LABELS AND
*                                      DATA RECORDS AND THE        0365
*                                      BLOCKCOUNT FOR THE DATA     0365
*                                      RECORDS INCLUDES THE LABEL  0365
*                                      COUNT.                        */
DT2NSL12 STM   @14,@05,12(@13)                                     0365
         STM   @07,@12,48(@13)                                     0365
*   LABLKCNT=0;                     /* ZERO LABEL COUNT      @YM07700*/
         SLR   LABLKCNT,LABLKCNT                                   0366
*   VERIFSWH='0'B;                  /* GOOD LABEL-VERIFY COMPLETE    */
         NI    VERIFSWH,B'10111111'                                0367
*   RETURN;                         /* RETURN TO CALLER              */
@EL00012 DS    0H                                                  0368
@EF00012 DS    0H                                                  0368
@ER00012 LM    @14,@05,12(@13)                                     0368
         LM    @07,@12,48(@13)                                     0368
         BR    @14                                                 0368
*   END DT2NSL12;                                                  0369
*                                                                  0370
*   /*****************************************************************/
*   /*                                                               */
*   /* NSL CODE 16 POSITIONING SUBROUTINE                            */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0370
*DT2NSL16:                                                         0370
*   PROC;                           /* THIS SUBROUTINE IS ENTERED  0370
*                                      WHEN LABEL VERIFICATION IS  0370
*                                      COMPLETE AND THE TAPE HAS ONE
*                                      OF THE FOLLOWING THREE FORMATS
*                                      -                           0370
*                                      L1×L2×L3×...×LN×D1×D2×...×DM×
*                                      (BLOCKCOUNT DOES NOT INCLUDE
*                                      LABEL COUNT), L1×L2×L3×...×LN×
*                                      TM×D1×D2×...×DM×, OR        0370
*                                      TM×D1×D2×...×DM×              */
DT2NSL16 STM   @14,@05,12(@13)                                     0370
         STM   @07,@12,48(@13)                                     0370
*   LABLKCNT=0;                     /* ZERO LABEL BLOCKCOUNT         */
         SLR   LABLKCNT,LABLKCNT                                   0371
*   VERIFSWH='0'B;                  /* VERIFY COMPLETE               */
         NI    VERIFSWH,B'10111111'                                0372
*   RETURN;                         /* RETURN TO CALLER              */
@EL00013 DS    0H                                                  0373
@EF00013 DS    0H                                                  0373
@ER00013 LM    @14,@05,12(@13)                                     0373
         LM    @07,@12,48(@13)                                     0373
         BR    @14                                                 0373
*   END DT2NSL16;                                                  0374
*                                                                  0375
*   /*****************************************************************/
*   /*                                                               */
*   /* NSL CODE 20 POSITIONING SUBROUTINE                            */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0375
*DT2NSL20:                                                         0375
*   PROC;                           /* THIS SUBROUTINE IS ENTERED  0375
*                                      WHEN THE NSLREPOS ROUTINE   0375
*                                      ELECTS TO CANCEL THE SWAP     */
DT2NSL20 STM   @14,@05,@SA00014                                    0375
         STM   @07,@12,@SA00014+32                                 0375
*   CALL DT2UNLD;                   /* REWIND AND UNLOAD             */
         BAL   @14,DT2UNLD                                         0376
*   DDRTER1=DDRTCU;                 /* CANCELLED BY USER             */
         MVI   DDRTER1(DDRPTR),X'09'                               0377
*   DERLRC=12;                      /* ABORT SWAP                    */
         MVI   DERLRC,X'0C'                                        0378
*   VERIFSWH='0'B;                  /* TERMINATE DT2NSL              */
         NI    VERIFSWH,B'10111111'                                0379
*   RETURN;                         /* RETURN TO CALLER              */
@EL00014 DS    0H                                                  0380
@EF00014 DS    0H                                                  0380
@ER00014 LM    @14,@05,@SA00014                                    0380
         LM    @07,@12,@SA00014+32                                 0380
         BR    @14                                                 0380
*   END DT2NSL20;                                                  0381
*                                                                  0382
*   /*****************************************************************/
*   /*                                                               */
*   /* ESOTERIC ESTAE SUBROUTINE                                     */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0382
*IGFDT2S:                                                          0382
*   PROC;                           /* THIS SUBROUTINE IS ENTERED  0382
*                                      FROM IGFDE0 DURING ESTAE    0382
*                                      PROCESSING                    */
IGFDT2S  STM   @14,@12,12(@13)                                     0382
*   IF DDRPTR^=0 THEN               /* IS DDRCOM BASE REG ZERO ?     */
         LTR   DDRPTR,DDRPTR                                       0383
         BZ    @RF00383                                            0383
*     DO;                           /* NO - DDRCOM BASE REG IS     0384
*                                      NON-ZERO                      */
*       IF SVC85SWH='1'B THEN       /* IS SVC 85 IN PROCESS ?        */
         TM    SVC85SWH,B'00100000'                                0385
         BNO   @RF00385                                            0385
*         DDRTER1=DDRTIU;           /* YES - INVALID USER EXIT       */
         MVI   DDRTER1(DDRPTR),X'06'                               0386
*       ELSE                                                       0387
*         ;                         /* NO                            */
@RF00385 DS    0H                                                  0388
*     END;                                                         0388
*   ELSE                                                           0389
*     ;                             /* YES -DDRCOM BASE REG IS ZERO  */
@RF00383 DS    0H                                                  0390
*   RETURN;                         /* RETURN TO CALLER              */
@EL00015 DS    0H                                                  0390
@EF00015 DS    0H                                                  0390
@ER00015 LM    @14,@12,12(@13)                                     0390
         BR    @14                                                 0390
*   END IGFDT2S;                                                   0391
*   END IGFDT2                                                     0392
*                                                                  0392
*/* THE FOLLOWING INCLUDE STATEMENTS WERE FOUND IN THIS PROGRAM.     */
*/*%INCLUDE SYSLIB  (IEFUCBOB)                                       */
*/*%INCLUDE SYSLIB  (IHADDR  )                                       */
*                                                                  0392
*       ;                                                          0392
@DATA    DS    0H
@CH00132 DC    H'3'
@CH00599 DC    H'80'
@DATD    DSECT
         DS    0F
@SA00001 DS    18F
@SA00011 DS    14F
@SA00008 DS    13F
@SA00014 DS    14F
@SA00002 DS    15F
@SA00003 DS    15F
@SA00004 DS    15F
@SA00007 DS    12F
@SA00006 DS    15F
@SA00005 DS    14F
@SA00009 DS    0F
         DS    14F
@AL00001 DS    1A
IGFDT2   CSECT
         DS    0F
@CF00051 DC    F'1'
@CF00080 DC    F'2'
@CF00134 DC    F'4'
@CF00417 DC    F'5'
@CF00621 DC    F'12'
@CH00621 EQU   @CF00621+2
@CF00694 DC    F'20'
@DATD    DSECT
         DS    0D
XLATEADD DS    A
SWITCHES DS    BL1
         ORG   SWITCHES
MOUNTSWH DS    BL1
VERIFSWH EQU   SWITCHES+0
SVC85SWH EQU   SWITCHES+0
@NM00013 EQU   SWITCHES+0
         ORG   SWITCHES+1
         DS    CL3
DERPLIST DS    CL48
         ORG   DERPLIST
DERFUNK  DS    AL1
DERSWCHS DS    BL1
         ORG   DERSWCHS
DERCRASH DS    BL1
DERPERK  EQU   DERSWCHS+0
DERECALL EQU   DERSWCHS+0
DERESTAE EQU   DERSWCHS+0
@NM00015 EQU   DERSWCHS+0
         ORG   DERPLIST+2
@NM00016 DS    CL2
DERREC   DS    AL4
DERSPEC  DS    AL4
DERRETRY DS    AL4
DERDATD  DS    CL4
         ORG   DERDATD
DERDASPN DS    FL1
DERDALNG DS    FL3
         ORG   DERPLIST+20
DERRSRC  DS    BL1
         ORG   DERRSRC
DERTAPE  DS    BL1
DERUREC  EQU   DERRSRC+0
DERDISK  EQU   DERRSRC+0
@NM00017 EQU   DERRSRC+0
         ORG   DERPLIST+21
DERLRC   DS    AL1
DERRUB   DS    CL18
         ORG   DERRUB
DERPFX   DS    BL2
DERRCODE DS    AL4
DERRDATA DS    AL4
DERRDDR  DS    AL4
DERRSAVE DS    AL4
         ORG   DERPLIST+40
DERGMSPL DS    CL4
         ORG   DERGMSPL
DERGMSPN DS    FL1
DERGMLNG DS    FL3
         ORG   DERPLIST+44
DERGMADR DS    AL4
         ORG   DERPLIST+48
         ORG   *+1-(*-@DATD)/(*-@DATD) INSURE DSECT DATA
@ENDDATD EQU   *
IGFDT2   CSECT
         DS    0F
@SIZDATD DC    AL1(245)
         DC    AL3(@ENDDATD-@DATD)
@CV00605 DC    V(IGFDE0)
@CV00607 DC    V(IGFDT1)
@CV00608 DC    V(IGFDM1)
@CV00609 DC    V(IGFDM0)
         DS    0D
@CC00688 DC    C'VOL1'
@CB00624 DC    X'000000000000'
@CB00670 DC    B'0000000011100100'
DERRECPM DS    CL24
         ORG   DERRECPM
@NM00018 DC    CL8'IGFDI0'
@NM00019 DC    CL8'IGFDT2'
@NM00020 DC    CL8'77109'
         ORG   DERRECPM+24
DT2SUBS  DC    AL4(DT2NSL0)
         DC    AL4(DT2NSL4)
         DC    AL4(DT2WRONG)
         DC    AL4(DT2NSL12)
         DC    AL4(DT2NSL16)
         DC    AL4(DT2NSL20)
IGFDT2P  DC    13F'0'
@00      EQU   00                      EQUATES FOR REGISTERS 0-15
@01      EQU   01
@02      EQU   02
@03      EQU   03
@04      EQU   04
@05      EQU   05
@06      EQU   06
@07      EQU   07
@08      EQU   08
@09      EQU   09
@10      EQU   10
@11      EQU   11
@12      EQU   12
@13      EQU   13
@14      EQU   14
@15      EQU   15
SUBPTR   EQU   @11
WRVOLCNT EQU   @07
FILECNT  EQU   @04
LABLKCNT EQU   @06
BLOCKCNT EQU   @05
CODEBASE EQU   @08
DATABASE EQU   @09
DDRPTR   EQU   @10
R1       EQU   @01
SAVEPTR  EQU   @13
RTNCODE  EQU   @15
UCB      EQU   0
UCBOB    EQU   0
UCBJBNR  EQU   UCBOB
UCBFL5   EQU   UCBOB+1
UCBAF    EQU   UCBFL5
UCBSTAT  EQU   UCBOB+3
UCBCHAN  EQU   UCBOB+4
UCBSFLS  EQU   UCBOB+6
UCBFLA   EQU   UCBSFLS
UCBFL1   EQU   UCBFLA
UCBBSY   EQU   UCBFL1
UCBNRY   EQU   UCBFL1
UCBPST   EQU   UCBFL1
UCBCUB   EQU   UCBFL1
UCBFLB   EQU   UCBSFLS+1
UCBCHM   EQU   UCBOB+8
UCBCHM1  EQU   UCBCHM
UCBPTH0  EQU   UCBCHM1
UCBPTH1  EQU   UCBCHM1
UCBWGT   EQU   UCBOB+12
UCBTYP   EQU   UCBOB+16
UCBTBYT1 EQU   UCBTYP
UCB1FEA5 EQU   UCBTBYT1
UCB1FEA6 EQU   UCBTBYT1
UCBTBYT2 EQU   UCBTYP+1
UCB2OPT2 EQU   UCBTBYT2
UCBDUDN1 EQU   UCB2OPT2
UCB2OPT3 EQU   UCBTBYT2
UCBDUDN2 EQU   UCB2OPT3
UCB2OPT4 EQU   UCBTBYT2
UCBRWTAU EQU   UCB2OPT4
UCB2OPT6 EQU   UCBTBYT2
UCB2OPT7 EQU   UCBTBYT2
UCBTBYT3 EQU   UCBTYP+2
UCBDVCLS EQU   UCBTBYT3
UCBTBYT4 EQU   UCBTYP+3
UCBEXTPT EQU   UCBOB+20
UCBFLC   EQU   UCBEXTPT
UCBDEV   EQU   UCBOB+24
UCBCMEXT EQU   0
UCBATI   EQU   UCBCMEXT+3
@NM00004 EQU   UCBATI
UCBFLP1  EQU   UCBCMEXT+5
UCBMT    EQU   0
UCBOCR   EQU   0
UCB3540X EQU   0
UCBDKBYT EQU   UCB3540X+6
UCBUCS   EQU   0
UCBUCSOP EQU   UCBUCS+4
UCBFCBOP EQU   UCBUCS+5
DDRCOM   EQU   0
DDRSHORT EQU   DDRCOM
DDRCNTRL EQU   DDRSHORT+8
DDRSRC   EQU   DDRCNTRL
DDRSTAT  EQU   DDRCNTRL+1
DDRDCHAR EQU   DDRCNTRL+2
DDRDSTAT EQU   DDRDCHAR+1
DDRLONG  EQU   DDRCOM+24
DDRTOUCB EQU   DDRLONG
DDRROWN  EQU   DDRLONG+8
DDRMIHT  EQU   DDRLONG+12
DDRTER   EQU   DDRLONG+36
DDRTER1  EQU   DDRTER
DDRINV   EQU   DDRLONG+38
DDRINV2  EQU   DDRINV+1
DDRAPP   EQU   DDRLONG+40
DDRIBUFL EQU   DDRLONG+42
DDRIBUF  EQU   DDRLONG+44
DDRCOUNT EQU   DDRLONG+48
DDRIOF   EQU   DDRLONG+52
DDRIOF1  EQU   DDRIOF
DDRIOF2  EQU   DDRIOF+1
DDRWHICH EQU   DDRIOF2
DDRITAKE EQU   DDRIOF2
DDRILAB  EQU   DDRIOF2
DDRIMNT  EQU   DDRIOF2
DDRICNT  EQU   DDRIOF2
DDRMSG   EQU   DDRLONG+54
DDRMSGCD EQU   DDRMSG+1
DDRMSGP  EQU   DDRLONG+56
DDRMSGPN EQU   DDRMSGP
DDRMSGPC EQU   DDRMSGP+1
DDRLABEL EQU   DDRLONG+64
DDRLAL   EQU   DDRLABEL
DDRLNL   EQU   DDRLABEL
DDRLNSL  EQU   DDRLABEL
DDRLSD   EQU   DDRLABEL
DDRLNOP  EQU   DDRLABEL
DDRRETRY EQU   DDRLONG+65
DDRREC   EQU   DDRLONG+66
DDRREC2  EQU   DDRREC+1
DDRUSER  EQU   DDRLONG+68
DDRUBCNT EQU   DDRLONG+72
IOBUFFER EQU   0
VOLLABIN EQU   IOBUFFER
VOLSERNO EQU   IOBUFFER+4
DT2SUB   EQU   0
UCBBGN   EQU   0
UCBPTR   EQU   DDRTOUCB
UCBOBS01 EQU   UCBDEV
UCBVOLI  EQU   UCBOBS01+4
UCBSTAB  EQU   UCBOBS01+10
UCBBSVL  EQU   UCBSTAB
UCBPRSRS EQU   UCBSTAB
UCBDMCT  EQU   UCBOBS01+11
UCBFL4   EQU   UCBOBS01+13
UCBOBS02 EQU   UCBDEV
UCBFSCT  EQU   UCBOBS02
UCBTFL1  EQU   UCBOBS02+19
UCBXTN   EQU   UCBOBS02+20
UCBVOPT  EQU   UCBXTN
UCBOBS03 EQU   UCBDEV
UCBXTADR EQU   UCBOBS03
UCBOBS04 EQU   UCBDEV
UCBBTA   EQU   UCBOBS04+12
UCBOBS06 EQU   UCBDEV
UCBAOF   EQU   UCBOBS06
UCBAOF1  EQU   UCBAOF
UCBAOF2  EQU   UCBAOF+1
@NM00003 EQU   UCBOBS06+3
UCBIRB   EQU   UCBOBS06+4
UCBGRAF  EQU   UCBIRB
UCBLDNCA EQU   UCBOBS06+8
UCBRDYQ  EQU   UCBLDNCA
UCBIRLN  EQU   UCBRDYQ
UCBLDNCB EQU   UCBRDYQ+1
UCBCTLNK EQU   UCBOBS06+12
UCBOBS07 EQU   UCBDEV
UCBOBS08 EQU   UCBDEV
UCBOBS09 EQU   UCBDEV
         AGO   .@UNREFD                START UNREFERENCED COMPONENTS
UCBRV066 EQU   UCBOBS09+4
UCBIOSBA EQU   UCBOBS09
UCBRV042 EQU   UCBOBS08+5
UCBCTCF1 EQU   UCBOBS08+4
UCBCTCAD EQU   UCBOBS08
UCBICNCB EQU   UCBOBS07+4
UCBRV040 EQU   UCBOBS07
UCBCTLNA EQU   UCBCTLNK+1
UCBRLN   EQU   UCBCTLNK
UCBRDYQA EQU   UCBLDNCB
UCBINRLN EQU   UCBIRLN
UCBIRBA  EQU   UCBIRB+1
UCBRV039 EQU   UCBGRAF
UCBDWNR  EQU   UCBGRAF
UCBRPND  EQU   UCBGRAF
UCBUPM   EQU   UCBGRAF
UCBBTAM  EQU   UCBGRAF
UCBDRNO  EQU   UCBGRAF
UCBDRO   EQU   UCBGRAF
UCBOIP   EQU   UCBGRAF
UCBATRCD EQU   @NM00003
UCBSKPFG EQU   @NM00003
UCBRIPND EQU   @NM00003
UCBRTIAC EQU   @NM00003
UCBRSV79 EQU   @NM00003
UCBRSV78 EQU   @NM00003
UCBRSV77 EQU   @NM00003
UCBOLTEP EQU   @NM00003
UCBATNCT EQU   UCBOBS06+2
UCBRSV76 EQU   UCBAOF2
UCBRSV75 EQU   UCBAOF2
UCBRSV74 EQU   UCBAOF2
UCBRSV73 EQU   UCBAOF2
UCBRSV72 EQU   UCBAOF2
UCBRSV71 EQU   UCBAOF2
UCBRSV70 EQU   UCBAOF2
UCBRSV69 EQU   UCBAOF2
UCBRSV68 EQU   UCBAOF1
UCBRSV67 EQU   UCBAOF1
UCBRSV66 EQU   UCBAOF1
UCBRSV65 EQU   UCBAOF1
UCBRSV64 EQU   UCBAOF1
UCBOFNL  EQU   UCBAOF1
UCBOFSP  EQU   UCBAOF1
UCBOFMCR EQU   UCBAOF1
UCBBTB   EQU   UCBBTA+1
UCBDI    EQU   UCBBTA
UCBSNS   EQU   UCBOBS04+8
UCBTEB   EQU   UCBOBS04+4
UCBGCB   EQU   UCBOBS04+3
UCBOPEN  EQU   UCBOBS04+2
UCBSTART EQU   UCBOBS04
UCBXTNB  EQU   UCBXTN+1
UCBRSV22 EQU   UCBVOPT
UCBRSV21 EQU   UCBVOPT
UCBRSV20 EQU   UCBVOPT
UCBESVE  EQU   UCBVOPT
UCBERPC  EQU   UCBVOPT
UCBESVC  EQU   UCBVOPT
UCBEVA   EQU   UCBVOPT
UCBESV   EQU   UCBVOPT
UCBRV009 EQU   UCBTFL1
UCBRV008 EQU   UCBTFL1
UCBRV007 EQU   UCBTFL1
UCBRV006 EQU   UCBTFL1
UCBRV005 EQU   UCBTFL1
UCBRV038 EQU   UCBTFL1
UCBNSLTP EQU   UCBTFL1
UCBNLTP  EQU   UCBTFL1
UCBRES1B EQU   UCBOBS02+18
UCBFSER  EQU   UCBOBS02+12
@NM00002 EQU   UCBOBS02+4
UCBFSEQ  EQU   UCBOBS02+2
UCBNEXP  EQU   UCBOBS01+20
UCBBASE  EQU   UCBOBS01+16
UCBRES1A EQU   UCBOBS01+15
UCBUSER  EQU   UCBOBS01+14
UCBFL47  EQU   UCBFL4
UCBFL46  EQU   UCBFL4
UCBFL45  EQU   UCBFL4
UCBRV065 EQU   UCBFL4
UCBDSS   EQU   UCBFL4
UCBRV028 EQU   UCBFL4
UCBWDAV  EQU   UCBFL4
UCBDAVV  EQU   UCBFL4
UCBSQC   EQU   UCBOBS01+12
UCBDATP  EQU   UCBOBS01+12
UCBDMC   EQU   UCBDMCT
UCBMOUNT EQU   UCBDMCT
UCBBNUL  EQU   UCBSTAB
UCBSHAR  EQU   UCBSTAB
UCBBSTR  EQU   UCBSTAB
UCBBPUB  EQU   UCBSTAB
UCBBPRV  EQU   UCBSTAB
UCBBALB  EQU   UCBPRSRS
UCBPGFL  EQU   UCBSTAB
UCBDVSHR EQU   UCBBSVL
UCBVTOC  EQU   UCBOBS01
@NM00014 EQU   IOBUFFER+10
DDRSSOB  EQU   DDRLONG+76
@NM00012 EQU   DDRUSER+1
DDRUMODE EQU   DDRUSER
@NM00011 EQU   DDRREC2
DDRRFMTO EQU   DDRREC2
DDRREC1  EQU   DDRREC
@NM00010 EQU   DDRLABEL
DDRLBLP  EQU   DDRLABEL
DDRMSGOP EQU   DDRMSG
@NM00009 EQU   DDRIOF2
DDRAPP2  EQU   DDRAPP+1
DDRAPP1  EQU   DDRAPP
DDRINV1  EQU   DDRINV
DDRTER2  EQU   DDRTER+1
DDRTEST  EQU   DDRLONG+32
DDRUASCB EQU   DDRLONG+28
DDRUTCB  EQU   DDRLONG+24
DDRUIOB  EQU   DDRLONG+20
DDRUDEB  EQU   DDRMIHT+4
DDRUDCB  EQU   DDRMIHT
DDRASID  EQU   DDRLONG+10
DDRMIH   EQU   DDRLONG+9
DDRFIRST EQU   DDRROWN
DDRJES3L EQU   DDRROWN
@NM00008 EQU   DDRROWN
DDRRDENQ EQU   DDRROWN
DDRRUENQ EQU   DDRROWN
DDRRTENQ EQU   DDRROWN
DDRFMUCB EQU   DDRLONG+4
DDRTOCUA EQU   DDRSHORT+21
DDRFMCUA EQU   DDRSHORT+18
DDRUASID EQU   DDRSHORT+16
DDRUIOSB EQU   DDRSHORT+12
@NM00007 EQU   DDRDSTAT
DDRUR    EQU   DDRDSTAT
DDRMT    EQU   DDRDSTAT
DDRDA    EQU   DDRDSTAT
DDRBUFL  EQU   DDRDSTAT
DDRMDR   EQU   DDRDCHAR
@NM00006 EQU   DDRSTAT
DDRSIRB  EQU   DDRSTAT
DDRPRG   EQU   DDRSTAT
DDRRMV   EQU   DDRSTAT
DDRHAMA  EQU   DDRSTAT
DDRQUE   EQU   DDRSTAT
DDRACTV  EQU   DDRSTAT
@NM00005 EQU   DDRSRC
DDRPAGE  EQU   DDRSRC
DDRSYS   EQU   DDRSRC
DDROPER  EQU   DDRSRC
DDRNXT   EQU   DDRSHORT+4
DDRID    EQU   DDRSHORT
UCBERADR EQU   UCBUCS+12
UCBFCBID EQU   UCBUCS+8
UCBERCNT EQU   UCBUCS+7
UCBRSV51 EQU   UCBUCS+6
UCBRSV50 EQU   UCBFCBOP
UCBRSV49 EQU   UCBFCBOP
UCBRSV48 EQU   UCBFCBOP
UCBRSV47 EQU   UCBFCBOP
UCBRSV46 EQU   UCBFCBOP
UCBRSV45 EQU   UCBFCBOP
UCBRSV44 EQU   UCBFCBOP
UCBFCBO1 EQU   UCBFCBOP
UCBUCSPE EQU   UCBUCSOP
UCBRSV43 EQU   UCBUCSOP
UCBRSV42 EQU   UCBUCSOP
UCBRSV41 EQU   UCBUCSOP
UCBRSV40 EQU   UCBUCSOP
UCBRSV39 EQU   UCBUCSOP
UCBUCSO2 EQU   UCBUCSOP
UCBUCSO1 EQU   UCBUCSOP
UCBUCSID EQU   UCBUCS
UCBRV073 EQU   UCB3540X+7
UCBRV072 EQU   UCBDKBYT
UCBRV071 EQU   UCBDKBYT
UCBRV070 EQU   UCBDKBYT
UCBRV069 EQU   UCBDKBYT
UCBRV068 EQU   UCBDKBYT
UCBRV067 EQU   UCBDKBYT
UCBVLVER EQU   UCBDKBYT
UCBDKAMX EQU   UCBDKBYT
UCBVLSER EQU   UCB3540X
UCBRDATA EQU   UCBOCR+4
UCBFRID  EQU   UCBOCR
UCBCLN   EQU   UCBMT+14
UCBERG   EQU   UCBMT+12
UCBMS    EQU   UCBMT+11
UCBNB    EQU   UCBMT+10
UCBPW    EQU   UCBMT+9
UCBPR    EQU   UCBMT+8
UCBSIO   EQU   UCBMT+6
UCBTW    EQU   UCBMT+5
UCBTR    EQU   UCBMT+4
UCBTWT   EQU   UCBMT+3
UCBTRT   EQU   UCBMT+2
UCBCTD   EQU   UCBMT
UCBWTOID EQU   UCBCMEXT+17
UCBRV043 EQU   UCBCMEXT+16
UCBASID  EQU   UCBCMEXT+14
UCBMFCNT EQU   UCBCMEXT+12
UCBPMSK  EQU   UCBCMEXT+10
UCBCCWOF EQU   UCBCMEXT+8
UCBRV041 EQU   UCBCMEXT+6
UCBRV036 EQU   UCBFLP1
UCBRV035 EQU   UCBFLP1
UCBRV034 EQU   UCBFLP1
UCBRV033 EQU   UCBFLP1
UCBRV032 EQU   UCBFLP1
UCBRV031 EQU   UCBFLP1
UCBSHRUP EQU   UCBFLP1
UCBNSRCH EQU   UCBFLP1
UCBSNSCT EQU   UCBCMEXT+4
UCBHPDV  EQU   @NM00004
UCBHALI  EQU   @NM00004
UCBRSV09 EQU   @NM00004
UCBRSV08 EQU   @NM00004
UCBRSV07 EQU   @NM00004
UCBRSV06 EQU   @NM00004
UCBRSV05 EQU   @NM00004
UCBRSV04 EQU   @NM00004
UCBDTI   EQU   UCBCMEXT+2
UCBSTI   EQU   UCBCMEXT+1
UCBETI   EQU   UCBCMEXT
UCBEXTP  EQU   UCBEXTPT+1
UCBDDRSW EQU   UCBFLC
UCBTICBT EQU   UCBFLC
UCBIVRR  EQU   UCBFLC
UCBIVRS  EQU   UCBFLC
UCBITF   EQU   UCBFLC
UCBUDE   EQU   UCBFLC
UCBWAA   EQU   UCBFLC
UCBATTP  EQU   UCBFLC
UCBUNTYP EQU   UCBTBYT4
UCBRSV11 EQU   UCBDVCLS
UCBRSV10 EQU   UCBDVCLS
UCB3CHAR EQU   UCBDVCLS
UCB3UREC EQU   UCBDVCLS
UCB3DISP EQU   UCBDVCLS
UCB3DACC EQU   UCBDVCLS
UCB3COMM EQU   UCBDVCLS
UCB3TAPE EQU   UCBDVCLS
UCBDVPWR EQU   UCB2OPT7
UCBVLPWR EQU   UCB2OPT6
UCB2OPT5 EQU   UCBTBYT2
UCBRVDEV EQU   UCBRWTAU
UCBRPS   EQU   UCBDUDN2
UCBRR    EQU   UCBDUDN1
UCB2OPT1 EQU   UCBTBYT2
UCB2OPT0 EQU   UCBTBYT2
UCB1FEA7 EQU   UCBTBYT1
UCBD6250 EQU   UCB1FEA6
UCBD1600 EQU   UCB1FEA5
UCB1FEA4 EQU   UCBTBYT1
UCB1FEA3 EQU   UCBTBYT1
UCB1FEA2 EQU   UCBTBYT1
UCB1FEA1 EQU   UCBTBYT1
UCB1FEA0 EQU   UCBTBYT1
UCBNAME  EQU   UCBOB+13
UCBRV029 EQU   UCBWGT
UCBVHRSN EQU   UCBWGT
UCBVORSN EQU   UCBWGT
UCBMTPXP EQU   UCBWGT
UCBREW   EQU   UCBWGT
UCBPUB   EQU   UCBWGT
UCBOUT   EQU   UCBWGT
UCBIN    EQU   UCBWGT
UCBCPU   EQU   UCBOB+11
UCBLCI   EQU   UCBOB+10
UCBCNT   EQU   UCBOB+9
UCBRV017 EQU   UCBCHM1
UCBRV016 EQU   UCBCHM1
UCBRV015 EQU   UCBCHM1
UCBRV014 EQU   UCBCHM1
UCBSPB   EQU   UCBPTH1
UCBPPB   EQU   UCBPTH1
UCBSPA   EQU   UCBPTH0
UCBPPA   EQU   UCBPTH0
UCBFLB7  EQU   UCBFLB
UCBVALPH EQU   UCBFLB
UCBCRHSN EQU   UCBFLB
UCBCRHRV EQU   UCBFLB
UCBRESVH EQU   UCBFLB
UCBSPST  EQU   UCBFLB
UCBASNS  EQU   UCBFLB
UCBIORST EQU   UCBFLB
UCBQISCE EQU   UCBFL1
UCBACTV  EQU   UCBFL1
UCBSAP   EQU   UCBFL1
UCBNOTRC EQU   UCBCUB
UCBPSNS  EQU   UCBFL1
UCBUSING EQU   UCBPST
UCBNOTRD EQU   UCBNRY
UCBBUSYD EQU   UCBBSY
UCBUA    EQU   UCBCHAN+1
UCBCHA   EQU   UCBCHAN
UCBDADI  EQU   UCBSTAT
UCBSYSR  EQU   UCBSTAT
UCBPRES  EQU   UCBSTAT
UCBALOC  EQU   UCBSTAT
UCBUNLD  EQU   UCBSTAT
UCBRESV  EQU   UCBSTAT
UCBCHGS  EQU   UCBSTAT
UCBONLI  EQU   UCBSTAT
UCBID    EQU   UCBOB+2
UCBALTPH EQU   UCBFL5
UCBALTCU EQU   UCBFL5
UCBNALOC EQU   UCBFL5
UCBENVRD EQU   UCBFL5
UCBVSDR  EQU   UCBFL5
UCBSASK  EQU   UCBFL5
UCBAMV   EQU   UCBAF
UCBDCC   EQU   UCBFL5
UCBMONT  EQU   UCBJBNR
UCBRV011 EQU   UCBJBNR
UCBRSV02 EQU   UCBJBNR
UCBOLDSM EQU   UCBJBNR
UCBRV003 EQU   UCBJBNR
UCBRV002 EQU   UCBJBNR
UCBJES3  EQU   UCBJBNR
UCBVRDEV EQU   UCBJBNR
UCBCMSEG EQU   UCBOB
UCBPFXND EQU   UCB+512
UCBIOQ   EQU   UCB+508
UCBLOCK  EQU   UCB+504
UCBPXST  EQU   UCB+504
@NM00001 EQU   UCB
.@UNREFD ANOP                          END UNREFERENCED COMPONENTS
@RC00143 EQU   @RC00139
@RC00141 EQU   @RC00139
@RF00157 EQU   @EL00002
@RC00281 EQU   @EL00007
@RC00327 EQU   @EL00008
@RC00285 EQU   @RC00281
@RC00302 EQU   @RC00281
@RF00301 EQU   @RC00281
@RC00297 EQU   @RC00281
@RC00293 EQU   @RC00281
@RC00294 EQU   @RC00293
@RC00298 EQU   @RC00297
@ENDDATA EQU   *
         END   IGFDT2,(C'PLS1639',0701,77109)
