CC60     TITLE  'IGFC60 - 2860 CHANNEL ANALYSIS ROUTINE'
IGFC60   CSECT
******************************************************************
*
*FUNCTION
*     THIS MODULE PERFORMS THE CHANNEL DEPENDENT ANALYSIS FOR THE 2860
*     CHANNEL. IT RECEIVES CONTROL FROM THE ERPIB FILL SUBROUTINE
*     (IGFCCHFE) OF THE CCH CENTRAL MODULE.
*
*     USING THE INFORMATION CONTAINED WITHIN THE LOGOUT , THE MODULE
*     DETERMINES THE CORRECT SETTTNGS FOR THE VALIDITY BITS, SOURCE OF
*     ERRORS INDICATORS, TERMINATION CODES, AND SEQUENCE CODES OF THE
*     WORK ERPIB. HAVING COMPLETED THE WORK ERPIB THE MODULE RETURNS
*     TO THE ERPIB FILL SUBROUTINE.
*
* STATUS  OS/VS2 REL3.7 SU851
*
*     APARS FIXED =                                            @ZA18585
*          OZ18585, OZ32238,
*
*ENTRY POINTS
*   IGFC60 -  FROM THE CENTRAL IGFCCHFE SUBROUTINE.
*
*INPUT
*   1. CHANNEL LOG
*   2. GPR6     -IOS UNIT ADDRESS
*   3. GPR8     -ADDRESS OF THE PCCA
*   4. GPR14    -RETURN ADDRESS
*   5. GPR15    -BASE ADDRESS FOR THIS MODULE
*   6. CSW
*   7. CCW AT COMMAND ADDRESS MINUS 8
*
*OUTPUT
*   1. APPROPRIATE BITS IN ERPIB
*   2. LOGOUT LENGTH AND ADDRESS TO PCCA
*
*EXTERNAL REFERENCES
*   CHANNEL LOG
*   PCCA
*   CCW
*   CSW
*
*EXIT,NORMAL
*   RETURN IS VIA LINK REGISTER 14 TO A POINT IN THE
*   ERPIB FILL SUBROUTINE(IGFCCHFE)
*
*
*EXIT,ERROR
*   NONE
*
*TABLES/WORK AREA
*   PCCAWERP (WORK ERPIB)
*   C60PATCH MODULE PATCH AREA                                 @ZA32238
*
*ATTRIBUTES
*   IGFC60 IS DISABLED AND PARALLEL REENTRANT FOR IOS
*
*NOTES
*
*   ERPIB ERROR RECOVERY PROCEDURE INTERFACE BYTES
*
*   BYTE 0 - ZERO
*   BYTE 1,2,3 - UCB ADDRESS POINTER
*   BYTE 4 - PROGRAM FLAG BITS
*        BIT 0 - SIO INST STORED A CSW
*        BIT 1 - I/O INTERRUPT STORED A CSW
*        BIT 2 - TIO INST STORED A CSW
*        BIT 3 - HIO INST STORED A CSW
*        BIT 4 - NOT USED
*        BIT 5 - SENSE DATA STORED
*        BIT 6 - VALID COUNT APPEARS IN CSW
*        BIT 7 - UNCONDITIONAL NO RETRY
*   BYTE 5 - PROBABLE SOURCE OF ERROR INDICATOR BITS
*        BIT 0 - CPU ERROR
*        BIT 1 - CHANNEL ERROR
*        BIT 2 - STORAGE CONTROL UNIT ERROR
*        BIT 3 - STORAGE ERROR
*        BIT 4 - CONTROL UNIT ERROR
*        BIT 5,6,7 - NOT USED
*   BYTE 6 - VALIDITY INDICATOR BITS
*        BIT 0 - INTERFACE ADDRESS
*        BIT 1,2 - NOT USED  MUST BE ZERO
*        BIT 3 - RETRY CODE
*        BIT 4 - DEVICE STATUS
*        BIT 5 - CHANNEL PROGRAM ADDRESS AND KEY
*        BIT 6 - CHANNEL ADDRESS
*        BIT 7 - DEVICE ADDRESS
*   BYTE 7 - TERMINATION/RETRY CODE BITS
*        BIT 0,1 - TERMINATION CODE BITS
*        BIT 2,3 - NOT USED
*        BIT 4 - DISCONNECT-IN
*        BIT 5,6,7 - RETRY BITS
*   CHARACTER CODE DEPENDENCIES
*        THIS ROUTINE IS CHARACTER CODE INDEPENDENT
*
* CHANGE AREA          APPROX
*    TYPE    APAR     SEQUENCE                                 @ZA18585
*     A      OZ18585  006000
*     A      OZ18585  040000
*     A      OZ18585  048400
*     A      OZ18585  235988
*     C      @G51BPLC 277700
*     DA     OZ32238  084700,085620
*     DC     OZ32238  325500,326700
*
*
******************************************************************
         SPACE 2
******************************************************************
*****    REGISTER DEFINITION
*
XLATEREG EQU   1              REG USED IN TRANSLATION OF CSW VIRT. @ CF
UAREG    EQU   6              UNIT ADDRESS
WKREG1   EQU   10             MAIN WORKING REGISTER
WKREG2   EQU   5              WORKING REGISTER
WKREG3   EQU   4              SPACE WORK REGISTER                    CF
LINKRG1  EQU   15             LINK REGISTER(ON ENTRY, BASE @ FOR RTN)CF
LINKRG2  EQU   14             SECONDARY LINK REGISTER
WKERPIB  EQU   9              BASEREG FOR WORK ERPIB                 CF
CCAREG   EQU   8              BASEREG FOR THE PCCA
RTNADRG  EQU   3              BASE REG FOR 2860 ROUTINE              CF
REG0     EQU   0                       ASID RTN FROM XLATE RTN @ZA18585
TESTWK   EQU   7                       WORK REGISTER           @ZA18585
         SPACE 2
*****************************************************************
*
*****    FIXED CORE LOCATIONS
*
*****************************************************************
CSWLOC   EQU   64                       CSW LOCATION
RECLNTH  EQU   102                    LENGTH OF  RECORD ENTRY
LOGLOC   EQU   304                      LOCATION OF LOG OUT AREA
LOGWD1A  EQU   304                      1ST HALF OF LOG WORD 1
LOGWD1B  EQU   308                      2ND HALF OF LOG WORD 1
LOGWD2A  EQU   312                      1ST HALF OF LOG WORD 2
LOGWD2B  EQU   316 .                    2ND HALF OF LOG WORD 2
LOGWD3A  EQU   320 .                    1ST HALF OF LOG WORD 3
LOGWD3B  EQU   324 .                    2ND HALF OF LOG WORD 3
         SPACE 2
*****
*        CSW STATUS INDICATORS
*
CCCBIT   EQU   X'04'                   CHANNEL CONTROL CHECK
ICCBIT   EQU   X'02'                   INTERFACE CONTROL CHECK
         SPACE 1
*
*
*
*        GENERAL EQUATES
*
CCHOPIN  EQU   X'80' .             TO TEST FOR OPERATION IN
CCHPIT   EQU   X'02' .             POLLING INTERRUPT BIT
CCHSIOLH EQU   X'02' .             SIO LATCH
CCHSTGCK EQU   X'04' .             STORAGE CHECK BIT
CCHSETUP EQU   X'10' .                 SET UP BIT IN LOG
         SPACE
ZERO     EQU   0 .                 CONSTANT FOR DISPLACEMENT
ONE      EQU   1 .                 CONSTANT FOR DISPLACEMENT
TWO      EQU   2 .                 CONSTANT FOR DISPLACEMENT
THREE    EQU   3 .                 CONSTANT FOR DISPLACEMENT
FOUR     EQU   4                   CONSTANT FOR DISPLACEMENT
FIVE     EQU   5 .                 CONSTANT FOR DISPLACEMENT
SIX      EQU   6 .                 CONSTANT FOR DISPLACEMENT
SEVEN    EQU   7                   CONSTANT FOR DISPLACEMENT
EIGHT    EQU   8                   CONSTANT FOR DISPLACEMENT
CCH3     EQU   3 .                 CONSTANT FOR DISPLACEMENT
CCH4     EQU   4 .                 CONSTANT FOR DISPLACEMENT
CCH7     EQU   7 .                 CONSTANT FOR DISPLACEMENT
CCH23    EQU   23 .                CONSTANT FOR DISPLACEMENT
HEX00    EQU   X'00'               CONSTANT FOR COUNT                CF
HEX01    EQU   X'01'               CONSTANT FOR MASK
HEX02    EQU   X'02'               CONSTANT FOR COUNT                CF
HEX08    EQU   X'08'               CONSTANT FOR MASK
HEX0E    EQU   X'0E' .             SEQUENCE 2,3,4 TRIGGERS
HEX0F    EQU   X'0F'               CONSTANT FOR MASK
HEX10    EQU   X'10' .             CONSTANT FOR MASK
HEX20    EQU   X'20'               CONSTANT FOR MASK
HEX40    EQU   X'40'               CONSTANT FOR MASK
HEXE0    EQU   X'E0' .             MODE TRIGGERS 9,10,11
ALLFS    EQU   X'FF' .             CONSTANT FOR MASK
BTECNT   EQU   X'03'               BYTE COUNT FOR PARITY TEST
*
         EJECT
*****    2860 DEPENDENT ERPIB FILL
*        THIS ROUTINE IS CALLED BY IGFCCHFE TO ANALYZE THE 2860
*        CHANNEL LOG AND SET THE APPROPRIATE BITS IN THE ERPIB.
         SPACE 2
         USING *,RTNADRG                                             CF
         USING PCCA,CCAREG         BASE FOR PCCA DSECT               CF
         USING IGFERPIB,WKERPIB    BASE FOR WRK ERPIB DSECT
         SPACE 2
         OI    PCCACHF1,PCCACF17  SET FOOTPRINT (2860 RTN ENTERED)   CF
CCH02860 LR    RTNADRG,LINKRG1     GET BASE ADDR IN BASE REG         CF
         MODID                                                 @ZA32238
         LA    WKERPIB,PCCAWERP   GET ADDRESS OF WORK ERPIB IN PCCA  CF
         LA    WKREG2,SIX          CONTROL NUMBER OF WORDS TO CHECK  CF
         LA    WKREG1,LOGLOC      GET BEGINNING OF CHAN LOGOUT AREA  CF
CCH029A  CLC   ZERO(CCH4,WKREG1),ALLONES DID CHAN FAIL TO LOG        CF
         BE    SETSYSTR            YES,BRANCH TO SET TERM
         LA    WKREG1,CCH4(WKREG1) POINT TO NEXT LOG WORD            CF
         BCT   WKREG2,CCH029A      GO CONTINUE TEST
*
         IC    WKREG2,LOGWD3B+THREE    GET UNIT ADDR PARITY BIT
         SRL   WKREG2,SEVEN             RIGHT ADJUST BIT
         STC   WKREG2,PCCALGP1          SET UP PARITY TEST PARAMETER CF
         MVI   PCCACHPB,HEX01      NO. OF BYTES TO BE TESTED IN PCCA CF
         LA    WKREG1,LOGWD2A+3    GET LOC OF UNIT ADDRESS IN LOG    CF
         BAL   LINKRG1,LOGPAR      TEST UNIT ADDRESS PARITY
         B     CCH109 .              GOOD PARITY=VALID UNIT ADDRESS
         OI    CCHSW2,SYSTERM      TURN ON I/O RESTART SWITCH        CF
         B     CCH109A                  INVALID UNIT ADDRESS
         SPACE 1
*****************************************************************
*        THIS ROUTINE CHECKS TO INSURE THAT THE CORRECT UNIT ADDRESS  I
*        IS SET VALID. IF IOS UNIT ADDRESS IS NOT EQUAL TO  UNIT
*        ADDRESS IN LOG, IOS UNIT ADDRESS IS INVALID
         SPACE 2
CCH109   LA    WKREG2,LOGWD2A+THREE .   GET UA ADDR IN LOG AREA.      I
UAVALSET TM    RECBYTE,CCHTIOB .        IS THIS AN ERROR ON A TIO     I
         BO    CCHTSTUA .            BRANCH TO TEST IF UNIT ADDRESS OK
CCHDAVAL OI    IGVALIDB,CCHDAV .        SET UNIT ADDRESS VALID BIT
         B     CCH109A                  TO RETURN TO NORMAL FLOW
         SPACE 1
*                                      DOES THE UNIT ADDRESS FROM
*                                      IOS EQUAL THE UNIT ADDRESS
TSTLOGUA CLI   ZERO(WKREG2),ZERO .     IN THE LOG
         SPACE 1
CCHTSTUA EX    UAREG,TSTLOGUA .         SEE IF HAVE CORRECT UA
         BE    CCHDAVAL .               YES,GO SET DEVICE ADDRESS VALID
         SPACE 2
CCH109A  SR    WKREG2,WKREG2       CLEAR REG
         IC    WKREG2,LOGWD3B+CCH3 .    GET PARITY BIT FOR COMMAND REG
         SRL   WKREG2,TWO .             ISOLATE PARITY BIT TO LOW     I
         STC   WKREG2,PCCALGP1      STORE FOR PARITY CHK SUBROUTINE  CF
         MVI   PCCACHPB,HEX01       NO. BYTES TO BE TESTED IN PCCA   CF
         LA    WKREG1,LOGWD2A+1     ADDR OF BYTE TO BE TESTED        CF
         BAL   LINKRG1,LOGPAR .         GO CHECK PARITY               I
         OI    CCHSW1,CCHCMDRG .        SET COMMAND REG VALID BIT
         TM    CSWLOC+FIVE,ICCBIT  .   WAS THE ERROR AN ICC           I
         BO    CCH110 .                 YES, BRANCH
         OI    IGTERMSQ,COMPFES .       NO, SET FES TERMINATION CODE
         TM    LOGWD3B,CCHOPIN .   IS OP-IN UP                        I
         BZ    CKCMDADP            NO,SKIP SETTING VALID BIT.         I
         OI    IGVALIDB,CCHUSV .        SET VALID UNIT STATUS BIT
CKCMDADP IC    WKREG2,LOGWD3B+TWO .    GET PARITY BITS FOR CMD ADDR   I
         SRL   WKREG2,FOUR              ISOLATE 3 PARITY BITS TO LOW
         STC   WKREG2,PCCALGP1          STORE IN PARAMETER FOR SUBRTNCF
         MVI   PCCACHPB,BTECNT     NO. BYTES TO BE TESTED IN PCCA    CF
         LA    WKREG1,LOGWD1A+1    ADDRESS OF 1ST BYTE TO BE TESTED  CF
         BAL   LINKRG1,LOGPAR .         GO TO CHECK PARITY
         B     CCH11A              GOOD PARITY
         B     CCH112 .           BAD PARITY, SKIP NEXT TEST
*                                          LOG COMMAND COPMARE TO
CCH11A   CLC   LOGWD1A+ONE(THREE),CSWLOC+ONE  CSW COMMAND ADDRESS
         BL    CCH112 .                 COMMAND ADDR INVALID, SKIP SET
         OI    IGVALIDB,CCHCMDV .       SET COMMAND ADDRESS VALID BIT
         SPACE 2
CCH112   TM    RECBYTE,CCHHIOB+CCHTIOB .     HIO OR TIO IN CSW
         BNZ   CCH128 .                 YES,BRANCH
CCH112G  TM    LOGWD3A+ONE,HEX10 .      SET UP ON IN LOG
         BO    CCH113 .                 YES, GO TO SET RETRY CODE
         TM    CCHSW1,CCHCMDRG .        IS COMMAND REG PARITY VALID
         BZ    CCH113 .                 NO, GO SET RETRY CODE
         TM    LOGWD3B,CCHOPIN .        IS OP-IN UP
         BO    CCH112H .                YES,GO SEE IF TIO
         NI    IGTERMSQ,ALLFS-COMPFES . SET TERM CODE TO 00
CCH112H  DS    0H
         TM    RECBYTE,CCHTIOB .        IS THIS ENTRY CAUSED BY TIO
         BO    CCH114 .                 YES, CHECK SEQ TRIGERS
         TM    LOGWD3A,HEX08 .          SEQ TWO TRIGER ON
         BO    CCH115 .                 YES,GO CHK DATA TRANSFER
         TM    LOGWD3B+ONE,CCHSTGCK .  IS THIS A STORAGE ERROR
         BO    CCH112D .           YES,BRANCH
CCH112A  OI    IGBLAME,CCHCHNL .  INTERNAL CHANNEL ERROR
CCH112B  OI    IGTERMSQ,RTCODE4 .       SET RETRY CODE TO 01
         TM    LOGWD3B,CCHSIOLH .       IS SIO LATCH ON
         BZ    CCHRETRN .               NO,RETURN TO COMMON POINT
CCH112C  OI    IGVALIDB,CCHUSV .        SET VALID UNIT STATUS BIT
         B     CCHRETRN .               RETURN TO COMMON POINT
*
         SPACE 1
CCH112D  TM    IGVALIDB,CCHCMDV .  IS C.A. VALID
         BZ    CCH112A .           NO,BRANCH,SET CHANNEL ERROR
*
         OI    IGBLAME,CCHSTG .   STORAGE IS SOURCE OF ERROR
         B     CCH112B .           GO CHECK SIO LATCH
         SPACE 1
*
         SPACE 2
CCH110   OI    IGTERMSQ,COMPSEL .       SET TERM CODE FOR SEL RESET
         TM    LOGWD3B+ONE,HEX40   Q. DISCONNECT-IN UP               CF
         BZ    CCH110E              NO. GO SET CMD ADDRESS VALID     CF
CCH110D  OI    IGTERMSQ,CCHDI       TURN ON DISCONNECT-IN IN ERPIB   CF
CCH110E  OI    IGVALIDB,CCHCMDV .       SET COMMAND ADDR VALID BIT
         TM    LOGWD3A+ONE,CCHPIT .    IS POLLING INTERUPT BIT SET
         BZ    CCH110A             NO,BRANCH
         OI    IGBLAME,CCHINTFC . INTERFACE IS SOURCE OF ERROR
         OI    IGTERMSQ,RTCODE3 .  SET RETRY CODE TO 011
         B     CCHRETRN .               GO TO COMMON RETURN POINT
         SPACE 1
CCH110A  TM    RECBYTE,CCHHIOB+CCHTIOB .     HIO OR TIO IN CSW
         BNZ   CCH123 .                      YES,BRANCH
CCH110B  TM    LOGWD3A+ONE,CCHSETUP .   SET UP BIT ON IN LOG
         BO    CCH116 .                 YES, GO TO SET RETRY CODE
         TM    CCHSW1,CCHCMDRG .        HAS COMMAND REG VALID PARITY
         BZ    CCH116 .                 NO,GO SET RETRY CODE=100
         TM    LOGWD3A,HEX20 .          COMMAND CHAINING
         BO    CCH110C .                YES,BRANCH
         TM    LOGWD3B,CCHSIOLH .       IS SIO LATCH ON
         BO    CCH110C .                YES,BRANCH
         TM    LOGWD3A,HEX08 .          SEQ TWO TRIGER ON
         BO    CCH115 .                 YES, CHECK FOR DATA TRANSFER
CCH110C  DS    0H .
         OI    IGBLAME,CCHINTFC . INTERFACE IS SOURCE OF ERROR
         OI    IGTERMSQ,RTCODE1 .       NO, SET RETRY CODE TO 001
         B     CCHRETRN .               GO TO COMMON RETURN POINT
*
         SPACE 2
CCH117   TM    CSWLOC+FIVE,ICCBIT       WAS ERROR AN ICC
         BO    CCH117A                  YES,DONOT SET COUNT VALID
         OI    IGPRGFLG,CCHCNTB         SET COUNT VALID
CCH117A  B     CCHRETRN                 GO TO COMMON RETURN POINT
*
CCH116   OI    IGTERMSQ,RTCODE4 .       SET RETRY CODE TO 100
         OI    IGBLAME,CCHINTFC . INTERFACE IS SOURCE OF ERROR
         B     CCHRETRN .               GO TO COMMON RETURN POINT
*
         SPACE 2
CCH113   OI    IGTERMSQ,RTCODE4 .       SET RETRY CODE TO 100
         TM    IGVALIDB,CCHDAV .   IS UNIT ADDRESS VALID
         BO    CCH113A .           YES,GO TEST STORAGE CHECK
         TM    LOGWD3B,CCHSIOLH .  IS SIO LATCH ON
         BZ    CCH113B .           NO,BRANCH.INTERNAL CHAN ERROR
*****************************************************************
*        CPU WAS SOURCE OF ERROR
         OI    IGBLAME,CCHCPU .   CPU WAS SOURCE OF ERROR
         B     CCH113C .
*****************************************************************
         SPACE 1
*
*        SEE IF CHANNEL ERROR OR STORAGE ERROR
*
CCH113A  TM    LOGWD3B+ONE,CCHSTGCK .  IS THIS A STORAGE ERROR
         BZ    CCH113B .           NO,BRANCH. CHANNEL ERROR
         OI    IGBLAME,CCHSTG .   SOURCE OF ERROR IS STORAGE
         B     CCH113C .            BRANCH TO STORAGE ERROR
         SPACE 1
CCH113B  OI    IGBLAME,CCHCHNL .  CHANNEL IS SOURCE OF ERROR
CCH113C  TM    LOGWD3B,CCHSIOLH .  IS SIO LATCH ON
         BZ    CCHRETRN                 GO TO COMMON RETURN POINT
         NI    IGVALIDB,ALLFS-CCHCMDV    COMMAND ADDR VALID BIT OFF
*                                      GO TO SET COUNT VALID BIT
         B     CCHRETRN                 GO TO COMMON RETURN POINT
*
         SPACE 2
CCH114   TM    LOGWD3A,HEX0E .          ANY SEQ TRIGERS (2-3-4)
         BC    FIVE,CCH115 .            YES, CHECK FOR DATA TRANSFER
         TM    LOGWD3A,HEX20 .     COMMAND CHAINING BIT ON IN LOG
         BZ    CCH114B .           NO,GO SET CODE
         TM    LOGWD3B,CCHOPIN .   IS OP-IN UP
         BO    CCH115 .            YES,CHECK FOR DATA TRANSFER
         OI    IGBLAME,CCHCHNL .  CHANNEL IS SOURCE OF ERROR
         OI    IGTERMSQ,RTCODE1 .  SET RETRY CODE TO 001
         B     CCHRETRN .          GO TO COMMON RETURN POINT
         SPACE 1
CCH114B  OI    IGTERMSQ,RTCODE4 .  SET RETRY CODE TO 100
         OI    IGBLAME,CCHCHNL .       INTERNAL CHANNEL ERROR
         B     CCH117 .            GO TO COUNT VALID AND RETURN
         SPACE 2
CCH115   TM    LOGWD3B,CCHOPIN .   IS OP-IN UP
         BO    CCH115B .           NO,BRANCH
         TM    CSWLOC+FIVE,CCCBIT .    IS THIS ICC ONLY
         BO    CCH115C .           NO,BRANCH.
CCH115A  OI    IGBLAME,CCHINTFC . ERROR DUE TO INTERFACE
         B     CCH118                   BRANCH TO SET RETRY CODE
         SPACE 1
CCH115B  TM    CSWLOC+FIVE,ICCBIT .    WAS THIS ICC
         BO    CCH115A .           YES,BRANCH. INTERFACE ERROR
         TM    LOGWD3B+ONE,CCHSTGCK .  IS THIS STORAGE CHECK
         BO    CCH115D .           YES,BRANCH
CCH115C  OI    IGBLAME,CCHCHNL .  INTERNAL CHANNEL ERROR
         B     CCH115E .            SKIP STORAGE ERROR SET
         SPACE 1
CCH115D  OI    IGBLAME,CCHSTG .   SOURCE OF ERROR IS STORAGE
CCH115E  TM    IGVALIDB,CCHCMDV .  IS THE COMMAND VALID BIT SET IN LOG
         BZ    CCH118 .                 NO, GO TO SET RETRY CODE
         MVC   PCCALGP1(1),LOGWD3B+TWO  MOVE PARITY BITS FOR SUBROUT CF
         MVI   PCCACHPB,HEX02           NO. BYTES TO BE CKED IN PCCA CF
         LA    WKREG1,LOGWD1B+2         ADR OF BYTES TO BE TESTED    CF
         BAL   LINKRG1,LOGPAR .         GO TO CHECK PARITY
         B     CCH119                   GOOD PARITY                  CF
         B     CCH118 .                 BAD PARITY, SKIP COMPARE     CF
CCH119   NI    LOGWD3A+TWO,HEX0F        CLEAR UNWANTED BITS
         MVI   PCCALGP1,HEX00           SET UP PARITY BYTE           CF
         MVI   PCCACHPB,HEX01           NO. BYTES TO BE CHECKED      CF
         LA    WKREG1,LOGWD3A+TWO       ADDRESS OF BYTE TO CHECKED   CF
         BAL   LINKRG1,LOGPAR .        GO TO CHECK PARITY ON BYTE COUNT
         B     CCH120 .                BRANCH, COUNT VALID           CF
CCH118   OI    IGTERMSQ,RTCODE5 .       SET RETRY TO 101
         B     CCHRETRN .               COMMON RETURN PR IN SUBROUT.
*
         SPACE 2
CCH120   L     XLATEREG,CSWLOC          GET CCW ADDRESS              CF
         LA    XLATEREG,ZERO(XLATEREG)  CLEAR HIGH ORDER BYTE        CF
         SH    XLATEREG,CCHLENGH        REDUCE ADDR BY EIGHT         CF
         BM    CCH118                   THE ADDR IS NEGATIVE(INVALID)CF
         ST    LINKRG2,PCCACHW2         SAVE THE FILL ERPIB RETURN @ CF
         L     WKREG1,CVTPTR            GET POINTER TO THE CVT       CF
         USING CVTMAP,WKREG1
         L     LINKRG1,CVTPTRV          GET THE ADDRESS OF XLATE RTN CF
         DROP  WKREG1
         BALR  LINKRG2,LINKRG1          GO TO THE TRANSLATE ROUTINE  CF
         L     LINKRG2,PCCACHW2         RESTORE FE RETURN PT @       CF
         LTR   LINKRG1,LINKRG1          REAL ADDRESS TRANSLATED ?    CF
         BNZ   CCH118                   NO. ADDRESS INVALID          CF
         L     TESTWK,PCCAPSAV         GET ADDR. OF PSA(V)     @ZA18585
         L     TESTWK,PSAAOLD-PSA(TESTWK) GET ADDR. OF PSAAOLD @ZA18585
         LH    TESTWK,ASCBASID-ASCB(TESTWK) GET ASID NUMBER    @ZA18585
         CR    TESTWK,REG0             COMPARE ASID            @ZA18585
         BNZ   CCH118                  NO - ASID'S NOT EQUAL   @ZA18585
         LR    WKREG2,XLATEREG          GET THE VIRTUAL ADDRESS IN RGCF
         LH    WKREG3,SIX(WKREG2) .     LOAD COUNT FROM THE CCW
         N     WKREG3,CCHMASK1 .        AND OUT UNWANTED BITS
         IC    WKREG2,THREE(WKREG2) .  GET LOW ORDER BYTE OF DATA ADDR
         N     WKREG2,CCHMASK2 .        AND OUT BUT LOW ORDER THREE BIT
         CH    WKREG3,CSWLOC+SIX .      CCW COUNT TO CSW COUNT
         BL    CCH122 .                 LOW,CONTINUE VALIDITY
CCH120A  AR    WKREG3,WKREG2 .          ADD THE LOW BITS TO COUNT
         STH   WKREG3,PCCACHW2          STORE UPDATED COUNT FOR TESTCF
         CLC   PCCACHW2(TWO),LOGWD1B+TWO COUNT EQUAL LOG COUNT      CF
         BNE   CCH121 .                 NO, GO TO SET RETRY CODE
         IC    WKREG3,LOGWD3A+TWO       GET BYTE COUNT REG
         N     WKREG3,CCHMASK2 .        ZERO UNWANTED BITS
         CR    WKREG2,WKREG3 .          EQUAL
         BNE   CCH121 .                 NO, GO TO SET CONDITION CODE
         OI    IGTERMSQ,RTCODE2 .       SET RETRY CODE TO 010
         B     CCH117 .                 GO TO SET COUNT VALID BIT
*
CCH121   OI    IGTERMSQ,RTCODE3 .       SET RETRY CODE TO 011
         B     CCH117 .                 GO TO SET COUNT VALID BIT
*
CCH122   LH    WKREG1,CSWLOC+SIX .      GET CSW BYTE COUNT
         N     WKREG1,CCHMASK1 .        AND OUT UNWANTED BITS
         SR    WKREG1,WKREG2 .          SUBTRACT DAB FROM COUNT
         CR    WKREG1,WKREG3 .          CSW COUNT TO CCW COUNT
         BH    CCH118 .                 HIGH,BR TR INDETERMINATE
         B     CCH120A .                GO CHECK FOR DATA TRANSFER
*
         SPACE 2
CCH123   TM    LOGWD3A,HEX20+HEX0E .   CMD CHAIN OR SEQ TRIGGERS
         BNZ   CCH110B .               YES,BRANCH
         TM    RECBYTE,CCHHIOB .        WAS ERROR ON A HIO
         BO    CCH127 .                 YES,BRANCH
         TM    LOGWD3A+ONE,CCHSETUP .   IS SET UP ON
*                                      NO,GO SET CODE
         BZ    CCH116 .                AND ERROR SOURCE
*
CCH125   TM    LOGWD3B,HEX10 .          SELECT OUT
*                                       YES,GO SET CODE
         BO    CCH116 .                 AND ERROR SOURCE
CCH126   OI    IGBLAME,CCHCHNL .       SET CHAN AS ERROR SOURCE
         OI    IGTERMSQ,RTCODE4 .       SET RETRY CODE TO 100
         B     CCHRETRN .               GO TO COMMON RETURN POINT
*
CCH127   TM    LOGWD3A+ONE,CCHSETUP .   IS SET UP ON
         BZ    CCH126 .                 NO,BRANCH
         B     CCH125                  GO SET CODE AND ERROR SOURCE
*
         SPACE 2
CCH128   TM    LOGWD3A,HEX20+HEX0E .    COMMAND CHAIN OR SEQ TRIGGERS
         BNZ   CCH112G .                YES,BRANCH
         TM    RECBYTE,CCHTIOB .        WAS CAUSE OF ERROR A TIO
         BO    CCH114B .                YES,BRANCH
         TM    IGVALIDB,CCHDAV .        IS UNIT ADDRESS VALID
         BO    CCH129 .                 YES,BRANCH
         OI    IGBLAME,CCHCPU .        SET CPU AS SOURCE OF ERROR
         B     CCH130 .                 BRANCH TO CPU ERROR
*
CCH129   OI    IGBLAME,CCHCHNL .       SET CHAN AS SOURCE OF ERROR
CCH130   OI    IGTERMSQ,RTCODE4 .       SET RETRY CODE TO 100
         B     CCHRETRN .              GO TO COMMON RETURN POINT
         SPACE 2
SETSYSTR OI    CCHSW1,CCHNOLST     SET RECORD ONLY SWITCH
         OI    CCHSW2,SYSTERM+NOLOG    SET SYSTEM TERM PLUS NOLOG
CCHRETRN MVC   PCCALOGL,LOGLNTH    PUT LOGOUT LENGTH IN PCCA   @G51BPLC
         LA    WKREG2,LOGLOC       GET THE ADDRESS LOGOUT            CF
         ST    WKREG2,PCCALOGA     IN THE PCCA                       CF
         BR    LINKRG2             RETURN TO CCH CENTRAL             CF
*
         EJECT
*****    PARITY TEST SUBROUTINE
*
*        THIS SUBROUTINE IS ENTERED BY THE 2860 DEPENDENT CHANNEL
*        ANALYSIS MAINLINE VIA LINKRG1.  ITS PURPOSE TO DETERMINE
*        IF THE PARITY IN ANY GIVEN PORTION OF THE LOG IS GOOD.  THIS
*        IS DETERMINED BY CALCULATING THE PARITY ON A PARTICULAR BYTE
*        AND COMPARING THE RESULT TO THE STORED PARITY BIT, ALSO IN
*        THE LOG.
         SPACE 2
LOGPAR   SR    WKREG2,WKREG2 .          ZERO REGISTER                CF
         IC    WKREG2,PCCACHPB .    GET COUNT OF NUMBER OF BYTES     CF
CCH202   MVI   PCCALGP2,HEX01 .         CLEAR PARITY BYTE            CF
         SR    WKREG3,WKREG3 .          CLEAR REGISTER
         IC    WKREG3,ZERO(WKREG1) .       GET BYTE TO BE CHECKED
CCH201   LTR   WKREG3,WKREG3 .          TEST REGISTER FOR ZERO
         BZ    CCH200 .                 END, COMPARE PARITY BIT
         EX    WKREG3,CCHXOR .          CALCULATE PARITY
         SRL   WKREG3,ONE               GET NEXT BIT
         B     CCH201 .                 LOOP
*
         SPACE 2
CCH200   NI    PCCALGP2,HEX01 .         AND OUT UNWANTED BITS FOR CLICF
         IC    WKREG3,PCCALGP1 .  GET PARITY BITS                    CF
         BCTR  WKREG2,ZERO              REDUCE COUNT OF NUMBER OF BYTES
         SRL   WKREG3,ZERO(WKREG2) .    ISOLATE PARITY BIT TO BE CHK
         N     WKREG3,CCHMASK3 .        AND OUT ANY UNWANTED BITS
         EX    WKREG3,CCHCLI .          TEST PARITY
         BNE   FOUR(LINKRG1) .          RETURN, BAD PARITY
         LTR   WKREG2,WKREG2 .          IS TEST FINISHED
         BE    ZERO(LINKRG1) .          RETURN, GOOD PARITY
         LA    WKREG1,ONE(WKREG1) .     UP ADDR POINTER
         B     CCH202 .                 SET UP TO TEST FOR PARITY
         EJECT
         DS    0F
CCHMASK1 DC    X'0000FFFF'        MASK FOR CLEARING OUT UNWANTED BITS
CCHMASK2 DC    X'00000007'        MASK FOR CLEARING OUT UNWANTED BITS
CCHMASK3 DC    X'00000001'         MASK FOR PARITY CHECK
ALLONES  DC    F'-1'              FOR LOG OUT COMPARISON
*                                  CORRECTION FACTOR FOR
CCHLENGH DC    H'8'                COMMAND ADDRESS
LOGLNTH  DC    H'24'               LOGOUT LENGTH               @G51BPLC
*
CCHXOR   XI    PCCALGP2,ZERO       INSTR TO BE EXECUTED BY PARITY    CF
CCHCLI   CLI   PCCALGP2,ZERO       INSTR TOBE EXECUTED BY PARITY     CF
         SPACE 2
******************************************************************
*                                                                *
*           MAINTAINENCE AREA                                    *
*                                                                *
******************************************************************
         SPACE 2
         DS    0F
C60PATCH DC    50X'00'         PATCH AREA
MAINT    EQU   C60PATCH        FOR XREF                        @ZA32238
         CVT   DSECT=YES                                       @ZA32238
         IHAPSA                                                @ZA18585
         IHAASCB                                               @ZA18585
         IGFERPIB                  1
         IHAPCCA
         END
