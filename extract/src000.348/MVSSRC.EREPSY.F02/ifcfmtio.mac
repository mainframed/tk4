         TITLE 'IFCFMTIO - LOGDATA I/O HANDLER'
IFCFMTIO CSECT ,                                                   0001
@MAINENT DS    0H                                                  0001
         USING *,@15                                               0001
         B     @PROLOG                                             0001
         DC    AL1(16)                                             0001
         DC    C'IFCFMTIO  79.011'                                 0001
         DROP  @15
@PROLOG  STM   @14,@06,12(@13)                                     0001
         STM   @08,@12,52(@13)                                     0001
         BALR  @12,0                                               0001
@PSTART  DS    0H                                                  0001
         USING @PSTART,@12                                         0001
         L     @00,@SIZDATD                                        0001
         GETMAIN  R,LV=(0)
         LR    @11,@01                                             0001
         USING @DATD,@11                                           0001
         ST    @13,@SA00001+4                                      0001
         LM    @00,@01,20(@13)                                     0001
         ST    @11,8(,@13)                                         0001
         LR    @13,@11                                             0001
*                                                                  0093
*/********************************************************************/
*/* FUNCTION-                                                      0093
*       ROUTINE TO DETERMINE IF THE REQUEST WAS FOR A READ OR A WRITE.
*     IF IT WAS NOT EITHER OF THESE REQUESTS,THE FOLLOWING MESSAGE IS
*     PRINTED:                                                     0093
*                                                                  0093
*        *** AN INVALID I/O REQUEST WAS MADE BY THE EREP EDITOR ***
*     (THE REQUEST WAS OTHER THAN A DIRECT READ OR A WRITE TO PRINTER)
*                                                                  0093
*    CALLS-                                                        0093
*         PRINT, PRINTIT, AND READ                                 0093
*                                                                  0093
*    CALLED BY -                                                   0093
*         EREP MODULES IFCEDSUM AND IFCEEDIT FOR READING A RECORD AND
*         PRINTING A LINE OF OUTPUT.                               0093
*                                                                  0093
*    RETURNS TO -                                                  0093
*         CALLER WITH A RETURN CODE OF ZERO IF THE REQUEST WAS VALID,
*         FOUR IF THE REQUEST WAS NOT.                             0093
*                                                                    */
*/********************************************************************/
*                                                                  0093
*   RCREG=ZERO;                     /* SET A GOOD RETURN CODE        */
         SLR   RCREG,RCREG                                         0093
*   IF ACTION=READIRCT THEN         /* READ THE NEXT RECORD          */
         L     @14,ACTPTR(,INPUTPTR)                               0094
         CLC   ACTION(2,@14),@CH00045                              0094
         BNE   @RF00094                                            0094
*     CALL READ;                    /* ROUTINE TO PLACE RECORD IN  0095
*                                      BUFFER                        */
         BAL   @14,READ                                            0095
*   ELSE                            /* NOT A DIRECT READ REQUEST     */
*     IF ACTION=RITEPRTR THEN       /* WRITE A LINE OF OUTPUT        */
         B     @RC00094                                            0096
@RF00094 L     @14,ACTPTR(,INPUTPTR)                               0096
         CLC   ACTION(2,@14),@CH00072                              0096
         BNE   @RF00096                                            0096
*       CALL PRINTIT;               /* ROUTINE TO PRINT              */
         BAL   @14,PRINTIT                                         0097
*     ELSE                          /* INVALID ACTION                */
*       DO;                                                        0098
         B     @RC00096                                            0098
@RF00096 DS    0H                                                  0099
*         ABDPLPTR=PDMPLIST;        /* PTR TO PRINT DUMP PARAMETER 0099
*                                      LIST                          */
         L     ABDPLPTR,PDMPLIST(,PARMPTR)                         0099
*         BUFFER(1:LENGTH(INVACT))=INVACT;/* ERROR MESSAGE           */
         L     @14,ADPLBUF(,ABDPLPTR)                              0100
         MVC   BUFFER(58,@14),INVACT                               0100
*         CALL PRINT;               /* PRINT IT                      */
         L     @15,ADPLPRNT(,ABDPLPTR)                             0101
         BALR  @14,@15                                             0101
*         RCREG=BADACT;             /* SET A BAD RETURN CODE         */
         LA    RCREG,4                                             0102
*       END;                        /* END INVALID ACTION REQUESTED  */
*   RETURN CODE(RCREG);                                            0104
@RC00096 DS    0H                                                  0104
@RC00094 LR    @10,@15                                             0104
         L     @13,4(,@13)                                         0104
         L     @00,@SIZDATD                                        0104
         LR    @01,@11                                             0104
         FREEMAIN R,LV=(0),A=(1)
         LR    @15,@10                                             0104
         L     @14,12(,@13)                                        0104
         LM    @00,@06,20(@13)                                     0104
         LM    @08,@12,52(@13)                                     0104
         BR    @14                                                 0104
*READ:                                                             0105
*   PROC OPTIONS(SAVE(14));                                        0105
*                                                                  0105
@EL00001 L     @13,4(,@13)                                         0105
@EF00001 L     @00,@SIZDATD                                        0105
         LR    @01,@11                                             0105
         FREEMAIN R,LV=(0),A=(1)
@ER00001 LM    @14,@06,12(@13)                                     0105
         LM    @08,@12,52(@13)                                     0105
         BR    @14                                                 0105
READ     ST    @14,@SA00002                                        0105
*/********************************************************************/
*/* FUNCTION-                                                      0106
*       ROUTINE TO MOVE THE RECORD INTO ANOTHER,ZEROED,BUFFFER IN ORDER
*     TO HAVE ALL RECORDS BE CONTIGUOUS INSTEAD OF WRAPPING AROUND THE
*     BUFFER. IT ALSO MOVES THE POINTER TO THE RECORD INTO REG 7 FOR TH
*     EDITOR. THE LENGTH OF THE RECORD IS PLACED IN THE 2 BYTES    0106
*     PRECEDING THE RECORD.                                        0106
*                                                                  0106
*    CALLS-                                                        0106
*         TIMECNV                                                  0106
*                                                                  0106
*    CALLED BY -                                                   0106
*         MAINLINE TO DO THE NECESSARY SET UP FOR THE EDITOR ON A READ
*         REQUEST.                                                 0106
*                                                                  0106
*    RETURNS TO -                                                  0106
*         CALLER WITHOUT SETTING A RETURN CODE.                    0106
*                                                                    */
*/********************************************************************/
*                                                                  0106
*   RECPTR=RECADR;                  /* FILL IN POINTER TO THE CONTROL
*                                      HEADER OF THE ENTRY TO BE READ*/
         L     @14,RECADR(,PARMPTR)                                0106
         LR    RECPTR,@14                                          0106
*   IF WRAP=OFF THEN                /* BUFFER DOES NOT WRAP AROUND   */
*                                                                  0107
         TM    WRAP(RECPTR),B'10000000'                            0107
         BNZ   @RF00107                                            0107
*     /***************************************************************/
*     /*                                                             */
*     /* THE RECORD DOES NOT WRAP THE BUFFER. THIS MEANS THE RECORD  */
*     /* CAN BE COPIED ALL AT ONCE INTO THE NEW BUFFER               */
*     /*                                                             */
*     /***************************************************************/
*                                                                  0108
*     DO;                                                          0108
*                                                                  0108
*       /*************************************************************/
*       /*                                                           */
*       /* SET UP FOR A MOVE CHARACTER LONG, IN CASE THE ENTRY IS    */
*       /* LONGER THAN 256 BYTES. THE MOVE CHAR LONG WILL ALSO PAD   */
*       /* THE REMAINDER OF THE NEW BUFFER TO ZEROS                  */
*       /*                                                           */
*       /*************************************************************/
*                                                                  0109
*       RFY                                                        0109
*        (BUFREG,                                                  0109
*         BUFSIZE,                                                 0109
*         RECREG,                                                  0109
*         RECSIZE) RSTD;                                           0109
*       BUFREG=ADDR(NEWREC);        /* WHERE TO COPY THE RECORD TO   */
         L     BUFREG,UNWRPBUF(,PARMPTR)                           0110
         LA    BUFREG,NEWREC(,BUFREG)                              0110
*       BUFSIZE=LENGTH(NEWREC);     /* BUFFER SIZE                   */
         LA    BUFSIZE,4088                                        0111
*       RECREG=RECADR+LENGTH(BEHDR);/* ADDRESS OF ENTRY TO BE COPIED */
         AH    @14,@CH00092                                        0112
         LR    RECREG,@14                                          0112
*       RECSIZE=BLEN;               /* LENGTH OF THE LOGREC ENTRY    */
         LH    RECSIZE,BLEN(,RECPTR)                               0113
*       MVCL(BUFREG,RECREG);        /* MOVE RECORD INTO NEW BUFFER   */
         MVCL  BUFREG,RECREG                                       0114
*       LNGTH=BLEN;                 /* FILL IN RECORD LENGTH         */
         L     @14,UNWRPBUF(,PARMPTR)                              0115
         MVC   LNGTH(2,@14),BLEN(RECPTR)                           0115
*       RFY                                                        0116
*        (BUFREG,                                                  0116
*         BUFSIZE,                                                 0116
*         RECREG,                                                  0116
*         RECSIZE) UNRSTD;                                         0116
*     END;                          /* END RECORD DOES NOT WRAP      */
*   ELSE                            /* RECORD WRAPS THE BUFFER       */
*                                                                  0118
*     /***************************************************************/
*     /*                                                             */
*     /* THE RECORD WRAPS AROUND THE LOGREC BUFFER. CHECK IF THE     */
*     /* HEADER WRAPS OR IF THE DATA ITSELF WRAPS                    */
*     /*                                                             */
*     /***************************************************************/
*                                                                  0118
*     DO;                                                          0118
         B     @RC00107                                            0118
@RF00107 DS    0H                                                  0119
*       IF RECPTR+LENGTH(BEHDR)>=ENDADR THEN/* CHECK IF HEADER WRAPS */
         LA    @14,16                                              0119
         LR    @10,RECPTR                                          0119
         ALR   @10,@14                                             0119
         L     @06,ENDADR(,PARMPTR)                                0119
         CR    @10,@06                                             0119
         BL    @RF00119                                            0119
*         DO;                       /* IF SO GET TO TOP OF BUFFER    */
*           WRAPDIST=ENDADR-RECPTR; /* DIFFERENCE BETWEEN PTR AND END
*                                      OF BUFFER                     */
         L     @10,ENDADR(,PARMPTR)                                0121
         SLR   @10,RECPTR                                          0121
         LR    WRAPDIST,@10                                        0121
*           WRAPDIST=LENGTH(BEHDR)-WRAPDIST;/* LENGTH LEFT IN HEADER
*                                      AFTER THE WRAP                */
*                                                                  0122
         SLR   @14,WRAPDIST                                        0122
         LR    WRAPDIST,@14                                        0122
*           /*********************************************************/
*           /*                                                       */
*           /* SET UP FOR A MOVE CHARACTER LONG, IN CASE THE ENTRY IS*/
*           /* LONGER THAN 256 BYTES. THE MOVE CHAR LONG WILL ALSO   */
*           /* PAD THE REMAINDER OF THE NEW BUFFER TO ZEROS          */
*           /*                                                       */
*           /*********************************************************/
*                                                                  0123
*           RFY                                                    0123
*            (BUFREG,                                              0123
*             BUFSIZE,                                             0123
*             RECREG,                                              0123
*             RECSIZE) RSTD;                                       0123
*           BUFREG=ADDR(NEWREC);    /* WHERE TO COPY THE RECORD TO   */
         L     BUFREG,UNWRPBUF(,PARMPTR)                           0124
         LA    BUFREG,NEWREC(,BUFREG)                              0124
*           BUFSIZE=LENGTH(NEWREC); /* BUFFER SIZE                   */
         LA    BUFSIZE,4088                                        0125
*           RECREG=BEGINADR+WRAPDIST;/* PTR TO LRB HEADER            */
         LR    RECREG,WRAPDIST                                     0126
         AL    RECREG,BEGINADR(,PARMPTR)                           0126
*           RECSIZE=BLEN;           /* LENGTH OF THE LOGREC ENTRY    */
         LH    RECSIZE,BLEN(,RECPTR)                               0127
*           MVCL(BUFREG,RECREG);    /* MOVE RECORD INTO NEW BUFFER   */
         MVCL  BUFREG,RECREG                                       0128
*           LNGTH=BLEN;             /* FILL IN RECORD LENGTH         */
         L     @14,UNWRPBUF(,PARMPTR)                              0129
         MVC   LNGTH(2,@14),BLEN(RECPTR)                           0129
*           RFY                                                    0130
*            (BUFREG,                                              0130
*             BUFSIZE,                                             0130
*             RECREG,                                              0130
*             RECSIZE) UNRSTD;                                     0130
*         END;                      /* END HEADER WRAP RECORD        */
*       ELSE                        /* RECORD ITSELF WRAPS RECORD    */
*                                                                  0132
*         /***********************************************************/
*         /*                                                         */
*         /* DATA IS THE PART THAT WRAPS                             */
*         /*                                                         */
*         /***********************************************************/
*                                                                  0132
*         DO;                                                      0132
         B     @RC00119                                            0132
@RF00119 DS    0H                                                  0133
*           WRAPDIST=ENDADR-(RECPTR+LENGTH(BEHDR));/* DISTANCE TO THE
*                                      END OF THE BUFFER, LENGTH   0133
*                                      BEFORE WRAP                   */
*                                                                  0133
         LA    @14,16                                              0133
         ALR   @14,RECPTR                                          0133
         L     WRAPDIST,ENDADR(,PARMPTR)                           0133
         SLR   WRAPDIST,@14                                        0133
*           /*********************************************************/
*           /*                                                       */
*           /* SET UP FOR A MOVE CHARACTER LONG, IN CASE THE ENTRY IS*/
*           /* LONGER THAN 256 BYTES. THE MOVE CHAR LONG WILL ALSO   */
*           /* PAD THE REMAINDER OF THE NEW BUFFER TO ZEROS          */
*           /*                                                       */
*           /*********************************************************/
*                                                                  0134
*           RFY                                                    0134
*            (BUFREG,                                              0134
*             BUFSIZE,                                             0134
*             RECREG,                                              0134
*             RECSIZE) RSTD;                                       0134
*           BUFREG=ADDR(NEWREC);    /* WHERE TO COPY THE RECORD TO   */
         L     BUFREG,UNWRPBUF(,PARMPTR)                           0135
         LA    BUFREG,NEWREC(,BUFREG)                              0135
*           BUFSIZE=LENGTH(NEWREC); /* BUFFER SIZE                   */
         LA    BUFSIZE,4088                                        0136
*           RECREG=RECPTR+LENGTH(BEHDR);/* PTR TO LRB HDR OF ENTRY   */
         LR    RECREG,@14                                          0137
*           RECSIZE=WRAPDIST;       /* LENGTH OF THE LOGREC ENTRY  0138
*                                      BEFORE WRAP                   */
         LR    RECSIZE,WRAPDIST                                    0138
*           MVCL(BUFREG,RECREG);    /* MOVE IN PARTIAL RECORD        */
         MVCL  BUFREG,RECREG                                       0139
*           SECONDLN=BLEN-WRAPDIST; /* LENGTH LEFT TO MOVE           */
         LH    SECONDLN,BLEN(,RECPTR)                              0140
         SLR   SECONDLN,WRAPDIST                                   0140
*           BUFREG=ADDR(NEWREC)+WRAPDIST;/* WHERE TO COPY REST OF REC
*                                      TO                            */
         L     BUFREG,UNWRPBUF(,PARMPTR)                           0141
         LA    BUFREG,NEWREC(,BUFREG)                              0141
         ALR   BUFREG,WRAPDIST                                     0141
*           BUFSIZE=LENGTH(NEWREC)-WRAPDIST;/* REMAINDER OF BUFFER 0142
*                                      SIZE                          */
         LA    BUFSIZE,4088                                        0142
         SLR   BUFSIZE,WRAPDIST                                    0142
*           RECREG=BEGINADR;        /* PTR TO BEGINNING OF LOGREC  0143
*                                      BUFFER WRAPPED PART OF ENTRY  */
         L     RECREG,BEGINADR(,PARMPTR)                           0143
*           RECSIZE=SECONDLN;       /* LENGTH OF REMAINDER OF ENTRY
*                                      AFTER WRAP                    */
         LR    RECSIZE,SECONDLN                                    0144
*           MVCL(BUFREG,RECREG);    /* MOVE IN REST OF RECORD        */
         MVCL  BUFREG,RECREG                                       0145
*           LNGTH=BLEN;             /* FILL IN RECORD LENGTH         */
         L     @14,UNWRPBUF(,PARMPTR)                              0146
         MVC   LNGTH(2,@14),BLEN(RECPTR)                           0146
*           RFY                                                    0147
*            (BUFREG,                                              0147
*             BUFSIZE,                                             0147
*             RECREG,                                              0147
*             RECSIZE) UNRSTD;                                     0147
*         END;                      /* END RECORD ITSELF WRAPS AROUND*/
*     END;                          /* END RECORD WRAPS THE BUFFER   */
@RC00119 DS    0H                                                  0150
*   RECADR=ADDR(NEWREC);            /* FILL IN POINTER TO RECORD     */
@RC00107 L     @14,UNWRPBUF(,PARMPTR)                              0150
         LA    @14,NEWREC(,@14)                                    0150
         ST    @14,RECADR(,PARMPTR)                                0150
*   RECLNGTH=BLEN;                  /* FILL IN RECORD LENGTH IN    0151
*                                      COMMUNICATIONS TABLE          */
         MVC   RECLNGTH(2,PARMPTR),BLEN(RECPTR)                    0151
*   JUSTREAD=ON;                    /* JUST READ A RECORD- NEW PAGE
*                                      FOR OUTPUT WANTED             */
         OI    JUSTREAD(PARMPTR),B'10000000'                       0152
*   RECPTR=ADDR(NEWREC);            /* PTR TO RECORD TO PASS TO    0153
*                                      CALLER                        */
         LR    RECPTR,@14                                          0153
*   CALL TIMECNV;                   /* CONVERT TIME STAMP TO LOCAL 0154
*                                      TIME                          */
         BAL   @14,TIMECNV                                         0154
*TIMECNV:                                                          0155
*   PROC OPTIONS(SAVE(14));                                        0155
*                                                                  0155
         B     @PB00003                                            0155
TIMECNV  ST    @14,@SA00003                                        0155
*/********************************************************************/
*/* FUNCTION-                                                      0156
*       ROUTINE TO CONVERT THE TIME STAMP FROM NANOSECONDS INTO LOCAL
*       TIME IN DECIMAL, FOR THE EREP EDITOR.                      0156
*                                                                  0156
*    CALLS-                                                        0156
*       MAKES NO OUTSIDE CALLS                                     0156
*                                                                  0156
*    CALLED BY -                                                   0156
*         READ,TO CONVERT THE TIME                                 0156
*                                                                  0156
*    RETURNS TO -                                                  0156
*         CALLER WITHOUT SETTING A RETURN CODE.                    0156
*                                                                    */
*/********************************************************************/
*                                                                  0156
*   RFY                                                            0156
*    (DAYS,                                                        0156
*     TIME) RSTD;                   /* RESTRICT EXPLICIT REGS        */
*   IF LRBHTMC=OFF THEN             /* IF THE TIME MACRO WAS NOT USED
*                                      - TIME NEEDS TO BE CONVERTED  */
*                                                                  0157
         TM    LRBHTMC(RECPTR),B'00001000'                         0157
         BNZ   @RF00157                                            0157
*     /***************************************************************/
*     /*                                                             */
*     /* NEW SYSTEM TO YYDDD AND HHMMSS                              */
*     /*                                                             */
*     /***************************************************************/
*                                                                  0158
*     DO;                                                          0158
*       DAYS=LRBHDATE;              /* SAVE DATE IN WORKAREA         */
         L     DAYS,LRBHDATE(,RECPTR)                              0159
*       TIME=LRBHTIME;              /* SAVE TIME IN WORK AREA        */
         L     TIME,LRBHTIME(,RECPTR)                              0160
*       LRBHNS=OFF;                 /* TURN OFF NS SWITCH            */
*       LRBHTMC=ON;                 /* INDICATE TIME CONVERTED       */
         OI    LRBHTMC(RECPTR),B'00001000'                         0162
         NI    LRBHNS(RECPTR),B'10111111'                          0162
*       IF((DAYS=ZERO)&(TIME=ZERO)) THEN                           0163
         SLR   @14,@14                                             0163
         CR    DAYS,@14                                            0163
         BNE   @RF00163                                            0163
         CR    TIME,@14                                            0163
         BE    @RT00163                                            0163
*         ;                         /* NO TIME TO BE CONVERTED       */
*       ELSE                        /* NS TIME NEEDS TO BE CONVERTED */
*         DO;                                                      0165
@RF00163 DS    0H                                                  0166
*           SRDL(DAYS,SHIFT12);     /* CONVERT FROM NANO SECS TO   0166
*                                      MICRO SECS                    */
*                                                                  0166
         SRDL  DAYS,12                                             0166
*           /*********************************************************/
*           /*                                                       */
*           /* DIVIDE THE MICRO SECONDS TO GET THE NUMBER OF MINUTES */
*           /* AND THE NUMBER OF MICRO SECONDS THAT REMAIN           */
*           /*                                                       */
*           /*********************************************************/
*                                                                  0167
*           GEN REFS(DAYS,TIME,SIXTYMIL) SETS(DAYS,TIME)           0167
*               (D DAYS,SIXTYMIL);                                 0167
         D DAYS,SIXTYMIL
*           MINUTES=TIME;           /* SAVE NUMBER OF MINUTES        */
         LR    MINUTES,TIME                                        0168
*           TIME=REMNDER;           /* MOVE THE REMAINING MICRO SECS
*                                      INTO TIME REG                 */
         LR    TIME,REMNDER                                        0169
*           REMNDER=ZERO;           /* INITIALIZE FOR A DIVIDE       */
*                                                                  0170
         SLR   REMNDER,REMNDER                                     0170
*           /*********************************************************/
*           /*                                                       */
*           /* DIVIDE THE MICRO SECONDS TO GET THE NUMBER OF SECONDS */
*           /* AND THE NUMBER OF MICRO SECONDS THAT REMAIN           */
*           /*                                                       */
*           /*********************************************************/
*                                                                  0171
*           GEN REFS(DAYS,TIME,MILLION) SETS(DAYS,TIME)(D DAYS,MILLION)
*               ;                                                  0171
         D DAYS,MILLION
*           CVD(TIME,WORKDWRD);     /* CONVERT SECONDS TO DECIMAL    */
         CVD   TIME,WORKDWRD                                       0172
*           TIME=REMNDER;           /* MOVE THE REMAINING MICRO    0173
*                                      SECONDS INTO TIME             */
         LR    TIME,REMNDER                                        0173
*           CVDVALUE=VALUE;         /* MOVE CONVERTED VALUE INTO A 0174
*                                      REG                           */
         SLR   CVDVALUE,CVDVALUE                                   0174
         ICM   CVDVALUE,3,VALUE                                    0174
*           SRL(CVDVALUE,SHIFT4);   /* ELIMINATE THE SIGN BITS       */
         SRL   CVDVALUE,4                                          0175
*           SEC=CVDVALUE;           /* SAVE THE SECONDS              */
         STC   CVDVALUE,SEC                                        0176
*           REMNDER=ZERO;           /* INITIALIZE FOR DIVIDE         */
*                                                                  0177
         SLR   REMNDER,REMNDER                                     0177
*           /*********************************************************/
*           /*                                                       */
*           /* DIVIDE THE MICRO SECONDS TO GET THE TENTHS OF SECONDS */
*           /*                                                       */
*           /*********************************************************/
*                                                                  0178
*           GEN REFS(DAYS,TIME,TTHOUS) SETS(DAYS,TIME)(D DAYS,TTHOUS);
         D DAYS,TTHOUS
*           CVD(TIME,WORKDWRD);     /* CONVERT TENTHS OF SECS TO   0179
*                                      DECIMAL                       */
         CVD   TIME,WORKDWRD                                       0179
*           CVDVALUE=VALUE;         /* MOVE CONVERTED VALUE INTO A 0180
*                                      REG                           */
         SLR   CVDVALUE,CVDVALUE                                   0180
         ICM   CVDVALUE,3,VALUE                                    0180
*           SRL(CVDVALUE,SHIFT4);   /* ELIMINATE THE SIGN BITS       */
         SRL   CVDVALUE,4                                          0181
*           TNTH=CVDVALUE;          /* SAVE TENTHS OF SECONDS        */
         STC   CVDVALUE,TNTH                                       0182
*           REMNDER=ZERO;           /* DONE WITH SECONDS, INITIALIZE
*                                      FOR FOR A DIVIDE              */
         SLR   REMNDER,REMNDER                                     0183
*           TIME=MINUTES;           /* RESTORE TIME WITH THE NUM OF
*                                      MINS                          */
*                                                                  0184
         LR    TIME,MINUTES                                        0184
*           /*********************************************************/
*           /*                                                       */
*           /* DIVIDE THE MINUTES TO GET THE HOURS AND THE NUMBER OF */
*           /* MINUTES REMAINING                                     */
*           /*                                                       */
*           /*********************************************************/
*                                                                  0185
*           GEN REFS(DAYS,TIME,SIXTY) SETS(DAYS,TIME)(D DAYS,SIXTY);
         D DAYS,SIXTY
*           CVD(DAYS,WORKDWRD);     /* CONVERT MINS TO DECIMAL       */
         CVD   DAYS,WORKDWRD                                       0186
*           CVDVALUE=VALUE;         /* MOVE CONVERTED VALUE INTO A 0187
*                                      REG                           */
         SLR   CVDVALUE,CVDVALUE                                   0187
         ICM   CVDVALUE,3,VALUE                                    0187
*           SRL(CVDVALUE,SHIFT4);   /* ELIMINATE THE SIGN BITS       */
         SRL   CVDVALUE,4                                          0188
*           MINS=CVDVALUE;          /* SAVE THE MINUTES              */
         STC   CVDVALUE,MINS                                       0189
*           REMNDER=ZERO;           /* INITIALIZE FOR THE DIVIDE     */
*                                                                  0190
         SLR   REMNDER,REMNDER                                     0190
*           /*********************************************************/
*           /*                                                       */
*           /* DIVIDE THE HOURS TO GET THE NUMBER OF DAYS AND THE    */
*           /* NUMBER OF HOURS REMAINING                             */
*           /*                                                       */
*           /*********************************************************/
*                                                                  0191
*           GEN REFS(DAYS,TIME,TFOUR) SETS(DAYS,TIME)(D DAYS,TFOUR);
         D DAYS,TFOUR
*           CVD(DAYS,WORKDWRD);     /* CONVERT HOURS TO DECIMAL      */
         CVD   DAYS,WORKDWRD                                       0192
*           CVDVALUE=VALUE;         /* MOVE CONVERTED VALUE INTO A 0193
*                                      REG                           */
         SLR   CVDVALUE,CVDVALUE                                   0193
         ICM   CVDVALUE,3,VALUE                                    0193
*           SRL(CVDVALUE,SHIFT4);   /* ELIMINATE THE SIGN BITS       */
         SRL   CVDVALUE,4                                          0194
*           HR=CVDVALUE;            /* SAVE HOURS                    */
         STC   CVDVALUE,HR                                         0195
*                                                                  0196
*           /*********************************************************/
*           /*                                                       */
*           /* DETERMINE THE DATE - YEAR AND DAY                     */
*           /*                                                       */
*           /*********************************************************/
*                                                                  0196
*           YEAR=ZERO;              /* SET YEAR TO 0                 */
         SLR   YEAR,YEAR                                           0196
*           TIME=TIME+1;            /* INCREMENT DAY COUNTER BY 1  0197
*                                      SINCE 1900 IS NOT A LEAP YEAR,
*                                      AND THE LOOP ASSUMES IT IS    */
         AH    TIME,@CH00040                                       0197
*           DO WHILE(TIME-LEAPYEAR>=ZERO);/* LOOP TO COUNT NUM YEARS */
         B     @DE00198                                            0198
@DL00198 DS    0H                                                  0199
*             TIME=TIME-LEAPYEAR;   /* DECREMENT DAYS BY NUMBER OF 0199
*                                      DAYS IN A LEAP YEAR           */
         SH    TIME,@CH00606                                       0199
*             YEAR=YEAR+1;          /* ADD 1 TO YEAR NUM             */
         LA    @14,1                                               0200
         ALR   YEAR,@14                                            0200
*             DO LOOP=1 TO 3 WHILE(TIME-NMALYEAR>=ZERO);/* LOOP TO 0201
*                                      COUNT NUMBER OF NORMAL YEARS  */
         LR    LOOP,@14                                            0201
@DL00201 LA    @14,365                                             0201
         LR    @10,TIME                                            0201
         SLR   @10,@14                                             0201
         LTR   @10,@10                                             0201
         BM    @DC00201                                            0201
*               TIME=TIME-NMALYEAR; /* DECREMENT BY NUMBER OF DAYS IN
*                                      A NORMAL YEAR                 */
         SLR   TIME,@14                                            0202
*               YEAR=YEAR+1;        /* ADD 1 TO YEAR NUM             */
         AH    YEAR,@CH00040                                       0203
*             END;                  /* END LOOP TO COUNT NUM NORMAL
*                                      YEARS                         */
         AH    LOOP,@CH00040                                       0204
         CH    LOOP,@CH00065                                       0204
         BNH   @DL00201                                            0204
@DC00201 DS    0H                                                  0205
*           END;                    /* END LOOP TO COUNT THE NUMBER
*                                      OF YEARS                      */
@DE00198 LR    @14,TIME                                            0205
         SH    @14,@CH00606                                        0205
         LTR   @14,@14                                             0205
         BNM   @DL00198                                            0205
*           TIME=TIME+1;            /* ADD AN EXTRA DAY TO ACCOUNT 0206
*                                      FOR THE SECONDS               */
         AH    TIME,@CH00040                                       0206
*           CVD(YEAR,WORKDWRD);     /* CONVERT NUM YEARS TO DECIMAL  */
         CVD   YEAR,WORKDWRD                                       0207
*           CVDVALUE=VALUE;         /* MOVE CONVERTED VALUE INTO A 0208
*                                      REG                           */
         SLR   CVDVALUE,CVDVALUE                                   0208
         ICM   CVDVALUE,3,VALUE                                    0208
*           SRL(CVDVALUE,SHIFT4);   /* ELIMINATE THE SIGN BITS       */
         SRL   CVDVALUE,4                                          0209
*           YR=CVDVALUE;            /* SAVE NUMBER OF YEARS          */
         STC   CVDVALUE,YR                                         0210
*           CVD(TIME,WORKDWRD);     /* CONVERT DAYS TO DECIMAL       */
         CVD   TIME,WORKDWRD                                       0211
*           DY=(VALUE×'000F'X);     /* SAVE DAYS WITH SIGN           */
         MVC   DY(2),VALUE                                         0212
         OC    DY(2),@CB00678                                      0212
*           DATEFLG=ZEROBYTE;       /* ZERO OUT HIGHORDER BYTE       */
         MVC   DATEFLG(1),ZEROBYTE                                 0213
*           LRBHTIME=TIMESAVE;      /* FILL IN NEW TIME              */
         MVC   LRBHTIME(4,RECPTR),TIMESAVE                         0214
*           LRBHDATE=DAYSAVE;       /* FILL IN NEW DATE              */
         MVC   LRBHDATE(4,RECPTR),DAYSAVE                          0215
*         END;                      /* END NS TIME CONVERSION NEEDED */
*     END;                          /* END TIME MACRO NOT USED-TIME
*                                      CONVERSION NEEDED             */
*   ELSE                                                           0218
*     ;                             /* TIME ALREADY CONVERTED        */
@RF00157 DS    0H                                                  0219
*   RFY                                                            0219
*    (DAYS,                                                        0219
*     TIME) UNRSTD;                                                0219
*   END TIMECNV;                                                   0220
@EL00003 DS    0H                                                  0220
@EF00003 DS    0H                                                  0220
@ER00003 L     @14,@SA00003                                        0220
         BR    @14                                                 0220
*   END READ;                                                      0221
@EL00002 DS    0H                                                  0221
@EF00002 DS    0H                                                  0221
@ER00002 L     @14,@SA00002                                        0221
         BR    @14                                                 0221
*PRINTIT:                                                          0222
*   PROC OPTIONS(SAVE(14));                                        0222
*                                                                  0222
PRINTIT  ST    @14,@SA00004                                        0222
*/********************************************************************/
*/* FUNCTION-                                                      0223
*      ROUTINE TO INTERPRET THE CARRIAGE CONTROL AND PRINT THE LINE OF
*     OUTPUT PASSED BY THE EDITOR. IF THE LINE IS THE FIRST LINE OF A
*     NEW RECORD, THE RECORD BEGINS ON A NEW PAGE. IF THE OUTPUT WAS TO
*     GO TO THE MESSAGE ROUTINE, THE MESSAGE WILL APPEAR DOUBLE SPACED.
*                                                                  0223
*    CALLS-                                                        0223
*         PRINT                                                    0223
*                                                                  0223
*    CALLED BY -                                                   0223
*         MAINLINE TO PRINT THE LINE OF OUTPUT PASSED BY THE EDITOR
*                                                                  0223
*    RETURNS TO -                                                  0223
*         CALLER WITHOUT SETTING A RETURN CODE.                    0223
*                                                                    */
*/********************************************************************/
*                                                                  0223
*   ABDPLPTR=PDMPLIST;              /* RESTORE PRINT DUMP PARM LIST
*                                      PTR                           */
         L     ABDPLPTR,PDMPLIST(,PARMPTR)                         0223
*   IF JUSTREAD=ON THEN             /* IF A NEW RECORD WAS READ,   0224
*                                      EJECT TO A NEW PAGE           */
         TM    JUSTREAD(PARMPTR),B'10000000'                       0224
         BNO   @RF00224                                            0224
*     DO;                                                          0225
*       JUSTREAD=OFF;               /* DO NOT WANT A NEW PAGE FOR  0226
*                                      EACH LINE                     */
*                                                                  0226
         NI    JUSTREAD(PARMPTR),B'01111111'                       0226
*       /*************************************************************/
*       /*                                                           */
*       /* SINCE AMDPRDMP IGNORES ALL BLANKS AT THE BEGINNING OF A   */
*       /* PAGE AND STARTS PRINTING WITH THE FIRST LINE OF DATA,     */
*       /* PRINT BLANKS FOR THE MAX NUMBER OF LINES ON A PAGE. THIS  */
*       /* WILL FORCE AMDPRDMP TO START A NEW RECORD ON A NEW PAGE.  */
*       /*                                                   @ZM44947*/
*       /*                                                           */
*       /*************************************************************/
*                                                                  0227
*       DO LOOP=1 TO LINECT;        /* LOOP TO PRINT BLANK LINES   0227
*                                                            @ZM44947*/
         LA    LOOP,1                                              0227
         B     @DE00227                                            0227
@DL00227 DS    0H                                                  0228
*         CALL PRINT;               /* PRINT A BLANK                 */
         L     @15,ADPLPRNT(,ABDPLPTR)                             0228
         BALR  @14,@15                                             0228
*       END;                        /* END LOOP TO PRINT BLANK LINES */
         AH    LOOP,@CH00040                                       0229
@DE00227 CH    LOOP,LINECT(,PARMPTR)                               0229
         BNH   @DL00227                                            0229
*     END;                          /* END EJECT TO A NEW PAGE       */
*   ELSE                                                           0231
*     ;                             /* NEW RECORD NOT READ   @ZM44947*/
@RF00224 DS    0H                                                  0232
*   IF DSET=MSG THEN                /* ERROR MESSAGE AS OPPOSED TO A
*                                      FORMATTED LINE OF OUTPUT      */
         L     @14,PRINTADR(,PARMPTR)                              0232
         CLC   DSET(1,@14),MSG                                     0232
         BNE   @RF00232                                            0232
*     CC=DOUBLE;                    /* SET DOUBLE SPACE FOR MESSAGES */
         MVC   CC(1,@14),DOUBLE                                    0233
*   ELSE                                                           0234
*     ;                             /* NOT A MESSAGE                 */
*                                                                  0234
@RF00232 DS    0H                                                  0235
*   /*****************************************************************/
*   /*                                                               */
*   /* INTERPRET THE CARRIAGE CONTROL FOR THE OUTPUT LINE. IF THE    */
*   /* CARRIAGE CONTROL INDICATED SPACING BEFORE THE PRINT, DETERMINE*/
*   /* HOW MANY LINES ARE TO BE SPACED                               */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0235
*   IF CC=TRIPLE×CC=MACHTRIP THEN   /* TRIPLE SPACE PRINTING         */
         L     @14,PRINTADR(,PARMPTR)                              0235
         CLC   CC(1,@14),TRIPLE                                    0235
         BE    @RT00235                                            0235
         CLC   CC(1,@14),MACHTRIP                                  0235
         BNE   @RF00235                                            0235
@RT00235 DS    0H                                                  0236
*     LOOPEND=2;                    /* 2 BLANK LINES                 */
         LA    LOOPEND,2                                           0236
*   ELSE                            /* NOT TRIPLE SPACE              */
*     IF CC=DOUBLE×CC=MACHDBLE THEN /* DOUBLE SPACE PRINTING         */
         B     @RC00235                                            0237
@RF00235 L     @14,PRINTADR(,PARMPTR)                              0237
         CLC   CC(1,@14),DOUBLE                                    0237
         BE    @RT00237                                            0237
         CLC   CC(1,@14),MACHDBLE                                  0237
         BNE   @RF00237                                            0237
@RT00237 DS    0H                                                  0238
*       LOOPEND=1;                  /* 1 BLANK LINES                 */
         LA    LOOPEND,1                                           0238
*     ELSE                          /* NOT DOUBLE SPACED             */
*       LOOPEND=ZERO;               /* SINGLE SPACE                  */
         B     @RC00237                                            0239
@RF00237 SLR   LOOPEND,LOOPEND                                     0239
*   DO LOOP=1 TO LOOPEND;           /* LOOP TO PRINT BLANK LINES     */
@RC00237 DS    0H                                                  0240
@RC00235 LA    LOOP,1                                              0240
         B     @DE00240                                            0240
@DL00240 DS    0H                                                  0241
*     CALL PRINT;                   /* BLANK LINE                    */
         L     @15,ADPLPRNT(,ABDPLPTR)                             0241
         BALR  @14,@15                                             0241
*   END;                            /* END BLANK LINE LOOP           */
*                                                                  0242
         AH    LOOP,@CH00040                                       0242
@DE00240 CR    LOOP,LOOPEND                                        0242
         BNH   @DL00240                                            0242
*   /*****************************************************************/
*   /*                                                               */
*   /* PRINT THE LINE OF OUTPUT                                      */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0243
*   BUFFER(1:120)=TEXT(1:120);      /* MOVE 120 CHARACTERS INTO PRINT
*                                      DUMPS BUFFER                  */
         L     @14,ADPLBUF(,ABDPLPTR)                              0243
         L     @10,PRINTADR(,PARMPTR)                              0243
         MVC   BUFFER(120,@14),TEXT(@10)                           0243
*   CALL PRINT;                     /* PRINT THE OUTPUT LINE         */
*                                                                  0244
         L     @15,ADPLPRNT(,ABDPLPTR)                             0244
         BALR  @14,@15                                             0244
*   /*****************************************************************/
*   /*                                                               */
*   /* CHECK IF THE CARRIAGE CONTROL INDICATED THE SPACING TO BE     */
*   /* AFTER THE LINE IS PRINTED. IF SO, DETERMINE HOW MANY LINES ARE*/
*   /* TO BE BLANK                                                   */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0245
*   IF CC=PRINTRIP THEN             /* PRINT THEN SPACE TWO LINES    */
         L     @14,PRINTADR(,PARMPTR)                              0245
         CLC   CC(1,@14),PRINTRIP                                  0245
         BNE   @RF00245                                            0245
*     LOOPEND=2;                    /* TWO BLANK LINES               */
         LA    LOOPEND,2                                           0246
*   ELSE                            /* NOT TRIPLE SPACE              */
*     IF CC=PRNTDBLE THEN           /* PRINT THEN SPACE ONE LINES    */
         B     @RC00245                                            0247
@RF00245 L     @14,PRINTADR(,PARMPTR)                              0247
         CLC   CC(1,@14),PRNTDBLE                                  0247
         BNE   @RF00247                                            0247
*       LOOPEND=1;                  /* 1 BLANK LINES                 */
         LA    LOOPEND,1                                           0248
*     ELSE                          /* NOT DOUBLE SPACE              */
*       LOOPEND=0;                  /* NO SPACEING WANTED AFTER    0249
*                                      PRINTING                      */
         B     @RC00247                                            0249
@RF00247 SLR   LOOPEND,LOOPEND                                     0249
*   DO LOOP=1 TO LOOPEND;           /* LOOP TO PRINT BLANK LINES     */
@RC00247 DS    0H                                                  0250
@RC00245 LA    LOOP,1                                              0250
         B     @DE00250                                            0250
@DL00250 DS    0H                                                  0251
*     CALL PRINT;                   /* BLANK LINE                    */
         L     @15,ADPLPRNT(,ABDPLPTR)                             0251
         BALR  @14,@15                                             0251
*   END;                            /* END BLANK LINE LOOP           */
         AH    LOOP,@CH00040                                       0252
@DE00250 CR    LOOP,LOOPEND                                        0252
         BNH   @DL00250                                            0252
*   TEXT(1:120)=BUFFER(1:120);      /* BLANK OUT EREP OUTPUT BUFFER  */
         L     @14,PRINTADR(,PARMPTR)                              0253
         L     @10,ADPLBUF(,ABDPLPTR)                              0253
         MVC   TEXT(120,@14),BUFFER(@10)                           0253
*   END PRINTIT;                                                   0254
@EL00004 DS    0H                                                  0254
@EF00004 DS    0H                                                  0254
@ER00004 L     @14,@SA00004                                        0254
         BR    @14                                                 0254
*   END IFCFMTIO                                                   0255
*                                                                  0255
*/* THE FOLLOWING INCLUDE STATEMENTS WERE FOUND IN THIS PROGRAM.     */
*/*%INCLUDE SYSLIB  (IHAABDPL)                                       */
*/*%INCLUDE SYSLIB  (IHALRB  )                                       */
*/*%INCLUDE SYSLIB  (COMTABLE)                                       */
*                                                                  0255
*       ;                                                          0255
@DATA    DS    0H
@CH00040 DC    H'1'
@CH00072 DC    H'2'
@CH00065 DC    H'3'
@CH00045 DC    H'6'
@CH00092 DC    H'16'
@CH00606 DC    H'366'
@DATD    DSECT
         DS    0F
@SA00001 DS    18F
@SA00002 DS    1F
@SA00004 DS    1F
@SA00003 DS    1F
IFCFMTIO CSECT
         DS    0F
@DATD    DSECT
         DS    0D
LRBPTR   DS    A
DAYSAVE  DS    CL4
         ORG   DAYSAVE
DATEFLG  DS    CL1
         ORG   DATEFLG
GMTSW    DS    BL1
@NM00036 EQU   DATEFLG+0
         ORG   DAYSAVE+1
YR       DS    CL1
DY       DS    CL2
         ORG   DAYSAVE+4
TIMESAVE DS    BL4
         ORG   TIMESAVE
HR       DS    CL1
MINS     DS    CL1
SEC      DS    CL1
TNTH     DS    CL1
         ORG   TIMESAVE+4
         DS    CL4
WORKDWRD DS    CL8
         ORG   WORKDWRD
@NM00049 DS    CL6
VALUE    DS    CL2
         ORG   WORKDWRD+8
         ORG   *+1-(*-@DATD)/(*-@DATD) INSURE DSECT DATA
@ENDDATD EQU   *
IFCFMTIO CSECT
         DS    0F
@SIZDATD DC    AL1(0)
         DC    AL3(@ENDDATD-@DATD)
         DS    0D
MILLION  DC    F'1000000'
SIXTY    DC    F'60'
SIXTYMIL DC    F'60000000'
TFOUR    DC    F'24'
TTHOUS   DC    F'10000'
MACHDBLE DC    XL1'13'
MACHTRIP DC    XL1'1B'
PRINTRIP DC    XL1'19'
PRNTDBLE DC    XL1'11'
ZEROBYTE DC    XL1'00'
@CB00678 DC    X'000F'
DOUBLE   DC    CL1'1'
MSG      DC    CL1'1'
TRIPLE   DC    CL1'0'
INVACT   DC    CL58'*** AN INVALID I/O REQUEST WAS MADE BY THE EREP EDIC
               TOR ***'
IFCIOPTH DC    CL200'IFCFMTIO PATCH AREA- IT IS 200 BYTES LONG'
@00      EQU   00                      EQUATES FOR REGISTERS 0-15
@01      EQU   01
@02      EQU   02
@03      EQU   03
@04      EQU   04
@05      EQU   05
@06      EQU   06
@07      EQU   07
@08      EQU   08
@09      EQU   09
@10      EQU   10
@11      EQU   11
@12      EQU   12
@13      EQU   13
@14      EQU   14
@15      EQU   15
YEAR     EQU   @08
WRAPDIST EQU   @06
SECONDLN EQU   @10
MINUTES  EQU   @06
LOOPEND  EQU   @04
LOOP     EQU   @06
ABDPLPTR EQU   @01
RECPTR   EQU   @07
PARMPTR  EQU   @02
INPUTPTR EQU   @01
DAYS     EQU   @04
REMNDER  EQU   @04
CVDVALUE EQU   @04
BUFREG   EQU   @04
BUFSIZE  EQU   @05
TIME     EQU   @05
RECREG   EQU   @08
RECSIZE  EQU   @09
RCREG    EQU   @15
ABDPL    EQU   0
ADPLFLAG EQU   ABDPL+7
ADPLBUF  EQU   ABDPL+8
ADPLPRNT EQU   ABDPL+12
LRB      EQU   0
LRBHREL  EQU   LRB+1
LRBHSYS  EQU   LRBHREL
LRBHSW0  EQU   LRB+2
LRBHNS   EQU   LRBHSW0
LRBHTMC  EQU   LRBHSW0
LRBHSW1  EQU   LRB+3
LRBHSW2  EQU   LRB+4
LRBMACT  EQU   LRBHSW2
LRBHSW3  EQU   LRB+5
LRBHDATE EQU   LRB+8
LRBHTIME EQU   LRB+12
LRBHCPID EQU   LRB+16
LRBBASE  EQU   LRB+24
LRBCVAR  EQU   0
LRBCMP   EQU   LRBCVAR+8
PRINT    EQU   0
ACTION   EQU   0
ACTPTR   EQU   0
BEHDR    EQU   0
BLEN     EQU   BEHDR
BFLGS    EQU   BEHDR+2
WRAP     EQU   BFLGS
BUFFER   EQU   0
EREPBUF  EQU   0
DSET     EQU   EREPBUF
CC       EQU   EREPBUF+1
TEXT     EQU   EREPBUF+2
NEWBUF   EQU   0
LNGTH    EQU   NEWBUF+6
NEWREC   EQU   NEWBUF+8
PARM     EQU   0
RECTYPE  EQU   PARM
SWITCHES EQU   PARM+2
DEBUG    EQU   PARM+4
DEBUGA   EQU   PARM+8
MISC     EQU   PARM+12
PRINTES  EQU   MISC
OPENCLSE EQU   PARM+13
OPENIO   EQU   OPENCLSE
CLOSEIO  EQU   OPENCLSE+2
DATENOW  EQU   PARM+17
STDT     EQU   PARM+23
STDATE   EQU   STDT
PSTD     EQU   STDATE+1
ENDDT    EQU   PARM+31
ENDDATE  EQU   ENDDT
PEND     EQU   ENDDATE+1
STTIME1  EQU   PARM+39
ENDTIME1 EQU   PARM+43
STTIME2  EQU   PARM+47
ENDTIME2 EQU   PARM+51
STRTDATE EQU   PARM+55
@NM00043 EQU   PARM+72
@NM00044 EQU   PARM+75
ERRID    EQU   PARM+92
IDTIMEA  EQU   ERRID+6
IDTIME   EQU   IDTIMEA
CCHHRLNG EQU   PARM+112
RECCCHHR EQU   CCHHRLNG
RECLNGTH EQU   CCHHRLNG+6
LINECT   EQU   PARM+120
PRINTADR EQU   PARM+148
DUMPTABL EQU   PARM+228
DUMPINFO EQU   DUMPTABL+4
PDMPLIST EQU   PARM+328
UNWRPBUF EQU   PARM+332
ENDADR   EQU   PARM+336
BEGINADR EQU   PARM+340
WRITEBIT EQU   PARM+344
JUSTREAD EQU   WRITEBIT
LRBHRSW1 EQU   LRBHSW1
LRBHCSW1 EQU   LRBHSW1
LRBHMSW1 EQU   LRBHSW1
LRBMMCH  EQU   LRBBASE
LRBMCEIA EQU   LRBMMCH+8
LRBMTERM EQU   LRBMCEIA
LRBMHARD EQU   LRBMCEIA+1
LRBMINTM EQU   LRBMCEIA+2
LRBMSOFT EQU   LRBMCEIA+3
LRBMPDAR EQU   LRBMMCH+12
LRBMRSR1 EQU   LRBMMCH+13
LRBMRSR2 EQU   LRBMMCH+14
LRBMFLO  EQU   LRBMMCH+24
LRBMCIC  EQU   LRBMFLO
@NM00019 EQU   LRBMCIC
@NM00021 EQU   LRBMCIC+1
@NM00023 EQU   LRBMCIC+2
@NM00025 EQU   LRBMCIC+3
LRBHDWR  EQU   LRBMCIC+4
@NM00028 EQU   LRBMCIC+5
LRBRDDR  EQU   LRBBASE
LRBCCCH  EQU   LRBBASE
LRBCCUA  EQU   LRBCCCH+49
LRBDMDR  EQU   LRBBASE
LRBNMIH  EQU   LRBBASE
LRBTTER  EQU   LRBBASE
RECADR   EQU   RECCCHHR
PARMP1   EQU   PARM
         AGO   .@UNREFD                START UNREFERENCED COMPONENTS
LRBTUSR  EQU   LRBTTER+8
LRBTWSC  EQU   LRBTTER+4
LRBTLNH  EQU   LRBTTER
LRBNINT  EQU   LRBNMIH+24
LRBNDEVT EQU   LRBNMIH+20
LRBNVOL  EQU   LRBNMIH+14
LRBNCUA1 EQU   LRBNMIH+11
LRBNCUA2 EQU   LRBNMIH+8
LRBNJOB  EQU   LRBNMIH
LRBDSENS EQU   LRBDMDR+8
LRBDVOL  EQU   LRBDMDR+2
LRBDCUA1 EQU   LRBDMDR
LRBCCLOG EQU   LRBCCCH+56
LRBCLOGL EQU   LRBCCCH+54
LRBCHCUA EQU   LRBCCCH+52
LRBCCUA2 EQU   LRBCCUA+1
@NM00032 EQU   LRBCCUA
LRBCCHID EQU   LRBCCCH+48
LRBCDEVT EQU   LRBCCCH+44
LRBCECSW EQU   LRBCCCH+40
LRBCFCSW EQU   LRBCCCH+32
LRBCFCCW EQU   LRBCCCH+24
LRBCAIO  EQU   LRBCCCH+8
LRBCJOB  EQU   LRBCCCH
LRBRDEV2 EQU   LRBRDDR+32
LRBRCUA2 EQU   LRBRDDR+29
LRBRPH2  EQU   LRBRDDR+28
LRBRDEV1 EQU   LRBRDDR+24
LRBRCUA1 EQU   LRBRDDR+21
LRBRPH1  EQU   LRBRDDR+20
LRBRVOL2 EQU   LRBRDDR+14
LRBRVOL1 EQU   LRBRDDR+8
LRBRJOB  EQU   LRBRDDR
LRBMCEL  EQU   LRBMMCH+304
@NM00031 EQU   LRBMFLO+20
LRBMFSA  EQU   LRBMFLO+16
@NM00030 EQU   LRBMFLO+8
LRBMCELL EQU   LRBMCIC+6
LRBMVCC  EQU   @NM00028
LRBMVPT  EQU   @NM00028
@NM00029 EQU   @NM00028
@NM00027 EQU   LRBHDWR
LRBMNVF  EQU   LRBHDWR
LRBMVST  EQU   @NM00025
LRBMVLG  EQU   @NM00025
LRBMVCR  EQU   @NM00025
LRBMVGR  EQU   @NM00025
LRBMVFP  EQU   @NM00025
@NM00026 EQU   @NM00025
LRBMVRC  EQU   @NM00025
LRBMVFA  EQU   @NM00025
LRBMVIA  EQU   @NM00023
LRBMVPM  EQU   @NM00023
LRBMVMS  EQU   @NM00023
LRBMVWP  EQU   @NM00023
@NM00024 EQU   @NM00023
LRBMFKE  EQU   @NM00023
LRBMFSC  EQU   @NM00023
LRBMFSE  EQU   @NM00023
LRBMIDY  EQU   @NM00021
LRBMIBU  EQU   @NM00021
@NM00022 EQU   @NM00021
LRBMFWN  EQU   @NM00021
LRBMFDG  EQU   @NM00019
@NM00020 EQU   @NM00019
LRBMFED  EQU   @NM00019
LRBMFCD  EQU   @NM00019
LRBMFTD  EQU   @NM00019
LRBMFSR  EQU   @NM00019
LRBMFPD  EQU   @NM00019
LRBMFSD  EQU   @NM00019
LRBMMOSW EQU   LRBMMCH+16
LRBMPWL  EQU   LRBMMCH+15
LRBMVEQR EQU   LRBMRSR2
LRBMPGFX EQU   LRBMRSR2
LRBMLSQA EQU   LRBMRSR2
LRBMFSQA EQU   LRBMRSR2
LRBMNUCL EQU   LRBMRSR2
LRBMSPER EQU   LRBMRSR2
LRBMINTC EQU   LRBMRSR2
LRBMOFLN EQU   LRBMRSR2
LRBMCHNG EQU   LRBMRSR1
LRBMSER  EQU   LRBMRSR1
@NM00018 EQU   LRBMRSR1
@NM00017 EQU   LRBMPDAR
LRBMRSRF EQU   LRBMPDAR
LRBMRSRC EQU   LRBMPDAR
LRBMINVP EQU   LRBMPDAR
@NM00016 EQU   LRBMPDAR
LRBMSBUF EQU   LRBMSOFT
LRBMSHIR EQU   LRBMSOFT
LRBMSECC EQU   LRBMSOFT
LRBMSEXD EQU   LRBMSOFT
@NM00015 EQU   LRBMSOFT
LRBMSSFT EQU   LRBMSOFT
LRBMIL80 EQU   LRBMINTM
LRBMICTM EQU   LRBMINTM
LRBMICKC EQU   LRBMINTM
LRBMITOD EQU   LRBMINTM
@NM00014 EQU   LRBMINTM
LRBMHIPD EQU   LRBMHARD
LRBMHSPF EQU   LRBMHARD
LRBMHSTO EQU   LRBMHARD
LRBMHINV EQU   LRBMHARD
@NM00013 EQU   LRBMHARD
LRBMHHRD EQU   LRBMHARD
LRBMTINV EQU   LRBMTERM
LRBMTDMG EQU   LRBMTERM
LRBMTWRN EQU   LRBMTERM
LRBMTCKS EQU   LRBMTERM
LRBMTSEC EQU   LRBMTERM
@NM00012 EQU   LRBMTERM
LRBMWSC  EQU   LRBMMCH+4
LRBMLNH  EQU   LRBMMCH
@NM00011 EQU   LRBHMSW1
LRBMSYST EQU   LRBHMSW1
@NM00010 EQU   LRBHMSW1
@NM00009 EQU   LRBHCSW1
LRBCERPP EQU   LRBHCSW1
LRBCDATA EQU   LRBHCSW1
LRBCICUA EQU   LRBHCSW1
LRBCNOSP EQU   LRBHCSW1
@NM00008 EQU   LRBHCSW1
LRBCINCO EQU   LRBHCSW1
LRBCMESG EQU   LRBHCSW1
@NM00007 EQU   LRBHRSW1
LRBRSYSI EQU   LRBHRSW1
LRBROPER EQU   LRBHRSW1
LRBRSEC  EQU   LRBHRSW1
LRBRPRIM EQU   LRBHRSW1
@NM00048 EQU   PARM+346
DUMPSIZE EQU   DUMPINFO+4
DUMPADR  EQU   DUMPINFO
DUMPNUM  EQU   DUMPTABL
@NM00047 EQU   PARM+212
MERDCPTR EQU   PARM+208
RECLNGT1 EQU   PARM+204
FRAMEPTR EQU   PARM+200
SHAREPTR EQU   PARM+196
TRENPTR  EQU   PARM+192
SYSUMPTR EQU   PARM+188
SYMCDPTR EQU   PARM+184
LIBADPTR EQU   PARM+180
CPCUAPTR EQU   PARM+176
CPUPTR   EQU   PARM+172
VOLPTR   EQU   PARM+168
SERPTR   EQU   PARM+164
MODPTR   EQU   PARM+160
DEVPTR   EQU   PARM+156
CUAPTR   EQU   PARM+152
ADCPUT   EQU   PARM+144
SORTADR  EQU   PARM+140
EVPTR    EQU   PARM+136
ADEDITB  EQU   PARM+132
ADIFCMSG EQU   PARM+128
ADIOHND  EQU   PARM+124
@NM00046 EQU   CCHHRLNG+5
USERPGM  EQU   PARM+102
IDTSEC   EQU   IDTIME+3
IDSEC    EQU   IDTIME+2
IDMIN    EQU   IDTIME+1
IDHOUR   EQU   IDTIME
IDASID   EQU   ERRID+4
IDCPU    EQU   ERRID+3
@NM00045 EQU   ERRID+2
IDVALUE  EQU   ERRID
NUMDAYS  EQU   PARM+88
SORTNUM  EQU   PARM+84
TABSIZE  EQU   PARM+80
SYSRETRN EQU   @NM00044
NUMIN222 EQU   @NM00043
WRTHRSH  EQU   PARM+69
RDTHRSH  EQU   PARM+66
TERM     EQU   PARM+58
EVSDAY   EQU   STRTDATE+1
EVSYEAR  EQU   STRTDATE
PENSEC2  EQU   ENDTIME2+2
PENMIN2  EQU   ENDTIME2+1
PENHOUR2 EQU   ENDTIME2
PSTSEC2  EQU   STTIME2+2
PSTMIN2  EQU   STTIME2+1
PSTHOUR2 EQU   STTIME2
PENSEC1  EQU   ENDTIME1+2
PENMIN1  EQU   ENDTIME1+1
PENHOUR1 EQU   ENDTIME1
PSTSEC1  EQU   STTIME1+2
PSTMIN1  EQU   STTIME1+1
PSTHOUR1 EQU   STTIME1
@NM00042 EQU   ENDDT+4
PENDY    EQU   PEND+1
PENYR    EQU   PEND
@NM00041 EQU   ENDDATE
@NM00040 EQU   STDT+4
PSTDY    EQU   PSTD+1
PSTYR    EQU   PSTD
@NM00039 EQU   STDATE
YEARNOW  EQU   DATENOW+4
@NM00038 EQU   DATENOW+3
DAYNOW   EQU   DATENOW
CSNAP    EQU   CLOSEIO
CDRCTWRK EQU   CLOSEIO
CSYSIN   EQU   CLOSEIO
CACCDEV  EQU   CLOSEIO
CACCIN   EQU   CLOSEIO
CSERLOG  EQU   CLOSEIO
CEREPPT  EQU   CLOSEIO
CTOURIST EQU   CLOSEIO
OSNAP    EQU   OPENIO
ODRCTWRK EQU   OPENIO
OSYSIN   EQU   OPENIO
OACCDEV  EQU   OPENIO
OACCIN   EQU   OPENIO
OSERLOG  EQU   OPENIO
OEREPPT  EQU   OPENIO
OTOURIST EQU   OPENIO
PASSFLAG EQU   MISC
PLOGREC  EQU   MISC
ERRORID  EQU   MISC
PSUM     EQU   PRINTES
PEDIT    EQU   PRINTES
PHIST    EQU   MISC
PACC     EQU   MISC
PZERO    EQU   MISC
DEBUG63  EQU   DEBUGA+3
DEBUG62  EQU   DEBUGA+3
DEBUG61  EQU   DEBUGA+3
DEBUG60  EQU   DEBUGA+3
DEBUG59  EQU   DEBUGA+3
DEBUG58  EQU   DEBUGA+3
DEBUG57  EQU   DEBUGA+3
DEBUG56  EQU   DEBUGA+3
DEBUG55  EQU   DEBUGA+2
DEBUG54  EQU   DEBUGA+2
DEBUG53  EQU   DEBUGA+2
DEBUG52  EQU   DEBUGA+2
DEBUG51  EQU   DEBUGA+2
DEBUG50  EQU   DEBUGA+2
DEBUG49  EQU   DEBUGA+2
DEBUG48  EQU   DEBUGA+2
DEBUG47  EQU   DEBUGA+1
DEBUG46  EQU   DEBUGA+1
DEBUG45  EQU   DEBUGA+1
DEBUG44  EQU   DEBUGA+1
DEBUG43  EQU   DEBUGA+1
DEBUG42  EQU   DEBUGA+1
DEBUG41  EQU   DEBUGA+1
DEBUG40  EQU   DEBUGA+1
DEBUG39  EQU   DEBUGA
DEBUG38  EQU   DEBUGA
DEBUG37  EQU   DEBUGA
DEBUG36  EQU   DEBUGA
DEBUG35  EQU   DEBUGA
DEBUG34  EQU   DEBUGA
DEBUG33  EQU   DEBUGA
DEBUG32  EQU   DEBUGA
DEBUG31  EQU   DEBUG+3
DEBUG30  EQU   DEBUG+3
DEBUG29  EQU   DEBUG+3
DEBUG28  EQU   DEBUG+3
DEBUG27  EQU   DEBUG+3
DEBUG26  EQU   DEBUG+3
DEBUG25  EQU   DEBUG+3
DEBUG24  EQU   DEBUG+3
DEBUG23  EQU   DEBUG+2
DEBUG22  EQU   DEBUG+2
DEBUG21  EQU   DEBUG+2
DEBUG20  EQU   DEBUG+2
DEBUG19  EQU   DEBUG+2
DEBUG18  EQU   DEBUG+2
DEBUG17  EQU   DEBUG+2
DEBUG16  EQU   DEBUG+2
DEBUG15  EQU   DEBUG+1
DEBUG14  EQU   DEBUG+1
DEBUG13  EQU   DEBUG+1
DEBUG12  EQU   DEBUG+1
DEBUG11  EQU   DEBUG+1
DEBUG10  EQU   DEBUG+1
DEBUG9   EQU   DEBUG+1
DEBUG8   EQU   DEBUG+1
DEBUG7   EQU   DEBUG
DEBUG6   EQU   DEBUG
DEBUG5   EQU   DEBUG
DEBUG4   EQU   DEBUG
DEBUG3   EQU   DEBUG
DEBUG2   EQU   DEBUG
DEBUG1   EQU   DEBUG
DEBUG0   EQU   DEBUG
SORTBRK  EQU   SWITCHES+1
COREFAIL EQU   SWITCHES+1
ANALYSIS EQU   SWITCHES+1
SHIFT3RD EQU   SWITCHES+1
DEVEXCL  EQU   SWITCHES+1
ZEROALL  EQU   SWITCHES+1
NOTALL   EQU   SWITCHES+1
NOSDR    EQU   SWITCHES
TIMESEQ  EQU   SWITCHES
SYSUM    EQU   SWITCHES
PARMTHR  EQU   SWITCHES
TREND    EQU   SWITCHES
SHORTOBR EQU   SWITCHES
PARMMES  EQU   SWITCHES
RDESUM   EQU   SWITCHES
PCCHFRAM EQU   RECTYPE+1
PMCHFRAM EQU   RECTYPE+1
PTTYP    EQU   RECTYPE+1
PEOD     EQU   RECTYPE
PMIH     EQU   RECTYPE
PDDR     EQU   RECTYPE
PIPL     EQU   RECTYPE
PSOFT    EQU   RECTYPE
POBR     EQU   RECTYPE
PCHAN    EQU   RECTYPE
PMCH     EQU   RECTYPE
@NM00037 EQU   NEWBUF
@NM00035 EQU   BEHDR+4
@NM00034 EQU   BFLGS+1
DATAP    EQU   BFLGS+1
@NM00033 EQU   BFLGS
WRITE    EQU   BFLGS
LOG      EQU   BFLGS
LRBCMPCS EQU   LRBCMP+2
LRBCMPPA EQU   LRBCMP
LRBCMPNO EQU   LRBCVAR+6
LRBCMPF2 EQU   LRBCVAR+5
LRBCMPF1 EQU   LRBCVAR+4
LRBCRESD EQU   LRBCVAR+2
LRBCFT   EQU   LRBCVAR
LRBHMCEL EQU   LRBHCPID+6
LRBHMDL  EQU   LRBHCPID+4
LRBHCSER EQU   LRBHCPID+1
@NM00006 EQU   LRBHCPID
@NM00005 EQU   LRB+7
LRBHCNT  EQU   LRB+6
LRBMCLB  EQU   LRBHSW3
LRBNDEM  EQU   LRBMACT
LRBNCEM  EQU   LRBMACT
@NM00004 EQU   LRBHSW0
@NM00003 EQU   LRBHSW0
LRBHMORE EQU   LRBHSW0
@NM00002 EQU   LRBHSYS
LRBHSYSB EQU   LRBHSYS
LRBHTYPE EQU   LRB
ADPLEXT  EQU   ABDPL+52
ADPLFMT2 EQU   ABDPL+48
ADPLFMT1 EQU   ABDPL+44
ADPLCOM4 EQU   ABDPL+40
ADPLCOM3 EQU   ABDPL+36
ADPLCOM2 EQU   ABDPL+32
ADPLCOM1 EQU   ABDPL+28
ADPLFRMT EQU   ABDPL+24
ADPLMEMA EQU   ABDPL+20
ADPLCVT  EQU   ABDPL+16
@NM00001 EQU   ADPLFLAG
ADPLSYTM EQU   ADPLFLAG
ADPLSNPR EQU   ADPLFLAG
ADPLSBPL EQU   ABDPL+6
ADPLASID EQU   ABDPL+4
ADPLTCB  EQU   ABDPL
.@UNREFD ANOP                          END UNREFERENCED COMPONENTS
@RC00157 EQU   @EL00003
@PB00003 EQU   @EL00002
@RT00163 EQU   @RC00157
@ENDDATA EQU   *
         END   IFCFMTIO,(C'PLS0222',0702,79011)
