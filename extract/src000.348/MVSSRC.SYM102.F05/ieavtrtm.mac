         TITLE 'IEAVTRTM, RTM1 MAINLINE'
IEAVTRTM CSECT ,                                                   0001
@MAINENT DS    0H                                                  0001
         USING *,@15                                               0001
         B     @PROLOG                                             0001
         DC    AL1(16)                                             0001
         DC    C'IEAVTRTM  78.080'                                 0001
         DROP  @15
@PROLOG  BALR  @09,0                                               0001
@PSTART  LA    @11,4095(,@09)                                      0001
         USING @PSTART,@09                                         0001
         USING @PSTART+4095,@11                                    0001
RBPRFXLN EQU 64
RBPRFLNA EQU 32
PRBLEN   EQU 136
SIRBLEN  EQU 200
TIRBLEN  EQU 136
IRBLEN   EQU 128
SVRBLEN  EQU 224
*                                      /*GEN EXTERNAL LABEL  @G17EP5W*/
RTMSTART  EQU @PSTART               LABEL ON 1ST EXECUTABLE  @G17EP5W
          ENTRY RTMSTART         INSTRUCTION OF RTM TO ALLOW @G17EP5W
*                                   /* OTHER MODULES TO RESTORE THE
*                                      VALUE OF RTM'S BASE REG     0079
*                                                            @G17EP5W*/
*                                                                  0079
*   /*****************************************************************/
*   /*                                                               */
*   /* IF ENTRY IS FROM ACR OR MCH THEN RTM MUST REPAIR AND OR RECORD*/
*   /* THE HARDWARE FAILURE                                          */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0079
*   IF R0=RT1WMACH THEN             /* IF MCH OR ACR IS CALLER       */
         CH    R0,@CH00435                                         0079
         BNE   @RF00079                                            0079
*     DO;                           /*                       @G17EP5W*/
*       CALL IEAVTRTH;              /* PERFORM REPAIR FUNCTION       */
         L     @15,@CV00156                                        0081
         BALR  @14,@15                                             0081
*       GEN(LA R11,4095(R9));       /* RESTORE BASE REG      @G17EP5W*/
         LA R11,4095(R9)
*     END;                          /*                       @G17EP5W*/
*                                                                  0083
*   /*****************************************************************/
*   /*                                                               */
*   /* IF ENTRY WAS NOT FROM MCH OR ACR, THEN SOFTWARE PROCESSING    */
*   /* MUST BE PERFORMED.                                            */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0084
*   ELSE                            /* IF MCH IS NOT THE CALLER      */
*     DO;                           /* PERFORM SOFTWARE PROCESSING   */
*                                                                  0084
         B     @RC00079                                            0084
@RF00079 DS    0H                                                  0085
*       /*************************************************************/
*       /*                                                           */
*       /* IF ENTRY WAS FROM AN ERROR DETECTING INTERRUPT HANDLER    */
*       /* I.E. PCFLIH, RESTART FLIH, SVC FLIH OR MCH (WHEN SOFTWARE */
*       /* DAMAGE WAS SUSTAINED) THEN THE RTM1 MUST PROCESS THE      */
*       /* INTERRUPT (SLIH MODE)                                     */
*       /*                                                           */
*       /*************************************************************/
*                                                                  0085
*       IF R0>=SLIHLOW&             /* IF RTM1 IS OPERATING AS A     */
*           R0<=SLIHHI              /* 2ND LEVEL INTERRUPT HANDLER   */
*         THEN                                                     0085
         CH    R0,@CH00073                                         0085
         BL    @RF00085                                            0085
         CH    R0,@CH00032                                         0085
         BH    @RF00085                                            0085
*         DO;                       /* DO INTERRUPT PROCESSING       */
*                                                                  0086
*           /*********************************************************/
*           /*                                                       */
*           /* THE FUNCTION OF THE REFRESH SEGMENT IS TO REFRESH     */
*           /* CRITICAL COMMON FIXED CONSTANTS WHENEVER RTM SOFTWARE */
*           /* PROCESSING IS TO BE PERFORMED. IT RECEIVES NO INPUT   */
*           /* AND PROVIDES NO OUTPUT TO SUCCEEDING SEGMENTS OF THE  */
*           /* RTM1. IT SHOULD BE NOTED THAT NO RECOVERY OF THE      */
*           /* ORIGINAL ERROR IS POSSIBLE IF A SECOND ERROR OCCURS   */
*           /* DURING THE PROCESSING OF THIS SEGMENT. IF THIS        */
*           /* HAPPENS, ALL THE INFORMATION ABOUT THE ORIGINAL ERROR */
*           /* IS SIMPLY LOST.                                       */
*           /*                                                       */
*           /*********************************************************/
*                                                                  0087
*           DO;                     /* START OF REFRESH SEGMENT      */
*             R7=PSACSTK;           /* HAND OPTIMIZE CODE            */
         L     R7,PSACSTK                                          0088
*             RFY                                                  0089
*               FRRS BASED(R7);     /* BY ELIMINATING LOADS FROM   0089
*                                      PSACSTK                       */
*             IF PSALCR='0'B THEN   /* IF RTM WAS NOT IN THE PROCESS
*                                      OF REFRESHING LOW CORE WHEN 0090
*                                      THE ERROR OCCURRED            */
         TM    PSALCR,B'00000001'                                  0090
         BNZ   @RF00090                                            0090
*               DO;                 /* THEN REFRESH LOW CORE         */
*                 PSALCR='1'B;      /* INDICATE RTM IS IN PROCESS OF
*                                      REFRESHING LOW CORE           */
         OI    PSALCR,B'00000001'                                  0092
*                 CALL IEAVELCR;    /* CALL THE LOW CORE REFRESH   0093
*                                      ROUTINE                       */
         L     @15,@CV00153                                        0093
         BALR  @14,@15                                             0093
*                 GEN(LA R11,4095(R9));/* RESTORE BASE REG   @G17EP5W*/
         LA R11,4095(R9)
*                 RFY                                              0095
*                  (R8,                                            0095
*                   R10) RSTD;      /* GET REGS FOR RESTART CS       */
*                 R8=(PSACPULA*65536)×RTMRSTID;/* PLACE RTM'S LOCK 0096
*                                      WORD IN REG                   */
         LH    R8,PSACPULA                                         0096
         SLA   R8,16                                               0096
         O     R8,RTMRSTID                                         0096
*                 R10=NULL;         /* PLACE FREE INDICATOR IN REG   */
         SLR   R10,R10                                             0097
*                 CS(R10,R8,CVTRSTWD);/* COMPARE RESTART RESOURCE  0098
*                                      WORD IN CVT WITH FREE       0098
*                                      INDICATOR. IF LOCK IS FREE, 0098
*                                      RTM'S LOCK WORD IS PLACED IN
*                                      IT. OTHERWISE, CURRENT LOCKED
*                                      VALUE IS PLACED IN RSTRTFRE 0098
*                                      (R10) REG.                    */
         L     @12,CVTPTR                                          0098
         CS    R10,@08,CVTRSTWD(@12)                               0098
*                 IF R10=NULL THEN  /* IF RSTRTFRE (R10) STILL HOLDS
*                                      THE FREE INDICATOR-I.E. RTM 0099
*                                      JUST ACQUIRED THE RSTRT LOCK  */
         LTR   R10,R10                                             0099
         BNZ   @RF00099                                            0099
*                   DO;             /* THEN RTM CAN REFRESH THE    0100
*                                      RESTART NEW PSW               */
*                     FLCRNPSW=RESNPSW;/* REFRESH THE RESTART NEW PSW*/
         MVC   FLCRNPSW(8),RESNPSW                                 0101
*                     CVTRSTWD=R10; /* FREE THE RESTART RESOURCE     */
         L     @12,CVTPTR                                          0102
         ST    R10,CVTRSTWD(,@12)                                  0102
*                   END;            /* END OF RESTART PSW REFRESH    */
*                 RFY                                              0104
*                  (R8,                                            0104
*                   R10) UNRSTD;    /* RELEASE REGS USED IN CS       */
@RF00099 DS    0H                                                  0105
*               END;                /* LOW CORE REFRESH COMPLETE     */
*             PSALCR='0'B;          /* INDICATE LOW CORE REFRESH IS
*                                      EITHER COMPLETE OR NOT DONE   */
@RF00090 NI    PSALCR,B'11111110'                                  0106
*           END;                    /* END OF REFRESH SEGMENT        */
*                                                                  0107
*           /*********************************************************/
*           /*                                                       */
*           /* THE FUNCTION OF THE RECURSE SEGMENT IS TO DETECT IF AN*/
*           /* UNANTICIPATED RECURSION INTO RTM1 HAS OCCURRED. IF SO,*/
*           /* RECOVERY ROUTINE OR ABORT PROCESSING TAKES PLACE. IF  */
*           /* NOT, A CHECK IS MADE FOR ANTICIPATED RECURSION. IF SO,*/
*           /* RESOURCES ACQUIRED PRIOR TO THIS RECURSIVE ENTRY WHICH*/
*           /* ARE NO LONGER NEEDED ARE FREED AND PART OF THE RTM1WA */
*           /* IS ZEROED. THE RTM1WA IS INITIALIZED. IF A SECOND     */
*           /* ERROR OCCURS WHILE RTM IS IN THIS SEGMENT PROCESSING  */
*           /* THE ORIGINAL ERROR, ONLY VERY LIMITED RECOVERY IS     */
*           /* POSSIBLE (SEE COMMENT BELOW). ALL THE INFORMATION     */
*           /* CONCERNING THE ORIGINAL ERROR IS LOST, AND RTM WILL   */
*           /* PROCESS THE SECOND ERROR. THE INPUT TO THIS SEGMENT IS*/
*           /* THE RTM1WA ADDRESSED BY THE CURRENT RSVT ENTRY IN THE */
*           /* PSA. THE FOLLOWING REGISTERS ALSO CONTAIN INPUT -     */
*           /* FUNCTION REGISTER (R0) - IT IS CHECK POINTED INTO THE */
*           /* WA, ADDRPSW1 REGISTER (R2) AND ADDRPSW2 REGISTER (R3) */
*           /* - ALSO CHECKPOINTED INTO THE WA. OUTPUT IS AN         */
*           /* INITIALIZED RTM1WA. IF RECOVERY IS REQUIRED THIS      */
*           /* SEGMENT WILL NOT RETURN CONTROL TO THE CALLING SEGMENT*/
*           /* BUT WILL GO UNCONDITIONALLY TO RECOVERY ROUTINES.     */
*           /*                                                       */
*           /*********************************************************/
*                                                                  0108
*           DO;                     /* START OF RECURSE SEGMENT      */
*             RFY                                                  0109
*               R12 RSTD;           /* GET REG FOR PTR TO TRACKING 0109
*                                      AREA                          */
*             R12=ADDR(RT1WLPTA);   /* USE TRACKING AREA IN RTM1WA   */
         LA    R12,RT1WLPTA(,R7)                                   0110
*             RFY                                                  0111
*               RT1TRACK BASED(R12);/* USE TRACKING AREA IN THE    0111
*                                      RTM1WA FOR RECURSION CK       */
*                                                                  0111
*             /*******************************************************/
*             /*                                                     */
*             /* PROCESS NON-ERROR CONDITIONS                        */
*             /*                                                     */
*             /*******************************************************/
*                                                                  0112
*             IF RT1TLPN=NULL×      /* IF RTM1 WAS NOT IN CONTROL    */
*                 RT1TLPN>=FRRRECUR THEN/* OR IF RECURSION WAS     0112
*                                      ANTICPTD (EITHER RTM MGR WAS
*                                      IN EXIT OR RESCHEDULE PHASE,
*                                      OR FRR WAS IN CONTROL)      0112
*                                                            @ZA20321*/
         CLI   RT1TLPN(R12),0                                      0112
         BE    @RT00112                                            0112
         CLI   RT1TLPN(R12),254                                    0112
         BL    @RF00112                                            0112
@RT00112 DS    0H                                                  0113
*               DO;                 /* THEN INITIALIZE THE WORKAREA  */
*                                                                  0113
*                 /***************************************************/
*                 /*                                                 */
*                 /* IF RTM1 WAS NOT IN CONTROL THEN ZERO THE ENTIRE */
*                 /* WA                                              */
*                 /*                                                 */
*                 /***************************************************/
*                                                                  0114
*                 IF RT1TLPN=NULL THEN/* IF NO LOGICAL PHASE SPECIFD */
         CLI   RT1TLPN(R12),0                                      0114
         BNE   @RF00114                                            0114
*                   RT1W=''B;       /* THEN ZERO THE WHOLE WORKAREA  */
*                                                                  0115
         XC    RT1W(68,R7),RT1W(R7)                                0115
*                 /***************************************************/
*                 /*                                                 */
*                 /* IF RTM1 WAS IN CONTROL BUT ANTICIPATES RECURSIVE*/
*                 /* ENTRIES-FREE UP ACQUIRED EEDS AND ZERO PART OF  */
*                 /* WA                                              */
*                 /*                                                 */
*                 /***************************************************/
*                                                                  0116
*                 ELSE              /* IF LOGICAL PHASE NUM NOT 0    */
*                   DO;                                            0116
         B     @RC00114                                            0116
@RF00114 DS    0H                                                  0117
*                     IF RT1WEED>EEDNULL THEN/* IF EEDS WERE       0117
*                                      PREVIOUSLY ACQUIRED AND NOT 0117
*                                      NEEDED                        */
         L     @10,RT1WEED(,R7)                                    0117
         CH    @10,@CH00073                                        0117
         BNH   @RF00117                                            0117
*                       DO;         /* FREE THESE EEDS               */
*                         RT1WPSW1=R6;/* SAVE PTR TO ENTRY EEDS    0119
*                                                            @G17EP5W*/
         ST    R6,RT1WPSW1(,R7)                                    0119
*                         R6=RT1WEED;/* PLACE PTR TO EEDS IN REG     */
         LR    R6,@10                                              0120
*                         RT1WEED=NULL;/* ZERO EED PTR IN WA - THIS
*                                      ACTION PROVIDES THE ONLY    0121
*                                      RECOVERY FOR THIS SEGMENT BY
*                                      INSURING THAT THIS SEGMENT  0121
*                                      WILL NOT BE REPEATED IF THE 0121
*                                      SECOND ERROR OCCURRED HERE    */
         SLR   @10,@10                                             0121
         ST    @10,RT1WEED(,R7)                                    0121
*                         RFY                                      0122
*                           R10 RSTD;/* GET CONTROL OF WORK REGISTER */
*                         R10=ADDR(RT1WVARI);/* POINT TO VARIABLE  0123
*                                      AREA                          */
         LA    R10,RT1WVARI(,R7)                                   0123
*                         GEN(STM R0,R4,0(R10));/* SAVE R0-R4 IN WA  */
         STM R0,R4,0(R10)
*                         CALL FREEDCEL;/* CALL ROUTINE TO FREE EEDS */
         L     @15,@CV00162                                        0125
         BALR  @14,@15                                             0125
*                         GEN(LA R11,4095(R9));/* RESTORE BASE REG 0126
*                                                            @G17EP5W*/
         LA R11,4095(R9)
*                         R6=RT1WPSW1;/* RESTORE PTR TO ENTRY EEDS   */
         L     R6,RT1WPSW1(,R7)                                    0127
*                         R10=ADDR(RT1WVARI);/* RESTORE PTR TO     0128
*                                      VARIABLE AREA                 */
         LA    R10,RT1WVARI(,R7)                                   0128
*                         GEN(LM R0,R4,0(R10));/* RESTORE REGISTERS  */
         LM R0,R4,0(R10)
*                         RFY                                      0130
*                           R10 UNRSTD;/* RELINQUISH CONTRL OF WORKRG*/
*                       END;        /* END OF EED PROCESSING         */
*                     RT1WLPN=RT1TLPN;/* SAVE INITIAL LOGICAL PHASE
*                                      NUMBER SO THAT SYSTEM RECOVERY
*                                      MGR CAN DETERMINE IF FRR WAS
*                                      IN CONTROL OR RTM MGR WAS IN
*                                      CONTROL IF ANTICIPATED      0132
*                                      RECURSION             @ZA20321*/
@RF00117 MVC   RT1WLPN(1,R7),RT1TLPN(R12)                          0132
*                     RT1WNPRS=''B; /* INITIALIZE SECTION OF WA WHICH
*                                      NEEDS NOT BE PRESERVED        */
         XC    RT1WNPRS(52,R7),RT1WNPRS(R7)                        0133
*                   END;            /* END UNIQUE VALID RECURSION  0134
*                                      PROCESSING                    */
*               END;                /* END NON-ERROR PROCESSING      */
*                                                                  0135
*             /*******************************************************/
*             /*                                                     */
*             /* PROCESS UNANTICIPATED RECURSION                     */
*             /*                                                     */
*             /*******************************************************/
*                                                                  0136
*             ELSE                                                 0136
*               DO;                 /* IF RTM WAS IN CONTROL WHEN THE
*                                      ERROR OCCURRED                */
         B     @RC00112                                            0136
@RF00112 DS    0H                                                  0137
*                 CALL RECVRRTM;    /* SEE IF RECOVERY IS POSSIBLE -
*                                      DEPENDENT ON WHERE IN RTM'S 0137
*                                      PROCESSING THE ERROR OCCRRED  */
         L     @15,@CV00161                                        0137
         BALR  @14,@15                                             0137
*                 GEN(LA R11,4095(R9));/* RESTORE BASE REG   @G17EP5W*/
         LA R11,4095(R9)
*               END;                /*                       @G17EP5W*/
*                                                                  0139
*             /*******************************************************/
*             /*                                                     */
*             /* ESTABLISH RECURSION CONTROL FOR THIS LOGICAL PHASE. */
*             /* THE RECOVERY ACTION OF RTM IF A SECOND ERROR OCCURS */
*             /* DURING PROCESSING OF THIS INITIAL PHASE IS CALLED   */
*             /* ABORT PROCESSING. THIS MEANS THAT RTM WILL SIMPLY   */
*             /* CLEAN UP AND EXIT.                                  */
*             /*                                                     */
*             /*******************************************************/
*                                                                  0140
*CWTRP:                             /* RETURN PT FROM LPRR IF THERE
*                                      IS ONLY CLEAN-UP TO BE      0140
*                                      PERFORMED IN CASE OF A      0140
*                                      RECURSIVE ERROR               */
*             GEN(LA R11,4095(R9)); /* RESTORE BASE REG      @G17EP5W*/
@RC00112 DS    0H                                                  0140
CWTRP    LA R11,4095(R9)
*             RT1TLPN=MGRINIT;      /* SET LPN FOR MANGR INITLZTION  */
         MVI   RT1TLPN(R12),X'01'                                  0141
*             RT1TENPT=R0;          /* CHECKPOINT ENTRY TYPE IN WA   */
         STC   R0,RT1TENPT(,R12)                                   0142
*             RT1WPSW1=R2;          /* CHCKPOINT 1ST PSW ADDR IN WA  */
         ST    R2,RT1WPSW1(,R7)                                    0143
*             RT1WPSW2=R3;          /* CHCKPOINT 2ND PSW ADDR IN WA  */
         ST    R3,RT1WPSW2(,R7)                                    0144
*             RT1WEED=R6;           /* EEDS MAY HAVE BEEN PASSED TO
*                                      RTM1 FOR SOFTWARE HANDLING OF
*                                      MACHINE CHECKS OR FOR ABEND 0145
*                                      PROCESSING FOR A PAGE IO    0145
*                                      ERROR. THIS EED CHAIN IS    0145
*                                      PRESERVED IN THE WA FOR     0145
*                                      SUBSEQUENT HANDLING BY RTM1   */
         ST    R6,RT1WEED(,R7)                                     0145
*           END;                    /* END OF RECURSE SEGMENT        */
*                                                                  0146
*           /*********************************************************/
*           /*                                                       */
*           /* THE PURPOSE OF THE SYSTATE SEGMENT IS TO CHECK THE    */
*           /* SYSTEM STATE INDICATORS IN THE PSA AND LCCA TO SEE IF */
*           /* THE SYSTEM WAS IN NORMAL TASK MODE OR SYSTEM MODE AT  */
*           /* THE TIME OF ERROR. INPUT IS THE LCCA, THE PSA, AND THE*/
*           /* POINTER TO THE PSW AT TIME OF ERROR IN A REGISTER.    */
*           /* OUTPUT IS AN UPDATED FIELD IN THE RTM1WA (RT1WMODE).  */
*           /* IF A SECOND ERROR OCCURS WHILE RTM IS IN THIS SEGMENT */
*           /* PROCESSING AN ERROR, NO ATTEMPT TO RECOVER THE        */
*           /* ORIGINAL ERROR CAN BE MADE. INSTEAD THE RECOVERY      */
*           /* HANDLER WILL SIMPLY CLEAN-UP AND EXIT.                */
*           /*                                                       */
*           /*********************************************************/
*                                                                  0147
*           DO;                     /* START OF SYSTATE SEGMENT      */
*                                                                  0147
*             /*******************************************************/
*             /*                                                     */
*             /* THE FOLLOWING CODE WAS MOVED HERE FROM THE REFRESH  */
*             /* SEGMENT. OLD FLAGS WERE: @Z40FPXH,@ZA11378,@G17EP5W */
*             /*                                             @ZA20555*/
*             /*                                                     */
*             /*******************************************************/
*                                                                  0148
*             RFY                                                  0148
*               TCB BASED(PSATOLD); /* TCB ADDRESSABILITY    @ZA20555*/
*             IF R0^=RT1WDAT&       /* IF NOT A DATERR AND   @ZA20555*/
*                 LCCAASID=NULL&    /* NOT TRAS MODE AND     @ZA20555*/
*                 PSATOLD^=NULL&    /* TCB PTR OK AND        @ZA20555*/
*                 PSATOLD->TCBTCBID=TCBIDENT THEN/* TCBID OK THEN  0149
*                                                            @ZA20555*/
         CH    R0,@CH00134                                         0149
         BE    @RF00149                                            0149
         SLR   @10,@10                                             0149
         L     @08,PSALCCAV                                        0149
         CL    @10,LCCAASID(,@08)                                  0149
         BNE   @RF00149                                            0149
         L     @08,PSATOLD                                         0149
         CR    @08,@10                                             0149
         BE    @RF00149                                            0149
         CLC   TCBTCBID(4,@08),@CC00201                            0149
         BNE   @RF00149                                            0149
*               DO;                 /* TCB CAN BE REF'D, SO  @ZA20555*/
*                 TCBNONPR='0'B;    /* MAKE TCB PREEMPTIVE   @ZA20555*/
         NI    TCBNONPR(@08),B'11101111'                           0151
*                 CALL ESTAECHK;    /* SEE IF ESTAE ACTIVE   @ZA20555*/
         L     @15,@CV00154                                        0152
         BALR  @14,@15                                             0152
*                 GEN(LA R11,4095(R9));/* RESTORE BASE REG   @ZA20555*/
         LA R11,4095(R9)
*               END;                /*                       @ZA20555*/
*             ELSE                                                 0155
*               ;                   /*                       @ZA20555*/
@RF00149 DS    0H                                                  0156
*             RFY                                                  0156
*               R10 RSTD;           /* GET REG FOR PTR TO MODE BYTE  */
*             R10=ADDR(RT1WMODE);   /* USE MODE BYTE IN RTM1WA       */
         LA    R10,RT1WMODE(,R7)                                   0157
*             RFY                                                  0158
*               MODEBYTE BASED(R10);/* USE RTM1WA FOR MODE INDICATOR
*                                      SETTINGS                      */
*             IF PSWIO='0'B&        /* IF PSW WAS DISABLED FOR IO    */
*                 PSWEXT='0'B THEN  /* AND PSW WAS DISABLED FOR EXT  */
         TM    PSWIO(R2),B'00000011'                               0159
         BNZ   @RF00159                                            0159
*               MODEDIS='1'B;       /* THEN TURN ON DISABLED BIT     */
         OI    MODEDIS(R10),B'01000000'                            0160
*             IF PSASUPER^=NULL THEN/* IF A SUPER ROUTINE WAS IN   0161
*                                      CONTROL                       */
@RF00159 ICM   @08,15,PSASUPER                                     0161
         BZ    @RF00161                                            0161
*               MODESUPR='1'B;      /* THEN INDICATE SUPER MODE      */
         OI    MODESUPR(R10),B'10000000'                           0162
*             RFY                                                  0163
*               R8 RSTD;            /* GET REG FOR SETLOCK TEST      */
@RF00161 DS    0H                                                  0164
*             RFY                                                  0164
*               R15 RSTD;           /* GET REG FOR SETLOCK TEST RC   */
*             GEN(SETLOCK TEST,TYPE=SPIN,REGS=(R8));/* TEST IF ANY 0165
*                                      SPIN LOCKS ARE HELD           */
         SETLOCK TEST,TYPE=SPIN,REGS=(R8)
*             GEN(LA R11,4095(R9)); /* RESTORE BASE REG      @G17EP5W*/
         LA R11,4095(R9)
*             IF R15=TSTLKHEL THEN  /* IF ANY SPIN LOCKS ARE HELD    */
         LTR   R15,R15                                             0167
         BNZ   @RF00167                                            0167
*               MODEGSPN='1'B;      /* INDICATE GLOBAL SPIN MODE     */
         OI    MODEGSPN(R10),B'00100000'                           0168
*             RFY                                                  0169
*               R8 UNRSTD;          /* RELEASE SETLOCK TEST REG      */
@RF00167 DS    0H                                                  0170
*             GEN(SETLOCK TEST,TYPE=CMS);/* TEST IF THE CMS LOCK IS
*                                      HELD                          */
         SETLOCK TEST,TYPE=CMS
*             GEN(LA R11,4095(R9)); /* RESTORE BASE REG      @G17EP5W*/
         LA R11,4095(R9)
*             IF R15=TSTLKHEL THEN  /* IF THE CMS LOCK IS HELD       */
         LTR   R15,R15                                             0172
         BNZ   @RF00172                                            0172
*               MODEGSUS='1'B;      /* INDICATE GLOBAL SUSPEND MODE  */
         OI    MODEGSUS(R10),B'00010000'                           0173
*             GEN(SETLOCK TEST,TYPE=LOCAL);/* TEST IF THE LOCAL LOCK
*                                      IS HELD                       */
@RF00172 DS    0H                                                  0174
         SETLOCK TEST,TYPE=LOCAL
*             GEN(LA R11,4095(R9)); /* RESTORE BASE REG      @G17EP5W*/
         LA R11,4095(R9)
*             IF R15=TSTLKHEL THEN  /* IF THE LOCAL LOCK IS HELD     */
         LTR   R15,R15                                             0176
         BNZ   @RF00176                                            0176
*               DO;                 /* CHECK FOR TYPE 1 SVC ONLY IF
*                                      LOCAL LOCK HELD ON THIS CPU.
*                                      (OTHERWISE TYPE 1 SVC IS    0177
*                                      RUNNING ON OTHER CPU.)        */
*                 MODELOC='1'B;     /* INDICATE LOCAL MODE           */
         OI    MODELOC(R10),B'00001000'                            0178
*                 IF ASCBTYP1='1'B THEN/* IF TYPE 1 SVC SWITCH IS ON */
         L     @14,PSAAOLD                                         0179
         TM    ASCBTYP1(@14),B'00000010'                           0179
         BNO   @RF00179                                            0179
*                   MODETYP1='1'B;  /* INDICATE TYPE 1 MODE          */
         OI    MODETYP1(R10),B'00000100'                           0180
*               END;                /* END LOCAL LOCK PROCESSING     */
@RF00179 DS    0H                                                  0182
*             RFY                                                  0182
*               R15 UNRSTD;         /* RELEASE SETLOCK TEST REG      */
@RF00176 DS    0H                                                  0183
*             IF LCCASRBM='1'B THEN /* IF CPU IS IN SRB MODE THEN  0183
*                                                            @YM01836*/
         L     @08,PSALCCAV                                        0183
         TM    LCCASRBM(@08),B'10000000'                           0183
         BNO   @RF00183                                            0183
*               MODESRB='1'B;       /* INDICATE SRB MODE             */
         OI    MODESRB(R10),B'00000010'                            0184
*             IF MODEBYTE=NULL THEN /* IF NO SYSTEM MODE INDICATOR 0185
*                                      WAS SET ABOVE THEN            */
@RF00183 CLI   MODEBYTE(R10),0                                     0185
         BNE   @RF00185                                            0185
*               MODETCB='1'B;       /* INDICATE TASK MODE            */
         OI    MODETCB(R10),B'00000001'                            0186
*             IF R0=RT1WDAT THEN    /* IF AN UNRECOVERABLE         0187
*                                      TRANSLATION FAILURE OCCURED   */
@RF00185 CH    R0,@CH00134                                         0187
         BNE   @RF00187                                            0187
*               DO;                                                0188
*                 MODETCB='0'B;     /* INSURE THAT SUBSEQUENT STEPS
*                                      DO NOT CONSIDER THIS A TASK 0189
*                                      ERROR                         */
*                 MODEDIS='1'B;     /* CAUSE SRM TO USE GLOBAL WORK
*                                      AREAS                         */
         OI    MODEDIS(R10),B'01000000'                            0190
         NI    MODETCB(R10),B'11111110'                            0190
*               END;                /* END DAT PROCESSING            */
*             RFY                                                  0192
*               R10 UNRSTD;         /* RELEASE REG POINTING TO MODE
*                                      BYTE                          */
@RF00187 DS    0H                                                  0193
*             RFY                                                  0193
*               MODEBYTE BASED(ADDR(RT1WMODE));/* USE DCL BASE FOR 0193
*                                      MODE BYTE                     */
*           END;                    /* END OF SYSTATE SEGMENT        */
*                                                                  0194
*           /*********************************************************/
*           /*                                                       */
*           /* IF THE SYSTEM WAS NOT IN TASK MODE AT THE TIME OF     */
*           /* ERROR THEN PERFORM SYSTEM RECOVERY                    */
*           /*                                                       */
*           /*********************************************************/
*                                                                  0195
*           IF(MODEBYTE&SYSMODE)^=NULL THEN/* IF SYSTEM MODE         */
*                                                                  0195
         LA    @10,254                                             0195
         SLR   @08,@08                                             0195
         IC    @08,MODEBYTE+80(,R7)                                0195
         NR    @10,@08                                             0195
         LTR   @10,@10                                             0195
         BZ    @RF00195                                            0195
*             /*******************************************************/
*             /*                                                     */
*             /* THE PURPOSE OF THE SYSRCVR SEGMENT IS TO INTERFACE  */
*             /* WITH THE SYSTEM RECOVERY MANAGER, IEAVTRTS, TO ALLOW*/
*             /* RECORDING OF A SYSTEM ERROR TO OCCUR ON SYS1.LOGREC */
*             /* AND TO INVOKE ANY FRRS AVAILABLE TO HANDLE THE      */
*             /* ERROR. THIS SEGMENT ALSO ANALYZES THE RETURN        */
*             /* INFORMATION FROM THE SRM, CONTAINED IN THE RTCA     */
*             /* (IHASDWA) TO DETERMINE THE NEXT APPROPRIATE ACTION  */
*             /* IN THE HANDLING OF THE ERROR - I.E. TO RESCHEDULE   */
*             /* ANOTHER ENTRY INTO THE RTM TO CONTINUE ERROR        */
*             /* PROCESSING, TO ALLOW THE PROGRAM WHICH SUFFERED THE */
*             /* ERROR TO RESUME OR RETRY, OR TO SIMPLY IGNORE THE   */
*             /* ERROR AND GO TO THE DISPATCHER. INPUT TO THIS MODULE*/
*             /* IS AS FOLLOWS: FUNCTION REGISTER (R0) - CONTAINS    */
*             /* INDICATION OF THE TYPE OF ERROR WHICH CAUSED ENTRY  */
*             /* INTO THE RTM1. FLAGSCC REGISTER (R1) - CONTAINS THE */
*             /* CALLRTM FLAGS AND COMPLETION CODE. RECVSTAK REGISTER*/
*             /* (R4) - POINTS TO A RECOVERY STACK WHICH MAY BE USED */
*             /* FOR SETFRRS ISSUED DURING SRMS PROCESSING. DUMPOPTS */
*             /* (R5) CONTAINS A POINTER TO USER SPECIFIED DUMP      */
*             /* OPTIONS IF THE ERROR CAUSING ENTRY TO THE RTM1 WAS  */
*             /* AN ABEND INSTRUCTION. REPAIRAD REGISTER OR REPRDATA */
*             /* REGISTER (R5) - CONTAINS THE ADDRESS OF HARDWARE    */
*             /* REPAIR INFORMATION, IF THE EEDCHAIN REGISTER IS NON */
*             /* ZERO (I.E. HARDWARE REAPAIR DATA CAN ONLY BE PASSED */
*             /* IF EEDS WERE OBTAINED.) OTHERWISE, THIS REGISTER    */
*             /* CONTAINS ABBREVIATED HARDWARE REPAIR DATA, IF EED   */
*             /* REGISTER IS ZERO AND A MACHINE CHECK REENTRY        */
*             /* FUNCTION IS BEING PROCESSED. SAVAREAP REGISTER (R13)*/
*             /* - CONTAINS A POINTER TO THE GENERAL PURPOSE         */
*             /* REGISTERS AT TIME OF ERROR. AFTER CALLING IEAVTRTS, */
*             /* IT IS ASSUMED THAT THE INPUT REGISTERS ARE          */
*             /* DESTROYED, AND THEIR ORIGINAL CONTENTS CAN BE BE    */
*             /* FOUND IN THE RTM1WA AND RTCA. THE OUTPUT FROM THE   */
*             /* SYSRCVR SEGMENT IS AS FOLLOWS: FUNCTION REGISTER    */
*             /* (R0) - IS SET TO CAUSE EITHER A A RESCHEDULE        */
*             /* FUNCTION TO GET CONTROL, OR IS SET WITH THE ORIGINAL*/
*             /* ENTRY POINT FUNCTION VALUE, TO CAUSE THE RESCHED    */
*             /* FUNCTION TO BE BYPASSED, AND TO PROVIDE INPUT TO THE*/
*             /* EXIT FUNCTION. FLAGSCC REGISTER (R1) - IS           */
*             /* REESTABLISHED TO CONTAIN THE COMPLETION CODE (WHICH */
*             /* MAY HAVE BEEN ADJUSTED BY AN FRR). EEDCHAIN REGISTER*/
*             /* (R6) - WILL CONTAIN A POINTER TO ANY EEDS WHICH HAVE*/
*             /* BEEN ACCUMULATED. IF THE EXIT FUNCTION GETS CONTROL */
*             /* NEXT, IT WILL FREE THESE EEDS. TRAKAREA REGISTER    */
*             /* (R4) - IS SET TO POINT TO THE TRACKING AREA IN THE  */
*             /* CURRENT RTM1WA. ADDITIONAL OUTPUT IS DOCUMENTED IN  */
*             /* THE COMMENTARY TO NESTED SEGMENTS OF THE SYSRCVR    */
*             /* SEGMENT.                                            */
*             /*                                                     */
*             /*******************************************************/
*                                                                  0196
*             DO;                   /* START OF SYSRCVR SEGMENT      */
*               CALL IEAVTRTS;      /* CALL SYSTEM RECOVERY MGR      */
         L     @15,@CV00155                                        0197
         BALR  @14,@15                                             0197
*               GEN(LA R11,4095(R9));/* RESTORE BASE REG     @G17EP5W*/
         LA R11,4095(R9)
*               R7=PSACSTK;         /* REESTABLISH REGISTER        0199
*                                      OPTIMIZATION                  */
         L     R7,PSACSTK                                          0199
*               R12=ADDR(RT1WLPTA); /* REESTABLISH REG OPTIMIZATION  */
         LA    R12,RT1WLPTA(,R7)                                   0200
*               RT1TLPID=RECOVRY1;  /* INDICATE SOME RECOVERY IS   0201
*                                      POSSIBLE IF ERROR OCCURS IN 0201
*                                      THIS SEGMENT                  */
         MVI   RT1TLPID(R12),X'01'                                 0201
*POSTSRRP:                          /* RETURN POINT FROM LPRR IF   0202
*                                      ERROR OCCURS                  */
*               GEN(LA R11,4095(R9));/* RESTORE BASE REG     @G17EP5W*/
POSTSRRP LA R11,4095(R9)
*               RT1TLPN=POSTRTS;    /* LPN=PHASE NUM FOR COMPLETION
*                                      OF SYSTEM RECOVERY PROCESSNG  */
         MVI   RT1TLPN(R12),X'02'                                  0203
*               R0=RT1TENPT;        /* REESTABLISH THE ORIGINAL    0204
*                                      FUNCTION ENTYPOINT ID         */
         SLR   R0,R0                                               0204
         IC    R0,RT1TENPT(,R12)                                   0204
*               R1=SDWAABCC;        /* REESTABLISH THE COMP CODE     */
         L     @10,RT1WRTCA(,R7)                                   0205
         L     R1,SDWAABCC(,@10)                                   0205
*               RT1WPSW1=ADDR(SDWAEC1);/* REESTABLISH PTR TO 1ST HALF
*                                      OF PSW FROM THE TIME OF ERROR
*                                      (NOW IN SDWA RATHER THAN LOW
*                                      CORE)                 @YM05118*/
         LA    @08,SDWAEC1(,@10)                                   0206
         ST    @08,RT1WPSW1(,R7)                                   0206
*               RT1WPSW2=ADDR(SDWAAEC1);/* REESTABLISH PTR TO 2ND  0207
*                                      HALF OF PSW FROM THE TIME OF
*                                      ERROR (AGAIN IN SDWA) @YM05118*/
         LA    @08,SDWAAEC1(,@10)                                  0207
         ST    @08,RT1WPSW2(,R7)                                   0207
*               R6=RT1WEED;         /* POINT TO ANY EEDS ACQUIRED  0208
*                                      THUS FAR . THIS WILL CAUSE AN
*                                      AUTOMATIC FREEING OF THESE  0208
*                                      CELLS IF IT IS SUBSEQUENTLY 0208
*                                      DETERMINED THAT FURTHER RTM 0208
*                                      HANDLING OF THIS ERROR IS NOT
*                                      TO BE PERFORMED (THEREBY    0208
*                                      OBVIATING THE NEED FOR EEDS)
*                                      OR, THIS WILL PROVIDE INPUT TO
*                                      THE EEDPROC SEGMENT IF EEDS 0208
*                                      ARE TO BE PROCESSED           */
         L     R6,RT1WEED(,R7)                                     0208
*               R4=ADDR(RT1WLPTA);  /* PRIME TRACKING AREA PTR TO  0209
*                                      POINT TO THE TRACK AREA IN THE
*                                      RTM1WA                        */
         LA    R4,RT1WLPTA(,R7)                                    0209
*               RFY                                                0210
*                 RT1TRACK BASED(R4);                              0210
*               IF SDWASPIN='1'B THEN/* IF AN FRR HAS INDICATED IT IS
*                                      VALIDLY SPINNING THEN         */
         TM    SDWASPIN(@10),B'00100000'                           0211
         BNO   @RF00211                                            0211
*                 R0=RSCHDCPU;      /* CAUSE THE RTM PROCESSING TO 0212
*                                      OCCUR ON THE CPU WHICH HOLDS
*                                      THE RESOURCE UPON WHICH THE 0212
*                                      CURRENT CPU IS SPINNING       */
         LA    R0,17                                               0212
*               ELSE                /* OTHERWISE, IF NOT A VALID SPIN
*                                      FUNCTION THEN SET UP FOR    0213
*                                      NONSPIN PROCESSNG             */
*                 IF SDWARCDE^=SDWARETY THEN/* IF RETRY WAS NOT    0213
*                                      REQUESTED                     */
         B     @RC00211                                            0213
@RF00211 L     @10,RT1WRTCA(,R7)                                   0213
         CLI   SDWARCDE(@10),4                                     0213
         BE    @RF00213                                            0213
*                   DO;             /* PROCESS PERCOLATION           */
*                     IF R0=RT1WDAT THEN/* IF AN UNRECOVERABLE     0215
*                                      TRANSLATION FAILURE OCCURRED  */
*                                                                  0215
         CH    R0,@CH00134                                         0215
         BNE   @RF00215                                            0215
*                       /*********************************************/
*                       /*                                           */
*                       /* THE PURPOSE OF THE DATPERC SEGMENT IS TO  */
*                       /* ESTABLISH A MEMTERM INTERFACE FOR THE     */
*                       /* RESCHEDULE FUNCTION TO CAUSE AN ADDRESS   */
*                       /* SPACE WHICH HAS SUFFERED UNRECOVERABLE    */
*                       /* TRANSLATION FAILURES TO BE TERMINATED. IN */
*                       /* ADDITION, DATA AREAS USED BY THE          */
*                       /* DISPATCHER ARE ADJUSTED TO PREVENT IT FROM*/
*                       /* ATTEMPTING TO REFERENCE ANY PRIVATE AREAS */
*                       /* IN THE FAILING ADDRESS SPACE. INPUT TO THE*/
*                       /* DATPERC SEGMENT IS THE RTM1WA, THE PSA,   */
*                       /* AND THE ASCB. OUTPUT IS AN UPDATED        */
*                       /* FUNCTION REGISTER (R0) AND UPDATED        */
*                       /* TARGASID REGISTER (R2).                   */
*                       /*                                           */
*                       /*********************************************/
*                                                                  0216
*                       DO;         /* PERFORM DATERR PERCOLATION    */
*                         RT1TLPID=NULL;/* INDICATE RECOVERY OF    0217
*                                      ORIGINAL ERROR IS NOT POSSIBLE
*                                      IF A SECOND ERROR OCCURS WHILE
*                                      RTM IS PROCESSING IN THIS   0217
*                                      SEGMENT                       */
         MVI   RT1TLPID(R4),X'00'                                  0217
*                         RFY                                      0218
*                           R12 RSTD;/* DESTROYED BY SET LOCK        */
*                         RFY                                      0219
*                           R14 RSTD;/* DESTROYED BY SET LOCK        */
*                         GEN;                                     0220
*                                      /*GET DISPATCHER LOCK         */
          SETLOCK OBTAIN,TYPE=DISP,MODE=UNCOND,RELATED=(ASCB,IEAVFRLK(I*
               EAVFRLK))
          LA  R11,4095(R9)   REESTABLISH BASE REGISTER       @G17EP5W
*                         RFY                                      0221
*                           R12 UNRSTD;/* DESTROYED BY SET LOCK      */
*                         RFY                                      0222
*                           R14 UNRSTD;/* DESTROYED BY SET LOCK      */
*                         IF MODESRB='0'B THEN/* IF CPU IS NOT IN SRB
*                                      MODE                  @YM02609*/
         TM    MODESRB+80(R7),B'00000010'                          0223
         BNZ   @RF00223                                            0223
*                           DO;     /* THEN KEEP THE DISPATCHER FROM
*                                      STORING STATUS IN THE DEAD  0224
*                                      MEMORY                @YM02609*/
*                             PSATOLD=NULL;/* ZERO TCB OLD TO PREVENT
*                                      THE DISPATCHER FROM         0225
*                                      REFERENCING LSQA IN DEAD    0225
*                                      MEMORY                @YM02609*/
         SLR   @12,@12                                             0225
         ST    @12,PSATOLD                                         0225
*                             ASCBCPUS=ASCBCPUS-ONE;/* DECREMENT   0226
*                                      NUMBER OF ACTIVE CPU'S IN DEAD
*                                      MEMORY - TO INDICATE CURRENT
*                                      CPU IS NO LONGER RUNNING A  0226
*                                      TASK IN THE CURRENT MEMORY  0226
*                                                            @YM02609*/
         L     @12,PSAAOLD                                         0226
         L     @10,ASCBCPUS(,@12)                                  0226
         BCTR  @10,0                                               0226
         ST    @10,ASCBCPUS(,@12)                                  0226
*                           END;    /* END OF NON-SRB PROCESSING   0227
*                                                            @YM02609*/
*                         PSAANEW=NULL;/* ZERO ASCB NEW TO CAUSE THE
*                                      DISPATCHER TO RE-SEARCH THE 0228
*                                      ASCB QUEUE AND SWITCH AWAY  0228
*                                      FROM DEAD MEMORY      @YM02609*/
@RF00223 SLR   @12,@12                                             0228
         ST    @12,PSAANEW                                         0228
*                         R2=ASCBASID;/* INDICATE DEAD MEMORY IS THE
*                                      ADDR SPACE TO BE TERMINATED 0229
*                                                            @YM02609*/
         L     @12,PSAAOLD                                         0229
         SLR   R2,R2                                               0229
         ICM   R2,3,ASCBASID(@12)                                  0229
*                         IF MODETYP1='1'B THEN/* IF THE CPU IS IN 0230
*                                      TYPE 1 SVC MODE               */
         LA    @10,80                                              0230
         ALR   @10,R7                                              0230
         TM    MODETYP1(@10),B'00000100'                           0230
         BNO   @RF00230                                            0230
*                           DO;     /* GET OUT OF TYPE1 SVC MODE - 0231
*                                      THIS IS NORMALLY DONE BY THE
*                                      EXIT PROLOGUE ROUTINE, HOW- 0231
*                                      VER IT CANNOT GET CONTROL   0231
*                                      SINCE IT ALWAYS REFERENCES  0231
*                                      LSQA                          */
*                             ASCBTYP1='0'B;/* REMOVE INDICATION THAT
*                                      A TYPE1 SVC IS OPERATING      */
         NI    ASCBTYP1(@12),B'11111101'                           0232
*                             MODETYP1='0'B;/* PREVENT THE EXIT    0233
*                                      FUNCTION FROM TAKING AN EXIT
*                                      PROLOG EXIT                   */
         NI    MODETYP1(@10),B'11111011'                           0233
*                           END;    /* END TYPE1 SVC PROCESSING      */
*                         R0=RT1WMEMT;/* INDICATE MEMTERM TO BE DONE
*                                      BY THE RESCHEDULE FUNCTION    */
@RF00230 LA    R0,15                                               0235
*                       END;        /* END DATERR PERCOLATION        */
*                     ELSE          /* IF NOT A DATERR PERCOLATION   */
*                       IF RT1WRTM^='1'B THEN/* IF IT WAS NOT RTM'S
*                                      FRR THAT JUST INDICATED     0237
*                                      PERCOLATION                   */
         B     @RC00215                                            0237
@RF00215 TM    RT1WRTM(R7),B'01000000'                             0237
         BO    @RF00237                                            0237
*                         DO;       /* PROCESS TASK PERCOLATION      */
*                           IF SDWADLST='1'B THEN/* IF DUMP OPTIONS
*                                      ARE PRESENT IN THE RTCA       */
         L     @12,RT1WRTCA(,R7)                                   0239
         TM    SDWADLST(@12),B'01000000'                           0239
         BNO   @RF00239                                            0239
*                             R5=ADDR(SDWASNPA);/* THEN PLACE A PTR
*                                      TO THE DUMP OPTS IN A REG FOR
*                                      THE RESCHEDULE FUNCTION       */
         LA    R5,SDWASNPA(,@12)                                   0240
*                           ELSE    /* IF DUMPOPTS WERENT PROVIDED   */
*                             R5=NULL;/* INDICATE NO DUMP OPTIONS    */
         B     @RC00239                                            0241
@RF00239 SLR   R5,R5                                               0241
*                           RFY                                    0242
*                             MODEBYTE BASED(ADDR(RT1WMODE));/* USE
*                                      MODE INDICATOR IN THE RTM1WA  */
@RC00239 DS    0H                                                  0243
*                           IF MODESRB='1'B THEN/* IF CPU IS IN SRB
*                                      MODE                          */
*                                                                  0243
         TM    MODESRB+80(R7),B'00000010'                          0243
         BNO   @RF00243                                            0243
*                             /***************************************/
*                             /*                                     */
*                             /* THE PURPOSE OF THE SRBPERC SEGMENT  */
*                             /* IS TO ESTABLISH THE INTERFACE TO THE*/
*                             /* RESCHEDULE MODE FUNCTION TO CAUSE A */
*                             /* DEPENDENT TASK OF THE FAILING SRB TO*/
*                             /* BE SENT THROUGH RTM2 PROCESSING. IF */
*                             /* THE SRB DOES NOT HAVE TASK AFFINITY,*/
*                             /* NO RESCHEDULE IS ESTABLISHED, AND   */
*                             /* THE EXIT FUNCTION WILL GET CONTROL. */
*                             /* INPUT IS THE LCCA, OUTPUT IS AN     */
*                             /* UPDATED FUNCTION REGISTER (R0) AND  */
*                             /* TARGASID REGISTER (R2).             */
*                             /*                                     */
*                             /***************************************/
*                                                                  0244
*                             DO;   /* PROCESS SRB PERCOLATION       */
*                               IF SRBAASID^=NULL&/* IF THE ASID   0245
*                                      AFFINITY FIELD OF THE LCCA HAS
*                                      BEEN PROVIDED AND             */
*                                   SRBATCB^=NULL THEN/* AND THE   0245
*                                      RELATED TCB HAS BEEN PROVIDED
*                                      IN THE LCCA THEN              */
         L     @12,PSALCCAV                                        0245
         SLR   @10,@10                                             0245
         ICM   @10,3,SRBAASID(@12)                                 0245
         LTR   @10,@10                                             0245
         BZ    @RF00245                                            0245
         L     @08,SRBATCB(,@12)                                   0245
         LTR   @08,@08                                             0245
         BZ    @RF00245                                            0245
*                                 DO;/* SET UP FOR TASK ABTERM       */
*                                   R3=SRBATCB;/* PUT PTR TO RELATED
*                                      TCB IN REG FOR RESCHEDULE     */
         LR    R3,@08                                              0247
*                                   R0=RT1WXMAB;/* INITIALIZE      0248
*                                      FUNCTION REG TO INDICATE    0248
*                                      XMABTERM              @YM02637*/
         LA    R0,16                                               0248
*                                   IF SRBAASID^=ASCBASID THEN/* IF
*                                      THE TCB IS NOT IN THE       0249
*                                      CURRENTLY LOADED ADDRESS SPACE
*                                      THEN                  @YM02637*/
         L     @08,PSAAOLD                                         0249
         CLC   SRBAASID(2,@12),ASCBASID(@08)                       0249
         BE    @RF00249                                            0249
*                                    R2=SRBAASID;/* INDICATE MEMORY
*                                      INTO WHICH THE ABTERM IS TO BE
*                                      SCHEDULED             @YM02637*/
         LR    R2,@10                                              0250
*                                   ELSE/* IF TCB IS IN CURRENT    0251
*                                      MEMORY                @YM02637*/
*                                    DO;/* ATTEMPT TO SET UP RESCHED
*                                      MODE FNCTN (ABTERM)   @YM02637*/
         B     @RC00249                                            0251
@RF00249 DS    0H                                                  0252
*                                     RFY                          0252
*                                      (R8,                        0252
*                                       R15) RSTD;/* GET REGS FOR  0252
*                                      STLCK TEST            @YM02637*/
*                                     GEN                          0253
*(SETLOCK TEST,TYPE=SPIN,REGS=(R8));/* TEST TO SEE IF ANY SPIN LOCKS
*                                      ARE HELD              @YM02637*/
         SETLOCK TEST,TYPE=SPIN,REGS=(R8)
*                                     GEN(LA R11,4095(R9));/* RESTORE
*                                      BASE REG              @G17EP5W*/
         LA R11,4095(R9)
*                                     IF R15^=TSTLKHEL THEN/* IF NO
*                                      SPIN LOCKS ARE HELD   @YM02637*/
         LTR   R15,R15                                             0255
         BZ    @RF00255                                            0255
*                                      DO;/* OBTAIN THE LOCAL LOCK 0256
*                                      (IF IT IS NOT ALREADY HELD) 0256
*                                      AND SET UP FOR THE RESCHEDULE
*                                      MODE FUNCTION         @YM02637*/
*                                       RFY                        0257
*                                         R15 UNRSTD;/* RELEASE REGS
*                                      USED BY SETLOCK TEST  @YM08291*/
*                                       R8=ADDR(RT1TREGS(1));/* POINT
*                                      TO SAVE AREA PORTION OF RTM1WA
*                                                            @YM08291*/
         LA    R8,RT1TREGS(,R4)                                    0258
*                                       GEN(STOSM 0(R8),X'03');/*  0259
*                                      ENSURE ENABLEMENT ON THIS PATH
*                                      TO PREVENT DISABLED SPIN WHEN
*                                      STATUS IS CALLED TO STOP THE
*                                      RELATED TASK          @YM08291*/
         STOSM 0(R8),X'03'
*                                       RFY                        0260
*                                         R8 UNRSTD;/* RELEASE WORK
*                                      REG                   @YM08291*/
*                                       RFY                        0261
*                                        (R12,                     0261
*                                         R13,                     0261
*                                         R14) RSTD;/* DESTROYED BY
*                                      SETLOCK               @YM02637*/
*                                       GEN;                       0262
*                                      /*REQUEST LOCAL LOCK  @YM02637*/
         SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,RELATED=(TCB,IEAVFRLK(IE*
               AVFRLK))
         LA R11,4095(R9)            RE-ESTABLISH BASE REG    @G17EP5W
*                                       RFY                        0263
*                                        (R12,                     0263
*                                         R13,                     0263
*                                         R14) UNRSTD;/* DEST BY   0263
*                                      SETLOCK               @YM02637*/
*                                       R0=RT1WABT1;/* INDICATE    0264
*                                      ABTERM IN CURRENT MEMORY    0264
*                                                            @YM02637*/
         LA    R0,11                                               0264
*                                      END;/* END OF SET UP FOR    0265
*                                      RESCHEDULE MODE FUNCTION    0265
*                                                            @YM02637*/
*                                     ELSE/* IF ANY SPIN LOCKS ARE 0266
*                                      HELD                  @YM02637*/
*                                      R2=ASCBASID;/* PUT CURRENT  0266
*                                      ASID IN REG SO ABTERM WILL  0266
*                                      OCCUR IN THIS ADDRESS SPACE 0266
*                                                            @YM02637*/
         B     @RC00255                                            0266
@RF00255 L     @12,PSAAOLD                                         0266
         SLR   R2,R2                                               0266
         ICM   R2,3,ASCBASID(@12)                                  0266
*                                    END;/* END OF ATTEMPT TO SET UP
*                                      RESCHEDULE MODE FUN   @YM02637*/
*                                 END;/* END TASK AFFINITY PROCESSING*/
*                             END;  /* END SRB PERC PROCESSING       */
*                           ELSE    /* IF NOT SRB PERCOLATION        */
*                             DO;   /* PROCESS TASK PERCOLATION      */
         B     @RC00243                                            0270
@RF00243 DS    0H                                                  0271
*                               R0=RT1WABT1;/* INITIALIZE FUNCTION TO
*                                      ABTERM IN CURRENT ADDR SPACE  */
         LA    R0,11                                               0271
*                               R3=NULL;/* INITIALIZE TCB TO CURRENT
*                                      TASK ABTERM                   */
         SLR   R3,R3                                               0272
*                             END;  /* END TASK PERC INITIALIZATION  */
*                           R13=ADDR(SDWAGRSV);/* ESTABLISH REGS AT
*                                      TIME OF ERROR FOR RESCHEDULE
*                                      FUNCTION (DONE LAST BECAUSE 0274
*                                      THE REGISTER USED FOR SAVAREAP
*                                      MAY HAVE BEEN USED IN       0274
*                                      PRECEEDING CODE)              */
@RC00243 L     R13,RT1WRTCA(,R7)                                   0274
         LA    R13,SDWAGRSV(,R13)                                  0274
*                         END;      /* END TASK PERC PROCESSING      */
*                       ELSE                                       0276
*                         ;         /* IF THE FRR PROTECTING THE   0276
*                                      RESCHEDULE FUNCTION OF RTM  0276
*                                      (I.E. TASK PERCOLATION) HAS 0276
*                                      INDICATED PERCOLATION, AN   0276
*                                      IMMEDIATE EXIT IS TAKEN TO  0276
*                                      PREVENT A RECURSIVE ERROR   0276
*                                      SITUATION                     */
@RF00237 DS    0H                                                  0277
*                   END;            /* END PERCOLATION PROCESSING    */
*                 ELSE                                             0278
*                   ;               /* IF RETRY THEN NO FURTHER    0278
*                                      PROCESSING REQUIRED IN THIS 0278
*                                      SEGMENT                       */
@RF00213 DS    0H                                                  0279
*             END;                  /* END SYS RECOVERY PROCESSING   */
*                                                                  0279
*           /*********************************************************/
*           /*                                                       */
*           /* IF THE CPU WAS IN TASK MODE AT THE TIME OF INTERRUPT  */
*           /* THEN THE CURRENT TASK MUST BE SENT TO RTM2 (I.E. MUST */
*           /* BE ABENDED) VIA THE RESCHEDULE FUNCTION               */
*           /*                                                       */
*           /*********************************************************/
*                                                                  0280
*           ELSE                    /* IF SYSTEM WAS IN TASK MODE    */
*                                                                  0280
*             /*******************************************************/
*             /*                                                     */
*             /* THE PURPOSE OF THE SETUPABT SEGMENT IS TO SET UP THE*/
*             /* CURRENT TASK FOR ABEND IF RTM HAD BEEN ENTERED FROM */
*             /* ONE OF THE INTERRUPT HANDLERS WHEN THE CPU WAS IN   */
*             /* TASK MODE. INPUT TO THIS SEGMENT INCLUDES THE       */
*             /* FUNCTION REGISTER (R0) WHICH INDICATES THE ORIGINAL */
*             /* ENTRY TYPE. OUTPUT FROM THIS SEGMENT IS AS FOLLOWS: */
*             /* FUNCTION REGISTER (R0) - INDICATES ABTERM FUNCTION. */
*             /* TARGTCB REGISTER (R3) - INDICATES CURRENT TCB.      */
*             /* TRAKAREA REGISTER (R4) - POINTS TO THE TRACKING AREA*/
*             /* IN THE RTM1WA.                                      */
*             /*                                                     */
*             /*******************************************************/
*                                                                  0280
*             DO;                   /* START OF SETUPABT SEGMENT     */
         B     @RC00195                                            0280
@RF00195 DS    0H                                                  0281
*               RFY                                                0281
*                 R12 RSTD;         /* THIS RFY WAS ADDED DURRING  0281
*                                      SU17, ERROR (R12 USED BUT NOT
*                                      RSTD) WAS FOUND AS A RESULT A
*                                      WALK-THRU             @G17SP2F*/
*               RFY                                                0282
*                 RT1TRACK BASED(R12);                             0282
*               RT1TLPID=RECOVRY1;  /* SET RECOVERY ID TO INDICATE 0283
*                                      SOME LEVEL OF RECOVERY IS   0283
*                                      POSSIBLE                      */
         MVI   RT1TLPID(R12),X'01'                                 0283
*NORTSRP:                           /* RETURN POINT FROM LPRR IF   0284
*                                      ERROR OCCURS AT THIS STAGE    */
*               GEN(LA R11,4095(R9));/* RESTORE BASE REG     @G17EP5W*/
NORTSRP  LA R11,4095(R9)
*               RT1TLPN=NORTS;      /* LPN=PHASE NUMBER FOR NO SYSTEM
*                                      RECOVERY PROCESSING           */
         MVI   RT1TLPN(R12),X'03'                                  0285
*               RFY                                                0286
*                 R12 UNRSTD;       /*                       @G17SP2F*/
*               IF R0=RT1WREST THEN /* IF ORIGINAL ENTRY WAS A     0287
*                                      RESTART ENTRY POINT           */
         CH    R0,@CH00142                                         0287
         BNE   @RF00287                                            0287
*                 CVTRSTWD=NULL;    /* THEN FREE THE RESTART LOCK -
*                                      ONLY NEEDED IF SIGP RESTART 0288
*                                      MIGHT BE DONE                 */
         L     @12,CVTPTR                                          0288
         SLR   @10,@10                                             0288
         ST    @10,CVTRSTWD(,@12)                                  0288
*               R0=RT1WABT1;        /* INDICATE TASK ABTERM FUNCTN   */
@RF00287 LA    R0,11                                               0289
*               R3=NULL;            /* INDICATE CURRENT TCB          */
         SLR   R3,R3                                               0290
*               R4=ADDR(RT1WLPTA);  /* PRIME THE TRACKING AREA REG 0291
*                                      WITH A PTR TO THE LOGICAL   0291
*                                      PHASE TRACK AREA IN THE RTM1WA*/
         LA    R4,RT1WLPTA(,R7)                                    0291
*               RFY                                                0292
*                 RT1TRACK BASED(R4);                              0292
*               R5=NULL;            /* ZERO DUMPOPTS REG-MIGHT NOT BE
*                                      ZERO AT THIS POINT, E.G. IF 0293
*                                      ENTRY TYPE HAD BEEN MACHCK  0293
*                                      RE-ENTRY                      */
         SLR   R5,R5                                               0293
*               PSARTM='1'B;        /* INDICATE SUPER MODE WHEN RTM
*                                      IS IN CONTROL TO PROCESS AN 0294
*                                      UNLOCKED TASK                 */
         OI    PSARTM,B'00000010'                                  0294
*             END;                  /* END ABEND SET UP CODE         */
*           RT1TLPID=NULL;          /* SET RECOVERY ID TO INDICATE NO
*                                      RECOVERY IS POSSIBLE          */
@RC00195 MVI   RT1TLPID(R4),X'00'                                  0296
*         END;                      /* END UNIQUE INTRPT PROCESSING  */
*                                                                  0297
*       /*************************************************************/
*       /*                                                           */
*       /* IF THE RTM WAS ENTERED TO PERFORM A RESCHEDULE SERVICE OR */
*       /* IF THE ACTION INDICATED AFTER SLIH MODE PROCESSING        */
*       /* DICTATES A RESCHEDULE FUNCTION THEN THE RESCHEDULE RTM    */
*       /* FUNCTION IS PERFORMED                                     */
*       /*                                                           */
*       /*************************************************************/
*                                                                  0298
*       IF R0>=SRVCLOW&             /* IF A SERVICE ROUTINE ENTRY PT
*                                      WAS USED                      */
*           R0<=SRVCHI              /* OR RESCHEDULE FUNCTION      0298
*                                      REQUIRED TO COMPLETE INTERRUPT
*                                      PROCESSING                    */
*         THEN                                                     0298
*                                                                  0298
@RF00085 CH    R0,@CH00418                                         0298
         BL    @RF00298                                            0298
         CH    R0,@CH00433                                         0298
         BH    @RF00298                                            0298
*         /***********************************************************/
*         /*                                                         */
*         /* THE PURPOSE OF THE RESCHEDULE SEGMENT IS TO CAUSE A     */
*         /* REENTRY INTO THE RTM (I.E. INTO MODULE IEAVTRT1 OR      */
*         /* IEAVTRT2). INPUT IS PASSED PRIMARILY THROUGH THE        */
*         /* REGISTERS, AND VARIES DEPENDING ON THE TYPE OF          */
*         /* RESCHEDULE FUNCTION BEING REQUESTED . FOR ALL TYPES,    */
*         /* REGISTER 0 CONTAINS AN INDICATION OF THE FUNCTION TO BE */
*         /* PERFORMED AND REGISTER 4 CONTAINS A POINTER TO THE      */
*         /* TRACKING AREA FOR CHECKPOINTING CRUCIAL INFORMATION. ALL*/
*         /* OTHER INPUT IS PASSED VIA REGISTERS 1,2,3,5,6,7, AND 13.*/
*         /* THE SPECIFIC REGISTER CONTENTS ARE DOCUMENTED IN THE    */
*         /* COMMENTARY TO THE SPECIFIC SUBFUNCTIONS BELOW.          */
*         /*                                                         */
*         /***********************************************************/
*                                                                  0299
*         DO;                       /* START OF RESCHED SEGMENT      */
*           RFY                                                    0300
*             RT1TRACK BASED(R4);   /* TRAKAREA REG (R4) POINTS TO 0300
*                                      THE PRIMARY TRACKING AREA   0300
*                                      THROUGHOUT THIS SEGMENT - THIS
*                                      AREA IS DEPENDENT ON RTM'S  0300
*                                      MODE OF ENTRY                 */
*           IF R0=RSCHDCPU THEN     /* IF RESCHEDULE CPU FUNCTION    */
*                                                                  0301
         CH    R0,@CH00199                                         0301
         BNE   @RF00301                                            0301
*             /*******************************************************/
*             /*                                                     */
*             /* THE PURPOSE OF THE RESCHEDULE CPU SEGMENT IS TO     */
*             /* CAUSE RTM1 TO BE INVOKED ON ANOTHER CPU. THIS       */
*             /* PROCESSING IS PERFORMED IF THE ENTRY TO RTM1 WAS A  */
*             /* RESTART REQUEST AND THE INTERRUPTED PROGRAM ON THE  */
*             /* CURRENT CPU HAS INDICATED THAT IT IS IN A VALID SPIN*/
*             /* WAITING FOR SOME GLOBAL RESOURCE NOW HELD BY ANOTHER*/
*             /* CPU. IT IS ASSUMED THAT THE OWNER OF THE RESOURCE IS*/
*             /* IN AN INVALID, DISABLED LOOP AND SO SHOULD BE       */
*             /* TERMINATED. THIS TERMINATION IS EFFECTED BY CAUSING */
*             /* A RESTART INTERRUPT ON THE OTHER CPU. THE ADDRESS OF*/
*             /* THIS CPU HAS BEEN DETERMINED BY THE TOP FRR ON THE  */
*             /* CURRENT CPU. INPUT TO THIS SEGMENT IS THE FUNCTION  */
*             /* REGISTER (R0), WHICH INDICATES THE RESCHEDULE CPU   */
*             /* FUNCTION, AND THE RTCA. OUTPUT FROM THIS SEGMENT IS */
*             /* AN UPDATED FUNCTION REGISTER (R0), WHICH IS RESET TO*/
*             /* THE ORIGINAL RESTART ENTRY POINT. ALSO, IF THE      */
*             /* RESTART COULD NOT BE PERFORMED, THE PSA AND CVT ARE */
*             /* UPDATED. THE VALUE OF R1 (FLAGSCC REGISTER) IS      */
*             /* PRESERVED THROUGHOUT THIS SEGMENT. ALSO, R8,R14,R15 */
*             /* ARE ASSUMED TO BE AVAILABLE FOR USE IN THIS SEGMENT.*/
*             /*                                                     */
*             /*******************************************************/
*                                                                  0302
*             DO;                   /* BEGIN THE RESCPU SEGMENT BY 0302
*                                      VALIDITY CHECKING THE CPU   0302
*                                      ADDRESS PASSED BY THE FRR     */
*               RT1TLPN=CPURSTRT;   /* LPN=PHASE NUMBER FOR        0303
*                                      RESCHEDULING RTM ON LOOPING 0303
*                                      CPU VIA A RESTART INTERRUPT   */
         MVI   RT1TLPN(R4),X'04'                                   0303
*               RT1TLPID=RECOVRY1;  /* SET RECOVERY INDICATOR TO   0304
*                                      INDICATE SOME RECOVERY IS   0304
*                                      POSSIBLE                      */
         MVI   RT1TLPID(R4),X'01'                                  0304
*               IF SDWALCPU>=LCPULOW&/* IF LOG CPU ADDR IS WITHIN    */
*                   SDWALCPU<=LCPUHIGH THEN/* RANGE OF VALID LOG   0305
*                                      ADDRESSES                     */
         L     @12,RT1WRTCA(,R7)                                   0305
         LH    @12,SDWALCPU(,@12)                                  0305
         CH    @12,@CH00228                                        0305
         BL    @RF00305                                            0305
         CH    @12,@CH00230                                        0305
         BH    @RF00305                                            0305
*                 DO;               /* CONTINUE TO PROCESS RESTART   */
*                   RFY                                            0307
*                     R8 RSTD;      /* GET REG FOR PHYSICAL CPU    0307
*                                      ADDRESS                       */
*                   R8=SDWALCPU&CONVLCPU;/* CONVERT LOG CPU ADDRESS
*                                      TO PHYSICAL CPU ADDRESS       */
         N     @12,@CF00232                                        0308
         LR    R8,@12                                              0308
*                   IF((CSDCPUAL&CSDMASK(R8+ONE))^=NULL)&/* IF THIS
*                                      CPU IS ONLINE AND ACTIVE      */
*                       R8^=PSACPUPA THEN/* AND NOT THE CURRENT CPU  */
         L     @12,CVTPTR                                          0309
         L     @10,CVTCSD(,@12)                                    0309
         LR    @15,R8                                              0309
         ALR   @15,@15                                             0309
         ALR   @15,@10                                             0309
         SLR   @14,@14                                             0309
         ICM   @14,3,CSDMASK(@15)                                  0309
         SLR   @15,@15                                             0309
         ICM   @15,3,CSDCPUAL(@10)                                 0309
         NR    @14,@15                                             0309
         LTR   @14,@14                                             0309
         BZ    @RF00309                                            0309
         CH    R8,PSACPUPA                                         0309
         BE    @RF00309                                            0309
*                     DO;           /* PREPARE TO ISSUE DSGNL RSTRT  */
*                       RT1TREGS(TWO)=R1;/* SAVE REG TO BE USED FOR
*                                      PCCA ADDRESS                  */
         ST    R1,RT1TREGS+4(,R4)                                  0311
*                       R1=PCCAT00P(R8+ONE);/* LOCATE PCCA ADDRESS 0312
*                                      FOR BAD CPU                   */
         LR    @10,R8                                              0312
         SLA   @10,2                                               0312
         L     @12,CVTPCCAT(,@12)                                  0312
         L     R1,PCCAT00P(@10,@12)                                0312
*                       RFY                                        0313
*                         R15 RSTD; /* GET REG FOR DSGNL R. C.       */
*                       GEN(DSGNL RESTART,CPU=(1));/* ISSUE RESTRT ON
*                                      BAD CPU                       */
         DSGNL RESTART,CPU=(1)
*                       IF R15=STRTSIGP THEN/* IF SIGP FUNC WAS    0315
*                                      STARTED                       */
         LTR   R15,R15                                             0315
         BNZ   @RF00315                                            0315
*                         R0=RT1TENPT;/* RESTORE ORIGINAL FUNC VALUE-
*                                      WILL ALLOW LATER PROCESSING TO
*                                      TEST IF RESTRT WAS ISSUED     */
         SLR   R0,R0                                               0316
         IC    R0,RT1TENPT(,R4)                                    0316
*                       ELSE        /* IF SIGP WAS UNSUCCESSFUL      */
*                         R0=RSCHDCPU;/* RESTORE RSCHDCPU FUNC VALUE */
         B     @RC00315                                            0317
@RF00315 LA    R0,17                                               0317
*                       R1=RT1TREGS(TWO);/* RESTORE REG USED FOR PCCA
*                                      ADDRESS                       */
@RC00315 L     R1,RT1TREGS+4(,R4)                                  0318
*                       RFY                                        0319
*                        (R8,                                      0319
*                         R15) UNRSTD;/* RELEASE REGS                */
*                     END;          /* END OF SIGP FUNC PROCESSING   */
*                 END;              /* END OF VALID CPU ADD PROCESS  */
@RF00309 DS    0H                                                  0322
*               IF R0=RSCHDCPU THEN /* IF RESTART COULD NOT BE     0322
*                                      PERFORMED                     */
@RF00305 CH    R0,@CH00199                                         0322
         BNE   @RF00322                                            0322
*                 DO;               /* ALTER INTERFACE TO CAUSE    0323
*                                      REENTRY TO RESTART FLIH       */
*                   RT1TLPN=NORSTRT;/* LPN=UNSUCCESSFUL RESTART PHASE
*                                      NUMBER                        */
         MVI   RT1TLPN(R4),X'05'                                   0324
*                   CVTRSTWD=NULL;  /* RELEASE RESTART RESOURCE WRD  */
         L     @12,CVTPTR                                          0325
         SLR   @10,@10                                             0325
         ST    @10,CVTRSTWD(,@12)                                  0325
*                   RT1TLPN=VALIDREC;/* LPN=VALID RECURSION INDICATOR
*                                      ALLOWS SOME INFORMATION IN THE
*                                      RTM1WA TO BE PRESERVED ON A 0326
*                                      RECURSIVE ENTRY TO RTM. THIS
*                                      INFORMATION INCLUDES THE PTR
*                                      TO THE RTCA DESCRIBING THE  0326
*                                      CURRENT ERROR.                */
         MVI   RT1TLPN(R4),X'FF'                                   0326
*                   GEN(ABEND X'071',DUMP,,SYSTEM);/* SINCE SOME   0327
*                                      ERROR OCCURRD ON RTM1'S     0327
*                                      ATTEMPT TO HANDLE THE FRR'S 0327
*                                      RESUME REQUEST, RTM1 ISSUES AN
*                                      ABEND WHICH CAUSES THIS SAME
*                                      FRR TO BE REENTERED, BUT WITH
*                                      ANOTHER ERROR INDICATION AND
*                                      WITH THE OPTION ONLY TO CLEAN
*                                      UP AND PERCOLATE.             */
         ABEND X'071',DUMP,,SYSTEM
*                 END;              /* END OF ERROR PROCESSING       */
*             END;                  /* END OF RESCPU SEGMENT         */
*           ELSE                    /* IF NOT RESCHED CPU FUNCTION   */
*                                                                  0330
*             /*******************************************************/
*             /*                                                     */
*             /* THE FOLLOWING CODE ESTABLISHES A RECOVERY           */
*             /* ENVIRONMENT FOR THE RESCHEDULE FUNCTION. IF         */
*             /* OPERATING IN SERVICE ROUTINE MODE, THEN RECOVERY AND*/
*             /* TRACKING HAS BEEN EFFECTED BY AN FRR ESTABLISHED BY */
*             /* IEAVTRT1. IF OPERATING IN SLIH MODE, THEN ERROR     */
*             /* PROTECTION AND TRACKING HAS BEEN EFFECTED BY THE    */
*             /* LOGICAL PHASE RECOVERY SCHEME. AFTER THIS POINT,    */
*             /* ERROR PROTECTION IS EFFECTED VIA A NEW FRR. THE     */
*             /* FOLLOWING CODE ESTABLISHES AN FRR AND PRESERVES     */
*             /* INFORMATION FROM THE TRACKING AREA ASSOCIATED WITH  */
*             /* THE PREVIOUS RECOVERY. INPUT IS THE TRAKAREA        */
*             /* REGISTER (R4) POINTING TO THE PREVIOUS TRACKING     */
*             /* AREA. OUTPUT IS AN UPDATED R4 POINTING TO THE NEW   */
*             /* TRACK AREA.                                         */
*             /*                                                     */
*             /*******************************************************/
*                                                                  0330
*             DO;                   /* CONTINUE RESCHEDULE PROCESS   */
         B     @RC00301                                            0330
@RF00301 DS    0H                                                  0331
*               RFY                                                0331
*                 FRRS BASED(PSACSTK);/* USE DCL BASE FOR FRRS       */
*               RFY                                                0332
*                 R12 RSTD;         /* GET CONTROL OF REGISTER       */
*               R12=R4;             /* SAVE ADDRESS OF PREVIOUS    0333
*                                      TRACKING AREA                 */
         LR    R12,R4                                              0333
*               IF RT1TENPT>=SLIHLOW&/* IF ORIGINAL ENTRY WAS SLIH   */
*                   RT1TENPT<=SLIHHI THEN/* MODE                     */
         CLI   RT1TENPT(R4),1                                      0334
         BL    @RF00334                                            0334
         CLI   RT1TENPT(R4),9                                      0334
         BH    @RF00334                                            0334
*                 DO;               /* PLACE AN ADDITIONAL FRR ON THE
*                                      STACK FOR CHECKPOINTING     0335
*                                      RECOVERY INFORMATION          */
*                   RT1TLPN=VALIDREC;/* INDICATE A RECURSION INTO RTM
*                                      IS ALLOWED                    */
         MVI   RT1TLPN(R4),X'FF'                                   0336
*                   RT1WEED=NULL;   /* ZERO EED POINTER IN WA SO EEDS
*                                      WON'T BE FREED IF A NEW ERROR
*                                      OCCURS                        */
         L     @10,PSACSTK                                         0337
         SLR   @08,@08                                             0337
         ST    @08,RT1WEED(,@10)                                   0337
*                   RT1WRTM='1'B;   /* INDICATE RTM HAS AN FRR ON THE
*                                      STACK                         */
         OI    RT1WRTM(@10),B'01000000'                            0338
*                   RFY                                            0339
*                    (R14,                                         0339
*                     R15) RSTD;    /* GET WORKREGS FOR SETFRR       */
*                   GEN             /* ISSUE SETFRR MACRO            */
*                                                                  0340
*(SETFRR A,FRRAD=SLIHFRR,PARMAD=(R4),WRKREGS=(R14,R15));           0340
         SETFRR A,FRRAD=SLIHFRR,PARMAD=(R4),WRKREGS=(R14,R15)
*                   RFY                                            0341
*                    (R14,                                         0341
*                     R15) UNRSTD;  /* RELEASE SETFRR WORKREGS       */
*                   RT1TENPT=R12->RT1TENPT;/* PLACE ORIGINAL ENTRY PT
*                                      INDICATOR FROM THE PREVIOUS 0342
*                                      TRACKING AREA INTO THE NEW  0342
*                                      TRACKING AREA                 */
         MVC   RT1TENPT(1,R4),RT1TENPT(R12)                        0342
*                   RT1TREGS(ONE)=R13;/* CHECKPOINT REG13 VALUE      */
         ST    R13,RT1TREGS(,R4)                                   0343
*                   R12=R4;         /* SAVE ADDR OF SLIHFRR PARM AREA*/
         LR    R12,R4                                              0344
*                 END;              /* END OF SLIHFRR PROCESSING     */
*                                                                  0345
*               /*****************************************************/
*               /*                                                   */
*               /* IF THE ORIGINAL ENTRY HAD BEEN IS SLIH MODE,      */
*               /* TRAKAREA REGISTER (R4) NOW POINTS TO THE SLIHFRR  */
*               /* PARM AREA. IF THE ORIGINAL ENTRY HAD BEEN IN      */
*               /* SERVICE ROUTINE MODE, THIS REGISTER POINTS TO     */
*               /* RT1'S FRR PARM AREA.                              */
*               /*                                                   */
*               /*****************************************************/
*                                                                  0346
*               RT1TREGS(TWO)=R5;   /* CHECKPOINT REG5 VALUE         */
@RF00334 ST    R5,RT1TREGS+4(,R4)                                  0346
*               RT1TREGS(THREE)=R6; /* CHECKPOINT REG6 VALUE         */
         ST    R6,RT1TREGS+8(,R4)                                  0347
*               RT1TREGS(FOUR)=R7;  /* CHECKPOINT REG7 VALUE         */
         ST    R7,RT1TREGS+12(,R4)                                 0348
*               RFY                                                0349
*                (R14,                                             0349
*                 R15) RSTD;        /* GET WORKREGS FOR SETFRR       */
*               GEN                 /* PLACE RESCHFRR ON STACK       */
*                                                                  0350
*(SETFRR A,FRRAD=RESCHFRR,PARMAD=(R4),WRKREGS=(R14,R15));          0350
         SETFRR A,FRRAD=RESCHFRR,PARMAD=(R4),WRKREGS=(R14,R15)
*               RFY                                                0351
*                (R14,                                             0351
*                 R15) UNRSTD;      /* RELEASE SETFRR WORKREGS       */
*                                                                  0351
*               /*****************************************************/
*               /*                                                   */
*               /* TRAKAREA REG (R4) NOW POINTS TO RESCHFRR PARM     */
*               /* AREA.                                             */
*               /*                                                   */
*               /*****************************************************/
*                                                                  0352
*               RFY                                                0352
*                 R8 RSTD;          /* GET CONTROL OF REG FOR STM    */
*               R8=ADDR(RT1TREGS);  /* LOCATE THE REG CHECKPT AREA   */
         LA    R8,RT1TREGS(,R4)                                    0353
*               GEN(STM   R0,R4,0(R8));/* CHECKPT REGS - R0 TO R4    */
         STM   R0,R4,0(R8)
*               RT1TENPT=R12->RT1TENPT;/* PLACE ORIGINAL ENTRY PT  0355
*                                      INDICATOR FROM THE PREVIOUS 0355
*                                      TRACKING AREA INTO THE NEW  0355
*                                      TRACKING AREA                 */
         MVC   RT1TENPT(1,R4),RT1TENPT(R12)                        0355
*               RT1TLPN=RESCHED;    /* LPN=PHASE NUMBER FOR RESCHED
*                                      FUNCTION                      */
         MVI   RT1TLPN(R4),X'5E'                                   0356
*               IF R0=RT1WXMAB THEN /* IF CROSS MEM ABTERM REQUEST   */
*                                                                  0357
         CH    R0,@CH00131                                         0357
         BNE   @RF00357                                            0357
*                 /***************************************************/
*                 /*                                                 */
*                 /* THE PURPOSE FOR THE XMABTERM SEGMENT IS TO      */
*                 /* SCHEDULE A REENTRY INTO RTM1 AT ENTRY POINT     */
*                 /* IEAVTRTX AS AN SRB. THIS FUNCTION IS PROVIDED TO*/
*                 /* ALLOW THE SCHEDULING OF RTM2 TO BE PERFORMED IN */
*                 /* AN ADDRESS SPACE OTHER THAN THE CURRENT, AND TO */
*                 /* ALLOW FOR AN ABTERM FUNCTION WHICH DOES NOT     */
*                 /* REQUIRE THE LOCAL LOCK. THE INPUT TO THIS       */
*                 /* SEGMENT IS AS FOLLOWS: FUNCTION REGISTER (R0) - */
*                 /* INDICATES XMABTERM FUNCTION. FLAGSCC REGISTER   */
*                 /* (R1) CONTAINS THE COMPLETION CODE. TARGASID     */
*                 /* REGISTER (R2) - CONTAINS THE ASID OF THE ADRESS */
*                 /* SPACE INTO WHICH THE SRB IS TO BE SCHEDULED, OR */
*                 /* CONTAINS ZERO, INDICATING THE CURRENT ADDRESS   */
*                 /* SPACE. TARGTCB (R3) - CONTAINS THE ADDRESS OF   */
*                 /* THE TCB TO BE SERVICED BY RTM2. TRAKAREA        */
*                 /* REGISTER (R4) - CONTAINS A POINTER TO A TRACKING*/
*                 /* AREA FOR CHECK POINTING VOLATILE REGISTERS. THE */
*                 /* TRACKAREA IS ALSO USED TO LOCATE THE ORIGINAL   */
*                 /* RTM ENTRYPOINT BYTE. DUMPOPTS REGISTER (R5)     */
*                 /* CONTAINS A POINTER TO DUMP OPTIONS OR ZERO      */
*                 /* INDICATING NO DUMP OPTIONS. EEDCHAIN (R6)       */
*                 /* CONTAINS A POINTER TO A CHAIN OF EEDS IF ANY    */
*                 /* WERE PREVIOUSLY ACQUIRED, OR ZERO, INDICATING NO*/
*                 /* ACQUISTION OF EEDS WAS PREVIOUSLY ATTEMPTED, OR */
*                 /* THE EEDNULL VALUE (1) INDICATING A PREVIOUS     */
*                 /* ATTEMPT AT ACQUIRING AN EED CELL FAILED.        */
*                 /* SAVAREAP REGISTER (R13) - CONTAINS A POINTER TO */
*                 /* REGS AT TIME OF ERROR (IF NOT PREVIOUSLY PLACED */
*                 /* INTO EEDS). RECVREGS REGISTER (R12) - CONTAINS A*/
*                 /* PTR TO THE SECONDARY TRACKING AREA USED TO      */
*                 /* CHECKPOINT RECOVERY INFORMATION. ADDITIONALLY,  */
*                 /* R7,R8,R10,R14 AND R15 ARE ASSUMED TO BE         */
*                 /* AVAILABLE FOR USE BY THIS SEGMENT. THE RTM1WA OF*/
*                 /* THE CURRENT STACK CONTAINS THE PSW AND ERRORTYPE*/
*                 /* CAUSING ENTRY TO THIS SEGMENT, IF IN SLIH MODE. */
*                 /* OUTPUT FROM THIS SEGMENT IS AS FOLLOWS: FUNCTION*/
*                 /* REGISTER (R0) - SET TO INDICATE TAKE AN EXIT R1 */
*                 /* - R5 CONTAIN THEIR INPUT VALUES. EEDCHAIN       */
*                 /* REGISTER (R6) - CONTAINS ZERO TO INDICATE NO    */
*                 /* EEDS ARE TO BE FREED DURING EXIT PROCESSING, IF */
*                 /* THE SCHEDULE WAS PERFORMED, OTHERWISE CONTAINS A*/
*                 /* PTR TO ANY EEDS ACQUIRED DURING THIS INVOCATION */
*                 /* OF THE RTM1.                                    */
*                 /*                                                 */
*                 /***************************************************/
*                                                                  0358
*                 DO;               /* START OF XMABTRM SEGMENT      */
*                   RFY                                            0359
*                     R8 RSTD;      /* GET REG FOR ASCB ADDRESS      */
*                   CALL ASIDCK;    /* VALIDITY CHECK THE ASID       */
         BAL   @14,ASIDCK                                          0360
*                   IF R0^=TAKEEXIT THEN/* IF VALIDITY CHECKS OK     */
         CH    R0,@CH00352                                         0361
         BE    @RF00361                                            0361
*                     DO;           /* SET UP FOR SCHEDULE           */
*                                                                  0362
*                       /*********************************************/
*                       /*                                           */
*                       /* THE PURPOSE FOR THE GETANSRB SEGMENT IS TO*/
*                       /* ACQUIRE AN EED CELL FOR USE AS AN SRB. IF */
*                       /* NO CELLS ARE AVAILABLE IN RTM1S QUICKCELL */
*                       /* POOL, THEN AN ATTEMPT IS MADE TO RE-USE A */
*                       /* CELL THAT HAD PREVIOUSLY BEEN ACQUIRED FOR*/
*                       /* AN EED. IF NONE HAD BEEN ACQUIRED, FURTHER*/
*                       /* XMABTRM PROCESSING IS PREVENTED. INPUT TO */
*                       /* THIS SEGMENT IS AS FOLLOWS: TRAKAREA      */
*                       /* REGISTER (R4) CONTAINS AREA FOR CHECK     */
*                       /* POINTING VOLATILE REGS. EEDCHAIN REGISTER */
*                       /* (R6) - CONTAINS POINTER TO ANY PREVIOUSLY */
*                       /* OBTAINED EEDS. RECVREGS REGISTER (R12) -  */
*                       /* CONTAINS POINTER TO SECONDARY TRACKING    */
*                       /* AREA USED TO CHECKPOINT RECOVERY          */
*                       /* INFORMATION IT IS ASSUMED THAT R7,R10,R14,*/
*                       /* AND R15 ARE AVAILABLE AS WORKREGS. OUTPUT */
*                       /* FROM THIS SEGMENT IS AS FOLLOWS: FUNCTION */
*                       /* REGISTER (R0) - INDICATES TO TAKE AN EXIT */
*                       /* IF A CELL COULD NOT BE ACQUIRED. EEDCHAIN */
*                       /* REGISTER (R6) - SET TO INDICATE MISSING   */
*                       /* EED IF AN EED CELL WAS STOLEN FROM THE    */
*                       /* CHAIN FOR USE AS AN SRB. IF MORE THAN ONE */
*                       /* EED WAS ON THE CHAIN THEN THE FORWARD PTR */
*                       /* OF THE LAST EED IS SET TO INDICATE MISSING*/
*                       /* DATA. SRBCELL REGISTER (R7) CONTAINS A    */
*                       /* POINTER TO THE ACQUIRED EED, IF ONE WAS   */
*                       /* OBTAINED.                                 */
*                       /*                                           */
*                       /*********************************************/
*                                                                  0363
*                       DO;         /* START OF GETANSRB SEGMENT     */
*                         RFY                                      0364
*                           R10 RSTD;/* GET CONTROL OF WORKREG       */
*                         R10=ADDR(RT1TREGS);/* LOCATE THE REG     0365
*                                      CHECKPT AREA                  */
         LA    R10,RT1TREGS(,R4)                                   0365
*                         R0=RT1CPOOL;/* PUT RTM1S CELL POOL ID IN 0366
*                                      PARM REG FOR GETCELL          */
         L     R0,RT1CPOOL                                         0366
*                         RT1TLPN=SRBEED;/* LPN=PHASE NMBER FOR    0367
*                                      ACQUIRING AN EED FOR USE AS AN
*                                      SRB                           */
         MVI   RT1TLPN(R4),X'5A'                                   0367
*                         GEN(GETCELL CPID=(0),BRANCH=YES,SAVE=NO);/*
*                                      REQUEST A CELL FROM THE POOL  */
         GETCELL CPID=(0),BRANCH=YES,SAVE=NO
*                         GEN(LA R11,4095(R9));/* RESTORE BASE REG 0369
*                                                            @G17EP5W*/
         LA R11,4095(R9)
*                         RFY                                      0370
*                           R15 RSTD;/* GET CONTROL OF PARM REG      */
*                         R7=R1;    /* PRESERVE GETCELLS RETURN    0371
*                                      PARAMETER                     */
         LR    R7,R1                                               0371
*                         GEN(LM R0,R4,0(R10));/* RELOAD ORIGINAL  0372
*                                      REGS                          */
         LM R0,R4,0(R10)
*SRBEEDRP:                          /* RETURN POINT FROM RESCHFRR IF
*                                      GETCELL FAILURE OCCURS        */
*                         GEN(LA R11,4095(R9));/* RESTORE BASE REG 0373
*                                                            @G17EP5W*/
SRBEEDRP LA R11,4095(R9)
*                         RT1TLPN=EEDSTEAL;/* LPN=PHASE NUMBER FOR 0374
*                                      ATTEMPT TO STEAL AN EED FOR AN
*                                      SRB                           */
         MVI   RT1TLPN(R4),X'5F'                                   0374
*                         IF R15^=QCELNORM THEN/* IF A CELL WASNT  0375
*                                      OBTAINED                      */
         LTR   R15,R15                                             0375
         BZ    @RF00375                                            0375
*                           DO;     /* TRY TO STEAL A CELL           */
*                             RFY                                  0377
*                               R15 UNRSTD;/* RELINQUISH GETCELL REG */
*                             RFY                                  0378
*                               R10 RSTD;/* GET A WORK REGISTER FOR
*                                      SEARCHING EED QUEUE           */
*                             RFY                                  0379
*                               R14 RSTD;/* GET A WORK REGISTER FOR
*                                      KEEPING TRACK OF THE PREV-  0379
*                                      IOUS EED ON THE QUEUE         */
*                             IF R6>EEDNULL THEN/* IF AT LEAST ONE 0380
*                                      CELL WAS PREVIOUSLY PLACED ON
*                                      THE Q                         */
         CH    R6,@CH00073                                         0380
         BNH   @RF00380                                            0380
*                               DO; /* SEARCH FOR END OF CHAIN       */
*                                 R10=R6;/* PRIME CURRENT TO POINT TO
*                                      FIRST ELEMENT ON QUEUE        */
         LR    R10,R6                                              0382
*                                 R14=NULL;/* PRIME POINTER TO     0383
*                                      PREVIOUS EED TO ZERO          */
         SLR   R14,R14                                             0383
*                                 DO WHILE/* ESTABLISH A SEARCH LOOP */
*                                       (R10->EEDFWRDP>EEDNULL);/* 0384
*                                      AND KEEP LOOPING UNTIL NO MORE
*                                      EEDS ARE FOUND                */
         B     @DE00384                                            0384
@DL00384 DS    0H                                                  0385
*                                   R14=R10;/* BUMP THE PTR TO     0385
*                                      PREVIOUS EED TO PT TO CURRENT */
         LR    R14,R10                                             0385
*                                   R10=R10->EEDFWRDP;/* BUMP PTR TO
*                                      CURRENT TO POINT TO NEXT    0386
*                                      ELEMENT                       */
         L     R10,EEDFWRDP(,R10)                                  0386
*                                 END;/* CHECK FOR LOOP EXIT CRITERIA*/
@DE00384 LA    @15,1                                               0387
         C     @15,EEDFWRDP(,R10)                                  0387
         BL    @DL00384                                            0387
*                                 IF R14=NULL THEN/* IF ONLY ONE EED
*                                      WAS ON THE Q                  */
         LTR   R14,R14                                             0388
         BNZ   @RF00388                                            0388
*                                   R6=EEDNULL;/* THEN DEQUEUE IT  0389
*                                      FROM THE CHAIN AND INDICATE 0389
*                                      MISSING EED IN THE QUEUE    0389
*                                      ORIGIN                        */
         LR    R6,@15                                              0389
*                                 ELSE/* IF > 1 EED ON CHAIN         */
*                                   R14->EEDFWRDP=EEDNULL;/* THEN  0390
*                                      DEQUEUE IT AND MARK THE LAST
*                                      ELEMENT WITH MISSING EED    0390
*                                      INDICATION                    */
         B     @RC00388                                            0390
@RF00388 MVC   EEDFWRDP(4,R14),@CF00073                            0390
*                                 R7=R10;/* SAVE PTR TO CELL FOR SRB */
@RC00388 LR    R7,R10                                              0391
*                                 RFY                              0392
*                                   R14 UNRSTD;/* RETURN WORKREG TO
*                                      CMPLR                         */
*                                 RFY                              0393
*                                   R10 UNRSTD;/* RETURN WORKREG TO
*                                      CMPLR                         */
*                               END;/* END EED SEARCH PROCESSING     */
*                             ELSE  /* IF AN EED CANT BE STOLEN      */
*                               R0=TAKEEXIT;/* INDICATE TERMINATE  0395
*                                      FURTHER RESCHEDULE PROCESSING */
         B     @RC00380                                            0395
@RF00380 LA    R0,30                                               0395
*                           END;    /* END EED STEAL PROCESSING      */
@RC00380 DS    0H                                                  0397
*                       END;        /* END GETANSRB PROCESSING       */
@RF00375 DS    0H                                                  0398
*                       IF R0^=TAKEEXIT THEN/* IF AN SRB WAS       0398
*                                      ALLOCATED                     */
         CH    R0,@CH00352                                         0398
         BE    @RF00398                                            0398
*                         DO;       /* THEN INITIALIZE IT            */
*                           R12->RT1TREGS(THREE)=R6;/* CHECKPOINT  0400
*                                      VALUE OF EEDCHAIN REGISTER    */
         ST    R6,RT1TREGS+8(,R12)                                 0400
*                           R12->RT1TREGS(FOUR)=R7;/* CHECKPOINT SRB
*                                      ADDRESS                       */
         ST    R7,RT1TREGS+12(,R12)                                0401
*                           RT1TLPN=FREESRB;/* LPN=PHASE NUMBER FOR
*                                      SRB INITIALIZATION            */
         MVI   RT1TLPN(R4),X'60'                                   0402
*                           RFY                                    0403
*                             SSRBSECT BASED(R7);/* ESTABLISH BASE OF
*                                      SRB MAPPING MACRO AS NEW CELL */
*                           SRB=''B;/* THIS SETS DEFAULTS FOR CPU  0404
*                                      AFFIN(NO AFF), PRTY(SYS PRTY)
*                                      AND KEY (KEY 0)               */
         XC    SRB(44,R7),SRB(R7)                                  0404
*                           SRBPARM=R7+LENGTH(SRB);/* POINT TO NEXT
*                                      AVAILABLE SLOT IN THE CELL    */
         LA    @10,44                                              0405
         ALR   @10,R7                                              0405
         ST    @10,SRBPARM(,R7)                                    0405
*                           SRBPTCB=R3;/* ASSIGN TASK AFFINITY TO THE
*                                      TASK BEING ABTERMED           */
         ST    R3,SRBPTCB(,R7)                                     0406
*                           SRBPASID=R2;/* INDICATE THE ASID CONTAING
*                                      RELATED TASK                  */
         STH   R2,SRBPASID(,R7)                                    0407
*                           SRBASCB=R8;/* POINT TO THE ASCB OF THE 0408
*                                      ADDRESS SPACE INTO WHICH THIS
*                                      SRB IS TO BE SCHEDULED        */
         ST    R8,SRBASCB(,R7)                                     0408
*                           SRBEP=ADDR(IEAVTRTX);/* INDICATE THE   0409
*                                      CROSS MEMORY ABTERM REENTRY 0409
*                                      POINT IN IEAVTRT1             */
         L     @10,@CV00152                                        0409
         ST    @10,SRBEP(,R7)                                      0409
*                           RT1TLPN=XMEEDS;/* LPN=PHASE NUMBER FOR 0410
*                                      EED PROCESSING ON XMABTRM   0410
*                                      REQST                         */
         MVI   RT1TLPN(R4),X'5B'                                   0410
*                           CALL EEDPROC;/* GATHER PERTINANT DATA  0411
*                                      CONCERNING ERROR INTO EEDS    */
         BAL   @14,EEDPROC                                         0411
*XMEEDRP:                           /* RETURN POINT FROM FRR IF    0412
*                                      GETCELL FAILURE OCCURS        */
*                           GEN(LA R11,4095(R9));/* RESTORE BASE REG
*                                                            @G17EP5W*/
XMEEDRP  LA R11,4095(R9)
*                           RT1TLPN=FREESRB;/* LPN=PHASE NUMBER FOR
*                                      SRB PROCESSING PRIOR TO     0413
*                                      SCHEDULE                      */
         MVI   RT1TLPN(R4),X'60'                                   0413
*                           IF R6>EEDNULL THEN/* IF AT LEAST 1 EED 0414
*                                      WAS OBTAINED THEN             */
         CH    R6,@CH00073                                         0414
         BNH   @RF00414                                            0414
*                             DO;   /* FILL IN MORE DATA INTO EED    */
*                               RFY                                0416
*                                 EED BASED(R6);/* USE THE FIRST EED
*                                      ON THE CHAIN                  */
*                               EEDASID=PSAAOLD->ASCBASID;/* SHOW THE
*                                      CURRENT ASID AS THE ADDRESS 0417
*                                      SPACE CAUSING THE ERROR       */
         L     @10,PSAAOLD                                         0417
         MVC   EEDASID(2,R6),ASCBASID(@10)                         0417
*                               EEDERTYP=RT1TENPT;/* SAVE THE      0418
*                                      ORIGINAL ENTRY PT INDICATOR 0418
*                                                            @YM03649*/
         MVC   EEDERTYP(1,R6),RT1TENPT(R4)                         0418
*                               IF RT1TENPT>=SLIHLOW&/* IF IN SLIH 0419
*                                      MODE                          */
*                                   RT1TENPT<=SLIHHI THEN          0419
         CLI   RT1TENPT(R4),1                                      0419
         BL    @RF00419                                            0419
         CLI   RT1TENPT(R4),9                                      0419
         BH    @RF00419                                            0419
*                                 EEDMODE=RT1WMODE;/* THEN INDICATE
*                                      THE SYSTEM MODE AT THE TIME 0420
*                                      THE ERROR INTERRUPT OCCURRED  */
         L     @10,PSACSTK                                         0420
         MVC   EEDMODE(1,R6),RT1WMODE(@10)                         0420
*                               ELSE/* IF NOT IN SLIH MODE           */
*                                 ADDR(EEDMODE)->MODETCB='1'B;/* THEN
*                                      SET TO TASK MODE AS A DEFAULT */
         B     @RC00419                                            0421
@RF00419 OI    MODETCB+8(R6),B'00000001'                           0421
*                             END;  /* END EED PROCESSING            */
@RC00419 DS    0H                                                  0423
*                           R8=SRBPARM;/* LOCATE THE PARM AREA IN THE
*                                      SRB CELL                      */
@RF00414 L     R8,SRBPARM(,R7)                                     0423
*                           GEN(STM R0,R6,0(R8));/* PLACE ALL DATA 0424
*                                      ABOUT THE ERROR INTO PARM AREA*/
         STM R0,R6,0(R8)
*                           GEN(SCHEDULE SRB=(R7));/* PUT SRB ON THE
*                                      DISPATCHING QUEUE             */
         SCHEDULE SRB=(R7)
*                           RFY                                    0426
*                             R8 UNRSTD;/* RELEASE CONTROL OF WORKREG*/
*                           R6=NULL;/* INDICATE THAT NO EEDS ARE TO
*                                      FREED BY THE EXIT FUNCTION    */
         SLR   R6,R6                                               0427
*                           R12->RT1TREGS(THREE)=R6;/* CHECKPOINT NEW
*                                      VALUE OF EEDCHAIN REGISTER    */
         ST    R6,RT1TREGS+8(,R12)                                 0428
*                           RT1TLPN=SRBCOMP;/* LPN=PHASE NUMBER FOR
*                                      POST SCHEDULE SRB PROCESSING  */
         MVI   RT1TLPN(R4),X'61'                                   0429
*                           R0=TAKEEXIT;/* SKIP FURTHER RESCHEDULE 0430
*                                      STEP                          */
         LA    R0,30                                               0430
*                         END;      /* END SRB INITIALIZING          */
*                     END;          /* END END SCHEDULE PROCESSING   */
@RF00398 DS    0H                                                  0433
*                 END;              /* END CROSS MEMORY ABTERM       */
@RF00361 DS    0H                                                  0434
*               IF R0>=MODELOW&     /* IF REQUEST IS IN THE RANGE    */
*                   R0<=MODEHI THEN /* OF RESCHEDULE MODE TYPES      */
*                                                                  0434
@RF00357 LA    @10,10                                              0434
         CR    R0,@10                                              0434
         BL    @RF00434                                            0434
         CH    R0,@CH00426                                         0434
         BH    @RF00434                                            0434
*                 /***************************************************/
*                 /*                                                 */
*                 /* THE PURPOSE OF THE RESCHEDULE MODE FUNCTION IS  */
*                 /* TO CAUSE THE RECOVERY AND TERMINATION PROCESS TO*/
*                 /* OCCUR IN THE SAME SYSTEM MODE AS THE ROUTINE    */
*                 /* WHICH SUFFERED THE ERROR. IF THE ROUTINE WAS AN */
*                 /* UNLOCKED, ENABLED TCB MODE ROUTINE, THE RTM2 -  */
*                 /* MODULE IEAVTRT2 - IS SCHEDULED TO BE DISPATCHED */
*                 /* FROM THE SAME TCB. IF THE ROUTINE WAS A LOCALLY */
*                 /* LOCKED TASK, THE RTM1 - MODULE IEAVTRT1 IS      */
*                 /* SCHEDULED TO BE DISPATCHED FROM THE ASXB. IF THE*/
*                 /* ROUTINE WAS AN SRB, THEN RTM1 IS SCHEDULED TO BE*/
*                 /* DISPATCHED FROM THE SRB QUEUE. IN ALL CASES, THE*/
*                 /* TECHNIQUE EMPLOYED IS TO CAUSE AN SVC 13        */
*                 /* INSTRUCTION TO BE THE FIRST INSTRUCTION EXECUTED*/
*                 /* WHEN THE ROUTINE IS DISPATCHED. THE INPUT IS AS */
*                 /* FOLLOWS: FUNCTION REGISTER (R0) - CONTAINS THE  */
*                 /* ENTRYPOINT/FUNCTION INDICATOR. FLAGSCC REGISTER */
*                 /* (R1) - CONTAINS THE COMPLETION CODE AND CALLRTM */
*                 /* FLAGS. SAVAREAP REGISTER (R13) - CONTAINS A PTR */
*                 /* TO THE REGISTERS AT TIME OF ERROR IF SLIH MODE, */
*                 /* OR REGISTERS AT TIME OF ENTRY IF SERVICE ROUTINE*/
*                 /* MODE. RECVREGS REGISTER (R12) - CONTAINS A      */
*                 /* POINTER TO THE SECONDARY TRACKING AREA USED TO  */
*                 /* CHECKPOINT RECOVERY INFORMATION. TARGASID       */
*                 /* REGISTER (R2) - CONTAINS ASID OF ADDRESS SPACE  */
*                 /* WHERE THE ERROR ORIGINALLY WAS DETECTED IF A    */
*                 /* CROSS MEMORY ABTERM REENTRY IS BEING SERVICED.  */
*                 /* OTHERWISE R2=0. TARGTCB (R3) - CONTAINS POINTER */
*                 /* TO THE TCB TO BE PROCESSED IF NON-SRB PROCESSING*/
*                 /* IS BEING REQUESTED. IF THE CURRENT TCB IS TO BE */
*                 /* PROCESSED, R3=0. TARGSRB (R3) - CONTAINS POINTER*/
*                 /* TO THE SRB TO BE PROCESSED IF THE FUNCTION IS   */
*                 /* PGIOERR PROCESSING AND NO RB ADDRESS WAS PASSED.*/
*                 /* TRAKAREA REGISTER (R4) CONTAINS POINTER TO AN   */
*                 /* AREA FOR TRACKING. THIS AREA WILL CONTAIN AN    */
*                 /* INDICATION OF THE ORIGINAL ENTRY POINT EMPLOYED */
*                 /* BY THE CALLER OF RTM1. IF THIS INDICATION IS A  */
*                 /* SLIH MODE ENTRY POINT THEN THE RTM1WA ASSOCIATED*/
*                 /* WITH THE CURRENT RECOVERY STACK WILL ALSO       */
*                 /* CONTAIN INPUT TO THE RTM. (I.E. PSW AT TIME OF  */
*                 /* ERROR AND POINTER TO AN RTCA IF SRM HAD BEEN    */
*                 /* CALLED TO SERVICE THE ERROR.) DUMPOPTS REGISTER */
*                 /* (R5) - CONTAINS A POINTER TO USER PROVIDED DUMP */
*                 /* PARAMETERS OR ZERO IF NONE. EEDCHAIN REGISTER   */
*                 /* (R6) - CONTAINS A POINTER TO A CHAIN OF EXTENDED*/
*                 /* ERROR DESCRIPTORS (EEDS) ACCUMULATED DURING THE */
*                 /* PROCESSING OF THE RTM1 DURING PREVIOUS          */
*                 /* PROCESSING. IF NO EEDS WERE PREVIOUSLY          */
*                 /* PROCESSED, THIS REGISTER IS ZERO. RBADDR        */
*                 /* REGISTER (R7) CONTAINS A PTR TO THE RB          */
*                 /* ASSOCIATED WITH A PAGE IO ERROR. IF R7 IS ZERO  */
*                 /* FOR A PGIOERR REQUEST, THEN R3 WILL POINT TO AN */
*                 /* SRB. R7 DOES NOT CONTAIN INPUT DATA IF ANY OF   */
*                 /* THE OTHER RESCHEDULE FUNCTIONS ARE REQUESTED.   */
*                 /* OUTPUT IS DESCRIBED IN DETAILED COMMENTARY.     */
*                 /*                                                 */
*                 /***************************************************/
*                                                                  0435
*                 DO;                                              0435
*                   RFY                                            0436
*                     TCB BASED(R3);/* USE THE TCB PASSED AS INPUT   */
*                   RFY                                            0437
*                     RBBASIC BASED(R7);/* USE THE RB PASSED AS INPUT*/
*                   RFY                                            0438
*                     RBSECT BASED(R7);/* USE THE RB PASSED AS INPUT */
*                   RFY                                            0439
*                     RBPREFIX BASED(R7-LENGTH(RBPREFIX));/* SAME AS
*                                      ABOVE                         */
*                   IF(R0=RT1WPGIO& /* IF PGIOERR PROCESSING         */
*                       R7^=NULL&   /* AND AN RB HAD THE ERROR       */
*                       TCBLLH='0'B)×/* AND THE LOCAL LOCK WAS NOT 0440
*                                      HELD WHEN THE RB PAGE FAULTD  */
*                       R0^=RT1WPGIO THEN/* OR IF A REGULAR TCB    0440
*                                      ABTERM FUNCTION WAS REQUESTED */
*                                                                  0440
         CR    R0,@10                                              0440
         BNE   @GL00013                                            0440
         LTR   R7,R7                                               0440
         BZ    @GL00013                                            0440
         TM    TCBLLH(R3),B'00000001'                              0440
         BZ    @RT00440                                            0440
@GL00013 CH    R0,@CH00418                                         0440
         BE    @RF00440                                            0440
@RT00440 DS    0H                                                  0441
*                     /***********************************************/
*                     /*                                             */
*                     /* THE PURPOSE OF THE SCHDRTM2 SEGMENT IS TO   */
*                     /* ESTABLISH THE INTERFACE AND PROVIDE THE     */
*                     /* LINKAGE TO RTM2. THIS FUNCTION INCORPORATES */
*                     /* THE ABTERM FUNCTION OF PREVIOUS RELEASES OF */
*                     /* THE OPERATING SYSTEM. INPUT TO THIS SEGMENT */
*                     /* IS AS FOLLOWS: FUNCTION REGISTER (R0) -     */
*                     /* CONTAINS THE ENTRYPOINT/FUNCTION INDICATOR. */
*                     /* FLAGSCC REGISTER (R1) - CONTAINS THE        */
*                     /* COMPLETION CODE AND CALLRTM FLAGS. SAVAREAP */
*                     /* REGISTER (R13) - CONTAINS A PTR TO THE      */
*                     /* REGISTERS AT TIME OF ERROR IF SLIH MODE, OR */
*                     /* REGISTERS AT TIME OF ENTRY IF SERVICE       */
*                     /* ROUTINE MODE. RECVREGS REGISTER (R12) -     */
*                     /* CONTAINS A PTR TO THE SECONDARY TRACKING    */
*                     /* AREA USED TO CHECKPOINT RECOVERY            */
*                     /* INFORMATION. TARGASID REGISTER (R2) -       */
*                     /* CONTAINS ASID OF ADDRESS SPACE WHERE THE    */
*                     /* ERROR ORIGINALLY WAS DETECTED IF A CROSS    */
*                     /* MEMORY ABTERM REENTRY IS BEING SERVICED.    */
*                     /* OTHERWISE R2=0. TARGTCB (R3) - CONTAINS     */
*                     /* POINTER TO THE TCB TO BE PROCESSED IF       */
*                     /* NON-SRB PROCESSING IS BEING REQUESTED. IF   */
*                     /* THE CURRENT TCB IS TO BE PROCESSED, R3=0.   */
*                     /* TRAKAREA REGISTER (R4) CONTAINS POINTER TO  */
*                     /* AN AREA FOR TRACKING. THIS AREA WILL CONTAIN*/
*                     /* AN INDICATION OF THE ORIGINAL ENTRY POINT   */
*                     /* EMPLOYED BY THE CALLER OF RTM1. IF THIS     */
*                     /* INDICATION IS A SLIH MODE ENTRY POINT THEN  */
*                     /* THE RTM1WA ASSOCIATED WITH THE CURRENT      */
*                     /* RECOVERY STACK WILL ALSO CONTAIN INPUT TO   */
*                     /* THE RTM. (I.E. PSW AT TIME OF ERROR AND     */
*                     /* POINTER TO AN RTCA IF SRM HAD BEEN CALLED TO*/
*                     /* SERVICE THE ERROR.) DUMPOPTS REGISTER (R5) -*/
*                     /* CONTAINS A POINTER TO USER PROVIDED DUMP    */
*                     /* PARAMETERS OR ZERO IF NONE. EEDCHAIN        */
*                     /* REGISTER (R6) - CONTAINS A POINTER TO A     */
*                     /* CHAIN OF EXTENDED ERROR DESCRIPTORS (EEDS)  */
*                     /* ACCUMULATED DURING THE PROCESSING OF THE    */
*                     /* RTM1 DURING PREVIOUS PROCESSING. IF NO EEDS */
*                     /* WERE PREVIOUSLY PROCESSED, THIS REGISTER IS */
*                     /* ZERO. RBADDR REGISTER (R7) CONTAINS A PTR TO*/
*                     /* THE RB ASSOCIATED WITH A PAGE IO ERROR. IF  */
*                     /* R7 IS ZERO FOR A PGIOERR REQUEST, THEN R3   */
*                     /* WILL POINT TO AN SRB. OUTPUT IS AN UPDATED  */
*                     /* TCB, RB AND EEDS IF REQUIRED. INTERMEDIARY  */
*                     /* OUTPUT IS DOCUMENTED IN THE COMMENTARY.     */
*                     /*                                             */
*                     /***********************************************/
*                                                                  0441
*                     DO;           /* START OF SCHDRTM2 SEGMENT     */
*                                                                  0441
*                       /*********************************************/
*                       /*                                           */
*                       /* THE PURPOSE OF THE VALIDITY CHECK SEGMENT */
*                       /* IS TO PREVENT A TASK FROM BEING ABTERMED  */
*                       /* UNNECESSARILY AND TO PREVENT DATA DAMAGE  */
*                       /* FROM BEING INCURRED BY THE RTM1 BECAUSE OF*/
*                       /* BAD INPUT PARAMETERS. AS AN AUXILLARY     */
*                       /* FUNCTION, THE VALIDITY CHECK SEGMENT      */
*                       /* LOCATES THE TCB AND RB TO BE ABTERMED IF  */
*                       /* THEY WERE NOT PROVIDED BY THE CALLING     */
*                       /* ROUTINE. INPUT TO THIS SEGMENT IS AS      */
*                       /* FOLLOWS: FUNCTION REGISTER (R0) - CONTAINS*/
*                       /* AN INDICATION OF WHICH RESCHEDULE MODE    */
*                       /* FUNCTION IS BEING REQUESTED. TARGTCB      */
*                       /* REGISTER (R3) - CONTAINS THE ADDRESS OF   */
*                       /* THE TCB TO BE VALIDITY CHECKED, OR 0      */
*                       /* INDICATING CURRENT. TRAKAREA REGISTER (R4)*/
*                       /* - CONTAINS PTR TO TRACKING AREA FOR CHECK */
*                       /* POINTING CRITICAL REGISTERS. RBADDR       */
*                       /* REGISTER (R7) - CONTAINS POINTER TO THE RB*/
*                       /* TO BE VALIDITY CHECKED OR ZERO INDICATING */
*                       /* HIGHEST RB. OUTPUT FROM THIS SEGMENT IS AS*/
*                       /* FOLLOWS: FUNCTION REGISTER (R0) - CONTAINS*/
*                       /* INDICATION TO TAKE AN EXIT IF ANY OF THE  */
*                       /* VALIDITY CHECKS FAIL OR CONTAINS AN       */
*                       /* INDICATION TO ABTERM CURRENT TASK IF THE  */
*                       /* TARGTCB REGISTER WAS ALTERED TO POINT TO  */
*                       /* THE CURRENT TCB, OR IS LEFT UNCHANGED IF  */
*                       /* VALIDITY CHECKS WENT SUCCESSFULLY FOR A   */
*                       /* NON CURRENT TCB. TARGTCB REGISTER (R3) -  */
*                       /* CONTAINS THE ADDRESS OF THE CURRENT TCB IF*/
*                       /* ABTERM CURRENT FUNCTION OTHERWISE         */
*                       /* UNCHANGED FROM INPUT VALUE. RBADDR        */
*                       /* REGISTER (R7) - CONTAINS POINTER TO       */
*                       /* HIGHEST RB ON RB QUEUE IF NOT PROVIDED ON */
*                       /* INPUT, OTHERWISE, UNCHANGED.              */
*                       /*                                           */
*                       /*********************************************/
*                                                                  0442
*                       DO;         /* START VALIDITY CHECKING       */
*                         IF R3=NULL THEN/* IF REQUEST WAS TO      0443
*                                      SCHEDULE THE CURRENT TCB FOR
*                                      RTM2                          */
*                                                                  0443
         SLR   @10,@10                                             0443
         CR    R3,@10                                              0443
         BNE   @RF00443                                            0443
*                           /*****************************************/
*                           /*                                       */
*                           /* THE FOLLOWING PROCESSING VERIFIES THAT*/
*                           /* A VALID TASK IS CURRENTLY DISPATCHED. */
*                           /* SINCE THE LOCAL LOCK MAY NOT BE HELD  */
*                           /* WHEN ABTERM OF CURRENT IS REQUESTED,  */
*                           /* THE TCBQ CAN NOT BE SEARCHED TO VERIFY*/
*                           /* THE TCB IS ON THE PRIORITY Q          */
*                           /*                                       */
*                           /*****************************************/
*                                                                  0444
*                           DO;     /* START UNIQUE ABTERM CURR TCB  */
*                             R0=ABTRMCUR;/* ADJUST FUNCTION       0445
*                                      INDICATION FOR SUBSEQUENT   0445
*                                      STEPS                         */
         LA    R0,14                                               0445
*                             RT1TREGS(ONE)=R0;/* CHCKPOINT NEW    0446
*                                      FUNCTION VALUE                */
         ST    R0,RT1TREGS(,R4)                                    0446
*                             IF PSATOLD=NULL×/* IF A TASK IS NOT  0447
*                                      CURRENTLY DISPATCHED          */
*                                 PSATOLD->TCBTCBID^=/* OR PSATOLD 0447
*                                      DOES NOT POINT                */
*                                 TCBIDENT THEN/* TO A VALID TCB     */
         L     @08,PSATOLD                                         0447
         CR    @08,@10                                             0447
         BE    @RT00447                                            0447
         CLC   TCBTCBID(4,@08),@CC00201                            0447
         BE    @RF00447                                            0447
@RT00447 DS    0H                                                  0448
*                               R0=TAKEEXIT;/* DISCONTINUE FURTHER 0448
*                                      PROCESNG                      */
         LA    R0,30                                               0448
*                             ELSE  /* IF A VALID TCB IS DISPATCHED  */
*                               DO;                                0449
         B     @RC00447                                            0449
@RF00447 DS    0H                                                  0450
*                                 R3=PSATOLD&HEX7FOXS;/* PLACE THE 0450
*                                      ADDRESS OF THE CURRENTLY    0450
*                                      DISPATCHED TCB IN TARGET TCB
*                                      REGISTER AND INSURE HI ORDER
*                                      BIT IS OFF                    */
         L     R3,PSATOLD                                          0450
         N     R3,@CF00226                                         0450
*                                 RT1TREGS(FOUR)=R3;/* CHECKPOINT TCB
*                                      ADDRESS                       */
         ST    R3,RT1TREGS+12(,R4)                                 0451
*                               END;                               0452
*                           END;    /* END UNIQUE ABTERM CURRENT TCB
*                                      PROCESSING                    */
*                         ELSE      /* IF NOT ABTERM CURRENT FUNCT   */
*                                                                  0454
*                           /*****************************************/
*                           /*                                       */
*                           /* THE PURPOSE FOR THE CKNONCUR SEGMENT  */
*                           /* IS TO VERIFY THAT A TCB WHICH WAS     */
*                           /* PASSED TO THE RTM1 IS ON THE TCB      */
*                           /* PRIORITY QUEUE, AND IF SO, TO INSURE  */
*                           /* THE TASK IS NOT ACTIVE (RUNNING) ON   */
*                           /* ANOTHER CPU. IT IS ASSUMED THAT THE   */
*                           /* LOCAL LOCK IS HELD BY THIS CPU DURING */
*                           /* THE PROCESSING OF THIS SEGMENT. THE   */
*                           /* INPUT TO THIS SEGMENT IS AS FOLLOWS:  */
*                           /* TARGTCB REGISTER (R3) - CONTAINS THE  */
*                           /* TCB TO BE VERIFIED. TRAKAREA REGISTER */
*                           /* (R4) - POINTS TO AREA WHERE CRITICAL  */
*                           /* REGISTERS CAN BE CHECK POINTED. ASXB -*/
*                           /* CONTAINS POINTERS TO BEGINNING AND    */
*                           /* ENDING OF TCB PRIORITY QUEUE. THE     */
*                           /* OUTPUT FROM THIS SEGMENT IS AS        */
*                           /* FOLLOWS: FUNCTION REGISTER (R0) -     */
*                           /* CONTAINS INDICATION TO DISCONTINUE    */
*                           /* FURTHER PROCESSING IF TCB NOT FOUND ON*/
*                           /* QUEUE, OTHERWISE UNCHANGED. THE STATUS*/
*                           /* ROUTINE IS CALLED TO STOP THE         */
*                           /* EXECUTION OF THE TCB IN THE EVENT THAT*/
*                           /* IT WAS ACTIVE ON ANOTHER CPU.         */
*                           /*                                       */
*                           /*****************************************/
*                                                                  0454
*                           DO;     /* START OF CKNONCUR SEGMENT     */
         B     @RC00443                                            0454
@RF00443 DS    0H                                                  0455
*                             RFY                                  0455
*                               R8 RSTD;/* GET CONTROL OF REGISTER   */
*                             R8=ASXBFTCB;/* PRIME A REGISTER WITH 0456
*                                      PTR TO FIRST TCB ON PRTY QUEUE*/
*                                                                  0456
         L     @10,PSAAOLD                                         0456
         L     @10,ASCBASXB(,@10)                                  0456
         L     R8,ASXBFTCB(,@10)                                   0456
*                             /***************************************/
*                             /*                                     */
*                             /* THE FOLLOWING INSTRUCTIONS SET UP A */
*                             /* LOOP TO SEARCH THE TCB PRIORITY     */
*                             /* QUEUE UNTIL EITHER THE TARGET TCB IS*/
*                             /* FOUND ON THE QUEUE OR THE ENTIRE    */
*                             /* QUEUE HAS BEEN SEARCHED.            */
*                             /*                                     */
*                             /***************************************/
*                                                                  0457
*                             DO    /* START TCB SEARCH LOOP         */
*                                   WHILE(R8^=ASXBLTCB&/* KEEP     0457
*                                      LOOPING UNTIL LAST TCB HAS  0457
*                                      BEEN CHECKED OR UNTIL         */
*                                   R8^=R3);/* A MATCH IS FOUND      */
         B     @DE00457                                            0457
@DL00457 DS    0H                                                  0458
*                               R8=R8->TCBTCB;/* POINT TO NEXT TCB ON
*                                      QUEUE                         */
         L     R8,TCBTCB(,R8)                                      0458
*                             END;  /* END TCB SEARCH LOOP           */
@DE00457 L     @10,PSAAOLD                                         0459
         L     @10,ASCBASXB(,@10)                                  0459
         C     R8,ASXBLTCB(,@10)                                   0459
         BE    @DC00457                                            0459
         CR    R8,R3                                               0459
         BNE   @DL00457                                            0459
@DC00457 DS    0H                                                  0460
*                             IF R3^=R8 THEN/* IF A MATCH WAS NOT  0460
*                                      FOUND                         */
         CR    R3,R8                                               0460
         BE    @RF00460                                            0460
*                               R0=TAKEEXIT;/* DISCONTINUE FURTHER 0461
*                                      PROCSNG                       */
         LA    R0,30                                               0461
*                             ELSE  /* IF A MATCH WAS FOUND          */
*                                                                  0462
*                               /*************************************/
*                               /*                                   */
*                               /* INTERFACE WITH THE STATUS ROUTINE */
*                               /* TO STOP THE EXECUTION OF THE TASK */
*                               /* IF IT IS CURRENTLY RUNNING ON     */
*                               /* ANOTHER CPU                       */
*                               /*                                   */
*                               /*************************************/
*                                                                  0462
*                               DO; /* START VALID TCB PROCESSING    */
         B     @RC00460                                            0462
@RF00460 DS    0H                                                  0463
*                                 RFY                              0463
*                                   R8 UNRSTD;/* RELINQUISH CONTROL
*                                      OF REG                        */
*                                 IF R3^=PSATOLD THEN/* IF THE TCB 0464
*                                      PASSED IS NOT THE CURRENTLY 0464
*                                      DISPATCHED TCB ON THIS CPU    */
         C     R3,PSATOLD                                          0464
         BE    @RF00464                                            0464
*                                   DO;/* START TASK STOPPING PROCESS*/
*                                    R13=NULL;/* INDICATE CURRENT  0466
*                                      ASID                          */
         SLR   R13,R13                                             0466
*                                    R0=NOPRIME;/* INDICATE NO     0467
*                                      PRIMARY DISPATCH ABLILITY   0467
*                                      FLAGS TO BE SET               */
         LA    R0,12                                               0467
*                                    R1=R3;/* INDICATE TARGET TCB TO
*                                      STOP                          */
         LR    R1,R3                                               0468
*                                    CALL STATUS;/* STOP THE TASKS 0469
*                                      EXECUTION                     */
         L     @10,CVTPTR                                          0469
         L     @10,CVTABEND(,@10)                                  0469
         L     @15,SCVTSTAT(,@10)                                  0469
         BALR  @14,@15                                             0469
*                                    GEN(LA R11,4095(R9));/* RESTORE
*                                      BASE REG              @G17EP5W*/
         LA R11,4095(R9)
*                                    R0=RT1TREGS(ONE);/* RESTORE   0471
*                                      ORIGINAL CONTENTS OF REG USED
*                                      FOR DISP FLAGS                */
         L     R0,RT1TREGS(,R4)                                    0471
*                                    R1=RT1TREGS(TWO);/* RESTORE   0472
*                                      ORIGINAL CONTENTS OF REG USED
*                                      FOR TCB                       */
         L     R1,RT1TREGS+4(,R4)                                  0472
*                                    R13=R12->RT1TREGS(ONE);/*     0473
*                                      RESTORE ORIG CONTENTS OF REG
*                                      USED FOR ASID                 */
         L     R13,RT1TREGS(,R12)                                  0473
*                                   END;/* END TASK STOPPING PROCESS */
*                               END;/* END VALID TCB PROCESSING      */
@RF00464 DS    0H                                                  0476
*                           END;    /* END NON CURRENT TCB PROCESIN  */
@RC00460 DS    0H                                                  0477
*                         IF R0^=TAKEEXIT THEN/* IF INIT VALIDITY  0477
*                                      CHECKS OK                     */
*                                                                  0477
@RC00443 CH    R0,@CH00352                                         0477
         BE    @RF00477                                            0477
*                           /*****************************************/
*                           /*                                       */
*                           /* VERIFY THAT TASK CAN SUSTAIN ABEND    */
*                           /* PROCESSING                            */
*                           /*                                       */
*                           /*****************************************/
*                                                                  0478
*                           DO;     /* START 2NDARY VALIDITY CHECKS  */
*                             IF TCBABTRM='1'B THEN/* IF TASK HAS  0479
*                                      ALREADY BEEN SET UP FOR ABTERM
*                                      BUT HAS NOT YET ABENDED       */
         TM    TCBABTRM(R3),B'00100000'                            0479
         BNO   @RF00479                                            0479
*                               DO; /* INSURE THAT THE TASK IS     0480
*                                      DISPATCHABLE                  */
*                                 R7=TCBRBP;/* USE HIGHEST RB ON THE
*                                      QUEUE                 @YM06111*/
         L     R7,TCBRBP(,R3)                                      0481
*                                 RFY                              0482
*                                   R8 RSTD;/* GET CONTROL OF REG  0482
*                                                            @YM06111*/
*                                 RFY                              0483
*                                   PSW BASED(ADDR(RBOPSW));/* USE 0483
*                                      PSW IN RB             @YM06111*/
*                                 R8=ENPSWWD×(PSWMODE&ENABLMSK);/* 0484
*                                      INSURE THAT THE FIRST WORD OF
*                                      THE RB'S PSW IS VALID SO THAT
*                                      RTM2 WILL GET CONTROL @YM06111*/
         LA    @10,16                                              0484
         ALR   @10,R7                                              0484
         L     R8,PSWMODE(,@10)                                    0484
         N     R8,@CF00211                                         0484
         O     R8,@CF00209                                         0484
*                                 PSWMODE=R8;/* PLACE VALID FIRST  0485
*                                      WORD IN RB            @YM06111*/
         ST    R8,PSWMODE(,@10)                                    0485
*                                 PSWIC=ADDR(ABENDSVC);/* INSURE THAT
*                                      THE RESUME ADDR POINTS TO AN
*                                      SVC 13 INSTR          @YM06111*/
         LA    @15,ABENDSVC                                        0486
         ST    @15,PSWIC(,@10)                                     0486
*                                 RFY                              0487
*                                   PSW BASED(ADDR(RBRTPSW1));/*   0487
*                                      INSURE THE FIRST WORD OF THE
*                                      PSW PRESERVED IN THE RB PREFIX
*                                      IS VALID              @YM06111*/
*                                 PSWMODE=R8;/* PLACE VALID FIRST  0488
*                                      WORD IN PSW IN RB PREFIX    0488
*                                                            @YM06111*/
         LR    @10,R7                                              0488
         AL    @10,@CF03660                                        0488
         ST    R8,PSWMODE(,@10)                                    0488
*                                 RFY                              0489
*                                   R8 UNRSTD;/* RELEASE WORKREG   0489
*                                                            @YM06111*/
*                                 IF R0^=ABTRMCUR THEN/* IF THE    0490
*                                      FUNCTION IS NOT ABTERM OF THE
*                                      CURRENT TCB THEN IT IS ASSUMED
*                                      THAT THE LOCAL LOCK, NEEDED 0490
*                                      FOR STATUS, IS ALREADY HELD 0490
*                                                            @YA00052*/
         CH    R0,@CH00426                                         0490
         BE    @RF00490                                            0490
*                                   CALL STATUSET;/* CALL STATUS TO
*                                      RESET TASK'S DISPATCHABILITY
*                                      FLAGS                         */
         BAL   @14,STATUSET                                        0491
*                                 R0=TAKEEXIT;/* DISCONTINUE FURTHER
*                                      ABTERM PROCESSING             */
@RF00490 LA    R0,30                                               0492
*                               END;                               0493
*                             ELSE  /* IF THE ABTRM FLAG IS NOT SET,
*                                      CONTINUE WITH FURTHER       0494
*                                      VERIFICATION                  */
*                               IF TCBFC='1'B×/* IF TASK HAS ALREADY
*                                      TERMNATED BUT THE TCB NOT   0494
*                                      FREED, OR                     */
*                                   (PSATOLD=0&/* AN SRB IS        0494
*                                      REQUESTING THE ABTERM @ZA05674*/
*                                   TCBFPRAP='1'B&/* AND ABEND IS  0494
*                                      CURRENTLY PERFORMING CRITICAL
*                                      PROCESSING FOR THIS TCB WHICH
*                                      CANNOT BE INTERRUPTED BY A  0494
*                                      RECURSIVE ABEND       @ZA05674*/
*                                   (RT1TENPT<SRVCLOW×/* AND REQUEST
*                                      NOT SERVICE MODE      @ZA05674*/
*                                   RT1TENPT>SRVCHI))×/* (SERVICE  0494
*                                      REQUESTS ARE SYNCHRONOUS AND
*                                      MUST BE HONORED), OR  @ZA05674*/
*                                   TCBABWF='1'B THEN/* ABEND HAS  0494
*                                      ALREADY DETERMINED THAT THIS
*                                      TASK MUST BE TERMINATED, THEN */
         B     @RC00479                                            0494
@RF00479 TM    TCBFC(R3),B'10000000'                               0494
         BO    @RT00494                                            0494
         ICM   @10,15,PSATOLD                                      0494
         BNZ   @GL00018                                            0494
         TM    TCBFPRAP(R3),B'00010000'                            0494
         BNO   @GL00018                                            0494
         CLI   RT1TENPT(R4),10                                     0494
         BL    @RT00494                                            0494
         CLI   RT1TENPT(R4),19                                     0494
         BH    @RT00494                                            0494
@GL00018 TM    TCBABWF(R3),B'01000000'                             0494
         BNO   @RF00494                                            0494
@RT00494 DS    0H                                                  0495
*                                 R0=TAKEEXIT;/* DISCONTINUE FURTHER
*                                      ABTERM PROCESSING             */
         LA    R0,30                                               0495
*                               ELSE/* IF TASK CAN SUSTAIN AN ABEND  */
*                                 IF R0=RT1WPGIO THEN/* AND IF     0496
*                                      ORIGINAL FUNCTION WAS PAGE IO
*                                      ERR PROCESSING                */
*                                                                  0496
         B     @RC00494                                            0496
@RF00494 CH    R0,@CH00418                                         0496
         BNE   @RF00496                                            0496
*                                   /*********************************/
*                                   /*                               */
*                                   /* THE PURPOSE OF THE VALDCKRB   */
*                                   /* SEGMENT IS TO VERIFY THAT THE */
*                                   /* RB PASSED TO THE RTM1 FOR     */
*                                   /* PGIOERR PROCESSING IS STILL ON*/
*                                   /* THE RB QUEUE AND STILL IN A   */
*                                   /* PAGE WAIT. IT IS POSSIBLE THAT*/
*                                   /* THE RB WAS FORCED OUT OF A    */
*                                   /* PAGE WAIT SITUATION BY AN     */
*                                   /* ASYNCHRONOUS ABEND. IF SO, THE*/
*                                   /* ROUTINE (RB) MAY HAVE         */
*                                   /* TERMINATED OR MAY PRESENTLY BE*/
*                                   /* IN ABEND PROCESSING,          */
*                                   /* THEREFORE, THIS ABTERM REQUEST*/
*                                   /* SHOULD BE IGNORED. IF THE RB  */
*                                   /* IS FOUND, AND IS IN A WAIT    */
*                                   /* STATE, THE ABTERM REQUEST IS  */
*                                   /* PERMITTED TO CONTINUE. INPUT  */
*                                   /* TO THIS SEGMENT IS AS FOLLOWS:*/
*                                   /* RBADDR REGISTER (R7) -        */
*                                   /* CONTAINS PTR TO RB TO BE      */
*                                   /* CHECKED. TARGTCB REGISTER (R4)*/
*                                   /* - CONTAINS PTR TO TCB         */
*                                   /* ASSOCIATED WITH THE RB QUEUE  */
*                                   /* TO BE CHECKED. THE OUTPUT FROM*/
*                                   /* THIS SEGMENT IS AN UPDATED    */
*                                   /* FUNCTION REGISTER (R0) IF THE */
*                                   /* ABTERM PROCESS IS TO BE       */
*                                   /* DISCONTINUED.                 */
*                                   /*                               */
*                                   /*********************************/
*                                                                  0497
*                                   DO;/* START RB VALIDITY CHECKING */
*                                    RFY                           0498
*                                      R8 RSTD;/* GET CONTROL OF   0498
*                                      REGISTER                      */
*                                    R8=TCBRBP;/* PRIME REGISTER WITH
*                                      HIGHEST RB ON QUEUE FOR     0499
*                                      SEARCHING                     */
*                                                                  0499
         L     R8,TCBRBP(,R3)                                      0499
*                                    /********************************/
*                                    /*                              */
*                                    /* THE FOLLOWING INSTRUCTIONS   */
*                                    /* SET UP A LOOP WHICH WILL     */
*                                    /*                        SEARCH*/
*                                    /* EACH ELEMENT OF THE RB QUEUE */
*                                    /* UNTIL A MATCH IS FOUND WITH  */
*                                    /* THE INPUT RB OR UNTIL THE    */
*                                    /* ENTIRE QUEUE HAS BEEN        */
*                                    /* SEARCHED                     */
*                                    /*                              */
*                                    /********************************/
*                                                                  0500
*                                    DO/* START RB SEARCH LOOP       */
*                                         WHILE(R8->RBTCBNXT^='1'B&/*
*                                      LOOP UNTIL THE END OF THE Q IS
*                                      REACHED               @YM02798*/
*                                         R8^=R7);/* OR UNTIL A MATCH
*                                      IS FOUND                      */
         B     @DE00500                                            0500
@DL00500 DS    0H                                                  0501
*                                     R8=R8->RBLINKB;/* POINT TO NEXT
*                                      RB ON QUEUE                   */
         SLR   @10,@10                                             0501
         ICM   @10,7,RBLINKB(R8)                                   0501
         LR    R8,@10                                              0501
*                                    END;/* END RB SEARCH LOOP       */
@DE00500 TM    RBTCBNXT(R8),B'10000000'                            0502
         BO    @DC00500                                            0502
         CR    R8,R7                                               0502
         BNE   @DL00500                                            0502
@DC00500 DS    0H                                                  0503
*                                    IF R7^=R8×/* IF THE RB WAS NOT
*                                      LOCATED OR                    */
*                                        R7=0×/* NO RB       @ZA08436*/
*                                        RBWCF=NULL THEN/* THE RB IS
*                                      NOT IN A WAIT STAT            */
         CR    R7,R8                                               0503
         BNE   @RT00503                                            0503
         LTR   R7,R7                                               0503
         BZ    @RT00503                                            0503
         CLI   RBWCF(R7),0                                         0503
         BNE   @RF00503                                            0503
@RT00503 DS    0H                                                  0504
*                                     R0=TAKEEXIT;/* DISCONTINUE   0504
*                                      FURTHER PROCESS               */
         LA    R0,30                                               0504
*                                    ELSE                          0505
*                                     ;/* IF RB OK LEAV FUNCTION   0505
*                                      ALONE                         */
@RF00503 DS    0H                                                  0506
*                                    RFY                           0506
*                                      R8 UNRSTD;/* RELINQUISH     0506
*                                      CONTROL OF REG                */
*                                   END;/* END RB VALIDITY CHECKING  */
*                                 ELSE/* IF FUNCTION WAS NOT PGIOERR */
*                                   DO;                            0508
         B     @RC00496                                            0508
@RF00496 DS    0H                                                  0509
*                                    R7=TCBRBPX;/* RB VALIDITY     0509
*                                      CHECKING NOT NECESSARY - JUST
*                                      USE THE HIGHEST RB ON THE   0509
*                                      QUEUE. TCBRBPX IS PTR(24)   0509
*                                      DEF(TCBRBP)           @ZA17768*/
         SLR   R7,R7                                               0509
         ICM   R7,7,TCBRBPX(R3)                                    0509
*                                    IF R7=0 THEN/* IF NO RB @ZA08436*/
         LTR   R7,R7                                               0510
         BNZ   @RF00510                                            0510
*                                     R0=TAKEEXIT;/* END RB  @ZA08436*/
         LA    R0,30                                               0511
*                                    ELSE/*                  @ZA08436*/
*                                     R12->RT1TREGS(FOUR)=R7;/*    0512
*                                      CHECKPOINT RB ADDRESS         */
         B     @RC00510                                            0512
@RF00510 ST    R7,RT1TREGS+12(,R12)                                0512
*                                   END;                           0513
@RC00510 DS    0H                                                  0514
*                           END;    /* END 2NDARY VALIDITY CHECKS    */
@RC00496 DS    0H                                                  0514
@RC00494 DS    0H                                                  0514
@RC00479 DS    0H                                                  0515
*                       END;        /* END VALIDITY CHECKING         */
@RF00477 DS    0H                                                  0516
*                       IF R0^=TAKEEXIT THEN/* IF VALIDITY CHECKING
*                                      WENT OK                       */
         CH    R0,@CH00352                                         0516
         BE    @RF00516                                            0516
*                         DO;       /* SET UP THE RTM2 INTERFACE     */
*                           RT1TLPN=RESRTM2;/* LPN=PHASE NUMBER FOR
*                                      RESCHEDULE OF RTM2            */
*                                                                  0518
         MVI   RT1TLPN(R4),X'62'                                   0518
*                           /*****************************************/
*                           /*                                       */
*                           /* THE PURPOSE OF THE TCBRB SEGMENT IS TO*/
*                           /* PLACE ERROR DATA INTO THE TCB AND RB  */
*                           /* OF THE PROGRAM WHICH HAS BEEN SET UP  */
*                           /* FOR RTM2. INPUT IS IN THE RTM1WA IF IN*/
*                           /* SLIH MODE. OTHER INPUT IS VIA         */
*                           /* REGISTERS AS FOLLOWS: FLAGSCC REGISTER*/
*                           /* (R1) CONTAINS COMP CODE AND CALLRTM   */
*                           /* FLAGS. TRAKAREA REGISTER (R4)CONTAINS */
*                           /* POINTER TO TRACKING AREA WHICH IN TURN*/
*                           /* CONTAINS ENTRY POINT DATA. OUTPUT FROM*/
*                           /* THIS SEGMENT IS AN UPDATED RB AND TCB.*/
*                           /*                                       */
*                           /*****************************************/
*                                                                  0519
*                           DO;     /* START TCB / RB UPDATE         */
*                             RFY                                  0520
*                               MODEBYTE BASED(ADDR(RT1WMODE));/* USE
*                                      THE MODE INDICATOR IN THE RTM1
*                                      WORK AREA                     */
*                                                                  0520
*                             /***************************************/
*                             /*                                     */
*                             /* CHECK IF REGISTERS AT TIME OF ERROR */
*                             /* SHOULD BE MOVED INTO THE TCB AND PSW*/
*                             /* INTO THE RB                         */
*                             /*                                     */
*                             /***************************************/
*                                                                  0521
*                             IF RT1TENPT>=SLIHLOW&/* IF OPERATING IN
*                                      SLIH MODE                     */
*                                 RT1TENPT<=SLIHHI THEN/* AND REGS 0521
*                                      (AND PSW) ARE AVAILABLE THEN  */
*                                                                  0521
         CLI   RT1TENPT(R4),1                                      0521
         BL    @RF00521                                            0521
         CLI   RT1TENPT(R4),9                                      0521
         BH    @RF00521                                            0521
*                               /*************************************/
*                               /*                                   */
*                               /* THE FOLLOWING IS PERFORMED ONLY IF*/
*                               /* SLIH MODE ENTRY                   */
*                               /*                                   */
*                               /*************************************/
*                                                                  0522
*                               DO; /* PERFORM UNIQUE SLIH PROCESS   */
*                                                                  0522
*                                 /***********************************/
*                                 /*                                 */
*                                 /* IF RTM1 WAS ENTERED IN UNLOCKED */
*                                 /* TCB MODE WHEN IT WAS OPERATING  */
*                                 /* AS A 2ND LEVEL INTERRUPT        */
*                                 /* HANDLER, THEN RTM1 MUST PERFORM */
*                                 /* THE STATUS SAVING FUNCTION      */
*                                 /* REQUIRED OF ANY INTERRUPT       */
*                                 /* HANDLER FOR UNLOCKED TASKS.     */
*                                 /*                                 */
*                                 /***********************************/
*                                                                  0523
*                                 TCBMODE=RT1WMODE;/* INDICATE SYSTEM
*                                      MODE AT TIME OF INTERRUPT     */
         L     @10,PSACSTK                                         0523
         MVC   TCBMODE(1,R3),RT1WMODE(@10)                         0523
*                                 IF RT1WPSW2^=0 THEN/* IF MORE PSW
*                                      INFO IS AVAILABLE     @YM04289*/
         L     @10,RT1WPSW2(,@10)                                  0524
         LTR   @10,@10                                             0524
         BZ    @RF00524                                            0524
*                                   RBRTRAN=RT1WPSW2->PSWTRAN;/*   0525
*                                      PRESERVE THE TRANSLATION    0525
*                                      EXCEPTION ADDRESS     @YM04289*/
         LR    @08,R7                                              0525
         AL    @08,@CF03678                                        0525
         MVC   RBRTRAN-52(4,@08),PSWTRAN(@10)                      0525
*                                 IF MODETCB='1'B THEN/* IF SYSTEM 0526
*                                      MODE IS UNLOCKED TCB MODE   0526
*                                                            @YM02636*/
@RF00524 L     @10,PSACSTK                                         0526
         TM    MODETCB+80(@10),B'00000001'                         0526
         BNO   @RF00526                                            0526
*                                   DO;/* SAVE STATUS        @YM02636*/
*                                    RBOPSW=RT1WPSW1->PSW;/* MOVE THE
*                                      FIRST HALF OF THE INTERRUPT 0528
*                                      PSW INTO THE RB       @YM02636*/
         L     @08,RT1WPSW1(,@10)                                  0528
         MVC   RBOPSW(8,R7),PSW(@08)                               0528
*                                    IF RT1WPSW2^=0 THEN/* IF MORE 0529
*                                      PSW INFO IS AVAILABLE @YM02636*/
         L     @10,RT1WPSW2(,@10)                                  0529
         LTR   @10,@10                                             0529
         BZ    @RF00529                                            0529
*                                     DO;/* MOVE EXTENDED INFO INTO
*                                      RB                    @YM02636*/
*                                      RBINLNTH=RT1WPSW2->PSWILC;/*
*                                      SAVE ILC              @YM02636*/
         LR    @08,R7                                              0531
         SH    @08,@CH00243                                        0531
         MVC   RBINLNTH(1,@08),PSWILC(@10)                         0531
*                                      RBINTCOD=RT1WPSW2->PSWINTCD;/*
*                                      SAVE THE INT CODE     @YM02636*/
         MVC   RBINTCOD(2,@08),PSWINTCD(@10)                       0532
*                                     END;/* SAVE OF EXTENDED PSW  0533
*                                      INFO COMPLETE         @YM02636*/
*                                    TCBGRS=ERREGS;/* MOVE INTERRUPT
*                                      REGS INTO TCB         @YM02636*/
@RF00529 MVC   TCBGRS(64,R3),ERREGS(R13)                           0534
*                                   END;/* STATUS SAV COMPLETE     0535
*                                                            @YM02636*/
*                               END;/* END UNIQUE SLIH MODE PROCESS  */
*                             ELSE  /* IF NOT IN SLIH MODE           */
*                                                                  0537
*                               /*************************************/
*                               /*                                   */
*                               /* THE FOLLOWING IS PERFORMED ONLY IF*/
*                               /* SERVICE ROUTINE ENTRY             */
*                               /*                                   */
*                               /*************************************/
*                                                                  0537
*                               DO; /* PERFORM UNIQUE SRVE RTN PROC  */
         B     @RC00521                                            0537
@RF00521 DS    0H                                                  0538
*                                 TCBMODE=NULL;/* ZERO OUT THE TCB 0538
*                                      FIELD                         */
         MVI   TCBMODE(R3),X'00'                                   0538
*                                 RFY                              0539
*                                   MODEBYTE BASED(ADDR(TCBMODE));/*
*                                      USE MODE FLAGS IN TCB         */
*                                 MODETCB='1'B;/* INDICATE TASK MODE.
*                                      IF THE RTM IS HANDLING A XMEM
*                                      ABTERM, AND EEDS WERE       0540
*                                      ACQUIRED, THIS FIELD WILL BE
*                                      OVERLAID WITH THE ORIGINAL  0540
*                                      SYSTEM MODE INDICATED IN THE
*                                      EED                           */
         OI    MODETCB+267(R3),B'00000001'                         0540
*                               END;/* END UNIQUE SRVC RTN PROCESS   */
*                                                                  0541
*                             /***************************************/
*                             /*                                     */
*                             /* PRESERVE THE STATUS SAVED EITHER BY */
*                             /* ONE OF THE INTERRUPT HANDLERS OR BY */
*                             /* RTM1.                               */
*                             /*                                     */
*                             /***************************************/
*                                                                  0542
*                             RBRTPSW1=RBOPSW;/* PRESERVE THE OLD PSW*/
@RC00521 LR    @10,R7                                              0542
         SH    @10,@CH00243                                        0542
         MVC   RBRTPSW1(8,@10),RBOPSW(R7)                          0542
*                             RBRTILC=RBINLNTH;/* PRESERVE THE ILC   */
         MVC   RBRTILC(1,@10),RBINLNTH(@10)                        0543
*                             RBRTINCD=RBINTCOD;/* PRESERVE THE    0544
*                                      INTERRUPT CODE                */
         MVC   RBRTINCD(2,@10),RBINTCOD(@10)                       0544
*                             TCBABGM='1'B;/* INDICATE THAT GETMAIN
*                                      REQUESTS FOR LSQA SHOULD BE 0545
*                                      CONVERTED TO SQA IF LSQA NOT
*                                      AVAILABLE - THIS INURES THE 0545
*                                      TERMINATION PROCESS WILL NOT
*                                      FAIL IF THE MEMORY IS OUT OF
*                                      SPACE                         */
         OI    TCBABGM(R3),B'00010000'                             0545
*                             TCBERTYP=RT1TENPT;/* PLACE ORIGINAL  0546
*                                      ENTRYPOINT INDICATION IN TCB.
*                                      IF THE RTM IS HANDLING A XMEM
*                                      ABTERM, AND EEDS WERE       0546
*                                      ACQUIRED, THIS FIELD WILL BE
*                                      OVERLAID WITH THE ORIGINAL  0546
*                                      ENTRY PT FOR THE PROCESSING IN
*                                      THE ORIGINAL ADDRESS SPACE    */
         MVC   TCBERTYP(1,R3),RT1TENPT(R4)                         0546
*                             TCBABTRM='1'B;/* INDICATE TASK HAS BEEN
*                                      ABTERMED (SET UP FOR RTM2) BUT
*                                      NOT YET ABENDED (RTM2 HAS NOT
*                                      YET PERFORMED ITS           0547
*                                      INITIALIZATION FOR THIS TASK) */
         OI    TCBABTRM(R3),B'00100000'                            0547
*                             TCBFX='1'B;/* TURN ON BIT TO PREVENT 0548
*                                      ASYNCHRONOUS EXITS    @YM01957*/
         OI    TCBFX(R3),B'00000001'                               0548
*                             RFY                                  0549
*                               PSW BASED(ADDR(RBOPSW));/* USE PSW IN
*                                      RB                            */
*                             PSWECTM='1'B;/* ENSURE EC MODE SO SVC
*                                      FLIH RECOGNIZE INTERRUPT    0550
*                                                            @ZA03293*/
         LA    @08,16                                              0550
         ALR   @08,R7                                              0550
         OI    PSWECTM(@08),B'00001000'                            0550
*                             PSWIC=ADDR(ABENDSVC);/* POINT THE    0551
*                                      RESUME ADDR IN THE PSW TO AN
*                                      SVC 13 INSTRUCTION            */
         LA    @15,ABENDSVC                                        0551
         ST    @15,PSWIC(,@08)                                     0551
*                             RT1TLPN=TCBTERM;/* LPN=PHASE NUM TO  0552
*                                      INDICATE THE TASK IS LOGICALLY
*                                      TERMINATED                    */
         MVI   RT1TLPN(R4),X'63'                                   0552
*                             RBWCSA=RBWCF;/* PRESERVE THE ORIGINAL
*                                      WAIT COUNT (WILL BE ZEROED)   */
         MVC   RBWCSA(1,@10),RBWCF(R7)                             0553
*                             TCBCMP=R1;/* STORE THE COMPLETION CODE
*                                      IN TO THE TCB                 */
         ST    R1,TCBCMP(,R3)                                      0554
*                           END;    /* END TCB/RB UPDATE             */
*                           RFY                                    0556
*                             MODEBYTE BASED(ADDR(TCBMODE));/* USE 0556
*                                      MODE FLAGS IN TCB             */
*                           IF(TCBERTYP>=SRVCLOW&/* IF ENTERED AS A
*                                      SERVICE RTN                   */
*                               TCBERTYP<=SRVCHI)×/* OR              */
*                               TCBERTYP=RT1WMCHR×/* ENTERED BECAUSE
*                                      OF MACHCK                     */
*                               MODETCB='0'B THEN/* OR A SYSTEM ERROR
*                                      OCCURRED                      */
         CLI   TCBERTYP(R3),10                                     0557
         BL    @GL00028                                            0557
         CLI   TCBERTYP(R3),19                                     0557
         BNH   @RT00557                                            0557
@GL00028 CLI   TCBERTYP(R3),5                                      0557
         BE    @RT00557                                            0557
         TM    MODETCB+267(R3),B'00000001'                         0557
         BNZ   @RF00557                                            0557
@RT00557 DS    0H                                                  0558
*                             DO;   /* PROCESS EEDS                  */
*                               IF RT1TENPT^=RT1WABT3 THEN/* IF RTM1
*                                      IS NOT CURRENTLY HANDLING A 0559
*                                      CROSS MEM ABTERM REENTRY THEN */
         CLI   RT1TENPT(R4),13                                     0559
         BE    @RF00559                                            0559
*                                 DO;                              0560
*                                   RT1TLPN=RT2EEDS;/* LPN=PHASE   0561
*                                      NUMBER FOR EED PROCESSING   0561
*                                      DURING SCHEDULING OF RTM2     */
         MVI   RT1TLPN(R4),X'5C'                                   0561
*                                   CALL EEDPROC;/* GO SEE IF EEDS 0562
*                                      CAN BE ACCUMULATED            */
         BAL   @14,EEDPROC                                         0562
*                                 END;                             0563
*                               ELSE                               0564
*                                 ; /* OTHERWISE, IF THIS IS A CROSS
*                                      MEM ABTERM REENTRY THEN THE 0564
*                                      EEDS HAVE ALREADY BEEN      0564
*                                      ACCUMULATED, AND ARE POINTED
*                                      TO BY THE EEDCHAIN REGISTER 0564
*                                      (R6)                          */
@RF00559 DS    0H                                                  0565
*RT2EEDRP:                          /* RETURN POINT FROM FRR IF    0565
*                                      GETCELL FAILURE OCCURS        */
*                               GEN(LA R11,4095(R9));/* RESTORE BASE
*                                      REG                   @G17EP5W*/
RT2EEDRP LA R11,4095(R9)
*                               RT1TLPN=TCBTERM;/* LPN=PHASE NUM FOR
*                                      FURTHER PROCESSING AFTER TCB
*                                      HAS BEEN LOGICALLY TERMINATED */
         MVI   RT1TLPN(R4),X'63'                                   0566
*                               TCBRTM12=R6;/* PLACE ORIGIN OF EED 0567
*                                      CHAIN IN THE TCB              */
         ST    R6,TCBRTM12(,R3)                                    0567
*                               R6=NULL;/* INDICATE TO THE EXIT    0568
*                                      FUNCTION THAT NO EEDS ARE TO
*                                      BE FREED                      */
         SLR   R6,R6                                               0568
*                               R12->RT1TREGS(THREE)=R6;/* CHECKPOINT
*                                      NEW VALUE OF EEDCHAIN REGISTER*/
         ST    R6,RT1TREGS+8(,R12)                                 0569
*                               IF TCBRTM12>EEDNULL&/* IF AT LEAST 0570
*                                      ONE EED WAS PLACED ON THE   0570
*                                      QUEUE, AND                    */
*                                   RT1TENPT=RT1WABT3 THEN/* THE   0570
*                                      CURRENT ERROR IS A CROSS    0570
*                                      MEMORY ABTERM REENTRY THEN    */
         L     @10,TCBRTM12(,R3)                                   0570
         CH    @10,@CH00073                                        0570
         BNH   @RF00570                                            0570
         CLI   RT1TENPT(R4),13                                     0570
         BNE   @RF00570                                            0570
*                                 DO;/* GET ORIG ERR DATA IN TCB     */
*                                   RFY                            0572
*                                     EED BASED(TCBRTM12);/* USE   0572
*                                      FIRST EED IN THE EED CHAIN    */
*                                   TCBERTYP=EEDERTYP;/* MOVE THE  0573
*                                      ORIGINAL ENTRY POINT INDICATOR
*                                      INTO THE TCB, IN SRB        0573
*                                      PERCOLATION PROCESSING THE  0573
*                                      ENTRY TYPE THAT CAUSED THE SRB
*                                      TO FAIL WOULD BE PLACED INTO
*                                      THE TCB, RATHER THAN THE    0573
*                                      XMABTERM ENTRY PT             */
         MVC   TCBERTYP(1,R3),EEDERTYP(@10)                        0573
*                                   TCBMODE=EEDMODE;/* MOVE THE    0574
*                                      ORIGINAL MODE MODE INDICATOR
*                                      INTO TCB                      */
         MVC   TCBMODE(1,R3),EEDMODE(@10)                          0574
*                                 END;/* END ORIG DATA PROCESSING    */
*                               ELSE                               0576
*                                 ; /* OTHERWISE, IF THE ORIGINAL  0576
*                                      DATA IS LOST, LEAVE THE TCB 0576
*                                      WITH THE DEFAULT SETTINGS SET
*                                      BY THE TCBRB SEGMENT          */
@RF00570 DS    0H                                                  0577
*                             END;  /* END EED PROCESSING            */
*                           ELSE                                   0578
*                             ;     /* OTHERWISE NO EEDS NEEDED      */
*                                                                  0578
@RF00557 DS    0H                                                  0579
*                           /*****************************************/
*                           /*                                       */
*                           /* THE FOLLOWING CODE INTERFACES WITH THE*/
*                           /* POST AND STATUS ROUTINES TO FORCE THE */
*                           /* TASK TO BE DISPATCHABLE               */
*                           /*                                       */
*                           /*****************************************/
*                                                                  0579
*                           IF R0^=ABTRMCUR THEN/* IF THE FUNCTION IS
*                                      NOT ABTERM OF THE CURRENT TCB
*                                      THEN IT IS ASSUMED THAT THE 0579
*                                      LOCAL LOCK, NEEDED FOR THE  0579
*                                      POST AND STATUS ROUTINES IS 0579
*                                      ALREADY HELD                  */
         CH    R0,@CH00426                                         0579
         BE    @RF00579                                            0579
*                             DO;   /* FORCE THE TASK DISPATCHABLE   */
*                               RFY                                0581
*                                 R10 RSTD;/* GET CONTROL OF REG FOR
*                                      POST                          */
*                               DO WHILE RBWCF^=NULL;/* LOOP UNTIL 0582
*                                      WAIT COUNT GOES TO ZERO       */
         B     @DE00582                                            0582
@DL00582 DS    0H                                                  0583
*                                 R10=R7;/* INDICATE RB TO POST      */
         LR    R10,R7                                              0583
*                                 GEN(SR 11,11);/* INDICATE POST   0584
*                                      WITHOUT ECB                   */
         SR 11,11
*                                 CALL POST;/* POST THE RB           */
         L     @08,CVTPTR                                          0585
         L     @15,CVT0PT01(,@08)                                  0585
         BALR  @14,@15                                             0585
*                                 GEN(LA R11,4095(R9));/* ESTABLISH
*                                      BASE REG              @G17EP5W*/
         LA R11,4095(R9)
*                               END;/* END WAIT COUT LOOP            */
@DE00582 CLI   RBWCF(R7),0                                         0587
         BNE   @DL00582                                            0587
*                               RFY                                0588
*                                 R10 UNRSTD;/* FREE POST REG        */
*                               CALL STATUSET;/* CALLS TO STATUS TO
*                                      RESET TASK'S DISPATCHABILITY
*                                      FLAGS                         */
         BAL   @14,STATUSET                                        0589
*                             END;  /* END FORCE DISPATCHABLE CODE   */
*                           ELSE                                   0591
*                             ;     /* IF THE TASK IS CURRENT THEN IT
*                                      IS ALREADY DISPATCHABLE       */
@RF00579 DS    0H                                                  0592
*                         END;      /* END INTERFACE SET UP PROCESS  */
*                     END;          /* END OF SCHDRTM2 SEGMENT       */
*                   ELSE            /* IF NOT RTM2 FUNCTION          */
*                     DO;           /* THEN MUST BE RTM1 FUNCTION    */
*                                                                  0594
         B     @RC00440                                            0594
@RF00440 DS    0H                                                  0595
*                       /*********************************************/
*                       /*                                           */
*                       /* ACQUIRE RESOURCES FOR SCHEDULE RTM1       */
*                       /* FUNCTION                                  */
*                       /*                                           */
*                       /*********************************************/
*                                                                  0595
*                       RFY                                        0595
*                         R8 RSTD;  /* GET CONTROL OF A WORK REG     */
*                       R8=ADDR(RT1TREGS(1));/* POINT TO REGISTER  0596
*                                      CHECKPOINT SECTION OF FRRPARM
*                                      AREA                          */
         LA    R8,RT1TREGS(,R4)                                    0596
*                       R0=RT1CPOOL;/* POINT RT1S CELLPOOL ID IN A 0597
*                                      PARAMETER REGISTER            */
         L     R0,RT1CPOOL                                         0597
*                       RFY                                        0598
*                         R15 RSTD; /* GET CONTROL OF REG            */
*                       RT1TLPN=RT1EEDS;/* LPN=PHASE NUMBER FOR EED
*                                      PROCESSING DURING RESCHEDULE
*                                      OF RTM1                       */
         MVI   RT1TLPN(R4),X'5D'                                   0599
*                       GEN(GETCELL CPID=(0),BRANCH=YES,SAVE=NO);/*
*                                      ACQUIRE A CELL FOR STATUS   0600
*                                      SAVING                        */
         GETCELL CPID=(0),BRANCH=YES,SAVE=NO
*                       GEN(LA R11,4095(R9));/* RESTORE BASE REG   0601
*                                                            @G17EP5W*/
         LA R11,4095(R9)
*                       IF R15=NULL THEN/* IF A CELL WAS RETURNED  0602
*                                      THEN                          */
         LTR   R15,R15                                             0602
         BNZ   @RF00602                                            0602
*                         R6=R1;    /* PUT ITS ADDRESS IN A REG      */
         LR    R6,R1                                               0603
*                       ELSE        /* IF A CELL WAS NOT OBTAINED    */
*                         R6=EEDNULL;/* INDICATE NO CELL AVAILABLE   */
         B     @RC00602                                            0604
@RF00602 LA    R6,1                                                0604
*                       GEN(LM R0,R4,0(R8));/* RELOAD REGS WITH    0605
*                                      ORIGINAL CONTENTS             */
@RC00602 DS    0H                                                  0605
         LM R0,R4,0(R8)
*RT1EEDRP:                          /* RETURN PT FROM FRR IF GETCELL
*                                      FAILURE OCCURS                */
*                       GEN(LA R11,4095(R9));/* RESTORE BASE REG   0606
*                                                            @G17EP5W*/
RT1EEDRP LA R11,4095(R9)
*                       RT1TLPN=RESRTM1;/* LPN=PHASE NUMBER FOR    0607
*                                      RESCHEDULE OF RTM1            */
         MVI   RT1TLPN(R4),X'64'                                   0607
*                       R12->RT1TREGS(THREE)=R6;/* CHECKPOINT NEW  0608
*                                      VALUE OF EEDCHAIN REGISTER    */
         ST    R6,RT1TREGS+8(,R12)                                 0608
*                       RFY                                        0609
*                         R15 UNRSTD;/* RELINQUISH CONTROL OF REG    */
*                       RFY                                        0610
*                         R8 UNRSTD;/* RELINQUISH CONTROL OF REG     */
*                                                                  0610
*                       /*********************************************/
*                       /*                                           */
*                       /* THE PURPOSE OF THE SCHDRTM1 SEGMENT IS TO */
*                       /* CAUSE A SUSPENDED LOCALLY LOCKED TASK, OR */
*                       /* A SUSPENDED SRB TO ISSUE AN ABEND         */
*                       /* INSTRUCTION WHEN IT IS BROUGHT OUT OF     */
*                       /* SUSPENSION (I.E. WHEN IT IS DISPATCHED).  */
*                       /* THIS PROCESSING IS PERFORMED IF THE CAUSE */
*                       /* FOR SUSPENSION WAS A PAGE FAULT, AND THE  */
*                       /* PAGE COULD NOT BE BROUGHT IN FROM         */
*                       /* SECONDARY STORAGE. INPUT TO THIS SEGMENT  */
*                       /* IS AS FOLLOWS: FUNCTION REGISTER (R0) -   */
*                       /* CONTAINS THE ENTRYPOINT/FUNCTION          */
*                       /* INDICATOR. FLAGSCC REGISTER (R1) -        */
*                       /* CONTAINS THE COMPLETION CODE AND CALLRTM  */
*                       /* FLAGS. RECVREGS REGISTER (R12) - CONTAINS */
*                       /* A PTR TO THE SECONDARY TRACKING AREA USED */
*                       /* TO CHECKPOINT RECOVERY INFORMATION.       */
*                       /* TARGTCB (R3) - CONTAINS POINTER TO THE TCB*/
*                       /* TO BE PROCESSED IF NON-SRB PROCESSING IS  */
*                       /* BEING REQUESTED. TARGSRB (R3) - CONTAINS  */
*                       /* POINTER TO THE SRB TO BE PROCESSED IF THE */
*                       /* FUNCTION IS PGIOERR PROCESSING AND NO RB  */
*                       /* ADDRESS WAS PASSED. TRAKAREA REGISTER (R4)*/
*                       /* CONTAINS POINTER TO AN AREA FOR TRACKING. */
*                       /* RBADDR REGISTER (R7) CONTAINS A PTR TO THE*/
*                       /* RB ASSOCIATED WITH A PAGE IO ERROR. IF R7 */
*                       /* IS ZERO FOR A PGIOERR REQUEST, THEN R3    */
*                       /* WILL POINT TO AN SRB. THE SSRB AND IHSA   */
*                       /* ARE ALSO INPUT TO THIS SEGMENT. OUTPUT IS */
*                       /* AN UPDATED SSRB OR IHSA.                  */
*                       /*                                           */
*                       /*********************************************/
*                                                                  0611
*                       DO;         /* START OF SCHDRTM1 SEGMENT     */
*                         IF R6^=EEDNULL THEN/* IF AN EED WAS      0612
*                                      OBTAINED                      */
         CH    R6,@CH00073                                         0612
         BE    @RF00612                                            0612
*                           DO;     /* FILL IN COMMON PARTS OF EED   */
*                             RFY                                  0614
*                               EED BASED(R6);/* USE JUST GOTTEN EED
*                                      CELL FOR MAPPING MACRO BASE   */
*                             EED=''B;/* ZERO OUT ENTIRE EED CELL    */
         XC    EED(92,R6),EED(R6)                                  0615
*                             EEDERTYP=R0;/* PRESERVE THE ENTRY PT 0616
*                                      FUNCTN                        */
         STC   R0,EEDERTYP(,R6)                                    0616
*                             EEDID=REGSPTYP;/* INDICATE EED CONTAINS
*                                      REGS                          */
         MVI   EEDID(R6),X'01'                                     0617
*                             EEDINTCD=PAGEFALT;/* INDICATE ORIGINAL
*                                      PROGRAM INTERRUPTION WAS A  0618
*                                      PAGEFAULT                     */
         MVC   EEDINTCD(2,R6),@CH00199                             0618
*                           END;    /* END COMMON EED PROCESSING     */
*                         IF R7=NULL THEN/* IF AN SRB SUFFERED THE 0620
*                                      ERR                           */
@RF00612 LTR   R7,R7                                               0620
         BNZ   @RF00620                                            0620
*                           DO;     /* SET SRB UP FOR ENTRY TO RTM1  */
*                             IF R6^=EEDNULL THEN/* IF AN EED WAS  0622
*                                      OBTAINED                      */
         CH    R6,@CH00073                                         0622
         BE    @RF00622                                            0622
*                               DO; /* FILL IN INTERRUPT INFORMATON  */
*                                 RFY                              0624
*                                   MODEBYTE BASED(ADDR(EEDMODE));/*
*                                      POINT TO EEDMODE              */
*                                 MODESRB='1'B;/* INDICATE CPU WAS IN
*                                      SRB MODE                      */
         OI    MODESRB+8(R6),B'00000010'                           0625
*                                 RFY                              0626
*                                   SSRBSECT BASED(R3);/* USE SSRB 0626
*                                      PASSED AS INPUT               */
*                                 EEDPSW1=SSRBCPSW;/* MOVE IN PSW AT
*                                      TIME OF PAGE FAULT            */
         MVC   EEDPSW1(8,R6),SSRBCPSW(R3)                          0627
*                                 EEDTRANS=SSRBTRAN;/* MOVE IN     0628
*                                      ADDRESS CAUSING THE PAGE    0628
*                                      EXCEPTION                     */
         MVC   EEDTRANS(4,R6),SSRBTRAN(R3)                         0628
*                                 EEDREGS=SSRBGPRS;/* MOVE IN      0629
*                                      REGISTERS AT TIME OF PAGE   0629
*                                      FAULT                         */
         MVC   EEDREGS(64,R6),SSRBGPRS(R3)                         0629
*                               END;/* END FILLING IN OF EED         */
*                             RFY                                  0631
*                               ERREGS BASED(ADDR(SSRBGPRS));/* BASE
*                                      REGISTER SAVE AREA STRUCTURE
*                                      ON THE REGS IN SSRB TO BE   0631
*                                      DISPATCHED                    */
@RF00622 DS    0H                                                  0632
*                             ERREG0=R6;/* PASS THE EED, OR THE    0632
*                                      EEDNULL INDICATOR TO IEAVTRT1 */
         LA    @10,88                                              0632
         ALR   @10,R3                                              0632
         ST    R6,ERREG0(,@10)                                     0632
*                             ERREG1=R1;/* PASS COMPCODE TO IEAVTRT1 */
         ST    R1,ERREG1(,@10)                                     0633
*                             RFY                                  0634
*                               PSW BASED(ADDR(SSRBCPSW));/* BASE THE
*                                      PSW MAPPING ON THE RESUME PSW */
*                             PSWECTM='1'B;/* ENSURE EC MODE SO SVC
*                                      FLIH WILL RECOGNIZE INTERRUPT
*                                                            @ZA03293*/
         LA    @10,48                                              0635
         ALR   @10,R3                                              0635
         OI    PSWECTM(@10),B'00001000'                            0635
*                             PSWIC=ADDR(ABENDSVC);/* ALTER THE    0636
*                                      RESUME PSW TO POINT TO AN   0636
*                                      ABEND SVC                     */
         LA    @08,ABENDSVC                                        0636
         ST    @08,PSWIC(,@10)                                     0636
*                           END;    /* END SRB SET UP PROCESSING     */
*                         ELSE      /* IF LOCAL LOCKED TASK SUFFERED
*                                      THE PAGE IO ERROR, THEN       */
*                           DO;     /* SET SRB UP FOR ENTRY TO RTM1  */
         B     @RC00620                                            0638
@RF00620 DS    0H                                                  0639
*                             IF R6^=EEDNULL THEN/* IF AN EED WAS  0639
*                                      OBTAINED                      */
         CH    R6,@CH00073                                         0639
         BE    @RF00639                                            0639
*                               DO; /* FILL IN INTERRUPT INFORMATON  */
*                                 RFY                              0641
*                                   MODEBYTE BASED(ADDR(EEDMODE));/*
*                                      POINT TO EEDMODE              */
*                                 RFY                              0642
*                                   ASCB BASED(PSAAOLD);/* USE     0642
*                                      CURRENT ADDRESS SPACE         */
*                                 MODELOC='1'B;/* INDICATE CPU WAS IN
*                                      LOCALLY LOCKED TASK MODE      */
         OI    MODELOC+8(R6),B'00001000'                           0643
*                                 EEDPSW1=IHSACPSW;/* MOVE IN PSW AT
*                                      TIME OF PAGE FAULT            */
         L     @10,PSAAOLD                                         0644
         L     @10,ASCBASXB(,@10)                                  0644
         L     @10,ASXBIHSA(,@10)                                  0644
         MVC   EEDPSW1(8,R6),IHSACPSW(@10)                         0644
*                                 EEDTRANS=RBRTRAN;/* MOVE IN ADDRESS
*                                      CAUSING THE PAGE EXCEPTION    */
         LR    @08,R7                                              0645
         AL    @08,@CF03678                                        0645
         MVC   EEDTRANS(4,R6),RBRTRAN-52(@08)                      0645
*                                 EEDREGS=IHSAGPRS;/* MOVE IN      0646
*                                      REGISTERS AT TIME OF PAGE   0646
*                                      FAULT                         */
         MVC   EEDREGS(64,R6),IHSAGPRS(@10)                        0646
*                               END;/* END FILLING IN OF EED         */
*                             RFY                                  0648
*                               ERREGS BASED(ADDR(IHSAGPRS));/* BASE
*                                      REGISTER SAVE AREA STRUCTURE
*                                      ON THE REGS IN IHSA TO BE   0648
*                                      DISPATCHED                    */
@RF00639 DS    0H                                                  0649
*                             ERREG0=R6;/* PASS THE EED, OR THE    0649
*                                      EEDNULL INDICATOR TO IEAVTRT1 */
         L     @10,PSAAOLD                                         0649
         L     @10,ASCBASXB(,@10)                                  0649
         L     @10,ASXBIHSA(,@10)                                  0649
         LA    @08,56                                              0649
         ALR   @08,@10                                             0649
         ST    R6,ERREG0(,@08)                                     0649
*                             ERREG1=R1;/* PASS COMPCODE TO IEAVTRT1 */
         ST    R1,ERREG1(,@08)                                     0650
*                             RFY                                  0651
*                               PSW BASED(ADDR(IHSACPSW));/* BASE THE
*                                      PSW MAPPING ON THE RESUME PSW */
*                             PSWECTM='1'B;/* ENSURE EC MODE SO SVC
*                                      FLIH WILL RECOGNIZE INTERRUPT
*                                                            @ZA03293*/
         AH    @10,@CH00131                                        0652
         OI    PSWECTM(@10),B'00001000'                            0652
*                             PSWIC=ADDR(ABENDSVC);/* ALTER THE    0653
*                                      RESUME PSW TO POINT TO AN   0653
*                                      ABEND SVC                     */
         LA    @08,ABENDSVC                                        0653
         ST    @08,PSWIC(,@10)                                     0653
*                           END;    /* END LOCAL TASK PROCESSING     */
*                         R6=NULL;  /* PREVENT THE EXIT PROCESSING 0655
*                                      FROM FREEING THE EED          */
@RC00620 SLR   R6,R6                                               0655
*                         R12->RT1TREGS(TWO)=R6;/* CHECKPOINT NEW  0656
*                                      VALUE OF EEDCHAIN REGISTER    */
         ST    R6,RT1TREGS+4(,R12)                                 0656
*                       END;        /* END SCHEDULING OF RTM1        */
*                     END;          /* END RESCHEDULE RTM1 PROCESIN  */
*                 END;              /* END RESCHEDULE MODE           */
@RC00440 DS    0H                                                  0660
*               IF R0=RT1WMEMT THEN /* IF MEMTERM FUNCTION REQUEST   */
*                                                                  0660
@RF00434 CH    R0,@CH00429                                         0660
         BNE   @RF00660                                            0660
*                 /***************************************************/
*                 /*                                                 */
*                 /* THE PURPOSE OF THE MEMTERM SEGMENT IS TO        */
*                 /* SCHEDULE AN ADDRESS SPACE FOR TERMINATION. THIS */
*                 /* INVOLVES VERIFYING THAT THE ASID PASSED IS      */
*                 /* VALID, QUEUEING THE ASCB ON THE TERMINATION     */
*                 /* QUEUE, AND NOTIFYING THE MEMORY TERMINATION     */
*                 /* CONTROLLER THAT AN ADDRESS SPACE IS TO BE       */
*                 /* PROCESSED. INPUT IS AS FOLLOWS: TARGASID        */
*                 /* REGISTER (R2) - CONTAINS THE ASID OF THE ADDRESS*/
*                 /* SPACE TO BE TERMINATED, OR CONTAINS ZERO        */
*                 /* INDICATING THE CURRENTLY LOADED ADDRESS SPACE.  */
*                 /* FLAGSCC REGISTER (R1) - CONTAINS THE COMPLETION */
*                 /* CODE ASSOCIATED WITH THIS MEMTERM REQUEST.      */
*                 /* TRAKAREA REGISTER (R4) - POINTS TO A TRACKING   */
*                 /* AREA FOR CHECKPOINTING CRITICAL REGISTERS.      */
*                 /* ADDITIONALLY REGS R5 AND R6 ARE ASSUMED         */
*                 /* RESTRICTED AND AVAILABLE FOR USE AS WORK REGS.  */
*                 /* THE RTCT, ASCB AND ASVT ARE ALSO INPUT TO THIS  */
*                 /* SEGMENT. OUTPUT IS AN UPDATED FUNCTION REGISTER */
*                 /* IF THE VALIDITY CHECKS FAILED OR AN UPDATED RTCT*/
*                 /* AND ASCB IF THE MEMTERM WAS PROCESSED.          */
*                 /*                                                 */
*                 /***************************************************/
*                                                                  0661
*                 DO;               /* START OF MEMTERM SEGMENT      */
*                   RFY                                            0662
*                     R8 RSTD;      /* GET CONTROL OF REG FOR ASCB 0662
*                                      ADDRESS                       */
*                   CALL ASIDCK;    /* VALIDITY CHECK THE ASID       */
         BAL   @14,ASIDCK                                          0663
*                   RFY                                            0664
*                     ASCB BASED(R8);/* USE ASCB LOCATED BY ASIDCK 0664
*                                      SEGMENT                       */
*                   IF R2<=MASTASID THEN/* IF AN ATTEMPT HAS BEEN  0665
*                                      MADE TO MEMTERM THE MASTER  0665
*                                      ADDRESS SPACE,        @Z40WPXH*/
         CH    R2,@CH00073                                         0665
         BH    @RF00665                                            0665
*                     R0=TAKEEXIT;  /* TAKE IMMEDIATE EXIT           */
         LA    R0,30                                               0666
*                   ELSE            /* IF NOT THE MASTERS ASID       */
*                     DO;           /* SCHEDULE MEMORY TERMINATION   */
         B     @RC00665                                            0667
@RF00665 DS    0H                                                  0668
*                       IF R0^=TAKEEXIT THEN/* IF THE VALIDITY CHECKS
*                                      WENT OK                       */
         LA    @10,30                                              0668
         CR    R0,@10                                              0668
         BE    @RF00668                                            0668
*                         DO;       /* PROCESS THE ASCB              */
*                           IF ASCBTERM='1'B THEN/* IF THE ADDRESS 0670
*                                      SPACE HAS ALREADY BEEN QUEUED
*                                      FOR TERMINATION               */
         TM    ASCBTERM(R8),B'00010000'                            0670
         BNO   @RF00670                                            0670
*                             R0=TAKEEXIT;/* TAKE AN EXIT            */
         LR    R0,@10                                              0671
*                           ELSE    /* IF NOT QUEUED FOR TERMINATON  */
*                             DO;   /* PLACE ON TERMINATION QUEUE    */
         B     @RC00670                                            0672
@RF00670 DS    0H                                                  0673
*                               RT1TLPN=MEMTERM;/* LPN=PHASE NUMBER
*                                      FOR PLACING ASCB ON MEMTERM 0673
*                                      QUEUE                         */
         MVI   RT1TLPN(R4),X'65'                                   0673
*                               ASCBTERM='1'B;/* INDICATE ADDRESS  0674
*                                      SPACE HAS BEEN SET UP FOR   0674
*                                      TERMINATION                   */
         OI    ASCBTERM(R8),B'00010000'                            0674
*                               ASCBMCC=R1;/* STORE THE COMPLETION 0675
*                                      CODE INTO THE ASCB    @ZA16855*/
         ST    R1,ASCBMCC(,R8)                                     0675
*                               IF(R1&'00FFF000'X)/4096^=NULL THEN/*
*                                      IF A NON ZERO COMPLETION WAS
*                                      PASSED THEN           @ZA16855*/
         SLR   @10,@10                                             0676
         LR    @14,R1                                              0676
         N     @14,@CF03608                                        0676
         SRL   @14,12                                              0676
         CR    @14,@10                                             0676
         BE    @RF00676                                            0676
*                                 DO;/*                      @ZA16855*/
*                                   ASCBABNT='1'B;/* INDICATE THAT 0678
*                                      THIS IS AN ABNORMAL         0678
*                                      TERMINATION           @ZA16855*/
*                                                                  0678
         OI    ASCBABNT(R8),B'00001000'                            0678
*                                   /*********************************/
*                                   /*                               */
*                                   /* THIS SEGMENT PERFORMS THE     */
*                                   /* FUNCTION OF ROUTING TO SLIP   */
*                                   /* PROCESSING WHEN THERE ARE     */
*                                   /* ENABLED SLIP TRAPS TO BE      */
*                                   /* CONSIDERED.           @ZA16855*/
*                                   /*                               */
*                                   /*********************************/
*                                                                  0679
*                                   IF CVTRTMS^=NULL THEN/* IF THE 0679
*                                      SLIP HEADER PTR IND THERE IS
*                                      AN IHASHDR            @ZA16855*/
         L     @14,CVTPTR                                          0679
         L     @14,CVTRTMS(,@14)                                   0679
         CR    @14,@10                                             0679
         BE    @RF00679                                            0679
*                                    DO;/*                   @ZA16855*/
*                                     RFY                          0681
*                                      (R14,                       0681
*                                       R15) RSTD;/*         @ZA16855*/
*                                     R14=SHDRPFC;/* GET UCRRENT   0682
*                                      VALUE FOR COMPARE IN THE CS 0682
*                                                            @ZA16855*/
         L     @10,CVTPTR                                          0682
         L     @10,CVTRTMS(,@10)                                   0682
         L     R14,SHDRPFC(,@10)                                   0682
*SLIPINCR:                          /* TOP OF CS LOOP FOR UPDATING 0683
*                                      THE IEAVTSLP USE COUNT, THIS
*                                      USE COUNT IS 0 IF IEAVTSLP IS
*                                      NOT AVAILABLE         @ZA16855*/
*                                     IF R14>NULL THEN/* IF THE USE
*                                      COUNT INDICATES IEAVTSLP IS 0683
*                                      AVAIL                 @ZA16855*/
SLIPINCR LTR   R14,R14                                             0683
         BNP   @RF00683                                            0683
*                                      DO;/* THEN SLIP SHOULD BE   0684
*                                      CALLED                @ZA16855*/
*                                       R15=R14+ONE;/* INCR THE USE
*                                      COUNT                 @ZA16855*/
         LA    R15,1                                               0685
         ALR   R15,R14                                             0685
*                                       CS(R14,R15,SHDRPFC);/*     0686
*                                      ATTEMPT TO UPDATE THE USE   0686
*                                      COUNT FIELD           @ZA16855*/
         L     @10,CVTPTR                                          0686
         L     @10,CVTRTMS(,@10)                                   0686
         CS    R14,@15,SHDRPFC(@10)                                0686
*                                       BC(4,SLIPINCR);/* IF SHDRPFC
*                                      HAS CHANGED BEFORE THIS CS, 0687
*                                      TRY AGAIN             @ZA16855*/
         BC    4,SLIPINCR                                          0687
*                                       RFY                        0688
*                                        (R14,                     0688
*                                         R15) UNRSTD;/*     @ZA16855*/
*                                                                  0688
*                                       /*****************************/
*                                       /*                           */
*                                       /* OBTAIN 3 CELLS FROM POOL  */
*                                       /* FOR SLIP WORK AREAS       */
*                                       /*                   @ZA16855*/
*                                       /*                           */
*                                       /*****************************/
*                                                                  0689
*                                       RFY                        0689
*                                        (R10,                     0689
*                                         R13,                     0689
*                                         R15) RSTD;/*       @ZA16855*/
*                                       R10=ADDR(RT1TREGS);/* FRRPARM
*                                      REG STORE             @ZA16855*/
         LA    R10,RT1TREGS(,R4)                                   0690
*                                       GEN(STM R0,R4,0(R10));/* SAVE
*                                      REGS CONTENTS         @ZA16855*/
         STM R0,R4,0(R10)
*                                       R0=RT1CPOOL;/* IND RT1 CELL
*                                      POOLID                @ZA16855*/
         L     R0,RT1CPOOL                                         0692
*                                       GEN                        0693
*(GETCELL CPID=(0),BRANCH=YES,SAVE=NO);/*                    @ZA16855*/
         GETCELL CPID=(0),BRANCH=YES,SAVE=NO
*                                       GEN(LA    R11,4095(R9));/* 0694
*                                      RESTORE BASE REG      @ZA16855*/
         LA    R11,4095(R9)
*                                       IF R15=QCELNORM THEN/* IF  0695
*                                      CELL OBTAINED         @ZA16855*/
         LTR   R15,R15                                             0695
         BNZ   @RF00695                                            0695
*                                        DO;/*               @ZA16855*/
*                                         R13=R1;/* SAVE ADDR OF CELL
*                                                            @ZA16855*/
         LR    R13,R1                                              0697
*                                         SLIPLIST=''B;/* CLEAR WORK
*                                      AREA                  @ZA16855*/
         XC    SLIPLIST(72,R13),SLIPLIST(R13)                      0698
*                                         R0=RT1CPOOL;/* IND RT1 CELL
*                                      POOLID                @ZA16855*/
         L     R0,RT1CPOOL                                         0699
*                                         GEN                      0700
*(GETCELL CPID=(0),BRANCH=YES,SAVE=NO);/*                    @ZA16855*/
         GETCELL CPID=(0),BRANCH=YES,SAVE=NO
*                                         GEN(LA R11,4095(R9));/*  0701
*                                      RESTORE BASE REG      @ZA16855*/
         LA R11,4095(R9)
*                                         IF R15=QCELNORM THEN/* IF
*                                      CELL OBTAINED         @ZA16855*/
         LTR   R15,R15                                             0702
         BNZ   @RF00702                                            0702
*                                          DO;/*             @ZA16855*/
*                                           SLPWAPTR=R1;/* SAVE ADDR
*                                      OF CELL               @ZA16855*/
         ST    R1,SLPWAPTR(,R13)                                   0704
*                                           R0=RT1CPOOL;/* IND RT1 0705
*                                      CELL POOLID           @ZA16855*/
         L     R0,RT1CPOOL                                         0705
*                                           GEN                    0706
*(GETCELL CPID=(0),BRANCH=YES,SAVE=NO);/*                    @ZA16855*/
         GETCELL CPID=(0),BRANCH=YES,SAVE=NO
*                                           GEN(LA R11,4095(R9));/*
*                                      RESTORE BASE REG      @ZA16855*/
         LA R11,4095(R9)
*                                           IF R15=QCELNORM THEN/* IF
*                                      OBTAINED              @ZA16855*/
         LTR   R15,R15                                             0708
         BNZ   @RF00708                                            0708
*                                            DO;/*           @ZA16855*/
*                                             RFY                  0710
*                                               R15 UNRSTD;/*      0710
*                                                            @ZA16855*/
*                                             GEN(LM R2,R4,8(R10));/*
*                                      RESTORE REGS          @ZA16855*/
         LM R2,R4,8(R10)
*                                             SLPCFRRS=NULL;/* IND 0712
*                                      ENTRY IS NOT FROM RTS @ZA16855*/
         SLR   @15,@15                                             0712
         ST    @15,SLPCFRRS(,R13)                                  0712
*                                             SLPRT2WA=NULL;/* IND 0713
*                                      ENTRY IS NOT FROM RT2 @ZA16855*/
         ST    @15,SLPRT2WA(,R13)                                  0713
*                                             SLPRTSTK=PSACSTK;/*  0714
*                                      PASS THE ADDRESS OF THE     0714
*                                      CURRENT FRR STACK     @ZA16855*/
         MVC   SLPRTSTK(4,R13),PSACSTK                             0714
*                                             SLPASCB=R8;/* PASS THE
*                                      ADDRESS OF THE ASCB TO BE   0715
*                                      MEMTERMED             @ZA16855*/
         ST    R8,SLPASCB(,R13)                                    0715
*                                             RFY                  0716
*                                               RT1TRACK BASED(R4- 0716
*                                                   FRRSESZE);/*   0716
*                                      ADDRESS THE RT1S FRR TRACK  0716
*                                      AREA                  @ZA16855*/
*                                             RFY                  0717
*                                               R15 RSTD;/*  @ZA16855*/
*                                             R15=CRTMR14-TWO;/*   0718
*                                      CALCULATE THE ADDRESS OF THE
*                                      CALLRTM BALR          @ZA16855*/
         LR    @14,R4                                              0718
         AL    @14,@CF03679                                        0718
         L     @14,RT1TREGS-4(,@14)                                0718
         L     R15,CRTMR14(,@14)                                   0718
         BCTR  R15,0                                               0718
         BCTR  R15,0                                               0718
*                                             GEN(LA  R15,0(R15));/*
*                                      CLEAR FIRST BYTE      @ZA16855*/
         LA  R15,0(R15)
*                                             SLPCRTM=R15;/* MOVE  0720
*                                      INTO PARM LIST        @ZA16855*/
         ST    R15,SLPCRTM(,R13)                                   0720
*                                             RFY                  0721
*                                               R15 UNRSTD;/*      0721
*                                                            @ZA16855*/
*                                             RFY                  0722
*                                               RT1TRACK BASED(R4);/*
*                                      RESET TO CURR         @ZA16855*/
*                                             R2=SLPWAPTR;/* SAVE  0723
*                                      CELL ADDR             @ZA16855*/
         L     R2,SLPWAPTR(,R13)                                   0723
*                                             R0=R1;/* SAVE CELL ADDR
*                                                            @ZA16855*/
         LR    R0,R1                                               0724
*                                             R1=R13;/* SET UP PARM
*                                      FOR SLIP              @ZA16855*/
         LR    R1,R13                                              0725
*                                             R13=R0;/* SET UP REG 0726
*                                      SAVE AREA             @ZA16855*/
         LR    R13,R0                                              0726
*                                             CALL IEAVTSLP;/* CALL
*                                      SLIP                  @ZA16855*/
         L     @14,CVTPTR                                          0727
         L     @14,CVTRTMS(,@14)                                   0727
         L     @15,SHDRPROC(,@14)                                  0727
         BALR  @14,@15                                             0727
*                                             R0=R1;/* SWAP CELL PTRS
*                                      IN                    @ZA16855*/
         LR    R0,R1                                               0728
*                                             R1=R13;/* ORDER TO FREE
*                                      THE                   @ZA16855*/
         LR    R1,R13                                              0729
*                                             R13=R0;/* CELLS      0730
*                                      OBTAINED              @ZA16855*/
         LR    R13,R0                                              0730
*                                             SLPWAPTR=R2;/* RESTORE
*                                      PTR TO CELL           @ZA16855*/
         ST    R2,SLPWAPTR(,R13)                                   0731
*                                             R0=RT1CPOOL;/* IND RT1
*                                      CELL POOL             @ZA16855*/
         L     R0,RT1CPOOL                                         0732
*                                             GEN                  0733
*(FREECELL CPID=(0),CELL=(1),BRANCH=YES,SAVE=NO);                  0733
         FREECELL CPID=(0),CELL=(1),BRANCH=YES,SAVE=NO
*                                             GEN(LA  R11,4095(R9));
         LA  R11,4095(R9)
*                                             /* RESTORE BASE REG  0735
*                                                            @ZA16855*/
*                                             R1=SLPWAPTR;/* ADDR OF
*                                      CELL                  @ZA16855*/
         L     R1,SLPWAPTR(,R13)                                   0735
*                                             R0=RT1CPOOL;/* IND RT1
*                                      CELL POOL             @ZA16855*/
         L     R0,RT1CPOOL                                         0736
*                                             GEN                  0737
*(FREECELL CPID=(0),CELL=(1),BRANCH=YES,SAVE=NO);                  0737
         FREECELL CPID=(0),CELL=(1),BRANCH=YES,SAVE=NO
*                                             GEN(LA  R11,4095(R9));
         LA  R11,4095(R9)
*                                             /* RESTORE BASE REG  0739
*                                                            @ZA16855*/
*                                             R1=R13;/* ADDR OF CELL
*                                                            @ZA16855*/
         LR    R1,R13                                              0739
*                                             R0=RT1CPOOL;/* IND RT1
*                                      CELL POOL             @ZA16855*/
         L     R0,RT1CPOOL                                         0740
*                                             GEN                  0741
*(FREECELL CPID=(0),CELL=(1),BRANCH=YES,SAVE=NO);                  0741
         FREECELL CPID=(0),CELL=(1),BRANCH=YES,SAVE=NO
*                                             GEN(LA  R11,4095(R9));
         LA  R11,4095(R9)
*                                             /* RESTORE BASE REG  0743
*                                                            @ZA16855*/
*                                            END;/*          @ZA16855*/
*                                           ELSE/* IF 3RD GETCELL  0744
*                                      FAILD                 @ZA16855*/
*                                            DO;/* FREE FIRST 2 CELLS
*                                                            @ZA16855*/
         B     @RC00708                                            0744
@RF00708 DS    0H                                                  0745
*                                             R1=SLPWAPTR;/* ADDR OF
*                                      CELL                  @ZA16855*/
         L     R1,SLPWAPTR(,R13)                                   0745
*                                             R0=RT1CPOOL;/* IND RT1
*                                      CELL POOL             @ZA16855*/
         L     R0,RT1CPOOL                                         0746
*                                             GEN                  0747
*(FREECELL CPID=(0),CELL=(1),BRANCH=YES,SAVE=NO);                  0747
         FREECELL CPID=(0),CELL=(1),BRANCH=YES,SAVE=NO
*                                             GEN(LA  R11,4095(R9));
         LA  R11,4095(R9)
*                                             /* RESTORE BASE REG  0749
*                                                            @ZA16855*/
*                                             R1=R13;/* ADDR OF CELL
*                                                            @ZA16855*/
         LR    R1,R13                                              0749
*                                             R0=RT1CPOOL;/* IND RT1
*                                      CELL POOL             @ZA16855*/
         L     R0,RT1CPOOL                                         0750
*                                             GEN                  0751
*(FREECELL CPID=(0),CELL=(1),BRANCH=YES,SAVE=NO);                  0751
         FREECELL CPID=(0),CELL=(1),BRANCH=YES,SAVE=NO
*                                             GEN(LA  R11,4095(R9));
         LA  R11,4095(R9)
*                                             /* RESTORE BASE REG  0753
*                                                            @ZA16855*/
*                                            END;/*          @ZA16855*/
*                                          END;/*            @ZA16855*/
*                                         ELSE/* IF 2ND GETCELL FAILD
*                                                            @ZA16855*/
*                                          DO;/* FREE CELL OBTAINED
*                                                            @ZA16855*/
         B     @RC00702                                            0755
@RF00702 DS    0H                                                  0756
*                                           R1=R13;/* ADDR OF CELL 0756
*                                                            @ZA16855*/
         LR    R1,R13                                              0756
*                                           R0=RT1CPOOL;/* IND RT1 0757
*                                      CELL POOL             @ZA16855*/
         L     R0,RT1CPOOL                                         0757
*                                           GEN                    0758
*(FREECELL CPID=(0),CELL=(1),BRANCH=YES,SAVE=NO);                  0758
         FREECELL CPID=(0),CELL=(1),BRANCH=YES,SAVE=NO
*                                           GEN(LA  R11,4095(R9));/*
*                                      RESTORE BASE REG      @ZA16855*/
         LA  R11,4095(R9)
*                                          END;/*            @ZA16855*/
*                                        END;/*              @ZA16855*/
*                                       ELSE                       0762
*                                        ;/*                 @ZA16855*/
@RF00695 DS    0H                                                  0763
*                                       GEN(LM R0,R4,0(R10));/*    0763
*                                      RESTORE REGISTERS     @ZA16855*/
@RC00695 DS    0H                                                  0763
         LM R0,R4,0(R10)
*                                       RFY                        0764
*                                        (R10,                     0764
*                                         R13) UNRSTD;/*     @ZA16855*/
*                                       RFY                        0765
*                                        (R14,                     0765
*                                         R15) RSTD;/*       @ZA16855*/
*                                       R14=SHDRPFC;/* GET CURRENT 0766
*                                      VALUE FOR COMPARE IN THE CS 0766
*                                                            @ZA16855*/
         L     @10,CVTPTR                                          0766
         L     @10,CVTRTMS(,@10)                                   0766
         L     R14,SHDRPFC(,@10)                                   0766
*SLIPDECR:                          /* TOP OF CS LOOP FOR UPDATING 0767
*                                      THE IEAVTSLP USE COUNT      0767
*                                                            @ZA16855*/
*                                       IF R14>ONE THEN/* IF THE   0767
*                                      IEAVTSLP USE COUNT IS NOT AT
*                                      THE MINIMUM           @ZA16855*/
SLIPDECR CH    R14,@CH00073                                        0767
         BNH   @RF00767                                            0767
*                                        DO;/* THEN DECREMENT IT   0768
*                                                            @ZA16855*/
*                                         R15=R14-ONE;/* PREPARE   0769
*                                      REPLACEMENT VALUE     @ZA16855*/
         LR    R15,R14                                             0769
         BCTR  R15,0                                               0769
*                                         CS(R14,R15,SHDRPFC);/*   0770
*                                      ATTEMPT TO UPDATE THE USE   0770
*                                      COUNT FIELD           @ZA16855*/
         L     @10,CVTPTR                                          0770
         L     @10,CVTRTMS(,@10)                                   0770
         CS    R14,@15,SHDRPFC(@10)                                0770
*                                         BC(4,SLIPDECR);/* IF     0771
*                                      SHDRPFC HAS CHANGED BEFORE  0771
*                                      THIS CS, TRY AGAIN    @ZA16855*/
         BC    4,SLIPDECR                                          0771
*                                        END;/*              @ZA16855*/
*                                       RFY                        0773
*                                        (R14,                     0773
*                                         R15) UNRSTD;/*     @ZA16855*/
@RF00767 DS    0H                                                  0774
*                                      END;/*                @ZA16855*/
*                                    END;/*                  @ZA16855*/
@RF00683 DS    0H                                                  0776
*                                 END;/*                     @ZA16855*/
@RF00679 DS    0H                                                  0777
*CSLOOP:                            /* THIS LABEL IS A BRANCH TARGET
*                                      IF THE COMPARE AND SWAP OF THE
*                                      NEW ASCB INTO THE MEMTERM ASCB
*                                      QUEUE FAILS                   */
*                               ASCBTMCH=RTCTFASB;/* CHAIN THE REST
*                                      OF THE QUEUE TO THE NEW     0777
*                                      ELEMENT                       */
@RF00676 DS    0H                                                  0777
CSLOOP   L     @10,CVTPTR                                          0777
         L     @10,CVTRTMCT(,@10)                                  0777
         L     @10,RTCTFASB(,@10)                                  0777
         ST    @10,ASCBTMCH(,R8)                                   0777
*                               R5=ASCBTMCH;/* PLACE FORWARD PTR IN
*                                      REG                           */
         LR    R5,@10                                              0778
*                               CS(R5,R8,RTCTFASB);/* COMPARE THE  0779
*                                      QUEUE PTR JUST PLACED IN THE
*                                      ASCB, WITH THE ONE CURRENTLY
*                                      IN THE RTCT, AND IF STILL   0779
*                                      EQUAL, STORE THE ASCB ADDR TO
*                                      BE ENQUEUED INTO THE RTCT,  0779
*                                      MAKING IT THE FIRST ELEMENT IN
*                                      THE QUEUE.                    */
         L     @10,CVTPTR                                          0779
         L     @10,CVTRTMCT(,@10)                                  0779
         CS    R5,@08,RTCTFASB(@10)                                0779
*                               BC(NOCOMPAR,CSLOOP);/* IF THE COMPARE
*                                      DID NOT GO, THEN TRY AGAIN    */
         BC    1,CSLOOP                                            0780
*                               RT1TLPN=MEMTCOMP;/* LPN=PHASE NO. FOR
*                                      SUCCESSFUL ENQUEUE OF ASCB  0781
*                                      ONTO MEMTERM QUEUE            */
         MVI   RT1TLPN(R4),X'66'                                   0781
*                             END;  /* END ENQUEUING OF ASCB         */
*                                                                  0782
*                           /*****************************************/
*                           /*                                       */
*                           /* THE PURPOSE OF THE WAKEMTC SEGMENT IS */
*                           /* TO INSURE THAT THE MEMORY TERMINATION */
*                           /* CONTROLLER IS NOTIFIED TO PROCESS THE */
*                           /* TERMINATION REQUEST. A SINGLE SRB IS  */
*                           /* PRE ALLOCATED FOR THIS PURPOSE AND A  */
*                           /* LOCKING TECHNIQUE IS EMPLOYED TO      */
*                           /* INSURE SERIAL USE OF THE SRB. IF THE  */
*                           /* SRB IS LOCKED (I.E. IN USE) THEN THE  */
*                           /* MTC IS ALREADY IN THE PROCESS OF BEING*/
*                           /* NOTIFIED TO PROCESS ANY ASCBS ON THE  */
*                           /* TERMINATION QUEUE. IF THE SRB IS      */
*                           /* UNLOCKED (I.E. NOT IN USE) THEN IT IS */
*                           /* SET TO BE LOCKED AND SCHEDULED. THE   */
*                           /* SRB WILL SUBSEQUENTLY NOTIFY THE MTC  */
*                           /* TO PROCESS THE ASCB TERMINATION QUEUE.*/
*                           /* INPUT TO THIS SEGMENT IS THE RTCT.    */
*                           /* OUTPUT IS A SCHEDULED SRB IF THE LOCK */
*                           /* WAS UNLOCKED. ADDITIONALLY, REGS R5   */
*                           /* AND R6 ARE ASSUMED TO BE RESTRICTED,  */
*                           /* AND AVAILABLE FOR USE BY THIS SEGMENT.*/
*                           /*                                       */
*                           /*****************************************/
*                                                                  0783
*                           DO;     /* START OF WAKEMTC SEGMENT      */
@RC00670 DS    0H                                                  0784
*                             R5=LOKVALUE;/* PRIME REG WITH THE    0784
*                                      LOCKED INDICATION             */
         SLR   R5,R5                                               0784
*                             R6=UNLOKVAL;/* PRIME ANOTHER REG WITH
*                                      THE UNLOCKED INDICATION       */
         LA    R6,1                                                0785
*                             CS(R6,R5,RTCTMLCK);/* CHECK IF THE   0786
*                                      RTCTMLCK PRESENTLY INDICATES
*                                      UNLOCKED, AND IF SO, STORE THE
*                                      LOCK INDICATION INTO IT. ELSE,
*                                      IF IT IS LOCKED, STORE THE  0786
*                                      LOCKED VALUE INTO THE SRBUNLOK
*                                      REG (R8) FOR THE FOLLOWING  0786
*                                      TEST                          */
         L     @10,CVTPTR                                          0786
         L     @10,CVTRTMCT(,@10)                                  0786
         CS    R6,@05,RTCTMLCK(@10)                                0786
*                             IF R6=UNLOKVAL THEN/* IF THE UNLOCK  0787
*                                      VALUE WAS LEFT INTACT IN THE
*                                      UNLOCK REGISTER THEN THE SRB
*                                      IS FREE TO BE SCHEDULED,SO    */
         CH    R6,@CH00073                                         0787
         BNE   @RF00787                                            0787
*                               DO; /* SCHEDULE THE MEMTERM SRB      */
*                                 RFY                              0789
*                                   R8 RSTD;/* GET A WORKREG FOR   0789
*                                      SCHEDULE                      */
*                                 R8=RTCTMSRB;/* LOCATE ADDR OF MTCS
*                                      SRB                           */
         L     @10,CVTPTR                                          0790
         L     @10,CVTRTMCT(,@10)                                  0790
         L     R8,RTCTMSRB(,@10)                                   0790
*                                 GEN(SCHEDULE SRB=(R8));/* PUT THE
*                                      SRB ON THE DISPATCHING QUEUE  */
         SCHEDULE SRB=(R8)
*                                 RFY                              0792
*                                   R8 UNRSTD;/* RETURN REG TO     0792
*                                      COMPILER                      */
*                               END;/* END SCHEDULE PROCESSING       */
*                             R6=NULL;/* RESTORE EED CHAIN TO      0794
*                                      ORIGINAL VALUE (NO EEDS).     */
@RF00787 SLR   R6,R6                                               0794
*                           END;    /* END WAKE MTC PROCESSING       */
*                         END;      /* END ASCB PROCESSING           */
*                     END;          /* END MEMORY TERM SCHEDULING    */
@RF00668 DS    0H                                                  0798
*                   RFY                                            0798
*                     ASCB BASED(PSAAOLD);/* POINT TO THE CURRENT  0798
*                                      ASCB                          */
@RC00665 DS    0H                                                  0799
*                 END;              /* END OF MEMTERM SEGMENT        */
*                                                                  0799
*               /*****************************************************/
*               /*                                                   */
*               /* THE FOLLOWING CODE DELETES THE RECOVERY           */
*               /* ENVIRONMENT SET UP FOR THE RESCHEDULE FUNCTION.   */
*               /*                                                   */
*               /*****************************************************/
*                                                                  0800
*               R0=RT1TENPT;        /* RE-ESTABLISH THE ORIGINAL   0800
*                                      ENTRY POINT INDICATION        */
@RF00660 SLR   R0,R0                                               0800
         IC    R0,RT1TENPT(,R4)                                    0800
*               R4=R12;             /* RE-ESTABLISH THE PREVIOUS   0801
*                                      TRACKING AREA, THE TRACK AREA
*                                      IN THE SLIH FRR IF SLIH MODE,
*                                      THE TRACK AREA IN RT1'S FRR IF
*                                      SERVICE ROUTINE MODE          */
         LR    R4,R12                                              0801
*               RFY                                                0802
*                 R12 UNRSTD;       /* RELEASE RECOVERY REG          */
*               RFY                                                0803
*                 R14 RSTD;         /* GET WORKREG FOR SETFRR        */
*               RFY                                                0804
*                 R15 RSTD;         /* GET WORKREG FOR SETFRR        */
*               GEN(SETFRR D,WRKREGS=(R14,R15));/* DELETE THE RESCH
*                                      FRR                           */
         SETFRR D,WRKREGS=(R14,R15)
*               IF R0>=SLIHLOW&     /* IF ORIGINAL ENTRY WAS IN      */
*                   R0<=SLIHHI THEN /* SLIH MODE                     */
         CH    R0,@CH00073                                         0806
         BL    @RF00806                                            0806
         CH    R0,@CH00032                                         0806
         BH    @RF00806                                            0806
*                 DO;               /* PERFORM UNIQUE SLIH MODE    0807
*                                      CLEAN-UP                      */
*                   R4=ADDR(RT1WLPTA);/* RE-ESTABLISH THE PTR TO THE
*                                      RTM1WA                        */
         L     R4,PSACSTK                                          0808
         LA    R4,RT1WLPTA(,R4)                                    0808
*                   GEN(SETFRR D,WRKREGS=(R14,R15));/* DELETE THE  0809
*                                                             SLIHFRR*/
         SETFRR D,WRKREGS=(R14,R15)
*                   RFY                                            0810
*                    (R14,                                         0810
*                     R15) UNRSTD;  /* RELEASE SETFRR WORKREGS       */
*                   RT1WRTM='0'B;   /* INDICATE RTM'S FRR HAS BEEN 0811
*                                      DELETED                       */
         L     @12,PSACSTK                                         0811
         NI    RT1WRTM(@12),B'10111111'                            0811
*                 END;              /* END OF SLIH MODE CLEAN-UP     */
*             END;                  /* END OF NON-RESCPU PROCESSING  */
@RF00806 DS    0H                                                  0814
*         END;                      /* END OF RESCHED SEGMENT        */
@RC00301 DS    0H                                                  0815
*     END;                          /* END UNIQUE SOFTWARE PROCESS   */
*                                                                  0815
@RF00298 DS    0H                                                  0816
*   /*****************************************************************/
*   /*                                                               */
*   /* THE PURPOSE OF THE EXIT FUNCTION IS TO 1)FREE RESOURCES       */
*   /* ACQUIRED BY THE RTM1 THAT ARE NO LONGER NEEDED, 2) CLEAN UP   */
*   /* RESOURCES HELD BY THE CPU IF AN UNRECOVERABLE (I.E. NON       */
*   /* RETRYABLE) ERROR HAS OCCURRED, AND 3) DETERMINE THE TYPE OF   */
*   /* EXIT THAT SHOULD BE TAKEN BY IEAVTRT1. REGISTERS R0 THRU R4,  */
*   /* WHICH INITIALLY CONTAINED INPUT INFORMATION, ARE RELEASED FOR */
*   /* USE BY THE COMPILER AND REGISTERS R5-R10 ARE REASSIGNED FOR   */
*   /* USE BY THE EXIT FUNCTION. INPUT TO THE EXIT FUNCTION IS AS    */
*   /* FOLLOWS: FUNCTION REGISTER (R0) - CONTAINS THE ORIGINAL ENTRY */
*   /* POINT FUNCTION INDICATION. THIS VALUE IS PLACED IN THE        */
*   /* EFUNCTON (R5) REGISTER SO THAT R0 CAN BE RELEASED. TRAKAREA   */
*   /* REGISTER (R4) CONTAINS A POINTER TO THE RTM1WA TRACKING AREA  */
*   /* IF OPERATING IN SLIH MODE, OR TO IEAVTRT1'S FRR TRACKING AREA */
*   /* IF OPERATING IN SERVICE ROUTINE MODE. THIS VALUE IS PLACED IN */
*   /* THE TRAKARE2 REGISTER (R7) SO THAT R4 CAN BE RELEASED. THE    */
*   /* RTRNPARM REGISTER (R10) CONTAINS A PTR TO MCH RETURN PARMS IF */
*   /* A MACHCK ENTRY WAS PROCESSED. EEDCHAIN REGISTER (R6) CONTAINS */
*   /* A POINTER TO A CHAIN OF EED CELLS IF ANY EEDS ACQUIRED DURING */
*   /* RTM1S PROCESSING ARE NO LONGER NEEDED, OR R6 CONTAINS 0       */
*   /* INDICATING NO EED FREEING IS NECESSARY. R9 IS STILL MAINTAINED*/
*   /* AS THE BASE REGISTER. IF RTM1 IS OPERATING IN SLIH MODE, THE  */
*   /* RTM1WA ASSOCIATED WITH THE FRR STACK SUFFERING THE ERROR ALSO */
*   /* PROVIDES ADDITIONAL INPUT TO THE EXIT FUNCTION. ALSO, IF SRM  */
*   /* WAS CALLED TO SERVICE THE ERROR, THE RTCA PROVIDES INPUT.     */
*   /* OUTPUT FROM THE EXIT FUNCTION IS AS FOLLOWS: R0 CONTAINS AN   */
*   /* INDICATION OF THE TYPE OF EXIT FOR MODULE IEAVTRT1 TO EFFECT, */
*   /* AND R1 CONTAINS A POINTER TO EXIT PARMS FOR RETRY EXITS AND   */
*   /* MACHINE CHECK EXITS.                                          */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0816
*RTHRETRN:                          /* LABEL TO ALLOW RTH'S RECOVERY
*                                      ROUTINE TO PRIME THE RETURN 0816
*                                      ADDRESS TO RTM ON RETRIABLE 0816
*                                      ERRORS                        */
*   DO;                             /* START OF EXIT SEGMENT         */
@RC00079 DS    0H                                                  0816
RTHRETRN DS    0H                                                  0817
*     GEN(LA R11,4095(R9));         /* RESTORE BASE REG      @G17EP5W*/
         LA R11,4095(R9)
*     RT1TLPN=VALIDREC;             /* LPN=VALID RECURSION INDICATOR
*                                      IF AN ERROR NOW OCCURS IN   0818
*                                      RTM'S REMAINING PROCESSING, 0818
*                                      RTM, WHEN REENTERED, WILL   0818
*                                      PRESERVE SOME INFO ABOUT THE
*                                      ORIG ERROR, SUCH AS INFO ABOUT
*                                      RESOURCES ACQUIRED BY RTM,  0818
*                                      SUCH AS THE RTCA. THIS TYPE OF
*                                      REENTRY WILL GIVE RTM ANOTHER
*                                      CHANCE TO FREE ANY SUCH     0818
*                                      RESOURCES.                    */
*                                                                  0818
         MVI   RT1TLPN(R4),X'FF'                                   0818
*     /***************************************************************/
*     /*                                                             */
*     /* THE FOLLOWING CODE REASSIGNS THE WORK REGISTERS FROM THEIR  */
*     /* ENTRY POINT ASSIGNMENTS TO REGISTERS WHICH ARE NOT AFFECTED */
*     /* BY THE EXTERNAL ROUTINES CALLED DURING EXIT PROCESSING.     */
*     /* INPUT TO IS THE FUNCTION REGISTER (R0), THE TRAKAREA        */
*     /* REGISTER (R4) AND THE RTRNPARM REGISTER (R10). OUTPUT IS THE*/
*     /* EFUNCTON REGISTER (R5) CONTAINING THE ORIGINAL ENTRY POINT  */
*     /* FUNCTION INDICATION, AND THE TRAKARE2 REGISTER (R7)         */
*     /* CONTAINING THE POINTER TO THE RECOVERY TRACKING AREA.       */
*     /*                                                             */
*     /***************************************************************/
*                                                                  0819
*     RFY                                                          0819
*       R5 RSTD;                    /* GET CONTROL OF REGISTER FOR 0819
*                                      ORIGINAL ENTRY POINT        0819
*                                      INDICATION                    */
*     R5=R0;                        /* PLACE ORIGINAL ENTRY POINT  0820
*                                      INDICATOR IN REGISTER         */
         LR    R5,R0                                               0820
*     RFY                                                          0821
*       R0 UNRSTD;                  /* RETURN REGISTER TO COMPILER   */
*     RFY                                                          0822
*       R7 RSTD;                    /* GET CONTROL OF REGISTER       */
*     R7=R4;                        /* PLACE RECOVERY TRACKING AREA
*                                      POINTER INTO REGISTER         */
         LR    R7,R4                                               0823
*     RFY                                                          0824
*       RT1TRACK BASED(R7);         /* ADJUST MAPPING MACRO BASE     */
*     RFY                                                          0825
*       R4 UNRSTD;                  /* RETURN REGISTER TO COMPILER   */
*     RFY                                                          0826
*       R1 UNRSTD;                  /* RETURN REGISTER TO COMPILER   */
*     RFY                                                          0827
*       R2 UNRSTD;                  /* RETURN REGISTER TO COMPILER 0827
*                                      THIS REGISTER ALSO USED AS  0827
*                                      ADDRPSW1                      */
*     RFY                                                          0828
*       R3 UNRSTD;                  /* RETURN REGISTER TO COMPILER 0828
*                                      THIS REGISTER ALSO USED AS  0828
*                                      ADDRPSW2 AND TARGSRB          */
*     RFY                                                          0829
*       R8 RSTD;                    /* GET CONTROL OF REGISTER FOR 0829
*                                      EXIT TYPE INDICATOR           */
*     RFY                                                          0830
*       R10 RSTD;                   /* GET CONTROL OF REGISTER FOR 0830
*                                      RETURN PARAMETERS TO IEAVTRT1 */
*     IF R5=RT1WMACH THEN           /* IF RTM DID HARDWARE REPAIR    */
         CH    R5,@CH00435                                         0831
         BNE   @RF00831                                            0831
*       R8=RT1MCHEX;                /* THEN A MACHCK EXIT IS TO BE 0832
*                                      TAKEN BY IEAVTRT1             */
         LA    R8,33                                               0832
*     ELSE                          /* IF NOT HARDWARE REPAIR        */
*       DO;                         /* SOME CLEAN UP MAY BE NEEDED   */
         B     @RC00831                                            0833
@RF00831 DS    0H                                                  0834
*         IF R6>EEDNULL THEN        /* IF EEDS WERE ACQUIRED         */
         CH    R6,@CH00073                                         0834
         BNH   @RF00834                                            0834
*           DO;                     /* ATTEMPT TO FREE THE EEDS      */
*             RT1TLPID=RECOVRY1;    /* INDICATE SOME RECOVERY IS   0836
*                                      POSSIBLE IF AN ERROR OCCURS IN
*                                      THIS SEGMENT                  */
         MVI   RT1TLPID(R7),X'01'                                  0836
*             RT1TLPN=EEDFREE;      /* LPN=PHASE NUMBER FOR FREEING
*                                      ACQUIRED EEDS                 */
         MVI   RT1TLPN(R7),X'78'                                   0837
*             CALL FREEDCEL;        /* FREE EED CELLS                */
         L     @15,@CV00162                                        0838
         BALR  @14,@15                                             0838
*EEDFRERP:                          /* RETURN PT OF LPRR IF FREE CELL
*                                      ERROR OCCURS                  */
*             GEN(LA R11,4095(R9)); /* RESTORE BASE REG      @G17EP5W*/
EEDFRERP LA R11,4095(R9)
*             RT1TLPN=VALIDREC;     /* RESET LPN TO INDICATE VALID 0840
*                                      RECURSION (SEE ABOVE COMMNT)  */
         MVI   RT1TLPN(R7),X'FF'                                   0840
*           END;                    /* END OF ATTEMPT TO FREE EEDS   */
*         IF R5>=SLIHLOW&           /* IF OPERATING AS A SECOND      */
*             R5<=SLIHHI THEN       /* LEVEL INTERRUPT HANDLER       */
@RF00834 CH    R5,@CH00073                                         0842
         BL    @RF00842                                            0842
         CH    R5,@CH00032                                         0842
         BH    @RF00842                                            0842
*           IF RT1WRTM='1'B&        /* IF RTM'S FRR HAD BEEN IN    0843
*                                      CONTROL                       */
*               SDWARCDE=SDWARETY THEN/* AND HAD REQUESTED RETRY     */
         L     @12,PSACSTK                                         0843
         TM    RT1WRTM(@12),B'01000000'                            0843
         BNO   @RF00843                                            0843
         L     @12,RT1WRTCA(,@12)                                  0843
         CLI   SDWARCDE(@12),4                                     0843
         BNE   @RF00843                                            0843
*             DO;                   /* SET UP SPECIAL RETRY INTERFACE*/
*               SDWASR15=SDWARTYA;  /* PLACE RETRY ADDR IN REG15 SLOT
*                                      OF SDWA                       */
         MVC   SDWASR15(4,@12),SDWARTYA(@12)                       0845
*               R8=RT1RETRY;        /* INDICATE RETRY EXIT TO BE   0846
*                                      TAKEN BY RT1                  */
         LA    R8,32                                               0846
*               R10=ADDR(SDWASR00); /* POINT TO RETRY REGS FOR RT1   */
         LA    R10,SDWASR00(,@12)                                  0847
*             END;                  /* END OF SPECIAL RETRY INTERFACE
*                                      FOR RTM'S FRR                 */
*           ELSE                    /* IF NOT RTM'S FRR REQUESTING 0849
*                                      RETRY                         */
*             DO;                   /* CONTINUE WITH UNIQUE SLIH MODE
*                                      CLEANUP                       */
         B     @RC00843                                            0849
@RF00843 DS    0H                                                  0850
*               RFY                                                0850
*                 MODEBYTE BASED(ADDR(RT1WMODE));/* USE THE MODE   0850
*                                      INDICATION IN THE WA TO DETER-
*                                      MINE SYSTEM MODE AT TIME OF 0850
*                                      ERROR INTERRUPT               */
*               IF MODESRB='1'B THEN/* IF CPU IS IN SRB MODE         */
         L     @12,PSACSTK                                         0851
         TM    MODESRB+80(@12),B'00000010'                         0851
         BNO   @RF00851                                            0851
*                 R8=RT1SRBEX;      /* THEN INITIALIZE EXIT INDI-  0852
*                                      CATOR TO THE SRB EXIT PT OF 0852
*                                      THE DISPATCHER                */
         LA    R8,36                                               0852
*               ELSE                /* IF NOT SRB MODE               */
*                 DO;               /* CHECK OTHER EXIT TYPES        */
         B     @RC00851                                            0853
@RF00851 DS    0H                                                  0854
*                   IF MODETYP1='1'B THEN/* IF THE CPU WAS IN TYPE 1
*                                      SVC MODE THEN                 */
         L     @12,PSACSTK                                         0854
         TM    MODETYP1+80(@12),B'00000100'                        0854
         BNO   @RF00854                                            0854
*                     R8=RT1EXPRO;  /* INITIALIZE THE EXIT TYPE    0855
*                                      INDICATOR TO AN SVC EXIT    0855
*                                      PROLOGUE EXIT                 */
         LA    R8,37                                               0855
*                   ELSE            /* IF NOT TYPE 1 SVC             */
*                     R8=RT1DISP;   /* INITIALIZE EXIT TYPE INDICATOR
*                                      TO A DISPATCHER EXIT          */
         B     @RC00854                                            0856
@RF00854 LA    R8,35                                               0856
*                 END;              /* END NON SRB EXIT TYPES        */
@RC00854 DS    0H                                                  0858
*               IF RT1WRTCA^=NULL THEN/* IF AN RTCA IS PROVIDED THEN
*                                      SRM SERVICED THE ERROR        */
*                                                                  0858
@RC00851 L     @12,PSACSTK                                         0858
         L     @04,RT1WRTCA(,@12)                                  0858
         LTR   @04,@04                                             0858
         BZ    @RF00858                                            0858
*                 /***************************************************/
*                 /*                                                 */
*                 /* THE PURPOSE OF THE SYSCLEAN SEGMENT IS TO FREE  */
*                 /* RESOURCES ACQUIRED BY SRM FOR SYSTEM RECOVERY,  */
*                 /* TO FREE LOCKS ACQUIRED BY THE FAILING SYSTEM    */
*                 /* ROUTINE AND TO ESTABLISH THE CORRECT EXIT       */
*                 /* PARAMETERS FOR IEAVTRT1 TO CAUSE NORMAL SYSTEM  */
*                 /* PROCESSING TO OCCUR. INPUT IS AS FOLLOWS:       */
*                 /* EFUCTION REGISTER (R5) - INDICATES THE ORIGINAL */
*                 /* ENTRY POINT FUNCTION OF RTM1. TRAKARE2 REGISTER */
*                 /* (R7) CONTAINS POINTER TO THE RTM1WA TRACKING    */
*                 /* AREA. FLAGS IN THE TRACKING AREA INDICATE WHICH */
*                 /* RESOURCES WERE ACQUIRED DURING SYSTEM RECOVERY  */
*                 /* PROCESSING. EXITTYPE REGISTER (R8) - INITIALIZED*/
*                 /* WITH THE EXIT TYPE CODE FOR PERCOLATION. OUTPUT */
*                 /* FROM SYSCLEAN IS AS FOLLOWS: EXITTYPE REGISTER  */
*                 /* (R8) CONTAINS THE FINAL EXIT TYPE INDICATION. IF*/
*                 /* RETRY, THE RTM1WA CONTAINS THE 16 RETRY         */
*                 /* REGISTERS. IF PERCOLATION IS BEING PROCESSED,   */
*                 /* ALL LOCKS WILL BE FREED.                        */
*                 /*                                                 */
*                 /***************************************************/
*                                                                  0859
*                 DO;               /* START OF SYSCLEAN SEGMENT     */
*                   RFY                                            0860
*                     R6 RSTD;      /* GET CONTROL OF REGISTER       */
*                   R6=RT1WRTCA;    /* SAVE PTR TO RTCA-SDWA         */
         LR    R6,@04                                              0861
*                   RFY                                            0862
*                     SDWA BASED(R6);/* SINCE THE RTM1WA MAY GET   0862
*                                      OVERLAID DURING THE EXIT    0862
*                                      PROCESSING, THE PTR TO THE  0862
*                                      SDWA WILL BE MAINTAINED IN A
*                                      REGISTER                      */
*                   RFY                                            0863
*                     R2 RSTD;      /* GET REG TO PRESERVE CARRY OVER
*                                      INFORMATION                   */
*                   R2=RT1WCOVR;    /* PRESERVE CARRY OVER INFO -  0864
*                                      COULD BE OVERLAID IF A RETRY
*                                      IS REQUESTED                  */
         SLR   R2,R2                                               0864
         IC    R2,RT1WCOVR(,@12)                                   0864
*                   IF SDWARCDE^=SDWACWT×/* IF A PERCOLATE IS NOT    */
*                       SDWASPIN='1'B THEN/* REQUESTED THEN          */
*                                                                  0865
         CLI   SDWARCDE(R6),0                                      0865
         BNE   @RT00865                                            0865
         TM    SDWASPIN(R6),B'00100000'                            0865
         BNO   @RF00865                                            0865
@RT00865 DS    0H                                                  0866
*                     /***********************************************/
*                     /*                                             */
*                     /* THE PURPOSE OF THE NOPERCEX SEGMENT IS TO   */
*                     /* SET UP FOR THE NON PERCOLATION EXITS - RETRY*/
*                     /* AND RESUME. ALSO IF ANY LOCKS WERE ACQUIRED */
*                     /* BY THE RTM THEY ARE FREED IN THIS SEGMENT   */
*                     /* SINCE THE FREELOCK ROUTINE WHICH FREES ALL  */
*                     /* LOCKS IS ONLY CALLED IN THE PERCOLATION     */
*                     /* SITUATION. INPUT TO THIS SEGMENT IS AS      */
*                     /* FOLLOWS: RTCAADDR REGISTER (R6) - POINTS TO */
*                     /* THE RTCA. THE RTCA IN TURN CONTAINS THE EXIT*/
*                     /* TYPE REQUESTED BY THE FRR - PERC, RETRY OR  */
*                     /* RESUME, AND THE RETRY REGISTERS AND ADDRESS,*/
*                     /* AND THE BAD CPU IF A RESUME IS REQUESTED.   */
*                     /* TRAKARE2 REGISTER (R7) - POINTS TO THE      */
*                     /* RTM1WA TRACKING AREA. IF A LOCK WAS ACQUIRED*/
*                     /* BY THE RTM1 OR SRM, IT WOULD BE INDICATED IN*/
*                     /* THE TRACKING AREA. OUTPUT FROM THIS SEGMENT */
*                     /* IS A FREED LOCAL LOCK IF OBTAINED BY THE RTM*/
*                     /* AND AN UPDATED EXITTYPE REGISTER (R8). IF A */
*                     /* RETRY IS BEING PROCESSED, THE RTM1WA WOULD  */
*                     /* CONTAIN THE RETRY REGISTERS.                */
*                     /*                                             */
*                     /***********************************************/
*                                                                  0866
*                     DO;           /* PERFORM NON PERC PROCESSING   */
*                       IF SDWASPIN='1'B THEN/* IF FRR INDICATED   0867
*                                      VALID SPIN                    */
         TM    SDWASPIN(R6),B'00100000'                            0867
         BNO   @RF00867                                            0867
*                         R8=RT1RESUM;/* THEN ALLOW IT TO RESUME THE
*                                      SPIN                          */
         LA    R8,34                                               0868
*                       ELSE        /* IF NOT A RESUME FUNCTION      */
*                         IF SDWARCDE=SDWARETY THEN/* SEE IF RETRY 0869
*                                      WAS REQUESTED                 */
*                                                                  0869
         B     @RC00867                                            0869
@RF00867 CLI   SDWARCDE(R6),4                                      0869
         BNE   @RF00869                                            0869
*                           /*****************************************/
*                           /*                                       */
*                           /* THE FOLLOWING CODE OVERLAYS THE ENTIRE*/
*                           /* RTM1WA EXCEPT THE FIRST WORD WHICH    */
*                           /* MUST BE PRESERVED TO CONTAIN RECURSION*/
*                           /* CONTROL DATA                          */
*                           /*                                       */
*                           /*****************************************/
*                                                                  0870
*                           DO;     /* AND PERFORM RETRY SET UP      */
*                             RT1R0R14=SDWASRSV;/* MOVE REG0 - REG14
*                                      INTO WA                       */
         L     @12,PSACSTK                                         0871
         MVC   RT1R0R14(60,@12),SDWASRSV(R6)                       0871
*                             RT1TLPN=NULL;/* INDICATE RECURSIONS TO
*                                      BE HANDLED AS NEW ERRORS -  0872
*                                      NECESSARY SINCE WA HAS BEEN 0872
*                                      OVERLAYED WITH RETRY REGISTERS
*                                                            @YM06110*/
         MVI   RT1TLPN(R7),X'00'                                   0872
*                             RT1RTYAD=SDWARTYA;/* MOVE RETRY ADDR 0873
*                                      INTO REG15 SLOT OF WA         */
         MVC   RT1RTYAD(4,@12),SDWARTYA(R6)                        0873
*                             R8=RT1RETRY;/* INDICATED RETRY EXIT TO
*                                      BE TAKEN BY IEAVTRT1          */
         LA    R8,32                                               0874
*                             R10=ADDR(RT1R0R14);/* POINT TO RETRY 0875
*                                      REGS FOR RT1                  */
         LA    R10,RT1R0R14(,@12)                                  0875
*                           END;    /* END RETRY PROCESSING          */
*                         ELSE                                     0877
*                           ;       /* IF NOT RETRY THEN NO SETUP    */
@RF00869 DS    0H                                                  0878
*                       IF(R2&LOCLMASK)^=NULL THEN/* IF A LOCAL LOCK
*                                      WAS ACQUIRED BY RTM1 OR SRM   */
@RC00867 LR    @12,R2                                              0878
         N     @12,@CF00215                                        0878
         LTR   @12,@12                                             0878
         BZ    @RF00878                                            0878
*                         DO;       /* FREE THE LOCAL LOCK           */
*                           RFY                                    0880
*                             R12 RSTD;/* DESTROYED BY SETLOCK       */
*                           RFY                                    0881
*                             R13 RSTD;/* DESTROYED BY SETLOCK       */
*                           RFY                                    0882
*                             R14 RSTD;/* DESTROYED BY SETLOCK       */
*                           GEN;                                   0883
*                                      /*GET THE LOCAL LOCK          */
          SETLOCK RELEASE,TYPE=LOCAL,RELATED=(LOCSDWA,IEAVTRTS(PUGETM))
          LA  R11,4095(R9)   RE-ESTABLISH BASE REGISTER      @G17EP5W
*                           RFY                                    0884
*                             R12 UNRSTD;/* RELEASE CONTROL OF WORK
*                                      REG                           */
*                           RFY                                    0885
*                             R13 UNRSTD;/* RELEASE CONTROL OF WORK
*                                      REG                           */
*                           RFY                                    0886
*                             R14 UNRSTD;/* RELEASE CONTROL OF WORK
*                                      REG                           */
*                         END;      /* END LOCAL LOCK FREEING        */
*                     END;          /* END NON PERCOLATE EXIT PROC   */
*                   ELSE            /* IF PERCOLATE IS REQUESTED     */
*                                                                  0889
*                     /***********************************************/
*                     /*                                             */
*                     /* THE FOLLOWING CODE INTERFACES WITH A        */
*                     /* SUBROUTINE OF SVC EXIT PROLOGUE WHICH FREES */
*                     /* ALL LOCKS HELD ON THIS CPU. IF THE CPU IS IN*/
*                     /* TYPE 1 SVC MODE, THEN THIS SUBROUTINE IS NOT*/
*                     /* CALLED SINCE AN EXIT PROLOGUE EXIT WILL BE  */
*                     /* TAKEN AND THE SUBROUTINE WILL BE CALLED     */
*                     /* DURING EXIT PROLOGUES PROCESSING.           */
*                     /*                                             */
*                     /***********************************************/
*                                                                  0889
*                     IF MODETYP1='0'B THEN/* IF NOT TYPE 1 SVC MODE */
         B     @RC00865                                            0889
@RF00865 L     @12,PSACSTK                                         0889
         TM    MODETYP1+80(@12),B'00000100'                        0889
         BNZ   @RF00889                                            0889
*                       DO;                                        0890
*                         RFY                                      0891
*                           R1 RSTD;/* GET CONTROL OF PARM REG       */
*                         R1=RTDISABL;/* INDICATE REMAIN DISABLED    */
         LA    R1,1                                                0892
*                         RFY                                      0893
*                           R12 RSTD;/* DESTROYED BY FREELOCK        */
*                         RFY                                      0894
*                           R13 RSTD;/* DESTROYED BY FREELOCK        */
*                         CALL IEAVFRLK;/* GO FREE ALL LOCKS HELD BY
*                                      THIS CPU                      */
         L     @15,@CV00157                                        0895
         BALR  @14,@15                                             0895
*                         GEN(LA R11,4095(R9));/* GET BASE REG VALUE
*                                                            @G17EP5W*/
         LA R11,4095(R9)
*                         RFY                                      0897
*                           R1 UNRSTD;/* RELEASE CONTROL OF PARM REG */
*                         RFY                                      0898
*                           R12 UNRSTD;/* RELEASE CONTROL OF WORK REG*/
*                         RFY                                      0899
*                           R13 UNRSTD;/* RELEASE CONTROL OF WORK REG*/
*                       END;        /* END NON EXPRO EXIT PROCESS    */
*                     ELSE                                         0901
*                       ;           /* IF TYPE1 NO LOCK FREEING      */
*                                                                  0901
@RF00889 DS    0H                                                  0902
*                   /*************************************************/
*                   /*                                               */
*                   /* THE FOLLOWING PROCESSING IS PERFORMED         */
*                   /* REGARDLESS OF THE TYPE OF EXIT BEING          */
*                   /* PERFORMED. IT IS ASSUMED AT THIS POINT THAT IF*/
*                   /* A DYNAMICALLY ACQUIRED RTCA IS TO BE FREED,   */
*                   /* THEN NO LOCKS ARE HELD SINCE RTCAS ARE        */
*                   /* GETMAINED ONLY WHEN NO LOCKS WERE HELD        */
*                   /*                                               */
*                   /*************************************************/
*                                                                  0902
*                   IF(R2&RTCAMASK)^=NULL THEN/* IF AN RTCA WAS    0902
*                                      GETMAINED                     */
@RC00865 LR    @12,R2                                              0902
         N     @12,@CF00217                                        0902
         LTR   @12,@12                                             0902
         BZ    @RF00902                                            0902
*                     DO;           /* FREE THE RTCA                 */
*                       RFY                                        0904
*                         R2 UNRSTD;                               0904
*                       RFY                                        0905
*                         R12 RSTD; /* DESTROYED BY SETLOCK          */
*                       RFY                                        0906
*                         R13 RSTD; /* DESTROYED BY SETLOCK          */
*                       RFY                                        0907
*                         R14 RSTD; /* DESTROYED BY SETLOCK          */
*                       GEN;                                       0908
*                                      /*GET THE LOCAL LOCK          */
           SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,RELATED=(FREEMAIN,IEAV*
               TRTM(SYSCLEAN))
            LA   R11,4095(R9)   REESTABLISH BASE REGISTER    @G17EP5W
*                       RFY                                        0909
*                         R12 UNRSTD;/* RELEASE CONTROL OF WORK REG  */
*                       RFY                                        0910
*                         R13 UNRSTD;/* RELEASE CONTROL OF WORK REG  */
*                       RFY                                        0911
*                         R14 UNRSTD;/* RELEASE CONTROL OF WORK REG  */
*                       RFY                                        0912
*                         R4 RSTD;  /* USED TO SAVE R7 VALUE         */
*                       R4=R7;      /* SAVE THE CONTENTS OF R7       */
         LR    R4,R7                                               0913
*                       RFY                                        0914
*                         RT1TRACK BASED(R4);                      0914
*                       R7=PSAAOLD; /* POINT TO THE CURRENT ASCB     */
         L     R7,PSAAOLD                                          0915
*                       IF SDWARCDE^=SDWARETY THEN/* IF A RETRY WAS
*                                      REQUESTED, NO RECOVERY IS   0916
*                                      POSSIBLE IF AN ERROR OCCURS 0916
*                                      DURING THE FREEMAIN, SINCE THE
*                                      RETRY REGS ARE STORED IN THE
*                                      RTM1WA PRIOR TO FREEING THE 0916
*                                      RTCA                          */
         CLI   SDWARCDE(R6),4                                      0916
         BE    @RF00916                                            0916
*                         DO;       /* STORE RECOVERY INFORMATION    */
*                           RT1TREGS(ONE)=R8;/* STORE THE ALREADY  0918
*                                      DETERMINED EXIT TYPE          */
         ST    R8,RT1TREGS(,R4)                                    0918
*                           RT1TLPID=RECOVRY1;/* INDICATE SOME     0919
*                                      RECOVERY IS POSSIBLE IF     0919
*                                      FREEMAIN ERROR OCCURS         */
         MVI   RT1TLPID(R4),X'01'                                  0919
*                           RT1TLPN=FREERTCA;/* LPN=PHASE NUM FOR  0920
*                                      RTCA FREEMAIN ATTEMPT         */
         MVI   RT1TLPN(R4),X'79'                                   0920
*                         END;                                     0921
*                       DO;         /* FREEMAIN(RU)                0922
*                                      LV(SDWALNTH)A(SDWA)         0922
*                                      SP(SDWASPID) BRANCH           */
@RF00916 DS    0H                                                  0923
*                         RESPECIFY                                0923
*                          (GPR01F,                                0923
*                           GPR03F,                                0923
*                           GPR00F) RESTRICTED;                    0923
*                         GPR01F=0; /* REG 1 MUST BE ZERO            */
         SLR   GPR01F,GPR01F                                       0924
*                         GPR03F=3; /* SET TYPE                      */
         LA    GPR03F,3                                            0925
*                         GPR00F=SDWALNTH;/* LENGTH REQUESTED        */
         SLR   GPR00F,GPR00F                                       0926
         ICM   GPR00F,7,SDWALNTH(R6)                               0926
*                         GPR01F=ADDR(SDWA);/* SET REGISTER ONE      */
         LR    GPR01F,R6                                           0927
*                         GPR03F=GPR03F+((SDWASPID)*256);/* SUBPOOL
*                                      VALUE                         */
         SLR   @12,@12                                             0928
         IC    @12,SDWASPID(,R6)                                   0928
         SLA   @12,8                                               0928
         ALR   GPR03F,@12                                          0928
*                         CALL CVTCRMN;/* BRANCH ENTRY POINT         */
         L     @12,CVTPTR                                          0929
         L     @15,CVTCRMN(,@12)                                   0929
         BALR  @14,@15                                             0929
*                         RESPECIFY                                0930
*                          (GPR01F,                                0930
*                           GPR03F,                                0930
*                           GPR00F) UNRESTRICTED;                  0930
*                       END;        /* FREEMAIN(RU)                0931
*                                      LV(SDWALNTH)A(SDWA)         0931
*                                      SP(SDWASPID) BRANCH FREE THE
*                                      SDWA                          */
*                       R7=R4;      /* RESTORE THE CONTENTS OF R7    */
         LR    R7,R4                                               0932
*                       RFY                                        0933
*                         RT1TRACK BASED(R7);                      0933
*                       RFY                                        0934
*                         R4 UNRSTD;/* USED TO SAVE R7 VALUE         */
*FREEMNRP:                          /* RETURN POINT OF LPRR IF ERROR
*                                      OCCURS                        */
*                       GEN(LA R11,4095(R9));/* RESTORE BASE REG   0935
*                                                            @G17EP5W*/
FREEMNRP LA R11,4095(R9)
*                       RT1TLPN=NULL;/* INDICATE RECURSIONS TO BE  0936
*                                      HANDLED AS NEW ERRORS         */
         MVI   RT1TLPN(R7),X'00'                                   0936
*                       RFY                                        0937
*                         R12 RSTD; /* DESTROYED BY SETLOCK          */
*                       RFY                                        0938
*                         R13 RSTD; /* DESTROYED BY SETLOCK          */
*                       RFY                                        0939
*                         R14 RSTD; /* DESTROYED BY SETLOCK          */
*                       GEN;                                       0940
*                                      /*GET THE LOCAL LOCK          */
       SETLOCK RELEASE,TYPE=LOCAL,RELATED=(FREEMAIN,IEAVTRTM(SYSCLEAN))
       LA  R11,4095(R9)       RE-ESTABLISH BASE REGISTER     @G17EP5W
*                       RFY                                        0941
*                         R12 UNRSTD;/* RELEASE CONTROL OF WORK REG  */
*                       RFY                                        0942
*                         R13 UNRSTD;/* RELEASE CONTROL OF WORK REG  */
*                       RFY                                        0943
*                         R14 UNRSTD;/* RELEASE CONTROL OF WORK REG  */
*                     END;          /* END RTCA FREEING PROCESSING   */
*                 END;              /* END SYSTEM CLEAN UP           */
@RF00902 DS    0H                                                  0946
*               LCCAPDAT='0'B;      /* TURN OFF PCFLIH DAT RECURSION
*                                      FLAG IF NOT ALREADY OFF       */
@RF00858 DS    0H                                                  0947
*               LCCAPSG1='0'B;      /* TURN OFF PCFLIH SEG RECURSION
*                                      FLAG IF NOT ALREADY OFF       */
         L     @12,PSALCCAV                                        0947
         NI    LCCAPDAT(@12),B'11001111'                           0947
*               PSAPI2='0'B;        /* TURN OFF PCFLIH RECURSION FLAG
*                                      IF NOT ALREADY OFF - PC HAS NO
*                                      RECOVERY              @ZA03844*/
*               PSAPSREG='0'B;      /* TURN OFF PCFLIH RECURSION FLAG
*                                      IF STILL ON           @ZA03844*/
         NI    PSAPI2,B'10011111'                                  0949
*               RT1TLPN=NULL;       /* MAKE NEW ERRORS APPEAR AS NEW
*                                      (NONRECURSIVE) ONES           */
         MVI   RT1TLPN(R7),X'00'                                   0950
*               PSARTM='0'B;        /* INDICATE RTM IS NO LONGER IN
*                                      CONTROL                       */
         NI    PSARTM,B'11111101'                                  0951
*             END;                  /* END UNIQUE SLIHMODE PROCESS   */
*         ELSE                      /* IF SERVICE ROUTINE MODE       */
*           R8=RT1RET;              /* INDICATE RT1 IS TO RETURN TO
*                                      CALLER                        */
         B     @RC00842                                            0953
@RF00842 LA    R8,38                                               0953
*       END;                        /* END NON MACHCK PROCESSING     */
@RC00842 DS    0H                                                  0955
*     RFY                                                          0955
*       R0 RSTD;                    /* GET CONTROL OF PARM REG       */
@RC00831 DS    0H                                                  0956
*     RFY                                                          0956
*       R1 RSTD;                    /* GET CONTROL OF PARM REG       */
*     R0=R8;                        /* RETURN EXIT INDICATION TO   0957
*                                      IEAVTRT1                      */
         LR    R0,R8                                               0957
*     R1=R10;                       /* RETURN EXIT PARAMETERS TO   0958
*                                      IEAVTRT1 (VALUE IS MEANINGFUL
*                                      ONLY FOR MACHCK AND RETRY EXIT
*                                      TYPES)                        */
         LR    R1,R10                                              0958
*   END;                            /* END EXIT PROCESSING           */
*EEDPROC:                                                          0960
*   PROC OPTIONS(NOSAVE NOSAVEAREA);                               0960
*                                                                  0960
         B     @PB00002                                            0960
EEDPROC  DS    0H                                                  0961
*   /*****************************************************************/
*   /*                                                               */
*   /* THE PURPOSE OF THE EEDPROC SEGMENT IS TO GATHER ERROR         */
*   /* INFORMATION INTO EXTENDED ERROR DESCRIPTORS (EEDS), AND CHAIN */
*   /* THE EEDS AS A SINGLE THREADED FORWARD POINTING QUEUE, WITH THE*/
*   /* ORIGIN OF THE CHAIN IN THE EEDCHAIN REGISTER (R6). IF ERRORID */
*   /* INFORMATION IS IN THE SDWA AND NO HARDWARE REPAIR EED IS BEING*/
*   /* SENT, THE ERRORID INFORMANTION IS ADDED TO THE DUMPS OTION EED*/
*   /* IF IT EXISTS,OR A NEW EED IS GOTTEN.@G17EP5W THE EEDPROC      */
*   /* SEGMENT IS IMPLEMENTED AS A CLOSED SUBROUTINE AND IS CALLED   */
*   /* FROM TWO DIFFERENT PLACES IN THE RESCHEDULE FUNCTION OF THE   */
*   /* RTM1. INPUT TO THIS SEGMENT IS AS FOLLOWS: TRAKAREA REGISTER  */
*   /* (R4) - POINTS TO A RECOVERY TRACKING AREA WHICH IS USED TO    */
*   /* CHECKPOINT VOLATILE REGISTERS. DUMPOPTS REGISTER (R5) -       */
*   /* CONTAINS A POINTER TO DUMP OPTIONS TO BE PLACED INTO EEDS, OR */
*   /* CONTAINS 0 TO INDICATE NO DUMP OPTIONS WERE SUPPLIED. EEDCHAIN*/
*   /* REGISTER (R6) CONTAINS A POINTER TO PREVIOUSLY ACQUIRED EEDS, */
*   /* OR THE VALUE 1 INDICATING A PREVIOUS ATTEMPT FOR AN EED CELL  */
*   /* FAILED, OR 0 INDICATING THAT NO REQUEST FOR EED CELLS HAD BEEN*/
*   /* PREVIOUSLY ATTEMPTED. THERE ARE TWO SITUATIONS WHERE EEDS MAY */
*   /* HAVE BEEN PREVIOUSLY REQUESTED. 1) IF A MACHINE CHECK HAD     */
*   /* OCCURRED, THE HARDWARE REPAIR DATA AND REGISTERS AND PSW AT   */
*   /* TIME OF INTERRUPT WOULD HAVE BEEN PREVIOUSLY PLACED IN EEDS.  */
*   /* 2) IF THE RTM1 HAD SET A LOCALLY LOCKED TASK OR AN SRB WHICH  */
*   /* HAD SUFFERED A PAGE IO ERROR UP FOR ABEND PROCESSING, THE     */
*   /* REGISTERS AND PSW AT TIME OF PAGE FAULT WOULD HAVE BEEN PLACED*/
*   /* IN AN EED. IN EITHER CASE, IF A REQUEST FOR AN EED FAILED,    */
*   /* THEN THE FORWARD POINTER IN THE PREVIOUS EED ( OR IN THE EED  */
*   /* QUEUE ORIGIN) WOULD HAVE BEEN SET TO THE EEDNULL VALUE (1).   */
*   /* SAVAREAP REGISTER (R13) - CONTAINS A POINTER TO THE REGISTERS */
*   /* AT TIME OF ERROR. THIS WOULD BE USED ONLY IF EEDS WERE NOT    */
*   /* PREVIOUSLY PROCESSED (I.E. IF EEDCHAIN=0). R14 - CONTAINS THE */
*   /* RETURN POINT TO THE CALLING SEGMENT. REGS R0-R3, R7 AND R12   */
*   /* ARE NOT USED AS INPUT, BUT THEIR CONTENTS ARE PRESERVED. REGS */
*   /* R8 AND R10 ARE CONSIDERED AVAILABLE AS WORK REGISTERS OUTPUT  */
*   /* FROM THIS SEGMENT IS AN UPDATED EEDCHAIN, IF EEROR DATA WAS   */
*   /* PROCESSED, AND THE CORRESPONDING ALLOCATED EED CELLS.         */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0961
*   RFY                                                            0961
*    (R0,                           /* PRESERVED FOR CALLER          */
*     R1,                           /* PRESERVED FOR CALLER          */
*     R2,                           /* PRESERVED FOR CALLER          */
*     R3,                           /* PRESERVED FOR CALLER          */
*     R4,                           /* PRESERVED FOR CALLER          */
*     R5,                           /* PRESERVED FOR CALLER          */
*     R6,                           /* PRESERVED FOR CALLER          */
*     R7,                           /* PRESERVED FOR CALLER          */
*     R12,                          /* PRESERVED FOR CALLER          */
*     R13,                          /* PRESERVED FOR CALLER          */
*     R14) RSTD;                    /* PRESERVED FOR CALLER          */
*   RFY                                                            0962
*     R10 RSTD;                     /* GET CONTROL OF REG FOR SAVING
*                                      R14S ORIG VALUE               */
*   R10=R14;                        /* PRESERVE RETURN PT VALUE      */
         LR    R10,R14                                             0963
*   RFY                                                            0964
*     R14 UNRSTD;                   /* ALLOW CPLR TO USE R14         */
*   RFY                                                            0965
*     R8 RSTD;                      /* GET CONTROL OF REG FOR      0965
*                                      ADDRESSING CHECKPOINT AREA    */
*   RFY                                                            0966
*     RT1TRACK BASED(R4);           /* REESTABLISH BASE FOR TRACK    */
*   RFY                                                            0967
*     ERREGS BASED(R13);            /* REESTABLISH BASE FOR REGS AT
*                                      TIME OF ERROR                 */
*   R8=ADDR(RT1TREGS);              /* LOCATE CHECKPOINT AREA        */
         LA    R8,RT1TREGS(,R4)                                    0968
*   RFY                                                            0969
*    (R1,                           /* ALLOW COMPR TO USE R1         */
*     R2,                           /* ALLOW COMPILER TO USE R2      */
*     R3) UNRSTD;                   /* ALLOW COMPILER TO USE R3      */
*   IF R6^=NULL THEN                /* IF SOME EED PROCESSING HAS  0970
*                                      PREVIOUSLY BEEN DONE          */
*                                                                  0970
         LTR   R6,R6                                               0970
         BZ    @RF00970                                            0970
*     /***************************************************************/
*     /*                                                             */
*     /* THE PURPOSE OF THE OLDEEDS SEGMENT IS TO VERIFY THAT A      */
*     /* PREVIOUS ATTEMPT TO ACQUIRE AN EED CELL DID NOT FAIL (I.E   */
*     /* THAT GETCELL DID NOT RETURN A NONZERO RETURN CODE) AND TO   */
*     /* DETERMINE IF AN ERRORID EXISTS IN AN EED. INPUT TO THIS     */
*     /* SEGMENT IS THE EEDCHAIN REGISTER (R6). OUTPUT IS THE        */
*     /* FUNCTION REGISTER (R0) SET WITH AN INDICATION TO EXIT THIS  */
*     /* SEGMENT IF A CELL COULD NOT BE OBTAINED OR SET TO ZERO TO   */
*     /* INDICATE FURTHER PROCSSING IS ALLOWED. THE RT1WEREX FLAG IS */
*     /* SET ON IF AN EED WERE FOUND.                                */
*     /*                                                             */
*     /***************************************************************/
*                                                                  0971
*     DO;                           /* CHECK FOR MISSING EEDS        */
*       IF R6=EEDNULL THEN          /* IF THE ORIGIN OF THE CHAIN  0972
*                                      INDICATES MISSING EEDS        */
         CH    R6,@CH00073                                         0972
         BNE   @RF00972                                            0972
*         R0=TAKEEXIT;              /* THEN TERM FURTHER PROCESSING  */
         LA    R0,30                                               0973
*       ELSE                        /* IF AT LEAST 1 EED IS ON THE 0974
*                                      CHAIN                         */
*         DO;                       /* THEN CHECK THE ENTIRE QUEUE 0974
*                                      FOR FAILURE INDICATORS        */
         B     @RC00972                                            0974
@RF00972 DS    0H                                                  0975
*           RFY                                                    0975
*             R2 RSTD;              /* GET A WORK REG FOR SEARCH     */
*           R2=R6;                  /* PRIME IT WITH FIRST ELEM PTR  */
         LR    R2,R6                                               0976
*           RFY                                                    0977
*             EED BASED(R2);        /* ESTABLISH THE BASE FOR THE EED
*                                      MAPPING MACRO                 */
*           DO WHILE(R2>EEDNULL);   /* PERFORM SEARCH LOOP UNTIL THE
*                                      EED PTR INDICATES THAT NO MORE
*                                      EEDS ARE ON CHAIN     @G17EP5W*/
         B     @DE00978                                            0978
@DL00978 DS    0H                                                  0979
*             IF EEDERFL=ON THEN    /* IF ERRORID IN EED     @G17EP5W*/
         TM    EEDERFL(R2),B'10000000'                             0979
         BNO   @RF00979                                            0979
*               IF RT1TENPT>=SLIHLOW&/* IF RTM1 IS IN SLIH   @G17EP5W*/
*                   RT1TENPT<=SLIHHI THEN/* MODE PROCESSING  @G17EP5W*/
         CLI   RT1TENPT(R4),1                                      0980
         BL    @RF00980                                            0980
         CLI   RT1TENPT(R4),9                                      0980
         BH    @RF00980                                            0980
*                 DO;               /* PROCESSING THEN       @G17EP5W*/
*                   RT1WEREX=ON;    /* SET FLAG IN RT1W      @G17EP5W*/
         L     @03,PSACSTK                                         0982
         OI    RT1WEREX(@03),B'00001000'                           0982
*                 END;              /* END EED FLAG          @G17EP5W*/
*             R2=EEDFWRDP;          /* POINT TO NEXT ELEMENT         */
@RF00980 DS    0H                                                  0984
@RF00979 L     R2,EEDFWRDP(,R2)                                    0984
*           END;                    /* GO SEE IF LOOP SHOULD BE    0985
*                                      EXITED                        */
@DE00978 LA    @03,1                                               0985
         CR    R2,@03                                              0985
         BH    @DL00978                                            0985
*           IF R2=EEDNULL THEN      /* IF THE LAST CELL ON THE CHAIN
*                                      HAD AN INDICATION THAT A    0986
*                                      PREVIOUS GETCELL ATTEMPT    0986
*                                      FAILED THEN                   */
         CR    R2,@03                                              0986
         BNE   @RF00986                                            0986
*             R0=TAKEEXIT;          /* FORCE A PREMATURE EXIT        */
         LA    R0,30                                               0987
*           ELSE                    /* IF ALL GETCELLS WERE OK       */
*             R0=NULL;              /* THEN PERFORM OTHER EED PROC   */
         B     @RC00986                                            0988
@RF00986 SLR   R0,R0                                               0988
*         END;                      /* END QUEUE SEARCHING           */
*     END;                          /* END CHECK OF OLD EEDS         */
*   ELSE                            /* IF EED PROCESSING WAS NOT   0991
*                                      PREVIOUSLY PERFORMED, THEN    */
*                                                                  0991
*     /***************************************************************/
*     /*                                                             */
*     /* THE PURPOSE OF THE NEWEEDS SEGMENT IS TO OBTAIN A CELL FOR  */
*     /* AN EED, AND TO FILL IN THE EED WITH THE REGISTERS AND PSW   */
*     /* ASSOCIATED WITH THE ERROR BEING HANDLED BY THE RTM1. IF A   */
*     /* CELL COULD NOT BE OBTAINED, THEN AN INDICATOR IS SET TO     */
*     /* BYPASS FURTHER EED PROCESSING. INPUT TO THIS SEGMENT IS AS  */
*     /* FOLLOWS: WORKREG REGISTER (R8) - CONTAINS THE POINTER TO THE*/
*     /* CHECKPOINTED ENTRY REGS. THESE ENTRY REGS MUST BE RELOADED  */
*     /* SO THAT FIELDS IN THE RT1 TRACKING AREA CAN BE REFERENCED.  */
*     /* SAVAREAP REGISTER (R13) - POINTS TO REGISTERS AT TIME OF    */
*     /* ERROR TO BE MOVED INTO THE EED. RTM1WA - CONTAINS A POINTERS*/
*     /* TO THE PSW AT TIME OF ERROR IF THE RTM1 IS OPERATING AS A   */
*     /* SLIH. OUTPUT IS THE FUNCTION REGISTER (R0) SET WITH AN      */
*     /* INDICATION TO EXIT THIS SEGMENT IF A CELL COULD NOT BE      */
*     /* OBTAINED AND AN UPDATED EEDCHAIN REGISTER (R6) TO CONTAIN   */
*     /* EITHER THE NULL INDICATOR, IF A CELL WASNT OBTAINED, OR THE */
*     /* PTR TO THE EED IF ONE WERE OBTAINED.                        */
*     /*                                                             */
*     /***************************************************************/
*                                                                  0991
*     DO;                           /* PROCESS A NEW EED             */
         B     @RC00970                                            0991
@RF00970 DS    0H                                                  0992
*       RFY                                                        0992
*        (R0,                       /* GET CONTOL OF GETCELL PARM    */
*         R1,                       /* GET CONTROL OF QCELL PARM RG  */
*         R15,                      /* GET CONTROL OF QCELL PARM RG  */
*         R2,                       /* CLOBBERED BY GETCELL          */
*         R3,                       /* CLOBBERED BY GETCELL          */
*         R4) RSTD;                 /* CLOBBERED BY GETCELL          */
*       R0=RT1CPOOL;                /* INDICATE RT1 CELL POOLID      */
         L     R0,RT1CPOOL                                         0993
*       GEN(GETCELL CPID=(0),BRANCH=YES,SAVE=NO);/* ATTEMPT TO GET A
*                                      CELL FOR THE EED              */
         GETCELL CPID=(0),BRANCH=YES,SAVE=NO
*       GEN(LA R11,4095(R9));       /* RESTORE BASE REG      @G17EP5W*/
         LA R11,4095(R9)
*       IF R15^=QCELNORM THEN       /* IF A CELL WAS NOT ACQUIRED    */
         LTR   R15,R15                                             0996
         BZ    @RF00996                                            0996
*         DO;                       /* PROCESS GETCELL FAILURE       */
*           R6=EEDNULL;             /* INDICATE EED INFO LOST        */
         LA    R6,1                                                0998
*           R0=TAKEEXIT;            /* CAUSE SUBSEQUENT EED PROCES-
*                                      SING TO BE BYPASSED           */
         LA    R0,30                                               0999
*         END;                      /* END GETCELL FAILURE PROCESS   */
*       ELSE                        /* IF A CELL WAS OBTAINED        */
*         DO;                       /* FILL IT IN WITH REG INFO      */
         B     @RC00996                                            1001
@RF00996 DS    0H                                                  1002
*           R6=R1;                  /* MAKE THIS CELL THE FIRST ONE
*                                      ON THE CHAIN                  */
         LR    R6,R1                                               1002
*           RFY                                                    1003
*             EED BASED(R6);        /* BASE THE EED MAPPING MACRO ON
*                                      THE NEWLY ACQUIRED CELL       */
*           EED=''B;                /* INITIALIZE THE EED            */
         XC    EED(92,R6),EED(R6)                                  1004
*           EEDID=REGSPTYP;         /* INDICATE THE EED IS A REGIS-
*                                      TER AND PSW TYPE              */
         MVI   EEDID(R6),X'01'                                     1005
*           EEDREGS=ERREGS;         /* MOVE IN REGS AT TIME OF ERR   */
         MVC   EEDREGS(64,R6),ERREGS(R13)                          1006
*           GEN(LM R0,R4,0(R8));    /* RELOAD THE ORIGINAL REGS -  1007
*                                      THIS WILL CAUSE THE FUNCTION
*                                      REGISTER TO HAVE A VALUE WHICH
*                                      WILL NOT BE = TO THE TAKEEXIT
*                                      VALUE. ALSO THIS WILL ALLOW 1007
*                                      ADDRESSABILITY TO THE RTM   1007
*                                      TRACK AREA                    */
         LM R0,R4,0(R8)
*           IF RT1TENPT>=SLIHLOW&   /* IF THE RTM1 IS OPERATING IN   */
*               RT1TENPT<=SLIHHI THEN/* SECOND LEV INTERRUPT HANDLR  */
         CLI   RT1TENPT(R4),1                                      1008
         BL    @RF01008                                            1008
         CLI   RT1TENPT(R4),9                                      1008
         BH    @RF01008                                            1008
*             DO;                   /* THEN A PSW IS AVAILABLE       */
*               EEDPSW1=RT1WPSW1->PSW;/* MOVE THE FIRST HALF OF THE
*                                      PSW INTO THE EED              */
         L     @14,PSACSTK                                         1010
         L     @14,RT1WPSW1(,@14)                                  1010
         MVC   EEDPSW1(8,R6),PSW(@14)                              1010
*               EEDPSW2=RT1WPSW2->PSWEXT1;/* MOVE SECOND HALF OF PSW
*                                      INTO THE EED                  */
         L     @14,PSACSTK                                         1011
         L     @14,RT1WPSW2(,@14)                                  1011
         MVC   EEDPSW2(8,R6),PSWEXT1(@14)                          1011
*             END;                  /* END PSW MOVES                 */
*           ELSE                                                   1013
*             ;                     /* IF NOT IN SLIH MODE THEN THEIR
*                                      IS NO PSW ASSOCIATED WITH THE
*                                      ERROR                         */
@RF01008 DS    0H                                                  1014
*           R12->RT1TREGS(THREE)=R6;/* CHECKPOINT NEW VALUE OF     1014
*                                      EEDCHAIN POINTER              */
         ST    R6,RT1TREGS+8(,R12)                                 1014
*         END;                      /* END EED FILLING IN            */
*     END;                          /* END PROCESSING OF NEW EED     */
@RC00996 DS    0H                                                  1017
*   IF R0^=TAKEEXIT THEN            /* IF A PREVIOUS ATTEMPT TO    1017
*                                      OBTAIN AN EED CELL HAS NOT  1017
*                                      FAILED, THEN                  */
@RC00970 LA    @14,30                                              1017
         CR    R0,@14                                              1017
         BE    @RF01017                                            1017
*     DO;                           /* PROCESS DUMPOPTS EED          */
*       R0=TAKEEXIT;                /* SET INDICATOR TO NO EED NEEDED
*                                      FOR ERRORID           @G17EP5W*/
         LR    R0,@14                                              1019
*       RFY                                                        1020
*        (R4) RSTD;                 /* RESTRICT REG          @G17EP5W*/
*       R4=(R8-LENGTH(RT1TRECC))->RT1TREGS(5);/* RELOAD BASE PTR TO
*                                      TRACKING AREA         @G17EP5W*/
         L     R4,RT1TREGS+12(,R8)                                 1021
*       IF RT1TENPT>=SLIHLOW&       /* IF THE RTM1 IS OPERATING IN   */
*           RT1TENPT<=SLIHHI THEN   /* SECOND LEV INTERRUPT HANDLR   */
         CLI   RT1TENPT(R4),1                                      1022
         BL    @RF01022                                            1022
         CLI   RT1TENPT(R4),9                                      1022
         BH    @RF01022                                            1022
*         DO;                       /* THEN CHECK WORKAREA   @G17EP5W*/
*           RFY                                                    1024
*            (R3,                                                  1024
*             R4) UNRSTD;           /* COMPILER WORK REGS    @G17EP5W*/
*           IF RT1WEREX=OFF THEN    /* IF ERRORID ^ IN EEDS  @G17EP5W*/
         L     @14,PSACSTK                                         1025
         TM    RT1WEREX(@14),B'00001000'                           1025
         BNZ   @RF01025                                            1025
*             IF RT1WRTCA^=NULL THEN/* & RTCA EXISTS WITH    @G17EP5W*/
         L     @14,RT1WRTCA(,@14)                                  1026
         LTR   @14,@14                                             1026
         BZ    @RF01026                                            1026
*               IF RT1WRTCA->SDWAERFL=ON THEN/* AN ERRORID   @G17EP5W*/
         TM    SDWAERFL(@14),B'00000001'                           1027
         BNO   @RF01027                                            1027
*                 R0=NULL;          /* SET INDICATOR TO GET EED    1028
*                                                            @G17EP5W*/
         SLR   R0,R0                                               1028
*         END;                      /* END CHECK SLIH MODE   @G17EP5W*/
@RF01027 DS    0H                                                  1029
@RF01026 DS    0H                                                  1029
@RF01025 DS    0H                                                  1030
*       IF((R5^=NULL)×              /* IF DUMP OPTIONS WERE PROVIDD  */
*           (R0=NULL)) THEN         /* OR ERRORID EED NEED   @G17EP5W*/
*                                                                  1030
@RF01022 SLR   @14,@14                                             1030
         CR    R5,@14                                              1030
         BNE   @RT01030                                            1030
         CR    R0,@14                                              1030
         BNE   @RF01030                                            1030
@RT01030 DS    0H                                                  1031
*         /***********************************************************/
*         /*                                                         */
*         /* THE PURPOSE OF THE DUMPEED SEGMENT IS TO PLACE DUMP     */
*         /* OPTIONS PASSED BY THE INVOKER OF THE ABEND, CALLRTM, OR */
*         /* SETRP MACRO INTO EEDS FOR EVENTUAL PROCESSING BY THE    */
*         /* RTM2. IF AN ERRORID EXISTS AND HAS NOT BEEN PUT IN AN   */
*         /* EED, THE ERRORID IS PUT IN THE EED. THE EEDTYPE WILL BE */
*         /* EITHER DUMPOTYP OR ERRIDTYP. THE FORMAT OF DUMP OPTIONS */
*         /* WILL BE DIFFERENT IF SET UP BY SETRP THAN BY THE L FORM */
*         /* OF THE SNAP MACRO (USED WITH THE CALLRTM AND ABEND      */
*         /* MACROS). UPON ENTRY TO THIS SEGMENT, THE DUMPOPTS       */
*         /* REGISTER (R5) WILL CONTAIN A POINTER TO THE USER        */
*         /* PROVIDED DUMP OPTION PARAMETERS. FOR OTHER INPUT SEE THE*/
*         /* SEGMENT PROLOG FOR THE EEDPROC SEGMENT. OUTPUT FROM THIS*/
*         /* SEGMENT IS AN EED CONTAINING EITHER DUMP OPTIONS OR AN  */
*         /* ERRORID OR BOTH.                                        */
*         /*                                                         */
*         /***********************************************************/
*                                                                  1031
*         DO;                       /* PROCESS DUMP OPTIONS          */
*           RFY                                                    1032
*            (R0,                   /* GET CONTOL OF GETCELL PARM    */
*             R1,                   /* GET CONTROL OF QCELL PARM RG  */
*             R15,                  /* GET CONTROL OF QCELL PARM RG  */
*             R2,                   /* CLOBBERED BY GETCELL          */
*             R3,                   /* CLOBBERED BY GETCELL AND USED
*                                      AS A WORK REGISTER            */
*             R4) RSTD;             /* CLOBBERED BY GETCELL AND USED
*                                      AS WORK REG                   */
*           R0=RT1CPOOL;            /* INDICATE RT1 CELL POOLID      */
         L     R0,RT1CPOOL                                         1033
*           GEN(GETCELL CPID=(0),BRANCH=YES,SAVE=NO);/* ATTEMPT TO 1034
*                                      GET A CELL FOR THE EED        */
         GETCELL CPID=(0),BRANCH=YES,SAVE=NO
*           GEN(LA R11,4095(R9));   /* RESTORE BASE REG      @G17EP5W*/
*                                                                  1035
         LA R11,4095(R9)
*           /*********************************************************/
*           /*                                                       */
*           /* THE FOLLOWING CODE LOCATES THE END OF THE EED CHAIN   */
*           /*                                                       */
*           /*********************************************************/
*                                                                  1036
*           RFY                                                    1036
*             EED BASED(R2);        /* GET BASE FOR EED MAPPING      */
*           R2=R6;                  /* PRIME EED PTR TO POINT TO THE
*                                      FIRST EED ON CHAIN            */
         LR    R2,R6                                               1037
*           DO WHILE(EEDFWRDP^=NULL);/* SET UP A LOOP TO SEARCH THE
*                                      EEDCHAIN UNTIL THE END OF THE
*                                      CHAIN IS FOUND                */
         B     @DE01038                                            1038
@DL01038 DS    0H                                                  1039
*             R2=EEDFWRDP;          /* POINT TO NEXT ELEMENT         */
         L     R2,EEDFWRDP(,R2)                                    1039
*           END;                    /* GO SEE IF END OF CHAIN FOUND  */
@DE01038 SLR   @14,@14                                             1040
         C     @14,EEDFWRDP(,R2)                                   1040
         BNE   @DL01038                                            1040
*           IF R15^=QCELNORM THEN   /* IF AN EED WASNT ACQUIRED      */
         CR    R15,@14                                             1041
         BE    @RF01041                                            1041
*             EEDFWRDP=EEDNULL;     /* THEN INDICATE THAT DATA WAS 1042
*                                      LOST BY MARKING THE FORWARD 1042
*                                      PTR OF THE LAST CHAINED EED   */
         MVC   EEDFWRDP(4,R2),@CF00073                             1042
*           ELSE                    /* IF AN EED CELL WAS OBTAINED   */
*             DO;                   /* FILL IN DUMP INFO             */
         B     @RC01041                                            1043
@RF01041 DS    0H                                                  1044
*               EEDFWRDP=R1;        /* ENQUEUE THE NEW CELL          */
         ST    R1,EEDFWRDP(,R2)                                    1044
*               RFY                                                1045
*                 EED BASED(R1);    /* CHANGE EED MAPPING MACRO BASE
*                                      TO USE NEW CELL               */
*               EED=''B;            /* ZERO OUT ENTIRE EED           */
         XC    EED(92,R1),EED(R1)                                  1046
*               IF R5^=NULL THEN    /* CHEK IF DUMP OPTIONS@G17EP5W  */
         LTR   R5,R5                                               1047
         BZ    @RF01047                                            1047
*                 DO;               /* ADD THEM TO EED       @G17EP5W*/
*                   EEDID=DUMPOTYP; /* INDICATE EED CONTAINS DUMP  1049
*                                      OPTIONS                       */
         MVI   EEDID(R1),X'02'                                     1049
*                   RFY                                            1050
*                    (R4) RSTD;     /* RESTRICT REG          @G17EP5W*/
*                   R4=(R8-LENGTH(RT1TRECC))->RT1TREGS(5);/* RELOAD
*                                      BASE PTR TO TRACKING AREA     */
         L     R4,RT1TREGS+12(,R8)                                 1051
*                   IF(RT1TENPT>=SLIHLOW&/* IF RTM IS RUNNING IN     */
*                       RT1TENPT<=SLIHHI) THEN/* SLIH MODE           */
         CLI   RT1TENPT(R4),1                                      1052
         BL    @RF01052                                            1052
         CLI   RT1TENPT(R4),9                                      1052
         BH    @RF01052                                            1052
*                     R0=NULL;      /* SET INDICATOR         @G17EP5W*/
         SLR   R0,R0                                               1053
*                   ELSE            /*                       @G17EP5W*/
*                     R0=TAKEEXIT;  /*                       @G17EP5W*/
         B     @RC01052                                            1054
@RF01052 LA    R0,30                                               1054
*                   RFY                                            1055
*                     R4 UNRSTD;    /* FREE FOR COMPILER     @G17EP5W*/
@RC01052 DS    0H                                                  1056
*                   IF R0=NULL&     /*                       @G17EP5W*/
*                       RT1WRTCA^=NULL THEN/* AND SRM WAS INVOKED  1056
*                                      THEN                          */
         SLR   @14,@14                                             1056
         CR    R0,@14                                              1056
         BNE   @RF01056                                            1056
         L     @04,PSACSTK                                         1056
         C     @14,RT1WRTCA(,@04)                                  1056
         BE    @RF01056                                            1056
*                     EEDDUMPO=DUMPARMS;/* COPY DUMP OPTS FROM SDWA  */
         MVC   EEDDUMPO(44,R1),DUMPARMS(R5)                        1057
*                   ELSE            /* IF DUMP PARMS DID NOT COME  1058
*                                      FROM AN FRR                   */
*                     DO;           /* PROCESS SNAP FORMAT DUMPOPTS  */
         B     @RC01056                                            1058
@RF01056 DS    0H                                                  1059
*                       EEDSCDMP=SNPCDMP;/* MOVE IN COMMON SECTION OF
*                                      SNAP PARMS                    */
         MVC   EEDSCDMP(8,R1),SNPCDMP(R5)                          1059
*                       IF SNPSLIST='1'B THEN/* IF STORAGE RANGES  1060
*                                      PROVIDED                      */
         TM    SNPSLIST(R5),B'00000010'                            1060
         BNO   @RF01060                                            1060
*                         DO;       /* MOVE THEM INTO THE EED        */
*                           RFY                                    1062
*                             R3 RSTD;/* RESTRICT REG        @G17EP5W*/
*                           DO R3=FIRST/* CALCULATE AMOUNT TO MOVE BY
*                                      INITIALIZING LENGTH TO THE  1063
*                                      FIRST PAIR            @YM02799*/
*                                 BY ONE/* SET LOOP INCREMENT      1063
*                                                            @YM02799*/
*                                 WHILE(STOREND(R3)='0'B/* UNTIL THE
*                                      END OF LIST IS DETECTED     1063
*                                                            @YM02799*/
*                                 &R3<DIM(LISTPAIR));/* OR THE     1063
*                                      MAXIMUM NUMBER OF STORAGE   1063
*                                      RANGES IS REACHED     @YM02799*/
         LA    R3,1                                                1063
         B     @DE01063                                            1063
@DL01063 DS    0H                                                  1064
*                           END;    /* END OF SEARCH LOOP    @YM02799*/
         AL    R3,@CF00073                                         1064
@DE01063 LR    @14,R3                                              1064
         SLA   @14,3                                               1064
         L     @04,SNPSTOR(,R5)                                    1064
         ALR   @04,@14                                             1064
         AL    @04,@CF03680                                        1064
         TM    STOREND-4(@04),B'10000000'                          1064
         BNZ   @DC01063                                            1064
         CH    R3,@CH00134                                         1064
         BL    @DL01063                                            1064
@DC01063 DS    0H                                                  1065
*                           R3=R3*LENGTH(LISTPAIR);/* CONVERT THE  1065
*                                      NUMBER OF PAIRS TO BYTES      */
         SLL   R3,3                                                1065
*                           EEDSDPSL(FIRST:R3)=STORLIST(FIRST:R3);/*
*                                      MOVE IN STORAGE RANGE LIST    */
         LR    @14,R3                                              1066
         BCTR  @14,0                                               1066
         L     @04,SNPSTOR(,R5)                                    1066
         EX    @14,@SM03681                                        1066
*                         END;      /* END STORAGE RANGE PROCESSING  */
*                     END;          /* END SNAP FORMAT PROCESSING    */
@RF01060 DS    0H                                                  1069
*                 END;              /* END DUMPOPT PROCESS   @G17EP5W*/
*                                                                  1069
@RC01056 DS    0H                                                  1070
*               /*****************************************************/
*               /*                                                   */
*               /* PUT ERRORID IN EED IF APPLICABLE                  */
*               /*                                                   */
*               /*****************************************************/
*                                                                  1070
*               RFY                                                1070
*                (R4) RSTD;         /* RESTRICT REG          @G17EP5W*/
@RF01047 DS    0H                                                  1071
*               R4=(R8-LENGTH(RT1TRECC))->RT1TREGS(5);/* RELOAD BASE
*                                      PTR TO TRACKING AREA  @G17EP5W*/
         L     R4,RT1TREGS+12(,R8)                                 1071
*               IF(RT1TENPT>=SLIHLOW&/* IF RTM IS RUNNING IN SLIH    */
*                   RT1TENPT<=SLIHHI) THEN/* MODE CHECK FOR  @G17EP5W*/
         CLI   RT1TENPT(R4),1                                      1072
         BL    @RF01072                                            1072
         CLI   RT1TENPT(R4),9                                      1072
         BH    @RF01072                                            1072
*                 R0=NULL;          /* AN ERRORID            @G17EP5W*/
         SLR   R0,R0                                               1073
*               ELSE                /* OTHERWISE SKIP        @G17EP5W*/
*                 R0=TAKEEXIT;      /* THIS SECTION          @G17EP5W*/
         B     @RC01072                                            1074
@RF01072 LA    R0,30                                               1074
*               RFY                                                1075
*                 R4 UNRSTD;        /* FREE FOR COMPILER     @G17EP5W*/
@RC01072 DS    0H                                                  1076
*               IF R0=NULL THEN     /*                       @G17EP5W*/
         SLR   @14,@14                                             1076
         CR    R0,@14                                              1076
         BNE   @RF01076                                            1076
*                 IF((RT1WEREX=OFF)&/* NO ERRORID IN EED &   @G17EP5W*/
*                     (RT1WRTCA^=NULL)&/* SDWA EXISTS WITH   @G17EP5W*/
*                     (RT1WRTCA->SDWAERFL=ON)) THEN/* AN ERRORID THEN
*                                                            @G17EP5W*/
         L     @04,PSACSTK                                         1077
         TM    RT1WEREX(@04),B'00001000'                           1077
         BNZ   @RF01077                                            1077
         L     @04,RT1WRTCA(,@04)                                  1077
         CR    @04,@14                                             1077
         BE    @RF01077                                            1077
         TM    SDWAERFL(@04),B'00000001'                           1077
         BNO   @RF01077                                            1077
*                   DO;             /* MOVE IT TO EED        @G17EP5W*/
*                     R2=RT1WRTCA;  /* ADDR.OF SDWA          @G17EP5W*/
         LR    R2,@04                                              1079
*                     RFY                                          1080
*                       SDWA BASED(R2);/* SDWA ADDRESSABILITY      1080
*                                                            @G17EP5W*/
*                     EEDESEQ#=SDWASEQ#;/* SEQUENCE NUM      @G17EP5W*/
         MVC   EEDESEQ#(2,R1),SDWASEQ#(R2)                         1081
*                     IF(SDWAFMID^=NULL)&/* IF ERROR MEM.^CUR      1082
*                                                            @G17EP5W*/
*                         (SDWAFMID^=INVLASID) THEN/* AND VALID THEN
*                                                            @G17EP5W*/
         SLR   @04,@04                                             1082
         ICM   @04,3,SDWAFMID(R2)                                  1082
         CR    @14,@04                                             1082
         BE    @RF01082                                            1082
         CLC   SDWAFMID(2,R2),@CB00207                             1082
         BE    @RF01082                                            1082
*                       EEDEASID=SDWAFMID;/* USE ERROR ASID  @G17EP5W*/
         MVC   EEDEASID(2,R1),SDWAFMID(R2)                         1083
*                     ELSE          /* ELSE USE CURRENT      @G17EP5W*/
*                       EEDEASID=PSAAOLD->ASCBASID;/* ASID   @G17EP5W*/
         B     @RC01082                                            1084
@RF01082 L     @14,PSAAOLD                                         1084
         MVC   EEDEASID(2,R1),ASCBASID(@14)                        1084
*                     EEDECPUI=SDWACPUI;/* LOGICAL CPUID     @G17EP5W*/
@RC01082 SLR   @14,@14                                             1085
         IC    @14,SDWACPUI(,R2)                                   1085
         STH   @14,EEDECPUI(,R1)                                   1085
*                     EEDETIME=SDWAERTM;/* TIME STAMP        @G17EP5W*/
         MVC   EEDETIME(4,R1),SDWAERTM(R2)                         1086
*                     EEDERFL=ON;   /* SET ERRORID FLAG ON   @G17EP5W*/
         OI    EEDERFL(R1),B'10000000'                             1087
*                     IF EEDID^=DUMPOTYP THEN/* IF DUMPOPTS^IN EED 1088
*                                                            @G17EP5W*/
         CLI   EEDID(R1),2                                         1088
         BE    @RF01088                                            1088
*                       EEDID=ERRIDTYP;/* THEN MARK AS ERRORID     1089
*                                                            @G17EP5W*/
         MVI   EEDID(R1),X'04'                                     1089
*                     RFY                                          1090
*                       SDWA BASED; /* REMOVE R2 SDWA ADDR   @G17EP5W*/
@RF01088 DS    0H                                                  1091
*                   END;            /* END ERRORID PROCESS   @G17EP5W*/
*               RFY                                                1092
*                (R4) RSTD;         /* RESTRICT REG          @G17EP5W*/
@RF01077 DS    0H                                                  1092
@RF01076 DS    0H                                                  1093
*             END;                  /* END FILLING IN OF EED         */
*         END;                      /* END DUMPOPTS PROCESSING       */
@RC01041 DS    0H                                                  1095
*     END;                          /* END NON FORCED EXIT PROCESSN  */
@RF01030 DS    0H                                                  1096
*   GEN(LM R0,R4,0(R8));            /* RESTORE CALLERS REGS          */
@RF01017 DS    0H                                                  1096
         LM R0,R4,0(R8)
*   IF RT1TENPT>=SLIHLOW&           /* IF THE RTM1 IS OPERATING IN   */
*       RT1TENPT<=SLIHHI THEN       /* SECOND LEV INTERRUPT HANDLR   */
         CLI   RT1TENPT(R4),1                                      1097
         BL    @RF01097                                            1097
         CLI   RT1TENPT(R4),9                                      1097
         BH    @RF01097                                            1097
*     DO;                           /*                       @G33NPHE*/
*       RT1WEREX=OFF;               /* SET TEMP FLAG OFF     @G17EP5W*/
         L     @14,PSACSTK                                         1099
         NI    RT1WEREX(@14),B'11110111'                           1099
*       IF RT1NODMP=ON              /* CHECK TO SEE IF SLIP HAS    1100
*                                      SPECIFIED DUMP SUPPRESSION  1100
*                                                            @G33NPHE*/
*           &R6^=NULL               /* AND THAT THE EED PTR IS GOOD
*                                                            @G33NPHE*/
*           &R6^=EEDNULL            /* AND ALSO THAT THERE IS AN EED
*                                      AVAILABLE             @G33NPHE*/
*         THEN                      /* IF ALL THIS IS TRUE FORWARD 1100
*                                      THE DUMP SUPPRESSION        1100
*                                      SPECIFICATION INTO THE EED  1100
*                                                            @G33NPHE*/
         TM    RT1NODMP(@14),B'00000100'                           1100
         BNO   @RF01100                                            1100
         LTR   R6,R6                                               1100
         BZ    @RF01100                                            1100
         CH    R6,@CH00073                                         1100
         BE    @RF01100                                            1100
*         R6->EEDNODMP=ON;          /* PASS SLIP NODUMP TO RTM2    1101
*                                                            @G33NPHE*/
         OI    EEDNODMP(R6),B'01000000'                            1101
*     END;                          /*                       @G33NPHE*/
@RF01100 DS    0H                                                  1103
*   RFY                                                            1103
*     R14 RSTD;                     /* GET CONTROL OF RETURN REG     */
@RF01097 DS    0H                                                  1104
*   R14=R10;                        /* REPLACE ORIGINAL VALUE        */
         LR    R14,R10                                             1104
*   RFY                                                            1105
*     R10 UNRSTD;                   /* RELEASE REG CONTAINING RETURN
*                                      VALUE                         */
*   END;                            /* RETURN TO CALLER              */
@EL00002 DS    0H                                                  1106
@EF00002 DS    0H                                                  1106
@ER00002 BR    @14                                                 1106
*ASIDCK:                                                           1107
*                                                                  1107
*   /*****************************************************************/
*   /*                                                               */
*   /* THE PURPOSE FOR THE ASIDCK SEGMENT IS TO VERIFY THAT AN ASID  */
*   /* INPUTTED TO THE RTM1 REPRESENTS A VALID VIABLE ADDRESS SPACE. */
*   /* THIS SEGMENT IS IMPLEMENTED AS A CLOSED NESTED SUBROUTINE     */
*   /* SINCE IT IS CALLED FROM TWO DIFFERENT SEGMENTS IN THE         */
*   /* RESCHEDULE FUNCTION (I.E. VIA MEMTERM AND XMABTRM). INPUT IS  */
*   /* AS FOLLOWS: TARGASID REGISTER (R2) - CONTAINS THE ASID TO BE  */
*   /* VALIDITY CHECKED OR THE VALUE 0 REPRESENTING CURRENT ADDRESS  */
*   /* SPACE OUTPUT IS AS FOLLOWS: FUNCTION REGISTER (R0) - SET TO AN*/
*   /* EXIT INDICATION IF ANY OF THE VALIDITY CHECKS FAILED. ASCBADDR*/
*   /* REGISTER (R8) - SET TO THE ADDRESS OF THE ASCB FOR THE GIVEN  */
*   /* ASID. TARGASID REGISTER (R2) - SET TO THE ASID OF THE CURRENT */
*   /* ADDRESS SPACE IF THE VALUE WAS ZERO ON ENTRY                  */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  1107
*   PROC OPTIONS(NOSAVE NOSAVEAREA);                               1107
ASIDCK   DS    0H                                                  1108
*   RFY                                                            1108
*    (R0,                           /* PRESERVED FOR CALLER          */
*     R1,                           /* PRESERVED FOR CALLER          */
*     R2,                           /* PRESERVED FOR CALLER          */
*     R3,                           /* PRESERVED FOR CALLER          */
*     R4,                           /* PRESERVED FOR CALLER          */
*     R5,                           /* PRESERVED FOR CALLER          */
*     R6,                           /* PRESERVED FOR CALLER          */
*     R8,                           /* OUTPUT FOR CALLER             */
*     R12,                          /* PRESERVED FOR CALLER          */
*     R13,                          /* PRESERVED FOR CALLER          */
*     R14) RSTD;                    /* PRESERVED FOR CALLER          */
*   RFY                                                            1109
*    (R10,                          /* AVAILABLE FOR COMPILERS USE   */
*     R15) UNRSTD;                  /* AVAILABLE FOR COMPILERS USE   */
*   IF R2=NULL THEN                 /* IF RTM1 IS TO BE SCHEDULED  1110
*                                      INTO THE CURRENT ADDR SPACE   */
         LTR   R2,R2                                               1110
         BNZ   @RF01110                                            1110
*     R2=PSAAOLD->ASCBASID;         /* GET PROPER ID FOR CURRENT     */
*                                                                  1111
         L     @15,PSAAOLD                                         1111
         SLR   R2,R2                                               1111
         ICM   R2,3,ASCBASID(@15)                                  1111
*   /*****************************************************************/
*   /*                                                               */
*   /* NOTE: IF THE ASVT IS BEING USED WITHOUT HOLDING THE LOCK AND  */
*   /* IF THE ADDRESS SPACE IS CURRENTLY IN DELETE PROCESSING, IT IS */
*   /* POSSIBLE THE VALIDITY CHECKS WILL APPEAR VALID, EVEN THOUGH   */
*   /* THE ADDRESS SPACE IS LOGICALLY TERMINATED.                    */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  1112
*   RFY                                                            1112
*     R8 RSTD;                      /* THE FOLLOWING USE OF R8 IS TO
*                                      BYPASS A PROBLEM WITH PLS   1112
*                                      REGISTER HISTORY. SINCE THE 1112
*                                      INDEX VALUE FOR THE ASVT ARRAY
*                                      IS DYNAMICALLY CALCULATED BY
*                                      PLS, IT STORES THE VALUE IN A
*                                      TEMP AREA FOR USE IN THE    1112
*                                      SECOND ARRAY REFERENCE. THIS
*                                      MODULE CANNOT HAVE TEMP AREAS
*                                      FOR PLS, THERE- FORE, A     1112
*                                      DIFFERENT VALUE (R8) IS USED
*                                      FOR THE THE SECOND ARRAY INDEX
*                                      EVEN THOUGH IT IS EQUAL TO THE
*                                      ASID REG.                     */
@RF01110 DS    0H                                                  1113
*   R8=R2;                          /* ASSIGN DUPLICATE INDEX (SEE 1113
*                                      COMMENT ABOVE)                */
         LR    R8,R2                                               1113
*   IF R2>ASVTMAXU×                 /* IF THE ASID IS NOT WITHIN THE
*                                      RANGE OF VALID ASIDS, OR      */
*       ASVTAVAL(R2)='1'B×          /* THE ASID IS NOT CURRENTLY   1114
*                                      ASSIGNED                      */
*       ASVTENTY(R8)->ASCBASCB^=ASCBID THEN/* OR THE ASVT ENTRY DOES
*                                      NOT PT TO A VALID ASCB, THEN  */
         L     @15,CVTPTR                                          1114
         L     @15,CVTASVT(,@15)                                   1114
         C     R2,ASVTMAXU(,@15)                                   1114
         BH    @RT01114                                            1114
         LR    @10,R2                                              1114
         SLA   @10,2                                               1114
         ALR   @10,@15                                             1114
         TM    ASVTAVAL-4(@10),B'10000000'                         1114
         BO    @RT01114                                            1114
         LR    @10,R8                                              1114
         SLA   @10,2                                               1114
         L     @15,ASVTENTY-4(@10,@15)                             1114
         CLC   ASCBASCB(4,@15),@CC00203                            1114
         BE    @RF01114                                            1114
@RT01114 DS    0H                                                  1115
*     R0=TAKEEXIT;                  /* TERMINATE FURTHER PROCESSING  */
         LA    R0,30                                               1115
*   ELSE                            /* OTHERWISE, IF ASID IS VALID   */
*     DO;                                                          1116
         B     @RC01114                                            1116
@RF01114 DS    0H                                                  1117
*       R8=ASVTENTY(R2);            /* PUT THE ASCB ADDRESS        1117
*                                      ASSOCIATED WITH THE GIVEN ASID
*                                      IN A WORK REGISTER FOR      1117
*                                      SUBSEQUENT PROCESSING         */
         LR    @15,R2                                              1117
         SLA   @15,2                                               1117
         L     @10,CVTPTR                                          1117
         L     @10,CVTASVT(,@10)                                   1117
         L     R8,ASVTENTY-4(@15,@10)                              1117
*       R12->RT1TREGS(FIVE)=R8;     /* CHECKPOINT REG8 VALUE         */
         ST    R8,RT1TREGS+16(,R12)                                1118
*     END;                                                         1119
*   END ASIDCK;                     /* END VALIDITY CHECKING         */
*                                                                  1120
@EL00003 DS    0H                                                  1120
@EF00003 DS    0H                                                  1120
@ER00003 BR    @14                                                 1120
*   /*****************************************************************/
*   /*                                                               */
*   /* THE PURPOSE OF THE STATUSET SEGMENT IS TO INTERFACE WITH THE  */
*   /* STATUS ROUTINE TO FORCE A TASK DISPATCHABLE. THE STATUSET     */
*   /* SEGMENT IS IMPLEMENTED AS A CLOSED SUBROUTINE AND IS CALLED   */
*   /* FROM TWO DIFFERENT PLACES IN THE SCHDRTM2 FUNCTION OF THE     */
*   /* RTM1. INPUT TO THIS SEGMENT IS AS FOLLOWS: TARGTCB REGISTER   */
*   /* (R3) - CONTAINS POINTER TO THE TCB TO BE PROCESSED. TRAKAREA  */
*   /* REGISTER (R4) - CONTAINS POINTER TO AN AREA FOR TRACKING. THIS*/
*   /* AREA WILL CONTAIN AN INDICATION OF THE ORIGINAL ENTRY POINT   */
*   /* EMPLOYED BY THE CALLER OF RTM1. IF THIS INDICATION IS A SLIH  */
*   /* MODE ENTRY POINT THEN THE RTM1WA ASSOCIATED WITH THE CURRENT  */
*   /* RECOVERY STACK WILL ALSO CONTAIN INPUT TO THE RTM. (I.E. PSW  */
*   /* AT TIME OF ERROR AND POINTER TO AN RTCA IF SRM HAD BEEN CALLED*/
*   /* TO SERVICE THE ERROR.) RECVREGS REGISTER (R12) - CONTAINS A   */
*   /* PTR TO THE SECONDARY TRACKING AREA USED TO CHECKPOINT RECOVERY*/
*   /* INFORMATION. REGS R0-R2, R5-R7, R13 ARE NOT USED AS INPUT, BUT*/
*   /* THEIR CONTENTS ARE PRESERVED. REGS R8 AND R10 ARE CONSIDERED  */
*   /* AVAILABLE AS WORK REGISTERS.                                  */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  1121
*STATUSET:                                                         1121
*   PROC OPTIONS(NOSAVE NOSAVEAREA);                               1121
STATUSET DS    0H                                                  1122
*   RFY                                                            1122
*    (R0,                           /* PRESERVED FOR CALLER          */
*     R1,                           /* PRESERVED FOR CALLER          */
*     R2,                           /* PRESERVED FOR CALLER          */
*     R3,                           /* PRESERVED FOR CALLER          */
*     R4,                           /* PRESERVED FOR CALLER          */
*     R5,                           /* PRESERVED FOR CALLER          */
*     R6,                           /* PRESERVED FOR CALLER          */
*     R7,                           /* PRESERVED FOR CALLER          */
*     R12,                          /* PRESERVED FOR CALLER          */
*     R13,                          /* PRESERVED FOR CALLER          */
*     R14) RSTD;                    /* PRESERVED FOR CALLER          */
*   RFY                                                            1123
*     R10 RSTD;                     /* GET CONTROL OF REG FOR SAVING
*                                      R14S ORIG VALUE               */
*   R10=R14;                        /* PRESERVE RETURN PT VALUE      */
         LR    R10,R14                                             1124
*   RFY                                                            1125
*     R14 UNRSTD;                   /* ALLOW CPLR TO USE R14         */
*   RFY                                                            1126
*     RT1TRACK BASED(R4);           /* REESTABLISH BASE FOR TRACKNG  */
*                                                                  1126
*   /*****************************************************************/
*   /*                                                               */
*   /* NOTE STATCODE (R0), STATTCB (R1) AND STATMASK (R13) ARE       */
*   /* ALREADY CHECKPOINTED INTO THE PARM AREAS.                     */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  1127
*   R0=S2NDARYD;                    /* PUT FUNCTION CODE IN REG      */
         LA    R0,11                                               1127
*   R1=R3×HEX8ZERO;                 /* PUT ADDRESS OF TCB IN REG AND
*                                      TURN ON HIGH ORDER BIT        */
         LR    R1,R3                                               1128
         O     R1,@CF00224                                         1128
*   R13=SECRYDF;                    /* PUT 2NDARY DISP FLAG IN REG   */
         L     R13,SECRYDF                                         1129
*   CALL STATUS;                    /* RESET 2NDARY DISP FLAGS       */
         L     @14,CVTPTR                                          1130
         L     @14,CVTABEND(,@14)                                  1130
         L     @15,SCVTSTAT(,@14)                                  1130
         BALR  @14,@15                                             1130
*   GEN(LA R11,4095(R9));           /* RESTORE BASE REG      @G17EP5W*/
         LA R11,4095(R9)
*   R13=NULL;                       /* INDICATE CURRENT ASID         */
         SLR   R13,R13                                             1132
*   R0=PRIMRYDF;                    /* PUT PRIMARY DISP FLAG IN REG  */
         L     R0,PRIMRYDF                                         1133
*   R1=R3×HEX8ZERO;                 /* PUT ADDRESS OF TCB IN REG AND
*                                      TURN HIGH ORDER BIT ON        */
         LR    R1,R3                                               1134
         O     R1,@CF00224                                         1134
*   CALL STATUS;                    /* RESET PRIMARY DISP BITS       */
         L     @14,CVTPTR                                          1135
         L     @14,CVTABEND(,@14)                                  1135
         L     @15,SCVTSTAT(,@14)                                  1135
         BALR  @14,@15                                             1135
*   GEN(LA R11,4095(R9));           /* RESTORE BASE REG      @G17EP5W*/
         LA R11,4095(R9)
*   R0=RT1TREGS(ONE);               /* RESTORE ORIGINAL REG CONTENT  */
         L     R0,RT1TREGS(,R4)                                    1137
*   R1=RT1TREGS(TWO);               /* RESTORE ORIGINAL REG CONTENT  */
         L     R1,RT1TREGS+4(,R4)                                  1138
*   R13=R12->RT1TREGS(ONE);         /* RESTORE ORIGINAL REG CONTENT  */
         L     R13,RT1TREGS(,R12)                                  1139
*   RFY                                                            1140
*     R14 RSTD;                     /* GET CONTROL OF RETURN REG     */
*   R14=R10;                        /* REPLACE ORIGINAL VALUE        */
         LR    R14,R10                                             1141
*   RFY                                                            1142
*     R10 UNRSTD;                   /* RELEASE REG CONTAINING RETURN
*                                      VALUE                         */
*   END;                            /* RETURN TO CALLER              */
@EL00004 DS    0H                                                  1143
@EF00004 DS    0H                                                  1143
@ER00004 BR    @14                                                 1143
@PB00004 DS    0H                                                  1144
*   DECLARE                         /* GENERAL PURPOSE REGISTERS     */
*     GPR00F FIXED(31) REG(0),                                     1144
*     GPR01F FIXED(31) REG(1),                                     1144
*     GPR03F FIXED(31) REG(3);                                     1144
*   DECLARE                         /* COMMON VARIABLES              */
*     I256C CHAR(256) BASED,                                       1145
*     I031F FIXED(31) BASED,                                       1145
*     I031P PTR(31) BASED,                                         1145
*     I015F FIXED(15) BASED,                                       1145
*     I015P PTR(15) BASED,                                         1145
*     I008P PTR(8) BASED,                                          1145
*     I001C CHAR(1) BASED;          /* DCLD DATA FOR PLS MACROS      */
*   RETURN TO IEAVTRTZ;             /* EXIT                          */
         L     @14,@CV00151                                        1146
@EL00001 DS    0H                                                  1146
@EF00001 DS    0H                                                  1146
@ER00001 BR    @14                                                 1146
*   END IEAVTRTM                    /* END OF EXTERNAL PROCEDURE     */
*                                                                  1147
*/* THE FOLLOWING INCLUDE STATEMENTS WERE FOUND IN THIS PROGRAM.     */
*/*%INCLUDE SYSUT5  (RTMSPEC )                                       */
*/*%INCLUDE SYSUT5  (RTMDCL  )                                       */
*/*%INCLUDE SYSLIB  (IHART1W )                                       */
*/*%INCLUDE SYSLIB  (IHARTCT )                                       */
*/*%INCLUDE SYSLIB  (IHARB   )                                       */
*/*%INCLUDE SYSLIB  (IKJRB   )                                       */
*/*%INCLUDE SYSLIB  (IKJTCB  )                                       */
*/*%INCLUDE SYSLIB  (IHASCVT )                                       */
*/*%INCLUDE SYSLIB  (IHAASCB )                                       */
*/*%INCLUDE SYSLIB  (IHAASXB )                                       */
*/*%INCLUDE SYSLIB  (IHALCCAT)                                       */
*/*%INCLUDE SYSLIB  (IHALCCA )                                       */
*/*%INCLUDE SYSLIB  (IHACSD  )                                       */
*/*%INCLUDE SYSLIB  (IHAPCCAT)                                       */
*/*%INCLUDE SYSLIB  (IHAASVT )                                       */
*/*%INCLUDE SYSLIB  (IHASSRB )                                       */
*/*%INCLUDE SYSLIB  (IHASRB  )                                       */
*/*%INCLUDE SYSLIB  (IHAIHSA )                                       */
*/*%INCLUDE SYSLIB  (IHAPSA  )                                       */
*/*%INCLUDE SYSLIB  (IHAFRRS )                                       */
*/*%INCLUDE SYSLIB  (IHASDWA )                                       */
*/*%INCLUDE SYSLIB  (IHASNP  )                                       */
*/*%INCLUDE SYSLIB  (IHASHDR )                                       */
*/*%INCLUDE SYSLIB  (CVT     )                                       */
*/*%INCLUDE SYSUT5  (REFRESH )                                       */
*/*%INCLUDE SYSUT5  (RECURSE )                                       */
*/*%INCLUDE SYSUT5  (RECSPROL)                                       */
*/*%INCLUDE SYSUT5  (SYSTATE )                                       */
*/*%INCLUDE SYSUT5  (SYSRCVR )                                       */
*/*%INCLUDE SYSUT5  (DATPERC )                                       */
*/*%INCLUDE SYSUT5  (SRBPERC )                                       */
*/*%INCLUDE SYSUT5  (SETUPABT)                                       */
*/*%INCLUDE SYSUT5  (RESCHED )                                       */
*/*%INCLUDE SYSUT5  (RESCPU  )                                       */
*/*%INCLUDE SYSUT5  (XMABTRM )                                       */
*/*%INCLUDE SYSUT5  (GETANSRB)                                       */
*/*%INCLUDE SYSUT5  (RESMODE )                                       */
*/*%INCLUDE SYSUT5  (SCHDRTM2)                                       */
*/*%INCLUDE SYSUT5  (VALIDCK )                                       */
*/*%INCLUDE SYSUT5  (CKNONCUR)                                       */
*/*%INCLUDE SYSUT5  (VALDCKRB)                                       */
*/*%INCLUDE SYSUT5  (TCBRB   )                                       */
*/*%INCLUDE SYSUT5  (SCHDRTM1)                                       */
*/*%INCLUDE SYSUT5  (MEMTERM )                                       */
*/*%INCLUDE SYSUT5  (CHKSLIP )                                       */
*/*%INCLUDE SYSUT5  (WAKEMTC )                                       */
*/*%INCLUDE SYSUT5  (EXIT    )                                       */
*/*%INCLUDE SYSUT5  (EXITREGS)                                       */
*/*%INCLUDE SYSUT5  (SYSCLEAN)                                       */
*/*%INCLUDE SYSUT5  (NOPERCEX)                                       */
*/*%INCLUDE SYSUT5  (EEDPROC )                                       */
*/*%INCLUDE SYSUT5  (OLDEEDS )                                       */
*/*%INCLUDE SYSUT5  (NEWEEDS )                                       */
*/*%INCLUDE SYSUT5  (DUMPEED )                                       */
*/*%INCLUDE SYSUT5  (ASIDCK  )                                       */
*/*%INCLUDE SYSUT5  (STATUSET)                                       */
*                                                                  1147
*       ;                                                          1147
@DATA    DS    0H
@CH00142 DC    H'2'
@CH00134 DC    H'4'
@CH00032 DC    H'9'
@CH00418 DC    H'10'
@CH00426 DC    H'14'
@CH00429 DC    H'15'
@CH00131 DC    H'16'
@CH00199 DC    H'17'
@CH00433 DC    H'19'
@CH00435 DC    H'20'
@CH00352 DC    H'30'
@CH00243 DC    H'64'
@CH00228 DC    XL2'0040'
@CH00230 DC    XL2'004F'
@SM03681 MVC   EEDSDPSL(0,R1),STORLIST(@04)
@DATD    DSECT
         DS    0F
IEAVTRTM CSECT
         DS    0F
@CF00073 DC    F'1'
@CH00073 EQU   @CF00073+2
@CF03679 DC    F'-28'
@CF03660 DC    F'-24'
@CF03678 DC    F'-12'
@CF03680 DC    F'-4'
@CF00209 DC    XL4'030C0000'
@CF00211 DC    XL4'44F13F00'
@CF00215 DC    XL4'00000020'
@CF00217 DC    XL4'00000010'
@CF00224 DC    XL4'80000000'
@CF00226 DC    XL4'7FFFFFFF'
@CF03608 DC    XL4'00FFF000'
@CF00232 DC    XL4'00BF'
@DATD    DSECT
         DS    0D
@ENDDATD EQU   *
IEAVTRTM CSECT
         NOPR  ((@ENDDATD-@DATD)*16)
         DS    0F
@SIZDATD DC    AL1(0)
         DC    AL3(@ENDDATD-@DATD)
@CV00151 DC    V(IEAVTRTZ)
@CV00152 DC    V(IEAVTRTX)
@CV00153 DC    V(IEAVELCR)
@CV00154 DC    V(ESTAECHK)
@CV00155 DC    V(IEAVTRTS)
@CV00156 DC    V(IEAVTRTH)
@CV00157 DC    V(IEAVFRLK)
@CV00158 DC    V(IEAVRSTR)
@CV00159 DC    V(RTMRSFRR)
@CV00160 DC    V(RTMSMFRR)
@CV00161 DC    V(RECVRRTM)
@CV00162 DC    V(FREEDCEL)
         DS    0D
RESCHFRR DC    VL4(RTMRSFRR)
SLIHFRR  DC    VL4(RTMSMFRR)
@CC00201 DC    C'TCB '
@CC00203 DC    C'ASCB'
@CB00207 DC    X'FFFF'
         DS    CL2
SECRYDF  DS    BL4
         ORG   SECRYDF
SECDSP0  DC    B'11111111'
         ORG   SECDSP0
@NM00001 DS    BL1
@NM00002 EQU   SECDSP0+0
@NM00003 EQU   SECDSP0+0
@NM00004 EQU   SECDSP0+0
@NM00005 EQU   SECDSP0+0
@NM00006 EQU   SECDSP0+0
@NM00007 EQU   SECDSP0+0
@NM00008 EQU   SECDSP0+0
         ORG   SECRYDF+1
SECDSP1  DC    B'10111111'
         ORG   SECDSP1
DSPDARTN DS    BL1
DSPDARPN EQU   SECDSP1+0
DSPRSTND EQU   SECDSP1+0
DSPRSPND EQU   SECDSP1+0
DSPDDRND EQU   SECDSP1+0
DSPTPSP  EQU   SECDSP1+0
DSPPIEND EQU   SECDSP1+0
@NM00009 EQU   SECDSP1+0
         ORG   SECRYDF+2
SECDSP2  DC    B'11101111'
         ORG   SECDSP2
DSPABD   DS    BL1
DSPSTPP  EQU   SECDSP2+0
DSPNDSVC EQU   SECDSP2+0
DSPNDTS  EQU   SECDSP2+0
DSPIWAIT EQU   SECDSP2+0
DSPOWAIT EQU   SECDSP2+0
DSPDSS   EQU   SECDSP2+0
DSPABE   EQU   SECDSP2+0
         ORG   SECRYDF+3
SECDSP3  DC    B'11111111'
         ORG   SECDSP3
DSPLJSND DS    BL1
@NM00010 EQU   SECDSP3+0
DSPSRBND EQU   SECDSP3+0
@NM00011 EQU   SECDSP3+0
@NM00012 EQU   SECDSP3+0
@NM00013 EQU   SECDSP3+0
@NM00014 EQU   SECDSP3+0
DSPNDINT EQU   SECDSP3+0
         ORG   SECRYDF+4
PRIMRYDF DS    BL4
         ORG   PRIMRYDF
PDISPFLG DC    B'11111111'
         ORG   PDISPFLG
PDINDUMP DS    BL1
PDISER   EQU   PDISPFLG+0
PDIRQENA EQU   PDISPFLG+0
PDIHNDSP EQU   PDISPFLG+0
PDIUXNDV EQU   PDISPFLG+0
PDIMPCVQ EQU   PDISPFLG+0
PDIMPCND EQU   PDISPFLG+0
PDIONDSP EQU   PDISPFLG+0
         ORG   PRIMRYDF+1
PDISPFL2 DC    B'00111010'
         ORG   PDISPFL2
PDIFC    DS    BL1
PDIABWF  EQU   PDISPFL2+0
PDIPAGE  EQU   PDISPFL2+0
PDIANDSP EQU   PDISPFL2+0
PDISYS   EQU   PDISPFL2+0
PDISTP   EQU   PDISPFL2+0
PDIFCD1  EQU   PDISPFL2+0
PDIPNDSP EQU   PDISPFL2+0
         ORG   PRIMRYDF+2
PRESETCD DC    XL2'000C'
         ORG   PRIMRYDF+4
RT1CPOOL DS    CL4
         ORG   RT1CPOOL
EBCDICNM DC    CL3'RT1'
HEXNM    DC    X'04'
         ORG   RT1CPOOL+4
RTMRSTID DS    CL4
         ORG   RTMRSTID
LDNG0S   DC    X'0000'
CHARID   DC    CL2'RF'
         ORG   RTMRSTID+4
IEAVTRTA DC    X'0A0D'
         ORG   IEAVTRTA
ABENDSVC DS    CL2
         ORG   ABENDSVC
SVCOPCOD DS    CL1
SVC13    DS    CL1
         ORG   IEAVTRTA+2
         DS    CL2
RESNPSW  DS    CL8
         ORG   RESNPSW
PSWWRD1  DC    X'040C0000'
ARESFLIH DC    VL4(IEAVRSTR)
         ORG   RESNPSW+8
RTMPATCH DS    CL100
@00      EQU   00                      EQUATES FOR REGISTERS 0-15
@01      EQU   01
@02      EQU   02
@03      EQU   03
@04      EQU   04
@05      EQU   05
@06      EQU   06
@07      EQU   07
@08      EQU   08
@09      EQU   09
@10      EQU   10
@11      EQU   11
@12      EQU   12
@13      EQU   13
@14      EQU   14
@15      EQU   15
R0       EQU   @00
R1       EQU   @01
R2       EQU   @02
R3       EQU   @03
R4       EQU   @04
R5       EQU   @05
R6       EQU   @06
R7       EQU   @07
R8       EQU   @08
R10      EQU   @10
R12      EQU   @12
R13      EQU   @13
R14      EQU   @14
R15      EQU   @15
GPR01F   EQU   @01
GPR03F   EQU   @03
GPR00F   EQU   @00
R11      EQU   @11
R9       EQU   @09
         ENTRY IEAVTRTA
         ENTRY POSTSRRP
         ENTRY NORTSRP
         ENTRY EEDFRERP
         ENTRY FREEMNRP
         ENTRY CWTRP
         ENTRY RTHRETRN
         ENTRY SRBEEDRP
         ENTRY RT1EEDRP
         ENTRY RT2EEDRP
         ENTRY XMEEDRP
PSA      EQU   0
FLCRNPSW EQU   PSA
FLCROPSW EQU   PSA+8
FLCICCW2 EQU   PSA+16
FLCCVT   EQU   FLCICCW2
PSAEEPSW EQU   PSA+132
PSAESPSW EQU   PSA+136
FLCSVILC EQU   PSAESPSW+1
PSAEPPSW EQU   PSA+140
FLCPIILC EQU   PSAEPPSW+1
FLCPICOD EQU   PSAEPPSW+2
PSAPICOD EQU   FLCPICOD+1
FLCTEA   EQU   PSAEPPSW+4
FLCPER   EQU   PSA+152
FLCMCLA  EQU   PSA+168
FLCIOEL  EQU   FLCMCLA+4
FLCIOA   EQU   FLCMCLA+16
FLCFSA   EQU   FLCMCLA+80
PSACPUPA EQU   PSA+516
PSACPULA EQU   PSA+518
PSALCCAV EQU   PSA+528
PSATOLD  EQU   PSA+540
PSAANEW  EQU   PSA+544
PSAAOLD  EQU   PSA+548
PSASUPER EQU   PSA+552
PSASUP1  EQU   PSASUPER
PSASUP2  EQU   PSASUPER+1
PSARTM   EQU   PSASUP2
PSALCR   EQU   PSASUP2
PSASUP3  EQU   PSASUPER+2
PSAPI2   EQU   PSASUP3
PSAPSREG EQU   PSASUP3
PSASUP4  EQU   PSASUPER+3
PSACLHT  EQU   PSA+640
PSALKSA  EQU   PSA+696
PSAHLHI  EQU   PSA+760
PSADSSFL EQU   PSA+836
PSADSSF1 EQU   PSADSSFL
PSADSSF3 EQU   PSADSSFL+2
PSADSSF4 EQU   PSADSSFL+3
PSARSVT  EQU   PSA+896
TCBPTR   EQU   0
ASCBPTR  EQU   0
SNAPPTR  EQU   0
FRREPTR  EQU   0
LCCAPTR  EQU   0
ASVTPTR  EQU   0
SRBPTR   EQU   0
FRRSPTR  EQU   0
SDWAPTR  EQU   0
RBSECPTR EQU   0
SCVTSPTR EQU   0
ASXBPTR  EQU   0
DUMPARMS EQU   0
ERREGS   EQU   0
ERREG0   EQU   ERREGS
ERREG1   EQU   ERREGS+4
PSW      EQU   0
PSWMODE  EQU   PSW
PSWIMASK EQU   PSWMODE
PSWIO    EQU   PSWIMASK
PSWEXT   EQU   PSWIMASK
PSWKYMWP EQU   PSWMODE+1
PSWECTM  EQU   PSWKYMWP
PSWCCPMK EQU   PSWMODE+2
PSWIC    EQU   PSW+4
PSWEXT1  EQU   0
PSWILCIC EQU   PSWEXT1
PSWILC   EQU   PSWILCIC+1
PSWINTCD EQU   PSWILCIC+2
PSWTRAN  EQU   PSWEXT1+4
STORLIST EQU   0
LISTPAIR EQU   STORLIST
TOADDR   EQU   LISTPAIR+4
STOREND  EQU   TOADDR
RT1TRACK EQU   0
RT1TRECC EQU   RT1TRACK
RT1TLPN  EQU   RT1TRECC
RT1TLPID EQU   RT1TRECC+1
RT1TENPT EQU   RT1TRECC+2
RT1TACQR EQU   RT1TRECC+3
RT1TREGS EQU   RT1TRACK+4
RTMBRTAB EQU   0
RTMBTERM EQU   RTMBRTAB
MODEBYTE EQU   0
MODESUPR EQU   MODEBYTE
MODEDIS  EQU   MODEBYTE
MODEGSPN EQU   MODEBYTE
MODEGSUS EQU   MODEBYTE
MODELOC  EQU   MODEBYTE
MODETYP1 EQU   MODEBYTE
MODESRB  EQU   MODEBYTE
MODETCB  EQU   MODEBYTE
EED      EQU   0
EEDFWRDP EQU   EED
EEDDES   EQU   EED+4
EEDID    EQU   EEDDES
EEDFLAGS EQU   EEDDES+1
EEDERFL  EQU   EEDFLAGS
EEDNODMP EQU   EEDFLAGS
EEDERROR EQU   EED+8
EEDMODE  EQU   EEDERROR
EEDERTYP EQU   EEDERROR+1
EEDASID  EQU   EEDERROR+2
EEDVARBL EQU   EED+12
RTCT     EQU   0
RTCTPLIB EQU   RTCT+4
RTCTSAP  EQU   RTCTPLIB
RTCTSAP1 EQU   RTCTSAP
RTCTSAP2 EQU   RTCTSAP+1
RTCTSAP3 EQU   RTCTSAP+2
RTCTSUP  EQU   RTCTPLIB+4
RTCTSUP1 EQU   RTCTSUP
RTCTSUP2 EQU   RTCTSUP+1
RTCTSUP3 EQU   RTCTSUP+2
RTCTSYD  EQU   RTCTPLIB+8
RTCTSY01 EQU   RTCTSYD
RTCTFASB EQU   RTCT+24
RTCTSDDS EQU   RTCT+36
RTCTFLG  EQU   RTCTSDDS+3
RTCTSDPL EQU   RTCT+156
RTCTMLCK EQU   RTCT+164
RTCTMSRB EQU   RTCT+168
RTCTRFLG EQU   RTCT+176
RTCTERID EQU   RTCT+224
RTCTOPT  EQU   RTCT+236
RTCTASO  EQU   RTCT+252
RTCTASO1 EQU   RTCTASO
RTCTASO2 EQU   RTCTASO+1
RTCTSDI  EQU   RTCT+254
RTCTSDF  EQU   RTCT+264
RTCTSDF1 EQU   RTCTSDF
RTCTSDF2 EQU   RTCTSDF+1
RTCTSDF3 EQU   RTCT+268
RTCTSDF4 EQU   RTCTSDF3+2
RTCTMOPT EQU   0
RTCTMSAO EQU   RTCTMOPT
RTCTSASD EQU   RTCTMSAO
RTCTSAO1 EQU   RTCTSASD
RTCTSAO2 EQU   RTCTSASD+1
RTCTSAPD EQU   RTCTMSAO+2
RTCTSAO3 EQU   RTCTSAPD
RTCTSAO4 EQU   RTCTSAPD+1
RTCTSAMG EQU   RTCTSAO4
RTCTMSUO EQU   RTCTMOPT+4
RTCTSUSD EQU   RTCTMSUO
RTCTSUO1 EQU   RTCTSUSD
RTCTSUO2 EQU   RTCTSUSD+1
RTCTSUPD EQU   RTCTMSUO+2
RTCTSUO3 EQU   RTCTSUPD
RTCTSUO4 EQU   RTCTSUPD+1
RTCTSUMG EQU   RTCTSUO4
RTCTMSYO EQU   RTCTMOPT+8
RTCTSD01 EQU   RTCTMSYO
RTCTSD04 EQU   RTCTMSYO+3
RTCTSMMG EQU   RTCTSD04
RTCTMSDO EQU   RTCTMOPT+12
RTCTSDOD EQU   RTCTMSDO
RTCTSDO1 EQU   RTCTSDOD
RTCTSDO2 EQU   RTCTSDOD+1
RTCTSDO3 EQU   RTCTMSDO+2
RTCTSDO4 EQU   RTCTMSDO+3
RTCTSDMG EQU   RTCTSDO4
RBPRFX   EQU   0
RBBASIC  EQU   0
RBEXRTNM EQU   RBBASIC
RBTMFLD  EQU   RBEXRTNM
RBSTAB   EQU   RBBASIC+10
XSTAB    EQU   RBSTAB
RBSTAB1  EQU   XSTAB
XSTAB1   EQU   RBSTAB1
RBFTCKPT EQU   XSTAB1
RBSTAB2  EQU   XSTAB+1
XSTAB2   EQU   RBSTAB2
RBTCBNXT EQU   XSTAB2
RBFACTV  EQU   XSTAB2
RBFDYN   EQU   XSTAB2
RBECBWT  EQU   XSTAB2
RBOPSW   EQU   RBBASIC+16
XRBPSW   EQU   RBOPSW
RBOPSWB2 EQU   XRBPSW+1
RBLINK   EQU   RBBASIC+28
XRBLNK   EQU   RBLINK
RBWCF    EQU   XRBLNK
RBLINKB  EQU   XRBLNK+1
RBGRSAVE EQU   RBBASIC+32
XRBREG   EQU   RBGRSAVE
RBGRS0   EQU   XRBREG
RBGRS1   EQU   XRBREG+4
RBGRS2   EQU   XRBREG+8
RBGRS3   EQU   XRBREG+12
RBGRS4   EQU   XRBREG+16
RBGRS5   EQU   XRBREG+20
RBGRS6   EQU   XRBREG+24
RBGRS7   EQU   XRBREG+28
RBGRS8   EQU   XRBREG+32
RBGRS9   EQU   XRBREG+36
RBGRS10  EQU   XRBREG+40
RBGRS11  EQU   XRBREG+44
RBGRS12  EQU   XRBREG+48
RBGRS13  EQU   XRBREG+52
RBGRS14  EQU   XRBREG+56
RBGRS15  EQU   XRBREG+60
XRBESA   EQU   RBBASIC+96
RBPREFIX EQU   0
RBRSV019 EQU   RBPREFIX+14
RBRSV028 EQU   RBPREFIX+15
RBRSV041 EQU   RBPREFIX+27
RBRSV054 EQU   RBPREFIX+39
RBRTOPSW EQU   RBPREFIX+40
RBRTPSW1 EQU   RBRTOPSW
RBRTPSW2 EQU   RBRTOPSW+8
RBRTICIL EQU   RBRTPSW2
RBRTILC  EQU   RBRTICIL+1
RBRTINCD EQU   RBRTICIL+2
RBRTRAN  EQU   RBRTPSW2+4
RBFLAGS1 EQU   RBPREFIX+56
RBWCSA   EQU   RBPREFIX+60
RBINTCDA EQU   RBPREFIX+61
RBINLNTH EQU   RBINTCDA
RBINTCOD EQU   RBINTCDA+1
RBSECT   EQU   0
RBPPSAV  EQU   RBSECT
@NM00054 EQU   RBSECT+10
@NM00055 EQU   @NM00054
RBTRSVRB EQU   @NM00055
@NM00057 EQU   @NM00054+1
RBETXR   EQU   @NM00057
RBEP     EQU   RBSECT+12
RBPGMQ   EQU   RBSECT+24
@NM00064 EQU   RBSECT+28
@NM00065 EQU   @NM00064
IRBEND   EQU   RBSECT+96
@NM00068 EQU   RBSECT+96
RBRSV138 EQU   @NM00068+7
RBSCBB   EQU   RBSECT+144
RBSPARM  EQU   RBSCBB+8
RBSFLGS1 EQU   RBSPARM
RBSIOPRC EQU   RBSFLGS1
RBSOWNR  EQU   RBSCBB+12
RBSFLGS2 EQU   RBSOWNR
RBSDATA  EQU   RBSCBB+16
RBSFLG3  EQU   RBSDATA
RBRSV150 EQU   RBSECT+167
TCBFIX   EQU   0
TCBFRS   EQU   TCBFIX
TCB      EQU   0
TCBRBP   EQU   TCB
TCBPIE   EQU   TCB+4
TCBPMASK EQU   TCBPIE
TCBCMP   EQU   TCB+16
TCBCMPF  EQU   TCBCMP
TCBCPP   EQU   TCBCMPF
TCBSTCC  EQU   TCBCMPF
TCBCDBL  EQU   TCBCMPF
TCBCWTO  EQU   TCBCMPF
TCBCIND  EQU   TCBCMPF
TCBCMSG  EQU   TCBCMPF
TCBTRN   EQU   TCB+20
TCBABF   EQU   TCBTRN
TCBMSS   EQU   TCB+24
TCBPKF   EQU   TCB+28
TCBFLGS  EQU   TCB+29
TCBFLGS1 EQU   TCBFLGS
TCBNONPR EQU   TCBFLGS1
TCBFX    EQU   TCBFLGS1
TCBFLGS2 EQU   TCBFLGS+1
TCBFLGS3 EQU   TCBFLGS+2
TCBABTRM EQU   TCBFLGS3
TCBABGM  EQU   TCBFLGS3
TCBFLGS4 EQU   TCBFLGS+3
TCBFLGS5 EQU   TCBFLGS+4
TCBFC    EQU   TCBFLGS5
TCBABWF  EQU   TCBFLGS5
TCBJPQ   EQU   TCB+44
TCBPURGE EQU   TCBJPQ
TCBGRS   EQU   TCB+48
TCBFSA   EQU   TCB+112
TCBTCB   EQU   TCB+116
TCBTME   EQU   TCB+120
TCBJSTCB EQU   TCB+124
TCBTSFLG EQU   TCB+148
TCBTSTSK EQU   TCBTSFLG
TCBSTAB  EQU   TCB+160
TCBNSTAE EQU   TCBSTAB
TCBTCT   EQU   TCB+164
TCBTCTGF EQU   TCBTCT
TCBSCNDY EQU   TCB+172
TCBNDSP  EQU   TCBSCNDY
TCBNDSP1 EQU   TCBNDSP+1
TCBNDSP2 EQU   TCBNDSP+2
TCBNDSP3 EQU   TCBNDSP+3
TCBJSCB  EQU   TCB+180
TCBRECDE EQU   TCBJSCB
TCBEXT1  EQU   TCB+196
TCBBITS  EQU   TCB+200
TCBNDSP4 EQU   TCBBITS
TCBNDSP5 EQU   TCBBITS+1
TCBFLGS6 EQU   TCBBITS+2
TCBFLGS7 EQU   TCBBITS+3
TCBDAR   EQU   TCB+204
TCBDARC  EQU   TCBDAR
TCBEXT2  EQU   TCB+208
TCBXSCT  EQU   TCB+240
TCBXSCT1 EQU   TCBXSCT
TCBFOE   EQU   TCB+244
TCBTCBID EQU   TCB+256
TCBRTM12 EQU   TCB+260
TCBESTAE EQU   TCB+264
TCBESTRM EQU   TCBESTAE+1
TCBERTYP EQU   TCBESTAE+2
TCBMODE  EQU   TCBESTAE+3
TCBFBYT1 EQU   TCB+276
TCBLLH   EQU   TCBFBYT1
TCBFBYT2 EQU   TCB+277
TCBFPRAP EQU   TCBFBYT2
TCBRV124 EQU   TCB+278
TCBRV133 EQU   TCB+279
TCBXTNT2 EQU   0
TCBGTF   EQU   TCBXTNT2
TCBTFLG  EQU   TCBGTF
TCBRV146 EQU   TCBXTNT2+28
TCBRV155 EQU   TCBXTNT2+29
TCBRV164 EQU   TCBXTNT2+30
TCBRV173 EQU   TCBXTNT2+31
SCVTSECT EQU   0
SCVTSTAT EQU   SCVTSECT+148
ASCB     EQU   0
ASCBASCB EQU   ASCB
ASCBSUPC EQU   ASCB+16
ASCBCPUS EQU   ASCB+32
ASCBASID EQU   ASCB+36
ASCBRSM  EQU   ASCB+52
ASCBRSMF EQU   ASCBRSM
ASCBFW1  EQU   ASCB+100
ASCBRCTF EQU   ASCBFW1+2
ASCBFLG1 EQU   ASCBFW1+3
ASCBTERM EQU   ASCBFLG1
ASCBABNT EQU   ASCBFLG1
ASCBTYP1 EQU   ASCBFLG1
ASCBTMCH EQU   ASCB+104
ASCBASXB EQU   ASCB+108
ASCBDSP1 EQU   ASCB+114
ASCBFLG2 EQU   ASCB+115
ASCBLKGP EQU   ASCB+128
ASCBMCC  EQU   ASCB+168
ASCBSRQ  EQU   ASCB+180
ASCBSRQ1 EQU   ASCBSRQ
ASCBSRQ2 EQU   ASCBSRQ+1
ASCBSRQ3 EQU   ASCBSRQ+2
ASCBSRQ4 EQU   ASCBSRQ+3
ASXB     EQU   0
ASXBFTCB EQU   ASXB+4
ASXBLTCB EQU   ASXB+8
ASXBIHSA EQU   ASXB+32
ASXBAEQ  EQU   ASXB+168
ASXBSECR EQU   ASXB+199
ASCBSFLG EQU   ASXBSECR
ASXBCASW EQU   ASXB+216
ASXBCRB1 EQU   ASXBCASW
LCCAVT   EQU   0
LCCA     EQU   0
LCCAIHRC EQU   LCCA+520
LCCAIHR1 EQU   LCCAIHRC
LCCAPDAT EQU   LCCAIHR1
LCCAPSG1 EQU   LCCAIHR1
LCCAIHR2 EQU   LCCAIHRC+1
LCCAIHR3 EQU   LCCAIHRC+2
LCCAIHR4 EQU   LCCAIHRC+3
LCCASPIN EQU   LCCA+524
LCCASPN1 EQU   LCCASPIN
LCCASPN2 EQU   LCCASPIN+1
LCCASPN3 EQU   LCCASPIN+2
LCCASPN4 EQU   LCCASPIN+3
LCCADSF1 EQU   LCCA+540
LCCADSF2 EQU   LCCA+541
LCCASRBM EQU   LCCADSF2
LCCASPSA EQU   LCCA+544
LCCACRFL EQU   LCCA+692
LCCACREX EQU   LCCA+693
LCCALKFG EQU   LCCA+694
LCCASRBF EQU   LCCA+720
LCCAPGTA EQU   LCCASRBF+2
LCCAASID EQU   LCCA+732
CSD      EQU   0
CSDCPUAL EQU   CSD+8
CSDSCWRD EQU   CSD+12
CSDSCFL1 EQU   CSDSCWRD
CSDSCFL2 EQU   CSDSCWRD+1
CSDSCFL3 EQU   CSDSCWRD+2
CSDSCFL4 EQU   CSDSCWRD+3
CSDFLAGS EQU   CSD+23
CSDMASK  EQU   CSD+128
PCCAVT   EQU   0
PCCAT00P EQU   PCCAVT
ASVT     EQU   0
ASVTMAXU EQU   ASVT+516
ASVTFRST EQU   ASVT+524
ASVTENTY EQU   ASVT+528
ASVTAVAL EQU   ASVTENTY
SSRBSECT EQU   0
SRBSECT  EQU   SSRBSECT
SRB      EQU   SRBSECT
SRBASCB  EQU   SRB+8
SRBFLC   EQU   SRB+12
SRBPASID EQU   SRBFLC+2
SRBPTCB  EQU   SRBFLC+4
SRBEP    EQU   SRB+20
SRBPARM  EQU   SRB+28
SSRB     EQU   SSRBSECT+48
SSRBCPSW EQU   SSRB
SSRBFPRS EQU   SSRB+8
SSRBGPRS EQU   SSRB+40
SSRBTRAN EQU   SSRB+104
SSRBFLG1 EQU   SSRB+704
IHSA     EQU   0
IHSACPSW EQU   IHSA+16
IHSAFPRS EQU   IHSA+24
IHSAGPRS EQU   IHSA+56
FRRS     EQU   0
FRRSHEAD EQU   FRRS
FRRSRTMW EQU   FRRS+16
FRRSENTR EQU   0
FRRSFLGS EQU   FRRSENTR+4
FRRSFLG1 EQU   FRRSFLGS
SDWA     EQU   0
SDWAFIOB EQU   SDWA+4
SDWAABCC EQU   SDWAFIOB
SDWACMPF EQU   SDWAABCC
SDWACTL1 EQU   SDWA+8
SDWACMKA EQU   SDWACTL1
SDWAMWPA EQU   SDWACTL1+1
SDWAPMKA EQU   SDWACTL1+4
SDWACTL2 EQU   SDWA+16
SDWACMKP EQU   SDWACTL2
SDWAMWPP EQU   SDWACTL2+1
SDWAPMKP EQU   SDWACTL2+4
SDWAGRSV EQU   SDWA+24
SDWANAME EQU   SDWA+88
SDWAEC1  EQU   SDWA+104
SDWAEMK1 EQU   SDWAEC1
SDWAMWP1 EQU   SDWAEC1+1
SDWAINT1 EQU   SDWAEC1+2
SDWANXT1 EQU   SDWAEC1+4
SDWAAEC1 EQU   SDWA+112
SDWAILC1 EQU   SDWAAEC1+1
SDWAINC1 EQU   SDWAAEC1+2
SDWAICD1 EQU   SDWAINC1+1
SDWAEC2  EQU   SDWA+120
SDWAEMK2 EQU   SDWAEC2
SDWAMWP2 EQU   SDWAEC2+1
SDWAINT2 EQU   SDWAEC2+2
SDWANXT2 EQU   SDWAEC2+4
SDWAAEC2 EQU   SDWA+128
SDWAILC2 EQU   SDWAAEC2+1
SDWAINC2 EQU   SDWAAEC2+2
SDWAICD2 EQU   SDWAINC2+1
SDWASRSV EQU   SDWA+136
SDWASR00 EQU   SDWASRSV
SDWASR15 EQU   SDWASRSV+60
SDWAIDNT EQU   SDWA+200
SDWASPID EQU   SDWAIDNT
SDWALNTH EQU   SDWAIDNT+1
SDWAMCH  EQU   SDWA+204
SDWASTCK EQU   SDWAMCH
SDWAMCHI EQU   SDWAMCH+8
SDWAMCHS EQU   SDWAMCHI
SDWAMCHD EQU   SDWAMCHI+1
SDWARSR1 EQU   SDWAMCH+12
SDWARSR2 EQU   SDWAMCH+13
SDWAFLGS EQU   SDWA+232
SDWAERRA EQU   SDWAFLGS
SDWAERRB EQU   SDWAFLGS+1
SDWAERRC EQU   SDWAFLGS+2
SDWAERRD EQU   SDWAFLGS+3
SDWAERFL EQU   SDWAERRD
SDWAFMID EQU   SDWA+236
SDWAIOFS EQU   SDWA+238
SDWACPUI EQU   SDWA+239
SDWARTYA EQU   SDWA+240
SDWACPUA EQU   SDWA+248
SDWALCPU EQU   SDWACPUA+2
SDWAPARQ EQU   SDWA+252
SDWARCDE EQU   SDWAPARQ
SDWAACF2 EQU   SDWAPARQ+1
SDWASPIN EQU   SDWAACF2
SDWAACF3 EQU   SDWAPARQ+2
SDWAACF4 EQU   SDWAPARQ+3
SDWALKWA EQU   SDWA+256
SDWALKWS EQU   SDWALKWA
SDWASEQ# EQU   SDWA+290
SDWARECP EQU   SDWA+292
SDWASNPA EQU   SDWA+320
SDWADUMP EQU   SDWASNPA
SDWADPFS EQU   SDWADUMP+1
SDWADLST EQU   SDWADPFS
SDWADDAT EQU   SDWASNPA+4
SDWASDAT EQU   SDWADDAT
SDWASDA0 EQU   SDWASDAT
SDWASDA1 EQU   SDWASDAT+1
SDWAPDAT EQU   SDWADDAT+2
SDWADPSA EQU   SDWA+328
SDWADPSL EQU   SDWADPSA
SDWAERTM EQU   SDWA+396
SDWARA   EQU   SDWA+400
SDWADPVA EQU   SDWARA+2
SNPPARMS EQU   0
SNPIDENT EQU   SNPPARMS
SNPFLAG  EQU   SNPPARMS+1
SNPSLIST EQU   SNPFLAG
SNPSDATA EQU   SNPPARMS+4
SNPSDAT0 EQU   SNPSDATA
SNPSDAT1 EQU   SNPSDATA+1
SNPPDATA EQU   SNPPARMS+6
SNPSTOR  EQU   SNPPARMS+16
SHDR     EQU   0
SHDRPFC  EQU   SHDR+4
SHDRCTFW EQU   SHDR+8
SHDRFLGS EQU   SHDR+20
SHDRPROC EQU   SHDR+24
CVTMAP   EQU   0
CVTBTERM EQU   CVTMAP+52
CVTDAR   EQU   CVTMAP+72
CVTFLGS1 EQU   CVTDAR
CVTDCB   EQU   CVTMAP+116
CVTIOQET EQU   CVTMAP+120
CVTIERLC EQU   CVTMAP+144
CVT0PT01 EQU   CVTMAP+152
CVTHEAD  EQU   CVTMAP+160
CVTSV76C EQU   CVTHEAD
CVTOPTA  EQU   CVTMAP+182
CVTOPTB  EQU   CVTMAP+183
CVTABEND EQU   CVTMAP+200
CVTGTF   EQU   CVTMAP+236
CVTGTFST EQU   CVTGTF
CVTGTFS  EQU   CVTGTFST
CVTSTATE EQU   CVTGTFST
CVTTMODE EQU   CVTGTFST
CVTFORM  EQU   CVTGTFST
CVTAQAVT EQU   CVTMAP+240
CVTTCMFG EQU   CVTAQAVT
CVTVOLM2 EQU   CVTMAP+244
CVTTATA  EQU   CVTVOLM2
CVTTSKS  EQU   CVTTATA
CVTVOLF2 EQU   CVTTSKS
CVTTAT   EQU   CVTTATA+1
CVTATER  EQU   CVTMAP+248
CVTEXT1  EQU   CVTMAP+252
CVTPURG  EQU   CVTMAP+260
CVTQMSG  EQU   CVTMAP+268
CVTDMSR  EQU   CVTMAP+272
CVTRSV37 EQU   CVTDMSR
CVTDMSRF EQU   CVTRSV37
CVTERPV  EQU   CVTMAP+316
CVTINTLA EQU   CVTMAP+320
CVTAPF   EQU   CVTMAP+324
CVTEXT2  EQU   CVTMAP+328
CVTHJES  EQU   CVTMAP+332
CVTPGSIA EQU   CVTMAP+348
CVTA1F1  EQU   CVTMAP+356
CVTSYSK  EQU   CVTMAP+357
CVTVOLM1 EQU   CVTMAP+380
CVTVOLF1 EQU   CVTVOLM1
CVTXTNT1 EQU   0
CVTXTNT2 EQU   0
CVTDSSV  EQU   CVTXTNT2
CVTFLGBT EQU   CVTXTNT2+5
CVTQID   EQU   CVTXTNT2+24
CVTRV400 EQU   CVTXTNT2+52
CVTRV409 EQU   CVTXTNT2+53
CVTATCVT EQU   CVTXTNT2+64
CVTRV429 EQU   CVTXTNT2+84
CVTRV438 EQU   CVTXTNT2+85
CVTRV457 EQU   CVTXTNT2+112
CVTRV466 EQU   CVTXTNT2+113
CVTFIX   EQU   0
CVTRELNO EQU   CVTFIX+252
STATUS   EQU   0
POST     EQU   0
SLIPLIST EQU   0
SLPCFRRS EQU   SLIPLIST
SLPRT2WA EQU   SLIPLIST+4
SLPWAPTR EQU   SLIPLIST+8
SLPRTSTK EQU   SLIPLIST+12
SLPASCB  EQU   SLIPLIST+16
SLPCRTM  EQU   SLIPLIST+20
IEAVTSLP EQU   0
@NM00185 EQU   0
CRTMR14  EQU   @NM00185+56
CSDPTR   EQU   0
IHSAPTR  EQU   0
I001C    EQU   0
I008P    EQU   0
I015F    EQU   0
I015P    EQU   0
I031F    EQU   0
I031P    EQU   0
I256C    EQU   0
RBPTR    EQU   0
SSRBPTR  EQU   0
EEDDUMPO EQU   EEDVARBL
EEDSCDMP EQU   EEDDUMPO
EEDSDDAT EQU   EEDSCDMP+4
EEDSDPSL EQU   EEDDUMPO+8
SNPCDMP  EQU   SNPIDENT
RT1W     EQU   FRRSRTMW
RT1WNPRS EQU   RT1W
RT1WLPTA EQU   RT1WNPRS
RT1WPSW1 EQU   RT1WNPRS+24
RT1WPSW2 EQU   RT1WNPRS+28
RT1WVARI EQU   RT1WNPRS+32
RT1WPRSV EQU   RT1W+52
RT1WRTCA EQU   RT1WPRSV
RT1WEED  EQU   RT1WPRSV+8
RT1WENTR EQU   RT1WPRSV+12
RT1WMODE EQU   RT1WENTR
RT1WCOVR EQU   RT1WENTR+2
RT1WRTM  EQU   RT1WCOVR
RT1WEREX EQU   RT1WCOVR
RT1NODMP EQU   RT1WCOVR
RT1WLPN  EQU   RT1WENTR+3
RT1RTRN  EQU   FRRSRTMW
RT1RTRRG EQU   RT1RTRN+4
RT1R0R14 EQU   RT1RTRRG
RT1RTYAD EQU   RT1RTRRG+60
EEDREGSP EQU   EEDVARBL
EEDREGS  EQU   EEDREGSP
EEDPSW   EQU   EEDREGSP+64
EEDPSW1  EQU   EEDPSW
EEDPSW2  EQU   EEDPSW+8
EEDINILC EQU   EEDPSW2
EEDINTCD EQU   EEDINILC+2
EEDTRANS EQU   EEDPSW2+4
EEDHWREP EQU   EEDVARBL
EEDHMCHS EQU   EEDHWREP+8
EEDHMCHD EQU   EEDHWREP+9
EEDHRSRS EQU   EEDHWREP+12
EEDHRSR1 EQU   EEDHRSRS
EEDHRSR2 EQU   EEDHRSRS+1
EEDERMAP EQU   EEDVARBL
EEDERRID EQU   EEDERMAP+70
EEDESEQ# EQU   EEDERRID
EEDECPUI EQU   EEDERRID+2
EEDEASID EQU   EEDERRID+4
EEDETIME EQU   EEDERRID+6
RBSECS03 EQU   RBEP
RBCDE    EQU   RBSECS03
RBCDFLGS EQU   RBCDE
RBSECS05 EQU   RBPGMQ
RBSQE    EQU   RBSECS05
RBSECS06 EQU   RBPGMQ
RBIQE    EQU   RBSECS06
RBSECS07 EQU   RBPGMQ
RBIQE2   EQU   RBSECS07
RBSECS08 EQU   IRBEND
RBSECS09 EQU   IRBEND
PSARSVTE EQU   PSARSVT
PSACSTK  EQU   PSARSVTE
CVTPTR   EQU   FLCCVT
CVTS01   EQU   CVTPGSIA
CVTLPDIA EQU   CVTS01+12
CVTDIRST EQU   CVTLPDIA
CVTSLIDA EQU   CVTS01+24
CVTCTLFG EQU   CVTS01+50
CVTCRMN  EQU   CVTS01+156
CVTASVT  EQU   CVTS01+208
CVTRTMCT EQU   CVTS01+224
CVTRTMS  EQU   CVTS01+244
CVTCSD   EQU   CVTS01+312
CVTRSTWD EQU   CVTS01+368
CVTPCCAT EQU   CVTS01+416
CVTLCCAT EQU   CVTS01+420
CVTRV210 EQU   CVTS01+424
CVTRV219 EQU   CVTS01+425
CVTRV228 EQU   CVTS01+426
CVTRV237 EQU   CVTS01+427
CVTMFRTR EQU   CVTS01+452
CVTRV262 EQU   CVTS01+468
CVTRV271 EQU   CVTS01+469
CVTRV280 EQU   CVTS01+470
CVTRV289 EQU   CVTS01+471
CVTGSDA  EQU   CVTS01+600
SRBAFIN  EQU   LCCAPGTA
SRBAASID EQU   SRBAFIN
SRBATCB  EQU   SRBAFIN+2
@NM00183 EQU   TCBRBP
TCBRBPX  EQU   @NM00183+1
FLC      EQU   PSA
*                                      START UNREFERENCED COMPONENTS
@NM00184 EQU   @NM00183
CVTRV628 EQU   CVTS01+728
CVTRV627 EQU   CVTS01+724
CVTRV626 EQU   CVTS01+720
CVTRV625 EQU   CVTS01+716
CVTRV624 EQU   CVTS01+712
CVTRV623 EQU   CVTS01+708
CVTRV622 EQU   CVTS01+704
CVTRV621 EQU   CVTS01+700
CVTIHASU EQU   CVTS01+696
CVTSUSP  EQU   CVTS01+692
CVTT6SVC EQU   CVTS01+688
CVTCDAL  EQU   CVTS01+684
CVTTCTL  EQU   CVTS01+680
CVTRSUME EQU   CVTS01+676
CVTJTERM EQU   CVTS01+672
CVTASMRM EQU   CVTS01+668
CVTTCASP EQU   CVTS01+664
CVT0PT03 EQU   CVTS01+660
CVT0PT0E EQU   CVTS01+656
CVTRV609 EQU   CVTS01+652
CVTCGK   EQU   CVTS01+648
CVTRAC   EQU   CVTS01+644
CVTHSM   EQU   CVTS01+640
CVTRV605 EQU   CVTS01+636
CVTRV604 EQU   CVTS01+632
CVTEFF02 EQU   CVTS01+628
CVTCBBR  EQU   CVTS01+624
CVTSSCR  EQU   CVTS01+620
CVTEVENT EQU   CVTS01+616
CVTCRCA  EQU   CVTS01+612
CVTTPIO  EQU   CVTS01+608
CVTADV   EQU   CVTS01+604
CVTGSDAB EQU   CVTGSDA
CVTQV3   EQU   CVTS01+596
CVTQV2   EQU   CVTS01+592
CVTQV1   EQU   CVTS01+588
CVTRPT   EQU   CVTS01+584
CVTSSRB  EQU   CVTS01+580
CVTCSDRL EQU   CVTS01+576
CVTEXP1  EQU   CVTS01+572
CVTRMPMT EQU   CVTS01+568
CVTRMPTT EQU   CVTS01+564
CVTVPSA  EQU   CVTS01+560
CVTVSTOP EQU   CVTS01+556
CVTGTFR8 EQU   CVTS01+552
CVTQUIT  EQU   CVTS01+548
CVTVACR  EQU   CVTS01+544
CVTWTCB  EQU   CVTS01+540
CVTSTPRS EQU   CVTS01+536
CVT0PT02 EQU   CVTS01+532
CVTDARCM EQU   CVTS01+528
CVTIRECM EQU   CVTS01+524
CVTJRECM EQU   CVTS01+520
CVTVEMS0 EQU   CVTS01+516
CVTSPFRR EQU   CVTS01+512
CVTRLSTG EQU   CVTS01+508
CVT0TC0A EQU   CVTS01+504
CVTGMBR  EQU   CVTS01+500
CVTLFRM  EQU   CVTS01+496
CVTRMBR  EQU   CVTS01+492
CVTVIOP  EQU   CVTS01+488
CVTRV307 EQU   CVTS01+486
CVTRV306 EQU   CVTS01+484
CVTRV305 EQU   CVTS01+482
CVTRV304 EQU   CVTS01+480
CVTRV303 EQU   CVTS01+478
CVTRV302 EQU   CVTS01+476
CVTTRCA  EQU   CVTS01+472
CVTRV297 EQU   CVTRV289
CVTRV296 EQU   CVTRV289
CVTRV295 EQU   CVTRV289
CVTRV294 EQU   CVTRV289
CVTRV293 EQU   CVTRV289
CVTRV292 EQU   CVTRV289
CVTRV291 EQU   CVTRV289
CVTRV290 EQU   CVTRV289
CVTRV288 EQU   CVTRV280
CVTRV287 EQU   CVTRV280
CVTRV286 EQU   CVTRV280
CVTRV285 EQU   CVTRV280
CVTRV284 EQU   CVTRV280
CVTRV283 EQU   CVTRV280
CVTRV282 EQU   CVTRV280
CVTRV281 EQU   CVTRV280
CVTRV279 EQU   CVTRV271
CVTRV278 EQU   CVTRV271
CVTRV277 EQU   CVTRV271
CVTRV276 EQU   CVTRV271
CVTRV275 EQU   CVTRV271
CVTRV274 EQU   CVTRV271
CVTRV273 EQU   CVTRV271
CVTRV272 EQU   CVTRV271
CVTRV270 EQU   CVTRV262
CVTRV269 EQU   CVTRV262
CVTRV268 EQU   CVTRV262
CVTRV267 EQU   CVTRV262
CVTRV266 EQU   CVTRV262
CVTRV265 EQU   CVTRV262
CVTRV264 EQU   CVTRV262
CVTRV263 EQU   CVTRV262
CVTVFP   EQU   CVTS01+464
CVTVSI   EQU   CVTS01+460
CVTVPSIB EQU   CVTS01+456
CVTMFACT EQU   CVTMFRTR
CVTMFCTL EQU   CVTS01+448
CVTPVBP  EQU   CVTS01+444
CVTPWI   EQU   CVTS01+440
CVTRV254 EQU   CVTS01+438
CVTRV253 EQU   CVTS01+436
CVTRV252 EQU   CVTS01+434
CVTRV251 EQU   CVTS01+433
CVTRV250 EQU   CVTS01+432
CVTRV249 EQU   CVTS01+431
CVTRV248 EQU   CVTS01+430
CVTRV247 EQU   CVTS01+429
CVTRV246 EQU   CVTS01+428
CVTRV245 EQU   CVTRV237
CVTRV244 EQU   CVTRV237
CVTRV243 EQU   CVTRV237
CVTRV242 EQU   CVTRV237
CVTRV241 EQU   CVTRV237
CVTRV240 EQU   CVTRV237
CVTRV239 EQU   CVTRV237
CVTRV238 EQU   CVTRV237
CVTRV236 EQU   CVTRV228
CVTRV235 EQU   CVTRV228
CVTRV234 EQU   CVTRV228
CVTRV233 EQU   CVTRV228
CVTRV232 EQU   CVTRV228
CVTRV231 EQU   CVTRV228
CVTRV230 EQU   CVTRV228
CVTRV229 EQU   CVTRV228
CVTRV227 EQU   CVTRV219
CVTRV226 EQU   CVTRV219
CVTRV225 EQU   CVTRV219
CVTRV224 EQU   CVTRV219
CVTRV223 EQU   CVTRV219
CVTRV222 EQU   CVTRV219
CVTRV221 EQU   CVTRV219
CVTRV220 EQU   CVTRV219
CVTRV218 EQU   CVTRV210
CVTRV217 EQU   CVTRV210
CVTRV216 EQU   CVTRV210
CVTRV215 EQU   CVTRV210
CVTRV214 EQU   CVTRV210
CVTRV213 EQU   CVTRV210
CVTRV212 EQU   CVTRV210
CVTRV211 EQU   CVTRV210
CVTIPCRP EQU   CVTS01+412
CVTIPCRI EQU   CVTS01+408
CVTIPCDS EQU   CVTS01+404
CVTAIDVT EQU   CVTS01+400
CVTSSAP  EQU   CVTS01+396
CVTEHCIR EQU   CVTS01+392
CVTEHDEF EQU   CVTS01+388
CVTDAIR  EQU   CVTS01+384
CVTPERFM EQU   CVTS01+380
CVT044R2 EQU   CVTS01+376
CVTFETCH EQU   CVTS01+372
CVTSPOST EQU   CVTS01+364
CVTIOBP  EQU   CVTS01+360
CVTASMVT EQU   CVTS01+356
CVTRECRQ EQU   CVTS01+352
CVTWSAC  EQU   CVTS01+348
CVTRV149 EQU   CVTS01+344
CVTWSAL  EQU   CVTS01+340
CVTSPSA  EQU   CVTS01+336
CVTGLMN  EQU   CVTS01+332
CVTVEAC0 EQU   CVTS01+328
CVT062R1 EQU   CVTS01+324
CVTRPOST EQU   CVTS01+320
CVTDQIQE EQU   CVTS01+316
CVTLKRMA EQU   CVTS01+308
CVTRSPIE EQU   CVTS01+304
CVTRENQ  EQU   CVTS01+300
CVTLQCB  EQU   CVTS01+296
CVTFQCB  EQU   CVTS01+292
CVTQCS01 EQU   CVTS01+288
CVTAPFT  EQU   CVTS01+284
CVTPARRL EQU   CVTS01+280
CVTVWAIT EQU   CVTS01+276
CVTGSPL  EQU   CVTS01+272
CVTLSMQ  EQU   CVTS01+268
CVTGSMQ  EQU   CVTS01+264
CVTEXPRO EQU   CVTS01+260
CVTOPCTP EQU   CVTS01+256
CVTSIC   EQU   CVTS01+252
CVTTPIOS EQU   CVTS01+248
CVTSDBF  EQU   CVTS01+240
CVTSCBP  EQU   CVTS01+236
CVTSDMP  EQU   CVTS01+232
CVTSV60  EQU   CVTS01+228
CVTASCBL EQU   CVTS01+220
CVTASCBH EQU   CVTS01+216
CVTGDA   EQU   CVTS01+212
CVTVVMDI EQU   CVTS01+204
CVTAQTOP EQU   CVTS01+200
CVTIOSCS EQU   CVTS01+196
CVTSDRM  EQU   CVTS01+192
CVTOPTE  EQU   CVTS01+188
CVTSTXU  EQU   CVTS01+184
CVTQUIS  EQU   CVTS01+180
CVTPARS  EQU   CVTS01+176
CVTS1EE  EQU   CVTS01+172
CVTFRAS  EQU   CVTS01+168
CVTQSAS  EQU   CVTS01+164
CVTCRAS  EQU   CVTS01+160
CVTDELCP EQU   CVTS01+152
CVTFRECL EQU   CVTS01+148
CVTGETCL EQU   CVTS01+144
CVTBLDCP EQU   CVTS01+140
CVTAUTHL EQU   CVTS01+136
CVTSCAN  EQU   CVTS01+132
CVTRV144 EQU   CVTS01+130
CVTMAXMP EQU   CVTS01+128
CVTSTCK  EQU   CVTS01+124
CVTRV139 EQU   CVTS01+123
CVTDSSAC EQU   CVTS01+122
CVTRV513 EQU   CVTS01+121
CVTIOSPL EQU   CVTS01+120
CVTPTGT  EQU   CVTS01+116
CVTCSPIE EQU   CVTS01+112
CVTSMFEX EQU   CVTS01+108
CVTOLT0A EQU   CVTS01+104
CVTSRBRT EQU   CVTS01+100
CVTPUTL  EQU   CVTS01+96
CVTASCRL EQU   CVTS01+92
CVTASCRF EQU   CVTS01+88
CVTRV326 EQU   CVTS01+84
CVTRV325 EQU   CVTS01+80
CVTRV324 EQU   CVTS01+76
CVT0VL01 EQU   CVTS01+72
CVTSHRVM EQU   CVTS01+68
CVTRV332 EQU   CVTS01+64
CVTTAS   EQU   CVTS01+60
CVTRSCN  EQU   CVTS01+56
CVTTRAC2 EQU   CVTS01+54
CVTTRACE EQU   CVTS01+52
CVTAPG   EQU   CVTS01+51
CVTSDTRC EQU   CVTCTLFG
CVTGTRCE EQU   CVTCTLFG
CVTNOMP  EQU   CVTCTLFG
CVTRSV79 EQU   CVTCTLFG
CVTDSTAT EQU   CVTCTLFG
CVTRSV78 EQU   CVTCTLFG
CVTRV333 EQU   CVTCTLFG
CVTRV323 EQU   CVTCTLFG
CVTSPVLK EQU   CVTS01+49
CVTRSV77 EQU   CVTS01+48
CVTRV331 EQU   CVTS01+44
CVTRV330 EQU   CVTS01+40
CVTRV329 EQU   CVTS01+36
CVTRV328 EQU   CVTS01+32
CVTRV322 EQU   CVTS01+28
CVTSLID  EQU   CVTSLIDA+1
CVTSYLK  EQU   CVTSLIDA
CVTRV321 EQU   CVTS01+20
CVTRV320 EQU   CVTS01+16
CVTLPDIR EQU   CVTLPDIA+1
CVTRSV69 EQU   CVTDIRST
CVTRSV68 EQU   CVTDIRST
CVTRSV67 EQU   CVTDIRST
CVTRSV66 EQU   CVTDIRST
CVTRSV65 EQU   CVTDIRST
CVTRSV64 EQU   CVTDIRST
CVTRSV63 EQU   CVTDIRST
CVTDICOM EQU   CVTDIRST
CVTPVTP  EQU   CVTS01+8
CVTLPDSR EQU   CVTS01+4
CVTGETL  EQU   CVTS01
PSARSAV  EQU   PSARSVTE+60
PSARSTK  EQU   PSARSVTE+56
PSAESAV3 EQU   PSARSVTE+52
PSAESTK3 EQU   PSARSVTE+48
PSAESAV2 EQU   PSARSVTE+44
PSAESTK2 EQU   PSARSVTE+40
PSAESAV1 EQU   PSARSVTE+36
PSAESTK1 EQU   PSARSVTE+32
PSAPSAV  EQU   PSARSVTE+28
PSAPSTK  EQU   PSARSVTE+24
PSAMSAV  EQU   PSARSVTE+20
PSAMSTK  EQU   PSARSVTE+16
PSASSAV  EQU   PSARSVTE+12
PSASSTK  EQU   PSARSVTE+8
PSANSTK  EQU   PSARSVTE+4
RBRSV161 EQU   RBSECS09+64
RBSIRBWA EQU   RBSECS09
RBIQEWRK EQU   RBSECS08+4
RBNEXAV  EQU   RBSECS08
RBIQEA   EQU   RBIQE2
RBIQE1   EQU   RBIQE+1
RBUSE    EQU   RBIQE
RBSQEA   EQU   RBSQE+1
@NM00069 EQU   RBSQE
RBCDE1   EQU   RBCDE+1
RBCDLOAD EQU   RBCDFLGS
RBCDXCTL EQU   RBCDFLGS
RBCDSYNC EQU   RBCDFLGS
RBCDNODE EQU   RBCDFLGS
RBRSV010 EQU   RBCDFLGS
RBCDATCH EQU   RBCDFLGS
RBRSV009 EQU   RBCDFLGS
RBNOCELL EQU   RBCDFLGS
@NM00029 EQU   EEDERMAP
EEDHTIME EQU   EEDHWREP+20
EEDHRFSA EQU   EEDHWREP+16
@NM00028 EQU   EEDHWREP+14
EEDHVERQ EQU   EEDHRSR2
EEDHPGFX EQU   EEDHRSR2
EEDHFLSQ EQU   EEDHRSR2
EEDHFSQA EQU   EEDHRSR2
EEDHNUCL EQU   EEDHRSR2
EEDHSPER EQU   EEDHRSR2
EEDHINTC EQU   EEDHRSR2
EEDHOFLN EQU   EEDHRSR2
EEDHCHNG EQU   EEDHRSR1
EEDHMSER EQU   EEDHRSR1
@NM00027 EQU   EEDHRSR1
EEDHCPID EQU   EEDHWREP+10
EEDHTERR EQU   EEDHMCHD
EEDHSOFT EQU   EEDHMCHD
EEDHINSF EQU   EEDHMCHD
EEDHACR  EQU   EEDHMCHD
EEDHSCK  EQU   EEDHMCHD
EEDHPSWU EQU   EEDHMCHD
EEDHREGU EQU   EEDHMCHD
EEDHSKYF EQU   EEDHMCHD
@NM00026 EQU   EEDHMCHS
@NM00025 EQU   EEDHMCHS
EEDHRSRF EQU   EEDHMCHS
EEDRSRC  EQU   EEDHMCHS
EEDINVP  EQU   EEDHMCHS
EEDHTSVL EQU   EEDHMCHS
EEDHRCDF EQU   EEDHMCHS
EEDHSRVL EQU   EEDHMCHS
EEDHSCKE EQU   EEDHWREP+4
EEDHSCKB EQU   EEDHWREP
EEDILC   EQU   EEDINILC+1
@NM00024 EQU   EEDINILC
EEDPSWIC EQU   EEDPSW1+4
EEDPSWMK EQU   EEDPSW1
EEDREG15 EQU   EEDREGS+60
EEDREG14 EQU   EEDREGS+56
EEDREG13 EQU   EEDREGS+52
EEDREG12 EQU   EEDREGS+48
EEDREG11 EQU   EEDREGS+44
EEDREG10 EQU   EEDREGS+40
EEDREG9  EQU   EEDREGS+36
EEDREG8  EQU   EEDREGS+32
EEDREG7  EQU   EEDREGS+28
EEDREG6  EQU   EEDREGS+24
EEDREG5  EQU   EEDREGS+20
EEDREG4  EQU   EEDREGS+16
EEDREG3  EQU   EEDREGS+12
EEDREG2  EQU   EEDREGS+8
EEDREG1  EQU   EEDREGS+4
EEDREG0  EQU   EEDREGS
@NM00021 EQU   RT1RTRN
@NM00020 EQU   RT1WCOVR
RT1TRTCA EQU   RT1WCOVR
RT1TLOCL EQU   RT1WCOVR
RT1WCLUP EQU   RT1WCOVR
RT1WSRMD EQU   RT1WENTR+1
RT1WSRBR EQU   RT1WPRSV+4
EEDSPDAT EQU   EEDSDDAT+2
EEDSSDAT EQU   EEDSDDAT
EEDSDUMP EQU   EEDSCDMP
@NM00186 EQU   @NM00185
SLPWA    EQU   SLIPLIST+24
CVTLEVL  EQU   CVTRELNO+2
CVTNUMB  EQU   CVTRELNO
CVTMDL   EQU   CVTFIX+250
@NM00182 EQU   CVTFIX+248
@NM00181 EQU   CVTFIX
CVTRV482 EQU   CVTXTNT2+128
CVTRV481 EQU   CVTXTNT2+124
CVTRV480 EQU   CVTXTNT2+120
CVTRV479 EQU   CVTXTNT2+118
CVTRV478 EQU   CVTXTNT2+117
CVTRV477 EQU   CVTXTNT2+116
CVTRV476 EQU   CVTXTNT2+115
CVTRV475 EQU   CVTXTNT2+114
CVTRV474 EQU   CVTRV466
CVTRV473 EQU   CVTRV466
CVTRV472 EQU   CVTRV466
CVTRV471 EQU   CVTRV466
CVTRV470 EQU   CVTRV466
CVTRV469 EQU   CVTRV466
CVTRV468 EQU   CVTRV466
CVTRV467 EQU   CVTRV466
CVTRV465 EQU   CVTRV457
CVTRV464 EQU   CVTRV457
CVTRV463 EQU   CVTRV457
CVTRV462 EQU   CVTRV457
CVTRV461 EQU   CVTRV457
CVTRV460 EQU   CVTRV457
CVTRV459 EQU   CVTRV457
CVTRV458 EQU   CVTRV457
CVTRV456 EQU   CVTXTNT2+108
CVTRV455 EQU   CVTXTNT2+104
CVTRV454 EQU   CVTXTNT2+100
CVTRV453 EQU   CVTXTNT2+96
CVTRV452 EQU   CVTXTNT2+94
CVTRV451 EQU   CVTXTNT2+92
CVTRV450 EQU   CVTXTNT2+90
CVTRV449 EQU   CVTXTNT2+88
CVTRV448 EQU   CVTXTNT2+87
CVTRV447 EQU   CVTXTNT2+86
CVTRV446 EQU   CVTRV438
CVTRV445 EQU   CVTRV438
CVTRV444 EQU   CVTRV438
CVTRV443 EQU   CVTRV438
CVTRV442 EQU   CVTRV438
CVTRV441 EQU   CVTRV438
CVTRV440 EQU   CVTRV438
CVTRV439 EQU   CVTRV438
CVTRV437 EQU   CVTRV429
CVTRV436 EQU   CVTRV429
CVTRV435 EQU   CVTRV429
CVTRV434 EQU   CVTRV429
CVTRV433 EQU   CVTRV429
CVTRV432 EQU   CVTRV429
CVTRV431 EQU   CVTRV429
CVTRV430 EQU   CVTRV429
CVTRV428 EQU   CVTXTNT2+80
CVTRV427 EQU   CVTXTNT2+76
CVTRV426 EQU   CVTXTNT2+72
CVTRV425 EQU   CVTXTNT2+68
CVTATACT EQU   CVTATCVT
CVTRV423 EQU   CVTXTNT2+62
CVTRV422 EQU   CVTXTNT2+60
CVTRV421 EQU   CVTXTNT2+58
CVTRV420 EQU   CVTXTNT2+56
CVTRV419 EQU   CVTXTNT2+55
CVTRV418 EQU   CVTXTNT2+54
CVTRV417 EQU   CVTRV409
CVTRV416 EQU   CVTRV409
CVTRV415 EQU   CVTRV409
CVTRV414 EQU   CVTRV409
CVTRV413 EQU   CVTRV409
CVTRV412 EQU   CVTRV409
CVTRV411 EQU   CVTRV409
CVTRV410 EQU   CVTRV409
CVTRV408 EQU   CVTRV400
CVTRV407 EQU   CVTRV400
CVTRV406 EQU   CVTRV400
CVTRV405 EQU   CVTRV400
CVTRV404 EQU   CVTRV400
CVTRV403 EQU   CVTRV400
CVTRV402 EQU   CVTRV400
CVTRV401 EQU   CVTRV400
CVTICB   EQU   CVTXTNT2+48
CVTSKTA  EQU   CVTXTNT2+44
CVTCCVT  EQU   CVTXTNT2+40
CVTRSV98 EQU   CVTXTNT2+36
CVTRSV97 EQU   CVTXTNT2+34
CVTRSV96 EQU   CVTXTNT2+32
CVTOLTEP EQU   CVTXTNT2+28
CVTQIDA  EQU   CVTQID+1
CVTRSV95 EQU   CVTQID
CVTRSV94 EQU   CVTXTNT2+20
CVTRSV93 EQU   CVTXTNT2+16
CVTRSV92 EQU   CVTXTNT2+12
CVTDEBVR EQU   CVTXTNT2+8
CVTRSV91 EQU   CVTXTNT2+6
CVTRSV9H EQU   CVTFLGBT
CVTRSV9G EQU   CVTFLGBT
CVTRSV9F EQU   CVTFLGBT
CVTRSV9E EQU   CVTFLGBT
CVTRSV9D EQU   CVTFLGBT
CVTBAH   EQU   CVTFLGBT
CVTVME   EQU   CVTFLGBT
CVTNPE   EQU   CVTFLGBT
CVTNUCLS EQU   CVTXTNT2+4
CVTDSSVA EQU   CVTDSSV+1
CVTRSV89 EQU   CVTDSSV
CVTRSV88 EQU   CVTXTNT1+8
CVTRSV87 EQU   CVTXTNT1+4
CVTFACHN EQU   CVTXTNT1
CVTRV488 EQU   CVTMAP+412
CVTRV487 EQU   CVTMAP+408
CVTRV486 EQU   CVTMAP+404
CVTRV485 EQU   CVTMAP+400
CVTACTAP EQU   CVTMAP+396
CVTAUTH  EQU   CVTMAP+392
CVTRV490 EQU   CVTMAP+388
CVTSU    EQU   CVTMAP+384
CVTVOLT1 EQU   CVTVOLM1+1
CVTVOLI1 EQU   CVTVOLF1
CVTSTOA  EQU   CVTMAP+376
CVTRSV58 EQU   CVTMAP+374
CVTRSV57 EQU   CVTMAP+372
CVTDDCE  EQU   CVTMAP+368
CVTPNWFR EQU   CVTMAP+364
CVTSMF   EQU   CVTMAP+360
CVTSULK  EQU   CVTMAP+358
CVTSLKO  EQU   CVTSYSK
CVTSLKP  EQU   CVTSYSK
CVTSLKQ  EQU   CVTSYSK
CVTSLKR  EQU   CVTSYSK
CVTRSV56 EQU   CVTSYSK
CVTRSV55 EQU   CVTSYSK
CVTRSV54 EQU   CVTSYSK
CVTRSV53 EQU   CVTSYSK
CVTRSV52 EQU   CVTA1F1
CVTRSV51 EQU   CVTA1F1
CVTRSV50 EQU   CVTA1F1
CVTRSV49 EQU   CVTA1F1
CVTRSV48 EQU   CVTA1F1
CVTRSV47 EQU   CVTA1F1
CVTSRSW  EQU   CVTA1F1
CVTPFSW  EQU   CVTA1F1
CVTPCVT  EQU   CVTMAP+352
CVTRSV46 EQU   CVTMAP+344
CVTRSV45 EQU   CVTMAP+340
CVTRSV44 EQU   CVTMAP+338
CVTRSV43 EQU   CVTMAP+336
CVTHJESA EQU   CVTHJES+1
CVTRSV42 EQU   CVTHJES
CVTEXT2A EQU   CVTEXT2+1
CVTRSV41 EQU   CVTEXT2
CVTAPFA  EQU   CVTAPF+1
CVTRSV40 EQU   CVTAPF
CVTRV518 EQU   CVTINTLA
CVTRV517 EQU   CVTERPV
CVTEORM  EQU   CVTMAP+312
CVTMCHPR EQU   CVTMAP+308
CVTTZ    EQU   CVTMAP+304
CVTJEPS  EQU   CVTMAP+300
CVTJESCT EQU   CVTMAP+296
CVTMODE  EQU   CVTMAP+292
CVTPTRV  EQU   CVTMAP+288
CVTREAL  EQU   CVTMAP+284
CVTRSV39 EQU   CVTMAP+280
CVTRSV38 EQU   CVTMAP+276
CVTDMSRA EQU   CVTDMSR+1
CVTRV634 EQU   CVTDMSRF
CVTRV633 EQU   CVTDMSRF
CVTRV632 EQU   CVTDMSRF
CVTRV631 EQU   CVTDMSRF
CVTRV630 EQU   CVTDMSRF
CVTRV629 EQU   CVTDMSRF
CVTUDUMP EQU   CVTDMSRF
CVTSDUMP EQU   CVTDMSRF
CVTQMSGA EQU   CVTQMSG+1
CVTRSV36 EQU   CVTQMSG
CVTAMFF  EQU   CVTMAP+264
CVTPURGA EQU   CVTPURG+1
CVTRSV35 EQU   CVTPURG
CVTCBSP  EQU   CVTMAP+256
CVTATERA EQU   CVTATER+1
CVTSYST  EQU   CVTATER
CVTVOLT2 EQU   CVTTAT
CVTVOLI2 EQU   CVTVOLF2
CVTAQAVB EQU   CVTAQAVT+1
CVTRSV34 EQU   CVTTCMFG
CVTRSV33 EQU   CVTTCMFG
CVTRSV32 EQU   CVTTCMFG
CVTRSV31 EQU   CVTTCMFG
CVTRSV30 EQU   CVTTCMFG
CVTRSV29 EQU   CVTTCMFG
CVTLDEV  EQU   CVTTCMFG
CVTTCRDY EQU   CVTTCMFG
CVTGTFA  EQU   CVTGTF+1
CVTRSV27 EQU   CVTGTFST
CVTRNIO  EQU   CVTGTFST
CVTUSR   EQU   CVTGTFST
CVTRV318 EQU   CVTFORM
CVTRV317 EQU   CVTTMODE
CVTRV316 EQU   CVTSTATE
CVTRV315 EQU   CVTGTFS
CVTGTFAV EQU   CVTGTFS
CVT0SCR1 EQU   CVTMAP+232
CVTRV515 EQU   CVTMAP+228
CVTRMS   EQU   CVTMAP+224
CVTPATCH EQU   CVTMAP+220
CVTTSCE  EQU   CVTMAP+216
CVTLNKSC EQU   CVTMAP+214
CVTQABST EQU   CVTMAP+212
CVTMDLDS EQU   CVTMAP+208
CVTUSER  EQU   CVTMAP+204
CVTSMCA  EQU   CVTMAP+196
CVTRSV18 EQU   CVTMAP+192
CVTQLPAQ EQU   CVTMAP+188
CVTQCDSR EQU   CVTMAP+184
CVTVS1B  EQU   CVTOPTB
CVTVS1A  EQU   CVTOPTB
CVTFP    EQU   CVTOPTB
CVTAPTHR EQU   CVTOPTB
CVTNLOG  EQU   CVTOPTB
CVTTOD   EQU   CVTOPTB
CVTCTIMS EQU   CVTOPTB
CVTPROT  EQU   CVTOPTB
CVTXPFP  EQU   CVTOPTA
CVTASCII EQU   CVTOPTA
CVTRSV13 EQU   CVTOPTA
CVTRSV12 EQU   CVTOPTA
CVTNIP   EQU   CVTOPTA
CVTDDR   EQU   CVTOPTA
CVTAPR   EQU   CVTOPTA
CVTCCH   EQU   CVTOPTA
CVTSNCTR EQU   CVTMAP+180
CVTQMWR  EQU   CVTMAP+176
CVTQOCR  EQU   CVTMAP+172
CVT1EF00 EQU   CVTMAP+168
CVTMZ00  EQU   CVTMAP+164
CVTSV76Q EQU   CVTSV76C
CVTRSV11 EQU   CVTMAP+156
CVTMSER  EQU   CVTMAP+148
CVTRV516 EQU   CVTIERLC
CVTILCH  EQU   CVTMAP+140
CVT0DS   EQU   CVTMAP+136
CVTFBOSV EQU   CVTMAP+132
CVTNUCB  EQU   CVTMAP+128
CVTIXAVL EQU   CVTMAP+124
CVTSV76M EQU   CVTIOQET
CVTDCBA  EQU   CVTMAP+117
CVTMVS2  EQU   CVTDCB
CVT6DAT  EQU   CVTDCB
CVT4MPS  EQU   CVTDCB
CVTRSV09 EQU   CVTDCB
CVT4MS1  EQU   CVTDCB
CVT2SPS  EQU   CVTDCB
CVT1SSS  EQU   CVTDCB
CVTRSV08 EQU   CVTDCB
CVTSTB   EQU   CVTMAP+112
CVTQTD00 EQU   CVTMAP+108
CVTQTE00 EQU   CVTMAP+104
CVTCUCB  EQU   CVTMAP+100
CVTSJQ   EQU   CVTMAP+96
CVTPBLDL EQU   CVTMAP+92
CVTTPC   EQU   CVTMAP+88
CVTSVDCB EQU   CVTMAP+84
CVTBRET  EQU   CVTMAP+82
CVTEXIT  EQU   CVTMAP+80
CVT0FN00 EQU   CVTMAP+76
CVTDARA  EQU   CVTDAR+1
CVTRSV07 EQU   CVTFLGS1
CVTRSV06 EQU   CVTFLGS1
CVTRSV05 EQU   CVTFLGS1
CVTRSV04 EQU   CVTFLGS1
CVTRSV03 EQU   CVTFLGS1
CVTRSV02 EQU   CVTFLGS1
CVTRSV01 EQU   CVTFLGS1
CVTDMPLK EQU   CVTFLGS1
CVTXITP  EQU   CVTMAP+68
CVTZDTAB EQU   CVTMAP+64
CVTMSLT  EQU   CVTMAP+60
CVTDATE  EQU   CVTMAP+56
CVTSYSAD EQU   CVTMAP+48
CVTXTLER EQU   CVTMAP+44
CVTILK2  EQU   CVTMAP+40
CVTILK1  EQU   CVTMAP+36
CVTPRLTV EQU   CVTMAP+32
CVTPCNVT EQU   CVTMAP+28
CVT0VL00 EQU   CVTMAP+24
CVTXAPG  EQU   CVTMAP+20
CVTBUF   EQU   CVTMAP+16
CVTJOB   EQU   CVTMAP+12
CVTLINK  EQU   CVTMAP+8
CVT0EF00 EQU   CVTMAP+4
CVTTCBP  EQU   CVTMAP
CVT      EQU   CVTMAP
SHDRIDCT EQU   SHDR+22
SHDRSEQ  EQU   SHDR+21
@NM00180 EQU   SHDRFLGS
SHDRDELP EQU   SHDRFLGS
SHDRFRR  EQU   SHDRFLGS
SHDRBKWD EQU   SHDR+16
SHDRFWD  EQU   SHDRCTFW+4
SHDRCTR  EQU   SHDRCTFW
SHDRCBID EQU   SHDR
SNPHDRA  EQU   SNPPARMS+20
SNPTCBA  EQU   SNPPARMS+12
SNPDCB   EQU   SNPPARMS+8
@NM00179 EQU   SNPPARMS+7
@NM00178 EQU   SNPPDATA
SNPSPLS  EQU   SNPPDATA
SNPPSW   EQU   SNPPDATA
SNPJPA   EQU   SNPPDATA
SNPLPA   EQU   SNPPDATA
SNPREGS  EQU   SNPPDATA
SNPSAVE2 EQU   SNPPDATA
SNPSAVE  EQU   SNPPDATA
@NM00177 EQU   SNPSDAT1
SNPERR   EQU   SNPSDAT1
SNPIO    EQU   SNPSDAT1
SNPDM    EQU   SNPSDAT0
SNPQCB   EQU   SNPSDAT0
SNPCB    EQU   SNPSDAT0
SNPTRT   EQU   SNPSDAT0
SNPSWA   EQU   SNPSDAT0
SNPLSQA  EQU   SNPSDAT0
SNPSQA   EQU   SNPSDAT0
SNPNUC   EQU   SNPSDAT0
@NM00176 EQU   SNPPARMS+2
SNPHDR   EQU   SNPFLAG
SNPTCB   EQU   SNPFLAG
SNPID    EQU   SNPFLAG
SNPABEND EQU   SNPFLAG
SNPVS2EN EQU   SNPFLAG
SNPVS2   EQU   SNPFLAG
SNPSNAP  EQU   SNPFLAG
@NM00175 EQU   SDWA+512
SDWAVRA  EQU   SDWARA+4
SDWAURAL EQU   SDWARA+3
@NM00174 EQU   SDWADPVA
SDWAEBC  EQU   SDWADPVA
SDWAHEX  EQU   SDWADPVA
SDWAVRAL EQU   SDWARA
SDWACOMP EQU   SDWA+392
SDWARCPL EQU   SDWA+364
@NM00173 EQU   SDWADPSA+32
SDWATO4  EQU   SDWADPSL+28
SDWAFRM4 EQU   SDWADPSL+24
SDWATO3  EQU   SDWADPSL+20
SDWAFRM3 EQU   SDWADPSL+16
SDWATO2  EQU   SDWADPSL+12
SDWAFRM2 EQU   SDWADPSL+8
SDWATO1  EQU   SDWADPSL+4
SDWAFRM1 EQU   SDWADPSL
@NM00172 EQU   SDWADDAT+3
@NM00171 EQU   SDWAPDAT
SDWAUSPL EQU   SDWAPDAT
SDWADPSW EQU   SDWAPDAT
SDWATJPA EQU   SDWAPDAT
SDWATLPA EQU   SDWAPDAT
SDWADREG EQU   SDWAPDAT
SDWADSAH EQU   SDWAPDAT
SDWADSAS EQU   SDWAPDAT
@NM00170 EQU   SDWASDA1
SDWAERR  EQU   SDWASDA1
SDWAIO   EQU   SDWASDA1
SDWADM   EQU   SDWASDA0
SDWAQQS  EQU   SDWASDA0
SDWACBS  EQU   SDWASDA0
SDWAGTF  EQU   SDWASDA0
SDWASWA  EQU   SDWASDA0
SDWALSQA EQU   SDWASDA0
SDWASQA  EQU   SDWASDA0
SDWANUC  EQU   SDWASDA0
@NM00169 EQU   SDWADUMP+2
@NM00168 EQU   SDWADPFS
SDWASLST EQU   SDWADPFS
@NM00167 EQU   SDWADPFS
SDWAENSN EQU   SDWADPFS
SDWADPT  EQU   SDWADPFS
SDWADPID EQU   SDWADUMP
SDWADPLA EQU   SDWA+316
SDWAREXN EQU   SDWARECP+16
SDWACSCT EQU   SDWARECP+8
SDWAMODN EQU   SDWARECP
SDWAASID EQU   SDWA+288
SDWATALW EQU   SDWALKWS+28
SDWATDLW EQU   SDWALKWS+24
SDWATNLW EQU   SDWALKWS+20
SDWAAPLW EQU   SDWALKWS+16
SDWAIPLW EQU   SDWALKWS+12
SDWAILLW EQU   SDWALKWS+8
SDWAIULW EQU   SDWALKWS+4
SDWAICLW EQU   SDWALKWS
SDWAFLLK EQU   SDWAACF4
SDWACMS  EQU   SDWAACF4
SDWAOPTM EQU   SDWAACF4
SDWATADB EQU   SDWAACF4
SDWATDNB EQU   SDWAACF4
SDWATNCB EQU   SDWAACF4
SDWAILCH EQU   SDWAACF4
SDWAIUCB EQU   SDWAACF4
SDWAICAT EQU   SDWAACF3
SDWAIPRG EQU   SDWAACF3
SDWASALL EQU   SDWAACF3
SDWAASMP EQU   SDWAACF3
SDWADISP EQU   SDWAACF3
@NM00166 EQU   SDWAACF3
@NM00165 EQU   SDWAACF2
SDWAFREE EQU   SDWAACF2
SDWAUPRG EQU   SDWAACF2
@NM00164 EQU   SDWAACF2
@NM00163 EQU   SDWAACF2
SDWARCRD EQU   SDWAACF2
@NM00162 EQU   SDWACPUA
SDWARECA EQU   SDWA+244
@NM00161 EQU   SDWAIOFS
SDWANIOP EQU   SDWAIOFS
SDWANOIO EQU   SDWAIOFS
SDWAIOHT EQU   SDWAIOFS
SDWAIOQR EQU   SDWAIOFS
SDWAMCIV EQU   SDWAERRD
SDWARPIV EQU   SDWAERRD
SDWAMABD EQU   SDWAERRD
SDWACTS  EQU   SDWAERRD
SDWASTAE EQU   SDWAERRD
SDWANRBE EQU   SDWAERRD
SDWACLUP EQU   SDWAERRD
@NM00160 EQU   SDWAERRC
SDWAEAS  EQU   SDWAERRC
SDWAPERC EQU   SDWAERRC
SDWAIRB  EQU   SDWAERRC
SDWASTAI EQU   SDWAERRC
SDWASTAF EQU   SDWAERRC
SDWASRBM EQU   SDWAERRB
SDWALDIS EQU   SDWAERRB
SDWAENRB EQU   SDWAERRB
SDWATYP1 EQU   SDWAERRB
@NM00159 EQU   SDWAERRB
SDWAPGIO EQU   SDWAERRA
SDWATEXC EQU   SDWAERRA
SDWASVCE EQU   SDWAERRA
SDWAABTM EQU   SDWAERRA
SDWASVCD EQU   SDWAERRA
SDWARKEY EQU   SDWAERRA
SDWAPCHK EQU   SDWAERRA
SDWAMCHK EQU   SDWAERRA
SDWATIME EQU   SDWAMCH+20
SDWARFSA EQU   SDWAMCH+16
@NM00158 EQU   SDWAMCH+14
SDWAVEQR EQU   SDWARSR2
SDWAPGFX EQU   SDWARSR2
SDWAFLSQ EQU   SDWARSR2
SDWAFSQA EQU   SDWARSR2
SDWANUCL EQU   SDWARSR2
SDWASPER EQU   SDWARSR2
SDWAINTC EQU   SDWARSR2
SDWAOFLN EQU   SDWARSR2
SDWACHNG EQU   SDWARSR1
SDWAMSER EQU   SDWARSR1
@NM00157 EQU   SDWARSR1
SDWACPID EQU   SDWAMCH+10
SDWATERR EQU   SDWAMCHD
SDWAFPRX EQU   SDWAMCHD
SDWAINSF EQU   SDWAMCHD
SDWAACR  EQU   SDWAMCHD
SDWASCK  EQU   SDWAMCHD
SDWAPSWU EQU   SDWAMCHD
SDWAREGU EQU   SDWAMCHD
SDWASKYF EQU   SDWAMCHD
@NM00156 EQU   SDWAMCHS
SDWARSRF EQU   SDWAMCHS
SDWARSRC EQU   SDWAMCHS
SDWAINVP EQU   SDWAMCHS
SDWATSVL EQU   SDWAMCHS
SDWARCDF EQU   SDWAMCHS
SDWASRVL EQU   SDWAMCHS
SDWASCKE EQU   SDWASTCK+4
SDWASCKB EQU   SDWASTCK
SDWASR14 EQU   SDWASRSV+56
SDWASR13 EQU   SDWASRSV+52
SDWASR12 EQU   SDWASRSV+48
SDWASR11 EQU   SDWASRSV+44
SDWASR10 EQU   SDWASRSV+40
SDWASR09 EQU   SDWASRSV+36
SDWASR08 EQU   SDWASRSV+32
SDWASR07 EQU   SDWASRSV+28
SDWASR06 EQU   SDWASRSV+24
SDWASR05 EQU   SDWASRSV+20
SDWASR04 EQU   SDWASRSV+16
SDWASR03 EQU   SDWASRSV+12
SDWASR02 EQU   SDWASRSV+8
SDWASR01 EQU   SDWASRSV+4
SDWATRN2 EQU   SDWAAEC2+4
SDWAIPC2 EQU   SDWAICD2
SDWAIMC2 EQU   SDWAICD2
SDWAIPR2 EQU   SDWAICD2
@NM00155 EQU   SDWAINC2
@NM00154 EQU   SDWAILC2
SDWAIL2  EQU   SDWAILC2
@NM00153 EQU   SDWAILC2
@NM00152 EQU   SDWAAEC2
SDWAADD2 EQU   SDWANXT2+1
@NM00151 EQU   SDWANXT2
@NM00150 EQU   SDWAEC2+3
SDWASGN2 EQU   SDWAINT2
SDWAEXP2 EQU   SDWAINT2
SDWADEC2 EQU   SDWAINT2
SDWAFPO2 EQU   SDWAINT2
SDWACC2  EQU   SDWAINT2
@NM00149 EQU   SDWAINT2
SDWAPGM2 EQU   SDWAMWP2
SDWAWAT2 EQU   SDWAMWP2
SDWAMCK2 EQU   SDWAMWP2
SDWAECT2 EQU   SDWAMWP2
SDWAKEY2 EQU   SDWAMWP2
SDWAEXT2 EQU   SDWAEMK2
SDWAIO2  EQU   SDWAEMK2
SDWATRM2 EQU   SDWAEMK2
@NM00148 EQU   SDWAEMK2
SDWAPER2 EQU   SDWAEMK2
@NM00147 EQU   SDWAEMK2
SDWATRAN EQU   SDWAAEC1+4
SDWAIPC1 EQU   SDWAICD1
SDWAIMC1 EQU   SDWAICD1
SDWAIPR1 EQU   SDWAICD1
@NM00146 EQU   SDWAINC1
@NM00145 EQU   SDWAILC1
SDWAIL1  EQU   SDWAILC1
@NM00144 EQU   SDWAILC1
@NM00143 EQU   SDWAAEC1
SDWAADD1 EQU   SDWANXT1+1
@NM00142 EQU   SDWANXT1
@NM00141 EQU   SDWAEC1+3
SDWASGN1 EQU   SDWAINT1
SDWAEXP1 EQU   SDWAINT1
SDWADEC1 EQU   SDWAINT1
SDWAFPO1 EQU   SDWAINT1
SDWACC1  EQU   SDWAINT1
@NM00140 EQU   SDWAINT1
SDWAPGM1 EQU   SDWAMWP1
SDWAWAT1 EQU   SDWAMWP1
SDWAMCK1 EQU   SDWAMWP1
SDWAECT1 EQU   SDWAMWP1
SDWAKEY1 EQU   SDWAMWP1
SDWAEXT1 EQU   SDWAEMK1
SDWAIO1  EQU   SDWAEMK1
SDWATRM1 EQU   SDWAEMK1
@NM00139 EQU   SDWAEMK1
SDWAPER1 EQU   SDWAEMK1
@NM00138 EQU   SDWAEMK1
SDWAIOBR EQU   SDWA+100
SDWAEPA  EQU   SDWA+96
@NM00137 EQU   SDWANAME+4
SDWARBAD EQU   SDWANAME
SDWAGR15 EQU   SDWAGRSV+60
SDWAGR14 EQU   SDWAGRSV+56
SDWAGR13 EQU   SDWAGRSV+52
SDWAGR12 EQU   SDWAGRSV+48
SDWAGR11 EQU   SDWAGRSV+44
SDWAGR10 EQU   SDWAGRSV+40
SDWAGR09 EQU   SDWAGRSV+36
SDWAGR08 EQU   SDWAGRSV+32
SDWAGR07 EQU   SDWAGRSV+28
SDWAGR06 EQU   SDWAGRSV+24
SDWAGR05 EQU   SDWAGRSV+20
SDWAGR04 EQU   SDWAGRSV+16
SDWAGR03 EQU   SDWAGRSV+12
SDWAGR02 EQU   SDWAGRSV+8
SDWAGR01 EQU   SDWAGRSV+4
SDWAGR00 EQU   SDWAGRSV
SDWANXTP EQU   SDWACTL2+5
SDWASGP  EQU   SDWAPMKP
SDWAEUP  EQU   SDWAPMKP
SDWADOP  EQU   SDWAPMKP
SDWAFPP  EQU   SDWAPMKP
SDWACCP  EQU   SDWAPMKP
SDWAILP  EQU   SDWAPMKP
SDWAINTP EQU   SDWACTL2+2
SDWASPVP EQU   SDWAMWPP
SDWAWATP EQU   SDWAMWPP
SDWAMCKP EQU   SDWAMWPP
@NM00136 EQU   SDWAMWPP
SDWAKEYP EQU   SDWAMWPP
SDWAEXTP EQU   SDWACMKP
SDWAIOP  EQU   SDWACMKP
SDWANXTA EQU   SDWACTL1+5
SDWASGA  EQU   SDWAPMKA
SDWAEUA  EQU   SDWAPMKA
SDWADOA  EQU   SDWAPMKA
SDWAFPA  EQU   SDWAPMKA
SDWACCA  EQU   SDWAPMKA
SDWAILA  EQU   SDWAPMKA
SDWAINTA EQU   SDWACTL1+2
SDWASPVA EQU   SDWAMWPA
SDWAWATA EQU   SDWAMWPA
SDWAMCKA EQU   SDWAMWPA
@NM00135 EQU   SDWAMWPA
SDWAKEYA EQU   SDWAMWPA
SDWAEXTA EQU   SDWACMKA
SDWAIOA  EQU   SDWACMKA
SDWACMPC EQU   SDWAABCC+1
@NM00134 EQU   SDWACMPF
SDWASTCC EQU   SDWACMPF
@NM00133 EQU   SDWACMPF
SDWASTEP EQU   SDWACMPF
SDWAREQ  EQU   SDWACMPF
SDWAPARM EQU   SDWA
FRRSPARM EQU   FRRSENTR+8
@NM00132 EQU   FRRSFLGS+1
@NM00131 EQU   FRRSFLG1
FRRSNEST EQU   FRRSFLG1
FRRSRCUR EQU   FRRSFLG1
FRRSFRRA EQU   FRRSENTR
FRRSENTS EQU   FRRS+84
FRRSCURR EQU   FRRSHEAD+12
FRRSELEN EQU   FRRSHEAD+8
FRRSLAST EQU   FRRSHEAD+4
FRRSEMP  EQU   FRRSHEAD
@NM00106 EQU   IHSA+720
IHSAFRRS EQU   IHSA+120
IHSAFPR6 EQU   IHSAFPRS+24
IHSAFPR4 EQU   IHSAFPRS+16
IHSAFPR2 EQU   IHSAFPRS+8
IHSAFPR0 EQU   IHSAFPRS
IHSAOTCB EQU   IHSA+12
IHSANTCB EQU   IHSA+8
IHSACPUT EQU   IHSA
@NM00105 EQU   SSRBFLG1
SSRBMAIN EQU   SSRBFLG1
SSRBLLH  EQU   SSRBFLG1
SSRBFRRS EQU   SSRB+108
SSRBFPR6 EQU   SSRBFPRS+24
SSRBFPR4 EQU   SSRBFPRS+16
SSRBFPR2 EQU   SSRBFPRS+8
SSRBFPR0 EQU   SSRBFPRS
@NM00104 EQU   SRB+40
@NM00103 EQU   SRB+38
SRBPRIOR EQU   SRB+37
SRBPKF   EQU   SRB+36
SRBSAVE  EQU   SRB+32
SRBRMTR  EQU   SRB+24
SRBCPAFF EQU   SRBFLC
SRBFLNK  EQU   SRB+4
SRBID    EQU   SRB
ASVTEND  EQU   ASVT+528
ASVTAVAI EQU   ASVTFRST
ASVTRS00 EQU   ASVT+520
ASVTASVT EQU   ASVT+512
ASVTBEGN EQU   ASVT+512
@NM00102 EQU   ASVT
@NM00101 EQU   CSD+160
CSDUCNT  EQU   CSD+124
CSDTCNT  EQU   CSD+120
CSDGDTOD EQU   CSD+116
CSDGDINT EQU   CSD+112
CSDGDCC  EQU   CSD+108
CSDDDRCT EQU   CSD+106
CSDRV044 EQU   CSD+104
CSDMAFF  EQU   CSD+24
CSDRV038 EQU   CSDFLAGS
CSDRV037 EQU   CSDFLAGS
CSDRV036 EQU   CSDFLAGS
CSDRV035 EQU   CSDFLAGS
CSDRV034 EQU   CSDFLAGS
CSDRV033 EQU   CSDFLAGS
CSDRV032 EQU   CSDFLAGS
CSDMP    EQU   CSDFLAGS
CSDACR   EQU   CSD+22
CSDMF1CP EQU   CSD+20
CSDRV043 EQU   CSD+16
CSDRV030 EQU   CSDSCFL4
CSDRV029 EQU   CSDSCFL4
CSDRV028 EQU   CSDSCFL4
CSDRV027 EQU   CSDSCFL4
CSDRV026 EQU   CSDSCFL4
CSDRV025 EQU   CSDSCFL4
CSDRV024 EQU   CSDSCFL4
CSDRV023 EQU   CSDSCFL4
CSDRV022 EQU   CSDSCFL3
CSDRV021 EQU   CSDSCFL3
CSDRV020 EQU   CSDSCFL3
CSDRV019 EQU   CSDSCFL3
CSDRV018 EQU   CSDSCFL3
CSDRV017 EQU   CSDSCFL3
CSDRV016 EQU   CSDSCFL3
CSDRV015 EQU   CSDSCFL3
CSDRV014 EQU   CSDSCFL2
CSDRV013 EQU   CSDSCFL2
CSDRV012 EQU   CSDSCFL2
CSDRV011 EQU   CSDSCFL2
CSDRV010 EQU   CSDSCFL2
CSDRV009 EQU   CSDSCFL2
CSDRV008 EQU   CSDSCFL2
CSDRV007 EQU   CSDSCFL2
CSDRV006 EQU   CSDSCFL1
CSDRV005 EQU   CSDSCFL1
CSDRV004 EQU   CSDSCFL1
CSDRV003 EQU   CSDSCFL1
CSDRV002 EQU   CSDSCFL1
CSDRV001 EQU   CSDSCFL1
CSDSYSND EQU   CSDSCFL1
CSDRV042 EQU   CSDSCFL1
CSDCPUOL EQU   CSD+10
CSDSAFF  EQU   CSDCPUAL
CSDCHAD  EQU   CSD+6
CSDCPUJS EQU   CSD+4
CSDCSD   EQU   CSD
LCCAR125 EQU   LCCA+964
LCCAR124 EQU   LCCA+960
LCCASGPR EQU   LCCA+896
LCCADRT2 EQU   LCCA+888
LCCADRT1 EQU   LCCA+880
LCCAR103 EQU   LCCA+876
LCCAESS2 EQU   LCCA+872
LCCASPLJ EQU   LCCA+868
LCCASMQJ EQU   LCCA+864
LCCAIRT  EQU   LCCA+736
LCCARV89 EQU   LCCA+728
LCCASAFN EQU   LCCASRBF
LCCAECSA EQU   LCCA+716
LCCAICR0 EQU   LCCA+712
LCCALWTM EQU   LCCA+704
LCCARV78 EQU   LCCA+700
LCCAPINV EQU   LCCA+696
LCCARV88 EQU   LCCA+695
LCCARV87 EQU   LCCALKFG
LCCARV86 EQU   LCCALKFG
LCCARV85 EQU   LCCALKFG
LCCARV84 EQU   LCCALKFG
LCCALKRD EQU   LCCALKFG
LCCALKAQ EQU   LCCALKFG
LCCALKSA EQU   LCCALKFG
LCCALKDP EQU   LCCALKFG
LCCACRST EQU   LCCACREX
LCCACRDP EQU   LCCACREX
LCCACRLM EQU   LCCACREX
LCCACRIN EQU   LCCACREX
LCCACRRT EQU   LCCACREX
LCCACRLE EQU   LCCACREX
LCCACRRM EQU   LCCACREX
LCCACREF EQU   LCCACREX
LCCAVARY EQU   LCCACRFL
LCCARV73 EQU   LCCACRFL
LCCARV72 EQU   LCCACRFL
LCCARV71 EQU   LCCACRFL
LCCARV70 EQU   LCCACRFL
LCCARV69 EQU   LCCACRFL
LCCACLMS EQU   LCCACRFL
LCCACRTM EQU   LCCACRFL
LCCALCR0 EQU   LCCA+688
LCCACRLC EQU   LCCA+684
LCCARCPU EQU   LCCA+680
LCCADCPU EQU   LCCA+676
LCCASRBJ EQU   LCCA+672
LCCADSSR EQU   LCCA+668
LCCADSSC EQU   LCCA+660
LCCADSS3 EQU   LCCA+648
LCCADSS2 EQU   LCCA+636
LCCADSS1 EQU   LCCA+624
LCCAWTIM EQU   LCCA+616
LCCAITOD EQU   LCCA+608
LCCADTOD EQU   LCCA+600
LCCASTOD EQU   LCCA+592
LCCARIR5 EQU   LCCASPSA+44
LCCARIR4 EQU   LCCASPSA+40
LCCARIR3 EQU   LCCASPSA+36
LCCARIR2 EQU   LCCASPSA+32
LCCARPR5 EQU   LCCASPSA+28
LCCARPR4 EQU   LCCASPSA+24
LCCARPR3 EQU   LCCASPSA+20
LCCARPR2 EQU   LCCASPSA+16
LCCADSR5 EQU   LCCASPSA+12
LCCADSR4 EQU   LCCASPSA+8
LCCADSR3 EQU   LCCASPSA+4
LCCADSR2 EQU   LCCASPSA
LCCARV68 EQU   LCCA+543
LCCAPSMK EQU   LCCA+542
LCCARV67 EQU   LCCADSF2
LCCARV66 EQU   LCCADSF2
LCCARV65 EQU   LCCADSF2
LCCARV64 EQU   LCCADSF2
LCCADSRW EQU   LCCADSF2
LCCADSPL EQU   LCCADSF2
LCCAGSRB EQU   LCCADSF2
LCCARV61 EQU   LCCADSF1
LCCARV60 EQU   LCCADSF1
LCCARV59 EQU   LCCADSF1
LCCARV58 EQU   LCCADSF1
LCCATIMR EQU   LCCADSF1
LCCADSS  EQU   LCCADSF1
LCCAVCPU EQU   LCCADSF1
LCCAACR  EQU   LCCADSF1
LCCACPUS EQU   LCCA+536
LCCAASCP EQU   LCCA+532
LCCAESSA EQU   LCCA+528
LCCARV55 EQU   LCCASPN4
LCCARV54 EQU   LCCASPN4
LCCARV53 EQU   LCCASPN4
LCCARV52 EQU   LCCASPN4
LCCARV51 EQU   LCCASPN4
LCCARV50 EQU   LCCASPN4
LCCARV49 EQU   LCCASPN4
LCCARV48 EQU   LCCASPN4
LCCARV47 EQU   LCCASPN3
LCCARV46 EQU   LCCASPN3
LCCARV45 EQU   LCCASPN3
LCCARV44 EQU   LCCASPN3
LCCARV43 EQU   LCCASPN3
LCCARV42 EQU   LCCASPN3
LCCARV41 EQU   LCCASPN3
LCCARV40 EQU   LCCASPN3
LCCARV39 EQU   LCCASPN2
LCCARV38 EQU   LCCASPN2
LCCARV37 EQU   LCCASPN2
LCCARV36 EQU   LCCASPN2
LCCARV35 EQU   LCCASPN2
LCCARV34 EQU   LCCASPN2
LCCARV33 EQU   LCCASPN2
LCCARV32 EQU   LCCASPN2
LCCARV31 EQU   LCCASPN1
LCCARV30 EQU   LCCASPN1
LCCAMFIO EQU   LCCASPN1
LCCARSTR EQU   LCCASPN1
LCCATSPN EQU   LCCASPN1
LCCALOCK EQU   LCCASPN1
LCCASIGP EQU   LCCASPN1
LCCAPTLB EQU   LCCASPN1
LCCARV27 EQU   LCCAIHR4
LCCARV26 EQU   LCCAIHR4
LCCARV25 EQU   LCCAIHR4
LCCARV24 EQU   LCCAIHR4
LCCARV23 EQU   LCCAIHR4
LCCARV22 EQU   LCCAIHR4
LCCARV21 EQU   LCCAIHR4
LCCARV20 EQU   LCCAIHR4
LCCARV19 EQU   LCCAIHR3
LCCARV18 EQU   LCCAIHR3
LCCARV17 EQU   LCCAIHR3
LCCARV16 EQU   LCCAIHR3
LCCARV15 EQU   LCCAIHR3
LCCARV14 EQU   LCCAIHR3
LCCARV13 EQU   LCCAIHR3
LCCARV12 EQU   LCCAIHR3
LCCARV11 EQU   LCCAIHR2
LCCARV10 EQU   LCCAIHR2
LCCARV09 EQU   LCCAIHR2
LCCARV08 EQU   LCCAIHR2
LCCARV07 EQU   LCCAIHR2
LCCARV06 EQU   LCCAIHR2
LCCARV05 EQU   LCCAIHR2
LCCARV04 EQU   LCCAIHR2
LCCARV03 EQU   LCCAIHR1
LCCARV02 EQU   LCCAIHR1
LCCARV01 EQU   LCCAIHR1
LCCAPPIE EQU   LCCAIHR1
LCCAXRC2 EQU   LCCAIHR1
LCCAXRC1 EQU   LCCAIHR1
LCCAIOPS EQU   LCCA+512
LCCAGPGR EQU   LCCA+448
LCCAR133 EQU   LCCA+444
LCCAR132 EQU   LCCA+440
LCCAR131 EQU   LCCA+436
LCCAR130 EQU   LCCA+432
LCCAR129 EQU   LCCA+428
LCCAR128 EQU   LCCA+424
LCCAR127 EQU   LCCA+420
LCCAR126 EQU   LCCA+416
LCCARSGR EQU   LCCA+352
LCCAXGR3 EQU   LCCA+288
LCCAXGR2 EQU   LCCA+224
LCCAXGR1 EQU   LCCA+160
LCCACR0  EQU   LCCA+156
LCCAMCR1 EQU   LCCA+152
LCCAPVAD EQU   LCCA+148
LCCAPINT EQU   LCCA+144
LCCAPPSW EQU   LCCA+136
LCCAPGR2 EQU   LCCA+72
LCCAPGR1 EQU   LCCA+8
LCCARV77 EQU   LCCA+6
LCCACPUA EQU   LCCA+4
LCCALCCA EQU   LCCA
LCCAT00P EQU   LCCAVT
ASXBEND  EQU   ASXB+232
ASXBRV25 EQU   ASXB+228
ASXBRV24 EQU   ASXB+224
ASXBPT0E EQU   ASXB+220
ASXBCRB4 EQU   ASXBCASW+3
ASXBCRB3 EQU   ASXBCASW+2
ASXBCRB2 EQU   ASXBCASW+1
ASXBCR06 EQU   ASXBCRB1
ASXBCR05 EQU   ASXBCRB1
ASXBCR04 EQU   ASXBCRB1
ASXBCR03 EQU   ASXBCRB1
ASXBCR02 EQU   ASXBCRB1
ASXBCR01 EQU   ASXBCRB1
ASXBTFD  EQU   ASXBCRB1
ASXBPIP  EQU   ASXBCRB1
ASXBCTDC EQU   ASXB+212
ASXBTDCB EQU   ASXB+208
ASXBRV19 EQU   ASXB+204
ASXBSENV EQU   ASXBSECR+1
ASXBRV34 EQU   ASCBSFLG
ASXBRV33 EQU   ASCBSFLG
ASXBRV32 EQU   ASCBSFLG
ASXBRV31 EQU   ASCBSFLG
ASXBRV30 EQU   ASCBSFLG
ASXBRV29 EQU   ASCBSFLG
ASXBRV28 EQU   ASCBSFLG
ASXBRV27 EQU   ASCBSFLG
ASXBUSER EQU   ASXB+192
ASXBLSRB EQU   ASXBAEQ+20
ASXBFSRB EQU   ASXBAEQ+16
ASXBLRQE EQU   ASXBAEQ+12
ASXBFRQE EQU   ASXBAEQ+8
ASXBLIQE EQU   ASXBAEQ+4
ASXBFIQE EQU   ASXBAEQ
ASXBETSK EQU   ASXB+164
ASXBSIRB EQU   ASXB+160
ASXBPSWD EQU   ASXB+152
ASXBPRG  EQU   ASXB+136
ASXBRV26 EQU   ASXB+132
ASXBOUSB EQU   ASXB+128
ASXBDDR  EQU   ASXB+124
ASXBRCTD EQU   ASXB+120
ASXBRSMD EQU   ASXB+116
ASXBSPSA EQU   ASXB+112
ASXBFRWA EQU   ASXB+108
ASXBFLSA EQU   ASXB+36
ASXBRV15 EQU   ASXB+28
ASXBRV14 EQU   ASXB+24
ASXBLWA  EQU   ASXB+20
ASXBMPST EQU   ASXB+16
ASXBRS00 EQU   ASXB+14
ASXBTCBS EQU   ASXB+12
ASXBASXB EQU   ASXB
ASXBEGIN EQU   ASXB
ASCBEND  EQU   ASCB+208
ASCBSRBT EQU   ASCB+200
ASCBSWTL EQU   ASCB+196
ASCBRS14 EQU   ASCB+195
ASCBSMCT EQU   ASCB+194
ASCBRS12 EQU   ASCB+192
ASCBPCTT EQU   ASCB+188
ASCBVGTT EQU   ASCB+184
ASCBRV43 EQU   ASCBSRQ4
ASCBRV42 EQU   ASCBSRQ4
ASCBRV41 EQU   ASCBSRQ4
ASCBRV40 EQU   ASCBSRQ4
ASCBRV39 EQU   ASCBSRQ4
ASCBRV38 EQU   ASCBSRQ4
ASCBRV37 EQU   ASCBSRQ4
ASCBRV36 EQU   ASCBSRQ4
ASCBRV35 EQU   ASCBSRQ3
ASCBRV34 EQU   ASCBSRQ3
ASCBRV33 EQU   ASCBSRQ3
ASCBRV32 EQU   ASCBSRQ3
ASCBRV31 EQU   ASCBSRQ3
ASCBRV30 EQU   ASCBSRQ3
ASCBRV29 EQU   ASCBSRQ3
ASCBRV28 EQU   ASCBSRQ3
ASCBRV27 EQU   ASCBSRQ2
ASCBRV26 EQU   ASCBSRQ2
ASCBRV25 EQU   ASCBSRQ2
ASCBRV24 EQU   ASCBSRQ2
ASCBRV23 EQU   ASCBSRQ2
ASCBRV22 EQU   ASCBSRQ2
ASCBRV21 EQU   ASCBSRQ2
ASCBRV20 EQU   ASCBSRQ2
ASCBRV19 EQU   ASCBSRQ1
ASCBRV18 EQU   ASCBSRQ1
ASCBRV17 EQU   ASCBSRQ1
ASCBRV16 EQU   ASCBSRQ1
ASCBRV15 EQU   ASCBSRQ1
ASCBRV14 EQU   ASCBSRQ1
ASCBRV13 EQU   ASCBSRQ1
ASCBSTA  EQU   ASCBSRQ1
ASCBJBNS EQU   ASCB+176
ASCBJBNI EQU   ASCB+172
ASCBRTWA EQU   ASCB+164
ASCBIQEA EQU   ASCB+160
ASCBXMPQ EQU   ASCB+156
ASCBRS01 EQU   ASCB+154
ASCBFMCT EQU   ASCB+152
ASCBOUXB EQU   ASCB+148
ASCBOUCB EQU   ASCB+144
ASCBMECB EQU   ASCB+140
ASCBQECB EQU   ASCB+136
ASCBLSQH EQU   ASCBLKGP+4
ASCBLOCK EQU   ASCBLKGP
ASCBTCBS EQU   ASCB+124
ASCBNVSC EQU   ASCB+122
ASCBVSC  EQU   ASCB+120
ASCBSRBS EQU   ASCB+118
ASCBSSRB EQU   ASCB+116
ASCBRV06 EQU   ASCBFLG2
ASCBRV05 EQU   ASCBFLG2
ASCBRV04 EQU   ASCBFLG2
ASCBSNQS EQU   ASCBFLG2
ASCBS2S  EQU   ASCBFLG2
ASCBCEXT EQU   ASCBFLG2
ASCBPXMT EQU   ASCBFLG2
ASCBXMPT EQU   ASCBFLG2
ASCBRF07 EQU   ASCBDSP1
ASCBRF06 EQU   ASCBDSP1
ASCBRF05 EQU   ASCBDSP1
ASCBRF04 EQU   ASCBDSP1
ASCBRF03 EQU   ASCBDSP1
ASCBRF02 EQU   ASCBDSP1
ASCBFAIL EQU   ASCBDSP1
ASCBNOQ  EQU   ASCBDSP1
ASCBSWCT EQU   ASCB+112
ASCBNSWP EQU   ASCBFLG1
ASCBSTND EQU   ASCBFLG1
ASCBS3S  EQU   ASCBFLG1
ASCBCMSH EQU   ASCBFLG1
ASCBTOFF EQU   ASCBFLG1
ASCBRF01 EQU   ASCBRCTF
ASCBTMLW EQU   ASCBRCTF
ASCBOUT  EQU   ASCBRCTF
ASCBWAIT EQU   ASCBRCTF
ASCBRV08 EQU   ASCBRCTF
ASCBFQU  EQU   ASCBRCTF
ASCBFRS  EQU   ASCBRCTF
ASCBTMNO EQU   ASCBRCTF
ASCBAFFN EQU   ASCBFW1
ASCBDUMP EQU   ASCB+96
ASCBRV44 EQU   ASCB+92
ASCBUBET EQU   ASCB+88
ASCBECB  EQU   ASCB+84
ASCBJSTL EQU   ASCB+80
ASCBEWST EQU   ASCB+72
ASCBEJST EQU   ASCB+64
ASCBTSB  EQU   ASCB+60
ASCBCSCB EQU   ASCB+56
ASCBRSMA EQU   ASCBRSM+1
ASCBRV54 EQU   ASCBRSMF
ASCBRV53 EQU   ASCBRSMF
ASCBRV52 EQU   ASCBRSMF
ASCBRV51 EQU   ASCBRSMF
ASCBVEQR EQU   ASCBRSMF
ASCBN2LP EQU   ASCBRSMF
ASCB1LPU EQU   ASCBRSMF
ASCB2LPU EQU   ASCBRSMF
ASCBLDA  EQU   ASCB+48
ASCBSTOR EQU   ASCB+44
ASCBDP   EQU   ASCB+43
ASCBRV07 EQU   ASCB+42
ASCBIOSM EQU   ASCB+40
ASCBSEQN EQU   ASCB+38
ASCBSPL  EQU   ASCB+28
ASCBIOSP EQU   ASCB+24
ASCBSYNC EQU   ASCBSUPC+4
ASCBSVRB EQU   ASCBSUPC
ASCBCMSF EQU   ASCB+12
ASCBBWDP EQU   ASCB+8
ASCBFWDP EQU   ASCB+4
ASCBEGIN EQU   ASCB
@NM00100 EQU   SCVTSECT+180
@NM00099 EQU   SCVTSECT+176
SCVTPIQE EQU   SCVTSECT+172
@NM00098 EQU   SCVTSECT+168
SCVTPTRM EQU   SCVTSECT+164
@NM00097 EQU   SCVTSECT+160
@NM00096 EQU   SCVTSECT+156
SCVTQCBR EQU   SCVTSECT+152
@NM00095 EQU   SCVTSECT+144
SCVTTQE  EQU   SCVTSECT+140
@NM00094 EQU   SCVTSECT+136
SCVTSVCT EQU   SCVTSECT+132
@NM00093 EQU   SCVTSECT+128
@NM00092 EQU   SCVTSECT+124
SCVTRXLQ EQU   SCVTSECT+120
@NM00091 EQU   SCVTSECT+116
SCVTCTCB EQU   SCVTSECT+112
@NM00090 EQU   SCVTSECT+108
@NM00089 EQU   SCVTSECT+104
@NM00088 EQU   SCVTSECT+100
@NM00087 EQU   SCVTSECT+96
SCVTCOMM EQU   SCVTSECT+92
@NM00086 EQU   SCVTSECT+88
@NM00085 EQU   SCVTSECT+84
@NM00084 EQU   SCVTSECT+80
@NM00083 EQU   SCVTSECT+76
@NM00082 EQU   SCVTSECT+72
SCVTGMBR EQU   SCVTSECT+68
SCVTRPTR EQU   SCVTSECT+64
SCVTHSKP EQU   SCVTSECT+60
@NM00081 EQU   SCVTSECT+56
@NM00080 EQU   SCVTSECT+52
SCVTLFRM EQU   SCVTSECT+48
SCVTCDCL EQU   SCVTSECT+44
@NM00079 EQU   SCVTSECT+40
SCVTRACE EQU   SCVTSECT+36
@NM00078 EQU   SCVTSECT+32
SCVTRMBR EQU   SCVTSECT+28
@NM00077 EQU   SCVTSECT+24
@NM00076 EQU   SCVTSECT+20
@NM00075 EQU   SCVTSECT+16
@NM00074 EQU   SCVTSECT+14
SCVTBR14 EQU   SCVTSECT+12
SCVTSPET EQU   SCVTSECT+8
SCVTPGWR EQU   SCVTSECT+4
SCVTPGTM EQU   SCVTSECT
@NM00073 EQU   TCBXTNT2+32
TCBRV181 EQU   TCBRV173
TCBRV180 EQU   TCBRV173
TCBRV179 EQU   TCBRV173
TCBRV178 EQU   TCBRV173
TCBRV177 EQU   TCBRV173
TCBRV176 EQU   TCBRV173
TCBRV175 EQU   TCBRV173
TCBRV174 EQU   TCBRV173
TCBRV172 EQU   TCBRV164
TCBRV171 EQU   TCBRV164
TCBRV170 EQU   TCBRV164
TCBRV169 EQU   TCBRV164
TCBRV168 EQU   TCBRV164
TCBRV167 EQU   TCBRV164
TCBRV166 EQU   TCBRV164
TCBRV165 EQU   TCBRV164
TCBRV163 EQU   TCBRV155
TCBRV162 EQU   TCBRV155
TCBRV161 EQU   TCBRV155
TCBRV160 EQU   TCBRV155
TCBRV159 EQU   TCBRV155
TCBRV158 EQU   TCBRV155
TCBRV157 EQU   TCBRV155
TCBRV156 EQU   TCBRV155
TCBRV154 EQU   TCBRV146
TCBRV153 EQU   TCBRV146
TCBRV152 EQU   TCBRV146
TCBRV151 EQU   TCBRV146
TCBRV150 EQU   TCBRV146
TCBRV149 EQU   TCBRV146
TCBRV148 EQU   TCBRV146
TCBRV147 EQU   TCBRV146
TCBRV145 EQU   TCBXTNT2+26
TCBRV144 EQU   TCBXTNT2+24
TCBRV143 EQU   TCBXTNT2+20
TCBRV142 EQU   TCBXTNT2+16
TCBRSV49 EQU   TCBXTNT2+12
TCBEVENT EQU   TCBXTNT2+8
TCBRCMP  EQU   TCBXTNT2+5
TCBRSVAB EQU   TCBXTNT2+4
TCBGTFA  EQU   TCBGTF+1
TCBRSV47 EQU   TCBTFLG
TCBRSV46 EQU   TCBTFLG
TCBRSV45 EQU   TCBTFLG
TCBRSV44 EQU   TCBTFLG
TCBRSV43 EQU   TCBTFLG
TCBDSPIT EQU   TCBTFLG
TCBERRTN EQU   TCBTFLG
TCBASYNC EQU   TCBTFLG
@NM00072 EQU   TCB+296
TCBSVCA2 EQU   TCB+292
TCBSWASA EQU   TCB+288
TCBDBTB  EQU   TCB+284
TCBRPT   EQU   TCB+280
TCBRV141 EQU   TCBRV133
TCBRV140 EQU   TCBRV133
TCBRV139 EQU   TCBRV133
TCBRV138 EQU   TCBRV133
TCBRV137 EQU   TCBRV133
TCBRV136 EQU   TCBRV133
TCBRV135 EQU   TCBRV133
TCBRV134 EQU   TCBRV133
TCBRV132 EQU   TCBRV124
TCBRV131 EQU   TCBRV124
TCBRV130 EQU   TCBRV124
TCBRV129 EQU   TCBRV124
TCBRV128 EQU   TCBRV124
TCBRV127 EQU   TCBRV124
TCBRV126 EQU   TCBRV124
TCBRV125 EQU   TCBRV124
TCBRV123 EQU   TCBFBYT2
TCBRV122 EQU   TCBFBYT2
TCBECBNV EQU   TCBFBYT2
TCBSSSYN EQU   TCBFBYT2
TCBFDW   EQU   TCBFBYT2
TCBFMW   EQU   TCBFBYT2
TCBCNCB  EQU   TCBFBYT2
TCBRV113 EQU   TCBFBYT1
TCBEOT   EQU   TCBFBYT1
TCBRTM2  EQU   TCBFBYT1
TCBPGNLY EQU   TCBFBYT1
TCBNDIOS EQU   TCBFBYT1
TCBRV327 EQU   TCBFBYT1
TCBEOTFM EQU   TCBFBYT1
TCBAFFN  EQU   TCB+274
TCBRV326 EQU   TCB+272
TCBUKYSP EQU   TCB+268
TCBRV314 EQU   TCBESTRM
TCBRV313 EQU   TCBESTRM
TCBRV312 EQU   TCBESTRM
TCBRV311 EQU   TCBESTRM
TCBRV310 EQU   TCBESTRM
TCBRV309 EQU   TCBESTRM
TCBRV308 EQU   TCBESTRM
TCBETERM EQU   TCBESTRM
TCBSCBKY EQU   TCBESTAE
TCBSTAWA EQU   TCB+252
TCBSWA   EQU   TCB+248
TCBFOEA  EQU   TCBFOE+1
TCBRSV42 EQU   TCBFOE
TCBCCPVI EQU   TCBXSCT+2
TCBRV325 EQU   TCBXSCT+1
TCBRV324 EQU   TCBXSCT1
TCBRV323 EQU   TCBXSCT1
TCBRV322 EQU   TCBXSCT1
TCBRV321 EQU   TCBXSCT1
TCBRV320 EQU   TCBXSCT1
TCBRV319 EQU   TCBXSCT1
TCBS3A   EQU   TCBXSCT1
TCBACTIV EQU   TCBXSCT1
TCBRSV41 EQU   TCB+239
TCBTID   EQU   TCB+238
TCBRSVAA EQU   TCB+237
TCBABCUR EQU   TCB+236
TCBTMSAV EQU   TCB+232
TCBIOTIM EQU   TCB+228
TCBRTWA  EQU   TCB+224
TCBBACK  EQU   TCB+220
TCBTIRB  EQU   TCB+216
TCBAECB  EQU   TCB+212
TCBEXT2A EQU   TCBEXT2+1
TCBRSV39 EQU   TCBEXT2
TCBSTMCT EQU   TCB+207
TCBSYSCT EQU   TCB+206
TCBRSV37 EQU   TCB+205
TCBEXSVC EQU   TCBDAR
TCBDARMS EQU   TCBDAR
TCBDARWT EQU   TCBDAR
TCBDARO  EQU   TCBDAR
TCBDARMC EQU   TCBDARC
TCBDARD  EQU   TCBDAR
TCBDARS  EQU   TCBDAR
TCBDARP  EQU   TCBDAR
TCBGTOFM EQU   TCBFLGS7
TCBADMP  EQU   TCBFLGS7
TCBRSTSK EQU   TCBFLGS7
TCBSVCS  EQU   TCBFLGS7
TCBSTACK EQU   TCBFLGS7
TCBRSV34 EQU   TCBFLGS7
TCBRSV33 EQU   TCBFLGS7
TCBGPECB EQU   TCBFLGS7
TCBNTJS  EQU   TCBFLGS6
TCBAPG   EQU   TCBFLGS6
TCBMIGR  EQU   TCBFLGS6
TCBRV303 EQU   TCBFLGS6
TCBSPVLK EQU   TCBFLGS6
TCBCPU   EQU   TCBFLGS6
TCBPIE17 EQU   TCBFLGS6
TCBRV    EQU   TCBFLGS6
TCBRSV79 EQU   TCBNDSP5
TCBRSV78 EQU   TCBNDSP5
TCBRSV77 EQU   TCBNDSP5
TCBRSV76 EQU   TCBNDSP5
TCBRSV75 EQU   TCBNDSP5
TCBRSV74 EQU   TCBNDSP5
TCBRSV95 EQU   TCBNDSP5
TCBRSV94 EQU   TCBNDSP5
TCBRSV93 EQU   TCBNDSP4
TCBRSV92 EQU   TCBNDSP4
TCBRSV91 EQU   TCBNDSP4
TCBRSV90 EQU   TCBNDSP4
TCBRSV89 EQU   TCBNDSP4
TCBRSV88 EQU   TCBNDSP4
TCBRSV87 EQU   TCBNDSP4
TCBRSV86 EQU   TCBNDSP4
TCBEXT1A EQU   TCBEXT1+1
TCBRSV32 EQU   TCBEXT1
TCBEXCPD EQU   TCB+192
TCBIOBRC EQU   TCB+188
TCBDDWTC EQU   TCB+186
TCBDDEXC EQU   TCB+184
TCBJSCBB EQU   TCBJSCB+1
@NM00071 EQU   TCBRECDE
TCBREC   EQU   TCBRECDE
TCBMDIDS EQU   TCB+176
TCBNDINT EQU   TCBNDSP3
TCBRSV27 EQU   TCBNDSP3
TCBRSV26 EQU   TCBNDSP3
TCBRSV25 EQU   TCBNDSP3
TCBRSV24 EQU   TCBNDSP3
TCBSRBND EQU   TCBNDSP3
TCBRV302 EQU   TCBNDSP3
TCBLJSND EQU   TCBNDSP3
TCBABE   EQU   TCBNDSP2
TCBDSS   EQU   TCBNDSP2
TCBOWAIT EQU   TCBNDSP2
TCBIWAIT EQU   TCBNDSP2
TCBNDTS  EQU   TCBNDSP2
TCBNDSVC EQU   TCBNDSP2
TCBSTPP  EQU   TCBNDSP2
TCBABD   EQU   TCBNDSP2
TCBRSV22 EQU   TCBNDSP1
TCBPIEND EQU   TCBNDSP1
TCBTPSP  EQU   TCBNDSP1
TCBDDRND EQU   TCBNDSP1
TCBRSPND EQU   TCBNDSP1
TCBRSTND EQU   TCBNDSP1
TCBDARPN EQU   TCBNDSP1
TCBDARTN EQU   TCBNDSP1
TCBNDSP0 EQU   TCBNDSP
TCBUSER  EQU   TCB+168
TCBTCTB  EQU   TCBTCT+1
TCBRSV9C EQU   TCBTCTGF
TCBRSV9B EQU   TCBTCTGF
TCBRSV9A EQU   TCBTCTGF
TCBRSV99 EQU   TCBTCTGF
TCBRSV98 EQU   TCBTCTGF
TCBRSV97 EQU   TCBTCTGF
TCBRSV20 EQU   TCBTCTGF
TCBSMFGF EQU   TCBTCTGF
TCBSTABB EQU   TCBSTAB+1
TCBSTCUR EQU   TCBNSTAE
TCBRV301 EQU   TCBNSTAE
TCBSYNCH EQU   TCBNSTAE
TCBHALT  EQU   TCBNSTAE
TCBPPSUP EQU   TCBNSTAE
TCB33E   EQU   TCBNSTAE
TCBQUIES EQU   TCBNSTAE
TCBSTABE EQU   TCBNSTAE
TCBAQE   EQU   TCB+156
TCBPQE   EQU   TCB+152
TCBTSDP  EQU   TCB+151
TCBTSLP  EQU   TCB+150
TCBSTPCT EQU   TCB+149
TCBCPUBN EQU   TCBTSFLG
TCBDYDSP EQU   TCBTSFLG
TCBRSV18 EQU   TCBTSFLG
TCBRSV17 EQU   TCBTSFLG
TCBTIOTG EQU   TCBTSFLG
TCBATT   EQU   TCBTSFLG
TCBSTPPR EQU   TCBTSFLG
TCBRV300 EQU   TCBTSTSK
TCBECB   EQU   TCB+144
TCBIQE   EQU   TCB+140
TCBLTC   EQU   TCB+136
TCBOTC   EQU   TCB+132
TCBNTC   EQU   TCB+128
TCBJSTCA EQU   TCBJSTCB+1
TCBRSV16 EQU   TCBJSTCB
TCBTQET  EQU   TCBTME
TCBFSAB  EQU   TCBFSA+1
TCBQEL   EQU   TCBFSA
TCBGRS15 EQU   TCBGRS+60
TCBGRS14 EQU   TCBGRS+56
TCBGRS13 EQU   TCBGRS+52
TCBGRS12 EQU   TCBGRS+48
TCBGRS11 EQU   TCBGRS+44
TCBGRS10 EQU   TCBGRS+40
TCBGRS9  EQU   TCBGRS+36
TCBGRS8  EQU   TCBGRS+32
TCBGRS7  EQU   TCBGRS+28
TCBGRS6  EQU   TCBGRS+24
TCBGRS5  EQU   TCBGRS+20
TCBGRS4  EQU   TCBGRS+16
TCBGRS3  EQU   TCBGRS+12
TCBGRS2  EQU   TCBGRS+8
TCBGRS1  EQU   TCBGRS+4
TCBGRS0  EQU   TCBGRS
TCBJPQB  EQU   TCBJPQ+1
TCBRSV15 EQU   TCBPURGE
TCBRSV14 EQU   TCBPURGE
TCBRSV13 EQU   TCBPURGE
TCBRSV12 EQU   TCBPURGE
TCBRSV11 EQU   TCBPURGE
TCBRSV10 EQU   TCBPURGE
TCBRSV09 EQU   TCBPURGE
TCBJPQF  EQU   TCBPURGE
TCBJLB   EQU   TCB+40
TCBLLS   EQU   TCB+36
TCBDSP   EQU   TCB+35
TCBLMP   EQU   TCB+34
TCBPNDSP EQU   TCBFLGS5
TCBFCD1  EQU   TCBFLGS5
TCBSTP   EQU   TCBFLGS5
TCBSYS   EQU   TCBFLGS5
TCBANDSP EQU   TCBFLGS5
TCBPAGE  EQU   TCBFLGS5
TCBUXNDF EQU   TCBABWF
TCBONDSP EQU   TCBFLGS4
TCBMPCND EQU   TCBFLGS4
TCBMPCVQ EQU   TCBFLGS4
TCBUXNDV EQU   TCBFLGS4
TCBHNDSP EQU   TCBFLGS4
TCBRQENA EQU   TCBFLGS4
TCBSER   EQU   TCBFLGS4
TCBNDUMP EQU   TCBFLGS4
TCBDWSTA EQU   TCBFLGS3
TCBRSV08 EQU   TCBFLGS3
TCBRSV07 EQU   TCBFLGS3
TCBRSV06 EQU   TCBFLGS3
TCBADINP EQU   TCBFLGS3
TCBFSM   EQU   TCBFLGS3
TCBFTS   EQU   TCBFLGS2
TCBFETXR EQU   TCBFLGS2
TCBFDSOP EQU   TCBFLGS2
TCBFJMC  EQU   TCBFLGS2
TCBFSMC  EQU   TCBFLGS2
TCBFABOP EQU   TCBFLGS2
TCBFSTI  EQU   TCBFLGS2
TCBFOINP EQU   TCBFLGS2
TCBFS    EQU   TCBFLGS1
TCBFT    EQU   TCBFLGS1
TCBPDUMP EQU   TCBFLGS1
TCBFERA  EQU   TCBFLGS1
TCBFE    EQU   TCBFLGS1
TCBFA    EQU   TCBFLGS1
TCBZERO  EQU   TCBPKF
TCBFLAG  EQU   TCBPKF
TCBMSSB  EQU   TCBMSS+1
TCBRSV03 EQU   TCBMSS
TCBTRNB  EQU   TCBTRN+1
TCBRSV02 EQU   TCBABF
TCBOLTEP EQU   TCBABF
TCBTCP   EQU   TCBABF
TCBTCPP  EQU   TCBABF
TCBRSV01 EQU   TCBABF
TCBGRPH  EQU   TCBABF
TCBNOCHK EQU   TCBABF
TCBMOD91 EQU   TCBABF
TCBCMPC  EQU   TCBCMP+1
TCBRV318 EQU   TCBCMSG
TCBRV317 EQU   TCBCIND
TCBRV316 EQU   TCBCWTO
TCBCASID EQU   TCBCDBL
TCBNOCC  EQU   TCBSTCC
TCBDMPO  EQU   TCBCPP
TCBCSTEP EQU   TCBCMPF
TCBCREQ  EQU   TCBCMPF
TCBTIO   EQU   TCB+12
TCBDEB   EQU   TCB+8
TCBPIEA  EQU   TCBPIE+1
TCBPM    EQU   TCBPMASK
@NM00070 EQU   TCBPMASK
TCBFRS6  EQU   TCBFRS+24
TCBFRS4  EQU   TCBFRS+16
TCBFRS2  EQU   TCBFRS+8
TCBFRS0  EQU   TCBFRS
SVRBEND  EQU   RBSECT+192
RBFEPARM EQU   RBSECT+168
SIRBEND  EQU   RBSECT+168
RBRSV158 EQU   RBRSV150
RBRSV157 EQU   RBRSV150
RBRSV156 EQU   RBRSV150
RBRSV155 EQU   RBRSV150
RBRSV154 EQU   RBRSV150
RBRSV153 EQU   RBRSV150
RBRSV152 EQU   RBRSV150
RBRSV151 EQU   RBRSV150
RBRSV149 EQU   RBSECT+166
RBRSV148 EQU   RBSECT+164
RBRSV169 EQU   RBSDATA+3
RBSID    EQU   RBSDATA+2
RBSPKEY  EQU   RBSDATA+1
RBRSV168 EQU   RBSFLG3
RBSTERMO EQU   RBSFLG3
RBSBRNTR EQU   RBSFLG3
RBSPRNTR EQU   RBSFLG3
RBSCNCEL EQU   RBSFLG3
RBSRECRD EQU   RBSFLG3
RBSTERMI EQU   RBSFLG3
RBRSV167 EQU   RBSFLG3
RBSOWNRA EQU   RBSOWNR+1
RBSSUPER EQU   RBSFLGS2
RBSKEY0  EQU   RBSFLGS2
RBRSV166 EQU   RBSFLGS2
RBRSV165 EQU   RBSFLGS2
RBSINUSE EQU   RBSFLGS2
RBRSV164 EQU   RBSFLGS2
RBSXCTL2 EQU   RBSFLGS2
RBRSV163 EQU   RBSFLGS2
RBSPARMA EQU   RBSPARM+1
RBSHALT  EQU   RBSIOPRC
RBSNOIOP EQU   RBSIOPRC
RBSASYNC EQU   RBSFLGS1
RBRSV162 EQU   RBSFLGS1
RBSESTAE EQU   RBSFLGS1
RBSDUMMY EQU   RBSFLGS1
RBSSTAR  EQU   RBSFLGS1
RBSSTAI  EQU   RBSFLGS1
RBSEXIT  EQU   RBSCBB+4
RBSCHAIN EQU   RBSCBB
TIRBEND  EQU   @NM00068+8
PRBEND   EQU   @NM00068+8
RBRSV146 EQU   RBRSV138
RBRSV145 EQU   RBRSV138
RBRSV144 EQU   RBRSV138
RBRSV143 EQU   RBRSV138
RBRSV142 EQU   RBRSV138
RBRSV141 EQU   RBRSV138
RBRSV140 EQU   RBRSV138
RBRSV139 EQU   RBRSV138
RBRSV137 EQU   @NM00068+6
RBRSV136 EQU   @NM00068+4
RBRSV135 EQU   @NM00068
@NM00067 EQU   RBSECT+32
@NM00066 EQU   @NM00064+1
RBSCF    EQU   @NM00065
RBPGMQ1  EQU   RBPGMQ+1
@NM00063 EQU   RBPGMQ
@NM00062 EQU   RBSECT+16
@NM00061 EQU   @NM00057
@NM00060 EQU   @NM00057
RBIQETP  EQU   @NM00057
RBUSIQE  EQU   RBETXR
RBATTN   EQU   @NM00057
@NM00059 EQU   @NM00057
@NM00058 EQU   @NM00057
RBPMSVRB EQU   @NM00055
RBATNXIT EQU   @NM00055
@NM00056 EQU   @NM00055
RBWAITP  EQU   @NM00055
RBFNSVRB EQU   RBTRSVRB
RBFTP    EQU   @NM00055
RBSIZE   EQU   RBSECT+8
RBABOPSW EQU   RBSECT+4
RBPPSAV1 EQU   RBPPSAV+1
@NM00053 EQU   RBPPSAV
RBPRFXND EQU   RBPREFIX+64
RBRSV004 EQU   RBPREFIX+57
RBSSSYN  EQU   RBFLAGS1
RBSCB    EQU   RBFLAGS1
RBLONGWT EQU   RBFLAGS1
RBASIR   EQU   RBFLAGS1
RBRSV159 EQU   RBFLAGS1
RBABEND  EQU   RBFLAGS1
RBXWAIT  EQU   RBFLAGS1
RBSLOCK  EQU   RBFLAGS1
RBRSV160 EQU   RBRTICIL
RBRSV062 EQU   RBRSV054
RBRSV061 EQU   RBRSV054
RBRSV060 EQU   RBRSV054
RBRSV059 EQU   RBRSV054
RBRSV058 EQU   RBRSV054
RBRSV057 EQU   RBRSV054
RBRSV056 EQU   RBRSV054
RBRSV055 EQU   RBRSV054
RBRSV053 EQU   RBPREFIX+38
RBRSV052 EQU   RBPREFIX+36
RBRSV051 EQU   RBPREFIX+32
RBPRFXST EQU   RBPREFIX+32
RBRSV050 EQU   RBPREFIX+28
RBRSV049 EQU   RBRSV041
RBRSV048 EQU   RBRSV041
RBRSV047 EQU   RBRSV041
RBRSV046 EQU   RBRSV041
RBRSV045 EQU   RBRSV041
RBRSV044 EQU   RBRSV041
RBRSV043 EQU   RBRSV041
RBRSV042 EQU   RBRSV041
RBRSV040 EQU   RBPREFIX+26
RBRSV039 EQU   RBPREFIX+24
RBRSV038 EQU   RBPREFIX+20
RBRSV037 EQU   RBPREFIX+16
RBRSV036 EQU   RBRSV028
RBRSV035 EQU   RBRSV028
RBRSV034 EQU   RBRSV028
RBRSV033 EQU   RBRSV028
RBRSV032 EQU   RBRSV028
RBRSV031 EQU   RBRSV028
RBRSV030 EQU   RBRSV028
RBRSV029 EQU   RBRSV028
RBRSV027 EQU   RBRSV019
RBRSV026 EQU   RBRSV019
RBRSV025 EQU   RBRSV019
RBRSV024 EQU   RBRSV019
RBRSV023 EQU   RBRSV019
RBRSV022 EQU   RBRSV019
RBRSV021 EQU   RBRSV019
RBRSV020 EQU   RBRSV019
RBRSV018 EQU   RBPREFIX+13
RBRSV017 EQU   RBPREFIX+12
RBSRV016 EQU   RBPREFIX+11
RBRSV015 EQU   RBPREFIX+10
RBRSV014 EQU   RBPREFIX+8
RBRSV013 EQU   RBPREFIX+4
RBRSV012 EQU   RBPREFIX
RBEXSAVE EQU   XRBESA
XRBREG15 EQU   RBGRS15
XRBREG14 EQU   RBGRS14
XRBREG13 EQU   RBGRS13
XRBREG12 EQU   RBGRS12
XRBREG11 EQU   RBGRS11
XRBREG10 EQU   RBGRS10
XRBREG9  EQU   RBGRS9
XRBREG8  EQU   RBGRS8
XRBREG7  EQU   RBGRS7
XRBREG6  EQU   RBGRS6
XRBREG5  EQU   RBGRS5
XRBREG4  EQU   RBGRS4
XRBREG3  EQU   RBGRS3
XRBREG2  EQU   RBGRS2
XRBREG1  EQU   RBGRS1
XRBREG0  EQU   RBGRS0
XRBLNKA  EQU   RBLINKB
XRBWT    EQU   RBWCF
@NM00052 EQU   RBBASIC+24
RBOPSWPS EQU   RBOPSWB2
@NM00051 EQU   RBOPSWB2
@NM00050 EQU   XRBPSW
@NM00049 EQU   RBBASIC+12
XRBWAIT  EQU   RBECBWT
XRBFRRB  EQU   RBFDYN
@NM00048 EQU   XSTAB2
XRBACTV  EQU   RBFACTV
XRBTCBP  EQU   RBTCBNXT
@NM00047 EQU   XSTAB1
XRBCKPT  EQU   RBFTCKPT
@NM00046 EQU   XSTAB1
@NM00045 EQU   RBBASIC+8
@NM00044 EQU   RBEXRTNM+1
RBTMIND3 EQU   RBTMFLD
RBTMIND2 EQU   RBTMFLD
RBTMCMP  EQU   RBTMFLD
RBWLIM   EQU   RBTMFLD
RBRSV005 EQU   RBTMFLD
RBTMTOD  EQU   RBTMFLD
RBTMQUE  EQU   RBTMFLD
@NM00043 EQU   RBPRFX
RTCTISVC EQU   RTCTSDO4
RTCTSDOV EQU   RTCTSDMG
@NM00042 EQU   RTCTSDO4
@NM00041 EQU   RTCTSDO3
RTCTSDPH EQU   RTCTSDO3
RTCTSDPG EQU   RTCTSDO3
@NM00040 EQU   RTCTSDO2
RTCTSDPD EQU   RTCTSDO2
RTCTSDPC EQU   RTCTSDO2
RTCTSDPB EQU   RTCTSDO2
RTCTSDPA EQU   RTCTSDO2
RTCTSDP9 EQU   RTCTSDO2
RTCTSDP8 EQU   RTCTSDO2
RTCTSDP7 EQU   RTCTSDO1
RTCTSDP6 EQU   RTCTSDO1
RTCTSDP5 EQU   RTCTSDO1
RTCTSDP4 EQU   RTCTSDO1
RTCTSDP3 EQU   RTCTSDO1
RTCTSDP2 EQU   RTCTSDO1
RTCTSDP1 EQU   RTCTSDO1
RTCTSDP0 EQU   RTCTSDO1
RTCTISYM EQU   RTCTSD04
RTCTSMOV EQU   RTCTSMMG
@NM00039 EQU   RTCTSD04
RTCTSD03 EQU   RTCTMSYO+2
RTCTSD02 EQU   RTCTMSYO+1
RTCTSDS7 EQU   RTCTSD01
RTCTSDS6 EQU   RTCTSD01
RTCTSDS5 EQU   RTCTSD01
RTCTSDS4 EQU   RTCTSD01
RTCTSDS3 EQU   RTCTSD01
RTCTSDS2 EQU   RTCTSD01
RTCTSDS1 EQU   RTCTSD01
RTCTSDS0 EQU   RTCTSD01
RTCTISYU EQU   RTCTSUO4
RTCTSUOV EQU   RTCTSUMG
@NM00038 EQU   RTCTSUO4
RTCTSYDF EQU   RTCTSUO3
RTCTSYDE EQU   RTCTSUO3
RTCTSYDD EQU   RTCTSUO3
RTCTSYDC EQU   RTCTSUO3
RTCTSYDB EQU   RTCTSUO3
RTCTSYDA EQU   RTCTSUO3
RTCTSYD9 EQU   RTCTSUO3
RTCTSYD8 EQU   RTCTSUO3
@NM00037 EQU   RTCTSUO2
RTCTSYDH EQU   RTCTSUO2
RTCTSYDG EQU   RTCTSUO2
RTCTSYD7 EQU   RTCTSUO1
RTCTSYD6 EQU   RTCTSUO1
RTCTSYD5 EQU   RTCTSUO1
RTCTSYD4 EQU   RTCTSUO1
RTCTSYD3 EQU   RTCTSUO1
RTCTSYD2 EQU   RTCTSUO1
RTCTSYD1 EQU   RTCTSUO1
RTCTSYD0 EQU   RTCTSUO1
RTCTISAB EQU   RTCTSAO4
RTCTSAOV EQU   RTCTSAMG
@NM00036 EQU   RTCTSAO4
RTCTSADF EQU   RTCTSAO3
RTCTSADE EQU   RTCTSAO3
RTCTSADD EQU   RTCTSAO3
RTCTSADC EQU   RTCTSAO3
RTCTSADB EQU   RTCTSAO3
RTCTSADA EQU   RTCTSAO3
RTCTSAD9 EQU   RTCTSAO3
RTCTSAD8 EQU   RTCTSAO3
@NM00035 EQU   RTCTSAO2
RTCTSADH EQU   RTCTSAO2
RTCTSADG EQU   RTCTSAO2
RTCTSAD7 EQU   RTCTSAO1
RTCTSAD6 EQU   RTCTSAO1
RTCTSAD5 EQU   RTCTSAO1
RTCTSAD4 EQU   RTCTSAO1
RTCTSAD3 EQU   RTCTSAO1
RTCTSAD2 EQU   RTCTSAO1
RTCTSAD1 EQU   RTCTSAO1
RTCTSAD0 EQU   RTCTSAO1
RTCTZZZ5 EQU   RTCT+340
RTCTZZZ4 EQU   RTCT+336
RTCTMRMQ EQU   RTCT+332
RTCTSDF5 EQU   RTCTSDF3+3
RTCTSDDO EQU   RTCTSDF4
RTCTSDEN EQU   RTCTSDF4
RTCTSDEQ EQU   RTCTSDF4
RTCTSDTR EQU   RTCTSDF4
RTCTSDRM EQU   RTCTSDF4
RTCTSDAN EQU   RTCTSDF4
RTCTSDNC EQU   RTCTSDF4
RTCTSDSS EQU   RTCTSDF4
RTCTSDAS EQU   RTCTSDF3
RTCTZZZ3 EQU   RTCT+266
RTCTSDFX EQU   RTCTSDF2
RTCTSDRW EQU   RTCTSDF2
RTCTSDSL EQU   RTCTSDF2
RTCTSDWF EQU   RTCTSDF2
RTCTSDLA EQU   RTCTSDF2
RTCTSDDI EQU   RTCTSDF2
RTCTSDTQ EQU   RTCTSDF2
RTCTSDMR EQU   RTCTSDF2
RTCTSDSC EQU   RTCTSDF1
RTCTSDRS EQU   RTCTSDF1
RTCTSDSD EQU   RTCTSDF1
RTCTSDEP EQU   RTCTSDF1
RTCTSDMA EQU   RTCTSDF1
RTCTSDSH EQU   RTCTSDF1
RTCTSDND EQU   RTCTSDF1
RTCTSDNO EQU   RTCTSDF1
RTCTZZZ2 EQU   RTCT+257
RTCTSDPR EQU   RTCTSDI+2
RTCTINDX EQU   RTCTSDI+1
RTCTSDNA EQU   RTCTSDI
@NM00034 EQU   RTCTASO2
RTCTASNQ EQU   RTCTASO2
RTCTASNA EQU   RTCTASO2
RTCTASNS EQU   RTCTASO2
RTCTASSU EQU   RTCTASO2
RTCTASSW EQU   RTCTASO2
RTCTASCS EQU   RTCTASO2
RTCTASTR EQU   RTCTASO1
RTCTASLP EQU   RTCTASO1
RTCTASRG EQU   RTCTASO1
RTCTASLS EQU   RTCTASO1
RTCTASSQ EQU   RTCTASO1
RTCTASNU EQU   RTCTASO1
RTCTASPS EQU   RTCTASO1
RTCTASAL EQU   RTCTASO1
RTCTSDO  EQU   RTCTOPT+12
RTCTSYO  EQU   RTCTOPT+8
RTCTSUO  EQU   RTCTOPT+4
RTCTSAO  EQU   RTCTOPT
RTCTXXX2 EQU   RTCT+234
RTCTETIM EQU   RTCTERID+6
RTCTEASD EQU   RTCTERID+4
RTCTECPU EQU   RTCTERID+2
RTCTESEQ EQU   RTCTERID
RTCTSDWK EQU   RTCT+220
RTCTTDCB EQU   RTCT+184
RTCTSDSW EQU   RTCT+180
RTCTSEQ# EQU   RTCT+178
RTCTXXX1 EQU   RTCT+177
@NM00033 EQU   RTCTRFLG
RTCTRSTF EQU   RTCTRFLG
RTCTRPER EQU   RTCTRFLG
RTCTRTER EQU   RTCTRFLG
RTCTTEST EQU   RTCT+172
RTCTFMT  EQU   RTCT+160
RTCTSDIP EQU   RTCTSDPL
RTCTDEV  EQU   RTCTSDDS+8
RTCTDCB  EQU   RTCTSDDS+4
RTCTDTND EQU   RTCTFLG
@NM00032 EQU   RTCTFLG
RTCTDETP EQU   RTCTFLG
RTCTDSUS EQU   RTCTFLG
RTCTDSST EQU   RTCTFLG
RTCTDSNM EQU   RTCTSDDS
RTCTRCB  EQU   RTCT+32
RTCTRECB EQU   RTCT+28
RTCTMECB EQU   RTCT+20
RTCTSDID EQU   RTCT+18
RTCTYYY1 EQU   RTCT+16
RTCTSY04 EQU   RTCTSYD+3
RTCTSY03 EQU   RTCTSYD+2
RTCTSY02 EQU   RTCTSYD+1
RTCTSYM7 EQU   RTCTSY01
RTCTSYM6 EQU   RTCTSY01
RTCTSYM5 EQU   RTCTSY01
RTCTSYM4 EQU   RTCTSY01
RTCTSYM3 EQU   RTCTSY01
RTCTSYM2 EQU   RTCTSY01
RTCTSYM1 EQU   RTCTSY01
RTCTSYM0 EQU   RTCTSY01
RTCTSUP4 EQU   RTCTSUP+3
RTCTSUDF EQU   RTCTSUP3
RTCTSUDE EQU   RTCTSUP3
RTCTSUDD EQU   RTCTSUP3
RTCTSUDC EQU   RTCTSUP3
RTCTSUDB EQU   RTCTSUP3
RTCTSUDA EQU   RTCTSUP3
RTCTSUD9 EQU   RTCTSUP3
RTCTSUD8 EQU   RTCTSUP3
@NM00031 EQU   RTCTSUP2
RTCTSUDH EQU   RTCTSUP2
RTCTSUDG EQU   RTCTSUP2
RTCTSUD7 EQU   RTCTSUP1
RTCTSUD6 EQU   RTCTSUP1
RTCTSUD5 EQU   RTCTSUP1
RTCTSUD4 EQU   RTCTSUP1
RTCTSUD3 EQU   RTCTSUP1
RTCTSUD2 EQU   RTCTSUP1
RTCTSUD1 EQU   RTCTSUP1
RTCTSUD0 EQU   RTCTSUP1
RTCTSAP4 EQU   RTCTSAP+3
RTCTSABF EQU   RTCTSAP3
RTCTSABE EQU   RTCTSAP3
RTCTSABD EQU   RTCTSAP3
RTCTSABC EQU   RTCTSAP3
RTCTSABB EQU   RTCTSAP3
RTCTSABA EQU   RTCTSAP3
RTCTSAB9 EQU   RTCTSAP3
RTCTSAB8 EQU   RTCTSAP3
@NM00030 EQU   RTCTSAP2
RTCTSABH EQU   RTCTSAP2
RTCTSABG EQU   RTCTSAP2
RTCTSAB7 EQU   RTCTSAP1
RTCTSAB6 EQU   RTCTSAP1
RTCTSAB5 EQU   RTCTSAP1
RTCTSAB4 EQU   RTCTSAP1
RTCTSAB3 EQU   RTCTSAP1
RTCTSAB2 EQU   RTCTSAP1
RTCTSAB1 EQU   RTCTSAP1
RTCTSAB0 EQU   RTCTSAP1
RTCTNAME EQU   RTCT
@NM00023 EQU   EEDDES+2
@NM00022 EQU   EEDFLAGS
RTMBXABT EQU   RTMBRTAB+44
RTMBACR  EQU   RTMBRTAB+40
RTMBPROG EQU   RTMBRTAB+36
RTMBMEMT EQU   RTMBRTAB+32
RTMBCABT EQU   RTMBRTAB+28
RTMBPGIO EQU   RTMBRTAB+24
RTMBSVC  EQU   RTMBRTAB+20
RTMBMACH EQU   RTMBRTAB+16
RTMBREST EQU   RTMBRTAB+12
RTMBDAT  EQU   RTMBRTAB+8
RTMBPAD2 EQU   RTMBTERM+6
RTMBBRAN EQU   RTMBTERM+2
RTMBBALR EQU   RTMBTERM
RT1TRETY EQU   RT1TACQR
RT1TLLCK EQU   RT1TACQR
RT1TDISP EQU   RT1TACQR
FROMADDR EQU   LISTPAIR
@NM00019 EQU   PSWILCIC
@NM00018 EQU   PSWMODE+3
PSWSIGNF EQU   PSWCCPMK
PSWWXPON EQU   PSWCCPMK
PSWDECIM EQU   PSWCCPMK
PSWFIXPT EQU   PSWCCPMK
PSWCONCD EQU   PSWCCPMK
@NM00017 EQU   PSWCCPMK
PSWPRBLM EQU   PSWKYMWP
PSWWAIT  EQU   PSWKYMWP
PSWMCHCK EQU   PSWKYMWP
PSWKEY   EQU   PSWKYMWP
PSWDAT   EQU   PSWIMASK
PSWEAM   EQU   PSWIMASK
@NM00016 EQU   PSWIMASK
PSWPER   EQU   PSWIMASK
@NM00015 EQU   PSWIMASK
ERREG15  EQU   ERREGS+60
ERREG14  EQU   ERREGS+56
ERREG13  EQU   ERREGS+52
ERREG12  EQU   ERREGS+48
ERREG11  EQU   ERREGS+44
ERREG10  EQU   ERREGS+40
ERREG9   EQU   ERREGS+36
ERREG8   EQU   ERREGS+32
ERREG7   EQU   ERREGS+28
ERREG6   EQU   ERREGS+24
ERREG5   EQU   ERREGS+20
ERREG4   EQU   ERREGS+16
ERREG3   EQU   ERREGS+12
ERREG2   EQU   ERREGS+8
@NM00130 EQU   PSA+3668
PSASTAK  EQU   PSA+3072
@NM00129 EQU   PSA+1048
PSAUSEND EQU   PSA+1048
PSARV062 EQU   PSA+1044
PSACDAL  EQU   PSA+1040
PSAWTCOD EQU   PSA+1036
PSAATCVT EQU   PSA+1032
PSAPCPSW EQU   PSA+1024
PSAPIR2  EQU   PSA+1020
PSARV059 EQU   PSA+1018
PSASVC13 EQU   PSA+1016
PSALSFCC EQU   PSA+1012
PSASFACC EQU   PSA+1008
PSASTOP  EQU   PSA+992
PSASTART EQU   PSA+976
PSARSPSW EQU   PSA+968
PSASRPSW EQU   PSA+960
PSARV045 EQU   PSA+892
PSARV044 EQU   PSA+888
PSARV043 EQU   PSA+884
PSARV042 EQU   PSA+880
PSARV041 EQU   PSA+876
PSARV040 EQU   PSA+872
PSARV025 EQU   PSA+868
PSADSSED EQU   PSA+868
PSADSSPR EQU   PSA+864
PSADSSFW EQU   PSA+860
PSADSS14 EQU   PSA+856
PSADSSPP EQU   PSA+848
PSADSSRP EQU   PSA+840
PSADSS05 EQU   PSADSSF4
PSADSS10 EQU   PSADSSF4
PSADSSVE EQU   PSADSSF4
PSADSSDE EQU   PSADSSF4
PSADSSC0 EQU   PSADSSF4
PSADSSIE EQU   PSADSSF4
PSADSS12 EQU   PSADSSF4
PSADSSRC EQU   PSADSSF4
PSARV057 EQU   PSADSSF3
PSARV056 EQU   PSADSSF3
PSARV055 EQU   PSADSSF3
PSADSSMC EQU   PSADSSF3
PSADSSRW EQU   PSADSSF3
PSADSSNM EQU   PSADSSF3
PSADSSES EQU   PSADSSF3
PSADSSGP EQU   PSADSSF3
PSADSSF2 EQU   PSADSSFL+1
PSADSSPI EQU   PSADSSF1
PSADSSOI EQU   PSADSSF1
PSADSSSP EQU   PSADSSF1
PSADSSTP EQU   PSADSSF1
PSADSSDW EQU   PSADSSF1
PSADSSDD EQU   PSADSSF1
PSADSSDM EQU   PSADSSF1
PSADSSMV EQU   PSADSSF1
PSADSSTS EQU   PSA+816
PSADSSWK EQU   PSA+812
PSADSSR3 EQU   PSA+808
PSADSSR2 EQU   PSA+804
PSADSSRS EQU   PSA+800
PSASTOR  EQU   PSA+796
PSACPUSA EQU   PSA+794
PSAVSTAP EQU   PSA+792
PSAWKVAP EQU   PSA+788
PSAWKRAP EQU   PSA+784
PSAMCHIC EQU   PSA+783
PSARV061 EQU   PSA+782
PSASYMSK EQU   PSA+781
PSAMCHFL EQU   PSA+780
PSACR0   EQU   PSA+776
PSAPSWSV EQU   PSA+768
PSALITA  EQU   PSA+764
PSACLHS  EQU   PSAHLHI
PSALKR15 EQU   PSALKSA+60
PSALKR14 EQU   PSALKSA+56
PSALKR13 EQU   PSALKSA+52
PSALKR12 EQU   PSALKSA+48
PSALKR11 EQU   PSALKSA+44
PSALKR10 EQU   PSALKSA+40
PSALKR9  EQU   PSALKSA+36
PSALKR8  EQU   PSALKSA+32
PSALKR7  EQU   PSALKSA+28
PSALKR6  EQU   PSALKSA+24
PSALKR5  EQU   PSALKSA+20
PSALKR4  EQU   PSALKSA+16
PSALKR3  EQU   PSALKSA+12
PSALKR2  EQU   PSALKSA+8
PSALKR1  EQU   PSALKSA+4
PSALKR0  EQU   PSALKSA
PSARV023 EQU   PSACLHT+52
PSALOCAL EQU   PSACLHT+48
PSACMSL  EQU   PSACLHT+44
PSAOPTL  EQU   PSACLHT+40
PSATPACL EQU   PSACLHT+36
PSATPDNL EQU   PSACLHT+32
PSATPNCL EQU   PSACLHT+28
PSAIOSLL EQU   PSACLHT+24
PSAIOSUL EQU   PSACLHT+20
PSAIOSCL EQU   PSACLHT+16
PSAIOSSL EQU   PSACLHT+12
PSASALCL EQU   PSACLHT+8
PSAASML  EQU   PSACLHT+4
PSADISPL EQU   PSACLHT
PSASRSA  EQU   PSA+636
PSARV050 EQU   PSA+634
PSADSSGO EQU   PSA+633
PSARECUR EQU   PSA+632
PSAHLHIS EQU   PSA+628
PSAIPCSA EQU   PSA+624
@NM00128 EQU   PSA+621
PSAIPCDM EQU   PSA+620
PSAIPCD  EQU   PSA+616
@NM00127 EQU   PSA+613
PSAIPCRM EQU   PSA+612
PSAIPCR  EQU   PSA+608
PSAMCHEX EQU   PSA+600
PSAMPSW  EQU   PSA+592
PSAEXPS2 EQU   PSA+584
PSAEXPS1 EQU   PSA+576
PSAPIREG EQU   PSA+572
PSARSREG EQU   PSA+568
PSAGPREG EQU   PSA+556
PSARV022 EQU   PSASUP4
PSARV021 EQU   PSASUP4
PSARV020 EQU   PSASUP4
PSARV019 EQU   PSASUP4
PSARV018 EQU   PSASUP4
PSARV017 EQU   PSASUP4
PSARV016 EQU   PSASUP4
PSARV015 EQU   PSASUP4
PSARV014 EQU   PSASUP3
PSAULCMS EQU   PSASUP3
PSARV012 EQU   PSASUP3
PSAESTA  EQU   PSASUP3
PSASPR   EQU   PSASUP3
PSAIOSUP EQU   PSASUP3
PSAACR   EQU   PSASUP2
PSAIPCE2 EQU   PSASUP2
PSAIPCES EQU   PSASUP2
PSAIPCEC EQU   PSASUP2
PSAGTF   EQU   PSASUP2
PSAIPCRI EQU   PSASUP2
PSATYPE6 EQU   PSASUP1
PSATCTL  EQU   PSASUP1
PSADISP  EQU   PSASUP1
PSALOCK  EQU   PSASUP1
PSAPI    EQU   PSASUP1
PSAEXT   EQU   PSASUP1
PSASVC   EQU   PSASUP1
PSAIO    EQU   PSASUP1
PSATNEW  EQU   PSA+536
PSALCCAR EQU   PSA+532
PSAPCCAR EQU   PSA+524
PSAPCCAV EQU   PSA+520
PSAPSA   EQU   PSA+512
FLCHDEND EQU   PSA+512
FLCCRSAV EQU   FLCMCLA+280
FLCGRSAV EQU   FLCMCLA+216
FLCFPSAV EQU   FLCMCLA+184
FLCFLA   EQU   FLCMCLA+88
FLCRGNCD EQU   FLCMCLA+84
FLCFSAA  EQU   FLCFSA+1
@NM00126 EQU   FLCFSA
@NM00125 EQU   FLCMCLA+72
FLCMCIC  EQU   FLCMCLA+64
@NM00124 EQU   FLCMCLA+20
FLCIOAA  EQU   FLCIOA+1
@NM00123 EQU   FLCIOA
@NM00122 EQU   FLCMCLA+15
@NM00121 EQU   FLCMCLA+14
@NM00120 EQU   FLCMCLA+12
FLCLCL   EQU   FLCMCLA+8
FLCIOELA EQU   FLCIOEL+1
@NM00119 EQU   FLCIOEL
FLCCHNID EQU   FLCMCLA
@NM00118 EQU   PSA+160
FLCMTRCD EQU   PSA+157
@NM00117 EQU   PSA+156
FLCPERA  EQU   FLCPER+1
@NM00116 EQU   FLCPER
@NM00115 EQU   PSA+151
FLCPERCD EQU   PSA+150
FLCMCNUM EQU   PSA+149
@NM00114 EQU   PSA+148
FLCTEAA  EQU   FLCTEA+1
@NM00113 EQU   FLCTEA
PSAPIPC  EQU   PSAPICOD
PSAPIMC  EQU   PSAPICOD
PSAPIPER EQU   PSAPICOD
PSARV049 EQU   FLCPICOD
FLCPILCB EQU   FLCPIILC
@NM00112 EQU   FLCPIILC
@NM00111 EQU   PSAEPPSW
FLCSVCN  EQU   PSAESPSW+2
FLCSILCB EQU   FLCSVILC
@NM00110 EQU   FLCSVILC
@NM00109 EQU   PSAESPSW
FLCEICOD EQU   PSAEEPSW+2
PSASPAD  EQU   PSAEEPSW
@NM00108 EQU   PSA+128
FLCINPSW EQU   PSA+120
FLCMNPSW EQU   PSA+112
FLCPNPSW EQU   PSA+104
FLCSNPSW EQU   PSA+96
FLCENPSW EQU   PSA+88
FLCTRACE EQU   PSA+84
FLCTIMER EQU   PSA+80
FLCCVT2  EQU   PSA+76
FLCCAW   EQU   PSA+72
FLCCSW   EQU   PSA+64
FLCIOPSW EQU   PSA+56
FLCMOPSW EQU   PSA+48
FLCPOPSW EQU   PSA+40
FLCSOPSW EQU   PSA+32
FLCEOPSW EQU   PSA+24
@NM00107 EQU   FLCICCW2+4
FLCICCW1 EQU   FLCROPSW
FLCIPPSW EQU   FLCRNPSW
*                                      END UNREFERENCED COMPONENTS
@RC00114 EQU   @RC00112
@RF00245 EQU   @RC00243
@RC00249 EQU   @RC00243
@RC00255 EQU   @RC00243
@RC00213 EQU   @RC00195
@RC00211 EQU   @RC00195
@RF00322 EQU   @RC00301
@RC00447 EQU   @RC00443
@RF00526 EQU   @RC00521
@RF00516 EQU   @RC00440
@RC00702 EQU   @RC00695
@RF00878 EQU   @RC00865
@RC00843 EQU   @RC00842
@RC00972 EQU   @RC00970
@RC00986 EQU   @RC00970
@RC01114 EQU   @EL00003
@PB00003 EQU   @PB00004
@RC00215 EQU   @RC00213
@RC00708 EQU   @RC00702
@PB00002 EQU   @PB00003
@ENDDATA EQU   *
         END   IEAVTRTM,(C'PLS2335',0800,78080)
