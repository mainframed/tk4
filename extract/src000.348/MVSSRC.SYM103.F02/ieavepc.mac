         TITLE 'IEAVEPC- PROGRAM FIRST LEVEL INTERRUPT HANDLER'
* /* START OF SPECIFICATIONS ****
*
*01*  MODULE-NAME = IEAVEPC
*
*02*     CSECT-NAME = IEAVEPC
*
*01*  DESCRIPTIVE-NAME = PROGRAM INTERRUPT HANDLER
*
*01*  COPYRIGHT = NONE
*
*01*  STATUS = VERSION 1
*
*01*  FUNCTION = SEE ENTRY POINT PURPOSES BELOW.
*
*02*     OPERATION = THE PROGRAM FLIH WILL RECEIVE CONTROL VIA PROGRAM
*        NEW PSW AFTER A PROGRAM TYPE INTERRUPTION HAS OCCURRED. ITS
*        MAIN FUNCTION IS TO DETERMINE WHAT TYPE OF PROGRAM
*        INTERRUPTION HAS OCCURRED AFTER SAVING STATUS, AND ROUTE
*        CONTROL TO THE APPROPRIATE PROCESSOR TO PERFORM THE FUNCTION
*        INDICATED.
*
*01*   NOTES = SEE ENTRY POINT PURPOSES BELOW.
*
*02*        DEPENDENCIES =
*
*           GENERAL:
*           1. IT IS ASSUMED THAT IF A SUPERVISORY CONTROL FUNCTION WAS
*           RUNNING AT THE TIME OF INTERRUPTION, THE PROGRAM RUNNING
*           WILL ALWAYS BE DISABLED (EVEN IF JUST FOR I/O OR EXTERNAL)
*
*           NIP0:
*           1. NIP0 MUST PLACE THE MASTER MEMORY'S C.R.1 IN LCCAMCR1
*           AFTER THE MASTER MEMORY SEGMENT TABLE HAS BEEN CREATED.
*           2. THERE IS A DEPENDENCY ON NIP0 TO PREALLOCATE AN SRB POOL
*           FOR THE PURPOSE OF SUSPENDING SRBS. THE AMOUNT OF CORE THAT
*           WILL BE FORMATED BY NIP0 FOR THIS PURPOSE USING BLDCPOOL
*           WILL BE 8K WITH THE CELL SIZE BEING 480 BYTES. THIS CAL-
*           CULATES TO BE 16 CELLS. THE CPID TO BE USED IN THE
*           BLDCPOOL IS C'SRB'X'00'.
*           3. THE PROGRAM FLIH CODE MUST BE IN V=R STORAGE.
*
*           GTF:
*           1. GTF IS ENTERED UNCONDITIONALLY ON A NON-RECURSIVE
*           PROGRAM INTERRUPT. GTF WILL DECIDE WHETHER MC PROCESSING
*           OR INTERRUPTION RECORDING IS TO BE DONE. IN EITHER CASE
*           RETURN WILL ALWAYS BE BACK TO THE INTERRUPT HANDLER.
*           2. LOCKS MAY NOT BE ASKED FOR.
*           3. DISABLEMENT MUST BE PRESERVED.
*
*           PAGING SUPERVISOR(IEAPIX,RSM):
*           1. THE PAGING SUPERVISOR MUST NOT ENABLE OR ISSUE MC HOOKS
*           (ONLY BRANCH HOOKS MAY BE ISSUED) AS A SLIH.
*           2. ON ENTRY TO THE SUSPEND ROUTINE(ENTRY IEAVSUSP) THE
*           SALLOC LOCK MUST BE HELD.
*           ON RETURN FROM THE SUSPEND ROUTINE, THE PAGING SUPERVISOR
*           MUST KEEP TRACK OF REGISTERS 4,5,6 SO THAT THE RESET
*           ROUTINE(IEAVRSET) CAN BE DONE AT SOME LATER POINT IN TIME.
*           4. ON ENTRY TO THE RESET ROUTINE IT IS NECESSARY FOR THE
*           SALLOC LOCK TO BE HELD AND THE SRB THAT ENTERS RESET MUST
*           BE A NON-QUIESCABLE PRIORITY SRB IF A VALUE OF 4 IN REG-
*           ISTER 6 WAS INDICATED FROM SUSPEND, IF A VALUE OF 0 WAS
*           INDICATED IN REGISTER 6 FROM SUSPEND, THE SRB MUST BE A
*           SYSTEM PRIORITY SRB AND MUST OWN THE LOCAL LOCK IN ADDITION
*           TO THE SALLOC LOCK. IN EITHER CASE THE ADDRESS SPACE BEING
*           SERVICED MUST BE THE ONE THE REST IS BEING DONE FROM.
*           REGISTERS 4 AND 5 TO RESET MUST BE THE SAME AS AT EXIT
*           FROM SUSPEND.
*
*           DISPATCHER:
*           IN GENERAL:
*           1. THE DISPATCHER MUST, WHEN DISPATCHING AN SRB WITH A NON-
*           ZERO SRBSAVE FIELD , CHECK THE SSRBMAIN BIT BEFORE
*           FREECELLING THE SSRB.  IF THE SSRBMAIN BIT IS ON, THE
*           DISPATCHER MUST FREEMAIN THE SSRB AREA.
*
*           IEA0DS ENTRY:
*           1. THIS ENTRY WILL SAVE ALL STATUS OTHER THAN GENERAL
*           REGISTERS AND PSW FOR A LOCALLY LOCKED TCB, WILL CHECK FOR
*           THE CMS LOCK AND SET INDICATORS IF NECESSARY, AND WILL
*           ZERO ALL NECESSARY LOCK TABLE ENTRIES. THE LOCAL LOCK MUST
*           NOT BE TOUCHED SINCE A SUSPEND ID(X'7FF..FF') IS IN THE
*           LOCK WORD(ASCBLOCK).
*
*           SPIE:
*           1. SPIE MUST SUPPLY A SPIE CONTROL AREA(SCA). THE LENGTH OF
*           THIS AREA IS 4 BYTES FOR A PIE POINTER + THE LENGTH OF AN
*           SRB + 16 BYTES FOR PARAMETERS USED BY THE INTERRUPT HAND-
*           LER. A POINTER TO THE SCA MUST BE PLACED IN THE TCBPIE
*           FIELD. IF A PIE EXISTS THE FIRST 4 BYTES OF THE SCA POINTS
*           TO THE PIE.
*           2. THE ADDRESS OF SPIE'S RMTR HAS BEEN PLACED IN THE
*           SRBRMTR FIELD OF THIS SRB LOCATED WITHIN THE SCA.
*
*           RTM:
*           1. THE SEGMENT AND TRANSLATION RECURSION BITS MUST BE TURN-
*           ED OFF BY RTM IN THE PROGCK AND DATERR ENTRIES AFTER SUC-
*           CESSFUL COMPLETION OF ITS PROCESSING.
*           2. ON THE DATERR ENTRY THE ERROR INFORMATION IS IN LCCAPGR1
*           (GENERAL REGISTERS) AND ALL OTHER INFO IS IN HARDWARE
*           STORED LOW CORE.
*           3. NORMALLY THE PROGCK ENTRY ERROR INFORMATION IS IN
*           LCCAPGR2(GENERAL REGS), LCCAPPSW(FOR PSW), LCCAPINT(ILC +
*           INTERRUPT CODE), AND LCCAPVAD(TRANSLATION ADDRESS). HOWEVER
*           IF A NON-ZERO COMPLETION CODE WAS SPECIFIED ON THE ENTRY
*           THE ERROR INFORMATION IS IN THE SAME AREAS AS FOR DATERR.
*           4. ON THE PGIOERR ENTRY FROM THE RESET ROUTINE, RTM IS EX-
*           PECTED TO TEST THE RB WAIT COUNT (PASSED IN REG 5) IF
*           RESETING AN UNLOCKED TCB, AND IF 0 IGNORE ANY OPERATIONS
*           DUE TO THE FACT THAT ABNORMAL TERMINATION IS ALREADY IN
*           PROGRESS.
*           5. BEFORE THE FREEING OF AN RB(DUE TO AN ABNORMAL TERMINA-
*           TION) OR ALLOWING THE RB TO RETRY IN ANY WAY, RTM MUST
*           PURGE ANY OUTSTANDING PAGING I/O FOR THE RB SO THAT RESET
*           WILL GET CONTROL AND PERFORM ITS CLEAN UP.
*           6. RTM AND EMS/MFA FRRS CAN NOT GIVE UP OR GET LOCKS.
*
*           PC FLIH RECURSIONS  -- PTM VS08516 --
*           IN CASE OF RECURSION IN THE FIRST SEGMENT OF THE PROGRAM
*           FLIH, THE FOLLOWING RECOVERY ACTIONS WILL BE TAKEN:
*           1. IF THE PROBLEM IS CAUSED BY A DAT-TYPE ERROR, MASTER'S
*           C.R.1 WILL BE LOADED, AND THE NORMAL DATERR ENTRY WILL
*           BE TAKEN TO RTM.  THE REGISTERS AT TIME OF INTERRUPT WILL
*           BE STORED IN LCCAPGR1.
*           2. IF THE PROBLEM IS CAUSED BY THE LCCA POINTERS BEING
*           OVERLAID, AN ATTEMPT WILL BE MADE TO RESTORE THEM FROM
*           THE LCCAT, AND THE PCCA POINTERS FROM THE PCCAT.
*           A FAILURE IN THIS ATTEMPT WILL ALSO RESULT IN THE DATERR
*           ENTRY BEING TAKEN TO RTM.  SUCCESSFUL REFRESH OF THESE
*           FIELDS WILL RESULT IN A PROGCHK ENTRY TO RTM, WITH A
*           COMPLETION CODE OF X'4FC', THE PC FLIH STACK AS CURRENT,
*           THE PC FLIH SUPER BIT ON, AND THE INCORRECT VALUES FROM
*           LOCATION X'208' - '217' STORED IN THE FIRST FOUR WORDS
*           OF LCCAPGR1.
*
*03*        CHARACTER-CODE-DEPENDENCIES = NONE
*
*02*     RESTRICTIONS = NONE
*
*02*     REGISTER-CONVENTIONS = SEE EQUATE SECTION OF THE MODULE
*
*02*     PATCH-LABEL = NONE(NUCLEUS RESIDENT)
*
*01*  MODULE-TYPE = PROCEDURE
*
*02*     PROCESSOR = ASSEMBLER
*
*02*     MODULE-SIZE = REFERENCE ESD LENGTH AT BEGGINNING OF MODULE.
*
*02*     ATTRIBUTES = NUCLEUS ,ZERO PROTECT KEY,DISABLE,REFRESHABLE,
*        ADDRSPC=REAL,SUPERVISOR MODE
*
*01*  ENTRY-POINT = IEAQPK00
*
*02*     PURPOSE = THIS IS THE MAIN ENTRY POINT INTO PROGRAM FLIH, IT
*        WILL DECIDE WHAT TYPE OF INTERRUPTION HAS OCCURED AND
*        CONSEQUENTLY DECIDE WHAT PROCESSOR SHOULD BE GIVEN CONTROL .
*
*02*     LINKAGE = SEE INPUT SECTION BELOW
*
*02*     INPUT =
*        INPUT ENVIRONMENT:
*        STATE-DISABLED FOR I/O,EXTERNAL,DAT,AND PER INTERRUPTS,
*        SUPERVISOR
*        KEY-0
*        LOCKS REQUIRED-NONE
*        INPUT DATA:
*        PROGRAM OLD PSW-LOCATION DECIMAL 40
*        PROGRAM INTERRUPT CODE-LOCATION DECIMAL 142
*        PROGRAM ILC VALUE-LOCATION DECIMAL 140-141
*        TRANSLATION EXCEPTION ADDRESS-LOCATION DECIMAL 144
*        ALL FIELDS OF THE CONTROL-BLOCKS BELOW
*        INPUT REGISTERS:
*        NONE
*
*02*     OUTPUT = NONE UNIQUE TO THIS ENTRY
*
*01*  ENTRY-POINT = IEAVPSRB
*
*02*     PURPOSE = THIS ROUTINE PERFORMS THE PIE/PICA PROCESSING
*        NECESSARY TO SATISFY AN ENTRY INTO A SPIE EXIT ROUTINE AFTER A
*        PROGRAM CHECK HAS OCCURED FOR AN UNLOCKED, PROBLEM PROGRAM TCB
*        ,WITH A SPIE EXIT.
*
*02*     LINKAGE = SEE INPUT SECTION BELOW
*
*02*     INPUT =
*        INPUT ENVIRONMENT:
*        STATE-ENABLED,SUPERVISOR STATE
*        KEY-0
*        LOCKS REQUIRED-NONE
*        INPUT DATA:
*        SCA(SPIE CONTROL AREA)
*        TCB BEING SERVICED
*        RB BEING SERVICED
*        INPUT REGISTERS:
*        0=CONTAINS ADDRESS OF SRB
*        1=CONTAINS ADDRESS OF PARAMETERS
*        14=CONTAINS RETURN ADDRESS
*        15=CONTAINS ENTRY POINT ADDRESS
*
*02*     OUTPUT = NONE UNIQUE TO THIS ENTRY
*
*01*  ENTRY-POINT = IEAVSUSP
*
*02*     PURPOSE = THIS ENTRY IS PROVIDED TO THE PAGING SUPERVISOR. IT
*        IS ENTERED IF PAGING I/O MUST BE PERFORMED. THIS ENTRY WILL
*        SAVE THE NECESSARY STATUS AND PERFORM THE OPERATIONS NECESSARY
*        TO SUSPEND AN SRB, LOCKED TCB, OR UNLOCKED TCB.
*
*02*     LINKAGE = SEE INPUT SECTION BELOW
*
*02*     INPUT =
*        INPUT ENVIRONMENT:
*        STATE-DISABLED,SUPERVISOR
*        KEY-0
*        LOCKS REQUIRED-SALLOC LOCK
*        INPUT DATA:
*        ALL INFORMATION FROM THE CONTROL-BLOCKS PSA AND LCCA.
*        INPUT REGISTERS:
*        13=SAVE AREA ADDRESS
*        14=RETURN ADDRESS
*
*02*     OUTPUT = NONE UNIQUE TO THIS ENTRY
*
*01*  ENTRY-POINT = IEAVRSET
*
*02*     PURPOSE = THIS ENTRY IS PROVIDED TO THE PAGING SUPERVISOR. IT
*        IS ENTERED ON PAGING I/O COMPLETION OR ON AN I/O ERROR OR ON
*        THE PURGING OF PAGING I/O. THIS ENTRY WILL CAUSE THE SUSPENDED
*        TCB OR SRB TO BE REDISPATCHED. IF AN ERROR IS INDICATED, RTM
*        IS ENTERED AND WILL PERFORM THE NECESSARY SET UP.
*
*02*     LINKAGE = SEE INPUT SECTION BELOW
*
*02*     INPUT =
*        INPUT ENVIRONMENT:
*        STATE-DISABLED,SUPERVISOR
*        KEY-0
*        LOCKS REQUIRED-LOCAL AND SALLOC LOCKS IF SERVICING AN
*                       UNLOCKED TCB.
*                       SALLOC LOCK ONLY OTHERWISE
*        INPUT DATA:
*        NONE
*        INPUT REGISTERS:
*        4=ADDRESS OF TCB OR SRB
*        5=ADDRESS OF RB OR 0(IF SRB)
*        6=0(IF NO ERROR)
*          NON-0(IF ERROR)
*        13=SAVE AREA ADDRESS
*        14=RETURN ADDRESS
*        15=ENTRY POINT ADDRESS
*
*02*     OUTPUT = NONE UNIQUE TO THIS ENTRY
*
*01*  EXIT-NORMAL = IEA0DS
*
*02*     CONDITIONS = IF AN SRB HAS BEEN SCHEDULED TO PERFORM PIE/PICA
*        PROCESSING, EXIT FROM THE PROGRAM FLIH IS TO THE DISPATCHER.
*        OR IF A PAGE EXCEPTION HAS OCCURED AND THE PAGING SUPERVISOR
*        HAS INDICATED THAT I/O HAS TO BE DONE AND SUSPENDED THE
*        TCB OR SRB, EXIT IS TO THE DISPATCHER
*
*02*     OUTPUT =
*        OUTPUT DATA-NONE DIRECTLY
*        OUTPUT REGISTERS-NONE
*        OUTPUT ENVIRONMENT-DISABLED,SUPERVISOR STATE,KEY 0,UNLOCKED
*
*02*     RETURN-CODES = NONE
*
*01*  EXIT-NORMAL = RTM(DATERR)
*
*02*     CONDITIONS = WHEN A TRANSLATION SPECIFICATION HAS OCCURED AND
*        CONTROL REGISTER 0 BITS 8-12 ARE VALID FOR TRANSLATION, OR
*        SEGMENT EXCEPTION RECURSION HAS OCCURED, RTM IS ENTERED AFTER
*        LOADING THE MASTER MEMORY'S CONTROL REGISTER 1(STOR REGISTER)
*        TO TERMINATE THE BAD MEMORY.
*
*02*     OUTPUT =
*        OUTPUT DATA-LCCAPDAT BIT ON,MAYBE LCCAPSG1 BIT ON,ALL OTHER
*                    INFO IN THE PSA
*        OUTPUT REGISTERS-NONE
*        OUTPUT ENVIRONMENT-DISABLED,KEY 0,SUPERVISOR STATE,ANY LOCK
*                           MAY BE HELD,IN MASTER MEMORY ADDRESS
*                           SPACE
*
*02*     RETURN-CODES = NONE
*
*01*  EXIT-NORMAL = RTM(PROGCK)
*
*02*     CONDITIONS = IF A TRANSLATION SPECIFICATION HAS OCCURED AND
*        CONTROL REGISTER 0 BITS 8-12 ARE INVALID FOR TRANSLATION, A
*        DEFAULT VALUE FOR C.R.0 IS LOADED AND RTM IS ENTERED TO
*        INITIATE RECOVERY TERMINATION. THIS ENTRY IS ALSO USED IF 1) A
*        PROGRAM FLIH RECURSION HAS OCCURED, 2) A INTERRUPT OTHER THAN
*        AN MC OR PER HAPPENED IN DISABLED CODE, 3) A SEGMENT EXCEPTION
*        ,INVALID PAGE EXCEPTION, SSM INSTRUCTION OR ANY PROGRAM CHECK
*        HAS OCCURED IN SRB MODE, IN A LOCALLY LOCKED TCB, IN AN
*        UNLOCKED TCB IN SUPERVISOR STATE, OR AN UNLOCKED TCB IN
*        PROBLEM STATE WITHOUT A SPIE EXIT OR 4) A NON-RECURSIVE
*        TRANSLATION SPECIFICATION HAS OCCURRED.
*
*02*     OUTPUT = 4 CASES
*        CASE 1: PROGRAM FLIH RECURSION
*        OUTPUT DATA-REGS IN LCCAPGR1 ALL OTHER IN HARDWARE STORED
*                    LOCATIONS
*        OUTPUT REGISTERS-1=NEGATIVE
*        OUTPUT ENVIRONMENT-DISABLED,KEY 0,SUPERVISOR STATE,ANY
*                           LOCK HELD
*        CASE 2: C.R.0 BAD
*        OUTPUT DATA-SAME AS CASE 1
*        OUTPUT REGS-1=COMPLETION CODE X'069'
*        OUTPUT ENVIRONMENT-SAME AS CASE 1
*        CASE 3: TRANSLATION SPECIFICATION OR ADDRESSING EXCEPTION
*        ALL OUTPUT AS IN CASE 1 WITH ADDITION LCCAPSG1 BIT OFF
*        CASE 4: ALL OTHER REASONS
*        OUTPUT DATA-REGS IN LCCAPGR2,PSW IN LCCAPPSW, ILC AND
*                    INTERRUPT CODE IN LCCAPINT, TRANSLATION ADDRESS
*                    IN LCCAPVAD(IF ANY)
*        OUTPUT REGISTERS-NONE
*        OUTPUT ENVIRONMENT-SAME AS CASE 1
*
*02*     RETURN-CODES = NONE
*
*01*  EXIT-NORMAL = BACK TO INTERRUPTED PROGRAM
*
*02*     CONDITIONS = IF AN MC OR PER INTERRUPT ALONE WAS THE CAUSE OF
*        THE PROGRAM INTERRUPTION, RETURN VIA A LPSW WILL BE BACK TO
*        THE INTERRUPTED PROGRAM AFTER THE NECESSARY TRACING HAS BEEN
*        PERFORMED. OR IF A PAGE EXCEPTION HAS OCCURED AND THE PAGING
*        SUPERVISOR WAS ABLE TO RECLAIM THE PAGE, RETURN VIA A LPSW
*        WILL BE BACK TO THE INTERRUPTED PROGRAM.
*
*02*     OUTPUT = ALL STATUS AND INFO AS AT INTERRUPT TIME
*
*02*     RETURN-CODES = NONE
*
*01*  EXIT-NORMAL = SPIE ROUTINE(TO HANDLE PAGE EXCEPTION)
*
*02*     CONDITIONS = WHEN A PAGE EXCEPTION HAS OCCURED AND THE
*        INTERRUPTED PROGRAM IS NEITHER  IN SRB MODE NOR IN SUPERVISOR
*        STATE AND THE TCBPIE17 BIT IS ON INDICATING A SPIE IS IN
*        EFFECT TO HANDLE THE PAGE EXCEPTION, A LPSW IS TAKEN TO THE
*        SPIE EXIT IF A RECURSIVE PROGRAM INTERRUPTION HAS NOT OCCURED
*        IN SETTING UP THE PIE/PICA.
*
*02*     OUTPUT =
*        OUTPUT DATA-PIE IS SET UP, THE RBOPSW IS SET UP, AND THE
*                    PROGRAM MASK IS AS INDICATED IN THE PICA.
*        OUTPUT REGISTERS-0=TRANSLATION EXCEPTION ADDRESS,
*                         1=ADDRESS OF PIE
*                         14=ADDRESS OF RETURN POINT
*                         15=ADDRESS OF SPIE EXIT
*                         ALL OTHERS AS AT INTERRUPT
*        OUTPUT ENVIRONMENT-ENABLED,PROBLEM STATE,NO LOCKS
*
*02*     RETURN-CODES = NONE
*
*01*  EXIT-NORMAL = PAGING SUPERVISOR(RSM)
*
*02*     CONDITIONS = RETURN TO CALLER AFTER RESET REQUEST HAS BEEN
*        SATISFIED
*
*02*     OUTPUT = NONE TO PAGING SUPERVISOR
*
*02*     RETURN-CODES = NONE
*
*01*  EXIT-ERROR = SYSTEM TERMINATION ROUTINE (IGFPTERM)
*
*02*     CONDITIONS = TRANSLATION SPECIFICATION RECURSION OR SEGMENT
*        EXCEPTION RECURSION(SECOND TIME) HAS OCCURED.
*
*02*     OUTPUT =
*        OUTPUT DATA- 2 WORD PARAMETER LIST
*        WORD 1 = ADDR WTO BUFFER CONTAINING MESSAGE IEA999W
*        WORD 2 = ADDR LOG REC BUFFER CONTAINING WAIT STATE  CODE X'14'
*        OUTPUT REGISTERS- REG 1 = ADDR PARAMETER LIST
*        OUTPUT ENVIRONMENT-DISABLED FOR DAT, I/O AND EXT INTERRUPTS
*        SUPERVISOR STATE, KEY 0, ANY LOCK HELD
*02*     RETURN-CODES = NONE
*
*01*  EXIT-ERROR = RTM (DATERR) OR (PROGCHK)
*
*02*     CONDITIONS = RECURSION IN THE TOP SEGMENT OF THE PROGRAM FLIH
*        DUE TO:
*        1. DAT-TYPE ERRORS REFERENCING THE LCCA ADDRESSES
*           IN A USER MEMORY  (DATERR ENTRY)
*        2. THE LCCA ADDRESSES HAVE BEEN OVERLAID IN LOW-CORE.
*           (PROGCHK ENTRY)
*
*02*     OUTPUT=
*        CASE 1: USUAL DATERR ENTRY -- MASTER'S C.R.1 HAS BEEN
*           LOADED , AND THE REGISTERS AT TIME OF INTERRUPT ARE IN
*           LCCAPGR1.
*        CASE2: PROGCHK ENTRY -- THE LCCA AND PCCA POINTERS HAVE BEEN
*           RESTORED, THE PC FLIH STACK IS CURRENT AND THE SUPER BIT
*           HAS BEEN SET.  A COMPLETION CODE OF X'4FC' IS PASSED IN
*           REGISTER 1.  THE INCORRECT VALUES OF LOCATIONS
*           X'208' - '217' ARE IN THE FIRST FOUR WORDS OF LCCAPGR1.
*
*01*  EXTERNAL-REFERENCES = SEE ROUTINES,DATA AREAS,CONTROL-BLOCKS
*     BELOW
*
*02*     ROUTINES =
*        AHLMCIH(GTF HANDLER)
*        IGFPTERM (SYSTEM TERMINATION FACILITY)
*        IEAVPIX(PAGING SUPERVISOR)
*        TRPI(TRACE ROUTINE)
*        IEAVPSRB(PIE/PICA SRB ROUTINE)
*        IEA0DS(MAIN DISPATCHER ENTRY)
*        RTM(DATERR)
*        RTM(PROGCK)
*        STATUS RESET
*        RTM(ABTERM)
*        SETLOCK (OBTAIN/RELEASE)
*        GETCELL
*        RTM(PGIOERR)
*        SCHEDULE
*        POST(NO ECB)
*
*02*     DATA-AREAS = ALL INCLUDED IN CONTROL-BLOCKS BELOW
*
*02*     CONTROL-BLOCKS =
*        PSA R/W
*        PCCA R
*        LCCA R/W
*        SRB R/W
*        SSRB W
*        ASCB R/W
*        TCB R/W
*        CVT R
*        SCA R/W
*        PIE R/W
*        PICA R
*        RB R/W
*        ASXB R
*        IHSA W
*        WSAG R
*        SSRB R/W
*        SCVT R/W
*        SDWA W
*        PVT R
*        PCCAT R
*        LCCAT R
*
*01*  TABLES = NONE
*
*01*  MACROS =
*        SCHEDULE
*        CALLRTM
*        HOOK
*        SETLOCK
*        SETRP
*        GETCELL
*
*01*  CHANGE-ACTIVITY = Y0715,Y02751,Y02752,D04015
*                       OZ31350 - GO INTO USER KEY BEFORE
*                       REFERENCING PICA                       @ZA31350
*
*01*  MESSAGES = NONE
*
*01*  ABEND-CODES =
*        X'0CX'-CODE DEPENDING ON TYPE OF PROGRAM CHECK
*        X'0FB'-BAD C.R. 0 TRANSLATION EXCEPTION
*        X'028'-INTERNAL ERROR IN PAGING SUPERVISOR
*        X'4FC'-LOW CORE OVERLAY                               @YM08516
*
**** END OF SPECIFICATIONS ***/
         EJECT
          SPACE 2
*/*IEAVEPC: CHART PROG FLIH */
*/* HEADER
*/*
*/*
*/*
*/*                                                  SECTION 3.1.8.4
*/* PROGRAM FLIH
*/*                                                  PAGE # */
          SPACE 2
IEAVEPC  CSECT
         MODID BR=NO
***********************************************************************
*                                                                     *
*                       REGISTER EQUATES                              *
*                                                                     *
***********************************************************************
TEMPREG  EQU   6                       TEMPORARY SAVE REG
COREREG  EQU   0                       GETMAIN REG
XSRBREG  EQU   7                       SRB REG
XPIEREG2 EQU   5                       PIE ADDRESS
XPICAREG EQU   8                       PICA ADDRESS
WORKREG1 EQU   10                      WORK REG
WORKREG3 EQU   11                      WORK REG
WORKREG4 EQU   12                      WORK REG
PARMREG  EQU   1                       PARAMETER REG
R4       EQU   4                       GENERAL REG
R5       EQU   5                       GENERAL REG
R3       EQU   3                       GENERAL REG
R2       EQU   2                  GENERAL REGISTER     @ZA06785
R8       EQU   8                  GENERAL REG          @ZA06785
R9       EQU   9                  BASE REG FOR IEAVSPER     @ZA06785
R7       EQU   7                       GENERAL REG
R13      EQU   13                      GENERAL REG
ASXBREG  EQU   6                       ASXB ADDRESS
IHSAREG  EQU   6                       IHSA ADDRESS
SCHLREG  EQU   6                       SCHEDULE REG
CPIDREG  EQU   0                       CELL POOL ID REG
CVTREG2  EQU   3                       CVT ADDRESS
SRBCRREG EQU   1                       SRB CELL REG
SRBSAVER EQU   8                       SRB SAVE AREA ADDRESS
FPR0     EQU   0                       FLOATING POINT REG
FPR2     EQU   2                       FLOATING POINT REG
FPR4     EQU   4                       FLOATING POINT REG
FPR6     EQU   6                       FLOATING POINT REG
ERREG    EQU   6                       ERROR CODE REGISTER
SRBREG   EQU   5                       SRB ADDRESS
R11      EQU   11                      GENERAL REG
CCABASE  EQU   7                       LCCA ADDRESS
R0       EQU   0                       GENERAL REG
R15      EQU   15                      GENERAL REG
WORKREG  EQU   14                      WORK REG
BASEREG  EQU   9                       BASE REG
CVTREG   EQU   13                      CVT ADDRESS
XPICODE  EQU   6                       PROGRAM CODE REG
SCAREG   EQU   15                      SCA ADDRESS
SCAREG2  EQU   3                       SCA ADDRESS
XTRBASE  EQU   10                      TRACE ENTRY POINT ADDRESS
XTRET    EQU   11                      TRACE BR INSTRUCTION ADDRESS
EPREG    EQU   15                      ENTRY POINT ADDRESS
RETREG   EQU   14                      RETURN ADDRESS
XTCBREG  EQU   4                       TCB ADDRESS
RBPTR    EQU   5                       RB ADDRESS
XPIEREG  EQU   1                       PIE ADDRESS
ASCBREG  EQU   3                       ASCB REG
WORKREG2 EQU   8                       WORK REG
DISPRTN  EQU   6                       DISPATCHER ADDRESS
CR0      EQU   0                       CONTROL REG 0
R1       EQU   1                       GENERAL REG
MASTER   EQU   1                       CONTROL REG 1
CR1      EQU   1                       CONTROL REG 1
R12      EQU   12                      GENERAL REG 12
R14      EQU   14                      GENERAL REG
RTCDREG  EQU   15                      RETURN CODE REG
CCABASE2 EQU   15                      LCCA BASE REG
PCCABASE EQU   14                      PCCA BASE REG
XPIPICA  EQU   3                       PICA REG
R10      EQU   10                      GENERAL REG
SAVEREG  EQU   2                       SAVE AREA FOR RETURN ADDRESS
ASCBBASE EQU   8                       ASCB ADDR FOR SUSPEND ROUTINE
PVTPTR   EQU   3                       PVT ADDR FOR SUSPEND ROUTINE
R6       EQU   6                       GENERAL REGISTER 6      @YM08516
FOOTMARK EQU   4                       RECURSION FOOT PRINT    @YM08516
TEMP0    EQU   2                       EVEN WORK REGISTER      @YM08516
TEMP1    EQU   3                       ODD WORK REGISTER       @YM08516
***********************************************************************
*                                                                     *
*                       CONSTANT EQUATES                              *
*                                                                     *
***********************************************************************
EXIT     EQU   3                       EXIT SVC
PERCODE  EQU   X'80'                   PER CODE
TRCODE   EQU   X'12'                   TRANSLATION EXCEPT CODE @YM08516
PGCODE   EQU   X'11'                   PAGE FAULT CODE
SGCODE   EQU   X'10'                   SEGMENT CODE
ADCODE   EQU   X'05'                   ADDRESS EXCEPT CODE     @YM08516
PRCODE   EQU   X'04'                   PROTECTION CHECK CODE
CR0MASK  EQU   X'80'                   BIT 8-12 C.R.0 MASK
RCDTYPE  EQU   X'81'                   RECORD TYPE OF LOG REC BUFFER
L1       EQU   1                       LENGTH VALUE
L2       EQU   2                       LENGTH VALUE            @YM08516
L4       EQU   4                       LENGTH VALUE
L6       EQU   6                       LENGTH VALUE
L8       EQU   8                       LENGTH VALUE
L12      EQU   12                      LENGTH VALUE
L60      EQU   60                      LENGTH VALUE
L64      EQU   64                      LENGTH VALUE
L84      EQU   84                      LENGTH VALUE
L256     EQU   256                     LENGTH VALUE
M1       EQU   1                       MASK VALUE
M4       EQU   4                       MASK VALUE              @YM08215
M7       EQU   7                       MASK VALUE
M8       EQU   8                       MASK VALUE
M11      EQU   11                      MASK VALUE
M12      EQU   12                      MASK VALUE
M15      EQU   15                      MASK VALUE
ZERO     EQU   0                       DISPLACEMENT VALUE
FOUR     EQU   4                       DISPLACEMENT VALUE
FIVE     EQU   5                       DISPLACEMENT VALUE
EIGHT    EQU   8                       DISPLACEMENT VALUE
ELEVEN   EQU   11                      DISPLACEMENT VALUE
C0       EQU   0                       DISPLACEMENT VALUE
C1       EQU   1                       DISPLACEMENT VALUE
C2       EQU   2                       DISPLACEMENT VALUE
C3       EQU   3                       DISPLACEMENT VALUE
C4       EQU   4                       DISPLACEMENT VALUE
C5       EQU   5                       DISPLACEMENT VALUE
C6       EQU   6                       DISPLACEMENT VALUE
C8       EQU   8                       DISPLACEMENT VALUE
C12      EQU   12                      DISPLACEMENT VALUE @ZA06785
C16      EQU   16                      DISPLACEMENT VALUE
C24      EQU   24                      DISPLACEMENT VALUE
C28      EQU   28                      DISPLACEMENT VALUE
C36      EQU   36                      DISPLACEMENT VALUE      @YM08516
C48      EQU   48                      DISPLACEMENT VALUE
C56      EQU   56                      DISPLACEMENT VALUE
C60      EQU   60                      DISPLACEMENT VALUE
C256     EQU   256                     DISPLACEMENT VALUE
CX01     EQU   X'01'                   IMMEDIATE VALUE
CX3F     EQU   X'3F'                   IMMEDIATE VALUE
CX03     EQU   X'03'                   IMMEDIATE VALUE
CXFF     EQU   X'FF'                   IMMEDIATE VALUE
CXFA     EQU   X'FA'                   IMMEDIATE VALUE
CX00     EQU   X'00'                   IMMEDIATE VALUE
CX10     EQU   X'10'                   IMMEDIATE VALUE
CX04     EQU   X'04'                   IMMEDIATE VALUE
CXF8     EQU   X'F8'                   IMMEDIATE VALUE
CXF0     EQU   X'F0'                   IMMEDIATE VALUE
CX0F     EQU   X'0F'                   IMMEDIATE VALUE
CXC0     EQU   X'C0'                   IMMEDIATE VALUE
CX80     EQU   X'80'                   IMMEDIATE VALUE
COMPCOD1 EQU   X'0FB'                  BAD C.R.0 COMP CODE
WAITCODE EQU   X'14'                   SYSTEM TERM WAIT STATE CODE
PCABCODE EQU   X'4FC'                  PC FLIH FRR ABEND CODE  @YM08516
SRBERRCC EQU   X'6FC'                  SRB FRR COMPLETION CODE
PIXABEND EQU   X'028'                  ABEND CODE FOR IEAPIX FAILURE
         EJECT
         USING PSA,0
PROGSVC3 SVC   EXIT                    SPECIAL SVC 3 FOR SPIE EXITS-
*                                      PLACEMENT IN FRONT OF IEAQPK00
         ENTRY IEAPSVC3
          SPACE 2
*/*IEAQPK00: E IEAQPK00 */
          SPACE 2
         ENTRY IEAQPK00
IEAPSVC3 DS    0H                      ENTRY STATEMENT FOR EXIT
IEAQPK00 DS    0H
          SPACE 2
*/* P SAVE TWO REGS IN PSAPIREG */
          SPACE 2
         ST    CCABASE,PSAPIREG        SAVE ONE REGISTER IN PSA
         ST    BASEREG,PSAPIR2                                 @YM08516
          SPACE 2
*/* P ESTABLISH ADDRESSABILITY */
          SPACE 2
         BALR  BASEREG,C0              ESTABLISH
         USING *,BASEREG               ADDRESSABILITY
ADDRESS  DS    0H                                              @YM08516
         SPACE 2
*/* D (NO,,YES,PSAREF) RECURSION IN FLIH? */
         SPACE 2
         TM    PSASUP3,PSAPI2          RECURSION IN FLIH?      @YM08516
         BO    PSAREF                  IF SO TRY TO RECOVER    @YM08516
         SPACE 2
*/* P SET RECURSION2 BIT ON */
         SPACE 2
         OI    PSASUP3,PSAPI2          SET RECURSION BIT ON    @YM08516
          SPACE 2
*/* P GET LCCA ADDR FROM PSALCCAR */
          SPACE 2
         L     CCABASE,PSALCCAR        GET REAL ADDRESS OF LOGICAL CCA
         USING LCCA,CCABASE            ESTABLISH BASE TO LCCA
          SPACE 2
*/* P SAVE ALL REGS IN LCCAPGR1 */
          SPACE 2
         STM   R0,R15,LCCAPGR1         SAVE ALL REGS IN LCCA AREA
         L     WORKREG,PSAPIREG        GET REGISTER SAVED INITIALLY
         ST    WORKREG,LCCAPGR1+C28    SAVE REGISTER USED
         L     WORKREG,PSAPIR2         GET REGISTER 2 SAVED    @YM08516
         ST    WORKREG,LCCAPGR1+C36    SAVE REGISTER USED      @YM08516
          SPACE 2
*/* P REFRESH CVT ADDR FROM INTERNAL ADCON */
          SPACE 2
         L     CVTREG,ADCVT            GET CVT ADDRESS
         ST    CVTREG,FLCCVT           REFRESH CVT POINTER
          SPACE 2
*/* P TURN OFF PER */
          SPACE 2
         USING CVT,CVTREG              ESTABLISH BASE TO CVT
         LH    XPICODE,FLCPICOD        GET PROGRAM INTRPR CODE
         LA    WORKREG,CXFF-PERCODE    GET MASK TO TURN PER OFF
         NR    XPICODE,WORKREG         TURN PER OFF IN REG
         SPACE 2
*/* D (YES,DATON,NO,) PAGE FAULT? */
         SPACE 2
PGFLTST  DS    0H
         STC   XPICODE,PSAPIR2         STORE PI CODE           @YM08516
         CLI   PSAPIR2,PGCODE          IS INTRPT PAGE FAULT    @YM08516
         BE    DATON                   IF SO GO HANDLE         @YM08516
          SPACE 2
*/*TRANSTST: D (YES,TRANS1,NO,) TRANS SPEC? */
          SPACE 2
TRANSTST DC    0H'0'                   TEST LABEL
         CLI   PSAPIR2,TRCODE          IS INTRPT TRANS SPEC
         BE    TRANS1                  IF SO GO PROCESS
          SPACE 2
*/* D (YES,TRANS3,NO,) ADDRESS EXCEPTION? */
          SPACE 2
         CLI   PSAPIR2,ADCODE          IS INTRPT ADDR EXCEPTION
         BE    TRANS3                  IF SO CHECK NEXT ACTION
          SPACE 2
*/*SEGTST: D (NO,DATON,YES,) SEG EXCEPTION? */
          SPACE 2
SEGTST   DC    0H'0'                   TEST LABEL
         CLI   PSAPIR2,SGCODE          IS INTRPT SEGMENT EXCEP
         BNE   DATON                   IF NOT PROCEED
          SPACE 2
*/* D (YES,TRANS2,NO,) SEG RECURSION? */
          SPACE 2
         TM    LCCAIHR1,LCCAPSG1       IS THIS A SEGMENT RECURSION
         BO    TRANS2                  IF SO TRY TO RECOVER
          SPACE 2
*/* P SET SEG REC BIT */
          SPACE 2
         OI    LCCAIHR1,LCCAPSG1       SET SEGMENT RECURSION BIT
          SPACE 2
*/*DATON: P ENABLE PSW FOR DAT */
          SPACE 2
DATON    STOSM LCCAPSMK,CX04           ENABLE FOR DAT
         L     CCABASE,PSALCCAV        GET VIRTUAL ADDRESS OF LCCA
          SPACE 2
*/*PIERCTST: D (YES,BADPIE,NO,PIRCTST) PIE RECURSION? */
          SPACE 2
PIERCTST DC    0H'0'                   TEST LABEL
         TM    LCCAIHR1,LCCAPPIE       IS THE PIE RECURSION BIT ON
         BO    PIEREC                  IF SO GO PROCESS RECURSION
          SPACE 2
*/*PIRCTST: D (NO,PROGCONT,YES,) PROGRAM RECURSION? */
          SPACE 2
PIRCTST  DC    0H'0'                   TEST LABEL
         TM    PSASUP1,PSAPI           DID A PROGRAM RECURSION OCCUR
         BNO   PROGCONT                IF NOT CONTINUE
          SPACE 2
*/* P (,ERR3) SET UP -1 COMPLETION CODE */
          SPACE 2
         NI    PSASUP3,CXFF-PSAPI2-PSAPSREG
*                                      CLEAR RECURSION 2 BITS  @YM08516
         MVC   FLCTRACE,CVTTRCA        REFRESH TRACE HEADER    @YA02352
         SR    R1,R1                   ZERO REG 1
         BCTR  R1,C0                   DECREMENT TO MINUS FOR COMPCODE
         B     ERR2                    PROCEED TO RTM          @ZA10452
          SPACE 2
*/*PROGCONT: P STORE THE CLOCK FOR JOB STEP TIMING */
          SPACE 2
PROGCONT STCK  PSAPCPSW                STORE CLOCK FOR JOB     @YM08398
*                                      STEP TIMING PURPOSES    @YM07640
          SPACE 2
*/* P SAVE CURRENT FRR STACK POINTER */
          SPACE 2
         L     WORKREG,PSACSTK         GET CURRENT STACK PTR
         ST    WORKREG,PSAPSAV         SAVE CURRENT PTR IN SAVE AREA
          SPACE 2
*/* P MAKE PROG FLIH STACK CURRENT */
          SPACE 2
         L     WORKREG,PSAPSTK         GET PROGRAM FLIH STACK PTR
         ST    WORKREG,PSACSTK         SET PROGRAM FLIH STACK PTR
          SPACE 2
*/* P SET PROGRAM FLIH RECURSION */
          SPACE 2
         OI    PSASUP1,PSAPI           SET PROGRAM FLIH BIT
         SPACE 2
*/* P CLEAR RECURSION2 BIT */
         SPACE 2
         NI    PSASUP3,CXFF-PSAPI2-PSAPSREG
*                                      CLEAR RECURSION 2 BIT   @YM08516
          SPACE 2
*/* P MOVE REGS LCCAPGR1 TO LCCAPGR2 */
          SPACE 2
         MVC   LCCAPGR2(L64),LCCAPGR1  MOVE SAVED REGISTERS INTO SAFE
*                                      AREA FROM RECURSIONS
          SPACE 2
*/* P MOVE PSW PIOPSW TO LCCAPPSW */
          SPACE 2
         MVC   LCCAPPSW(L8),FLCPOPSW   MOVE PSW TO SAFE AREA
          SPACE 2
*/* P MOVE ILC AND INT CODE TO LCCAPINT */
          SPACE 2
         L     WORKREG,FLCPIILC-C1     MOVE ILC AND INTERRUPT CODE
*                                      INTO REGISTER
         ST    WORKREG,LCCAPINT        SAVE ILC AND INTERRUPT CODE
*                                      INTO SAFE AREA
          SPACE 2
*/* P MOVE TRANS ADDR TO LCCAPVAD */
          SPACE 2
         L     WORKREG,FLCTEA          GET DAT EXCEPTION ADDRESS
         ST    WORKREG,LCCAPVAD        SAVE DAT EXCEPTION ADDRESS
*                                      REGISTERS 0,1,15 AS ON ENTRY
          SPACE 2
*/* D (NO,GTF1,YES,) IS TRACE TO BE DONE? */
          SPACE 2
         CLI   CVTTRACE+C1,CXFA        IS TRACE TO BE DONE
         BNE   GTF1                    IF NOT DONT TRACE
         L     XTRBASE,ATRPI           GET PI TRACE ENTRY ADDRESS
         L     WORKREG,CVTTRCA         GET TRACE HEADER        @ZA10452
         ST    WORKREG,FLCTRACE        RESTORE TRACE HEADER    @ZA10452
          SPACE 2
*/*TRACEEP: L TRACE-- VIA BALR 11,10 */
          SPACE 2
TRACEEP  DC    0H'0'                   TEST LABEL
         BALR  XTRET,XTRBASE           GO TO TRACE
          SPACE 2
*/*GTF1: L GTF-- HANDLE MC OR TRACE INTERRUPT */
          SPACE 2
GTF1     HOOK  EID=IEAPINT,TYPE=BP     GO HANDLE MC OR TRACE INTERRUPT
          SPACE 2
*/*MCPERTST: D (YES,GOBACK,NO,) WAS INTERRUPT ONLY PER/MC? */
          SPACE 2
MCPERTST DC    0H'0'                   TEST LABEL
         TM    LCCAPINT+C3,CX3F        WAS THERE AN INTERRUPT OTHER
*                                      THAN MC OR PER ONLY
         BZ    GOBACK                  IF NOT RETURN TO INTERRUPTED
*                                      PROGRAM
          SPACE 2
*/* P CLEAR PER BIT IN LCCAPINT */
          SPACE 2
         NI    LCCAPINT+C3,CXFF-PERCODE CLEAR PER IN INTERRUPT CODE
          SPACE 2
*/*DISTST1: D (YES,ERR1,NO,) PSW DISABLED? */
          SPACE 2
DISTST1  DC    0H'0'                   TEST LABEL
         TM    LCCAPPSW,CX03           WAS PSW DISABLED
         BC    M12,ERR1                IF SO PROCEED TO RECOVERY
          SPACE 2
*/*PGTST: D (YES,PAGEPR,NO,) PAGE FAULT? */
          SPACE 2
PGTST    DC    0H'0'                   TEST LABEL
         CLI   LCCAPINT+C3,PGCODE      IS INTERRUPT A PAGE FAULT
         BE    PAGEPR                  IF SO PROCESS
          SPACE 2
*/*PROGCK: D (YES,ERR1,NO,) SRB MODE? */
          SPACE 2
PROGCK   DS    0H
         TM    LCCADSF2,LCCASRBM       IS PROGRAM IN SRB MODE
         BO    ERR1                    IF SO PROCEED TO RECOVERY
          SPACE 2
*/*LTST1: L (YES,ERR1,NO,) SETLOCK-- ANY LOCKS HELD? */
          SPACE 2
LTST1    DC    0H'0'                   TEST LABEL
         SETLOCK TEST,TYPE=ALL,BRANCH=(HELD,ERR1),REGS=(WORKREG)
*                                      ANY LOCKS HELD?
          SPACE 2
*/*TCBERR1: P GET TCB ADDR FROM PSATOLD */
          SPACE 2
TCBERR1  DC    0H'0'                   TEST LABEL
         L     XTCBREG,PSATOLD         GET CURRENT TCB ADDRESS
         USING TCB,XTCBREG
          SPACE 2
*/* P MOVE LCCAPGR2 REGS TO TCBGRS */
          SPACE 2
         MVC   TCBGRS(L64),LCCAPGR2    MOVE REGS TO TCB SAVE AREA
          SPACE 2
*/* P GET RB ADDR FROM TCBRBP */
          SPACE 2
         L     RBPTR,TCBRBP            GET RB ADDRESS
         USING RBSECT,RBPTR
          SPACE 2
*/* P MOVE LCCAPPSW TO RBOPSW */
          SPACE 2
         MVC   RBOPSW(L8),LCCAPPSW     MOVE PSW TO RB SAVE AREA
          SPACE 2
*/*SPSTTST2: D (YES,ERR1,NO,) SUPV STATE? */
          SPACE 2
SPSTTST2 DC    0H'0'                   TEST LABEL
         TM    LCCAPPSW+C1,CX01        IS PROGRAM IN SUPERVISOR STATE
         BZ    ERR1                    IF SO PROCEED TO RECOVERY
         L     SCAREG,TCBPIE           GET PIE ADDRESS
         LA    SCAREG,C0(SCAREG)       CLEAR ANY STATUS BITS IN REG
          SPACE 2
*/*PIE2TST1: D (NO,ERR1,YES,) IS THERE A PIE? */
          SPACE 2
PIE2TST1 DC    0H'0'                   TEST LABEL
         LTR   SCAREG,SCAREG           IS THERE A PIE
         BZ    ERR1                    IF NOT PROCEED TO RECOVERY
          SPACE 2
         USING SCA,SCAREG
         L     XPIEREG,SCAPIE          GET ADDRESS OF PIE
         LA    XPIEREG,C0(XPIEREG)     CLEAR ANY HIGH ORDER BITS
          SPACE 2
*/*PIE2TST2: D (YES,ERR1,NO,) IS PIE ADDR ZER0? */
          SPACE 2
PIE2TST2 DC    0H'0'                   TEST LABEL
         LTR   XPIEREG,XPIEREG         IS PIE EXISTENT
         BZ    ERR1                    IF NOT PROCEED TO RECOVERY
          SPACE 2
*/* D (NO,SCAINIT,YES,) IS INTERRUPT PAGE FAULT OR SEG EXCEP? */
          SPACE 2
         TM    LCCAPINT+C3,CX10        IS INTERRUPT PAGE OR SEG CODE
         BZ    SCAINIT                 IF NOT DONT CONVERT
          SPACE 2
*/* P RESET INTERRUPT CODE TO X'04' AND ZERO ILC VALUE */
          SPACE 2
         MVI   LCCAPINT+C3,PRCODE      RESET TO PROTECTION
         MVI   LCCAPINT+C1,CX00        RESET ILC TO ZERO
          SPACE 2
*/*SCAINIT: P CLEAR SEG REC BIT */
          SPACE 2
SCAINIT  LA    XPIEREG,SCASRB          GET ADDRESS OF PIE/PICA SRB
         NI    LCCAIHR1,CXFF-LCCAPSG1  CLEAR SEG. REC. BIT IF ON
          SPACE 2
*/* P GET ASCB ADDR FROM PSAAOLD */
          SPACE 2
         L     ASCBREG,PSAAOLD         GET ASCB ADDRESS
         USING ASCB,ASCBREG
         USING SRBSECT,XPIEREG
          SPACE 2
*/* P PUT ASCB ADDR IN SRBASCB */
          SPACE 2
         ST    ASCBREG,SRBASCB         PLACE ASCB ADDRESS IN SRB
          SPACE 2
*/* P GET ASCBASID AND PUT IN SRBPASID */
          SPACE 2
         LH    WORKREG,ASCBASID        GET ASID VALUE FOR MEMORY
         STH   WORKREG,SRBPASID        PLACE ASID VALUE IN SRB
          SPACE 2
*/* P PUT TCB ADDR IN SRBPTCB */
          SPACE 2
         ST    XTCBREG,SRBPTCB         PLACE TCB ADDRESS IN SRB
          SPACE 2
*/* P PUT SRB ROUTINE ADDR IEAVPSRB IN SRBEP AND INDICATE SYSTEM
*/*PRIORITY */
          SPACE 2
         LA    WORKREG,IEAVPSRB        GET ROUTINE ENTRY POINT
         ST    WORKREG,SRBEP           PLACE ROUTINE ENTRY POINT IN SRB
         MVI   SRBPRIOR,CX00           INDICATE SYSTEM LEVEL SRB
          SPACE 2
*/* P GET ADDR OF SRBEND AND PUT IN SRBPARM */
          SPACE 2
         LA    WORKREG,SCAPARMS        GET ADDRESS OF PARMS
         ST    WORKREG,SRBPARM         STORE ADDRESS OF PARMS IN SRB
          SPACE 2
*/* P PUT RB ADDR IN AT END OF SRB(PARM) */
          SPACE 2
         ST    RBPTR,SCAPARMS          STORE RB ADDRESS IN SRB
          SPACE 2
*/* P PUT ILC AND INT CODE AFTER RB ADDR */
          SPACE 2
         L     WORKREG,LCCAPINT        GET ILC + INT. CODE VALUES
         ST    WORKREG,SCAPARMS+C4     STORE ILC AND INT CODE IN SRB
         MVC   SCAPARMS+C8(L8),LCCAPPSW MOVE PSW TO PARMS FIELD
          SPACE 2
*/* P SET TCB NON-DISP TCBPIEND=1 TCBDNSSP=1 */
          SPACE 2
         OI    TCBNDSP1,TCBPIEND       SET NON-DISP BIT FOR PIE/PICA
*                                      PROCESSING
         OI    TCBFLGS5,TCBPNDSP       SET NON-DISP SUMMARY BIT
         L     WORKREG,ASCBTCBS        LOAD VALUE OF READY TCBS
          SPACE 2
*/*DECTCBS: P DECREMENT COUNT OF READY TCBS VIA CS IN ASCBTCBS */
          SPACE 2
DECTCBS  LR    WORKREG2,WORKREG        TRANSFER VALUE TO REG
         BCTR  WORKREG2,C0             DECREMENT COUNT
CSINS1   DC    0H'0'                   TEST LABEL
         CS    WORKREG,WORKREG2,ASCBTCBS REPLACE OLD WITH NEW
         BC    M4,DECTCBS              IF UNEQUAL TRY AGAIN    @YM08215
*                                      XPIEREG=1
         DROP  XPIEREG
         DROP  SCAREG
          SPACE 2
*/*SCHED: L SCHEDULE-- SRB TO DO PIE/PICA PROCESS */
          SPACE 2
SCHED    SCHEDULE SRB=(1)              SCHEDULE SRB FOR PIE/PICA PROCES
          SPACE 2
*/*DISPRET: P MOVE CLOCK AND CLEAR PROGRAM FLIH BIT */
          SPACE 2
DISPRET  L     DISPRTN,AIEA0DS         GET DISPATCHER ENTRY ADDRESS
         L     WORKREG2,PSATOLD        HAS J.S.T. BEEN DONE?   @YM08398
         LTR   WORKREG2,WORKREG2       IF TOLD=0 IT HAS, SO    @YM08398
         BZ    CLRPBIT                 BYPASS MOVING CLOCK     @YM08398
         MVC   LCCAITOD,PSAPCPSW       MOVE CLOCK VALUE FOR JOB STEP
*                                      TIMING CALCULATIONS     @YM08398
CLRPBIT  NI    PSASUP1,CXFF-PSAPI      CLEAR PROGRAM FLIH BIT
          SPACE 2
*/*TCBXIT: R EXIT TO DISPATCHER */
          SPACE 2
TCBXIT   DC    0H'0'                   TEST LABEL
         BR    DISPRTN                 BRANCH TO DISPATCHER
          SPACE 2
*/*TRANS1: D (YES,LOADWAIT,NO,) TRANS RECURSION? */
          SPACE 2
TRANS1   TM    LCCAIHR1,LCCAPDAT       IS THIS A TRANSLATION RECURSION
*                                      MEANING MASTER MEMORY IS BAD
         BO    LOADWAIT                IF SO LOAD WAIT STATE
          SPACE 2
*/*STCTL1: P GET C.R.0 VALUE IN LCCACR0 */
          SPACE 2
STCTL1   DC    0H'0'                   TEST LABEL
         ENTRY IEADSS01
IEADSS01 STCTL CR0,CR0,LCCACR0         STORE C.R.0 FOR CHECKING
         NI    LCCACR0+C1,CXF8         TURN OFF BITS 13-15 FOR A
*                                      COMPARE
          SPACE 2
*/*DATBITS: D (YES,MASCHECK,NO,) IS CR 0  OK? */
          SPACE 2
DATBITS  DC    0H'0'                   TEST LABEL
         CLI   LCCACR0+C1,CR0MASK      ARE DAT BITS IN CR0 OK
         BE    MASCHECK                IF SO CHECK NEXT ACTION
          SPACE 2
*/*LCTL1: P (,DATENON) LOAD DEFAULT VALUE */
          SPACE 2
LCTL1    DC    0H'0'                   TEST LABEL
         LCTL  CR0,CR0,DFLCR0          LOAD DEFAULT CR0 VALUE
         LA    R1,COMPCOD1             GET UNIQUE COMP CODE
         B     DATENON
          SPACE 2
*/*TRANS3: D (YES,LOADWAIT,NO,) TRANSLATION RECURSION? */
          SPACE 2
TRANS3   TM    LCCAIHR1,LCCAPDAT       IS THIS A TRANSLATION RECURSION
*                                      MEANING MASTER MEMORY IS BAD
         BO    LOADWAIT                IF SO LOAD WAIT STATE
          SPACE 2
*/*MASCHECK: D (YES,MASMEM,NO,) IS THIS MASTER MEMORY? */
          SPACE 2
MASCHECK TM    LCCAIHR1,LCCAPSG1       IS MASTER BIT ON
         BO    MASMEM                  IF SO SWITCH TO MASTER
*                                      MEMORY
          SPACE 2
*/* P SET SEG RECURSION BIT */
          SPACE 2
         OI    LCCAIHR1,LCCAPSG1       SET MASTER BIT
         NI    PSASUP3,CXFF-PSAPI2-PSAPSREG
*                                      CLEAR RECURSION 2 BITS  @YM08516
         SR    R1,R1                   ZERO REG 1
         BCTR  R1,0                    DECREMENT REG 1 TO MINUS 1
          SPACE 2
*/*DATENON: P ENABLE PSW FOR DAT */
          SPACE 2
DATENON  STOSM LCCAPSMK,CX04           ENABLE DAT
         L     CCABASE,PSALCCAV        GET VIRTUAL ADDRESS OF LCCA
          SPACE 2
*/* D (NO,GTF2,YES,) IS TRACE TO BE DONE? */
          SPACE 2
ERR2     CLI   CVTTRACE+C1,CXFA        IS TRACE TO BE DONE   @ZA10452
         BNE   GTF2                    IF NOT DONT TRACE
          SPACE 2
*/* P GET CVTTRACE VALUE AND TRPIEP */
          SPACE 2
         MVC   FLCTRACE,CVTTRCA        REFRESH TRACE HEADER    @YA02352
         LR    WORKREG,R1              SAVE REG 1 VALUE(COMPCODE)
         L     R1,LCCAPGR1+C4          GET ORIGINAL REG 1 VAL FOR TRACE
         L     XTRBASE,ATRPI           GET PI TRACE ENTRY ADDRESS
          SPACE 2
*/*TRACEEP2: L EP=CVTTRACE--  BALR 11,10 */
          SPACE 2
TRACEEP2 DC    0H'0'                   TEST LABEL
         BALR  XTRET,XTRBASE           GO TO TRACE
         LR    R1,WORKREG              RESTORE COMPCODE VALUE
          SPACE 2
*/*GTF2: L (,ERR3) GTF-- RECORD INTERRUPT */
          SPACE 2
GTF2     HOOK  EID=IEATINT,TYPE=BP     GO TRACE TRANSLATION ERROR
          SPACE 2
*/*ERR3: L () CALL RTM-- TYPE=PROGCK SPECIAL E.P. NO RETURN */
          SPACE 2
ERR3     CALLRTM TYPE=PROGCK,COMPCOD=(R1) GO TO RTM
          SPACE 2
*/*TRANS2: D (YES,LOADWAIT,NO,) TRANSLATION RECURSION? */
          SPACE 2
TRANS2   DS    0H
         TM    LCCAIHR1,LCCAPDAT       IS THIS A TRANSLATION RECURSION
         BO    LOADWAIT                IF SO LOAD WAIT STATE
          SPACE 2
*/*MASMEM: P SET TRANSLATION RECURSION BIT */
          SPACE 2
MASMEM   OI    LCCAIHR1,LCCAPDAT       SET TRANSLATION RECURSION BIT
         NI    PSASUP3,CXFF-PSAPI2-PSAPSREG
*                                      CLEAR RECURSION 2 BITS  @YM08516
          SPACE 2
*/*LCTL2: P LOAD MASTER C.R.1 FROM LCCAMCR1 */
          SPACE 2
LCTL2    DC    0H'0'                   TEST LABEL
         LCTL  MASTER,MASTER,LCCAMCR1  LOAD MASTER MEMORY STOR REG
          SPACE 2
*/*DATENON2: P ENABLE PSW FOR DAT AND ZERO LCCAITOD */
          SPACE 2
DATENON2 DC    0H'0'                   TEST LABEL
         XC    LCCAITOD,LCCAITOD       ZERO LCCAITOD FOR J.S.T.@YM08398
         STOSM LCCAPSMK,CX04           ENABLE DAT              @YM30128
          SPACE 2
*/* D (NO,GTF3,YES,) IS TRACE TO BE DONE? */
          SPACE 2
         CLI   CVTTRACE+C1,CXFA        IS TRACE TO BE DONE
         BNE   GTF3                    IF NOT DONT TRACE
          SPACE 2
*/* P GET CVTTRACE VALUE AND TRPI EP */
          SPACE 2
         MVC   FLCTRACE,CVTTRCA        REFRESH TRACE HEADER    @YA02352
         L     XTRBASE,ATRPI           GET PI TRACE ENTRY ADDRESS
          SPACE 2
*/*TRACEEP3: L EP=CVTTRACE-- BALR 11,10 */
          SPACE 2
TRACEEP3 DC    0H'0'                   TEST LABEL
         BALR  XTRET,XTRBASE           GO TO TRACE
          SPACE 2
*/*GTF3: L GTF-- RECORD INTERRUPT */
          SPACE 2
GTF3     HOOK  EID=IEATINT,TYPE=BP     GO TRACE TRANSLATION ERROR
          SPACE 2
*/*DATERREP: L () CALL RTM-- TYPE=DATERR NO RETURN */
          SPACE 2
DATERREP DC    0H'0'                   TEST LABEL
         CALLRTM TYPE=DATERR           GO TO RTM
         EJECT
*/*PSAREF: P TRY TO RECOVER LOW CORE OVERLAY */
         SPACE 2
PSAREF   DS    0H                                              @YM08516
         SPACE 2
*/* D (YES,RECURS1,NO,) RECURSIVE ENTRY? */
         SPACE 2
         TM    PSASUP3,PSAPSREG        CHECK RECURSION FLAG    @YM08516
         BO    RECURS1                 WILL SWITCH TO MASTER   @YM08516
         SPACE 2
*/* P SET RECURSION FLAG */
         SPACE 2
         OI    PSASUP3,PSAPSREG   SET RECURSION FLAG ON        @YM08516
         SPACE 2
*/* P REFRESH CVT FROM V-CON */
         SPACE 2
         L     CVTREG,ADCVT       REFRESH CVT PTR              @YM08516
         ST    CVTREG,FLCCVT                                   @YM08516
         SPACE 2
*/*CPUPAREF: P REFRESH PSACPUPA */
         SPACE 2
CPUPAREF DS    0H                                              @YM08516
         L     TEMP1,CVTCSD       OBTAIN CSD ADDRESS           @YM08516
         LRA   TEMP1,CSDFLAGS-CSD(TEMP1)                       @YM08516
*                                 OBTAIN ADDRESS OF FLAG FIELD @YM08516
         BNZ   DATERR             CSDFLAGS ADDRESS IS NOT TRANSLATABLE
         TM    C0(TEMP1),CSDMP    CHECK IF ON MP               @YM08516
         BZ    UPCONFIG           ON UP                        @YM08516
         STAP  PSACPUPA           STORE CPU PHYSICAL ADDRESS   @YM08516
         B     LCCATCHK           CONTINUE VERIFYING LCCAT     @YM08516
UPCONFIG DS    0H                                              @YM08516
         XC    PSACPUPA(L2),PSACPUPA
*                                 CPU PHYSICAL ADDRESS = 0     @YM08516
         SPACE 2
*/*LCCATCHK: P (NE 0,DATERR,EQ 0,) LRA ON CVTLCCAT */
         SPACE 2
LCCATCHK DS    0H
         LH    TEMP1,PSACPUPA     OBTAIN PHYSICAL CPU ADDRESS  @YM08516
         SLL   TEMP1,C2           MULTIPLY BY 4                @YM08516
         L     TEMP0,CVTLCCAT     OBTAIN ADDRESS OF LCCAVT     @YM08516
         AR    TEMP0,TEMP1        ADDRESS LCCAT(PA)            @YM08516
         SPACE 2
*/* P (NE 0,DATERR,EQ 0,) LRA ON LCCAT(CPUPA) */
         SPACE 2
         LRA   TEMP1,0(TEMP0)     CHECK LCCAT(PA) **VIRTUAL**  @YM08516
         BNZ   DATERR             LCCAT(PA) NOT TRANSLATABLE   @YM08516
         L     TEMP0,0(TEMP1)          GET LCCA VIRT ADDR      @YM08516
         LRA   TEMP1,0(TEMP0)          CHECK LCCAV             @YM08516
         BNZ   DATERR                  LCCAV NOT TRANSLATABLE  @YM08516
         SPACE 2
*/*LCCACHK: D (NO,DATERR,YES,) LCCAR--> 'LCCA' ? */
         SPACE 2
LCCACHK  DS    0H
         CLC   LCCAEBC(L4),0(TEMP1)
*                                 CHECK FIRST WORD IS 'LCCA'   @YM08516
         BNE   DATERR
         SPACE 2
*/* P REFRESH PSALCCAV AND PSALCCAR */
         SPACE 2
         LM    R0,R1,PSALCCAV          GET OLD LCCA VALUES     @YM08516
         STM   R0,R1,LCCAPGR1-LCCA(TEMP1)
*                                      SAVE IN LCCAPGR1        @YM08516
         ST    TEMP0,PSALCCAV     REFRESH PSALCCAV             @YM08516
         ST    TEMP1,PSALCCAR     REFERSH PSALCCAR             @YM08516
         SPACE 2
*/* P REFRESH PSAPCCAV AND PSAPCCAR FROM PCCAT */
         SPACE 2
         LH    TEMP1,PSACPUPA    OBTAIN PHYSICAL CPU ADDRESS   @ZA03845
         SLL   TEMP1,C2           MULTIPLY BY 4                @YM08516
         L     TEMP0,CVTPCCAT          GET PCCAT ADDRESS       @YM08516
         AR    TEMP0,TEMP1                                     @YM08516
         LRA   TEMP1,0(TEMP0)                                  @YM08516
         BNZ   DATERR                                          @YM08516
         L     TEMP0,0(TEMP1)          CHECK PCCAT(PA)         @YM08516
         LRA   TEMP1,0(TEMP0)          CHECK PCCAV             @YM08516
         BNZ   DATERR                  PCCAV NOT TRANSLATABLE  @YM08516
         LM    R0,R1,PSAPCCAV          GET OLD PCCA VALUES     @YM08516
         ST    TEMP0,PSAPCCAV                                  @YM08516
         ST    TEMP1,PSAPCCAR                                  @YM08516
         SPACE 2
*/* P (,ERR3) SET UP TO GO TO RTM WITH X'4FC' CODE */
         SPACE 2
         STOSM PSAPIR2,CX04            ENABLE DAT              @YM08516
         L     CCABASE,PSALCCAV        ADDRESS LCCA            @YM08516
         STM   R0,R1,LCCAPGR1+C8       SAVE OLD PCCA VALUES    @YM08516
*                                           IN LCCAPGR1        @YM08516
         MVC   PSAPSAV,PSACSTK         SAVE CURRENT STACK      @YM08516
         MVC   PSACSTK,PSAPSTK         PROGRAM FLIH STACK      @YM08516
         OI    PSASUP1,PSAPI           TURN ON SUPER FLAG      @YM08516
         NI    PSASUP3,CXFF-PSAPI2-PSAPSREG
*                                      TURN OFF RECURS 2 BITS  @YM08516
         LA    R1,PCABCODE             SET COND CODE=X'4FC'    @YM08516
         B     ERR2                    GO TO RTM               @ZA10452
         SPACE 2
*/*RECURS1: P  LCTL MASTER'S C.R.1 */
         SPACE 2
RECURS1  DS    0H                                              @YM08516
         LCTL  MASTER,MASTER,PSASTOR  SWITCH TO MASTER'S C.R.1 @YM08516
         SPACE 2
*/*DATERR: P SET UP FOR DATERR */
         SPACE 2
DATERR   DS    0H
         L     CCABASE,PSALCCAR   SET UP FOR DAT ERROR         @YM08516
         OI    LCCAIHR1,LCCAPSG1                               @YM08516
         SPACE 2
*/* P (,MASMEM ) TERMINATE MEMORY */
         SPACE 2
         B     MASMEM              CONTINUE FLIH PROCESSING    @YM08516
         EJECT
*/*LOADWAIT: P SET UP LOGOUT AREA FOR SYSTEM TERMINATION */
         SPACE 2
LOADWAIT DS    0H                      SET UP FOR SYSTEM TERMINATION
         USING PCCA,PCCABASE
         L     PCCABASE,PSAPCCAR       ESTABLISH BASE TO PSA FROM PSA
         L     PARMREG,PCCALRBR        GET ADDRESS OF LOG REC BUFFER
         DROP  PCCABASE
         SPACE 2
*/* P MOVE WTO MESSAGE IEA999W INTO LOG OUT AREA */
         SPACE 2
         USING LOGOUT,PARMREG
         MVC   LOGWTOM(L60),MSG999W    MOVE MESSAGE INTO WTO AREA
         LA    WORKREG,LOGWTOM         PARM 1 = ADDR OF WTO MESSAGE
         ST    WORKREG,LOGWTOA
         SPACE 2
*/* P MOVE PERTINENT INFO INTO LOG REC BUFFER */
         SPACE 2
         LA    WORKREG,LOGLRB          PARM 2 = ADDR OF LOG REC BUFFER
         ST    WORKREG,LOGLRBA
         XC    LOGLHDR,LOGLHDR         CLEAR LRB HEADER
         MVI   LOGLRCDT,RCDTYPE        PUT RECORD TYPE IN HEADER
         LA    WORKREG,LOGLRBSZ        SIZE OF LRB IN HEADER
         ST    WORKREG,LOGLSIZE
         SPACE 2
*/* P LOAD WAIT STATE CODE = X'14' INTO LOG REC HEADER */
         SPACE 2
         LA    WORKREG,WAITCODE        WAIT-STATE CODE FOR SYSTEM TERM
         ST    WORKREG,LOGLCODE
         MVC   LOGLGPR(L64),LCCAPGR1   REGISTERS AT TIME OF INTERRUPT
         STCTL CR0,CR1,LOGLCR0         CONTROL REGS 0 AND 1
         MVC   LOGLOPSW,FLCPOPSW       PC FLIH OLD PSW
         MVC   LOGLILC(C4),PSAEPPSW    ILC AND INTERRUPT CODE
         MVC   LOGLTNEW(C16),PSATNEW   TNEW,TOLD,ANEW AND AOLD
         SPACE 2
*/* L () IGFPTERM-- GO TO SYSTEM TERMINATION ROUTINE */
         SPACE 2
         L     R15,SYSTERM             GET ADDR OF SYSTEM TERM. RTN
         BR    R15
         EJECT
*/*ERR1: P CLEAR PROGRAM FLIH BIT */
         SPACE 2
ERR1     NI    PSASUP1,CXFF-PSAPI      CLEAR PROGRAM FLIH BIT
         SPACE 2
*/* P RESTORE FRR STACK TO OLD CURRENT */
         SPACE 2
         L     WORKREG,PSAPSAV         GET SAVED STACK PTR
         ST    WORKREG,PSACSTK         MAKE SAVE PTR CURRENT
          SPACE 2
*/*ERR: L () CALLRTM-- TYPE=PROGCK NO RETURN */
         SPACE 2
ERR      CALLRTM TYPE=PROGCK           PROCEED TO RECOVERY
PIEREC   DS    0H
          SPACE 2
*/*BADPIE: P CLEAR SUPER SPIE RECUR BIT AND SEGMENT RECUR
*/*BIT */
          SPACE 2
BADPIE   NI    LCCAIHR1,CXFF-LCCAPPIE-LCCAPSG1  CLEAR PIE RECURSION
*                                      AND SEGMENT REC BITS
         NI    PSASUP3,CXFF-PSAPI2-PSAPSREG
*                                      CLEAR RECURSION 2 BITS  @YM08516
         B     PGSUPER                 GO TO PAGING SUPERVISOR
          SPACE 2
*/*PAGEPR: D (YES,PGSUPER,NO,SPSTTST1) SRB MODE? */
          SPACE 2
PAGEPR   DS    0H
SRBTST1  DC    0H'0'                   TEST LABEL
         TM    LCCADSF2,LCCASRBM       IS PROGRAM IN SRB MODE
         BZ    SPSTTST1                IF NOT, CONTINUE CHECKING
         B     PGSUPER                 IF SO PROCEED TO PAGING SUPV.
          SPACE 2
*/*SPSTTST1: D (YES,PGSUPER,NO,) SUPV STATE? */
          SPACE 2
SPSTTST1 DC    0H'0'                   TEST LABEL
         TM    LCCAPPSW+C1,CX01        IS PROGRAM IN SUPV. STATE
         BZ    PGSUPER                 IF SO PROCEED TO PAGING SUPV.
          SPACE 2
*/* P GET TCB ADDR FROM PSATOLD */
          SPACE 2
         L     XTCBREG,PSATOLD         GET TCB ADDRESS
         USING TCB,XTCBREG
          SPACE 2
*/*SUPSPCK: D (YES,SUPSPIE,NO,) EXTENDED PICA? */
          SPACE 2
SUPSPCK  DC    0H'0'                   TEST LABEL
         TM    TCBFLGS6,TCBPIE17       IS THERE AN EXTENDED PICA
         BO    SUPSPIE                 IF SO GO HANDLE SPIE @ZA11376
          SPACE 2
*/*PGSUPER: L IEAPIX-- RETURN REG14 */
          SPACE 2
PGSUPER  L     R15,AIEAPIX             GET ADDRESS OF PAGING SUPV.
PGSPEP   DC    0H'0'                   TEST LABEL
         BALR  R14,R15                 BR TO IEAPIX
          SPACE 2
*/*IEAVEPXR: P REESTABLISH ADDRESSABILITY */
          SPACE 2
         ENTRY IEAVEPXR
IEAVEPXR DS    0H                      RETURN FROM IEAPIX
         USING *,R14
         L     BASEREG,AADDRESS        GET ORIGINAL ADDRESSABILITY ADD.
         DROP  R14                     REESTABLISH
         USING ADDRESS,BASEREG         ADDRESSABILITY
          SPACE 2
*/* P RELOAD LCCA FROM PSALCCAV */
          SPACE 2
         L     CCABASE,PSALCCAV        RELOAD LCCA ADDRESS
          SPACE 2
*/*SUSPTST: D (YES,DISPRET,NO,) WAS USER SUSPENDED? */
          SPACE 2
SUSPTST  DC    0H'0'                   TEST LABEL
         LTR   RTCDREG,RTCDREG         WAS PROGRAM SUSPENDED
         BZ    DISPRET                 IF SO EXIT TO DISPATCHER
          SPACE 2
*/*RCTST: D (=4,GOBACK,=8,PROGCK,=12,PIXABD) CHECK RETURN CODE FROM
*/*IEAPIX */
          SPACE 2
RCTST    DC    0H'0'                   TEST LABEL
         LA    WORKREG,EIGHT           LOAD COMPARE VALUE
         CR    RTCDREG,WORKREG         CHECK RETURN CODE FROM IEAPIX
         BL    GOBACK                  RC = 4: PAGE WAS RECLAIMED
         BE    PROGCK                  RC = 8: INVALID PAGING EXCEPTION
         BH    PIXABD                  RC =12: ERROR IN PIX PROCESSING
          SPACE 2
*/*GOBACK: P MOVE LCCAPPSW TO PIOPSW */
          SPACE 2
GOBACK   MVC   PSAPCPSW(L8),LCCAPPSW   MOVE BACK TO PROGRAM OLD
*                                      PSW TO ALLOW FOR LPSW
          SPACE 2
*/* P LOAD ALL REGS FROM LCCAPGR2 */
          SPACE 2
         LM    R0,R15,LCCAPGR2         RESTORE ALL REGS
          SPACE 2
*/* P CLEAR PROGRAM FLIH BIT AND RESTORE STACK */
          SPACE 2
         NI    PSASUP1,CXFF-PSAPI      CLEAR PROGRAM BIT
         MVC   PSACSTK(4),PSAPSAV      RESTORE SAVED STACK PTR
          SPACE 2
*/*RCRTN: R EXIT VIA LPSW ON PIOPSW */
          SPACE 2
RCRTN    DC    0H'0'                   TEST LABEL
         LPSW  PSAPCPSW                RETURN TO INTERRUPTED PROGRAM
          SPACE 2
*/*PIXABD: P LOAD ALL REGS FROM LCCAPGR2 */
          SPACE 2
PIXABD   DS    0H                      IF RC >8, ABEND
         LM    R0,R15,LCCAPGR2         RESTORE ALL REGS
          SPACE 2
*/* P CLEAR PROGRAM FLIH BIT AND RESTORE THE STACK */
          SPACE 2
         NI    PSASUP1,CXFF-PSAPI      CLEAR PROGRAM BIT
         MVC   PSACSTK(4),PSAPSAV      RESTORE SAVED STACK PTR
         SPACE 2
*/* L () ABEND-- ABEND THE TASK WITH CODE X'028' */
         SPACE 2
         LA    PARMREG,PIXABEND        PUT PIX ABEND CODE IN REG 1
         ABEND (1),DUMP,,SYSTEM        ABEND THE TASK
          SPACE 2
*/*SUPSPIE: P GET PIE ADDRESS FROM THE TCB */
          SPACE 2
SUPSPIE  L     SCAREG,TCBPIE           GET PTR TO PIE ADDRESS
         LA    SCAREG,C0(SCAREG)       CLEAR ANY STAUS BITS IN REG
          SPACE 2
*/*PIETST1: D (YES,PGSUPER,NO,) IS TCBPIE = 0? */
          SPACE 2
PIETST1  DC    0H'0'                   TEST LABEL
         LTR   SCAREG,SCAREG           IS PTR TO PIE ADDRESS ZERO
         BZ    PGSUPER                 IF SO PROCEED TO HANDLE PAGE
*                                      FAULT
         USING SCA,SCAREG
         L     XPIEREG,SCAPIE          GET PIE ADDRESS
         LA    XPIEREG,C0(XPIEREG)     CLEAR ANY STATUS BITS IN REG
          SPACE 2
*/*PIETST2: D (YES,PGSUPER,NO,) IS PIE ADDR ZERO? */
          SPACE 2
PIETST2  DC    0H'0'                   TEST LABEL
         LTR   XPIEREG,XPIEREG         IS PIE ADDRESS 0
         BZ    PGSUPER                 IF SO PROCEED TO HANDLE PAGE
*                                      FAULT
*        FROM  HERE SUSEPTABLE TO PAGE FAULTS
         SPACE 2
*/* P SET PIE RECURSION BIT LCCAPPIE = 1 */
         SPACE 2
         OI    LCCAIHR1,LCCAPPIE       SET PIE RECURSION BIT
         USING PIE,XPIEREG
         L     XPIPICA,PIEPICA         GET PICA ADDRESS FROM PIE
          SPACE 2
*/*PIETST3: D (YES,BADPIE,NO,) IS PICA 0 OR PIE BUSY? */
          SPACE 2
PIETST3  DC    0H'0'                   TEST LABEL
         LTR   XPIPICA,XPIPICA         IS PIE BUSY OR NO PICA
         BNP   BADPIE                  IF SO PROCEED TO HANDLE PAGE
*                                      FAULT
         USING PICA,XPIPICA
          SPACE 2
*/*PIETST4: D (NO,BADPIE,YES,) IS PICA EXTENDED? */
          SPACE 2
PIETST4  DC    0H'0'                   TEST LABEL
         TM    PICITMK1,PICAEXT        IS PICA EXTENDED
         BNO   BADPIE                  IF NOT PROCEED TO HANDLE PAGE
*                                      FAULT
          SPACE 2
*/*PIETST5: D (NO,BADPIE,YES,) CAN PAGE FAULT BE HANDLED? */
          SPACE 2
PIETST5  DC    0H'0'                   TEST LABEL
         TM    PICITMK3,PICACD17       CAN PAGE FAULT BE HANDLED
         BNO   BADPIE                  IF NOT PROCEED TO HANDLE PAGE
*                                      FAULT
          SPACE 2
*/* P SET PROTECT KEY = TCB KEY */
          SPACE 2
         IC    WORKREG,TCBPKF          GET TCB PROTECT KEY
         SPKA  0(WORKREG)              SET PROTECT KEY TO USER KEY
          SPACE 2
*/* P MOVE USER REGS 14-2 TO PIEGR14- PIEGR2 */
          SPACE 2
         MVC   PIEGR14(L8),LCCAPGR2+C56 MOVE REGS 14 AND 15 TO PIE
         MVC   PIEGR0(L12),LCCAPGR2    MOVE REGS 0-2 TO PIE
          SPACE 2
*/* P BUILD BC MODE PSW AND PVT IN PIEPSW */
          SPACE 2
         MVC   PIEPSW(L8),LCCAPPSW     MOVE EC MODE PSW TO PIEPSW
         LH    WORKREG,LCCAPINT+C2     GET INTERRUPT CODE
         STH   WORKREG,PIEPSW+C2       STORE INTERRUPT CODE
         IC    R10,LCCAPPSW+C2         GET C.C. AND PROC. MASK
         IC    WORKREG,LCCAPINT+C1     GET ILC CODE
         SLL   WORKREG,FIVE            MOVE ILC TO HIGH ORDER BITS
         OR    R10,WORKREG             PUT TOGETHER ILC+CC+ PROG MASK
         STC   R10,PIEPSW+C4           STORE IN PIE PSW
          SPACE 2
*/* P GET PICAEXIT FROM PICA */
          SPACE 2
         L     R15,PICAEXIT            GET ADDRESS OF USER EXIT
         LA    R15,C0(R15)             CLEAR HIGH ORDER BYTE
          SPACE 2
*/* P GET PICAPRMK VALUE FROM PICA */
          SPACE 2
         IC    WORKREG,PICAPRMK        GET PROG MASK IN PICA
          SPACE 2
*/* P SET PIE BUSY BIT PIENOPI = 1 */
          SPACE 2
         OI    PIEPICA,PIENOPI         SET PIE BUSY BIT THIS MUST BE
*                                      DONE LAST IN PIE/PICA PROCESS
*                                      FOR EXTENDED PICA DUE TO POSS-
*                                      IBLE RECURSION
*        THIS COMPLETES SUSEPTABILITY TO PAGE FAULTS, CAN NOW UPDATE
*        REGISTER SAVE AREA
         DROP  XPIEREG
         DROP  XPIPICA
         DROP  SCAREG
         SPKA  ZERO                    RESET PROTECT KEY TO ZERO
          SPACE 2
*/* P CLEAR SUPER SPIE REC BIT */
          SPACE 2
         NI    LCCAIHR1,CXFF-LCCAPPIE  CLEAR PIE RECURSION BIT
         ST    R15,LCCAPGR2+C60        PUT USER EXIT ADDRESS IN SAVE
*                                      AREA
          SPACE 2
*/* P PUT PICAEXIT IN LCCAPGR2 (REG15) AND RIGHT SIDE OF LCCAPPSW */
          SPACE 2
         ST    R15,LCCAPPSW+C4         PUT EXIT ADDRESS IN PSW
          SPACE 2
*/* P PUT PROG MASK OF PICAPRMK IN LCCAPPSW */
          SPACE 2
         STC   WORKREG,LCCAPPSW+C2     PUT PICA MASK INTO PSW
         NI    LCCAPPSW+C2,CX3F        CLEAR HIGH BITS OF PROG MASK BYTE
                                       OF PSW
          SPACE 2
*/* P PUT TCBPKF IN LCCAPPSW FOR SPIE EXIT */
    SPACE 2
* SPIE EXIT RECEIVES CONTROL IN TCB KEY SINCE SPIES ARE    @ZA11376
*       TASK RELATED                                       @ZA11376
    SPACE 2
        MVZ   LCCAPPSW+C1(L1),TCBPKF   PUT TCB KEY IN PSW     @ZA11376
    SPACE 2
*/* P POINT REG 14 TO SVC 3 IN FRONT OF PROG FLIH */
          SPACE 2
         L     WORKREG,ASVC3           GET RETURN ADDRESS FOR EXIT
         ST    WORKREG,LCCAPGR2+C56    PUT RETURN ADDRESS IN SAVE ADDA
          SPACE 2
*/* P PUT PIE ADDR IN REG 1 OF LCCAPGR2 */
          SPACE 2
         ST    XPIEREG,LCCAPGR2+C4     PUT PIE ADDRESS IN SAVE AREA R1
          SPACE 2
*/* P PUT VIRT ADDR IN REG 0 OF LCCAPGR2 */
          SPACE 2
         L     WORKREG,LCCAPVAD        GET VIRTUAL ADDRESS ADDRESS
         ST    WORKREG,LCCAPGR2        PUT VIRTUAL ADDRESS ADDRESS IN
*                                      REG 0
          SPACE 2
*/* P MOVE LCCAPPSW TO PIOPSW */
          SPACE 2
         MVC   PSAPCPSW(L8),LCCAPPSW   MOVE SAVED PSW TO PI OLD TO
*                                      DO LPSW
          SPACE 2
*/* P LOAD ALL REGS FROM LCCAPGR2 */
          SPACE 2
         LM    R0,R15,LCCAPGR2         GET ALL REGS
          SPACE 2
*/* P CLEAR PROGRAM FLIH BIT */
          SPACE 2
         NI    PSASUP1,CXFF-PSAPI      CLEAR PROGRAM FLIH BIT
         MVC   PSACSTK(4),PSAPSAV      RESTORE SAVED STACK PTR
          SPACE 2
*/*SUPSPXIT: R EXIT VIA LPSW ON PIOPSW */
          SPACE 2
SUPSPXIT DC    0H'0'                   TEST LABEL
         LPSW  PSAPCPSW                GO DIRECTLY TO USER EXIT
         DROP  CCABASE
         DROP  RBPTR
         EJECT
***********************************************************************
*                                                                     *
*                    CONSTANTS & STORAGE                              *
*                                                                     *
***********************************************************************
         EXTRN IEACVT
ADCVT    DC    A(IEACVT)               ADDRESS OF CVT
         EXTRN TRPI
ATRPI    DC    A(TRPI)                 PI TRACE ENTRY POINT
IEACON1  DC    V(AHLMCIH)              GTF ENTRY POINT
         EXTRN IEA0DS
AIEA0DS  DC    A(IEA0DS)               DISPATCHER MAIN ENTRY POINT
         EXTRN IEAVPIX
AIEAPIX  DC    A(IEAVPIX)              PAGING SUPERVISOR ENTRY POINT
AADDRESS DC    A(ADDRESS)              ADDRESS TO REESTABLISH ADD.
CLEARBIT DS    0F
         DC    X'000000F0'             MASK USED TO TURN OFF BITS
DISAWAIT DS    0D                      WAIT STATE PSW WITH WAIT STATE
         DC    XL8'000E000000000014'   CODE OF 14
DFLCR0   DC    X'C080EC40'             DEFAULT CR 0 FOR TRANSLATION
         EXTRN IGFPTERM
SYSTERM  DC    V(IGFPTERM)             ADDR SYSTEM TERM RTN
LCCAEBC  DC    CL4'LCCA'               EBCDIC FOR LCCA         @YM08516
MSG999W  WTO   'IEA999W ADDRESS TRANSLATION ERROR IN MASTER MEMORY  ', *
               ROUTCDE=(2),DESC=(1),MF=L
          TITLE 'IEAVEPC- SRB ROUTINE (IEAVPSRB)'
*/*IEAVPSRB: E IEAVPSRB */
          SPACE 2
         ENTRY IEAVPSRB
IEAVPSRB DS    0H
          SPACE 2
*/* P ESTABLISH ADDRESSABILITY */
          SPACE 2
         BALR  BASEREG,C0              ESTABLISH
         USING *,BASEREG               ADDRESSABILITY
         LR   TEMPREG,RETREG           SAVE RETURN REGISTER    @YM30620
          SPACE 2
*/*OBTAINLL: L SETLOCK-- OBTAIN LOCAL UNCOND */
          SPACE 2
OBTAINLL SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,RELATED=('LOCK IS OBTAIN*
               ED TO PREVENT IRB TO BE QUEUED FOR TCBS IN THIS ASCB',IE*
               AVEPC(EXIT1))           GET LOCAL LOCK
          SPACE 2
*/* L SETFRR--  SET UP RECOVERY */
          SPACE 2
         SETFRR A,FRRAD=ASRBERR,PARMAD=(2),WRKREGS=(3,4) SETUP RECOVERY
          SPACE 2
*/* D (NO,EXIT1,YES,) IS TCB NON-DISP? */
          SPACE 2
         LR    XSRBREG,R0              GET SRB ADDRESS
         USING SRBSECT,XSRBREG
         L     XTCBREG,SRBPTCB         GET TCB ADDRESS
         ST    XTCBREG,C0(,R2)         PASS TCB ADDRESS TO FRR @ZA06785
         USING TCB,XTCBREG
         TM    TCBNDSP1,TCBPIEND       IS TCB STILL NON-DISP
         BNO   EXIT1                   IF NOT EXIT
          SPACE 2
*/* P GET PIE ADDR AND PICA ADDR */
          SPACE 2
         L     SCAREG2,TCBPIE          GET ADDRESS OF PIE ADDRESS
         USING SCA,SCAREG2
         L     XPIEREG2,SCAPIE         GET PIE ADDRESS
         SPACE 2                                               @ZA31350
*/* P SET PROTECT KEY = TCB'S KEY  */
         SPACE 2                                               @ZA31350
         IC    WORKREG,TCBPKF          GET TCB PROTECT KEY     @ZA31350
         SPKA  0(WORKREG)              SET PROTECT KEY TO USER @ZA31350
         SPACE 2                                               @ZA31350
         USING PIE,XPIEREG2
         L     XPICAREG,PIEPICA        GET PICA ADDRESS FROM PIE
         SPACE 2                                               @ZA31350
*/* P SET PROTECT KEY = 0  */
         SPACE 2                                               @ZA31350
         SPKA  ZERO                    SET PROTECT KEY TO 0    @ZA31350
          SPACE 2
*/* D (YES,TERMINAT,NO,) IS PIE BUSY OR PICA=0? */
          SPACE 2
         LTR   XPICAREG,XPICAREG       IS PIE BUSY OR PICA ADDRESS = 0
         BNP   TERMINAT                IF EITHER ABTERM TCB
         SPACE 2                                               @ZA31350
*/* P SET PROTECT KEY = TCB'S KEY  */
         SPACE 2                                               @ZA31350
         SPKA  0(WORKREG)              SET PROTECT KEY TO USER @ZA31350
         SPACE 2                                               @ZA31350
*/* P GET INTERRUPT MASK FROM PICA  */
         SPACE 2                                               @ZA31350
         USING PICA,XPICAREG
         L     R0,PICAITMK             GET INTRPT MASK FROM PICA
         SPACE 2                                               @ZA31350
*/* P SET PROTECT KEY = 0  */
         SPACE 2                                               @ZA31350
         SPKA  ZERO                    RESET PROTECT KEY TO 0  @ZA31350
          SPACE 2
*/* D (NO,TERMINAT,YES,) CAN INTERRUPT BE HANDLED? */
          SPACE 2
         LH    WORKREG1,SCAPARMS+C6    GET INTRPT CODE FROM SRB
         SLL   R0,C0(WORKREG1)         SHIFT TO ALIGN INTRPT MASK BIT
*                                      FOR THIS INTERRUPT IN HIGHER
*                                      ORDER BIT
         LTR   R0,R0                   CAN INTERRUPT BE HANDLED
         BNM   TERMINAT                IF NOT ABTERM TCB
          SPACE 2
*/* D (YES,REGSFND,NO,) IS THIS THE TOP RB? */
          SPACE 2
         L     WORKREG1,TCBRBP         GET ADDRESS OF TOP RB
         LA    WORKREG3,TCBGRS         GET ADDRESS OF REG.SAVE AREA
         C     WORKREG1,SCAPARMS       IS TOP RB THE ONE BEING SER-
*                                      VICED
         BE    REGSFND                 IF SO CONTINUE PROCESS
          SPACE 2
*/* P CHAIN DOWN RB UNTIL RB BEING SERVICED IS FOUND */
          SPACE 2
         USING RBSECT,WORKREG1
NEXTRB   LA    WORKREG3,RBGRSAVE       GET ADDRESS OF REG SAVE AREA
         L     WORKREG1,RBLINK         GET NEXT RB ADDRESS
         C     WORKREG1,SCAPARMS       IS NEXT RB THE ONE BEING SER-
*                                      VICED
         BNE   NEXTRB                  IF NO TRY AGAIN
          SPACE 2
*/*REGSFND: P SET PROTECT KEY = TCB'S KEY */
          SPACE 2
REGSFND  EQU   *                                               @ZA31350
         SPKA  0(WORKREG)              SET PROTECT KEY TO USERS
          SPACE 2
*/* P MOVE REGS 0,1,2,14 & 15 TO PIE */
          SPACE 2
         MVC   PIEGR14(L8),C56(WORKREG3) MOVE REGS 14 AND 15 TO PIE
         MVC   PIEGR0(L12),C0(WORKREG3) MOVE REGS 0-2 TO PIE
          SPACE 2
*/* P CONSTRUCT PSW IN PIE */
          SPACE 2
         MVC   PIEPSW(L8),SCAPARMS+C8  MOVE PSW AT INTERRUPT TO PIEPSW
         LH    WORKREG4,SCAPARMS+C6    GET INTERRUPT CODE
         STH   WORKREG4,PIEPSW+C2      STORE INTERRUPT CODE
         IC    WORKREG4,RBOPSW+C2      GET C.C. AND PROR MASK
         IC    WORKREG,SCAPARMS+C5     GET ILC CODE
         SLL   WORKREG,FIVE            MOVE ILC TO HIGH ORDER BITS
         OR    WORKREG4,WORKREG        PUT TOGETHER ILC+CC+PROG MASK
         STC   WORKREG4,PIEPSW+C4      STORE IN PIE PSW
          SPACE 2
*/* P SET PIE BUSY BIT */
          SPACE 2
         OI    PIEPICA,PIENOPI         SET PIE BUSY BIT
         SPACE 2
*/* P GET ADDRESS OF USER EXIT FROM PICA  */
         SPACE 2
         L     WORKREG4,PICAEXIT       GET ADDRESS OF USER EXIT
          SPACE 2
*/* P SET PROTECT KEY = 0 */
          SPACE 2
         SPKA  ZERO                    RESET PROTECT KEY TO ZERO
          SPACE 2
*/* P STORE USER EXIT ADDR AND RETURN ADDR IN SAVE AREA */
          SPACE 2
         LA    WORKREG4,C0(WORKREG4)   CLEAR HIGH ORDER BYTE
         ST    WORKREG4,C60(WORKREG3)  PUT USER EXIT ADDRESS IN SAVE
*                                      AREA
         ST    WORKREG4,RBOPSW+C4      PUT EXIT ADDRESS IN PSW
         SPACE 2
*/* P PUT TCBPKF IN RBOPSW FOR SPIE EXIT ROUTINE */
         SPACE 2
* SPIE EXIT RECEIVES CONTROL IN TCBKEY SINCE SPIES ARE TASK @ZA11376
*        RELATED                                            @ZA11376
         SPACE 2
         MVZ   RBOPSW+C1(L1),TCBPKF    PUT KEY IN RB FOR SPIE @ZA11376
         L     WORKREG4,ASVC3          GET RETURN ADDRESS FOR EXIT
         ST    WORKREG4,C56(WORKREG3)  PUT RETURN ADDRESS IN SAVE AREA
         SPACE 2
*/* P SET PROTECT KEY = TCB'S KEY  */
         SPACE 2
         IC    WORKREG4,TCBPKF         GET TCB PROTECT KEY     @ZA31350
         SPKA  0(WORKREG4)             SET PROTECT KEY TO USER @ZA31350
         SPACE 2
*/* P GET PROGRAM MASK FROM PICA  */
         SPACE 2
         IC    WORKREG4,PICAPRMK       GET PICA PROGRAM MASK   @ZA31350
         SPACE 2
*/* P SET PROTECT KEY = 0  */
         SPACE 2
         SPKA  ZERO                    RESET PROTECT KEY TO 0  @ZA31350
         SPACE 2
*/* P PUT PROGRAM MASK IN RBOPSW FOR SPIE EXIT ROUTINE  */
         SPACE 2
         STC   WORKREG4,RBOPSW+C2      STORE PROG MASK IN RB   @ZA31350
         NI    RBOPSW+C2,CX3F          CLEAR PROG MASK
          SPACE 2
*/* P (,EXIT2) SAVE PIE ADDRESS */
          SPACE 2
         ST    XPIEREG2,C4(WORKREG3)   PUT PIE ADDRESS IN SAVE AREA R1
         B     EXIT2                   BRANCH TO EXIT
          SPACE 2
*/*TERMINAT: P SET UP COMPLETION CODE */
          SPACE 2
TERMINAT LH    WORKREG1,C6(PARMREG)    GET COMPLETION CODE
         LA    WORKREG1,CXC0(WORKREG1) PUT 'C' IN FRONT OF COMP CODE
          SPACE 2
*/* L (,EXIT1) CALL RTM-- ABTERM */
          SPACE 2
         CALLRTM TYPE=ABTERM,COMPCOD=(WORKREG1),TCB=(XTCBREG)
         B     EXIT1                   BRANCH TO EXIT
          SPACE 2
*/*EXIT2:  P SET TCB  DISPATCHABLE */
          SPACE 2
EXIT2    LA    R0,ELEVEN               INDICATE SECONDARY NON-DISP
         LR    R1,XTCBREG              GET TCB ADDRESS FOR STATUS
         O     R1,HIGHON               SET HIGH ORDER BIT ON-RESET
         L     CVTREG,FLCCVT           GET CVT ADDRESS
         USING CVT,CVTREG
         L     CVTREG,CVTABEND         GET SECONDARY CVT ADDRESS
         USING SCVTSECT,CVTREG
         L     EPREG,SCVTSTAT          GET ENTRY POINT ADD. OF STATUS
         LA    R13,TCBPIEND            PUT NON-DISP BIT IN REG
         SLL   R13,C16                 MOVE BIT INTO RIGHT POSITION
         BALR  RETREG,EPREG
         SPACE 2
*/*EXIT1: L SETFRR-- REMOVE RECOVERY */
         SPACE 2
EXIT1    SETFRR D,WRKREGS=(3,4)        CLEAR FRR ELEMENT
         DROP  XSRBREG
         DROP  WORKREG1
          SPACE 2
*/* L SETLOCK-- RELEASE LOCAL */
          SPACE 2
         SETLOCK RELEASE,TYPE=LOCAL,RELATED=('PROCESS ON RB CHAIN IS CO*
               MPLETE',IEAVEPC(OBTAINLL)) CLEAR LOCAL LOCK
          SPACE 2
*/* R EXIT */
          SPACE 2
         BR    TEMPREG                 EXIT
***********************************************************************
*                                                                     *
*                     CONSTANTS & STORAGE                             *
*                                                                     *
***********************************************************************
ASVC3    DC    A(PROGSVC3)             SVC 3 INSTRUCTION ADDRESS
HIGHON   DC    X'80000000'             HIGH BIT ON IN WORD
ASRBERR  DC    A(SRBERR)          ADDRESS OF SRB ERROR FRR
         TITLE 'IEAVEPC- SRB ERROR FRR'
         SPACE 2
*/*SRBERR: E ENTRY SRB FRR */
*/* P GET CURRENT TCB ADDRESS (R4=TCB@) */
*/* S IEAVSPER: PROCESS SPIE ERROR */
*/* L SETRP-- CHANGE COMP CODE RELEASE LOCAL LOCK */
*/* P NOTE: CONTINUE WITH ABEND AND PERCOLATE TO NEXT LEVEL OF RECOVERY
*/* */
*/* R RETURN */
         SPACE 2
SRBERR   DC    0H'0'
*                                 **********SRB ERROR FRR**********
*                                 GO PROCESS PIE/PICA ERROR @ZA06785
*                                      CHANGE COMPLETION CODE
*                                      RELEASE LOCAL LOCK
*                                      CONTINUE WITH ABEND
*                                      PERCOLATE TO NEXT RECOVERY LEVEL
         USING *,R15                   ESTABLISH BASE         @ZA06785
         USING SDWA,R1                 ESTABLISH SDWA         @ZA06785
         LR    R5,R14                  SAVE RETURN ADDRESS
         L     R4,SDWAPARM             GET PARMLIST ADDRESS @ZA06785
         L     R4,C0(,R4)              GET CURRENT TCB ADDRESS @ZA06785
         LA    R9,IEAVSPER             GET SPIE ERR RTN ADDR @ZA06785
         BALR  R11,R9                  GO TO SPIE ERR RTN  @ZA06785
         SETRP DUMP=YES,RC=0,COMPCOD=(SRBERRCC,SYSTEM),FRELOCK=(LOCAL)
         LR    R14,R5                  RESTORE RETURN ADDRESS
         BR    R14                     RETURN TO CALLER
         EJECT
*/*IEAVSPER: E ENTRY SPIE ERROR RTN */
*/* D (NO,PIEBAD,YES,) SCA ADDRESS ERROR */
*/* P PUT BAD SCA IN SDWA */
*/*RECORD: L SETRP  RECORD ERROR */
*/* R RETURN TO CALLER */
*/*PIEBAD: P (,RECORD) PUT BAD PIE IN SDWA */
          SPACE 2
*        IEAVSPER IS GIVEN CONTROL WHENEVER PROGRAM FLIH OR @ZA06785
*        PROGRAM MANAGER DETECTS AN INVALID PIE OR PICA. THIS @ZA06785
*        ROUTINE WILL RECORD THE CONTENTS OF THE SCAPIE FIELD @ZA06785
*        IN THE FIRST TWELVE BYTES OF VARIABLE RECORDING AREA @ZA06785
*        IN THE SDWA AFTER A LABEL "SCAPIE= ". IF THE TCBPIE  @ZA06785
*        FIELD IS FOUND TO BE INVALID IT WILL BE RECORDED     @ZA06785
*        FOLLOWING THE LABEL "TCBPIE= "                       @ZA06785
*
*       INPUT: R1= ADDRESS OF SDWA                           @ZA06785
*              R4= ADDRESS OF TCB                            @ZA06785
*              R9= ENTRY POINT ADDRESS                       @ZA06785
*              R11= RETURN ADDRESS                           @ZA06785
*
*        REGISTERS DESTROYED: 2,3,8,12                       @ZA06785
         SPACE 2
IEAVSPER DS  0H                                              @ZA06785
         ENTRY IEAVSPER                                      @ZA06785
         USING *,R9                   ESTABLISH BASE         @ZA06785
         USING SDWA,R1                ADDRESSABILITY TO SDWA @ZA06785
         USING SCA,R3                 ADDRESSABILITY TO SCA  @ZA06785
         SR    R2,R2                  CLEAR WORK REGISTER    @ZA06785
         SR    R8,R8                  DITTO                  @ZA06785
         IC    R8,SDWAURAL            GET LENGTH OF USED VRA @ZA06785
         LA    R12,C12(R8)            ADD LENGTH OF NEW RECORD @ZA06785
         STC   R12,SDWAURAL           UPDATE FIELD IN SDWA    @ZA06785
         OI    SDWADPVA,SDWAHEX       INDICATE DUMP IN HEX    @ZA06785
         LA    R12,SDWAVRA(R8) GET ADDRESS OF NEXT RECORD    @ZA06785
CHKSCA   LRA   R3,TCBPIE-TCB(R4)  Q.SCA ADDRESS TRANS ERROR  @ZA06785
         BZ    PIEBAD             A. NO ERRORS               @ZA06785
         MVC   ZERO(L8,R12),VRAHDR1   PUT HEADER IN VRA      @ZA06785
         MVC   C8(L4,R12),TCBPIE-TCB(R4) PUT BAD SCA IN VRA  @ZA06785
         ST    R2,TCBPIE-TCB(R4)      ZERO SCA POINTER       @ZA06785
RECORD SETRP RECORD=YES,COMPCOD=(SPIERR,SYSTEM) RECORD ERROR @ZA06785
         BR    R11                    RETURN TO CALLER        @ZA06785
PIEBAD   EQU   *                                              @ZA06785
         L     R3,TCBPIE-TCB(R4)      GET SCA ADDRESS         @ZA06785
         MVC   ZERO(L8,R12),VRAHDR2   PUT HEADER IN VRA       @ZA06785
         MVC   C8(L4,R12),SCAPIE      PUT PIE ADDRESS IN VRA  @ZA06785
         ST    R2,SCAPIE              CUT PIE CHAIN           @ZA06785
         B     RECORD                 GO RECORD ERROR         @ZA06785
       EJECT
********************************************************************
*                                                                  *
*                      CONSTANTS AND STORAGE            @ZA06785   *
*                                                                  *
********************************************************************
       SPACE 2
VRAHDR1 DC    CL8'TCBPIE= '    BAD SCA HEADER             @ZA06785
VRAHDR2 DC    CL8'SCAPIE= '    BAD PIE HEADER             @ZA06785
SPIERR  EQU   X'6FC'           SPIE ERROR CODE            @ZA06785
        EJECT
         TITLE 'IEAVEPC- SUSPEND ROUTINE (IEAVSUSP)'
         ENTRY IEAVSUSP
          SPACE 2
*/*IEAVSUSP: E IEAVSUSP */
          SPACE 2
IEAVSUSP DS    0H
          SPACE 2
*/* P SAVE REGS IN SPECIAL GLOBAL LOCK AREA FOR SUSPEND/RESET */
          SPACE 2
         STM   R0,R15,C0(R13)          SAVE ALL REGISTERS
          SPACE 2
*/* P ESTABLISH ADDRESSABILITY */
          SPACE 2
         BALR  BASEREG,C0              ESTABLISH
         USING *,BASEREG               ADDRESSABILITY
          SPACE 2
*/* P GET LCCA ADDRESS */
          SPACE 2
         L     CCABASE,PSALCCAV        GET LCCA ADDRESS
         USING LCCA,CCABASE
          SPACE 2
*/* P GET ASCB ADDR FROM PSAOLD */
          SPACE 2
         L     ASCBBASE,PSAAOLD        GET CURRENT ASCB ADDRESS
         USING ASCB,ASCBBASE
          SPACE 2
*/* D (YES,SRBPRSS,NO,) SRB MODE? */
          SPACE 2
         TM    LCCADSF2,LCCASRBM       IS SRB MODE INDICATED
         BO    SRBPRSS                 IF SO GO PROCESS
          SPACE 2
*/* P GET TCB ADDR FROM PSATOLD */
          SPACE 2
         L     XTCBREG,PSATOLD         GET CURRENT TCB ADDRESS
         USING TCB,XTCBREG
          SPACE 2
*/* P GET RB ADDR FROM TCBRBP */
          SPACE 2
         L     RBPTR,TCBRBP            GET RB ADDRESS
          SPACE 2
*/* P GET PAGE FAULT ADDR FROM LCCAPVAD AND STORE IN RB */
          SPACE 2
         LA    WORKREG3,RBSECT-RBRTRAN GET OFFSET IN PREFIX
         SR    RBPTR,WORKREG3          GET TO RBRTRAN LABEL
         L     WORKREG1,LCCAPVAD       GET PAGE FAULT ADDRESS
         ST    WORKREG1,C0(RBPTR)      PUT ADDRESS IN RBRTRAN
         AR    RBPTR,WORKREG3          GET ADDRESS OF RB BACK
         USING RBSECT,RBPTR
          SPACE 2
*/* L (NO,NOLOCAL,YES,) SETLOCK-- IS LOCAL LOCK HELD? */
          SPACE 2
         SETLOCK TEST,TYPE=LOCAL,BRANCH=(NOTHELD,NOLOCAL)
*                                      IS LOCAL LOCK HELD?
          SPACE 2
*/* P GET ASXB ADDRESS FROM ASCBASXB */
          SPACE 2
         L     ASXBREG,ASCBASXB         GET ASXB ADDRESS
         USING ASXB,ASXBREG
          SPACE 2
*/* P GET IHSA ADDR FROM ASXBIHSA */
          SPACE 2
         L     IHSAREG,ASXBIHSA        GET IHSA ADDRESS
         USING IHSA,IHSAREG
          SPACE 2
*/* P MOVE REGS FROM LCCAPGRL TO IHSAGPRS */
          SPACE 2
         MVC   IHSAGPRS(L64),LCCAPGR2  MOVE REGS SAVE AT PAGE FAULT
*                                      TIME INTO IHSA SAVE AREA
          SPACE 2
*/* P MOVE PSW FROM LCCAPPSW TO IHSACPSW AND MOVE CLOCK TO LCCAITOD */
          SPACE 2
         MVC   IHSACPSW(L8),LCCAPPSW   MOVE PSW SAVE AT PAGE FAULT
*                                      TIME INTO IHSA SAVE AREA
         MVC   LCCAITOD,PSAPCPSW       MOVE CLOCK FOR J.S.T.   @YM08398
         DROP  IHSAREG
          SPACE 2
*/* P SET LOCAL LOCK HELD BIT IN TCB */
          SPACE 2
         OI    TCBFBYT1,TCBLLH         SET LOCAL LOCK HELD BIT
          SPACE 2
*/* P (,SUSPEND) PUT 4 IN REG 6 TO INDICATE NON-QUIESCE SRB TO RUN */
          SPACE 2
         LA    SCHLREG,FOUR            INDICATE NON-QUIESCABLE SRB
*                                      TO BE SCHEDULED TO DO PAGE I/O
         SR    R1,R1                   CLEAR REG 1 FOR SUSPEND ROUTINE
         B     SUSPEND                 GO SET UP FOR COMMON SUSPEND RTN
          SPACE 2
*/*NOLOCAL: P MOVE REGS FROM LCCAPGR2 TO TCBGRS */
          SPACE 2
NOLOCAL  MVC   TCBGRS(L64),LCCAPGR2    MOVE REGS TO TCB
          SPACE 2
*/* P MOVE PSW FROM LCCAPPSW TO RBOPSW */
          SPACE 2
         MVC   RBOPSW(L8),LCCAPPSW     MOVE PSW TO RB
         SR    WORKREG1,WORKREG1       ZERO REG
          SPACE 2
*/* P INCREMENT RB WAIT COUNT */
          SPACE 2
         IC    WORKREG1,RBWCF          GET WAIT COUNT
         LA    WORKREG1,C1(WORKREG1)   ADD ONE TO COUNT
         STC   WORKREG1,RBWCF          PUT WAIT COUNT BACK
          SPACE 2
*/* P ZERO REG 6 TO INDICATE SYSTEM LEVEL SRB TO RUN */
          SPACE 2
         SR    SCHLREG,SCHLREG         INDICATE QUIESCABLE SRB TO BE
*                                      SCHEDULED TO DO  PAGE I/O
         L     WORKREG,ASCBTCBS        LOAD VALUE OF READY TCBS
          SPACE 2
*/*DECTCBS2: P (,EXIT3) DECREMENT COUNT OF READY TCBS */
          SPACE 2
DECTCBS2 LR    WORKREG3,WORKREG        TRANSFER VALUE
         BCTR  WORKREG3,C0             DECREMENT COUNT
         CS    WORKREG,WORKREG3,ASCBTCBS REPLACE OLD WITH NEW
         BC    M4,DECTCBS2             IF UNEQUAL,TRY AGAIN    @YM08215
         LTR   WORKREG3,WORKREG3      NUMBER READY TCBS=0? @ZD04015
         BNZ   EXIT3                NO,BRANCH TO EXIT    @ZD04015
         LH    WORKREG3,ASCBSWCT     GET WAIT COUNT       @ZD04015
         LA    WORKREG3,1(WORKREG3)       INCREMENT COUNT  @ZD04015
         STH   WORKREG3,ASCBSWCT         SAVE NEW WAIT COUNT  @ZD04015
         B     EXIT3                   BRANCH TO EXIT
          SPACE 2
*/*SRBPRSS: P GET CPID VALUE SRB00 IN REG 0 */
          SPACE 2
SRBPRSS  L     CPIDREG,IDFIELD         GET GETCELL CELL POOL ID
          SPACE 2
*/* L GETCELL-- GET SRB-SAVE AREA CELL */
          SPACE 2
         GETCELL CPID=(CPIDREG),BRANCH=YES,SAVE=NO GET SRB CELL
          SPACE 2
*/* D (YES,CELLSOK,NO,) CELL OBTAINED OK? */
          SPACE 2
         LTR   RTCDREG,RTCDREG         WAS CELL OBTAINED
         BZ    CELLSOK                 IF SO GO PROCESS
          SPACE 2
*/* P SET UP ADDRESSABILITY TO THE PVT */
          SPACE 2
         USING PVT,PVTPTR                                      @YM07664
         L     CVTREG2,FLCCVT      GET THE ADDRESS OF THE CVT  @YM07664
*                                  GET THE ADDRESS OF THE PVT  @YM07664
         L     PVTPTR,CVTPVTP-CVTMAP(0,3)                      @YM07664
         SPACE 2
*/* D (NO,SUSPABD,YES,) IS THE PVTSSRB AVAILABLE? */
         SPACE 2
         TM    PVTFLAG1,PVTSIT     CHECK IF PVTSSRB REPLENISH INDICATOR
*                                  IS ON, MEANING NO SSRB AVAILABLE
         BO    SUSPABD             NO AVAILABLE SSRB -- ABEND  @YM07664
          SPACE 2
*/* P USE THE SSRB CHAINED OUT OF THE PVT TO STORE STATUS */
          SPACE 2
         OI    PVTFLAG1,PVTSIT     SET PVTSSRB REPLENISH FLAG  @YM07664
         L     SRBCRREG,PVTSSRB    USE PVTSSRB TO STORE STATUS @YM07664
         DROP  PVTPTR
          SPACE 2
*/* P SET FREEMAIN INDICATOR IN THE SSRB */
          SPACE 2
         USING SRBSECT,SRBCRREG
         LA    R15,SSRBMAIN            SET BIT IN SSRB SO THAT FREEMAIN
*                                      IS DONE RATHER THAN FREECELL
          SPACE 2
*/*CELLSOK: P STORE PAGE FAULT ADDRESS INTO SSRB AND SET MODE OF
*/*RELEASE */
          SPACE 2
CELLSOK  STC   R15,SSRBFLG1            INDICATE HOW AREA IS TO BE FREED
         L     WORKREG1,LCCAPVAD       GET PAGE FAULT ADDRESS
         ST    WORKREG1,SSRBTRAN       PUT ADDRESS IN SSRB
          SPACE 2
*/* P MOVE LCCAPGR2 TO SRBGPRS */
          SPACE 2
         MVC   SSRBGPRS(L64),LCCAPGR2  MOVE REGS TO SRB SAVE AREA
          SPACE 2
*/* P MOVE LCCAPSW TO SRBCPSW */
          SPACE 2
         MVC   SSRBCPSW(L8),LCCAPPSW   MOVE PSW TO SRB SAVE AREA
          SPACE 2
*/* P ZERO REG 5 TO INDICATE SRB */
*/* P REG 4 = PTR(SRB CELL) */
          SPACE 2
         LR    R4,SRBCRREG             SET UP PARM REG 4
         SR    R5,R5                   ZERO PARM REG 5
         SPACE 2
*/* P INDICATE UNLOCKED SRB IN REG 6 */
         SPACE 2
         LA    SCHLREG,EIGHT           INDICATE UNLOCKED SRB SUSPENDED
          SPACE 2
*/* L (NO,SUSPEND,YES,) SETLOCK-- IS LOCAL LOCK HELD? */
          SPACE 2
         SETLOCK TEST,TYPE=LOCAL,BRANCH=(NOTHELD,SUSPEND)
*                                      LOCAL LOCK HELD?
         SPACE 2
*/* P INDICATE LOCAL LOCK HELD IN REG 6 */
         SPACE 2
         LA    SCHLREG,FOUR            INDICATE LOCAL LOCK IS HELD
         SPACE 2
*/*SUSPEND: P REG 12 = ADDR COMMON SUSPEND RTN REG 15 = RETURN ADDR */
*/* L IEAVSPCR-- SUSPEND AND STATUS SAVE */
         SPACE 2
SUSPEND  L     R12,ASPCR               GET ADDRESS COMMON SUSPEND RTN
         BALR  R15,R12                 COMMON RTN PERFORMS SUSPEND
          SPACE 2
*/*EXIT3: P RESTORE ALL REGS EXCEPT PARMS 4,5,6 */
          SPACE 2
EXIT3    DS    0H
         LM    R0,R3,C0(R13)           RESTORE
         LM    R7,R15,C28(R13)         REGISTEGS
         DROP  SRBCRREG
         DROP  ASCBBASE
         DROP  CCABASE
          SPACE 2
*/* R RETURN VIA BR 14 */
          SPACE 2
         BR    RETREG                  RETURN TO CALLER
         SPACE 4
*/*SUSPABD: L () ABEND-- ABEND THE TASK WITH CODE X'028' */
         SPACE 2
SUSPABD  LA    PARMREG,PIXABEND    PUT PIX ABEND CODE IN REG 1 @YM07664
         ABEND (1),DUMP,,SYSTEM                                @YM07664
***********************************************************************
*                                                                     *
*                      CONSTANTS & STORAGE                            *
*                                                                     *
***********************************************************************
         DS    0F                      ALIGN TO FCELL POOL ID TO FWORD
IDFIELD  DS    0CL4                    CELL POOL ID
         DC    C'SRB'                  SRB SAVE AREA CELL POOL ID
         DC    X'00'                   SRB SAVE AREA CELL POOL ID
         EXTRN IEAVSPCR
ASPCR    DC    V(IEAVSPCR)             COMMON SUSPEND ROUTINE
         TITLE 'IEAVEPC- RESET ROUTINE (IEAVRSET)'
         ENTRY IEAVRSET
          SPACE 2
*/*IEAVRSET: E IEAVRSET */
          SPACE 2
IEAVRSET DS    0H
          SPACE 2
*/* P SAVE REGS IN SPECIAL GLOBAL LOCK AREA FOR SUSPEND/RESET */
          SPACE 2
         STM   R0,R15,C0(R13)          SAVE ALL REGS
          SPACE 2
*/* P ESTABLISH ADDRESSABILITY */
          SPACE 2
         BALR  BASEREG,C0              ESTABLISH
         USING *,BASEREG               ADDRESSABILITY
          SPACE 2
*/* D (NO,NOERR,YES,) ERROR DETECTED? */
          SPACE 2
         LTR   ERREG,ERREG             WAS ERROR DETECTED IN I/O PROC.
         BZ    NOERR                   CONTINUE NORMALLY
          SPACE 2
*/* L CALLRTM-- TYPE= PGIOERR */
          SPACE 2
         LR    WORKREG1,R13            SAVE SAVE AREA VALUE
         L     R13,FLCCVT              GET CVT ADDRESS
         L     R13,CVTSPSA-CVT(R13)    GET SAVE AREA VECTOR TABLE ADD
         L     R13,WSAGPGIO-WSAG(R13)  GET PGIOERR SAVE AREA ADD
         CALLRTM TYPE=PGIOERR          LET RTM HANDLE ERROR
         LR    R13,WORKREG1            RESTORE SAVE AREA POINTER
          SPACE 2
*/*NOERR: D (YES,SCHSRB,NO,) SRB MODE? */
          SPACE 2
NOERR    LTR   SRBREG,SRBREG           WAS SRB SUSPENDED
         BZ    SCHSRB                  IF SO GO SCHEDULE
          SPACE 2
*/* P GET TCB ADDRESS FROM REG 4 */
          SPACE 2
         USING TCB,XTCBREG
          SPACE 2
*/* D (NO,NOLLH,YES,) WAS LOCAL LOCK HELD? */
          SPACE 2
         TM    TCBFBYT1,TCBLLH         WAS TCB LOCALLY LOCKED
         BZ    NOLLH                   IF NOT PROCEED TO POST
          SPACE 2
*/* P CLEAR TCBLLH */
          SPACE 2
         NI    TCBFBYT1,CXFF-TCBLLH    CLEAR LOCAL LOCK HELD BIT
          SPACE 2
*/* P (,REXIT) CHANGE SUSPEND ID TO INTERRUPT ID */
          SPACE 2
         L     ASCBREG,PSAAOLD         GET ASCB ADDRESS
         USING ASCB,ASCBREG
         OI    ASCBLOCK,CX80           SET HIGH ORDER BIT OF LOCAL LOCK
*                                      WHICH IS NOW INTERRUPT ID
         B     REXIT                   EXIT
          SPACE 2
*/*NOLLH: P GET RB ADDR FROM REG 5 */
          SPACE 2
NOLLH    DS    0H
         USING RBSECT,RBPTR
          SPACE 2
*/* D (YES,REXIT,NO,) WAIT COUNT = 0? */
          SPACE 2
         CLI   RBWCF,CX00              IS WAIT COUNT ZERO
         BE    REXIT                   IF SO,THEN FINISHED
          SPACE 2
*/* L (,REXIT) POST-- W/O ECB FOR RB */
          SPACE 2
         LR    R10,RBPTR               PUT RB ADDRESS IN REG FOR POST
         SR    R11,R11                 ZERO REG 11 FOR POST NO ECB
         L     EPREG,APOST             GET POST ENTRY POINT
         LR    R1,R13                  SAVE REG 13 VALUE
         BALR  RETREG,EPREG            GO TO POST NO-ECB
         LR    R13,R1                  RESTORE SAVE AREA ADDRESS
         B     REXIT                   GET OUT
          SPACE 2
*/*SCHSRB: L SCHEDULE-- SRB=(REG 4) LOCAL SPL PRIOR=NONQ */
          SPACE 2
SCHSRB   SCHEDULE SRB=(R4)             SCHEDULE SRB SAVE CELL
          SPACE 2
*/*REXIT: P RESTORE ALL SAVED REGISTERS */
          SPACE 2
REXIT    DS    0H
         LM    R0,R15,C0(R13)          RESTORE ALL REGISTERS
          SPACE 2
*/* R RETURN VIA BR 14 */
          SPACE 2
         BR    RETREG                  RETURN TO CALLER
          SPACE 2
*/* FOOTING
*/*
*/*  */
*/*IEAVEPC: END PC FLIH */
          SPACE 2
***********************************************************************
*                                                                     *
*                       CONSTANTS & STORAGE                           *
*                                                                     *
***********************************************************************
          EXTRN IEA0PT01
APOST    DC    A(IEA0PT01)             POST ENTRY ADDRESS
         TITLE 'IEAVEPC- PSA MAPPING'
         IHAPSA
         TITLE 'IEAVEPC- LCCA DSECT MAPPING'
         IHALCCA
         TITLE 'IEAVEPC- ASCB DSECT MAPPING'
         IHAASCB
         TITLE 'IEAVEPC- ASXB DSECT MAPPING'
         IHAASXB
         TITLE 'IEAVEPC- IHSA DSECT MAPPING'
         IHAIHSA
         TITLE 'IEAVEPC- SSRB DSECT MAPPING'
         IHASSRB
         TITLE 'IEAVEPC- RB DSECT MAPPING'
         IKJRB
         TITLE 'IEAVEPC- TCB DSECT MAPPING'
         IKJTCB
         TITLE 'IEAVEPC- SCA DSECT MAPPING'
         IHASCA
         TITLE 'IEAVEPC- PIE DSECT MAPPING'
         IHAPIE
         TITLE 'IEAVEPC- PICA DSECT MAPPING'
         IHAPICA
         TITLE 'IEAVEPC- FRRS DSECT MAPPING'
         IHAFRRS
         TITLE 'IEAVEPC- WSAVT DSECT MAPPING'
         IHAWSAVT DSECT=YES,CLASS=GLOBAL
         TITLE 'IEAVEPC- CVT DSECT MAPPING'
         CVT   DSECT=YES,PREFIX=NO,LIST=YES
         TITLE 'IEAVEPC- SCVT DSECT MAPPING'
         IHASCVT LIST=YES
         TITLE 'IEAVEPC- SDWA DSECT MAPPING'
         IHASDWA
         TITLE 'IEAVEPC- PCCA DSECT MAPPING'
         IHAPCCA
         TITLE 'IEAVEPC - PVT DSECT MAPPING'
         IHAPVT
         TITLE 'IEAVEPC - CSD DSECT MAPPING'
         IHACSD
         TITLE 'IEAVEPC- LOGOUT DSECT MAPPING'
LOGOUT   DSECT MAPPING OF LOG OUT AREA FOR SYS TERM
LOGWTOA  DS    A                  ADDRESS WTO MESSAGE
LOGLRBA  DS    A                  ADDRESS LOG REC BUFFER
LOGWTOM  DS    CL60               WTO MESSAGE
         DS    0F                 ALLIGN TO FULL WORD BDRY
LOGLRB   DS    0CL132             LOG REC BUFFER
LOGLHDR  DS    0CL32              LOG REC BUFFER HEADER
LOGLRCDT DS    CL1                RECORD TYPE
LOGLRES  DS    CL23               RESERVED BYTES FOR HEADER
LOGLSIZE DS    F                  SIZE OF LOG REC BUFFER
LOGLCODE DS    F                  WAIT-STATE CODE FOR SYSTEM TERMINAT'N
LOGLGPR  DS    CL64               GENERAL REGS AT TIME OF INTERRUPT
LOGLCR0  DS    F                  CONTROL REG 0
LOGLCR1  DS    F                  CONTROL REG 1
LOGLILC  DS    CL1                INSTR LENGTH COUNTER
LOGLINT  DS    CL1                INTERRUPT CODE
LOGLOPSW DS    D                  PROG FLIH OLD PSW
LOGLTNEW DS    A                  T-NEW
LOGLTOLD DS    A                  T-OLD
LOGLANEW DS    A                  A-NEW
LOGLAOLD DS    A                  A-OLD
LOGEND   EQU   *                  END OF LOG OUT AREA
LOGLRBSZ EQU   LOGEND-LOGLRB      SIZE OF LOG REC PORTION
LOGSIZE  EQU   LOGEND-LOGOUT      SIZE OF ENTIRE LOG OUT AREA
         END
