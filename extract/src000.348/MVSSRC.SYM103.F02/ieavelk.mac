         TITLE 'IEAVELK-LOCK MANAGER ROUTINES'
* /* START OF SPECIFICATIONS ****
*
*01*  MODULE-NAME = IEAVELK
*
*02*     CSECT-NAME = IEAVELK
*
*01*  DESCRIPTIVE-NAME = SETLOCK SERVICE ROUTINE
*
*01*  COPYRIGHT = NONE
*
*01*  STATUS = VERSION 1
*
*01*  FUNCTION = PROVIDES A MEANS OF SYNCHRONIZING AND CONTROLLING
*     ACCESS TO THE SYSTEMS SERIALLY REUSABLE RESOURCES.
*
*02*     OPERATION = A LOCK IS OBTAINED BY INSERTING IN THE LOCKWORD
*        THE LOGICAL CPU ID OF THE REQUESTOR CPU (OR THE ADDRESS SPACE
*        ID FOR THE CMS LOCK), USING THE COMPARE AND
*        SWAP INSTRUCTION TO MAKE SURE THAT THE LOCKWORD CURRENTLY
*        CONTAINS A FULLWORD OF ZEROES. THE LOCK IS RELEASED BY
*        REPLACING THE CURRENT ID WHICH IS IN THE LOCK BY A FULLWORD OF
*        ZEROES, USING AN ORDINARY STORE INSTRUCTION. WHEN A LOCK IS
*        OBTAINED OR RELEASED, A BIT IS TURNED ON OR OFF IN A BIT
*        STRING ASSOCIATED WITH THE REQUESTING CPU. THIS STRING
*        CONTAINS ONE BIT PER TYPE OF LOCK IN A PREDEFINED HIERARCHICAL
*        ORDER. AT OBTAIN TIME THIS STRING IS USED TO MAKE SURE THAT
*        THE REQSTR DOES NOT VIOLTE THE HIERCHY & AT RELEASE   @Z40FPXJ
*        TIME IT IS USED TO DETERMINE WHETHER THE REQUESTOR MUST BE
*        RETURNED CONTROL ENABLED OR DISABLED. FOR THOSE LEVELS WHERE
*        THERE IS MORE THAN ONE LOCK (E.G.: IOSUCB,TPNCB,...) A CPU
*        LOCKS HELD TABLE, CONTAINING ONE WORD PER LEVEL IN THE
*        HIERARCHY, IS USED TO KEEP TRACK OF WHICH LOCK IS HELD AT THIS
*        LEVEL.  THERE ARE TWO TYPES OF LOCKS, SPIN AND SUSPEND. IF AN
*        UNCONDITIONAL REQUEST IS ISSUED FOR AN UNAVALIABLE SPIN LOCK,
*        THE LOCK ROUTINE WILL ENTER A SPIN LOOP UNTIL THE LOCK BECOMES
*        AVALIABLE. THIS LOOP OPENS A WINDOW FOR EMERGENCY SIGNALS AND
*        MALFUNCTION ALERTS. IF AN UNCONDITIONAL REQUEST IS ISSUED FOR
*        AN UNAVALIABLE SUSPEND LOCK, THE CALLER WILL BE SUSPENDED
*        (STATUS SAVED) AND CONTROL WILL RETURN TO THE DISPATCHER TO
*        SELECT ANOTHER AVALIABLE READY UNIT OF WORK. SPECIFIC RETURN
*        CODES AND REQUIREMENTS ARE DESCRIBED IN THE ENTRY POINT
*        DESCRIPTION.
*
*01*   NOTES = REFERENCE ENTRY POINTS.
*
*02*     DEPENDENCIES = LISTED ARE THE FOLLOWING DEPENDENCIES -
*     1.  SYSGEN - THE FOLLOWING AREAS MUST BE INITIALIZED IN EACH CPUS
*     PSA BEFORE ANY SETLOCK REQUESTS CAN BE ISSUED.
*          1.1 - THE 13 FULLWORD CPU LOCKS HELD TABLE, PSACLHT, MUST BE
*          INITIALIZED TO ZEROS.
*          1.2 - THE 1 FULLWORD CPU LOCKS HELD STRING, PSAHLHI,
*          MUST BE INITIALIZED TO X''00000000''.
*          1.3 - THE 16 FULLWORD SETLOCK REGISTER SAVE AREA MUST BE
*          INITIALIZED TO ZEROS.
*          1.4 - A MODEL PSW, PSAMPSW, MUST BE INITIALIZED TO
*          X''000C000000000000''.
*          1.5 - THE ADDRESS OF SETLOCKS LOCK INTERFACE TABLE, PSALITA,
*          MUST BE INITIALIZED TO THE ADDRESS OF IEAVELIT.
*          1.6 - A QUICKCELL POOL FOR SETLOCK/PGM CHECK FLIH TO GET
*          SUSPENSION SRBS MUST BE INITIALIZED.
*          1.7 - ANY PRE-ASSEMBLED ASCBS MUST HAVE FIELDS INITIALIZED
*          AS DESCRIBED IN MEMORY CREATE, 3.
*
*     2.  NIP - NIP MUST INITIALIZE THE PSACPULA AS FOLLOWS -
*          2.1 - THE LOGICAL CPU ADDRESS, PSACPULA, MUST BE INITIALIZED
*          TO THE PHYSICAL CPU ADDRESS AND ORD WITH A X''0040''.
*
*     3.  MEMORY CREATE - THE 3 FULLWORDS IN THE ASCB USED AS  @Z40FPXJ
*     THE LOCAL LOCK, THE LOCAL SRB SUSPEND QUEUE, AND THE CMS @Z40FPXJ
*     FOWARD POINTER/MUST BE INITIALIZED TO ZERO.              @Z40FPXJ
*
*     4.  VARY CPU ONLINE - SAME AS NIP.
*
*     5.  IOS - MUST INITIALIZE ITS IOS LOCKS TO ZERO PRIOR TO ANY
*     SETLOCK REQUESTS AGAINST THEM.
*
*     6.  ASM - MUST INITIALIZE ITS LOCK TO ZERO PRIOR TO ANY SETLOCK
*     REQUESTS AGAINST IT.
*
*     7.  ATCAM - MUST INITIALIZE ITS TP LOCKS TO ZERO PRIOR TO ANY
*     SETLOCK REQUESTS AGAINST THEM.
*
*     8.  DISPATCHER - MUST PROVIDE THE FOLLOWING.
*          8.1 - AN SRB ACTIVE INDICATOR IN THE LCCA,
*          (LCCADSF2/LCCASRMB).  THE CPU AFFINITY, LCCASAFN, AND PURGE
*          ASID/TCB ADDRESS, LCCAPGTA, ARE STORED IN THE CPUS LCCA WHEN
*          EVER A SRB IS DISPATCHED.
*          8.2 - THE ASCB ADDRESS OF THE CURRENTLY ACTIVE MEMORY IN THE
*          PSA, PSAAOLD.
*          8.3 - THE SRB SCHEDULING FUNCTION.  THIS INCLUDES THE
*          FREEING OF THE SUSPENDED SRB WHEN IT IS DISPATCHED.
*          8.4 - A DISPATCHER ENTRY POINT THAT CAN BE BRANCHED TO BY
*          THE SETLOCK SERVICE ROUTINE FOR THE FOLLOWING CASES.
*                8.4.1 - SUSPENSION OF A LOCAL LOCK REQUEST BY A TCB
*                CONTROLLED PROGRAM  DISPATCHER MUST SAVE - FPRS,
*                JOB STEP TIMING INFORMATION.  DISPATCHER ENTRY POINT =
*                IEA0DS.
*                8.4.2 - SUSPENSION OF A LOCAL LOCK REQUEST BY AN SRB
*                OCNTROLLED PROGRAM.
*                DISPATCHER ENTRY POINT
*                = IEAPDS2.
*                8.4.3 - SUSPENSION OF A CMS LOCK REQUEST BY A TCB
*                CONTROLLED PROGRAM.
*                DISPATCHER ENTRY POINT = IEAPDS2.
*                8.4.4 - SUSPENSION OF A CMS LOCK REQUEST BY AN SRB
*                CONTROLLED PROGRAM.  SAME AS 8.4.2.
*          8.5 - THE DISPATCHER  HAS SUPPLIED A COMMON SAVE STATUS
*          ROUTINE(IEAVSPCR) WHOSE CODE IS CONTAINED HEREIN FOR
*          SUSPENDED SRBS AND LOCALLY LOCKED TCBS. DOCUMENTSTION OF THE
*          INTERFACE CAN BE FOUND IN THE DISPATCHER SPECIFICATIONS AND
*          AT THE ENTRY POINT BELOW
*
*     9.  ACR MUST PROVIDE THE FOLLOWING-
*          9.1 - A ''THIS CPU IS IN ACR MODE'' INDICATOR.
*          9.2 - THE LOGICAL CPU ADDRESS OF THE CPU THAT ACR IS
*          RECOVERING.
*          9.3 - AN ENTRY POINT FOR SETLOCK TO BRANCH TO ACR FOR THE
*          CASE WHERE THE CPU OWNING A LOCK OR A HIGHER LOCK THAN
*          THE ONE SETLOCK IS ATTEMPTING TO ACQUIRE FAILS.
*          9.4 - SAVE ALL OF SETLOCKS SERIAL RESOURCES (REGISTER SAVE
*          ARE, PSALKSA, PSACLHT,PSAHLHI) FOR THE CASE WHERE
*          SETLOCK DOES ENTER ACR AND ACR IS GOING TO GIVE CONTROL TO
*          FRRS WHICH WILL THEMSELVES ISSUE SETLOCK REQUESTS.
*
*    10. - QUICKCELL - MUST PROVIDE A BRANCH ENTRY INTERFACE AND MUST
*    BE ABLE TO PERFORM ITS PROCESSING WITHOUT ISSUING A
*    SETLOCK REQUEST.
*
*    11. - EXTERNAL FIRST LEVEL INTERRUPT HANDLER - MUST TEST THE
*    SETLOCK ''WINDOW SPIN'' INDICATOR WHEN ENTERED AND IF ON
*    MUST RETURN CONTROL TO THE POINT OF INTERRUPTION UPON COMPLETION
*    OF ITS INTERRUPT PROCESSING.
*
*    12. - SETLOCK IS RESTRICTED TO EC MODE CALLERS.
*
*    13. - MEMORY TERMINATION MUST GIVE SETLOCKS RESOURCE MANAGER
*    CLEANUP ROUTINE CONTROL TO REMOVE THE MEMORYS ASCB
*    IF IT IS ON THE CMS LOCKS SUSPEND QUEUE.  THE RESOURCE MANAGER
*    CLEANUP ROUTINE MUST ALSO REMOVE FROM THE CMS AND
*    LOCAL LOCK SUSPEND QUEUES ANY SUSPENDED SRBS SCHEDULED TO THE
*    TERMINATING MEMORY.
*
*    14. - PURGEDQ MUST GIVE SETLOCKS RESOURCE MANAGER RMTR CONTROL TO
*    FREE UP ANY SUSPENDED SRBS THAT HAVE BEEN SCHEDULED
*    BUT NOT YET DISPATCHED.
*
*03*        CHARACTER-CODE-DEPENDENCIES = NONE.
*
*02*     RESTRICTIONS = NONE
*
*02*     REGISTER-CONVENTIONS = REFERENCE EQUATE SECTION
*
*02*     PATCH-LABEL = NONE, THIS IS A RESIDENT NUCLEUS MODULE.
*
*01*  MODULE-TYPE = PROCEDURE
*
*02*     PROCESSOR = ASSEMBLER
*
*02*     MODULE-SIZE = 4000 BYTES
*
*02*     ATTRIBUTES = NUCLEUS,ZERO PROTECT KEY,DISABLED,REFRESHABLE,
*        SUPERVISOR MODE,ADDRSPC=FIXED
*
*01*  ENTRY-POINT = GSLMCOBT
*
*02*     PURPOSE = CONDITIONAL OBTAIN FOR GLOBAL SPIN TYPE LOCKS WHEN
*        THERE ARE SEVERAL LOCKS AT SAME LEVEL, OR USER PROVIDES LOCK
*        ADDRESS.
*
*02*     LINKAGE = SETLOCK MACRO CONDITION REQUEST FOR SPIN LOCK.
*
*02*     INPUT = SUPERVISOR STATE, ZERO PROTECT KEY.  INPUT REGISTERS -
*        R0-R10 = CALLERS REGISTERS, R11 = LOCK ADDRESS, R12 = LOCK
*        ENTRY OFFSET IN CPU LOCKS HELD TABLE, R13 = GSLMCOBT ENTRY
*        POINT ADDRESS, R14 = CALLERS RETURN, R15=CALLERS REGISTER.
*
*02*     OUTPUT = NONE.
*
*01*  EXIT-NORMAL = GSLMCOBT
*
*02*     CONDITIONS = BRANCH REGISTER 14 FOR SUCCESSFUL OBTAIN OF LOCK,
*        LPSW FOR UNSUCCESSFUL OBTAIN  OF LOCK.
*
*02*     OUTPUT = SUCCESSFUL OBTAIN - LOCK ACQUIRED, CPU DISABLED,
*        UNSUCCESSFUL OBTAIN - SAME AS INPUT ENVIRONMENT
*        REGISTERS R0-R10 = CALLERS REGISTERS, R11-R12 = UNPREDICTABLE,
*        R13 = RETURN CODE, R14 = RETURN ADDRESS, R15 = CALLERS
*        REGISTER.
*
*02*     RETURN-CODES = 0 - LOCK SUCCESSFULLY OBTAINED, 4 - LOCK
*        ALREADY HELD BY CALLER., 8 - UNSUCCESSFUL, LOCK OWNED BY
*        ANOTHER CPU.
*
*01*  EXIT-ERROR = GSLMCOBT
*
*02*     CONDITIONS = SVC 13 TO ABEND ANY CALLER REQUESTING A DIFFERENT
*        LOCK OF THE SAME TYPE AS ONE HELD.
*
*02*     OUTPUT = SUPERVISOR STATE, ZERO PROTECT KEY, LOCKS MAY OR MAY
*        NOT BE HELD. ABEND CALLER WITH 073 SYSTEM ABEND.
*
*02*     RETURN-CODES = NONE.
*
*01*  ENTRY-POINT = GSLSCOBT
*
*02*     PURPOSE = CONDITIONAL OBTAIN FOR GLOBAL SPIN TYPE LOCKS WHEN
*        THERE IS ONLY ONE LOCK AT THIS LEVEL, AND SYSTEM KNOWS LOCK
*        ADDRESS.
*
*02*     LINKAGE = SETLOCK MACRO CONDITION REQUEST FOR SPIN LOCK.
*
*02*     INPUT = SUPERVISOR STATE, ZERO PROTECT KEY.  INPUT REGISTERS -
*        R0-R10 = CALLERS REGISTERS, R11 = LOCK ADDRESS, R12 = MASK TO
*        UPDATE CPU LOCKS HELD STRING, R13 = GSLCOBT ENTRY
*        POINT ADDRESS, R14 = CALLERS RETURN, R15=CALLERS REGISTER.
*
*02*     OUTPUT = NONE.
*
*01*  EXIT-NORMAL = GSLSCOBT
*
*02*     CONDITIONS = BRANCH REGISTER 14 FOR SUCCESSFUL OBTAIN OF LOCK,
*        LPSW FOR UNSUCCESSFUL OBTAIN  OF LOCK.
*
*02*     OUTPUT = SUCCESSFUL OBTAIN - LOCK ACQUIRED, CPU DISABLED,
*        UNSUCCESSFUL OBTAIN - SAME AS INPUT ENVIRONMENT
*        REGISTERS R0-R10 = CALLERS REGISTERS, R11-R12 = UNPREDICTABLE,
*        R13 = RETURN CODE, R14 = RETURN ADDRESS, R15 = CALLERS
*        REGISTER.
*
*02*     RETURN-CODES = 0 - LOCK SUCCESSFULLY OBTAINED, 4 - LOCK
*        ALREADY HELD BY CALLER., 8 - UNSUCCESSFUL, LOCK OWNED BY
*        ANOTHER CPU.
*
*01*  EXIT-ERROR = GSLSCOBT
*
*02*     CONDITIONS = SVC 13 TO ABEND ANY CALLER REQUESTING A DIFFERENT
*        LOCK OF THE SAME TYPE AS ONE HELD.
*
*02*     OUTPUT = SUPERVISOR STATE, ZERO PROTECT KEY, LOCKS MAY OR MAY
*        NOT BE HELD. ABEND CALLER WITH 073 SYSTEM ABEND.
*
*02*     RETURN-CODES = NONE.
*
*01*  ENTRY-POINT = GSLMUOBT(OR VIA GSLMUOBD FOR DISABLED ENTRY)
*
*02*     PURPOSE = UNCONDITIONAL OBTAIN FOR GLOBAL SPIN TYPE LOCKS WHEN
*        THERE ARE SEVERAL LOCKS AT SAME LEVEL, OR USER PROVIDES LOCK
*        ADDRESS.
*
*02*     LINKAGE = SETLOCK MACRO UNCONDITIONAL OBTAIN REQUEST FOR SPIN
*        LOCK.
*
*02*     INPUT = SUPERVISOR STATE, ZERO PROTECT KEY.  INPUT REGISTERS -
*        R0-R10 =CALLERS REGISTERS, R11 = LOCK ADDRESS, R12 = LOCK
*        ENTRY OFFSET IN CPU LOCKS HELD TABLE, R13 = GSLMUOBT ENTRY
*        POINT ADDRESS, R14 = RETURN ADDRESS, R15 = CALLERS REGISTERS.
*
*02*     OUTPUT = NONE.
*
*01*  EXIT-NORMAL = GSLMUOBT
*
*02*     CONDITIONS = BRANCH REGISTER 14 FOR SUCCESSFUL OBTAIN OF LOCK,
*        LPSW FOR UNSUCCESSFUL OBTAIN OF LOCK.
*
*02*     OUTPUT = SUCCESSFUL OBTAIN - LOCK ACQUIRED, CPU DISABLED,
*        UNSUCCESSFUL OBTAIN - SAME AS INPUT ENVIRONMENT.
*        REGISTERS R0-R10 = CALLERS REGISTERS, R11-R12 = UNPREDICTABLE,
*        R13 = RETURN CODE, R14 = RETURN ADDRESS, R15 = CALLERS
*        REGISTER.
*
*02*     RETURN-CODES = 0 - LOCK SUCCESSFULLY OBTAINED., 4 - LOCK
*        ALREADY HELD BY CALLER., 8 - UNSUCCESSFUL, LOCK OWNED BY
*        ANOTHER CPU.
*
*01*  EXIT-ERROR = GSLMUOBT
*
*02*     CONDITIONS = SVC 13 TO ABEND ANY CALLER REQUESTING A DIFFERENT
*        LOCK OF THE SAME TYPE AS ONE HELD OR REQUESTING A LOCK LOWER
*        IN THE HIERARCHY THAN A LOCK ALREADY HELD.
*
*02*     OUTPUT = SUPERVISOR STATE, ZERO PROTECT KEY, LOCKS MAY OR MAY
*        NOT BE HELD.  ABEND CALLER WITH 073 SYSTEM ABEND.
*
*02*     RETURN-CODES = NONE.
*
*01*  ENTRY-POINT = GSLSUOBT(OR VIA GSLSUOBD FOR DISABLED ENTRY OR VIA
*     GSLSDISP FOR DISPATCHER ENTRY ONLY)
*
*02*     PURPOSE = UNCONDITIONAL OBTAIN FOR GLOBAL SPIN TYPE LOCKS WHEN
*        THERE IS ONLY ONE LOCK AT THIS LEVEL, AND SYSTEM KNOWS LOCK
*        ADDRESS.
*
*02*     LINKAGE = SETLOCK MACRO UNCONDITIONAL OBTAIN REQUEST FOR SPIN
*        LOCK.
*
*02*     INPUT = SUPERVISOR STATE, ZERO PROTECT KEY.  INPUT REGISTERS -
*        R0-R10 =CALLERS REGISTERS, R11 = LOCK ADDRESS, R12 =  MASK TO
*        UPDATE CPU LOCKS HELD STRING, R13 = GSLSUOBT ENTRY
*        POINT ADDRESS, R14 = RETURN ADDRESS, R15 = CALLERS REGISTERS.
*
*02*     OUTPUT = NONE.
*
*01*  EXIT-NORMAL = GSLSUOBT
*
*02*     CONDITIONS = BRANCH REGISTER 14 FOR SUCCESSFUL OBTAIN OF LOCK,
*        LPSW FOR UNSUCCESSFUL OBTAIN OF LOCK.
*
*02*     OUTPUT = SUCCESSFUL OBTAIN - LOCK ACQUIRED, CPU DISABLED,
*        UNSUCCESSFUL OBTAIN - SAME AS INPUT ENVIRONMENT.
*        REGISTERS R0-R10 = CALLERS REGISTERS, R11-R12 = UNPREDICTABLE,
*        R13 = RETURN CODE, R14 = RETURN ADDRESS, R15 = CALLERS
*        REGISTER.
*
*02*     RETURN-CODES = 0 - LOCK SUCCESSFULLY OBTAINED., 4 - LOCK
*        ALREADY HELD BY CALLER., 8 - UNSUCCESSFUL, LOCK OWNED BY
*        ANOTHER CPU.
*
*01*  EXIT-ERROR = GSLSUOBT
*
*02*     CONDITIONS = SVC 13 TO ABEND ANY CALLER REQUESTING A DIFFERENT
*        LOCK OF THE SAME TYPE AS ONE HELD OR REQUESTING A LOCK LOWER
*        IN THE HIERARCHY THAN A LOCK ALREADY HELD.
*
*02*     OUTPUT = SUPERVISOR STATE, ZERO PROTECT KEY, LOCKS MAY OR MAY
*        NOT BE HELD.  ABEND CALLER WITH 073 SYSTEM ABEND.
*
*02*     RETURN-CODES = NONE.
*
*01*  ENTRY-POINT = GSLMREL
*
*02*     PURPOSE = RELEASE FOR GLOBAL SPIN LOCKS WHEN THERE ARE SEVERAL
*        LOCKS AT SAME LEVEL, OR USER PROVIDES LOCK ADDRESS.
*
*02*     LINKAGE = SETLOCK MACRO RELEASE REQUEST FOR SPIN LOCK.
*
*02*     INPUT = SUPERVISOR STATE, ZERO PROTECT KEY.  INPUT REGISTERS -
*        R0-R10 = CALLERS REGISTERS, R11 = LOCK ADDRESS,
*        R12 = LOCK ENTRY OFFSET IN CPU LOCKS HELD TABLE, R13 = GSLMREL
*        ENTRY POINT ADDRESS, R14 = CALLERS RETURN ADDRESS, R15 =
*        CALLERS REGISTER.
*
*02*     OUTPUT = NONE.
*
*01*  EXIT-NORMAL = GSLMREL
*
*02*     CONDITIONS = BRANCH REGISTER 14 FOR SUCCESSFUL RELEASE OF LOCK
*        AND OTHER GLOBAL SPIN LOCKS HELD OR DISABLED SUPERVISOR
*        INDICATOR ON.  LPSW TO RETURN CONTROL ENABLE IF NO OTHER
*        GLOBAL SPIN LOCKS ARE HELD AND NO SUPERVISOR INDICATORS ARE
*        ON.  LPSW TO RETURN CONTROL IS SAME STATE AS CALLED IF RELEASE
*        IS UNSUCCESSFUL.
*
*02*     OUTPUT = LOCK RELEASED IF PREVIOUSLY HELD, CPU DISABLED OR
*        ENABLED DEPENDING ON CONDITIONS.  REGISTERS R0-R10 = CALLERS
*        REGISTERS, R11-R12 = UNPREDICTABLE, R13 = RETURN CODE,
*        R14 = RETURN ADDRESS, R15 = CALLERS REGISTER.
*
*02*     RETURN-CODES = 0 - LOCK SUCCESSFULLY RELEASED., 4 - LOCK WAS
*        NOT OWNED BY ANYONE., 8 - LOCK WAS OWNED BY ANOTHER CPU.
*
*01*  ENTRY-POINT = GSLSREL
*
*02*     PURPOSE = RELEASE FOR GLOBAL SPIN LOCKS WHEN THERE IS ONLY ONE
*        LOCK AT SAME LEVEL, AND SYSTEM KNOWS LOCK ADDRESS.
*
*02*     LINKAGE = SETLOCK MACRO RELEASE REQUEST FOR SPIN LOCK.
*
*02*     INPUT = SUPERVISOR STATE, ZERO PROTECT KEY.  INPUT REGISTERS -
*        R0-R10 = CALLERS REGISTERS, R11 = LOCK ADDRESS,
*        R12 = MASK TO UPDATE CPU LOCKS HELD STRING, R13 = GSLSREL
*        ENTRY POINT ADDRESS, R14 = CALLERS RETURN ADDRESS, R15 =
*        CALLERS REGISTER.
*
*02*     OUTPUT = NONE.
*
*01*  EXIT-NORMAL = GSLSREL
*
*02*     CONDITIONS = BRANCH REGISTER 14 FOR SUCCESSFUL RELEASE OF LOCK
*        AND OTHER GLOBAL SPIN LOCKS HELD OR DISABLED SUPERVISOR
*        INDICATOR ON.  LPSW TO RETURN CONTROL ENABLE IF NO OTHER
*        GLOBAL SPIN LOCKS ARE HELD AND NO SUPERVISOR INDICATORS ARE
*        ON.  LPSW TO RETURN CONTROL IS SAME STATE AS CALLED IF RELEASE
*        IS UNSUCCESSFUL.
*
*02*     OUTPUT = LOCK RELEASED IF PREVIOUSLY HELD, CPU DISABLED OR
*        ENABLED DEPENDING ON CONDITIONS.  REGISTERS R0-R10 = CALLERS
*        REGISTERS, R11-R12 = UNPREDICTABLE, R13 = RETURN CODE,
*        R14 = RETURN ADDRESS, R15 = CALLERS REGISTER.
*
*02*     RETURN-CODES = 0 - LOCK SUCCESSFULLY RELEASED., 4 - LOCK WAS
*        NOT OWNED BY ANYONE., 8 - LOCK WAS OWNED BY ANOTHER CPU.
*
*01*  ENTRY-POINT = GSLMRELD
*
*02*     PURPOSE = RELEASE A GLOBAL SPIN LOCK WHEN THERE ARE SEVERAL
*        LOCKS AT SAME LEVEL, OR USER PROVIDES LOCK ADDRESS, AND RETURN
*        CONTROL DISABLED.
*
*02*     LINKAGE = SETLOCK MACRO RELEASE SPIN LOCK DISABLED REQUEST.
*
*02*     INPUT = SUPERVISOR STATE, ZERO PROTECT KEY.  INPUT REGISTERS -
*        R0-R10 = CALLERS REGISTERS, R11 = LOCK ADDRESS, R12 = LOCK
*        ENTRY OFFSET IN CPU LOCKS HELD TABLE, R13 = GSLMRELD ENTRY
*        POINT ADDRESS, R14 = CALLERS RETURN ADDRESS, R15 = CALLERS
*        REGISTER.
*
*02*     OUTPUT = NONE.
*
*01*  EXIT-NORMAL = GSLMRELD
*
*02*     CONDITIONS = BRANCH REGISTER 14 FOR SUCCESSFUL RELEASE OF
*        LOCK.  LPSW FOR UNSUCCESSFUL RELEASE OF LOCK.
*
*02*     OUTPUT = SUCCESSFUL RELEASE, CPU DISABLED.  UNSUCCESSFUL
*        RELEASE, CPU IN SAME STATE AS ENTRY ENVIRONMENT.  REGISTERS -
*        R0-R10 = CALLERS REGISTERS, R11-R12 = UNPREDICTABLE, R13 =
*        RETURN CODE, R14 = RETURN ADDRESS, R15 = CALLERS REGISTER.
*
*02*     RETURN-CODES = 0 - LOCK SUCCESSFULLY RELEASED., 4 - LOCK
*        ALREADY HELD BY CALLER., 8 - UNSUCCESSFUL, LOCK OWNED BY
*
*01*  ENTRY-POINT = GSLSRELD
*
*02*     PURPOSE = RELEASE A GLOBAL SPIN LOCK WHEN THERE IS ONLY ONE
*        LOCK AT SAME LEVEL, AND SYSTEM KNOWS LOCK ADDRESS, AND RETURN
*        CONTROL DISABLED.
*
*02*     LINKAGE = SETLOCK MACRO RELEASE SPIN LOCK DISABLED REQUEST.
*
*02*     INPUT = SUPERVISOR STATE, ZERO PROTECT KEY.  INPUT REGISTERS -
*        R0-R10 = CALLERS REGISTERS, R11 = LOCK ADDRESS, R12 = MASK TO
*        UPDATE CPU LOCKS HELD STRING, R13 = GSLSRELD ENTRY
*        POINT ADDRESS, R14 = CALLERS RETURN ADDRESS, R15 = CALLERS
*        REGISTER.
*
*02*     OUTPUT = NONE.
*
*01*  EXIT-NORMAL = GSLSRELD
*
*02*     CONDITIONS = BRANCH REGISTER 14 FOR SUCCESSFUL RELEASE OF
*        LOCK.  LPSW FOR UNSUCCESSFUL RELEASE OF LOCK.
*
*02*     OUTPUT = SUCCESSFUL RELEASE, CPU DISABLED.  UNSUCCESSFUL
*        RELEASE, CPU IN SAME STATE AS ENTRY ENVIRONMENT.  REGISTERS -
*        R0-R10 = CALLERS REGISTERS, R11-R12 = UNPREDICTABLE, R13 =
*        RETURN CODE, R14 = RETURN ADDRESS, R15 = CALLERS REGISTER.
*
*02*     RETURN-CODES = 0 - LOCK SUCCESSFULLY RELEASED., 4 - LOCK
*        ALREADY HELD BY CALLER., 8 - UNSUCCESSFUL, LOCK OWNED BY
*
*01*  ENTRY-POINT = LLCOBT(OR VIA LLCOSVCF FOR SVC FLIH ONLY)
*
*02*     PURPOSE = CONDITIONAL OBTAIN FOR THE LOCAL MEMORY LOCK
*
*02*     LINKAGE = SETLOCK MACRO CONDITIONAL OBTAIN REQUEST FOR THE
*        LOCAL LOCK.
*
*02*     INPUT = SUPERVISOR STATE, ZERO PROTECT KEY.  REGISTERS -
*        R0-R10 = CALLERS REGISTER, R11 = ZERO, R12 = LOCAL LOCKS ENTRY
*        ADDRESS IN CPU LOCK HELD TABLE, R13 = RETURN CODE, R14 =
*        RETURN ADDRESS, R15 = CALLERS REGISTER.
*
*01*  EXIT-NORMAL = LLCOBT
*
*02*     CONDITIONS = LPSW TO RETURN CONTROL TO CALLER IN SAME STATE AS
*        CALLED.  LOCAL LOCK MAY OR MAY NOT BE OBTAINED.
*
*02*     OUTPUT = LOCAL LOCK HELD IF SUCCESSFUL.  SAME STATE AS ENTRY
*        ENVIRONMENT.  REGISTERS - R0-R10 = CALLERS REGISTERS, R11-R12
*        = UNPREDICTABLE, R13 = RETURN CODE, R14 = RETURN ADDRESS, R15
*        = CALLERS REGISTER.
*
*02*     RETURN-CODES = 0 - LOCK SUCCESSFULLY OBTAINED., 4 - LOCK
*        ALREADY HELD BY CALLER., 8 - UNSUCCESSFUL, LOCK OWNED BY
*        ANOTHER CPU.
*
*01*  ENTRY-POINT = LLREL(OR VIA LRELEXPR FOR EXIT PROLOGUE ONLY OR VIA
*     LRELDISP FOR DISPATCHER ONLY)
*
*02*     PURPOSE = RELEASE FOR THE LOCAL MEMORY LOCK.
*
*02*     LINKAGE = SETLOCK MACRO RELEASE LOCAL LOCK REQUEST.
*
*02*     INPUT = SUPERVISOR STATE, ZERO PROTECT KEY.  REGISTERS -
*        R0-R10 = CALLERS REGISTERS, R11 = ZERO, R12=LOCAL LOCKS ENTRY
*        ADDRESS IN CPU LOCK HELD TABLE, R13 = LLREL ENTRY POINT
*        ADDRESS, R14 = RETURN ADDRESS, R15 = CALLERS REGISTER.
*
*01*  EXIT-NORMAL = LLREL
*
*02*     CONDITIONS = LPSW TO RETURN TO SAME STATE AS ENTERED.  LOCAL
*        LOCK RELEASED IF PREVIOUSLY HELD.
*
*02*     OUTPUT = SAME STATE AS ENTRY ENVIRONMENT.  A SUSPEND- @Z40FPXJ
*        ED SRB, IF THERE IS ONE, WILL HAVE BEEN GIVEN THE     @Z40FPXJ
*        LOCK AND SCHEDULED. A MEMORY SWITCH MAY HAVE BEEN     @Z40FPXJ
*        INVOKED IF THERE WERE NO SUSPENDED SRBS AND THE NUMBER OF
*        READY TCBS IN THE LOCAL MEMORY EXCEEDED THE NUMBER OF CPUS
*        DISPATCHED TO THE MEMORY.  REGISTERS - R0-R10 = CALLERS
*        REGISTERS, R11-R12 = UNPREDICTABLE, R13 = RETURN CODE, R14 =
*        RETURN ADDRESS, R15 = CALLERS REGISTER.
*
*02*     RETURN-CODES = 0 - LOCAL LOCK SUCCESSFULLY RELEASED., 4 -
*        LOCAL LOCK NOT OWNED BY ANYONE., 8 - LOCAL LOCK OWNED BY
*        ANOTHER CALLER.
*
*01*  EXIT-ERROR = LLREL
*
*02*     CONDITIONS = SVC 13 TO ABEND ANY CALLER ATTEMPTING TO FREE THE
*        LOCAL LOCK WHILE HOLDING THE CMS LOCK.
*
*02*     OUTPUT = SUPERVISOR STATE, ZERO PROTECT KEY, LOCKS HELD.
*        ABEND CALLER WITH 073 SYSTEM ABEND.
*
*02*     RETURN-CODES = NONE.
*
*01*  ENTRY-POINT = LLUOBT
*
*02*     PURPOSE = UNCONDITIONAL OBTAIN OF THE LOCAL LOCK.
*
*02*     LINKAGE = SETLOCK MACRO UNCONDITION OBTAIN  REQUEST.
*
*02*     INPUT = SUPERVISOR STATE, ZERO PROTECT KEY.  REGISTERS -
*        R0-R10 = CALLERS REGISTERS, R11 = ZERO, R12 = LOCAL LOCKS
*        ENTRY ADDRESS IN CPU LOCKS HELD TABLE, R13 = LLUOBT ENTRY
*        POINT ADDRESS, R14 = RETURN ADDRESS, R15 = CALLERS REGISTER.
*
*02*     OUTPUT = NONE.
*
*01*  EXIT-NORMAL = LLUOBT
*
*02*     CONDITIONS = LPSW TO EXIT IN SAME STATE AS CALLED EXCEPT LOCAL
*        LOCK WILL BE HELD.
*
*02*     OUTPUT = SUPERVISOR STATE, ZERO PROTECT KEY, REGISTERS -
*        R0-R10 = CALLERS REGISTERS, R11-R12 = UNPREDICTABLE, R13 =
*        RETURN CODE, R14 = RETURN ADDRESS, R15 = CALLERS REGISTER.
*
*02*     RETURN-CODES = 0 - LOCAL LOCK SUCCESSFULLY OBTAINED., 4 -
*        LOCAL LOCK ALREADY HELD.
*
*01*  EXIT-NORMAL = LLUOBT
*
*02*     CONDITIONS = BRANCH REGISTER 15 TO THE DISPATCHER AT ENTRY
*        IEA0DS                                                @Z40FPXJ
*
*02*     OUTPUT = AT ENTRY POINT IEA0DS, THE DISPATCHER WILL BE ENTERED
*        WITH NO LOCKS HELD AND THE STATUS OF THE CALLER SAVED IN THE
*        TCB & RB OR A SUSPENDED SRB. ENTRY WILL BE MADE IN    @Z40FPXJ
*        SUPERVISOR STATE, 0 PROTECT KEY, & PHISICALLY         @Z40FPXJ
*        DISABLED EXCEPT FOR M.C.                              @Z40FPXJ
*
*02*     RETURN-CODES = NONE.
*
*01*  EXIT-ERROR = LLUOBT
*
*02*     CONDITIONS = SVC 13 TO ABEND ANY CALLER REQUESTING THE LOCAL
*        LOCK AND HOLDING ANOTHER LOCK (HIERARCHY VIOLATION) OR IF THE
*        CALLER IS NOT IN TCB/RB OR SRB MODE.
*
*02*     OUTPUT = SUPERVISOR STATE, ZERO PROTECT KEY, LOCKS MAY OR MAY
*        NOT BE HELD. ABEND CALLER WITH 073 SYSTEM ABEND.
*
*02*     RETURN-CODES = NONE.
*
*01*  ENTRY-POINT = CMSUOBT
*
*02*     PURPOSE = UNCONDITIONAL OBTAIN FOR THE CMS LOCK.
*
*02*     LINKAGE = SETLOCK MACRO UNCONDITIONAL OBTAIN CMS LOCK REQUEST.
*
*02*     INPUT = SUPERVISOR STATE, ZERO PROTECT KEY, LOCAL LOCK HELD.
*        REGISTERS - R0-R10 = CALLERS REGISTER, R11 = CMS LOCK ADDRESS,
*        R12 = CMS LOCKS ENTRY ADDRESS IN CPU LOCKS HELD TABLE, R13 =
*        CMSUOBT ENTRY POINT ADDRESS, R14 = RETURN ADDRESS, R15 =
*        CALLERS REGISTER.
*
*02*     OUTPUT = NONE.
*
*01*  EXIT-NORMAL = CMSUOBT
*
*02*     CONDITIONS = LPSW TO RETURN CONTROL BACK TO CALLER IN SAME
*        STATE AS CALLED, AND THE CMS LOCK WILL BE HELD.
*
*02*     OUTPUT = SUPERVISOR STATE, ZERO PROTECT KEY, CMS AND LOCAL
*        LCOK HELD.  REGISTERS - R0-R10 = CALLERS REGISTERS, R11-R12 =
*        UNPREDICTABLE, R13 = RETURN CODE, R14 = RETURN ADDRESS, R15 =
*        CALLERS REGISTER.
*
*02*     RETURN-CODES = 0 - CMS LOCK SUCCESSFULLY OBTAINED, 4 - CMS
*        LOCK ALREADY OWNED.
*
*01*  EXIT-NORMAL = CMSUOBT
*
*02*     CONDITIONS = CONTROL WILL BE GIVEN TO THE DISPATCHER IF THE
*        CALLER FAILS TO OBTAIN THE CMS LOCK.  IF THE CALLER IS A
*        NON-SRB CALLER, CALLERS STATUS WILL BE SAVED IN THE INTERRUPT
*        HANDLER SAVE AREA, THE ASCB WILL BE ENQED ON THE CMS  @Z40FPXJ
*        SUSPEND QUEUE WHICH IS SERIALIZED BY CDS LOGIC.  THE  @Z40FPXJ
*        INTERRUPT ID WILL BE PLACED IN THE LOCAL LOCK. CONTRL @Z40FPXJ
*        WILL BE GIVEN TO THE DISP AT ENTRY PT IEAODS. IF      @Z40FPXJ
*        THE CALLER IS A SRB CALLER, CALLERS STATUS WILL BE SAVED IN A
*        SUSPENDED SRB.  THE SUSPENDED SRB WILL BE ENQUEED ON THE CMS
*        SUSPEND QUEUE WHICH IS SERIALIZED BY CDS LOGIC.       @Z40FPXJ
*        THE INTERRUPT ID WILL BE PLACED IN THE LOCAL LOCK,    @Z40FPXJ
*        THE LOCAL LOCKS CPU LOCK HELD TABLE ENTRY WILL BE ZEROD OUT
*        AND CONTROL WILL BE GIVEN TO THE DISPATCHER AT ENTRY POINT
*        IEA0DS.                                               @Z40FPXJ
*
*02*     OUTPUT = SUPERVISOR STATE, ZERO PROTECT KEY, PHYSICALLY
*        DISABLED EXCEPT FOR M.C.  DISPATCHER LOCK HELD, REGISTERS -
*        R0-R14 = UNPREDICTABLE, R15 = DISPATCHER ENTRY POINT.
*
*02*     RETURN-CODES = NONE.
*
*01*  EXIT-ERROR = CMSUOBT
*
*02*     CONDITIONS = SVC 13 TO ABEND ANY CALLER REQUESTING THE CMS
*        LOCK WITHOUT OWNING THE LOCAL LOCK OR HOLDING A LOCK HIGHER IN
*        THE LOCKING HIERARCHY.
*
*02*     OUTPUT = SUPERVISOR STATE, ZERO PROTECT KEY, LOCKS MAY OR MAY
*        NOT BE HELD.  ABEND CALLER WITH 073 SYSTEM ABEND.
*
*02*     RETURN-CODES = NONE.
*
*01*  ENTRY-POINT = CMSCOBT
*
*02*     PURPOSE = CONDITIONAL OBTAIN FOR THE CMS LOCK
*
*02*     LINKAGE = SETLOCK MACRO CONDITIONAL OBTAIN REQUEST FOR CMS
*        LOCK.
*
*02*     INPUT = SUPERVISOR STATE, ZERO PROTECT KEY, REGISTERS - R0-R10
*        = CALLERS REGISTERS, R11 = CMS LOCK ADDRESS, R12 = CMS LOCKS
*        CPU LOCKS HELD TABLE ENTRY ADDRESS, R13 = CMSCOBT ENTRY POINT
*        ADDRESS, R14 = RETURN ADDRESS, R15 = CALLERS REGISTER.
*
*02*     OUTPUT = NONE.
*
*01*  EXIT-NORMAL = CMSCOBT
*
*02*     CONDITIONS = LPSW TO RETURN CONTROL IN SAME STATE AS CALLED.
*
*02*     OUTPUT = SUPERVISOR STATE, ZERO PROTECT KEY, REGISTERS -
*        R0-R10 = CALLERS REGISTERS, R11-R12 = UNPREDICTABLE, R13 =
*        RETURN CODE , R14 = RETURN ADDRESS, R15 = CALLERS REGISTER.
*
*02*     RETURN-CODES = 0 - CMS LOCK SUCCESSFULLY OBTAINED, 4 - CMS
*        LOCK ALREADY OWNED., 8 - CMS LOCK OWNED BY ANOTHER MEMORY.
*
*01*  EXIT-ERROR = CMSCOBT
*
*02*     CONDITIONS = SVC 13 TO ABEND ANY CALLER REQUESTING THE CMS
*        LOCK WITHOUT OWNING THE LOCAL LOCK.
*
*02*     OUTPUT = SUPERVISOR STATE, ZERO PROTECT KEY, LOCKS MAY OR MAY
*        NOT BE HELD.  ABEND CALLER WITH 073 SYSTEM ABEND.
*
*02*     RETURN-CODES = NONE.
*
*01*  ENTRY-POINT = CMSREL
*
*02*     PURPOSE = RELEASE FOR THE CMS LOCK.
*
*02*     LINKAGE = SETLOCK MACRO RELEASE REQUEST FOR THE CMS LOCK.
*
*02*     INPUT = SUPERVISOR STATE, ZERO PROTECT KEY, REGISTERS - R0-R10
*        = CALLERS REGISTERS, R11 = CMS LOCK ADDRESS, R12 = CMS LOCKS
*        CPU LOCKS HELD TABLE ENTRY ADDRESS, R13 = RETURN CODE, R14 =
*        RETURN ADDRESS, R15 = CALLERS REGISTER.
*
*02*     OUTPUT = NONE.
*
*01*  EXIT-NORMAL = CMSREL
*
*02*     CONDITIONS = LPSW TO RETURN TO CALLER IN SAME STATE AS CALLED.
*
*02*     OUTPUT = SUPERVISOR STATE, ZERO PROTECT KEY, ANY SUSPENDED
*        SRBS DEQUED FROM THE SUSPEND QUEUE & SCHEDULED, ANY SUSPENDED
*        ASCBS DEQUEUED AND  MEMORY SWITCH INVOKED FOR EACH ONE IF NO
*        SRBS ARE SCHEDULED, REGISTERS - R0-R10 = CALLERS REGISTERS,
*        R11-R12 = UNPREDICTABLE, R13 = RETURN CODES, R14 = RETURN
*        ADDRESS, R15 = CALLER REGISTER.
*
*02*     RETURN-CODES = 0 - CMS LOCK SUCCESSFULLY RELEASED., 4 - CMS
*        LOCK NOT OWNED BY ANYONE., 8 - CMS LOCK OWNED BY ANOTHER
*        MEMORY.
*
*01*  ENTRY-POINT = RELGSD
*
*02*     PURPOSE = MULTIPLE RELEASE OF SPIN LOCKS, ACCORDING TO AN
*        INPUT STRING IN R11;
*
*02*     LINKAGE = BRANCH REGISTER 13 WHICH CONTAINS AN ADDRESS
*        OBTAINED FROM THE LOCK INTERFACE TABLE, IEAVELIT.
*
*02*     INPUT = SUPERVISOR STATE, ZERO PROTECT KEY, DISABLED BECAUSE
*        AT LEAST ONE SPIN LOCK HELD, R0-R10 = CALLERS REGISTERS, R11 =
*        STRING INDICATING WHICH SPIN LOCKS ARE TO BE RELEASED, R12 =
*        ADDRESS OF AN INDIRECT ADDRESS LIST TOWARD LOCKWORDS, R13 =
*        ENTRY POINT ADDRESS IN RELGS, R14 = RETURN ADDRESS, R15 =
*        CALLER REGISTER.
*
*01*  EXIT-NORMAL = RELGS
*
*02*     CONDITIONS = BRANCH AFTER A POSSIBLE STOSM TO RETURN
*        CONTROL TO THE CALLER IN A DISABLED OR ENABLED STATE
*        WITH REQUIRED LOCKS RELEASED, DEPENDING ON REQUEST, REQUESTOR,
*        AND/OR STATUS OF NON INVOLVED SPIN LOCKS IF ANY.
*
*02*     OUTPUT = SUPERVISOR STATE, ZERO PROTECT KEY,
*        REGISTERS - R0-R10 = CALLERS REGISTERS, R11-R13 =
*        UNPREDICTABLE, R14 = CALLERS RETURN ADDRESS, R15 = CALLERS
*        REGISTER.
*
*02*     RETURN-CODES = NONE.
*
*01*  ENTRY-POINT = IEAVELRM
*
*02*     PURPOSE = TO CLEANUP LOCAL LOCK SRB SUSPEND QUEUE.
*
*02*     LINKAGE = BRANCH REGISTER 15 WHICH CONTAINS
*        THE ENTRY POINT ADDRESS.
*
*02*     INPUT = SUPERVISOR STATE, ZERO PROTECT KEY, ENABLED  R1 =
*        ADRESS OF THE ADDRESS OF A PARM LIST, R14 CONTAINS THE RETURN
*        ADDRESS R13 CONTAINS THE ADDRESS OF A REGISTER SAVE AREA.  THE
*        PARMLIST CONTAINS THE ADDRESS OF THE ASCB BEING TERMINATED  IN
*        THE FIELD RMPLASCB.
*
*01*  EXIT-NORMAL = BRANCH ON R14.
*
*02*     CONDITIONS =  IN ALL CASES.
*
*02*     OUTPUT = SUPERVISOR STATE, ZERO PROTECT KEY,
*        ENABLED,ALL REGS AS ON ENTRY,LOCAL SUSPEND QUEUE CLEARED.
*
*02*     RETURN-CODES = NONE.
*
*01*  ENTRY-POINT = RELGSD
*
*02*     PURPOSE = MULTIPLE RELEASE OF SPIN LOCKS, ACCORDING TO AN
*        INPUT STRING IN R11;
*
*02*     LINKAGE = BRANCH REGISTER 13 WHICH CONTAINS AN ADDRESS
*        OBTAINED FROM THE LOCK INTERFACE TABLE, IEAVELIT.
*
*02*     INPUT = SUPERVISOR STATE, ZERO PROTECT KEY, DISABLED BECAUSE
*        AT LEAST ONE SPIN LOCK HELD, R0-R10 = CALLERS REGISTERS, R11 =
*        STRING INDICATING WHICH SPIN LOCKS ARE TO BE RELEASED, R12 =
*        ADDRESS OF AN INDIRECT ADDRESS LIST TOWARD LOCKWORDS, R13 =
*        ENTRY POINT ADDRESS IN RELGS, R14 = RETURN ADDRESS, R15 =
*        CALLER REGISTER.
*
*01*  EXIT-NORMAL = RELGS
*
*01*  EXTERNAL REFERENCES = DISPLOCK - DISPATCHER LOCK, CMSSRBF AND
*     CMSSRBL - CMS SUSPEND QUEUE HEADER POINTING TO FIRST AND LAST
*     SUSPENDED SRB,  CMSASBF - CMS SUSPEND QUEUE HEADER POINTING TO
*     FIRST SUSPENDED ASCB. IEA0DS, IEAPDS2 AND IEAPDS5 - DISPATCHER
*     ENTRY POINTS,IEAVEMS0 - ADDRESS OF MEMORY SWITCH ENTRY POINT.
*
*02*     ROUTINES = IEA0DS - GIVE CONTROL TO DISPATCHER WHEN SUSPENDING
*        A TCB/RB CALLER. ALL ENTRIES TO DISPATCHER            @Z40FPXJ
*        ARE A LOAD AND BRANCH R15. IEAVEMS0 - CALL MEMORY SWITCH WHEN
*        DEQUEUING A SUSPENDED ASCB  OR                        @Z40FPXJ
*        WHEN FREEING THE LOCAL LOCK AND THE ASCBS2S SWITCH IS ON OR
*        THE NUMBER OF READY TCB FOR THAT MEMORY EXCEEDS THE NUMBER OF
*        OF CPU CURRENTLY DISPATCHED TO THAT ADRESS SPACE. QUICKCELL -
*        TO OBTAIN A SRB IN ORDER TO SUSPEND CURRENT SRB. CALL IS VIA
*        MACRO GETCELL WHICH BRANCH AND LINK R14,R15. SCHEDULE - INLINE
*        MACRO EXPANSION TO SCHEDULE ANY SUSPENDED SRB WHEN RELEASING
*        THE REQUIRED LOCK. RECOVERY MANAGER -  TO PURGE THE FRR STACK
*        WHEN SUSPENDING A CALLER AND GIVING CONTROL TO THE DISPATCHER.
*        CALL IS AN INLINE EXPANSION OF SETFRR MACRO. ACR - TO GIVE ACR
*        CONTROL IS ACR ACTIVATED DURING WINDOW SPIN PROCESSING, CALL
*        IS VIA MACRO CALLRTM. ABEND- TO ABEND A CALLER VIOLATING THE
*        LOCKING REGULATIONS - VIA SVC 13.
*02*     DATA-AREAS = NONE.
*
*02*     CONTROL-BLOCKS - (1) = PSA  (W)(R), (2) = LCCA  (W)(R), (3) =
*        ASCB (W)(R), (4) = TCB (R)(W), (5) = RB (W), (6) = SRB (W)(R),
*        (7) = IEAVBK (W)(R), (8) = CSD (W)(R) , (9) = ASXB (R), (10) =
*        IHSA (W)
*
*01*  TABLES = NONE.
*
*01*  MACROS = (1) = SCHEDULE, (2) = GETCELL, (3) = SETFRR, (4) =
*     CALLRTM, (5) = WINDOW.
*
*02*    SERIALIZATION = DISPATCHER LOCK TO SERIALIZE THE SUSPEND
*       QUEUES.
*
*01*  CHANGE-ACTIVITY = Y02751,Y02752,ZM02352
*                       OZ28255 - LOCK MANAGER REENTERED DURING GETMAIN
*                                 FOR AN SSRB                  @ZA28255
*                       OZ32162 - NO CODE CHANGE. FIX COVER LETTER FOR
*                                 SU51 BECAUSE PREREQ MACRO IHAPSA IS
*                                 IN SU51 CORRECT.             @ZA32162
*
*01*  MESSAGES = NONE.
*
*01*  ABEND-CODES = SYSTEM ABEND CODE 073 - (1) - INVALID OBTAIN
*     REQUEST, LOCKING HIERARCHY VIOLATED OR ANOTHER LOCK OF THE SAME
*     TYPE IS ALREADY HELD OR THE CMS LOCK WAS REQUESTED BUT THE LOCAL
*     LOCK WAS NOT HELD OR THE LOCAL LOCK WAS UNCONDITIONALLY REQUESTED
*     BY A NON-TCB/RB OR NON-SRB MODE CALLER. (2) - INVALID RELEASE
*     REQUEST. LOCAL LOCK WAS SPECIFIED AND THE CMS LOCK IS STILL HELD
*     OR MULTIPLE REQUEST VIA REGISTER INVOLVING SPIN LOCKS NOT HELD.
*
**** END OF SPECIFICATIONS ***/
IEAVELK  CSECT
*                                       CSECT FOR SETLOCK MODULE
         MODID BR=NO
REG0     EQU   0                        REGISTER 0
REG1     EQU   1                        REGISTER 1
REG2     EQU   2                        REGISTER 2
REG3     EQU   3                        REGISTER 3
REG4     EQU   4                        REGISTER 4
REG5     EQU   5                        REGISTER 5
REG6     EQU   6                        REGISTER 6
REG7     EQU   7                        REGISTER 7
REG8     EQU   8                        REGISTER 8
REG9     EQU   9                        REGISTER 9
REG10    EQU   10                       REGISTER 10
R10      EQU   10                       REGISTER 10            @Z40FPXJ
REG11    EQU   11                       REGISTER 11
R11      EQU   11                       REGISTER 11            @Z40FPXJ
REG12    EQU   12                       REGISTER 12
R12      EQU   12                       REGISTER 12            @Z40FPXJ
REG13    EQU   13                       REGISTER 13
R13      EQU   13                       REGISTER 13            @Z40FPXJ
REG14    EQU   14                       REGISTER 14
REG15    EQU   15                       REGISTER 15
CPIDRG0  EQU   0                        CONTROL REGISTER 0
CSDPTR   EQU   3                        BASE FOR CSD
FOUR     EQU   4                        CONSTANT 4
TWO      EQU   2                        CONSTANT 2
ONE      EQU   1                        CONSTANT 1             @Z40FPXJ
CPUCNT   EQU   4                        COUNT OF ACTIVE CPUS
CVTBASE  EQU   4                        BASE FOR CFT
SRBCNT   EQU   5                        COUNT OF AVAILABLE SUSPEND SRBS
SPINRTNR EQU   6                        BASE FOR SINDOW SPIN ROUTINE
MNLRETRN EQU   7                        RETURN REGISTER FOR SPIN RTN
LCCAPTR  EQU   8                        BASE FOR LCCA
EIGHT    EQU   8                        CONSTANT 8
CPUADDR9 EQU   9                        LOGICAL CPU ADDRESS
ASCBADR9 EQU   9                        BASE FOR ASCBS
TCBPTR   EQU   9                        BASE FOR TCB
REGMASK  EQU   9                        MASK TO UPDATE CLHS
ZERORG10 EQU   10                       CONTAINS FW OF ZEROS FOR CS
RBPTR    EQU   10                       BASE FOR RB
LKADDR11 EQU   11                       ADDRESS OF LOCKWORD
LLTSTREG EQU   11                       WKREG TO VALIDATE LL UNCOND OBT
DISPLOCK EQU   11                       ADDRESS OF DISPATCHER LOCK
SALCLOCK EQU   11                       ADDRESS OF SALLOC LOCK
ALECMS11 EQU   11                       ADDRESS OF CMS' CLHT ENTRY
TWELVE   EQU   12                       CONSTANT 12
ALECLHT  EQU   12                       ADDRESS OF A LOCK'S CLHT ENTRY
BASER13  EQU   13                       BASE FOR SETLOCK ROUTINES
RCREG13  EQU   13                       REGISTER USED TO PASS LOCK'S RC
RETURN   EQU   14                       ADDRESS OF CALLERS RETURN ADDR
CVTADR   EQU   16                       LOCATION CONTAINS CVT ADDRESS
K16      EQU   16                       LENGTH OF 4 GPRS
K28      EQU   28                       OFFSET FOR 7 FULL WORDS
K44      EQU   44                       LENGTH OF 11 GPRS
K64      EQU   64                       LENGTH OF 16 REGISTERS
ZERO     EQU   0                        CONSTANT 0
CX10     EQU   X'10'                    MASK FOR DISP LOCK
CXEF     EQU   X'EF'                    MASK FOR DISP CLEAR
CX04     EQU   X'04'                    DISABLE INDICATOR
CXFE     EQU   X'FE'                    CLEAR LOCAL BIT
DISABLE  EQU   X'FC'                    MASK TO DISABLE CALLER
ENABLE   EQU   X'03'                    MASK TO ENABLE CALLER
SRBNOLH  EQU   X'7F'                    MASK TO TURN OFF NO LOCAL LOCK
LOCKNACT EQU   X'F7'                    MASK TO TURN OFF SETLOCK ACTIVE
LOCKNSPN EQU   X'DF'                    MASK TO TURN OFF SETLOCK SPIN
LOCKRDSP EQU   X'7F'                    MASK TO TURN OFF DISP LK HELD
ALLONES  EQU   X'FF'                    ONE BYTE OF ONES
         SPACE 2
*/*IEAVELK: CHART SETLOCK */
*/* HEADER
*/*                                               IBM CONFIDENTIAL
*/*
*/*
*/*                                               SECTION 3.1.7.14.10
*/* SETLOCK
*/*                                               PAGE # */
         SPACE 2
         USING FLC,0
         USING SRBSECT,REG1
         USING CSD,CSDPTR
         USING CVT,CVTBASE
         USING TCB,TCBPTR
         USING RBSECT,RBPTR
         USING ASCB,REG11
         USING LCCA,LCCAPTR
         TITLE 'IEAVELK -SETLOCK''S UNCONDITIONAL OBTAIN GLOBAL SPIN LO*
               CK ROUTINE (MULTIPLE LOCKS AT SAME LEVEL) '
         ENTRY GSLMUOBT
         SPACE  2
*/*GSLMUOBT: E GSLMUOBT */
         SPACE  2
GSLMUOBT DS    0H
         USING *,BASER13
         SPACE  2
*/* P DISABLE CPU FOR I/O & EXT SAVE PSW SYS MASK IN MODEL PSW */
         SPACE  2
         STNSM PSAMPSW,DISABLE          DISABLE CPU FOR EXT & I/O INT
         SPACE  2
*/*GSLMUOBD: P SAVE REG PSALKSA */
         SPACE  2
*        THIS IS THE ENTRY USED FOR DISABLED CALLERS
GSLMUOBD DS    0H
         ST    REG12,PSALKR12           SAVE CALLERS REG12
         SPACE  2
*/* P OBTAIN BIT MASK FOR HIERARHY CHECK */
         SPACE 2
         L     REG12,MASKTAB(ALECLHT)   ONE AT LOCK LEVEL IN HRCHY
         SPACE 2
*/* D (GE,GSLMUOH1,LT,) COMPARE BIT MASK WITH STRING */
         SPACE  2
         CL    REG12,PSACLHS            LOCK HIERARCHY CHECK
         BNH   GSLMUOH1                 HIGHER OR SAME LK ALREADY HELD
         SPACE  2
*/* P TURN ON SETLOCK ACTIVE INDICATOR IN PSA */
         SPACE  2
         OI    PSASUP1,PSALOCK          SETLOCK ACTIVE INDICATOR
         SPACE  2
*/*GSLMUSPN: P GET GET LOCK TABLE OFFSET VALUE */
         SPACE  2
GSLMUSPN DS    0H
         L     REG13,PSALKR12           GET OFFSET VALUE SAVED
*        NOTE-ADDRESSABILITY HAS JUST BEEN LOST
         SPACE  2
*/* P UPDATE LOCK TABLE AT CORRECT OFFSET */
         SPACE  2
         ST    LKADDR11,PSACLHT(REG13)  STORE INTO LOCK TABLE
         SPACE 2
*/* P ZERO REG FOR CS */
         SPACE 2
         SLR   REG13,REG13              ZERO REG FOR CS
         SPACE 2
*/* P SET HIERARCHY BIT FOR LOCK REQUESTED */
         SPACE 2
         O     REG12,PSAHLHI            UPDATE HIERARCHY MASK
         ST    REG12,PSAHLHI            STORE UPDATED VALUE
         SPACE 2
*/* P GET CPUID FOR CS */
         SPACE 2
         LH    REG12,PSACPULA           GET CPUID VALUE
         SPACE 2
*/* P CLEAR SETLOCK BIT */
*/* D (YES,RETURN,NO,) IS LOCK AVAILABLE VIA CS? */
         SPACE 2
         CS    REG13,REG12,ZERO(LKADDR11) GET LOCK
         NI    PSASUP1,LOCKNACT         CLEAR LOCK SUPER BIT
         LTR   REG13,REG13              WAS CS OK
         BZR   RETURN                   IF SO RETURN TO CALLER
         SPACE 2
*/* P REESTABLISH ORIGINAL ADDRESSABILITY */
         SPACE 2
         BALR  BASER13,ZERO             GET ADDRESS BACK
         USING *,BASER13                RESET ADDRESSABILITY
         L     BASER13,GSLMUOBS         GET OLD ADDRESS
         USING GSLMUOBT,BASER13         RESET BACK TO OLD
         SPACE 2
*/* P SET SETLOCK BIT */
         SPACE 2
         OI    PSASUP1,PSALOCK          SET SUPER BIT
         SPACE 2
*/* P SAVE DESTROYED REGS IN PSA */
         SPACE 2
         STM   REG5,REG10,PSALKR5       SAVE DESTROYED REGS
         SPACE 2
*/* P CLEAR HIERARCHY BIT ALREADY SET */
         SPACE 2
         L     REG12,PSALKR12           GET LOCK OFFSET SAVED
         SLR   REG9,REG9                CLEAR REG FOR STORE
         ST    REG9,PSACLHT(REG12)      RESET LOCK TABLE ENTRY TO 0
         L     REG12,MASKTAB(REG12)     SET REG12 TO HIERARCHY MASK
         LR    REG9,REG12               HIERARCHY MASK FOR UPDATE
         X     REG9,PSAHLHI             UPDATE HIERARCHY MASK BACK
         ST    REG9,PSAHLHI             STORE UPDATED STRING
         SPACE 2
*/* P SET UP WINDOW SPIN INTERFACE */
         SPACE 2
         L     REG8,PSALCCAV            GET LCCA ADDRESS
         LA    SPINRTNR,WINDSPIN        GET SPIN ROUTINE ADDRESS
         SPACE 2
*/* S WINDSPIN:GO TO OPEN WINDOW FOR EMS/MFA */
         SPACE 2
         BALR  MNLRETRN,SPINRTNR        GO TO WINDOW SPIN
         SPACE 2
*/* P (,GSLMUSPN) RELOAD SAVED REGS */
         SPACE 2
         LM    REG5,REG10,PSALKR5       RELOAD SAVED REGS
         B     GSLMUSPN                 TRY TO GET LOCK AGAIN
         SPACE  2
*/*GSLMUOH1: D (NO,STLKAB73,YES,) WAS LOCK HELD? */
         SPACE  2
GSLMUOH1 DC    0H'0'
         N     REG12,PSAHLHI            WAS LOCK HELD
         BZ    STLKAB73                 IF NOT ABEND CALLER
         L     REG12,PSALKR12           GET OFFSET VALUE
         C     REG11,PSACLHT(REG12)     SAME CLASS LOCK REQUESTED?
         BNE   STLKAB73                 IF SO ABEND
         SPACE 2
*/* P SET RC=4 */
*/*RETURN: R RETURN TO CALLER */
         SPACE 2
         LA    REG13,FOUR               SET RETURN CODE
         BR    RETURN                   RETURN TO CALLER
         TITLE 'IEAVELK -SETLOCK''S UNCONDITIONAL OBTAIN GLOBAL SPIN LO*
               CK ROUTINE (SINGLE LOCK AT GIVEN LEVEL) '
         ENTRY GSLSUOBT
         SPACE  2
*/*GSLSUOBT: E GSLSUOBT */
         SPACE  2
GSLSUOBT DS    0H
         USING *,BASER13
         SPACE  2
*/* P DISABLE CPU FOR I/O & EXT SAVE PSW SYS MASK IN MODEL PSW */
         SPACE  2
         STNSM PSAMPSW,DISABLE          DISABLE CPU FOR EXT & I/O INT
         SPACE  2
*/*GSLSUOBD: P SAVE REG PSALKSA */
         SPACE  2
*        THIS IS THE ENTRY USED FOR DISABLED CALLERS
GSLSUOBD DS    0H
         ST    REG12,PSALKR12           SAVE CALLERS REG12
         SPACE  2
*/* D (GE,GSLSUOH1,LT,) COMPARE BIT MASK WITH STRING */
         SPACE  2
         CL    ALECLHT,PSACLHS          LOCK HIERARCHY CHECK
         BNH   GSLSUOH1                 HIGHER OR SAME LK ALREADY HELD
         SPACE 2
*/*GSLSUSPN: P ZERO REG FOR CS */
         SPACE 2
GSLSUSPN DS    0H
         SLR   REG13,REG13              CLEAR REG FOR CS
*        NOTE-ADDRESSABILITY HAS JUST BEEN DESTROYED
         SPACE 2
*/* P SET HIERARCHY BIT ON IN MASK */
         SPACE 2
         O     REG12,PSAHLHI            UPDATE HIERARCHY MASK
         ST    REG12,PSAHLHI            STORE NEW VALUE IN MASK
         SPACE 2
*/* P GET CPUID FOR CS */
         SPACE 2
         LH    REG12,PSACPULA           GET CPUID FOR CS
         SPACE 2
*/* D (YES,RETURN1,NO,) IS LOCK AVAILABLE? */
         SPACE 2
         CS    REG13,REG12,ZERO(LKADDR11) GET LOCK
         BZR   RETURN                   IF GOTTEN RETURN TO CALLER
         SPACE 2
*/* P REESTABLISH ORIGINAL ADDRESSABILITY */
         SPACE 2
         BALR  BASER13,ZERO             REESTABLISH
         USING *,BASER13                ADDRESSABILITY
         L     BASER13,GSLSUOBS         GET OLD ADDRESS
         USING GSLSUOBT,BASER13         REESTABLISH OLD ADDR.
         SPACE 2
*/* P SET SETLOCK BIT */
         SPACE 2
         OI    PSASUP1,PSALOCK          SET SUPER BIT
         SPACE 2
*/* P SAVE REGS DESTROYED */
         SPACE 2
         STM   REG5,REG10,PSALKR5       SAVE DESTROYED REGS
         SPACE 2
*/* P RESET HIERARCHY MASK BIT TO ZERO */
         SPACE 2
         L     REG12,PSALKR12           GET HIERARCHY BIT MASK
         LR    REG9,REG12               GET BIT MASK FOR UPDATE
         X     REG9,PSAHLHI             UPDATE MASK BY CLEARING BIT
         ST    REG9,PSAHLHI             STORE NEW MASK VALUE
         SPACE 2
*/* P SET UP WINDOW SPIN INTERFACE */
         L     REG8,PSALCCAV            GET LCCA ADDRESS
         LA    SPINRTNR,WINDSPIN        GET WINDOW SPIN ADDRESS
         SPACE 2
*/* S WINDSPIN:GO TO OPEN WINDOW FOR EMS/MFA */
         SPACE 2
         BALR  MNLRETRN,SPINRTNR        GO TO WINDOW SPIN
         SPACE 2
*/* P RELOAD SAVED REGS */
*/* P (,GSLSUSPN) CLEAR SETLOCK BIT */
         SPACE 2
         LM    REG5,REG10,PSALKR5       RELOAD SAVED REGS
         NI    PSASUP1,LOCKNACT         CLEAR SUPER BIT
         B     GSLSUSPN                 TRY TO GET LOCK AGAIN
         SPACE 2
*/*GSLSUOH1: D (NO,STLKAB73,YES,) WAS LOCK HELD? */
         SPACE 2
GSLSUOH1 DC    0H'0'
         N     ALECLHT,PSACLHS          ZERO REG IF LOCK ALREADY HELD
         BZ    STLKAB73                 HIERARCHY VIOLATION
         SPACE 2
*/* P SET RC=4 FOR LOCK HELD */
*/*RETURN1: R RETURN TO CALLER */
         SPACE 2
         LA    REG13,FOUR               SET RETURN CODE
         BR    RETURN                   RETURN TO CALLER
         SPACE 2
*/*GSLSDISP: E DISP ENTRY FOR DISP LOCK */
         SPACE 2
*        THE FOLLOWING ENTRY IS SOLELY FOR THE USE OF THE DISPATCHER
         ENTRY GSLSDISP
GSLSDISP DS    0H
         USING *,BASER13
         SPACE 2
*/* P GET DISP LOCK ADDRESS */
         SPACE 2
         L     LKADDR11,ADISPLCK        GET DISPATCHER LOCK ADDRESS
         SPACE 2
*/*GSLSDSPN: P SET DISP LOCK HELD BIT IN MASK */
         SPACE 2
GSLSDSPN DS    0H
         OI    PSAHLHI+TWO,CX10         SET DISP LOCK BIT IN MASK
         SPACE 2
*/* P CLEAR REG FOR CS */
*/* P GET CPUID FOR CS */
         SPACE 2
         SLR   REG13,REG13              CLEAR REG FOR CS
*        NOTE-ADDRESSABILITY HAS JUST BEEN DESTROYED
         LH    REG12,PSACPULA           GET CPUID FOR CS
         SPACE 2
*/* D (YES,RETURN1,NO,) WAS DISP LOCK GOTTEN? */
         CS    REG13,REG12,ZERO(LKADDR11) GET LOCK
         BZR   RETURN                   IF GOTTEN RETURN TO CALLER
         SPACE 2
*/* P REESTABLISH ORIGINAL BASE */
         SPACE 2
         BALR  BASER13,ZERO             REESTABLISH
         USING *,BASER13                ADDRESSABILITY
         L     BASER13,GSLSDISB         GET OLD ADDRESS
         USING GSLSDISP,BASER13         REESTABLISH OLD ADDR.
         SPACE 2
*/* P CLEAR DISP BIT IN MASK */
         SPACE 2
         NI    PSAHLHI+TWO,CXEF         CLEAR DISP BIT IN MASK
         SPACE 2
*/* P SET SUPER BIT */
         SPACE 2
         OI    PSASUP1,PSALOCK          SET SUPER BIT
         SPACE 2
*/* P SAVE REGS DESTROYED */
         SPACE 2
         STM   REG5,REG10,PSALKR5       SAVE DESTROYED REGS
         SPACE 2
*/* P SET UP WINDOW SPIN INTERFACE */
         SPACE 2
         L     REG12,MASKDISP           GET HIERARCHY BIT MASK
         L     REG8,PSALCCAV            GET LCCA ADDRESS
         LA    SPINRTNR,WINDSPIN        GET WINDOW SPIN ADDRESS
         SPACE 2
*/* S WINDSPIN:GO OPEN EMS/MFA WINDOW */
         SPACE 2
         BALR  MNLRETRN,SPINRTNR        GO TO WINDOW SPIN
         SPACE 2
*/* P RESTORE SAVED REGS */
         SPACE 2
         LM    REG5,REG10,PSALKR5       RELOAD SAVED REGS
         SPACE 2
*/* P (,GSLSDSPN) CLEAR SETLOCK BIT */
         SPACE 2
         NI    PSASUP1,LOCKNACT         CLEAR SUPER BIT
         B     GSLSDSPN                 TRY TO GET LOCK AGAIN
         TITLE 'IEAVELK -SETLOCK''S CONDITIONAL OBTAIN GLOBAL SPIN LOCK*
                ROUTINE (MULTIPLE LOCKS AT SAME LEVEL) '
         ENTRY GSLMCOBT
         SPACE 1
         SPACE  2
*/*GSLMCOBT: E GSLMCOBT */
         SPACE  2
GSLMCOBT DS    0H
         USING *,BASER13
         SPACE  2
*/* P DISABLE CPU FOR I/O & EXT SAVE PSW SYS MASK IN MODEL PSW */
         SPACE  2
         STNSM PSAMPSW,DISABLE          DISABLE CPU FOR EXT & I/O INT
         SPACE  2
*/* P TURN ON SETLOCK ACTIVE INDICATOR IN PSA */
         SPACE  2
         OI    PSASUP1,PSALOCK          SETLOCK ACTIVE INDICATOR
         SPACE  2
*/* P SAVE REGS. PSALICSA */
         SPACE  2
         STM   REG9,REG10,PSALKR9       SAVE CALLERS REGS 9 AND 10
         SPACE  2
*/* P GET CLHT ENTRY FOR CONFLICT CHECK */
         SPACE 2
         L     ZERORG10,PSACLHT(ALECLHT) ZERO CS REG IF NO VIOLATION
         SPACE 2
*/* D (YES,GSLMCOH1,NO,) LOCK THIS LEVEL ALREADY HELD? */
         SPACE 2
         LTR   ZERORG10,ZERORG10        CHECK CLHT ENTRY FOR ZERO
         BNZ   GSLMCOH1                 LOCK HELD OR VIOLATE
         SPACE 2
*/* P GET LOGICAL CPU ID FROM PSA  */
*/* P FORM 'CS' LOCK ARG. */
         SPACE  2
         LH    CPUADDR9,PSACPULA        LOGICAL CPU ADDRESS
         SPACE  2
*/* P OBTAIN LOCK */
*/* D (YES,GSLMCOS,NO,GSLCOU) SUCESS? */
         SPACE  2
         CS    ZERORG10,CPUADDR9,ZERO(LKADDR11) WAS LOCK AVAILABLE?
         BNZ   GSLCOU                   LOCK NOT OBTAINED
         SPACE  2
*/*GSLMCOS: P PLACE LOCK'S ADDR INTO LOCK'S ENTRY IN CLHT */
         SPACE  2
GSLMCOS  DC    0H'0'                    LOCK SUCCESSFULLY OBTAINED
         ST    LKADDR11,PSACLHT(ALECLHT) STORE LOCK ADDR IN CLHT ENTRY
         SPACE 2
*/* P UPDATE CPU LOCKS HELD STRING */
         SPACE 2
         L     REGMASK,MASKTAB(ALECLHT) MASK TO UPDT STRING
         O     REGMASK,PSACLHS          UPDT LOCK HELD STRING
         ST    REGMASK,PSACLHS          STORE NEW STRING
         SPACE  2
*/*GSLMCOR: P SET RETURN CODE IN PROPER REG */
         SPACE  2
GSLMCOR  DC    0H'0'
         LR    RCREG13,REG10            GET RETURN CODE FROM REG10
         SPACE  2
*/* P RESTORE REGS. 9-10 */
         SPACE  2
         LM    REG9,REG10,PSALKR9       RESTORE CALLERS REGS 9 AND 10
         SPACE  2
*/* P TURN OFF ACTIVE INDICATOR */
         NI    PSASUP1,LOCKNACT         TURN OFF SETLOCK ACTIVE BIT
         SPACE  2
*/* P BR 14 RETURN WITH LOCK HELD & DISABLED */
*/* R RETURN */
         SPACE  2
         BR    RETURN                   RETURN DISABLED TO CALLER
         SPACE  2
*/*GSLMCOH1: P SET RC=4 LOCK ALREADY HELD */
         SPACE 2
GSLMCOH1 DC    0H'0'
         SPACE  2
*/* D (YES,STLKAB73,NO,GSLMCOR) DIFF LOCK OF SAME TYPE? */
         SPACE  2
         CR    LKADDR11,ZERORG10        DIFF LOCK OF SAME TYPE
         LA    REG10,FOUR               LOCK ALREADY HELD
         BE    GSLMCOR                  NO LOCK IS SAME AS ONE OWNED
         B     STLKAB73                 VIOLATION: ABEND CALLER
         TITLE 'IEAVELK -SETLOCK''S CONDITIONAL OBTAIN GLOBAL SPIN LOCK*
                ROUTINE (SINGLE LOCK AT THIS LEVEL) '
         ENTRY GSLSCOBT
         SPACE 1
         SPACE  2
*/*GSLSCOBT: E GSLSCOBT */
         SPACE  2
GSLSCOBT DS    0H
         USING *,BASER13
         SPACE  2
*/* P DISABLE CPU FOR I/O & EXT SAVE PSW SYS MASK IN MODEL PSW */
         SPACE  2
         STNSM PSAMPSW,DISABLE          DISABLE CPU FOR EXT & I/O INT
         SPACE  2
*/* P TURN ON SETLOCK ACTIVE INDICATOR IN PSA */
         SPACE  2
         OI    PSASUP1,PSALOCK          SETLOCK ACTIVE INDICATOR
         SPACE  2
*/* P SAVE REGS. PSALICSA */
         SPACE  2
         STM   REG9,REG10,PSALKR9       SAVE CALLERS REGS 9 AND 10
         SPACE  2
*/* P SAVE MASK FOR LOCK ALREADY HELD CHECK */
         SPACE 2
         LR    ZERORG10,ALECLHT         SAVE BIT MASK FOR STRING UPDATE
         SPACE 2
*/* D (YES,GSLSCOH1,NO,) LOCK ALREADY HELD? */
         SPACE 2
         N     ZERORG10,PSACLHS         THIS ZERO REG IF LOCK NOT HELD
         BNZ   GSLSCOH1                 LOCK ALREADY HELD
         SPACE 2
*/* P GET LOGICAL CPU ID FROM PSA  */
*/* P FORM 'CS' LOCK ARG. */
         SPACE  2
         LH    CPUADDR9,PSACPULA        LOGICAL CPU ADDRESS
         SPACE  2
*/* P OBTAIN LOCK */
*/* D (YES,GSLSCOS,NO,GSLCOU) SUCESS? */
         SPACE  2
         CS    ZERORG10,CPUADDR9,ZERO(LKADDR11) WAS LOCK AVAILABLE?
         BNZ   GSLCOU                   LOCK NOT OBTAINED
         SPACE 2
*/*GSLSCOS: P UPDATE CPU LOCKS HELD STRING */
         SPACE 2
GSLSCOS  DC    0H'0'                    LOCK SUCCESSFULLY OBTAINED
         O     ALECLHT,PSACLHS          UPDT LOCK HELD STRING
         ST    ALECLHT,PSACLHS          STORE NEW STRING
         SPACE  2
*/*GSLSCOR: P SET RETURN CODE IN PROPER REG */
         SPACE  2
GSLSCOR  DC    0H'0'
         LR    RCREG13,REG10            GET RETURN CODE FROM REG10
         SPACE  2
*/* P RESTORE REGS. 9-10 */
         SPACE  2
         LM    REG9,REG10,PSALKR9       RESTORE CALLERS REGS 9 AND 10
         SPACE  2
*/* P TURN OFF ACTIVE INDICATOR */
         NI    PSASUP1,LOCKNACT         TURN OFF SETLOCK ACTIVE BIT
         SPACE  2
*/* P BR 14 RETURN WITH LOCK HELD & DISABLED */
*/* R RETURN */
         SPACE  2
         BR    RETURN                   RETURN DISABLED TO CALLER
         SPACE 2
*/*GSLCOU: P SET RC=8 LOCK NOT AVAILABLE RESTORE REGS */
         SPACE  2
GSLCOU   DC    0H'0'
         LM    REG9,REG10,PSALKR9       RESTORE CALLERS REGS 9 AND 10
         LA    RCREG13,EIGHT            LOCK WAS HELD BY ANOTHER CPU
         SPACE  2
*/*GSLORET: P PLACE CALLER'S RETURN ADDR INTO MODEL PSW IN PSA */
         SPACE  2
GSLORET  DC    0H'0'
         LA    RETURN,ZERO(RETURN)      STORE CALLERS RETURN ADDRESS
         ST    RETURN,PSAMPSW+FOUR      IN MODEL PSW
         SPACE  2
*/* P TURN OFF ACTIVE INDICATOR IN PSASUP1 */
         SPACE  2
         NI    PSASUP1,LOCKNACT         TURN OFF SETLOCK ACTIVE BIT
         SPACE  2
*/* P LPSW NOTE: STATE SAME AS WHEN ENTERED */
*/* R RETURN */
         SPACE  2
         LPSW  PSAMPSW                  RETURN TO CALLER IN SAME STATE
         SPACE  2
*/*GSLSCOH1: P (,GSLSCOR) SET RC=4 LOCK ALREADY HELD */
         SPACE
GSLSCOH1 DC    0H'0'
         LA    REG10,FOUR               LOCK ALREADY HELD
         B     GSLSCOR                  GOTO COMMON RETURN CODE
         TITLE 'IEAVELK - SETLOCK RELEASE GLOBAL SPIN LOCK ROUTINE (MUL*
               TIPLE LOCKS AT SAME LEVEL) '
         ENTRY GSLMREL
         SPACE  2
*/*GSLMREL: E GSLMREL */
         SPACE  2
GSLMREL  DS    0H
         USING *,BASER13
         SPACE  2
*/* D (NO,GSLMRNH,YES,) IS LOCK HELD? */
         SPACE 2
         C     LKADDR11,PSACLHT(ALECLHT) IS LOCK HELD?
         BNE   GSLMRNH                  NO: GO SET RETURN CODE
         SPACE 2
*/* P TURN ON ACTIVE INDICATOR IN PSW */
         SPACE  2
         OI    PSASUP1,PSALOCK          TURN ON SETLOCK ACTIVE BIT
         SPACE  2
*/* P UPDATE CPU LOCKS HELD STRING */
         SPACE 2
         L     REG13,MASKTAB2(ALECLHT)  GET MASK FOR UPDT
         N     REG13,PSACLHS            UPDATE STRING
         ST    REG13,PSACLHS            STORE NEW STRING
         SPACE  2
*/* P CLEAR LOCK AND LOCK'S ENTRY IN CLHT */
         SPACE  2
         SR    REG13,REG13              ZERO IN REG13
         ST    REG13,0(LKADDR11)        RESET LOCKWORD TO ZERO
         ST    REG13,PSACLHT(ALECLHT)   CLEAR CLHT ENTRY
         SPACE  2
*/* P TURN OFF ACTIVE INDICATOR */
         SPACE 2
         NI    PSASUP1,LOCKNACT         TURN OFF SETLOCK ACTIVE BIT
         BALR  BASER13,ZERO             RESET ADDRESSABILITY
         USING *,BASER13
         SPACE  2
*/* D (YES,GSLMRRD,NO,) SYS. DISABLED INDICATOR ON? */
         SPACE  2
         L     REG12,SUPMASK            MASK TO CHECK SUP CONTROL BYTES
         N     REG12,PSASUPER           ZERO REG IF ONLY SETLOCK BIT ON
         BNZ   GSLMRRD                  SUPERVISOR RETURN DISABLED
         SPACE 2
*/* D (YES,GSLMRRD,NO,) OTHER SPIN LOCKS HELD? */
         SPACE 2
         LA    REG12,FRSTSPIN           ONE IN 1ST SPIN LOCK POSITION
         CL    REG12,PSACLHS            COMPARE WITH NEW STRING VALUE
         BNH   GSLMRRD                  TO RETURN DISABLED
         SPACE 2
*/* P ENABLE FOR IO & EXT */
         SPACE 2
         STOSM PSAMPSW,ENABLE           ENABLE FOR IO & EXT
         SPACE 2
*/* GSLMRRD: P SET RC=0 */
         SPACE 2
GSLMRRD  DC    0H'0'
         SR    RCREG13,RCREG13          RC 0 - RELEASE SUCCESSFUL
         SPACE 2
*/* P RETURN TO CALLER DISABLED */
*/* R RETURN */
         SPACE  2
         BR    RETURN                   RETURN DISABLE
         TITLE 'IEAVELK - SETLOCK RELEASE GLOBAL SPIN LOCK ROUTINE (SIN*
               GLE LOCK AT THIS LEVEL) '
         ENTRY GSLSREL
         SPACE  2
*/*GSLSREL: E GSLSREL */
         SPACE  2
GSLSREL  DS    0H
         USING *,BASER13
         SPACE  2
*/* P UPDATE CPU LOCKS HELD STRING */
         SPACE 2
         N     ALECLHT,PSACLHS          UPDATE STRING
         ST    ALECLHT,PSACLHS          STORE NEW STRING
         SPACE  2
*/* P GET CONTENT OF LOCKWORD */
*/* D (NO,GSLSRNH,YES,) IS LOCK HELD? */
         SPACE 2
         L     REG12,0(LKADDR11)        GET CONTENT OF LOCKWORD
         CH    REG12,PSACPULA           IS LOCK HELD?
         BNE   GSLSRNH                  NO: GO SET RETURN CODE
         SPACE  2
*/* P RELEASE LOCK */
         SPACE  2
         SR    REG12,REG12              GET FULLWORD OF ZEROES
         ST    REG12,0(LKADDR11)        STORE IN LOCKWORD
         SPACE  2
*/* D (YES,GSLSRRD,NO,) SYS. DISABLED INDICATOR ON? */
         SPACE  2
         L     REG12,SUPMASK            MASK TO CHECK SUP CTRL BYTES
         N     REG12,PSASUPER           ZERO REG IF ONLY SETLOCK BIT ON
         BNZ   GSLSRRD                  RELEASE DISABLED
         SPACE  2
*/* D (YES,GSLSRRD,NO,) OTHER SPIN LOCKS HELD? */
         SPACE 2
         LA    REG12,FRSTSPIN           ONE IN 1ST SPIN LOCK POSITION
         CL    REG12,PSACLHS            COMPARE WITH NEW STRING VALUE
         BNH   GSLSRRD                  TO RETURN DISABLED
         SPACE 2
*/* P ENABLE FOR IO & EXT */
         SPACE 2
         STOSM PSAMPSW,ENABLE           ENABLE FOR IO & EXT
         SPACE 2
*/*GSLSRRD: P SET RC=0 */
         SPACE  2
GSLSRRD DC    0H'0'
         SR    RCREG13,RCREG13          RC 0 - RELEASE SUCCESSFUL
         SPACE  2
*/* P RETURN TO CALLER DISABLED */
*/* R RETURN */
         SPACE  2
         BR    RETURN                   RETURN DISABLE
         TITLE 'IEAVELK - SETLOCK''S RELEASE DISABLED GLOBAL SPIN LOCK *
               ROUTINE(MULTIPLE LOCKS AT SAME LEVEL)'
         SPACE  2
*/*GSLMRELD: E GSLMRELD */
         SPACE  2
         ENTRY GSLMRELD
GSLMRELD DS    0H
         USING *,BASER13
         SPACE  2
*/* D (NO,GSLMRNH,YES,) IS LOCK HELD? */
         SPACE 2
         C     LKADDR11,PSACLHT(ALECLHT) IS LOCK HELD?
         BNE   GSLMRNH                  NO: GO SET RETURN CODE
         SPACE 2
*/* P TURN ON ACTIVE INDICATOR IN PSW */
         SPACE  2
         OI    PSASUP1,PSALOCK          TURN ON SETLOCK ACTIVE BIT
         SPACE  2
*/* P UPDATE CPU LOCKS HELD STRING */
         SPACE 2
         L     REG13,MASKTAB2(ALECLHT)  GET MASK FOR UPDT
         N     REG13,PSACLHS            UPDATE STRING
         ST    REG13,PSACLHS            STORE NEW STRING
         SPACE  2
*/* P CLEAR LOCK AND LOCK'S ENTRY IN CLHT */
         SPACE  2
         SR    REG13,REG13              ZERO IN REG13
         ST    REG13,0(LKADDR11)        RESET LOCKWORD TO ZERO
         ST    REG13,PSACLHT(ALECLHT)   CLEAR CLHT ENTRY
         SPACE  2
*/* P TURN OFF ACTIVE INDICATOR */
         SPACE 2
         NI    PSASUP1,LOCKNACT         TURN OFF SETLOCK ACTIVE BIT
         SPACE  2
*/* P SET RC=0 */
         SPACE 2
         SPACE 2
*/* P RETURN TO CALLER DISABLED */
*/* R RETURN */
         SPACE  2
         BR    RETURN                   RETURN DISABLE
         TITLE 'IEAVELK - SETLOCK''S RELEASE DISABLED GLOBAL SPIN LOCK *
               ROUTINE(SINGLE LOCK AT THIS LEVEL)'
         SPACE  2
*/*GSLSRELD: E GSLSRELD */
         SPACE  2
         ENTRY GSLSRELD
GSLSRELD DS    0H
         USING *,BASER13
         SPACE  2
*/* P UPDATE CPU LOCKS HELD STRING */
         SPACE 2
         N     ALECLHT,PSACLHS          UPDATE STRING
         ST    ALECLHT,PSACLHS          STORE NEW STRING
         SPACE  2
*/* P GET CONTENT OF LOCKWORD */
*/* D (NO,GSLSRNH,YES,) IS LOCK HELD? */
         SPACE 2
         L     REG12,0(LKADDR11)        GET CONTENT OF LOCKWORD
         CH    REG12,PSACPULA           IS LOCK HELD?
         BNE   GSLSRNH                  NO: GO SET RETURN CODE
         SPACE  2
*/* P RELEASE LOCK */
         SPACE  2
         SR    REG12,REG12              GET FULLWORD OF ZEROES
         ST    REG12,0(LKADDR11)        STORE IN LOCKWORD
         SPACE  2
*/* P SET RC=0 */
         SPACE  2
         SR    RCREG13,RCREG13          RC 0 - RELEASE SUCCESSFUL
         SPACE  2
*/* P RETURN TO CALLER DISABLED */
*/* R RETURN */
         SPACE  2
         BR    RETURN                   RETURN DISABLE
         SPACE  2
*/*GSLMRNH: P GET CONTENT OF LOCKWORD */
         SPACE 2
GSLMRNH  DC    0H'0'
         L     REG12,0(LKADDR11)        GET LOCKWORD CONTENT
         SPACE 2
*/*GSLSRNH: P PRESET RETURN CODE FOR LOCK NOT HELD */
         SPACE 2
GSLSRNH  DC    0H'0'
         LA    RCREG13,FOUR             PRESET RC FOR LOCK NO HELD
         SPACE 2
*/* D (YES,,NO,GSLRNA) IS LOCK AVALIABLE? */
*/* P RETURN TO CALLER IN SAME STATE */
*/* R RETURN */
         SPACE 2
         LTR   REG12,REG12              CHECK LOCKWORD FOR ZERO
         BCR   EIGHT,RETURN             RETURN IF ZERO
         SPACE 2
*/*GSLRNA: P SET RETURN CODE LOCK HELD BY ANOTHER CPU */
*/* P RETURN TO CALLER IN SAME STATE */
*/* R RETURN */
         SPACE 2
         LA    RCREG13,EIGHT            SET RC LOCK HELD BY ANOTHER CPU
         BR    RETURN                   RETURN TO CALLER
         TITLE 'IEAVELK - SETLOCK''S CONDITIONAL OBTAIN LOCAL LOCK ROUT*
               INE'
         SPACE  2
*/*LLCOBT: E LLCOBT */
         SPACE  2
         ENTRY LLCOBT
LLCOBT   DS    0H
         USING *,BASER13                ESTABLISH ADDRESSABILITY
         SPACE  2
*/* P DISABLE CPU FOR I/O & EXT SAVE PSW SYS MASK IN MODEL PSW */
         SPACE  2
         STNSM PSAMPSW,DISABLE          DISABLE CPU FOR EXT & I/O INT
         SPACE  2
*/*LLSUP: P TURN ON ACTIVE INDICATOR IN PSA */
         SPACE  2
LLSUP    OI    PSASUP1,PSALOCK          SETLOCK ACTIVE INDICATOR
         SPACE  2
*/* P SAVE REGS 9 & 10 */
         SPACE  2
         ST    REG9,PSALKR9             SAVE CALLERS REG 9     @Z40FPXJ
         ST    REG10,PSALKR10           SAVE CALLERS REG 10    @Z40FPXJ
*/* P GET ASCB ADDR FROM PSAAOLD */
         SPACE  2
         L     LKADDR11,PSAAOLD         OBTAIN CURRENT ASCB ADDRESS
         SPACE 2
*/* D (NO,LLCOLH,YES,) IS LOCAL LOCK ALREADY HELD? */
         SPACE 2
         TM    PSACLHS+3,LOCAL          IS LOCAL LOCK ALREADY HELD?
         BO    LLCOLH                   RETURN LOCK ALREADY HELD
*                                       NB: THE ONLY LOCAL LK POSSIBLY
*                                       HELD IS SAME AS REQUIRED; ANY
*                                       OTHER IS SUSPENDED BEFORE THIS
*                                       TASK IS DISPATCHED.
         SPACE 2
*/* P GET LOGICAL CPU ID */
         SPACE  2
         LH    CPUADDR9,PSACPULA        OBTAIN LOGICAL CPU ADDRESS
         SPACE  2
*/* P FORM 'CS' LOCK ARGUMENT */
         SPACE 2
         LA    ZERORG10,ZERO            FULLWORD OF ZEROS
         SPACE 2
*/* P OBTAIN LOCAL LOCK */
*/* D (NO,LLCOU,YES,) SUCCESS? */
         SPACE  2
         CS    ZERORG10,CPUADDR9,ASCBLOCK IS LOCK AVAILABLE
         BNZ   LLCOU                    LOCK IS HELD BY ANOTHER CPU
         SPACE  2
*/* P UPDATE CPU LOCKS HELD STRING */
         SPACE 2
         OI    PSACLHS+3,LOCAL          UPDATE STRING
         SPACE  2
*/*LLCORET: P SET RETURN CODE IN PROPER REG */
         SPACE  2
LLCORET  DS    0H'0'
         LR    RCREG13,REG10            GET RETURN CODE FROM REG10
         SPACE  2
*/* P RESTORE REGS */
         SPACE  2
         L     REG9,PSALKR9              RESTORE CALLERS REG 9 @Z40FPXJ
         L     REG10,PSALKR10            RESTORE CLRS REG 10   @Z40FPXJ
*/* P TURN OFF ACTIVE INDICATOR */
         SPACE  2
         NI    PSASUP1,LOCKNACT         TURN OFF SETLOCK ACTIVE BIT
         SPACE 2
*/*LLCORET1: P PLACE RTN ADDR INTO MODEL PSW IN PSA */
         SPACE  2
         LA    RETURN,ZERO(RETURN)      STORE CALLERS RETURN ADDRESS
         ST    RETURN,PSAMPSW+FOUR      IN MODEL PSW
         SPACE 2
*/* P LPSW RETURN IN STATE CALLED */
*/* R RETURN */
         SPACE  2
         LPSW  PSAMPSW                  RETURN TO CALLER IN SAME STATE
         SPACE 2
*/*LLCOLH: P (,LLCORET) SET RC=4 "ALREADY OWNED" */
         SPACE  2
LLCOLH   DS    0H'0'
         LA    REG10,FOUR               R.C 4, LOCK ALREADY OWNED
         B     LLCORET                  BRANCH TO COMMON RETURN CODE
         SPACE 2
*/*LLCOU: P (,LLCORET) SET RC=8 */
         SPACE  2
LLCOU    DC    0H'0'
         LA    REG10,EIGHT              RC 8, LOCK HELD BY ANOTHER CPU
         B     LLCORET                  GO TO COMMON RETURN CODE
         SPACE 2
*/*LLCOSVCF: E SVC FLIH LOCAL OBTAIN ENTRY */
         SPACE 2
*        THE FOLLOWING ENTRY IS SOLELY FOR THE USE OF THE SVCFLIH
         ENTRY LLCOSVCF
LLCOSVCF DS    0H
         USING *,BASER13
         SPACE 2
*/* P SET LOCAL LOCK BIT IN MASK */
         SPACE 2
         OI    PSAHLHI+3,LOCAL          SET HIERARCHY BIT FOR LOCAL
         SPACE 2
*/* P GET ASCB ADDRESS FOR CS */
*/* P GET CPUID FOR CS */
*/* P ZERO REG FOR CS */
         SPACE 2
         L     REG11,PSAAOLD            GET ASCB ADDRESS
         LH    REG12,PSACPULA           GET CPUID
         SLR   REG13,REG13              ZERO REG FOR CS
*        NOTE-ADDRESSABILITY HAS JUST BEEN DESTROYED
         SPACE 2
*/* D (YES,RETURN2,NO,) WAS LOCK OBTAINED? */
         SPACE 2
         CS    REG13,REG12,ASCBLOCK     TRY TO GET LOCK
         BZR   RETURN                   IF GOTTEN RETURN
         SPACE 2
*/* P CLEAR LOCAL BIT IN MASK */
*/* P SET RETURN CODE=8 */
*/*RETURN2: R RETURN TO SVCFLIH */
         SPACE 2
         NI    PSAHLHI+3,CXFE           CLEAR LOCAL LOCK BIT
         LA    REG13,EIGHT              SET RETURN CODE
         BR    RETURN                   RETURN TO SVCFLIH
         TITLE 'IEAVELK - SETLOCK''S RELEASE LOCAL LOCK ROUTINE'
*/*LRELEXPR: E EXIT PROLOGUE RELEASE LOCAL ENTRY */
         SPACE 2
*        THE FOLLOWING ENTRY IS SOLELY FOR THE USE OF EXIT PROLOGUE
         ENTRY LRELEXPR
LRELEXPR DS    0H
         USING *,REG11
         SPACE 2
*/* P (,LRELDISP) SET DISABLE INDICATOR */
         SPACE 2
         MVI   PSAMPSW,CX04             SET DISABLED INDICATOR
         B     LRELDISP                 GO TO MAINLINE CODE
         DROP  REG11
         USING ASCB,REG11
         ENTRY LLREL
         SPACE  2
*/*LLREL: E LLREL */
         SPACE  2
LLREL    DS    0H
         USING *,BASER13                ESTABLISH BASE REGISTER
         SPACE  2
*/* P DISABLE CPU FOR I/O & EXT SAVE PSW SYS MASK IN MODEL PSW */
         SPACE  2
         STNSM PSAMPSW,DISABLE          DISABLE & SAVE CALLER'S STATE
         SPACE  2
*/*LLSUP2: D (NO,,YES,STLKAB73) CMS LOCK HELD BY CALLER? */
         SPACE  2
LLSUP2   TM    PSACLHS+3,CMS            DOES THIS CPU HOLD CMS LOCK
         BO    STLKAB73                 CMS LOCK HELD BY THIS CPU:ABEND
         SPACE 2
*/*LRELDISP: E THIS ENTRY IS USED BY DISP ONLY */
         SPACE 2
*        THE FOLLOWING ENTRY IS USED SOLELY BY THE DISPATCHER
         ENTRY LRELDISP
LRELDISP DS    0H
         SPACE  2
*/* P GET ASCB'S ADDR FROM PSA LOCAL LOCK IN ASCB */
         SPACE  2
         L     REG11,PSAAOLD            GET CURRENT ASCB ADDRESS
         SPACE  2
*/* P GET CONTENT OF LOCKWORD */
         SPACE  2
         L     REG12,ASCBLOCK           GET CONTENT OF LOCKWORD
         SPACE  2
*/* D (NO,LLRELNH,YES,) IS LOCK HELD? */
         SPACE 2
         CH    REG12,PSACPULA           IS LOCK HELD?
         BNE   LLRELNH                  NO: GO SET RETURN CODE
*/* P SAVE REGS */
         SPACE  2
         STM   REG6,REG10,PSALKR6       SAVE CALLERS REGISTERS @Z40FPXJ
         SPACE  2
*/* P TURN SETLOCK ACTIVE INDICATOR IN PSA */
         SPACE  2
         OI    PSASUP1,PSALOCK          SETLOCK ACTIVE INDICATOR ON
         SPACE  2
*/*LLRELDAH: P SET ASCB ADDRESSABILITY */
         SPACE 2
LLRELDAH DC    0H'0'
         LR    REG9,REG11               GET ASCB ADDR          @Z40FPXJ
         DROP  REG11
         USING ASCB,REG9
         SPACE 2
*/* D (YES,LLRELSRB,NO,) ARE ANY SRB'S SUSPENDED? */
         SPACE 2
         LR    R6,REG12                 GET LOCKWORD           @Z40FPXJ
         SLR   R7,R7                    ZERO FOR CS            @Z40FPXJ
         SLR   R10,R10                  ZERO FOR CS            @Z40FPXJ
         SLR   R11,R11                  ZERO FOR CS            @Z40FPXJ
         CDS   R6,R10,ASCBLOCK          IF Q IS EMPTY, ZERO LK @Z40FPXJ
         BNZ   LLRELSRB                 Q NOT EMPTY, REL SRB   @Z40FPXJ
         SPACE 2                                               @Z40FPXJ
*/* P RELEASE THE LOCAL LOCK */                                @Z40FPXJ
*/* D (YES,LLRELMS,NO,) MUST MEMORY SWITCH BE INVOKED? */
         SPACE 2                                               @Z40FPXJ
         NI    PSACLHS+3,ALLONES-LOCAL   UPDATE STRING         @Z40FPXJ
         TM    ASCBFLG2,ASCBS2S         HAS STAGE 2 BEEN INVOKED?
         BO    LLRELMS                  YES INVOKE MEMORY SWITCH
         L     REG10,ASCBTCBS           COMPARE NUMBER OF READY TCBS
         C     REG10,ASCBCPUS           IN THIS ADDR SPACE TO NO. CPUS
         BH    LLRELMS                  ACTIVE IN ADDR SPACE
         SPACE 2
*/*LLRELRET: P RESTORE REGS */
         SPACE 2
LLRELRET DS    0H'0'
         LM    REG6,REG10,PSALKR6       RESTORE CALLER'S REGS  @Z40FPXJ
         SPACE 2
*/*LLRELRT1: P TURN OFF ACTIVE INDICATOR IN PSA */             @Z40FPXJ
*/*  P SET RETURN CODE IN PROPER REG */                        @Z40FPXJ
         SPACE 2
LLRELRT1 DC    0H'0'
         NI    PSASUP1,LOCKNACT         TRN OFF STLCK ACT BIT  @Z40FPXJ
         LR    RCREG13,REG11            GET RTRN CD FRM REG11  @Z40FPXJ
         SPACE 2
*/* D (YES,,NO,LLRELRT2) WAS CALLER SUPER? */
*/* P RETURN VIA BRANCH INSTRUCTION */
*/* R RETURN */
         SPACE 2
         L     REG11,PSASUPER           GET SUPER BITS
         LTR   REG11,REG11              ARE ANY ON
         BNZR  RETURN                   IF SO RETURN DISABLED
         TM    PSAMPSW,ENABLE           WAS  CALLER DISABLED?
         BCR   EIGHT,RETURN             YES: RETURN VIA BRANCH
         SPACE 2
*/*LLRELRT2: P PLACE RETURN ADDR INTO MODEL PSW IN PSA */
         SPACE 2
         LA    RETURN,ZERO(RETURN)      STORE CALLER'S RETURN ADDR
         ST    RETURN,PSAMPSW+FOUR      IN MODEL PSW
         SPACE 2
*/* P LPSW RETURN IN SAME STATE AS CALLED */
*/* R RETURN */
         SPACE 2
         LPSW  PSAMPSW                  RETURN TO CALLER IN SAME STATE
*                                       AS CALLED.
         SPACE 2
*/*LLRELNH: P (,LLRELRT1) SET PROPER RETURN CODE: -4= LOCK FREE; -8=
*/*LOCK HELD BY OTHER CPU */
         SPACE 2
LLRELNH  DC    0H'0'
         LTR   REG12,REG12              WAS LOCK AVALIABLE?
         BNZ   LLRELOCH                 NO: HELD BY OTHER CPU
         LA    REG11,FOUR               SET LK FREE RTN CODE   @Z40FPXJ
         B     LLRELRT1                 GO TO COMMON RETURN CODE
LLRELOCH DC    0H'0'
         LA    REG11,EIGHT              SET LK HLD BY CPU R.C. @Z40FPXJ
         B     LLRELRT1                 GO TO COMMON RETURN CODE
         SPACE 2
*/*LLRELSRB: P SAVE REGS USED BY SCHEDULE */
         SPACE 2
LLRELSRB DC    0H'0'
         ST    REG0,PSALKR0        SAVE CALLERS REGISTER 0     @Z40FPXJ
         ST    REG1,PSALKR1        SAVE CALLERS REGISTER 1     @Z40FPXJ
         ST    REG14,PSALKR14      SAVE CALLERS REGISTER 14    @Z40FPXJ
         ST    REG15,PSALKR15      SAVE CALLERS REGISTER 15    @Z40FPXJ
         USING SRBSECT,REG7             RG7 NOW THE SRB BASE   @Z40FPXJ
         SPACE 2
*/*LLRELSCH:S DEQUEUE TOP SRB AND SCHEDULE IT */               @Z40FPXJ
         SPACE 2                                               @Z40FPXJ
         DROP  REG9                                            @Z40FPXJ
         LR    REG11,REG9               GET ASCB ADDRESS       @Z40FPXJ
         USING ASCB,REG11                                      @Z40FPXJ
         LA    REG6,ASCBLOCK            GET ADDR OF LOCK WORD  @Z40FPXJ
LLRSRBLK DS    0H                                              @Z40FPXJ
         L     REG8,SRBFLNK             GET SRB LINK FIELD     @Z40FPXJ
         LTR   REG8,REG8                IS LINK ZERO?          @Z40FPXJ
         BZ    LLRCSDEQ                 YES, CS TO DEQUEUE     @Z40FPXJ
         SPACE 2                                               @Z40FPXJ
*/* D (YES,LLRCSDEQ,NO,) ONLY ONE SSRB ON QUEUE? */            @Z40FPXJ
*/*LLRUPTNX: P UPDATE TO NEXT SSRB */                          @Z40FPXJ
*/* D (YES,,NO,LLRUPTNX) IS THIS THE LAST SSRB? */             @Z40FPXJ
*/* P (,LLRSPNID) ZERO NEW LAST FOWARD PTR */                  @Z40FPXJ
*/*LLRCSDEQ: D (YES,,NO,LLRELSCH) C.S. SSRB SUCCESSFUL */      @Z40FPXJ
*/*LLRSPNID: P PUT SUSPEND ID IN LOCK */                       @Z40FPXJ
*/* P (,LLRELRET) SCHEDULE SSRB */                             @Z40FPXJ
         SPACE 2                                               @Z40FPXJ
LLRUPTNX DS 0H                                                 @Z40FPXJ
         LR    REG6,REG7                SAVE PREV ELEMENT PTR  @Z40FPXJ
         LR    REG7,REG8                UPDATE PTR TO CURRENT  @Z40FPXJ
         L     REG8,SRBFLNK             GER SRB LINK FIELD     @Z40FPXJ
         LTR   REG8,REG8                IS LINK ZERO?          @Z40FPXJ
         BNZ   LLRUPTNX                 NO, GET NEXT SRB       @Z40FPXJ
         ST    REG8,SRBFLNK-SRBSECT(0,6) ZERO PREV FWD PTR     @Z40FPXJ
         B     LLRSPNID                 GIVE LOCK TO SRB       @Z40FPXJ
LLRCSDEQ DS    0H                                              @Z40FPXJ
         CS    REG7,REG8,SRBFLNK-SRBSECT(6) CS ELE OFF QUEUE   @Z40FPXJ
         BNZ   LLRSRBLK                 NOT SUCCESFUL, DO OVER @Z40FPXJ
LLRSPNID DS    0H                                              @Z40FPXJ
         L     REG6,SUSPNDID            GET SUSPEND ID         @Z40FPXJ
         ST    REG6,ASCBLOCK            STORE IT IN LOCK       @Z40FPXJ
         NI    PSACLHS+3,ALLONES-LOCAL  UPDATE LK HELD STRING  @Z40FPXJ
         OI    SSRBFLG1,SSRBLLH         SSRB OWNS LOCAL LOCK   @Z40FPXJ
         L     REG6,SSRBGPRS+56         GET SRB RTRN ADDR(R14) @Z40FPXJ
         LA    REG6,ZERO(REG6)          ZERO OUT HIGH BYTE     @Z40FPXJ
         ST    REG6,SSRBCPSW+4          STORE RTRN ADDR IN PSW @Z40FPXJ
         ST    REG10,SSRBGPRS+52        SET R13 R.C. TO ZERO   @Z40FPXJ
         SCHEDULE SRB=(7)               SCHEDULE SSRB          @Z40FPXJ
         B     LLRELNDP                                        @Z40FPXJ
         SPACE 2                                               @Z40FPXJ
*/*LLRELMS: P SAVE REGS USED BY MEMORY SWITCH */               @Z40FPXJ
         SPACE 2                                               @Z40FPXJ
LLRELMS  DC    0H'0'                                           @Z40FPXJ
         ST    REG0,PSALKR0             SAVE CALLERS REG 0     @Z40FPXJ
         ST    REG1,PSALKR1             SAVE CALLERS REG 1     @Z40FPXJ
         ST    REG14,PSALKR14           SAVE CALLERS REG 14    @Z40FPXJ
         ST    REG15,PSALKR15           SAVE CALLERS REG 15    @Z40FPXJ
         LR    REG1,REG9                MORE ACTIVE TCBS THAN CPUS,
         LH    REG0,ASCBAFFN-ASCB(REG1) GET AFFINITY MASK
         C     REG0,NOCPUAFF            TEST FOR AFFN SPECIFIED
         BE    LLRELMS1                 NO AFFINITY SPECIFIED
         LCR   REG1,REG1                INDICATE AFFINITY TO MS
LLRELMS1 DC    0H'0'                                           @Z40FPXJ
         SPACE 2                                               @Z40FPXJ
*/*LLRELMS2: S INVOKE MEMORY SWITCH */                         @Z40FPXJ
         SPACE 2                                               @Z40FPXJ
LLRELMS2 L     REG15,AMEMSW             CRNT ASCB ADDR RG1 &   @Z40FPXJ
         BALR  REG14,REG15              MEMORY SWITCH IS CALLED
         SPACE 2                                               @Z40FPXJ
*/* LLRELNDP: P (,LLRELRET) RESTORE CALLER'S REGISTERS */      @Z40FPXJ
         SPACE 2
LLRELNDP DS    0H                                              @Z40FPXJ
         L     REG0,PSALKR0             RESTORE CALLERS REG 0  @Z40FPXJ
         L     REG1,PSALKR1             RESTORE CALLERS REG 1  @Z40FPXJ
         L     REG14,PSALKR14           RESTORE CALLERS REG 14 @Z40FPXJ
         L     REG15,PSALKR15           RESTORE CALLERS REG 15 @Z40FPXJ
         SLR   R11,R11                  GET A ZERO R.C.        @Z40FPXJ
         B     LLRELRET                 RETURN                 @Z40FPXJ
         USING ASCB,REG11                                      @Z40FPXJ
         DROP  REG7                                            @Z40FPXJ
         TITLE 'IEAVELK - SETLOCK''S UNCONDITIONAL OBTAIN LOCAL LOCK RO*
               UTINE'
         ENTRY LLUOBT
         SPACE 2
*/*LLUOBT: E LLUOBT */
         SPACE 2
LLUOBT   DS    0H
         USING *,BASER13                ESTABLISH ADDRESSABILITY
         SPACE 2
*/* D (YES,LLULKSH,NO,) ARE SUPER BITS OR HIERARCHY BITS ON? */
         SPACE 2
         L     REG11,PSASUPER           GET SUPER BITS
         O     REG11,PSAHLHI            ARE ANY SUPER OR HIER BITS ON
         BNZ   LLULKSH                  IF SO GO CHECK FURTHER
         SPACE 2
*/* P DISABLE CPU FOR EXT & I/O SAVE PSW SYS. MASK IN MODEL PSW */
         SPACE 2
         STNSM PSAMPSW,DISABLE          DISABLE & SAVE CALLERS STATE
         SPACE 2
*/* P TURN ON ACTIVE INDICATOR */
         SPACE 2
         OI    PSASUP3,PSAULCMS         SETLOCK ACTIVE IN A POSSIBLE
*                                       SUSPEND PATH           @ZA28255
         SPACE 2
*/* P GET ASCB'S ADDR FROM PSA LOCAL LOCK IN ASCB */
         SPACE 2
         L     LKADDR11,PSAAOLD         GET ASCB ADDRESS
         SPACE 2
*/* P GET LOGICAL CPUID FROM PSA */
         SPACE 2
         LH    REG12,PSACPULA           GET CPU LOGICAL ADDRESS
         SPACE 2
*/* P FORM 'CS' LOCK ARG */
         SPACE 2
         SLR   REG13,REG13              ZERO REG FOR CS
*        note-ADDRESSABILITY HAS JUST BEEN DESTROYED
         SPACE 2
*/* P OBTAIN LOCAL LOCK */
*/* P REESTABLISH ADDRESSABILITY */
*/* D (NO,LLUSUPND,YES,) SUCCESS? */
         SPACE 2
         CS    REG13,REG12,ASCBLOCK     WAS LOCK AVAILABLE
         BALR  REG12,ZERO               SET
         USING *,REG12                  ADDRESSABILITY
         BNZ   LLUSUPND                 LOCK HELD BY ANOTHER CPU
         SPACE 2
*/* P SET LOCAL LOCK BIT IN MASK */
         SPACE 2
*        NOTE-ADDRESSABILITY EXIST FROM HERE TO LPSW USING REG12
         OI    PSAHLHI+3,LOCAL          SET LOCAL HIERARCHY BIT
         SPACE 2
*/* P (,LLURET) CLEAR SETLOCK BIT */
         SPACE 2
         NI    PSASUP3,ALLONES-PSAULCMS SETLOCK NOT ACTIVE     @ZA28255
         LA    RETURN,ZERO(RETURN)      CLEAR RETURN REG
         ST    RETURN,PSAMPSW+FOUR      BUILD RETURN PSW
         LPSW  PSAMPSW                  RETURN TO REQUESTOR
         SPACE 2
*/*LLUSUPND: P REESTABLISH ORIGINAL BASE */
*/* P SAVE REGS DESTROYED */
*/* D (YES,LLUSPSRB,NO,) SRB MODE? */
         SPACE 2
LLUSUPND DC    0H'0'
         L     BASER13,LLUOBS           GET ORIGINAL ADDRESS
         DROP  REG12                    DROP ADDRESSABILITY
         USING LLUOBT,BASER13           REESTABLISH ADDRESSABILITY
         STM   REG6,REG10,PSALKR6       SAVE REGS              @Z40FPXJ
         L     LCCAPTR,PSALCCAV         OBTAIN LOGICAL CCA ADDRESS
         USING LCCA,LCCAPTR             ESTABLISH LCCA ADDRESSABILITY
         TM    LCCADSF2,LCCASRBM        TEST IF CALLER IS SRB MODE
         BO    LLUSPSRB                 CALLER IS IN SRB MODE
         SPACE 2
*/* P SAVE ALL GP REGS IN TCB */
         SPACE 2
         L     TCBPTR,PSATOLD           CURRENT TCB ADDRESS
         USING TCB,TCBPTR               ESTABLISH TCB ADDRESSABILITY
         STM   REG0,REG15,TCBGRS        SAVE ALL CURRENT REGS IN TCB
         SPACE 2
*/* P PLACE CALLER E.P. TO SETLOCK INTO MODEL PSW */
         SPACE 2
         MVC   TCBGRS6(20),PSALKR6      SAV CLRS RGS AT ENTRY  @Z40FPXJ
         L     RBPTR,TCBRBP             LOCATE TOP RB
         USING RBSECT,RBPTR             ESTABLISH RB ADDRESSABILITY
         L     REG4,PSAMPSW             CALLERS STATE AT ENTRY
         SPACE 2
*/* P SAVE MODEL PSW IN RBOPSW */
         SPACE 2
         ST    REG4,RBOPSW              SAVE STATE IN RB
         LA    BASER13,ZERO(BASER13)    GOOD PSW ADDR
         ST    BASER13,RBOPSW+FOUR      SET IC TO LOCK RTN'S ENTRY
         L     REG15,AIEA0DS            DISPATCHERS ENTRY POINT
         SPACE 2
*/* P TURN OFF SETLOCK ACTIVE INDICATOR IN PSA */
         SPACE 2
         NI    PSASUP3,ALLONES-PSAULCMS SETLOCK NOT ACTIVE     @ZA28255
         SPACE 2
*/* R DISPLATCHER IEAODS */
         SPACE 2
         BR    REG15                    GIVE CONTROL TO THE DISPATCHER
         SPACE 2
*/*LLUSPSRB: P SAVE REMAINDER OF CALLER REGISTERS */           @Z40FPXJ
         SPACE 2                                               @Z40FPXJ
LLUSPSRB DS    0H                                              @Z40FPXJ
         STM   REG0,REG5,PSALKR0        SAVE REST  OF CALLERS  @Z40FPXJ
         STM   REG12,REG15,PSALKR12     REGISTERS
         SPACE 2
*/* L Q CEL:GET A SUSPEND SRB/SA */
         SPACE 2
         L     CPIDRG0,SRBCPID          CPID FOR QUICK CELL
         GETCELL   CPID=(0),BRANCH=YES,SAVE=NO OBTAIN A SUSPEND SRB
         SPACE 2
*/* D (YES,LLUSPAVL,NO,) WAS CELL OBTAINED?  */
         SPACE 2
         LTR   REG15,REG15              WAS CELL OBTAINED
         BZ    LLUSPAVL                 IF SO GO SET UP
         SPACE 2
*/* P GET SALLOC LOCK FOR GETMAIN   */
         L     ALECLHT,MASKSALC         GET SALLOC HIERARCHY MASK
         L     SALCLOCK,ASALCLCK        GET SALLOC LOCK ADDR
         BAL   REG2,USPOBTL             GO GET LOCK
         SETFRR A,FRRAD=LOCKASVT,PARMAD=(1),WRKREGS=(2,3)      @ZA28255
         OI    RRRAFLG1-RRRA(R1),RRRALOCK  INDICATE SETLOCKFRR @ZA28255
         OI    LCCALKFG,LCCALKSA        SET SALLOC LOCK BIT
         SPACE 2
         SPACE 2
*/* D (YES,LLUSPRL2,NO,) IS LOCAL LOCK AVAILABLE?  */
         SPACE 2
         SLR   REG10,REG10              ZERO FOR CS            @Z40FPXJ
         L     LKADDR11,PSAAOLD         GET ASCB ADDR
         CS    ZERORG10,CPUADDR9,ASCBLOCK IS LOCAL LOCK AVAIL  @Z40FPXJ
         BZ    LLUSPRL2                 IF SO RELEASE SPINS
         MVC   LCCAGPGR(64),PSALKSA     SAVE REGS IN CASE LOCK MANAGER
*                                       IS CALLED AGAIN        @ZA28255
         SPACE 2
*/* L GETMAIN SSRB TO SAVE STATUS  */
         SPACE 2
         LA    REG0,SSRBLEN             GET SSRB LENGTH
         GETMAIN RU,LV=(0),SP=245,BRANCH=(YES,GLOBAL) GET SSRB
         SPACE 2
*/* P INDICATE SSRB WAS GETMAINED */
         SPACE 2
         LA    REG15,SSRBMAIN           INDICATE GETMAIN
         MVC   PSALKSA,LCCAGPGR         MOVE SAVED REGS BACK   @ZA28255
         SPACE 2
*/* P FREE SALLOC LOCK */
         SPACE 2
         SLR   ZERORG10,ZERORG10        CLEAR REG
         L     SALCLOCK,ASALCLCK        GET SALLOC LOCK ADDR
         NI    LCCALKFG,ALLONES-LCCALKSA CLEAR SALLOC LOCK BIT
         SETFRR D,WRKREGS=(4,7)         GETMAIN COMPLETED      @ZA28255
         ST    ZERORG10,ZERO(SALCLOCK)  FREE SALLOC LOCK
         OI    PSAMPSW,ENABLE          SET RETURN PSW ENABLE   @ZA28255
***********************************************************************
*        THIS SECTION BUILDS A SUSPENDED SRB, WHOSE ADDRESS WAS       *
*        RETURNED IN REGISTER 1 VIA QUICKCELL,OR GETMAIN              *
***********************************************************************
         SPACE 2
*/*LLUSPAVL: P BUILD SUSPENDED SRB */
         SPACE 2
LLUSPAVL DC    0H'0'
         SPACE 2
*/* P INITIALIZE FLAG BYTE  */
         SPACE 2
         STC   REG15,SSRBFLG1           INIT FLAG BYTE
         SPACE 2
*/* P BUILD & SAVE PSW IN SRB PSAMPSW-> SSRBCPSW */
*/* P REG 13 (LOCK RETURN EP -> SSRBCPSW+4 */
         SPACE 2
         L     REG4,PSAMPSW             LEFT HALF OF CALLERS ENTRY PSW
         ST    REG4,SSRBCPSW            SAVE IN SRB FOR REDISPATCH
         LA    REG13,ZERO(REG13)        INSURE HIGH ORDER BYTE IS ZERO
         ST    REG13,SSRBCPSW+4         STORE SETLCKS EP IN CALLERS PSW
         SPACE 2
*/* P SAVE GPR'S OF CALLER AT ENTRY IN SRBSA */
         SPACE 2
         MVC   SSRBGPRS(64),PSALKR0     SAVE ALL CALLERS REGISTERS
         SPACE 2
*/* P SET UP COMMON SAVE STATUS INTERFACE  */
         SPACE 2
         LR    REG7,REG8                PUT LCCA ADDR IN REG7
         L     REG8,PSAAOLD             GET ASCB ADDR
         LR    REG4,REG1                SAVE SSRB ADDR IN REG4
         LA    REG12,IEAVSPCR           GET COMMON SAVE ADDR
         SPACE 2
*/* L GO TO IEAVSPCR TO SAVE STATUS */
         SPACE 2
         BALR  REG15,REG12              GO TO SAVE RTN
         SPACE 2
*/* P RESTORE DESTROYED REGS  */
         SPACE 2
         LR    REG1,REG4                GET SSRB ADDR
         LR    REG8,REG7                RESTORE LCCA ADDR
         SPACE 2
*/*LLUSQFLN: P QUEUE SRB TO LOCAL LOCK SRB SUSPEND QUEUE */    @Z40FPXJ
*/* D (YES,LLUSQEND,NO,) DID CDS TO ENQUEUE SSRB GO */         @Z40FPXJ
         SPACE 2
         L     REG11,PSAAOLD            GET ASCB ADDR          @Z40FPXJ
         LR    REG7,REG1                SSRB ADDR IN REG7      @Z40FPXJ
         DROP  REG1                                            @Z40FPXJ
         USING SRBSECT,REG7                                    @Z40FPXJ
         L     REG4,ASCBLOCK            GET LK CONTS FOR CDS   @Z40FPXJ
         LTR   REG4,REG4                IS LOCK AVAILABLE      @Z40FPXJ
         BZ    LLUTRLK                  GO OBTAIN IT           @Z40FPXJ
LLUSQFLN DS    0H                                              @Z40FPXJ
         L     REG5,ASCBLSQH            GET Q HDR FIELD        @Z40FPXJ
LLUSQLNK ST    REG5,SRBFLNK             SET SSRB LINK FIELD    @Z40FPXJ
         LR    REG6,REG4                GET CPUID FOR CDS      @Z40FPXJ
         CDS   REG4,REG6,ASCBLOCK       ENQUE ELEMENT          @Z40FPXJ
         BZ    LLUSQEND                 ELEMENT WAS ENQUED     @Z40FPXJ
         SPACE 2                                               @Z40FPXJ
*/* D (NO,LLUSQFLN,YES,) IS LOCAL LOCK NOW AVAILABLE */        @Z40FPXJ
*/* D (YES,LLUFRMN,NO,) WAS SSRB GETMAINED */                  @Z40FPXJ
*/* L (,LLUSPRL3) FREECELL SSRB STORAGE */                     @Z40FPXJ
*/*LLUFRMN: P GET SALLOC FOR FREEMAIN */                       @Z40FPXJ
*/* L (,LLUSPRL2) FREEMAIN SSRB */                             @Z40FPXJ
         SPACE 2                                               @Z40FPXJ
         LTR   REG4,REG4                IS LOCK NOW FREE?      @Z40FPXJ
         BNZ   LLUSQLNK                 NO, RETRY ENQUE        @Z40FPXJ
LLUTRLK  DS    0H                                              @Z40FPXJ
         LH    REG6,PSACPULA            GET CPU LOGICAL ADDR   @Z40FPXJ
         CS    REG4,REG6,ASCBLOCK       YES, TRY TO OBTAIN LK  @Z40FPXJ
         BNZ   LLUSQFLN                 LOCK NOT AVAIL, REENQ  @Z40FPXJ
         DROP  REG7                                            @Z40FPXJ
         USING SRBSECT,REG1                                    @Z40FPXJ
         OI    LCCADSF2,LCCASRBM       INDICATE SRB MODE       @ZA28255
         OI    PSACLHS+3,LOCAL         INDICATE LOCK HELD      @ZA28255
         TM    SSRBFLG1,SSRBMAIN        WAS SSRB GETMAINED?    @Z40FPXJ
         BO    LLUFRMN                  YES, FREEMAIN          @ZM40340
         L     CPIDRG0,SRBCPID          GET CPID FOR FREECELL  @Z40FPXJ
         FREECELL CPID=(0),BRANCH=YES,SAVE=NO,CELL=(1)         @Z40FPXJ
         SLR   REG10,REG10              GET A ZERO R.C.        @Z40FPXJ
         B     LLUSPRL3                 RETURN TO MAINLINE     @Z40FPXJ
LLUFRMN  L     ALECLHT,MASKSALC         GET SALLOC MASK        @Z40FPXJ
         L     SALCLOCK,ASALCLCK        GET SALLOC ADDR        @Z40FPXJ
         BAL   REG2,USPOBTL             CBT SALLOC             @Z40FPXJ
         SETFRR A,FRRAD=LOCKASVT,PARMAD=(7),WRKREGS=(2,3)      @ZA28255
         OI    RRRAFLG1-RRRA(R7),RRRALOCK  INDICATE SETLOCKFRR @ZA28255
         OI    LCCALKFG,LCCALKSA        SET ON SALLOC FLAG     @Z40FPXJ
         LA    REG0,SSRBLEN             LENGTH FOR FREEMAIN    @Z40FPXJ
         FREEMAIN RU,LV=(0),BRANCH=(YES,GLOBAL),SP=245,A=(1) FREE SSRB
         OI    PSAMPSW,ENABLE          SET RETURN PSW ENABLE   @ZA28255
         MVC   PSALKSA,LCCAGPGR        MUST RESTORE SAVED REGS @ZA28255
         B     LLUSPRL2                 BACK TO MAINLINE       @Z40FPXJ
         SPACE 2
*/*LLUSQEND: P TURN OFF SETLOCK ACTIVE INDICATOR */
         SPACE 2
LLUSQEND DS    0H                                              @Z40FPXJ
         L     REG15,AIEA0DS                                   @Z40FPXJ
         NI    PSASUP3,ALLONES-PSAULCMS SETLOCK NOT ACTIVE     @ZA28255
         BR    REG15                    GIVE CTL TO DISP       @Z40FPXJ
         SPACE 2
*/* R IEA0DS DISPATCHER */                                     @Z40FPXJ
         SPACE 2
*/*LLUSPRL2: P RELEASE SALLOC LOCK  */
*/*LLUSPRL3: P RESTORE REGS */                                 @Z40FPXJ
         SPACE 2
LLUSPRL2 L     SALCLOCK,ASALCLCK        GET SALLOC LOCK ADDR   @Z40FPXJ
         NI    LCCALKFG,ALLONES-LCCALKSA CLEAR SALLOC LOCK BIT
         SETFRR D,WRKREGS=(4,5)         FREEMAIN COMPLETED     @ZA28255
         ST    ZERORG10,ZERO(SALCLOCK)  FREE SALLOC LOCK
         SPACE 2
LLUSPRL3 OI    LCCADSF2,LCCASRBM        INDICATE SRB MODE      @ZM40337
         LM    REG0,REG5,PSALKR0        RESTORE REGS 0-5       @Z40FPXJ
         LM    REG12,REG15,PSALKR12     RESTORE REGS 12-15     @Z40FPXJ
         SPACE 2
*/*LLUOBTD: P UPDATE CPU LOCKS HELD STRING */
         SPACE 2
LLUOBTD  DC    0H'0'
         OI    PSACLHS+3,LOCAL          UPDATE STRING
         SPACE 2
*/*LLURET: P SET RETURN CODE IN PROPER REG */
         SPACE 2
LLURET   DS    0H'0'
         LR    RCREG13,REG10            GET RETURN CODE FROM REG10
         SPACE 2
*/* P RESTORE REGS */
         SPACE 2
         LM    REG6,REG10,PSALKR6       RSTR RGS 6-10 OF CLRS  @Z40FPXJ
         SPACE 2
*/* P PLACE RTN ADDR INTO MODEL PSW IN PSA */
         SPACE 2
         LA    RETURN,ZERO(RETURN)      STORE CALLERS RETURN ADDRESS
         ST    RETURN,PSAMPSW+FOUR      IN MODEL PSW
         SPACE 2
*/* P TURN OFF ACTIVE INDICATOR */
         SPACE 2
         NI    PSASUP3,ALLONES-PSAULCMS SETLOCK NOT ACTIVE     @ZA28255
         SPACE 2
*/* P LPSW RETURN IN STATE CALLED */
*/* R RETURN */
         SPACE 2
         LPSW  PSAMPSW                  RETURN TO CALLER IN SAME STATE
*                                       AS CALLED.
         SPACE 2
*/*LLULKSH: P SET RC=4 FOR HELD */
*/* D (NO,STLKAB73,YES,LLURET) IS LOCAL LOCK HELD? */
         SPACE 2
LLULKSH  DC    0H'0'
         TM    PSACLHS+3,LOCAL          IS LOCAL ALREADY HELD?
         BNO   SUSPAB73                 NO: VIOLATION          @ZA28255
         LA    REG13,FOUR               LCL LK IS ALRDY HLD    @Z40FPXJ
         BR    RETURN                   RETURN TO CALLER
*/*USPOBTL: E LOCK OBTAIN SUBROUTINE */
*/*USPSPL: P THIS PORTION GETS THE LOCK  */
*/* D (YES,USPFINL,NO,) WAS LOCK OBTAINED */
*/* S WINDSPIN:GO TO OPEN EMS/MFA WINDOW */
*/* P (,USPSPL) TRY AGAIN */
*/*USPFINL: R RETURN */
         SPACE 2
USPOBTL  DS    0H                                              @YM02494
         LH    CPUADDR9,PSACPULA        GET CPUID              @YM02494
USPSPL   SLR   ZERORG10,ZERORG10        CLEAR CS REG           @YM02494
         CS    ZERORG10,CPUADDR9,ZERO(REG11) GET LOCK          @YM02494
         BZR   REG2                     IF GOTTEN RETURN       @YM02494
         LA    SPINRTNR,WINDSPIN        SPIN ON LOCK           @YM02494
         BALR  MNLRETRN,SPINRTNR        GO TO WINDOW RTN       @YM02494
         B     USPSPL                   TRY AGAIN              @YM02494
         TITLE 'IEAVELK - SETLOCK''S UNCONDITIONAL CMS OBTAIN ROUTINE'
         ENTRY CMSUOBT
         SPACE 2
*/*CMSUOBT: E CMSUOBT */
         SPACE 2
CMSUOBT  DS    0H
         USING *,BASER13
         SPACE 2
*/* P DISABLE EXT & I/O SAVE SYS MASK IN MODEL PSW */
         SPACE 2
         STNSM PSAMPSW,DISABLE          DISABLE CPU FOR EXT & I/O INT
         SPACE  2
*/* P TURN ON ACTIVE INDICATOR IN PSA */
         SPACE 2
         OI    PSASUP3,PSAULCMS         SETLOCK ACTIVE IN A POSSIBLE
*                                       SUSPEND PATH           @ZA28255
         SPACE 2
*/* P SAVE REGS */
         SPACE 2
         STM   REG4,REG10,PSALKR4       SAVE CALLERS REGS
         SPACE 2
*/* D (NO,CMSULH,YES,) IS LOCAL LOCK ONLY LOCK HELD? */
         SPACE 2
         L     ALECLHT,PSACLHS          GET STRING FOR CHECKING
         BCT   ALECLHT,CMSULH           CONTENT IS ONE IF ONLY LL HELD
         SPACE 2
*/* P GET ASCB ADDR FROM PSAAOLD */
         SPACE 2
         L     ASCBADR9,PSAAOLD         OBTAIN CURRENT ASCB ADDR
         DROP  REG11
         USING ASCB,REG9                                       @Z40FPXJ
         SPACE 2
*/* P FORM 'CS' LOCK ARG */
         SPACE 2
         SLR   ZERORG10,ZERORG10        ZERO VALUE     FOR CS  @Z40FPXJ
         SPACE 2
*/* P OBTAIN CMS LOCK */
*/* D (NO,CMSUUNS,YES,) SUCCESS? */
         SPACE 2
         CS    ZERORG10,ASCBADR9,ZERO(LKADDR11)  IS CMS LOCK FREE
         BNZ   CMSUUNS                  CMS LOCK OWNED BY ANOTHER
         SPACE 2
*/*CMSUSOBT: P UPDATE CPU LOCKS HELD STRING */
         SPACE 2
CMSUSOBT DC    0H'0'
         OI    PSACLHS+3,CMS+LOCAL      UPDATE STRING          @Z40FPXJ
         SPACE 2
*/*CMSURET: P PUT RETURN CODE IN PROPER REG */
         SPACE 2
CMSURET  DC    0H'0'
         LR    RCREG13,REG10            GET RETURN CODE FROM REG10
         SPACE 2
*/* P RESTORE REGS */
         SPACE 2
         LM    REG4,REG10,PSALKR4       RESTORE CALLER'S REGISTERS
         SPACE 2
*/* P PLACE RTN ADDR INTO MODEL PSW IN PSA */
         SPACE 2
         LA    RETURN,ZERO(RETURN)      SAVE CALLERS RETURN ADDRESS
         ST    RETURN,PSAMPSW+4         IN MODEL PSW
         SPACE 2
*/* P TURN OFF ACTIVE INDICATOR */
         SPACE 2
         NI    PSASUP3,ALLONES-PSAULCMS SETLOCK NOT ACTIVE     @ZA28255
         SPACE 2
*/* P LPSW RETURN IN SAME STATE CALLED */
*/* R RETURN */
         SPACE 2
         LPSW  PSAMPSW                  RETURN TO CALLER IN SAME STATE
*                                       AS CALLED
         SPACE 2
*/*CMSULH: P SET RC=4 "ALREADY OWNED" */
         SPACE 2
CMSULH   DC    0H'0'
         LA    REG10,FOUR               THE CMS LOCK IS ALREADY HELD
         SPACE 2
*/* D (YES,CMSURET,NO,STLKAB73) IS CMS LOCK ALREADY HELD? */
         SPACE 2
         TM    PSACLHS+3,CMS            IS CMS LOCK ALREADY HELD?
         BO    CMSURET                  YES: GO TO COMMON RETURN CODE
         B     SUSPAB73                 NO: VIOLATION          @ZA28255
         SPACE 2
*/*CMSUUNS: P GET LOGICAL CPU ADDR */
         SPACE 2
CMSUUNS  DC    0H'0'
         L     LCCAPTR,PSALCCAV         OBTAIN LCCA ADDR IN REG 8
         SPACE 2
*/* D (YES,CMSUUSRB,NO,) SRB MODE? */
         SPACE 2
         TM    LCCADSF2,LCCASRBM        IS THIS A SRB CALLER?
         BO    CMSUUSRB                 SRB CALLER MUST BE SUSPENDED
         SPACE 2
*/* P SAVE REGS 0-3 & 11-15 IN IHSA */                         @Z40FPXJ
         SPACE 2
         L     REG5,ASCBASXB            OBTAIN ASXB ADDR
         USING ASXB,REG5
         L     REG4,ASXBIHSA            OBTAIN INT HANDLER SAVE AREA
         USING IHSA,REG4
         STM   REG0,REG3,IHSAGPRS       SAVE CALLERS REGS 0 THRO 3
         SPACE 2
*/* P MOVE REGS 4-10 FROM PSA TO IHSA */                       @Z40FPXJ
         SPACE 2
         MVC   IHSAGPRS+16(28),PSALKR4  SAVE CALLERS REGS 4 THRO 10
         STM   REG11,REG15,IHSAGPRS+44  SAVE CALLERS REGS 11 THR 15
         SPACE 2
*/* P BUILD (STCM) RESUME PSW R13-> PSAMPSW+3 */
         SPACE 2
         MVC   IHSACPSW(4),PSAMPSW      SAVE CALLERS LEFT HALF PSW
         LA    BASER13,ZERO(BASER13)    INSURE HIGH BYTE ZERO
         SPACE 2
*/* P SAVE RESUME PSW IN IHSA (OBTAIN RTN'S ENTRY POINT) */
         SPACE 2
         ST    BASER13,IHSACPSW+4       SAVE CALLERS EP TO CMS OBTAIN
         SPACE 2
*/* P SET UP INTERFACE TO COMMON SAVE ROUTINE */
         SPACE 2
         SLR   REG1,REG1                CLEAR REG1 -NOTSRB
         LR    REG7,REG8                GET LCCA ADDR IN 7
         L     REG8,PSAAOLD             GET ASCB ADDR IN 8
         LA    REG12,IEAVSPCR           GET ENTRY ADDR
         SPACE 2
*/* L GO TO IEAVSPCR TO SAVE STATUS */
         SPACE 2
         BALR  REG15,REG12              GO TO SAVE STATUS
         SPACE 2
*/* P RESTORE NEEDED VALUES */
         SPACE 2
         L     REG9,PSAAOLD             GET ASCB ADDR IN 9
         LR    REG8,REG7                RESTORE LCCA ADDR
         SPACE 2
*/*CMSUQACB: P QUEUE ASCB TO ASCBCMS SUSPEND Q */              @Z40FPXJ
         SPACE 2                                               @Z40FPXJ
         LR    REG10,REG11              GET CMS LK ADDR        @Z40FPXJ
         LR    REG7,REG9                GET ASCB ADDR FOR CS   @Z40FPXJ
CMSUQACB DS   0H                                               @Z40FPXJ
         L     REG5,4(REG11)            GET Q HDR              @Z40FPXJ
CMSUACBS DS    0H                                              @Z40FPXJ
         ST    REG5,ASCBCMSF            STR HDR IN ASCB FWDPTR @Z40FPXJ
         L     REG4,ZERO(REG10)         GET LOCKWORD           @Z40FPXJ
         LTR   REG4,REG4                IS LOCK AVAILABLE      @Z40FPXJ
         BZ    CMSUTRLK                 GO GET IT              @Z40FPXJ
         LR    REG6,REG4                PUT LKWD IN R6 FOR CDS @Z40FPXJ
         CDS   REG4,REG6,ZERO(REG10)    CDS ELE ONTO QUE       @Z40FPXJ
*/* D (YES,CMSUACBQ,NO,) DID CDS TO QUE ASCB GO */             @Z40FPXJ
*/* D (NO,CMSUQACB,YES,) IS CMS LOCK AVAIL */                  @Z40FPXJ
         BZ    CMSUACBQ                 ELE ON QUE             @Z40FPXJ
         LTR   REG4,REG4                IS LOCK AVAIL          @Z40FPXJ
         BNZ   CMSUACBS                 NO TRY TO REQUE        @Z40FPXJ
CMSUTRLK DS    0H                                              @Z40FPXJ
         CS    REG4,REG7,ZERO(REG10)    YES TRY TO GET IT      @Z40FPXJ
         BNZ   CMSUQACB                 LK NOT AVAIL REQUE ELE @Z40FPXJ
         SLR   ZERORG10,ZERORG10        GET A ZERO RETURN CODE @Z40FPXJ
         L     REG5,ASCBASXB            GET ASXB ADDRESS       @Z40FPXJ
         L     REG4,ASXBIHSA            GET IHSA ADDRESS       @Z40FPXJ
         SPACE 2                                               @Z40FPXJ
*/* D (YES,,NO,CMSUQACB) DID CS FOR LOCK GO ? */               @Z40FPXJ
*/* P RESET TOLD AND TNEW */                                   @Z40FPXJ
         SPACE 2                                               @Z40FPXJ
         MVC   PSATNEW(EIGHT),IHSANTCB-IHSA(REG4) ST TOLD/TNEW @Z40FPXJ
         SPACE 2                                               @Z40FPXJ
*/* D (YES,,NO,CMSUNTQE) IS THERE A TQE ? */                   @Z40FPXJ
         SPACE 2                                               @Z40FPXJ
         L     REG5,PSATOLD             TCB ADDRESS            @Z40FPXJ
         L     REG5,TCBTME-TCB(REG5)    TQE ADDRESS            @Z40FPXJ
         LTR   REG5,REG5                IS THERE A TQE         @Z40FPXJ
         BNH   CMSUNTQE                 NO, SKIP TIMER SETTING @Z40FPXJ
         SPACE 2                                               @Z40FPXJ
*/* D (YES,,NO,CMSUNTQE) IS CPU TIMER OK ? */                  @Z40FPXJ
         SPACE 2                                               @Z40FPXJ
         L     REG5,PSAPCCAV            PCCA ADDRESS           @Z40FPXJ
         TM    PCCAINTE-PCCA(REG5),PCCANUIN CPU TIMER WORKING  @Z40FPXJ
         BO    CMSUNTQE                 NOT WORKING SKIP SET   @Z40FPXJ
         SPACE 2                                               @Z40FPXJ
*/* P RESET CPU TIMER AND DISPATCHER TOD */                    @Z40FPXJ
         SPACE 2                                               @Z40FPXJ
         SPT   IHSACPUT-IHSA(REG4)      RESET CPU TIMER        @Z40FPXJ
         L     REG5,PSALCCAV            LCCA ADDRESS           @Z40FPXJ
         STCK  LCCADTOD-LCCA(REG5)      RESET DISPATCHER TOD   @Z40FPXJ
CMSUNTQE DS    0H                                              @Z40FPXJ
         SPACE 2                                               @Z40FPXJ
*/*CMSUNTQE: P RESET LOCAL LOCK TO CPU ADDRESS */              @Z40FPXJ
         SPACE 2                                               @Z40FPXJ
         LH    REG5,PSACPULA            GET CPU ADDRESS        @Z40FPXJ
         ST    REG5,ASCBLOCK-ASCB(REG7) UPDATE LOCAL LOCK      @Z40FPXJ
         SPACE 2                                               @Z40FPXJ
*/* P (,CMSUSOBT) RESET CPUS COUNT */                          @Z40FPXJ
         SPACE 2                                               @Z40FPXJ
         L     REG3,ASCBCPUS-ASCB(REG7) GET THE CPUS COUNT     @ZM40337
CMSUPCPU DS    0H                                              @Z40FPXJ
         LA    REG5,ONE(REG3)           INCREMENT COUNT FOR CS @ZM40337
         CS    REG3,REG5,ASCBCPUS-ASCB(REG7) UPDATE CPUS COUNT @ZM40337
         BNZ   CMSUPCPU                 COUNT HAS CHANGED      @Z40FPXJ
         LM    REG0,REG3,IHSAGPRS       RELOAD R0-R3           @Z40FPXJ
         LM    REG11,REG15,IHSAGPRS+44  LOAD R11-R15           @Z40FPXJ
         B     CMSUSOBT                 TO EXIT WITH LOCK      @Z40FPXJ
CMSUACBQ DS    0H                                              @Z40FPXJ
         SPACE 2
*/* D (YES,CMSUACBQ,NO,) DID CDS TO QUE ASCB GO */             @Z40FPXJ
*/*CMSUACBQ: P GET DISPATCHER ENTRY POINT */                   @Z40FPXJ
         SPACE 2
         L     REG15,AIEA0DS            OBTAIN DISP ENTRY,     @Z40FPXJ
*                                       IEAPDS2 FOR SUSPENDED LOCKED
*                                       ADDRESS SPACES
         SPACE 2
         SPACE 2
*/* P TURN OFF SETLOCK ACTIVE INDICATOR */
         SPACE 2
         NI    PSASUP3,ALLONES-PSAULCMS SETLOCK NOT ACTIVE     @ZA28255
         SPACE 2
*/* R IEA0DS DISPATCHER */                                     @Z40FPZJ
*/*CMSUAGLK: D (NO,CMSUQACB,YES,CMSUSOBT) IS CMS LOCK AVAIL */ @Z40FPXJ
         SPACE 2
         BR    REG15                    TO DISP, NO DISP LOCK  @Z40FPXJ
         SPACE 2
*/*CMSSPRL2: P RELEASE SALLOC LOCK  */
         SPACE 2
CMSSPRL2 L     REG5,ASALCLCK            GET SALLOC LOCK ADDR   @Z40FPXJ
         NI    LCCALKFG,ALLONES-LCCALKSA CLEAR SALLOC LOCK BIT
         SETFRR D,WRKREGS=(2,3)         FREEMAIN COMPLETED     @ZA28255
         ST    ZERORG10,ZERO(REG5)      FREE SALLOC LOCK
CMSSPRL3 LM    REG0,REG3,PSALKR0        RESTORE REGS 0-3       @Z40FPXJ
         LM    REG11,REG15,PSALKR11     RESTORE REGS 11-15     @Z40FPXJ
         SPACE 2
*/*CMSSPRL3: P RESTORE REGS */                                 @Z40FPXJ
*/*CMSULSO: P (,CMSUSOBT) RETURN TO MAINLINE EXIT */           @Z40FPXJ
         SPACE 2
         OI    LCCADSF2,LCCASRBM        INDICATE SRB MODE      @ZM40337
         B     CMSUSOBT                 GO PROCESS FOR GOTTEN LOCK
         SPACE 2
*/*CMSUUSRB: P SAVE REGS 0-3, 11-15 IN PSA */
         SPACE 2
CMSUUSRB DC    0H'0'
         STM   REG0,REG3,PSALKR0        SAVE CALLER'S OTHER REGS
         STM   REG11,REG15,PSALKR11     SAVE CALLERS'S OTHER REGS
         SPACE 2
*/* S QCELL:GET A SUSPENDED SRB */
         SPACE 2
         L     CPIDRG0,SRBCPID          CPID FOR QUICK CELL
         GETCELL   CPID=(0),BRANCH=YES,SAVE=NO OBTAIN A SUSPEND SRB
         SPACE 2
*/* D (YES,CMSUSAVL,NO,) WAS CELL OBTAINED?  */
         SPACE 2
         LTR   REG15,REG15              WAS CELL OBTAINED
         BZ    CMSUSAVL                 IF SO GO SET UP
         SPACE 2
*/* P GET SALLOC LOCK FOR GETMAIN   */
         SPACE 2
         LR    REG4,REG11               SAVE CMS LK ADDR       @Z40FPXJ
         L     ALECLHT,MASKSALC         GET SALLOC HIERARCHY MASK
         L     SALCLOCK,ASALCLCK        GET SALLOC LOCK ADDR
         BAL   REG2,USPOBT              GO GET LOCK
         SETFRR A,FRRAD=LOCKASVT,PARMAD=(1),WRKREGS=(2,3)      @ZA28255
         OI    RRRAFLG1-RRRA(R1),RRRALOCK  INDICATE SETLOCKFRR @ZA28255
         OI    LCCALKFG,LCCALKSA        SET SALLOC LOCK BIT
         SPACE 2
*/* D (YES,CMSSPRL2,NO,) IS CMS LOCK AVAILABLE?  */
         SPACE 2
         L     CPUADDR9,PSAAOLD         GET ASCB ADDR FOR SWAP
         LR    LKADDR11,REG4            GET CMS LOCK ADDR BACK @Z40FPXJ
         CS    ZERORG10,CPUADDR9,ZERO(LKADDR11) IS LOCK AVAIL
         BZ    CMSSPRL2                 IF SO RELEASE SPINS
         MVC   LCCAGPGR(64),PSALKSA     SAVE REGS IN CASE LOCK MANAGER
*                                       IS CALLED AGAIN        @ZA28255
         SPACE 2
*/* L GETMAIN SSRB SAVE ARE  */
         SPACE 2
         LA    REG0,SSRBLEN             GET SSRB LENGTH
         GETMAIN RU,LV=(0),SP=245,BRANCH=(YES,GLOBAL) GET SSRB
         SPACE 2
*/* P INDICATE SSRB WAS GETMAINED */
         SPACE 2
         LA    REG15,SSRBMAIN           INDICATE GETMAIN
         MVC   PSALKSA,LCCAGPGR         MOVE SAVED REGS BACK   @ZA28255
         SPACE 2
*/* P FREE SALLOC LOCK */
         SPACE 2
         L     REG4,ASALCLCK            GET SALLOC LOCK BIT    @Z40FPXJ
         NI    LCCALKFG,ALLONES-LCCALKSA CLEAR SALLOC LOCK BIT
         SETFRR D,WRKREGS=(5,7)         GETMAIN COMPLETED      @ZA28255
         SLR   ZERORG10,ZERORG10        CLEAR R10 TO FREE LK   @Z40FPXJ
         ST    ZERORG10,ZERO(REG4)      FREE SALLOC LOCK       @Z40FPXJ
         OI    PSAMPSW,ENABLE          SET RETURN PSW ENABLE   @ZA28255
***********************************************************************
*        THIS SECTION BUILDS A SUSPENDED SRB, WHOSE ADDRESS WAS       *
*        RETURNED IN REGISTER 1 VIA QUICKCELL,OR GETMAIN              *
***********************************************************************
         SPACE 2
*/*CMSUSAVL: P BUILD A SUSPENDED SRB*/
CMSUSAVL DC    0H'0'
         USING SRBSECT,REG1
         SPACE 2
*/* P INITIALIZE FLAG BYTE  */
         SPACE 2
         STC   REG15,SSRBFLG1           INIT FLAG BYTE
         SPACE 2
*/* P BUILD & SAVE PSW IN SRB PSAMPSW-> SSRBCPSW */
*/* P REG 13 (LOCK RETURN EP -> SSRBCPSW+4 */
         SPACE 2
         L     REG4,PSAMPSW             LEFT HALF OF CALLERS ENTRY PSW
         ST    REG4,SSRBCPSW            SAVE IN SRB FOR REDISPATCH
         LA    REG13,ZERO(REG13)        INSURE HIGH ORDER BYTE IS ZERO
         ST    REG13,SSRBCPSW+4         STORE SETLCKS EP IN CALLERS PSW
         SPACE 2
*/* P SAVE GPR'S OF CALLER AT ENTRY IN SRBSA */
         SPACE 2
         MVC   SSRBGPRS(64),PSALKR0     SAVE ALL CALLERS REGISTERS
         SPACE 2
*/* P SET UP COMMON SAVE STATUS INTERFACE  */
         SPACE 2
         LR    REG7,REG8                PUT LCCA ADDR IN REG7
         L     REG8,PSAAOLD             GET ASCB ADDR
         LR    REG4,REG1                SAVE SSRB ADDR IN REG4
         LA    REG12,IEAVSPCR           GET COMMON SAVE ADDR
         SPACE 2
*/* L GO TO IEAVSPCR TO SAVE STATUS */
         SPACE 2
         BALR  REG15,REG12              GO TO SAVE RTN
         SPACE 2
*/* P RESTORE DESTROYED REGS  */
         SPACE 2
         LR    REG8,REG7                RESTORE LCCA ADDR
         SPACE 2
*/*CMSUQSRB: P QUEUE SRB TO CMS SRB SUSPEND QUEUE */           @Z40FPXJ
*/* D (NO,,YES,CMSUSRBQ) DID CDS TO ENQUE ELE GO */            @Z40FPXJ
         SPACE 2
         LR    REG10,REG11              GET CMS LK ADDR        @Z40FPXJ
         USING SRBSECT,REG7                                    @Z40FPXJ
         LR    REG7,REG4                GET SSRB ADDR          @Z40FPXJ
CMSUQSRB DS    0H                                              @Z40FPXJ
         L     REG5,FOUR(REG11)         GET SRB Q HDR          @Z40FPXJ
CMSUSRBS DS    0H                                              @Z40FPXJ
         ST    REG5,SRBFLNK             STR HDR IN SRB LN FLD  @Z40FPXJ
         L     REG4,ZERO(REG10)         GET CMSLK              @Z40FPXJ
         LTR   R4,R4                    Q. LOCK AVAILABLE      @ZA15008
         BZ    CMSULOKA                 A. YES - GO TRY TO GET @ZA15008
         LR    REG6,REG4                PUT LK IN REG6 FOR CDS @Z40FPXJ
         CDS   REG4,REG6,ZERO(REG10)    CDS ELE ON QUE         @Z40FPXJ
         BZ    CMSUSRBQ                 ELE IS ENQUED          @Z40FPXJ
         LTR   REG4,REG4                NOT ENQD IS LOCK FREE  @Z40FPXJ
         BNZ   CMSUSRBS                 NO REENQUE             @Z40FPXJ
CMSULOKA LH    REG2,PSACPULA            GET CPU ID             @ZA19338
         L     REG6,PSAAOLD             GET ASCB ADDR          @ZA19338
         CS    REG4,REG6,ZERO(REG10)    TRY TO GET CMS LOCK    @Z40FPXJ
         BNZ   CMSUQSRB                 FAILED, TOP OF QUE RTN @Z40FPXJ
         ST    REG2,ASCBLOCK-ASCB(REG6) STORE CPUID IN LOCK    @ZA19338
         OI    LCCADSF2,LCCASRBM       INDICATE SRB MODE       @ZA28255
         OI    PSACLHS+3,CMS+LOCAL     INDICATE LOCKS HELD     @ZA28255
         TM    SSRBFLG1,SSRBMAIN        SUCCESS, WAS ELE GTMD  @Z40FPXJ
         BO    CMSUFRMN                 YES, GOTO FREEMAIN     @Z40FPXJ
         L     CPIDRG0,SRBCPID          CPID FOR FREE CELL     @Z40FPXJ
         FREECELL CPID=(0),BRANCH=YES,SAVE=NO,CELL=(7)         @Z40FPXJ
         SLR   ZERORG10,ZERORG10        GET 0 RTN CODE         @Z40FPXJ
         B     CMSSPRL3                 TO EXIT                @Z40FPXJ
CMSUFRMN DS    0H                                              @Z40FPXJ
         L     ALECLHT,MASKSALC         GET SALLOC MASK        @Z40FPXJ
         L     SALCLOCK,ASALCLCK        GET SALLOC ADDR        @Z40FPXJ
         LR    R4,R7                    SAVE SSRB ADDR ACROSS  @ZA18192
*                                       SUBRTN CALL            @ZA18192
         BAL   REG2,USPOBT              GO GET LK              @Z40FPXJ
         SETFRR A,FRRAD=LOCKASVT,PARMAD=(1),WRKREGS=(2,3)      @ZA28255
         OI    RRRAFLG1-RRRA(R1),RRRALOCK  INDICATE SETLOCKFRR @ZA28255
         OI    LCCALKFG,LCCALKSA        UPDATE LK HELD STRING  @Z40FPXJ
         LA    REG0,SSRBLEN             GET LNGTH FOR FREEMAIN @Z40FPXJ
         FREEMAIN RU,LV=(0),SP=245,BRANCH=(YES,GLOBAL),A=(4)   @ZA18192
         OI    PSAMPSW,ENABLE          SET RETURN PSW ENABLE   @ZA28255
         MVC   PSALKSA,LCCAGPGR        MUST RESTORE SAVED REGS @ZA28255
         SLR   REG10,REG10              GET ZERO R.C.          @Z40FPXJ
         B     CMSSPRL2                 TO EXIT                @Z40FPXJ
         DROP REG7                                             @Z40FPXJ
CMSUSRBQ DS    0H                                              @Z40FPXJ
         L     REG15,AIEA0DS            ADDR OF DISP ENTRY     @Z40FPXJ
         NI    PSASUP3,ALLONES-PSAULCMS SETLOCK NOT ACTIVE     @ZA28255
         SPACE 2
*/* D (YES,,NO,CMSUQSRB) IS CMS LOCK AVAIL */                  @Z40FPXJ
*/* D (NO,,YES,CMSUFRMN) WAS SSRB GETMAINED */                 @Z40FPXJ
*/* L (,CMSSPRL3) FREECELL SSRB STORAGE */                     @Z40FPXJ
*/*CMSUFRMN: P GET SALLOC LOCK FOR FREEMAIN */                 @Z40FPXJ
*/* L (,CMSSPRL2) FREEMAIN SSRB STORAGE */                     @Z40FPXJ
*/*CMSUSRBQ: P TURN OFF SETLOCK ACTIVE INDICATOR */            @Z40FPXJ
*/* R IEA0DS DISPATCHER */                                     @Z40FPXJ
         SPACE 2
         BR    REG15                    ENTER DISPATCHER AT ITS ENTRY
*                                       POINT FOR SUSPENDING SRBS.
         SPACE 2
*/*USPOBT: E LOCK OBTAIN SUBROUTINE */
*/*USPSP: P THIS PORTION GETS THE LOCK  */
*/* D (YES,USPFIN,NO,) WAS LOCK OBTAINED */
*/* S WINDSPIN:GO TO OPEN EMS/MFA WINDOW */
*/* P (,USPSP) TRY AGAIN */
*/*USPFIN: R RETURN */
         SPACE 2
USPOBT   DS    0H
         LH    CPUADDR9,PSACPULA        GET CPUID
USPSP    SLR   ZERORG10,ZERORG10        CLEAR CS REG
         CS    ZERORG10,CPUADDR9,ZERO(REG11) GET LOCK
         BZR   REG2                     IF GOTTEN RETURN
         LA    SPINRTNR,WINDSPIN        SPIN ON LOCK
         BALR  MNLRETRN,SPINRTNR        GO TO WINDOW RTN
         B     USPSP                    TRY AGAIN
         TITLE 'IEAVELK''S CMS CONDITIONAL OBTAIN ROUTINE'
         ENTRY CMSCOBT
         SPACE  2
*/*CMSCOBT: E CMSCOBT */
         SPACE  2
CMSCOBT  DS    0H
         USING *,BASER13
         SPACE  2
*/* P DISABLE EXT & I/O SAVE SYS MASK IN MODEL PSW */
         SPACE  2
         STNSM PSAMPSW,DISABLE          DISABLE CPU FOR EXT & I/O INT
         SPACE  2
*/* P TURN ON SETLOCK ACTIVE INDICATOR IN PSA */
         SPACE  2
         OI    PSASUP1,PSALOCK          SETLOCK ACTIVE INDICATOR
         SPACE  2
*/* P SAVE REGS */
         SPACE 2
         ST    REG9,PSALKR9             SAVE CALLERS REG9      @Z40FPXJ
         ST    REG10,PSALKR10          SAVE CALLERS RG 10      @Z40FPXJ
         SPACE  2
*/* D (NONE,STLKAB73,BOTH,CMSCHLD,LL,) LOCAL &/OR CMS HELD? */
         SPACE  2
         TM    PSACLHS+3,CMS+LOCAL      CHECK LOCAL & CMS IND
         BO    CMSCHLD                  LOCK ALREADY HELD
         BZ    STLKAB73                 HIERARCHY VIOLATE: LL NOT HELD
         SPACE  2
*/*CMSCNTHD: P GET ASCB ADDR FROM PSA */
         SPACE 2
CMSCNTHD DC    0H'0'
         L     ASCBADR9,PSAAOLD         OBTAIN CURRENT ASCB ADDR
         SPACE 2
*/* P FORM 'CS' LOCK ARG */
         SPACE 2
         SLR   ZERORG10,ZERORG10        FULLWORD OF ZEROS      @Z40FPXJ
         SPACE 2
*/* P OBTAIN CMS LOCK */
*/* D (NO,CMSCOBTU,YES,) SUCCESS? */
         SPACE 2
         CS    ZERORG10,ASCBADR9,ZERO(LKADDR11)   WAS LOCK AVAILABLE
         BNZ   CMSCOBTU                 LOCK NOT AVAILABLE
         SPACE 2
*/* P UPDATE CPU LOCKS HELD STRING */
         SPACE 2
         OI    PSACLHS+3,CMS            UPDATE STRING
         SPACE 2
*/*CMSCRET: P GET RETURN CODE IN PROPER REG */
         SPACE 2
CMSCRET  DC    0H'0'
         LR    RCREG13,REG10            GET RETURN CODE FROM REG10
         SPACE 2
*/* P RESTORE REGS */
         SPACE 2
         L      REG9,PSALKR9             RESTORE CALLERS REG9  @Z40FPXJ
         L     REG10,PSALKR10           RESTORE CALLERS REG10  @Z40FPXJ
         SPACE 2
*/*CMSCRET1: P PLACE RTN ADDR INTO MODEL PSW IN PSA */
         SPACE 2
CMSCRET1 DC    0H'0'
         LA    RETURN,ZERO(RETURN)      STORE CALLER'S RETURN ADDR
         ST    RETURN,PSAMPSW+4         IN MODEL PSW
         SPACE 2
*/* P TURN OFF ACTIVE INDICATOR */
         SPACE 2
         NI    PSASUP1,LOCKNACT         TURN OFF SETLOCK ACTIVE BIT
         SPACE 2
*/* P LPSW RETURN IN STATE CALLED */
*/* R RETURN */
         SPACE 2
         LPSW  PSAMPSW                  RETURN CONTROL IN SAME STATE
         SPACE 2
*/*CMSCOBTU: P (,CMSCRET) SET RC=8 */
         SPACE  2
CMSCOBTU DC    0H'0'
         LA    REG10,EIGHT              LOCK WAS HELD BY ANOTHER CPU
         B     CMSCRET                  GO TO COMMON RETURN CODE
         SPACE  2
*/*CMSCHLD: P (,CMSCRET) SET RC=4 "ALREADY OWNED" */
         SPACE 2
CMSCHLD DC    0H'0'
         LA    REG10,FOUR               LOCK ALREADY HELD
         B     CMSCRET                  GO TO COMMON RETURN CODE
         TITLE 'IEAVELK''S CMS RELEASE ROUTINE'
         ENTRY CMSREL
         SPACE 2
*/* E CMSREL */
         SPACE 2
CMSREL   DS    0H
         USING *,BASER13
         SPACE 2
*/* P DISABLE EXT & I/O SAVE SYS MASK IN MODEL PSW */
         SPACE 2
         STNSM PSAMPSW,DISABLE          DISABLE CPU FOR EXT & I/O INT
         SPACE 2
*/* P TURN ON ACTIVE INDICATOR IN PSA */
*/* P NOTE: NO TEST FOR LOGICAL LOCK */
         SPACE 2
         OI    PSASUP1,PSALOCK          SETLOCK ACTIVE INDICATOR
         SPACE 2
*/*CMSRLLO: P SAVE REGS */
         SPACE 2
CMSRLLO  DC    0H'0'
         STM   REG4,REG10,PSALKR4       SAVE CALLERS R4-10     @ZM40338
         SPACE 2
*/* P FORM 'CS' LOCK ARG */
         SPACE 2
         SLR   ZERORG10,ZERORG10        ZERO RETURN CODE
         SPACE 2
*/* D (NO,CMSRNTHD,YES,) IS LOCK HELD? */
*/* P RELEASE CMS LOCK */
         SPACE 2
         TM    PSACLHS+3,CMS            IS CMS LOCK HELD
         BNO   CMSRNTHD                 NO: SET PROPER RETURN CODE
         SPACE 2
*/*CMSRQCHK: D (YES,CMSREXIT,NO,) IS QUEUE EMPTY? */           @Z40FPXJ
*/* S CMSRDEQS: DEQ ELEMENTS ON SUSPEND QUEUE */               @Z40FPXJ
         SPACE 2
CMSRQCHK DS    0H                                              @Z40FPXJ
         L     R6,ZERO(REG11)           GET LK WORD            @Z40FPXJ
         SLR   R7,R7                    ZERO FOR CS            @Z40FPXJ
         SLR   R8,R8                    ZERO FOR CS            @Z40FPXJ
         SLR   R9,R9                    ZERO FOR CS            @Z40FPXJ
         CDS   REG6,REG8,ZERO(REG11)    IS QUEUE EMPTY         @Z40FPXJ
         BNZ   CMSRDEQS                 GO DEQUE CHAIN         @Z40FPXJ
         NI    PSACLHS+3,ALLONES-CMS    UPDATE STRING          @Z40FPXJ
         SPACE 2
*/*CMSREXIT: P SET RETURN CODE IN PROPER REG */
         SPACE 2
CMSREXIT DC    0H'0'
         LR    RCREG13,REG10            INDICATE RELEASE SUCCESSFUL
         SPACE 2
*/*CMSRRET: P RESTORE REGS */
         SPACE 2
CMSRRET  DC    0H'0'
         LM    REG4,REG10,PSALKR4       RESTORE CALLER'S R4-10 @ZM40338
         SPACE 2
*/* P BUILD RETURN PSW */
         SPACE 2
         LA    RETURN,ZERO(RETURN)      STORE CALLER'S RETURN ADDR
         ST    RETURN,PSAMPSW+4         IN MODEL PSW
         SPACE 2
*/* P TURN OFF ACTIVE INDICATOR */
         SPACE 2
         NI    PSASUP1,LOCKNACT         TURN OFF LOCK ACTIVE BIT
         SPACE 2
*/* P LPSW RETURN IN SAME STATE AS CALLED */
*/* R RETURN */
         SPACE 2
         LPSW  PSAMPSW                  RETURN CONTROL IN SAME STATE
*                                       AS WHEN CALLED.
         SPACE 2
*/*CMSRNTHD: D (NO,CMSROCH,YES,) WAS LOCK FREE */
         SPACE 2
CMSRNTHD DC    0H'0'
         C     ZERORG10,ZERO(LKADDR11)  IS LOCK AVALIABLE?
         BNE   CMSROCH                  NO: HELD BY OTHER CPU
         SPACE 2
*/* P (,CMSREXIT) SET RC=4 "LOCK NOT HELD" */
         SPACE 2
         LA    REG10,FOUR               RC 4 - LOCK NOT HELD BY ANY CPU
         B     CMSREXIT                 GO TO COMMON RETURN CODE
         SPACE 2
*/*CMSROCH: P (,CMSREXIT) SET RC=8 "ANOTHER CPU OWNS LOCK" */
         SPACE 2
CMSROCH  DC    0H'0'
         LA    REG10,EIGHT              RC 8 - LOCK OWNED BY ANOTHER
         B     CMSREXIT                 GO TO COMMON RETURN CODE
         SPACE 2
**********************************************************************
*                                                                    *
*        THIS ROUTINE DEQUEUES ANY SRBS AND ASCBS THAT ARE SUSPENDED *
*        ON THE CMS LCK SPND Q. IF ANY SRBS ARE ON THE       @Z40FPXJ*
*        SUSPEND QUEUE, THEY WILL BE SCHEDULED AND MEMORY SWITCH     *
*        WILL NOT BE INVOKED.  IF THERE ARE NO SRBS (THEN THERE      *
*        MUST BE ASCBS) MEMORY SWITCH WILL BE INVOKED EACH TIME      *
*        AN ASCB IS DEQUEUED.  EACH ASCB WILL HAVE THE INTERRUPTED   *
*        LOCK ID PLACED IN ITS LOCAL LOCK (PREVIOUS VALUE WAS THE    *
*        SUSPEND ID) IN ORDER THAT THE DISPATCHER WILL DISPATCH THAT *
*        ASCB WHEN IT BECOMES HIGHEST READY MEMORY.                  *
**********************************************************************
         SPACE 2
*/*CMSRDEQS: E CMSRDEQS */
*/* P SAVE REGS */
         SPACE 2
CMSRDEQS DC    0H'0'
         ST    REG0,PSALKR0             SAVE CALLERS REG 0     @Z40FPXJ
         ST    REG1,PSALKR1             SAVE CALLERS REG1      @Z40FPXJ
         ST    REG14,PSALKR14           SAVE CALLERS REG 14    @Z40FPXJ
         ST    REG15,PSALKR15           SAVE CALLERS REG 15    @Z40FPXJ
CMSRDQCS DS    0H                                              @Z40FPXJ
         CDS   REG6,REG8,ZERO(REG11)    DEQUE CHAIN            @Z40FPXJ
         BNZ   CMSRDQCS                 UNSUCCESSFUL, TRY AGN  @Z40FPXJ
         NI    PSACLHS+3,ALLONES-CMS    UPDATE STRING          @Z40FPXJ
CMSRELNC DS    0H                                              @Z40FPXJ
         L     REG1,CASCB               PICK UP ASCB ACRONYM   @Z40FPXJ
         C     REG1,ZERO(REG7)          IS IT AN ASCB          @Z40FPXJ
         BE    CMSRASCB                 YES GO DEQUE ASCB      @Z40FPXJ
         USING SRBSECT,REG7                                    @Z40FPXJ
         LR     REG1,REG7              SAVE  SRB  ADDRESS     @Z40FPXJ
         L     REG7,SRBFLNK            GET NEXT ELEMENT        @Z40FPXJ
         SCHEDULE SRB=(REG1)            SCHED SRB              @Z40FPXJ
         LTR   REG7,REG7                IS Q EMPTY             @Z40FPXJ
         BZ    CMSRDEX                  YES, DONE              @Z40FPXJ
         B     CMSRELNC                 NO, GET NEXT ELEMENT   @Z40FPXJ
CMSRASCB DS    0H                                              @Z40FPXJ
         DROP  REG9
         USING ASCB,REG7                                       @Z40FPXJ
         L     REG4,ASCBCMSF                                   @ZM40338
         L     REG6,INTERTID            GET INTERRUPT ID       @Z40FPXJ
         ST    REG6,ASCBLOCK            STORE IT IN LOCK       @Z40FPXJ
         SPACE 2                                               @Z40FPXJ
*/* P FREE LOCK AND UPDATE STRING */                           @Z40FPXJ
*/* CMSRELNC: D (YES,CMSRASCB,NO,) IS ELEMENT ASCB */          @Z40FPXJ
*/* P SCHEDULE SRB */                                          @Z40FPXJ
*/* D (NO,CMSRDEX,YES,CMSRELNC) ANY MORE ELEMENTS */           @Z40FPXJ
*/* CMSRASCB: P PUT INTERRUPT ID IN LOCAL LOCK */              @Z40FPXJ
         SPACE 2
         LA    REG1,ZERO(REG7)          ASCB ADDR IN REG1     @Z40FPXJ
         LH    REG0,ASCBAFFN-ASCB(REG1) GET AFFINITY MASK
         C     REG0,NOCPUAFF            TEST FOR AFFN SPECIFIED
         BE    CMSRDMS1                 NO AFFINITY SPECIFIED
         LCR   REG1,REG1                INDICATE AFFINITY TO MS
CMSRDMS1 DC    0H'0'
         SPACE 2                                               @Z40FPXJ
*/* CMSRAOLD: S IEAVEMS0 MEMORY SW */                          @Z40FPXJ
         SPACE 2                                               @Z40FPXJ
CMSRAOLD DS    0H                                              @Z40FPXJ
         L     REG15,AMEMSW             ADDR OF MEMORY SWITCH
         BALR  REG14,REG15              INVOKE MEMORY SWITCH
*/*CMSRDNMS: D (YES,CMSRELNC,NO,) ANY MORE ELEMENTS? */        @Z40FPXJ
         SPACE 2
CMSRDNMS DC    0H'0'
         LR    REG7,REG4                RESTORE ASCB PTR       @ZM40338
         LTR   REG7,REG7                IS THIS THE LAST ELE   @Z40FPXJ
         BNZ   CMSRELNC                 MORE ELEMENTS          @Z40FPXJ
         SPACE 2
*/*CMSRDEX: P RESTORE REGS */
*/* R RETURN */
         SPACE 2
CMSRDEX  DC    0H'0'
         L     REG0,PSALKR0             RESTORE CALLER'S REG 0 @Z40FPXJ
         L     REG1,PSALKR1             RESTORE CALLER'S REG 1 @Z40FPXJ
         L     REG14,PSALKR14           RESTORE CALLER REG 14  @Z40FPXJ
         L     REG15,PSALKR15           RESTORE CALLER REG 15  @Z40FPXJ
         SLR   REG10,REG10              GET A ZERO RETURN CODE @Z40FPXJ
         B     CMSREXIT                 RETURN TO CALLER       @Z40FPXJ
         TITLE 'IEAVELK''S RELEASE MULTIPLE SPIN LOCKS ROUTINE'
         SPACE 2
OFSTREG  EQU   8                        OFFSET REG FOR CLHT & OTHER
CLHSREG  EQU   11                       REG TO MANIPULATE CLHS
LOCKWREG EQU   7                        REG TO CONTENT LOCK ADDR
ALCKATAB EQU   12                       TAB OF ADDR OF LOCK ADDR
NZNCARRY EQU   4                        MASK VALUE
ZNOCARRY EQU   8                        MASK VALUE
ZCARRY   EQU   2                        MASK VALUE
         SPACE 2
*/*RELGS: E RELGS */
         SPACE 2
RELGS    DC    0H'0'
         ENTRY RELGS
         USING *,BASER13
         SPACE 2
*/* P SAVE CALLER'S REGS */
         SPACE 2
         STM   REG6,REG10,PSALKR6       SAVE CALLERS REGISTERS
         SPACE 2
*/* P SAVE RELEASE STRING VALUE */
         SPACE 2
         LR    REG6,CLHSREG             SAVE RELEASE STRING VALUE
         SPACE 2
*/* P TURN OF SETLOCK ACTIVE BIT */
         SPACE 2
         OI    PSASUP1,PSALOCK          SETLOCK ACTIVE INDICATOR
         SPACE 2
*/* P SET 'CS' COMPERAND TO ZERO */
         SPACE 2
         LA    ZERORG10,ZERO            FULLWORD OF ZEROS FOR COMPARE
         SPACE 2
*/* P INIT LOOP TO CHECK RELEASE STRING */
         SPACE 2
         SR    OFSTREG,OFSTREG          INIT INDEX REGISTER TO ZERO
         SLL   CLHSREG,30-NBSPIN        SHIFT DISP BIT HIGH ORDER
         SPACE 2
*/*RGSNEXT: P PREPARE CHECK OF NEXT LEVEL */
         SPACE 2
RGSNEXT  DC    0H'0'
         ALR   CLHSREG,CLHSREG          FORCE HIGH BIT OUT:CARRY IF 1
         SPACE 2
*/* D (YES,RGSREL,NO,) IS A LOCK OF THIS LEVEL HELD? */
*/* D (NO,RGSOUT,YES,RGSINCR) ANY LOCK HELD AT LOWER LEVEL? */
         SPACE 2
         BC    NZNCARRY,RGSINCR         LOCKS HELD BUT NOT THIS LEVEL
*                                       COND. NEVER HAPPENS: REG NEVER
*                                       NULL AT ENTRY AND THEN GOES 1ST
*                                       THRU ZERO+CARRY WHICH EXIT AT
*                                       END OF PROCESSING TO 'RGSOUT'.
         SPACE 2
*/*RGSREL: P OBTAIN LOCKWORD ADDR THRU LOCK INTFCE TAB */
         SPACE 2
         L     LOCKWREG,ZERO(OFSTREG,ALCKATAB) ADDR OF LOCK ADDR
         L     LOCKWREG,ZERO(LOCKWREG)  ADDR OF LOCKWORD
         SPACE 2
*/* P RELEASE LOCK */
         SPACE 2
         ST    ZERORG10,ZERO(LOCKWREG)  PLACE ZEROS IN LOCK
         SPACE 2
*/* P UPDATE CPU LOCKS HELD TABLE ENTRY */
         SPACE 2
         ST    ZERORG10,PSACLHT(OFSTREG) STORE ZERO IN CLHT ENTRY
         SPACE 2
*/* D (NO,RGSOUT,YES,) MORE LOCKS TO RELEASE? */
         SPACE 2
         BC    ZCARRY,RGSOUT            NO MORE LOCKS:EXIT FROM LOOP
*                                       NOTE: CHK STILL ON ALR RETCODE
         SPACE 2
*/*RGSINCR: P (,RGSNEXT) INCREMENT INDEX FOR CLHT */
         SPACE 2
RGSINCR  DC    0H'0'
         LA    OFSTREG,FOUR(OFSTREG)    INCREMENT TO NEXT CLHT OFFSET
         B     RGSNEXT                  TEST NEXT BIT IN STRING
         SPACE 2
*/*RGSOUT: P UPDATE CPU LOCKS HELD STRING */
         SPACE 2
RGSOUT   DC    0H'0'
         X     REG6,PSACLHS             RESET ALL RELEASED LOCKS BITS
         ST    REG6,PSACLHS             STORE NEW STRING
         SPACE 2
*/* P RESTORE REGS */
         SPACE 2
         LM    REG6,REG10,PSALKR6       RESTORE CALLER'S REGISTERS
         SPACE 2
*/* P TURN OFF SETLOCK ACTIVE INDICATOR */
         SPACE 2
         NI    PSASUP1,LOCKNACT         TURN OFF LOCK ACTIVE BIT
         SPACE 2
*/* D (YES,RGSRETDS,NO,) RETURN IN DISABLED STATE? */
         SPACE 2
         TM    PSAMPSW,ENABLE           CHECK RETURN DISABLED
         BZR   RETURN                   BRANCH IF YES
         SPACE 2
*/* D (YES,RGSRETDS,NO,) SYS. DISABLED INDICATOR ON? */
         SPACE 2
         L     REG12,SUPMASK            MASK TO CHECK SUP CTRL BITS
         N     REG12,PSASUPER           ZERO REG IF ONLY SETLOCK BIT ON
         BNZR  RETURN                   RELEASE DISABLED
         SPACE 2
*/* D (YES,RGSRETDS,NO,) SOME SPIN LOCKS STILL HELD? */
         SPACE 2
         LA    REG12,FRSTSPIN           MASK TO CHK FOR MORE SPIN LOCKS
         CL    REG12,PSACLHS            ARE THERE MORE?
         BNHR  RETURN                   YES: ELEASE DISABLED
         SPACE 2
*/* P TURN ON ENABLE BITS IN MODEL PSW */
         SPACE 2
         STOSM PSAMPSW,ENABLE           ENABLE FOR IO & EXT
         SPACE 2
*/*RGSRETDS: P BR 14 TO RETURN DISABLE */
*/* R RETURN */
         SPACE 2
RGSRETDS DC    0H'0'
         BR    RETURN                   RETURN TO CALLER
         SPACE 2
*/*STLKAB73: P ABEND CODE SYSTEM 073 HIERARCHY VIOLATION */
*/* P OR NON-TCBIRB OR SRB CALLER */
*/* P TURN OFF SETLOCK ACTIVE INDICATOR */
*/* P ABEND SVC */
*/* R ABEND */
         SPACE 2
SUSPAB73 NI    PSASUP3,ALLONES-PSAULCMS SETLOCK NOT ACTIVE     @ZA28255
STLKAB73 DC    0H'0'
         NI    PSASUP1,LOCKNACT         TURN OFF SETLOCK ACTIVE BIT
         ABEND X'073',DUMP,,SYSTEM      ABEND THE CALLER
         TITLE 'IEAVELK''S WINDOW SPIN ROUTINE'
***********************************************************************
*        WINDOW SPIN ROUTINE - THIS ROUTINE WILL ENABLE FOR EMERGENCY *
*        SIGNAL AND MALFUNCTION ALERT EXTERNAL INTERRUPTS, IMMEDIATELY*
*        DISABLE AND TEST TO SEE IF ACR WAS ACTIVED DURING THE ENABLED*
*        PERIOD. IF ACR WAS ACTIVATED, THE LOCK WILL BE COMPARED WITH *
*        THE FAILING CPU ID TO DETERMINE IF FAILING CPU OWN THE LOCK  *
*        OR A HIGHER LOCK. IN EITHER CASE ACR WILL BE INVOKED         *
***********************************************************************
         SPACE 2
*/*WINDSPIN: E WINDSPIN */
         SPACE 2
         ENTRY IEAVELKW                                        @Z40FPXJ
WINDSPIN DC    0H'0'
IEAVELKW DS    0H                                              @Z40FPXJ
         USING *,SPINRTNR               EST. SPIN ROUTINES ADDRESSABLTY
         SPACE 2
*/* P TURN ON LOCK'S SPIN INDICATOR FOR EXT FLITH */
         SPACE 2
         OI    LCCASPN1,LCCALOCK        LOCK IN SPIN ROUTINE
WINDLOOP DS    0H                                              @Z40FPXJ
         CL    ALECLHT,MASKSALC         IS THIS SPN FOR SALLOC @Z40FPXJ
         BE    WINDSALC                 YES, SET SMALL COUNT   @Z40FPXJ
         L     REG5,LOOPCTN             NO, SET HIGH COUNT     @Z40FPXJ
         B     WINDSPNI                 GO SPIN FOR LOCK       @Z40FPXJ
WINDSALC DS    0H                                              @Z40FPXJ
         L     REG5,LOOPSALC            SET LOW CNT FOR SALLOC @Z40FPXJ
WINDSPNI DS    0H                                              @Z40FPXJ
         L     REG10,ZERO(LKADDR11)     CHECK IF LOCK AVAIL    @Z40FPXJ
         LTR   REG10,REG10                                     @Z40FPXJ
         BNZ   WINDBCT                  NO, DECRMENT SPIN CNT  @Z40FPXJ
         NI    LCCASPN1,LOCKNSPN        LOCK OUT OF SPIN RTN   @Z40FPXJ
         BR    MNLRETRN                 RETURN TO MAINLINE     @Z40FPXJ
WINDBCT  DS    0H                                              @Z40FPXJ
         BCT   REG5,WINDSPNI            CNT>1 CONTINUE LOOP    @Z40FPXJ
*/*WINDLOOP: D (YES,WINDSALC,NO,) IS SPIN FOR SALLOC */        @Z40FPXJ
*/* P (,WINDSPNI) SET COUNT='100'X */                          @Z40FPXJ
*/* WINDSALC: P SET COUNT='05'X */                             @Z40FPXJ
*/* WINDSPNI: D (YES,,NO,WINDLP) LOCK AVAIL? */                @Z40FPXJ
*/* P TURN OFF SPIN BIT */                                     @Z40FPXJ
*/* R RETURN TO MAINLINE */                                    @Z40FPXJ
*/*WINDLP: P DECREMENT COUNT BY 1 */                           @Z40FPXJ
*/*  D (YES,,NO,WINDSPNI) TIME TO OPEN WINDOW */               @Z40FPXJ
*/* P SAVE CR0 IN PSACR0 & LCCALCR0 */
*/* P MODIFY CR0 TO ENABLE MFA & ES */
*/* P ENABLE EXT & INT SUMM MASK BIT IN PSW */
*/* P DISABLE EXT. INT. SUMM. MASK IN PSW */
*/* P LOAD CR0 FROM PSACR0 */
         SPACE 2
         WINDOW  LCCALCR0               ENABLE/DISABLE FOR EMS AND MFA
         SPACE 2
*/* P TURN OFF SPIN INDICATOR */
         SPACE 2
         NI    LCCASPN1,LOCKNSPN        LOCK OUT OF SPIN ROUTINE
         SPACE 2
*/* D (YES,,NO,WINDSPIN) ACR ACTIVE IND ON? */                 @Z0FPXJ
         SPACE 2
         TM    LCCADSF1,LCCAACR         IS ACR IN PROCESS
         BZ    WINDSPIN                 NO ACR RETN TO SPN LP @Z40FPXJ
         SPACE 2
*/* P SET FAILING CPU = OTHER CPU */
         SPACE 2
*  CODE FOR SETLOCK REQUEST BY FAILING CPU ON GOOD CPU
         L     REG10,LCCADCPU           GET FAILING CPU'S LOGICAL CCA
         SPACE 2
*/* D (YES,WINDFCPU,NO,) LCCA= RECOVERYING CPU? */
         SPACE 2
         CR    LCCAPTR,REG10            IS REQUEST BY FAILING CPU
         BNE   WINDFCPU                 GOOD CPU REQUESTING LOCK
         SPACE 2
*/* P SET RECOVERYING CPU= OTHER CPU */
         SPACE 2
         L     REG10,LCCARCPU           RECOVERYING CPU BECOMES OTHER
         SPACE 2
*/*WINDFCPU: P COMPARE CPUID OF OTHER CPU WITH CPUID OF LOCK */
         SPACE 2
WINDFCPU DC    0H'0'                    TEST FOR OTHER CPU OWNING LOCKS
         DROP  REG8                     REG10 IS NEW LCCA BASE
         USING LCCA,REG10               EST. NEW LCCA ADDRESSABILITY
         LH    REG5,LCCACPUA            GET OTHER CPU'S LOGICAL ADDR
         SPACE 2
*/* D (YES,WINDACR,NO,) CPUIDS EQUAL? */
         SPACE 2
         C     REG5,ZERO(LKADDR11)      DOES OTHER CPU OWN LOCK?
         BE    WINDACR                  OTHER CPU OWNS LOCK CALL ACR
         SPACE 2
*/* D (YES,,NO,WINDEXIT) OTHER CPU OWNS HIGHER LOCK? */
         SPACE 2
         CL    ALECLHT,LCCACRLC         DOES OTHER CPU OWN HIGHER LK?
         BL    WINDEXIT                 OTHER CPU DOES NOT
         SPACE 2
*/*WINDACR: S ACRLM:CALL RTM TYPE=ACRLM, CCA=(1) */
         SPACE 2
         DROP  REG10                    REG 10 NOT REQUIRED FOR LCCA
         USING LCCA,LCCAPTR             REESTABLISH REG8 AS LCCA BASE
WINDACR  DC    0H'0'
         CALLRTM TYPE=ACRLM,CCA=(LCCAPTR)   INVOKE ACR
         SPACE 2
*/*WINDEXIT: R RETURN */
         SPACE 2
WINDEXIT DC    0H'0'
         BR    MNLRETRN                 RETURN TO CALLER
         ENTRY IEAVELKE                                        @YM04039
IEAVELKE DS    0H                       END OF LOCK RTN        @YM04039
*/*IEAVSPCR: E COMMON SUSPEND ROUTINE ENTRY POINT */
*/* HEADER
*/*                                           IBM CONFIDENTIAL
*/*
*/*
*/*                                        SECTION: 3.1.7.14
*/*         SETLOCK ROUTINES
*/*                                      PAGE # */
         ENTRY IEAVSPCR
IEAVSPCR DC    0H'0'
***********************************************************************
*        IEAVSPCR IS A COMMON SUSPEND ROUTINE AVAILABLE TO THE LOCK   *
*        MANAGER AND THE PAGE SUSPEND PROCESSOR WHEN SUSPENDING A SRB *
*        OR A LOCALLY LOCKED TASK.  THIS ROUTINE WILL CALL THE JOB    *
*        STEP TIMING SUBROUTINE IN THE DISPATCHER TO COMPLETE THE     *
*        STATUS SAVING FUNCTION. DISPATCHER'S RECOVERY ROUTINE WILL   *
*        ALSO CALL THIS SUBROUTINE WHEN SAVING A LOCALLY LOCKED TCB'S *
*        STATUS.                                                      *
*        INPUT TO THIS ROUTINE IS AS FOLLOWS:                         *
*        REGISTERS: R7 - LCCA ADDRESS                                 *
*                   R8 - ASCB ADDRESS                                 *
*                  R12 - IEAVSPCR ENTRY POINT ADDRESS                 *
*                  R15 - RETURN ADDRESS OF CALLER                     *
*                   R1 - 0 - (SUSPEND A LOCALLY LOCKED TASK)          *
*                      - ADDRESS OF SRB - (SUSPEND A SRB)             *
***********************************************************************
*                  REGISTER EQUATES                                   *
R0       EQU   0                       REG 0
R1       EQU   1                       REG 1
R2       EQU   2                       REG 2
R3       EQU   3                       REG 3
R4       EQU   4                       REG 4
R6       EQU   6                       REG 6
R7       EQU   7                       REG 7
R8       EQU   8                       REG 8
R9       EQU   9                       REG 9
BASER12  EQU   12                      BASE REGISTER
RE       EQU   14                      REG 14
R14      EQU   14                      REG 14
RF       EQU   15                      REG 15                   ZM02352
R15      EQU   15                      REG 15
DSL0     EQU   0                       DISPLACEMENT VALUE
DSL1     EQU   1                       DISPLACEMENT VALUE
DSL2     EQU   2                       DISPLACEMENT VALUE
DSCC7    EQU   7                       DISPLACEMENT VALUE
XFF      EQU   X'FF'                   MASK VALUE
SPCRLLHI EQU   1                       LOCAL LOCK HELD MASK
SPCRCMSI EQU   2                       CMS LOCK HELD BIT
         USING *,BASER12
         USING LCCA,R7
         USING ASCB,R8
         USING PSA,0
         SPACE 2
*/* D (YES,SPCRSRBS,NO,) IS SRB TO BE SAVED? */
         SPACE 2
         LTR   R1,R1                   IS THIS A SUSPENDED SRB?
         BNZ   SPCRSRBS                PROCESS SRB WHOSE ADDR IS IN R1
         SPACE 2
*/* P GET IHSA ADDRESS */
         SPACE 2
         L     R3,ASCBASXB             ASXB ADDRESS
         DROP  REG5
         USING ASXB,R3
         L     R3,ASXBIHSA             IHSA ADDRESS
         DROP  R3
         USING IHSA,R3
         SPACE 2
*/* P STORE FLOATING POINT REGISTERS */
         SPACE 2
         STD   R0,IHSAFPR0-IHSA(R3)    *    STORE
         STD   R2,IHSAFPR2-IHSA(R3)    *         FLOATING
         STD   R4,IHSAFPR4-IHSA(R3)    *              POINT
         STD   R6,IHSAFPR6-IHSA(R3)    *                   REGISTERS.
         SPACE 2
*/* P SAVE PSATNEW AND PSATOLD */
         SPACE 2
         L     R2,PSATNEW              *    STORE
         L     RE,PSATOLD              *         PSATNEW
         ST    R2,IHSANTCB-IHSA(R3)    *              AND
         ST    RE,IHSAOTCB-IHSA(R3)    *                   PSATOLD
         SPACE 2
*/* D (NO,SPCRNTME,YES,) IS THERE A TCB? */
         SPACE 2
         LTR   RE,RE                   TEST FOR TCB ADDRESS.
         BZ    SPCRNTME                NO. BYPASS TIMER TESTS.
         SPACE 2
*/* D (NO,SPCRNTME,YES,) IS THERE A TQE FOR THIS TCB? */
         SPACE 2
         USING TCB,RE                  TCB ADDRESSABILITY.
         L     R2,TCBTME               TQE ADDRESS FROM TCB.
         LTR   R2,R2                   IS THERE A TQE?
         BNH   SPCRNTME                NO. BYPASS TIMER SETTING.
         DROP  RE                      DROP TCB ADDRESSABILITY.
         SPACE 2
*/* D (NO,SPCRNTME,YES,) IS THIS CPU'S TIMER OK? */
         SPACE 2
         L     R1,PSAPCCAV             PCCA ADDRESS.
         USING PCCA,R1                 PCCA ADDRESSABILITY.
         TM    PCCAINTE,PCCANUIN       IS THE CPU TIMER OK?
         DROP  R1
         BO    SPCRNTME                NO. BYPASS TIMER SETTINGS.
         SPACE 2
*/* P SAVE CPU INTERVAL TIMER INTO IHSA */
         SPACE 2
         STPT  IHSACPUT-IHSA(R3)       SAVE CPU INTERVAL TIMER VALUE
         SPACE 2
*/* P SET CPU TIMER TO HIGH VALUE */
         SPACE 2
         SPT   SPCRHITM                SET CPU INT TIMER TO X'7F---F'
         SPACE 2
*/*SPCRNTME: P SAVE LOCAL SUPERVISOR'S FRR STACK */
         SPACE 2
SPCRNTME DC    0H'0'
         LR    R9,R15                  SAVE R15 VALUE ACROSS MVCL
         LA    R2,IHSAFRRS-IHSA(R3)    OBTAIN FRR SAVE AREA ADDR
         L     RE,PSANSTK              OBTAIN NORMAL STACK ADDRESS
         L     R3,FRRSCURR-FRRS(RE)    CURRENT ENTRY           @ZM02352
         L     RF,FRRSELEN-FRRS(RE)    LENGTH OF CURRENT ENTRY @ZM02352
         AR    R3,RF                   ADDR OF LAST BYTE       @ZM02352
         SR    R3,RE                   LENGTH OF STACK TO SAVE @ZM02352
         LA    R15,DSL0(R3)            DUPLICATE LENGTH
         MVCL  R2,RE                   MOVE THE NORMAL STK TO SAVE AREA
         LR    R15,R9                  RESTORE R15 VALUE
         SPACE 2
*/*SPCRJSTR: P SET UP FOR CALL TO JST RTN */
*/* S DSJST:CALCULATE JOB STEP TIME */
         SPACE 2
SPCRJSTR DC    0H'0'
         L     R1,SPCRJSTA             DISP JST SUB RTN EP
         BALR  RE,R1                   GO TO CALCULATE JOB STEP TIME
*   DSJST USES REGISTERS 0,1,2,3,9 AND 14.
         SPACE 2
*/* D (NO,SPCRNCMS,YES,) IS THE CMS LOCK HELD? */
*/* P SET ASCBCMSH BIT */
         SPACE 2
         SETLOCK TEST,TYPE=CMS,BRANCH=(NOTHELD,SPCRNCMS)
         OI    ASCBFLG1,ASCBCMSH       SET CMS LOCK HELD BIT IN ASCB
         SPACE 2
*/*SPCRNCMS: D (NO,SPCRNOLK,YES,) IS THIS CPU ID IN LOCAL LOCK */
         SPACE 2
SPCRNCMS DC    0H'0'
         LH    R2,ASCBLOCK+DSL2        ID VALUE FROM THE LOCAL LOCK
         CH    R2,PSACPULA             IS IT THE CURRENT CPU.
         BC    DSCC7,SPCRNOLK          NO. RETURN
         SPACE 2
*/* D (YES,SPCRSRBM,NO,) IS THIS SRB MODE? */
*/* P DECREMENT ASCBCPUS COUNT */
         SPACE 2
         TM    LCCADSF2,LCCASRBM       IS THIS SRB MODE?
         BO    SPCRSRBM                SRB MODE, DON'T DECREMENT COUNT
         L     R1,ASCBCPUS             GET NO. OF CPUS ACTIVE
SPCRCSLP DC    0H'0'
         LR    R2,R1                   CUPLICATE NO. OF CPUS ACTIVE
         BCTR  R2,ZERO                 DECREMENT COUNT OF CPUS
         CS    R1,R2,ASCBCPUS          UPDATE ASCBCPUS
         BNZ   SPCRCSLP                COUNT HAS CHANGED REPEAT
         SPACE 2
*/*SPCRSRBM: P STORE SUSPEND ID INTO LOCAL LOCK */
         SPACE 2
SPCRSRBM DC    0H'0'
         L     R1,SPCRSPID              YES. STORE SUSPEND ID
         ST    R1,ASCBLOCK              INTO THE LOCAL LOCK.
         SPACE 2
*/*SPCRNOLK: P CLEAR PSATNEW AND PSATOLD FIELDS */
         SPACE 2
SPCRNOLK DC    0H'0'
         SR    R1,R1                    ZERO THE STORE REG
         ST    R1,PSATNEW               *    CLEAR PSANEW
         ST    R1,PSATOLD               *         AND PSAOLD
         SPACE 2
*/* P CLEAR LOCAL AND CMS CPU LOCK HELD INDICATORS */
         SPACE 2
         NI    PSAHLHI+3,XFF-SPCRLLHI-SPCRCMSI  CLEAR LOCK BITS
         NI    LCCADSF2,XFF-LCCASRBM-LCCAGSRB   CLEAN UP SRB MODE
*              INDICATORS
         SPACE 2
DST110A  DC    0H'0'                    *** TEST LABEL ***
*/*DST110A: R RETURN */
         SPACE 2
         BR    R15                      RETURN.
         EJECT
SPCRSRBS DC    0H'0'
         USING SRBSECT,R1
         SPACE 2
*/*SPCRSRBS: P SAVE FPRS IN SRB S A */
         SPACE 2
         STD   R0,SSRBFPR0            SAVE FPR 0 IN SRB SAVE AREA
         STD   R2,SSRBFPR2            SAVE FPR 2 IN SRB SAVE AREA
         STD   R4,SSRBFPR4            SAVE FPR 4 IN SRB SAVE AREA
         STD   R6,SSRBFPR6            SAVE FPR 6 IN SRB SAVE AREA
         SPACE 2
*/* P SAVE FRR STACK IN SRB S A */
         SPACE 2
         LR    R9,R15                  SAVE R15 VALUE ACROSS MVCL
         LA    R2,SSRBFRRS             OBTAIN FRR SAVE AREA ADDR
         L     RE,PSANSTK              OBTAIN NORMAL STACK ADDRESS
         L     R3,FRRSCURR-FRRS(RE)    CURRENT ENTRY           @ZM02352
         L     RF,FRRSELEN-FRRS(RE)    LENGTH OF CURRENT ENTRY @ZM02352
         AR    R3,RF                   ADDR OF LAST BYTE       @ZM02352
         SR    R3,RE                   LENGTH OF STACK TO SAVE @ZM02352
         LA    R15,DSL0(R3)            DUPLICATE LENGTH
         MVCL  R2,RE                   MOVE THE NORMAL STK TO SAVE AREA
         LR    R15,R9                  RESTORE R15 VALUE
         SPACE 2
*/* P SAVE ASCB ADDR FROM PSAOLD IN SRB */
         SPACE 2
         ST    R8,SRBASCB               SAVE ASCB ADDR IN SRB  @ZA18876
         SPACE 2
*/* P SAVE CPU AFFINITY & PURGE ASID/TCB FROM LCCA */
         SPACE 2
         MVC   SRBFLC,LCCASRBF          MOVE CPU AFFINITY, ASID & TCB
         SPACE 2
*/* P MOVE REG 3 FROM PSA TO SRB SA */
         SPACE 2
         LA    R3,SSRB                  FIRST BYTE OF SRB SAVE AREA
         SPACE 2
*/* P PLACE ADDR OF SRB SA IN SRB */
         SPACE 2
         ST    R3,SRBSAVE               SAVE SRB SAVE AREA ADDR IN SRB
         SPACE 2
*/* P EST. PRIORITY LELEL - NONQ FOR THE SRB */
         SPACE 2
         LA    R3,SRBPNONQ               ESTABLISH X'04'
         STC   R3,SRBPRIOR               EST. THIS SRB AS A NONQ LEVEL
         SPACE 2
*/* P ESTABLISH RMTR FOR SRB */
         SPACE 2
         L     R2,ARMTRRTN               RMTR ROUTINE FOR PURDGE DQ
         ST    R2,SRBRMTR                SAVE RMTR ADDR IN SRB
         SPACE 2
*/* D (NO,SPCRJSTR,YES,) IS LOCAL LOCK HELD */
         SPACE 2
         SETLOCK TEST,TYPE=LOCAL,BRANCH=(NOTHELD,SPCRJSTR)
         SPACE 2
*/* P (,SPCRJSTR) TURN ON LOCAL LOCK HELD BIT IN SRB */
         SPACE 2
         OI    SSRBFLG1,SSRBLLH         INDICATE LOCAL LOCK HELD
         B     SPCRJSTR                 PERFORM JST AND CPU CLEAN UP
         DS    0D
SPCRHITM DC    X'7FFFFFFFFFFFFFFF'     HIGH CPU TIMER VALUE>
SPCRSPID DC    X'7FFFFFFF'             SUSPEND ID FOR LOCAL LOCK
ARMTRRTN DC    V(IEAVEFRE)             SUSPEND SRBS' RMTR RTN
SPCRJSTA DC    V(DSJSTCSR)             ENTRY TO JOB STEP TIMING RTN
         EJECT
***********************************************************************
*****     LOCK MANAGER RESOURCE CLEAN-UP ON MEMORY TERMINATION    *****
***********************************************************************
         SPACE 2
*/*IEAVELRM: E RESOURCE MANAGER */
         SPACE 2
         ENTRY IEAVELRM
IEAVELRM DS    0H
         SPACE 2
*/* P SAVE REGS USED */
*/* P GET SUSPEND QUEUE HEADER */
         SPACE 2
         STM   REG14,REG12,TWELVE(REG13) SAVE AREA PROVIDED BY MEM TERM
         BALR  REG9,ZERO                ESTABLISH ADDRESSABILITY
         USING *,REG9
         L     REG2,ZERO(REG1)          ADDR OF MEM TERM'S PARM LIST
         L     REG6,RMPLASCB-RMPL(REG2) GET ADDR OF TERMINATING MEMORY
         L     REG5,ASCBLSQH-ASCB(REG6) LOCAL LK SPND Q HEADER @Z40FPXJ
         SPACE 2
*/*LRMSQCHK: D (NO,LRMSQEND,YES,) ANY SRBS ON QUEUE? */
         SPACE 2
LRMSQCHK DC    0H'0'
         LTR   REG5,REG5                HAS LAST ELEMENT ON QUEUE BEEN
*                                       PROCESSED?
         BZ    LRMSQEND                 EXIT TO MEM TERM
         SPACE 2
*/* L SCHEDULE: SCHEDULE SRB TO LSMQ */
         SPACE 2
         LA    REG1,ZERO(REG5)          PLACE SRB ADDRESS IN REG 1.
         L     REG5,SRBFLNK-SRB(REG5)   GET NEXT SRB ON QUEUE IF ANY.
         SCHEDULE SRB=(1)
         SPACE 2
*/* P (,LRMSQCHK) GO SEE IF ANY MORE */
         SPACE 2
         B     LRMSQCHK                 GO TEST FOR LAST SRB
         SPACE 2
*/*LRMSQEND: P RESTORE SAVED REGS */
         SPACE 2
LRMSQEND DC    0H'0'
         LM    REG14,REG12,TWELVE(REG13) RELOAD REGS
         SPACE 2
*/* P SET RC=0 */
*/* R RETURN TO CALLER */
         SPACE 2
         LA    REG15,ZERO               SET RETURN CODE
         BR    REG14                    RETURN
***********************************************************************
*****                CONSTANTS & EXTERNAL ADDRESSES               *****
***********************************************************************
ZEROS    DC    A(0)                     COMPARISON VALUE - FW OF ZEROS
LLUOBS   DC    A(LLUOBT)                LOCAL UNCOND ADDR
GSLMUOBS DC    A(GSLMUOBT)              MULT UNCOND ADDR
GSLSUOBS DC    A(GSLSUOBT)              SINGLE UNCOND ADDR
GSLSDISB DC    A(GSLSDISP)              DISP LOCK RTN ADDR
ADISPLCK DC    V(DISPLOCK)              ADDRESS OF DISPATCHER LOCK
ASALCLCK DC    V(SALCLOCK)              ADDRESS OF SALLOC LOCK
ACMSLOCK DC    V(CMSLOCK)               ADDRESS OF CMS LOCK
LOCKASVT DC    V(IEAVLKRR)              SETLOCK FRR ADDRESS    @ZA28255
SUPMASK  DC    AL1(255-PSALOCK),3AL1(255) MASK TO CHECK SUP BYTES
NOCPUAFF DC    X'FFFFFFFF'              MASK FOR NO CPU AFFINITY
INTERTID DC    X'FFFFFFFF'              INTERRUPT ID FOR LOCKWORD
ACMSSQH  DC    V(CMSSQH)                CMS SPND Q SRB 1ST PTR @Z40FPXJ
*                                       CMS REQUESTOR, NON-SRB MODE
SUSPNDID DC    X'7FFFFFFF'              SUSPEND ID FOR LOCKWORD
AIEA0DS  DC    V(IEA0DS)                DISPATCHER'S NORMAL ENTRY
AMEMSW   DC    V(IEAVEMS0)              MEMORY SWITCH ADDRESS
LOOPCTN  DC    X'00000100'              SPIN COUNT             @Z40FPXJ
LOOPSALC DC    X'00000005'              SALLOC SPIN COUNT      @Z40FPXJ
SRBCPID  DC    C'SRB',X'00'             QUICKCELL CPID FOR SUSPENDED
*                                       SRBS
CASCB    DC    C'ASCB'                                         @Z40FPXJ
NOSUSPND DC    XL8'00'                  COMPERAND TO DETERMINE IF
*                                       SUSPEND QUEUES ARE EMPTY
LOCAL    EQU   1                       VALUE OF MASK FOR LOCAL LOCK
CMS      EQU   LOCAL*2                 VALUE OF MASK FOR CMS LOCK
OPT      EQU   CMS*2                   VALUE OF MASK FOR OPT LOCK
FRSTSPIN EQU   OPT                     FIRST SPIN LOCK
TPACBDEB EQU   OPT*2                   VALUE OF MASK FOR TPACBDEB LOCK
TPDNCB   EQU   TPACBDEB*2              VALUE OF MASK FOR TPDNCB LOCK
TPNCB    EQU   TPDNCB*2                VALUE OF MASK FOR TPNCB LOCK
IOSLCH   EQU   TPNCB*2                 VALUE OF MASK FOR IOSLCH LOCK
IOSUCB   EQU   IOSLCH*2                VALUE OF MASK FOR IOSUCB LOCK
IOSCAT   EQU   IOSUCB*2                VALUE OF MASK FOR IOSCAT LOCK
IOSYNCH  EQU   IOSCAT*2                VALUE OF MASK FOR IOSYNCH LOCK
SALLOC   EQU   IOSYNCH*2               VALUE OF MASK FOR SALLOC LOCK
ASM      EQU   SALLOC*2                VALUE OF MASK FOR ASM LOCK
DISP     EQU   ASM*2                   VALUE OF MASK FOR DISP LOCK
FF       EQU   X'FFFF'                 HALFWORD OF ONES
MASKTAB  DS    0F'0'                   MASKS FOR CLHS UPDATING(OBTAIN)
MASKDISP DC    A(DISP)                 MASKS FOR CLHS UPDATING(OBTAIN)
         DC    A(ASM)                  MASKS FOR CLHS UPDATING(OBTAIN)
MASKSALC DC    A(SALLOC)               MASKS FOR CLHS UPDATING(OBTAIN)
         DC    A(IOSYNCH)              MASKS FOR CLHS UPDATING(OBTAIN)
         DC    A(IOSCAT)               MASKS FOR CLHS UPDATING(OBTAIN)
         DC    A(IOSUCB)               MASKS FOR CLHS UPDATING(OBTAIN)
         DC    A(IOSLCH)               MASKS FOR CLHS UPDATING(OBTAIN)
         DC    A(TPNCB)                MASKS FOR CLHS UPDATING(OBTAIN)
         DC    A(TPDNCB)               MASKS FOR CLHS UPDATING(OBTAIN)
         DC    A(TPACBDEB)             MASKS FOR CLHS UPDATING(OBTAIN)
MASKLSPN EQU   *                       LAST SPIN LOCK
         DC    A(OPT)                  MASKS FOR CLHS UPDATING(OBTAIN)
MASKCMS  DC    A(CMS)                  MASKS FOR CLHS UPDATING(OBTAIN)
         DC    A(LOCAL)                MASKS FOR CLHS UPDATING(OBTAIN)
MASKTAB2 DS    0F'0'                   MASK FOR CLHS UPDATING(RELEASE)
MSK2DISP DC    AL2(FF,FF-DISP)         MASK FOR CLHS UPDATING(RELEASE)
         DC    AL2(FF,FF-ASM)          MASK FOR CLHS UPDATING(RELEASE)
         DC    AL2(FF,FF-SALLOC)       MASK FOR CLHS UPDATING(RELEASE)
         DC    AL2(FF,FF-IOSYNCH)      MASK FOR CLHS UPDATING(RELEASE)
         DC    AL2(FF,FF-IOSCAT)       MASK FOR CLHS UPDATING(RELEASE)
         DC    AL2(FF,FF-IOSUCB)       MASK FOR CLHS UPDATING(RELEASE)
         DC    AL2(FF,FF-IOSLCH)       MASK FOR CLHS UPDATING(RELEASE)
         DC    AL2(FF,FF-TPNCB)        MASK FOR CLHS UPDATING(RELEASE)
         DC    AL2(FF,FF-TPDNCB)       MASK FOR CLHS UPDATING(RELEASE)
         DC    AL2(FF,FF-TPACBDEB)     MASK FOR CLHS UPDATING(RELEASE)
         DC    AL2(FF,FF-OPT)          MASK FOR CLHS UPDATING(RELEASE)
         DC    AL2(FF,FF-CMS)          MASK FOR CLHS UPDATING(RELEASE)
         DC    AL2(FF,FF-LOCAL)        MASK FOR CLHS UPDATING(RELEASE)
NBSPIN   EQU   (MASKCMS-MASKDISP)/4        NUMBER OF SPIN LOCKS
         SPACE 2
         TITLE 'IEAVELK - SETLOCK - CVT EXPANSION'
         CVT  DSECT=YES,PREFIX=NO,LIST=YES
         TITLE 'IEAVELK - SETLOCK - PSA EXPANSION'
         IHAPSA
         TITLE 'IEAVELK - SETLOCK - LCCA EXPANSION'
         IHALCCA
         TITLE 'IEAVELK - SETLOCK - PCCA EXPANSION'
         IHAPCCA
         TITLE 'IEAVELK - SETLOCK - ASCB EXPANSION'
         IHAASCB
         TITLE 'IEAVELK - SETLOCK - TCB EXPANSION'             @Z40FPXJ
         IKJTCB                                                @Z40FPXJ
         TITLE 'IEAVELK - SETLOCK - RB EXPANSION'              @Z40FPXJ
         IKJRB
         TITLE 'IEAVELK - SETLOCK - CSD EXPANSION'
         IHACSD
         TITLE 'IEAVELK - SETLOCK - SSRB EXPANSION'
         IHASSRB
         TITLE 'IEAVELK - SETLOCK - IHSA EXPANSION'
         IHAIHSA
         TITLE 'IEAVELK - SETLOCK - ASXB EXPANSION'
         IHAASXB
         TITLE 'IEAVELK - SETLOCK - FRR EXPANSION'
         IHAFRRS
         TITLE 'IEAVELK - SETLOCK - WSAC EXPANSION'
         IHAWSAVT CLASS=CPU
         TITLE 'IEAVELK - SETLOCK - WSAG EXPANSION'
         IHAWSAVT DSECT=YES,CLASS=GLOBAL
         TITLE 'IEAVELK - SETLOCK - RMPL EXPANSION'
         IHARMPL
         IHARRRA                        UNCONDITIONAL LOCAL AND CMS
*                                       LOCK REQUESTS CAUSE FRRS TO BE
*                                       SET ACROSS THE GETMAINS AND
*                                       FREEMAINS FOR SSRBS    @ZA28255
*/* FOOTING
*/*
*/* */
*/*IEAVELK: END SETLOCK */
         SPACE 2
         END   IEAVELK
