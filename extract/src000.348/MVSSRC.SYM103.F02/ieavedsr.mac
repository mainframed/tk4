         TITLE 'IEAVEDSR - PROLOGUE'
* /* START OF SPECIFICATIONS ****
*
*01*  MODULE-NAME = IEAVEDSR
*
*02*     CSECT-NAME = IEAVEDSR
*
*01*  DESCRIPTIVE-NAME = DISPATCHER RECOVERY
*
*01*  COPYRIGHT = NONE
*
*01*  STATUS = CHANGE LEVEL 0
*
*01*  FUNCTION = RECOVERS FROM FAILURES IN THE DISPATCHER.
*
*02*     OPERATION =THE DISPATCHER RECOVERY CALLS THE NECESSARY
*        FUNCTIONS TO CLEAN UP THE DISPATCHING QUEUES AND THE CPU
*        IN ORDER THAT THE DISPATCHER MAY CONTINUE TO DISPATCH
*        READY WORK.
*
*01*   NOTES =
*
*02*     DEPENDENCIES = ORDER OF SAVING AND RESTORING STATUS IN THE
*        DISPATCHER. SEE DISPATCHER RECOVERY SPECIFICATIONS FOR
*        DETAILS.
*
*03*        CHARACTER-CODE-DEPENDENCIES = CHARACTER CODE INDEPENDENT
*
*02*     RESTRICTIONS = NONE
*
*02*     REGISTER-CONVENTIONS = DEFINED IN THE EQUATES SECTION OF THIS
*        MODULE
*
*02*     PATCH-LABEL = NUCLEUS PATCH AREA
*
*01*  MODULE-TYPE = PROCEDURE
*
*02*     PROCESSOR = ASSEMBLER-370R
*
*02*     MODULE-SIZE = SEE ESD FOR THIS MODULE
*
*02*     ATTRIBUTES = NUCLEUS×SUPERVISOR MODE×REFRESHABLE×FIXED×
*        ZERO PROTECT KEY×DISABLED
*
*01*  ENTRY-POINT = IEAVEDSR
*
*02*     PURPOSE = MAIN DISPATCHER RECOVERY ENTRY POINT. DISABLED, KEY
*        ZERO, SUPERVISOR MODE AND ANY LOCK MIGHT BE HELD.
*
*02*     LINKAGE = THE DISPATCHER RECOVERY IS ENTERED VIA A BRANCH.
*        THE FOLLOWING PARAMETERS ARE PASSED TO IT:  THE SDWA AND
*        A 200 BYTE WORK AREA.  THE ONLY CALLER IS THE SUPER
*        RECOVERY ROUTINE, IEAVESPR.
*
*02*     INPUT = THE DISPATCHER RECOVERY LOOKS AT INPUT REGISTERS
*        AND THE LOCKS HELD BY THIS CPU.
*
*02*     OUTPUT = THE DISPATCHER RECOVERY INSURES THE STATUS (REGS,
*        FLOATING POINT REGISTERS, CPU INTERVAL TIMER VALUE, LOCKING
*        STATUS AND PSW) OF THE UNIT BEING DISPATCHED.  THE FOLLOWING
*        READY QUEUES WILL BE VERIFIED AND CORRECTED IF REQUIRED IF THE
*        DISPATCHER LOCK IS HELD:  SERVICE MANAGER GLOBAL AND LOCAL
*        STAGING QUEUES, THE LOCAL SERVICE PRIORITY LIST QUEUES AND THE
*        ASCB READY QUEUE.  IF THE DISPATCHER OBTAINED AND OWNED THE
*        LOCAL LOCK AT TIME OF ERROR, THE TCB READY QUEUE AND THE
*        EXIT EFFECTOR QUEUES (IF THEY HAVE STAGE 3 WORK) WILL BE
*        VERIFIED AND CORRECTED.  THE CPU LOCK HELD INDICATORS WILL BE
*        UPDATED TO REFLECT THE CURRECT STATUS AND RECORDING OF
*        SPECIFIC DISPATCHER DATA WILL BE DONE IN THE SDWA RECORD AREA.
*
*02*     REGISTERS-SAVED = NONE
*
*02*     REGISTER-USAGE = REG 9 - LCCA ADDRESS , REGISTER 8 - CURRENT
*        ASCB ADDRESS, REGISTER 1 - SDWA ADDRESS, REGISTER 12 - BASE
*        REGISTER. ALL OTHER USAGE VARIES AT DIFFERENT POINTS
*        WITHIN THE MODULE.
*
*02*     REGISTERS-RESTORED = NONE OF THE REGISTERS EXCEPT REGISTER 1
*        RESTORED.  REGISTER 15 WILL CONTAIN THE RETURN ADDRESS UPON
*        RETURN TO IEAVESPR.
*
*01*  EXIT-NORMAL = IEAVERTN, RETURN ADDRESS IN IEAVESPR.
*
*02*     CONDITIONS = WHEN FUNCTION IS COMPLETE.
*
*02*     OUTPUT = SDWA RECORDING AREA UPDATED, READY QUEUES IN
*        DISPATCHABLE ORDER.
*
*02*     RETURN-CODES = NONE
*
*01*  EXIT-ERROR = NONE
*
*02*     RETURN-CODES = NONE
*
*01*  EXTERNAL-REFERENCES =
*        IEAVETCB - ADDRES OF TCB CONTROL BLOCK VERIFICATION RTN
*
*02*     ROUTINES =
*       IEAVESCR - SCHEDULE RECOVERY
*              REASON - VERIFY AND CORRECT ALL SRB QUEUES
*              LINKAGE - BRANCH AND LINK R14,R15
*       IEAVESRB - SRB CONTROL BLOCK VERIFICATION RTN
*              REASON - VERIFY CURRENT SRB IS A VALID SRB
*              LINKAGE - BRANCH AND LINK R14,R15
*       IEAVETCB - TCB CONTROL BLOCK VERIFICATION RTN
*              REASON - VERIFY CURRENT TCB IS VALID
*              LINKAGE BRANCH AND LINK VIA REGISTERS 14,15
*       IEAVEGAS - GENERAL ASCB CONTROL BLOCK VERIFICATION RTN
*              REASON - VERIFY ALL ASCBS ON READY QUEUE ARE VALID
*              LINKAGE - BRANCH AND LINK ON REGISTERS 14,15
*       IEAVEQV3 - QUEUE VERIFICATION ROUTINE FOR DOUBLE THREAD QUEUES
*              REASON - TO VERIFY AND CORRECT ASCB AND TCB READY
*              QUEUES.
*              LINKAGE - BRANCH AND LINK ON REGISTER 14,15
*       IEAVEMS0 - MEMORY SWITCH
*              REASON - TO CAUSE A SWITCH TO TOP OF READY QUEUE.
*              LINKAGE - BRANCH AND LINK ON REGISTERS 14,15
*       IEAVEEER - EXIT EFFECTOR RECOVERY RTN
*              REASON - TO VERIFY AND CORRECT THE EXIT EFFECTOR QUEUES.
*              LINKAGE - BRANCH AND LINK ON REGISTERS 14,15.
*       IEAVSPCR - COMMON SUSPEND ROUTINE
*              REASON - TO SUSPEND A SRB.
*              LINKAGE - BRANCH AND LINK REGISTERS 15,12
*
*02*     DATA-AREAS = SDWA DATA RECORDING AREA.
*
*02*     CONTROL-BLOCKS =
*              1. PSA - W/R
*              2. LCCA - W/R
*              3. PCCA - R
*              4. CVT - R
*              5. ASCB - W/R
*              6. ASXB - R
*              7. TCB - W/R
*              8. RB - R
*              9. SDWA - W/R
*             10. SRB - R
*             11. SSRB - W/R
*             12. IHSA - W/R
*             13. CSD - W/R
*             14. SPL - W/R
*             15. WSAVT - R
*
*01*  TABLES = WSACEDS0 - DISPATCHER'S REGISTER SAVE AREA.
*
*01*  MACROS =
*              1. SETLOCK - OBTAIN AND RELEASE AND TEST OF VARIOUS LKS
*              2. SCHEDULE - SCHEDULE SRB TO LOCAL QUEUE
*
*02*    SERIALIZATION =
*              1. GLOBAL DISPATCHER LOCK - SERIALIZE ON THE ASCB
*                 DISPATCHING QUEUE AND THE SPL QUEUES
*              2. LOCAL LOCK - SERIALIZE ON THE TCB DISPATCHING QUEUE
*
*01*  CHANGE-ACTIVITY = SUPPORT CODES - Y02715,Y02751,Y02752
*
*01*  MESSAGES = NONE
*
*01*  ABEND-CODES =
*
**** END OF SPECIFICATIONS ***/
*/*IEAVEDSR: CHART DISPATCHER RECOVERY */
*/* HEADER
*/*
*/*
*/*
*/*                                                  ID: 3.1.8.2
*/* DISPATCHER RECOVERY
*/*                                                  PAGE # */
*/*IEAVEDSR: E IEAVEDSR */
         TITLE 'IEAVEDSR - DISPATCHER RECOVERY'
IEAVEDSR CSECT
R0       EQU   0                   REGISTER 0
R1       EQU   1                   REGISTER 1
R2       EQU   2                   REGISTER 2
R3       EQU   3                   REGISTER 3
R4       EQU   4                   REGISTER 4
R5       EQU   5                   REGISTER 5
R6       EQU   6                   REGISTER 6
R7       EQU   7                   REGISTER 7
R8       EQU   8                   REGISTER 8
R9       EQU   9                   REGISTER 9
R10      EQU   10                  REGISTER 10
R11      EQU   11                  REGISTER 11
R12      EQU   12                  REGISTER 12
R13      EQU   13                  REGISTER 13
R14      EQU   14                  REGISTER 14
R15      EQU   15                  REGISTER 15
XFF      EQU   X'FF'               CONSTANT X'FF'
L3       EQU   3                   LENGTH 3
L4       EQU   4                   LENGTH 4
L8       EQU   8                   LENGTH 8
L12      EQU   12                  LENGTH 12
L16      EQU   16                  LENGTH 16
L20      EQU   20                  LENGTH 20
L24      EQU   24                  LENGTH 24
L26      EQU   26                  LENGTH 26
L72      EQU   72                  LENGTH 72
ZERO     EQU   0                   ZERO VALUE
CMSLLOFF EQU   3                   MASK FOR CMS & LOCAL LOCK BITS
FOUR     EQU   4
HEXL4    EQU   4                   LENGTH 4
D32      EQU   32                  DISPLACEMENT X'20'
         SPACE 2
*/* P ESTABLISH ADDRESSABILITY */
         SPACE 2
         BALR  R12,R0              ESTABLISH BASE
         USING *,R12
         USING SDWA,R1
         USING PSA,R0
DSRBASE  DC    0H'0'
         MODID BR=YES
         SPACE 2
*/* P RECORD IN SDWA THAT A DISPATCHER ERROR OCCURRED  */
         SPACE 2
         MVC   SDWAMODN,DISPNAME   INDICATE DISPATCHER MODULE
         MVC   SDWACSCT,DISPNAME   INDICATE DISPATCHER CSECT
         MVC   SDWAREXN,DISPRECY   INDICATE DISPATCHER RECOVERY
         OI    SDWADPVA,SDWAHEX    INDICATE HEX DATA
         L     R9,PSALCCAV         OBTAIN LCCA ADDRESS
         L     R8,PSAAOLD          OBTAIN ASCB ADDRESS
         USING LCCA,R9
         USING ASCB,R8
         LA    R2,L'PSAHLHI+L'LCCASPLJ+L'ASCBLOCK+L'PSATOLD+L'ASCBSTOR+-
               L'PSAAOLD+HEXL4     LENGTH OF DATA RECORDED
         SPACE 2
*/* P RECORD PSAHLHI, ASCBLOCK, LCCASPLJ VALUES */
         SPACE 2
         SR    R3,R3               ZERO REGISTER 3
         IC    R3,SDWAURAL         USER RECORDING LENGTH
         LA    R4,0(R2,R3)         UPDATE RECD AREA LENGTH
         STC   R4,SDWAURAL         SAVE NEW VALUE
         LA    R4,SDWAVRA          GET POINTER TO RCD AREA
         LA    R10,0(R3,R4)        LOCATE RECORD AREA
         L     R2,PSAHLHI          CPU LOCKS HELD AT ENTRY
         ST    R2,0(R10)           SAVE IN RECD AREA
         L     R2,ASCBLOCK         GET LOCAL LOCK VALUE
         ST    R2,L4(R10)          SAVE IN RECORDING AREA
         L     R2,LCCASPLJ         OBTAIN SPL JOURNAL WORD
         ST    R2,L8(R10)          SAVE IN RECORDING AREA
         SPACE 2
*/* P RECORD PSAAOLD, CR1, PSATOLD, DISP FLGS VALUES */
         SPACE 2
         L     R2,PSAAOLD          OBTAIN AOLD VALUE
         ST    R2,L12(R10)         SAVE IN RECORDING AREA
         STCTL R1,R1,L16(R10)      SAVE IN RECORDING AREA
         L     R2,PSATOLD          OBTAIN TOLD VALUE
         ST    R2,L20(R10)         SAVE IN RECORDING AREA
         LH    R2,LCCADSF1         OBTAIN DISPATCHER FLAGS
         STH   R2,L24(R10)          SAVE IN RECORDING AREA
         LR    R13,R0              SAVE WORK AREA ADDR
*                                                              @Z40FPXJ
*NOTE - THIS CODE IS TO SUPPORT TCTL RECOVERY                  @Z40FPXJ
*                                                              @Z40FPXJ
         SPACE 2                                               @Z40FPXJ
*/* D (YES,,NO,DSRTSTLK) IS TCTL ACTIVE ? */                   @Z40FPXJ
*/* D (YES,,NO,DSRETURN) IS TCB VALID ? */                     @Z40FPXJ
*/* P (,DSRETURN) TURN OFF TCBACTIV AND ZERO CDAL ENTRY */     @Z40FPXJ
         SPACE 2                                               @Z40FPXJ
         L     R2,PSACDAL          GET CDAL PTR                @Z40FPXJ
         L     R3,0(R2)            GET 1ST CDAL ENTRY          @Z40FPXJ
         LTR   R3,R3               IS TCTL ACTIVE ?            @Z40FPXJ
         BZ    DSRTSTLK            NO, CONTINUE WITH RECOV     @Z40FPXJ
         L     R0,PSATOLD          GET TCB ADDRESS             @Z40FPXJ
         L     R15,ATCBVRTN        GET CB VERIFY RTN ADDRESS   @Z40FPXJ
         BALR  R14,R15             CALL CB VERIFY RTN          @Z40FPXJ
         LTR   R15,R15             IS TCB VALID                @Z40FPXJ
         BNZ   DSRETURN            NO, EXIT TO CALLER          @Z40FPXJ
         LR    R3,R0               GET TCB ADDR IN REG 2       @Z40FPXJ
         NI    TCBXSCT1-TCB(R3),XFF-TCBACTIV TURN OFF ACTIVE   @Z40FPXJ
         SLR   R3,R3               ZERO REG 2                  @Z40FPXJ
         ST    R3,0(R2)            ZERO CDAL ENTRY             @Z40FPXJ
         B     DSRETURN            RETURN TO CALLER            @Z40FPXJ
         SPACE 2
*/*DSRTSTLK: D (NO,DSRLLRTN,YES,) WAS DISPATCHER LOCK HELD ? */
         SPACE 2
DSRTSTLK DS    0H                                              @Z40FPXJ
         SETLOCK TEST,TYPE=DISP,BRANCH=(NOTHELD,DSRLLRTN)
         L     R15,ASCHRECV        OBTAIN SCHEDULE RECOVERY RTN ADDR
         LR    R7,R12              SAVE BASE REG
         SPACE 2
*/* S IEAVESCR: INVOKE SCHEDULE RECOVERY FOR SRB QUEUES */
         SPACE 2
         BALR  R14,R15             CALL SCHEDULE RECOVERY RTN
         LR    R12,R7              RESTORE BASE REG
         LR    R13,R0              SAVE 72 BYTE SAVE AREA ADDR
         L     R0,LCCASPLJ         OBTAIN SPL JOURNAL WORD VALUE
         LTR   R0,R0               WAS DISPATCHER PROCESSING A SRB
         LR    R11,R1              SAVE SDWA ADDRESS
         SPACE 2
*/* D (NO,DSRASCBR,YES,) SRB BEING PROCESSED ? */
         SPACE 2
         BZ    DSRASCBR            NO PROCESS THE ASCB
         SPACE 2
*/* S IEAVESRB: VERIFY SRB CONTROL BLOCK */
         SPACE 2
         L     R15,ASCBVRTN        OBTAIN CONTROL BLK VERIFICATION RTN
         BALR  R14,R15             CALL CONTROL BLOCK VERIFICATION RTN
         SPACE 2
*/* D (NO,DSR0SPLJ,YES,) WAS THIS VALID SRB ? */
         SPACE 2
         LTR   R15,R15             WAS THIS A GOOD SRB?
         STH   R15,L26(R10)        SAVE THE RET CODE IN RECD AREA
         BNZ   DSR0SPLJ            CLEAR THE SPL JOURNAL WORD
         SPACE 2
*/* D (NO,DSRSRBSC,YES,) WAS LOCAL LOCK OWNED ? */
         SPACE 2
         L     R2,ASCBLOCK         OBTAIN VALUE IN LOCAL LOCK
         LH    R3,PSACPULA         OBTAIN CPU LOGICAL ID
         CR    R2,R3               WAS LOCAL LOCK OWNED BY THIS CPU?
         BNE   DSRSRBSC            NO LOCK, SCHEDULE SRB
         SPACE 2
*/* P PLACE SUSPEND ID IN LOCAL LOCK */
         SPACE 2
         L     R2,DSRSUPID         OBTAIN THE SUSPEND ID
         ST    R2,ASCBLOCK         PLACE SUSPEND ID IN LOCAL LK
         SPACE 2
*/*DSRSRBSC: P SCHEDULE SRB AT LOCAL LEVEL */
         SPACE 2
DSRSRBSC EQU   *
         L     R1,LCCASPLJ         SRB ADDR IN REG 1
         SCHEDULE SRB=(1),SCOPE=LOCAL
         SPACE 2
*/*DSR0SPLJ: P ZERO OUT SRB JOURNAL WORD */
         SPACE 2
DSR0SPLJ EQU   *
         LA    R1,ZERO             ZERO REGISTER 1
         ST    R1,LCCASPLJ         ZERO OUT SPL JOURNAL WORD
         SPACE 2
*/*DSRASCBR: S IEAVEMS0: ZERO PSAANEW IN CASE ASCB REMOVED */
         SPACE 2
DSRASCBR EQU   *
         LA    R1,ZERO             ZERO REGISTER 1 FOR MEMORY SW
         L     R15,AMEMSW          OBTAIN MEMORY SWITCH ADDRESS
         BALR  R14,R15             CALL MEMORY SWITCH TO ZERO ANEWS
         LR    R0,R11              SET R0 TO SDWA ADDRESS
         LA    R1,L72(R13)         SET UP QVPL ADDRESS
         USING QVPL,R1
         SPACE 2
*/* P SET UP QVPL FOR ASCB C.B. VERIFICATION */
         SPACE 2
         XC    0(QVPLSIZE,R1),0(R1)  ZERO OUT QVPL
         LA    R3,DSRCBVR          ADDR OF ASCB CB VERIFICATION RTN
         ST    R3,QVPLEVR          PLACE IN QVPL
         LA    R3,QVPLSIZE(R1)     ADDR OF WORK AREA
         ST    R3,QVPLWKA          PLACE IN QVPL
         LA    R3,SDWARA-SDWA(R11)    GET OUTPUT DATA AREA ADDR
         ST    R3,QVPLODA          PLACE IN QVPL
         LA    R3,ASCBFWDP-ASCB    OFFSET OF FORWARD PTR
         STH   R3,QVPLFPTR         PLACE IN QVPL
         L     R4,CVTPTR           LOCATE CVT
         USING CVT,R4
         LA    R3,CVTASCBH         GET HEADER VALUE
         ST    R3,QVPLHDR          STORE IN QVPL
         LA    R3,CVTASCBL         GET TRAILER VALUE
         ST    R3,QVPLTRLR         STORE IN QVPL
         LA    R3,ASCBBWDP-ASCB    OFFSET OF BACKWARD PTR
         STH   R3,QVPLBPTR         STORE IN QVPL
         LA    R3,ZERO             ZERO REG 3
         IC    R3,SDWAURAL-SDWA(R11) LOCATE USERS DATA LENGTH
         LA    R10,SDWAVRA-SDWA(R11) LOCATE REC DATA AREA
         LA    R10,0(R3,R10)       LOCATE QV'S DATA AREA
         SPACE 2
*/* S IEAVEQV3: VERIFY ASCB READY QUEUE */
         SPACE 2
         L     R15,AQV3EP          ADDRESS OF QUEUE VERIFICATION RTN
         BALR  R14,R15             CALL QUEUE VERIFICATION
         LR    R1,R11              RESTORE SDWA ADDR IN R1
*NOTE - IEAVEDSR IS DEPENDENT ON SUPER RECOVERY RTN FREEING ALL LOCKS
         SPACE 2
*/*DSRCPUXX: P CLEAN UP CPU */
         SPACE 2
DSRCPUXX EQU   *
         L     R2,PSAPCCAV         OBTAIN PCCA ADDR
         USING PCCA,R2             PCCA ADDRESSABILITY
         SPACE 2
*/* D (NO,DSRCPUX1,YES,) DOES CPU HAVE GOOD CPU TIMER ? */
         SPACE 2
         TM    PCCAINTE,PCCANUIN   IS THE TIMER OKAY?
         BO    DSRCPUX1            NO, BYPASS TIMER SETTING
         SPACE 2
*/* P SET CPU TIMER TO HIGH VALUE */
         SPACE 2
         SPT   CPUHITIM            SET CPU TIMER TO HI VALUE
         SPACE 2
*/*DSRCPUX1: P TURN OFF SRB INDICATOR, ZERO PSATOLD */
         SPACE 2
DSRCPUX1 EQU   *
         NI    LCCADSF2,XFF-LCCASRBM-LCCAGSRB   TURN OFF SRB INDICATOR
         LA    R2,ZERO             ZERO REGISTER 2
         ST    R2,PSATOLD          ZERO OUT TOLD TO AVOID STATUS SAVE
         ST    R2,PSATNEW          ZERO OUT TNEW
         ST    R2,LCCAITOD         ZERO OUT ITOD
         SPACE 2
*/* P ZERO PSATNEW, CLEAR LOCK INDICATORS */
         SPACE 2
         NI    PSAHLHI+L3,XFF-CMSLLOFF TURN OFF CMS/LOCAL LOCK @ZA11858
         SPACE 2
*/*DSRETURN R RETURN TO IEAVESPR */
         SPACE 2
DSRETURN DS    0H                                              @Z40FPXJ
         L     R15,ASUPRTNP        RESTORE CALLERS RETURN ADDR
         BR    R15                 RETURN TO SUPER RECOVERY ROUTINE
         EJECT
         SPACE 2
*/*DSRCBVR: P CALLED BY QUEUE VERIFIER */
         SPACE 2
         SPACE 2
*/* P SAVE QUEUE VERIFIER'S REGISTERS */
         SPACE 2
DSRCBVR  DC    0H'0'
         L     R2,PSALCCAV         OBTAIN ADDR OF LCCA
         L     R3,LCCACPUS-LCCA(R2) OBTAIN DISP CPU RELATED SAVE AREA
         L     R4,WSACEDS0-WSAC(R3) ADDR OF DISPATCHER SAVE AREA
         STM   R8,R14,D32(R4)      SAVE QUEUE VERIFIER'S REGS 8-14
         SPACE 2
*/* P ESTABLISH ADDRESSABILITY */
         SPACE 2
         BALR  R12,R0              ESTABLISH ADDRESSABILITY
         USING *,R12
         L     R12,DSRBASEA        OBTAIN OLD BASE ADDR
         USING DSRBASE,R12
         LR    R9,R4               SAVE R4 FOR CALL TO CONT BLK VERFY
         SPACE 2
*/* S IEAVEGAS: VERIFY EACH ASCB */
         SPACE 2
         L     R15,AASCBCBR        ADDRESS OF GENERAL ASCB C.B. VERIFY
         BALR  R14,R15             CALL CONTROL BLOCK VERIFICATION RTN
         SPACE 2
*/* D (NO,DSRBYNOQ,YES,) VALID ASCB WITH INVALID DATA ? */
         SPACE 2
         C     R15,DSRFOUR         WAS RETURN CODE FOUR - VALID ASCB
*                                  WITH INVALID DATA
         BH    DSRBYNOQ            NOT R.C. 4 - DON'T MARK AS NOT ON Q
         LR    R6,R0               OBTAIN ADDRESS OF ASCB CB
         BE    DSRSTNOQ            R.C. 4 SET NOT ON Q
         TM    ASCBDSP1-ASCB(R6),ASCBNOQ IS ASCB MARKED NOT ON Q
         BNO   DSRBYNOQ            EVERYTHING IS OKAY
         LA    R15,FOUR            INDICATE TO TAKE OFF Q
         B     DSRBYNOQ            RETURN
         SPACE 2
*/*DSRSTNOQ: P MARK ASCB AS NOT ON QUEUE */
         SPACE 2
DSRSTNOQ EQU   *
         OI    ASCBDSP1-ASCB(R6),ASCBNOQ INDICATE ASCB NOT ON Q
         SPACE 2
*/*DSRBYNOQ: R RETURN TO QUEUE VERIFIER */
         SPACE 2
DSRBYNOQ DC    0H'0'
         LM    R8,R14,D32(R9)      RESTORE REGS 8-14 FOR RETURN
*                                  TO QUEUE VERIFICATION ROUTINE
         BR    R14                 RETURN TO QUEUE VERIFICATION
         EJECT
***********************************************************************
*         THE FOLLOWING ROUTINE IS ENTERED IF THE DISPATCHER LOCK IS  *
*         NOT HELD.  THIS ROUTINE CHECKS THE STATUS OF THE LOCAL LOCK *
*         AND DETERMINES WHAT STATUS SAVING SHOULD BE PERFORMED       *
*         THE STAGE 3 EXIT EFFECTOR RECOVERY ROUTINE IS CALLED AND    *
*         THE TCB QUEUE MAY BE VERIFIED.                           *
***********************************************************************
         SPACE 2
*/*DSRLLRTN: D (NO,DSRLLRT1,YES,) DID DISPATCHER OWN LOCAL LOCK */
         SPACE 2
DSRLLRTN EQU   *
         TM    LCCADSF2,LCCADSPL   DID THE DISP OBTAIN THE LL
         BZ    DSRLLRT1            LOCAL LOCK WASN'T OBTAINED BY DISP
         SPACE 2
*/* D (YES,DSRLLRTR,NO,) WAS THIS A DAT ERROR ? */
         SPACE 2
         LH    R2,SDWAFMID-SDWA(R1) OBTAIN DAT ERROR INDICATOR
         LTR   R2,R2               WAS THIS A DAT ERROR?
         BNZ   DSRLLRTR            DAT ERROR WAS TAKEN
         SPACE 2
*/* D (NO,DSRLLRTR,YES,) CR1 MATCH ASCBSTOR ? */
         SPACE 2
         CLC   ASCBSTOR,L16(R10)   WAS WAS CONTROL REGISTER 1 GOOD?
         BNE   DSRLLRTR            GO RELEASE LOCAL LOCK
         SPACE 2
*/* S DSRTCBSS: SAVE STATUS IN TCB */
         SPACE 2
         BAL   R11,DSRTCBSS        CALL COMMON STATUS SAVING RTN
         SPACE 2
*/*DSRLLRTS: D (NO,DSRLLRTT,YES,) DOES EXIT EFFECTOR HAVE READY WORK */
         SPACE 2
DSRLLRTS EQU   *
         TM    ASCBFLG1,ASCBS3S    DOES EXIT EFFECTOR HAVE READY WRK
         BNO   DSRLLRTT            NO, BYPASS EXIT EFFECTOR RECY RTN
         LR    R0,R13              72 BYTE SAVE AREA
         SPACE 2
*/* S IEAVEEER: EXIT EFFECTOR RECOVERY */
         SPACE 2
         L     R15,AS3EEQVR        ADDR OF S3EE RECOVERY RTN
         LR    R7,R12              SAVE BASE REG
         BALR  R14,R15             CALL S3EE RECOVERY ROUTINE
         LR    R12,R7              RESTORE BASE REG
         LR    R13,R0              RESTORE SAVE AREA ADDR
         SPACE 2
*/*DSRLLRTT: P SET UP QVPL FOR TCB QUEUE VERIFICATION */
         SPACE 2
DSRLLRTT EQU   *
         LR    R0,R1               SAVE SDWA ADDR
         LA    R1,L72(R13)         SET UP QVPL ADDRESS
         USING QVPL,R1
         XC    0(QVPLSIZE,R1),0(R1)  ZERO OUT QVPL
         L     R3,ATCBVRTN         ADDR OF TCB CB VERIFICATION RTN
         ST    R3,QVPLEVR          PLACE IN QVPL
         LA    R3,QVPLSIZE(R1)     ADDR OF WORK AREA
         ST    R3,QVPLWKA          PLACE IN QVPL
         LR    R3,R0               GET OUTPUT DATA AREA ADDR
         LA    R3,SDWARA-SDWA(R3) OUTPUT DATA AREA ADDR
         ST    R3,QVPLODA          PLACE IN QVPL
         LA    R3,TCBTCB-TCB       OFFSET OF FORWARD PTR
         STH   R3,QVPLFPTR         PLACE IN QVPL
         L     R4,ASCBASXB         LOCATE THE ASXB
         USING ASXB,R4
         LA    R3,ASXBFTCB         GET HEADER VALUE
         ST    R3,QVPLHDR          STORE IN QVPL
         LA    R3,ASXBLTCB         GET TRAILER ADDR
         ST    R3,QVPLTRLR         STORE IN QVPL
         LA    R3,TCBBACK-TCB      OFFSET OF BACKWARD PTR
         STH   R3,QVPLBPTR         STORE IN QVPL
         SPACE 2
*/* S IEAVEQV3: VERIFY TCB READY QUEUE */
         SPACE 2
         L     R15,AQV3EP          QUEUE VERIFICATION ROUTINE
         BALR  R14,R15             CALL QUEUE VERIFICATION RTN
         LR    R1,R0               RESTORE SDWA ADDR
         SPACE 2
*/*DSRLLRTR: S IEAVELK: LLREL - RELEASE LOCAL LOCK */
         SPACE 2
DSRLLRTR EQU   *
         LR    R15,R12             SAVE BASE REGISTER
         SETLOCK RELEASE,TYPE=LOCAL,RELATED=('TCB READY QUEUE',IEAVEDS0-
               ,(DSLOCK))
         NI    LCCADSF2,XFF-LCCADSPL TURN OFF DISP OBTAINED LL BIT
         LR    R12,R15             RESTORE BASE REGISTER
         SPACE 2
*/* P (,DSRCPUXX) CLEAN UP CPU */
         SPACE 2
         B     DSRCPUXX            RETURN TO CPU CLEAN UP
         EJECT
**********************************************************************
*         ROUTINE ENTERED IF DISPATCHER DIDN'T OBTAIN THE LOCAL LOCK *
**********************************************************************
         SPACE 2
*/*DSRLLRT1: D (NO,DSRCPUXX,YES,) CR1 MATCH ASCBSTOR ? */
         SPACE 2
DSRLLRT1 EQU   *
         CLC   ASCBSTOR,L16(R10)   WAS WAS CONTROL REGISTER 1 GOOD?
         BNE   DSRCPUXX            CONTROL REG1 NOT AOLD'S AVOID
*                                  LOCAL MEMORY USAGE
         SPACE 2
*/* D (YES,DSRCPUXX,NO,) WAS THIS A DAT ERROR ? */
         SPACE 2
         LH    R3,SDWAFMID-SDWA(R1) WAS THIS A DAT ERROR?
         LTR   R3,R3               DAT ERROR?
         BNZ   DSRCPUXX            YES, CLEAN UP CPU
         SPACE 2
*/* D (YES,DSRLLSUS,NO,) WAS CPUID IN LOCAL LOCK ? */
         SPACE 2
         LH    R2,PSACPULA         OBTAIN LOGICAL CPU ID
         C     R2,ASCBLOCK         WAS CPUID IN LOCAL LOCK?
         BE    DSRLLSUS            YES, SUSPEND IT
         SPACE 2
*/* D (YES,DSRCPUXX,NO,) WAS SUSPEND ID IN LOCAL LOCK ? */
         SPACE 2
         CLC   ASCBLOCK,DSRSUPID   WAS SUSPEND ID IN LOCAL LOCK?
         BE    DSRCPUXX            YES, CLEAN UP CPU
         SPACE 2
*/* D (YES,DSRCPUXX,NO,) WAS INTERRUPT ID IN LOCAL LOCK ? */
         SPACE 2
         CLC   ASCBLOCK,DSRINTID   WAS INTERRUPT ID IN LOCAL LOCK?
         BE    DSRCPUXX            YES, CLEAN UP CPU
         SPACE 2
*/* D (YES,DSRCPUXX,NO,) WAS STATUS ALREADY SAVED ? */
         SPACE 2
         L     R3,PSATOLD          OBTAIN TCB ADDR
         LTR   R3,R3               WAS VALUE ZERO?
         BZ    DSRCPUXX            YES, CLEAN UP CPU
         SPACE 2
*/* S DSRTCBSS: SAVE TCB STATUS */
         SPACE 2
         BAL   R11,DSRTCBSS        CALL TCB SAVE STATUS RTN
         SPACE 2
*/* P (,DSRCPUXX) CLEAN UP THE CPU */
         SPACE 2
         B     DSRCPUXX            RETURN TO CLEAN UP CPU
**********************************************************************
*         THIS ROUTINE WILL INVOKE COMMON SUSPEND ROUTINE IF REQUIRED *
*         AND PLACE THE INTERRUPT ID IN THE LOCAL LOCK.              *
**********************************************************************
         SPACE 2
*/*DSRLLSUS: D (YES,DSRLLINT,NO,) HAD STATUS BEEN SAVED ? */
         SPACE 2
DSRLLSUS EQU   *
         SETLOCK TEST,TYPE=LOCAL,BRANCH=(NOTHELD,DSRLLINT)
         TM    LCCADSF2,LCCASRBM   IS THIS A SRB
         BO    DSRCPUXX            CLEAN UP CPU
         SPACE 2
*/* P SAVE REGISTERS FOR COMMON SUSPEND RTN CALL */
         SPACE 2
         STM   R0,R15,0(R13)       SAVE REGISTERS
         L     R7,PSALCCAV         OBTAIN LCCA ADDR
         LA    R1,ZERO             INDICATE NON-SRB
         SPACE 2
*/* S IEAVSPCR: SAVE STATUS IN IHSA */
         SPACE 2
         L     R12,ASPCRTN         OBTAIN ADDR OF COMMON SUSPEND RTN
         BALR  R15,R12             GO SUSPEND SRB OR LL TCB
         LM    R0,R15,0(R13)       RESTORE REGS
         SPACE 2
*/*DSRLLINT: P (,DSRCPUXX) PLACE INTERRUPT ID IN LOCAL LOCK */
         SPACE 2
DSRLLINT EQU   *
         L     R2,DSRINTID         OBTAIN INTERRUPT ID
         ST    R2,ASCBLOCK         STORE INTO LOCAL LOCK
         B     DSRCPUXX            GO CLEAN UP CPU
         EJECT
**********************************************************************
*         THIS ROUTINE WILL SAVE STATUS IN TCB IF ITS VALID          *
**********************************************************************
         SPACE 2
*/*DSRTCBSS: S IEAVETCB: VERIFY TCB IS VALID */
         SPACE 2
DSRTCBSS EQU   *
         L     R0,PSATOLD          OBTAIN TCB ADDRESS
         L     R15,ATCBVRTN        OBTAIN ADDRESS OF CONTROL BLOCK
*                                  VERIFICATION ROUTINE
         BALR  R14,R15             CALL CONTROL BLOCK VERIFIER FOR TCB
         LTR   R15,R15             WAS CONTROL BLOCK GOOD?
         SPACE 2
*/* D (NO,DSRTCBOT,YES,) WAS TCB VALID ? */
         SPACE 2
         BNZ   DSRTCBOT            TCB IS INVALID
         L     R2,DSRPREFX         OBTAIN PREFIX VALUE
         AR    R2,R0               ADD TO TCB ADDRESS
         USING TCBFIX,R2
         SPACE 2
*/* P SAVE FLOATING POINT REGISTERS */
         SPACE 2
         STD   R0,TCBFRS0          STORE FLOATING POINT REGISTERS
         STD   R2,TCBFRS2          STORE FLOATING POINT REGISTERS
         STD   R4,TCBFRS4          STORE FLOATING POINT REGISTERS
         STD   R6,TCBFRS6          STORE FLOATING POINT REGISTERS
         L     R3,PSATOLD          OBTAIN TCB ADDRESS
         USING TCB,R3
         SPACE 2
*/* P TURN OFF TCB ACTIVE AND ZERO CPUID */
         SPACE 2
         NI    TCBXSCT1,XFF-TCBACTIV  TURN OFF TCB ACTIVE BIT  @Z40FPXJ
         LA    R2,ZERO             ZERO TCB
         STH   R2,TCBCCPVI         CLEAR CPUID
         L     R3,ASCBCPUS         OBTAIN CPU COUNT
         SPACE 2
*/* D (YES,DSRTCBOT,NO,) WAS CPU COUNT ZERO ? */
         SPACE 2
         LTR   R3,R3               WAS COUNT DECREMENTED?
         BZ    DSRTCBOT            YES EXIT
         SPACE 2
*/*DSCSLOOP: P DECREMENT CPUS COUNT */
         SPACE 2
DSCSLOOP EQU   *
         LR    R2,R3               DUPLICATE COUNT
         BCTR  R2,R0               DECREMENT COUNT BY 1
         CS    R3,R2,ASCBCPUS      UPDATE CPUS COUNT
         BNZ   DSCSLOOP            REPEAT VALUE HAS CHANGED
         SPACE 2
*/*DSRTCBOT: R RETURN BR R11 */
         SPACE 2
DSRTCBOT EQU   *
         BR    R11                 RETURN TO CALLER
*/* FOOTING
*/*
*/*  */
*/*IEAVEDSR: END DISPATCHER RECOVERY */
         EJECT
***********************************************************************
*         CONSTANTS & ADDRESSES                                    *
***********************************************************************
         DS    0D
CPUHITIM DC    X'7FFFFFFFFFFFFFFF' HI CPU TIME VALUE
DISPNAME DC    C'IEAVEDS0'         DISPATCHER MAINLINE ROUTINE
DISPRECY DC    C'IEAVEDSR'         DISPATCHER RECOVERY ROUTINE
DSRBASEA DC    A(DSRBASE)          ADDRESS OF BASE REG VALUE
DSRFOUR  DC    F'4'                RETURN CODE FOUR CHECK
ASUPRTNP DC    V(IEAVERTN)         RETURN ADDR OF CALLER
ASCHRECV DC    V(IEAVESCR)         SCHEDULE RECOVERY ROUTINE
ASCBVRTN DC    V(IEAVESRB)         SRB CONTROL BLOCK VERIFICATION RTN
ATCBVRTN DC    V(IEAVETCB)         TCB CONTROL BLOCK VERIFICATION RTN
AASCBCBR DC    V(IEAVEGAS)         ASCB CB VERIFICATION ROUTINE
AMEMSW   DC    V(IEAVEMS0)         ADDR OF MEMORY SWITCH RTN
ASPCRTN  DC    V(IEAVSPCR)         COMMON SUSPEND ROUTINE
AQV3EP   DC    V(IEAVEQV3)         ADDR OF QUEUE VERIFIER RTN
DSRPREFX DC    A(-(TCB-TCBFRS))    TCB PREFIX DECREMENT VALUE
AS3EEQVR DC    V(IEAVEEER)         ADDR OF EXIT EFFECTOR RECOVERY RTN
DSRSUPID DC    X'7FFFFFFF'         SUSPEND ID
DSRINTID DC    X'FFFFFFFF'         INTERRUPT ID
         IHAASCB
         IHAASXB
         IHASRB
         IHALCCA
         IHAQVPL
         IHAPSA
         IHASDWA
         IHAQVOD
         IHAPCCA
         IHAWSAVT  CLASS=CPU,DSECT=YES
         IKJTCB
         CVT   DSECT=YES,LIST=NO
         END   IEAVEDSR
