           TITLE   'IEAVELKR-SETLOCK REPAIR ROUTINE'
* /* START OF SPECIFICATIONS ****
*        MODULE NAME=
*                  IEAVELKR
*             CSECT NAME=
*                  IEAVELKR
*        DESCRIPTIVE NAME=   SETLOCK REPAIR ROUTINE-FRR ROUTINE
*
*        COPYRIGHT=     NONE
*
*        STATUS=   VERSION 1
*
*        FUNCTION=
*             THE SETLOCK REPAIR ROUTINE CORRELATES THE LOCKING
*             HIERARCHY MASK TO THE LOCKWORDS AND WITH THE ASSUMP-
*             TION THAT A DOUBLE ERROR HAS NOT OCCURRED(I.E. THE
*             LOCKWORD AND THE HIERARCHY MASK ARE BOTH NOT INVALID),
*             WILL ASSURE THAT A VALID HIERARCHY MASK, AND MATCHED
*             AGAINST THE LOCKWORDS, DOES EXIST. IF AN INVALID STATE
*             IS DETECTED, THERE ARE CASES WHERE THE HIERARCHY MASK
*             WILL BE ALTERED WHILE IN OTHERS A LOCKWORD MAY BE COR-
*             RECTED. IN CERTAIN EXTREME CASES A LOCK WILL BE STOLEN
*             IN ORDER TO ALLOW THE SYSTEM TO CONTINUE. THE CMS LOCK
*             WILL BE STOLEN IF EITHER A DAT ERROR OCCURRES WHILE THE
*             CMS LOCK OWNER IS SUSPENDED, OR A RESTART INTERRUPT
*             OCCURRES WHILE THE CMS LOCK OWNER IS SUSPENDED AND THE
*             SYSTEM IS IN A WAIT SITUATION. IN CERTAIN CASES, A LOCK
*             WILL NOT BE CORRECTED EVEN THOUGH AN INVALID VALUE MAY
*             BE IN THE LOCK. IN THIS CASE RATHER THAN STEALING A
*             RESOURCE AWAY FROM A POSSIBLE OWNER, THE LOCK WILL
*             NO LONGER BE AVAILABLE FOR USE UNTIL ALL CPUS INVOLVED
*             ARE WAITING(OR SPINNING) ON THE LOCKWORD. AT THIS TIME
*             DEPRESSING THE RESTART KEY IS AN APPROPRIATE ACTION
*             WHICH ENABLES THIS ROUTINE TO CLEAR THE UNAVAILABLE
*             LOCK. IF SETLOCK WAS IN CONTROL AT TIME OF ERROR, THIS
*             ROUTINE WILL DO A SETFRR TO ESTABLISH A RECOVERY ROUTINE
*             FOR SETLOCK TO FREE ITS OWN RESOURCES.
*
*             THE SETLOCK FRR ROUTINE WILL WITH 2 EXCEPTIONS ALWAYS
*             INDICATE CONTINUE WITH RECOVERY IF IT IS ENTERED. IT
*             WILL DETERMINE IF LOCKS WERE DYNAMICALLY OBTAINED FOR
*             SETLOCK PURPOSES AND IF SO INDICATE THE FREEING OF THOSE
*             LOCKS. IT WILL CORRECT ITS SUSPEND QUEUES, IF THEY WERE
*             IN THE PROCESS OF BEING UPDATED. IT WILL REMOVE ALL
*             ELEMENTS FROM ITS CMS LOCK SUSPEND QUEUE AND ITS LOCAL
*                                                              @Z40FPXJ
*             LOCK SUSPEND QUEUE. IT WILL CLEAR ALL INDICATORS
*                                                              @Z40FPXJ
*             THAT MAY HAVE BEEN SET IN THE MAINLINE. THE 2 EXCEPTION
*             CASES ARE: 1. IF A RESTART INTERRUPTION OCCURRES DURING
*             A VALID SETLOCK SPIN,THIS ROUTINE WILL INDICATE VAL SPIN
*                                                              @Z40FPXJ
*             AND INDICATE TO RTM THE VALUE OF THE LOCKWORD IT IS
*             SPINNING ON.
*             2. IF NO LOCKS ARE HELD, NO SUPER BITS ARE ON,   @ZA27996
*             AND SYSTEM IS NOT IN TCB OR SRB MODE,            @ZA27996
*             RETRY WILL BE DONE AT IEA0DS.                    @ZA27996
*
*        OPERATION= SEE FUNCTION
*
*
*             DEPENDENCIES=
*                  RTM:
*                  1. REGISTER INPUT THE SAME AS AT ENTRY TO RTM1.
*                  2. SETLOCK'S FRR MUST ALWAYS RECEIVE CONTROL IF
*                     IT IS ON THE RECOVERY STACK.
*                  3. RTM MUST NOT DEPEND ON ANY LOCKS THAT MAY HAVE
*                     BEEN INDICATED AS HELD ON ENTRY TO THIS ROUTINE.
*                  4. IF A DAT ERROR HAS OCCURRED, RTM CAN NOT DEPEND
*                     ON ANY FURTHER DISPATCHING IN THE CURRENT MEMORY.
*                  SETLOCK:
*                  1. DEPENDENT ON THE VS2/2 IMPLMENTATION OF SETLOCK.
*                  ASVT RECONSTRUCT(IEAVEVRR):
*                  1. NO SETRPS MAY BE ISSUED.
*                  2. REGISTER 1 MUST BE PRESERVED.
*
*             CHARACTER CODE DEPENDENCIES=
*                  MUST BE REASSEMBLED IF CHARACTER SET OTHER THAN
*                  EBCIDC.
*
*             RESTRICTIONS=
*                  NONE
*
*             REGISTER CONVENTIONS=
*                  REFERENCE EQUATE SECTION OF MODULE
*
*        MODULE TYPE=   PROCEDURE
*
*        PROCESSOR=     ASSEMBLER
*
*        MODULE SIZE=
*             REFERENCE ESD LENGTH AT BEGINNING OF MODULE.
*
*        ATTRIBUTES=
*             NUCLEUS
*             ZERO PROTECT KEY
*             DISABLED
*             REFRESHABLE
*             SUPERVISOR MODE
*             ANY LOCKS HELD(OR NO LOCKS)
*
*        ENTRY POINT=
*             IEAVELKR
*
*             PURPOSE=
*                  TO VERIFY AND RECONSTRUCT LOCKS,LOCK TABLE, AND
*                  HIERARCHY MASK. ALSO TO SETFRR IF NECESSARY.
*
*             LINKAGE=
*                  SEE INPUT SECTION BELOW.
*
*             INPUT=
*                  ENVIRONMENT=
*                            SEE ATTRIBUTES
*                  DATA=
*                       ALL SYSTEM LOCKWORDS
*                       CPU LOCKS HELD TABLE
*                       LOCKS HIERARCHY MASK
*                       ERROR INFORMATION AS DEFINED BY RTM'S REGISTERS
*                  REGISTERS=
*                       13-ADDRESS OF RTM'S SAVED REGISTERS
*                       15-ENTRY POINT REGISTER
*                       ALL OTHERS IRRELEVANT
*                       THE FOLLOWING ARE RTM'S SAVED REGISTERS:
*                       0-TYPE OF ENTRY(=2 IF RESTART,=4 IF DAT ERROR)
*                       1-COMPLETION CODE(IN MID 12 BITS)
*                       2- ADDRESS OF ERROR PSW
*                       3-ADDRESS OF ILC AND INTERRUPT CODE
*                       5-ADDRESS OF VARIABLE INFORMATION(ERROR
*                         DEPENDENT)
*                       13-ADDRESS OF REGISTERS AT TIME OF ERROR
*                       14-RETURN ADDRESS
*                       15-ENTRY POINT ADDRESS
*
*             OUTPUT=
*                  SEE EXIT-NORMAL
*
*        EXIT-NORMAL=
*             ASVT VERIFICATION ROUTINE(IEAVEVRR)
*
*             CONDITIONS=
*                  EXIT IS ALWAYS TO IEAVEVRR
*
*             OUTPUT=
*                  DATA=
*                       THE CORRELATION BETWEEN THE HIERARCHY MASK
*                       AND THE LOCKWORDS ARE CORRECT OR HAVE BEEN
*                       CORRECTED. IN THE CASE OF A DAT ERROR OR
*                       RESTART INTERRUPT THE CMS LOCK MAY HAVE BEEN
*                       STOLEN FROM ITS OWNER. IN THE CASE OF A
*                       RESTART INTERRUPT ALL SPIN LOCKWORDS HAVE
*                       VALID VALUES IN THEM.
*                       ALSO IF SETFRR HAS BEEN DONE THE HIGH ORDER BIT
*                       OF THE FIRST WORD OF THE FRR WORK AREA WILL BE
*                       SET ON.
*
*                  REGISTERS=
*                       1-FRR PARM REGISTER(IF 0 NO SETFRR DONE,
*                                           IF NON-0 THEN IS THE AD-
*                                           DRESS OF THE FRR WORK AREA)
*                       13-ADDRESS OF RTM'S SAVED REGISTERS
*                       15-ENTRY POINT OF IEAVEVRR
*
*             RETURN CODES=
*                  NONE
*
*        ENTRY POINT=
*             IEAVLKRR(INTERNAL ENTRY)
*
*             PURPOSE=
*                  THIS IS THE REPAIR ROUTINE FRR. IT WILL DETERMINE IF
*                  SETLOCK RECOVERY IS TO BE INITIATED IF SO IT WILL
*                  DETERMINE IF IN A VALID SPIN, A RETRYABLE SITUATION
*                  OR A PERCOLATION CONDITION.SETLOCK SUSPEND QUEUES
*                  ARE ALSO CLEARED IN MANY CASES.
*                  IN ADDITION TO THIS IT WILL DETERMINE IF THE
*                  ASVT RECONSTRUCT ROUTINE
*                  IS TO BE GIVEN CONTROL AND IF SO GO THERE.
*
*             LINKAGE=
*                  SEE INPUT SECTION BELOW
*             INPUT=
*                  ENVIRONMENT=
*                       SEE ATTRIBUTES
*                  DATA=
*                       SETLOCK INDICATORS-LCCALOCK,LCCALKDP,LCCALKSA,
*                                          LCCALKAQ,PSALOCK.
*                       SETLOCK TABLE OF LOCKWORD ADDRESS(ADDRESSES
*                       OF THE LOCKWORD ADDRESSES).
*                       SETLOCK SUSPEND QUEUES AND HEADER AND TRAILER
*                       ADDRESSES.
*                       SDWA CONTROL BLOCK INFORMATION.
*                  REGISTERS=
*                       1-ADDRESS OF SDWA
*                       14-RETURN ADDRESS
*                       15-ENTRY POINT ADDRESS
*             OUTPUT=
*                  SEE EXIT-NORMAL BELOW
*
*        EXIT-NORMAL=
*             BACK TO CALLER(VIA BR 14)
*
*             CONDITIONS=
*                  EXIT IS ALWAYS VIA BR 14
*
*             OUTPUT=
*                  DATA=
*                       FOR ALL CASES EXCEPT FOR A VALID SPIN CONDITION
*                       ALL SUSPEND QUEUES WILL BE CLEARED,    @Z40FPXJ
*                       ALL INTERNAL INDICATORS CLEARED, AND   @Z40FPXJ
*                       ANY SELF-OBTAINED LOCKS ARE FREED.     @Z40FPXJ
*                       IN THE VARIABLE RECORDING AREA WILL BE PLACED
*                       THE ACRONYM C'RRRA' AND THE FIRST WORD OF THE
*                       RRRA(FRR WORK AREA) WHICH MAPS AS FOLLOWS:
*                       BIT0=1 MEANS SETLOCK WAS ENTERED, BIT1=1 MEANS
*                       ASVT RECONSTRUCT WAS ENTERED
*                  REGISTERS=
*                       1-ADDRESS OF SDWA
*                       14-RETURN ADDRESS
*
*             RETURN CODES=
*                  NONE
*
*        EXIT-ERROR=
*             NONE
*
*        EXTERNAL REFERENCES=
*
*             ROUTINES=
*                  SETFRR ADD-INLINE MACRO EXPANSION. THE FRR THAT
*                             IS ADDED MUST ALWAYS RECEIVE CONTROL.
*                             ONLY THE WORKREGISTERS SPECIFIED ARE
*                             DESTROYED ACROSS THE MACRO CALL.
*                  SETFRR DELETE- DONE TO DELETE FRR IF IN VALID SPIN.
*                  SETLOCK RELEASE,TYPE=CMS-THE MACRO SETS UP ALL
*                       REQUIRED REGISTERS. REGISTERS 11-14 ARE DE-
*                       STROYED UPON RETURN. THE ENVIRONMENT RE-
*                       MAINS UNCHANGED.
*                  SETRP-INLINE MACRO EXPANSION. REGISTER 1 CONTAINS
*                       THE SDWA AS INPUT. NO REGISTERS ARE DESTROYED.
*                  SETLOCK WINDOW SPIN ROUTINE(IEAVELKW)=
*                       INPUTS=
*                            REGISTERS=     6    ENTRY ADDRESS
*                                           7    RETURN ADDRESS
*                                           8    LCCA ADDRESS
*                                           11   LOCK ADDRESS
*                                           12   DISP HIERARY MASK
*                       OUTPUTS=
*                            REGISTERS=     5-10 DESTROYED
*                  MEMTERM=
*                       INPUTS=
*                            REGISTERS=     1  COMPLETION CODE
*                                           13 SAVE AREA ADDRESS
*                       OUTPUTS= NONE
*
*
*
*
*             DATA AREA=
*                  SEE INPUTS SECTION
*
*             CONTROL BLOCKS=
*                  PSA  R/W
*                  LCCA R/W
*                  ASCB R/W
*                  CVT  R
*                  SDWA R/W
*                  CSD  R
*
*        TABLES=
*             SETLOCK'S CPU LOCKS HELD TABLE USED
*             SETLOCK'S ADDRESSES OF LOCK ADDRESSES TABLE USED
*
*        MACROS=
*             SETFRR A
*             SETLOCK RELEASE,TYPE=CMS
*             SETRP CPU=(CPUID)
*             SETRP RETADDR=(R),RC=4
*             SETRP FRELOCK=(DISP)
*             SETRP FRELOCK=(SALLOC)
*             SETRP COMPCOD=(X'074',SYSTEM)
*             CALLRTM TYPE=MEMTERM
*
*        SERIALIZATION=
*             DISPATCHER LOCK/DISABLE
*
*        CHANGE LEVEL=
*                                                              @ZA19968
*             OZ27996--THIS ROUTINE'S FRR WOULD FORMERLY RETRY @ZA27996
*                      IN MANY SITUATIONS. NOW IT WILL RETRY   @ZA27996
*                      ONLY IF NO LOCKS ARE HELD AND THE STATE @ZA27996
*                      CANNOT BE DETERMINED.                   @ZA27996
*             OZ28255 -LOCK REPAIR WILL CHECK BOTH LOCK SUPER  @ZA28255
*                      BITS AND THE LOCK MANAGER SALLOC LOCK   @ZA28255
*                      BIT TO DETERMINE IF AN FRR SHOULD BE    @ZA28255
*                      SET. IT WILL NOT BE SET IF THE LOCK     @ZA28255
*                      SUSPEND SUPER BIT (PSAULCMS) AND THE    @ZA28255
*                      LOCK MANAGER SALLOC LOCK BIT            @ZA28255
*                      (LCCALKSA) ARE BOTH ON.                 @ZA28255
*                      THE SETLOCK FRR ROUTINE WILL PROCESS    @ZA28255
*                      THE TWO SUPER BITS SEPARATELY.          @ZA28255
*             OZ32162 - NO CODE CHANGE. FIX COVER LETTER FOR SU51
*                       BECAUSE PREREQ MACRO IHAPSA IS IN SU51
*                       CORRECT.                               @ZA32162
*
*        MESSAGES=
*             NONE
*        ABEND CODES=
*             X'074'-GENERAL ERROR COMPLETION CODE
*
**** END OF SPECIFICATIONS ***/
*/*IEAVELKR: CHART SETLOCK RECOVERY */
*/* HEADER
*/*
*/*
*/*
*/*                                            SECTION 3.1.7.14
*/* SETLOCK RECOVERY
*/*                                            PAGE # */
*/*IEAVELKR: E BEGIN SETLOCK REPAIR ROUTINE */
         SPACE 2
IEAVELKR CSECT
         USING LCCA,LCCAREG
         USING PSA,0
         USING SDWA,R1
*        EQUATE SECTION
R0       EQU   0                       REGISTER 0
R1       EQU   1                       REGISTER 1
R2       EQU   2                       REGISTER 2
STLRET   EQU   2                       STEAL ROUTINE RETURN REG
WORKREG3 EQU   3                       WORK REGISTER           @ZA19968
MASKREG  EQU   3                       MASK REGISTER
COUNTREG EQU   3                       GENERAL COUNT REG
BASEREG2 EQU   4                       ALTERNATE BASE REGISTER
TEMPSAVE EQU   4                       TEMPORARY SAVE REG
TABLEREG EQU   4                       TABLE INDEX REG
R5       EQU   5                       REGISTER 5
JRNLREG  EQU   5                       JOURNAL REGISTER
TEMPPARM EQU   5                       TEMPORARY SAVE REG
INDREG   EQU   5                       INDEX REGISTER
RETADD   EQU   5                       RETRY ADDRESS REG
R6       EQU   6                       REGISTER 6
VALREG   EQU   6                       GENERAL VALUE REG
R7       EQU   7                       REGISTER 7
LCCAREG  EQU   8                       LCCA ADDRESS REG
ALTWORK  EQU   9                       WORK REGISTER
BASEREG  EQU   9                       REPAIR ROUTINE BASE REG
WORKREG  EQU   10                      WORK REGISTER
LOCKREG  EQU   11                      LOCK ADDRESS REG
R13      EQU   13                      REGISTER 13
R14      EQU   14                      REGISTER 14
R15      EQU   15                      REGISTER 15
*        VALUE EQUATES
ZERO     EQU   0                       DISPLACEMENT VALUE
ONE      EQU   1                       DISPLACEMENT VALUE
THREE    EQU   3                       DISPLACEMENT VALUE
FOUR     EQU   4                       DISPLACEMENT VALUE
EIGHT    EQU   8                       DISPLACEMENT VALUE
WAITON   EQU   X'02'                   WAIT BIT IN PSW
COMPCOD  EQU   X'074'                  LOCK COMPCODE
CMSLOCHM EQU   X'03'                   CMS-LOCAL HIERARCHY MASK
CMSHM    EQU   X'02'                   CMS HIERARCHY MASK
LOCHM    EQU   X'01'                   LOCAL HIERARCHY MASK
MAX      EQU   X'FF'                   AND HIGH MASK
         SPACE 2
*/* P ESTABLISH ADDRESSABILITY */
         SPACE 2
         BALR  BASEREG,R0              ESTABLISH
         USING *,BASEREG               ADDRESSABILITY
         SPACE 2
*/* P CLEAR FRR PARM REG */
         SPACE 2
         SLR   R1,R1                   ZERO PARM REGISTER
*
*        CHECK IS A SETFRR IS APPROPRIATE(SETLOCK IN CONTROL)
         SPACE 2
*/* D (NO,VERIFY,YES,) IS SETLOCK ACTIVE? */
         SPACE 2
         TM    PSASUP1,PSALOCK         IS SETLOCK ACTIVE
         BO    SALOCKON                SETLOCK IS ACTIVE       @ZA28255
         TM    PSASUP3,PSAULCMS        SETLOCK SUSPEND ACTIVE? @ZA28255
         BZ    VERIFY                  SETLOCK IS NOT ACTIVE   @ZA28255
SALOCKON L     LCCAREG,PSALCCAV        GET THE LCCA ADDRESS    @ZA28255
         SPACE 2
*/* D (NO,SETFRR,YES,) DID RESTART OCCURR? */
         SPACE 2
         L     R0,ZERO(R13)            GET TYPE OF ENTRY VALUE
         C     R0,ADTWO                DID A RESTART OCCUR
         BNE   SETFRR                  IF NOT, DO A SETFRR
         SPACE 2
*/* D (NO,SETFRR,YES,) IS SETLOCK SPINNING? */
         SPACE 2
         TM    LCCASPN1,LCCALOCK       IS SETLOCK SPINNING
         BNO   SETFRR                  IF NOT, DO A SETFRR
*        CHECK IF ERROR OCCURRED IN SETLOCK RANGE
         SPACE 2
*/* D (NO,VERIFY,YES,) IS ERROR PSW IN SETLOCK? */
         SPACE 2
         L     R2,EIGHT(R13)           GET PSW ADDRESS
         L     R2,FOUR(R2)             GET ADDRESS OF ERROR
         C     R2,LOCKSTRT             IS ERROR LESS THAN START
         BL    VERIFY                  IF SO,CONTINUE PROCESSING
         C     R2,LOCKEND              IS ERROR WITHIN LOCK
         BH    VERIFY                  IF NOT,CONTINUE PROCESSING
         SPACE 2
*/*SETFRR: L PERFORM A SETFRR ADD */
*/* P SET SETLOCK BIT IN FRR PARM AREA */
         SPACE 2
SETFRR   TM    PSASUP1,PSALOCK         IS SETLOCK ACTIVE       @ZA28255
         BO    SETFRR1                 GO SET FRR IF ACTIVE    @ZA28255
         TM    LCCALKFG,LCCALKSA       IS SETLOCK SALLOC BIT ON@ZA28255
         BO    VERIFY                  FRR IS ALREADY SET      @ZA28255
SETFRR1  SETFRR A,FRRAD=LOCKASVT,PARMAD=(1),WRKREGS=(2,3)      @ZA28255
         OI    RRRAFLG1-RRRA(R1),RRRALOCK INDICATE SETLOCK FRR
*
*      THE FOLLOWING ROUTINES RECONSTRUCT HIERARCHY MASK AND LOCKWORDS
         SPACE 2
*/*VERIFY: P CLEAR ALL UNUSED BITS IN HIERARCHY MASK */
*/* P SET UP TO SCAN LOCKWORDS AND LOCK TABLE */
         SPACE 2
VERIFY   DS    0H
*      SPIN LOCK RECONSTRUCTION
         L     MASKREG,HIGHHM          GET HIGHEST HIERARCHY MASK VAL
         LR    WORKREG,MASKREG         GET HIGH MASK VALUE
         SLL   WORKREG,ONE             MULT BY 2
         BCTR  WORKREG,ZERO            GET AND VALUE
         N     WORKREG,PSAHLHI         CLEAR ALL HIGH BITS
         ST    WORKREG,PSAHLHI         STORE GOOD HLHI
         L     TABLEREG,TABLEADD       GET ADDRESS OF LOCK ADDRESS TAB
         SLR   INDREG,INDREG           ZERO INDEX REG
         SPACE 2
*/*SPINLOOP: D (YES,ENDLOOP,NO,) IS LOCK ADDRESS ZERO? */
         SPACE 2
SPINLOOP L     LOCKREG,ZERO(INDREG,TABLEREG) GET ADDRESS OF LOCK ADDR
         L     LOCKREG,ZERO(LOCKREG)   GET ADDRESS OF LOCKWORD
         LTR   LOCKREG,LOCKREG         IS LOCK ADDRESS ZERO(ONLY WHEN
*                                      CLASS LOCK IS USED
         BZ    ENDLOOP                 IF SO,GET NEXT ENTRY
         SPACE 2
*/* D (NO,ENDLOOP,YES,) IS LOCK ADDRESS REFRENCABLE? */
         SPACE 2
         LRA   WORKREG,ZERO(LOCKREG)   IS LOCK ADDRESS IN STORAGE
         BNZ   ENDLOOP                 IF NOT,GET NEXT ENTRY
         SPACE 2
*/* D (YES,SPINOWN,NO,) IS LOCK OWNED BY THIS CPU? */
         SPACE 2
         L     VALREG,ZERO(LOCKREG)    GET VALUE FROM LOCKWORD
         LH    WORKREG,PSACPULA        GET CPU ID
         CR    VALREG,WORKREG          IS THE LOCK OWNED BY THIS CPU
         BE    SPINOWN                 IF SO INDICATE OWNED
         SPACE 2
*/* D (NO,ENDLOOP,YES,) DID RESTART OCCUR? */
         SPACE 2
         L     WORKREG,ZERO(R13)       GET ERROR TYPE VALUE
         C     WORKREG,ADTWO           DID RESTART OCCUR
         BNE   ENDLOOP                 IF NOT,END LOOP
         SPACE 2
*/* D (NO,ENDLOOP,YES,) IS LOCK OWNED AT ALL? */
         SPACE 2
         LTR   VALREG,VALREG           LOCK OWNED
         BZ    ENDLOOP                 IF NOT,END LOOP
         SPACE 2
*/* D (YES,ENDLOOP,NO,) IS VALID CPUID IN LOCKWORD? */
         SPACE 2
         C     VALREG,AD40             IS LOCK VALUE LOWER THAN MIN.
         BL    SPNSTEAL                IF SO,CLEAR LOCK
         C     VALREG,AD7F             IS LOCK VALUE HIGHER THAN MAX.
         BNH   ENDLOOP                 IF NOT,END LOOP
         SPACE 2
*/*SPNSTEAL: P CLEAR LOCKWORD WITH CS INSTRUCTION */
         SPACE 2
SPNSTEAL SLR   WORKREG,WORKREG         ZERO CS REG
         CS    VALREG,WORKREG,ZERO(LOCKREG) CLEAR LOCKWORD(MAY NOT
*                                           COMPARE)
         SPACE 2
*/*ENDLOOP: P CLEAR LOCK TABLE ENTRY */
*/* P CLEAR HIERARCHY MASK BIT */
         SPACE 2
ENDLOOP  SLR   WORKREG,WORKREG         CLEAR WORKREG
         ST    WORKREG,PSACLHT(INDREG) ZERO CLHT ENTRY
         LR    WORKREG,MASKREG         GET HIERARCHY MASK VALUE
         X     WORKREG,ALLON           GET AND VALUE
         N     WORKREG,PSAHLHI         CLEAR HIERARCHY MASK VALUE
         ST    WORKREG,PSAHLHI         STORE CORRECT HIERARCHY MASK
         SPACE 2
*/*ENDLOOP2: D (YES,CMSCHECK,NO,) LAST SPIN DONE? */
         SPACE 2
ENDLOOP2 C     MASKREG,LASTSPIN        FINISHED
         BE    CMSCHECK                IF SO,DO CMS CHECKING
         SPACE 2
*/* P (,SPINLOOP) SET UP FOR NEXT LOCK VERIFICATION */
         SPACE 2
         SRL   MASKREG,ONE             GET LOWER HIERARCHY VALUE
         LA    INDREG,FOUR(INDREG)     INCREMENT TABLE INDEX
         B     SPINLOOP                CONTINUE LOOP
         SPACE 2
*/*SPINOWN: P (,ENDLOOP2) SET HIERARCHY MASK BIT ON */
         SPACE 2
SPINOWN  L     WORKREG,PSAHLHI         GET CURRENT HIERARCHY MASK
         OR    WORKREG,MASKREG         SET HIERARCHY MASK BIT
         ST    WORKREG,PSAHLHI         STORE CORRECT HIERARCHY MASK
         B     ENDLOOP2                GO END LOOP
         SPACE 2
*/*CMSCHECK: D (YES,CMSCLEAR,NO,) IS CMS LOCK CLEAR? */
         SPACE 2
*        CMS LOCK RECONSTRUCT ROUTINE
CMSCHECK DS    0H
         L     LOCKREG,CMSLOCK         GET ADDRESS OF CMS LOCK
         L     LOCKREG,ZERO(LOCKREG)   GET CMS LOCK VALUE
         LTR   LOCKREG,LOCKREG         IS CMS LOCK CLEAR
         BZ    CMSCLEAR                IF SO,FINISHED CMS CHECKS
         SPACE 2
*/* D (NO,CMSCHK2,YES,) DID RESTART OCCUR? */
         SPACE 2
         L     WORKREG,ZERO(R13)       GET ERROR TYPE VALUE
         C     WORKREG,ADTWO           DID RESTART OCCUR
         BNE   CMSCHK2                 IF NOT, CHECK FURTHER
         SPACE 2
*/* D (NO,CMSCHK2,YES,) IS ERROR PSW IN WAIT? */
         SPACE 2
         L     WORKREG,EIGHT(R13)      GET ERROR PSW ADDRESS
         TM    ONE(WORKREG),WAITON     IS PSW IN WAIT
         BNO   CMSCHK2                 IF NOT,CHECK FURTHER
         SPACE 2
*/* D (NO,CMSCHK2,YES,) IS CURRENT ASCB WAITASCB? */
         SPACE 2
         L     WORKREG,WAITASCB        GET WAIT ASCB ADDRESS
         C     WORKREG,PSAAOLD         IS WAIT CURRENT ASCB
         BNE   CMSCHK2                 IF NOT,CHECK FURTHER
         SPACE 2
*/* D (NO,CMSCHK2,YES,) ARE ALL CPUS IN WAIT ASCB? */
         SPACE 2
         L     COUNTREG,FLCCVT         GET CVT ADDRESS
         L     COUNTREG,CVTCSD-CVT(COUNTREG) GET CSO ADDRESS
         LH    COUNTREG,CSDCPUOL-CSD(COUNTREG) GET CPU ON-LINE COUNT
         C     COUNTREG,ASCBCPUS-ASCB(WORKREG) ALL CPUS IN WAIT ASCB
         BNE   CMSCHK2                 IF NOT,CHECK FURTHER
         SPACE 2
*/* D (NO,CMSCHK2,YES,) IS CMS VALUE REFRENCABLE? */
         SPACE 2
         LRA   WORKREG,ZERO(LOCKREG)   IS CMSLOCK VALUE REFERENCABLE
         BNZ   CMSCHK2                 IF NOT,CHECK FURTHER
         SPACE 2
*/* D (NO,CMSCHK2,YES,) DOES CMSLOCK POINT TO REAL ASCB? */
         SPACE 2
         L     WORKREG,ZERO(LOCKREG)   GET FIRST 4 BYTES OF ASCB OWNER
*                                                            @ZA06217
         C     WORKREG,CASCB           IS IT A REAL ASCB       @ZA06217
         BNE   CMSCHK2                 IF NOT,CHECK FURTHER   @ZA06217
         SPACE 2
*/* D (NO,CMSCHK2,YES,) IS OWNER OF CMS IN PAGE WAIT? */
         SPACE 2
         L     WORKREG,ASCBLOCK-ASCB(LOCKREG) GET VALUE OF LOCAL LOCK
*                                             OF CMS OWNER
         C     WORKREG,SUSPID          IS OWNER IN PAGE WAIT
         BNE   CMSCHK2                 IF NOT, CHECK FURTHER
         SPACE 2
*/* P SET UP TO MEMTERM MEMORY THAT OWNS CMSLOCK */
         SPACE 2
*        THE OWNER OF THE CMS LOCK WILL BE MEMTERMED AND CMS STOLEN
         L     LCCAREG,PSALCCAV        GET LCCA ADDRESS
         L     WORKREG,LCCACPUS        GET WSAC ADDRESS
         LR    TEMPSAVE,R13            SAVE SAVE AREA ADDRESS
         LR    TEMPPARM,R1             SAVE PARM REG VALUE
         L     R13,WSACABTM-WSAC(WORKREG) GET MEMTERM SAVE AREA ADDR
         LA    R1,COMPCOD              GET MEMTERM CODE
         SLR   WORKREG,WORKREG         CLEAR ASID REG
         ICM   WORKREG,THREE,ASCBASID-ASCB(LOCKREG) GET ASID VALUE
         SPACE 2
*/* L MEMTERM MEMORY */
         SPACE 2
         CALLRTM TYPE=MEMTERM,COMPCOD=(1),ASID=(WORKREG) TERM MEMORY
         NI    ASCBFLG1-ASCB(LOCKREG),MAX-ASCBCMSH CLEAR CMS BIT
         LR    R13,TEMPSAVE            RESTORE SAVE AREA
         LR    R1,TEMPPARM             RESTORE PARM ADDRESS
         SPACE 2
*/* P SET UP TO STEAL CMSLOCK */
         SPACE 2
         L     WORKREG,PSAAOLD         GET CURRENT ASCB ADDRESS
         L     LOCKREG,CMSLOCK         GET CMS LOCK ADDRESS
         ST    WORKREG,ZERO(LOCKREG)   REPLACE CMS VALUE WITH CURRENT
         OI    PSAHLHI+THREE,CMSLOCHM  SET CMS AND LOCAL H M
         SPACE 2
*/* S CMSSTEAL:GO TO INTERNAL STEAL ROUTINE */
         SPACE 2
         BAL   STLRET,CMSSTEAL         GO STEAL THE LOCK RELEASING
*                                      SUSPENDED CMS REQUESTORS
         SPACE 2
*/*CMSCLEAR: P (,LOCALCHK) CLEAR CMS HIERARCHY AMSK BIT */
         SPACE 2
CMSCLEAR NI    PSAHLHI+THREE,MAX-CMSHM CLEAR CMS HIERARCHY BIT
         B     LOCALCHK                GO PERFORM LOCAL CHECKS
         SPACE 2
*/*CMSSTEAL: E CMS STEAL ROUTINE */
         SPACE 2
*        THE FOLLOWING ROUTINE STEALS THE CMS LOCK
CMSSTEAL DS    0H
         SPACE 2
*/* D (NO,STEAL2,YES,) SETLOCK ACTIVE? */
         SPACE 2
         TM    PSASUP1,PSALOCK         IS SETLOCK IN CONTROL
         BO    STEAL1                  IT IS DONT USE SETLOCK  @ZA28255
         TM    PSASUP3,PSAULCMS        SETLOCK SUSPEND ACTIVE  @ZA28255
         BZ    STEAL2                  IS NOT, USE SETLOCK     @ZA28255
STEAL1   DS    0H
         SPACE 2
*/* P (,FINSTEAL) STEAL CMSLOCK WITH CS INSTRUCTION */
         SPACE 2
         SLR   WORKREG,WORKREG         CLEAR REG
         L     LOCKREG,CMSLOCK         GET CMS LOCK ADDRESS
         L     VALREG,ZERO(LOCKREG)    GET CMS VALUE
         CS    VALREG,WORKREG,ZERO(LOCKREG) CLEAR CMSLOCK
         BR    STLRET                  RETURN TO CALLER
         SPACE 2
*/*STEAL2: L REQUEST CMS LOCK TO BE FREED */
         SPACE 2
STEAL2   DS    0H
         LR    WORKREG,R13             SAVE REG 13
         SETLOCK RELEASE,TYPE=CMS,RELATED=('STEALING CMS')
         LR    R13,WORKREG             RESTORE REG 13
         SPACE 2
*/*FINSTEAL: R END CMSSTEAL ROUTINE-RETURN */
         SPACE 2
         BR    STLRET                  RETURN TO CALLER
         SPACE 2
*/*CMSCHK2: D (NO,CMSCLEAR,YES,) DOES CURRENT ASCB OWN CMSLOCK? */
         SPACE 2
*        CONTINUE WITH CMS LOCK CHECKS
CMSCHK2  DS    0H
         C     LOCKREG,PSAAOLD         DOES CURRENT ASCB OWN LOCK
         BNE   CMSCLEAR                IF NOT,FINISHED
         SPACE 2
*/* D (YES,CMSLOCAL,NO,) IS CPUID IN LOCAL LOCK? */
         SPACE 2
         L     WORKREG,ASCBLOCK-ASCB(LOCKREG) GET LOCAL LOCK VALUE
         LH    VALREG,PSACPULA         GET CPU ID
         CR    WORKREG,VALREG          IS CPUID IN LOCAL LOCK
         BE    CMSLOCAL                IF SO,CLEAN UP
         SPACE 2
*/* D (YES,CMSSUSP,NO,) IS SUSPEND ID IN LOCAL LOCK? */
         SPACE 2
         C     WORKREG,SUSPID          IS SUSPEND ID IN LOCAL LOCK
         BE    CMSSUSP                 IF SO,CHECK FURTHER
         SPACE 2
*/* D (YES,CMSSUSP,NO,) IS INTERRUPT ID IN LOCAL LOCK? */
         SPACE 2
         C     WORKREG,INTID           IS INTERRUPT ID IN LOCAL LOCK
         BE    CMSINT                  IF SO,CHECK FURTHER
         SPACE 2
*/* D (NO,LOCALCHK,YES,) IS LOCAL LOCK ZERO? */
         SPACE 2
         LTR   WORKREG,WORKREG         IS LOCAL LOCK ZERO
         BNZ   LOCALCHK                IF NOT,GO TO LOCAL CHECKS
         SPACE 2
*/* S CMSSTEAL:GO TO STEAL CMS LOCK */
*/* P (,CMSCLEAN) GO CLEAN UP INDICATORS */
         SPACE 2
         OI    PSAHLHI+THREE,CMSLOCHM  SET CMS AND LOCAL H M
         BAL   STLRET,CMSSTEAL         GO STEAL CMS LOCK
         B     CMSCLEAN                CLEAN UP
         SPACE 2
*/*CMSSUSP: D (NO,CMSCLEAN,YES,) DID DATERROR OCCUR? */
         SPACE 2
CMSSUSP  DS    0H
CMSINT   DS    0H
         OI    ASCBFLG1-ASCB(LOCKREG),ASCBCMSH SET CMS HELD BIT
         L     WORKREG,ZERO(R13)       GET ERROR ENTRY VALUE
         C     WORKREG,ADFOUR          IS ERROR A DAT ERROR
         BNE   CMSCLEAN                IF NOT,CLEAN UP
         SPACE 2
*/* P STOP FURTHER MEMORY DISPATCHING */
*/* S CMSSTEAL:STEAL CMS LOCK */
         SPACE 2
*        CMSLOCK WILL BE STOLEN ON DAT ERROR
         OI    ASCBDSP1-ASCB(LOCKREG),ASCBFAIL STOP FURTHER MEMORY DISP
         OI    PSAHLHI+THREE,CMSLOCHM  SET CMS AND LOCAL H M
         BAL   STLRET,CMSSTEAL         GO STEAL CMS LOCK
         SPACE 2
*/* P (,CMSCLEAN) CLEAR ASCBCMSH BIT */
         SPACE 2
         NI    ASCBFLG1-ASCB(LOCKREG),MAX-ASCBCMSH CLEAR CMS HELD BIT
         B     CMSCLEAN                FINISH CLEAN UP
         SPACE 2
*/*CMSLOCAL: D (YES,LOCALCHK,NO,) IS DISPATCHER IN CNTL? */
         SPACE 2
CMSLOCAL TM    PSASUP1,PSADISP         IS DISPATCHER IN CONTROL
         BO    LOCALCHK                IF SO,GO TO LOCAL CHECKS
         SPACE 2
*/* P (,LOCALCHK) SET CMS AND LOCAL BITS */
         SPACE 2
         OI    PSAHLHI+THREE,CMSLOCHM  SET CMS AND LOCAL H M
         B     LOCALCHK                GO DO LOCAL PROCESS
         SPACE 2
*/*CMSCLEAN: P CLEAR CMS AND LOCAL BITS */
         SPACE 2
CMSCLEAN NI    PSAHLHI+THREE,MAX-CMSLOCHM CLEAR CMS AND LOCAL HIER BITS
         SPACE 2
*/*LOCALCHK: D (YES,LOCALOWN,NO,) DOES THIS CPU OWN LOCAL LOCK? */
         SPACE 2
*        THE FOLLOWING CONSTITUTES THE LOCAL LOCK CHECKS
LOCALCHK DS    0H
         L     WORKREG,PSAAOLD         GET CURRENT ASCB ADDRESS
         L     LOCKREG,ASCBLOCK-ASCB(WORKREG) GET VALUE IN LOCALLOCK
         L     WORKREG,ZERO(WORKREG)   FIRST 4 BYTES OF ASCB
         C     WORKREG,CASCB           IS IT A REAL ASCB
         BNE   EXIT                    IF NOT, EXIT
         LH    VALREG,PSACPULA         GET CPUID
         CR    LOCKREG,VALREG          DOES THIS CPU OWN LOCALLOCK
         BE    LOCALOWN                IF SO,CLEAN UP ACCORDINGLY
         SPACE 2
*/* D (YES,LOCALCLR,NO,) IS SUSPEND ID IN LOCK? */
         SPACE 2
         C     LOCKREG,SUSPID          IS SUSPEND ID IN LOCK
         BE    LOCALCLR                IF SO CLEAN UP
         SPACE 2
*/* D (YES,LOCALCLR,NO,) IS INTERRUPT ID IN LOCK? */
         SPACE 2
         C     LOCKREG,INTID           IS INTERRUPT ID IN LOCK
         BE    LOCALCLR                IF SO CLEAN UP
         SPACE 2
*/* D (YES,LOCALCLR,NO,) IS LOCAL LOCK CLEAR? */
         SPACE 2
         LTR   LOCKREG,LOCKREG         IS LOCK VALUE ZERO
         BZ    LOCALCLR                IF SO CLEAN UP
         SPACE 2
*/* D (YES,LOCHMCHK,NO,) IS INVALID VALUE IN LOCK? */
         SPACE 2
         C     LOCKREG,AD40            IS ID IN LOCK LOWER THAN MIN
         BL    LOCHMCHK                IF SO,CHECK NEXT ACTION
         C     LOCKREG,AD7F            IS ID IN LOCK HIGHER THAN MAX
         BH    LOCHMCHK                IF SO,CHECK NEXT ACTION
         SPACE 2
*/*LOCALCLR: P CLEAR CMS AND LOCAL BITS */
         SPACE 2
LOCALCLR NI    PSAHLHI+THREE,MAX-CMSLOCHM CLEAR CMS AND LOCAL HIERARCHY
         SPACE 2
*/*EXIT: P (,FINI) EXIT TO ASVT ROUTINE */
         SPACE 2
EXIT     DS    0H
         L     R15,ASVTRTN             GET EXIT ADDRESS
         BR    R15                     GO TO ASVT ROUTINE
         SPACE 2
*/*LOCALOWN: D (YES,EXIT,NO,) IS DISPATCHER IN CNTL? */
         SPACE 2
LOCALOWN DS    0H
         TM    PSASUP1,PSADISP         IS DISP IN CONTROL
         BO    EXIT                    IF SO EXIT
         SPACE 2
*/* P (,EXIT) CLEAR LOCAL HIERARCHY BIT */
         SPACE 2
         OI    PSAHLHI+THREE,LOCHM     SET CMS AND LOCAL H M
         B     EXIT                    ELSE CLEAR BITS FIRST
         SPACE 2
*/*LOCHMCHK: D (YES,GETLOCAL,NO,) IS LOCAL HIERARCHY BIT ON? */
         SPACE 2
LOCHMCHK DS    0H
         TM    PSAHLHI+THREE,LOCHM     IS HIERARCHY MASK BIT ON
         BO    GETLOCAL                IF SO,ATTEMPT TO GET LOCK BACK
         SPACE 2
*/* P CLEAR LOCAL LOCK WITH CS INSTRUCTION */
*/* D (YES,LOCALCLR,NO,) DID CS FAIL? */
         SPACE 2
         LH    VALREG,PSACPULA         GET CS VALUE
         L     WORKREG,PSAAOLD         GET ASCB ADDRESS
         CS    LOCKREG,VALREG,ASCBLOCK-ASCB(WORKREG) CLEAR LOCAL LOCK
         BNZ   LOCALCLR                IF CS FAILED,CLEAN UP
         SPACE 2
*/* D (NO,LOCFREE,YES,) DOES ASCB OWN CMSLOCK? */
         SPACE 2
         L     LOCKREG,CMSLOCK         GET CMS LOCK ADDRESS
         L     LOCKREG,ZERO(LOCKREG)   GET CMS LOCK VALUE
         C     LOCKREG,PSAAOLD         DOES THIS ASCB OWN CMS LOCK
         BNE   LOCFREE                 IF NOT,CLEAN UP
         SPACE 2
*/* S CMSSTEAL:STEAL CMS LOCK */
         SPACE 2
         OI    PSAHLHI+THREE,CMSLOCHM  SET CMS AND LOCAL H M
         NI    ASCBFLG1-ASCB(LOCKREG),MAX-ASCBCMSH CLEAR CMS BIT
         BAL   STLRET,CMSSTEAL         IF SO,STEAL CMS LOCK
         SPACE 2
*/*LOCFREE: P (,LOCALCLR) GO CLEAN UP */
         SPACE 2
LOCFREE  SLR   VALREG,VALREG           CLEAR REG
         L     WORKREG,PSAAOLD         GET ASCB ADDRESS
         ST    VALREG,ASCBLOCK-ASCB(WORKREG) CLEAR LOCAL LOCK
         B     LOCALCLR                CLEAN UP
         SPACE 2
*/*GETLOCAL: P TRY TO GET LOCAL WITH CS INSTRUCTION */
*/* D (NO,LOCALCLR,YES,) CS FAILED? */
         SPACE 2
GETLOCAL DS    0H
         LH    VALREG,PSACPULA         GET CPUID
         L     WORKREG,PSAAOLD         GET ASCB ADDRESS
         CS    LOCKREG,VALREG,ASCBLOCK-ASCB(WORKREG) GET LOCAL LOCK
         BNZ   LOCALCLR                IF NOT GOTTEN CLEAN UP
         SPACE 2
*/* D (YES,CMSREOBT,NO,) CMS LOCK OWNED BY THIS ASCB? */
         SPACE 2
         L     LOCKREG,CMSLOCK         GET CMS ADDRESS
         C     WORKREG,ZERO(LOCKREG)   IS CMS OWNED BY THIS ASCB
         BE    CMSREOBT                IF SO INDICATE
         SPACE 2
*/* P (,EXIT) CLEAR CMS HIERARCHY BIT */
         SPACE 2
         NI    PSAHLHI+THREE,MAX-CMSHM CLEAR CMS BIT
         B     EXIT                    FINISHED
         SPACE 2
*/*CMSREOBT: P (,EXIT) SET CMS AND LOCAL BITS */
         SPACE 2
CMSREOBT OI    PSAHLHI+THREE,CMSLOCHM  SET CMS AND LOCAL H M
         B     EXIT                    FINISHED
         SPACE 2
*/*FINI: R END SETLOCK REPAIR ROUTINE */
         TITLE 'IEAVELKR-SETLOCK FRR ROUTINE'
         SPACE 2
*/*IEAVLKRR: E SETLOCK FRR ROUTINE */
         SPACE 2
         ENTRY IEAVLKRR
IEAVLKRR DS    0H
         SPACE 2
*/* P ESTABLISH ADDRESSABILITY */
         SPACE 2
         BALR  BASEREG2,R0             ESTABLISH
         USING *,BASEREG2              ADDRESSABILITY
ADDRESS  DS   0H                      LABEL FOR ADDRESSABILITY @YM06769
         SPACE 2
*/*  P RECORD MODULE,CSECT NAME */
         SETRP RECPARM=IDFRR           RECORD NAME PARMS       @YM05105
         SPACE 2
*/* D (YES,LOCKFRR,NO,) IS SETLOCK FRR TO ACT? */
         SPACE 2
         L     WORKREG,SDWAPARM        GET PARM AREA ADDRESS   @YM06769
         ST    R0,RRRASAV0-RRRA(WORKREG) SAVE R0 VALUE
         ST    R14,RRRASA14-RRRA(WORKREG) SAVE RETURN ADDRESS
         TM    RRRAFLG1-RRRA(WORKREG),RRRALOCK IS SETLOCK TO BE ENTERED
         BO    LOCKFRR                 IF SO GO TO SETLOCK FRR
         SPACE 2
*/*ASVTCHK: P GET PARAMETER AREA ADDRESS TO CHECK FLAGS */     @ZA04120
         SPACE 2
ASVTCHK  BALR  BASEREG2,R0             REESTABLISH ADDRESSABILITY
         USING *,BASEREG2
         L     BASEREG2,ADDR           RELOAD ORIGINAL BASE
         USING ADDRESS,BASEREG2
         L     WORKREG,SDWAPARM        GET PARM AREA ADDRESS
         SPACE 2                                               @ZA04120
*/*RTMRTN: P RECORD C'RRRA' AND FIRST WORD OF RRRA */
         SPACE 2                                               @ZA04120
         L     VALREG,CRRRA            GET ACRONYM
         ST    VALREG,SDWAVRA          PUT ACRONYM IN RECORD AREA
         MVC   SDWAVRA+FOUR(FOUR),RRRASTAT-RRRA(WORKREG) RECORD STATUS
*                                      BITS
         MVI   SDWAURAL,EIGHT          UPDATE USER LENGTH
         L     R0,RRRASAV0-RRRA(WORKREG) GET R0 VALUE
         SPACE 2                                               @ZA04120
*/* D (NO,,YES,ASVTFIX) IS ASVT FRR TO ACT ? */                @ZA04120
*/* R RETURN TO RTM */
         SPACE 2                                               @ZA04120
         L     R14,RRRASA14-RRRA(WORKREG) RESTORE RETURN ADDR @ZA10781
         TM    RRRAFLG1-RRRA(WORKREG),RRRAASVT IS ASVT TO BE ENTERED
         BNOR  R14                     EXIT TO RTM IF NOT      @ZA04120
         SPACE 2
*/*ASVTFIX: L GO TO ASVT FRR ROUTINE (NO RETURN) */            @ZA04120
         SPACE 2
ASVTFIX  DS    0H                                              @ZA04120
         L     R15,ASVTFRR             GET ASVT FRR ADDRESS
         BR    R15                     GO TO ASVT ROUTINE      @ZA04120
         SPACE 2
*/*LOCKFRR: D (NO,NOSPIN,YES,) IS SETLOCK IN SPIN? */
         SPACE 2
LOCKFRR  DS    0H                      LOCK FRR
         L     LCCAREG,PSALCCAV        GET LCCA ADDRESS
         TM    LCCASPN1,LCCALOCK       IS SETLOCK IN A SPIN
         BNO   NOSPIN                  IF NO,PROCESS NON-SPIN
         SPACE 2
*/* D (NO,PERC,YES,) DID RESTART OCCUR? */
         SPACE 2
         TM    SDWAERRA,SDWARKEY       DID RESTART OCCUR
         BNO   NOSPIN                  IF NOT, CHECK THE QUEUES@ZA28255
         SPACE 2
*/* D (YES,PERC,NO,) IS LOCK ALREADY OWNED? */
         SPACE 2
         LH    VALREG,PSACPULA         GET CPUID
         L     WORKREG,SDWAGR11        GET LOCK ADDRESS BEING OBTAINED
         C     VALREG,ZERO(WORKREG)    IS LOCK ALREADY OWNED
         BE    NOSPIN                  IF SO, CHECK THE QUEUES @ZA28255
         SPACE 2
*/* D (YES,PERC,NO,) IS VALUE IN CPUID INVALID? */
         SPACE 2
         L     VALREG,ZERO(WORKREG)    GET CPUID IN LOCK
         C     VALREG,AD40             IS CPUID LOW
         BL    NOSPIN                  IF SO, CHECK THE QUEUES @ZA28255
         C     VALREG,AD7F             IS CPUID HIGH
         BH    NOSPIN                  IF SO, CHECK THE QUEUES @ZA28255
         SPACE 2
*/* L INDICATE VALID SPIN VIA SETRP */
         SPACE 2
*                       INDICATE VALID SPIN AND RECORD
         SETRP CPU=(VALREG),RECORD=YES
         USING SDWA,1
         TM    LCCALKFG,LCCALKSA       IS SETLOCK SALLOC BIT ON@ZA28255
         BZ    NOSALLOC                NO CONTINUE BUT NO RESET@ZA28255
         NC    PSAHLHI,UNSALLOC        RESET THE SALLOC PSAHLHI@ZA28255
NOSALLOC DS    0H                      CONTINUE WITH PROCESS   @ZA28255
         SPACE 2
*/* L DELETE REPAIR RTN FRR FROM STACK */
*/* P (,ASVTCHK) GO CHECK FOR ASVT */
         SPACE 2
         SETFRR D,WRKREGS=(5,6)        DELETE SETLOCK FRR
         LA    R14,ASVTCHK             GET RETURN ADDRESS
         BR    R14                     RETURN
         SPACE 2
         SPACE 2
*/*PERC: P CLEAR ALL SETLOCK BITS */
         SPACE 2
PERC2    NI    LCCALKFG,MAX-LCCALKSA-LCCALKDP CLEAR STAT BITS  @ZA28255
         NI    LCCASPN1,MAX-LCCALOCK   CLEAR SPIN BIT
         NI    PSASUP1,MAX-PSALOCK     CLEAR SETLOCK BIT
         NI    PSASUP3,MAX-PSAULCMS    CLEAR SETLOCK SUSPEND   @ZA28255
         SPACE 2
*/* L INDICATE PERCOLATE WITH X'074' */
*/* P (,ASVTCHK) GO CHECK FOR ASVT FRR */
         SPACE 2
PERC1    DS    0H                      PERC WITHOUT RESET BITS @ZA28255
         SETRP COMPCOD=(X'074',SYSTEM),RC=0,RECORD=YES  PERCOLATE ERROR
         USING SDWA,1
         LA    R14,ASVTCHK             GET RETURN ADDRESS
         BR    R14                     RETURN
         SPACE 2
*/*NOSPIN: P CLEAR SETLOCK BIT EARLY TO AVOID REC */           @Z40FPXJ
         SPACE 2                                               @Z40FPXJ
NOSPIN   DS    0H                                              @Z40FPXJ
         TM    PSASUP1,PSALOCK         IS SETLOCK ACTIVE       @ZA28255
         BZ    TSTULCMS                NOT ACTIVE CONTINUE     @ZA28255
         NI    PSASUP1,MAX-PSALOCK     CLEAR SETLOCK BIT       @ZA28255
         NI    LCCASPN1,MAX-LCCALOCK   CLEAR SPIN BIT          @ZA28255
         TM    PSASUP3,PSAULCMS        SETLOCK SUSPEND ACTIVE  @ZA28255
         BZ    LOCALCMS                NOT ACTIVE CONTINUE     @ZA28255
         B     PERC1                   BOTH ACTIVE DONT CLEAR  @ZA28255
TSTULCMS TM    PSASUP3,PSAULCMS        SETLOCK SUSPEND ACTIVE  @ZA28255
         BZ    LOCALCMS                NOT ACTIVE CONTINUE     @ZA28255
         OI    LCCALKFG,LCCALKSA       TURN ON SETLOCK SALLOC  @ZA28255
         NI    PSASUP3,MAX-PSAULCMS    TURN OFF BEFORE QUE REL @ZA28255
LOCALCMS DS    0H
         L     ALTWORK,ACMSSQH         GET CMS Q FWD PTR ADDR  @Z40FPXJ
         L     ALTWORK,ZERO(ALTWORK)   GET CMS Q FWD PTR       @Z40FPXJ
         LTR   ALTWORK,ALTWORK         IS Q EMPTY              @Z40FPXJ
         BNZ   LKRRQREL                NO GO TO QRELEASE       @Z40FPXJ
          SPACE 2                                              @Z40FPXJ
*/* D (YES,,NO,LKRRQREL) IS CMS SUS Q EMPTY? */                @Z40FPXJ
           SPACE 2                                             @Z40FPXJ
         L     INDREG,PSAAOLD          GET ASCB PTR            @Z40FPXJ
         USING ASCB,INDREG                                     @Z40FPXJ
         L     ALTWORK,ASCBLSQH        GET LCL SUS Q HEADER    @Z40FPXJ
         LTR   ALTWORK,ALTWORK         IS Q EMPTY              @Z40FPXJ
          SPACE 2                                              @Z40FPXJ
*/* D (NO,,YES,AQOK) IS LOCAL SUS Q EMPTY? */                  @ZA27996
         SPACE 2                                               @Z40FPXJ
         BZ    AQOK                    YES, CHECK FOR RETRY    @ZA27996
LKRRQREL DS    0H                                              @Z40FPXJ
            SPACE 2                                            @Z40FPXJ
*/*LKRRQREL: S QRELEASE */                                     @Z40FPXJ
         SPACE 2                                               @Z40FPXJ
         BAL   STLRET,QRELEASE         GO FREE SUS QUEUES      @Z40FPXJ
         SPACE 2
*/*AQOK: D (YES,LKRRSALC,NO,) LOCKS HELD OR SUPER RTN? */      @ZA27996
         SPACE 2
AQOK     L     WORKREG,PSASUPER        OBTAIN SUPER FLAGS      @ZA27996
         N     WORKREG,OFFSUPER        TURN OFF SUPER BITS     @ZA28255
         O     WORKREG,PSAHLHI         CHECK HLHI FOR LOCKS    @ZA27996
         BNZ   LKRRSALC                PERCOLATE IF NON-ZERO   @ZA27996
         SPACE 2
*/* D (YES,LKRRSALC,NO,) TASK MODE? */                         @ZA27996
         SPACE 2
         C     WORKREG,PSATOLD         TASK MODE?              @ZA27996
         BNZ   LKRRSALC                YES, PERC WITH 074      @ZA27996
         SPACE 2
*/* D (YES,LKRRSALC,NO,) SRB MODE? */                          @ZA27996
         SPACE 2
         TM    LCCADSF2,LCCASRBM       SRB MODE?               @ZA27996
         BO    LKRRSALC                YES, PERCOLATE WITH 074 @ZA27996
         SPACE 2
*/* P CLEAR ALL SETLOCK BITS */
*/* P SET DISP HIERARCHY MASK BIT */
         SPACE 2
         NI    LCCALKFG,MAX-LCCALKSA-LCCALKDP CLEAR STAT BITS  @Z40FPXJ
         NI    LCCASPN1,MAX-LCCALOCK   CLEAR SPIN BIT
         L     RETADD,AIEA0DS          GET DISP ENTRY ADDRESS  @Z40FPXJ
         SPACE 2
*/* L INDICATE RETRY FROM IEA0DS */                            @Z40FPXJ
         SPACE 2
         SETRP RETADDR=(RETADD),RC=4,RECORD=YES INDICATE RETRY
         USING SDWA,1
         SPACE 2
*/* P (,ASVTCHK) GO CHECK FOR ASVT FRR */
         SPACE 2                                               @Z40FPXJ
         LA    R14,ASVTCHK             GET RETURN ADDRESS
         BR    R14                     RETURN
         SPACE 2
LKRRSALC DS    0H                                              @Z40FPXJ
         SPACE 2
*/*LKRRSALC: D (NO,DISPREL,YES,) SALLOC OBTAINED BY SETLOCK? */@Z40FPXJ
          SPACE 2                                              @Z40FPXJ
         TM    LCCALKFG,LCCALKSA       SALLOC LOCK OBTAINED
         BNO   PERC2                   IF NOT PERCOLATE        @ZA28255
         SPACE 2
*/* L INDICATE SALLOC TO BE FREED */
         SPACE 2
         SETRP FRELOCK=(SALLOC)        INDICATE SALLOC TO BE FREED
         B     PERC2                   DONT CHECK SUSPEND ACTV @ZA28255
         SPACE 2
*/*QRELEASE: E QUEUE RELEASE ROUTINE */                        @Z40FPXJ
*/* D (YES,,NO,LKRRCMSQ) ANY ELEMENTS ON LOCAL Q? */           @Z40FPXJ
*/*LKRRNSRB: P DEQUE AND SCHEDULE SRB  */                      @Z40FPXJ
*/* D (YES,LKRRNSRB,NO,) ANY MORE SRB'S ? */                   @Z40FPXJ
         SPACE 2                                               @Z40FPXJ
QRELEASE DS    0H                                              @Z40FPXJ
         L     INDREG,PSAAOLD          GET ASCB ADDR           @Z40FPXJ
         USING ASCB,INDREG                                     @Z40FPXJ
         L     ALTWORK,ASCBLSQH        GET LOCAL SUS Q HEADER  @Z40FPXJ
         USING SRBSECT,ALTWORK                                 @Z40FPXJ
         LR    WORKREG3,R1             SAVE SDWA ADDRESS       @ZA19968
LKRRGSQH DS    0H                                              @Z40FPXJ
         LTR   ALTWORK,ALTWORK         ANY ELEMENTS ON Q?      @Z40FPXJ
         BZ    LKRRCMSQ                NO CHECK CMS SUS Q      @Z40FPXJ
         SLR   R6,R6                   ZERO REG FOR CS         @Z40FPXJ
         CS    ALTWORK,R6,ASCBLSQH     REMOVE Q FROM HEADER    @Z40FPXJ
         BNZ   LKRRGSQH                UNABLE TO REMOVE QUE    @Z40FPXJ
LKRRNSRB DS    0H                                              @Z40FPXJ
         LR    INDREG,ALTWORK          LOAD R5 FOR SCHED       @Z40FPXJ
         L     ALTWORK,SRBFLNK         GET NEXT ELE            @Z40FPXJ
         SCHEDULE SRB=(5)              SCHEDULE SRB            @Z40FPXJ
         LTR   ALTWORK,ALTWORK         ANY MORE ELEMENTS       @Z40FPXJ
         BNZ   LKRRNSRB                YES SCHED NXT SRB       @Z40FPXJ
           SPACE 2                                             @Z40FPXJ
*/*LKRRCMSQ: D (YES,LKRRCDL,NO,) IS CMS Q  EMPTY */            @Z40FPXJ
*/*  D  (YES,,NO,LKRRFCES) IS ELEMENT ASCB */                  @Z40FPXJ
*/* P (,LKRRCMSQ) PUT INT ID IN  LOCAL LK & UPDATE TO NXT ELE*/@Z40FPXJ
*/*LKRRFCES: P (,LKRRCMSQ) SCHEDULE SRB & UPDATE TO NXT ELE */ @Z40FPXJ
*/*LKRRCDL: D (NO,,YES,QRELEXIT) DOES LK MGR OWN DISP LOCK */  @Z40FPXJ
         SPACE 2                                               @Z40FPXJ
LKRRCMSQ DS    0H                                              @Z40FPXJ
         L     ALTWORK,ACMSSQH         GET CMS SUS Q HDR ADDR  @Z40FPXJ
         L     WORKREG,ZERO(ALTWORK)   GET CMS SUS Q HDR       @Z40FPXJ
LKRRGFCE DS    0H                                              @Z40FPXJ
         LTR   WORKREG,WORKREG         IS Q EMPTY              @Z40FPXJ
         BZ    LKRRCDL                 YES CHECK DISP LOCK     @Z40FPXJ
         SLR   INDREG,INDREG           ZERO FOR C.S.           @Z40FPXJ
         CS    WORKREG,INDREG,ZERO(ALTWORK)     DEQ ELE        @Z40FPXJ
         BNZ   LKRRGFCE                NOT SUCCESSFUL          @Z40FPXJ
LKRRCNE  DS    0H                                              @Z40FPXJ
         CLC   CASCB,0(WORKREG)        IS ELEMENT AN ASCB      @Z40FPXJ
         BNE   LKRRFCES                NO ELE IS SRB           @Z40FPXJ
         USING ASCB,WORKREG                                    @Z40FPXJ
         L     INDREG,INTID            GET INTERRUPT ID        @Z40FPXJ
         ST    INDREG,ASCBLOCK         STORE IT IN LOCK        @Z40FPXJ
         L     WORKREG,ASCBCMSF        GET NXT ELE PTR         @Z40FPXJ
         LTR   WORKREG,WORKREG         IS THERE ANOTHER        @Z40FPXJ
         BZ    LKRRCDL                 EMPTY NOW               @Z40FPXJ
         B     LKRRCNE                 CHECK NEXT ELE          @Z40FPXJ
LKRRFCES DS    0H                                              @Z40FPXJ
         LR     R1,WORKREG             SAVE SSRB ADDRESS       @Z40FPXJ
         USING SRBSECT,WORKREG                                 @Z40FPXJ
         L     WORKREG,SRBFLNK         GET ADDRESS NEXT        @Z40FPXJ
         SCHEDULE SRB=(R1)             SCHEDULE SSRB           @Z40FPXJ
         LTR   WORKREG,WORKREG         ANYMORE ELEMENTS        @Z40FPXJ
         BNZ   LKRRCNE                 YES CHECK NEXT          @Z40FPXJ
LKRRCDL  DS    0H                                              @Z40FPXJ
         LR    TEMPPARM,WORKREG3       SAVE SDWA ADDRESS       @ZA28255
         SLR   R1,R1                   INDICATE 0 ANEW VALUE
         L     R15,AMEMSW              GET MEMORY SW ADDRESS
         BALR  R14,R15                 GO TO MEMORY SWITCH
         LR    R1,TEMPPARM             RESTORE SDWA ADDRESS
         BR    STLRET                  RETURN TO CALLER
         SPACE 2
*/*IEAVELKR: END END SETLOCK RECOVERY */
         SPACE 2
ADTWO    DC    F'2'                    RESTART ERROR CODE
ASVTFRR  DC    V(IEAVVFRR)             ADDRESS OF ASVT FRR
AMEMSW   DC    V(IEAVEMS0)             MEMORY SWITCH ENTRY
LOCKSTRT DC    V(IEAVELK)              SETLOCK CSECT ADDRESS
LOCKEND  DC    V(IEAVELKE)             SETLOCK ENDING ADDRESS
TABLEADD DC    V(IEAVELKT)             SETLOCK LOCK TABLE ADRESS
CMSLOCK  DC    V(CMSLOCK)              CMS LOCKWORD ADDRESS
WAITASCB DC    V(IEAWASCB)             WAIT ASCB ADDRESS
ASVTRTN  DC    V(IEAVEVRR)             ASVT VERIFICATION RTN ADDR
AIEA0DS  DC    V(IEA0DS)               DISPLATCHER ENTRY       @Z40FPXJ
ACMSSQH  DC    V(CMSSQH)               CMS SUSP Q HDR ADDRESS  @Z40FPXJ
ADDR     DC    A(ADDRESS)              ADDRESS OF ORIGINAL ADDR
LOCKASVT DC    A(IEAVLKRR)             SETLOCK FRR ADDRESS
ADFOUR   DC    F'4'                    DAT ERROR CODE
HIGHHM   DC    X'00001000'             HIGHEST LOCK IN SYSTEM
AD40     DC    X'00000040'             LOWEST VALID CPUID
UNSALLOC DC    X'FFFFFBFF'             TURN OFF THE SALLOC LOCK@ZA28255
OFFSUPER DS    0F                      TURN OFF THE SUPER BITS @ZA28255
         DC    AL1(MAX-PSALOCK)        SUPER1 LOCK MANAGER BIT @ZA28255
         DC    AL1(MAX)                NON LOCK MANAGER SUPER  @ZA28255
         DC    AL1(MAX-PSAULCMS)       SUPER2 LOCK MANAGER BIT @ZA28255
         DC    AL1(MAX)                NON LOCK MANAGER SUPER  @ZA28255
AD7F     DC    X'0000007F'             HIGHEST VALID CPUID
LASTSPIN DC    X'00000004'             LOWEST SPIN LOCK
CASCB    DC    C'ASCB'                 ACRONYM ASCB
CRRRA    DC    C'RRRA'                 ACRONYM RRRA
IDFRR    DS    0H                      ID FOR SDWA             @YM05105
         DC    CL8'IEAVELK '           MODULE NAME             @YM05105
         DC    CL8'IEAVELK '           CSECT NAME              @YM05105
         DC    CL8'IEAVLKRR'           FRR ROUTINE NAME        @YM05105
SUSPID   DC    X'7FFFFFFF'             SUSPEND ID VALUE
ALLON    EQU   *                       ALL ONES WORD
INTID    DC    X'FFFFFFFF'             INTERRUPT ID VALUE
         IHAPSA
         IHALCCA
         IHASDWA
         IHAFRRS
         IHAASCB
         IHASRB
         IHAWSAVT DSECT=YES,CLASS=CPU
         IHARRRA
         IHACSD
         CVT DSECT=YES
         END
