         TITLE 'TSO EDIT COMMAND  RENUMBER BASIC  IKJEBERN'
IKJEBERN CSECT
*C466000,541000                                                  A45103
*A121500-121600                                                 YA00040
*A222187-222189,222263-222279,223573-223581,427010-427040       YA01202
*A433010-433170,620945-620951                                   YA01202
*C222259,222327,427000                                          YA01202
*D222263-222273,431000,434000-447000                            YA01202
***********************************************************************
* STATUS- VERSION NO. 01, OS/360 RELEASE NO. 20                       *
*                                                                     *
* FUNCTION- THIS MODULE PROVIDES FOR THE RENUMBERING OF A BASIC DATA  *
*    SET. IT IS CALLED BY THE EDIT RENUMBER SUBCOMMAND, IKJEBERE, TO  *
*    RENUMBER THE BASIC SOURCE AND SEQUENCE FIELDS.                   *
*                                                                     *
* ENTRY POINTS- IKJEBERN, THE MAIN AND ONLY ENTRY POINT.              *
*                                                                     *
* INPUT- REGISTER 1 POINTS TO A TWO-WORD PARAMETER LIST AS FOLLOWS-   *
*    WORD ONE - POINTER TO THE EDIT COMMUNICATION AREA.               *
*    WORD TWO - POINTER TO THE RENUMBER PARAMETERS-                   *
*    1  OLD LINE NUMBER                                               *
*    2  NEW LINE NUMBER                                               *
*    3  INCREMENT FOR RENUMBERING                                     *
*                                                                     *
* OUTPUT- A RETURN CODE IS PASSED IN REGISTER 15. THREE RETURN CODES  *
*    ARE POSSIBLE.                                                    *
*    0 - SUCCESSFUL COMPLETION                                        *
*    4 - UNSUCCESSFUL COMPLETION                                      *
*    8 - I/O ERROR ON THE UTILITY DATA SET                            *
*                                                                     *
* EXTERNAL REFERENCES-                                                *
*         IKJEBEUT - READS THE UTILITY DATA SET                       *
*         IKJEBEMS - SENDS MESSAGES TO THE TERMINAL USER              *
*   MACROS USED-                                                      *
*         IKJEBESV - STANDARD ENTRY LINKAGE                           *
*         IKJEBERT - STANDARD EXIT LINKAGE                            *
*         IKJEBEML - STANDARD MESSAGE PARAMETER LIST                  *
*         IKJEBEMG - STANDARD MESSAGE INSERTION PARAMETER LIST        *
*         IKJEBECA - COMMUNICATION AREA DSECT MAPPING MACRO           *
*                                                                     *
* EXITS, NORMAL- TO IKJEBERE WITH RETURN CODE IN REGISTER 15          *
*                                                                     *
* EXITS, ERROR- TO IKJEBERE WITH RETURN CODE IN REGISTER 15           *
*                                                                     *
* TABLES/WORK AREAS- THE EDIT COMMUNICATION AREA IS USED FOR WORK     *
*    SPACE.                                                           *
*                                                                     *
* ATTRIBUTES- REFRESHABLE, ENABLED, NON-PRIVILEGED                    *
*                                                                     *
* CHARACTER CODE DEPENDENCY- THIS MODULE IS DEPENDENT ON THE NUMBERS  *
*    1-9 BEING REPRESENTED BY CONSECUTIVE BIT REPRESENTATIONS         *
*                                                                     *
* NOTES- REGISTER USAGE                                               *
*    PARMREG0      0                   USED BY MACROS                 *
*    PARMREG1      1                   USED BY MACROS                 *
*    REG1          1                   PTR TO PARAMETERS              *
*    RWORK         2                   WORK REGISTER                  *
*    RCOUNT        3                   USED FOR SQUEEZE               *
*    RLGTH         3                   CONVERTING/STORE NUMBER        *
*    RTBL          4                   OLD/NEW TBL PTR                *
*    RSRC          5                   PTR TO SOURCE READ IN          *
*    RINCR         5                   INCREMENT                      *
*    RBUFF         6                   PTR TO WORK BUFFER             *
*    RLASTNO       6                   LAST NUMBER USED               *
*    RNUM          7                   OLD LINE NUMBER (PARAMETER)    *
*    RTRNM         8                   LINK REG                       *
*    COMMREG       9                   PTR TO COMM REGION             *
*    BASEREG       11                  BASE                           *
*    RETREG        14                  RETURN REG                     *
*    RETCDREG      15                  BRANCH/RETURN CODES            *
*    RCODE         15                  CODES                          *
*                                                                     *
*    STANDARD LINKAGE CONVENTIONS ARE USED.                           *
*                                                                     *
***********************************************************************
         EJECT
         IKJEBESV   (14,12),,*,COMMREG=0(1)
         SPACE
         USING IKJEBECA,COMMREG        ESTABLISH ADDRESSABILITY
         L     RWORK,FOUR(REG1)        PTR TO PARMS
         MVC   OLDNUMB(TWELVE),O(RWORK)  MOVE PARAMS
         XC    ADDKEY(FOUR),ADDKEY     ZERO FIRST ADDRESS
         XC    RTNCODE(TWO),RTNCODE    INIT RETURN CODE
         NI    ERRBITS,FLGOF           TURN OFF ALL ERROR FLAGS
         L     RNUM,OLDNUMB            NUMBER TO SRCH FOR
         XC    TABNO(SIX),TABNO        TBLS USED, TBLS, SCAN NUM
         MVC   READCB(FOUR),CAPTCDCB   PTR TO DATA SET
         MVC   RDPARMS(FOUR),READCB    PTR TO DATA SET
         MVC   MINSIZ(EIGHT),MININUM   INIT SIZE FOR GETMAIN
         MVI   RDPARMS,READWKEY        SEARCH FOR OLD NUMBER
         LA    RWORK,RDKEY
         ST    RWORK,RDKEYPTR          STORE PTR TO KEY
         ST    RNUM,RDKEY              STORE OLD LINE NO
         BAL   RTRNM,READ              READ IN RECORD
         LTR   RCODE,RCODE             TAKE CORRECT ACTION
         BNZ   NOTFOUND                4 (NOT FOUND)
         MVI   RDPARMS,READPREV        KEY-READ PREVIOUS RECORD
         BAL   RTRNM,READ              READ IN RECORD
         LTR   RCODE,RCODE             TAKE CORRECT ACTION
         BNZ   TBLBLD                  4(NOT FOUND) -IMPOSSIBLE
         CLC   KEY(FOUR),STLINENO      KEY OF PREVIOUS RECORD GTR THAN
*                                      STARTING NUMBER
         BNL   NOTCOMPT                NO-ERROR
TBLBLD   EQU   *
*
*        BUILD RENUMBER TABLE
*        OLD LINE NUMBER               4 BYTES BINARY NUMBER
*        NEW LINE NUMBER               4 BYTES BINARY NUMBER
*
         BAL   RTRNM,GETTABLE          ALLOCATE FIRST TBL
         L     RINCR,INCR
         L     RLASTNO,STLINENO        START
         SR    RLASTNO,RINCR           SUB INCREMENT
         MVI   RDPARMS,READFST         READ FIRST RECORD
         XC    RDKEYPTR(FOUR),RDKEYPTR  ZERO-NO KEY
BUILDTBL EQU   *
         BAL   RTRNM,READ              READ IN RECORD
         LTR   RCODE,RCODE             TAKE CORRECT ACTION
         BNZ   SEEEND                  4(NOT FOUND)
         LA    RWORK,EIGHT(RTBL)       ROOM FOR ENTRY IN TABLE
         C     RWORK,TBLEND
         BNH   ROOM                    YES
         BAL   RTRNM,GETTABLE          NO-GET NEXT TABLE AREA
ROOM     EQU   *
         L     RWORK,KEY
         ST    RWORK,O(RTBL)           STORE OLD LINE NUM
         CR    RNUM,RWORK              OLD LINE NO. LESS THAN KEY
         BNH   NEWNUM                  NO-CHANGE LINE NO.
         ST    RWORK,FOUR(RTBL)        NEW=OLD
UPTBL    EQU   *
         TM    CACFLAG3,CAIMINPT       INPUT LINES ENTERED      YA00040
         BNO   UPTBL2                  NO                       YA00040
         C     RWORK,CAIMLLNO          MATCH
         BNE   UPTBL2                  NO
         MVC   BAIMLLNO(FOUR),FOUR(RTBL)  SAVE FOR RETURN
UPTBL2   EQU   *
         C     RWORK,CACURNUM          MATCH
         BNE   UPTBL3                  NO
         MVC   BACURNUM(FOUR),FOUR(RTBL)  SAVE FOR RETURN
UPTBL3   EQU   *
         LA    RTBL,EIGHT(RTBL)        UPDATE PTR
         MVI   RDPARMS,READNEXT        READ NEXT RECORD
         LA    RWORK,RDKEY
         ST    RWORK,RDKEYPTR          STORE PTR TO KEY IN PARM LIST
         MVC   RDKEY(FOUR),KEY         STORE OLD KEY
         B     BUILDTBL                BUILDTBL
NEWNUM   EQU   *
         AR    RLASTNO,RINCR           NEW=LAST + INCREMENT
         ST    RLASTNO,FOUR(RTBL)      STORE NEW LINE NO. IN TBL
         B     UPTBL                   CONTINUE
SEEEND   EQU   *
         ST    RTBL,TBLEND2            NO-STORE TBL END
         ST    RLASTNO,NEWLAST         SAVE NEW LAST NUMBER
         ST    RINCR,NEWINCR           SAVE NEW INCREMENT
         MVI   RDPARMS,READFST         READ FIRST RECORD
         XC    RDKEYPTR(FOUR),RDKEYPTR  ZERO KEY
RENUM    EQU   *
         BAL   RTRNM,READ              READ IN RECORD
         LTR   RCODE,RCODE             TAKE CORRECT ACTION
         BNZ   FINRENUM                4 NOT FOUND-DONE
         MVC   LASTNUMB(FOUR),KEY      SAVE KEY OF RECORD READ
         LA    RSRC,DATA               PTR TO SOURCE
         LA    RBUFF,DATA2             PTR TO BUFFER
         LH    RCOUNT,LL               LENGTH RECORD
         SH    RCOUNT,THIRTENN         MINUS LENGTH,NUMBER,+1
         TM    CACFLAG2,CARECFM        VARIABLE RECORD
         BO    SEESQU2                 NO-FIXED
         LA    RSRC,EIGHT(RSRC)        YES-UPDATE PTR TO DATA
         LA    RBUFF,EIGHT(RBUFF)      UPDATE PTR IN BUFFER
SEESQU2  EQU   *
         ST    RBUFF,STSRC             SAVE START OF SOURCE(NEW)
         ST    RSRC,STSRCOLD           SAVE START OF SOURCE(OLD)
         MVI   O(RBUFF),BLNK           MOVE IN BLANK
         EX    RCOUNT,BLANKM           PROPAGATE BLANKS
         LA    RCOUNT,ONE(RCOUNT)      CORRECT LENGTH OF DATA
         LA    RWORK,O(RCOUNT,RBUFF)   PTR TO END OF DATA
         ST    RWORK,ENDSRC
SQU      EQU   *
         CLI   O(RSRC),BLNK            BLANK
         BE    SQU32                   YES-OMIT
         MVC   O(ONE,RBUFF),O(RSRC)    NO STORE
         CLI   O(RSRC),QUOTC           QUOTE
         BE    QUOTE                   YES
         CLI   O(RSRC),DQUTC           DOUBLE QUOTE
         BE    QUOTE                   YES
SQU2     EQU   *
         LA    RBUFF,ONE(RBUFF)        UPDATE PTRS
SQU32    EQU   *
         LA    RSRC,ONE(RSRC)
         BCT   RCOUNT,SQU              LOOP
FINSQU   EQU   *
         MVI   GOTOBIT,FLGOF           TURN OFF GO TO STATEMENT FLAG
         L     RBUFF,STSRC             RELOAD PTR TO START OF SOURCE
         CLC   O(FOUR,RBUFF),CGOTO     IS IT GOTO
         BE    GOTO                    YES-CHANGE LINE NO.
         CLC   O(TWO,RBUFF),CIF        IS IT IF
         BE    IF                      YES-CHANGE LINE NO.
         CLC   O(FIVE,RBUFF),CGOSUB    IS IT GOSUB
         BE    GOSUB                   YES-CHANGE LINE NO.
         CLC   O(TEN,RBUFF),CPRUS      IS IT PRINTUSING
         BE    PRU                     YES-CHANGE LINE NO.
         CLC   O(THIRTEEN,RBUFF),CMPRUS IS IT MATPRINTUSING
         BE    MATPRU                  YES-CHANGE LINE NO.
         EJECT
*  THE RECORD, COMPRESSED IN SOME CASES, IS CHANGED BACK
*  TO ITS ORIGINAL FORMAT AND WRITTEN OUT
STOREKEY EQU   *
         MVC   KEY(FOUR),LASTNUMB      LAST KEY
         MVC   KEY2(FOUR),LASTNUMB     LAST KEY
         LA    RSRC,KEY                OLD KEY
         ST    RSRC,RDKEYPTR           PTR TO KEY
         MVC   RDPARMS(FOUR),READCB    PTR TO UTILITY DATA SET
         MVI   RDPARMS,READWKEY        READ KEY
         XC    READPTR,READPTR         LOCATE MODE
         MVI   RDKEYPTR,ENDFLAG        FLAG END
         IKJEBESH  (COMMREG),IKJEBEUT,PARAM=((COMMREG),RDPARMS),       X
               MF=(E,RPLIST)
         B     WRITE1(RCODE)           TAKE CORRECT ACTION
WRITE1   EQU   *
         B     NEXTRNUM                0  GOOD
         B     ERROR                   4  ERROR
         B     IOERR                   8  I/O ERROR
         B     NETHNGLZ                12 INVALID LINE NO
NEXTRNUM EQU   *
         BAL   RTRNM,GETADDR           GET NEXT LINE NUMBER
         L     WRA,ADDKEY              GET KEY
         MVC   KEY2(FOUR),FOUR(WRA)    REPLACE KEY WITH NEW KEY
         MVC   KEY(FOUR),FOUR(WRA)     MOVE NEW KEY INTO NEW RCD
         MVC   LL2(FOUR),LL            MOVE LENGTH
         MVI   DATA2,BLANK             BLANK OUT FIRST BYTE OF BFR
         MVC   DATA2+L1(T55),DATA2     BLANK BUFFER
         LR    WRB,PARMREG1            PTR TO OLD RCD
         BAL   RETREG,POINDATA         GET PTR TO BEG AND END
         LR    OLD,DATPTR              PTR TO BEG OF OLD RCD
         ST    ENDPTR,EOLD             SAVE PTR TO EOD
         LA    WRB,KEY                 PTR TO NEW RCD
         BAL   RETREG,POINDATA         GET PTRS TO BEG AND END OF DATA
         LR    NEW,DATPTR              PTR TO BEG OF NEW RCD
         ST    ENDPTR,ENEW             SAVE END PTR
         LA    WRB,KEY2                PTR TO RCD TO BE BUILT
         BAL   RETREG,POINDATA         GET PTR TO BEG AND END
COMPX    EQU   *
         C     NEW,ENEW                END OF DATA
         BNL   EXOUT                   IF DONE, GO TO EXIT RTN
         C     OLD,EOLD                END OF DATA
         BNL   EXOUT                   IF SO, EXIT
         CLI   O(NEW),ZERO             BYTE LT ZERO
         BL    NOTNUM                  IF SO, BRANCH
         CLI   O(NEW),NINE             BYTE GT NINE
         BH    NOTNUM                  IF SO, BRANCH
         CLI   O(OLD),ZERO             BYTE LT ZERO
         BL    NOTNUM                  IF SO, BRANCH
         CLI   O(OLD),NINE             BYTE GT NINE
         BNH   MOVNXTNM                IF NOT, BRANCH
NOTNUM   EQU   *
         CLC   O(L1,NEW),O(OLD)        COMPARE BYTES
         BNE   NOCOMPX                 IF NOT EQUAL, BRANCH
         CLI   O(OLD),QUOTC            IS CHARACTER A QUOTE
         BE    QPRCX                   IF SO, PROCESS SEPARATELY
         CLI   O(OLD),DQUTC            IS CHARACTER A DOUBLE QUOTE
         BE    QPRCX                   IF SO, PROCESS SEPARATELY
ENQTX    EQU   *                       ENTRY FROM STRING PROC RTN
         MVC   O(L1,DATPTR),O(OLD)     MOVE TO NEW RCD
         LA    NEW,L1(NEW)             INCREMENT PTR
         LA    OLD,L1(OLD)             INCREMENT PTR
         LA    DATPTR,L1(DATPTR)       INCREMENT PTR
INCFAKE  EQU   *
         C     NEW,ENEW                END OF DATA
         BNL   ENDNEW                  IF SO BRANCH
         C     OLD,EOLD                END OF OLD DATA
         BNL   ENDOLD                  IF SO BRANCH
         B     COMPX                   CONTINUE COMPARES
QPRCX    EQU   *                       PROCESS QUOTED STRINGS
         MVC   DELIM,O(OLD)            SAVE TYPE OF QUOTE       YA01202
QPRCX2   EQU   *                                                YA01202
         MVC   O(L1,DATPTR),O(OLD)     MOVE TO NEW RECORD
         LA    OLD,L1(OLD)             INCREMENT OLD PTR
         LA    NEW,L1(NEW)             INCREMENT NEW PTR
         LA    DATPTR,L1(DATPTR)       INCREMENT DATA PTR
         C     OLD,EOLD                END OF DATA
         BNL   TESTNETH                IF SO, TEST IF UNBALANCEDYA01202
*                                        QUOTES ALLOWED         YA01202
         C     NEW,ENEW                END OF DATA              YA01202
         BNL   TESTNETH                IF SO, TEST IF UNBALANCEDYA01202
*                                        QUOTES ALLOWED         YA01202
         CLC   DELIM,O(OLD)            TEST FOR END QUOTE       YA01202
         BE    ENQTX                   IF SO, RETURN TO MAIN CODE
         B     QPRCX2                  IF NOT, CONTINUE SCAN    YA01202
NOCOMPX  EQU   *                       BYTES DID NOT COMPARE
         CLI   O(OLD),BLANK            IS OLD BYTE A BLANK
         BNE   INCNEWQ                 IF NOT, BRANCH
         MVI   O(DATPTR),BLANK         MOVE BLANK INTO BFR
         LA    DATPTR,L1(DATPTR)       INCREMENT PTR
         LA    OLD,L1(OLD)             INCREMENT PTR
         B     INCFAKE                 CONTINUE
INCNEWQ  EQU   *
         CLI   O(NEW),BLANK            IS NEW BYTE A BLANK
         BNE   QUERCHAR                IF NOT, BRANCH
         LA    NEW,L1(NEW)             INCREMENT PTR
         B     INCFAKE                 CONTINUE
QUERCHAR EQU   *
         B     NETHNGLZ                ERROR
CKA      EQU   *
         CLI   0(NEW),ZERO             BYTE A DIGIT
         BL    NETHNGLZ                IF NOT, BRANCH
         CLI   O(NEW),NINE             BYTE A DIGIT
         BH    NETHNGLZ                IF NOT, BRANCH
MOVNXTNM EQU   *
         MVC   O(L1,DATPTR),O(NEW)     MOVE DIGIT
         LA    DATPTR,L1(DATPTR)       INCREMENT PTR
         LA    NEW,L1(NEW)             INCREMENT NEW PTR
         C     NEW,ENEW                END OF DATA
         BNL   ENDNEW                  IF SO EXIT
         CLI   O(NEW),ZERO             IS NEW BYTE LT ZERO
         BL    ENDNEWNM                IF SO, END OF DIGITS
         CLI   O(NEW),NINE             IS BYTE GT NINE
         BH    ENDNEWNM                IF SO, END OF DIGITS
         B     MOVNXTNM                CONTINUE SCAN
ENDNEWNM EQU   *
INCOLRNO EQU   *
         LA    OLD,L1(OLD)
         C     OLD,EOLD                END OF DATA
         BNL   ENDOLD                  IF SO, BRANCH
         CLI   O(OLD),BLANK            BLANK CHAR
         BE    INCOLRNO                IF SO, CONTINUE
         CLI   O(OLD),ZERO             IS BYTE LT ZERO
         BL    ENDLDNM                 IF SO, END OF DIGITS
         CLI   O(OLD),NINE             IS BYTE GT NINE
         BH    ENDLDNM                 IF SO, END OF DIGITS
         B     ENDNEWNM                CONTINUE SCAN
ENDLDNM  EQU   *
         BCTR  OLD,PARMREG0            LOOK AT PREVIOUS BYTE
         CLI   O(OLD),BLANK            WAS IT A BLANK
         BNE   RESOLD                  IF NOT, BRANCH AROUND
         MVI   O(DATPTR),BLANK         ADD BLANK TO RCD
         LA    DATPTR,L1(DATPTR)       INCREMENT PTR
RESOLD   LA    OLD,L1(OLD)             RESET OLD PTR
         B     INCFAKE                 CONTINUE SCAN
TESTNETH EQU   *                                                YA01202
         BAL   RTRNM,TESTUNBQ          TEST IF UNBALANCED QUOTESYA01202
*                                      ALLOWED - RETURN IF NOT  YA01202
WRAPUP   EQU   *
ENDNEW   EQU   *
EXOUT    EQU   *
ENDOLD   EQU   *
         TM    CACFLAG2,CARECFM        FIXED FORMAT
         BZ    VRXX                    IF NOT, BRANCH
         SR    WRA,WRA                 ZERO REGISTER
         IC    WRA,CALENGTH            GET LENGTH OF LINE NUMBER
         LR    ENDPTR,DATPTR           SAVE PTR
         AR    DATPTR,WRA              INCREMENT PTR
         LA    WRA,LL2                 POINT TO LL PART OF RCD
         LH    WRB,O(WRA)              GET LENGTH
         SR    DATPTR,WRA              GET LENGTH
         CR    DATPTR,WRB              COMPARE WITH MAX
         BNH   WRITLST                 IF OKAY, GO TO WRITE RTN
         SR    DATPTR,WRB              GET LENGTH OF OVERFLOW
         BCTR  ENDPTR,PARMREG0         INIT PTR TO LAST BYTE
LOPXC    EQU   *
         CLI   O(ENDPTR),BLANK         IS BYTE A BLANK
         BNE   OFLOMSG                 IF NOT, OVERFLOW
         BCTR  ENDPTR,PARMREG0         DECREMENT PTR
         BCT   DATPTR,LOPXC            LOOP TO SCANN ALL OVERFLOW
         B     WRITLST                 GO TO WRITE RTN
VRXX     EQU   *
         LA    WRA,LL2                 PTR TO LL PART
         LH    WRB,LL2                 LENGTH
         LR    ENDPTR,DATPTR           SAVE PTR
         SR    DATPTR,WRA              GET NEW LENGTH
         CH    DATPTR,CALRECL          IS IT TOO LONG
         BH    BLNKSRCH                IF SO, MAYBE TRUNC
         STH   DATPTR,LL2              SAVE NEW LENGTH
         B     WRITLST                 GO TO WRITE RTN
BLNKSRCH EQU   *
         LH    WRA,CALRECL             MAX LENGTH
         SH    DATPTR,CALRECL          GET OVERFLOW
         BCTR  ENDPTR,PARMREG0         POINT TO LAST BYTE
FNDOF    EQU   *
         CLI   O(ENDPTR),BLANK         IS BYTE A BLANK
         BNE   OFLOVX                  IF NOT, OVERFLOW
         BCTR  ENDPTR,PARMREG0         POINT TO NEXT BYTE
         BCTR  WRA,PARMREG0            DECREMENT COUNT
         BCT   DATPTR,FNDOF            CONTINUE SCAN
         STH   WRA,LL2                 SAVE NEW LENGTH
         B     WRITLST                 GO TO WRITE RTN
OFLOVX   EQU   *
         LH    WRA,CALRECL             MAX LENGTH
         STH   WRA,LL2                 SAVE IN RECORD
         B     OFLOMSG                 WRITE OVERFLOW MSG
WRITLST  EQU   *
         MVC   RDPARMS(FOUR),REDCB     PTR TO NEW UTILITY DS DCB
         MVI   RDPARMS,WRITERCD        WRITE NEW RECORD
         LA    RSRC,KEY2               POINT TO RECORD
         ST    RSRC,RDKEYPTR           PTR TO RCD INTO PARMLIST
         MVI   RDKEYPTR,ENDFLAG        END OF PARMS FLAG
         IKJEBESH (COMMREG),IKJEBEUT,PARAM=((COMMREG),RDPARMS),        X
               MF=(E,RPLIST)
         B     WRITE2(RCODE)           CHECK RETURN CODE
WRITE2   EQU   *
         B     NXXTRNUM                0 NO ERROR
         B     ERROR                   4 ERROR EXIT
         B     IOERR                   8 I/O ERROR
         B     NETHNGLZ                12 NUMBER TOO HIGH
NXXTRNUM EQU   *
         LA    RWORK,RDKEY
         ST    RWORK,RDKEYPTR          STORE PTR TO KEY
         MVC   RDPARMS(FOUR),READCB    SWITCH TO READ DCB
         MVI   RDPARMS,READNEXT        KEY FOR READ NEXT
         MVC   RDKEY(FOUR),LASTNUMB    STORE LAST LINE NO. USED
         B     RENUM                   LOOP THROUGH DATA SET
         EJECT
*  THIS ROUTINE GETS A POINTER TO THE RECORD IN WRB AND RETURNS
*  A POINTER TO THE BEGINNING OF THE DATA PORTION IN DATPTR
*  AND A POINTER TO THE END OF THE DATA PORTION PLUS ONE IN ENDPTR
POINDATA EQU   *
         MVC   LHALF(L2),L4(WRB)       GET
         LH    WRC,LHALF               LENGTH
         LA    WRB,L4(WRB)             INC BY LEN OF KEY
         AR    WRC,WRB                 POINT NEAR END
         TM    CACFLAG1,CANONUM        IS DS NUMBERED
         BZ    NUMBRD                  IF SO PROCESS AS SUCH
         LA    WRB,L4(WRB)             POINT TO BEG OF DATA PORTION
         B     OUTPT                   GO TO EXIT
NUMBRD   EQU   *
         SR    WRA,WRA                 ZERO REG
         IC    WRA,CALINE              GET OFFSET OF LINE NUMBER
         LA    WRD,L1                  IS IT ONE
         CR    WRA,WRD                 IF NUMBER IS AT END
         BNE   LCALDCD                 THEN BRANCH
         IC    WRA,CALENGTH            GET LENGTH OF NUMBER
         AR    WRB,WRA                 INCREMENT BEG PTR BY LEN
         LA    WRB,L4(WRB)             INC TO POINT PAST LL00
         B     OUTPT                   GO TO EXIT
LCALDCD  EQU   *
         LR    WRC,WRB                 PTR TO LL00
         AR    WRC,WRA                 ADD OFFSET OF LINE NUM
         LA    WRC,L3(WRC)             ADD LL00 LEN - 1
         LA    WRB,L4(WRB)             INC BY LEN OF LL00
OUTPT    EQU   *
         LR    DATPTR,WRB              PTR TO BEG OF DATA PORTION
         LR    ENDPTR,WRC              PTR PAST EOD OF RCD
         BR    RETREG                  RETURN TO CALLER
GOTO     EQU   *
         OI    GOTOBIT,GOTOFLAG        TURN ON GO TO FLAG
         L     RWORK,STSRC
         LA    RWORK,FOUR(RWORK)       PTR PAST KEYWD TO NUMBER
GOTO2    EQU   *
         ST    RWORK,LINEPTR           STORE
         BAL   RTRNM,INITBLNK          BLANK BUFFER
         BAL   RTRNM,CHANGE            CHANGE NUMBER
         BAL   RTRNM,STORSRC           SCAN
         L     RWORK,LINEPTR           PTR TO NUMBER
         AH    RWORK,SRCLGTH           PTR TO NUMBER
         TM    GOTOBIT,GOTOFLAG        IS IT A GO TO STATEMENT
         BZ    NOGOTO                  BR NO
         CLI   O(RWORK),COMA           IS THIS COMPUTED GOTO
         BE    COMPUTED                IF COMPUTED GOTO BRANCH
         CLC   O(TWO,RWORK),CHON       COMPUTED GOTO
         BE    COMPUTE2                YES
NOGOTO   EQU   *
SEELGTH  EQU   *
         S     RBUFF,STSRCOLD          CALC NEW LENGTH
         LA    RWORK,TWELVE(RBUFF)     FOR NUMBER, LENGTH
         TM    CACFLAG2,CARECFM        IS IT VARIABLE
         BO    FIXED                   IF FIXED, BRANCH
         CH    RWORK,TWO55             IS IT TOO BIG
         BH    NETHNGLZ                IF SO, BRANCH
         STH   RWORK,LL                STORE NEW LGTH
         B     STOREKEY                WRITE RCD AND CONTINUE
FIXED    EQU   *
         LH    RLGTH,LL                LENGTH OF RECORD
         CR    RWORK,RLGTH             LINE TOO BIG
         BH    NETHNGLZ                IF SO, BRANCH
         B     STOREKEY                WRITE RECORD AND CONTINUE
CHANGE   EQU   *                       CHANGE OLD SOURCE NUMBER
*
*        THE FOLLOWING ROUTINE CONVERTS THE EBCDIC LINE NUMBER FROM
*        THE SOURCE AND RETURNS THE UPDATED EBCDIC NUMBER FOR THE
*        CORRESPONDING NEW LINE NUMBER
*
         L     RWORK,LINEPTR
         LR    RLGTH,RWORK
CCHANGE  EQU   *
         C     RLGTH,ENDSRC            AT END
         BNL   FNDNUM                  YES-DONE WITH NUMBER
         CLI   O(RLGTH),C'0'           DIGIT
         BL    FNDNUM                  BR NO
         CLI   O(RLGTH),C'9'           DIGIT
         BH    FNDNUM                  NO
         LA    RLGTH,ONE(RLGTH)        INCREMENT LENGTH
         B     CCHANGE                 BR TO CHARACTER CHANGE
FNDNUM   EQU   *
         SR    RLGTH,RWORK             CALC LENGTH OLD SRCE NUMBER
         STH   RLGTH,SRCLGTH           STORE
         LTR   RLGTH,RLGTH             VALID LINE NUMBER
         BNP   NETHNGLZ                NO-ERROR
         CH    RLGTH,NUM8              VALID LENGTH
         BH    NETHNGLZ                NO-ERROR
         BCTR  RLGTH,O                 SUB 1 FOR EX
         EX    RLGTH,PACKN             PACK ORIGINAL SOURCE NUM
         CVB   R0,DOUBLE               CONVERT TO BINARY
         XC    TABNO+L4(TWO),TABNO+L4  ZERO NUM TABLES USES
         MVI   DEFINED,FLGOF           INIT-NUMBER NOT DEFINED
BGNSCAN  EQU   *
         B     SCANTBL                 GET ADDRESS OF TABLE
SCANNUM  EQU   *
         C     R0,O(RTBL)              ENTRIES EQUAL
         BE    FNDENTRY                YES
SCANNUM2 EQU   *
         LA    RTBL,EIGHT(RTBL)        UPDATE
         C     RTBL,TBLEND             AT END
         BL    SCANNUM                 NO-CONTINUE
         CLC   TABNO(TWO),TABNO+L4     LAST TABLE
         BNE   BGNSCAN                 NO-CONTINUE
         TM    DEFINED,EIGTY           DEFINED
         BZ    NETHNGLZ                NO-ERROR
         L     RWORK,DOUBLE            LOAD NEW NUMBER
         CVD   RWORK,DOUBLE
         UNPK  LINENUM(EIGHT),DOUBLE(EIGHT)  NEW NUMB NOW IN LINENUM
         LA    RLGTH,EIGHT
         LA    RWORK,LINENUM           PTR TO NUMBER
SCANZERO EQU   *
         CLI   O(RWORK),C'0'           LEADING ZERO
         BNE   SIZEDONE                NO
         LA    RWORK,ONE(RWORK)        UPDATE TO NEXT
         BCT   RLGTH,SCANZERO          DECREMENT LENGTH-CONTINUE
         LA    RLGTH,ONE               ALL ZERO-STORE ONE
         BCTR  RWORK,O                 PT TO LAST DIGIT
SIZEDONE EQU   *
         OI    LINENUM+L7,MASK1        CHANGE SIGN
         STH   RLGTH,NEWLGTH           STORE LENGTH NEW NUMBER
         MVC   LINENUM(EIGHT),O(RWORK) MOVE OVER LEADING ZERO
         BR    RTRNM                   RETURN
FNDENTRY EQU   *
         TM    DEFINED,EIGTY           DEFINED ALREADY
         BO    NETHNGLZ                YES-DEFINED TWICE
         OI    DEFINED,EIGTY           SET FLAG-DEFINED
         MVC   DOUBLE(FOUR),FOUR(RTBL) SAVE NEW NUMBER
         B     SCANNUM2                CONTINUE SCAN FOR DUPLICATES
GOSUB    EQU   *
         L     RWORK,STSRC             PTR TO SQUEEZED SOURCE
         LA    RWORK,FIVE(RWORK)       PTR TO NUMBER
         B     GOTO2                   CHANGE/STORE
STORSRC  EQU   *                       STORE START OF SOURCE/FIRST NUMB
*
*        THE FOLLOWING ROUTINE STORES THE OLD SOURCE UP TO THE LINE
*        NUMBER THAT WAS CONVERTED
         L     RSRC,STSRC              PTR TO SQUEEZED SOURCE
         L     RBUFF,STSRCOLD          PTR TO OLD DATA AREA
         L     RLGTH,LINEPTR           PTR TO NUMBER
         SR    RLGTH,RSRC
         BCTR  RLGTH,O                 MINUS 1 FOR EX
         EX    RLGTH,COPYSRC           COPY
         LA    RWORK,ONE(RBUFF,RLGTH)  UPDATE TO NEXT
STORNEWN EQU   *
*
*        THE FOLLOWING ROUTINE STORES THE NEW LINE NUMBER IN THE
*        CONVERTED SOURCE
*
         MVI   O(RWORK),BLNK           NEXT CHAR=BLANK
         LH    RLGTH,NEWLGTH           LENGTH NEW NUMBER
         BCTR  RLGTH,O                 MINUS 1 FOR EX
         EX    RLGTH,STORNUM           STORE NEW NUMBER
         LA    RBUFF,TWO(RWORK,RLGTH)  UPDATE PAST BLANK,NUMBER
         BR    RTRNM                   RETURN
IF       EQU   *
         L     RWORK,STSRC             CALC PTR TO END OF SOURCE
         AH    RWORK,LL                OLD LENGTH
         SH    RWORK,THIRTENN          PTR TO LAST CHARACTER
NEXTIF   EQU   *
         CLI   O(RWORK),BLNK           BLANK
         BNE   NEXTIF3                 NO-FOUND DIGIT
         BCT   RWORK,NEXTIF            DECREMENT PTR-CONTINUE
NEXTIF2  EQU   *
         CLI   O(RWORK),C'0'           DIGIT
         BNL   NEXTIF4                 YES-CONTINUE
NEXTIF5  EQU   *
         LA    RWORK,ONE(RWORK)        RESET PTR TO FIRST DIGIT OF NUM
         B     GOTO2                   CONVERT AND CHANGE
NEXTIF4  EQU   *
         CLI   O(RWORK),C'9'           DIGIT
         BH    NEXTIF5                 NO-END OF NUMB
NEXTIF3  EQU   *
         BCT   RWORK,NEXTIF2           CONTINUE
PRU      EQU   *
         LA    RWORK,TEN               NUMBER OF KEY CHARACTERS
PRU2     EQU   *
         A     RWORK,STSRC             PAST KEY WORDS
         ST    RWORK,LINEPTR           STORE PTR TO NUMBER
         BAL   RTRNM,INITBLNK          INIT BUFFER TO BLANKS
         BAL   RTRNM,CHANGE            CONVERT NUMBER
         BAL   RTRNM,STORSRC           STORE KEY WDS, NUMBER
*                                      RBUFF POINTS TO NEXT FREE CHAR
STOREEND EQU   *
*
*        THE FOLLOWING ROUTINE STORES THE OLD SOURCE FROM THE LAST
*        LINE NUMBER THAT WAS CONVERTED UP TO THE END
*
         L     RSRC,LINEPTR            PTR. TO NUMBER
         AH    RSRC,SRCLGTH            PTR PAST OLD SOURCE
         LH    RLGTH,LL                CALC NUM CHARS STILL TO STORE
         SH    RLGTH,TWELVEN           NUMBER/LENGTH
         LR    RWORK,RSRC
         S     RWORK,STSRC             NUM CHARS. USED
         SR    RLGTH,RWORK             NUM CHARS. LEFT
         CH    RLGTH,NUM0              ANY LEFT
         BE    SEELGTH                 NO
         BCTR  RLGTH,O                 SUB1
         EX    RLGTH,COPYEND           STORE END
         LA    RBUFF,ONE(RLGTH,RBUFF)  PTR TO NEXT FREE
*                                      ELIMINATE TRAILING BLANKS
BLNKLOOP EQU   *
         BCTR  RBUFF,O                 PT AT CHAR
         CLI   O(RBUFF),BLNK           BLANK
         BE    BLNKLOOP                YES-CONTINUE
         LA    RBUFF,ONE(RBUFF)        UPDATE TO NEXT FREE
         B     SEELGTH                 SEE IF ROOM
MATPRU   EQU   *
         LA    RWORK,THIRTEEN          NUMBER OF KEY CHARACTERS
         B     PRU2                    GET NEW POINTER
COMPUTED EQU   *
         MVI   O(RBUFF),COMA           INIT FIRST COMMA
         LA    RBUFF,ONE(RBUFF)        UPDATE TO NEXT FREE BUFFER CHAR
         ST    RBUFF,FREE              SAVE FREE PTR
         LA    RWORK,ONE(RWORK)        UPDATE TO NUMBER
         ST    RWORK,LINEPTR           STORE PTR TO NUMBER
         BAL   RTRNM,CHANGE            CALL NEW REFERENCE
         L     RWORK,FREE              LOAD PTR TO NEXT FREE BYTE
         BAL   RTRNM,STORNEWN          STORE NEW REFERENCE
         C     RBUFF,STSRC             PAST MAX  (WAY PAST)
         BNL   NETHNGLZ                YES
         L     RWORK,LINEPTR           PTR TO NUMBER JUST STORED
         AH    RWORK,SRCLGTH           +LENGTH OLD NUMBER
         CLI   O(RWORK),COMA           MORE
         BE    COMPUTED                YES
COMPUTE2 EQU   *
*                                      NO-COPY END OF SOURCE
         LA    RBUFF,ONE(RBUFF)        ADD BLANK
         B     STOREEND                STORE AND CHECK
QUOTE    EQU   *
         MVC   DELIM(ONE),O(RSRC)      SAVE DELIM
QUOTE1   BCT   RCOUNT,QUOTE2           UPDATE LENGTH LEFT       YA01202
*                                      UNBALANCED QUOTE FOUND   YA01202
         BAL   RTRNM,TESTUNBQ          TEST FOR UNBALANCED      YA01202
*                                      QUOTES ALLOWED - RETURN  YA01202
*                                      IF NOT                   YA01202
         B     FINSQU                  UNBALANCED QUOTES ALLOWEDYA01202
QUOTE2   EQU   *
         LA    RSRC,ONE(RSRC)          UPDATE PAST QUOTE
         LA    RBUFF,ONE(RBUFF)
         MVC   O(ONE,RBUFF),O(RSRC)    SAVE CHAR
         CLC   O(ONE,RSRC),DELIM       DELIM
         BNE   QUOTE1                  IF NOT, CONTINUE         YA01202
         B     SQU2                    END OF STRING            YA01202
TESTUNBQ EQU   *                                                YA01202
         L     REG1,STSRC              SET PTR TO STATEMENT     YA01202
         CLC   O(L'END,REG1),END       TEST FOR END STATEMENT   YA01202
         BCR   EIGHT,RTRNM             END ALLOWS UNBAL. QUOTES YA01202
         CLI   O(REG1),IMAGE           TEST FOR IMAGE STATEMENT YA01202
         BCR   EIGHT,RTRNM             IMAGE ALLOWS UNBAL. QTES.YA01202
         CLC   O(L'PAUSE,REG1),PAUSE   TEST FOR PAUSE STATEMENT YA01202
         BCR   EIGHT,RTRNM             PAUSE ALLOWS UNBAL. QTES.YA01202
         CLC   O(L'REM,REG1),REM       TEST FOR REM STATEMENT   YA01202
         BCR   EIGHT,RTRNM             REM ALLOWS UNBAL. QTES.  YA01202
         CLC   O(L'RESTORE,REG1),RESTORE TEST FOR RESTORE STMT. YA01202
         BCR   EIGHT,RTRNM             RESTORE ALLOWS UNBAL.    YA01202
*                                      QUOTES                   YA01202
         CLC   O(L'RETURN,REG1),RETURN TEST FOR RETURN STATEMENTYA01202
         BCR   EIGHT,RTRNM             RETURN ALLOWS UNBAL QTES.YA01202
         CLC   O(L'STOP,REG1),STOP     TEST FOR STOP STATEMENT  YA01202
         BCR   EIGHT,RTRNM             STOP ALLOWS UNBAL. QUOTESYA01202
         B     NETHNGLZ                ELSE, BAD CHAR. STRING   YA01202
READ     EQU   *
*                                      READ IN RELOAD
         LA    RWORK,REINAREA          ADDRESS TO READ INTO
         ST    RWORK,READPTR           STORE
         MVI   READPTR,ENDFLAG         SET END PTR
         IKJEBESH  (COMMREG),IKJEBEUT,PARAM=((COMMREG),RDPARMS),       X
               MF=(E,RPLIST)
         CH    RCODE,NUM8              I/O ERROR
         BE    IOERR                   YES
         BR    RTRNM                   NO-CONTINUE
GETTABLE EQU   *
*
*        THE FOLLOWING ROUTINE ALLOCATES THE RENUMBER TABLE
*
*                                      ALLOCATE TABLE-500 ENTRIES
         LH    RWORK,TABNO             NUM TO DATE
         SLL   RWORK,THREE             MULT BY 8(LENGTH EACH ENTRY)
         LA    RTBL,TBLADDR(RWORK)     ADDRESS FIRST TABLE / LENGTH
         GETMAIN VC,LA=MINSIZ,A=(RTBL),SP=1,MF=(E,RPLIST)        A45103
         CH    RCODE,NUM0              SUCCESS
         BNE   NOTABLE                 NO-ERROR
         LH    RWORK,TABNO             NUM PREVIOUS
         LA    RCODE,ONE(RWORK)        UPDATE
         STH   RCODE,TABNO             STORE UPDATED NUMBER
         L     RWORK,FOUR(RTBL)        LENGTH
         A     RWORK,O(RTBL)           +START ADDRESS=END
         ST    RWORK,TBLEND            STORE END OF TABLE
         ST    RWORK,FOUR(RTBL)
         L     RTBL,O(RTBL)            LOAD ADDRESS TABLE
         BR    RTRNM                   RETURN
GETADDR  EQU   *
*
*        THE FOLLOWING ROUTINE RETURNS THE NEXT NEW LINE NUMBER
*
         CLC   ADDKEY(FOUR),NUM0       FIRST TIME
         BNE   GETADDR2                NO-CONTINUE
         MVI   TABNO+THREE,MASK2       INIT -ONE USED
         MVC   ADDKEY(FOUR),TBLADDR    ADDRESS FIRST TABLE
         BR    RTRNM                   RETURN
GETADDR2 EQU   *
         L     RTBL,ADDKEY             PREVIOUS ADD.
         LA    RTBL,EIGHT(RTBL)        PTR TO NEXT ENTRY
         LH    RWORK,TABNO+TWO         NUM USED
         CH    RWORK,TABNO             ON LAST
         BL    GETADDR3                NO
         C     RTBL,TBLEND2            AT END
         BNL   NEXTTBL2                YES-ERROR
         B     STORADDR                CONTINUE
GETADDR3 EQU   *
         BCTR  RWORK,O                 LOOK AT CURRENT
         SLL   RWORK,THREE             MULT BY 8 (FOR EACH ENTRY)
         C     RTBL,TBLADDR+FOUR(RWORK) END OF TBL
         BL    STORADDR
         LH    RWORK,TABNO+TWO
         LA    RWORK,ONE(RWORK)
         STH   RWORK,TABNO+TWO
         BCTR  RWORK,0
         SLL   RWORK,3
         L     RTBL,TBLADDR(RWORK)
         B     STORADDR
STORADDR EQU   *
         ST    RTBL,ADDKEY             STORE
         BR    RTRNM                   RETURN
INITBLNK EQU   *                       INIT BUFFER TO BLANKS
         L     RSRC,STSRCOLD           PTR TO SOURCE AREA
         MVI   O(RSRC),BLNK            MOVE IN BLANK
         MVC   ONE(T55,RSRC),O(RSRC)   SET TO BLANK
         BR    RTRNM                   RETURN
SCANTBL  EQU   *
         LH    RWORK,TABNO+FOUR        NO. USED SO FAR
         LA    RWORK,ONE(RWORK)        UPDATE
         STH   RWORK,TABNO+FOUR        STORE
         BCTR  RWORK,O                 RESTORE ORIGINAL COUNT
         SLL   RWORK,THREE             MULTIPLY BY 8-PTR TO NEXT ENTRY
         L     RTBL,TBLADDR(RWORK)     START OF TABLE
         CLC   TABNO(TWO),TABNO+FOUR   ALL USED
         BE    SCANTBL2                YES
         LA    RWORK,TBLADDR+FOUR(RWORK) PTR END OF TABLE ENTRY
         MVC   TBLEND(FOUR),O(RWORK)   STORE END ADDRESS
         B     SCANNUM                 RETURN
SCANTBL2 EQU   *
         MVC   TBLEND(FOUR),TBLEND2    END OF TABLE
         B     SCANNUM                 RETURN
FINRENUM EQU   *                       FINISHED-FREE BLOCKS
         LH    RCOUNT,TABNO            NUM TABLES ALLOCATED
         LTR   RCOUNT,RCOUNT           ANY TABLES
         BZ    FINISH                  NO
         LA    RTBL,TBLADDR            ADDRESS FIRST TABLE STORED HERE
FREELOOP EQU   *
         L     RWORK,FOUR(RTBL)        END OF TABLE
         S     RWORK,O(RTBL)           END-START=LENGTH
         ST    RWORK,FOUR(RTBL)        STORE LENGTH
         FREEMAIN V,A=(RTBL),SP=1,MF=(E,RPLIST)                  A45103
         LA    RTBL,EIGHT(RTBL)        UPDATE TO NEXT ENTRY
         BCT   RCOUNT,FREELOOP         BRANCH TO CONTINUE
FINISH   EQU   *
         LH    RCODE,RTNCODE           RETURN CODE
         LTR   RCODE,RCODE             RETURN CODE = 0
         BNE   RTNBAD                  NO
         L     RWORK,INCR              INCREMENT
         ST    RWORK,CAINCRE           UPDATE
         ST    RWORK,CAIMLINC          UPDATE
         MVC   CAIMLLNO(FOUR),BAIMLLNO UPDATE
         MVC   CACURNUM(FOUR),BACURNUM UPDATE
RTNBAD   EQU   *
         IKJEBERT (14,12),RC=(15)
         SPACE
***********************************************************************
*                                                                     *
*        SEND MESSAGE TO TERMINAL USER                                *
*                                                                     *
***********************************************************************
SENDERR  EQU   *
         IKJEBEML ,,,,MF=(E,RPLIST)
         SPACE
         TM    ERRBITS,EXIT            CONTINUE
         BO    WRITLST                 BR YES
         B     ERROR                   BR TO END PROCESSING
         EJECT
***********************************************************************
*                                                                     *
*        MESSAGE 312                                                  *
*                                                                     *
***********************************************************************
NOTABLE  EQU   *
         XC    RPLIST(K40),RPLIST      INIT PARMLIST TO 0
         MVC   LEVEL1(TWO),RM312       SET UP LEVEL1 PARMLIST
         MVC   INS1(RMGL),RMG          SET UP INSERTION PARMLIST
         NI    ERRBITS,FLGOF           TURN OFF CONTINUE FLAG
CHAIN    EQU   *
         LA    WRA,INS1                CHAIN INSERTION1 PARMLIST
         ST    WRA,LEV1IN              TO LEVEL1 PARMLIST
         B     SENDERR                 BR TO SEND MESSAGE TO USER
         SPACE
***********************************************************************
*                                                                     *
*        MESSAGE 503                                                  *
*                                                                     *
***********************************************************************
NOTCOMPT EQU   *
         XC    RPLIST(K40),RPLIST      INIT PARMLIST TO 0
         MVC   LEVEL1(TWO),RM503       SET UP LEVEL1 PARMLIST
         NI    ERRBITS,FLGOF           TURN OFF CONTINUE FLAG
         B     SENDERR                 BR TO SEND MESSAGE TO USER
         SPACE
***********************************************************************
*                                                                     *
*        MESSAGE 504                                                  *
*                                                                     *
***********************************************************************
NOTFOUND EQU   *
         XC    RPLIST(K40),RPLIST      INIT PARMLIST TO 0
         MVC   LEVEL1(TWO),RM504       SET UP LEVEL1 PARMLIST
         MVI   INS1O,M504IN1           PTR TO INSERTION PT
         L     WRA,RDKEY               BINARY KEY OF RCD
         BAL   RTRNM,CNVSTRP           BR TO CONVERT AND STRIP
         NI    ERRBITS,FLGOF           TURN OFF CONTINUE FLAG
         B     CHAIN                   BR TO CHAIN PARMLISTS
         SPACE
***********************************************************************
*                                                                     *
*        MESSAGE 507                                                  *
*                                                                     *
***********************************************************************
OFLOMSG  EQU   *
         XC    RPLIST(K40),RPLIST      INIT PARMLIST TO 0
         MVC   LEVEL1(FOUR),RM507      SET UP LEVEL1 PARMLIST
         L     WRA,DOUBLE              NUMBER TO BE CONVERTED
         BAL   RTRNM,CNVSTRP           BR TO CONVERT AND STRIP
         LH    WRA,INS1L               THE CONVERTED NUMBER (LINE LEN)
         BCTR  WRA,O                   IS IN INSERTION2. THE CONVERT
         EX    WRA,IN2MVC              ROUTINE HAS SET IT UP AS INSERT-
*                                      TION1. AN MVC IS DONE TO MOVE
*                                      THE INSERTION1 PARMLIST TO THE
*                                      INSERTION2 PARMLIST.
         MVI   INS1O,M507IN1           PTR TO INSERTION PT
         MVI   INS2O,M5071IN1          PTR TO INSERTION PT
         L     WRA,KEY2                NUMBER TO BE CONVERTED
         BAL   RTRNM,CNVSTRP           BR TO CONVERT AND STRIP
         LA    WRA,INS2                CHAIN INSERTION2 PARMLIST TO
         ST    WRA,LEV2IN              LEVEL1 PARMLIST
         OI    ERRBITS,EXIT            SET FLAG TO INDICATE CONTINUE
         B     CHAIN                   BR TO CHAIN INSERTION1 PARMLIST
         SPACE
**********************************************************************
*                                                                    *
*        MESSAGE 565                                                 *
*                                                                    *
**********************************************************************
NETHNGLZ EQU   *
         XC    RPLIST(K40),RPLIST      INIT PARMLIST TO 0
         MVC   LEVEL1(FOUR),RM565      SET UP LEVEL1 PARMLIST
         MVI   INS1O,M565IN1           PTR TO INSERTION PT
         L     WRA,LASTNUMB            NUMBER TO BE CONVERTED
         BAL   RTRNM,CNVSTRP           BR TO CONVERT AND STRIP
         NI    ERRBITS,FLGOF           TURN OFF CONTINUE FLAG
         B     CHAIN                   BR TO CHAIN PARMLISTS
         SPACE
***********************************************************************
*                                                                     *
*        THIS SUBROUTINE CONVERTS A NUMBER IN REGISTER WRA            *
*        TO DECIMAL. THE LEADING ZEROES ARE THEN STRIPPED             *
*        OFF THE NUMBER AND THE INSERTION PARAMETER LIST              *
*        IS SET UP.                                                   *
*                                                                     *
***********************************************************************
CNVSTRP  EQU   *
         CVD   WRA,DOUBLE              CONVERT NUMBER TO DECIMAL
         UNPK  IN1(EIGHT),DOUBLE+L3(FIVE) UNPK INTO INSERTION1
         OI    IN1+L7,MASK1            INSURE LAST DIGIT IS CHAR
         LA    WRC,EIGHT               MAXIMUM
         LA    WRB,IN1                 INSERTION
FLOOP    EQU   *
         CLI   O(WRB),ZERO             IS DIGIT A CHARACTER ZERO
         BNE   FOUND                   BR NO
         LA    WRB,ONE(WRB)            INCREMENT DISPLACEMENT
         BCT   WRC,FLOOP               LOOP THROUGH INSERTION
         MVI   IN1,ZERO                NUMBER IS 0
         B     ADDX                    BR TO INC COUNT
FOUND    EQU   *
         BCTR  WRC,O                   MINUS 1 FOR EX
         EX    WRC,INSRTMVC            MOVE TO STRIP LEADING ZEROES
ADDX     LA    WRC,FIVE(WRC)           OFFSET + 1 FOR EX
SAVEL    EQU   *
         STH   WRC,INS1L               LENGTH OF INSERTION
         BR    RTRNM                   RETURN TO CALLER
         SPACE
***********************************************************************
*                                                                     *
*        I/O ERROR OCCURRED                                           *
*                                                                     *
***********************************************************************
IOERR    EQU   *
         LA    WRA,EIGHT               SET RETURN CODE TO 8
         STH   WRA,RTNCODE             SAVE RETURN CODE
         B     FINRENUM                BR TO END PROCESSING
         SPACE
***********************************************************************
*                                                                     *
*        ERROR ROUTINE                                                *
*                                                                     *
***********************************************************************
ERROR    EQU   *                       IMPOSSIBLE ERROR
NEXTTBL2 EQU   *                       ERROR
         LA    WRA,FOUR                SET RETURN CODE TO 4
         STH   WRA,RTNCODE             SAVE RETURN CODE
         B     FINRENUM                BR TO END PROCESSING
         EJECT
RMG      IKJEBEMG 0,M312IN1,'RENUM'
RMGL     EQU   *-RMG
         SPACE
RM312    DC    AL2(M312)               RELATIVE LEVEL1 MESSAGE NUM
RM503    DC    AL2(M503)               RELATIVE LEVEL1 MESSAGE NUM
RM504    DC    AL2(M504)               RELATIVE LEVEL1 MESSAGE NUM
RM507    DC    AL2(M507)               RELATIVE LEVEL1 MESSAGE NUM
         DC    AL2(M5071)              RELATIVE LEVEL2 MESSAGE NUM
RM565    DC    AL2(M565)               RELATIVE LEVEL1 MESSAGE NUM
         DC    AL2(M5651)              RELATIVE LEVEL2 MESSAGE NUM
         SPACE
PACKN    PACK  DOUBLE(EIGHT),O(O,RWORK) PACK ORIGINAL SOURCE NUMBER
COPYSRC  MVC   O(O,RBUFF),O(RSRC)      MOVE DATA BACK TO INPUT AREA
STORNUM  MVC   ONE(O,RWORK),LINENUM    COPY NEW LINE NUMBER
COPYEND  MVC   O(O,RBUFF),O(RSRC)      COPY REST OF INPUT
BLANKM   MVC   ONE(O,RBUFF),O(RBUFF)   INIT BUFFER TO BLANK
INSRTMVC MVC   IN1(O),0(WRB)           STRIP LEADING ZEROES
IN2MVC   MVC   INS2(O),INS1            MOVE INSERT1 PLIST TO INSERT2
MOVEROLD MVC   O(O,DATPTR),O(OLD)      MOVE OLD DATA
MOVERNEW MVC   O(O,DATPTR),O(NEW)      MOVE NEW DATA
         SPACE
MININUM  DC    F'400'                  MINIMUM SIZE-50 STATE
         DC    F'4000'                 MAX WANTED AT ONE TIME
NUM0     DC    F'0'                    0
NUM1     DC    H'1'                    1
NUM2     DC    H'2'                    2
NUM5     DC    H'5'                    5
NUM8     DC    H'8'                    8
TWELVEN  DC    H'12'                   12
THIRTENN DC    H'13'                   13
TWO55    DC    H'255'                  255
CHON     DC    C'ON'                   KEYWORD CONSTANT
CGOTO    DC    C'GOTO'                 KEYWORD CONSTANT
CIF      DC    C'IF'                   KEYWORD CONSTANT
CGOSUB   DC    C'GOSUB'                KEYWORD CONSTANT
CPRUS    DC    C'PRINTUSING'           KEYWORD CONSTANT
CMPRUS   DC    C'MATPRINTUSING'        KEYWORD CONSTANT
END      DC    C'END'                  END STATEMENT            YA01202
IMAGE    EQU   C':'                    FIRST CHAR OF IMAGE STMT.YA01202
PAUSE    DC    C'PAUSE'                PAUSE STATEMENT          YA01202
REM      DC    C'REM'                  REM STATEMENT            YA01202
RESTORE  DC    C'RESTORE'              RESTORE STATEMENT        YA01202
RETURN   DC    C'RETURN'               RETURN STATEMENT         YA01202
STOP     DC    C'STOP'                 STOP STATEMENT           YA01202
         SPACE
         IKJEBEMI (312,503,504,507,565)
         EJECT
         IKJEBECA
         EJECT
REDCB    EQU CAPTPDCB                  PTR TO UTILITY DATA SET
         ORG   CASRWKA                 WORK AREA
         SPACE
TBLADDR  DS    6F                      START TABLE/END TABLE
MINSIZ   DS    2F                      GETMAIN SIZE SPECIFICATIONS
TBLEND2  DS    F                       WPRD FIELD
NEWLAST  DS    F                       NEW LAST NUMBER
NEWINCR  DS    F                       NEW INCREMENT
TABNO    DS    6X                      NUM TABLES/NUM USED/NUM USED FOR
*                                      SCAN
RPLIST   DS    10F                     WORK SPACE FOR MACROS
LEVEL1   EQU   RPLIST                  LEVEL1 AND LEVEL2 MSG NUMBERS
LEV1IN   EQU   LEVEL1+4                PTR TO INSERTION1 PARMLIST
LEV2IN   EQU   LEVEL1+8                PTR TO INSERTION2 PARMLIST
INS1     EQU   LEVEL1+12               PTR TO NEXT INSERTION
INS1L    EQU   INS1+4                  INSERTION1 LENGTH
INS1O    EQU   INS1+7                  INSERTION1 OFFSET
IN1      EQU   INS1+8                  INSERTION1
INS2     EQU   IN1+8                   PTR TO NEXT INSERTION
INS2L    EQU   INS2+5                  INSERTION2 LENGTH
INS2O    EQU   INS2+7                  INSERTION2 OFFSET
IN2      EQU   INS2+8                  INSERTION2
         SPACE
*        3F    IKJEBEUT PARM LIST
RDPARMS  DS    F                       PTR TO DATA SET(KEY IN BYTE 1)
RDKEYPTR DS    F                       PTR TO KEY
READPTR  DS    F                       PTR TO INPUT AREA
*
RDKEY    DS    F                       STORE KEY
ADDKEY   DS    F                       WORK WORD
TBLEND   DS    F                       WORK WORD
STSRC    DS    F                       PTR TO START SQUEEZED SOURCE
STSRCOLD DS    F                       PTR TO START OF DATA IN INPUT
LINEPTR  DS    F                       PTR TO NUMBER TO BE CHANGED
ENDSRC   DS    F                       PTR TO END OF DATA
EOLD     DS    F                       END OF OLD DATA PORTION
*        PARAMETERS PASSED
DOUBLE   EQU   *
OLDNUMB  DS    F                       NUMB AT WHICH TO START RENUM
STLINENO DS    F                       NEW FIRST NUMBER
INCR     DS    F                       INCREMENT
*
LASTNUMB DS    F                       LAST NUMBER READ IN
READCB   DS    F                       PTR TO DATA SET TO READ IN
FREE     DS    F                       PTR TO NEXT FREE LOCATION
BAIMLLNO DS    F                       SAVE NEW CACURNUM
BACURNUM DS    F                       SAVE NEW CACURNUM
SRCLGTH  DS    H                       LENGTH OF LINE REFERENCE IN INP.
NEWLGTH  DS    H                       LENGTH OF NEW LINE REFERENCE
RTNCODE  DS    H                       RETURN
LHALF    DS    H                       HALFWORD FOR LL ALIGNMENT
LINENUM  DS    8X                      NEW NUMBER
ERRBITS  DS    X                       FLAGS FOR ERROR MSGS
DELIM    DS    X                       QUOTE OR DOUBLE QUOTE
DEFINED  DS    X                       WORKSPACE-DEFINED/NOT DEFINED
GOTOBIT  DS    X                       FLAG-GOTO STATEMENT
ENEW     DS    F                       END OF NEW DATA
         ORG   ,                       RESUME CSECT
REINAREA EQU   CATEMPBF                TEMP BFR
KEY      EQU   REINAREA
LL       EQU   REINAREA+4
DATA     EQU   REINAREA+8
ERRMSG   EQU   DATA                    ERROR MSG BUFFER
RDBUFF2  EQU   REINAREA+264
KEY2     EQU   RDBUFF2
LL2      EQU   RDBUFF2+4
DATA2    EQU   RDBUFF2+8
         EJECT
*        REGISTER EQUATES
R0       EQU   0                       WORK REG
PARMREG0 EQU   0                       0 PARM
PARMREG1 EQU   1                       1 PARM
REG1     EQU   1                       WORK REG
RWORK    EQU   2                       WORK REG
WRA      EQU   2                       WORK REG
RCOUNT   EQU   3                       USED FOR SQUEEZE
RLGTH    EQU   3                       CONVERTING/STORE NUMBER
WRB      EQU   3                       WORK REG
RTBL     EQU   4                       OLD/NEW TABLE PTR
WRC      EQU   4                       WORK REG
RSRC     EQU   5                       PTR TO SOURCE READ IN
RINCR    EQU   5                       INCREMENT
WRD      EQU   5                       WORK REG
RBUFF    EQU   6                       PTR TO WORK BUFFER
RLASTNO  EQU   6                       LAST NUMBER USED
DATPTR   EQU   6                       DATA POINTER
RNUM     EQU   7                       OLD LINE NUMBER
OLD      EQU   7                       OLD DATA POINTER
RTRNM    EQU   8                       USED FOR LINKAGE
NEW      EQU   8                       NEW DATA POINTER
COMMREG  EQU   9                       PTR TO COMMUNICATION AREA
ENDPTR   EQU   10                      PTR TO END OF DATA
BASEREG  EQU   11                      BASE REGISTER
DATAREG  EQU   12                      NOT USED
SAVEREG  EQU   13                      PTR TO SAVE AREA
RETREG   EQU   14                      RETURN REG
RETCDREG EQU   15                      BRANCH/RETURN CODES
RCODE    EQU   15                      RETURN CODE ON I/O REQUESTS
         EJECT
*        NUMERIC EQUATES
O        EQU   0                       CONSTANT 0
ONE      EQU   1                       CONSTANT 1
L1       EQU   1                       CONSTANT 1
TWO      EQU   2                       CONSTANT 2
L2       EQU   2                       CONSTANT 2
THREE    EQU   3                       CONSTANT 3
L3       EQU   3                       CONSTANT 3
FOUR     EQU   4                       CONSTANT 4
L4       EQU   4                       CONSTANT 4
FIVE     EQU   5                       CONSTANT 5
SIX      EQU   6                       CONSTANT 6
L7       EQU   7                       CONSTANT 7
EIGHT    EQU   8                       CONSTANT 8
TEN      EQU   10                      CONSTANT 10
TWELVE   EQU   12                      CONSTANT 12
THIRTEEN EQU   13                      CONSTANT 13
K40      EQU   40                      CONSTANT 40
T55      EQU   255                     CONSTANT 255
         EJECT
*        CHARACTER AND HEXADECIMAL EQUATES
READFST  EQU   X'04'                   READ FIRST RECORD DATA SET
READPREV EQU   X'01'                   READ RECORD PREV. TO CURRENT
READWKEY EQU   X'00'                   READ CURRENT REFERENCED RECORD
READNEXT EQU   X'02'                   READ RECORD AFTER CURRENT REF.
ENDFLAG  EQU   X'80'                   FLAG- END OF PLIST
WRITERCD EQU   X'20'                   WRITE RECORD IN PLACE
FLGOF    EQU   X'00'                   OP FOR OFF FLAG
GOTOFLAG EQU   X'80'                   FLAG FOR GO TO STATEMENT
BLNK     EQU   C' '                    BLANK OPERAND
FOXES    EQU   X'FF'                   PLUG FOR TABLE
BLANK    EQU   C' '                    CONSTANT BLANK
ZERO     EQU   C'0'                    CONSTANT ZERO
NINE     EQU   C'9'                    CONSTANT NINE
EXIT     EQU   X'80'                   EXIT AFTER PRINTING
EIGTY    EQU   X'80'                   BIT ON OPERAND
MASK1    EQU   X'F0'                   SIGN MASK
MASK2    EQU   X'01'                   ONE TABLE USED
COMA     EQU   C','                    COMMA OPERAND
QUOTC    EQU   C''''                   QUOTE OPERAND
DQUTC    EQU   C'"'                    DOUBLE QUOTE OPERAND
         END
