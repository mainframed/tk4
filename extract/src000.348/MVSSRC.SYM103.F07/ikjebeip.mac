         TITLE 'IKJEBEIP - EDIT COMMAND INPUT SUBCOMMAND               *
                        '
IKJEBEIP CSECT ,                                                   0001
@MAINENT DS    0H                                                  0001
         USING *,@15                                               0001
         B     @PROLOG                                             0001
         DC    AL1(16)                                             0001
         DC    C'IKJEBEIP  78.121'                                 0001
         DROP  @15
@PROLOG  STM   @14,@12,12(@13)                                     0001
         BALR  @11,0                                               0001
@PSTART  LA    @06,4095(,@11)                                      0001
         USING @PSTART,@11                                         0001
         USING @PSTART+4095,@06                                    0001
*           COMMREG = PARMREG1;      /* GET ADDR OF IKJEBECA         */
*                                                                  0110
         LR    COMMREG,PARMREG1                                    0110
*           RESPECIFY (GPR13P,GPR15P) RSTD;                        0111
*           GPR15P = CANXTSVA;       /* SAVE AREA FOR THIS MODULE    */
         L     GPR15P,CANXTSVA(,COMMREG)                           0112
*           EVAL(GPR15P + 4) -> CASAVPTR = GPR13P;   /* SET THIS     */
         LA    @14,4                                               0113
         ALR   @14,GPR15P                                          0113
         ST    GPR13P,CASAVPTR(,@14)                               0113
*                                    /* SAVEAREA BKWD PTR            */
*           EVAL(GPR13P + 8) -> CASAVPTR = GPR15P;   /* SET CALLER   */
         LA    @14,8                                               0114
         ALR   @14,GPR13P                                          0114
         ST    GPR15P,CASAVPTR(,@14)                               0114
*                                    /* FWD PTR                      */
*           GPR13P = GPR15P;         /* NEW SAVEAREA ADDR            */
         LR    GPR13P,GPR15P                                       0115
*           CANXTSVA = GPR13P + 72;   /* UPDATE NEX-SAVE-AREA PTR    */
         LA    @14,72                                              0116
         ALR   @14,GPR13P                                          0116
         ST    @14,CANXTSVA(,COMMREG)                              0116
*           RESPECIFY (GPR13P,GPR15P) UNRSTD;                      0117
*                                                                  0117
*           DATAREG = ADDR(CASCWKA);   /* SET BASE REG FOR WORK AREA */
         LA    DATAREG,CASCWKA(,COMMREG)                           0118
*           GEN( USING @DATD,DATAREG);   /* SET ADDRESSABILITY TO    */
          USING @DATD,DATAREG
*                                    /* CASCWKA                      */
*        CCODE = 0;                    /* INIT RETURN CODE            *
         SLR   @12,@12                                             0120
         STH   @12,CCODE                                           0120
*        FLAGS = FLAGS && FLAGS;       /* TURN OFF SWITCHES           *
         XC    FLAGS(1),FLAGS                                      0121
*        UTDCBPTR = CAPTCDCB;          /* SET UTIL DCB PTR            *
         MVC   UTDCBPTR(4),CAPTCDCB(COMMREG)                       0122
*        CAPROMPT = '0'B;              /* INIT AUTO PROMPT SWITCH OFF *
         NI    CAPROMPT(COMMREG),B'11011111'                       0123
*        CAIMIR = '1'B;                /* INDICATE I OPERATION        *
         OI    CAIMIR(COMMREG),B'00010000'                         0124
*        NUMBXXX = 0;                  /* INITIALIZE AREA TO ZERO     *
*                                                                  0125
         STH   @12,NUMBXXX                                         0125
*        /* WAS ENTRY FROM INSERT                                     *
*        IF CAIMINS = '1'B                                         0126
*          THEN                        /* YES, ENTRY FROM INSERT      *
         TM    CAIMINS(COMMREG),B'01000000'                        0126
         BNO   @RF00126                                            0126
*            DO;                                                   0127
*              SAVEINCR = CAIMLINC;    /* SAVE INCREMENT              *
         MVC   SAVEINCR(4,COMMREG),CAIMLINC(COMMREG)               0128
*              CAIMLINC = 1;           /* SET NEW TEMP INCREMENT      *
         LA    @12,1                                               0129
         ST    @12,CAIMLINC(,COMMREG)                              0129
*              READKEY = CACURNUM;     /* SET FIRST RECORD VALUE      *
         L     @08,CACURNUM(,COMMREG)                              0130
         ST    @08,READKEY                                         0130
*              FIRSTLN = READKEY + CAIMLINC; /* SET FIRST INPUTYA10479
*                                         RECORD KEY TO        YA01479
*                                         CURRENT LINE+1       YA01479*
         ALR   @08,@12                                             0131
         ST    @08,FIRSTLN(,COMMREG)                               0131
*              GOTO RDNEXT;            /* CONTINUE             YA01479*
         B     RDNEXT                                              0132
*            END;                                                  0133
*          ELSE;                       /* NO, ENTRY NOT FROM INSERT   *
*                                                                  0134
@RF00126 DS    0H                                                  0135
*        /* WAS ENTRY FROM INPUT SUBCOMMAND                           *
*        IF CAIMSC = '1'B                                          0135
*          THEN                        /* NO ENTRY NOT FROM SUBCMD    *
         TM    CAIMSC(COMMREG),B'00100000'                         0135
         BNO   @RF00135                                            0135
*          /* DETERMINE WHERE INPUT LINES ARE TO BE WRITTEN           *
*            DO;                                                   0136
*                                                                  0136
*              /* CHECK FOR PREVIOUS LINE NUMBER                      *
*              IF CAIMINPT = '0'B      /*                      YA00040*
*              THEN                    /* WAS INP ENTERED BEFORE   0137
*                                         NO-INPUT IS FROM CARRIAGE
*                                         RETURN OR INPUT DATA SET IS
*                                         EMPTY                       *
         TM    CAIMINPT(COMMREG),B'00000010'                       0137
         BNZ   @RF00137                                            0137
*              /* INPUT LINES TO BE WRITTEN AT END OF DATA SET        *
*              DO;                                                 0138
*BTMPRMT: ;                            /* LINES TO BE WRITTEN AT END
*                                         OF DATA SET                 *
BTMPRMT  DS    0H                                                  0140
*BOTTOM: ;                             /* PREPARE TO 'READ BOTTOM' ON
*                                         THE UTILITY DATA SET        *
BOTTOM   DS    0H                                                  0141
*              UTOPTCD = '85'X;        /* INDICATE READ BOTTOM        *
         MVI   UTOPTCD,X'85'                                       0141
*              CALL IORTN;             /* CALL UTILITY DS ACCESS   0142
*                                         METHOD                      *
*                                                                  0142
         BAL   @14,IORTN                                           0142
*              /* CHECK RETURN CODE FROM UTILITY ACCESS METHOD        *
*              IF RCODEREG = 0                                     0143
*                THEN                  /* YES, RET CODE 0             *
         LTR   RCODEREG,RCODEREG                                   0143
         BNZ   @RF00143                                            0143
*                  FIRSTLN = INKEY + CAINCRE; /* IF READ BOTTOM IS 0144
*                                                SUCCESSFUL SET FIRST
*                                                LINE NUMBER TO KEY OF
*                                                LAST RECORD + DEFAULT
*                                                INCR                 *
         L     @12,INKEY(,UTPREG1)                                 0144
         AL    @12,CAINCRE(,COMMREG)                               0144
         ST    @12,FIRSTLN(,COMMREG)                               0144
*                ELSE                  /* RET CODE NOT 0              *
*                /* DATA SET IS EMPTY, INPUT LINES BASED ON INCREMENT *
*                  DO;                 /* FALLING THROUGH HERE MEANS
*                                         THE DATA SET IS EMPTY       *
         B     @RC00143                                            0145
@RF00143 DS    0H                                                  0146
*                    FIRSTLN = CAINCRE; /* SET FIRST LINE NUM =    0146
*                                          INCREMENT                  *
         MVC   FIRSTLN(4,COMMREG),CAINCRE(COMMREG)                 0146
*                  END;                                            0147
*              EODSW = '1'B;           /* INDICATE NO FOURTHER READ
*                                         NEXTS                       *
@RC00143 OI    EODSW,B'00100000'                                   0148
*              NEXTREC = MAXREC;       /* SET MAXIMUM AS NEXT RECORD
*                                         NUMBER                      *
         MVC   NEXTREC(4,COMMREG),MAXREC                           0149
*              GOTO AUTOLNPT;          /* GO TO SUBRTN                *
         B     AUTOLNPT                                            0150
*            END;                                                  0151
*          ELSE                        /* CONTINUE                    *
*          /* INPUT LINES BASED ON LAST INPUT MODE SESSION            *
*            DO;                       /* ENTER HERE IF INPUT MODE WAS
*                                         ENTERED BEFORE              *
@RF00137 DS    0H                                                  0153
*              READKEY = CAIMLLNO;     /* KEY VALUE FOR READ   YA01479
*                                         NEXT OPERATION (TO   YA01479
*                                         CHECK IF NEW LINE    YA01479
*                                         WILL FIT IN D.S.)    YA01479*
         L     @12,CAIMLLNO(,COMMREG)                              0153
         ST    @12,READKEY                                         0153
*              FIRSTLN = READKEY + CAIMLINC; /* APPLY INCR. TO YA01479
*                                         DETERMINE KEY VALUE  YA01479
*                                         FOR FIRST INPUT      YA01479
*                                         LINE                 YA01479*
         AL    @12,CAIMLINC(,COMMREG)                              0154
         ST    @12,FIRSTLN(,COMMREG)                               0154
*              GOTO RDNEXT;            /* DETERMINE IF RECORDS YA01479
*                                         EXIST IN DATA SET    YA01479
*                                         BEYOND LAST LINE     YA01479
*                                         ENTERED IN INPUT MODEYA01479*
         B     RDNEXT                                              0155
*            END;                                                  0156
*        END;                                                      0157
*                                                                  0157
*        /* FALLING THROUGH HERE MEANS THAT ENTRY WAS TO PROCESS AN   *
*        /* INPUT SUBCOMMAND CHECK IF SUBCOMMAND HAS ANY OPERANDS     *
*        IF CAOPERND = '1'B                                        0158
*          THEN                        /* YES, OPERANDS PRESENT       *
@RF00135 TM    CAOPERND(COMMREG),B'10000000'                       0158
         BNO   @RF00158                                            0158
*          /* SUBCOMMAND OPERANDS TO BE SCANNED BY PARSE SERVICE RTN  *
*            DO;                       /* YES OPERANDS ARE PRESENT,
*                                         CALL IKJPARSE OT SCAN AND
*                                         VALIDATE THEM               *
*              PPLPTR = ADDR (CATMPLST); /* SET PARSE PARM LIST PTR   *
         LA    PPLPTR,CATMPLST(,COMMREG)                           0160
*              PPLANS = ADDR (PDLPTR ); /* SET ANSWER PTR             *
         LA    @12,PDLPTR(,COMMREG)                                0161
         ST    @12,PPLANS(,PPLPTR)                                 0161
*              PPLPCL = ADDR (IKJEBIP1); /* SET PCL PTR               *
         L     @12,@CV01140                                        0162
         ST    @12,PPLPCL(,PPLPTR)                                 0162
*              PPLCBUF = CAPTIBFR;     /* POINT TO COMMAND BUFFER     *
         MVC   PPLCBUF(4,PPLPTR),CAPTIBFR(COMMREG)                 0163
*              PPLUWA = 0;             /* INDICATE NO SAVE AREA       *
         SLR   @12,@12                                             0164
         ST    @12,PPLUWA(,PPLPTR)                                 0164
*              DO; /*CALLTSSR EP(IKJPARS)MF(E,PPL)*/               0165
*                RESPECIFY GPR01P RSTD;                            0166
*                GPR01P = ADDR(PPL);                               0167
         LR    GPR01P,PPLPTR                                       0167
*                IF CVTPARS = 0                                    0168
*                  THEN                                            0168
         L     @08,CVTPTR                                          0168
         C     @12,CVTPARS(,@08)                                   0168
         BNE   @RF00168                                            0168
*                    GEN(LINK EP=IKJPARS);                         0169
         LINK EP=IKJPARS
*                  ELSE                                            0170
*                    CALL CVTPARS;                                 0170
         B     @RC00168                                            0170
@RF00168 L     @12,CVTPTR                                          0170
         L     @15,CVTPARS(,@12)                                   0170
         BALR  @14,@15                                             0170
*                RESPECIFY GPR01P UNRSTD;                          0171
@RC00168 DS    0H                                                  0172
*              END; /* INVOKE IKJPARS                              0172
*                      SERVICE ROUTINE     */                      0172
*              RESPECIFY (RCODEREG) RSTD;                          0173
*              PRSSW = '1'B;           /* INDICATE PARSE WAS CALLED   *
*                                                                  0174
         OI    PRSSW,B'10000000'                                   0174
*              /* CHECK FOR SUCCESSFUL COMPLETION OF PARSE            *
*              IF RCODEREG = 0                                     0175
*                THEN;                 /* RETURN NORMAL - CONTINUE    *
         LTR   RCODEREG,RCODEREG                                   0175
         BZ    @RT00175                                            0175
*                ELSE                  /* RETURN NOT 0                *
*                  DO;                                             0177
*                    CODESAVE = RCODEREG; /* SAVE RETURN CODE         *
*                                                                  0178
         LR    CODESAVE,RCODEREG                                   0178
*                    RESPECIFY (RCODEREG) UNRSTD;                  0179
*                    /* RETURN CODE 16                                *
*                    IF CODESAVE = 16                              0180
*                      THEN            /* YES CODE WAS 16             *
         CH    CODESAVE,@CH00228                                   0180
         BNE   @RF00180                                            0180
*                        DO;                                       0181
*                        /* NOTIFY USER THAT GETMAIN FAILED           *
*                                                                  0182
*                          RELMSG1 = 270;  /* LOAD MSG NUMBER         *
         MVC   RELMSG1(2),@CH01250                                 0182
*                          RELMSG2 = 0;    /* LOAD RELATIVE LEV-2 NUM *
*                                                                  0183
         SLR   @12,@12                                             0183
         STH   @12,RELMSG2                                         0183
*                          /* POINT TO INSERT                         *
*                          LEV1INS = ADDR (INSM25);                0184
         LA    LEV1INS,INSM25                                      0184
*                          LEV2INS = 0;    /* NO LEV-2 INSERTION      *
         SLR   LEV2INS,LEV2INS                                     0185
*                          CALL MSGRTN; /* PUT OUT MESSAGE            *
         BAL   @14,MSGRTN                                          0186
*                          CCODE=8;    /* INDICATE FLUSH NEEDED       *
*                                                                  0187
         MVC   CCODE(2),@CH00049                                   0187
*                        END;                                      0188
*                      ELSE            /* CODE NOT 16                 *
*                        DO;           /* CHECK NEXT RETURN CODE      *
*                                                                  0189
         B     @RC00180                                            0189
@RF00180 DS    0H                                                  0190
*                          /* CHECK FOR RETURN CODE 12                *
*                          IF CODESAVE = 12                        0190
*                            THEN      /* YES, CODE IS 12             *
         CH    CODESAVE,@CH00137                                   0190
         BNE   @RF00190                                            0190
*                              DO;     /* PREPARE TO CALL MSGRTN      *
*                                                                  0191
*                                /* MOVE MODEL INTO WORK AREA         *
*                                /* -PARSE                            *
*                                INSREC = M313INS1;                0192
*                                                                  0192
         MVC   INSREC(16),M313INS1                                 0192
*                                /* GET RETURN CODE                   *
*                                SAVERC = CODESAVE;                0193
         ST    CODESAVE,SAVERC                                     0193
*                                CALL SRVERRTN; /* GO PUT OUT MESSAGE *
         BAL   @14,SRVERRTN                                        0194
*                              END;                                0195
*                            ELSE      /* NO, CODE IS 4 OR 8          *
*                              /* DETERMINE IF UNSTACK/TCLEARQ REQ.   *
*                              IF CODESAVE=4                       0196
*                                THEN  /* INDICATE FLUSH NEEDED       *
         B     @RC00190                                            0196
@RF00190 CH    CODESAVE,@CH00389                                   0196
         BNE   @RF00196                                            0196
*                                  CCODE=8;  /* SET RETURN CODE       *
         MVC   CCODE(2),@CH00049                                   0197
*                                ELSE; /* RETURN CODE IS 8            *
@RF00196 DS    0H                                                  0199
*                        END;                                      0199
*                    GOTO EXIT;        /* GO RETURN TO COMMAND MODE   *
         B     EXIT                                                0200
*                  END;                                            0201
*            END;                                                  0202
*          ELSE                        /* CONTINUE                    *
*            GOTO BTMPRMT;             /* IF ALL OPERANDS OMITTED, 0203
*                                         INPUT WILL BEGIN AT THE  0203
*                                         BOTTOM OF THE DATA SET      *
*                                                                  0203
*        /* CHECK FOR 'R' SPECIFIED                                   *
*        IF PRSIRFLG = 2                                           0204
*          THEN                        /* YES, R SPECIFIED            *
@RC00158 L     @12,PDLPTR(,COMMREG)                                0204
         CLC   PRSIRFLG(2,@12),@CH00072                            0204
         BNE   @RF00204                                            0204
*            CAIMIR = '0'B;            /* SET FLAG IN COMM AREA       *
         NI    CAIMIR(COMMREG),B'11101111'                         0205
*          ELSE;                       /* NO, I SPEC OR DEFAULT       *
*                                                                  0206
@RF00204 DS    0H                                                  0207
*        /* CHECK FOR LINE NUMBER OPERAND IN SUBCOMMAND               *
*        IF PRSNMOM = '1'B                                         0207
*          THEN                        /* PROCESS LINE NUMBER         *
         L     @12,PDLPTR(,COMMREG)                                0207
         TM    PRSNMOM(@12),B'10000000'                            0207
         BNO   @RF00207                                            0207
*          /* LINE NUMBER OPERAND VALIDATION                          *
*            DO;                       /* DO IF OPERAND PRESENT       *
*                                                                  0208
*              /* CHECK FOR * AS LINE NUMBER                          *
*              IF NUMBER (1) = '*'                                 0209
*                THEN                  /* '*' SPECIFIED,TREAT AS IF
*                                         CURRENT LINE NUMBER WERE 0209
*                                         SPECIFIED                   *
         L     @12,PRSNMPTR(,@12)                                  0209
         CLI   NUMBER(@12),C'*'                                    0209
         BNE   @RF00209                                            0209
*                  DO;                                             0210
*                    READKEY = CACURNUM; /* OBTAIN CURRENT LINE PTR
*                                           FROM COMMAREA AND STORE AS
*                                           KEY FOR NEXT READ         *
         MVC   READKEY(4),CACURNUM(COMMREG)                        0211
*                    GOTO CHKPRMT;     /* GO CONTINUE PROCESSING      *
         B     CHKPRMT                                             0212
*                  END;                                            0213
*                ELSE;                 /* IF A NUMBER WAS SPECIFIED,
*                                         CONTINUE                    *
*                                                                  0214
@RF00209 DS    0H                                                  0215
*              /* CHECK TO SEE IF DATA SET IS LINE NUMBERED           *
*              IF CANONUM = '1'B                                   0215
*                THEN                  /* DATA SET IS NOT NUMBERED,
*                                         PUT OUT MESSAGE             *
         TM    CANONUM(COMMREG),B'00000001'                        0215
         BNO   @RF00215                                            0215
*                  DO;                                             0216
*                    RELMSG1 = 1288;   /* LOAD MESSAGE NUMBER         *
         MVC   RELMSG1(2),@CH01254                                 0217
*                    RELMSG2 = 0;      /* INDICATE NO LEVEL 2 MSG     *
         SLR   @12,@12                                             0218
         STH   @12,RELMSG2                                         0218
*                    LEV1INS = 0;      /* POINT TO LEV-1 INSERTION    *
         SLR   LEV1INS,LEV1INS                                     0219
*                    LEV2INS = 0;      /* INDICATE NO LEV-2 INSERT    *
         SLR   LEV2INS,LEV2INS                                     0220
*                    CALL MSGRTN;      /* PUT OUT MESSAGE             *
         BAL   @14,MSGRTN                                          0221
*                    CCODE=8;          /*INDICATE FLUSH NEEDED        *
         MVC   CCODE(2),@CH00049                                   0222
*                    GOTO EXIT;        /* TERMINATE SUBCOMMAND        *
         B     EXIT                                                0223
*                  END;                                            0224
*                ELSE;                 /* OS IS NUMBERED,CONTINUE     *
@RF00215 DS    0H                                                  0226
*        END;                                                      0226
*          ELSE                        /* THIS PATH IS FOR INPUT WITH
*                                         NO LINENUM BUT WITH PROMPT/
*                                         NOPROMPT KEYWORD. I OR R IS
*                                         IGNORED                     *
*            DO;                                                   0227
*                                                                  0227
         B     @RC00207                                            0227
@RF00207 DS    0H                                                  0228
*              /* CHECK FOR PROMPT OPTION OMITTED                     *
*              IF PRSPFLG = 0                                      0228
*                THEN                  /* YES, OPTION OMITTED         *
         L     @12,PDLPTR(,COMMREG)                                0228
         LH    @12,PRSPFLG(,@12)                                   0228
         LTR   @12,@12                                             0228
         BZ    @RT00228                                            0228
*                  GOTO BTMPRMT;       /* GO SET DEFAULTS             *
*                ELSE;                 /* NO, PROMPT/NOPROMPT SPEC    *
*                                                                  0230
*              /* CHECK FOR PROMPT OPTION                             *
*              IF PRSPFLG = 2                                      0231
*                THEN                  /* NOPROMPT SPECIFIED          *
         CH    @12,@CH00072                                        0231
         BNE   @RF00231                                            0231
*                  CAIMPT = '0'B;      /* SET FLAG TO INDICATE     0232
*                                         NOPROMPT                    *
         NI    CAIMPT(COMMREG),B'01111111'                         0232
*                ELSE                  /* PROMPT SPECIFIED            *
*                  CAIMPT = '1'B;      /* INDICATE PROMPT             *
         B     @RC00231                                            0233
@RF00231 OI    CAIMPT(COMMREG),B'10000000'                         0233
*              GOTO BOTTOM;            /* GO PROCESS AS NO OPERANDS
*                                         AND FIRST TIME IN INPUT     *
         B     BOTTOM                                              0234
*            END;                                                  0235
*        WREG1 = PRSNMLEN;             /* GET LENGTH FOR CONVERT      *
@RC00207 L     @12,PDLPTR(,COMMREG)                                0236
         LH    WREG1,PRSNMLEN(,@12)                                0236
*        WREG2 = PRSNMPTR;             /* GET ADDR OF STRING TO BE 0237
*                                         CONVERTED                   *
         L     WREG2,PRSNMPTR(,@12)                                0237
*        CALL CONVERT;                 /* GO CONVERT THE LINE NUMBER
*                                         TO BINARY                   *
         BAL   @14,CONVERT                                         0238
*        READKEY = WREG1;              /* STORE CONVERTED VALUE       *
*                                                                  0239
         ST    WREG1,READKEY                                       0239
*CHKPRMT:  /* CHECK TO SEE IF INCREMENT WAS SPECIFIED          A50478 *
*        IF PRSINOM = '1'B                                         0240
*          THEN                        /* IF INCREMENT WAS PRESENT    *
CHKPRMT  L     @12,PDLPTR(,COMMREG)                                0240
         TM    PRSINOM(@12),B'10000000'                            0240
         BNO   @RF00240                                            0240
*            DO;                       /* OCNVERT TO BINARY AND STORE
*                                         AS LAST INCR USED IN INPUT  *
*              WREG1 = PRSINLEN;       /* GET LENGTH OF INCEMENT      *
         LH    WREG1,PRSINLEN(,@12)                                0242
*              WREG2 = PRSINPTR;       /* POINT TO INCREMENT          *
         L     WREG2,PRSINPTR(,@12)                                0243
*              CALL CONVERT;           /* GO CONVERT THE INCR TO BIN  *
         BAL   @14,CONVERT                                         0244
*              CAIMCIN = '1'B;         /* INDIC INCREMENT SPECIFIED   *
         OI    CAIMCIN(COMMREG),B'00001000'                        0245
*              CAIMLINC = WREG1;       /* SAVE CONVERTED VALUE        *
         ST    WREG1,CAIMLINC(,COMMREG)                            0246
*            END;                                                  0247
*          ELSE;                       /* NO INCR SPECIFIED, CONTINUE
*                                         PROCESSING                  *
@RF00240 DS    0H                                                  0249
*          /* CHECK IF PROMPT/NOPROMPT KEYWORD OMITTED         A50478 *
*        IF PRSPFLG = 0                                            0249
*          THEN;                       /* YES, OPERAND OMITTED        *
         L     @12,PDLPTR(,COMMREG)                                0249
         ICM   @08,3,PRSPFLG(@12)                                  0249
         BZ    @RT00249                                            0249
*          ELSE                        /* NO OPERAND SPECIFIED        *
*            DO;                                                   0251
*                                                                  0251
*              /* CHECK FOR PROMPT OPTION SPECIFIED                   *
*              IF PRSPFLG = 2                                      0252
*                THEN                  /* NOPROMPT WAS SPECIFIED      *
         L     @12,PDLPTR(,COMMREG)                                0252
         CLC   PRSPFLG(2,@12),@CH00072                             0252
         BNE   @RF00252                                            0252
*                  CAIMPT = '0'B;      /* SET FLAG TO INDICATE     0253
*                                         NOPROMPT                    *
         NI    CAIMPT(COMMREG),B'01111111'                         0253
*                ELSE                  /* PROMPT WAS SPECIFIED        *
*                  CAIMPT = '1'B;      /* (DEFAULT) INDICATE PROMPT   *
         B     @RC00252                                            0254
@RF00252 OI    CAIMPT(COMMREG),B'10000000'                         0254
*            END;                                                  0255
@RC00252 DS    0H                                                  0256
*        /* DETERMINE KEY VALUE FOR FIRST INPUT LINE           YA01479*
*        IF CAIMIR = '0'B                                          0256
*          THEN                        /* R-FORM OF INPUT MODE YA01479
*                                         WAS SPECIFIED        YA01479*
@RT00249 TM    CAIMIR(COMMREG),B'00010000'                         0256
         BNZ   @RF00256                                            0256
*            FIRSTLN = READKEY;        /*USE KEY VALUE ENTERED YA01479
*                                         (OR DEFAULTED) FOR   YA01479
*                                         FIRST INPUT LINE KEY YA01479*
         MVC   FIRSTLN(4,COMMREG),READKEY                          0257
*          ELSE                        /* I-FORM OF INPUT MODE YA01479*
*            DO;                       /* READ 'READKEY' LINE  YA01479
*                                         TO DETERMINE CORRECT YA01479
*                                         ACTION               YA01479*
         B     @RC00256                                            0258
@RF00256 DS    0H                                                  0259
*              UTOPTCD = '00'X;        /* INITIALIZE PARAMETERSYA01479
*                                         FOR CALLING IKJEBEUT YA01479
*                                         INDICATE READ CURRENTYA01479*
         MVI   UTOPTCD,X'00'                                       0259
*              UTKEYPTR = ADDR(READKEY); /* ADDR. OF READ KEY  YA01479*
         LA    @12,READKEY                                         0260
         ST    @12,UTKEYPTR                                        0260
*              LBIT2 = '1'B;           /* SET END-OF-PARM MARK YA01479*
         OI    LBIT2,B'10000000'                                   0261
*              CALL IORTN;             /* CALL IO SUBRTN TO    YA01479
*                                         DO READ OPERATION    YA01479*
         BAL   @14,IORTN                                           0262
*              IF RCODEREG = 0                                     0263
*                THEN                  /* 'READKEY' LINE FOUND YA01479*
         LTR   RCODEREG,RCODEREG                                   0263
         BNZ   @RF00263                                            0263
*                  FIRSTLN= READKEY + CAIMLINC; /* APPLY INCR. YA01479
*                                         TO KEY OBTAIN        YA01479
*                                         FIRST INPUT LINE KEY YA01479*
         L     @12,READKEY                                         0264
         AL    @12,CAIMLINC(,COMMREG)                              0264
         ST    @12,FIRSTLN(,COMMREG)                               0264
*                ELSE                  /* LINE NOT IN DATA SET YA01479*
*                  FIRSTLN= READKEY;   /* USE 'READKEY' AS KEY YA01479
*                                         FOR FIRST INPUT LINE YA01479*
         B     @RC00263                                            0265
@RF00263 MVC   FIRSTLN(4,COMMREG),READKEY                          0265
*            END;                      /* END DETERMINATION OF YA01479
*                                         FIRST INPUT KEY VALUEYA01479*
@RC00263 DS    0H                                                  0267
*RDNEXT: /* A 'READ-NEXT' OPERATION IS REQUIRED ON UTILITY DATA SET   *
*        UTOPTCD = '02'X;              /* PREPARE FOR A READ NEXT TO
*                                         DETERMINE THE UPPER LIMITS
*                                         OF INPUT MODE               *
@RC00256 DS    0H                                                  0267
RDNEXT   MVI   UTOPTCD,X'02'                                       0267
*        UTKEYPTR = ADDR (READKEY);    /* SET KEY TO BE USED BY READ  *
         LA    @12,READKEY                                         0268
         ST    @12,UTKEYPTR                                        0268
*        LBIT2 = '1'B;                 /* SET END-OF-PARM INDICATION  *
         OI    LBIT2,B'10000000'                                   0269
*        CALL IORTN;                   /* GO ISSUE READ NEXT          *
*                                                                  0270
         BAL   @14,IORTN                                           0270
*        /* CHECK RETURN CODES FROM IKJEBEUT                          *
*        IF RCODEREG = 0                                           0271
*          THEN                        /* IF RETURN CODE IS 0, SAVE   *
         LTR   RCODEREG,RCODEREG                                   0271
         BNZ   @RF00271                                            0271
*            NEXTREC = INKEY;          /* LINE NUMBER(KEY) AS NEXT 0272
*                                         RECORD                      *
         MVC   NEXTREC(4,COMMREG),INKEY(UTPREG1)                   0272
*          ELSE;                       /* RETURN CODE IS 4 - END-OF
*                                         DATA SET WAS REACHED        *
@RF00271 DS    0H                                                  0274
*AUTOLNPT:                             /* AT THIS POINT, THE FIRST    *
*                                      /* LINE NUMBER TO BE ISSUED IN *
*                                      /* INPUT MODE HAS BEEN ESTAB-  *
*                                      /* LISHED AND IS STORED IN     *
*                                      /* 'FIRSTLN'.  THE LIMIT VALUE *
*                                      /* FOR 1-FORM OR THE NEXT      *
*                                      /* RECORD NUMBER FOR THE       *
*                                      /* R-FORM (WITHOUT AN INCRE-   *
*                                      /* MENT) HAS BEEN STORED IN    *
*                                      /* 'NEXTREC'.  IF AN INCREMENT *
*                                      /* WAS SPECIFIED, IT HAS BEEN  *
*                                      /* 'CAIMLINC'.  CHECK TO SEE   *
*                                      /* IF A NEW RECORD WILL FIT IN *
*                                      /* IN DATA SET.  CHECK FOR     *
*                                      /* 'PROMPT' OPTION.            *
*        WREG2 = ADDR (PTLPBLK);       /* PUT THE 'INPUT' MESSAGE TO
*                                         THE TERMINAL POINT TO PARM
*                                         LIST                        *
AUTOLNPT LA    WREG2,PTLPBLK                                       0274
*        PARMREG1 = ADDR (CATMPLST);   /* POINT TO SRVC RTN PARM LIST *
         LA    PARMREG1,CATMPLST(,COMMREG)                         0275
*        PTLPBLK = PTLINE;             /* MOVE IN PUTLINE L-FORM      *
*                                                                  0276
         MVC   PTLPBLK(20),PTLINE                                  0276
*        /* PUT INPUT MESSAGE TO TERMINAL                             *
*        GEN REFS(WREG2);                                          0277
*                                                                  0277
         PUTLINE PARM=(WREG2),OUTPUT=(INPMSG,TERM,SINGLE,DATA),        X
               TERMPUT=(EDIT),MF=(E,(1))
*        /* CHECK PROMPT SWITCH                                       *
*        IF CAIMPT = '1'B                                          0278
*          THEN                        /* YES, PROMPT SPECIFIED OR 0278
*                                         DEFAULTED                   *
         TM    CAIMPT(COMMREG),B'10000000'                         0278
         BNO   @RF00278                                            0278
*          /* DETERMINE IF AUTOMATIC LINE PROMPTING IS TO BE USED     *
*          DO;                                                     0279
*                                                                  0279
*        /* CHECK FOR SYNTAX CHECKING IN EFFECT                       *
*        IF CASCANSW = '1'B                                        0280
*          THEN                        /* YES CHECKING IN EFFECT      *
         TM    CASCANSW(COMMREG),B'00010000'                       0280
         BO    @RT00280                                            0280
*            GOTO INDSFPT;             /* GO SET UP PROMPTING         *
*          ELSE;                       /* NO, CHECKING NOT ACTIVE     *
*                                                                  0282
*        /* CHECK FOR PRESENCE OF LINE NUMBERS                        *
*        IF CANONUM = '0'B                                         0283
*          THEN                        /* YES DATA SET IS LINE     0283
*                                         NUMBERED                    *
*                                                                  0283
         TM    CANONUM(COMMREG),B'00000001'                        0283
         BNZ   @RF00283                                            0283
*            /* IF INPUT IS FOR A LINE NUMBERED DATA SET AND IS       *
*            /* R-FORM WITH NO INCREMENT, THEN PROMPTING IS DONE BY   *
*            /* INPUT DIRECTLY                                        *
*            IF CAIMIR = '0'B & CAIMCIN = '0'B & CAIMPT = '1'B     0284
*              THEN                    /* SELF PROMPTING TO BE DONE   *
         TM    CAIMPT(COMMREG),B'10000000'                         0284
         BNO   @RF00284                                            0284
         TM    CAIMIR(COMMREG),B'00011000'                         0284
         BNZ   @RF00284                                            0284
*                DO;                                               0285
*INDSFPT:    /* SELF-PROMPTING IS TO BE USED                          *
*                  CAIMSFPT = '1'B;    /* SET SELF-PROMPTING SWITCH
*                                         FOR NEXT PHASE              *
INDSFPT  OI    CAIMSFPT(COMMREG),B'00000100'                       0286
*                END;                                              0287
*              ELSE                    /* AUTOMATIC PROMPT MAY BE USED*
*                DO;                                               0288
         B     @RC00284                                            0288
@RF00284 DS    0H                                                  0289
*                  WREG1 = ADDR (FIRSTLN); /* POINT TO FIRST LINE  0289
*                                             NUMBER FOLLOWED BY BLANK*
         LA    WREG1,FIRSTLN(,COMMREG)                             0289
*                  WREG2 = ADDR (CAIMLINC); /* POINT TO INCREMENT     *
*                                                                  0290
         LA    WREG2,CAIMLINC(,COMMREG)                            0290
*                  /* ISSUE AUTOMATIC PROMPT BY LINE NUMBER           *
*                  GEN(STAUTOLN S=(WREG1),I=(WREG2))               0291
*                       REFS(WREG1,WREG2);                         0291
         STAUTOLN S=(WREG1),I=(WREG2)
*                  CAPROMPT = '1'B;    /* INDICATE AUTO PROMPT STARTED*
         OI    CAPROMPT(COMMREG),B'00100000'                       0292
*                END;                                              0293
*          ELSE                        /* DATA SET IS NOT NUMBERED    *
*            DO;                       /* START AUTO PROMPT           *
         B     @RC00283                                            0294
@RF00283 DS    0H                                                  0295
*            GEN (STAUTOCP);           /* ISSUE AUTOMATIC CHARACTER
*                                         PROMPT                      *
         STAUTOCP
*            CAPROMPT = '1'B;          /* INDICATE AUTO PROMPT STARTED*
         OI    CAPROMPT(COMMREG),B'00100000'                       0296
*            END;                                                  0297
*        END;                                                      0298
*                                                                  0298
@RC00283 DS    0H                                                  0299
*        /* CHECK WHETHER OR NOT PARSE WAS CALLED                     *
*        IF PRSSW = '1'B                                           0299
*          THEN                        /* YES PARSE WAS CALLED        *
@RF00278 TM    PRSSW,B'10000000'                                   0299
         BNO   @RF00299                                            0299
*            DO;                                                   0300
*              WREG2 = ADDR(PDLPTR);   /* POINT TO PARSE PDL ANS PLACE*
         LA    WREG2,PDLPTR(,COMMREG)                              0301
*              CAFREEDL = '1'B;        /* INDICATE NO PDL TO FREE     *
         OI    CAFREEDL(COMMREG),B'10000000'                       0302
*              GEN (IKJRLSA (WREG2))   /* FREE PARSE CORE             *
*                   REFS(WREG2);                                   0303
         IKJRLSA (WREG2)
*            END;                                                  0304
*          ELSE;                       /* NO PARSE WAS NOT CALLED     *
*                                                                  0305
@RF00299 DS    0H                                                  0306
*        /* CALL SUBROUTINE IKJEBEIM TO CONTINUE INPUT MODE           *
*        CALL CONTRTN;                 /*  GO CONTINUE INPUT          *
         BAL   @14,CONTRTN                                         0306
*EXIT:   /* RETURN TO EDIT MAIN CONTROLLER                            *
*                                                                  0307
*        /* CHECK WHETHER OR NOT PARSE WAS CALLED                     *
*        IF PRSSW = '1'B                                           0307
*          THEN                        /* YES PARSE WAS CALLED        *
EXIT     TM    PRSSW,B'10000000'                                   0307
         BNO   @RF00307                                            0307
*            DO;                                                   0308
*              WREG2 = ADDR(PDLPTR);   /* POINT TO PARSE PDL ANS PLACE*
         LA    WREG2,PDLPTR(,COMMREG)                              0309
*              CAFREEDL = '1'B;        /* INDICATE NO PDL TO FREE     *
         OI    CAFREEDL(COMMREG),B'10000000'                       0310
*              GEN (IKJRLSA (WREG2))   /* FREE PARSE CORE             *
*                 REFS(WREG2);                                     0311
         IKJRLSA (WREG2)
*            END;                                                  0312
*          ELSE;                       /* NO PARSE WAS NOT CALLED     *
@RF00307 DS    0H                                                  0314
*        CAIMSC = '0'B;                /* TURN OFF SUBCMD SWITCH      *
*                                                                  0314
         NI    CAIMSC(COMMREG),B'11011111'                         0314
*        /* CHECK FOR ENTRY FROM INSERT SUBCOMMAND                    *
*        IF CAIMINS = '1'B                                         0315
*          THEN                        /* YES, ENTRY FROM INSERT      *
         TM    CAIMINS(COMMREG),B'01000000'                        0315
         BNO   @RF00315                                            0315
*            CAIMLINC = SAVEINCR;      /* RESTORE LAST USED INCRMNT   *
         MVC   CAIMLINC(4,COMMREG),SAVEINCR(COMMREG)               0316
*          ELSE;                       /* NO, ENTRY NOT FROM INSERT   *
@RF00315 DS    0H                                                  0318
*        CAIMFLG (2:6) = '0000000'B;   /* TURN OFF FLAGS       YA00040*
         NI    CAIMFLG(COMMREG),B'10000011'                        0318
*        CAMODMSG = '1'B;              /* INDICATE MODE MESSAGE IS TO
*                                         GO TO THE TERMINAL FROM MA  *
         OI    CAMODMSG(COMMREG),B'00010000'                       0319
*        RCODEREG = CCODE;             /* SET RETURN CODE             *
*                                                                  0320
         LH    RCODEREG,CCODE                                      0320
*        RESPECIFY (GPR12P,GPR13P) RSTD;                           0321
*        CANXTSVA = GPR13P;          /* UPDATE NEXT-SAVE-AREA PTR    */
         ST    GPR13P,CANXTSVA(,COMMREG)                           0322
*        GPR12P = GPR13P;            /* SAVE PRESENT SAVE-AREA ADDR  */
         LR    GPR12P,GPR13P                                       0323
*        GPR13P = (GPR13P + 4) -> CASAVPTR; /* GET BACKWARD          */
         L     @08,CASAVPTR+4(,GPR13P)                             0324
         LR    GPR13P,@08                                          0324
*                                    /* SAVE-AREA PTR                */
*        RESPECIFY CASAVE BASED(GPR12P); /* CHANGE BASE FOR          */
*                                    /* SAVE-AREA                    */
*        CASAVE = CASAVE && CASAVE;  /* ZERO OUT THIS SAVE-AREA      */
         XC    CASAVE(72,GPR12P),CASAVE(GPR12P)                    0326
*        RESPECIFY CASAVE BASED;                                   0327
*        RETURN CODE(RCODEREG);      /* RETURN WITH RETURN CODE      */
         L     @14,12(,@13)                                        0328
         LM    @00,@12,20(@13)                                     0328
         BR    @14                                                 0328
*        RESPECIFY (GPR12P,GPR13P) UNRSTD;                         0329
*                                            /* RETURN TO CMD MODE 0330
*    */                                                            0330
*                                                                  0330
*        /* THE FOLLOWING CODE GENERATES A CONTROL SECTION WHICH      *
*        /* CONTAINS THE VALIDITY CHECK EXIT FOR AN INCREMENT IF      *
*        /* SPECIFIED ON THE INPUT SUBCOMMAND. IT IS ENTERED          *
*        /* DIRECTLY FROM AND RETURNS TO IKJPARS                      *
*        GEN DATA DEFS(VALCHECK);                                  0330
*                                                                  0331
*        /* THE FOLLOWING STATEMENTS ARE THE MACROS FOR IKJPARS TO    *
*        /* USE IN SCANNING THE INPUT SUBCOMMAND. THERE ARE ALSO      *
*        /* MESSAGE INSERTIONS AND MACRO LIST FORMS.                  *
*        GEN DATA DEFS(IPPCE);                                     0331
*        /*************************************************************
*        /* THIS ROUTINE IS CALLED TO PUT OUT THE ERROR MESSAGE       *
*        /* WHICH DIAGNOSES THAT AN UNUSUAL RETURN CODE WAS RECEIVED  *
*        /* FROM A SYSTEM SERVICE ROUTINE.                            *
*        /*                                                           *
*        /* INPUT  - SAVERC CONTAINS THE RETURN CODE FROM THE SERVICE *
*        /* ROUTINE.                                                  *
*        /*************************************************************
*SRVERRTN:                                                         0332
*        PROC OPTIONS (NOSAVE,NOSAVEAREA);                         0332
*                                                                  0332
@EL00001 DS    0H                                                  0332
@EF00001 DS    0H                                                  0332
@ER00001 LM    @14,@12,12(@13)                                     0332
         BR    @14                                                 0332
SRVERRTN DS    0H                                                  0333
*        /* THE FOLLOWING REGISTERS ARE RESTRICTED FOR THE DURATION   *
*        /* OF INPUT                                                  *
*        RESPECIFY (PARMREG1, WREG1, WREG2, COMMREG, SAVEREG, DATAREG,
*            BASEREG,BASEREG2) RSTD;                               0333
*                                                                  0333
*        SRVPTR = RETREG;              /* SAVE RETURN POINT           *
         ST    RETREG,SRVPTR                                       0334
*        CVDREG = SAVERC;              /* GET RETURN CODE TO CONVERT  *
         L     CVDREG,SAVERC                                       0335
*        CALL CVDRTN;                  /* CONVERT RETURN CODE TO DEC  *
         BAL   @14,CVDRTN                                          0336
*        INSREC1 = M313INS4;           /* MOVE SECOND INSERTION MODEL
*                                         TO WORK AREA                *
         MVC   INSREC1(11),M313INS4                                0337
*        INSNUM1 (1:2) = NUMTEMP (7:8); /* MOVE RETURN CODE TO MODEL  *
         MVC   INSNUM1(2),NUMTEMP+6                                0338
*        INS2PTR = ADDR(INSREC1);  /* CHAIN UP 2ND INSERT    @ZM30991*/
         LA    @12,INSREC1                                         0339
         ST    @12,INS2PTR                                         0339
*        RELMSG1 = 271;                 /* GET MESSAGE NUMBER         *
         MVC   RELMSG1(2),@CH01272                                 0340
*        RELMSG2 = 1;                  /* LOAD RELATIVE LEV-2 NUMBER  *
         MVC   RELMSG2(2),@CH00051                                 0341
*        LEV1INS = 0;                  /* INDICATE NO LEV-1 INSERTION *
         SLR   LEV1INS,LEV1INS                                     0342
*        LEV2INS = ADDR (INSREC);      /* POINT TO INSERTION FOR   0343
*                                         LEVEL-2 MESSAGE             *
         LA    LEV2INS,INSREC                                      0343
*        CALL MSGRTN;                  /* GO PUT OUT MESSAGE          *
         BAL   @14,MSGRTN                                          0344
*        CCODE=8;                      /* INDICATE FLUSH NEEDED       *
         MVC   CCODE(2),@CH00049                                   0345
*        RETREG = SRVPTR;              /* RESTORE RETURN POINT PTR    *
         L     RETREG,SRVPTR                                       0346
*        RETURN;                       /* RETURN FINISH INPUT         *
@EL00002 DS    0H                                                  0347
@EF00002 DS    0H                                                  0347
@ER00002 BR    @14                                                 0347
*        END SRVERRTN;                                             0348
*                                                                  0349
*                                                                  0349
*        /*************************************************************
*        /* THIS ROUTINE PERFORMS ALL I/O REQUESTS ON THE UTILITY     *
*        /* DATA SET. UPON ENTRY, ALL PARAMETERS IN UTPRMLST MUST     *
*        /* BE INITIALIZED BY THE CALLER FOR THE DESIRED OPERATION.   *
*        /* THIS ROUTINE ALSO CHECKS END-OF-DATA FROM A READ NEXT     *
*        /* (RC=4) AND INITIALIZES EODSW TO 1 WHEN IT OCCURS. THIS    *
*        /* CONDITION ALSO CAUSES 'NEXTREC' TO BE INITIALIZED TO      *
*        /* 99999999 FOR A NUMBERED DATA SET OR 2,147,483,648         *
*        /* (2**31-1) FOR A NON-LINENUMBERED DATA SET. IF AN I/O      *
*        /* ERROR IS ENCOUNTERED, 'CCODE' IS SET TO 12 AND THIS       *
*        /* ROUTINE GOES DIRECTLY TO 'EXIT'. RETURN CODES FOR         *
*        /* CALLER ARE: FOR OP CODES 00-20 THE RETURN CODE IS 0 OR    *
*        /* 4 FOR OP CODE 20 A RETURN CODE OF 12 IS ADDED THESE       *
*        /* RETURN CODES ARE AS DESCRIBED FOR IKJEBEUT REGISTER 1     *
*        /* WILL BE LEFT INTACT FOLLOWING A READ                      *
*        /*************************************************************
*IORTN:                                                            0349
*        PROC OPTIONS (NOSAVE, NOSAVEAREA);                        0349
*                                                                  0349
IORTN    DS    0H                                                  0350
*        /* THE FOLLOWING REGISTERS ARE RESTRICTED FOR THE DURATION   *
*        /* OF INPUT                                                  *
*        RESPECIFY (PARMREG1, WREG1, WREG2, COMMREG, SAVEREG, DATAREG,
*            BASEREG,BASEREG2) RSTD;                               0350
*        IORTNPTR = RETREG;            /* SAVE RETURN POINT PTR       *
         ST    RETREG,IORTNPTR                                     0351
*        CODESAVE = 0;                 /* INIT RETURN CODE            *
         SLR   CODESAVE,CODESAVE                                   0352
*        RESPECIFY (RCODEREG) RSTD;                                0353
*        /* CHECK FOR EOD ON PREVIOUS READ NEXT                       *
*        IF EODSW = '1'B                                           0354
*          THEN                        /* YES EOD HAS BEEN REACHED    *
         TM    EODSW,B'00100000'                                   0354
         BNO   @RF00354                                            0354
*            DO;                                                   0355
*                                                                  0355
*              /* IGNORE IF OPERATION WAS A WRITE                     *
*              IF UTOPTCD ^= '20'X                                 0356
*                THEN                  /* NO, OPERATION NOT WRITE     *
         CLI   UTOPTCD,X'20'                                       0356
         BE    @RF00356                                            0356
*                  DO;                                             0357
*                    RCODEREG = 0;       /* SET NORMAL RETURN CODE    *
         SLR   RCODEREG,RCODEREG                                   0358
*                    GOTO IORET;       /* RETURN TO CALLER            *
         B     IORET                                               0359
*                  END;                                            0360
*            END;                                                  0361
*          ELSE;                       /* NO PREVIOUS EOD - ISSUE I/O
*                                         REQUEST                     *
*                                                                  0362
@RF00354 DS    0H                                                  0363
*        /* PERFORM I/O OPERATION BY CALLING IKJEBEUT                 *
*        GEN REFS(COMMREG);                                        0363
*                                                                  0363
@RC00354 DS    0H                                                  0363
         IKJEBESH (COMMREG),IKJEBEUT,PARAM=((COMMREG),UTPRMLST),       X
               MF=(E,SRWORK)
*        /* CHECK RETURN CODE                                         *
*        IF RCODEREG = 0                                           0364
*          THEN                        /* OPERATION SUCCESSFUL        *
         LTR   RCODEREG,RCODEREG                                   0364
         BZ    @RT00364                                            0364
*            GOTO IORET;               /* RETURN TO CALLER            *
*          ELSE;                       /* OPERATION UNSUCCESSFUL      *
*        CODESAVE = RCODEREG;          /* SAVE RETURN CODE            *
*                                                                  0367
         LR    CODESAVE,RCODEREG                                   0367
*        /* CHECK FOR RETURN CODE OF 4                                *
*        IF CODESAVE = 4                                           0368
*          THEN                        /* R.C. = 4                    *
         CH    CODESAVE,@CH00389                                   0368
         BNE   @RF00368                                            0368
*          /* IKJEBEUT RETURN CODE 4 IS VALID ONLY FOR READ FUNCTIONS *
*            DO;                                                   0369
*                                                                  0369
*              /* IF I/O WAS NOT READ NEXT, RETURN                    *
*              IF UTOPTCD = '02'X                                  0370
*                THEN                  /* I/O WAS READ NEXT           *
         CLI   UTOPTCD,X'02'                                       0370
         BNE   @RF00370                                            0370
*                /* END OF DATA SET HAS BEE REACHED                   *
*                  DO;                                             0371
*                    EODSW = '1'B;     /* INDICATE END-OF-DATA        *
*                                                                  0372
         OI    EODSW,B'00100000'                                   0372
*                    /* SET 'NEXTREC'BASED ON WHETHER OR NOT DATA     *
*                    /* SET IS NUMBERED                               *
*                    IF CANONUM = '1'B                             0373
*                      THEN            /* DATA SET NOT NUMBERED       *
         TM    CANONUM(COMMREG),B'00000001'                        0373
         BNO   @RF00373                                            0373
*                        NEXTREC = MAXRECU; /* SET NEXTREC TO MAX  0374
*                                              VALUE                  *
         MVC   NEXTREC(4,COMMREG),MAXRECU                          0374
*                      ELSE            /* DATA SET IS NUMBERED        *
*                        NEXTREC = MAXREC; /* SET NEXTREC TO MAX VALUE*
         B     @RC00373                                            0375
@RF00373 MVC   NEXTREC(4,COMMREG),MAXREC                           0375
*                    GOTO IORET;       /* RETURN TO CALLER            *
         B     IORET                                               0376
*                  END;                                            0377
*                ELSE;                 /* CONTINUE CHECKING RET CODE  *
@RF00370 DS    0H                                                  0379
*            END;                                                  0379
*          ELSE;                       /* CONTINUE CHECKING RET CODE  *
*                                                                  0380
@RF00368 DS    0H                                                  0381
*        /* CHECK FOR I/O ERROR ON UTILITY DATA SET                   *
*        IF CODESAVE = 8                                           0381
*          THEN                        /* YES I/O ERROR OCCURRED      *
         CH    CODESAVE,@CH00049                                   0381
         BNE   @RF00381                                            0381
*            DO;                                                   0382
*              CCODE = 12;             /* SET RETURN CODE             *
         MVC   CCODE(2),@CH00137                                   0383
*              RETREG = ADDR (EXIT);   /* RTURN TO COMMAND MODE       *
         LA    RETREG,EXIT                                         0384
*              RETURN;                 /* RETURN                      *
@EL00003 DS    0H                                                  0385
@EF00003 DS    0H                                                  0385
@ER00003 BR    @14                                                 0385
*            END;                                                  0386
*          ELSE;                       /* RETURN CODE IS NOT 8        *
@RF00381 DS    0H                                                  0388
*IORET:    /* RESET IKJEBEUT RETURN CODE AND RETURN                   *
*        RCODEREG = CODESAVE;          /* FALLING THROUGH HERE ASSUMES
*                                         A RETURN CODE OF 12 RESTORE
*                                         RETURN CODE                 *
IORET    LR    RCODEREG,CODESAVE                                   0388
*        IOPTR = PARMREG1;             /* SET RECORD PTR IN REG 1     *
         L     @14,BACKREG(,SAVEREG)                               0389
         ST    PARMREG1,IOPTR(,@14)                                0389
*        RETREG = IORTNPTR;          /* RESTORE RETURN POINT PTR    */
         L     RETREG,IORTNPTR                                     0390
*        RESPECIFY (RCODEREG) UNRSTD;                              0391
*        RETURN;                                                   0392
         B     @EL00003                                            0392
*        END IORTN;                                                0393
*                                                                  0394
*                                                                  0394
*        /*************************************************************
*        /* THIS ROUTINE IS USED TO PUT OUT MESSAGES WHICH REQUIRE    *
*        /* FIRST AND OR SECOND LEVEL MESSAGES WITH NO INSERTIONS     *
*        /* RELMSG1 CONTAINS THE MESSAGE NUMBER. RELMSG2 CONTAINS     *
*        /* THE RELATIVE SECOND LEVEL NUMBER. 0 IF NONE. LEV1INS      *
*        /* POINTS TO THE FIRST INSERTION FOR THE FIRST LEVEL MSG     *
*        /* . LEV2INS POINTS TO THE FIRST INSERTION FOR THE           *
*        /* SECOND-LEVEL MSG.                                         *
*        /*************************************************************
*MSGRTN:                                                           0394
*        PROC OPTIONS (NOSAVE, NOSAVEAREA);                        0394
MSGRTN   DS    0H                                                  0395
*        RESPECIFY (DATAREG,BASEREG,BASEREG2,PARMREG1,WREG1,WREG2, 0395
*             COMMREG,SAVEREG) RSTD;                               0395
*        MSGPTR = RETREG;           /* SAVE RETURN PT PTR             *
         LR    MSGPTR,RETREG                                       0396
*        GENERATE REFS(LEV1INS,LEV2INS);                           0397
         IKJEBEML ,,(LEV1INS),(LEV2INS),MF=(E,SRWORK)
*        RETREG = MSGPTR;           /* RESTORE RETURN PT PTR          *
         LR    RETREG,MSGPTR                                       0398
*        RETURN;                                                   0399
@EL00004 DS    0H                                                  0399
@EF00004 DS    0H                                                  0399
@ER00004 BR    @14                                                 0399
*        END MSGRTN;                                               0400
*                                                                  0401
*        /*************************************************************
*         /* THIS ROUTINE CONVERTS AN UNPACKED DECIMAL STRING TO      *
*         /* BINARY.                                                  *
*         /*                                                          *
*         /* INPUT                                                    *
*         /*    WREG1 CONTAINS THE LENGTH OF THE STRING               *
*         /*    WREG2 CONTAINS A POINTER TO THE STRING                *
*         /*                                                          *
*         /* OUTPUT - WREG 1 CONTAINS THE CONVERTED VALUE             *
*        /*************************************************************
*CONVERT:                                                          0401
*        PROC OPTIONS (SAVE(14),NOSAVEAREA);                       0401
*                                                                  0401
CONVERT  ST    @14,12(,@13)                                        0401
*        /* GENERATE REQUIRED ASSEMBLER STATEMENTS                    *
*        GEN REFS(WREG1);                                          0402
*                                                                  0402
         BCTR  WREG1,0                 REDUCE LENGTH BY 1
         EX    WREG1,PACK              PACK STRING
         CVB   WREG1,PACKTMP           CONVERT TO BINARY
*        /* GENERATE PACK INSTRUCTION                                 *
*        GEN;                                                      0403
LPACKTMP EQU   8                       LENGTH OF PACKTMP
OFFSET0  EQU   0                       0 OFFSET
PACK     PACK  PACKTMP(LPACKTMP),OFFSET0(,WREG2)
*        RETURN;                                                   0404
@EL00005 DS    0H                                                  0404
@EF00005 DS    0H                                                  0404
@ER00005 L     @14,12(,@13)                                        0404
         BR    @14                                                 0404
*        END CONVERT;                                              0405
*                                                                  0406
*                                                                  0406
*        /*************************************************************
*        /* THIS ROUTINE CONVERTS A BINARY NUMBER TO ZONED DECIMAL    *
*        /* AND PUTS IT IN 'NUMTEMP'. THE NUMBER TO BE CONVERTED IS   *
*        /* ASSUMED TO BE IN CVDREG. THE FOLLOWING REGISTERS ARE      *
*        /* RESTRICTED FOR THE DURATION OF INPUT                      *
*        /*************************************************************
*CVDRTN:                                                           0406
*        PROC OPTIONS (SAVE(14),NOSAVEAREA);                       0406
CVDRTN   ST    @14,12(,@13)                                        0406
*       RESPECIFY (PARMREG1, WREG1, WREG2, COMMREG, SAVEREG, DATAREG)
*       RSTD;                                                      0407
*                                                                  0407
*        /* CONVERT TO DECIMAL                                        *
*        GEN (CVD   CVDREG,PACKTMP  CONVERT NUM TO PACKED DECIMAL) 0408
*        REFS(CVDREG);                                             0408
         CVD   CVDREG,PACKTMP  CONVERT NUM TO PACKED DECIMAL
*        /* GENERATE REQUIRED ASSEMBLER INSTRUCTIONS                  *
*        GEN;                                                      0409
LNUMTMP  EQU   8                       LENGTH OF NUMTEMP
         UNPK  NUMTEMP(LNUMTMP),PACKTMP(LPACKTMP) UNPACK NUMBER
SEVEN    EQU   7                       OFFSET OF SIGN FIELD IN NUMTEMP
         OI    NUMTEMP+SEVEN,C'0'      CHANGE SIGN TO DEC ZONE
*        RETURN;                       /* RETURN TO CALLER            *
@EL00006 DS    0H                                                  0410
@EF00006 DS    0H                                                  0410
@ER00006 L     @14,12(,@13)                                        0410
         BR    @14                                                 0410
*        END CVDRTN;                                               0411
*/*********************************************************************
*/*                                                                   *
*/* THIS SUBROUTINE OF THE INPUT SUBCOMMAND OF EDIT ALLOWS CONTINUAL  *
*/* INPUT LINES TO BE ENTERED INTO A DATA SET.  THE TERMINAL USER IS  *
*/* PROMPTED FOR EACH NEW LINE IF DESIRED. THE INPUT STATEMENTS ARE   *
*/* PASSED TO A SYNTAX CHECKER IF SCAN IS SPECIFIED AND A SYNTAX      *
*/* CHECKER IS AVAILABLE IN THE SYSTEM. THE NEW LINES ARE ADDED TO    *
*/* THE DATA SET UNLESS THE KEYWORD 'R' IS SPECIFIED, IN WHICH CASE   *
*/* EXISTING LINES IN THE DATA SET STARTING AT THE SPECIFIED LOCATION *
*/* ARE REPLACED.  INPUT MODE IS NORMALLY TERMINATED BY HITTING       *
*/* CARRIAGE RETURN ON A NULL LINE.  IN ADDITION, IT IS TERMINATED    *
*/* AFTER DETECTING AN ERROR OR ISSUING A SYNTACTIC DIAGNOSTIC MESSAGE*
*/* IF SCAN IS SPECIFIED.                                             *
*/*                                                                   *
*/*********************************************************************
*CONTRTN:                              /* SUBROUTINE ENTRY POINT      *
*    PROC OPTIONS (NOSAVE,NOSAVEAREA);                             0412
CONTRTN  DS    0H                                                  0413
*        RESPECIFY (PARMREG1, WREG1, WREG2, COMMREG, SAVEREG, DATAREG,
*            BASEREG,BASEREG2) RSTD;                               0413
*        CONTPTR = RETREG;           /* SAVE RETURN POINT PTR        */
         ST    RETREG,CONTPTR                                      0414
*        BFCTLBLK = BFCTLBLK && BFCTLBLK; /* CLEAR SYNTAX CHECKER  0415
*                                            BUFFER POINTERS FOR   0415
*                                            SYNCHK                   *
         XC    BFCTLBLK(12),BFCTLBLK                               0415
*        CASYNECD = '1000'B;           /* INIT SYNTAX CHECKER ENTRY
*                                         CODE                        *
         MVI   CASYNECD(COMMREG),B'10000000'                       0416
*        CCODE = CCODE && CCODE;       /* INIT RETURN CODE            *
         LH    @12,CCODE                                           0417
         LR    @08,@12                                             0417
         XR    @08,@12                                             0417
         STH   @08,CCODE                                           0417
*        SYNSW = SYNSW && SYNSW;       /* CLEAR SYNTAX CHKR SWITCHES  *
         XC    SYNSW(1),SYNSW                                      0418
*        GMPARM = GMPARMX;             /* MOVE SIZE LIST FOR GETMAIN
*                                         TO DYNAMIC AREA             *
*                                                                  0419
         MVC   GMPARM(8),GMPARMX                                   0419
*        /* CHECK DATA SET TYPE FOR PARAMETER INITIALIZATION          *
*        IF CATYPE = CABASIC  CATYPE = CAIPLI                     0420
*          THEN                        /* YES TYPE IS BASIC OR IPLI   *
         CLI   CATYPE(COMMREG),X'20'                               0420
         BE    @RT00420                                            0420
         CLI   CATYPE(COMMREG),X'21'                               0420
         BNE   @RF00420                                            0420
@RT00420 DS    0H                                                  0421
*            CASYNCD2 = '10000'B;      /* INIT SYNTAX CHECKER      0421
*                                         INTERFACE                   *
         MVI   CASYNCD2(COMMREG),B'10000000'                       0421
*          ELSE;                       /* NO, TYPE NOT BASIC OR IPLI  *
@RF00420 DS    0H                                                  0423
*        FLAGS = FLAGS && FLAGS;       /* TURN OFF SWITCHES           *
         XC    FLAGS(1),FLAGS                                      0423
*        UTDCBPTR = CAPTCDCB;          /* SET UTIL DCB PTR            *
         MVC   UTDCBPTR(4),CAPTCDCB(COMMREG)                       0424
*        PTLPBLK = PTLINE;             /* MOVE L-FORM PUTLINE TO WORK
*                                         AREA                        *
*                                                                  0425
         MVC   PTLPBLK(20),PTLINE                                  0425
*MAINLP: ;                             /* MAIN LOOP PROCESSING        *
MAINLP   DS    0H                                                  0427
*        /* CHECK IF NEW LINE WILL FIT IN DATA SET                    *
*        IF NEXTREC > FIRSTLN                                      0427
*          THEN;                       /* NEW LINE WILL FIT IN DATA
*                                         SET - CONTINUE PROCESSING AT
*                                         'SETPRMPT'                  *
         L     @12,NEXTREC(,COMMREG)                               0427
         C     @12,FIRSTLN(,COMMREG)                               0427
         BH    @RT00427                                            0427
*          ELSE                        /* LINE WILL NOT FIT IN DS     *
*                                      /* NO ROOM ROUTINE             *
*            DO;                       /* THERE IS NO ROOM TO PUT THE
*                                         NEW RECORD IN THE DATA SET  *
*                                                                  0429
*              /* CHECK FOR LINE-NUMBERED DATA SET                    *
*              IF CANONUM = '1'B                                   0430
*                THEN                  /* DATA SET NOT NUMBERED       *
         TM    CANONUM(COMMREG),B'00000001'                        0430
         BNO   @RF00430                                            0430
*                                      /* SEQUENCE NUMBER ROUTINE     *
*                  DO;                                             0431
*                                                                  0431
*                    /* CHECK FOR NEW SEQUENCE NUMBER AT MAX VALUE    *
*                    IF MAXRECU <= FIRSTLN                         0432
*                      THEN            /* YES - LINE NUMBER EXCEEDS
*                                         PHYSICAL MAXIMUM            *
         L     @12,MAXRECU                                         0432
         C     @12,FIRSTLN(,COMMREG)                               0432
         BH    @RF00432                                            0432
*                        DO;                                       0433
*                                                                  0433
*                          LEV1INS = 0;    /* INDICATE NO LEV1 INSERT-
*                                             ION                     *
         SLR   LEV1INS,LEV1INS                                     0434
*RENUMMSG:                             /* DATA SET MUST BE RENUMBERED *
*                          RELMSG1 = 776;  /* SET MESSAGE NUMBER      *
RENUMMSG MVC   RELMSG1(2),@CH01296                                 0435
*                          RELMSG2 = 0;    /* INDICATE NO LEVEL-2 MSG *
         SLR   @12,@12                                             0436
         STH   @12,RELMSG2                                         0436
*                          LEV2INS = 0;    /* INDICATE NO LEV-2 INSERT-
*                                             ION                     *
         SLR   LEV2INS,LEV2INS                                     0437
*                          CALL MSGRTN;/* PUT OUT MESSAGE             *
*                                                                  0438
         BAL   @14,MSGRTN                                          0438
*                          CCODE=8;    /* INDICATE FLUSH NEEDED       *
         MVC   CCODE(2),@CH00049                                   0439
*                          GOTO EXIT2; /* ISSUE ERROR MESSAGE - DATA
*                                         SET MUST BE RENUMBERED   0440
*                                         RETURN TO EDIT MODE         *
         B     EXIT2                                               0440
*                        END;                                      0441
*                      ELSE            /* NO - NEW SEQUENCE NUMBER 0442
*                                         DOES NOT EXCEED MAX         *
*                                      /* UPDATE NEXT RECORD          *
*                        DO;                                       0442
@RF00432 DS    0H                                                  0443
*                          FIRSTLN = NEXTREC; /* UPDATE RECORD KEY    *
         MVC   FIRSTLN(4,COMMREG),NEXTREC(COMMREG)                 0443
*                          UTOPTCD = '00'X; /* READ CURRENT           *
*                                                                  0444
         MVI   UTOPTCD,X'00'                                       0444
*                          /* BFR ADDR                                *
*                          UTADPTR = ADDR (CLNBFR (1));            0445
*                                                                  0445
         LA    @12,CLNBFR(,COMMREG)                                0445
         ST    @12,UTADPTR                                         0445
*                          /* POINT TO KEY                            *
*                          UTKEYPTR = ADDR (NEXTREC);              0446
         LA    @12,NEXTREC(,COMMREG)                               0446
         ST    @12,UTKEYPTR                                        0446
*                          LBIT2 = '0'B; /* TURN OFF FLAG             *
         NI    LBIT2,B'01111111'                                   0447
*                          LBIT3 = '1'B; /* TURN ON END-OF-PARM       *
         OI    LBIT3,B'10000000'                                   0448
*                          CALL IORTN; /* READ CURRENT RECORD FOR  0449
*                                         CLNSAVE ROUTINE             *
         BAL   @14,IORTN                                           0449
*                          UTOPTCD = '10'X; /* SET CODE FOR DELETE    *
         MVI   UTOPTCD,X'10'                                       0450
*                          CALL IORTN; /* DELETE RECORD TO BE RIPPLED *
         BAL   @14,IORTN                                           0451
*                          CALL CLNSAVE; /* GO MAKE ROOM IN THE DATA
*                                           SET FOR NEW RECORD        *
         BAL   @14,CLNSAVE                                         0452
*GETNEXT:                  GOTO MAINLP;/* UPON RETURN FROM CLNSAVE,
*                                         'NEXTREC' WILL HAVE BEEN 0453
*                                         UPDATED TO REFLECT THE NEW
*                                         SEQUENCE NUMBER GIVEN TO 0453
*                                         THE EXISTING NEXT RECORD.  GO
*                                         GET THE NEXT INPUT RECORD   *
         B     MAINLP                                              0453
*                        END;                                      0454
*                  END;                                            0455
*                ELSE                  /* DATA SET IS NUMBERED        *
*                                      /* CHECK FOR RECORD NUMBER MAX *
*                  DO;                                             0456
*                                                                  0456
@RF00430 DS    0H                                                  0457
*                    /* CHECK FOR RECORD NUMBER EXCEEDING PHYSICAL    *
*                    /* MAXIMUM                                       *
*                    IF MAXREC <= NEXTREC                          0457
*                      THEN            /* YES, MAX NUMBER EXCEEDED    *
         L     @12,MAXREC                                          0457
         C     @12,NEXTREC(,COMMREG)                               0457
         BH    @RF00457                                            0457
*                        DO;                                       0458
*                          /* LOAD INSERT NUM                         *
*                          LEV1INS = ADDR (INSM402);               0459
         LA    LEV1INS,INSM402                                     0459
*                          GOTO RENUMMSG; /* GO PUT OUT MESSAGE       *
         B     RENUMMSG                                            0460
*                        END;                                      0461
*                      ELSE;           /* NO MAX NOT EXCEEDED         *
*                                                                  0462
@RF00457 DS    0H                                                  0463
*                    /* CHECK IF R-FORM SPECIFIED                     *
*                    IF CAIMIR = '0'B                              0463
*                      THEN            /* R-FORM WAS SPECIFIED        *
         TM    CAIMIR(COMMREG),B'00010000'                         0463
         BZ    @RT00463                                            0463
*                        GO TO SETPRMPT; /* GET NEXT INPUT LINE       *
*                      ELSE            /* R-FORM WAS NOT SPECIFIED THE
*                                         RECORD CANNOT BE DELETED    *
*                        DO;                                       0465
*                                      /* TERMINATE INPUT MODE        *
*                          CVDREG = NEXTREC; /* GET NUMBER TO BE   0466
*                                               CONVERTED             *
         L     CVDREG,NEXTREC(,COMMREG)                            0466
*                          CALL CVDRTN;/* CONVERT NUMBER TO DECIMAL   *
         BAL   @14,CVDRTN                                          0467
*                          INSREC = INSM400; /* MOVE MODEL TO WORKAREA*
*                                                                  0468
         MVC   INSREC(16),INSM400                                  0468
*                          /* THIS DO LOOP LOCATES THE FIRST          *
*                          /* NON-ZERO BYTE OF THE NUMBER TO BE       *
*                          /* SENT TO THE TERMINAL. IT SCANS FROM     *
*                          /* LEFT TO RIGHT.                          *
*                          DO WREG2 = 1 TO LENGTH (INSNUM) BY 1;   0469
*                                                                  0469
         LA    WREG2,1                                             0469
@DL00469 DS    0H                                                  0470
*                            /* CHECK CURRENT CHAR FOR DECIMAL ZERO   *
*                            IF NUMTEMP (WREG2) = '0'              0470
*                              THEN;   /* ZERO, CONTINUE LOOP         *
         LA    @12,NUMTEMP-1(WREG2)                                0470
         CLI   0(@12),C'0'                                         0470
         BNE   @RF00470                                            0470
*                              ELSE    /* NOT ZERO - EXIT             *
*                                GOTO LPOUT1; /* EXIT FROM LOOP       *
*                          END;        /* WREG2 CONTAINS THE OFFSET   *
*                                                                  0473
         AH    WREG2,@CH00051                                      0473
         CH    WREG2,@CH00049                                      0473
         BNH   @DL00469                                            0473
*                          /* RESET TO MAX LENGTH                     *
*                          WREG2 = LENGTH (INSNUM);                0474
         LA    WREG2,8                                             0474
*LPOUT1: ;                             /* CONTINUE                    *
*                                                                  0475
LPOUT1   DS    0H                                                  0476
*                          /* FIND LENGTH OF THE NUMBER               *
*                          WREG1 = LENGTH (INSNUM) + 1 - WREG2;    0476
*                                                                  0476
         LA    WREG1,9                                             0476
         SLR   WREG1,WREG2                                         0476
*                          /* MOVE NON-ZERO PORTION TO INSERTION      *
*                          /* RECORD                                  *
*                          INSNUM (1:WREG1) =                      0477
*                                NUMTEMP(WREG2:WREG2+WREG1-1);     0477
         LR    @12,WREG1                                           0477
         BCTR  @12,0                                               0477
         LA    @08,NUMTEMP-1(WREG2)                                0477
         EX    @12,@SM01400                                        0477
*                          /* FIND INSERT LENGTH                      *
*                          INSLEN = WREG1 + 4;                     0478
*                                                                  0478
         LA    @12,4(,WREG1)                                       0478
         STH   @12,INSLEN                                          0478
*                          RELMSG1 = 774;  /* LOAD MSG NUMBER         *
         MVC   RELMSG1(2),@CH01306                                 0479
*                          RELMSG2 = 0;    /* INDICATE NO LEVEL-2 MSG *
*                                                                  0480
         SLR   @12,@12                                             0480
         STH   @12,RELMSG2                                         0480
*                          /* POINT TO INSERTION                      *
*                          LEV1INS = ADDR (INSREC);                0481
         LA    LEV1INS,INSREC                                      0481
*                          LEV2INS = 0;    /* NO LEVEL-2 INSERTION    *
         SLR   LEV2INS,LEV2INS                                     0482
*                          CALL MSGRTN;/* PUT OUT MESSAGE             *
*                                                                  0483
         BAL   @14,MSGRTN                                          0483
*                          GOTO EXIT2; /* RETURN TO COMMAND MODE      *
         B     EXIT2                                               0484
*                        END;                                      0485
*                  END;                                            0486
*            END;                      /* PROCESSING CONTINUES HERE IF
*                                         THERE IS ROOM TO WRITE THE
*                                         NEXT RECORD FROM THE     0487
*                                         TERMINAL INTO THE DATA SET  *
*SETPRMPT: ;                           /* CONTINUE, LINE FITS         *
*                                                                  0488
@RT00427 DS    0H                                                  0488
SETPRMPT DS    0H                                                  0489
*        /* CHECK FOR SELF PROMPTING                                  *
*        IF CAIMSFPT = '1'B                                        0489
*          THEN                        /* YES, INPUT DOES PROMPTING   *
         TM    CAIMSFPT(COMMREG),B'00000100'                       0489
         BNO   @RF00489                                            0489
*                                      /* NUMBERED DATA SET ROUTINE   *
*            DO;                                                   0490
*                                                                  0490
*              /* CHECK FOR A NUMBERED DATA SET                       *
*              IF CANONUM = '0'B                                   0491
*                THEN;                 /* DATA SET IS NUMBERED        *
         TM    CANONUM(COMMREG),B'00000001'                        0491
         BZ    @RT00491                                            0491
*                ELSE                  /* NO, NOT NUMBERED            *
*                  DO;                                             0493
*                    NUMTEMP (1:2) = 'I ';     /* SET PROMPT CHAR     *
         MVC   NUMTEMP(2),@CC01308                                 0494
*                    LNUMTEMP = 6;     /* SET LENGTH FOR PROMPT       *
         LA    @12,6                                               0495
         STH   @12,LNUMTEMP                                        0495
*                    LTEMPNUM = 6;     /* RESET LENGTH FOR PROMPT     *
         STH   @12,LTEMPNUM                                        0496
*                    NUMBTMP(1:2) = NUMTEMP(1:2);/* RESET PROMPT CHAR *
         MVC   NUMBTMP(2),NUMTEMP                                  0497
*                    GOTO SETLKPRM;    /* GO PUT PROMPT TO TERM       *
         B     SETLKPRM                                            0498
*                  END;                                            0499
*                                      /* PREPARE PROMPT LINE NUMBER  *
*              CVDREG = FIRSTLN;       /* GET NUMBER OF NEXT LINE     *
@RT00491 L     CVDREG,FIRSTLN(,COMMREG)                            0500
*              CALL CVDRTN;            /* CONVERT NUMBER TO DECIMAL   *
         BAL   @14,CVDRTN                                          0501
*              WREG2 = ADDR (NUMTEMP); /* THE FOLLOWING CODE       0502
*                                         ELIMINATES UP TO 3 LEADING
*                                         ZEROS FROM THE NUMBER THAT
*                                         WILL BE SENT TO THE TERMINAL
*                                         AS A PROMPT.  GET ADDR OF
*                                         CONVERTED NUM               *
*                                                                  0502
         LA    WREG2,NUMTEMP                                       0502
*              /* SET LOOP                                            *
*              DO WREG1 = 3 TO 1 BY -1;                            0503
*                                                                  0503
         LA    WREG1,3                                             0503
@DL00503 DS    0H                                                  0504
*                /* CHECK FOR 0                                       *
*                IF WREG2 -> NUMSCAN(1) = '0'                      0504
*                  THEN;               /* CHARACTER IS ZERO           *
         CLI   NUMSCAN(WREG2),C'0'                                 0504
         BNE   @RF00504                                            0504
*                  ELSE                /* NO, NOT ZERO, END LOOP      *
*                    GOTO MVNUM;       /* GO ADJUST NUMBER            *
*                WREG2 = WREG2 + 1;    /* POINT TO NEXT CHAR          *
         AH    WREG2,@CH00051                                      0507
*              END;                    /* CONTINUE LOOP               *
         BCTR  WREG1,0                                             0508
         LTR   WREG1,WREG1                                         0508
         BP    @DL00503                                            0508
*MVNUM: ;                              /* ADJUST NUMBER FOR PRINT OUT *
MVNUM    DS    0H                                                  0510
*              WREG1 = ADDR (NUMTEMP) + 8 - WREG2;    /* FIND LENGTH OF
*                                                        NUM          *
*                                                                  0510
         LA    WREG1,NUMTEMP                                       0510
         AH    WREG1,@CH00049                                      0510
         SLR   WREG1,WREG2                                         0510
*              /* LEFT-ADJUST NUMBER                                  *
*              NUMTEMP (1:WREG1) = WREG2 -> NUMADJ (1:WREG1);      0511
         LR    @12,WREG1                                           0511
         BCTR  @12,0                                               0511
         EX    @12,@SM01402                                        0511
*              LNUMTEMP = WREG1 + 4;   /* STORE LENGTH OF NUMBER      *
         LR    @08,WREG1                                           0512
         AH    @08,@CH00389                                        0512
         STH   @08,LNUMTEMP                                        0512
*              LTEMPNUM = LNUMTEMP + 1;  /* ADD ONE FOR ENDING BLANK  *
         LA    @08,1(,@08)                                         0513
         STH   @08,LTEMPNUM                                        0513
*              NUMBTMP(1:WREG1) = NUMTEMP(1:WREG1); /*PUT NUMBER   0514
*                                                   IN TEMP BUFFER    *
         EX    @12,@SM01404                                        0514
*              NUMBTMP(WREG1+1) = ' ';   /* PLACE BLANK AFTER NUMBER  *
         LA    @12,NUMBTMP(WREG1)                                  0515
         MVI   0(@12),C' '                                         0515
*SETLKPRM: ;                           /* PREPARE TO ISSUE LINE OR CHAR
*                                         PROMPT FOR USER             *
SETLKPRM DS    0H                                                  0517
*              WREG2 = ADDR (PTLPBLK); /* GET ADDR OF PUT/GET PARMS   *
         LA    WREG2,PTLPBLK                                       0517
*              PARMREG1 = ADDR (CATMPLST); /* POINT TO PARM LIST      *
*                                                                  0518
         LA    PARMREG1,CATMPLST(,COMMREG)                         0518
*              /* PROMPT TERMINAL AND GET NEXT LINE                   *
*              GEN REFS(WREG2);                                    0519
         PUTLINE PARM=(WREG2),OUTPUT=(LTEMPNUM,TERM,SINGLE,DATA),      X
               MF=(E,(1))
*              RESPECIFY(RCODEREG) RSTD;                           0520
*              /* CHECK FOR RETURN CODE OF 0                          *
*              IF RCODEREG = 0                                     0521
*                THEN                  /* YES, RETURN CODE IS 0       *
         LTR   RCODEREG,RCODEREG                                   0521
         BZ    @RT00521                                            0521
*                  GOTO RDTERM;        /* CONTINUE PROCESSING         *
*                ELSE                  /* NO, RETURN CODE NOT 0       *
*                  CODESAVE = RCODEREG;/* SAVE RETURN CODE           */
         LR    CODESAVE,RCODEREG                                   0523
*              RESPECIFY(RCODEREG) UNRSTD;                         0524
*              /* CHECK FOR RETURN CODE OF 16                         *
*              IF CODESAVE = 16                                    0525
*                THEN                  /* YES, GETMAIN FAILURE        *
         CH    CODESAVE,@CH00228                                   0525
         BNE   @RF00525                                            0525
*                  DO;                                             0526
*NOCORE: ;                             /* CORE NOT AVAILABLE          *
NOCORE   DS    0H                                                  0528
*                    RELMSG1 = 270;    /* LOAD MESSAGE NUMBER         *
         MVC   RELMSG1(2),@CH01250                                 0528
*                    RELMSG2 = 0;      /* INDICATE NO LEVEL 2         *
         SLR   @12,@12                                             0529
         STH   @12,RELMSG2                                         0529
*                    LEV1INS = ADDR (INSM25); /* POINT TO INSERT      *
         LA    LEV1INS,INSM25                                      0530
*                    LEV2INS = 0;      /* INDICATE NO LEV-2 INSERTION *
         SLR   LEV2INS,LEV2INS                                     0531
*                    CALL MSGRTN;      /* PUT OUT MESSAGE             *
*                                                                  0532
         BAL   @14,MSGRTN                                          0532
*                    CCODE=8;          /* INDICATE FLUSH NEEDED       *
         MVC   CCODE(2),@CH00049                                   0533
*                    GOTO EXIT2;       /* RETURN TO EDIT MODE         *
         B     EXIT2                                               0534
*                  END;                                            0535
*                ELSE;                 /* NOT GETMAIN FAILURE         *
*                                                                  0536
@RF00525 DS    0H                                                  0537
*              /* CHECK FOR RETURN CODE 8 OR 12                       *
*              IF CODESAVE = 12  CODESAVE = 8                     0537
*                THEN                  /* YES RETURN CODE IS 12       *
         CH    CODESAVE,@CH00137                                   0537
         BE    @RT00537                                            0537
         CH    CODESAVE,@CH00049                                   0537
         BNE   @RF00537                                            0537
@RT00537 DS    0H                                                  0538
*                  DO;                                             0538
*                    INSREC = M313INS2;/* MOVE MODEL TO WORK AREA -
*                                         PUTLINE                     *
         MVC   INSREC(16),M313INS2                                 0539
*                    DO;                                           0540
*SRVERR: ;                             /* INVALID RETURN CODE         *
SRVERR   DS    0H                                                  0542
*                      SRVREG2 = CODESAVE; /* GET RETURN CODE         *
         LR    SRVREG2,CODESAVE                                    0542
*                      CALL SRVERRTN;  /* DIAGNOSE CMD SYS ERROR      *
         BAL   @14,SRVERRTN                                        0543
*                      GOTO EXIT2;     /* GO RETURN TO EDIT MODE      *
         B     EXIT2                                               0544
*                    END;                                          0545
*                  END;                                            0546
*                ELSE                  /* RETURN CODE NOT 8 OR 12     *
*                  GOTO EXIT2;         /* GO RETURN TO EDIT MODE      *
*            END;                                                  0548
*          ELSE;                       /* NO, PROMPT ISNONE OR AUTO   *
@RF00489 DS    0H                                                  0550
*RDTERM: ;                             /* GET INPUT FROM USER         *
RDTERM   DS    0H                                                  0551
*        GTPBPTR = ADDR (GLPBLK);      /* SET PARM LIST PTR           *
         LA    GTPBPTR,GLPBLK                                      0551
*        WREG2 = GTPBPTR;              /* POINT TO GETL PARMS         *
         LR    WREG2,GTPBPTR                                       0552
*        PARMREG1 = ADDR (CATMPLST);   /* SET PARM REG                *
*                                                                  0553
         LA    PARMREG1,CATMPLST(,COMMREG)                         0553
*        /* GET LINE FROM TERMINAL                                    *
*        GEN REFS(WREG2);                                          0554
        GETLINE PARM=(WREG2),INPUT=(TERM,PHYSICAL),TERMGET=(EDIT,WAIT),X
               MF=(E,(1))
*                                      /* INTERROGATE RETURN CODE     *
*        WREG2 = RCODEREG;             /* SAVE RETURN CODE REG        *
*                                                                  0555
         LR    WREG2,RCODEREG                                      0555
*        /* CHECK RETURN CODE FROM GETLINE                            *
*        IF WREG2 = 0                                              0556
*          THEN;                       /* OK, CONTINUE                *
         LTR   WREG2,WREG2                                         0556
         BZ    @RT00556                                            0556
*          ELSE                        /* ERROR, NO LINE RETURNED     *
*            DO;                                                   0558
*                                                                  0558
*              /* DID GETMAIN FAIL                                    *
*              IF WREG2 = 24                                       0559
*                THEN                  /* YES GETMAIN FAILED          *
         CH    WREG2,@CH00068                                      0559
         BE    @RT00559                                            0559
*                  GOTO NOCORE;        /* GO PUT OUT MESSAGE          *
*                ELSE                  /* NO, OTHER FAILURE           *
*                  DO;                                             0561
*                                                                  0561
*                    /* CHECK FOR RETURN CODE 8                       *
*                    IF WREG2 = 8                                  0562
*                      THEN            /* ATTN WAS ENTERED            *
         CH    WREG2,@CH00049                                      0562
         BE    @RT00562                                            0562
*                        GOTO EXIT2;   /* GO RETURN TO EDIT MODE      *
*                      ELSE            /* RETURN CODE IS NOT 8        *
*                        DO;                                       0564
*                                                                  0564
*                          /* MOVE MODEL TO WORK AREA - GETLINE       *
*                          INSREC (1:16) = M313INS3;               0565
         MVC   INSREC(16),M313INS3                                 0565
*                          GOTO SRVERR;/* GO PUT OUT MESSAGE          *
         B     SRVERR                                              0566
*                        END;                                      0567
*                  END;                                            0568
*            END;                                                  0569
*                                                                  0569
*        /* CHECK FOR RECORD FROM TERMINAL BEING LONGER THAN MAX      *
*        /* ALLOWABLE FOR DATA SET                                    *
*        IF INLEN <= 259                                           0570
*          THEN                        /* RECORD IS LESS THAN MAX     *
@RT00556 L     @08,INBUFPTR(,GTPBPTR)                              0570
         LH    @08,INLEN(,@08)                                     0570
         CH    @08,@CH01321                                        0570
         BH    @RF00570                                            0570
*            DO;                                                   0571
*              WREG1 = INLEN;          /* SET LENGTH OF INPUT LINE FOR
*                                         MOVE                        *
         LR    WREG1,@08                                           0572
*            END;                                                  0573
*          ELSE                        /* RECORD IS TOO LARGE         *
*            DO;                                                   0574
         B     @RC00570                                            0574
@RF00570 DS    0H                                                  0575
*              MSGSW1 = '1'B;          /* SET SWITCH TO PUT OUT MSG   *
         OI    MSGSW1,B'01000000'                                  0575
*              WREG1 = 259;            /* STORE LENGTH FOR DATA MOVE
*                                         -4 FOR HEADER               *
         LA    WREG1,259                                           0576
*            END;                                                  0577
*        /* CHECK FOR CARRIAGE RETURN ONLY IN INPUT                   *
*        IF WREG1 = 4                                              0578
*          THEN                        /* YES, NEXT LINE IS CR        *
@RC00570 CH    WREG1,@CH00389                                      0578
         BE    @RT00578                                            0578
*                                      /* RETURN TO COMMAND MODE      *
*              GOTO EXIT1;             /* RETURN TO CMD MODE  @ZM30965*
*                                                                  0579
*        /* MOVE NEW REC TO WORK AREA                                 *
*        OUTDATA (1:WREG1 - 4) = INLINE (5:WREG1);                 0580
         LR    @08,WREG1                                           0580
         SH    @08,@CH00124                                        0580
         L     @07,INBUFPTR(,GTPBPTR)                              0580
         EX    @08,@SM01407                                        0580
*        OUTLEN = WREG1;               /* STORE RECORD LENGTH         *
         STH   WREG1,OUTLEN(,COMMREG)                              0581
*        OUTRESV = 0;                  /* CLEAR UNUSED FIELD          *
         SLR   @08,@08                                             0582
         STH   @08,OUTRESV(,COMMREG)                               0582
*        FMADDR = INBUFPTR;            /* LINE HAS BEEN RECEIVED FROM
*                                         THE TERMINAL AND MUST NOW BE
*                                         EDITED FOR TABS AND      0583
*                                         CONVERTED TO UPPER CASE IF
*                                         NECESSARY.  THE BUFFER   0583
*                                         OBTAINED BY GETLINE      0583
*                                         MUST BE FREED.  POINT TO INPU
*                                         BUFFER                      *
         ST    @07,FMADDR                                          0583
*        FMLEN = INLEN;                /* GET LENGTH OF BUFFER        *
         LH    @08,INLEN(,@07)                                     0584
         ST    @08,FMLEN                                           0584
*        FMLIST = FMPRMLST;            /* MOVE L-FORM OF FREEMAIN TO
*                                         WORK AREA                   *
         MVC   FMLIST(10),FMPRMLST                                 0585
*        GEN (FREEMAIN A=FMPARM,MF=(E,FMLIST)); /* FREE GETL BFR      *
         FREEMAIN A=FMPARM,MF=(E,FMLIST)
*        /* CHECK IF R-FORM AND INCREMENT SPECIFIED                   *
*        IF CAIMIR = '0'B & CAIMCIN = '1'B                         0587
*          THEN                        /* YES, R-FORM INCRE SPECIFIED *
         TM    CAIMCIN(COMMREG),B'00001000'                        0587
         BNO   @RF00587                                            0587
         TM    CAIMIR(COMMREG),B'00010000'                         0587
         BNZ   @RF00587                                            0587
*            DO;                                                   0588
*                                                                  0588
*            /* CHECK IF NEW LINE WILL FIT IN DATA SET                *
*RFORMLP:    IF NEXTREC < FIRSTLN                                  0589
*              THEN                    /* NO, DELETE 'NEXTREC'        *
RFORMLP  L     @12,NEXTREC(,COMMREG)                               0589
         C     @12,FIRSTLN(,COMMREG)                               0589
         BNL   @RF00589                                            0589
*                DO;                                               0590
*                  UTOPTCD = '10'X;    /* GO TO IKJEBEUT TO DELETE THE
*                                         CURRENT 'NEXTREC' RECORD.
*                                         SET DELETE CODE.            *
*                                                                  0591
         MVI   UTOPTCD,X'10'                                       0591
*                  /* POINT TO RECORD TO BE DELETED                   *
*                  UTKEYPTR = ADDR (NEXTREC);                      0592
         LA    @12,NEXTREC(,COMMREG)                               0592
         ST    @12,UTKEYPTR                                        0592
*                  LBIT2 = '1'B;       /* SET END-OF-PARM INDICATOR   *
         OI    LBIT2,B'10000000'                                   0593
*                  CALL IORTN;         /* DELETE CURRENT 'NEXTREC'    *
*                                                                  0594
         BAL   @14,IORTN                                           0594
*                  /* IF TYPE IS IPLI OR BASIC, THE DELETION MUST BE  *
*                  /* PASSED TO THE SYNTAX CHECKER                    *
*                  IF CADSCODE = CAIPLI  CADSCODE = CABASIC       0595
*                    THEN              /* TYPE IS BASIC OR IPLI       *
         CLI   CADSCODE(COMMREG),X'21'                             0595
         BE    @RT00595                                            0595
         CLI   CADSCODE(COMMREG),X'20'                             0595
         BNE   @RF00595                                            0595
@RT00595 DS    0H                                                  0596
*                      DO;                                         0596
*                                                                  0596
*                      /* SEE IF SYNTAX CHECKER IS AVAILABLE          *
*                        IF CAPTCHK = 0  SYNCKOFF = '1'B          0597
*                          THEN;       /* NO, CHECKER UNAVAILABLE     *
         ICM   @12,15,CAPTCHK(COMMREG)                             0597
         BZ    @RT00597                                            0597
         TM    SYNCKOFF,B'00001000'                                0597
         BO    @RT00597                                            0597
*                          ELSE        /* YES, CHECKER AVAILABLE      *
*                            DO;                                   0599
*                              STARTV = NEXTREC; /* STORE LINE NUM TO
*                                                   BE DELETED        *
         L     @12,NEXTREC(,COMMREG)                               0600
         ST    @12,STARTV                                          0600
*                              STOPV = NEXTREC; /* LAST LINE TO BE DLT*
         ST    @12,STOPV                                           0601
*                              /* POINT TO DELETE LIST                *
*                              CASYNBFR = ADDR (SNCHKDLT);         0602
         LA    @12,SNCHKDLT                                        0602
         ST    @12,CASYNBFR(,COMMREG)                              0602
*                              CASYNECD = '1000'B; /* SET ENTRY CODE  *
         MVI   CASYNECD(COMMREG),B'10000000'                       0603
*                              CASYNCD2 = '01000'B;/* INDICATE DELETE *
         MVI   CASYNCD2(COMMREG),B'01000000'                       0604
*                              /* POINT TO PARMLIST IN REG ONE        *
*                              PARMREG1 = ADDR (CASYNLST);         0605
         LA    PARMREG1,CASYNLST(,COMMREG)                         0605
*                              CALL CHECKER; /* DELETE RECORD FROM 0606
*                                               POLISH DATA SET       *
         L     @15,CAPTCHK(,COMMREG)                               0606
         BALR  @14,@15                                             0606
*                              CASYNCD2 = '10000'B;/* RESET INTERFACE *
         MVI   CASYNCD2(COMMREG),B'10000000'                       0607
*                            END;                                  0608
*                      END;                                        0609
*                    ELSE;             /* TYPE IS NOT IPLI OR BASIC   *
@RF00595 DS    0H                                                  0611
*                  UTOPTCD = '02'X;    /* SET FOR READ NEXT           *
@RC00595 MVI   UTOPTCD,X'02'                                       0611
*                  LBIT1 = '1'B;       /* SET END-OF-PARM INDICATOR   *
         OI    LBIT1,B'10000000'                                   0612
*                  CALL IORTN;         /* GO READ NEXT                *
*                                                                  0613
         BAL   @14,IORTN                                           0613
*                  /* CHECK FOR SUCCESSFUL READ                       *
*                  IF RCODEREG = 0                                 0614
*                    THEN              /* YES, RECORD FOUND           *
         LTR   RCODEREG,RCODEREG                                   0614
         BNZ   @RF00614                                            0614
*                      NEXTREC = INKEY; /* UPDATE NEXT RECORD PTR     *
         MVC   NEXTREC(4,COMMREG),INKEY(UTPREG1)                   0615
*                  GO TO RFORMLP;      /* CONTINUE TO CHECK           *
         B     RFORMLP                                             0616
*                END;                                              0617
*            END;                                                  0618
*                                                                  0618
@RF00589 DS    0H                                                  0619
*        /* CHECK FOR TRAILING CONTINUATION CHARACTER                 *
*        IF OUTDATA (OUTLEN - 4) = '-'                             0619
*          THEN                        /* YES, CONT CHAR PRESENT      *
@RF00587 LH    @12,OUTLEN(,COMMREG)                                0619
         ALR   @12,COMMREG                                         0619
         CLI   OUTDATA-5(@12),C'-'                                 0619
         BNE   @RF00619                                            0619
*            DO;                                                   0620
*                                                                  0620
*              /* IF TYPE IS BASIC OR IPLI, CONTINUATIONS ARE NOT     *
*              /* LEGAL                                               *
*              IF CADSCODE = CABASIC  CADSCODE = CAIPLI           0621
*                THEN;                 /* TYPE IS BASIC OR IPLI       *
         CLI   CADSCODE(COMMREG),X'20'                             0621
         BE    @RT00621                                            0621
         CLI   CADSCODE(COMMREG),X'21'                             0621
         BE    @RT00621                                            0621
*                ELSE                  /* NOT BASIC OR IPLI           *
*                  CONTSW = '1'B;      /* INDICATE CONT FOLLOWS       *
*                                                                  0623
         OI    CONTSW,B'00010000'                                  0623
*              /* CHECK WHETHER OR NOT TO REMOVE CONTINUATION         *
*              /* CHARACTER                                           *
*              IF CADSCONT = '1'B & CARECFM = '0'B                 0624
*                THEN;                 /* CONT CHAR REMAINS           *
@RT00621 TM    CADSCONT(COMMREG),B'00001000'                       0624
         BNO   @RF00624                                            0624
         TM    CARECFM(COMMREG),B'01000000'                        0624
         BZ    @RT00624                                            0624
*                ELSE                  /* REMOVE CONT CHAR            *
*                  OUTLEN = OUTLEN - 1;  /* BACK UP LENGTH FOR LE     *
@RF00624 LH    @12,OUTLEN(,COMMREG)                                0626
         BCTR  @12,0                                               0626
         STH   @12,OUTLEN(,COMMREG)                                0626
*            END;                                                  0627
*          ELSE                        /* NO, CONT CHAR NOT PRESENT   *
*            CONTSW = '0'B;            /* TURN OFF CONT SWITCH        *
         B     @RC00619                                            0628
@RF00619 NI    CONTSW,B'11101111'                                  0628
*        LETXTPTR = ADDR (OUTLEN);     /* BUILD PARAMETER LIST FOR 0629
*                                         IKJEBELE POINT TO LINE TO BE
*                                         EDITED                      *
@RC00619 LA    @12,OUTLEN(,COMMREG)                                0629
         ST    @12,LETXTPTR                                        0629
*        OUTRESV = 0;                  /* ALWAYS ZERO                 *
         SLR   @12,@12                                             0630
         STH   @12,OUTRESV(,COMMREG)                               0630
*        LEFLAG = '00'X;               /* INIT FLAGS FOR IKJEBELE     *
         MVI   LEFLAG,X'00'                                        0631
*        LECAREA = COMMREG;            /* SET COMM AREA PTR FOR LE    *
*                                                                  0632
         ST    COMMREG,LECAREA                                     0632
*        /* CALL LINE EDITING ROUTINE                                 *
*        GENERATE REFS(COMMREG);                                   0633
         IKJEBESH (COMMREG),IKJEBELE,PARAM=((COMMREG),LEPARM),         X
               MF=(E,SRWORK)
*        /* CHECK RETURN CODE FROM IKJEBELE                           *
*        IF RCODEREG = 0                                           0634
*          THEN;                       /* CODE 0, SUCCESSFUL          *
         LTR   RCODEREG,RCODEREG                                   0634
         BZ    @RT00634                                            0634
*          ELSE                        /* CODE 4 - LINE OVERFLOW      *
*            MSGSW1 = '1'B;            /* SET SW TO PUT OUT 'LINE  0636
*                                         TRUNCATED' MSG              *
         OI    MSGSW1,B'01000000'                                  0636
*        OUTKEY = FIRSTLN;             /* AT THIS POINT THE LINE IS
*                                         READY TO BE WRITTEN INTO THE
*                                         UTILITY DATA SET UPDATE  0637
*                                         RECORD KEY                  *
@RT00634 MVC   OUTKEY(4,COMMREG),FIRSTLN(COMMREG)                  0637
*        UTKEYPTR = ADDR (OUTLINE);    /* POINT TO OUTPUT RECORD      *
         LA    @12,OUTLINE(,COMMREG)                               0638
         ST    @12,UTKEYPTR                                        0638
*        UTOPTCD = '20'X;              /* SET WRITE OP CODE           *
         MVI   UTOPTCD,X'20'                                       0639
*        LBIT2 = '1'B;                 /* SET END-OF-PARMLIST         *
         OI    LBIT2,B'10000000'                                   0640
*        CALL IORTN;                   /* GO WRITE RECORD INTO UTIL
*                                         DATA SET                    *
*                                                                  0641
         BAL   @14,IORTN                                           0641
*        /* CHECK FOR SUCCESSFUL COMPLETION OF WRITE                  *
*        IF RCODEREG = 0                                           0642
*          THEN;                       /* I/O OK - CONTINUE           *
         LTR   RCODEREG,RCODEREG                                   0642
         BZ    @RT00642                                            0642
*          ELSE                        /* ERROR - RECORD NOT WRITTEN  *
*            DO;                                                   0644
*              GOTO EXIT2;             /* GO RETURN TO COMMAND MODE   *
         B     EXIT2                                               0645
*            END;                                                  0646
*        CACURNUM = OUTKEY;            /* CONTINUE PROCESSING HERE FOR
*                                         RET CODE=0 UPDATE CURRENT
*                                         LINE PTR                    *
@RT00642 L     @12,OUTKEY(,COMMREG)                                0647
         ST    @12,CACURNUM(,COMMREG)                              0647
*        CAIMLLNO = OUTKEY;            /* SAVE LAST LINE NUM IN COMM
*                                         AREA                        *
         ST    @12,CAIMLLNO(,COMMREG)                              0648
*        CAIMINPT = '1'B;              /*INDICATE LINE WRITTEN YA00040*
*                                                                  0649
         OI    CAIMINPT(COMMREG),B'00000010'                       0649
*        /* FOR TYPES IPLI OR BASIC OR IF THE SCAN SWITCH IS ON,      *
*        /* SYNTAX CHECKING MUST BE PERFORMED ON THE NEW INPUT LINE   *
*        IF CASCANSW = '1'B                                        0650
*          THEN                        /* SCAN SWITCH IS ON           *
         TM    CASCANSW(COMMREG),B'00010000'                       0650
         BO    @RT00650                                            0650
*            GOTO SYNSCAN;             /* GO SYNTAX CHECK THE LINE    *
*          ELSE                        /* SCAN NOT IN EFFECT          *
*                                                                  0652
*            /* SCAN NOT SPECIFIED CHECK FOR BASIC OR IPLI            *
*            IF CADSCODE = CABASIC  CADSCODE = CAIPLI             0652
*              THEN                    /* TYPE IS IPLI OR BASIC       *
         CLI   CADSCODE(COMMREG),X'20'                             0652
         BE    @RT00652                                            0652
         CLI   CADSCODE(COMMREG),X'21'                             0652
         BNE   @RF00652                                            0652
@RT00652 DS    0H                                                  0653
*                DO;                                               0653
*SYNSCAN:                              /* SYNTAX CHECKING ROTINE      *
*                                      /* PREPARE FOR SYNTAX CHECKING *
*                                                                  0654
*                  /* CHECK TO SEE IF CHECKER AVAILABLE               *
*                  IF CAPTCHK = 0  SYNCKOFF = '1'B                0654
*                    THEN              /* CHECKER NOT AVAILABLE       *
SYNSCAN  ICM   @12,15,CAPTCHK(COMMREG)                             0654
         BZ    @RT00654                                            0654
         TM    SYNCKOFF,B'00001000'                                0654
         BO    @RT00654                                            0654
*                      GOTO NOCHKR;    /* SKIP SYNTAX CHECKING        *
*                    ELSE;             /* CHECKER IS AVAILABLE        *
*                  PARMREG1 = ADDR (OUTLINE); /* POINT TO LINE TO BE
*                                                SYNTAX CHECKED       *
         LA    PARMREG1,OUTLINE(,COMMREG)                          0657
*                  SYNCKSW = '1'B;     /* INDICATE SYN CHKR CALLED    *
         OI    SYNCKSW,B'10000000'                                 0658
*                  CALL SYNCHK;        /* GO SYNTAX SCAN THE LINE     *
         BAL   @14,SYNCHK                                          0659
*                END;                                              0660
*              ELSE;                   /* TYPE IS NOT IPLI OB BASIC   *
@RF00652 DS    0H                                                  0662
*NOCHKR:                               /* SYNTAX CHECKER NOT AVABLE   *
*                                                                  0662
*        /* CHECK FOR LINE OVERFLO  MSG                               *
*        IF MSGSW1 = '1'B                                          0662
*          THEN                        /* YES A MSG IS TO BE SENT     *
NOCHKR   TM    MSGSW1,B'01000000'                                  0662
         BNO   @RF00662                                            0662
*                                      /* MESSAGE TO BE SENT          *
*            DO;                                                   0663
*              MSGSW1 = '0'B;          /* TURN OFF MSG SWITCH         *
         NI    MSGSW1,B'10111111'                                  0664
*              INSREC1 = MSGNUM2;      /* MOVE MODEL TO WORKAREA      *
*                                                                  0665
         MVC   INSREC1(11),MSGNUM2                                 0665
*              /* CHECK IF DATA SET IS LINE NUMBERED                  *
*              IF CANONUM = '0'B                                   0666
*                THEN                  /* DATA SET IS LINE NUMBERED   *
         TM    CANONUM(COMMREG),B'00000001'                        0666
         BNZ   @RF00666                                            0666
*                                      /* CONVERT LINE NUMBER         *
*                  DO;                                             0667
*                    CVDREG = OUTKEY;  /* LOAD NUMBER TO BE CONVERT   *
         L     CVDREG,OUTKEY(,COMMREG)                             0668
*                    CALL CVDRTN;      /* GO CONVERT LINE NUM         *
         BAL   @14,CVDRTN                                          0669
*                    INSREC = MSGNUM1; /* MOVE EXPANDED INSERTION  0670
*                                         RECORD TO DYNAMIC CORE      *
*                                                                  0670
         MVC   INSREC(16),MSGNUM1                                  0670
*                    /* THIS DO LOOP LOCATES THE FIRST NON-ZERO       *
*                    /* BYTE OF THE NUMBER TO BE SENT TO THE          *
*                    /* TERMINAL. IT SCANS FROM LEFT TO RIGHT         *
*                    DO WREG2 = 1 TO LENGTH (NUMTEMP1) BY 1;    /*9178*
         LA    WREG2,1                                             0671
@DL00671 DS    0H                                                  0672
*                      /* CHECK CURRENT CHAR. FOR DECIMAL ZERO        *
*                      IF NUMTEMP1 (WREG2) = '0'        /*     ZA29178*
*                        THEN;         /* ZERO - CONTINUE LOOP        *
         LA    @12,NUMTEMP1-1(WREG2)                               0672
         CLI   0(@12),C'0'                                         0672
         BNE   @RF00672                                            0672
*                        ELSE          /* NOT ZERO - EXIT             *
*                          GOTO LPOUT; /* EXIT FROM LOOP              *
*                    END;              /* WREG2 CONTAINS THE OFFSET   *
         AH    WREG2,@CH00051                                      0675
         CH    WREG2,@CH00049                                      0675
         BNH   @DL00671                                            0675
*                    WREG2 = LENGTH (NUMTEMP1); /* RESET VALUE ZA29178
*                                          TO MAX LENGTH       ZA29178*
*                                                                  0676
         LA    WREG2,8                                             0676
*LPOUT: ;                              /* CONTINUE                    *
LPOUT    DS    0H                                                  0678
*                    /* FIND LENGTH OF NUMBER                         *
*                    WREG1 = LENGTH (INSNUM) + 1 - WREG2;          0678
*                                                                  0678
         LA    WREG1,9                                             0678
         SLR   WREG1,WREG2                                         0678
*                    /* MOVE NONZERO PORTION OF NUMBER TO INSERTION   *
*                    /* RECORD                                        *
*                    INSNUM (1:WREG1) =                            0679
*                        NUMTEMP (WREG2:LENGTH (NUMTEMP));         0679
         LR    @12,WREG1                                           0679
         BCTR  @12,0                                               0679
         LA    @08,NUMTEMP-1(WREG2)                                0679
         EX    @12,@SM01400                                        0679
*                    INSLEN = WREG1 + 4;      /* FIND LENGTH FOR   0680
*                                                INSERTION            *
         LA    @12,4(,WREG1)                                       0680
         STH   @12,INSLEN                                          0680
*                    WREG2 = ADDR (INSREC); /* POINT TO LEVEL-1 INSERT*
         LA    WREG2,INSREC                                        0681
*LNTRMSG:                              /* LENGTH MESSAGE              *
*                    CVDREG = CALRECL - 4;    /* LOAD MAX REC LENGTH TO
*                                             INSERT IN LEVEL-2 MSG   *
LNTRMSG  LH    CVDREG,CALRECL(,COMMREG)                            0682
         SH    CVDREG,@CH00389                                     0682
*                    CALL CVDRTN;      /* CONVERT REG LENGTH TO DEC   *
*                                                                  0683
         BAL   @14,CVDRTN                                          0683
*                    /* MOVE MAX RECORD LEN LEVEL 2 INSERTION         *
*                    INSNUM1 (1:3) = NUMTEMP (6:8);                0684
         MVC   INSNUM1(3),NUMTEMP+5                                0684
*                    LEV1INS = WREG2;  /* POINT TO LEVEL-1 INSERTION  *
         LR    LEV1INS,WREG2                                       0685
*                    RELMSG1 = 1293;   /* LOAD MESSAGE NUMBER         *
         MVC   RELMSG1(2),@CH01335                                 0686
*                    RELMSG2 = 1;      /* LOAD REL SECOND LEVEL NUM   *
         MVC   RELMSG2(2),@CH00051                                 0687
*                    LEV2INS = ADDR (INSREC1); /* POINT TO LEV-2 INS  *
         LA    LEV2INS,INSREC1                                     0688
*                    CALL MSGRTN;      /* PUT OUT MSG                 *
         BAL   @14,MSGRTN                                          0689
*                  END;                /* PUT ERROR MSG OUT TO     0690
*                                         TERMINAL - LINE TRUNCATED   *
*                ELSE                  /* DATA SET IS NOT LINE NUMRD
*                                         PUT OUT SAME MSGS AS ABOVE
*                                         BUT WITHOUT LINE NUMBER     *
*                                      /* NO LINE NUMBERS             *
*                  DO;                                             0691
         B     @RC00666                                            0691
@RF00666 DS    0H                                                  0692
*                    WREG2 = 0;        /* INDICATE NO LINE NUMBER     *
         SLR   WREG2,WREG2                                         0692
*                    GOTO LNTRMSG;     /* GO PUT OUT MESSAGE          *
         B     LNTRMSG                                             0693
*                  END;                                            0694
*            END;                                                  0695
*                                                                  0695
@RC00666 DS    0H                                                  0696
*        /* CHECK FOR ATTENTION ENTERED FROM TERMINAL                 *
*        IF CAATTNIS = '1'B                                        0696
*          THEN                        /* YES - ATTN WAS ENTERED      *
@RF00662 TM    CAATTNIS(COMMREG),B'01000000'                       0696
         BO    @RT00696                                            0696
*            GOTO EXIT2;               /* TERMINATE INPUT             *
*          ELSE;                       /* NO - CONTINUE PROCESSING    *
*                                                                  0698
*        /* THE FOLLOWING CODE COMPUTES THE LINE NUMBER FOR THE       *
*        /* NEXT INPUT LINE AND STORES IT IN 'FIRSTLN'.  CHECK FOR    *
*        /* R-FORM                                                    *
*        IF CAIMIR = '1'B                                          0699
*          THEN                        /* NO R-FORM NOT SPECIFIED     *
         TM    CAIMIR(COMMREG),B'00010000'                         0699
         BNO   @RF00699                                            0699
*            DO;                                                   0700
*                                      /* CUMPUTE NEXT RECORD NUMBER  *
*              FIRSTLN = FIRSTLN + CAIMLINC; /* COMPUTE NEXT RECORD
*                                               NUM                   *
         L     @12,FIRSTLN(,COMMREG)                               0701
         AL    @12,CAIMLINC(,COMMREG)                              0701
         ST    @12,FIRSTLN(,COMMREG)                               0701
*              GOTO MAINLP;            /* GO BACK TO GET NEXT RECORD  *
         B     MAINLP                                              0702
*            END;                                                  0703
*          ELSE;                       /* YES R-FORM SPECIFIED        *
*                                                                  0704
@RF00699 DS    0H                                                  0705
*        /* CHECK FOR INCREMENT SPECIFIED                             *
*        IF CAIMCIN = '1'B                                         0705
*          THEN                        /* YES INCREMENT SPECIFIED     *
         TM    CAIMCIN(COMMREG),B'00001000'                        0705
         BNO   @RF00705                                            0705
*            DO;                                                   0706
*              UTOPTCD = '02'X;        /* SET FOR READ NEXT           *
         MVI   UTOPTCD,X'02'                                       0707
*              UTKEYPTR = ADDR( FIRSTLN); /* POINT TO CURRENT LINE    *
         LA    @12,FIRSTLN(,COMMREG)                               0708
         ST    @12,UTKEYPTR                                        0708
*              LBIT2 = '1'B;           /* SET END-OF-PARM INDICATOR   *
         OI    LBIT2,B'10000000'                                   0709
*              CALL IORTN;             /* READ NEXT RECORD            *
*                                                                  0710
         BAL   @14,IORTN                                           0710
*              /* CHECK IF END OF DATA REACHED                        *
*              IF EODSW = '0'B                                     0711
*                THEN                  /* NO, SET NEW 'NEXTREC'       *
         TM    EODSW,B'00100000'                                   0711
         BNZ   @RF00711                                            0711
*                  NEXTREC = INKEY;    /* SET NEW NEXT RECORD KEY     *
         MVC   NEXTREC(4,COMMREG),INKEY(UTPREG1)                   0712
*              FIRSTLN = FIRSTLN + CAIMLINC; /* UPDATE NEW CURRENT REC*
@RF00711 L     @12,FIRSTLN(,COMMREG)                               0713
         AL    @12,CAIMLINC(,COMMREG)                              0713
         ST    @12,FIRSTLN(,COMMREG)                               0713
*              GO TO MAINLP;           /* CONTINUE PROCESSING         *
         B     MAINLP                                              0714
*            END;                                                  0715
*          ELSE;                       /* NO INCREMENT NOT SPECIFIED  *
@RF00705 DS    0H                                                  0717
*        UTOPTCD = '02'X;              /* AT THIS POINT INPUT IS   0717
*                                         REPLACING THE EXISTING LINES
*                                         IN THE DATA SET          0717
*                                         LINE-BY-LINE.  THE NEXT LINE
*                                         NUMBER IS FOUND BY ISSUING A
*                                         READ NEXT.  SET OP CODE FOR
*                                         IKJEBEUT TO READ NEXT       *
         MVI   UTOPTCD,X'02'                                       0717
*        UTKEYPTR = ADDR (FIRSTLN);    /* POINT TO KEY OF CURRENT  0718
*                                         RECORD                      *
         LA    @12,FIRSTLN(,COMMREG)                               0718
         ST    @12,UTKEYPTR                                        0718
*        LBIT2 = '1'B;                 /* SET END-OF-PARMLIST         *
         OI    LBIT2,B'10000000'                                   0719
*        CALL IORTN;                   /* GO GET NEXT RECORD FROM  0720
*                                         UTILITY DATA SET            *
*                                                                  0720
         BAL   @14,IORTN                                           0720
*        /* CHECK FOR END-OF-DATA                                     *
*        IF EODSW = '1'B                                           0721
*          THEN                        /* EOD REACHED ON UTIL DS      *
         TM    EODSW,B'00100000'                                   0721
         BNO   @RF00721                                            0721
*            DO;                                                   0722
*              CAIMIR = '1'B;          /* TURN OFF R SWITCH           *
         OI    CAIMIR(COMMREG),B'00010000'                         0723
*              FIRSTLN = FIRSTLN + CAIMLINC; /* COMPUTE NEXT LINE NUM *
         L     @12,FIRSTLN(,COMMREG)                               0724
         AL    @12,CAIMLINC(,COMMREG)                              0724
         ST    @12,FIRSTLN(,COMMREG)                               0724
*              GOTO MAINLP;            /* GO BEGIN AUTO LINE PROMPT   *
         B     MAINLP                                              0725
*            END;                                                  0726
*          ELSE;                       /* EOD NOT REACHED ON UTIL DS  *
@RF00721 DS    0H                                                  0728
*        DO;                                                       0728
*          FIRSTLN = INKEY;            /* SET FIRST LINE NUMBER       *
         MVC   FIRSTLN(4,COMMREG),INKEY(UTPREG1)                   0729
*          GOTO MAINLP;                /* SEND NEXT LINE NUMBER       *
         B     MAINLP                                              0730
*        END;                                                      0731
*EXIT2:                                /* EXIT ROUTINE                *
*        IF CAATTNIS = '0'B            /* ISSUE TCLEARQ ONLY IFYA02023*
*          THEN IF CCODE = 16         /* NO ATTENTION AND     YA02023*
EXIT2    TM    CAATTNIS(COMMREG),B'01000000'                       0732
         BNZ   @RF00732                                            0732
*                  CCODE = 0           /* RETURN CODE=0 OR 16  YA02023*
*          THEN GEN (TCLEARQ INPUT);   /* CLEAR INPUT LINES    YA02023*
         LH    @12,CCODE                                           0733
         CH    @12,@CH00228                                        0733
         BE    @RT00733                                            0733
         LTR   @12,@12                                             0733
         BNZ   @RF00733                                            0733
@RT00733 DS    0H                                                  0734
         TCLEARQ INPUT
*          ELSE;                       /*                      YA02023*
@RF00733 DS    0H                                                  0736
*          ELSE;                       /*                      YA02023*
@RF00732 DS    0H                                                  0737
*EXIT1:                                /*                      YA02023*
*        CAIMSC = '0'B;                /* TURN OFF SUBCMD SWITCH      *
*                                                                  0737
EXIT1    NI    CAIMSC(COMMREG),B'11011111'                         0737
*        /* CHECK FOR SYNCHK ROUTINE BEING CALLED                     *
*        IF SYNCKSW = '1'B                                         0738
*          THEN                        /* YES IT WAS CALLED           *
         TM    SYNCKSW,B'10000000'                                 0738
         BNO   @RF00738                                            0738
*                                      /* CHECK FOR REMAINING RECORDS *
*            DO;                                                   0739
*                                                                  0739
*              /* CHECK FOR REMAINING RECORDS TO BE SENT TO THE       *
*              /* SYNTAX CHECKER                                      *
*              IF CONTSW = '1'B                                    0740
*                THEN                  /* YES CLEAN-UP NEEDED         *
         TM    CONTSW,B'00010000'                                  0740
         BNO   @RF00740                                            0740
*                  DO;                                             0741
*                    PARMREG1 = 0;     /* INDICATE CLEAN-UP           *
         SLR   PARMREG1,PARMREG1                                   0742
*                    CALL SYNCHK;      /* GO TO SYNTAX CHECKER        *
         BAL   @14,SYNCHK                                          0743
*                  END;                                            0744
*                ELSE;                 /* NO, CLEAN-UP NOT NEEDED     *
@RF00740 DS    0H                                                  0746
*              FMLIST = FMPRMLST;      /* MOVE L-FORM OF FREEMAIN     *
         MVC   FMLIST(10),FMPRMLST                                 0746
*              FMADDR = SNBFRPT;       /* POINT TO LAST SYNCHK BFR    *
         L     @12,SNBFRPT                                         0747
         ST    @12,FMADDR                                          0747
*              FMLEN = SNBFRPT -> BUFLEN; /* GET BUFFER LENGTH        *
*                                                                  0748
         LH    @12,BUFLEN(,@12)                                    0748
         ST    @12,FMLEN                                           0748
*              /* FREE CHECKER BUFFER                                 *
*              GEN (FREEMAIN A=FMPARM,MF=(E,FMLIST));              0749
         FREEMAIN A=FMPARM,MF=(E,FMLIST)
*            END;                                                  0750
*          ELSE;                       /* NO, CONTIN NOT EXPECTED     *
*                                                                  0751
@RF00738 DS    0H                                                  0752
*        /* CHECK FOR ENTRY FROM INSERT SUBCOMMAND                    *
*        IF CAIMINS = '1'B                                         0752
*          THEN                        /* YES, ENTRY FROM INSERT      *
         TM    CAIMINS(COMMREG),B'01000000'                        0752
         BNO   @RF00752                                            0752
*            CAIMLINC = SAVEINCR;      /* RESTORE LAST USED INCRMNT   *
         MVC   CAIMLINC(4,COMMREG),SAVEINCR(COMMREG)               0753
*          ELSE;                       /* NO, ENTRY NOT FROM INSERT   *
@RF00752 DS    0H                                                  0755
*        CAIMFLG (2:6) = '0000000'B;   /* TURN OFF FLAGS       YA00040*
*                                                                  0755
         NI    CAIMFLG(COMMREG),B'10000011'                        0755
*        /* CHECK IF AUTOMATIC LINE PROMPTING IN EFFECT               *
*        IF CAPROMPT = '1'B                                        0756
*          THEN                        /* YES, STOP AUTO PROMPTING    *
         TM    CAPROMPT(COMMREG),B'00100000'                       0756
         BNO   @RF00756                                            0756
*            GEN (SPAUTOPT);           /* ISSUE STOP PROMPTING MACRO  *
*                                                                  0757
         SPAUTOPT
*        /* CHECK IF ATTENTION WAS ISSUED                             *
*        IF CAATTNIS = '0'B                                        0758
*          THEN                        /* NO, MODE MSG NOT ALREADY OUT*
@RF00756 TM    CAATTNIS(COMMREG),B'01000000'                       0758
         BNZ   @RF00758                                            0758
*            CAMODMSG = '1'B;          /* INDICATE MODE MESSAGE IS TO
*                                         GO TO THE TERMINAL FROM MA  *
         OI    CAMODMSG(COMMREG),B'00010000'                       0759
*        RCODEREG = CCODE;             /* SET RETURN CODE             *
@RF00758 LH    RCODEREG,CCODE                                      0760
*        RETREG = CONTPTR;             /* RESTORE RETURN POINT PTR    *
         L     RETREG,CONTPTR                                      0761
*        RETURN;                       /* RETURN TO COMMAND MODE      *
@EL00007 DS    0H                                                  0762
@EF00007 DS    0H                                                  0762
@ER00007 BR    @14                                                 0762
*        END CONTRTN;                      /*       END OF CONTRTN    *
*SYNCHK:                                                           0764
*        /* ********************************************************* *
*        /* THIS ROUTINE TAKES A NEW INPUT LINE AND PASSES IT ALONG   *
*        /* WITH ANY CONTINUATION LINES TO THE APPROPRIATE SYNTAX     *
*        /* CHECKER. IT GETS CORE FOR ALL REQUIRED BUFFERS AND        *
*        /* CHAINS THE BUFFERS TOGETHER. IT ALSO EXAMINES THE         *
*        /* RETURN CODE FROM THE SYNTAX CHECKER AND HANDLES ANY       *
*        /* NON-ZERO CONDITIONS. INPUT PARMREG1 POINTS TO NEW INPUT   *
*        /* LINE (INCLUDING THE KEY) IT IS SET TO ZERO TO TELL        *
*        /* SYNCHK TO PASS ANY LINES IT CURRENTLY HAS IN A BUFFER     *
*        /* TO THE SYNTAX CHECKER. NO RETURN CODE IS PASSED BACK TO   *
*        /* THE CALLING ROUTINE AS ALL ERROR CONDITIONS ARE HANDLED   *
*        /* LOCALLY.                                                  *
*        /* ********************************************************* *
*        PROC (Q) OPTIONS (NOSAVE, NOSAVEAREA);                    0764
SYNCHK   MVC   @PC00008(4),0(@01)                                  0764
*        /* THE FOLLOWING REGISTERS ARE RESTRICTED FOR THE DURATION   *
*        /* OF INPUT                                                  *
*        RESPECIFY (PARMREG1, WREG1, WREG2, COMMREG, SAVEREG, DATAREG,
*            BASEREG) RSTD;                                        0765
*        SYNPTR = RETREG;             /* SAVE RETURN POINT PTR        *
*                                                                  0766
         ST    RETREG,SYNPTR                                       0766
*        /* CHECK THE PARM REG TO SEE IF A NEW LINE IS PRESENT        *
*        IF PARMREG1 = 0                                           0767
*          THEN                        /* NO, NEW LINE NOT PRESENT.
*                                         PASS ANY COLLECTED LINES TO
*                                         SYNTAX CHECKER              *
         SLR   @12,@12                                             0767
         CR    PARMREG1,@12                                        0767
         BE    @RT00767                                            0767
*            GOTO NOLINE;              /* GO CLEAN UP                 *
*          ELSE;                       /* YES, NEW LINE IS PRESENT    *
*        INPTR = PARMREG1;             /* SAVE PTR TO LINE            *
         LR    INPTR,PARMREG1                                      0770
*        CODE8SW = '0'B;               /* TURN OFF RET CODE 8 SWITCH  *
*                                                                  0771
         NI    CODE8SW,B'10111111'                                 0771
*        /* SEE IF BUFFERS WERE PREVIOUSLY ACQUIRED                   *
*        IF SNBFRPT = 0                                            0772
*          THEN                        /* NO, BUFFER HAS NOT BEEN  0772
*                                         ACQUIRED                    *
         SLR   @08,@08                                             0772
         C     @08,SNBFRPT                                         0772
         BNE   @RF00772                                            0772
*                                      /* GET CORE                    *
*            DO;                                                   0773
*              LENPTR = ADDR (GMPARM); /* INIT PARM LIST FOR GETMAIN  *
         LA    @08,GMPARM                                          0774
         ST    @08,LENPTR                                          0774
*              ADDRPTR = ADDR (GMDATA);/* POINT TO ADDR LIST          *
*                                                                  0775
         LA    @08,GMDATA                                          0775
         ST    @08,ADDRPTR                                         0775
*              /* ISSUE GETMAIN FOR FIRST BUFFER                      *
*              GEN (GETMAIN VC,SP=1,MF=(E,GMPRMLST));              0776
*                                                                  0776
         GETMAIN VC,SP=1,MF=(E,GMPRMLST)
*              /* CHECK FOR SUCCESSFUL COMPLETION                     *
*              IF RCODEREG = 0                                     0777
*                THEN;                 /* SUCCESSFUL CONTINUE         *
         LTR   RCODEREG,RCODEREG                                   0777
         BZ    @RT00777                                            0777
*                ELSE                  /* UNSUCCESSFUL, DIAGNOSE      *
*                  DO;                                             0779
*NOCOREMG:                             /* ISSUE NO CORE AVAILABLE MSG *
*                    RELMSG1 = 270;    /* LOAD MSG NUMBER             *
NOCOREMG MVC   RELMSG1(2),@CH01250                                 0780
*                    RELMSG2 = 0;      /* LOAD REL LEV-2 NUMBER       *
         SLR   @12,@12                                             0781
         STH   @12,RELMSG2                                         0781
*                    LEV1INS = ADDR (INSM25); /* POINT TO LEV-1 INSERT*
         LA    LEV1INS,INSM25                                      0782
*                    LEV2INS = 0;      /* INDICATE NO LEV-2 INSERT    *
         SLR   LEV2INS,LEV2INS                                     0783
*                    CALL MSGRTN;      /* PUT OUT MSG                 *
         BAL   @14,MSGRTN                                          0784
*                    CCODE=8;          /* INDICATE FLUSH NEEDED       *
         MVC   CCODE(2),@CH00049                                   0785
*                    SYNCKOFF = '1'B;  /* STOP FURTHER SYNTX CHKING   *
         OI    SYNCKOFF,B'00001000'                                0786
*                    SYNCKSW = '0'B;   /* SUPPRESS FINAL FREEMAIN     *
         NI    SYNCKSW,B'01111111'                                 0787
*                    GOTO SNEXIT;      /* RETURN TO COMMAND MODE      *
         B     SNEXIT                                              0788
*                  END;                                            0789
*              SNBFRPT = GMADDR;       /* THIS CODE INITIALIZES FOR
*                                         THE FIRST BUFFER.  SAVE ADDR
*                                         OF BUFFER                   *
@RT00777 L     @08,GMADDR                                          0790
         ST    @08,SNBFRPT                                         0790
*              SNCURBF = GMADDR;       /* POINT TO CURRENT BUFFER     *
         ST    @08,SNCURBF                                         0791
*              SNCURPOS = 8 + GMADDR;     /* PT TO FIRST AVAIL BYTE   *
         LA    @00,8                                               0792
         ALR   @00,@08                                             0792
         ST    @00,SNCURPOS                                        0792
*              BUFLEN = GMLEN;         /* SAVE LENGTH WITH BUFFER     *
         MVC   BUFLEN(2,@08),GMLEN+2                               0793
*              RECNUM = 0;             /* RESET RECORD COUNT          *
         MVI   RECNUM(@08),X'00'                                   0794
*              NEXTBFR = 0;            /* INDICATE LAST BUFFER        *
         SLR   @00,@00                                             0795
         STCM  @00,7,NEXTBFR(@08)                                  0795
*            END;                                                  0796
*          ELSE;                       /* YES,BUFFER WAS ACQUIRED     *
*                                                                  0797
@RF00772 DS    0H                                                  0798
*        /* CHECK TO SEE IF NEW RECORD CAN FIT IN CURRENT BUFFER      *
*        IF SNCURBF + BUFLEN - SNCURPOS < NEWLEN                   0798
*          THEN                        /* LINE WILL NOT FIT IN BFR    *
         L     @08,SNCURBF                                         0798
         LH    @00,BUFLEN(,@08)                                    0798
         ALR   @00,@08                                             0798
         SL    @00,SNCURPOS                                        0798
         CH    @00,NEWLEN(,INPTR)                                  0798
         BNL   @RF00798                                            0798
*                                      /* LINE TOO LARGE              *
*            DO;                                                   0799
*              LENPTR = ADDR (GMPARM); /* POINT TO RANGE LIST         *
         LA    @08,GMPARM                                          0800
         ST    @08,LENPTR                                          0800
*              ADDRPTR = ADDR (GMDATA);/* POINT TO ADDR LIST          *
*                                                                  0801
         LA    @08,GMDATA                                          0801
         ST    @08,ADDRPTR                                         0801
*              /* GET CORE FOR NEW BUFFER                             *
*              GEN (GETMAIN VC,SP=1,MF=(E,GMPRMLST));              0802
*                                                                  0802
         GETMAIN VC,SP=1,MF=(E,GMPRMLST)
*              /* CHECK RETURN CODE  FROM GETMAIN                     *
*              IF RCODEREG = 0                                     0803
*                THEN;                 /* SUCCESSFUL, CONTINUE        *
         SLR   @14,@14                                             0803
         CR    RCODEREG,@14                                        0803
         BNE   @RF00803                                            0803
*                ELSE                  /* UNSUCESSFUL GETMAIN         *
*                  GOTO NOCOREMG;      /* GO PUT OUT ERROR MSG        *
*              SNCURPOS = GMADDR + 8;   /* SET CURRENT LINE PTR       *
         L     @08,GMADDR                                          0806
         LA    @15,8                                               0806
         LR    @00,@08                                             0806
         ALR   @00,@15                                             0806
         ST    @00,SNCURPOS                                        0806
*              SNCURBF -> NEXTBFR = GMADDR + 4;   /* CHAIN PREVIOUS
*                                                    BUFFER TO CURRENT
*                                                    ONE              *
         LA    @00,4                                               0807
         ALR   @00,@08                                             0807
         L     @05,SNCURBF                                         0807
         STCM  @00,7,NEXTBFR(@05)                                  0807
*              SNCURBF = GMADDR;       /* UPDATE CURRENT BFR PTR      *
         ST    @08,SNCURBF                                         0808
*              BUFLEN = GMLEN;         /* STORE BUFFER LENGTH         *
         L     @00,GMLEN                                           0809
         STH   @00,BUFLEN(,@08)                                    0809
*              RECNUM = 0;             /* INIT RECORD COUNT           *
         MVI   RECNUM(@08),X'00'                                   0810
*              NEXTBFR = 0;            /* INDICATE LAST BUFFER        *
*                                                                  0811
         STCM  @14,7,NEXTBFR(@08)                                  0811
*              /* FIND OUT IF NEXT INPUT LINE WILL FIT IN NEW         *
*              /* BUFFER                                              *
*              IF NEWLEN > BUFLEN - 8                              0812
*                THEN                  /* NO, LINE WILL NOT FIT       *
         SLR   @00,@15                                             0812
         CH    @00,NEWLEN(,INPTR)                                  0812
         BL    @RT00812                                            0812
*                  GOTO NOCOREMG;      /* GO PUT OUT MSG              *
*                ELSE;                 /* YES, LINE WILL FIT          *
*            END;                                                  0815
*          ELSE;                       /* YES LINE WILL FIT IN CURRENT
*                                         BUFFER                      *
*                                                                  0816
@RF00798 DS    0H                                                  0817
*        /* AT THIS POINT THE NEW LINE CAN BE PUT IN THE BUFFER FOR   *
*        /* FIXED LENGTH RECORDS, DO NOT INCLUDE THE LL00 FIELD       *
*        IF CARECFM = '1'B                                         0817
*          THEN                        /* FORMAT IS FIXED             *
         TM    CARECFM(COMMREG),B'01000000'                        0817
         BNO   @RF00817                                            0817
*            DO;                                                   0818
*              BUFLINE (1:NEWLEN - 4) = NEWDATA;    /* MOVE NEWLINE INT
*                                                      BUFFER         *
         L     @08,SNCURPOS                                        0819
         LH    @15,NEWLEN(,INPTR)                                  0819
         LR    @14,@15                                             0819
         SH    @14,@CH00124                                        0819
         EX    @14,@SM01411                                        0819
*              SNCURPOS = SNCURPOS + NEWLEN - 4;    /* UPDATE POSITION
*                                                      PTR            *
         ALR   @08,@15                                             0820
         SH    @08,@CH00389                                        0820
         ST    @08,SNCURPOS                                        0820
*            END;                                                  0821
*          ELSE                        /* FORMAT IS VARIABLE          *
*            DO;                                                   0822
         B     @RC00817                                            0822
@RF00817 DS    0H                                                  0823
*              BUFLINE (1:NEWLEN) = NEWLINE (5:4+NEWLEN); /* MOVE NEW
*                                                   LINE TO BFR       *
         L     @08,SNCURPOS                                        0823
         LH    @15,NEWLEN(,INPTR)                                  0823
         LR    @14,@15                                             0823
         BCTR  @14,0                                               0823
         EX    @14,@SM01413                                        0823
*              SNCURPOS = SNCURPOS + NEWLEN; /* UPDATE POSTION PTR    *
         ALR   @08,@15                                             0824
         ST    @08,SNCURPOS                                        0824
*            END;                                                  0825
*        RECNUM = RECNUM + 1;          /* INCREMENT RECORD COUNT      *
*                                                                  0826
@RC00817 L     @12,SNCURBF                                         0826
         LA    @08,1                                               0826
         SLR   @00,@00                                             0826
         IC    @00,RECNUM(,@12)                                    0826
         ALR   @08,@00                                             0826
         STC   @08,RECNUM(,@12)                                    0826
*        /* CHECK FOR CONTINUATION POSSIBILITY AT THIS POINT          *
*        IF CONTSW = '1'B                                          0827
*          THEN                        /* YES CONT INDICATED          *
         TM    CONTSW,B'00010000'                                  0827
         BO    @RT00827                                            0827
*            GOTO SYNEXIT;             /* GET NEXT RECORD             *
*          ELSE;                       /* NO CONT RECORD              *
*NOLINE:                               /* NO MORE LINES            0830
*                                         AT THIS POINT THE        0830
*                                         ACCUMULATED RECORDS MUST BE
*                                         SENT TO THE CHECKER         *
*        CASYNECD = '1000'B;           /* ENTRY AT THIS POINT IS WHEN
*                                         THERE IS NO INPUT RECORD TO
*                                         SYNCHK BUT INPUT MODE IS 0830
*                                         BEING TERMINATED. ANY    0830
*                                         ACCUMULATED RECORDS MUST BE
*                                         SENT TO THE SYNTAX CHECKER
*                                         BEFORE CLEANUP. INDICATE 0830
*                                         NORMAL ENTRY TO SYNTAX   0830
*                                         CHECKER                     *
*                                                                  0830
NOLINE   MVI   CASYNECD(COMMREG),B'10000000'                       0830
*        /* CHECK TYPE FOR BASIC OR IPLI                              *
*        IF CATYPE = CABASIC  CATYPE = CAIPLI                     0831
*          THEN                        /* YES, TYPE IS BASIC OR IPLI  *
         CLI   CATYPE(COMMREG),X'20'                               0831
         BE    @RT00831                                            0831
         CLI   CATYPE(COMMREG),X'21'                               0831
         BNE   @RF00831                                            0831
@RT00831 DS    0H                                                  0832
*            DO;                                                   0832
*              CASYNCD2 = '10000'B;    /* SET SPECIAL OPTION CODE     *
         MVI   CASYNCD2(COMMREG),B'10000000'                       0833
*            END;                                                  0834
*          ELSE;                       /* NO, TYPE IS NOT BASIC OR 0835
*                                         IPLI                        *
@RF00831 DS    0H                                                  0836
*        CASYNIS = '0'B;               /* SUPPRESS RETURN CODE 12     *
         NI    CASYNIS(COMMREG),B'11101111'                        0836
*        CONTSW = '0'B;                /* TURN OFF CONTIN INDICATOR   *
         NI    CONTSW,B'11101111'                                  0837
*CALLCKR:                              /* INVOKE SYNTAX CHECKER       *
*        PARMREG1 = ADDR (CASYNLST);   /* POINT TO CHECKER PARM LIST  *
CALLCKR  LA    PARMREG1,CASYNLST(,COMMREG)                         0838
*        CASYNBFR = SNBFRPT + 4;       /* SET FIRST BFR PTR           *
         LA    @12,4                                               0839
         AL    @12,SNBFRPT                                         0839
         ST    @12,CASYNBFR(,COMMREG)                              0839
*        CALL CHECKER;                 /* PASS BUFFER(S) TO SYNTAX 0840
*                                         CHECKER                     *
         L     @15,CAPTCHK(,COMMREG)                               0840
         BALR  @14,@15                                             0840
*        RESPECIFY (RCODEREG) RSTD;                                0841
*        /* CHECK RETURN CODE FROM SYNTAX CHECKER                     *
*        IF RCODEREG = 0                                           0842
*          THEN                        /* NORMAL RETURN - CONTINUE 0842
*                                         PROCESSING                  *
*                                                                  0842
         LTR   RCODEREG,RCODEREG                                   0842
         BNZ   @RF00842                                            0842
*            /* CHECK FOR ANY ERROR DETECTED PREVIOUSLY               *
*            IF SYNERSW = '0'B                                     0843
*              THEN;                   /* NO ERROR-NORMAL EXIT        *
         TM    SYNERSW,B'00000100'                                 0843
         BNZ   @RF00843                                            0843
*              ELSE                    /* PREVIOUS ERRORS             *
*                GOTO EXITCK;          /* RETURN TO COMMAND MODE      *
*          ELSE                        /* ERROR RETURN                *
*                                      /* ERROR RETURN                *
*            DO;                                                   0846
         B     @RC00842                                            0846
@RF00842 DS    0H                                                  0847
*              CODESAVE = RCODEREG;    /* THE FOLLOWING CODE TO THE
*                                         END OF DO66 PROCESSES ALL
*                                         NONE-ZERO RETURN CODES.  SAVE
*                                         RETURN CODE                 *
         LR    CODESAVE,RCODEREG                                   0847
*              RESPECIFY (RCODEREG) UNRSTD;                        0848
*                                                                  0848
*              /* RETURN CODE 4                                       *
*              IF CODESAVE = 4                                     0849
*                THEN                  /* RETURN CODE IS 4            *
         CH    CODESAVE,@CH00389                                   0849
         BNE   @RF00849                                            0849
*                  DO;                                             0850
*                                                                  0850
*                  /* CHECK IF DATA SET TYPE IS BASIC OR IPLI         *
*                  IF CATYPE ^= CABASIC & CATYPE ^= CAIPLI         0851
*                  THEN                /* NO, ISSUE MESSAGE TO USER   *
         CLI   CATYPE(COMMREG),X'20'                               0851
         BE    @RF00851                                            0851
         CLI   CATYPE(COMMREG),X'21'                               0851
         BE    @RF00851                                            0851
*DO68:                                                             0852
*                  DO;                                             0852
DO68     DS    0H                                                  0853
*                    SYNERRTX = SYNMSG;/* MOVE ERROR MSG TO BUFFER    *
         L     @12,CASYNMS1(,COMMREG)                              0853
         MVC   SYNERRTX(72),SYNMSG(@12)                            0853
*                    SYNERRM2 = 0;     /* CLEAR SECOND INSERT PTR     *
         SLR   @12,@12                                             0854
         ST    @12,SYNERRM2                                        0854
*                    SYNERRLN = 76;    /* SET LENGTH FIELD IN MSG  0855
*                                         HEADER                      *
         MVC   SYNERRLN(2),@CH01354                                0855
*                    SYNERROF = 0;       /* SET INSERTION POINT       *
*                                                                  0856
         STH   @12,SYNERROF                                        0856
*                    WREG1 = 0;        /* INDICATE NO LEV-2 MSG       *
         SLR   WREG1,WREG1                                         0857
*                    WREG2 = 0;        /* INDICATE NO LEV-2 INSERTION *
         SLR   WREG2,WREG2                                         0858
*                    LEV2INS = WREG2;  /* THE NEXT 4 STATEMENTS MUST
*                                         BE KEPT IN THIS EXACT ORDER
*                                         POINT TO LEV-2 INSERTION    *
*                    LEV1INS = ADDR (SYNERMG1); /* POINT TO LEV-1  0860
*                                                  INSERT             *
         LA    LEV1INS,SYNERMG1                                    0860
*                    RELMSG2 = WREG2;  /* LOAD REL LEV-2 NUMBER       *
         STH   WREG2,RELMSG2                                       0861
*                    RELMSG1 = 1280;   /* LOAD MESSAGE NUMBER         *
*                                                                  0862
         MVC   RELMSG1(2),@CH01355                                 0862
*                    /* CHECK WHETHER OR NOT TO PUT OUT MESSAGE       *
*                    IF CASCANSW = '1'B                            0863
*                      THEN            /* YES PUT OUT MESSAGE         *
         TM    CASCANSW(COMMREG),B'00010000'                       0863
         BNO   @RF00863                                            0863
*                        CALL MSGRTN;  /* PUT OUT MESSAGE             *
*                                                                  0864
         BAL   @14,MSGRTN                                          0864
*                    /* CHECK IF THIS CODE WAS EXECUTED BECAUSE OF    *
*                    /* RETURN CODE 8                                 *
*                    IF CODE8SW = '1'B                             0865
*                      THEN            /* YES, PROCESSING WAS FOR  0865
*                                         RETURN CODE 8               *
@RF00863 TM    CODE8SW,B'01000000'                                 0865
         BNO   @RF00865                                            0865
*                        DO;                                       0866
*                          CODE8SW = '0'B; /* TURN OFF REPEATE SW     *
         NI    CODE8SW,B'10111111'                                 0867
*                          SYNERSW = '1'B; /* INDICATE AN ERROR FOUND *
         OI    SYNERSW,B'00000100'                                 0868
*                          GOTO CALLCKR; /* GO CONTINUE PROCESSING 0869
*                                           BUFFER                    *
         B     CALLCKR                                             0869
*                        END;                                      0870
*                      ELSE            /* NO ENTRY NOT FROM RET 8     *
*                        DO;                                       0871
*                                                                  0871
@RF00865 DS    0H                                                  0872
*EXITCK: ;                             /* DETERMINE TYPE OF EXIT      *
*                                                                  0872
EXITCK   DS    0H                                                  0873
*                          /* CHECK WHETHER OR NOT TO TERMINATE       *
*                          /* INPUT MODE                              *
*                          IF CASCANSW = '0'B                      0873
*                            THEN      /* DO NOT TERMINATE INPUT MODE *
         TM    CASCANSW(COMMREG),B'00010000'                       0873
         BZ    @RT00873                                            0873
*                              GO TO SNEREXIT; /* RETURN TO INPUT MODE*
*                ELSE                  /* TERMINATE INPUT MODE        *
*                  DO;                                             0875
*                    CCODE=8;          /* INDICATE FLUSH NEEDED       *
         MVC   CCODE(2),@CH00049                                   0876
*                    GOTO SNEXIT;      /* RETURN TO COMMAND MODE      *
         B     SNEXIT                                              0877
*                  END;                                            0878
*            END;                                                  0879
*        END DO68;                     /* END OF RET CODE 4           *
*        GO TO EXITCK;                 /* DETERMINE MODE              *
         B     EXITCK                                              0881
*        END;                                                      0882
*        ELSE                          /* NOT RETURN CODE 4           *
*                                                                  0883
*        /* CHECK IF RETURN CODE IS 8 AND DATA SET NOT BASIC OR IPLI  *
*        IF CODESAVE = 8 & CATYPE ^= CABASIC & CATYPE ^= CAIPLI    0883
*            THEN                      /* YES RETURN CODE IS 8        *
@RF00849 LA    @12,8                                               0883
         CR    CODESAVE,@12                                        0883
         BNE   @RF00883                                            0883
         CLI   CATYPE(COMMREG),X'20'                               0883
         BE    @RF00883                                            0883
         CLI   CATYPE(COMMREG),X'21'                               0883
         BE    @RF00883                                            0883
*              DO;                                                 0884
*                CODE8SW = '1'B;       /* INDICATE RETURN CODE WAS 8  *
         OI    CODE8SW,B'01000000'                                 0885
*                CASYNECD = '1100'B;   /* INDICATE SYNTAX CHECKER IS
*                                         BEING CALLED AFTER RETURN
*                                         CODE OF 8                   *
         MVI   CASYNECD(COMMREG),B'11000000'                       0886
*                CCODE=8;              /* INDICATE FLUSH NEEDED       *
         STH   @12,CCODE                                           0887
*                GOTO DO68;            /* GO PROCESS AS RET CODE 4    *
         B     DO68                                                0888
*              END;                                                0889
*                                                                  0889
*        /* CHECK IF PROCESSOR OR CHECKER OPERATIONAL                 *
*        IF CODESAVE = 20                                          0890
*          THEN                        /* NOT 16                      *
@RF00883 CH    CODESAVE,@CH00128                                   0890
         BNE   @RF00890                                            0890
*            DO;                                                   0891
*              SYNCKOFF = '1'B;        /* SUPPRESS SYNTAX CHECKING    *
         OI    SYNCKOFF,B'00001000'                                0892
*              CCODE = 16;             /* SET RETURN CODE FOR MA      *
         MVC   CCODE(2),@CH00228                                   0893
*              GOTO SNEXIT;            /* GO RETURN TO EDIT MODE      *
         B     SNEXIT                                              0894
*            END;                                                  0895
*                                                                  0895
*        /* CHECK IF NOT ENOUGH CORE AVAILABLE                        *
*        IF CODESAVE = 16                                          0896
*          THEN                        /* YES, NOTIFY USER AND EXIT   *
@RF00890 CH    CODESAVE,@CH00228                                   0896
         BE    @RT00896                                            0896
*            GO TO NOCOREMG;           /* BRANCH TO ISSUE MSG         *
*                                                                  0897
*        /* IF FALL THROUGH HERE RETURN CODE INVALID                  *
*        INSLEN = 12;                  /* LENGTH OF MODULE NAME INSERT*
         MVC   INSLEN(2),@CH00137                                  0898
*        INSCTL = 10;                  /* OFFSET FOR INSERTION        *
         MVC   INSCTL(2),@CH01146                                  0899
*        INSNUM = CASYNAME;            /* NAME OF CHECKER OR PROCESSOR*
         MVC   INSNUM(8),CASYNAME(COMMREG)                         0900
*        SRVREG2 = CODESAVE;           /* SAVE RETURN CODE FOR MSG    *
         LR    SRVREG2,CODESAVE                                    0901
*        CALL SRVERRTN;                /* ISSUE CMD SYSTEM ERROR MSG  *
         BAL   @14,SRVERRTN                                        0902
*        GO TO SNEXIT;                 /* RETURN TO EDIT MODE         *
         B     SNEXIT                                              0903
*        END;                          /* END OF ERROR PROCESSING     *
*        GOTO SNEREXIT;                /* EXIT                        *
         B     SNEREXIT                                            0905
*SNEXIT:                               /* COMMAND MODE EXIT           *
*        SYNPTR = ADDR (EXIT);         /* SET RTURN TO GO TO CMD MODE *
SNEXIT   LA    @12,EXIT                                            0906
         ST    @12,SYNPTR                                          0906
*SNEREXIT:                             /* PRIMARY EXIT                *
*                                      /* PROCESSING CONTINUES HERE IF
*                                         RETURN CODE WAS 0           *
*                                                                  0907
*        /* CHECK FOR BUFFERS TO BE FREED                             *
*        IF SNBFRPT = SNCURBF                                      0907
*          THEN;                       /* NO NEW BUFFERS              *
SNEREXIT CLC   SNBFRPT(4),SNCURBF                                  0907
         BE    @RT00907                                            0907
*          ELSE                        /* YES BUFFERS TO BE FREE'D    *
*            DO;                                                   0909
*              FMPTR = SNBFRPT -> NEXTBFR - 4;    /* INIT PTR FOR  0910
*                                                    FREEMAIN LOOP    *
         L     @12,SNBFRPT                                         0910
         SLR   FMPTR,FMPTR                                         0910
         ICM   FMPTR,7,NEXTBFR(@12)                                0910
         SH    FMPTR,@CH00389                                      0910
*SNFMLP:                               /* CLEAN UP                    *
*              WREG2 = FMPTR -> NEXTBFR; /* SAVE NEXT BUFFER PTR      *
SNFMLP   SLR   WREG2,WREG2                                         0911
         ICM   WREG2,7,NEXTBFR(FMPTR)                              0911
*              GMADDR = FMPTR;         /* ADDR OF BFR TO BE FREE'D    *
         ST    FMPTR,GMADDR                                        0912
*              GMLEN = FMPTR -> BUFLEN;/* LENGTH OF BFR TO FREE       *
         LH    @12,BUFLEN(,FMPTR)                                  0913
         ST    @12,GMLEN                                           0913
*              FMLIST = FMPRMLST;      /* MOVE L-FORM OF FREEMAIN TO  *
*                                                                  0914
         MVC   FMLIST(10),FMPRMLST                                 0914
*              /* ISSUE FREEMAIN FOR BUFFERS                          *
*/*         IKJENDP  - ENDS THE PARSE PCL.                            *
*              GEN (FREEMAIN A=GMDATA,MF=(E,FMLIST));              0915
         FREEMAIN A=GMDATA,MF=(E,FMLIST)
*              FMPTR = WREG2;          /* GET NEXT ADDR TO BE FREE'D  *
*                                                                  0916
         LR    FMPTR,WREG2                                         0916
*              /* SEE IF MORE BUFFERS TO BE FREE'D                    *
*              IF FMPTR = 0                                        0917
*                THEN                  /* NO, ALL BFRS FREE'D         *
         LTR   FMPTR,FMPTR                                         0917
         BNZ   @RF00917                                            0917
*                  SNCURBF = SNBFRPT;  /* REINITIALISE BFR PTR TO     *
         MVC   SNCURBF(4),SNBFRPT                                  0918
*                ELSE                  /* YES, MORE TO FREE           *
*                  DO;                                             0919
         B     @RC00917                                            0919
@RF00917 DS    0H                                                  0920
*                    WREG2 = WREG2 - 4;   /* POINT TO BEG OF BUFFER   *
         SH    WREG2,@CH00389                                      0920
*                    GOTO SNFMLP;      /* GO FREE NEXT BUFFER         *
         B     SNFMLP                                              0921
*                  END;                                            0922
*            END;                                                  0923
*                                                                  0923
@RC00917 DS    0H                                                  0924
*        /* CHECK FOR GETMAIN FAILURE                                 *
*        IF SYNCKSW = '1'B                                         0924
*          THEN                        /* IF NO, REINIT BUFER CONTROLS*
@RT00907 TM    SYNCKSW,B'10000000'                                 0924
         BNO   @RF00924                                            0924
*            DO;                                                   0925
*              SNCURPOS = SNCURBF + 8;    /* INIT CURRENT POS PTR     *
         L     @12,SNCURBF                                         0926
         LA    @08,8                                               0926
         ALR   @08,@12                                             0926
         ST    @08,SNCURPOS                                        0926
*              RECNUM = 0;             /* RESET RECORD COUNT          *
         MVI   RECNUM(@12),X'00'                                   0927
*            END;                                                  0928
*        CASYNIS = '1'B;               /* RESET CHKR INTERFACE        *
@RF00924 OI    CASYNIS(COMMREG),B'00010000'                        0929
*SYNEXIT: ;                            /* EXIT FROM SUBROUTINE        *
SYNEXIT  DS    0H                                                  0931
*        RETREG = SYNPTR;              /* RESTORE RETURN POINT        *
         L     RETREG,SYNPTR                                       0931
*        RETURN;                       /* RETURN TO CALLER            *
@EL00008 DS    0H                                                  0932
@EF00008 DS    0H                                                  0932
@ER00008 BR    @14                                                 0932
*        END SYNCHK;                   /* END OF SYNCHK               *
*                                                                  0934
*CLNSAVE:                                                          0934
*        /* ********************************************************* *
*        /* THIS ROUTINE ASSUMES THAT THE RECORD         CONTAINED    *
*        /* ENTRY IS TO BE MADE AVAILABLE IN THAT SLOT. TO DO THIS,   *
*        /* THE EXISTING RECORD WILL BE RE-WRITTEN WITH A KEY 1       *
*        /* LARGER THAN IT THEN HAS. IF A RECORD EXISTS AT THE NEW    *
*        /* KEY THEN IT WILL BE RE-WRITTEN THE SAME WAY. WHEN ALL     *
*        /* DISPLACED RECORDS HAVE BEEN WRITTEN BACK INTO THE DATA    *
*        /* SET THIS ROUTINE RETURNS INPUTNONE OUTPUT - IF            *
*        /* OPERATION IS SUCCESSFUL, CONTROL IS RETURNED TO CALLER.   *
*        /* IN 'CLNBFR(1)' EXISTS IN THE UTILITY DATA SET AND AN      *
*        /* IF  UNSUCCESSFUL, A BRANCH IS MADE DIRECTLY TO 'EDIT'     *
*        /* AFTER PUTTING OUT A MESSAGE.                              *
*        /* ********************************************************* *
*        PROC OPTIONS (NOSAVE, NOSAVEAREA);                        0934
CLNSAVE  DS    0H                                                  0935
*        /* THE FOLLOWING REGISTERS ARE RESTRICTED FOR THE DURATION   *
*        /* OF INPUT.                                                 *
*        RESPECIFY (PARMREG1, WREG1, WREG2, COMMREG, SAVEREG, DATAREG,
*                  BASEREG) RSTD;                                  0935
*                                                                  0935
*        CLNPTR = RETREG;              /* SAVE RETURN POINT PTR       *
         LR    CLNPTR,RETREG                                       0936
*        WREG1 = ADDR (CLNBFR (1));    /* INIT FOR FIRST BUFFER       *
         LA    WREG1,CLNBFR(,COMMREG)                              0937
*        WREG2 = ADDR (CLNBFR (2));    /* INIT FOR SECOND BUFFER      *
         LA    WREG2,CLNBFR+264(,COMMREG)                          0938
*        NEXTREC = CLNKEY + 1;         /* UPDATE NEXT RECORD PTR      *
         LA    @08,1                                               0939
         AL    @08,CLNKEY(,WREG1)                                  0939
         ST    @08,NEXTREC(,COMMREG)                               0939
*CLNLP:                                /* DO THE READ                 *
*        CLNKEY = CLNKEY + 1;          /* INCREMENT KEY TO NEXT KEY   *
CLNLP    LA    @08,1                                               0940
         AL    @08,CLNKEY(,WREG1)                                  0940
         ST    @08,CLNKEY(,WREG1)                                  0940
*        UTOPTCD = '00'X;              /* SET OP CODE FOR READ        *
         MVI   UTOPTCD,X'00'                                       0941
*        UTKEYPTR = ADDR (CLNKEY);     /* POINT TO KEY FOR READ       *
         ST    WREG1,UTKEYPTR                                      0942
*        UTADPTR = WREG2;              /* POINT TO BUFFER FOR READ    *
         ST    WREG2,UTADPTR                                       0943
*        LBIT2 = '0'B;                 /* TURN OFF 2-WORD LIST IND    *
         NI    LBIT2,B'01111111'                                   0944
*        LBIT3 = '1'B;                 /* TURN ON 3-WORD LIST INDIC   *
         OI    LBIT3,B'10000000'                                   0945
*        CALL IORTN;                   /* GO PERFORM READ             *
*                                                                  0946
         BAL   @14,IORTN                                           0946
*        /* CHECK RETURN CODE FROM IKJEBEUT                           *
*        IF RCODEREG = 0                                           0947
*          THEN;                       /* RECORD EXISTS, NEXT SLOT IS
*                                         NOT EMPTY                   *
         LTR   RCODEREG,RCODEREG                                   0947
         BZ    @RT00947                                            0947
*          ELSE                        /* RECORD DOES NOT EXIST, NEXT
*                                         SLOT IS EMPTY               *
*            WREG2 = 0;                /* SET END-OF-LOOP INDICATION  *
         SLR   WREG2,WREG2                                         0949
*        UTOPTCD = '20'X;              /* SET WRITE OP CODE           *
@RT00947 MVI   UTOPTCD,X'20'                                       0950
*        UTKEYPTR = WREG1;             /* POINT TO RECORD TO BE    0951
*                                         WRITTEN                     *
         ST    WREG1,UTKEYPTR                                      0951
*        LBIT2 = '1'B;                 /* INDICATE 2-WORD LIST        *
         OI    LBIT2,B'10000000'                                   0952
*        CALL IORTN;                   /* GO WRITE RECORD IN DS       *
*                                                                  0953
         BAL   @14,IORTN                                           0953
*        /* CHECK RETURN CODE FROM IKJEBEUT                           *
*        IF RCODEREG ^= 0                                          0954
*          THEN                        /* WRITE WAS UNSUCCESSFUL ,    *
         SLR   @14,@14                                             0954
         CR    RCODEREG,@14                                        0954
         BE    @RF00954                                            0954
*            DO;                       /* DIAGNOSE ERROR (CODE=12)    *
*              RELMSG1 = 776;          /* LOAD MSG NUMBER             *
         MVC   RELMSG1(2),@CH01296                                 0956
*              RELMSG2 = 0;            /* INDICATE NO LEVEL 2         *
         STH   @14,RELMSG2                                         0957
*              LEV1INS = 0;            /* INDICATE NO LEV 1 INS       *
         SLR   LEV1INS,LEV1INS                                     0958
*              LEV2INS = 0;            /* INDICATE NO LEV 2 INS       *
         SLR   LEV2INS,LEV2INS                                     0959
*              CALL MSGRTN;            /* GO PUT OUT MSG              *
         BAL   @14,MSGRTN                                          0960
*              RETREG = ADDR ( EXIT);  /* SET RTURN ADDR              *
         LA    RETREG,EXIT                                         0961
*              RETURN;                 /* RETURN TO COMMAND MODE      *
@EL00009 DS    0H                                                  0962
@EF00009 DS    0H                                                  0962
@ER00009 BR    @14                                                 0962
*            END;                                                  0963
*          ELSE;                       /* WRITE WAS SUCCESSFUL        *
*                                                                  0964
@RF00954 DS    0H                                                  0965
*        /* CHECK FOR END-OF-LOOP                                     *
*        IF WREG2 = 0                                              0965
*          THEN DO;                    /* YES, FINISHED               *
         LTR   WREG2,WREG2                                         0965
         BNZ   @RF00965                                            0965
*CLNRET:                               /* EXIT CODE                   *
*            RETREG = CLNPTR;          /* RESTORE RETURN POINT PTR    *
CLNRET   LR    RETREG,CLNPTR                                       0967
*            RETURN;                   /* RETURN TO CALLER            *
         B     @EL00009                                            0968
*               END;                                               0969
*          ELSE;                       /* NO, SLOT WAS NOT FOUND      *
*                                                                  0970
@RF00965 DS    0H                                                  0971
*        /* THE NEXT 3 INSTRUCTIONS SWAP THE BUFFER PTRS              *
*        GEN REFS(WREG1,WREG2);                                    0971
         XR    WREG1,WREG2
         XR    WREG2,WREG1
         XR    WREG1,WREG2
*        GOTO CLNLP;                   /* CONTINUE LOOPING            *
         B     CLNLP                                               0972
*        END CLNSAVE;                  /* END OF CLNSAVE              *
*                                                                  0973
*                                                                  0973
*  DECLARE /*GENERAL PURPOSE REGISTERS */                          0974
*    GPR00P PTR(31) REG(0),                                        0974
*    GPR01P PTR(31) REG(1),                                        0974
*    GPR02P PTR(31) REG(2),                                        0974
*    GPR03P PTR(31) REG(3),                                        0974
*    GPR04P PTR(31) REG(4),                                        0974
*    GPR05P PTR(31) REG(5),                                        0974
*    GPR06P PTR(31) REG(6),                                        0974
*    GPR07P PTR(31) REG(7),                                        0974
*    GPR08P PTR(31) REG(8),                                        0974
*    GPR09P PTR(31) REG(9),                                        0974
*    GPR12P PTR(31) REG(12),                                       0974
*    GPR13P PTR(31) REG(13),                                       0974
*    GPR14P PTR(31) REG(14),                                       0974
*    GPR15P PTR(31) REG(15);                                       0974
*                                                                  0974
*  /* VARIABLES REQUIRED BY PL/S SYSTEM MACROS */                  0975
*    DECLARE CASAVPTR PTR(31) BASED;/*SAVE AREA PTR FOR IKJEBESV*/ 0975
*    DECLARE COMMREG REG(9) PTR(31) RSTD;/*POINTER TO EDIT COMMO AREA*/
*    DECLARE DATAREG REG(10) PTR(31) RSTD;/*BASEREG FOR EDIT SUBCOMMAND
*WORK AREA*/                                                       0977
*    DECLARE CASAVE CHAR(72) BASED;/*SAVE AREA EDIT MODULE*/       0978
*                                                                  0978
*  DECLARE /* COMMON VARIABLES */                                  0979
*    I256C CHAR(256) BASED,                                        0979
*    I031F FIXED(31) BASED,                                        0979
*    I031P PTR(31)   BASED,                                        0979
*    I015F FIXED(15) BASED,                                        0979
*    I015P PTR(15)   BASED,                                        0979
*    I008P PTR(8)    BASED,                                        0979
*    I001C CHAR(1)   BASED;                                        0979
*        END IKJEBEIP                                              0980
*/* THE FOLLOWING INCLUDE STATEMENTS WERE FOUND IN THIS PROGRAM.      *
*/*%INCLUDE SYSLIB  (IKJEBECA)                                        *
*/*%INCLUDE SYSLIB  (CVT     )                                        *
*/*%INCLUDE SYSLIB  (IKJPPL  )                                        *
*/*%INCLUDE SYSLIB  (IKJEBEMJ)                                        *
*/*%INCLUDE SYSLIB  (IKJGTPB )                                        *
*;                                                                 0980
@DATA    DS    0H
@CH00051 DC    H'1'
@CH00072 DC    H'2'
@CH00389 DC    H'4'
@CH00124 DC    H'5'
@CH00049 DC    H'8'
@CH01146 DC    H'10'
@CH00137 DC    H'12'
@CH00228 DC    H'16'
@CH00128 DC    H'20'
@CH00068 DC    H'24'
@CH01354 DC    H'76'
@CH01321 DC    H'259'
@CH01250 DC    H'270'
@CH01272 DC    H'271'
@CH01306 DC    H'774'
@CH01296 DC    H'776'
@CH01355 DC    H'1280'
@CH01254 DC    H'1288'
@CH01335 DC    H'1293'
@SM01400 MVC   INSNUM(0),0(@08)
@SM01402 MVC   NUMTEMP(0),NUMADJ(WREG2)
@SM01404 MVC   NUMBTMP(0),NUMTEMP
@SM01407 MVC   OUTDATA(0,COMMREG),INLINE+4(@07)
@SM01411 MVC   BUFLINE(0,@08),NEWDATA(INPTR)
@SM01413 MVC   BUFLINE(0,@08),NEWLINE+4(INPTR)
@DATD    DSECT
         DS    0F
@PC00008 DS    1F
IKJEBEIP CSECT
         DS    0F
@DATD    DSECT
         DS    0D
READKEY  DS    F
SAVERC   DS    F
CONTPTR  DS    A
IORTNPTR DS    A
SRVPTR   DS    A
SYNPTR   DS    A
CLNCUR   DS    A
CCODE    DS    H
         DS    CL2
PTLPBLK  DS    CL20
SRWORK   DS    CL40
         ORG   SRWORK
RELMSG1  DS    FL2
RELMSG2  DS    FL2
SRWORK2  DS    CL36
         ORG   SRWORK+40
INSREC   DS    CL16
         ORG   INSREC
INS2PTR  DS    CL4
INSLEN   DS    FL2
INSCTL   DS    CL2
INSNUM   DS    CL8
         ORG   INSREC+16
TEMPBUFF DS    CL13
         ORG   TEMPBUFF
LTEMPNUM DS    FL2
NUMBXXX  DS    FL2
NUMBTMP  DS    CL9
         ORG   TEMPBUFF+13
         DS    CL3
NUMBFR   DS    CL21
         ORG   NUMBFR
NUMSEG   DS    FL4
NUMPTR   DS    AL4
         ORG   NUMPTR
NUMEOL   DS    CL1
         ORG   NUMBFR+8
LNUMTEMP DS    FL2
NUMXXX   DS    FL2
NUMTEMP  DS    CL9
         ORG   NUMTEMP
NUMTEMP1 DS    CL8
         ORG   NUMBFR+21
         DS    CL3
INSREC1  DS    CL11
         ORG   INSREC1
@NM00033 DS    CL8
INSNUM1  DS    CL3
         ORG   INSREC1+11
         DS    CL1
UTPRMLST DS    CL12
         ORG   UTPRMLST
UTDCBPTR DS    AL4
         ORG   UTDCBPTR
UTOPTCD  DS    CL1
         ORG   UTOPTCD
LBIT1    DS    BL1
         ORG   UTPRMLST+4
UTKEYPTR DS    AL4
         ORG   UTKEYPTR
LBIT2    DS    BL1
         ORG   UTPRMLST+8
UTADPTR  DS    AL4
         ORG   UTADPTR
LBIT3    DS    BL1
         ORG   UTPRMLST+12
FLAGS    DS    BL1
         ORG   FLAGS
PRSSW    DS    BL1
MSGSW1   EQU   FLAGS+0
EODSW    EQU   FLAGS+0
CONTSW   EQU   FLAGS+0
SYNCKOFF EQU   FLAGS+0
SYNERSW  EQU   FLAGS+0
BFRFREE  EQU   FLAGS+0
         ORG   FLAGS+1
         DS    CL3
LEPARM   DS    CL8
         ORG   LEPARM
LETXTPTR DS    AL4
         ORG   LETXTPTR
LEFLAG   DS    BL1
         ORG   LEPARM+4
LECAREA  DS    AL4
         ORG   LEPARM+8
FMPARM   DS    CL8
         ORG   FMPARM
FMADDR   DS    AL4
FMLEN    DS    AL4
         ORG   FMPARM+8
GLPBLK   DS    CL20
SNCHKDLT DS    CL12
         ORG   SNCHKDLT
@NM00036 DS    FL4
STARTV   DS    FL4
STOPV    DS    FL4
         ORG   SNCHKDLT+12
FMLIST   DS    CL10
         DS    CL2
BFCTLBLK DS    CL12
         ORG   BFCTLBLK
SNBFRPT  DS    AL4
SNCURPOS DS    AL4
SNCURBF  DS    AL4
         ORG   BFCTLBLK+12
GMDATA   DS    CL8
         ORG   GMDATA
GMADDR   DS    AL4
GMLEN    DS    FL4
         ORG   GMDATA+8
GMPARM   DS    CL8
GMPRMLST DS    CL12
         ORG   GMPRMLST
LENPTR   DS    AL4
ADDRPTR  DS    AL4
@NM00039 DS    FL4
         ORG   GMPRMLST+12
SYNERMG1 DS    CL80
         ORG   SYNERMG1
SYNERRM2 DS    FL4
SYNERRLN DS    FL2
SYNERROF DS    FL2
SYNERRTX DS    CL72
         ORG   SYNERMG1+80
SYNERNG2 DS    CL80
         ORG   SYNERNG2
SYNERRM3 DS    FL4
SYNERLN2 DS    FL2
SYNEROF2 DS    FL2
SYNERTX2 DS    CL72
         ORG   SYNERNG2+80
SYNSW    DS    BL1
         ORG   SYNSW
SYNCKSW  DS    BL1
CODE8SW  EQU   SYNSW+0
         ORG   SYNSW+1
         DS    CL3
PACKTMP  DS    CL8
IKJEBEIP CSECT
         NOPR  ((@ENDDATD-@DATD)/673*16)
         DS    0F
@SIZDATD DC    AL1(0)
         DC    AL3(@ENDDATD-@DATD)
@CV01140 DC    V(IKJEBIP1)
         DS    0D
MAXREC   DC    F'100000000'
MAXRECU  DC    F'2147483647'
@CC01308 DC    C'I '
         DS    CL2
INPMSG   DS    CL9
         ORG   INPMSG
@NM00030 DC    H'9'
@NM00031 DC    H'0'
@NM00032 DC    CL5'INPUT'
         ORG   INPMSG+9
         DS    CL3
GMPARMX  DS    CL8
         ORG   GMPARMX
@NM00037 DC    F'264'
@NM00038 DC    F'2048'
         ORG   GMPARMX+8
IKJEBEIP CSECT
IKJEBXT1 CSECT
XTR5     EQU   5
XTR6     EQU   6                       WORK REGISTER
XT12     EQU   12                      LAST REG TO BE SAVED
XTRCODE4 EQU   4                       RETURN CODE FOR BAD PARM
XTRET    EQU   14                      RETURN REGISTER
XTRCODE  EQU   15                      RETURN CODE REGISTER
XTBASE   EQU   15                      BASE REG FOR EXIT ROUTINE
RECBASE  EQU   1                       POINTS TO PDE FROM PARSE
OFF0     EQU   0                       USED FOR 0 FIELDS OF
*                                      INSTRUCTIONS
IKJEBXT1 CSECT
         USING *,XTBASE                ESTABLISH ADDRESSABILITY
         SAVE  (14,12),,*              SAVE PARSE REGISTERS
         USING IKJEBXT2,RECBASE        EST ADDRESSABILITY FOR INPUT
*                                      RECORD
         L     RECBASE,OFF0(,RECBASE)  GET PTR TO PDE FROM PARSE
         L     XTR5,XTPTR              GET POINTER TO NUMBER FROM PDE
         LH    XTR6,XTLEN              GET LENGTH OF NUMBER FROM PDE
         BCTR  XTR6,0                  REDUCE LENGTH FOR COMPARE
         EX    XTR6,XTCLC              COMPARE NUMBER TO 0(DECIMAL)
         BE    XTBADINC                BRANCH IF 0, VALUE NO GOOD
         SR    XTRCODE,XTRCODE         SET RETURN CODE 0 - OK
         RETURN (14,12),RC=(15)        RETURN TO PARSE
XTBADINC EQU   *
         LA    XTRCODE,XTRCODE4        SET RETURN CODE FOR PARSE
         RETURN (14,12),RC=(15)        RETURN TO PARSE
XTCLC    CLC   OFF0(OFF0,XTR5),ZEROS   EXECUTED TO COMPARE NUMBER TO
*                                      0
ZEROS    DC    C'00000000'             COMPARAND FOR INPUT NUMBER
IKJEBXT2 DSECT
* THIS DSECT DEFINES THE PDE FORMAT FROM PARSE
*
*
XTPTR    DS    F                       POINTER TO NUMBER TO VERIFY
XTLEN    DS    H                       LENGTH OF NUMBER TO BE VERIFIED
         DROP  XTBASE
         DROP  RECBASE
IKJEBEIP CSECT ,                       RESUME MAIN CSECT
IKJEBEIP CSECT
IKJEBIP1 IKJPARM
PA       IKJIDENT 'LINE NUMBER OPERAND',ASTERISK,FIRST=NUMERIC,        X
               OTHER=NUMERIC,MAXLNTH=8
PB       IKJIDENT 'INCREMENT',FIRST=NUMERIC,OTHER=NUMERIC,MAXLNTH=8,   X
               VALIDCK=IKJEBXT1
PRMT     IKJKEYWD
PC       IKJNAME 'PROMPT'
PD       IKJNAME 'NOPROMPT'
RI       IKJKEYWD DEFAULT='I'
PE       IKJNAME 'I'
PF       IKJNAME 'R'
PG       IKJENDP
INSOFF1  EQU   15
MSGNUM1  IKJEBEMG ,INSOFF1,'        '  INSERT FOR LINE TRUNC MSG
INSOFF2  EQU   25
MSGNUM2  IKJEBEMG ,INSOFF2,'   '       INSERT FOR LEV 2 OF LINE TRUNC
*                                      MSG                     @ZM30991
INSOFF3  EQU   28
INSM402  IKJEBEMG ,INSOFF3,'99999999'
INSOFF   EQU   45
INSM25   IKJEBEMG ,INSOFF,'INPUT'      SECOND LEVEL MSG FOR MSG25
M313INS1 IKJEBEMG M313INS4,10,'PARSE'
M313INS2 IKJEBEMG M313INS4,10,'PUTLINE'
M313INS4 IKJEBEMG ,22,'00'       INSERTION FOR SRV RTN FAILURE
INSOFF4  EQU   48
INSM400  IKJEBEMG ,INSOFF4,'        '
M313INS3 IKJEBEMG M313INS4,10,'GETLINE'
FMPRMLST FREEMAIN V,SP=1,MF=L
PTLINE   PUTLINE OUTPUT=(0,TERM,SINGLE,DATA),TERMPUT=ASIS,MF=L
@DATD    DSECT
         ORG   *+1-(*-@DATD)/(*-@DATD) INSURE DSECT DATA
@ENDDATD EQU   *
IKJEBEIP CSECT
@00      EQU   00                      EQUATES FOR REGISTERS 0-15
@01      EQU   01
@02      EQU   02
@03      EQU   03
@04      EQU   04
@05      EQU   05
@06      EQU   06
@07      EQU   07
@08      EQU   08
@09      EQU   09
@10      EQU   10
@11      EQU   11
@12      EQU   12
@13      EQU   13
@14      EQU   14
@15      EQU   15
FMPTR    EQU   @04
INPTR    EQU   @12
GTPBPTR  EQU   @12
MSGPTR   EQU   @12
CLNPTR   EQU   @12
CODESAVE EQU   @07
PPLPTR   EQU   @04
BASEREG2 EQU   @06
COMMREG  EQU   @09
SAVEREG  EQU   @13
BASEREG  EQU   @11
RCODEREG EQU   @15
PARMREG1 EQU   @01
WREG1    EQU   @02
WREG2    EQU   @03
LEV1INS  EQU   @02
LEV2INS  EQU   @03
SRVREG2  EQU   @03
RETREG   EQU   @14
CVDREG   EQU   @02
UTPREG1  EQU   @01
DATAREG  EQU   @10
GPR13P   EQU   @13
GPR15P   EQU   @15
GPR01P   EQU   @01
GPR12P   EQU   @12
EPREG    EQU   @15
GPR00P   EQU   @00
GPR02P   EQU   @02
GPR03P   EQU   @03
GPR04P   EQU   @04
GPR05P   EQU   @05
GPR06P   EQU   @06
GPR07P   EQU   @07
GPR08P   EQU   @08
GPR09P   EQU   @09
GPR14P   EQU   @14
PARMREG0 EQU   @00
RETCDREG EQU   @15
CVTPTR   EQU   16
IKJEBECA EQU   0
CAPTPRSD EQU   IKJEBECA+36
CAPRSPDL EQU   CAPTPRSD
CAFREEDL EQU   CAPRSPDL
CAPTIBFR EQU   IKJEBECA+40
CAOPERND EQU   CAPTIBFR
CAPTCDCB EQU   IKJEBECA+52
CAPTCHK  EQU   IKJEBECA+72
CAATTN   EQU   IKJEBECA+120
CAATTNIS EQU   CAATTN
CACFLAG  EQU   IKJEBECA+124
CACFLAG1 EQU   CACFLAG
CAPROMPT EQU   CACFLAG1
CASCANSW EQU   CACFLAG1
CANONUM  EQU   CACFLAG1
CACFLAG2 EQU   CACFLAG+1
CARECFM  EQU   CACFLAG2
CAMODMSG EQU   CACFLAG2
CACFLAG3 EQU   CACFLAG+2
CAIMFLG  EQU   CACFLAG3
CAIMPT   EQU   CAIMFLG
CAIMINS  EQU   CAIMFLG
CAIMSC   EQU   CAIMFLG
CAIMIR   EQU   CAIMFLG
CAIMCIN  EQU   CAIMFLG
CAIMSFPT EQU   CAIMFLG
CAIMINPT EQU   CAIMFLG
CACFLAG4 EQU   CACFLAG+3
CACFLAG5 EQU   CACFLAG+4
CACFLAG6 EQU   CACFLAG+5
CAPD     EQU   IKJEBECA+152
CASYNAME EQU   CAPD+32
CADSCODE EQU   CAPD+40
CADSATTR EQU   CAPD+41
CADSCONT EQU   CADSATTR
CADSATR2 EQU   CAPD+42
CAPTPDXT EQU   IKJEBECA+228
CALRECL  EQU   IKJEBECA+232
CAEDFLAG EQU   IKJEBECA+236
CAEDFLG2 EQU   IKJEBECA+237
CASAFLAG EQU   IKJEBECA+376
CASAFLG2 EQU   IKJEBECA+377
CASTNUM  EQU   IKJEBECA+448
CANXTREC EQU   IKJEBECA+452
CACURNUM EQU   IKJEBECA+456
CAINCRE  EQU   IKJEBECA+460
CAIMLLNO EQU   IKJEBECA+464
CAIMLINC EQU   IKJEBECA+468
CAINSAVE EQU   IKJEBECA+476
CASYNLST EQU   IKJEBECA+496
CASYNBFR EQU   CASYNLST
CASYNWA  EQU   IKJEBECA+508
CASYNECD EQU   CASYNWA
CASYNMS1 EQU   CASYNWA+4
CASYNOPT EQU   IKJEBECA+524
CASYNCD2 EQU   CASYNOPT+1
CASYNSW  EQU   CASYNOPT+3
CASYNIS  EQU   CASYNSW
CATMPLST EQU   IKJEBECA+528
CAMAWKA  EQU   IKJEBECA+596
MACFLAGS EQU   CAMAWKA+28
MACFLAG2 EQU   CAMAWKA+29
CAMODEMG EQU   IKJEBECA+928
CASCWKA  EQU   IKJEBECA+1448
CABFRPL  EQU   IKJEBECA+2120
CATEMPBF EQU   IKJEBECA+2648
CANXTSVA EQU   IKJEBECA+3896
IKJEBECX EQU   0
BACKREG  EQU   4
CVTMAP   EQU   0
CVTDAR   EQU   CVTMAP+72
CVTFLGS1 EQU   CVTDAR
CVTDCB   EQU   CVTMAP+116
CVTIOQET EQU   CVTMAP+120
CVTIERLC EQU   CVTMAP+144
CVTHEAD  EQU   CVTMAP+160
CVTSV76C EQU   CVTHEAD
CVTOPTA  EQU   CVTMAP+182
CVTOPTB  EQU   CVTMAP+183
CVTGTF   EQU   CVTMAP+236
CVTGTFST EQU   CVTGTF
CVTGTFS  EQU   CVTGTFST
CVTSTATE EQU   CVTGTFST
CVTTMODE EQU   CVTGTFST
CVTFORM  EQU   CVTGTFST
CVTAQAVT EQU   CVTMAP+240
CVTTCMFG EQU   CVTAQAVT
CVTVOLM2 EQU   CVTMAP+244
CVTTATA  EQU   CVTVOLM2
CVTTSKS  EQU   CVTTATA
CVTVOLF2 EQU   CVTTSKS
CVTTAT   EQU   CVTTATA+1
CVTATER  EQU   CVTMAP+248
CVTEXT1  EQU   CVTMAP+252
CVTPURG  EQU   CVTMAP+260
CVTQMSG  EQU   CVTMAP+268
CVTDMSR  EQU   CVTMAP+272
CVTRSV37 EQU   CVTDMSR
CVTDMSRF EQU   CVTRSV37
CVTERPV  EQU   CVTMAP+316
CVTINTLA EQU   CVTMAP+320
CVTAPF   EQU   CVTMAP+324
CVTEXT2  EQU   CVTMAP+328
CVTHJES  EQU   CVTMAP+332
CVTPGSIA EQU   CVTMAP+348
CVTA1F1  EQU   CVTMAP+356
CVTSYSK  EQU   CVTMAP+357
CVTVOLM1 EQU   CVTMAP+380
CVTVOLF1 EQU   CVTVOLM1
CVTATMCT EQU   CVTMAP+388
CVTXTNT1 EQU   0
CVTXTNT2 EQU   0
CVTDSSV  EQU   CVTXTNT2
CVTFLGBT EQU   CVTXTNT2+5
CVTQID   EQU   CVTXTNT2+24
CVTRV400 EQU   CVTXTNT2+52
CVTRV409 EQU   CVTXTNT2+53
CVTATCVT EQU   CVTXTNT2+64
CVTRV429 EQU   CVTXTNT2+84
CVTRV438 EQU   CVTXTNT2+85
CVTRV457 EQU   CVTXTNT2+112
CVTRV466 EQU   CVTXTNT2+113
CVTFIX   EQU   0
CVTRELNO EQU   CVTFIX+252
PPL      EQU   0
PPLPCL   EQU   PPL+12
PPLANS   EQU   PPL+16
PPLCBUF  EQU   PPL+20
PPLUWA   EQU   PPL+24
PRSPDE   EQU   0
PRSNMPTR EQU   PRSPDE+8
@NM00026 EQU   PRSPDE+12
PRSNMLEN EQU   @NM00026
PRSNMFLG EQU   @NM00026+2
PRSNMOM  EQU   PRSNMFLG
PRSINPTR EQU   PRSPDE+16
@NM00028 EQU   PRSPDE+20
PRSINLEN EQU   @NM00028
PRSINFLG EQU   @NM00028+2
PRSINOM  EQU   PRSINFLG
PRSPFLG  EQU   PRSPDE+24
PRSIRFLG EQU   PRSPDE+26
NUMBER   EQU   0
IOPTR    EQU   24
INKEY    EQU   0
NUMSCAN  EQU   0
NUMADJ   EQU   0
GTPB     EQU   0
GTPBIBUF EQU   GTPB+4
INLINE   EQU   0
INLEN    EQU   INLINE
BUFCTL   EQU   0
BUFLEN   EQU   BUFCTL
RECNUM   EQU   BUFCTL+4
NEXTBFR  EQU   BUFCTL+5
BUFLINE  EQU   0
NEWLINE  EQU   0
NEWLEN   EQU   NEWLINE+4
NEWDATA  EQU   NEWLINE+8
SYNMSG   EQU   0
CLNREC   EQU   0
CLNKEY   EQU   CLNREC
CHECKER  EQU   0
CASAVPTR EQU   0
CASAVE   EQU   0
CLNREC1  EQU   0
I001C    EQU   0
I008P    EQU   0
I015F    EQU   0
I015P    EQU   0
I031F    EQU   0
I031P    EQU   0
I256C    EQU   0
RTREG    EQU   12
Q        EQU   0
CVTS01   EQU   CVTPGSIA
CVTLPDIA EQU   CVTS01+12
CVTDIRST EQU   CVTLPDIA
CVTSLIDA EQU   CVTS01+24
CVTCTLFG EQU   CVTS01+50
CVTPARS  EQU   CVTS01+176
CVTRV210 EQU   CVTS01+424
CVTRV219 EQU   CVTS01+425
CVTRV228 EQU   CVTS01+426
CVTRV237 EQU   CVTS01+427
CVTMFRTR EQU   CVTS01+452
CVTRV262 EQU   CVTS01+468
CVTRV271 EQU   CVTS01+469
CVTRV280 EQU   CVTS01+470
CVTRV289 EQU   CVTS01+471
CVTGSDA  EQU   CVTS01+600
PDLPTR   EQU   CAPTPRSD
M44IN1   EQU   CATEMPBF
FIRSTLN  EQU   CASTNUM
NEXTREC  EQU   CANXTREC
SAVEINCR EQU   CAINSAVE
CATYPE   EQU   CADSCODE
OUTLINE  EQU   CABFRPL
OUTKEY   EQU   OUTLINE
OUTLEN   EQU   OUTLINE+4
OUTRESV  EQU   OUTLINE+6
OUTDATA  EQU   OUTLINE+8
DATA1    EQU   OUTDATA
INBUFPTR EQU   GTPBIBUF
CLNBFR   EQU   CATEMPBF
DATAF    EQU   OUTDATA
DATAVNS  EQU   OUTDATA
OUTREC   EQU   OUTLEN
*                                      START UNREFERENCED COMPONENTS
DATAVS   EQU   DATA1+8
SEQVS    EQU   DATA1
M44INTXT EQU   M44IN1+8
M44INX   EQU   M44IN1+6
M44INLN  EQU   M44IN1+4
M44IN2PT EQU   M44IN1
CVTRV628 EQU   CVTS01+728
CVTRV627 EQU   CVTS01+724
CVTRV626 EQU   CVTS01+720
CVTRV625 EQU   CVTS01+716
CVTRV624 EQU   CVTS01+712
CVTRV623 EQU   CVTS01+708
CVTRV622 EQU   CVTS01+704
CVTRV621 EQU   CVTS01+700
CVTIHASU EQU   CVTS01+696
CVTRV619 EQU   CVTS01+692
CVTRV618 EQU   CVTS01+688
CVTRV617 EQU   CVTS01+684
CVTRV616 EQU   CVTS01+680
CVTRV615 EQU   CVTS01+676
CVTRV614 EQU   CVTS01+672
CVTRV613 EQU   CVTS01+668
CVTTCASP EQU   CVTS01+664
CVT0PT03 EQU   CVTS01+660
CVT0PT0E EQU   CVTS01+656
CVTRV609 EQU   CVTS01+652
CVTCGK   EQU   CVTS01+648
CVTRAC   EQU   CVTS01+644
CVTHSM   EQU   CVTS01+640
CVTRV605 EQU   CVTS01+636
CVTRV604 EQU   CVTS01+632
CVTEFF02 EQU   CVTS01+628
CVTCBBR  EQU   CVTS01+624
CVTSSCR  EQU   CVTS01+620
CVTEVENT EQU   CVTS01+616
CVTCRCA  EQU   CVTS01+612
CVTTPIO  EQU   CVTS01+608
CVTADV   EQU   CVTS01+604
CVTGSDAB EQU   CVTGSDA
CVTQV3   EQU   CVTS01+596
CVTQV2   EQU   CVTS01+592
CVTQV1   EQU   CVTS01+588
CVTRPT   EQU   CVTS01+584
CVTSSRB  EQU   CVTS01+580
CVTCSDRL EQU   CVTS01+576
CVTEXP1  EQU   CVTS01+572
CVTRMPMT EQU   CVTS01+568
CVTRMPTT EQU   CVTS01+564
CVTVPSA  EQU   CVTS01+560
CVTVSTOP EQU   CVTS01+556
CVTGTFR8 EQU   CVTS01+552
CVTQUIT  EQU   CVTS01+548
CVTVACR  EQU   CVTS01+544
CVTWTCB  EQU   CVTS01+540
CVTSTPRS EQU   CVTS01+536
CVT0PT02 EQU   CVTS01+532
CVTDARCM EQU   CVTS01+528
CVTIRECM EQU   CVTS01+524
CVTJRECM EQU   CVTS01+520
CVTVEMS0 EQU   CVTS01+516
CVTSPFRR EQU   CVTS01+512
CVTRLSTG EQU   CVTS01+508
CVT0TC0A EQU   CVTS01+504
CVTGMBR  EQU   CVTS01+500
CVTLFRM  EQU   CVTS01+496
CVTRMBR  EQU   CVTS01+492
CVTVIOP  EQU   CVTS01+488
CVTRV307 EQU   CVTS01+486
CVTRV306 EQU   CVTS01+484
CVTRV305 EQU   CVTS01+482
CVTRV304 EQU   CVTS01+480
CVTRV303 EQU   CVTS01+478
CVTRV302 EQU   CVTS01+476
CVTTRCA  EQU   CVTS01+472
CVTRV297 EQU   CVTRV289
CVTRV296 EQU   CVTRV289
CVTRV295 EQU   CVTRV289
CVTRV294 EQU   CVTRV289
CVTRV293 EQU   CVTRV289
CVTRV292 EQU   CVTRV289
CVTRV291 EQU   CVTRV289
CVTRV290 EQU   CVTRV289
CVTRV288 EQU   CVTRV280
CVTRV287 EQU   CVTRV280
CVTRV286 EQU   CVTRV280
CVTRV285 EQU   CVTRV280
CVTRV284 EQU   CVTRV280
CVTRV283 EQU   CVTRV280
CVTRV282 EQU   CVTRV280
CVTRV281 EQU   CVTRV280
CVTRV279 EQU   CVTRV271
CVTRV278 EQU   CVTRV271
CVTRV277 EQU   CVTRV271
CVTRV276 EQU   CVTRV271
CVTRV275 EQU   CVTRV271
CVTRV274 EQU   CVTRV271
CVTRV273 EQU   CVTRV271
CVTRV272 EQU   CVTRV271
CVTRV270 EQU   CVTRV262
CVTRV269 EQU   CVTRV262
CVTRV268 EQU   CVTRV262
CVTRV267 EQU   CVTRV262
CVTRV266 EQU   CVTRV262
CVTRV265 EQU   CVTRV262
CVTRV264 EQU   CVTRV262
CVTRV263 EQU   CVTRV262
CVTVFP   EQU   CVTS01+464
CVTVSI   EQU   CVTS01+460
CVTVPSIB EQU   CVTS01+456
CVTMFACT EQU   CVTMFRTR
CVTMFCTL EQU   CVTS01+448
CVTPVBP  EQU   CVTS01+444
CVTPWI   EQU   CVTS01+440
CVTRV254 EQU   CVTS01+438
CVTRV253 EQU   CVTS01+436
CVTRV252 EQU   CVTS01+434
CVTRV251 EQU   CVTS01+433
CVTRV250 EQU   CVTS01+432
CVTRV249 EQU   CVTS01+431
CVTRV248 EQU   CVTS01+430
CVTRV247 EQU   CVTS01+429
CVTRV246 EQU   CVTS01+428
CVTRV245 EQU   CVTRV237
CVTRV244 EQU   CVTRV237
CVTRV243 EQU   CVTRV237
CVTRV242 EQU   CVTRV237
CVTRV241 EQU   CVTRV237
CVTRV240 EQU   CVTRV237
CVTRV239 EQU   CVTRV237
CVTRV238 EQU   CVTRV237
CVTRV236 EQU   CVTRV228
CVTRV235 EQU   CVTRV228
CVTRV234 EQU   CVTRV228
CVTRV233 EQU   CVTRV228
CVTRV232 EQU   CVTRV228
CVTRV231 EQU   CVTRV228
CVTRV230 EQU   CVTRV228
CVTRV229 EQU   CVTRV228
CVTRV227 EQU   CVTRV219
CVTRV226 EQU   CVTRV219
CVTRV225 EQU   CVTRV219
CVTRV224 EQU   CVTRV219
CVTRV223 EQU   CVTRV219
CVTRV222 EQU   CVTRV219
CVTRV221 EQU   CVTRV219
CVTRV220 EQU   CVTRV219
CVTRV218 EQU   CVTRV210
CVTRV217 EQU   CVTRV210
CVTRV216 EQU   CVTRV210
CVTRV215 EQU   CVTRV210
CVTRV214 EQU   CVTRV210
CVTRV213 EQU   CVTRV210
CVTRV212 EQU   CVTRV210
CVTRV211 EQU   CVTRV210
CVTLCCAT EQU   CVTS01+420
CVTPCCAT EQU   CVTS01+416
CVTIPCRP EQU   CVTS01+412
CVTIPCRI EQU   CVTS01+408
CVTIPCDS EQU   CVTS01+404
CVTAIDVT EQU   CVTS01+400
CVTSSAP  EQU   CVTS01+396
CVTEHCIR EQU   CVTS01+392
CVTEHDEF EQU   CVTS01+388
CVTDAIR  EQU   CVTS01+384
CVTPERFM EQU   CVTS01+380
CVT044R2 EQU   CVTS01+376
CVTFETCH EQU   CVTS01+372
CVTRSTWD EQU   CVTS01+368
CVTSPOST EQU   CVTS01+364
CVTIOBP  EQU   CVTS01+360
CVTASMVT EQU   CVTS01+356
CVTRECRQ EQU   CVTS01+352
CVTWSAC  EQU   CVTS01+348
CVTRV149 EQU   CVTS01+344
CVTWSAL  EQU   CVTS01+340
CVTSPSA  EQU   CVTS01+336
CVTGLMN  EQU   CVTS01+332
CVTVEAC0 EQU   CVTS01+328
CVT062R1 EQU   CVTS01+324
CVTRPOST EQU   CVTS01+320
CVTDQIQE EQU   CVTS01+316
CVTCSD   EQU   CVTS01+312
CVTLKRMA EQU   CVTS01+308
CVTRSPIE EQU   CVTS01+304
CVTRENQ  EQU   CVTS01+300
CVTLQCB  EQU   CVTS01+296
CVTFQCB  EQU   CVTS01+292
CVTQCS01 EQU   CVTS01+288
CVTAPFT  EQU   CVTS01+284
CVTPARRL EQU   CVTS01+280
CVTVWAIT EQU   CVTS01+276
CVTGSPL  EQU   CVTS01+272
CVTLSMQ  EQU   CVTS01+268
CVTGSMQ  EQU   CVTS01+264
CVTEXPRO EQU   CVTS01+260
CVTOPCTP EQU   CVTS01+256
CVTSIC   EQU   CVTS01+252
CVTTPIOS EQU   CVTS01+248
CVTRTMS  EQU   CVTS01+244
CVTSDBF  EQU   CVTS01+240
CVTSCBP  EQU   CVTS01+236
CVTSDMP  EQU   CVTS01+232
CVTSV60  EQU   CVTS01+228
CVTRTMCT EQU   CVTS01+224
CVTASCBL EQU   CVTS01+220
CVTASCBH EQU   CVTS01+216
CVTGDA   EQU   CVTS01+212
CVTASVT  EQU   CVTS01+208
CVTVVMDI EQU   CVTS01+204
CVTAQTOP EQU   CVTS01+200
CVTIOSCS EQU   CVTS01+196
CVTSDRM  EQU   CVTS01+192
CVTOPTE  EQU   CVTS01+188
CVTSTXU  EQU   CVTS01+184
CVTQUIS  EQU   CVTS01+180
CVTS1EE  EQU   CVTS01+172
CVTFRAS  EQU   CVTS01+168
CVTQSAS  EQU   CVTS01+164
CVTCRAS  EQU   CVTS01+160
CVTCRMN  EQU   CVTS01+156
CVTDELCP EQU   CVTS01+152
CVTFRECL EQU   CVTS01+148
CVTGETCL EQU   CVTS01+144
CVTBLDCP EQU   CVTS01+140
CVTAUTHL EQU   CVTS01+136
CVTSCAN  EQU   CVTS01+132
CVTRV144 EQU   CVTS01+130
CVTMAXMP EQU   CVTS01+128
CVTSTCK  EQU   CVTS01+124
CVTRV139 EQU   CVTS01+123
CVTDSSAC EQU   CVTS01+122
CVTRV513 EQU   CVTS01+121
CVTIOSPL EQU   CVTS01+120
CVTPTGT  EQU   CVTS01+116
CVTCSPIE EQU   CVTS01+112
CVTSMFEX EQU   CVTS01+108
CVTOLT0A EQU   CVTS01+104
CVTSRBRT EQU   CVTS01+100
CVTPUTL  EQU   CVTS01+96
CVTASCRL EQU   CVTS01+92
CVTASCRF EQU   CVTS01+88
CVTRV326 EQU   CVTS01+84
CVTRV325 EQU   CVTS01+80
CVTRV324 EQU   CVTS01+76
CVT0VL01 EQU   CVTS01+72
CVTSHRVM EQU   CVTS01+68
CVTRV332 EQU   CVTS01+64
CVTTAS   EQU   CVTS01+60
CVTRSCN  EQU   CVTS01+56
CVTTRAC2 EQU   CVTS01+54
CVTTRACE EQU   CVTS01+52
CVTAPG   EQU   CVTS01+51
CVTSDTRC EQU   CVTCTLFG
CVTGTRCE EQU   CVTCTLFG
CVTNOMP  EQU   CVTCTLFG
CVTRSV79 EQU   CVTCTLFG
CVTDSTAT EQU   CVTCTLFG
CVTRSV78 EQU   CVTCTLFG
CVTRV333 EQU   CVTCTLFG
CVTRV323 EQU   CVTCTLFG
CVTSPVLK EQU   CVTS01+49
CVTRSV77 EQU   CVTS01+48
CVTRV331 EQU   CVTS01+44
CVTRV330 EQU   CVTS01+40
CVTRV329 EQU   CVTS01+36
CVTRV328 EQU   CVTS01+32
CVTRV322 EQU   CVTS01+28
CVTSLID  EQU   CVTSLIDA+1
CVTSYLK  EQU   CVTSLIDA
CVTRV321 EQU   CVTS01+20
CVTRV320 EQU   CVTS01+16
CVTLPDIR EQU   CVTLPDIA+1
CVTRSV69 EQU   CVTDIRST
CVTRSV68 EQU   CVTDIRST
CVTRSV67 EQU   CVTDIRST
CVTRSV66 EQU   CVTDIRST
CVTRSV65 EQU   CVTDIRST
CVTRSV64 EQU   CVTDIRST
CVTRSV63 EQU   CVTDIRST
CVTDICOM EQU   CVTDIRST
CVTPVTP  EQU   CVTS01+8
CVTLPDSR EQU   CVTS01+4
CVTGETL  EQU   CVTS01
CLNLEN   EQU   CLNREC+4
@NM00042 EQU   NEWLINE+6
@NM00041 EQU   NEWLINE
@NM00040 EQU   BUFCTL+2
INDATA   EQU   INLINE+4
@NM00035 EQU   INLINE+2
@NM00034 EQU   GTPB
@NM00029 EQU   @NM00028+3
@NM00027 EQU   @NM00026+3
@NM00025 EQU   PRSPDE
PPLECB   EQU   PPL+8
PPLECT   EQU   PPL+4
PPLUPT   EQU   PPL
CVTLEVL  EQU   CVTRELNO+2
CVTNUMB  EQU   CVTRELNO
CVTMDL   EQU   CVTFIX+250
@NM00024 EQU   CVTFIX+248
@NM00023 EQU   CVTFIX
CVTRV482 EQU   CVTXTNT2+128
CVTRV481 EQU   CVTXTNT2+124
CVTRV480 EQU   CVTXTNT2+120
CVTRV479 EQU   CVTXTNT2+118
CVTRV478 EQU   CVTXTNT2+117
CVTRV477 EQU   CVTXTNT2+116
CVTRV476 EQU   CVTXTNT2+115
CVTRV475 EQU   CVTXTNT2+114
CVTRV474 EQU   CVTRV466
CVTRV473 EQU   CVTRV466
CVTRV472 EQU   CVTRV466
CVTRV471 EQU   CVTRV466
CVTRV470 EQU   CVTRV466
CVTRV469 EQU   CVTRV466
CVTRV468 EQU   CVTRV466
CVTRV467 EQU   CVTRV466
CVTRV465 EQU   CVTRV457
CVTRV464 EQU   CVTRV457
CVTRV463 EQU   CVTRV457
CVTRV462 EQU   CVTRV457
CVTRV461 EQU   CVTRV457
CVTRV460 EQU   CVTRV457
CVTRV459 EQU   CVTRV457
CVTRV458 EQU   CVTRV457
CVTRV456 EQU   CVTXTNT2+108
CVTRV455 EQU   CVTXTNT2+104
CVTRV454 EQU   CVTXTNT2+100
CVTRV453 EQU   CVTXTNT2+96
CVTRV452 EQU   CVTXTNT2+94
CVTRV451 EQU   CVTXTNT2+92
CVTRV450 EQU   CVTXTNT2+90
CVTRV449 EQU   CVTXTNT2+88
CVTRV448 EQU   CVTXTNT2+87
CVTRV447 EQU   CVTXTNT2+86
CVTRV446 EQU   CVTRV438
CVTRV445 EQU   CVTRV438
CVTRV444 EQU   CVTRV438
CVTRV443 EQU   CVTRV438
CVTRV442 EQU   CVTRV438
CVTRV441 EQU   CVTRV438
CVTRV440 EQU   CVTRV438
CVTRV439 EQU   CVTRV438
CVTRV437 EQU   CVTRV429
CVTRV436 EQU   CVTRV429
CVTRV435 EQU   CVTRV429
CVTRV434 EQU   CVTRV429
CVTRV433 EQU   CVTRV429
CVTRV432 EQU   CVTRV429
CVTRV431 EQU   CVTRV429
CVTRV430 EQU   CVTRV429
CVTRV428 EQU   CVTXTNT2+80
CVTRV427 EQU   CVTXTNT2+76
CVTRV426 EQU   CVTXTNT2+72
CVTRV425 EQU   CVTXTNT2+68
CVTATACT EQU   CVTATCVT
CVTRV423 EQU   CVTXTNT2+62
CVTRV422 EQU   CVTXTNT2+60
CVTRV421 EQU   CVTXTNT2+58
CVTRV420 EQU   CVTXTNT2+56
CVTRV419 EQU   CVTXTNT2+55
CVTRV418 EQU   CVTXTNT2+54
CVTRV417 EQU   CVTRV409
CVTRV416 EQU   CVTRV409
CVTRV415 EQU   CVTRV409
CVTRV414 EQU   CVTRV409
CVTRV413 EQU   CVTRV409
CVTRV412 EQU   CVTRV409
CVTRV411 EQU   CVTRV409
CVTRV410 EQU   CVTRV409
CVTRV408 EQU   CVTRV400
CVTRV407 EQU   CVTRV400
CVTRV406 EQU   CVTRV400
CVTRV405 EQU   CVTRV400
CVTRV404 EQU   CVTRV400
CVTRV403 EQU   CVTRV400
CVTRV402 EQU   CVTRV400
CVTRV401 EQU   CVTRV400
CVTICB   EQU   CVTXTNT2+48
CVTSKTA  EQU   CVTXTNT2+44
CVTCCVT  EQU   CVTXTNT2+40
CVTRSV98 EQU   CVTXTNT2+36
CVTRSV97 EQU   CVTXTNT2+34
CVTRSV96 EQU   CVTXTNT2+32
CVTOLTEP EQU   CVTXTNT2+28
CVTQIDA  EQU   CVTQID+1
CVTRSV95 EQU   CVTQID
CVTRSV94 EQU   CVTXTNT2+20
CVTRSV93 EQU   CVTXTNT2+16
CVTRSV92 EQU   CVTXTNT2+12
CVTDEBVR EQU   CVTXTNT2+8
CVTRSV91 EQU   CVTXTNT2+6
CVTRSV9H EQU   CVTFLGBT
CVTRSV9G EQU   CVTFLGBT
CVTRSV9F EQU   CVTFLGBT
CVTRSV9E EQU   CVTFLGBT
CVTRSV9D EQU   CVTFLGBT
CVTRSV9C EQU   CVTFLGBT
CVTVME   EQU   CVTFLGBT
CVTNPE   EQU   CVTFLGBT
CVTNUCLS EQU   CVTXTNT2+4
CVTDSSVA EQU   CVTDSSV+1
CVTRSV89 EQU   CVTDSSV
CVTRSV88 EQU   CVTXTNT1+8
CVTRSV87 EQU   CVTXTNT1+4
CVTFACHN EQU   CVTXTNT1
CVTRV488 EQU   CVTMAP+412
CVTRV487 EQU   CVTMAP+408
CVTRV486 EQU   CVTMAP+404
CVTRV485 EQU   CVTMAP+400
CVTACTAP EQU   CVTMAP+396
CVTAUTH  EQU   CVTMAP+392
CVTATMCA EQU   CVTATMCT+1
CVTATMST EQU   CVTATMCT
CVTRSV61 EQU   CVTMAP+384
CVTVOLT1 EQU   CVTVOLM1+1
CVTVOLI1 EQU   CVTVOLF1
CVTSTOA  EQU   CVTMAP+376
CVTRSV58 EQU   CVTMAP+374
CVTRSV57 EQU   CVTMAP+372
CVTDDCE  EQU   CVTMAP+368
CVTPNWFR EQU   CVTMAP+364
CVTSMF   EQU   CVTMAP+360
CVTSULK  EQU   CVTMAP+358
CVTSLKO  EQU   CVTSYSK
CVTSLKP  EQU   CVTSYSK
CVTSLKQ  EQU   CVTSYSK
CVTSLKR  EQU   CVTSYSK
CVTRSV56 EQU   CVTSYSK
CVTRSV55 EQU   CVTSYSK
CVTRSV54 EQU   CVTSYSK
CVTRSV53 EQU   CVTSYSK
CVTRSV52 EQU   CVTA1F1
CVTRSV51 EQU   CVTA1F1
CVTRSV50 EQU   CVTA1F1
CVTRSV49 EQU   CVTA1F1
CVTRSV48 EQU   CVTA1F1
CVTRSV47 EQU   CVTA1F1
CVTSRSW  EQU   CVTA1F1
CVTPFSW  EQU   CVTA1F1
CVTPCVT  EQU   CVTMAP+352
CVTRSV46 EQU   CVTMAP+344
CVTRSV45 EQU   CVTMAP+340
CVTRSV44 EQU   CVTMAP+338
CVTRSV43 EQU   CVTMAP+336
CVTHJESA EQU   CVTHJES+1
CVTRSV42 EQU   CVTHJES
CVTEXT2A EQU   CVTEXT2+1
CVTRSV41 EQU   CVTEXT2
CVTAPFA  EQU   CVTAPF+1
CVTRSV40 EQU   CVTAPF
CVTRV518 EQU   CVTINTLA
CVTRV517 EQU   CVTERPV
CVTEORM  EQU   CVTMAP+312
CVTMCHPR EQU   CVTMAP+308
CVTTZ    EQU   CVTMAP+304
CVTJEPS  EQU   CVTMAP+300
CVTJESCT EQU   CVTMAP+296
CVTMODE  EQU   CVTMAP+292
CVTPTRV  EQU   CVTMAP+288
CVTREAL  EQU   CVTMAP+284
CVTRSV39 EQU   CVTMAP+280
CVTRSV38 EQU   CVTMAP+276
CVTDMSRA EQU   CVTDMSR+1
CVTRV634 EQU   CVTDMSRF
CVTRV633 EQU   CVTDMSRF
CVTRV632 EQU   CVTDMSRF
CVTRV631 EQU   CVTDMSRF
CVTRV630 EQU   CVTDMSRF
CVTRV629 EQU   CVTDMSRF
CVTUDUMP EQU   CVTDMSRF
CVTSDUMP EQU   CVTDMSRF
CVTQMSGA EQU   CVTQMSG+1
CVTRSV36 EQU   CVTQMSG
CVTAMFF  EQU   CVTMAP+264
CVTPURGA EQU   CVTPURG+1
CVTRSV35 EQU   CVTPURG
CVTCBSP  EQU   CVTMAP+256
CVTATERA EQU   CVTATER+1
CVTSYST  EQU   CVTATER
CVTVOLT2 EQU   CVTTAT
CVTVOLI2 EQU   CVTVOLF2
CVTAQAVB EQU   CVTAQAVT+1
CVTRSV34 EQU   CVTTCMFG
CVTRSV33 EQU   CVTTCMFG
CVTRSV32 EQU   CVTTCMFG
CVTRSV31 EQU   CVTTCMFG
CVTRSV30 EQU   CVTTCMFG
CVTRSV29 EQU   CVTTCMFG
CVTRSV28 EQU   CVTTCMFG
CVTTCRDY EQU   CVTTCMFG
CVTGTFA  EQU   CVTGTF+1
CVTRSV27 EQU   CVTGTFST
CVTRNIO  EQU   CVTGTFST
CVTUSR   EQU   CVTGTFST
CVTRV318 EQU   CVTFORM
CVTRV317 EQU   CVTTMODE
CVTRV316 EQU   CVTSTATE
CVTRV315 EQU   CVTGTFS
CVTGTFAV EQU   CVTGTFS
CVT0SCR1 EQU   CVTMAP+232
CVTRV515 EQU   CVTMAP+228
CVTRMS   EQU   CVTMAP+224
CVTPATCH EQU   CVTMAP+220
CVTTSCE  EQU   CVTMAP+216
CVTLNKSC EQU   CVTMAP+214
CVTQABST EQU   CVTMAP+212
CVTMDLDS EQU   CVTMAP+208
CVTUSER  EQU   CVTMAP+204
CVTABEND EQU   CVTMAP+200
CVTSMCA  EQU   CVTMAP+196
CVTRSV18 EQU   CVTMAP+192
CVTQLPAQ EQU   CVTMAP+188
CVTQCDSR EQU   CVTMAP+184
CVTRSV17 EQU   CVTOPTB
CVTRSV16 EQU   CVTOPTB
CVTFP    EQU   CVTOPTB
CVTAPTHR EQU   CVTOPTB
CVTNLOG  EQU   CVTOPTB
CVTTOD   EQU   CVTOPTB
CVTCTIMS EQU   CVTOPTB
CVTPROT  EQU   CVTOPTB
CVTXPFP  EQU   CVTOPTA
CVTASCII EQU   CVTOPTA
CVTRSV13 EQU   CVTOPTA
CVTRSV12 EQU   CVTOPTA
CVTNIP   EQU   CVTOPTA
CVTDDR   EQU   CVTOPTA
CVTAPR   EQU   CVTOPTA
CVTCCH   EQU   CVTOPTA
CVTSNCTR EQU   CVTMAP+180
CVTQMWR  EQU   CVTMAP+176
CVTQOCR  EQU   CVTMAP+172
CVT1EF00 EQU   CVTMAP+168
CVTMZ00  EQU   CVTMAP+164
CVTSV76Q EQU   CVTSV76C
CVTRSV11 EQU   CVTMAP+156
CVT0PT01 EQU   CVTMAP+152
CVTMSER  EQU   CVTMAP+148
CVTRV516 EQU   CVTIERLC
CVTILCH  EQU   CVTMAP+140
CVT0DS   EQU   CVTMAP+136
CVTFBOSV EQU   CVTMAP+132
CVTNUCB  EQU   CVTMAP+128
CVTIXAVL EQU   CVTMAP+124
CVTSV76M EQU   CVTIOQET
CVTDCBA  EQU   CVTMAP+117
CVTMVS2  EQU   CVTDCB
CVT6DAT  EQU   CVTDCB
CVT4MPS  EQU   CVTDCB
CVTRSV09 EQU   CVTDCB
CVT4MS1  EQU   CVTDCB
CVT2SPS  EQU   CVTDCB
CVT1SSS  EQU   CVTDCB
CVTRSV08 EQU   CVTDCB
CVTSTB   EQU   CVTMAP+112
CVTQTD00 EQU   CVTMAP+108
CVTQTE00 EQU   CVTMAP+104
CVTCUCB  EQU   CVTMAP+100
CVTSJQ   EQU   CVTMAP+96
CVTPBLDL EQU   CVTMAP+92
CVTTPC   EQU   CVTMAP+88
CVTSVDCB EQU   CVTMAP+84
CVTBRET  EQU   CVTMAP+82
CVTEXIT  EQU   CVTMAP+80
CVT0FN00 EQU   CVTMAP+76
CVTDARA  EQU   CVTDAR+1
CVTRSV07 EQU   CVTFLGS1
CVTRSV06 EQU   CVTFLGS1
CVTRSV05 EQU   CVTFLGS1
CVTRSV04 EQU   CVTFLGS1
CVTRSV03 EQU   CVTFLGS1
CVTRSV02 EQU   CVTFLGS1
CVTRSV01 EQU   CVTFLGS1
CVTDMPLK EQU   CVTFLGS1
CVTXITP  EQU   CVTMAP+68
CVTZDTAB EQU   CVTMAP+64
CVTMSLT  EQU   CVTMAP+60
CVTDATE  EQU   CVTMAP+56
CVTBTERM EQU   CVTMAP+52
CVTSYSAD EQU   CVTMAP+48
CVTXTLER EQU   CVTMAP+44
CVTILK2  EQU   CVTMAP+40
CVTILK1  EQU   CVTMAP+36
CVTPRLTV EQU   CVTMAP+32
CVTPCNVT EQU   CVTMAP+28
CVT0VL00 EQU   CVTMAP+24
CVTXAPG  EQU   CVTMAP+20
CVTBUF   EQU   CVTMAP+16
CVTJOB   EQU   CVTMAP+12
CVTLINK  EQU   CVTMAP+8
CVT0EF00 EQU   CVTMAP+4
CVTTCBP  EQU   CVTMAP
CVT      EQU   CVTMAP
CXDATEXT EQU   IKJEBECX
CAPDEXT  EQU   IKJEBECA+3984
CADSNRC2 EQU   IKJEBECA+3928
CADSNOF2 EQU   IKJEBECA+3926
CADSNLN2 EQU   IKJEBECA+3924
CADSNPT2 EQU   IKJEBECA+3920
@NM00022 EQU   IKJEBECA+3900
CASVAREA EQU   IKJEBECA+3176
CAFIBFR  EQU   IKJEBECA+1188
CAAEDCB  EQU   IKJEBECA+1096
CALDROP  EQU   IKJEBECA+1064
CAATNWKA EQU   IKJEBECA+956
CAATNBUF EQU   IKJEBECA+952
CAMODETX EQU   CAMODEMG+12
CAMODEOF EQU   CAMODEMG+10
CAMODELN EQU   CAMODEMG+8
CAMODEPT EQU   CAMODEMG+4
CAMODEIS EQU   CAMODEMG
CASRWKA  EQU   IKJEBECA+728
CAMSWKA  EQU   IKJEBECA+628
@NM00021 EQU   CAMAWKA+30
@NM00020 EQU   MACFLAG2
MATABLE1 EQU   MACFLAG2
@NM00019 EQU   MACFLAGS
MAENDPRC EQU   MACFLAGS
MAABBREV EQU   MACFLAGS
MAECTMOD EQU   MACFLAGS
@NM00018 EQU   CAMAWKA
CASTAEPL EQU   IKJEBECA+576
CASTAXPL EQU   IKJEBECA+556
CASRPLST EQU   CATMPLST+12
CAPTECB  EQU   CATMPLST+8
CAPTECT  EQU   CATMPLST+4
CAPTUPT  EQU   CATMPLST
CASYNSCN EQU   CASYNSW
CASYNML  EQU   CASYNSW
CASYNSF  EQU   CASYNSW
CASYNRFM EQU   CASYNSW
@NM00017 EQU   CASYNSW
CASYNLN  EQU   CASYNSW
@NM00016 EQU   CASYNSW
CASYNRCL EQU   CASYNOPT+2
CASYNCD1 EQU   CASYNOPT
CASYNTEM EQU   CASYNWA+12
CASYNMS2 EQU   CASYNWA+8
CASYNWAP EQU   CASYNWA+1
CASYNPTO EQU   CASYNLST+8
CASYNPWA EQU   CASYNLST+4
@NM00015 EQU   IKJEBECA+484
CARECNO  EQU   IKJEBECA+480
@NM00014 EQU   IKJEBECA+472
CASAPSWD EQU   IKJEBECA+440
CASADDN  EQU   IKJEBECA+432
CASAMEMB EQU   IKJEBECA+424
CASADSN  EQU   IKJEBECA+380
CASADSNL EQU   IKJEBECA+378
CASADQTY EQU   CASAFLG2
CASANCTG EQU   CASAFLG2
CASAALOC EQU   CASAFLAG
CASAUNCG EQU   CASAFLAG
CASADSOR EQU   CASAFLAG
CASAMEM  EQU   CASAFLAG
CASADISP EQU   CASAFLAG
CASAINCP EQU   CASAFLAG
CASAFNCP EQU   CASAFLAG
CASAVEDS EQU   CASAFLAG
CADSNREC EQU   IKJEBECA+320
CADSNOFF EQU   IKJEBECA+318
CADSNLEN EQU   IKJEBECA+316
CADSNPTR EQU   IKJEBECA+312
CAEDTSIZ EQU   IKJEBECA+308
CAEDPSWD EQU   IKJEBECA+300
CAEDDDN  EQU   IKJEBECA+292
CAEDMEMB EQU   IKJEBECA+284
CAEDDSN  EQU   IKJEBECA+240
CAEDDSNL EQU   IKJEBECA+238
CAEDPRTC EQU   CAEDFLG2
CAEDALOC EQU   CAEDFLAG
CAEDUNCG EQU   CAEDFLAG
CAEDDSOR EQU   CAEDFLAG
CAEDMEM  EQU   CAEDFLAG
CAEDDISP EQU   CAEDFLAG
CAEDINCP EQU   CAEDFLAG
CAEDFNCP EQU   CAEDFLAG
CAEDITDS EQU   CAEDFLAG
CABLK2   EQU   IKJEBECA+234
@NM00013 EQU   IKJEBECA+226
CAPDEND  EQU   CAPD+82
CADATEXT EQU   CAPD+74
CAEXTNAM EQU   CAPD+66
CAPRNAME EQU   CAPD+58
CACHKOPT EQU   CAPD+56
CAULRLMX EQU   CAPD+54
CAULRLDF EQU   CAPD+52
CAVLRLMX EQU   CAPD+50
CAVLRLDF EQU   CAPD+48
CAFLRLMX EQU   CAPD+46
CAFLRLDF EQU   CAPD+44
CARECFMD EQU   CAPD+43
@NM00012 EQU   CADSATR2
CAINLIST EQU   CADSATR2
CARUNDS  EQU   CADSATR2
CAOBJGEN EQU   CADSATR2
CADSNDEF EQU   CADSATR2
CALINTAB EQU   CADSATR2
@NM00011 EQU   CADSATTR
CALRECLX EQU   CADSATTR
CALNNUM  EQU   CADSATTR
CACAPSDF EQU   CADSATTR
CACAPSRQ EQU   CADSATTR
CASCAN   EQU   CADSATTR
CARUN    EQU   CADSATTR
CATABS   EQU   CAPD+20
CALENGTH EQU   CAPD+19
CALINE   EQU   CAPD+18
CABLKS   EQU   CAPD+16
CADSQUAL EQU   CAPD+8
CADSTYPE EQU   CAPD
@NM00010 EQU   CACFLAG+8
CAPLIRTM EQU   CACFLAG+7
CAPLILFM EQU   CACFLAG+6
@NM00009 EQU   CACFLAG6
CACHAR60 EQU   CACFLAG6
CACHAR48 EQU   CACFLAG6
CAFREE   EQU   CACFLAG6
@NM00008 EQU   CACFLAG5
CAEDLNDP EQU   CACFLAG5
CADSUSED EQU   CACFLAG4
CARECURS EQU   CACFLAG4
CAINPROC EQU   CACFLAG4
CASCRC20 EQU   CACFLAG4
CAABEND  EQU   CACFLAG4
CATPUTVF EQU   CACFLAG4
CAPTGTBF EQU   CACFLAG4
CAFINDIS EQU   CACFLAG4
@NM00007 EQU   CAIMFLG
@NM00006 EQU   CACFLAG2
CAX22ABN EQU   CACFLAG2
CAX37ABN EQU   CACFLAG2
CASEQCOL EQU   CACFLAG2
CASCANON EQU   CACFLAG2
CADSMODS EQU   CACFLAG2
CACAPS   EQU   CACFLAG1
CAENDSC  EQU   CACFLAG1
CAINITSC EQU   CACFLAG1
CAVRFYSW EQU   CACFLAG1
CALNTOVF EQU   CACFLAG1
@NM00005 EQU   CAATTN
@NM00004 EQU   IKJEBECA+118
CAMAXBLK EQU   IKJEBECA+116
CAESDSPL EQU   IKJEBECA+112
@NM00003 EQU   IKJEBECA+88
CAPTICLN EQU   IKJEBECA+84
CAPTICDS EQU   IKJEBECA+80
CAPTNBFR EQU   IKJEBECA+76
CACORELN EQU   IKJEBECA+68
CAPTCORE EQU   IKJEBECA+64
CAUTILNO EQU   IKJEBECA+60
CAPTPDCB EQU   IKJEBECA+56
@NM00002 EQU   IKJEBECA+50
CASCMDLN EQU   IKJEBECA+48
CAPTSCMD EQU   IKJEBECA+44
CAPTRTRY EQU   IKJEBECA+32
CAPTMSGM EQU   IKJEBECA+28
CAPTUT   EQU   IKJEBECA+24
CAPTMS   EQU   IKJEBECA+20
CAPTLE   EQU   IKJEBECA+16
CAPTAT   EQU   IKJEBECA+12
CAPTAE   EQU   IKJEBECA+8
@NM00001 EQU   IKJEBECA+4
CAPTTMP  EQU   IKJEBECA
*                                      END UNREFERENCED COMPONENTS
@RC00180 EQU   EXIT
@RC00190 EQU   EXIT
@RT00175 EQU   @RC00158
@RF00158 EQU   BTMPRMT
@RT00228 EQU   BTMPRMT
@RC00231 EQU   BOTTOM
@RT00280 EQU   INDSFPT
@RC00284 EQU   @RC00283
@RF00356 EQU   @RC00354
@RT00364 EQU   IORET
@RC00373 EQU   IORET
GETNEXT  EQU   MAINLP
@RT00463 EQU   SETPRMPT
@RF00470 EQU   LPOUT1
@RF00504 EQU   MVNUM
@RT00521 EQU   RDTERM
@RF00537 EQU   EXIT2
@RT00559 EQU   NOCORE
@RT00562 EQU   EXIT2
@RT00578 EQU   EXIT1
@RT00597 EQU   @RC00595
@RF00614 EQU   RFORMLP
@RT00624 EQU   @RC00619
@RT00650 EQU   SYNSCAN
@RT00654 EQU   NOCHKR
@RF00672 EQU   LPOUT
@RT00696 EQU   EXIT2
@RT00767 EQU   NOLINE
@RF00803 EQU   NOCOREMG
@RT00812 EQU   NOCOREMG
@RT00827 EQU   SYNEXIT
@RF00843 EQU   EXITCK
@RT00873 EQU   SNEREXIT
@RF00851 EQU   EXITCK
@RT00896 EQU   NOCOREMG
@RC00842 EQU   SNEREXIT
@PB00009 EQU   @EL00001
@PB00008 EQU   @PB00009
@PB00007 EQU   @PB00008
@PB00006 EQU   @PB00007
@PB00005 EQU   @PB00006
@PB00004 EQU   @PB00005
@PB00003 EQU   @PB00004
@PB00002 EQU   @PB00003
@ENDDATA EQU   *
         END   IKJEBEIP,(C'PLS1515',0701,78121)
