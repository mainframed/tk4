BEAA TITLE 'EDIT COMMAND ACCESS METHOD -VECTOR TABLE ---IKJEBEAA'
IKJEBEAA CSECT
*C0-999999                                                     @Y30NQKG
*          FIX B0A ABEND ON LARGE DATA SET                     @ZA12679
         SPACE 3
*   THE FOLLOWING ARE REGISTER ASSIGNMENTS
PARMREG0 EQU   0                       PARM POINTER
PARMREG1 EQU   1                       PARM POINTER
FROMREG  EQU   2                       FROM ADDRESS REGISTER
TOREG    EQU   3                       TO ADDRESS REGISTER
WORK2    EQU   2                       WORK REGISTER
WORK3    EQU   3                       WORK REGISTER
WORK4    EQU   4                       WORK REGISTER
WORK5    EQU   5                       WORK REGISTER
WORK6    EQU   6                       WORK REGISTER
WORK7    EQU   7                       WORK REGISTER
WORK8    EQU   8                       WORK REGISTER
LINK9    EQU   9                       SUBROUTINE LINK REGISTER
WORK9    EQU   9                       WORK REGISTER
COMMREG  EQU   10                      VECTOR TABLE ADDRESSING
BASEREG  EQU   11                      BASE REGISTER
DATAREG  EQU   12                      UTILITY WORK AREA ADDRESSING
SAVEREG  EQU   13                      SAVE AREA ADDRESSING
RETREG   EQU   14                      RETURN REGISTER
RETCDREG EQU   15                      RETURN CODE
ENTRY    EQU   15                      ENTRY POINT ADDRESS
         EJECT
*   DEFINITIONS
ZERO     EQU   0                       CONSTANT OF ZERO
ONE      EQU   1                       CONSTANT OF ONE
L2       EQU   2                       LENGTH OF TWO
L3       EQU   3                       LENGTH OF THREE
L4       EQU   4                       LENGTH OF FOUR
L8       EQU   8                       LENGTH OF EIGHT
X0       EQU   0                       OFFSET OF ZERO
X1       EQU   1                       OFFSET OF ONE
FOUR     EQU   4                       CONSTANT OF FOUR
K50      EQU   50                      CONSTANT OF 50
K78      EQU   78                      CONSTANT OF 78
K255     EQU   255                     CONSTANT OF 255
PTR      EQU   4                       LENGTH OF ADDRESSES
NRF      EQU   4                       RECORD DOES NOT EXIST CODE
EMPTY    EQU   8                       EMPTY DATA SET CODE
SPONE    EQU   1                       SUBPOOL ONE
IOERR    EQU   12                      I/O ERROR CODE
SAVEL    EQU   72                      SAVE AREA LENGTH
WORD1    EQU   0                       OFFSET TO 1ST PARAMETER WORD
WORD2    EQU   4                       OFFSET TO 2ND PARAMETER WORD
WORD3    EQU   8                       OFFSET TO 3RD PARAMETER WORD
EQUAL    EQU   8                       MASK FOR BRANCH ON EQUAL
NOTZERO  EQU   7                       MASK FOR BR ON NOT ZERO
RECHIGH  EQU   2                       MASK, RECORD KEY HIGH
COMPLETE EQU   X'40'                   I/O COMPLETE FLAG
GOOD     EQU   X'7F'                   I/O SUCCESSFUL FLAG
LAST     EQU   X'80'                   LAST ENTRY INDICATOR
ALL      EQU   X'FF'                   REPRESENTS ALL BITS//BYTE SWITCH
X3       EQU   3                       MASK TO GET HALFWORD    @ZA12679
*                                      UNSIGNED DSDBSIZE       @ZA12679
MAXDSI   EQU   X'F0'                   MAXDSDB SIZE=15*4096    @ZA12679
DIRCODE  EQU   11                      OFFSET TO INPUT OPTION
DELKEY   EQU   X'00'                   DELETE INDEX ENTRY CODE
NEWKEY   EQU   X'01'                   KEY ONLY UPDATE CODE
ALLKEY   EQU   X'FF'                   ENTIRE NEW ENTRY CODE
         SPACE 1
*   MESSAGE REFERENCES-  INSERTION FOR I/O ERROR MESSAGE IS RETURNED
*     VIA 'SYNADAF' AND STORED IN THE 'IOMSG' FIELD OF THE WORKAREA.
         EJECT
***********************************************************************
*                                                                     *
*STATUS -- VERSION NO. 02, VS2     RELEASE NO. 03                     *
*                                                                     *
*COPYRIGHT N/A                                                        *
*FUNCTION- THIS LOAD MODULE IS COMPRISED OF 16 CSECTS.
*   THE FIRST OF WHICH MUST BE THE VECTOR TABLE. THE
*   VECTOR TABLE CONTAINS THE ADDRESSES OF THE FIFTEEN
*   ROUTINES WHICH COMPRISE THE EDIT ACCESS METHOD. IN
*   ADDITION, THIS TABLE ALSO CONTAINS THE ADDRESS OF
*   THE SYNAD ROUTINE. THIS ALLOWS THE SYNAD ADDRESS IN THE
*   DCB TO BE EASILY RE-ESTABLISHED IF THIS LOAD MODULE
*   IS EVER DELETED AND THEN RELOADED.
*
*   EACH OF THE FOLLOWING ROUTINES (CSECTS) HAS ITS OWN PROLOGUE      *
*                                                                     *
*   THIS VECTOR TABLE IS USED BY ALL ROUTINES IN THIS MODULE THAT     *
*   CALL OTHER ROUTINES                                               *
*                                                                     *
*ENTRY POINTS-  FIVE ENTRY POINTS VIA A CALL FROM IKJEBEUT
*       IKJEBEDR             -DELETES RECORDS
*       IKJEBERR             -READS RECORDS
*       IKJEBEWR             -WRITES RECORDS
*       IKJEBEWP             -FINAL ENTRY FOR WRITE SEQUENTIAL
*       IKJEBEWS             -WRITE SEQUENTIAL RECORDS
*
*INPUT -- FOR INPUT INTO THE LOAD MODULE IKJEBEAA, SEE THE
*   PROLOGUE DESCRIPTIONS UNDER THE FIVE ROUTINES LISTED
*   AS ENTRY POINTS ABOVE.
*
*OUTPUT -- FOR OUTPUT OF THE LOAD MODULE IKJEBEAA, SEE THE
*   PROLOGUE DESCRIPTIONS UNDER THE FIVE ROUTINES LISTED
*   AS ENTRY POINTS ABOVE.
*
*EXTERNAL REFERENCES --  THIS FIRST CSECT, IKJEBEAA, CONTAINS         *
*   VCONS FOR ALL THE ROUTINES IN LOAD MODULE IKJEBEAA.               *
*                                                                     *
*EXITS,NORMAL -- SEE EACH INDIVIDUAL ROUTINE PROLOGUE                 *
*                                                                     *
*EXITS,ERROR -- SEE EACH INDIVIDUAL ROUTINE PROLOGUE                  *
*                                                                     *
*TABLES-                                                              *
*   'VECTABLE' IS A DSECT THAT DESCRIBES THIS VECTOR TABLE AND IS     *
*   USED IN THE FOLLOWING ADDITIONAL MODULES-                         *
*       IKJEBEUI             -UTILITY INITIALIZATION                  *
*       IKJEBEUT             -UTILITY ACCESSING                       *
*                                                                     *
*   RECORD FORMAT-                                                    *
*        ********************************************************     *
*        *        *    *    *                                   *     *
*        *  KEY   * LL * 00 *    DATA                           *     *
*        *        *    *    *                                   *     *
*        ********************************************************     *
*                                                                     *
*          WHERE-                                                     *
*            KEY-   IS A 4 BYTE BINARY FIELD DENOTING THE             *
*                   LOGICAL POSITION OF THE RECORD IN THE DATA SET.   *
*                                                                     *
*            LL-    IS A 2 BYTE LENGTH FIELD IN BINARY AND IS THE     *
*                   TOTAL LENGTH OF THE RECORD, EXCLUDING THE 'KEY'   *
*                   FIELD.                                            *
*                                                                     *
*            00-    IS A 2 BYTE FIELD CONTAINING BINARY ZERO.         *
*                                                                     *
*            DATA-  A 1 TO 251 BYTE FIELD THAT IS NOT ACCESSED BY     *
*                   THESE ROUTINES AND CAN BE IN ANY DATA FORMAT      *
*                   REPRESENTATION.                                   *
*                                                                     *
*   BLOCK FORMATS-                                                    *
*                                                                     *
*        DATA BLOCKS-  DESCRIBED IN DSECT 'BUFFER', STARTS AT         *
*                      LABEL 'DATA'.                                  *
*                                                                     *
*        DIRECTORY BLOCK - DESCRIBED IN DSECT 'BUFFER', STARTS AT     *
*                      LABEL 'NLEV'                                   *
*                                                                     *
*ATTRIBUTES- REFRESHABLE,ENABLED,NON-PRIVILEGED                       *
*                                                                     *
*NOTES -- THE VCONS ARE ORDER-DEPENDENT BECAUSE THEY ARE MAPPED       *
*   BY THE DSECT 'VECTABLE'                                           *
*                                                                     *
*   THIS ROUTINE IS CHARACTER CODE INDEPENDENT                        *
*                                                                     *
***********************************************************************
         EJECT
         SPACE 2
*   THIS CSECT MUST BE THE FIRST IN THE LOAD MODULE.                  *
*   THE ENTRIES BELOW ARE ORDER DEPENDENT AND CONTAIN
*     THE ADDRESSES FOR THE FOLLOWING ROUTINES
         SPACE 2
         DC    V(IKJEBEAD)             ADD-A-BLOCK
         DC    V(IKJEBEAS)             BUFFER ASSIGNMENT
         DC    V(IKJEBEDL)             REMOVE A RECORD
         DC    V(IKJEBEDR)             DELETE A RECORD
         DC    V(IKJEBEDS)             DIRECTORY SEARCH
         DC    V(IKJEBEDU)             DIRECTORY UPDATE
         DC    V(IKJEBELO)             FIND A RECORD
         DC    V(IKJEBEMV)             MOVE DATA
         DC    V(IKJEBERB)             READ A BLOCK
         DC    V(IKJEBERR)             READ A RECORD
         DC    V(IKJEBEWA)             WAIT ON I/O
         DC    V(IKJEBEWB)             WRITE A BLOCK
         DC    V(IKJEBEWP)             PURGE WRITE BUFFERS
         DC    V(IKJEBEWR)             WRITE A RECORD
         DC    V(IKJEBEWS)             WRITE SEQUENTIAL
         DC    V(IKJEBESY)             SYNAD ROUTINE
 TITLE 'EDIT COMMAND ACCESS METHOD --ADD A BLOCK ROUTINE ---IKJEBEAD'
***********************************************************************
*                                                                     *
*STATUS -- VERSION NO. 02, VS2     RELEASE NO. 03                     *
*                                                                     *
*FUNCTION-  -THIS ROUTINE IS USED WHENEVER A NEW BLOCK IS ADDED       *
*   TO THE UTILITY DATA SET. IF THERE ARE ANY EMPTY BLOCKS IN THE     *
*   DATA SET, THEY WILL BE RE-USED FIRST. ASSIGNING AN EMPTY BLOCK    *
*   CONSISTS OF REMOVING IT FROM THE EMPTY BLOCK QUEUE. THIS UNCHAIN- *
*   ING PROCESS CONSISTS OF PICKING UP THE TTR OF THE FIRST BLOCK ON  *
*   THE QUEUE FROM THE WORKAREA. THIS BLOCK IS READ IN AND IF ANOTHER *
*   BLOCK IS CHAINED TO THAT BLOCK, ITS TTR POINTER IS STORED IN THE  *
*   WORKAREA. WHEN THE LAST BLOCK IS USED, THE QUEUE POINTER (TTR)    *
*   IS SET TO ZERO.                                                   *
*        IF THERE ARE NO EMPTY BLOCKS, A BUFFER IS ASSIGNED BY THE    *
*   BUFFER ASSIGNMENT ROUTINE, IKJEBEAS. THIS EMPTY BUFFER IS         *
*   USED TO INITIATE A WRITE OPERATION IN ORDER TO FORMAT THE NEW     *
*   BLOCK IN THE DATA SET.                                            *
*        THE BUFFER ADDRESS FOR THE ASSIGNED BLOCK IS PASSED BACK     *
*   IN THE INPUT PARM LIST                                            *
*                                                                     *
*
*ENTRY POINT- AT IKJEBEAD VIA A CALL FROM-
*       IKJEBEWR             -THE WRITE A RECORD ROUTINE              *
*                                                                     *
*INPUT- REGISTER ONE POINTS TO A TWO WORD PARAMETER LIST              *
*   WORD1  -CONTAINS ADDRESS OF THE UTILITY WORKAREA                  *
*   WORD2  -NOT USED ON INPUT                                         *
*                                                                     *
*OUTPUT- REGISTERS AS DESCRIBED UNDER 'EXIT' BELOW                    *
*   WORD2 OF THE INPUT PARM LIST CONTAINS THE ADDRESS OF THE NEW      *
*     BUFFER AND BLOCK.                                               *
*   IF THERE WERE ANY EMPTY BLOCKS, IT REMOVES THE FIRST ONE ON THE   *
*     QUEUE.                                                          *
*                                                                     *
*EXTERNAL REFERENCES --                                               *
*       IKJEBERB            -READS IN EMPTY BLOCKS                    *
*       IKJEBEAS            -ASSIGNS A NEW BUFFER                     *
*       IKJEBEWB            -FORMATS NEW BLOCK                        *
*       IKJEBEWA            -WAITS ON I/O                             *
*                                                                     *
*EXITS,NORMAL --                                                      *
*   A RETURN CODE OF 0 IN REGISTER 15                                 *
*   BUFFER ADDRESS IN WORD2 OF PASSED PARAMETER LIST                  *
*                                                                     *
*EXITS,ERROR --                                                       *
*   A RETURN CODE OF 12 IN REGISTER 15  FOR I/O ERRORS                *
*                                                                     *
*TABLES/WORKAREA --                                                   *
*   DEPENDENT ON THE EMPTY BLOCK POINTER IN THE WORKAREA              *
*   DEPENDENT ON THE TABLE OF ROUTINE ADDRESSES FOR THE ABOVE         *
*     DESCRIBED EXTERNAL ROUTINES                                     *
*                                                                     *
*ATTRIBUTES- REFRESHABLE, ENABLED, NON-PRIVILEGED                     *
*                                                                     *
*NOTES -- REGISTER CONVENTIONS ARE AS FOLLOWS-                        *
*       BASEREG              -BASE REGISTER                           *
*       DATAREG              -WORK AREA ADDRESSING                    *
*       COMMREG              -VECTOR TABLE ADDRESSING                 *
*       WORK6                -BUFFER ADDRESSING                       *
*       WORK7                -BLOCK ADDRESSING
*                                                                     *
*   THIS ROUTINE IS CHARACTER CODE INDEPENDENT                        *
*                                                                     *
***********************************************************************
         SPACE 2
IKJEBEAD CSECT
*   PERFORM THE INITIALIZATION OPERATIONS HERE
         SAVE  (14,12),T,*
         LA    SAVEREG,SAVEL(SAVEREG)  STEP TO NEXT SAVEAREA
         LR    BASEREG,ENTRY           ENTRY POINT ADDRESS
         USING IKJEBEAD,BASEREG
         L     DATAREG,WORD1(PARMREG1) WORKAREA ADDRESS
         USING UTILWORK,DATAREG
         L     COMMREG,VTABLE          TABLE OF ROUTINE ADDRESSES
         USING VECTABLE,COMMREG
         SPACE 2
*   IF THERE ARE ANY EMPTY BLOCKS, USE THE FIRST OR ONLY IN CHAIN
         LR    WORK2,PARMREG1          SAVE INPUT PARM LIST ADDRESS
         OC    DCBEBQX(L4),DCBEBQX     ARE THERE ANY EMPTY BLOCKS
         BNZ   AD1                     YES-
         L     ENTRY,AS                ENTRY POINT ADDRESS
         CALL  (15)                    ASSIGN A BUFFER
         LTR   RETCDREG,RETCDREG       ANY I/O ERRORS
         BNZ   AD6                     YES
         L     WORK6,L4(PARMREG1)      ASSIGNED BUFFER ADDRESS
         USING BUFFER,WORK6
         SPACE 2
*   INITIATE THE WRITE OF THE NEW BLOCK HERE
         OI    BUFSTATS,NEWBLK         INDICATE NEWLY ASSIGNED BLOCK
         L     ENTRY,WB                ENTRY POINT ADDRESS
         CALL  (15)                    FORMAT THE NEW BLOCK
         LTR   RETCDREG,RETCDREG       ANY I/O ERRORS
         BNZ   AD6                     YES--RETURN
         ST    WORK6,WORD2(PARMREG1)   BUFFER ADDRESS TO PARM LIST
         L     ENTRY,WA                ENTRY POINT ADDRESS
         CALL  (15)                    WAIT FOR THE I/O
         LTR   RETCDREG,RETCDREG       ANY ERRORS
         BNZ   AD6                     YES-RETURN
         SPACE 2
*   EXIT TO CALLING PROGRAM HERE
AD50     SR    RETCDREG,RETCDREG       SET RETURN CODE
AD6      EQU   *                       ERROR RETURNS HERE
AD5      L     SAVEREG,WORD2(SAVEREG)  OLD SAVE AREA
         RETURN (14,12),T,RC=(15)      RESTORE THE REGISTERS
         SPACE 2
*   EMPTY BLOCK PROCESSING HANDLED HERE
AD1      MVC   PARM2(L4),DCBEBQX       TTR OF FIRST EMPTY BLOCK
         L     ENTRY,RB                ENTRY POINT ADDRESS
         CALL  (15)                    READ IN THE EMPTY BLOCK
         LTR   RETCDREG,RETCDREG       SUCCESSFUL
         BNZ   AD6                     NO--TERMINATE
AD4      L     WORK6,WORD2(PARMREG1)   BUFFER ADDRESS
         L     WORK7,BUFBLOCK          BLOCK ADDRESS
         USING DATA,WORK7              BLOCK ADDRESSABILITY
         MVC   DCBEBQX(TTR),EBTTR      TTR OF NEXT EMPTY BLOCK, IF ANY
         MVI   BUFSTATS,ZERO           CLEAR BUFFER STATUS FLAGS
         B     AD50                    EXIT SUCCESSFULLY
         SPACE
         DROP  BASEREG,DATAREG,COMMREG,WORK6,WORK7
 TITLE 'EDIT COMMAND ACCESS METHOD  -BUFFER ASSIGNMENT  ---IKJEBEAS'
***********************************************************************
*                                                                     *
*                                                                     *
*FUNCTION --  THIS ROUTINE ASSIGNS A BUFFER FOR A GIVEN        *
*   REQUEST. BUFFERS ARE ASSIGNED BY INSPECTING THE BUFFER     *
*   CHAIN.  EACH BUFFER IS INTERROGATED TO SEE IF IT IS
*   AVAILABLE, I.E. NEITHER THE WAIT, UPDATE, OR BLOCK-
*   IN-BUFFER FLAGS ARE ON. THE FIRST FOUND AVAILABLE
*   BUFFER IS THEN ASSIGNED TO FULFILL THE REQUEST.            *
*       IN THE EVENT THAT NO BUFFERS ARE AVAILABLE, AN ATTEMPT *
*   WILL BE MADE TO FREE-UP BUFFERS, BY EITHER WAITING FOR     *
*   BUFFERS THAT HAVE AN I/O OPERATION SCHEDULED WHICH HAS     *
*   NOT YET BEEN WAITED UPON,OR WRITING BACK BUFFERS THAT HAVE *
*   BEEN UPDATED BUT HAVE NOT BEEN WRITTEN BACK TO DIRECT-     *
*   ACCESSS.                                                   *
*                                                                     *
*ENTRY POINT --  AT IKJEBEAS VIA A CALL FROM EITHER-                  *
*       IKJEBEAD             -ADD A BLOCK ROUTINE                     *
*       IKJEBERB             -READ A BLOCK ROUTINE                    *
*                                                                     *
*INPUT --  REGISTER 1 POINTS TO A TWO WORD PARM LIST-                 *
*       WORD1-   -ADDRESS OF WORKAREA//DCB                            *
*       WORD2-   -NOT USED ON INPUT                                   *
*                                                                     *
*OUTPUT --  THE SECOND WORD OF THE INPUT PARM LIST CONTAINS THE       *
*   ADDRESS OF THE ASSIGNED BUFFER.                                   *
*   THE REGISTERS ARE AS DESCRIBED UNDER 'EXIT' BELOW.                *
*                                                                     *
*EXTERNAL REFERENCES --                                               *
*       IKJEBEWA             -WAITS ON I/O REQUESTS                   *
*       IKJEBEWB             -WRITE OUT UPDATED BLOCKS                *
*                                                                     *
*EXITS,NORMAL --  REGISTER 15 CONTAINS A RETURN CODE OF 0.            *
*   WORD2 OF INPUT PARM LIST CONTAINS THE BUFFER ADDRESS              *
*                                                                     *
*EXITS,ERROR -- A RETURN CODE OF 12 IN REGISTER 15 FOR I/O ERRORS     *
*                                                                     *
*TABLES/WORK AREAS --                                                 *
*       DEPENDENT ON THE WORKAREA, 'UTILWORK'.                        *
*       DEPENDENT ON THE BUFFER DESCRIPTION.                          *
*       DEPENDENT ON THE VECTOR TABLE FOR EXTERNAL REFERENCES         *
*                                                                     *
*ATTRIBUTES -- REFERESHABLE, NON-PRIVILEGED,  ENABLED                 *
*                                                                     *
*NOTE -- THE REGISTER CONVENTIONS ARE AS FOLLOWS-                     *
*       BASEREG              -BASE REGISTER                           *
*       DATAREG              -WORK AREA ADDRESSING                    *
*       COMMREG              -VECTOR TABLE ADDRESS                    *
*       WORK6                -BUFFER ADDRESSING                       *
*                                                                     *
*   THIS ROUTINE IS CHARACTER CODE INDEPENDENT                        *
*                                                                     *
***********************************************************************
         SPACE 2
IKJEBEAS CSECT
         SPACE
         SPACE
*   PERFORM THE INITIALIZATION OPERATIONS HERE
         SAVE  (14,12),T,*             SAVE THE REGISTERS
         LA    SAVEREG,SAVEL(SAVEREG)  STEP TO NEXT SAVEAREA
         LR    BASEREG,ENTRY           ENTRY POINT ADDRESS
         USING IKJEBEAS,BASEREG
         L     DATAREG,WORD1(PARMREG1) WORKAREA ADDRESS
         USING UTILWORK,DATAREG
         L     COMMREG,VTABLE          TABLE OF ROUTINE ADDRESSES
         USING VECTABLE,COMMREG
         LR    WORK2,PARMREG1          SAVE INPUT PARM ADDRESS
         SPACE 2
*   LOOK FOR AN AVAILABLE BUFFER
* CHECK FOR UPDATED,WAITING,LLDB AND BLKINBUF HERE
*
         USING BUFFER,WORK6
*
         LA    WORK3,UPDATED+WAITB+WAITXR+WAITXW+BLKINBUF
*                                      GET TEST BITS
         BAL   RETREG,AS8              TEST BUFFER STATUS
*                                      IF A SUITABLE BUFFER WAS
*                                      FOUND,CONTROL IS RETURNED
*                                      HERE, ELSE THE NEXT
*                                      INSTRUCTION IS SKIPPED.
         B     AS2                     *B TO ASSIGN BUFFER
         SPACE 2
* CHECK FOR A BUFFER THAT CAN BE WAITED UPON HERE
         LA    WORK3,UPDATED+BLKINBUF  GET TEST BITS
         BAL   RETREG,AS8              TEST BUFFER STATUS
*                                      IF A SUITABLE BUFFER HAS
*                                      BEEN FOUND,CONTROL IS
*                                      RETURNED HERE,ELSE THE
*                                      NEXT INSTRUCTION IS
*                                      SKIPPED.
         B     AS3                     *B TO WAIT ON BUFFER
         SPACE 2
*   FIND A BUFFER THAT CAN BE PURGED HERE
         LA    WORK3,BLKINBUF          STATUS BITS
         BAL   RETREG,AS8              FIND PURGE BUFFER
         B     AS4                     GO PURGE BUFFER
         SPACE 2
* PURGE BUFFER BY WRITING IT TO D-A HERE
AS4      ST    WORK6,WORD2(WORK2)      STORE IN PARMLIST
         LR    PARMREG1,WORK2          ADDRESS LIST
         L     ENTRY,WB                ENTRY POINT ADDRESS
         CALL  (15)                    WRITE OUT THIS BLOCK
         LTR   RETCDREG,RETCDREG       ANY ERRORS
         BNZ   AS9                     YES-RETURN
         SPACE 2
*   WAIT FOR A BUFFER TO EMPTY BEFORE ASSIGNING IT
AS3      ST    WORK6,WORD2(WORK2)      BUFFER ADDRESS TO LIST
         L     ENTRY,WA                ENTRY POINT ADDRESS
         CALL  (15)                    WAIT FOR THE I/O TO COMPLETE
         LTR   RETCDREG,RETCDREG       ANY I/O ERRORS
         BNZ   AS9                     YES-RETURN
         SPACE 2
*   ASSIGN THE SELECTED BUFFER HERE
AS2      ST    WORK6,WORD2(PARMREG1)   BUFFER ADDRESS
         SR    RETCDREG,RETCDREG       SET RETURN CODE = 0
AS9      EQU   *                       RETURN ON ERRORS HERE
AS11     L     SAVEREG,WORD2(SAVEREG)  OLD SAVE AREA
         RETURN (14,12),T,RC=(15)      RESTORE THE REGISTERS
         SPACE 2
* SEARCH THE BUFFER CHAIN FOR A SUITABLE BUFFER HERE
AS8      LH    WORK5,DCBBFNO           TOTAL BUFFERS
         LA    WORK6,BUF1              ADDRESS OF FIRST BUF.
AS81     XR    WORK4,WORK4             CLEAR
         IC    WORK4,BUFSTATS          GET BUFFER STATUS
         NR    WORK4,WORK3             RELEVANT FLAGS ON
         BZ    X0(,RETREG)             BUFFER IS OK TO USE
         LA    WORK6,L'BUF1(,WORK6)    NEXT BUFFER ADDRESS
         BCT   WORK5,AS81              REPEAT FOR ALL BUFFERS
         B     FOUR(,RETREG)           NONE FOUND-RETURN
         SPACE 2
         DROP  BASEREG,DATAREG,COMMREG,WORK6
 TITLE 'EDIT COMMAND ACCESS METHOD --RECORD REMOVAL ---IKJEBEDL'
***********************************************************************
*                                                                     *
*STATUS -- VERSION NO. 02, VS2     RELEASE NO. 03                     *
*                                                                     *
*FUNCTION --  THIS ROUTINE DELETES THE RECORD INDICATED BY THE        *
*   'BUFREF' FIELD IN THE SELECTED BUFFER.  DELETION OF A RECORD      *
*   INVOLVES REMOVING THE LOCATOR FOR THAT RECORD, ADJUSTING THE      *
*   POSITION OF OTHER LOCATORS IF NECESSARY, UPDATING THE RECORD      *
*   COUNT, AND MODIFYING THE SPACE CONTROL FIELDS FOR THAT BLOCK.     *
*       IF THE LAST RECORD OF A DATA BLOCK IS DELETED
*   THE DIRECTORY WILL BE UPDATED.
*        ANYTIME A DELETION RESULTS IN AN EMPTY BLOCK, THAT BLOCK     *
*   WILL BE PLACED IN THE EMPTY BLOCK QUEUE.                          *
*                                                                     *
*ENTRY POINT --                                                       *
*       IKJEBEDL   -VIA A CALL FROM EITHER IKJEBEDR OR IKJEBEWR       *
*                                                                     *
*INPUT --  REGISTER ONE POINTS TO A TWO WORD PARAMETER LIST-          *
*       WORD1-     POINTS TO THE WORKAREA, UTILWORK.                  *
*       WORD2-     POINTS TO THE SELECTED BUFFER.                     *
*                                                                     *
*OUTPUT --  THE RECORD INDICATED BY THE BUFREF FIELD HAS BEEN         *
*   REMOVED FROM THE BUFFER AND THE DATA BLOCK CONTROL FIELDS         *
*   UPDATED.  THE DIRECTORY IS UPDATED IF THE LAST LOGICAL RECORD     *
*   IS DELETED.  THE EMPTY BLOCK QUEUE TAKES ON A NEW ENTRY IF        *
*   AN EMPTY DATA BLOCK OR DIRECTORY BLOCK RESULTS BECAUSE OF THE     *
*   RECORD DELETION.                                                  *
*                                                                     *
*EXTERNAL REFERENCES --                                               *
*       IKJEBEMV             -MOVES INDICES OR LOCATORS               *
*       IKJEBEDU             -UPDATES THE DIRECTORY
*       IKJEBEWA             -WAITS ON I/O
*       IKJEBEWB             -WRITE OUT BLOCKS                        *
*                                                                     *
*EXITS,NORMAL -- RETURNS TO THE CALLING ROUTINE//RETURN CODES-        *
*       RETURN CODE =0   NORMAL DELETION, OUTPUT AS ABOVE.            *
*       RETURN CODE =8   EMPTY DATA SET,  OUTPUT AS ABOVE.            *
*                                                                     *
*EXITS,ERROR --  RETURNS TO CALLING ROUTINE -                         *
*       RETURN CODE = 12 I/O ERROR ENCOUNTERED.                       *
*                                                                     *
*TABLES/WORKAREAS --                                                  *
*       DEPENDENT ON EMPTY BLOCK QUEUE POINTER IN WORKAREA.           *
*       DEPENDENT ON 'BUFFER' DSECT DESCRIPTION                       *
*                                                                     *
*ATTRIBUTES -- REFRESHABLE, ENABLED, NON-PRIVILEGED                   *
*                                                                     *
*NOTES --  REGISTER CONVENTIONS ARE AS FOLLOWS-                       *
*       BASEREG              -BASE REGISTER                           *
*       COMMREG              -VECTOR TABLE ADDRESSING                 *
*       DATAREG              -WORK AREA ADDRESSING                    *
*       WORK6                -BUFFER ADDRESSING                       *
*       WORK7                -BLOCK ADDRESSING
*       WORK2,WORK3          -WORK REGISTERS                          *
*       WORK4,WORK5          -WORK REGISTERS                          *
*                                                                     *
*   THIS ROUTINE IS CHARACTER CODE INDEPENDENT                        *
*                                                                     *
***********************************************************************
         SPACE 2
IKJEBEDL CSECT
*   PERFORM THE INITIALIZATION OPERATIONS HERE
         SAVE  (14,12),T,*             SAVE THE REGISTERS
         LA    SAVEREG,SAVEL(SAVEREG)  STEP TO NEXT SAVEAREA
         LR    BASEREG,ENTRY           ENTRY POINT ADDRESS
         USING IKJEBEDL,BASEREG
         L     DATAREG,WORD1(PARMREG1) WORKAREA ADDRESS
         USING UTILWORK,DATAREG
         L     COMMREG,VTABLE          TABLE OF ROUTINE ADDRESSES
         USING VECTABLE,COMMREG
         SPACE 2
*   INDICATE BUFFER MODIFIED AND DECREMENT THE RECORD COUNT
         L     WORK6,WORD2(PARMREG1)   BUFFER ADDRESS
         USING BUFFER,WORK6
         L     WORK7,BUFBLOCK          BLOCK ADDRESS
         USING DATA,WORK7              BLOCK ADDRESSABILITY
         OI    BUFSTATS,UPDATED        INDICATE MODIFICATION TO BUFFER
         LH    WORK4,NUMREC            NUMBER OF RECORDS IN BLOCK
         BCTR  WORK4,ZERO              REDUCE RECORD COUNT BY ONE
         LTR   WORK4,WORK4             THIS AN EMPTY BLOCK NOW
         BNP   DL3                     YES-GO PUT IN EMPTY BLOCK QUEUE
         STH   WORK4,NUMREC            SAVE NEW RECORD COUNT
         SPACE 2
*   OBTAIN CONTENTS OF LOCATOR AND LENGTH OF RECORD
         SLA   WORK4,ONE               DOUBLE FOR INCREMENT TO LAST
         LA    PARMREG0,LOCATORS(WORK4) ADDRESS OF LAST LOCATOR
         L     WORK4,BUFREF            RECORD LOCATOR ADDRESS
         LH    WORK2,X0(WORK4)         CONTENTS OF LOCATOR
         LA    WORK5,DATA(WORK2)       RECORD ADDRESS
         MVC   TEMP1(L2),KEYL(WORK5)   LENGTH OF RECORD
         LH    WORK3,TEMP1             LENGTH OF RECORD
         LA    WORK3,KEYL(WORK3)       ACCOUNT FOR KEY LENGTH
         SPACE 2
*   IS THIS THE FIRST PHYSICAL RECORD
         CH    WORK2,DATASTRT          CHECK FOR FIRST PHYSICAL RECORD
         BE    DL4                     YES
         AH    WORK3,RECVSP            OLD USABLE SPACE PLUS NEW
         STH   WORK3,RECVSP            SAVE FOR FUTURE USE
         B     DL1                     GO CHECK IF LAST LOGICAL
         SPACE 2
*   IS THIS THE LAST LOGICAL RECORD
DL4      AH    WORK3,DATASTRT          OFFSET TO 1ST RECORD PLUS LENGTH
         STH   WORK3,DATASTRT            OF DELETED RECORD
DL1      SR    PARMREG0,WORK4          IS DELETED LOCATOR THE LAST
         BZ    DL9                     YES-MUST CHECK DIRECTORY
*                                      NO--REGISTER (PARMREG0) NOW
*                                      CONTAINS THE NO. OF BYTES TO
*                                      MOVE THE LOCATORS
         SPACE 2
*   ADJUST LOCATORS TO FILL EMPTY POSITION
         ST    WORK4,TEMP2             DELETED LOCATOR/MOVE-TO ADDRESS
         LA    WORK4,LOCL(WORK4)       ADDRESS OF NEXT LOCATOR
         ST    WORK4,TEMP1             MOVE FROM ADDRESS
         LA    PARMREG1,TEMP1          PARM LIST ADDRESS
         L     ENTRY,MV                ENTRY POINT ADDRESS
         CALL  (15)                    MOVE THE LOCATORS DOWN
         SPACE 2
*   SET RETURN CODE AND EXIT HERE
DL2      SR    RETCDREG,RETCDREG       SET RETURN CODE = 0.
         L     WORK4,DCBRECNO          GET PREVIOUS RECORD COUNT
         BCTR  WORK4,ZERO              LOWER RECORD COUNT BY ONE
         ST    WORK4,DCBRECNO          STORE NEW COUNT
DL15     EQU   *                       LEAVE RETURN CODE AS IS
DL7      L     SAVEREG,WORD2(SAVEREG)  OLD SAVE AREA
         RETURN (14,12),T,RC=(15)      RESTORE THE REGISTERS
         SPACE 2
*   PUT DATA BLOCKS IN THE EMPTY BLOCK QUEUE HERE
DL3      MVC   EBTTR(L4),DCBEBQX       PREVIOUS EB TTR IF ANY, ELSE 0
         MVC   DCBEBQX(L4),BUFTTR      THIS NEW EB TTR FIRST IN CHAIN
         L     ENTRY,WB                ENTRY POINT ADDRESS
         CALL  (15)                    WRITE OUT THE EMPTY BLOCK
         LTR   RETCDREG,RETCDREG       ANY ERRORS
         BNZ   DL15                    YES-RETURN
         SPACE 2
*   WAIT FOR THE I/O TO COMPLETE HERE
         L     ENTRY,WA                ENTRY POINT
         CALL  (15)                    WAIT FOR I/O
         LTR   RETCDREG,RETCDREG       ANY ERRORS
         BNZ   DL15                    YES-RETURN
         SPACE 2
*   NEED TO UPDATE DIRECTORY VIA AN ENTRY REMOVAL
         LA    WORK3,PRIMEKEY          KEY ADDRESS
         ST    WORK3,PARM2             TO PARM LIST
         ST    DATAREG,PARM1           WORKAREA ADDRESS
         MVC   PARM3,BUFTTR            TTR TO LIST
         LA    PARMREG1,PARM1          PARM LIST ADDR.
         MVI   DIRCODE(PARMREG1),DELKEY DELETE OPTION
         L     ENTRY,DU                ROUTINE ADDRESS
         CALL  (15)                    UPDATE DIRECTORY
         B     DL2                     RETURN
         SPACE 2
*   SAVE KEY NEW-LAST RECORD
DL9      BCTR  WORK4,ZERO              DECREMENT TO PREVIOUS LOCATOR
         BCTR  WORK4,ZERO              ADDRESS OF NEW LAST LOCATOR
         LH    WORK2,X0(WORK4)         CONTENTS OF THAT LOCATOR
         LA    WORK2,DATA(WORK2)       ADDRESS OF RECORD
         ST    WORK2,PARM2             KEY ADDR. TO LIST
         MVC   PARM3,BUFTTR            TTR TO LIST
         ST    DATAREG,PARM1           WORKAREA ADDR.
         LA    PARMREG1,PARM1          PARM LIST ADDR.
         MVI   DIRCODE(PARMREG1),NEWKEY KEY ONLY OPTION
         L     ENTRY,DU                ROUTINE ADDRESS
         CALL  (15)                    UPDATE DIRECTORY
         B     DL2                     RETURN
         SPACE 2
         DROP  BASEREG,COMMREG,DATAREG,WORK6,WORK7
         TITLE 'EDIT COMMAND ACCESS METHOD -RECORD DELETE ---IKJEBEDR'
***********************************************************************
*                                                                     *
*STATUS -- VERSION NO. 02, VS2     RELEASE NO. 03                     *
*                                                                     *
*FUNCTION --  THIS ROUTINE IS USED TO DELETE THE CURRENT              *
*   REFERENCE RECORD.  IF A KEY IS SPECIFIED ON INPUT, IT REPLACES    *
*   THE REFERENCE (PRIMEKEY) BEFORE THE OPERATION TAKES PLACE. THE    *
*   RECORD LOCATING ROUTINE, IKJEBELO, IS USED TO FIND THE RECORD     *
*   AND IF IT EXISTS THE RECORD IS REMOVED FROM THE DATA SET BY THE   *
*   RECORD REMOVAL ROUTINE, IKJEBEDL.                                 *
*        IN THE EVENT THE RECORD DOES NOT EXIST OR AN ERROR IS        *
*   ENCOUNTERED, THE CURRENT REFERENCE FIELD (PRIMEKEY) IS RESET      *
*   TO ITS ORIGINAL VALUE.                                            *
*                                                                     *
*ENTRY POINT --  IKJEBEDR VIA A CALL FROM IKJEBEUT.                   *
*                                                                     *
*INPUT --  REGISTER 1 CONTAINS THE ADDRESS OF THE WORKAREA//DCB.      *
*          REGISTER 0 OPTIONALLY POINTS TO A KEY VALUE                *
*                                                                     *
*OUTPUT --  THE SPECIFIED RECORD HAS BEEN DELETED FROM THE DATA SET   *
*  OR A RETURN CODE IS PASSED BACK IF IT DOES NOT EXIST.              *
*   THE REGISTERS ARE DESCRIBED UNDER 'EXIT' BELOW.                   *
*                                                                     *
*EXTERNAL REFERENCES --                                               *
*       IKJEBELO             -FINDS THE SPECIFIED RECORD              *
*       IKJEBEDL             -DELETES THE SPECIFIED RECORD            *
*                                                                     *
*EXITS,NORMAL --   RETURNS TO THE CALLING ROUTINE.                    *
*       RETURN CODE = 0      -RECORD EXISTS, OUTPUT AS ABOVE.         *
*       RETURN CODE = 4      -RECORD DOES NOT EXIST.                  *
*                                                                     *
*EXITS,ERROR --    RETURNS TO THE CALLING ROUTINE.                    *
*       RETURN CODE = 12     -I/O ERROR                               *
*                                                                     *
*TABLES/WORKAREAS --                                                  *
*       DEPENDENT ON THE WORKAREA DESCRIPTION 'UTILWORK'.             *
*       DEPENDENT ON THE VECTOR TABLE, 'VECTABLE', FOR EXTERNAL       *
*         REFERENCES                                                  *
*                                                                     *
*ATTRIBUTES --  REFRESHABLE, NON-PRIVILEGED, ENABLED                  *
*                                                                     *
*NOTES  --  REGISTER CONVENTIONS ARE AS FOLLOWS                       *
*       BASEREG              -BASE REGISTER                           *
*       DATAREG              -WORK AREA ADDRESSING                    *
*       COMMREG              -VECTOR TABLE ADDRESSING                 *
*       WORK3,WORK6          -WORK REGISTERS                          *
*                                                                     *
*   THIS ROUTINE IS CHARACTER CODE INDEPENDENT                        *
*                                                                     *
***********************************************************************
         EJECT
IKJEBEDR CSECT
*   PERFORM THE INITIALIZATION OPERATIONS HERE
         SAVE  (14,12),T,*
         LR    BASEREG,ENTRY           ENTRY POINT ADDRESS
         USING IKJEBEDR,BASEREG
         LR    DATAREG,PARMREG1        WORK AREA ADDRESS
         USING UTILWORK,DATAREG
         L     COMMREG,VTABLE          TABLE OF ROUTINE ADDRESSES
         USING VECTABLE,COMMREG
         LA    WORK6,SAVEAREA          NEW SAVE AREA
         ST    SAVEREG,WORD2(WORK6)    OLD ADDRESS TO NEW
         ST    WORK6,WORD3(SAVEREG)    NEW ADDRESS TO OLD
         LR    SAVEREG,WORK6           NEW SAVE AREA
         SPACE 2
*   HANDLE ANY INPUT KEY HERE
         MVC   SAVEKEY(KEYL),PRIMEKEY  SAVE OLD KEY
         LR    WORK3,PARMREG0          KEY ADDRESS, IF ANY.
         LA    WORK3,ZERO(WORK3)       CLEAR HIGH ORDER BYTE
         LTR   WORK3,WORK3             IS THERE A KEY SPECIFIED
         BZ    DR1                     NO--GO FIND OLD REFERENCE
         MVC   PRIMEKEY(KEYL),X0(WORK3) MOVE IN NEW KEY
         SPACE 2
*   FIND THE SPECIFIED RECORD
DR1      LA    PARMREG1,PARM1          PARAMETER LIST ADDRESS
         LA    DATAREG,X0(DATAREG)     SET OPTION CODE=0
         ST    DATAREG,PARM1           PARM LIST FOR LOCATE
         L     ENTRY,LO                ENTRY POINT ADDRESS
         CALL  (15)                    FIND THE RECORD
         LTR   RETCDREG,RETCDREG       DOES THE RECORD EXIST
         BZ    DR2                     YES-GO DELETE IT.
         SPACE 2
*   ENTER HERE FOR ERRORS OR RECORD DOES NOT EXIST
DR70     MVC   PRIMEKEY(KEYL),SAVEKEY  RESET REFERENCE KEY
DR7      TM    DCBSTATS,ERROR          ANY I/O ERRORS
         BO    DR5                     YES-RETURN
         LA    RETCDREG,NRF            RETURN CODE FOR NO RECORD
         SPACE 2
*   FINAL HOUSEKEEPING AND RETURN HERE
DR5      EQU   *                       RETURN ON ERROR HERE
DR50     L     SAVEREG,WORD2(SAVEREG)  OLD SAVE AREA ADDRESS
         RETURN (14,12),T,RC=(15)      RESTORE THE REGISTERS
         SPACE 2
*   IF THE RECORD EXISTS, USE THE RECORD REMOVAL ROUTINE
DR2      L     ENTRY,DL                ENTRY POINT ADDRESS
         CALL  (15)                    DELETE THE RECORD
         LTR   RETCDREG,RETCDREG       ANY ERRORS
         BZ    DR50                    NO-RETURN TO CALLER
         CH    RETCDREG,DREMPTY        IS THE DATA SET NOW EMPTY
         BNE   DR70                    NO-GO CHECK ERROR CONDITIONS
         SR    RETCDREG,RETCDREG       SET RETURN CODE = 0
         B     DR50                    RETURN
         SPACE
         DROP  BASEREG,COMMREG,DATAREG
         SPACE
*   CONSTANT AREA FOR RECORD DELETE ROUTINE
DREMPTY  DC    H'8'                    RETURN CODE FOR EMPTY DATA SET
         TITLE 'EDIT COMMAND ACCESS METHOD -DIRECTORY SEARCH -IKJEBEDS'
***********************************************************************
*                                                                     *
*STATUS -- VERSION NO. 02, VS2     RELEASE NO. 03                     *
*                                                                     *
*FUNCTION --  THIS ROUTINE ATTEMPTS TO LOCATE A DIRECTORY INDEX       *
*   ENTRY GIVEN AN INPUT KEY VALUE.
*        IF THE 'BEGIN' OR 'END' OPTIONS ARE SPECIFIED, THIS ROUTINE  *
*   WILL LOCATE THE FIRST OR LAST ENTRY RESPECTIVELY. ANYTIME THE     *
*   CORRECT ENTRY IS FOUND, THE 'DBUFREF' FIELD WILL
*   CONTAIN THE ADDRESS OF THE PROPER INDEX ENTRY AND A RETURN CODE   *
*   OF 0 IS PASSED BACK.                                              *
*        IF THE INPUT KEY DOES NOT FALL WITHIN THE DIRECTORY LIMITS,  *
*   A RETURN CODE OF 4 IS PASSED BACK.  A RETURN CODE OF 8 INDICATES  *
*   AN EMPTY DATA SET. IN BOTH OF THESE CASES, THE 'DBUFREF'
*   FIELD WILL POINT TO THE NEXT AVAILABLE INDEX ENTRY SLOT.
*                                                                     *
*ENTRY POINT --                                                       *
*       IKJEBEDS   VIA A CALL FROM IKJEBEDL(2), IKJEBEDU, IKJEBELO    *
*                                                                     *
*INPUT --  REGISTER 1 POINTS TO A TWO WORD PARAMETER LIST-            *
*       WORD1-   HIGH ORDER BYTE CONTAINS THE OPTION CODE             *
*                THREE LOW ORDER BYTES = ADDRESS OF WORKAREA          *
*       WORD2-   POINTS TO THE DESIRED KEY VALUE                      *
*                                                                     *
*OUTPUT --  WORD2 OF THE INPUT PARAMETER LIST WILL CONTAIN THE        *
*   ADDRESS OF THE LOCATED INDEX BUFFER.  THE BUFREF FIELD WILL       *
*   THEN POINT TO THE FOUND ENTRY OR THE NEXT AVAILABLE ENTRY         *
*   DEPENDING ON THE RETURN CODE. SEE 'EXIT' BELOW.                   *
*                                                                     *
*EXTERNAL REFERENCES --                                               *
*   NONE
*                                                                     *
*EXITS,NORMAL --                                                      *
*       -ENTRY FOUND-   WORD2 OF THE INPUT LIST CONTAINS THE          *
*          SELECTED BUFFER ADDRESS.  RETURN CODE = 0.                 *
*       -DATA SET EMPTY-  WORD2 OF THE INPUT LIST CONTAINS THE        *
*          ADDRESS OF THE BUFFER WITH THE NEXT AVAILABLE SLOT.        *
*          RETURN CODE = 8.                                           *
*       -ENTRY NOT FOUND-  WORD2 OF THE INPUT LIST CONTAINS THE       *
*          ADDRESS OF THE BUFFER WITH THE NEXT AVAILABLE SLOT.        *
*          RETURN CODE = 4.                                           *
*                                                                     *
*EXITS,ERROR --
*       NONE
*                                                                     *
*TABLES/WORK AREAS --                                                 *
*       DEPENDENT ON THE VECTOR TABLE FOR CALL TO EXTERNAL ROUTINES   *
*       DEPENDENT ON THE BUFFER DESCRIPTION DSECT FOR DIRECTORY       *
*         BLOCK FORMAT                                                *
*                                                                     *
*ATTRIBUTES -- REFRESHABLE, ENABLED, NON-PRIVILEGED                   *
*                                                                     *
*NOTES --  REGISTER CONVENTIONS ARE AS FOLLOWS-                       *
*       BASEREG              -BASE REGISTER                           *
*       DATAREG              -WORK AREA ADDRESSING                    *
*       COMMREG              -VECTOR TABLE ADDRESSING                 *
*       WORK6                -DIRECTORY BLOCK BUFFER ADDRESSING       *
*       WORK7                -BLOCK ADDRESSING
*       WORK2                -RETAIN INPUT PARM LIST POINTER          *
*       WORK3,WORK4,WORK5    -WORK REGISTERS                          *
*                                                                     *
*   THIS ROUTINE IS CHARACTER CODE INDEPENDENT                        *
*                                                                     *
***********************************************************************
         SPACE 2
IKJEBEDS CSECT                         DIRECTORY SEARCH ROUTINE
*   PERFORM THE INITIALIZATION OPERATIONS HERE
         SAVE  (14,12),T,*             SAVE THE REGISTERS
         LA    SAVEREG,SAVEL(SAVEREG)  NEXT SAVE AREA
         LR    BASEREG,ENTRY           ENTRY POINT ADDRESS
         USING IKJEBEDS,BASEREG        ADDRESSABILITY
         L     DATAREG,WORD1(PARMREG1) WORKAREA
         USING UTILWORK,DATAREG        ADDRESSABILITY
         SPACE 2
*   SAVE INPUT PARMS AND CHECK FOR EMPTY DATA SET
         L     WORK2,WORD2(PARMREG1)   KEY VALUE POINTER
         MVC   TEMP3(KEYL),X0(WORK2)   INPUT KEY VALUE
         L     WORK7,DBUFBLCK          BLOCK ADDRESS
         USING DATA,WORK7              ADDRESSABILITY
         OC    NUMINDEX,NUMINDEX       IS DSDB EMPTY
         BZ    DS170                   YES-EXIT
         SPACE 2
*   DETERMINE THE INPUT OPTION HERE
         CLI   X0(PARMREG1),B          1ST ENTRY OPTION
         BE    DS80                    YES-GO PROCESS
         CLI   X0(PARMREG1),E          LAST ENTRY OPTION
         BE    DS100                   YES-GO PROCESS
         CLI   X0(PARMREG1),P          PREVIOUS ENTRY OPTION
         BE    DS120                   YES-GO PROCESS
         CLI   X0(PARMREG1),N          NEXT ENTRY OPTION
         BE    DS130                   YES-GO PROCESS
         SPACE 2
*   PROCESS THE 'CURRENT' (SPECIFIED) OPTION HERE
DS60     BAL   LINK9,DS500             GET LAST ENTRY
         CLC   TEMP3(KEYL),X0(WORK5)   WITHIN LIMITS?
         BH    DS180                   NO-ENTRY NOT FOUND
DS70     LH    WORK2,NUMINDEX          NO. OF ENTRIES
         CH    WORK2,DSENT             BELOW THRESHOLD
         BL    DS62                    YES-DO SERIAL SEARCH
         SPACE 2
*   INITIALIZE FOR THE BINARY SEARCH HERE
*        REGISTER USAGE
*              WORK2     NO. OF ENTRIES IN LOWER HALF
*              WORK3     NO. OF ENTRIES IN UPPER HALF
*              WORK4     LOW BOUNDARY ADDRESS
*              WORK5     HIGH BOUNDARY ADDRESS
*              WORK6     MIDPOINT COMPARISON ADDRESS
DS72     LA    WORK4,INDICES           SET LOW PTR. TO FIRST
         SPACE 2
*   COMPUTE NO. OF ENTRIES IN EACH HALF
DS74     LR    WORK3,WORK2             NO. OF ENTRIES TO CHECK
         LA    WORK3,ONE(WORK3)        PLUS ONE
         SRL   WORK3,ONE               (N+1)/2=UPPER
         SR    WORK2,WORK3             LOWER=TOTAL-UPPER
         SPACE 2
*   COMPUTE THE POINT TO MAKE THE COMPARISON
DS76     LR    PARMREG1,WORK2          #LOWER ENTRIES
         BCTR  PARMREG1,ZERO           LESS ONE
         LA    WORK9,KEYL+TTR          SIZE OF EACH ENTRY
         MR    WORK8,PARMREG1          OFFSET TO START TEST
         LA    WORK6,ZERO(WORK9,WORK4) COMPARE ADDR=LOW+OFFSET
         SPACE 2
*   COMPARE INPUT KEY VERSUS SELECTED ENTRY KEY
         CLC   TEMP3(KEYL),ZERO(WORK6) INPUT KEY VS. MIDPOINT
         BH    DS77                    BRANCH- HIGHER
         SPACE 2
*   IMPUT KEY IS LOW OR EQUAL
         CH    WORK2,DSONE             ONE ENTRY LEFT
         LR    WORK5,WORK6             NEW HIGH OR FOUND ENTRY
         BNE   DS74                    BRANCH-MORE TO CHECK
         B     DS190                   ENTRY FOUND
         SPACE 2
*   INPUT KEY IS GREATER
DS77     CH    WORK3,DSONE             ONE ENTRY LEFT
         BNE   DS78                    NO-BRANCH/CHECK MORE
         LA    WORK5,KEYL+TTR(WORK6)   SELECTED ENTRY ADDR.
         B     DS190                   FOUND ENTRY -EXIT
         SPACE 2
*   DO SEARCH ON UPPER HALF
DS78     LR    WORK2,WORK3             # ENTRIES TO CHECK
         LA    WORK4,KEYL+TTR(WORK6)   NEW LOW ADDRESS
         B     DS74                    REPEAT THE SEARCH
         SPACE 2
*   DO A SERIAL SEARCH HERE
DS62     LA    WORK5,INDICES           1ST ENTRY ADDRESS
DS64     CLC   TEMP3(KEYL),X0(WORK5)   CORRECT ENTRY
         BNH   DS190                   YES-EXIT
         LA    WORK5,KEYL+TTR(WORK5)   NEXT ENTRY ADDRESS
         B     DS64                    REPEAT UNTIL FOUND
         SPACE 2
*   PROCESS THE 'BEGIN' (FIRST) OPTION HERE
DS80     LA    WORK5,INDICES           FIRST ENTRY ADDRESS
         B     DS190                   EXIT
         SPACE 2
*   PROCESS THE 'END' (LAST) OPTION HERE
DS100    BAL   LINK9,DS500             LOCATE LAST ENTRY
         B     DS190                   EXIT
         SPACE 2
*   PROCESS THE 'PREVIOUS' OPTION HERE
DS120    BAL   LINK9,DS500             FIND LAST ENTRY
         OC    TEMP3(KEYL),TEMP3       SPECIFIED KEY=0
         BZ    DS180                   YES-ENTRY NOT FOUND
         CLC   TEMP3(KEYL),X0(WORK5)   KEY VS. ENTRY VALUE
         BH    DS190                   USE LAST ENTRY VALUE
DS124    LA    WORK5,INDICES           1ST ENTRY ADDRESS
         LA    WORK3,ONE               CONSTANT OF ONE
DS128    CLC   TEMP3(KEYL),X0(WORK5)   KEY VS. ENTRY VALUE
         BNH   DS190                   ENTRY FOUND
         MVC   TEMP1(KEYL),X0(WORK5)   ALIGNMENT
         L     WORK4,TEMP3             INPUT KEY VALUE
         S     WORK4,TEMP1             DIFFERENCE
         CLR   WORK4,WORK3             IS DIFFERENCE ONE
         BE    DS190                   BRANCH-ENTRY FOUND
         LA    WORK5,KEYL+TTR(WORK5)   NEXT ENTRY ADDRESS
         B     DS128                   REPEAT UNTIL FOUND
         SPACE 2
*   PROCESS THE 'NEXT' OPTION HERE --- FAST PATH
DS130    L     WORK5,DBUFREF           LAST ENTRY ADDRESS
         CLC   TEMP3(KEYL),X0(WORK5)   INPUT KEY VS LAST
         BNL   DS135                   NOT CORRECT,CHECK FURTHER
         LR    WORK6,WORK5             SAVE CURRENT
         LA    WORK3,INDICES           1ST ENTRY ADDRESS
         CR    WORK6,WORK3             AT 1ST ENTRY NOW
         BNH   DS190                   YES-USE THIS
         SH    WORK6,DSDIRSIZ          PREVIOUS ENTRY
         CLC   TEMP3(KEYL),X0(WORK6)   KEY VS.PREVIOUS
         BL    DS140                   TOO LOW-DO SEARCH
         B     DS190                   O.K.-USE ENTRY
DS135    LA    WORK6,KEYL+TTR(WORK5)   NEXT ENTRY ADDRESS
         BAL   LINK9,DS500             LAST ENTRY ADDRESS
         CR    WORK6,WORK5             BEYOND LIMITS NOW?
         BH    DS180                   YES-ENTRY NOT FOUND
         LR    WORK5,WORK6             NEXT ENTRY ADDRESS
         CLC   TEMP3(KEYL),X0(WORK5)   KEY VS. NEXT
         BL    DS190                   BRANCH-FOUND ENTRY
         SPACE 2
*   PROCESS THE 'NEXT' OPTION HERE --- SLOW PATH
DS140    BAL   LINK9,DS500             FIND LAST ENTRY
         CLC   TEMP3(KEYL),X0(WORK5)   BEYOND LIMITS?
         BNL   DS180                   ENTRY NOT FOUND
         LR    WORK4,WORK5             LAST ENTRY ADDRESS
         LA    WORK3,INDICES           1ST ENTRY ADDRESS
DS144    SH    WORK4,DSDIRSIZ          PREVIOUS ENTRY ADDR.
         CLC   TEMP3(KEYL),X0(WORK4)   KEY GREATER PREVIOUS
         BNL   DS190                   YES-ENTRY FOUND
         CR    WORK3,WORK4             AT 1ST ENTRY
         BNL   DS148                   YES-USE FIRST ENTRY
         LR    WORK5,WORK4             LAST CHECKED/NEXT PASS
         B     DS144                   REPEAT UNTIL FOUND
DS148    LA    WORK5,INDICES           FIRST ENTRY ADDRESS
         B     DS190                   EXIT
         SPACE 2
*   DATA SET IS EMPTY
DS170    LA    WORK5,INDICES           1ST ENTRY ADDRESS
         LA    RETCDREG,EMPTY          SET RETURN CODE
         B     DS200                   GO TO EXIT CODE
         SPACE 2
*   ENTRY WAS NOT FOUND
DS180    LA    RETCDREG,NRF            SET RETURN CODE
         B     DS200                   GO TO EXIT CODE
         SPACE 2
*   NORMAL EXIT HERE
DS190    SR    RETCDREG,RETCDREG       SET RETURN CODE
         SPACE 2
*   ALL EXITS THRU HERE
DS200    ST    WORK5,DBUFREF           SELECTED ENTRY
         SPACE 2
*   ALL EXITS THRU HERE
DS210    L     SAVEREG,WORD2(SAVEREG)  OLD SAVE AREA
         RETURN (14,12),T,RC=(15)      RESTORE THE REGISTERS
         SPACE 2
*   FIND ADDRESS OF LAST ENTRY IN DIRECTORY BLOCK
DS500    LH    WORK3,NUMINDEX          NO. OF ENTRIES
         LA    WORK5,KEYL+TTR          SIZE OF EACH ENTRY
         BCTR  WORK3,ZERO              NUMBER LESS ONE
         MR    WORK4,WORK3             NO. TIMES SIZE
         LA    WORK5,INDICES(WORK5)    LAST ENTRY ADDRESS
         BR    LINK9                   RETURN
         SPACE 2
         DROP  BASEREG,DATAREG,WORK7   RELEASE
         SPACE 2
*   CONSTANT AREA FOR IKJEBEDS
DSONE    DC    H'1'                    CONSTANT OF ONE
DSENT    DC    H'20'                   COMPARE THRESHOLD
DSDIRSIZ DC    H'7'                    LENGTH PER DIRECTORY ENTRY
 TITLE 'EDIT COMMAND ACCESS METHOD  -DIRECTORY UPDATE --- IKJEBEDU'
***********************************************************************
*                                                                     *
*STATUS -- VERSION NO. 02, VS2     RELEASE NO. 03                     *
*                                                                     *
*FUNCTION --  THIS ROUTINE PERFORMS THE FUNCTION OF UPDATING THE      *
*   DIRECTORY BLOCK(S) WHENEVER A NEW RECORD IS ADDED TO THE DATA     *
*   SET SUCH THAT IS AFFECTS THE INDICES.  THIS MAY INVOLVE           *
*   CREATING A NEW ENTRY OR MODIFYING AN EXISTING ONE.                *
*       THERE ARE THREE BASIC TYPES OF DIRECTORY OPERATIONS
*   AND THEY ARE INDICATED BY AN ENTRY CODE.  THEY ARE
*   AS FOLLOWS:
*
*       1.  A NEW ENTRY IS TO BE ADDED TO THE DIRECTORY.
*           IF THERE IS INSUFFICIENT SPACE, THE CURRENT
*           DIRECTORY SIZE IS INCREMENTED BY THE BLOCKSIZE
*           OF THE UTILITY DATA SET.  THIS INVOLVES GETTING
*           A LARGER CORE AREA, MOVING THE OLD DIRECTORY TO
*           THE NEW AREA, AND RELEASING THE OLD SPACE.
*
*       2.  AN ENTRY IS TO BE DELETED FROM THE DIRECTORY.
*           THIS INVOLVES REPOSITIONING THE OTHER ENTRIES
*           OR RECOGNIZING THAT THE DATA SET IS EMPTY.
*
*       3.  MODIFICATION OF A CURRENT ENTRY.  THIS MEANS
*           A GIVEN ENTRY IS TO HAVE A NEW KEY VALUE
*           ASSOCIATED WITH IT.
*
*                                                                     *
*ENTRY POINT --  AT IKJEBEDU VIA A CALL FROM IKJEBEWR                 *
*                                                                     *
*INPUT --  REGISTER ONE POINTS TO A THREE WORD PARAMETER LIST         *
*       WORD1-  ADDRESS OF THE WORKAREA                               *
*       WORD2-  ADDRESS OF THE NEW KEY VALUE                          *
*       WORD3-  TTR OF NEW BLOCK ENTRY AND OPTION CODE
*               AS FOLLOWS:
*                 DELKEY(00)  DELETE ENTRY
*                 NEWKEY(01)  ADD ENTRY
*                 ALLKEY(FF)  MODIFY ENTRY
*                                                                     *
*OUTPUT -- THE NEW INPUT INDEX ENTRY (KEY+TTR) IS ADDED TO THE        *
*                                                                     *
*EXTERNAL REFERENCES --                                               *
*       IKJEBEDS             -SEARCHES THE DIRECTORY                  *
*       IKJEBEMV            -MOVES ENTRIES
*       GETMAIN             -GETS A LARGER BUFFER
*       FREEMAIN            -RELEASES OLD BUFFER
*                                                                     *
*EXITS,NORMAL -- RETURNS TO CALLING ROUTINE WITH A RETURN CODE        *
*   OF ZERO.  OUTPUT AS ABOVE.                                        *
*                                                                     *
*EXITS,ERROR -- RETURNS TO CALLING ROUTINE -                   @ZA12679
*       RETURN CODE = 12 I/O ERROR ENCOUNTERED.                @ZA12679
*                                                                     *
*TABLES/WORKAREAS --                                                  *
*       DEPENDENT ON VECTOR TABLE FOR CALLS TO EXTERNAL ROUTINES      *
*       DEPENDENT ON BUFFER DESCRIPTION OF DIRECTORY BLOCKS           *
*                                                                     *
*ATTRIBUTES -- REFRESHABLE, ENABLED, NON-PRIVILEGED                   *
*                                                                     *
*NOTES --  THE REGISTER CONVENTIONS ARE AS FOLLOWS-                   *
*       BASEREG              -BASE REGISTER                           *
*       DATAREG              -WORK AREA ADDRESSING                    *
*       COMMREG              -VECTOR TABLE ADDRESSING                 *
*       WORK7                -NEW DIRECTORY BLOCK ADDRESSING          *
*       WORK2,WORK3          -WORK REGISTERS                          *
*       WORK5,WORK8          -WORK REGISTERS                          *
*                                                                     *
*   THIS ROUTINE IS CHARACTER CODE INDEPENDENT                        *
*                                                                     *
***********************************************************************
         SPACE 2
IKJEBEDU CSECT                         DIRECTORY UPDATE ROUTINE
*   PERFORM THE INITIALIZATION OPERATIONS HER
         SAVE  (14,12),T,*             SAVE THE REGISTERS
         LA    SAVEREG,SAVEL(SAVEREG)  NEXT SAVE AREA
         LR    BASEREG,ENTRY           ENTRY POINT ADDRESS
         USING IKJEBEDU,BASEREG        ADDRESSABILITY
         L     DATAREG,WORD1(PARMREG1) WORKAREA ADDRESS
         USING UTILWORK,DATAREG        ADDRESSABILITY
         L     COMMREG,VTABLE          ROUTINE ADDRESSES
         USING VECTABLE,COMMREG        ADDRESSABILITY
         SPACE 2
*   SAVE THE INPUT PARAMETERS
         L     WORK2,WORD2(PARMREG1)   ADDRESS OF KEY
         MVC   TEMP1(KEYL),X0(WORK2)   SAVE KEY VALUE
         MVC   TEMP2(TTR),WORD3(PARMREG1) SAVE TTR VALUE
         L     WORK7,DBUFBLCK          BLOCK ADDRESS
         USING DATA,WORK7              ADDRESSABILITY
         SPACE 2
*   DETERMINE THE TYPE OF UPDATE HERE
         CLI   DIRCODE(PARMREG1),DELKEY DELETE OPTION?
         BE    DU300                   YES-GO PROCESS
         CLI   DIRCODE(PARMREG1),NEWKEY KEY ONLY UPDATE?
         BE    DU200                   YES-GO PROCESS
         SPACE 2
*   PROCESS AS ENTIRE NEW ENTRY HERE
DU50     LH    WORK3,NUMINDEX          NO. OF ENTRIES
         LA    WORK5,KEYL+TTR          SIZE OF EACH
         LR    WORK8,WORK5             SAVE SIZE
         MR    WORK4,WORK3             ENTRIES TIME SIZE
         LA    WORK5,INDICES(WORK5)    NEXT AVAILABLE SLOT
         SR    WORK4,WORK4             CLEAR WORKREG           @ZA12679
         ICM   WORK4,X3,DSDBSIZE       BLOCK SIZE              @ZA12679
         SH    WORK4,DUDIRSIZ          SIZE OF NEW ENTRY
         LA    WORK4,DATA(WORK4)       LAST POSSIBLE START
         CLR   WORK5,WORK4             IS THERE SPACE
         BH    DU90                    NO--GO GET NEW BLOCK
         SPACE 2
*   FIND CORRECT SLOT BY USING DIRECTORY SEARCH
DU60     LA    WORK4,TEMP1             ADDRESS OF NEW KEY
         ST    WORK4,PARM2             TO PARM LIST
         LA    PARMREG1,PARM1          PARM LIST ADDRESS
         L     ENTRY,DS                ROUTINE ADDRESS
         CALL  (15)                    FIND CORRECT POSITION
         LA    WORK4,EMPTY             EMPTY RETURN CODE
         CR    WORK4,RETCDREG          IS DATA SET EMPTY
         BE    DU76                    YES-GO MOVE IN ENTRY
         SPACE 2
*   NEED TO MOVE THE ENTRIES DOWN
         LA    WORK4,INDICES           1ST ENTRY ADDRESS
DU70     CLR   WORK5,WORK4             AT 1ST ENTRY
         BE    DU76                    YES-GO USE
         SR    WORK5,WORK8             PREVIOUS ENTRY
         CLC   TEMP1(KEYL),X0(WORK5)   CORRECT SLOT
         BH    DU75                    YES-GO USE
         MVC   KEYL+TTR(KEYL+TTR,WORK5),X0(WORK5) MOVE DOWN
         B     DU70                    GO FIND SLOT
         SPACE 2
*   SET UP THE NEW ENTRY HERE
DU75     LA    WORK5,KEYL+TTR(WORK5)   SET TO AVAILABLE SLOT
DU76     MVC   KEYL(TTR,WORK5),TEMP2   NEW TTR VALUE
         MVC   X0(KEYL,WORK5),TEMP1    NEW KEY VALUE
DU80     LH    WORK4,NUMINDEX          NO. OF ENTRIES
         LA    WORK4,ONE(WORK4)        PLUS ONE
         STH   WORK4,NUMINDEX          NEW TOTAL
         B     DU400                   GO EXIT
         SPACE 2
*   GET A LARGER DIRECTORY HERE
DU90     TM    DSDBSIZE,MAXDSI      MAX DIRECTORY SIZE?        @ZA12679
         BO    DU390                IF SO, RETURN CODE 12      @ZA12679
         SR    WORK3,WORK3          CLEAR WORKREG              @ZA12679
         ICM   WORK3,X3,DSDBSIZE    GET CURRENT SIZE           @ZA12679
         AH    WORK3,DCBBLKSI          INCREMENT BY BLOCKSIZE
         GETMAIN R,LV=(WORK3),SP=SPONE CORE FOR NEW BLOCK
         LR    WORK9,PARMREG1          NEW BLOCK ADDRESS
         SPACE 2
*   MOVE THE CONTENTS OF PREVIOUS DIRECTORY BLOCK TO NEW
         SR    PARMREG0,PARMREG0       CLEAR WORKREG           @ZA12679
         ICM   PARMREG0,X3,DSDBSIZE    NO. OF BYTES TO MOVE    @ZA12679
         ST    WORK9,TEMPWRD2          MOVE-TO ADDRESS
         ST    WORK7,TEMPWRD1          MOVE-FROM ADDRESS
         LA    PARMREG1,TEMPWRD1       PARM LIST ADDRESS
         L     ENTRY,MV                ROUTINE ADDRESS
         CALL  (15)                    MOVE THE ENTRIES
         SPACE 2
*   FREEMAIN THE OLD DIRECTORY BLOCK HERE
         SR    WORK3,WORK3             CLEAR WORKREG           @ZA12679
         ICM   WORK3,X3,DSDBSIZE       GET DIRECTORY SIZE      @ZA12679
         FREEMAIN R,LV=(WORK3),A=(WORK7),SP=SPONE FREE OLD
         SPACE 2
*   SET UP THE CONTROL FIELDS FOR THE NEW BLOCK HERE
         LR    WORK7,WORK9             NEW BLOCK ADDRESS
         ST    WORK7,DBUFBLCK          SAVE ADDRESS
         SR    WORK3,WORK3             CLEAR WORKREG           @ZA12679
         ICM   WORK3,X3,DSDBSIZE       GET DSDBSIZE            @ZA12679
         AH    WORK3,DCBBLKSI          PLUS INCREMENT
         STH   WORK3,DSDBSIZE          SAVE NEW TOTAL SIZE
         B     DU50                    HAVE SPACE//GO PROCESS
         SPACE 2
*   NEED TO UPDATE THE KEY FIELD OF ENTRY ONLY
DU200    LA    WORK5,INDICES           1ST ENTRY ADDRESS
DU204    CLC   KEYL(TTR,WORK5),TEMP2   TTR MATCH
         BE    DU208                   YES-GO PROCESS
         LA    WORK5,KEYL+TTR(WORK5)   NEXT ENTRY
         B     DU204                   REPEAT UNTIL FOUND
DU208    MVC   X0(KEYL,WORK5),TEMP1    NEW KEY VALUE
         B     DU400                   GO EXIT
         SPACE 2
*   NEED TO REMOVE AN ENTRY HERE
DU300    LA    WORK5,INDICES           1ST ENTRY ADDRESS
DU304    CLC   KEYL(TTR,WORK5),TEMP2   TTR MATCH?
         BE    DU308                   YES-ENTRY FOUND
         LA    WORK5,KEYL+TTR(WORK5)   NEXT ENTRY
         B     DU304                   REPEAT UNTIL FOUND
         SPACE 2
*   HAVE FOUND THE ENTRY TO DELETE
DU308    LH    PARMREG1,NUMINDEX       NO. OF ENTRIES
         BCTR  PARMREG1,ZERO           LESS ONE
         STH   PARMREG1,NUMINDEX       NEW TOTAL
         LTR   PARMREG1,PARMREG1       DATA SET EMPTY NOW
         BP    DU312                   NO-PROCEED WITH UPDATE
         OI    DCBSTATS,DSEMPTY        SHOW EMPTY NOW
         SPACE 2
*   UPDATE THE DIRECTORY BLOCK HERE
DU312    LR    PARMREG0,WORK5          ENTRY TO BE DELETED
         LH    WORK2,DUDIRSIZ          SIZE OF ENTRY
         SR    PARMREG0,WORK2          LESS LENGTH
         LA    WORK3,INDICES           1ST ENTRY ADDRESS
         CR    WORK3,PARMREG0          AT 1ST ENTRY NOW
         BNH   DU320                   NO--BRANCH
         LR    PARMREG0,WORK3          SET TO 1ST ENTRY
DU320    ST    PARMREG0,DBUFREF        PREVIOUS ENTRY
         AR    WORK2,WORK5             NEXT ENTRY
         MH    PARMREG1,DUDIRSIZ       ENTRIES-1 TIMES LENGTH
         LA    PARMREG1,INDICES(PARMREG1) LAST ENTRY ADDRESS
         SR    PARMREG1,WORK5          BYTES TO MOVE
         BZ    DU400                   LAST ENTRY/RETURN
         SPACE 2
*   MUST ADJUST THE INDEX ENTRIES HERE
         LR    PARMREG0,PARMREG1       BYTE COUNT
         ST    WORK5,TEMP2             MOVE-TO ADDRESS
         ST    WORK2,TEMP1             MOVE-FROM ADDRESS
         LA    PARMREG1,TEMP1          PARM LIST ADDRESS
         L     ENTRY,MV                ROUTINE ADDRESS
         CALL  (15)                    MOVE ENTRIES DOWN
         SPACE 2
*   EXIT PROCESSING HERE
DU400    SR    RETCDREG,RETCDREG       RETURN CODE=0
DU410    EQU   *                                               @ZA12679
         L     SAVEREG,WORD2(SAVEREG)  OLD SAVE AREA
         RETURN (14,12),T,RC=(15)      RESTORE REGISTERS
DU390    LA    RETCDREG,IOERR         I/O ERROR                @ZA12679
         B        DU410               RETURN                   @ZA12679
         SPACE 2
         DROP  BASEREG,COMMREG,DATAREG,WORK7 RELEASE
         SPACE 2
*   CONSTANTS FOR IKJEBEDU
DUDIRSIZ DC    H'7'                    LENGTH OF EACH INDEX ENTRY
 TITLE 'EDIT COMMAND ACCESS METHOD -RECORD LOCATING-  -IKJEBELO-'
***********************************************************************
*                                                                     *
*STATUS -- VERSION NO. 02, VS     RELEASE NO. 03                      *
*                                                                     *
*FUNCTION --  THIS ROUTINE IS USED TO FIND A SPECIFIC RECORD.         *
*   DEPENDING ON THE OPTION SPECIFIED, THE RECORD MAY BE THE FIRST    *
*   IN THE DATA SET, THE LAST IN THE DATA SET, THE CURRENT            *
*   REFERENCE RECORD, THE FIRST PRIOR TO THE REFERENCE RECORD, OR     *
*   THE NEXT AFTER THE REFERENCE RECORD.  REFERENCE RECORD IS         *
*   DEFINED AS THE RECORD WITH A KEY VALUE EQUAL TO THAT STORED IN    *
*   'PRIMEKEY' OF THE WORKAREA.                                       *
*        IN ALL CASES ABOVE, FINDING THE BLOCK THAT CONTAINS THE      *
*   DESIRED RECORD INVOLVES USING THE DIRECTORY SEARCH ROUTINE,       *
*   IKJEBEDS.  IF THE CORRECT BLOCK EXISTS, IT IS READ IN WITH THE    *
*   READ BLOCK ROUTINE, IKJEBERB. WHEN THE CORRECT RECORD IS LOCATED  *
*   WITHIN THE DATA BLOCK, THE 'BUFREF' FIELD OF THAT BUFFER CONTAINS *
*   THE ADDRESS OF THE LOCATOR FOR THAT RECORD.                       *
*                                                                     *
*ENTRY POINTS -- AT IKJEBELO VIA A CALL FROM IKJEBEDR, IKJEBERR,      *
*   OR IKJEBEWR.                                                      *
*                                                                     *
*INPUT --  REGISTER 1 POINTS TO A 3 WORD PARAMETER LIST.              *
*   WORD1 --CONTAINS A POINTER TO WORKAREA//DCB.                      *
*        HIGH ORDER BYTE CONTAINS AN OPTION CODE AS FOLLOWS-          *
*          X'00'            -FIND CURRENT REFERENCE RECORD            *
*          X'01'            -FIND RECORD PRIOR TO REFERENCE           *
*          X'02'            -FIND RECORD AFTER REFERENCE              *
*          X'04'            -FIND FIRST RECORD IN DATA SET            *
*          X'05'            -FIND LAST RECORD IN DATA SET             *
*                                                                     *
*   WORD2 AND WORD3 -- NOT USED ON INPUT                              *
*                                                                     *
*OUTPUT --  REGISTERS AS DESCRIBED UNDER 'EXIT' BELOW.                *
*   WORD2 OF THE INPUT PARM LIST CONTAINS THE ADDRESS OF THE BUFFER   *
*   FOR THE FOUND RECORD.  THE 'BUFREF' FIELD OF THE BUFFER CONTAINS  *
*   THE ADDRESS OF THE 'LOCATOR' FOR THE FOUND RECORD.  THE 'PRIMEKEY'*
*   FIELD IN THE WORKAREA IS UPDATED WITH THE FOUND RECORD KEY.       *
*                                                                     *
*EXTERNAL REFERENCES --                                               *
*       IKJEBEDS            -FIND THE DESIRED DATA BLOCK              *
*       IKJEBERB            -READ IN THE REQUIRED DATA BLOCK          *
*                                                                     *
*EXITS,NORMAL -- RETURNS TO CALLING ROUTINE WITH A RETURN CODE--      *
*       RETURN CODE = 0     -OUTPUT AS ABOVE,  RECORD FOUND           *
*       RETURN CODE = 4     -NO OUTPUT,        RECORD NOT FOUND       *
*       RETURN CODE = 8     -NO OUTPUT,        EMPTY DATA SET         *
*                                                                     *
*                                                                     *
*EXITS,ERROR --  RETURNS TO THE CALLING ROUTINE.                      *
*       RETURN CODE = 12    -I/O ERROR ENCOUNTERED                    *
*                                                                     *
*TABLES/WORK AREAS --                                                 *
*       DEPENDENT ON THE 'BUFFER' DSECT DESCRIPTION.                  *
*       DEPENDENT ON THE 'UTILWORK' WORKAREA DESCRIPTION              *
*       DEPENDENT ON THE VECTOR TABLE FOR EXTERNAL REFERENCES         *
*                                                                     *
*ATTRIBUTES --  REFRESHABLE, NON-PRIVILEGED, ENABLED                  *
*                                                                     *
*NOTES --  THE REGISTER CONVENTIONS ARE AS FOLLOWS                    *
*       BASEREG                   -BASE REGISTER                      *
*       DATAREG                   -WORK AREA ADDRESSING               *
*       COMMREG                    -VECTOR TABLE ADDRESSING           *
*       WORK6                     -BUFFER ADDRESSING                  *
*       WORK7                -BLOCK ADDRESSING
*       WORK2,WORK3,WORK4,WORK5   -WORK REGISTERS                     *
*                                                                     *
*   THIS ROUTINE IS CHARACTER CODE INDEPENDENT                        *
*                                                                     *
***********************************************************************
         SPACE 2
IKJEBELO CSECT
         SPACE
         SPACE
*   PERFORM THE INITIALIZATION OPERATIONS HERE
         SAVE  (14,12),T,*             SAVE THE REGISTERS
         USING DATA,WORK7              BLOCK ADDRESSABILITY
         LA    SAVEREG,SAVEL(SAVEREG)  NEXT SAVE AREA
         LR    BASEREG,ENTRY           ENTRY POINT ADDRESS
         USING IKJEBELO,BASEREG
         L     DATAREG,WORD1(PARMREG1) WORK AREA ADDRESS
         USING UTILWORK,DATAREG
         L     COMMREG,VTABLE          TABLE OF ROUTINE ADDRS
         USING VECTABLE,COMMREG
         USING BUFFER,WORK6
         SPACE 2
*   CHECK FOR INPUT OPTION CURRENT OR NEXT
         CLI   X0(PARMREG1),K          WAS CURRENT SPECIFIED
         BE    LO2                     YES -
         CLI   X0(PARMREG1),N          WAS NEXT SPECIFIED
         BE    LO3                     YES -
         SPACE 2
*   SEARCH DIRECTORY AND READ DATA BLOCK INTO CORE,
*   DETERMINE OPTION
         BAL   LINK9,LO1               GET DATA BLOCK
         LTR   RETCDREG,RETCDREG       ANY ERRORS
         BNZ   LO16                    YES, TERMINATE
         CLI   X0(PARMREG1),B          WAS BEGIN OPTION SPECIF
         BE    LO9                     YES -
         CLI   X0(PARMREG1),P          PREVIOUS OPTION SPECIFIED
         BE    LO6                     YES -
*                                      NO, MUST BE LAST OPTION
         SPACE 2
*   LOCATE LAST RECORD OF DATA BLOCK
         LH    WORK2,NUMREC            NUMBER OF RECORDS
*                                        IN DATA BLOCK
         AR    WORK2,WORK2             TOTAL LENGTH OF LOCATORS
         LA    WORK3,LOCATORS-LOCL(WORK2)   ADDRESS OF LOCATOR
         LH    WORK2,X0(WORK3)         CONTENTS OF LOCATOR
LO8      LA    WORK2,DATA(WORK2)       ADDRESS OF RECORD
         SPACE 2
*   SET UP OUTPUT AND RETURN TO CALLING ROUTINE HERE
LO12     EQU   *
         ST    WORK3,BUFREF            ADDRESS OF RECORD LOCATOR
LO13     MVC   PRIMEKEY(KEYL),X0(WORK2)  SAVE ACTUAL KEY VALUE
         SR    RETCDREG,RETCDREG       SET RETURN CODE
LO16     L     SAVEREG,WORD2(SAVEREG)  OLD SAVE AREA
         RETURN (14,12),T,RC=(15)      RESTORE REGISTERS
         SPACE 2
*   MUST FIND FIRST RECORD OF DATA SET
LO9      LH    WORK2,LOCATORS          CONTENTS OF FIRST LOCATOR
         LA    WORK3,LOCATORS          ADDRESS OF FIRST LOCATOR
         B     LO8                     GO FIND ADDRESS OF RECORD
         SPACE 2
*   MUST FIND RECORD AFTER CURRENT REFERENCE
LO3      BAL   WORK8,LO30              LOCATE NEXT RECORD
LO32     LTR   RETCDREG,RETCDREG       ANY ERRORS
         BNZ   LO16                    YES, TERMINATE
         B     LO12                    NO, RETURN LOCATOR ADDR
         SPACE 2
*   MUST FIND CURRENT REFERENCE RECORD
LO2      BAL   WORK8,LO20              LOCATE CURRENT RECORD
         B     LO32                    GO CHECK RETURN CODE
         SPACE 2
*   MUST FIND RECORD PRIOR TO CURRENT REFERENCE
LO6      LH    WORK5,NUMREC            NUMBER OF RECORDS IN
*                                        DATA BLOCK
         LR    WORK4,WORK5             TOTAL LENGTH OF
         AR    WORK4,WORK4               LOCATORS
LO62     LA    WORK3,LOCATORS-LOCL(WORK4)   ADDRESS OF LOCATOR
         LH    WORK2,LOCATORS-LOCL(WORK4)   CONTENTS OF LOCATOR
         LA    WORK2,DATA(WORK2)       RECORD ADDRESS
         CLC   X0(KEYL,WORK2),PRIMEKEY IS THIS THE PREVIOUS REC
         BL    LO12                    YES, RETURN LOCATOR ADDR
         BCTR  WORK4,ZERO              DECREMENT TO PICK UP
         BCTR  WORK4,ZERO                PREVIOUS LOCATOR
         BCT   WORK5,LO62              REPEAT UNTIL ALL RECORDS
*                                        HAVE BEEN TESTED
         SPACE 2
*   RECORD PRIOR TO CURRENT REFERENCE NOT IN THIS DATA BLOCK,
*     MUST DO BINARY SEARCH BY KEY
         MVC   HIGHKEY(KEYL),PRIMEKEY  INITIALIZE TOP BOUND FOR
*                                        SEARCH
         SR    WORK4,WORK4             INITIALIZE LOWER BOUND
         ST    WORK4,LOWKEY              TO ZERO
LO63     L     WORK4,LOWKEY            COMPUTE SEARCH KEY =
         A     WORK4,HIGHKEY             (LOWKEY + HIGHKEY)/2  ,
         SRL   WORK4,ONE                 IGNORING REMAINDER
         ST    WORK4,PRIMEKEY          SEARCH KEY
         BAL   WORK8,LO30              LOCATE NEXT RECORD AFTER
*                                        SEARCH KEY
         CLC   X0(KEYL,WORK2),HIGHKEY  IS RECORD FOUND A
*                                        CANDIDATE FOR
*                                        PREVIOUS RECORD
         BNL   LO64                    NO, CHECK FOR CONVERGENCE
*                                      YES, CHECK IF THIS MUST
*                                        BE  PREVIOUS RECORD
         L     WORK4,HIGHKEY           HIGH BOUND
         BCTR  WORK4,ZERO                LESS ONE
         MVC   TEMP3(KEYL),X0(WORK2)   FOR ALIGNMENT
         L     WORK5,TEMP3             KEY OF RECORD FOUND
         CR    WORK4,WORK5             IS RECORD FOUND
*                                        NECESSARILY THE
*                                        PREVIOUS RECORD
         BE    LO12                    YES, RETURN
         ST    WORK5,LOWKEY            NO, RESET LOWER BOUND
*                                        AND REPEAT
         B     LO63                    REPEAT SEARCH
         SPACE 2
*   NO RECORD FOUND BETWEEN SEARCH KEY AND HIGH BOUND. TEST FOR
*     CONVERGENCE BEFORE REPEATING SEARCH
LO64     L     WORK4,PRIMEKEY          SEARCH KEY PLUS ONE (HIGH
         AH    WORK4,LOCONST1            ORDER BYTE PRESERVED)
         C     WORK4,HIGHKEY           CONVERGED YET
         BE    LO65                    YES
*                                      NO, RESET HIGH BOUND
*                                        AND REPEAT
         ST    WORK4,HIGHKEY           HIGH BOUND = SEARCH KEY+1
         B     LO63                    REPEAT SEARCH
         SPACE 2
*   CONVERGENCE ATTAINED
LO65     BAL   WORK8,LO20              CHECK FOR RECORD WITH
*                                        KEY EQUAL TO LAST
*                                        SEARCH KEY
         LTR   RETCDREG,RETCDREG       WAS RECORD FOUND
         BZ    LO12                    YES, HAS TO BE PREVIOUS
*                                        RECORD
         OC    LOWKEY(KEYL),LOWKEY     HAS A RECORD BEEN FOUND
*                                        DURING BINARY SEARCH
         BNZ   LO66                    YES, HAS TO BE PREVIOUS
*                                        RECORD
*                                      NO, MUST CHECK KEY = 0
         OC    PRIMEKEY(KEYL),PRIMEKEY HAS KEY = 0 ALREADY BEEN
*                                        CHECKED
         BZ    LO67                    YES, HENCE NO PREVIOUS
*                                        RECORD EXISTS
*                                      NO, MUST SEARCH KEY = 0
         SR    WORK4,WORK4             SET SEARCH KEY
         ST    WORK4,PRIMEKEY            TO ZERO
         BAL   WORK8,LO20              SEARCH FOR RECORD KEY 0
         LTR   RETCDREG,RETCDREG       WAS RECORD FOUND
         BZ    LO12                    YES, THIS IS THE PREVIOUS
*                                        RECORD
         B     LO16                    NO, TERMINATE
         SPACE 2
*   PREVIOUS RECORD FOUND TO BE THAT REFERENCED BY LOWKEY, SET
*     UP REGISTERS FOR RETURN
LO66     MVC   PRIMEKEY(KEYL),LOWKEY   KEY OF PREVIOUS RECORD
         BAL   WORK8,LO20              SET UP WORK2 AND WORK3
         B     LO12                    RETURN
         SPACE 2
LO67     LA    RETCDREG,NRF            RETURN CODE FOR RECORD
*                                        NOT FOUND
         B     LO16                    EXIT
         SPACE 2
*   THIS SUBROUTINE LOCATES RECORD WITH KEY EQUAL TO PRIMEKEY
LO20     MVI   X0(PARMREG1),K          INSURE THAT OPTION CODE
*                                         IS CORRECT
         BAL   LINK9,LO1               GET DATA BLOCK
         LTR   RETCDREG,RETCDREG       DATA BLOCK FOUND
         BCR   NOTZERO,WORK8           NO, RETURN
         LH    WORK5,NUMREC            NUMBER OF RECORDS IN
*                                        DATA BLOCK
         SR    WORK4,WORK4             OFFSET TO FIRST LOCATOR
LO21     LH    WORK2,LOCATORS(WORK4)   CONTENTS OF LOCATOR
         LA    WORK3,LOCATORS(WORK4)   ADDRESS OF LOCATOR
         LA    WORK2,DATA(WORK2)       ADDRESS OF RECORD
         CLC   PRIMEKEY(KEYL),X0(WORK2)  IS THIS THE REFERENCED
*                                        RECORD
         BCR   EQUAL,WORK8             YES, RETURN
         BL    LO22                    NO MORE POSSIBILITES,
*                                        RECORD NOT IN DATA SET
         LA    WORK4,LOCL(WORK4)       INCREMENT TO NEXT LOCATOR
         BCT   WORK5,LO21              REPEAT IF MORE RECORDS
LO22     LA    RETCDREG,NRF            RETURN CODE FOR NO RECORD
         BR    WORK8                   RETURN
         SPACE 2
*   THIS SUBROUTINE LOCATES RECORD FOLLOWING REFERENCE
*     KEY (PRIMEKEY)
LO30     MVI   X0(PARMREG1),N          INSURE THAT OPTION CODE
*                                        IS CORRECT
         BAL   LINK9,LO1               GET DATA BLOCK
         LTR   RETCDREG,RETCDREG       ANY ERRORS
         BCR   NOTZERO,WORK8           YES, RETURN
         SR    WORK4,WORK4             OFFSET TO FIRST LOCATOR
LO31     LH    WORK2,LOCATORS(WORK4)   CONTENTS OF LOCATOR
         LA    WORK3,LOCATORS(WORK4)   ADDRESS OF LOCATOR
         LA    WORK2,DATA(WORK2)       ADDRESS OF RECORD
         CLC   X0(KEYL,WORK2),PRIMEKEY IS THIS THE NEXT RECORD
         BCR   RECHIGH,WORK8           YES, RETURN
         LA    WORK4,LOCL(WORK4)       INCREMENT TO NEXT LOCATOR
         B     LO31                    REPEAT UNTIL FOUND
         SPACE 2
*   THIS SUBROUTINE OBTAINS DATA BLOCK USING OPTION CODE
         SPACE
*   BEGIN WITH DIRECTORY SEARCH
LO1      LA    WORK4,PRIMEKEY          SEARCH KEY ADDRESS INTO
         ST    WORK4,WORD2(PARMREG1)      PARM LIST
         L     ENTRY,DS                ENTRY POINT ADDRESS
         CALL  (15)                    FIND TTR OF BLOCK NEEDED
         CH    RETCDREG,LOEMPTY        EMPTY OR I/O ERROR
         BNL   LO16                    YES, TERMINATE
         LTR   RETCDREG,RETCDREG       WAS THE SEARCH SUCCESSFUL
         BNZ   LO17                    NO-RECORD NOT FOUND
         BAL   WORK5,LO18              READ CORRECT DATA BLOCK
         BR    LINK9                   RETURN
         SPACE
*   READ IN DATA BLOCK
LO18     EQU   *                       ENTRY
         L     WORK4,DBUFREF           FOUND ENTRY ADDRESS
         MVC   WORD2(TTR,PARMREG1),KEYL(WORK4)  MOVE TTR TO
*                                               PARM LIST
         L     ENTRY,RB                ENTRY POINT ADDRESS
         CALL  (15)                    READ IN DATA BLOCK
         LTR   RETCDREG,RETCDREG       ANY ERRORS
         BNZ   LO16                    YES, TERMINATE
         L     WORK6,WORD2(PARMREG1)   ADDRESS OF DATA BLOCK
         L     WORK7,BUFBLOCK          BLOCK ADDRESS
         BR    WORK5                   RETURN
LO17     BAL   WORK5,LO18              READ NEXT AVAILABLE BLOCK
         LA    RETCDREG,NRF            RETURN CODE FOR RECORD
*                                        NOT FOUND
         BR    LINK9                   RETURN
         SPACE 2
         DROP  BASEREG,COMMREG,DATAREG,WORK6,WORK7
         SPACE 2
*   CONSTANT AREA FOR RECORD LOCATE ROUTINE
LOEMPTY  DC    H'8'                    DATA SET EMPTY CONSTANT
LOCONST1 DC    H'1'                    CONSTANT FOR INCREM KEY
         TITLE 'EDIT COMMAND ACCESS METHOD -MOVE ROUTINE ---IKJEBEMV'
***********************************************************************
*                                                                     *
*STATUS -- VERSION NO. 02, VS     RELEASE NO. 03                      *
*                                                                     *
*FUNCTION- THIS ROUTINE IS USED TO MOVE ANY NUMBER OF BYTES FROM      *
*   ONE LOCATION TO ANOTHER. MORE SPECIFICALLY IT IS USED FOR THE     *
*   FOLLOWING-                                                        *
*       -MOVES RECORDS INTO THE DATA SET BUFFERS                      *
*       -MOVES RECORDS FROM THE DATA SET BUFFERS                      *
*       -MOVES RECORD LOCATORS WITHIN THE DATA BLOCKS                 *
*       -MOVES INDEX ENTRIES WITHIN THE DIRECTORY BLOCKS              *
*                                                                     *
*ENTRY POINT- AT IKJEBEMV FROM THE FOLLOWING ROUTINES-                *
*       IKJEBEDL   (TWO  PLACES)      -RECORD DELETION                *
*       IKJEBERR                      -READING RECORDS                *
*       IKJEBEWR   (FOUR PLACES)      -WRITING RECORDS                *
*                                                                     *
*INPUT --                                                             *
*       REGISTER 0 CONTAINS THE LENGTH OF THE DATA TO MOVE            *
*        REGISTER 1 POINTS TO A TWO WORD PARAMETER LIST               *
*          WORD1- CONTAINS THE MOVE-FROM ADDRESS                      *
*          WORD2- CONTAINS THE MOVE-TO   ADDRESS                      *
*                                                                     *
*OUTPUT- THE NUMBER OF BYTES INDICATED IN REGISTER 0 ARE MOVED FROM   *
*   THE ADDRESS CONTAINED IN WORD1 OF THE INPUT LIST TO THE           *
*   ADDRESS SPECIFIED IN WORD2 OF THE INPUT LIST                      *
*                                                                     *
*EXTERNAL REFERENCES -- NONE                                          *
*                                                                     *
*EXITS,NORMAL-  NO RETURN CODE, OUTPUT AS ABOVE                       *
*                                                                     *
*EXITS,ERROR-  NONE                                                   *
*                                                                     *
*TABLES/WORK AREAS- NONE                                              *
*                                                                     *
*ATTRIBUTES- REFRESHABLE,ENABLED,NON-PRIVILEGED                       *
*                                                                     *
*NOTES --  REGISTER CONVENTIONS ARE AS FOLLOWS-                       *
*       BASEREG              -BASE REGISTER                           *
*       PARMREG0             -TOTAL BYTE COUNT                        *
*       FROMREG              -MOVE-FROM ADDRESS                       *
*       TOREG                -MOVE-TO  ADDRESS                        *
*       PARMREG1             -MOVE COUNT PER PASS                     *
*                                                                     *
*   THIS ROUTINE IS CHARACTER CODE INDEPENDENT                        *
*                                                                     *
***********************************************************************
         EJECT
IKJEBEMV CSECT
*   PERFORM THE INITIALIZATION OPERATIONS HERE
         SAVE  (14,12),T,*
         LA    SAVEREG,SAVEL(SAVEREG)  NEXT SAVE AREA
         LR    BASEREG,ENTRY
         USING IKJEBEMV,BASEREG
         SPACE
*   SET UP THE STARTING POSITIONS AND LENGTH MINUS ONE
         BCTR  PARMREG0,ZERO           DECREMENT ONE FROM LENGTH
         L     TOREG,WORD2(PARMREG1)   TO ADDRESS
         L     FROMREG,WORD1(PARMREG1) FROM ADDRESS
         SPACE
*   MOVES 256 BYTES ON ALL PASSES EXCEPT THE LAST
MV2      LA    PARMREG1,K255           MAXIMUM MOVE LENGTH
         CR    PARMREG0,PARMREG1       COMPARE BALANCE TO MAXIMUM
         BNL   MV3                     USE MAXIMUM MOVE LENGTH
         LR    PARMREG1,PARMREG0       USE BALANCE
MV3      EX    PARMREG1,MOVEINST       MOVE REQUIRED AMOUNT
         LA    PARMREG1,ONE(PARMREG1)  AMOUNT MOVED
         AR    FROMREG,PARMREG1        ADJUST FROM ADDRESS
         AR    TOREG,PARMREG1          ADJUST TO-ADDRESS
         SR    PARMREG0,PARMREG1       REDUCE THE BALANCE
         BNM   MV2                     ARE WE FINISHED -NO BRANCH
         SPACE
*   EXIT HERE WHEN ALL MOVED
         L     SAVEREG,WORD2(SAVEREG)  YES-OLD SAVE AREA
         RETURN (14,12),T              RESTORE THE REGISTERS
         SPACE
         DROP  BASEREG
         SPACE 2
*   CONSTANT AREA FOR IKJEBEMV
MOVEINST MVC   X0(ONE,TOREG),X0(FROMREG) EXECUTED TO MOVE DATA
 TITLE 'EDIT COMMAND ACCESS METHOD -READ A BLOCK ROUTINE --IKJEBERB'
***********************************************************************
*                                                                     *
*STATUS -- VERSION NO. 02, VS2     RELEASE NO. 03                    *
*                                                                     *
*FUNCTION -- THIS ROUTINE READS IN A REQUESTED BLOCK GIVEN A TTR      *
*   THAT IS PASSED IN THE INPUT PARAMETER LIST.  IF THE REQUESTED     *
*   BLOCK IS ALREADY IN CORE, NO PHYSICAL I/O IS REQUIRED. THE        *
*   BUFFER CHAIN IS INSPECTED TO SEE IF THE REQUESTED BLOCK IS        *
*   PRESENT. IF THE BLOCK IS IN CORE, ITS ADDRESS IS PASSED BACK      *
*   IN THE PARAMETER LIST.                                            *
*        IF THE BLOCK IS NOT IN CORE, AN EMPTY BUFFER IS OBTAINED     *
*   BY CALLING THE BUFFER ASSIGNMENT ROUTINE, IKJEBEAS.  THE BLOCK    *
*   IS READ IN BY GOING TO THE RESIDENT CONVERT ROUTINE FOR THE       *
*   TTR TO MBBCCHHR CONVERSION.  A XDAP READ IS THEN PERFORMED TO     *
*   OBTAIN THE BLOCK.  THE WAIT ROUTINE, IKJEBEWA, INSURES THAT       *
*   THE I/O IS COMPLETE BEFORE RETURNING THE ADDRESS OF THE BUFFER    *
*   IN THE INPUT PARAMETER LIST.                                      *
*                                                                     *
*ENTRY POINTS --                                                      *
*       IKJEBERB VIA A CALL FROM EITHER IKJEBEAD, IKJEBEDL,           *
*        IKJEBEDS, IKJEBEDU, OR IKJEBELO.                             *
*                                                                     *
*INPUT -- REGISTER ONE POINTS TO A TWO WORD PARAMETER LIST.           *
*       WORD1-  CONTAINS A POINTER TO THE WORKAREA, UTILWORK          *
*       WORD2-  CONTAINS THE TTR OF THE DESIRED BLOCK                 *
*                                                                     *
*OUTPUT -- THE SECOND WORD OF THE INPUT PARM LIST CONTAINS THE        *
*   ADDRESS OF THE BUFFER THAT CONTAINS THE REQUESTED BLOCK.          *
*                                                                     *
*EXTERNAL REFERENCES --                                               *
*       IKJEBEAS             -ASSIGNS BUFFER READ-IN AREA             *
*       IKJEBEWA             -WAITS ON THE I/O OPERATION              *
*       IECPCNVT             -RESIDENT CONVERT ROUTINE                *
*       MACROS USED                                                   *
*         XDAP               -READ INTO CORE ANY BLOCK                *
*                                                                     *
*EXITS,NORMAL -- REGISTER 15 CONTAINS A RETURN CODE OF ZERO WITH      *
*   OUTPUT AS DESCRIBED ABOVE.                                        *
*                                                                     *
*EXITS,ERROR --  REGISTER 15 CONTAINS A RETURN CODE OF TWELVE ON      *
*   I/O ERRORS.                                                       *
*                                                                     *
*TABLES/WORK AREAS -- THIS ROUTINE IS DEPENDENT ON THE WORKAREA       *
*   FOR THE BUFFER ADDRESSES AND ON 'VECTABLE' FOR THE ADDRESSES      *
*   OF THE EXTERNAL ROUTINES.                                         *
*                                                                     *
*ATTRIBUTES -- REFRESHABLE, NON-PRIVILEGED, ENABLED                   *
*                                                                     *
*NOTES -- REGISTER CONVENTIONS ARE AS FOLLOWS-                        *
*       BASEREG              -BASE REGISTER                           *
*       DATAREG              -WORK AREA ADDRESSING                    *
*       COMMREG              -VECTOR TABLE ADDRESSING                 *
*       WORK6                -BUFFER ADDRESSING                       *
*       WORK7                -BLOCK ADDRESS
*       WORK2,3              -WORK REGISTERS
*       WORK4,5              -WORK REGISTERS
*                                                                     *
*   THIS ROUTINE IS CHARACTER CODE INDEPENDENT                        *
*                                                                     *
***********************************************************************
         SPACE 2
IKJEBERB CSECT
*   PERFORM THE INITIALIZATION OPERATIONS HERE
         SAVE  (14,12),T,*             SAVE THE REGISTERS
         LA    SAVEREG,SAVEL(SAVEREG)  STEP TO NEXT SAVEAREA
         LR    BASEREG,ENTRY           ENTRY POINT ADDRESS
         USING IKJEBERB,BASEREG
         L     DATAREG,WORD1(PARMREG1) WORK AREA ADDRESS
         USING UTILWORK,DATAREG
         L     COMMREG,VTABLE          TABLE OF ROUTINE ADDRESSES
         USING VECTABLE,COMMREG
         SPACE 2
*   CHECK IF THE DESIRED BLOCK IS IN CORE
RB6      MVI   TTR+WORD2(PARMREG1),ZERO  INSURE TTR0
         L     WORK5,WORD2(PARMREG1)   TTR OF DESIRED BLOCK
         LA    WORK6,BUF1              ADDRESS OF 1ST BUFFER
         LH    WORK4,DCBBFNO           TOTAL BUFFERS
         USING BUFFER,WORK6
RB2      C     WORK5,BUFTTR            IS THIS THE CORRECT BLOCK
         BE    RB1                     YES-RETURN
         LA    WORK6,L'BUF1(WORK6)     NEXT BUF.CNTL FIELD
         BCT   WORK4,RB2               REPEAT UNTIL FOUND
*                                      DESIRED BLOCK NOT IN CORE
         SPACE 2
*   BLOCK IS NOT IN CORE AND MUST BE READ INTO EMPTY BUFFER
         L     ENTRY,AS                ENTRY POINT ADDRESS
         CALL  (15)                    GET AN EMPTY BUFFER
         LTR   RETCDREG,RETCDREG       ANY ERRORS
         BNZ   RB13                    YES-RETURN
         L     WORK6,WORD2(PARMREG1)   ASSIGNED BUFFER ADDRESS
         L     WORK7,BUFBLOCK          BLOCK ADDRESS
         USING DATA,WORK7              BLOCK ADDRESSABILITY
         ST    WORK5,BUFTTR            TTR OF DESIRED BLOCK
         SPACE 2
*   POSITION ACCESS METHOD FOR CORRECT BLOCK
RB4      LR    PARMREG0,WORK5          TTR TO BE CONVERTED
         L     PARMREG1,DCBDEBAD       ADDRESS OF DEB
         LA    WORK2,RBLKREF           ADDRESS TO RECEIVE MBBCCHHR
         LR    WORK3,DATAREG           SAVE ADDRESS FOR WORKAREA
         DROP  DATAREG
         USING UTILWORK,WORK3
         STM   WORK9,SAVEREG,TEMPREGS  SAVE REGISTERS 9-13
         L     ENTRY,CVTPTR            ADDRESS OF CVT
         USING CVT,ENTRY
         L     ENTRY,CVTPCNVT          ADDRESS OF CONVERT ROUTINE
         DROP  ENTRY
         BALR  RETREG,ENTRY            CONVERT TTR TO MBBCCHHR
         LM    WORK9,SAVEREG,TEMPREGS  RESTORE REGISTERS 9-13
         DROP  WORK3
         USING UTILWORK,DATAREG
         SPACE 2
*   READ IN THE DESIRED BLOCK HERE
         XDAP  XDAPRLST,RI,UTILDCB,DATA,,MF=E   READ IN A BLOCK
         LA    PARMREG1,PARM1          PARAMETER LIST ADDRESS
         ST    WORK6,WORD2(PARMREG1)   BUFFER TO WAIT UPON
         MVI   BUFSTATS,WAITXR         INDICATE OPERATION UPON WHICH
*                                        TO WAIT
         L     ENTRY,WA                ENTRY POINT ADDRESS
         CALL  (15)                    WAIT FOR THE I/O TO COMPLETE
         LTR   RETCDREG,RETCDREG       ANY ERRORS
         BNZ   RB13                    YES-RETURN
         SPACE 2
*   STORE RETURN BUFFER ADDRESS AND EXIT HERE
RB1      ST    WORK6,WORD2(PARMREG1)   DESIRED BUFFER ADDRESS
         SR    RETCDREG,RETCDREG       SET RETURN CODE = 0
RB13     L     SAVEREG,WORD2(SAVEREG)  OLD SAVE AREA ADDRESS
         RETURN (14,12),T,RC=(15)      RESTORE THE REGISTERS
         SPACE 2
         DROP  BASEREG,COMMREG,DATAREG,WORK6,WORK7
 TITLE 'EDIT COMMAND ACCESS METHOD --READ A RECORD ROUTINE --IKJEBERR'
***********************************************************************
*                                                                     *
*STATUS -- VERSION NO. 02, VS2     RELEASE NO. 03                    *
*                                                                     *
*FUNCTION --  THIS ROUTINE SERVES AS THE INTERFACE WHEN READING       *
*   RECORDS FROM THE UTILITY DATA SET. FIVE DIFFERENT READ OPTIONS    *
*   ARE POSSIBLE (AS SPECIFIED BELOW), IN ADDITION, AN INPUT KEY      *
*   MAY BE PROVIDED WHICH WILL REPLACE THE LAST REFERENCED KEY IN     *
*   THE ACCESS METHOD BEFORE THE OPERATION TAKES PLACE.  THE DESIRED  *
*   RECORD WILL EITHER BE MOVED TO THE ADDRESS SPECIFIED BY THE       *
*   CALLER OR A POINTER TO THE RECORD PASSED BACK IN A REGISTER.      *
*                                                                     *
*        FINDING THE DESIRED RECORD INVOLVES USING THE RECORD         *
*   LOCATING ROUTINE (IKJEBELO).  IF THE DESIRED RECORD DOES NOT      *
*   EXIST, A RETURN CODE OF 4 IS PASSED BACK.  A RETURN CODE OF 12    *
*   IS PASSED BACK IF AN I/O ERROR IS ENCOUNTERED.                    *
*                                                                     *
*ENTRY POINTS --                                                      *
*       IKJEBERR             VIA A CALL FROM IKJEBEUT                 *
*                                                                     *
*INPUT -- REGISTER ONE POINTS TO A 1-3 WORD PARAMETER LIST            *
*        WORD1-                                                       *
*         HIGH ORDER BYTE CONTAINS A CODE AS FOLLOWS-                 *
*           X'00'            READ CURRENT REFERENCE RECORD            *
*           X'01             READ RECORD PREVIOUS TO REFERENCE        *
*           X'02'            READ RECORD AFTER REFERENCE              *
*           X'04'            READ FIRST RECORD IN DATA SET            *
*           X'05'            READ LAST RECORD IN DATA SET             *
*         THREE LOW ORDER BYTES CONTAIN A POINTER TO THE WORKAREA/DCB *
*                                                                     *
*       WORD2-  OPTIONALLY CONTAINS A POINTER TO A FOUR BYTE BINARY   *
*         KEY THAT REPLACES THE LAST REFERENCED KEY IN THE ACCESS     *
*         METHOD BEFORE THE READ OPERATION TAKES PLACE.               *
*                                                                     *
*       WORD3-  OPTIONALLY CONTAINS AN ADDRESS WHICH INDICATES        *
*         WHERE THE LOCATED RECORD IS TO BE PLACED.                   *
*                                                                     *
*OUTPUT --  REGISTERS AS DESCRIBED BELOW                              *
*   THE DESIRED RECORD IS EITHER MOVED TO THE SPECIFIED LOCATION OR   *
*   A POINTER IS RETURNED TO THE RECORD IN REGISTER ONE.              *
*                                                                     *
*EXTERNAL REFERENCES --                                               *
*       IKJEBELO             -FINDS THE DESIRED RECORD                *
*       IKJEBEMV             -MOVES RECORD TO USER AREA, ON REQUEST   *
*                                                                     *
*EXITS,NORMAL --  A RETURN CODE OF ZERO IN REGISTER 15 AND THE        *
*   DESIRED RECORD HAS BEEN MADE AVAILABLE TO THE USER.               *
*        A RETURN CODE OF FOUR IS PASSED BACK IF THE REQUESTED        *
*   RECORD DOES NOT EXIST                                             *
*                                                                     *
*EXITS,ERROR --  A RETURN CODE OF 12 IS RETURNED IN REGISTER 15       *
*   IF AN I/O ERROR IS ENCOUNTERED                                    *
*                                                                     *
*TABLES/WORK AREAS --  THIS ROUTINE IS DEPENDENT ON THE WORKAREA,     *
*   UTILWORK, FOR THE REFERENCE KEY INFORMATION AND ON THE VECTOR     *
*   TABLE, 'VECTABLE', FOR THE EXTERNAL REFERENCES.                   *
*                                                                     *
*ATTRIBUTES -- REFRESHABLE,NON-PRIVILEGED,ENABLED                     *
*                                                                     *
*NOTES --  REGISTER USE IS AS FOLLOWS-                                *
*       BASEREG              -BASE REGISTER                           *
*       COMMREG              -VECTOR TABLE ADDRESSING                 *
*       DATAREG              -WORK AREA ADDRESSING                    *
*       WORK6                -BUFFER ADDRESSING                       *
*       WORK7                -BLOCK ADDRESSING
*       WORK2,WORK4,WORK5    -WORK REGISTERS                          *
*                                                                     *
*   THIS ROUTINE IS CHARACTER CODE INDEPENDENT                        *
*                                                                     *
*                                                                     *
***********************************************************************
         SPACE 2
IKJEBERR CSECT
*   PERFORM THE INITIALIZATION OPERATIONS HERE
         SAVE  (14,12),T,*
         LR    BASEREG,ENTRY           ENTRY POINT ADDRESS
         USING IKJEBERR,BASEREG
         L     DATAREG,WORD1(PARMREG1) WORK AREA ADDRESS
         USING UTILWORK,DATAREG
         L     COMMREG,VTABLE          TABLE OF ROUTINE ADDRESSES
         USING VECTABLE,COMMREG
         LA    WORK5,SAVEAREA          NEW SAVE AREA
         ST    SAVEREG,WORD2(WORK5)    OLD ADDRESS TO NEW
         ST    WORK5,WORD3(SAVEREG)    NEW ADDRESS TO OLD
         LR    SAVEREG,WORK5           NEW SAVE AREA
         SPACE 2
*   PROCESS INPUT PARAMETER LIST
         MVC   SAVEKEY(KEYL),PRIMEKEY  SAVE REFERENCE KEY
         LR    WORK4,PARMREG1          SAVE INPUT PARM LIST ADDRESS
         TM    X0(PARMREG1),LAST       MORE THAN ONE PARAMETER
         BO    RR3                     NO--
         L     WORK6,WORD2(PARMREG1)   POSSIBLE POINTER TO KEY
         LA    WORK6,X0(WORK6)         CLEAR HIGH ORDER BYTE
         LTR   WORK6,WORK6             IS THERE A KEY POINTER
         BZ    RR3                     NO--
RR1      MVC   PRIMEKEY(KEYL),X0(WORK6) RESET REFERENCE KEY
         SPACE 2
*   FIND THE SPECIFIED RECORD
RR3      MVC   PARM1(PTR),WORD1(PARMREG1)  INPUT DCB POINTER AND OPTION
         LA    PARMREG1,PARM1                CODE TO PARAMETER LIST
         NI    PARM1,ALL-LAST          INSURE HIGH ORDER BIT OFF
         L     ENTRY,LO                ENTRY POINT ADDRESS
         CALL  (15)                    FIND THE RECORD
         LTR   RETCDREG,RETCDREG       DOES THE RECORD EXIST
         BNZ   RR40                    NO--
         SPACE 2
*   THE RECORD WAS FOUND -- COMPUTE ADDRESS OF THE RECORD
RR2      L     WORK6,WORD2(PARMREG1)   BUFFER ADDRESS
         USING BUFFER,WORK6
         L     WORK7,BUFBLOCK          BLOCK ADDRESS
         USING DATA,WORK7              BLOCK ADDRESSABILITY
         L     WORK5,BUFREF            ADDRESS OF RECORD LOCATOR
         LH    WORK5,X0(WORK5)         CONTENTS OF LOCATOR
         LA    WORK5,DATA(WORK5)       RECORD ADDRESS
         SPACE 2
*   DETERMINE FORM OF OUTPUT HERE
         TM    X0(WORK4),LAST          MORE THAN ONE PARAMETER
         BO    RR5                     NO--PASS BACK ADDRESS OF RECORD
         TM    WORD2(WORK4),LAST       MORE THAN TWO PARAMETERS
         BO    RR5                     NO--PASS BACK ADDRESS OF RECORD
         L     WORK2,WORD3(WORK4)      AREA ADDRESS, IF ANY
         LA    WORK2,X0(WORK2)         CLEAR HIGH ORDER
         LTR   WORK2,WORK2             IS THERE AN ADDRESS
         BNZ   RR4                     YES-MOVE RECORD TO THIS ADDRESS
         SPACE 2
*   SET UP RETURN PARM LIST AND RETURN TO CALLER HERE
RR5      LR    PARMREG1,WORK5          RECORD ADDRESS
         SR    RETCDREG,RETCDREG       RETURN CODE
RR6      L     SAVEREG,WORD2(SAVEREG)  OLD SAVE AREA
         L     RETREG,L3*L4(SAVEREG)   RESTORE REGISTER 14
         L     PARMREG0,L8*L2+L4(SAVEREG) RESTORE REGISTER 0
         RETURN (2,12),T               RESTORE REGISTERS 2-12
         SPACE 2
*   MOVE THE RECORD TO THE USER SPECIFIED AREA                        *
RR4      ST    WORK2,TEMP2             MOVE-TO ADDRESS
         ST    WORK5,TEMP1             MOVE-FROM ADDRESS
         LA    PARMREG1,TEMP1          PARAMETER LIST ADDRESS
         MVC   TEMP3(L2),KEYL(WORK5)   LENGTH OF RECORD
         LH    WORK2,TEMP3             LENGTH OF RECORD
         LA    WORK2,KEYL(WORK2)       ACCOUNT FOR KEY LENGTH
         LR    PARMREG0,WORK2          LENGTH TO PARM REGISTER
         L     ENTRY,MV                ENTRY POINT ADDRESS
         CALL  (15)                    MOVE RECORD TO CALLERS AREA
         B     RR5                     RETURN
         SPACE 2
*   ON ERROR CONDITIONS ENTER HERE
RR40     MVC   PRIMEKEY(KEYL),SAVEKEY  RESTORE OLD KEY
         TM    DCBSTATS,ERROR          ANY I/O ERRORS
         BO    RR6                     YES- R.C. =12
RR10     LA    RETCDREG,NRF            NO--RETURN CODE//NO RECORD
         B     RR6                     RETURN
         SPACE 2
         DROP  BASEREG,COMMREG,DATAREG,WORK6
 TITLE 'EDIT COMMAND ACCESS METHOD --THE WAIT ROUTINE  ---IKJEBEWA'
***********************************************************************
*                                                                     *
*STATUS -- VERSION NO. 02, VS2     RELEASE NO. 03                    *
*                                                                     *
*FUNCTION -- THIS ROUTINE IS UTILIZED TO INSURE THAT A PREVIOUS I/O   *
*   REQUEST IS COMPLETE.  A WAIT MACRO IS ISSUED FOR A PRIOR XDAP     *
*   OPERATION AND A CHECK MACRO FOR A BSAM OPERATION.  IN THE EVENT   *
*   THAT AN I/O ERROR HAS OCCURRED, THE SYNAD ROUTINE WILL BE         *
*   GIVEN CONTROL DIRECTLY AFTER THE WAIT OR INDIRECTLY AS A RESULT   *
*   OF A CHECK MACRO.  THE SYNAD ROUTINE OBTAINS THE ERROR INFORM-    *
*   ATION VIA THE SYNADAF MACRO.                                      *
*        IF THE I/O HAS JUST COMPLETED ON A NEWLY FORMATTED BLOCK,    *
*   ITS TTR IS OBTAINED WITH THE NOTE MACRO AND RETAINED IN THE       *
*   BUFFER.                                                           *
*                                                                     *
*ENTRY POINTS --                                                      *
*       IKJEBEWA             -VIA A CALL FROM IKJEBEAD, IKJEBEAS,     *
*                               IKJEBERB, IKJEBEWB.                   *
*INPUT --  REGISTER 1 POINTS TO A TWO WORD PARAMETER LIST             *
*       WORD1-  CONTAINS ADDRESS OF THE WORKAREA, UTILWORK            *
*       WORD2-  CONTAINS ADDRESS OF BUFFER TO 'WAIT' UPON             *
*                                                                     *
*OUTPUT --  THE I/O OPERATION ON THE SPECIFIED IS ALLOWED TO          *
*   COMPLETE. ANY I/O ERROR RESULTS IN THE SYNADAF INFORMATION        *
*   BEING STORED IN THE 'IOMSG' FIELD OF THE WORKAREA.                *
*                                                                     *
*EXTERNAL REFERENCES --                                               *
*       MACROS USED                                                   *
*         WAIT               -'WAIT' ON XDAP OPERATION                *
*         CHECK              -'WAIT' AND 'CHECK' BSAM OPERATION       *
*         NOTE               -FIND TTR OF LAST NEW BLOCK              *
*         SYNADAF            -OBTAIN I/O ERROR INFORMATION            *
*         SYNADRLS           -RELEASE ERROR MESSAGE BUFFER            *
*                                                                     *
*EXITS,NORMAL -- REGISTER 15 CONTAINS A RETURN CODE OF ZERO AND THE   *
*   I/O ON THE SPECIFIED BUFFER IS INSURED OF BEING COMPLETED.        *
*                                                                     *
*EXITS,ERROR --  REGISTER 15 CONTAINS A RETURN CODE OF 12.  THE       *
*   SPECIFIC ERROR INFORMATION IS STORED IN THE WORKAREA.             *
*                                                                     *
*TABLES/WORK AREAS -- THIS ROUTINE IS DEPENDENT UPON THE DCB AND      *
*   BUFFER STATUS SWITCHES, THE BSAM DECBS, THE XDAP ECB, AND         *
*   THE ERROR MESSAGE FIELD IN THE WORKAREA.                          *
*                                                                     *
*ATTRIBUTES -- REFRESHABLE,NON-PRIVILEGED,ENABLED                     *
*                                                                     *
*NOTES --  THE REGISTER CONVENTIONS ARE AS FOLLOWS-                   *
*       BASEREG              -BASE REGISTER                           *
*       DATAREG              -WORK AREA ADDRESSING                    *
*       WORK6                -BUFFER ADDRESSING                       *
*                                                                     *
*   THIS ROUTINE IS CHARACTER CODE INDEPENDENT                        *
*                                                                     *
***********************************************************************
         SPACE 2
IKJEBEWA CSECT
         ENTRY IKJEBESY
*   PERFORM THE INITIALIZATION OPERATIONS HERE
         SAVE  (14,12),T,*             SAVE THE REGISTERS
         LA    SAVEREG,SAVEL(SAVEREG)  STEP TO NEXT SAVEAREA
         LR    BASEREG,ENTRY           ENTRY POINT ADDRESS
         USING IKJEBEWA,BASEREG
         L     DATAREG,WORD1(PARMREG1) WORK AREA ADDRESS
         USING UTILWORK,DATAREG
         SPACE 2
*   CHECK FOR TYPE OF OPERATION (BSAM OR XDAP)
         L     WORK6,WORD2(PARMREG1)   BUFFER ADDRESS
         USING BUFFER,WORK6
         TM    BUFSTATS,WAITB          WAS THIS A BSAM OPERATION
         BO    WA5                     YES-GO ISSUE CHECK MACRO
         SPACE 2
*   INSURE THAT THE XDAP OPERATION IS COMPLETE
         LA    PARMREG1,XRECB          ECB FOR XDAP READ
         TM    BUFSTATS,WAITXR         WAS THIS A XDAP READ
         BO    WA3                     YES-GO CHECK IF A-OK
         LA    PARMREG1,XWECB          ECB FOR XDAP WRITE
WA3      TM    X0(PARMREG1),COMPLETE   IS THE I/O COMPLETE
         BO    WA6                     YES--GO CHECK STATUS
         WAIT  ECB=(1)                 WAIT FOR COMPLETION
         SPACE 2
*   TEST FOR ERRORS AND PROCESS SAME IN SYNAD ROUTINE
WA6      CLI   X0(PARMREG1),GOOD       ANY ERRORS
         BE    WA11                    NO--RETURN
         L     ENTRY,DCBSYNAD          ADDRESS OF SYNAD ROUTINE
         BALR  RETREG,ENTRY            PROCESS ERROR INFORMATION
WA21     LA    RETCDREG,IOERR          SET RETURN CODE =12
         B     WA2                     RETURN TO CALLER
         SPACE 2
*   INSURE A COMPLETED BSAM OPERATION HERE
WA5      LA    PARMREG1,WRDECB         ADDRESS OF BSAM WRITE DECB
WA52     CHECK (1)                     WAIT FOR COMPLETION OF I/O
         TM    DCBSTATS,ERROR          WERE THERE ANY ERRORS
         BO    WA21                    YES--RETURN
         SPACE 2
*   LOG THE TTR OF ALL NEW BLOCKS
         LA    PARMREG1,UTILDCB        DCB ADDRESS
         NOTE  (1)                     OBTAIN TTR
         ST    PARMREG1,BUFTTR         SAVE TTR
         SPACE 2
*   TURN OFF ALL FLAGS AND EXIT HERE
WA11     NI    BUFSTATS,ALL-WAITB-WAITXR-WAITXW  TURN OFF WAIT FLAGS
WA1      SR    RETCDREG,RETCDREG       SET RETURN CODE
WA2      L     SAVEREG,WORD2(SAVEREG)  OLD SAVE AREA
         RETURN (14,12),T,RC=(15)      RESTORE THE REGISTERS
         EJECT
*   ERROR PROCESSING HERE
*   REGISTER 0 CONTAINS THE ADDRESS OF DECB FOR BSAM OPERATIONS
*   REGISTER 1 INDICATES BSAM READ OR WRITE AND DCB ADDRESS
*   REGISTERS 2-13 SAME AS AT 'CHECK' TIME OR WAIT ON XDAP
*   REGISTER 14 IS THE RETURN ADDRESS
*   REGISTER 15 IS THE ENTRY POINT ADDRESS
IKJEBESY EQU   *                       ENTER SYNAD ROUTINE HERE
*   DETERMINE THE OPERATION IN ERROR
         TM    BUFSTATS,WAITB          IS THIS A BSAM OPERATION
         BO    SY1                     YES-
         SPACE 2
*   PROCESS XDAP ERRORS HERE
         LA    PARMREG1,XRIOB          XDAP READ IOB ADDRESS
         TM    BUFSTATS,WAITXR         WAS THIS A XDAP READ
         BO    SY2                     YES-GO ISSUE SYNADAF
         LA    PARMREG1,XWIOB          XDAP WRITE IOB ADDRESS
SY2      SYNADAF ACSMETH=EXCP          OBTAIN ERROR INFORMATION
SY11     MVC   IOMSG(K78),K50(PARMREG1) I/O ERROR INFO TO WORKAREA
         SYNADRLS                      RELEASE THE SYNADAF BUFFER
         OI    DCBSTATS,ERROR          INDICATE PERMANENT ERROR
         BR    RETREG                  RETURN
         SPACE 2
*   PROCESS BSAM ERRORS HERE
SY1      SYNADAF ACSMETH=BSAM          OBTAIN ERROR INFORMATION
         B     SY11                    RETURN
         SPACE 2
         DROP  BASEREG,DATAREG,WORK6
 TITLE 'EDIT COMMAND ACCESS METHOD --WRITE A BLOCK ROUTINE ---IKJEBEWB'
***********************************************************************
*                                                                     *
*STATUS -- VERSION NO. 02, VS2     RELEASE NO. 03                    *
*                                                                     *
*FUNCTION --  THIS ROUTINE INITIATES A WRITE OPERATION OF THE BLOCK   *
*   IN A SPECIFIED BUFFER.  BEFORE THE WRITE IS STARTED, ANY PREVIOUS *
*   I/O IS BROUGHT TO COMPLETION BY CALLING THE WAIT ROUTINE, IKJEBEWA*
*   NEW BLOCKS ARE WRITTEN OUT WITH A BSAM WRITE AND A XDAP WRITE     *
*   IS USED ON ALL PREVIOUSLY FORMATTED BLOCKS.                       *
*        IF AN XDAP WRITE IS USED ON AN OLD BLOCK, ITS TTR IS         *
*   COMVERTED TO AN ACTUAL DEVICE TRACK ADDRESS BY THE SYSTEM         *
*   RESIDENT CONVERT ROUTINE, IECPCNVT.                               *
*        ANYTIME A BLOCK IS WRITTEN OUT, BIT SWITCHES ARE SET IN      *
*   THE BUFFER INDICATING THE TYPE OF OPERATION AND THE BUFFER        *
*   ADDRESS IS SAVED IN THE WORKAREA.                                 *
*                                                                     *
*ENTRY POINT --                                                       *
*       IKJEBEWB   -VIA A CALL FROM IKJEBEAD, IKJEBEAS, IKJEBEDL,     *
*                     IKJEBEDU, AND IKJEBEWR.                         *
*                                                                     *
*INPUT --  REGISTER ONE POINTS TO A TWO-WORD PARAMETER LIST           *
*       WORD1-   CONTAINS THE ADDRESS OF THE WORKAREA                 *
*       WORD2-   CONTAINS THE ADDRESS OF THE BUFFER THAT CONTAINS     *
*                THE BLOCK TO BE WRITTEN.                             *
*                                                                     *
*OUTPUT -- A WRITE OPERATION TO A DIRECT ACCESS DEVICE IS INITIATED   *
*   FOR THE BLOCK CONTAINED IN THE SPECIFIED BUFFER.                  *
*                                                                     *
*EXTERNAL REFERENCES --                                               *
*       IKJEBEWA             -WAITS ON ANY I/O IN PROGRESS            *
*       IECPCNVT             -CONVERTS TTR TO MBBCCHHR                *
*       MACROS USED                                                   *
*         WRITE              -INITIATE WRITE OF NEW BLOCK             *
*         XDAP               -INITIATE WRITE OF OLD BLOCK             *
*EXITS,NORMAL --  RETURNS TO CALLING ROUTINE WITH REGISTER 15         *
*   CONTAINING A RETURN CODE OF 0.                                    *
*                                                                     *
*EXITS,ERROR --   RETURNS TO CALLING ROUTINE WITH REGISTER 15         *
*   CONTAINING A RETURN CODE OF 12.                                   *
*                                                                     *
*TABLES/WORK AREAS -- THIS ROUTINE IS DEPENDENT ON THE VECTOR TABLE   *
*   FOR CALLS TO EXTERNAL ROUTINES.  THIS ROUTINE IS DEPENDENT ON THE *
*   CVT FOR THE ADDRESS OF THE RESIDENT CONVERT ROUTINE, IECPCNVT.    *
*                                                                     *
*ATTRIBUTES -- REFRESHABLE, ENABLED, NON-PRIVILEGED                   *
*                                                                     *
*NOTES --  REGISTER CONVENTIONS ARE AS FOLLOWS-                       *
*       BASEREG              -BASE REGISTER                           *
*       COMMREG              -VECTOR TABLE ADDRESSING                 *
*       DATAREG              -WORKAREA ADDRESSING                     *
*       WORK6                -BUFFER ADDRESSING                       *
*       WORK7                -BLOCK ADDRESSING
*       WORK2,WORK3          -WORK REGISTERS                          *
*                                                                     *
*   THIS ROUTINE IS CHARACTER CODE INDEPENDENT                        *
*                                                                     *
***********************************************************************
         SPACE 2
IKJEBEWB CSECT
*   PERFORM THE INITIALIZATION OPERATIONS HERE
         SAVE  (14,12),T,*             SAVE THE REGISTERS
         LA    SAVEREG,SAVEL(SAVEREG)  STEP TO NEXT SAVE AREA.
         LR    BASEREG,ENTRY           ENTRY POINT ADDRESS
         USING IKJEBEWB,BASEREG
         L     DATAREG,WORD1(PARMREG1) WORK AREA ADDRESS
         USING UTILWORK,DATAREG
         L     COMMREG,VTABLE          TABLE OF ROUTINE ADDRESSES
         USING VECTABLE,COMMREG
         SPACE 2
*   DETERMINE THE TYPE OF I/O OPERATION HERE
WB3      L     WORK6,WORD2(PARMREG1)   BUFFER ADDRESS
         USING BUFFER,WORK6            ADDRESSABILITY
         L     WORK7,BUFBLOCK          BLOCK ADDRESS
         USING DATA,WORK7              BLOCK ADDRESSABILITY
         TM    BUFSTATS,NEWBLK         IS THIS A NEW BLOCK
         BZ    WB2                     NO--USE XDAP WRITE
*                                      YES-USE BSAM WRITE
         SPACE 2
*   WRITE OUT THE NEW BLOCK
         WRITE WRDECB,SF,UTILDCB,DATA,'S',,,MF=E
         MVI   BUFSTATS,WAITB          INDICATE TO WAIT LATER ON
*                                        THE BSAM WRITE OPERATION
         SPACE 2
*   PERFORM FINAL HOUSEKEEPING AND EXIT HERE
WB11     SR    RETCDREG,RETCDREG       SET RETURN CODE = 0
WB10     EQU   *                       RETURN HERE ON ERRORS
WB5      L     SAVEREG,WORD2(SAVEREG)  OLD SAVE AREA
         RETURN (14,12),T,RC=(15)      RESTORE THE REGISTERS
         SPACE 2
*   CONVERT TTR OF BLOCK TO ACTUAL TRACK ADDRESS
WB2      L     PARMREG0,BUFTTR         TTR TO BE CONVERTED
         L     PARMREG1,DCBDEBAD       ADDRESS OF DEB
         LA    WORK2,WBLKREF           ADDRESS TO RECEIVE MBBCCHHR
         LR    WORK3,DATAREG           SAVE ADDRESS FOR WORKAREA
         DROP  DATAREG
         USING UTILWORK,WORK3
         STM   WORK9,SAVEREG,TEMPREGS  SAVE REGISTERS 9-13
         L     ENTRY,CVTPTR            ADDRESS OF CVT
         USING CVT,ENTRY
         L     ENTRY,CVTPCNVT          ADDRESS OF CONVERT ROUTINE
         DROP  ENTRY
         BALR  RETREG,ENTRY            CONVERT TTR TO MBBCCHHR
         LM    WORK9,SAVEREG,TEMPREGS  RESTORE REGISTERS 9-13
         DROP  WORK3
         USING UTILWORK,DATAREG
         SPACE 2
*   WRITE OUT THE BLOCK WITH AN XDAP-WRITE HERE
         XDAP  XDAPWLST,WI,UTILDCB,DATA,,MF=E
         MVI   BUFSTATS,WAITXW         SET WAIT FLAG
         B     WB11                    RETURN
         SPACE 2
         DROP  BASEREG,COMMREG,DATAREG,WORK6,WORK7
 TITLE 'EDIT COMMAND ACCESS METHOD --WRITE PURGE ROUTINE ---IKJEBEWP'
*****************************************************************
*
*STATUS -- VERSION NO. 02, VS2     RELEASE NO. 03                     *
*
*FUNCTION -- THIS ROUTINE IS CALLED AFTER A WRITE SEQUENTIAL
*   OPERATION HAS COMPLETED.  ITS PURPOSE IS TO WAIT ON ANY
*   OUTSTANDING I/O AND TO INITIATE AND COMPLETE THE I/O
*   AND DIRECTORY UPDATING FOR THE LAST BLOCK.  THE LAST
*   BUFFER PROCESSED IS ALWAYS KNOWN FROM THE 'BUFCURNT'
*   FIELD.
*
*ENTRY POINTS --
*       IKJEBEWP             -VIA A CALL FROM IKJEBEUT
*
*INPUT --  REGISTER 1 POINTS TO A 3-WORD PARAMETER LIST.
*       WORD1-   ADDRESS OF WORKAREA/DCB
*       WORD2-   NOT USED.
*       WORD3-   NOT USED.
*
*OUTPUT --  THE OPERATION TAKES PLACE AS DESCRIBED ABOVE. THE
*       REGISTERS ARE DESCRIBED UNDER 'EXIT' BELOW.
*
*EXTERNAL REFERENCES --
*       IKJEBEWB             -WRITES OUT BLOCKS
*       IKJEBEWA             -WAITS ON THE I/O
*       IKJEBEDU             -UPDATES THE DIRECTORY
*
*EXITS,NORMAL --  RETURNS TO THE CALLING ROUTINE.  THE OUTPUT
*   IS DESCRIBED ABOVE.  REGISTER 15 CONTAINS A RETURN CODE
*   OF ZERO.
*
*EXITS,ERROR --  RETURNS TO THE CALLING ROUTINE WITH REGISTER 15
*   CONTAINING A RETURN CODE OF 12.
*
*TABLES/WORK AREAS --  THIS ROUTINE IS DEPENDENT ON THE VECTOR
*   TABLE FOR EXTERNAL REFERENCES.
*
*ATTRIBUTES --  REFRESHABLE,ENABLED,NON-PRIVILEGED
*
*NOTES --  REGISTER CONVENTIONS ARE AS FOLLOWS-
*       BASEREG              -BASE REGISTER
*       COMMREG              -VECTOR TABLE ADDRESSES
*       DATAREG              -WORKAREA/DCB ADDRESSING
*       WORK6                -BUFFER ADDRESSING
*       WORK7                -BUFFER ADDRESSING
*       WORK5                -WORK REGISTER
*
*   THIS ROUTINE IS CHARACTER CODE INDEPENDENT.
*
*****************************************************************
         SPACE 2
IKJEBEWP CSECT
*   PERFORM THE INITIALIZATION OPERATIONS HERE
         SAVE  (14,12),T,*             SAVE THE REGS
         LR    BASEREG,ENTRY           BASE ADDRESSING
         USING IKJEBEWP,BASEREG        ADDRESSABILITY
         L     DATAREG,WORD1(PARMREG1) WORKAREA
         USING UTILWORK,DATAREG        ADDRESSABILITY
         L     COMMREG,VTABLE          VECTOR TABLE
         USING VECTABLE,COMMREG        ADDRESSABILITY
         SPACE 2
*   SET UP A SAVE AREA
         LA    WORK5,SAVEAREA          1ST SAVEAREA
         ST    SAVEREG,WORD2(,WORK5)   OLD AREA TO NEW
         ST    WORK5,WORD3(,SAVEREG)   NEW AREA TO OLD
         LR    SAVEREG,WORK5           NEW SAVEAREA
         SPACE 2
*   GET ADDRESS OF BUFFER CURRENTLY BEING WRITTEN
*     ADDRESS OF THE NEXT BUFFER
         L     WORK7,BUFCURNT          LAST BUFFER PROCESSED
         USING BUFFER,WORK6            ADDRESSABILITY
         L     WORK6,BBKCHAIN-BUFFER(WORK7)  PREV. BUFFER ADDR.
         SPACE 2
WP40     TM    BUFSTATS,WAITB          PREVIOUS WAITING
         BO    WP70                    NO--GO WRITE CURRENT
         SPACE 2
*   INITIATE THE WRITE ON THE CURRENT BUFFER
WP50     ST    WORK7,PARM2             BUFFER ADDRESS
         LA    PARMREG1,PARM1          PARM LIST ADDR.
         L     ENTRY,WB                ROUTINE ADDRESS
         CALL  (15)                    WRITE THE BLOCK
         LTR   RETCDREG,RETCDREG       ANY ERRORS
         BNZ   WP130                   YES-GO EXIT
         SPACE 2
WP60     NI    DCBSTATS,ALL-DCBSEQ     OPERATION COMPLETE
         LR    WORK6,WORK7             CURRENT BUFFER
         SPACE 2
*   WAIT FOR THE COMPLETION OF THE I/O HERE
WP70     ST    WORK6,PARM2             BUFFER ADDR. TO LIST
         LA    PARMREG1,PARM1          PARM LIST ADDR.
         L     ENTRY,WA                ROUTINE ADDRESS
         CALL  (15)                    WAIT FOR I/O
         LTR   RETCDREG,RETCDREG       ANY ERRORS
         BNZ   WP130                   YES-GO EXIT
         SPACE 2
*   UPDATE THE DIRECTORY HERE
WP80     MVC   PARM3,BUFTTR            TTR-THIS BLOCK
         LA    WORK5,BUFREF            HIGH KEY//THIS BLOCK
         ST    WORK5,PARM2             ADDR. TO PARM LIST
         LA    PARMREG1,PARM1          PARM LIST ADDR.
         MVI   DIRCODE(PARMREG1),ALLKEY ENTIRE ENTRY
         L     ENTRY,DU                ROUTINE ADDRESS
         CALL  (15)                    UPDATE DIRECTORY
         LTR   RETCDREG,RETCDREG       ANY ERRORS
         BNZ   WP130                   YES-GO EXIT
         SPACE 2
*   CHECK TO SEE IF ALL BUFFERS PROCESSED
WP100    TM    DCBSTATS,DCBSEQ         ARE WE FINISHED
         BO    WP50                    NO--TAKE ONE MORE PASS
         SPACE 2
*   NORMAL EXIT HERE
WP120    SR    RETCDREG,RETCDREG       RETURN CODE=0
*   ERROR EXIT HERE
WP130    SR    WORK5,WORK5             CLEAR
         ST    WORK5,BUFCURNT          INITIALIZE TO 0
         STH   WORK5,BUFCTR            INITIALIZE TO 0
         L     SAVEREG,WORD2(,SAVEREG) OLD SAVE AREA
         RETURN (14,12),T,RC=(15)      RESTORE REGS
         SPACE 2
WPPATCH  DC    C'ZAP HERE'
         DC    7D'0'
         SPACE 2
         DROP  BASEREG,DATAREG,COMMREG,WORK6        RELEASE
 TITLE 'EDIT COMMAND ACCESS METHOD --WRITE A RECORD --- IKJEBEWR'
***********************************************************************
*                                                                     *
*STATUS -- VERSION NO. 02, VS2     RELEASE NO. 03                    *
*                                                                     *
*FUNCTION --  THIS ROUTINE IS CALLED TO PLACE NEW RECORDS IN THE      *
*   DATA SET.  A CHECK IS ALWAYS MADE TO SEE IF A RECORD EXISTS       *
*   WITH THE SAME KEY VALUE AS THE NEW INPUT RECORD.  IF A RECORD     *
*   EXISTS WITH THE SAME KEY VALUE, THE LENGTH OF THE OLD RECORD      *
*   IS CHECKED TO SEE IF THE NEW RECORD WILL FIT IN ITS PLACE. IF     *
*   THE OLD RECORD IS THE SAME SIZE OR LARGER, THE NEW RECORD         *
*   IS MOVED TO THE SAME POSITION AND NO DIRECTORY UPDATING IS        *
*   NECESSARY.                                                        *
*        IN THE EVENT THAT THE NEW RECORD IS LARGER, THE OLD RECORD   *
*   IS DELETED BY USING THE RECORD REMOVAL ROUTINE, IKJEBEDL.  THAT   *
*   BLOCK IS THEN CHECKED TO SEE IF THERE IS SPACE FOR THE NEW RECORD.*
*   ANYTIME A RECORD LOGICALLY BELONGS IN A BLOCK AND THERE IS        *
*   INSUFFICIENT SPACE, IT IS SPLIT INTO TWO DATA BLOCKS.             *
*        IF THE KEY OF THE INPUT RECORD IS UNIQUE, THE NEW INPUT      *
*   RECORD MUST BE INSERTED IN THE DATA BLOCK WHERE IT LOGICALLY      *
*   BELONGS.  AGAIN, AS IN THE ABOVE CASE, THE DATA BLOCK MAY BE      *
*   REQUIRED TO BE SPLIT INTO TWO DATA BLOCKS.                        *
*        WHENEVER A NEW RECORD BECOMES THE LAST LOGICAL RECORD OF     *
*   A DATA BLOCK OR DATA BLOCKS ARE SPLIT, THE DIRECTORY IS UPDATED   *
*   BY CALLING THE DIRECTORY UPDATE ROUTINE, IKJEBEDU.                *
*        ANYTIME A BUFFER IS MODIFIED, ITS 'UPDATE' FLAG WILL BE      *
*   TURNED ON SO THAT THEY GET WRITTEN OUT, IF NECESSARY              *
*                                                                     *
*ENTRY POINT --                                                       *
*       IKJEBEWR             -VIA A CALL FROM IKJEBEUT                *
*                                                                     *
*INPUT --  REGISTER 1 POINTS TO A THREE WORD PARAMETER LIST           *
*       WORD1-   ADDRESS OF THE WORKAREA                              *
*       WORD2-   ADDRESS OF NEW RECORD TO BE PLACED IN DATA SET       *
*       WORD3-   NOT USED                                             *
*                                                                     *
*OUTPUT --  THE SPECIFIED RECORD HAS BEEN PLACED IN THE DATA SET      *
*   THE REGISTERS ARE DESCRIBED UNDER 'EXIT' BELOW.                   *
*                                                                     *
*EXTERNAL REFERENCES --                                               *
*       IKJEBELO             -CHECK IF RECORD EXISTS                  *
*       IKJEBEDL             -DELETE THE OLD RECORD                   *
*       IKJEBEDU             -UPDATE THE DIRECTORY                    *
*       IKJEBEAD             -DETERMINE TTR FOR NEW BLOCK             *
*       IKJEBEMV             -MOVES DATA OR CONTROL INFORMATION       *
*       IKJEBEWB             -WRITE OUT DATA BLOCKS                   *
*       GETMAIN              -GET CORE FOR NEW BLOCKS
*       FREEMAIN             -RELEASE CORE FOR BLOCKS
*                                                                     *
*EXITS,NORMAL --  OUTPUT AS DESCRIBED ABOVE.  REGISTER 15 CONTAINS    *
*   A RETURN CODE OF 0.                                               *
*                                                                     *
*EXITS,ERROR --  RETURNS TO THE CALLING ROUTINE WITH A RETURN CODE    *
*   OF 12.                                                            *
*                                                                     *
*TABLES/WORK AREAS --                                                 *
*       DEPENDENT ON THE VECTOR TABLE FOR EXTERNAL REFERENCES.        *
*                                                                     *
*ATTRIBUTES -- REFRESHABLE, NON-PRIVILEGED, ENABLED                   *
*                                                                     *
*NOTES --  REGISTER CONVENTIONS AREAS FOLLOWS-                        *
*       BASEREG              -BASE REGISTER                           *
*       COMMREG              -VECTOR TABLE ADDRESSING                 *
*       DATAREG              -WORK AREA ADDRESSING                    *
*       WORK6,8              -BUFFER ADDRESSES
*       WORK7,9              -BLOCK ADDRESSES
*       WORK2                -INPUT RECORD ADDRESS                    *
*       WORK3,WORK4,WORK5    -WORK REGISTERS                          *
*                                                                     *
*   THIS SUBROUTINE IS CHARACTER CODE INDEPENDENT                     *
*                                                                     *
***********************************************************************
         SPACE 2
         SPACE
IKJEBEWR CSECT                         WRITE A RECORD
*   PERFORM THE INITIALIZATION OPERATIONS HERE
         SAVE  (14,12),T,*             SAVE THE REGISTERS
         LR    BASEREG,ENTRY           ENTRY POINT ADDRESS
         USING IKJEBEWR,BASEREG        ADDRESSABILITY
         L     DATAREG,WORD1(PARMREG1) WORKAREA/DCB
         USING UTILWORK,DATAREG        ADDRESSABILITY
         L     COMMREG,VTABLE          ROUTINE ADDRESSED
         USING VECTABLE,COMMREG        ADDRESSABILITY
         LA    WORK5,SAVEAREA          NEW SAVE AREA
         ST    SAVEREG,WORD2(,WORK5)   OLD ADDRESS TO NEW
         ST    WORK5,WORD3(,SAVEREG)   NEW ADDRESS TO OLD
         LR    SAVEREG,WORK5           NEW SAVE AREA
         SPACE 2
*   CHECK IF THE RECORD ALREADY EXISTS
         L     WORK2,WORD2(,PARMREG1)  ADDRESS OF RECORD
WR10     LA    PARMREG1,PARM1          PARM LIST ADDRESS
         LA    DATAREG,X0(DATAREG)     OPTION CODE=0
         ST    DATAREG,PARM1           CODE AND DCB TO LIST
         MVC   PRIMEKEY(KEYL),X0(WORK2) INPUT KEY VALUE
         L     ENTRY,LO                ENTRY POINT ADDRESS
         CALL  (15)                    CHECK FOR RECORD
         TM    DCBSTATS,ERROR          ANY I/O ERRORS
         BO    WR200                   YES--RETURN
         LTR   RETCDREG,RETCDREG       DOES RECORD EXIST
         BNZ   WR100                   NO--GO PROCESS NEW RECORD
         SPACE 2
*   YES, THE RECORD EXISTS // COMPARE THE LENGTHS
         L     WORK6,WORD2(,PARMREG1)  BUFFER ADDR. WITH RECORD
         USING BUFFER,WORK6            BUFFER ADDRESSABILITY
         L     WORK7,BUFBLOCK          BLOCK ADDR. WITH RECORD
         USING DATA,WORK7              BLOCK ADDRESSABILITY
         L     WORK5,BUFREF            LOCATOR ADDRESS
         LH    WORK5,X0(WORK5)         LOCATOR CONTENTS
         LA    WORK5,DATA(WORK5)       OLD RECORD ADDRESS
         CLC   KEYL(L2,WORK2),KEYL(WORK5) IS NEW RECORD LARGER
         BNH   WR180                   NO--GO PROCESS
         SPACE 2
*   NEW RECORD CANNOT GO INTO THE OLD RECORD POSITION
*   DELETE THE OLD RECORD // PROCESS NEW RECORD AS INITIAL ENTRY
         ST    WORK6,PARM2             BUFFER ADDRESS
         LA    PARMREG1,PARM1          PARM LIST ADDRESS
         L     ENTRY,DL                ROUTINE ADDRESS
         CALL  (15)                    DELETE OLD RECORD
         TM    DCBSTATS,ERROR          ANY ERRORS
         BO    WR200                   YES-RETURN
         B     WR10                    PROCESS NEW RECORD
         SPACE 2
WR100    CH    RETCDREG,WREMPTY        IS DATASET EMPTY
         BE    WR150                   YES-GO PROCESS RECORD
         SPACE 2
*   CHECK IF SPACE IS AVAILABLE IN THE DATA BLOCK
         L     WORK6,WORD2(PARMREG1)   BUFFER ADDRESS
         L     WORK7,BUFBLOCK          BLOCK ADDRESS
         LH    WORK3,NUMREC            NO. OF RECORDS IN BLOCK
         LA    WORK3,CTRLEND-DATA+LOCL+KEYL(WORK3,WORK3) PLUS
*                                      BLOCK AND RECORD OVERHEAD
         LH    WORK4,DATASTRT          DISPLACEMENT TO THE
*                                      1ST PHSICAL RECORD
         SR    WORK4,WORK3             WORK4=AVAILABLE SPACE
         CH    WORK4,KEYL(WORK2)       IS SPACE AVAILABLE
*                                      FOR THE NEW RECORD
         BNL   WR170                   YES-PLACE RECORD IN BLOCK
         SPACE 2
*   DETERMINE IF  NEW BLOCK IS REQUIRED, SPACE CAN BE RECLAIMED,
*     OR THE OLD BLOCK MUST BE SPLIT.
         LH    WORK3,NUMREC            NO. OF RECORDS
         AR    WORK3,WORK3             TIMES TWO
         LH    WORK3,LOCATORS-LOCL(WORK3) LAST LOCATOR CONTENTS
         LA    WORK3,DATA(WORK3)       ADDRESS OF LAST RECORD
         CLC   X0(KEYL,WORK2),X0(WORK3) NEW KEY TO LAST OLD
         BH    WR150                   NO SPLIT NECESSARY
         SPACE 2
*   THE NEW RECORD LOGICALLY BELONGS IN THIS BLOCK AND
*     THERE IS INSUFFICIENT SPACE
*   CHECK FOR RECLAIMABLE SPACE
         SPACE 2
         LH    WORK3,KEYL(WORK2)       NEW RECORD LENGTH
         LA    WORK3,KEYL(,WORK3)      PLUS KEY LENGTH
         AH    WORK4,RECVSP            AVAIL.+RECOVERABLE
         CR    WORK3,WORK4             SPACE AVAILABLE
         BH    WR110                   NO--DO BLOCK SPLIT
         SPACE 2
*   RECLAIM SPACE HERE FOR THE NEW RECORD
*   GET CORE FOR A NEW BUFFER BLOCK
         MVC   TEMPAREA(WRGMEND-WRGM),WRGM  LIST FORM
         LH    WORK3,DCBBLKSI          GETMAIN SIZE
         LA    PARMREG1,TEMPAREA       PARM LIST ADDR.
         GETMAIN EC,A=TEMPWRD1,LV=(WORK3),MF=(E,(1))  GET CORE
         LTR   RETCDREG,RETCDREG       CORE AVAILABLE?
         BNZ   WR110                   NO--THEN KEEP CORE
*                                      BLOCK AND SPLIT IT.
         L     WORK9,TEMPWRD1          ADDR. OF NEW BLOCK
         XC   NUMREC-DATA(CTRLEND-DATA,WORK9),NUMREC-DATA(WORK9)
*                                      CLEAR CONTROL FIELDS
         LH    WORK5,DCBBLKSI          SIZE OF BLOCK
         STH   WORK5,DATASTRT-DATA(WORK9) SPACE AVAILABLE
WR105    LH    WORK5,NUMREC            RECORDS TO MOVE
         AR    WORK5,WORK5             TIMES TWO
         LH    WORK3,LOCATORS-LOCL(WORK5)  LOCATOR CONTENTS
         LA    WORK3,DATA(WORK3)       RECORD ADDRESS
         MVC   TEMP1(L2),KEYL(WORK3)   RECORD LENGTH
         LH    WORK4,TEMP1             RECORD LENGTH
         LA    WORK4,KEYL(WORK4)       ACCOUNT FOR KEY
         LR    PARMREG0,WORK4          TOTAL LENGTH PARM
         ST    WORK3,TEMP1             MOVE-FROM ADDRESS
         LH    WORK3,DATASTRT-DATA(WORK9) NEXT AVAIL. SPACE
         SR    WORK3,PARMREG0          NEW AVAILABLE
         STH   WORK3,DATASTRT-DATA(WORK9) FOR NEXT PASS
         LA    WORK4,LOCATORS-LOCL-DATA(WORK5,WORK9) NEXT LOC.
         STH   WORK3,X0(WORK4)         RECORD LOCATOR
         LA    WORK3,X0(WORK3,WORK9)   NEW RECORD ADDR.
         ST    WORK3,TEMP2             MOVE-TO ADDRESS
         LH    WORK4,NUMREC-DATA(WORK9) NEW BLOCK RECORDS
         LA    WORK4,ONE(,WORK4)       PLUS ONE
         STH   WORK4,NUMREC-DATA(WORK9) NEW TOTAL
         LA    PARMREG1,TEMP1          PARM LIST ADDR.
         L     ENTRY,MV                ROUTINE ADDRESS
         CALL  (15)                    MOVE THE RECORD
         LH    WORK5,NUMREC            OLD BLOCK COUNT
         BCTR  WORK5,X0                LESS ONE MOVED
         STH   WORK5,NUMREC            FOR NEXT PASS
         LTR   WORK5,WORK5             ANY LEFT TO MOVE
         BNZ   WR105                   YES- REPEAT
         SPACE 2
*   ALL RECORDS HAVE BEEN MOVED
*   NEED TO CLEAN UP THE OLD BLOCK HERE AND CHAIN IN NEW BLOCK
         L     WORK4,BUFBLOCK          OLD BLOCK ADDR.
         ST    WORK9,BUFBLOCK          NEW BLOCK ADDR.
         LH    WORK3,DCBBLKSI          SIZE OF BLOCK
         FREEMAIN R,LV=(WORK3),A=(WORK4),SP=SPONE RELEASE CORE
         LR    WORK7,WORK9             NEW BLOCK ADDRESS
         B     WR170                   HANDLE AS SPACE AVAIL.
*                                      FOR NEW RECORD.
         SPACE 2
*   THE DATA BLOCK MUST BE SPLIT
*   GET A NEW BLOCK AND INITIALIZE IT HERE
         SPACE 2
WR110    OI    BUFSTATS,BLKINBUF       SAVE THIS BUFFER
         LA    PARMREG1,PARM1          PARM LIST ADDRESS
         L     ENTRY,AD                ROUTINE ADDRESS
         CALL  (15)                    ADD A BLOCK
         LTR   RETCDREG,RETCDREG       ANY ERRORS
         BNZ   WR200                   YES-RETURN
         NI    BUFSTATS,ALL-BLKINBUF   RESET BUFFER SAVE
         L     WORK8,WORD2(PARMREG1)   NEW BUFFER ADDRESS
         L     WORK9,BUFBLOCK-BUFFER(WORK8) BLOCK ADDRESS
         XC   NUMREC-DATA(CTRLEND-DATA,WORK9),NUMREC-DATA(WORK9)
         LH    WORK5,DCBBLKSI          BLOCKSIZE
         STH   WORK5,DATASTRT-DATA(WORK9) SPACE AVAILABLE
         SPACE 2
*   BLOCK MUST BE SPLIT
         LH    WORK3,NUMREC            TOTAL RECORDS
         LA    WORK3,ONE(WORK3)        PLUS ONE
         SRA   WORK3,ONE               DIVIDE BY TWO
         LA    WORK5,LOCATORS          ALWAYS DELETE 1ST
         ST    WORK5,BUFREF              LOGICAL RECORD
WR115    LH    WORK5,LOCATORS          MOVE 1ST LOGICAL RECORD
         LA    WORK5,DATA(WORK5)       RECORD ADDRESS
         MVC   TEMP1(L2),KEYL(WORK5)   LENGTH OF RECORD
         LH    WORK4,TEMP1             PICK UP LENGTH
         LA    WORK4,KEYL(WORK4)       ACCOUNT FOR KEY
         LR    PARMREG0,WORK4          SET LENGTH PARM
         ST    WORK5,TEMP1             MOVE FROM ADDRESS
         LH    WORK5,DATASTRT-DATA(WORK9) NEXT AVAILABLE
         SR    WORK5,PARMREG0          NEW AVAILABLE
         STH   WORK5,DATASTRT-DATA(WORK9) SAVE FOR NEXT
         LH    WORK4,NUMREC-DATA(WORK9) NO. OF RECORDS
         AR    WORK4,WORK4             TIMES TWO
         LA    WORK4,LOCATORS-DATA(WORK4,WORK9) NEXT POSITION
         STH   WORK5,X0(WORK4)         OFFSET TO RECORD
         LA    WORK5,X0(WORK5,WORK9)   RECORD ADDRESS
         ST    WORK5,TEMP2             MOVE TO ADDRESS
         LH    WORK4,NUMREC-DATA(WORK9) NO. OF RECORDS
         LA    WORK4,ONE(,WORK4)       PLUS ONE
         STH   WORK4,NUMREC-DATA(WORK9) SAVE NEW TOTAL
         LA    PARMREG1,TEMP1          PARM LIST ADDR.
         L     ENTRY,MV                ROUTINE ADDRESS
         CALL  (15)                    MOVE RECORD
         SPACE 2
*   DELETE THE OLD RECORD HERE
         ST    WORK6,PARM2             BUFFER ADDRESS
         LA    PARMREG1,PARM1          PARM LIST ADDRESS
         L     ENTRY,DL                ROUTINE ADDRESS
         CALL  (15)                    DELETE THE OLD RECORD
         TM    DCBSTATS,ERROR          ANY ERRORS
         BO    WR200                   YES-RETURN
         L     WORK5,DCBRECNO          INSURE CURRENT COUNT
         LA    WORK5,ONE(WORK5)        IS PLUS ONE BECAUSE
         ST    WORK5,DCBRECNO          OF DELETE PROCESS
         BCT   WORK3,WR115             REPEAT FOR (N+1)/2 MOVED
         SPACE 2
*   UPDATE THE DIRECTORY HERE
WR120    OI    BUFSTATS-BUFFER(WORK8),UPDATED MODIFIED BLOCK
         LH    WORK3,NUMREC-DATA(WORK9) RECORDS//NEW BLOCK
         AR    WORK3,WORK3             TIMES TWO
         LH    WORK3,LOCATORS-LOCL-DATA(WORK3,WORK9) CONTENTS
         LA    WORK5,X0(WORK3,WORK9)   RECORD ADDRESS
         ST    WORK5,PARM2             RECORD/KEY ADDRESS
         MVC   PARM3,BUFTTR-BUFFER(WORK8) TTR THIS BLOCK
         LA    PARMREG1,PARM1          PARM LIST ADDRESS
         MVI   DIRCODE(PARMREG1),ALLKEY ENTIRE ENTRY
         L     ENTRY,DU                ROUTINE ADDRESS
         CALL  (15)                    UPDATE THE DIRECTORY
         LTR   RETCDREG,RETCDREG       ANY ERRORS
         BNZ   WR200                   YES-RETURN
         B     WR10                    PROCESS NEW RECORD
         SPACE 2
*   NEED A NEW BLOCK FOR A SINGLE INPUT RECORD
WR150    L     ENTRY,AD                ROUTINE ADDRESS
         CALL  (15)                    GET A BLOCK
         LTR   RETCDREG,RETCDREG       ANY ERRORS
         BNZ   WR200                   YES-RETURN
         OI    DCBSTATS,NBLK           NEW BLOCK OBTAINED
         L     WORK6,WORD2(PARMREG1)   BUFFER ADDRESS
         L     WORK7,BUFBLOCK          BLOCK ADDRESS
         SPACE 2
*   INITIALIZE THE NEW CONTROL FIELDS HERE
WR160    XC    NUMREC(CTRLEND-DATA),NUMREC CLEAR
         LH    WORK5,DCBBLKSI          BLOCKSIZE=SPACE
         STH   WORK5,DATASTRT          AVAILABLE SPACE
*
WR170    LH    WORK5,DATASTRT          NEXT SPACE
         MVC   TEMP1(L2),KEYL(WORK2)   LENGTH OF NEW RECORD
         LH    WORK3,TEMP1             LENGTH
         LA    WORK3,KEYL(WORK3)       ACCOUNT FOR KEY
         SR    WORK5,WORK3             AVAILABLE LESS LENGTH
         STH   WORK5,DATASTRT          SAVE FOR NEXT UPDATE
         SPACE 2
*   SET UP THE RECORD LOCATOR HERE
WR175    LH    WORK5,NUMREC            NO. OF RECORDS
         LA    WORK5,ONE(WORK5)        ACCOUNT FOR NEW RECORD
         AR    WORK5,WORK5             TIMES TWO
WR177    LA    WORK4,LOCATORS-LOCL-LOCL(WORK5) LAST OLD
         BCTR  WORK5,ZERO              RESET INDEX FOR
         BCTR  WORK5,ZERO                NEXT PASS
         LTR   WORK5,WORK5             LAST LOCATOR
         BNP   WR178                   YES-PUT LOCATOR HERE
         MVC   LOCL(LOCL,WORK4),X0(WORK4) SLIDE LOCATOR
         LH    WORK3,X0(WORK4)         CONTENTS
         LA    WORK3,DATA(WORK3)       RECORD ADDRESS
         CLC   PRIMEKEY(KEYL),X0(WORK3) NEW KEY VS OLD
         BL    WR177                   REPEAT UNTIL SLOT FOUND
WR178    MVC   LOCL(LOCL,WORK4),DATASTRT NEW  RECORD LOCATOR
         LH    WORK5,DATASTRT          OFFSET TO RECORD
         LA    WORK5,DATA(WORK5)       RECORD ADDRESS
         SPACE 2
*   UPDATE THE RECORD COUNT FOR THIS BLOCK
         LH    WORK3,NUMREC            CURRENT COUNT
         LA    WORK3,ONE(WORK3)        PLUS ONE
         STH   WORK3,NUMREC            UPDATED COUNT
         SPACE 2
*   UPDATE COUNT FOR TOTAL RECORDS IN DATA SET
         L     WORK3,DCBRECNO          CURRENT COUNT
         LA    WORK3,ONE(,WORK3)       PLUS ONE
         ST    WORK3,DCBRECNO          NEW TOTAL
         SPACE 2
*   MOVE THE NEW RECORD TO THE BLOCK
*   WORK5 CONTAINS THE ADDRESS AT WHICH
*     THE RECORD SHOULD BE PLACED
WR180    MVC   TEMP1(L2),KEYL(WORK2)   LENGTH
         LH    WORK3,TEMP1             LENGTH OF RECORD
         LA    PARMREG0,KEYL(,WORK3)   PLUS KEY
         ST    WORK5,TEMP2             MOVE-TO ADDRESS
         ST    WORK2,TEMP1             MOVE-FROM ADDRESS
         LA    PARMREG1,TEMP1          PARM LIST ADDRESS
         L     ENTRY,MV                ROUTINE ADDRESS
         CALL  (15)                    MOVE THE RECORD
         SPACE 2
*   INDICATE THAT THE BLOCK HAS BEEN MODIFIED
WR190    OI    BUFSTATS,UPDATED        DATA SET CHANGED
         SPACE 2
*   CHECK IF THE DIRECTORY NEEDS UPDATING HERE
         LH    WORK5,NUMREC            NO. OF RECORDS
         AR    WORK5,WORK5             TIMES TWO
         LH    WORK5,LOCATORS-LOCL(WORK5) CONTENTS OF LAST
*                                        LOCATOR
         LA    WORK5,DATA(WORK5)       LAST RECORD ADDR.
         CLC   X0(KEYL,WORK2),X0(WORK5) THIS THE INPUT RECORD
         BNE   WR195                   NO--DIRECTORY OK
         SPACE 2
*   UPDATE THE DIRECTORY HERE
         ST    WORK2,PARM2             NEW KEY ADDRESS
         MVC   PARM3,BUFTTR            TTR THIS BLOCK
         ST    DATAREG,PARM1           DCB/WORKAREA
         LA    PARMREG1,PARM1          PARM LIST ADDR.
         MVI   DIRCODE(PARMREG1),NEWKEY KEY ONLY CODE
         TM    DCBSTATS,NBLK           DID WE GET NEW BLOCK
         BZ    WR192                   NO--UPDATE DIRECTORY
         MVI   DIRCODE(PARMREG1),ALLKEY ALL ENTRY UPDATE
WR192    L     ENTRY,DU                ROUTINE ADDRESS
         CALL  (15)                    UPDATE DIRECTORY
         LTR   RETCDREG,RETCDREG       ANY ERRORS
         BNZ   WR200                   YES-RETURN
         SPACE 2
*   CLEAN UP SWITCHES AND CONTROLS HERE
WR195    NI    DCBSTATS,ALL-DSEMPTY-NBLK SET OFF
         SR    RETCDREG,RETCDREG       RETURN CODE
         SPACE 2
*   ERROR EXIT HERE
WR200    L     SAVEREG,WORD2(SAVEREG) OLD SAVE AREA
         RETURN (14,12),T,RC=(15)  RESTORE REGISTERS
         SPACE 2
*   CONSTANT AREA FOR IKJEBEWR
WREMPTY  DC    H'8'                    CONSTANT/EMPTY DATA SET
         SPACE 2
WRGM     GETMAIN EC,LV=0,A=0,SP=SPONE,MF=L  LIST FORM
WRGMEND  EQU   *                       END OF LIST
         SPACE 2
         DROP  BASEREG,DATAREG,COMMREG,WORK6,WORK7
 TITLE 'EDIT COMMAND ACCESS METHOD--WRITE SEQUENTIAL ROUTINE--IKJEBEWS'
*****************************************************************
*
*STATUS --  VERSION NO. 02, VS2     RELEASE 03                        *
*
*FUNCTION --  THIS ROUTINE IS CALLED WHENEVER IT IS NECESSARY
*   PLACE RECORDS IN SEQUENTIAL ORDER IN A NEW UTILITY
*   DATA SET.  AN ATTEMPT IS MADE TO MAKE FULL USE OF THE
*   ALLOTTED DATA BUFFERS.  THE DATA BUFFERS ARE IN A CIRCULAR
*   CHAIN AND PROCESSING ALWAYS BEGINS WITH THE FIRST BUFFER.
*   WHEN A BUFFER IS FULL, A CHECK IS MADE TO SEE IF THERE IS
*   ANY OUTSTANDING I/O.  IF SO, THIS I/O IS CHECKED FOR
*   SATISFACTORY COMPLETION AND THE DIRECTORY IS UPDATED FOR THE
*   BLOCK THAT WAS JUST WRITTEN OUT. A 'WRITE' IS THEN INITIATED
*   ON THE NEWLY FILLED BLOCK AND PROCESSING BEGINS WITH THE
*   NEXT BUFFER. WHEN THE NEXT BUFFER IS FILLED, THE ABOVE
*   DESCRIBED OPERATION IS REPEATED.
*
*   ALL WRITES ARE BSAM FORMAT WRITES.  NO PREFORMATING OF THE
*   BLOCK IS NECESSARY.  FILLING THE NEXT BUFFER IS ALWAYS
*   OVERLAPPED WITH THE PRECEDING WRITE.
*
*   AT THE COMPLETION, THERE MAY BE OUTSTANDING I/O AND A
*   PARTIALLY FILLED BLOCK THAT NEEDS TO BE WRITTEN OUT.  THESE
*   I/O OPERATIONS ARE ACCOMPLISHED IN THE WRITE-PURGE ROUTINE
*   (IKJEBEWP) VIA A CALL FROM THE UTILITY INTERFACE ROUTINE
*   (IKJEBEUT).  THIS ROUTINE NEVER KNOWS WHEN THE LAST ENTRY
*   IS MADE TO IT.
*
*ENTRY POINT --
*       IKJEBEWS             -VIA A CALL FROM IKJEBEUT
*
*INPUT --  REGISTER 1 POINTS TO A THREE WORD PARM LIST
*       WORD1  ADDRESS OF WORKAREA/DCB
*       WORD2  ADDRESS OF INPUT RECORD
*       WORD3  NOT USED
*
*OUTPUT -- THE SPECIFIED RECORD HAS BEEN PLACED IN THE DATA SET.
*   DIRECTORY UPDATES AND I/O TAKE PLACE AS DESCRIBED ABOVE.
*   THE REGISTERS ARE DESCRIBED UNDER EXIT BELOW.
*
*EXTERNAL REFERENCES --
*       IKJEBEWB             -WRITE OUT BLOCK
*       IKJEBEWA             -WAIT ON I/O
*       IKJEBEDU             -UPDATE DIRECTORY
*       IKJEBEMV             -MOVE RECORD TO BLOCK
*
*EXITS,NORMAL --  OUTPUT AS DESCRIBED ABOVE. RETURN CODE = 0.
*
*EXITS,ERROR --  RETURNS TO THE CALLING ROUTINE WITH A RETURN
*   CODE OF 12.
*
*TABLES/WORKAREAS --
*       DEPENDENT ON THE VECTOR TABLE FOR EXTERNAL REFERENCES.
*
*ATTRIBUTES --  REFRESHABLE,NON-PRIVILIGED,ENABLED.
*
*NOTES --  REGISTER CONVENTIONS ARE AS FOLLOWS
*       BASEREG              -BASE REGISTER
*       COMMREG              -VECTOR TABLE
*       DATAREG              -WORKAREA/DCB
*       WORK2                -INPUT RECORD ADDRESS
*       WORK6,WORK8          -BUFFER ADDRESSES
*       WORK7,WORK9          -BLOCK ADDRESSES
*       WORK3,4,5            -WORK REGISTERS
*
*   THIS ROUTINE IS CHARACTER CODE INDEPENDENT.
*
*****************************************************************
         SPACE 2
IKJEBEWS CSECT
*   PERFORM THE INITIALIZATION OPERATIONS HERE
         SAVE  (14,12),T,*             SAVE THE REGISTERS
         LR    BASEREG,ENTRY           BASE REGISTER
         USING IKJEBEWS,BASEREG        BASE ADDRESSING
         L     DATAREG,WORD1(PARMREG1) DATA AREA
         USING UTILWORK,DATAREG        WORKAREA ADDRESSABILITY
         L     COMMREG,VTABLE          VECTOR TABLE ADDRESS
         USING VECTABLE,COMMREG        ADDRESSABILITY
         SPACE 2
*   SET UP A SAVE AREA
         LA    WORK5,SAVEAREA          FIRST SAVE AREA
         ST    SAVEREG,WORD2(WORK5)    OLD ADDRESS TO NEW
         ST    WORK5,WORD3(SAVEREG)    NEW ADDRESS TO OLD
         LR    SAVEREG,WORK5           NEW SAVEAREA ADDRESS
         SPACE 2
*   TEST FOR FIRST ENTRY
WS10     L     WORK2,WORD2(PARMREG1)   INPUT RECORD ADDRESS
         ST    DATAREG,PARM1           DCB ADDRESS TO PARM LIST
         TM    DCBSTATS,DCBSEQ         IS THIS 1ST ENTRY
         BZ    WS100                   YES-GO START 1ST BLOCK
         SPACE 2
*   NOT FIRST ENTRY //  FIND NEXT BUFFER TO PROCESS
WS20     L     WORK6,BUFCURNT          LAST BUFFER PROCESSED
         USING BUFFER,WORK6            ADDRESSABILITY
         SPACE 2
*   DETERMINE IF SPACE IS AVAILABLE HERE
WS30     L     WORK7,BUFBLOCK          BLOCK ADDRESS
         USING DATA,WORK7              ADDRESSABILITY
         LH    WORK3,NUMREC            NO. OF RECORDS
         LA    WORK3,CTRLEND-DATA+LOCL+KEYL(WORK3,WORK3) PLUS
*                                      BLOCK AND RECORD OVERHEAD
         LH    WORK4,DATASTRT          DISPLACEMENT/1ST RECORD
         SR    WORK4,WORK3             WORK4=AVAILABLE SPACE
         CH    WORK4,KEYL(WORK2)       IS SPACE AVAILABLE
         BNL   WS150                   YES-PUT RECORD IN BLOCK
         SPACE 2
*   CHECK IF THERE IS AN OUTSTANDING WRITE OPERATION
         L     WORK8,BBKCHAIN-BUFFER(WORK6)  PREVIOUS BUFFER
         TM    BUFSTATS-BUFFER(WORK8),WAITB  WAITING?
         BZ    WS40                    NO--GO WRITE BLOCK
         SPACE 2
*   WAIT FOR THE I/O HERE
         ST    WORK8,PARM2             BLOCK ADDRESS
         LA    PARMREG1,PARM1          PARM LIST ADDRESS
         L     ENTRY,WA                ROUTINE ADDRESS
         CALL  (15)                    WAIT FOR THE I/O
         LTR   RETCDREG,RETCDREG       ANY ERRORS
         BNZ   WS190                   YES-RETURN
         SPACE 2
*   UPDATE THE DIRECTORY HERE
         L     WORK9,BUFBLOCK-BUFFER(WORK8) BLOCK ADDRESS
         MVC   PARM3,BUFTTR-BUFFER(WORK8)  TTR TO LIST
         LA    WORK3,BUFREF-BUFFER(WORK8)  HIGH KEY ADDRESS
         ST    WORK3,PARM2             ADDR. TO PARM LIST
         LA    PARMREG1,PARM1          PARM LIST ADDRESS
         MVI   DIRCODE(PARMREG1),ALLKEY  ENTIRE ENTRY
         L     ENTRY,DU                ROUTINE ADDRESS
         CALL  (15)                    UPDATE DIRECTORY
         LTR   RETCDREG,RETCDREG       ANY ERRORS
         BNZ   WS190                   YES-RETURN
         SPACE 2
*    SPACE IS NOT AVAILABLE IN THIS BLOCK
*    INITIATE A WRITE ON THIS BLOCK
WS40     ST    WORK6,PARM2             BUFFER ADDRESS
         LA    PARMREG1,PARM1          PARM LIST ADDRESS
         L     ENTRY,WB                ROUTINE ADDRESS
         CALL  (15)                    WRITE OUT BLOCK
         LTR   RETCDREG,RETCDREG       ANY ERRORS
         BNZ   WS190                   YES-RETURN
         SPACE 2
WS50     L     WORK6,BUFCHAIN          NEXT BUFFER ADDRESS
         ST    WORK6,BUFCURNT          CURRENT BUFFER
         B     WS130                   SET UP NEW BLOCK
         SPACE 2
*   START WITH THE FIRST AVAILABLE BLOCK HERE
WS100    LA    WORK6,BUF1              1ST BUFFER ADDR.
         ST    WORK6,BUFCURNT          INDICATE CURRENT BUFFER
         OI    DCBSTATS,DCBSEQ         SEQ. OPERATION STARTED
         NI    DCBSTATS,ALL-DSEMPTY    NOT EMPTY NOW
         SPACE 2
*   INITIALIZE THE NEXT BLOCK HERE
WS130    OI    BUFSTATS,NEWBLK         WILL BE NEW BLOCK
         L     WORK7,BUFBLOCK          BLOCK ADDRESS
         XC    NUMREC(CTRLEND-DATA),NUMREC CLEAR CNTL. FIELDS
         LH    WORK5,DCBBLKSI          BLOCK SIZE IS TOTAL
         STH   WORK5,DATASTRT            AVAIL. SPACE IN BLOCK
         SPACE 2
*   PLACE THE RECORD IN THE BLOCK HERE
WS150    LH    WORK5,DATASTRT          OFFSET TO SPACE
         MVC   TEMP1(L2),KEYL(WORK2)   LENGTH OF NEW RECORD
         LH    PARMREG1,TEMP1          LENGTH OF RECORD
         LA    PARMREG1,KEYL(PARMREG1) ACCOUNT FOR KEY
         SR    WORK5,PARMREG1          OFFSET TO NEW RECORD
         STH   WORK5,DATASTRT            TO CONTROL BLOCK
         LA    WORK5,DATA(WORK5)       OFFSET PLUS BLOCK ADDR.
         ST    WORK5,TEMP2               THE MOVE TO-ADDR.
         ST    WORK2,TEMP1             MOVE FROM ADDRESS
         LR    PARMREG0,PARMREG1       NO. OF BYTES TO MOVE
         LA    PARMREG1,TEMP1          PARM LIST ADDR.
         L     ENTRY,MV                ROUTINE ADDRESS
         CALL  (15)                    MOVE THE RECORD
         SPACE 2
*   UPDATE THE BLOCK CONTROL FIELDS HERE
WS160    LH    WORK4,NUMREC            PREVIOUS NO. OF RECORDS
         LA    WORK4,ONE(,WORK4)       ACCOUNT FOR NEW RECORD
         STH   WORK4,NUMREC            UPDATED TOTAL
         SPACE 2
WS170    LR    WORK5,WORK4             RECORD COUNT
         SLA   WORK5,ONE               TIMES TWO
         LA    WORK4,LOCATORS-LOCL(WORK5) ADDR. OF NEW LOCATOR
         MVC   X0(LOCL,WORK4),DATASTRT NEW LOCATOR IN BLOCK
         MVC   PRIMEKEY,ZERO(WORK2)    HIGH KEY //THIS BLOCK
         MVC   BUFREF,PRIMEKEY         HIGH KEY THIS BLOCK
         L     WORK4,DCBRECNO          RECORDS IN DATA SET
         LA    WORK4,ONE(WORK4)        ADD ONE
         ST    WORK4,DCBRECNO          NEW TOTAL
         SPACE 2
*   NORMAL EXIT HERE
WS180    SR    RETCDREG,RETCDREG       RETURN CODE=0
*   ERROR EXIT HERE
WS190    L     SAVEREG,WORD2(,SAVEREG) OLD SAVE AREA
         RETURN (14,12),T,RC=(15)      RESTORE REGS/RETURN
         SPACE 2
         DROP  COMMREG,BASEREG,DATAREG,WORK6,WORK7
         SPACE 2
WSPATCH DC     C'ZAP HERE'
         DC    7D'0'
 TITLE 'EDIT COMMAND ACCESS METHOD--WORKAREA/BUFFER DESCRIPTIONS'
         IKJEBEUW
         EJECT
CVT      DSECT
         CVT   SYS=MVT
***********************************************************************
         END
