         TITLE 'IKJEFF16 && 17 - SUBMIT PCL AND EXIT FOR PARSE'
*    GEN(TITLE  'IKJEFF16 && IKJEFF17 - SUBMIT PCL AND EXIT FOR PARSE')
         TITLE  'IKJEFF16 && IKJEFF17 - SUBMIT PCL AND EXIT FOR PARSE'
*  /*******************************************************************
*  /*                                                                 *
*  /*     MODULE NAME = IKJEFF16                                      *
*  /*        CSECT NAME = IKJEFF16 - PARSE PCL, PCE CONTROL BLOCKS    *
*  /*        CSECT NAME = IKJEFF17 - PARSE VALIDITY CHECK EXIT        *
*  /*                                                                 *
*  /*     DESCRIPTIVE NAME = SUBMIT'S PARSE PCL AND EXIT ROUTINE      *
*  /*                                                                 *
*  /*******************************************************************
*  /*                                                                 *
*  /*     COPYRIGHT = NONE                                            *
*  /*                                                                 *
*  /*     STATUS     CHANGE LEVEL=Y02656  SCHEDULER PROTECTION        *
*  /*                             Y02993  SCHEDULER MODULE OWNERSHIP  *
*  /*                                                                 *
*  /*     FUNCTION                                                    *
*  /*               . MODULE 16  CONSISTS  OF  PARSE  PCL'S,          *
*  /*                 CODED WITH THE PARSE MACROS.                    *
*  /*                                                                 *
*  /*               . MODULE 17 IS ENTERED FROM PARSE AS  AN          *
*  /*                 EXIT.  IT BUILDS DAIR08 BLOCKS AND THE          *
*  /*                 DD   ELEMENT   CHAIN,   USED   BY  THE          *
*  /*                 PARSALLOC AND READING ROUTINES.  (04 AND 05)    *
*  /*                                                                 *
*  /*               . THE TWO CSECTS ARE PART  OF  THE  SAME          *
*  /*                 MODULE  TO  SATISFY THE REQUIREMENT OF          *
*  /*                 HAVING AN 'ADCON' REFERENCE  FROM  THE          *
*  /*                 PCL MACRO TO THE EXIT.                          *
*  /*                                                                 *
*  /*     OPERATION                                                   *
*  /*               . CHECK THE INPUT PARSE DATA SET NAME PDE AND     *
*  /*                 BUILD A DAIR 08 BLOCK AND SUBMIT EXTENSION      *
*  /*                 BLOCK FOR THE DATA SET.  (IF THE SAME           *
*  /*                 DATA SET NAME WAS ENTERED MORE THAN ONCE        *
*  /*                 ON THE SUBMIT COMMAND DUPLICATE DAIR 08         *
*  /*                 BLOCKS ARE ELIMINATED FROM THE CHAIN, THOUGH    *
*  /*                 EACH ENTRY GETS A SUBMIT EXTENSION BLOCK.)      *
*  /*                                                                 *
*  /*               . IF THE DATA SET NAME WAS ENTERED IN QUOTES,     *
*  /*                 DON'T PASS IT TO IKJDFLT FOR CHECKING (ASSUME   *
*  /*                 IT'S CATALOGED - IF IT ISN'T IKJDAIR WILL CATCH *
*  /*                 THE ERROR LATER).                               *
*  /*                                                                 *
*  /*               . OTHERWISE PASS THE DSNAME TO IKJDFLT, AND TELL  *
*  /*                 IT TO PREFIX THE TSO ID AND SUFFIX .CNTL TO     *
*  /*                 THE NAME THAT WAS ENTERED (ID.NAMEONCMD.CNTL)   *
*  /*                                                                 *
*  /*               . IF IKJDFLT SAYS IT COULDN'T FIND THAT NAME IN   *
*  /*                 THE CATALOG, CALL IKJDFLT AGAIN, TELLING IT     *
*  /*                 TO JUST PREFIX THE TSO ID (IT WILL PROMPT THE   *
*  /*                 USER IF DUPLICATE NAMES ARE FOUND IN THE        *
*  /*                 CATALOG).                                       *
*  /*                                                                 *
*  /*               . IF STILL GET ERROR RETURN, ANALYZE THE RETURN   *
*  /*                 CODE.  ISSUE AN ERROR MESSAGE IF IKJDFLT        *
*  /*                 DIDN'T ISSUE ONE ALREADY.  THEN RETURN TO       *
*  /*                 PARSE WITH A PROMPTING RETURN CODE (IF POSSIBLE *
*  /*                 TO RECOVER WHEN USER REENTERS A DATA SET NAME)  *
*  /*                 OR AN ERROR RETURN CODE.                        *
*  /*                                                                 *
*  /*     ENTRY POINTS                                                *
*  /*              IKJEFF17                                           *
*  /*                                                                 *
*  /*     INPUT                                                       *
*  /*               . REGISTER  1  POINTS  TO  A   LIST   OF          *
*  /*                 POINTERS TO THE FOLLOWING PARAMETERS            *
*  /*                                                                 *
*  /*                             PARSE DATA SET NAME PDE             *
*  /*                             EXIT WORK AREA                      *
*  /*                                                                 *
*  /*     OUTPUT                                                      *
*  /*           PARAMETER LIST POINTED TO BY REG 1                    *
*  /*           RETURN CODE IN REGISTER 15                            *
*  /*                                                                 *
*  /*     EXTERNAL REFERENCES                                         *
*  /*              IKJDFLT                                            *
*  /*                                                                 *
*  /*     EXITS, NORMAL                                               *
*  /*              RETURN TO CALLER (IKJPARS)                         *
*  /*                                                                 *
*  /*     EXITS,ERROR                                                 *
*  /*           RETURN TO CALLER                                      *
*  /*           - R.C.  8 TELLS PARSE TO PROMPT WITH 'REENTER'        *
*  /*           - R.C. 12 MEANS TERMINATE PROCESSING THE COMMAND.     *
*  /*                                                                 *
*  /*     TABLE/WORK AREAS                                            *
*  /*              PARSE EXIT WORK AREA      UPDATE                   *
*  /*              PARSE DATA SET NAME PDE   REF                      *
*  /*              DAIR08 BLOCK  (IKJDAP08)  CREATE IN SUBPOOL 1      *
*  /*              DD ELEMENT CHAIN=IKJEFFD8 CREATE IN SUBPOOL 1      *
*  /*              MSGTABLE      (IKJEFFMT)  UPDATE                   *
*  /*              PARSE PCL'S, PCE'S        CREATE                   *
*  /*                (IKJPARM, IKJPOSIT, IKJKEYWD, IKJNAME, IKJENDP)  *
*  /*                                                                 *
*  /*     EXECUTABLE MACROS                                           *
*  /*              FREEMAIN, GETMAIN                                  *
*  /*                                                                 *
*  /*     ATTRIBUTES                                                  *
*  /*              REENTRANT AND REFRESHABLE                          *
*  /*              SUPERVISOR STATE, KEY 0                            *
*  /*                (SEE SUBPOOL NOTES IN IKJEFF04'S PROLOGUE)       *
*  /*                                                                 *
*  /*     NOTES                                                       *
*  /*              CHARACTER CODE DEPENDENCY - EBCDIC CHARACTER SET   *
*  /*              USED IN ASSEMBLING, MUST BE REASSEMBLED IF ANOTHER *
*  /*              CHARACTER SET IS USED FOR EXECUTION.               *
*  /*                                                                 *
*  /*        MESSAGES (SEE IKJEFF03 FOR MESSAGE ID'S AND              *
*  /*                  DESCRIPTIONS)                                  *
*  /*                                                                 *
*  /*              17A  COMMAND SYSTEM ERROR - <DEFAULT>              *
*  /*                   ERROR CODE <NNN>                              *
*  /*                                                                 *
*  /*              17B  INVALID DATA SET NAME <DSNAME> EXCEEDS        *
*  /*                   44 CHARACTERS                                 *
*  /*                                                                 *
*  /*              17C  DATA SET <DSNAME> NOT IN CATALOG              *
*  /*                                                                 *
*  /*     PATCH NAME = PATCH                                          *
*  /*                                                                 *
*  /*     CHANGE ACTIVITY = Y02656 (ONE OS APAR, FIXED AS PTM YM3631) *
*  /*       APAR/PTM HISTORY -                                        *
*  /*         OS/VS2 RELEASE 2 -                                      *
*  /*           YM3631 = 'REENTER' PROMPT IF SUBMIT ((MEMBERNAME))    *
*  /*           C 112000,112500                               @YM3631 *
*  /*           A 114550                                      @YM3631 *
*  /*           D 113000,113500,143500-145000                 @YM3631 *
*  /*                                                                 *
*  /*******************************************************************
*    GEN;
         LCLA  &T,&SPN
IKJEFF17 CSECT
         B     18(0,15)
         DC    AL1(8)
         DC    CL8'IKJEFF17'
         DC    CL5'11/73'                                       @YM3631
         AGO   .@001
*     IKJEFF17:
*         PROC (DSNPDE, EXAREA) OPTIONS (REENTRANT);
         LCLA  &T,&SPN                                            0003
.@001    ANOP                                                     0003
IKJEFF17 CSECT ,                                                  0003
         STM   @E,@C,12(@D)                                       0003
         BALR  @B,0                                               0003
@PSTART  DS    0H                                                 0003
         USING @PSTART+00000,@B                                   0003
         L     @0,@SIZ001                                         0003
         GETMAIN  R,LV=(0)                                        0003
         LR    @C,@1                                              0003
         USING @DATD+00000,@C                                     0003
         LM    @0,@1,20(@D)                                       0003
         XC    @TEMPS(@L),@TEMPS                                  0003
         ST    @D,@SAV001+4                                       0003
         LA    @F,@SAV001                                         0003
         ST    @F,8(0,@D)                                         0003
         LR    @D,@F                                              0003
*
*         RESTRICT (2,3,4,5,6);
*
*
*    /* DECLARES FOR DAIR08 BLOCK AND EXTENSION */
*
*         DCL DAPB0PTR PTR REG(2); /* POINTER TO DAIR08 BLOCK  @Y02993*
*
*
** DECLARE
**   1 DAPB08    BASED(DAPB0PTR),
** /* *************************************************************** *
** /* S OPERATION CODE CAUSES ALLOCATION OF A DATA SET. IT CAN ALLOC. *
** /* HER A NEW OR OLD SET.                                           *
** /* *************************************************************** *
**    2 DA08CD   CHAR(2),             /* DAIR ENTRY CODE              *
**    2 DA08FLG  CHAR(2),            /* FUNCTIONS PERFORMED WHEN
**                                       RETURN CODE= 0               *
**     3 DA08FPE  BIT(1),             /* FUNCT PERFORMED BUT ERROR
**                                       INDICATED BY RETCD           *
**     3 *        BIT(1),             /* RESERVED                     *
**     3 *        BIT(1),             /* RESERVED                     *
**     3 *        BIT(1),             /* RESERVED                     *
**     3 *        BIT(1),             /* RESERVED                     *
**     3 *        BIT(1),             /* RESERVED                     *
**     3 *        BIT(1),             /* RESERVED                     *
**     3 *        BIT(1),             /* RESERVED                     *
**    2 DA08DARC FIXED(15),           /*DYN  ALLOC                    *
**    2 DA08CTRC FIXED(15),           /* CATALOG RETURN CODE          *
**    2 DA08PDSN PTR(31),             /* POINTER TO DSNAME TO BE
**                                       SEARCHED IN DSE              *
**    2 DA08DDN  CHAR(8),             /* DDNAME TO BE SEARCHED IN DSE *
**    2 DA08UNIT CHAR(8),             /* UNITNAME REQUESTED           *
**    2 DA08SER  CHAR(8),             /* VOLUME SERIAL NUMBER-PADDED
**                                       W/BLANKS                     *
**    2 DA08BLK  CHAR(4),             /* DATA SET                     *
**    2 DA08PQTY CHAR(4),             /* PRIMARY SPACE QUANTITY       *
**    2 DA08SQTY CHAR(4),             /* SECONDARY SPACE QUANTITY     *
**    2 DA08DQTY CHAR(4),             /* DIRECTORY BLOCK QUANTITY     *
**    2 DA08MNM  CHAR(8),             /* MEMBER NAME                  *
**    2 DA08PSWD CHAR(8),             /* PASSWORD                     *
**    2 DA08DSP1 CHAR(1),             /* DATA SET STATUS FLGS(IF=0
**                                       OLD ASSUMED)                 *
**     3 *        BIT(1),             /* RESERVED                     *
**     3 *        BIT(1),             /* RESERVED                     *
**     3 *        BIT(1),             /* RESERVED                     *
**     3 *        BIT(1),             /* RESERVED                     *
**     3 DA08SHR  BIT(1),             /* DATA SET IS SHR              *
**     3 DA08NEW  BIT(1),             /* DATA SET IS NEW              *
**     3 DA08MOD  BIT(1),             /* DATA SET IS MOD              *
**     3 DA08OLD  BIT(1),             /* DATA SET IS OLD              *
**    2 DA08DPS2 CHAR(1),             /* DATA SET DISPOSITION(IF=0
**                                       KEEP ASSUMED)                *
**     3 *        BIT(1),             /* RESERVED                     *
**     3 *        BIT(1),             /* RESERVED                     *
**     3 *        BIT(1),             /* RESERVED                     *
**     3 *        BIT(1),             /* RESERVED                     *
**     3 DA08KEEP BIT(1),             /* DS DISP IS KEEP              *
**     3 DA08DEL  BIT(1),             /* DS DISP IS DELETE            *
**     3 DA08CAT  BIT(1),             /* DS DISP IS CATLG             *
**     3 DA08UCAT BIT(1),             /* DS DISP IS UNCATALOG         *
**    2 DA08DPS3 CHAR(1),             /* DATA SET CONDITIONAL
**                                       DISPOSITION                  *
**     3 *        BIT(1),             /* RESERVED                     *
**     3 *        BIT(1),             /* RESERVED                     *
**     3 *        BIT(1),             /* RESERVED                     *
**     3 *        BIT(1),             /* RESERVED                     *
**     3 DA08KEP  BIT(1),             /* DS DISP OF KEEP DESIRED      *
**     3 DA08DELE  BIT(1),
**     3 DA08CATL  BIT(1),
**     3 DA08UNCT  BIT(1),
**    2 DA08CTL  CHAR(1),             /* FLAGS TO CONTROL ACTIONS
**                                       TAKEN BY DAIR                *
**     3  DA08TRKS  BIT(1),             /*SPACE UNITS REQUESTED       *
**     3  DA08ABKL  BIT(1),
**     3  DA08UID  BIT(1),
**     3  DA08RLSE BIT(1),
**     3  DA08PERM BIT(1),
**     3  DA08DMMY BIT(1),
**     3  DA08ATRL BIT(1),              /*ATTR LIST SUPPLIED    C99236*
**     3  *  BIT(1),                    /*                      C99236*
**    2 *        CHAR(3),             /* RESERVED                     *
**    2 DA08DSO  CHAR(1),             /* DSORG                  C99236*
**    2 DA08ALN  CHAR(8);             /* ATTR-LIST-NAME         C99236*
**
*           DCL 1 D08ADDED BASED(ADDR(DAPB08)+LENGTH(DAPB08)),
*               2 D08EXTRA,
*
*           /* THIS AREA IS ADDED TO THE 'DAIR08' PARM BLOCK AREA
*              AND IS USED TO CONTAIN THE NAME OF THE DATA SET AND
*              ITS LENGTH, TOGETHER WITH AN ADJUSTMENT VALUE USED
*              TO 'STRIP OFF' THE USERID, AND A POINTER TO THE NEXT
*              SIMILAR DAIR08 AREA */
*
*                 3 NEXT08 PTR BDY (WORD),
*                 3 D8SWITS,
*                   4 D8ADJUST PTR (8),
*                   4 D8SPARE CHAR (1),
*                 3 ORIGNAME BDY (HWORD),
*                   4 NAMELEN FIXED (15),
*                   4 DSNAME CHAR (44),
*               2 ENDEXTRA CHAR (1);
*         /* DECLARE FOR THE INPUT DATA-SET-NAME PDE FROM PARSE */
*         DCL
*               1 DSNPDE,
*                                    /* THIS IS THE CURRENT PDE FOR
*                                       THE DATA SET NAME NOW BEING
*                                       PROCESSED BY PARSE */
*                 2 PDEDSNPT PTR,
*                 2 PDEDSNLN FIXED (15),
*                 2 PDEFLG1 CHAR (1),
*                   3 PDEDSNB BIT (1),
*                                    /* 1 IF DSN PRESENT */
*                   3 PDEQUOTE BIT (1),
*                                    /* 1 IF DSN QUOTED */
*                 2 * CHAR (1),
*                 2 PDEMEMPT PTR BDY (WORD),
*                 2 PDEMEMLN FIXED (15),
*                 2 PDEFLG2 CHAR (1),
*                   3 PDEMEMB BIT (1),
*                                    /* 1 IF MEMBER */
*                 2 * CHAR (1),
*                 2 PDEPASSP PTR BDY (WORD),
*                 2 PDEPASLN FIXED (15),
*                 2 PDEFLG3 CHAR (1),
*                   3 PDEPASSB BIT (1);
*                                    /* 1 IF PASSWORD */
*         DCL
*               PDEDSNAM CHAR (44) BASED (PDEDSNPT),
*               PDEMEM CHAR (8) BASED (PDEMEMPT),
*               PDEPASS CHAR (8) BASED (PDEPASSP);
*         DCL
*               EXAREA;
*         DCL
*               INTFPTR PTR;
*         DCL
*               SUBPOOL1 PTR(31) INIT('01000000'X); /* FOR GETMAINS OF
*                                            DD AND DAIR08 BLKS-Y02656*
*         DCL
*              1 MSSG (6) STATIC,          /*TABLE WHICH HOUSES THE
*                                            POSSIBLE MESSAGE IDS FOR
*                                            THIS CSECT       */
*                 2 MSG CHAR(4) INIT ('17B ',
*                   '17B ',
*                   '17C ',
*                   '17C ',
*                   '17A ',
*                   '17A ');
*         DCL
*              1 ERRR (6) STATIC,           /*TABLE TO BE USED IN SEARC
*                                             OF POSSIBLE RETURN CODES
*                                             FROM DEFAULT RTN*/
*                 2 ERROR CHAR(4) INIT ('00000010'X,
*                   '00000008'X,
*                   '00000014'X,
*                   '00000024'X,
*                   '0000001C'X,
*                   '00000000'X);
*         DCL
*               1 ERRR2 (2) STATIC,      /*TABLE TO BE USED IN SEARCH
*                                           OF THOSE RETURN CODES FOR
*                                           WHICH DEFAULT WILL PUT OUT
*                                           THE ERROR MESSAGE */
*                  2 EROR2 CHAR(4) INIT ('00000004'X,
*                    '0000000C'X);
*         DCL
*               1 PARSWORK BASED(INTFPTR),
*                                    /* AREA USED TO MAKE THE
*                                       CONNECTION BETWEEN PARSING OF
*                                       DATA SET NAMES AND ALLOCATING
*                                       THEM */
*                 2 DDCHAIN PTR,
*                                    /* ANCHOR FOR THE DDNAME CHAIN- 8
*                                       BYTES- PTR TO DAIR08 BLK THAT
*                                       HAS DDNAME AND POINTER TO THE
*                                       NEXT CHAIN ELEMENT */
*                 2 DAIR08PT PTR,
*                                    /* ANCHOR FOR DAIR08'S */
*                 2 PARSPSCB PTR,
*                                    /* PT TO PSCB, WHICH HAS USERID
*                                       AND LEN */
*                 2 EXUPT PTR,
*                 2 EXECT PTR,
*                 2 EXECB PTR,
*                 2 DEFAULT PTR,
*                 2 MSGPTR PTR,
*                 2 DAIR8CT FIXED (15),
*                                    /* CT OF 08 BLOCKS */
*                 2 SWA CHAR (1),
*                 2 SWB CHAR (1),
*                 2 LAST08 PTR BDY (WORD),
*                 2 LASTDD PTR,
*                 2 DSNCT FIXED(15);    /* HAS # OF SUBMITTED DATA SETS
*                                          - WILL NOT = DAIR08CT IF HAV
*                                          SUBMIT WITH SAME DATA SET
*                                          TWICE                      *
*         DCL
*               UPT BASED (EXUPT),
*               ECT BASED (EXECT),
*               ECB BASED (EXECB);
*         DCL
*               IKJDFLT ENTRY BASED (DEFAULT);
*         DCL
*               R13 PTR REG (13),
*               PTBACK PTR BASED (R13+4),
*               OLDR1 BASED (PTBACK+24),
*               R15SLOT BASED (PTBACK+16);
*         DCL
*               R0 REG (0),
*               R1 REG (1);
*         DCL
*               I REG (6);
*         DCL
*               K REG (5);
*         DCL
*               L;
*         DCL
*               PTR08 PTR REG (2);
*         DCL
*               DDPTR PTR REG (3);   /* WORKING BASE FOR DDNAMES
*                                       ELEMENT */
*         DCL
*               1 DDNAMES BASED (DDPTR),
*                 2 DDELEMNT,
*                   3 DD08PTR PTR,
*                   3 DDNEXT PTR,
*                 2 DDEND;
*         DCL
*               COMPTR PTR REG (4);  /* WORKING POINTER USED FOR
*                                       COMPARE OF DATA SET NAMES WHEN
*                                       CHECKING FOR DUPLICATIONS */
*         DCL
*               R15 REG (15);
*         DCL
*               DFLTWORD CHAR(7) INIT('DEFAULT'); /* INSERT IN MSG 17A*
*         DCL
*               1 DEFPARMS,
*                                    /* PARAMETER AREA PASSED TO THE
*                                       DATA SET NAMING DEFAULT
*                                       ROUTINE IKJDFLT */
*                 2 DEFDSN PTR,
*                   3 DEFCODE CHAR (1),
*                 2 DEFPSCB PTR,
*                   3 DEFCON CHAR (1),
*                 2 DEFQUAL PTR,
*                   3 DEFLOC PTR (8);
*                                    /* LOCATE RETURN CODE COMES BACK
*                                       IN THIS FIELD */
*         DCL
*               DEFCNTL CHAR (8);
*         DCL
*               DEFR15 PTR (31);
*         DCL
*               1 COPY,
*                                    /* THIS FIELD IS USED TO MAKE A
*                                       COPY OF THE DATA SET NAME AND
*                                       IS PASSED TO THE DEFAULT
*                                       ROUTINE IKJDFLT -- IF THE NAME
*                                       IS ACCEPTED BY DEFAULT --
*                                       WHICH MAY OR MAY NOT APPEND
*                                       QUALIFIERS -- IT IS THEN
*                                       COPIED BACK TO THE DSNAME
*                                       FIELD IN THE PDE */
*                 2 COPYLEN FIXED (15),
*                 2 COPYNAME CHAR (44);
*         DCL PATCH(10) CHAR(3) INIT((10)'ZAP'); /* FOR F.E. ZAPS
*                                       -                      @Y02993*
*
**
**/********************************************************************
**/*                                                                  *
**/* *** IKJEFFMT ***     LEVEL= 9/11/73     OS/VS2 RELEASE 02.0      *
**/*                                                                  *
**/* DESCRIPTION - BILINGUAL MAPPING MACRO FOR PARAMETER LIST TO      *
**/*               IKJEFF02 (TSO MESSAGE ISSUER ROUTINE)              *
**/*                                                                  *
**/* FUNCTION    - THE PARAMETER LIST IDENTIFIES A MESSAGE (WHICH     *
**/*               MAY HAVE A SECOND LEVEL MESSAGE), DESCRIBES        *
**/*               INSERT(S) FOR THE MESSAGE, AND INDICATES WHETHER   *
**/*               TO ISSUE THE MESSAGE AS A PUTLINE, PUTGET, WTO,    *
**/*               OR A WRITE TO PROGRAMMER.                          *
**/*                                                                  *
**/*               THE PARAMETER LIST ALSO POINTS TO A MESSAGE        *
**/*               CSECT CONTAINING THE MESSAGE'S TEXT.  THE          *
**/*               IKJTSMSG MACRO IS USED TO GENERATE THE             *
**/*               NECESSARY DC'S FOR THE TEXT AND THE OFFSETS        *
**/*               TO INSERTS IN THE MESSAGE.  THE LAST ENTRY IN      *
**/*               THE CSECT MUST BE AN IKJTSMSG MACRO WITH NO        *
**/*               OPERANDS.  SEE THE MICROFICHE LISTING OF MODULE    *
**/*               IKJEFF55 FOR EXAMPLES OF MESSAGE TEXTS GENERATED   *
**/*               BY THE IKJTSMSG MACRO.                             *
**/*                                                                  *
**/*               REGISTER 1 -> MTPARML = MSGTABLE PARMLIST          *
**/*               REGISTER 15 WILL CONTAIN IKJEFF02'S RETURN CODE    *
**/*                           TO THE CALLER                          *
**/*                           (RETURN CODE = 0 IF MESSAGE WAS        *
**/*                           ISSUED SUCCESSFULLY, 12 IF MSGID NOT   *
**/*                           FOUND IN CSECT (MESSAGE ALSO ISSUED),  *
**/*                           OR NONZERO RETURN CODE FROM PUTLINE    *
**/*                           OR PUTGET SERVICE ROUTINE)             *
**/*                                                                  *
**/* METHOD OF ACCESS                                                 *
**/*      PL/S   - %MTNEW='1' - - - - - - IF DON'T WANT BASED         *
**/*               %MTBASE='ANY BASE' - - IF MTNEW ISN'T SPECIFIED,   *
**/*                                       DEFAULTS TO BASED(MSGPTR)  *
**/*               %MTINSRTN='N'  - - - - TO GET INSERT ARRAY WITH N  *
**/*                                       ELEMENTS - DEFAULTS TO     *
**/*                                       4 INSERTS, NO ARRAY        *
**/*               %INCLUDE SYSLIB(IKJEFFMT)                          *
**/*                                                                  *
**/*      BAL    - <<MACRO SPECIFICATION IS                           *
**/*                       IKJEFFMT MTDSECT=XX,MTNINST=XX>>           *
**/*               MTDSECT=YES  IF DON'T WANT TO GET CORE,            *
**/*                 THEN CODE      LA    REG,MYMTCORE  *CALLER AREA* *
**/*                                USING MTDSECTD,REG                *
**/*               MTDSECT=NO  IS THE DEFAULT.                        *
**/*                                                                  *
**/*               MTNINST=NUMBER  SPECIFIES NUMBER OF ENTRIES FOR    *
**/*               INSERTS IN THE PARAMETER LIST.  MTNINST=4 IS       *
**/*               THE DEFAULT.                                       *
**/*                                                                  *
**/* F.E.'S      - MICROFICHE LISTING = IKJEFFMT                      *
**/*                                                                  *
**/********************************************************************
**
**       DCL 1 MSGTABLE
**           BASED(MSGPTR)
*            ,                                /* ** MESSAGE TABLE **  *
*                 2 LISTPTR  PTR (31),        /* PTR TO MSG PARAM LIST*
*                 2 TMCTPTR  PTR (31),        /* PTR TO TMCT          *
*                  3 MTCPPL  PTR(31),         /* (ALSO CALLED CPPL)   *
*                 2 ECBPTR   PTR (31),        /* PTR TO COMM ECB      *
*                 2 *        PTR(31),         /* ** RESERVED **       *
*                  3 MTHIGH  BIT(1),          /* FOR STD LINKAGE      *
*                 2 MSGCSECT PTR (31),        /* **MSG PARAM LIST ** -
*                                                PTR TO MSG CSECT    */
*                 2 SW       PTR  (8),        /* SWITCH BYTE          *
*                  3 MTNOIDSW BIT(1),         /* ON IF DATA, NOT MSG  *
*                  3 MTPUTLSW BIT(1),         /* ON IF WANT PUTLINE,
*                                                NOT PUTGET (PROMPT)  *
*                  3 MTWTOSW  BIT(1),         /* ON IF WANT WTO MSG   *
*                  3 MTHEXSW  BIT(1),         /* ON IF ALL CONVERSIONS
*                                                OF NUMBERS ARE TO
*                                                PRINTABLE HEX
*                                                (X'VALUE'), NOT TO
*                                                PRINTABLE DECIMAL */
*                  3 MTKEY1SW BIT(1),         /* ON IF CALLER IN KEY 1*
*                  3 MTJOBISW BIT(1),         /* ON IF COMPRESS BLANKS
*                                                OUT OF JOBNAME(JOBID)
*                                                INSERT               *
*                  3 MTWTPSW BIT(1),          /* ON IF WANT WRITE TO
*                                                PROGRAMMER MESSAGE   *
*                  3 MTNHEXSW BIT(1),         /* ON IF TRANSLATE ALL
*                                                NUMBERS TO PRINTABLE
*                                                DECIMAL (DEFAULT IS TO
*                                                TRANSLATE TO DECIMAL I
*                                                VALUE IS LESS THAN
*                                                X'FFFF', OTHERWISE
*                                                TRANSLATE TO PRINTABLE
*                                                HEX)                 *
*                 2 RETMSG   PTR (24),        /* PTR TO REPLY AREA    *
*                 2 SW2      PTR(8),          /* SWITCH BYTE 2        *
*                  3 MT2OLDSW BIT(1),         /* ON IF MTOLDPTR POINTS
*                                                TO SECOND LEVEL MSG
*                                                ALREADY IN PUTLINE
*                                                FORMAT (IN OUTPUT LINE
*                                                DESCRIPTOR(OLD) CONTRO
*                                                BLOCK).  IKJEFF02 WILL
*                                                COPY IKJ MSG ID FROM
*                                                FIRST LEVEL INTO FIRST
*                                                SEGMENT OF SECOND LEVE
*                                                MESSAGE.             *
*                  3 MTDOMSW BIT(1),          /* ON IF DELETE WRITE TO
*                                                PROGRAMMER (OR WTO)
*                                                MESSAGES FROM CONSOLE,
*                                                IF THEY ARE DISPLAYED.
*                                                (MTWTOSW OR MTWTPSW
*                                                MUST ALSO BE ON) */
*                  3 *        BIT(6),         /* ** RESERVED **       *
*                 2 *        PTR(24),         /* ** RESERVED **       *
*                 2 MTOLDPTR PTR(31),         /* POINTS TO O.L.D. FOR
*                                                2ND LEVEL MSG IF
*                                                MT2OLDSW IS ON       *
*                 2 *        PTR(31),         /* ** RESERVED **       *
*                 2 *        PTR(31),         /* ** RESERVED **       *
*                 2 MSGID CHAR (4),           /* MESSAGE ID USED TO FIN
*                                                MSG TEXT IN MSGCSECT *
*                 2 MTINSRTS,                 /* USE THIS NAME TO ZERO
*                                                INSERT AREA          *
*                  3 L1       PTR  (8),       /* LENGTH OF INSERT 1   *
*                   4 HIGHL1 BIT (1),         /* ON IF TRANSLATE 1ST
*                                                4 BYTES OF INSERT
*                                                FROM HEX TO CHARACTER
*                                                (IGNORE REST). ALSO SE
*                                                MTHEXSW.             *
*                  3 VAR1     PTR (24),       /* ADDRESS OF INSERT1
*                                                -NOTE- INSERTS FOR
*                                                SECOND LEVEL MSG MUST
*                                                BE FIRST IF PUTLINE  *
*                  3 L2       PTR  (8),       /* LEN OF INSERT2       *
*                   4 HIGHL2 BIT (1),         /* BIT FOR INSERT2      *
*                  3 VAR2     PTR (24),       /* ADDR OF INSERT2      *
*                  3 L3 PTR (8),              /* LEN OF INSERT3       *
*                   4 HIGHL3 BIT (1),         /* BIT FOR INSERT3      *
*                  3 VAR3 PTR (24),           /* ADDR OF INSERT3      *
*                  3 L4 PTR (8),              /* LEN OF INSERT4       *
*                   4 HIGHL4 BIT (1),         /* BIT FOR INSERT4      *
*                  3 VAR4 PTR (24),           /* ADDR OF INSERT4      *
*                 2 MSGRTN   PTR (31);        /* MSG RTN ADDR-NOT USED
*                                                BY IKJEFF02          *
*
*         /* IKJEFFMT - FORMAT OF REPLY FROM TSO USER */
*         DCL 1 RET BDY (WORD) BASED (RETMSG),  /* REPLY TO MESSAGE   *
*                 2 RETSIZE FIXED (15),         /* - SIZE, INCLUDING
*                                                    THESE TWO BYTES  *
*                 2 RETCHAR CHAR (18);          /* - RETURN TEXT      *
*
*         /* IKJEFFMT - CPPL AND ECB POINTED TO BY MESSAGE TABLE */
*         DCL MSGTMCT BASED (TMCTPTR);          /* CPPL FOR MSG RTN   *
*         DCL MSGECB BASED (ECBPTR);            /* ECB FOR MSG RTN    *
*    /*****************************************************************
*    /*  END OF IKJEFFMT MAPPING MACRO                                *
*    /*****************************************************************
*
*         DCL   IKJEFF02 ENTRY BASED (MSGRTN); /* MESSAGE ISSUER
*                                       ROUTINE                @Y02993*
*         /************************************************************
*         /* INITIALIZATION FOR IKJEFF17 CODE                         *
*         /************************************************************
*
*         INTFPTR=ADDR(EXAREA);      /* PICK UP ADDR OF PASSED
*                                       PARAMETER */
         L     @7,4(0,@1)          ADDRESS OF EXAREA              0040
         ST    @7,INTFPTR                                         0040
*
*         /* OBTAIN AND INITIALIZE DAIR08 BLOCK FOR THIS DSNAME */
*         GEN (LA R0,ENDEXTRA-D08EXTRA);
         LA R0,ENDEXTRA-D08EXTRA
         DS    0H
*                                    /*  DETERMINE THE LENGTH OF THE
*                                        ADDITIONS (I.E. DATASET NAME,
*                                        PTR TO NEXT DAIR 08) TO THE
*                                        DAIR BLOCK BEING PASSED & PUT
*                                        THE LENGTH IN REG 0 */
*         R0=(LENGTH(DAPB08)+R0) × SUBPOOL1; /*
*                                        THEN ADD THE ADDITIONS TO THE
*                                        DAIR 08 BLOCK LENGTH
*                                        - H-O BYTE IS SUBPOOL1 Y02656*
         LR    @F,@0                                              0042
         AH    @F,@D1                                             0042
         O     @F,SUBPOOL1                                        0042
         LR    @0,@F                                              0042
*         GEN (GETMAIN R,LV=(0));
         GETMAIN R,LV=(0)
         DS    0H
*         PTR08=R1;                  /*  SAVE REG 1 PASSED FROM PARSE *
         LR    @2,@1                                              0044
*         R1=OLDR1;                  /* OBTAIN THE REG 1 WHICH POINTS T
*                                       THE PARAMETER LIST*/
         L     @8,4(0,@D)          
         L     @1,24(0,@8)                                        0045
*                                    /* GET A BLOCK FOR DAIR08 AND
*                                       CLEAR AND INITIALIZE IT */
*         DAPB08=DAPB08&&DAPB08;
         XC    0(84,@2),0(@2)                                     0046
*         D08EXTRA=D08EXTRA&&D08EXTRA;
         XC    84(52,@2),84(@2)                                   0047
*         DA08CD='0008'X;
         MVC   0(2,@2),@X1                                        0048
*         DA08PDSN=ADDR(NAMELEN);
         LA    @F,90(0,@2)                                        0049
         ST    @F,8(0,@2)                                         0049
*         DA08DDN=' ';
         MVI   12(@2),C' '                                        0050
         MVC   13(7,@2),12(@2)                                    0050
*         DA08MNM=' ';
         MVI   52(@2),C' '                                        0051
         MVC   53(7,@2),52(@2)                                    0051
*         DA08SER=' ';
         MVI   28(@2),C' '                                        0052
         MVC   29(7,@2),28(@2)                                    0052
*         DA08UNIT=' ';
         MVI   20(@2),C' '                                        0053
         MVC   21(7,@2),20(@2)                                    0053
*         /* CHECK DSNAME INFORMATION IN PARSE PDE */
*
*         IF PDEMEMB='1'B THEN
         L     @9,0(0,@1)          ADDRESS OF DSNPDE              0054
         TM    14(@9),B'10000000'                                 0054
         BC    12,@9FF                                            0054
*           DA08MNM(1:PDEMEMLN)= PDEMEM(1:PDEMEMLN);
         L     @7,8(0,@9)          DSNPDE                         0055
         LR    @E,@7                                              0055
         LH    @8,12(0,@9)                                        0055
         BCTR  @8,0                                               0055
         LA    @A,52(0,@2)                                        0055
         EX    @8,@MVC                                            0055
*                                    /* IF THE PRESENCE OF A MEMBER NAM
*                                       IS INDICATED, STORE THE NAME IN
*                                       THE DAIR 08 BLOCK */
*         DA08PSWD=' ';
@9FF     MVI   60(@2),C' '                                        0056
         MVC   61(7,@2),60(@2)                                    0056
*         IF PDEPASSB='1'B THEN
         L     @7,0(0,@1)          ADDRESS OF DSNPDE              0057
         TM    22(@7),B'10000000'                                 0057
         BC    12,@9FE                                            0057
*           DA08PSWD(1:PDEPASLN)= PDEPASS(1:PDEPASLN);
         L     @8,16(0,@7)         DSNPDE                         0058
         LR    @E,@8                                              0058
         LH    @9,20(0,@7)                                        0058
         BCTR  @9,0                                               0058
         LA    @A,60(0,@2)                                        0058
         EX    @9,@MVC                                            0058
*         DA08SHR='1'B;              /* DATA SET DISP IS SHR */
@9FE     OI    68(@2),B'00001000'                                 0059
*         DA08KEEP='1'B;             /* DATA SET DISP IS KEEP */
         OI    69(@2),B'00001000'                                 0060
*         DA08KEP='1'B;              /* ALSO DESIRE TO KEEP THE DATA SE
*                                       AFTER PROCESSING */
         OI    70(@2),B'00001000'                                 0061
*         IF PDEDSNB='1'B THEN       /* IF HAVE DATA SET NAME ENTERED,
*                                       PASS IT TO IKJDFLT     @YM3631*
         L     @7,0(0,@1)          ADDRESS OF DSNPDE              0062
         TM    6(@7),B'10000000'                                  0062
         BC    12,@9FD                                            0062
*           DO;
*             NAMELEN=PDEDSNLN;
         MVC   90(2,@2),4(@7)                                     0064
*             DSNAME(1:NAMELEN)=PDEDSNAM(1:NAMELEN);
         L     @8,0(0,@7)          DSNPDE                         0065
         LR    @E,@8                                              0065
         LH    @9,90(0,@2)                                        0065
         BCTR  @9,0                                               0065
         LA    @A,92(0,@2)                                        0065
         EX    @9,@MVC                                            0065
*           END;                     /* NOTE PDEDSNB='0'B IS LEGAL -
*                                       'ID.CNTL' IS VALID DSNAME
*                                       WHEN SUB ((MEMBER))    @YM3631*
*
*         /* OBTAIN AND INITIALIZE DD CHAIN ELEMENT FOR THIS DSNAME */
*         GEN (LA R0,DDEND-DDNAMES); /* GET AREA FOR DD CHAIN EL */
@9FD     EQU   *                                                  0067
         LA R0,DDEND-DDNAMES
         DS    0H
*         R0 = R0 × SUBPOOL1;        /* GET FROM SUBPOOL 1     @Y02656*
         O     @0,SUBPOOL1                                        0068
*         GEN (GETMAIN R,LV=(0));
         GETMAIN R,LV=(0)
         DS    0H
*         DDPTR=R1;                  /* PUT THE ADDR OF THE GOTTEN CORE
*                                       IN THE DD ELEMENT POINTER SO DD
*                                       CHAIN MAY BE BUILT */
         LR    @3,@1                                              0070
*         R1=OLDR1;                  /* RESTORE REG 1 TO POINT TO THE
*                                       PARAMETER LIST */
         L     @7,4(0,@D)          
         L     @1,24(0,@7)                                        0071
*         DDELEMNT=DDELEMNT&&DDELEMNT;
         XC    0(8,@3),0(@3)                                      0072
*                                    /* ZERO THE DD ELEMENT OUT */
*
*         /* DON'T CALL DEFAULT ROUTINE IF DSNAME IS FULLY QUALIFIED */
*         IF PDEQUOTE='1'B THEN
         L     @8,0(0,@1)          ADDRESS OF DSNPDE              0073
         TM    6(@8),B'01000000'                                  0073
*           GO TO COMPARE;           /* IF DSN WAS QUOTED, THEN IT IS
*                                       COMPLETE AS ENTERED, SO NOW
*                                       JUST GO COMPARE FOR
*                                       DUPLICATION */
         BC    01,COMPARE                                         0074
*         /* CALL DEFAULT SERVICE ROUTINE TO GET FULLY QUALIFIED */
*         /* TSO DATA SET NAME                                   */
*
*         DEFDSN=ADDR(COPY);
         LA    @F,COPY                                            0075
         ST    @F,DEFPARMS                                        0075
*         DEFPSCB=PARSPSCB;
         L     @9,INTFPTR                                         0076
         MVC   DEFPARMS+4(4),8(@9)                                0076
*         DEFCON='20'X;              /* ID TO BE PREFIXED      @Y02993*
         MVI   DEFPARMS+4,X'20'                                   0077
*         DEFQUAL=ADDR(DEFCNTL);
         LA    @F,DEFCNTL                                         0078
         ST    @F,DEFPARMS+8                                      0078
*         DEFCNTL='CNTL';            /* CNTL TO BE ADDED TO FULLY
*                                       QUALIFY THE DATA SET NAME */
         MVC   DEFCNTL(4),@C5                                     0079
         MVI   DEFCNTL+4,C' '                                     0079
         MVC   DEFCNTL+5(3),DEFCNTL+4                             0079
*
*     CALLDEF:
*         COPY=ORIGNAME;
CALLDEF  MVC   COPY(46),90(@2)                                    0080
*         CALL IKJDFLT (UPT,ECT,ECB,DEFPARMS);
         L     @7,INTFPTR                                         0081
         L     @7,12(0,@7)         PARSWORK                       0081
         ST    @7,@PL001                                          0081
         L     @8,INTFPTR                                         0081
         L     @8,16(0,@8)         PARSWORK                       0081
         ST    @8,@PL001+4                                        0081
         L     @9,INTFPTR                                         0081
         L     @9,20(0,@9)         PARSWORK                       0081
         ST    @9,@PL001+8                                        0081
         LA    @F,DEFPARMS                                        0081
         ST    @F,@PL001+12                                       0081
         L     @7,INTFPTR                                         0081
         L     @7,24(0,@7)         PARSWORK                       0081
         LR    @F,@7                                              0081
         LA    @1,@PL001                                          0081
         BALR  @E,@F                                              0081
         L     @1,4(0,@D)                                         0081
         L     @1,24(0,@1)                                        0081
*                                    /* CALL THE DATA SET NAME DEFAULT
*                                       ROUTINE -- FIRST TIME GIVE
*                                       CODE '00' AND IF THAT FAILS
*                                       THEN CALL AGAIN WITH CODE '04'
*                                       -- IF THAT FAILS THEN PUT OUT
*                                       'DATA SET <X> NOT IN CATALOG'
*                                       MESSAGE TO SAY CANNOT QUALIFY
*                                       DSNAME AND TELL PARSE TO HAVE
*                                       THE USER REEENTER THE NAME. */
*         DEFR15=R15;                /* SAVE REG 15 IN CASE IT IS
*                                       CHANGED */
         ST    @F,DEFR15                                          0082
*
*         /* CHECK FOR GOOD RETURN CODE FROM IKJDFLT */
*         IF R15=0 THEN
         LTR   @F,@F                                              0083
         BC    07,@9FA                                            0083
*           DO;                      /* DO/END GROUP           @Y02993*
*                /* CODE TO COMPUTE D8ADJUST VALUE, USED TO STRIP
*                   ID FROM FULLY QUALIFIED TSO DSNAME BEFORE 04,
*                   05 ISSUE ERROR MESSAGES FOR THE DSNAME --
*                   CAN'T USE D8ADJUST = PSCBUSRL+1 BECAUSE THE
*                   DSNAME'S ID NEED NOT BE THE TSO USERID     @Y02993*
*
*             DO D8ADJUST = 1 TO COPYLEN; /* SCAN QUALIFIED DSNAME UNTI
*                                       FIND THE PERIOD FOLLOWING THE I
*                                       FIELD                         *
         LA    @F,1                                               0085
         STC   @F,88(0,@2)                                        0085
@DO9F9   LH    @F,COPY                                            0085
         SR    @0,@0                                              0085
         IC    @0,88(0,@2)                                        0085
         CR    @F,@0                                              0085
         BC    04,@DO9F6                                          0085
         BC    15,@DO9F7                                          0085
@DO9F8   LA    @F,1                                               0085
         SR    @0,@0                                              0085
         IC    @0,88(0,@2)                                        0085
         AR    @F,@0                                              0085
         STC   @F,88(0,@2)                                        0085
         BC    15,@DO9F9                                          0085
*               IF COPYNAME(D8ADJUST) = '.' THEN /* IF HAVE A MATCH   *
@DO9F7   SR    @7,@7                                              0086
         IC    @7,88(0,@2)                                        0086
         LA    @A,COPY+1(@7)                                      0086
         CLI   0(@A),C'.'                                         0086
*                   GO TO HAVELEN;   /* TAKE SUCCESS EXIT FROM LOOP   *
         BC    08,HAVELEN                                         0087
         BC    15,@DO9F8                                          0088
*             END;                   /* END OF DO LOOP TO SCAN DSNAME *
*             D8ADJUST = 0;          /* IF DROP THRU LOOP, SET
*                                       D8ADJUST = ZERO SO ENTIRE
*                                       QUALIFIED DSNAME WILL BE
*                                       INSERTED INTO 04, 05 ERROR
*                                       MESSAGES */
@DO9F6   MVI   88(@2),0                                           0089
* HAVELEN:                           /* SUCCESS EXIT FROM DO LOOP */
*           GO TO COPYBACK;          /* NOW SAVE THE QUALIFIED
*                                       DSNAME IN D08ADDED C.B. */
         BC    15,COPYBACK                                        0090
*           END;                     /* END OF R15=0 CODE      @Y02993*
*         /* PROCESSING FOR ERROR RETURN FROM IKJDFLT */
*         IF DEFCODE='04'X THEN
@9FA     CLI   DEFPARMS,X'04'                                     0092
*               GO TO DFLTERR;       /* TAKE THE SECOND CALL INTO THE
*                                       DEFAULT RTN TO CHECK FOR THE
*                                       DATA SET NAME THAT IS FULLY
*                                       QUALIFIED WITH SOMETHING OTHER
*                                       THAN CNTL */
         BC    08,DFLTERR                                         0093
*         DEFCODE='04'X;
         MVI   DEFPARMS,X'04'                                     0094
*         GO TO CALLDEF;
         BC    15,CALLDEF                                         0095
*     DFLTERR:                       /* THE FIRST SEARCH IS FOR THOSE
*                                       RETURN CODES FOR WHICH DEFAULT
*                                       ITSELF ISSUES A MESSAGE */
*         DO I=1 TO 2;
DFLTERR  LA    @6,1                                               0096
*          IF DEFR15=EROR2(I) THEN
@DO9F5   LR    @7,@6                                              0097
         SLA   @7,2                                               0097
         L     @F,ERRR2-4(@7)                                     0097
         CL    @F,DEFR15                                          0097
         BC    07,@9F1                                            0097
*            DO;                     /* DFLTMSG DO/END GROUP   @Y02993*
*              R15SLOT=12;           /* AN ERROR WAS ENCOUNTERED FROM
*                                       DEFAULT QUALIFY SO TELL PARSE
*                                       TO CLEANUP AND THEN TELL
*                                       SUBMIT TO TERMINATE    @Y02993*
         LA    @F,12                                              0099
         L     @8,4(0,@D)          
         ST    @F,16(0,@8)                                        0099
*              RETURN;               /* EXIT SINCE MSG ISSUED  @Y02993*
         BC    15,@EL01                                           0100
*            END;                    /* DFLTMSG DO/END GROUP   @Y02993*
*         END;
*
*         /* IF DEFAULT DIDN'T ISSUE MESSAGE, ISSUE APPROPRIATE
*            MESSAGE AND THEN HAVE PARSE PROMPT THE USER TO
*            REENTER A DATA SET NAME */
*         R15SLOT=8;                 /* TELLS PARSE TO PROMPT  @Y02993*
@9F1     AH    @6,@D2                                             0102
@DO9F4   CH    @6,@D3                                             0102
         BC    12,@DO9F5                                          0102
         LA    @F,8                                               0103
         L     @7,4(0,@D)          
         ST    @F,16(0,@7)                                        0103
*
*                                    /* FIND THE CORRECT MSG DEALING
*                                       WITH THE DEFAULT ERROR RETURN
*                                       CODE */
*         DO I=1 TO 5;
         LA    @6,1                                               0104
*          IF DEFR15=ERROR(I) THEN
@DO9F0   LR    @7,@6                                              0105
         SLA   @7,2                                               0105
         L     @F,ERRR-4(@7)                                      0105
         CL    @F,DEFR15                                          0105
*            GO TO BADNEWS;
         BC    08,BADNEWS                                         0106
*         END;
*
*
*     BADNEWS:                       /* THIS SECTION OF CODE SETS UP A
*                                       MSG AND THEN CALLS IKJEFF02
*                                       TO PUT IT OUT */
*         MSGID=MSG(I);              /* PICK UP MSG ID */
         AH    @6,@D2                                             0107
@DO9EF   CH    @6,@D4                                             0107
         BC    12,@DO9F0                                          0107
BADNEWS  LR    @7,@6                                              0108
         SLA   @7,2                                               0108
         LA    @E,MSSG-4(@7)                                      0108
         L     @8,INTFPTR                                         0108
         L     @8,28(0,@8)         PARSWORK                       0108
         MVC   40(4,@8),0(@E)                                     0108
*         VAR2=ADDR(DEFR15);         /* SET UP RETURN CODE AS A VARIABL
*                                       TO BE INSERTED */
         LA    @F,DEFR15                                          0109
         ST    @F,@TEMP4                                          0109
         MVC   49(3,@8),@TEMP4+1                                  0109
*         L2='84'X;                  /* INDICATES DECIMAL CONVERSION*/
         MVI   48(@8),X'84'                                       0110
*         VAR1=ADDR(DSNAME);         /* SET UP DATA SET NAME AS A VARI-
*                                       ABLE TO BE INSERTED */
         LA    @F,92(0,@2)                                        0111
         ST    @F,@TEMP4                                          0111
         MVC   45(3,@8),@TEMP4+1                                  0111
*         L1=NAMELEN;                /*OBTAIN LENGTH OF NAME SO MSG
*                                      RTN WILL PUT OUT CORECT AMOUNT*/
         MVC   44(1,@8),91(@2)                                    0112
*         HIGHL1='0'B;               /*INDICATES NO DECIMAL CONVERSION*
         NI    44(@8),B'01111111'                                 0113
*         IF MSGID(3)='A' THEN
         CLI   42(@8),C'A'                                        0114
         BC    07,@9EC                                            0114
*           DO;                      /* ALL ERROR MSGS WILL INCLUDE
*                                       ONLY THE DATA SET NAME EXCEPT
*                                       17A WHICH WILL INCLUDE THE
*                                       ERROR CODE          */
*              VAR1=ADDR(DFLTWORD);  /* INSERT 'DEFAULT' IN
*                                       COMMAND SYSTEM ERROR MSG
*                                       -                      @Y02993*
         LA    @F,DFLTWORD                                        0116
         ST    @F,@TEMP4                                          0116
         MVC   45(3,@8),@TEMP4+1                                  0116
*              L1=LENGTH(DFLTWORD);  /* LENGTH OF INSERT       @Y02993*
         MVI   44(@8),7                                           0117
*           END;
*         IF MSGID(3)='B' THEN
@9EC     L     @7,INTFPTR                                         0119
         L     @7,28(0,@7)         PARSWORK                       0119
         CLI   42(@7),C'B'                                        0119
         BC    07,@9EB                                            0119
*            IF L1>44 THEN
         CLI   44(@7),44                                          0120
         BC    12,@9EA                                            0120
*               L1=44;               /*THIS MSG ONLY ALLOWS THE INSER-
*                                      TION OF A MAX OF 44 CHARACTERS
*                                      FOR A DATASET NAME*/
         MVI   44(@7),44                                          0121
*         R1=MSGPTR;
@9EA     EQU   *                                                  0122
@9EB     L     @7,INTFPTR                                         0122
         L     @1,28(0,@7)                                        0122
*         CALL IKJEFF02;
         L     @8,INTFPTR                                         0123
         L     @8,28(0,@8)         PARSWORK                       0123
         L     @8,60(0,@8)         MSGTABLE                       0123
         LR    @F,@8                                              0123
         BALR  @E,@F                                              0123
*         R1=DDPTR;                  /* FREE DDNAME ELEMENT */
         LR    @1,@3                                              0124
*         GEN (LA R0,DDEND-DDNAMES);
         LA R0,DDEND-DDNAMES
         DS    0H
*         R0 = R0 × SUBPOOL1;        /* FREE FROM SUBPOOL 1     Y02656*
         O     @0,SUBPOOL1                                        0126
*         GEN (FREEMAIN R,LV=(0),A=(1));
         FREEMAIN R,LV=(0),A=(1)
         DS    0H
*     /* FREE THE DAIR 08 BLOCK IF ERROR OR DUPLICATE DSNAME */
*     FREE08:
*         R1=PTR08;                  /* FREE DAIR08 BLOCK */
FREE08   LR    @1,@2                                              0128
*         GEN (LA R0,ENDEXTRA-D08EXTRA);
         LA R0,ENDEXTRA-D08EXTRA
         DS    0H
*         R0=(LENGTH(DAPB08)+R0) × SUBPOOL1; /* FREE FROM SUBPOOL 1
*                                               -               Y02656*
         LR    @F,@0                                              0130
         AH    @F,@D1                                             0130
         O     @F,SUBPOOL1                                        0130
         LR    @0,@F                                              0130
*         GEN (FREEMAIN R,LV=(0),A=(1));
         FREEMAIN R,LV=(0),A=(1)
         DS    0H
*         RETURN;
         BC    15,@EL01                                           0132
*
*         /* SAVE THE QUALIFIED DSNAME RETURNED BY IKJDFLT */
*     COPYBACK:
*         NAMELEN=COPYLEN;
COPYBACK MVC   90(2,@2),COPY                                      0133
*         DSNAME=DSNAME&&DSNAME;     /* ZERO THE ENTIRE DSNAME FIELD
*                                       IN THE DAIR08 AREA -- THIS WAY
*                                       THE COMPARE FOR DUPLICATE
*                                       NAMES AT 'CHECK' WILL BE VALID
*                                       BECAUSE THE DSNAME FIELD WAS
*                                       ORIGINALLY ZEROED WHEN THE
*                                       ENTIRE DAIR08 AREA WAS ZEROED
*                                       */
         XC    92(44,@2),92(@2)                                   0134
*         DSNAME(1:NAMELEN)=COPYNAME(1:NAMELEN);
         LA    @E,COPY+2                                          0135
         LH    @7,90(0,@2)                                        0135
         BCTR  @7,0                                               0135
         LA    @A,92(0,@2)                                        0135
         EX    @7,@MVC                                            0135
*                                    /* COPY THE NAME BACK AS RECEIVED
*                                       FROM THE DEFAULT ROUTINE */
*         /* CHECK FOR DUPLICATE DSNAMES IN DAIR08 BLOCKS */
*     COMPARE:
*                                    /* NOW COMPARE THE DATA SET NAME
*                                       AGAINST THOSE ALREADY CHAINED
*                                       UP IN THE DAIR08 BLOCKS -- THE
*                                       DDNAME PTR IN THE DDNAME CHAIN
*                                       ELEMENT WILL BE SET TO POINT
*                                       TO THE DAIR08 BLOCK FOR THIS
*                                       NAME, EITHER TO AN OLD BLOCK
*                                       OR TO THE CURRENT BLOCK IF THE
*                                       DATA SET NAME IS  NEW (IN
*                                       WHICH CASE THE CURRENT DAIR08
*                                       BLOCK WILL BE ADDED TO THE
*                                       CHAIN) */
*         R15SLOT=0;                 /* INDICATE ALL IS O.K. TO PARSE *
COMPARE  SR    @F,@F                                              0136
         L     @7,4(0,@D)          
         ST    @F,16(0,@7)                                        0136
*         DSNCT = DSNCT + 1;         /* UPDATE COUNT OF SUBMITTED
*                                       DATA SETS              @Y02993*
         LA    @F,1                                               0137
         L     @8,INTFPTR                                         0137
         AH    @F,44(0,@8)                                        0137
         STH   @F,44(0,@8)                                        0137
*         IF DDCHAIN=0 THEN
         SR    @F,@F                                              0138
         C     @F,0(0,@8)                                         0138
         BC    07,@9E9                                            0138
*           DO;                      /* IF THIS IS THE FIRST ONE THEN
*                                       SIMPLY ADD DD ELEMENT AND 08
*                                       BLOCK AS FIRST IN THE CHAINS
*                                       */
*             DDCHAIN=DDPTR;
         ST    @3,0(0,@8)                                         0140
*             DAIR08PT=PTR08;        /* POINT TO THE 08 BLOCK THAT IS
*                                       CURRENTLY ACTIVE */
         ST    @2,4(0,@8)                                         0141
*             DD08PTR=PTR08;         /* ALSO PUT A POINTER IN THE DD
*                                       ELEMENT CHAIN */
         ST    @2,0(0,@3)                                         0142
*             DAIR8CT=DAIR8CT+1;     /* INCREMENT COUNT OF DAIR BLOCK *
         LA    @F,1                                               0143
         AH    @F,32(0,@8)                                        0143
         STH   @F,32(0,@8)                                        0143
*             LAST08=PTR08;          /* SINCE THIS IS THE FIRST DD
*                                       ELEMENT IT ALSO IS THE LAST &
*                                       WILL BE THE ALST AS OTHERS ARE
*                                       ADDED TO THE CHAIN */
         ST    @2,36(0,@8)                                        0144
*             LASTDD=DDPTR;
         ST    @3,40(0,@8)                                        0145
*             RETURN;
         BC    15,@EL01                                           0146
*           END;
*         COMPTR=DAIR08PT;
@9E9     L     @7,INTFPTR                                         0148
         L     @4,4(0,@7)                                         0148
*     CHECK:
*  /* IF ADJUSTMENT IS THE SAME, DSNAME IS THE SAME, MEMBER HAS NOT BEE
*      CHANGED THEN SET THE POINTER TO THE DDCHAIN AND DAIR08BLK */
*         IF COMPTR->D8ADJUST=D8ADJUST THEN
CHECK    CLC   88(1,@4),88(@2)                                    0149
         BC    07,@9E8                                            0149
*           IF COMPTR->DSNAME=DSNAME THEN
         CLC   92(44,@4),92(@2)                                   0150
         BC    07,@9E7                                            0150
*             IF COMPTR->DA08MNM=DA08MNM THEN
         CLC   52(8,@4),52(@2)                                    0151
         BC    07,@9E6                                            0151
*               DO;                  /* MATCH FOUND IF THIS DATA SET
*                                       NAME IS THE SAME AS SOME PRIOR
*                                       ENTRY */
*
*     CHAINDD:
*                 LASTDD->DDNEXT=DDPTR;
CHAINDD  L     @7,INTFPTR                                         0153
         L     @7,40(0,@7)         PARSWORK                       0153
         ST    @3,4(0,@7)                                         0153
*                 LASTDD=DDPTR;      /* ADD EL TO DD CHAIN */
         L     @8,INTFPTR                                         0154
         ST    @3,40(0,@8)                                        0154
*                 DD08PTR=COMPTR;
         ST    @4,0(0,@3)                                         0155
*                 GO TO FREE08;      /* FREE THE DUP 08 BLOCK */
         BC    15,FREE08                                          0156
*           END;
*         COMPTR=COMPTR->NEXT08;
@9E6     EQU   *                                                  0158
@9E7     EQU   *                                                  0158
@9E8     L     @4,84(0,@4)                                        0158
*         IF COMPTR ^=0 THEN
         LTR   @4,@4                                              0159
*           GO TO CHECK;             /* SET WORKING COMPARISON POINTER
*                                       'COMPTR' TO NEXT 08 BLOCK --
*                                       IF NOT 0 THEN REPEAT THE
*                                       COMPARE -- OTHERWISE THIS IS A
*                                       NEW 08 BLOCK */
         BC    07,CHECK                                           0160
*         DAIR8CT=DAIR8CT+1;
         LA    @F,1                                               0161
         L     @7,INTFPTR                                         0161
         AH    @F,32(0,@7)                                        0161
         STH   @F,32(0,@7)                                        0161
*         LAST08->NEXT08=PTR08;
         L     @8,INTFPTR                                         0162
         L     @8,36(0,@8)         PARSWORK                       0162
         ST    @2,84(0,@8)                                        0162
*         LAST08=PTR08;              /* ADD 08 BLOCK TO THIS CHAIN AND
*                                       ADD DD EL TO ITS CHAIN */
         ST    @2,36(0,@7)                                        0163
*         LASTDD->DDNEXT=DDPTR;
         L     @8,INTFPTR                                         0164
         L     @8,40(0,@8)         PARSWORK                       0164
         ST    @3,4(0,@8)                                         0164
*         LASTDD=DDPTR;
         ST    @3,40(0,@7)                                        0165
*         DD08PTR=PTR08;
         ST    @2,0(0,@3)                                         0166
*         RETURN;
         BC    15,@EL01                                           0167
*         GEN;
*        /* CSECT 16 CONSISTS ONLY OF PCL'S FOR PARSE AND IT IS
*            CODED HERE SO THAT MODULE 17 CAN BE ENTERED FROM THE
*            ADDRESS GIVEN IN 16                   */
IKJEFF16 IKJPARM
DSN      IKJPOSIT  DSNAME,                                             X
               LIST,                                                   X
               PROMPT='DATA SET NAME',                                 X
               VALIDCK=IKJEFF17,                                       X
               HELP='NAME OF DATA SET CONTAINING JCL'
NOTIFY   IKJKEYWD  DEFAULT='NOTIFY'
         IKJNAME   'NOTIFY'
         IKJNAME   'NONOTIFY'
         IKJENDP
IKJEFF17  CSECT
         DS    0H
**/*IKJEFF17:          CHART */
**/*HEADER
**/*IKJEFF17              PARSE EXIT ROUTINE */
**/*E ENTER */
**/*P IF THE MEMBER SW IN PDE IS ON, COPY LENGTH OF MEMBER */
**/*P IF PASSWORD SW ON, COPY PASSWORD TO DAIR08 */
**/*P TURN ON SHARE, KEEP & CONDITIONAL KEEP SWS */
**/*D (YES,, NO,%C4) WAS A DATA SET NAME GIVEN */
**/*P COPY THE NAME & ITS LENGTH INTO DAIR08 */
**/*D (NO,,YES,COMPARE) WAS DATA SET NAME IN QUOTES */
**/*CALLDEF: S DEFAULT: CALL DEFAULT RTN */
**/*D (NO,,YES,COMPARE) WERE WE ABLE TO ADD QUALIFIERS */
**/*P (,BADNEWS) A SECOND CALL IS MADE TO DEFAULT FOR QUALIFYING */
**/*COMPARE: D (YES,,NO,CHAINDD) IS THERE A DUPLICATE NAME */
**/*P (,%J5) SET UP DD ELEMENT PTR TO EXISTING DAIR08 BLOCK */
**/*CHAINDD: P ADD ANOTHER DAIR08 BLOCK & DD ELEMENT AS A PTR TO IT */
**/*%J5: R RETURN TO CALLER */
**/*BADNEWS: I PUT OUT DEFAULT ERROR MSG/S      */
**/*%C4: P (,%J5) SEND RETURN CODE OF 8 TO PARSE */
**/*IKJEFF17:       END */
*         END
* /* THE FOLLOWING INCLUDE STATEMENTS WERE FOUND IN THIS PROGRAM.
* /*%INCLUDE SYSLIB  (IKJDAP08)
* /*%INCLUDE SYSLIB  (IKJEFFD8)
* /*%INCLUDE SYSLIB  (IKJEFFMT)
* ;
@EL01    L     @D,4(0,@D)                                         0169
         LR    @1,@C                                              0169
         L     @0,@SIZ001                                         0169
         FREEMAIN R,LV=(0),A=(1)                                  0169
         LM    @E,@C,12(@D)                                       0169
         BCR   15,@E                                              0169
@DATA1   EQU   *
@0       EQU   00                  EQUATES FOR REGISTERS 0-15
@1       EQU   01
@2       EQU   02
@3       EQU   03
@4       EQU   04
@5       EQU   05
@6       EQU   06
@7       EQU   07
@8       EQU   08
@9       EQU   09
@A       EQU   10
@B       EQU   11
@C       EQU   12
@D       EQU   13
@E       EQU   14
@F       EQU   15
@D1      DC    H'84'
@D2      DC    H'1'
@D3      DC    H'2'
@D4      DC    H'5'
@MVC     MVC   0(1,@A),0(@E)
         DS    0F
@SIZ001  DC    AL1(&SPN)
         DC    AL3(@DATEND-@DATD)
         DS    0F
@C5      DC    C'CNTL'
@X1      DC    X'0008'
         DS    0D
@DATA    EQU   *
DAPB0PTR EQU   00000002            FULLWORD POINTER REGISTER
DAPB08   EQU   00000000            84 BYTE(S) ON WORD
DA08CD   EQU   DAPB08+00000000     2 BYTE(S)
DA08FLG  EQU   DAPB08+00000002     2 BYTE(S)
DA08FPE  EQU   DAPB08+00000002     1 BIT(S)
A00000   EQU   DAPB08+00000002     1 BIT(S)
A00001   EQU   DAPB08+00000002     1 BIT(S)
A00002   EQU   DAPB08+00000002     1 BIT(S)
A00003   EQU   DAPB08+00000002     1 BIT(S)
A00004   EQU   DAPB08+00000002     1 BIT(S)
A00005   EQU   DAPB08+00000002     1 BIT(S)
A00006   EQU   DAPB08+00000002     1 BIT(S)
DA08DARC EQU   DAPB08+00000004     HALFWORD INTEGER
DA08CTRC EQU   DAPB08+00000006     HALFWORD INTEGER
DA08PDSN EQU   DAPB08+00000008     FULLWORD POINTER
DA08DDN  EQU   DAPB08+00000012     8 BYTE(S)
DA08UNIT EQU   DAPB08+00000020     8 BYTE(S)
DA08SER  EQU   DAPB08+00000028     8 BYTE(S)
DA08BLK  EQU   DAPB08+00000036     4 BYTE(S)
DA08PQTY EQU   DAPB08+00000040     4 BYTE(S)
DA08SQTY EQU   DAPB08+00000044     4 BYTE(S)
DA08DQTY EQU   DAPB08+00000048     4 BYTE(S)
DA08MNM  EQU   DAPB08+00000052     8 BYTE(S)
DA08PSWD EQU   DAPB08+00000060     8 BYTE(S)
DA08DSP1 EQU   DAPB08+00000068     1 BYTE(S)
A00007   EQU   DAPB08+00000068     1 BIT(S)
A00008   EQU   DAPB08+00000068     1 BIT(S)
A00009   EQU   DAPB08+00000068     1 BIT(S)
A00010   EQU   DAPB08+00000068     1 BIT(S)
DA08SHR  EQU   DAPB08+00000068     1 BIT(S)
DA08NEW  EQU   DAPB08+00000068     1 BIT(S)
DA08MOD  EQU   DAPB08+00000068     1 BIT(S)
DA08OLD  EQU   DAPB08+00000068     1 BIT(S)
DA08DPS2 EQU   DAPB08+00000069     1 BYTE(S)
A00011   EQU   DAPB08+00000069     1 BIT(S)
A00012   EQU   DAPB08+00000069     1 BIT(S)
A00013   EQU   DAPB08+00000069     1 BIT(S)
A00014   EQU   DAPB08+00000069     1 BIT(S)
DA08KEEP EQU   DAPB08+00000069     1 BIT(S)
DA08DEL  EQU   DAPB08+00000069     1 BIT(S)
DA08CAT  EQU   DAPB08+00000069     1 BIT(S)
DA08UCAT EQU   DAPB08+00000069     1 BIT(S)
DA08DPS3 EQU   DAPB08+00000070     1 BYTE(S)
A00015   EQU   DAPB08+00000070     1 BIT(S)
A00016   EQU   DAPB08+00000070     1 BIT(S)
A00017   EQU   DAPB08+00000070     1 BIT(S)
A00018   EQU   DAPB08+00000070     1 BIT(S)
DA08KEP  EQU   DAPB08+00000070     1 BIT(S)
DA08DELE EQU   DAPB08+00000070     1 BIT(S)
DA08CATL EQU   DAPB08+00000070     1 BIT(S)
DA08UNCT EQU   DAPB08+00000070     1 BIT(S)
DA08CTL  EQU   DAPB08+00000071     1 BYTE(S)
DA08TRKS EQU   DAPB08+00000071     1 BIT(S)
DA08ABKL EQU   DAPB08+00000071     1 BIT(S)
DA08UID  EQU   DAPB08+00000071     1 BIT(S)
DA08RLSE EQU   DAPB08+00000071     1 BIT(S)
DA08PERM EQU   DAPB08+00000071     1 BIT(S)
DA08DMMY EQU   DAPB08+00000071     1 BIT(S)
DA08ATRL EQU   DAPB08+00000071     1 BIT(S)
A00019   EQU   DAPB08+00000071     1 BIT(S)
A00020   EQU   DAPB08+00000072     3 BYTE(S)
DA08DSO  EQU   DAPB08+00000075     1 BYTE(S)
DA08ALN  EQU   DAPB08+00000076     8 BYTE(S)
D08ADDED EQU   00000084            53 BYTE(S) ON WORD
D08EXTRA EQU   D08ADDED+00000000   52 BYTE(S) ON WORD
NEXT08   EQU   D08ADDED+00000000   FULLWORD POINTER
D8SWITS  EQU   D08ADDED+00000004   2 BYTE(S) ON WORD
D8ADJUST EQU   D08ADDED+00000004   1  BYTE  POINTER
D8SPARE  EQU   D08ADDED+00000005   1 BYTE(S)
ORIGNAME EQU   D08ADDED+00000006   46 BYTE(S) ON HWORD
NAMELEN  EQU   D08ADDED+00000006   HALFWORD INTEGER
DSNAME   EQU   D08ADDED+00000008   44 BYTE(S)
ENDEXTRA EQU   D08ADDED+00000052   1 BYTE(S)
DSNPDE   EQU   00000000            23 BYTE(S) ON WORD
PDEDSNPT EQU   DSNPDE+00000000     FULLWORD POINTER
PDEDSNLN EQU   DSNPDE+00000004     HALFWORD INTEGER
PDEFLG1  EQU   DSNPDE+00000006     1 BYTE(S)
PDEDSNB  EQU   DSNPDE+00000006     1 BIT(S)
PDEQUOTE EQU   DSNPDE+00000006     1 BIT(S)
A00021   EQU   DSNPDE+00000007     1 BYTE(S)
PDEMEMPT EQU   DSNPDE+00000008     FULLWORD POINTER
PDEMEMLN EQU   DSNPDE+00000012     HALFWORD INTEGER
PDEFLG2  EQU   DSNPDE+00000014     1 BYTE(S)
PDEMEMB  EQU   DSNPDE+00000014     1 BIT(S)
A00022   EQU   DSNPDE+00000015     1 BYTE(S)
PDEPASSP EQU   DSNPDE+00000016     FULLWORD POINTER
PDEPASLN EQU   DSNPDE+00000020     HALFWORD INTEGER
PDEFLG3  EQU   DSNPDE+00000022     1 BYTE(S)
PDEPASSB EQU   DSNPDE+00000022     1 BIT(S)
PDEDSNAM EQU   00000000            44 BYTE(S)
PDEMEM   EQU   00000000            8 BYTE(S)
PDEPASS  EQU   00000000            8 BYTE(S)
EXAREA   EQU   00000000            FULLWORD INTEGER
SUBPOOL1 EQU   *                   FULLWORD POINTER
         DC    XL4'01000000'
MSSG     EQU   @DATA+00000004      6*4 BYTE(S) ON WORD
MSG      EQU   *                   4 BYTE(S)
         DC    C'17B '
         DC    C'17B '
         DC    C'17C '
         DC    C'17C '
         DC    C'17A '
         DC    C'17A '
ERRR     EQU   @DATA+00000028      6*4 BYTE(S) ON WORD
ERROR    EQU   *                   4 BYTE(S)
         DC    X'00000010'
         DC    X'00000008'
         DC    X'00000014'
         DC    X'00000024'
         DC    X'0000001C'
         DC    X'00000000'
ERRR2    EQU   @DATA+00000052      2*4 BYTE(S) ON WORD
EROR2    EQU   *                   4 BYTE(S)
         DC    X'00000004'
         DC    X'0000000C'
PARSWORK EQU   00000000            46 BYTE(S) ON WORD
DDCHAIN  EQU   PARSWORK+00000000   FULLWORD POINTER
DAIR08PT EQU   PARSWORK+00000004   FULLWORD POINTER
PARSPSCB EQU   PARSWORK+00000008   FULLWORD POINTER
EXUPT    EQU   PARSWORK+00000012   FULLWORD POINTER
EXECT    EQU   PARSWORK+00000016   FULLWORD POINTER
EXECB    EQU   PARSWORK+00000020   FULLWORD POINTER
DEFAULT  EQU   PARSWORK+00000024   FULLWORD POINTER
MSGPTR   EQU   PARSWORK+00000028   FULLWORD POINTER
DAIR8CT  EQU   PARSWORK+00000032   HALFWORD INTEGER
SWA      EQU   PARSWORK+00000034   1 BYTE(S)
SWB      EQU   PARSWORK+00000035   1 BYTE(S)
LAST08   EQU   PARSWORK+00000036   FULLWORD POINTER
LASTDD   EQU   PARSWORK+00000040   FULLWORD POINTER
DSNCT    EQU   PARSWORK+00000044   HALFWORD INTEGER
UPT      EQU   00000000            FULLWORD INTEGER
ECT      EQU   00000000            FULLWORD INTEGER
ECB      EQU   00000000            FULLWORD INTEGER
R13      EQU   00000013            FULLWORD POINTER REGISTER
PTBACK   EQU   00000004            FULLWORD POINTER
OLDR1    EQU   00000024            FULLWORD INTEGER
R15SLOT  EQU   00000016            FULLWORD INTEGER
R0       EQU   00000000            FULLWORD INTEGER REGISTER
R1       EQU   00000001            FULLWORD INTEGER REGISTER
I        EQU   00000006            FULLWORD INTEGER REGISTER
K        EQU   00000005            FULLWORD INTEGER REGISTER
PTR08    EQU   00000002            FULLWORD POINTER REGISTER
DDPTR    EQU   00000003            FULLWORD POINTER REGISTER
DDNAMES  EQU   00000000            12 BYTE(S) ON WORD
DDELEMNT EQU   DDNAMES+00000000    8 BYTE(S) ON WORD
DD08PTR  EQU   DDNAMES+00000000    FULLWORD POINTER
DDNEXT   EQU   DDNAMES+00000004    FULLWORD POINTER
DDEND    EQU   DDNAMES+00000008    FULLWORD INTEGER
COMPTR   EQU   00000004            FULLWORD POINTER REGISTER
R15      EQU   00000015            FULLWORD INTEGER REGISTER
DFLTWORD EQU   *                   7 BYTE(S)
         DC    C'DEFAULT'
PATCH    EQU   *                   10*3 BYTE(S)
         DC    00010C'ZAP'
MSGTABLE EQU   00000000            64 BYTE(S) ON WORD
LISTPTR  EQU   MSGTABLE+00000000   FULLWORD POINTER
TMCTPTR  EQU   MSGTABLE+00000004   FULLWORD POINTER
MTCPPL   EQU   MSGTABLE+00000004   FULLWORD POINTER
ECBPTR   EQU   MSGTABLE+00000008   FULLWORD POINTER
A00023   EQU   MSGTABLE+00000012   FULLWORD POINTER
MTHIGH   EQU   MSGTABLE+00000012   1 BIT(S)
MSGCSECT EQU   MSGTABLE+00000016   FULLWORD POINTER
SW       EQU   MSGTABLE+00000020   1  BYTE  POINTER
MTNOIDSW EQU   MSGTABLE+00000020   1 BIT(S)
MTPUTLSW EQU   MSGTABLE+00000020   1 BIT(S)
MTWTOSW  EQU   MSGTABLE+00000020   1 BIT(S)
MTHEXSW  EQU   MSGTABLE+00000020   1 BIT(S)
MTKEY1SW EQU   MSGTABLE+00000020   1 BIT(S)
MTJOBISW EQU   MSGTABLE+00000020   1 BIT(S)
MTWTPSW  EQU   MSGTABLE+00000020   1 BIT(S)
MTNHEXSW EQU   MSGTABLE+00000020   1 BIT(S)
RETMSG   EQU   MSGTABLE+00000021   3  BYTE  POINTER ON WORD+1
SW2      EQU   MSGTABLE+00000024   1  BYTE  POINTER
MT2OLDSW EQU   MSGTABLE+00000024   1 BIT(S)
MTDOMSW  EQU   MSGTABLE+00000024   1 BIT(S)
A00024   EQU   MSGTABLE+00000024   6 BIT(S)
A00025   EQU   MSGTABLE+00000025   3  BYTE  POINTER ON WORD+1
MTOLDPTR EQU   MSGTABLE+00000028   FULLWORD POINTER
A00026   EQU   MSGTABLE+00000032   FULLWORD POINTER
A00027   EQU   MSGTABLE+00000036   FULLWORD POINTER
MSGID    EQU   MSGTABLE+00000040   4 BYTE(S)
MTINSRTS EQU   MSGTABLE+00000044   16 BYTE(S) ON WORD
L1       EQU   MSGTABLE+00000044   1  BYTE  POINTER
HIGHL1   EQU   MSGTABLE+00000044   1 BIT(S)
VAR1     EQU   MSGTABLE+00000045   3  BYTE  POINTER ON WORD+1
L2       EQU   MSGTABLE+00000048   1  BYTE  POINTER
HIGHL2   EQU   MSGTABLE+00000048   1 BIT(S)
VAR2     EQU   MSGTABLE+00000049   3  BYTE  POINTER ON WORD+1
L3       EQU   MSGTABLE+00000052   1  BYTE  POINTER
HIGHL3   EQU   MSGTABLE+00000052   1 BIT(S)
VAR3     EQU   MSGTABLE+00000053   3  BYTE  POINTER ON WORD+1
L4       EQU   MSGTABLE+00000056   1  BYTE  POINTER
HIGHL4   EQU   MSGTABLE+00000056   1 BIT(S)
VAR4     EQU   MSGTABLE+00000057   3  BYTE  POINTER ON WORD+1
MSGRTN   EQU   MSGTABLE+00000060   FULLWORD POINTER
RET      EQU   00000000            20 BYTE(S) ON WORD
RETSIZE  EQU   RET+00000000        HALFWORD INTEGER
RETCHAR  EQU   RET+00000002        18 BYTE(S)
MSGTMCT  EQU   00000000            FULLWORD INTEGER
MSGECB   EQU   00000000            FULLWORD INTEGER
         ORG   @DATA
         DS    00000097C
@L       EQU   1
@DATD    DSECT
@SAV001  EQU   @DATD+00000000      72 BYTE(S) ON WORD
INTFPTR  EQU   @DATD+00000072      FULLWORD POINTER
L        EQU   @DATD+00000076      FULLWORD INTEGER
DEFPARMS EQU   @DATD+00000080      12 BYTE(S) ON WORD
DEFDSN   EQU   DEFPARMS+00000000   FULLWORD POINTER
DEFCODE  EQU   DEFPARMS+00000000   1 BYTE(S)
DEFPSCB  EQU   DEFPARMS+00000004   FULLWORD POINTER
DEFCON   EQU   DEFPARMS+00000004   1 BYTE(S)
DEFQUAL  EQU   DEFPARMS+00000008   FULLWORD POINTER
DEFLOC   EQU   DEFPARMS+00000008   1  BYTE  POINTER
DEFCNTL  EQU   @DATD+00000092      8 BYTE(S)
DEFR15   EQU   @DATD+00000100      FULLWORD POINTER
COPY     EQU   @DATD+00000104      46 BYTE(S) ON WORD
COPYLEN  EQU   COPY+00000000       HALFWORD INTEGER
COPYNAME EQU   COPY+00000002       44 BYTE(S)
         DS    00000150C
@TEMPS   DS    0F
@TEMP4   DC    F'0'
@PL001   DS    04F
@DATEND  EQU   *
IKJEFF17 CSECT ,
HAVELEN  EQU   COPYBACK
         END
