TKBA     TITLE 'IGTKBA -- VPSS ISSUE STARTIO REQUEST'
*/* * START OF SPECIFICATIONS ************************************** */
*/*                                                                  */
*/*   MODULE-NAME = IGTKBA                                           */
*/*                                                                  */
*/*   DESCRIPTIVE-NAME = VPSS STARTIO DRIVER                         */
*/*                                                                  */
*/*   COPYRIGHT = NONE                                               */
*/*                                                                  */
*/*   STATUS = RELEASE 1, MODIFICATION LEVEL 0.                      */
*/*                                                                  */
*/*   FUNCTION = TO SCHEDULE A VPSS I/O REQUEST TO IOS.  THIS        */
*/*       INCLUDES SELECTING THE "BEST" 3838 SUBCHANNEL FOR          */
*/*       THE I/O, COMPLETING THE IOSB/SRB, AND PASSING THE          */
*/*       I/O REQUEST (DESIGNATED BY THE SRB) TO IOS.  AS            */
*/*       AUXILARY FUNCTIONS, SMF DATA IS MAINTAINED, PAGES          */
*/*       ARE FIXED IF REQUIRED, AND THE USER PLACED IN THE          */
*/*       WAIT STATE IF SYNCHRONOUS PROCESSING IS USED.              */
*/*                                                                  */
*/*   NOTES = THE GENERAL INTERFACE SPECIFICATIONS ARE DETERMINED    */
*/*       BY VS/2 (MVS) IOS INTERFACES AS DOCUMENTED IN THE IOS      */
*/*       DESIGN NOTEBOOK AND THE SUPERVISOR SRL.                    */
*/*                                                                  */
*/*     DEPENDENCIES = THE FOLLOWING ARE THE INTERFACES TO THE       */
*/*                    SYSTEM ROUTINES --                            */
*/*                                                                  */
*/*         SETLOCK --                                               */
*/*           PURPOSE: BRANCH ENTERED FROM A SUPERVISOR STATE,       */
*/*                    KEY-0 ROUTINE DESIRING TO ACQUIRE OR          */
*/*                    RELEASE A SYSTEM LOCK.                        */
*/*           LINKAGE: BALR (USING MACRO SETLOCK)                    */
*/*           INPUT:                                                 */
*/*             USE MACRO SETLOCK                                    */
*/*           OUTPUT:                                                */
*/*             REGISTERS 0-10, 15 UNCHANGED. REGISTERS 11-14        */
*/*             ARE DESTROYED. REGISTER 13 HAS THE RETURN CODE--     */
*/*             (0) OK, (4/8) ERROR.                                 */
*/*                                                                  */
*/*         PGFIX  (IEAVPSIB) --                                     */
*/*           PURPOSE: BRANCH ENTERED FROM A SUPERVISOR STATE,       */
*/*                    KEY-0 ROUTINE DESIRING A PAGE SERVICES        */
*/*                    FUNCTION.                                     */
*/*           LINKAGE: BALR - ADDRESS IN CVTVPSIB                    */
*/*           INPUT:                                                 */
*/*             LOCAL LOCK HELD                                      */
*/*             R0   - ECB ADDRESS OR ZERO                           */
*/*             R1,R2- IF BYTE 0 BIT 0 OF R1=1, THEN R1 CONTAINS     */
*/*                    A POINTER TO A VIRTUAL SUBAREA LIST (VSL)     */
*/*                    AND R2 IS IRRELEVANT (THE VSL MUST ALREADY    */
*/*                    BE IN FIXED STORAGE).                         */
*/*                    IF BYTE 0 BIT 0 OF R1=0, THEN R1 AND R2       */
*/*                    FORM A VSL ENTRY.                             */
*/*             R4   - TCB ASSOCIATED WITH PAGE FIX REQUEST.         */
*/*                    IF ZERO, NO TCB SO DO NOT BUILD FOE'S         */
*/*             R14  - RETURN ADDRESS                                */
*/*             R15  - ENTRY POINT OF IEAVPSIB                       */
*/*           OUTPUT:                                                */
*/*             LOCAL LOCK STILL HELD.                               */
*/*             REGISTERS 0-14 ARE UNCHANGED.                        */
*/*             REGISTER 15 HAS RETURN CODE (SAME AS PGFIX/PGFREE    */
*/*             SVC REQUESTS).                                       */
*/*             ECB POINTED TO BY REGISTER 0 (IF ANY) IS POSTED.     */
*/*                                                                  */
*/*         SUSPEND -- IEAVETCL                                      */
*/*           PURPOSE: BRANCH ENTERED FROM A SUPERVISOR STATE,       */
*/*                    KEY-0 ROUTINE DESIRING TO 'SUSPEND' AN        */
*/*                    RB.                                           */
*/*           LINKAGE: BALR - USING MACRO SUSPEND                    */
*/*           INPUT:                                                 */
*/*             R1   - SUSPEND INDICATORS                            */
*/*             R14  - RETURN ADDRESS (SET BY MACRO)                 */
*/*             R15  - ADDRESS OF SUSPEND PROCESSOR (SET BY MACRO)   */
*/*           OUTPUT:                                                */
*/*             REGISTER 0 CONTAINS THE ADDRESS OF THE SUSPENDED TCB */
*/*             REGISTER 1 CONTAINS THE ADDRESS OF THE SUSPENDED RB  */
*/*             REGISTERS 2-10 ARE RETURNED UNCHANGED.               */
*/*             REGISTER 11-15 ARE DESTROYED AND ARE UNPREDICTABLE   */
*/*                                                                  */
*/*         RESUME  -- IEAVRSME                                      */
*/*           PURPOSE: BRANCH ENTERED FROM A SUPERVISOR STATE,       */
*/*                    KEY-0 ROUTINE DESIRING TO 'RESUME' AN         */
*/*                    RB.                                           */
*/*           LINKAGE: BALR - USING MACRO RESUME                     */
*/*           INPUT:                                                 */
*/*             R4   - ADDRESS OF TCB TO 'RESUME'                    */
*/*             R5   - ADDRESS OF RB TO 'RESUME'                     */
*/*             R14  - RETURN ADDRESS (SET BY MACRO)                 */
*/*             R15  - ADDRESS OF RESUME PROCESSOR  (SET BY MACRO)   */
*/*           OUTPUT:                                                */
*/*             REGISTERS 2-10 UNCHANGED.                            */
*/*             REGISTERS 0-1, 11-15 ARE UNPREDICTABLE.              */
*/*                                                                  */
*/*         PGFREE -- IEAVPSIB                                       */
*/*           PURPOSE: BRANCH ENTERED FROM A SUPERVISOR STATE,       */
*/*                    KEY-0 ROUTINE DESIRING A PAGE SERVICES        */
*/*                    FUNCTION.                                     */
*/*           LINKAGE: BALR - ADDRESS IN CVTVPSIB                    */
*/*           INPUT:                                                 */
*/*             LOCAL LOCK HELD                                      */
*/*             R0   - ECB ADDRESS OR ZERO                           */
*/*             R1,R2- IF BYTE 0 BIT 0 OF R1=1, THEN R1 CONTAINS     */
*/*                    A POINTER TO A VIRTUAL SUBAREA LIST (VSL)     */
*/*                    AND R2 IS IRRELEVANT (THE VSL MUST BE IN      */
*/*                    FIXED STORAGE).                               */
*/*                    IF BYTE 0 BIT 0 OF R1=0, THEN R1 AND R2       */
*/*                    FORM A VSL ENTRY.                             */
*/*             R4   - TCB ASSOCIATED WITH THE PGFIX REQUEST.        */
*/*                    IF ZERO, NO FOE(S) BUILT.                     */
*/*             R14  - RETURN ADDRESS                                */
*/*             R15  - ADDRESS OF PAGE SERVICES (IEAVPSIB)           */
*/*           OUTPUT:                                                */
*/*             LOCAL LOCK STILL HELD.                               */
*/*             REGISTERS 0-14 ARE UNCHAGED.                         */
*/*             REGISTER 15 HAS THE RETURN CODE (SAME AS PGFREE      */
*/*             SVC REQUESTS).                                       */
*/*             SPECIFIED PAGE(S) HAVE THE FIX COUNTS REDUCED.       */
*/*                                                                  */
*/*     RESTRICTIONS = THE SUSPEND (IF ANY) MUST BE ISSUED PRIOR     */
*/*         TO THE STARTIO REQUEST TO INSURE THE SUSPEND OCCURS      */
*/*         PRIOR TO THE RESUME.  ALSO, THE LOCAL LOCK MUST BE       */
*/*         OWNED PRIOR TO TRANSLATING THE CCW AND IDAL ADDRESSES    */
*/*         TO REAL ADDRESSES AND NOT RELEASED BEFORE ISSUING THE    */
*/*         STARTIO REQUEST.  THIS INSURES THAT THE USER IS NOT      */
*/*         SWAPPED OUT, THUS CHANGING THE VIRTUAL TO REAL MAPPING.  */
*/*         HOLDING THE LOCAL LOCK INSURES THAT PURGE (AND THUS      */
*/*         SWAP) DOES NOT COMPLETE BEFORE THE I/O.                  */
*/*                                                                  */
*/*     REGISTER-CONVENTIONS = NONE                                  */
*/*                                                                  */
*/*     PATCH-LABEL = APPATCH                                        */
*/*                                                                  */
*/*   MODULE-TYPE = CSECT                                            */
*/*                                                                  */
*/*     PROCESSOR = VS/2 ASSEMBLER                                   */
*/*                                                                  */
*/*     MODULE SIZE = SEE END OF SOURCE LISTING                      */
*/*                                                                  */
*/*     ATTRIBUTES = RE-ENTRANT                                      */
*/*                                                                  */
*/*   ENTRY-POINT = IGTKBA                                           */
*/*                                                                  */
*/*     PURPOSE = VPSS STARTIO DRIVER                                */
*/*                                                                  */
*/*     LINKAGE = BRANCHED TO BY IGTKAA (WHICH WAS INDIRECTLY        */
*/*               ENTERED BY SVC 111).  THIS ROUTINES EXECUTES       */
*/*               IN KEY-0, SUPERVISOR STATE, ENABLED, UNDER         */
*/*               AN SVRB.                                           */
*/*                                                                  */
*/*     INPUT = THE FOLLOWING REGISTERS ARE INITIALIZED ON ENTRY --  */
*/*         REGISTER  1 - APRL ADDRESS                               */
*/*         REGISTER  2 - DEB ADDRESS                                */
*/*         REGISTER  3 - CVT ADDRESS                                */
*/*         REGISTER  4 - ADDRESS OF TCB WHICH ISSUED THE REQUEST    */
*/*         REGISTER 11 - ADDRESS OF VPSS DEB EXTENSION              */
*/*         REGISTER 12 - ADDRESS OF THE VPSS APCT                   */
*/*         REGISTER 15 - ADDRESS OF THIS ROUTINE (IGTKBA)           */
*/*         NOTE: REGISTER 14 DOES NOT CONTAIN RETURN ADDRESS        */
*/*         ROUTINE IS ENTERED IN KEY-0, SUPERVISOR STATE,           */
*/*              UNLOCKED, TASK MODE, ENABLED.                       */
*/*                                                                  */
*/*     OUTPUT = REGISTER 15 IS SET TO INDICATE IF THE REQUEST       */
*/*         WAS SUCCESSFUL.  REGISTERS 0 AND 1 ARE UNPREDICATABLE.   */
*/*         REGISTER 2-14 RETURN TO THE SVC CALLER UNCHANGED.        */
*/*         NO LOCKS MAY BE OWNED ON EXIT.                           */
*/*                                                                  */
*/*   EXIT-NORMAL = EXIT IS TO THE BRANCH ENTRY FOR SVC-3 (EXIT).    */
*/*                 IF ASYNCHRONOUS PROCESSING (WAIT/POST) IS USED,  */
*/*                 CONTROL RETURNS TO IEAVEXP1. OTHERWISE           */
*/*                 (SUSPEND/RESUME) CONTROL RETURNS TO IEAVEXPR.    */
*/*                                                                  */
*/*   EXIT-ERROR = RETURN TO ISSUER VIA SVC-3 BRANCH ENTRY.          */
*/*                SET REGISTER 15 = 8, AND INDICATE IN THE APRL     */
*/*                THAT THE REQUEST FAILED.  THE ECB COMPLETION      */
*/*                CODE IS SET TO HEX '40' TO INDICATE A STARTIO     */
*/*                FAILURE RATHER THAN A 3838 ERROR.                 */
*/*                                                                  */
*/*   EXTERNAL-REFERENCES = THE FOLLOWING SYSTEM ROUTINES AND        */
*/*                         CONTROL BLOCKS ARE USED.                 */
*/*                                                                  */
*/*     ROUTINES =                                                   */
*/*         SETLOCK                                                  */
*/*         PGFIX                                                    */
*/*         SUSPEND                                                  */
*/*         IOS STARTIO INTERFACE                                    */
*/*         IEAVEXIT                                                 */
*/*         PGFREE                                                   */
*/*         RESUME                                                   */
*/*         IGTUKA (FRR/ESTAE EXIT ROUTINE)                          */
*/*                                                                  */
*/*     DATA-AREAS =                                                 */
*/*         VSL      - R, M  (VIRTUAL STORAGE LIST)                  */
*/*         ECB      - M     (EVENT CONTROL BLOCK)                   */
*/*         APES     -       C (IGTUKA INTERFACE BLOCK)              */
*/*                                                                  */
*/*     CONTROL-BLOCKS =                                             */
*/*         PSA      - R                                             */
*/*         CVT      - R                                             */
*/*         PVT      - R                                             */
*/*         IOCOM    - R                                             */
*/*         ASCB     - R                                             */
*/*         ASXB     - R, M                                          */
*/*         FRRS     - R, M                                          */
*/*         IOSB     - R, M                                          */
*/*         SRB      - R                                             */
*/*         TCB      - R                                             */
*/*         RB       - R                                             */
*/*         DEB      - R                                             */
*/*         APIO     - R, M                                          */
*/*         APUB     - R, M                                          */
*/*         APRL     - R, M                                          */
*/*         APCT     - R                                             */
*/*         APDS     - R, M                                          */
*/*         APDX     - R, M                                          */
*/*         APMF     - R, M                                          */
*/*         APVU     - R, M                                          */
*/*         APXL     - R                                             */
*/*                                                                  */
*/*   TABLES =                                                       */
*/*         APCC                                                     */
*/*         APCM                                                     */
*/*                                                                  */
*/*   MACROS =                                                       */
*/*       SUSPEND                                                    */
*/*       STARTIO                                                    */
*/*       MODESET                                                    */
*/*       SETLOCK                                                    */
*/*       RESUME                                                     */
*/*       SETFRR                                                     */
*/*       ABEND                                                      */
*/*       IGTXEPLG                                                   */
*/*                                                                  */
*/*   CHANGE-ACTIVITY = NONE                                         */
*/*                                                                  */
*/*   MESSAGES = NONE                                                */
*/*                                                                  */
*/*   ABEND-CODES = NONE                                             */
*/*                                                                  */
*/* * END OF SPECIFICATIONS **************************************** */
         EJECT ,
IGTKBA   CSECT ,                   ISSUE STARTIO REQUEST
         USING *,R15               INPUT BASE
         B     STARTUP             SKIP IN-CORE ID
         DC    YL1(COREIDE-*-1)    * ID LENGTH
         DC    C'IGTKBA'           * MODULE NAME
         DC    C' &SYSDATE '       * ASSEMBLY DATE
COREIDE  EQU   *                   * END OF ID
         SPACE 3
STARTUP  DS    0H                  START OF CODE
         SPACE 2
***********************************************************************
**                                                                   **
** VERIFY INPUT AND ESTABLISH RECOVERY ENVIRONMENT                   **
**                                                                   **
***********************************************************************
         SPACE 2
*
** INPUT REGISTERS
*
         USING FLC,*-*             LOW CORE (0-4095) NEEDS NO BASE
         USING DEBBASIC,RDEBPTR    DEB (BASIC SECTION)
         USING CVTMAP,RCVTPTR      CVT
         USING TCB,RTCBPTR         USER'S TCB
         USING ASCB,RASCBPTR       CURRENT ASCB
         USING APRL,R1             VPSS APRL
         USING APDX,RXAPDX         VPSS DEB EXTENSION
         SPACE 2
*
** ESTABLISH NEW BASE AND SAVE VOLITILE POINTERS
*
         LA    RCODE,0(,R15)       NEW BASE. HI-BIT SHOWS IF
*                                  * ASYNCHRONOUS I/O (=1).
         LR    RAPRLPTR,R1         SAVE APRL ADDRESS
         LR    RAPDXPTR,RXAPDX     SAVE APDX ADDRESS
         DROP  R1,RXAPDX,R15,RTCBPTR,RASCBPTR NOT NEEDED
         USING IGTKBA,RCODE        TELL ASSEMBLER
         USING APRL,RAPRLPTR       * OF THE NEW
         USING APDX,RAPDXPTR       * BASE REGISTERS
*
** CURRENTLY ASSIGNED REGISTERS:
**      R2         DEBBASIC
**      R3         CVTMAP
**      R4         APRL
**      R5         APDX
**      R6         BASE REGISTER
*
         EJECT ,
*
** SWITCH TO THE USER'S PROTECT KEY. INITIALIZE THE USER'S
** ECB COMPLETION CODE. THEN SAVE REQUIRED APRL VALUES
** BEFORE RETURNING TO KEY 0.
*
         MODESET KEYADDR=DEBPROTG, SWITCH TO USER KEY                  *
               WORKREG=7           * (KEY OF OPEN REQUESTOR)           *
                                   * KEEP APRL KEY IN REG 7
         MVI   APRLECBC,ECBNORM    NORMAL I/O COMPLETION CODE
         TM    APRLOPT0,APRLASY    ASYNCHRONOUS (WAIT/POST) REQUEST ?
         BZ    RESUME1             * NO--SUSPEND/RESUME. LEAVE POSTED
         MVI   APRLECBC,0          SHOW NOT YET POSTED
         O     RCODE,CASYNCH       SHOW ASYNCHROUS I/O REQUEST
*                                  * (BASE REGISTER NEGATIVE)
RESUME1  EQU   *                   SYNCHRONOUS/ASYNCHROUS DETERMINED
         L     RAPIONUM,APRLAPIO   APIO INDEX INTO APDX
         MODESET EXTKEY=ZERO       RESUME NORMAL KEY
         DROP  RDEBPTR             FINISHED WITH DEBBASIC
*
** CURRENTLY ASSIGNED REGISTERS:
**      R2         APDXAPIO INDEX VALUE (APRLAPIO)
**      R3         CVTMAP
**      R4         APRL
**      R5         APDX
**      R6         BASE REGISTER
**      R7         USER PROTECT KEY (FROM DEB)
*
         SPACE 3
*
** OBTAIN THE LOCAL LOCK. THIS IS REQUIRED FOR ALL
** FURTHER PROCESSING (UNTIL THE I/O ISSUED).
** REGISTERS DESTROYED: 11,12,13,14.
*
         SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND, GET THE LOCAL LOCK     *
               RELATED=STARTIO     * REQUIRED BY STARTIO.
         LTR   RAPIOPTR,R13        LOCK ACQUIRED ?  (CLEAR RAPIOPTR)
         BNZ   ERRORA              * NO--ERROR
         SPACE 3
*
** ESTABLISH RECOVERY ENVIRONMENT AND RECOVERY WORKAREA
** REGISTER 'RFRRSTK' SET TO ADDRESS 6-WORD RECOVERY-TRACING AREA
*
** REGISTERS DESTROYED: R11, R12 (SEE WRKREGS OPTION)
*
         SETFRR A,FRRAD=CXSTAEAD,  PROVIDE RECOVERY RTN - XSTAE        *
               PARMAD=(RFRRSTK),   * PUT 6-WORD WORKAREA IN RFRRSTK    *
               CLEAR=NO,           * DO NOT CLEAR DSECT                *
               WRKREGS=(R11,R12),  * WORK REGS (DESTROYED BY SETLOCK)  *
               RELATED=(DFRRSTK)   * DFRRSTK IS 6-WORD DSECT
         USING DFRRSTK,RFRRSTK     RECOVERY TRACING DSECT
         ST    RAPIOPTR,DFRRAPIO   SHOW NO APIO IN RECOVERY
         ST    RAPRLPTR,DFRRAPRL   SAVE APRL ADDRESS (IN CASE ERROR
*                                  * MUST BE REPORTED TO USER)
         STC   R7,DFRRKEY          SAVE APRL PROTECTION KEY
*                                  * DONE WITH REGISTER 7
         MVI   DFRRCODE,CERRN99    SET DEFAULT ERROR CODE
         L     R0,APDXAPCT         SAVE ADDRESS OF THE APCT
         ST    R0,DFRRAPCT         * IN THE RECOVERY WORKAREA
         DROP  RAPRLPTR            DON'T NEED REGISTER POINTER
*
** CURRENTLY ASSIGNED REGISTERS:
**      R2         APDXAPIO INDEX VALUE (APRLAPIO)
**      R3         CVTMAP
**      R5         APDX
**      R6         BASE REGISTER
**      R8         DFRRSTK
**      R9         APIO (CURRENTLY 0)
*
         SPACE 3
*
** FIND THE APIO FOR THIS REQUEST. REGISTER 'RAPIONUM'
** HAS THE APDX INDEX VALUE.
*
         CH    RAPIONUM,APDXIOCT   MUST NOT EXCEED APDX LIMIT
         BH    ERRORB              * ELSE IS ERROR
         AR    RAPIONUM,RAPIONUM   MAKE RAPIONUM = OFFSET INTO APDX
         BNP   ERRORB              IS ERROR IF NEGATIVE OR ZERO INDEX
         AR    RAPIONUM,RAPIONUM   RAPIONUM = 4*INDEX
*
** RAPIOPTR SET TO ZERO FROM SETLOCK ABOVE
*
         A     RAPIOPTR,APDXAPIO-L'APDXAPIO(RAPIONUM) POINT TO APIO
         BZ    ERRORB              APIO EXIST ?
*                                  * NO -- ERROR
         USING APIO,RAPIOPTR       TELL ASSEMBLER OF BASE TO APIO
*
** CURRENTLY ASSIGNED REGISTERS:
**      R3         CVTMAP
**      R5         APDX
**      R6         BASE REGISTER
**      R8         DFRRSTK
**      R9         APIO (INCLUDES IOSB AND SRB)
*
*
         SPACE 2
*
** INSURE VALID APIO (SYSTEM ERROR IF NOT)
** TERMINATE REQUEST IF INVALID. THIS CHECK
** MINIMIZES EFFECT OF STORAGE OVERLAY.
*
         L     R0,CAPIOID          LOAD CONTROL BLOCK ID (='APIO')
         C     R0,APIOID           INSURE CONTROL BLOCK OK
         BNE   ERRORG              * ERROR IF NOT (APDX OR APIO)
         SPACE 3
*
** SEE IF APIO CURRENTLY IN-USE (I/O OUTSTANDING).
** IF SO, IS ERROR. OTHERWISE, MARK IN USE NOW.
*
         CLI   APIOACTV,0          APIO IN-USE ?
         BNE   ERRORC              * YES -- IS ERROR
         L     R0,APIOFLGA         CLEAR THE APIO PROCESSING
         N     R0,CAPIOFLG         * FLAGS (LEAVE IGTKCA-SET FLAGS)
         ST    R0,APIOFLGA         * USED FOR I/O & RECOVERY
         ST    RAPIOPTR,DFRRAPIO   SAVE APIO ADDRESS FOR RECOVERY
         MVI   APIOACTV,X'FF'      SHOW APIO "OWNED"
         LH    R15,APIONBRI        INCREMENT NUMBER OF I/O
         LA    R15,1(,R15)         * REQUESTS AGAINST
         STH   R15,APIONBRI        * THIS APIO.
         EJECT ,
***********************************************************************
**                                                                   **
** UPDATE SMF STATISTICS.  DATA KEPT IN TWO RECORDS.  THE STANDARD   **
** TYPE-4 SMF RECORD CONTAINS THE NUMBER OF I/O REQUESTS USING THE   **
** DD-STATEMENT (EQUIVALENT TO THE "NORMAL" EXCP I/O COUNTS).  THE   **
** SECOND RECORD TYPE KEEPS SPECIALIZED 3838-VPSS STATISTICS.  THIS  **
** RECORD IS POINTED TO BY THE APDX.                                 **
**                                                                   **
***********************************************************************
         SPACE 3
*
** UPDATE THE ASSOCIATED I/O STATISTICS IN THE
** STANDARD TYPE-4 SMF RECORD (AS FOR EXCP).
*
** FOLLOWING REGISTERS FOR SMF ROUTINE (IEASMFEX -- SC102):
**    0 - TCB ADDRESS
**    1 - NUMBER OF I/O REQUESTS (ALWAYS 1)
**    3 - DEB ADDRESS
**    7 - UCB ADDRESS (ALWAYS 0)
**   14 - RETURN ADDRESS
**   15 - ENTRY POINT
** REGISTERS DESTROYED BY THIS PROCESSING: 0, 1, 7, 10-15
*
         MVI   DFRRCODE,CERRN01    SET ERROR CODE
         L     R0,PSATOLD          CURRENT TCB
         LA    R1,1                INCREMENT I/O COUNT BY 1
         SR    R7,R7               UCB ADDRESS IN TCT IS 0
         L     R15,CVTSMFEX        SMF COUNT RTN (IEASMFEX) ADDRESS
         L     R3,APDXDEB          ASSOCIATED DEB                      *
                                   * NOTE: R3->CVT LOST
         CALL  (15)                UPDATE I/O COUNT
         MVI   DFRRCODE,CERRN99    SET DEFAULT ERROR CODE
         L     RCVTPTR,FLCCVT      RE-ESTABLISH CVT ADDRESS
         SPACE 5
*
** UPDATE THE ASSOCIATED I/O STATISTICS
** IN THE VPSS SMF RECORD (APMF)
** NOTE: SINCE LOCAL LOCK OWNED, APMF UPDATE SERIALIZED.
**       THEREFORE 'COMPARE-AND-SWAP' NOT REQUIRED
**       FOR THE I/O COUNTERS (APMFIXXX).
** REGISTERS DESTROYED: 0, 1, 15
*
         L     RAPMFPTR,APDXAPMF   POINT TO SMF RECORD
         USING APMF,RAPMFPTR       TELL ASSEMBLER
         LA    R0,1                COUNT INCREMENT
         LTR   RCODE,RCODE         SYNCHRONOUS/ASYNCHRONOUS I/O
         BP    UPDAPMF1            * BRANCH IF SYNCHRONOUS
         L     R1,APMFIASY         INCREMENT SYNCHRONOUS I/O COUNT
         AR    R1,R0
         ST    R1,APMFIASY
         B     UPDAPMF2            SKIP SYNCH
UPDAPMF1 EQU   *                   HERE IF SYNCHRONOUS I/O
         L     R1,APMFISYN         UPDATE COUNT
         AR    R1,R0
         ST    R1,APMFISYN
UPDAPMF2 EQU   *                   SYNCHRONOUS/ASYNCHRONOUS COUNTED
         SPACE ,
         TM    APIOFLG0,APIOFXED   PGFIX AT TRANSLATE OR I/O ?
         BO    UPDAPMF3            * BRANCH IF AT TRANSLATE
         TM    APIOFLG0,APIORXLT   RE-TRANSLATION OF CCWS REQUESTED ?
         BO    UPDAPMF5            * YES -- GO COUNT IT        @ZA26916
         L     R1,APMFIFXI         UPDATE NUMBER OF I/O
         AR    R1,R0
         ST    R1,APMFIFXI
         B     UPDAPMF4            SKIP RE-TRANSLATION COUNT   @ZA26916
UPDAPMF5 EQU   *                   HERE IF RE-TRANSLATE OF CCW @ZA26916
         L     R1,APMFIFXR         UPDATE I/O COUNT            @ZA26916
         AR    R1,R0                                           @ZA26916
         ST    R1,APMFIFXR                                     @ZA26916
         B     UPDAPMF4            SKIP PGFIX AT XLTE
UPDAPMF3 EQU   *                   HERE IF PGFIX AT TRANSLATE
         L     R1,APMFIFXX         UPDATE I/O COUNT
         AR    R1,R0
         ST    R1,APMFIFXX
UPDAPMF4 EQU   *                   PGFIX AT TRANSLATE/STARTIO COUNTED
         DROP  RAPMFPTR            FINISHED WITH APMF
         DROP  RAPDXPTR            FINISHED WITH APDX
*
** CURRENTLY ASSIGNED REGISTERS:
**      R3         CVTMAP
**      R6         BASE REGISTER
**      R8         DFRRSTK
**      R9         APIO (INCLUDES IOSB AND SRB)
*
         EJECT ,                                               @ZA26916
***********************************************************************
**                                                                   **
** IF RE-TRANSLATION MODE (APIORXLT=1), LOOP THRU THE USER'S         **
** CHANNEL PROGRAM AND UPDATE THE ACTUAL CHANNEL PROGRAM.            **
** ALSO UPDATE THE VSL, IDAL AND APXL TABLES.                        **
**                                                                   **
***********************************************************************
         SPACE 2                                               @ZA26916
         TM    APIOFLG0,APIOFXED   PAGES FIXED BY TRANSLATE CALL ?
         BO    NOPGFIX             * YES -- NO NEED TO FIX NOW @ZA26916
*                                  * ALSO CANNOT BE RE-TRANSLATE MODE
         TM    APIOFLG0,APIORXLT   RE-TRANSLATION REQUIRED ?   @ZA26916
         BZ    NOXLTE              * NO -- SKIP PROCESSING     @ZA26916
*                                                              @ZA26916
** RE-TRANSLATION REQUIRED. LOOP THRU THE USER'S CHANNEL       @ZA26916
** PROGRAM AND DO THE FOLLOWING FOR EACH CCW:                  @ZA26916
**   1 - SAVE DATA TRANSFER COUNT IN THE PROTECTED CCW         @ZA26916
**   2 - BUILD APXL ENTRIES TO CONSTRUCT IDAL ENTRIES FOR      @ZA26916
**       THIS I/O                                              @ZA26916
**   3 - ADD A VSL ENTRY FOR EACH BUFFER                       @ZA26916
** AT THE END, ADJUST THE 'LAST-ENTRY' POINTERS                @ZA26916
*                                                              @ZA26916
** FOLLOWING REGISTERS USED DURING THIS PROCESSING:            @ZA26916
**    0 - MASK OF X'00FFF800' TO ROUND DOWN TO 2K BOUNDARY     @ZA26916
**    1 - POINTER TO USER I/O BUFFER                           @ZA26916
**    2 - I/0 TRANSFER COUNT FROM USER CCW                     @ZA26916
**    3 - MASK OF X'0000FFFF' TO CLEAR FLAGS FROM CCW COUNT    @ZA26916
**    4 - POINTER TO IDAL SLOT                                 @ZA26916
**    5 - POINTER TO APXL SLOT WHICH POINTS TO 1ST IDAL SLOT EACH CCW
**    7 - POINTER TO AVAILABLE APXL ENTRY                      @ZA26916
**   11 - POINTER TO AVAILABLE VSL ENTRY                       @ZA26916
**   12 - POINTER TO USER CCW                                  @ZA26916
**   13 - POINTER TO PROTECTED CCW                             @ZA26916
**   14 - USER'S PROTECT KEY (FROM DEB)                        @ZA26916
**   15 - WORK REGISTER                                        @ZA26916
*                                                              @ZA26916
** FOLLOWING REGISTERS DESTROYED BY THIS LOOP:                 @ZA26916
**   0, 1, 2, 3, 4, 5, 7, 11, 12, 13, 14, 15.                  @ZA26916
*                                                              @ZA26916
         L     R0,CRND2KDN         ROUND ADDR TO 2K (IDAL BOUNDARY)
         L     R3,CLRCOUNT         CLEAR CCW TRANSFER COUNT    @ZA26916
         L     R15,APIOAPXL        POINT TO APXL               @ZA26916
         L     R5,APXLIDAL-APXL(,R15) POINTER TO IDAL SLOTS IN APXL
         L     R7,APXLFREE-APXL(,R15) 1ST AVAILABLE APXL SLOT  @ZA26916
         L     R11,APIOPGFF        1ST AVAILABLE PGFIX SLOT    @ZA26916
         L     R12,APIOUCCW        ADDRESS OF USER'S CHANNEL PROGRAM
         L     R13,APIOCCW         ADDRESS OF PROTECTED CHANNEL PROGRAM
         IC    R14,DFRRKEY         USER'S PROTECT KEY (FROM DEB)
         LA    R12,2*CCWLN(,R12)   SKIP PROCESS & WRITE OF CIT IN
         LA    R13,2*CCWLN(,R13)   * BOTH USER & PROTECTED CHAN. PGM
*                                                              @ZA26916
** LOOP THRU PROTECTED CHANNEL PROGRAM UNTIL REACHING          @ZA26916
** THE NOP. NOTE -- AT LEAST 1 CCW MUST REQUIRE TRANSLATION.   @ZA26916
**                                                             @ZA26916
*                                                              @ZA26916
XLTE01   EQU   *                   PROCESS NEXT CCW            @ZA26916
         MVI   DFRRCODE,CERRN14    SET ERROR CODE (PGM CHECK ON CCW)
**       MODESET KEYADDR=(R14)     SWITCH TO USER'S KEY        @ZA26916
         SPKA  0(R14)              * MODESET EQUIVALENT        @ZA26916
         LM    R1,R2,CCW-CCW(R12)  R1=ADDR, R2=LENGTH OF BUFFER@ZA26916
         MODESET EXTKEY=ZERO       RESUME STANDARD KEY         @ZA26916
         MVI   DFRRCODE,CERRN99    RESET STANDARD ERROR CODE   @ZA26916
         LA    R1,0(,R1)           CLEAR OP-CODE               @ZA26916
         NR    R2,R3               CLEAR FLAGS                 @ZA26916
         STH   R2,CCWBCNT-CCW(,R13) SAVE UPDATED COUNT         @ZA26916
         ST    R1,VSLSTRT-VSL(,R11) START OF PGFIX             @ZA26916
         LA    R2,0(R1,R2)         R2 = ADDR END OF BUFFER + 1 @ZA26916
         ST    R2,VSLEND-VSL(,R11) END OF PGFIX                @ZA26916
         CR    R2,R1               END POINT > START POINT ?   @ZA26916
         BNH   ERRORH              * NO - 0 COUNT OR WRAP-AROUND
*                                                              @ZA26916
** BUILD APXL ENTRIES FOR IDALS                                @ZA26916
*                                                              @ZA26916
         L     R4,APXLADDV-APXL(,R5) POINT TO IDAL AREA FOR THIS CCW
XLTE05   EQU   *                   LOOP POINT                  @ZA26916
         ST    R1,APXLADDV-APXL(,R7) ADDRESS TO CONVERT        @ZA26916
         ST    R4,APXLADDL-APXL(,R7) ADDR IDAL ENTRY           @ZA26916
         LA    R7,APXLLN1(,R7)     NEXT APXL ENTRY             @ZA26916
         LA    R4,4(,R4)           NEXT IDAL ENTRY             @ZA26916
         LA    R1,CXIOLN(,R1)      SET R1 = NEXT 2K            @ZA26916
         NR    R1,R0               * BOUNDARY                  @ZA26916
         CR    R1,R2               IF MORE TO PROCESS          @ZA26916
         BL    XLTE05              * CONTINUE LOOP             @ZA26916
*                                                              @ZA26916
** PROCESS NEXT CCW                                            @ZA26916
*                                                              @ZA26916
         LA    R5,APXLLN1(,R5)     NEXT APXL -> IDAL ENTRY     @ZA26916
         LA    R11,VSLLEN(,R11)    NEXT AVAILABLE VSL ENTRY    @ZA26916
         LA    R12,CCWLN(,R12)     POINT TO NEXT CCW           @ZA26916
         LA    R13,CCWLN(,R13)     * USER & PROTECTED COPIES   @ZA26916
         CLI   CCWOP-CCW(R13),CCWOPNOP REACHED NOP ?           @ZA26916
         BNE   XLTE01              * NO -- CONTINUE TRANSLATION@ZA26916
*                                                              @ZA26916
** COMPLETE END POINTERS FOR VSL AND APXL TABLES.              @ZA26916
** CURRENTLY:                                                  @ZA26916
**   R7  -> NEXT AVAILABLE APXL SLOT                           @ZA26916
**   R11 -> NEXT AVAILABLE VSL SLOT                            @ZA26916
*                                                              @ZA26916
         LA    R0,VSLLEN           SET R11 =                   @ZA26916
         SR    R11,R0              * ADDRESS OF LAST VSL USED  @ZA26916
         ST    R11,APIOPGFL        SAVE ITS ADDRESS            @ZA26916
         OI    VSLFLAG2-VSL(R11),VSLAST SHOW LAST ENTRY        @ZA26916
         LA    R0,APXLLN0+APXLLN1  SET R7 = ADDRESS OF LAST APXL
         SR    R7,R0               * USED MINUS HEADER LENGTH  @ZA26916
         L     R15,APIOAPXL        SAVE THIS ADDRESS IN THE    @ZA26916
         ST    R7,APXLLAST-APXL(,R15) * APXL FOR VIRT->REAL CONVERSION
         SPACE ,                                               @ZA26916
*                                                              @ZA26916
** RE-TRANSLATION COMPLETE                                     @ZA26916
*                                                              @ZA26916
         L     RCVTPTR,CVTPTR      RESTORE CVT POINTER         @ZA26916
         SPACE 3                                               @ZA26916
NOXLTE   EQU   *                   NO RE-TRANSLATION REQUIRED  @ZA26916
         SPACE 2                                               @ZA26916
*                                                              @ZA26916
** CURRENTLY ASSIGNED REGISTERS:                               @ZA26916
**      R3         CVTMAP                                      @ZA26916
**      R6         BASE REGISTER                               @ZA26916
**      R8         DFRRSTK                                     @ZA26916
**      R9         APIO (INCLUDES IOSB AND SRB)                @ZA26916
*                                                              @ZA26916
         EJECT ,
***********************************************************************
**                                                                   **
** IF PAGES WHERE NOT FIXED AT CHANNEL PROGRAM TRANSLATION BY        **
** IGTKCA, THEY MUST BE FIXED NOW.  USE A SHORT TERM PGFIX SINCE     **
** THE PAGES WILL BE UNFIXED BY THE VPSS TERMINATION ROUTINE         **
** (IGTKBC) WHICH RUNS AS AN SRB WHEN THE I/O COMPLETES.             **
**                                                                   **
***********************************************************************
         SPACE 2
*
** PGFIX REQUIRED.  LOOP THRU THE VSL PGFIX ENTRIES TO FIX
** THE REQUIRED PAGES USING THE REGISTER FORMAT OF PGFIX.  THIS
** VERSION IS USED RATHER THAN THE LIST FORM TO ELIMINATE THE
** PARAMETER LIST CHECKING BY PGFIX.  THE REGISTER FORMAT PATH
** LENGTH IS SHORTER THAN THE LIST FORMAT IN IEAVPSIB.
*
** FOLLOWING INPUT REQUIRED FOR PGFIX:
**    0 - ECB TO POST WHEN PGFIX COMPLETE (NOT USED FOR WAIT)
**    1 - 1ST HALF OF VSL ENTRY (BIT-0 = 0 SHOWS REGISTER FORMAT)
**    2 - 2ND HALF OF VSL ENTRY (REGISTER FORMAT)
**    4 - TCB ADDRESS (=0 TO SHOW NO FOE ACCOUNTING)
**   14 - RETURN ADDRESS
**   15 - ADDRESS OF PGFIX ENTRY POINT (IEAVPSIB CONTAINED IN CVTVPSIB)
*
** OUTPUT FROM IEAVPSIB:
**    0-14 - UNCHANGED
**    15 - RETURN CODE
*
** FOLLOWING REGISTERS DESTROYED BY THIS LOOP:
**    0, 1, 2, 4, 5, 11, 12, 13, 14, 15.
*
         MVI   DFRRCODE,CERRN02    SET ERROR CODE
         L     RVSLPTR,APIOPGFX    FIRST VSL ENTRY
         L     RVSLEND,APIOPGFL    LAST VSL ENTRY
         LA    RVSLINCR,VSLLEN     LENGTH OF VSL ENTRY
         ST    RVSLPTR,DFRRVSL     RECOVERY - SHOW ONE IN ERROR
         LA    R0,APIOSAVE         ECB TO POST (NOT USED FOR WAIT)
         MVI   APIOSAVE,0          SHOW ECB NOT WAITED ON
         SR    RTCBPTR,RTCBPTR     NO FOE ACCOUNTING WANTED
         L     RPGFXFLG,CPGFXFLG   SHOWS SHORT-TERM PGFIX
         OI    APIOFLG3,APIOPGIP   PGFIX IN PROGRESS
         USING VSL,RVSLPTR         TELL ASSEMBLER OF VSL POINTER
*
** LOOP THRU VSL ENTRIES
*
PGFIX1   EQU   *                   FIRST/NEXT VSL ENTRY
         LM    R1,R2,VSLSTRT       START, END+1
         ST    RVSLPTR,DFRRVSL     RECOVERY - SHOW ONE IN ERROR
         OR    R1,RPGFXFLG         SHOW SHORT-TERM PGFIX
         L     R15,CVTVPSIB        ADDRESS OF IEAVPSIB
         CALL  (15)                CALL IEAVPSIB TO FIX PAGES
*
** REGISTER 15 HAS RETURN CODE --
**   00 - ALL PAGES NOW FIXED
**   04 - INVALID VSL CONTENTS
**   08 - PAGE-IN IN PROCESS
**   12 - INVALID VSL
*
** IF CODE=8, REFERENCE EACH PAGE. WHEN COMPLETE,
** ONE CAN BE SURE ALL PAGES HAVE BEEN PAGED-IN AND
** THUS ARE NOW FIXED. A WAIT CAN NOT BE ISSUED SINCE THE
** LOCAL LOCK IS OWNED AND MUST NOT BE GIVEN UP.
*
         LTR   R15,R15             PAGE FIX COMPLETE ?
         BZ    PGFIX3              * YES -- SKIP FORCE-IN PROCESSING
         C     R15,CPGFIXIP        PAGE FIX IN PROGRESS ?
         BNE   ERRORD              * NO -- GO TO TERMINATION PROCESS
*
** REFERENCE EACH PAGE IN THE VSL ENTRY.
** WHEN THIS LOOP IS COMPLETE, ALL PAGES
** HAVE BEEN BROUGHT INTO STORAGE, AND
** THEREFORE ARE NOW PAGE FIXED.
*
         N     R1,CRNDPGDN         CLEAR HI-FLAGS AND ROUND DOWN
*                                  * TO PAGE BOUNDARY
         LA    R2,0(,R2)           CLEAR FLAGS FROM END ENTRY
         L     R15,CPGSIZE         PAGE SIZE
PGFIX2   EQU   *                   FIRST/NEXT PAGE IN VSL ENTRY
         CLI   0(R1),*-*           FORCE PAGE INTO STORAGE
*                                  * ABOVE PAGE NOW FIXED
         AR    R1,R15              NEXT PAGE
         CR    R1,R2               END OF ENTRY ?
         BL    PGFIX2              * NO--GO REFERENCE THIS PAGE
*
** VSL ENTRY PROCESSED. CONTINUE WITH
** NEXT VSL ENTRY (IF ANY).
*
PGFIX3   EQU   *                   CHECK FOR MORE VSL ENTRIES
         BXLE  RVSLPTR,RVSLINCR,PGFIX1 PROCESS ALL ENTRIES
*
** ALL PAGES NOW IN-CORE. PAGE FIX COMPLETE
*
         MVI   DFRRCODE,CERRN99    RESET ERROR CODE
         DROP  RVSLPTR             FINISHED WITH VSL POINTER
         XI    APIOFLG3,APIOPGFS+APIOPGIP RESET PGFIX-IN-PROGRESS
*                                  * SHOW PGFREE REQUIRED (RECOVERY)
         SPACE 2
NOPGFIX  EQU   *                   PAGES NOW FIXED (SHORT OR LONG)
         SPACE 2
*
** CURRENTLY ASSIGNED REGISTERS:
**      R3         CVTMAP
**      R6         BASE REGISTER
**      R8         DFRRSTK
**      R9         APIO (INCLUDES IOSB AND SRB)
*
         EJECT ,
***********************************************************************
**                                                                   **
** FIND A SUITABLE SUBCHANNEL FOR THIS I/O REQUEST.                  **
** PROCESS DEPENDS ON WHETHER THE REQUEST IS FOR AN                  **
** EXCLUSIVE OR SHARED SUBCHANNEL.                                   **
**                                                                   **
***********************************************************************
         SPACE 2
         TM    APIOFLG2,APIOEXCL   EXCLUSIVE PORT ?            @ZA26916
         BZ    SHAREFND            * NO -- GO PROCESS SHARED REQUEST
*
** EXCLUSIVE SUBCHANNEL REQUEST. APIO ALREADY HAS
** A POINTER TO THE DESIRED APUB (AND UCB). VERIFY
** THAT THE SUBCHANNEL IS STILL AVAILABLE. IF NOT,
** GO TO TERMINATION PROCESSING.
*
         L     RAPUBPTR,APIOAPUB   POINT TO ASSOCIATED APUB
         USING APUB,RAPUBPTR       TELL ASSEMBLER
         L     R1,APUBIOFG         I/O FLAGS
         N     R1,CLRXIOF          CLEAR NON-EXCLUSIVE FAIL BITS
         BZ    PORTSET             * IF EXC-FAIL BITS OFF, APUB OK
         N     R1,CLRXIPL          OTHER THAN RE-IPL'ED BIT ON ?
         BNZ   ERRORE              * YES -- LOGICAL ERROR
*                                  * PORT SHOULD HAVE BEEN AVAILABLE
*
** BOX RE-IPLED; EXCLUSIVE USER HAS LOST DATA.
** GIVE USER I/O ERROR & RESET ERROR BIT.
** USER SHOULD NOW KNOW BOX LOST DATA.
** NOT NEEDED FOR SHARED USER SINCE EACH
** I/O SELF CONTAINED.
*
         L     R1,APUBIOFG         RELOAD INITIAL FLAGS
EXCCS    EQU   *                   COMPARE-AND-SWAP RETRY
         LR    R0,R1               SET R0 = APUBIOFG
         N     R0,CLRXIPL          * WITH RE-IPL FLAG OFF.
         CS    R1,R0,APUBIOFG      TRY UPDATE
         BNZ   EXCCS               RETRY IF CS FAILED
         B     ERRORJ              GO TO RETURN ERROR TO USER
         DROP  RAPUBPTR            LOWER CODE DOES NOT HAVE POINTER
         EJECT ,
SHAREFND EQU   *                   USER HAS SHARED ALLOCATION
*
** SHARED SUBCHANNEL REQUEST.
*
** SHARED SUBCHANNEL REQUEST. SCAN LIST AND DETERMINE "BEST"
** SUBCHANNEL FOR THIS I/O REQUEST.  THE FOLLOWING CRITERIA
** ARE CHECKED:
**   1.  SUBCHANNEL REGION MUST BE SUFFICIENT TO HOLD REQUEST.
**   2.  "SHARED-SUBCHANNEL I/O PROHIBITED FLAGS" IN THE APUB
**       MUST BE ZERO.
** IF THESE CONDITIONS MET, THE SUBCHANNEL IS ACCEPTABLE.  NOW
** SCAN THE FOLLOWING OPTIONAL CRITERIA:
**   3.  "I/O NON-SUGGESTED FLAGS" IN THE APUB SHOULD BE ZERO.
**   4.  THE CURRENT ACTIVITIY ON THE SUBCHANNEL (SEE LATER
**       PROCESSING OF 'APIOTMES' FIELD) IS LESS THAN PREVIOUS
**       SUBCHANNELS.  IF THE ACTIVITY IS 0, AND ONLY 1-3838
**       IS IPL'ED, USE THIS SUBCHANNEL.  NO FUTHER CHECKING
**       IS REQUIRED.
**   5.  THE CURRENT ACTIVITIY ON THE ENTIRE 3838 IS LESS
**       THAN PROCESSING ON THE PREVIOUSLY CHECKED 3838'S.
*
*
** FOLLOWING REGISTERS DESTROYED BY THIS PROCESSING:
**       0, 11, 12, 14, 15
** REGISTERS SET BY THIS PROCESSING:
**       5 - ADDRESS OF THE SELECTED APUB
*
         L     APCTPTR,APIOAPCT    POINT TO THE APCT
         USING APCT,APCTPTR        * TELL THE ASSEMBLER
         LA    RAPUBPTR,CAPUB      FAKE APUB (NO I/O ALLOWED)
         L     RXAPUB,APCTUBIS     ADDRESS APUB I/O QUEUE
SHAREA   EQU   *                   FIRST/NEXT APUB
         LTR   RXAPUB,RXAPUB       END OF APUB CHAIN ?
         BZ    SHAREY              * YES -- RAPUBPTR POINTS TO
*                                  *        SELECTED APUB
         USING APUB,RXAPUB         CHECK THIS APUB
*
** SEE IF THIS APUB CAN PROCESS THE REQUEST
*
         LH    R0,APUBRGN          INSURE APUB REGION IS AT LEAST
         C     R0,APIORGN          * AS LARGE AS APDS REQUIREMENT
         BL    SHARES              * IF NOT, APUB CANNOT BE USED
         L     R0,APUBIOFG         I/O PROCESSING FLAGS
         N     R0,CLRSIOF          CLEAR SHARED FLAGS. GOOD APUB ?
         BZ    SHAREG              * YES -- APUB NOW ACCEPTABLE
         L     R0,APUBIOFG         MAY BE ONLY WARNING FLAGS
         N     R0,CLRSIOFR         CLEAR ALL BUT PROHIBITED FLAGS
         BNZ   SHARES              SKIP IS ANY OF THESE FLAGS ON.
*                                  ONLY WARNING FLAGS SET
         TM    APUBIOF1-APUB(RAPUBPTR),X'FF' PREVIOUS BEST CHOICE
*                                  * HAVE WARNINGS ?
         BZ    SHARES              * NO -- SKIP THIS NEW APUB
SHAREG   EQU   *                   RXAPUB->APUB IS ACCEPTABLE
*
** APUB POINTED TO BY RXAPUB IS ACCEPTABLE.
** SET RAPUBPTR TO BETTER CHOICE.
** NOTE:R0 CURRENTLY 0.
*
         A     R0,APUBIOCT         NUMBER OF OUTSTANDING I/O'S
*                                  * WEIGHTED BY ELASPED I/O TIME
         BNZ   SHAREK              IF SUBCHANNEL FREE AND ONLY 1-3838,
         CLI   APCTCTUB,1          * THIS IS BEST SUBCHANNEL,
         BH    SHAREK              * SO TERMINATE SCAN
         TM    APUBIOF1,X'FF'      * UNLESS WARNINGS SET.
         BNZ   SHAREM              * THEN IS BEST SO FAR.
         LR    RAPUBPTR,RXAPUB     POINT TO SELECTED APUB
         B     SHAREY              TERMINATE APUB SCAN LOOP
SHAREK   EQU   *                   I/O IS PROGRESS OR
*                                  * MORE THAN 1-3838.
         C     R0,APUBIOCT-APUB(,RAPUBPTR) COMPARE NUMBER OF
*                                  OUTSTANDING I/O'S
         BH    SHARES              DONOT USE IF MORE THAN CURRENT BEST
         BL    SHAREM              USE IS LESS THAN CURRENT BEST
*                                  * IF EQUAL, COMPARE ENTIRE 3838
*                                  WORKLOAD
         L     R14,APUBMSTR        SUBCHANNEL-0 FOR CURRENT APUB
         L     R0,APUBIOCT-APUB(,R14) I/O CURRENT FOR 3838
         L     R14,APUBMSTR-APUB(,RAPUBPTR) I/O COUNT FOR BEST 3838
         C     R0,APUBIOCT-APUB(,R14) IF NEW 3838 HAS LESS I/O
         BNL   SHARES              * THAN CURRENT BEST, USE NEW ONE.
SHAREM   EQU   *                   NEW UNIT SELECTED
*
** NEW APUB IS "BETTER" UNIT
*
         LR    RAPUBPTR,RXAPUB     SAVE CURRENT "BEST" ADDRESS
SHARES   EQU   *                   FIND NEXT APUB
*
** RAPUBPTR CONTAINS "BEST" APUB CHOICE, SO FAR.
*
         L     RXAPUB,APUBNXIO     NEXT APUB (IF ANY)
         B     SHAREA              CONTINUE APUB SCAN
SHAREY   EQU   *
*
** RAPUBPTR POINTS TO SELECTED APUB (OR CAPUB IF
** NO SUBCHANNEL.  UPDATE THE APIO TO POINT TO
** THIS APUB/UCB.  THEN INSURE THAT THE APUB IS
** STILL VALID (MAY BE CAPUB OR VARIED OFFLINE SINCE
** NOT ENQUEUED ON THE APUB MAJOR/MINOR).  IF NOT
** VALID AND NOT THE FAKE APUB, JUST RETRY THE LOOP.
** IF THE FAKE APUB (CAPUB) IS THE 'BEST', IT IS AN ERROR.
*
         DROP  RXAPUB              FINIHSED WITH TEMPORARY SCANNER
         USING APUB,RAPUBPTR       POINT TO SELECTED APUB
         ST    RAPUBPTR,APIOAPUB   SAVE APUB/UCB ADDRESSES
         L     R0,APUBUCB          * IN THE APIO (INCLUDES IOSB).
         ST    R0,IOSUCB           SAVE APIO ADDRESS IN UCB
         L     R0,APUBIOFG         INSURE SELECTED SUBCHANNEL STILL OK
         N     R0,CLRSIOFR         CLEAR ALL BUT PERMANENT FAILURE
         BZ    SHARESET            IF ZERO, SUBCHANNEL OK
         LA    R0,CAPUB            SEE IF FAK APUB ('CAPUB')
         CR    RAPUBPTR,R0         * IF NO -- RETRY THE ENTIRE LOOP
         BNE   SHAREFND            * IF YES -- IS ERROR
         B     ERRORE              FORCE ERROR CONDITION
SHARESET EQU   *                   BEST APUB FOUND SET IN APIO
         DROP  APCTPTR             FINISHED WITH POINTER
         SPACE 4
PORTSET  EQU   *                   APUB SELECTED
*
** SUBCHANNEL SELECTED (SHARED AND EXCLUSIVE).
** APIO NOW POINTS TO THE ASSOCIATED APUB AND UCB.
*
** CURRENTLY ASSIGNED REGISTERS:
**      R3         CVTMAP
**      R5         APUB
**      R6         BASE REGISTER
**      R8         DFRRSTK
**      R9         APIO (INCLUDES IOSB AND SRB)
         EJECT ,
***********************************************************************
**                                                                   **
** CONVERT THE VIRTUAL ADDRESSES IN THE IOSB,                        **
** CCWS AND IDALS TO REAL ADDRESSES. THE APXL                        **
** IS USED FOR THIS CONVERSION. SINCE THE LOCAL LOCK                 **
** IS OWNED AND KEPT UNTIL THE STARTIO IS ISSUED                     **
** SRM/ASM WILL NOT "MOVE" THE PAGES AROUND IN                       **
** STORAGE. (NOTE: A PAGE BEING "FIXED" DOES NOT                     **
** PREVENT IT FROM BEING MOVED IN MVS.)                              **
**                                                                   **
***********************************************************************
         SPACE 2
         L     R1,APIOAPXL         POINT TO TRANSLATE TABLE
         L     R15,APXLLAST-APXL(,R1) LAST ENTRY MINUS HEADER LENGTH
         LA    R14,APXLLN1         ENTRY LENGTH
         USING APXL-APXLLN0,R1     ALLOW FOR HEADER
XLTEL1   EQU   *                   TRANSLATE LOOP
         LM    RTEMPB,RTEMPC,APXLADDR VIRTUAL/STORE ADDRESSES
         LRA   RTEMPB,0(,RTEMPB)   FIND REAL ADDRESS
         BNZ   ERRORF              IF NOT FOUND, IS ERROR
         STCM  RTEMPB,B'0111',1(RTEMPC) PLACE IN LOW 3-BYTES
         BXLE  R1,R14,XLTEL1       CONTINUE LOOP
*
** ALL ADDRESSES CONVERTED TO REAL
*
*
** CURRENTLY ASSIGNED REGISTERS:
**      R3         CVTMAP
**      R5         APUB
**      R6         BASE REGISTER
**      R8         DFRRSTK
**      R9         APIO (INCLUDES IOSB AND SRB)
         EJECT ,
***********************************************************************
**                                                                   **
** UPDATE THE I/O STATISTICS IN THE APUB.                            **
** NOTE: APUB ERROR STATISTICS ARE ONLY APPROXIMATE.                 **
**                                                                   **
***********************************************************************
         SPACE 2
*
** INCREMENT THE NUMBER OF ACTIVE I/O REQUESTS FOR
** THE SELECTED 3838 SUBCHANNEL.  USE THE PREVIOUS
** EXECUTION'S ELAPSED TIME AS A WEIGHT.  ALTOUGH THIS
** TIME IS NOT REPEATABLE (SYSTEM ACTIVITY, DATA DEPENDENCIES),
** IT IS THE BEST GUESS OF NEW EXECUTION TIME. THIS HELPS
** DISTRIBUTE THE PROCESSING LOAD ACROSS SUBCHANNELS AND
** MULTIPLE 3838'S.
*
** REGISTERS DESTROYED BY THESE ROUTINES: 0, 1, 14, 15
*
         OI    APIOFLG3,APIOIOCT   SHOW APIO INCLUDED IN APUBIOCT
         L     R14,APIOXTME        LAST EXECUTION ELAPSED-I/O TIME
         SPACE 1
         L     R1,APUBIOCT         CURRENT ACTIVITY ON SUBCHANNEL
IOCOUNT1 EQU   *                   'CS' FAIL RETRY POINT
         LR    R0,R1               INCREMENT COUNT BY PREVIOUS
         AR    R0,R14              * EXECUTION'S ELAPSED TIME
         CS    R1,R0,APUBIOCT      SAVE UPDATED COUNT
         BNZ   IOCOUNT1            RETRY IF 'CS' FAILED
*
** PERFORM THE SAME PROCESSING FOR THE MASTER (SUBCHANNEL-0)
** APUB OF THE SELECTED 3838.  THIS IS USED TO BALANCE THE
** LOAD ACROSS MULTIPLE 3838'S.
*
         L     R15,APUBMSTR        ADDRESS OF ASSOCIATED SUBCHANNEL 0
         USING APUB,R15            TEMPORARY CHANGE IN BASE REGISTER
         L     R1,APUBIOCT         CURRENT 3838 LOAD (ENTIRE 3838)
IOCOUNT3 EQU   *                   'CS' FAIL RETRY POINT
         LR    R0,R1               INCREMENT COUNT BY PREVIOUS
         AR    R0,R14              * EXECUTIONS'S ELAPSED TIME
         CS    R1,R0,APUBIOCT      SAVE UPDATED COUNT
         BNZ   IOCOUNT3            RETRY IF 'CS' FAILED
         DROP  R15                 FINISHED WITH SUBCHANNEL-0
*
** UPDATE NUMBER OF I/O REQUESTS ISSUED
** IN THIS ERROR DETECTION CYCLE. IF THE
** CYCLE LIMIT HAS BEEN EXCEEDED, RESET THE
** ERROR COUNTERS TO 0 AND SET THE NUMBER OF
** I/O REQUESTS THIS CYCLE TO 1.
*
** NOTE THAT THE ERROR COUNTS ARE ONLY APPROXIMATE.
** SERIALIZATION IS NOT USED TO CLEAR THE APUBERRS
** COUNTS.  THEREFORE AN ERROR MAY NOT BE COUNTED.
** THE ADDITION OF SERIALIZTION (CMS LOCK) WOULD
** SERIOUSLY DEGRADE PERFORMACE.  THE LOSS OF AN
** OCCASIONAL ERROR COUNT UPDATE SHOULD NOT AFFECT
** RELIABILITY.
*
         L     R15,APUBAPCT        POINT TO APCT
         L     R1,APUBERRT         CURRENT I/O COUNT
CTAPUB1  EQU   *                   COMPARE-AND-SWAP RETRY POINT
         LA    R0,1(,R1)           INCREMENT COUNT
         CH    R0,APCTERTT-APCT(,R15) CYCLE LIMIT EXCEEDED ?
         BL    CTAPUB2             * YES -- RESET ERROR COUNTS
         LA    R0,1                RESET NUMBER I/O REQUEST THIS CYCLE
         XC    APUBERRS,APUBERRS   CLEAR ERROR COUNTS
CTAPUB2  EQU   *                   SKIP RESET POINT
         CS    R1,R0,APUBERRT      SAVE I/O COUNT
         BNZ   CTAPUB1             IF CS FAILED, RETRY LOOP
         SPACE 1
         DROP  RAPUBPTR            FINISHED WITH APUB
*
** CURRENTLY ASSIGNED REGISTERS:
**      R3         CVTMAP
**      R6         BASE REGISTER
**      R8         DFRRSTK
**      R9         APIO (INCLUDES IOSB AND SRB)
         EJECT ,
***********************************************************************
**                                                                   **
** PERFORM PROCESSING RELATED TO SYNCHRONOUS/ASYNCHRONOUS I/O.       **
** THIS INCLUDES DETERMINING THE EXIT ADDRESS.                       **
** 'RCODE' (BASED REGISTER) IS NEGATIVE IF ASYNCHRONOUS, AND         **
** POSITIVE IF SYNCHRONOUS.                                          **
**                                                                   **
***********************************************************************
         SPACE 2
         LTR   RCODE,RCODE         SYNCHRONOUS I/O ?
         BP    SYNCH               * YES -- GO PROCESS
*
** ASYSNCHRONOUS PROCESSING WANTED (WAIT/POST)
*
** APIOSYNC ALREADY ZET TO 0 (SHOWS ASYNCHRONOUS PROCESSING).
** SET REGISTER 13 TO THE ADDRESS OF THE STANDARD BRANCH
** ENTRY ADDRESS TO TYPE-2 SVC EXIT.  REGISTER 13 IS USED
** SINCE IT IS THE ONLY REGISTER NOT DESTROYED BY THE
** 'STARTIO' MACRO.
*
** FOLLOWING REGISTERS DESTROYED: NONE
** REGISTER 13 SET TO EXIT ADDRESS (BIT-0 MUST BE 0).
*
*                                  APIOSYNC OFF = ASYNCHRONOUS
         L     R13,CVTEXPRO        USE NORMAL EXIT WHICH ATTEMPTS
*                                  * TO DISPATCH NEXT HIGHER RB.
         B     SYNCHSET            SKIP SYNCHRONOUS PROCESSING CODE
         SPACE 5
SYNCH    EQU   *                   SYNCHRONOUS I/O
*
** SYSNCHRONOUS PROCESSING WANTED (SUSPEND/RESUME)
*
** SET APIOSYNC = 1 (SHOWS SYNCHRONOUS PROCESSING).
*
         OI    APIOFLG0,APIOSYNC   SHOW SYNCHRONOUS PROCESSING
*
** SUSPEND THE PREVIOUS RB (USER).  THE SUSPEND MUST BE
** ISSUED PRIOR TO THE STARTIO. (ACTUALLY -- BEFORE
** THE RESUME).  THEN SET REGISTER 13 TO THE ADDRESS
** OF THE FORCE-DISPATCH SVC EXIT ROUTINE.  SINCE THE
** PREVIOUS RB HAS BEEN "SUSPENDED" THERE IS NO REASON
** TO CHECK FOR DISPATCHABILITY.
*
** FOLLOWING REGISTERS DESTROYED: 11,12,13,14,15.
** FOLLOWING REGISTERS SET BY RESUME:
**       0 = ADDRESS OF SUSPENDED TCB.
**       1 = ADDRESS OF SUSPENDED RB.
** REGISTER 13 SET TO EXIT ADDRESS (BIT-0 MUST BE 0).
*
         MVI   DFRRCODE,CERRN03    SET ERROR CODE
         SUSPEND RB=PREVIOUS       SUSPEND CALLER'S RB
         STM   R0,R1,APIOTR        SAVE SUSPENDED TCB/RB
*                                  * IN APIOTCB/APIORB.
         MVI   DFRRCODE,CERRN99    RESET DEFAULT CODE
         L     R13,CVTEXP1         FORCE DISPATCH SEARCH SINCE
*                                  * PREVIOUS RB NON-DISPATCHABLE
*                                  * (SUSPENDED - RESUME NOT ISSUED)
         OI    APIOFLG3,APIORSME   SHOW RESUME REQUIRED (RECOVERY)
         SPACE 5
SYNCHSET EQU   *                   APIO UPDATED
*
** APIO UPDATED FOR SYNCHRONOUS/ASYNCHRONOUS PROCESSING
*
*
** CURRENTLY ASSIGNED REGISTERS:
**      R3         CVTMAP
**      R6         BASE REGISTER
**      R8         DFRRSTK
**      R9         APIO (INCLUDES IOSB AND SRB)
**      R13        EXIT ADDRESS
*
         EJECT ,
***********************************************************************
**                                                                   **
** CONTROL BLOCKS BUILT.  CANCEL THE RECOVERY ENVIRONMENT.           **
** KEEP THE LOCAL LOCK.                                              **
**                                                                   **
***********************************************************************
         SPACE 2
*
** CANCEL THE FRR. THE LOCAL LOCK STILL HELD TO PREVENT
** CANCELLATION, DETACH, ETC.
*
** REGISTERS DESTROYED: R14,R15  (SEE WRKREGS OPTION)
*
         DROP  RFRRSTK             DONE WITH RECOVERY DSECT
         SETFRR D,                 DELETE RECOVERY ENVIRONMENT         *
               WRKREGS=(R14,R15),  * (PREPARATION FOR EXIT)            *
               RELATED=(DFRRSTK,EXIT,CALLDISP)
*
** CURRENTLY ASSIGNED REGISTERS:
**      R3         CVTMAP
**      R6         BASE REGISTER
**      R9         APIO (INCLUDES IOSB AND SRB)
**      R13        EXIT ADDRESS
         EJECT ,
***********************************************************************
**                                                                   **
** APIO/IOSB/SRB CONSTRUCTED.  SCHEDULE THE I/O REQUEST.             **
**                                                                   **
***********************************************************************
         SPACE 2
*
** SRB ADDRESS IS IN THE APIO AT LABEL APIOSRB.
** SAVE THE TOD CLOCK.  THIS IS USED FOR 3838
** LOAD BALANCE PROCESSING.  THEN ISSUE THE
** STARTIO.
*
** REGISTERS DESTROYED:  ALL BUT REGISTER 13.
*
         STCK  APIOSAVE+2          SAVE TOD CLOCK.
         L     R1,APIOSAVE+4       SET APIOTMES TO START TIME.  USE
         LA    R1,0(,R1)           * BITS 24-43 OF THE TOD CLOCK.
         SRL   R1,4                * BITS 0-11 = 0
         ST    R1,APIOTMES         * BITS 12-31 = BITS 24-43 OF TOD CLK
*                                  * (BIT 19 = APRROX 1 SEC)
         SPACE 2
         LA    R1,APIOSRB          POINT TO SRB
         STARTIO SRB=(1),TCB=SRB   ISSUE I/O REQUEST. SRB POINTS TO TCB
         SPACE 3
*
** CURRENTLY ASSIGNED REGISTERS:
**      R13        EXIT ADDRESS
*
         EJECT ,
***********************************************************************
**                                                                   **
** I/O PROCESSING COMPLETE.  PERFORM EXIT LOGIC                      **
**                                                                   **
***********************************************************************
         SPACE 2
         BR    R13                 EXIT
         SPACE 5
***********************************************************************
**                                                                   **
** PROCESSING COMPLETE.  ALL RESOURCES RELEASED                      **
**                                                                   **
***********************************************************************
         EJECT ,
***********************************************************************
**                                                                   **
**                           ERROR EXITS                             **
**                                                                   **
**  SET ERROR CODE IN 'DFRRCODE' AND THEN ABEND.  THIS FORCES        **
**  CONTROL TO 'XSTAE' TO LOG THE ERROR AND BACK-OUT ANY             **
**  UPDATES.                                                         **
**                                                                   **
***********************************************************************
         SPACE 2
         USING DFRRSTK,RFRRSTK     FRR ESTABLISHED DURING
*                                  * DRIVER PROCESSING
         DS    0H                  INSURE ALIGNMENT
ERRORA   EQU   *                   SETLOCK FAILED
         L     R1,APDXAPCT-APDX(,RAPDXPTR) FRR NOT ESTABLISHED
         L     R1,APCTABND-APCT(,R1) * ABEND TO SHOW LOCK NOT AVAILABLE
         ABEND (1)                 * LOGS PROBLEM (SYSTEM)
         SPACE ,
ERRORB   EQU   *                   INVALID APIO SPECIFIED
         MVI   DFRRCODE,CERRN04    SHOW ERROR
         B     ERRORZ              GO TO COMMON ERROR EXIT LOGIC
         SPACE ,
ERRORC   EQU   *                   APIO ALREADY ACTIVE
         MVI   DFRRCODE,CERRN05    SHOW ERROR
         B     ERRORZ              GO TO COMMON ERROR EXIT LOGIC
         SPACE ,
ERRORD   EQU   *                   PGFIX FAILED
         MVI   DFRRCODE,CERRN02    SHOW ERROR
         B     ERRORZ              GO TO COMMON ERROR EXIT LOGIC
         SPACE ,
ERRORE   EQU   *                   CANNOT FIND USABLE PORT
*                                  (UNALLOCATION MUST LEAVE ONE AROUND)
         MVI   DFRRCODE,CERRN06    SHOW ERROR
         B     ERRORZ              GO TO COMMON ERROR EXIT LOGIC
         SPACE ,
ERRORF   EQU   *                   'LRA' INSTRUCTION FAILED
         MVI   DFRRCODE,CERRN08    SHOW ERROR
         B     ERRORZ              GO TO COMMON ERROR EXIT LOGIC
         SPACE ,
         SPACE 2
ERRORG   EQU   *                   APIO OVERLAID
         MVI   DFRRCODE,CERRN09    SHOW ERROR
         B     ERRORZ              GO TO COMMON ERROR EXIT LOGIC
         SPACE ,                                               @ZA26916
ERRORH   EQU   *                   0 COUNT OR WRAP-AROUND      @ZA26916
         MVI   DFRRCODE,CERRN15    SHOW ERROR                  @ZA26916
         B     ERRORZ              GO TO COMMON ERROR EXIT CODE@ZA26916
         SPACE ,
ERRORJ   EQU   *                   3838 FOR EXCLUSIVE USER RE-IPL'ED
         MVI   DFRRCODE,CERRN07    SHOW ERROR
         B     ERRORZ              GO TO COMMON ERROR EXIT LOGIC
         SPACE 2
ERRORZ   EQU   *                   COMMON ERROR EXIT LOGIC
         L     R1,DFRRAPCT         FIND APCT
         L     R1,APCTABND-APCT(,R1) ABEND CODE/DUMPT
         ABEND (1)                 TAKE DUMP
*
** CONTROL PASSES TO 'XSTAE' VIA RTM/1.
*
         DROP  RFRRSTK             FINISHED WITH RECOVERY POINTER
         EJECT ,
XSTAE    EQU   *
         SPACE ,
***********************************************************************
**                                                                   **
**     ABEND OCCURRED.  THIS FRR EXIT GAINS CONTROL FROM RTM/1.      **
**     THIS ROUTINE WILL BUILD AN 'APES' (THE STANDARD VPSS          **
**     ERROR RECOVERY INTERFACE), AND THEN PASS CONTROL TO 'IGTUKA'  **
**     FOR PROCESSING (STANDARD VPSS RECOVERY ROUTINE).  THIS        **
**     TECHNIQUE ALLOWS THE USE OF THE STANDARD VPSS RECOVERY        **
**     PROCESSING WITHOUT THE OVERHEAD OF BUILDING THE APES ON       **
**     NON-ERROR CALLS.  CONTROL WILL BE PASSED TO IGTUKA AS IF      **
**     IT WERE DEFINED AS THE INITIAL FRR PROGRAM.                   **
**                                                                   **
**     THE APVU WORKAREA IS USED BY THIS ROUTINE.  ALTHOUGH THIS     **
**     REQUIRES THE CMS LOCK, THERE SHOULD BE NO PROBLEM SINCE       **
**     THIS PROCESSING IS SELDOM REQUIRED.                           **
**                                                                   **
**     CONTROL WILL BE RETURNED TO 'XSTAE2' WHEN IGTUKA COMPLETES    **
**     RECOVERY (AFTER LOGGING THE ERROR).                           **
**                                                                   **
***********************************************************************
         SPACE 2
         PUSH  USING               REGISTERS DESTROYED ON ENTRY
         DROP  ,                   TO FRR.  ONLY THE FOLLOWING
*                                  REGISTERS OK --
         USING XSTAE,R15           BASE REGISTER
         USING SDWA,R1             DIAGNOSITC WORKAREA
*                                  R0 -> 200 BYTE WORKAREA
         USING FLC,*-*             ABSOLUTE ADDRESSING
         DROP  R15                 DONE WITH BASE
         LR    R15,R0              PUT WORKAREA ADDR IN USEFULL
*                                  REGISTER
         STM   R0,R15,0(R15)       SAVE INPUT REGISTERS
         LR    RFRRSAVE,R0         KEEP IN STABLE REGISTER
         BALR  R15,*-*             *** MUST PRECEDE 'LA'
         LA    RCODE,*-IGTKBA      *** MUST FOLLOW 'BALR'
         LCR   RCODE,RCODE         RE-ESTABLISH BASE REGISTER
         AR    RCODE,R15           TO STANDARD ADDRESS
         LR    RSDWAPTR,R1         KEEP SDWA ADDRESS IN STABLE REGISTER
         DROP  R1                  FINISHED WITH TEMPORARY REGS
         USING SDWA,RSDWAPTR       STANDARD POINTER
         USING IGTKBA,RCODE        STANDARD BASE
         L     RFRRSTK,SDWAPARM    POINT TO DFRRSTK
         USING DFRRSTK,RFRRSTK     TELL ASSEMBLER
*
** INSURE APCT ADDRESS IN RECOVERY WORKAREA OK.
** IF NOT, THEN JUST CONTINUE THE ABEND SINCE
** THE REQUIRED POINTERS ARE NOT YET SAVED IN THE
** 6-WORD RECOVERY WORKAREA.
*
         L     APCTPTR,DFRRAPCT    POINT TO APCT
         USING APCT,APCTPTR        TELL THE ASSEMBLER
         SRL   APCTPTR,2           INSURE APCTPTR CONTAINS
         SLL   APCTPTR,2           FULLWORD-ALIGNED ADDRESS
         LRA   R0,APCT             INSURE ADDRESS IN REAL MEMORY
         BNZ   XSTAE1A             (APCT FIXED).
         L     R0,CAPCTID          INSURE REALLY APCT. IF NOT,
         C     R0,APCTID           CONTINUE THE ABEND.
         BNE   XSTAE1A             * (MUST BE EARLY IN PROCESSING)
         DROP  APCTPTR             SETLOCK WILL DESTROY APCTPTR
*
** OBTAIN THE CMS LOCK.  THIS IS REQUIRED TO USE
** THE APVU WORKAREA (APVUWORK).  THE CMS LOCK
** MUST BE MAINTAINED THROUGHOUT THE RECOVERY
** PROCESS SINCE THE 'APES' IS CONSTRUCTED IN
** 'APVUWORK'.
*
** REGISTERS DESTROYED: 11, 12, 13, 14
** REGISTERS SET: R13 SET TO SETLOCK RETURN CODE
*
         SETLOCK OBTAIN,TYPE=CMS,  GET THE CMS LOCK                    *
               MODE=UNCOND,        * REQUIRED TO USE THE WORKAREA      *
               RELATED=APVU        * IN THE APVU (APVUWORK).
         LTR   R13,R13             CHECK SETLOCK RETURN CODE
         BNZ   XSTAE1A             IF FAIL, QUIT
         SPACE 2
***********************************************************************
**                                                                   **
**     BUILD AN 'APES' IN 'APVUWORK'.  THIS WORKAREA IS MAPPED BY    **
**     THE LOCAL DSECT 'DVUDSECT'.  SET RETRY REGISTERS TO THE       **
**     FOLLOWING:                                                    **
**              3 - ADDRESS OF THE CVT (CVTMAP)                      **
**              6 - ADDRESS OF IGTKBA (BASE REGISTER)                **
**              7 - ADDRESS OF DVUDSECT (APVUWORK)                   **
**              8 - ADDRESS OF DFRRSTK (6-WORD FRR WORKAREA)         **
**              9 - ADDRESS OF APIO (INCLUDES IOSB AND SRB)          **
**             12 - ADDRESS OF APCT                                  **
**             15 - ADDRESS OF THE RETRY ROUTINE (XSTAE2)            **
**     NOTE THAT DEPENDING UPON WHERE THE ERROR OCCURRED, CERTAIN    **
**     VALUES MAY BE INVALID.  DETERMINATION OF THIS IS A            **
**     REQUIREMENT OF THE RETRY ROUTINE.                             **
**                                                                   **
***********************************************************************
         SPACE ,
         L     APCTPTR,DFRRAPCT    POINT TO APCT
         USING APCT,APCTPTR        TELL ASSEMBLER
         L     RVUWORK,APCTAPVU    POINT TO WORKAREA IN
         LA    RVUWORK,APVUWORK-APVU(,RVUWORK) * APVU (APVUWORK).
         USING DVUDSECT,RVUWORK    TELL THE ASSEMBLER
         LA    R0,APES             INITIALIZE APES WITH
         LA    R1,APESLN           * STANDARD HEADER INFORMATION.
         LA    R14,CAPES           * INITIALIZE REMAINDER OF APES
         LA    R15,L'CAPES         * TO ZEROS (FOR DEBUGGING).
         MVCL  R0,R14              NOTE: APES > 256 BYTES
         LA    R1,APES             SET 1ST WORD OF 6-WORD FRR
         ST    R1,DFRRAPES         * AREA TO @ APES
         ST    R1,APESADDR         * THIS IS IGTUKA REQUIREMENT.
         LA    R1,APESREGZ         INITIALIZE POINTER TO
         ST    R1,APESREGP         * RETRY REGISTER VALUES.
*                                  * INITIALIZE ADDITIONAL RETRY REGS
         L     RCVTPTR,FLCCVT      CVT ADDRESS
         L     RAPIOPTR,DFRRAPIO   APIO ADDRESS (IF ANY)
         LA    R15,XSTAE2          SET RETRY POINT
         STM   R0,R15,APESREGZ     SAVE RETRY REGISTERS
*
** SET DUMP/RECORDING OPTIONS IN THE APES.
** USE 'DFRRCODE' TO INDEX INTO 'MERRTBL'
** TO SET 'APESFLG0'.
*
         SR    R1,R1               CLEAR HI BYTES
         ICM   R1,B'0001',DFRRCODE GET ERROR CODE
         BZ    XSTAE1B             IF OUTSIDE OF RANGE
         CLI   DFRRCODE,CERRN99    * 0 < DFRRCODE <= CERRN99
         BNH   XSTAE1C             * USE CERRN99
XSTAE1B  EQU   *                   * (IE SET TO
         LA    R1,CERRN99          *  'UNEXPECTED ERROR')
XSTAE1C  EQU   *                   R1 = ERROR INDEX
         STC   R1,APESCODE         SAVE ERROR CODE IN APES
         SLL   R1,3                SET MERRTBL INDEX (ENTRY = 8-BYTES)
         IC    R1,XESFLG0-APESMV+MERRTBL-APESMVLN(R1) PUT APESFLG0
*                                  * IN APES (ENTRY 0 IS ERR # 1)
         STC   R1,APESFLG0         (DUMP/LOG REQUIREMENTS)
         SPACE 2
***********************************************************************
**                                                                   **
**     APES BUILT.  ISSUE SETFRR TO RESET THE RETRY ADDRESS TO       **
**     'IGTUKA'.  RECURSION PROCESSING WILL THEN GO DIRECTLY TO      **
**     THE STANDARD VPSS RECOVERY ROUTINE (OK SINCE THE APES         **
**     IS NOW CONSTRUCTED).  THE 6-WORD RECOVERY AREA WILL NOT       **
**     BE MODIFIED.  THEN PASS CONTROL TO 'IGTUKA' TO PROCESS THIS   **
**     INITIAL ERROR.  REGISTERS 0-14 ARE THE SAME AS WHEN THIS      **
**     ROUTINE WAS ENTERED.  REGISTER 15 IS SET TO THE ADDRESS OF    **
**     'IGTUKA'.  THEREFORE IT APPEARS TO 'IGTUKA' THAT IT WAS THE   **
**     INITIAL RECOVERY ROUTINE.  CONTROL WILL BE RETURNED TO        **
**     'XSTAE2' WHEN RECOVERY IS COMPLETE.                           **
**                                                                   **
***********************************************************************
         SPACE ,
*
** ISSUE SETFRR TO CHANGE EXIT TO 'IGTUKA'.
*
** REGISTERS DESTROYED: 14, 15 (SEE WRKREGS OPTIONS)
*
         SETFRR R,FRRAD=APCTZUKA,  REPLACE CURRENT FRR WITH ENTRY      *
               WRKREGS=(R14,R15),  * TO IGTUKA.  DO NOT CLEAR          *
               RELATED=(DFRRSTK)   * 6-WORD WORKAREA -- DFRRSTK
         SPACE ,
         L     R15,APCTZUKA        GO TO STANDARD RECOVERY ROUTINE
         LM    R0,R14,0(RFRRSAVE)  * PASS SAME REGISTERS AS ON
         BR    R15                 * INPUT EXCEPT R15 -> NEW EXIT
*                                  * ROUTINE (IGTUKA)
         SPACE ,
*
** CONTROL DOES NOT RETURN HERE
** BUT PASSES TO 'XSTAE2'.
*
         SPACE 5
*
** INVALID INPUT TO FRR -- CANNOT LOCATE APCT
** RETURN TO RTM/1 TO PERCOLATE THE ERROR
*
         SPACE ,
XSTAE1A  EQU   *                   UNABLE TO RECOVER
         LM    R0,R15,0(RFRRSAVE)  RE-LOAD INPUT REGISTERS
         BR    R14                 RETURN TO RTM
         SPACE ,
         POP   USING               RESTORE INITIAL USING STATUS
         EJECT ,
XSTAE2   EQU   *                   RECOVERY LOGIC
         SPACE ,
***********************************************************************
**                                                                   **
**     IGTKBA RECOVERY ROUTINE.  THIS ROUTINE GAINS CONTROL FROM     **
**     IGTUKA TO RELEASE RESOURCES ACQUIRED BY IGTKBA PRIOR TO THE   **
**     FAILURE AND TO INDICATE THE FAILURE TO THE USER.  TO          **
**     MAXIMIZE RECOVERY, RECURSION RECOVERY IS PROVIDED TO FREE     **
**     AS MANY ACQUIRED RESOURCES AS POSSIBLE.  TO PROVIDE THIS      **
**     BACK-OUT CAPABILITY WHILE PREVENTING ENDLESS LOOPS, THE       **
**     FOLLOWING IS DONE FOR EACH RESOURCE TO BE RELEASED:           **
**          1.  RESET THE APPROPRIATE "BACK-OUT REQUIRED" INDICATOR  **
**          2.  SHOW RECOVERY COMPLETE (THUS ALLOWING RECURSION)     **
**          3.  PERFORM THE ACTUAL BACK-OUT.                         **
**     IF A FAILURE OCCURS FREEING A RESOURCE, THE NEXT PASS THRU    **
**     THIS LOGIC WILL BYPASS FREEING THE SAME RESOURCE.             **
**                                                                   **
***********************************************************************
         SPACE 2
*
**     FOLLOWING REGISTERS INITIALIZED ON ENTRY:
**              3 - ADDRESS OF THE CVT (CVTMAP)
**              6 - ADDRESS OF IGTKBA (BASE REGISTER)
**              7 - ADDRESS OF DVUDSECT (APVUWORK)
**              8 - ADDRESS OF DFRRSTK (6-WORD FRR WORKAREA)
**              9 - ADDRESS OF APIO (INCLUDES IOSB AND SRB)
**             12 - ADDRESS OF APCT
**             15 - ADDRESS OF THE RETRY ROUTINE (XSTAE2)
**     NOTE THAT DEPENDING UPON WHERE THE ERROR OCCURRED, CERTAIN
**     VALUES MAY BE INVALID.
*
         SPACE 2
         PUSH  USING               SAVE USING STATUS
         DROP  ,                   RESET ALL REGISTER DEFINITIONS
         USING CVTMAP,RCVTPTR      TELL ASSEMBLER OF
         USING IGTKBA,RCODE        * BASE REGISTERS
         USING DVUDSECT,RVUWORK    * FOR THE RETRY
         USING DFRRSTK,RFRRSTK     * ROUTINE
         USING APIO,RAPIOPTR
         USING APCT,APCTPTR
         USING FLC,*-*             ABSOLUTE ADDRESSING 0-4095
         DROP  APCTPTR             REG 12 IS LOCALLY DESTROYED
         SPACE ,
         MVI   APESCODE,CERRN99    SET "UNEXPECTED ERROR" INDICATOR
         OI    APESFLG0,APESFDMP+APESFREC+APESFSDP SET STANDARD
*                                  * LOGGING/DUMPING INDICATORS
         LTR   RAPIOPTR,RAPIOPTR   APIO EXIST ?
         BZ    NREC20              * NO -- JUST GO FLAG APRL SINCE
*                                  * RESOURCES ARE TIED TO AN APIO.
         L     R0,CAPIOID          INSURE VALID APIO
         C     R0,APIOID           * SKIP PROCESSING IF NOT
         BNE   NREC20              * (PREVENTS STORAGE OVERLAY)
         CLI   APIOACTV,0          APIO ACTIVE ?
         BE    NREC20              * IF NOT, ALSO SKIP
         SPACE ,
*
** IF SUSPEND ISSUED (APIORSME = 1), ISSUE RESUME
*
         TM    APIOFLG3,APIORSME   RESUME REQUIRED ?
         BZ    NREC01Z             * NO -- TRY NEXT RESOURCE
         NI    APIOFLG3,X'FF'-APIORSME RESET RESUME-REQUIRED INDICATOR
         NI    APESFLG1,X'FF'-APESFPRV SHOW RECOVERY COMPLETE
         MVI   APESCODE,CERRN11    SET ERROR INDICATOR
*
** FOLLOWING REGISTERS DESTROYED: 0, 1, 4, 5, 11, 12, 13, 14, 15
*
         LM    R4,R5,APIOTR        R4 = TCB, T5 = RB
         RESUME TCB=(4),RB=(5)     SET WAIT COUNT TO ZERO
         MVI   APESCODE,CERRN99    RESET STANDARD ERROR ID
         SPACE ,
NREC01Z  EQU   *                   RESUME ISSUED IF REQUIRED
         SPACE 2
*
** IF APUB I/O COUNT INCLUDES THIS APIO,
** ADJUST THE COUNTS SINCE THE I/O WILL NOT BE
** ISSUED.
*
         TM    APIOFLG3,APIOIOCT   APUB I/O COUNTS INCLUDE THIS APIO ?
         BZ    NREC02Z             * NO -- TRY NEXT RESOURCE
         NI    APIOFLG3,X'FF'-APIOIOCT RESET COUNT-INCLUDED INDICATOR
         NI    APESFLG1,X'FF'-APESFPRV SHOW RECOVERY COMPLETE
         MVI   APESCODE,CERRN12    SET ERROR INDICATOR
         MODESET EXTKEY=SCHED      GO TO APUB KEY
*
** FOLLOWING REGISTERS DESTROYED: 0, 1, 14, 15
*
         L     R14,APIOXTME        I/O VALUE TO SUBTRACT
         L     R15,APIOAPUB        APUB WHICH WAS TO PROCESS I/O
         USING APUB,R15            TELL ASSEMBLER
         L     R0,CAPUBID          INSURE REALLY AT APUB
         C     R0,APUBID           * (ERROR IF NOT)
         BNE   NREC02Y             * PREVENT STORAGE OVERLAY
         L     R1,APUBIOCT         CURRENT I/O COUNT
NREC02B  EQU   *                   COMPARE-AND-SWAP RETRY POINT
         LR    R0,R1               SET R0 = NEW I/O COUNT
         SR    R0,R14              * I.E. REMOVE THIS I/O COUNT
         BNP   NREC02Y             DO NOT LET COUNT GO NEGATIVE
         CS    R1,R0,APUBIOCT      UPDATE COUNT IF POSSIBLE
         BNZ   NREC02B             RETRY IF CS FAILED
         SPACE ,
         L     R15,APUBMSTR        POINT TO MASTER APUB
         L     R0,CAPUBID          INSURE REALLY AT APUB
         C     R0,APUBID           * (ERROR IF NOT)
         BNE   NREC02Y             * PREVENT STORAGE OVERLAY
         L     R1,APUBIOCT         CURRENT I/O COUNT
NREC02C  EQU   *                   COMPARE-AND-SWAP RETRY POINT
         LR    R0,R1               SET R0 = NEW I/O COUNT
         SR    R0,R14              * I.E. REMOVE THIS I/O COUNT
         BNP   NREC02Y             DO NOT LET COUNT GO NEGATIVE
         CS    R1,R0,APUBIOCT      UPDATE COUNT IF POSSIBLE
         BNZ   NREC02C             RETRY IF CS FAILED
         SPACE ,
NREC02Y  EQU   *                   APUB ERROR DETECTED
         MODESET EXTKEY=ZERO       RESUME STANDARD KEY
         MVI   APESCODE,CERRN99    RESET STANDARD ERROR ID
         SPACE ,
NREC02Z  EQU   *                   I/O COUNTS DECREMENTED IF REQUIRED
         SPACE 2
*
** IF PGFIX COMPLETED BY IGTKBA (APIOPGFS=1)
** OR ABEND OCCURED WHILE IGTKBA PROCESSING VSL
** ENTRIES (APIOPGIP=1), ISSUE PGFREE.  TREAT
** A COMPLETED PGFIX AS PGFIX IN PROGRESS AND
** SET THE FAILING ENTRY POINTER (DFRRVSL)
** AS IF PROCESSING THE ENTRY PAST THE END OF
** THE LIST (DFRRVSL POINTS TO FAILING ENTRY,
** SO THIS INDICATES ALL PREVIOUS ENTRIES ARE FIXED).
*
** REGISTERS DESTROYED BY ROUTINE: 0, 1, 2, 4, 14, 15
*
         TM    APIOFLG3,APIOPGIP+APIOPGFS PGFIX DONE OR IN PROGRESS ?
         BZ    NREC03Z             * NO -- TRY NEXT RESOURCE
         TM    APIOFLG3,APIOPGFS   PGFIX COMPLETE ?
         BZ    NREC03B             * NO -- GOTO IN-PROGRESS PROCESSING
         L     R15,APIOPGFL        SET FAILING ENTRY ADDRESS TO
         LA    R15,VSLLEN(,R15)    LAST ENTRY + 1
         ST    R15,DFRRVSL         THEN ACT AS IF
         XI    APIOFLG3,APIOPGIP+APIOPGFS * PGFIX IN PROGRESS
NREC03B  EQU   *                   PGFIX IN PROGRESS PROCESSING
*
** WORK FROM LAST FIXED ENTRY BACK TO INITIAL ENTRY.
** BACK-UP DFRRVSL TO PREVENT ENDLESS RECURSION.
** SHOW RECOVERY SUCCESSFUL WHEN DFRRVSL RESET.
*
         L     R15,DFRRVSL         ADDRESS OF NEXT VSL
         LA    R0,VSLLEN           SET R15 TO LAST PROCESSED ENTRY
         SR    R15,R0              * (IE PREVIOUS VSL ENTRY)
         ST    R15,DFRRVSL         SAVE FOR RECURSION
         C     R15,APIOPGFX        REACHED START OF VSL ?
         BL    NREC03D             * YES -- PGFREE COMPLETE
         NI    APESFLG1,X'FF'-APESFPRV SHOW RECOVERY COMPLETE
         MVI   APESCODE,CERRN13    SET ERROR INDICATOR
         LM    R1,R2,VSLSTRT-VSL(R15) BEGIN/END OF PGFIX AREA
         O     R1,CPGFRFLG         SHOW SHORT-TERM PGFREE
         O     R2,CSETHIBT         SHOW END-OF-LIST
         SR    R4,R4               NO TCB (SHORT TERM - NO FOE)
         LA    R0,APIOSAVE         PGFIX ECB
         L     R15,CVTVPSIB        CALL BRANCH ENTRY
         CALL  (15)                * PGFIX/PGFREE SERVICES
         B     NREC03B             GO PROCESS NEXT ENTRY
NREC03D  EQU   *                   ALL VSL ENTRIES PROCESSED
         NI    APIOFLG3,X'FF'-APIOPGIP-APIOPGFS CLEAR PGFIX DONE FLAG
         NI    APESFLG1,X'FF'-APESFPRV SHOW RECOVERY COMPLETE
         MVI   APESCODE,CERRN99    RESET STANDARD ERROR CODE
         SPACE ,
NREC03Z  EQU   *                   PGFIX COMPLETE OR NOT REQUIRED
         SPACE 2
*
** MARK APIO INACTIVE.  WHEN THIS OCCURS, THE
** APIO CANNOT BE REFERENCED AGAIN.
*
         SPACE ,
         CLI   APIOACTV,0          APIO ACTIVE ?
         BE    NREC04Z             * NO -- SKIP RESET
         MVI   APESCODE,CERRN09    SET ERROR CODE
         SR    R0,R0               CLEAR APIO POINTER TO PREVENT
         ST    R0,DFRRAPIO         * RE-USE OF DEACTIVATED APIO
         NI    APESFLG1,X'FF'-APESFPRV SHOW RECOVERY COMPLETE
         MVI   APIOACTV,0          INACTIVATE APIO
         MVI   APESCODE,CERRN99    RESET STANDARD ERROR CODE
         SPACE ,
NREC04Z  EQU   *                   APIO NOW DEACTIVATED
*                                  * AND THEREFORE CANNOT BE REFERENCED
         DROP  RAPIOPTR            * TELL ASSEMBLER
         EJECT ,
NREC20   EQU   *                   RESOURCES FREED -- FLAG APRL
*
         SPACE 2
***********************************************************************
**                                                                   **
**     RECOVERY HAS FREED SYSTEM RESOURCES.  UPDATE THE APRL TO      **
**     INDICATE THE INITIAL ERROR (APESCOD1 CONTAINS THIS VALUE).    **
**     SET ECB COMPLETION CODE TO '40' TO INDICATE ERROR DETECTED    **
**     BY IGTKBA (RATHER THAN 3838).                                 **
**                                                                   **
***********************************************************************
         SPACE 2
         L     RAPRLPTR,DFRRAPRL   ADDRESS OF APRL
         LTR   RAPRLPTR,RAPRLPTR   ANY EXIST ?
         BZ    NREC20Z             * NO -- SKIP UPDATE
         SR    R1,R1               CLEAR REGISTER
         ST    R1,DFRRAPRL         PREVENT RECURSION
         NI    APESFLG1,X'FF'-APESFPRV SHOW RECOVERY COMPLETE
         USING APRL,RAPRLPTR
         ICM   R1,B'0001',APESCOD1 INITIAL ERROR CODE
         BZ    NREC20Z             SKIP IF NO ERROR (?)
         SLL   R1,3                INDEX INTO MERRTBL
         LA    R1,MERRTBL-APESMVLN(R1) * FOR ERROR VALUES
         USING APESMV,R1           TELL ASSEMBLER
         MVI   DFRRCODE,CERRN10    SET ERROR CODE
         MODESET KEYADDR=DFRRKEY,  SWITCH TO APRL (USER)               *
               WORKREG=15          * KEY
         MVI   APRLECBC,ECBPOST    RETURN CODE = X'40'
         LH    R0,APESMVMS         MESSAGE NUMBER
         STH   R0,APRLMSGN         * MOVE TO USER'S APRL
         LH    R0,APESMVKW         KEYWORD (IF ANY)
         STH   R0,APRLVALN         * MOVE TO USER'S APRL
         IC    R0,XESRLRCN         RETURN CODE NUMBER
         STC   R0,APRLRCN          * MOVE TO USER'S APRL
         MVI   APRLRCC,APCCI       SHOW I/O ERROR
         IC    R0,XESRLRCT         SET RETURN CODE TYPE
         STC   R0,APRLRCT          * (LOGICAL, CONTROL BLOCK, I/O)
         DROP  R1,RAPRLPTR         DONE WITH POINTERS
         MODESET EXTKEY=ZERO       RESUME STANDARD KEY
         MVI   DFRRCODE,CERRN99    RESET ERROR CODE
NREC20Z  EQU   *                   APRL UPDATED TO INDICATE ERROR
         EJECT ,
***********************************************************************
**                                                                   **
**     RECOVERY PROCESSING COMPLETE.  CANCEL THE RECOVERY UMBRELLA   **
**     AND RELEASE THE OWNED LOCKS (CMS AND LOCAL).  THEN EXIT       **
**     TO THE CALLER VIA SVC 3 (TYPE-2 EXIT).  SET REGISTER          **
**     15 TO 'APCCRERR' TO INDICATE THAT PROCESSING FAILED.          **
**                                                                   **
***********************************************************************
         SPACE 2
*
** CANCEL THE RECOVERY ENVIRONMENT
** REGISTERS DESTROYED: 14, 15 (SEE WRKREGS OPTIONS)
*
         SETFRR D,                 CANCEL RECOVERY ENVIRONEMENT        *
               WRKREGS=(R14,R15),  * NOTE -- ALL CRITICAL RESOURCES    *
               RELATED=(DFRRSTK)   * MUST BE RELEASED SINCE NO RECOVERY
*
** RELEASE THE OWNED LOCKS (CMS AND LOCAL)
** REGISTERS DESTROYED: 11, 12, 13, 14
*
         SETLOCK RELEASE,TYPE=CMS, CANNOT USE APVU WHEN CMS LOCK       *
               RELATED=APVU        * RELEASED
         SETLOCK RELEASE,TYPE=LOCAL, RECOVERY MUST BE COMPLETE SINCE   *
               RELATED=SETFRR      * FRR GONE
         LA    R15,APCCRERR        SET ERROR INDICATOR
         L     R14,FLCCVT          EXIT TO TYPE-2 SVC EXIT
         L     R14,CVTEXPRO-CVTMAP(,R14) *  VIA BRANCH ENTRY
         BR    R14                 * SINCE IN KEY-0, SUPERVISOR STATE.
         SPACE 2
***********************************************************************
**                                                                   **
**     CONTROL DOES NOT RETURN HERE BUT RATHER PASSES BACK TO THE    **
**     USER (NEXT HIGHER RB) VIA SVC 3.                              **
**                                                                   **
***********************************************************************
         SPACE 2
         POP   USING               RESTORE USING STATUS
         EJECT ,
***********************************************************************
**                                                                   **
** CONSTANTS                                                         **
**                                                                   **
***********************************************************************
         SPACE 2
CXSTAEAD DC    A(XSTAE)            ADDRESS OF RECOVERY ROUTINE
CASYNCH  DC    A(X'80000000')      SHOW ASYNCHRONOUS I/O REQUESTED
*                                  * (WAIT/POST)
CSETHIBT EQU   CASYNCH,4,C'F'      SET END-OF-LIST INDICATOR IN
*                                  * PGFIX REGISTER FORM.
CPGFXFLG DC    A(X'40000000')      SHOW PGFIX WANTED (SET IN VSLFLAG1)
CPGFRFLG DC    A(X'20000000')      SHOW SHORT TERM PGFREE WANTED
CPGFIXIP DC    F'8'                RETURN CODE FROM PGFIX (IEAVPISB)
*                                  * INDICATING PAGE-IN IN PROGRESS
CPGSIZE  DC    A(4096)             PAGE SIZE
CRNDPGDN DC    A(X'00FFF000')      ROUND ADDRESS DOWN TO PAGE BOUNDARY
*                                  * AND CLEAR HI-ORDER BYTE
CRND2KDN DC    A(X'00FFF800')      ROUND DOWN TO IDAL BOUNDARY (2K)
CLRXIOF  DC    A(X'FF0000FF')      CLEAR ALL BUT EXCLUSIVE-PROHIBITED
*                                  * INDICATORS FROM APUBIOFG
CLRXIPL  DC    A(X'FFFFFF7F')      CLEAR RE-IPL BIT
CLRSIOF  DC    A(X'FFFFFF00')      CLEAR ALL BUT SHARED NOT-RECOMMENDED
*                                  * INDICATORS FROM APUBIOFG
CLRSIOFR DC    A(X'FF00FF00')      CLEAR ALL BUT SHARED-PROHIBITED
*                                  * INDICATORS FROM APUBIOFG
CAPIOFLG DC    A(X'B0008800')      CLEAR APIOFLGA BITS EXCEPT  @ZA26916
*                                  * ONES SET BY IGTKCA
CLRCOUNT DC    A(X'0000FFFF')      CLEAR FLAGS FROM CCW XFER COUNT
*                                  * (NOTE -- CANNOT USE HALFWORD)
CAPIOID  DC    A(APIOIDC)          APIO ID FIELD
CAPCTID  DC    A(APCTIDC)          APCT ID FIELD
CAPUBID  DC    A(APUBIDC)          APUB ID FIELD
         EJECT ,                                               @ZA26916
***********************************************************************
**                                                                   **
** EQUATES                                                           **
**                                                                   **
***********************************************************************
         SPACE 2                                               @ZA26916
CXIOLN   EQU   X'800'              DATA TRANSFERRED BY 1 IDAL SLOT
         EJECT ,
***********************************************************************
**                                                                   **
** RECOVERY WORKAREA FORMAT (MAXIMUM 6 WORDS)                        **
**                                                                   **
***********************************************************************
DFRRSTK  DSECT ,                   RECOVERY WORKAREA (6-WORD MAX)
DFRRAPES DS    A                   ADDRESS OF APES (MUST BE FIRST WORD)
DFRRAPIO DS    A                   ADDRESS OF APIO BEING PROCESSING
DFRRAPRL DS    A                   ADDRESS OF INPUT APRL
DFRRAPCT DS    A                   ADDRESS OF APCT
DFRRFLGS DS    0A                  FLAGS
DFRRCODE DS    1X'00'              CURRENT CERRNXX ERROR INDEX
*                                  * SEE MERRTBL FOR MEANING
DFRRKEY  DS    1X'00'              APRL KEY (FROM DEB)
         DS    1X                  *** RESERVED ***
         DS    1X                  *** RESERVED ***
DFRRVSL  DS    A                   VSL BEING PROCESSED
         SPACE ,
         NOPR  ((*-DFRRSTK)/(6*4+1)*16) 6-WORD MAX
         EJECT ,                                               @ZA26916
***********************************************************************
**                                                                   **
** CHANNEL COMMAND WORD (CCW) FORMAT                                 **
**                                                                   **
***********************************************************************
         SPACE 2                                               @ZA26916
CCW      DSECT ,                   CCW FORMAT                  @ZA26916
CCWOP    DC    01HL1'00'           OP CODE                     @ZA26916
CCWOPWR  EQU   X'01'               WRITE OP-CODE               @ZA26916
CCWOPRD  EQU   X'02'               READ OP-CODE                @ZA26916
CCWOPNOP EQU   X'03'               NO-OP OP-CODE               @ZA26916
CCWOPPRC EQU   X'0F'               PROCESS OP-CODE             @ZA26916
CCWDATA  DC    01AL3(*-*)          DATA ADDRESS                @ZA26916
CCWFLAGS DC    01BL1'00000000'     FLAGS                       @ZA26916
CCWFCD   EQU   X'80'               DATA CHAINED                @ZA26916
CCWFCC   EQU   X'40'               COMMAND CHAINED             @ZA26916
CCWFSLI  EQU   X'20'               SUPPRESS INCORRECT LENGTH   @ZA26916
CCWFSKIP EQU   X'10'               SKIP STORAGE TRANSFER       @ZA26916
CCWFPCI  EQU   X'08'               PGM CONTROLLED INTERRUPT    @ZA26916
CCWFIDA  EQU   X'04'               CCWDATA->IDAW RATHER THAN DATA
CCWFB6   EQU   X'02'               *** RESERVED ***            @ZA26916
CCWFB7   EQU   X'01'               *** RESERVED ***            @ZA26916
         DC    01BL1'00000000'     *** RESERVED ***            @ZA26916
CCWBCNT  DC    01H'0'              BYTE COUNT TO TRANSFER      @ZA26916
         SPACE ,                                               @ZA26916
CCWLN    EQU   *-CCW               LENGTH OF CCW               @ZA26916
         SPACE 5                                               @ZA26916
IGTKBA   CSECT ,                   RESUME PROGRAM CSECT        @ZA26916
         SPACE 2
         EJECT ,
***********************************************************************
**                                                                   **
**     APVUWORK OVERLAY.  CONTAINS 'APES' AND OTHER WORKAREAS        **
**     USED BY THE RECOVERY ROUTINES.  THIS AREA IS NOT AVAILABLE    **
**     DURING NORMAL PROCESSING (CMS LOCK REQUIRED TO USE APVUWORK). **
**                                                                   **
***********************************************************************
         SPACE 2
DVUDSECT DSECT ,                   APVUWORK OVERLAY
         SPACE ,
         IGTXAPES DSECT=NO         RECOVERY WORKAREA
         SPACE 5
XESFLG0  EQU   APESMV+4,1,C'X'     APESFLG0 VALUE
XESRLRCN EQU   APESMV+5,1,C'H'     APRLRCN VALUE
XESRLRCT EQU   APESMV+6,1,C'H'     APRLRCT VALUE
         SPACE ,
DVUDSECT DSECT ,                   RESUME WORKAREA
         NOPR  ((*-DVUDSECT)/(APVUHDLN+1)*16) DO NOT EXCEED APVUWORK
*                                  * ASSEMBLY ERROR IF DOES
         SPACE ,
IGTKBA   CSECT ,                   RESUME CSECT
         EJECT ,
***********************************************************************
**                                                                   **
**     'CERRN__' VALUES.  USED TO INDEX INTO 'MERRTBL' TABLE TO      **
**     DETERMINE ERROR CONDITION DETECTED AND THE DESIRED            **
**     RECOVERY MESSAGES AND PROCESSING OPTIONS.                     **
**     NOTE THAT ENTRY 0 DOES NOT EXIST, AND 'CERRN99' MUST BE THE   **
**     HIGHEST ENTRY ('UNEXPECTED ABEND').                           **
**                                                                   **
***********************************************************************
         SPACE 2
CERRN01  EQU   01                  SMF FAILURE
CERRN02  EQU   02                  PGFIX FAILURE
CERRN03  EQU   03                  SUSPEND FAILURE
CERRN04  EQU   04                  INVALID APRL (USER ERROR)
CERRN05  EQU   05                  APIO ACTIVE (USER ERROR)
CERRN06  EQU   06                  CANNOT FIND PORT
CERRN07  EQU   07                  EXCLUSIVE PORT RE-IPLED
CERRN08  EQU   08                  'LRA' INSTRUCTION FAILED AFTER PGFIX
CERRN09  EQU   09                  APIO OVERLAID
CERRN10  EQU   10                  ABEND REFERENCING APRL
CERRN11  EQU   11                  RESUME FAILED
CERRN12  EQU   12                  APUB UPDATE ERROR
CERRN13  EQU   13                  PGFREE ERROR
CERRN14  EQU   14                  PGM CHECK REFERENCING USER CCW
CERRN15  EQU   15                  USER CCW COUNT BAD (RETRANS)@ZA26916
CERRN99  EQU   16                  UNEXPECTED ABEND            @ZA26916
         EJECT ,
***********************************************************************
**                                                                   **
**     APESMV TABLE LOOKUP.  EACH 'CERRN__' INDEXES INTO THIS        **
**     TABLE TO LOCATE THE APPRORIATE ERROR CONDITIONS.              **
**     THE TABLE FORMAT IS:                                          **
**          0-1  - MESSAGE NUMBER (REQUIRED BY IGTUKA)               **
**          2-3  - KEYWORD NUMBER (REQUIRED BY IGTUKA)               **
**          4    - DESIRED APESFLG0 (LOG/DUMP) OPTIONS               **
**          5    - APRLRCN VALUE (SPECIFIC ERROR NUMBER)             **
**          6    - APRLRCT VALUE (RETURN CODE TYPE)                  **
**          7    - RESERVED                                          **
**                                                                   **
***********************************************************************
         SPACE 2
MERRTBL  DS    0Y                  FIRST ENTRY IS NUMBER 1
*                                  * SO ALLOW FOR 0-TH ENTRY
         SPACE ,
*                                  01 - SMF FAILURE
         DC    Y(APCMI160)         SUPV SERV FAIL
         DC    Y(APCMK070)         SMF
         DC    YL1(APESFDMP+APESFREC+APESFSDP) SYSUDUMP + EREP + SDUMP
         DC    YL1(APCCI160)       ERROR = 160
         DC    YL1(APCCTLOG)       LOGICAL ERROR
         DC    YL1(*-*)            RESERVED
         SPACE ,
*                                  02 - PGFIX FAILURE
         DC    Y(APCMI161)         SUPV SERV FAIL
         DC    Y(APCMK057)         PGFIX
         DC    YL1(APESFDMP)       SYSUDUMP
         DC    YL1(APCCI161)       ERROR = 161
         DC    YL1(APCCTLOG)       LOGICAL ERROR
         DC    YL1(*-*)            RESERVED
         SPACE ,
*                                  03 - SUSPEND FAILURE
         DC    Y(APCMI162)         SUPV SERV FAIL
         DC    Y(APCMK071)         SUSPEND
         DC    YL1(APESFDMP+APESFREC+APESFSDP) SYSUDUMP + EREP + SDUMP
         DC    YL1(APCCI162)       ERROR = 162
         DC    YL1(APCCTLOG)       LOGICAL ERROR
         DC    YL1(*-*)            RESERVED
         SPACE ,
*                                  04 - INVALID APRL
         DC    Y(APCMI163)         BAD CNTRL BLOCK
         DC    Y(APCMK052)         APRL
         DC    YL1(APESFDMP)       SYSUDUMP
         DC    YL1(APCCI163)       ERROR = 163
         DC    YL1(APCCTICB)       INVALID CONTROL BLOCK
         DC    YL1(*-*)            RESERVED
         SPACE ,
*                                  05 - APIO ACTIVE
         DC    Y(APCMI164)         APIO ACTIVE
         DC    Y(APCMK000)         NO KEYWORD
         DC    YL1(APESFDMP)       SYSUDUMP
         DC    YL1(APCCI164)       ERROR = 164
         DC    YL1(APCCTICB)       INVALID CONTROL BLOCK
         DC    YL1(*-*)            RESERVED
         SPACE ,
*                                  06 - CANNOT FIND PORT TO USE
         DC    Y(APCMI165)         NO PORT AVAIL
         DC    Y(APCMK000)         NO KEYWORD
         DC    YL1(APESFDMP+APESFREC+APESFSDP) SYSUDUMP + EREP + SDUMP
         DC    YL1(APCCI165)       ERROR = 165
         DC    YL1(APCCTLOG)       LOGIC ERROR
         DC    YL1(*-*)            RESERVED
         SPACE ,
*                                  07 - 3838 RE-IPLED FOR EXCL USER
         DC    Y(APCMI166)         EXCL PORT REIPL
         DC    Y(APCMK000)         NO KEYWORD
         DC    YL1(APESFREC)       EREP
         DC    YL1(APCCI166)       ERROR = 166
         DC    YL1(APCCTPIO)       PHYSICAL ERROR
         DC    YL1(*-*)            RESERVED
         SPACE ,
*                                  08 - 'LRA' FAILED AFTER PGFIX
         DC    Y(APCMI167)         LOGIC ERROR
         DC    Y(APCMK000)         NO KEYWORD
         DC    YL1(APESFDMP+APESFREC+APESFSDP) SYSUDUMP + EREP + SDUMP
         DC    YL1(APCCI167)       ERROR = 167
         DC    YL1(APCCTLOG)       LOGIC ERROR
         DC    YL1(*-*)            RESERVED
         SPACE ,
*                                  09 - APIO OVERLAID
         DC    Y(APCMI168)         BAD CONTRL BLOCK
         DC    Y(APCMK045)         APIO
         DC    YL1(APESFDMP+APESFREC+APESFSDP) SYSUDUMP + EREP + SDUMP
         DC    YL1(APCCI168)       ERROR = 168
         DC    YL1(APCCTICB)       INVALID CONTROL BLOCK
         DC    YL1(*-*)            RESERVED
         SPACE ,
*                                  10 - PGM CHK REFERENCING APRL
         DC    Y(APCMI169)         PGM CHK REF
         DC    Y(APCMK052)         APRL
         DC    YL1(APESFDMP)       SYSUDUMP
         DC    YL1(APCCI169)       ERROR = 169
         DC    YL1(APCCTICB)       INVALID CONTROL BLOCK
         DC    YL1(*-*)            RESERVED
         SPACE ,
*                                  11 - FAILURE DOING RESUME
         DC    Y(APCMI170)         SUPV SERV FAIL
         DC    Y(APCMK072)         RESUME
         DC    YL1(APESFDMP+APESFREC+APESFSDP) SYSUDUMP + EREP + SDUMP
         DC    YL1(APCCI170)       ERROR = 170
         DC    YL1(APCCTLOG)       LOGIC ERROR
         DC    YL1(*-*)            RESERVED
         SPACE ,
*                                  12 - ABEND REFERENCING APUB
         DC    Y(APCMI171)         PGM CHK REF
         DC    Y(APCMK035)         APUB
         DC    YL1(APESFDMP+APESFREC+APESFSDP) SYSUDUMP + EREP + SDUMP
         DC    YL1(APCCI171)       ERROR = 171
         DC    YL1(APCCTICB)       INVALID CONTROL BLOCK
         DC    YL1(*-*)            RESERVED
         SPACE ,
*                                  13 - PGFREE FAILURE
         DC    Y(APCMI172)         SUPV SERV FAIL
         DC    Y(APCMK058)         RESUME
         DC    YL1(APESFDMP+APESFREC+APESFSDP) SYSUDUMP + EREP + SDUMP
         DC    YL1(APCCI172)       ERROR = 172
         DC    YL1(APCCTLOG)       LOGIC ERROR
         DC    YL1(*-*)            RESERVED
        SPACE ,                                                @ZA26916
*                                  14 - ABEND REFERENCING USER CCW
         DC    Y(APCMI173)         PGM CHK REF                 @ZA26916
         DC    Y(APCMK061)         CCW                         @ZA26916
         DC    YL1(APESFDMP)       SYSUDUMP                    @ZA26916
         DC    YL1(APCCI173)       ERROR = 173                 @ZA26916
         DC    YL1(APCCTLOG)       LOGICAL ERROR               @ZA26916
         DC    YL1(*-*)            RESERVED                    @ZA26916
        SPACE ,                                                @ZA26916
*                                  15 - BAD CCW COUNT (RETRANS)@ZA26916
         DC    Y(APCMI174)         BAD CNTRL BLOCK             @ZA26916
         DC    Y(APCMK061)         CCW                         @ZA26916
         DC    YL1(APESFDMP)       SYSUDUMP                    @ZA26916
         DC    YL1(APCCI174)       ERROR = 174                 @ZA26916
         DC    YL1(APCCTLOG)       LOGICAL ERROR               @ZA26916
         DC    YL1(*-*)            RESERVED                    @ZA26916
         SPACE ,
*                                  99 - ALL OTHER ABENDSSUME
         DC    Y(APCMI189)         UNEXPECTED ABEND
         DC    Y(APCMK000)         NO KEYWORD
         DC    YL1(APESFDMP+APESFREC+APESFSDP) SYSUDUMP + EREP + SDUMP
         DC    YL1(APCCI189)       ERROR = 189
         DC    YL1(APCCTLOG)       LOGIC ERROR
         DC    YL1(*-*)            RESERVED
         EJECT ,
***********************************************************************
**                                                                   **
**       VPSS DSECTS                                                 **
**                                                                   **
***********************************************************************
         SPACE 2
         IGTXDSCT IGTXAPRL         VPSS ACB REQUEST BLOCK
         IGTXDSCT IGTXAPUB         VPSS UNIT BLOCK
         IGTXDSCT IGTXAPXL         VPSS TRANSLATE TABLE
         IGTXDSCT IGTXAPCT         VPSS CONTROL TABLE
         IGTXDSCT IGTXAPIO         VPSS I/O BLOCK
         IGTXDSCT IGTXAPCC         VPSS RETURN CODES
         IGTXDSCT IGTXAPCM         VPSS MESSAGE CODES
         IGTXDSCT IGTXAPDX         VPSS DEB EXTENSION
         IGTXDSCT IGTXAPDS         VPSS DATA SET DECRIPTION
         IGTXDSCT IGTXAPMF         VPSS SMF RECORD
         IGTXDSCT IGTXAPVU         VPSS USAGE TABLE
         EJECT ,
         PRINT NOGEN
         IHAPSA ,                  FIXED LOW CORE
         PRINT GEN
         EJECT ,
         CVT   DSECT=YES           COMMUNICATIONS VECTOR TABLE
         EJECT ,
         PRINT NOGEN
         IHAPVT ,                  PAGING VECTOR TABLE
         PRINT GEN
         EJECT ,
         PRINT NOGEN
         IECDIOCM ,                I/O COMMUNICATIONS TABLE
         PRINT GEN
         EJECT ,
         PRINT NOGEN
         IHAASCB ,                 ADDRESS SPACE CONTROL BLOCK
         PRINT GEN
         EJECT ,
         PRINT NOGEN
         IHAASXB ,                 ADDRESS SPACE EXTENSION
         PRINT GEN
         EJECT ,
         PRINT NOGEN
         IHAFRRS ,                 FUNCTIONAL RECOVERY ROUTINE STACKS
         PRINT GEN
         EJECT ,
         IKJTCB ,                  TASK CONTROL BLOCK
         EJECT ,
         PRINT NOGEN
         IHARB ,                   REQUEST BLOCK
         PRINT GEN
         EJECT ,
         IEZDEB ,                  DATA EXTENT BLOCK
         PRINT NOGEN
         IHASDWA ,                 SYSTEM DIAGNOSTIC WORKAREA
         PRINT GEN
         EJECT ,
         PRINT NOGEN
         IHAVSL ,                  VIRTUAL STORAGE LIST (PGFIX)
         PRINT GEN
         EJECT ,
         PRINT NOGEN
         IHAECB ,                  EVENT CONTROL BLOCK
         PRINT GEN
         EJECT ,
***********************************************************************
**                                                                    *
**       MAKE IOSB PART OF APIO CONTROL BLOCK                         *
**                                                                    *
***********************************************************************
         SPACE 2
IOSB     DSECT ,                   APIO/IOSB DSECT
         IECDIOSB ,                I/O SUPERVISOR BLOCK (IN APIO)
         SPACE 2
IOSB     DSECT ,                   APIO/IOSB DSECT
         ORG   IOSB                APIO STARTS WITH THE IOSB
         IGTXAPIO DSECT=NO,LIST=YES APIO IS PART OF IOSB DSECT
         EJECT ,
         IHASRB ,                  SRB LOCATED AT APIOSRB
         EJECT ,
IGTKBA   CSECT ,                   RESUME CSECT CODE
         IGTXEPLG ,                DSECTS/REGISTERS
RTEMPA   EQU   R15                 WORK REGISTER
RTEMPB   EQU   R11                 WORK REGISTER
RTEMPC   EQU   R12                 WORK REGISTER
RDEBPTR  EQU   R2                  DEB ADDRESS (SET ON INPUT)
RAPIONUM EQU   R2                  APRL SPECIFIED APIO INDEX
RIONBR   EQU   R2                  HOLDS APIONBR ACROSS 'CALLDISP'
*                                  * AND I/O EXECUTION
RCVTPTR  EQU   R3                  CVT (SET ON INPUT)
RTCBPTR  EQU   R4                  CURRENT TCB ADDRESS (SET ON INPUT)
RAPRLPTR EQU   R4                  VPSS APRL ADDRESS
RFRRSAVE EQU   R4                  FRR POINT TO INPUT REGISTER SAVEAREA
RAPUBPTR EQU   R5                  APUB FOR THIS I/O REQUEST
RAPDXPTR EQU   R5                  VPSS DEB EXTENSION
RSDWAPTR EQU   R5                  FRR POINT TO SDWA
RPGFXFLG EQU   R5                  HOLDS PGFIX INDICATOR
RCODE    EQU   R6                  BASE REGISTER FOR CODE
RASCBPTR EQU   R7                  CURRENT ASCB ADDRESS (SET ON INPUT)
RVUWORK  EQU   R7                  FRR WORKAREA POINTER (IN APVU)
RFRRSTK  EQU   R8                  RECOVERY WORKAREA (DFRRSTK) BASE
RAPIOPTR EQU   R9                  VPSS APIO/IOSB/SRB BASE
RXAPDX   EQU   R11                 VPSS DEB EXTENSION (SET ON INPUT)
RXAPUB   EQU   R11                 SHARED APUB SELECT SCANNER
RVSLPTR  EQU   R11                 PSI (PGFIX) LIST SCAN REGISTER
RVSLINCR EQU   R12                 VSL ENTRY SIZE
RVSLEND  EQU   R13                 LAST VSL ENTRY ADDRESS
*                                  * NOTE: RVSLINCR/RVSLEND MUST BE
*                                  * EVEN/ODD REGISTER PAIR (BXLE)
RAPMFPTR EQU   R15                 VPSS SMF RECORD (APMF)
         EJECT ,
***********************************************************************
**                                                                    *
**       FAKE APUB. USED BY SHARED-APUB SCAN ROUTINE.  THIS           *
**       APUB SKELETON IS USED AS INITIAL COMPARISION.  IT            *
**       IS CONSTRUCTED TO INSURE THAT ANY SELECTABLE APUB            *
**       IS BETTER THAN THIS APUB.  ALSO, IF NO APUB IS               *
**       AVAILABLE, THIS APUB WILL FAIL THE FINAL SHARED TEST         *
**                                                                    *
***********************************************************************
         SPACE 2
CAPUB    DS    0D                  INSURE ALIGNMENT
         DC    01XL(APUBLN)'00'    UN-USED FIELDS ZERO
         ORG   CAPUB+(APUBID-APUB) NEXT FIELD
         DC    01CL4'APUB'         IN-CORE ID
         ORG   CAPUB+(APUBMSTR-APUB) NEXT FIELD
         DC    01A(CAPUB)          SUBCHANNEL-0 APUB (RE-USE THIS APUB)
         ORG   CAPUB+(APUBIOCT-APUB) NEXT FIELD
         DC    01A(X'7FFFFFFE')    MORE OUTSTANDING I/O THAN REAL APUB
         ORG   CAPUB+(APUBMSTP-APUB) NEXT FIELD
         DC    01A(CAPUB)          SUBCHANNEL-0 APUB (RE-USE THIS APUB)
         ORG   CAPUB+(APUBIOFG-APUB) NEXT FIELD
         DC    01A(X'FFFFFFFF')    INSURE I/O NOT ALLOWED
         ORG   ,                   END OF APUB
         EJECT ,
***********************************************************************
**                                                                   **
**     USED TO INITIALIZE APES HEADER (REMAINDER IS SET TO 0).       **
**                                                                   **
***********************************************************************
         SPACE 2
CAPES    DC    XL(APESSDWA-APES)'00' INITIALIZE FIELDS TO ZERO @ZA25360
         ORG   APESID-APES+CAPES   GO TO FIELD TO COMPLETE
         DC    A(APESIDC)          ID FIELD (='APES')
         ORG   APESAPMV-APES+CAPES GO TO FIELD TO COMPLETE
         DC    A(MERRTBL)          ERROR INDICATOR TABLE
         ORG   APESMXCD-APES+CAPES GO TO FIELD TO COMPLETE
         DC    AL1(CERRN99)        MAXIMUM ERROR INDEX
         ORG   APESMOD-APES+CAPES  GO TO FIELD TO COMPLETE
         DC    CL8'IGTKBA'         MODULE IN CONTROL
         ORG   APESPROC-APES+CAPES GO TO FIELD TO COMPLETE
         DC    CL8'IGTKBA'         MODULE IN CONTROL
         ORG   APESFRR-APES+CAPES  GO TO FIELD TO COMPLETE
         DC    CL8'XSTAE2'         FRR IN CONTROL
         ORG   ,                   RESET LOCATION COUNTER
         SPACE 5
         END   ,                   MODULE END
