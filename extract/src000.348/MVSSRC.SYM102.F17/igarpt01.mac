         TITLE 'RADIX PARTITION TREE SERVICES. SEPTEMBER 1, 1973'
***********************************************************************
*                                                                     *
*      R A D I X   P A R T I T I O N   T R E E   S E R V I C E S      *
*                                                                     *
***********************************************************************
*                                                                     *
* THE COMPONENT RADIX PARTITION TREE SERVICES (RPTS) PROVIDES A SET   *
* OF MACRO-INSTRUCTIONS AND SUBROUTINES FOR SEARCHING, SORTING,       *
* SCANNING, AND DYNAMICALLY MAINTAINING INDEXED COLLECTIONS OF ITEMS. *
* EACH ITEM IN AN INDEXED COLLECTION IS TREATED AS HAVING A KEY, OR   *
* IDENTIFIER, AND ASSOCIATED DATA (OR AN ASSOCIATED ADDRESS).         *
* THE KEYS MAY OR MAY NOT BE UNIQUE AND/OR PART OF THE DATA.          *
* THE DATA MAY BE A CONTROL BLOCK, A QUEUE ELEMENT, ANOTHLR KEY, OR AN*
* ARBITRARY RECORD. FOR SIMPLICITY ALL OF THESE ARE CALLED RECORDS.   *
* A RADIX PARTITION TREE IS A PARTICULAR REPRESENTATION FOR MAINTAIN- *
* ING AN INDEXED COLLECTION, WHERE EACH KEY VALUE IS ASSOCIATED WITH  *
* THE ADDRESS OF A RECORD.                                            *
*                                                                     *
* THE BASIC OPERATIONS PROVIDED ARE SEARCHING, INSERTING, DELETEING,  *
* AND SCANNING. THE SEARCH OPERATION, WHEN GIVEN A KEY VALUE, SEARCHES*
* THE RADIX PARTITION TREE TO FIND THE ADDRESS OF THE RECORD ASSOCIATED
* WITH THE KEY.  THE INSERT  OPERATION  ADDS A KEY  VALUE  AND ITS    *
* ASSOCIATED RECORD ADDRESS TO THE RPT, SO THAT SUBSEQUENT SEARCHES   *
* WITH THE NEW KEY WILL FIND ITS ASSOCIATED RECORD ADDRESS.           *
* THE DELETE OPERATION REMOVES AN ASSOCIATION BETWEEN A KEY AND ITS   *
* ASSOCIATED RECORD ADDRESS FROM THE RPT.                             *
* THE SCANNING OPERATIONS RETRIEVE THE RECORD ADDRESSES IN ASCENDING  *
* OR DESCENDING ORDER OF THEIR ASSOCIATED KEYS.                       *
*                                                                     *
* AUXILIARY OPERATIONS ARE PROVIDED FOR INITIALLY DEFINING AN RPT,    *
* ALLOCATING AND RELEASING SSPACE FOR RECORDS, RELEASING THE SPACE FOR*
* RECORDS, RELEASING THE SPACE FOR AN ENTIRE RPT, AND INITIALIZING FOR*
* SCANNING IN ASCENDING OR DESCENDING ORDER.                          *
*                                                                     *
* THE MACRO-INSTRUCTIONS THAT PROVIDE THESE FUNCTIONS ARE:            *
*                                                                     *
* MACRO   FUNCTION                                                    *
* -----   --------                                                    *
* DEL     DELETE AN ASSOCIATION BETWEEN A KEY VALUE AND A RECORD      *
*         ADDRESS FROM THE RADIX PARTITION TREE.                      *
* FSPACE  FREE A RECORD SPACE BY RELEASING IT TO THE SYSTEM.          *
* FTREE    RELEASE ALL THE SPACE IN AN RPT TO THE SYSTEM.             *
* GSPACE  GET A RECORD SPACE IN MAIN STORAGE.                         *
* INS     INSERT AN ASSOCIATION BETWEEN A KEY VALUE AND A RECORD      *
*         ADDRESS TO THE RPT.                                         *
* ISCAN   INITIALIZE FOR SCANNING IN EITHER ASCENDING OR DESCENDING   *
*         ORDER.                                                      *
* SCANL   SCAN IN DESCENDING ORDER.                                   *
* SCANR   SCAN IN ASCENDING ORDER.                                    *
* SRCH    SEARCH FOR THE RECORD ADDRESS ASSOCIATED WITH A GIVEN KEY   *
*         VALUE.                                                      *
* STREE   SET UP THE RPT BY GETTING SPACE FOR IT AND FILLING IN       *
*         VARIOUS INTERNAL FIELDS. THE NEW RPT IS EMPTY, I. E. DOES   *
*         NOT HAVE ANY ASSOCIATION PAIRS REPRESENTED IN IT.           *
* TSORT   INTERNAL SORT OPERATION.                                    *
         EJECT
* TO UNDERSTAND THE OPERATION OF THE VARIOUS ROUTINES, A DICTIONARY OF*
* TERMS IS PROVIDED. THE TERMS ARE DEFINED IN RELATION TO THE FIGURE  *
* ON THIS PAGE.                                                       *
*                                                                     *
*                             F I G U R E  0.                         *
*                                                                     *
*                                                                     *
*                                  ***                                *
*                               A * 5 *                               *
*                                  ***                                *
*                                 *   *                               *
*                                *     *                              *
*                               *       *                             *
*                              *         *                            *
*                             *           *                           *
*                            *             *                          *
*                           *               *                         *
*                          *                 *                        *
*                         *                   *                       *
*                        *                     *                      *
*                       *                       *                     *
*                      *                         *                    *
*                     *                           *                   *
*                    ***                         ***                  *
*                 B * 3 *                     C * 2 *                 *
*                    ***                         ***                  *
*                   *   *                       *   *                 *
*                  *     *                     *     *                *
*                 *       *                   *       *               *
*                *         *                 *         *              *
*               *           *               *           *             *
*              *             *             *             *            *
*             *               *           *               *           *
*            ***             ***         ***             ***          *
*         D * 7 *         E * 4 *     F * 1 *         G * 8 *         *
*            ***             ***         ***             ***          *
*                           *   *                                     *
*                          *     *                                    *
*                         *       *                                   *
*                        *         *                                  *
*                       *           *                                 *
*                      *             *                                *
*                     *               *                               *
*                    ***             ***                              *
*                 H * 9 *         I * 6 *                             *
*                    ***             ***                              *
*                                                                     *
*                                                                     *
*.....................................................................*
* ASCENDING PATH PROPERTY: A PROPERTY OF VALUES ASSOCIATED WITH THE   *
*        VERTICES IN A DIRECTED GRAPH IN WHICH ANY SEQUENCE OF VALUES *
*        ALONG A DIRECTED PATH IS IN NON-DECREASING ORDER.            *
*.....................................................................*
* BINARY COLLATING SEQUENCE: A COLLATING SEQUENCE DEFINED IN WHICH IF *
*        BYTES REPRESENTING THE CHARACTERS IN THE CHARACTER SET ARE   *
*        ARRANGED IN ASCENDING ORDER BY THEIR BINARY VALUES, THEN THE *
*        CHARACTERS REPRESENTED BY THE BYTES ARE IN LEXICOGRAPHICAL   *
*        ORDER.  IN ORDER FOR A RADIX PARTITION TREE TO PRESERVE THE  *
*        ORDER OF THE VALUES IN THE SET PARTITIONED, EACH VAULE MUST  *
*        BE A BINARY NUMBER (I. E. A STRING OF BYTES), AND THE COLLAT-*
*        ING SEQUENCE OF THE CORRESPONDING CHARACTER SET MUST BE A    *
*        BINARY COLLATING SEQUENCE.                                   *
*.....................................................................*
* DEGREE: THE THE TOTAL NUMBER OF EDGES AT A VERTEX, REGARDLESS OF    *
*        THEIR DIRECTION.  INDEGREE IS THE NUMBER OF INCOMING EDGES AT*
*        A VERTEX, AND OUTDEGREE IS THE NUMBER OF OUTGOING EDGES AT A *
*        VERTEX.                                                      *
*.....................................................................*
* EDGE: A CONNECTION BETWEEN A PAIR OF VERTICES IN A GRAPH, USUALLY   *
*        REPRESENTED BY A LINE WHEN DRAWN ON PAPER. IN A FORMAL SENSE,*
*        AN EDGE IS PAIR OF VERTICES. A DIRECTED EDGE IS AN EDGE THAT *
*        DEFINES A CONNECTION IN ONLY ONE DIRECTION. AN UNDIRECTED    *
*        EDGE IMPLIES A CONNECTION IN BOTH DIRECTIONS.                *
*        THUS A DIRECTED EDGE IS AN ORDERED PAIR OF VERTICES, AND AN  *
*        UNDIRECTED EDGE IS AN UNORDERED PAIR OF VERTICES.            *
*.....................................................................*
*        IN THE RPT PROGRAMS, THE VERTICES OF THE GRAPHS ARE MAIN     *
*        STORAGE ADDRESSES, AND THE EDGES ARE PAIRS OF ADDRESSES.     *
*        EDGES ARE REPRESENTED BY EDGE FIELDS, WHICH REPRESENT THE    *
*        TWO ADDRESSES IN THE PAIR OF ADDRESSES IN SOME FASHION.      *
*        AN INVERTIBLE EDGE IS ONE THAT IS REPRESENTED BY A SINGLE    *
*        FIELD, AND WHERE THE SINGLE FIELD ALLOWS EITHER OF THE TWO   *
*        ADDRESSES TO BE COMPUTED FROM THE OTHER ADDRESS, THE EDGE    *
*        FIELD, AND ONE OTHER ADDRESS.                                *
*        FOR EXAMPLE, SUPPOSE THE GRAPH CONTAINS THE TWO EDGES (A,B)  *
*        AND (B,C). THEN IF THE FIELD STORED AT LOCATION B IS FORMED  *
*        BY SUBTRACTING THE ADDRESS A FROM THE ADDRESS C, THEN WHEN   *
*        THE TWO ADDRESSES A AND B ARE KNOWN, THE ADDRESS CAN BE      *
*        COMPUTED BY ADDING THE FIELD AT B TO THE ADDRESS A.          *
*        ARITHMETICALLY, E(B)=C-A, WHICH MEANS THAT C=A+E(B), AND     *
*        A=C-E(B), WHERE E(B)=C-A.  THUS, GIVEN TWO CONSECUTIVE       *
*        ADDRESSES ALONG A PATH, THE NEXT VERTEX ALONG THE PATH CAN   *
*        BE COMPUTED.                                                 *
*.....................................................................*
         EJECT
         MACRO
&TAG     DEL   &TREE,&LV=,&T=,&TYPE=,&S=,&SP=,                         X
               &FREE=,&RECL=
.**********************************************************************
.* THE DEL MACRO-INSTRUCTION IS USED TO DELETE A KEY-ADDRESS          *
.* ASSOCIATION PAIR FROM THE RADIX PARTITION TREE. THE MEANINGS OF THE*
.* PARAMETERS ARE AS FOLLOWS:                                         *
.**********************************************************************
.* TREE: THE TREE PARAMETER SPECIFIES THE ADDRESS OF THE RADIX        *
.*       PARTITION TREE, AS IT IS OBTAINED FROM USING THE STREE       *
.*       MACRO-INSTRUCTION. THE ADDRESS MAY EITHER BE IN MAIN STORAGE *
.*       OR IN A REGISTER. IF "LABEL" IS CODED FOR THE TREE PARAMETER,*
.*       THE ADDRESS IS IN A WORD IN MAIN STORAGE. IF "(TREE)" IS     *
.*       CODED, THE ADDRESS IS IN THE CORRESPONDING REGISTER.         *
.* LV:   LV MEANS "LENGTH VALUE", AND IS USED TO SPECIFY THE LENGTH OF*
.*       THE RECORD IF THE RECORD AREA IS TO BE RELEASED TO THE SYSTEM*
.*       VIA THE FSPACE MACRO-INSTRUCTION. IF THE LV PARAMETER IS NOT *
.*       CODED, THEN NO FSPACE OPERATION TAKES PLACE, BUT ONLY THE    *
.*       SPACE FOR THE RADIX PARTITION TREE ENTRY IS RELEASED.        *
.*       THE LV PARAMETER IS CODED EXACTLY THE SAME WAY AS IN THE     *
.*       FSPACE MACRO-INSTRUCTION. IF THE RECORD IS A VARIABLE LENGTH *
.*       RECORD WITH EITHER A ONE-BYTE OR HALFWORD COUNT AT THE FRONT *
.*       OF THE RECORD, THE LENGTH VALUE MAY BE CODED AS:             *
.*       LV=((15),1) FOR A ONE BYTE LENGTH;                           *
.*       LV=((15),2) FOR A HALFWORD LENGTH FIELD.                     *
.*       IF THE RECORD IS A FIXED LENGTH RECORD, THEN "LV=LENGTH"     *
.*       SHOULD BE CODED, WHERE "LENGTH" IS THE RECORD LENGTH.        *
.*                                                                    *
.* S,SP: THESE PARAMETERS ARE CODED EXACTLY THE SAME WAY AS IN THE    *
.*       FSPACE MACRO-INSTRUCTION; SEE THE DESCRIPTION OF FSPACE FOR  *
.*       DETAILS.                                                     *
.* FREE: THIS PARAMETER IS PRESENT ONLY FOR COMPATIBILITY WITH EARLIER*
.*       VERSIONS, AND SHOULD NOT BE USED.                            *
.* RECL: THIS PARAMETER IS PRESENT ONLY FOR COMPATIBILITY WITH EARLIER*
.*       VERSIONS, AND SHOULD NOT BE USED.                            *
.*       THE RETURN CODE IN REGISTER 15 IS THE ADDRESS THAT WAS       *
.*       ASSOCIATED WITH THE KEY BEFORE THE DELETE IF THE LENGTH VALUE*
.*       IS NOT CODED. THE CONDITION CODE SETTING DOES NOT ALWAYS     *
.*       AGREE WITH THE RETURN CODE IN THIS EVENT, SINCE THE CONDITION*
.*       CODE IS SET TO 01 (MINUS) WHEN THE DEL MACRO-INSTRUCTION     *
.*       DELETES THE LAST KEY-ADDRESS PAIR IN THE RPT. WHEN THE LV    *
.*       PARAMETER IS NOT CODED A BM INSTRUCTION WILL BRANCH WHEN THE *
.*       ADDRESS RETURNED IN REGISTER 15 IS THE LAST ADDRESS THAT WAS *
.*       IN THE RPT. A BNM INSTRUCTION WILL BRANCH WHEN THE ADDRESS   *
.*       RETURNED IN REGISTER 15 WAS NOT THE LAST ADDRESS IN THE RPT. *
.*       WHEN THE LENGTH VALUE IS CODED, THE CONDITION CODE SETTING IS*
.*       THE SAME AS ABOVE, BUT THE RETURN CODE IN REGISTER 15 IS SET *
.*       TO ZERO, SINCE THE FSPACE MACRO-INSTRUCTION SETS IT TO ZERO. *
.*       THE CONDITION CODE IS PRESERVED THROUGH THE FSPACE           *
.*       MACRO-INSTRUCTION, SO THAT IT IS THE SAME AS IT IS WHEN      *
.*       RETURNING FROM THE DEL SUBROUTINE IN THE MODULE IGARPT01.    *
.* AFTER THE DEL OPERATION, THE CURSOR IS SET BETWEEN THE TWO KEYS ON *
.* EITHER SIDE OF THE DELETED KEY, SO THAT IS A SCANL OR SCANR        *
.* MACRO-INSTRUCTION IS SUBSEQUENTLY EXECUTED THE CURSOR IS POSITIONED*
.* TO THE KEY LOWER OR HIGHER THAN THE DELETED KEY.                   *
.* THUS IT IS POSSIBLE TO PROCESS ALL THE ADDRESS IN THE RPT IN       *
.* ASCENDING ORDER, AND DELETE EACH PAIR AFTER IT HAS BEEN PROCESSED, *
.* BY USING ISCAN TO INITIALIZE THE CURSOR, AND THEN FOLLOWING EACH   *
.* SCANR BY A DEL, WHICH DELETES EACH ENTRY AFTER IT HAS BEEN         *
.* PROCESSED.                                                         *
.* A SAMPLE PROGRAM TO DO THIS IS AS FOLLOWS:                         *
.*       ISCAN TREE  SET THE CURSOR TO THE INITIAL STATE.             *
.* MORE: SCANR TREE,DONE=END  SET THE CURSOR TO THE NEXT.             *
.*       PROCESS THE RECORD AT THE ADDRESS IN REGISTER 15.            *
.*       DEL TREE,LV=80  DELETE THE CURSOR-SELECTED KEY-ADDRESS PAIR  *
.*                        FROM THE RADIX PARTITION TREE, AND RELEASE  *
.*                        THE 80-BYTE RECORD AREA TO THE SYSTEM VIA   *
.*                        THE FSPACE MACRO-INSTRUCTION.               *
.*       BNM MORE  BRANCH BACK TO SCAN MORE IF THERE IS STILL AT LEAST*
.*                        ONE ENTRY.                                  *
.**********************************************************************
         GBLC  &IGABLST  THE OFFSET INTO THE TREE HEADER FOR THE LIST  *
                         OF RPT ENTRY POINTS.
         GBLC  &IGADEL   INDEX OF THE ADDRESS OF THE DELETE ROUTINE    *
                         ADDRESS IN THE LIST OF ENTRY POINTS IN THE    *
                         TREE HEADER.
         GBLC  &IGADDR   THE ADDRESS OF THE MODULE IGARPTXX.
         GBLC  &IGARPT#  THE TYPE OF THE RADIX PARTITION TREE FROM ONE *
               OF THE PARAMETERS T OR TYPE.
         LCLC  &R,&Q
.*A000000                                                        Y02147
.**********************************************************************
         AIF   (K'&RECL EQ 0).NEW  SEE IF THE OLD PARAMETER RECL IS    *
                         CODED INSTEAD OF LV.
&TAG     DEL   &TREE,T=&T,TYPE=&TYPE,LV=&RECL,S=&S,SP=&SP
         AGO   .FIN
.NEW     ANOP
      RPTDSECT T=5,DS=NO
      RPTDSECT T=8,DS=NO
.**********************************************************************
&R       SETC  'R'
         AIF   (K'&TREE EQ K'&TREE(1)+2 AND N'&TREE EQ 1).LW2
&R       SETC  ' '
.LW2     AIF   ('&TREE' NE '(1)').LW3  SEE IF THE TREE ADDRESS IS      *
                         ALREADY IN R1.
         AIF   (K'&TAG EQ 0).LW4  SEE IF THERE IS NO TAG.
&TAG     EQU   *
         AGO   .LW4      SKIP THE LR INSTRUCTION.
.LW3     ANOP
&TAG     L&R   1,&TREE(1)
.LW4     ANOP
         L     15,(&IGABLST+&IGADEL)(,1)  ADDRESS OF THE DELETE ROUTINE
         BALR  14,15           LINK TO THE DELETE ROUTINE.
         AIF   (K'&LV EQ 0).FIN  SEE IF A LENGTH VALUE IS GIVEN.
         AIF   ('&LV' EQ '0').FIN  SEE IF THE LENGTH IS ZERO.
        FSPACE R,A=(15),S=&S,SP=&SP,LV=&LV  FREE THE RECORD AREA.
         SPM   14        RESTORE CONDITION CODE.
FIN&SYSNDX EQU *
.FIN     ANOP
         MEND
         EJECT
         MACRO
&TAG    FSPACE &R,&LV=,&A=,&S=,&SP=
.* THIS MACRO RELEASES THE SPACE AT THE ADDRESS SPECIFIED BY THE      *
.* PARAMETER A TO THE SYSTEM, USING THE LOCAL STORAGE MANAGEMENT      *
.* ROUTINES IN THE MODULE IGARPT01.                                   *
.*                                                                    *
.*             LOCAL STORAGE ALLOCATION                               *
.*             ----- ------- ----------                               *
.*                                                                    *
.* THE GSPACE AND FSPACE MACRO-INSTRUCTIONS ARE THE INTERFACE TO THE  *
.* LOCAL STORAGE ALLOCATION FUNCTIONS IN THE RPTS COMPONENT OF THE    *
.* OPERATING SYSTEM.                                                  *
.*                                                                    *
.* THE GSPACE AND FSPACE MACRO-INSTRUCTIONS PROVIDE FUNCTIONS THAT ARE*
.* EQUIVALENT TO THE R-FORM OF THE GETMAIN AND FREEMAIN               *
.* MACRO-INSTRUCTIONS, BUT ARE SIGNIFICANTLY FASTER THAN GETMAIN AND  *
.* FREEMAIN. THE GSPACE MACRO-INSTRUCTION ALLOCATES SPACE, AND THE    *
.* FSPACE MACRO-INSTRUCTION RELEASES SPACE TO THE SYSTEM.             *
.*                                                                    *
.* AS THE NAME "LOCAL STORAGE ALLOCATION" IMPLIES, THE GSPACE AND     *
.* FSPACE MACRO-INSTRUCTIONS ALLOCATE AND RELEASE VIRTUAL STORAGE ON A*
.* LOCAL BASIS. THE GSPACE AND FSPACE MACRO-INSTRUCTIONS ALLOCATE AND *
.* RELEASE STORAGE IN A LOCAL COLLECTION OF STORAGE AREAS DEFINED BY A*
.* SPACE CONTROL AREA (SPCA). EACH SPCA IS IDENTIFIED BY ITS VIRTUAL  *
.* STORAGE ADDRESS, WHICH IS KEPT IN A WORD CALLED THE ADDRESS OF THE *
.* SPACE CONTROL AREA, OR THE SPACE CONTROL WORD (SPCW). THE SPCA     *
.* CONTAINS ENOUGH INFORMATION TO IDENTIFY THE AVAILABLE STORAGE AREAS*
.* IN THE COLLECTION OF AREAS DEFINED BY THE SPCA.                    *
.*                                                                    *
.* EVERY TIME THE GSPACE AND FSPACE MACRO-INSTRUCTIONS ARE EXECUTED,  *
.* THEY USE THE ADDRESS OF THE SPCA TO DETERMINE THE COLLECTION OF    *
.* STORAGE AREAS THAT PARTICIPATE IN THE ALLOCATION OR RELEASE OF AN  *
.* AREA OF STORAGE. THE S PARAMETER IN THE GSPACE AND FSPACE          *
.* MACRO-INSTRUCTIONS SPECIFIES THE ADDRESS OF THE SPCA TO BE USED.   *
.*                                                                    *
.* SINCE EVERY ALLOCATION OR RELEASE OF STORAGE USES AN SPCA, AN SPCA *
.* MUST BE ESTABLISHED BEFORE ANY ALLOCATION CAN BE DONE. THERE ARE   *
.* TWO WAYS OF ESTABLISHING AND USING AN SPCA; THE EXPLICIT MODE AND  *
.* THE IMPLICIT MODE.                                                 *
.*                                                                    *
.* IN THE EXPLICIT MODE, THE SPCA IS ESTABLISHED BY USING THE GSPACE  *
.* MACRO-INSTRUCTION WITH THE POSITIONAL PARAMETER CODED AS "S" OR    *
.* "SC", WHICH CREATES AN SPCA AND STORES THE ADDRESS OF THE SPCA IN  *
.* THE PLACE SPECIFIED BY THE S PARAMETER. THE THE S PARAMETER MUST BE*
.* CODED ON ALL SUBSEQUENT GSPACE AND FSPACE USES OF THE LOCAL        *
.* COLLECTION OF STORAGE DEFINED BY THE SPCA.                         *
.* THE FOLLOWING EXAMPLE ILLUSTRATES HOW A SPACE CONTROL AREA CAN BE  *
.* ESTABLISHED, USED, AND RELEASED USING THE EXPLICIT MODE:           *
.*                                                                    *
.*       GSPACE S,S=(9)  ESTABLISH AN SPCA AND SAVE ITS ADDRESS IN    *
.*                       REGISTER 9.                                  *
.*       GSPACE R,LV=200,S=(9)  ALLOCATE 200 BYTES USING THE SPCA.    *
.*       LR     3,1      SAVE THE ADDRESS OF THE AREA ALLOCATED.      *
.*       GSPACE R,LV=256,S=(9)  ALLOCATE 256 BYTES USING THE SPCA.    *
.*       LR     4,1      SAVE THE ADDRESS OF THE 256-BYTE AREA        *
.*                       ALLOCATED.                                   *
.*       FSPACE R,S=(9),LV=200,A=(3) RELEASE THE 200-BYTE AREA TO THE *
.*              SYSTEM.                                               *
.*       FSPACE S,S=(9)         RELEASE THE SPACE CONTROL AREA TO THE *
.*                       SYSTEM, AS WELL AS ALL STORAGE ASSOCIATED    *
.*                       WITH IT (IN THIS CASE THE 256-BYTE AREA IS   *
.*                       RELEASED ALONG WITH THE SPCA). NO FUTURE     *
.*                       EXECUTIONS OF GSPACE OR FSPACE ARE VALID     *
.*                       AFTER THE SPCA HAS BEEN RELEASED VIA THE     *
.*                       FSPACE MACRO-INSTRUCTION.                    *
.*                                                                    *
.* IN THE EXPLICT MODE THE SUBPOOL FOR THE STORAGE CAN BE SPECIFIED   *
.* WHEN THE SPCA IS ESTABLISHED BY CODING THE SP PARAMETER IN THE     *
.* GSPACE MACRO-INSTRUCTION. THUS IF "GSPACE S,S=(9),SP=23" HAD BEEN  *
.* CODED IN THE FIRST GSPACE IN THE EXAMPLE, SUBPOOL 23 WOULD BE USED *
.* FOR ALLOCATING THE SPCA, AND THE 200 AND 256-BYTE AREAS WOULD ALSO *
.* BE ALLOCATED USING SUBPOOL 23.                                     *
.* THE TWO GSPACE ALLOCATIONS FOR THE 200 BYTES AND THE 256 BYTES NEED*
.* NOT HAVE THE SP PARAMETER CODED, SINCE THE SPCA USED ALREADY       *
.* CONTAINS THE SUBPOOL TO BE USED. IF THE SP PARAMETER IS CODED IN   *
.* THE EXPLICIT MODE, IT IS IGNORED, AND THE SUBPOOL IN THE SPCA IS   *
.* USED.                                                              *
.*                                                                    *
.* IN THE IMPLICIT MODE, THERE IS ONE SPCA FOR EACH COLLECTION OF     *
.* STORAGE DEFINED, AND EACH COLLECTION OF STORAGE CORRESPONDS TO A   *
.* SUBPOOL BEING USED FOR ALLOCATION AND RELEASE OF SPACE. THE        *
.* COLLECTION OF SPCA'S IS LOCATED BY MEANS OF A WORD IN THE CURRENT  *
.* TASK CONTROL BLOCK (TCBRPT). THE SPCA FOR THE SUBPOOL SPECIFIED BY *
.* THE REQUEST IS FOUND BY EXAMINING THE TCB-ADDRESSED COLLECTION. IF *
.* THERE IS NO SPCA FOR THE REQUEST SUBPOOL, THEN ONE IS ESTABLISHED  *
.* AUTOMATICALLY AND ADDED TO THE TCB-ADDRESSED COLLECTION.           *
.* WHEN USING THE GSPACE AND FSPACE MACRO-INSTRUCTIONS IN THE IMPLICIT*
.* MODE THE S PARAMETER IS NEVER CODED. THE SP PARAMETER IS USED TO   *
.* LOCATE THE APPROPRIATE SPCA.                                       *
.*                                                                    *
.* THE EXAMPLE ABOVE, WITH THE S PARAMETER NOT CODED ON ANY           *
.* MACRO-INSTRUCTION, WOULD ESTABLISH AN SPCA FOR SUBPOOL ZERO,       *
.* ALLOCATE THE TWO AREAS USING IT, RELEASE THE 200-BYTE AREA, AND    *
.* THEN RELEASE THE SPCA FOR SUBPOOL ZERO ALONG WITH THE 256-BYTE     *
.* AREA.                                                              *
.*                                                                    *
.* IN THE IMPLICIT MODE, AN SPCA FOR SUBPOOL ZERO MUST ALWAYS EXIST   *
.* FOR CORRECT OPERATION OF THE LOCAL STORAGE ALLOCATION ROUTINES. THE*
.* SPCA FOR SUBPOOL ZERO IS ESTABLISHED BEFORE ANY SPCA FOR ANY OTHER *
.* SUBPOOL. THE FOLLOWING EXAMPLE ILLUSTRATES HOW TO USE THE LOCAL    *
.* STORAGE ALLOCATION FACILITY FOR SUBPOOL 127, AND THEN RELEASE THE  *
.* SPCA FOR SUBPOOL 127 FROM THE TCB-ADDRESSED COLLECTION:            *
.*                                                                    *
.*       GSPACE S,SP=127,LV=200  ALLOCATE 200 BYTES USING THE SPCA FOR*
.*                       SUBPOOL 127 (WHICH IS CREATED WITH THIS      *
.*                       REQUEST).                                    *
.*       LR     3,1     SAVE THE ADDRESS OF THE AREA ALLOCATED.       *
.*       GSPACE R,LV=256,SP=127  ALLOCATE 256 BYTES USING SUBPOOL 127.*
.*       FSPACE R,LV=200,SP=127,A=(3)  RELEASE THE 200-BYTE AREA.     *
.*       FSPACE S,SP=127  RELEASE THE SPCA FOR SUBPOOL 127, AND       *
.*                       RELEASE ALL STORAGE ALLOCATED USING IT.      *
.*                                                                    *
.* AT THIS POINT THERE IS STILL AN SPCA FOR SUBPOOL ZERO. IF NO       *
.* SUBSEQUENT ALLOCATION OR RELEASE IS DONE, AND THE TASK TERMINATES, *
.* THE STORAGE IS AUTOMATICALLY RELEASED AT TASK TERMINATION TIME.    *
.* THE SPCA FOR SUBPOOL ZERO CANNOT BE RELEASED EXCEPT AT TASK        *
.* TERMINATION TIME.                                                  *
.*                                                                    *
.* SINCE THE SPCA FOR THE SPECIFIED SUBPOOL MAY NOT BE IN THE         *
.* COLLECTION DEFINED BY THE TCB, THE FOLLOWING RETURN CODES ARE      *
.* PROVIDED:                                                          *
.*                                                                    *
.*                                                                    *
.*       CODE: MEANING:                                               *
.*       ----- --------                                               *
.*       ZERO: THE SPCA WAS SUCCESSFULLY RELEASED.                    *
.*       ZERO: THE SPCA WAS SUCCESSFULLY RELEASED.                    *
.*         -1: EITHER THE SPCA FOR THE SPECIFIED SUBPOOL COULD NOT BE *
.*             FOUND OR SUBPOOL ZERO IS SPECIFIED, AND THE SPCA FOR   *
.*             SUBPOOL ZERO CAN NOT BE RELEASED EXCEPT AT TASK        *
.*             TERMINATION TIME.                                      *
.*                                                                    *
.* ALL STORAGE ALLOCATED VIA THE GSPACE MACRO-INSTRUCTION IS ALLOCATED*
.* IN INCREMENTS OF 16 BYTES IN SIZE. THE LENGTH VALUE FOR THE REQUEST*
.* IS ROUNDED TO THE NEXT EXACT MULTIPLE OF 16 BYTES BEFORE THE       *
.* REQUEST IS PROCESSED.                                              *
.**********************************************************************
.*                                                                    *
.* THE VARIOUS PARAMETER MEANINGS ARE AS FOLLOWS:                     *
.*--------------------------------------------------------------------*
.* R     CODING "R" FOR THE R PARAMETER IMPLIES THE SAME FUNCTION AS  *
.*       THE R-FORM OF THE FREEMAIN MACRO-INSTRUCTION.                *
.*       IF "S" IS CODED FOR THE R-PARAMETER, THEN THE SPECIFIED SPACE*
.*       CONTROL AREA IS RELEASED VIA THE FREEMAIN MACRO-INSTRUCTION, *
.*       AND ALL THE SPACE ALLOCATED USING IT IS ALSO RELEASED.       *
.*       THE SPACE CONTROL AREA MAY BE SPECIFIED DIRECTLY BY CODING   *
.*       THE S PARAMETER, OR IMPLICITLY BY CODING THE SP PARAMETER.   *
.*                                                                    *
.*       NOTE THAT CODING THE SUBPOOL PARAMETER WILL ONLY RELEASE THE *
.*       SPACE FOR THE INDICATED SUBPOOL THAT HAS BEEN ALLOCATED VIA  *
.*       THE GSPACE MACRO-INSTRUCTION, AND DOES NOT ISSUE A FREEPOOL  *
.*       NOR DOES IT FREE THE SUBPOOL USING FREEMAIN. THEREFORE, IF   *
.*       ANY SPACE HAS BEEN ALLOCATED VIA THE GETMAIN MACRO-INSTRUCTION
.*       FOR THE SAME SUBPOOL, IT IS NOT RELEASED BY USING THE FSPACE *
.*       MACRO-INSTRUCTION. THE FSPACE MACRO-INSTRUCTION ONLY RELEASES*
.*       SPACE OBTAINED VIA THE GSPACE MACRO-INSTRUCTION.             *
.*                                                                    *
.*       THE RETURN CODES WHEN "S" IS CODED ARE AS FOLLOWS:           *
.* -1:   THE SPCIFIED SPACE CONTROL AREA COULD NOT BE FOUND.          *
.*  0:   THE SPECIFIED SPACE CONTROL AREA WAS SUCCESSFULLY RELEASED,  *
.*       AND ALL THE SPACE OBTAINED USING IT WAS ALSO RELEASED.       *
.*  1:   THE SPECIFIED SUBPOOL IS ZERO, THE SPACE CONTROL AREA IS NOT *
.*       EXPLICITLY CODED, AND THERE ARE SPACE CONTROL AREAS          *
.*       OTHER THAN FOR SUBPOOL ZERO PRESENT, WHICH PREVENTS RELEASING*
.*       THE SPACE CONTROL AREA FOR SUBPOOL ZERO.                     *
.*                                                                    *
.* NOTE: THE CONDITION CODE IS SET TO CORRESPOND TO THE RETURN CODE   *
.*       AS IF AN LTR 15,15 WAS THE LAST INSTRUCTION EXECUTED IN THE  *
.*       FSPACE MACRO-INSTRUCTION.                                    *
.*--------------------------------------------------------------------*
.* LV  - LV SPECIFIES THE LENGTH OF THE AREA TO BE RELEASED.          *
.*       THERE ARE FOUR BASIC WAYS TO CODE THE LV PARAMETER:          *
.* CASE  CODE FORM       MEANING                                      *
.* ----  ---- ----       -------                                      *
.*  0.   LV=NUMBER       NUMBER IS A DECIMAL NUMBER GIVING THE NUMBER *
.*                       OF BYTES TO BE RELEASED, OR IS AN ABSOLUTE   *
.*                       EXPRESSION, NOT SURROUNDED BY PARENTHESES,   *
.*                       THAT DETERMINES THE NUMBER OF BYTES TO BE    *
.*                       RELEASED.                                    *
.*  1.   LV=(GPR)        GPR IS AN ABSOLUTE EXPRESSION HAVING A VALUE *
.*                       FROM 1 TO 15, AND IS THE REGISTER CONTAINING *
.*                       THE NUMBER OF BYTES TO BE RELEASED.          *
.*  2.   LV=(ADDRESS,NUMBER)   ADDRESS IS THE MAIN STORAGE ADDRESS OF *
.*                       EITHER A 1-BYTE OR A HALFWORD FIELD THAT     *
.*                       CONTAINS THE LENGTH OF THE AREA.             *
.*                       LENGTH IS A 1 OR A 2, TO DETERMINE A 1-BYTE  *
.*                       OR HALFWORD FIELD RESPECTIVELY.              *
.*    IF LV=(ADDRESS,) IS CODED, THE LENGTH FIELD IS AN IMPLIED 1-BYTE*
.*                     FIELD.                                         *
.*  3.   LV=((ADR),LENGTH)     THIS CASE IS ESSENTIALLY THE SAME AS   *
.*                       THE PRECEDING CASE, EXCEPT THAT THE ADDRESS  *
.*                       OF THE LENGTH FIELD IS IN THE SPECIFIED GPR  *
.*                       ADR.                                         *
.*  4.   LV=   WHEN THE LENGTH VALUE IS NOT CODED, AND THE R PARAMETER*
.*             IS CODED AS "S", THEN THE SPACE CONTROL AREA SPECIFIED *
.*             BY THE S PARAMETER IS RELEASED TO THE SYSTEM, AND ALL  *
.*             THE SPACE OBTAINED VIA IT IS ALSO RELEASED.            *
.*             THE RELEASE OF THIS SPACE IS VIA FREEMAIN, SO THAT ANY *
.*             SUBSEQUENT REFERENCE TO ANY AREA ALLOCATED WITH THE    *
.*             SPACE CONTROL WORD IS INVALID, AS WELL AS ANY MORE USES*
.*             OF THE SPACE CONTROL ADDRESS WITH FSPACE OR GSPACE     *
.*             MACRO-INSTRUCTIONS.                                    *
.*  5.   IF THE R PARAMETER IS CODED AS "RF", AND THE LV IS EXPLICITLY*
.*             CODED AS A SELF-DEFINING TERM, THEN IF THE NUMERIC VALUE
.*             OF THE LENGTH IS 8, 12, OR 80, THE AREA IS RELEASED TO *
.*             FREE SPACE CHAIN OF FIXED LENGTH ENTRIES OF THE SAID   *
.*             LENGTH. THIS MEANS OF GETTING AND FREEING FIXED LENGTH *
.*             AREAS OF 8, 12, OR 80 BYTES IS VERY FAST.              *
.* A   - A SPECIFIES THE ADDRESS OF THE AREA OF STORAGE TO BE RELEASED.
.*    IF A=ADDRESS IS CODED, THEN "ADDRESS" MUST BE A SUITABLE OPERAND*
.*                 FOR A LOAD ADDRESS INSTRUCTION, AND IS THE ADDRESS *
.*                 OF THE FIRST BYTE OF THE AREA TO BE RELEASED.      *
.*    IF A=(GPR) IS CODED, THEN "GPR" MUST DESIGNATE A REGISTER THAT  *
.*               CONTAINS THE ADDRESS OF THE FIRST BYTE OF THE AREA TO*
.*               BE RELEASED.                                         *
.*--------------------------------------------------------------------*
.* REGISTERS 0,1,14, AND 15 ARE USED AS WORKING REGISTERS, AND ARE    *
.* NOT RESTORED TO THEIR ORIGINAL VALUES.                             *
.*--------------------------------------------------------------------*
.*       THE RETURN CODE SETTINGS ARE:                                *
.*       ZERO - THE AREA WAS RELEASED SUCCESSFULLY.                   *
.**********************************************************************
.* THE LENGTH VALUE IS PLACED IN GPR0, THE ADDRESS IS PLACED IN R1, AND
.* THE BOUNDARY ALIGNMENT VALUE IS PLACED IN R15. THEN THE FSPACE     *
.* SUBROUTINE IN THE MODULE IGARPT01 IS CALLED.                       *
         GBLC  &IGADDR   THE LOCATION CONTAINING THE ADDRESS OF THE
.*                       MODULE IGARPT01.
         GBLC  &IGATCB   THE ADDTREE OF THE TCBRPT WORD.
         GBLC  &IGAFSP         BRANCH ENTRY OFFSET FOR FSPACE.
         GBLC  &IGAFSPS  OFFSET FOR THE BRANCH ENTRY TO THE FSPACE     *
                         PROGRAM WHEN THE SPACE CONTROL ADDRESS IS     *
                         CODED IN THE FSPACE MACRO-INSTRUCTION.
         GBLC  &IGAFS8,&IGAFS12,&IGAFS80  THESE ARE THE ENTRY POINTS TO*
                         RELEASE FIXED LENGTH AREAS OF 8, 12, OR 80    *
                         BYTES RESPECTIVELY USING AN SPCA.
         GBLC  &IGAFRSC  ENTRY POINT TO RELEASE A SPACE CONTROL AREA   *
                         AND ITS ASSOCIATED SPACE TO THE SYSTEM.
         GBLC  &IGASPZ   THE SIZE OF THE SPACE CONTROL HEADER.
         LCLC  &C        JUST A TEMPORARY CHARACTER VECTOR.
         LCLA  &I        JUST A TEMPORARY ARITHMETIC VARIABLE USED FOR *
                         SUNDRY PURPOSES.
         LCLC  &O,&LKR
&O       SETC  '0'
&LKR     SETC  '14'
.*A000000                                                        Y02147
.**********************************************************************
      RPTDSECT T=SPACE,DS=N  GET THE GLOBALS WITHOUT THE DSECT.
         AIF   (K'&TAG EQ 0).LJW0
&TAG     EQU   *
.LJW0    ANOP
         AIF   ('&R' EQ 'S').FRSPCTL  SEE IF THE REQUEST IS TO RELEASE *
                         A SPACE CONTROL AREA.
         AIF   ('&R' EQ 'RF').FIXED  SEE IF THE POSITIONAL PARAMETER   *
                         INDICATES A RELEASE OF A FIXED LENGTH AREA.
.*       PUT THE LENGTH VALUE IN R0.                                  *
         AIF   (K'&LV NE 0).LVHERE  SEE IF THE LV IS CODED.
         MNOTE 12,'MISSING LENGTH VALUE, LV= MUST BE CODED.'
         AGO   .CHKA           GO CHECK THE ADDRESS.
.LVHERE  AIF   ('&LV'(1,1) EQ '(').LV234  GO IF CASE 2, 3, OR 4.
         AIF   (NOT((K'&SP EQ 0)OR('&SP' EQ '0'))).SESPIL0             *
                         SEE IF THE SUBPOOL IS SUBPOOL ZERO.
         LA    0,&LV     LV
         AGO   .CHKA     GO CHECK THE ADDRESS.
.SESPIL0 AIF   ('&SP'(1,1) EQ '(').SESPIL1  SEE IF THE SUBPOOL         *
                         PARAMETER IS IN A REGISTER, AND GO IF IT IS.
         L     0,=AL1(&SP,&LV/X'10000',(&LV-X'10000'*(&LV/X'10000'))/X'*
               100',&LV-X'100'*(&LV/X'100'))  LOAD THE SUBPOOL NUMBER  *
               AND LENGTH VALUE IN THE REGISTER.
         AGO   .CHKA
.SESPIL1 LA    14,&LV    LENGTH VALUE.
         AIF   ('&SP' EQ '(0)').ERGIJ  SEE IF THE SUBPOOL IS ALREADY   *
                         IN REGISTER ZERO.
         LR    0,&SP(1)  SUBPOOL NUMBER.
.ERGIJ   SLL   0,24      PUT THE SUBPOOL IN BYTE 0 OF GPR 0.
.**********************************************************************
.* THE FOLLOWING BXLE IS USED TO ADD THE SUBPOOL AND LENGTH TOGETHER  *
.* BECAUSE THE BXLE INSTRUCTION DOES NOT CHANGE THE CONDITION CODE.   *
.* THE DEL MACRO-INSTRUCTION DEPENDS ON THE FACT THAT THE FSPACE      *
.* MACRO-INSTRUCTION DOES NOT CHANGE THE CONDITION CODE BEFORE THE BAL*
.* TO THE FSPACE ROUTINE.                                             *
.**********************************************************************
.*                                                                    *
         BXLE  0,14,*+4  ADD IN THE SUBPOOL NUMBER.
         AGO   .CHKA
.LV234   AIF   (N'&LV EQ 1).LV2  SEE IF LV=(GPR) IS CODED.
         AIF   ('&LV'(2,1) EQ '(').LV4  SEE IF LV=((ADR),LNG) IS CODED.
         AIF   (K'&LV(2) EQ 0).LV3A    SEE IF LV=(ADR,) IS CODED.
.*       LV=(ADR,LNG) IS CODED.
         AIF   ('&LV(2)' EQ '1').LV3A  SEE IF LV=(ADR,1) IS CODED.
         AIF   ('&LV(2)' EQ '2').LV3B  SEE IF LV=(ADR,2) IS CODED.
         AIF   ('&LV(2)' EQ '4').LV3D  SEE IF "LV=(ADR,4)" IS CODED.
         MNOTE 12,'LV CODED WRONG, 1 OR 2 ONLY ALLOWED FOR LV LENGTH.'
         AGO   .CHKA           GO CHECK THE ADDRESS.
.*  THE LENGTH OF THE LENGTH VALUE IS ONE.  .*
.LV3A    AIF   ((K'&SP NE 0)AND('&SP' NE '0')).SESPIL2  GO IF THE      *
                         SUBPOOL IS NOT SUBPOOL ZERO.
         LA    0,0       GET THE LENGTH VALUE.
.LV3AA   ANOP
         IC    0,&LV(1)  FOR THE AREA TO BE RELEASED.
         AGO   .CHKA     GO CHECK THE ADDRESS.
.SESPIL2 AIF   ('&SP'(1,1) EQ '(').SESPIL3  GO IF SP IS IN GPR.
         LA    0,&SP     SUBPOOL #.
         SLL   0,24      PUT IT IN BYTE 0 OF GPR 0.
         AGO   .LV3AA    GO PUT IN THE LENGTH VALUE.
.SESPIL3 AIF   ('&SP' EQ '(0)').LV3AAAA
         LR    0,&SP(1)  SUBPOOL #.
.LV3AAAA SLL   0,24      PUT THE SUBPOOL IN BYTE 0 OF GPR 0.
         AGO   .LV3AA
.LV3B    AIF   ((K'&SP NE 0)AND('&SP' NE '0')).SESPIL4                 *
                         SEE IF THE SUBPOOL IS ZERO, AND GO IF IT ISN'T.

         LH    0,&LV(1)  GET THE LENGTH VALUE.
         AGO   .CHKA     GO CHECK THE ADDRESS.
.SESPIL4 AIF   ('&SP' EQ '(0)').SESPIL5  SEE IF IT IS IN GPR 0.
         AIF   ('&SP'(1,1) EQ '(').SESPIL6  SEE IF IT IS IN A GPR.
         LA    0,&SP     SUBPOOL #.
         AGO   .SESPIL5  GO GENERATE THE SHIFT INSTRUCTION.
.SESPIL6 LR    0,&SP(1)  SUBPOOL #.
.SESPIL5 SLL   0,24      PUT THE SUBPOOL # IN BYTE 0 OF GPR 0.
         LH    14,&LV(1)  GET THE LENGTH VALUE.
         BXH   0,14,*+4  PRESERVE THE CONDITION CODE.
         AGO   .CHKA
.LV3D    ANOP
         AIF   ((K'&SP NE 0)AND('&SP' NE '0')).LV3DNZ  SEE IF THE      *
                         SUBPOOL IS SUBPOOL ZERO.
         L     0,&LV(1)                        SUBPOOL AND LV.
         AGO   .CHKA
.LV3DNZ  AIF   ('&SP'(1,1) EQ '(').LV3DSPR  SEE IF THE SUBPOOL NUMBER  *
                         IS IN A REGISTER.
         LA    0,&SP                           SUBPOOL #.
         SLL   0,24
         L     14,&LV(1)                        LV.
         BXH   0,14,*+X'04'  PRESERVE THE CONDITION CODE.
         AGO   .CHKA
.LV3DSPR LR    0,&SP(1)                        SP #.
         SLL   0,24
         L     14,&LV(1)                        LV.
         BXLE  0,14,*+X'04'  PRESERVE THE CONDITION CODE.
         AGO   .CHKA
.*  LV=((ADR),LNG) IS CODED.  .*
.LV4     AIF   (K'&LV(2) EQ 0).LV4A  SEE IF LV=((ADR),) IS CODED.
         AIF   ('&LV(2)' EQ '1').LV4A  SEE IF LV=((ADR),1) IS CODED.
         AIF   ('&LV(2)' EQ '2').LV4B  SEE IF LV=((ADR),2) IS CODED.
         AIF   ('&LV(2)' EQ '4').LV4D  SEE IF "LV=((ADR),4)" IS CODED.
.*   LV=((ADR),EXPRESSION) IS CODED.  .*
         MNOTE 12,'INVALID LENGTH OF LV OPERAND, LV=&LV.'
         AGO   .CHKA     GO CHECK THE ADDRESS.
.LV4A    AIF   ((K'&SP NE 0)AND('&SP' NE '0')).SESPIL7  GO IF SP^0.
         LA    0,0
.LV4AA   ANOP
         IC    0,0&LV(1)  GET THE LENGTH OF AREA.
         AGO   .CHKA     GO CHECK THE ADDRESS.
.SESPIL7 AIF   ('&SP'(1,1) EQ '(').SESPIL8  GO IF SP IS IN A GPR.
         LA    0,&SP     SUBPOOL #.
.BEGRUDG SLL   0,24      PUT THE SUBPOOL # IN BYTE 0 OF GPR0.
         AGO   .LV4AA
.SESPIL8 AIF   ('&SP' EQ '(0)').BEGRUDG  SEE IF THE SP# IS IN GPR 0.
         LR    0,&SP(1)  LOAD SUBPOOL # INTO GPR ZERO.
         AGO   .BEGRUDG  GO SHIFT IT OVER INTO BYTE 0.
.LV4B    AIF   ((K'&SP NE 0)AND('&SP' NE '0')).SESPIL9  GO IF SP# IS ^0
         LH    0,0&LV(1) LV=((ADR),1)
         AGO   .CHKA     GO CHECK THE ADDRESS.
.SESPIL9 AIF   ('&SP'(1,1) EQ '(').SESPILA  GO IF SP# IS IN A GPR.
         LA    0,&SP     SUBPOOL #.
         AGO   .SESPILB  GO SHIFT IT OVER INTO BYTE ZERO.
.SESPILA AIF   ('&SP' EQ '(0)').SESPILB  GO IF SP# IS ALREADY IN GPR 0.
         LR    0,&SP(1)  SUBPOOL #.
.SESPILB SLL   0,24      SHIFT IT OVER INTO BYTE ZERO.
         LH    14,&LV(1)  LENGTH VALUE
         BXLE  0,14,*+4  KEEP THE CC.
         AGO   .CHKA
.LV4D    ANOP
         AIF   ((K'&SP NE 0)AND('&SP' NE '0')).LV4DNZ  SEE IF THE      *
                         SUBPOOL IS SUBPOOL ZERO.
         L     0,0&LV(1)                        SUBPOOL AND LV.
         AGO   .CHKA
.LV4DNZ  AIF   ('&SP'(1,1) EQ '(').LV4DSPR  SEE IF THE SUBPOOL NUMBER  *
                         IS IN A REGISTER.
         LA    0,&SP                           SUBPOOL #.
         SLL   0,24
         L     14,0&LV(1)                        LENGTH VALUE.
         BXLE  0,14,*+X'04'
         AGO   .CHKA
.LV4DSPR LR    0,&SP(1)                        SP #.
         SLL   0,24
         AL    0,0&LV(1)                        LV.
         AGO   .CHKA
.LV2     AIF        (('&LV' EQ '(0)')AND((K'&SP EQ 0)OR('&SP' EQ '0')OR*
               ('&SP' EQ '(0)'))).CHKA  GO IF THE SUBPOOL # AND LENGTH
.*             VALUE ARE ALREADY IN REGISTER 0, WHICH MEANS THAT      *
.*             "LV=(0)" IS CODED, AND THE SUBPOOL NUMBER DOESN'T HAVE *
.*             TO BE FILLED IN.                                       *
         AIF   (K'&SP NE 0).SESPILC  GO IF THE SUBPOOL # IS CODED.
         LR    0,&LV(1)  LV.
         AGO   .CHKA     GO CHECK THE ADDRESS.
.SESPILC AIF   ('&SP'(1,1) EQ '(').SESPILD  GO IF THE SP# IS IN A GPR.
         AIF   ('&LV' EQ '(0)').SESPILE  GO IF THE LENGTH IS IN R0.
         LA    0,&SP     SUBPOOL #.
         SLL   0,24      PUT THE SUBPOOL NUMBER IN BYTE 0.
         BXH   0,&LV(1),*+4  KEEP THE CC.
         AGO   .CHKA
.SESPILD AIF   ('&SP' EQ '(0)').SESPILF  GO IF SP# IS IN GPR 0.
         LR    0,&SP(1)  SUBPOOL#.
         AIF   ('&SP' EQ '&LV').CHKA  SEE IF THE SUBPOOL NUMBER AND THE*
                         LENGTH VALUE ARE ALREADY IN THE SAME REGISTER.
.SESPILF SLL   0,24      PUT SP# IN BYTE 0 OF GPR ZERO.
         BXH   0,&LV(1),*+4  PRESERVE THE CONDITION CODE.
         AGO   .CHKA
.SESPILE LA    14,&SP    SUBPOOL NUMBER.
         BXH   0,14,*+4
         AGO   .CHKA
.*********************************************************************.
.* THE LENGTH VALUE IS ALL ANALYZED AND LOADED, NOW GET THE ADDRESS.  *
.*********************************************************************.
.CHKA    AIF   (K'&A NE 0).AHERE   SEE IF A IS CODED.
         MNOTE 12,'THE ADDRESS OF THE AREA IS MISSING; A= MUST BE HERE'
         AGO   .CHKB     GO CHECK THE BOUNDARY ALIGNMENT PARAMETER.
.AHERE   AIF   ('&A'(1,1) EQ '(').A1  SEE IF A=(ADR) IS CODED.
.*       A=ADDRESS IS CODED.
         LA    1,&A      AREA ADDRESS.
         AGO   .CHKB     GO CHECK THE BOUNDARY ALIGNMENT PARAMETER.
.*       A=(ADDRESS) IS CODED.
.A1      AIF   ('&A' EQ '(1)').CHKB  SEE IF A=(1) IS CODED.
         LR    1,&A(1)  AREA ADDRESS.
         AGO   .CHKB     GO CHECK THE BOUNDARY ALIGNMENT PARAMETER.
.*--------------------------------------------------------------------*
.CHKB    ANOP
.*--------------------------------------------------------------------*
.* ALL THREE REGISTERS ARE SET UP, NOW LINK TO THE FSPACE SUBROUTINE. *
.*--------------------------------------------------------------------*
.LINK    ANOP
         AIF   (K'&S EQ 0).LINKGEN  SEE IF THE SPACE ADDRESS IS CODED.
         AIF   ('&S'(1,1) EQ '(').LINKGPR  SEE IF THE SPACE ADDRESS IS *
                         IN A GENERAL PURPOSE REGISTER.
         L     15,&S  LOAD THE ADDRESS OF THE SPACE CONTROL AREA.
         L     14,0(,15)  LOAD THE ADDRESS OF IGARPT01.
         AGO   .LINKTO   GO LINK TO THE FSPACE PROGRAM.
.LINKGPR AIF   ('&S' EQ '(15)').LINKREG  SEE IF IT IS IN R15 ALREADY.
         LR    15,&S(1)  PUT THE ADDRESS OF THE SPACE CONTROL AREA IN  *
               GENERAL REGISTER 15.
.LINKREG L     14,0(,15)  LOAD THE ADDRESS OF MODULE IGARPT01.
.LINKTO  ANOP
         BAL   &LKR,&IGAFSPS.(,&LKR)  INDICATE SPCA PRESENT.
         AGO   .FIN
.LINKGEN RPTDSECT GEN=(CVTRPT,15)  GET THE ADDRESS OF THE MODULE       *
                         IGARPT01 IN REGISTER 15.
         BAL   &LKR,&IGAFSP.(,15)  LINK TO FSPACE ROUTINE.
         AGO   .FIN
.**********************************************************************
.* COME HERE WHEN "S" IS CODED IN THE R-PARAMETER.                    *
.**********************************************************************
.*                                                                    *
.FRSPCTL ANOP
         AIF   (K'&S EQ 0).FSMT  SEE IF S IS CODED.
         AIF   ('&S'(1,1) EQ '(').SFINGPR  SEE IF THE SPACE CONTROL    *
                         AREA ADDRESS IS IN A GPR.
         L     1,&S  SPACE CONTROL WORD.
         AGO   .SISHERE  MERGE WITH THE COMMONE SEQUENCE AFTER THE     *
                         SPACE CONTROL ADDRESS IS LOADED IN R1.
.SFINGPR AIF   ('&S' EQ '(1)').SISHERE  SEE IF IT IS ALREADY IN R1.
         LR    1,&S(1)   ADDRESS OF SPACE CONTROL AREA.
         AGO   .SISHERE  MERGE IN WITH THE COMMON SEQUENCE.
.FSMT    LA    1,0       INDICATE NO SPACE CONTROL WORD.
.SISHERE AIF   (K'&SP EQ 0).FSIS0  SEE IF IT IS SUBPOOL ZERO.
         AIF   ('&SP' EQ '0').FSIS0  SEE IF IT IS SUBPOOL ZERO.
         LA    15,&SP    SUBPOOL #.
         SLL   15,24
         LA    0,&IGASPZ
         BXH   0,15,*+4  KEEP THE CONDITION CODE.
         AGO   .FLINK    GO LINK TO THE SUBROUTINE.
.FSIS0   LA    0,&IGASPZ
.FLINK   AIF   (K'&S NE 0).FLINK0  SEE IF THE ADDRESS OF THE MODULE    *
                         IGARPT01 IS AVAILABLE VIA THE SPACE CONTROL   *
                         WORD.
      RPTDSECT GEN=(TCBRPT,15)  GET THE ADDRESS OF THE MODULE IGARPT01 *
                         IN REGISTER 15.
         AGO   .FLINK1   GO TO GENERATE THE ACTUAL LINK.
.FLINK0  L     15,&IGADDR.(,1)  ADDRESS OF IGARPT01.
.FLINK1  BAL   14,&IGAFRSC.(,15)  LINK TO RELEASE SPACE CONTROL AREA.
         AIF   (K'&S EQ 0).FIN  SEE IF THE SPCA IS EXPLICITLY CODED.
         AIF   ('&S'(1,1) EQ '(').FLINK2  SEE IF THE SPCA ADDRESS IS IN*
                         A GPR.
         ST    15,&S              RESET THE SPCA ADDRESS.
         AGO   .FIN
.FLINK2  LR    &S(1),15              RESET THE SPCA ADDRESS.
         AGO   .FIN      GO DIRECTLY TO THE EXIT FOR THE FSPACE        *
                         MACRO-INSTRUCTION.
.**********************************************************************
.* COME HERE TO GENERATE THE LINKAGE TO RELEASE A FIXED LENGTH AREA   *
.* USING THE FIXEDHDR IN THE SPACE CONTROL AREA. ONLY AREAS OF LENGTH *
.* 8, 12, OR 80 CAN BE RELEASED IN THIS MANNER. ALSO THE SPACE CONTROL*
.* AREA ADDRESS MUST BE SPECIFIED BY CODING THE S PARAMETER IN ORDER  *
.* TO DO IT.                                                          *
.**********************************************************************
.FIXED   ANOP
         AIF   ((K'&A NE 0)AND(K'&S NE 0)AND(K'&LV NE 0)).FIXEDOK      *
                         SEE IF ALL THE NECESSARY PARAMETERS ARE CODED.
         AIF   (K'&A NE 0).FXAOK  SEE IF IT IS THE A PARAMETER THAT IS *
                         NOT CODED.
         MNOTE 12,'ADDRESS OF AREA TO RELEASE IS MISSING -- A PARAMETER*
               .'
.FXAOK   ANOP
         AIF   (K'&S NE 0).FXSOK  SEE IF THE S PARAMETER IS MISSING.
         MNOTE 12,'THE S PARAMETER MUST BE CODED FOR FSPACE RF,...'
.FXSOK   ANOP
         AIF   (K'&LV NE 0).FXLVOK  SEE IF THE LENGTH VALUE PARAMETER  *
                         IS MISSING.
         MNOTE 12,'LENGTH VALUE IS MISSING -- LV PARAMETER.'
.FXLVOK  ANOP
         AGO   .FIN   EXIT BECAUSE THE IS NO HOPE OF CORRECT EXECUTION.
.**********************************************************************
.* CHECK THE LENGTH VALUE TO SEE IF IT IS 8, 12, OR 80.               *
.**********************************************************************
.FIXEDOK ANOP
         AIF   (('&LV' EQ '8')OR('&LV' EQ '12')OR('&LV' EQ '80')OR('&LV*
               ' EQ 'X''8''')OR('&LV' EQ 'X''C''')OR('&LV' EQ 'X''50'''*
               )).FXLOK
         MNOTE 12,'THE LENGTH VALUE MUST BE 8, 12, OR 80 TO USE THE RF *
               FORM OF FSPACE.'
         AGO   .FIN
.FXLOK   ANOP
.**********************************************************************
.* PUT THE ADDRESS OF THE AREA TO BE RELEASED IN GPR 1.               *
.**********************************************************************
         AIF   ('&A'(1,1) EQ '(').FXAGPR  SEE IF THE ADDRESS IS IN A   *
                         GENERAL REGISTER.
         LA    1,&A      ADDRESS OF AREA TO BE RELEASED.
         AGO   .FXGOTA   MERGE WITH THE COMMON SEQUENCE.
.FXAGPR  AIF   ('&A' EQ '(1)').FXGOTA  SEE IF THE ADDRESS IS ALREADY IN*
                         THE RIGHT REGISTER.
         LR    1,&A(1)   AREA ADDRESS.
.FXGOTA  ANOP
.**********************************************************************
.* GET THE ADDRESS OF THE SPCA IN REGISTER 15, AND GET THE ADDRESS OF *
.* THE MODULE IGARPT01 IN REGISTER 14 FOR THE LINKAGE.                *
.**********************************************************************
         AIF   ('&S'(1,1) EQ '(').FXSGPR  SEE IF THE SPACE CONTROL     *
                         ADDRESS IS IN A GENERAL REGISTER.
         L     15,&S     SPCA ADDRESS.
         AGO   .FXGOTS   MERGE WITH THE COMMON PATH.
.FXSGPR  AIF   ('&S' EQ '(15)').FXGOTS  SEE IF IT IS ALREADY IN THE    *
                         RIGHT REGISTER.
         LR    15,&S(1)  THE ADDRESS OF THE SPCA.
.FXGOTS  ANOP
         L     14,&IGADDR.(,15)  ADDRESS OF IGARPT01.
.**********************************************************************
.* NOW CHECK THE LENGTH VALUE TO SEE WHICH ONE OF THE LENGTHS IS      *
.* INVOLVED; 8, 12, OR 80.                                            *
.**********************************************************************
         AIF   (('&LV' EQ '8')OR('&LV' EQ 'X''8''')).FXLV8  SEE IF IT  *
                         IS 8 BYTES.
         AIF   (('&LV' EQ '80')OR('&LV' EQ 'X''50''')).FXLV80          *
                         SEE IF IT IS AN 80-BYTE AREA.
         BAL   14,&IGAFS12.(,14)  LINK TO RELEASE THE 12-BYTE AREA.
         AGO   .FIN      ALL DONE NOW, EXIT.
.FXLV8   BAL   14,&IGAFS8.(,14)  LINK TO RELEASE THE 8-BYTE AREA.
         AGO   .FIN
.FXLV80  BAL   14,&IGAFS80.(,14)  LINK TO RELEASE THE 80-BYTE AREA.
         AGO   .FIN
.FIN     ANOP
         MEND
         EJECT
         MACRO
&TAG    FTREE  &TREE,&T=,&TYPE=,&S=,&SP=,&LV=
         GBLC  &IGABLST  THE OFFSET INTO THE TREE HEADER FOR THE LIST  *
                         OF RPT ENTRY POINTS.
         GBLC  &IGAFTRE
         GBLC  &IGADDR         THE ADDRESS OF THE MODULE.
         GBLC  &IGAHVFC  THE OFFSET IN THE RPT HEADER TO THE ADDRESS OF*
                         THE FIXEDHDR FOR THE INNER VERTEX SPACE CHAIN.
         GBLC  &IGARPT#  THIS HOLDS THE RADIX PARTITION TREE TYPE.
.*A000000                                                        Y02147
.* THE FTREE MACRO-INSTRUCTION DELETES ALL THE KEY-ADDRESS ASSOCIATION*
.* PAIRS FROM A RADIX PARTITION TREE.                                 *
.* IF THE LV PARAMETER IS CODED IT IS PASSED ON THE THE DEL           *
.* MACRO-INSTRUCTION TO BE USED FOR RELEASING THE RECORD AREAS TO THE *
.* SYSTEM, AS DESCRIBED IN THE DESCRIPTION OF THE DEL                 *
.* MACRO-INSTRUCTION.                                                 *
.* THE VARIOUS PARAMETERS ARE DESCRIBED BELOW:                        *
.* TREE: THIS SPECIFIES THE ADDRESS OF THE RADIX PARTITION TREE AS    *
.*       RECEIVED FROM THE STREE MACRO-INSTRUCTION WHEN THE TREE IS   *
.*       CONSTRUCTED. IF "LABEL" IS CODED, WHERE "LABEL" IS A LABEL OF*
.*       A WORD IN STORAGE, THEN THE ADDRESS IS LOADED FROM THE       *
.*       DESIGNATED WORD. IF "(GPR)" IS CODED, THEN THE ADDRESS IS    *
.*       TAKEN FROM THE DESIGNATED GPR.                               *
.* T:    THIS SPECIFIES THE RADIX PARTITION TREE TYPE, IF IT IS NOT   *
.*       CODED THE DEFAULT TYPE IS 8.                                 *
.* S:    S IS THE SPACE CONTROL ADDRESS, AS DESCRIBED IN THE GSPACE   *
.*       MACRO-INSTRUCTION.                                           *
.* SP:   SEE THE DESCRIPTION OF THE FSPACE MACRO-INSTRUCTION.         *
.* LV:   SEE THE DESCRIPTION OF THE LV PARAMETER IN THE DEL           *
.*       MACRO-INSTRUCTION DESCRIPTION.                               *
.**********************************************************************
.* CHECK THE TYPE AND T PARAMETERS TO SEE IF A VALID RPT TYPE IS      *
.* SPECIFIED. IF NEITHER IS SPECIFIED, ASSUME IT IS TYPE 8 RPT. THE   *
.* TYPE IS PUT INTO THE GLOBAL VARIABLE &IGARPT# AT THE END OF THE    *
.* TYPE CHECKING SECTION.                                             *
.**********************************************************************
.RPT#    AIF   (K'&T EQ 0).RPT#TMT  SEE IF THE T PARAMETER IS CODED.
         AIF   (K'&TYPE EQ 0).RPT#TCK  USE THE T PARAMETER IF IT IS    *
                         CODED AND THE TYPE PARAMETER IS NOT CODED.
.**********************************************************************
.* BOTH THE T AND TYPE PARAMETERS ARE CODED; SEE IF THEY ARE THE SAME,*
.* AND IF THEY ARE NOT THEN USE T.                                    *
.**********************************************************************
         AIF   ('&T' EQ '&TYPE').RPT#TCK  IF THEY ARE THE SAME THEN USE*
                         T.
         MNOTE 4,'TYPE CONFLICT, ONLY T OR TYPE SHOULD BE CODED.'
.RPT#TCK ANOP
&IGARPT# SETC  '&T'      GET THE RPT TYPE.
         AGO   .RPT#CHK  GO TO CHECK THE VALIDITY OF THE RADIX         *
                         PARTITION TREE TYPE.
.**********************************************************************
.* THE T PARAMETER IS NOT CODED, SEE IF THE TYPE PARAMETER IS CODED.  *
.**********************************************************************
.RPT#TMT AIF   (K'&TYPE EQ 0).RPT#8  IF BOTH ARE LEFT OUT USE TYPE 8   *
                         RPT.
&IGARPT# SETC  '&TYPE'   SET THE TYPE TO THE TYPE THAT IS SPECIFIED BY *
                         THE TYPE PARAMETER.
         AGO   .RPT#CHK  GO CHECK IT FOR VALIDITY.
.RPT#8   ANOP
&IGARPT# SETC  '8'       SET THE RPT TYPE TO 8.
.RPT#CHK AIF   (('&IGARPT#' EQ '8')OR('&IGARPT#' EQ '5')OR('&IGARPT#' E*
               Q '4')).RPT#FIN
         MNOTE 4,'INVALID RPT TYPE, TYPE 8 ASSUMED.'
&IGARPT# SETC  '8'       TAKE THE DEFAULT TYPE 8 RPT.
.RPT#FIN ANOP
      RPTDSECT T=&IGARPT#,DS=YES
         AIF   ('&IGARPT#' EQ '8').TYPE8  SEE IF IT IS A TYPE 8 RPT.
         AIF   (K'&TREE EQ K'&TREE(1)+2).LW0
&TAG     L     1,&TREE
         AGO   .LW1
.LW0     AIF   ('&TREE' EQ '(1)').IFBR
&TAG     LR    1,&TREE(1)
         AGO   .LW1
.IFBR    AIF   (K'&TAG EQ 0).LW1
&TAG     EQU   *
.LW1     ANOP
SRCH&SYSNDX SRCH (1),TYPE=5,SARG=((0))
         LTR   15,15
         BC    4,OVER&SYSNDX
         DEL   (1),TYPE=5,FREE=NO
         BC    15,SRCH&SYSNDX
OVER&SYSNDX    EQU       *
         USING IGARPTH5,1
         L     2,IGAHVFC5
         IC    0,IGASP5
         SLL   0,24
         AL    0,=AL4(IGATYP5S)
     FREEMAIN R,LV=(0),A=(1)
         N     0,=XL4'FF000000'
         AL    0,=F'8'
FREE&SYSNDX LTR 1,2
         BC    8,DONE&SYSNDX
         L     2,0(2)
     FREEMAIN R,LV=(0),A=(1)
         BC    15,FREE&SYSNDX
DONE&SYSNDX EQU *
         DROP 1
         MEXIT
.NOT5    ANOP
.TYPE8   ANOP
&TAG     ISCAN &TREE
LW&SYSNDX SCANL &TREE
         BM    LJW&SYSNDX
         DEL   &TREE,T=&IGARPT#,S=&S,SP=&SP,LV=&LV
         BNM   LW&SYSNDX  GO BACK IF IT WAS NOT THE LAST ONE.
         USING IGARPTH,0
         AIF   ('&TREE'(1,1) EQ '(').FTRGPR  SEE IF THE TREE ADDRESS IS*
                         IN A GPR.
         L     1,&TREE                 ADDRESS OF RPT.
         AGO   .FTRMERG  MERGE IN WITH THE COMMON SEQUENCE.
.FTRGPR  LR    1,&TREE(1)                        ADDRESS OF TREE.
.FTRMERG L     15,&IGAHVFC             INNVER VERTEX ALLOCATION BLOCK.
         L     15,4(,15)               SUBPOOL # FOR TREE HEADER.
         N     15,=XL4'00FFFFFF'
         LA    0,IGATYP8S
         ALR   0,15
LJW&SYSNDX FSPACE R,A=(1),LV=(0),S=&S            FREE HEADER.
         DROP  0
.END     ANOP
         MEND
         EJECT
         MACRO
&TAG    GSPACE &R,&LV=,&S=,&SP=
.* THIS MACRO ALLOCATES AN AREA OF MAIN STORAGE OF THE SIZE INDICATED *
.* BY THE LV PARAMETER, USING THE LOCAL STORAGE MANAGEMENT ROUTINES IN*
.* THE MODULE IGARPT01.                                               *
.*                                                                    *
.*             LOCAL STORAGE ALLOCATION                               *
.*             ----- ------- ----------                               *
.*                                                                    *
.* THE GSPACE AND FSPACE MACRO-INSTRUCTIONS ARE THE INTERFACE TO THE  *
.* LOCAL STORAGE ALLOCATION FUNCTIONS IN THE RPTS COMPONENT OF THE    *
.* OPERATING SYSTEM.                                                  *
.*                                                                    *
.* THE GSPACE AND FSPACE MACRO-INSTRUCTIONS PROVIDE FUNCTIONS THAT ARE*
.* EQUIVALENT TO THE R-FORM OF THE GETMAIN AND FREEMAIN               *
.* MACRO-INSTRUCTIONS, BUT ARE SIGNIFICANTLY FASTER THAN GETMAIN AND  *
.* FREEMAIN. THE GSPACE MACRO-INSTRUCTION ALLOCATES SPACE, AND THE    *
.* FSPACE MACRO-INSTRUCTION RELEASES SPACE TO THE SYSTEM.             *
.*                                                                    *
.* AS THE NAME "LOCAL STORAGE ALLOCATION" IMPLIES, THE GSPACE AND     *
.* FSPACE MACRO-INSTRUCTIONS ALLOCATE AND RELEASE VIRTUAL STORAGE ON A*
.* LOCAL BASIS. THE GSPACE AND FSPACE MACRO-INSTRUCTIONS ALLOCATE AND *
.* RELEASE STORAGE IN A LOCAL COLLECTION OF STORAGE AREAS DEFINED BY A*
.* SPACE CONTROL AREA (SPCA). EACH SPCA IS IDENTIFIED BY ITS VIRTUAL  *
.* STORAGE ADDRESS, WHICH IS KEPT IN A WORD CALLED THE ADDRESS OF THE *
.* SPACE CONTROL AREA, OR THE SPACE CONTROL WORD (SPCW). THE SPCA     *
.* CONTAINS ENOUGH INFORMATION TO IDENTIFY THE AVAILABLE STORAGE AREAS*
.* IN THE COLLECTION OF AREAS DEFINED BY THE SPCA.                    *
.*                                                                    *
.* EVERY TIME THE GSPACE AND FSPACE MACRO-INSTRUCTIONS ARE EXECUTED,  *
.* THEY USE THE ADDRESS OF THE SPCA TO DETERMINE THE COLLECTION OF    *
.* STORAGE AREAS THAT PARTICIPATE IN THE ALLOCATION OR RELEASE OF AN  *
.* AREA OF STORAGE. THE S PARAMETER IN THE GSPACE AND FSPACE          *
.* MACRO-INSTRUCTIONS SPECIFIES THE ADDRESS OF THE SPCA TO BE USED.   *
.*                                                                    *
.* SINCE EVERY ALLOCATION OR RELEASE OF STORAGE USES AN SPCA, AN SPCA *
.* MUST BE ESTABLISHED BEFORE ANY ALLOCATION CAN BE DONE. THERE ARE   *
.* TWO WAYS OF ESTABLISHING AND USING AN SPCA; THE EXPLICIT MODE AND  *
.* THE IMPLICIT MODE.                                                 *
.*                                                                    *
.* IN THE EXPLICIT MODE, THE SPCA IS ESTABLISHED BY USING THE GSPACE  *
.* MACRO-INSTRUCTION WITH THE POSITIONAL PARAMETER CODED AS "S" OR    *
.* "SC", WHICH CREATES AN SPCA AND STORES THE ADDRESS OF THE SPCA IN  *
.* THE PLACE SPECIFIED BY THE S PARAMETER. THE THE S PARAMETER MUST BE*
.* CODED ON ALL SUBSEQUENT GSPACE AND FSPACE USES OF THE LOCAL        *
.* COLLECTION OF STORAGE DEFINED BY THE SPCA.                         *
.* THE FOLLOWING EXAMPLE ILLUSTRATES HOW A SPACE CONTROL AREA CAN BE  *
.* ESTABLISHED, USED, AND RELEASED USING THE EXPLICIT MODE:           *
.*                                                                    *
.*       GSPACE S,S=(9)  ESTABLISH AN SPCA AND SAVE ITS ADDRESS IN    *
.*                       REGISTER 9.                                  *
.*       GSPACE R,LV=200,S=(9)  ALLOCATE 200 BYTES USING THE SPCA.    *
.*       LR     3,1      SAVE THE ADDRESS OF THE AREA ALLOCATED.      *
.*       GSPACE R,LV=256,S=(9)  ALLOCATE 256 BYTES USING THE SPCA.    *
.*       LR     4,1      SAVE THE ADDRESS OF THE 256-BYTE AREA        *
.*                       ALLOCATED.                                   *
.*       FSPACE R,S=(9),LV=200,A=(3) RELEASE THE 200-BYTE AREA TO THE *
.*              SYSTEM.                                               *
.*       FSPACE S,S=(9)         RELEASE THE SPACE CONTROL AREA TO THE *
.*                       SYSTEM, AS WELL AS ALL STORAGE ASSOCIATED    *
.*                       WITH IT (IN THIS CASE THE 256-BYTE AREA IS   *
.*                       RELEASED ALONG WITH THE SPCA). NO FUTURE     *
.*                       EXECUTIONS OF GSPACE OR FSPACE ARE VALID     *
.*                       AFTER THE SPCA HAS BEEN RELEASED VIA THE     *
.*                       FSPACE MACRO-INSTRUCTION.                    *
.*                                                                    *
.* IN THE EXPLICT MODE THE SUBPOOL FOR THE STORAGE CAN BE SPECIFIED   *
.* WHEN THE SPCA IS ESTABLISHED BY CODING THE SP PARAMETER IN THE     *
.* GSPACE MACRO-INSTRUCTION. THUS IF "GSPACE S,S=(9),SP=23" HAD BEEN  *
.* CODED IN THE FIRST GSPACE IN THE EXAMPLE, SUBPOOL 23 WOULD BE USED *
.* FOR ALLOCATING THE SPCA, AND THE 200 AND 256-BYTE AREAS WOULD ALSO *
.* BE ALLOCATED USING SUBPOOL 23.                                     *
.* THE TWO GSPACE ALLOCATIONS FOR THE 200 BYTES AND THE 256 BYTES NEED*
.* NOT HAVE THE SP PARAMETER CODED, SINCE THE SPCA USED ALREADY       *
.* CONTAINS THE SUBPOOL TO BE USED. IF THE SP PARAMETER IS CODED IN   *
.* THE EXPLICIT MODE, IT IS IGNORED, AND THE SUBPOOL IN THE SPCA IS   *
.* USED.                                                              *
.*                                                                    *
.* IN THE IMPLICIT MODE, THERE IS ONE SPCA FOR EACH COLLECTION OF     *
.* STORAGE DEFINED, AND EACH COLLECTION OF STORAGE CORRESPONDS TO A   *
.* SUBPOOL BEING USED FOR ALLOCATION AND RELEASE OF SPACE. THE        *
.* COLLECTION OF SPCA'S IS LOCATED BY MEANS OF A WORD IN THE CURRENT  *
.* TASK CONTROL BLOCK (TCBRPT). THE SPCA FOR THE SUBPOOL SPECIFIED BY *
.* THE REQUEST IS FOUND BY EXAMINING THE TCB-ADDRESSED COLLECTION. IF *
.* THERE IS NO SPCA FOR THE REQUEST SUBPOOL, THEN ONE IS ESTABLISHED  *
.* AUTOMATICALLY AND ADDED TO THE TCB-ADDRESSED COLLECTION.           *
.* WHEN USING THE GSPACE AND FSPACE MACRO-INSTRUCTIONS IN THE IMPLICIT*
.* MODE THE S PARAMETER IS NEVER CODED. THE SP PARAMETER IS USED TO   *
.* LOCATE THE APPROPRIATE SPCA.                                       *
.*                                                                    *
.* THE EXAMPLE ABOVE, WITH THE S PARAMETER NOT CODED ON ANY           *
.* MACRO-INSTRUCTION, WOULD ESTABLISH AN SPCA FOR SUBPOOL ZERO,       *
.* ALLOCATE THE TWO AREAS USING IT, RELEASE THE 200-BYTE AREA, AND    *
.* THEN RELEASE THE SPCA FOR SUBPOOL ZERO ALONG WITH THE 256-BYTE     *
.* AREA.                                                              *
.*                                                                    *
.* IN THE IMPLICIT MODE, AN SPCA FOR SUBPOOL ZERO MUST ALWAYS EXIST   *
.* FOR CORRECT OPERATION OF THE LOCAL STORAGE ALLOCATION ROUTINES. THE*
.* SPCA FOR SUBPOOL ZERO IS ESTABLISHED BEFORE ANY SPCA FOR ANY OTHER *
.* SUBPOOL. THE FOLLOWING EXAMPLE ILLUSTRATES HOW TO USE THE LOCAL    *
.* STORAGE ALLOCATION FACILITY FOR SUBPOOL 127, AND THEN RELEASE THE  *
.* SPCA FOR SUBPOOL 127 FROM THE TCB-ADDRESSED COLLECTION:            *
.*                                                                    *
.*       GSPACE S,SP=127,LV=200  ALLOCATE 200 BYTES USING THE SPCA FOR*
.*                       SUBPOOL 127 (WHICH IS CREATED WITH THIS      *
.*                       REQUEST).                                    *
.*       LR     3,1     SAVE THE ADDRESS OF THE AREA ALLOCATED.       *
.*       GSPACE R,LV=256,SP=127  ALLOCATE 256 BYTES USING SUBPOOL 127.*
.*       FSPACE R,LV=200,SP=127,A=(3)  RELEASE THE 200-BYTE AREA.     *
.*       FSPACE S,SP=127  RELEASE THE SPCA FOR SUBPOOL 127, AND       *
.*                       RELEASE ALL STORAGE ALLOCATED USING IT.      *
.*                                                                    *
.* AT THIS POINT THERE IS STILL AN SPCA FOR SUBPOOL ZERO. IF NO       *
.* SUBSEQUENT ALLOCATION OR RELEASE IS DONE, AND THE TASK TERMINATES, *
.* THE STORAGE IS AUTOMATICALLY RELEASED AT TASK TERMINATION TIME.    *
.* THE SPCA FOR SUBPOOL ZERO CANNOT BE RELEASED EXCEPT AT TASK        *
.* TERMINATION TIME.                                                  *
.*                                                                    *
.* SINCE THE SPCA FOR THE SPECIFIED SUBPOOL MAY NOT BE IN THE         *
.* COLLECTION DEFINED BY THE TCB, THE FOLLOWING RETURN CODES ARE      *
.* PROVIDED:                                                          *
.*                                                                    *
.*                                                                    *
.*       CODE: MEANING:                                               *
.*       ----- --------                                               *
.*       ZERO: THE SPCA WAS SUCCESSFULLY RELEASED.                    *
.*       ZERO: THE SPCA WAS SUCCESSFULLY RELEASED.                    *
.*         -1: EITHER THE SPCA FOR THE SPECIFIED SUBPOOL COULD NOT BE *
.*             FOUND OR SUBPOOL ZERO IS SPECIFIED, AND THE SPCA FOR   *
.*             SUBPOOL ZERO CAN NOT BE RELEASED EXCEPT AT TASK        *
.*             TERMINATION TIME.                                      *
.*                                                                    *
.* ALL STORAGE ALLOCATED VIA THE GSPACE MACRO-INSTRUCTION IS ALLOCATED*
.* IN INCREMENTS OF 16 BYTES IN SIZE. THE LENGTH VALUE FOR THE REQUEST*
.* IS ROUNDED TO THE NEXT EXACT MULTIPLE OF 16 BYTES BEFORE THE       *
.* REQUEST IS PROCESSED.                                              *
.**********************************************************************
.*                                                                    *
.* THE VARIOUS PARAMETER MEANINGS ARE AS FOLLOWS:                     *
.*--------------------------------------------------------------------*
.*  R  - THE R PARAMETER IS USED TO INDICATE A CONDITIONAL OR AN      *
.*       UNCONDITIONAL REQUEST.                                       *
.*                                                                    *
.*       IF "R" IS CODED THE REQUEST IS UNCONDITIONAL.                *
.*       IF "RC"IS CODED THE REQUEST IS CONDITIONAL.                  *
.*       THE ADDRESS OF THE SPACE ALLOCATED IS RETURNED IN R1.        *
.*       THE RETURN CODE IN REGISTER 15 IS SET TO ZERO IF THE REQUEST *
.*       WAS SATISFIED, OR TO 4 IF THE REQUEST WAS NOT SATISFIED.     *
.*                                                                    *
.*       THE ADDRESS OF THE SPACE OBTAINED IS RETURNED IN REGISTER 1. *
.*       IF "S" IS CODED, THEN A SPACE CONTROL AREA IS ESTABLISHED FOR*
.*       SUBSEQUENT USE WITH THE GSPACE AND FSPACE MACRO-INSTRUCTIONS.*
.*                                                                    *
.*       WHEN THE SPACE CONTROL OPTION IS USED, YOU SHOULD BE SURE    *
.*       THAT ALL SUBSEQUENT REFERENCES TO THE SPACE ARE BY MEANS OF  *
.*       THE ADDRESS OF THE SPACE CONTROL AREA THAT IS RETURNED BY THE*
.*       GSPACE MACRO-INSTRUCTION.                                    *
.*                                                                    *
.*       IN PARTICULAR, THE STREE MACRO-INSTRUCTION MUST HAVE THE S   *
.*       PARAMETER CODED IF THE GSPACE MACRO-INSTRUCTION IS USED TO   *
.*       ESTABLISH THE SPACE CONTROL AREA.                            *
.*       NOTE THAT THE STREE MACRO-INSTRUCTION IS NOT PART OF THE     *
.*       GSPACE/FSPACE PAIR, AND IS ONLY MENTIONED HERE BECAUSE IT HAS*
.*       A PARAMETER S THAT CAN BE USED TO SPECIFY A SPACE CONTROL    *
.*       AREA OBTAINED VIA THE GSPACE MACRO-INSTRUCTION.              *
.*                                                                    *
.*       IF "SC" IS CODED AND THE LV PARAMETER IS CODED, AFTER THE    *
.*       SPACE CONTROL AREA IS ESTABLISHED AN AREA OF THE INDICATED   *
.*       LENGTH IS ALLOCATED USING THE NEW SPACE CONTROL AREA, AND    *
.*       THIS ALLOCATION IS CONDITIONAL. IF "S" IS CODED AND THE LV   *
.*       PARAMETER IS CODED, THE REQUEST FOR THE AREA OF THE SPECIFIED*
.*       LENGTH IS UNCONDITIONAL.                                     *
.*                                                                    *
.*       THE ALLOCATION OF THE SPACE CONTROL AREA IS ALWAYS AN        *
.*       UNCONDITIONAL REQUEST (I.E. AN UNCONDITIONAL GETMAIN IS      *
.*       USED).                                                       *
.*                                                                    *
.*       IF THE S PARAMETER IS CODED, IT MAY DESIGNATE EITHER A GPR OR*
.*       A MAIN STORAGE LOCATION; THE CONVENTION USED IS THAT         *
.*       SURROUNDING THE OPERAND WITH PARENTHESES DESIGNATES A GPR    *
.*       THAT CONTAINS THE ADDRESS OF THE SPACE CONTROL AREA.         *
.*       IF "S" OR "SC" IS CODED AND THE S PARAMETER IS CODED, THE    *
.*       ADDRESS OF THE NEW SPACE CONTROL AREA IS STORED INTO THE     *
.*       DESIGNATED GPR OR MAIN STORAGE LOCATION.                     *
.*                                                                    *
.*--------------------------------------------------------------------*
.* LV    LV SPECIFIES THE LENGTH OF THE AREA TO BE ALLOCATED.         *
.*       THERE ARE FOUR BASIC WAYS TO CODE THE LV PARAMETER:          *
.* CASE  CODE FORM       MEANING                                      *
.* ----  ---- ----       -------                                      *
.*  0.   LV=NUMBER       NUMBER IS A DECIMAL NUMBER GIVING THE NUMBER *
.*                       OF BYTES TO BE RELEASED, OR IS AN ABSOLUTE   *
.*                       EXPRESSION, NOT SURROUNDED BY PARENTHESES,   *
.*                       THAT DETERMINES THE NUMBER OF BYTES TO BE    *
.*                       RELEASED.                                    *
.*  1.   LV=(GPR)        GPR IS AN ABSOLUTE EXPRESSION HAVING A VALUE *
.*                       FROM 1 TO 15, AND IS THE REGISTER CONTAINING *
.*                       THE NUMBER OF BYTES TO BE RELEASED.          *
.*  2.   LV=(ADDRESS,NUMBER)   ADDRESS IS THE MAIN STORAGE ADDRESS OF *
.*                       EITHER A 1-BYTE OR A HALFWORD FIELD THAT     *
.*                       CONTAINS THE LENGTH OF THE AREA.             *
.*                       LENGTH IS A 1 OR A 2, TO DETERMINE A 1-BYTE  *
.*                       OR HALFWORD FIELD RESPECTIVELY.              *
.*    IF LV=(ADDRESS,) IS CODED, THE LENGTH FIELD IS AN IMPLIED 1-BYTE*
.*                     FIELD.                                         *
.*  3.   LV=((ADR),LENGTH)     THIS CASE IS ESSENTIALLY THE SAME AS   *
.*                       THE PRECEDING CASE, EXCEPT THAT THE ADDRESS  *
.*                       OF THE LENGTH FIELD IS IN THE SPECIFIED GPR  *
.*                       ADR.                                         *
.*--------------------------------------------------------------------*
.* THE LENGTH VALUE AND SUBPOOL ARE PLACED IN REGISTER ZERO, AND THEN *
.* THE APPROPRIATE ROUTINE IN THE MODULE IGARPT01 IS CALLED.          *
         GBLC  &IGADDR   THE LOCATION CONTAINING THE ADDRESS OF THE
.*                       MODULE IGARPT01.
         GBLC  &IGATCB   THE ADDTREE OF THE TCBRPT WORD.
         GBLC  &IGAGSP   BRANCH ENTRY OFFSET FOR VARIABLE LENGTH       *
                         ENTRIES WHEN THE SPACE CONTROL ADDRESS IS NOT *
                         CODED.
         GBLC  &IGAGS8,&IGAGS12,&IGAGS80  THESE ARE THE ENTRY POINTS TO*
                         ALLOCATE AN AREA OF 8, 12, OR 80 BYTES        *
                         RESPECTIVELY USING THE FIXEDHDR IN AN SPCA.
         GBLC  &IGAGSPF  BRANCH ENTRY OFFSET FOR FIXED LENGTH ENTRIES  *
                         USING A FIXEDHDR FROM THE GSPACE MACRO OR FROM*
                         INSIDE THE MODULE IGARPT01.
         GBLC  &IGAGSPS  BRANCH ENTRY OFFSET FOR VARIABLE LENGTH SPACE *
                         ALLOCATION WHEN THE SPACE CONTROL ADDRESS IS  *
                         CODED IN THE GSPACE MACRO.
         GBLC  &IGASPZ   THE SIZE OF THE SPACE CONTROL AREA.
         GBLC  &IGAISP   BRANCH ENTRY OFFSET FOR THE SPACE CONTROL     *
                         INITIALIZATION ROUTINE IN IGARPT01.
         GBLB  &IGALONE  ON FOR UNIT TEST THE PROGRAM ON A STANDALONE  *
                         BASIS.
         LCLC  &C        JUST A TEMPORARY CHARACTER VECTOR.
         LCLA  &Z        A TEMPORARY ARITHMETIC VARIABLE.
         LCLC  &O,&LKR
&O       SETC  '0'
&LKR     SETC  '14'
.*A000000                                                        Y02147
.**********************************************************************
         AIF   (('&R' EQ 'S')OR('&R' EQ 'SC')).SPACE SEE IF THE SPACE  *
               CONTROL AREA IS TO BE SET UP BEFORE SATISFYING THE      *
               REQUEST.
      RPTDSECT T=SPACE,DS=N  GET THE GLOBALS WITHOUT THE DSECT.
         AIF   (K'&TAG EQ 0).LJW0
&TAG     EQU   *
.LJW0    ANOP
         AIF   (('&R' EQ 'RF')OR('&R' EQ 'RCF')).FIXED  SEE IF THE     *
                         REQUEST FORM IS FOR AN AREA FROM A FIXED      *
                         LENGTH FREE SPACE CHAIN.
.**********************************************************************
.*       PUT THE LENGTH VALUE IN R0.                                  *
.**********************************************************************
         AIF   (K'&LV NE 0).LVHERE  SEE IF THE LV IS CODED.
         MNOTE 12,'MISSING LENGTH VALUE, LV= MUST BE CODED.'
         AGO   .CHKA           GO CHECK THE ADDRESS.
.LVHERE  AIF   ('&LV'(1,1) EQ '(').LV234  GO IF CASE 2, 3, OR 4.
         AIF   (NOT((K'&SP EQ 0)OR('&SP' EQ '0'))).SESPIL0             *
                         SEE IF THE SUBPOOL IS SUBPOOL ZERO.
         LA    0,&LV     LV
         AGO   .CHKA     GO CHECK THE ADDRESS.
.SESPIL0 AIF   ('&SP'(1,1) EQ '(').SESPIL1  SEE IF THE SUBPOOL         *
                         PARAMETER IS IN A REGISTER, AND GO IF IT IS.
         L     0,=AL1(&SP,&LV/X'10000',(&LV-X'10000'*(&LV/X'10000'))/X'*
               100',&LV-X'100'*(&LV/X'100'))  LOAD THE SUBPOOL NUMBER  *
               AND LENGTH VALUE IN THE REGISTER.
         AGO   .CHKA
.SESPIL1 LA    14,&LV    LENGTH VALUE.
         AIF   ('&SP' EQ '(0)').ERGIJ  SEE IF THE SUBPOOL IS ALREADY   *
                         IN REGISTER ZERO.
         LR    0,&SP(1)  SUBPOOL NUMBER.
.ERGIJ   SLL   0,24      PUT THE SUBPOOL IN BYTE 0 OF GPR 0.
         ALR   0,14      ADD IN THE LENGTH VALUE.
         AGO   .CHKA
.LV234   AIF   (N'&LV EQ 1).LV2  SEE IF LV=(GPR) IS CODED.
         AIF   ('&LV'(2,1) EQ '(').LV4  SEE IF LV=((ADR),LNG) IS CODED.
         AIF   (K'&LV(2) EQ 0).LV3A    SEE IF LV=(ADR,) IS CODED.
.**********************************************************************
.*       LV=(ADR,LNG) IS CODED.
.**********************************************************************
         AIF   ('&LV(2)' EQ '1').LV3A  SEE IF LV=(ADR,1) IS CODED.
         AIF   ('&LV(2)' EQ '2').LV3B  SEE IF LV=(ADR,2) IS CODED.
         AIF   ('&LV(2)' EQ '4').LV3D  SEE IF "LV=(ADR,4)" IS CODED.
         MNOTE 12,'LV CODED WRONG, 1 OR 2 ONLY ALLOWED FOR LV LENGTH.'
         AGO   .CHKA           GO CHECK THE ADDRESS.
.**********************************************************************
.*  THE LENGTH OF THE LENGTH VALUE IS ONE.  .*
.**********************************************************************
.LV3A    AIF   ((K'&SP NE 0)AND('&SP' NE '0')).SESPIL2  GO IF THE      *
                         SUBPOOL IS NOT SUBPOOL ZERO.
         SLR   0,0       GET THE LENGTH VALUE.
.LV3AA   ANOP
         IC    0,&LV(1)  FOR THE AREA TO BE RELEASED.
         AGO   .CHKA     GO CHECK THE ADDRESS.
.SESPIL2 AIF   ('&SP'(1,1) EQ '(').SESPIL3  GO IF SP IS IN GPR.
         LA    0,&SP     SUBPOOL #.
         SLL   0,24      PUT IT IN BYTE 0 OF GPR 0.
         AGO   .LV3AA    GO PUT IN THE LENGTH VALUE.
.SESPIL3 AIF   ('&SP' EQ '(0)').LV3AAAA
         LR    0,&SP(1)  SUBPOOL #.
.LV3AAAA SLL   0,24      PUT THE SUBPOOL IN BYTE 0 OF GPR 0.
         AGO   .LV3AA
.LV3B    AIF   ((K'&SP NE 0)AND('&SP' NE '0')).SESPIL4                 *
                         SEE IF THE SUBPOOL IS ZERO, AND GO IF IT ISN'T.

         LH    0,&LV(1)  GET THE LENGTH VALUE.
         AGO   .CHKA     GO CHECK THE ADDRESS.
.SESPIL4 AIF   ('&SP' EQ '(0)').SESPIL5  SEE IF IT IS IN GPR 0.
         AIF   ('&SP'(1,1) EQ '(').SESPIL6  SEE IF IT IS IN A GPR.
         LA    0,&SP     SUBPOOL #.
         AGO   .SESPIL5  GO GENERATE THE SHIFT INSTRUCTION.
.SESPIL6 LR    0,&SP(1)  SUBPOOL #.
.SESPIL5 SLL   0,24      PUT THE SUBPOOL # IN BYTE 0 OF GPR 0.
         AH    0,&LV(1)  ADD IN THE LENGTH VALUE.
         AGO   .CHKA
.LV3D    ANOP
         AIF   ((K'&SP NE 0)AND('&SP' NE '0')).LV3DNZ  SEE IF THE      *
                         SUBPOOL IS SUBPOOL ZERO.
         L     0,&LV(1)                        SUBPOOL AND LV.
         AGO   .CHKA
.LV3DNZ  AIF   ('&SP'(1,1) EQ '(').LV3DSPR  SEE IF THE SUBPOOL NUMBER  *
                         IS IN A REGISTER.
         LA    0,&SP                           SUBPOOL #.
         SLL   0,24
         AL    0,&LV(1)                        LV.
         AGO   .CHKA
.LV3DSPR LR    0,&SP(1)                        SP #.
         SLL   0,24
         AL    0,&LV(1)                        LV.
         AGO   .CHKA
.**********************************************************************
.*  LV=((ADR),LNG) IS CODED.  .*
.**********************************************************************
.LV4     AIF   (K'&LV(2) EQ 0).LV4A  SEE IF LV=((ADR),) IS CODED.
         AIF   ('&LV(2)' EQ '1').LV4A  SEE IF LV=((ADR),1) IS CODED.
         AIF   ('&LV(2)' EQ '2').LV4B  SEE IF LV=((ADR),2) IS CODED.
         AIF   ('&LV(2)' EQ '4').LV4D  SEE IF "LV=((ADR),4)" IS CODED.
.**********************************************************************
.*   LV=((ADR),EXPRESSION) IS CODED.  .*
.**********************************************************************
         MNOTE 12,'INVALID LENGTH OF LV OPERAND, LV=&LV.'
         AGO   .CHKA     GO CHECK THE ADDRESS.
.LV4A    AIF   ((K'&SP NE 0)AND('&SP' NE '0')).SESPIL7  GO IF SP^0.
         SLR   0,0       LV=((ADR),1)
.LV4AA   ANOP
         IC    0,0&LV(1)  GET THE LENGTH OF AREA.
         AGO   .CHKA     GO CHECK THE ADDRESS.
.SESPIL7 AIF   ('&SP'(1,1) EQ '(').SESPIL8  GO IF SP IS IN A GPR.
         LA    0,&SP     SUBPOOL #.
.BEGRUDG SLL   0,24      PUT THE SUBPOOL # IN BYTE 0 OF GPR0.
         AGO   .LV4AA
.SESPIL8 AIF   ('&SP' EQ '(0)').BEGRUDG  SEE IF THE SP# IS IN GPR 0.
         LR    0,&SP(1)  LOAD SUBPOOL # INTO GPR ZERO.
         AGO   .BEGRUDG  GO SHIFT IT OVER INTO BYTE 0.
.LV4B    AIF   ((K'&SP NE 0)AND('&SP' NE '0')).SESPIL9  GO IF SP# IS ^0
         LH    0,0&LV(1) LV=((ADR),1)
         AGO   .CHKA     GO CHECK THE ADDRESS.
.SESPIL9 AIF   ('&SP'(1,1) EQ '(').SESPILA  GO IF SP# IS IN A GPR.
         LA    0,&SP     SUBPOOL #.
         AGO   .SESPILB  GO SHIFT IT OVER INTO BYTE ZERO.
.SESPILA AIF   ('&SP' EQ '(0)').SESPILB  GO IF SP# IS ALREADY IN GPR 0.
         LR    0,&SP(1)  SUBPOOL #.
.SESPILB SLL   0,24      SHIFT IT OVER INTO BYTE ZERO.
         AH    0,0&LV(1) ADD IN THE LENGTH VALUE.
         AGO   .CHKA
.LV4D    ANOP
         AIF   ((K'&SP NE 0)AND('&SP' NE '0')).LV4DNZ  SEE IF THE      *
                         SUBPOOL IS SUBPOOL ZERO.
         L     0,0&LV(1)                        SUBPOOL AND LV.
         AGO   .CHKA
.LV4DNZ  AIF   ('&SP'(1,1) EQ '(').LV4DSPR  SEE IF THE SUBPOOL NUMBER  *
                         IS IN A REGISTER.
         LA    0,&SP                           SP #.
         SLL   0,24
         AL    0,0&LV(1)                        LV.
         AGO   .CHKA
.LV4DSPR LR    0,&SP(1)                        SP #.
         SLL   0,24
         AL    0,0&LV(1)                        LV.
         AGO   .CHKA
.LV2     AIF        (('&LV' EQ '(0)')AND((K'&SP EQ 0)OR('&SP' EQ '0')OR*
               ('&SP' EQ '(0)'))).CHKA  GO IF THE SUBPOOL # AND LENGTH
.*             VALUE ARE ALREADY IN REGISTER 0. THIS MEANS "LV=(0)"   *
.*             IS CODED AND THE SUBPOOL DOESN'T HAVE TO BE FILLED IN. *
         AIF   (K'&SP NE 0).SESPILC  GO IF THE SUBPOOL # IS CODED.
         LR    0,&LV(1)  LV.
         AGO   .CHKA     GO CHECK THE ADDRESS.
.SESPILC AIF   ('&SP'(1,1) EQ '(').SESPILD  GO IF THE SP# IS IN A GPR.
         AIF   ('&LV' EQ '(0)').SESPILE  GO IF THE LENGTH IS IN R0.
         AL    0,&SP     SUBPOOL #.
         SLL   0,24      PUT THE SUBPOOL NUMBER IN BYTE 0.
         ALR   0,&LV(1)  ADD   IN THE LENGTH VALUE.
         AGO   .CHKA
.SESPILD AIF   ('&SP' EQ '(0)').SESPILF  GO IF SP# IS IN GPR 0.
         LR    0,&SP(1)  SUBPOOL#.
         AIF   ('&SP' EQ '&LV').CHKA  SEE IF THE SUBPOOL NUMBER AND THE*
                         LENGTH VALUE ARE IN THE SAME REGISTER.
.SESPILF SLL   0,24      PUT SP# IN BYTE 0 OF GPR ZERO.
         ALR   0,&LV(1)  ADD   IN THE LENGTH VALUE.
         AGO   .CHKA
.SESPILE AL    0,=AL1(&SP,X'00',B'0',0)  ADD IN THE SUBPOOL #.
.CHKA    ANOP
.*--------------------------------------------------------------------*
.* THE LENGTH VALUE AND SUBPOOL ARE IN REGISTER ZERO, NOW LINK TO THE *
.* MODULE IGARPT01.                                                   *
.*--------------------------------------------------------------------*
         AIF   (K'&S EQ 0).LINKGEN  SEE IF THE SPACE ADDRESS IS CODED.
         AIF   ('&S'(1,1) EQ '(').LINKGPR  SEE IF THE SPACE ADDRESS IS *
                         IN A GENERAL PURPOSE REGISTER.
         L     1,&S      SPACE CONTROL WORD.
         AGO   .LINKREG  GO LINK TO THE VARIABLE LENGTH GSPACE ROUTINE *
                         IN IGARPT01.
.LINKGPR AIF   ('&S' EQ '(1)').LINKREG  SEE IF IT IS IN R1 ALREADY.
         LR    1,&S(1)                                     SPCA.
.LINKREG L     15,&IGADDR.(,1)  ADDRESS OF IGARPT01.
         AIF   (K'&R EQ 0).LINKSR0  SEE IF THE R PARAMETER WAS OMITTED.
         AIF   ('&R' EQ 'R').LINKSU  GO IF IT IS AN UNCONDITIONAL      *
                         GSPACE.
         AIF   ('&R' EQ 'RC').LINKSC  GO IF IT IS A CONDITIONAL GSPACE *
                         REQUEST.
         MNOTE 12,'INVALID CONDITIONAL/UNCONDITIONAL SPECIFICATION.'
.LINKSU  LA    &LKR,&IGAGSPS.(,15)  GSPACE ENTRY POINT ADDRESS.
         BALR  &LKR,&LKR  INDICATE UNCONDITIONAL GSPACE.
         AGO   .FIN      ALL DONE WITH THE GSPACE, NOW EXIT.
.LINKSR0 MNOTE 0,'UNCONDITIONAL GSPACE ASSUMED.'
         AGO   .LINKSU   GO LINK TO THE GSPACE UNCONDITIONALLY.
.LINKSC  ANOP
         BAL   &LKR,&IGAGSPS.(,15)  INDICATE CONDITIONAL GSPACE.
         AGO   .FIN      ALL DONE, NOW EXIT.
.LINKGEN ANOP
      RPTDSECT GEN=(CVTRPT,15)  GET THE ADDRESS OF THE MODULE IGARPT01 *
                         IN REGISTER 15.
.LINKTO  ANOP
         AIF   (K'&R EQ 0).LINKR0  SEE IF THE R PARAMETER IS NOT CODED.
         AIF   ('&R' EQ 'RC').LINKC  SEE IF IT IS CODED AS A           *
                         CONDITIONAL GSPACE REQUEST.
         AIF   ('&R' EQ 'R').LINKU  SEE IF IT IS CODED AS AN           *
                         UNCONDITIONAL GSPACE REQUEST.
         MNOTE 12,'INVALID REQUEST MODE, UNCONDITIONAL ASSUMED.'
.LINKU   LA    &LKR,&IGAGSP.(,15)
         BALR  &LKR,&LKR  INDICATE UNCONDITIONAL GSPACE.
         AGO   .FIN      ALL DONE, NOW EXIT FROM THE GSPACE            *
                         MACRO-INSTRUCTION.
.LINKR0  MNOTE 0,'UNCONDITIONAL GSPACE ASSUMED.'
         AGO   .LINKU    GO TO THE UNCONDITIONAL LINKAGE.
.LINKC   BAL   &LKR,&IGAGSP.(,15)  INDICATE CONDITIONAL GSPACE.
         AGO   .FIN      ALL DONE NOW, EXIT.
.**********************************************************************
.* COME HERE TO SET UP A SPACE CONTROL AREA.                          *
.**********************************************************************
.SPACE   ANOP
.CHECKS  ANOP
      RPTDSECT T=SPACE,DS=NO
         AIF   (&IGALONE).LOAD  SEE IF THE MODULE MUST BE LOADED VIA   *
                         THE LOAD MACRO-INSTRUCTION.
         AIF   (K'&TAG EQ 0).NOTAG  SEE IF THERE IS A LABEL.
&TAG     EQU   *
.NOTAG   ANOP
      RPTDSECT GEN=(CVTRPT,(15))  GET THE ADDRESS OF IGARPT01.
         AGO   .MERGE    MERGE WITH THE COMMON PATH.
.LOAD    ANOP
&TAG     LOAD  EP=IGARPT01  LOAD THE MODULE.
         LR    14,0      GET THE ADDRESS OF THE MODULE IGARPT01 IN THE *
                         REGISTER.
.MERGE   AIF   (K'&SP EQ 0).SPZERO  SEE IF THE SUBPOOL IS ZERO BY VIRTUE
               OF NOT EVEN BEING CODED FOR THE ISPACE MACRO.
         AIF   ('&SP' EQ '0').SPZERO  SEE IF THERE IS NO OTHER SUBPOOL *
                         SPECIFIED FOR THE SPACE CONTROL AREA.
         AIF   (K'&LV NE 0).LONGSPC  SEE IF THE LENGTH VALUE IS CODED.
         L     0,=AL1(&SP,0,(&IGASPZ/X'100'),(&IGASPZ-X'100'*(&IGASPZ/X*
               '100')))  SPCA SP AND LV.
         AGO   .LINK     GO LINK TO THE SUBROUTINE.
.LONGSPC AIF   ('&LV'(1,1) EQ '(').LONGPR  SEE IF IT IS IN A GPR.
         L     0,=AL1(&SP,0,(&LV/X'100'),(&LV-X'100'*(&LV/X'100')))
         AGO   .LINK     GO LINK TO &IGAISP.
.LONGPR  LR    0,&LV(1)                LENGTH VALUE FOR THE SPCA.
         AL    0,=AL1(&SP,0,0,0)                 SUBPOOL #.
         AGO   .LINK
.SPZERO  AIF   (K'&LV NE 0).LENGTH  SEE IF THE LENGTH VALUE IS CODED.
         LA    0,&IGASPZ                         LENGTH FOR THE SPCA.
         AGO   .LINK     GO LINK TO &IGAISP.
.LENGTH  AIF   ('&LV'(1,1) EQ '(').GPRLONG  SEE IF THE LENGTH IS IN A  *
                         REGISTER.
         LA    0,&LV                   GET THE LENGTH FOR THE SPCA.
         AGO   .LINK
.GPRLONG LR    0,&LV(1)        LENGTH FOR THE SPCA.
.LINK    ANOP
*---------------------------------------------------------------------*
.LINKBAL BAL   14,&IGAISP.(,14)  LINK TO &IGAISP IN IGARPT01.
         AIF   (K'&S EQ 0).FINSCTL  SEE IF REGISTER 1 SHOULD HAVE THE  *
                         ADDRESS IN IT.
.SNOTMT  AIF   ('&S'(1,1) EQ '(').GPR  SEE IF THE SPACE WORD IS TO BE  *
                         LEFT IN A GPR.
         ST    1,&S      STORE THE ADDRESS OF THE SPACE CONTROL AREA.
         AGO   .FIN
.GPR     AIF   ('&S' EQ '(1)').FINSCTL SEE IF THE ADDRESS IS ALREADY IN*
                         THE RIGHT REGISTER.
         LR    &S(1),1   TRANSFER THE SPACE CONTROL ADDRESS TO THE     *
                         OTHER REGISTER.
.FINSCTL ANOP
.END     ANOP
         AGO   .FIN
.**********************************************************************
.* COME HERE TO ALLOCATE AN AREA OF 8, 12, OR 80 BYTES USING THE      *
.* FIXEDHDR IN A SPACE CONTROL AREA.                                  *
.**********************************************************************
.FIXED   ANOP
         AIF   ((K'&S NE 0)AND(K'&LV NE 0)).FIXEDOK  SEE IF ALL THE    *
                         NECESSARY PARAMETERS ARE CODED.
         AIF   (K'&S NE 0).FXSOK  SEE IF THE S PARAMETER IS MISSING.
         MNOTE 12,'THE S PARAMETER MUST BE CODED FOR FSPACE RF,...'
.FXSOK   ANOP
         AIF   (K'&LV NE 0).FXLVOK  SEE IF THE LENGTH VALUE PARAMETER  *
                         IS MISSING.
         MNOTE 12,'LENGTH VALUE IS MISSING -- LV PARAMETER.'
.FXLVOK  ANOP
         AGO   .FIN   EXIT BECAUSE THE IS NO HOPE OF CORRECT EXECUTION.
.**********************************************************************
.* CHECK THE LENGTH VALUE TO SEE IF IT IS 8, 12, OR 80.               *
.**********************************************************************
.FIXEDOK ANOP
         AIF   (('&LV' EQ '8')OR('&LV' EQ '12')OR('&LV' EQ '80')OR('&LV*
               ' EQ 'X''8''')OR('&LV' EQ 'X''C''')OR('&LV' EQ 'X''50'''*
               )).FXLOK
         MNOTE 12,'THE LENGTH VALUE MUST BE 8, 12, OR 80 TO USE THE RF *
               FORM OF GSPACE.'
         AGO   .FIN
.FXLOK   ANOP
.**********************************************************************
.* GET THE ADDRESS OF THE SPCA IN REGISTER 1, AND GET THE ADDRESS OF  *
.* THE MODULE IGARPT01 IN REGISTER 14 FOR THE LINKAGE.                *
.**********************************************************************
         AIF   ('&S'(1,1) EQ '(').FXSGPR  SEE IF THE SPACE CONTROL     *
                         ADDRESS IS IN A GENERAL REGISTER.
         L     1,&S      SPCA ADDRESS.
         AGO   .FXGOTS   MERGE WITH THE COMMON PATH.
.FXSGPR  AIF   ('&S' EQ '(1)').FXGOTS  SEE IF IT IS ALREADY IN THE     *
                         RIGHT REGISTER.
         LR    1,&S(1)   THE ADDRESS OF THE SPCA.
.FXGOTS  ANOP
         L     14,&IGADDR.(,1)  ADDRESS OF IGARPT01.
.**********************************************************************
.* NOW CHECK THE LENGTH VALUE TO SEE WHICH ONE OF THE LENGTHS IS      *
.* INVOLVED; 8, 12, OR 80.                                            *
.**********************************************************************
         AIF   (('&LV' EQ '8')OR('&LV' EQ 'X''8''')).FXLV8  SEE IF IT  *
                         IS 8 BYTES.
         AIF   (('&LV' EQ '80')OR('&LV' EQ 'X''50''')).FXLV80          *
                         SEE IF IT IS AN 80-BYTE AREA.
         AIF   ('&R' EQ 'RCF').FXL12C  SEE IF IT IS A CONDITIONAL      *
                         REQUEST.
         LA    14,&IGAGS12.(,14)  GET THE ENTRY POINT ADDRESS.
         BALR  14,14     INDICATE UNCONDITIONAL GSPACE.
         AGO   .FIN      ALL DONE, NOW EXIT FROM THE GSPACE            *
                         MACRO-INSTRUCTION.
.FXL12C  BAL   14,&IGAGS12.(,14)  LINK TO ALLOCATE THE 12-BYTE AREA.
         AGO   .FIN      ALL DONE NOW, EXIT.
.FXLV8   AIF   ('&R' EQ 'RCF').FXL8C  SEE IF IT IS A CONDITIONAL       *
                         REQUEST.
         LA    14,&IGAGS8.(,14)  GET THE ENTRY POINT ADDRESS.
         BALR  14,14     INDICATE UNCONDITIONAL GSPACE.
         AGO   .FIN      ALL DONE, NOW EXIT.
.FXL8C   BAL   14,&IGAGS8.(,14)  LINK TO ALLOCATE THE 8-BYTE AREA.
         AGO   .FIN
.FXLV80  AIF   ('&R' EQ 'RCF').FXL80C  SEE IF THE REQUEST IS A         *
                         CONDITIONAL REQUEST.
         LA    14,&IGAGS80.(,14)  GET THE ENTRY ADDRESS FOR AN         *
                         UNCONDITIONAL REQUEST.
         BALR  14,14     INDICATE UNCONDITIONAL REQUEST.
         AGO   .FIN      ALL DONE, NOW EXIT.
.FXL80C  BAL   14,&IGAGS80.(,14)  LINK TO ALLOCATE THE 80-BYTE AREA.
         AGO   .FIN
.FIN     ANOP
         MEND
         EJECT
         MACRO
&TAG     INS   &TREE,&A=,&R=,&#=,&T=,&C=,&SP=,&S=,&INSARG=,&MOVE=,     *
               &RECL=,&TYPE=
.**********************************************************************
.* THE INS MACRO-INSTRUCTION ASSOCIATES A KEY WITH A RECORD ADDRESS BY*
.* CHANGING THE RADIX PARTITION TREE OF ASSOCIATIONS.                 *
.*                                                                    *
.* THE ADDRESS USED IS OBTAINED IN EITHER ONE OF TWO WAYS:            *
.*                                                                    *
.* 0:    IF THE A-PARAMETER IS CODED AND THE R-PARAMETER IS NOT CODED,*
.*       THE ADDRESS IS AS SPECIFIED BY THE A-PARAMETER.              *
.*                                                                    *
.* 1:    IF BOTH THE A AND R PARAMETERS ARE CODED, SPACE IS ALLOCATED *
.*       FOR THE RECORD VIA THE GSPACE MACRO-INSTRUCTION, THE RECORD  *
.*       IS MOVED TO THE AREA ALLOCATED, AND THE ADDRESS OF THE       *
.*       ALLOCATED AREA IS USED. BY CODING THE R-PARAMETER THE RECORD *
.*       IS DEFINED SO IT CAN BE COLLECTED AT THE ALLOCATED AREA.     *
.*       IN EITHER CASE, AFTER THE INS MACRO HAS BEEN SUCCESSFULLY    *
.*       EXECUTED THE ADDRESS USED FOR THE ASSOCIATION IS RETURNED IN *
.*       REGISTER 15 AS THE RETURN CODE. IF THE INSERT IS NOT         *
.*       SUCCESSFUL FOR SOME REASON, THE RETURN CODE IN REGISTER 15 IS*
.*       NEGATIVE.                                                    *
.*                                                                    *
.* THE DESCRIPTIONS OF THE PARAMETERS FOR THE INS MACRO ARE AS        *
.* FOLLOWS:                                                           *
.*                                                                    *
.* TREE: THIS SPECIFIES THE ADDRESS OF THE RADIX PARTITION TREE USED  *
.*       TO STORE THE KEY-ADDRESS ASSOCIATIONS. IT MAY BE CODED TO    *
.*       SPECIFY EITHER A MAIN STORAGE LOCATION CONTAINING THE ADDRESS*
.*       OF THE RPT OR IN PARENTHESES TO INDICATE A GENERAL REGISTER  *
.*       CONTAINING THE ADDRESS OF THE RPT. IF "(1)" IS CODED, NO LOAD*
.*       REGISTER INSTRUCTION IS GENERATED BY THE INS MACRO, AS THE   *
.*       ADDRESS IS ALREADY IN THE APPROPRIATE PARAMETER LIST         *
.*       REGISTER.                                                    *
.*       THE TREE PARAMETER MAY BE OMITTED, IN WHICH CASE THE ADDRESS *
.*       OF THE RPT IS ASSUMED IN GPR 1.                              *
.*                                                                    *
.* A:    THE A-PARAMETER SPECIFIES THE ADDRESS OF THE RECORD          *
.*       CONTAINING THE KEY TO BE USED FOR THE ASSOCIATION. THE RECORD*
.*       ADDRESS MAY BE EITHER A MAIN STORAGE LOCATION OR MAY BE IN A *
.*       REGISTER, INDICATED BY ENCLOSING THE REGISTER NAME OR # IN   *
.*       PARENTHESES. FOR EXAMPLE, IF "A=LABEL" IS CODED, "LABEL" IS  *
.*       TAKEN AS THE SYMBOLIC NAME OF THE MAIN STORAGE LOCATION      *
.*       CONTAINING THE RECORD. THE A PARAMETER MAY BE USED IN        *
.*       CONJUNCTION WITH THE R PARAMETER TO SPECIFY A SCATTERED      *
.*       RECORD TO BE COLLECTED INTO A SPACE PROVIDED VIA THE GSPACE  *
.*       MACRO-INSTRUCTION.                                           *
.*                                                                    *
.* R:    THE R-PARAMETER IS USED TO SPECIFY THE RECORD WHEN IT IS     *
.*       DESIRED THAT THE INS MACRO ALLOCATE AN AREA TO HOLD THE      *
.*       RECORD VIA THE GSPACE MACRO AND MOVE THE RECORD TO THE AREA  *
.*       ALLOCATED BEFORE INSERTING THE ASSOCIATION IN THE RPT.       *
.*       THERE ARE TWO MODES FOR CODING THE R PARAMETER; THE FIRST WAY*
.*       IS IN CONJUNCTION WITH THE A PARAMETER, AND THE SECOND IS    *
.*       WITHOUT CODING THE A PARAMETER. IF BOTH THE A AND R          *
.*       PARAMETERS ARE CODED, THEN THE A PARAMETER PROVIDES THE      *
.*       ADDRESS OF A BASE AREA FROM WHICH TO COLLECT THE RECORD, AND *
.*       THE R-PARAMETER SPECIFIES THE RECORD IN THE BASE AREA BY     *
.*       PAIRS OF DISPLACEMENTS AND LENGTHS, ENCLOSED IN PARENTHESES. *
.*       THE DISPLACEMENT-LENGTH PAIRS ARE CODED AS ((D,L),(D,L),...  *
.*       ,(D,L)), WHERE EACH DISPLACEMENT AND LENGTH IS ENCLOSED IN   *
.*       PARENTHESES, AND THE ORDER THE PAIRS APPEAR IN THE LIST IS   *
.*       THE ORDER IN WHICH THE RECORD IS COLLECTED.                  *
.*       EACH DISPLACEMENT AND LENGTH MUST BE A SELF-DEFINING DECIMAL *
.*       NUMBER.                                                      *
.*       FOR EXAMPLE, CODING "A=(8),R=((10,3),(6,9))" CAUSES THE      *
.*       RECORD TO BE COLLECTED FROM THE TWO FIELDS AT OFFSETS 10 AND *
.*       6 RESPECTIVELY FROM THE BASE ADDRESS IN GPR 8. NOTE THAT NO  *
.*       CHECK IS MADE FOR OVERLAPPING FIELDS.                        *
.*       IF THERE IS ONLY ONE DISPLACEMENT-LENGTH PAIR, IT MAY BE     *
.*       CODED WITH ONLY ONE SET OF ENCLOSING PARENTHESES INSTEAD OF  *
.*       TWO.                                                         *
.*                                                                    *
.*       IF THE R PARAMETER IS CODED AND THE A PARAMETER IS NOT CODED,*
.*       THE ELEMENTS IN THE LIST FOR THE R PARAMETER MAY BE CODED AS *
.*       ADDRESS-LENGTH PAIRS. IN THIS CASE, EACH ADDRESS MAY EITHER  *
.*       BE A MAIN STORAGE LOCATION, OR IN A REGISTER. EACH ADDRESS   *
.*       MUST BE A RELOCATABLE EXPRESSION IF IT NOT IN A REGISTER.    *
.*       INSTEAD OF THE ADDRESS-LENGTH PAIR, A LABEL MAY BE CODED, AS *
.*       LONG AS THE LABEL HAS A LENGTH ATTRIBUTE THAT CAN BE USED TO *
.*       OBTAIN THE LENGTH OF THE CORRESPONDING FIELD.                *
.*                                                                    *
.* T:    THE T-PARAMETER IS USED TO SPECIFY THE RADIX PARTITION TREE  *
.*       TYPE FOR THE INSERTION. THE T-PARAMETER MUST BE CODED AS A   *
.*       SINGLE SELF-DEFINING DECMIAL NUMBER WITHOUT LEADING ZEROS.   *
.*       IF THE T-PARAMETER IS NOT CODED, THE TYPE WILL BE OBTAINED   *
.*       FROM THE GLOBAL VARIABLE &IGATYPE (IF IT IS A VALID RPT      *
.*       TYPE). IF IT IS NOT A VALID TREE TYPE, A TYPE 8 IS SUPPLIED, *
.*       AND THE GLOBAL VARIABLE &IGATYPE IS SET TO 8.                *
.*                                                                    *
.*       THE PARAMETERS INSARG, MOVE, RECL, AND TYPE SHOULD NOT BE    *
.*       USED, AS THEY ARE ONLY PRESENT FOR COMPATIBILITY WITH EARLIER*
.*       VERSIONS OF THE INSERT MACRO.                                *
         GBLC  &IGABLST  THE OFFSET INTO THE TREE HEADER FOR THE LIST  *
                         OF RPT ENTRY POINTS.
         GBLC  &IGAINS
         GBLC  &IGARPT#  THE RADIX PARTITION TREE TYPE FROM EITHER THE *
                         T OR TYPE PARAMETER.
         GBLA  &IGARECL  THE LENGTH OF THE RECORD TO BE INSERTED BY THE*
                         INSERT MACRO-INSTRUCTION.
         GBLA  &IGALEFT(256)  LEFT INVERTIBLE SUBTRACTION EDGES FOR THE*
                         BINARY PARSE TREE.
         GBLA  &IGARGHT(256)  RIGHT INVERTIBLE SUBTRACTION EDGES FOR   *
                         THE BINARY PARSE TREE.
         GBLA  &IGAX     PENULTIMATE VERTEX ON PATH TO CURRENT ATOM    *
                         WHEN SCANNING.
         GBLA  &IGAZ     LAST INNER VERTEX ON PATH TO ATOM.
         GBLA  &IGAPATH(16)  PATH VECTOR FOR THE SCANNING OPERATIONS ON*
                         THE PARSE TREE.
         GBLA  &IGALEVL  NUMBER OF NESTED LEVELS OF PARENTHESES FOR    *
                         CURRENT ATOM.
         GBLB  &IGAOKAY  ON IF THE PARSE IN RPTDSECT DID NOT FIND ANY  *
                SYNTAX ERRORS IN THE R PARAMETER LIST.
         LCLA  &I        A LOCAL VARIABLE FOR KEEPING TRACK OF THE     *
                         CURRENT ENTRY BEING SCANNED IN THE R PARAMETER*
                         LIST.
         LCLA  &LNG      THE LENGTH OF THE CURRENT DISPLACEMENT-LENGTH *
                         PAIR.
         LCLA  &TMPA     USED TO REMEMBER &IGAPATH(&IGALEVL-1).
         LCLC  &RC       USED TO SET THE REQUEST MODE FOR THE GSPACE   *
                         MACRO TO CONDIRIONAL OR UNCONDITIONAL.
         LCLC  &X        JUST A LOCAL CHARACTER VECTOR FOR COLLECTING  *
                         OPERANDS.
         LCLB  &REQUEST  ON IF THE GSPACE REQUEST IS A CONDITIONAL     *
                         REQUEST.
         LCLB  &R1SAVED  ON IF REGISTER 1 IS SAVED THROUGH THE GSPACE  *
                         OPERATION.
         LCLB  &FINEQU   ON IF THE EQUATE "FIN&SYSNDX EQU *" MUST BE   *
                         GENERATED AT THE END OF THE MACRO EXECUTION.
         LCLB  &ERROR    THIS BIT IS TURNED ON WHENEVER AN MNOTE OF    *
                         SUFFICIENT SEVERITY IS GENERATED.
         LCLA  &DSP      THIS IS USED FOR COLLECTING THE DISPLACEMENT  *
                         AS A NUMBER.
         LCLC  &FIELD    THIS IS USED TO HOLD THE FIELD OF AN (F,L)    *
                         PAIR WHILE GETTING THE L.
         LCLB  &XFER     ON TO GENERATE THE MOVES WHEN IT IS THE RIGHT *
               ITERATION THROUGH THE LOOP.
.*A000000                                                        Y02147
.**********************************************************************
.* CHECK TO SEE WHETHER ANY OF THE OLD PARAMETERS ARE CODED, AND IF   *
.* THEY ARE THEN MAP THEM TO THE NEW PARAMETERS VIA MACRO RECURSION.  *
.**********************************************************************
.*                                                                    *
         AIF   ((K'&INSARG EQ 0)AND(K'&MOVE EQ 0)AND(K'&RECL EQ 0)).NEW*
                         GO IF NONE OF THE OLD PARAMETERS ARE CODED.
         AIF   (K'&RECL EQ 0).NORECL  SEE IF THE RECORD LENGTH IS NOT  *
                         CODED.
&TAG     INS   &TREE,A=&INSARG,T=&T,TYPE=&TYPE,R=(0,&RECL),C=1
         AGO   .FIN      ALL DONE, NOW EXIT.
.NORECL  ANOP
&TAG     INS   &TREE,A=&INSARG,T=&T,TYPE=&TYPE,C=1
         AGO   .FIN  ALL DONE NOW, EXIT FROM THE INS MACRO-INSTRUCTION.
.**********************************************************************
.* ALL FINISHED WITH COMPATIBILITY PROCESSING WITH THE OLD FORMATS,   *
.* NOW REALLY DO IT.                                                  *
.**********************************************************************
.NEW     ANOP
.**********************************************************************
.* CHECK TO SEE IF THE LABEL FIELD IS CODED AND GENERATE THE          *
.* APPROPRIATE EQUATE IF IT IS.                                       *
.**********************************************************************
         AIF   (K'&TAG EQ 0).NOTAG  GO AROUND THE EQUATE IF THE TAG IS *
                         NOT PRESENT.
&TAG     EQU   *         PROVIDE THE LABEL.
.NOTAG   ANOP
.**********************************************************************
.* CHECK THE TYPE AND T PARAMETERS TO SEE IF A VALID RPT TYPE IS      *
.* SPECIFIED. IF NEITHER IS SPECIFIED, ASSUME IT IS TYPE 8 RPT. THE   *
.* TYPE IS PUT INTO THE GLOBAL VARIABLE &IGARPT# AT THE END OF THE    *
.* TYPE CHECKING SECTION.                                             *
.**********************************************************************
.RPT#    AIF   (K'&T EQ 0).RPT#TMT  SEE IF THE T PARAMETER IS CODED.
         AIF   (K'&TYPE EQ 0).RPT#TCK  USE THE T PARAMETER IF IT IS    *
                         CODED AND THE TYPE PARAMETER IS NOT CODED.
.**********************************************************************
.* BOTH THE T AND TYPE PARAMETERS ARE CODED; SEE IF THEY ARE THE SAME,*
.* AND IF THEY ARE NOT THEN USE T.                                    *
.**********************************************************************
         AIF   ('&T' EQ '&TYPE').RPT#TCK  IF THEY ARE THE SAME THEN USE*
                         T.
         MNOTE 4,'TYPE CONFLICT, ONLY T OR TYPE SHOULD BE CODED.'
.RPT#TCK ANOP
&IGARPT# SETC  '&T'      GET THE RPT TYPE.
         AGO   .RPT#CHK  GO TO CHECK THE VALIDITY OF THE RADIX         *
                         PARTITION TREE TYPE.
.**********************************************************************
.* THE T PARAMETER IS NOT CODED, SEE IF THE TYPE PARAMETER IS CODED.  *
.**********************************************************************
.RPT#TMT AIF   (K'&TYPE EQ 0).RPT#8  IF BOTH ARE LEFT OUT USE TYPE 8   *
                         RPT.
&IGARPT# SETC  '&TYPE'   SET THE TYPE TO THE TYPE THAT IS SPECIFIED BY *
                         THE TYPE PARAMETER.
         AGO   .RPT#CHK  GO CHECK IT FOR VALIDITY.
.RPT#CHK AIF   (('&IGARPT#' EQ '8')OR('&IGARPT#' EQ '5')OR('&IGARPT#' E*
               Q '4')).RPT#FIN
         MNOTE 4,'INVALID RPT TYPE, TYPE 8 ASSUMED.'
.RPT#8   ANOP
&IGARPT# SETC  '8'       SET RPT TYPE TO THE DEFAULT.
.RPT#FIN ANOP
      RPTDSECT T=5,DS=NO
      RPTDSECT T=8,DS=NO
.**********************************************************************
.* INSERT INTO A TYPE 8 RADIX PARTITION TREE. FIRST CHECK TO SEE      *
.* WHETHER THE AREA TO HOLD THE NEW RECORD MUST BE ALLOCATED VIA THE  *
.* GSPACE MACRO-INSTRUCTION. IF THE R-PARAMETER IS CODED THEN THE AREA*
.* MUST BE ALLOCATED. IF THE AREA DOES NOT HAVE TO BE ALLOCATED GO    *
.* DIRECTLY TO .CHKA.                                                 *
.**********************************************************************
         AIF   (K'&R EQ 0).CHKA  SEE IF THERE IS NO RECORD SPECIFIED.
.**********************************************************************
.* CHECK TO SEE WHETHER THE TREE ADDRESS IS IN GPR 1 AND MUST BE      *
.* PRESERVED THROUGH THE GSPACE OPERATION.                            *
.**********************************************************************
         AIF   (K'&TREE EQ 0).TREEMT  GO IF THE TREE PARAMETER IS NOT  *
                         CODED.
         AIF   ('&TREE'(1,1) NE '(').TREEOK  SEE IF IT IS NOT IN A     *
                         REGISTER.
         AIF   ('&TREE' EQ '(1)').TREEMT  SEE IF IT IS SPECIFICALLY    *
                         SPECIFIED IN REGISTER 1.
         AGO   .TREEOK   IT IS APPARENTLY NOT IN REGISTER 1, ASSUME IT *
                         IS OK.
.TREEMT  ST    1,((4*1)+20-64*((2+1)/16))(,13)  SAVE R1.
&R1SAVED SETB  (1)       SET THE BIT ON TO INDICATE R1 WAS STORED      *
                         THROUGH THE GSPACE OPERATION.
.TREEOK  ANOP
.**********************************************************************
.* DETERMINE THE LENGTH OF THE AREA NEEDED FOR THE RECORD BY ADDING UP*
.* ALL THE INDIVIDUAL LENGTHS IN THE DISPLACEMENT-LENGTH PAIRS IN THE *
.* R-PARAMETER.                                                       *
.**********************************************************************
.* THE R PARAMETER HAS BEEN CHECKED AT THIS POINT, AND IS NOT THE     *
.* EMPTY STRING.                                                      *
.* THE FOLLOWING LOOP IS DONE TWICE; THE FIRST TIME THROUGH IT ONLY   *
.* CHECKS ALL THE R-PARAMETER ELEMENTS FOR VALIDITY AND ADDS UP ALL   *
.* THE FIELD LENGTHS FOR THE GSPACE, AND THE SECOND TIME THROUGH IT   *
.* GENERATES ALL THE MVC'S TO MOVE THE RECORD TO THE AREA ALLOCATED.  *
.* IF THE FIRST TIME THROUGH FINDS ERRORS, THEN THERE IS NO SECOND    *
.* TIME.                                                              *
.**********************************************************************
.LOOPAIR ANOP
&IGARECL SETA  0         INITIALIZE THE RECORD LENGTH TO ZERO.
         AIF   (N'&R EQ 2).RHAS2  SEE IF THERE ARE EXACTLY TWO ELEMENTS*
                         IN R ON PARENTHESIS LEVEL ONE.
         AIF   (N'&R NE 1).RMIXED  SEE IF THERE ARE MORE THAN TWO      *
                         ELEMENTS, FOR IF SO THE LIST CONSISTS OF A    *
                         SERIES OF FIELD NAMES OR (D,L) PAIRS.
.**********************************************************************
.* R HAS ONLY ONE ELEMENT ON LEVEL 1. FIND OUT WHICH OF THE FOLLOWING *
.* CASES APPLIES, AND TAKE THE INDICATED ACTION:                      *
.* IN THE FOLLOWING DISCUSSION, )F" MEANS A FIELD NAME, "D" MEANS     *
.* DISPLACEMENT, "L" MEANS LENGTH, AND "X" MEANS ANY STRING. THE D AND*
.* L FIELDS MUST BE SELF-DEFINING TERMS,.                             *
.* IF:   THEN:                                                        *
.* R=F   ENTER THE ROUTINE AT .RMIXED TO PROCESS A LIST OF PAIRS OF   *
.*       F'S AND (D,L) PAIRS, SINCE THIS CASE WILL BE TREATED AS A    *
.*       SINGLE FIELD NAME BY THAT ROUTINE.                           *
.* R=(F) THIS IS AN ERROR, BECAUSE OF THE POSSIBLE FUTURE USE OF THIS *
.*       FORM TO INDICATE THE ADDRESS OF A LIST OF DISPLACEMENT-LENGTH*
.*       PAIRS IN A REGISTER.                                         *
.* R=L   L IS THE LENGTH OF THE RECORD TO BE INSERTED. THE A PARMAETER*
.*       MUST BE CODED FOR THIS TO BE VALID, BECAUSE OTHERWISE THERE  *
.*       IS NO WAY TO FIND OUT WHERE THE RECORD IS THAT IS TO BE      *
.*       INSERTED.                                                    *
.* R=(L) THIS IS AN ERROR, BECAUSE OF THE POSSIBILITY THAT IN THE     *
.*       FUTURE I WILL WANT TO PUT THE ADDRESS OF A LIST OF           *
.*       DISPLACEMENT-LENGTH PAIRS IN A REGISTER.                     *
.* R=((X)) ENTER THE .RMIXED ROUTINE, SINCE IT LOOKS LIKE A LIST OF   *
.*       DISPLACEMENT-LENGTH PAIRS WITH ONLY ONE PAIR.                *
.*       ANYTHING ELSE IS INVALID, AND PRODUCES THE MNOTE 12,'INVALID *
.*       R-PARAMETER.'                                                *
.**********************************************************************
         AIF   ('&R'(1,1) NE '(').RNOTLP  SEE IF THERE ARE NO          *
                         PARENTHESES AROUND THE OPERAND.
         AIF   ('&R'(1,2) EQ '((').RMIXED  SEE IF THIS IS THE CASE     *
                         R=((X)).
         MNOTE 12,'A REGISTER CANNOT BE SPECIFIED FOR THE LIST OF DISPL*
               ACEMENT-LENGTH PAIRS.'
&ERROR   SETB  1         SET THE ERROR FLAG ON.
         AGO   .RFIN     END THIS PART.
.**********************************************************************
.* THIS MUST BE ONE OF THE TWO CASES R=F OR R=L.                      *
.**********************************************************************
.RNOTLP  ANOP
         AIF   (((T'&R(1) NE 'M')AND(T'&R(1) NE 'N')AND(T'&R(1) NE 'O')*
               AND(T'&R(1) NE 'T')AND(T'&R(1) NE 'W')AND(T'&R(1) NE '$'*
               )AND(T'&R(1) NE 'U'))).RMIXED
.* THIS MUST BE THE CASE WHERE "R=L" IS CODED.                        *
         AIF   (T'&R(1) NE 'N').R1NOTN  SEE IF IT IS A SELF-DEFINING   *
                         FIELD.
.**********************************************************************
.* R=L IS CODED, AND L IS A SELF-DEFINING TERM. USE L FOR THE RECORD  *
.* LENGTH, BUT FIRST CHECK TO SEE IF THE A PARAMETER IS CODED. IF THE *
.* A PARAMETER IS NOT CODED IT IS AN ERROR.                           *
.**********************************************************************
&IGARECL SETA  (&R(1))   GET THE RECORD LENGTH FROM THE L OF THE R     *
                         PARAMETER.
         AIF   (K'&A EQ 0).R1AMT  SEE IF THE A PARAMETER HAS BEEN LEFT *
                         OUT.
         AIF   (&IGARECL GT 256).R1LERR  FOR THE NONCE ONLY TAKE FIELDS*
                         THAT ARE LESS THAN 257 BYTES LONG.
         AIF   (NOT &XFER).RFIN  SEE IF THIS IS THE MVC GENERATION     *
                         LOOP, OR JUST THE VALIDATION AND ADDING UP    *
                         FIELD LENGTHS LOOP.
.* GENERATE THE MOVE OF THE RECORD TO THE AREA ALLOCATED VIA GSPACE.  *
         AIF   ('&A'(1,1) EQ '(').R1AGPR  SEE IF THE ADDRESS IS IN A   *
                         GPR.
         MVC   0(&IGARECL,1),&A  MOVE THE RECORD.
         AGO   .RFIN     ALL DONE NOW.
.R1AGPR  MVC   0(&IGARECL,1),0&A  MOVE THE RECORD.
         AGO   .RFIN     GO TO THE END OF THE R PARAMETER PROCESSING.
.**********************************************************************
.* FOLLOWING ARE THE MISCELLANEOUS ERROR MNOTES FROM THE SINGLE       *
.* ELEMENT CASE OF THE R PARAMETER.                                   *
.**********************************************************************
.R1LERR  MNOTE 12,'THE LENGTH OF EACH FIELD DEFINED BY R CANNOT EXCEED *
               256 BYTES.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON SO THE MVC'S DON'T GET  *
                         GENERATED.
         AGO   .RFIN
.R1AMT   MNOTE 12,'THE A PARAMETER MUST BE CODED WITH R AS CODED.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .RFIN
.R1NOTN  MNOTE 12,'THE LENGTH MUST BE A SELF-DEFINING TERM FOR THE R PA*
               RAMETER.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .RFIN
.**********************************************************************
.* THE R PARAMETER HAS EXACTLY TWO ELEMENTS IN IT ON LEVEL 1. SEE IF  *
.* EITHER OF THESE TWO ELEMENTS STARTS WITH A LEFT PARENTHESIS, WHICH *
.* MEANS ONE OF THE CASES R=(X,(X)), R=((X),X), OR R=((X),(X)). IF IT *
.* IS ONE OF THESE CASES ENTER THE MIXED ROUTINE AT .RMIXED.          *
.* IF IT IS NOT ONE OF THOSE THREE CASES, THEN IT MUST BE ONE OF THE  *
.* CASES R=(F,F), R=(F,L), OR R=(D,L). NOTE THAT THE CASE R=(D,L) CAN *
.* BE CODED AS R=(,L).                                                *
.**********************************************************************
.RHAS2   AIF   (K'&R(2) NE 0).R2NOTMT  SEE IF THE SECOND ELEMENT IS THE*
                         EMPTY STRING. THIS IS NO GOOD.
         MNOTE 12,'THE SECOND ELEMENT OF A DISPLACEMENT-LENGTH PAIR MUS*
               T BE CODED.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .FIN      FORGET IT, CAN'T DO ANYTHING WITH AN EMPTY    *
                         STRING FOR THE LENGTH.
.R2DMT   ANOP
&DSP     SETA  (0)       SET THE DISPLACEMENT TO ZERO, SINCE IT IS     *
                         CODED AS THE EMPTY STRING.
         AGO   .R2MERGE  MERGE WITH THE CASE WHERE THE DISPLACEMENT IS *
                         NOT THE EMPTY STRING.
.R2NOTMT AIF   (K'&R(1) EQ 0).R2DMT  SEE IF THE DISPLACEMENT IS THE    *
                         EMPTY STRING.
         AIF   (('&R(1)'(1,1) EQ '(')OR('&R(2)'(1,1) EQ '(')).RMIXED   *
                         LOOK FOR ONE OF THE CASES R=(X,(X)), R=((X),  *
                         X), OR R=((X),(X)).
         AIF   (((T'&R(2) NE 'M')AND(T'&R(2) NE 'N')AND(T'&R(2) NE 'O')*
               AND(T'&R(2) NE 'T')AND(T'&R(2) NE 'W')AND(T'&R(2) NE '$'*
               )AND(T'&R(2) NE 'U'))).RMIXED
.* THE SECOND ELEMENT IS NOT A FIELD NAME, SO IT MUST EITHER BE ONE OF*
.* THE TWO CASES R=(F,L) OR R=(D,L), OR IT IS AN ERROR.               *
         AIF   ((T'&R(1) NE 'M')AND(T'&R(1) NE 'N')AND(T'&R(1) NE 'O')A*
               ND(T'&R(1) NE 'T')AND(T'&R(1) NE 'W')AND(T'&R(1) NE '$')*
               AND(T'&R(1) NE 'U')).R2F1
         AIF   (T'&R(1) NE 'N').R2DTYPE  SEE IF THE FIRST ONE IS A     *
                         VALID DISPLACEMENT.
&DSP     SETA  (&R(1))   PICK UP THE DISPLACEMENT.
.R2MERGE ANOP
         AIF   (T'&R(2) EQ 'N').R2TSELF  SEE IF THE LENGTH IS A        *
                         SELF-DEFINING FIELD.
&I       SETA  (K'&R(2))  CHECK THE FIELD TO SEE IF IT ALL NUMERIC.
.R2LTKLP AIF   (('&R(2)'(&I,1) LT '0')OR('&R(2)'(&I,1) GT '9')).R2LTYPE*
                         SEE IF IT IS NOT ONE OF THE DIGITS 0-9.
&I       SETA  (&I-1)    STEP DOWN TO THE NEXT CHARACTER.
         AIF   (&I GT 0).R2LTKLP  SEE IF ALL THE CHARACTERS HAVE BEEN  *
                         CHECKED.
.R2TSELF ANOP
&IGARECL SETA  (&R(2))   GET THE LENGTH AS A NUMBER.
         AIF   (&IGARECL GT 256).R1LERR  SEE IF THE LENGTH IS MORE THAN*
                         256 BYTES.
         AIF   (&DSP GT 4095).R2DERR  SEE IF THE DISPLACEMENT IS       *
                         GREATER THAN 4095.
         AIF   (K'&A EQ 0).R1AMT  SEE IF THE A PARAMETER IS LEFT OUT;  *
                         THAT IS BAD.
         AIF   (NOT &XFER).RFIN  SEE IF THIS IS THE MVC GENERATING LOOP*
                         OR NOT.
.**********************************************************************
.* GENERATE THE MOVE OF THE RECORD TO THE AREA ALLOCATED FOR IT VIA   *
.* THE GSPACE MACRO-INSTRUCTION.                                      *
.**********************************************************************
         AIF   ('&A'(1,1) EQ '(').R2AGPR  SEE IF THE ADDRESS IS IN A   *
                         GPR.
         MVC   0(&IGARECL,1),&DSP+&A  MOVE THE RECORD.
         AGO   .RFIN
.R2AGPR  MVC   0(&IGARECL,1),&DSP&A  MOVE THE RECORD IN.
         AGO   .RFIN
.**********************************************************************
.* IT IS AN (F,L) PAIR, NOW SEE IF THE SECOND ELEMENT IS A VALID L.   *
.**********************************************************************
.R2F1    AIF   (T'&R(2) NE 'N').R2LTYPE  SEE IF THE SECOND ELEMENT IS A*
                         SELF-DEFINING TERM.
&IGARECL SETA  (&R(2))   GET THE LENGTH OF THE (F,L) PAIR.
         AIF   (&IGARECL GT 256).R1LERR  SEE IF THE LENGTH OF THE FIELD*
                         IS MORE THAN 256.
         AIF   (NOT &XFER).RFIN  SEE IF THIS IS THE MOVE GENERATION    *
                         LOOP.
         MVC   0(&IGARECL,1),&R(1)  MOVE THE RECORD.
         AIF   (K'&A EQ 0).RFIN  SEE IF THE A PARAMETER IS CODED.
         MNOTE 4,'THE A PARAMETER IS REDUNDANT.'
         AGO   .RFIN     ALL DONE NOW, GO CHECK FOR THE MOVE GENERATION*
                         ITERATION.
.**********************************************************************
.* THE FOLLOWING ARE THE SUNDRY MNOTES FOR THE TWO ELEMENT CASE FOR   *
.* THE R PARAMETER.                                                   *
.**********************************************************************
.R2DERR  MNOTE 12,'DISPLACEMENT IN R PARAMETER CANNOT EXCEED 4095.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .RFIN
.R2DTYPE MNOTE 12,'THE DISPLACEMENT IN R MUST BE A SELF-DEFINING TERM.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON TO PREVENT THE MVC      *
                         GENERATION.
         AGO   .RFIN
.R2LTYPE MNOTE 12,'THE LENGTH IN R MUST BE A SELF-DEFINING TERM.'
&ERROR   SETB  1         SET THE ERROR FLAG ON.
         AGO   .RFIN
.**********************************************************************
.* THE R PARAMETER CONSISTS OF A LIST OF MIXED PAIRS OF FIELDS AND    *
.* DISPLACEMENT-LENGTH PAIRS. PICK OUT ALL THESE AND CHECK THEM FOR   *
.* VALIDITY, WHILE ADDING UP ALL THE LENGTHS OF THE INDIVIDUAL FIELDS *
.* FOR THE GSPACE MACRO-INSTRUCTION LATER. GENERATE THE MVC'S IF THIS *
.* IS THE SECOND TIME THROUGH THE LOOP.                               *
.**********************************************************************
.**********************************************************************
.* THIS IS THE SECTION TO PROCESS A MIXED LIST OF FIELD NAMES AND (D  *
.* ,L) PAIRS. PARSE THE OPERAND USING THE PARSE IN THE RPTDSECT       *
.* MACRO-INSTRUCTION, AND CHECK THE VARIABLE &IGAOKAY TO SEE IF THERE *
.* ARE NO SYNTAX ERRORS IN THE R PARAMETER.                           *
.**********************************************************************
.RMIXED  ANOP
      RPTDSECT SCAN=PARSE,LIST=&R  PARSE THE OPERAND.
         AIF   (&IGAOKAY).RMXOK  SEE IF THE PARSE DETECTED BAD SYNTAX.
         MNOTE 12,'INVALID SYNTAX IN THE R PARAMETER.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .RFIN     CAN'T DO ANYTHING WITH THIS.
.**********************************************************************
.* THE SYNTAX APPEARS TO BE OK, NOW START SCANNING OUT THE ATOMS ONE  *
.* AT A TIME, ANALYZING EACH ONE INDIVIDUALLY IN CONTEXT WITH THE ONES*
.* ON EITHER SIDE OF IT.                                              *
.**********************************************************************
.RMXOK RPTDSECT SCAN=ISCAN  INITIALIZE FOR SUBSEQUENT SCANNING OF      *
                         ATOMS.
.RMXMOR RPTDSECT SCAN=NEXT  GET THE CURSOR POSITIONED AT THE NEXT ATOM.
.RMXCHK  AIF   (&IGAX EQ 0).RFIN  SEE IF THERE ARE ANY MORE TO DO.
         AIF   (&IGALEVL EQ 2).RMXLVL2  SEE IF THIS ATOM IS ON LEVEL 2.
         AIF   (&IGALEVL LE 1).RMXL01  SEE IF THIS ATOM IS ON LEVEL 0  *
                         OR 1.
.**********************************************************************
.* THE CURRENT ATOM HAS TOO MANY LEVELS OF PARENTHESES AROUND IT, GIVE*
.* THE ERROR MESSAGE AND GO LOOK FOR THE NEX THING THAT CHANGES LEVEL *
.* 1 IN THE PATH VECTOR.                                              *
.**********************************************************************
&I       SETA  &IGAPATH(1)+1  SET &I TO THE CURRENT OPERAND NUMBER.
         MNOTE 12,'TOO MANY () LEVELS IN OPERAND &I OF R.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
.**********************************************************************
.* AN ERROR HAS BEEN DETECTED AND FLAGGED IN THE CURRENT OPERAND. SCAN*
.* OVER TO THE NEXT ATOM THAT IS NOT PART OF THE CURRENT ENTRY ON     *
.* LEVEL 1 IN THE PARAMETER.                                          *
.**********************************************************************
.SYNC    ANOP
&I       SETA  &IGAPATH(1)  SET &I TO THE INDEX OF THE OPERAND ON LEVEL*
                         1.
      RPTDSECT SCAN=NEXT  SET THE CURSOR TO THE NEXT ONE.
         AIF   (&IGAX EQ 0).RFIN  SEE IF THERE AREN'T ANY MORE.
         AIF   (&I EQ &IGAPATH(1)).SYNC  SEE IF IT IS STILL ON THE SAME*
                         ONE.
         AGO   .RMXCHK   FINALLY GOT THE NEXT ATOM, NOW GO CHECK IT FOR*
                         VALIDITY.
.**********************************************************************
.* THE CURRENT ATOM IS ON LEVEL 0 OR 1. THEREFORE IT SHOULD BE A VALID*
.* FIELD NAME; SEE IF IT IS.                                          *
.**********************************************************************
.RMXL01  ANOP
.RMX01   ANOP
&I       SETA  (1+&IGAPATH(1))  SET &I TO THE 1-ORIGIN INDEX OF THE    *
                         FIELD NAME ON LEVEL 1.
         AIF   ((T'&R(&I) NE 'M')AND(T'&R(&I) NE 'N')AND(T'&R(&I) NE 'O*
               ')AND(T'&R(&I) NE 'T')AND(T'&R(&I) NE 'W')AND(T'&R(&I) N*
               E '$')AND(T'&R(&I) NE 'U')).RMX01OK
         MNOTE 12,'OPERAND &I OF R DOES NOT HAVE THE PROPER TYPE ATTRIB*
               UTE.'
&ERROR   SETB  (1)       SET THE ERROR FLAG.
         AGO   .SYNC     GO POSITION THE CURSOR TO THE NEXT ONE.
.**********************************************************************
.* THE CURRENT ATOM LOOKS LIKE A VALIID FIELD NAME, GET ITS LENGTH    *
.* ATTRIBUTE AND SEE IF IT ACCEPTABLE.                                *
.**********************************************************************
.RMX01OK ANOP
&LNG     SETA  (L'&R(&I))  CAPTURE IT AS A NUMBER.
         AIF   (&LNG LE 256).RMX0LOK  SEE IF IT EXCEEDS 256.
         MNOTE 12,'THE LENGTH OF FIELD &I OF R EXCEEDS 256 BYTES.'
&ERROR   SETB  (1)       SET TEH ERROR FLAG.
         AGO   .SYNC     GO LOOK AT THE NEXT ONE.
.RMX0LOK ANOP
.**********************************************************************
.* NOW SEE IF THIS IS THE MOVE GENERATION ITERATION.                  *
.**********************************************************************
         AIF   (NOT &XFER).RX0M  GO IF THIS ISN'T THE MOVE GENERATION  *
                         ITERATION.
         MVC   &IGARECL.(&LNG,1),&R(&I)  MOVE THE FIELD.
.RX0M    ANOP
&IGARECL SETA  (&IGARECL+&LNG)  EKE THE CUMMULATIVE RECORD LENGTH.
         AGO   .RMXMOR   GO LOKK FOR THE NEXT ONE.
.**********************************************************************
.* THE CURRENT ATOM IS ON LEVEL 2. IT MUST THEREFORE BE THE FIRST     *
.* ELEMENT IN ONE OF THE CASES (F,L) OR (D,L).                        *
.* FIND OUT WHETHER THE CURRENT ATOM IS AN F OR A D.                  *
.**********************************************************************
.RMXLVL2 ANOP
&X       SETC  '0'       SET THIS FOR THE CASE WHERE THE DISPLACEMENT  *
                         IS AN EMPTY STRING.
         AIF   (&IGAZ EQ 0).RMGDSP  GO IF IT IS AN EMPTY STRING, WHICH *
                         MEANS A DISPLACEMENT OF 0.
.**********************************************************************
.* SEE IF ALL THE CHARACTERS IN THE CURRENT ATOM ARE DIGITS 0 THROUGH *
.* 9, WHICH WOULD MAKE IT A SELF-DEFINING DECIMAL TERM.               *
.**********************************************************************
&I       SETA  0         INITIALIZE THE INDEX OF THE CURRENT CHARACTER *
                         IN THE ATOM.
.RMCONT  AIF   (('&R'(&IGALEFT(&IGAZ)+&I,1) LT '0')OR('&R'(&IGALEFT(&IG*
               AZ)+&I,1) GT '9')).RMNOTD
&I       SETA  (&I+1)    EKE THE INDEX.
         AIF   (&I LT &IGARGHT(&IGAZ)).RMCONT  KEEP GOING UNTIL ALL    *
                         DIGITS HAVE BEEN EXAMINED.
         AIF   (&IGARGHT(&IGAZ) GT 4).RMXBADD  SEE IF THE DISPLACEMENT *
                         HAS TOO MANY BYTES IN IT.
&X       SETC  '&R'(&IGALEFT(&IGAZ),&I)  GET THE DISPLACEMENT AS A     *
                         NUMBER.
.RMGDSP  ANOP
&DSP     SETA  (&X)      GET THE NUMBER NOW.
         AIF   (&DSP GT 4095).RMXDBAD  SEE IF THE DISPLACEMENT IS TOO  *
                         BIG.
.**********************************************************************
.* THE CURRENT ATOM IS A VALID DISPLACEMENT OF A (D,L) PAIR, AND ITS  *
.* ARITHMETIC VALUE IS IN THE APPROPRIATE RANGE OF VALUES FOR A       *
.* DISPLACEMENT. ITS VALUE HAS BEEN CAPTURED IN &DSP. NOW LOOK FOR THE*
.* CORRESPONDING L OF THE PAIR.                                       *
.**********************************************************************
&I       SETA  (&IGAPATH(1))  SAVE THE CURRENT ATOM LEVEL 1 INDEX.
      RPTDSECT SCAN=NEXT  POSITION THE CURSOR TO THE NEXT ATOM.
         AIF   (&IGAX EQ 0).RMXNOLL  SEE IF THERE ISN'T ANY L FOR IT   *
                         BECAUSE THERE AREN'T ANY MORE ATOMS.
         AIF   (&IGAPATH(1) NE &I).RMXNOL  SEE IF THE NEXT ATOM IS PART*
                         OF A DIFFERENT ELEMENT ON LEVEL 1.
         AIF   (&IGALEVL NE 2).RMXPRN  SEE IF THERE ARE TOO MANY LEVELS*
                         OF PARENTHESES.
         AIF   (&IGAZ EQ 0).RMXLBAD  SEE IF THE L ATOM IS THE EMPTY    *
                         STRING.
.**********************************************************************
.* THERE IS A NEXT ATOM IN THE SAME PAIR, NOW CHECK IT TO SEE IF IT IS*
.* A SELF-DEFINING DECIMAL TERM.                                      *
.**********************************************************************
&I       SETA  0  INITIALIZE THE INDEX OF THE CURRENT BYTE IN THE ATOM.
.RMCNT1  AIF   (('&R'(&IGALEFT(&IGAZ)+&I,1) LT '0')OR('&R'(&IGALEFT(&IG*
               AZ)+&I,1) GT '9')).RMXBADL
&I       SETA  (&I+1)    EKE THE INDEX TO THE NEXT BYTE.
         AIF   (&I LT &IGARGHT(&IGAZ)).RMCNT1  KEEP LOOKING UNTIL ALL  *
                         THE BYTES ARE EXAMINED.
         AIF   (&IGARGHT(&IGAZ) GT 4).RMXLERR  SEE IF THE LENGTH IS    *
                         MORE THAN 4 CHARACTERS.
&X       SETC  '&R'(&IGALEFT(&IGAZ),&IGARGHT(&IGAZ))  GET THE LENGTH.
&LNG     SETA  (&X)      TURN IT INTO A NUMBER.
         AIF   (&LNG GT 256).RMXLERR  SEE IF IT IS TOO BIG TO DO WITH  *
                         AN MVC.
.**********************************************************************
.* THE DISPLACEMENT OF THE DISPLACEMENT-LENGTH PAIR IS AT &DSP, AND   *
.* THE LENGTH IS AT &LNG. CHECK THE A PARAMETER TO SEE IF IT IS CODED,*
.* BECAUSE IF IT ISN'T CODED THERE IS NO WAY TO FIND OUT WHERE THE    *
.* RECORD REALLY IS.                                                  *
.**********************************************************************
         AIF   (K'&A EQ 0).RMXAMT  SEE IF IT ISN'T THERE.
.* NOW GENERATE THE MOVE OF THE FIELD IF THIS IS THE MOVE GENERATION  *
.* ITERATION.                                                         *
         AIF   (NOT &XFER).RMOVED  SEE IF IT ISN'T THE MOVE GENERATION *
                         ITERATION.
&X       SETC  ''        SET IT UP FOR THE ADDRESS IN A REGISTER.
         AIF   ('&A'(1,1) EQ '(').RMAGPR  GO IF THE ADDRESS IS IN A    *
                         REGISTER.
&X       SETC  '+'       SET IT UP FOR THE CASE EHERE THE ADDRESS IS   *
                         SUPPLIED IN THE FORM OF A LABEL.
.RMAGPR  MVC   &IGARECL.(&LNG,1),&DSP&X&A  MOVE SUBFIELD.
.RMOVED  ANOP
&IGARECL SETA  (&IGARECL+&LNG)  EKE THE CUMMULATIVE RECORD LENGTH.
.**********************************************************************
.* NOW SET THE CURSOR TO THE NEXT ATOM, AND SEE IF THE FIRST ELEMENT  *
.* IS PART OF THE SAME ELEMENT ON LEVEL 1 AS THE LAST (D,L) PAIR.     *
.**********************************************************************
&I       SETA  &IGAPATH(1)  PRESERVE THE CURRENT LEVEL 0 INDEX.
      RPTDSECT SCAN=NEXT  POSITION THE CURSOR TO THE NEXT ATOM.
         AIF   (&IGAX EQ 0).RFIN  GO IF THERE ISN'T ANY NEXT ATOM.
         AIF   (&I EQ &IGAPATH(1)).RMXSAME  SEE IF THE LEVEL 1 ELEMENT *
                         IN THE PATH VECTOR DIDN'T CHANGE.
         AGO   .RMXCHK   GO CHECK THE NEXT ATOM, IT ISN'T PART OF THE  *
                         LAST TWO.
.**********************************************************************
.* THE FOLLOWING ARE SUNDRY MNOTES FROM THE PROCESSING OF A LIST OF   *
.* MIXED PAIRS WHERE THE PAIRS ARE OF THE FORM (D,L).                 *
.**********************************************************************
.RMXSAME ANOP
&I       SETA  (&IGAPATH(1)+1)  SET &I TO THE CURRENT OPERAND #.
         MNOTE 12,'TOO MANY ELEMENTS IN SUBLIST OPERAND &I IN R.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .SYNC     GO LOOK FOR THE NEXT ONE.
.RMXAMT  ANOP
&I       SETA  (1+&IGAPATH(1))  GET THE CURRENT OPERAND NUMBER.
         MNOTE 12,'THE A PARAMETER MUST BE CODED TO USE A (D,L) PAIR FO*
               R R(&I).'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .SYNC     GO LOOK FOR THE NEXT ONE.
.RMXLERR ANOP
&I       SETA  (&IGAPATH(1)+1)  GET THE CURRENT OPERAND NUMBER.
         MNOTE 12,'THE LENGTH OF THE FIELD DEFINED BY R(&I) EXCEEDS 256*
                BYTES.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .SYNC     GO LOOK AT THE NEXT ONE.
.RMXBADL ANOP
&I       SETA  (1+&IGAPATH(1))
         MNOTE 12,'THE LENGTH FOR R(&I) MUST BE A SELF-DEFINING DECIMAL*
                NUMBER.'
&ERROR   SETB  (1)
         AGO   .SYNC
.RMXLBAD ANOP
&I       SETA  (1+&IGAPATH(1))
         MNOTE 12,'THE LENGTH FOR R(&I) CANNOT BE THE EMPTY STRING.'
&ERROR   SETB  (1)
         AGO   .SYNC
.RMXNOL  ANOP
&I       SETA  (1+&IGAPATH(1))
         MNOTE 12,'LENGTH OF (D,L) PAIR MISSING IN R(&I).'
&ERROR   SETB  (1)
         AGO   .RMXCHK   GO CHECK THE CURRENT ATOM FOR VALIDITY.
.RMXNOLL ANOP
         MNOTE 12,'LENGTH OF LAST (D,L) PAIR IN R IS MISSING.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .RFIN
.RMXPRN  ANOP
&I       SETA  (&IGAPATH(1)+1)
         MNOTE 12,'TOO MANY () LEVELS IN R(&I).'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .SYNC
.RMXBADD ANOP
&I       SETA  (1+&IGAPATH(1))
         MNOTE 12,'DISPLACEMENT IN R(&I) EXCEEDS 4 DIGITS.'
&ERROR   SETB  (1)
         AGO   .SYNC
.RMXDBAD ANOP
&I       SETA  (1+&IGAPATH(1))
         MNOTE 12,'DISPLACEMENT IN R(&I) EXCEEDS 4095.'
&ERROR   SETB  (1)
         AGO   .SYNC
.**********************************************************************
.* THE CURRENT ATOM IS AN F OF A (F,L) PAIR.                          *
.**********************************************************************
.RMNOTD  AIF   (&IGARGHT(&IGAZ) LE 8).RMXBIGF  SEE IF THE STRING IS    *
                         BIGGER THAN 8 CHARACTERS.
&I       SETA  (1+&IGAPATH(1))
         MNOTE 12,'FIELD NAME IN R(&I) IS BIGGER THAN 8 CHARACTERS.'
&ERROR   SETB  (1)
         AGO   .SYNC
.RMXBIGF ANOP
&FIELD   SETC  '&R'(&IGALEFT(&IGAZ),&IGARGHT(&IGAZ))  GET THE FIELD    *
                         NAME.
.* NOW TRY TO GET THE L OF THE (F,L) PAIR.                            *
&I       SETA  (&IGAPATH(1))  PRESERVE THE CURRENT LEVEL 1 INDEX.
      RPTDSECT SCAN=NEXT  POSITION THE CURSOR TO THE NEXT ATOM.
         AIF   (&IGAX EQ 0).RFLNOL  SEE IF THERE IS NO LENGTH BECAUSE  *
                         THERE ISN'T ANY NEXT ATOM.
         AIF   (&IGAPATH(1) NE &I).RFNOL  SEE IF THE NEXT ATOM IS NOT  *
                         PART OF THE SAME PAIR.
         AIF   (&IGALEVL NE 2).RFNOLL  SEE IF THE NEXT ATOM HAS TOO    *
                         MANY () LEVELS.
         AIF   (&IGAZ EQ 0).RFLMT  SEE IF THE LENGTH ATOM IS THE EMPTY *
                         STRING.
.**********************************************************************
.* THE CURRENT ATOM IS INDEED THE SECOND ELEMENT OF A (F,X) PAIR. NOW *
.* LET'S SEE IF X IS A VALID L.                                       *
.**********************************************************************
         AIF   (&IGARGHT(&IGAZ) GT 3).RFLLBAD  SEE IF THE LENGTH ATOM  *
                         IS MORE THAN 3 DIGITS.
&I       SETA  0         INITIALIZE THE INDEX OF THE CURRENT BYTE.
.RMXCNT2 AIF   (('&R'(&IGALEFT(&IGAZ)+&I,1) LT '0')OR('&R'(&IGALEFT(&IG*
               AZ)+&I,1) GT '9')).RFLBAD
&I       SETA  (&I+1)    STEP OVER TO THE NEXT DIGIT.
         AIF   (&I LT &IGARGHT(&IGAZ)).RMXCNT2  KEEP GOING UNTIL ALL   *
                         THE DIGITS HAVE BEEN SCANNED.
&X       SETC  '&R'(&IGALEFT(&IGAZ),&IGARGHT(&IGAZ))  EXTRACT THE      *
                         LENGTH.
&LNG     SETA  (&X)      CONVERT IT TO A NUMBER.
         AIF   (&LNG GT 256).RFBADL  SEE IF THE LENGTH EXCEEDS 256     *
                         BYTES.
.**********************************************************************
.* IT LOOKS LIKE A VALID (F,L) PAIR; GENERATE THE MOVE IF THIS IS THE *
.* MOVE GENERATION ITERATION.                                         *
.**********************************************************************
         AIF   (NOT &XFER).RMOVED  GO IF IT IS NOT THE MOVE ITERATION.
         MVC   &IGARECL.(&LNG,1),&FIELD  MOVE SUBFIELD.
         AGO   .RMOVED   MERGE WITH THE COMMON PATH.
.**********************************************************************
.* THE FOLLOWING ARE SUNDRY MNOTES FOR THE (F,L) CASE IN A MIXED LIST.*
.**********************************************************************
.RFBADL  ANOP
&I       SETA  (&IGAPATH(1)+1)
         MNOTE 12,'LENGTH IN OPERAND &I OF R EXCEEDS 256 BYTES.'
&ERROR   SETB  (1)
         AGO   .SYNC
.RFLBAD  ANOP
&I       SETA  (1+&IGAPATH(1))
         MNOTE 12,'THE LENGTH IN OPERAND R(&I) IS NOT A SELF-DEFINING D*
               ECIMAL NUMBER.'
&ERROR   SETB  (1)
         AGO   .SYNC
.RFLLBAD ANOP
&I       SETA  (1+&IGAPATH(1))
         MNOTE 12,'LENGTH IN OPERAND R(&I) IS MORE THAN 3 DIGITS.'
&ERROR   SETB  (1)
         AGO   .SYNC
.RFLMT   ANOP
&I       SETA  (1+&IGAPATH(1))
         MNOTE 12,'LENGTH IN OPERAND &I OF R CANNOT BE THE EMPTY STRING*
               .'
&ERROR   SETB  (1)
         AGO   .SYNC
.RFNOL   ANOP
         MNOTE 12,'LENGTH OF (F,L) PAIR IN OPERAND &I OF R IS MISSING.'
&ERROR   SETB  (1)
         AGO   .RMXCHK
.RFNOLL  ANOP
&I       SETA  (1+&IGAPATH(1))
         MNOTE 12,'TOO MANY () LEVELS IN R(&I).'
         AGO   .SYNC
.RFLNOL  MNOTE 12,'LENGTH OF LAST (FIELD,LENGTH) PAIR IN R IS MISSING.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON TO PREVENT THE MOVES.
         AGO   .RFIN
.**********************************************************************
.RFIN    ANOP
         AIF   ((&XFER)OR(&ERROR)).MV#FIN  SEE IF THE MOVE GENERATION  *
                         LOOP MUST BE DONE THIS TIME.
&XFER    SETB  (1)       SET IT ON SO THE MOVES ONLY GET GENERATED ONCE
&RC      SETC  'C'
         AIF   (K'&C EQ 0).GSPACE  SEE IF THE CONDITIONAL PARAMETER HAS*
                         BEEN LEFT OUT.
         AIF  ((('&C' EQ 'C')OR('&C'(1,1) EQ 'Y')OR('&C'(1,1) EQ '1')))*
               .GSPACE   SEE IF IT IS A CONDITIONAL REQUEST.
&RC      SETC  ''        IT IS AN UNCONDITIONAL REQUEST.
.GSPACE  ANOP
        GSPACE R&RC,LV=&IGARECL,S=&S,SP=&SP  GET SPACE TO PUT RECORD.
         AIF   ('&RC' NE 'C').SKIPBNZ  SEE IF THE REQUEST IS COND.
         BNZ   SETR&SYSNDX BR IF ALLOCATION FAILED.
.SKIPBNZ AGO   .LOOPAIR  GO GENERATE THE MOVE OF THE RECORD.
.MV#FIN  ANOP
         LR    15,1      PUT THE RECORD ADDRESS IN R15.
         AIF   (NOT &R1SAVED).R1ISOK  SEE IF R1 WAS SAVED THROUGH THE  *
                         GSPACE OPERATION.
         L     1,((4*1)+20-64*((2+1)/16))(,13)  RESTORE R1.
.R1ISOK  AGO   .CHK#     NOW GO CHECK THE # PARAMETER.
.**********************************************************************
.* THERE IS NO NEED TO ALLOCATE A SPACE FOR THE RECORD VIA THE GSPACE *
.* MACRO-INSTRUCTION. GET THE ADDRESS OF THE RECORD IN REGISTER 15.   *
.**********************************************************************
.CHKA    AIF   (K'&A EQ 0).ASARG  SEE IF THE ADDRESS IS OMITTED; IF IT *
                         IS GET IT OUT OF THE SEARCH ARGUMENT.
         AIF   ('&A'(1,1) EQ '(').AGPR  SEE IF THE ADDRESS IS IN A GPR.
         LA    15,&A     ADDRESS OF THE RECORD TO INSERT.
         AGO   .CHKAEND  GO TO THE END OF CHECKING THE A PARAMETER.
.AGPR    AIF   ('&A' EQ '(15)').CHKAEND  SEE IF IT IS ALREADY IN R15.
         LR    15,&A(1)  INSERT ADDRESS.
         AGO   .CHKAEND  ALL DONE NOW EXIT FROM CHECKING THE A         *
                         PARAMETER.
.ASARG   ANOP
         MNOTE 12,'EITHER A OR R MUST BE CODED TO SPECIFY THE INS.ARG.'
.CHKAEND ANOP
.**********************************************************************
.* CHECK THE # PARAMETER TO SEE IF A DIFFERENT ADDRESS THAN THE ONE   *
.* FURNISHED BY THE A PARAMETER IS TO BEBUSED BY THE INSERT ROUTINE.  *
.**********************************************************************
.CHK#    AIF   (K'&# EQ 0).#ZORRO  SEE IF THE # PARAMETER IS CODED.
         AIF   ('&#'(1,1) EQ '(').#GPR  SEE IF THE # PARAMETER IS IN A *
                         GPR.
         L     0,&#      LOAD IN THE ERSATZ ADDRESS.
         AGO   .#FIN     ALL DONE WITH THE ERSATZ ADDRESS.
.#GPR    DC    ((30-&#(1))/16)AL1(X'18',&#(1))  LOAD THE ERSATZ ADDRESS*
                         IN GPR 0 UNLESS IT IS ALREADY IN GPR 0.
         AGO   .#FIN     ALL DONE WITH THE ERSATZ ADDRESS.
.#ZORRO  LR    0,15  # NOT CODED.
.#FIN    ANOP
.**********************************************************************
.* SEE IF THE REQUEST IS CONDITIONAL OR UNCONDITIONAL, AND CALL THE   *
.* APPROPRIATE ROUTINE IN THE MODULE IGARPT01.                        *
.**********************************************************************
         AIF   (K'&TREE EQ 0).INGPR1  SEE IF THE TREE ADDRESS IS       *
                         SPECIFIED.
         AIF   ('&TREE'(1,1) EQ '(').RPTGPR  SEE IF THE TREE ADDRESS IS*
                         IN A GPR.
         L     1,&TREE   LOAD THE ADDRESS OF THE RPT.
         AGO   .R1LOAD   SKIP AROUND THE GPR CASE.
.RPTGPR  LR    1,&TREE(1)  GET THE RPT ADDRESS.
.R1LOAD  ANOP
.INGPR1  ANOP
         L     14,(&IGABLST+&IGAINS)(,1)  ADDRESS OF INSERT ROUTINE.
.**********************************************************************
.* NOW GENERATE THE LINKAGE TO THE INSERT ROUTINE IN THE MODULE       *
.* IGARPT01.                                                          *
.**********************************************************************
&REQUEST SETB  (1)       SET THE REQUEST MODE TO CONDITIONAL.
         AIF   (K'&C EQ 0).LINKC  SEE IF IT IS A CONDITIONAL REQUEST.
         AIF (('&C'(1,1) EQ 'Y')OR('&C' EQ '1')OR('&C' EQ 'C')).LINKC  *
                         SEE IF IT IS A CONDITIONAL REQUEST.
&REQUEST SETB  (0)       SET THE REQUEST MODE TO UNCONDITIONAL.
         BALR  14,14     INDICATE UNCONDITIONAL TYPE 8 INSERT.
         AGO   .LINKFIN  ALL DONE WITH THE LINKAGE.
.LINKC   BAL   14,0(,14)  INDICATE CONDITIONAL INSERT.
.LINKFIN ANOP
         AIF   (K'&R EQ 0).FIN  SEE IF THE AREA WAS ALLOCATED VIA THE  *
                         GSPACE MACRO-INSTRUCTION.
         AIF   (NOT &REQUEST).FIN  SEE IF IT WAS AN UNCONDITIONAL      *
                         REQUEST.
&FINEQU  SETB  (1)       SET THE BIT ON TO GENERATE THE EQUATE AT THE  *
                         END OF THE MACRO EXECUTION.
         BC    10,FIN&SYSNDX  BRANCH IF THE INSERT WAS SUCCESSFUL.
         L     1,X'10'(,13)  PUT THE ADDRESS IN R1 TO FREE IT UP.
        FSPACE LV=&IGARECL,A=(1),SP=&SP,S=&S
SETR&SYSNDX LA 15,1      SET THE RETURN CODE NEGATIVE.
         LNR   15,15     SET THE CONDITION CODE ALSO.
.FIN     AIF   (NOT &FINEQU).END  SEE IF THE EQUATE MUST BE GENERATED.
FIN&SYSNDX EQU *         LABEL FOR THE BRANCH TO BRANCH TO.
.END     ANOP
         MEND
         EJECT
         MACRO
&TAG     ISCAN &TREE,&T=,&TYPE=
.*A000000                                                        Y02147
.**********************************************************************
.* THE ISCAN MACRO-INSTRUCTION SETS THE RPT CURSOR AT 12 O'CLOCK.     *
.* EVERY RADIX PARTITION TREE HAS A CURSOR AS PART OF THE CONTROL     *
.* INFORMATION THAT IS MAINTAINED BY THE OPERATIONS PROVIDED. THERE   *
.* ARE 6 BASIC CURSOR STATES. A CURSOR IS BEST VISUALIZED AS A        *
.* POSITION ON A CIRCLE (SUCH AS A CLOCK). THE POSITION THAT SELECTS  *
.* THE KEY-ADDRESS PAIR WITH THE LOWEST KEY IS AT 8 O'CLOCK. THE      *
.* POSITION THAT SELECTS THE KEY-ADDRESS PAIR WITH THE HIGHEST KEY IS *
.* AT 4 O'CLOCK. THE KEY-ADDRESS PAIRS ARE IN ASCENDING ORDER FROM    *
.* LEFT TO RIGHT ACROSS THE BOTTOM OF THE CIRCLE, STARTING WITH THE 8 *
.* O'CLOCK POSITION AND ENDING WITH THE 4 O'CLOCK POSITION.           *
.* THE CURSOR STATES AND THE OPERATIONS THAT SET THEM ARE LISTED      *
.* BELOW:                                                             *
.* 0:    THIS STATE IS THE EMPTY, OR NULL STATE, WHERE THERE ARE NO   *
.*       KEY-ADDRESS ASSOCIATION PAIRS IN THE RPT.                    *
.* 1:    THIS STATE IS THE ONE WHERE THE CURSOR IS IN THE 9 O'CLOCK   *
.*       POSITION. THIS STATE CAN ONLY ARISE WHEN THERE IS AT LEAST 1 *
.*       KEY-ADDRESS ASSOCIATION PAIR IN THE RPT. THE CURSOR IS       *
.*       POSITIONED BEFORE THE KEY-ADDRESS PAIR WITH THE LOWEST KEY.  *
.*       THIS STATE CAN ARISE BY REPEATEDLY EXECUTING THE SCANL       *
.*       OPERATION, UNTIL THE CURSOR GOES PAST THE LEFT END OF THE    *
.*       RANGE OF KEYS PRESENT IN THE RPT. IT CAN ALSO ARISE BY USING *
.*       THE DEL MACRO-INSTRUCTION, WHEN THE KEY-ADDRESS PAIR DELETED *
.*       IS THE ONE WITH THE LOWEST KEY. THERE ARE NO OTHER WAYS IT   *
.*       CAN ARISE.                                                   *
.* 2:    THIS STATE REPRESENTS THE CURSOR POSITION AT 3 O'CLOCK, AND  *
.*       IS SIMILAR TO THE 9 O'CLOCK STATE, BUT THE CURSOR IS         *
.*       POSITIONED AFTER THE KEY-ADDRESS PAIR WITH THE HIGHEST KEY.  *
.*       THIS STATE CAN ONLY ARISE IF THE RPT HAS AT LEAST ONE        *
.*       KEY-ADDRESS ASSOCIATION PAIR PRESENT, AND CAN ONLY COME ABOUT*
.*       AS A RESULT OF DELETING THE KEY-ADDRESS PAIR WITH THE HIGHEST*
.*       KEY, OR BY REPEATED EXECUTIONS OF THE SCANR                  *
.*       MACRO-INSTRUCTION, UNTIL THE CURSOR GOES PAST THE RIGHTMOST  *
.*       KEY-ADDRESS PAIR.                                            *
.* 3:    IN THIS STATE THE CURSOR IS POSITIONED AT A SINGLE           *
.*       KEY-ADDRESS PAIR. THIS STATE CAN NOT ARISE UNLESS THERE IS AT*
.*       LEAST ONE KEY-ADDRESS ASSOCIATION PAIR PRESENT IN THE RPT.   *
.*       THIS STATE CAN ARISE AS A RESULT OF EXECUTING THE INS        *
.*       MACRO-INSTRUCTION, BY EXECUTING THE SRCH MACRO-INSTRUCTION,  *
.*       OR BY EXECUTING EITHER THE SCANL OR SCANR MACRO-INSTRUCTIONS.*
.*       THE SRCH MACRO-INSTRUCTION ALWAYS SETS THE CURSOR IN THIS    *
.*       STATE IF THERE IS AT LEAST ONE KEY-ADDRESS PAIR IN THE RPT.  *
.*       IF THERE ARE NO PAIRS PRESENT, THE SRCH MACRO-INSTRUCTION    *
.*       SETS THE CURSOR TO THE EMPTY, OR NULL, STATE.                *
.*       THE INS MACRO-INSTRUCTION ALWAYS SETS THE CURSOR TO THIS     *
.*       STATE.                                                       *
.*       THE SCANL AND SCANR MACRO-INSTRUCTIONS ALWAYS SET THE CURSOR *
.*       TO THIS STATE UNLESS THE CURSOR WAS PREVIOUSLY POSITIONED IN *
.*       THE 8 O'CLOCK OR 4 O'CLOCK POSITION. WHEN THE CURSOR IS IN   *
.*       THE 4 O'CLOCK POSITION AND THE SCANR MACRO-INSTRUCTION IS    *
.*       EXECUTED, THE CURSOR STATE IS STATE 2. WHEN THE CURSOR IS IN *
.*       THE 8 O'CLOCK POSITION AND THE SCANL MACRO-INSTRUCTION IS    *
.*       EXECUTED, THE CURSOR IS POSITIONED IN STATE 1.               *
.* 4:    IN THIS STATE THE CURSOR IS POSITIONED BETWEEN TWO           *
.*       KEY-ADDRESS PAIRS. THIS STATE CAN ONLY ARISE WHEN THERE ARE  *
.*       AT LEAST TWO KEY-ADDRESS PAIRS PRESENT IN THE RPT. THE ONLY  *
.*       OPERATION THAT SETS THE CURSOR TO THIS STATE IS THE DEL      *
.*       OPERATION. THE CURSOR IS SET TO THIS STATE SO THAT IF A SCANR*
.*       OR SCANL OPERATION IS THEN EXECUTED THE CURSOR IS SET AT THE *
.*       KEY-ADDRESS PAIR ON THE RIGHT OF LEFT, RESPECTIVELY, OF THE  *
.*       KEY-ADDRESS PAIR THAT WAS DELETED.                           *
.* 5:    IN THIS STATE THE CURSOR IS IN THE 12 O'CLOCK POSITION. THE  *
.*       ISCAN MACRO-INSTRUCTION IS THE ONLY ONE THAT SETS THE CURSOR *
.*       IN THIS STATE. WHEN THE SCANR MACRO-INSTRUCTION IS EXECUTED  *
.*       WITH THE CURSOR IN THIS STATE, THEN THE CURSOR IS SET TO     *
.*       STATE 3, POSITIONED AT THE KEY-ADDRESS PAIR WITH THE LOWEST  *
.*       KEY. WHEN THE SCANL OPERATION IS EXECUTED WITH THE CURSOR IN *
.*       THIS STATE, THE CURSOR IS SET TO STATE 3, POSITIONED AT THE  *
.*       KEY-ADDRESS PAIR WITH THE HIGHEST KEY. IN THIS WAY THE ISCAN *
.*       MACRO-INSTRUCTION INITIALIZES THE CURSOR FOR SUBSEQUENT      *
.*       SCANNING, REGARDLESS OF WHETHER THE SUBSEQUENT SCANNING IS   *
.*       LEFT TO RIGHT OR RIGHT TO LEFT.                              *
.**********************************************************************
         GBLC  &IGARPT#  GLOBAL VARIABLE FOR RECORDING THE RPT TYPE    *
                         FROM THE T OR TYPE PARAMETER.
         GBLC  &IGAEOPV  OFFSET TO THE PATH CODE IN THE RPT HEADER.
.**********************************************************************
.* CHECK THE TYPE AND T PARAMETERS TO SEE IF A VALID RPT TYPE IS      *
.* SPECIFIED. IF NEITHER IS SPECIFIED, ASSUME IT IS TYPE 8 RPT. THE   *
.* TYPE IS PUT INTO THE GLOBAL VARIABLE &IGARPT# AT THE END OF THE    *
.* TYPE CHECKING SECTION.                                             *
.**********************************************************************
.RPT#    AIF   (K'&T EQ 0).RPT#TMT  SEE IF THE T PARAMETER IS CODED.
         AIF   (K'&TYPE EQ 0).RPT#TCK  USE THE T PARAMETER IF IT IS    *
                         CODED AND THE TYPE PARAMETER IS NOT CODED.
.**********************************************************************
.* BOTH THE T AND TYPE PARAMETERS ARE CODED; SEE IF THEY ARE THE SAME,*
.* AND IF THEY ARE NOT THEN USE T.                                    *
.**********************************************************************
         AIF   ('&T' EQ '&TYPE').RPT#TCK  IF THEY ARE THE SAME THEN USE*
                         T.
         MNOTE 4,'TYPE CONFLICT, ONLY T OR TYPE SHOULD BE CODED.'
.RPT#TCK ANOP
&IGARPT# SETC  '&T'      GET THE RPT TYPE.
         AGO   .RPT#CHK  GO TO CHECK THE VALIDITY OF THE RADIX         *
                         PARTITION TREE TYPE.
.**********************************************************************
.* THE T PARAMETER IS NOT CODED, SEE IF THE TYPE PARAMETER IS CODED.  *
.**********************************************************************
.RPT#TMT AIF   (K'&TYPE EQ 0).RPT#8  IF BOTH ARE LEFT OUT USE TYPE 8   *
                         RPT.
&IGARPT# SETC  '&TYPE'   SET THE TYPE TO THE TYPE THAT IS SPECIFIED BY *
                         THE TYPE PARAMETER.
         AGO   .RPT#CHK  GO CHECK IT FOR VALIDITY.
.RPT#8   ANOP
&IGARPT# SETC  '8'       SET THE RPT TYPE TO 8.
.RPT#CHK AIF   (('&IGARPT#' EQ '8')OR('&IGARPT#' EQ '5')OR('&IGARPT#' E*
               Q '4')).RPT#FIN
         MNOTE 4,'INVALID RPT TYPE, TYPE 8 ASSUMED.'
.RPT#FIN ANOP
      RPTDSECT T=8,DS=NO
.**********************************************************************
         AIF   ('&IGARPT#' EQ '8').ISCANOK  CHECK THE APPLICABILITY OF *
               THE ISCAN OPERATION TO THE RPT OF THE SPECIFIED TYPE.
         MNOTE 12,'ISCAN IS INVALID FOR RPT TYPE &IGARPT#.'
.ISCANOK ANOP
         AIF   (K'&TREE EQ K'&TREE(1)+2).LW1
&TAG     L     1,&TREE
.LW0     ANOP
         OI    &IGAEOPV.(1),B'0110' INITIALIZE FOR SCANNING OPERATIONS.
         AGO   .FIN
.LW1     AIF  ((K'&TAG NE 0)AND('&TREE' EQ '(1)')).LW2
&TAG     LR    1,&TREE
         AGO   .LW0
.LW2     ANOP
&TAG     EQU   *
         AGO   .LW0
.FIN     ANOP
         MEND
         EJECT
         MACRO
&TAG  RPTDSECT &T=,&TYPE=,&LIST=,&SCAN=,&GEN=,&DS=NO
         GBLC  &IGAHVFC  THE OFFSET IN THE RPT HEADER TO THE ADDRESS OF*
                         THE FIXEDHDR FOR THE INNER VERTEX SPACE CHAIN.
         GBLC  &IGABLST  THE OFFSET INTO THE TREE HEADER FOR THE LIST  *
                         OF RPT ENTRY POINTS.
         GBLC  &IGAGKW   THE OFFSET IN THE IGARPT01 MODULE TO THE      *
                         ROUTINE TO GET A WORK AREA FOR COLLECTING     *
                         KEYS.
         GBLC  &IGABFIN  THE SIZE OF THE RESERVED LIST OF ENTRY POINT  *
                         ADDRESSES IN THE TREE HEADER.
         GBLC  &IGASCH8  THE OFFSET IN THE RPT MODULE FOR THE TYPE 8   *
                         SEARCH ROUTINE.
         GBLC  &IGADEL8  THE OFFSET IN THE IGARPT01 MODULE TO THE TYPE *
                         8 RPT DELETE ROUTINE.
         GBLC  &IGAINS8  THE OFFSET IN THE MODULE IGARPT01 TO THE      *
                         ROUTINE TO INSERT IN A TYPE 8 RPT.
         GBLC  &IGALSCN  THE OFFSET TO THE ROUTINE TO SCAN LEFT IN THE *
                         MODULE IGARPT01.
         GBLC  &IGARSCN  THE OFFSET TO THE ROUTINE TO SCAN RIGHT IN THE*
                         MODULE IGARPT01.
         GBLC  &IGASPV   THE OFFSET TO THE PARTIAL ORDER SEARCH ROUTINE*
                         IN THE MODULE IGARPT01.
         GBLC  &IGAPVG   THE OFFSET TO THE ROUTINE TO GET THE PARTIAL  *
                         ORDER VALUE FOR THE CURRENT SINK IN THE MODULE*
                         IGARPT01.
         GBLC  &IGAPVAJ   THE OFFSET TO THE ROUTINE TO ADJUST THE      *
                         PARTIAL ORDER VALUE FOR THE CURRENT SINK IN   *
                         THE IGARPT01 MODULE.
         GBLC  &IGADSP8  THE OFFSET TO THE ROUTINE TO DISPLAY A TYPE 8 *
                         RPT IN THE MODULE IGARPT01.
         GBLC  &IGASRCH,&IGAINS,&IGADEL,&IGAFTRE
         GBLC  &IGAKEYW  THE INDEX OF THE ADDRESS OF THE ROUTINE TO GET*
                         A WORK AREA FOR COLLECTING KEYS FOR SEARCH.
         GBLC  &IGASCNL,&IGASCNR,&IGAFSP
         GBLC  &IGAFSPS  OFFSET FOR THE BRANCH ENTRY TO THE FSPACE     *
                         PROGRAM WHEN THE SPACE CONTROL ADDRESS IS     *
                         CODED IN THE FSPACE MACRO-INSTRUCTION.
         GBLC  &IGAFSPF  BRANCH ENTRY OFFSET FOR FSPACE WITH A FIXED   *
                         LENGTH ENTRY USING A FIXEDHDR.
         GBLC  &IGAFS8,&IGAFS12,&IGAFS80  THE ENTRY POINTS TO RELEASE  *
               ENTRIES OF THE RESPECTIVE LENGTHS USING THE FIXEDHDR IN *
               A SPACE CONTROL AREA.
         GBLC  &IGASTRE,&IGAGSP
         GBLC  &IGAINS5,&IGADEL5
         GBLC  &IGAEOPV  THE OFFSET TO THE PATH CODE BYTE IN THE TYPE 8*
                         RPT HEADER FOR THE PATH TO THE SINK CURRENTLY *
                         SELECTED BY THE CURSOR.
         GBLC  &IGACNT5  THE OFFSET TO THE USE COUNTER IN THE TYPE 5   *
                         RPT HEADER.
         GBLC  &IGAMSK5  THE OFFSET TO THE TABLE OF MASKS FOR TYPE 5   *
                         RPT.
         GBLC  &IGATOP5  THE OFFSET TO THE RPT SOURCE IN THE TYPE 5 RPT*
                         HEADER.
         GBLC  &IGAMAX   THE OFFSET TO THE WORD CONTAINING THE MAXIMUM *
                         PARTIAL ORDER VALUE.
         GBLC  &IGADJPV    ENTRY OFFSET FOR PARTIAL ORDER ADJUSTMENT.
         GBLC  &IGAPVS     ENTRY POINT FOR PARTIAL ORDER SEARCH.
         GBLC  &IGAGPV     ENTRY OFFSET FOR GETTING PARTIAL ORDER VALUE
         GBLC  &IGAISP   BRANCH ENTRY OFFSET FOR SPACE CONTROL SETUP.
         GBLC  &IGAFRSC  BRANCH ENTRY OFFSET TO THE ROUTINE TO RELEASE *
                         A SPACE CONTROL AREA AND ALL OF ITS RELATED   *
                         SPACE VIA THE FREEMAIN MACRO-INSTRUCTION.
         GBLC  &IGAGSPF  BRANCH ENTRY OFFSET FOR FIXED LENGTH ENTRIES  *
                         USING A FIXEDHDR FROM THE GSPACE MACRO OR FROM*
                         INSIDE THE MODULE IGARPT01.
         GBLC  &IGAGSPS  BRANCH ENTRY OFFSET FOR VARIABLE LENGTH SPACE *
                         ALLOCATION WHEN THE SPACE CONTROL ADDRESS IS  *
                         CODED IN THE GSPACE MACRO-INSTRUCTION.
         GBLC  &IGAGS8,&IGAGS12,&IGAGS80  THE BRANCH ENTRY OFFSETS FOR *
                         THE ROUTINES TO ALLOCATE SPACE FOR THE        *
                         RESPECTIVE FIXED LENGTHS IN A SPACE CONTROL A.
         GBLC  &IGACON   THE OFFSET TO THE CONTANT AREA.
         GBLC  &IGANAME    THE NAME OF THE PROGRAM.
         GBLC  &IGADSP         BRANCH ENTRY FOR DSPRPT.
         GBLC  &IGAISCN  THE INDEX OF THE ADDRESS OF THE ROUTINE TO USE*
                         IN THE MODULE IGARPT01 TO INITIALIZE FOR      *
                         SUBSEQUENT SCANNING OPERATIONS FOR SOME RPT'S.
         GBLC  &IGADDR   THE OFFSET TO THE ADDRESS OF THE MODULE       *
                        IGARPT01 FROM THE BEGINNING OF THE TREE HEADER.
         GBLA  &IGALEFT(256)  GLOBAL INDEXED VARIABLE FOR LEFT EDGES
.*                             IN THE BINARY PARSE TREE.
         GBLA  &IGARGHT(256)   GLOBAL VECTOR FOR RIGHT EDGES.
         GBLB  &IGARL(256)     GLOBAL VECTOR FOR RIGHT/LEFT FLAGS.
         GBLB  &IGAIS(256)     GLOBAL VECTOR FOR INNER/SINK STATUS.
         GBLA  &IGAPATH(16)  PATH VECTOR TO ATOMIC ELEMENT IN PARSE.
         GBLA  &IGALEVL      PATH LENGTH TO ATOM IN PARSE TREE.
         GBLB  &IGAOKAY  GLOBAL FOR INDICATING VALID SYNTAX.
         GBLB  &IGAPGM   FOR USE IN IGARPTXX MODULES ONLY.
         GBLB  &IGALOAD  1 IF PGM IS LOADED VIA LOAD MACRO.
         GBLB  &IGAXTRN  1 IF THE EXTRN HAS BEEN GENERATED.
         GBLB  &IGALONE  ON FOR STAND-ALONE OPERATION OF THE RPTS      *
               COMPONENT FOR UNIT TESTING.
         GBLB  &IGAFTCH  ON TO FAKE OUT THE CVTRPT AND TCBRPT LOADS    *
                         WHEN THE RPTS COMPONENT IS BEING UNIT TESTED.
         GBLC  &IGARPT#  RADIX PARTITION TREE TYPE.
         GBLB  &RPTVNUM(16)    INDEXED GLOBAL LOGICAL VECTOR FOR C
.*                             CONTROLLING THE GENERATION OF DSECTS.
         GBLB  &IGASPDS  THIS BIT IS ON IF THE SPACE CONTROL DSECT HAS *
                         ALREADY BEEN GENERATED.
         GBLC  &IGASA0   OFFSET TO THE FIRST SAVE AREA.
         GBLC  &IGASA1   OFFSET TO THE SECOND SAVE AREA IN THE SPACE   *
                         CONTROL AREA.
         GBLC  &IGAS8    THE OFFSET TO THE 8-BYTE FREE SPACE CHAIN.
         GBLC  &IGAS12   THE OFFSET TO THE 12-BYTE FREE SPACE CHAIN.
         GBLC  &IGAS80   THE OFFSET TO THE 80-BYTE FREE SPACE CHAIN.
         GBLC  &IGASPZ   LENGTH OF THE SPACE CONTROL AREA.
         GBLA  &IGAMINP  THE MINIMUM SIZE NEEDED FOR A TYPE 8 TREE.
         GBLA  &IGAMINS  THE MINIMUM REFILL SIZE NEEDED FOR A TYPE 8.
         GBLA  &IGAX     TRIPLE FOR LEFT LIST SCAN OF THE BINARY PARSE
         GBLA  &IGAY     TREE THAT RESULTS FROM EXECUTING RPTDSECT WITH
         GBLA  &IGAZ     THE LIST PARAMETER CODED.
         LCLA  &N        A LOCAL TEMPORARY INDEX FOR SUBSCRIPTING
.*                       INDEXED VARIABLES.
.*A000000                                                        Y02147
.**********************************************************************
         LCLA  &X        STRING SCANNER.
         LCLA  &Y        LIMIT OF NUMBER OF ELEMENTS.
         LCLC  &CHAR     CURRENT LIST CHARACTER.
         LCLA  &P        PREDECESSOR OF CURRENT VERTEX IN PARSE TREE.
         LCLA  &C        CURRENT VERTEX IN PARESE TREE.
         LCLA  &S        SUCCESSOR OF CURRENT VERTEX IN PARSE TREE.
         LCLA  &NX       INDEX OF NEXT AVAILABLE VERTEX.
&IGAXTRN SETB  (0)   TURN OFF THE EXTRN SYMBOL IN STREE.
         AIF   (K'&GEN NE 0).GEN  GO IF THE GEN PARAMETER IS CODED.
         AIF   (K'&T EQ 0).OLDT  SEE IF THE NEW TYPE IS CODED.
&TAG  RPTDSECT TYPE=&T,LIST=&LIST,SCAN=&SCAN,DS=&DS,GEN=&GEN
         AGO   .FIN
.OLDT    ANOP
         AIF   (K'&TAG EQ 0).NOTAG  SEE IF THERE IS A LABEL ON IT.
&TAG     EQU   *
.NOTAG   ANOP
         AIF   ((K'&SCAN NE 0) OR (K'&TYPE NE 0)).GOOD  CHK 4 AT LEAST
.*                                                   1 OPERAND.
         MNOTE 12,'NO KEYWORDS CODED FOR RPTDSECT; &SCAN CODED.'
         MEXIT
.GOOD    ANOP
&IGARPT# SETC  '&TYPE'   SET THE RPT #.
         AIF   (K'&TYPE NE 0).VERSION  CHECK FOR RPT TYPE.
         AIF   (('&SCAN' EQ 'NEXT')OR('&SCAN' EQ 'ISCAN')).ITSCAN
         AIF   ('&SCAN' EQ 'PARSE').PARSE          CHECK FOR PARSE REQ.
         MNOTE 12,'SCAN PARAMTER INCORRECT IN RPTDSECT; &SCAN CODED.'
         MEXIT
.PARSE   ANOP
.*--------------------------------------------------------------------*
.*       PARSE THE LIST INTO A BINARY PARSE TREE.                     *
.*--------------------------------------------------------------------*
&X       SETA  (1)       SET &X TO THE INDEX OF THE FIRST CHARACTER IN
.*                       THE STRING TO BE PARSED.
&Y       SETA  (1+K'&LIST)     SET &Y TO THE INDEX OF THE FIRST
.*                             CHARACTER POSITION AFTER THE LAST
.*                             CHARACTER IN THE STRING TO BE PARSED.
&P       SETA  1         SET &P TO THE SOURCE OF THE PARSE TREE.
&C       SETA  1         SET &C TO THE SOURCE OF THE PARSE TREE.
&NX      SETA  1         SET &NX TO ONE LESS THAN THE NEXT AVAILABLE
.*                       VERTEX.
&IGARL(&C)     SETB      (0)   SET THE SOURCE TO A LEFT SUCCESSOR.
&IGAIS(&C)     SETB      (1)   SET THE SOURCE AS AN INNER VERTEX.
.**********************************************************************
.*       IS THERE A LEFT EDGE FROM THE CURRENT VERTEX?                *
.**********************************************************************
.ISLEFT  ANOP
         AIF   (&X EQ &Y).LEOS GO IF THE END OF STRING REACHED.
&CHAR    SETC  '&LIST'(&X,1)   EXTRACT THE CURRENT CHARACTER.
&X       SETA  (&X+1)          EKE THE INDEX TO THE NEXT CHARACTER.
         AIF   ('&CHAR' EQ '(').LLPAREN  AGO IF LEFT PAREN FOUND.
         AIF   ('&CHAR' EQ ')').LRPAREN  AGO IF RIGHT PAREN FOUND.
         AIF   ('&CHAR' EQ ',').LCOMMA   AGO IF COMMA FOUND.
.*--------------------------------------------------------------------*
.* THE LEFT EDGE GOES TO AN ATOMIC SYMBOL, COLLECT THE SYMBOL AND PUT *
.* THE LEFT EDGE OF THE CURRENT VERTEX GOING TO IT.                   *
.*--------------------------------------------------------------------*
&NX      SETA  (1+&NX)   ESTABLISH PLACE TO PUT THE DEFINITION OF ATOM.
&IGALEFT(&NX) SETA (&X-1)      INDEX OF FIRST CHARACTER OF ATOM.
.COLLECT ANOP
         AIF   (&X EQ &Y).STORE2       SEE IF EOS AFTER ATOM.
&CHAR    SETC  '&LIST'(&X,1)   PICK OUT THE NEXT CHARACTER.
&X       SETA  (&X+1)    EKE INDEX TO NEXT CHARACTER.
         AIF   ('&CHAR' EQ '(').STORE  AGO IF ATOM ALL COLLECTED.
         AIF   ('&CHAR' EQ ')').STORE  AGO IF ATOM ALL COLLECTED.
         AIF   ('&CHAR' NE ',').COLLECT  AGO IF ATOM NOT YET COLLECTED.
.STORE   ANOP
&IGARGHT(&NX) SETA (&X-(1+&IGALEFT(&NX)))  COMPUTE LENGTH OF ATOM.
&IGALEFT(&C) SETA (&NX-&P)  FILL IN LEFT EDGE TO ATOM.
&IGARL(&NX) SETB (0)     FLAG AS LEFT SUCCESSOR.
&IGAIS(&NX)  SETB (0)    FLAG AS A SINK.
         AGO   .RIGHTIN        INTERROGATE CHARACTER.
.STORE2  ANOP
&IGARGHT(&NX) SETA (&X-(&IGALEFT(&NX)))  COMPUTE LENGTH OF ATOM.
&IGALEFT(&C) SETA (&NX-&P)     FILL IN LEFT EDGE TO ATOM.
&IGARL(&NX) SETB (0)     FLAG ATOMIC VERTEX AS LEFT SUCCESSOR.
&IGAIS(&NX) SETB (0)     FLAG ATOMIC VERTEX AS A SINK.
         AGO   .REOS     GO TO RIGHT EOS SEQUENCE.
.*--------------------------------------------------------------------*
.* THE LEFT EDGE GOES TO AN EMPTY LIST, SINCE THE CURRENT CHARACTER   *
.* IS A COMMA.                                                        *
.*--------------------------------------------------------------------*
.LCOMMA  ANOP
&IGALEFT(&C) SETA (0-&P)  SET THE LEFT EDGE EMPTY.
         AGO   .MAKRGHT        GO ESTABLISH A RIGHT SUCCESSOR.
.*--------------------------------------------------------------------*
.* THERE IS A LIST FOR THE LEFT SUCCESSOR, BECAUSE THE CURRENT        *
.* CHARACTER IS A LEFT PARENTHESIS.                                   *
.*--------------------------------------------------------------------*
.LLPAREN ANOP
&NX      SETA  (&NX+1)   ESTABLISH A LEFT SUCCESSOR INNER VERTEX.
&IGARL(&NX) SETB (0)  MAKE NEW INNER VERTEX A LEFT SUCCESSOR.
&IGAIS(&NX) SETB (1)  MAKE NEW VERTEX AN INNER VERTEX.
&IGALEFT(&C) SETA (&NX-&P)     FILL IN LEFT SUBTRACTION INVERTIBLE EDGE
.*                             TO THE NEW LEFT INNER VERTEX.
&P       SETA  (&C)      TRACE THE EDGE TO THE NEW LEFT INNER VERTEX.
&C       SETA  (&NX)     XX
         AGO   .ISLEFT   GO BACK TO LOOK FOR A LEFT EDGE.
.*--------------------------------------------------------------------*
.* THERE IS NO LEFT EDGE, BECAUSE THE CURRENT CHARACTER IS A RIGHT    *
.* PARENTHESIS. NOW THE BACKPATH MUST BE TRACED TO THE MATCHING LEFT  *
.* PARENTHESIS.                                                       *
.*--------------------------------------------------------------------*
.LRPAREN ANOP
&IGALEFT(&C) SETA (0-&P)  SET LEFT INVERTIBLE SUBTRACTION EDGE EMPTY.
.RRPAREN ANOP
&IGARGHT(&C) SETA (0-&P)  ESTABLISH A NULL RIGHT EDGE TOO.
.*--------------------------------------------------------------------*
.* TRACE THE BACKPATH TO FIND THE FIRST LEFT SUCCESSOR ON THE WAY TO  *
.* THE SOURCE. THAT VERTEX SHOULD BE THE PREDECESSOR OF THE FIRST     *
.* VERTEX IN THE SUBLIST THAT STARTED WITH THE LEFT PARENTHESIS THAT  *
.* MATCHED THE CUURENT RIGHT PARENTHESIS.                             *
.*--------------------------------------------------------------------*
         AIF   (NOT &IGARL(&C)).RPISBAK  GO IF &C IS A LEFT SUCCESSOR.
.RPBACK  ANOP
&S       SETA  (&C)      CYCLE THE THREE VERTICES UP THE BACKPATH.
&C       SETA  (&P)      XX
&P       SETA  (&S-&IGARGHT(&C))  TRACE THE RIGHT EDGE BACKWARD.
         AIF   (&IGARL(&C)).RPBACK     TRACE UNTIL IT FINDS A LEFT SIDE
.*--------------------------------------------------------------------*
.RPISBAK ANOP
         AIF   (&C EQ 1).ERROR  SEE IF THE SOURCE WAS REACHED; I. E.
.*                              NO MATCHING LEFT PARENTHESIS.
&S       SETA  (&C)      TRACE THE EDGE BACK TO THE PREDECESSOR OF
&C       SETA  (&P)      THE FIRST LEFT SUCCESSOR FOUND ON THE
&P       SETA  (&S-&IGALEFT(&C))  BACKPATH.
         AGO   .ISRIGHT
.*--------------------------------------------------------------------*
.* THERE IS NO LEFT OR RIGHT EDGE, BECAUSE THE END OF THE STRING      *
.* HAS BEEN ENCOUNTERED.                                              *
.*--------------------------------------------------------------------*
.LEOS    ANOP
&IGALEFT(&C) SETA (0-&P)  SET LEFT INVERTIBLE EDGE NULL.
.REOS    ANOP
&IGARGHT(&C) SETA (0-&P)  SET RIGHT INVERTIBLE EDGE NULL.
         AIF   (NOT &IGARL(&C)).EOSBAK  CONTINUE UNTIL THE FIRST LEFT.
.EOSBACK ANOP
&S       SETA  (&C)      TRACE THE BACKPATH TO THE FIRST LEFT
&C       SETA  (&P)            SUCCESSOR.
&P       SETA  (&S-&IGARGHT(&C))
         AIF   (&IGARL(&C)).EOSBACK    CHECK FOR A RIGHT SUCCESSOR.
.EOSBAK  ANOP
         AIF   (&C NE 1).ERROR
&IGAOKAY SETB  (1)       INDICATE VALID SYNTAX.
         MEXIT
.**********************************************************************
.* IS THERE A RIGHT EDGE?                                             *
.**********************************************************************
.ISRIGHT ANOP
         AIF   (&X EQ &Y).REOS  GO IF END OF STRING REACHED.
&CHAR    SETC  '&LIST'(&X,1)   GET CURRENT CHARACTER.
&X       SETA  (&X+1)    EKE TO NEXT CHARACTER.
.RIGHTIN ANOP
         AIF   ('&CHAR' EQ ',').MAKRGHT
         AIF   ('&CHAR' EQ ')').RRPAREN
         AGO   .ERROR
.*--------------------------------------------------------------------*
.* THERE IS A RIGHT EDGE, THE CURRENT CHARACTER IS A COMMA.           *
.*--------------------------------------------------------------------*
.MAKRGHT ANOP
&NX      SETA  (&NX+1)   GET A PLACE FOR THE NEW RIGHT SUCCESSOR.
&IGARL(&NX) SETB (1)     INDICATE RIGHT SUCCESSOR.
&IGARGHT(&C) SETA (&NX-&P)  STORE RIGHT INVERTIBLE EDGE.
&IGAIS(&NX) SETB (1)     INDICATE AN INNER VERTEX.
&P       SETA  (&C)      TRACE OVER TO THE NEW RIGHT SUCCESSOR.
&C       SETA  (&NX)     XX
         AGO   .ISLEFT
.*--------------------------------------------------------------------*
.ERROR   ANOP
&IGAOKAY SETB  (0)       INDICATE INVALID SYSNTAX.
         MEXIT
.**********************************************************************
.ITSCAN  AIF   ('&SCAN' NE 'ISCAN').TRYNEXT  GO IF NOT 1ST INITIALIZE.
.* INITIALIZE FOR LEFT LIST SCANNING.                                 *
.*--------------------------------------------------------------------*
&IGAX    SETA  (1)       SET IT TO THE SOURCE.
&IGAY    SETA  (0)       SIGNAL THAT ISCAN HAS BEEN DONE.
&IGAZ    SETA  (0)       DON'T CAUSE ANY CONFUSION.
&IGALEVL SETA  (0)
         MEXIT
.*--------------------------------------------------------------------*
.*  COME HERE FOR THE REAL SCANNING, AFTER THE ISCAN.                 *
.*--------------------------------------------------------------------*
.TRYNEXT AIF   ('&SCAN' EQ 'NEXT').DONEXT
         MNOTE 12,'INVALID SCAN, NEXT OR ISCAN EXPECTED.'
&IGAZ    SETA  0         MAYBE IT WILL WORK ANYWAY.
         MEXIT
.DONEXT  AIF   (&IGAY NE 0).NOT1ST  CHECK FOR FIRST TIME.
.*--------------------------------------------------------------------*
.*  FIRST TIME INTO TREE FOR LEFT LIST SCAN.                          *
.*--------------------------------------------------------------------*
&IGAY    SETA  (1)       SET IT TO THE SOURCE.
         AGO   .CHKLEFT  GO LOOK AT THE LEFT SUBTREE.
.TREF    ANOP
&IGAPATH(&IGALEVL) SETA (&IGAPATH(&IGALEVL)+1)  EKE PATH VECTOR ELEMENT
         AGO   .TEDGF                           ON THE SAME LEVEL.
.TLEF    ANOP
&IGALEVL SETA  (1+&IGALEVL)  MAKE PATH VECTOR LONGER TO ATOM.
&IGAPATH(&IGALEVL) SETA (0)  SET PATH VECTOR ELEMENT TO ZERO.
.TEDGF   ANOP
&IGAX    SETA  (&IGAY)   CYCLE THE THREE DOWN THE PATH.
&IGAY    SETA  (&IGAZ)   XX
.CHKLEFT ANOP
&IGAZ    SETA  (&IGAX+&IGALEFT(&IGAY))  TRACE LEFT EDGE (IF THERE IS 1)
         AIF   (&IGAZ NE 0).TRYLEFT    SEE IF THERE WAS A LEFT EDGE.
         MEXIT
.TRYLEFT AIF   (&IGAIS(&IGAZ)).TLEF    SEE IF THE SINK WAS REACHED.
         AIF   (&IGARGHT(&IGAZ) NE 0).FINZ  SEE IF MT SINK.
&IGAZ    SETA  (0)       PRETEND EMPTY CHARACTER STRINGS AREN'T THERE.
.FINZ    MEXIT
.*--------------------------------------------------------------------*
.*   INSPECT THE RIGHT SUBTREE.                                       *
.*--------------------------------------------------------------------*
.CHKRGHT ANOP
.NOT1ST  ANOP
&IGAZ    SETA  (&IGAX+&IGARGHT(&IGAY))  GET RIGHT SUCCESSOR (IF ANY).
         AIF   (&IGAZ NE 0).TREF       GO IF THERE IS ONE.
.CHKTOP  AIF   (&IGAY EQ 1).SOURCE     SEE IF SOURCE REACHED FROM RIGHT
         AIF   (&IGARL(&IGAY)).TREB  GO IF Y IS RIGHT SUCCESSOR.
&IGAZ    SETA  (&IGAY)   TRACE THE LEFT EDGE BACKWARD.
&IGAY    SETA  (&IGAX)   BACKPATH TRACE.
&IGAX    SETA  (&IGAZ-&IGALEFT(&IGAY))  BACKTRACE LEFT EDGE.
&IGALEVL SETA  (&IGALEVL-1)  GO BACK TO NEXT LOWER LEVEL.
         AGO   .CHKRGHT
.TREB    ANOP
&IGAPATH(&IGALEVL) SETA (&IGAPATH(&IGALEVL)-1)  DECREASE ELEMENT IN PV.
&IGAZ    SETA  (&IGAY)   BACKAPTH TRACE VIA THE RIGHT EDGE.
&IGAY    SETA  (&IGAX)   XX
&IGAX    SETA  (&IGAZ-&IGARGHT(&IGAY))  TRACE LEFT INVERTIBLE EDGE BACK
         AGO   .CHKTOP
.SOURCE  ANOP
&IGAX    SETA  (0)  SET THE EOP TRIPLE ACCORDINGLY.
&IGAY    SETA  (0)  XX
&IGAZ    SETA  (0)       THE WHOLE TREE HAS BEEN PROCESSED.
         MEXIT
.**********************************************************************
.VERSION ANOP
&IGABLST SETC  'X''20'''  SET THE OFFSET INTO THE TREE HEADER FOR THE  *
                         LIST OF ENTRY POINTTS.
         AIF   (K'&GEN NE 0).GEN  SEE IF THE GEN PARAMETER IS CODED.
         AIF   ('&IGARPT#' EQ 'SPACE').SPACNTL  SHOULD THE SPACE CONTROL
                         DSECT BE GENERATED?
&N       SETA  (&IGARPT#)  CONVERT THE TREE TYPE TO A #.
         AIF   (&RPTVNUM(&N)).FIN  IF IT'S ALREADY DONE, SKIP IT.
         AIF   (('&DS' EQ 'NO')OR('&DS' EQ '0')).LETIT  SEE IF THIS IS *
                         NOT REALLY A REQUEST TO GENERATE THE DSECT.
&RPTVNUM(&N) SETB (1)          SET IT ON SO IT DOESN'T DO IT AGAIN.
.LETIT   ANOP
         AIF   (&N EQ 8).RPTV8
         AIF   (&N EQ 5).RPTV5
         MNOTE 12,'INVALID TREE TYPE SPECIFIED.'
         AGO   .FIN
.RPTV5   ANOP
&IGADDR  SETC  'X''00'''  THE OFFSET TO THE ADDRESS OF THE MODULE      *
                         IGARPT01 FROM THE BEGINNING OF THE TREE HEADER.

&IGATOP5 SETC  'X''04'''  THE OFFSET TO THE SOURCE OF THE TYPE 5 RPT IN*
                         THE TYPE 5 TREE HEADER.
&IGACNT5 SETC  'X''0C'''  THE OFFSET TO THE USE COUNTER IN THE TYPE 5  *
                         RPT HEADER.
&IGAMSK5 SETC  'X''80'''  OFFSET TO THE TABLE OF MASKS IN THE TYPE 5   *
                         RPT HEADER.
         AIF   (('&DS'(1,1) EQ 'N')OR('&DS'(1,1) EQ '0')).RPT5END      *
                         SEE IF THE DSECT IS NOT SUPPOSED TO BE        *
                         GENERATED THIS TIME.
IGARPTH5 DSECT 0         DSECT FOR SRCH5, INS5, DEL5.
IGADDR5  DC    F'0'  THE ADDRESS OF IGARPT01.
IGATOP5  DC    F'0'      SOURCE OF BINARY TREE.
IGAHVFC5 DC    F'0'      HEAD OF INNER VERTEX FREE CHAIN.
IGACNT5  DC    F'0'      COUNTER FOR READ-ONLY VALIDATION.
IGAKEYI5 DC    H'0'      INDEX OF KEY IN RECORD.
IGAKEYL5 DC    XL1'00'   THE NUMBER OF BYTES IN THE KEY.
IGASP5   DC    XL1'00'   THE SUBPOOL NUMBER FOR GETMAINS.
IGA5MARK EQU   *  THE BYTE JUST PAST THE LAST THING BEFORE THE B-LIST.
         DC    (&IGAMSK5-(IGA5MARK-IGARPTH5))XL1'00'  LEAVE ROOM.
IGAMASKS DC    128XL1'FF'  THIS IS FILLED IN BY STREE, TYPE=5.
IGAMASKZ EQU   *
         CNOP  0,8       MAKE IT ON A DOUBLE WORD BOUNDARY.
IGAFIN5  EQU   *         FIRST BYTE PAST HEADER.
IGATYP5S EQU   IGAFIN5-IGARPTH5  TREEHDR SIZE FOR TYPE 5 TREE.
&SYSECT CSECT
IGAZERO  EQU   0         JUST A ZERO.
IGABASE5 EQU   1         THE ADDRESS OF THE TREEHDR.
IGAP5    EQU   2         REGISTER CONTAINING ANTEPENULTIMATE VERTEX.
IGAC5    EQU   3         REGISTER CONTAINING THE PENULTIMATE VERTEX.
IGAS5    EQU   15        REGISTER CONTAINING THE SINK ADDRESS.
IGACREG5 EQU   14        REGISTER TO HOLD THE COUNTER DURING THE SEARCH
IGASARG5 EQU   0         REGISTER CONTAINING THE SEARCH ARGUMENT.
.RPT5END ANOP
.RPTV8   ANOP
&IGADDR  SETC  'X''00'''  THE OFFSET TO THE ADDRESS OF THE MODULE      *
                         IGARPT01 FROM THE BEGINNING OF THE TREE HEADER.

&IGAHVFC SETC  'X''14'''  OFFSET TO THE IV FREE SPACE BLOCK ADDRESS.
&IGANAME SETC  'IGARPT01'  THE NAME OF THE MODULE.
&IGASRCH SETC  'X''0'''
&IGAINS  SETC  'X''04'''  SET THE INDEX OF THE ENTRY POINT TO INSERT A *
                         KEY-ADDRESS PAIR IN THE RPT.
&IGADEL  SETC  'X''08'''  SET THE INDEX OF THE DELETE ENTRY POINT.
&IGADSP  SETC  'X''0C'''  SET THE INDEX OF THE ENTRY POINT TO DISPLAY  *
                         THE TREE.
&IGAKEYW SETC  'X''10'''  INDEX OF THE ENTRY POINT WORD FOR OBTAINING  *
                         THE ADDRESS OF THE KEY WORK AREA.
&IGAISCN SETC  'X''14'''  INDEX OF THE ENTRY POINT WORD TO INITIALIZE  *
                         FOR SCANNING.
&IGASCNL SETC  'X''18'''  ENTRY POINT FOR SCANNING LEFT.
&IGASCNR SETC  'X''1C'''  ENTRY POINT FOR SCANNING RIGHT.
&IGAPVS  SETC  'X''20'''  INDEX OF ENTRY POINT FOR PARTIAL ORDER VALUE *
                         SEARCH.
&IGAGPV  SETC  'X''24'''  INDEX OF ENTRY POINT ADDRESS FOR GETTING THE *
                         PARTIAL ORDER VALUE FOR THE CURRENT SINK.
&IGADJPV SETC  'X''28'''  ENTRY POINT ADDRESS FOR ADJUSTING THE PARTIAL*
                         ORDER VALUE FOR THE CURRENT SINK.
&IGABFIN SETC  'X''40'''  THE SIZE OF THE LIST OF ENTRY POINT WORDS IN *
                         THE RPT HEADER.
&IGASCH8 SETC  'X''0'''  THE OFFSET INTO THE IGARPT01 MODULE FOR THE   *
                         TYPE 8 RPT SEARCH ROUTINE.
&IGADEL8 SETC  'X''180'''  THE OFFSET TO THE TYPE 8 RPT DELETE ROUTINE *
                         IN THE IGARPT01 MODULE.
&IGADEL5 SETC  'X''2A0'''
&IGAINS5 SETC  'X''300'''  BRANCH ENTRY OFFSET FOR INSERT INTO A TYPE 5*
                         RPT.
&IGAINS8 SETC  'X''450'''  THE OFFSET TO THE TYPE 8 INSERT ROUTINE IN  *
                         THE IGARPT01 MODULE.
&IGALSCN SETC  'X''4B0'''  THE OFFSET TO THE ROUTINE TO SCAN LEFT IN   *
                         THE IGARPT01 MODULE.
&IGARSCN SETC  'X''4D0'''  THE OFFSET TO THE ROUTINE TO SCAN RIGHT IN  *
                         THE IGARPT01 MODULE.
&IGAISP  SETC  'X''640'''
&IGAFRSC SETC  'X''680'''
&IGAGSPS SETC  'X''780'''  LOCATION OF THE GSPACE ROUTINE FOR VARIABLE *
                         LENGTH AREAS WHEN THE SPCA IS PROVIDED.
&IGAGSP  SETC  'X''790'''
&IGAGS8  SETC  'X''900'''
&IGAGS12 SETC  'X''920'''
&IGAGS80 SETC  'X''940'''
&IGAGSPF SETC  'X''960'''
&IGAFSP  SETC  'X''9E0'''
&IGAFSPS SETC  'X''A40'''  ENTRY LOCATION FOR VARIABLE LENGTH          *
                         FSPACE WITH THE SPCA CODED.
&IGAFS8  SETC  'X''BC0'''  BRANCH ENTRY OFFSET FOR FIXED LENGTH FSPACE *
                         FOR 8 BYTES.
&IGAFS12 SETC  'X''BE0'''  BRANCH ENTRY OFFSET FOR FIXED LENGTH FSPACE *
                         FOR 12 BYTES.
&IGAFS80 SETC  'X''C00'''  ENTRY POINT FOR FSPACE FOR FIXED LENGTH 80  *
                         BYTES.
&IGAFSPF SETC  'X''C20'''  ENTRY POINT FOR FSPACE WITH A FIXEDHDR.
&IGASPV  SETC  'X''C40'''  THE OFFSET TO THE PARTIAL ORDER SEARCH      *
                         ROUTINE IN THE MODULE IGARPT01.
&IGAPVG  SETC  'X''D20'''  THE OFFSET TO THE ROUTINE TO GET THE PARTIAL*
                         ORDER VALUE FOR THE CURRENT SINK.
&IGAPVAJ  SETC 'X''DA0'''  THE OFFSET TO THE ROUTINE TO ADJUST THE     *
                         PARTIAL ORDER VALUE FOR THE CURRENT SINK.
&IGADSP8 SETC  'X''ED8'''  THE OFFSET TO THE ROUTINE TO DISPLAY A TYPE *
                         8 RPT.
&IGASTRE SETC  'X''EE8'''  ENTRY POINT TO SET UP A RADIX PARTITION     *
                         TREE.
&IGACON  SETC  'X''F00'''
&IGAGKW  SETC  'X''F90'''  OFFSET TO ROUTINE TO GET A KEY WORK AREA.
&IGAEOPV SETC  'X''04'''  THE OFFSET TO THE PATH CODE BYTE IN THE TYPE *
                         8 RPT HEADER.
&IGAMAX  SETC  'X''24'''  THE OFFSET TO THE WORD CONTAINING THE MAXIMUM*
                         PARTIAL ORDER VALUE.
         AIF   ('&IGARPT#' NE '8').FIN  SEE IF THIS IS NOT EVEN REALLY *
               A TYPE 8 RADIX PARTITION TREE.
         AIF   ('&DS'(1,1) EQ 'N').FIN  SEE IF THE DSECT SHOULD BE     *
                         GENERATED THIS TIME.
         AIF   ('&DS'(1,1) EQ '0').FIN  SEE IF IT ISN'T THIS TIME.
IGARPTH  DSECT 0  PARAMETER LIST FOR TREE ROUTINES.
IGADDR   DC    XL4'00'  THIS IS THE BASE ADDRESS OF THE PROGRAM.
IGAPT    DC    F'0'  THE ADDRESS OF THE TREE SOURCE DOUBLE WORD.
         ORG   IGAPT
IGAPATH  DC    XL1'00'  THE PATH CODE BYTE.
         DC    AL3(0)  ADDRESS OF THE SOURCE OF THE TREE.
IGANTPEN DC    XL4'00'   ADDRESS OF ANTEPENULTIMATE VERTEX ON PATH.
IGAPENLT DC    F'0'      ADDRESS OF PENULTIMATE VERTEX ON PATH.
IGAFARG  DC    F'0'  THE ADDRESS OF THE KEY OF THE RECORD FOUND BY SRCH
IGAHVFC  DC    F'0'  THE ADDRESS OF THE INNER SPACE FIXEDHDR.
IGAKEYL  DC    H'0'  THE LENGTH OF A KEY IN BYTES.
IGAKEYI  DC    H'0'  THE 0-ORIGIN INDEX OF THE FIRST BYTE OF THE KEY
*                    IN THE RECORD.
IGAMAP   DC    F'0'      THE ADDRESS OF THE SUBROUTINE TO MAP AN       *
                         ASSOCIATED # TO AN ADDRESS OF AN AREA         *
                         CONTAINING THE CORRESPONDING KEY.
IGA9FILL DC    F'0'      THE REFILL SUBPOOL AND LENGTH FOR TYPE 9      *
                         VARIABLE LENGTH SPACE ALLOCATION TREES.
         CNOP  0,4   IGAMAX IS ON A 4-BYTE BOUNDARY.
IGAMAX   DC    F'0'   MAXIMUM VALUE FOR PARTIALLY ORDERED TREES.
IGAVALUE DC    F'0'  THE PARTIAL ORDER VALUE FOR SEMILATTICE CONDITION.
IGAWORK  DC    F'0'  WORK AREA FOR TYPE 9 RPT POV.
IGAPOV   EQU   8  INDEX OF PARTIAL ORDER VALUE IN INNER VERTEX.
         ORG   IGARPTH+&IGABLST  PUT THE LIST OF THE ENTRY POINTS FOR  *
                         THE VARIOUS OPERATIONS IN THE RIGHT PLACE.
IGASRCH  DC    F'0'      THE ADDRESS OF THE SEARCH ROUTINE FOR THIS    *
                         TYPE RPT.
IGAINS   DC    F'0'      THE ADDRESS OF THE INSERT ROUTINE FOR THE RPT.
IGADEL   DC    F'0'      THE ADDRESS OF THE DELETE ROUTINE FOR THE RPT.
IGADSP   DC    F'0'      THE ADDRESS OF THE ROUTINE TO DISPLAY THE RPT.
IGAKEYW  DC    F'0'      EITHER THE ADDRESS OF THE WORK AREA TO COLLECT*
                         KEYS OR THE ADDRESS OF THE ROUTINE TO SET ONE *
                         UP.
IGAISCN  DC    F'0'  THE ADDRESS TO LINK TO TO INITIALIZE FOR SCANNING.
IGASCNL  DC    F'0'      THE ADDRESS OF THE SCAN LEFT ROUTINE.
IGASCNR  DC    F'0'      THE ADDRESS OF THE SCAN RIGHT ROUTINE.
IGAPVS   DC    F'0'      THE ADDRESS OF THE PARTIAL ORDER VALUE SEARCH *
                         ROUTINE.
IGAGPV   DC    F'0'      THE ADDRESS OF THE ROUTINE TO OBTAIN THE      *
                         PARTIAL ORDER VALUE FOR THE CURRENT SINK.
IGADJPV  DC    F'0'      THE ADDRESS OF THE ROUTINE TO ADJUST THE      *
                         PARTIAL ORDER VALUE FOR THE CURRENT SINK.
IGABFIN  EQU   *
         DC    (X'40'+IGABFIN-IGARPTH)XL1'00'  FILL OUT THE REST OF THE*
                         RPT ENTRY POINT AREA.
IGAFIN8  EQU   *  BYTE PAST TREE HEADER FOR TYPE 8 AND 9 RPT.
IGATYP8S EQU   IGAFIN8-IGARPTH  TREE HEADER SIZE FOR TYPE 8 AND 9 RPT.
IGANEBIT EQU   B'00010000'  FLAG BIT TO INDICATE SUBTREE CONTAINS
*                           UNEQUAL KEYS.
IGASTBIT EQU   B'00001000'  SUBTREE OF KNOWN ORDER SELECTION BIT.
IGARLBIT EQU   B'00000100'  RIGHT/LEFT SUCCESSOR FLAG BIT.
IGAT0BIT EQU   B'00000010'  LEFT INNER VERTEX FLAG BIT.
IGAT1BIT EQU   B'00000001'  INNER VERTEX RIGHT EDGE FLAG BIT.
&SYSECT  CSECT
         AIF   (NOT &IGAPGM).NOSHORT  SKIP THE SHORT LABELS IF NOT RPT.
         RASS  (APT,IGAPT,PATH,IGAPATH,FARG,IGAFARG)
         RASS  (HVFC,IGAHVFC,KEYL,IGAKEYL)
         RASS  (OFFSET,IGAKEYI,AP,IGANTPEN,AC,IGAPENLT)
         RASS  (TREEHDR,IGARPTH,KEYWORK,IGAWORK,VALUE,IGAPOV)
         RASS  (TREEFIN,IGAFIN8,TREESZ,IGATYP8S)
         RASS  (NE,IGANEBIT,IGAQBIT,IGASTBIT,Q,IGAQBIT,RL,IGARLBIT)
         RASS  (T0,IGAT0BIT,T1,IGAT1BIT,KEYI,IGAKEYI)
.NOSHORT ANOP
         AGO   .FIN      ALL DONE, NOW EXIT FROM RPTDSECT.
.SPACNTL AIF   (&IGASPDS OR ('&DS'(1,1) EQ 'N')).NOSPDS  SEE IF THE    *
                         DSECT SHOULD BE GENERATED, OR JUST THE GLOBAL *
                         VARIABLE SYMBOLS.
&IGASPDS SETB  (1)     SET THE BIT SO THAT IT ONLY GETS GENERATED ONCE.
IGASPCTL DSECT 0         SPACE CONTROL DSECT FOR THE FSPACE AND GSPACE *
                         MACRO-INSTRUCTIONS.
IGARPT9  DC    12F'0'    THE TREE HEADER FOR THE TYPE 9 SPACE CONTROL  *
                         FITS IN THESE 12 WORDS.
IGASPEDG DC    F'0' THIS IS THE HEAD OF THE DEFINITION WORD CHAIN FOR *
*              SPACE CONTROL AREAS FOR SUBPOOLS OTHER THAN SUBPOOL    *
*              ZERO. THIS IS ONLY THE HEAD OF THE CHAIN FOR THE SPACE *
*              CONTROL AREA FOR SUBPOOL ZERO, HOWEVER; IN THE SPACE   *
*              CONTROL AREA FOR THE OTHER SUBPOOLS IT IS THE ADDRESS  *
*              OF THE SPACE CONTROL AREA FOR SUBPOOL ZERO.            *
IGAROUND DC    XL4'FFFFFFF0'  THIS IS THE MASK TO USE FOR ROUNDING     *
                         REQUEST LENGTHS TO KEEP THE AREA ALLOCATED ON *
                         THE PROPER ADDRESSING BOUNDARY.
IGABLOCK DC    F'0'      THIS IS THE HEAD OF THE BLOCK CHAIN OF BLOCK  *
                         DEFINITION WORDS THAT DEFINE THE SPACE        *
                         OBTAINED IN GSPACE FOR REFILLS.
IGASPLNG DC    XL4'00000000'  THE SUBPOOL NUMBER AND LENGTH OF THE SPACE
                         CONTROL AREA.
IGASA0   DC    18F'0'    THIS IS THE INNER SPACE SAVE AREA.
IGASA1   DC    18F'0'    THIS IS THE OUTER SPACE SAVE AREA.
IGAS8    DC    4F'0'     THE FIXED LENGTH HEADER FOR THE FREE SPACE    *
                         CHAIN OF 8-BYTE ENTRIES.
IGAS12   DC    4F'0'     THE FIXEDHDR FOR THE 12-BYTE ENTRY FREE SPACE *
                         CHAIN.
IGAS80   DC    4F'0'     THE FIXEDHDR FOR THE 80-BYTE FREE SPACE CHAIN.
IGASPC   DSECT 0
IGANXSP  DC    F'0'  THE EDGE TO THE NEXT ONE.
IGASPADR DC    F'0'  THE ADDRESS OF THE SPACE CONTROL AREA. THE SUBPOOL*
                         NUMBER FOR THIS ONE IS IN THE LEFT BYTE OF THE*
                         ADDRESS.
IGASPFIN EQU   B'10000000'  THIS BIT IS ON FOR THE LAST EDGE IN THE    *
                         SPACE CONTROL AREA SUBPOOL CHAIN.
&SYSECT  CSECT
.NOSPDS  ANOP
&IGASA0  SETC  'X''40'''  THE OFFSET TO THE FIRST SAVE AREA IN THE SPACE
                         CONTROL AREA.
&IGASA1  SETC  'X''88'''  THE OFFSET TO THE SECOND SAVE AREA IN THE    *
                         SPACE CONTROL AREA.
&IGAS8   SETC  'X''D0'''  SET THE OFFSET FROM THE BEGINNING OF THE     *
                         SPACE CONTROL AREA TO THE FIXEDHDR FOR 8-BYTE *
                         ENTRIES.
&IGAS12  SETC  'X''E0'''  SET THE OFFSET TO THE FIXEDHDR FOR 12-BYTE   *
                         ENTRIES.
&IGAS80  SETC  'X''F0'''  SET THE OFFSET TO THE FIXEDHDR FOR 80-BYTE   *
                         ENTRIES.
&IGASPZ  SETC  'X''100'''  SET THE LENGTH OF THE SPACE CONTROL AREA.
         AGO   .RPTV8  ALMOST ALL DONE, EXCEPT FOR THE GLOBAL VARIABLES*
               FOR THE TYPE 8 AND 9 RADIX PARTITION TREES.
.**********************************************************************
.* COME HERE TO GENERATE MISCELLANEOUS GENERATA.                      *
.**********************************************************************
.GEN     AIF   ('&GEN(1)' EQ 'CVTRPT').LOADCVT  SEE IF THE SEQUENCE TO *
                         LOAD THE CVTRPT WORD SHOULD BE GENERATED.
         AIF   ('&GEN(1)' EQ 'TCBRPT').LOADTCB  SEE IF THE SEQUENCE TO *
                         LOAD THE TCBRPT WORD SHOULD BE GENERATED.
         AIF   ('&GEN(1)' EQ 'TCBRPTA').TCBADDR  SEE IF THE SEQUENCE TO*
                         GET THE ADDRESS OF THE TCBRPT WORD SHOULD BE  *
                         GENERATED.
         MNOTE 12,'INVALID GEN PARAMETER.'
         AGO   .FIN      FORGET IT, CAN'T DO ANYTHING WITH THIS.
.**********************************************************************
.* GENERATE THE CODE TO LOAD THE ADDRESS OF THE MODULE IGARPT01 FROM  *
.* THE CVTRPT WORD INTO THE REGISTER SPECIFIED BY THE SECOND ELEMENT  *
.* IN THE GEN PARAMTER.                                               *
.**********************************************************************
.LOADCVT ANOP
         AIF   (&IGAPGM).IGACVTL  SEE IF THIS IS THE IGARPT01 MODULE.
         AIF   (NOT(&IGALONE)).NOTLONE  SEE IF THIS IS REALLY IT.
&TAG     L     &GEN(2),=AL4(IGAFETCH)  ADDRESS OF THE FAKE TCBRPT WORD.
         BAL   &GEN(2),(X'10'+X'40'*(&GEN(2)-14))(,&GEN(2))  LINK TO   *
                         REPLACE THIS INSTRUCTION WITH A LOAD OF THE   *
                         ADDRESS OF IGARPT01.
         AGO   .GENFIN   ALL DONE GENERATING IT NOW.
.IGACVTL L     &GEN(2),ADDRESS  LOAD THE ADDRESS OF THE BEGINNING OF   *
                         THE MODULE IGARPT01.
         AGO   .GENFIN   ALL DONE NOW.
.NOTLONE ANOP
&TAG     L     &GEN(2),X'10'  CVT PTR.
         USING CVT,&GEN(2)
         L     &GEN(2),CVTRPT  ADDRESS OF IGARPT01.
         DROP  &GEN(2)
         AGO   .GENFIN
.**********************************************************************
.* GENERATE THE CODE TO LOAD THE TCBRPT WORD INTO THE REGISTER        *
.* SPECIFIED BY THE SECOND ELEMENT IN THE GEN PARAMETER.              *
.**********************************************************************
.LOADTCB ANOP
         AIF   (NOT &IGALONE).LTCBWRD  SEE IF THIS IS UNIT TEST.
         AIF   (&IGAPGM).IGATCBL  SEE IF THIS IS THE PROGRAM IGARPT01.
         MNOTE 12,'CAN''T GET THE TBCRPT STUFF.'
         AGO   .GENFIN   ALL DONE GENERATING IT NOW.
.IGATCBL ANOP
&TAG     BALR  &GEN(2),0
         AGO   .GENFIN
         USING *,&GEN(2)
         L     &GEN(2),=AL4(IGATCB)
         DROP  &GEN(2)
         AIF   ('&GEN(1)' EQ 'TCBRPTA').GENFIN
         L     &GEN(2),0(,&GEN(2))
         AGO   .GENFIN   ALL DONE NOW.
.LTCBWRD ANOP
&TAG     L     &GEN(2),X'10'  ADDRESS OF CVT.
         AGO   .GENFIN
         L     &GEN(2),0(&GEN(2))    ADDRESS OF TCB CHAIN.
         L     &GEN(2),X'04'(,&GEN(2))  CURRENT TCB ADDRESS.
         USING TCB,&GEN(2)
&CHAR    SETC  'A'       PREPARE FOR A LOAD ADDRESS INSTRUCTION.
         AIF   ('&GEN(1)' EQ 'TCBRPTA').NOWLOAD  SEE IF IT IS THE      *
                         ADDRESS OF THE TCBRPT WORD, OR THE ACTUAL     *
                         CONTENTS OF THE TCBRPT WORD.
&CHAR    SETC  ''        IT IS THE ACTUAL CONTENTS OF THE WORD.
.NOWLOAD L&CHAR &GEN(2),TCBRPT  LOAD IGA'S WORD.
         DROP  &GEN(2)
         AGO   .GENFIN   ALL DONE NOW.
.**********************************************************************
.* GENERATE THE ADDRESS OF THE TCBRPT WORD IN THE REGISTER SPECIFIED  *
.* BY THE SECOND ELEMENT OF THE GEN PARAMETER.                        *
.**********************************************************************
.TCBADDR ANOP
         AIF   (NOT &IGALONE).LTCBWRD  SEE IF THIS IS THE REAL THING,  *
                         AND NOT JUST UNIT TEST.
         AIF   (&IGAPGM).IGATCBL  SEE IF THIS IS THE MODULE IGARPT01.
         MNOTE 12,'CAN''T GET THE ADDRESS OF THE TCBRPT WORD.'
         AGO   .GENFIN   ALL DONE GENERATING IT NOW.
.GENFIN  AIF   ((NOT &IGALONE)OR &IGAFTCH).FIN  SEE IF THE IGAFETCH    *
                         CSECT IS NEEDED.
         AIF   (&IGAPGM).FIN  DON'T GENERATE IT IN THE IGARPT01 MODULE.
&IGAFTCH SETB  (1)       DON'T GENERATE IT MORE THAN ONCE.
IGAFETCH CSECT
IGACVT   DC    F'0'      THIS WILL BE THE ADDRESS OF THE MODULE        *
                         IGARPT01 AFTER IT IS LOADED.
&X       SETA  (14)      START BY GENERATING THE CODE FOR REGISTER 14.
.GOAGAIN ANOP
         ORG   IGAFETCH+X'10'+(X'40'*(&X-14))  ORIGIN TO THE CORRECT   *
                         OFFSET FOR THE BRANCH ENTRY.
&Y       SETA  8
.BCTRCTR BCTR  &X,0
&Y       SETA  (&Y-1)
         AIF (&Y GT 0).BCTRCTR GENERATE 8 BCTR INSTRUCTIONS TO BACK UP *
                         THE LINKAGE ADDRESS TO THE LOAD INSTRUCTION.
         ST    2,4(,&X)  SAVE REGISTER 2 ON TOP OF THE BAL INSTRUCTION.
         BALR  2,0       ESTABLISH ADDRESSABILITY.
         USING *,2
         STM   0,1,IGASAVE0  SAVE REGISTERS 0 AND 1.
         BAL   2,IGAGCVT  GO CHECK TO SEE IF THE MODULE IS LOADED.
         DROP  2
         BALR  1,0       GET BACK ADDRESSABILITY.
         USING *,1
         AIF   (&X EQ 14).XIS14  SEE IF &X IS FOURTEEN.
         L     0,IGA15AL1  LOAD THE INSTRUCTION "L 15,0(,15)".
         AGO   .XDONE    SKIP AROUND THE CASE FOR &X = 14.
.XIS14   L     0,IGA14AL1  LOAD THE INSTRUCTION "L 14,0(,14)".
.XDONE   ANOP
         L     2,4(,&X)  RESTORE REGISTER 2.
         ST    0,4(,&X)  OVERLAY THE BAL INSTRUCTION WITH A LOAD OF THE*
                         ADDRESS OF IGARPT01.
         LM    0,1,IGASAVE0  RESTORE REGISTERS ZERO AND ONE.
         BR    &X        RETUTN TO THE LOAD OF THE ADDRESS OF IGAFETCH.
         DROP  1
&X       SETA  (&X+1)    EKE THE REGISTER.
         AIF   (&X EQ 15).GOAGAIN  REPEAT IT FOR REGISTER 15.
         ORG   IGAFETCH+X'40'*2  ORIGIN TO THE RIGHT PLACE FOR THE     *
                         SUBROUTINE TO LOAD THE MODULE.
***********************************************************************
* FETCH THE CONTENTS OF THE CVTRPT WORD, WHICH IS JUST THE ADDRESS OF *
* THE MODULE IGARPT01. DO THIS BY LOOKING TO SEE IF THE MODULE HAS    *
* BEEN LOADED ALREADY, AND IF IT HASN'T THEN LOAD IT FIRST.           *
***********************************************************************
IGAGCVT  SLR   0,0
         BALR  1,0
         USING *,1
IGASL0   SL    1,IGASL0A
         DROP  1
         USING IGAFETCH,1
         CL    0,IGACVT  SEE IF THE MODULE IS ALREADY LOADED.
         BCR   8,2       RETURN IF IT IS ALREADY LOADED.
         LOAD  EP=IGARPT01  LOAD THE MODULE.
         DROP  1
         BALR  1,0
         USING *,1
IGASL1   SL    1,IGASL1A
         DROP  1
         USING IGAFETCH,1
         ST    0,IGACVT  STORE THE ADDRESS OF THE LOADED MODULE.
         DROP  1
         BR    2
         CNOP  0,8
IGASAVE0 DC    XL8'FFFFFFFFFFFFFFFF'
IGASL0A  DC    AL4(IGASL0-IGAFETCH)
IGASL1A  DC    AL4(IGASL1-IGAFETCH)
IGA14AL1 L     14,0(,14)
IGA15AL1 L     15,0(,15)
&SYSECT  CSECT
.FIN     ANOP
         MEND
         EJECT
         MACRO
&TAG     SCANL &TREE,&MORE=,&DONE=,&T=,&TYPE=
.*A000000                                                        Y02147
.**********************************************************************
.* THE SCANL MACRO-INSTRUCTION IS USED FOR MOVING THE CURSOR TO A     *
.* KEY-ADDRESS PAIR WITH A NEXT LOWER KEY. SEE THE DESCRIPTION OF THE *
.* CURSOR STATES IN THE ISCAN MACRO-INSTRUCTION DESCRIPTION FOR A     *
.* DISCUSSION OF THE CURSOR STATES. IF THE CURSOR IS POSITIONED       *
.* BETWEEN TWO PAIRS BY THE DEL OPERATION, THEN THE SCANL OPERATION   *
.* SETS THE CURSOR TO THE PAIR ON THE LEFT, I. E. IN THE DESCENDING   *
.* COLLATING SEQUENCE DIRECTION. THE ADDRESS RETURNED IN REGISTER 15  *
.* IS THE ADDRESS ASSOCIATED WITH THE KEY ON THE LEFT OF THE KEY THAT *
.* WAS DELETED. THE CONDITION CODE IS SET TO CORRESPOND TO THE RETURN *
.* CODE, SO THAT IF THE RPT HAS PAIRS PRESENT THE CONDITION CODE IS   *
.* NON-NEGATIVE WHEN THE CURSOR IS LEFT IN STATE 3, OR IS NEGATIVE IF *
.* THE CURSOR IS LEFT IN STATE 0, 1, OR 2.                            *
.*                                                                    *
.* IF THE CURSOR IS IN STATE 3, POSITIONED AT A KEY-ADDRESS PAIR, THEN*
.* THE SCANL OPERATION POSITIONS THE CURSOR AT THE PAIR ON THE LEFT OF*
.* THE ONE SELECTED. IF THERE IS NO PAIR ON THE LEFT OF THE ONE       *
.* SELECTED, THEN THE CURSOR IS SET TO STATE 1. IF THE CURSOR IS IN   *
.* STATE 1, AND THE SCANL OPERATION IS EXECUTED, THEN THE CURSOR IS   *
.* LEFT IN STATE 1. WHENEVER THE CURSOR IS LEFT IN STATE 1 BY THE     *
.* SCANL OPERATION, THE RETURN CODE IN REGISTER 15 IS SET TO -1, AND  *
.* THE CONDITION CODE IS SET TO CORRESPOND TO IT (CC=01).             *
         GBLC  &IGASCNL
         GBLC  &IGABLST  THE OFFSET INTO THE TREE HEADER FOR THE LIST  *
                         OF RPT ENTRY POINTS.
         GBLC  &IGARPT#  THIS HOLDS THE RPT TYPE.
.**********************************************************************
.* CHECK THE TYPE AND T PARAMETERS TO SEE IF A VALID RPT TYPE IS      *
.* SPECIFIED. IF NEITHER IS SPECIFIED, ASSUME IT IS TYPE 8 RPT. THE   *
.* TYPE IS PUT INTO THE GLOBAL VARIABLE &IGARPT# AT THE END OF THE    *
.* TYPE CHECKING SECTION.                                             *
.**********************************************************************
.RPT#    AIF   (K'&T EQ 0).RPT#TMT  SEE IF THE T PARAMETER IS CODED.
         AIF   (K'&TYPE EQ 0).RPT#TCK  USE THE T PARAMETER IF IT IS    *
                         CODED AND THE TYPE PARAMETER IS NOT CODED.
.**********************************************************************
.* BOTH THE T AND TYPE PARAMETERS ARE CODED; SEE IF THEY ARE THE SAME,*
.* AND IF THEY ARE NOT THEN USE T.                                    *
.**********************************************************************
         AIF   ('&T' EQ '&TYPE').RPT#TCK  IF THEY ARE THE SAME THEN USE*
                         T.
         MNOTE 4,'TYPE CONFLICT, ONLY T OR TYPE SHOULD BE CODED.'
.RPT#TCK ANOP
&IGARPT# SETC  '&T'      GET THE RPT TYPE.
         AGO   .RPT#CHK  GO TO CHECK THE VALIDITY OF THE RADIX         *
                         PARTITION TREE TYPE.
.**********************************************************************
.* THE T PARAMETER IS NOT CODED, SEE IF THE TYPE PARAMETER IS CODED.  *
.**********************************************************************
.RPT#TMT AIF   (K'&TYPE EQ 0).RPT#8  IF BOTH ARE LEFT OUT USE TYPE 8   *
                         RPT.
&IGARPT# SETC  '&TYPE'   SET THE TYPE TO THE TYPE THAT IS SPECIFIED BY *
                         THE TYPE PARAMETER.
         AGO   .RPT#CHK  GO CHECK IT FOR VALIDITY.
.RPT#8   ANOP
&IGARPT# SETC  '8'       SET THE RPT TYPE TO 8.
.RPT#CHK AIF   (('&IGARPT#' EQ '8')OR('&IGARPT#' EQ '5')OR('&IGARPT#' E*
               Q '4')).RPT#FIN
         MNOTE 4,'INVALID RPT TYPE, TYPE 8 ASSUMED.'
&IGARPT# SETC  '8'       TAKE THE DEFAULT TYPE 8 RPT.
.RPT#FIN ANOP
       RPTDSECT T=&IGARPT#,DS=NO
         AIF   (K'&TREE EQ K'&TREE(1)+2).LW1
&TAG     L     1,&TREE
.LW0     ANOP
         L     15,(&IGABLST+&IGASCNL)(,1)  ADDRESS OF SCANL ROUTINE.
         BALR  14,15     LINK TO SCAN LEFT IN IGARPT01.
         AGO   .FIN
.LW1     ANOP
&TAG     LR    1,&TREE
         AGO   .LW0
.FIN     ANOP
         AIF   (K'&MORE NE 0).LW3
         AIF   (K'&DONE EQ 0).END
         BC    4,&DONE
         AGO   .END
.LW3     AIF   (K'&DONE NE 0).LW4
         BC    10,&MORE
         AGO   .END
.LW4     ANOP
         BC    10,&MORE
         BC    4,&DONE
.END     ANOP
.EOS     ANOP
         MEND
         EJECT
         MACRO
&TAG     SCANR &TREE,&MORE=,&DONE=,&T=,&TYPE=
.**********************************************************************
.* THE SCANR MACRO-INSTRUCTION IS USED TO POSITION THE CURSOR TO A    *
.* NEXT PAIR TO THE RIGHT OF THE CURRENT CURSOR POSITION. THE         *
.* OPERATION IS IDENTICAL TO THE SCANL OPERATION, EXCEPT THAT STATE 2 *
.* IS USED INSTEAD OF STATE 1, AND WHEREVER THE WORDS "LEFT" AND      *
.* "RIGHT" APPEAR IN THE SCANL DESCRIPTION, REPLACE THEM WITH THE     *
.* WORDS "RIGHT" AND "LEFT" RESPECTIVELY.                             *
         GBLC  &IGASCNR
         GBLC  &IGARPT#  THIS HOLDS THE RPT TYPE.
.*A000000                                                        Y02147
         GBLC  &IGABLST  THE OFFSET INTO THE TREE HEADER FOR THE LIST  *
                         OF ENTRY POINTS FOR THE ROUTINES IN THE       *
                         IGARPT01 MODULE.
.**********************************************************************
.* CHECK THE TYPE AND T PARAMETERS TO SEE IF A VALID RPT TYPE IS      *
.* SPECIFIED. IF NEITHER IS SPECIFIED, ASSUME IT IS TYPE 8 RPT. THE   *
.* TYPE IS PUT INTO THE GLOBAL VARIABLE &IGARPT# AT THE END OF THE    *
.* TYPE CHECKING SECTION.                                             *
.**********************************************************************
.RPT#    AIF   (K'&T EQ 0).RPT#TMT  SEE IF THE T PARAMETER IS CODED.
         AIF   (K'&TYPE EQ 0).RPT#TCK  USE THE T PARAMETER IF IT IS    *
                         CODED AND THE TYPE PARAMETER IS NOT CODED.
.**********************************************************************
.* BOTH THE T AND TYPE PARAMETERS ARE CODED; SEE IF THEY ARE THE SAME,*
.* AND IF THEY ARE NOT THEN USE T.                                    *
.**********************************************************************
         AIF   ('&T' EQ '&TYPE').RPT#TCK  IF THEY ARE THE SAME THEN USE*
                         T.
         MNOTE 4,'TYPE CONFLICT, ONLY T OR TYPE SHOULD BE CODED.'
.RPT#TCK ANOP
&IGARPT# SETC  '&T'      GET THE RPT TYPE.
         AGO   .RPT#CHK  GO TO CHECK THE VALIDITY OF THE RADIX         *
                         PARTITION TREE TYPE.
.**********************************************************************
.* THE T PARAMETER IS NOT CODED, SEE IF THE TYPE PARAMETER IS CODED.  *
.**********************************************************************
.RPT#TMT AIF   (K'&TYPE EQ 0).RPT#8  IF BOTH ARE LEFT OUT USE TYPE 8   *
                         RPT.
&IGARPT# SETC  '&TYPE'   SET THE TYPE TO THE TYPE THAT IS SPECIFIED BY *
                         THE TYPE PARAMETER.
         AGO   .RPT#CHK  GO CHECK IT FOR VALIDITY.
.RPT#8   ANOP
&IGARPT# SETC  '8'       SET THE RPT TYPE TO 8.
.RPT#CHK AIF   (('&IGARPT#' EQ '8')OR('&IGARPT#' EQ '5')OR('&IGARPT#' E*
               Q '4')).RPT#FIN
         MNOTE 4,'INVALID RPT TYPE, TYPE 8 ASSUMED.'
&IGARPT# SETC  '8'       TAKE THE DEFAULT TYPE 8 RPT.
.RPT#FIN ANOP
       RPTDSECT T=&IGARPT#,DS=NO
.**********************************************************************
         AIF   (K'&TREE EQ K'&TREE(1)+2).LW1
&TAG     L     1,&TREE
.LW0     ANOP
         L     15,(&IGABLST+&IGASCNR)(,1)  ADDRESS OF SCANR ROUTINE.
         BALR  14,15     LINK TO SCAN RIGHT IN IGARPT01.
         AGO   .FIN
.LW1     ANOP
&TAG     LR    1,&TREE
         AGO   .LW0
.FIN     ANOP
         AIF   (K'&MORE NE 0).LW3
         AIF   (K'&DONE EQ 0).END
         BC    4,&DONE
         AGO   .END
.LW3     AIF   (K'&DONE NE 0).LW4
         BC    10,&MORE
         AGO   .END
.LW4     ANOP
         BC    10,&MORE
         BC    4,&DONE
.END     ANOP
.EOS     ANOP
         MEND
         EJECT
         MACRO
&TAG     SRCH  &TREE,&A=,&K=,&Y=,&N=,&NULL=,&T=,&REL=,                 X
               &SARG=,&EQUAL=,&UNEQUAL=,&TYPE=,&KEYL=
.*A000000                                                        Y02147
.*  THE MEANINGS OF THE PARAMETERS FOR THE SRCH MACRO-INSTRUCTION ARE *
.*  AS FOLLOWS:                                                       *
.*--------------------------------------------------------------------*
.*  &TREE  IS THE ADDRESS OF THE RADIX PARTITION TREE.                *
.*         IF "TREE" IS CODED, WHERE "TREE" IS A SUITABLE OPERAND FOR *
.*         A LOAD ADDRESS INSTRUCTION, THE THE MAIN STORAGE LOCATION  *
.*         SO SPECIFIED IS PRESUMED TO CONTAIN THE ADDRESS OF THE RPT *
.*         AS RETURNED BY THE STREE MACRO-INSTRUCTION.                *
.*                                                                    *
.*         IF "(GPR)" IS CODED, THEN THE INDICATED REGISTER HAS THE   *
.*         ADDRESS OF THE RPT IN IT.                                  *
.*                                                                    *
.*         THE TREE ADDRESS IS LOADED INTO REGISTER 1 BY THE SRCH     *
.*         MACRO, SO THAT IF "(1)" IS CODED NO LOAD OR LR IS          *
.*         GENERATED.                                                 *
.*                                                                    *
.*         IF THE PARAMETER IS NOT CODED, THE MNOTE "TREE PARAMETER   *
.*         MISSING, ASSUMED IN R1." IS GENERATED WITH SEVERITY O, AND *
.*         THE ADDRESS OF THE RPT IS ASSUMED TO BE IN REGISTER 1.     *
.*--------------------------------------------------------------------*
.*  &T     IS THE TYPE OF THE RPT. SEE THE DESCRIPTION OF THE STREE   *
.*         MACRO INSTRUCTION FOR THE COMPLETE LIST OF OPERATIONS      *
.*         AVAILABLE WITH THE DIFFERENT TYPES OF TREES.               *
.*                                                                    *
.*        THE ONLY ALLOWED WAYS TO CODE THE T-PARAMETER ARE:          *
.*        T=5 FOR TYPE 5 RPT.                                         *
.*        T=8 FOR TYPE 8 RPT.                                         *
.*        IF THE T-PARAMETER IS NOT CODED A DEFAULT OF T=8 IS SUPPLIED*
.*--------------------------------------------------------------------*
.*  &A    SPECIFIES THE ADDRESS OF THE RECORD OR CONTROL BLOCK        *
.*        CONTAINING THE KEY TO BE USED IN THE SEARCH.                *
.*        THE A-PARAMETER, TOGETHER WITH THE K-PARAMETER, DEFINES     *
.*        THE SEARCH KEY.                                             *
.*                                                                    *
.*        IF "A=ADDRESS" IS CODED, WHERE "ADDRESS" IS A MAIN STORAGE  *
.*        LOCATION, THEN THE ADDRESS OF THE FIRST BYTE OF THE RECORD  *
.*        IS FORMED WITH A LOAD ADDRESS INSTRUCTION.                  *
.*                                                                    *
.*        IF "A=(GPR)" IS CODED, THEN THE ADDRESS OF THE FIRST BYTE   *
.*        OF THE RECORD IS IN THE SPECIFIED REGISTER.                 *
.*                                                                    *
.*--------------------------------------------------------------------*
.*  &K     SPECIFIES THE SEARCH KEY, WHEN TAKEN IN COMBINATION WITH   *
.*         THE A-PARAMETER. AT LEAST ONE OF THESE TWO PARAMETERS MUST *
.*         ALWAYS BE CODED, OR THE MNOTE "A OR K MUST BE CODED." IS   *
.*         GENERATED, WITH A SEVERITY CODE OF 12.                     *
.*                                                                    *
.*         THE FOLLOWING COMBINATIONS ARE VALID:                      *
.*         --- --------- ------------ --- ------                      *
.*                                                                    *
.*         "K=(DISPLACEMENT,LENGTH)", WHERE "DISPLACEMENT" IS EITHER  *
.*         A RELOCATABLE EXPRESSION OR A SELF-DEFINING ABSOLUTE       *
.*         DECIMAL NUMBER SPECIFYING EITHER THE ADDRESS OF BYTE ZERO  *
.*         OF THE KEY OR THE DISPLACEMENT FROM THE ADDRESS SPECIFIED  *
.*         BY THE A-PARAMETER TO THE FIRST BYTE OF THE KEY.           *
.*         "LENGTH" IS AN ABSOLUTE EXPRESSION GIVING THE LENGTH OF    *
.*         THE KEY. FOR TYPE 5 RPT, "LENGTH" IS A DECIMAL NUMBER.     *
.*                                                                    *
.*         FOR TYPE 5 RPT, THE KEY LENGTH CANNOT BE GREATER THAN 16.  *
.*         FOR TYPE 8 RPT, THE KEY LENGTH CANNOT BE GREATER THAN 256. *
.*                                                                    *
.*         IF THE A-PARAMETER IS CODED, THE ADDRESS OF THE FIRST      *
.*         BYTE OF THE KEY IS FORMED BY ADDING THE DISPLACEMENT TO THE*
.*         ADDRESS FROM THE A-PARAMETER. THE DISPLACEMENT MUST NOT    *
.*         EXCEED 4095.                                               *
.*                                                                    *
.*         IF THE A-PARAMETER IS CODED AND THE K-PARAMETER IS NOT     *
.*         CODED, THE THE K-PARAMETER IS ASSUMED TO BE THE SAME AS THE*
.*         K-PARAMETER THAT WAS CODED IN THE STREE MACRO WHEN THE RPT *
.*         WAS CREATED.                                               *
.*--------------------------------------------------------------------*
.*  &Y     IS THE ADDRESS TO BRANCH TO IF THE SEARCH KEY IS EQUAL TO  *
.*         THE KEY FOUND BY THE SEARCH.                               *
.*         IF  "Y=(GPR)" IS CODED, THEN THE ADDRESS TO BRANCH TO IF   *
.*         THEY ARE EQUAL IS IN THE SPECIFIED GPR.                    *
.*         IF THE  Y-PARAMETER IS NOT CODED, THEN EXECUTION CONTINUES *
.*         WITH THE NEXT INSTRUCTION AFTER THE SRCH MACRO.            *
.*--------------------------------------------------------------------*
.*  &N     IS THE ADDRESS TO BRANCH TO IF THE SEARCH KEY IS NOT EQUAL *
.*         TO THE KEY FOUND BY THE SEARCH. IT IS CODED THE SAME WAY   *
.*         THE  Y-PARAMETER IS CODED.                                 *
.*         NOTE THAT IF THE RPT HAS NO ENTRIES IN IT THE SEARCH KEY   *
.*         IS CONSIDERED NOT EQUAL.                                   *
.*--------------------------------------------------------------------*
.*  &NULL  IS THE ADDRESS TO BRANCH TO IF THERE ARE NO SINKS IN THE   *
.*         RPT. IT IS CODED IN THE SAME WAY AS THE N AND Y            *
.*         PARAMETERS. IF BOTH THE NULL AND N  PARAMETERS ARE CODED   *
.*         AND THE RPT IS EMPTY A BRANCH TO THE NULL ADDRESS IS TAKEN.*
.*                                                                    *
.*--------------------------------------------------------------------*
.*  &REL   IS A QUALIFIER SPECIFYING THE RELATIONSHIP BETWEEN THE     *
.*         SEARCH KEY AND THE KEY TO BE FOUND.                        *
.*                                                                    *
.*         THE REL PARAMETER IS CODED AS FOLLOWS:                     *
.*                                                                    *
.*             **  **     **               **   **  **                *
.*            **  **       **             **  LT **  **               *
.*           **   **  MAX  **             **  LE **   **              *
.*           **   **       **             **  EQ **   **              *
.*   REL=    **  **   MIN   **       ,,  **   --  **  **              *
.*           **   **  ---  **         ,,  **  GE **   **              *
.*           **   **       **         ,,  **  GT **   **              *
.*            **  **  POV  **        ,,   ** POV **  **               *
.*             **  **     **        ,,     **   **  **                *
.*                                 ,,                                 *
.*                                                                    *
.*         THUS "REL=(MAX,LE)" IMPLIES A SEARCH FOR THE LARGEST KEY   *
.*         THAT IS LESS THAN OR EQUAL TO THE SEARCH KEY.              *
.*                                                                    *
.*         WHEN THE REL PARAMETER IS CODED THE KEY LENGTH MUST BE     *
.*         CODED EXPLICTLY IN THE K PARAMETER.                        *
.*--------------------------------------------------------------------*
.*         WHEN "REL=(MAX/MIN,POV)" IS CODED, A SEARCH IS MADE TO FIND*
.*         THE LARGEST OR SMALLEST PARTIAL ORDER VALUE.               *
.*         WHEN "REL=(POV,GE)" IS CODED A SEARCH TO FIND A PARTIAL    *
.*         ORDER VALUE THAT IS GREATER THAN OR EQUAL TO THE SEARCH    *
.*         KEY, BUT IS THE SMALLEST THAT CAN BE SO DETERMINED         *
.*         EFFICIENTLY (NOT NECESSARILY THE SMALLEST POSSIBLE).       *
.*--------------------------------------------------------------------*
.*         ONLY THE FOLLOWING COMBINATIONS ARE VALID:                 *
.*                                                                    *
.*         REL=(MAX,LT/LE/EQ/POV)                                     *
.*         REL=(MIN,EQ/GE/GT/POV)                                     *
.*         REL=(POV,GE) MEANS FIND MIN POV>=KEY.                      *
.*--------------------------------------------------------------------*
.*         REL=(POV,EQ) MEANS FIND POV FOR THE SINK ADDRESSED BY THE  *
.*         CURRENT SETTING OF THE CURSOR.                             *
.*--------------------------------------------------------------------*
.*  &SARG      THESE ARE ONLY PRESENT FOR COMPATIBILITY WITH EARLIER  *
.*  &EQUAL     VERSIONS, AND SHOULD NOT BE USED.                      *
.*  &UNEQUAL                                                          *
.*  &TYPE                                                             *
.*  &KEYL                                                             *
         GBLC  &IGABLST  THE BEGINNING OF THE LIST OF ENTRY POINTS FOR *
                         THE RPT OPERATIONS.
         GBLC  &IGASRCH
         GBLC  &IGADDR   THE ADDRESS OF THE MODULE IGARPTXX.
         GBLC  &IGARPT#  THE RADIX PARTITION TREE TYPE.
         GBLA  &IGAPATH(16)  PATH VECTOR IN BIG PARSE TREE.
         GBLA  &IGALEVL      PATH LENGTH TO ATOM IN PARSE TREE.
         GBLA  &IGALEFT(256)  LEFT EDGE FIELDS IN PARSE TREE.
         GBLA  &IGARGHT(256)  RIGHT EDGE FIELDS IN PARSE TREE.
         GBLA  &IGAX  EOP TRIPLE FOR THE BINARY PARSE TREE WITH
         GBLA  &IGAY  SUBTRACTION INVERTIBLE EDGES GENERATED BY
         GBLA  &IGAZ  THE MACRO-INSTRUCTION RPTDSECT.
         GBLA  &IGAKEYL  THE LENGTH OF THE SEARCH KEY.
         GBLC  &IGAGPV  BRANCH ENTRY OFFSET TO GET THE PARTIAL ORDER
.*                      VALUE FOR THE CURSOR-SELECTED SINK (TYPE 9 RPT)
         GBLC  &IGAPVS  BRANCH ENTRY OFFSET TO THE ROUTINE IN IGARPT01
.*                      TO SEARCH FOR A PARTIAL ORDER VALUE THAT IS
.*                      GREATER THAN OR EQUAL TO THE SEARCH KEY.
         GBLC  &IGAEOPV  THE OFFSET TO THE PATH CODE BYTE IN THE TYPE 8*
                         RPT HEADER FOR THE PATH TO THE SINK CURRENTLY *
                         SELECTED BY THE CURSOR.
         GBLC  &IGACNT5  THE OFFSET TO THE USE COUNTER IN THE TYPE 5   *
                         RPT HEADER.
         GBLC  &IGAMSK5  THE OFFSET TO THE TABLE OF MASKS FOR TYPE 5   *
                         RPT.
         GBLC  &IGATOP5  THE OFFSET TO THE RPT SOURCE IN THE TYPE 5 RPT*
                         HEADER.
         GBLC  &IGAMAX   THE OFFSET TO THE WORD CONTAINING THE MAXIMUM *
                         PARTIAL ORDER VALUE.
         GBLC  &IGAKEYW  THE OFFSET TO THE WORD CONTAINING THE ADDRESS *
                         OF THE WORK AREA FOR COLLECTING KEYS.
         GBLB  &IGAOKAY  ON IF THE PARSE IN RPTDSECT DID NOT FIND ANY  *
                SYNTAX ERRORS IN THE R PARAMETER LIST.
         LCLA  &I        A LOCAL VARIABLE FOR KEEPING TRACK OF THE     *
                         CURRENT ENTRY BEING SCANNED IN THE R PARAMETER*
                         LIST.
         LCLA  &LNG      THE LENGTH OF THE CURRENT DISPLACEMENT-LENGTH *
                         PAIR.
         LCLC  &X        JUST A LOCAL CHARACTER VECTOR FOR COLLECTING  *
                         OPERANDS.
         LCLB  &FINEQU   ON IF THE EQUATE "FIN&SYSNDX EQU *" MUST BE   *
                         GENERATED AT THE END OF THE MACRO EXECUTION.
         LCLB  &ERROR    THIS BIT IS TURNED ON WHENEVER AN MNOTE OF    *
                         SUFFICIENT SEVERITY IS GENERATED.
         LCLB  &KLMNOTE  ON WHEN THE KEY LENGTH EXCEEDS 256 BYTES.
         LCLA  &DSP      THIS IS USED FOR COLLECTING THE DISPLACEMENT  *
                         AS A NUMBER.
         LCLC  &FIELD    THIS IS USED TO HOLD THE FIELD OF AN (F,L)    *
                         PAIR WHILE GETTING THE L.
         LCLB  &XFER     ON TO GENERATE THE MOVES WHEN IT IS THE RIGHT *
               ITERATION THROUGH THE LOOP.
         LCLA  &KL             KEY LENGTH ARITHMETIC VARIABLE.
         LCLA  &TMPA     A LOCAL ARITHMETIC TEMPORARY.
         LCLB  &WORKEY   ON IF THE KEY IS COLLECTED AT IGAWORK.
         LCLB  &USING    THIS BIT IS TURNED ON WHEN A USING WITH       *
                         REGISTER R1 IS GENERATED.
         LCLB  &FIN      ON IF THE FIN&SYSNDX EQU * IS TO BE GENERATED *
                         AT THE END.
         LCLC  &P,&C,&S,&GOLEFT,&ITSMOP,&ITSEOP,&TREEHDR,&ARG,&EKER
         LCLC  &EKE,&TOOBAD,&FOUR,&O
         LCLC  &R1       GENERAL REGISTER 1.
         LCLC  &TMP      A TEMPORARY LOCAL CHARACTER VECTOR.
         LCLC  &TMP0     A LOCAL TEMPORARY CHARACTER VARIABLE.
         LCLC  &TMP1     A TEMPORARY LOCAL CHARACTER VECTOR.
         AIF   ((K'&SARG EQ 0)AND(K'&EQUAL EQ 0)AND(K'&UNEQUAL EQ 0)AND*
               (K'&KEYL EQ 0)).NEW
         AIF   (K'&KEYL EQ 0).OLDKLZ  SEE IF THE OLD KEY LENGTH IS NOT *
                         GIVEN.
&TAG     SRCH  &TREE,A=&SARG,Y=&EQUAL,N=&UNEQUAL,T=&T,TYPE=&TYPE,K=(0, *
               &KEYL),NULL=&NULL,REL=&REL
         AGO   .END
.OLDKLZ  ANOP
         AIF   (K'&SARG LE 2).OLDONE  SEE IF THE SEARCH ARGUMENT IS NOT*
                         OF THE FORM "D(GPR)".
         AIF   (NOT(('&SARG'(1,1) LE '9')AND('&SARG'(1,1) GE '0'))).OLD*
               ONE       SEE IF IT NOT OF THE FORM "D(GPR)".
.**********************************************************************
.* THE OLD SEARCH ARGUMENT IS SPECIFIED AS "D(GPR)", TRANSLATE THIS   *
.* INTO A GOOD NEW FORMAT VIA THE MACRO RECURSION FACILITY.           *
.**********************************************************************
         AIF   ('&SARG'(K'&SARG,1) NE ')').OLDONE  HOWEVER, FIRST CHECK*
                         IT FOR VALIDITY.
&I       SETA  (1)       LOOK FOR THE LEFT PARENTHESIS.
.OLDLOOP ANOP
&I       SETA  (&I+1)    EKE THE INDEX TO THE NEXT CHARACTER.
         AIF   (&I GT (K'&SARG)).OLDONE  SEE IF THERE ISN'T ANY LEFT   *
                         PARENTHESIS.
         AIF   ('&SARG'(&I,1) NE '(').OLDLOOP  SEE IF IT IS STILL      *
                         GOING.
&TMP0    SETC  '&SARG'(1,&I-1)  PICK UP THE DISPLACEMENT FIELD.
&TMP1    SETC  '&SARG'(&I,K'&SARG-(&I+1))  GET THE GPR WITH ITS        *
                         SURROUNDING PARENTHESES.
&TAG     SRCH  &TREE,A=&TMP1,K=(&TMP0,),Y=&EQUAL,N=&UNEQUAL,T=&T,      *
               TYPE=&TYPE,NULL=&NULL,REL=&REL
         AGO   .END      ALL DONE NOW.
.OLDONE  ANOP
&TAG     SRCH  &TREE,A=&SARG,Y=&EQUAL,N=&UNEQUAL,T=&T,TYPE=&TYPE,      *
               NULL=&NULL,REL=&REL
         AGO   .END      ALL DONE NOW.
.NEW     ANOP
.**********************************************************************
.* CHECK THE TYPE AND T PARAMETERS TO SEE IF A VALID RPT TYPE IS      *
.* SPECIFIED. IF NEITHER IS SPECIFIED, ASSUME IT IS TYPE 8 RPT. THE   *
.* TYPE IS PUT INTO THE GLOBAL VARIABLE &IGARPT# AT THE END OF THE    *
.* TYPE CHECKING SECTION.                                             *
.**********************************************************************
.RPT#    AIF   (K'&T EQ 0).RPT#TMT  SEE IF THE T PARAMETER IS CODED.
         AIF   (K'&TYPE EQ 0).RPT#TCK  USE THE T PARAMETER IF IT IS    *
                         CODED AND THE TYPE PARAMETER IS NOT CODED.
.**********************************************************************
.* BOTH THE T AND TYPE PARAMETERS ARE CODED; SEE IF THEY ARE THE SAME,*
.* AND IF THEY ARE NOT THEN USE T.                                    *
.**********************************************************************
         AIF   ('&T' EQ '&TYPE').RPT#TCK  IF THEY ARE THE SAME THEN USE*
                         T.
         MNOTE 4,'TYPE CONFLICT, ONLY T OR TYPE SHOULD BE CODED.'
.RPT#TCK ANOP
&IGARPT# SETC  '&T'      GET THE RPT TYPE.
         AGO   .RPT#CHK  GO TO CHECK THE VALIDITY OF THE RADIX         *
                         PARTITION TREE TYPE.
.**********************************************************************
.* THE T PARAMETER IS NOT CODED, SEE IF THE TYPE PARAMETER IS CODED.  *
.**********************************************************************
.RPT#TMT AIF   (K'&TYPE EQ 0).RPT#8  IF BOTH ARE LEFT OUT USE TYPE 8   *
                         RPT.
&IGARPT# SETC  '&TYPE'   SET THE TYPE TO THE TYPE THAT IS SPECIFIED BY *
                         THE TYPE PARAMETER.
         AGO   .RPT#CHK  GO CHECK IT FOR VALIDITY.
.RPT#8   ANOP
&IGARPT# SETC  '8'       SET THE RPT TYPE TO 8.
.RPT#CHK AIF   (('&IGARPT#' EQ '8')OR('&IGARPT#' EQ '5')OR('&IGARPT#' E*
               Q '4')).RPT#FIN
         MNOTE 4,'INVALID RPT TYPE, TYPE 8 ASSUMED.'
&IGARPT# SETC  '8'       TAKE THE DEFAULT TYPE 8 RPT.
.RPT#FIN ANOP
      RPTDSECT T=&IGARPT#,DS=0  DON'T GENERATE THE BIG DSECT.
.**********************************************************************
         AIF   (K'&TREE NE 0).CHKGPR  SEE IF THE TREE ADDRESS IS CODED.
         MNOTE 0,'TREE PARAMETER MISSING, ASSUMED IN R1.'
         AGO   .CHKTAG  GO CHECK THE LABEL TO SEE IF EQU * NEEDED.
.CHKGPR  ANOP
         AIF   (K'&TREE EQ K'&TREE(1)+2 AND N'&TREE EQ 1).LW1
&TAG     L     1,&TREE   LOAD ADDRESS OF PARAMETER LIST.
         AGO   .LW2
.LW1     ANOP
         AIF   ('&TREE' NE '(1)').LW1F  SEE IF THE TREE ADDR IS IN GPR1
.CHKTAG  ANOP
         AIF   (K'&TAG EQ 0).LW1B  SINCE THERE IS NO LR, DOES IT HAVE
.*                                 TO GENERATE THE LABEL EQU * ?
&TAG     EQU   *
.LW1B    AGO   .LW2      DONE WITH LABEL AND TREE.
.LW1F    ANOP
&TAG     LR    1,&TREE(1)
.**********************************************************************
.* THE TREE ADDRESS IS NOW IN REGISTER 1.                             *
.**********************************************************************
.LW2     AIF   ((K'&A NE 0)OR(K'&K NE 0)).LW3  MAKE SURE THAT EITHER
.*             THE A OR K PARAMETER IS CODED.
         MNOTE 12,'A OR K MUST BE CODED.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
.LW3     ANOP
&R1      SETC  '1'  REGISTER 1 FOR USING STATEMENT.
.*--------------------------------------------------------------------*
.*  BRANCH OUT TO THE VARIOUS SEARCHES HERE.                          *
         AIF   ('&IGARPT#' EQ '8').SRCH8  SEE IF THIS IS A TYPE 8 RPT.
         AIF   ('&IGARPT#' EQ '5').SRCH5  SEE IF THIS IS A TYPE 5 RPT.
         MNOTE 12,'INVALID RPT TYPE, NO TYPE &IGARPT#.'
         MEXIT
.*--------------------------------------------------------------------*
.* SRCH8, USING THE SUBROUTINE IN IGARPT01.                           *
.*                                                                    *
.*       FOR SRCH8:                                                   *
.* 0. LEFT AND RIGHT INVERTIBLE EDGES, 3 BYTES LONG, EITHER OF THE    *
.*    SUBTRACTION OR EXCLUSIVE-OR TYPE.                               *
.* 1. NO SUCCESSOR PAIRING.                                           *
.* 2. MAXIMUM OF A 256-BYTE KEY IS SUPPORTED.                         *
.* 3. THE FLAG BITS ARE STORED WITH THE PREDECESSOR VERTEX.           *
.* 4. SCANNING FUNCTIONS ARE SUPPORTED WITH INVERTIBLE EDGES.         *
.*--------------------------------------------------------------------*
.SRCH8   ANOP
.**********************************************************************
.* CHECK THE REL PARAMETER TO SEE IF A PARTIAL ORDER VALUE IS         *
.* INVOLVED.                                                          *
.**********************************************************************
         AIF   (K'&REL NE 0).NOTPOV  SEE IF THE REL PARAMETER IS NOT   *
                         CODED.
         AIF   (N'&REL NE 1).TWOREL  SEE IF THERE ARE TWO ELEMENTS IN  *
                         THE REL PARAMETER.
         AIF   ('&REL(1)' EQ 'POV').POVGET  SEE IS THE SEARCH IS JUST  *
                         TO GET THE POV FROM THE CURRENT CURSOR        *
                         SETTING, OR USING THE KEY (IF THERE IS ONE).
         AGO   .NOTPOV   IT IS NOT A PARTIAL ORDER VALUE SEARCH.
.TWOREL  ANOP
         AIF   (('&REL(1)' EQ 'POV')OR('&REL(2)' EQ 'POV')).ITSAPOV    *
                         SEE IF A PARTIAL ORDER VALUE IS INVOLVED.
.NOTPOV  ANOP
.**********************************************************************
.* GENERATE THE ADDRESS OF THE SEARCH ARGUMENT IN REGISTER ZERO FOR   *
.* THE SEARCH SUBROUTINE IN THE MODULE IGARPT01.                      *
.* IF THE K PARAMETER IS NOT CODED JUST GO DIRECTLY TO .CHKA AND USE  *
.* THE ADDRESS SPECIFIED BY THE A PARAMETER.                          *
.* IF THE K PARAMETER IS CODED AND DEFINES A KEY CONSISTING OF MORE   *
.* THAN ONE FIELD, COLLECT IT AT IGAWORK IN THE TREE HEADER. THEN PUT *
.* THE ADDRESS OF IGAWORK IN REGISTER 0 FOR THE SEARCH.               *
.**********************************************************************
         AIF   (K'&K EQ 0).CHKA  SEE IF THERE IS NO SEARCH KEY         *
                         SPECIFIED.
.**********************************************************************
.* THE K PARAMETER HAS BEEN CHECKED AT THIS POINT, AND IS NOT THE     *
.* EMPTY STRING.                                                      *
.**********************************************************************
.LOOPAIR ANOP
&XFER    SETB  (1)       FOR THE SRCH MACRO ALWAYS GENERATE THE MOVES  *
                         ON THE SINGLE PASS THROUGH THIS PART.
&IGAKEYL SETA  0         INITIALIZE THE RECORD LENGTH TO ZERO.
         AIF   (N'&K EQ 2).KHAS2  SEE IF THERE ARE EXACTLY TWO ELEMENTS*
                         IN K ON PARENTHESIS LEVEL ONE.
         AIF   (N'&K NE 1).KMIXED  SEE IF THERE ARE MORE THAN TWO      *
                         ELEMENTS, FOR IF SO THE LIST CONSISTS OF A    *
                         SERIES OF FIELD NAMES OR (D,L) PAIRS.
.**********************************************************************
.* K HAS ONLY ONE ELEMENT ON LEVEL 1. FIND OUT WHICH OF THE FOLLOWING *
.* CASES APPLIES, AND TAKE THE INDICATED ACTION:                      *
.* IN THE FOLLOWING DISCUSSION, )F" MEANS A FIELD NAME, "D" MEANS     *
.* DISPLACEMENT, "L" MEANS LENGTH, AND "X" MEANS ANY STRING. THE D AND*
.* L FIELDS MUST BE SELF-DEFINING TERMS,.                             *
.* IF:   THEN:                                                        *
.* K=F   ENTER THE ROUTINE AT .KMIXED TO PROCESS A LIST OF PAIRS OF   *
.*       F'S AND (D,L) PAIRS, SINCE THIS CASE WILL BE TREATED AS A    *
.*       SINGLE FIELD NAME BY THAT ROUTINE.                           *
.* K=(F) THIS IS AN ERROR, BECAUSE OF THE POSSIBLE FUTURE USE OF THIS *
.*       FORM TO INDICATE THE ADDRESS OF A LIST OF DISPLACEMENT-LENGTH*
.*       PAIRS IN A REGISTER.                                         *
.* K=L   L IS THE LENGTH OF THE RECORD TO BE INSERTED. THE A PARMAETER*
.*       MUST BE CODED FOR THIS TO BE VALID, BECAUSE OTHERWISE THERE  *
.*       IS NO WAY TO FIND OUT WHERE THE RECORD IS THAT IS TO BE      *
.*       INSERTED.                                                    *
.* K=(L) THIS IS AN ERROR, BECAUSE OF THE POSSIBILITY THAT IN THE     *
.*       FUTURE I WILL WANT TO PUT THE ADDRESS OF A LIST OF           *
.*       DISPLACEMENT-LENGTH PAIRS IN A REGISTER.                     *
.* K=((X)) ENTER THE .KMIXED ROUTINE, SINCE IT LOOKS LIKE A LIST OF   *
.*       DISPLACEMENT-LENGTH PAIRS WITH ONLY ONE PAIR.                *
.*       ANYTHING ELSE IS INVALID, AND PRODUCES THE MNOTE 12,'INVALID *
.*       R-PARAMETER.'                                                *
.**********************************************************************
         AIF   ('&K'(1,1) NE '(').KNOTLP  SEE IF THERE ARE NO          *
                         PARENTHESES AROUND THE OPERAND.
         AIF   ('&K'(1,2) EQ '((').KMIXED  SEE IF THIS IS THE CASE     *
                         K=((X)).
         MNOTE 12,'A REGISTER CANNOT BE SPECIFIED FOR THE LIST OF DISPL*
               ACEMENT-LENGTH PAIRS.'
&ERROR   SETB  1         SET THE ERROR FLAG ON.
         AGO   .KFIN     END THIS PART.
.**********************************************************************
.* THIS MUST BE ONE OF THE TWO CASES K=F OR K=L.                      *
.**********************************************************************
.KNOTLP  ANOP
         AIF   (((T'&K(1) NE 'M')AND(T'&K(1) NE 'N')AND(T'&K(1) NE 'O')*
               AND(T'&K(1) NE 'T')AND(T'&K(1) NE 'W')AND(T'&K(1) NE '$'*
               )AND(T'&K(1) NE 'U'))).KMIXED
.* THIS MUST BE THE CASE WHERE "R=L" IS CODED.                        *
         AIF   (T'&K(1) NE 'N').K1NOTN  SEE IF IT IS A SELF-DEFINING   *
                         FIELD.
.**********************************************************************
.* K=L IS CODED, AND L IS A SELF-DEFINING TERM. USE L FOR THE RECORD  *
.* LENGTH, BUT FIRST CHECK TO SEE IF THE A PARAMETER IS CODED. IF THE *
.* A PARAMETER IS NOT CODED IT IS AN ERROR.                           *
.**********************************************************************
&IGAKEYL SETA  (&K(1))   GET THE RECORD LENGTH FROM THE L OF THE K     *
                         PARAMETER.
         AIF   (K'&A EQ 0).K1AMT  SEE IF THE A PARAMETER HAS BEEN LEFT *
                         OUT.
         AIF   (&IGAKEYL GT 256).K1LERR  FOR THE NONCE ONLY TAKE FIELDS*
                         THAT ARE LESS THAN 257 BYTES LONG.
         AIF   (NOT &XFER).KFIN  SEE IF THIS IS THE MVC GENERATION     *
                         LOOP, OR JUST THE VALIDATION AND ADDING UP    *
                         FIELD LENGTHS LOOP.
         AIF   ('&A'(1,1) EQ '(').K1AGPR  SEE IF THE ADDRESS IS IN A   *
                         GPR.
         LA    0,&A      ADDRESS OF SEARCH KEY.
         AGO   .KFIN     ALL DONE NOW.
.K1AGPR  AIF   ('&A' EQ '(0)').KFIN  SEE IF THE SEARCH KEY ADDRESS IS  *
                         ALREADY IN REGISTER 0.
         LR    0,&A(1)   ADDRESS OF SEARCH KEY.
         AGO   .KFIN     GO TO THE END OF THE K PARAMETER PROCESSING.
.**********************************************************************
.* FOLLOWING ARE THE MISCELLANEOUS ERROR MNOTES FROM THE SINGLE       *
.* ELEMENT CASE OF THE K PARAMETER.                                   *
.**********************************************************************
.K2LERR  ANOP
.K1LERR  MNOTE 12,'THE LENGTH OF EACH FIELD DEFINED BY K CANNOT EXCEED *
               256 BYTES.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON SO THE MVC'S DON'T GET  *
                         GENERATED.
         AGO   .KFIN
.K1AMT   MNOTE 12,'THE A PARAMETER MUST BE CODED WITH K AS CODED.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .KFIN
.K1NOTN  MNOTE 12,'THE LENGTH MUST BE A SELF-DEFINING TERM FOR THE K PA*
               RAMETER.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .KFIN
.**********************************************************************
.* THE K PARAMETER HAS EXACTLY TWO ELEMENTS IN IT ON LEVEL 1. SEE IF  *
.* EITHER OF THESE TWO ELEMENTS STARTS WITH A LEFT PARENTHESIS, WHICH *
.* MEANS ONE OF THE CASES K=(X,(X)), K=((X),X), OR K=((X),(X)). IF IT *
.* IS ONE OF THESE CASES ENTER THE MIXED ROUTINE AT .KMIXED.          *
.* IF IT IS NOT ONE OF THOSE THREE CASES, THEN IT MUST BE ONE OF THE  *
.* CASES K=(F,F), K=(F,L), OR K=(D,L). NOTE THAT THE CASE K=(D,L) CAN *
.* BE CODED AS K=(,L).                                                *
.**********************************************************************
.KHAS2   AIF   (K'&K(2) NE 0).K2NOTMT  SEE IF THE SECOND ELEMENT IS THE*
                         EMPTY STRING. THIS IS NO GOOD.
         MNOTE 12,'THE SECOND ELEMENT OF A DISPLACEMENT-LENGTH PAIR MUS*
               T BE CODED.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .FIN      FORGET IT, CAN'T DO ANYTHING WITH AN EMPTY    *
                         STRING FOR THE LENGTH.
.K2DMT   ANOP
&DSP     SETA  (0)       SET THE DISPLACEMENT TO ZERO, SINCE IT IS     *
                         CODED AS THE EMPTY STRING.
         AGO   .K2MERGE  MERGE WITH THE CASE WHERE THE DISPLACEMENT IS *
                         NOT THE EMPTY STRING.
.K2NOTMT AIF   (K'&K(1) EQ 0).K2DMT  SEE IF THE DISPLACEMENT IS THE    *
                         EMPTY STRING.
         AIF   (('&K(1)'(1,1) EQ '(')OR('&K(2)'(1,1) EQ '(')).KMIXED   *
                         LOOK FOR ONE OF THE CASES K=(X,(X)), K=((X),  *
                         X), OR K=((X),(X)).
         AIF   (((T'&K(2) NE 'M')AND(T'&K(2) NE 'N')AND(T'&K(2) NE 'O')*
               AND(T'&K(2) NE 'T')AND(T'&K(2) NE 'W')AND(T'&K(2) NE '$'*
               )AND(T'&K(2) NE 'U'))).KMIXED
.* THE SECOND ELEMENT IS NOT A FIELD NAME, SO IT MUST EITHER BE ONE OF*
.* THE TWO CASES K=(F,L) OR K=(D,L), OR IT IS AN ERROR.               *
&IGAKEYL SETA  0         ALLOW THE CASE WHERE THE LENGTH IS LEFT OUT   *
                         WHEN THERE IS ONLY ONE DISPLACEMENT.
         AIF    (K'&K EQ 0).MERGEK2  SEE IF THE LENGTH IS ELIDED.
         AIF   ((T'&K(1) NE 'M')AND(T'&K(1) NE 'N')AND(T'&K(1) NE 'O')A*
               ND(T'&K(1) NE 'T')AND(T'&K(1) NE 'W')AND(T'&K(1) NE '$')*
               AND(T'&K(1) NE 'U')).K2F1
         AIF   (T'&K(1) EQ 'N').K2D  SEE IF THE DISPLACEMENT IS A SELF-*
               DEFINING TERM.
&I       SETA  (K'&K(1)) THE DISPLACEMENT IS NOT A SELF-DEFINING TERM,
.K2DCHK  AIF   (('&K(1)'(&I,1) LT '0')OR('&K(1)'(&I,1) GT '9')).K2DTYPE
&I       SETA  (&I+1)    SEE IF IT IS A DECIMAL NUMBER ANYWAY.
         AIF   (&I GT 0).K2DCHK  THIS IS NECESSARY BECAUSE OF THE WAY  *
               ASSEMBLER F DOES NOT RECORD THE CORRECT TYPE ATTRIBUTE  *
               OF OPERANDS PASSED IN A SUBLIST VIA MACRO-RECURSION.
         AIF   (K'&K(1) GT 4).K2DERR  SEE IF IT HAS TOO MANY DIGITS.
.K2D     ANOP
&DSP     SETA  (&K(1))   PICK UP THE DISPLACEMENT.
.K2MERGE ANOP
         AIF   (T'&K(2) EQ 'N').K2L  SEE IF IT IS A SELF-DEFINING TERM.
&I       SETA  (K'&K(2))  SET THE INDEX TO IT'S INITIAL VALUE.
         AIF   (K'&K(2) EQ 0).K2LERR SEE IF IT IS THE EMPTY STRING.
.K2LCHK  AIF   (('&K(2)'(&I,1) LT '0')OR('&K(2)'(&I,1) GT '9')).K2LTYPE
&I       SETA  (&I-1)    DECREASE THE INDEX TO THE NEXT CHARACTER.
         AIF   (&I GT 0).K2LCHK  SEE IF THERE ARE MORE TO CHECK.
         AIF   (K'&K(2) GT 4).K2LERR  SEE IF IT HAS TOO MANY DIGITS.
.K2L     ANOP
&IGAKEYL SETA  (&K(2))   GET THE LENGTH AS A NUMBER.
.MERGEK2 ANOP
         AIF   (&IGAKEYL GT 256).K1LERR  SEE IF THE LENGTH IS MORE THAN*
                         256 BYTES.
         AIF   (&DSP GT 4095).K2DERR  SEE IF THE DISPLACEMENT IS       *
                         GREATER THAN 4095.
         AIF   (K'&A EQ 0).K1AMT  SEE IF THE A PARAMETER IS LEFT OUT;  *
                         THAT IS BAD.
         AIF   (NOT &XFER).KFIN  SEE IF THIS IS THE MVC GENERATING LOOP*
                         OR NOT.
.**********************************************************************
.* THERE IS ONLY ONE FIELD SPECIFIED FOR THE KEY; PUT ITS ADDRESS IN  *
.* REGISTER 0 FOR THE SEARCH SUBROUTINE IN IGARPT01.                  *
.**********************************************************************
         AIF   ('&A'(1,1) EQ '(').K2AGPR  SEE IF THE ADDRESS IS IN A   *
                         GPR.
         AIF   (&DSP EQ 0).K2SZDSP  SEE IF THE DISPLACEMENT IS ZERO.
         LA    0,&DSP+&A  ADDRESS OF SEARCH KEY.
         AGO   .KFIN
.K2SZDSP LA    0,&A      ADDRESS OF SEARCH KEY.
         AGO   .KFIN     ALL DONE WITH THE A AND K NOW.
.K2AGPR  AIF   (&DSP EQ 0).K2RZDSP  SEE IF THE DISPLACEMENT IS ZERO.
         LA    0,&DSP&A  ADDRESS OF SEARCH KEY.
         AGO   .KFIN
.K2RZDSP AIF   ('&A' EQ '(0)').KFIN  SEE IF THE ADDRESS IS ALREADY IN  *
                         REGISTER 0.
         LR    0,&A(1)   ADDRESS OF SEARCH KEY.
         AGO   .KFIN     ALL DONE GETTING THE ADDRESS OF THE SEARCH KEY*
                         IN REGISTER 0.
.**********************************************************************
.* IT IS AN (F,L) PAIR, NOW SEE IF THE SECOND ELEMENT IS A VALID L.   *
.**********************************************************************
.K2F1    AIF   (T'&K(2) EQ 'N').K2F  SEE IF IT IS A SELF-DEFINING TERM.
&I       SETA  (K'&K(2))  SET THE INDEX TO IT'S INITIAL VALUE.
.K2FCHK  AIF   (('&K(2)'(&I,1) LT '0')OR('&K(2)'(&I,1) GT '9')).K2LTYPE
&I       SETA  (&I+1)    EKE THE INDEX TO THE NEXT CHARACTER.
         AIF   (&I GT 0).K2FCHK  SEE IF THERE ARE MORE TO CHECK.
         AIF   (K'&K(2) GT 4).K2LERR  SEE IF IT HAS TOO MANY DIGITS.
.K2F     ANOP
&IGAKEYL SETA  (&K(2))   GET THE LENGTH OF THE (F,L) PAIR.
         AIF   (&IGAKEYL GT 256).K1LERR  SEE IF THE LENGTH OF THE FIELD*
                         IS MORE THAN 256.
         AIF   (NOT &XFER).KFIN  SEE IF THIS IS THE MOVE GENERATION    *
                         LOOP.
         AIF   (K'&A EQ 0).AISNT  SEE IF A ISN'T.
         MNOTE 4,'THE A PARAMETER IS REDUNDANT.'
.AISNT   LA    0,&K(1)   ADDRESS OF SEARCH KEY.
         AGO   .KFIN     ALL DONE NOW, GO CHECK FOR THE MOVE GENERATION*
                         ITERATION.
.**********************************************************************
.* THE FOLLOWING ARE THE SUNDRY MNOTES FOR THE TWO ELEMENT CASE FOR   *
.* THE K PARAMETER.                                                   *
.**********************************************************************
.K2DERR  MNOTE 12,'DISPLACEMENT IN K PARAMETER CANNOT EXCEED 4095.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .KFIN
.K2DTYPE MNOTE 12,'THE DISPLACEMENT IN K MUST BE A SELF-DEFINING TERM.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON TO PREVENT THE MVC      *
                         GENERATION.
         AGO   .KFIN
.K2LTYPE MNOTE 12,'THE LENGTH IN K MUST BE A SELF-DEFINING TERM.'
&ERROR   SETB  1         SET THE ERROR FLAG ON.
         AGO   .KFIN
.**********************************************************************
.* THE K PARAMETER CONSISTS OF A LIST OF MIXED PAIRS OF FIELDS AND    *
.* DISPLACEMENT-LENGTH PAIRS. PICK OUT ALL THESE AND CHECK THEM FOR   *
.* VALIDITY, WHILE ADDING UP ALL THE LENGTHS OF THE INDIVIDUAL FIELDS *
.* FOR THE MOVES TO IGAWORK, AND (POSSIBLY) FOR USE IN THE REL        *
.* PARAMETER LATER.                                                   *
.**********************************************************************
.* THIS IS THE SECTION TO PROCESS A MIXED LIST OF FIELD NAMES AND (D  *
.* ,L) PAIRS. PARSE THE OPERAND USING THE PARSE IN THE RPTDSECT       *
.* MACRO-INSTRUCTION, AND CHECK THE VARIABLE &IGAOKAY TO SEE IF THERE *
.* ARE NO SYNTAX ERRORS IN THE K PARAMETER.                           *
.**********************************************************************
.KMIXED  ANOP
      RPTDSECT SCAN=PARSE,LIST=&K  PARSE THE OPERAND.
         AIF   (&IGAOKAY).KMXOK  SEE IF THE PARSE DETECTED BAD SYNTAX.
         MNOTE 12,'INVALID SYNTAX IN THE K PARAMETER.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .KFIN     CAN'T DO ANYTHING WITH THIS.
.**********************************************************************
.* THE SYNTAX APPEARS TO BE OK, NOW START SCANNING OUT THE ATOMS ONE  *
.* AT A TIME, ANALYZING EACH ONE INDIVIDUALLY IN CONTEXT WITH THE ONES*
.* ON EITHER SIDE OF IT.                                              *
.**********************************************************************
.KMXOK RPTDSECT SCAN=ISCAN  INITIALIZE FOR SUBSEQUENT SCANNING OF      *
                         ATOMS.
         L     15,(&IGAKEYW+&IGABLST)(,1)   ADDR OF W.A. TO COLLECT THE
         BALR  14,0      SEARCH KEY OR THE ADDRESS OF A ROUTINE IN THE
         LTR   0,15      MODULE IGARPT01 TO GET AN AREA TO USE FOR
&WORKEY  SETB  (1)       ON TO INDICATE THAT THE KEY HAS BEEN COLLECTED*
                         AT IGAWORK.
         BCR   4,15      COLLECTING THE SEARCH KEY.
.KMXMOR RPTDSECT SCAN=NEXT  GET THE CURSOR POSITIONED AT THE NEXT ATOM.
.KMXCHK  AIF   (&IGAX EQ 0).KFIN  SEE IF THERE ARE ANY MORE TO DO.
         AIF   (&IGALEVL EQ 2).KMXLVL2  SEE IF THIS ATOM IS ON LEVEL 2.
         AIF   (&IGALEVL LE 1).KMXL01  SEE IF THIS ATOM IS ON LEVEL 0  *
                         OR 1.
.**********************************************************************
.* THE CURRENT ATOM HAS TOO MANY LEVELS OF PARENTHESES AROUND IT, GIVE*
.* THE ERROR MESSAGE AND GO LOOK FOR THE NEX THING THAT CHANGES LEVEL *
.* 1 IN THE PATH VECTOR.                                              *
.**********************************************************************
&I       SETA  &IGAPATH(1)+1  SET &I TO THE CURRENT OPERAND NUMBER.
         MNOTE 12,'TOO MANY () LEVELS IN OPERAND &I OF R.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
.**********************************************************************
.* AN ERROR HAS BEEN DETECTED AND FLAGGED IN THE CURRENT OPERAND. SCAN*
.* OVER TO THE NEXT ATOM THAT IS NOT PART OF THE CURRENT ENTRY ON     *
.* LEVEL 1 IN THE PARAMETER.                                          *
.**********************************************************************
.SYNC    ANOP
&I       SETA  &IGAPATH(1)  SET &I TO THE INDEX OF THE OPERAND ON LEVEL*
                         1.
      RPTDSECT SCAN=NEXT  SET THE CURSOR TO THE NEXT ONE.
         AIF   (&IGAX EQ 0).KFIN  SEE IF THERE AREN'T ANY MORE.
         AIF   (&I EQ &IGAPATH(1)).SYNC  SEE IF IT IS STILL ON THE SAME*
                         ONE.
         AGO   .KMXCHK   FINALLY GOT THE NEXT ATOM, NOW GO CHECK IT FOR*
                         VALIDITY.
.**********************************************************************
.* THE CURRENT ATOM IS ON LEVEL 0 OR 1. THEREFORE IT SHOULD BE A VALID*
.* FIELD NAME; SEE IF IT IS.                                          *
.**********************************************************************
.KMXL01  ANOP
.KMX01   ANOP
&I       SETA  (1+&IGAPATH(1))  SET &I TO THE 1-ORIGIN INDEX OF THE    *
                         FIELD NAME ON LEVEL 1.
         AIF   ((T'&K(&I) NE 'M')AND(T'&K(&I) NE 'N')AND(T'&K(&I) NE 'O*
               ')AND(T'&K(&I) NE 'T')AND(T'&K(&I) NE 'W')AND(T'&K(&I) N*
               E '$')AND(T'&K(&I) NE 'U')).KMX01OK
         MNOTE 12,'OPERAND &I OF K DOES NOT HAVE THE PROPER TYPE ATTRIB*
               UTE.'
&ERROR   SETB  (1)       SET THE ERROR FLAG.
         AGO   .SYNC     GO POSITION THE CURSOR TO THE NEXT ONE.
.**********************************************************************
.* THE CURRENT ATOM LOOKS LIKE A VALIID FIELD NAME, GET ITS LENGTH    *
.* ATTRIBUTE AND SEE IF IT ACCEPTABLE.                                *
.**********************************************************************
.KMX01OK ANOP
&LNG     SETA  (L'&K(&I))  CAPTURE IT AS A NUMBER.
         AIF   (&LNG LE 256).KMX0LOK  SEE IF IT EXCEEDS 256.
         MNOTE 12,'THE LENGTH OF FIELD &I OF K EXCEEDS 256 BYTES.'
&ERROR   SETB  (1)       SET TEH ERROR FLAG.
         AGO   .SYNC     GO LOOK AT THE NEXT ONE.
.KMX0LOK ANOP
.**********************************************************************
.* NOW SEE IF THIS IS THE MOVE GENERATION ITERATION.                  *
.**********************************************************************
         AIF   (NOT &XFER).KX0M  GO IF THIS ISN'T THE MOVE GENERATION  *
                         ITERATION.
         MVC   &IGAKEYL.(&LNG,15),&K(&I)         MOVE SUBKEY.
.KX0M    ANOP
&IGAKEYL SETA  (&IGAKEYL+&LNG)  EKE THE CUMMULATIVE RECORD LENGTH.
         AIF   (&IGAKEYL LE 256).KMXMOR  SEE IF THE KEYL LENGTH IS     *
                         STILL LESS THAN 257.
         AIF   (&KLMNOTE).KMXMOR  SEE IF THE MNOTE HAS ALREADY BEEN    *
                         GENERATED.
&KLMNOTE SETB  (1)       SET THE BIT ON SO THE MNOTE ONLY GETS         *
                         GENERATED ONCE.
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         MNOTE 12,'KEY LENGTH EXCEEDS 256 BYTES.'
         AGO   .KMXMOR   GO LOKK FOR THE NEXT ONE.
.**********************************************************************
.* THE CURRENT ATOM IS ON LEVEL 2. IT MUST THEREFORE BE THE FIRST     *
.* ELEMENT IN ONE OF THE CASES (F,L) OR (D,L).                        *
.* FIND OUT WHETHER THE CURRENT ATOM IS AN F OR A D.                  *
.**********************************************************************
.KMXLVL2 ANOP
&X       SETC  '0'       SET THIS FOR THE CASE WHERE THE DISPLACEMENT  *
                         IS AN EMPTY STRING.
         AIF   (&IGAZ EQ 0).KMGDSP  GO IF IT IS AN EMPTY STRING, WHICH *
                         MEANS A DISPLACEMENT OF 0.
.**********************************************************************
.* SEE IF ALL THE CHARACTERS IN THE CURRENT ATOM ARE DIGITS 0 THROUGH *
.* 9, WHICH WOULD MAKE IT A SELF-DEFINING DECIMAL TERM.               *
.**********************************************************************
&I       SETA  0         INITIALIZE THE INDEX OF THE CURRENT CHARACTER *
                         IN THE ATOM.
.KMCONT  AIF   (('&K'(&IGALEFT(&IGAZ)+&I,1) LT '0')OR('&K'(&IGALEFT(&IG*
               AZ)+&I,1) GT '9')).KMNOTD
&I       SETA  (&I+1)    EKE THE INDEX.
         AIF   (&I LT &IGARGHT(&IGAZ)).KMCONT  KEEP GOING UNTIL ALL    *
                         DIGITS HAVE BEEN EXAMINED.
         AIF   (&IGARGHT(&IGAZ) GT 4).KMXBADD  SEE IF THE DISPLACEMENT *
                         HAS TOO MANY BYTES IN IT.
&X       SETC  '&K'(&IGALEFT(&IGAZ),&I)  GET THE DISPLACEMENT AS A     *
                         NUMBER.
.KMGDSP  ANOP
&DSP     SETA  (&X)      GET THE NUMBER NOW.
         AIF   (&DSP GT 4095).KMXDBAD  SEE IF THE DISPLACEMENT IS TOO  *
                         BIG.
.**********************************************************************
.* THE CURRENT ATOM IS A VALID DISPLACEMENT OF A (D,L) PAIR, AND ITS  *
.* ARITHMETIC VALUE IS IN THE APPROPRIATE RANGE OF VALUES FOR A       *
.* DISPLACEMENT. ITS VALUE HAS BEEN CAPTURED IN &DSP. NOW LOOK FOR THE*
.* CORRESPONDING L OF THE PAIR.                                       *
.**********************************************************************
&I       SETA  (&IGAPATH(1))  SAVE THE CURRENT ATOM LEVEL 1 INDEX.
      RPTDSECT SCAN=NEXT  POSITION THE CURSOR TO THE NEXT ATOM.
         AIF   (&IGAX EQ 0).KMXNOLL  SEE IF THERE ISN'T ANY L FOR IT   *
                         BECAUSE THERE AREN'T ANY MORE ATOMS.
         AIF   (&IGAPATH(1) NE &I).KMXNOL  SEE IF THE NEXT ATOM IS PART*
                         OF A DIFFERENT ELEMENT ON LEVEL 1.
         AIF   (&IGALEVL NE 2).KMXPRN  SEE IF THERE ARE TOO MANY LEVELS*
                         OF PARENTHESES.
         AIF   (&IGAZ EQ 0).KMXLBAD  SEE IF THE L ATOM IS THE EMPTY    *
                         STRING.
.**********************************************************************
.* THERE IS A NEXT ATOM IN THE SAME PAIR, NOW CHECK IT TO SEE IF IT IS*
.* A SELF-DEFINING DECIMAL TERM.                                      *
.**********************************************************************
&I       SETA  0  INITIALIZE THE INDEX OF THE CURRENT BYTE IN THE ATOM.
.KMCNT1  AIF   (('&K'(&IGALEFT(&IGAZ)+&I,1) LT '0')OR('&K'(&IGALEFT(&IG*
               AZ)+&I,1) GT '9')).KMXBADL
&I       SETA  (&I+1)    EKE THE INDEX TO THE NEXT BYTE.
         AIF   (&I LT &IGARGHT(&IGAZ)).KMCNT1  KEEP LOOKING UNTIL ALL  *
                         THE BYTES ARE EXAMINED.
         AIF   (&IGARGHT(&IGAZ) GT 4).KMXLERR  SEE IF THE LENGTH IS    *
                         MORE THAN 4 CHARACTERS.
&X       SETC  '&K'(&IGALEFT(&IGAZ),&IGARGHT(&IGAZ))  GET THE LENGTH.
&LNG     SETA  (&X)      TURN IT INTO A NUMBER.
         AIF   (&LNG GT 256).KMXLERR  SEE IF IT IS TOO BIG TO DO WITH  *
                         AN MVC.
.**********************************************************************
.* THE DISPLACEMENT OF THE DISPLACEMENT-LENGTH PAIR IS AT &DSP, AND   *
.* THE LENGTH IS AT &LNG. CHECK THE A PARAMETER TO SEE IF IT IS CODED,*
.* BECAUSE IF IT ISN'T CODED THERE IS NO WAY TO FIND OUT WHERE THE    *
.* RECORD REALLY IS.                                                  *
.**********************************************************************
         AIF   (K'&A EQ 0).KMXAMT  SEE IF IT ISN'T THERE.
.* NOW GENERATE THE MOVE OF THE FIELD IF THIS IS THE MOVE GENERATION  *
.* ITERATION.                                                         *
         AIF   (NOT &XFER).KMOVED  SEE IF IT ISN'T THE MOVE GENERATION *
                         ITERATION.
&X       SETC  ''        SET IT UP FOR THE ADDRESS IN A REGISTER.
         AIF   ('&A'(1,1) EQ '(').KMAGPR  GO IF THE ADDRESS IS IN A    *
                         REGISTER.
&X       SETC  '+'       SET IT UP FOR THE CASE EHERE THE ADDRESS IS   *
                         SUPPLIED IN THE FORM OF A LABEL.
.KMAGPR  MVC   &IGAKEYL.(&LNG,15),&DSP&X&A            MOVE SUBKEY.
.KMOVED  ANOP
&IGAKEYL SETA  (&IGAKEYL+&LNG)  EKE THE CUMMULATIVE RECORD LENGTH.
         AIF   (&IGAKEYL LE 256).STILLOK  SEE IF THE CUMMULATIVE KEY   *
                         LENGTH HAS GONE OVER 256 BYTES.
         AIF   (&KLMNOTE).STILLOK  SEE IF THE MNOTE HAS ALREADY BEEN   *
                         GENERATED.
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
&KLMNOTE SETB  (1)   SET IT ON SO THE MNOTE HAS ALREADY BEEN GENERATED.
         MNOTE 12,'KEY LENGTH IS TOO BIG   256 BYTES IS MAX.'
.STILLOK ANOP
.**********************************************************************
.* NOW SET THE CURSOR TO THE NEXT ATOM, AND SEE IF THE FIRST ELEMENT  *
.* IS PART OF THE SAME ELEMENT ON LEVEL 1 AS THE LAST (D,L) PAIR.     *
.**********************************************************************
&I       SETA  &IGAPATH(1)  PRESERVE THE CURRENT LEVEL 0 INDEX.
      RPTDSECT SCAN=NEXT  POSITION THE CURSOR TO THE NEXT ATOM.
         AIF   (&IGAX EQ 0).KFIN  GO IF THERE ISN'T ANY NEXT ATOM.
         AIF   (&I EQ &IGAPATH(1)).KMXSAME  SEE IF THE LEVEL 1 ELEMENT *
                         IN THE PATH VECTOR DIDN'T CHANGE.
         AGO   .KMXCHK   GO CHECK THE NEXT ATOM, IT ISN'T PART OF THE  *
                         LAST TWO.
.**********************************************************************
.* THE FOLLOWING ARE SUNDRY MNOTES FROM THE PROCESSING OF A LIST OF   *
.* MIXED PAIRS WHERE THE PAIRS ARE OF THE FORM (D,L).                 *
.**********************************************************************
.KMXSAME ANOP
&I       SETA  (&IGAPATH(1)+1)  SET &I TO THE CURRENT OPERAND #.
         MNOTE 12,'TOO MANY ELEMENTS IN SUBLIST OPERAND &I IN R.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .SYNC     GO LOOK FOR THE NEXT ONE.
.KMXAMT  ANOP
&I       SETA  (1+&IGAPATH(1))  GET THE CURRENT OPERAND NUMBER.
         MNOTE 12,'THE A PARAMETER MUST BE CODED TO USE A (D,L) PAIR FO*
               R K(&I).'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .SYNC     GO LOOK FOR THE NEXT ONE.
.KMXLERR ANOP
&I       SETA  (&IGAPATH(1)+1)  GET THE CURRENT OPERAND NUMBER.
         MNOTE 12,'THE LENGTH OF THE FIELD DEFINED BY K(&I) EXCEEDS 256*
                BYTES.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .SYNC     GO LOOK AT THE NEXT ONE.
.KMXBADL ANOP
&I       SETA  (1+&IGAPATH(1))
         MNOTE 12,'THE LENGTH FOR K(&I) MUST BE A SELF-DEFINING DECIMAL*
                NUMBER.'
&ERROR   SETB  (1)
         AGO   .SYNC
.KMXLBAD ANOP
&I       SETA  (1+&IGAPATH(1))
         MNOTE 12,'THE LENGTH FOR K(&I) CANNOT BE THE EMPTY STRING.'
&ERROR   SETB  (1)
         AGO   .SYNC
.KMXNOL  ANOP
&I       SETA  (1+&IGAPATH(1))
         MNOTE 12,'LENGTH OF (D,L) PAIR MISSING IN K(&I).'
&ERROR   SETB  (1)
         AGO   .KMXCHK   GO CHECK THE CURRENT ATOM FOR VALIDITY.
.KMXNOLL ANOP
         MNOTE 12,'LENGTH OF LAST (D,L) PAIR IN K IS MISSING.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .KFIN
.KMXPRN  ANOP
&I       SETA  (&IGAPATH(1)+1)
         MNOTE 12,'TOO MANY () LEVELS IN K(&I).'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .SYNC
.KMXBADD ANOP
&I       SETA  (1+&IGAPATH(1))
         MNOTE 12,'DISPLACEMENT IN K(&I) EXCEEDS 4 DIGITS.'
&ERROR   SETB  (1)
         AGO   .SYNC
.KMXDBAD ANOP
&I       SETA  (1+&IGAPATH(1))
         MNOTE 12,'DISPLACEMENT IN K(&I) EXCEEDS 4095.'
&ERROR   SETB  (1)
         AGO   .SYNC
.**********************************************************************
.* THE CURRENT ATOM IS AN F OF A (F,L) PAIR.                          *
.**********************************************************************
.KMNOTD  AIF   (&IGARGHT(&IGAZ) LE 8).KMXBIGF  SEE IF THE STRING IS    *
                         BIGGER THAN 8 CHARACTERS.
&I       SETA  (1+&IGAPATH(1))
         MNOTE 12,'FIELD NAME IN K(&I) IS BIGGER THAN 8 CHARACTERS.'
&ERROR   SETB  (1)
         AGO   .SYNC
.KMXBIGF ANOP
&FIELD   SETC  '&K'(&IGALEFT(&IGAZ),&IGARGHT(&IGAZ))  GET THE FIELD    *
                         NAME.
.* NOW TRY TO GET THE L OF THE (F,L) PAIR.                            *
&I       SETA  (&IGAPATH(1))  PRESERVE THE CURRENT LEVEL 1 INDEX.
      RPTDSECT SCAN=NEXT  POSITION THE CURSOR TO THE NEXT ATOM.
         AIF   (&IGAX EQ 0).KFLNOL  SEE IF THERE IS NO LENGTH BECAUSE  *
                         THERE ISN'T ANY NEXT ATOM.
         AIF   (&IGAPATH(1) NE &I).KFNOL  SEE IF THE NEXT ATOM IS NOT  *
                         PART OF THE SAME PAIR.
         AIF   (&IGALEVL NE 2).KFNOLL  SEE IF THE NEXT ATOM HAS TOO    *
                         MANY () LEVELS.
         AIF   (&IGAZ EQ 0).KFLMT  SEE IF THE LENGTH ATOM IS THE EMPTY *
                         STRING.
.**********************************************************************
.* THE CURRENT ATOM IS INDEED THE SECOND ELEMENT OF A (F,X) PAIR. NOW *
.* LET'S SEE IF X IS A VALID L.                                       *
.**********************************************************************
         AIF   (&IGARGHT(&IGAZ) GT 3).KFLLBAD  SEE IF THE LENGTH ATOM  *
                         IS MORE THAN 3 DIGITS.
&I       SETA  0         INITIALIZE THE INDEX OF THE CURRENT BYTE.
.KMXCNT2 AIF   (('&K'(&IGALEFT(&IGAZ)+&I,1) LT '0')OR('&K'(&IGALEFT(&IG*
               AZ)+&I,1) GT '9')).KFLBAD
&I       SETA  (&I+1)    STEP OVER TO THE NEXT DIGIT.
         AIF   (&I LT &IGARGHT(&IGAZ)).KMXCNT2  KEEP GOING UNTIL ALL   *
                         THE DIGITS HAVE BEEN SCANNED.
&X       SETC  '&K'(&IGALEFT(&IGAZ),&IGARGHT(&IGAZ))  EXTRACT THE      *
                         LENGTH.
&LNG     SETA  (&X)      CONVERT IT TO A NUMBER.
         AIF   (&LNG GT 256).KFBADL  SEE IF THE LENGTH EXCEEDS 256     *
                         BYTES.
.**********************************************************************
.* IT LOOKS LIKE A VALID (F,L) PAIR; GENERATE THE MOVE IF THIS IS THE *
.* MOVE GENERATION ITERATION.                                         *
.**********************************************************************
         AIF   (NOT &XFER).KMOVED  GO IF IT IS NOT THE MOVE ITERATION.
         MVC   &IGAKEYL.(&LNG,15),&FIELD         MOVE SUBKEY.
         AGO   .KMOVED   MERGE WITH THE COMMON PATH.
.**********************************************************************
.* THE FOLLOWING ARE SUNDRY MNOTES FOR THE (F,L) CASE IN A MIXED LIST.*
.**********************************************************************
.KFBADL  ANOP
&I       SETA  (&IGAPATH(1)+1)
         MNOTE 12,'LENGTH IN OPERAND &I OF K EXCEEDS 256 BYTES.'
&ERROR   SETB  (1)
         AGO   .SYNC
.KFLBAD  ANOP
&I       SETA  (1+&IGAPATH(1))
         MNOTE 12,'THE LENGTH IN OPERAND K(&I) IS NOT A SELF-DEFINING D*
               ECIMAL NUMBER.'
&ERROR   SETB  (1)
         AGO   .SYNC
.KFLLBAD ANOP
&I       SETA  (1+&IGAPATH(1))
         MNOTE 12,'LENGTH IN OPERAND K(&I) IS MORE THAN 3 DIGITS.'
&ERROR   SETB  (1)
         AGO   .SYNC
.KFLMT   ANOP
&I       SETA  (1+&IGAPATH(1))
         MNOTE 12,'LENGTH IN OPERAND &I OF K CANNOT BE THE EMPTY STRING*
               .'
&ERROR   SETB  (1)
         AGO   .SYNC
.KFNOL   ANOP
         MNOTE 12,'LENGTH OF (F,L) PAIR IN OPERAND &I OF K IS MISSING.'
&ERROR   SETB  (1)
         AGO   .KMXCHK
.KFNOLL  ANOP
&I       SETA  (1+&IGAPATH(1))
         MNOTE 12,'TOO MANY () LEVELS IN K(&I).'
         AGO   .SYNC
.KFLNOL  MNOTE 12,'LENGTH OF LAST (FIELD,LENGTH) PAIR IN K IS MISSING.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON TO PREVENT THE MOVES.
         AGO   .KFIN
.**********************************************************************
.KFIN    ANOP
         AGO   .LINK     GO LINK TO THE SRCH8 SUBROUTINE.
.**********************************************************************
.* THERE IS NO NEED TO COLLECT THE SEARCH KEY AT IGAWORK, BECAUSE THE *
.* THE K PARAMETER IS NOT CODED, AND THERE IS ONLY ONE FIELD.         *
.**********************************************************************
.CHKA    AIF   (K'&A EQ 0).ASARG  SEE IF THE ADDRESS IS OMITTED; IF IT *
                         IS GET IT OUT OF THE SEARCH ARGUMENT.
         AIF   ('&A'(1,1) EQ '(').AGPR  SEE IF THE ADDRESS IS IN A GPR.
         LA    0,&A  ADDRESS OF SEARCH KEY.
         AGO   .CHKAEND  GO TO THE END OF CHECKING THE A PARAMETER.
.AGPR    AIF   ('&A' EQ '(0)').CHKAEND  SEE IF IT IS ALREADY IN R0.
         LR    0,&A(1)   ADDRESS OF SEARCH KEY.
         AGO   .CHKAEND  ALL DONE NOW EXIT FROM CHECKING THE A         *
                         PARAMETER.
.ASARG   ANOP
.CHKAEND ANOP
.**********************************************************************
.* THE ADDRESS OF THE SEARCH KEY IS IN REGISTER 0, NOW LINK TO THE    *
.* SEARCH SUBROUTINE IN IGARPT01 FOR TYPE 8 RADIX PARTITION TREES.    *
.**********************************************************************
.LINK    ANOP
         L     15,(&IGABLST+&IGASRCH)(,1)  ADDRESS OF SEARCH ROUTINE.
         BALR  14,15     LINK TO THE APPROPRIATE SEARCH ROUTINE.
.**********************************************************************
.* CHECK THE REL PARAMETER FOR ANY ADDITIONAL ACTIONS THAT MUST BE DONE
.**********************************************************************
         AIF   (K'&REL EQ 0).FIN0  SEE IF THE REL PARAMETER IS CODED.
         MNOTE 12,'NONCE ERROR, REL NOT YET AVAILABLE.'
         AGO   .FIN0     SKIP THE REST.
.**********************************************************************
.*   CHECK THE REL PARAMETER FOR A PARTIAL ORDER VALUE SEARCH.        *
.**********************************************************************
.ITSAPOV ANOP
         AIF   (('&REL(1)' EQ 'POV')AND('&REL(2)' EQ 'GE')).POVSRCH
         AIF   (('&REL(1)' EQ 'MAX')AND('&REL(2)' EQ 'POV')).MAXPOV
.BADREL  MNOTE 12,'INVALID REL PARAMETER.'
         AGO   .FIN0  GO TO THE END OF THE SRCH MACRO.
.MAXPOV  AIF   (K'&NULL EQ 0).LOADMAX  SEE IF THE NULL IS CODED.
         TM    &IGAEOPV.(1),B'1001'  SEE IF THE TREE IS EMPTY.
         AIF   ('&NULL'(1,1) EQ '(').MXPVGPR
         BC    8,&NULL  BRANCH IF THE TREE IS EMPTY.
         AGO   .LOADMAX
.MXPVGPR BCR   8,&NULL(1)  BRANCH IF THE RPT IS EMPTY.
.LOADMAX L     0,&IGAMAX.(,1)   LOAD THE MAXIMUM PARTIAL ORDER VALUE.
         L     15,(&IGABLST+&IGAPVS)(,1)  ADDRESS OF POV SEARCH.
         BALR  14,15     SET CURSOR TO SINK WITH MAX POV.
         AGO   .FIN0  GO TO THE END OF THE SEARCH.
.**********************************************************************
.* SEARCH FOR A PARTIAL ORDER VALUE THAT IS GREATER THAN OR EQUAL TO  *
.* THE SEARCH ARGUMENT, BUT AS SMALL A VALUE AS CAN EFFICIENTLY BE    *
.* FOUND.                                                             *
.**********************************************************************
.POVSRCH AIF   ((K'&A EQ 0)AND(K'&K NE 0)).PVS01
         AIF   ((K'&A NE 0)AND(K'&K EQ 0)).PVS10
         AIF   ((K'&A EQ 0)AND(K'&K EQ 0)).PVS00
         AIF   ('&A'(1,1) EQ '(').PVS11R
         L     0,&A(1)+&K(1)  LOAD PARTIAL ORDER SEARCH KEY.
.PVS11RR L     15,(&IGABLST+&IGAPVS)(,1)  ADDRESS OF POV SEARCH.
         BALR  14,15     LINK TO POV SEARCH ROUTINE.
.PVSTEST AIF   (K'&NULL EQ 0).PVNNULL  SEE IF THE NULL IS CODED.
&TMP     SETC  ''  SET IT TO THE EMPTY VECTOR.
         AIF   ('&NULL'(1,1) NE '(').PVSNGPR  AGO IF NULL NOT A GPR.
&TMP     SETC  'R'  SET IT TO GENERATE A BCR.
.PVSNGPR TM    &IGAEOPV.(1),B'1001'  SEE IF THE TREE IS EMPTY.
         BC&TMP 8,&NULL(1)  BRANCH IF IT IS EMPTY.
.PVNNULL AIF   ((K'&Y EQ 0)AND(K'&N EQ 0)).FIN0  SEE IF EITHER Y OR N.
         LTR   15,15  TEST THE RETURN CODE.
         AIF   (K'&Y EQ 0).PVNOY  SEE IF THE Y PARAMETER NOT CODED.
&TMP     SETC  ''  SET IT UP TO GENERATE A BC.
         AIF   ('&Y'(1,1) NE '(').PVYBC  GO IF A BC IS GENERATED.
&TMP     SETC  'R'  SET IT UP TO GENERATE A BCR.
.PVYBC   BC&TMP 10,&Y(1)  BRANCH IF THE SEARCH FOUND ONE.
.PVNOY   AIF   (K'&N EQ 0).FIN0  GO IF N IS NOT CODED.
&TMP     SETC  ''
         AIF   ('&N'(1,1) NE '(').PVNBC  GO IF IT'S NOT IN A GPR.
&TMP     SETC  'R'  GET SET TO GENERATE A BCR.
.PVNBC   AIF   (K'&Y NE 0).PVNBCC  GO IF THE LTR IS ALREADY THERE.
         LTR   15,15  TEST THE RETURN CODE.
.PVNBCC  BC&TMP 4,&N(1)  BRANCH IF THERE IS NO QUALIFYING VALUE.
         AGO   .FIN0  THE SRCH MACRO IS FINISHED.
.PVS11R  L     0,&K(1)(,&A(1))  LOAD THE PARTIAL ORDER SEARCH KEY.
         AGO   .PVS11RR  GO DO THE SEARCH.
.PVS00   MNOTE 12,'PARTIAL ORDER SEARCH KEY NOT SPECIFIED.'
         AGO   .FIN0  FORGET, CAN'T DO ANYTHING.
.PVS10   AIF   ('&A' EQ '((0))').PVS11RR SEE IF IT'S ALREADY LOADED.
&TMP     SETC  ''
         AIF   ('&A'(1,1) NE '(').PVS10M
&TMP     SETC  'R'
.PVS10M  L&TMP 0,&A(1)  LOAD THE PARTIAL ORDER SEARCH KEY.
         AGO   .PVS11RR  GO DO THE SEARCH.
.PVS01   ANOP
&TMP     SETC  'R'  PREPARE TO GENEATE A LOAD REGISTER INSTRUCTION.
         AIF   ('&K(1)'(1,1) EQ '(').PVS01R
&TMP     SETC  ''
.PVS01R  L&TMP 0,&K(1)  LOAD THE PARTIAL ORDER SEARCH KEY.
         AGO   .PVS11RR  GO DO THE SEARCH.
.**********************************************************************
.* PARTIAL ORDER VALUE SEARCH. IF A SEARCH KEY IS SPECIFIED SET THE   *
.* CURSOR USING THE SEARCH KEY. IN ORDER FOR THE SEARCH TO BE         *
.* SUCCESSFUL THERE MUST BE AN EXACT MATCH BETWEEN THE SEARCH KEY AND *
.* ONE ALREADY IN THE TREE.                                           *
.**********************************************************************
.POVGET  ANOP
         AIF   ((K'&A EQ 0)AND(K'&K EQ 0)).GETPOV
         SRCH  (1),A=&A,K=&K,T=&IGARPT#  SET THE CURSOR.
.GETPOV  L     15,(&IGABLST+&IGAGPV)(,1)  ADDRESS OF GET POV.
         BALR  14,15     LINK TO GET POV FOR CURRENT SINK.
         AGO   .PVSTEST   GO TEST FOR EXITING BRANCHES, ETC..
.*--------------------------------------------------------------------*
.FIN0    ANOP
         AIF   (NOT(&FIN)).SRCH8ZZ  SEE IF THE FIN&SYSNDX EQU * SHOULD *
                         BE GENERATED.
FIN&SYSNDX EQU *
.SRCH8ZZ ANOP
         AIF   (NOT &USING).FIN  SEE IF A USING FOR R1 HAS BEEN        *
                         GENERATED; IF SO GENERATE THE CORRESPONDING   *
                         DROP.
         AGO   .FIN      SKIP AROUND SRCH5.
.**********************************************************************
.*   R E A D     O N L Y     S E A R C H  ------- S R C H 5.          *
.**********************************************************************
.*       FOR SRCH5:                                                   *
.* 0. ABSOLUTE 3-BYTE EDGE FIELDS WITH SUCCESSOR PAIRING.             *
.* 1. BIT 0 OF EACH WORD IS A ZERO FOR SINK WORDS AND A ONE FOR INNER *
.*    VERTICES.                                                       *
.* 2. BITS 1-7 OF EACH INNER VERTEX ARE THE BIT INDEX, THUS ALLOWING  *
.*    A MAXIMUM KEY OF 16 BYTES.                                      *
.* 3. NO SCAN FUNCTIONS ARE AVAILABLE WITH SRCH5.                     *
.* 4. SRCH5 IS READ-ONLY, IN THE SENSE THAT IT DOES NOT STORE INTO    *
.*    ANY MEMORY LOCATIONS, BUT USES REGISTERS 0, 1, 2, 3, 14, AND 15 *
.*    AS WORKING REGISTERS.                                           *
.*    SRCH5 CHECKS A USE COUNT AFTER TERMINATION TO SEE IF AN INSERT  *
.*    OR DELETE CHANGE THE TREE DURING THE TIME THE SEARCH WAS IN     *
.*    PROGRESS. THIS IS TO ALLOW THE VALIDITY OF SEARCHES PROCEEDING  *
.*    WHILE AN INSERT OR DELETE IS IN PROGRESS IN AN MP SITUATION.    *
.*--------------------------------------------------------------------*
.SRCH5   ANOP
&GOLEFT  SETC  'LOOP'.'&SYSNDX'     GENERATE THE LABELS FOR THE
&ITSMOP  SETC  'MOP'.'&SYSNDX'   READ-ONLY SEARCH LOOP.
&ITSEOP  SETC  'EOP'.'&SYSNDX'   XX
&TOOBAD  SETC  'MORE'.'&SYSNDX'
&O       SETC  '0'   JUST A ZERO DISPLACEMENT.
&EKE     SETC  '4'   DISPLACEMENT TO THE USE COUNTER.
&FOUR    SETC  '4'    A CONSTANT DISPLACEMENT 4.
&ARG     SETC  '0'  REGISTER TO HOLD THE SEARCH ARGUMENT.
&TREEHDR SETC  '1'  USE REGISTER 1 FOR THE TREEHDR ADDRESS.
&P       SETC  '2'   USE REGISTER 2 FOR THE PREDECESSOR.
&C       SETC  '3'   USE REGISTER 3 FOR THE PENULTIMATE VERTEX.
&EKER    SETC  '14'  REGISTER TO HOLD THE COUNTER DURING THE
.*                   READ-ONLY SEARCH.
&S       SETC  '15'     USE REGISTER 15 TO HOLD THE SINK WORD.
&USING   SETB  (1)       SET THE BIT ON TO INDICATE THAT A USING HAS   *
                         BEEN GENERATED FOR R1.
.**********************************************************************
.* THE FOLLOWING TABLE SHOWS THE VARIOUS COMBINATIONS AND             *
.* INTERPRETATIONS OF THE OPERANDS FOR SRCH WITH TYPE 5 TREES:        *
.**********************************************************************
.* A:    A=LABEL OR A=(GPR) MAY BE CODED.                             *
.* K:    K=, K=FIELDNAME, K=(FIELDNAME,LENGTH), OR K=(D,L) MAY BE     *
.*       CODED. IF "K=FIELDNAME" OR "K=(FIELDNAME,LENGTH)" IS CODED,  *
.*       THEN THE A PARAMETER DOES NOT HAVE TO BE CODED. IF A IS ALSO *
.*       CODED AN MNOTE WILL BE GENERATED.                            *
.*       THE MAXIMUM SIZE KEY THAT CAN BE ACCOMODATED FOR TYPE 5 TREES*
.*       IS 16 BYTES. THERE CAN ONLY BE ONE (D,L) PAIR FOR TYPE 5     *
.*       TREES, UNLIKE TYPE 8 TREES, WHERE THERE CAN BE AN ARBITRARY  *
.*       NUMBER.                                                      *
.*--------------------------------------------------------------------*
.* CHECK FOR THE VARIOUS ALLOWABLE COMBINATIONS OF THE KEYL AND SARG. *
.*--------------------------------------------------------------------*
.**********************************************************************
.* THE FOLLOWING ARE THE ONLY WAYS TO CODE THE A AND K PARAMETERS FOR *
.* TYPE 5 RADIX PARTITION TREES:                                      *
.* F MEANS A FIELD NAME WITH A LENGTH ATTRIBUTE.                      *
.* L MEANS A LENGTH, WHICH MUST BE A SELF-DEFINING TERM.              *
.* D MEANS A DISPLACEMENT, WHICH MUST EITHER BE THE EMPTY STRING OR A *
.*   SELF-DEFINING TERM.                                              *
.* GPR IS A GENERAL REGISTER NAME OR NUMBER.                          *
.* X MEANS ANY STRING OF CHARACTERS.                                  *
.*                                                                    *
.* COMBINATION:          MEANING:                                     *
.* ------------          --------                                     *
.* A=F,K=                F IS A LABEL, AND THE LENGTH OF THE KEY IS   *
.*                       THE SAME AS THE LENGTH OF F.                 *
.* A=F,K=L               F IS THE SEARCH KEY, AND L IS THE SEARCH KEY *
.*                       LENGTH (IT MUST BE A SELF-DEFINING TERM).    *
.* A=F,K=(,L)            SAME AS ABOVE.                               *
.* A=F,K=(D,L)           THE SEARCH KEY IS AT DISPLACEMENT D FROM THE *
.*                       BEGINNING OF THE FIELD F, AND IS L BYTES LONG.
.* A=(GPR),K=L           THE ADDRESS OF THE FIRST BYTE OF THE SEARCH  *
.*                       KEY IS IN THE INDICATED REGISTER, AND THE KEY*
.*                       IS L BYTES LONG.                             *
.* A=(GPR),K=(,L)        SAME AS ABOVE.                               *
.* A=(GPR),K=(D,L)       THE ADDRESS OF THE KEY IS FORMED BY ADDING   *
.*                       THE ADDRESS IN THE INDICATED REGISTER TO THE *
.*                       DISPLACEMENT D, AND THE KEY IS L BYTES LONG. *
.* A=,K=F                F IS THE SEARCH KEY, AND ITS LENGTH IS THE   *
.*                       SAME AS THE LENGTH OF F.                     *
.* A=,K=(F,L)            F IS THE SEARCH KEY, AND L IS ITS LENGTH.    *
.**********************************************************************
.*--------------------------------------------------------------------*
.**********************************************************************
.* IN THE FOLLOWING, THE SEARCH IS DONE FOR KEYS WITH 4 BYTES OR LESS.*
.* THE KEY IS PLACED IN REGISTER 0 JUST BEFORE THE MAIN SEARCH LOOP.  *
.* THE KEY IS RIGHT ALIGNED IN REGISTER ZERO, WITH ZEROS FILLED IN ON *
.* THE LEFT.                                                          *
.**********************************************************************
         AIF   (&ERROR).FIN5  SEE IF ANY ERRORS HAVE BEEN DISCOVERED   *
                         PRIOR TO THIS PART.
         AIF   ((K'&A EQ 0)AND(K'&K EQ 0)).FIN5  SEE IF NEITHER A NOR K*
                         IS CODED.
         AIF   (K'&K NE 0).S5KNOTZ  SEE IF K IS CODED.
.**********************************************************************
.* ONLY THE A PARAMETER IS CODED, SO IT MUST BE A FIELD NAME WITH A   *
.* LENGTH ATTRIBUTE IN ORDER TO BE VALID.                             *
.**********************************************************************
         AIF   (K'&A LE 4).NOTPP  SEE IF THE A PARAMETER IS CODED AS   *
                         "A=((GPR))". IF IT IS, THEN THE SEARCH KEY IS *
                         ALREADY LOADED INTO THE INDICATED REGISTER.
         AIF   ('&A'(1,2) NE '((').NOTPP  IF IT IS IN A REGISTER, THEN *
                         IT MUST BE RIGHT ALIGNED, WITH THE LEFT FILL  *
                         BITS BEING ZERO.
         AIF   ('&A' EQ '((0))').SRCH5Z  SEE IF IT IS EVEN ALREADY IN  *
                         REGISTER 0.
         LR    0,&A(1)   SEARCH KEY.
         AGO   .SRCH5Z   GOT THE SEARCH KEY IN REGISTER 0, NOW GO      *
                         GENERATE THE SEARCH.
.NOTPP   ANOP
         AIF   ('&A'(1,1) EQ '(').AGRNOK  SEE IF THE A PARAMETER IS    *
                         INCORRECTLY SPECIFIED IN A REGISTER.
         AIF   ((T'&A EQ 'M')OR(T'&A EQ 'N')OR(T'&A EQ 'O')OR (T'&A EQ *
               'T')OR(T'&A EQ 'W')OR(T'&A EQ '$')OR(T'&A EQ 'U')).ANOTF*
                         SEE IF A IS NOT A FIELD NAME.
&IGAKEYL SETA  (L'&A)    GET THE SEARCH KEY LENGTH.
         AIF   (K'&A GT 8).ATOOBIG SEE IF THE FIELD NAME IS BIGGER     *
                         THAN 8 CHARACTERS.
&FIELD   SETC  '&A'      GET THE FIELD NAME.
.S5LCHK  AIF   (&IGAKEYL GT 4).AFLGT4  SEE IF THE KEY LENGTH IS MORE   *
                         THAN FOUR BYTES.
         AIF   (&IGAKEYL GE 3).AFL34  SEE IF THE KEY LENGTH IS BIGGER  *
                         THAN TWO BYTES.
         AIF   (&IGAKEYL EQ 2).AFL2  SEE IF THE KEY LENGTH IS EXACTLY  *
                         TWO BYTES.
         AIF   (&IGAKEYL NE 1).NULLKEY  SEE IF THE KEY LENGTH IS ZERO.
.AFL1    SLR   0,0       THE SEARCH KEY
         IC    0,&FIELD  IS ONE BYTE LONG.
         AGO   .SRCH5Z   NOW GO GENERATE THE SRCH5 IN LINE.
.AFL2    LH    0,&FIELD  SEARCH KEY IS
         N     0,=XL4'0000FFFF'  TWO BYTES LONG.
         AGO   .SRCH5Z   NOW GO GENERATE THE SEARCH IN LINE.
.AFL3    L     00,&FIELD  3-BYTE SEARCH KEY.
         SRL   0,8  GET IT RIGHT ALIGNED.
         AGO   .SRCH5Z   GO GENERATE THE SEARCH LOOP.
.AFL34   AIF   (&IGAKEYL EQ 3).AFL3  SEE IF THE SEARCH KEY LENGTH IS   *
                         EXACTLY THREE BYTES.
         L     0,&FIELD  4-BYTE SEARCH KEY.
         AGO   .SRCH5Z   GO FINISH UP NOW.
.AFLGT4  AGO   .S5NONCE  CAN'T HAVE TYPE 5 KEYS BIGGER THAN 5 YET.
.**********************************************************************
.* THE K PARAMETER IS CODED, SEE IF THE A PARAMETER IS CODED TOO.     *
.**********************************************************************
.S5KNOTZ ANOP
         AIF   (K'&A NE 0).S5BOTH  SEE IF BOTH THE A AND K PARAMETERS  *
                         ARE CODED.
.**********************************************************************
.* ONLY THE K PARAMETER IS CODED. IT MUST BE ONE OF THE CASES K=F OR  *
.* K=(F,L). ANYTHING ELSE MUST BE WRONG.                              *
.**********************************************************************
         AIF   (N'&K GT 2).LOTSAK  SEE IF THERE ARE TOO MANY OPERANDS.
         AIF   (N'&K EQ 2).S5K2  SEE IF THERE ARE EXACTLY 2.
         AIF   ('&K'(1,1) EQ '(').S5K1P  SEE IF IT LOOKS LIKE A GPR.
         AIF   ((T'&K(1) EQ 'M')OR(T'&K(1) EQ 'N')OR(T'&K(1) EQ 'O')OR(*
               T'&K(1) EQ 'T')OR(T'&K(1) EQ 'W')OR(T'&K(1) EQ '$')OR(T'*
               &K(1) EQ 'U')).KINVF  SEE IF K IS A GOOD FIELD NAME.
         AIF   (K'&K GT 8).KBIGTAG  SEE IF THE FIELD NAME HAS TOO MANY *
                         CHARACTERS IN IT TO BE A VALID NAME.
&FIELD   SETC  '&K'      SET FIELD TO THE FIELD NAME.
         AGO   .S5LCHK   MERGE IN WITH THE OTHER LENGTH CHECK.
.**********************************************************************
.* THE K PARAMETER IS CODED AND THE A PARAMETER IS NOT CODED, AND THE *
.* K PARAMETER HAS EXACTLY TWO ELEMENTS IN IT. SEE IF K IS OF THE FORM*
.* (F,L). IF IT ISN'T IT IS AN ERROR.                                 *
.**********************************************************************
.S5K2    ANOP
         AIF   (T'&K(2) EQ 'N').S5K2N  SEE IF THE LENGTH IS A SELF-    *
                         DEFINING TERM.
&I       SETA  (K'&K(2))  SET THE INDEX TO IT'S INITIAL VALUE.
.K5LCHK  AIF   (('&K(2)'(&I,1) LT '0')OR('&K(2)'(&I,1) GT '9')).S5LERR
&I       SETA  (&I-1)    DECREASE THE INDEX TO THE NEXT CHARACTER.
         AIF   (&I GT 0).K5LCHK  SEE IF THERE ARE MORE TO CHECK.
         AIF   (K'&K(2) GT 4).S5LERR  SEE IF IT HAS TOO MANY DIGITS.
.S5K2N   ANOP
&IGAKEYL SETA  (&K(2))   GET THE LENGTH AS A NUMBER.
         AIF   (K'&K(1) GT 8).KBIGTAG  SEE IF IT HAS TOO MANY          *
                         CHARACTERS IN IT TO BE A VALID NAME.
&FIELD   SETC  '&K(1)'   GET THE FIELD NAME.
         AGO   .S5LCHK   MERGE IN WITH THE OTHER SEQUENCE.
.**********************************************************************
.* BOTH THE A AND K PARAMETERS ARE CODED.                             *
.**********************************************************************
.S5BOTH  ANOP
         AIF   ('&A'(1,1) EQ '(').S5BAISG  SEE IF THE A PARAMETER      *
                         SPECIFIES A GENERAL REGISTER.
         AIF   (N'&K GT 2).LOTSAK  SEE IF THERE ARE TOO MANY.
         AIF   (N'&K EQ 2).S5AK2  SEE IF THERE ARE EXACTLY 2.
         AIF   ('&K'(1,1) EQ '(').S5K1P  SEE IF IT LOOKS LIKE THE      *
                         DISPLACEMENT-LENGTH PAIR IS IN A GPR.
.**********************************************************************
.* THIS MUST BE THE CASE WHERE A=F,K=L.                               *
.**********************************************************************
         AIF   (T'&K EQ 'N').AFKL5OK  SEE IF THE LENGTH IS A           *
                         SELF-DEFINING TERM.
&I       SETA  (1)       SET THE INDEX TO ITS INITIAL VALUE.
.AFKL5CK AIF   (('&K'(&I,1) LE '0')OR('&K'(&I,1) GT '9')).S5LERR       *
                         CHECK THE LENGTH TO SEE IF IT IS REALLY A     *
                         NUMBER.
&I       SETA  (&I+1)    EKE THE INDEX OF THE NEXT CHARACTER TO BE     *
                         INSPECTED.
         AIF   (&I LT K'&K).AFKL5CK  KEEP ON LOOKING UNTIL ALL THE     *
                         CHARACTERS HAVE BEEN INSPECTED.
.AFKL5OK ANOP
&IGAKEYL SETA  (&K)      CAPTURE THE KEY LENGTH AS A NUMBER.
         AIF   (&IGAKEYL EQ 1).AFKL51  SEE IF THE KEY LENGTH IS ONE    *
                         BYTE.
         AIF   (&IGAKEYL EQ 2).AFKL52  SEE IF THE KEY LENGTH IS TWO    *
                         BYTES.
         AIF   (&IGAKEYL EQ 3).AFKL53  SEE IF THE KEY LENGTH IS 3      *
                         BYTES.
         AIF   (&IGAKEYL NE 4).S5NONCE  SEE IF THE KEY LENGTH IS FOUR  *
                         BYTES.
         L     0,&A                     SEARCH ARGUMENT.
         AGO   .SRCH5Z   GO DO THE ACTUAL SEARCH.
.AFKL51  SLR   0,0     KEY LENGTH IS ONE BYTE.
         IC    0,&A                 1-BYTE SEARCH KEY.
         AGO   .SRCH5Z   GO GENERATE THE ACTUAL SEARCH CODE.
.AFKL52  LH    0,&A              HALFWORD SEARCH KEY.
         AGO   .SRCH5Z   GO GENERATE THE SEARCH CODE.
.AFKL53  L     0,&A                  LOAD 3-BYTE SEARCH KEY.
         SRL   0,8       SHIFT IT OVER.
         AGO   .SRCH5Z   GO GENERATE THE REAL SEARCH.
.AFKL54  L     0,&A                   LOAD FULL-WORD SEARCH KEY.
         AGO   .SRCH5Z   GO GENERATE THE REAL SEARCH CODE.
.**********************************************************************
.* THIS MUST BE THE CASE WHERE A=F,K=(D,L).                           *
.**********************************************************************
.S5AK2   AIF   (T'&K(2) EQ 'N').S5K2N1 SEE IF THE LENGTH IS A SELF-    *
               DEFINING TERM.
         AIF   (K'&K(2) EQ 0).S5LERR  SEE IF IT IS THE EMPTY STRING.
&I       SETA  (K'&K(2))  SET THE INDEX TO IT'S INITIAL VALUE.
.K5LCHK1 AIF   (('&K(2)'(&I,1) LT '0')OR('&K(2)'(&I,1) GT '9')).S5LERR
&I       SETA  (&I-1)    DECREASE THE INDEX TO THE NEXT CHARACTER.
         AIF   (&I GT 0).K5LCHK1 SEE IF THERE ARE MORE TO CHECK.
         AIF   (K'&K(2) GT 4).S5LERR  SEE IF IT HAS TOO MANY DIGITS.
.S5K2N1  ANOP
&IGAKEYL SETA  (&K(2))   GET THE KEY LENGTH AS A NUMBER.
&DSP     SETA  0         SET THE DISPLACEMENT TO ITS DEFAULT VALUE.
         AIF   (K'&K(1) EQ 0).S5AK2D  SEE IF THE DISPLACEMENT FIELD IS *
                         ELIDED.
         AIF   ('&K(1)' EQ '0').S5AK2D  SEE IF IT IS ZERO.
         AIF   (T'&K(1) EQ 'N').PICK5D  SEE IF THE DISPLACEMENT IS A   *
                         SELF-DEFINING TERM.
&I       SETA  (K'&K(1))  SET THE INDEX TO IT'S INITIAL VALUE.
.CHECK5D AIF   (('&K(1)'(&I,1) LT '0')OR('&K(1)'(&I,1) GT '9')).S5DERR
&I       SETA  (&I-1)    DECREASE THE INDEX TO THE NEXT CHARACTER.
         AIF   (&I GT 0).CHECK5D  SEE IF IT GOT TO THE END.
         AIF   (K'&K(1) GT 4).S5DLONG  SEE IF IT HAS TOO MANY DIGITS.
.PICK5D  ANOP
&DSP     SETA  (&K(1))   GET THE DISPLACEMENT AS A NUMBER.
.S5AK2D  ANOP
.S5DLCHK ANOP
         AIF   (&IGAKEYL GT 4).S5DL5  SEE IF THE KEY LENGTH IS MORE    *
                         THAN 4 BYTES.
         AIF   (&IGAKEYL EQ 4).S5DL4  SEE IF THE KEY LENGTH IS 4 BYTES.
         AIF   (&IGAKEYL EQ 3).S5DL3  SEE IF THE KEY LENGTH IS 3 BYTES.
         AIF   (&IGAKEYL EQ 2).S5DL2  SEE IF THE KEY LENGTH IS 2 BYTES.
         AIF   (&IGAKEYL NE 1).NULLKEY  SEE IF THE KEY LENGTH IS ZERO.
.S5DL1   SLR   0,0       SEARCH KEY IS
         AIF   (&DSP EQ 0).S5DL1Z  SEE IF THE DISPLACEMENT IS ZERO.
         IC    0,&A                    ONE BYTE LONG.
         AGO   .S5DL1ZZ  SKIP AROUND THE OTHER INSERT CHARACTER        *
                         INSTRUCTION.
.S5DL1Z  IC    0,&DSP+&A        ONE BYTE LONG.
.S5DL1ZZ ANOP
         AGO   .SRCH5Z   GO DO THE IN LINE SEARCH.
.S5DL2   AIF   (&DSP EQ 0).S5DL2Z  SEE IF THE DISPLACEMENT IS ZERO.
         LH    0,&DSP+&A          HALFWORD
         AGO   .S5DL2ZZ  SKIP AROUND THE OTHER LOAD HALFWORD           *
                         INSTRUCTION.
.S5DL2Z  LH    0,&A           HALFWORD
.S5DL2ZZ ANOP
         N     0,=XL4'0000FFFF'  SEARCH KEY.
         AGO   .SRCH5Z   GO WRAP IT UP.
.S5DL3   AIF   (&DSP EQ 0).S5DL3Z  SEE IF THE DISPLACEMENT IS ZERO.
         L     0,&DSP+&A           THREE-BYTE SEARCH KEY.
         AGO   .S5DL3ZZ  SKIP THE OTHER LOAD INSTRUCTION.
.S5DL3Z  L     0,&A                 THREE-BYTE SEARCH KEY.
.S5DL3ZZ ANOP
         SRL   0,8       GET IT RIGHT ALIGNED.
         AGO   .SRCH5Z   GO DO THE IN-LINE SEARCH.
.S5DL4   AIF   (&DSP EQ 0).S5DL4Z  SEE IF THE DISPLACEMENT IS ZERO.
         L     0,&DSP+&A           4-BYTE KEY.
         AGO   .S5DL4ZZ  SKIP THE OTHER LOAD INSTRUCTION.
.S5DL4Z  L     0 &A                  4-BYTE KEY.
.S5DL4ZZ ANOP
         AGO   .SRCH5Z   GO FINISH IT UP.
.S5DL5   AGO   .S5NONCE  THIS IS ONLY FOR THE NONCE.
.**********************************************************************
.* BOTH THE A AND K PARAMETERS ARE CODED, AND A SPECIFIES A GPR.      *
.* THEREFORE IT MUST BE THE CASE WHERE A=(GPR),K=(D,L). NOTE THAT THE *
.* DISPLACEMENT CAN BE THE EMPTY STRING.                              *
.* ALSO THE CASE OF A=(GPR),K=L GOES ALONG WITH THESE.                *
.**********************************************************************
.S5BAISG ANOP
         AIF   (N'&K GT 2).LOTSAK  SEE IF K HAS TOO MANY OPERANDS.
         AIF   (N'&K EQ 2).S5AGK2  SEE IF K HAS EXACTLY 2 OPERANDS.
         AIF   ('&K'(1,1) EQ '(').S5K1P  SEE IF IT LOOKS LIKE A GPR.
         AIF   (T'&K NE 'N').S5LERR  SEE IF IT'S A SELF-DEFINING TERM.
.**********************************************************************
.* IT IS A=(GPR),K=L.                                                 *
.**********************************************************************
&IGAKEYL SETA  (&K)      GET THE KEY LENGTH AS A NUMBER.
&DSP     SETA  0         SET THE DISPLACEMENT TO ITS DEFAULT VALUE.
.S5GLCHK AIF   (&IGAKEYL GT 4).S5GL5  SEE IF THE KEY LENGTH EXCEEDS 4.
         AIF   (&IGAKEYL EQ 4).S5GL4  SEE IF IT IS EXACTLY 4 BYTES.
         AIF   (&IGAKEYL EQ 3).S5GL3  SEE IF IT IS EXACTLY 3 BYTES.
         AIF   (&IGAKEYL EQ 2).S5GL2  SEE IF IT IS EXACTLY 2 BYTES.
         AIF   (&IGAKEYL NE 1).S5LERR  SEE IF IT IS ZERO.
.S5GL1   SLR   0,0       1-BYTE KEY.
         IC    0,&DSP&A
         AGO   .SRCH5Z   GO FINISH UP.
.S5GL2   LH    0,&DSP&A  2-BYTE KEY.
         N     0,=XL4'0000FFFF'
         AGO   .SRCH5Z
.S5GL3   L     0,&DSP&A  3-BYTE KEY.
         SRL   0,8
         AGO   .SRCH5Z
.S5GL4   L     0,&DSP&A  4-BYTE KEY.
         AGO   .SRCH5Z   GO FINISH IT UP.
.S5GL5   AGO   .S5NONCE
.**********************************************************************
.* IT IS A=(GPR),K=(D,L).                                             *
.**********************************************************************
.S5AGK2  ANOP
         AIF   (T'&K(2) NE 'N').S5LERR   SEE IF IT'S NOT SELF-DEFINING.
&DSP     SETA  0         SET D TO THE DEFAULT VALUE.
&IGAKEYL SETA  (&K(2))   GET THE KEY LENGTH AS A NUMBER.
         AIF   (K'&K(1) EQ 0).S5GLCHK  SEE IF THE DISPLACEMENT IS THE  *
                         EMPTY STRING.
         AIF   (T'&K(1) NE 'N').S5DERR   SEE IF IT'S NOT SELF-DEFINING.
&DSP     SETA  (&K(1))   GET THE DISPLACEMENT AS A NUMBER.
         AGO   .S5GLCHK  MERGE WITH THE COMMON PATH.
.SRCH5Z  AIF   (&ERROR).FIN5  DON'T GENERATE THE SEARCH IF ERRORS HAVE *
                         BEEN DETECTED ALREADY.
&TOOBAD  L     &EKER,&IGACNT5.(,&TREEHDR)  LOAD THE USE COUNTER.
         LA    &P,&IGATOP5.(,&TREEHDR)  ADDRESS OF RPT SOURCE.
         LR    &C,&P     XX
         L     &S,&O.(&O,&C)
         CL    &S,&IGAMSK5.(,&TREEHDR)  SEE IF THERE ARE ZERO SINKS.
         BC    7,&GOLEFT+4
         BC    15,&ITSEOP
&GOLEFT L     &S,&O.(&O,&C)   LOAD THE SINK WORD OR THE NEXT INNER
         LTR   &S,&S          VERTEX AND TEST FOR THE END OF THE PATH.
         BC    10,&ITSEOP     BRANCH IF THE SINK WORD WAS LOADED.
&ITSMOP LR    &P,&C           CYCLE THE REGISTERS SO THAT THESE TWO
         LR    &C,&S          ARE ALWAYS CONSECUTIVE VERTICES.
         SRL   &S,24          GET THE BIT INDEX FIELD IN THE LOW ORDER.
         L     &S,(&IGAMSK5-X'80')(&TREEHDR,&S)  LOAD MASK TO TEST BIT.
         NR    &S,&ARG          TEST THE BIT.
         BC    8,&GOLEFT    BRANCH IF IT IS A ZERO TO THE LEFT PATH.
         L     &S,&FOUR.(&O,&C)  ENTER THE RIGHT SUBTREE BY LOADING
         LA    &C,&FOUR.(&O,&C)  THE PAIRED RIGHT SUCCESSOR AND
         LTR   &S,&S   MAKE THE CURRENT VERTEX ADDRESS IT.
         BC    4,&ITSMOP   BRANCH IF THE NEW VERTEX IS AN INNER VERTEX.
&ITSEOP  CL    &EKER,&IGACNT5.(,&TREEHDR)  CHECK THE COUNTER TO SEE IF
         BC    7,&TOOBAD   THE READ-ONLY SEARCH MUST BE DONE AGAIN.
         AGO   .FIN5
.AGRNOK  MNOTE 12,'SEARCH KEY LENGTH CANNOT BE DETERMINED WITH A IN A  *
               GPR AND NO K.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .FIN5     FINISH UP AND GET OUT.
.ANOTF   MNOTE 12,'THE FIELD DEFINED BY A HAS NOT A VALID LENGTH ATTRIB*
               UTE.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .FIN5     GET OUT NOW.
.ATOOBIG MNOTE 12,'FIELD NAME IN A PARAMETER IS TOO MANY CHARACTERS.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .FIN5     EXIT.
.NULLKEY MNOTE 12,'LENGTH OF SEARCH KEY DEFINED IS ZERO.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .FIN5     EXIT AFTER CLEANING UP.
.S5NONCE MNOTE 12,'NONCE ERROR, ONLY KEYS UP TO 4 BYTES ARE SUPPORTED.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .FIN5     FORGET IT FOR THE NONCE.
.LOTSAK  MNOTE 12,'TOO MANY OPERANDS IN THE K PARAMETER LIST.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .FIN5
.S5K1P   MNOTE 12,'THE DISPLACEMENT-LENGTH PAIR MAY NOT BE IN A GPR.'
&ERROR   SETB  (1)
         AGO   .FIN5
.KINVF   MNOTE 12,'FIELD IN K PARAMETER HAS INVALID LENGTH ATTRIBUTE.'
&ERROR   SETB  (1)
         AGO   .FIN5
.KBIGTAG MNOTE 12,'TOO MANY CHARACTERS IN FIELD NAME; ONLY 8 ALLOWED.'
&ERROR   SETB  (1)
         AGO   .FIN5
.S5LERR  MNOTE 12,'LENGTH IS NOT A SELF-DEFINING TERM IN K PARAMETER.'
&ERROR   SETB  (1)
         AGO   .FIN5
.S5DERR  MNOTE 12,'THE DISPLACEMENT IN THE K PARAMETER IS NOT A SELF-DE*
               FINING TERM.'
&ERROR   SETB  (1)
         AGO   .FIN5
.S5DLONG MNOTE 12,'K PARAMETER DISPLACEMENT HAS TOO MANY DIGITS.'
&ERROR   SETB  (1)
.FIN5    ANOP
         AIF   (NOT &USING).FIN  SEE IF THE DROP SHOULD BE GENERATED.
.*--------------------------------------------------------------------*
.*      T H E    E N D    O F    M A C R O    S R C H.                *
.*--------------------------------------------------------------------*
.FIN     ANOP
.END     ANOP
         MEND
         EJECT
         MACRO
&TAG     STREE &TREE,&TSP=,&T=,&TYPE=,&FIX=NO,&K=,&IVS=,&S=,&MAP=,&C=, *
               &TSPACE=,&RSPACE=,&RSP=,&KEYL=,&OFFSET=,&RECL=
.**********************************************************************
.* THE STREE MACRO-INSTRUCTION IS USED TO CREATE A RADIX PARTITION    *
.* TREE FOR SUBSEQUENT USE. THE STREE SUBROUTINE IN THE MODULE        *
.* IGARPT01 OBTAINS SPACE FOR THE RPT, AND STORES THE INFORMATION     *
.* SUPPLIED IN A CONTROL BLOCK FOR THE RPT. THE ADDRESS OF THIS       *
.* CONTROL BLOCK IS RETURNED IN REGISTER 1, AND IS (OPTIONALLY) STORED*
.* IN THE MAIN STORAGE LOCATION SPECIFIED BY THE TREE PARAMETER.      *
.*                                                                    *
.* THE ADDRESS RETURNED BY THE STREE MACRO-INSTRUCTION MUST BE USED   *
.* FOR ALL SUBSEQUENT OPERATIONS WITH IT USING THE OTHER RPT          *
.* MACRO-INSTRUCTIONS, SUCH AS SRCH, DEL, INS, SCANL, SCANR, FTREE,   *
.* ETC. THE ADDRESS CAN BE STORED EITHER IN A MAIN STORAGE LOCATION   *
.* VIA THE TREE PARAMETER, OR MAY BE PUT IN A REGISTER BY CODING      *
.* "(GPR)" FOR THE TREE PARAMETER, WHERE "GPR" IS THE REGISTER NAME OR*
.* NUMBER.                                                            *
.*                                                                    *
.* THE SPACE FOR THE RPT CAN BE OBTAINED VIA THE GSPACE               *
.* MACRO-INSTRUCTION USING A PREVIOUSLY ESTABLISHED SPACE CONTROL     *
.* AREA, OR MAY BE OBTAINED IMPLICITLY VIA THE GSPACE                 *
.* MACRO-INSTRUCTION USING THE APPROPRIATE SPACE CONTROL AREA FROM THE*
.* TCB (SEE THE DESCRIPTION OF THE GSPACE MACRO-INSTRUCTION FOR THE   *
.* USE OF SPACE CONTROL AREAS).                                       *
.*                                                                    *
.* THERE ARE DIFFERENT TYPES OF RADIX PARTITION TREES, WHICH ARE      *
.* DIFFERENTIATED FROM ONE ANOTHER BY CODING THE T PARAMETER ON ALL   *
.* THE MACRO-INSTRUCTIONS THAT DEAL WITH RPTS. THERE ARE LIMITATIONS  *
.* ON THE OPERATIONS THAT MAY BE INVOKED WITH THE DIFFERENT RPT TYPES,*
.* DEPENDING ON THE RPT TYPE.                                         *
.*                                                                    *
.* THE ALLOCATION OF SPACE, AS DESCRIBED ABOVE, APPLIES TO TYPE 8     *
.* RADIX PARTITION TREES. THE GSPACE MACRO-INSTRUCTION IS ALWAYS USED *
.* TO ALLOCATE THE SPACE FOR A TYPE 8 RPT.                            *
.* THE SPACE FOR THE RPT CAN BE OBTAINED EITHER CONDITIONALLY OR      *
.* UNCONDITIONALLY, DEPENDING ON THE C PARAMETER. IF "C=C" IS CODED,  *
.* THEN THE ALLOCATION IS VIA A CONDITIONAL GSPACE OPERATION, WHICH   *
.* HAS A RETURN CODE FOR THE STREE MACRO-INSTRUCTION OF -1 IF THE     *
.* SPACE COULD NOT BE ALLOCATED, OR HAS A RETURN CODE IN REGISTER 15  *
.* WHICH IS THE ADDRESS OF THE RPT'S CONTROL BLOCK (CALLED THE TREE   *
.* HEADER, OR THE ADDRESS OF THE RPT).                                *
.* FOR TYPE 5 RADIX PARTITION TREE, THE SPACE IS ALWAYS OBTAINED VIA  *
.* THE GETMAIN MACRO-INSTRUCTION, AND A CONDITIONAL GETMAIN IS ALWAYS *
.* USED, UNLESS THE C PARAMETER IS CODED "C=U".                       *
.*                                                                    *
.**********************************************************************
.* WITH TYPE 8 RADIX PARTITION TREES, THE FOLLOWING OPERATIONS ARE    *
.* EFFECTIVE:                                                         *
.*                                                                    *
.* SRCH: SEARCH FOR A GIVEN KEY.                                      *
.* INS:  INSERT A NEW KEY-ADDRESS ASSOCIATION PAIR.                   *
.* DEL:  DELETE A KEY-ADDRESS ASSOCIATION PAIR SELECTED BY THE CURRENT*
.*       SETTING OF THE CURSOR (SEE THE DESCRIPTION OF THE CURSOR     *
.*       UNDER THE ISCAN MACRO-INSTRUCTION DESCRIPTION).              *
.* ISCAN:INITIALIZE THE CURSOR FOR SUBSEQUENT SCANNING OPERATIONS.    *
.* SCANL:SCAN LEFT TO THE NEXT KEY IN DESCENDING ORDER.               *
.* SCANR:SCAN RIGHT TO THE NEXT KEY IN ASCENDING ORDER.               *
.* FTREE:RELEASE ALL THE SPACE FOR THE RPT TO THE SYSTEM VIA THE      *
.*       FSPACE MACRO-INSTRUCTION.                                    *
.*                                                                    *
.* THE MAXIMUM KEY LENGTH THAT CAN BE SUPPORTED WITH TYPE 8 RADIX     *
.* PARTITION TREES IS 256 BYTES.                                      *
.**********************************************************************
.*                                                                    *
.* WITH TYPE 5 RADIX PARTITION TREES, THE FOLLOWING OPERATIONS ARE    *
.* VALID:                                                             *
.*                                                                    *
.* SRCH: SEARCH FOR A GIVEN KEY AND SET THE CURSOR TO THE             *
.*       CORRESPONDING KEY-ADDRESS PAIR.                              *
.* INS:  INSERT A NEW KEY-ADDRESS PAIR.                               *
.* DEL:  DELETE A KEY-ADDRESS PAIR BASED ON THE CURRENT SETTING OF THE*
.*       CURSOR.                                                      *
.* FTREE:FREE THE SPACE FOR THE TREE BY RELEASING IT TO THE SYSTEM VIA*
.*       THE FREEMAIN MACRO-INSTRUCTION.                              *
.*       NO OTHER OPERATIONS ARE VALID FOR TYPE 5 TREES.              *
.*                                                                    *
.*       THE MAXIMUM SIZE KEY PERMITTED WITH TYPE 5 TREES IS 16 BYTES.*
.*       THE KEY MUST ALWAYS BE PRESENTED AS A SINGLE FIELD FOR THE   *
.*       SRCH AND INS MACRO-INSTRUCTIONS, UNLIKE TYPE 8 TREES, WHERE  *
.*       THE KEY IS PERMITTED TO BE COMPOSED OF A NUMBER OF SCATTERED *
.*       FIELDS.                                                      *
.*                                                                    *
.* THE MAIN REASON FOR HAVING TYPE 5 RADIX PARTITION TREES IS TO ALLOW*
.* SEARCHES TO PROCEED IN A MULTIPROCESSING SITUATION SIMULTANEOUSLY  *
.* WITH AN INSERT OR DELETE IN PROGRESS. THIS IS ACCOMPLISHED WITHOUT *
.* NEEDING TO LOCK THE RPT HEADER.                                    *
.**********************************************************************
.* THE MEANING AND USE OF THE VARIOUS PARAMETERS FOR THE STREE        *
.* MACRO-INSTRUCTION ARE AS FOLLOWS:                                  *
.*                                                                    *
.* TREE: THIS PARAMETER SPECIFIES WHERE TO PUT THE ADDRESS OF THE     *
.*       RADIX PARTITION TREE AFTER IT HAS BEEN ESTABLISHED. IT MAY   *
.*       SPECIFY EITHER A MAIN STORAGE LOCATION OR A GENERAL REGISTER.*
.*                                                                    *
.* TSP:  THIS PARAMETER SPECIFIES THE SUBPOOL TO BE USED FOR          *
.*       ALLOCATING SPACE FOR THR RPT, BOTH INITIALLY AND LATER WHEN  *
.*       SPACE IS NEEDED FOR INSERTIONS.                              *
.*                                                                    *
.* T:    THIS SPECIFIES THE RPT TYPE. IT MAY BE 5 OR 8. IF IT IS      *
.*       ELIDED, THE RPT TYPE IS 8.                                   *
.*                                                                    *
.* FIX:  THIS PARAMETER SPECIFIES WHETHER A PGFIX OPERATION MUST BE   *
.*       PERFORMED ON THE PAGES CONTAINING THE IGARPT01 MODULE. IF    *
.*       "FIX=YES" IS CODED, THEN THE PGFIX OPERATION IS GENERATED AS *
.*       PART OF THE STREE MACRO EXPANSION.                           *
.*                                                                    *
.* K:    THIS SPECIFIES THE DISPLACEMENT AND LENGTH OF THE KEY, AS A  *
.*       DISPLACEMENT-LENGTH PAIR. IT IS CODED AS "K=(D,L)", WHERE D  *
.*       IS THE DISPLACEMENT FROM THE START OF ANY ADDRESS ASSOCIATED *
.*       WITH A KEY AND THE FIRST BYTE OF THE KEY. THE DISPLACEMENT   *
.*       MAY NOT EXCEED 4095 BYTES.                                   *
.*       L IS THE LENGTH OF THE KEYS, IN BYTES. IF VARIABLE LENGTH    *
.*       KEYS ARE USED, THEY ARE TREATED AS IF THEY ARE ALL THE SAME  *
.*       LENGTH, I. E. L BYTES LONG. AS LONG AS THE SET OF KEYS DO NOT*
.*       CONTAIN TWO BYTE STRINGS SUCH THAT ONE IS A PROPER SUBSTRING *
.*       OF THE OTHER ONE, THIS WILL NOT CAUSE A PROBLEM, SINCE THE   *
.*       COMPARISONS DO NOT EXTEND PAST THE POINT OF INEQUALITY OF ANY*
.*       TWO KEYS.                                                    *
.*                                                                    *
.* S:    THIS SPECIFIES THE ADDRESS OF THE SPACE CONTROL AREA IF A    *
.*       SPACE CONTROL AREA IS EXPLICITLY USED TO ALLOCATE AND RELEASE*
.*       THE STORAGE FOR THE RPT. THE SPACE CONTROL ADDRESS IS THE    *
.*       WORD THAT IS RETURNED FROM THE GSPACE MACRO-INSTRUCTION WHEN *
.*       "GSPACE S,..ETC. " IS CODED. SEE THE DESCRIPTION OF THE      *
.*       GSPACE MACRO-INSTRUCTION FOR A MORE COMPLETE DISCUSSION OF   *
.*       THE USE OF THE SPACE CONTROL WORD.                           *
.*                                                                    *
.* C:    THIS IS USED TO SPECIFY A CONDITIONAL OR UNCONDITIONAL       *
.*       ATTEMPT TO ALLOCATE THE SPACE FOR THE RPT INITIALLY. IF "C=C"*
.*       IS CODED, THE REQUEST IS A CONDITIONAL REQUEST. IF "C=U" IS  *
.*       CODED THE REQUEST IS UNCONDITIONAL. IF THE C PARAMETER IS NOT*
.*       CODED, THE REQUEST IS CONDITIONAL.                           *
.*                                                                    *
.* MAP:  THIS PARAMETER IS USED WHEN THE ADDRESSES ASSOCIATED WITH    *
.*       KEYS IN THE RPT ARE NOT ADDRESSES OF AREAS CONTAINING THE    *
.*       CORRESPONDING KEYS. THIS PARAMETER SPECIFIES THE ADDRESS OF A*
.*       SUBROUTINE TO BE EXECUTED WHEN THE RPT MODULE (IGARPT01) MUST*
.*       ACCESS A KEY USING ONE OF THE ADDRESSES FROM A KEY-ADDRESS   *
.*       PAIR. THE ADDRESS SPECIFIED BY THE MAP PARAMETER IS STORED IN*
.*       THE TREE HEADER, AND WHENEVER THE IGARPT01 MODULE MUST ACCESS*
.*       A KEY FROM ONE OF THE ADDRESSES THE ADDRESS ASSOCIATED WITH  *
.*       THE KEY IS PLACED IN REGISTER 1, AND A LINK IS MADE TO THE   *
.*       SUBROUTINE SPECIFIED BY THE MAP PARAMETER. UPON ENTRY TO THIS*
.*       ROUTINE A REGISTER SAVE AREA IS AVAILABLE USING THE ADDRESS  *
.*       IN REGISTER 13. THE MAPPING SUBROUTINE MAY STORE IT'S        *
.*       REGISTERS IN THE SAVE AREA PROVIDED. THE MAPPING SUBROUTINE  *
.*       MUST RESTORE ALL REGISTERS EXCEPT 0, 14, AND 15 TO THEIR     *
.*       CONTENTS UPON ENTRY.                                         *
.*                                                                    *
.*       THE MAPPING SUBROUTINE MUST COMPUTE THE ADDRESS OF THE       *
.*       CORRESPONDING KEY FROM THE ADDRESS FURNISHED IN REGISTER 1,  *
.*       AND LEAVE IT IN REGISTER 0 UPON RETURN TO THE IGARPT01       *
.*       MODULE. IF THE K PARAMETER HAS BEEN CODED "K=(D,L)" IN THE   *
.*       STREE MACRO-INSTRUCTION, THEN THE ADDRESS LEFT IN REGISTER 0 *
.*       MUST BE EQUAL TO THE ADDRESS OF THE CORRECT KEY MINUS THE    *
.*       DISPLACEMENT D, SINCE THE IGARPT01 MODULE WILL ADD THE       *
.*       DISPLACEMENT D TO THE ADDRESS IN REGISTER 0 TO FORM THE      *
.*       ADDRESS OF THE FIRST BYTE OF THE KEY.                        *
.*                                                                    *
.*       A TYPICAL USE OF THIS FEATURE WOULD BE TO STORE RECORDS ON A *
.*       DISK USING A BDAM ORGANIZATION, WHERE THE ADDRESSES          *
.*       ASSOCIATED WITH THE KEYS ARE THE BDAM BLOCK NUMBERS OF THE   *
.*       CORRESPONDING RECORDS. THEN THE MAPPING SUBROUTINE TAKES THE *
.*       BDAM BLOCK NUMBER IN REGISTER 1, READS THE CORRESPONDIN BDAM *
.*       BLOCK, AND PUTS THE MAIN STORAGE ADDRESS OF THE REOCRD READ  *
.*       IN REGISTER 0 PRIOR TO RETURNING TO THE IGARPT01 MODULE. IN  *
.*       THIS WAY THE ADDRESSES ASSOCIATED WITH THE KEYS IN THE RPT   *
.*       CAN BE COMPLETELY ARBITRARY, TO BE RESOLVED WHEN NEEDED BY   *
.*       THE MAPPING SUBROUTINE.                                      *
.*                                                                    *
.*       THE ADDRESS OF THE MAPPING SUBROUTIE CAN BE IN A REGISTER BY *
.*       CODING "MAP=(GPR)", WHERE "GPR" IS THE NAME OR NUMBER OF THE *
.*       REGISTER CONTAINING THE ADDRESS OF THE MAPPING SUBROUTINE. IF*
.*       "MAP=LABEL" IS CODED, THE ADDRESS OF THE MAPPING SUBROUTINE  *
.*       IS AT THE LOCATION "LABEL". A BRANCH TO THE SPECIFIED LABEL  *
.*       SHOULD RESULT IN EXECUTION OF THE MAPPING SUBROUTINE. THE    *
.*       ADDRESS IS FORMED BY EXECUTINNG A LOAD-ADDRESS INSTRUCTION   *
.*       WITH THE SPECIFIED LABEL.                                    *
.*                                                                    *
.*       IF THE MAP PARAMETER IS NOT CODED THERE IS NO ATTEMPT MADE TO*
.*       EXECUTE A MAPPING SUBROUTINE BY THE IGARPT01 MODULE. IN THIS *
.*       CASE EVERY ADDRESS ASSOCIATED WITH A KEY MUST BE THE MAIN    *
.*       STORAGE ADDRESS OF AN AREA CONTAINING THE KEY.               *
.*                                                                    *
.*       THE PARAMETERS IVS, TYPE, TSPACE, RSPACE, RSP, KEYL, OFFSET, *
.*       AND RECL ARE ONLY PRESENT FOR COMPATIBILITY WITH EARLIER     *
.*       VERSIONS OF THE STREE MACRO-INSTRUCTION, AND SHOULD NOT BE   *
.*       USED, AS THEY ARE NOT SUPPORTED IN ANY CONTEXT OTHER THAN THE*
.*       ONE THEY WERE USED IN ORIGINALLY.                            *
         GBLA  &IGALEFT(256)   LEFT EDGES FOR BINARY TREE PARSE.
         GBLA  &IGARGHT(256)   RIGHT EDGES FOR BINARY TREE PARSE.
         GBLB  &IGARL(256)     LEFT/RIGHT FLAG BITS FOR BINARY PARSE.
         GBLB  &IGAIS(256)     INNER/SINK BIT FLAGS FOR PARSE TREE.
         GBLB  &IGAOKAY        1 IF PARSE DISCOVERED BAD SYNTAX.
         GBLA  &IGAX     TRIPLE FOR SCANNING OPERATION.
         GBLA  &IGAY     XX
         GBLA  &IGAZ     XX
         GBLC  &IGASTRE
         GBLB  &IGALONE  ON TO RUN THE RPT PROGRAMS STANDALONE.
         GBLC  &IGARPT#  THE RADIX PARTITION TREE TYPE.
         GBLB  &IGAPGM  ON IF THIS IS IGARPT01.
         LCLC  &X        LOCAL CHARACTER STRING.
         LCLA  &N        LOCAL VARIABLE.
         LCLA  &I        LOCAL INDEX VARIABLE.
         LCLA  &J        LOCAL VARIABLE.
.*A000000                                                        Y02147
.**********************************************************************
.* CHECK TO SEE IF ANY OF THE OLD PARAMETERS OF THE STREE MACRO ARE   *
.* SPECIFIED, AND IF THEY ARE TRANSLATE THEM TO THE NEW PARAMETERS VIA*
.* THE MACRO RECURSION TECHNIQUE.                                     *
.**********************************************************************
         AIF   ((K'&KEYL EQ 0)AND(K'&OFFSET EQ 0)).NEW  SEE IF THEY ARE*
                         BOTH NOT SPECIFIED.
&TAG     STREE &TREE,TSP=&TSP,T=&T,TYPE=&TYPE,FIX=&FIX,IVS=&IVS,S=&S,  *
               MAP=&MAP,K=(&OFFSET,&KEYL)
         AGO   .FIN      ALL DONE WITH THE MAPPING FROM THE OLD TO THE *
                         NEW FORMATS, NOW EXIT FROM THE STREE MACRO.
.NEW     ANOP
.**********************************************************************
.* CHECK THE TYPE AND T PARAMETERS TO SEE IF A VALID RPT TYPE IS      *
.* SPECIFIED. IF NEITHER IS SPECIFIED, ASSUME IT IS TYPE 8 RPT. THE   *
.* TYPE IS PUT INTO THE GLOBAL VARIABLE &IGARPT# AT THE END OF THE    *
.* TYPE CHECKING SECTION.                                             *
.**********************************************************************
.RPT#    AIF   (K'&T EQ 0).RPT#TMT  SEE IF THE T PARAMETER IS CODED.
         AIF   (K'&TYPE EQ 0).RPT#TCK  USE THE T PARAMETER IF IT IS    *
                         CODED AND THE TYPE PARAMETER IS NOT CODED.
.**********************************************************************
.* BOTH THE T AND TYPE PARAMETERS ARE CODED; SEE IF THEY ARE THE SAME,*
.* AND IF THEY ARE NOT THEN USE T.                                    *
.**********************************************************************
         AIF   ('&T' EQ '&TYPE').RPT#TCK  IF THEY ARE THE SAME THEN USE*
                         T.
         MNOTE 4,'TYPE CONFLICT, ONLY T OR TYPE SHOULD BE CODED.'
.RPT#TCK ANOP
&IGARPT# SETC  '&T'      GET THE RPT TYPE.
         AGO   .RPT#CHK  GO TO CHECK THE VALIDITY OF THE RADIX         *
                         PARTITION TREE TYPE.
.**********************************************************************
.* THE T PARAMETER IS NOT CODED, SEE IF THE TYPE PARAMETER IS CODED.  *
.**********************************************************************
.RPT#TMT AIF   (K'&TYPE EQ 0).RPT#8  IF BOTH ARE LEFT OUT USE TYPE 8   *
                         RPT.
&IGARPT# SETC  '&TYPE'   SET THE TYPE TO THE TYPE THAT IS SPECIFIED BY *
                         THE TYPE PARAMETER.
         AGO   .RPT#CHK  GO CHECK IT FOR VALIDITY.
.RPT#8   ANOP
&IGARPT# SETC  '8'       SET THE RPT TYPE TO 8.
.RPT#CHK AIF   (('&IGARPT#' EQ '8')OR('&IGARPT#' EQ '5')OR('&IGARPT#' E*
               Q '4')).RPT#FIN
         MNOTE 4,'INVALID RPT TYPE, TYPE 8 ASSUMED.'
&IGARPT# SETC  '8'       USE TYPE 8 RPT.
.RPT#FIN ANOP
      RPTDSECT T=&IGARPT#,DS=NO
.**********************************************************************
.* GET THE ADDRESS OF THE MODULE IGARPT01 IN REGISTER 14 FOR THE LINK *
.* TO THE APPROPRIATE ROUTINE TO SET UP THE RPT.                      *
.**********************************************************************
         AIF   (K'&S NE 0).USE@S  SEE IF THE SPACE CONTROL ADDRESS IS  *
                         CODED; BECAUSE IF IT IS THE ADDRESS CAN BE    *
                         LOADED DIRECTLY FROM IT.
         AIF   (&IGALONE).LOAD  IF THIS IS THE STAND-ALONE CASE USE THE*
               LOAD MACRO TO LOAD THE MODULE IGARPT01.
&TAG   RPTDSECT GEN=(CVTRPT,14)  GET THE ADDRESS FROM THE CVT.
         AGO   .LOADED   THE ADDRESS IS IN GPR 14.
.LOAD    LOAD  EP=IGARPT01  LOAD THE MODULE.
         LR    14,0
         AGO   .LOADED   ALL DONE GETTING THE ADDRESS IN R14.
.USE@S   AIF   ('&S'(1,1) EQ '(').USESGPR  SEE IF THE SPACE CONTROL    *
               ADDRESS IS IN A GENERAL PURPOSE REGISTER.
         L     15,&S     LOAD THE ADDRESS OF THE SPACE CONTROL AREA.
         L     14,0(,15) ADDRESS OF IGARPT01.
         AGO   .LOADED   ALL LOADED NOW.
.USESGPR AIF   ('&S' EQ '(15').LOAD14  SEE IF IT IS ALREADY IN R15.
         LR    15,&S(1)  SPACE CONTROL ADDRESS.
.LOAD14  L     14,0(,15)  ADDRESS OF IGARPT01.
.LOADED  ANOP
.**********************************************************************
.* CHECK TO SEE IF A PGFIX OPERATION MUST BE DONE ON THE RPT MODULE.  *
.**********************************************************************
         AIF   (K'&FIX EQ 0).NOFIX  GO AROUND THE PGFIX IF IT IS NOT   *
               CODED IN THE STREE MACRO-INSTRUCTION.
         AIF   (('&FIX'(1,1) NE 'Y')AND('&FIX'(1,1) NE '1')).NOFIX
         STM   14,3,12(13) SAVE REGS.
         LR    2,14
         LA    3,(3*X'C')(13) ECB ADDRESS.
         MVI   0(3),X'00'
         PGFIX R,A=(2),ECB=(3)
         WAIT  ECB=(3)
         LM    14,12,12(13)  RESTORE REGISTERS.
.NOFIX   ANOP
.**********************************************************************
.* NOW PUT THE STREE PARAMETERS IN REGISTERS 0, 1, AND 15, AND LINK TO*
.* THE MODULE IGARPT01 TO SET UP THE RADIX PARTITION TREE OF THE      *
.* INDICATED TYPE.                                                    *
.* THE REGISTER CONTENTS UPON LINKING TO THE MODULE IGARPT01 ARE:     *
.* R0    KEYI, TYPE, AND KEY LENGTH. THE KEY INDEX IS A HALFWORD      *
.*       OFFSET, THE TREE TYPE IS A 7-BIT #, AND THE KEY LENGTH IS A  *
.*       9-BIT #.                                                     *
.* R1    THE ADDRESS OF THE MAPPING SUBROUTINE (IF THERE IS A MAPPING *
.*       SUBROUTINE).                                                 *
.* 14    THE ADDRESS OF THE MODULE IGARPT01.                          *
.* R15   TSP,S - THE TREE SUBPOOL AND THE ADDRESS OF THE SPACE CONTROL*
.*       AREA (IF THERE IS ONE).                                      *
.**********************************************************************
         AIF   (K'&TSP EQ 0).SPZERO  SEE IF THE SUBPOOL IS NOT CODED.
         AIF   ('&TSP' EQ '0').SPZERO  SEE IF SUBPOOL ZERO IS          *
                         EXPLICITLY CODED.
         AIF   (K'&S EQ 0).SELIDED  SEE IF THE SPACE CONTROL ADDRESS IS*
                         NOT CODED.
         AIF   ('&S'(1,1) EQ '(').SINGPR  SEE IF THE SPACE CONTROL     *
                         ADDRESS IS IN A GPR.
         LA    15,0(,15)
.S15AL   AL    15,=AL1(&TSP,0,0,0)  RPT SUBPOOL.
         AGO   .GOT15    GOT REGISTER 15 SET UP NOW.
.SINGPR  LA    15,0(,&S(1))  SPACE CONTROL ADDRESS.
         AGO   .S15AL    NOW GO ADD IN THE SUBPOOL NUMBER.
.SELIDED LA    15,&TSP   RPT SUBPOOL.
         SLL   15,24
         AGO   .GOT15    GOT REGISTER 15 ALL SET UP NOW.
.SPZERO  AIF   (K'&S EQ 0).NOSORSP  SEE IF THERE IS NEITHER A SPACE    *
                         CONTROL ADDRESS NOR A SUBPOOL CODED.
         LA    15,0(,15)
         AGO   .GOT15    ALL DONE SETTING UP REGISTER 15 NOW.
.NOSORSP SLR   15,15     SUBPOOL ZERO.
.GOT15   ANOP
.**********************************************************************
.* NOW PUT THE KEY INDEX, THE RPT TYPE #, AND THE KEY LENGTH IN       *
.* REGISTER 0.                                                        *
.**********************************************************************
         AIF   (K'&K NE 0).KNOTMT  SEE IF THE K PARAMETER IS CODED.
.KMNOTE  MNOTE 12,'"K=(DISPLACEMENT,KEY LENGTH)" MUST BE CODED.'
         AGO   .FIN      CAN'T DO ANY MORE WITH THIS, EXIT.
.KNOTMT  AIF   (N'&K EQ 2).KHAS2  SEE IF THERE ARE EXACTLY 2 OPERANDS  *
                         IN THE K PARAMETER.
         AIF   (N'&K NE 1).KMNOTE  SEE IF THERE IS JUST ONE.
&X       SETC  '&K(1)'(1,1)  GET THE FIRST CHARACTER OF THE FIRST      *
                         ELEMENT IN THE K PARAMETER.
         AIF   ((('&X' EQ '0')OR('&X' EQ '1')OR('&X' EQ '2')OR('&X' EQ *
               '3')OR('&X' EQ '4')OR('&X' EQ '5')OR('&X' EQ '6')OR('&X'*
                EQ '7')OR('&X' EQ '8')OR('&X' EQ '9'))).K1#
         LA    0,&K
         LH    1,*-2     OFFSET TO KEY + BASE REGISTER.
         N     1,=XL4'00000FFF'  ELIMINATE BASE REGISTER.
         SLL   1,7
         LA    0,&IGARPT#.(,1)  RPT TYPE.
&X       SETC  'L'''
         LA    1,&X&K
         SLL   0,16
         ALR   0,1
         AGO   .GETMAP   GO SEE IF THE MAP IS CODED.
.K1#     L     0,=AL4(B'1000000000'*&IGARPT#+&K)  RPT# &KL.
         MNOTE 0,'DISPLACEMENT TO KEY ASSUMED ZERO.'
         AGO   .GETMAP   ALL DONE WITH K NOW.
.KHAS2   ANOP
         AIF   (K'&K(1) EQ 0).KDSP0  CHECK FOR A ZERO DISPLACEMENT.
         AIF   ('&K(1)' EQ '0').KDSP0  SEE IF THE ZERO DISPLACEMENT IS *
                         EXPLICITLY CODED.
         LA    1,&K(1)   DISPLACEMENT TO THE KEY.
         SLL   1,7
         LA    0,&IGARPT#.(,1)  RPT TYPE.
         AGO   .GOTKDSP  ALL FINISHED SETTING UP DISPLACEMENT AND RPT  *
                         TYPE NOW.
.KDSP0   LA    0,&IGARPT#  RPT TYPE.
.GOTKDSP SLL   0,9
         LA    1,&K(2)   KEY LENGTH IN BYTES.
         ALR   0,1
.GETMAP  ANOP
         AIF   (K'&MAP EQ 0).NOMAP  SEE IF THE ADDRESS OF THE MAPPING  *
                         SUBROUTINE IS SPECIFIED.
         AIF   ('&MAP' EQ '0').NOMAP  SEE IF IT IS EXPLICITLY CODED AS *
                         ZERO.
         AIF   ('&MAP'(1,1) EQ '(').MAPGPR  SEE IF THE ADDRESS OF THE  *
                         MAPPING SUBROUTINE IS IN A GENERAL REGISTER.
         L     1,=AL4(&MAP)  ADDRESS OF MAPPING SUBROUTINE.
         AGO   .GOTMAP   ALL FINISHED SETTING UP REGISTER 1 NOW.
.MAPGPR  LR    1,&MAP(1)  ADDRESS OF MAPPING SUBROUTINE.
         AGO   .GOTMAP   ALL DONE WITH R1 NOW.
.NOMAP   SLR   1,1       INDICATE NO MAPPING SUBROUTINE PRESENT.
.GOTMAP  ANOP
.**********************************************************************
.* CHECK THE INNER VERTEX SIZE FOR 8 OR 12 BYTES, AND SET BIT 0 OF    *
.* REGISTER R1 TO 0 IF IT IS 8 BYTES, OR TO 1 IF IT IS 12 BYTES. IF IT*
.* IS NEITHER 8 NOR 12 BYTES GENERATE THE MNOTE.                      *
.**********************************************************************
         AIF   ('&IGARPT#' NE '8').SKIPIVS  SEE IF THIS IS A TYPE 8    *
                         RPT.
         AIF   (K'&IVS EQ 0).IVSIS8  THE DEFAULT INNER VERTEX SIZE IS 8*
                         BYTES.
         AIF   ('&IVS' EQ '8').IVSIS8  SEE IF THE INNER VERTEX SIZE IS *
                         8 BYTES.
         AIF   ('&IVS' EQ '12').IVSIS12  SEE IF THE INNER VERTEX SIZE  *
                         IS 12 BYTES.
         MNOTE 12,'INVALID INNER VERTEX SIZE, CAN ONLY BE 8 OR 12.'
         AGO   .IVSFIN   GO ON AND CHECK OTHER THINGS.
.IVSIS8  LA    1,0(,1)   SET BIT 0 TO 0 FOR IVS=8.
         AGO   .IVSFIN   ALL DONE SETTING UP R1 NOW.
.IVSIS12 O     1,=XL4'80000000'  INDICATE IVS=12.
.IVSFIN  ANOP
.SKIPIVS ANOP
.**********************************************************************
.* LINK TO THE STREE SUBROUTINE IN THE MODULE IGARPT01. IF THE C      *
.* PARAMETER IS CODED "C=Y", "C=1", OR "C=" THEN A BAL IS GENERATED TO*
.* INDICATE CONDITIONAL GSPACE/GETMAIN OPERATIONS. IF "C=N" OR "C=0"  *
.* IS CODED THE REQUEST IS UNCONDITIONAL, AND A BALR IS GENERATED FOR *
.* THE LINK TO THE STREE ROUTINE IN THE MODULE IGARPT01.              *
.**********************************************************************
         AIF   (K'&C EQ 0).LINKC  SEE IF THE C PARAMETER IS NOT CODED.
         AIF   ('&C' EQ 'C').LINKC  SEE IF IT A CONDITIONAL REQUEST.
         AIF   (('&C'(1,1) NE 'Y')AND('&C' NE '1')).LINKU  SEE IF THE  *
                         REQUEST IS UNCONDITIONAL.
.LINKC   BAL   14,&IGASTRE.(,14)  INDICATE CONDITIONAL GSPACE/GETMAIN.
         AGO   .TREE     ALL DONE NOW, EXCEPT FOR THE REGISTER TO      *
                         CONTAIN THE TREE ADDRESS.
.LINKU   LA    14,&IGASTRE.(,14)
         BALR  14,14     INDICATE UNCONDITIONAL GSPACE/GETMAIN.
.TREE    ANOP
         AIF   (K'&TREE EQ 0).STR5R1   GO IF IT'S TO BE LEFT IN R1.
         AIF   ('&TREE'(1,1) NE '(').STR5L   GO IF IT'S NOT A REGISTER.
         AIF   ('&TREE' EQ '(1)').STR5R1  GO IF IT'S ALREADY THERE.
         LR    &TREE(1),1      SAVE THE TREE ADDRESS.
         AGO   .STR5R1         MERGE.
.STR5L   ST    1,&TREE(1)  STORE THE TREE ADDRESS.
.STR5R1  ANOP
         AIF   ('&IGARPT#' NE '5').END  SEE IF THIS IS A TYPE 5 TREE.
      RPTDSECT T=5,DS=YES  GENERATE THE DSECT FOR TYPE 5 TREES.
.END     ANOP
.FIN     ANOP
         MEND
         EJECT
         MACRO
&TAG     TSORT &TREE,&OFFSET=0,&KEYL=256
.*A000000                                                        Y02147
.**********************************************************************
      RPTDSECT
LJW&SYSNDX EQU 1
         USING IGARPTH,LJW&SYSNDX  BASE REGISTER FOR DSECT.
         AIF   (K'&TREE EQ K'&TREE(1)+2).LW0
&TAG     L     1,&TREE
         AGO   .LW1
.LW0     ANOP
&TAG     LR    1,&TREE(1)
.LW1     ANOP
         AIF   (K'&OFFSET EQ K'&OFFSET(1)+2).LW2
         LA    0,&OFFSET       OFFSET TO KEY IN RECORD.
         STH   0,OFFSET
         AGO   .LW3
.LW2     ANOP
         STH   &OFFSET(1),OFFSET
.LW3     ANOP
         AIF   ('&KEYL'(1,1) EQ '(').LW4
         LA    0,&KEYL
         STH   0,KEYL
         AGO   .LW5
.LW4     STH   &KEYL(1),KEYL
.LW5     ANOP
         DROP  LJW&SYSNDX
         ISCAN (1)
SCAN&SYSNDX SCANL (1)
         LTR   15,15
         BC    8,END&SYSNDX
DEL&SYSNDX DEL (1),FREE=NO
         O     15,=XL4'80000000'
        FSPACE (1),A=(15)
         SCANL (1)
         LTR   15,15
         BC    7,DEL&SYSNDX
GSP&SYSNDX GSPACE (1)
         LTR   15,15
         BC    10,FIN&SYSNDX
LWR&SYSNDX EQU 1
         USING IGARPTH,LWR&SYSNDX
         AH    15,OFFSET
         DROP  LWR&SYSNDX
         SRCH  (1),SARG=(15)
         INS   (1),MOVE=NO
         BC    15,GSP&SYSNDX
FIN&SYSNDX EQU *
        FSPACE (1),A=(15)
END&SYSNDX EQU *
         MEND
         EJECT
         MACRO
&TAG     FOP   &R
&TAG     CLI   0(&R),C' '      SEEEE IF THE FIRST COLUMN IS BLANK?.
         BC    8,LA1&SYSNDX    BRANCH IF THERE ISN'T ANY LABEL.
LA0&SYSNDX LA  &R,1(&R)        ADD ONE TO THE ADDRESS IN THE REGISTER.
         CLI   0(&R),C' '      SEE IF THE LABEL IS PASSED BY TO MORE.
         BC    7,LA0&SYSNDX    BRANCH AS LONG AS THE LABEL ISN'T PASSED
LA1&SYSNDX LA  &R,1(&R)  NOW KEEP LOOKING UNTIL THE OP CODE FIELD IS
         CLI   0(&R),C' '      FOUND BY FINDING NOT A BLANK.
         BC    8,LA1&SYSNDX    XX
         MEND
         MACRO
&TAG     DSPRPT &TREE
         GBLB  &DSPRPT  IF THE GLOBAL ON DO IT;
         GBLC  &IGADSP         BRANCH ENTRY OFFSET FOR DSPRPT.
         LCLC  &R
         AIF   (K'&TAG EQ 0).NOLAB
&TAG     EQU   *
.NOLAB   AIF   (NOT &DSPRPT).FIN  DO IT NOT IF IT NOT ON.
       RPTDSECT TYPE=8
&R       SETC  ''
         AIF   ('&TREE'(1,1) NE '(').LOADIT
         AIF   ('&TREE' EQ '(1)').DONTLOD
&R       SETC  'R'
.LOADIT  L&R   1,&TREE(1)
.DONTLOD ANOP
         L     15,0(0,1)       LOAD THE ADDRESS OF IGARPT01.
         BAL   14,&IGADSP.(0,15)  LINK TO DSPRPT.
.FIN     ANOP
         MEND
         MACRO
         RASS  &A
         LCLA  &I
         LCLA  &J
         LCLA  &N
.**********************************************************************
&N       SETA  (N'&A)
&I       SETA  (1)
.LW0     ANOP
&J       SETA  (1+&I)
         AIF   (&J GT &N).END
&A(&I)   EQU  &A(&J)
&I       SETA  (&I+2)
         AGO   .LW0
.END     ANOP
         MEND
         MACRO
&TAG     BIT   &I=,&A=,&B=,&J=,&N=
.*--------------------------------------------------------------------*
.* THIS MACRO COMPUTES THE INDEX OF THE BIT OF INEQUALITY BETWEEN THE *
.* TWO BYTES ADDRESSED BY THE ADDRESSES IN REGISTERS &A AND &B.       *
.* &J AND &N ARE TWO WORKING REGISTERS; UPON EXECUTION OF THIS MACRO  *
.* THEY  BOTH  MUST CONTAIN ZEROS IN THE LEFT THREE BYTES.            *
.* &I IS A REGISTER THAT WAS PREVIOUSLY SET TO THE NEGATIVE OF THE    *
.* ADDRESS OF THE FIRST BYTE OF THE A-FIELD.                          *
.* THE RESULTING BIT INDEX IS LEFT IN REGISTER &I.                    *
.*--------------------------------------------------------------------*
&TAG     IC    &J,O(O,&A)  FETCH THE TWO BYTES OF INEQUALITY FROM THE
         IC    &N,O(O,&B)  TWO OPERANDS.
         ALR   &I,&A     COMPUTE THE INDEX OF THE BYTE OF INEQUALITY.
         SLL   &I,THREE  TRANSFORM THE BYTE INDEX INTO A BIT INDEX.
         XR    &N,&J     GET THE EXCLUSIVE-OR RESULT OF THE TWO BYTES.
BIT&SYSNDX LA  &J,X'FF'(O,&N)  SUBTRACT ONE FROM THE 8-BIT #.
         NR    &N,&J     MAKE THE RIGHTMOST BIT A ZERO.
         BC    7,BIT&SYSNDX KEEP DOING THIS UNTIL THERE IS ONLY ONE BIT
*                        LEFT.
         IC    &N,INSBIT-X'FF'(&J)  GET THE INDEX OF THE BIT OF
*                        INEQUALITY FROM THE TABLE.
         ALR   &I,&N     ADD THE BIT INDEX INTO THE SHIFTED BYTE TO
*                        FORM THE COMPLETE BIT INDEX.
         MEND
         MACRO
&TAG     ICALL &SUBR
.**********************************************************************
         AIF   ('&SUBR'(1,1) EQ '(').NOPAREN     SEE IF THERE ARE      *
                         ALREADY PARENTHESES AROUND THE ADDRESS.
&TAG     L     15,=AL4(&SUBR)
         AGO   .LINK
.NOPAREN L     15,=AL4&SUBR
.LINK    ANOP
         BALR  14,15
         MEND
         MACRO
&TAG     CHXN  &N=,&W=,&A=
.* CONVERT THE NUMBER IN DOUBLE-DIGIT PRINTABLE FORM STARTING AT THE  *
.* ADDRESS IN REGISTER &A TO A BINARY NUMBER IN REGISTER &N.          *
.* REGISTER &W IS JUST A WORKING REGISTER.                            *
.* STOP WHEN A CHARACTER IS FOUND THAT IS NEITHER IN THE RANGE X'C0'  *
.* TO X'C5' NOR IN THE RANGE X'F0'-X'F9'.                             *
.* THE ADDRESS IN REGISTER A IS LEFT AT THE FIRST NON-DIGIT.          *
&TAG     SLR   &N,&N         ZERO OUT THE NUMBER.
         BCTR  &A,0      SUBTRACT ONE FOR A TRAILING LOOP DECISION.
         LR    &W,&N   ZERO OUT THE WORKING REGISTER.
SLL&SYSNDX SLL &N,4  SHIF LEFT 4, THUS MULTIPLYING BY SIXTEEN.
         ALR   &N,&W  ADD IN THE NEXT DIGIT.
         IC    &W,1(0,&A)  PICK UP THE NEXT DIGIT.
         CLI   0(&A),C'0'  TEST IT FOR A ZERO TO NINE.
         BC    10,NUM&SYSNDX
         LA    &W,(X'FA'-C'A')(0,&W)  IT'S LESS, MUST BE A LETTER.
NUM&SYSNDX SL  &W,=AL4(C'0')  MAKE IT A 0-ORIGIN NUMBER.
         CL    &W,=F'15'  SEE IF IT REALLY IS A DIGIT.
         LA    &A,1(0,&A)  EKE THE ADDRESS.
         BC    12,SLL&SYSNDX  CONTINUE THE LOOP IF IT'S A DIGIT.
         MEND
         MACRO
&TAG     GOING &A
.**********************************************************************
&TAG     BALR  15,0            ESTABLISH ADDRESSABILITY.
         USING *,15
BAS&SYSNDX EQU *
         STM   14,12,12(13)    SAVE ALL THE REGISTERS.
         LA    15,SAV&SYSNDX
         DROP  15
         ST    15,8(0,13)
         ST    13,4(0,15)
         LR    13,15
         LA    &A,SAV&SYSNDX+2-BAS&SYSNDX  ADJUST THE BASE SO THAT IT
         LCR   &A,&A  AGREES WITH THE ADDRESS IN
         ALR   &A,15  REGISTER 15 ON ENTRY TO THE SUBROUTINE.
         USING BAS&SYSNDX-2,&A     XX
         BC    15,FIN&SYSNDX
SAV&SYSNDX DS 18F
FIN&SYSNDX EQU *
         MEND
         MACRO
&TAG     BACK
.**********************************************************************
&TAG     L     13,4(13)
         L     14,12(13)
         LM    0,12,20(13)
         SLR   15,15     SET THE RETURN CODE TO ZERO.
         BCR   15,14
         MEND
         MACRO
&TAG     FBI   &I=,&A=,&B=,&LV=,&WRK=,&ERROR=
.**********************************************************************
.* THIS MACRO FINDS THE INDEX OF THE BYTE OF INEQUALITY BETWEEN THE   *
.* TWO FIELDS SPECIFIED IN REGISTERS &A AND &B,                       *
.*                                                                    *
.* &LV IS THE REGISTER CONTAINING THE LENGTH OF THE TWO FIELDS IN BYTES
.* IF IT SPECIFIES A REGISTER, OR IT IS THE LENGTH OF THE TWO FIELDS. *
.* E. G. IF LV=(4) IS CODED, THE LENGTH IIS TAKEN FROM REGISTER 4,    *
.* BUT IF LV=15 IS CODED, THE FIELDS ARE OF LENGTH 15.                *
.* A MAXIMUM OF 256 CAN BE CODED FOR THE LENGTH VALUE.                *
.* &I IS THE REGISTER TO LEAVE THE RESULTING BIT-INDEX IN.            *
.* &WRK IS A WORKING REGISTER, AND MUST BE SPECIFIED.                 *
.* &ERROR IS A BRANCH ADDRESS FOR THE ERROR CONDITION OF LENGTH ZERO. *
.*                                                                    *
.*       NOTE: NONE OF THE REGISTERS CAN BE REGISTER 0 EXCEPT &I.     *
.*       IMPORTANT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   *
.**********************************************************************
         GBLB  &IGAVS2,&IGADIAG
         LCLC  &J,&N,&O,&K1,&K2,&K3,&K4
&O       SETC  '0'       JUST A ZERO.
&K1      SETC  '1'       JUST A ONE.
&K2      SETC  '2'       JUST A TWO.
&K3      SETC  '3'       JUST A THREE.
&K4      SETC  '4'       JUST A FOUR.
&N       SETC  '&WRK(1)'       THE 0-ORIGIN INDEX OF THE LAST BYTE OF
.*                             THE REMAINING PART OF THE KEY.
&J       SETC  '&LV(1)'        THE CURRENT MIDDLE OF WHAT'S LEFT INDEX.
         AIF   (K'&TAG EQ 0).SKIP
&TAG     EQU   *
.SKIP    ANOP
         AIF   (K'&ERROR EQ 0).SKIP2   SEE IF THE ERROR CHECK SHOULD
         LTR   &J,&J     CHECK FOR A ZERO LENGTH VALUE.
         BC    8,&ERROR        BRANCH IF THERE IS ZERO LENGTH.
.SKIP2   ANOP
         LCR   &I,&A(1)  SAVE THE NEGATIVE OF ONE OF THE ADDRESSES.
         AIF   ((&IGAVS2 AND (NOT &IGADIAG))).USECLCL
         BCTR  &J,&O     SUBTRACT ONE FOR 0-ORIGIN INDEXING.
LOOP&SYSNDX LTR &N,&J          TEST FOR THE END OF THE LOOP.
         JMP   8,BYTE&SYSNDX  BRANCH IF THE LAST ITERATION IS DONE.
SRL&SYSNDX SRL &J,&K1          DIVIDE BY TWO BY SHIFTING.
         EX    &J,CLC&SYSNDX  COMPARE HALF OF THE KEY.
         JMP   7,LOOP&SYSNDX  JUMP IF THE BYTE OF INEQUALITY IS IN
*                              THE FIRST HALF OF THE REMAINING PART.
         LA    &J,&K1.(&O,&J)  ADD ONE TO MAKE UP FOR 0-ORIGIN.
         SLR   &N,&J     SUBTRACT THE NUMBER OF BYTES ELIMINATED.
         ALR   &A,&J           EKE THE TWO ADDRESSES OF THE TWO
         ALR   &B,&J     FIELDS BEING COMPARED.
         LTR   &J,&N     CHECK FOR THE LAST ITERATION.
         JMP   7,SRL&SYSNDX    JUMP IF BINARY SEARCH NOT YET DONE.
BYTE&SYSNDX EQU *  COME HERE WHEN THE BYTE IS FOUND.
CLC&SYSNDX CLC &O.(&O,&A),&O.(&B)  COMPARE THE BYTE OF INEQUALITY,
*                        AND LEAVE THE CONDITION CODE SET.
         AIF   (NOT (&IGAVS2 AND &IGADIAG)).FIN
         BC    7,NOT&SYSNDX    THESE THREE INSTRUCTIONS ARE TO GENERATE
         LA    &A,ONE(O,&A)  AN EXACT DUPLICATE OF THE RESULTS OF THE
         LA    &B,ONE(O,&B)  CLCL INSTRUCTION FOR TESTING.
NOT&SYSNDX EQU *
         AGO   .FIN
.USECLCL LR    &N,&J  PUT THE LENGTH IN THE OTHER LENGTH REGISTER FOR
         DC    AL2(X'0F00'+(16*&A)+&B)  THE CLCL INSTRUCTION.
.FIN     ANOP
         MEND
         EJECT
         MACRO
&TABLE   TABLE &A
.**********************************************************************
.* THIS MACRO GENERATES A 256 BYTE TABLE, AND FILLS IN THE BYTES AT   *
.* THE LOCATIONS SPECIFIED BY THE FIRST MEMBERS OF EACH PAIR OF       *
.* ELEMENTS IN THE LIST WITH ONE-BYTE AL1 CONSTANTS SPECIFIED BY THE  *
.* CORRESPONDING SECOND MEMBERS OF EACH PAIR IN THE LIST.             *
.* THE REST OF THE BYTES ARE SET TO ZEROS.                            *
.**********************************************************************
         LCLA  &I,&N
         LCLC  &C
&TABLE   DC    256XL1'00'
&C       SETC  'X''FF'''
&N       SETA  N'&A
&I       SETA  (1)
.LOOP    ORG   *+&A(&I)-1-&C
         DC    AL1(&A(&I+1))
&C       SETC  '&A(&I)'
&I       SETA  (&I+2)
         AIF   (&I LT &N).LOOP
         ORG   *-1-&C+X'100'
         MEND
         MACRO
&TAG     JMP   &CC,&JUMP
         GBLB  &IGASPIE  TURN ON FOR SPIE BRANCH TRACE.
         AIF   ('&JUMP'(1,1) NE '(').RX  SEE IF IT IS AN RX BRANCH.
         AIF   (&IGASPIE).CNTRSPY  GO IF IT'S AN RR JUMP.
&TAG     BCR   &CC,&JUMP(1)
         AGO   .NOSPY
.CNTRSPY ANOP
&TAG     DC    AL2(X'0D00'+(16*&CC)+&JUMP(1))
         AGO   .NOSPY
.NOSPY   AGO   .FIN
.RX      ANOP
&TAG     BC &CC,&JUMP
         AIF   (NOT &IGASPIE).USPY     GO IF NO BRANCH TRACE.
         ORG   *-4       OVERLAY THE OP CODE WITH X'4D'
         DC    XL1'4D'
         ORG   *+3
.USPY    ANOP
.FIN     ANOP
         MEND
         MACRO
&TAG     JM    &JUMP
&TAG     JMP   4,&JUMP
         MEND
         MACRO
&TAG     JNZ   &JUMP
&TAG     JMP   7,&JUMP
         MEND
         MACRO
&TAG     JZ    &JUMP
&TAG     JMP   8,&JUMP
         MEND
         MACRO
&TAG     SHOWHEX &TO=,&FROM=,&N=
         GBLB  &IGADSHX  ON AFTER THE CSECT TO DISPLAY HEX HAS BEEN    *
                         GENERATED ONCE.
.**********************************************************************
&TAG     LA    1,&TO     DESTINATION ADDRESS.
         LA    2,&FROM   SOURCE ADDRESS.
         LA    3,&N      NUMBER OF SOURCE BYTES.
         L     15,=AL4(IGADSPHX)
         BALR  14,15     CALL THE CONVERSION SUBROUTINE.
         AIF   (&IGADSHX).END  SEE IF THE CSECT HAS ALREADY BEEN DONE.
&IGADSHX SETB  (1)       SET IT ON TO INDICATE THAT THE CSECT TO DISPLAY
                         HEX HAS ALREADY BEEN GENERATED.
IGADSPHX CSECT
         USING *,15
* R1 IS THE DESTINATION ADDRESS.                                      *
* R2 IS THE SOURCE ADDRESS.                                           *
* R3 IS THE LENGTH OF THE SOURCE FIELD IN BYTES.                      *
         ALR   3,3       DOUBLE THE FIELD LENGTH.
         BCTR  3,0
         EX    3,IGADSPMV      MOVE IN THE PATTERN.
         EX    3,IGADSPTR      MOVE FIELD TO OUTPUT AREA (TWICE).
         EX    3,IGADSPNC      KNOCK OFF THE REDUNDANT BITS.
         EX    3,IGADSPCV      CONVERT TO EBCDIC REPRESENTATION.
         BR    14        IT'S ALL OVER NOW.
IGADSPMV MVC   0(0,1),IGAX0011  MOVE IN THE PATTERN.
IGADSPTR TR    0(0,1),0(2)     THIS TRANSLATE IS REALLY A MOVE.
IGADSPNC NC    0(0,1),IGADSPF0  KNOCK OFF THE REDUNDANT BITS.
IGADSPCV TR    0(0,1),IGADSPTB  CONVERT TO EBCDIC REPRESENTATION.
IGADSPTB DC    CL16'0123456789ABCDEF'
         DC    15CL15'123456789ABCDEF'
IGAX0011 DC    256AL1((*-IGAX0011)/2)  X'0001010202...' ETC..
IGADSPF0 DC    128XL2'F00F'
         DROP  15
&SYSECT  CSECT
.END     ANOP
         MEND
         EJECT
         MACRO
&TAG     NTR   &RASS=,&BR=12,&SAVE=(14,12),&S=,&LV=80,&R1=,&R0=,&SP=,  *
               &I=NO,&MODE=
.*--------------------------------------------------------------------*
.* THIS MACRO SAVES THE REGISTERS FROM THE &SAVE PARAMETER IN THE     *
.* SAVE AREA ADDRESSED BY REGISTER 13, ESTABLISHES ADDRESSABILITY IN  *
.* THE REGISTER SPECIFIED BY &BR, AND GETS SPACE FOR ANOTHER SAVE AREA*
.* THE ISPACE MACRO IS THEN EXECUTED, AND THE SPACE ADDRESS IS STORED *
.* INTO THE MAIN STORAGE LOCATION OR REGISTER SPECIFIED BY THE &S     *
.* PARAMETER.                                                         *
.* MODULE IGARPT01 IS GENERATED, WHICH CONTAINS THE GSPACE SUBROUTINES.
.* THE SUBPOOL CAN BE SPECIFIED BY CODING THE &SP PARAMETER.          *
.* AN 80 BYTE SAVE AREA IS OBTAINED VIA GSPACE, AND IS CHAINED BACK   *
.* TO THE OLD SAVE AREA.                                              *
.* THE GLOBAL VARIABLE &IGALONE IS ON WHEN THE PROGRAM IS BEING UNIT  *
.* TESTED.                                                            *
.* IF THE R1 PARAMETER IS CODED, THE CONTENTS OF REGISTER R1 ARE MOVED*
.* TO THE SPECIFIED LOCATION BEFORE REGISTER R1 IS USED FOR THE GSPACE.
.*--------------------------------------------------------------------*
          GBLB  &IGALONE  ON TO UNIT TEST THE PROGRAM (I. E.STANDALONE)
         GBLB  &IGADSEK        ON IF THE TCB DSECT HAS BEEN GENERATED.
         GBLB  &IGARASS  ON IF THE REGISTER AND OTHER EQUATES ARE DONE.
         LCLA  &O
         LCLC  &S1,&S2   THIS IS FOR THE TWO REGISTERS IN THE SAVE LIST
.*                       IN THE &SAVE PARAMETER.                      *
.*--------------------------------------------------------------------*
         AIF   (K'&RASS EQ 0).DIDRASS  SEE IF THE RASS PARAMETER IS    *
                         CODED.
         AIF   (('&RASS'(1,1) NE 'Y')AND('&RASS'(1,1) NE '1')).DIDRASS *
                         SEE IF IT IS EITHER ALREADY DONE OR IT IS     *
                         CODED "NO".
         AIF   (&IGARASS).DIDRASS  GO IF RASS IS ALREADY DONE.
&IGARASS SETB  (1)  TURN IT ON SO THAT IT IS TURNED OFF.
R0       EQU   0         GPR 0 EQUATE.
R1       EQU   1         R1 EQU.
R2       EQU   2
R3       EQU   3         R3 EQU.
R4       EQU   4         R4 EQU.
R5       EQU   5         R5 EQU
R6       EQU   6         R6 EQU.
R7       EQU   7         R7 EQU.
R8       EQU   8         R8
R9       EQU   9         R9 EQU.
R10      EQU   10        R10   EQUATE.
RA       EQU   10        R10 EQU.
R11      EQU   11        R11 EQU.
RB       EQU   11        R11 EQU.
R12      EQU   12        R12 EQU.
RC       EQU   12        R12 EQU.
R13      EQU   13        R13 EQU.
RD       EQU   13        R13 EQU.
R14      EQU   14        R14 EQU.
RE       EQU   14        R14 EQU.
LKR      EQU   14        LINKAGE REGISTER.
R15      EQU   15        R15 EQU.
RF       EQU   15        R15 EQU.
ZERO     EQU   0         MISCELLANEOUS CONSTANTS EVERY PROGRAM NEEDS.
ONE      EQU   1         XX
TWO      EQU   2         XX
THREE    EQU   3         XX
FOUR     EQU   4         XX
FIVE     EQU   5         XX
SIX      EQU   6         XX
SEVEN    EQU   7         XX
EIGHT    EQU   8         XX
NINE     EQU   9         XX
TEN      EQU   10        XX
ELEVEN   EQU   11        XX
TWELVE   EQU   12        XX
THIRTEEN EQU   13        XX
FOURTEEN EQU   14        XX
FIFTEEN  EQU   15
SIXTEEN  EQU   16        XX
TWENTY   EQU   20        XX
.DIDRASS ANOP
.*--------------------------------------------------------------------*
&S1      SETC  '&SAVE(1)'(1,K'&SAVE(1))  GET THE FIRST REGISTER OF THE *
                         GROUP OF REGISTERS TO BE SAVED.
&S2      SETC  '&SAVE(2)'(1,K'&SAVE(2))  GET THE SECOND REGISTER OF THE*
                         GROUP TO BE SAVED.
&O       SETA  0    SET THE NUMBER OF BYTES GENERATED THUS FAR TO ZERO.
         AIF   (K'&SAVE EQ 0).NOSAVE  SEE IF THERE ARE ANY REGISTERS TO*
                         BE SAVED THIS TIME.
&O       SETA  4         FOUR BYTES GENERATED THUS FAR FOR THE STM     *
                         INSTRUCTION.
&TAG     STM   &S1,&S2,((4*&S1)+20-64*((2+&S1)/16))(13)  SAVE REGS.
.NOSAVE  AIF   ((&O EQ 4)OR(K'&TAG EQ 0)).SKIP0  SEE IF THE TAG IS     *
                         CODED AND THE STM WAS NOT GENERATED.
&TAG     EQU   *         PROVIDE A REFERENCE POINT FOR BRANCHES, ETC..
.SKIP0   ANOP
         AIF   (N'&BR EQ 2).TWO  SEE IF THIS IS THE ENTRY POINT.
         BALR  &BR,0     ESTABLISH A BASE REGISTER.
&O       SETA  (&O+2)  ADD THE LENGTH OF THE BALR INSTRUCTION.
         AIF   (K'&TAG EQ 0).NOLABEL  SEE IF THE LABEL IS THERE.
         USING &TAG,&BR  THE BASE REGISTER ADDRESSES THE LABEL.
         LCR   &BR(1),&BR(1)  CAUSE THE ADDRESS TO AGREE WITH
         LA    &BR(1),&O.(,&BR(1))  THE LABEL ON THE NTR MACRO.
         LCR   &BR(1),&BR(1)  DO THIS WITHOUT USING ANY OTHER GPRS.
         AGO   .JOIN     JOIN THE COMMON PATH.
.NOLABEL USING *,&BR     ESTABLISH ADDRESSABILITY.
         AGO   .JOIN     JOIN THE COMMON PATH.
.TWO     AIF   ('&BR(1)' EQ '&BR(2)').TWOTOO       SEE IF THE SAME.
&O       SETA  (&O-4)
         LR    &BR(1),&BR(2)  LOAD THE BASE REGISTER.
.TWOTOO  AIF   (K'&TAG EQ 0).NOTAG
         USING &TAG,&BR(1)     ESTABLISH ADDRESSABILITY.
         AGO   .JOIN
.NOTAG   USING *-&O,&BR(1)  PROVIDE ADDRESSABILITY.
.JOIN    ANOP
         AIF   (K'&R1 EQ 0).NOR1NOW
         AIF   ('&R1'(1,1) EQ '(').R1REG           SEE IF IT'S A REG.
         ST    1,&R1     SAVE THE PARAMETER LIST REGISTER CONTENTS.
         AGO   .NOR1NOW
.R1REG   LR    &R1(1),1  SAVE THE PARAMETER LIST REGISTER.
.NOR1NOW ANOP
.* THE STM AND THE USING ARE ALL FINISHED, NOW GET THE SAVE AREA.     *
         AIF   (('&I'(1,1) EQ 'Y')OR('&I'(1,1) EQ '1')).INIT           *
                         SEE IF THE INITIALIZATION PARAMETER IS CODED  *
                         SO AS TO INVOKE THE ISPACE MACRO-INSTRUCTION.
         AIF   ((K'&LV EQ 0)OR('&LV' EQ '0')).END  SEE IF THERE IS A   *
                         ZERO LENGTH VALUE.
         AIF   ('&MODE' EQ 'GETMAIN').GETMAIN  SEE IF THE MODE IS      *
               GETMAIN INSTEAD OF GSPACE.
        GSPACE R,S=&S,LV=&LV,SP=&SP  GET THE SPACE.
         AGO   .SKIPIT
.GETMAIN GETMAIN R,LV=&LV,SP=&SP  GET THE SAVE AREA VIA GETMAIN.
         AGO   .SKIPIT   ALL DONE GETTING THE SAVE AREA NOW.
.INIT   GSPACE S,S=&S,SP=&SP,LV=&LV
.SKIPIT  ANOP
         ST    1,8(0,13)  STORE THE FORWARD CHAIN.
         ST    13,4(0,1)  STORE THE BACK CHAIN FIELD.
         LR    13,1      ADDRESS OF NEW SAVE AREA.
.END     ANOP
.FIN     ANOP
         MEND
         EJECT
         MACRO
&TAG     LEAF  &SAVE=(14,12),&RC=0,&SP=,&S=,&LV=80,&R0=,&R1=,&MODE=
.*--------------------------------------------------------------------*
.* THIS MACRO RELEASES THE SAVE AREA ADDRESSED BY REGISTER 13 TO THE  *
.* SYSTEM VIA THE FSPACE MACRO, AFTER SAVING THE BACK CHAIN WORD.     *
.* THE REGISTERS SPECIFIED BY THE S PARAMETER ARE THEN RESTORED USING *
.* THE SAVE AREA RECOVERED VIA THE BACK CHAIN WORD.                   *
.* THE RETURN CODE IS THEN SET USING THE RC PARAMETER. IF THE RC      *
.* PARAMETER SPECIFIES THE RETURN CODE IN A REGISTER (INDICATED BY    *
.* CODING THE REGISTER NAME OR NUMBER IN PARENTHESES), THEN THAT GPR  *
.* IS SAVED IN THE FORWARD CHAIN WORD OF THE SAVE AREA ACCESSED VIA   *
.* THE BACK CHAIN BEFORE THE REGISTERS ARE RESTORED. THEN THE VALUE   *
.* IS PLACED IN REGISTER 15. IF THE RETURN CODE IS NOT IN A REGISTER, *
.* THEN IT MUST BE A SUITABLE VALUE FOR THE OPERAND OF A LOAD ADDRESS *
.* INSTRUCTION.  FOR EXAMPLE, CODING THE LEAF MACRO AS:               *
.*       LEAF  SAVE=(6,8),RC=0  WILL RESULT IN REGISTERS 6-8 BEING    *
.* RESTORED AFTER THE SAVE AREA IS RELEASED. THEN THE RETURN CODE IS  *
.* IS SET TO ZERO, AND THE RETURN IS EXECUTED VIA BR 14.              *
.*--------------------------------------------------------------------*
.* LV=#  MEANS LR 1,13;  L 13,4(,13);  FSPACE;  LM;  BR 14.           *
.* LV=0  MEANS L 13,4(,13);  LM;  BR 14.                              *
.* LV=-0 MEANS L 13,4(,13);  LM;  L 13,4(,13);  BR 14                 *
.* LV=   MEANS LM;  BR 14.                                            *
         GBLB  &IGALONE  THIS IS ON FOR THE UNIT TEST OF FSPACE.
         GBLA  &IGAX     THE PENULTIMATE VERTEX ON THE PATH TO THE ATOM*
                         IN THE BINARY PARSE TREE.
         GBLA  &IGAZ     THE VERTEX ON THE END OF THE PATH TO THE ATOM.
         GBLA  &IGALEFT(256)  SUBTRACTION INVERTIBLE LEFT EDGES IN THE *
                         BINARY PARSE TREE.
         GBLA  &IGARGHT(256)  SUBTRACTION INVERTIBLE RIGHT EDGES IN THE*
                         BINARY PARSE TREE.
         GBLA  &IGALEVL  THE NUMBER OF PARENTHESES SURROUNDING THE     *
                         CURRENT ATOM.
         GBLA  &IGAPATH(16)  THE PATH VECTOR TO THE ATOM IN THE PARSE  *
                         TREE.
         LCLC  &S1,&S2,&SA
         LCLA  &Z,&TMPA  LOCAL VARIABLES TO CORRESPOND TO THOSE ABOVE.
         LCLC  &X        JUST A LOCAL CHARACTER VARIABLE.
&SA      SETC  '13'      USE THIS LOCAL NAME FOR REGISTER 13.
&X       SETC  '+20-64*'  USE THIS TO AVOID EXPRESSIONS THAT ARE TOO   *
                         LONG.
         AIF   (K'&TAG EQ 0).NOTAG  SEE IF THE TAG IS CODED.
&TAG     EQU   *
.NOTAG   AIF   (K'&LV EQ 0).CHKRC  SEE IF THE LENGTH VALUE IS THE EMPTY*
                         STRING.
         AIF   ('&LV' EQ '0').LV0  SEE IF IT IS CODED AS "LV=0"
         AIF   ('&LV' EQ '-0').LV0  SEE IF THERE ARE TWO LEVELS OF SAVE*
                         AREAS IN THE SAVE AREA STACK.
.* LV=#BYTES IS CODED.                                                *
         AIF   (K'&R0 EQ 0).R0DONE  SEE IF R0 SHOULD BE SAVED THROUGH  *
                         THE FSPACE.
         LR    &R0,0     SAVE R0 SO IT DOESN'T GET LOST DURING THE     *
                         FSPACE MACRO-INSTRUCTION.
.R0DONE  AIF   (K'&R1 EQ 0).R1DONE  SEE IF R1 SHOULD BE SAVED THROUGH  *
                         THE FSPACE MACRO-INSTRUCTION.
         LR    &R1,1     SAVE R1 SO THE FSPACE MACRO DOESN'T SMASH IT'S*
                         CONTENTS.
.R1DONE  LR    1,13      ADDRESS OF SAVE AREA TO BE RELEASED.
         L     13,4(,13)  TRACE BACK TO PREVIOUS LEVEL SAVE AREA.
         AIF   ('&MODE' EQ 'FREEMAIN').FMAIN  SEE IF THE MODE IS TO USE*
                         FREEMAIN TO FREE THE SAVE AREA.
        FSPACE R,LV=&LV,S=&S,SP=&SP,A=(1)  RELEASE THE SAVE AREA.
         AGO   .CHKR0    GO CHECK THE R0 PARAMETER NOW.
.FMAIN FREEMAIN R,LV=&LV,SP=&SP,A=(1)  RELEASE THE SAVE AREA.
.CHKR0   ANOP
         AIF   (K'&R0 EQ 0).DIDR0  SEE IF R0 HAS TO BE RESTORED.
         LR    0,&R0     RESTORE R0.
.DIDR0   AIF   (K'&R1 EQ 0).DIDR1  SEE IF R1 MUST BE RESTORED.
         LR    1,&R1     RESTORE R1.
.DIDR1   AGO   .CHKRC    GO CHECK THE RETURN CODE.
.LV0     L     13,4(,13)  TRACE BACK TO PREVIOUS LEVEL SAVE AREA.
.CHKRC   AIF   (K'&RC EQ 0).LOAD#  SEE IF THE RETURN CODE IS CODED.
         AIF   ('&RC'(1,1) NE '(').LOAD#  SEE IF THE RETURN CODE IS    *
                         CODED AS A NUMBER INSTEAD OF IN A REGISTER.
         LTR   15,&RC(1)  SET THE RETURN CODE AND SET THE CONDITION    *
                         CODE.
.**********************************************************************
.* PARSE THE SAVE PARAMETER AND GENERATE ALL THE LOAD OR LOAD-MULTIPLE*
.* INSTRUCTIONS TO RESTORE ALL THE INDICATED REGISTERS.               *
.**********************************************************************
.LOAD#   AIF   (K'&SAVE EQ 0).L#FIN  SEE IF THERE ARE NO REGISTERS TO  *
                         BE RESTORED.
      RPTDSECT LIST=&SAVE,SCAN=PARSE  PARSE THE SAVE PARAMETER.
      RPTDSECT SCAN=ISCAN
      RPTDSECT SCAN=NEXT  GET THE NEXT ATOM IN THE SAVE LIST.
         AIF   (&IGALEVL EQ 0).L#0  SEE IF THE SAVE PARAMETER ONLY HAS *
                         ONE ELEMENT, NOT ENCLOSED IN PARENTHESES.
         AIF   (&IGALEVL EQ 1).L#1A  SEE IF THERE IS ONE LEVEL OF      *
                         PARENTHESES, I.E. THE REGISTER IS ONLY A      *
                         SINGLE REGISTER.
         AIF   (&IGALEVL EQ 2).L#2  SEE IF THERE IS A PAIR OF REGISTERS*
                         ENCLOSED IN PARENTHESES.
         MNOTE 12,'TOO MANY NESTED LEVELS OF PARENTHESES-- SAVE PARAM.'
         AGO   .FIN
.L#0     ANOP
&S1      SETC  '&SAVE'(&IGALEFT(&IGAZ),&IGARGHT(&IGAZ))                *
                         GET THE REGISTER TO BE RESTORED.
         L     &S1,((4*&S1)+20-64*((2+&S1)/16))(,13) RESTORE THE GPR.
         AGO   .L#FIN    ALL DONE WITH THE RESTORING OF THE REGISTERS.
.L#1     ANOP
&S1      SETC  '&SAVE'(&IGALEFT(&IGAZ),&IGARGHT(&IGAZ))                *
                         GET THE REGISTER TO BE RESTORED.
         L     &S1,((4*&S1)+20-64*((2+&S1)/16))(,13) RESTORE THE GPR.
         AGO   .L#MOR    GO LOOK FOR THE NEXT ELEMENT IN THE LIST.
.L#1A    AIF   (N'&SAVE EQ 1).L#0  SEE IF THERE IS EXACTLY ONE ELEMENT *
                         IN THE LIST.
         AIF   ((N'&SAVE NE 2)OR('&SAVE(2)'(1,1) EQ '(')).L#1          *
                         SEE IF IT IS JUST A SINGLE RANGE OR IF IT IS A*
                         SINGLE REGISTER FOLLOWED BY A RANGE.
.L#1B    LM    &SAVE(1),&SAVE(2),((4*&SAVE(1))+20-64*((2+&SAVE(1))/16))*
               (13)      RESTORE THE REGISTERS.
         AGO   .L#FIN    ALL FINISHED, GO TO THE COMMON EXIT POINT FROM*
                         THE MACRO SUBROUTINE.
.L#2     ANOP
&Z       SETA  &IGAZ     XX
&TMPA    SETA  &IGAPATH(&IGALEVL-1)  SAVE THE PATH VECTOR ELEMENT.
      RPTDSECT SCAN=NEXT  SET THE CURSOR TO THE NEXT ATOM IN THE LIST.
         AIF   (&IGALEVL NE 2).L#2A  SEE IF THE NEXT ATOM IS NOT IN THE*
                         SAME SUBLIST.
         AIF   (&IGAPATH(&IGALEVL-1) NE &TMPA).L#2A  CHECK FURTHER FOR *
                         THE NEXT ATOM BEING IN THE SAME SUBLIST.
&S1      SETC  '&SAVE'(&IGALEFT(&Z),&IGARGHT(&Z))                      *
                         GET THE FIRST REGISTER OF THE GROUP TO BE     *
                         RESTORED.
&S2      SETC  '&SAVE'(&IGALEFT(&IGAZ),&IGARGHT(&IGAZ))                *
               GET THE SECOND REGISTER OF THE GROUP TO BE RESTORED.
         LM    &S1,&S2,((4*&S1)+20-64*((2+&S1)/16))(13)  RESTORE GPRS.
.**********************************************************************
.* SCAN FOR THE NEXT ATOM IN THE LIST AFTER THE LAST PAIR; THE NEXT   *
.* ATOM MAY EITHER BE A SINGLE ATOM OF PARENTHESIS LEVEL 1, OR IT MAY *
.* BE OF PARENTHESIS LEVEL 2. IF IT IS PARENTHESIS LEVEL 2, CHECK TO  *
.* SEE IF IT HAS A PAIRED ELEMENT TO INDICATE A RANGE OF REGISTERS TO *
.* BE RESTORED.                                                       *
.**********************************************************************
.L#MOR RPTDSECT SCAN=NEXT  GET THE CURSOR POSITIONED AT THE NEXT ATOM  *
                         IN THE LIST.
.L#CHK   AIF   (&IGAX EQ 0).L#FIN  SEE IF THERE ARE ANY MORE ELEMENTS  *
                         IN THE LIST.
         AIF   (&IGALEVL EQ 2).L#2  SEE IF THE NEXT ATOM IS ON LEVEL 2.
         AIF   (&IGALEVL EQ 1).L#1  SEE IF IT IS ON LEVEL 1; IF IT     *
                         ISN'T ON LEVEL 1 THERE IS AN ERROR.
         MNOTE 12,'TOO MANY NESTED PARENTHESIS LEVELS IN SAVE PARAM.'
         AGO   .L#FIN    ALL DONE, WIG OUT NOW.
.L#2A    ANOP
&S1      SETC  '&SAVE'(&IGALEFT(&Z),&IGARGHT(&Z))                      *
                         GET THE REGISTER TO BE RESTORED.
         L     &S1,((4*&S1)+20-64*((2+&S1)/16))(,13) RESTORE THE GPR.
         AGO   .L#CHK    NOW SEE WHAT THE NEXT ATOM IS.
.L#FIN   ANOP
.*       N O W   F I G U R E   O U T   W H A T   T O   D O   N E X T  *
         AIF   ('&LV' NE '-0').SKIP0  SEE IF THE SAVE AREAS WERE NESTED*
                         TWO LEVELS DEEP.
         L     13,4(,13) TRACE THE SAVE AREA CHAIN BACKPATH ONE EDGE.
.SKIP0   ANOP
         AIF   (K'&RC EQ 0).SKIP3  SEE IF THE RETURN CODE WAS CODED.
         AIF   ('&RC'(1,1) EQ '(').SKIP3  SEE IF THE RETURN CODE WAS   *
                         ALREADY PUT INTO REGISTER 15.
.SKIP2   AIF   ('&RC' EQ '0').SKIP2B  SEE IF THE RETURN CODE SHOULD BE *
                         SET TO ZERO.
         AIF   ('&RC'(1,1) EQ '-').SKIP2A  SEE IF THE RETURN CODE IS   *
                         NEGATIVE.
         LA    15,&RC    SET THE RETURN CODE.
         LTR   15,15     SET THE CONDITION CODE FOR THE RETURN CODE.
         AGO   .SKIP3    ALL DONE, NOW GO GENERATE THE BR 14.
.SKIP2A  ANOP
         LA    15,0-(0&RC)  LOAD THE RETURN CODE IN 15.
         LNR   15,15  SET THE RETURN CODE MINUS AND THE CONDITION CODE.
         AGO   .SKIP3    NOW GO GENERATE THE BR 14.
.SKIP2B  SR    15,15     SET THE RETURN CODE TO ZERO.
.SKIP3   ANOP
         JMP   15,(14)   RETURN.
.FIN     ANOP
         MEND
         MACRO
&TAG     BT00  &V,&JUMP
.**********************************************************************
&TAG     TM    FLAGS(&V),T0
         JMP   8,&JUMP   JUMP IF T0 IS OFF.
         MEND
         MACRO
&TAG     BT01  &V,&JUMP
.**********************************************************************
&TAG     TM    FLAGS(&V),T0
         JMP   1,&JUMP   JUMP IF LEFT SUCCESSOR IS INNER.
         MEND
         MACRO
&TAG     BT10  &V,&JUMP
.**********************************************************************
&TAG     TM    FLAGS(&V),T1
         JMP   8,&JUMP   JUMP IF THE RIGHT SUCCESSOR IS A SINK.
         MEND
         MACRO
&TAG     BT11  &V,&JUMP
.**********************************************************************
&TAG     TM    FLAGS(&V),T1
         JMP   1,&JUMP   JUMP IF RIGHT SUCCESSOR IS AN INNER VERTEX.
         MEND
         MACRO
&TAG     BNET00 &V,&JUMP
&TAG     TM    FLAGS(&V),IGANEBIT+IGAT0BIT  SEE IF IT IS END.
         JMP   B'1110',&JUMP
         MEND
         MACRO
&TAG    BNET01 &V,&JUMP
&TAG     TM    FLAGS(&V),IGANEBIT+IGAT0BIT
         JMP   B'0001',&JUMP
         MEND
         MACRO
&TAG    BNET10 &V,&JUMP
&TAG     TM    FLAGS(&V),IGANEBIT+IGAT1BIT
         JMP   B'1110',&JUMP
         MEND
         MACRO
&TAG    BNET11 &V,&JUMP
&TAG     TM    FLAGS(&V),IGANEBIT+IGAT1BIT
         JMP   B'0001',&JUMP
         MEND
         MACRO
&TAG     SXIT  &A,&B,&P,&STM=NO
         LCLC  &XQ
         LCLC  &Q
         LCLC  &Z
         LCLC  &O
.**********************************************************************
&XQ      SETC  'X'''
&Q       SETC  ''''
&O       SETC  '1'
&Z       SETC  '0'
&TAG     MVI   PATH,&P
         LA    &A,0(0,&A)
         LA    &B,0(0,&B)
         AIF   ('&STM' EQ 'NO').LW0
         STM   &A,&B,AP
         AGO   .LW1
.LW0     ST    &A,AP
         ST    &B,AC
.LW1     AIF   ('&P'(K'&P,1) EQ '&Z').LW2
         G1ES  &A,&B,&A
         AGO   .LW3
.LW2     G0ES  &A,&B,&A
.LW3     ANOP
         LR    R15,&A  GET THE SINK ADDRESS TO RETURN IN REGISTER 15.
         AH    &A,OFFSET
         ST    &A,FARG
         SNAPR
         LM    FIRSTR,LASTR,20(13)
         BCR   15,LKR    RETURN.
***********************************************************************
         MEND
         MACRO
&TAG     TEDGF &EDG,&A,&B
         GBLB  &PAIRING
         GBLB  &SUB
         GBLB  &EXOR
         LCLC  &OPRN
         LCLC  &RP
         LCLC  &LPZC
         LCLC  &CMA
.**********************************************************************
         AIF   (K'&TAG EQ 0).SKIP
&TAG     EQU   *
.SKIP    ANOP
&RP      SETC  ')'
&LPZC    SETC  '(0,'
&CMA     SETC  ','
&OPRN    SETC  '&A'.'&CMA'.'&EDG'.'&LPZC'.'&B'.'&RP'
         AIF   (&EXOR).LWX
         AIF   (&SUB).LWS
         MNOTE 12,'ERROR, NO EDGE REPRESENTATION SPECIFIED.'
         AGO   .END
.LWX     X     &A,&EDG.(O,&B)
         AGO   .END
.LWS     AL    &A,&EDG.(O,&B)
         AGO   .END
.END     ANOP
         MEND
         MACRO
&TAG     TLE   &A,&B
         LCLC  &LFC
.**********************************************************************
&LFC     SETC  'LEF'
&TAG     TEDGF &LFC,&A,&B
         MEND
         MACRO
&TAG     TRE   &A,&B
         LCLC  &LFC
.**********************************************************************
&LFC     SETC  'RGHT'
&TAG     TEDGF &LFC,&A,&B
         MEND
         MACRO
&TAG     TLEF  &P,&C,&S,&CYCLE=NO
.**********************************************************************
         AIF   ('&C' EQ '&P').LW2
         AIF   ('&C' EQ '&S').LW2
         AIF   ('&P' NE '&S').LW0
&TAG     TLE   &S,&C
         AIF   ('&CYCLE' EQ 'NO').END
         MNOTE 12,'MEANINGLESS TO CYCLE TWO REGISTERS.'
         AGO   .END
.LW0     ANOP
&TAG     LR    &S,&P
         TLE   &S,&C
         AIF   ('&CYCLE' EQ 'NO').LW1
         LR    &P,&C
         LR    &C,&S
.LW1     AGO   .END
.LW2     MNOTE 12,'DUPLICATE REGISTER WITH CURRENT VERTEX'
.END     ANOP
         MEND
         MACRO
&TAG     TREF  &P,&C,&S,&CYCLE=NO
.**********************************************************************
         AIF   ('&C' EQ '&P').LW2
         AIF   ('&C' EQ '&S').LW2
         AIF   ('&P' NE '&S').LW0
&TAG     TRE   &S,&C
         AIF   ('&CYCLE' EQ 'NO').END
         MNOTE 12,'MEANINGLESS TO CYCLE TWO REGISTERS.'
         AGO   .END
.LW0     ANOP
&TAG     LR    &S,&P
         TRE   &S,&C
         AIF   ('&CYCLE' EQ 'NO').LW1
         LR    &P,&C
         LR    &C,&S
.LW1     AGO   .END
.LW2     MNOTE 12,'DUPLICATE REGISTER WITH CURRENT VERTEX'
.END     ANOP
         MEND
         MACRO
&TAG     TEDGB &EDG,&P,&C,&S,&CYCLE=NO
         GBLB  &PAIRING
         GBLB  &SUB
         GBLB  &EXOR
         LCLC  &OPRN
         LCLC  &RP
         LCLC  &LPZC
         LCLC  &CMA
.**********************************************************************
         AIF   (K'&TAG EQ 0).SKIP
&TAG     EQU   *
.SKIP    ANOP
&RP      SETC  ')'
&LPZC    SETC  '(0,'
&CMA     SETC  ','
&OPRN    SETC  '&P'.'&CMA'.'&EDG'.'&LPZC'.'&C'.'&RP'
         AIF   ('&CYCLE' EQ 'NO').ORK
         LR    &S,&C
         LR    &C,&P
.ORK     ANOP
         AIF   (&SUB).LWS
         AIF   (&EXOR).LWX
         MNOTE 12,'NO EDGE REPRESENTATION, ERROR.'
         AGO   .END
.LWX     AIF   ('&P' EQ '&S').LWX0
         LR    &P,&S
         X     &P,&EDG.(O,&C)
         AGO   .END
.LWX0    ANOP
         X     &P,&EDG.(O,&C)
         AGO   .END
.LWS     AIF   ('&P' EQ '&S').LWS0
         LR    &P,&S
.LWS0    SL    &P,&EDG.(O,&C)
         AGO   .END
.END     ANOP
         MEND
         MACRO
&TAG     TLEB  &P,&C,&S,&CYCLE=NO
         LCLC  &CMA
         LCLC  &LFC
.**********************************************************************
&CMA     SETC  ','
&LFC     SETC  'LEF'
&TAG     TEDGB &LFC,&P,&C,&S,CYCLE=&CYCLE
         MEND
         MACRO
&TAG     TREB  &P,&C,&S,&CYCLE=NO
         LCLC  &CMA
         LCLC  &LFC
.**********************************************************************
&CMA     SETC  ','
&LFC     SETC  'RGHT'
&TAG     TEDGB &LFC,&P,&C,&S,CYCLE=&CYCLE
         MEND
         MACRO
&TAG     TRBP  &P,&C,&S,&RL=,&TOP=,&CLEAR=NO
         GBLB  &PAIRING,&ABS,&SUB,&EXOR,&ESS,&EDG2,&EDG3
         LCLC  &X,&R
.*--------------------------------------------------------------------*
.* THIS MACRO CYCLES THE THREE REGISTERS &P, &C, AND &S, SO THAT      *
.* &P AND &C ARE ALWAYS TWO CONSECUTIVE VERTICES ON THE PATH. ONLY &P *
.* AND &C ARE VALID, &S IS USED AS A WORKING REGISTER.                *
.* THIS MACRO TRACES ONE EDGE UP THE BACKPATH; &C IS THE CURRENT
.* VERTEX, &S IS A WORKING REGISTER, AND &P IS THE PREDECESSOR OF &C. *
.* &S IS REPLACED BY &C, SO AS TO SAVE THE CURRENT VERTEX FOR         *
.* COMPUTING THE PREDECESSOR WITH THE INVERTIBLE EDGE, THEN &C IS     *
.* REPLACED BY &P, AND THEN THE NEW &P IS COMPUTED BY USING THE NEW   *
.* CONTENTS OF &S AS THE SUCCESSOR OF THE NEW VERTEX &C.              *
.* THUS THE EDGE FIELD USED TO FOR THE PREDECESSOR COMES FROM THE NEW *
.* VERTEX &C, AFTER &C HAS BEEN REPLACED BY THE ORIGINAL &P.          *
.* -------------------------------------------------------------------*
.* &RL IS EITHER A REGISTER CONTAINING THE VALUE 4, OR IS AN ADDRESS  *
.* OF A MAIN STORAGE LOCATION HAVING A FULL WORD CONSTANT 4.          *
.* IF &RL IS A REGISTER, IT MUST BE ENCLOSED IN PARENTHESIS, I. E.    *
.* IT MUST BE CODED AS RL=(REGISTER) IN WRITING THE MACRO.            *
.* NOTE THAT THE REGISTER RL MUST BE LOADED PRIOR TO EXECUTING TRBP.  *
.* IF RL IS OMITTED, THE LITERAL "=XL4'00000004'" IS USED.            *
.* &TOP IS THE PLACE TO BRANCH TO IF THE BACKPATH TRACE REACHES THE   *
.* TOP OF PATH CONDITION. IF TOP=^JUMP IS CODED, IT WILL BRANCH TO    *
.*  LOCATION "JUMP" IF THE TOP OF THE PATH HAS NOT BEEN REACHED.      *
.*--------------------------------------------------------------------*
         AIF   (K'&RL NE 0).RLNOTMT  AGO IF THE RL KEYWORD IS CODED.
&X       SETC  '=XL4''00000004'''  SUPPLY THE LITERAL AND DO IT AGAIN.
&TAG     TRBP  &P,&C,&S,RL=&X,TOP=&TOP,CLEAR=&CLEAR
         AGO   .FIN          FINISH UP.
.RLNOTMT ANOP
&TAG     LR    &S,&C         LOAD REGISTER WITH CURRENT VERTEX.
         LR    &C,&P         CAUSE THE PREDECESSOR TO BECOME CURRENT.
         IC    &P,FLAGS(O,&S)  GET THE FLAG BYTE.
&R       SETC  'R'
         AIF   ('&RL'(1,1) EQ '(').RRLR  GO IF &RL IS A REGISTER.
&R       SETC  ''     OTHERWISE SET &R TO THE EMPTY VECTOR.
.RRLR    N&R   &P,&RL(1)  AND X'04' WITH THE FLAG BYTE, TO PRODUCE
*                       THE INDEX OF THE LEFT OR RIGHT EDGE FIELD.
         AIF   (&EXOR).XOR   AGO IF EXCLUSIVE-OR INVERTIBLE EDGES.
         AIF   (&SUB).SUB    AGO IF SUBTRACTION INVERTIBLE EDGES.
         MNOTE 12,'INVALID EDGE REPRESENTATIONS.'
         AGO   .FIN          THAT WRAPS IT UP.
.XOR     L     &P,O(&P,&C)  LOAD THE LEFT OR RIGHT EXCLUSIVE-OR EDGE.
         XR    &P,&S        TRACE THE EDGE BACKWORD.
         AGO   .CCLEAR    GO SEE IF IT HAS TO CLEAR THE LEFT BYTE.
.SUB     SL    &S,O(&P,&C)  TRACE THE SUBTRACTION EDGE BACKWORD.
         LR    &P,&S   COMPLETE THE EDGE CYCLING PROCESS.
.* NOW THE EDGE HAS BEEN TRACED BACKWORD. SEE IF THE CLEAR IS NEEDED.
.CCLEAR  AIF  (('&CLEAR' EQ 'NO') AND (K'&TOP EQ 0)).CLEARNO
         LA    &P,O(O,&P)    CLEAR THE HIGH ORDER BYTE.
.CLEARNO ANOP
.* NOW SEE IF THE PAIR SHOULD BE CHECKED TO SEE IF THEY ARE THE TOP.  *
.CHKTOP  AIF   (K'&TOP EQ 0).SKIPTOP  SKIP IT IF THERE IS NO CHECK.
         CLR   &P,&C   SEE IF THE TOP-OF-PATH CONDITION EXISTS.
         AIF   ('&TOP'(1,1) EQ '^').NOTTOP  BRANCH IF NOT THE TOP JUMPS
         AIF   ('&TOP'(1,1) EQ '(').TOPBCR  BRANCH IF THE ADR IS IN REG
         BC    8,&TOP  BRANCH IF THE TOP OF THE PATH HAS BEEN REACHED.
         AGO   .END
.TOPBCR  BCR   8,&TOP(1)  BRANCH IT THE TOP OF THE PATH IS REACHED.
         AGO   .END  GO ON TO THE END.
.NOTTOP  ANOP
&X       SETC  '&TOP'(2,K'&TOP-1)
         AIF   ('&X'(1,1) EQ '(').BCRNOT  GO IF THE NOT TOP B.A. IS RR.
         BC    7,&X  BRANCH IF TOP NOT REACHED.
         AGO   .END  ALL DONE HERE, GO ON TO THE NEXT THING.
.BCRNOT  ANOP
&X       SETC  '&TOP'(3,K'&TOP-3)  GET ONLY THE REGISTER NAME.
         BCR   7,&X  BRANCH IF THE TOP HAS NOT YET BEEN REACHED.
.SKIPTOP ANOP
.END     ANOP
.FIN     ANOP
.*--------------------------------------------------------------------*
         MEND
         MACRO
&TAG   SQRLBPT &RL=,&TMP=0,&PATH=PATH,&MASK=
         LCLC  &R
.* THIS MACRO PERFORMS THE NECESSARY SETUP FOR THE BACKPATH TRACE TO  *
.* THE INNER VERTEX ON THE BACKPATH FROM THE SINK DETERMINED BY &P, &C*
.* AND THE PATH BYTE SUCH THAT THE SEMILATTICE VALUE AT THE INNER     *
.* VERTEX IS THE VALUE ASSOCIATED WITH THE DESIGNATED SINK.           *
.*--------------------------------------------------------------------*
.* &RL IS A TEMPORARY REGISTER TO HOLD THE CONSTANT X'04', USED FOR   *
.* SELECTING LEFT OR RIGHT EDGE FIELDS BY ANDING IT WITH THE RL BIT   *
.* AND INDEXING TO THE CORRECT EDGE FIELD FOR TRACING THE BACKPATH.   *
.* IF &RL IS LEFT OUT, IT MUST BE LEFT OUT IN THE OTHER MACROS TOO.   *
.* &TMP IS A WORKING REGISTER TO HOLD THE WORD CONTAINING THE RL BIT  *
.* FROM THE SUCCESSOR OF THE CURRENT VERTEX &C WHILE BACK TRACING.    *
.* &TMP IS USED TO LINE UP THE RL BIT WITH THE Q-BIT IN C'S FLAG      *
.* FIELD, AND TO COMPARE THESE TWO BITS VIA THE BQEQRL MACRO.         *
.* &PATH IS THE WORD CONTAINING THE PATH BYTE IN IT'S LEFT BYTE.      *
.* &MASK IS A WORKING REGISTER USED TO HOLD THE CONSTANT X'08000000'  *
.* THAT IS NEEDED FOR MASKING OUT ALL THE BITS EXCEPT THE Q-BIT.      *
.* &MASK IS ALSO SPECIFIED IN THE BQEQRL MACRO.                       *
.*--------------------------------------------------------------------*
.* THIS MACRO LEAVES THE REGISTERS ALL SET UP TO EXECUTE THE MACRO    *
.* BQEQRL NEXT. NOTE THAT THIS MACRO SHOULD NOT BE USED UNLESS THERE  *
.* ARE AT LEAST TWO SINKS IN THE TREE AND THE REGISTERS P AND C HAVE  *
.* THEIR HIGH ORDER BYTES BOTH ZERO.                                  *
.*--------------------------------------------------------------------*
         AIF   (K'&TAG EQ 0).SKIPTAG
&TAG     EQU   *
.SKIPTAG ANOP
         AIF   (K'&RL EQ 0).SKIP0  GO IF &RL IS NOT CODED.
         LA    &RL(1),RL  SET THE RL MASK FOR ANDING RL BITS.
.SKIP0   ANOP
&R       SETC  ''   SET &R TO THE EMPTY VECTOR.
         AIF   ('&PATH'(1,1) NE '(').SKIP2  GO IF PATH IS NOT IN GPR.
&R       SETC  'R'  SET TO "R" FOR LR INSTRUCTION.
.SKIP2   L&R &TMP(1),&PATH(1)  LOAD PATH IN REGISTER.
         SLL   &TMP,RL/2  CAUSE THE LOW ORDER BIT OF PATH TO LINE UP.
.FIN     ANOP
         MEND
         MACRO
&TAG     BQEQRL &TMP,&C,&MASK=,&JUMP=
         LCLC  &R,&CC
         LCLA  &K        CHARACTER COUNT.
.* THIS MACRO COMPARES THE RL-BIT IN REGISTER &TMP WITH THE Q-BIT IN  *
.* THE FLAG FIELD AT THE VERTEX &C, AND BRANCHES ON THE RESULT IF     *
.* &JUMP IS SPECIFIED. IF &JUMP IS NOT CODED, THEN THE CONDITION CODE *
.* IS SET TO 00 IF THEY ARE EQUAL.                                    *
.* &MASK SPECIFIES EITHER A MAIN STORAGE LOCATION CONTAINING THE MASK *
.* X'08000000' OR A REGISTER CONTAINING IT. IF &MASK IS NOT CODED A   *
.* REFERENCE TO THE APPROPRIATE LITERAL IS GENERATED.                 *
         AIF   (K'&MASK NE 0).SKIP0  GO IF &MASK IS CODED.
&R       SETC  '=XL4''0800000000'''
&TAG     BQEQRL &TMP,&C,MASK=&R,JUMP=&JUMP
         AGO   .FIN
.SKIP0   ANOP
&TAG     ALR   &TMP,&TMP  CAUSE THE RL BIT TO LINE UP WITH Q-BIT.
         X     &TMP,FLAGS(O,&C)  COMPARE BY EXCLUSIVE-ORING.
.*--------------------------------------------------------------------*
&R       SETC  ''  SET &R TO THE EMPTY VECTOR IF &MASK IS NOT A REG.
         AIF   ('&MASK'(1,1) NE '(').SKIP1  GO IF &MASK NOT A GPR.
&R       SETC  'R'  SET &R TO AN R FOR AN NR INSTRUCTION.
.SKIP1   N&R &TMP,&MASK(1)  ZERO OUT ALL OTHER BIT POSITIONS.
         AIF   (K'&JUMP EQ 0).FIN  FINISHED IF &JUMP NOT CODED.
&CC      SETC  '8'  PREPARE TO BRANCH IF THEY ARE EQUAL.
&R       SETC  '&JUMP'  GET THE BRANCH ADDRESS.
&K       SETA  (K'&JUMP)
         AIF   ('&JUMP'(1,1) NE '^').SKIP2  GO IF NOT NOT JUMP.
&CC      SETC  '7'  PREPARE TO BRANCH IF THEY ARE NOT EQUAL.
&R       SETC  '&JUMP'(2,K'&JUMP-1)  DISCARD THE ^ SIGN.
&K       SETA  (&K-1)
.SKIP2   AIF   ('&R'(1,1) EQ '(').SKIP3  GO IF &JUMP IS IN A GPR.
         BC    &CC,&R  BRANCH ON THE RESULT OF THE COMPARE.
         AGO   .FIN
.SKIP3   ANOP
&R       SETC  '&R'(2,&K-2)    DISCARD THE PARENTHESIS.
         BCR   &CC,&R  BRANCH ON THE RESULT OF THE COMPARE.
.FIN     ANOP
         MEND
         MACRO
&TAG     LTRBP &P,&C,&S,&RL=,&TMP=0
.* THIS MACRO ENABLES CONTINUATION AFTER THE BQEQRL MACRO TO LOAD THE *
.* WORD CONTAINING THE FLAG BYTE FIELD FROM VERTEX &C INTO &TMP, AND  *
.* TRACE THE BACKPATH ONE EDGE VIA BP.                                *
&TAG     L     &TMP,FLAGS(O,&C)  LOAD THE WORD WITH THE RL BIT IN IT.
         TRBP  &P,&C,&S,RL=&RL,CLEAR=YES
         MEND
         MACRO
&TAG     BQ0   &V,&JUMP
&TAG     TM    FLAGS(&V),IGAQBIT  TEST THE Q-BIT, AND
         BC    8,&JUMP       BRANCH IF IT IS A ZERO.
         MEND
         MACRO
&TAG     BQ1   &V,&JUMP
&TAG     TM    FLAGS(&V),IGAQBIT  TEST THE Q-BIT,
         BC    1,&JUMP   AND BRANCH IF IT IS A ONE.
         MEND
         MACRO
&TAG     COLLECT
         GBLB  &EXOR
         GBLB  &SUB
         GBLB  &PAIRING
.**********************************************************************
&TAG     DS    0H
         AIF   (&PAIRING).LW0
FLAGS    EQU   4
         AGO   .LW1
.LW0     ANOP
FLAGS    EQU   1
IVTM     TM    *+1,B'1111011'  TEST THE EVEN OR ODDNESS OF THE ADDRESS.
.LW1     ANOP
         MEND
         MACRO
&TAG     BIV0  &V,&JUMP
         GBLB  &PAIRING
         GBLB  &SUB
         GBLB  &EXOR
.**********************************************************************
         AIF   (&PAIRING).LW0
&TAG     TM    FLAGS(&V),RL
         BC    8,&JUMP
         AGO   .LW1
.LW0     ANOP
&TAG     EX    &V,IVTM   TM *+1,B'11111011'
         BC    1,&JUMP
.LW1     ANOP
         MEND
         MACRO
&TAG     BIV1  &V,&JUMP
         GBLB  &EXOR
         GBLB  &SUB
         GBLB  &PAIRING
.**********************************************************************
         AIF   (&PAIRING).LW0
&TAG     TM    FLAGS(&V),RL
         BC    1,&JUMP
         AGO   .LW1
.LW0     ANOP
&TAG     EX    &V,IVTM   TM *+1,B'11111011'
         BC    14,&JUMP
.LW1     ANOP
         MEND
         MACRO
&TAG     G0ES  &P,&C,&S
         GBLB  &EXOR
         GBLB  &SUB
         GBLB  &PAIRING
         GBLB  &SEI
.**********************************************************************
         AIF   (K'&TAG EQ 0).SKIP
&TAG     EQU   *
.SKIP    ANOP
         AIF   (&SEI).LW0
         L     &S,LEF(0,&C)
         LA    &S,0(0,&S)
         AGO   .END
.LW0     AIF   (&EXOR).LWX
         AIF   (&SUB).LWS
         MNOTE 12,'NO EDGE REPRESENTATION SPECIFIED.'
         AGO   .END
.LWX     AIF   ('&P' EQ '&S').LWX0
         LR    &S,&P
.LWX0    X     &S,LEF(0,&C)
         LA    &S,0(0,&S)
         AGO   .END
.LWS     AIF  ('&P' EQ '&S').LWS0
         LR    &S,&P
.LWS0    AL    &S,LEF(0,&C)
         LA    &S,0(0,&S)
         AGO   .END
.END     ANOP
         MEND
         MACRO
&TAG     G1ES  &P,&C,&S
         GBLB  &SUB
         GBLB  &SEI
         GBLB  &PAIRING
         GBLB  &EXOR
.**********************************************************************
         AIF   (K'&TAG EQ 0).SKIP
&TAG     EQU   *
.SKIP    ANOP
         AIF   (&SEI).LW0
         L     &S,RGHT(0,&C)
         LA    &S,0(0,&S)
         AGO   .END
.LW0     AIF   (&EXOR).LWX
         AIF   (&SUB).LWS
         MNOTE 12,'NO EDGE REPRESENTATION SPECIFIED.'
         AGO   .END
.LWX     AIF   ('&P' EQ '&S').LWX0
         LR    &S,&P
.LWX0    X     &S,RGHT(0,&C)
         LA    &S,0(0,&S)
         AGO   .END
.LWS     AIF  ('&P' EQ '&S').LWS0
         LR    &S,&P
.LWS0    AL    &S,RGHT(0,&C)
         LA    &S,0(0,&S)
         AGO   .END
.END     ANOP
         MEND
         MACRO
         SCNRFIN
.**********************************************************************
         LM    A,B,GPR2        RESTORE THE REGISTERS.
         BCR   15,LKR    RETURN
         MEND
         MACRO
&TAG     TSTBT &A,&ZERO=,&ONE=
         GBLB  &BIGMASK
.**********************************************************************
&TAG     IC    ZX,BYTEI(0,&A)
         IC    TMP,0(ZX,ADR)  GET THE VALUE OF THE ARGUMENT BYTE.
         IC    ZX,FLAGS(0,&A)
         AIF   (&BIGMASK).BIGMASK  IF BIG TABLE IS USED SKIP THE SRL.
         SRL   ZX,5            SHIFT RIGHT FOR A 3-BIT INDEX.
.BIGMASK ANOP
         IC    ZX,MSKTBL(ZX)  GET THE MASK TO TEST THE BIT BY ANDING.
         NR    TMP,ZX      TEST THE BIT IN THE SEARCH ARGUMENT.
         AIF   (K'&ONE EQ 0).LW0
         BC    7,&ONE
.LW0     AIF   (K'&ZERO EQ 0).LW1
         BC    8,&ZERO
.LW1     ANOP
.END     ANOP
         MEND
         MACRO
         SNAPR
         GBLB  &SNAPXT
         GBLB  &TEST
.**********************************************************************
         AIF   (NOT(&TEST)).FIN
         AIF   (&SNAPXT).LW0
&SNAPXT  SETB  (1)
.LW0     ANOP
SNAP&SYSNDX EQU *
         STM   14,15,SNS&SYSNDX
         CNOP  2,4
         ICALL SNAP
         DC    AL4(&SYSNDX)
SNS&SYSNDX DC CL8'SAVE1415'
         L     14,SNS&SYSNDX
.FIN     ANOP
         MEND
         MACRO
&TAG     GSNAP
.**********************************************************************
         MEND
         MACRO
&TAG     SNIP
         GBLB  &SNIP,&SNARF
         LCLA  &A,&B
         AIF   (NOT(&SNIP)).FIN
SNAP&SYSNDX EQU *  PROVIDE A REFERENCE NUMBER FOR THE SNAPS.
         AIF   (&SNARF).LW1
&SNARF   SETB  (1)
.LW1     ANOP
&TAG     STM   14,15,SNS&SYSNDX
         CNOP  0,4
         L     15,=AL4(SNAPPY)
         BALR  14,15
&A       SETA  (&SYSNDX)
&B       SETA  (&A-10*(&A/10)+16*((&A/10)-10*(&A/100)))
&B       SETA  (&B+256*((&A/100)-10*(&A/1000)))
         DC    AL2(&B)
SNS&SYSNDX DC CL8'SAVE1415'
         DC    XL4'98EFE002'
.FIN     ANOP
         MEND
         MACRO
&TAG  GODOWNTO &A
         GBLC  &IGANAME  THE NAME OF THE MODULE.
DOWN&SYSNDX EQU *-&IGANAME  OFFSET FROM THE START OF THE MODULE.
         AIF   ('&A' NE 'SPACE').SKIP  SEE IF THIS IS JUST TO LEAVE    *
                         SOME LEBENSRAUM.
UP&SYSNDX EQU  (X'20'*((DOWN&SYSNDX+X'1F')/X'20')-DOWN&SYSNDX)
         DC    (UP&SYSNDX+16-16*((2*(UP&SYSNDX/X'10'))/(1+(UP&SYSNDX/X'*
               10'))))XL1'FF'
         AIF   (K'&TAG EQ 0).FIN  SEE IF THERE IS A LABEL ON THE       *
                         MACRO-INSTRUCTION.
&TAG     EQU   *         PROVIDE A LABEL FOR REFERENCE.
         AGO   .FIN      NOW EXIT, IT IS ALL DONE.
.SKIP    ANOP
.**********************************************************************
.* THE FOLLOWING DC STATEMENT GENERATESA BIT PATTERN OF ALL ONES TO   *
.* FILL UP THE SPACE BETWEEN THE CURRENT SETTING OF THE LOCATION      *
.* COUNTER AND THE OFFSET &A INTO THE MODULE. THE EXPRESSION          *
.* "(&A-DOWN&SYSNDX)" PROVIDES THE NUMBER OF BYTES TO BE FILLED WITH  *
.* ONES, BUT IF THE CURRENT LOCATION COUNTER ALREADY EXCEEDS THE      *
.* OFFSET &A THEN THE VALUE OF THE EXPRESSION IS NEGATIVE, WHICH      *
.* CAUSES THE ASSEMBLER PROGRAM TO ABNORMALLY TERMIATE WITH A SYSTEM  *
.* COMPLETION CODE OF B37 BY RUNNING OUT OF DISK WORK SPACE.          *
.*                                                                    *
.* THEREFORE, TO PREVENT THIS CONDITION, AN ADJUSTMENT IS MADE TO THE *
.* DUPLICATION FACTOR EXPRESSION TO MAKE IT ZERO IF THE CONDITION     *
.* ARISES. THE ADJUSTMENT FOLLOWS FROM THE FOLLOWING REASONING:       *
.*                                                                    *
.*   (0) LET X=(&A-DOWN&SYSNX), SO THAT X IS THE NUMBER OF BYTES TO   *
.*       FILL WITH ONES.                                              *
.*   (1) LET Y BE ANY POSITIVE CONSTANT SO THAT THE ABSOLUTE VALUE OF *
.*       X IS LESS THAN Y.                                            *
.*   (2) THEN THE VALUE OF THE EXPRESSION "((X+Y)/Y)" IS 1 IF X IS NOT*
.*       NEGATIVE, OR IS 0 IF X IS NEGATIVE, AND THE VALUE OF THE     *
.*       EXPRESSION "((Y-(X+1))/Y)" IS 0 IF X IS NOT NEGATIVE, OR 1 IF*
.*       X IS NEGATIVE.                                               *
.*                                                                    *
.* THUS BY MULTIPLYING X BY THE EXPRESSION "((X+Y)/Y)", IF X IS       *
.* NEGATIVE THE RESULT IS ZERO, OTHERWISE THE RESULT IS EQUAL TO X.   *
.* SIMILARLY, BY MULTIPLYING SOME CONSTANT Z BY THE EXPRESSION        *
.* "((Y-(X+1))/Y)", THE RESULT IS ZERO IF X IS NON-NEGATIVE, OR THE   *
.* RESULT IS EQUAL TO Z IF X IS NEGATIVE.                             *
.*                                                                    *
.* BY PUTTING THE EXPRESSION "(X*((X+Y)/Y))" IN THE DUPLICATION FACTOR*
.* OF THE DC STATEMENT, IF X IS NEGATIVE THE DUPLICATION FACTOR IS    *
.* ZERO, WHICH RESERVES NO SPACE AND DOES NOT CAUSE AN ASSEMLER ERROR.*
.* THIS CORRECTS THE PROBLEM OF THE ASSEMBLER PROGRAM ABENDING, BUT IT*
.* DOESN'T FLAG THE STATEMENT AS AN ERROR IN THE LISTING. TO FLAG THE *
.* STATEMENT AS AN ERROR, THE EXPRESSION "((X+Y)/Y)" IS SUBSTITUTED   *
.* FOR THE "1" OF THE "AL1" IN THE STATEMENT, SO THAT IF X IS NOT     *
.* NEGATIVE THE VALUE IS 1, BUT IF X IS NEGATIVE THE VALUE IS 0, AND  *
.* "AL0" IS INVALID FOR THE DC STATEMENT, FLAGGINF THE STATEMENT AS AN*
.* ERROR IN THE LISTING.                                              *
.*                                                                    *
.* THIS IS JUST ONE WAY TO CIRCUMVENT THE ARBITRARY LIMITATIONS OF THE*
.* ASSEMBLER LANGUAGE.                                                *
.**********************************************************************
         DC    ((((&A-DOWN&SYSNDX)+X'1000')/X'1000')*(&A-DOWN&SYSNDX))A*
               L(((&A-DOWN&SYSNDX)+X'1000')/X'1000')(X'FF')
         AIF   (K'&TAG EQ 0).FIN       SEE IF THE LABEL IS NOT CODED.
&TAG     EQU   *
.FIN     ANOP
         MEND
         EJECT
         GBLC  &IGABLST  THE OFFSET INTO THE TREE HEADER FOR THE LIST  *
                         OF RPT ENTRY POINTS.
         GBLC  &IGABFIN  THE SIZE OF THE RESERVED LIST OF ENTRY POINT  *
                         ADDRESSES IN THE TREE HEADER.
         GBLC  &IGASCH8  THE OFFSET IN THE RPT MODULE FOR THE TYPE 8   *
                         SEARCH ROUTINE.
         GBLC  &IGAGKW   THE OFFSET IN THE IGARPT01 MODULE TO THE      *
                         ROUTINE TO GET A WORK AREA FOR COLLECTING     *
                         KEYS.
         GBLC  &IGADEL8  THE OFFSET IN THE IGARPT01 MODULE TO THE TYPE *
                         8 RPT DELETE ROUTINE.
         GBLC  &IGAINS8  THE OFFSET IN THE MODULE IGARPT01 TO THE      *
                         ROUTINE TO INSERT IN A TYPE 8 RPT.
         GBLC  &IGALSCN  THE OFFSET TO THE ROUTINE TO SCAN LEFT IN THE *
                         MODULE IGARPT01.
         GBLC  &IGARSCN  THE OFFSET TO THE ROUTINE TO SCAN RIGHT IN THE*
                         MODULE IGARPT01.
         GBLC  &IGASPV   THE OFFSET TO THE PARTIAL ORDER SEARCH ROUTINE*
                         IN THE MODULE IGARPT01.
         GBLC  &IGAPVG   THE OFFSET TO THE ROUTINE TO GET THE PARTIAL  *
                         ORDER VALUE FOR THE CURRENT SINK IN THE MODULE*
                         IGARPT01.
         GBLC  &IGAPVAJ   THE OFFSET TO THE ROUTINE TO ADJUST THE      *
                         PARTIAL ORDER VALUE FOR THE CURRENT SINK IN   *
                         THE IGARPT01 MODULE.
         GBLC  &IGADSP8  THE OFFSET TO THE ROUTINE TO DISPLAY A TYPE 8 *
                         RPT IN THE MODULE IGARPT01.
         GBLC  &IGASRCH  THE BRANCH ENTRY OFFSET FOR SEARCH OF A TYPE 8*
                         RPT IN THE MODULE IGARPT01.
         GBLC  &IGAKEYW  THE INDEX OF THE ADDRESS OF THE ROUTINE TO GET*
                         A WORK AREA FOR COLLECTING KEYS FOR SEARCH.
         GBLC  &IGAINS   THE BRANCH ENTRY OFFSET FOR INSERTION INTO A  *
                         TYPE 8 RPT.
         GBLC  &IGADEL   THE BRANCH ENTRY OFFSET FOR A DELETION        *
                         OPERATION FOR A TYPE 8 RPT.
         GBLC  &IGAFTRE  THE BRANCH ENTRY OFFSET FOR FTREE.
         GBLC  &IGASCNL  BRANCH ENTRY OFFSET FOR THE SCAN LEFT         *
                         OPERATION FOR TYPE 8 RPT.
         GBLC  &IGASCNR  BRANCH ENTRY OFFSET FOR THE SCAN RIGHT        *
                         OPERATION FOR TYPE 8 RPT.
         GBLC  &IGASTRE,&IGAINS5,&IGADEL5
         GBLC  &IGADJPV        ENTRY OFFSET FOR ADJUSTING THE PARTIAL
**                             ORDER VALUE ASSOCIATED WITH A SINK.
         GBLC  &IGAPVS         BRANCH ENTRY OFFSET TO FIND A SINK WITH
**                             A PARTIAL ORDER VALUE THAT IS NOT LESS
**                             THAN THE VALUE IN REQL (GPR 0).
**                             THE EOP STATE IS SET TO THE SINK SO
**                             DETERMINED, AND THE VALUE IS STORED IN
**                             THE TREEHDR AT IGAVALUE.
**                             THE SINK WORD IS RETURNED IN GPR 15 AS
**                             THE RETURN CODE, UNLESS THERE DOES NOT
**                             EXIST A SINK WITH A POV LARGER THAN OR
**                             EQUAL TO THE VALUE IN GPR 0. IN THIS
**                             CASE A NEGATIVE NUMBER IS RETURNED IN
**                             GPR 15.
         GBLC  &IGAGPV         BRANCH ENTRY OFFSET TO GET THE PARTIAL
**                             ORDER VALUE ASSOCIATED WITH THE SINK
**                             CURRENTLY SELECTED BY THE EOP STATE.
**                             THE VALUE IS RETURNED IN GPR 0.
         GBLC  &IGANAME        THE NAME OF THE RPT PROGRAM.
         GBLC  &IGADSP         BRANCH ENTRY OFFSET FOR DSPRPT.
         GBLC  &IGAISP   BRANCH ENTRY OFFSET TO SET UP A SPACE CONTROL
*                        AREA FOR AN ARBITRARY SUBPOOL.
         GBLC  &IGAFRSC  BRANCH ENTRY OFFSET TO THE ROUTINE TO RELEASE *
                         A SPACE CONTROL AREA AND ALL OF ITS RELATED   *
                         SPACE VIA THE FREEMAIN MACRO-INSTRUCTION.
         GBLC  &IGASPZ   THE SIZE OF THE SPACE CONTROL AREA.
         GBLC  &IGASA0   THE OFFSET TO THE SAVE AREA IN THE SPACE      *
                         CONTROL AREA.
         GBLC  &IGASA1   OFFSET TO THE SECOND SAVE AREA IN THE SPACE   *
                         CONTROL AREA.
         GBLC  &IGAFSP   THIS IS THE BRANCH ENTRY OFFSET FOR THE       *
                         VARIABLE LENGTH FSPACE WHEN THE SPACE CONTROL *
                         ADDRESS IS NOT CODED IN THE FSPACE MACRO.
         GBLC  &IGAFSPS  BRANCH ENTRY OFFSET FOR VARIABLE LENGTH FSPACE*
                         WHEN THE SPACE CONTROL ADDRESS IS CODED IN THE*
                         FSPACE MACRO.
         GBLC  &IGAFS8,&IGAFS12,&IGAFS80  THE ENTRY POINTS TO RELEASE  *
               ENTRIES OF THE RESPECTIVE LENGTHS USING THE FIXEDHDR IN *
               A SPACE CONTROL AREA.
         GBLC  &IGAFSPF  THE BRANCH ENTRY OFFSET TO RELEASE A FIXED    *
                         LENGTH ENTRY USING A FIXEDHDR.
         GBLC  &IGAGSP   BRANCH ENTRY OFFSET FOR THE VARIABLE LENGTH   *
                         GSPACE WHEN THE SPACE CONTROL ADDRESS IS NOT  *
                         CODED IN THE GSPACE MACRO-INSTRUCTION.
         GBLC  &IGAGSPS  BRANCH ENTRY OFFSET FOR VARIABLE LENGTH SPACE *
                         ALLOCATION WHEN THE SPACE CONTROL ADDRESS IS  *
                         CODED IN THE GSPACE MACRO-INSTRUCTION.
         GBLC  &IGAGS8,&IGAGS12,&IGAGS80  THE BRANCH ENTRY OFFSETS FOR *
                         THE ROUTINES TO ALLOCATE SPACE FOR THE        *
                         RESPECTIVE FIXED LENGTHS IN A SPACE CONTROL A.
         GBLC  &IGAGSPF  BRANCH ENTRY OFFSET FOR FIXED LENGTH ENTRIES  *
                         USING A FIXEDHDR FROM THE GSPACE MACRO OR FROM*
                         INSIDE THE MODULE IGARPT01.
         GBLC  &IGAS8    THE OFFSET FROM THE FIRST BYTE OF THE SPACE   *
                         CONTROL AREA TO THE FIXEDHDR FOR              *
                         8-BYTE ENTRIES.
         GBLC  &IGAS12   THE OFFSET FROM THE FIRST BYTE OF THE SPACE   *
                         CONTROL AREA TO THE FIXEDHDR FOR              *
                         12-BYTE ENTRIES.
         GBLC  &IGAS80   THE OFFSET FROM THE FIRST BYTE OF THE SPACE   *
                         CONTROL AREA TO THE FIXEDHDR FOR              *
                         80-BYTE ENTRIES.
         GBLC  &IGACON   THE OFFSET TO THE CONTANT AREA.
         GBLC  &IGADDR   THIS IS THE OFFSET PAST THE BEGINNING OF THE  *
                         TREEHDR TO FIND THE ADDRESS OF THE MODULE     *
                         IGARPT01.
         GBLB  &IGALONE  ON FOR DIAGNOSTIC CHECKOUT FOR STANDALONE UNIT*
                         TESTING.
         GBLB  &SNIP
         GBLB  &TEST
         GBLB  &EXOR
         GBLB  &PAIRING
         GBLB  &EDGE3
         GBLB  &EDGE2
         GBLB  &SEI
         GBLB  &ESS
         GBLB  &IGAVS2,&IGADIAG
         GBLB  &SUB
         GBLB  &NOCBIT
         GBLB  &CBIT  ONE IF THE C0 AND C1 FLAGS ARE FLAGS FOR THE
*                     LEFT AND RIGHT SUBTREES, ZERO IF NOT.
         GBLB  &BIGMASK  SET THIS TO ONE IF THERE IS ENOUGH SPACE FOR
         GBLB  &SNAP
         GBLB  &IGASPIE        ON FOR SPIE BRANCH TRACE.
         GBLB  &IGAPGM  THIS IS SO THAT RPTDSECT GENERATES THE SHORTS.
         LCLC  &X        JUST A TEMPORARY VARIABLE FOR GENERATING      *
               EXTREMELY COMPLICATED EXPRESSIONS WITH TOO LONG LABELS.
         LCLC  &Y,&Z     HERE ARE TWO MORE OF THE SAME KIND OF LOCAL   *
                         TEMPORARIES.
         LCLB  &CEDG
         LCLC  &PROGRAM
*A000000-999998                                                  Y02147
IGARPT01 CSECT
&PROGRAM SETC  'IGARPT01'
&TEST    SETB  (0)
&CEDG    SETB  (0)
&EXOR    SETB  (1)
&SUB     SETB  (0)
&PAIRING SETB  (0)
&EDGE3   SETB  (1)
&EDGE2   SETB  (0)
&SEI     SETB  (1)
&ESS     SETB  (0)
&CBIT    SETB  (0)  DON'T COPY C-BITS.
&NOCBIT  SETB  (0)
&BIGMASK SETB  (0)  USE THE LITTLE MASK TABLE FOR NOW.
&SNIP    SETB  (0)
         EJECT
***********************************************************************
* THE FOLLOWING ARE THE INTERPRETATIONS OF THE VALUES OF THE PATH BYTE:
P0000    EQU 0   A PATH BYTE CONTAINING FOUR LOW ORDER ZERO BITS MEANS*
*                THAT THERE ARE ZERO SINKS IN THE TREE.               *
P0001    EQU 1   0001 MEANS THERE IS ONE SINK, AND THE CURRENT PATH   *
*                SETTING ENDS WITH IT AS THE LAST VERTEX ON IT.       *
P0010    EQU 2   THIS IS AN UNUSED SETTING.                           *
P0011    EQU 3   THERE IS ONE SINK, AND THE CURRENT PATH IS AN        *
*                IMAGINARY PATH, SO THAT THE FIRST SINK TO THE RIGHT  *
*                OF THE IMAGINARY SINK IS THE SINGLE SINK PRESENT.    *
*                THERE ARE SEVERAL WAYS THIS PATH CODE CAN ARISE.     *
*                ONE WAY IS FOR A DELETE TO DELETE THE INNER VERTEX IN*
*                A TREE WITH EXACTLY TWO SINKS, WHERE THE SINK        *
*                REMAINING IS THE RIGHT SUCCESSOR OF THE MORIBUND     *
*                INNER VERTEX. THIS IS DONE SO THAT A SCANR AFTER A   *
*                DELETE WILL FIND THE FIRST SINK THAT WAS TO THE RIGHT*
*                OF THE DELETED SINK.                                 *
*                                                                     *
P0100    EQU 4   THIS CODE IS NOT USED.                               *
*                                                                     *
P0101    EQU   5   THERE IS EXACTLY ONE SINK AND THE IMAGINARY PATH   *
*                  GOES TO THE RIGHT OF IT.                           *
*                                                                     *
P0110    EQU   6   THERE ARE ZERO SINKS AND ISCAN HAS BEEN EXECUTED.  *
*                                                                     *
P0111    EQU   7   THERE IS EXACTLY ONE SINK AND ISCAN HAS BEEN DONE. *
*---------------------------------------------------------------------*
* NOTE THAT IN ALL OF THE ABOVE CASES IF BOTH THE FIRST AND LAST BITS *
* OF THE FOUR-BIT CODE ARE ZERO THEN THERE ARE ZERO SINK; IF THE      *
* FIRST BIT IS A ZERO AND THE LAST BIT IS ONE THEN THERE IS EXACTLY   *
* ONE SINK; AND IF THE TWO MIDDLE BITS ARE BOTH ONE THEN ISCAN HAS    *
* BEEN EXECUTED. THIS ALLOWS INITIALIZATION FOR SCANNING IN EITHER    *
* DIRECTION TO BE ACCOMPLISHED BY ORING B'00000110' TO THE PATH BYTE. *
         EJECT
***********************************************************************
* IN ALL OF THE FOLLOWING CASES THE NUMBER OF SINKS IS AT LEAST TWO,  *
* WHICH IS REPRESENTED BY THE FIRST BIT BEING A ONE. SIMILARLY, IN    *
* THE FOLLOWING CODES THE EXECUTION OF ISCAN IS REPRESENTED BY BOTH   *
* THE MIDDLE TWO BITS BEING ONES.                                     *
*                                                                     *
* IN ALL OF THE FOLLOWING CASES IF THE LAST BIT IS ZERO THE SINK AT   *
* THE END OF CURRENT PATH IS A LEFT SUCCESSOR, AND IF THE LAST BIT    *
* IS ONE THEN THE SINK AT THE END OF THE CURRENT PATH IS A RIGHT      *
* SUCCESSOR.                                                          *
*                                                                     *
* IN THE FOLLOWING DIAGRAMS P, C, AND S ARE THE VERTICES ON THE CURRENT
* PATH SETTING, AND X IS THE INNER VERTEX DELETED BY THE DELETE ROUTINE
* WHEREAS Z IS THE SINK THAT WAS DELETED. THE TREES SHOWN WITH X AND Z
* SHOW THE GRAPH BEFORE THE DELETE OCCURRED. THE REAL EDGES IN THE    *
* TREE ARE DEPICTED WITH  BARS  , WHILE THE FORMER EDGES ARE SHOWN    *
* WITH  PERIODS.  SINCE THE EDGES SHOWN WITH  PERIODS  ARE NO LONGER  *
* PRESENT, BUT THEIR FORMER REALITY LINGERS IN THE PATH CODE, THESE   *
* EDGES ARE REFERRED TO AS "CAT'S EDGES" IN THE COMMENTS.             *
* SIMILARLY, THE VERTEX Z IS OF SUCH IMAGINARY NATURE, AS WELL AS X.  *
* R IS THE VERTEX THAT SHARES THE SAME PREDECESSOR WITH S.            *
* IN THE FOLLING CODES IF THE VERTEX Z IS A LEFT SUCCESSOR OF X THEN  *
* THEN THE PENULTIMATE BIT IS ZERO, BUT IF Z IS A RIGHT SUCCESSOR     *
* THEN THE PENULTIMATE BIT OF THE PATH CODE IS A ONE.                 *
*        P1000   *   P1001      *     P1010   *   P1011      *
*                *              *             *              *
*          P     *     P        *       P     *     P        *
*               *             *            *             *
*    Z..X--C--R  *  R--C--X--S  * S--X--C--R  *  R--C--X..Z  *
*               *        .     *    .        *             *
*               *        .     *    .        *             *
*       S        *        Z     *    Z        *        S     *
*                *              *             *              *
***********************************************************************
         RASS  (P1000,B'1000',P1001,B'1001',P1010,B'1010',P1011,X'B')
***********************************************************************
*                *           *
*        P1100   *   P1101   *
*                *           *
*          P     *     P     *
*               *          *
*       S--C--R  *  R--C--S  *
*                *           *
         RASS   (P1100,B'1100',P1101,B'1101')
***********************************************************************
*    THE CODES P1110 AND P1111 MEAN THAT ISCAN HAS BEEN EXECUTED.
         RASS   (P1110,B'1110',P1111,B'1111')
***********************************************************************
LEF      EQU   0
RGHT     EQU   4
         RASS  (R0,0,R1,1,R2,2,R3,3,R4,4,R5,5,R6,6,R7,7,R8,8)
         RASS  (R9,9,R10,10,R11,11,R12,12,R13,13,R14,14,R15,15)
         RASS (TMP7,0,TMP8,1,LNG,11,E0,0,E1,1,I,2,NEW,3,P,4,VX,P,C,5,  X
               VY,C)
         RASS  (O,0,ALT,7,TAX,2,PAX,3)
         RASS  (PR,2,CR,3,SR,4)
         RASS  (S,6,FOR,6,RRL,7,SAR,8,TMP1,8,TMP2,8,TMP3,8,TMP4,8)
         RASS  (TMP5,8,TMP0,9,BIT,9,FAR,10,TMP6,10,VZ,11,PLA,12)
BYTEI    EQU   0   INDEX IN INNER VERTEX TO BYTE INDEX.
         RASS  (ONE,1,TWO,2,THREE,3,FOUR,4,FIVE,5,SIX,6,SEVEN,7,       X
               EIGHT,8,NINE,9,TEN,10,ELEVEN,11,TWELVE,12,THIRTEEN,13,  X
               FOURTEEN,14,FIFTEEN,15,SIXTEEN,16)
         RASS  (EIGHTY,X'50')
TWENTY4  EQU   24        JUST XXIV.
SAVEDSEK DSECT 0                REGISTER SAVE AREA DSECT.
SPACEWRD DC    F'0'  THIS IS THE TREE ADDRESS IF THE GSPCE/FSPACE
*                    STORAGE MANAGEMENT OPTION IS CHOSEN.
BACKEDGE DC    F'0'  EDGE FIELD FOR THE BACK CHAIN SAVE AREA.
BACKWARD EQU   BACKEDGE  USE THE SAME WORD FOR BOTH LABELS.
BACKWORD EQU   BACKWARD  USE ALL THREE LABELS FOR THE SAME THING.
FORWARD  DC    F'0'      EDGE FIELD FOR THE FORWARD EDGE IN THE REGISTER
                         SAVE AREA CHAIN.
GPR14    DC    F'0'  SAVE AREA FOR THE LINKAGE REGISTER, GPR14.
GPR15    DC    F'0'  SAVE AREA FOR GPR15.
GPR0     DC    F'0'  SAVE AREA FOR GPR0.
GPR1     DC    F'0'  SAVE AREA FOR GPR1.
GPR2     DC    F'0'  SAVE AREA FOR GPR2.
GPR3     DC    F'0'  SAVE AREA FOR GPR3.
GPR4     DC    F'0'  SAVE AREA FOR GPR4.
GPR5     DC    F'0'  SAVE AREA FOR GPR5.
GPR6     DC    F'0'  SAVE AREA FOR GPR6.
GPR7     DC    F'0'  SAVE AREA FOR GPR7.
GPR8     DC    F'0'  SAVE AREA FOR GPR8.
GPR9     DC    F'0'  SAVE AREA FOR GPR9.
GPR10    DC    F'0'  SAVE AREA FOR GPR10.
GPR11    DC    F'0'  SAVE AREA FOR GPR11.
GPR12    DC    F'0'  SAVE AREA FOR GPR12.
GPR13    DC    F'0'  SAVE AREA FOR GPR13.
IGAIARG  EQU   GPR0  THIS IS THE NEW SINK ADDRESS FOR INSERT.
INSARG   EQU   IGAIARG
SAVEFIN  EQU   *         THE END OF THE SAVE AREA.
&PROGRAM CSECT
         EJECT
&IGAPGM  SETB  (1)       GET THE SHORT LABELS.
      RPTDSECT T=5,DS=YES
DEADSINK EQU   IGAMASKS  DEAD SINK CONSTANT FOR TYPE 5 TREES, 80000000.
      RPTDSECT T=8,DS=YES
      RPTDSECT T=SPACE,DS=YES
         EJECT
      GODOWNTO &IGASCH8
IGASRCH8 EQU   *
SRCH8    EQU   *
*******************************************************************
*    S U B R O U T I N E  S R C H 8                               *
*******************************************************************
*
*                                                                     *
* UPON ENTRY TO THE SEARCH ROUTINE FOR TYPE 8 RADIX PARTITION TREES,  *
* THE REGISTERS HAVE THE FOLLOWING CONTENTS:                          *
*  R0:   THE ADDRESS OF THE RECORD OR AREA CONTAINING THE SEARCH KEY. *
*        THE ADDRESS OF THE SEARCH KEY IS FORMED BY ADDING THE        *
*        HALFWORD AT IGAKEYI IN THE RPT HEADER TO THE CONTENTS OF     *
*        REGISTER 0. THE KEY INDEX AT IGAKEYI IS OBTAINED FROM THE    *
*        STREE MACRO-INSTRUCTION AT THE TIME THE RPT IS FORMED, BY    *
*        MEANS OF THE K PARAMETER.                                    *
*                                                                     *
*  R1:   REGISTER 1 CONTAINS THE ADDRESS OF THE TREEHDR, AS IT IS     *
*        RETURNED TO THE USER PROGRAM FROM THE STREE                  *
*        MACRO-INSTRUCTION.                                           *
*                                                                     *
*  R13:  REGISTER 13 MUST ADDRESS A SAVE AREA THAT CAN BE USED FOR    *
*        STORING THE REGISTERS WHILE EXECUTING THE SEARCH.            *
*                                                                     *
*  LKR:REGISTER 14 CONTAINS THE RETURN ADDRESS FROM THE CALLING       *
*        PROGRAM.                                                     *
*                                                                     *
*  R15:  REGISTER 15 CONTAINS THE ADDRESS OF THE BEGINNING OF THE     *
*        MODULE IGARPT01.                                             *
*                                                                     *
*        THE RETURN CODE IS SET IN GPR 15:
*        NON-NEGATIVE:   R15 CONTAINS THE ADDRESS ASSOCIATED WITH THE *
*                        KEY FOUND BY THE SEARCH.                     *
*        NEGATIVE:       THE RPT IS EMPTY, I. E. IT DOES NOT CONTAIN  *
*                        ANY KEY-ADDRESS ASSOCIATIONS.                *
*        IN BOTH CASES THE CONDITION CODE IS EITHER SET TO 01 IF THE  *
*        RPT IS EMPTY, OR TO 00 (ZERO) IF THE SEARCH FOUND A SINK IN  *
*        A SUBTREE OF EQUALS, OR TO 11 IF THE ONE IT FOUND IS NOT IN  *
*        A SUBTREE OF EQUALS.                                         *
*
FIRSTR   EQU   0   THIS IS THE FIRST REGISTER THAT MUST BE SAVED.
SARG     EQU   0         THIS REGISTER CONTAINS THE ADDRESS OF THE     *
                         SEARCH KEY UPON ENTRY TO THE SEARCH ROUTINE.
LASTR    EQU   5  THIS IS THE LAST REGISTER THAT MUST BE SAVED.
TMP      EQU   0  THIS IS A WORKING REGISTER.
BASE     EQU   1  THIS IS THE BASE REGISTER FOR THE PARAMETER LIST.
A        EQU   2  THIS IS THE ADDRESS OF A VERTEX.
B        EQU   3  THIS IS ALSO A VERTEX ADDRESS.
ADR      EQU   4  THIS IS THE ADDRESS OF THE SEARCH ARGUMENT.
ZX       EQU   5  THIS IS A WORKING REGISTER TO TEST THE BITS.
LKR      EQU   14        LINKAGE REGISTER FOR SUBROUTINES.
         USING SRCH8,15  USE THE SAME BASE REGISTER THAT IS SET UP.
         USING TREEHDR,BASE  THIS IS THE BASE OF THE DSECT ENTRY.
         TM    PATH,P1000      START THE SEARCH WITH SRCH8A IF THERE
         BC    1,SRCH8A        ARE AT LEAST TWO SINKS.
         NI    PATH,P1001      THERE IS EITHER ONE OR ZERO SINKS.
         BC    7,SRCHFOR1  BRANCH IF THERE IS EXACTLY ONE SINK.
         LEAF  SAVE=,LV=,RC=-1
***********************************************************************
*   SEARCH SUBROUTINE.                                                *
***********************************************************************
SRCH8A   EQU   *
         STM   FIRSTR,LASTR,((X'04'*FIRSTR)+X'14'-X'40'*((X'02'+FIRSTR)-
               /X'10'))(13)  SAVE THE REGISTERS.
         SLR   ZX,ZX           ZERO OUT REGISTER FOR IC INSTRUCTION.
         AH    SARG,IGAKEYI  COMPUTE THE ADDRESS OF THE SEARCH KEY.
         LR    ADR,SARG  PUT THE ADDRESS OF THE SEARCH KEY IN ADR.
         L     A,APT  INITIALIZE A TO THE ADDRESS OF THE SOURCE.
         LR    B,A    SET B TO THE SAME INITIAL VALUE AS A.
         TSTBT A,ONE=SRCH8D    BRANCH IF ONE EDGE IS TAKEN.
SRCH8B   BT00  A,SRCH8J        BRANCH IF T0 IS ZERO.
         TLE   B,A       TRACE PATH TO LEFT SUCCESSOR OF A.
         TSTBT B,ONE=SRCH8G    TEST BIT AND BRANCH IF ONE.
SRCH8C   BT00  B,SRCH8K        BRANCH IF B'S LEFT SUCCESSOR IS A SINK.
         TLE   A,B       TRACE THE PATH TO B'S SUCCESSOR.
         TSTBT A,ZERO=SRCH8B   BRANCH TO TAKE THE LEFT EDGE.
SRCH8D  BNET10 A,SRCH8H
SRCH8E   TRE   B,A       TRACE EDGE TO A'S RIGHT SUCCESSOR.
SRCH8F   TSTBT B,ZERO=SRCH8C   BRANCH TO TAKE THE LEFT EDGE.
SRCH8G  BNET10 B,SRCH8I
         TRE   A,B       TRACE RIGHT EDGE TO B'S RIGHT SUCCESSOR.
         TSTBT A,ZERO=SRCH8B   BRANCH TO TAKE THE LEFT EDGE.
        BNET11 A,SRCH8E
SRCH8H   LR    TMP,A  EXCHANGE THE CONTENTS OF REGISTERS A AND B SO
         LR    A,B    THAT REGISTERS A AND B CONTAIN CONSECUTIVE
         LR    B,TMP  VERTICES DOWN THE PATH TO THE SINK FOUND.
***********************************************************************
* THE SITUATION AT THIS POINT IS SUMMARIZED IN THE FOLLOWING TABLE,   *
* WHICH RELATES THE POSSIBLE COMBINATIONS OF THE THREE BITS IGANEBIT, *
* T0, AND T1 AT THE VERTEX B TO THE CONDITION CODE SETTINGS, AND THE  *
* INDICATED ACTIONS ARE PERFORMED:                                    *
* IGANEBIT: T0: T1: CONDITION  MEANING AND ACTION:                    *
* --------- --- --- CODE:      -------------------                    *
*                   ---------                                         *
*    0       0   0  00         B IS IN A SUBTREE OF EQUAL KEYS, AND   *
*                              THEREFORE THE SEARCH SHOULD PROCEED    *
*                              DOWN THE PATH INTO THE LEFT SUCCESSOR  *
*                              OF VERTEX B. BY GOING TO SRCH8C BIT T0 *
*                              IS TESTED TO SEPARATE THIS CASE FROM   *
*                              THE 0 1 0 CASE DOWN BELOW.             *
*    0       0   1  01         GO TO SRCH8J TO GET A'S LEFT SUCCESSOR *
*                              FOR THE SINK ADDRESS FOUND BY SEARCH.  *
*                              THIS IS DONE BY LETTING THE TEST FOR   *
*                              BIT T0 BEING A ZERO BE PERFORMED AT    *
*                              SRCH8C.                                *
*    0       1   0  00         SEE THE DESCRIPTION OF THE FIRST CASE  *
*                              ABOVE.                                 *
*    0       1   1  01         ALSO SEE THE FIRST CASE ABOVE.         *
*    1       0   0  01         GET B'S RIGHT SUCCESSOR FOR THE SINK.  *
*    1       0   1  XX         THIS CASE IS NOT POSSIBLE.             *
*    1       1   0  01         GET B'S RIGHT SUCCESSOR FOR THE SINK.  *
*    1       1   1  XX         THIS CASE IS NOT POSSIBLE.             *
*                                                                     *
SRCH8I   TM    FLAGS(A),IGANEBIT  SEE IF B IS THE SOURCE OF A SUBTREE  *
                         OF EQUAL KEYS.
         BZ    SRCH8C    BRANCH IF IT IS ANY OF THE ABOVE FOUR CASES. *
         MVI   IGAPATH,P1101   SET THE PATH CODE TO INDICATE A RIGHT   *
                         SINK SUCCESSOR.
         LA    A,O(,A)   CLEAR THE HIGH ORDER BYTE.
         LA    B,O(,B)   CLEAR THE HIGH ORDER BYTE.
         STM   A,B,IGANTPEN  STORE THE LAST TWO INNER VERTICES ON THE  *
                         PATH TO THE SINK.
         X     A,RGHT(,B)  GET THE RIGHT SINK SUCCESSOR OF B.
         LA    R15,O(,A)  CLEAR THE HIGH ORDER BYTE.
         ST    R15,IGAFARG  STORE THE ADDRESS ASSOCIATED WITH THE KEY  *
               FOUND BY SEARCH.
         TM    *+1,B'11111111'  SET THE CONDITION CODE TO 11.
         LM    FIRSTR,LASTR,((X'04'*FIRSTR)+X'14'-X'40'*((X'02'+FIRSTR)-
               /X'10'))(13)  RESTORE THE REGISTERS.
         BR    LKR       RETURN.
SRCH8J   LR    TMP,A  EXCHANGE THE CONTENTS OF REGISTERS A AND B SO
         LR    A,B    THAT REGISTERS A AND B CONTAIN CONSECUTIVE
         LR    B,TMP  VERTICES DOWN THE PATH TO THE SINK FOUND.
SRCH8K   MVI   IGAPATH,P1100  SET THE PATH CODE TO INDICATE A LEFT SINK*
                         SUCCESSOR.
         LA    A,0(,A)   CLEAR THE HIGH ORDER BYTES IN THE TWO
         LA    B,O(,B)   ADDRESS DOWN THE PATH.
         STM   A,B,IGANTPEN  STORE THE ANTEPENULTIMATE AND THE         *
                         PENULTIMATE VERTICES ON THE PATH TO THE SINK.
         X     A,LEF(,B)  GET THE LEFT SUCCESSOR OF VERTEX B.
         LA    R15,O(,A)  CLEAR THE HIGH ORDER BYTE.
         ST    R15,IGAFARG  STORE THE ADDRESS ASSOCIATED WITH THE KEY  *
               THAT IS NOW AT THE CURRENT CURSOR SETTING.
         TM    FLAGS(B),IGANEBIT  SET THE CONDITION CODE TO ZERO IF THE*
                         SINK THAT SEARCH FOUND IS IN A SUBTREE OF     *
                         EQUAL KEYS.
         LM    FIRSTR,LASTR,((X'04'*FIRSTR)+X'14'-X'40'*((X'02'+FIRSTR)-
               /X'10'))(13)  RESTORE THE REGISTERS.
         BR    14        EXIT.
SRCHFOR1 L     R15,APT       THERE IS EXACLTY ONE SINK, RETURN IT.
         LA    R15,O(O,R15)  CLEAR THE HIGH ORDER BYTE.
         ST    R15,FARG      SAVE THE ADDRESS OF THE KEY FOUND.
         TM    *+1,B'11111111'  SET THE CONDITION CODE TO 11.
         BCR   15,LKR        RETURN WITH THE PROPER RETURN CODE.
         DROP  R15
         DROP  BASE
         EJECT
***********************************************************************
* DELETE THE SINK S WHEN THERE ARE MORE THAN TWO SINKS STILL IN THE   *
* TREE.                                                               *
***********************************************************************
* THERE ARE THREE MAJOR CASES:                                        *
*----------------------------------------------------------------------
* A. THE INNER VERTEX THAT WILL BE DELETED IS CURRENTLY THE SOURCE;   *
* B. THE INNER VERTEX C TO BE DELETED IS NOT THE SOURCE, AND THE      *
*    VERTEX PAIRED WITH THE SINK S BEING DELETED IS A SINK;           *
* C. THE INNER VERTEX TO BE DELETED IS NOT THE SOURCE, AND THE VERTEX *
*    PAIRED WITH THE SINK S TO BE DELETED IS AN INNER VERTEX.         *
*.....................................................................*
*  FOR CASE (A) THE FOLLWOING STEPS MUST BE DONE:                     *
* 0. SET ALT TO TO THE INNER VERTEX PAIRED WITH S.                    *
* 1. SET PATH TO 1000 IF S IS A LEFT SUCCESSOR, OR TO 1011 IF S IS A  *
*    RIGHT SUCCESSOR.                                                 *
* 2. SET APT, AP, AND AC TO ALT.                                      *
* 3. SET RL AT ALT TO ZERO, SINCE ALT WILL BE THE NEW SOURCE.         *
* 4. ADJUST THE EDGES AT ALT IF THEY HAVE TO BE ADJUSTED.             *
* 5. RETURN THE SPACE FREED BY THE DELETION TO THE FREE SPACE CHAINS. *
*    THIS IS ACCOMPLISHED BY BRANCHING TO DEL8FREE.                   *
*......................................................................
*   FOR CASE B, THE FOLLOWING STEPS MUST BE DONE:                     *
* 0. SET ALT TO THE VERTEX PAIRED WITH THE SINK S BEING DELETED.      *
* 1. SET PATH TO 10QR, WHERE Q=0 IF S IS A LEFT SUCCESSOR, Q=1 IF S   *
*    IS A RIGHT SUCCESSOR, R=0 IF C IS A LEFT SUCCESSOR, AND R=1 IF C *
*    A RIGHT SUCCESSOR.                                               *
* 2. SET AC TO P.                                                     *
* 3. SET AP TO P'S PREDECESSOR.                                       *
* 4. REMOVE THE EDGE (P,C) FROM THE GRAPH AND PUT IN THE EDGE (P,ALT).*
* 5. COPY THE APPROPRIATE C-BIT FROM C TO P FOR ALT.                  *
* 6. SET THE TR BIT AT P TO ZERO, BECAUSE THE NEW SUCCESSOR OF P, WZ, *
*    ON SIDE R OF P, WILL BE A SINK.                                  *
*......................................................................
*   FOR CASE C, THE FOLLOWING STEPS MUST BE DONE:                     *
*                                                                     *
* 0. SET ALT TO THE VERTEX PAIRED WITH THE SINK S TO BE DELETED.      *
* 1. SET PATH TO 1000 IF S IS A LEFT SUCCESSOR, OR TO 1011 IF S IS A  *
*    RIGHT SUCCESSOR.                                                 *
* 2. SET AC TO ALT.                                                   *
* 3. REMOVE THE EDGE (P,C) FROM THE GRAPH AND PUT IN THE EDGE (P,ALT).*
* 4. COPY THE C-BIT FOR ALT FROM C TO P.                              *
* 5. COPY THE RL BIT FROM C TO ALT.                                   *
* 6. ADJUST THE EDGES AT ALT IF NECESSARY.                            *
* 7. RETURN THE SPACE MADE AVAILABLE BY GOING TO DEL8FREE.            *
*                                                                     *
***********************************************************************
* ENTRY POINT FOR THE DEL MACRO-INSTRUCTION.                          *
***********************************************************************
      GODOWNTO &IGADEL8  SKIP DOWN TO THE LOCATION FOR THE TYPE 8      *
                         DELETION ROUTINE.
DEL8     EQU   *   ENTRY POINT FOR A DELETION.
         USING DEL8,R15  USE THE BASE REGISTER THAT THE DEL            *
                         MACRO-INSTRUCTION PROVIDES.
         USING TREEHDR,R1
         TM    PATH,P1000      SEE IF THERE ARE AT LEAST TWO SINKS,
         JMP   1,ATLEAST2      JUMP IF THERE ARE AT LEAST 2.
         L     R15,APT       RETURN THE ADDRESS SO IT CAN BE FREED.
         XC    APT,APT       ZERO OUT THE ADDRESS OF THE RADIX
*                            PARTITION TREE. USE XC TO DO THIS BECAUSE
*                            THERE AREN'T ANY REGISTERS AVAILABLE TO
*                            USE THE SLR-ST SEQUENCE.
         LA    R15,O(O,R15)    CLEAR THE LEFT BYTE.
         TM    IGADDR,B'11111111'  SET THE CONDITION CODE TO 01, TO    *
                         INDICATE THAT THERE ARE NO MORE ENTRIES LEFT  *
                         IN THE TREE.  A BM INSTRUCTION TAKES WITH IT.
         BCR   15,LKR          ZERO AND RETURN.
         DROP  R1
ATLEAST2 EQU   *  COME HERE FOR DELETE WHEN THERE ARE AT LEAST 2 SINKS.
         RASS  (WX,3,WY,4,WZ,8,DW0,6,WZ0,6,DW1,6,DW2,6,DW3,7,SNK,9,    X
               RC,10,RS,11,PXC,12)
         STM   R2,R12,((4*R2)+20-64*((2+R2)/16))(R13)  SAVE THE GPRS.
         USING TREEHDR,R1      ADDRESS OF TREEHDR IS IN R1.
         LM    P,C,AP    LOAD UP THE REGISTERS WITH THE LAST TWO
*                        INNER VERTICES ON THE PATH TO THE SINK
*                        TO BE DELETED.
         LA    RS,RL     (S4) SET UP RS TO HAVE A FOUR IF THE SINK TO
*                             BE DELETED IS A RIGHT SUCCESSOR.
         IC    RC,FLAGS(O,C)   (S8) SET RC TO THE VALUE OF THE RL FLAG
         NR    RC,RS           (S8) AT VERTEX C, I.E. SET RC TO A ZERO
*                                   IF C IS A LEFT SUCCESSOR OR TO FOUR
*                                   IF C IS A RIGHT SUCCESSOR.
         LM    WZ,SNK,O(C)     (S4,S5) PREPARE TO COMPUTE THE
*                              SUCCESSORS OF THE VERTEX C, WHICH IS
*                              PREDECESSOR OF THE SINK TO DELETE.
         TM    PATH,P0001      (S4) SET THE CONDITION CODE TO ONE IF
*                              THE VERTEX TO DELETE IS A RIGHT
*                              SUCCESSOR.
         LA    WY,O(O,P)       (S4) CLEAR THE HIGH ORDER BYTE SO IT CAN
*                              BE USED FOR ADJUSTING EDGES.
         L     HDB,HVFC  (S6) PUT THE FIXEDHDR ADDRESS IN
*                        HDB SO THE DOUBLE WORD AT C CAN BE FREED.
         LA    WX,O(O,C)       (S8) WX WILL EVENTUALLY HAVE THE
*                              PREDECESSOR OF THE ANTEPENULTIMATE
*                              VERTEX ON THE PATH TO THE SINK.
         USING FIXEDHDR,HDB    (S6) ESTABLISH ADDRESSABILITY TO THE
*                              BLOCK CONTAINING THE HEAD OF THE FREE
*                              SPACE CHAIN.
         L     PXC,HEADFREE    (S6) GET THE CURRENT ADDRESS OF THE
*                              FIRST DOUBLE WORD ON THE FREE SPACE
*                              CHAIN.
         JMP   1,SISRIGHT      (S4) JUMP IF S IS A RIGHT SUCCESSOR,
*                              SO THAT RS, WZ, AND SNK ARE SET UP
*                              CORRECTLY IF THE JUMP TAKES.
         LR    DW0,WZ    (S4,S5) S IS A LEFT SUCCESSOR, EXCHANGE THE
         LR    WZ,SNK    (S4,S5) TWO VERTICES WZ AND SNK, SO THAT
         LR    SNK,DW0   (S4,S5) SNK IS THE LEFT SUCCESSOR AND WZ IS
*                        THE RIGHT SUCCESSOR OF C.
         SLR   RS,RS     (S4) SET RS TO A ZERO, BECAUSE S IS A LEFT
*                        SUCCESSOR.
SISRIGHT EQU   *         JUMP HERE IF S IS A RIGHT SUCCESSOR.
         ST    PXC,O(O,WX)     (S6) STORE THE ADDRESS OF THE REST OF
*                              THE FREE SPACE CHAIN IN THE FIRST WORD
*                              OF THE NEWLY AVAILABLE DOUBLE WORD.
*        NOTE THAT THE SECOND WORD OF THE DOUBLE WORD IS NOT CHANGED  *
*        BY THIS STORE, AND THE FLAG BYTE THAT IT CONTAINS IS TESTED  *
*        LATER IN THE DEL8 CODE SEQUENCE.                             *
         XR    WZ,WY     (S4) COMPUTE THE VERTEX PAIRED WITH THE
*                        SINK TO BE DELETED.
         XR    SNK,WY    (S5) COMPUTE THE SINK ADDRESS THAT IS TO BE
*                        DELETED.
         ST    WX,HEADFREE     (S6) STORE THE ADDRESS OF THE RELEASED
         DROP  HDB             DOUBLE WORD AS THE NEW HEAD OF THE
*                              FREE SPACE CHAIN.
         LR    PXC,WX    (S7) COMPARE THE PENULTIMATE AND
         XR    PXC,WY    (S7) ANTEPENULTIMATE VERTICES ON THE PATH TO
*                        THE SINK BY EXCLUSIVE-ORING TO FIND OUT IF
*                        THEY ARE EQUAL. IF THEY ARE EQUAL THE TOP OF
*                        THE RPT IS AFFECTED BY THE DELETE.
*                        THE EXCLUSIVE-ORED RESULT IS ALSO USEFUL
*                        LATER IF IT IS A MOP DELETE.
         LA    WZ,O(O,WZ)      (S14) CLEAR THE HIGH ORDER BYTE SO IT
*                              CAN BE USED FOR EDGE ADJUSTMENT.
         JMP   8,DEL8TOP (S7) JUMP IF THE TOP IS AFFECTED.
         X     WX,O(RC,WY)     (S8) COMPUTE THE PREDECESSOR OF THE
*                        ANTEPENULTIMATE VERTEX ON THE PATH TO THE
*                        SINK TO BE DELETED.
*        NOTE THAT THE LEFT BYTE OF THE WORD NOW IN WX IS THE SAME    *
*        AS THE LEFT BYTE IN THE WORD AT O(RC,WY).                    *
*        THIS IS VERY GOOD, BECAUSE THE EDGE FIELD IS ADJUSTED BY     *
*        STORING THE WHOLE WORD WITHOUT CHANGING THE BYTE.            *
         LR    WZ0,WZ    (S9) COMPUTE THE EXCLUSIVE-OR EDGE FIELD FROM
*                        THE TWO ADDRESSES TOGETHER.
         XR    WZ0,WX    (S9) WY TO ITS NEW SUCCESSOR BY
         ST    WZ0,O(RC,WY)  (S9) EXCLUSIVE-ORING THE TWO ADDRESSES
*                              TOGETHER.
         LA    WX,O(O,WX)      (S12) CLEAR THE LEFT BYTE FOR USE LATER.
         TM    FLAGS(C),T0+T1  (S10) SEE IF THE VERTEX WZ IS AN INNER
         JMP   7,DEL8MOP       (S10) VERTEX, AND JUMP IF SO.
DEL8EOP  STM   WX,WY,AP  (S12,S13) STORE THE TWO PATH VERTICES.
         L     DW1,FLAGS(O,WY) (S13) PREPARE TO SET THE T-BIT FOR WZ
*                              AT ITS PREDECESSOR TO ZERO.
         LA    RS,(FOUR*P1000)(RS,RS)  (S11) SET THE PATH BYTE
         ALR   RS,RC     (S11)  TO 1,0,RS,RC TO REPRESENT THE
         SRL   RS,TWO    (S11) CAT'S EDGE TO THE DELETED SINK FOR
         STC   RS,PATH   (S11) SUBSEQUENT SCANL OR SCANR OPERATIONS.
         AL    DW1,SETTZERO(RC)  (S13) SET THE T-BIT FOR WZ TO ZERO IN
         ST    DW1,FLAGS(O,WY)  (S13) ITS PREDECESSOR'S FLAG BYTE.
         LA    R15,O(O,SNK)    (S5) GET THE RETURN CODE, I.E. THE
*                              SINK ADDRESS DELETED.
         LM    R2,R12,((4*R2)+20-64*((2+R2)/16))(R13)  (S13)
         LTR   R15,R15   SET THE CONDITION CODE FOR THE RETURN.
         JMP   15,(LKR)        XX
DEL8MOP  EQU   *         (S14) COME HERE WHEN THE VERTEX PAIRED WITH
*                        THE SINK TO BE DELETED IS AN INNER VERTEX,
*                        SO THAT THE DELETE IS A MOP DELETE.
         ST    WZ,AC     (S14) STORE THE NEW PENULTIMATE PATH VERTEX.
         LM    DW2,DW3,O(WZ)   (S15,16) ADJUST THE EDGES OF THE INNER
*                              (S15) VERTEX PAIRED WITH THE SINK TO
*                              BE DELETED.
         ALR   RC,RS     (S15) SET THE RL BIT AT WZ TO BE THE SAME
         X     DW3,RLTAB0(RC)  (S15) AS THE RL BIT IN THE DELETED
*                              INNER VERTEX C.
*        THIS IS ACCOMPLISHED BY REALIZING THAT RS IS A ZERO OR FOUR  *
*        WHEN WZ IS A RIGHT OR LEFT SUCCESSOR OF C RESPECTIVELY, AND  *
*        THAT RC IS A ZERO OR FOUR WHEN C IS A LEFT OR RIGHT VERTEX   *
*        RESPECTIVELY. THIS MEANS THAT IF RS AND RC ARE EQUAL THEN    *
*        THE RL BIT CURRENTLY IN WZ MUST BE COMPLEMENTED, BUT IF RS   *
*        AND RC ARE NOT EQUAL THE RL BIT AT WZ CAN BE LEFT ALONE,     *
*        BECAUSE IT IS ALREADY SET CORRECTLY.                         *
*        THUS BY ADDING RC AND RS A RESULT OF ZERO OR EIGHT IS        *
*        OBTAINED IF THEY ARE EQUAL, OR A RESULT OF FOUR IS OBTAINED  *
*        IF THEY ARE NOT EQUAL. THEN BY USING THIS VALUE OF 0, 4, OR 8*
*        TO INDEX INTO A TABLE THAT HAS A ONE IN THE RL BIT POSITION  *
*        IN THE FIRST AND THIRD WORDS, AND WITH THE MIDDLE WORD ALL   *
*        ZEROS, EXCLUSIVE-ORING THE SELECTED WORD WILL EITHER LEAVE   *
*        THE RL BIT ALONE OR COMPLEMENT IT APPROPRIATELY.             *
         XR    DW2,PXC   (S16) ADJUST WZ'S EDGE FIELDS BY REMOVING
         XR    DW3,PXC   (S16) THE DELETED INNER VERTEX AND PUTTING
*                        IN THE NEW PREDECESSOR OF WZ.
         STM   DW2,DW3,O(WZ)   (S15,S16) STORE BACK THE ADJUSTED FIELDS
*                              FOR WZ.
         IC    RS,RSTAB0(RS)  (S17) SET THE PATH CODE BYTE TO 10,RS,RS.
DEL8PATH STC   RS,PATH   (S17) STORE THE NEW PATH BYTE.
         LA    R15,O(O,SNK)    (S5) SET THE RETURN CODE TO THE SINK
*                              THAT WAS DELETED.
         LM    R2,R12,((4*R2)+20-64*((2+R2)/16))(R13)  (S18)
         LTR   R15,R15   SET THE CONDITION CODE FOR THE RETURN.
         JMP   15,(LKR)        (S18) COULD HAVE BEEN CHANGED.
DEL8TOP  ST    WZ,APT    (S19) STORE THE NEW SOURCE OF THE RPT.
         SLR   RC,RC     (S20) SET RC TO ZERO SO THAT THE RL BIT AT
*                        WZ WILL BE SET TO ZERO, SINCE IT IS THE NEW
*                        SOURCE OF THE RPT.
         XR    WX,WZ     (S22) CAUSE THE EDGE ADJUSTMENT FOR STEP 16
         XR    PXC,WX    (S22) TO PUT WZ IN ITS EDGE FIELDS AS ITS OWN
*                        PREDECESSOR, WHICH IS THE CONVENTION FOR THE
*                        SOURCE VERTEX OF THE RPT.
         ST    C,AP      (S22) STORE THE NEW ANTEPENULTIMATE VERTEX.
         TM    FLAGS(C),T0+T1  (S21) SEE IF WZ IS AN INNER VERTEX,
         JMP   7,DEL8MOP  (S23) BECAUSE IF IT IS NOT AN INNER VERTEX
*                              THE DELETE IS DELETING ONE OF THE ONLY
*                              TWO SINKS LEFT IN THE RPT.
         IC    RS,RSTAB1(RS)   (S24) SET THE PATH BYTE TO 0011 OR 0101,
*                             FOR RS BEING A ZERO OR FOUR RESPECTIVELY.
         STC   RS,PATH   (S24) STORE THE NEW PATH CODE.
         LA    R15,O(O,SNK)    S5) RETURN THE ADDRESS OF THE SINK.
         LM    R2,R12,((4*R2)+20-64*((2+R2)/16))(R13)  (S25)
         LTR   R15,R15   SET THE CONDITION CODE FOR THE RETURN.
         JMP   15,(LKR)        (S25) RETURN.
         DROP  R1
         DROP  R15
         EJECT
***********************************************************************
*   D E L E T E    R O U T I N E    F O R    T Y P E    5    R A D I X*
*    P A R T I T I O N    T R E E S    .                              *
***********************************************************************
     GODOWNTO  &IGADEL5  SKIP DOWN TO THE ENTRY POINT FOR THE TYPE 5   *
                         DELETE.
EVEN5    EQU   R4        AN EVEN/ODD PAIR OF WORK REGISTERS
ODD5     EQU   R5        FOR USE IN DEL5.
IGADEL5  EQU   *         COME HERE TO DELETE FROM A TYPE 5 TREE.
         USING IGARPTH5,R1
         USING IGADEL5,R15  USE THE BASE REGISTER THAT THE DEL         *
                         MACRO-INSTRUCTION PROVIDES.
         USING SAVEDSEK,R13
         STM   EVEN5,ODD5,GPR0+4*EVEN5  SAVE THE TWO REGISTERS.
         L     ODD5,O(O,IGAC5)  LOAD THE OLD SINK WORD FOR THE RETURN
*                               CODE IN GPR 15 LATER.
         CLR   IGAP5,IGAC5     SEE IF THERE IS ONLY ONE SINK BEFORE
         JMP   7,AROUND5       THE DELETE, JUMPING IF NOT.
         MVC   IGATOP5,DEADSINK  MOVE IN THE EMPTY TREE FLAG.
         BC    15,DOWN5  BRANCH TO THE EXIT, THAT WAS SHORT.
AROUND5  LA    EVEN5,FOURCON   GET A CONSTANT 4.
         XR    IGAC5,EVEN5     GET THE VERTEX PAIRED WITH THE SINK
*                              THAT IS TO BE DELETED.
         MVC   O(4,IGAP5),O(IGAC5)  DELETE THE SINK.
         OR    IGAC5,EVEN5     GENERATE THE VERTEX WHICH IS THE LEFT
         XR    IGAC5,EVEN5     SUCCESSOR OF THE PREDECESSOR OF THE SINK
*                              TO BE DELETED.
         L     EVEN5,IGACNT5   SUBTRACT ONE FROM THE USE COUNT SO THE
         BCTR  EVEN5,O         VALIDITY OF SIMULTANEOUS READ-ONLY
         ST    EVEN5,IGACNT5   SEARCHES IS MAINTAINED.
         L     EVEN5,IGAHVFC5  PUT THE DOUBLE WORD MADE AVAILABLE BY
         STM   EVEN5,ODD5,O(IGAC5)  THE DELETION ON THE FREE SPACE
*                              CHAIN, AND MAKE SURE THAT BIT 0 OF
*                              BOTH WORDS ON THE FREE SPACE CHAIN ARE
*                              ZERO TO AVOID THE INFINITE SEARCH LOOP
*                              THAT COULD OCCUR SOMETIME DURING THE
*                              NEXT THOUSAND YEARS.
         ST    IGAC5,IGAHVFC5  STORE THE NEW HEAD OF THE CHAIN.
DOWN5    LTR   R15,ODD5  PUT THE SINK WORD IN R15 FOR THE RETURN CODE.
         LM    EVEN5,ODD5,GPR0+4*EVEN5  RESTORE THE TWO REGISTERS.
         JMP   15,(LKR)  RETURN.
         DROP  R1
         DROP  R13
         DROP  R15
         EJECT
***********************************************************************
* I N S E R T    I N T O    A    R A D I X    P A R T I T I O N       *
*   T R E E    O F    T Y P E    5.                                   *
***********************************************************************
      GODOWNTO &IGAINS5  SKIP DOWN TO THE BRANCH ENTRY POINT FOR THE   *
                         INSERTION INTO A RADIX PARTITION TREE OF TYPE *
                         5.
     RPTDSECT  TYPE=5
         RASS  (P5,IGAP5,C5,IGAC5,FAR5,4,SAR5,10,NSNK5,6,FSNK5,7)
         RASS  (FSNK5B,5,I5,8,NEW5,9,S5,10,INS5TMP,11)
         RASS  (LNG5,5)
BASE5    EQU   R12       BASE REGISTER FOR INS5.
IGAINS5  EQU   *         ENTRY POINT FOR INSERT INTO A TYPE 5 TREE.
         NTR   BR=BASE5,SAVE=(LKR,R12),LV=0
         USING IGARPTH5,R1     TREE HEADER ADDRESS IS IN R1.
         USING SAVEDSEK,R13
         CLC   IGATOP5,DEADSINK  SEE IF THE TREE IS EMPTY.
         LR    NSNK5,R0  SAVE THE NEW SINK WORD FOR LATER, BECAUSE THIS
*                        REGISTER COULD BE TRANSMOGRIFIED BY GETMAIN.
         JMP   8,INS5ZERO      BRANCH IF IT IS THE EMPTY TREE.
***********************************************************************
*  CHECK THE FREE SPACE CHAIN TO SEE IF THERE IS ANOTHER 8 BYTES ON IT*
* TO USE FOR THE INSERTION. IF THERE IS, PUT THE ADDRESS OF THE 8 BYTE*
* AREA IN NEW5. IF THERE ISN'T ENOUGH SPACE, THEN GO TO INS5GET TO TRY*
* TO GET SOME MORE SPACE USING THE GETMAIN MACRO-INSTRUCTION.         *
***********************************************************************
         L     NEW5,IGAHVFC5   HEAD OF THE FREE SPACE CHAIN.
         LTR   NEW5,NEW5       SEE IF THE CHAIN IS EMPTY.
         JMP   8,INS5GET       GET MORE SPACE IF IT IS.
         MVC   IGAHVFC5,O(NEW5)  OTHERWISE DECAPITATE THE CHAIN.
INS5GOT  EQU   *         GOT THE SPACE FOR THE NEW VERTEX.
         L     FAR5,O(O,C5)    LOAD THE SINK ADDRESS AT EOP.
         LH    SAR5,IGAKEYI5   GET INDEX OF KEY IN RECORD.
         LR    FSNK5,FAR5      GET THE ADDRESS OF THE EOP SINK.
         ALR   FAR5,SAR5       GENERATE THE ADDRESS OF THE KEY.
         ALR   SAR5,R15  GET THE ADDRESS OF THE KEY TO BE INSERTED.
*---------------------------------------------------------------------*
*  FIND THE NEW BIT INDEX FOR THE NEW INNER VERTEX.                   *
*---------------------------------------------------------------------*
INS5BIT  EQU   *
         SLR   LNG5,LNG5       GET ZERO IN THE HIGH ORDER PART.
         IC    LNG5,IGAKEYL5   GET THE KEY LENGTH IN BYTES.
         FBI   I=I5,A=SAR5,B=FAR5,LV=(LNG5),WRK=INS5TMP  GET BIT INDEX.
         STM   NSNK5,FSNK5,O(NEW5)  STORE THE TWO AND MAYBE THEY WILL
*                              ALREADY THEN BE IN THE RIGHT PLACE.
*                              AT LEAST 50% OF THE TIME THEY WILL BE.
         LR    P5,C5    SET THE ANTEPENULTIMATE VERTEX ON THE NEW PATH.
         LR    C5,NEW5   SET THE LAST INNER VERTEX ON THE NEW INSERT
*                        PATH TO BE THE NEW INNER VERTEX.
         JMP   4,REVERSE       JUMP IF THEY ARE OKAY NOW.
*---------------------------------------------------------------------*
* OOPS, IT STORED THEM IN THE WRONG ORDER, THE NEW SINK IS GREATER    *
* THAN THE OLD SINK, SO IT SHOULD BE AT 4(NEW5) AND THE OLD SINK      *
* SHOULD BE AT 0(NEW5), SO STORE THEM IN THE OTHER ORDER.             *
*---------------------------------------------------------------------*
         LR    FSNK5B,FSNK5    MOVE IT TO THE REGISTER ON THE LEFT OF
         STM   FSNK5B,NSNK5,O(NEW5)  THE NEW SINK SO THEY CAN BE STORED
*                              IN THE CORRECT ORDER.
         LA    C5,4(O,NEW5)    PUT THE ADDRESS OF THE EOP WORD IN C5.
         SLR   LNG5,LNG5       ZERO IT OUT FOR THE IC INSTRUCTION.
REVERSE  BIT   I=I5,A=SAR5,B=FAR5,J=LNG5,N=INS5TMP
*                        COMPENSATE FOR RIGHT ALIGNED KEYS
         IC    INS5TMP,IGAKEYL5  THAT ARE LESS THAN FOUR BYTES LONG,
         IC    INS5TMP,INS5BITS(INS5TMP)  FIX FOR RIGHT ALIGNED KEYS.
         ALR   I5,INS5TMP      ADD IN THE ALIGNMENT AND INNER VERTEX
         SLL   I5,2            FLAG BIT.
         SLL   NEW5,8          VERTEX AND CATENATE THE NEW BIT INDEX
         SRDL  I5,8            AND FLAG BIT TO THE INNER VERTEX EDGE.
INSCOUNT L     R15,IGACNT5     SUBTRACT ONE FROM THE INSERT/DELETE
         BCTR  R15,O           COUNTER TO MAINTAIN THE VALIDITY OF
         ST    R15,IGACNT5     SIMULTANEOUS SEARCHES.
         ST    NEW5,O(O,P5)    STORE THE EDGE TO THE NEW VERTEX AT EOP.
         LTR   R15,NSNK5       PUT THE NEW SINK WORD IN GPR 15 AND ALSO
         LR    R0,NSNK5        PUT IT IN GPR 0.
         LM    R4,R12,((4*R4)+20-64*((2+R4)/16))(R13)  RESTORE ONLY THE*
                         REGISTERS IT USED.
         JMP   15,(LKR)  JUMP BACK TO THE CALLING PROGRAM.
***********************************************************************
* ZERO SINKS IN A TYPE 5 TREE BEFORE THE INSERT.                      *
***********************************************************************
INS5ZERO EQU   *         COME HERE FOR ZERO SINKS.
         LR    NEW5,R0   THIS IS A VERY SHORT EXCEPTION SEQUENCE.
         JMP   15,INSCOUNT     THAT'S IT.
***********************************************************************
* RAN OUT OF INNER VERTEX SPACE FOR A TYPE 5 TREE, GET MORE.          *
***********************************************************************
INS5GET  EQU   *
         LA    R0,EIGHT  PUT THE LENGTH VALUE FOR THE CONDITIONAL      *
                         GETMAIN IN REGISTER ZERO,
         IC    R15,IGASP5      AND PUT THE SUBPOOL NUMBER IN REGISTER  *
                         FIFTEEN.
         LTR   LKR,LKR         SEE IF IT A CONDITIONAL OR AN           *
                               UNCONDITIONAL REQUEST.
         JMP   4,INS5COND      BRANCH IF IT IS A CONDITIONAL REQUEST.
         SLL   R15,TWENTY4  PUT THE SUBPOOL NUMBER IN THE LEFT BYTE OF
         ALR   R0,R15    REGISTER ZERO FOR THE UNCONDITIONAL GETMAIN.
      GETMAIN  R,LV=(0)
         LR    NEW5,R1   GET THE NEW INNER VERTEX.
         LM    R15,R1,((4*R15)+20-64*((2+R15)/16))(R13)  RESTORE THE   *
                         REGISTERS THAT GETMAIN INVALIDATED.
         L     R1,((4*R1)+20-64*((2+R1)/16))(,R13)  RESTORE R1 TO THE  *
                         ADDRESS OF THE TREE HEADER.
         B     INS5GOT   CONTINUE, NOW THAT IT GOT THE SPACE FOR THE   *
                         NEW INNER VERTEX.
***********************************************************************
*                                                                     *
* USE A CONDITIONAL GETMAIN TO GET THE ADDITIONAL SPACE FOR THE       *
* INSERTION.                                                          *
***********************************************************************
*                                                                     *
INS5COND LA    R1,((4*R2)+20-64*((2+R2)/16))(,R13)  GET THE ADDRESS OF *
                         A TWELVE BYTE WORK AREA FOR THE GETMAIN.
       GETMAIN EC,A=(1),LV=(0),SP=(15),MF=(E,(1))  CONDITIONAL GETMAIN.
         L     NEW5,((4*R2)+20-64*((2+R2)/16))(,R13)  GET THE ADDRESS  *
                         OF THE 8-BYTE AREA ALLOCATED (IF THE GETMAIN  *
                         WAS SUCCESSFUL).
         STM   R2,R4,((4*R2)+20-64*((2+R2)/16))(R13)  SAVE THE         *
                         REGISTERS AGAIN, BECAUSE GETMAIN USED THEIR   *
                         SAVE AREA.
         LTR   R15,R15   TEST THE RETURN CODE FROM THE CONDITIONAL     *
                         GETMAIN.
         LM    R15,R1,((4*R15)+20-64*((2+R15)/16))(R13)  RESTORE THE   *
                         REGISTERS THAT GETMAIN SMASHED.
         BZ    INS5GOT   BRANCH IF IT IS OKAY.
         LEAF  LV=,SAVE=(LKR,R12),RC=-1  IT DIDN'T WORK.
         DROP  R1
         DROP  R13
         DROP  BASE5
         EJECT
***********************************************************************
      GODOWNTO &IGAINS8  SKIP DOWN TO THE LOCATION FOR THE TYPE 8 RPT  *
                         INSERTION ROUTINE.
***********************************************************************
* UPON ENTRY TO THE TYPE 8 INSERT, THE REGISTERS HAVE THE FOLLOWING:  *
* R0:    THE ACTUAL SINK ADDRESS TO BE INSERTED IN THE RPT.           *
* R1:    THE ADDRESS OF THE RADIX PARTITION TREE.                     *
* R13:   THE ADDRESS OF A VALID SAVE AREA TO BE USED BY INSERT.       *
* LKR:   THE RETURN ADDRESS.                                          *
*        BIT 0 OF LKR IS A 0 IF THE INSERT IS AN UNCONDITIONAL INSERT,*
*        OR IT IS A ONE IF THE INSERT IS A CONDITIONAL INSERT.        *
* R15:   THE ADDRESS OF THE RECORD CONTAINING THE INSERT KEY.         *
***********************************************************************
INS8     NTR   BR=R15,SAVE=(LKR,R12),LV=0
         LR    PLA,R1          ADDRESS OF THE TREE HEADER.
         USING TREEHDR,PLA
         L     HDB,HVFC      LOAD THE ADDRESS OF THE FIXEDHDR FOR THE
         USING FIXEDHDR,HDB  INNER SPACE.
         L     NEW,HEADFREE  LOAD THE HEAD OF THE FREE SPACE CHAIN.
         TM    PATH,P1000      SEE IF THERE ARE AT LEAST TWO SINKS.
         JMP   8,INS801        BRANCH IF THERE ARE ZERO OR ONE.
***********************************************************************
*     INSERTION SUBROUTINE.                                           *
***********************************************************************
         LTR   NEW,NEW   SEE IF THERE IS ENOUGH SPACE FOR THE INSERT.
         JMP   (X'F'-4),JUMPOVER  JUMP IF THERE IS ENOUGH SPACE.
INS8FULL EQU   *         COME HERE WHEN THE SPACE CHAIN IS EMPTY.
         N     LKR,X800  ZERO OUT BITS 1-31 OF LKR.
         AL    LKR,INS8ACON    GET THE RETURN ADDRESS FROM THE ROUTINE *
                         TO GET MORE SPACE OF THE FREE SPACE CHAIN.
         DROP  R15
         USING INS8LOAD,LKR    THE ADDRESS IN R15 IS NOT BIG ENOUGH TO *
                         REACH THE BRANCH TARGET, SO USE ONE THAT IS   *
                         BIG ENOUGH.
         JMP   15,NEEDMORE  GO GET MORE SPACE ON THE CHAIN.
         DROP  LKR
         CNOP  0,4
INS8ACON DC    AL4(INS8LOAD)  THIS IS THE RETURN ADDRESS FROM NEEDMORE.
INS8LOAD EQU   *         COME BACK HERE FROM NEEDMORE.
         L     LKR,((4*LKR)+20-64*((2+LKR)/16))(,R13)  RESTORE LKR.
         BALR  R15,O     RE-ESTABLISH ADDRESSABILITY.
INS8ADR8 EQU   *
         USING INS8ADR8,R15
         LCR   R15,R15   PUT THE ADDRESS BACK AT THE INS8 LABEL.
         LA    R15,(INS8ADR8-INS8)(,R15)  SUBTRACT THE DIFFERENCE BY
         LCR   R15,R15   FIRST ADDING IT TO THE COMPLEMENT AND THEN    *
                         COMPLEMENTING IT BACK AGAIN.
         DROP  R15
         USING INS8,R15
         L     NEW,HEADFREE  LOAD THE ADDRESS OF THE FIRST CHAIN ENTRY.
         LTR   NEW,NEW   SEE IF IT WAS ABLE TO GET ANY MORE SPACE ON
         JMP   10,JUMPOVER  THE FREE SPACE CHAIN.
INS8LEAF LEAF  SAVE=(R0,R12),RC=-1,LV=
         DROP  R15
         DROP  PLA
         DROP  HDB
         EJECT
***********************************************************************
*    ENTRY POINT FOR SCANNING LEFT.                                   *
***********************************************************************
      GODOWNTO &IGALSCN
***********************************************************************
         USING TREEHDR,R1
         USING (&IGANAME+&IGALSCN),R15  USE THE BASE REGISTER THAT THE *
                         SCANL MACRO-INSTRUCTION SETS UP.
         STM   PR,SR,PRPAST(R13)   SAVE THE REGISTERS.
         SLR   SR,SR               USE THE PATH AS AN INDEX TO BRANCH
         IC    SR,PATH             DIRECTLY TO THE RIGHT PLACE.
         IC    SR,SCANLTAB(SR)     XX
         LM    PR,CR,AP  SET UP THE FIRST TWO ON THE PATH.
         JMP   15,SCANLORG(SR)  JUMP INTO THE CORRECT SEQUENCE.
         DROP  R15
         DROP  R1
***********************************************************************
*   ENTRY POINT FOR SCANNING RIGHT.                                   *
***********************************************************************
      GODOWNTO &IGARSCN
         USING TREEHDR,R1
         USING (&IGANAME+&IGARSCN),R15  USE THE BASE REGISTER THAT THE *
                         SCANR MACRO-INSTRUCTION PROVIDES.
PRPAST   EQU   28
         STM   PR,SR,PRPAST(R13)  SAVE THE REGISTERS.
         SLR   R4,R4              USE THE PATH AS AN INDEX TO ENTER
         IC    R4,PATH            THE EXACT PLACE IN THE SUBROUTINE
         IC    R4,SCANRTAB(R4)    TO CONTINUE THE SCAN.
         LM    PR,CR,AP           SET UP PR'AND CR INITIALLY.
         JMP   15,SCANRORG(SR)  JUMP INTO THE CORRECT SEQUENCE.
         DROP  R15
         DROP  R1
***********************************************************************
*        SUBROUTINE FOR SCANNING LEFT.
***********************************************************************
SCANLORG EQU   *
***********************************************************************
         USING (&IGANAME+&IGALSCN),R15  REVERT TO THE BASE REGISTER FOR*
                         THE SCANL ROUTINE.
         USING TREEHDR,R1
PASTLEFT EQU   *  PASSED THE SINGLE SINK ON THE LEFT.
         MVI   PATH,P0011          SET PATH TO LEFT OF SINGLE SINK.
         BC    15,NULLIN           MERGE WITH IDENTICAL EXIT SEQUENCE.
***********************************************************************
SCLTREB  TREB  PR,CR,SR,CYCLE=YES  TRACE BACKPATH UP RIGHT EDGE
SCLBT00  BT00  CR,PATHTOC          BRANCH IF C'S LEFT IS A SINK.
         TLEF  PR,CR,SR,CYCLE=YES  TRACE PATH DOWN LEFT EDGE.
         BT10  CR,SCLG1ES      BRANCH IF THE RIGHT SIDE IS A SINK.
SCLTREF  TREF  PR,CR,SR,CYCLE=YES  TRACE THE PATH DOWN THE RIGHT EDGE.
SCLBT11  BT11  CR,SCLTREF      BRANCH IF C'S RIGHT SUCCESSOR IS INNER.
SCLG1ES  STM   PR,CR,AP  STORE THE ANTEPENULTIMATE AND PENULTIMATE     *
                         VERTICES ON THE CURRENT PATH.
         X     PR,RGHT(,CR)  GET THE RIGHT SINK SUCCESSOR OF CR.
         LA    R15,O(,PR)  CLEAR THE LEFT BYTE OF THE SINK.
         LM    PR,SR,PRPAST(R13)   RESTORE THE REGISTERS.
         MVI   PATH,P1101          SET PATH TO RIGHT SINK.
         LTR   R15,R15   SET THE CONDITION CODE TO CORRESPOND TO THE   *
                         RETURN CODE.
         BCR   15,LKR              EXIT.
***********************************************************************
SCLTLEB  TLEB  PR,CR,SR,CYCLE=YES  TRACE BACKPATH UP LEFT EDGE.
SCLBIV1  BIV1  CR,SCLTREB          BRANCH IF C IS A RIGHT SUCCESSOR.
         LA    PR,0(0,PR)          CLEAR THE HIGH
         LA    CR,0(0,CR)          ORDER BYTES.
         CLR   PR,CR               CONTINUE THE SCAN
         BC    7,SCLTLEB           IF THE SOURCE NOT REACHED.
         MVI   PATH,P1000          SET PATH TO PAST LEFT END.
         STM   PR,CR,AP            STORE VERTICES.
         BC    15,NULLIN           MERGE WITH IDENTICAL SEQUENCE.
SCANLGO  EQU   *         COME HERE AFTER ISCAN HAS BEEN EXECUTED TO
         L     PR,APT    START THE SCAN LEFT WITH THE RIGHT
         LR    CR,PR     SUBTREE 3F THE SOURCE OF THE TREE.
         BC    15,SCLBT11      GO INVESTIGATE THE RIGHT SUBTREE.
         DROP  R15
***********************************************************************
*  SUBROUTINE FOR SCANNING RIGHT TO NEXT SINK. THE SETTINGS OF THE
*  PATH CODE ON ENTRY AND THE POSSIBLE RESULTING SETTINGS ARE SHOWN
*  IN THE FOLLOWING INCIDENCE MATRIX:
*
*           0 1 2 34 5 6 78 9 A BC D E F
*         0 X                           
*         1          X                  
*         2                             
*       I 3   X                         
*       N 4                             
*       P 5          X                  
*       U 6 X                           
*       T 7   X                         
*         8                      X      
*       C 9                      X X    
*       O A                      X X    
*       D B                     XX X    
*       E C                      X X    
*         D                     XX X    
*         E                      X      
*         F                      X      
***********************************************************************
SCANRORG EQU   *-TWO  PROVIDE A X'02' FOR THE FIRST BYTE SCANRTAB.    *
***********************************************************************
         USING (&IGANAME+&IGARSCN),R15  REVERT TO THE BASE REGISTER FOR*
                         THE SCANR ROUTINE.
NULLPATH EQU   *  THERE ARE ZERO SINKS IN THE TREE.
         MVI   PATH,P0000  SET THE PATH TO THE NULL CASE.
NULLIN   LM    PR,SR,PRPAST(R13)  RESTORE THE REGISTERS.
         LA    R15,ONE   SET THE RETURN CODE TO MINUS ONE, AND
         LNR   R15,R15   SET THE CONDITION CODE TO CORRESPOND TO IT.
         BR    LKR       EXIT.
***********************************************************************
PLEFOFIT EQU   *  THERE IS ONE SINK AND THE CAT'S SINK IS TO ITS LEFT.
         L     R15,APT   GET THE SINGLE SINK FOR THE RETURN CODE.
         MVI   PATH,P0001         ADDRESS THE SINGLE SINK.
         LM    PR,SR,PRPAST(R13)  RESTORE THE REGISTERS.
         LA    R15,O(O,R15)  CLEAR THE HIGH ORDER BYTE.
         LTR   R15,R15   SET THE CONDITION CODE TO CORRESPOND TO THE   *
                         RETURN CODE.
         BCR   15,LKR             EXIT.
***********************************************************************
PASTRGHT EQU   *  PASSED THE SINGLE SINK ON THE RIGHT.
         MVI   PATH,P0101         SET PATH PAST IT.
         BC    15,NULLIN          MERGE WITH AN IDENTICAL EXIT.
***********************************************************************
SCRTLEB  TLEB  PR,CR,SR,CYCLE=YES  TRACE BACKPATH UP LEFT EDGE.
SCRTRYT1 BT11  CR,SCRTREF          BRANCH IF C'S RIGHT IS INNER.
PATHOD   STM   PR,CR,AP  STORE THE ANTEPENULTIMATE AND THE PENULTIMATE *
                         VERTICES ON THE PATH TO THE SINK SELECTED BY  *
                         THE CURSOR.
         X     PR,RGHT(,CR)  GET THE RIGHT SINK SUCCESSOR OF CR.
         LA    R15,O(,PR)  CLEAR THE LEFT BYTE.
         LTR   R15,R15   SET THE CONDITION CODE TO CORRESPOND TO THE   *
                         RETURN CODE.
         LM    PR,SR,PRPAST(R13)   RESTORE THE REGISTERS.
         MVI   PATH,P1101          SET PATH NON-NULL RIGHT SINK.
         BCR   15,LKR              RETURN.
SCRTREF  TREF  PR,CR,SR,CYCLE=YES  TRACE RIGHT EDGE DOWN THE PATH.
         BT00  CR,PATHTOC      BRANCH IF LEFT SUCCESSOR IS A SINK.
SCRTLEF  TLEF  PR,CR,SR,CYCLE=YES  TRACE LEFT EDGE FORWARD.
SCRBT01  BT01  CR,SCRTLEF      BRANCH IF C'S LEFT SUCCESSOR IS INNER.
PATHTOC  EQU   *  COME HERE TO SET THE PATH CODE TO 1100 UPON EXIT.
         STM   PR,CR,AP            STORE THE ANTEPENULTIMATE AND
*                                  THE PENULTIMATE VERTICES ON PATH.
         X     PR,LEF(,CR)  GET THE LEFT SINK SUCCESSOR OF CR.
         LA    R15,O(,PR)  CLEAR THE LEFT BYTE.
         LTR   R15,R15   SET THE CONDITION CODE TO CORRESPOND TO THE   *
                         RETURN CODE.
         LM    PR,SR,PRPAST(R13)   RESTORE THE REGISTERS.
         MVI   PATH,P1100          SET PATH TO LEFT SINK, N AT LEAST 2.
         JMP   15,(LKR)        RETURN.
***********************************************************************
SCRTREB  TREB  PR,CR,SR,CYCLE=YES  TRACE BACKPATH WITH RIGHT EDGE.
SCRBIV1  BIV1  CR,SCRTREB          TRACE IT MORE IF CR IS RIGHT.
         LA    PR,0(0,PR)          CLEAR THE HIGH ORDER BYTES SO
         LA    CR,0(0,CR)          AS TO CHECK FOR EQUAL ADDRESSES.
         CLR   PR,CR               HAS THE SOURCE BEEN REACHED FROM ITS
         BC    7,SCRTLEB           RIGHT SUCCESSOR. IF SO IT IS DONE.
         MVI   PATH,P1011          SCANR WENT PAST END.
         STM   PR,CR,AP            STORE PATH VERTICES.
         BC    15,NULLIN           MERGE WITH OTHER EXIT SEQUENCE.
SCANRGO  EQU   *         COME HERE TO SET P AND C TO THE SOURCE ON THE
         L     PR,APT    FIRST EXECUTION AFTER ISCAN HAS BEEN EXECUTED.
         LR    CR,PR     THUS THE SOURCE IS THE START FOR THE SCAN.
         BC    15,SCRBT01      GO SCAN FOR THE LEFT SUBTREE.
***********************************************************************
         DROP  R1
         DROP  R15
         EJECT
***********************************************************************
* COME HERE TO ESTABLISH A SPACE CONTROL AREA FOR AN ARBITRARY SUBPOOL*
* AND RETURN THE ADDRESS IN REGISTER 1. UPON ENTRY TO IGASPAC THE GPRS*
* ARE AS FOLLOWS:                                                     *
*        R0    SUBPOOL AND LENGTH OF THE SPACE CONTROL AREA.          *
*        R1:   IGNORED.                                               *
*        LKR   RETURN ADDRESS.                                        *
*        R15:            THE POWER OF TWO TO BE USED IN COMPUTING THE *
*                        MASK FOR ROUNDING THE REQUEST LENGTH. THE    *
*                        POWER CAN BE ANY INTEGER IN THE RANGE FROM 0 *
*                        TO 15 INCLUSIV (ALTHOUGH ANY INTEGER ABOVE 8 *
*                        IS HIGHLY UNUSUAL).                          *
*                        THE DEFAULT VALUE FOR THIS POWER SUPPLIED BY *
*                        THE GSPACE MACRO-INSTRUCTION IS 4, SO THAT   *
*                        ALL REQUESTS ARE ON 16-BYTE BOUNDARIES.      *
***********************************************************************
      GODOWNTO &IGAISP   SKIP DOWN TO THE ENTRY POINT FOR THE ROUTINE  *
                         TO SET UP A SPACE CONTROL AREA.
         BALR  R15,O     ESTABLISH ADDRESSABILITY.
         USING *,R15
      GETMAIN  R,LV=(0)  ASSUME THE SUBPOOL AND LENGTH ARE IN R0.
         DROP  R15       GETMAIN SMASHES R15.
         USING IGASPCTL,R1     GOT THE AREA, NOW USE IT.
         STM   LKR,R12,IGASA0+FOUR*THREE  SAVE THE REGISTERS.
         BALR  R15,O     RE-ESTABLISH ADDRESSABILITY.
         USING *,R15     ALSO USE IT.
         L     R2,X800   GET X'80000000' IN R2 TO FLAG THE FIRST BIT OF*
                         THE LAST EDGE FIELD ON THE SPACE CONTROL AREA *
                         SUBPOOL CHAIN.
         ALR   R2,R1     SET THE ADDRESS IN IT.
         ICALL SETSPACE
         L     LKR,IGASA0+FOUR*THREE  RESTORE THE LINKAGE REGISTER.
         LM    R2,R12,IGASA0+FOUR*(THREE+FOUR)  ONLY PUT BACK THE      *
                         REGISTERS THAT ARE CHANGED AND IMPORTANT.
         BR    LKR       RETURN
         DROP  R15
         DROP  R1
         EJECT
***********************************************************************
* GSPACE FOR VARIABLE LENGTH RECORDS.                                 *
***********************************************************************
         RASS  (W0,R3,W1,R4,W2,R5,W3,R6,W4,R7,W5,R8,W6,R9,W7,R10)
***********************************************************************
* THIS IS THE ENTRY POINT FOR GSPACE FOR VARIABLE LENGTH ENTRIES WHEN *
* THE SPACE CONTROL ADDRESS IS CODED ON THE GSPACE MACRO-INSTRUCTION. *
* UPON ENTRY THE REGISTERS HAVE THE FOLLOWING CONTENTS:               *
*  R0:   SUBPOOL AND LENGTH OF THE REQUEST.                           *
*  R1:   THE ADDRESS OF THE SPACE CONTROL AREA.                       *
* LKR:   THE RETURN ADDRESS. BIT 0 OF LKR IS A ONE IF THE REQUEST IS  *
*        A CONDITIONAL REQUEST, OR IS A ZERO IF THE REQUEST IS AN     *
*        UNCONDITIONAL REQUEST.                                       *
* R15:   THE ADDRESS OF THE BASE OF THE MODULE IGARPT01.              *
***********************************************************************
     GODOWNTO  &IGAGSPS  SKIP DOWN TO THE ENTRY POINT.
         LTR   R1,R1     CHECK THE SPACE CONTROL ADDRESS TO SEE IF IT  *
                         IS REALLY THERE.
         BALR  R15,O
         USING *,R15
         BNZ   GSPACVAR  BRANCH IF IT REALLY IS THERE.
         B     GETSPACE  OTHERWISE TREAT IT AS IF IT ISN'T THERE.
         DROP  R15
***********************************************************************
* THIS IS THE ENTRY POINT FOR VARIABLE LENGTH GSPACE REQUESTS WHEN THE*
* SPACE CONTROL WORD IS NOT CODED ON THE GSPACE MACRO-INSTRUCTION.    *
* USE THE TCBRPT WORD TO FIND THE RIGHT ONE.                          *
* UPON ENTRY TO THIS SECTION THE REGISTERS HAVE THE FOLLOWING         *
* CONTENTS:                                                           *
* R0     THE LENGTH AND SUBPOOL FOR THE REQUEST.                      *
* R1     IS THE REGISTER THAT WILL CONTAIN THE ADDRESS OF THE SPACE   *
*        OBTAINED.                                                    *
* THE FIRST SECTION CHECKS TO SEE IF THE TCBRPT WORD IS FILLED IN, AND*
* INITIALIZES THE SPACE CONTROL AREA IF IT IS NOT.                    *
***********************************************************************
      GODOWNTO &IGAGSP  SKIP DOWN TO THE ENTRY POINT.
GETSPACE EQU   *         PROVIDE AN ENTRY POINT FROM THE GSPACE        *
                         MACRO-INSTRUCTION.
      RPTDSECT GEN=(TCBRPTA,(1))  GENERATE THE ADDRESS OF THE TCBRPT   *
                         WORD.
         SLR   R15,R15   GET SET TO CHECK TO SEE IF THE TCBRPT WORD IS *
                         FILLED IN ALREADY.
         CL    R15,O(O,R1)  CHECK THE TCBRPT WORD FOR ALL ZEROS, SAVING*
                         THE RESULT IN THE CONDITION CODE.
         BALR  R15,O     ESTABLISH ADDRESSABILITY FOR THE REST OF THE  *
                         PROGRAM.
         USING *,R15     NOW USE IT.
GSPACEB  JMP   8,FIRST1  JUMP IF THE TCBRPT WORD HAS NOT ALREADY BEEN  *
                         FILLED IN.
         L     R1,O(,R1)  LOAD THE CONTENTS OF THE TCBRPT WORD, WHICH  *
                         IS THE ADDRESS OF THE SPACE CONTROL AREA.
***********************************************************************
* CHECK THE SUBPOOL # IN THE SPACE CONTROL AREA TO SEE IF THE SUBPOOL *
* FOR THE REQUEST MATCHES IT. IF IT DOES EVERYTHING IS OKAY AND THE   *
* PROGRAM JUMPS TO GSPACVAR. IF THE SUBPOOLS DON'T MATCH, THEN LOOK   *
* DOWN THE CHAIN TO TRY TO FIND THE RIGHT ONE. IF ALL THAT ALSO FAILS,*
* THEN A NEW SPACE CONTROL AREA MUST BE ESTABLISHED FOR THE NEW SP#.  *
***********************************************************************
CHKSP#G  EQU   *
* IT IS RATHER AWKWARD THAT ONLY REGISTERS 1 AND 15 CAN BE USED AT THIS
* POINT.                                                              *
         CL    R0,=XL4'01000000'  SEE IF THE REQUEST IS FOR SUBPOOL 0.
         BL    GSPACVAR  BRANCH IF IT IS.
         USING IGASPCTL,R1
         LA    R1,IGASPEDG  GET THE ADDRESS OF THE ADDRESS OF THE NEXT *
                         8-BYTE ENTRY DEFINING A SPACE CONTROL AREA IF *
                         THERE IS ONE.
         DROP  R1
         DROP  R15
         BALR  R15,O     ESTABLISH ADDRESSABILITY AGAIN.
GSP#LOOP EQU   *
         USING GSP#LOOP,R15  USE THE STARTING ADDRESS OF THE LOOP AS   *
                         IT'S OWN BASE REGISTER SO THAT THE CONDITIONAL*
                         BRANCH TO CONTINUE THE LOOP CAN BE A BCR.
         USING IGASPC,R1  USE THE DSECT FOR THE SUBPOOL # CHAIN.
         TM    IGANXSP,IGASPFIN  SEE IF THIS IS THE LAST ONE ON THE    *
                         CHAIN.
         JMP   1,GSP#GONE JUMP IF IT IS THE LAST ONE, MEANING THE SPACE*
                         CONTROL AREA FOR THE REQUEST SUBPOOL ISN'T    *
                         THERE.
         L     R1,IGANXSP      GET THE NEXT EDGE FIELD TO THE NEXT ONE.
         L     R15,IGASPADR  ADDRESS OF THE SPACE CONTROL AREA, WITH   *
               IT'S SUBPOOL NUMBER IN THE LEFT BYTE.
         DROP  R15
         XR    R15,R0    COMPARE BY EXCLUSIVE-ORING.
         SRA   R15,24    SET THE CONDITION CODE.
         BALR  R15,O     ESTABLISH ADDRESSABILITY AGAIN.
         USING *,R15
         L     R15,=AL4(GSP#LOOP)  LOAD BACK THE ADDRESS OF THE START  *
               OF THE LOOP.
         DROP  R15
         USING GSP#LOOP,R15  USE IT AGAIN.
         JMP   7,(R15)   CONTINUE THE LOOP IF THE SUBPOOL NUMBERS DON'T*
               MATCH.
*        D O N E   F O U N D   I T . **********************************
         L     R1,IGASPADR  ADDRESS OF THE SPACE CONTROL AREA.
         DROP  R1
         DROP  R15
         EJECT
***********************************************************************
* THIS IS THE COMMON GSPACE ALLOCATION ROUTINE FOR VARIABLE LENGTH    *
* REQUEST SIZES. AT THIS POINT REGISTER R1 HAS THE ADDRESS OF THE     *
* APPROPRIATE SPACE CONTROL AREA IN IT.                               *
***********************************************************************
GSPACVAR EQU   *         COME HERE FOR VARIABLE LENGTH RECORDS.
         BALR  R15,O
         USING *,R15
         L     R15,ADDRESS
         DROP  R15
         USING &PROGRAM,R15  USE THE REAL BASE REGISTER NOW.
*---------------------------------------------------------------------*
         USING SAVEDSEK-&IGASA0,R1  ESTABLISH ADDRESSABILITY TO THE    *
                         FIRST SAVE AREA IN THE SPACE CONTROL AREA.
         STM   LKR,R12,GPR14   SAVE THE REGISTERS IN THE INNER TREE
         ST    R13,BACKEDGE    SAVE AREA, SAVE R13 IN THE BACKEDGE IN
         L     R13,FORWARD  THE OUTER SAVE AREA AND TRACE THE
         DROP  R1        EDGE TO THE INNER SAVE AREA.
         USING SAVEDSEK,R13  R13 NOW HAS THE ADDRESS OF THE INNER SAVE *
                         AREA.
* --------------------------------------------------------------------*
         USING IGASPCTL,R1  USE THE IGAROUND MASK TO ROUND THE REQUEST *
                         TO THE PROPER BOUNDARY.
         SL    REQL,IGAROUND  FIRST ADD IN THE APPROPRIATE POWER OF TWO*
                         BY SUBTRACTING ITS COMPLEMENT.
         BCTR  REQL,O    NOW SUBTRACT ONE FOR A NET PLUS OF ONE LESS   *
                         THAN THE APPROPRIATE POWER OF TWO.
         N     REQL,IGAROUND  NOW KNOCK OFF THE LOWER ORDER BITS THAN  *
                         ARE IMPORTANT.
         DROP  R1
         JMP   8,RCODE0  NOW JUMP IMMEDIATELY TO THE EXIT IF THE       *
                         ROUNDED REQUEST IS ZERO.
*---------------------------------------------------------------------*
         USING TREEHDR,R1  NOW USE THE TREE HEADER.
         LR    W1,REQL         SAVE THE REQUEST LENGTH FOR LATER.
         ICALL POVSRCH   EXECUTE THE SEARCH FOR A SINK WITH A POV
*                              LARGE ENOUGH TO SATISFY THE REQUEST.
         LTR   W0,R15    SAVE THE ADDRESS OF THE FREE SPACE SO OBTAINED
         L     R15,IGADDR      AND TEST IT TO SEE IF THERE IS ONE
         JMP   4,NOTENUF       LARGE ENOUGH.
*---------------------------------------------------------------------*
         L     W2,IGAVALUE     COMPUTE THE LENGTH THAT THE AREA WILL
         SLR   W2,REQL         HAVE AFTER THE ALLOCATION HAS BEEN MADE.
         LA    W3,O(W0,W2)     COMPUTE THE ADDRESS OF THE AREA TO BE
*                              ALLOCATED BY ADDING THE RESIDUAL LENGTH
*                              TO THE ADDRESS OF THE BEGINNING OF THE
*                              FREE AREA.
         LR    REQL,W2         ADJUST THE POV FOR THE FREE AREA
         ICALL (&IGANAME+&IGAPVAJ)  REMAINING TO MAKE IT THE RESIDUAL  *
                         LENGTH.
         L     R15,IGADDR  RESTORE THE BASE REGISTER FOR THIS SECTION.
*---------------------------------------------------------------------*
         LTR   REQL,REQL       NOW SEE IF THE RESIDUAL LENGTH IS ZERO,
         JMP   7,NOTEXACT      BECAUSE IF IT IS THE SINK GETS DELETED.
         ICALL DEL8      DELETE THE SINK.
*---------------------------------------------------------------------*
NOTEXACT EQU   *
         LR    R1,W3     PUT THE ADDRESS OF THE ALLOCATED AREA IN R1.
VAROUT   EQU   *  MERGE WITH A COMMON PATH HERE.
         LR    REQL,W1   PUT THE LENGTH OF THE ALLOCATED AREA IN R0.
         LEAF  SAVE=(LKR,(R2,R12)),LV=-0,RC=0  SET THE RETURN CODE TO  *
                         ZERO TO SIGNAL A SUCCESSFUL ALLOCATION.
***********************************************************************
* THERE IS NO FREE AREA LARGE ENOUGH TO SATISFY THE REQUEST, GET MORE.*
***********************************************************************
NOTENUF  EQU   *
         L     W4,IGA9FILL     LOAD THE SUBPOOL # AND REFILL SIZE FOR  *
               THE TYPE 9 VARIABLE LENGTH SPACE ALLOCATION TREE.
         LA    W5,O(O,W4)      CHECK THE SIZE OF THE REQUEST TO SEE IF
         CLR   W5,W1           IT IS LESS THAN OR EQUAL TO THE REFILL
         JMP   10,REFISOK      LENGTH; BRANCH IF IT IS.
         SLR   W4,W5     IT'S NOT, MAKE THE REFILL SIZE LARGER.
         LA    W5,X'FFF'(,W1)  ROUND THE REQUEST SIZE UP TO THE NEXT   *
                         EXACT MULTIPLE OF A PAGE (4096 BYTES).
         N     W5,=XL4'FFFFF000'  KNOCK OFF THE REDUNDANT LOW ORDER    *
                         BITS.
         ALR   W4,W5           GETMAIN DOES THIS ANYWAY, WHY WASTE THE
*                              SPACE?
         ST    W4,IGA9FILL     STORE THE ADJUSTED REFILL SIZE.
*---------------------------------------------------------------------*
REFISOK  EQU   *
         L     HDB,HVFC        NOW CHECK TO SEE IF THERE IS A SPACE TO
*                              STORE THE BLOCK DEFINITION WORD FOR IT.
         USING FIXEDHDR,HDB    THE SPACE FOR THE BLOCK DEFINITION WORD
         L     W6,HEADFREE     IS TAKEN FROM THE INNER VERTEX FREE
         LTR   W6,W6           SPACE CHAIN.
         JMP   2,NOGETINR      JUMP IF IT'S THERE.
         STM   R15,R10,GPR15   CHAIN EMPTY, GET MORE.
         L     LKR,=AL4(NEEDMORE)  ADDRESS OF THE NEEDMORE ROUTINE.
         BALR  LKR,LKR  GET MORE.
         LM    R15,R10,GPR15   ON TO THE INNER SPACE CHAIN.
         L     W6,HEADFREE     GET THE NEW CHAIN HEAD.
*---------------------------------------------------------------------*
NOGETINR EQU   *
         MVC   HEADFREE,O(W6)  DECAPTITATE THE CHAIN.
         USING BLOCKHDR,W6     SET UP THE BLOCK DEFINITION WORD.
         L     R0,IGA9FILL     SUBPOOLAND REFILL SIZE.
       GETMAIN R,LV=(0)        GET THE ADDITIONAL SPACE.
         STM   R0,R1,BSPL      STORE THE BLOCK DEFINITION.
         MVC   BEDGE,BLOKHEAD  PUT THE NEW BLOCK ON THE BLOCK CHAIN.
         ST    W6,BLOKHEAD     XX
         DROP  W6
         DROP  HDB
*  NOW COMPUTE THE RESIDUAL LENGTH.                                   *
         LR    W7,R1           ADDRESS OF THE AREA OBTAINED.
         L     R1,((4*R1)+20-64*((2+R1)/16))(,R13)  PUT THE ADDRESS OF *
                         THE TYPE 9 SPACE CONTROL RPT BACK IN R1.
         L     R15,IGADDR      RESTORE THE PROGRAM BASE REGISTER.
         SR    W5,W1           COMPUTE THE RESIDUAL LENGTH.
         JMP   8,THATSIT       JUMP IF THE RESIDUAL SIZE IS ZERO.
* THE RESIDUAL LENGTH IS NOT ZERO, INSERT THE NEW SINK WITH IT POV.   *
         ST    W7,IGAVALUE  USE THIS AS A TEMPORARY WORK AREA FOR THE  *
                         NEW KEY, WHICH IS THE SAME AS THE ADDRESS OF  *
                         THE AREA.
         LA    R0,IGAVALUE  ADDRESS OF SEARCH KEY.
         BAL   LKR,SRCH8       SEARCH FOR THE INSERTION POINT.
         ST    R15,KEYWORK     STORE THE SINK ADDRESS FOUND.
         DROP  R15
         L     LKR,IGADDR  RESTORE THE ADDRESS OF THE MODULE.
         USING &IGANAME,LKR
         LA    R0,KEYWORK      ADDRESS OF THE FOUND KEY.
         ST    R0,FARG         STORE IT THERE FOR INSERT.
         L     R0,IGAVALUE  LOAD THE ACTUAL SINK WORD TO BE INSERTED.
         LA    R15,IGAVALUE  GET THE ADDRESS OF THE KEY TO BE INSERTED.
         BAL   LKR,INS8        INSERT THE NEW AREA.
         DROP  LKR       USE THE REVISED ADDRESS IN THE LINKAGE
         USING *,LKR     REGISTER FOR THE NEW BASE REGISTER ADDRESS.
         LR    REQL,W5         GET THE RESIDUAL LENGTH TO STORE IN THE
         ICALL (&IGANAME+&IGAPVAJ)  TREE FOR ITS NEW PARTIAL ORDER     *
                         VALUE.
         DROP  LKR
         USING &IGANAME,R15
         L     R15,IGADDR  RESTORE THE BASE REGISTER FOR THIS SECTION.
THATSIT  EQU   *         THAT'S IT, ALL DONE NOW EXCEPT FOR CLEANUP.
         LA    R1,O(W5,W7)  GET THE ADDRESS OF THE AREA ALLOCATED TO   *
                         THE USER PROGRAM.
         JMP   15,VAROUT       MERGE WITH THE COMMON EXIT PATH.
         DROP  R15
***********************************************************************
* HERE IS AN AGORONOMIC ROUTINE TO SET THE RETURN CODE TO ZERO,       *
* RESTORE ALL THE REGISTERS, AND RETURN, AFTER TRACING THE SAVE AREA  *
* CHAIN BACK ONE LEVEL FROM THE INNER TO THE OUTER SAVE AREA.         *
RCODE0   EQU   *        COME HERE FROM THE ENTRY TO THE GSPACE ROUTINE.
         L     R13,BACKWORD  TRACE BACK TO THE PREVIOUS LEVEL SAVE     *
                         AREA.
         XC    GPR15,GPR15  SET THE RETURN CODE TO ZERO.
LMBR14   LM    LKR,R12,GPR14  RESTORE ALL THE REGISTERS.
         L     R13,BACKWORD  RESTORE R13 TO IT'S ORIGINAL VALUE.
         BR    LKR       NOW RETURN.
         DROP  R1
         DROP  R13
          EJECT
***********************************************************************
* THIS IS THE ROUTINE TO ALLOCATE AN 8-BYTE FIXED LENGTH AREA USING   *
* THE FIXEDHDR FOR 8-BYTE ENTRIES IN THE SPACE CONTROL AREA.          *
* UPON ENTRY THE REGISTERS HAVE THE FOLLOWING CONTENTS:               *
*  R1:   THE ADDRESS OF THE SPACE CONTROL AREA.                       *
* LKR:   THE RETURN ADDRESS. BIT 0 OF LKR IS A 1 IF THE REQUEST IS    *
*        CONDITIONAL, OR IS A 0 IF THE REQUEST IS AN UNCONDITIONAL    *
*        REQUEST.                                                     *
***********************************************************************
      GODOWNTO &IGAGS8
         USING  FIXEDHDR-&IGAS8,R1  USE THE SPACE CONTROL AREA.
          L    R15,HEADFREE  LOAD THE CURRENT HEAD OF THE FREE SPACE   *
                         CHAIN.
         L     R0,O(,R15)  GET THE NEXT ADDRESS ON THE CHAIN (IF THERE *
                         IS ONE).
         ST    R0,HEADFREE  STORE THE NEW HEAD OF THE CHAIN.
         LA    R1,O(,R15)  CLEAR THE HIGH ORDER BYTE SO AS TO TEST THE
         SR    R15,R1    HIGH ORDER BIT IN THE ADDRESS OBTAINED TO SEE
         JMP   8,(LKR)   IF THE ALLOCATION IS SUCCESSFUL.
         LA    R0,&IGAS8  THE ALLOCATION FAILED, NOW USE THE COMMON    *
                         ROUTINE TO REFILL THE FIXEDHDR.
         BALR  R15,O     ESTABLISH ADDRESSABILITY.
         USING *,R15
         B     IGACOMNG  BRANCH TO THE COMMON ROUTINE FOR REFILLING.
         DROP  R15
         DROP  R1
         EJECT
***********************************************************************
* THIS IS THE ROUTINE TO ALLOCATE A 12-BYTE FIXED LENGTH AREA USING   *
* THE FIXEDHDR FOR 12-BYTE ENTRIES IN THE SPACE CONTROL AREA.         *
* UPON ENTRY THE REGISTERS HAVE THE FOLLOWING CONTENTS:               *
*  R1:   THE ADDRESS OF THE SPACE CONTROL AREA.                       *
* LKR:   THE RETURN ADDRESS. BIT 0 OF LKR IS A 1 IF THE REQUEST IS    *
*        CONDITIONAL, OR IS A 0 IF THE REQUEST IS AN UNCONDITIONAL    *
*        REQUEST.                                                     *
***********************************************************************
       GODOWNTO &IGAGS12
         USING  FIXEDHDR-&IGAS12,R1 USE THE SPACE CONTROL AREA.
          L    R15,HEADFREE  LOAD THE CURRENT HEAD OF THE FREE SPACE   *
                         CHAIN.
         L     R0,O(,R15)  GET THE NEXT ADDRESS ON THE CHAIN (IF THERE *
                         IS ONE).
         ST    R0,HEADFREE  STORE THE NEW HEAD OF THE CHAIN.
         LA    R1,O(,R15)  CLEAR THE HIGH ORDER BYTE SO AS TO TEST THE
         SR    R15,R1    HIGH ORDER BIT IN THE ADDRESS OBTAINED TO SEE
         JMP   8,(LKR)   IF THE ALLOCATION IS SUCCESSFUL.
         LA    R0,&IGAS12 THE ALLOCATION FAILED, NOW USE THE COMMON    *
                         ROUTINE TO REFILL THE FIXEDHDR.
         BALR  R15,O     ESTABLISH ADDRESSABILITY.
         USING *,R15
         B     IGACOMNG  BRANCH TO THE COMMON ROUTINE FOR REFILLING.
         DROP  R15
         DROP  R1
          EJECT
***********************************************************************
* THIS IS THE ROUTINE TO ALLOCATE AN 80-BYTE FIXED LENGTH AREA USING  *
* THE FIXEDHDR FOR 80-BYTE ENTRIES IN THE SPACE CONTROL AREA.         *
* UPON ENTRY THE REGISTERS HAVE THE FOLLOWING CONTENTS:               *
*  R1:   THE ADDRESS OF THE SPACE CONTROL AREA.                       *
* LKR:   THE RETURN ADDRESS. BIT 0 OF LKR IS A 1 IF THE REQUEST IS    *
*        CONDITIONAL, OR IS A 0 IF THE REQUEST IS AN UNCONDITIONAL    *
*        REQUEST.                                                     *
***********************************************************************
       GODOWNTO &IGAGS80
         USING  FIXEDHDR-&IGAS80,R1 USE THE SPACE CONTROL AREA.
          L    R15,HEADFREE  LOAD THE CURRENT HEAD OF THE FREE SPACE   *
                         CHAIN.
         L     R0,O(,R15)  GET THE NEXT ADDRESS ON THE CHAIN (IF THERE *
                         IS ONE).
         ST    R0,HEADFREE  STORE THE NEW HEAD OF THE CHAIN.
         LA    R1,O(,R15)  CLEAR THE HIGH ORDER BYTE SO AS TO TEST THE
         SR    R15,R1    HIGH ORDER BIT IN THE ADDRESS OBTAINED TO SEE
         JMP   8,(LKR)   IF THE ALLOCATION IS SUCCESSFUL.
         LA    R0,&IGAS80 THE ALLOCATION FAILED, NOW USE THE COMMON    *
                         ROUTINE TO REFILL THE FIXEDHDR.
DPFGS80  EQU   (((16*((*+15-&IGANAME)/16))-(*+6-&IGANAME))/2)
         DC    (DPFGS80)XL2'0700'  PUT IN NOPR'S UP TO THE SIX BYTES IN*
                         FRONT OF THE ROUTINE FOR ANY FIXEDHDR.
         DROP  R1
***********************************************************************
* COME HERE FROM THE GSPACE MACRO-INSTRUCTION TO GET A FIXED LENGTH   *
* ENTRY USING A FIXEDHDR. THE REGISTERS CONTAIN THE FOLLOWING UPON    *
* ENTRY:                                                              *
*   R0   IGNORED.                                                     *
*   R:  THE ADDRESS OF THE FIXEDHDR TO BE USED FOR ALLOCATING THE    *
*        SPACE.                                                       *
*   LKR  THE RETURN ADDRESS.                                          *
* IF LKR HAS BEEN SET WITH A BALR, THEN THE REQUEST IS A CONDITIONAL  *
* REQUEST, BUT IF LKR HAS BEEN SET WITH A BAL THE REQUEST IS AN       *
* UNCONDITIONAL REQUEST. IF THE REQUEST IS SATISFIED, THE RETURN CODE *
* IS SET TO ZERO, AND THE CONDITION CODE IS SET TO GREATER THAN ZERO. *
* IF THE REQUEST IS NOT SATISFIED, THE RETURN CODE IS SET TO FOUR, AND*
* THE CONDITION CODE IS SET TO NEGATIVE.                              *
***********************************************************************
       GODOWNTO &IGAGSPF
         ORG   *-6
IGACOMNG ALR   R1,R0     GET THE ADDRESS OF THE FIXEDHDR.
         LA    R15,O(,R1)  PUT THE ADDRESS OF THE FIXEDHDR IN R15.
IGAGSPAC EQU   *
         USING FIXEDHDR,R1
LOADNEXT L     R15,HEADFREE  LOAD THE CURRENT HEAD OF THE FREE SPACE   *
                         CHAIN.
         L     R0,O(,R15)  GET THE ADDRESS OF THE NEXT AREA ON THE FREE*
                         SPACE CHAIN.
         ST    R0,HEADFREE  STORE THE NEW HEAD OF THE FREE SPACE CHAIN *
                         IF THE ALLOCATION WAS SUCCESSFUL.
         LA    R1,O(,R15)  CLEAR THE HIGH ORDER BYTE IN ORDER TO TEST  *
                         THE ALLOCATION TO SEE IF IT WAS SUCCESSFUL.
         SR    R15,R1    SUBTRACT THE ADDRESS, SO THAT THE RESULT IS   *
                         ZERO IF THE HIGH ORDER BIT IN THE ADDRESS FROM*
                         THE CHAIN WAS ZERO.
         BCR   8,LKR     RETURN TO THE CALLING ROUTINE IF THE          *
                         ALLOCATION WAS SUCCESSFUL.
         DROP  R1
***********************************************************************
* TOO BAD, THIS IS ONE OF THOSE RARE CASES WHERE THERE ISN'T ANY MORE *
* SPACE LEFT ON THE CHAIN. NOW THE ROUTINE TO GET MORE SPACE HAS TO BE*
* EXECUTED.                                                           *
***********************************************************************
*                                                                     *
* NOW RE-ESTABLISH THE ADDRESS OF THE SPACE CONTROL AREA BY LOOKING   *
* FOR THE FIXEDHDR FOR 80-BYTE ENTRIEW, THEN SUBTRACTING THE          *
* DIFFERENCE BETWEEN THE FIXEDHDR FOR 80-BYTE ENTRIES AND THE         *
* BEGINNING OF THE SPACE CONTROL AREA.                                *
         LR    R0,R1     SAVE THE ADDRESS OF THE FIXEDHDR.
         BALR  R15,O     RE-ESTABLISH ADDRESSABILITY.
         USING *,R15
GFIXDUSE EQU   *
         JMP   15,FIXEDCLI  GO CHECK FOR THE 80-BYTE FIXEDHDR.
         DROP  R15
***********************************************************************
         USING GFIXDUSE,R15    NOW USE THE BASE REGISTER THAT WAS SET  *
                               UP TO USE FOR IT.
         USING FIXEDHDR,R1
FIXEDLA  LA    R1,SIXTEEN(O,R1)  ADD SIXTEEN TO THE ADDRESS.
FIXEDCLI CLI   FIXDRECL+THREE,EIGHTY  SEE IF THE LENGTH IS 83.
         JMP   4,FIXEDLA  CONTINUE THE LOOP IF IT IS NOT.
         SL    R1,=AL4(&IGAS80)  SUBTRACT THE FUDGE FACTOR TO GET THE  *
                         ADDRESS OF THE SPACE CONTROL AREA.
         DROP  R1
         STM   LKR,R12,(&IGASA0+((4*LKR)+20-64*((2+LKR)/16)))(R1)      *
                         SAVE THE REGISTERS IN SAVE AREA 0 IN THE SPACE*
                         CONTROL AREA.
         ST    R13,(&IGASA0+FOUR)(,R1)  STORE THE SAVE AREA BACK CHAIN *
                         ADDRESS.
         LA    R13,&IGASA0.(,R1)  GET THE ADDRESS OF THE CURRENT (I. E.*
                         LAST USED) SAVE AREA.
         N     LKR,X800  KNOCK OFF ALL BUT THE FIRST BIT IN THE LKR, IT*
                         IS A ONE IF THE REQUEST IS AN UNCONDITIONAL   *
                         GSPACE.
         AL    LKR,COMEBACK  GET THE RETURN ADDRESS FROM THE ROUTINE TO*
                         GET MORE SPACE ON THE FREE SPACE CHAIN.
         LR    HDB,R0    SET UP THE FIXEDHDR ADDRESS FOR THE ROUTINE TO*
                         GET MORE SPACE.
         B     NEEDMORE  GO GET SOME MORE SPACE FOR THE FIXED LENGTH   *
                         CHAIN.
         CNOP  0,4
COMEBACK DC    AL4(COMEBACK+X'04')
         USING SAVEDSEK,R13  USE THE NEW SAVE AREA ADDRESS TO BACK UP  *
                         TO THE USER'S SAVE AREA (IF HE HAS ONE).
         LM    LKR,R12,GPR14  RESTORE THE REGISTERS.
         L     R13,BACKWARD  TRACE THE EDGE BACK TO THE PREVIOUS SAVE  *
                         AREA.
         DROP  R13
         LR    R1,R0     GET THE ADDRESS OF THE FIXEDHDR BACK.
         USING FIXEDHDR,R1
         L     R0,HEADFREE  GET THE NEW HEAD OF THE FREE SPACE CHAIN.
         LTR   R0,R0     SEE IF THE ALLOCATION WAS SUCCESSFUL.
         L     R15,ADDRESS  RESTORE THE PROGRAM BASE REGISTER.
         DROP  R15
         USING &PROGRAM,R15  USE THE REAL BASE AGAIN.
         JMP   2,LOADNEXT  JUMP IF THE ALLOCATION WAS SUCCESSFUL.
         LA    R15,FOUR  THE ALLOCATION WAS UNSUCCESSFUL, SET THE      *
                         RETURN CODE TO FOUR.
         SLR   R1,R1   PUT A ZERO IN R1, SO THE ADDRESS IS NOT USEABLE.
         BCTR  R1,O      SUBTRACT ONE, SO THAT THE ADDRESS IS NEGATIVE *
                         ONE WHEN IT IS RETURNED.
         LTR   R0,R1     SET THE CONDITION CODE NEGATIVE TO SIGNAL THE *
                         ALLOCATION FAILED.
         JMP   15,(LKR)  RETURN TO THE GSPACE MACRO.
         DROP  R15       NO MORE NEED FOR THIS ONE NOW.
         DROP  R1              DROP THE TREE BASE REGISTER.
***********************************************************************
* ENTRY POINT FOR VARIABLE LENGTH FSPACE REQUESTS WHEN THE SPACE      *
* CONTROL ADDRESS IS NOT EXPLICITLY CODED ON THE FSPACE               *
* MACRO-INSTRUCTION HEADER.                                           *
***********************************************************************
*                                                                     *
      GODOWNTO &IGAFSP
***********************************************************************
* THE REGISTER CONTENTS UPON ENTRY ARE AS FOLLOWS:                    *
*                                                                     *
*  R0:   SUBPOOL AND REQUEST LENGTH.                                  *
*  R1:   THE ADDRESS OF THE AREA TO BE RELEASED.                      *
*  LKR:  THE RETURN ADDRESS FROM THE CALLING PROGRAM.                 *
*  R15:  THE CONTENTS OF REGISTER 15 ARE IGNORED.                     *
***********************************************************************
         LA    R15,O(,R1)  SEE IF THE ADDRESS OF THE AREA TO BE        *
                         RELEASED IS ZERO.
         LTR   R15,R15   XX
         BCR   8,LKR     EXIT WITH THE RETURN CODE ZERO IF THE ADDRESS *
                         OF THE AREA TO RELEASE IS ZERO.
      RPTDSECT GEN=(TCBRPTA,15)  GET SET TO FIND THE APPROPRIATE SPCA  *
                         IN THE TCB-ADDRESSED COLLECTION.
         L     R15,O(,R15)  GET THE CONTENTS OF THE TCBRPT WORD.
         BCTR  R15,O     SUBTRACT ONE SO THAT IF IT IS ZERO THE RESULT *
                         IS NEGATIVE.
         LTR   R15,R15   SEE IF THE TCBRPT WORD IS FILLED IN.
         BCR   4,LKR     RETURN WITH RETURN CODE -1 IF THE WORD IS NOT *
                         FILLED IN.
***********************************************************************
* THE TCBRPT WORD HAS BEEN INITIALIZED, USE SAVE AREA 0 IN THE SPCA TO*
* SAVE THE REGISTERS.                                                 *
***********************************************************************
         STM   LKR,R12,(ONE+&IGASA0+((X'04'*LKR)+X'14'-X'40'*((2+LKR)/1*
               6)))(R15)  SAVE THE REGISTERS.
         ST    R13,(FIVE+&IGASA0)(,R15)  STORE THE BACKWARD EDGE FIELD *
                         FOR THE SAVE AREA CHAIN.
         LA    R13,(ONE+&IGASA1)(,R15)  GET THE ADDRESS OF THE SAVE    *
                         AREA TO USE IN FSPACE.
         LR    F2,R1     SAVE THE ADDRESS OF THE AREA TO BE RELEASED.
         LA    F1,ONE(,R15)  GET THE ADDRESS OF THE SPCA FOR SUBPOOL   *
                         ZERO.
         L     R15,&IGADDR.(,F1)  GET THE ADDRESS OF THE BASE OF THE   *
                         MODULE.
         USING &IGANAME,R15  USE THE BASE OF THE MODULE FOR            *
                         ADDRESSABILITY.
         CL    R0,=XL4'01000000'  SEE IF THE REQUEST SUBPOOL IS ZERO.
         BL    FSPACVAR  BRANCH IF THE REQUEST IS FOR SUBPOOL ZERO.
         LR    F3,R0     GET THE REQUEST SUBPOOL #
         SRL   F3,24     AND PUT IT IN THE RIGHT BYTE OF THE REGISTER.
         SLR   F4,F4     MAKE THE LEFT THREE BYTES ZERO FOR THE        *
                         SUBSEQUENT INSERT CHARACTER INSTRUCTION.
         USING IGASPCTL,F1  F1 HAS THE SPCA ADDRESS IN IT.
         L     F5,IGASPEDG  LOAD THE EDGE FIELD TO THE FIRST 8-BYTE    *
                         ENTRY ON THE SPCA CHAIN.
         DROP  F1        FROM NOW ON F1 IS SET TO THE ADDRESS OF EACH  *
                         CURRENT SPCA AS THE SEARCH FOR THE RIGHT      *
                         SUBPOOL PROGRESSES.
ZFSPLOOP LTR   F5,F5  CHECK FOR THE LAST DOUBLE WORD ON THE SPCA CHAIN.
         BM    NULLEXIT  EXIT WITH A RETURN CODE -1 IF THE SPCA FOR THE*
                         SUBPOOL CAN NOT BE FOUND.
         USING IGASPC,F5  USE F5 FOR THE BASE OF THE 8-BYTE ENTRY.
         IC    F4,IGASPADR  GET THE SUBPOOL # FOR THE CURRENT SPCA.
         L     F1,IGASPADR  GET THE ADDRESS OF THE CURRENT SPCA.
         CLR   F3,F4     SEE IF THE REQUEST SUBPOOL IS EQUAL TO THE    *
                         SPCA SUBPOOL.
         BE    FSPACVAR  BRANCH IF THE RIGHT SPCA HAS BEEN FOUND.
         B     ZFSPLOOP  CONTINUE IF THE SPCA HAS NOT YET BEEN FOUND.
         DROP  F5
         DROP  R15
***********************************************************************
* ENTRY POINT FOR VARIABLE LENGTH ENTRIES FROM THE FSPACE MACRO WHEN  *
* THE SPACE CONTROL ADDRESS IS CODED IN THE FSPACE MACRO.             *
***********************************************************************
      GODOWNTO &IGAFSPS
         USING SAVEDSEK-&IGASA0,R15  USE THE SAVE AREA IN THE CONTROL  *
                         AREA.
         STM   LKR,R12,GPR14   SAVE THE REGISTERS.
         ST    R13,BACKWORD    FILL IN THE BACK CHAIN EDGE FOR THE SAVE*
                         AREA CHAIN.
         DROP  R15
         USING IGASPCTL,R15    ADDRESS THE SPACE CONTROL AREA.
         LA    R13,IGASA1  ESTABLISH THE SAVE AREA FOR THE VARIABLE    *
                         LENGTH SPACE ALLOCATION ROUTINES.
         DROP  R15
         LA    R1,0(,R1) CLEAR LEFT BYTE
         LTR   F2,R1     TEST THE ADDRESS TO BE RELEASED.
         LR    F1,R15    ADDRESS OF THE SPACE CONTROL AREA.
         L     R15,O(,R15)     GET THE ADDRESS OF IGARPT01.
         USING &PROGRAM,R15
         JMP   8,NULLEXIT  EXIT IMMEDIATELY IF THE ADDRESS IS ZERO.
         DROP  R15
         EJECT
***********************************************************************
* FSPACE SUBROUTINE FOR VARIABLE LENGTH AREAS                         *
*                                                                     *
* THE REGISTER CONTENTS UPON ENTRY TO THIS SECTION ARE AS FOLLOWS:    *
*                                                                     *
*  R0:   THE LENGTH OF THE AREA TO BE RELEASED.                       *
*  R1:   THE ADDRESS OF THE SPACE CONTROL AREA.                       *
*  F2:   THE ADDRESS OF THE AREA TO BE RELEASED.                      *
*  R13:  THE ADDRESS OF SAVE AREA 1 IN THE SPCA.                      *
*  R15:  THE BASE REGISTER FOR THIS SECTION, CONTAINING THE ADDRESS OF*
*        THE BASE OF THE MODULE.                                      *
***********************************************************************
FSPACVAR EQU   *
         RASS  (F0,R0,F1,R1,F2,R2,F3,R3,F4,R4,F5,R5,F6,R6,F7,R7)
         RASS  (F8,R8,F9,R9,F10,R10,F11,R11,F12,R12,F15,R15)
         USING &PROGRAM,F15    PROGRAM BASE REGISTER.
         USING SAVEDSEK,R13    OUTER SAVE AREA.
         USING IGASPCTL,R1  NOW ROUND THE REQUEST UP TO A MULTIPLE OF  *
                         THE APPROPRIATE POWER OF TWO.
         SL    REQL,IGAROUND  ADD THE APPROPRIATE POWER OF TWO TO THE  *
                         REQUEST LENGTH BY SUBTRACTING ITS COMPLEMENT.
         BCTR  REQL,O    NOW SUBTRACT ONE FOR A NET PLUS OF ONE LESS   *
                         THAN THE POWER OF TWO.
         N     REQL,IGAROUND  NOW KNOCK OFF THE REDUNDANT LOW ORDER    *
                         BITS.
         DROP  R1
         USING TREEHDR,F1
         LR    F3,REQL         LENGTH OF THE AREA TO FREE UP.
         LA    F4,O(F2,F3)     ADD THE LENGTH TO THE ADDRESS TO GET THE
         ST    F4,IGAWORK  ADDRESS OF THE BYTE JUST PAST THE AREA
*                              TO BE FREED.
         LA    F0,IGAWORK  GET THE ADDRESS FOR THE SEARCH.
         BAL   LKR,SRCH8       SEARCH FOR THE ADDRESS JUST PAST IT.
         ST    F2,IGAWORK  STORE THE NEW ADDRESS BACK IN.
         LTR   F5,F15    GET THE ADDRESS FOUND BY SEARCH.
         L     F15,IGADDR      SEE IF THE TREE IS EMPTY.
         JMP   4,FRINS         JUMP TO INSERT IT IF THE TREE IS EMPTY.
         CLR   F4,F5           SEE IF THE AREA JUST TO THE RIGHT OF THE
         JMP   8,FREQUAL       AREA TO BE FREED IS ALSO FREE.
         BC    4,FRSCANL       BRANCH IF IT FOUND SOME AREA TO THE
*                              RIGHT OF THE AREA TO BE FREED.
*---------------------------------------------------------------------*
LMFRLOOP EQU   *         LOOP TO FIND AREA TO NEW'S LEFT.
         LM    F6,F9,APT  CAPTURE THE CURRENT CURSOR SETTING TOGETHER  *
                         WITH P AND C.
         ICALL (&IGANAME+&IGARSCN)  SCAN OVER TO FIND THE AREA JUST TO *
                         THE
         ST    R15,FARG        LEFT OF THE AREA TO FREE.
         L     R15,IGADDR      RESTORE THE PROGRAM BASE REGISTER.
         JMP   4,FOUNDIT       JUMP IF IT WENT OFF THE RIGHT END.
         CL    F2,FARG         SEE IF F4 IS STILL TO THE RIGHT OF FARG.
         BC    2,LMFRLOOP      BRANCH IF SCANR DID'T PASS IT YET.
FOUNDIT  EQU   *  COME HERE WHEN SCANR HAS GONE PAST THE LARGEST AREA
*                 AREA THAT DOES NOT EXCEED THE AREA TO BE FREED.
         STM   F6,F9,APT       RESTORE THE PATH TO LAST TIME.
         ICALL (&IGANAME+&IGAPVG)  GET THE SINK'S POV ON THIS PATH.
         L     R15,IGADDR  RESTORE THE BASE REGISTER.
FRAFTPOV EQU   *         THIS IS AFTER THE POV HAS BEEN FOUND IN REQL.
         LR    F10,REQL        SEE IF THE AREA JUST TO THE LEFT OF THE
         ALR   F10,F9          THE NEW AREA IS ADJACENT TO IT.
         CLR   F2,F10    XX
         JMP   7,FSRCHINS      JUMP IF THE NEW AREA DOES NOT.
*                              COMBINE WITH THE AREA ON ITS LEFT.
         ALR   F0,F3           THE NEW AREA COMBINES WITH THE AREA ON
         ICALL (&IGANAME+&IGAPVAJ)  ITS LEFT, ADJUST THE POV OF THE    *
                         AREA ON
*                              THE LEFT TO BE THE SUM OF THE TWO
*                              LENGTHS.
VARFEXIT EQU   *         ALL DONE, NOW BACK OUT.
         L     R13,BACKEDGE    GO BACK TO THE INNER TREE.
         LM    LKR,R12,GPR14   RESTORE THE REGISTER FROM THE INNER
         L     R13,BACKEDGE    SAVE AREA, RESTORE R13 TO ITS ORIGINAL
         SR    R15,R15   SET RETURN CODE TO ZERO AND SET
         JMP   15,(LKR)  CONDITION CODE TO AGREE WITH THE RETURN CODE.
NULLEXIT LEAF  RC=-1,LV=-0 ADDRESS IS ZERO. NOTHING TO RELEASE
***********************************************************************
* THE NEW AREA BEING FREED DOESN'T COMBINE WITH THE AREA ON ITS LEFT, *
* INSERT IT AS A NEW SINK IN THE OUTER TREE AND PUT IN ITS POV.       *
***********************************************************************
FSRCHINS EQU   *         SEARCH AND INSERT NEW AREA.
FRINS    EQU   *  COME HERE.
         LA    F0,IGAWORK  GET THE ADDRESS FOR THE SEARCH.
         BAL   LKR,SRCH8       SEARCH FOR THE INSERTION POINT.
         ST    F15,IGAVALUE  STORE THE ADDRESS RETRIEVED BY SEARCH.
         LA    F15,IGAVALUE  GET THE ADDRESS OF THE FOUND KEY FOR THE  *
               INSERT ROUTINE.
         ST    F15,IGAFARG  STORE THE ADDRESS OF THE FOUND KEY.
         L     LKR,IGADDR  LOAD THE ADDRESS OF THE BASE OF THE MODULE.
         DROP  R15
         USING &IGANAME,LKR  USE THE LKR TO ADDRESS THINGS.
         LR    R0,F2     GET THE ADDRESS TO ASSOCIATE WITH THE KEY.
         LA    R15,IGAWORK  GET THE ADDRESS OF THE KEY (WHICH IS ALSO  *
                         AN ADDRESS).
         LA    LKR,INS8  GET THE ADDRESS OFN  OF THE TYPE 8 RPT INSERT *
                         SUBROUTINE.
         BALR  LKR,LKR   LINK TO THE INSERT ROUTINE.
         DROP  LKR       NOW GO BACK TO THE OTHER BASE REGISTER.
         L     F15,IGADDR      RESTORE THE PROGRAM BASE REGISTER.
         USING &IGANAME,R15
         LR    REQL,F3         GET THE LENGTH OF THE NEW AREA.
         LA    LKR,VARFEXIT    ADJUST THE SINK'S POV SO AS TO
         L     R15,=AL4(&IGANAME+&IGAPVAJ)  MAINTAIN THE PARTIAL ORDER *
                         CONDITION.
         BCR   15,R15    LINK TO ADJUST THE PARTIAL ORDER VALUE.
***********************************************************************
FRSCANL  EQU   *         SCAN LEFT TO THE AREA JUST TO THE LEFT OF THE
*                        AREA TO BE FREED.
         ICALL (&IGANAME+&IGALSCN)  SCAN LEFT.
         ST    R15,FARG        SAVE THE ADDRESS ACCESSED BY SCANL.
         LTR   F9,R15          SEE IF IT WENT OFF THE END.
         L     F15,IGADDR      RESTORE THE PROGRAM BASE.
         JMP   4,FRINS         JUMP IF IT WENT OFF THE LEFT END.
*                              LEFT END.
         CLR   F2,F9           SEE IF THE NEW AREA IS STILL LESS THAN
         BC    4,FRSCANL  THE ONE THE SCAN FOUND.
         LA    LKR,FRAFTPOV    THE NEW AREA IS GREATER THAN THE ONE
         L     R15,=AL4(&IGANAME+&IGAPVG)  FOUND BY THE SCANL.
*                              SEE IF THE NEW AREA COMBINES WITH IT.
***********************************************************************
FREQUAL  EQU   *         NEW AREA COMBINES WITH THE ONE ON ITS RIGHT.
         ICALL (&IGANAME+&IGAPVG)  GET THE PARTIAL ORDER VALUE FOR THE *
                         ONE ON THE RIGHT.
         DROP  R15
         USING *,LKR     USE THE LINKAGE REGISTER AS A TEMPORARY BASE  *
                         REGISTER.
         ALR   F3,REQL         AND ADD THE TWO LENGTH TOGETHER.
         LM    F6,F8,APT       RESTORE THE PATH TO THE ONE ON THE
*                              LEFT OF THE NEW AREA, AND SEE IF THE
         ICALL (&IGANAME+&IGALSCN)  THREE AREAS CAN BE COMBINED.
         DROP  LKR
         USING *,LKR     NOW USE THIS AS A TEMPORARY BASE REGISTER     *
                         ADDRESS.
         LTR   F9,R15          SEE IF THERE IS ONE ON IT'S LEFT.
         JMP   4,VARFADJ       JUMP IF THE NEW ONE COMBINES WITH THE
*                              WITH THE ONE ON ITS RIGHT.
         ICALL (&IGANAME+&IGAPVG) GET THE LENGTH OF THE ONE ON ITS LEFT
         DROP  LKR
         USING *,LKR     USE A NEW TEMPORARY BASE REGISTER.
         LR    F10,REQL        ADD THE LENGTH OF THE ONE ON THE LEFT TO
         ALR   F10,F9          THE ADDRESS OF THE ONE ON THE LEFT TO
         CLR   F10,F2          FORM THE ADDRESS OF THE AREA JUST TO THE
         BC    7,VARFADJ       RIGHT OF THE ONE ON THE LEFT OF THE NEW
*                              ONE, AND COMPARE THIS ADDRESS TO THE
*                              ADDRESS OF THE NEW ONE.
*                              IF THESE ADDRESSES ARE EQUAL, THEN ALL
*                              THREE AREAS COMBINE INTO ONE, BUT IF
*                              THESE ADDRESSES ARE NOT EQUAL THEN
*                              THE NEW ONE ONLY COMBINES WITH THE ONE
*                              ON ITS RIGHT.
*---------------------------------------------------------------------*
* THE NEW ONE COMBINES WITH THE AREAS ON BOTH SIDES OF IT TO MAKE     *
* ONE BIG AREA. DELETE THE ONE ON THE RIGHT AND ADJUST THE LENGTH OF  *
* THE ONE ON THE LEFT TO BE THE SUM OF ALL THREE LENGTHS.             *
*---------------------------------------------------------------------*
         ALR   F0,F3     GET THE SUM OF ALL THREE LENGTHS.
         ICALL (&IGANAME+&IGAPVAJ)  ADJUST THE LENGTH OF THE ONE ON THE*
                         LEFT OF THE AREA TO BE RELEASED.
         DROP  LKR
         USING *,LKR     USE THE LINKAGE REGISTER AS A TEMPORARY BASE  *
                         REGISTER.
         STM   F6,F8,APT       RESTORE THE PATH TO THE ONE ON THE RIGHT
         SLR   REQL,REQL       AND ADJUST ITS POV TO BE ZERO, IN
         ICALL (&IGANAME+&IGAPVAJ)  PREPARATION FOR DELETING IT.
         DROP  LKR
         USING *,LKR     NOW USE THIS AS A TEMPORARY BASE ADDRESS.
         L     R15,=AL4(&IGANAME+&IGADEL8)  GET THE ADDRESS OF THE TYPE*
                         8 DELETION ROUTINE.
         DROP  LKR
         USING (&IGANAME+&IGADEL8),R15  USE THIS REGISTER.
         LA    LKR,VARFEXIT    AFTER IT IS DELETED IT IS ESSENTIALLY
         BCR   15,R15    FINISHED, EXCEPT FOR CLEANUP AND EXIT.
         DROP  R15
***********************************************************************
* THE NEW AREA ONLY COMBINES WITH THE AREA IMMEDIATELY TO ITS RIGHT.  *
* RESTORE THE PATH TO THE ONE ON ITS RIGHT. IF THE ONE ON THE RIGHT IS*
* A RIGHT SINK, THEN IT IS ONLY NECESSARY TO ADJUST THE POV AND REPLACE
* IT WITH THE NEW ADDRESS.                                            *
*   HOWEVER, IF THE ONE ON THE RIGHT IS NOT A RIGHT SINK, THEN IT MUST*
* BE DELETED AND THE NEW ONE INSERTED WITH ITS NEW POV.               *
***********************************************************************
VARFADJ  EQU   *         ADJUST THE POV OF THE ONE ON THE RIGHT
         BALR  R15,O     ESTABLISH A NEW BASE REGISTER.
         USING *,R15     USE THE NEW BASE REGISTER.
         STM   F6,F8,APT       RESTORE THE PATH TO THE ONE ON THE RIGHT
         SLR   REQL,REQL       GET ZERO TO ADJUST THE POV TO ZERO
         ICALL (&IGANAME+&IGAPVAJ)  JUST BEFORE DELETING IT FROM THE   *
                         TREE.
         DROP  R15
         USING *,LKR     USE YET ANOTHER BASE REGISTER.
         ICALL (&IGANAME+&IGADEL8)  DELETE THE ONE ON THE RIGHT OF THE *
                         AREA TO BE RELEASED.
         DROP  LKR
         USING &IGANAME,R15
         L     F15,IGADDR      RESTORE THE PROGRAM BASE REGISTER.
         JMP   15,FSRCHINS     GO INSERT THE NEW ONE.
         DROP  F1
         DROP  R13
         DROP  R15
***********************************************************************
* COME HERE TO RELEASE AN 8-BYTE AREA USING THE FREE SPACE CHAIN FROM *
* THE FIXEDHDR IN THE SPACE CONTROL AREA.                             *
*                                                                     *
* UPON ENTRY THE REGISTERS HAVE THE FOLLOWING CONTENTS:               *
*                                                                     *
* R1:    THE ADDRESS OF THE AREA TO BE RELEASED.                      *
* LKR:   THE RETURN ADDRESS FROM THE CALLING PROGRAM.                 *
* R15:   THE ADDRESS OF THE SPACE CONTROL AREA CONTAINING THE FIXEDHDR.
***********************************************************************
      GODOWNTO &IGAFS8
         USING FIXEDHDR-&IGAS8,R15
         LA    R1,O(,R1)  CLEAR THE HIGH ORDER BYTE OF THE ADDRESS OF  *
                         THE AREA TO BE RELEASED.
         LTR   R1,R1     SEE IF THERE IS AN ADDRESS OF AN AREA TO BE   *
                         RELEASED.
         BCR   8,LKR     DO NOTHING IF THE ADDRESS IS ZERO.
         L     R0,HEADFREE  LOAD THE HEAD OF THE FREE SPACE CHAIN.
         ST    R0,O(,R1)  STORE THE OLD HEAD OF THE FREE SPACE CHAIN   *
                         IN THE FIRST WORD OF THE NEW AREA.
         ST    R1,HEADFREE  STORE THE NEW HEAD OF THE FREE SPACE CHAIN.
         JMP   15,(LKR)  EXIT.
         DROP  R15
***********************************************************************
* COME HERE TO RELEASE A 12-BYTE AREA USING THE FIXEDHDR IN THE SPACE *
* CONTROL AREA. UPON ENTRY TO THIS SUBROUTINE THE REGISTERS CONTAIN   *
* THE FOLLOWING:                                                      *
*                                                                     *
*  R1:   THE ADDRESS OF THE AREA TO BE RELEASED.                      *
*  LKR:  THE RETURN ADDRESS FROM THE BRANCH AND LINK IN THE CALLING   *
*        PROGRAM.                                                     *
*  R15:  THE ADDRESS OF THE SPACE CONTROL AREA CONTAINING THE FIXEDHDR*
*        TO BE USED.                                                  *
* IF THE ADDRESS OF THE AREA BEING RELEASED IS ZERO THE OPERATION IS  *
* AN EFFECTIVE NOP.                                                   *
***********************************************************************
*                                                                     *
      GODOWNTO &IGAFS12
         USING FIXEDHDR-&IGAS12,R15  USE THE 12-BYTE FIXEDHDR.
         LA    R1,O(,R1)  CLEAR THE HIGH ORDER BYTE IN THE ADDRESS OF  *
                         THE AREA TO BE RELEASED.
         LTR   R1,R1     SEE IF THE ADDRESS IS ZERO.
         BCR   8,LKR     RETURN IF THE ADDRESS IS ZERO.
         L     R0,HEADFREE  GET THE CURRENT HEAD OF THE FREE SPACE     *
                         CHAIN.
         ST    R0,O(,R1)  CATENATE THE CHAIN TO THE NEW AREA, THUS     *
                         MAKING IT THE NEW HEAD.
         ST    R1,HEADFREE  STORE THE NEW HEAD OF THE FREE SPACE CHAIN.
         JMP   15,(LKR)  RETURN TO THE CALLING PROGRAM.
         DROP  R15
***********************************************************************
      GODOWNTO &IGAFS80
* COME HERE TO RELEASE AN 80-BYTE AREA USING THE FIXEDHDR IN THE SPACE*
* CONTROL AREA. UPON ENTRY TO THIS SUBROUTINE THE REGISTERS CONTAIN   *
* THE FOLLOWING:                                                      *
*                                                                     *
*  R1:   THE ADDRESS OF THE AREA TO BE RELEASED.                      *
*  LKR:  THE RETURN ADDRESS FROM THE BRANCH AND LINK IN THE CALLING   *
*        PROGRAM.                                                     *
*  R15:  THE ADDRESS OF THE SPACE CONTROL AREA CONTAINING THE FIXEDHDR*
*        TO BE USED.                                                  *
*                                                                     *
* IF THE ADDRESS OF THE AREA BEING RELEASED IS ZERO THE OPERATION IS  *
* AN EFFECTIVE NOP.                                                   *
***********************************************************************
         USING FIXEDHDR-&IGAS80,R15  USE THE 80-BYTE FIXEDHDR.
         LA    R1,O(,R1)  CLEAR THE HIGH ORDER BYTE IN THE ADDRESS OF  *
                         THE AREA TO BE RELEASED.
         LTR   R1,R1     SEE IF THE ADDRESS IS ZERO.
         BCR   8,LKR     RETURN IF THE ADDRESS IS ZERO.
         L     R0,HEADFREE  GET THE CURRENT HEAD OF THE FREE SPACE     *
                         CHAIN.
         ST    R0,O(,R1)  CATENATE THE CHAIN TO THE NEW AREA, THUS     *
                         MAKING IT THE NEW HEAD.
         ST    R1,HEADFREE  STORE THE NEW HEAD OF THE FREE SPACE CHAIN.
         JMP   15,(LKR)  RETURN TO THE CALLING PROGRAM.
         DROP  R15
***********************************************************************
* ENTRY POINT TO FREE UP ONE RECORD SPACE TO THE RECORD FREE SPACE    *
* CHAIN. COME HERE FOR FIXED RECORDS ONLY, VARIABLE LENGTHS DON'T WORK.
* COME HERE FROM THE FSPACE MACRO-INSTRUCTION TO FREE UP A FIXED      *
* LENGTH AREA. UPON ENTRY THE REGISTERS CONTAIN THE FOLLOWING:        *
*   R1   THE ADDRESS OF THE AREA TO BE RELEASED.                      *
*   LKR  THE RETURN ADDRESS.                                          *
*   R15  THE ADDRESS OF THE FIXEDHDR FOR THE FIXED LENGTH FREE SPACE  *
*        CHAIN.                                                       *
***********************************************************************
      GODOWNTO &IGAFSPF
IGAFSPAC EQU   *   COME HERE TO FREE UP A RECORD SPACE.
         LA    R1,O(,R1) CLEAR THE HIGH ORDER BYTE OF THE ADDRESS.
         LTR   R1,R1     SEE IF THERE IS ANYTHING TO FREE UP.
         JMP   12,(LKR)        RETURN IMMEDIATELY IF NOT.
         USING FIXEDHDR,R15
         L     R0,HEADFREE  GET THE CURRENT HEAD OF THE CHAIN.
         ST    R0,O(O,R1)  STORE THE CURRENT HEAD AT THE AREA BEING    *
                         RELEASED,THUS CHAINING THE CURRENT CHAIN ON AS*
                         THE TAIL OF THE NEW HEAD.
         ST    R1,HEADFREE  STORE THE NEW HEAD.
         JMP   15,(LKR)  RETURN TO THE FSPACE MACRO-INSTRUCTION.
         DROP  R15
         AGO   .FINFFSP  SKIP AROUND THIS CODE THAT IS UNUSED FOR THE  *
                         NONCE.
         USING FIXEDHDR,HDB    USE THE FIXEDHDR.
         L     R3,BLOKHEAD     SET UP FOR THE CHECK LOOP.
         USING BLOCKHDR,R3     R3 ADDRESSES THE BLOCKHDR.
BADLOOP  LM    R3,R5,O(R3)     LOAD IN THE EDGE, SP/LENGTH, AND LIMIT.
         LA    R4,O(O,R4)      SEE IF THE ADDRESS IN GPR 15 IS IN THE
         LCR   R5,R5           BLOCK DEFINED BY THIS BLOCKHDR.
         ALR   R5,R15          THIS TECHNIQUE IS IDENTICAL TO THE ONE
         CLR   R5,R4           USED IN THE APL INTERPRETER FOR CHECKING
*                              SUBSCRIPTS TO SEE IF THEY ARE IN THE
*                              RANGE OF THE INDEX SET FOR THE ARRAY,
*                              WHICH WAS IMPLEMENTED BY L. J. WOODRUM
*                              IN 1966.
         BC    4,GOODEND       THIS BLOCK.
         LTR   R3,R3           IT ISN'T, CHECK FOR THE END OF THE
         BC    7,BADLOOP       BLOCK CHAIN, AND CONTINUE IF NOT END.
         DC    XL2'0D00'       ABEND IF IT'S NOT IN THE BLOCK CHAIN.
GOODEND  EQU   *  COME HERE WHEN IT HAS BEEN FOUND IN THE BLOCK CHAIN.
         MVC   O(4,R15),HEADFREE  MOVE OLD CHAIN HEAD TO NEW VERTEX.
         ST    R15,HEADFREE  STORE THE NEW HEAD OF THE CHAIN.
         LM    LKR,R5,TREESAVE+GPR14-SAVEDSEK  RESTORE THE REGISTERS.
RCODE0   EQU   *  COME HRE TO RETURN WITH A RETURN CODE OF ZERO.
         SLR   R15,R15       DON'T GIVE BACK ADDRESSABILITY TO THIS.
         BCTR  R15,LKR     SET THE RETURN CODE TO MINUS ONE.
         DROP  R1
         DROP  HDB
         DROP  R3
.FINFFSP ANOP
         EJECT
***********************************************************************
* SUBROUTINE TO SEARCH FOR A SINK THAT HAS AN ASSOCIATED PARTIAL ORDER*
* VALUE THAT IS GREATER THAN OR EQUAL TO THE PARTIAL RODER VALUE      *
* SEARCH ARGUMENT IN REGISTER REQL. THE BASIC ALGORITHM IS CHECK THE  *
* PARTIAL ORDER VALUE AGAINST THE POV AT EACH INNER VERTEX DOWN THE   *
* PATH TO SEE IF THE REQL IS SMALLER OR EQUAL TO IT. IF REQL IS LESS  *
* THAN THE POV OR EQUAL TO IT, THEN THE SUBTREE OF KNOWN ORDER CONTAINS
* A SINK WITH A (POSSIBLY) SMALLER POV THAN THE ONE THAT WAS DETERMINED
* PREVIOUSLY. IN THIS CASE, THE SEARCH PROCEEDS INTO THE SUBTREE OF   *
* KNOWN ORDER, AND SAVES THE POV AT THE INNER VERTEX FOR LATER.     *
* IF THE POV AT THE INNER VERTEX IS SMALLER THAN REQL, THEN THE SUBTREE
* OF KNOWN ORDER CANNOT CONTAIN A POV THAT IS NOT SMALLER THAN REQL,  *
* SINCE THE MAXIMUM VALUE FROM THE SUBTREE OF KNOWN ORDER IS ALREADY  *
* SMALLER THAN REQL. IN THIS CASE THE SEARCH PATH ENTERS THE SUBTREE  *
* OF UNKNOWN ORDER, WHERE IT IS CERTAIN TO FIND AT LEAST ONE SINK WITH*
* A VALUE NOT SMALLER THAN REQL.                                      *
*---------------------------------------------------------------------*
* UPON ENTRY TO THIS SUBROUTINE THE REGISTERS ARE AS FOLLOWS:         *
*                                                                     *
REQL     EQU   R0    THE PARTIAL ORDER VALUE SEARCH ARGUMENT.         *
*              R1    THE ADDRESS OF THE TREEHDR FOR THE RADIX PARTITION
*                    TREE.                                            *
*       R13:             R13 MUST HAVE A VALID SAVE AREA ADDRESS IN IT*
*                        TO SAVE THE REGISTERS.                       *
*              R15:THE ADDRESS OF THE POVSRCH ROUTINE.                *
*              LKR   THE ADDRESS TO RETURN TO.                        *
*---------------------------------------------------------------------*
* AT THE END OF THE SEARCH, THE POV FOR THE SINK FOUND IS STORED AT   *
* IGAVALUE IN THE TREEHDR, AND THE SINK ADDRESS IS RETURNED IN GPR 15.*
* THE ANTEPENULTIMATE AND PENULTIMATE VERTICES ON THE PATH TO THE SINK*
* ARE RECORDED IN IGANTPEN AND IGAPENLT RESPECTIVELY.                 *
* IF NO PARTIAL ORDER EXISTS IN THE RPT THAT IS GREATER THAN OR EQUAL *
* TO THE REQL, THEN A ZERO IS RETURNED IN GPR 15.                     *
***********************************************************************
SINKPOV  EQU   R2    THE SMALLEST ELIGIBLE PARTIAL ORDER VALUE THUS FAR
      GODOWNTO &IGASPV
         USING (&IGANAME+&IGASPV),R15
         USING TREEHDR,R1
POVSRCH  STM   R0,R9,((4*R0)+20-64*((2+R0)/16))(R13)  SAVE ONLY THOSE  *
                         REGISTERS THAT THE PARTIAL ORDER VALUE SEARCH *
                         USES.
         CL    REQL,IGAMAX     SEE IF THERE IS A VALUE LARGE ENOUGH
*                              TO SATISFY THE REQUEST.
         BC    2,POVSNOPE      BRANCH IF THERE IS NOT ONE BIG ENOUGH.
         L     SINKPOV,IGAMAX  SET SINKPOV TO THE MAXIMUM VALUE.
         L     P,APT     INITIALIZE THE TWO VERTICES TO THE SOURCE
         LA    P,O(O,P)  OF THE RADIX PARTITION TREE.
         LR    C,P       XX
         TM    PATH,P1000      SEE IF THERE ARE AT LEAST TWO SINKS.
         BC    1,POVSLOOP      BRANCH TO ENTER THE SEARCH LOOP IF
*                              THERE ARE AT LEAST TWO SINKS.
         NI    PATH,P0001      NOW MAKE SURE THERE IS AT LEAST ONE SINK
         BC    7,ONESIT        TO LOOK AT, BRANCHING IF THE ONE'S IT.
POVSNOPE SLR   C,C             RETURN A ZERO SINK ADDRESS.
         BCTR  C,O             SET THE RETURN CODE TO MINUS ONE.
         SLR   SINKPOV,SINKPOV SET THE VALUE TO ZERO FOR THERE BEING NO
*                              VALUE LARGE ENOUGH.
ONESIT   EQU   *         COME HERE WHEN THE SINGLE SINK WORKS.
         ST   SINKPOV,IGAVALUE  STORE THE SINK VALUE FOUND.
         LTR   R15,C     RETURN THE ADDRESS OF THE SINK FOUND, AND SET *
                         THE CONDITION CODE TO CORRESPOND TO THE RETURN*
                         CODE.
         STM   P,C,IGANTPEN    STORE THE TWO VERTICES ON THE PATH.
         LM    R0,R9,((4*R0)+20-64*((2+R0)/16))(R13)  RESTORE THE      *
                         REGISTERS IT USED.
         JMP   15,(LKR)  RETURN.
***********************************************************************
POVSTLEF TLEF  P,C,S,CYCLE=YES  TRACE THE EDGE INTO THE LEFT SUBTREE.
POVSLOOP EQU   *         ENTER THE POV SEARCH LOOP HERE.
         CL    REQL,VALUE(O,C)  IF THE SEARCH ARGUMENT POV IS LESS THAN
         BC    12,ENTKNOWN      OR EQUAL TO THE MAXIMAL POV OF THE
*                               SUBTREE OF KNOWN ORDER, THEN GO TO
*                               ENTER THE SUBTREE OF KNOWN ORDER.
ENTUNKWN EQU   *               ENTER SUBTREE OF UNKNOWN ORDER.
         BQ1   C,ENTRLEFT  GO IF LEFT SUBTREE IS OF UNKNOWN ORDER.
ENTRIGHT EQU   *         ENTER THE RIGHT SUBTREE.
         BT11  C,POVSTREF      GO TRACE THE RIGHT EDGE IF NOT EOP.
         STM   P,C,IGANTPEN    STORE THE LAST TWO VERTICES ON THE PATH.
         MVI   PATH,P1101      SIGNAL RIGHT SINK WITH AT LEAST 2 SINKS.
         ST    SINKPOV,IGAVALUE        STORE THE VALUE FOUND.
         X     P,RGHT(O,C)  GET THE RIGHT SINK SUCCESSOR OF VERTEX C.
         LA    P,O(O,P)  CLEAR THE LEFT BYTE OF THE SINK WORD.
         LTR   R15,P     SET THE RETURN CODE AND SET THE CONDITION CODE*
                         TO CORRESPOND TO THE RETURN CODE.
         LM    R0,R9,((4*R0)+20-64*((2+R0)/16))(R13)  RESTORE THE      *
                         REGISTERS IT USED.
         JMP   15,(LKR)        AND RETURN.
***********************************************************************
POVSTREF TREF  P,C,S,CYCLE=YES  TRACE THE EDGE INTO THE RIGHT SUBTREE.
         CL    REQL,VALUE(O,C)  IF THE SEARCH ARGUMENT POV IS GREATER
         BC    2,ENTUNKWN       THAN THE MAXIMAL POV OF THE SUBTREE OF
*                               KNOWN ORDER, THEN BRANCH TO ENTER THE
*                               SUBTREE OF UNKNOWN ORDER.
ENTKNOWN EQU   *         ENTER THE SUBTREE OF KNOWN ORDER, THE REQL IS
*                        NOT GREATER THAN THE VALUE AT THE INNER VERTEX
*                        C. THERE IS A SINK IN THE SUBTREE WITH AN OK
*                        VALUE.
         L     SINKPOV,VALUE(O,C)  GET THE VALUE AND ENTER THE SUBTREE.
         BQ1   C,ENTRIGHT  GO IF THE RIGHT SUBTREE IS OF KNOWN ORDER.
ENTRLEFT EQU   *         ENTER THE LEFT SUBTREE.
         BT01  C,POVSTLEF      ENTER LEFT SUBTREE IF IT'S THERE.
         STM   P,C,IGANTPEN    STORE THE LAST TWO VERTICES ON THE PATH.
         MVI   PATH,P1100      SIGNAL LEFT SINK WITH AT LEAST 2 SINKS.
         ST    SINKPOV,IGAVALUE        STORE THE VALUE FOUND.
         X     P,LEF(O,C)  GET THE LEFT SINK SUCCESSOR OF VERTEX C.
         LA    P,O(,P)   CLEAR THE LEFT BYTE OF THE SINK WORD.
         LTR   R15,P     SET THE RETURN CODE AND SET THE CONDITION CODE*
                         TO CORRESPOND TO THE RETURN CODE.
         LM    R0,R9,((4*R0)+20-64*((2+R0)/16))(R13)  RESTORE ALL THOSE*
                         REGISTERS.
         JMP   15,(LKR)        AND RETURN.
         DROP  R1
         DROP  R15
         EJECT
***********************************************************************
* THIS IS YET ANOTHER HOLE-FINDING BACKPATH TRACE TO FIND THE PARTIAL *
* ORDER VALUE ASSOCIATED WITH A SINK, BUT NOT TO MAKE ANY CHANGES TO  *
* THE VALUES ON THE PATH.                                             *
***********************************************************************
      GODOWNTO &IGAPVG
         USING (&IGANAME+&IGAPVG),R15
         USING TREEHDR,R1
GETPOV   EQU   *  COME HERE TO GET THE SINK'S POV.
         STM   R2,R9,((X'04'*R2)+20-64*((X'02'+R2)/X'10'))(R13)  SAVE  *
               THE REGISTERS THIS ROUTINE USES.
         LM    P,C,AP          LOAD P AND C FOR THE BACKPATH TRACE.
         LA    P,O(O,P)        CLEAR THE HIGH ORDER BYTE.
         LA    C,O(O,C)        CLEAR THE HIGH ORDER BYTE.
         TM    PATH,P1000      BRANCH IF THERE ARE LESS THAN TWO
         JMP   8,LOADMAX       SINKS IN THE RPT.
         LA    R3,RL           USED TO TRACE ONE EDGE IN THE BACKPATH.
         L     R8,QBITMASK     USED TO COMPARE THE RL BIT TO THE
*                                 Q BIT.
         L     R0,APT          FIRST LET'S SEE IF THE SINK'S POV IS
         SLL   R0,((Q/4)+(Q/8))  ALREADY AT IT'S PREDECESSOR C.
         X     R0,FLAGS(O,C)   COMPARE THE Q BIT AT C TO THE EVEN/ODD
         NR    R0,R8           BIT IN THE PATH VECTOR BYTE.
         JMP   7,UPTOHOLE      JUMP IF IT'S NOT AT C.
* THE POV IS RIGHT AT THE SINK'S PREDECESSOR C. *
GOTHOLE  EQU   *   COME WHEN IT GOT THE HOLE.
         L     R0,VALUE(O,C)   LOAD THE SINK'S PARTIAL ORDER VALUE.
         LM    R2,R9,((X'04'*R2)+20-64*((X'02'+R2)/X'10'))(R13) RESTORE*
               THE REGISTERS THIS ROUTINE USES.
         JMP   15,(LKR)        RETURN.
***********************************************************************
* THE HOLE IS FARTHER UP THE BACKPATH, TRACE THE BACKPATH UNTIL IT IS *
* FOUND.                                                              *
***********************************************************************
HOLEUP   EQU   *  COME HERE TO KEEP LOOKING FOR THE HOLE.
         L     R0,FLAGS(O,C)   GET THE RL BIT AT C.
         ALR   R0,R0     MAKE THE RL BIT FROM C LINE UP WITH THE Q-BIT
*                        AT VERTEX P.
         X     R0,FLAGS(O,P)   COMPARE THE RL BIT FROM C TO THE Q-BIT
         NR    R0,R8           AT P BY EXCLUSIVE-ORING.
         LR    S,C       CYCLE PART OF THE REGISTERS FOR THE BACKPATH
         LR    C,P       TRACE, AS IT MIGHT NOT HAVE TO TRACE FARTHER.
         JMP   8,GOTHOLE       JUMP ON THE RL(C)=Q(P).
         IC    P,FLAGS(O,S)    GET THE RL-BIT FROM THE CURRENT VERTEX
         NR    P,R3            TO USE AS AN INDEX FOR SELECTING THE
         L     P,O(P,C)        LEFT OR THE RIGHT EDGE FIELD AT THE
         XR    P,S             PREDECESSOR OF THE CURRENT VERTEX FOR
         LA    P,O(O,P)        TRACING ONE EDGE IN THE BACKPATH.
UPTOHOLE EQU   *  ENTRY POINT FOR THE SECOND HOLE-FINDING BACKPATH
*                 TRACE LOOP.
         CLR   P,C             SEE IF THE SOURCE HAS BEEN REACHED.
         JMP   7,HOLEUP        CONTINUE THE BACKPATH TRACE IF NOT.
*---------------------------------------------------------------------*
LOADMAX  EQU   *         COME HERE TO GET THE MAXIMUM VALUE.
         L     R0,IGAMAX       THE POV WAS OUTSIDE THE TREE.
         LM    R2,R9,((X'04'*R2)+20-64*((X'02'+R2)/X'10'))(R13) RESTORE*
               THE REGISTERS THIS ROUTINE USES.
         JMP   15,(LKR)        RETURN.
         DROP  R1
         DROP  R15
         EJECT
***********************************************************************
*  P A R T I A L   O R D E R   A D J U S T M E N T   R O U T I N E    *
*  F O R   P A R T I A L   O R D E R   V A L U E S   I N              *
*  T Y P E   8   R A D I X   P A R T I T I O N   T R E E S            *
*---------------------------------------------------------------------*
*                   F U N C T I O N:                                  *
*                   - - - - - - - -                                   *
*  GIVEN A NEW PARTIAL ORDER VALUE IN REGISTER REQL, AND THAT P AND C *
* ARE THE PREDESSORS OF THE SINK IN QUESTION, REPLACE THE PARTIAL     *
* ORDER VALUE CURRENTLY ASSOCIATED WITH THE SINK WITH THE VALUE IN    *
* REQL.                                                               *
***********************************************************************
      GODOWNTO &IGAPVAJ
         USING (&IGANAME+&IGAPVAJ),R15
V        EQU  R2
H        EQU   R9
MKR      EQU   R3  REGISTER TO HOLD THE MASK X'08000000' WHEN COMPARING
*                  RL BITS TO Q-BITS.
IGADJPOV EQU   *
         USING TREEHDR,R1
INCSMV   EQU   *  INCORPORATE SEMILATTICE VALUE.
     STM R0,R9,((R0*X'04')+X'14'-X'40'*((2+R0)/X'10'))(R13)  SAVE GPRS.
         LR    V,REQL          GET THE NEW VALUE IN A SAFER PLACE.
         LM    P,C,AP  LOAD P AND C FOR THE BACKPATH TRACE.
         LA    P,O(O,P)  CLEAR THE HIGH ORDER BYTE.
         LA    C,O(O,C)  CLEAR THE HIGH ORDER BYTE.
         TM    PATH,P1000      SEE IF THERE IS ONLY ONE SINK.
         JMP   8,INCSMVST      BRANCH IF THERE IS.
         LA    R3,RL           USE THIS FOR TRACING THE BACKPATH.
         L     R8,=XL4'08000000'  USE THIS TO SEE IF RL(C)=Q(P).
***********************************************************************
* SEE IF THE HOLE IS ALREADY AT C, OR IF THE HOLE IS FARTHER UP THE   *
* BACKPATH. IF THE HOLE IS AT C, THEN THE PATIAL ORDER MAINTENANCE    *
* BACKPATH TRACE IS ENTERED RIGHT AWAY, BUT IF THE HOLE IS NOT AT C   *
* THEN THE HOLE MUST BE FOUND BY THE HOLE-FINDING BACKPATH TRACE.     *
* THE HOLE-FINDING BACKPATH TRACE THEN ENTERS THE PARTIAL ORDER       *
* MAINTENANCE BACKPATH TRACE TO COMPLETE THE OPERATION.               *
***********************************************************************
         L     R0,APT    LOAD THE PATH BYTE IN THE WORKING REGISTER
         SLL   R0,((Q/4)+(Q/8))  TO COMPARE IT TO THE Q-BIT AT C.
         X     R0,FLAGS(O,C)   IF THE TWO ARE EQUAL, THEN THE HOLE IS
         NR    R0,R8           AT C, AND THE PARTIAL ORDER MAINTENANCE
         JMP   7,FINDHOLE      BACKPATH TRACE IS ENTERED.
         LR    H,C         SET THE HOLE AT THE VERTEX C.
         CLR   P,C         SEE IF IT IS ALREADY AT THE SOURCE.
         JMP   8,ATTHETOP  JUMP IF IT IS AT THE SOURCE.
         CL    V,VALUE(O,P)  SEE IF THE VALUE IS BIGGER THAN P'S VALUE.
         JMP   2,BIGGER        JUMP IF SO.
HOLEIN1  ST    V,VALUE(O,H)  FILL THE HOLE WITH THIS TTASTY TIDBIT.
      LM R0,R9,((R0*X'04')+X'14'-X'40'*((2+R0)/X'10'))(R13)  RESTORE.
         JMP   15,(LKR)        AND RETURN.
HOLECHK  CL    V,VALUE(O,P)  SEE IF THE VALUE IN V IS BIGGER THAN
         JMP   12,HOLEIN1  THE PREDECESSOR'S EDGE; GO IF NOT.
BIGGER   L     R0,FLAGS(O,C)  IT WAS BIGGER THAN THE PREDECESSOR'S,
*                             NOW SEE IF THE PREDECESSOR'S VALUE CAME
*                             FROM THE SAME SUBTREE THAT C IS IN BY
*                             COMPARING THE RL BIT AT C WITH THE Q-BIT
*                             AT P.
       BQEQRL  R0,P,MASK=(R8),JUMP=^CIRCLE
         XI    FLAGS(H),IGAQBIT  FLIP THE SUBTREE SELECTOR BIT TO THE
*                                OTHER SUBTREE.
         MVC   VALUE(4,H),VALUE(P)  FILL THE HOLE WITH THE
*                                   PRFEDECESSOR'S VALUE.
ROUNDTHE LR    H,P       THE HOLE FLOWS UP THE BACKPATH.
CIRCLE   TRBP  P,C,S,RL=(R3),CLEAR=YES,TOP=^HOLECHK
ATTHETOP CL    V,IGAMAX    SEE IF IT'S BIGGER THAN THE BIGGEST.
         BC    12,HOLEIN1  BRANCH IF IT ISN'T TO FILL THE HOLE.
         XI    FLAGS(H),IGAQBIT  MAKE THE HOLEY BIT SELECT THE OTHER
*                                SUBTREE.
         MVC   VALUE(4,H),IGAMAX  THE NEXT-TO-BIGGEST FILLS THE HOLE.
INCSMVST ST    V,IGAMAX           PUT THE NEW ONE IN THE BIGGEST SPOT.
      LM R0,R9,((R0*X'04')+X'14'-X'40'*((2+R0)/X'10'))(R13)  RESTORE.
         JMP   15,(LKR)  RETURN.
***********************************************************************
* HOLE-FINDING BACKPATH TRACE TO INCORPORATE THE PARTIAL ORDER VALUE  *
* IN THE PATH FROM THE HOLE TO THE SINK.                              *
***********************************************************************
HOLELOOP EQU   *         COME HERE TO CLOSE THE HOLE LOOP.
         L     R0,FLAGS(O,C)   GET THE RL BIT AT C.
         BQEQRL R0,P,MASK=(R8),JUMP=ROUNDTHE
         TRBP  P,C,S,RL=(R3),CLEAR=YES
FINDHOLE EQU   *         ENTER THE HOLE LOOP HERE.
         L     H,VALUE(O,C)    GET TEH VALUE AT C.
         CLR   V,H             SEE IF THE VALUE V IS BIGGER.
         BC    10,HIGHHOLE     BRANCH IF THE V IS BIGGER.
         ST    V,VALUE(O,C)    THE V IS SMALLER, EXCHANGE THE TWO
         LR    V,H             VALUES AND SWITCH THE DIRECTION OF THE
         XI    FLAGS(C),Q      SUBTREE OF KNOWN ORDER SELECTION BIT.
*---------------------------------------------------------------------*
HIGHHOLE EQU   *         THE VALUE V IS BIGGER IF IT BRANCHES HERE.
         CLR   P,C             CHECK TO SEE IF TEH SOURCE IS REACHED.
         BC    7,HOLELOOP      BRANCH IF THE SOURCE NOT REACHED.
         ST    V,IGAMAX  STORE THE MAXIMUM VALUE.
      LM R0,R9,((R0*X'04')+X'14'-X'40'*((2+R0)/X'10'))(R13)  RESTORE.
         JMP   15,(LKR)  RETURN.
***********************************************************************
         DROP  R15
         DROP  R1
***********************************************************************
         AGO   .SKIPDPV        DO NOT INCLUDE DELETE POV FOR NOW.
***********************************************************************
* ROUTINE TO REMOVE THE PARTIAL ORDER VALUE ASSOCIATED WITH A SINK    *
* FROM THE VALUES STORE AT THE INNER VERTICES OF THE RADIX PARTITION  *
* TREE. THIS ROUTINE IS EXECUTED JUST PRIOR TO DELETING THE SINK FROM *
* THE RPT. THIS ROUTINE IS THE EXACT INVERSE OPERATION TO THE ROUTINE *
* THAT INCORPORATES THE PARTIAL ORDER VALUE FOR A NEW SINK IN THE RPT.*
***********************************************************************
         USING TREEHDR,R1
         USING &PROGRAM,R15
IGADPOV  EQU   *
         STM   R0,R9,GPR0  SAVE THE REGISTERS.
         LA    V,O           PUT ZERO IN IGAMAX WHEN THERE IS ONLY ONE
*                            SINK NOW AND THERE AREN'T GOING TO BE ANY.
         LM    P,C,AP        LOAD THE ANTEPENULTIMATE AND PENULTIMATE
*                            VERTICES ON THE PATH TO THE SINK.
         TM    PATH,P1000    SEE IF THERE IS ONLY ONE SINK,
         BC    8,FLIPTOP     AND GO TRADE IGAMAX FOR V IF THERE IS.
         TM    PATH,P0001    SEE IF THE SINK IS A RIGHT SUCCESSOR,
         BC    1,ITSRIGHT    AND BRANCH IF IT IS.
         TM    FLAGS(C),Q    SEE IF THE PARTIAL ORDER VALUE IS ALREADY
         BC    8,ALLDONE     STORED AT THE PREDECESSOR OF THE SINK.
*                            IF IT IS, IT IS ONLY NECESSARY TO COPY
*                            THE POV FROM VERTEX C TO IGAVALUE.
NOTYET   EQU   *             IT HASN'T YET COME TO THE SINK'S POV.
         LA    P,O(O,P)      CLEAR THE HIGH ORDER BYTES IN THE TWO
         LA    C,O(O,C)      REGISTERS FOR THE TOP CHECK.
         NI    FLAGS(C),255-Q  THIS CAUSES THIS ROUTINE TO BE AN EXACT
*                              INVERSE TO THE OTHER ONE.
         L     V,VALUE(O,C)  GET THE VALUE THAT CAME FROM THE SUBTREE
*                            THAT IS PAIRED WITH THE SINK.
         LA    RRL,RL        USE THIS FOR A MASK TO MAKE AN INDEX TO
*                            GET THE CORRECT EDGE FIELDS WITH.
         L     MKR,=XL4'08000000'  GET THE MASK TO USE FOR COMPARING
*                                  THE RL BIT WITH THE Q BIT.
         CLR   P,C           SEE IF IT IS ALREADY AT THE SOURCE; IF IT
         BC    8,FLIPTOP     IT THE ONLY THING IT HAS TO DO IS TO
*                            EXCHANGE IGAMAX WITH V.
***********************************************************************
* IT'S NOT AT THE SOURCE ALREADY, CHECK TO SEE IF THE RL BIT AT C IS  *
* EQUAL TO THE Q BIT AT P. IF THEY ARE EQUAL, THEN THE POV AT P IS THE*
* ONE THAT IS ASSOCIATED WITH THE SINK, AND IT CAN STOP NOW.          *
*---------------------------------------------------------------------*
GRABCSRL L     TMP,FLAGS(O,C)  GET THE FLAG BYTE WITH C'S RL BIT IN IT.
       BQEQRL  TMP,P,MASK=(MKR),JUMP=STOPPOV
***********************************************************************
* THE PARTIAL ORDER VALUE AT P DIDN'T COME FROM THE SUBTREE WHOSE     *
* SOURCE IS C, HENCE THE POV AT P ISN'T THE ONE FOR THE SINK.         *
* THEREFORE, COMPARE V WITH THE POV AT P, AND IF V<POV(P) EXCHANGE V  *
* WITH THE POV AT P AND COMPLEMENT THE Q BIT, THEREBY INDICATING THAT *
* POV LEFT AT P CAME FROM C'S SUBTREE.                                *
***********************************************************************
         CL    V,VALUE(O,P)    COMPARE V TO P'S POV.
         BC    10,DONTFLIP   IF V IS GREATER OR EQUAL THE EXCHANGE
*                            DOESN'T HAVE TO BE DONE.
***********************************************************************
*              V<POV(P), EXCHANGE THE TWO AND FLIP THE Q BIT.         *
***********************************************************************
         L     TMP,VALUE(O,P)  GET P'S POV.
         ST    V,VALUE(O,P)    P'S POV GETS V.
         LR    V,TMP           V GETS P'S OLD POV.
         XI    FLAGS(P),Q      FLIP P'S SUBTREE OF KNOWN ORDER BIT.
***********************************************************************
* TRACE THE BACKPATH ONE EDGE AND GO BACK TO GET C'S RL BIT AGAIN IF  *
* IT DOESN'T GET TO THE TOP OF THE BACKPATH.                          *
***********************************************************************
DONTFLIP TRBP  P,C,S,RL=(RRL),TOP=^GRABCSRL
***********************************************************************
* IT CAME RIGHT OUT OF THE SOURCE, THE SINK'S POV MUST BE IN IGAMAX.  *
* SO IGAMAX HAS TO BE PUT INTO IGAVALUE, AND V GETS STORED IN IGAMAX. *
***********************************************************************
FLIPTOP  MVC   IGAVALUE,IGAMAX  MOVE THE PREVIOUS MAXIMUM VALUE OUT.
         ST    V,IGAMAX         STORE THE NEW MAXIMUM VALUE THERE.
         LM    R0,R9,GPR0  RESTORE THE REGISTERS
         BCR   15,LKR      AND RETURN.
***********************************************************************
* THE SINK'S POV IS AT VERTEX P. REPLACE THE VALUE AT P WITH V, AND   *
* PUT THE SINK'S VALUE AT IGAVALUE.                                   *
***********************************************************************
STOPPOV  MVC   IGAVALUE,VALUE(P)  MOVE THE SINK'S POV FROM P.
         ST    V,VALUE(O,P)  STORE THE NEW MAXIMUM FOR P'S SUBTREE.
         LM    R0,R9,GPR0  RESTORE THE REGISTERS.
         BCR   15,LKR      RETURN.
***********************************************************************
ITSRIGHT TM    FLAGS(C),Q      SEE IF THE SINK'S POV IS RIGHT THERE AT
         BC    8,NOTYET    IT'S PREDECESSOR.
ALLDONE  MVC   IGAVALUE,VALUE(C)  MOVE THE SINK'S VALUE OUT.
         LM    R0,R9,GPR0  RESTORE THE REGISTERS
         BCR   15,LKR      AND RETURN.
         DROP  R1
.SKIPDPV ANOP
         LTORG *
      GODOWNTO &IGADSP8
         AIF   (NOT &SNAP).SNAPSKP  SEE IF THE DISPLAY ROUTINE SHOULD  *
                         BE INCLUDED THIS TIME.
DSPENTRY BALR  R15,O     ESTABLISH ADDRESSABILITY.
         USING *,R15
         JMP   15,DSPRPT
         DROP  R15
.SNAPSKP ANOP
       GODOWNTO &IGASTRE
GOSTREE  NTR   BR=R10,SAVE=(LKR,R12),LV=0
         B     SETUP8
         DROP  R10
         EJECT
      GODOWNTO &IGACON  SKIP DOWN TO THE CONSTANT SECTION.
INSBIT   EQU   *          THIS IS THE BEGINNING OF A 129 BYTE TABLE
*                        THAT IS USED FOR COMPUTING THE INDEX OF THE
*                        BIT OF INEQUALITY BETWEEN TWO OPERANDS.
*                        THIS TABLE IS COMPOSED OF 8 BYTES, LOCATED AT
*                        POSITIONS 0, 1, 4, 8, 16, 32, 64, AND 128,
*                        AND CONTAINS THE CONSTANT X'0007060504030201'
*                        IN THESE BYTE POSITIONS.
*                        THIS TABLE IS USED BY FIRST CONVERTING THE
*                        BYTES OF INEQUALITY INTO A MASK THAT
*                        SELECTS THE FIRST BIT OF INEQUALITY IN THE
*                        IN THE TWO BYTES, AND THEN INDEXING AN IC
*                        INSTRUCTION USING INSBIT.
         DC    XL3'000706'     THIS IS THE FIRST 3 BYTES OF INSBIT.
         DC    XL1'FF'         THIS IS AN UNUSED BYTE.
         DC    XL1'05'         THIS IS POSITION 04 OF INSBIT.
         DC    XL1'FF'         THIS IS AN UNUSED BYTE.
         DC    XL1'FF'         THIS IS AN UNUSED BYTE.
         DC    XL1'FF'         THIS IS AN UNUSED BYTE.
         DC    XL1'04'         POSITION 08 IN INSBIT.
         DC    XL1'FF'         THIS IS AN UNUSED BYTE.
         DC    XL1'FF'         THIS IS AN UNUSED BYTE.
         DC    XL1'FF'         THIS IS AN UNUSED BYTE.
*---------------------------------------------------------------------*
X800     DC    XL4'80000000'    AN AGORONOMIC CONSTANT.
RSTAB1   DC    AL1(P0011)      THIS IS USED TO SET THE PATH CODE IN
*                              THE DELETE OPERATION, AND IS ALSO THE
*                              BYTE IN POSITION X'10' OF THE TABLE
*                              INSBIT.
         DC    XL1'FF'         THIS IS AN UNUSED BYTE.
TBTAB1   EQU   *-2       THIS IS AN 8 BYTE TABLE, THAT CONTAINS TWO
         DC    AL2(T1)   FULL WORDS, WHERE THE FIRST TWO BYTES OF EACH
*                        WORD ARE NOT USED (I. E. CAN BE ANYTHING),
*                        AND THE SECOND HALFWORD OF EACH FULL WORD
*                        CONTAINS THE TWO BYTE HALFWORD VALUES FOR
*                        T1 AND T0 RESPECTIVELY.
*                        THESE ARE USED TO SET THE APPROPRIATE T-BIT TO
*                        ONE IN THE NEW INNER VERTEX FOR TOP AND MOP
*                        INSERTS.
         DC    AL1(P0101)      THIS IS PART OF RSTAB1.
         DC    XL1'FF'         THIS IS AN UNUSED BYTE.
TBTAB0   EQU   *-2       THIS CONTINUES THE TABLE TBTAB1, AND STARTS
*                        AN 8 BYTE TABLE WHERE THE TWO LOW ORDER BYTES
*                        IN THE TWO FULL ARE T0 AND T1 RESPECTIVELY.
*---------------------------------------------------------------------*
         DC    AL2(T0)   THIS IS THE LAST ENTRY IN TBTAB1 AND THE
*                        FIRST LOW ORDER BYTE IN THE FIRST WORD OF
*                        TBTAB0.
NEWPATH  DC    AL1(P1100)      THIS BYTE AND THE BYTE AT NEWPATH+4 ARE
*                              USED TO SET THE PATH BYTE CODE AFTER
*                              AN INSERTION OPERATION.
RSTAB0   DC    AL1(P1000)      THIS BYTE AND THE BYTE AT RSTAB+4 ARE
*                              USED TO SET THE PATH CODE IN DEL8.
         DC    XL1'FF'   THIS IS AN UNUSED BYTE.
         DC    AL1(T1)         THIS COMPLETES THE TBTAB0 TABLE.
         DC    AL1(P1101)     THIS IS THE BYTE ASSOCIATED WITH NEWPATH.
         DC    AL1(P1011)      THIS IS THE BYTE AT RSTAB0+4.
INSFFEQ  EQU   *-TWO     THIS IS USED IN THE INSERT ROUTINE WHEN THE
   DC  AL2(X'FFE0'+Q)    NEW KEY IS EQUAL TO A KEY ALREADY IN THE RPT
*                        TO SET THE BIT INDEX FOR THE NEW INNER VERTEX
*                        TO ALL ONES, AND TO SET THE Q-BIT TO 1.
*---------------------------------------------------------------------*
***********************************************************************
SCANRTAB EQU   *
         DC    AL1(NULLPATH-SCANRORG)  P0000.
         DC    AL1(PASTRGHT-SCANRORG)  P0001.
         DC    AL1(NULLPATH-SCANRORG)  P0010.
         DC    AL1(PLEFOFIT-SCANRORG)  P0011.
         DC    AL1(NULLPATH-SCANRORG)  P0100.
         DC    AL1(PASTRGHT-SCANRORG)  P0101.
         DC    AL1(NULLPATH-SCANRORG)  P0110.
         DC    AL1(PLEFOFIT-SCANRORG)  P0111.
         DC    AL1(SCRBT01-SCANRORG)   P1000.
         DC    AL1(SCRTRYT1-SCANRORG)  P1001.
         DC    AL1(SCRTRYT1-SCANRORG)  P1010.
         DC    AL1(SCRBIV1-SCANRORG)   P1011.
         DC    AL1(SCRTRYT1-SCANRORG)  P1100.
         DC    AL1(SCRBIV1-SCANRORG)   P1101.
         DC    AL1(SCANRGO-SCANRORG)   P1110.
         DC    AL1(SCANRGO-SCANRORG)   P1111.
***********************************************************************
SCANLTAB EQU   *
         DC    AL1(NULLPATH-SCANLORG)  P0000.
         DC    AL1(PASTLEFT-SCANLORG)  P0001.
         DC    AL1(NULLPATH-SCANLORG)  P0010.
         DC    AL1(PASTLEFT-SCANLORG)  P0011. GRINNIG VERTEX ON LEFT.
         DC    AL1(NULLPATH-SCANLORG)  P0100.
         DC    AL1(PLEFOFIT-SCANLORG)  P0101.
         DC    AL1(NULLPATH-SCANLORG)  P0110.
         DC    AL1(PLEFOFIT-SCANLORG)  P0111.
         DC    AL1(SCLBIV1-SCANLORG)   P1000.
         DC    AL1(SCLBT00-SCANLORG)   P1001.
         DC    AL1(SCLBT00-SCANLORG)   P1010.
         DC    AL1(SCLBT11-SCANLORG)   P1101.
         DC    AL1(SCLBIV1-SCANLORG)   P1100.
         DC    AL1(SCLBT00-SCANLORG)   P1101.
         DC    AL1(SCANLGO-SCANLORG)   P1110.
         DC    AL1(SCANLGO-SCANLORG)   P1111.
P0001ZZZ DC    AL1(P0001,0,0,0)  USED AS A MASK FOR SELECTING THE
***********************************************************************
*                                                                     *
*              LOW ORDER BIT IN THE PATH CODE BYTE.
*---------------------------------------------------------------------*
RLTAB0   DC    AL1(RL,0,0,0,0,0,0,0,RL,0,0,0)  THIS TABLE IS USED TO  *
*              SET THE RL BIT CORRECTLY IN THE DISPLACED INNER VERTEX *
*              IN AN INSERTION OPERATION.                             *
*              THE FIRST BYTE OF RLTAB0 IS ALSO THE BYTE IN POSITION  *
*              X'40' OF THE TABLE INSBIT.                             *
*---------------------------------------------------------------------*
MASKS    DC    XL8'8040201008040201'  THIS IS A TABLE USED TO SELECT  *
*        THE BIT IN THE SEARCH ARGUMENT BYTE WHILE DOING A SEARCH.    *
*---------------------------------------------------------------------*
SETTZERO DC    AL1(X'100'-T0,0,0,0,X'100'-T1,0,0,0)  TABLE TO USE     *
*              WHEN SETTING T0 OR T1 TO ZERO IN THE DEL8 ROUTINE.     *
QBITMASK DC    AL1(Q,0,0,0)    THIS IS USED TO COMPARE THE Q-BIT TO
*              THE RL-BIT IN THE BACKPATH TRACE THAT ADJUSTS PARTIAL
*              ORDER VALUES.
X08Z     EQU   QBITMASK  X08000000
ADDRESS  DC    AL4(&PROGRAM)   ADDRESS OF THE PROGRAM FOR RESTORING   *
*                              THE BASE REGISTER.                     *
X10      DC    XL4'00000010'   JUST SIXTEEN IN IT'S OWN BASE.
TWOTO8   DC    XL4'00000100'   THE NUMBER TWO HUNDRED FIFTY SIX.
X0100    EQU   TWOTO8
UNUSED1  DC    CL16'MORE UNUSED BITS'
IGATCB   EQU   UNUSED1
*---------------------------------------------------------------------*
INS5BITS DC    XL16'00383028202020202020202020202020'
*        THIS IS USED IN THE INS5 ROUTINE TO COMPUTE THE SHIFTED BIT  *
*        INDEX FOR THE NEW INNER VERTEX.                              *
*        THE FIRST BYTE OF THIS TABLE IS ALSO THE BYTE IN POSITION    *
*        X'80' OF THE TABLE INSBIT.                                   *
*---------------------------------------------------------------------*
      GODOWNTO &IGAGKW
         DC    16XL1'FF'  THE ROUTINE TO GET A KEY WORK AREA GOES HERE.
         AIF   (&BIGMASK).BIGMASK  IF ON USE THE 256 BYTE MASK TABLE.
MSKTBL   EQU   MASKS     USE THE LITTLE MASK TABLE, NOT ENOUGH FOR BIG.
         AGO   .MASKEND   SKIP AROUND THE BIG MASK TABLE.
.BIGMASK ANOP
MSKTBL   DC    32XL1'80'
         DC    32XL1'40'
         DC    32XL1'20'
         DC    32XL1'10'
         DC    32XL1'08'
         DC    32XL1'04'
         DC    32XL1'02'
         DC    32XL1'01'
.MASKEND ANOP
         EJECT
***********************************************************************
* THIS IS THE CONTINUATION OF THE INSERT ROUTINE FOR TYPE 8 RADIX     *
* PARTITION TREES.                                                    *
***********************************************************************
JUMPOVER EQU   *   COME HERE FOR INSERT WHEN THERE ARE AT LEAST TWO
*                  SINKS AND THERE IS A SPACE FOR THE NEW INNER VERTEX.
         USING INS8,R15
         USING IGARPTH,PLA
         USING SAVEDSEK,R13
         USING FIXEDHDR,HDB
         MVC   HEADFREE,O(NEW)  DECAPITATE THE CHAIN.
         DROP  HDB
         LM    P,C,AP  GET THE FIRST TWO VERTICES ON THE PATH.
INSONEIN EQU   *         ENTRY POINT IN THE SEQUENCE FOR INSERTS INTO
*                        A TREE WITH JUST 1 SINK BEFORE THE INSERTION.
         MVI   IGAIARG,X'00'   MAKE SURE THE LEFT BYTE OF THE INSERT
*                              ADDRESS IS ZERO.
         LA    FOR,FOURCON     PUT A CONSTANT 4 IN FOR FOR USE AS A
*                              MASK IN SELECTING RIGHT/LEFT FLAGS.
         LR    RRL,FOR         SET RRL TO FOUR IF THE SINK FOUND BY
         LA    P,0(0,P)  CLEAR THE HIGH ORDER BYTES.
         LA    C,0(0,C)
         TM    PATH,P0001      THE SEARCH IS A RIGHT SUCCESSOR, OR SET
         JMP   1,ALLRIGHT      RRL TO A ZERO IF THE SINK FOUND BY THE
         SLR   RRL,RRL         SEARCH IS A LEFT SUCCESSOR.
ALLRIGHT EQU   *         ----------------------------------------------
* REGISTERS (FOR,NEW,P,C,RRL,PLA,R15) ARE PROPAGATED FORWARD.
         L     FAR,IGAFARG     ADDRESS OF KEY FOUND BY THE SEARCH.
         LH    SAR,IGAKEYI  GET THE INDEX OF THE FIRST BYTE OF THE KEY *
               IN THE RECORD.
         ALR   FAR,SAR   COMPUTE THE ADDRESS OF THE FIRST BYTE OF THE  *
               KEY FOUND BY THE SEARCH SUBROUTINE.
         AL    SAR,((4*R15)+20-64*((2+R15)/16))(,R13)                  *
               COMPUTE THE ADDRESS OF THE KEY TO BE INSERTED.
         LH    LNG,IGAKEYL     THE LENGTH OF THE KEYS.
         FBI   I=I,A=SAR,B=FAR,LV=(LNG),WRK=TMP0   FIND BIT INDEX.
         LR    BIT,FOR   SET BIT TO A FOUR IF THE NEW KEY IS GREATER
         LR    TMP8,FOR  ZERO OUT THE LEFT 3 BYTES FOR THE IC.
         JMP   2,GETBIT  THAN THE FOUND KEY, OR SET IT TO ZERO IF THE
         BC    8,INSEQUAL  NEW KEY IS LESS THAN THE FOUND KEY.
         SLR   BIT,BIT   SET IT TO ZERO, THE NEW SINK IS A LEFT SINK.
GETBIT   EQU   *         (I,BIT,FOR,RRL,NEW,P,C,PLA,R15) FORWARD.
         BIT   I=I,A=SAR,B=FAR,J=LNG,N=TMP8
         SLL   I,FIVE    SHIFT IT OVER TO MAKE ROOM FOR THE Q AND NE   *
                         BITS.
         ALR   I,BIT     SET THE Q-BIT TO A ONE IF THE NEW SINK IS A
         LA    I,NE(I,BIT)     RIGHT SUCCESSOR, OR TO ZERO IF THE NEW
*                              SINK IS A LEFT SUCCESSOR, AND SET THE NE
*                              BIT ON TO SIGNIFY THE NEW INNER VERTEX
*                              IS THE SOURCE OF A SUBTREE WITH AT
*                              LEAST TWO UNEQUAL KEYS IN IT.
         SLL   I,SIXTEEN  ALIGN THE BIT INDEX AT BIT 0 IN THE GPR SO
*                        THAT IT CAN BE MADE A SIGNED HALFWORD BY
*                        SHIFTING IT BACK LATER.
         LH    TMP1,BYTEI(O,C)  PUT THE BYTE INDEX IN BITS 0-23.
         SRA   I,16      CAUSE THE BIT INDEX AND FLAG FIELD TO BE A
*                        A SIGNED HALFWORD SO THE CLR INSTRUCTION CAN
*                        BE USED.
         IC    TMP1,FLAGS(O,C)  GET THE INDEX OF THE BIT IN THE BYTE.
         CLR   I,TMP1          SEE IF THE NEW BIT INDEX IS GREATER THAN
         JMP   4,GETRRL        THE BIT INDEX AT THE END OF THE PATH.
***********************************************************************
* THE INSERT IS AT THE END OF THE PATH, EOP INSERT.                   *
***********************************************************************
EOPINS8  EQU   *         JUST A LABEL, NO BRANCHES TO IT.
         AL    TMP1,TBTAB0(RRL)  SET THE T0 OR T1 BIT TO A ONE FOR THE
*                              VERTEX THAT WILL BECOME THE PREDECESSOR
*                              OF THE NEW INNER VERTEX.
         LR    VZ,P      GET THE ALTERNATE SUCCESSOR OF THE PREDECESSOR
         LR    VX,C      SET VX TO THE ANTEPENULTIMATE VERTEX ON THE
         X     VZ,O(RRL,VX)    OF THE NEW SINK.
*                        PATH TO THE NEW SINK.
         LR    VY,NEW    SET VY TO THE PENULTIMATE VERTEX ON THE PATH
*                        TO THE NEW SINK.
         STM   VX,VY,IGANTPEN  STORE THE TWO IN THE TREE HDR.
         LA    VZ,O(O,VZ)      CLEAR THE HIGH ORDER BYTE IN VZ.
         STC   TMP1,FLAGS(O,VX)   STORE THE ADJUSTED FLAG BYTE BACK.
***********************************************************************
* HERE THE EXECUTION PATHS FOR EOP, MOP, AND TOP INSERTS ALL JOIN     *
* TOGETHER TO BECOME UNITED INTO ONE.                                 *
***********************************************************************
INS8JOIN EQU   *         MERGE POINT FOR ALL THREE.
         L     TMP2,O(VX,RRL)  GET THE EDGE FIELD OF THE PREDECESSOR
*                              OF THE NEW INNER VERTEX.
         ALR   I,RRL     SET THE RL BIT IN THE NEW INNER VERTEX TO BE
*                        A ZERO IF THE DISPLACED VERTEX IS A LEFT SINK,
*                        OR TO A ONE IF THE DISPLACED SINK IS A RIGHT
*                        SUCCESSOR, SINCE THE NEW INNER VERTEX IS A
*                        LEFT OR RIGHT INNER VERTEX ACCORDING TO THE
*                        LEFT/RIGHT STATUS OF THE SINK IT DISPLACES.
         XR    TMP2,VZ   REMOVE VZ FROM THE EDGE FIELD FROM VX TO THE
         XR    TMP2,VY   NEW INNER VERTEX AND PUT IN VY.
         ST    TMP2,O(VX,RRL)  STORE THE EDGE FILED BACK.
INS8ONE  EQU   *         ENTRY POINT INTO THE COMMON SEQUENCE FOR
*                        AN INSERTION TO A TREE WITH ONLY ONE SINK.
         IC    TMP3,NEWPATH(BIT)  GET THE NEW PATH BYTE CODE.
         STC   TMP3,PATH       STORE THE NEW PATH CODE.
         L     R15,INSARG      SINK ADDRESS FOR NEW SINK.
         XR    VZ,VX     FORM THE INVERTIBLE EDGE FOR THE NEW INNER
*                        VERTEX INCLUDING IT'S PREDECESSOR AND IT'S
*                        SUCCESSOR VZ.
         XR    VX,R15    FORM THE EDGE FIELD FOR THE NEW INNER VERTEX
*                        TO THE NEW SINK.
         ST    VX,O(BIT,NEW)   STORE THE EDGE FIELD FROM THE NEW INNER
*                              VERTEX TO THE NEW SINK.
*                        INNER VERTEX TO VZ.
         XR    BIT,FOR   GET THE INDEX OF THE EDGE FIELD FROM THE NEW
         ST    VZ,O(BIT,NEW)   STORE THE EDGE FIELD FROM THE NEW
*                              INNER VERTEX TO VZ.
         STC   I,FLAGS(O,NEW)  STORE THE FLAG FIELD FOR THE NEW INNER
*                              VERTEX.
         SRL   I,8       GET THE BYTE INDEX IN THE LAST 8 BITS.
         STC   I,BYTEI(O,NEW)  STORE THE BYTE INDEX FOR THE NEW INNER
*                              VERTEX.
         LM    R0,R12,GPR0     RESTORE ALL THE REGISTERS.
         LTR   R15,R15   SET THE CONDITION CODE TO AGREE WITH THE      *
                         RETURN CODE.
         JMP   15,(LKR)        RETURN.
***********************************************************************
* THIS IS THE BACKPATH TRACE TO FIND THE INSERTION POINT FOR THE NEW  *
* INNER VERTEX WHEN THE INSERTION IS NOT EOP.                         *
***********************************************************************
BPTINS8  EQU   *         LOOP CLOSURE.
         LR    TMP4,C    TRACE ONE EDGE IN THE BACKPATH
         X     TMP4,O(RRL,P)   SO THAT P AND C ARE CONSECUTIVE
         LR    C,P             VERTICES ON THE PATH.
         LA    P,O(O,TMP4)     CLEAR THE HIGH BYTE FOR TOP TEST.
*---------------------------------------------------------------------*
GETRRL   IC    RRL,FLAGS(O,C)  SET RRL TO A ZERO IF RL(C)=0, OR TO
         NR    RRL,FOR   FOUR IF RL(C)=1.
*---------------------------------------------------------------------*
         CLR   P,C       CHECK FOR THE TOP REACHED.
         JMP   8,TOPINS8  BRANCH IF THE INSERT IS TOP.
*---------------------------------------------------------------------*
         LH    TMP4,BYTEI(O,P)  THE TOP WAS NOT REACHED, COMPARE THE
         IC    TMP4,FLAGS(O,P)  NEW BIT INDEX TO THE BIT INDEX OF THE
         CLR   I,TMP4           THE NEXT INNER VERTEX UP THE BACKPATH
         JMP   4,BPTINS8       TO KEEP LOOKING UNTIL THE INSERTION
*                               POINT IS FOUND.
*        THE VERTEX FOUND BY THE BACKPATH TRACE IS EITHER THE TOP, OR *
* IS THE FIRST INNER VERTEX ON THE FORWARD PATH WHOSE BIT INDEX IS    *
* GREATER THAN THE NEW BIT INDEX. THIS VERTEX IS THE VERTEX THAT IS   *
* DISPLACED BY THE INSERTION.                                         *
***********************************************************************
* THE INSERT IS IN THE MIDDLE OF THE PATH, SO THAT THE DISPLACED VERTEX
* IS AN INNER VERTEX, AND IS NOT THE SOURCE.                          *
***********************************************************************
MOPINS8  EQU   *         JUST A LABEL, NOT BRANCHED TO.
         LR    VZ,C      SET VZ TO THE INNER VERTEX SUCCESSOR OF THE
*                        NEW INNER VERTEX.
MOPEQ8   EQU   *  COME HERE TO JOIN MOP FROM CASE 2-MOP OF PROCESSING *
*                 PROCESSING EQUAL KEYS.                              *
* THE FOLLOWING LR IS A VIRTUAL LR BECAUSE P AND VX ARE THE SAME COLOR.
******** LR    VX,P      GET THE ANTEPENULTIMATE AND
         LR    VY,NEW    PENULTIMATE VERTICES ON THE PATH TO THE NEW
         STM   VX,VY,IGANTPEN  SINK, AND STORE THEM IN THE TREE HDR.
***********************************************************************
JOINMOP8 EQU   *         TOP AND MOP INSERTS JOIN HERE.
***********************************************************************
         LM    E0,E1,O(VZ)  ADJUST EDGE FIELDS OF THE DISPLACED INNER
         LA    TMP5,O(RRL,BIT)  VERTEX, AND SET THE RL BIT FOR THE
         X    E1,RLTAB0(TMP5)  INNER VERTEX, BUT SET IT TO A ONE IF IT
         LR    TMP6,VX         DISPLACED INNER VERTEX TO A ZERO IF IT
         XR    TMP6,VY         BECOMES A LEFT SUCCESSOR OF THE NEW
*                              BECOMES A RIGHT SUCCESSOR OF THE NEW
*                              INNER VERTEX.
         AL    I,TBTAB1(BIT)   SET THE T0 OR T1 BIT AT THE NEW INNER
*                              VERTEX TO REFLECT THE INNER VERTEX
*                              STATUS OF VZ.
         XR    E0,TMP6   FINISH UP ADJUSTING THE EDGE FIELDS OF THE
         XR    E1,TMP6   DISPLACED INNER VERTEX.
         STM   E0,E1,O(VZ)     STORE THE FIELDS BACK FOR VZ.
         JMP   15,INS8JOIN     NOW MERGE WITH THE COMMON PATH.
***********************************************************************
* THE INSERT IS AT THE TOP OF THE PATH, SO THAT THE SOURCE WILL BE    *
* THE DISPLACED INNER VERTEX.                                         *
***********************************************************************
TOPINS8  EQU   *         BRANCH HERE FOR TOP INSERTION.
         TM    PATH,P1000      TEST THE PATH BYTE TO SEE IF THIS IS THE
*                              CASE WHERE THERE IS ONLY ONE SINK BEFORE
*                              THE INSERTION.
         L     VZ,APT    PUT THE OLD SINK IN VZ IN CASE THIS IS THE    *
                         TIME WHEN THERE IS ONLY ONE SINK IN THE RPT   *
                         PRIOR TO THE INSERTION.
         ST    NEW,APT   STORE THE ADDRESS OF THE NEW SOURCE OF THE
*                        RADIX PARTITION TREE.
         LR    TMP7,P          NEED THIS BECAUSE VX AND P ARE THE SAME
*                              COLOR.
         LR    VX,NEW    THE NEW SOURCE IS IT'S OWN PREDECESSOR.
         MVC   IGANTPEN(8),APT  MOVE THE SAME ADDRESS IN ALL 3 PLACES.
         JMP   8,INS8ONE       JUMP ON THE RESULT OF THE TEST OF THE
*                              PATH BYTE MADE UPON ENTRY TO THE TOP.
         LR    VY,TMP7   THIS IS ONLY TO FAKE IT.
         LR    VZ,TMP7   SET THE ALTERNATE SUCCESSOR OF THE NEW INNER
*                        VERTEX TO THE OLD SOURCE.
         JMP   15,JOINMOP8     NOW MERGE WITH THE COMMON PATH.
FOURCON  EQU   4         JUST A FOUR.
         CNOP  0,8
INS801   EQU   *
         TM    PATH,P0001      NOW SEE IF THERE IS ONLY ONE SINK,
         JMP   1,INS81   AND JUMP IF THERE IS.
         LR    S,R0            STORE THE INSERT ARGUMENT ADDRESS
         LA    S,0(0,S)        AT ALL FOUR PLACES.
         LR    C,S       XX
         LR    P,S       XX
         STM   P,S,APT   STORE THE NEW SOURCE AND P AND C.
         MVI   PATH,P0001      SET PATH CODE TO ONE SINK.
         L     R15,GPR15  RESTORE R15.
         LEAF  SAVE=(R2,R12),LV=,RC=(R15)
INS81    EQU   *
         USING FIXEDHDR,HDB
         LTR   NEW,NEW       SEE IF THERE IS A PLACE FOR THE NEW INNER.
         BC    2,INS81OK     BRANCH IF THERE IS.
         LTR   LKR,LKR   LINK TO THE ROUTINE AT NEEDMORE TO GET MORE   *
                         SPACE ON THE FREE SPACE CHAIN, BUT SET UP THE *
                         LINKAGE REGISTER CORRECTLY.
         LA    LKR,INS81LD  BIT 0 OF LKR IS A ONE IF THE REQUEST IS A  *
                         CONDITIONAL REQUEST, AND BIT 0 IS A ZERO IF   *
                         THE REQUEST IS AN UNCONDITIONAL REQUEST.
         DROP  R15
         USING INS81LD,LKR  USE THIS ADDRESS TO MAKE THE LINKAGE,      *
                         BECAUSE THE ADDRESS IN REGISTER 15 IS NOT BIG *
                         ENOUGH TO REACH THE BRANCH TARGET WITHIN 4K.
         JMP   10,NEEDMORE     JUMP IF THE REQUEST IS UNCONDITIONAL.
         BAL   LKR,NEEDMORE    OTHERWISE LINK TO IT IN THE NORMAL WAY.
         DROP  LKR       NOW GO BACK TO THE OTHER USING.
         USING INS8,R15
INS81LD  EQU   *         RETURN FROM NEEDMORE.
         L     LKR,GPR14       RESTORE THE LINKAGE REGISTER.
         L     NEW,HEADFREE  LOAD THE NEW ADDRESS TO PUT THE INNER.
         LTR   NEW,NEW   SEE IF IT WAS ABLE TO GET ANY MORE SPACE.
         JMP   4,INS8LEAF  JUMP IF THERE ISN'T ENOUGH SPACE TO DO THE  *
                         INSERT.
INS81OK  MVC   HEADFREE,O(NEW)  DECAPITATE THE CHAIN.
         DROP  HDB
         L     VZ,APT    GET THE SINGLE SINK ADDRESS.
         LR    P,NEW           SET UP THE NEW INNER VERTEX TO BE THE
         LR    C,NEW           FIRST TWO VERTICES ON THE PATH TRIPLE.
         MVI   BYTEI(NEW),(X'FF'-NE)  CAUSE THE BACKPATH TRACE LOOP TO
         LA    VZ,O(O,VZ)      CLEAR THE HIGH ORDER BYTE.
         MVI   BYTEI(NEW),X'FF'  THINK THE INSERT IS AT THE TOP.
         JMP   15,INSONEIN  JUMP INTO THE SEQUENCE TO FIND THE UNEQUAL
*                          BIT POSITION BETWEEN THE NEW KEY AND THE OLD
         EJECT
***********************************************************************
* COME HERE WHEN THE NEW KEY IS EQUAL TO THE KEY ALREADY IN THE RPT   *
* ON AN INSERT. THIS SPECIAL PROCESSING FOR EQUAL KEYS IS TO INSURE   *
* THAT THE TEMPORAL ORDER OF INSERTION OF EQUAL KEYS IS PRESERVED, SO *
* THAT IF THEY ARE RETRIEVED VIA THE SCANR MACRO THEY ARE RETRIEVED IN*
* THE SAME ORDER THAT THEY WERE INSERTED.                             *
*                                                                     *
* THE FLAG BIT IGANEBIT IS A ONE FOR EACH VERTEX THAT IS THE SOURCE   *
* OF A SUBTREE WHERE THERE ARE AT LEAST TWO UNEQUAL KEYS, AND THE     *
* FLAG BIT IGANEBIT IS A ZERO FOR EACH VERTEX THAT IS THE SOURCE OF A *
* SUBTREE CONTAINING ONLY DUPLICATE KEYS.                             *
* THE SEARCH OPERATION ALWAYS POSITIONS THE CURSOR TO THE FIRST OF A  *
* GROUP OF EQUAL KEYS WHEN A SEARCH IS DONE WITH ONE OF THEM.         *
*---------------------------------------------------------------------*
* THERE ARE THREE BASIC CASES FOR THE SPECIAL PROCESSING FOR EQUALS:  *
* CASE 0: THERE IS ONLY ONE SINK PRESENT, AND THE NEW KEY IS EQUAL TO *
*         THE KEY ALREADY THERE; THE FLAG BIT IGANEBIT IS SET TO ZERO *
*         IN THE NEW INNER VERTEX, REGISTER BIT IS SET TO 4 TO SIGNAL *
*         THE NEW SINK IS A RIGHT SUCCESSOR, AND THEN THE REGULAR     *
*         PROCESSING FOR N=1 IS ENTERED.                              *
*                                                                     *
* CASE 1: THE NEW KEY IS EQUAL TO THE ONE ALREADY THERE AND THE VERTEX*
*         C ON THE PATH HAS THE FLAG BIT IGANEBIT =1, MEANING THAT    *
*         THERE WILL BE EXACTLY TWO EQUALS PRESENT AFTER THE INSERT.  *
*         REGISTER BIT IS SET TO 4, THE NE-BIT IS SET TO ZERO IN THE  *
*         NEW INNER VERTEX, AND THE NORMAL EOP PROCESSING IS ENTERED. *
*                                                                     *
* CASE 2: THE KEYS ARE EQUAL AND THE PENULTIMATE VERTEX ON THE PATH   *
*         TO THE SINK FOUND HAS THE NE-BIT OFF, MEANING IT IS THE     *
*         SOURCE OF A SUBTREE OF EQUALS ALREADY.                      *
*         IN THIS CASE THE BACKPATH IS TRACED TO THE VERTEX C SUCH THAT
*         THE NE-BIT AT C IS A ZERO AND THE NE-BIT AT IT'S PREDECESSOR*
*         P IS A ONE (IF IT HAS A PREDECESSOR).                       *
*         THEN THE INSERT IS MADE SO THAT THE NEW INNER VERTEX IS A   *
*         RIGHT SUCCESSOR OF C, AND THE FORMER RIGHT SUCCESSOR OF C   *
*         IS A LEFT SUCCESSOR OF THE NEW INNER VERTEX.                *
*         THE NE-BIT IS SET TO ZERO IN THE NEW INNER VERTEX.          *
*                                                                     *
* CASE 2 HAS THREE SUBCASES, 2-EOP, 2-MOP, AND 2-TOP.                 *
*         THESE CORRESPOND TO END-OF-PATH INSERTION, MIDDLE-OF-PATH   *
*         INSERTION, AND TOP-OF-PATH INSERTION, RESPECTIVELY.         *
*        THE 2-EOP CASE CAN ARISE WHEN THE RIGHT SUCCESSOR OF THE     *
*        VERTEX DETERMINED BY THE BACKPATH TRACE HAS A SINK FOR ITS   *
*        RIGHT SUCCESSOR, SO THAT THE NEW INNER VERTEX DISPLACES A SINK
*        CASE 2-MOP ARISES WHEN C HAS AN INNER VERTEX FOR A RIGHT     *
*        SUCCESSOR, SO THAT THE NEW INNER VERTEX DISPLACES AN INNER   *
*        VERTEX IN THE MIDDLE OF THE PATH.                            *
*        CASE 2-TOP IS MERGED WITH CASE 2-MOP, SO THAT THE INSERT FOR *
*        CASE 2 NEVER CAUSES THE NEW INNER VERTEX TO DISPLACE THE     *
*        ALREADY EXISTING SOURCE OF THE RPT.                          *
***********************************************************************
INSEQUAL L     I,INSFFEQ       SET THE BIT INDEX FOR THE NEW INNER
*                              VERTEX TO ALL ONES, AND SET THE Q-BIT
*                              FOR THE NEW INNER VERTEX TO ONE.
         TM    FLAGS(C),NE     SEE IF THE VERTEX C IS SOURCE OF A
*                              SUBTREE WITH AT LEAST TWO UNEQUAL KEYS.
INSEQLBI IC    TMP1,FLAGS(O,C)  PUT THE BIT INDEX AND FLAG FIELDS IN
*                               THE REGISTER FOR USE IN THE EOP INSERT
*                               ROUTINE.
* NOTE HOW CAREFULLY THE CONDITION CODE IS PRESERVED THROUGH THE IC   *
* INSTRUCTION, AND HOW THE BRANCH MASK IS PICKED SO THAT THE TWO PATHS,
* THIS PATH AND THE PATH FROM EQSBTREE, CAN USE THE SAME IC INSTRUCTION
* ON THE WAY TO THE EOP ROUTINE.                                      *
         JMP   7,EOPINS8       JUMP IF NOT ZEROS.
* NOTE THAT THE ABOVE TEST MEANS THAT THE NE-BIT MUST BE ZERO IN THE  *
* DUMMY INNER VERTEX USED IN INSERT FOR THE CASE OF N=1.              *
         TM    PATH,P1000      SEE IF THIS IS CASE 0.
         JMP   7,GETEQRRL      IF NOT, ENTER THE CASE 2 PROCESSING.
         JMP   15,GETRRL       CASE 0 MERGES WITH THE REGULAR TOP INS.
***********************************************************************
* TRACE THE BACKPATH FOR CASE 2-TOP OR CASE 2-MOP. CONTINUE THE TRACE *
* UNTIL VERTEX P HAS THE NE-BIT ON OR UNTIL P=C, WHEN THE TOP IS      *
* REACHED.                                                            *
***********************************************************************
INSEQBPT LR    TMP4,C    TRACE THE BACKPATH ONE EDGE.
         X     TMP4,O(RRL,P)   SELECT THE LEFT OR RIGHT EDGE BY USING
         LR    C,P             BIT RL(C) AS AN INDEX.
         LA    P,O(O,TMP4)     CLEAR THE BYTE TO CHECK FOR TOP.
GETEQRRL IC    RRL,FLAGS(O,C)  GET THE RL BIT FROM C FOR LATER.
         NR    RRL,FOR         MAKE IT INTO A ZERO OR FOUR.
         CLR   P,C       SEE IF THE TOP HAS BEEN REACHED,
         JMP   8,EQSBTREE      AND IF IT HAS LOOK AT THE RIGHT SIDE.
         TM    FLAGS(P),NE     SEE IF VERTEX C IS NOW THE SOURCE OF
         JMP   1,INSEQBPT      ENTIRE SUBTREE OF EQUAL KEYS.
* VERTEX C IS NOW THE SOURCE OF THE ENTIRE SUBTREE OF EQUAL KEYS.     *
EQSBTREE EQU   *         COME HERE FOR CASE 2-MOP OR 2-EOP.
*                        CASE 2-TOP MERGES IN WITH 2-MOP AT THIS PLACE.
         TM    FLAGS(C),(B'11100000'+T1)  SEE IF THE RIGHT SUCCESSOR
         JMP   4,INSEQLBI      OF C IS A SINK; IF IT IS THIS IS CASE
*                              2-EOP, AND THE FUNNY THING HAPPENS ON
*                              WAY TO THE EOP ROUTINE.
* CASE 2-MOP, C'S RIGHT SUCCESSOR IS AN INNER VERTEX, AND THE NEW     *
* INNER VERTEX DISPLACES IT.                                          *
         TREF  P,C,TMP4,CYCLE=YES  TRACE EDGE INTO RIGHT SUBTREE.
         LR    RRL,FOR   SET RRL FOR THE NEW C.
         LA    VZ,O(O,C) PREPARE TO JOIN MOP.
         JMP   15,MOPEQ8 JOIN THE MOP INSERT ROUTINE.
         DROP  R15
         DROP  R13
         DROP  PLA
         EJECT
***********************************************************************
* THIS IS THE ROUTINE TO SET UP A RADIX PARTITION TREE FOR THE FIRST  *
* TIME.                                                               *
***********************************************************************
* UPON ENTRY THE REGISTER CONTENTS ARE AS FOLLOWS:                    *
*                                                                     *
*        0   1516  2223  31                                       *
*  R0:   ------------------                                       *
*         KEYI  RPT#  KEYL                                        *
*                                                                     *
*  R1:   MAPPING SUBROUTINE ADDRESS. BIT 0 OF R1 IS A ZERO IF THE     *
*        INNER VERTEX SIZE FOR THE RPT IS 8 BYTES, OR IS A ONE IF THE *
*        INNER VERTEX SIZE FOR THE RPT IS 12 BYTES.                   *
*                                                                     *
*  R10:  REGISTER 10 IS THE BASE REGISTER UPON ENTRY.                 *
*                                                                     *
*  LKR:  LKR CONTAINS THE RETURN ADDRESS. BIT 0 OF LKR IS A ONE IF THE*
*        REQUEST IS CONDITIONAL, OR IS A ZERO IF THE REQUEST IS       *
*        UNCONDITIONAL.                                               *
*                                                                     *
*        0       78                    31                          *
*  R15:  --------------------------------                          *
*         RPT SP#  SPACE CONTROL ADDRESS                           *
*                    (IF THERE IS ONE)                                *
*                                                                     *
* THE REGISTERS HAVE BEEN SAVED AND REGISTER 10 HAS BEEN SET TO THE   *
* ADDRESS "GOSTREE".                                                  *
***********************************************************************
*                                                                     *
* AFTER GETTING SPACE FOR THE TREE HEADER, ALL THE FIELDS FROM IGAPT  *
* TO IGAWORK ARE FIRST CLEARED TO ZEROS. THEN THE FOLLOWING FIELDS ARE*
* SET TO THE INDICATED VALUES:                                        *
*                                                                     *
*  IGADDR: IGADDR IS SET TO THE ADDRESS OF THE MODULE IGARPT01, AND   *
*          THE LEFT BYTE IS SET TO THE RPT TYPE.                      *
*                                                                     *
*  IGAHVFC:IF THE SPACE CONTROL ADDRESS IS NOT ZERO, THEN IGAHVFC IS  *
*          SET TO THE ADDRESS OF THE 8 OR 12-BYTE FIXEDHDR IN THE     *
*          SPACE CONTROL AREA, DEPENDING ON WHETHER THE INNER VERTEX  *
*          SIZE IS 8 OR 12 BYTES RESPECTIVELY. IF THE SPACE CONTROL   *
*          ADDRESS IS ZERO, THEN THE SPACE CONTROL SUBPOOL CHAIN FROM *
*          THE TCBRPT WORD IS SEARCHED TO FIND THE RIGHT SPACE CONTROL*
*          AREA FIRST.                                                *
*                                                                     *
*  IGAKEYL:IGAKEYL IS SET TO THE KEY LENGTH, USING THE NUMBER IN BITS *
*          23-31 OF REGISTER 0.                                       *
*                                                                     *
*  IGAMAP: IGAMAP IS SET TO THE ADDRESS OF THE MAPPING SUBROUTINE,    *
*          FROM REGISTER 1.                                           *
***********************************************************************
*                                                                     *
      GODOWNTO SPACE     LEAVE SOME ROOM HERE, AND ALIGN IT ON A       *
                         16-BYTE BOUNDARY.
SETUP8   EQU   *         COME HERE AFTER THE BRANCH ENTRY FROM THE     *
                         STREE MACRO-INSTRUCTION.
***********************************************************************
         USING GOSTREE,R10  USE THE USING FROM THE ENTRY.
         USING SAVEDSEK,R13  USE THE SAVE AREA DSECT.
         L     PLA,ADDRESS  GET THE ADDRESS OF THE BASE OF THE MODULE.
         DROP  R10
         LA    R10,X'800'(,PLA)  GET AN ADDRESS CLOSE ENOUGH TO THIS   *
                         CODE TO BE USED AS A BASE REGISTER, BUT NOT SO*
                         CLOSE THAT THE CONSTANTS CAN'T BE USED.
         USING &PROGRAM+X'800',R10  NEED TO DO THIS TO USE THE CONSTANT*
               DATA IN THE FIRST 4K OF THE MODULE.
         USING TREEHDR,PLA  USE THE GOODOLE PLA.
         LA    R9,0(,R15)  ADDRESS OF THE SPACE CONTROL WORD, IF THERE *
               IS ONE.
         LR    R3,R15    SAVE THE SUBPOOL # AND SPACE CONTROL ADDRESS  *
                         FOR LATER.
         SRL   R3,TWENTY4  GET THE SUBPOOL # IN THE RIGHT BYTE.
         LR    R6,R0     KEYI,RPT#, AND KEYL.
         SRDL  R6,NINE   GET KEYL IN LEFT NINE BITS OF R7, AND RPT # IN*
                         RIGHT 7 BITS OF R6.
         LA    R2,B'1111111'  MASK TO PICK OUT ONLY THE RPT#.
         NR    R2,R6     GET THE RPT# IN R2.
         CL    R2,=F'5'  SEE IF THIS IS A TYPE 5 RPT.
         JMP   8,SETUP5  JUMP IF IT IS A TYPE 5 RPT.
         LA    R0,IGATYP8S  GET THE SIZE OF A TYPE 8 RPT HEADER FOR THE*
                         GSPACE.
         ALR   R0,R15    ADD IN THE RPT SUBPOOL #.
         SLR   R0,R9     SUBTRACT OUT THE SPACE CONTROL AREA ADDRESS.
         N     LKR,X800  KNOCK OFF ALL THE BITS EXCEPT BIT 0, WHICH IS *
                         A ONE IF THE STREE IS A CONDITIONAL REQUEST.
         AL    LKR,=AL4(SETBACK)  ADD IN THE RETURN ADDRESS FROM GSPACE
         DROP  PLA
         LA    R1,O(,R9)  GET THE ADDRESS OF THE SPACE CONTROL AREA IN *
                         R1 IF THERE IS A SPACE CONTROL AREA.
         DROP  R10
         USING &PROGRAM,PLA
         JMP   15,&PROGRAM+&IGAGSPS  BRANCH ENTRY FOR GSPACE.
         DROP  PLA
         USING &PROGRAM+X'800',R10  GO BACK TO THE REAL ONE.
SETBACK  BNZ   MINUSRC   JUMP TO RETURN A NEGATIVE RETURN CODE IF THE  *
               GSPACE DIDN'T WORK DUE TO LACK OF SPACE.
         USING TREEHDR,R1
         ST    PLA,IGADDR  STORE THE ADDRESS OF IGARPT01.
         DROP  R1
         USING TREEHDR,PLA  BACK TO THE TREE HEADER TOO.
         LR    PLA,R1    SAVE THE ADDRESS OF THE TREE HEADER.
         MVI   IGADDR,X'08'  FLAG IT AS A TYPE 8 RPT.
         XC    IGAPT(IGAWORK-IGAPT),IGAPT  ZERO OUT ALL THE ENTRIES IN *
               THE TREE HEADER EXCEPT IGADDR.
         LTR   R9,R9     SEE IF THE SPACE CONTROL ADDRESS IS PRESENT.
         JNZ   GOTSTR#   JUMP IF IT IS PRESENT IN REGISTER 9 ALREADY.
      RPTDSECT GEN=(TCBRPT,R9)  GET THE ADDRESS OF THE SPACE CONTROL   *
                         AREA FOR SUBPOOL ZERO.
         USING FIXEDHDR-&IGAS8,R9  USE THE FIXEDHDR TO LOOK AT THE     *
                         SUBPOOL # IN THE SPACE CONTROL AREA.
         SLR   R4,R4  ZERO OUT THE LEFT 3 BYTES FOR THE IC INSTRUCTION.
         CLR   R3,R4     SEE IF THE REQUEST SUBPOOL IS THE SAME AS THE *
                         SUBPOOL # IN THE SACPE CONTROL AREA.
         JMP   8,GOTSTR#  JUMP IF IT IS, FOR THEN R9 HAS THE ADDRESS OF*
                         THE APPROPRIATE SPACE CONTROL AREA IN IT.
         DROP  R9
         USING IGASPCTL,R9  GET SET TO TRACE THE SPACE CONTROL AREA    *
                         SUBPOOL CHAIN.
         LA    R9,IGASPEDG  GET THE ADDRESS OF THE HEAD OF THE CHAIN.
         DROP  R9
         USING IGASPC,R9  USE THE CHAIN DSECT.
STREE#SP L     R9,IGANXSP  LOAD THE ADDRESS OF THE NEXT 8-BYTE SPACE   *
                         CONTROL AREA DEFINITION WORD.
         LTR   R9,R9     THE REQUEST SUBPOOL SHOULD BE PRESENT, SINCE  *
                         IT HAD TO BE USED TO ALLOCATE THE TREE HEADER *
                         PREVIOUSLY.
         JM    =XL2'FFFF'  HANG UP QUICKLY IF SOMETHING IS FOULED UP.
         IC    R4,IGASPADR  GET THE SUBPOOL IN REGISTER R4.
         CLR   R3,R4     SEE IF THEY ARE THE SAME.
         JMP   7,STREE#SP  JUMP IF THE RIGHT ONE IS NOT YET FOUND.
         L     R9,IGASPADR  FOUND THE RIGHT ONE, LOAD THE ADDRESS OF   *
                         THE CORRESPONDING SPACE CONTROL AREA.
         DROP  R9
GOTSTR#  EQU   *         COME HERE WHEN THE RIGHT SPACE CONTROL AREA   *
                         HAS BEEN FOUND.
         LA    R8,&IGAS8.(,R9)  GET THE ADDRESS OF THE FIXEDHDR FOR    *
                         8-BYTE ENTRIES FOR THE SPACE ALLOCATION FOR   *
                         INNER VERTEX ENTRIES.
         LM    R0,R1,((4*0)+20-64*((2+0)/16))(13)  RESTORE R0 AND R1.
         LTR   R1,R1     SEE IF THE INNER VERTEX SIZE IS 8 BYTES.
         JMP   10,IVSIS8  JUMP IF THE INNER VERTEX SIZE IS 8 BYTES.
         LA    R8,SIXTEEN(,R8)  ADD SIXTEEN TO THE FIXEDHDR ADDRESS,   *
                         CAUSING IT TO BE THE ADDRESS OF THE 12-BYTE   *
                         FIXEDHDR.
IVSIS8   EQU   *         NOW THE FIXEDHDR ADDRESS IS ALL SET UP.
         ST    R8,IGAHVFC  STORE THE ADDRESS OF THE FIXEDHDR IN THE    *
                         INNER VERTEX FREE SPACE WORD.
         LA    R1,O(,R1)  CLEAR THE LEFT BYTE.
         ST    R1,IGAMAP  STORE THE ADDRESS OF THE MAPPING SUBROUTINE  *
                         (IF THERE IS ONE).
         LA    R1,B'111111111'  MASK TO PICK OUT THE LAST 9 BITS OF R0,*
                         WHICH IS THE KEY LENGTH.
         NR    R1,R0     GET THE KEY LENGTH.
         STH   R1,IGAKEYL  STORE THE LENGTH OF THE KEY.
         SRDL  R0,16     GET THE INDEX OF THE FIRST BYTE OF THE KEY IN *
                         THE RECORD.
         STH   R0,IGAKEYI  STORE THE INDEX OF THE FIRST BYTE OF THE KEY*
                         IN THE RECORD.
&X       SETC  '&IGANAME'  THE NAME IS TOO BIG TO WRITE THE STATEMENT, *
                         SO USE THE LITTLE CHARACTER VARIABLE.
         MVC   &IGABLST.(X'28',PLA),=AL4(&X+&IGASCH8,&X+&IGAINS8,&X+&IG*
               ADEL8,&X+&IGADSP8,&X+&IGAGKW,0,&X+&IGALSCN,&X+&IGARSCN,&*
               X+&IGASPV,&X+&IGAPVG,&X+&IGAPVAJ)
         MVI   IGAKEYW,(B'11111111'-B'01111111')  FLAG THE WORD AS THE *
                         ADDRESS OF THE ROUTINE TO GET A WORK AREA FOR *
                         COLLECTING KEYS.
         LM    LKR,R11,GPR14  RESTORE THE REGISTERS.
         LR    R1,PLA    PUT THE ADDRESS OF THE TYPE 8 RPT IN REGISTER *
                         ONE.
         L     PLA,GPR12  RESTORE THE LINKAGE REGISTER.
         LTR   R15,R1    RETURN THE ADDRESS IN R15 ALSO, AND SET THE   *
                         CONDITION CODE TO REFLECT THE RETURN CODE.
         JMP   15,(LKR)  RETURN.
***********************************************************************
* SET UP THE TYPE 5 RADIX PARTITION TREE.                             *
***********************************************************************
*                                                                     *
      GODOWNTO SPACE     LEAVE A LITTLE ROOM AND ALIGN IT ON A 16-BYTE *
                         BOUNDARY.
SETUP5   EQU   *         COME HERE FROM THE CHECK FOR TYPE 5 STREE.
         LA    R0,IGATYP5S  THE SIZE OF THE TYPE 5 RPT HEADER.
         LTR   LKR,LKR   SEE IF THE STREE REQUEST IS CONDITIONAL OR IS
         BC    4,STR5COND  AN UNCONDITIONAL REQUEST, AND BRANCH IF IT  *
                         A CONDITIONAL REQUEST.
***********************************************************************
* USE AN UNCONDITIONAL GETMAIN TO ALLOCATE THE SPACE FOR THE TYPE 5   *
* RPT HEADER, BECAUSE THE STREE MACRO-INSTRUCTION WAS CODED FOR AN    *
* UNCONDITIONAL REQUEST.                                              *
***********************************************************************
         ALR   R0,R15    ADD IN THE SUBPOOL #.
         SLR   R0,R9     SUBTRACT OUT THE OTHER TWENTY FOUR BITS FROM  *
                         REGISTER 15.
       GETMAIN R,LV=(0)  UNCONDITIONAL GETMAIN.
         BC    15,SETUP5A      GO SET UP THE TYPE 5 RPT HEADER.
***********************************************************************
* USE A CONDITIONAL GETMAIN TO ALLOCATE THE SPACE FOR THE TYPE 5 RPT  *
* HEADER, BECAUSE THE STREE MACRO-INSTRUCTION WAS NOT CODED TO SELECT *
* AN UNCONDITIONAL REQUEST.                                           *
***********************************************************************
STR5COND EQU   *  COME HERE TO USE THE CONDITIONAL GETMAIN.
         LA    R1,EIGHT(,R13)  ADDRESS OF THE WORK AREA FOR THE        *
                         CONDITIONAL GETMAIN.
         SRL   R15,TWENTY4  GET THE SUBPOOL NUMBER RIGHT ALIGNED IN THE*
                         REGISTER.
       GETMAIN EC,A=(1),LV=(0),SP=(15),MF=(E,(1))  CONDITIONAL GETMAIN.
         ST    LKR,TWELVE(,R13)  STORE BACK THE LINKAGE REGISTER.
         LTR   R15,R15   TEST THE RETURN CODE FROM THE CONDITIONAL     *
                         GETMAIN.
         BZ    SETUP5A   BRANCH IF THE GETMAIN WAS SUCCESSFUL.
MINUSRC  LEAF  LV=,RC=-1,SAVE=(LKR,(R0,R12))
         DROP  PLA
SETUP5A  EQU   *         COME HERE FOR THE SETTING UP OF THE TYPE 5    *
                         TREEHEADER AFTER THE SUCCESSFUL GETMAIN.
         L     R1,EIGHT(,R13)  GET THE ADDRESS OF THE TREE HEADER.
         USING IGARPTH5,R1  USE THE TYPE 5 RPT HEADER.
         LA    R15,FOUR  GET A MINUS FOUR IN REGISTER 15
         LCR   R15,R15   FOR THE BXH INSTRUCTION.
         LA    LKR,IGAMASKZ-(IGATOP5+FOUR)  SET UP
         LA    R0,ONE    TO FILL IN THE TYPE 5 RPT HEADER.
STORE5   ST    R0,IGATOP5(LKR)  STORE THE NEXT MASK FOR SRCH5.
         ALR   R0,R0     GET THE NEXT MASK BY DOUBLING.
         BXH   LKR,R15,STORE5  FILL IN THE WHOLE MASK TABLE WITH THIS  *
                         LOOP.
         L     R15,IGAMASKS  GET THE DEAD SINK CONSTANT, I. E.         *
                         X'80000000'.
         ST    R15,IGATOP5  INDICATE ZERO SINKS IN THE TYPE 5 RPT.
         SRL   R6,SEVEN  GET THE KEY INDEX RIGHT ALIGNED IN REGISTER   *
                         SIX.
         STH   R6,IGAKEYI5  STORE THE INDEX TO THE FIRST BYTE OF THE   *
                         KEY IN THE RECORD.
         SRL   R7,23     GET THE KEY LENGTH RIGHT ALIGNED.
         STC   R7,IGAKEYL5  STORE THE KEY LENGTH IN THE TYPE 5 RPT     *
                         HEADER (NOTE THAT THE TYPE 5 KEY LENGTH CANNOT*
                         EXCEED 16 BYTES).
         STC   R3,IGASP5  STORE THE SUBPOOL #.
         MVC   (IGARPTH5+&IGABLST)(X'14'),=AL4(0,&IGANAME+&IGAINS5,&IGA*
               NAME+&IGADEL5,0,&IGANAME+&IGAGKW)
         L     R10,ADDRESS  THE ADDRESS OF IGARPT01.
         ST    R10,IGADDR5  STORE THE ADDRESS OF THE MODULE IGARPT01.
         DROP  R10
         MVI   IGADDR5,X'05'  FLAG IT AS A TYPE 5 RPT.
         LEAF  LV=,RC=(1),SAVE=(LKR,(R2,R12))
         DROP  R1
         DROP  R13
         LTORG *
         EJECT
***********************************************************************
* THIS IS THE SUBROUTINE FOR GETTING MORE INNER SPACE AND CHAINING IT *
* ON A FREE SPACE CHAIN. UPON ENTRY TO THE ROUTINE THE REGISTERS ARE  *
* AS INDICATED IN THE FOLLOWING COMMENTS:                             *
*                                                                     *
HDB      EQU   R2  THE ADDRESS OF THE FIXEDHDR DSECT FOR THE SPACE,   *
*                  IF THERE IS ONE. INITIALLY, HDB IS ZERO, AND A     *
*                  FIXEDHDR IS CONSTRUCTED THAT IS USED TO REFERENCE  *
*                  THE SPACE THEREAFTER. AFTER THE FIRST TIME, HDB    *
*                  HAS IN IT THE ADDRESS OF THE FIXEDHDR, WHICH IS THE*
*                  WORD CALLED HEADFREE IN THE FIXED DSECT. BIT ZERO  *
*                  IS A ONE IN THIS ADDRESS, SO THAT THE ADDRESS OF   *
*                  THE HEAD OF THE FREE SPACE CHAIN CAN BE STORED IN  *
*                  THE EDGE FIELD OF THE LAST VERTEX ON THE FREE SPACE*
*                  CHAIN. THEN WHEN A MOVE TO DECAPITATE THE CHAIN    *
*                  IS DONE, THE WORD AT HEADFREE IS MOVED TO IT'S OWN *
*                  LOCATION, THEREBY RESULTING IN AN EFFECTIVE NOP.   *
*                  THEN THE TEST FOR A SUCCESSFUL DECAPITATION FINDS  *
*                  THAT BIT ZERO IS ON, AND IT EXECUTES THIS ROUTINE  *
*                  TO GET MORE SPACE.                                 *
*                                                                     *
SPL      EQU   R3  THIS IS THE SUBPOOL AND LENGTH VALUE FOR GETMAIN.  *
XVL      EQU   R4  INNER VERTEX LENGTH; THE LENGTH OF EACH ENTRY ON   *
*                  THE FREE SPACE CHAIN.                              *
XTR      EQU   R5  THE AMOUNT OF SPACE TO LEAVE WHEN INITIALLY        *
*                  ALLOCATING SPACE, FOR SUCH THINGS AS THE TREEHDR.  *
*                  THIS IS ONLY GIVEN WHEN THIS IS THE INITIAL        *
*                  ALLOCATION, I. E. WHEN HDB=0. THEREAFTER THE       *
*                  FOLLOWING ARE THE CONTENTS:                        *
BBAS     EQU   R5  THE ADDRESS OF THE FIRST BLOCK ON THE BLOCK CHAIN, *
*                  WHOSE FORMAT IS GIVEN IN THE DSECT BLOCKHDR.       *
RFL      EQU   R6  WHEN THIS IS THE FIRST ALLOCATION, THEN THIS IS THE*
*                  SUBPOOL AND LENGTH VALUE TO USE FOR SUBSEQUENT     *
*                  GETMAINS. THIS WORD IS PUT INTO SPL AFTER THE FIRST*
*                  ALLOCATION OF SPACE.                               *
*                                                                     *
* LKR IS THE LINKAGE REGISTER, AND R15 IS THE PROGRAM BASE REGISTER.  *
* PRIOR TO ENTERING THIS ROUTINE ALL REGISTERS HAVE BEEN SAVED, SO    *
* THAT NO SAVING OF REGISTERS MUST BE DONE. ALL REGISTERS FROM 0 TO 10*
* ARE AVILABLE FOR USE IN THIS ROUTINE.                               *
***********************************************************************
BLOCKHDR DSECT 0  THIS IS THE DSECT FOR A TYPICAL ENTRY ON THE BLOCK  *
*                 CHAIN. THE BLOCK CHAIN KEEPS TRACK OF THE SPACE     *
*                 OBTAINED BY GETMAIN, SO THAT WHEN THE MACRO FTREE   *
*                 IS EXECUTED ALL THIS SPACE CAN BE RETURNED TO THE   *
*                 SYSTEM BY EXECUTING FREEMAINS FOR THE SAME SIZE     *
*                 THAT WAS REQUESTED ORIGINALLY.                      *
BEDGE    DC    F'0'  THIS IS THE EDGE FIELD CONTAINING THE ADDRESS OF *
*                    NEXT VERTEX ON THE BLOCK CHAIN. IF THIS IS THE   *
*                    LAST VERTEX THEN THIS FIELD IS ZERO.             *
BSPL     DC    F'0'  SUBPOOL AND LENGTH VALUE FROM THE GETMAIN THAT   *
*                    GOT THIS BLOCK.                                  *
BADR     DC    F'0'  THIS IS THE ADDRESS THAT WAS RETURNED FROM GETMAIN
BLOKBACK DC    F'0'  THE ADDRESS OF THE FIXED SPACE HEADER THAT HAS   *
*                    THIS BLOCK IN IT'S BLOCK CHAIN.                  *
BWORK    EQU   BLOKBACK  A WORK AREA THAT ENDS UP BY SETTING BLOKBACK.*
FIXBLNG  EQU   16  THE LENGTH OF THE BLOCK CHAIN ENTRY.
FIXEDHDR DSECT 0  DSECT FOR THE FIXED LENGTH IN-PLACE FREE SPACE CHAIN.
HEADFREE DC    F'0'  THE HEAD OF THE FREE SPACE CHAIN.
FXREFILL DC    F'0'  REFILL SUBPOOL AND ITEM LENGTH.
FIXDRECL DC    F'0'  THE LENGTH OF EACH ITEM IN THE FREE SPACE CHAIN.
BLOKHEAD DC    F'0'  THE HEAD OF THE BLOCK CHAIN.
FIXEDLNG EQU   32  LENGTH OF FIXEDHDR+BLOCKHDR
&PROGRAM CSECT
      GODOWNTO SPACE     LEAVE A LITTLE ROOM.
***********************************************************************
NEEDMORE EQU   *         ENTRY POINT IF 3 WORDS MUST BE LOADED.
         USING FIXEDHDR,HDB
         LM    HDB,BBAS,HEADFREE  LOAD THE WHOLE FIXEDHDR.
         DROP  HDB
GTMORINR EQU   *  ENTRY POINT IF THE REGISTERS HAVE BEEN LOADED WITH
*                 THE FOUR WORDS IN THE FIXEDHDR.
         LR    R0,SPL  SUBPOOL AND LENGTH VALUE FOR GETMAIN.
         LTR   LKR,LKR   SEE IF THIS IS A CONDITIONAL OR AN            *
                         UNCONDITIONAL REQUEST.
         BALR  R15,O     ESTABLISH ADDRESSABILITY.
         USING *,R15
         JMP   4,GFCOND  BRANCH IF IT IS A CONDITIONAL REQUEST.
      GETMAIN  R,LV=(0)  GET SPACE FOR A BLOCK OF INNER SPACE.
         DROP  R15  IN DOING SO IT LOST THE ADDRESSABILITY IN R15.
         BALR  R15,O  SO THAT ADDRESSABILITY HAS TO BE RECOVERED.
         USING *,R15  NATURALLY WE WANT TO USE THE NEW ADDRESSABILITY.
         JMP   15,TOTHERE  SKIP AROUND THE CONDITIONAL CASE.
         DROP  R15
GFCOND   LA    R1,O(,HDB)  GET THE ADDRESS OF THE WORK AREA FOR THE    *
                         GETMAIN USING THE LIST FORM AND EXECUTE.
         LR    R15,R0    PUT THE LENGTH VALUE IN REGISTER 15 AND
         LA    R15,O(,R15)  CLEAR THE LEFT BYTE.
         SRL   R0,TWENTY4  GET THE SUBPOOL NUMBER RIGHT ALIGNED IN THE *
                         REGISTER.
       GETMAIN EC,A=(1),LV=(15),SP=(0),MF=(E,(1))  CONDITIONAL GETMAIN.
         LTR   R15,R15   TEST THE RETURN CODE TO SEE IF THE CONDITIONAL*
                         GETMAIN WORKED.
         L     R1,O(O,R1)  GET THE ADDRESS OF THE SPACE OBTAINED VIA   *
                         GETMAIN.
         STM   HDB,BBAS,O(HDB)  PUT BACK THE THINGS THE LIST COVERED   *
                         UP.
         JMP   7,(LKR)   RETURN IF THE ALLOCATION DID NOT SUCCEED.
TOTHERE  BALR  R15,O     ESTABLISH NEW ADDRESSABILITY.
         USING *,R15
***********************************************************************
* NOW THE SIXTEEN BYTE BLOCK DEFINITION ENTRY IS TAKEN FROM THE FRONT *
* OF THE SPACE JUST OBTAINED.                                         *
         SNIP
         USING BLOCKHDR,R1  USING TO STORE THE RIGHT STUFF.
         STM   R0,R1,BSPL  STORE THE TWO DEFINING WORDS FOR THE BLOCK.
*---------------------------------------------------------------------*
         LTR   HDB,HDB         TEST HDB TO SEE IF IS ZERO , BRANCHING
         BC    4,SUBSQUNT      IF IT IS NOT THE FIRST ALLOCATION.
         SNIP
*---------------------------------------------------------------------*
*  IT IS THE FIRST ALLOCATION.                                        *
         ST    HDB,BEDGE  ZERO OUT THE EDGE BECAUSE THIS IS THE LAST
*                         BLOCK ON THE BLOCK CHAIN.
         LR    SPL,RFL    NOW THE SUBPOOL AND LENGTH VALUE FOR
*                         GETMAINS IS SET, SINCE THE INITIAL VALUE HAS
*                         BEEN USED AND RECORDED IN THE BLOCK CHAIN.
XTRB     EQU   R6  THIS REGISTER HAS THE ADDRESS OF THE EXTRA SPACE
*                  REQUIRED IF IT IS THE FIRST TIME.
         LA    XTRB,FIXEDLNG(O,R1)  COMPUTE THE ADDRESS OF THE EXTRA.
XCUR     EQU   R7  ADDRESS OF THE FIRST BYTE OF THE SPACE TO BE CHAINED
*                  TOGETHER. IT IS INCREMENTED DURING THE BXLE LOOP.
         LA    XCUR,FIXEDLNG(XTR,R1)  COMPUTE THE ADDRESS.
         LR    BBAS,R1  SET THE ADDRESS OF THE BLOCK CHAIN HEAD.
         DROP  R1
         USING BLOCKHDR,BBAS  USE THIS ADDRESS FROM NOW ON.
         LA    HDB,FIXBLNG(O,R1)  GET THE ADDRESS OF THE SPACE HEADER.
         AL    HDB,=XL4'80000000'  SET THE LEFT BIT ON TO SIGNAL THE
*                                  END OF THE FREE SPACE CHAIN.
         BC 15,FSPMERGE  NOW JOIN WITH THE OTHER PATH FROM NOT THE
*                        FIRST TIME.
         DROP  BBAS  DROP IT UNTIL THE OTHER PATH MERGES WITH THIS ONE.
*---------------------------------------------------------------------*
SUBSQUNT EQU   *  BRANCH POINT FOR NOT THE FIRST TIME.
         USING BLOCKHDR,R1  ALLOCATE THE BLOCK CHAIN ENTRY FROM THE
         ST    BBAS,BEDGE   FRONT OF THE SPACE, CHAINING THE NEW
         LR    BBAS,R1      ENTRY ON THE FRONT OF THE CHAIN.
         DROP  R1
         LA    XCUR,FIXBLNG(O,R1)  COMPUTE THE ADDRESS OF THE FIRST
*                                  BYTE OF THE SPACE TO CHAIN TOGETHER.
*---------------------------------------------------------------------*
FSPMERGE EQU   *  HERE IS WHERE RHE SEQUENCES COME TOGETHER.
         SNIP
         USING FIXEDHDR,HDB  HDB IS NOW GUARANTEED TO HAVE THE ADDRESS
*                            OF THE FIXEDHDR.
         STM   HDB,BBAS,HEADFREE  IT STORES THE WHOLLLE THING.
XINC     EQU  XVL  THE INCREMENT FOR THE BXLE IS THE SAME AS THE LENGTH
*                  OF EACH ENTRY ON THE FREE SPACE CHAIN.
XLIM     EQU   R5  THIS IS THE LIMIT FOR THE BXLE; NOTE HOW TRICKY THIE
*                  LIMIT IS TO COMPUTE.
XPRED    EQU   R8  PREDECESSOR OF THE VERTEX XCUR DURING THE BXLE LOOP.
XNEG     EQU   R3  COMPLEMENT OF ITEM LENGTH FOR SUBTRACTING.
XBBAS    EQU   R9              USE THIS REGISTER INSTEAD OF BBAS,
         LR    XBBAS,BBAS      BECAUSE BBAS AND XLIM ARE THE SAME
         USING BLOCKHDR,XBBAS  COLOR. HTE COLORING IS NOT QUITE PERFECT
         LCR   XNEG,XINC  PUT THE COMPLEMENT OF ITEM LENGTH IN XNEG.
         ALR   R1,R0     COMPUTE THE ADDRESS OF THE FIRST BYTE PAST THE
*                        SPACE OBTAINED BY THE GETMAIN.
         LA    XLIM,O(XNEG,R1)  SUBTRACT ONE ITEM LENGTH AND CLEAR THE
*                               HIGH ORDER BYTE FOR THE BXLE LIMIT.
         ST    XCUR,HEADFREE   STORE THE HEAD OF THE CHAIN IT IS MAKING
*                              IN THE HEAD OF THE CHAIN IN FIXEDHDR.
*                              IT IS STORED DOWN HERE INSTEAD OF UP
*                              THERE BECAUSE IT GIVES THE MEMORY TIME
*                              TO REST, SO IT IS READY TO STORE AGAIN.
         LR    XPRED,XCUR      GET SET TO START THE BIG LOOP.
         SNIP
         BXH   XCUR,XINC,BXLEND  THERE MIGHT BE ONLY ROOM FOR ONE.
         LA    R0,3  SEE IF THE FAST LOOP CAN BE USED, BY CHECKING THE
         NR    R0,XCUR  THE ITEM LENGTH TO SEE IF IT IS A MULTIPLE OF 4
         BC    8,FASTLOOP  BRANCH IF THE FAST LOOP CAN BE USED.
         SNIP
BXLOOP   ST    XCUR,BWORK  STORE THE CURRENT ADDRESS TO STORE IT INTO
         MVC   O(4,XPRED),BWORK THE EDGE FIELD OF IT'S PREDECESSOR.
         LR    XPRED,XCUR       GET THE CURRENT ONE FOR NEXT TIME'S
*                               PREDECESSOR.
         BXLE  XCUR,XINC,BXLOOP  LOOP CLOSURE.
BXLEND   ST    HDB,BWORK  STORE THE EDGE FIELD FOR THE LAST VERTEX,
         MVC   O(4,XPRED),BWORK  WHICH HAS THE LEFT BIT ON AND GOES TO
*                                THE FIXED SPACE HEADER.
         LR    R1,XTRB  PUT THE ADDRESS OF THE EXTRA SPACE (IF ANY) IN
*                       REGISTER ONE FOR CONVENIENT REMEMBERING WHERE
*                       IT IS IN OTHER PLACES.
         SNIP
         BCR   15,LKR  HAVING FINISHED THIS LONG NARRATIVE, RETURN.
         CNOP  0,8   IT GOES MUCH FASTER WHEN IT IS ON A DOUBLE-WORD
*                    BOUNDARY.
FASTLOOP ST    XCUR,O(XNEG,XCUR)  BY USING THE NEGATIVE INDEX IT WORKS.
         BXLE  XCUR,XINC,FASTLOOP  LOOP CLOSURE.
         SNIP
         ST    HDB,O(XNEG,XCUR)  STORE THE LAST EDGE FIELD.
         ST    HDB,BWORK  STORE THE EDGE TO THE FIXEDHDR.
         LR    R1,XTRB  LOAD THE ADDRESS OF THE EXTRA SPACE.
         SNIP
&SNIP    SETB  (0)  TURN OFF THE SNIP TRACE.
         BCR   15,LKR  AND RETURN.
         DROP  XBBAS    DON'T NEED THIS ANY MORE.
         DROP  HDB   USINGS ANY MORE.
         DROP  R15
*---------------------------------------------------------------------*
* UPON RETURN, R1 HAS THE ADDRESS OF THE EXTRA SPACE, AND             *
* HDB, REGISTER 2, HAS THE ADDRESS OF THE FIXEDHDR.                   *
***********************************************************************
         EJECT
***********************************************************************
* MISCELLANEOUS ROUTINES TO TAKE CARE OF THE BOUNDARY CONDITIONS FOR  *
* GSPACE, FOR EXAMPLE, THE TCBRPT WORD IS ZERO, OR THE REQUEST        *
* SUBPOOL IS NOT IN THE SPACE CONTROL SUBPOOL CHAIN, ETC..            *
***********************************************************************
*                                                                     *
***********************************************************************
* THE SPACE CONTROL AREA FOR THE REQUEST SUBPOOL HAS NOT YET BEEN SET *
* UP ON THE SPACE CONTROL AREA CHAIN ORIGINATING FROM THE TCBRPT WORD.*
* GO BACK TO THE SPACE CONTROL AREA FOR SUBPOOL ZERO, WHICH HAS TWO   *
* SAVE AREAS IN IT, AND SAVE THE REGISTERS IN IGASA1. THEN GET A SPACE*
* CONTROL AREA FOR THE NEW SUBPOOL AND CHAIN IT ON THE END OF THE     *
* EXISTING CHAIN.                                                     *
* THE LAST WORD IN THE CHAIN HAS THE ADDRESS OF THE SPACE CONTROL AREA*
* FOR SUBPOOL ZERO IN IT FOR EASE OF GETTING BACK THERE.              *
***********************************************************************
      GODOWNTO SPACE
GSP#GONE EQU   *  COME HERE WHEN THE SUBPOOL IS NOT THERE.
         L     R15,O(,R1)  LOAD THE ADDRESS OF THE SPACE CONTROL AREA  *
                         FOR SUBPOOL ZERO.
         USING IGASPCTL,R15
         STM   LKR,R12,(IGASA1+((4*LKR)+20-64*((2+LKR)/16)))  SAVE THE *
                         REGISTERS IN SAVE AREA 1.
         DROP  R15
         LR    R2,R15    THE ADDRESS OF THE SPACE CONTROL AREA FOR     *
                         SUBPOOL ZERO.
         USING IGASPCTL,R2
         LR    R4,R1     ADDRESS OF THE LAST 8-BYTE ENTRY ON THE SPACE *
                         CONTROL AREA CHAIN.
         LR    R1,R2     THE ADDRESS OF THE SPACE CONTROL AREA FOR     *
                         SUBPOOL ZERO.
         BALR R12,O      ESTABLISH A BASE REGISTER FOR THIS SECTION.
NEWSPCTL EQU   *  USE THIS LABEL IN THE USING STATEMENTS.
         USING NEWSPCTL,R12
         L     LKR,=AL4(&IGANAME+&IGAGS8)  LOAD THE ADDRESS OF THE     *
                         POINT TO GET 8 BYTES USING THE FIXEDHDR IN THE*
                         SPACE CONTROL AREA FOR SUBPOOL ZERO.
         BALR  LKR,LKR   GET THE 8 BYTES.
         LR    R8,R1     SAVE THE ADDRESS OF THE NEW 8-BYTE AREA.
         LA    R3,FOUR   SET THE BOUNDARY ALIGNMENT TO ALLOCATE SPACE  *
                         ON 16-BYTE BOUNDARIES.
         L     R6,IGASA1+((4*R0)+20-64*((2+R0)/16))  LOAD THE SUBPOOL  *
                         AND REQUEST LENGTH.
         LA    R0,&IGASPZ  THE SIZE OF A SPACE CONTROL AREA.
         ALR   R0,R6     ADD IN THE SUBPOOL FOR THE NEW SPACE CONTROL  *
                         AREA.
         LA    R7,O(,R6)  CLEAR THE SUBPOOL BYTE.
         SLR   R0,R7     SUBTRACT OUT THE REQUEST LENGTH.
       GETMAIN R,LV=(0)  GET THE SPACE FOR THE NEW SPACE CONTROL AREA.
         ICALL SETSPACE  SET UP THE NEW SPACE CONTROL AREA.
         SLR   R6,R7     MAKE THE SUBPOOL BYTE BE ALL BY ITSELF.
         ALR   R6,R1     ADD IN THE ADDRESS OF THE NEW SPACE CONTROL   *
                         AREA FOR THE 8-BYTE ENTRY.
         LR    R5,R2     GET THE ADDRESS OF THE SPACE CONTROL AREA FOR *
                         SUBPOOL ZERO (NOTE THAT BIT 0 OF THE ADDRESS  *
                         WORD IS A ONE).
         STM   R5,R6,O(R8)  STORE THE NEW 8-BYTE ENTRY.
         ST    R8,O(,R4)  STORE THE EDGE FIELD TO THE NEW 8-BYTE ENTRY.
         L     LKR,IGASA1+((4*LKR)+20-64*((2+LKR)/16))  RESTORE LKR.
         L     R15,=AL4(&IGANAME)  RESTORE THE ADDRESS OF THE BEGINNING*
                         OF THE IGARPT01 MODULE.
         LM    R0,R12,(IGASA1+((4*R0)+20-64*((2+R0)/16)))  RESTORE THE *
                         REST OF THE REGISTERS.
         DROP  R12
         B     &IGAGSP.(,R15)  RE-ENTER THE ROUTINE AS IF NOTHING HAD  *
                         HAPPENED.
         DROP  R2
      GODOWNTO SPACE
***********************************************************************
* COME HERE TO SET UP THE SPACE CONTROL AREA FOR THE FIRST TIME.      *
***********************************************************************
FIRST1   EQU   *   COME HERE FROM GSPACEB WHEN THE TCBRPT WORD IS ZERO.
         USING GSPACEB,R15  USE THE PREVIOUSLY ESTABLISHED             *
                         ADDRESSABILITY.
         AL    REQL,TWOTO8  ADD IN ENOUGH TO GET AT LEAST 256 BYTES FOR*
                         A TEMPORARY WORK ARE.
       GETMAIN R,LV=(0)  GET THE WORK AREA.
         DROP  R15       GETMAIN CHANGES R15, SO IT NO LONGER HAS THE  *
                         ADDRESS IN IT.
         BALR  R15,O     GET ANOTHER ADDRESS IN R15.
         USING *,R15     AND USE IT FOR ADDRESSABILITY.
         USING SAVEDSEK,R1  SAVE THE REGISTERS FROM THE CALLING PROGRAM
         STM   R13,R12,FORWARD  IN THE WORKAREA.
         LR    R9,R1     GET THE ADDRESS OF THE TEMPORARY WORK AREA.
         DROP  R1  NOW USE R1 FOR THE ADDRESS OF THE TCBRPT WORD AGAIN.
         USING SAVEDSEK,R9  USE R9 FOR THE ADDRESS OF THE TEMPORARY    *
                         WORK AREA.
      RPTDSECT GEN=(TCBRPTA,(R3))  GET THE ADDRESS OF THE TCBRPT WORD.
         LA    R1,SAVEFIN  GENERATE THE ADDRESS OF THE LIST IN THE WORK*
                         AREA FOR GETMAIN.
         DROP  R15
         LA    0,&IGASPZ  GET THE LENGTH IN THE REGISTER SO IT WON'T   *
                         GENERATE AN ADDRESSABILITY ERROR.
       GETMAIN EU,A=(1),LV=(0),SP=0,MF=(E,(1))  THE GETMAIN STORES THE *
                         ADDRESS OF THE SPACE CONTROL AREA IN TCBRPT.
***********************************************************************
* NOW SET UP REGISTERS 0, 1, 2, AND 3 FOR THE SETSPACE ROUTINE, WHICH *
* INITIALIZES THE SPACE CONTROL AREA. THIS TIME THE SUBPOOL IS ZERO,  *
* BECAUSE IF THERE ISN'T A SPACE CONTROL AREA FOR SUBPOOL ZERO IT IS  *
* VERY DIFFICULT TO MAINTAIN THE SPACE CONTROL SUBPOOL CHAIN.         *
***********************************************************************
         BALR  R15,O     ESTABLISH ADDRESSABILITY.
         USING *,R15
         LM    R0,R1,O(R1)  LOAD THE LENGTH VALUE AND THE ADDRESS OF   *
                         THE SPACE CONTROL AREA INTO REGISTERS R0 AND  *
                         R1 RESPECTIVELY.
         L     R2,=XL4'80000000'  MAKE BIT 0 OF R2 A ONE TO SET THE    *
                         END-OF-CHAIN FLAG BIT IN SETSPACE.
         ALR   R2,R1     ADD IN THE ADDRESS OF THE SPACE CONTROL AREA  *
                         FOR SUBPOOL ZERO.
         ICALL SETSPACE  NOTE THAT SETSPACE BETTER NOT CHANGE REGISTER *
                         9, OR TROUBLE WILL DEVELOP.
         DROP  R15
* NOW FREE UP THE WORK AREA, AFTER TRANSFERRING THE REGISTER CONTENTS *
* TO THE NEWLY ESTABLISHED SPACE CONTROL AREA.                        *
         ST    R1,GPR15  STORE THE ADDRESS OF THE SPACE CONTROL AREA   *
                         FOR SUBPOOL ZERO.
         LM    R13,R12,FORWARD  RESTORE THE REGISTERS ALMOST THE WAY   *
                         THEY WERE BEFORE.
         DROP  R9
         STM   LKR,R12,(&IGASA0+((4*LKR)+20-64*((2+LKR)/16)))(R15)     *
                         SAVE THE REGISTERS IN SAVE AREA 0 IN THE SPACE*
                         CONTROL AREA.
         LR    LKR,R15   SAVE R15 FOR LATER.
      FREEMAIN R,LV=(0),A=(1)
         LR    R1,LKR    NOW GET THE ADDRESS OF THE SPACE CONTROL AREA *
                         FOR SUBPOOL ZERO IN R1.
         L     LKR,(&IGASA0+((4*LKR)+20-64*((2+LKR)/16)))(,R1)         *
                         RESTORE THE LINKAGE REGISTER FROM SAVE AREA 0 *
                         IN THE SPACE CONTROL AREA.
         BALR  R15,O     ESTABLISH ADDRESSABILITY.
         USING *,R15
         L     R15,=AL4(GSPACEB)  USE GSPACEB FOR THE BASE REGISTER.
         DROP  R15
         USING GSPACEB,R15
         SL    REQL,X0100  SUBTRACT OUT THE X'100' THAT WAS ADDED TO   *
                         THE REQUEST LENGTH TO GET A WORK AREA LARGE   *
                         FOR A REGISTER SAVE AREA.
         JMP   15,CHKSP#G  GO CHECK THE REQUEST SUBPOOL AGAINST ZERO.
         DROP  R15
         EJECT
***********************************************************************
* ROUTINE TO SET UP THE SPACE CONTROL AREA. UPON ENTRY TO SETSPACE THE*
* REGISTERS HAVE THE FOLLOWING CONTENTS:                              *
*        R0    THE SUBPOOL # FOR THE AREA AND IT'S LENGTH.            *
*        R1    THE ADDRESS OF THE AREA TO BE SET UP.                  *
*        R2    THE ADDRESS OF THE SPACE CONTROL AREA FOR SUBPOOL ZERO,*
*              OR THE ZERO FOR THE INITIAL ALLOCATION.                *
*        R3    THE POWER OF TWO TO USE FOR ROUNDING REQUESTS BEFORE   *
*              THEY ARE SERVED. FOR EXAMPLE, IF R3 CONTAINS A 4 A     *
*              SIXTEEN-BYTE BOUNDARY IS IMPLIED. THIS NUMBER IS       *
*              TRANSLATED TO THE COMPLEMENT OF TWO RAISED TO THE POWER*
*              IN R3, AND THEN STORED IN IGAROUND IN THE SPACE CONTROL*
*              AREA.                                                  *
*        R15   THE ADDRESS OF SETSPACE.                               *
*        LKR   THE RETURN ADDRESS.                                    *
***********************************************************************
      GODOWNTO SPACE
SETSPACE EQU   *         ENTER HERE.
         USING SETSPACE,R15
         USING IGASPCTL,R1  ESTABLISH ADDRESSABILITY TO THE AREA.
         XC    IGASPCTL(X'40'),IGASPCTL  ZERO OUT THE FIRST PART OF THE*
                         SPACE CONTROL AREA.
         ST    R0,IGASPLNG  STORE THE SUBPOOL AND LENGTH OF THE SPCA.
         LA    R3,B'00010000'  GET THE POWER OF TWO TO BE USED FOR     *
                         ROUNDING REQUEST LENGTHS.
         LCR   R3,R3     TAKE THE COMPLEMENT.
         STM   R2,R3,IGASPEDG  STORE THE EDGE FIELD FOR THE SUBPOOL    *
                         CHAIN AND THE MASK FOR IGAROUND.
         LA    R4,IGASA0  CHAIN THE SAVE AREAS IN A MEANINGFUL WAY.
         LA    R5,IGASA1  XX
         ST    R5,(FORWARD-SAVEDSEK+IGASA0)  STORE THE FORWARD CHAIN   *
                         EDGE FIELD IN THE FIRST SAVE AREA.
         ST    R4,(IGASA1+BACKWARD-SAVEDSEK)  STORE THE BAKPATH CHAIN  *
                         EDGE FIELD.
         LA    R6,IGAS8  GET THE ADDRESS OF THE 8-BYTE FIXEDHDR.
         AL    R6,=XL4'80000000'  TURN ON THE HIGH ORDER BIT FOR GSPACE*
                         SO THE REQUEST IS A CONDITIONAL REQUEST.
         USING FIXEDHDR,R6
         MVC  HEADFREE(SIXTEEN),=XL16'00000000000001000000000800000000'
         LR    R7,R0     PUT THE SUBPOOL # IN THE FXREFILL FIELD.
         SRL   R7,24     ALIGN IT FIRST.
         STC   R7,FXREFILL     STORE IT INTO THE REFILL SUBPOOL FIELD.
         MVC   FXREFILL+X'10'(X'20'),FXREFILL  PROPAGATE THE SIXTEEN   *
                         BYTES INTO THE OTHER TWO FIXEDHDR AREAS.
         ST    R6,HEADFREE     FILL IN THE HEAD OF THE FREE SPACE CHAIN
         AL    R6,=XL4'00000010'  STEP DOWN TO THE 12-BYTE FIXEDHDR.
         MVI   FIXDRECL+3,TWELVE  PUT IN THE LENGTH.
         MVI   FXREFILL+TWO,SIXTEEN  MAKE THE REFILL SIZE 4K.
         DROP  R1        NOW FILL IN THE HEAD OF THE VERTEX FREE SPACE *
                         CHAIN FOR THE TYPE 9 RADIX PARTITION TREE.
         USING IGARPTH,R1      XX
         ST    R6,IGAHVFC      STORE THE HEAD OF THE CHAIN.
         STC   R7,IGA9FILL  STORE THE SUBPOOL NUMBER FOR THE SPACE     *
                         CONTROL AREA.
         MVI   IGA9FILL+TWO,SIXTEEN  MAKE THE REFILL SIZE 4K.
         DROP  R1        GO BACK TO THE OTHER USING NOW,
         USING IGASPCTL,R1  AND FILL IN THE OTHER FIXEDHDR.
         ST    R6,HEADFREE     STORE THE HEAD OF THE CHAIN.
         AL    R6,=XL4'00000010'  STEP DOWN TO THE 80-BYTE FIXEDHDR.
         ST    R6,HEADFREE     STORE THE EMPTY HEAD.
         MVI   FIXDRECL+3,EIGHTY       FILL IN THE INTERNAL LENGTH.
         MVI   FXREFILL+TWO,EIGHT  MAKE THE REFILL SIZE EQUAL TO       *
                         X'0800'.
GRJBGGL EQU ((SETSPACE-&PROGRAM)-(X'100'*((SETSPACE-&PROGRAM)/X'100')))
FIGLFUJ  EQU   ((X'100'-GRJBGGL)*((GRJBGGL*2)/(GRJBGGL+1)))
         AL   R15,=AL1(X'08',X'FF',X'100'-((SETSPACE-&PROGRAM)/X'100')+-
               0-((GRJBGGL*2)/(GRJBGGL+1)),FIGLFUJ)
* FILL IN THE NINE FOR THE TYPE 9 RPT FLAG BYTE AND FILL IN THE       *
* ADDRESS OF THE BASE OF THE MODULE IGARPT01.                         *
         DROP  R1
         USING IGARPTH,R1
         ST    R15,IGADDR      STORE IN THE ADDRESS.
         MVI   IGAKEYL+ONE,THREE  FILL IN THE LENGTH OF THE KEY.
         MVI   IGAKEYI+ONE,ONE  SET THE KEY INDEX TO ONE.
         BR    LKR       RETURN TO FROM WHENCE IT CAME.
         DROP  R1
         DROP  R6
         DROP  R15
      GODOWNTO SPACE
***********************************************************************
     COLLECT
         LTORG *
         EJECT
         AIF   (NOT &SNAP).SKPSNAP
***********************************************************************
* THE FOLLOWING SUBROUTINE PRODUCES A FORMATTED DISPLAY OF A TYPE 8 OR*
* TYPE 9 RADIX PARTITION TREE. THE DISPLAY IS WRITTEN ON THE DATA SET *
* NAMED SNAPOUT. THE DD CARD FOR SNAPOUT SHOULD HAVE LRECL=121 CODED, *
* AND THE BLKSIZE CAN BE SET TO 121 TO GET THE LAST LINE OF FORMATTED *
* DISPLAY BEFORE THE ONE THAT HANGS UP THE DISPLAY ROUTINE IF THERE   *
* ARE PROBLEMS WITH THE TREE.                                         *
***********************************************************************
&IGASPIE SETB  (0)  TURN THE JUMP TRACE OFF.
X        EQU   8
Y        EQU   9
Z        EQU   10
DSPRPT   NTR   RASS=0,BR=R11,LV=80,R1=(R5),MODE=GETMAIN
         LR    R1,R5
DSPMORE  EQU   *
         LR    R5,R1
         L     0,CONTRSPY
         CL    0,CNT
         BC    2,DSPBACK
         USING IGARPTH,R5
SNAPOPEN BC    0,DSPKIPS       BRANCH IF SNAPOUT IS ALREADY OPEN.
         OPEN  (OUTDCB,(OUTPUT))
         OI    SNAPOPEN+1,X'F0'  SET IT OPEN FROM NOW ON.
DSPKIPS  EQU   *
***********************************************************************
*  DISPLAY THE BLOCK CHAIN OF SPACE OBTAINED VIA GETMAIN.             *
***********************************************************************
TRYTREE EQU *
***********************************************************************
*    DISPLAY THE CONTENTS OF THE TREE HEADER.                         *
***********************************************************************
         L     R2,=AL4(HDRDSP)
         PUT   OUTDCB,0(0,R2)
       SHOWHEX TO=HADDR,FROM=IGADDR,N=4
DSPHEX   EQU   IGADSPHX
         SHOWHEX TO=HAPT,FROM=APT,N=4
     SHOWHEX   TO=HP,FROM=AP,N=4
       SHOWHEX TO=HC,FROM=AC,N=4
         SHOWHEX FROM=FARG,TO=HFARG,N=4
       SHOWHEX TO=HHVFC,FROM=IGAHVFC,N=4
       SHOWHEX TO=HKEYL,FROM=IGAKEYL,N=2
         SHOWHEX TO=HOFF,FROM=OFFSET,N=2
         SHOWHEX TO=HHVFC,FROM=HVFC,N=4
       SHOWHEX TO=HMAX,FROM=IGAMAX,N=4
       SHOWHEX TO=HVALUE,FROM=IGAVALUE,N=4
         PUT   OUTDCB,HDRCON
         IC    R1,PATH   DISPLAY THE BITS IN THE PATH BYTE.
         N     R1,=XL4'0000000F'
         SLL   R1,2      MULTIPLY BY FOUR.
         AL    R1,=AL4(HEX)
         MVC   HPATH+2(4),0(R1)
***********************************************************************
*  DISPLAY THE FIXEDHDR FOR THE INNER VERTEX SPACE AND THE BLOCK CHAIN*
***********************************************************************
         L     X,IGAHVFC       ADDRESS OF FIXEDHXR.
         USING FIXEDHDR,X
       SHOWHEX TO=HHDFREE,FROM=HEADFREE,N=4
       SHOWHEX FROM=FXREFILL,TO=HFXR,N=4
       SHOWHEX TO=HFXDRCL,FROM=FIXDRECL,N=4
       SHOWHEX TO=HBLKHD,FROM=BLOKHEAD,N=4
         PUT   OUTDCB,HFIXD0   DISPLAY THE FIXEDHDR.
         PUT   OUTDCB,HBLOK00          BLOCK CHAIN TRACE MESSAGE.
         L     X,BLOKHEAD      GET THE ADDRESS OF THE FIRST BLOCKHDR.
         DROP  X
         USING BLOCKHDR,X
         BC    15,HBLOKN       GO TEST FOR THE END OF THE CHAIN.
HBLOKLUP EQU   *
       SHOWHEX TO=HBEDGE,FROM=BEDGE,N=4
       SHOWHEX TO=HBSPL,FROM=BSPL,N=4
       SHOWHEX TO=HBADR,FROM=BADR,N=4
         PUT   OUTDCB,HBLOKHED   WRITE OUT THE BLOCK CHAIN ELEMENT.
         L     X,BEDGE   LOAD NEXT EDGE IN THE BLOCK CHAIN.
HBLOKN   EQU   *
         LTR   X,X
         BC    7,HBLOKLUP
         DROP  X
         TM    PATH,P1000      SEE IF THERE ARE LESS THAN TWO SINKS.
         BC    8,DSPRPTZ       BRANCH IF SO.
         L     X,APT     SET X, Y, AND Z TO THE SOURCE OF
         LR    Y,X       THE RADIX PARTITION TREE.
         L     R2,=AL4(DSPRPT0)
         PUT   OUTDCB,0(0,R2)
         L     R2,=AL4(DSPRPT1)
         PUT   OUTDCB,0(0,R2)
***********************************************************************
* DISPLAY THE INNER VERTEX Y, TOGETHER WITH IT'S PREDECESSOR, AND     *
* LEFT AND RIGHT SUCCESSORS, IN ABSOLUTE ADDRESSES. ALSO DISPLAY ALL  *
* OF THE FLAG FIELDS.                                                 *
* THE DISPLAY ONLY ASSUMES THAT X AND Y ARE VALID, SINCE IT           *
* GENERATES THE SUCCESSOR VERTICES BEFORE THE DISPLAY.                *
***********************************************************************
DSPRA    EQU   *
         ST    Y,DTMP
         LA    R1,VERTEX
         LA    R2,DTMP+1
         LA    R3,3
         ICALL DSPHEX
*----------------------------------------------------------------------
         LA    R1,DBYTE
 LA      R2,BYTEI(Y)     BYTE INDEX.
         LA    R3,1
         ICALL DSPHEX
*----------------------------------------------------------------------
         IC    R3,FLAGS(Y)
         SRL   R3,5
         SLL   R3,2
         AL    R3,=AL4(DSPTAB)
         MVC   DBIT(3),0(R3)
*----------------------------------------------------------------------
         MVI   DRL,C'0'
         BIV0  Y,DSPGONE
         MVI   DRL,C'1'
DSPGONE  EQU   *
*----------------------------------------------------------------------
         MVI   DC0,C'0'
         TM    FLAGS(Y),IGANEBIT  TEST THE BIT TO SEE IF UNEQUALS THERE
         BC    8,DSPGO2
         MVI   DC0,C'1'
DSPGO2   EQU   *
*----------------------------------------------------------------------
         MVI   DC1,C'1'
         TM    FLAGS(Y),IGAQBIT
         BC    1,DSPGO3
         MVI   DC1,C'0'
DSPGO3   EQU   *
*----------------------------------------------------------------------
         MVI   DT0,C'0'
         BT00  Y,DSPGO4
         MVI   DT0,C'1'
DSPGO4   EQU   *
*----------------------------------------------------------------------
         MVI   DT1,C'0'
         BT10  Y,DSPGO5
         MVI   DT1,C'1'
DSPGO5   EQU   *
*----------------------------------------------------------------------
       SHOWHEX N=4,TO=LATTICEV,FROM=VALUE(Y)
*---------------------------------------------------------------------*
 ST      X,DTMP
         LA    R1,DANTE
         LA    R2,DTMP+1
 LA      R3,3
         ICALL DSPHEX
*----------------------------------------------------------------------
         BT01  Y,DSPINT
 G0ES    X,Y,Z
         MVC   LSINK(8),0(Z)   DISPLAY LEFT SINK CONTENTS.
 BC      15,DSPCOM
DSPINT   TLEF  X,Y,Z
         MVC   LSINK(8),=CL8' '        BLANK OUT LEFT SINK CONTESTS.
DSPCOM   ST    Z,DTMP
         LA    R1,DLEFT
         LA    R3,3
         ICALL DSPHEX
*----------------------------------------------------------------------
         BT11  Y,DSPORG
         G1ES  X,Y,Z
         MVC   RSINK(8),0(Z)   DISPLAY RIGHT CONTENTS.
         BC    15,DSPTOR
DSPORG   TREF  X,Y,Z
         MVC   RSINK(8),=CL8' '        BLANK OUT RIGHT SINK CONTENTS.
DSPTOR   EQU   *
 ST      Z,DTMP
         LA    R1,DRIGHT
         LA    R3,3
         ICALL DSPHEX
*----------------------------------------------------------------------
         LR    R2,Y
         LA    R1,CONTENTS     DISPLAY THE ACTUAL CONTENTS AT VERTEX.
    LA  R3,8
         ICALL  DSPHEX
*----------------------------------------------------------------------
         PUT   OUTDCB,DSPRPT2
***********************************************************************
*  RESUME THE LEFT LIST SCAN.    **************************************
***********************************************************************
         BT00  Y,DSPRB   BRANCH IF Y'S LEFT SUCCESSOR IS A SINK.
         TLEF  X,Y,Z,CYCLE=YES
         BC    15,DSPRA
DSPRB    BT10  Y,DSPRC   BRANCH IF Y HAS NOT AN INNER RIGHT SUCCESSOR.
         TREF  X,Y,Z,CYCLE=YES
         BC    15,DSPRA
DSPRC    BIV0  Y,DSPRD   BRANCH IF Y IS A LEFT SUCCESSOR.
         TREB  X,Y,Z,CYCLE=YES
         BC    15,DSPRC
DSPRD    EQU   *
***********************************************************************
* CHECK TO SEE IF THE SOURCE HAS BEEN REACHED FROM A RIGHT SUCCESSOR, *
* FOR WHEN THIS HAPPENS THE SCAN IS COMPLETELY FINISHED.              *
***********************************************************************
         LA    X,0(0,X)  CLEAR THE LEFT BYTE TO CHECK.
         LA    Y,0(0,Y)        LIKEWISE.
         CLR   X,Y       CHECK FOR THE SOURCE DONE.
         BC    8,DSPRPT9       END IS SO.
         TLEB  X,Y,Z,CYCLE=YES
         BC    15,DSPRB
DSPRPTZ  EQU   *
         TM    PATH,P0001      SEE IF THERE IS AT LEAST ONE SINK.
         BC    1,DSPRPT4       DISPLAY IT IF THERE IS.
         MVC   OUT(10),=CL10'EMPTY TREE'
         BC    15,DSPRPT8
DSPRPT4  MVC   OUT(10),=CL10'ONE SINK.'
       SHOWHEX TO=OUT+12,FROM=0(R5),N=12
         L     Z,APT     DISPLAY THE CONTENTS.
         MVC   RSINK(8),0(Z)   MOVE THE CONTENTS OUT.
DSPRPT8  PUT   OUTDCB,OUT0     DISPLY THE MESSAGE.
         MVC   OUT(120),=CL120' '      BLANK OUT THE PRINT AREA.
DSPRPT9  EQU   *
DSPBACK  EQU   *
         AGO   .FICKLE
***********************************************************************
* TEST THE RECORD FREE SPACE CHAIN FOR VALIDITY.                      *
***********************************************************************
         CLI   IGADDR,X'08'    ONLY DO THIS FOR TYPE 8 TREES.
         JMP   7,FECKLESS      BRANCH IF IT ISN'T A TYPE 8 RPT.
         TM    IGARECL,X'80'   SEE IF THE RECORD LENGTH IS VARIABLE.
         JMP   1,FECKLESS      BRANCH IF IT IS.
         L     R1,HRFC   LOAD THE ADDRESS OF THE FIXEDHDR.
         LTR   R1,R1     SEE IF THERE IS A RECORD SPACE CHAIN.
         JMP   10,FECKLESS     BRANCH IF THERE ISN'T.
         USING FIXEDHDR,R1
         L     R15,HEADFREE    GET THE HEAD OF THE BLOCK CHAIN.
         LR    R0,R15    SAVE THE PREDECESSOR OF EACH ONE.
         LTR   R15,R15   SEE IF THIS IS THE EMPTY CHAIN.
         JMP   2,KEEPITUP      BRANCH IF IT ISN'T THE EMPTY CHAIN.
         CL    R15,HRFC  CHECK THE TAIL.
         JMP   8,FECKLESS      BRANCH IF IT IS OK.
         DC    XL2'0D00' INVALID CHAIN, CAUSE THE PROGRAM INTERRUPT.
KEEPITUP EQU   *         KEEP IT UP.
         L     R2,BLOKHEAD     LOAD THE ADDRESS OF THE HEAD OF THE
*                              BLOCK CHAIN FROM THE FIXEDHDR.
         USING BLOCKHDR,R2
KEEPDOWN LM    R2,R4,O(R2)     LOAD THE WHOLE BLOCKHDR.
         LA    R3,O(R3,R4)     GET THE ADDRESS OF THE LAST
         BCTR  R4,O            BYTE IN THE BLOCK.
         SLR   R3,R15    NOW TEST TO SEE IF THE ADDRESS IN REGISTER 15
         SLR   R4,R15    IS GREATER THAN OR EQUAL TO THE ADDRESS IN R3
         XR    R3,R4     AND IS LESS THAN THE ADDRESS OF THE SPACE
         LTR   R3,R3     JUST PAST THE BLOCK DEFINED.
         JMP   4,DOWNHERE      BRANCH IF IT IS WITHIN LIMITS.
         LTR   R2,R2     IT ISN'T IN THAT BLOCK, TRY THE NEXT BLOCK.
         JMP   7,KEEPDOWN      (IF THERE IS A NEXT BLOCK)
         DC    XL2'0D00' HERE IS THE PROGRAM INTERRUPT FOR INVALID
*                        RECORD FREE SPACE CHAIN.
DOWNHERE LR    R0,R15    IT WAS IN THE BLOCK, NOW LET'S GET THE NEXT
         L     R15,O(O,R15)    FREE SPACE CHAIN ADDRESS AND CHECK IT.
         LTR   R15,R15   SEE IF IT IS THE END OF THE CHAIN.
         JMP   2,KEEPITUP      THERE IS A NEXT ONE, CHECK IT.
         CL    R15,HRFC        THERE IS NO NEXT ONE, CHECK TO SEE IF
         JMP   8,FECKLESS      THE TAIL IS CORRECT.
         DC    XL2'0D00'       IT ISN'T, HERE IS ITS PROGRAM INTERRUPT.
         DROP  R2
         DROP  R2
.FICKLE  ANOP
FECKLESS EQU   *         COME HERE ALL YOU FEARLESS READERS.
         LEAF  MODE=FREEMAIN
         DROP  R11
         DROP  R5
DSPRPT2  DC    CL1' '
VERTEX   DC    CL6' '
         DC    CL2' '
DBYTE    DC    CL2' '
         DC    CL2' '
DBIT     DC    CL3' '
         DC    CL2' '
DC0      DC    CL1' '    THE E-BIT.
         DC    CL2' '
DC1      DC    CL1' '    THE Q-BIT.
         DC    CL2' '
DRL      DC    CL1' '    THE RL BIT.
         DC    CL2' '
DT0      DC    CL1' '
         DC    CL2' '
DT1      DC    CL1' '
         DC    CL3' '
DANTE    DC    CL6' '
         DC    CL5' '
DLEFT    DC    CL6' '
         DC    CL4' '
DRIGHT   DC    CL6' '
         DC    CL2'  '
CONTENTS DC    CL8'XXXXXXXX'  THE ACTUAL CONTENTS OF WORD Y.
         DC    CL8'XXXXXXXX'  LEAVE ROOM FOR THE CONTENTS DISPLAY.
         DC    CL1' '
LATTICEV DC    CL8' '  THE SEMILATTICE VALUE.
         DC    CL1' '
LSINK    DC    CL16' ' THE CONTENTS OF THE LEFT SINK.
         DC    CL1' '
RSINK    DC    CL16' ' THE CONTENTS OF THE RIGHT SINK.
         DC    CL70' '
         CNOP  0,4
DTMP     DC    XL4'0'
HDRCON   DC    CL1' '
HADDR    DC    CL9' '
HAPT     DC    CL9' '
HP       DC    CL9' '
HC       DC    CL9' '
HFARG    DC    CL9' '
HSARG    DC    CL9' '
HINSARG  DC    CL9' '
HHVFC    DC    CL9' '
HHRFC    DC    CL9' '
HRECL    DC    CL9' '
HKEYL    DC    CL5' '
HOFF     DC    CL5' '
HMAX     DC    CL9' '
HVALUE   DC    CL9' '
         DC    CL1' '
HTSP     DC    CL9' '
HRSP     DC    CL9' '
         DC    CL10' '
HDRDSP1  DC    CL1'0'
HPATH    DC    CL4' '
         DC    CL80' '
HFIXD0   DC    CL1'0'
         DC    CL26'FIXEDHDR FOR INNER SPACE. '
         DC    CL9'HEADFREE='
HHDFREE  DC    CL8' '
         DC    CL11', FXREFILL='
HFXR     DC    CL8' '
         DC    CL11', FIXDRECL='
HFXDRCL  DC    CL8' '
         DC    CL11', BLOKHEAD='
HBLKHD   DC    CL8' '
         DC    CL40' '
HBLOK00  DC    CL20'0BLOCK CHAIN TRACE.'
         DC    CL101' '
HBLOKHED DC    CL7'0BEDGE='
HBEDGE   DC    CL8' '
         DC    CL7', BSPL='
HBSPL    DC    CL8' '
         DC    CL7', BADR='
HBADR    DC    CL8' '
         DC    CL80' '
CNT      DC    F'0'
NUM      DC    F'256'    NUMBER OF BRANCHES TO STACK.
CONTRSPY DC    XL4'00000000'  NUMBER OF BRANCHES BEFORE ACTIVIATING
*                             THE RPT DISPLAY ROUTINES.
         CNOP  0,4
HEAD     DC    XL4'00'
         CNOP  0,4
OUTDCB   DCB   DSORG=PS,MACRF=(PM),BLKSIZE=121,LRECL=121,              X
               RECFM=FB,EODAD=ERROR,DDNAME=SNAPOUT
SNAPOUT  EQU   OUTDCB
         LTORG *
OUT0     DC    CL1'0'
OUT      DC    CL121' '
SAVE1    DC    18F'0'
SAVE2    DC    18F'0'
ERROR    EQU   *
DSPRPT0  DC    CL1'0'
         DC    CL7'VERTEX '
         DC    CL9'  INDEX  '
         DC    CL15' NE Q RL T0 T1 '
         DC    CL12'PREDECESSOR '
         DC    CL9'  LEFT   '
         DC    CL9'  RIGHT  '
         DC    CL6' '
        DC CL10' CONTENTS '
         DC    CL10'  LATTICE'
         DC    CL60' '
DSPRPT1  DC    CL1' '
         DC    CL7' '
         DC    CL9'BYTE BIT '
         DC    CL15' '
         DC    CL12' '
         DC    CL9'SUCCESSOR'
         DC    CL10' SUCCESSOR'
         DC    CL16' '
         DC  CL10'   VALUE  '
         DC    CL59' '
HDRDSP   DC    CL1'0'    DOUBLE SPACE.
         DC    CL9' ADDRESS '
         DC    CL9' SOURCE '
         DC    CL9'   AP    '
         DC    CL9'   AC    '
         DC    CL9'  FARG   '
         DC    CL9'  SARG   '
         DC    CL9' INSARG  '
         DC    CL9'  HVFC   '
         DC    CL9'  HRFC   '
         DC    CL9'  RECL   '
         DC    CL5'KEYL '
         DC    CL5'KEYI '
         DC    CL9'IGAMAX  '
         DC    CL9'IGAVALUE '
         DC    CL5' '  SLOP.
         DC    CL9'RECSPACE '
         DC    CL9'  HVFC   '
         DC    CL10' '
HEX      DC    CL32'00000001001000110100010101100111'
         DC    CL32'10001001101010111100110111101111'
DSPTAB   DC    CL32'000 001 010 011 100 101 110 111'
.SKPSNAP ANOP
         AGO   .NOT24
.NOT24   ANOP
         END
