         TITLE 'IKJEE150 - OPERATOR ATTENTION EXIT ROUTINE             *
                        '
IKJEE150 CSECT ,                                                   0001
@MAINENT DS    0H                                                  0001
         USING *,@15                                               0001
         B     @PROLOG                                             0001
         DC    AL1(16)                                             0001
         DC    C'IKJEE150  73.286'                                 0001
         DROP  @15
@PROLOG  STM   @14,@12,12(@13)                                     0001
         BALR  @12,0                                               0001
@PSTART  DS    0H                                                  0001
         USING @PSTART,@12                                         0001
REGLIST  DS    0H                                                  0004
*    LINKAGE CONVENTIONS TO SAVE AREA PROVIDED BY IKJEE100
     L     R2,EIGHT(NULL,R1)        ADDR OF EXIT PARMS
     L     R3,FORTY(NULL,R2)        ADDR OF ATTN EXIT SAVE AREA
     ST    R13,FOUR(NULL,R3)        SAVE CALLERS SAVE AREA ADDR IN
*                                     2ND WORD OF OWN SAVE AREA
     ST    R3,EIGHT(NULL,R13)       SAVE OWN SAVE AREA ADDR IN
*                                     3RD WORD OF CALLERS SAVE
     LR    R13,R3                   ADDR OF OWN SAVE AREA
NULL  EQU  0                        0 DISPLACEMENT
FOUR  EQU  4                        LENGTH OR DISPLACEMENT OF FOUR
EIGHT EQU  8                        LENGTH OR DISPLACEMENT OF EIGHT
FORTY EQU  40                       LENGTH OR DISPLACEMENT OR FORTY
*   R3=R1;                          /* ADDRESS OF ATTN EXIT PARAMETER
*                                      LIST                          */
         LR    R3,R1                                               0037
*   RESPECIFY                                                      0038
*    (R1) UNRSTD;                   /* FREE FOR COMPILER USAGE       */
*   R2=PARMPTR;                     /* ADDRESS OF PARAMETERS FROM  0039
*                                      IKJEE100                      */
         L     R2,PARMPTR(,R3)                                     0039
*   R4=WORKPTR;                     /* ADDR OF ATTN EXIT RTN W/A     */
         L     R4,WORKPTR(,R2)                                     0040
*   CONCAT='0'B;                    /* INITIALIZE FLAG               */
         NI    CONCAT(R2),B'01111111'                              0041
*   IOPLUPT=CPPLUPT;                /* PTR TO UPT                    */
         L     @07,CPPLPTR(,R2)                                    0042
         MVC   IOPLUPT(4,R4),CPPLUPT(@07)                          0042
*   IOPLECT=CPPLECT;                /* PTR TO ECT                    */
         MVC   IOPLECT(4,R4),CPPLECT(@07)                          0043
*   IOPLECB=CPECBPTR;               /* PTR TO EGB POSTED BY ATTN EXIT
*                                      WHEN COMMAND IS ENTERED       */
         MVC   IOPLECB(4,R4),CPECBPTR(R2)                          0044
*   AXLEN=TAIEMSGL+4;               /* SET BUFFER LENGTH             */
         LA    @07,4                                               0045
         L     @15,IBUFPTR(,R3)                                    0045
         SLR   @15,@07                                             0045
         L     @14,TAIEPTR(,R3)                                    0045
         LH    @11,TAIEMSGL(,@14)                                  0045
         ALR   @07,@11                                             0045
         STH   @07,AXLEN(,@15)                                     0045
*   AXOFF=0;                        /* SET BUFFER OFFSET             */
         SLR   @07,@07                                             0046
         STH   @07,AXOFF(,@15)                                     0046
*   R6=TAIETGET;                    /* MOVE RETURN CODE FOR POSSIBLE
*                                      ERROR                         */
         SLR   R6,R6                                               0047
         IC    R6,TAIETGET(,@14)                                   0047
*   R5=1;                           /* SET CODE FOR SERVICE ROUTINE
*                                      NAME                          */
         LA    R5,1                                                0048
*   IF R6^=0                        /* CHECK RETURN CODE FROM TGET 0049
*                                      ISSUED BY STAX                */
*     THEN                          /* UNSUCCESSFUL, ISSUE AN ERROR  */
         CR    R6,@07                                              0049
         BNE   @RT00049                                            0049
*     GO TO ERRMSG;                 /* MSG AND RETURN TO INTERRUPTED
*                                      PROCESSING                    */
*   IF TAIEMSGL=0                   /* WHEN INPUT LINE HAS LENGTH  0051
*                                      ZERO                          */
*     THEN                          /* RETURN TO INTERRUPTED         */
         CR    @11,@07                                             0051
         BE    @RT00051                                            0051
*     GO TO EXIT;                   /* PROCESSING                    */
*   IF AXTEXT(TAIEMSGL)='-'         /* IS LAST CHAR OF INPUT LINE A
*                                      CONTINUATION CHARACTER        */
*     THEN                          /* YES,                          */
         ALR   @15,@11                                             0053
         CLI   AXTEXT-1(@15),C'-'                                  0053
         BNE   @RF00053                                            0053
*     DO;                           /* USE GETLINE TO GET            */
*       CONCAT='1'B;                /* REMAINDER OF LOGICAL LINE     */
         OI    CONCAT(R2),B'10000000'                              0055
*       CALL GETLRTN;               /* AND CONCATENATE IT TO         */
         BAL   @14,GETLRTN                                         0056
*     END;                          /* INPUT LINE                    */
*   ELSE                            /* FOR NO CONTINUATION GETMAIN   */
*     DO;                           /* A BUFFER TO MOVE THE CMD INTO */
         B     @RC00053                                            0058
@RF00053 DS    0H                                                  0059
*       RESPECIFY                                                  0059
*        (R0,                                                      0059
*         R1) RSTD;                 /* RESTRICT REGS ACROSS GETMAIN  */
*       R0=AXLEN+8;                 /* GET LENGTH OF BUFFR NEEDED    */
         L     @07,IBUFPTR(,R3)                                    0060
         LA    R0,8                                                0060
         AL    @07,@CF00282                                        0060
         AH    R0,AXLEN(,@07)                                      0060
*       R6=R0;                      /* SAVE THE LENGTH               */
         LR    R6,R0                                               0061
*       R0=R0×'01000000'X;          /* SET SUBPOOL NUMBER            */
         O     R0,@CF00246                                         0062
*       GEN(GETMAIN R,LV=(0));      /* GET THE BUFFER FOR THE CMD    */
         GETMAIN R,LV=(0)
*       ATTNBUFF=R1;                /* SAVE THE ADDRESS              */
         ST    R1,ATTNBUFF(,R2)                                    0064
*       RESPECIFY                                                  0065
*        (R0,                                                      0065
*         R1) UNRSTD;               /* FREE FOR COMPILER             */
*       CALL BLANK;                 /* BLANK OUT THE BUFFER          */
         BAL   @14,BLANK                                           0066
*       GETTEXT(1:TAIEMSGL)=AXTEXT(1:TAIEMSGL);/* MOVE THE CMD TEXT
*                                      IN                            */
         L     @07,ATTNBUFF(,R2)                                   0067
         L     @01,TAIEPTR(,R3)                                    0067
         LH    @15,TAIEMSGL(,@01)                                  0067
         BCTR  @15,0                                               0067
         L     @01,IBUFPTR(,R3)                                    0067
         EX    @15,@SM00283                                        0067
*       GETLEN=R6;                  /* SET THE BUFFR LENGTH          */
         STH   R6,GETLEN(,@07)                                     0068
*       GETOFF=0;                   /* INITIALIZE THE OFFSET         */
         SLR   @15,@15                                             0069
         STH   @15,GETOFF(,@07)                                    0069
*     END;                                                         0070
*                                                                  0070
*/*                                                                0071
*    USE COMMAND SCAN TO DETERMINE IF INPUT LINE IS NULL,          0071
*    A QUESTION MARK OR A COMMAND                                  0071
*                                                                    */
*                                                                  0071
*SCAN:                                                             0071
*   CSPLFLG=ADDR(FLAGWORD);         /* INDICATE NO SYNTAX CHECK      */
@RC00053 DS    0H                                                  0071
SCAN     LA    @07,FLAGWORD                                        0071
         ST    @07,CSPLFLG(,R4)                                    0071
*   CSPLCBUF=ATTNBUFF;              /* ADDR OF COMMAND BUFFER        */
         MVC   CSPLCBUF(4,R4),ATTNBUFF(R2)                         0072
*   CSPLOA=ADDR(CSOA);              /* ADDRESS OF OUTPUT AREA        */
         LA    @07,CMDSCAN(,R4)                                    0073
         ST    @07,CSPLOA(,R4)                                     0073
*   RESPECIFY                                                      0074
*    (R1,                                                          0074
*     R15) RSTD;                    /* RESTRICT REGS ACROSS SCAN     */
*   R1=ADDR(CSPL);                  /* ADDRESS OF PARAMETER LIST     */
         LR    R1,R4                                               0075
*   GEN(LINK EP=IKJSCAN);           /* SCAN THE COMMAND              */
         LINK EP=IKJSCAN
*   R6=R15;                         /* MOVE RETURN CODE              */
         LR    R6,R15                                              0077
*   RESPECIFY                                                      0078
*    (R1,                                                          0078
*     R15) UNRSTD;                  /* FREE FOR COMPILER USAGE       */
*   R5=5;                           /* SERVICE ROUTINE NAME CODE SET */
         LA    R5,5                                                0079
*   IF R6^=0                        /* CHECK FOR SUCCESSFUL        0080
*                                      COMPLETION                    */
*     THEN                          /* UNSUCCESSFUL, ISSUE ERROR MSG */
         LTR   R6,R6                                               0080
         BNZ   @RT00080                                            0080
*     GO TO ERRMSG;                 /* AND RETURN                    */
*   IF CSOANOC='1'B                 /* IS INPUT A NULL LINE?         */
*     THEN                          /* YES, RETURN TO INTERRUPTED    */
         LA    @07,CMDSCAN(,R4)                                    0082
         TM    CSOANOC(@07),B'00010000'                            0082
         BO    @RT00082                                            0082
*     GO TO EXIT;                   /* PROCESSING                    */
*   IF CSOAQM='1'B                  /* IS INPUT A QUESTON MARK       */
*     THEN                          /* YES, PUT OUT 2ND LEVEL MSG, A */
         TM    CSOAQM(@07),B'00100000'                             0084
         BO    @RT00084                                            0084
*     GO TO QMARK;                  /* MODE MSG AND GET A NEW LINE   */
*/*                                                                0086
*    NOTE: IF INPUT LINE IS NOT A QUESTION MARK OR NULL LINE, IT   0086
*          IS ASSUMED TO BE A COMMAND                              0086
*                                                                    */
*                                                                  0086
*                                                                  0086
*/********************************************************************/
*/*      WHEN THE INPUT LINE IS A COMMAND, THE SECOND LEVEL MESSAGE  */
*/* CHAIN IS DELETED, THE INPUT STACK IS RESET, AND THE CP ECB       */
*/* IS POSTED TO NOTIFY OPERATOR THAT PROCESSING ON THE CURRENT      */
*/* COMMAND IS TO BE TERMINATED AND THIS NEW COMMAND SHOULD BE       */
*/* PROCESSED.                                                       */
*/********************************************************************/
*                                                                  0086
*   ECTMSGF='1'B;                   /* SET SWITCH IN ECT WHICH WILL
*                                      NOTIFY AN I/O SERVICE ROUTINE
*                                      TO DELETE THE 2ND LEVEL MSG 0086
*                                      CHAIN                         */
         L     @07,CPPLPTR(,R2)                                    0086
         L     @07,CPPLECT(,@07)                                   0086
         MVI   ECTMSGF(@07),B'10000000'                            0086
*/*                                                                0087
*    USE STACK SERVICE ROUTINE TO RESET THE INPUT STACK TO         0087
*    THE TERMINAL                                                  0087
*                                                                    */
*                                                                  0087
*   IOPLIOPB=ADDR(STPB);            /* ADDRESS OF STACK PARAMETER  0087
*                                      BLOCK                         */
         LA    @07,IOBLOCK(,R4)                                    0087
         ST    @07,IOPLIOPB(,R4)                                   0087
*   STPB=STKL;                      /* MOVE STACK PARAMETER BLOCK TO
*                                      DYNAMIC STORAGE               */
         MVC   STPB(16,@07),STKL                                   0088
*   RESPECIFY                                                      0089
*    (R1,                                                          0089
*     R15) RSTD;                    /* RESTRICT ACROSS STACK         */
*   R1=ADDR(IOPL);                  /* ADDRESS OF PARM LIST          */
         LR    R1,R4                                               0090
*   R15=STKENTRY;                   /* ADDRESS OF STACK              */
         L     R15,STKENTRY(,R2)                                   0091
*   GEN(STACK ENTRY=(15),MF=(E,(1)));                              0092
         STACK ENTRY=(15),MF=(E,(1))
*   R6=R15;                         /* MOVE RETURN CODE              */
         LR    R6,R15                                              0093
*   RESPECIFY                                                      0094
*    (R1,                                                          0094
*     R15) UNRSTD;                  /* FREE REGS FOR COMPILER        */
*   R5=2;                           /* SERVICE ROUTINE NAME CODE SET */
         LA    R5,2                                                0095
*   IF R6^=0                        /* CHECK FOR SUCCESSFUL        0096
*                                      COMPLETION                    */
*     THEN                          /* UNSUCCESSFUL, ISSUE AN ERROR  */
         LTR   R6,R6                                               0096
         BNZ   @RT00096                                            0096
*     GO TO ERRMSG;                 /* MSG AND RETURN TO INTERRUPTED
*                                      PROCESSING                    */
*/*                                                                0098
*    ADJUST POINTERS TO COMMAND BUFFER AND COMMAND SCAN OUTPUT     0098
*    AREA FOR NEW COMMAND AND RETURN TO POINT OF INTERRUPTION      0098
*                                                                    */
*                                                                  0098
*   SCANPTR=ADDR(CSOA);             /* PTR TO CMD SCAN OUTPUT        */
         LA    @07,CMDSCAN(,R4)                                    0098
         ST    @07,SCANPTR(,R2)                                    0098
*   WORK7PTR=ATTNBUFF;              /* PTR TO COMMAND BUFFER         */
         MVC   WORK7PTR(4,R2),ATTNBUFF(R2)                         0099
*/*                                                                0100
*    POST THE CP ECB TO NOTIFY OPERATOR CP OR SERVICE ROUTINE      0100
*    THAT AN ATTENTION INTERRUPT OCCURED AND A LINE OF INPUT IS    0100
*    READY TO BE PROCESSED                                         0100
*                                                                    */
*                                                                  0100
*   R5=CPECBPTR;                    /* ADDR OF CPECB TO BE POSTED    */
         L     R5,CPECBPTR(,R2)                                    0100
*   GEN(POST (5));                                                 0101
         POST (5)
*   IF HELPBIT='1'B                 /* CHECK IF HELP CP WAS ATTACHED */
*     THEN                          /* YES, TEST IF HELP ECB WAS     */
         TM    HELPBIT(R2),B'00100000'                             0102
         BNO   @RF00102                                            0102
*     IF ATCHECB(2)='0'B            /* POSTED ALREADY                */
*       THEN                        /* NO, POST HELP ECB SO THAT     */
         L     @07,ATTACHCB(,R2)                                   0103
         TM    ATCHECB(@07),B'01000000'                            0103
         BNZ   @RF00103                                            0103
*       DO;                         /* OPERATOR CP WILL DETACH HELP  */
*         GEN(STATUS STOP);         /* STOP HELP CP SUBTASK          */
         STATUS STOP
*         R5=ATTACHCB;                                             0106
         L     R5,ATTACHCB(,R2)                                    0106
*         GEN(POST (5));            /* POST ATTACH HELP ECB          */
         POST (5)
*       END;                                                       0108
*EXIT:                              /* RETURN TO POINT OF          0109
*                                      INTERRUPTION                  */
*   GEN;                                                           0109
@RF00103 DS    0H                                                  0109
@RF00102 DS    0H                                                  0109
EXIT     DS    0H                                                  0109
     L     R13,FOUR(NULL,R13)       RESTORE SAVE AREA PTR
     LM    R14,R12,TWELVE(R13)      RESTORE REGISTERS
     BCR   FIFTEEN,R14              RETURN
TWELVE  EQU 12                      DISPLACEMENT OF TWELVE
FIFTEEN EQU  15                     MASK OF FIFTEEN
*                                                                  0110
*/********************************************************************/
*/*      WHEN THE INPUT LINE IS A QUESTION MARK, THE SECOND LEVEL    */
*/* MESSAGE CHAIN IS PUT OUT FOLLOWED BY A MODE MESSAGE USING        */
*/* THE PUTLINE SERVICE ROUTINE.  A NEW COMMAND IS OBTAINED USING    */
*/* THE GETLINE SERVICE ROUTINE AND PROCESSED AS THE ORIGINAL INPUT  */
*/* LINE.                                                            */
*/********************************************************************/
*                                                                  0110
*QMARK:                             /* ISSUE 2ND LEVEL MESSAGE CHAIN */
*   IOPLIOPB=ADDR(PTPB);            /* PUTLINE PARAMETER BLOCK ADDR  */
QMARK    LA    @07,IOBLOCK(,R4)                                    0110
         ST    @07,IOPLIOPB(,R4)                                   0110
*   PTPB=PUTL;                      /* CLEAR PARAMETER BLOCK         */
         MVC   PTPB(12,@07),PUTL                                   0111
*   RESPECIFY                                                      0112
*    (R1,                                                          0112
*     R15) RSTD;                    /* RESTRICT ACAROSS PUTLINE      */
*   R1=ADDR(IOPL);                  /* PARAMETER LIST ADDRESS        */
         LR    R1,R4                                               0113
*   R15=PUTENTRY;                   /* PUTLINE ENTRY POINT           */
         L     R15,PUTENTRY(,R2)                                   0114
*   GEN(PUTLINE OUTPUT=(0),ENTRY=(15),MF=(E,(1)));                 0115
         PUTLINE OUTPUT=(0),ENTRY=(15),MF=(E,(1))
*   R6=R15;                         /* MOVE RETURN CODE              */
         LR    R6,R15                                              0116
*   RESPECIFY                                                      0117
*    (R1,                                                          0117
*     R15) UNRSTD;                  /* FREE FOR COMPILER             */
*   R5=3;                           /* SERVICE ROUTINE NAME CODE SET */
         LA    R5,3                                                0118
*   IF R6^=0                        /* CHECK FOR SUCCESSFUL        0119
*                                      COMPLETION                    */
*     THEN                          /* UNSUCCESSFUL, ISSUE ERROR MSG */
         LTR   R6,R6                                               0119
         BNZ   @RT00119                                            0119
*     GO TO ERRMSG;                 /* AND RETURN TO INTERRUPTED   0120
*                                      PROCESSING                    */
*/*                                                                0121
*    ISSUE MODE MESSAGE                                            0121
*                                                                    */
*                                                                  0121
*   MSGSEG(1:5)=MSG0021;            /* MOVE MSG HEADER FOR           */
         MVC   MSGSEG(5,R4),MSG0021                                0121
*   MSGTEXT(2:9)=ECTPCMD;           /* MODE MSG USING COMMAND NAME 0122
*                                      FROM ECT                      */
         L     @07,CPPLPTR(,R2)                                    0122
         L     @07,CPPLECT(,@07)                                   0122
         MVC   MSGTEXT+1(8,R4),ECTPCMD(@07)                        0122
*   PTPB(1:12)=PUTL;                /* CLEAR PARAMETER BLOCK         */
         LA    @07,IOBLOCK(,R4)                                    0123
         MVC   PTPB(12,@07),PUTL                                   0123
*   NOSEGS=1;                       /* OPERATOR SEGMENT MESSAGE      */
         MVC   NOSEGS(4,R4),@CF00082                               0124
*   MSGPTR=ADDR(MSGSEG);            /* ADDR OF MESSAGE               */
         LA    @07,MSGSEG(,R4)                                     0125
         ST    @07,MSGPTR(,R4)                                     0125
*   R5=ADDR(OLDBLK);                /* ADDRESS OF OUTPUT             */
         LA    R5,OLDBLK(,R4)                                      0126
*   RESPECIFY                                                      0127
*    (R1,                                                          0127
*     R15) RSTD;                    /* RESTRICT ACROSS PUTLINE       */
*   R1=ADDR(IOPL);                  /* ADDRESS OF PARAMETER LIST     */
         LR    R1,R4                                               0128
*   R15=PUTENTRY;                   /* ADDRESS OF PUTLINE            */
         L     R15,PUTENTRY(,R2)                                   0129
*   GEN(PUTLINE OUTPUT=((5)),ENTRY=(15),MF=(E,(1)));               0130
         PUTLINE OUTPUT=((5)),ENTRY=(15),MF=(E,(1))
*   R6=R15;                         /* MOVE RETURN CODE              */
         LR    R6,R15                                              0131
*   RESPECIFY                                                      0132
*    (R1,                                                          0132
*     R15) UNRSTD;                  /* FREE FOR COMPILER USAGE       */
*   R5=3;                           /* SERVICE ROUTINE NAME CODE SET */
         LA    R5,3                                                0133
*   IF R6^=0                        /* CHECK FOR SUCCESSFUL        0134
*                                      COMPLETION                    */
*     THEN                          /* UNSUCCESSFUL, ISSUE ERROR MSG */
         LTR   R6,R6                                               0134
         BNZ   @RT00134                                            0134
*     GO TO ERRMSG;                 /* AND RETURN TO INTERRUPTED   0135
*                                      PROCESSING                    */
*/*                                                                0136
*    GET A NEW COMMAND AND PROCESS IT AS ORIGINAL INPUT LINE       0136
*                                                                    */
*                                                                  0136
*   CALL GETLRTN;                   /* GET A NEW LINE OF INPUT       */
         BAL   @14,GETLRTN                                         0136
*   GO TO SCAN;                     /* GO AND CHECK THE NEW LINE   0137
*                                                                    */
         B     SCAN                                                0137
*                                                                  0138
*/********************************************************************/
*/*      ATTENTION CANNOT BE PROCESSED.  AN ATTEMPT IS MADE TO ISSUE */
*/* AN ERROR MSG.  CONTROL RETURNS TO THE POINT OF INTERRUPTION.     */
*/********************************************************************/
*                                                                  0138
*ERRMSG:                                                           0138
*                                                                  0138
*/*                                                                0138
*    INITIALIZE FIRST OUTPUT LINE DESCRIPTOR BLOCK                 0138
*                                                                    */
*                                                                  0138
*   NEXT1=ADDR(BLOCK2);             /* ADDR OF 2ND BLOCK             */
ERRMSG   LA    @07,CMDSCAN(,R4)                                    0138
         LA    @15,MSGSEG(,R4)                                     0138
         ST    @15,NEXT1(,@07)                                     0138
*   NOSEGS1=1;                      /* 1 SEGMENT MSG                 */
         MVC   NOSEGS1(4,@07),@CF00082                             0139
*   SEG11=ADDR(ERRORMSG);           /* ADDR OF MSG                   */
         LA    @14,ERRORMSG                                        0140
         ST    @14,SEG11(,@07)                                     0140
*/*                                                                0141
*    INITIALIZE 2ND OUTPUT LINE DESCRIPTOR BLOCK                   0141
*                                                                    */
*                                                                  0141
*   NEXT2=0;                        /* LAST BLOCK                    */
         SLR   @07,@07                                             0141
         ST    @07,NEXT2(,@15)                                     0141
*   NOSEGS2=3;                      /* 3 SEGMENT MSG                 */
         MVC   NOSEGS2(4,@15),@CF00232                             0142
*   SEG21=ADDR(IDSEG);              /* ADDR OF SEG FOR ID            */
         LA    @07,IDSEG                                           0143
         ST    @07,SEG21(,@15)                                     0143
*   SEG22=ADDR(NAMESEG(R5));        /* ADDR OF SEG FOR SERVICE     0144
*                                      ROUTINE NAME                  */
         LR    @07,R5                                              0144
         SLA   @07,4                                               0144
         LA    @07,NAMESEG-16(@07)                                 0144
         ST    @07,SEG22(,@15)                                     0144
*   SEG23=ADDR(CDSEG);              /* ADDR OF SEG FOR RETURN CODE -
*                                      TO BE BUILT                   */
         LA    @07,OLDBLK(,R4)                                     0145
         ST    @07,SEG23(,@15)                                     0145
*/*                                                                0146
*    CONVERT HEX RETURN CODE TO PRINTABLE DECIMAL CHARACTERS AND   0146
*    BUILD SEGMENT FOR IT                                          0146
*                                                                    */
*                                                                  0146
*   RESPECIFY                                                      0146
*    (R1) RSTD;                     /* RESTRICT R1 USAGE             */
*   R1=ADDR(PTPB);                  /* USE AS WORKAREA               */
         LA    R1,IOBLOCK(,R4)                                     0147
*   R5=ADDR(CDSEG);                 /* ADDR OF SEG FOR RETURN CODE   */
         LR    R5,@07                                              0148
*   GEN;                                                           0149
     CVD   R6,NULL(R1)              CONVERT HEX TO PACKED DEC
     UNPK  FOUR(A3,R5),A6(A2,R1)    UNPACK TO ZONED DECIMAL
     OI    A6(R5),A0                CHANGE SIGN BITS TO PRINTABLE
*                                    CHARACTERS
A0   EQU 240                        HEX 0
A3   EQU 3                          3
A2   EQU 2                          2
A6   EQU 6                          SIX
*   RESPECIFY                                                      0150
*    (R1) UNRSTD;                   /* FREE FOR COMPILER             */
*   CDLEN=7;                        /* LENGTH                        */
         LA    @07,OLDBLK(,R4)                                     0151
         MVC   CDLEN(2,@07),@CH00264                               0151
*   CDOFF=25;                       /* SET OFFSET                    */
         MVC   CDOFF(2,@07),@CH00224                               0152
*   R5=ADDR(BLOCK1);                /* CHAINED OUTPUT DESCRIPTORS  0153
*                                      ADDR                          */
         LA    R5,CMDSCAN(,R4)                                     0153
*   PTPB(1:12)=PUTL;                /* MOVE PUTLINE PARM BLOCK TO  0154
*                                      DYNAMIC STORAGE               */
         LA    @07,IOBLOCK(,R4)                                    0154
         MVC   PTPB(12,@07),PUTL                                   0154
*   IOPLIOPB=ADDR(PTPB);            /* ADDRESS OF PUTLINE PARM BLOCK */
         ST    @07,IOPLIOPB(,R4)                                   0155
*   RESPECIFY                                                      0156
*    (R1,                                                          0156
*     R15) RSTD;                    /* RESTRICT ACROSS PUTLINE       */
*   R1=ADDR(IOPL);                  /* ADDRESS OF PARAMETER LIST     */
         LR    R1,R4                                               0157
*   R15=PUTENTRY;                   /* ADDRESS OF PUTLINE            */
         L     R15,PUTENTRY(,R2)                                   0158
*   GEN(PUTLINE OUTPUT=((5),MULTLVL),ENTRY=(15),MF=(E,(1)));       0159
         PUTLINE OUTPUT=((5),MULTLVL),ENTRY=(15),MF=(E,(1))
*   RESPECIFY                                                      0160
*    (R1,                                                          0160
*     R15) UNRSTD;                  /* FREE FOR COMPILER             */
*   GO TO EXIT;                     /* RETURN TO POINT OF          0161
*                                      INTERRUPTION                0161
*                                                                    */
         B     EXIT                                                0161
*                                                                  0162
*/********************************************************************/
*/*      THE GETLINE SUBROUTINE GETS AN INPUT LINE FROM THE          */
*/* TERMINAL USER BY USING THE GETLINE SERVICE ROUTINE.  A NEW LINE  */
*/* IS NECESSARY WHEN THE ORIGINAL LINE ENDS WITH A CONTINUATION     */
*/* CHARACTER.  THIS ROUTINE THEN CONCATENATES THE NEW LINE TO THE   */
*/* ORIGINAL LINE AND FREES THE GETLINE BUFFER.  IF THE ORIGINAL     */
*/* LINE IS A QUESTION MARK A NEW LINE IS OBTAINED AFTER THE         */
*/* QUESTION MARK IS PROCESSED.  THE NEW LINE IS MOVED TO THE        */
*/* COMMAND BUFFER AND THE GETLINE BUFFER IS FREED.                  */
*/********************************************************************/
*                                                                  0162
*GETLRTN:                                                          0162
*   PROC OPTIONS(NOSAVEAREA,DONTSAVE);                             0162
@EL00001 DS    0H                                                  0162
@EF00001 DS    0H                                                  0162
@ER00001 LM    @14,@12,12(@13)                                     0162
         BR    @14                                                 0162
@PB00001 DS    0H                                                  0162
GETLRTN  DS    0H                                                  0163
*   RESPECIFY                                                      0163
*    (R2,                                                          0163
*     R3,                                                          0163
*     R4,                                                          0163
*     R5,                                                          0163
*     R6,                                                          0163
*     R14) RESTRICTED;                                             0163
*   SAVE14=R14;                     /* SAVE RETURN POINT             */
         ST    R14,SAVE14(,R4)                                     0164
*   RESPECIFY                                                      0165
*    (R14) UNRSTD;                  /* FREE FOR COMPILER             */
*   IF ATTNBUFF^=0                  /* CHECK IF A FORMER ATTENTION 0166
*                                      BUFFER SHOULD BE FREED        */
*     THEN                          /* YES,                          */
         L     @07,ATTNBUFF(,R2)                                   0166
         LTR   @07,@07                                             0166
         BZ    @RF00166                                            0166
*     DO;                           /* FREE BUFFER                   */
*       RESPECIFY                                                  0168
*        (R0,                                                      0168
*         R1) RSTD;                 /* RESTRICT ACROSS FREEMAIN      */
*       R1=ATTNBUFF;                /* GET ADDR OF BUFFER TO BE FREED*/
         LR    R1,@07                                              0169
*       R0=GETLEN;                  /* GET LENGTH TO BE FREED        */
         LH    R0,GETLEN(,@07)                                     0170
*       R0=R0×SPNO;                 /* OR LENGTH WITH SUBPOOL NUMBER */
         O     R0,SPNO                                             0171
*       GEN(FREEMAIN R,LV=(0),A=(1));                              0172
         FREEMAIN R,LV=(0),A=(1)
*       RESPECIFY                                                  0173
*        (R0,                                                      0173
*         R1) UNRSTD;               /* FREE REGS FOR COMPILER        */
*       ATTNBUFF=0;                 /* CLEAR INDICATOR FOR GETMAINED */
         SLR   @07,@07                                             0174
         ST    @07,ATTNBUFF(,R2)                                   0174
*     END;                          /* BUFFER                        */
*   IOPLIOPB=ADDR(GTPB);            /* GET ADDRESS OF GETLINE      0176
*                                      PARAMETER BLOCK               */
@RF00166 LA    @07,IOBLOCK(,R4)                                    0176
         ST    @07,IOPLIOPB(,R4)                                   0176
*   GTPB(1:8)=GETL;                 /* CLEAR GETLINE PARAMETER BLOCK */
         MVC   GTPB(8,@07),GETL                                    0177
*   RESPECIFY                                                      0178
*    (R1,                                                          0178
*     R15) RSTD;                    /* RESTRICT FOR GETLINE          */
*   R1=ADDR(IOPL);                  /* GET PARAMETER LIST ADDRESS    */
         LR    R1,R4                                               0179
*   R15=GETENTRY;                   /* GETLINE ENTRY POINT           */
         L     R15,GETENTRY(,R2)                                   0180
*   GEN(GETLINE INPUT=TERM,ENTRY=(15),MF=(E,(1)));                 0181
         GETLINE INPUT=TERM,ENTRY=(15),MF=(E,(1))
*   R6=R15;                         /* MOVE RETURN CODE              */
         LR    R6,R15                                              0182
*   RESPECIFY                                                      0183
*    (R1,                                                          0183
*     R15) UNRSTD;                  /* FREE ACROSS COMPILER          */
*   R5=4;                           /* SERVICE ROUTINE NAME CODE SET */
         LA    R5,4                                                0184
*   IF R6^=0                        /* CHECK FOR SUCCESSFUL        0185
*                                      COMPLETION                    */
*     THEN                          /* UNSUCCESSFUL,ISSUE AN ERROR 0185
*                                      MSG                           */
         LTR   R6,R6                                               0185
         BNZ   @RT00185                                            0185
*     GO TO ERRMSG;                 /* AND RETURN TO INTERRUPTED   0186
*                                      PROCESSING                    */
*   RESPECIFY                                                      0187
*    (R0) RSTD;                     /* RESTRICT REGISTER USAGE       */
*   IF CONCAT='1'B                  /* CHECK IF CONCATENATION      0188
*                                      NECESSRY                      */
*     THEN                          /* CALCULATE COMBINED LENGTH OF  */
         TM    CONCAT(R2),B'10000000'                              0188
         BNO   @RF00188                                            0188
*     R0=GTLEN+TAIEMSGL+8;          /* BUFFER NECESSARY TO BE GET- 0189
*                                      MAINED COMBINING BUFFER LENGTH
*                                      FROM ATTN HANDLER AND       0189
*                                      GETLINE'S BUFFER LENGTH + 8   */
         LA    @07,IOBLOCK(,R4)                                    0189
         L     @07,GTPBIBUF(,@07)                                  0189
         L     @01,TAIEPTR(,R3)                                    0189
         LH    R0,GTLEN(,@07)                                      0189
         AH    R0,TAIEMSGL(,@01)                                   0189
         AH    R0,@CH00060                                         0189
*   ELSE                            /* NO CONTINUATION LINE,       0190
*                                      THEREFORE                     */
*     R0=GTLEN+8;                   /* LENGTH OF GETMAINED BUFFER  0190
*                                      NEED ONLY BE LENGTH OF ATTN 0190
*                                      HANDLER BUFFER + 8            */
         B     @RC00188                                            0190
@RF00188 LA    @07,IOBLOCK(,R4)                                    0190
         L     @07,GTPBIBUF(,@07)                                  0190
         LA    R0,8                                                0190
         AH    R0,GTLEN(,@07)                                      0190
*   R6=R0;                          /* SAVE THE LENGTH               */
@RC00188 LR    R6,R0                                               0191
*   R0=R0×SPNO;                     /* OR R0 WITH SUBPOOL NUMBER     */
         O     R0,SPNO                                             0192
*   RESPECIFY                                                      0193
*    (R1) RSTD;                     /* RESTRICT ACROSS GETMAIN       */
*   GEN(GETMAIN R,LV=(0));          /* GETMAIN BUFFER                */
         GETMAIN R,LV=(0)
*   ATTNBUFF=R1;                    /* SAVE ADDR OF GETMAINED BUFFER */
         ST    R1,ATTNBUFF(,R2)                                    0195
*   RESPECIFY                                                      0196
*    (R0,                                                          0196
*     R1) UNRSTD;                   /* FREE FOR COMPILER USAGE       */
*   CALL BLANK;                     /* BLANK OUT THE BUFFER          */
         BAL   @14,BLANK                                           0197
*   IF CONCAT='1'B                  /* CHECK IF LINE SHOULD BE     0198
*                                      CONCATENATED TO ORIGINAL      */
*     THEN                          /* YES, CONCATENATE TEXT FROM    */
         TM    CONCAT(R2),B'10000000'                              0198
         BNO   @RF00198                                            0198
*     DO;                           /* GETLINE TO ORIGINAL LINE      */
*       CONCAT='0'B;                /* CLEAR FLAG                    */
         NI    CONCAT(R2),B'01111111'                              0200
*       GETTEXT(1:TAIEMSGL)=AXTEXT(1:TAIEMSGL);/* MOVE 1ST LINE OF 0201
*                                      MSG GOTTEN BY ATTN HANDLER TO
*                                      GETMAIN AREA                  */
         L     @07,ATTNBUFF(,R2)                                   0201
         L     @01,TAIEPTR(,R3)                                    0201
         LH    @15,TAIEMSGL(,@01)                                  0201
         LR    @14,@15                                             0201
         BCTR  @14,0                                               0201
         L     @01,IBUFPTR(,R3)                                    0201
         EX    @14,@SM00283                                        0201
*       ENDPT=TAIEMSGL              /* ENDING SPOT = LENGTH OF     0202
*                                      ORIGINAL LINE                 */
*           +GTLEN                  /* + LENGTH OF TEXT FROM GETLINE */
*           -5;                     /* - 1 FOR OVERLAYED CONTINUATION
*                                      CHARACTER                     */
         LA    @14,IOBLOCK(,R4)                                    0202
         L     @14,GTPBIBUF(,@14)                                  0202
         LH    @11,GTLEN(,@14)                                     0202
         ALR   @11,@15                                             0202
         SH    @11,@CH00206                                        0202
         STH   @11,ENDPT(,R4)                                      0202
*       GETTEXT(TAIEMSGL:ENDPT)=GTTEXT(1:GTLEN-4);/* MOVE 2ND LINE OF
*                                      MSG GOTTEN BY GETLINE TO    0203
*                                      GETMAIN AREA                  */
         ALR   @07,@15                                             0203
         SLR   @11,@15                                             0203
         EX    @11,@SM00285                                        0203
*     END;                                                         0204
*   ELSE                            /* NO,                           */
*     GETBUFFR(1:GTLEN)=GTBUF(1:GTLEN);/* MOVE LINE TO CMD BUFFER    */
         B     @RC00198                                            0205
@RF00198 L     @07,ATTNBUFF(,R2)                                   0205
         LA    @15,IOBLOCK(,R4)                                    0205
         L     @15,GTPBIBUF(,@15)                                  0205
         LH    @14,GTLEN(,@15)                                     0205
         BCTR  @14,0                                               0205
         EX    @14,@SM00287                                        0205
*FREE:                              /* FREE BUFFER OBTAINED BY     0206
*                                      GETLINE                       */
*   GETLEN=R6;                      /* UPDATE CORRECT GETMAIN'D    0206
*                                      LENGTH                        */
@RC00198 DS    0H                                                  0206
FREE     L     @07,ATTNBUFF(,R2)                                   0206
         STH   R6,GETLEN(,@07)                                     0206
*   RESPECIFY                                                      0207
*    (R0,                                                          0207
*     R1) RSTD;                     /* RESTRICT USAGE ACROSS GETMAIN */
*   GETOFF=0;                       /* INITIALIZE OFFSET TO ZERO     */
         SLR   @15,@15                                             0208
         STH   @15,GETOFF(,@07)                                    0208
*   R0=GTLEN;                       /* GET LENGTH FROM HEADER        */
         LA    @07,IOBLOCK(,R4)                                    0209
         L     @07,GTPBIBUF(,@07)                                  0209
         LH    R0,GTLEN(,@07)                                      0209
*   R0=R0×SPNO;                     /* SET SUBPOOL NUMBER TO 1       */
         O     R0,SPNO                                             0210
*   R1=GTPBIBUF;                    /* GET ADDRESS OF BUFFER         */
         LR    R1,@07                                              0211
*   RESPECIFY                                                      0212
*    (R0,                                                          0212
*     R1) UNRSTD;                   /* FREE FOR COMPILER             */
*   RESPECIFY                                                      0213
*    (R14) RSTD;                    /* RESTRICT RETURN REG           */
*   R14=SAVE14;                     /* RESTORE RETURN ADDRESS        */
         L     R14,SAVE14(,R4)                                     0214
*   RETURN;                                                        0215
@EL00002 DS    0H                                                  0215
@EF00002 DS    0H                                                  0215
@ER00002 BR    @14                                                 0215
*   RESPECIFY                                                      0216
*    (R14) UNRSTD;                  /* FREE FOR COMPILER             */
*   END GETLRTN;                                                   0217
*                                                                  0218
*/****************************************************************** */
*/*    THE BLANK SUBROUTINE IS USED IN IKJEE150 TO CLEAR OUT A       */
*/* COMMAND BUFFER AREA DYNAMICALLY ACQUIRED VIA A GETMAIN           */
*/* MACRO INSTRUCTION. THE LENGTH IS VARIABLE AND WHEN IT HAS BEEN   */
*/* DETERMINED AND OBTAINED, THIS SUBROUTINE IS CALLED TO BLANK THE  */
*/* AREA OUT.                                                        */
*/********************************************************************/
*                                                                  0218
*BLANK:                                                            0218
*   PROC OPTIONS(NOSAVEAREA,DONTSAVE);                             0218
BLANK    DS    0H                                                  0219
*   RESPECIFY                                                      0219
*    (R2,                                                          0219
*     R3,                                                          0219
*     R4,                                                          0219
*     R5,                                                          0219
*     R6,                                                          0219
*     R7,                                                          0219
*     R8,                                                          0219
*     R9,                                                          0219
*     R10) RSTD;                                                   0219
*                                                                  0219
*/*                                                                0220
*    CLEAR VARIABLE LENGTH BUFFER                                  0220
*                                                                    */
*                                                                  0220
*   R7=R6;                          /* SIZE OF BUFFR TO BE CLEARED   */
         LR    R7,R6                                               0220
*   R8=ATTNBUFF;                    /* ADDR OF BUFFR INTO A REG      */
         L     @11,ATTNBUFF(,R2)                                   0221
         LR    R8,@11                                              0221
*   R10=ATTNBUFF;                   /* PTR FOR USE IN BLANKING OUT   */
         LR    R10,@11                                             0222
*   R9=255;                         /* SET REG FOR MAX LENGTH ON     */
*                                                                  0223
         LA    R9,255                                              0223
*   /*****************************************************************/
*   /*                                                               */
*   /* EXECUTE INSTRUCTION                                           */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0224
*   GEN(MVI 0(R8),C' ');            /* BLANK 1ST CHAR. IN BUFFER     */
         MVI 0(R8),C' '
*   R8=R8+1;                        /* ADJUST POINTER IN BUFFER      */
         AH    R8,@CH00082                                         0225
*   R7=R7-1;                        /* ADJUST SIZE LEFT              */
         BCTR  R7,0                                                0226
*   GO TO TESTLEN;                  /* CHECK FOR MORE THAN 256       */
         B     TESTLEN                                             0227
*REBLANK:                                                          0228
*   GEN(EX R9,BLANKOUT);            /* BLANK OUT BUFFR FOR 256 BYTES */
REBLANK  EX R9,BLANKOUT
*   R7=R7-R9-1;                     /* DECREMENT SIZE LEFT TO BE     */
*                                                                  0229
         LR    @11,R7                                              0229
         SLR   @11,R9                                              0229
         BCTR  @11,0                                               0229
         LR    R7,@11                                              0229
*   /*****************************************************************/
*   /*                                                               */
*   /* BLANKED                                                       */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0230
*   R8=R8+R9+1;                     /* INCREMENT PTR IN BUFFR        */
         LR    @11,R8                                              0230
         ALR   @11,R9                                              0230
         AH    @11,@CH00082                                        0230
         LR    R8,@11                                              0230
*TESTLEN:                                                          0231
*   IF R7>R9+1                      /* IF MORE THAN 256 BYTES LEFT   */
*     THEN                          /* LOOP AND BLANK AGAIN          */
TESTLEN  LA    @11,1                                               0231
         ALR   @11,R9                                              0231
         CR    R7,@11                                              0231
         BH    @RT00231                                            0231
*     GO TO REBLANK;                /* LOOP AGAIN                    */
*   R9=R7-1;                        /* SET REG FOR LENGTH ON THE   0233
*                                      EXECUTE INSTRUCTION           */
         LR    R9,R7                                               0233
         BCTR  R9,0                                                0233
*   GEN(EX R9,BLANKOUT);            /* GO TO CLEAR REST OF BUFFER    */
         EX R9,BLANKOUT
*   RESPECIFY                                                      0235
*    (R7,                                                          0235
*     R8,                                                          0235
*     R9,                                                          0235
*     R10) RSTD;                    /* FREE REGISTERS FOR COMPILER   */
*   RETURN;                         /* RETURN TO CALLER              */
@EL00003 DS    0H                                                  0236
@EF00003 DS    0H                                                  0236
@ER00003 BR    @14                                                 0236
*BLANKOUT:                                                         0237
*   GEN(MVC 0(1,R8),0(R10));        /* BLANK OUT FOR GIVEN LENGTH    */
BLANKOUT MVC 0(1,R8),0(R10)
*   END BLANK;                                                     0238
         B     @EL00003                                            0238
*   END IKJEE150                                                   0239
*                                                                  0239
*/* THE FOLLOWING INCLUDE STATEMENTS WERE FOUND IN THIS PROGRAM.     */
*/*%INCLUDE SYSLIB  (IKJCPPL )                                       */
*/*%INCLUDE SYSLIB  (IKJECT  )                                       */
*/*%INCLUDE SYSLIB  (IKJIOPL )                                       */
*/*%INCLUDE SYSLIB  (IKJPTPB )                                       */
*/*%INCLUDE SYSLIB  (IKJGTPB )                                       */
*/*%INCLUDE SYSLIB  (IKJSTPB )                                       */
*/*%INCLUDE SYSLIB  (IKJCSPL )                                       */
*/*%INCLUDE SYSLIB  (IKJCSOA )                                       */
*/*%INCLUDE SYSLIB  (IKJTAIE )                                       */
*                                                                  0239
*       ;                                                          0239
@DATA    DS    0H
@CH00206 DC    H'5'
@CH00264 DC    H'7'
@CH00060 DC    H'8'
@CH00224 DC    H'25'
@SM00283 MVC   GETTEXT(0,@07),AXTEXT-4(@01)
@SM00285 MVC   GETTEXT-1(0,@07),GTTEXT(@14)
@SM00287 MVC   GETBUFFR(0,@07),GTBUF(@15)
@DATD    DSECT
         DS    0F
@PC00001 DS    1F
@ZTEMPS  DS    C
@ZTEMPND EQU   *
@ZLEN    EQU   @ZTEMPND-@ZTEMPS
IKJEE150 CSECT
         DS    0F
@CF00082 DC    F'1'
@CH00082 EQU   @CF00082+2
@CF00232 DC    F'3'
@CF00282 DC    F'-4'
@CF00246 DC    XL4'01000000'
@DATD    DSECT
         DS    0D
IKJEE150 CSECT
         DS    0F
@SIZDATD DC    AL1(0)
         DC    AL3(@ENDDATD-@DATD)
         DS    0D
ERRORMSG DS    CL42
         ORG   ERRORMSG
ERRLEN   DC    H'42'
ERROFF   DC    H'0'
ERRTEXT  DC    CL38'IKJ55007I UNABLE TO PROCESS ATTENTION+'
         ORG   ERRORMSG+42
MSG0021  DS    CL5
         ORG   MSG0021
MSG21LEN DC    H'13'
MSG21OFF DC    H'0'
MSG21TXT DC    CL1' '
         ORG   MSG0021+5
         DS    CL1
IDSEG    DS    CL29
         ORG   IDSEG
IDLEN    DC    H'29'
IDOFF    DC    H'0'
IDTEXT   DC    CL25'IKJ55007I  ERROR CODE IS '
         ORG   IDSEG+29
         DS    CL3
FLAGWORD DC    X'10000000'
SPNO     DC    X'01000000'
NAMESEG  DS    CL16
         ORG   NAMESEG+0
NLEN     DC    H'8'
NOFF     DC    H'10'
NTEXT    DC    CL12'TGET'
         ORG   NAMESEG+16
         ORG   NAMESEG+16
         DC    H'9'
         DC    H'10'
         DC    CL12'STACK'
         ORG   NAMESEG+32
         ORG   NAMESEG+32
         DC    H'11'
         DC    H'10'
         DC    CL12'PUTLINE'
         ORG   NAMESEG+48
         ORG   NAMESEG+48
         DC    H'11'
         DC    H'10'
         DC    CL12'GETLINE'
         ORG   NAMESEG+64
         ORG   NAMESEG+64
         DC    H'16'
         DC    H'10'
         DC    CL12'COMMAND SCAN'
         ORG   NAMESEG+80
IKJEE150 CSECT
         DS   0H
PATCHLOC DC ((@DATA-@PSTART)/20)X'00'
IKJEE150 CSECT
PUTL PUTLINE ,MF=L
     SPACE
GETL GETLINE ,MF=L
     SPACE
STKL STACK DELETE=ALL,MF=L
@DATD    DSECT
         ORG   *+1-(*-@DATD)/(*-@DATD) INSURE DSECT DATA
@ENDDATD EQU   *
IKJEE150 CSECT
@00      EQU   00                      EQUATES FOR REGISTERS 0-15
@01      EQU   01
@02      EQU   02
@03      EQU   03
@04      EQU   04
@05      EQU   05
@06      EQU   06
@07      EQU   07
@08      EQU   08
@09      EQU   09
@10      EQU   10
@11      EQU   11
@12      EQU   12
@13      EQU   13
@14      EQU   14
@15      EQU   15
R0       EQU   @00
R1       EQU   @01
R2       EQU   @02
R3       EQU   @03
R4       EQU   @04
R5       EQU   @05
R6       EQU   @06
R7       EQU   @07
R8       EQU   @08
R9       EQU   @09
R10      EQU   @10
R14      EQU   @14
R15      EQU   @15
R12      EQU   @12
R13      EQU   @13
WORKAREA EQU   0
SRPARM   EQU   WORKAREA
OLDBLK   EQU   WORKAREA+16
NOSEGS   EQU   OLDBLK
MSGPTR   EQU   OLDBLK+4
IOBLOCK  EQU   WORKAREA+24
CMDSCAN  EQU   WORKAREA+40
SAVE14   EQU   WORKAREA+48
MSGSEG   EQU   WORKAREA+52
MSGTEXT  EQU   MSGSEG+4
ENDPT    EQU   WORKAREA+76
PARMAREA EQU   0
CPPLPTR  EQU   PARMAREA
CPECBPTR EQU   PARMAREA+4
PUTENTRY EQU   PARMAREA+8
GETENTRY EQU   PARMAREA+12
WORKPTR  EQU   PARMAREA+20
WORK7PTR EQU   PARMAREA+24
SCANPTR  EQU   PARMAREA+28
EXITFLAG EQU   PARMAREA+32
CONCAT   EQU   EXITFLAG
HELPBIT  EQU   EXITFLAG
STKENTRY EQU   PARMAREA+36
ATTACHCB EQU   PARMAREA+48
ATTNBUFF EQU   PARMAREA+64
ATCHECB  EQU   0
CPPL     EQU   0
CPPLUPT  EQU   CPPL+4
CPPLECT  EQU   CPPL+12
ECT      EQU   0
ECTMSGF  EQU   ECT+8
ECTPCMD  EQU   ECT+12
ECTSWS   EQU   ECT+28
IOPL     EQU   0
IOPLUPT  EQU   IOPL
IOPLECT  EQU   IOPL+4
IOPLECB  EQU   IOPL+8
IOPLIOPB EQU   IOPL+12
PTPB     EQU   0
GTPB     EQU   0
GTPBIBUF EQU   GTPB+4
STPB     EQU   0
CSPL     EQU   0
CSPLFLG  EQU   CSPL+12
CSPLOA   EQU   CSPL+16
CSPLCBUF EQU   CSPL+20
CSOA     EQU   0
CSOAFLG  EQU   CSOA+6
CSOAQM   EQU   CSOAFLG
CSOANOC  EQU   CSOAFLG
AXPL     EQU   0
TAIEPTR  EQU   AXPL
IBUFPTR  EQU   AXPL+4
PARMPTR  EQU   AXPL+8
TAIE     EQU   0
TAIEMSGL EQU   TAIE
TAIETGET EQU   TAIE+2
AXBUF    EQU   0
AXLEN    EQU   AXBUF
AXOFF    EQU   AXBUF+2
AXTEXT   EQU   AXBUF+4
GTBUF    EQU   0
GTLEN    EQU   GTBUF
GTTEXT   EQU   GTBUF+4
GETBUFFR EQU   0
GETLEN   EQU   GETBUFFR
GETOFF   EQU   GETBUFFR+2
GETTEXT  EQU   GETBUFFR+4
CDSEG    EQU   0
CDLEN    EQU   CDSEG
CDOFF    EQU   CDSEG+2
BLOCK1   EQU   0
NEXT1    EQU   BLOCK1
NOSEGS1  EQU   BLOCK1+4
SEG11    EQU   BLOCK1+8
BLOCK2   EQU   0
NEXT2    EQU   BLOCK2
NOSEGS2  EQU   BLOCK2+4
SEG21    EQU   BLOCK2+8
SEG22    EQU   BLOCK2+12
SEG23    EQU   BLOCK2+16
DUMMYPTR EQU   0
         AGO   .@UNREFD                START UNREFERENCED COMPONENTS
CDTEXT   EQU   CDSEG+4
GTOFF    EQU   GTBUF+2
TAIERSAV EQU   TAIE+8
TAIEIAD  EQU   TAIE+4
@NM00012 EQU   TAIE+3
@NM00011 EQU   CSOA+7
@NM00010 EQU   CSOAFLG
@NM00009 EQU   CSOAFLG
@NM00008 EQU   CSOAFLG
CSOABAD  EQU   CSOAFLG
CSOAVNP  EQU   CSOAFLG
CSOAVWP  EQU   CSOAFLG
CSOALNM  EQU   CSOA+4
CSOACNM  EQU   CSOA
CSPLECB  EQU   CSPL+8
CSPLECT  EQU   CSPL+4
CSPLUPT  EQU   CSPL
STPBOTDD EQU   STPB+12
STPBINDD EQU   STPB+8
STPBALSD EQU   STPB+4
@NM00007 EQU   STPB
@NM00006 EQU   GTPB
PTPBFLN  EQU   PTPB+8
PTPBOPUT EQU   PTPB+4
@NM00005 EQU   PTPB
ECTBKPB  EQU   ECT+36
ECTUSER  EQU   ECT+32
ECTDDNUM EQU   ECT+29
@NM00004 EQU   ECTSWS
ECTBKGRD EQU   ECTSWS
ECTNNOT  EQU   ECTSWS
ECTNMAL  EQU   ECTSWS
ECTLOGF  EQU   ECTSWS
ECTATRM  EQU   ECTSWS
@NM00003 EQU   ECTSWS
ECTNOPD  EQU   ECTSWS
ECTSCMD  EQU   ECT+20
ECTSMSG  EQU   ECT+9
ECTIOWA  EQU   ECT+4
ECTRTCD  EQU   ECT+1
ECTRCDF  EQU   ECT
CPPLPSCB EQU   CPPL+8
CPPLCBUF EQU   CPPL
WORKADDR EQU   PARMAREA+60
BASE100  EQU   PARMAREA+56
REGISTR8 EQU   PARMAREA+52
STAESAVE EQU   PARMAREA+44
ATTNSAVE EQU   PARMAREA+40
@NM00002 EQU   EXITFLAG
@NM00001 EQU   PARMAREA+16
GTEXTLEN EQU   WORKAREA+78
BEG      EQU   WORKAREA+74
MSGOFF   EQU   MSGSEG+2
MSGLEN   EQU   MSGSEG
.@UNREFD ANOP                          END UNREFERENCED COMPONENTS
@RT00049 EQU   ERRMSG
@RT00051 EQU   EXIT
@RT00080 EQU   ERRMSG
@RT00082 EQU   EXIT
@RT00084 EQU   QMARK
@RT00096 EQU   ERRMSG
@RT00119 EQU   ERRMSG
@RT00134 EQU   ERRMSG
@RT00185 EQU   ERRMSG
@RT00231 EQU   REBLANK
@PB00003 EQU   @EL00001
@PB00002 EQU   @PB00003
@ENDDATA EQU   *
         END   IKJEE150
