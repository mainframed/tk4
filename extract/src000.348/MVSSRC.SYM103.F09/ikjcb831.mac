         TITLE 'GENERALIZED TRANSLATE ROUTINE                          *
                       '
IKJCB831 CSECT ,                                                   0001
GENTRANS DS    0H                                                  0001
         ENTRY GENTRANS
@MAINENT DS    0H                                                  0001
         USING *,@15                                               0001
         B     @PROLOG                                             0001
         DC    AL2(@EP00001-@MAINENT)
         DC    AL1(16)                                             0001
         DC    C'IKJCB831  73.255'                                 0001
         DROP  @15
@PROLOG  STM   @14,@12,12(@13)                                     0001
         BALR  @11,0                                               0001
@PSTART  LA    @12,4095(,@11)                                      0001
         USING @PSTART,@11                                         0001
         USING @PSTART+4095,@12                                    0001
         L     @00,@SIZDATD                                        0001
         GETMAIN R,LV=(0)
         LR    @10,@01                                             0001
         USING @DATD,@10                                           0001
         ST    @13,@SA00001+4                                      0001
         LM    @15,@01,16(@13)                                     0001
         ST    @10,8(,@13)                                         0001
         LR    @13,@10                                             0001
         XC    @ZTEMPS(@ZLEN),@ZTEMPS
         AH    @15,4(,@15)                                         0001
         BR    @15                                                 0001
@EP00001 DS    0H                                                  0002
*                                                                  0073
*                                                                  0074
*        GTPLPTR = R1;                                             0074
         ST    R1,GTPLPTR                                          0074
*        FAIL = '00'X;                 /* INITIALIZE FAIL BYTE       */
         MVI   FAIL,X'00'                                          0075
*        SWITCH = '0000'X;             /* INITIALIZE SWITCHES        */
         MVC   SWITCH(2),@CB00432                                  0076
*        RTCODE = 0;                   /* INITIALIZE RETURN CODE     */
         SR    @06,@06                                             0077
         ST    @06,RTCODE                                          0077
*        CALL  GETSTRGE;               /* GET CORE FOR TEXT, ADDRESS */
         BAL   @14,GETSTRGE                                        0078
*        CALL  TRNSLATE;               /* TRANSLATE PARAMETERS       */
*                                                                  0079
         BAL   @14,TRNSLATE                                        0079
*        IF FAIL ^= 0 & GETFAIL ^= '1'B THEN /* IF GENTRANS FAILED,  */
         CLI   FAIL,0                                              0080
         BE    @RF00080                                            0080
         TM    GETFAIL,B'01000000'                                 0080
         BO    @RF00080                                            0080
*          DO;                         /* IF NOT GETMAIN FAILURE,    */
*            GTPLOUTA = 0;                                         0082
         L     @06,GTPLPTR                                         0082
         SR    @02,@02                                             0082
         ST    @02,GTPLOUTA(,@06)                                  0082
*            R1 = ADDRPTR;             /* PUT ADDRESS IN REG 1       */
         L     R1,ADDRPTR                                          0083
*            SBPOOL = '01'X;           /* SUBPOOL AND                */
         MVI   SBPOOL,X'01'                                        0084
*            SIZE = ADDRCTR + 8 + TEXTCTR; /* LENGTH                 */
         LA    @06,8                                               0085
         AR    @06,ADDRCTR                                         0085
         AR    @06,TEXTCTR                                         0085
         ST    @06,@TF00001                                        0085
         MVC   SIZE(3),@TF00001+1                                  0085
*            R0 = SPLEN;               /* IN REG 0                   */
         L     R0,SPLEN                                            0086
*            GEN (FREEMAIN R,LV=(0),A=(1));  /* FREE STORAGE         */
         FREEMAIN R,LV=(0),A=(1)
*          END;                                                    0088
*                                                                  0088
*        R15 = RTCODE;                 /* RETURN CODE IN REG 15      */
@RF00080 L     R15,RTCODE                                          0089
*        RETURN CODE(R15);             /* RETURN TO CALLER           */
         LR    @09,@15                                             0090
         L     @13,4(,@13)                                         0090
         L     @00,@SIZDATD                                        0090
         LR    @01,@10                                             0090
         FREEMAIN R,LV=(0),A=(1)
         LR    @15,@09                                             0090
         L     @14,12(,@13)                                        0090
         LM    @00,@12,20(@13)                                     0090
         BR    @14                                                 0090
*                                                                  0091
*/********************************************************************/
*/*                                                                  */
*/* SEGMENT NAME -                                                   */
*/*      GETSTRGE                                                    */
*/*                                                                  */
*/* FUNCTION -                                                       */
*/*      THIS ROUTINE DETERMINES THE AMOUNT OF STORAGE NEEDED FOR    */
*/*      THE TEXT UNITS TO BE BUILT, AND THE ADDRESSES OF THE TEXT   */
*/*      UNITS.  THE GETMAIN IS ISSUED, AND IF SUCCESSFUL, POINTERS  */
*/*      TO THE STORAGE ARE SET UP.  IF THE GETMAIN FAILED, THE      */
*/*      RETURN CODE IS SET TO 12.                                   */
*/*                                                                  */
*/* INPUT -                                                          */
*/*      PTR TO PDL                                                  */
*/*      PTR TO PCL                                                  */
*/*      PTR TO ADDITIONAL TEXT                                      */
*/*                                                                  */
*/* OUTPUT -                                                         */
*/*      PTR TO ADDRESS STORAGE                                      */
*/*      PTR TO TEXT STORAGE                                         */
*/*      RETURN CODE :                                               */
*/*           0 = SUCCESSFUL                                         */
*/*           8 = UNSUPPORTED PARAMETER TYPE                         */
*/*          12 = GETMAIN FAILURE                                    */
*/*                                                                  */
*/* NOTE:  THIS ROUTINE REPRESENTS A DIRECT LINE FUNCTION AND CAN    */
*/*        BE INCORPORATED AS AN INCLUDED CODE SEGMENT WHEN THE      */
*/*        INCLUDE FUNCTION HAS RECEIVED A STANDARD DEFINITION       */
*/*                                                                  */
*/********************************************************************/
*    GETSTRGE: PROC;                                               0091
GETSTRGE STM   @14,@02,@SA00002                                    0091
         STM   @04,@06,@SA00002+20                                 0091
         STM   @08,@12,@SA00002+32                                 0091
*        PCLADS = GTPLPCL;             /* GET PTR TO PCL             */
         L     @15,GTPLPTR                                         0092
         L     @14,GTPLPCL(,@15)                                   0092
         ST    @14,PCLADS                                          0092
*        PDLADS = GTPLPDL;             /* AND PTR TO PDL             */
         L     @15,GTPLPDL(,@15)                                   0093
         ST    @15,PDLADS                                          0093
*        TEXTCTR = 0;                  /* INITIALIZE COUNTERS        */
         SR    @09,@09                                             0094
         LR    TEXTCTR,@09                                         0094
*        ADDRCTR = 0;                                              0095
*                                                                  0095
         LR    ADDRCTR,@09                                         0095
*        CURPCE = PCLADS + 6;          /* INCREMENT PAST PCL HEADER  */
         AH    @14,@CH00140                                        0096
         LR    CURPCE,@14                                          0096
*        CURPDE = PDLADS + CMPDEOF;                                0097
         AH    @15,CMPDEOF(,CURPCE)                                0097
         LR    CURPDE,@15                                          0097
*        DO WHILE (PCLEND = '0'B);     /* DO UNTIL END OF PCL FOUND  */
         B     @DE00098                                            0098
@DL00098 DS    0H                                                  0099
*          CALL PARMSTG;               /* INVOKE PARMSTG             */
         BAL   @14,PARMSTG                                         0099
*          IF FAIL = 0 THEN            /* IF PARMSTG SUCCESSFUL,     */
         CLI   FAIL,0                                              0100
         BNE   @RF00100                                            0100
*            CURPCE = CURPCE + PCELEN; /* GET NEXT PCE AND REPEAT    */
         AH    CURPCE,PCELEN                                       0101
*          ELSE                                                    0102
*            PCLEND = '1'B;            /* ELSE, EXIT FROM D0-WHILE   */
         B     @RC00100                                            0102
@RF00100 OI    PCLEND,B'10000000'                                  0102
*        END;                                                      0103
*                                                                  0103
@RC00100 DS    0H                                                  0103
@DE00098 TM    PCLEND,B'10000000'                                  0103
         BZ    @DL00098                                            0103
*        IF FAIL = 0 THEN              /* ERROR FOUND ?              */
         CLI   FAIL,0                                              0104
         BNE   @RF00104                                            0104
*          DO;                         /* NO -                       */
*            PCLEND = '0'B;                                        0106
         NI    PCLEND,B'01111111'                                  0106
*            IF GTPLABLK ^= 0 THEN     /* IF ADDITIONAL TEXT SUPPLIED*/
         L     @06,GTPLPTR                                         0107
         L     @06,GTPLABLK(,@06)                                  0107
         LTR   @06,@06                                             0107
         BZ    @RF00107                                            0107
*              ADDRCTR = ADDRCTR + (ADDBLKNM*4); /* ADD TO COUNTER   */
         LH    @06,ADDBLKNM(,@06)                                  0108
         SLA   @06,2                                               0108
         AR    ADDRCTR,@06                                         0108
*            SIZE = ADDRCTR+TEXTCTR+8; /* LENGTH AND                 */
@RF00107 LR    @06,ADDRCTR                                         0109
         AR    @06,TEXTCTR                                         0109
         AH    @06,@CH00162                                        0109
         ST    @06,@TF00001                                        0109
         MVC   SIZE(3),@TF00001+1                                  0109
*            SBPOOL = '01'X;           /* SUBPOOL NUMBER             */
         MVI   SBPOOL,X'01'                                        0110
*            R0 = SPLEN;               /* IN REG 0                   */
         L     R0,SPLEN                                            0111
*            GEN (GETMAIN R,LV=(0));   /* GET CORE                   */
*                                                                  0112
         GETMAIN R,LV=(0)
*            IF R15 ^= 0 THEN          /* IF GETMAIN FAILED,         */
         LTR   R15,R15                                             0113
         BZ    @RF00113                                            0113
*              DO;                     /* THEN                       */
*                RTCODE = 12;          /* SET RETURN CODE            */
         MVC   RTCODE(4),@CF00037                                  0115
*                GETFAIL = '1'B;       /* INDICATE ERROR TYPE        */
         OI    GETFAIL,B'01000000'                                 0116
*              END;                                                0117
*                                                                  0117
*            IF FAIL=0 THEN            /* ERROR FOUND ?              */
@RF00113 CLI   FAIL,0                                              0118
         BNE   @RF00118                                            0118
*              DO;                     /* NO -                       */
*                ADDRPTR = R1;         /* SET PTR TO ADDRESS LIST    */
         ST    R1,ADDRPTR                                          0120
*                SPNSIZE = SPLEN;      /* SET SUBPOOL AND SIZE       */
         L     @06,ADDRPTR                                         0121
         MVC   SPNSIZE(4,@06),SPLEN                                0121
*                NUMENTRY = ADDRCTR/4; /* NUMBER OF ENTRIES          */
         LR    @00,ADDRCTR                                         0122
         SRDA  @00,32                                              0122
         D     @00,@CF00172                                        0122
         STH   @01,NUMENTRY(,@06)                                  0122
*                TEXTPTR = ADDRPTR + ADDRCTR +8; /* AND TEXT STORAGE */
         LR    @02,ADDRCTR                                         0123
         AR    @02,@06                                             0123
         AH    @02,@CH00162                                        0123
         ST    @02,TEXTPTR                                         0123
*                GTPLOUTA = ADDRPTR;                               0124
         L     @02,GTPLPTR                                         0124
         ST    @06,GTPLOUTA(,@02)                                  0124
*              END;                                                0125
*          END;                                                    0126
*                                                                  0126
*END GETSTRGE;                                                     0127
@EL00002 DS    0H                                                  0127
@EF00002 DS    0H                                                  0127
@ER00002 LM    @14,@02,@SA00002                                    0127
         LM    @04,@06,@SA00002+20                                 0127
         LM    @08,@12,@SA00002+32                                 0127
         BR    @14                                                 0127
*/********************************************************************/
*/*                                                                  */
*/* SEGMENT NAME -                                                   */
*/*      PARMSTG                                                     */
*/*                                                                  */
*/* FUNCTION -                                                       */
*/*      THIS ROUTINE DETERMINES THE AMOUNT OF STORAGE NEEDED TO     */
*/*      BUILD THE TEXT FOR EACH PARAMETER IN THE PCL.               */
*/*                                                                  */
*/* OPERATION -                                                      */
*/*      BY EXAMINING THE PCE, THE PARAMETER TYPE IS DETERMINED      */
*/*      AND THE APPROPRIATE ROUTINE IS INVOKED TO DETERMINE THE     */
*/*      AMOUNT OF CORE FOR THIS PARAMETER. IF THE END OF THE PCL IS */
*/*      FOUND, AN INDICATOR IS SET.  IF A SUBFIELD PCE IS FOUND,    */
*/*      AN INDICATOR IS SET.  IF THE PARAMETER TYPE IS NEITHER OF   */
*/*      THE TYPES POSIT, IDENT, KEYWD, NAME, SUBF, OR ENDP THEN     */
*/*      THE RETURN CODE IS SET TO 8 (UNSUPPORTED PARAMETER TYPE).   */
*/*                                                                  */
*/* INPUT -                                                          */
*/*      PTR TO PDL                                                  */
*/*      PTR TO PCL                                                  */
*/*                                                                  */
*/* OUTPUT -                                                         */
*/*      A COUNTER INDICATING THE AMOUNT OF STORAGE NEEDED FOR THE   */
*/*      ADDRESS LIST.                                               */
*/*      A COUNTER INDICATING THE AMOUNT OF STORAGE NEEDED FOR THE   */
*/*      TEXT UNITS.                                                 */
*/*      SUBSTG = 1 - SUBFIELD PROCESSING                            */
*/*      PCLEND = 1 - END OF PCL FOUND                               */
*/*      RETURN CODE:                                                */
*/*           0 = SUCCESSFUL                                         */
*/*           8 = UNSUPPORTED PARAMETER TYPE                         */
*/*                                                                  */
*/* NOTE:  THIS ROUTINE REPRESENTS A DIRECT LINE FUNCTION AND CAN    */
*/*        BE INCORPORATED AS AN INCLUDED CODE SEGMENT WHEN THE      */
*/*        INCLUDE FUNCTION HAS RECEIVED A STANDARD DEFINITION.      */
*/********************************************************************/
*    PARMSTG: PROC;                                                0128
PARMSTG  STM   @14,@02,@SA00003                                    0128
         STM   @04,@06,@SA00003+20                                 0128
         STM   @08,@12,@SA00003+32                                 0128
*        IF CMTYPE = '010'B THEN            /* IF KEYWORD PCE,       */
         TM    CMTYPE(CURPCE),B'01000000'                          0129
         BNO   @RF00129                                            0129
         TM    CMTYPE(CURPCE),B'10100000'                          0129
         BNZ   @RF00129                                            0129
*          CALL STGKEYWD;                   /* GO TO PROCESS         */
         BAL   @14,STGKEYWD                                        0130
*        ELSE                                                      0131
*          IF CMTYPE = '001'B THEN          /* IF POSIT PCE,         */
         B     @RC00129                                            0131
@RF00129 TM    CMTYPE(CURPCE),B'00100000'                          0131
         BNO   @RF00131                                            0131
         TM    CMTYPE(CURPCE),B'11000000'                          0131
         BNZ   @RF00131                                            0131
*            DO;                            /* AND                   */
*              IF POSTYPE = 7 ×             /* DSNAME TYPE, GO TO    */
*                 POSTYPE = 8 THEN                                 0133
         CLI   POSTYPE(CURPCE),7                                   0133
         BE    @RT00133                                            0133
         CLI   POSTYPE(CURPCE),8                                   0133
         BNE   @RF00133                                            0133
@RT00133 DS    0H                                                  0134
*                CALL STGDSN;               /* PROCESS DSNAME        */
         BAL   @14,STGDSN                                          0134
*              ELSE                         /* ELSE, HANDLE NON-DSN  */
*                CALL STGIDENT;             /* POSIT SAME AS IDENT   */
         B     @RC00133                                            0135
@RF00133 BAL   @14,STGIDENT                                        0135
*            END;                                                  0136
*          ELSE                                                    0137
*            IF CMTYPE = '100'B THEN        /* IF IDENT PCE, GO TO   */
         B     @RC00131                                            0137
@RF00131 TM    CMTYPE(CURPCE),B'10000000'                          0137
         BNO   @RF00137                                            0137
         TM    CMTYPE(CURPCE),B'01100000'                          0137
         BNZ   @RF00137                                            0137
*              CALL STGIDENT;               /* PROCESS IDENT         */
         BAL   @14,STGIDENT                                        0138
*            ELSE                            /* IF ENDP CPE, SET END */
*              IF CURPCE=LENPCL+PCLADS-1 THEN                      0139
         B     @RC00137                                            0139
@RF00137 L     @02,PCLADS                                          0139
         LH    @15,LENPCL(,@02)                                    0139
         AR    @15,@02                                             0139
         BCTR  @15,0                                               0139
         CR    CURPCE,@15                                          0139
         BNE   @RF00139                                            0139
*                PCLEND = '1'B;             /* OF PCL INDICATOR      */
         OI    PCLEND,B'10000000'                                  0140
*              ELSE                                                0141
*                IF CMTYPE = '011'B THEN    /* IF NAME PCE, DO NOT   */
         B     @RC00139                                            0141
@RF00139 TM    CMTYPE(CURPCE),B'01100000'                          0141
         BNO   @RF00141                                            0141
         TM    CMTYPE(CURPCE),B'10000000'                          0141
         BNZ   @RF00141                                            0141
*                  PCELEN = CMPCELEN;       /* PROCESS-JUST SET LENGH*/
         MVC   PCELEN(2),CMPCELEN(CURPCE)                          0142
*                ELSE                                              0143
*                  DO;                                             0143
         B     @RC00141                                            0143
@RF00141 DS    0H                                                  0144
*                    IF CMTYPE = '000'B THEN                       0144
         TM    CMTYPE(CURPCE),B'11100000'                          0144
         BNZ   @RF00144                                            0144
*                      DO;                  /* IF SUBF PCE,          */
*                        SUBSTG = '1'B;     /* INDICATE SUBFIELD     */
         OI    SUBSTG,B'01000000'                                  0146
*                        PCELEN = 3;        /* SET PCE LENGTH TO 3   */
         MVC   PCELEN(2),@CH00119                                  0147
*                      END;                                        0148
*                    ELSE                   /* IF NONE OF ABOVE,     */
*                      DO;                                         0149
         B     @RC00144                                            0149
@RF00144 DS    0H                                                  0150
*                        RTCODE = 8;        /* SET RETURN CODE       */
         MVC   RTCODE(4),@CF00162                                  0150
*                        NOSUPT = '1'B;     /* UNSUPPORTED PARM TYPE */
         OI    NOSUPT,B'00100000'                                  0151
*                      END;                                        0152
*                  END;                                            0153
*                                                                  0153
*END PARMSTG;                                                      0154
@EL00003 DS    0H                                                  0154
@EF00003 DS    0H                                                  0154
@ER00003 LM    @14,@02,@SA00003                                    0154
         LM    @04,@06,@SA00003+20                                 0154
         LM    @08,@12,@SA00003+32                                 0154
         BR    @14                                                 0154
*/********************************************************************/
*/*                                                                  */
*/* SEGMENT NAME -                                                   */
*/*      STGKEYWD                                                    */
*/*                                                                  */
*/* FUNCTION -                                                       */
*/*      THIS ROUTINE DETERMINES THE AMOUNT OF STORAGE NEEDED FOR A  */
*/*      KEYWORD TEXT UNIT.                                          */
*/*                                                                  */
*/* OPERATION -                                                      */
*/*      IF THE KEYWORD IS IN A SUBFIELD, THE ADDRESS COUNTER        */
*/*      IS NOT INCREMENTED. IF THE KEYWORD IS NOT IN A SUBFIELD,    */
*/*      THE ADDRESS COUNTER IS INCREMENTED BY 4.  IF THE KEYWORD    */
*/*      IS NOT ENTERED, THE TEXT COUNTER IS NOT INCREMENTED.        */
*/*      OTHERWISE, THE TEXT COUNTER IS INCREMENTED BY 7.            */
*/*                                                                  */
*/* INPUT -                                                          */
*/*      PTR TO KEYWORD PCE                                          */
*/*      PTR TO PDL                                                  */
*/*                                                                  */
*/* OUTPUT -                                                         */
*/*      ADDRESS COUNTER AND TEXT COUNTER INCREMENTED ACCORDING      */
*/*      TO INFORMATION GIVEN IN PCE.                                */
*/*                                                                  */
*/* NOTE:  THIS ROUTINE REPRESENTS A DIRECT LINE FUNCTION AND CAN BE */
*/*        INCORPORATED AS AN INCLUDED CODE SEGMENT WHEN THE INCLUDE */
*/*        FUNCTION HAS RECEIVED A STANDARD DEFINITION.              */
*/********************************************************************/
*    STGKEYWD: PROC;                                               0155
STGKEYWD STM   @14,@02,12(@13)                                     0155
         STM   @04,@06,36(@13)                                     0155
         STM   @08,@12,52(@13)                                     0155
*        CURPDE = PDLADS + CMPDEOF;    /* SET UP PDE POINTER         */
         LH    CURPDE,CMPDEOF(,CURPCE)                             0156
         A     CURPDE,PDLADS                                       0156
*        IF SUBSTG = '0'B THEN         /* IF NOT PROCESSING SUBFIELD,*/
         TM    SUBSTG,B'01000000'                                  0157
         BNZ   @RF00157                                            0157
*          ADDRCTR = ADDRCTR + 4;      /* ALLOW FOR ADDRESS          */
*                                                                  0158
         AH    ADDRCTR,@CH00172                                    0158
*        PCELEN = CMPCELEN;            /* SAVE PCE LENGTH            */
*                                                                  0159
@RF00157 MVC   PCELEN(2),CMPCELEN(CURPCE)                          0159
*        IF KYWDNBR ^= 0 THEN          /* IF PARM WAS ENTERED,       */
         LH    @15,KYWDNBR(,CURPDE)                                0160
         LTR   @15,@15                                             0160
         BZ    @RF00160                                            0160
*          TEXTCTR = TEXTCTR + 7;      /* INCREASE STORAGE CTR       */
*                                                                  0161
         AH    TEXTCTR,@CH00125                                    0161
*END STGKEYWD;                                                     0162
@EL00004 DS    0H                                                  0162
@EF00004 DS    0H                                                  0162
@ER00004 LM    @14,@02,12(@13)                                     0162
         LM    @04,@06,36(@13)                                     0162
         LM    @08,@12,52(@13)                                     0162
         BR    @14                                                 0162
*/********************************************************************/
*/*                                                                  */
*/* SEGMENT NAME -                                                   */
*/*      STGIDENT                                                    */
*/*                                                                  */
*/* FUNCTION -                                                       */
*/*      THIS ROUTINE DETERMINES THE AMOUNT OF CORE NEEDED FOR AN    */
*/*      IDENT OR POSIT (OTHER THAN DSNAME) TEXT UNIT.               */
*/*                                                                  */
*/* OPERATION -                                                      */
*/*      IF PARAMETER IN SUBFIELD, ADDRESS CTR NOT INCREMENTED.  IF  */
*/*      THE PARAMETER IS NOT IN A  SUBFIELD, THE ADDRESS COUNTER    */
*/*      IS INCREMENTED BY 4. IF THE PARAMETER IS NOT ENTERED, THE   */
*/*      TEXT COUNTER IS NOT INCREMENTED.  OTHERWISE, THE TEXT       */
*/*      COUNTER IS INCREMENTED BY LENGTH OF THE PARAMETER PLUS 6.   */
*/*      IF A LIST IS SPECIFIED, THE TEXT COUNTER IS INCREMENTED     */
*/*      BY LENGTH OF PARAMETER PLUS 2 FOR EACH ELEMENT IN THE LIST. */
*/*                                                                  */
*/* INPUT -                                                          */
*/*      PTR TO IDENT OR POSIT PCE                                   */
*/*      PTR TO PDL                                                  */
*/*                                                                  */
*/* OUTPUT -                                                         */
*/*      ADDRESS COUNTER AND TEXT COUNTER INCREMENTED ACCORDING      */
*/*      TO INFORMATION GIVEN IN PCE.                                */
*/*                                                                  */
*/* NOTE:  THIS ROUTINE REPRESENTS A DIRECT LINE FUNCTION AND CAN    */
*/*        BE INCORPORATED AS AN INCLUDED CODE SEGMENT WHEN THE      */
*/*        INCLUDE FUNCTION HAS RECEIVED A STANDARD DEFINITION.      */
*/********************************************************************/
*                                                                  0163
*    STGIDENT: PROC;                                               0163
STGIDENT STM   @14,@02,12(@13)                                     0163
         STM   @04,@06,36(@13)                                     0163
         STM   @08,@12,52(@13)                                     0163
*        CURPDE = PDLADS+CMPDEOF;      /* SET UP PDE POINTER         */
         LH    CURPDE,CMPDEOF(,CURPCE)                             0164
         A     CURPDE,PDLADS                                       0164
*        IF SUBSTG = '0'B THEN         /* IF NOT PROCESSING SUBFIELD,*/
         TM    SUBSTG,B'01000000'                                  0165
         BNZ   @RF00165                                            0165
*          ADDRCTR = ADDRCTR + 4;      /* ALLOW FOR ADDRESS          */
         AH    ADDRCTR,@CH00172                                    0166
*        PCELEN = CMPCELEN;            /* SAVE PCE LENGTH            */
@RF00165 MVC   PCELEN(2),CMPCELEN(CURPCE)                          0167
*        IF PARMPRES = '1'B THEN       /* IF PARAMETER ENTERED,      */
         TM    PARMPRES(CURPDE),B'10000000'                        0168
         BNO   @RF00168                                            0168
*          DO;                         /* INCREMENT TEXT STORAGE CTR */
*            TEXTCTR = TEXTCTR + (PARMLEN + 6);                    0170
         LA    @15,6                                               0170
         AH    @15,PARMLEN(,CURPDE)                                0170
         AR    TEXTCTR,@15                                         0170
*            IF CMLIST = '1'B THEN     /* IF LIST OPTION SPECIFIED,  */
         TM    CMLIST(CURPCE),B'10000000'                          0171
         BNO   @RF00171                                            0171
*              DO WHILE (NEXTPARM ^= PDECMPRE);                    0172
         B     @DE00172                                            0172
@DL00172 DS    0H                                                  0173
*                CURPDE = NEXTPARM;    /* GET NEXT PDE IN LIST       */
         L     CURPDE,NEXTPARM(,CURPDE)                            0173
*                TEXTCTR = TEXTCTR + (PARMLEN + 2);                0174
         LA    @15,2                                               0174
         AH    @15,PARMLEN(,CURPDE)                                0174
         AR    TEXTCTR,@15                                         0174
*              END;                    /* INCREMENT TEXT STORAGE CTR */
@DE00172 CLC   NEXTPARM(4,CURPDE),PDECMPRE                         0175
         BNE   @DL00172                                            0175
*          END;                                                    0176
*END STGIDENT;                                                     0177
@EL00005 DS    0H                                                  0177
@EF00005 DS    0H                                                  0177
@ER00005 LM    @14,@02,12(@13)                                     0177
         LM    @04,@06,36(@13)                                     0177
         LM    @08,@12,52(@13)                                     0177
         BR    @14                                                 0177
*/********************************************************************/
*/*                                                                  */
*/* SEGMENT NAME -                                                   */
*/*      STGDSN                                                      */
*/*                                                                  */
*/* FUNCTION -                                                       */
*/*      THIS ROUTINE DETERMINES THE AMOUNT OF STORAGE NEEDED        */
*/*      FOR A DATA SET NAME TYPE TEXT UNIT.                         */
*/*                                                                  */
*/* OPERATION -                                                      */
*/*      IF DSNAME IS IN SUBFIELD, ADDRESS COUNTER INCREMENTED BY 8  */
*/*      (4 FOR ADDRESS OF MEMBER NAME, AND 4 FOR ADDRESS OF         */
*/*      PASSWORD).  IF THE DATA SET NAME IS NOT IN A SUBFIELD, THE  */
*/*      ADDRESS COUNTER IS INCREMENTED BY 12 (THE ABOVE, PLUS 4 FOR */
*/*      THE ADDRESS OF DSNAME).  IF THE PARAMETER IS NOT ENTERED,   */
*/*      THE TEXT COUNTER IS NOT INCREMENTED.   IF THE PARAMETER IS  */
*/*      ENTERED, THE TEXT COUNTER IS INCREMENTED BY LENGTH OF THE   */
*/*      DSNAME PLUS 42 (6 FOR HEADER OF DSNAME UNIT, 6 FOR HEADER   */
*/*      OF MEMBER NAME UNIT, 8 FOR MAXIMUM MEMBER NAME, 6 FOR       */
*/*      HEADER OF PASSWORD UNIT, 8 FOR MAXIMUM USERID, AND 8 FOR    */
*/*      MAXIMUM PASSWORD).  IF A LIST OF DSNAMES IS ENTERED, THE    */
*/*      TEXT COUNTER IS INCREMENTED BY THE DSNAME LENGTH PLUS 30    */
*/*      FOR EACH DSNAME IN LIST (2 FOR DSNAME LENGTH, 8 FOR         */
*/*      MAXIMUM USERID, 2 FOR MEMBER NAME LENGTH, 8 FOR MAXIMUM     */
*/*      MEMBER NAME, 2 FOR PASSWORD LENGTH, AND 8 FOR MAXIMUM       */
*/*      PASSWORD).                                                  */
*/*                                                                  */
*/* INPUT -                                                          */
*/*      PTR TO DSNAME PCE                                           */
*/*      PTR TO PDL                                                  */
*/*                                                                  */
*/* OUTPUT -                                                         */
*/*      ADDRESS COUNTER AND TEXT COUNTER INCREMENTED ACCORDING      */
*/*      TO INFORMATION GIVEN IN PCE.                                */
*/*                                                                  */
*/* NOTE:  THIS ROUTINE REPRESENTS A DIRECT LINE FUNCTION AND CAN    */
*/*        BE INCORPORATED AS AN INCLUDED CODE SEGMENT WHEN THE      */
*/*        INCLUDE FUNCTION HAS RECEIVED A STANDARD DEFINITION.      */
*/********************************************************************/
*    STGDSN: PROC;                                                 0178
STGDSN   STM   @14,@02,12(@13)                                     0178
         STM   @04,@06,36(@13)                                     0178
         STM   @08,@12,52(@13)                                     0178
*        CURPDE = PDLADS + CMPDEOF;    /* SET UP PDE POINTER         */
         LH    CURPDE,CMPDEOF(,CURPCE)                             0179
         A     CURPDE,PDLADS                                       0179
*        PCELEN = CMPCELEN;            /* SAVE PCE LENGTH            */
*                                                                  0180
         MVC   PCELEN(2),CMPCELEN(CURPCE)                          0180
*        IF SUBSTG = '1'B THEN         /* IF PROCESSING SUBFLD, ALLOW*/
         TM    SUBSTG,B'01000000'                                  0181
         BNO   @RF00181                                            0181
*          ADDRCTR = ADDRCTR + 8;      /* FOR MBR, PSWORD ADDRESSES  */
         AH    ADDRCTR,@CH00162                                    0182
*        ELSE                          /* ELSE, ALLOW FOR DSN, MBR   */
*          ADDRCTR = ADDRCTR + 12;     /* AND PSWORD ADDRESSES       */
*                                                                  0183
         B     @RC00181                                            0183
@RF00181 AH    ADDRCTR,@CH00037                                    0183
*        IF PARMPRES = '1'B THEN       /* IF PARAMETER ENTERED,      */
@RC00181 TM    PARMPRES(CURPDE),B'10000000'                        0184
         BNO   @RF00184                                            0184
*          DO;                         /* INCREMENT TEXT STORAGE CTR */
*            TEXTCTR = TEXTCTR + PARMLEN + 42;                     0186
         LR    @15,TEXTCTR                                         0186
         AH    @15,PARMLEN(,CURPDE)                                0186
         AH    @15,@CH00462                                        0186
         LR    TEXTCTR,@15                                         0186
*            IF CMLIST = '1'B THEN     /* IF LIST OPTION SPECIFIED,  */
         TM    CMLIST(CURPCE),B'10000000'                          0187
         BNO   @RF00187                                            0187
*              DO WHILE (DSNNEXT ^= 'FF000000'X);                  0188
         B     @DE00188                                            0188
@DL00188 DS    0H                                                  0189
*                CURPDE = DSNNEXT;     /* GET NEXT PDE IN LIST       */
         L     CURPDE,DSNNEXT(,CURPDE)                             0189
*                                      /* INCREMENT TEXT STORAGE CTR */
*                TEXTCTR = TEXTCTR + PARMLEN + 30;                 0190
         LR    @15,TEXTCTR                                         0190
         AH    @15,PARMLEN(,CURPDE)                                0190
         AH    @15,@CH00463                                        0190
         LR    TEXTCTR,@15                                         0190
*              END;                                                0191
@DE00188 CLC   DSNNEXT(4,CURPDE),@CF00192                          0191
         BNE   @DL00188                                            0191
*          END;                                                    0192
*END STGDSN;                                                       0193
@EL00006 DS    0H                                                  0193
@EF00006 DS    0H                                                  0193
@ER00006 LM    @14,@02,12(@13)                                     0193
         LM    @04,@06,36(@13)                                     0193
         LM    @08,@12,52(@13)                                     0193
         BR    @14                                                 0193
*/********************************************************************/
*/*                                                                  */
*/* SEGMENT NAME -                                                   */
*/*      TRNSLATE                                                    */
*/*                                                                  */
*/* FUNCTION -                                                       */
*/*      THIS ROUTINE BUILDS THE TEXT UNITS FOR EACH PARAMETER       */
*/*      ENTERED IN THE PDL.                                         */
*/*                                                                  */
*/* OPERATION -                                                      */
*/*      A ROUTINE IS INVOKED WHICH WILL DETERMINE THE PARAMETER     */
*/*      TYPE AND WILL SUBSEQUENTLY INVOKE THE PROPER ROUTINE TO     */
*/*      TRANSLATE THE PARAMETER.  THE TRNSLATE ROUTINE WILL THEN    */
*/*      INCREMENT TO THE NEXT PCE, AND REPEAT THE PROCESS ABOVE.    */
*/*      WHEN THE END OF THE PCL IS REACHED, THE ADDITIONAL BLOCK    */
*/*      OF TEXT PASSED BY THE USER (IF ANY) WILL BE APPENDED TO THE */
*/*      TEXT JUST BUILT, AND THE INDICATOR WILL BE SET TO SHOW THE  */
*/*      END OF THE LIST.                                            */
*/*                                                                  */
*/* INPUT -                                                          */
*/*      PTR TO PDL                                                  */
*/*      PTR TO PCL                                                  */
*/*      PTR TO KEY LIST                                             */
*/*      PTR TO KEYWORD TABLE                                        */
*/*      PTR TO ADDITIONAL TEXT                                      */
*/*      PTR TO ADDRESS LIST                                         */
*/*      PTR TO TEXT STORAGE                                         */
*/*                                                                  */
*/* OUTPUT -                                                         */
*/*       PTR TO A LIST OF ADDRESSES WHICH POINT TO THE TEXT UNITS.  */
*/*       RETURN CODE:                                               */
*/*             0 = SUCCESSFUL                                       */
*/*             4 = INVALID PARAMETERS PASSED TO GENTRANS            */
*/*                                                                  */
*/* NOTE:  THIS ROUTINE REPRESENTS A DIRECT LINE FUNCTION AND CAN    */
*/*        BE INCORPORATED AS AN INCLUDED CODE SEGMENT WHEN THE      */
*/*        INCLUDE FUNCTION HAS RECEIVED A STANDARD DEFINITION.      */
*/********************************************************************/
*    TRNSLATE: PROC;                                               0194
TRNSLATE STM   @14,@12,@SA00007                                    0194
*        IF FAIL = 0 THEN                   /* ERROR FOUND ?         */
         CLI   FAIL,0                                              0195
         BNE   @RF00195                                            0195
*          DO;                              /* NO -                  */
*            CURPCE = PCLADS + 6;           /* GET FIRST PCE         */
         LA    CURPCE,6                                            0197
         A     CURPCE,PCLADS                                       0197
*            CURPDE = PDLADS+CMPDEOF;                              0198
         LH    CURPDE,CMPDEOF(,CURPCE)                             0198
         A     CURPDE,PDLADS                                       0198
*            KEYLIST = GTPLKLST;                                   0199
         L     @01,GTPLPTR                                         0199
         L     KEYLIST,GTPLKLST(,@01)                              0199
*            I = 1;                         /* INITIALIZE SUBSCRIPT  */
         LA    I,1                                                 0200
*            B = KEYLIST;                   /* INIT B FOR KEYLIST    */
         ST    KEYLIST,B                                           0201
*            A = TEXTPTR;                   /* INITIALIZE A FOR TEXT */
         L     A,TEXTPTR                                           0202
*            DO WHILE (CMTYPE ^= '000'B);                          0203
         B     @DE00203                                            0203
@DL00203 DS    0H                                                  0204
*              CALL DETTYPE;                /* DETERMINE PARM TYPE   */
         BAL   @14,DETTYPE                                         0204
*              IF PCLEND = '0'B THEN                               0205
         TM    PCLEND,B'10000000'                                  0205
         BNZ   @RF00205                                            0205
*                DO;                                               0206
*              CALL TYPEPROC;               /* PROCESS POSSIBLE REPLY*/
         BAL   @14,TYPEPROC                                        0207
*              IF FAIL = 0 THEN             /* ERROR FOUND ?         */
         CLI   FAIL,0                                              0208
         BNE   @RF00208                                            0208
*                DO;                        /* NO -                  */
*                  CURPCE=CURPCE+CMPCELEN;  /* GET NEXT PCE          */
         AH    CURPCE,CMPCELEN(,CURPCE)                            0210
*                  TEXTPTR = A;             /* INCREMENT TEXT PTR    */
         ST    A,TEXTPTR                                           0211
*                  I = I+1;                 /* INCREMENT ADDRESS PTR */
         AH    I,@CH00081                                          0212
*                  KEYLIST = KEYLIST + 4;                          0213
         AH    KEYLIST,@CH00172                                    0213
*                  B = KEYLIST;                                    0214
         ST    KEYLIST,B                                           0214
*                END;                                              0215
*              ELSE                         /* IF ERROR FOUND (2ND)  */
*                CMTYPE = '000'B;           /* EXIT FROM DO-WHILE    */
         B     @RC00208                                            0216
@RF00208 NI    CMTYPE(CURPCE),B'00011111'                          0216
*                END;                                              0217
@RC00208 DS    0H                                                  0218
*           END;                                                   0218
*                                                                  0218
@RF00205 DS    0H                                                  0218
@DE00203 TM    CMTYPE(CURPCE),B'11100000'                          0218
         BNZ   @DL00203                                            0218
*           IF FAIL=0 THEN                  /* ERROR FOUND ?         */
         CLI   FAIL,0                                              0219
         BNE   @RF00219                                            0219
*              DO;                          /* NO -                  */
*                IF GTPLABLK ^= 0 THEN      /* IF TEXT TO BE ADDED,  */
         L     @06,GTPLPTR                                         0221
         L     @06,GTPLABLK(,@06)                                  0221
         LTR   @06,@06                                             0221
         BZ    @RF00221                                            0221
*                  DO K = 1 TO ADDBLKNM;  /* GET ADDRESSES           */
         LA    K,1                                                 0222
         B     @DE00222                                            0222
@DL00222 DS    0H                                                  0223
*                    ADDRLIST(I) = ADDBLKPT(K);                    0223
         LR    @09,I                                               0223
         SLA   @09,2                                               0223
         LR    @06,K                                               0223
         SLA   @06,2                                               0223
         L     @01,GTPLPTR                                         0223
         L     @01,GTPLABLK(,@01)                                  0223
         L     @06,ADDBLKPT-4(@06,@01)                             0223
         L     @01,ADDRPTR                                         0223
         ST    @06,ADDRLIST-4(@09,@01)                             0223
*                    I = I+1;                                      0224
         AH    I,@CH00081                                          0224
*                  END;                                            0225
         AH    K,@CH00081                                          0225
@DE00222 L     @09,GTPLPTR                                         0225
         L     @09,GTPLABLK(,@09)                                  0225
         CH    K,ADDBLKNM(,@09)                                    0225
         BNH   @DL00222                                            0225
*                  ADDREND(I-1) = '1'B;   /* INDICATE END OF TEXT  */
@RF00221 LR    @06,I                                               0226
         SLA   @06,2                                               0226
         L     @01,ADDRPTR                                         0226
         ALR   @01,@06                                             0226
         OI    ADDREND-8(@01),B'10000000'                          0226
*              END;                                                0227
*          END;                                                    0228
*END TRNSLATE;                                                     0229
@EL00007 DS    0H                                                  0229
@EF00007 DS    0H                                                  0229
@ER00007 LM    @14,@12,@SA00007                                    0229
         BR    @14                                                 0229
*/********************************************************************/
*/*                                                                  */
*/* SEGMENT NAME -                                                   */
*/*      DETTYPE                                                     */
*/*                                                                  */
*/* FUNCTION -                                                       */
*/*      THIS ROUTINE INVOKES THE APPROPRIATE ROUTINE TO TRANSLATE   */
*/*      A PCE TO TEXT FORMAT.                                       */
*/*                                                                  */
*/* OPERATION -                                                      */
*/*      BY EXAMINING THE PCE TO DETERMINE THE PARAMETER TYPE,       */
*/*      THIS ROUTINE ROUTES CONTROL TO VARIOUS TRANSLATING          */
*/*      ROUTINES TO BUILD THE TEXT UNITS.                           */
*/*                                                                  */
*/* INPUT -                                                          */
*/*     PTR TO CURRENT PCE                                           */
*/*     PTR TO PDL                                                   */
*/*     PTR TO KEYLIST                                               */
*/*     PTR TO KEYWORD TABLE                                         */
*/*     PTR TO ADDRESS LIST                                          */
*/*     PTR TO TEXT STORAGE                                          */
*/*                                                                  */
*/* OUTPUT -                                                         */
*/*     PTR TO TEXT FOR CURRENT PARAMETER                            */
*/*     PCLEND=1 - END OF PCL FOUND                                  */
*/*                                                                  */
*/* NOTE:  THIS ROUTINE REPRESENTS A DIRECT LINE FUNCTION AND CAN    */
*/*        BE INCORPORATED AS AN INCLUDED CODE SEGMENT WHEN THE      */
*/*        INCLUDE FUNCTION HAS RECEIVED A STANDARD DEFINITION.      */
*/********************************************************************/
*    DETTYPE: PROC;                                                0230
DETTYPE  STM   @14,@02,@SA00008                                    0230
         STM   @04,@05,@SA00008+20                                 0230
         STM   @08,@12,@SA00008+28                                 0230
*        IF FAIL = 0 THEN                                          0231
         CLI   FAIL,0                                              0231
         BNE   @RF00231                                            0231
*          DO;                                                     0232
*            DO WHILE (CMTYPE = '011'B);    /* IF NAME PCE, INCREMENT*/
         B     @DE00233                                            0233
@DL00233 DS    0H                                                  0234
*              CURPCE = CURPCE + CMPCELEN;  /* TO NEXT PCE           */
         AH    CURPCE,CMPCELEN(,CURPCE)                            0234
*            END;                                                  0235
*                                                                  0235
@DE00233 TM    CMTYPE(CURPCE),B'01100000'                          0235
         BNO   @DC00233                                            0235
         TM    CMTYPE(CURPCE),B'10000000'                          0235
         BZ    @DL00233                                            0235
@DC00233 DS    0H                                                  0236
*            IF CMTYPE = '010'B THEN        /* IF KEYWORD PCE,       */
         TM    CMTYPE(CURPCE),B'01000000'                          0236
         BNO   @RF00236                                            0236
         TM    CMTYPE(CURPCE),B'10100000'                          0236
         BNZ   @RF00236                                            0236
*              DO;                          /* THEN                  */
*              NAMECTR = 0;                 /* INIT NAME CTR @YM01873*/
         SR    @02,@02                                             0238
         STH   @02,NAMECTR                                         0238
*              CALL TNKEYWD;                /* TRANSLATE KEYWORD     */
         BAL   @14,TNKEYWD                                         0239
*              END;                                                0240
*            ELSE                                                  0241
*              IF CMTYPE = '001'B THEN      /* IF POSIT PCE,         */
         B     @RC00236                                            0241
@RF00236 TM    CMTYPE(CURPCE),B'00100000'                          0241
         BNO   @RF00241                                            0241
         TM    CMTYPE(CURPCE),B'11000000'                          0241
         BNZ   @RF00241                                            0241
*                DO;                        /* AND                   */
*                  IF POSTYPE = 7 ×         /* IF DSNAME TYPE THEN   */
*                     POSTYPE = 8 THEN                             0243
         CLI   POSTYPE(CURPCE),7                                   0243
         BE    @RT00243                                            0243
         CLI   POSTYPE(CURPCE),8                                   0243
         BNE   @RF00243                                            0243
@RT00243 DS    0H                                                  0244
*                    CALL DSNTRANS;         /* GO TO TRANSLATE DSN   */
         BAL   @14,DSNTRANS                                        0244
*                  ELSE                     /* ELSE, HANDLE POSIT    */
*                    CALL TNIDENT;          /* SAME AS IDENT PCE     */
         B     @RC00243                                            0245
@RF00243 BAL   @14,TNIDENT                                         0245
*                END;                                              0246
*              ELSE                                                0247
*                IF CMTYPE = '100'B THEN    /* IF IDENT PCE, GO TO   */
         B     @RC00241                                            0247
@RF00241 TM    CMTYPE(CURPCE),B'10000000'                          0247
         BNO   @RF00247                                            0247
         TM    CMTYPE(CURPCE),B'01100000'                          0247
         BNZ   @RF00247                                            0247
*                  CALL TNIDENT;            /* TRANSLATE IDENT       */
         BAL   @14,TNIDENT                                         0248
*                ELSE                                              0249
*                  IF CMTYPE = '000'B THEN  /* IF ENDP OR SUBF,      */
         B     @RC00247                                            0249
@RF00247 TM    CMTYPE(CURPCE),B'11100000'                          0249
         BNZ   @RF00249                                            0249
*                    PCLEND = '1'B;         /* INDICATE PCL END      */
         OI    PCLEND,B'10000000'                                  0250
*          END;                                                    0251
*END DETTYPE;                                                      0252
@EL00008 DS    0H                                                  0252
@EF00008 DS    0H                                                  0252
@ER00008 LM    @14,@02,@SA00008                                    0252
         LM    @04,@05,@SA00008+20                                 0252
         LM    @08,@12,@SA00008+28                                 0252
         BR    @14                                                 0252
*/********************************************************************/
*/*                                                                  */
*/* SEGMENT NAME -                                                   */
*/*      TNKEYWD                                                     */
*/*                                                                  */
*/* FUNCTION -                                                       */
*/*      THIS ROUTINE TRANSLATES A KEYWORD PARAMETER TO THE TEXT     */
*/*      FORMAT.                                                     */
*/*                                                                  */
*/* OPERATION -                                                      */
*/*       IF THE KEYWORD WAS NOT ENTERED, AN INDICATOR IS SET.  IF   */
*/*       THE KEYWORD WAS ENTERED, THE PCE POINTER IS INCREMENTED TO */
*/*       CORRESPONDING NAME PCE.  IF A SUBFIELD IS ALLOWED FOR      */
*/*       THE NAME, INDICATORS ARE SET, THE CURRENT PCE IS SAVED,    */
*/*       AND THE POINTER TO THE SUBFIELD PCE IS SET UP.  CONTROL IS */
*/*       THEN RETURNED TO THE CALLER.  IF A SUBFIELD IS NOT         */
*/*       ALLOWED, THE ROUTINE KEYTRNS IS INVOKED TO HANDLE THE      */
*/*       KEYWORD.                                                   */
*/*                                                                  */
*/* INPUT -                                                          */
*/*       PTR TO KEYWORD PCE                                         */
*/*       PTR TO PDL                                                 */
*/*       PTR TO KEY LIST                                            */
*/*       PTR TO KEYWORD TABLE                                       */
*/*       PTR TO TEXT STORAGE                                        */
*/*                                                                  */
*/* OUTPUT -                                                         */
*/*       PARMOMIT = 1 - PARAMETER NOT ENTERED                       */
*/*       SUBTRN = 1 - SUBFIELD PROCESSING                           */
*/*       PTR TO TEXT FOR KEYWORD (IF SUBFIELD NOT ALLOWED)          */
*/*       PTR TO SUBFIELD PCE (IF SUBFIELD ALLOWED)                  */
*/*                                                                  */
*/* NOTE:  THIS ROUTINE REPRESENTS A DIRECT LINE FUNCTION AND CAN    */
*/*        BE INCORPORATED AS AN INCLUDED CODE SEGMENT WHEN THE      */
*/*        INCLUDE FUNCTION HAS RECEIVED A STANDARD DEFINITION.      */
*/********************************************************************/
*    TNKEYWD: PROC;                                                0253
TNKEYWD  STM   @14,@02,@SA00009                                    0253
         STM   @04,@05,@SA00009+20                                 0253
         STM   @08,@12,@SA00009+28                                 0253
* AA:    CURPDE = PDLADS + CMPDEOF;         /* SET UP PDE PTR        */
AA       LH    CURPDE,CMPDEOF(,CURPCE)                             0254
         A     CURPDE,PDLADS                                       0254
*        IF KYWDNBR = 0 THEN                /*IF PARM NOT ENTERED,   */
         LH    @15,KYWDNBR(,CURPDE)                                0255
         LTR   @15,@15                                             0255
         BNZ   @RF00255                                            0255
*          DO;                              /* AND                   */
*            IF SUBTRN = '1'B THEN          /* WITHIN A SUBFIELD,    */
         TM    SUBTRN,B'00010000'                                  0257
         BNO   @RF00257                                            0257
*              KYNOFND = '1'B;              /* INDICATE NOT FOUND    */
         OI    KYNOFND,B'10000000'                                 0258
*            ELSE                           /* OTHERWISE             */
*              DO;                                                 0259
         B     @RC00257                                            0259
@RF00257 DS    0H                                                  0260
*                PARMOMIT = '1'B;           /* INDICATE PARM OMITTED */
         OI    PARMOMIT,B'00000100'                                0260
*                IF DYNKEY = DALDSNAM ×     /* IF KEY FOR            */
*                   DYNKEY = DUNDSNAM ×     /* DSNAME,               */
*                   DYNKEY = DINDSNAM THEN  /* THEN                  */
         LA    @02,2                                               0261
         L     @01,B                                               0261
         LH    @15,DYNKEY(,@01)                                    0261
         CR    @15,@02                                             0261
         BE    @RT00261                                            0261
         CR    @15,@02                                             0261
         BE    @RT00261                                            0261
         CR    @15,@02                                             0261
         BNE   @RF00261                                            0261
@RT00261 DS    0H                                                  0262
*                   DO;                                            0262
*                     ADDRLIST(I) = 0;      /* SET ADDRLIST TO 0     */
         SR    @02,@02                                             0263
         L     @15,ADDRPTR                                         0263
         LR    @14,I                                               0263
         SLA   @14,2                                               0263
         ST    @02,ADDRLIST-4(@14,@15)                             0263
*                     I = I+1;              /* INCREMENT SUBSCRIPT   */
         LA    @14,1                                               0264
         AR    I,@14                                               0264
*                     ADDRLIST(I) = 0;      /* SET ADDRLIST TO 0     */
         LR    @09,I                                               0265
         SLA   @09,2                                               0265
         ST    @02,ADDRLIST-4(@09,@15)                             0265
*                     I = I+1;              /* INCREMENT SUBSCRIPT   */
         AR    I,@14                                               0266
*                   END;                                           0267
*                ELSE                       /* ELSE,                 */
*                  DO;                                             0268
         B     @RC00261                                            0268
@RF00261 DS    0H                                                  0269
*                    B = B+2;               /* CHECK ALTERNATE KEY   */
         LA    @02,2                                               0269
         A     @02,B                                               0269
         ST    @02,B                                               0269
*                    IF DYNKEY = DALDSNAM × /* IF DSNAME,            */
*                       DYNKEY = DUNDSNAM ×                        0270
*                       DYNKEY = DINDSNAM THEN                     0270
         LA    @15,2                                               0270
         LH    @02,DYNKEY(,@02)                                    0270
         CR    @02,@15                                             0270
         BE    @RT00270                                            0270
         CR    @02,@15                                             0270
         BE    @RT00270                                            0270
         CR    @02,@15                                             0270
         BNE   @RF00270                                            0270
@RT00270 DS    0H                                                  0271
*                      DO;                  /* THEN                  */
*                        ADDRLIST(I) = 0;   /* SET ADDRLIST TO 0     */
         SR    @02,@02                                             0272
         L     @15,ADDRPTR                                         0272
         LR    @14,I                                               0272
         SLA   @14,2                                               0272
         ST    @02,ADDRLIST-4(@14,@15)                             0272
*                        I = I+1;           /* INCREMENT SUBSCRIPT   */
         LA    @14,1                                               0273
         AR    I,@14                                               0273
*                        ADDRLIST(I) = 0;   /* SET ADDRLIST TO 0     */
         LR    @09,I                                               0274
         SLA   @09,2                                               0274
         ST    @02,ADDRLIST-4(@09,@15)                             0274
*                        I = I+1;           /* INCREMENT SUBSCRIPT   */
         AR    I,@14                                               0275
*                      END;                                        0276
*                  END;                                            0277
*               END;                                               0278
*            GO TO CC;                      /* GET NEXT PARM         */
         B     CC                                                  0279
*          END;                                                    0280
*        ELSE                               /* OTHERWISE,            */
*          DO;                                                     0281
@RF00255 DS    0H                                                  0282
*            IF SUBTRN = '1'B THEN          /* IF IN A SUBFIELD,     */
         TM    SUBTRN,B'00010000'                                  0282
         BNO   @RF00282                                            0282
*              KYFOUND = '1'B;              /* INDICATE KEYWORD FOUND*/
         OI    KYFOUND,B'01000000'                                 0283
*            A = ADDR(LEN);                 /* SET TEXT ADDRESSING   */
@RF00282 L     A,TEXTPTR                                           0284
         LA    A,LEN(,A)                                           0284
*            SAVKEYWD = KYWDNBR;            /* GET THE KEYWORD NUMBER*/
         MVC   SAVKEYWD(2),KYWDNBR(CURPDE)                         0285
*            DO WHILE(SAVKEYWD > 0);        /* INCREMENT THE PCE PTR */
         B     @DE00286                                            0286
@DL00286 DS    0H                                                  0287
*              CURPCE = CURPCE + CMPCELEN;  /* AND DECREMENT KEYWORD */
         AH    CURPCE,CMPCELEN(,CURPCE)                            0287
*              SAVKEYWD = SAVKEYWD - 1;     /* NUMBER UNTIL POINTING */
         LH    @15,SAVKEYWD                                        0288
         BCTR  @15,0                                               0288
         STH   @15,SAVKEYWD                                        0288
*            END;                           /* TO PROPER NAME PCE    */
*                                                                  0289
@DE00286 LH    @15,SAVKEYWD                                        0289
         LTR   @15,@15                                             0289
         BP    @DL00286                                            0289
*            IF CMSUBF = '1'B THEN          /* IF A SUBFIELD WAS     */
         TM    CMSUBF(CURPCE),B'00000100'                          0290
         BNO   @RF00290                                            0290
*              DO;                          /* SPECIFIED, INDICATE   */
*                KEYTRN = '1'B;             /* TO REPEAT DETTYPE     */
*                SUBTRN = '1'B;             /* INDICATE SUBF PROCESS */
         OI    KEYTRN,B'00110000'                                  0293
*                B  = B + 2;                /* GET PROPER KEY        */
         LA    @15,2                                               0294
         L     @14,B                                               0294
         AR    @14,@15                                             0294
         ST    @14,B                                               0294
*                SUBPDEPT= CURPCE + 6 + NAMELEN; /* GET SUB PCE OFFST*/
         LA    SUBPDEPT,6                                          0295
         AR    SUBPDEPT,CURPCE                                     0295
         MVC   @ZT00003+3(1),NAMELEN(CURPCE)                       0295
         A     SUBPDEPT,@ZT00003                                   0295
*                SAVPCE = CURPCE;           /* SAVE CURRENT PCE      */
         ST    CURPCE,SAVPCE                                       0296
*                CURPCE = PCLADS+2+SUBOFST; /* SET UP SUB PCE PTR    */
         A     @15,PCLADS                                          0297
         AH    @15,SUBOFST(,SUBPDEPT)                              0297
         LR    CURPCE,@15                                          0297
*                IF CMTYPE = '010'B THEN    /* IF SUBF PCE KEYWORD,  */
         TM    CMTYPE(CURPCE),B'01000000'                          0298
         BNO   @RF00298                                            0298
         TM    CMTYPE(CURPCE),B'10100000'                          0298
         BNZ   @RF00298                                            0298
*                  DO;                                             0299
*                    SUBFOUND = '1'B;       /* INDICATE SO,          */
         OI    SUBFOUND,B'00100000'                                0300
*                    KEYTRN = '0'B;        /* TURN OFF INDICATOR TO  */
         NI    KEYTRN,B'11011111'                                  0301
*                                          /* REPEAT DETTYPE         */
*                    GO TO AA;             /* GO PROCESS KEYWORD     */
         B     AA                                                  0302
*                  END;                                            0303
*                ELSE                      /* IF OTHER TYPE,         */
*                  GO TO BB;               /* EXIT TO PROCESS        */
*              END;                                                0305
*            ELSE                           /* IF NO SUBFIELD, GO TO */
*              CALL KEYTRNS;                /* TRANSLATE KEYWORD     */
@RF00290 BAL   @14,KEYTRNS                                         0306
*          END;                                                    0307
*                                                                  0307
*    CC: IF SUBTRN = '1'B THEN            /* IF IN A SUBFIELD        */
CC       TM    SUBTRN,B'00010000'                                  0308
         BNO   @RF00308                                            0308
*          DO;                            /* THEN                    */
*            CURPCE = CURPCE + CMPCELEN;  /* GET NEXT PCE            */
         AH    CURPCE,CMPCELEN(,CURPCE)                            0310
*            DO WHILE (CMTYPE = '011'B);  /* IF NAME PCE,            */
         B     @DE00311                                            0311
@DL00311 DS    0H                                                  0312
*              NAMECTR = NAMECTR +1;      /* INCREMENT NAME CTR      */
         LA    @02,1                                               0312
         AH    @02,NAMECTR                                         0312
         STH   @02,NAMECTR                                         0312
*              CURPCE = CURPCE + CMPCELEN;/* GET NEXT PCE            */
         AH    CURPCE,CMPCELEN(,CURPCE)                            0313
*            END;                                                  0314
@DE00311 TM    CMTYPE(CURPCE),B'01100000'                          0314
         BNO   @DC00311                                            0314
         TM    CMTYPE(CURPCE),B'10000000'                          0314
         BZ    @DL00311                                            0314
@DC00311 DS    0H                                                  0315
*            IF CMTYPE = '000'B THEN      /* IF END OF SUBFIELD,     */
         TM    CMTYPE(CURPCE),B'11100000'                          0315
         BNZ   @RF00315                                            0315
*              DO;                        /* THEN, IF KEYWORDS IN    */
*                IF KYFOUND = '0'B & KYNOFND = '1'B THEN           0317
         TM    KYNOFND,B'10000000'                                 0317
         BNO   @RF00317                                            0317
         TM    KYFOUND,B'01000000'                                 0317
         BNZ   @RF00317                                            0317
*                  PARMOMIT = '1'B;       /* THE SUBFIELD NOT ENTERED*/
         OI    PARMOMIT,B'00000100'                                0318
*                                         /* INDICATE PARM OMITTED   */
*                CURPCE = SAVPCE;         /* RESTORE PCE PTR         */
@RF00317 L     CURPCE,SAVPCE                                       0319
*                PCELEN = CMPCELEN;       /* SAVE PCE LENGTH         */
         MVC   PCELEN(2),CMPCELEN(CURPCE)                          0320
*                KEYFIRST = '0'B;         /* TURN OFF INDICATORS     */
*                SUBTRN = '0'B;                                    0322
         NI    KEYFIRST,B'11101110'                                0322
*                KYFOUND = '0'B;                                   0323
*                KYNOFND = '0'B;                                   0324
         NI    KYFOUND,B'00111111'                                 0324
*                NAMECTR = 0;             /* SET NAME COUNTER TO 0   */
         SR    @02,@02                                             0325
         STH   @02,NAMECTR                                         0325
*              END;                                                0326
*            ELSE                         /* IF NOT END OF SUBFIELD, */
*              GO TO AA;                  /* PROCESS NEXT KEYWORD    */
*          END;                                                    0328
*   BB:  END TNKEYWD;                                              0329
*                                                                  0329
@EL00009 DS    0H                                                  0329
@EF00009 DS    0H                                                  0329
@ER00009 LM    @14,@02,@SA00009                                    0329
         LM    @04,@05,@SA00009+20                                 0329
         LM    @08,@12,@SA00009+28                                 0329
         BR    @14                                                 0329
*/********************************************************************/
*/*                                                                  */
*/* SEGMENT NAME -                                                   */
*/*      TNIDENT                                                     */
*/*                                                                  */
*/* FUNCTION -                                                       */
*/*      THIS ROUTINE TRANSLATES AN IDENT OR POSIT PCE (OTHER THAN   */
*/*      DSNAME) TO TEXT FORMAT.                                     */
*/*                                                                  */
*/* OPERATION -                                                      */
*/*      IF THE PARAMETER IS NOT ENTERED, AN INDICATOR IS SET. IF    */
*/*      THE PARAMETER IS ENTERED, THE PCE IS EXAMINED TO DETERMINE  */
*/*      IF THE PARAMETER IS NUMERIC. IF SO, ROUTINES CONVRT AND     */
*/*      NUMLENGH ARE INVOKED TO CONVERT THE PARAMETER TO A BINARY   */
*/*      VALUE AND TO OBTAIN THE PROPER LENGTH FOR THE PARAMETER.    */
*/*      THE TEXT UNIT IS THEN BUILT. IF A LIST IS ALLOWED FOR       */
*/*      THIS PARAMETER, THE ROUTINE LISTTRNS IS INVOKED.            */
*/*                                                                  */
*/* INPUT -                                                          */
*/*      PTR TO POSIT OR IDENT PCE                                   */
*/*      PTR TO PDL                                                  */
*/*      PTR TO TEXT STORAGE                                         */
*/*      PTR TO KEY LIST                                             */
*/*                                                                  */
*/* OUTPUT -                                                         */
*/*      PARMOMIT = 1 - PARAMETER NOT ENTERED                        */
*/*      TEXT FOR IDENT OR POSIT PARAMETER                           */
*/*                                                                  */
*/* NOTE:  THIS ROUTINE REPRESENTS A DIRECT LINE FUNCTION AND CAN    */
*/*        BE INCORPORATED AS AN INCLUDED CODE SEGMENT WHEN THE      */
*/*        INCLUDE FUNCTION HAS RECEIVED A STANDARD DEFINITION.      */
*/********************************************************************/
*    TNIDENT: PROC;                                                0330
TNIDENT  STM   @14,@02,@SA00010                                    0330
         STM   @04,@12,@SA00010+20                                 0330
*        CURPDE = PDLADS + CMPDEOF;    /* SET UP PDE PTR             */
         LH    CURPDE,CMPDEOF(,CURPCE)                             0331
         A     CURPDE,PDLADS                                       0331
*        IF PARMPRES = '0'B THEN       /* IF PARM NOT ENTERED,       */
         TM    PARMPRES(CURPDE),B'10000000'                        0332
         BNZ   @RF00332                                            0332
*          DO;                         /* AND,                       */
*            IF SUBTRN = '1'B THEN     /* WITHIN A SUBFIELD,         */
         TM    SUBTRN,B'00010000'                                  0334
         BNO   @RF00334                                            0334
*              DO;                     /* THEN                       */
*                RTCODE = 4;           /* SET RETURN CODE FOR        */
         MVC   RTCODE(4),@CF00172                                  0336
*                INVPARM = '1'B;       /* INVALID PARAMETERS         */
         OI    INVPARM,B'10000000'                                 0337
*              END;                                                0338
*            PARMOMIT = '1'B;          /* INDICATE NOT ENTERED       */
@RF00334 OI    PARMOMIT,B'00000100'                                0339
*          END;                                                    0340
*        ELSE                                                      0341
*          DO;                         /* OTHERWISE,                 */
         B     @RC00332                                            0341
@RF00332 DS    0H                                                  0342
*            A = ADDR(LEN);                                        0342
         L     @07,TEXTPTR                                         0342
         LA    A,LEN(,@07)                                         0342
*            NUMBER = 1;               /* SET NUMBER IN TEXT TO 1    */
         MVC   NUMBER(2,@07),@CH00081                              0343
*            IF IDFIRST = 2 & IDOTHER = 2 THEN /* IF PARM IS NUMERIC,*/
         CLI   IDFIRST(CURPCE),2                                   0344
         BNE   @RF00344                                            0344
         CLI   IDOTHER(CURPCE),2                                   0344
         BNE   @RF00344                                            0344
*              DO;                                                 0345
*                 CALL CONVRT;         /* CONVERT TO BINARY          */
         BAL   @14,CONVRT                                          0346
*                 CALL NUMLENGH;       /* GET PROPER LENGTH          */
         BAL   @14,NUMLENGH                                        0347
*              END;                                                0348
*            ELSE                                                  0349
*               DO;                    /* IF NON-NUMERIC             */
         B     @RC00344                                            0349
@RF00344 DS    0H                                                  0350
*                 SAVLEN = PARMLEN;    /* SAVE THE LENGTH AND        */
         LH    @07,PARMLEN(,CURPDE)                                0350
         STH   @07,SAVLEN                                          0350
*                 IF SAVLEN < 256 THEN /* PUT INTO BUFFER IF POSSIBLE*/
         CH    @07,@CH00491                                        0351
         BNL   @RF00351                                            0351
*                   ADPARM = ADDR(REALPARM);                       0352
         LA    @07,REALPARM                                        0352
         ST    @07,ADPARM                                          0352
*                 ELSE                 /* OTHERWISE,                 */
*                   DO;                /* GETMAIN FOR NEW BUFFER     */
         B     @RC00351                                            0353
@RF00351 DS    0H                                                  0354
*                     SIZE = PARMLEN;  /* LENGTH, AND                */
         LH    @07,PARMLEN(,CURPDE)                                0354
         ST    @07,@TF00001                                        0354
         MVC   SIZE(3),@TF00001+1                                  0354
*                     SBPOOL = '01'X;  /* SUBPOOL NUMBER             */
         MVI   SBPOOL,X'01'                                        0355
*                     R0 = SPLEN;      /* IN REGISTER 0              */
         L     R0,SPLEN                                            0356
*                     GEN (GETMAIN R,LV=(0));  /* ISSUE GETMAIN      */
         GETMAIN R,LV=(0)
*                     ADPARM = R1;     /* SAVE GOTTEN AREA           */
         ST    R1,ADPARM                                           0358
*                   END;                                           0359
*                  SAVPARM(1:PARMLEN)=VALUE(1:PARMLEN);            0360
@RC00351 L     @07,ADPARM                                          0360
         LH    @15,PARMLEN(,CURPDE)                                0360
         BCTR  @15,0                                               0360
         L     @01,PARMPTR(,CURPDE)                                0360
         EX    @15,@SM00562                                        0360
*               END;                                               0361
*                                                                  0361
*             LSTLEN=SAVLEN;           /* MOVE LENGTH INTO TEXT      */
@RC00344 LH    @07,SAVLEN                                          0362
         STH   @07,LSTLEN(,A)                                      0362
*             LSTTEXT(1:SAVLEN) = SAVPARM(1:SAVLEN);/* MOVE PARAMETER
*                                                      INTO TEXT     */
         LR    @15,@07                                             0363
         BCTR  @15,0                                               0363
         L     @01,ADPARM                                          0363
         EX    @15,@SM00564                                        0363
*             A = A + 2 + SAVLEN;                                  0364
         LA    @15,2                                               0364
         AR    @15,A                                               0364
         AR    @15,@07                                             0364
         LR    A,@15                                               0364
*              IF CMLIST = '1'B THEN   /* IF LIST OPTION SPECIFIED,  */
         TM    CMLIST(CURPCE),B'10000000'                          0365
         BNO   @RF00365                                            0365
*                CALL LISTTRNS;        /* GO TO PROCESS LIST         */
         BAL   @14,LISTTRNS                                        0366
*          END;                                                    0367
*END TNIDENT;                                                      0368
@EL00010 DS    0H                                                  0368
@EF00010 DS    0H                                                  0368
@ER00010 LM    @14,@02,@SA00010                                    0368
         LM    @04,@12,@SA00010+20                                 0368
         BR    @14                                                 0368
*/********************************************************************/
*/*                                                                  */
*/* SEGMENT NAME -                                                   */
*/*      DSNTRANS                                                    */
*/*                                                                  */
*/* FUNCTION -                                                       */
*/*      THIS ROUTINE TRANSLATES A DSNAME PARAMETER TO TEXT FORMAT.  */
*/*                                                                  */
*/* OPERATION -                                                      */
*/*      AN INDICATOR IS SET TO SHOW DSNAME PROCESSING. A POINTER TO */
*/*      THE CORRESPONDING PDE IS SET UP. IF A LIST OF DSNAMES WAS   */
*/*      ENTERED, ROUTINE DSNLIST IS INVOKED. OTHERWISE, ROUTINES    */
*/*      DSNSNGLE, MBRSNGLE AND PSWSNGLE ARE INVOKED.                */
*/*                                                                  */
*/* INPUT -                                                          */
*/*      PTR TO DSNAME PCE                                           */
*/*      PTR TO PDL                                                  */
*/*      PTR TO KEY LIST                                             */
*/*      PTR TO TEXT STORAGE                                         */
*/*      PTR TO ADDRESS LIST                                         */
*/*                                                                  */
*/* OUTPUT -                                                         */
*/*      PTR TO TEXT UNIT FOR DSNAME                                 */
*/*                                                                  */
*/* NOTE:  THIS ROUTINE REPRESENTS A DIRECT LINE FUNCTION AND CAN    */
*/*        BE INCORPORATED AS AN INCLUDED CODE SEGMENT WHEN THE      */
*/*        INCLUDE FUNCTION HAS RECEIVED A STANDARD DEFINITION.      */
*/********************************************************************/
*    DSNTRANS: PROC;                                               0369
DSNTRANS STM   @14,@02,@SA00011                                    0369
         STM   @04,@06,@SA00011+20                                 0369
         STM   @08,@12,@SA00011+32                                 0369
*        IF FAIL = 0 THEN                   /* ERROR FOUND ?         */
         CLI   FAIL,0                                              0370
         BNE   @RF00370                                            0370
*          DO;                              /* NO -                  */
*            DSNPROC = '1'B;                /* SET DSN INDICATOR     */
         OI    DSNPROC,B'00001000'                                 0372
*            CURPDE = PDLADS + CMPDEOF;     /* SET UP PDE POINTER    */
         LH    CURPDE,CMPDEOF(,CURPCE)                             0373
         A     CURPDE,PDLADS                                       0373
*            IF SUBTRN = '1'B THEN          /* IF WITHIN A SUBFIELD  */
         TM    SUBTRN,B'00010000'                                  0374
         BNO   @RF00374                                            0374
*              DO;                          /* AND                   */
*                IF PARMPRES = '0'B &       /* DSNAME NOT ENTERED,   */
*                   MBRPRES = '0'B &        /* NOR MEMBER NAME,      */
*                   PASSPRES = '0'B THEN    /* NOR PASSWORD,         */
         TM    PARMPRES(CURPDE),B'10000000'                        0376
         BNZ   @RF00376                                            0376
         TM    MBRPRES(CURPDE),B'10000000'                         0376
         BNZ   @RF00376                                            0376
         TM    PASSPRES(CURPDE),B'10000000'                        0376
         BNZ   @RF00376                                            0376
*                  DO;                      /* THEN                  */
*                    RTCODE = 4;            /* SET RETURN CODE FOR   */
         MVC   RTCODE(4),@CF00172                                  0378
*                    INVPARM = '1'B;        /* INVALID PARAMETERS    */
         OI    INVPARM,B'10000000'                                 0379
*                    PARMOMIT = '1'B;       /* PARM NOT ENTERED      */
         OI    PARMOMIT,B'00000100'                                0380
*                  END;                                            0381
*              END;                                                0382
@RF00376 DS    0H                                                  0383
*            IF CMLIST = '1'B &             /* IF LIST POSSIBLE      */
*               DSNNEXT ^= PDECMPRE THEN    /* AND LIST ENTERED,     */
@RF00374 TM    CMLIST(CURPCE),B'10000000'                          0383
         BNO   @RF00383                                            0383
         CLC   DSNNEXT(4,CURPDE),PDECMPRE                          0383
         BE    @RF00383                                            0383
*               CALL DSNLIST;               /* THEN PROCESS LIST     */
         BAL   @14,DSNLIST                                         0384
*            ELSE                                                  0385
*              DO;                          /* ELSE,                 */
         B     @RC00383                                            0385
@RF00383 DS    0H                                                  0386
*                CALL DSNSNGLE;             /* PROCESS DSNAME        */
         BAL   @14,DSNSNGLE                                        0386
*                CALL MBRSNGLE;             /* PROCESS MEMBER NAME   */
         BAL   @14,MBRSNGLE                                        0387
*                CALL PSWSNGLE;             /* PROCESS PASSWORD      */
         BAL   @14,PSWSNGLE                                        0388
*              END;                                                0389
*          END;                                                    0390
*                                                                  0390
*END DSNTRANS;                                                     0391
@EL00011 DS    0H                                                  0391
@EF00011 DS    0H                                                  0391
@ER00011 LM    @14,@02,@SA00011                                    0391
         LM    @04,@06,@SA00011+20                                 0391
         LM    @08,@12,@SA00011+32                                 0391
         BR    @14                                                 0391
*/********************************************************************/
*/*                                                                  */
*/* SEGMENT NAME -                                                   */
*/*      KEYTRNS                                                     */
*/*                                                                  */
*/* FUNCTION -                                                       */
*/*      THIS ROUTINE TRANSLATES TO TEXT FORMAT A KEYWORD WHICH HAS  */
*/*      NO SUBFIELD.                                                */
*/*                                                                  */
*/* OPERATION -                                                      */
*/*      A SEARCH IS MADE OF THE KEYWORD TABLE FOR A KEY THAT        */
*/*      MATCHES THE CURRENT KEY IN THE KEY LIST. IF NO MATCH IS     */
*/*      FOUND, THE RETURN CODE IS SET TO 4 (INVALID PARAMETERS).    */
*/*      IF A MATCH IS FOUND, THEN IF THE NUMBER IN THE KEYWORD PDE  */
*/*      EXCEEDS THE NUMBER IN THE KEYWORD TABLE THE RETURN CODE IS  */
*/*      SET TO 4 (INVALID PARAMETERS). OTHERWISE, THE BIT SETTING   */
*/*      FOR THE KEYWORD IS PICKED UP FROM THE KEYWORD TABLE AND     */
*/*      PUT INTO THE TEXT. IF THE SETTING WAS 0, THEN THE NUMBER    */
*/*      AND LENGTH IN THE TEXT ARE SET TO 0. OTHERWISE, THEY ARE    */
*/*      SET TO 1.                                                   */
*/*                                                                  */
*/* INPUT -                                                          */
*/*      PTR TO KEYWORD PDE                                          */
*/*      PTR TO KEY LIST                                             */
*/*      PTR TO KEYWORD TABLE                                        */
*/*      PTR TO TEXT STORAGE                                         */
*/*                                                                  */
*/* OUTPUT -                                                         */
*/*      PTR TO KEYWORD TEXT UNIT                                    */
*/*      RETURN CODE:                                                */
*/*            0 = SUCCESSFUL                                        */
*/*            4 = INVALID PARAMETERS PASSED TO GENTRANS             */
*/*                                                                  */
*/* NOTE:  THIS ROUTINE REPRESENTS A DIRECT LINE FUNCTION AND CAN    */
*/*        BE INCORPORATED AS AN INCLUDED CODE SEGMENT WHEN THE      */
*/*        INCLUDE FUNCTION HAS RECEIVED A STANDARD DEFINITION.      */
*/********************************************************************/
*    KEYTRNS: PROC;                                                0392
KEYTRNS  STM   @14,@02,12(@13)                                     0392
         STM   @04,@12,36(@13)                                     0392
*        IF FAIL = 0 THEN                   /* ERROR FOUND ?         */
         CLI   FAIL,0                                              0393
         BNE   @RF00393                                            0393
*          DO;                              /* NO -                  */
*        IF KEYFIRST = '0'B THEN            /* FIRST TIME THROUGH?   */
         TM    KEYFIRST,B'00000001'                                0395
         BNZ   @RF00395                                            0395
*          DO;                              /* YES -                 */
*            KEYFIRST = '1'B;               /* INDICATE SO           */
         OI    KEYFIRST,B'00000001'                                0397
*            A = ADDR(LEN);                                        0398
         L     A,TEXTPTR                                           0398
         LA    A,LEN(,A)                                           0398
*            LSTTEXT(1) = '00'X;            /* INITIALIZE TEXT AREA  */
         MVI   LSTTEXT(A),X'00'                                    0399
*            Y = GTPLTBLE;                 /* SET PTR TO KEYTABLE   */
         L     @01,GTPLPTR                                         0400
         MVC   Y(4),GTPLTBLE(@01)                                  0400
*            DO WHILE (SEARCH = '0'B);      /*SEARCH FOR MATCHING KEY*/
         B     @DE00401                                            0401
@DL00401 DS    0H                                                  0402
*              IF TABKEY ^= DYNKEY THEN     /* IF NOT MATCHING,      */
         L     @01,Y                                               0402
         MVC   @ZT00002+2(2),TABKEY(@01)                           0402
         L     @15,@ZT00002                                        0402
         L     @14,B                                               0402
         CH    @15,DYNKEY(,@14)                                    0402
         BE    @RF00402                                            0402
*                DO;                        /* AND                   */
*                  IF TABKEY = 'FFFF'X THEN /* END OF TABLE          */
         C     @15,@CF00503                                        0404
         BNE   @RF00404                                            0404
*                    DO;                    /* THEN                  */
*                      SEARCH = '1'B;       /* EXIT FROM DO-WHILE    */
         OI    SEARCH,B'00000010'                                  0406
*                      RTCODE = 4;          /* SET RETURN CODE       */
         MVC   RTCODE(4),@CF00172                                  0407
*                      INVPARM = '1'B;      /* INDICATE ERROR        */
         OI    INVPARM,B'10000000'                                 0408
*                    END;                                          0409
*                  ELSE                     /* IF NOT END OF TABLE,  */
*                    Y = Y + 4 + TABCNT;    /* PT TO NEXT ELEMENT    */
         B     @RC00404                                            0410
@RF00404 L     @15,Y                                               0410
         LA    @14,4                                               0410
         AR    @14,@15                                             0410
         AH    @14,TABCNT(,@15)                                    0410
         ST    @14,Y                                               0410
*                END;                                              0411
*              ELSE                         /* IF KEYS DO MATCH,     */
*                SEARCH = '1'B;             /* EXIT FROM DO-WHILE    */
         B     @RC00402                                            0412
@RF00402 OI    SEARCH,B'00000010'                                  0412
*            END;                                                  0413
@RC00402 DS    0H                                                  0413
@DE00401 TM    SEARCH,B'00000010'                                  0413
         BZ    @DL00401                                            0413
*            SEARCH = '0'B;                 /* RESET INDICATOR       */
         NI    SEARCH,B'11111101'                                  0414
*            IF FAIL=0 THEN                 /* ERROR FOUND IN SEARCH?*/
         CLI   FAIL,0                                              0415
         BNE   @RF00415                                            0415
*              DO;                          /* NO -                  */
*                NAMECTR=NAMECTR+KYWDNBR;   /* INCREMENT NAME CTR    */
         LH    @15,NAMECTR                                         0417
         AH    @15,KYWDNBR(,CURPDE)                                0417
         STH   @15,NAMECTR                                         0417
*                IF NAMECTR > TABCNT THEN   /* IF NUMBER EXCEEDS     */
         L     @02,Y                                               0418
         CH    @15,TABCNT(,@02)                                    0418
         BNH   @RF00418                                            0418
*                  DO;                      /* NUMBER IN TABLE,      */
*                    RTCODE = 4;            /* SET RETURN CODE       */
         MVC   RTCODE(4),@CF00172                                  0420
*                    INVPARM = '1'B;        /* INDICATE ERROR        */
         OI    INVPARM,B'10000000'                                 0421
*                  END;                                            0422
*                ELSE                       /* OTHERWISE,            */
*                  DO;                      /* GET BIT SETTING AND   */
         B     @RC00418                                            0423
@RF00418 DS    0H                                                  0424
*                    BITVALUE = ADDR(TABCNT)+NAMECTR+1;            0424
         L     BITVALUE,Y                                          0424
         LA    BITVALUE,TABCNT(,BITVALUE)                          0424
         AH    BITVALUE,NAMECTR                                    0424
         AH    BITVALUE,@CH00081                                   0424
*                    LSTTEXT(1)=LSTTEXT(1)×SETTING;/* PUT INTO TEXT  */
         OC    LSTTEXT(1,A),SETTING(BITVALUE)                      0425
*                    IF SETTING = 0 THEN    /* IF BIT SETTING IS 0   */
         CLI   SETTING(BITVALUE),0                                 0426
         BNE   @RF00426                                            0426
*                      DO;                  /* THEN                  */
*                        LSTLEN = 0;        /* LENGTH AND            */
         SR    @02,@02                                             0428
         STH   @02,LSTLEN(,A)                                      0428
*                        NUMBER = 0;        /* NUMBER ARE 0.         */
         L     @01,TEXTPTR                                         0429
         STH   @02,NUMBER(,@01)                                    0429
*                      END;                                        0430
*                    ELSE                   /* OTHERWISE,            */
*                      DO;                                         0431
         B     @RC00426                                            0431
@RF00426 DS    0H                                                  0432
*                        LSTLEN = 1;        /* LENGTH AND            */
         LA    @02,1                                               0432
         STH   @02,LSTLEN(,A)                                      0432
*                        NUMBER = 1;        /* NUMBER ARE 1          */
         L     @01,TEXTPTR                                         0433
         STH   @02,NUMBER(,@01)                                    0433
*                      END;                                        0434
*                    A = A+3;               /* INCREMENT TEXT PTR    */
@RC00426 AH    A,@CH00119                                          0435
*                  END;                                            0436
*              END;                                                0437
*            END;                                                  0438
*           ELSE                           /* IF OTHER THAN FIRST    */
*             DO;                          /* TIME THROUGH,          */
         B     @RC00395                                            0439
@RF00395 DS    0H                                                  0440
*              NAMECTR = NAMECTR+KYWDNBR;  /* INCREMENT NAME CTR     */
         LH    @15,NAMECTR                                         0440
         AH    @15,KYWDNBR(,CURPDE)                                0440
         STH   @15,NAMECTR                                         0440
*              IF NAMECTR > TABCNT THEN    /* IF NUMBER EXCEEDS      */
         L     @02,Y                                               0441
         CH    @15,TABCNT(,@02)                                    0441
         BNH   @RF00441                                            0441
*                DO;                       /* NUMBER IN TABLE,       */
*                  RTCODE = 4;             /* SET RETURN CODE FOR    */
         MVC   RTCODE(4),@CF00172                                  0443
*                  INVPARM = '1'B;         /* INVALID PARAMETERS     */
         OI    INVPARM,B'10000000'                                 0444
*                END;                                              0445
*              ELSE                        /* OTHERWISE,             */
*                DO;                       /* PUT BIT SETTING IN TEXT*/
         B     @RC00441                                            0446
@RF00441 DS    0H                                                  0447
*                  BITVALUE = ADDR(TABCNT) + NAMECTR+1;            0447
         L     BITVALUE,Y                                          0447
         LA    BITVALUE,TABCNT(,BITVALUE)                          0447
         AH    BITVALUE,NAMECTR                                    0447
         AH    BITVALUE,@CH00081                                   0447
*                  LSTTEXT(1) = LSTTEXT(1) × SETTING;              0448
         OC    LSTTEXT(1,A),SETTING(BITVALUE)                      0448
*                  A = A+3;                /* INCREMENT TEXT PTR     */
         AH    A,@CH00119                                          0449
*                END;                                              0450
*            END;                                                  0451
*          END;                                                    0452
*END KEYTRNS;                                                      0453
@EL00012 DS    0H                                                  0453
@EF00012 DS    0H                                                  0453
@ER00012 LM    @14,@02,12(@13)                                     0453
         LM    @04,@12,36(@13)                                     0453
         BR    @14                                                 0453
*/********************************************************************/
*/*                                                                  */
*/* SEGMENT NAME -                                                   */
*/*      TYPEPROC                                                    */
*/*                                                                  */
*/* FUNCTION -                                                       */
*/*      THIS ROUTINE HANDLES VARIOUS SITUATIONS THAT COULD ARISE    */
*/*      DEPENDING ON THE TYPE OF PARAMETER BEING PASSED.            */
*/*                                                                  */
*/* OPERATION -                                                      */
*/*      IF A KEYWORD WITH A SUBFIELD WAS FOUND, THEN ROUTINE        */
*/*      DETTYPE IS INVOKED. OTHERWISE ROUTINES SUBFPROC AND TSTDSN  */
*/*      ARE INVOKED.                                                */
*/*                                                                  */
*/* INPUT -                                                          */
*/*      KEYTRN = 1 - PROCESSING KEYWORD WITH SUBFIELD               */
*/*      SUBTRN = 1 - PROCESSING SUBFIELD                            */
*/*      DSNPROC = 1 - PROCESSING DSNAME                             */
*/*      PARMOMIT = 1 - PARAMETER NOT ENTERED                        */
*/*      PTR TO KEY LIST                                             */
*/*      PTR TO ADDRESS LIST                                         */
*/*      PTR TO TEXT UNIT                                            */
*/*      PTR TO CURRENT PCE                                          */
*/*                                                                  */
*/* OUTPUT -                                                         */
*/*      PTR TO TEXT OR 0 IN ADDRESS LIST                            */
*/*                                                                  */
*/* NOTE:  THIS ROUTINE REPRESENTS A DIRECT LINE FUNCTION AND CAN    */
*/*        BE INCORPORATED AS AN INCLUDED CODE SEGMENT WHEN THE      */
*/*        INCLUDE FUNCTION HAS RECEIVED A STANDARD DEFINITION.      */
*/********************************************************************/
*    TYPEPROC: PROC;                                               0454
TYPEPROC STM   @14,@02,@SA00013                                    0454
         STM   @04,@05,@SA00013+20                                 0454
         STM   @08,@12,@SA00013+28                                 0454
*        IF FAIL=0 THEN                     /* ERROR FOUND ?         */
         CLI   FAIL,0                                              0455
         BNE   @RF00455                                            0455
*          DO;                              /* NO -                  */
*            IF SUBFOUND = '1'B THEN        /* IF SUBF PCE FOUND     */
         TM    SUBFOUND,B'00100000'                                0457
         BNO   @RF00457                                            0457
*              DO;                          /* THEN                  */
*                SUBFOUND = '0'B;           /* TURN OFF INDICATOR    */
         NI    SUBFOUND,B'11011111'                                0459
*                CALL TSTDSN;               /* GO TO PROCESS TYPE    */
         BAL   @14,TSTDSN                                          0460
*              END;                                                0461
*            ELSE                       /* IF NOT SUBF PCE FOUND,    */
*              DO;                      /* THEN                      */
         B     @RC00457                                            0462
@RF00457 DS    0H                                                  0463
*                IF KEYTRN = '1'B THEN  /* IF KEYWORD WITH SUBFLD    */
         TM    KEYTRN,B'00100000'                                  0463
         BNO   @RF00463                                            0463
*                  DO;                  /* THEN                      */
*                    KEYTRN = '0'B;     /* TURN OFF INDICATOR        */
         NI    KEYTRN,B'11011111'                                  0465
*                    CALL DETTYPE;      /* PROCESS SUBF TYPE         */
         BAL   @14,DETTYPE                                         0466
*                  END;                                            0467
*                CALL SUBFPROC;         /* PROCESSING FOR SUBFIELD   */
@RF00463 BAL   @14,SUBFPROC                                        0468
*                CALL TSTDSN;           /* PROCESSING FOR DSNAME     */
         BAL   @14,TSTDSN                                          0469
*              END;                                                0470
*          END;                                                    0471
*                                                                  0471
*END TYPEPROC;                                                     0472
@EL00013 DS    0H                                                  0472
@EF00013 DS    0H                                                  0472
@ER00013 LM    @14,@02,@SA00013                                    0472
         LM    @04,@05,@SA00013+20                                 0472
         LM    @08,@12,@SA00013+28                                 0472
         BR    @14                                                 0472
*/********************************************************************/
*/*                                                                  */
*/* SEGMENT NAME -                                                   */
*/*      SUBFPROC                                                    */
*/*                                                                  */
*/* FUNCTION -                                                       */
*/*      THIS ROUTINE PERFORMS PROCESSING FOR A SUBFIELD THAT HAS    */
*/*      BEEN TRANSLATED.                                            */
*/*                                                                  */
*/* OPERATION -                                                      */
*/*      THE PCE POINTER IS INCREMENTED TO THE NEXT PCE AFTER THE    */
*/*      SUBFIELD PCE. IF NAME TYPE, INCREMENT PCE POINTER AGAIN.    */
*/*      IF ENDP OR SUBF TYPE, RESTORE POINTER TO PCE WHICH HAD      */
*/*      THE SUBFIELD. IF ANY OTHER TYPE, INVOKE ROUTINE DETTYPE     */
*/*      TO PROCESS IT.                                              */
*/*                                                                  */
*/* INPUT -                                                          */
*/*      SUBTRN = 1 - PROCESSING SUBFIELD                            */
*/*      PTR TO CURRENT PCE                                          */
*/*                                                                  */
*/* OUTPUT -                                                         */
*/*      PTR TO FORMER PCE (WHEN SUBFIELD WAS FOUND)                 */
*/*                                                                  */
*/* NOTE:  THIS ROUTINE REPRESENTS A DIRECT LINE FUNCTION AND CAN    */
*/*        BE INCORPORATED AS AN INCLUDED CODE SEGMENT WHEN THE      */
*/*        INCLUDE FUNCTION HAS RECEIVED A STANDARD DEFINITION.      */
*/********************************************************************/
*    SUBFPROC: PROC;                                               0473
*                                                                  0473
SUBFPROC STM   @14,@02,@SA00014                                    0473
         STM   @04,@05,@SA00014+20                                 0473
         STM   @08,@12,@SA00014+28                                 0473
*        IF FAIL=0 THEN                     /* ERROR FOUND ?         */
         CLI   FAIL,0                                              0474
         BNE   @RF00474                                            0474
*          DO;                              /* NO -                  */
*            IF SUBTRN = '1'B THEN          /* IN SUBF PROCESSING ?  */
         TM    SUBTRN,B'00010000'                                  0476
         BNO   @RF00476                                            0476
*              DO;                          /* YES -                 */
*                CURPCE=CURPCE+CMPCELEN;    /* GET NEXT PCE          */
         AH    CURPCE,CMPCELEN(,CURPCE)                            0478
*                DO WHILE (CMTYPE='011'B);  /* IF NAME PCE,          */
         B     @DE00479                                            0479
@DL00479 DS    0H                                                  0480
*                  NAMECTR = NAMECTR+1;     /* INCREMENT NAME CTR    */
         LA    @02,1                                               0480
         AH    @02,NAMECTR                                         0480
         STH   @02,NAMECTR                                         0480
*                  CURPCE = CURPCE+CMPCELEN; /* GET NEXT PCE         */
         AH    CURPCE,CMPCELEN(,CURPCE)                            0481
*                END;                       /* REPEAT CHECK FOR NAME */
*                                                                  0482
@DE00479 TM    CMTYPE(CURPCE),B'01100000'                          0482
         BNO   @DC00479                                            0482
         TM    CMTYPE(CURPCE),B'10000000'                          0482
         BZ    @DL00479                                            0482
@DC00479 DS    0H                                                  0483
*                IF CMTYPE = '000'B THEN    /* IF NOT NAME, BUT      */
         TM    CMTYPE(CURPCE),B'11100000'                          0483
         BNZ   @RF00483                                            0483
*                  DO;                      /* ENDP OR SUBF PCE -    */
*                    CURPCE = SAVPCE;       /* RESTORE FORMER PCE    */
         L     CURPCE,SAVPCE                                       0485
*                    PCELEN = CMPCELEN;     /* GET PCE LENGTH        */
         MVC   PCELEN(2),CMPCELEN(CURPCE)                          0486
*                    KEYFIRST = '0'B;       /* RESET KEYWD INDICATOR */
         NI    KEYFIRST,B'11111110'                                0487
*                    NAMECTR = 0;           /* RESET NAME CTR        */
         SR    @02,@02                                             0488
         STH   @02,NAMECTR                                         0488
*                    SUBTRN = '0'B;         /* TURN OFF SUBF INDICATOR*
         NI    SUBTRN,B'11101111'                                  0489
*                  END;                                            0490
*                ELSE                       /* ANY OTHER PCE,        */
*                  CALL DETTYPE;            /* GO TO DETERMINE TYPE  */
         B     @RC00483                                            0491
@RF00483 BAL   @14,DETTYPE                                         0491
*              END;                                                0492
*            ELSE                                                  0493
*              DO;                                                 0493
         B     @RC00476                                            0493
@RF00476 DS    0H                                                  0494
*                KEYFIRST = '0'B;          /* RESET KEYWD INDICATOR  */
         NI    KEYFIRST,B'11111110'                                0494
*                NAMECTR = 0;              /* RESET NAME COUNTER     */
         SR    @02,@02                                             0495
         STH   @02,NAMECTR                                         0495
*              END;                                                0496
*          END;                                                    0497
*END SUBFPROC;                                                     0498
@EL00014 DS    0H                                                  0498
@EF00014 DS    0H                                                  0498
@ER00014 LM    @14,@02,@SA00014                                    0498
         LM    @04,@05,@SA00014+20                                 0498
         LM    @08,@12,@SA00014+28                                 0498
         BR    @14                                                 0498
*/********************************************************************/
*/*                                                                  */
*/* SEGMENT NAME -                                                   */
*/*      TSTDSN                                                      */
*/*                                                                  */
*/* FUNCTION -                                                       */
*/*      THIS ROUTINE PUTS THE KEY INTO THE TEXT UNIT, AND THE       */
*/*      ADDRESS OF THE TEXT UNIT INTO THE ADDRESS LIST, UNLESS      */
*/*      THE PARAMETER TRANSLATED WAS A DSNAME IN WHICH THIS HAS     */
*/*      ALREADY BEEN DONE.                                          */
*/*                                                                  */
*/* OPERATION -                                                      */
*/*      IF A DSNAME WAS NOT TRANSLATED, DETERMINE IF THE PARAMETER  */
*/*      WAS ENTERED. IF SO, PUT THE KEY INTO THE TEXT UNIT FROM     */
*/*      THE KEY LIST, AND PUT THE ADDRESS OF THE TEXT UNIT INTO     */
*/*      THE ADDRESS LIST. OTHERWISE, PUT 0 INTO THE ADDRESS LIST.   */
*/*                                                                  */
*/* INPUT -                                                          */
*/*      DSNPROC = 1 - PROCESSED DSNAME                              */
*/*      PARMOMIT =1 - PARAMETER NOT ENTERED                         */
*/*      PTR TO KEYLIST                                              */
*/*      PTR TO ADDRESS LIST                                         */
*/*      PTR TO TEXT UNIT                                            */
*/*                                                                  */
*/* OUTPUT -                                                         */
*/*      POINTER TO TEXT OR 0 IN ADDRESS LIST                        */
*/*      KEY IN TEXT UNIT                                            */
*/*                                                                  */
*/* NOTE:  THIS ROUTINE REPRESENTS A DIRECT LINE FUNCTION AND CAN    */
*/*        BE INCORPORATED AS AN INCLUDED CODE SEGMENT WHEN THE      */
*/*        INCLUDE FUNCTION HAS RECEIVED A STANDARD DEFINITION.      */
*/********************************************************************/
*    TSTDSN: PROC;                                                 0499
TSTDSN   STM   @14,@12,12(@13)                                     0499
*        IF FAIL = 0 THEN                   /* ERROR FOUND ?         */
         CLI   FAIL,0                                              0500
         BNE   @RF00500                                            0500
*          DO;                              /* NO -                  */
*            IF DSNPROC = '0'B THEN         /* PROCESSING OTHER THAN */
         TM    DSNPROC,B'00001000'                                 0502
         BNZ   @RF00502                                            0502
*              DO;                          /* DSNAME -              */
*                IF PARMOMIT='1'B THEN      /* IF PARM NOT ENTERED,  */
         TM    PARMOMIT,B'00000100'                                0504
         BNO   @RF00504                                            0504
*                  DO;                                             0505
*                    ADDRLIST(I)=0;         /* PUT 0 IN ADDRESS LIST */
         LR    @06,I                                               0506
         SLA   @06,2                                               0506
         SR    @15,@15                                             0506
         L     @14,ADDRPTR                                         0506
         ST    @15,ADDRLIST-4(@06,@14)                             0506
*                    PARMOMIT = '0'B;       /* TURN OFF INDICATOR    */
         NI    PARMOMIT,B'11111011'                                0507
*                  END;                                            0508
*                ELSE                       /* IF PARM ENTERED,      */
*                  DO;                                             0509
         B     @RC00504                                            0509
@RF00504 DS    0H                                                  0510
*                    KEY = DYNKEY;          /* PUT KEY IN TEXT       */
         L     @06,TEXTPTR                                         0510
         L     @01,B                                               0510
         MVC   KEY(2,@06),DYNKEY(@01)                              0510
*                    ADDRLIST(I)=TEXTPTR;   /* PUT ADDRESS INTO LIST */
         LR    @15,I                                               0511
         SLA   @15,2                                               0511
         L     @01,ADDRPTR                                         0511
         ST    @06,ADDRLIST-4(@15,@01)                             0511
*                  END;                                            0512
*              END;                                                0513
*            ELSE                                                  0514
*              DSNPROC = '0'B;             /* TURN OFF DSN INDICATOR */
         B     @RC00502                                            0514
@RF00502 NI    DSNPROC,B'11110111'                                 0514
*          END;                                                    0515
*                                                                  0515
*END TSTDSN;                                                       0516
@EL00015 DS    0H                                                  0516
@EF00015 DS    0H                                                  0516
@ER00015 LM    @14,@12,12(@13)                                     0516
         BR    @14                                                 0516
*/********************************************************************/
*/*                                                                  */
*/* SEGMENT NAME -                                                   */
*/*      DSNSNGLE                                                    */
*/*                                                                  */
*/* FUNCTION -                                                       */
*/*      THIS ROUTINE TRANSLATES TO TEXT FORMAT A DATA SET NAME      */
*/*      WHICH IS NOT ENTERED IN A LIST.                             */
*/*                                                                  */
*/* OPERATION -                                                      */
*/*      IF THE PARAMETER WAS NOT ENTERED, 0 IS PUT INTO THE         */
*/*      ADDRESS LIST. ELSE, SET THE KEY AND INITIALIZE THE NUMBER   */
*/*      IN THE TEXT UNIT. PUT THE ADDRESS OF THIS TEXT UNIT INTO    */
*/*      THE ADDRESS LIST. IF THE DSNAME IS FULLY QUALIFIED, PUT     */
*/*      THE DSNAME LENGTH AND DSNAME INTO THE TEXT UNIT. OTHERWISE  */
*/*      INVOKE ROUTINE PREFIX TO PREFIX USERID TO THE DSNAME.       */
*/*                                                                  */
*/* INPUT -                                                          */
*/*      PTR TO DSNAME PDE                                           */
*/*      PTR TO ADDRESS LIST                                         */
*/*      PTR TO TEXT STORAGE                                         */
*/*                                                                  */
*/* OUTPUT -                                                         */
*/*      PTR TO DSNAME TEXT UNIT                                     */
*/*                                                                  */
*/* NOTE:  THIS ROUTINE REPRESENTS A DIRECT LINE FUNCTION AND CAN    */
*/*        BE INCORPORATED AS AN INCLUDED CODE SEGMENT WHEN THE      */
*/*        INCLUDE FUNCTION HAS RECEIVED A STANDARD DEFINITION.      */
*/********************************************************************/
*    DSNSNGLE: PROC;                                               0517
DSNSNGLE STM   @14,@02,12(@13)                                     0517
         STM   @04,@12,36(@13)                                     0517
*        IF FAIL=0 THEN                     /* ERROR FOUND ?         */
         CLI   FAIL,0                                              0518
         BNE   @RF00518                                            0518
*          DO;                              /* NO -                  */
*            IF PARMPRES = '1'B THEN        /* IF DSNAME ENTERED,    */
         TM    PARMPRES(CURPDE),B'10000000'                        0520
         BNO   @RF00520                                            0520
*              DO;                          /* THEN                  */
*                A = ADDR(LEN);             /* SET UP BUFFER PTR     */
         L     @06,TEXTPTR                                         0522
         LA    A,LEN(,@06)                                         0522
*                KEY = DALDSNAM;            /* PUT KEY IN TEXT       */
         MVC   KEY(2,@06),@CH00216                                 0523
*                NUMBER = 1;                /* SET NUMBER TO 1       */
         MVC   NUMBER(2,@06),@CH00081                              0524
*                ADDRLIST(I) = TEXTPTR;     /* PUT TEXT PTR IN LIST  */
         LR    @15,I                                               0525
         SLA   @15,2                                               0525
         L     @01,ADDRPTR                                         0525
         ST    @06,ADDRLIST-4(@15,@01)                             0525
*                    LSTLEN = PARMLEN;      /* AND DSNAME INTO TEXT  */
         LH    @06,PARMLEN(,CURPDE)                                0526
         STH   @06,LSTLEN(,A)                                      0526
*                    LSTTEXT(1:PARMLEN)=VALUE(1:PARMLEN);          0527
         LR    @15,@06                                             0527
         BCTR  @15,0                                               0527
         L     @01,PARMPTR(,CURPDE)                                0527
         EX    @15,@SM00574                                        0527
*                A = A + 2 + LSTLEN;        /* INCREMENT BUFFER PTR  */
         LA    @15,2                                               0528
         AR    @15,A                                               0528
         AR    @15,@06                                             0528
         LR    A,@15                                               0528
*              END;                                                0529
*           ELSE                            /* IF DSNAME NOT ENTERED,*/
*              ADDRLIST(I) = 0;             /* PUT 0 IN ADDRESS LIST */
         B     @RC00520                                            0530
@RF00520 LR    @06,I                                               0530
         SLA   @06,2                                               0530
         SR    @15,@15                                             0530
         L     @14,ADDRPTR                                         0530
         ST    @15,ADDRLIST-4(@06,@14)                             0530
*          END;                                                    0531
*END DSNSNGLE;                                                     0532
@EL00016 DS    0H                                                  0532
@EF00016 DS    0H                                                  0532
@ER00016 LM    @14,@02,12(@13)                                     0532
         LM    @04,@12,36(@13)                                     0532
         BR    @14                                                 0532
*/********************************************************************/
*/*                                                                  */
*/* SEGMENT NAME -                                                   */
*/*      MBRSNGLE                                                    */
*/*                                                                  */
*/* FUNCTION -                                                       */
*/*      THIS ROUTINE TRANSLATES TO TEXT FORMAT THE MEMBER NAME      */
*/*      PORTION OF THE DSNAME WHEN THE DSNAME IS NOT ENTERED IN     */
*/*      A LIST.                                                     */
*/*                                                                  */
*/* OPERATION -                                                      */
*/*      IF THE PARAMETER WAS NOT ENTERED, 0 IS PUT INTO THE         */
*/*      ADDRESS LIST. ELSE, SET THE KEY AND INITIALIZE THE NUMBER   */
*/*      IN THE TEXT UNIT. PUT THE ADDRESS OF THIS TEXT UNIT INTO    */
*/*      THE ADDRESS LIST. PUT THE MEMBER NAME LENGTH AND THE        */
*/*      MEMEBER NAME INTO THE TEXT UNIT.                            */
*/*                                                                  */
*/* INPUT -                                                          */
*/*      PTR TO DSNAME PDE                                           */
*/*      PTR TO ADDRESS LIST                                         */
*/*      PTR TO TEXT STORAGE                                         */
*/*                                                                  */
*/* OUTPUT -                                                         */
*/*      PTR TO MEMBER NAME TEXT UNIT                                */
*/*                                                                  */
*/* NOTE:  THIS ROUTINE REPRESENTS A DRIECT LINE FUNCTION AND CAN    */
*/*        BE INCORPORATED AS AN INCLUDED CODE SEGMENT WHEN THE      */
*/*        INCLUDE FUNCTION HAS RECEIVED A STANDARD DEFINITION.      */
*/*                                                                  */
*/********************************************************************/
*    MBRSNGLE: PROC;                                               0533
MBRSNGLE STM   @14,@02,12(@13)                                     0533
         STM   @04,@06,36(@13)                                     0533
         STM   @08,@12,52(@13)                                     0533
*        IF FAIL = 0 THEN                   /* ERROR FOUND ?         */
         CLI   FAIL,0                                              0534
         BNE   @RF00534                                            0534
*          DO;                              /* NO -                  */
*            I = I+1;                       /* INCREMENT SUBSCRIPT   */
         LA    @06,1                                               0536
         AR    I,@06                                               0536
*            TEXTPTR = A;                   /* INCREMENT TEXT PTR    */
*                                                                  0537
         ST    A,TEXTPTR                                           0537
*            IF MBRPRES = '1'B THEN         /* IF MEMBER NAME ENTERED*/
         TM    MBRPRES(CURPDE),B'10000000'                         0538
         BNO   @RF00538                                            0538
*              DO;                          /* SET UP BUFFER PTR     */
*                A = ADDR(LEN);                                    0540
         L     @15,TEXTPTR                                         0540
         LA    A,LEN(,@15)                                         0540
*                ADDRLIST(I)=TEXTPTR;       /* PUT TEXT PTR IN LIST  */
         LR    @14,I                                               0541
         SLA   @14,2                                               0541
         L     @01,ADDRPTR                                         0541
         ST    @15,ADDRLIST-4(@14,@01)                             0541
*                KEY = DALMEMBR;            /* PUT KEY IN TEXT       */
         MVC   KEY(2,@15),@CH00218                                 0542
*                NUMBER = 1;                /* SET NUMBER IN TEXT    */
         STH   @06,NUMBER(,@15)                                    0543
*                LSTLEN = MBRLEN;           /* PUT LENGTH AND MEMBER */
         LH    @06,MBRLEN(,CURPDE)                                 0544
         STH   @06,LSTLEN(,A)                                      0544
*                LSTTEXT(1:MBRLEN)=MBRBUF(1:MBRLEN); /* IN TEXT      */
         LR    @15,@06                                             0545
         BCTR  @15,0                                               0545
         L     @01,MBRPTR(,CURPDE)                                 0545
         EX    @15,@SM00576                                        0545
*                A = A + 2 + MBRLEN;        /* INCREMENT BUFFER PTR  */
         LA    @15,2                                               0546
         AR    @15,A                                               0546
         AR    @15,@06                                             0546
         LR    A,@15                                               0546
*              END;                                                0547
*            ELSE                           /* IF MEMBER NOT ENTERED,*/
*              ADDRLIST(I) = 0;             /* PUT 0 IN ADDRESS LIST */
         B     @RC00538                                            0548
@RF00538 LR    @06,I                                               0548
         SLA   @06,2                                               0548
         SR    @15,@15                                             0548
         L     @14,ADDRPTR                                         0548
         ST    @15,ADDRLIST-4(@06,@14)                             0548
*          END;                                                    0549
*END MBRSNGLE;                                                     0550
@EL00017 DS    0H                                                  0550
@EF00017 DS    0H                                                  0550
@ER00017 LM    @14,@02,12(@13)                                     0550
         LM    @04,@06,36(@13)                                     0550
         LM    @08,@12,52(@13)                                     0550
         BR    @14                                                 0550
*/********************************************************************/
*/*                                                                  */
*/* SEGMENT NAME -                                                   */
*/*      PSWSNGLE                                                    */
*/*                                                                  */
*/* FUNCTION -                                                       */
*/*      THIS ROUTINE TRANSLATES TO TEXT FORMAT THE PASSWORD PORTION */
*/*      OF A DSNAME PARAMETER WHEN THE DSNAME IS NOT ENTERED IN A   */
*/*      LIST.                                                       */
*/*                                                                  */
*/* OPERATION -                                                      */
*/*      IF THE PARAMETER WAS NOT ENTERED, 0 IS PUT INTO THE         */
*/*      ADDRESS LIST. ELSE, SET THE KEY AND INITIALIZE THE NUMBER   */
*/*      IN THE TEXT UNIT. PUT THE PASSWORD LENGTH AND PASSWORD      */
*/*      INTO THE TEXT UNIT. PUT THE ADDRESS OF THIS TEXT UNIT       */
*/*      INTO THE ADDRESS LIST.                                      */
*/*                                                                  */
*/* INPUT -                                                          */
*/*      PTR TO DSNAME PDE                                           */
*/*      PTR TO ADDRESS LIST                                         */
*/*      PTR TO TEXT STORAGE                                         */
*/*                                                                  */
*/* OUTPUT -                                                         */
*/*      PTR TO PASSWORD TEXT UNIT                                   */
*/*                                                                  */
*/* NOTE:  THIS ROUTINE REPRESENTS A DIRECT LINE FUNCTION AND CAN    */
*/*        BE INCORPORATED AS AN INCLUDED CODE SEGMENT WHEN THE      */
*/*        INCLUDE FUNCTION HAS RECEIVED A STANDARD DEFINITION.      */
*/********************************************************************/
*    PSWSNGLE: PROC;                                               0551
PSWSNGLE STM   @14,@02,12(@13)                                     0551
         STM   @04,@06,36(@13)                                     0551
         STM   @08,@12,52(@13)                                     0551
*        IF FAIL=0 THEN                     /* ERROR FOUND ?         */
         CLI   FAIL,0                                              0552
         BNE   @RF00552                                            0552
*          DO;                              /* NO -                  */
*            I = I+1;                       /* INCREMENT SUBSCRIPT   */
         LA    @06,1                                               0554
         AR    I,@06                                               0554
*            TEXTPTR = A;                   /* INCREMENT TEXT PTR    */
*                                                                  0555
         ST    A,TEXTPTR                                           0555
*            IF PASSPRES = '1'B THEN        /* IF PASSWORD ENTERED,  */
         TM    PASSPRES(CURPDE),B'10000000'                        0556
         BNO   @RF00556                                            0556
*              DO;                          /* THEN                  */
*                A = ADDR(LEN);             /* SET BUFFER PTR        */
         L     @15,TEXTPTR                                         0558
         LA    A,LEN(,@15)                                         0558
*                ADDRLIST(I)=TEXTPTR;       /* PUT TEXT PTR IN LIST  */
         LR    @14,I                                               0559
         SLA   @14,2                                               0559
         L     @01,ADDRPTR                                         0559
         ST    @15,ADDRLIST-4(@14,@01)                             0559
*                KEY = DALPASSW;            /* PUT KEY IN TEXT       */
         MVC   KEY(2,@15),@CH00372                                 0560
*                NUMBER = 1;                /* PUT NUMBER IN TEXT    */
         STH   @06,NUMBER(,@15)                                    0561
*                LSTLEN = PASSLEN;          /* PUT LENGTH AND PASSWRD*/
         LH    @06,PASSLEN(,CURPDE)                                0562
         STH   @06,LSTLEN(,A)                                      0562
*                LSTTEXT(1:PASSLEN)=PASSBUF(1:PASSLEN); /* IN TEXT */
         LR    @15,@06                                             0563
         BCTR  @15,0                                               0563
         L     @01,PASSPTR(,CURPDE)                                0563
         EX    @15,@SM00578                                        0563
*                A = A + 2 + PASSLEN;       /* INCREMENT BUFFER PTR  */
         LA    @15,2                                               0564
         AR    @15,A                                               0564
         AR    @15,@06                                             0564
         LR    A,@15                                               0564
*              END;                                                0565
*            ELSE                           /* IF PSWORD NOT ENTERED,*/
*              ADDRLIST(I) = 0;             /* PUT 0 IN ADDR LIST    */
         B     @RC00556                                            0566
@RF00556 LR    @06,I                                               0566
         SLA   @06,2                                               0566
         SR    @02,@02                                             0566
         L     @01,ADDRPTR                                         0566
         ST    @02,ADDRLIST-4(@06,@01)                             0566
*          END;                                                    0567
*                                                                  0567
*END PSWSNGLE;                                                     0568
@EL00018 DS    0H                                                  0568
@EF00018 DS    0H                                                  0568
@ER00018 LM    @14,@02,12(@13)                                     0568
         LM    @04,@06,36(@13)                                     0568
         LM    @08,@12,52(@13)                                     0568
         BR    @14                                                 0568
*/********************************************************************/
*/*                                                                  */
*/* SEGMENT NAME -                                                   */
*/*      DSNLIST                                                     */
*/*                                                                  */
*/* FUNCTION -                                                       */
*/*      THIS ROUTINE TRANSLATES TO TEXT FORMAT A LIST OF DATA       */
*/*      SET NAMES.                                                  */
*/*                                                                  */
*/* OPERATION -                                                      */
*/*      IF NEITHER DSNAME, MEMBER NAME OR PASSWORD ARE ENTERED      */
*/*      THEN AN INDICATOR IS SET TO SHOW THE PARAMETER WAS          */
*/*      OMITTED. OTHERWISE, ROUTINES LISTDSN, LISTMBR AND           */
*/*      LISTPSW ARE INVOKED.                                        */
*/*                                                                  */
*/* INPUT -                                                          */
*/*      PTR TO DSNAME PDE                                           */
*/*      PTR TO ADDRESS LIST                                         */
*/*      PTR TO TEXT STORAGE                                         */
*/*                                                                  */
*/* OUTPUT -                                                         */
*/*      PTRS TO TEXT UNITS FOR DSNAME, MEMBER NAME, AND PASSWORD    */
*/*      PARMOMIT = 1 - PARAMETER NOT ENTERED                        */
*/*                                                                  */
*/* NOTE:  THIS ROUTINE REPRESENTS A DIRECT LINE FUNCTION AND        */
*/*        CAN BE INCORPORATED AS AN INCLUDED CODE SEGMENT WHEN      */
*/*        THE INCLUDE FUNCTION HAS RECEIVED A STANDARD DEFINITION.  */
*/********************************************************************/
*    DSNLIST: PROC;                                                0569
DSNLIST  STM   @14,@02,@SA00019                                    0569
         STM   @04,@06,@SA00019+20                                 0569
         STM   @08,@12,@SA00019+32                                 0569
*        IF FAIL = 0 THEN                   /* ERROR FOUND ?         */
         CLI   FAIL,0                                              0570
         BNE   @RF00570                                            0570
*          DO;                              /* NO -                  */
*            IF PARMPRES ^= '1'B THEN       /* IF DSNAME,            */
         TM    PARMPRES(CURPDE),B'10000000'                        0572
         BO    @RF00572                                            0572
*              DO;                                                 0573
*                IF MBRPRES ^= '1'B THEN    /* MEMBER NAME, OR       */
         TM    MBRPRES(CURPDE),B'10000000'                         0574
         BO    @RF00574                                            0574
*                  DO;                                             0575
*                    IF PASSPRES ^= '1'B THEN/* PASSWORD NOT ENTERED,*/
         TM    PASSPRES(CURPDE),B'10000000'                        0576
         BO    @RF00576                                            0576
*                      PARMOMIT = '1'B;     /* INDICATE PARM OMITTED */
         OI    PARMOMIT,B'00000100'                                0577
*                  END;                                            0578
*              END;                                                0579
*            ELSE                           /* IF PARAMETER WAS      */
*              DO;                          /* ENTERED,              */
         B     @RC00572                                            0580
@RF00572 DS    0H                                                  0581
*                CALL LISTDSN;              /* GO PROCESS DSNAMES    */
         BAL   @14,LISTDSN                                         0581
*                CALL LISTMBR;              /* PROCESS MEMBER NAMES  */
         BAL   @14,LISTMBR                                         0582
*                CALL LISTPSW;              /* PROCESS PASSWORDS     */
         BAL   @14,LISTPSW                                         0583
*              END;                                                0584
*          END;                                                    0585
*                                                                  0585
*END DSNLIST;                                                      0586
@EL00019 DS    0H                                                  0586
@EF00019 DS    0H                                                  0586
@ER00019 LM    @14,@02,@SA00019                                    0586
         LM    @04,@06,@SA00019+20                                 0586
         LM    @08,@12,@SA00019+32                                 0586
         BR    @14                                                 0586
*/********************************************************************/
*/*                                                                  */
*/* SEGMENT NAME -                                                   */
*/*      LISTDSN                                                     */
*/*                                                                  */
*/* FUNCTION -                                                       */
*/*      THIS ROUTINE TRANSLATES TO TEXT FORMAT THE DSNAME PARAMETER */
*/*      WHEN IT HAS BEEN ENTERED IN A LIST.                         */
*/*                                                                  */
*/* OPERATION -                                                      */
*/*      THE FIRST PDE IN THE LIST IS SAVED. THE KEY IS PUT INTO THE */
*/*      TEXT AND THE NUMBER IN THE TEXT IS INITIALIZED TO 1. IF THE */
*/*      DSNAME IS FULLY QUALIFIED, THE DSNAME LENGTH AND DSNAME ARE */
*/*      PUT INTO THE TEXT. OTHERWISE, THE ROUTINE PREFIX IS INVOKED */
*/*      TO PREFIX THE USERID TO THE DSNAME. THE CHAIN POINTER IS    */
*/*      EXAMINED TO DETERMINE IF THIS IS THE LAST ELEMENT IN THE    */
*/*      LIST. IF SO, PUT THE ADDRESS OF THE TEXT INTO THE ADDRESS   */
*/*      LIST AND RETURN TO CALLER. ELSE, POINT TO THE NEXT PDE IN   */
*/*      THE LIST AND INCREMENT THE NUMBER IN THE TEXT BY 1. IF THE  */
*/*      PARAMETER IS NOT FULLY QUALIFIED, INVOKE ROUTINE PREFIX TO  */
*/*      PREFIX THE USERID TO THE DSNAME. IF THE PARAMETER IS FULLY  */
*/*      QUALIFIED, PUT THE LENGTH INTO THE TEXT. IF THE LENGTH IS   */
*/*      NOT 0, PUT THE DSNAME INTO THE TEXT.                        */
*/*      REPEAT THE ABOVE PROCESS UNTIL THE CHAIN POINTER INDICATES  */
*/*      THE END OF THE LIST HAS BEEN REACHED.                       */
*/*                                                                  */
*/* INPUT -                                                          */
*/*      PTR TO DSNAME PDE                                           */
*/*      PTR TO ADDRESS LIST                                         */
*/*      PTR TO TEXT STORAGE                                         */
*/*                                                                  */
*/* OUTPUT -                                                         */
*/*      PTR TO TEXT BUILT FOR DSNAME LIST                           */
*/*                                                                  */
*/* NOTE:  THIS ROUTINE REPRESENTS A DIRECT LINE FUNCTION AND CAN    */
*/*        BE INCORPORATED AS AN INCLUDED CODE SEGMENT WHEN THE      */
*/*        INCLUDE FUNCTION HAS RECEIVED A STANDARD DEFINITION.      */
*/********************************************************************/
*    LISTDSN: PROC;                                                0587
LISTDSN  STM   @14,@02,12(@13)                                     0587
         STM   @04,@06,36(@13)                                     0587
         STM   @08,@12,52(@13)                                     0587
*        IF FAIL = 0 THEN                   /* ERROR FOUND ?         */
         CLI   FAIL,0                                              0588
         BNE   @RF00588                                            0588
*          DO;                              /* NO -                  */
*            FIRSTPDE = CURPDE;             /* SAVE FIRST PDE IN LIST*/
         ST    CURPDE,FIRSTPDE                                     0590
*            A = ADDR(LEN);                 /* SET PTR TO LIST TEST  */
         L     @06,TEXTPTR                                         0591
         LA    A,LEN(,@06)                                         0591
*            KEY = DALDSNAM;                /* SET KEY               */
         MVC   KEY(2,@06),@CH00216                                 0592
*            NUMBER = 1;                    /* INITIALIZE NUMBER TO 1*/
         MVC   NUMBER(2,@06),@CH00081                              0593
*                LSTLEN = PARMLEN;          /* PUT LENGTH IN TEXT    */
         LH    @06,PARMLEN(,CURPDE)                                0594
         STH   @06,LSTLEN(,A)                                      0594
*                IF LSTLEN ^= 0 THEN        /* IF LENGTH NO 0, PUT   */
         LTR   @06,@06                                             0595
         BZ    @RF00595                                            0595
*                  LSTTEXT(1:PARMLEN)=VALUE(1:PARMLEN); /*DSN IN TEXT*/
         BCTR  @06,0                                               0596
         L     @01,PARMPTR(,CURPDE)                                0596
         EX    @06,@SM00574                                        0596
*            A = A + 2 + LSTLEN;            /* INCREMENT TEXT PTR    */
@RF00595 LA    @06,2                                               0597
         AR    @06,A                                               0597
         AH    @06,LSTLEN(,A)                                      0597
         LR    A,@06                                               0597
*            IF FAIL=0 THEN                 /* ERROR FOUND ?         */
         CLI   FAIL,0                                              0598
         BNE   @RF00598                                            0598
*              DO;                          /* NO -                  */
*                DO WHILE (DSNNEXT ^= PDECMPRE);                   0600
         B     @DE00600                                            0600
@DL00600 DS    0H                                                  0601
*                  CURPDE = DSNNEXT;        /* GET NEXT DSNAME PDE   */
         L     CURPDE,DSNNEXT(,CURPDE)                             0601
*                  NUMBER = NUMBER + 1;                            0602
         L     @06,TEXTPTR                                         0602
         LA    @15,1                                               0602
         AH    @15,NUMBER(,@06)                                    0602
         STH   @15,NUMBER(,@06)                                    0602
*                      LSTLEN = PARMLEN;    /* PUT LENGTH IN TEXT    */
         LH    @06,PARMLEN(,CURPDE)                                0603
         STH   @06,LSTLEN(,A)                                      0603
*                      IF LSTLEN ^= 0 THEN  /* IF LENGTH NOT 0, PUT  */
         LTR   @06,@06                                             0604
         BZ    @RF00604                                            0604
*                        LSTTEXT (1:PARMLEN)=VALUE(1:PARMLEN);     0605
         BCTR  @06,0                                               0605
         L     @01,PARMPTR(,CURPDE)                                0605
         EX    @06,@SM00574                                        0605
*                      A = A + 2 + LSTLEN;  /* INCREMENT TEXT PTR    */
@RF00604 LA    @06,2                                               0606
         AR    @06,A                                               0606
         AH    @06,LSTLEN(,A)                                      0606
         LR    A,@06                                               0606
*                END;                                              0607
@DE00600 CLC   DSNNEXT(4,CURPDE),PDECMPRE                          0607
         BNE   @DL00600                                            0607
*                  IF FAIL = 0 THEN         /* ERROR FOUND ?         */
         CLI   FAIL,0                                              0608
         BNE   @RF00608                                            0608
*                    DO;                    /* NO -                  */
*                      ADDRLIST(I) = TEXTPTR; /* PTR TO TEXT IN LIST */
         LR    @06,I                                               0610
         SLA   @06,2                                               0610
         L     @02,TEXTPTR                                         0610
         L     @01,ADDRPTR                                         0610
         ST    @02,ADDRLIST-4(@06,@01)                             0610
*                      I = I+1;             /* INCREMENT SUBSCRIPT   */
         AH    I,@CH00081                                          0611
*                      TEXTPTR = A;         /* INCREMENT TEXT PTR    */
         ST    A,TEXTPTR                                           0612
*                    END;                                          0613
*              END;                                                0614
*          END;                                                    0615
*END LISTDSN;                                                      0616
@EL00020 DS    0H                                                  0616
@EF00020 DS    0H                                                  0616
@ER00020 LM    @14,@02,12(@13)                                     0616
         LM    @04,@06,36(@13)                                     0616
         LM    @08,@12,52(@13)                                     0616
         BR    @14                                                 0616
*/********************************************************************/
*/*                                                                  */
*/* SEGMENT NAME -                                                   */
*/*      LISTMBR                                                     */
*/*                                                                  */
*/* FUNCTION -                                                       */
*/*      THIS ROUTINE TRANSLATES TO TEXT FORMAT THE MEMBER NAME      */
*/*      PORTION OF A DSNAME PARAMETER WHEN THE DSNAME HAS BEEN      */
*/*      ENTERED IN A LIST.                                          */
*/*                                                                  */
*/* OPERATION -                                                      */
*/*      THE PDE POINTER IS SET TO THE FIRST PDE IN THE LIST. THE    */
*/*      KEY IS PUT INTO THE TEXT AND THE NUMBER IN THE TEXT IS      */
*/*      INITIALIZED TO 1. THE MEMBER NAME LENGTH IS PUT INTO THE    */
*/*      TEXT. IF THE LENGTH IS NOT 0, PUT THE MEMBER NAME INTO THE  */
*/*      TEXT. EXAMINE THE CHAIN POINTER TO DETERMINE IF THIS IS     */
*/*      THE LAST ELEMENT IN THE LIST. IF SO, PUT THE ADDRESS OF THE */
*/*      TEXT INTO THE ADDRESS LIST. ELSE, POINT TO THE NEXT PDE IN  */
*/*      THE LIST AND INCREMENT THE NUMBER IN THE TEXT BY 1. THE     */
*/*      MEMBER NAME LENGTH IS PUT INTO THE TEXT. IF THE LENGTH IS   */
*/*      NOT 0, PUT THE MEMBER NAME INTO THE TEXT. REPEAT THE ABOVE  */
*/*      PROCESS UNTIL THE CHAIN POINTER INDICATES THE END OF THE    */
*/*      LIST HAS BEEN REACHED.                                      */
*/*                                                                  */
*/* INPUT -                                                          */
*/*      PTR TO LAST DSNAME PDE IN LIST                              */
*/*      PTR TO ADDRESS LIST                                         */
*/*      PTR TO TEXT STORAGE                                         */
*/*                                                                  */
*/* OUTPUT -                                                         */
*/*      PTR TO TEXT BUILT FOR MEMBER NAME LIST                      */
*/*                                                                  */
*/* NOTE:  THIS ROUTINE REPRESENTS A DIRECT LINE FUNCTION AND CAN    */
*/*        BE INCORPORATED AS AN INCLUDED CODE SEGMENT WHEN THE      */
*/*        INCLUDE FUNCTION HAS RECEIVED A STANDARD DEFINITION.      */
*/********************************************************************/
*    LISTMBR: PROC;                                                0617
LISTMBR  STM   @14,@02,12(@13)                                     0617
         STM   @04,@06,36(@13)                                     0617
         STM   @08,@12,52(@13)                                     0617
*        IF FAIL = 0 THEN                   /* ERROR FOUND ?         */
         CLI   FAIL,0                                              0618
         BNE   @RF00618                                            0618
*          DO;                              /* NO -                  */
*            CURPDE = FIRSTPDE;             /* GET FIRST PDE IN LIST */
         L     CURPDE,FIRSTPDE                                     0620
*            A = ADDR(LEN);                 /* SET UP TEXT PTR       */
         L     @06,TEXTPTR                                         0621
         LA    A,LEN(,@06)                                         0621
*            KEY = DALMEMBR;                /* SET KEY               */
         MVC   KEY(2,@06),@CH00218                                 0622
*            NUMBER = 1;                    /* INITIALIZE NUMBER TO 1*/
         MVC   NUMBER(2,@06),@CH00081                              0623
*            LSTLEN = MBRLEN;               /* PUT LENGTH IN TEXT    */
         LH    @06,MBRLEN(,CURPDE)                                 0624
         STH   @06,LSTLEN(,A)                                      0624
*            IF LSTLEN ^= 0 THEN            /* IF LENGTH NOT 0, PUT  */
         LTR   @06,@06                                             0625
         BZ    @RF00625                                            0625
*              LSTTEXT(1:MBRLEN)=MBRBUF(1:MBRLEN); /* MBR IN TEXT    */
         BCTR  @06,0                                               0626
         L     @01,MBRPTR(,CURPDE)                                 0626
         EX    @06,@SM00576                                        0626
*            A = A + 2 + MBRLEN;            /* INCRMENT TEXT PTR     */
*                                                                  0627
@RF00625 LA    @06,2                                               0627
         AR    @06,A                                               0627
         AH    @06,MBRLEN(,CURPDE)                                 0627
         LR    A,@06                                               0627
*            DO WHILE (DSNNEXT ^= PDECMPRE);                       0628
         B     @DE00628                                            0628
@DL00628 DS    0H                                                  0629
*              NUMBER = NUMBER + 1;         /* INCREMENT TEXT NUMBER */
         L     @06,TEXTPTR                                         0629
         LA    @15,1                                               0629
         AH    @15,NUMBER(,@06)                                    0629
         STH   @15,NUMBER(,@06)                                    0629
*              CURPDE = DSNNEXT;            /* POINT TO NEXT PDE     */
         L     CURPDE,DSNNEXT(,CURPDE)                             0630
*              LSTLEN = MBRLEN;             /* PUT LENGTH IN TEXT    */
         LH    @06,MBRLEN(,CURPDE)                                 0631
         STH   @06,LSTLEN(,A)                                      0631
*              IF LSTLEN ^= 0 THEN          /* IF LENGTH NOT 0, PUT  */
         LTR   @06,@06                                             0632
         BZ    @RF00632                                            0632
*                LSTTEXT(1:MBRLEN) = MBRBUF(1:MBRLEN); /* MBR IN TEXT*/
         BCTR  @06,0                                               0633
         L     @01,MBRPTR(,CURPDE)                                 0633
         EX    @06,@SM00576                                        0633
*              A = A + 2 + MBRLEN;          /* INCREMENT TEXT PTR    */
@RF00632 LA    @06,2                                               0634
         AR    @06,A                                               0634
         AH    @06,MBRLEN(,CURPDE)                                 0634
         LR    A,@06                                               0634
*            END;                           /* LOOP THROUGH DO-WHILE */
*                                                                  0635
@DE00628 CLC   DSNNEXT(4,CURPDE),PDECMPRE                          0635
         BNE   @DL00628                                            0635
*            ADDRLIST(I) = TEXTPTR;         /* PTR TO TEXT IN LIST   */
         LR    @06,I                                               0636
         SLA   @06,2                                               0636
         L     @02,TEXTPTR                                         0636
         L     @01,ADDRPTR                                         0636
         ST    @02,ADDRLIST-4(@06,@01)                             0636
*            I = I+1;                       /* INCREMENT SUBSCRIPT   */
         AH    I,@CH00081                                          0637
*            TEXTPTR = A;                   /* INCREMENT TEXT PTR    */
*                                                                  0638
         ST    A,TEXTPTR                                           0638
*          END;                                                    0639
*                                                                  0639
*END LISTMBR;                                                      0640
@EL00021 DS    0H                                                  0640
@EF00021 DS    0H                                                  0640
@ER00021 LM    @14,@02,12(@13)                                     0640
         LM    @04,@06,36(@13)                                     0640
         LM    @08,@12,52(@13)                                     0640
         BR    @14                                                 0640
*/********************************************************************/
*/*                                                                  */
*/* SEGMENT NAME -                                                   */
*/*      LISTPSW                                                     */
*/*                                                                  */
*/* FUNCTION -                                                       */
*/*      THIS ROUTINE TRANSLATS TO TEXT FORMAT THE PASSWORD PORTION */
*/*      OF A DSNAME PARAMETER WHEN THE DSNAME HAS BEEN ENTERED IN   */
*/*      A LIST.                                                     */
*/*                                                                  */
*/* OPERATION -                                                      */
*/*      THE PDE POINTER IS SET TO THE FIRST PDE IN THE LIST. THE    */
*/*      KEY IS PUT INTO THE TEXT AND THE NUMBER IN THE TEXT IS      */
*/*      INITIALIZED TO 1. THE PASSWORD LENGTH IS PUT INTO THE TEXT. */
*/*      IF THE LENGTH IS NOT 0, PUT THE PASSWORD INTO THE TEXT.     */
*/*      EXAMINE THE CHAIN POINTER TO DETERMINE IF THIS IS LAST      */
*/*      ELEMENT IN THE LIST. IF SO, PUT THE ADDRESS OF THE TEXT     */
*/*      IN THE ADDRESS LIST. ELSE, POINT TO THE NEXT PDE IN THE     */
*/*      LIST AND INCREMENT THE NUMBER IN THE TEXT BY 1. THE         */
*/*      PASSWORD LENGTH IS PUT INTO THE TEXT. IF THE LENGTH IS NOT  */
*/*      0, PUT THE PASSWORD INTO THE TEXT. REPEAT THE ABOVE         */
*/*      PROCESS UNTIL THE CHAIN POINTER INDICATES THE END OF THE    */
*/*      LIST HAS BEEN REACHED.                                      */
*/*                                                                  */
*/* INPUT -                                                          */
*/*      PTR TO LAST DSNAME PDE IN LIST                              */
*/*      PTR TO ADDRESS LIST                                         */
*/*      PTR TO TEXT STORAGE                                         */
*/*                                                                  */
*/* OUTPUT -                                                         */
*/*      PTR TO TEXT BUILT FOR PASSWORD LIST                         */
*/*                                                                  */
*/* NOTE:  THIS ROUTINE REPRESENTS A DIRECT LINE FUNCTION AND CAN    */
*/*        BE INCORPORATED AS AN INCLUDED CODE SEGMENT WHEN THE      */
*/*        INCLUDE FUNCTION HAS RECEIVED A STANDARD DEFINITION.      */
*/********************************************************************/
*    LISTPSW: PROC;                                                0641
LISTPSW  STM   @14,@02,12(@13)                                     0641
         STM   @04,@12,36(@13)                                     0641
*        IF FAIL = 0 THEN                   /* ERROR FOUND ?         */
         CLI   FAIL,0                                              0642
         BNE   @RF00642                                            0642
*          DO;                              /* NO -                  */
*            CURPDE = FIRSTPDE;             /* GET FIRST PDE IN LIST */
         L     CURPDE,FIRSTPDE                                     0644
*            A = ADDR(LEN);                 /* SET UP TEXT PTR       */
         L     @06,TEXTPTR                                         0645
         LA    A,LEN(,@06)                                         0645
*            KEY = DALPASSW;                /* SET KEY               */
         MVC   KEY(2,@06),@CH00372                                 0646
*            NUMBER = 1;                    /* INITIALIZE NUMBER TO 1*/
         MVC   NUMBER(2,@06),@CH00081                              0647
*            LSTLEN = PASSLEN;              /* PUT LENGTH IN TEXT    */
         LH    @06,PASSLEN(,CURPDE)                                0648
         STH   @06,LSTLEN(,A)                                      0648
*            IF LSTLEN ^= 0 THEN            /* IF LENGTH NOT 0,PUT  */
         LTR   @06,@06                                             0649
         BZ    @RF00649                                            0649
*              LSTTEXT(1:PASSLEN) = PASSBUF(1:PASSLEN);/*PSWD IN TEXT*/
         BCTR  @06,0                                               0650
         L     @01,PASSPTR(,CURPDE)                                0650
         EX    @06,@SM00578                                        0650
*            A = A + 2 + PASSLEN;           /* INCREMENT TEXT PTR    */
*                                                                  0651
@RF00649 LA    @06,2                                               0651
         AR    @06,A                                               0651
         AH    @06,PASSLEN(,CURPDE)                                0651
         LR    A,@06                                               0651
*            DO WHILE (DSNNEXT ^= PDECMPRE);                       0652
         B     @DE00652                                            0652
@DL00652 DS    0H                                                  0653
*              NUMBER = NUMBER + 1;         /* INCREMENT TEXT NUMBER */
         L     @06,TEXTPTR                                         0653
         LA    @15,1                                               0653
         AH    @15,NUMBER(,@06)                                    0653
         STH   @15,NUMBER(,@06)                                    0653
*              CURPDE = DSNNEXT;            /* GET NEXT PDE IN LIST  */
         L     CURPDE,DSNNEXT(,CURPDE)                             0654
*              LSTLEN = PASSLEN;            /* PUT LENGTH IN TEXT    */
         LH    @06,PASSLEN(,CURPDE)                                0655
         STH   @06,LSTLEN(,A)                                      0655
*              IF LSTLEN ^= 0 THEN          /* IF LENGTH NOT 0,PUT   */
         LTR   @06,@06                                             0656
         BZ    @RF00656                                            0656
*                LSTTEXT(1:PASSLEN) = PASSBUF(1:PASSLEN);/* PSWD IN  */
         BCTR  @06,0                                               0657
         L     @01,PASSPTR(,CURPDE)                                0657
         EX    @06,@SM00578                                        0657
*              A = A + 2 + PASSLEN;         /* INCREMENT TEXT PTR    */
@RF00656 LA    @06,2                                               0658
         AR    @06,A                                               0658
         AH    @06,PASSLEN(,CURPDE)                                0658
         LR    A,@06                                               0658
*            END;                           /* LOOP THROUGH DO-WHILE */
*                                                                  0659
@DE00652 CLC   DSNNEXT(4,CURPDE),PDECMPRE                          0659
         BNE   @DL00652                                            0659
*            ADDRLIST(I) = TEXTPTR;         /* TEXT PTR IN LIST      */
         LR    @06,I                                               0660
         SLA   @06,2                                               0660
         L     @02,TEXTPTR                                         0660
         L     @01,ADDRPTR                                         0660
         ST    @02,ADDRLIST-4(@06,@01)                             0660
*            TEXTPTR = A;                   /* INCREMENT TEXT PTR    */
*                                                                  0661
         ST    A,TEXTPTR                                           0661
*          END;                                                    0662
*                                                                  0662
*END LISTPSW;                                                      0663
@EL00022 DS    0H                                                  0663
@EF00022 DS    0H                                                  0663
@ER00022 LM    @14,@02,12(@13)                                     0663
         LM    @04,@12,36(@13)                                     0663
         BR    @14                                                 0663
*/********************************************************************/
*/*                                                                  */
*/* SEGMENT NAME -                                                   */
*/*      LISTTRNS                                                    */
*/*                                                                  */
*/* FUNCTION -                                                       */
*/*      THIS ROUTINE TRANSLATS TO TEXT FORMAT A LIST OF IDENT OR    */
*/*      POSIT PARAMETERS (OTHER THAN DSNAME).                       */
*/*                                                                  */
*/* OPERATION -                                                      */
*/*      IF THIS IS LAST ELEMENT IN LIST, RETURN TO CALLER. ELSE,    */
*/*      POINT TO NEXT PDE IN LIST AND INCREMENT THE NUMBER IN THE   */
*/*      TEXT BY 1. IF THE PARAMETER IS NUMERIC, INVOKE ROUTINES     */
*/*      CONVRT AND NUMLENGH TO CONVERT THE VALUE TO BINARY. THE     */
*/*      LENGTH AND THE PARAMETER ARE PUT INTO THE TEXT. REPEAT THE  */
*/*      ABOVE PROCESS UNTIL THE END OF THE LIST IS REACHED.         */
*/*                                                                  */
*/* INPUT -                                                          */
*/*      PTR TO POSIT OR IDENT PCE                                   */
*/*      PTR TO PDL                                                  */
*/*      PTR TO TEXT STORAGE                                         */
*/*                                                                  */
*/* OUTPUT -                                                         */
*/*      PTR TO TEXT FOR POSIT OR IDENT PARAMETER LIST.              */
*/*                                                                  */
*/* NOTE:  THIS ROUTINE REPRESENTS A DIRECT LINE FUNCTION AND CAN    */
*/*        BE INCORPORATED AS AN INCLUDED CODE SEGMENT WHEN THE      */
*/*        INCLUDE FUNCTION HAS RECEIVED A STANDARD DEFINITION.      */
*/********************************************************************/
*    LISTTRNS: PROC;                                               0664
LISTTRNS STM   @14,@02,@SA00023                                    0664
         STM   @04,@12,@SA00023+20                                 0664
*        IF FAIL = 0 THEN                   /* ERROR FOUND ?         */
         CLI   FAIL,0                                              0665
         BNE   @RF00665                                            0665
*          DO;                              /* NO -                  */
*            DO WHILE (NEXTPARM^= PDECMPRE);/* DO TO END OF LIST:    */
         B     @DE00667                                            0667
@DL00667 DS    0H                                                  0668
*              NUMBER = NUMBER + 1;         /* INCREMENT TEXT NUMBER */
         L     @07,TEXTPTR                                         0668
         LA    @15,1                                               0668
         AH    @15,NUMBER(,@07)                                    0668
         STH   @15,NUMBER(,@07)                                    0668
*              CURPDE = NEXTPARM;           /* GET NEXT PDE IN LIST  */
         L     CURPDE,NEXTPARM(,CURPDE)                            0669
*              IF IDFIRST = 2 & IDOTHER=2 THEN                     0670
         CLI   IDFIRST(CURPCE),2                                   0670
         BNE   @RF00670                                            0670
         CLI   IDOTHER(CURPCE),2                                   0670
         BNE   @RF00670                                            0670
*                DO;                                               0671
*                  CALL CONVRT;             /* CONVERT IF NUMERIC    */
         BAL   @14,CONVRT                                          0672
*                  CALL NUMLENGH;           /* DETERMINE LENGTH      */
         BAL   @14,NUMLENGH                                        0673
*                END;                                              0674
*              ELSE                                                0675
*                DO;                        /* IF NON-NUMERIC,       */
         B     @RC00670                                            0675
@RF00670 DS    0H                                                  0676
*                  SAVLEN = PARMLEN;        /* SAVE LENGTH           */
         LH    @07,PARMLEN(,CURPDE)                                0676
         STH   @07,SAVLEN                                          0676
*                  IF SAVLEN <256 THEN      /* IF LESS THAN 255,     */
         CH    @07,@CH00491                                        0677
         BNL   @RF00677                                            0677
*                    ADPARM = ADDR(REALPARM);  /* SET PTR TO BUFFER  */
         LA    @07,REALPARM                                        0678
         ST    @07,ADPARM                                          0678
*                  ELSE                                            0679
*                    DO;                    /* ELSE,                 */
         B     @RC00677                                            0679
@RF00677 DS    0H                                                  0680
*                      SIZE=PARMLEN;        /* LENGTH AND            */
         LH    @07,PARMLEN(,CURPDE)                                0680
         ST    @07,@TF00001                                        0680
         MVC   SIZE(3),@TF00001+1                                  0680
*                      SBPOOL='01'X;        /* SUBPOOL NUMBER        */
         MVI   SBPOOL,X'01'                                        0681
*                      R0=SPLEN;            /* IN REGISTER 0         */
         L     R0,SPLEN                                            0682
*                      GEN(GETMAIN R,LV=(0));  /* GET BUFFER         */
         GETMAIN R,LV=(0)
*                      ADPARM=R1;           /* SET POINTER TO BUFFER */
         ST    R1,ADPARM                                           0684
*                    END;                                          0685
*                  SAVPARM(1:PARMLEN)=VALUE(1:PARMLEN); /* PARAMETER */
@RC00677 L     @07,ADPARM                                          0686
         LH    @15,PARMLEN(,CURPDE)                                0686
         BCTR  @15,0                                               0686
         L     @01,PARMPTR(,CURPDE)                                0686
         EX    @15,@SM00562                                        0686
*                END;                                              0687
*              LSTLEN = SAVLEN;             /* PUT LENGTH AND PARM   */
@RC00670 LH    @07,SAVLEN                                          0688
         STH   @07,LSTLEN(,A)                                      0688
*              LSTTEXT (1:LSTLEN)=SAVPARM(1:LSTLEN); /* INTO TEXT    */
         LR    @15,@07                                             0689
         BCTR  @15,0                                               0689
         L     @01,ADPARM                                          0689
         EX    @15,@SM00564                                        0689
*              A = A + 2 + SAVLEN;          /* INCREMENT TEXT PTR    */
         LA    @15,2                                               0690
         AR    @15,A                                               0690
         AR    @15,@07                                             0690
         LR    A,@15                                               0690
*            END;                                                  0691
@DE00667 CLC   NEXTPARM(4,CURPDE),PDECMPRE                         0691
         BNE   @DL00667                                            0691
*          END;                                                    0692
*                                                                  0692
*END LISTTRNS;                                                     0693
@EL00023 DS    0H                                                  0693
@EF00023 DS    0H                                                  0693
@ER00023 LM    @14,@02,@SA00023                                    0693
         LM    @04,@12,@SA00023+20                                 0693
         BR    @14                                                 0693
*/********************************************************************/
*/*                                                                  */
*/* SEGMENT NAME -                                                   */
*/*      CONVRT                                                      */
*/*                                                                  */
*/* FUNCTION -                                                       */
*/*      THIS ROUTINE CONVERTS A NUMERIC PARAMETER FROM DECIMAL TO   */
*/*      BINARY.                                                     */
*/*                                                                  */
*/* OPERATION -                                                      */
*/*      IF THE LENGTH OF THE PARAMETER IS GREATER THAN 16, SET THE  */
*/*      RETURN CODE TO 4 (INVALID PARAMETERS) AND RETURN TO CALLER. */
*/*      ELSE, PERFORM THE CONVERSION.                               */
*/*                                                                  */
*/* INPUT -                                                          */
*/*      PTR TO PDE                                                  */
*/*                                                                  */
*/* OUTPUT -                                                         */
*/*      VALUE CONVERTED TO BINARY                                   */
*/*                                                                  */
*/* NOTE:  THIS ROUTINE REPRESENTS A DIRECT LINE FUNCTION AND CAN    */
*/*        BE INCORPORATED AS AN INCLUDED CODE SEGMENT WHEN THE      */
*/*        INCLUDE FUNCTION HAS RECEIVED A STANDARD DEFINITION.      */
*/********************************************************************/
*    CONVRT: PROC OPTIONS(DONTSAVE(4));                            0694
CONVRT   STM   @14,@03,@SA00024                                    0694
         STM   @05,@12,@SA00024+24                                 0694
*        RFY CVBREG RSTD;                                          0695
*        IF FAIL = 0 THEN              /* ERROR FOUND ?              */
         CLI   FAIL,0                                              0696
         BNE   @RF00696                                            0696
*          DO;                         /* NO -                       */
*            IF PARMLEN > 9  THEN      /* IF PARM > 16 CHARACTERS,   */
         LH    @05,PARMLEN(,CURPDE)                                0698
         CH    @05,@CH00144                                        0698
         BNH   @RF00698                                            0698
*              DO;                     /* CANNOT BE CONVERTED        */
*                RTCODE = 4;           /* SET RETURN CODE            */
         MVC   RTCODE(4),@CF00172                                  0700
*                INVPARM = '1'B;       /* INDICATE ERROR FOUND       */
         OI    INVPARM,B'10000000'                                 0701
*              END;                                                0702
*            ELSE                      /* IF PARM NOT > 16 THEN      */
*              DO;                     /* CONVERT                    */
         B     @RC00698                                            0703
@RF00698 DS    0H                                                  0704
*                PKAREA(1)='F0'X;      /* CLEAR PACK AREA            */
         MVI   PKAREA,X'F0'                                        0704
*                P = ADDR(PKAREA(1));                              0705
         LA    P,PKAREA                                            0705
*                Q = ADDR(PKAREA(2));                              0706
         LA    Q,PKAREA+1                                          0706
*                Q->AREA1 = P->AREA2;                              0707
         MVC   AREA1(15,Q),AREA2(P)                                0707
*                Y=16-PARMLEN+ADDR(PKAREA);  /* SET UP POINTER       */
         LH    @05,PARMLEN(,CURPDE)                                0708
         LA    @03,16                                              0708
         SR    @03,@05                                             0708
         LA    @15,PKAREA                                          0708
         AR    @03,@15                                             0708
         ST    @03,Y                                               0708
*                PKAREA1(1:PARMLEN) = VALUE(1:PARMLEN);            0709
         BCTR  @05,0                                               0709
         L     @01,PARMPTR(,CURPDE)                                0709
         EX    @05,@SM00580                                        0709
*                                      /* MOVE PARM TO BUFFER        */
*                GENERATE;             /* PACK AND CONVERT TO BINARY */
        PACK  CVBAREA(8),PKAREA(16)
        CVB   CVBREG,CVBAREA
*              END;                                                0711
*          END;                                                    0712
*END CONVRT;                                                       0713
@EL00024 DS    0H                                                  0713
@EF00024 DS    0H                                                  0713
@ER00024 LM    @14,@03,@SA00024                                    0713
         LM    @05,@12,@SA00024+24                                 0713
         BR    @14                                                 0713
*/********************************************************************/
*/*                                                                  */
*/* SEGMENT NAME -                                                   */
*/*      NUMLENGH                                                    */
*/*                                                                  */
*/* FUNCTION -                                                       */
*/*      THIS ROUTINE DETERMINES THE REQUIRED LENGTH FOR A NUMERIC   */
*/*      PARAMETER.                                                  */
*/*                                                                  */
*/* OPERATION -                                                      */
*/*      THE LENGTH TABLE IS SEARCHED FOR A KEY THAT MATCHES THE     */
*/*      KEY FOR THIS NUMERIC PARAMETER. IF A MATCH IS NOT FOUND,    */
*/*      THE RETURN CODE IS SET TO 4 (INVALID PARAMETERS) AND        */
*/*      CONTROL IS RETURNED TO THE CALLER. OF A MATCH IS FOUND,     */
*/*      THE CORRESPONDING LENGTH IS GOTTEN. IF THE PARAMETER VALUE  */
*/*      EXCEEDS THE MAXIMUM ALLOWABLE FOR ITS LENGTH, THEN THE      */
*/*      RETURN CODE IS SET TO 4 (INVALID PARAMETERS). ELSE, THE     */
*/*      PARAMETER VALUE AND LENGTH ARE SAVED TO LATER BE PUT IN     */
*/*      THE TEXT.                                                   */
*/*                                                                  */
*/* INPUT -                                                          */
*/*      PTR TO BINARY VALUE                                         */
*/*      PTR TO KEY LIST                                             */
*/*                                                                  */
*/* OUTPUT -                                                         */
*/*      APPROPRIATE LENGTH AND VALUE                                */
*/*                                                                  */
*/* NOTE:  THIS ROUTINE REPRESENTS A DIRECT LINE FUNCTION AND CAN    */
*/*        BE INCORPORATED AS AN INCLUDED CODE SEGMENT WHEN THE      */
*/*        INCLUDE FUNCTION HAS RECEIVED A STANDARD DEFINITION.      */
*/********************************************************************/
*    NUMLENGH: PROC;                                               0714
NUMLENGH STM   @14,@12,12(@13)                                     0714
*RFY (J,K) RSTD;                                                   0715
*        IF FAIL = 0 THEN                   /* ERROR FOUND ?         */
         CLI   FAIL,0                                              0716
         BNE   @RF00716                                            0716
*          DO;                              /* NO -                  */
*            J = 1;                         /* INITIALIZE SUBSCRIPTS */
         LA    @09,1                                               0718
         LR    J,@09                                               0718
*            K = 1;                         /* FOR LENGTH TABLE      */
*                                                                  0719
         LR    K,@09                                               0719
*            DO WHILE (SEARCH = '0'B);      /* SEARCH LENGTH TABLE   */
         B     @DE00720                                            0720
@DL00720 DS    0H                                                  0721
*              IF LENTABLE(J,K)^=DYNKEY THEN/* IF KEYS DO NOT MATCH  */
         LR    @09,J                                               0721
         AR    @09,@09                                             0721
         AR    @09,K                                               0721
         AR    @09,@09                                             0721
         LA    @01,LENTABLE-6(@09)                                 0721
         L     @09,B                                               0721
         CLC   0(2,@01),DYNKEY(@09)                                0721
         BE    @RF00721                                            0721
*                DO;                        /* THEN                  */
*                  J = J+1;                 /* INCREMENT SUBSCRIPT   */
         AH    J,@CH00081                                          0723
*                  IF LENTABLE(J,K)='00'X THEN   /* IF END OF TABLE  */
         LR    @09,J                                               0724
         AR    @09,@09                                             0724
         AR    @09,K                                               0724
         AR    @09,@09                                             0724
         LH    @09,LENTABLE-6(@09)                                 0724
         LTR   @09,@09                                             0724
         BNZ   @RF00724                                            0724
*                    DO;                    /* THEN                  */
*                      RTCODE = 4;          /* SET RETURN CODE       */
         MVC   RTCODE(4),@CF00172                                  0726
*                      INVPARM = '1'B;      /* INDICATE ERROR FOUND  */
         OI    INVPARM,B'10000000'                                 0727
*                      SEARCH = '1'B;       /* EXIT FROM DO-WHILE    */
         OI    SEARCH,B'00000010'                                  0728
*                    END;                                          0729
*                END;                                              0730
*              ELSE                         /* IF KEYS DO MATCH,     */
*                SEARCH = '1'B;             /* EXIT FROM DO-WHILE    */
         B     @RC00721                                            0731
@RF00721 OI    SEARCH,B'00000010'                                  0731
*            END;                                                  0732
*                                                                  0732
@RC00721 DS    0H                                                  0732
@DE00720 TM    SEARCH,B'00000010'                                  0732
         BZ    @DL00720                                            0732
*            SEARCH = '0'B;                 /* TURN OFF SEARCH BIT   */
         NI    SEARCH,B'11111101'                                  0733
*            IF FAIL = 0 THEN               /* ERROR FOUND IN SEARCH?*/
         CLI   FAIL,0                                              0734
         BNE   @RF00734                                            0734
*              DO;                          /* NO -                  */
*                ADPARM = ADDR(REALPARM);                          0736
         LA    @09,REALPARM                                        0736
         ST    @09,ADPARM                                          0736
*                SAVLEN = LENTABLE(J,2);    /* GET LENGTH FROM TABLE */
         LR    @09,J                                               0737
         SLA   @09,2                                               0737
         LH    @09,LENTABLE-2(@09)                                 0737
         STH   @09,SAVLEN                                          0737
*                TEMPCVB = CVBREG;          /* SAVE CONVERTED VALUE  */
         ST    CVBREG,@TF00001                                     0738
         MVC   TEMPCVB(4),@TF00001                                 0738
*                IF SAVLEN = 3 THEN         /* IF LENGTH IS 3, AND   */
         CH    @09,@CH00119                                        0739
         BNE   @RF00739                                            0739
*                  DO;                      /* IF VALUE EXCEEDS MAX  */
*                    IF TEMPCVB > 16777215 THEN                    0741
         CLC   TEMPCVB(4),@CF00549                                 0741
         BNH   @RF00741                                            0741
*                      DO;                  /* THEN                  */
*                        RTCODE = 4;        /* SET RETURN CODE       */
         MVC   RTCODE(4),@CF00172                                  0743
*                        INVPARM = '1'B;    /* INDICATE ERROR FOUND  */
         OI    INVPARM,B'10000000'                                 0744
*                      END;                                        0745
*                    ELSE                   /* IF VALUE < MAX THEN   */
*                      SAVPARM(1:3) = TEMPCVB(2:4);/* MOVE INTO AREA */
         B     @RC00741                                            0746
@RF00741 L     @09,ADPARM                                          0746
         MVC   SAVPARM(3,@09),TEMPCVB+1                            0746
*                  END;                                            0747
@RC00741 DS    0H                                                  0748
*                IF SAVLEN = 2 THEN         /* IF LENGTH IS 2, AND   */
@RF00739 CLC   SAVLEN(2),@CH00097                                  0748
         BNE   @RF00748                                            0748
*                  DO;                      /* IF VALUE EXCEEDS MAX  */
*                    IF TEMPCVB > 65535 THEN                       0750
         CLC   TEMPCVB(4),@CF00550                                 0750
         BNH   @RF00750                                            0750
*                      DO;                  /* THEN                  */
*                        RTCODE = 4;        /* SET RETURN CODE       */
         MVC   RTCODE(4),@CF00172                                  0752
*                        INVPARM = '1'B;    /* INDICATE ERROR FOUND  */
         OI    INVPARM,B'10000000'                                 0753
*                      END;                                        0754
*                    ELSE                   /* IF VALUE < MAX THEN   */
*                      SAVPARM(1:2) = TEMPCVB(3:4);/* MOVE INTO AREA */
         B     @RC00750                                            0755
@RF00750 L     @09,ADPARM                                          0755
         MVC   SAVPARM(2,@09),TEMPCVB+2                            0755
*                  END;                                            0756
@RC00750 DS    0H                                                  0757
*                IF SAVLEN = 1 THEN         /* IF LENGTH IS 1,       */
@RF00748 CLC   SAVLEN(2),@CH00081                                  0757
         BNE   @RF00757                                            0757
*                  DO;                      /* AND                   */
*                    IF TEMPCVB > 255 THEN  /* VALUE EXCEEDS MAX     */
         CLC   TEMPCVB(4),@CF00195                                 0759
         BNH   @RF00759                                            0759
*                      DO;                  /* THEN                  */
*                        RTCODE = 4;        /* SET RETURN CODE       */
         MVC   RTCODE(4),@CF00172                                  0761
*                        INVPARM = '1'B;    /* INDICATE ERROR FOUND  */
         OI    INVPARM,B'10000000'                                 0762
*                      END;                                        0763
*                    ELSE                   /* IF VALUE < MAX,       */
*                      SAVPARM(1)=TEMPCVB(4);/* MOVE INTO AREA       */
         B     @RC00759                                            0764
@RF00759 L     @09,ADPARM                                          0764
         MVC   SAVPARM(1,@09),TEMPCVB+3                            0764
*                  END;                                            0765
*                                                                  0765
*              END;                                                0766
*          END;                                                    0767
*RFY (J,K,CVBREG) UNRSTD;                                          0768
*END NUMLENGH;                                                     0769
@EL00025 DS    0H                                                  0769
@EF00025 DS    0H                                                  0769
@ER00025 LM    @14,@12,12(@13)                                     0769
         BR    @14                                                 0769
@PB00025 DS    0H                                                  0770
*        GENERATE;                                                 0770
EXTLIST EXTRACT MF=L
EXTEND  EQU *
EXTLEN  DC  A(EXTEND-EXTLIST)
*END IKJCB831                                                      0771
*/* THE FOLLOWING INCLUDE STATEMENTS WERE FOUND IN THIS PROGRAM.      *
*/*%INCLUDE SYSLIB  (IKJZB831)                                        *
*/*%INCLUDE SYSLIB  (IEFZB4D2)                                        *
*;                                                                 0771
@EL00001 L     @13,4(,@13)                                         0771
@EF00001 L     @00,@SIZDATD                                        0771
         LR    @01,@10                                             0771
         FREEMAIN R,LV=(0),A=(1)
@ER00001 LM    @14,@12,12(@13)                                     0771
         BR    @14                                                 0771
@DATA    DS    0H
@CH00081 DC    H'1'
@CH00097 DC    H'2'
@CH00119 DC    H'3'
@CH00140 DC    H'6'
@CH00125 DC    H'7'
@CH00144 DC    H'9'
@CH00463 DC    H'30'
@CH00462 DC    H'42'
@CH00491 DC    H'256'
@CH00216 DC    XL2'0002'
@CH00218 DC    XL2'0003'
@CH00372 DC    XL2'0050'
@SM00562 MVC   SAVPARM(0,@07),VALUE(@01)
@SM00564 MVC   LSTTEXT(0,A),SAVPARM(@01)
@SM00574 MVC   LSTTEXT(0,A),VALUE(@01)
@SM00576 MVC   LSTTEXT(0,A),MBRBUF(@01)
@SM00578 MVC   LSTTEXT(0,A),PASSBUF(@01)
@SM00580 MVC   PKAREA1(0,@03),VALUE(@01)
@DATD    DSECT
         DS    0F
@SA00001 DS    18F
@SA00002 DS    13F
@SA00007 DS    15F
@SA00003 DS    13F
@SA00008 DS    12F
@SA00013 DS    12F
@SA00009 DS    12F
@SA00011 DS    13F
@SA00010 DS    14F
@SA00024 DS    14F
@SA00023 DS    14F
@SA00019 DS    13F
@SA00014 DS    12F
@TF00001 DS    F
@ZTEMPS  DS    0F
@ZT00002 DC    F'0'
@ZT00003 DC    F'0'
@ZTEMPND EQU   *
@ZLEN    EQU   @ZTEMPND-@ZTEMPS
IKJCB831 CSECT
         DS    0F
@CF00172 DC    F'4'
@CH00172 EQU   @CF00172+2
@CF00162 DC    F'8'
@CH00162 EQU   @CF00162+2
@CF00037 DC    F'12'
@CH00037 EQU   @CF00037+2
@CF00195 DC    F'255'
@CF00550 DC    F'65535'
@CF00549 DC    F'16777215'
@CF00503 DC    XL4'FFFF'
@CF00192 DC    XL4'FF000000'
@DATD    DSECT
         DS    0D
B        DS    A
Y        DS    A
GTPLPTR  DS    A
ADDRPTR  DS    A
TEXTPTR  DS    A
PDLADS   DS    A
PCLADS   DS    A
EXTPTR   DS    A
FIRSTPDE DS    A
SAVPCE   DS    A
ADPARM   DS    A
RTCODE   DS    F
EXTOUTA  DS    A
PSCBPTR  DS    A
SAVKEYWD DS    H
PCELEN   DS    H
NAMECTR  DS    H
SAVLEN   DS    H
SWITCH   DS    CL2
         ORG   SWITCH
PCLEND   DS    BL1
SUBSTG   EQU   SWITCH+0
KEYTRN   EQU   SWITCH+0
SUBTRN   EQU   SWITCH+0
DSNPROC  EQU   SWITCH+0
PARMOMIT EQU   SWITCH+0
SEARCH   EQU   SWITCH+0
KEYFIRST EQU   SWITCH+0
KYNOFND  DS    BL1
KYFOUND  EQU   SWITCH+1
SUBFOUND EQU   SWITCH+1
@NM00002 EQU   SWITCH+1
         ORG   SWITCH+2
FAIL     DS    CL1
         ORG   FAIL
INVPARM  DS    BL1
GETFAIL  EQU   FAIL+0
NOSUPT   EQU   FAIL+0
@NM00003 EQU   FAIL+0
         ORG   FAIL+1
PKAREA   DS    CL16
TEMPCVB  DS    CL4
REALPARM DS    CL255
         DS    CL2
SPLEN    DS    CL4
         ORG   SPLEN
SBPOOL   DS    CL1
SIZE     DS    AL3
         ORG   SPLEN+4
         DS    CL4
CVBAREA  DS    CL8
         ORG   *+1-(*-@DATD)/(*-@DATD) INSURE DSECT DATA
@ENDDATD EQU   *
IKJCB831 CSECT
         DS    0F
@SIZDATD DC    AL1(0)
         DC    AL3(@ENDDATD-@DATD)
         DS    0D
@CB00432 DC    X'0000'
         DS    CL2
PDECMPRE DC    X'FF000000'
PATCH    DC    25F'0'
LENTABLE DC    XL2'0009'
         DC    H'3'
         DC    XL2'000A'
         DC    H'3'
         DC    XL2'000B'
         DC    H'3'
         DC    XL2'000C'
         DC    H'3'
         DC    XL2'0012'
         DC    H'2'
         DC    XL2'0013'
         DC    H'1'
         DC    XL2'0016'
         DC    H'1'
         DC    XL2'001B'
         DC    H'3'
         DC    XL2'001D'
         DC    H'1'
         DC    XL2'001F'
         DC    H'2'
         DC    XL2'0023'
         DC    H'2'
         DC    XL2'0030'
         DC    H'2'
         DC    XL2'0031'
         DC    H'1'
         DC    XL2'0032'
         DC    H'2'
         DC    XL2'0033'
         DC    H'1'
         DC    XL2'0034'
         DC    H'1'
         DC    XL2'0036'
         DC    H'1'
         DC    XL2'0037'
         DC    H'1'
         DC    XL2'0038'
         DC    H'2'
         DC    XL2'003E'
         DC    H'1'
         DC    XL2'003F'
         DC    H'1'
         DC    XL2'0040'
         DC    H'1'
         DC    XL2'0041'
         DC    H'3'
         DC    XL2'0042'
         DC    H'2'
         DC    XL2'0044'
         DC    H'1'
         DC    XL2'004A'
         DC    H'1'
         DC    XL2'004B'
         DC    H'1'
         DC    XL2'004C'
         DC    H'2'
         DC    XL2'004E'
         DC    H'1'
         DC    XL2'000F'
         DC    H'2'
         DC    XL2'00'
         DC    H'0'
@00      EQU   00                      EQUATES FOR REGISTERS 0-15
@01      EQU   01
@02      EQU   02
@03      EQU   03
@04      EQU   04
@05      EQU   05
@06      EQU   06
@07      EQU   07
@08      EQU   08
@09      EQU   09
@10      EQU   10
@11      EQU   11
@12      EQU   12
@13      EQU   13
@14      EQU   14
@15      EQU   15
TEXTCTR  EQU   @07
ADDRCTR  EQU   @03
SUBPDEPT EQU   @02
Q        EQU   @06
P        EQU   @03
BITVALUE EQU   @02
KEYLIST  EQU   @02
CURPDE   EQU   @02
CURPCE   EQU   @06
I        EQU   @07
A        EQU   @03
R0       EQU   @00
R1       EQU   @01
CVBREG   EQU   @04
J        EQU   @05
K        EQU   @08
R15      EQU   @15
R10      EQU   @10
R11      EQU   @11
R12      EQU   @12
R13      EQU   @13
R14      EQU   @14
R2       EQU   @02
R3       EQU   @03
R5       EQU   @05
R7       EQU   @07
R9       EQU   @09
GTPL     EQU   0
GTPLPDL  EQU   GTPL
GTPLPCL  EQU   GTPL+4
GTPLKLST EQU   GTPL+8
GTPLTBLE EQU   GTPL+12
GTPLABLK EQU   GTPL+16
GTPLOUTA EQU   GTPL+20
DYNKEY   EQU   0
BITTABLE EQU   0
TABKEY   EQU   BITTABLE
TABCNT   EQU   BITTABLE+2
SETTING  EQU   0
ADDBLOCK EQU   0
ADDBLKNM EQU   ADDBLOCK
ADDBLKPT EQU   ADDBLOCK+4
DYNTEXT  EQU   0
KEY      EQU   DYNTEXT
NUMBER   EQU   DYNTEXT+2
LEN      EQU   DYNTEXT+4
LISTFRMT EQU   0
LSTLEN   EQU   LISTFRMT
LSTTEXT  EQU   LISTFRMT+2
COMNPCE  EQU   0
COMNFLAG EQU   COMNPCE
CMTYPE   EQU   COMNFLAG
CMSUBF   EQU   COMNFLAG
CMLIST   EQU   COMNFLAG+1
CMPCELEN EQU   COMNPCE+2
CMPDEOF  EQU   COMNPCE+4
IDENTPCE EQU   6
IDFIRST  EQU   IDENTPCE+1
IDOTHER  EQU   IDENTPCE+2
NAMELEN  EQU   4
PARMPDE  EQU   0
PARMPTR  EQU   PARMPDE
PARMLEN  EQU   PARMPDE+4
PARMFLAG EQU   PARMPDE+6
PARMPRES EQU   PARMFLAG
NEXTPARM EQU   PARMPDE+8
DSNAMPDE EQU   8
MBRPTR   EQU   DSNAMPDE
MBRLEN   EQU   DSNAMPDE+4
MBRFLAG  EQU   DSNAMPDE+6
MBRPRES  EQU   MBRFLAG
PASSPTR  EQU   DSNAMPDE+8
PASSLEN  EQU   DSNAMPDE+12
PASSFLAG EQU   DSNAMPDE+14
PASSPRES EQU   PASSFLAG
DSNNEXT  EQU   DSNAMPDE+16
KYWDNBR  EQU   0
POSTYPE  EQU   6
VALUE    EQU   0
MBRBUF   EQU   0
PASSBUF  EQU   0
PKAREA1  EQU   0
AREA1    EQU   0
AREA2    EQU   0
LENPCL   EQU   0
SUBOFST  EQU   0
SAVPARM  EQU   0
OUTAREA  EQU   0
SPNSIZE  EQU   OUTAREA
NUMENTRY EQU   OUTAREA+4
ADDRLIST EQU   OUTAREA+8
@NM00015 EQU   ADDRLIST
ADDREND  EQU   @NM00015
EXTCORE  EQU   0
         AGO   .@UNREFD                START UNREFERENCED COMPONENTS
@NM00016 EQU   @NM00015
@NM00014 EQU   OUTAREA+6
@NM00013 EQU   DSNAMPDE+15
@NM00012 EQU   PASSFLAG
@NM00011 EQU   DSNAMPDE+7
@NM00010 EQU   MBRFLAG
@NM00009 EQU   PARMPDE+7
@NM00008 EQU   PARMFLAG
PARMQUOT EQU   PARMFLAG
@NM00007 EQU   IDENTPCE
@NM00006 EQU   COMNFLAG+1
@NM00005 EQU   COMNFLAG
@NM00004 EQU   COMNFLAG
TEXT     EQU   DYNTEXT+6
@NM00001 EQU   ADDBLOCK+2
TABSET   EQU   BITTABLE+4
.@UNREFD ANOP                          END UNREFERENCED COMPONENTS
@RF00104 EQU   @EL00002
@RF00118 EQU   @EL00002
@RC00141 EQU   @EL00003
@RC00139 EQU   @EL00003
@RC00137 EQU   @EL00003
@RC00131 EQU   @EL00003
@RC00129 EQU   @EL00003
@RC00144 EQU   @EL00003
@RF00160 EQU   @EL00004
@RF00168 EQU   @EL00005
@RF00171 EQU   @EL00005
@RF00184 EQU   @EL00006
@RF00187 EQU   @EL00006
@RF00195 EQU   @EL00007
@RF00219 EQU   @EL00007
@RF00231 EQU   @EL00008
@RF00249 EQU   @EL00008
@RC00247 EQU   @EL00008
@RC00241 EQU   @EL00008
@RC00236 EQU   @EL00008
@RC00257 EQU   CC
@RC00261 EQU   CC
@RF00270 EQU   CC
@RF00315 EQU   AA
@RF00308 EQU   @EL00009
BB       EQU   @EL00009
@RC00332 EQU   @EL00010
@RF00365 EQU   @EL00010
@RF00370 EQU   @EL00011
@RC00383 EQU   @EL00011
@RC00404 EQU   @RC00402
@RF00393 EQU   @EL00012
@RC00395 EQU   @EL00012
@RC00441 EQU   @EL00012
@RF00455 EQU   @EL00013
@RC00457 EQU   @EL00013
@RF00474 EQU   @EL00014
@RC00476 EQU   @EL00014
@RF00500 EQU   @EL00015
@RC00502 EQU   @EL00015
@RF00518 EQU   @EL00016
@RC00520 EQU   @EL00016
@RF00534 EQU   @EL00017
@RC00538 EQU   @EL00017
@RF00552 EQU   @EL00018
@RC00556 EQU   @EL00018
@RF00570 EQU   @EL00019
@RC00572 EQU   @EL00019
@RF00588 EQU   @EL00020
@RF00598 EQU   @EL00020
@RF00608 EQU   @EL00020
@RF00618 EQU   @EL00021
@RF00642 EQU   @EL00022
@RF00665 EQU   @EL00023
@RF00696 EQU   @EL00024
@RC00698 EQU   @EL00024
@PB00024 EQU   @PB00025
@RF00724 EQU   @RC00721
@RF00716 EQU   @EL00025
@RF00734 EQU   @EL00025
@RF00757 EQU   @EL00025
@RC00759 EQU   @EL00025
@RC00133 EQU   @RC00131
@RC00243 EQU   @RC00241
@RF00298 EQU   BB
@RF00415 EQU   @RC00395
@RC00418 EQU   @RC00395
@RC00483 EQU   @RC00476
@RC00504 EQU   @RC00502
@RF00574 EQU   @RC00572
@RF00576 EQU   @RC00572
@PB00023 EQU   @PB00024
@PB00022 EQU   @PB00023
@PB00021 EQU   @PB00022
@PB00020 EQU   @PB00021
@PB00019 EQU   @PB00020
@PB00018 EQU   @PB00019
@PB00017 EQU   @PB00018
@PB00016 EQU   @PB00017
@PB00015 EQU   @PB00016
@PB00014 EQU   @PB00015
@PB00013 EQU   @PB00014
@PB00012 EQU   @PB00013
@PB00011 EQU   @PB00012
@PB00010 EQU   @PB00011
@PB00009 EQU   @PB00010
@PB00008 EQU   @PB00009
@PB00007 EQU   @PB00008
@PB00006 EQU   @PB00007
@PB00005 EQU   @PB00006
@PB00004 EQU   @PB00005
@PB00003 EQU   @PB00004
@PB00002 EQU   @PB00003
@ENDDATA EQU   *
         END   IKJCB831
