         TITLE 'IEFVSCAN -- TABLE-DRIVEN SYNTAX SCAN'
*        GENERATE;
        LCLA &T,&SPN
        LCLC &LUPDAT        DEFINE VARIABLE FOR DATE OF LAST MODULE    *
                            UPDATE
&SPN    SETA 0              OBTAIN DSA FROM SUBPOOL 0
&LUPDAT SETC '70226'        DATE OF LAST MODULE UPDATE
VSCN   TITLE 'IEFVSCAN -- TABLE-DRIVEN SYNTAX SCAN -- MODULE PROLOGUE'
* /* START OF SPECIFICATIONS ****
********  MODULE PROLOGUE -- A BRIEF DESCRIPTION OF THE MODULE *******/
* /*******************************************************************/
* /*                                                                 */
* /* STATUS --                                                       */
* /*    RELEASE 20, MODIFICATION LEVEL 01                            */
* /*    A 0-999999                                            S20029 */
* /*    C                                                      21974 */
* /*                                                                 */
* /* FUNCTION --                                                     */
* /*    ROUTINE TO PERFORM A STRICT LEFT-TO-RIGHT SCAN ACROSS A      */
* /*    BUFFER OF ASSEMBLER/JCL FORMAT TEXT, PASSING CONTROL TO AN   */
* /*    INVOKER-SPECIFIED PROCESSOR AS EACH WELL-FORMED KEYWORD OR   */
* /*    POSITIONAL OPERAND IS ENCOUNTERED. RETURN AN ARRAY OF        */
* /*    SUMMARY DATA REGARDING THE SCAN TO THE INVOKER ALONG WITH AN */
* /*    INDICATIVE RETURN CODE.                                      */
* /*                                                                 */
* /* ENTRY POINTS --                                                 */
* /*         IEFVSCAN, IEFVSCN1                                      */
* /*                                                                 */
* /* INPUT --                                                        */
* /*    R1 = ADDRESS OF A TYPE I PARAMETER LIST CONTAINING 5         */
* /*    POINTERS. THE FIRST POINTER MUST CONTAIN THE ADDRESS OF A    */
* /*    STRING DOPE VECTOR DESCRIBING THE BUFFER TO BE SCANNED. THE  */
* /*    SECOND POINTER MUST CONTAIN THE ADDRESS OF AN ARRAY OF       */
* /*    HALFWORD OFFSETS TO OPERAND PROCESSORS. THE THIRD POINTER    */
* /*    MUST CONTAIN THE ADDRESS OF A DESCRIPTION OF THE ADMISSIBLE  */
* /*    SYNTAX FOR THE BUFFER. THE FOURTH POINTER MUST CONTAIN THE   */
* /*    ADDRESS OF AN ARRAY OF HALFWORD INTEGERS TO CONTROL THE SCAN */
* /*    AND PROVIDE FOR A SUMMARY OF IEFVSCAN PROCESSING. THE FIFTH  */
* /*    POINTER MAY CONTAIN ANY VALUE THAT THE INVOKER OF IEFVSCAN   */
* /*    DESIRES; THAT VALUE WILL BE PASSED AS PART OF THE PARAMETER  */
* /*    LIST TO EACH OF THE OPERAND PROCESSORS.                      */
* /*    R13 = THE ADDRESS OF A 72-BYTE SAVE AREA                     */
* /*    R14 = THE ADDRESS TO WHICH CONTROL SHOULD BE PASSED AFTER    */
* /*    IEFVSCAN PROCESSING HAS CONCLUDED                            */
* /*    R15 = THE ADDRESS OF THE IEFVSCAN ENTRY POINT INVOKED        */
* /*                                                                 */
* /* OUTPUT --                                                       */
* /*    R0-R14 = SAME AS ON INPUT                                    */
* /*    R15 = RETURN CODE                                            */
* /*                                                                 */
* /* EXTERNAL REFERENCES --                                          */
* /*         NONE                                                    */
* /*                                                                 */
* /* EXITS, NORMAL --                                                */
* /*         INVOKER                                                 */
* /*                                                                 */
* /* EXITS, ERROR --                                                 */
* /*         INVOKER                                                 */
* /*                                                                 */
* /* TABLE/WORK AREAS --                                             */
* /*         PARAM, SAVEAREA                                         */
* /*                                                                 */
* /* ATTRIBUTES --                                                   */
* /*         REENTRANT, REFRESABLE, LOCATION-INDEPENDENT             */
* /*                                                                 */
* /* NOTES --                                                        */
* /*    SEE THE FOLLOWING SPECIFICATIONS FOR A MORE DETAILED         */
* /*    DESCRIPTION OF THE INPUT, OUTPUT, AND OPERATION OF THIS      */
* /*    MODULE.  THIS MODULE IS CHARACTER DEPENDENT IN THAT THE      */
* /*    TRANSLATE AND TEST TABLE DEPENDS ON THE INTERNAL             */
* /*    CONFIGURATION OF THE EBCDIC CHARACTERS TO FUNCTION           */
* /*    PROPERLY.  REASSEMBLY IS NECESSARY IF A DIFFERENT            */
* /*    CHARACTER SET IS TO BE USED DURING EXECUTION.                */
* /*                                                                 */
* /*******************************************************************/
* /*****  MODULE SPECIFICATIONS -- A MORE DETAILED DESCRIPTION ********
*1MODULE-NAME = IEFVSCAN
*  2PROCESSOR = BSL
**********************************************************************/
* /********************************************************************
***** THE RELEASE FOR WHICH THIS MODULE WAS MOST RECENTLY UPDATED *****
*1STATUS = 20 MODIFICATION LEVEL 00
**********************************************************************/
* /********************************************************************
*1DESCRIPTIVE-NAME = TABLE-DRIVEN SYNTAX SCAN
**********************************************************************/
* /********************************************************************
*1DESCRIPTION = ROUTINE TO PERFORM A STRICT LEFT-TO-RIGHT SCAN       -
*ACROSS A BUFFER OF ASSEMBLER/JCL FORMAT TEXT, PASSING CONTROL TO AN -
*INVOKER-SPECIFIED PROCESSOR AS EACH WELL-FORMED KEYWORD OR          -
*POSITIONAL OPERAND IS ENCOUNTERED. RETURN AN ARRAY OF SUMMARY DATA  -
*REGARDING THE SCAN TO THE INVOKER ALONG WITH AN INDICATIVE RETURN   -
*CODE.
**********************************************************************/
* /********************************************************************
*1ASSUMPTIONS = OS/360 OPERATING ENVIRONMENT
**********************************************************************/
* /********************************************************************
*1PERFORMANCE = CPU-BOUND
**********************************************************************/
* /********************************************************************
*1FUNCTION = SEE DESCRIPTION
**********************************************************************/
* /********************************************************************
*1RESTRICTIONS = NONE
**********************************************************************/
* /********************************************************************
*1MODULE-TYPE = PROCEDURE
**********************************************************************/
* /********************************************************************
*1MODULE-SIZE = 2048 BYTES
**********************************************************************/
* /********************************************************************
*1CODE-ATTRIBUTES = REENTERABLE, RECURSIVE
**********************************************************************/
* /********************************************************************
*1LOAD-ATTRIBUTES = CONTIGUOUS, REFRESHABLE, LOCATION-INDEPENDENT
**********************************************************************/
* /********************************************************************
*1ENTRY-POINT = IEFVSCAN
*  2LINKAGE = ATTACH, CALL, LINK, SYNCH
*  *******************************************************************/
*  /*******************************************************************
*  * THE FOLLOWING DESCRIBES THE REQUIRED INPUT TO THIS ENTRY.
*  * DATA MADE AVAILABLE THROUGH THE STANDARD INVOCATION SEQUENCE
*  * BUT NOT USED IN ANY WAY IS NOT NECESSARILY MENTIONED HERE.
*  2PARAMETER-RECEIVED = POINTER-TO-PARAMETER-LIST
*  2HOW-PASSED = REGISTER 1
*  2NAME-OF-LIST = PARM
*  2LENGTH-OF-LIST = 20 BYTES
*    *****************************************************************/
*    /*****************************************************************
*    3FIELD = PARMBDV
*      4REFERENCE-TYPE = READ
*      4FIELD-DISPLACEMENT = 0 BYTES
*      4TYPE = ADDRESS
*      4ADDRESS-LENGTH = 32 BITS
*      4ADDRESS-OF = BDV
*        5REFERENCE-TYPE = READ
*        5TYPE-ADDRESSED = TABLE
*        5PURPOSE = DESCRIBE THE BUFFER TO BE SCANNED
*        5SCOPE = INTERNAL
*        5TABLE-SIZE = 8 BYTES
*        *************************************************************/
*        /*************************************************************
*        5FIELD = BDVBUF
*          6REFERENCE-TYPE = READ
*          6FIELD-DISPLACEMENT = 0 BYTES
*          6FIELD-TYPE = ADDRESS
*          6ADDRESS-LENGTH = 32 BITS
*          6ADDRESS-OF = BUFFER
*            7REFERENCE-TYPE = READ
*            7TYPE-ADDRESSED = CHARACTER STRING
*            7LENGTH+MODE = VARIABLE
*            7LENGTH-VARIABLE = BDVLEN
*              8LENGTH-VARIABLE-TYPE = ARITHMETIC
*            7STRING-VALUE = THE DATA TO BE SCANNED BEGINNING WITH   -
*            THE FIRST CHARACTER OF THE BUFFER
*        *************************************************************/
*        /*************************************************************
*        5FIELD = BDVMX
*          6REFERENCE-TYPE = READ
*          6FIELD-DISPLACEMENT = 4 BYTES
*          6FIELD-TYPE = ARITHMETIC
*          6MODE = BINARY
*          6LENGTH = 15 BITS
*          6SIGN = SIGNED
*          6SCALING = 0
*          6VALUE = THE NUMBER OF BYTES IN THE DATA BUFFER WHICH     -
*          CONTAINS THE INPUT TO BE SCANNED
*        *************************************************************/
*        /*************************************************************
*        5FIELD = BDVLEN
*          6REFERENCE-TYPE = READ
*          6FIELD-DISPLACEMENT = 6 BYTES
*          6FIELD-TYPE = ARITHMETIC
*          6MODE = BINARY
*          6LENGTH = 15 BITS
*          6SIGN = SIGNED
*          6SCALING = 0
*          6VALUE = THE NUMBER OF BYTES OF TEXT ELIGIBLE TO BE       -
*          SCANNED IN THE BUFFER
*    *****************************************************************/
*    /*****************************************************************
*    3FIELD = PARMPROC
*      4REFERENCE-TYPE = READ
*      4FIELD-DISPLACEMENT = 4 BYTES
*      4TYPE = ADDRESS
*      4ADDRESS-LENGTH = 32 BITS
*      4ADDRESS-OF = PROCCA
*        5REFERENCE-TYPE = READ
*        5TYPE-ADDRESSED = OFFSET
*        5OFFSET-REPLICATION = VARIABLE
*        5TERMINATOR = NOT KNOWN EXPLICITLY BY IEFVSCAN. THE INVOKER -
*        OF IEFVSCAN MUST TAKE THE RESPONSIBILITY TO ASSURE THAT THE -
*        SYNTAX DESCRIPTION REFERENCES ONLY DEFINED ENTRIES IN THIS  -
*        ARRAY.
*        5OFFSET-FROM = PROCCA
*        5OFFSET-LENGTH = 15 BITS
*        5SIGN = SIGNED
*        5OFFSET-SCALING = 0
*        5OFFSET-OF = OPERPROC
*          6TYPE-ADDRESSED = ENTRY
*    *****************************************************************/
*    /*****************************************************************
*    3FIELD = PARMSCAD
*      4REFERENCE-TYPE = READ
*      4FIELD-DISPLACEMENT = 8 BYTES
*      4TYPE = ADDRESS
*      4ADDRESS-LENGTH = 32 BITS
*      4ADDRESS-OF = SCADV
*        5REFERENCE-TYPE = READ
*        5TYPE-ADDRESSED = TABLE
*        5PURPOSE = DESCRIBE A SYNTAX CONTROL ARRAY.
*        5SCOPE = INTERNAL
*        5TABLE-SIZE = 4 BYTES
*        *************************************************************/
*        /*************************************************************
*        5FIELD = SCADVSCA
*          6REFERENCE-TYPE = READ
*          6FIELD-DISPLACEMENT = 0 BYTES
*          6FIELD-TYPE = OFFSET
*          6OFFSET-FROM = SCADV
*          6OFFSET-LENGTH = 15 BITS
*          6SIGN = SIGNED
*          6OFFSET-SCALING = 0
*          6OFFSET-OF = SCA
*            7REFERENCE-TYPE = READ
*            7TYPE-ADDRESSED = TABLE
*            7PURPOSE = DESCRIBE A POSITIONAL CONTROL ARRAY AND A    -
*            SYNTAX CONTROL ARRAY FOR EACH ADMISSIBLE SYNTACTIC      -
*            ENVIRONMENT
*            7SCOPE = INTERNAL
*            7TABLE-REPLICATION = VARIABLE
*            7REPLICATION-COUNT = SCADVMX
*              8COUNT-TYPE = ARITHMETIC
*            7TABLE-SIZE = 8 BYTES
*            *********************************************************/
*            /*********************************************************
*            7FIELD = SCAPD
*              8REFERENCE-TYPE = READ
*              8FIELD-DISPLACEMENT = 0 BYTES
*              8FIELD-TYPE = TABLE
*              8PURPOSE = DEFINE THE POSITIONAL CONTROL ARRAY FOR    -
*              ONE SYNTACTIC ENVIRONMENT
*              8SCOPE = INTERNAL
*              8TABLE-SIZE = 4 BYTES
*              *******************************************************/
*              /*******************************************************
*              8FIELD = SCAPDO
*                9REFERENCE-TYPE = READ
*                9FIELD-DISPLACEMENT = 0 BYTES
*                9FIELD-TYPE = OFFSET
*                9OFFSET-FROM = SCADV
*                9OFFSET-LENGTH = 15 BITS
*                9SIGN = SIGNED
*                9OFFSET-SCALING = 0
*                9OFFSET-OF = PCA
*                 10REFERENCE-TYPE = READ
*                 10TYPE-ADDRESSED = TABLE
*                 10PURPOSE = DEFINE ADMISSIBLE AND INADMISSIBLE     -
*                 POSITIONAL OPERANDS FOR A SYNTACTIC ENVIRONMENT
*                 10SCOPE = INTERNAL
*                 10TABLE-REPLICATION = VARIABLE
*                 10REPLICATION-COUNT = SCAPDMX
*                  11COUNT-TYPE = ARITHMETIC
*                 10TABLE-SIZE = 4 BYTES
*                 ****************************************************/
*                 /****************************************************
*                 10FIELD = PCAPROC
*                  11REFERENCE-TYPE = READ
*                  11FIELD-DISPLACEMENT = 0 BYTES
*                  11FIELD-TYPE = ARITHMETIC
*                  11MODE = BINARY
*                  11LENGTH = 15 BITS
*                  11SIGN = SIGNED
*                  11SCALING = 0
*                  11VALUE = INDEX OF THE PROCCA ENTRY WHICH POINTS  -
*                  TO THE OPERAND PROCESSOR WHICH SHOULD BE INVOKED  -
*                  WHEN THIS POSITIONAL OPERAND IS ENCOUNTERED IN    -
*                  THE SPECIFIED SYNTACTIC ENVIRONMENT
*                 ****************************************************/
*                 /****************************************************
*                 10FIELD = PCASNO
*                  11REFERENCE-TYPE = READ
*                  11FIELD-DISPLACEMENT = 2 BYTES
*                  11FIELD-TYPE = ARITHMETIC
*                  11MODE = BINARY
*                  11LENGTH = 15 BITS
*                  11SIGN = SIGNED
*                  11SCALING = 0
*                  11VALUE = INDEX OF THE SCA ENTRY WHICH DEFINES    -
*                  THE SYNTAX FOR THE SUBFIELD OF THE POSITIONAL     -
*                  OPERAND
*              *******************************************************/
*              /*******************************************************
*              8FIELD = SCAPDMX
*                9REFERENCE-TYPE = READ
*                9FIELD-DISPLACEMENT = 2 BYTES
*                9FIELD-TYPE = ARITHMETIC
*                9MODE = BINARY
*                9LENGTH = 15 BITS
*                9SIGN = SIGNED
*                9SCALING = 0
*                9VALUE = THE NUMBER OF OPERANDS IN THE POSITIONAL   -
*                CONTROL ARRAY FOR THIS SYNTACTIC ENVIRONMENT
*            *********************************************************/
*            /*********************************************************
*            7FIELD = SCAKLD
*              8REFERENCE-TYPE = READ
*              8FIELD-DISPLACEMENT = 4 BYTES
*              8FIELD-TYPE = TABLE
*              8PURPOSE = DESCRIBE A KEYWORD LENGTH CONTROL ARRAY    -
*              FOR THIS SYNTACTIC ENVIRONMENT
*              8SCOPE = INTERNAL
*              8TABLE-SIZE = 4 BYTES
*              *******************************************************/
*              /*******************************************************
*              8FIELD = SCAKLDO
*                9REFERENCE-TYPE = READ
*                9FIELD-DISPLACEMENT = 0 BYTES
*                9FIELD-TYPE = OFFSET
*                9OFFSET-FROM = SCADV
*                9OFFSET-LENGTH = 15 BITS
*                9SIGN = SIGNED
*                9OFFSET-SCALING = 0
*                9OFFSET-OF = KLCA
*                 10REFERENCE-TYPE = READ
*                 10TYPE-ADDRESSED = TABLE
*                 10PURPOSE = DESCRIBE KEYWORD CONTROL ARRAYS FOR    -
*                 KEYWORDS OF EACH ADMISSIBLE LENGTH IN THIS         -
*                 SYNTACTIC ENVIRONMENT
*                 10SCOPE = INTERNAL
*                 10TABLE-REPLICATION = VARIABLE
*                 10REPLICATION-COUNT = SCAKLDMX
*                  11COUNT-TYPE = ARITHMETIC
*                 10TABLE-SIZE = 4 BYTES
*                 ****************************************************/
*                 /****************************************************
*                 10FIELD = KLCAKCA
*                  11REFERENCE-TYPE = READ
*                  11FIELD-DISPLACEMENT = 0 BYTES
*                  11FIELD-TYPE = OFFSET
*                  11OFFSET-FROM = SCADV
*                  11OFFSET-LENGTH = 15 BITS
*                  11SIGN = SIGNED
*                  11OFFSET-SCALING = 0
*                  11OFFSET-OF = KCA
*                   12REFERENCE-TYPE = READ
*                   12TYPE-ADDRESSED = TABLE
*                   12PURPOSE = DESCRIBE ALL ADMISSIBLE KEYWORDS OF  -
*                   A SINGLE LENGTH FOR A SYNTACTIC ENVIRONMENT
*                   12SCOPE = INTERNAL
*                   12TABLE-REPLICATION = VARIABLE
*                   12REPLICATION-COUNT = KLCAMX
*                    13COUNT-TYPE = ARITHMETIC
*                   12TABLE-SIZE = VARIABLE
*                   12TERMINATOR = THE LENGTH OF THE KEYWORDS        -
*                   REPRESENTED IN THIS ARRAY PLUS THE LENGTH OF THE -
*                   HEADER
*                   **************************************************/
*                   /**************************************************
*                   12FIELD = KCAPROC
*                    13REFERENCE-TYPE = READ
*                    13FIELD-DISPLACEMENT = 0 BYTES
*                    13FIELD-TYPE = ARITHMETIC
*                    13MODE = BINARY
*                    13LENGTH = 15 BITS
*                    13SIGN = SIGNED
*                    13SCALING = 0
*                    13VALUE = INDEX OF THE PROCCA ARRAY WHICH       -
*                    POINTS TO THE OPERAND PROCESSOR WHICH SHOULD BE -
*                    INVOKED WHEN THIS KEYWORD OR AN UNAMBIGUOUS     -
*                    TRUNCATION OF THE KEYWORD IS ENCOUNTERED IN THE -
*                    SPECIFIED SYNTACTIC ENVIRONMENT
*                   **************************************************/
*                   /**************************************************
*                   12FIELD = KCASNO
*                    13REFERENCE-TYPE = READ
*                    13FIELD-DISPLACEMENT = 2 BYTES
*                    13FIELD-TYPE = ARITHMETIC
*                    13MODE = BINARY
*                    13LENGTH = 15 BITS
*                    13SIGN = SIGNED
*                    13SCALING = 0
*                    13VALUE = INDEX OF THE SCA ENTRY WHICH          -
*                    SPECIFIES THE SYNTAX FOR THE SUBFIELD OF THE    -
*                    KEYWORD
*                   **************************************************/
*                   /**************************************************
*                   12FIELD = KCAIMAG
*                    13REFERENCE-TYPE = READ
*                    13FIELD-DISPLACEMENT = 4 BYTES
*                    13FIELD-TYPE = CHARACTER STRING
*                    13LENGTH+MODE = VARIABLE
*                    13TERMINATOR = CALCULATED. EQUAL TO THE INDEX   -
*                    OF THE KEYWORD LENGTH CONTROL ARRAY ENTRY WHICH -
*                    IS USED TO LOCATE THIS KEYWORD CONTROL ARRAY
*                    13STRING-VALUE = THE IMAGE OF THE ADMISSIBLE    -
*                    KEYWORD
*                 ****************************************************/
*                 /****************************************************
*                 10FIELD = KLCAMX
*                  11REFERENCE-TYPE = READ
*                  11FIELD-DISPLACEMENT = 2 BYTES
*                  11FIELD-TYPE = ARITHMETIC
*                  11MODE = BINARY
*                  11LENGTH = 15 BITS
*                  11SIGN = SIGNED
*                  11SCALING = 0
*                  11VALUE = THE NUMBER OF ENTRIES IN THE KEYWORD    -
*                  CONTROL ARRAY REFERENCED BY KLCAKCA.  THIS IS     -
*                  ALSO THE LENGTH OF THE LONGEST ADMISSIBLE KEYWORD -
*                  IN THIS SYNTACTIC ENVIRONMENT
*              *******************************************************/
*              /*******************************************************
*              8FIELD = SCAKLDMN
*                9REFERENCE-TYPE = READ
*                9FIELD-DISPLACEMENT = 2 BYTES
*                9FIELD-TYPE = ARITHMETIC
*                9MODE = BINARY
*                9LENGTH = 8 BITS
*                9SIGN = UNSIGNED
*                9SCALING = 0
*                9VALUE = THE INDEX OF THE FIRST ENTRY ACTUALLY      -
*                PRESENT IN THE KEYWORD LENGTH CONTROL ARRAY         -
*                REFERENCED BY SCAKLDO. THIS IS GENERALLY ALSO THE   -
*                LENGTH OF THE SHORTEST ADMISSIBLE KEYWORD IN THIS   -
*                SYNTACTIC ENVIRONMENT.
*              *******************************************************/
*              /*******************************************************
*              8FIELD = SCAKLDMX
*                9REFERENCE-TYPE = READ
*                9FIELD-DISPLACEMENT = 3 BYTES
*                9FIELD-TYPE = ARITHMETIC
*                9MODE = BINARY
*                9LENGTH = 8 BITS
*                9SIGN = UNSIGNED
*                9SCALING = 0
*                9VALUE = INDEX OF THE LAST ENTRY PRESENT IN THE     -
*                KEYWORD LENGTH CONTROL ARRAY REFERENCED BY KCAKLDO. -
*                THIS IS ALSO GENERALLY THE LENGTH OF THE LONGEST    -
*                ADMISSIBLE KEYWORD IN THIS SYNTACTIC ENVIRONMENT
*    *****************************************************************/
*    /*****************************************************************
*    3FIELD = PARMNUM
*      4REFERENCE-TYPE = READ
*      4FIELD-DISPLACEMENT = 12 BYTES
*      4TYPE = ADDRESS
*      4ADDRESS-LENGTH = 32 BITS
*      4ADDRESS-SIGN = UNSIGNED
*      4ADDRESS-OF = NUM
*        5REFERENCE-TYPE = READ-WRITE
*        5TYPE-ADDRESSED = TABLE
*        5PURPOSE = PROVIDE CONTROL DATA FOR IEFVSCAN AND PROVIDE    -
*        FOR THE RETURN OF SUMMARY DATA REGARDING THE SCAN
*        5SCOPE = INTERNAL
*        5TABLE-SIZE = 12 BYTES
*        *************************************************************/
*        /*************************************************************
*        5FIELD = NUMA
*          6REFERENCE-TYPE = READ-WRITE
*          6FIELD-DISPLACEMENT = 0 BYTES
*          6FIELD-TYPE = TABLE
*          6SCOPE = INTERNAL
*          6TABLE-SIZE = 8 BYTES
*          ***********************************************************/
*          /***********************************************************
*          6FIELD = NUMLEVEL
*            7REFERENCE-TYPE = READ-WRITE
*            7FIELD-DISPLACEMENT = 0 BYTES
*            7FIELD-TYPE = ARITHMETIC
*            7MODE = BINARY
*            7LENGTH = 15 BITS
*            7SIGN = SIGNED
*            7SCALING = 0
*            7VALUE = THE SYNTACTIC LEVEL NUMBER. THIS MAY BE        -
*            INITIALIZED TO ANY VALUE UPON ENTRY TO IEFVSCAN;        -
*            IEFVSCAN WILL INCREMENT THIS NUMBER BY ONE EACH TIME    -
*            THAT A NEW KEYWORD LEVEL IS ENCOUNTERED AND DECREMENT   -
*            AGAIN AT THE NORMAL CONCLUSION OF PROCESSING FOR        -
*            THAT LEVEL.  IF PROCESSING DOES NOT CONCLUDE NORMALLY   -
*            AT A LEVEL, THE LEVEL NUMBER OF THAT LEVEL IS RETAINED  -
*            AND RETURNED TO THE INVOKER.
*          ***********************************************************/
*          /***********************************************************
*          6FIELD = NUMOPER
*            7REFERENCE-TYPE = READ-WRITE
*            7FIELD-DISPLACEMENT = 2 BYTES
*            7FIELD-TYPE = ARITHMETIC
*            7MODE = BINARY
*            7LENGTH = 15 BITS
*            7SIGN = SIGNED
*            7SCALING = 0
*            7VALUE = THE NUMBER OF OPERANDS SCANNED. THIS MAY BE    -
*            INITIALIZED TO ANY VALUE UPON ENTRY TO IEFVSCAN;        -
*            IEFVSCAN WILL INCREMENT THIS NUMBER BY ONE EACH TINE    -
*            THAT A NEW OPERAND IS SCANNED AT THE INPUT SYNTACTIC    -
*            LEVEL; THIS WILL ALSO BE DONE, BEGINNING WITH AN        -
*            INITIAL VALUE OF ZERO FOR ALL OTHER LEVELS SCANNED. THE -
*            VALUE RETURNED IN THIS FIELD WILL BE THE SUM OF THE     -
*            INITIAL VALUE AND THE NUMBER OF OPERANDS ENCOUNTERED AT -
*            THE INPUT SYNTACTIC LEVEL IF PROCESSING COMPLETES       -
*            NORMALLY; OTHERWISE, THE NUMBER OF OPERANDS SCANNED     -
*            WITHIN THE SUBFIELD UNDER CONSIDERATION WHEN AN         -
*            ABNORMAL CONDITION WAS DETECTED WILL BE RETURNED.
*          ***********************************************************/
*          /***********************************************************
*          6FIELD = NUMPOPER
*            7REFERENCE-TYPE = READ-WRITE
*            7FIELD-DISPLACEMENT = 4 BYTES
*            7FIELD-TYPE = ARITHMETIC
*            7MODE = BINARY
*            7LENGTH = 15 BITS
*            7SIGN = SIGNED
*            7SCALING = 0
*            7VALUE = THE NUMBER OF POSITIONAL OPERANDS SCANNED.     -
*            THIS MAY BE INITIALIZED TO ANY VALUE UPON ENTRY TO      -
*            IEFVSCAN; IEFVSCAN WILL INCREMENT THIS NUMBER BY ONE    -
*            EACH TIME THAT A NEW POSITIONAL OPERAND IS SCANNED AT   -
*            THE INPUT SYNTACTIC LEVEL; THIS WILL ALSO BE DONE,      -
*            BEGINNING WITH AN INITIAL VALUE OF ZERO FOR ALL OTHER   -
*            LEVELS SCANNED. THE VALUE RETURNED IN THIS FIELD WILL   -
*            BE THE SUM OF THE INITIAL VALUE AND THE NUMBER OF       -
*            POSITIONAL OPERANDS ENCOUNTERED AT THE INPUT SYNTACTIC  -
*            LEVEL IF PROCESSING COMPLETES NORMALLY; OTHERWISE THE   -
*            NUMBER OF OPERANDS SCANNED WITHIN THE SUBFIELD UNDER    -
*            CONSIDERATION WHEN AN ABNORMAL CONDITION WAS DETECTED   -
*            WILL BE RETURNED.
*          ***********************************************************/
*          /***********************************************************
*          6FIELD = NUMSNTX
*            7REFERENCE-TYPE = READ-WRITE
*            7FIELD-DISPLACEMENT = 6 BYTES
*            7FIELD-TYPE = ARITHMETIC
*            7MODE = BINARY
*            7LENGTH = 15 BITS
*            7SIGN = SIGNED
*            7SCALING = 0
*            7VALUE = THE SYNTAX NUMBER. THIS MUST BE INITIALIZED TO -
*            THE NUMBER OF THE SYNTAX IEFVSCAN IS TO USE FOR THE     -
*            INPUT SYNTACTIC LEVEL AND THE SAME VALUE WILL BE        -
*            RETURNED IN THIS FIELD IF PROCESSING CONCLUDES          -
*            NORMALLY; OTHERWISE, THE SYNTAX NUMBER BEING USED AT    -
*            THE SYNTACTIC LEVEL INDICATED BY NUMLEVEL WILL BE       -
*            RETURNED.
*        *************************************************************/
*        /*************************************************************
*        5FIELD = NUMB
*          6REFERENCE-TYPE = READ-WRITE
*          6FIELD-DISPLACEMENT = 8 BYTES
*          6FIELD-TYPE = RES: CHOOSE: TABLE=SPC16;
*1RESUME = RES: CHOOSE: REFETCH=SPC1;
*
**** END OF SPECIFICATIONS ***/
*        GENERATE;
** /*
IEFVSCAN START 0
         ENTRY     IEFVSCN1
SCAN0001 B   SCAN0003-SCAN0001(0,R15) BRANCH AROUND IDENTIFIER
         DC  AL1(L'SCAN0002)     LENGTH OF IDENTIFIER
SCAN0002 DC C'IEFVSCAN&LUPDAT'   ENTRY NAME AND DATE OF LAST UPDATE
SCAN0003 DS 0H                   BRANCH TARGET
         AGO  .@001
** */
*/*IEFVSCAN:     CHART   (AMODE,IBM68,NSAVE,NSEQ) */
*/*         HEADER
*/*IEFVSCAN -- TABLE-DRIVEN SYNTAX SCAN */
*/*IEFVSCAN:     E    MULTIPLE OPERAND SCAN FUNCTION */
*IEFVSCAN: PROC/*(BDV, PROCCA, SCADV, NUM, COMM)*/
*             OPTIONS(REENTRANT, CODEREG(0), DATAREG(0));
         LCLA  &T,&SPN                                            0003
.@001    ANOP                                                     0003
IEFVSCAN CSECT ,                                                  0003
         STM   @E,@C,12(@D)                                       0003
*        GENERATE;
        TITLE 'IEFVSCAN -- TABLE-DRIVEN SYNTAX SCAN -- DEFINITIONS OF  V
               ARIABLES'
         DS    0H
*
*
*
*
* /*******************************************************************/
* /*      DEFINE THE GENERAL PURPOSE REGISTERS                       */
* /*******************************************************************/
* DECLARE
*         R0FIXED POINTER(31) REGISTER(0) UNRESTRICTED,
*         /***********************************************************/
*         /*    STANDARD LINKAGE CONVENTION PARAMETER LIST POINTER   */
*         /***********************************************************/
*         R1PTR24 POINTER(24) REGISTER(1) RESTRICTED,
*         R2FIXED FIXED(31) REGISTER(2) RESTRICTED,
*         R3FIXED FIXED(31) REGISTER(3) RESTRICTED,
*         R4PTR24 POINTER(24) REGISTER(4) RESTRICTED,
*         R5PTR24 POINTER(24) REGISTER(5) RESTRICTED,
*         R6PTR24 POINTER(24) REGISTER(6) RESTRICTED,
*         R7PTR24 POINTER(24) REGISTER(7) UNRESTRICTED,
*         R8 POINTER(31) REGISTER(8) UNRESTRICTED,
*         R9 POINTER(31) REGISTER(9) UNRESTRICTED,
*         R10 POINTER(31) REGISTER(10) UNRESTRICTED,
*         R11 POINTER(31) REGISTER(11) UNRESTRICTED,
*         R12 POINTER(31) REGISTER(12) UNRESTRICTED,
*         /***********************************************************/
*         /*   STANDARD LINKAGE CONVENTION SAVE AREA POINTER         */
*         /***********************************************************/
*         R13 POINTER(31) REGISTER(13) UNRESTRICTED,
*         /***********************************************************/
*         /*   STANDARD LINKAGE CONVENTION RETURN POINTER            */
*         /***********************************************************/
*         R14 POINTER(31) REGISTER(14) UNRESTRICTED,
*         /***********************************************************/
*         /*   STANDARD LINKAGE CONVENTION SUBROUTINE ENTRY POINTER  */
*         /***********************************************************/
*         R15 POINTER(31) REGISTER(15) UNRESTRICTED;
*
* /*******************************************************************/
* /*      DEFINE A SAVE AREA                                         */
* /*******************************************************************/
* DECLARE
* 1       SAVEAREA  BASED( R13) BOUNDARY( WORD),
*         /***********************************************************/
*         /*    PL/I USES THIS WORD TO INDICATE THE LENGTH OF THE    */
*         /*    DYNAMIC STORAGE AREA REPRESENTED BY THIS SAVE AREA   */
*         /***********************************************************/
*         2     SAVEWRD1 POINTER(32),
*               3  SAVEPFLG POINTER(8),
*               3  SAVEPLGH POINTER(24),
*         /***********************************************************/
*         /*    POINTER TO THE PREVIOUS SAVE AREA, THE SAVE AREA OF  */
*         /*    THE INVOKER UNLESS THIS SUBROUTINE PROVIDES NO SAVE  */
*         /*    AREA OF ITS OWN                                      */
*         /***********************************************************/
*         2     SAVELAST POINTER(32),
*         /***********************************************************/
*         /*    POINTER TO THE NEXT SAVE AREA FOR ALL BUT THE LOWEST */
*         /*    LEVEL SUBROUTINE ON THE STACK                        */
*         /***********************************************************/
*         2     SAVENEXT POINTER(32),
*         /***********************************************************/
*         /*    SAVE AREA WORD FOR INPUT REGISTER 14, THE ADDRESS TO */
*         /*    WHICH CONTROL IS NORMALLY TO BE RETURNED AFTER A     */
*         /*    SUBROUTINE HAS CONCLUDED PROCESSING.  THE HIGH-ORDER */
*         /*    BYTE OF THIS POINTER SHOULD BE SET TO 'FF'X IF THIS  */
*         /*    ROUTINE HAS CONTROL AFTER A RETURN HAS BEEN MADE FROM*/
*         /*    A SUBROUTINE.                                        */
*         /***********************************************************/
*         2     SAVER14 POINTER(32),
*               3  SAVERETF POINTER(8),
*         /***********************************************************/
*         /*    SAVE AREA FOR INPUT REGISTERS 15 THROUGH 12          */
*         /***********************************************************/
*         2     SAVER15 POINTER(32),
*         2     SAVER0 POINTER(32),
*         2     SAVER1 POINTER(32),
*         2     SAVER2 POINTER(32),
*         2     SAVER3 POINTER(32),
*         2     SAVER4 POINTER(32),
*         2     SAVER5 POINTER(32),
*         2     SAVER6 POINTER(32),
*         2     SAVER7 POINTER(32),
*         2     SAVER8 POINTER(32),
*         2     SAVER9 POINTER(32),
*         2     SAVER10 POINTER(32),
*         2     SAVER11 POINTER(32),
*         2     SAVER12 POINTER(32),
*         /***********************************************************/
*         /*   AREA USED BY PL/I AND BSL FOR TEMPORARY AND AUTOMATIC */
*         /*   STORAGE AREAS                                         */
*         /***********************************************************/
*         2     SAVEXTNT CHARACTER( 8);
*
* /*******************************************************************/
* /*      DEFINE A TYPE I PARAMETER LIST                             */
* /*******************************************************************/
* DECLARE
* 1       PARAM BASED( R1PTR24) BOUNDARY( WORD),
*         2     PARAM1 POINTER(32),
*         2     PARAM2 POINTER(32),
*         2     PARAM3 POINTER(32),
*         2     PARAM4 POINTER(32),
*         2     PARAM5 POINTER(32),
*         2     PARAM6 POINTER(32),
*         2     PARAM7 POINTER(32),
*         2     PARAM8 POINTER(32),
*         2     PARAM9 POINTER(32),
*         2     PARAM10 POINTER(32),
*         2     PARAM11 POINTER(32),
*         2     PARAM12 POINTER(32),
*         2     PARAM13 POINTER(32),
*         2     PARAM14 POINTER(32),
*         2     PARAM15 POINTER(32),
*         2     PARAM16 POINTER(32),
*         2     PARAM17 POINTER(32),
*         2     PARAM18 POINTER(32),
*         2     PARAM19 POINTER(32),
*         2     PARAM20 POINTER(32),
*         2     PARAM21 POINTER(32),
*         2     PARAM22 POINTER(32),
*         2     PARAM23 POINTER(32),
*         2     PARAM24 POINTER(32),
*         2     PARAM25 POINTER(32),
*         2     PARAM26 POINTER(32),
*         2     PARAM27 POINTER(32),
*         2     PARAM28 POINTER(32),
*         2     PARAM29 POINTER(32),
*         2     PARAM30 POINTER(32);
*
*        /************************************************************/
*        /*   DEFINE AN AUTOMATIC STORAGE IMAGE OF THE PARAMETER     */
*        /*   LIST TO IEFVSCAN                                       */
*        /************************************************************/
*        DECLARE
*        1    PARM AUTOMATIC BOUNDARY(WORD),
*             2    PARMBDV POINTER(31), /* POINTER TO A BUFFER DOPE
*                                 VECTOR DESCRIBING AN EBCDIC INPUT
*                                 BUFFER TO BE SCANNED               */
*             2    PARMPROC POINTER(31), /* POINTER TO A PROCEDURE
*                                 ARRAY CONSISTING OF HALFWORD OFFSETS
*                                 TO OPERAND PROCESSORS, THE OFFSETS
*                                 BEING COMPUTED FROM THE ORIGIN OF
*                                 THE PROCEDURE CONTROL ARRAY        */
*             2    PARMSCAD POINTER(31), /* POINTER TO A SYNTAX CON-
*                                 TROL ARRAY DOPE VECTOR DESCRIBING
*                                 THE SYNTAX TO WHICH THE BUFFER MUST
*                                 CONFORM                            */
*             2    PARMNUM POINTER(31), /* POINTER TO A STRUCTURE
*                                 CONSISTING OF FOUR HALFWORD CURRENT
*                                 SYNTACTIC LEVEL NUMBER, THE NUMBER
*                                 OF OPERANDS SCANNED FROM THE LEVEL,
*                                 THE NUMBER OF POSITIONAL OPERANDS
*                                 SCANNED FROM THE LEVEL, AND THE
*                                 INDEX OF THE SYNTAX WHICH APPLIES
*                                 TO THE CURRENT LEVEL               */
*             2    PARMCOMM POINTER(31), /* POINTER AVAILABLE TO THE
*                                 INVOKER OF SCAN FOR COMMUNICATION
*                                 WITH OPERAND PROCESSORS            */
*             2    PARMODV POINTER(31); /* ADDITIONAL VARIABLES TO
*                                 FORM A PARAMETER LIST TO OPERAND
*                                 PROCESSORS                         */
*
*
*        /************************************************************/
*        /*   DEFINE A PROCESSOR CONTROL ARRAY                       */
*        /************************************************************/
*        DECLARE
*        PROCCA(32767) BASED(PARMPROC) FIXED(15) BOUNDARY(HWORD);
*
*        /************************************************************/
*        /*   DEFINE A STRUCTURE CONSISTING OF NUMERIC OPERANDS      */
*        /*   DESCRIBING A SYNTACTIC ENVIRONMENT                     */
*        /************************************************************/
*        DECLARE
*        1    NUM BASED(R6PTR24) BOUNDARY(HWORD),
*             2    NUMA BOUNDARY(HWORD),
*                  3    NUMLEVEL FIXED(15) BOUNDARY(HWORD),
*                  3    NUMOPER FIXED(15) BOUNDARY(HWORD),
*                  3    NUMPOPER FIXED(15) BOUNDARY(HWORD),
*                  3    NUMSNTX FIXED(15) BOUNDARY(HWORD),
*             2    NUMB BOUNDARY(HWORD),
*                  3    NUMSCAN FIXED(15) BOUNDARY(HWORD),
*                  3    NUMRCODE FIXED(15) BOUNDARY(HWORD);
*
*        /************************************************************/
*        /*   DEFINE A STRUCTURE CONSISTING OF NUMERIC OPERANDS      */
*        /*   DESCRIBING THE SYNTACTIC ENVIRONMENT IN WHICH THE      */
*        /*   NEXT LEVEL OF IEFVSCAN OR IEFVSCN1 WILL BE INVOKED     */
*        /************************************************************/
*        DECLARE
*        1    LNUM AUTOMATIC BOUNDARY(HWORD),
*             2    LNUMA BOUNDARY(HWORD),
*                  3    LNUMLEVL FIXED(15) BOUNDARY(HWORD),
*                  3    LNUMOPER FIXED(15) BOUNDARY(HWORD),
*                  3    LNUMPOPR FIXED(15) BOUNDARY(HWORD),
*                  3    LNUMSNTX FIXED(15) BOUNDARY(HWORD),
*             2    LNUMB BOUNDARY(HWORD),
*                  3    LNUMSCAN FIXED(15) BOUNDARY(HWORD),
*                  3    LNUMRCOD FIXED(15) BOUNDARY(HWORD);
*
*        /************************************************************/
*        /*   DEFINE A BUFFER DOPE VECTOR                            */
*        /************************************************************/
*        DECLARE
*        1    BDV BASED(PARMBDV) BOUNDARY(WORD),
*             2    BDVBUF POINTER(31),
*             2    BDVMX POINTER(15),
*             2    BDVLEN POINTER(15);
*
*        /************************************************************/
*        /*   DEFINE A LOCAL BUFFER DOPE VECTOR                      */
*        /************************************************************/
*        DECLARE
*        1    LBDV AUTOMATIC BOUNDARY(WORD),
*             2    LBDVBUF POINTER(31),
*             2    LBDVMX POINTER(15),
*             2    LBDVLEN POINTER(15);
*
*        /************************************************************/
*        /*   DEFINE AN OPERAND BUFFER DOPE VECTOR                   */
*        /************************************************************/
*        DECLARE
*        1    ODV AUTOMATIC BOUNDARY(WORD),
*             2    ODVOPER POINTER(31),
*             2    ODVMX POINTER(15),
*             2    ODVLEN POINTER(15);
*
*        /************************************************************/
*        /*   DEFINE A BUFFER                                        */
*        /************************************************************/
*        DECLARE
*        BUFFER CHAR(32767) BASED(BDVBUF) BOUNDARY(BYTE);
*
*        /************************************************************/
*        /*   DEFINE AN OPERAND                                      */
*        /************************************************************/
*        DECLARE
*        OPERAND CHAR(32767) BASED(ODVOPER) BOUNDARY(BYTE);
*
*        /************************************************************/
*        /*   DEFINE A TRANSLATE AND TEST TABLE FOR SCANNING         */
*        /*   BUFFERS CONTAINING DATA IN ASSEMBLER/JCL LANGUAGE      */
*        /*   SYNTAX                                                 */
*        /************************************************************/
*        DECLARE
*        TRTTAB(256) POINTER(8) STATIC BOUNDARY(BYTE)
*             INIT((64)255,      /* THE FIRST 64 EBCDIC CODES ARE
*                                 INVALID CHARACTERS EXCEPT WHEN
*                                 ENCLOSED WITHIN APOSTROPHES        */
*                  0,          /* BLANK GENERATES CHARACTER CODE 1   */
*                  (12)255,      /* THE EBCDIC CODES FROM '41'X TO
*                                 '4C'X ARE INVALID CHARACTERS EXCEPT
*                                 WHEN ENCLOSED WITHIN APOSTROPHES   */
*                  4,          /* LEFT PARENTHESIS GENERATES CHARACTER
*                                 CODE 4                             */
*                  (13)255,      /* THE EBCDIC CODES FROM '4E'X TO
*                                 '5A'X ARE INVALID CHARACTERS EXCEPT
*                                 WHEN ENCLOSED WITHIN APOSTROPHES   */
*                  0,          /* THE DOLLAR SIGN IS A LEGAL, NATIONAL
*                                 CHARACTER                          */
*                  255,        /* ASTERISK IS AN INVALID CHARACTER
*                                 EXCEPT WHEN ENCLOSED WITHIN
*                                 APOSTROPHES                        */
*                  5,          /* RIGHT PARENTHESIS GENERATES CHAR-
*                                 ACTER CODE 5                       */
*                  (13)255,      /* THE EBCDIC CODES FROM '5E'X TO
*                                 '6A'X ARE INVALID CHARACTERS EXCEPT
*                                 WHEN ENCLOSED WITHIN APOSTROPHES   */
*                  2,          /* COMMA GENERATES CHARACTER CODE 2   */
*                  (15)255,      /* THE EBCDIC CODES FROM '6C'X TO
*                                 '7A'X ARE INVALID CHARACTERS EXCEPT
*                                 WHEN ENCLOSED WITHIN APOSTROPHES   */
*                  0,          /* THE POUND SIGN IS A LEGAL, NATIONAL
*                                 CHARACTER                          */
*                  0,          /* THE 'AT SIGN' IS A LEGAL, NATIONAL
*                                 CHARACTER                          */
*                  6,          /* APOSTROPHE GENERATES CHARACTER
*                                 CODE 6                             */
*                  3,          /* THE EQUAL SIGN GENERATES CHARACTER
*                                 CODE 3                             */
*                  (66)255,      /* THE EBCDIC CODES FROM '7F'X TO
*                                 'C0'X ARE INVALID CHARACTERS EXCEPT
*                                 WHEN ENCLOSED WITHIN APOSTROPHES   */
*                  (9)0,       /* 'A' THROUGH 'I' ARE LEGAL CHAR-
*                                 ACTERS                             */
*                  (7)255,      /* THE EBCDIC CODES FROM 'CA'X TO
*                                 'D0'X ARE ILLEGAL CHARACTERS EXCEPT
*                                 WHEN ENCLOSED WITHIN APOSTROPHES   */
*                  (9)0,       /* 'J' THROUGH 'R' ARE LEGAL CHAR-
*                                 ACTERS                             */
*                  (8)255,      /* THE EBCDIC CODES FROM 'DA'X TO
*                                 'E1'X ARE ILLEGAL CHARACTERS EXCEPT
*                                 WHEN ENCLOSED WITHIN APOSTROPHES   */
*                  (8)0,       /* 'S' THROUGH 'Z' ARE LEGAL CHAR-
*                                 ACTERS                             */
*                  (6)255,      /* THE EBCDIC CODES FROM 'EA'X TO
*                                 'EF'X ARE ILLEGAL CHARACTERS EXCEPT
*                                 WHEN ENCLOSED WITHIN APOSTROPHES   */
*                  (10)0,       /* '0' THROUGH '9' ARE LEGAL CHAR-
*                                 ACTERS                             */
*                  (6)255);      /* THE EBCDIC CODES FROM 'FA'X TO
*                                 'FF'X ARE ILLEGAL CHARACTERS EXCEPT
*                                 WHEN ENCLOSED WITHIN APOSTROPHES   */
*
*        /************************************************************/
*        /*   DEFINE A SYNTAX CONTROL ARRAY DOPE VECTOR              */
*        /************************************************************/
*        DECLARE
*        1    SCADV BASED(PARMSCAD) BOUNDARY(HWORD),
*             2    SCADVSCA POINTER(15),
*             2    SCADVMX POINTER(15);
*
*        /************************************************************/
*        /*   DEFINE A SYNTAX CONTROL ARRAY                          */
*        /************************************************************/
*        DECLARE
*        1    SCA(32767) BASED(R5PTR24) BOUNDARY(HWORD),
*                              /* ADDR(SCADV) + SCADVSCA             */
*             2    SCAPD BOUNDARY(HWORD), /* SYNTAX CONTROL ARRAY
*                                 POSITIONAL OPERAND ARRAY DOPE
*                                 VECTOR                             */
*                  3    SCAPDO FIXED(15) BOUNDARY(HWORD), /* OFFSET OF
*                                 A POSITIONAL OPERAND CONTROL ARRAY
*                                 FROM THE SYNTAX CONTROL ARRAY DOPE
*                                 VECTOR                             */
*                  3    SCAPDMX POINTER(15) BOUNDARY(HWORD), /* MAXI-
*                                 MUM INDEX INTO THE POSITIONAL OPER-
*                                 AND CONTROL ARRAY.  IF THIS INDEX
*                                 IS ZERO, NO POSITIONAL OPERANDS ARE
*                                 SUPPORTED.  IF IT IS NON-ZERO AND THE
*                                 LAST POSITIONAL PROCESSOR CODE IN THE
*                                 POSITIONAL OPERAND CONTROL ARRAY IS
*                                 ZERO, EXACTLY THAT NUMBER OF POSI-
*                                 TIONAL OPERANDS ARE SUPPORTED BY THE
*                                 SYNTAX.  IF THE INDEX IS NON-ZERO AND
*                                 THE LAST POSITIONAL PROCESSOR CODE IN
*                                 THE POSITIONAL OPERAND CONTROL ARRAY
*                                 IS NON-ZERO, THE FINAL POSITIONAL
*                                 OPERAND PROCESSOR WILL BE INVOKED FOR
*                                 ALL POSITIONAL OPERANDS FOLLOWING THE
*                                 LAST ONE FOR WHICH A PROCESSOR IS
*                                 EXPLICITLY SPECIFIED               */
*             2    SCAKLD BOUNDARY(HWORD), /* SYNTAX CONTROL ARRAY
*                                 KEYWORD OPERAND LENGTH CONTROL ARRAY
*                                 DOPE VECTOR                        */
*                  3    SCAKLDO FIXED(15) BOUNDARY(HWORD), /* OFFSET
*                                 OF THE LOGICAL ORIGIN OF A KEYWORD
*                                 LENGTH CONTROL ARRAY FROM THE
*                                 SYNTAX CONTROL ARRAY DOPE VECTOR   */
*                  3    SCAKLDMN POINTER(8) BOUNDARY(BYTE), /* MINIMUM
*                                 KEYWORD LENGTH                     */
*                  3    SCAKLDMX POINTER(8) BOUNDARY(BYTE); /* MINIMUM
*                                 KEYWORD LENGTH                     */
*
*        /************************************************************/
*        /*   DEFINE A SINGLE ELEMENT IN THE SYNTAX CONTROL ARRAY    */
*        /************************************************************/
*        DECLARE
*        1    SCEPTR POINTER(31) AUTOMATIC,
*        1    SCE BASED(SCEPTR) BOUNDARY(HWORD),
*             2    SCEPD BOUNDARY(HWORD),
*                  3    SCEPDO FIXED(15) BOUNDARY(HWORD),
*                  3    SCEPDMX POINTER(15) BOUNDARY(HWORD),
*             2    SCEKLD BOUNDARY(HWORD),
*                  3    SCEKLDO FIXED(15) BOUNDARY(HWORD),
*                  3    SCEKLDMN POINTER(8) BOUNDARY(BYTE),
*                  3    SCEKLDMX POINTER(8) BOUNDARY(BYTE);
*
*        /************************************************************/
*        /*   DEFINE A BASED STRUCTURE TO MAP AN OPTIONS POSITIONAL  */
*        /*   CONTROL ARRAY                                          */
*        /************************************************************/
*        DECLARE
*        1    PCA(32767) BASED(R1PTR24) BOUNDARY(BYTE),
*                              /* (ADDR(SCADV) + SCAPDO(I))          */
*             2    PCAPROC POINTER(15) BOUNDARY(BYTE), /* CODE REPRE-
*                                 SENTING THE PROCESSOR TO HANDLE THE
*                                 POSITIONAL OPERAND                 */
*             2    PCASNO POINTER(15) BOUNDARY(BYTE); /* CODE REPRE-
*                                 SENTING THE PREPROCESSOR TO HANDLE
*                                 THE OPERAND VALUE VALIDITY CHECKING*/
*
*        /************************************************************/
*        /*   DEFINE A BASED STRUCTURE TO MAP AN OPTIONS KEYWORD     */
*        /*   LENGTH CONTROL ARRAY                                   */
*        /************************************************************/
*        DECLARE
*        1    KLCA(32767) BASED(R1PTR24) BOUNDARY(HWORD),
*                              /* (ADDR(SCADV) + SCAKLCA(I))         */
*             2    KLCAKCA FIXED(15) BOUNDARY(HWORD), /* OFFSET OF A
*                                 KEYWORD CONTROL ARRAY FROM THE
*                                 ORIGIN OF THE SYNTAX CONTROL ARRAY
*                                 DOPE VECTOR                        */
*             2    KLCAMX POINTER(15) BOUNDARY(HWORD); /* NUMBER OF
*                                 KEYWORDS OF THIS LENGTH            */
*
*        /************************************************************/
*        /*   DEFINE A BASED STRUCTURE MAPPING A SINGLE ELEMENT IN   */
*        /*   AN OPTIONS KEYWORD CONTROL ARRAY.                      */
*        /*        NOTE: AN ACTUAL ENTRY IN A KEYWORD CONTROL ARRAY  */
*        /*        FOR KEYWORDS OF LENGTH = N WILL BE N+4 BYTES IN   */
*        /*        LENGTH RATHER THAN THE NUMBER OF BYTES MAPPED HERE*/
*        /*        FOR THIS REASON ALL COMPUTATION OF ARRAY INDICES  */
*        /*        IS HANDLED EXPLICITLY IN LINE.                    */
*        /************************************************************/
*        DECLARE
*        1    KCA BASED(R4PTR24) BOUNDARY(BYTE),/* (DYNAMIC)         */
*             2    KCAPROC POINTER(15) BOUNDARY(BYTE), /* CODE REPRE-
*                                 SENTING THE PROCESSOR TO HANDLE THE
*                                 KEYWORD OPERAND                    */
*             2    KCASNO POINTER(15) BOUNDARY(BYTE), /* CODE REPRE-
*                                 SENTING THE PREPROCESSOR TO HANDLE
*                                 THE OPERAND VALUE VALIDITY CHECKING*/
*             2    KCAIMAG CHAR(32767) BOUNDARY(BYTE);   /* KEYWORD
*                                 IMAGE                              */
*
*
*        /************************************************************/
*        /*   DEFINE AN OPERAND PROCESSOR                            */
*        /************************************************************/
*        DECLARE
*        OPERPROC BASED(R15) ENTRY;
*
*        /************************************************************/
*        /*   DEFINE THE ENTRY POINTS TO IEFVSCAN AND THE ENTRY      */
*        /*   POINTS FOR INTERNAL FUNCTIONS                          */
*        /************************************************************/
*        DECLARE
*        SCAN BASED(R15) ENTRY, /* BASED ENTRY NAME USED TO INVOKE
*                                 IEFVSCAN                           */
*        IEFVSCN1 STATIC GENERATED ENTRY, /* ENTRY POINT TO SCAN A
*                                 SINGLE OPERAND AT A LEVEL          */
*        SCN10003 STATIC LOCAL ENTRY INTERNAL, /* ENTRY POINT DEFINED
*                                 TO BSL FOR ENTRY IEFVSCN1          */
*        SCN1 BASED(R15) ENTRY, /* BASED ENTRY NAME USED TO INVOKE
*                                 IEFVSCN1                           */
*        PROLOGUE STATIC LOCAL ENTRY INTERNAL, /* INTERNAL INITIALI-
*                                 ZATION FUNCTION                    */
*        DELIMIT STATIC LOCAL ENTRY INTERNAL, /* INTERNAL FUNCTION TO
*                                 LOCATE A DELIMITER                 */
*        UPDATREG STATIC LOCAL ENTRY INTERNAL; /* INTERNAL FUNCTION TO
*                                 UPDATE THE GENERAL REGISTERS USED
*                                 WITHIN THE OPERAND SCAN FUNCTION   */
*
*        /************************************************************/
*        /*   DEFINE THE LABEL VARIABLES WHICH APPEAR WITHIN THE     */
*        /*   MODULE                                                 */
*        /************************************************************/
*        DECLARE
*        SCAN0001 STATIC GENERATED LABEL INTERNAL,
*        SCAN0002 STATIC GENERATED LABEL INTERNAL,
*        SCAN0003 STATIC GENERATED LABEL INTERNAL,
*        SCAN0200 STATIC LOCAL LABEL INTERNAL,
*        SCAN0400 STATIC LOCAL LABEL INTERNAL,
*        SCN10001 STATIC GENERATED LABEL INTERNAL,
*        SCN10002 STATIC GENERATED LABEL INTERNAL,
*        SCN10020 STATIC LOCAL LABEL INTERNAL,
*        SCN10040 STATIC LOCAL LABEL INTERNAL,
*        SCN10060 STATIC LOCAL LABEL INTERNAL,
*        SCN10080 STATIC GENERATED LABEL INTERNAL,
*        SCN10100 STATIC LOCAL LABEL INTERNAL,
*        SCN11100 STATIC LOCAL LABEL INTERNAL,
*        SCN12100 STATIC LOCAL LABEL INTERNAL,
*        SCN12120 STATIC LOCAL LABEL INTERNAL,
*        SCN12140 STATIC LOCAL LABEL INTERNAL,
*        SCN12160 STATIC LOCAL LABEL INTERNAL,
*        SCN12180 STATIC LOCAL LABEL INTERNAL,
*        SCN12200 STATIC LOCAL LABEL INTERNAL,
*        SCN12220 STATIC LOCAL LABEL INTERNAL,
*        SCN12240 STATIC LOCAL LABEL INTERNAL,
*        SCN12242 STATIC LOCAL LABEL INTERNAL,
*        SCN12244 STATIC LOCAL LABEL INTERNAL,
*        SCN12248 STATIC LOCAL LABEL INTERNAL,
*        SCN12252 STATIC LOCAL LABEL INTERNAL,
*        SCN12256 STATIC LOCAL LABEL INTERNAL,
*        SCN12260 STATIC LOCAL LABEL INTERNAL,
*        SCN12264 STATIC LOCAL LABEL INTERNAL,
*        SCN12272 STATIC LOCAL LABEL INTERNAL,
*        SCN12276 STATIC LOCAL LABEL INTERNAL,
*        SCN12300 STATIC LOCAL LABEL INTERNAL,
*        SCN12320 STATIC LOCAL LABEL INTERNAL,
*        SCN12340 STATIC LOCAL LABEL INTERNAL,
*        SCN12360 STATIC LOCAL LABEL INTERNAL,
*        SCN12380 STATIC GENERATED LABEL INTERNAL,
*        SCN12400 STATIC LOCAL LABEL INTERNAL,
*        SCN12420 STATIC LOCAL LABEL INTERNAL,
*        SCN12430 STATIC LOCAL LABEL INTERNAL,
*        SCN12440 STATIC GENERATED LABEL INTERNAL,
*        SCN12500 STATIC LOCAL LABEL INTERNAL,
*        SCN12510 STATIC LOCAL LABEL INTERNAL,
*        SCN12520 STATIC LOCAL LABEL INTERNAL,
*        SCN12540 STATIC LOCAL LABEL INTERNAL,
*        SCN12560 STATIC LOCAL LABEL INTERNAL,
*        SCN12600 STATIC LOCAL LABEL INTERNAL,
*        SCN13100 STATIC LOCAL LABEL INTERNAL,
*        SCN13120 STATIC LOCAL LABEL INTERNAL,
*        SCN13140 STATIC LOCAL LABEL INTERNAL,
*        SCN14100 STATIC LOCAL LABEL INTERNAL,
*        SCN14140 STATIC LOCAL LABEL INTERNAL,
*        SCN14160 STATIC LOCAL LABEL INTERNAL,
*        SCN14180 STATIC GENERATED LABEL INTERNAL,
*        SCN14200 STATIC LOCAL LABEL INTERNAL,
*        SCN14220 STATIC LOCAL LABEL INTERNAL,
*        SCN14240 STATIC LOCAL LABEL INTERNAL,
*        SCN14260 STATIC LOCAL LABEL INTERNAL,
*        SCN14280 STATIC LOCAL LABEL INTERNAL,
*        SCN14300 STATIC LOCAL LABEL INTERNAL,
*        SCN14320 STATIC LOCAL LABEL INTERNAL,
*        SCN14360 STATIC LOCAL LABEL INTERNAL,
*        SCN15100 STATIC LOCAL LABEL INTERNAL,
*        SCN15150 STATIC LOCAL LABEL INTERNAL,
*        SCN15200 STATIC LOCAL LABEL INTERNAL,
*        SCN15250 STATIC LOCAL LABEL INTERNAL,
*        SCN16100 STATIC LOCAL LABEL INTERNAL,
*        SCN16150 STATIC LOCAL LABEL INTERNAL,
*        SCN16200 STATIC LOCAL LABEL INTERNAL,
*        SCN16300 STATIC LOCAL LABEL INTERNAL,
*        SCN16400 STATIC LOCAL LABEL INTERNAL,
*        SCN16500 STATIC LOCAL LABEL INTERNAL,
*        SCN1R000 STATIC LOCAL LABEL INTERNAL,
*        SCN1R004 STATIC LOCAL LABEL INTERNAL,
*        SCN1R008 STATIC LOCAL LABEL INTERNAL,
*        SCN1R00C STATIC LOCAL LABEL INTERNAL,
*        SCN1R010 STATIC LOCAL LABEL INTERNAL,
*        SCN1R400 STATIC LOCAL LABEL INTERNAL,
*        SCN1R404 STATIC LOCAL LABEL INTERNAL,
*        SCN1R408 STATIC LOCAL LABEL INTERNAL,
*        SCN1R40C STATIC LOCAL LABEL INTERNAL,
*        SCN1RSCN STATIC LOCAL LABEL INTERNAL,
*        SCN1RC STATIC LOCAL LABEL INTERNAL;
*
*        RESTRICT(R1PTR24, R2FIXED, R3FIXED, R4PTR24, R5PTR24, R6PTR24,
*R12);                                          /* RESERVE SEVERAL
*                                 REGISTERS FOR EXPLICIT CODE
*                                 REFERENCES                         */
*        GENERATE;
        TITLE  'IEFVSCAN -- TABLE-DRIVEN SYNTAX SCAN -- MULTIPLE OPERA N
               D SCAN FUNCTION'
         DS    0H
*        R12 = R15;            /* ESTABLISH ADDRESSIBILITY FOR ENTRY
*                                 POINT IEFVSCAN                     */
         LR    @C,@F                                              0029
*        GENERATE(USING     IEFVSCAN,R12   TELL THE ASSEMBLER);
         USING     IEFVSCAN,R12   TELL THE ASSEMBLER
         DS    0H
*
*/*      S    PROLOGUE: COMMON INITIALIZATION */
*
*        CALL PROLOGUE;        /* PERFORM INITIALIZATION COMMON TO
*                                 IEFVSCAN AND IEFVSCN1 ENTRY POINTS */
         BAL   @E,PROLOGUE                                        0031
*        GENERATE(USING @DATD,R13      TELL THE ASSEMBLER); /* THE
*                                 PROLOGUE FUNCTION HAS NOW ESTAB-
*                                 LISHED ADDRESSIBILITY TO THE DYNAMIC
*                                 SAVE AREA THROUGH REGISTER 13      */
         USING @DATD,R13      TELL THE ASSEMBLER
         DS    0H
*
*/*      M    IEFVSCAN INITIALIZATION */
*
*        R5PTR24 = PARMBDV;    /* SET THE BUFFER DOPE VECTOR POINTER
*                                 TO THE ADDRESS OF THE INPUT BUFFER
*                                 DOPE VECTOR                        */
         L     @5,PARM                                            0033
*        RESPECIFY BDV BASED(R5PTR24);/* IN THIS PORTION OF THE MODULE
*                                 THE BUFFER DOPE VECTOR SHOULD BE
*                                 LOCATED USING THE BUFFER DOPE
*                                 VECTOR POINTER                     */
*        PARMBDV = ADDR(LBDV); /* SET THE PARAMETER LIST POINTER TO
*                                 THE BUFFER DOPE VECTOR TO POINT TO
*                                 THE LOCAL BUFFER DOPE VECTOR       */
         LA    @F,LBDV                                            0035
         ST    @F,PARM                                            0035
*        R1PTR24 = ADDR(PARM); /* SET REGISTER 1 TO POINT TO THE
*                                 LOCAL COPY OF THE PARAMETER LIST   */
         LA    @1,PARM                                            0036
*
*/*SCAN0200:     S    IEFVSCN1: SCAN NEXT OPERAND */
*SCAN0200:
*        R15 = ADDR(IEFVSCN1); /* INVOKE IEFVSCN1 PASSING THAT
*                                 PARAMETER LIST                     */
SCAN0200 LA    @F,IEFVSCN1                                        0037
*        CALL SCN1;            /* (LBDV, PROCCA, SCADV, NUM, COMM)   */
         BALR  @E,@F                                              0038
*        R3FIXED = R15;        /* SAVE IEFVSCN1 RETURN CODE AS THE
*                                 SCAN CODE                          */
         LR    @3,@F                                              0039
*
*/*      D    (YES,SCAN0400,NO,SCN1RSCN)   IEFVSCN1 RETURN CODE = 4 */
*
*        /************************************************************/
*        /*   CONTINUE PROCESSING ACCORDING TO THE RETURN CODE       */
*        /*   RECEIVED FROM IEFVSCN1                                 */
*        /************************************************************/
*        /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/
*        /*   IF THE RETURN CODE WAS NOT EQUAL TO 4, SET THE RETURN  */
*        /*   CODE EQUAL TO THE RETURN CODE RETURNED BY IEFVSCN1.    */
*        /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/
*        IF R3FIXED ^= 4
*        THEN
         CH    @3,@D1                                             0040
*             GO TO SCN1RSCN;  /* RETURN TO THE INVOKER WITH A RETURN
*                                 CODE EQUAL TO THE SCAN CODE        */
         BC    07,SCN1RSCN                                        0041
*        /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/
*        /*   IF THE RETURN CODE WAS PRECISELY 4, ITERATE THE CALL   */
*        /*   TO IEFVSCN1                                            */
*        /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/
*
*/*SCAN0400:  P    (,SCAN0200)
*/*                LBUFFER = SUBSTR( LBUFFER, NUMSCAN) */
*
*        ELSE
*SCAN0400:    DO;
*             /*******************************************************/
*             /*   UPDATE THE LOCAL BUFFER DOPE VECTOR TO REFLECT    */
*             /*   THE UNSCANNED PORTION OF THE BUFFER               */
*             /*******************************************************/
*             LBDVBUF = BDVBUF + NUMSCAN; /* THE ORIGIN OF THE BUF-
*                                 FER IS THE ORIGINAL ORIGIN PLUS
*                                 THE NUMBER OF BYTES WHICH HAVE
*                                 BEEN SCANNED                       */
SCAN0400 LH    @F,8(0,@6)                                         0043
         A     @F,0(0,@5)                                         0043
         ST    @F,LBDV                                            0043
*             LBDVLEN = BDVLEN - NUMSCAN; /* THE LENGTH OF THE BUFFER
*                                 IS THE ORIGINAL LENGTH MINUS THE
*                                 NUMBER OF BYTES WHICH HAVE BEEN
*                                 SCANNED                            */
         LH    @F,8(0,@6)                                         0044
         LCR   @F,@F                                              0044
         AH    @F,6(0,@5)                                         0044
         STH   @F,LBDV+6                                          0044
*             LBDVMX = LBDVLEN; /* THE BUFFER PASSED TO IEFVSCN1 NEXT
*                                 SHOULD CONTAIN ONLY THOSE BYTES
*                                 WHICH HAVE NOT YET BEEN SCANNED.   */
         MVC   LBDV+4(2),LBDV+6                                   0045
*             GO TO SCAN0200;  /* ITERATE THE CALL TO IEFVSCN1       */
         BC    15,SCAN0200                                        0046
*             END SCAN0400;
*/*IEFVSCN1:  E    SINGLE OPERAND SCAN FUNCTION */
*
*        /************************************************************/
*        /*   PRODUCE AN IDENTIFIER FOR ENTRY POINT IEFVSCN1         */
*        /************************************************************/
*        GENERATE;
** /*
        TITLE 'IEFVSCAN -- TABLE-DRIVEN SYNTAX SCAN -- SINGLE OPERAND  S
               CAN FUNCTION'
IEFVSCN1 DS  0H        SINGLE OPERAND SCAN ENTRY POINT
SCN10001 B   SCN10003-SCN10001(0,R15) BRANCH AROUND IDENTIFIER
         DC  AL1(L'SCN10002)     LENGTH OF IDENTIFIER
SCN10002 DC  C'IEFVSCN1&LUPDAT'  IDENTIFIER
** */
         DS    0H
         BC    15,@9FF                                            0049
*SCN10003:/***********************************************************/
*/*      ENTRY POINT IEFVSCN1                                        */
*/********************************************************************/
*        ENTRY;                /* (BDV, PROCCA, SCADV, NUM, COMM)    */
SCN10003 STM   @E,@C,12(@D)                                       0049
@9FF     EQU   *                                                  0049
*        RELEASE(R5PTR24);     /* ALLOW IMPLICIT USE OF REGISTER 5   */
*        RESPECIFY BDV BASED(PARMBDV); /* IN THIS PORTION OF THE MOD-
*                                 ULE THE BUFFER DOPE VECTOR SHOULD
*                                 BE LOCATED USING REGISTER 5.       */
*        /************************************************************/
*        /*   ESTABLISH ADDRESSIBILITY FOR ENTRY POINT IEFVSCN1      */
*        /************************************************************/
*        GENERATE;
        DROP R12,R13        INDICATE REGISTERS 12 AND 13 NOT VALID
        LR   R12,R15        LOAD ADDRESS OF IEFVSCN1
        LA   R15,IEFVSCN1-IEFVSCAN    LOAD OFFSET OF IEFVSCN1
        SR   R12,R15        ESTABLISH IEFVSCAN ADDRESS AS BASE
        USING IEFVSCAN,R12  TELL THE ASSEMBLER
         DS    0H
*
*/*      S    PROLOGUE: COMMON INITIALIZATION */
*
*        CALL PROLOGUE;        /* PERFORM INITIALIZATION COMMON TO
*                                 IEFVSCAN AND IEFVSCN1 ENTRY POINTS */
         BAL   @E,PROLOGUE                                        0053
*        GENERATE(USING @DATD,R13      TELL THE ASSEMBLER); /* THE
*                                 PROLOGUE FUNCTION HAS NOW ESTAB-
*                                 LISHED ADDRESSIBILITY TO THE DYNAMIC
*                                 SAVE AREA THROUGH REGISTER 13      */
         USING @DATD,R13      TELL THE ASSEMBLER
         DS    0H
*
*/*      M    DBUF1 = BUFFER */
*
*        /************************************************************/
*        /*   INITIALIZE REGISTERS FOR OPERAND LOCATION              */
*        /************************************************************/
*        R4PTR24 = LBDVBUF;    /* DELIMITER BUFFER POINTER 1 CONTAINS
*                                 THE ADDRESS OF THE BUFFER SEGMENT
*                                 BEING SCANNED.  THIS IS INITIALLY
*                                 THE ADDRESS OF THE BUFFER          */
         L     @4,LBDV                                            0055
*        R3FIXED = LBDVLEN - 1;    /* DELIMITER BUFFER RESIDUE 1
*                                 CONTAINS THE LENGTH OF THE REMAINING
*                                 BUFFER MINUS 1 (TO FACILITATE ITS
*                                 USE IN SYSTEM/360 INSTRUCTIONS).
*                                 THIS VARIABLE IS INITIALLY SET TO
*                                 THE LENGTH OF THE BUFFER MINUS 1.  */
         LH    @3,@D2                                             0056
         AH    @3,LBDV+6                                          0056
*
*/*      M    OPERAND = DBUF1 */
*
*        ODVOPER = R4PTR24;    /* THE FIRST CHARACTER OF THE NEXT
*                                 OPERAND SHOULD BE THE FIRST CHARAC-
*                                 TER OF THE BUFFER                  */
         ST    @4,ODV                                             0057
*
*/*SCN10020:  S    DELIMIT: LOCATE NEXT DELIMITER CHARACTER */
*SCN10020:
*        CALL DELIMIT;         /* INVOKE THE DELIMIT INTERNAL SUBROU-
*                                 TINE TO LOCATE THE NEXT DELIMITER  */
SCN10020 BAL   @E,DELIMIT                                         0058
*
*/*SCN10040:  D    (YES,SCN1R40C,NO,SCN10060)
*/*                CHARACTER CODE = INVALID */
*
*SCN10040:/***********************************************************/
*        /*   USE A BRANCH TABLE UNLESS A HIGH CODE WAS OBTAINED FROM*/
*        /*   THE TRANSLATE AND TEST INSTRUCTION. IN THAT CASE SET A */
*        /*   RETURN CODE OF 1036 AND RETURN TO THE INVOKER.         */
*        /************************************************************/
*        IF R2FIXED > 6
*        THEN
SCN10040 CH    @2,@D3                                             0059
*             GO TO SCN1R40C;  /* SET THE RETURN CODE TO 1036 AND
*                                 RETURN TO THE INVOKER              */
         BC    02,SCN1R40C                                        0060
*
*/*SCN10060:  D    (00,SCN10100,01,SCN11100,02,SCN12100,
*/*                03,SCN13100,04,SCN14100,05,SCN15100,
*/*                06,SCN16100)
*/*                GO TO PROCESSOR(CHARACTER CODE) */
*
*      ELSE
*SCN10060:    DO;
*             R2FIXED = R2FIXED * 4;      /* SET REGISTER 2 FOR USE
*                                 AS AN INDEX INTO A BRANCH TABLE    */
SCN10060 SLA   @2,2                                               0062
*             /* CHARACTER CODE LESS THAN CODELUB. USE A BRANCH TABLE
*                TO INVOKE THE APPROPRIATE PROCESSOR, GIVEN THE LAST
*                CHARACTER CODE OBTAINED                            */
*             GENERATE;
        B    SCN10080(R2FIXED)   INVOKE APPROPRIATE PROCESSOR
SCN10080 B   SCN10100       CHARACTER CODE 0 PROCESSOR
        B    SCN11100       CHARACTER CODE 1 PROCESSOR
        B    SCN12100       CHARACTER CODE 2 PROCESSOR
        B    SCN13100       CHARACTER CODE 3 PROCESSOR
        B    SCN14100       CHARACTER CODE 4 PROCESSOR
        B    SCN15100       CHARACTER CODE 5 PROCESSOR
        B    SCN16100       CHARACTER CODE 6 PROCESSOR
         DS    0H
*             END SCN10060;
*/*SCN10100:  P    (,SCN12120)
*/*                DELIMITER CODE = 0 */
*SCN10100:
*        GO TO SCN12120;       /* END OF BUFFER ENCOUNTERED WITHOUT
*                                 LOCATING A DELIMITER CHARACTER.
*                                 SIMULATE LOCATING A CODE 1 CHARACTER
*                                 IN THE BYTE DIRECTLY FOLLOWING THE
*                                 BUFFER.                            */
         BC    15,SCN12120                                        0065
*/*SCN11100:  P    (,SCN12120)
*/*                DELIMITER CODE = 0 */
*
*SCN11100:/***********************************************************/
*        /*   A CODE 1 CHARACTER ENCOUNTERED.  SET THE DELIMITER     */
*        /*   CODE TO 0 AND PROCESS THE OPERAND. SIMPLY DROP THROUGH */
*        /*   TO SCN12100                                            */
*        /************************************************************/
*
*/*SCN12100:  P    (,SCN12120)
*/*                DELIMITER CODE = 4 */
*
*SCN12100:/***********************************************************/
*        /*   A CODE 2 CHARACTER ENCOUNTERED. SET THE DELIMITER CODE */
*        /*   TO 4 AND PROCESS THE OPERAND.                          */
*        /************************************************************/
*        R2FIXED = R2FIXED - 4;
SCN11100 EQU   *                                                  0066
SCN12100 SH    @2,@D1                                             0066
*
*/*SCN12120:  P    OPERAND = SUBSTR( OPERAND, 1, DLMTPTR) */
*SCN12120:
*        ODVLEN = R1PTR24 - ODVOPER; /* SET THE OPERAND LENGTH TO THE
*                                 DIFFERENCE OF THE DELIMITER POINTER
*                                 AND THE LOCATION OF THE INITIAL
*                                 CHARACTER OF THE OPERAND           */
SCN12120 LR    @F,@1                                              0067
         S     @F,ODV                                             0067
         STH   @F,ODV+6                                           0067
*        ODVMX = ODVLEN;       /* THE BUFFER CONTAINING THE OPERAND
*                                 IS THE SAME LENGTH AS THE OPERAND  */
         MVC   ODV+4(2),ODV+6                                     0068
*
*/*SCN12140:  S    UPDATREG: UPDATE SCAN VARIABLES */
*SCN12140:
*        CALL UPDATREG;        /* SET THE LOCAL BUFFER DOPE VECTOR TO
*                                 DESCRIBE THE UNSCANNED BYTES OF THE
*                                 BUFFER.  UPDATE DELIMITER POINTER 1
*                                 AND DELIMITER BUFFER RESIDUE 1 TO
*                                 DESCIBE THE UNSCANNED PORTION OF THE
*                                 BUFFER.                            */
SCN12140 BAL   @E,UPDATREG                                        0069
*
*/*SCN12160:  P    LBUFFER = DBUF1 */
*SCN12160:
*        LBDVBUF = R4PTR24;    /* SET THE LOCAL BUFFER DOPE VECTOR
*                                 ORIGIN POINTER TO POINT TO THE FIRST
*                                 UNSCANNED BYTE OF THE BUFFER       */
SCN12160 ST    @4,LBDV                                            0070
*        LBDVLEN = R3FIXED + 1;    /* SET THE LOCAL BUFFER DOPE VECTOR
*                                 LENGTH FIELD TO THE LENGTH OF THE
*                                 UNSCANNED BUFFER                   */
         LA    @F,1                                               0071
         AR    @F,@3                                              0071
         STH   @F,LBDV+6                                          0071
*        LBDVMX = LBDVLEN;     /* THE BUFFER PASSED TO IEFVSCAN OR
*                                 IEFVSCN1 NEXT SHOULD CONTAIN ONLY
*                                 THOSE BYTES WHICH HAVE NOT YET BEEN
*                                 MOVED                              */
         MVC   LBDV+4(2),LBDV+6                                   0072
*
*/*      P    NUMRCODE = DLMTCODE */
*
*        NUMRCODE = R2FIXED;   /* SET THE NUMERIC ARRAY RETURN CODE TO
*                                 THE DELIMITER CODE                 */
         STH   @2,10(0,@6)                                        0073
*
*/*      P    NUMOPER = NUMOPER + 1 */
*
*        NUMOPER = NUMOPER + 1;   /* INCREMENT THE NUMBER OF OPERANDS
*                                 ENCOUNTERED AT THIS LEVEL          */
         LA    @F,1                                               0074
         AH    @F,2(0,@6)                                         0074
         STH   @F,2(0,@6)                                         0074
*
*/*      P    NUMSCAN = NUMSCAN + LENGTH( LBUFFER) - LENGTH( BUFFER) */
*
*        NUMSCAN = NUMSCAN + LBDVBUF - BDVBUF; /* INCREMENT THE NUMBER
*                                 OF BYTES SCANNED DURING THIS INVO-
*                                 CATION OF IEFVSCN1                 */
         L     @5,PARM                                            0075
         L     @F,0(0,@5)                                         0075
         LCR   @F,@F                                              0075
         A     @F,LBDV                                            0075
         AH    @F,8(0,@6)                                         0075
         STH   @F,8(0,@6)                                         0075
*        PARMBDV = ADDR(LBDV); /* ALTER THE LOCAL COPY OF THE PARAME-
*                                 TER LIST TO POINT TO THE LOCAL BUFFER
*                                 DOPE VECTOR INSTEAD OF THE BUFFER
*                                 DOPE VECTOR WHICH WAS PASSED INTO
*                                 IEFVSCN1                           */
         LA    @F,LBDV                                            0076
         ST    @F,PARM                                            0076
*
*/*      P    SCE = SCA( NUMSNTX) */
*
*             RESTRICT(R5PTR24);/* SET THE POINTER TO THE SYNTAX CON-
*                                 TROL ARRAY ELEMENT FOR THE INPUT
*                                 SYNTAX.  RESERVE THE SYNTAX CONTROL
*                                 ARRAY POINTER FOR EXPLICIT REFER-
*                                 ENCES.                             */
*             R5PTR24 = ADDR(SCADV) + SCADVSCA;/* SET THE SYNTAX CON-
*                                 TROL ARRAY POINTER TO THE ADDRESS
*                                 OF THE SYNTAX CONTROL ARRAY        */
         L     @7,PARM+8           PARM                           0078
         LH    @F,0(0,@7)                                         0078
         ALR   @F,@7                                              0078
         LR    @5,@F                                              0078
*             SCEPTR = ADDR(SCA(NUMSNTX)); /* SET THE SYNTAX CONTROL
*                                 ARRAY ELEMENT POINTER TO ADDRESS OF
*                                 THE SYNTAX CONTROL ARRAY ELEMENT
*                                 FOR THE INPUT SYNTAX.              */
         LH    @B,6(0,@6)                                         0079
         BCTR  @B,0                                               0079
         SLA   @B,3                                               0079
         LA    @F,0(@B,@5)                                        0079
         ST    @F,SCEPTR                                          0079
*             RELEASE(R5PTR24);/* RELEASE THE SYNTAX CONTROL ARRAY
*                                 POINTER FOR IMPLICIT REFERENCES    */
*
*/*      D    (YES,SCN1R404,NO,SCN12180)
*/*           NUMSNTX > HBOUND(SCA) */
*
*        /************************************************************/
*        /*   IF THE SYNTAX INDICATED IS EXCESSIVE, SET THE RETURN   */
*        /*   CODE TO 1028 AND RETURN TO THE INVOKER                 */
*        /************************************************************/
*     IF NUMSNTX > SCADVMX
*        THEN
         LH    @F,2(0,@7)                                         0081
         CH    @F,6(0,@6)                                         0081
*             GO TO SCN1R404;  /* SET THE RETURN CODE TO 1028 AND RE-
*                                 TURN TO THE INVOKER                */
         BC    04,SCN1R404                                        0082
*        /************************************************************/
*        /*   IF THE SYNTAX INDICATED IS VALID, DETERMINE HOW THE    */
*        /*   OPERAND ENCOUNTERED IS TO BE PROCESSED.                */
*        /************************************************************/
*
*/*SCN12180:  D    (YES,SCN12200,NO,SCN12240)
*/*                LENGTH( OPERAND) > HBOUND( SCEKLDO -> KLCA) */
*
*        ELSE
*SCN12180:    DO;
*             R1PTR24 = ADDR(SCADV) + SCEKLDO; /* SET THE KEYWORD
*                                 LENGTH CONTROL ARRAY POINTER TO THE
*                                 KEYWORD LENGTH CONTROL ARRAY APPRO-
*                                 PRIATE TO THE SPECIFIED SYNTAX     */
SCN12180 L     @5,SCEPTR                                          0084
         LH    @F,4(0,@5)                                         0084
         L     @7,PARM+8           PARM                           0084
         ALR   @F,@7                                              0084
         LR    @1,@F                                              0084
*             /*******************************************************/
*             /*   IF THERE IS NO KEYWORD DEFINED WITH THE LENGTH    */
*             /*   OF THIS OPERAND, THEN PROCESS THE OPERAND AS A    */
*             /*   POSITIONAL.                                       */
*             /*******************************************************/
*             IF ODVLEN > SCEKLDMX
*             THEN
         SR    @F,@F                                              0085
         IC    @F,7(0,@5)                                         0085
         CH    @F,ODV+6                                           0085
         BC    10,@9FE                                            0085
*
*/*SCN12200:       D  (YES,SCN12220,NO,SCN1R400)
*/*                   HBOUND( SCEPDO -> PCA) = 0 */
*
*SCN12200:         DO;
*                  R2FIXED = SCEPDMX;/*
*                                   SET REGISTER 2 TO THE NUMBER OF
*                                 POSITIONAL OPERAND ENTRIES WHICH
*                                 ARE CONTAINED IN THE POSITIONAL
*                                 CONTROL ARRAY FOR THIS SYNTAX      */
SCN12200 L     @5,SCEPTR                                          0087
         LH    @2,2(0,@5)                                         0087
*                  IF R2FIXED = 0/*
*                                  IF THERE ARE NO ENTRIES IN THE
*                                 POSITIONAL CONTROL ARRAY, SET THE
*                                 RETURN CODE TO 1024 AND RETURN TO
*                                 THE CALLER.                        */
*                  THEN
         LTR   @2,@2                                              0088
*                     GO TO SCN1R400; /* SET THE RETURN CODE TO 1024
*                                 AND RETURN TO THE INVOKER.         */
         BC    08,SCN1R400                                        0089
*                  ELSE        /* IF SOME ENTRY EXISTS IN THE POSI-
*                                 TIONAL CONTROL ARRAY, THEN DETERMINE
*                                 HOW THE OPERAND SHOULD BE PROCESSED*/
*
*/*SCN12220:          P  NUMPOPER = NUMPOPER + 1 */
*
*SCN12220:            DO;
*                     NUMPOPER = NUMPOPER + 1;   /* INCREMENT THE
*                                 NUMBER OF POSITIONAL OPERANDS EN-
*                                 COUNTERED AT THIS LEVEL            */
SCN12220 LA    @F,1                                               0091
         AH    @F,4(0,@6)                                         0091
         STH   @F,4(0,@6)                                         0091
*                     R1PTR24 = ADDR(SCADV) + SCEPDO;/* SET THE
*                                 POSITIONAL CONTROL ARRAY POINTER
*                                 TO THE ADDRESS OF THE POSITIONAL
*                                 CONTROL ARRAY FOR THIS SYNTAX      */
         L     @5,SCEPTR                                          0092
         LH    @F,0(0,@5)                                         0092
         L     @7,PARM+8           PARM                           0092
         ALR   @F,@7                                              0092
         LR    @1,@F                                              0092
*
*/*                   D  (YES,,NO,SCN12230)
*/*                      NUMPOPER > HBOUND( SCEPDO -> PCA) */
*
*                     IF NUMPOPER > R2FIXED
*                     THEN     /* DETERMINE WHETHER MORE POSITIONAL
*                                 OPERANDS HAVE BEEN ENCOUNTERED THAN
*                                 THERE ARE ENTRIES IN THE POSITIONAL
*                                 CONTROL ARRAY                      */
         CH    @2,4(0,@6)                                         0093
         BC    10,@9FD                                            0093
*
*/*                      P  (,SCN12300)
*/*                         ADDR( SCEPDO -> PCA( HBOUND(
*/*                         SCEPDO -> PCA))) */
*
*                        R4PTR24 = ADDR(PCA(R2FIXED));/*
*                                                   IF SO, PROCESS
*                                 THE OPERAND USING THE FINAL ENTRY
*                                 IN THE POSITIONAL OPERAND CONTROL
*                                 ARRAY                              */
         LR    @B,@2                                              0094
         BCTR  @B,0                                               0094
         SLA   @B,2                                               0094
         LA    @4,0(@B,@1)                                        0094
         BC    15,@9FC                                            0095
*                     ELSE     /* IF NOT, PROCESS THE OPERAND USING
*                                 THE SPECIFIC ENTRY SPECIFIED FOR THE
*                                 (NUMPOPER)TH POSITIONAL OPERAND    */
*
*/*                      P  (,SCN12300)
*/*                         ADDR( SCEPDO -> PCA( NUMPOPER)) */
*
*                        R4PTR24 = ADDR(PCA(NUMPOPER));
@9FD     LH    @8,4(0,@6)                                         0095
         BCTR  @8,0                                               0095
         SLA   @8,2                                               0095
         LA    @4,0(@8,@1)                                        0095
*                     GO TO SCN12300; /* GO TO A COMMON SUBROUTINE TO
*                                 INVOKE THE USER-SUPPLIED PROCESSOR */
         BC    15,SCN12300                                        0096
*                     END SCN12220;
*                  END SCN12200;
*             /*******************************************************/
*             /*   DETERMINE WHETHER THE OPERAND SHOULD BE PROCESSED */
*             /*   AS A KEYWORD.                                     */
*             /*******************************************************/
*             ELSE
*
*/*SCN12240:       P  KCAPTR2 = NULL */
*
*SCN12240:         DO;
@9FE     EQU   *                                                  0099
*                  RESTRICT(R5PTR24, R7PTR24);/*
*                                       RESERVE REGISTERS FOR EXPLICIT
*                                 REFERENCE WITHIN THE ELSE CLAUSE   */
*                  KCAPTR2 = 0;    /* INITIALIZE THE POINTER TO THE
*                                 LAST KEYWORD CONTROL ARRAY ELEMENT
*                                 WHERE A MATCH WAS FOUND TO A NULL
*                                 VALUE.                             */
SCN12240 SR    @F,@F                                              0101
         ST    @F,KCAPTR2                                         0101
*
*/*                D  (YES,,NO,SCN12241)
*/*                   LENGTH( OPERAND) < LBOUND( SCEKLDO -> KLCA) */
*
*                  /**************************************************/
*                  /*   IF THE OPERAND IS SHORTER THAN ANY KEYWORD   */
*                  /*   DEFINED, BEGIN THE KEYWORD CHECK WITH THE    */
*                  /*   SHORTEST LENGTH KEYWORD(S) DEFINED.          */
*                  /**************************************************/
*                  IF ODVLEN < SCEKLDMN
*                  THEN
         L     @B,SCEPTR                                          0102
         IC    @F,6(0,@B)                                         0102
         CH    @F,ODV+6                                           0102
         BC    12,@9FB                                            0102
*
*/*                   P  (,SCN12242)
*/*                      KEYLEN = LBOUND( SCEKLDO -> KLCA) */
*
*                     R3FIXED = SCEKLDMN;/* INITIALIZE THE KEYWORD
*                                 LENGTH VARIABLE TO THE LENGTH OF
*                                 THE SHORTEST KEYWORD(S) DEFINED.   */
         SR    @3,@3                                              0103
         IC    @3,6(0,@B)                                         0103
*                  /**************************************************/
*                  /*   OTHERWISE, BEGIN THE KEYWORD CHECK WITH      */
*                  /*   KEYWORDS HAVING THE SAME LENGTH AS THE       */
*                  /*   OPERAND.                                     */
*                  /**************************************************/
*                  ELSE
*
*/*SCN12241:          P  (,SCN12242)
*/*                      KEYLEN = LENGTH( OPERAND) */
*
*                     R3FIXED = ODVLEN;/* INITIALIZE THE KEYWORD
*                                 LENGTH VARIABLE TO THE LENGTH OF
         BC    15,@9FA                                            0104
*                                 THE OPERAND.                       */
@9FB     LH    @3,ODV+6                                           0104
*
*/*SCN12242:       D  (YES,SCN12244,NO,SCN12276)
*/*                   KEYLEN > HBOUND( SCEKLDO -> KLCA) */
*
*SCN12242:         /**************************************************/
*                  /*   SEARCH FOR A MATCHING KEYWORD BEGINNING WITH */
*                  /*   KEYWORDS OF LENGTH = KEYLEN AND CONTINUE THE */
*                  /*   SEARCH UNTIL EITHER A PRECISE MATCH IS FOUND */
*                  /*   OR UNTIL ALL KEYWORDS FOR THIS SYNTAX HAVE   */
*                  /*   BEEN CHECKED.                                */
*                  /**************************************************/
*                  DO R3FIXED = R3FIXED
*                      TO SCEKLDMX
*                      BY 1;
@9FA     EQU   *                                                  0105
SCN12242 EQU   *                                                  0105
@DO9F9   L     @B,SCEPTR                                          0105
         SR    @F,@F                                              0105
         IC    @F,7(0,@B)                                         0105
         CR    @F,@3                                              0105
         BC    04,@DO9F6                                          0105
         BC    15,@DO9F7                                          0105
@DO9F8   LA    @F,1                                               0105
         AR    @3,@F                                              0105
         BC    15,@DO9F9                                          0105
@DO9F7   EQU   *                                                  0105
*
*/*SCN12244:       P  KCAPTR =
*/*                   ADDR( SCEKLDO -> KLCAKCA( KEYLEN) -> KCA(1) */
*
*SCN12244:         R4PTR24 =
*                     ADDR(SCADV) + KLCAKCA(R3FIXED);/* INITIALIZE THE
*                                 KEYWORD CONTROL ARRAY POINTER TO
*                                 POINT TO THE FIRST ELEMENT IN THE
*                                 KEYWORD CONTROL ARRAY FOR KEYWORDS
*                                 IN THIS SYNTAX AND HAVING LENGTH
*                                 = KEYLEN                           */
SCN12244 LR    @B,@3                                              0106
         BCTR  @B,0                                               0106
         SLA   @B,2                                               0106
         LH    @F,0(@B,@1)                                        0106
         L     @8,PARM+8           PARM                           0106
         ALR   @F,@8                                              0106
         LR    @4,@F                                              0106
*
*/*SCN12248:          P  R2 =
*/*                      HBOUND( SCEKLDO -> KLCAKCA( KEYLEN) -> KCA) */
*/*SCN12249:          D  (YES,SCN12276,NO,SCN12252)
*/*                      R2 = 0 */
*
*SCN12248:            /***********************************************/
*                     /*   PREPARE TO CHECK ALL KEYWORDS IN THE      */
*                     /*   KEYWORD CONTROL ARRAY AGAINST THE OPERAND.*/
*                     /***********************************************/
*                     DO R2FIXED = KLCAMX(R3FIXED)
*                        TO 1
*                        BY -1;
SCN12248 LR    @B,@3                                              0107
         BCTR  @B,0                                               0107
         SLA   @B,2                                               0107
         LH    @F,2(@B,@1)                                        0107
         LTR   @2,@F                                              0107
         BC    12,@DO9F4                                          0107
@DO9F5   EQU   *                                                  0107
*
*/*SCN12252:             D  (>,SCN12272,=,SCN12260,<,SCN12276)
*/*                         OPERAND = KCAPTR -> SUBSTR( KCEIMAG, 1,
*/*                         LENGTH( OPERAND)) */
*
*SCN12252:              DO R5PTR24 = 1
*                           TO ODVLEN
*                           BY 256;      /* CHECK AS MANY BYTES OF THE
*                                 OPERAND AGAINST THE KEYWORD MODEL
*                                 AS THE HARDWARE PERMITS IN ONE
*                                 COMPARISON.                        */
SCN12252 LA    @5,1                                               0108
         BC    15,@DO9F0                                          0108
*                        IF R5PTR24 + 256 > ODVLEN
*                        THEN
@DO9F1   LA    @F,256                                             0109
         AR    @F,@5                                              0109
         CH    @F,ODV+6                                           0109
         BC    12,@9ED                                            0109
*SCN12256:                  DO; /* IF NO MORE BYTES REMAIN TO BE COM-
*                                 PARED THAN THE HARDWARE PERMITS IN A
*                                 SINGLE COMPARISON, THIS COMPARISON
*                                 WILL ALLOW A FINAL CONCLUSION WHE-
*                                 THER THE KEYWORD AND THE OPERAND
*                                 MATCH.                             */
*                           /*****************************************/
*                           /*   IF THE OPERAND IS GREATER THAN THE  */
*                           /*   KEYWORD IMAGE, CHECK THE NEXT KEY-  */
*                           /*   WORD DEFINED WHICH HAS THIS LENGTH. */
*                           /*****************************************/
*                           IF OPERAND(R5PTR24:
*                              R5PTR24 + ODVLEN - 1) >
*                              KCAIMAG(R5PTR24:
*                              R5PTR24 + ODVLEN - 1)
*                           THEN
SCN12256 LR    @B,@5                                              0111
         LA    @E,3(@B,@4)                                        0111
         LH    @8,@D2                                             0111
         AH    @8,ODV+6                                           0111
         AR    @8,@5                                              0111
         SR    @8,@B                                              0111
         L     @9,ODV                                             0111
         LA    @A,0(@B,@9)                                        0111
         BCTR  @A,0                                               0111
         EX    @8,@CLC                                            0111
*                              GO TO SCN12272; /* ITERATE DO LOOP
*                                 SCN12248                           */
         BC    02,SCN12272                                        0112
*                           /*****************************************/
*                           /*   IF THE OPERAND IS LESS THAN THE     */
*                           /*   KEYWORD IMAGE, THERE ARE NO MORE    */
*                           /*   KEYWORDS WHICH HAVE LENGTH = KEYLEN */
*                           /*   AND WHICH ARE AS LOW IN THE COLLAT- */
*                           /*   ING SEQUENCE AS THE OPERAND. INCRE- */
*                           /*   MENT KEYLEN AND CHECK FOR KEYWORDS  */
*                           /*   OF A NEW LENGTH.                    */
*                           /*****************************************/
*                           ELSE IF
*                              OPERAND(R5PTR24:
*                              R5PTR24 + ODVLEN - 1) <
*                              KCAIMAG(R5PTR24:
*                              R5PTR24 + ODVLEN - 1)
*                           THEN
         LH    @8,@D2                                             0113
         AH    @8,ODV+6                                           0113
         AR    @8,@5                                              0113
         SR    @8,@B                                              0113
         EX    @8,@CLC                                            0113
*                              GO TO SCN12276; /* ITERATE DO LOOP
*                                 SCN12242                           */
         BC    04,SCN12276                                        0114
*                           /*****************************************/
*                           /*   IF THE OPERAND IS EQUAL TO THE      */
*                           /*   PORTION OF THE KEYWORD IMAGE        */
*                           /*   AGAINST WHICH IT WAS COMPARED,      */
*                           /*   ONE OF TWO CIRCUMSTANCES PREVAIL.   */
*                           /*   1. IF THE KEYWORD AND THE OPERAND   */
*                           /*      ARE THE SAME LENGTH, THEN THE    */
*                           /*      OPERAND SHOULD DEFINITELY BE     */
*                           /*      TREATED AS THIS KEYWORD.         */
*                           /*   2. IF THE OPERAND IS CONTAINED      */
*                           /*      WITHIN THE KEYWORD BUT IS ALSO   */
*                           /*      CONTAINED WITHIN ANOTHER         */
*                           /*      KEYWORD, IT SHOULD BE TREATED    */
*                           /*      AS A POSITIONAL.  HOWEVER, IF    */
*                           /*      THE OPERAND IS CONTAINED         */
*                           /*      WITHIN ONLY ONE KEYWORD, THEN    */
*                           /*      IT IS A VALID ABBREVIATION FOR   */
*                           /*      THAT KEYWORD AND SHOULD BE       */
*                           /*      TREATED AS THAT KEYWORD.         */
*                           /*****************************************/
*                           ELSE
*
*/*SCN12260:                   D  (YES,SCN12300,NO,)
*/*                               KEYLEN = LENGTH( OPERAND) */
*
*SCN12260:                     DO;
*                              IF R3FIXED = ODVLEN/* IF THE KEYWORD AND
*                                 THE OPERAND HAVE IDENTICAL LENGTHS,
*                                 THEN THE OPERAND SHOULD DEFINITELY
*                                 BE TREATED AS THE KEYWORD.         */
*                              THEN
SCN12260 CH    @3,ODV+6                                           0116
*                                 GO TO SCN12300; /* PROCESS THE OP-
*                                 ERAND AS THE KEYWORD               */
         BC    08,SCN12300                                        0117
*                              ELSE /* IF THE OPERAND IS A STRICT
*                                 SUBSET OF THE KEYWORD IMAGE AND A
*                                 SIMILAR MATCH HAS BEEN ENCOUNTERED
*                                 PREVIOUSLY, TREAT THE OPERAND AS A
*                                 POSITIONAL.  OTHERWISE, RETAIN THE
*                                 POSITION WHERE A MATCHING KEYWORD
*                                 WAS FOUND AND CONTINUE TO SEARCH
*                                 FOR OTHER MATCHES.                 */
*
*/*                               D  (YES,,NO,SCN12200)
*/*                                  KCAPTR2 = NULL */
*
*                                 IF KCAPTR2 ^= 0    /* IF ANOTHER
*                                 MATCH HAS ALREADY BEEN FOUND, PRO-
*                                 CESS THE OPERAND AS A POSITIONAL.  */
*                                 THEN
         SR    @F,@F                                              0118
         C     @F,KCAPTR2                                         0118
*                                    GO TO SCN12200; /* PROCESS THE
*                                    OPERAND AS A POSITIONAL.        */
         BC    07,SCN12200                                        0119
*                                 ELSE /* IF THIS IS THE FIRST KEYWORD
*                                 FOR WHICH THIS OPERAND IS A MATCH,
*                                 SAVE THE POSITION OF ITS KEYWORD
*                                 CONTROL ARRAY AND CONTINUE TO SEARCH
*                                 FOR OTHER MATCHING KEYWORDS        */
*
*/*                                  P  KCAPTR2 = KCAPTR */
*
*                                    KCAPTR2 = R4PTR24;/* SET THE
*                                      POINTER TO THE KEYWORD CONTROL
*                                      ARRAY WHERE A MATCH WAS FOUND.*/
         ST    @4,KCAPTR2                                         0120
*                              END SCN12260;
*                           END SCN12256;
*                        /********************************************/
*                        /*   IF MORE BYTES REMAIN TO BE COMPARED    */
*                        /*   THAN THE HARDWARE PERMITS IN A SINGLE  */
*                        /*   COMPARISON, THIS COMPARISON WILL ONLY  */
*                        /*   PERMIT ACTION BASED UPON AN UNEQUAL    */
*                        /*   COMPARISON WHILE DEFERRING ANY ACTION  */
*                        /*   TO BE TAKEN GIVEN A MATCH.             */
*                        /********************************************/
*                        ELSE
*SCN12264:                  DO;
         BC    15,@9EC                                            0123
@9ED     EQU   *                                                  0123
*                           /*****************************************/
*                           /*   IF THE OPERAND IS GREATER THAN THE  */
*                           /*   KEYWORD IMAGE,CHECK THE NEXT KEYWORD*/
*                           /*   DEFINED WHICH HAS THIS LENGTH.      */
*                           /*****************************************/
*                           IF OPERAND(R5PTR24:
*                              R5PTR24 + 255)
*                              > KCAIMAG(R5PTR24:
*                              R5PTR24 + 255)
*                           THEN
SCN12264 LR    @B,@5                                              0124
         LA    @E,3(@B,@4)                                        0124
         L     @8,ODV                                             0124
         LA    @A,0(@B,@8)                                        0124
         BCTR  @A,0                                               0124
         CLC   0(256,@A),0(@E)                                    0124
*                              GO TO SCN12272; /* ITERATE DO LOOP
*                                 SCN12248                           */
         BC    02,SCN12272                                        0125
*                           /*****************************************/
*                           /*   IF THE OPERAND IS LESS THAN THE KEY-*/
*                           /*   WORD IMAGE, THERE ARE NO MORE KEY-  */
*                           /*   WORDS WHICH HAVE LENGTH = KEYLEN AND*/
*                           /*   WHICH ARE AS LOW IN THE COLLATING   */
*                           /*   SEQUENCE AS THE OPERAND.  INCREMENT */
*                           /*   KEYLEN AND CHECK FOR KEYWORDS OF A  */
*                           /*   NEW LENGTH.                         */
*                           /*****************************************/
*                           ELSE IF OPERAND(R5PTR24:
*                              R5PTR24 + 255)
*                              < KCAIMAG(R5PTR24:
*                              R5PTR24 + 255)
*                           THEN
         CLC   0(256,@A),0(@E)                                    0126
*                              GO TO SCN12276; /* ITERATE DO LOOP
*                                 SCN12242                           */
         BC    04,SCN12276                                        0127
*                           /*****************************************/
*                           /*   IF THE PORTION OF THE KEYWORD       */
*                           /*   AND THE OPERAND WHICH HAVE BEEN     */
*                           /*   COMPARED MATCH, CONTINUE THE        */
*                           /*   COMPARISON.                         */
*                           /*****************************************/
*                           ELSE; /* NO PROCESSING                   */
*                           END SCN12264;
*                        END SCN12252; /* END OF LOOP TO PERFORM
*                                 COMPARISON OF AN OPERAND AND ONE
*                                 KEYWORD IMAGE                      */
*
*/*SCN12272:          P  KCAPTR = KCAPTR + LENGTH( KCE) */
*SCN12272:
*                     R4PTR24 = R4PTR24 + R3FIXED
*                        + 4;       /* UPDATE KEYWORD CONTROL ARRAY
*                                 ELEMENT POINTER TO POINT TO THE NEXT
*                                 ELEMENT IN THE ARRAY.              */
@9EC     AH    @5,@D4                                             0130
@DO9F0   CH    @5,ODV+6                                           0130
         BC    12,@DO9F1                                          0130
SCN12272 LA    @4,4(@3,@4)                                        0131
*
*/*                   P  (,SCN12249)
*/*                      R2 = R2 - 1 */
*
*                     END SCN12248; /* END OF LOOP TO PERFORM COMPAR-
*                                 ISON OF AN OPERAND AND THE KEYWORD
*                                 IMAGES WITHIN ONE KEYWORD CONTROL
*                                 ARRAY.                             */
*
*/*SCN12276:       P  (,SCN12242)
*/*                   KEYLEN = KEYLEN + 1 */
*SCN12276:
*                  END SCN12242; /* END OF LOOP TO PERFORM A COMPAR-
*                                 ISON OF AN OPERAND AND THE KEYWORD
*                                 IMAGES FOR THE INPUT SYNTAX.       */
         BCT   @2,@DO9F5                                          0132
@DO9F4   EQU   *                                                  0132
SCN12276 EQU   *                                                  0133
*
*/*                D  (YES,SCN12200,NO,)
*/*                   KCAPTR2 = NULL */
*
*                  /**************************************************/
*                  /*   IF THE OPERAND IS NEITHER AN IMAGE NOR AN    */
*                  /*   UNAMBIGUOUS TRUNCATION FOR A KEYWORD OF THIS */
*                  /*   SYNTAX, IT SHOULD BE PROCESSED AS A          */
*                  /*   POSITIONAL OPERAND.                          */
*                  /**************************************************/
         BC    15,@DO9F8                                          0133
*                  IF KCAPTR2 = 0
*                  THEN
@DO9F6   SR    @F,@F                                              0134
         C     @F,KCAPTR2                                         0134
*                     GO TO SCN12200; /* PROCESS THE OPERAND AS A
*                                 POSITIONAL                         */
         BC    08,SCN12200                                        0135
*                  /**************************************************/
*                  /*   IF THE OPERAND IS AN UNAMBIGUOUS TRUNCATION  */
*                  /*   FOR A KEYWORD OF THIS SYNTAX, PROCESS THE    */
*                  /*   OPERAND AS THAT KEYWORD.                     */
*                  /**************************************************/
*                  ELSE
*
*/*                   P  KCAPTR = KCAPTR2 */
*
*                     R4PTR24 = KCAPTR2;/* SET THE KEYWORD CONTROL
*                                 ARRAY ELEMENT POINTER TO POINT TO
*                                 THE KEYWORD CONTROL ARRAY ELEMENT
*                                 FOR THE KEYWORD WHICH CONTAINED THE
*                                 OPERAND.                           */
         L     @4,KCAPTR2                                         0136
*                  RELEASE(R5PTR24, R7PTR24);/*
*                                      ALLOW IMPLICIT REFERENCES TO A
*                                 REGISTER                           */
*                  END SCN12240;
*             END SCN12180;
*
*/*SCN12300:     P    PROCNDX = KCAPTR -> KCAPROC */
*
*SCN12300:/***********************************************************/
*        /*   DETERMINE OPERAND PROCESSOR                            */
*        /************************************************************/
*        R3FIXED = KCAPROC;    /* SET THE PROCESSOR INDEX TO THE
*                                 PROCESSOR CODE FOR THE OPERAND
*                                 PROCESSOR                          */
SCN12300 MVC   @TEMP2+2(2),0(@4)                                  0140
         L     @3,@TEMP2                                          0140
*
*/*      D    (YES,SCN1R400,NO,SCN12320)
*/*           PROCNDX = 0 */
*
*        IF R3FIXED = 0        /* IF NO PROCESSOR IS SPECIFIED TO
*                                 HANDLE THE OPERAND, SET THE RETURN
*                                 CODE TO 1024 AND RETURN TO THE
*                                 CALLER                             */
*        THEN
         LTR   @3,@3                                              0141
*             GO TO SCN1R400;  /* SET THE RETURN CODE TO 1024 AND
*                                 RETURN TO THE CALLER               */
         BC    08,SCN1R400                                        0142
*        ELSE                  /* IF A PROCESSOR IS SPECIFIED TO
*                                 HANDLE THE OPERAND, INVOKE THE
*                                 PROCESSOR.                         */
*
*/*SCN12320:  S    OPERPROC: CALL PROCCA( PROCNDX) */
*SCN12320:
*             DO;
*             PARMODV = ADDR(ODV); /* SET THE OPERAND DOPE VECTOR
*                                 POINTER IN THE PARAMETER LIST TO THE
*                                 OPERAND PROCESSOR TO THE ADDRESS OF
*                                 THE OPERAND DOPE VECTOR.           */
SCN12320 LA    @F,ODV                                             0144
         ST    @F,PARM+20                                         0144
*             R1PTR24 = ADDR(PARMNUM);/*
*                                    SET REGISTER 1 TO POINT TO THE
*                                 PARAMETER LIST TO THE OPERAND
*                                 PROCESSOR                          */
         LA    @1,PARM+12                                         0145
*             R15 = PROCCA(R3FIXED) + ADDR(PROCCA); /* OBTAIN THE
*                                 ADDRESS OF THE PROCESSOR TO BE
*                                 INVOKED IN REGISTER 15.            */
         L     @5,PARM+4           PARM                           0146
         LR    @F,@5                                              0146
         LR    @7,@3                                              0146
         BCTR  @7,0                                               0146
         SLA   @7,1                                               0146
         AH    @F,0(@7,@5)                                        0146
*             CALL OPERPROC;   /* (NUM, COMM, ODV)                   */
         BALR  @E,@F                                              0147
*                              /* INVOKE THE OPERAND PROCESSOR       */
*
*/*           P    SCAN CODE = OPERPROC RETURN CODE */
*
*             /*******************************************************/
*             /*   IF THE RETURN CODE FROM THE OPERAND PROCESSOR     */
*             /*   WAS ZERO, CONTINUE PROCESSING ACCORDING TO THE    */
*             /*   DELIMITER CODE FOR THE RIGHT DELIMITER OF THE     */
*             /*   OPERAND.  OTHERWISE, RETURN TO THE INVOKER WITH   */
*             /*   A RETURN CODE OF 1028 IF THE PROCESSOR RETURN     */
*             /*   CODE WAS LESS THAN OR EQUAL TO 2048, THE          */
*             /*   PROCESSOR RETURN CODE OTHERWISE.                  */
*             /*******************************************************/
*             R3FIXED = R15;
         LR    @3,@F                                              0148
*
*/*           D    (YES,SCN12340,NO,SCN12350)
*/*                SCAN CODE = 0 */
*
*             IF R3FIXED ^= 0         /* IF THE RETURN CODE FROM THE
*                                 OPERAND PROCESSOR WAS NON-ZERO,
*                                 RETURN TO THE INVOKER OF IEFVSCN1
*                                 WITH THE SAME RETURN CODE AS THAT
*                                 SET BY THE OPERAND PROCESSOR       */
*
*/*SCN12340:       D  (YES,SCN1RSCN,NO,SCN1R404)
*/*                   OPERPROC RETURN CODE > 2044 */
*
*             THEN
         LTR   @3,@3                                              0149
         BC    08,@9EB                                            0149
*SCN12340:         DO;
*                  IF R3FIXED <= 2044      /* IF THE EXIT ROUTINE
*                                 PASSED AN INVALID RETURN CODE, SET
*                                 THE SCAN CODE TO 1028 AND RETURN TO
*                                 THE INVOKER                        */
*                  THEN
SCN12340 CH    @3,@D5                                             0151
*                     GO TO SCN1R404; /* SET THE RETURN CODE TO 1028
*                                 AND RETURN TO THE INVOKER          */
         BC    12,SCN1R404                                        0152
*                  ELSE        /* IF THE EXIT ROUTINE PASSED A VALID,
*                                 NON-ZERO RETURN CODE, RETURN TO THE
*                                 INVOKER WITH THE RETURN CODE PASSED
*                                 BY THE EXIT ROUTINE                */
*                     GO TO SCN1RSCN; /* SET THE RETURN CODE TO THE
*                                 SCAN CODE AND RETURN TO THE INVOKER*/
         BC    15,SCN1RSCN                                        0153
*                  END SCN12340;
*
*/*SCN12250:  P    SCANCODE = NUMRCODE */
*
*             R3FIXED = NUMRCODE;  /* SET THE SCAN CODE TO THE LAST
*                                 DELIMITER CODE                     */
@9EB     LH    @3,10(0,@6)                                        0155
*
*/*           D    (YES,SCN1RSCN,NO,SCN12360)
*/*                SCANCODE > 24 */
*
*             /*******************************************************/
*             /*   IF THE DELIMITER CODE FOR THE LAST OPERAND WAS    */
*             /*   HIGHER THAN 24, SET THE RETURN CODE EQUAL TO      */
*             /*   THAT DELIMITER CODE AND RETURN CONTROL TO THE     */
*             /*   INVOKER                                           */
*             /*******************************************************/
*             IF R3FIXED > 24
*             THEN
         CH    @3,@D6                                             0156
*                  GO TO SCN1RSCN; /* BRANCH TO A COMMON ROUTINE TO
*                                 CLEAN UP AND RETURN TO THE INVOKER */
         BC    02,SCN1RSCN                                        0157
*             /*******************************************************/
*             /*   IF THE LAST DELIMITER CODE WAS LESS THAN 24,      */
*             /*   CONTINUE PROCESSING ACCORDING TO THE DELIMITER    */
*             /*   CODE                                              */
*             /*******************************************************/
*             ELSE
*
*/*SCN12360:       P  LNUMLEVEL = LNUMLEVEL + 1 */
*
*SCN12360:         DO;
*                  LNUMLEVL = NUMLEVEL + 1;   /* SET THE LEVEL NUMBER
*                                 FOR THE NEXT IEFVSCAN OR IEFVSCN1
*                                 TO BE RECURSIVELY INVOKED          */
SCN12360 LA    @F,1                                               0159
         AH    @F,0(0,@6)                                         0159
         STH   @F,LNUM                                            0159
*                  PARMNUM = ADDR(LNUM); /* SET THE NUMERIC ARRAY
*                                 POINTER IN THE PARAMETER LIST TO
*                                 IEFVSCAN OR IEFVSCN1 TO POINT TO
*                                 THE LOCAL NUMERIC ARRAY.           */
         LA    @F,LNUM                                            0160
         ST    @F,PARM+12                                         0160
*
*/*                P  LNUMSNTX = KCAPTR -> KCASNO */
*
*                  LNUMSNTX = KCASNO; /* SET THE SYNTAX NUMBER FOR
*                                 THE NEXT IEFVSCAN OR IEFVSCN1 TO
*                                 BE INVOKED                         */
         MVC   LNUM+6(2),2(@4)                                    0161
*
*/*                D  (000,SCN1R000,004,SCN1R004,008,SCN12400,
*/*                   00C,SCN12420,010,SCN1R008,014,SCN1R00C,
*/*                   018,SCN1R010)  GO TO PROCESSOR( SCAN CODE) */
*
*                  /* BRANCH TO AN APPROPRIATE PROCESSOR FOR EACH
*                     DELIMITER                                      */
*                  GENERATE;
        B    SCN12380(R3FIXED)   INVOKE APPROPRIATE PROCESSOR
SCN12380 B   SCN1R000       DELIMITER CODE 0 PROCESSOR
        B    SCN1R004       DELIMITER CODE 4 PROCESSOR
        B    SCN12400       DELIMITER CODE 8 PROCESSOR
        B    SCN12420       DELIMITER CODE 12 PROCESSOR
        B    SCN1R008       DELIMITER CODE 16 PROCESSOR
        B    SCN1R00C       DELIMITER CODE 20 PROCESSOR
        B    SCN1R010       DELIMITER CODE 24 PROCESSOR
         DS    0H
*
*/*SCN12400:       S  IEFVSCN1: SCAN A SINGLE OPERAND */
*SCN12400:
*                  /**************************************************/
*                  /*   IF THE LAST DELIMITER CODE WAS 8, SET        */
*                  /*   REGISTER 1 TO POINT TO THE PARAMETER LIST    */
*                  /*   AND INVOKER IEFVSCN1; THEN RETURN CONTROL    */
*                  /*   TO THE INVOKER OF IEFVSCN1 WITH THE SAME     */
*                  /*   RETURN CODE AS THAT PASSED BY IEFVSCN1       */
*                  /**************************************************/
*                     R1PTR24 = ADDR(PARM);/*
*                                         SET REGISTER 1 TO THE AD-
*                                 DRESS OF THE LOCAL COPY OF THE PA-
*                                 RAMETER LIST TO IEFVSCN1           */
SCN12400 LA    @1,PARM                                            0163
*                     R15 = ADDR(IEFVSCN1);
         LA    @F,IEFVSCN1                                        0164
*                     CALL SCN1; /* INVOKE IEFVSCN1                  */
         BALR  @E,@F                                              0165
*
*/*                   P  SCAN CODE = IEFVSCN1 RETURN CODE */
*
*                     R3FIXED = R15;  /* SET THE SCAN CODE TO THE
*                                 VALUE RETURNED BY IEFVSCN1 AS A
*                                 RETURN CODE                        */
         LR    @3,@F                                              0166
*
*/*                   D  (YES,,NO,SCN1RSCN)
*/*                      SCAN CODE > 16 */
*
*                     /***********************************************/
*                     /*   IF THE RETURN CODE TO BE RETURNED IS TO   */
*                     /*   BE HIGHER THAN 16, TRANSCRIBE PART OF     */
*                     /*   THE LOCAL NUMERIC ARRAY TO THE NUMERIC    */
*                     /*   ARRAY TO FLAG THE SITUATION WHERE THE     */
*                     /*   PROBLEM AROSE.                            */
*                     /***********************************************/
*                     IF R3FIXED > 16
*                     THEN
         CH    @3,@D7                                             0167
         BC    12,@9EA                                            0167
*
*/*                      P  (,SCN1RSCN) NUMA = LNUMA */
*
*                        NUMA = LNUMA; /* COPY THE A-PORTION OF THE
*                                 LOCAL NUMERIC ARRAY TO THE NUMERIC
*                                 ARRAY                              */
         MVC   0(8,@6),LNUM                                       0168
*                        GO TO SCN1RSCN; /* RETURN TO THE INVOKER
*                                 WITH THE SAME RETURN CODE AS THAT
*                                 JUST RETURNED BY IEFVSCN1          */
         BC    15,SCN1RSCN                                        0169
*
*/*SCN12420:       S  IEFVSCAN: SCAN MULTIPLE OPERANDS */
*
*SCN12420:         /**************************************************/
*                  /*   IF THE LAST DELIMITER CODE WAS 12, SET       */
*                  /*   REGISTER 1 TO POINT TO THE PARAMETER LIST    */
*                  /*   AND INVOKE IEFVSCAN; THEN RETURN CONTROL     */
*                  /*   TO THE INVOKER OF IEFVSCN1 WITH A RETURN     */
*                  /*   CODE DEPENDENT UPON THAT RETURNED BY IEFVSCAN*/
*                  /**************************************************/
*                     R1PTR24 = ADDR(PARM);/*
*                                         SET REGISTER 1 TO THE
*                                 ADDRESS OF THE LOCAL COPY OF THE
*                                 PARAMETER LIST TO IEFVSCN1         */
SCN12420 LA    @1,PARM                                            0170
*                     R15 = R12; /* R15 = ADDR(IEFVSCAN)             */
         LR    @F,@C                                              0171
*                     CALL SCAN; /* INVOKE IEFVSCAN                  */
         BALR  @E,@F                                              0172
*
*/*                   P  SCAN CODE = IEFVSCAN RETURN CODE */
*
*                     R3FIXED = R15;  /* SAVE THE RETURN CODE FROM
*                                 IEFVSCAN IN THE SCAN CODE          */
         LR    @3,@F                                              0173
*
*/*                   D  (YES,SCN12430,NO,SCN12440)
*/*                      SCAN CODE > 16 */
*
*                     /***********************************************/
*                     /*   IF THE RETURN CODE FROM IEFVSCAN WAS      */
*                     /*   GREATER THAN 16, THEN RETURN TO THE       */
*                     /*   INVOKER OF IEFVSCN1 WITH THE SAME         */
*                     /*   RETURN CODE JUST PASSED BY IEFVSCAN       */
*                     /***********************************************/
*                     IF R3FIXED > 16
*                     THEN
         CH    @3,@D7                                             0174
         BC    12,@9E9                                            0174
*
*/*SCN12430:             P  (,SCN1RSCN) NUMA = LNUMA */
*
*SCN12430:               DO;
*                        NUMA = LNUMA; /* COPY THE A-PORTION OF THE
*                                 LOCAL NUMERIC ARRAY TO THE NUMERIC
*                                 ARRAY                              */
SCN12430 MVC   0(8,@6),LNUM                                       0176
*                        GO TO SCN1RSCN; /* SET THE RETURN CODE TO THE
*                                 SCAN CODE AND RETURN TO THE INVOKER*/
         BC    15,SCN1RSCN                                        0177
*                        END SCN12430;
*
*/*SCN12440:          D  (000,SCN1R408,004,SCN1R408,008,SCN1R004,
*/*                      00C,SCN1R000,010,SCN12500)
*/*                      GO TO PROCESSOR( SCAN CODE) */
*
*                     /***********************************************/
*                     /*   IF THE RETURN CODE FROM IEFVSCAN WAS      */
*                     /*   LESS THAN OR EQUAL TO 16, BRANCH TO       */
*                     /*   AN APPROPRIATE PROCESSOR ACCORDING        */
*                     /*   TO THE IEFVSCAN RETURN CODE               */
*                     /***********************************************/
*                     GENERATE;
@9E9     EQU   *                                                  0179
        B    SCN12440(R3FIXED)   INVOKE APPROPRIATE PROCESSOR
SCN12440 B   SCN1R408       RETURN CODE 0 PROCESSOR
        B    SCN1R408       RETURN CODE 4 PROCESSOR
        B    SCN1R004       RETURN CODE 8 PROCESSOR
        B    SCN1R000       RETURN CODE 12 PROCESSOR
*       FINAL BRANCH NO-OP BECAUSE DESTINATION DIRECTLY FOLLOWS
*       B    SCN12500       RETURN CODE 16 PROCESSOR
         DS    0H
*
*/*SCN12500:          P  DBUF1 = SUBSTR( LBUFFER, LNUMSCAN) */
*
*SCN12500:            R4PTR24 = LBDVBUF + LNUMSCAN;  /* SET DELIMITER
*                                 BUFFER POINTER 1 TO POINT TO THE
*                                 FIRST UNSCANNED BYTE OF THE INPUT
*                                 BUFFER.                            */
SCN12500 LH    @4,LNUM+8                                          0180
         A     @4,LBDV                                            0180
*                     R3FIXED = LBDVLEN - LNUMSCAN - 1;    /* SET
*                                 DELIMITER BUFFER RESIDUE 1 TO THE
*                                 NUMBER OF UNSCANNED BYTES IN THE
*                                 INPUT BUFFER LESS ONE              */
         LH    @3,@D2                                             0181
         SH    @3,LNUM+8                                          0181
         AH    @3,LBDV+6                                          0181
*
*/*                   S  DELIMIT: LOCATE NEXT DELIMITER CHARACTER */
*
*                     CALL DELIMIT; /* INVOKE THE DELIMIT INTERNAL
*                                 SUBROUTINE ORDER TO LOCATE THE NEXT
*                                 DELIMITER CHARACTER                */
         BAL   @E,DELIMIT                                         0182
*
*/*                   D  (YES,SCN12510,NO,SCN12520)
*/*                      DLMTPTR = 1  CHARACTER CODE ^= 5 */
*
*                     /***********************************************/
*                     /*   IF THE DELIMITER CHARACTER WAS NOT IN     */
*                     /*   THE FIRST POSITION IN THE REMAINING       */
*                     /*   BUFFER OR THE DELIMITER CHARACTER WAS     */
*                     /*   NOT A CODE 5 CHARACTER, RETURN TO THE     */
*                     /*   INVOKER INDICATING A DELIMITER ERROR.     */
*                     /***********************************************/
*                     IF R1PTR24 > R4PTR24 
*                        R2FIXED ^= 5
*                     THEN
         CR    @1,@4                                              0183
         BC    02,@9E8                                            0183
         CH    @2,@D8                                             0183
         BC    08,@9E7                                            0183
*
*/*SCN12510:             P  (,SCN12600) SCAN CODE = 1032 */
*
*SCN12510:               DO;
@9E8     EQU   *                                                  0184
*                        R3FIXED = 1032;      /*  SET THE SCAN CODE
*                                 TO INDICATE A DELIMITER ERROR      */
SCN12510 LA    @3,1032                                            0185
*                        GO TO SCN12600; /* UPDATE THE LOCAL NUMERIC
*                                 ARRAY TO INDICATE THE STATUS OF THE
*                                 SCAN AT THE TIME THAT THE DELIMITER
*                                 ERROR WAS ENCOUNTERED, SET THE RETURN
*                                 CODE TO INDICATE A DELIMITER ERROR,
*                                 AND RETURN TO THE INVOKER          */
         BC    15,SCN12600                                        0186
*                        END SCN12510;
*                     /***********************************************/
*                     /*   IF THE DELIMITER CHARACTER APPEARED IN    */
*                     /*   THE FIRST REMAINING POSITION IN THE       */
*                     /*   BUFFER AND THE CHARACTER WAS A CODE 5     */
*                     /*   DELIMITER CHARACTER, CONTINUE TO SCAN     */
*                     /*   IN ORDER TO DETERMINE WHICH DELIMITER     */
*                     /*   TERMINATES THE FIELD.                     */
*                     /***********************************************/
*                     ELSE
*
*/*SCN12510:             S  UPDATREG: UPDATE SCAN VARIABLES */
*
*SCN12520:               DO;
@9E7     EQU   *                                                  0188
*                        CALL UPDATREG; /* RESET THE SCAN VARIABLES
*                                 TO REFLECT THE REMAINING, UNSCANNED
*                                 BUFFER                             */
SCN12520 BAL   @E,UPDATREG                                        0189
*
*/*                      S  DELIMIT: LOCATE NEXT DELIMITER CHARACTER */
*
*                        CALL DELIMIT; /* INVOKE THE DELIMIT INTERNAL
*                                 SUBROUTINE IN ORDER TO LOCATE THE
*                                 NEXT DELIMITER CHARACTER.          */
         BAL   @E,DELIMIT                                         0190
*
*/*                      D  (YES,SCN12540,NO,SCN12560)
*/*                         DLMTPTR > 1  CHARACTER CODE ^= 02 */
*
*                        IF R1PTR24 > R4PTR24
*                            R2FIXED ^= 2
*                        THEN  /* IF NO DELIMITER CHARACTER WAS LO-
*                                 CATED IN THE FIRST REMAINING BYTE
*                                 OF THE BUFFER, RETURN TO THE WITH
*                                 RETURN CODE 16                     */
         CR    @1,@4                                              0191
         BC    02,@9E6                                            0191
         CH    @2,@D9                                             0191
         BC    08,@9E5                                            0191
*
*/*SCN12540:                P  (,SCN12600) SCAN CODE = 16 */
*
*SCN12540:                  DO;
@9E6     EQU   *                                                  0192
*                           R3FIXED = 16;        /* SET THE SCAN CODE
*                                 TO 16                              */
SCN12540 LA    @3,16                                              0193
*                           GO TO SCN12600; /* UPDATE THE LOCAL NU-
*                                 MERIC ARRAY TO INCICATE THE STATUS
*                                 OF THE SCAN AT THE TIME THAT THE
*                                 DELIMITER ERROR WAS ENCOUNTERED,
*                                 SET THE RETURN CODE TO INDICATE A
*                                 DELIMITER ERROR, AND RETURN TO THE
*                                 INVOKER                            */
         BC    15,SCN12600                                        0194
*                           END SCN12540;
*                        /********************************************/
*                        /*   IF A DELIMITER CHARACTER WAS LOCATED   */
*                        /*   IN THE FIRST REMAINING POSITION IN     */
*                        /*   THE BUFFER, DETERMINE THE DELIMITER    */
*                        /*   ENCOUNTERED.                           */
*                        /********************************************/
*                        ELSE
*
*/*SCN12560:                P  SCAN CODE = 16 */
*
*SCN12560:                  DO;
@9E5     EQU   *                                                  0196
*                           R3FIXED = 16;        /* SET THE SCAN CODE
*                                 TO 16                              */
SCN12560 LA    @3,16                                              0197
*
*/*SCN12600:                P  (,SCN1RSCN)
*/*                            LNUMSCAN =
*/*                            LENGTH( BUFFER) - LENGTH( LBUFFER) */
*
*SCN12600:                  LNUMSCAN =
*                              R1PTR24 - LBDVBUF + 1;   /* UPDATE THE
*                                 LOCAL NUMERIC ARRAY TO REFLECT ALL
*                                 BYTES SCANNED DURING THE NEXT LEVEL
*                                 OF IEFVSCAN OR IEFVSCN1 AND DURING
*                                 THE PERIOD SUBSEQUENT TO THE RETURN
*                                 FROM THEM                          */
SCN12600 LA    @F,1                                               0198
         S     @F,LBDV                                            0198
         AR    @F,@1                                              0198
         STH   @F,LNUM+8                                          0198
*                           GO TO SCN1RSCN; /* SET THE RETURN CODE
*                                 TO THE SCAN CODE AND RETURN TO THE
*                                 INVOKER                            */
         BC    15,SCN1RSCN                                        0199
*                           END SCN12560;
*                        END SCN12520;
*                  END SCN12360;
*             END SCN12320;
*SCN13100:/***********************************************************/
*        /*   A CODE 3 CHARACTER ENCOUNTERED.  DETERMINE DELIMITER   */
*        /*   CODE AND PROCESS THE OPERAND                           */
*        /************************************************************/
*        ODVLEN = R1PTR24 - ODVOPER; /* SET THE OPERAND LENGTH TO THE
*                                 DIFFERENCE OF THE DELIMITER POINTER
*                                 AND THE LOCATION OF THE INITIAL
*                                 CHARACTER OF THE OPERAND           */
SCN13100 LR    @F,@1                                              0204
         S     @F,ODV                                             0204
         STH   @F,ODV+6                                           0204
*        ODVMX = ODVLEN;       /* SET THE BUFFER LENGTH EQUAL TO THE
*                                 OPERAND LENGTH                     */
         MVC   ODV+4(2),ODV+6                                     0205
*        CALL UPDATREG;        /* RESET THE SCAN VARIABLES TO REFLECT
*                                 THE REMAINING, UNSCANNED BUFFER    */
         BAL   @E,UPDATREG                                        0206
*        CALL DELIMIT;         /* LOCATE THE NEXT DELIMITER CHARACTER
*                                 WITHIN THE BUFFER                  */
         BAL   @E,DELIMIT                                         0207
*        /************************************************************/
*        /*   IF A CODE 4 CHARACTER WAS ENCOUNTERED IN THE POSITION  */
*        /*   ADJACENT TO THE CODE 3 CHARACTER, SET THE DELIMITER    */
*        /*   CODE TO 12.  PROCESS THE OPERAND.                      */
*        /************************************************************/
*        IF R2FIXED = 4
*             & R1PTR24 <= R4PTR24
*        THEN
         CH    @2,@D1                                             0208
         BC    07,@9E4                                            0208
         CR    @1,@4                                              0208
         BC    02,@9E3                                            0208
*SCN13120:    DO;
*             R2FIXED = 12;        /* SET THE DELIMITER CODE TO 12   */
SCN13120 LA    @2,12                                              0210
*             GO TO SCN12140;  /* PROCESS THE OPERAND                */
         BC    15,SCN12140                                        0211
*             END SCN13120;
*        /************************************************************/
*        /*   IF A CODE 4 CHARACTER WAS NOT ENCOUNTERED OR THE       */
*        /*   POSITION IN WHICH IT WAS ENCOUNTERED WAS NOT ADJACENT  */
*        /*   TO THE CODE 3 CHARACTER, SET THE DELIMITER CODE TO     */
*        /*   8 AND PROCESS THE OPERAND.                             */
*        /************************************************************/
*        ELSE
*SCN13140:    DO;
@9E3     EQU   *                                                  0213
@9E4     EQU   *                                                  0213
*             R2FIXED = 8;         /* SET THE DELIMITER CODE TO 8    */
SCN13140 LA    @2,8                                               0214
*             GO TO SCN12160;  /* PROCESS THE OPERAND.               */
         BC    15,SCN12160                                        0215
*             END SCN13140;
*SCN14100:/***********************************************************/
*        /*   A CODE 4 CHARACTER ENCOUNTERED.  SCAN TO A BALANCING   */
*        /*   CODE 5 CHARACTER TO IDENTIFY AN OPERAND.               */
*        /************************************************************/
*        CALL UPDATREG;        /* UPDATE THE DELIMITER SCAN INPUT
*                                 VARIABLES TO REFLECT THE REMAINING
*                                 UNSCANNED BUFFER                   */
SCN14100 BAL   @E,UPDATREG                                        0217
*        RESTRICT(R5PTR24);    /* RESERVE REGISTER 5 FOR EXPLICIT
*                                 REFERENCES                         */
*             R5PTR24 = 1;     /* SET THE NUMBER OF CODE 4 CHARACTERS
*                                 ENCOUNTERED TO 1                   */
         LA    @5,1                                               0219
*             ODVOPER = R1PTR24; /* INDICATE THAT THE OPERAND ORIGIN
*                                 IS THE CODE 4 CHARACTER            */
         ST    @1,ODV                                             0220
*SCN14140:    CALL DELIMIT;    /* INVOKE THE DELIMIT FUNCTION TO LOCATE
*                                 THE NEXT DELIMITER IN THE STREAM   */
SCN14140 BAL   @E,DELIMIT                                         0221
*             IF R2FIXED >= 6
*             THEN             /* TAKE ACTION ACCORDING TO THE CHAR-
*                                 ACTER CODE ENCOUNTERED NEXT WITHIN
*                                 THE TEXT                           */
         CH    @2,@D3                                             0222
*                  GO TO SCN1R40C; /* RETURN TO THE INVOKER INDICATING
*                                 THAT AN INVALID CHARACTER WAS
*                                 ENCOUNTERED                        */
         BC    10,SCN1R40C                                        0223
*             /*******************************************************/
*             /*   IF A VALID CHARACTER WAS LOCATED WITHIN THE       */
*             /*   BUFFER, USE A BRANCH TABLE TO INVOKE AN APPRO-    */
*             /*   PRIATE PROCESSOR FOR THE DELIMITER CHARACTER      */
*             /*******************************************************/
*             ELSE
*SCN14160:         DO;
*                  R2FIXED = R2FIXED * 4;      /* ADJUST THE CHARACTER
*                                 CODE FOR USE IN A BRANCH TABLE     */
SCN14160 SLA   @2,2                                               0225
*                  /* BRANCH TO A PROCESSOR TO HANDLE THE DELIMITER
*                     CHARACTER ENCOUNTERED                          */
*                  GENERATE;
        B    SCN14180(R2FIXED)   INVOKE APPROPRIATE PROCESSOR
SCN14180 B   SCN1R408  CHARACTER CODE 0 PROCESSOR
        B    SCN1R408  CHARACTER CODE 1 PROCESSOR
        B    SCN14200  CHARACTER CODE 2 PROCESSOR
        B    SCN14200  CHARACTER CODE 3 PROCESSOR
        B    SCN14220  CHARACTER CODE 4 PROCESSOR
        B    SCN14240  CHARACTER CODE 5 PROCESSOR
        B    SCN14280  CHARACTER CODE 6 PROCESSOR
         DS    0H
*                  END SCN14160;
*SCN14200:    /*******************************************************/
*             /*   COMMON PROCESSING FUNCTION TO CONTINUE THE SCAN   */
*             /*   FOR A BALANCING CODE 5 CHARACTER WITHIN AN        */
*             /*   OPERAND WITH A CODE 4 CHARACTER AS ITS INITIAL    */
*             /*   CHARACTER.  THIS FUNCTION IS INVOKED IMMEDIATELY  */
*             /*   AFTER A CODE 2 OR 3 CHARACTER IS ENCOUNTERED      */
*             /*   WITHIN SUCH AN OPERAND, AFTER PRELIMINARY         */
*             /*   PROCESSING FOR OTHER DELIMITERS.                  */
*             /*******************************************************/
*             CALL UPDATREG;   /* INVOKE UPDATREG                    */
SCN14200 BAL   @E,UPDATREG                                        0228
*             GO TO SCN14140;  /* ITERATE THE DELIMITER SCAN FOR THE
*                                 END OF THE OPERAND                 */
         BC    15,SCN14140                                        0229
*SCN14220:    /*******************************************************/
*             /*   A CODE 4 CHARACTER ENCOUNTERED WITHIN AN OPERAND  */
*             /*   BOUNDED ON THE LEFT BY A CODE 4 CHARACTER.        */
*             /*******************************************************/
*             R5PTR24 = R5PTR24 + 1; /* INCREMENT PARENTHESIS COUNTER*/
SCN14220 LA    @5,1(0,@5)                                         0230
*             GO TO SCN14200;  /* ITERATE THE DELIMITER SCAN         */
         BC    15,SCN14200                                        0231
*SCN14240:    /*******************************************************/
*             /*   A CODE 5 CHARACTER ENCOUNTERED WITHIN AN OPERAND  */
*             /*   BOUNDED ON THE LEFT BY A CODE 4 CHARACTER.        */
*             /*******************************************************/
*             R5PTR24 = R5PTR24 - 1; /* DECREMENT THE CODE 4 CHARACTER
*                                 COUNTER                            */
SCN14240 BCTR  @5,0                                               0232
*             IF R5PTR24 > 0
*             THEN             /* IF THE CODE 4 CHARACTER COUNT IS
*                                 GREATER THAN ZERO, THEN LOOP BACK
*                                 TO FIND THE NEXT DELIMITER.        */
         LTR   @5,@5                                              0233
*                  GO TO SCN14200; /* SCAN FOR THE NEXT DELIMITER
*                                 CHARACTER                          */
         BC    02,SCN14200                                        0234
*             ELSE             /* IF THE CODE 4 CHARACTER COUNT IS
*                                 ZERO OR LESS, FIND THE TERMINAL
*                                 DELIMITER FOR THE OPERAND.         */
*SCN14260:         DO;
*                  CALL UPDATREG; /* RESET THE SCAN REGISTERS FOR A
*                                 CONTINUED SCAN                     */
SCN14260 BAL   @E,UPDATREG                                        0236
*                  GO TO SCN10020; /* RESUME THE SCAN FOR THE TERMINAL
*                                 FIELD DELIMITER                    */
         BC    15,SCN10020                                        0237
*                  END SCN14260;
*             RESPECIFY
*                  R7PTR24 RESTRICTED;  /* RESERVE A REGISTER FOR
*                                 EXPLICIT REFERENCE                 */
*SCN14280:    /*******************************************************/
*             /*   A CODE 6 CHARACTER ENCOUNTERED WITHIN AN OPERAND  */
*             /*   BOUNDED ON THE LEFT BY A CODE 4 CHARACTER         */
*             /*******************************************************/
*             R7PTR24 = R1PTR24;  /* SAVE THE LOCATION OF THE CODE 6
*                                 CHARACTER                          */
SCN14280 LR    @7,@1                                              0240
*             CALL UPDATREG;   /* RESET THE SCAN VARIABLES FOR A
*                                 CONTINUED SCAN                     */
         BAL   @E,UPDATREG                                        0241
*SCN14300:    CALL DELIMIT;    /* SCAN FOR THE NEXT DELIMITER
*                                 CHARACTER                          */
SCN14300 BAL   @E,DELIMIT                                         0242
*             IF R2FIXED = 0
*             THEN             /* IF NO DELIMITER IS PRESENT IN THE
*                                 REMAINING BUFFER, RETURN TO THE IN-
*                                 VOKER INDICATING A DELIMITER ERROR */
         LTR   @2,@2                                              0243
*                  GO TO SCN1R408; /* SET THE RETURN CODE TO INDICATE
*                                 A DELIMITER ERROR AND RETURN TO THE
*                                 INVOKER                            */
         BC    08,SCN1R408                                        0244
*             ELSE             /* IF A DELIMITER CHARACTER IS PRESENT
*                                 IN THE REMAINING BUFFER, DETERMINE
*                                 WHETHER IT IS A MATCHING CODE 6
*                                 CHARACTER                          */
*SCN14320:         DO;
*                  CALL UPDATREG; /* RESET THE SCAN VARIABLES FOR A
*                                 CONTINUED SCAN                     */
SCN14320 BAL   @E,UPDATREG                                        0246
*                  IF R2FIXED = 6 &
*                     R1PTR24 -> BUFFER(1:1) =
*                     R7PTR24 -> BUFFER(1:1)
*                  THEN        /* IF A MATCHING CODE 6 CHARACTER WAS
*                                 FOUND, RESUME THE SCAN FOR A BAL-
*                                 ANCING CODE 5 CHARACTER            */
         CH    @2,@D3                                             0247
         BC    07,@9E2                                            0247
         CLC   0(1,@1),0(@7)                                      0247
*                     GO TO SCN14140; /* RESUME THE SCAN FOR A BAL-
*                                 ANCING CODE 5 CHARACTER            */
         BC    08,SCN14140                                        0248
*                  ELSE        /* IF NO MATCHING CODE 6 CHARACTER WAS
*                                 FOUND, CHECK FOR THE END OF BUFFER
*                                 AND RESUME THE SCAN IF IT HAS NOT
*                                 BEEN REACHED.                      */
*SCN14360:            DO;
@9E1     EQU   *                                                  0249
@9E2     EQU   *                                                  0249
*                     IF R3FIXED < 0
*                     THEN     /* IF THE ENTIRE BUFFER HAS BEEN SCANNED
*                                 WITHOUT LOCATING A BALANCING CODE 6
*                                 CHARACTER, RETURN TO THE INVOKER
*                                 INDICATING A DELIMITER ERROR       */
SCN14360 LTR   @3,@3                                              0250
*                        GO TO SCN1R408; /* SET THE RETURN CODE TO
*                                 INDICATE A DELIMITER ERROR AND
*                                 RETURN TO THE INVOKER              */
         BC    04,SCN1R408                                        0251
*                     ELSE     /* IF THE ENTIRE BUFFER HAS NOT BEEN
*                                 SCANNED, CONTINUE TO SEARCH FOR A
*                                 BALANCING CODE 6 CHARACTER         */
*                        GO TO SCN14300; /* CONTINUE THE SCAN FOR A
*                                 MATCHING CODE 6 CHARACTER          */
         BC    15,SCN14300                                        0252
*                     END SCN14360;
*                  END SCN14320;
*             RESPECIFY
*                  (R7PTR24,
*                  R5PTR24) UNRESTRICTED;/* ALLOW IMPLICIT REFERENCES
*                                 TO SEVERAL REGISTERS               */
*SCN15100:/***********************************************************/
*        /*   A CODE 5 CHARACTER ENCOUNTERED. DETERMINE DELIMITER    */
*        /*   CODE AND PROCESS THE OPERAND.                          */
*        /************************************************************/
*        ODVLEN = R1PTR24 - ODVOPER; /* SET THE OPERAND LENGTH TO THE
*                                 DIFFERENCE OF THE DELIMITER POINTER
*                                 AND THE LOCATION OF THE INITIAL
*                                 CHARACTER OF THE OPERAND           */
SCN15100 LR    @F,@1                                              0256
         S     @F,ODV                                             0256
         STH   @F,ODV+6                                           0256
*        ODVMX = ODVLEN;       /* SET THE OPERAND BUFFER LENGTH EQUAL
*                                 TO THE LENGTH OF                   */
         MVC   ODV+4(2),ODV+6                                     0257
*        CALL UPDATREG;        /* RESET THE SCAN REGISTERS TO REFLECT
*                                 THE REMAINING UNSCANNED BUFFER     */
         BAL   @E,UPDATREG                                        0258
*        CALL DELIMIT;         /* LOCATE THE NEXT DELIMITER CHARACTER
*                                 WITHIN THE BUFFER                  */
         BAL   @E,DELIMIT                                         0259
*        IF R1PTR24 > R4PTR24
*        THEN
         CR    @1,@4                                              0260
*             GO TO SCN15250;
         BC    02,SCN15250                                        0261
*        ELSE
*             IF R2FIXED <= 1
*             THEN
         CH    @2,@D10                                            0262
         BC    02,@9E0                                            0262
*SCN15150:         DO;
*                  R2FIXED = 20;
SCN15150 LA    @2,20                                              0264
*                  GO TO SCN12140;
         BC    15,SCN12140                                        0265
*                  END SCN15150;
*             ELSE
*                  IF R2FIXED = 2
*                  THEN
@9E0     CH    @2,@D9                                             0267
         BC    07,@9DF                                            0267
*SCN15200:            DO;
*                     R2FIXED = 16;
SCN15200 LA    @2,16                                              0269
*                     GO TO SCN12140;
         BC    15,SCN12140                                        0270
*                     END SCN15200;
*                  ELSE
*SCN15250:            DO;
@9DF     EQU   *                                                  0272
*                     R2FIXED = 24;
SCN15250 LA    @2,24                                              0273
*                     GO TO SCN12160;
         BC    15,SCN12160                                        0274
*                     END SCN15250;
*        RESPECIFY
*             R7PTR24 RESTRICTED;  /* RESERVE A REGISTER FOR EXPLICIT
*                                 REFERENCES                         */
*SCN16100:/***********************************************************/
*        /*   A CODE 6 CHARACTER ENCOUNTERED. SCAN TO A BALANCING    */
*        /*   CODE 6 CHARACTER                                       */
*        /************************************************************/
*             R7PTR24 = R1PTR24;
SCN16100 LR    @7,@1                                              0277
*             CALL UPDATREG;
         BAL   @E,UPDATREG                                        0278
*SCN16150:    CALL DELIMIT;
SCN16150 BAL   @E,DELIMIT                                         0279
*             IF R2FIXED = 0
*             THEN
         LTR   @2,@2                                              0280
*                  GO TO SCN1R408;
         BC    08,SCN1R408                                        0281
*             ELSE
*SCN16200:         DO;
*                  CALL UPDATREG;
SCN16200 BAL   @E,UPDATREG                                        0283
*                  IF R2FIXED = 6 &
*                     R1PTR24 -> BUFFER(1:1) =
*                     R7PTR24 -> BUFFER(1:1)
*                  THEN
         CH    @2,@D3                                             0284
         BC    07,@9DE                                            0284
         CLC   0(1,@1),0(@7)                                      0284
         BC    07,@9DD                                            0284
*SCN16300:            DO;
*                     IF R3FIXED < 0
*                     THEN
SCN16300 LTR   @3,@3                                              0286
         BC    10,@9DC                                            0286
*SCN16400:               DO;
*                        R2FIXED = 0;
SCN16400 SR    @2,@2                                              0288
*                        ODVLEN = R1PTR24 - ODVOPER;
         LR    @F,@1                                              0289
         S     @F,ODV                                             0289
         STH   @F,ODV+6                                           0289
*                        ODVMX = ODVLEN;
         MVC   ODV+4(2),ODV+6                                     0290
*                        GO TO SCN12160;
         BC    15,SCN12160                                        0291
*                        END SCN16400;
*                     ELSE
*                        GO TO SCN10020;
*                     END SCN16300;
*                  ELSE
*SCN16500:            DO;
@9DD     EQU   *                                                  0295
@9DE     EQU   *                                                  0295
*                     IF R3FIXED < 0
*                     THEN
SCN16500 LTR   @3,@3                                              0296
*                        GO TO SCN1R408;
         BC    04,SCN1R408                                        0297
*                     ELSE
*                        GO TO SCN16150;
         BC    15,SCN16150                                        0298
*                     END SCN16500;
*                  END SCN16200;
@9DB     EQU   *                                                  0300
*        RESPECIFY
*             R7PTR24 UNRESTRICTED;  /* ALLOW IMPLICIT REFERENCES TO
*                                 A REGISTER                         */
*SCN1R000:    R3FIXED = 0;         /* SET SCAN CODE TO 0 AND BRANCH
*                                 TO A COMMON EXIT FUNCTION          */
SCN1R000 SR    @3,@3                                              0302
*             GO TO SCN1RSCN;
         BC    15,SCN1RSCN                                        0303
*SCN1R004:    R3FIXED = 4;         /* SET SCAN CODE TO 4 AND BRANCH
*                                 TO A COMMON EXIT FUNCTION          */
SCN1R004 LA    @3,4                                               0304
*             GO TO SCN1RSCN;
         BC    15,SCN1RSCN                                        0305
*SCN1R008:    R3FIXED = 8;         /* SET SCAN CODE TO 8 AND BRANCH
*                                 TO A COMMON EXIT FUNCTION          */
SCN1R008 LA    @3,8                                               0306
*             GO TO SCN1RSCN;
         BC    15,SCN1RSCN                                        0307
*SCN1R00C:    R3FIXED = 12;        /* SET SCAN CODE TO 12 AND BRANCH
*                                 TO A COMMON EXIT FUNCTION          */
SCN1R00C LA    @3,12                                              0308
*             GO TO SCN1RSCN;
         BC    15,SCN1RSCN                                        0309
*SCN1R010:    R3FIXED = 16;        /* SET SCAN CODE TO 16 AND BRANCH
*                                 TO A COMMON EXIT FUNCTION          */
SCN1R010 LA    @3,16                                              0310
*             GO TO SCN1RSCN;
         BC    15,SCN1RSCN                                        0311
*SCN1R400:    R3FIXED = 1024;      /* SET SCAN CODE TO 1024 AND BRANCH
*                                 TO A COMMON EXIT FUNCTION          */
SCN1R400 LA    @3,1024                                            0312
*             GO TO SCN1RSCN;
         BC    15,SCN1RSCN                                        0313
*SCN1R404:    R3FIXED = 1028;      /* SET SCAN CODE TO 1028 AND BRANCH
*                                 TO A COMMON EXIT FUNCTION          */
SCN1R404 LA    @3,1028                                            0314
*             GO TO SCN1RSCN;
         BC    15,SCN1RSCN                                        0315
*SCN1R408:    R3FIXED = 1032;      /* SET SCAN CODE TO 1032 AND BRANCH
*                                 TO A COMMON EXIT FUNCTION          */
SCN1R408 LA    @3,1032                                            0316
*             GO TO SCN1RSCN;
         BC    15,SCN1RSCN                                        0317
*SCN1R40C:    R3FIXED = 1036;      /* SET SCAN CODE TO 1036 AND BRANCH
*                                 TO A COMMON EXIT FUNCTION          */
SCN1R40C LA    @3,1036                                            0318
*             GO TO SCN1RSCN;
*SCN1RSCN:/***********************************************************/
*        /*   SET THE RETURN CODE TO THE VALUE CONTAINED IN SCAN     */
*        /*   CODE AND RESTORE THE NUMERIC ARRAY TO THE LEVEL WHICH  */
*        /*   SHOULD BE RETURNED TO THE INVOKER                      */
*        /************************************************************/
*        NUMRCODE = R3FIXED;   /* SET THE RETURN CODE TO THE VALUE
*                                 CONTAINED IN SCAN CODE.            */
SCN1RSCN STH   @3,10(0,@6)                                        0320
*SCN1RC: /************************************************************/
*        /*   COMMON EXIT ROUTINE FOR IEFVSCN1 AND FOR IEFVSCAN      */
*        /************************************************************/
*        NUMSCAN = NUMSCAN + LNUMSCAN; /* UPDATE THE NUMBER OF BYTES
*                                 WHICH HAVE BEEN SCANNED DURING THIS
*                                 INVOCATION OF THE SCAN             */
SCN1RC   LH    @F,LNUM+8                                          0321
         AH    @F,8(0,@6)                                         0321
         STH   @F,8(0,@6)                                         0321
*        R3FIXED = NUMRCODE;   /* SET SCAN CODE TO THE VALUE WHICH IS
*                                 TO BE USED AS A RETURN CODE        */
         LH    @3,10(0,@6)                                        0322
*        SAVELAST -> SAVER15 = R3FIXED;  /* SET UP RETURN CODE FOR
*                                 REGISTER 15                        */
         L     @5,4(0,@D)          
         ST    @3,16(0,@5)                                        0323
*        /************************************************************/
*        /*   PERFORM EPILOGUE FUNCTIONS                             */
*        /************************************************************/
*        R0FIXED = SAVEWRD1;   /* LOAD DSA SPECIFICATION             */
         L     @0,0(0,@D)                                         0324
*        R1PTR24 = R13;        /* LOAD DSA ADDRESS                   */
         LR    @1,@D                                              0325
*        R13 = SAVELAST;       /* RELOAD OLD SAVE AREA POINTER       */
         L     @D,4(0,@D)                                         0326
*        GENERATE;
** /*
        DROP R13                 INDICATE R13 NO LONGER VALID
        FREEMAIN R,LV=(0),A=(1)  RELEASE DSA
** */
         DS    0H
*        SAVERETF = 'FF'X;     /* INDICATE RETURN                    */
         MVI   12(@D),X'FF'                                       0328
*
*/*      R    RETURN TO INVOKER */
*
*        RETURN;               /* RETURN TO THE INVOKER              */
         BC    15,@EL01                                           0329
*PROLOGUE:/***********************************************************/
*/*      PROLOGUE -- COMMON INITIALIZATION FUNCTION FOR IEFVSCAN AND */
*/*           IEFVSCN1                                               */
*/*                                                                  */
*/*      INPUT -- REGISTER 13 POINTS TO A SAVE AREA WHICH IS         */
*/*           BACK-CHAINED IN A STANDARD MANNER TO THE SAVE AREA     */
*/*           WHICH WAS INPUT TO IEFVSCAN OR IEFVSCN1                */
*/*                                                                  */
*/*      OUTPUT -- A COPY OF THE INPUT PARAMETER LIST TO IEFVSCAN    */
*/*           OR IEFVSCN1 WILL HAVE BEEN TRANSCRIBED TO THE LOCAL    */
*/*           STRUCTURE PARM.  A LOCAL COPY OF THE BUFFER DOPE       */
*/*           VECTOR INPUT TO THE MODULE WILL BE PLACED IN LBDV.     */
*/*           THE NUMERIC ARRAY POINTER WILL BE SET TO THE ADDRESS   */
*/*           OF THE NUMERIC INPUT ARRAY.                            */
*/********************************************************************/
*        PROCEDURE OPTIONS(NOSAVEAREA, DONTSAVE);
@EL01    LM    @E,@C,12(@D)                                       0330
         BCR   15,@E                                              0330
PROLOGUE EQU   *                                                  0330
*        GENERATE;
** /*
        TITLE   'IEFVSCAN -- TABLE-DRIVEN SYNTAX SCAN -- INTERNAL COMM O
               N INITIALIZATION FUNCTION'
** */
         DS    0H
*        RESTRICT(R1PTR24, R2FIXED, R3FIXED,
*                 R4PTR24, R5PTR24, R6PTR24, R12);/*
*                                      RESERVE SEVERAL REGISTERS FOR
*                                 EXPLICIT CODE REFERENCES           */
*        R5PTR24 = R14;        /* SAVE RETURN ADDRESS IN REGISTER 5  */
         LR    @5,@E                                              0333
*        R4PTR24 = R1PTR24;    /* SAVE PARAMETER LIST POINTER IN
*                                 REGISTER 4                         */
         LR    @4,@1                                              0334
*        GENERATE;
** /*
        L    R0FIXED,@SIZ001     LOAD DSA SPECIFICATION
        GETMAIN R,LV=(0)         OBTAIN DSA
        MVC  SAVEWRD1-SAVEAREA(4,R1PTR24),@SIZ001 DSA DESCRIPTOR
** */
         DS    0H
*        R1PTR24 -> SAVELAST = R13;/*
*                                 CHAIN NEW SAVE AREA                */
         ST    @D,4(0,@1)                                         0336
*        SAVENEXT = R1PTR24;   /* CHAIN OLD SAVE AREA                */
         ST    @1,8(0,@D)                                         0337
*        R13 = R1PTR24;        /* LOAD DSA POINTER                   */
         LR    @D,@1                                              0338
*        GENERATE;
** /*
        USING @DATD,R13          TELL THE ASSEMBLER
        XC   @TEMPS(@L),@TEMPS   CLEAR TEMPORARIES FOR ALIGNMENT
** */
         DS    0H
*        PARM(1:20) =
*             R4PTR24 -> PARAM(1:20);         /* OBTAIN A LOCAL COPY
*                                 OF THE PARAMETER LIST              */
         MVC   PARM(20),0(@4)                                     0340
*        LNUM = LNUM && LNUM;  /* CLEAR THE LOCAL NUMERIC ARRAY      */
         XC    LNUM(12),LNUM                                      0341
*        LBDV = BDV;           /* OBTAIN A LOCAL COPY OF THE INPUT
*                                 BUFFER DOPE VECTOR                 */
         L     @7,PARM                                            0342
         MVC   LBDV(8),0(@7)                                      0342
*        R6PTR24 = PARMNUM;    /* SET THE NUMERIC ARRAY POINTER TO
*                                 POINT TO THE INPUT NUMERIC ARRAY   */
         L     @6,PARM+12                                         0343
*        R14 = R5PTR24;        /* RELOAD RETURN ADDRESS              */
         LR    @E,@5                                              0344
*        RETURN;               /* RETURN TO THE INVOKER              */
*        END PROLOGUE;         /* END OF PROLOGUE INTERNAL FUNCTION  */
@EL02    BCR   15,@E                                              0346
*UPDATREG:/***********************************************************/
*/*      UPDATREG -- INTERNAL FUNCTION RESPONSIBLE FOR RESETTING     */
*/*           DELIMITER BUFFER POINTER 1 AND DELIMITER BUFFER        */
*/*           RESIDUE 1 FOR CONTINUED SCAN GIVEN THE ADDRESS OF THE  */
*/*           LAST BYTE SCANNED IN DELIMITER POINTER, THE STATUS OF  */
*/*           THE SCAN DIRECTLY BEFORE REFLECTED IN DELIMITER        */
*/*           BUFFER POINTER 1 AND DELIMITER BUFFER RESIDUE 1.       */
*/*                                                                  */
*/*      INPUT -- THE DELIMITER POINTER MUST CONTAIN THE ADDRESS OF  */
*/*           THE LAST BYTE SCANNED.  DELIMITER BUFFER RESIDUE 1     */
*/*           MUST CONTAIN THE NUMBER OF BYTES WHICH REMAINED TO BE  */
*/*           SCANNED BEFORE THE LAST SCAN WAS MADE, AND DELIMITER   */
*/*           BUFFER POINTER 1 MUST CONTAIN THE ADDRESS OF THE FIRST */
*/*           BYTE SCANNED DURING THE PREVIOUS SCAN.                 */
*/*                                                                  */
*/*      OUTPUT -- DELIMIT BUFFER RESIDUE 1 WILL CONTAIN THE NUMBER  */
*/*           OF BYTES WHICH REMAIN TO BE SCANNED IN THE BUFFER, AND */
*/*           DELIMITER BUFFER POINTER 1 WILL CONTAIN A POINTER TO   */
*/*           THE FIRST UNSCANNED BYTE OF THE BUFFER.                */
*/********************************************************************/
*        PROCEDURE OPTIONS(NOSAVEAREA, DONTSAVE(3,4));
UPDATREG STM   @E,@2,12(@D)                                       0347
         STM   @5,@C,40(@D)                                       0347
*        RESTRICT(R1PTR24 ,R2FIXED ,R3FIXED,
*                 R4PTR24, R5PTR24, R6PTR24, R12);/*
*                                      RESERVE REGISTERS FOR EXPLICIT
*                                 REFERENCES                         */
*        GENERATE;
        TITLE 'IEFVSCAN -- TABLE-DRIVEN SYNTAX SCAN -- INTERNAL REGIST E
               R UPDATE FUNCTION'
         DS    0H
*        R3FIXED = R3FIXED + R4PTR24
*             - R1PTR24 - 1;   /* UPDATE THE BUFFER RESIDUE 1 TO
*                                 REFLECT THE BYTES SCANNED DURING
*                                 THE LAST CALL TO DELIMIT.          */
         LH    @F,@D2                                             0350
         SR    @F,@1                                              0350
         AR    @F,@4                                              0350
         AR    @3,@F                                              0350
*        R4PTR24 = R1PTR24 + 1;    /* UPDATE DELIMITER BUFFER POINTER
*                                 1 TO REFLECT THE BYTES SCANNED
*                                 DURING THE LAST CALL TO DELIMIT.   */
         LA    @4,1(0,@1)                                         0351
*        RETURN;               /* RETURN TO THE INVOKER              */
*        END UPDATREG;         /* END OF UPDATREG INTERNAL FUNCTION  */
@EL03    LM    @E,@2,12(@D)                                       0353
         LM    @5,@C,40(@D)                                       0353
         BCR   15,@E                                              0353
*DELIMIT:/************************************************************/
*/*      DELIMIT -- INTERNAL FUNCTION RESPOSIBLE FOR DRIVING A       */
*/*           TRANSLATE AND TEST ACROSS A VARIABLE LENGTH BUFFER     */
*/*                                                                  */
*/*      INPUT -- DELIMIT BUFFER POINTER 1 MUST CONTAIN THE ADDRESS  */
*/*           OF THE BUFFER WHICH IS TO BE SCANNED.  DELIMIT BUFFER  */
*/*           RESIDUE 1 MUST CONTAIN THE LENGTH OF THE BUFFER MINUS  */
*/*           1.                                                     */
*/*                                                                  */
*/*      OUTPUT -- DELIMIT BUFFER POINTER 1 WILL BE UNCHANGED AS     */
*/*           WILL BE DELIMIT BUFFER RESIDUE 1.  THE CHARACTER CODE  */
*/*           WILL CONTAIN ZERO IF NO DELIMITER WAS ENCOUNTERED, THE */
*/*           TRANSLATE AND TEST CODE FOR THE DELIMITER IF ONE WAS.  */
*/*           THE DELIMITER POINTER WILL CONTAIN THE ADDRESS OF THE  */
*/*           BYTE FOLLOWING THE LAST BYTE OF THE BUFFER IF NO       */
*/*           DELIMITER WAS                                          */
*/*           ENCOUNTERED, THE ADDRESS OF THE DELIMITER ITSELF       */
*/*           IF ONE WAS ENCOUNTERED.  ALL OTHER VARIABLES WILL BE   */
*/*           RETURNED TO THE INVOKER UNALTERED.                     */
*/********************************************************************/
*        PROCEDURE
*             OPTIONS(NOSAVEAREA,
*             DONTSAVE(1,2));
DELIMIT  STM   @E,@0,12(@D)                                       0354
         STM   @3,@C,32(@D)                                       0354
*        GENERATE;
        TITLE 'IEFVSCAN -- TABLE-DRIVEN SYNTAX SCAN -- INTERNAL DELIMI T
               ER CHARACTER LOCATION FUNCTION'
         DS    0H
*        /************************************************************/
*        /*   DEFINE THOSE VARIABLES KNOWN ONLY WITHIN THE DELIMIT   */
*        /*   SUBROUTINE                                             */
*        /************************************************************/
*        DECLARE
*        DLMT0050 STATIC LOCAL LABEL INTERNAL,
*        DLMT0100 STATIC LOCAL LABEL INTERNAL,
*        DLMT0200 STATIC LOCAL LABEL INTERNAL,
*        DLMT0300 STATIC LOCAL LABEL INTERNAL,
*        DLMT9990 STATIC LOCAL LABEL INTERNAL;
*        RESTRICT(R1PTR24, R2FIXED, R3FIXED,
*                 R4PTR24, R5PTR24, R6PTR24, R12);/*
*                                      RESERVE SEVERAL REGISTERS FOR
*                                 EXPLICIT CODE REFERENCES           */
*        R1PTR24 = R4PTR24;    /* SET DELIMIT BUFFER POINTER 2 TO THE
*                                 ADDRESS OF THE BUFFER.  DURING THE
*                                 EXECUTION OF THIS ROUTINE THIS
*                                 VARIABLE SHOULD ALWAYS CONTAIN THE
*                                 ADDRESS OF THE NEXT PART OF THE BUF-
*                                 FER TO WHICH THE TRANSLATE AND TEST
*                                 INSTRUCTION SHOULD BE DIRECTED     */
         LR    @1,@4                                              0358
*        R6PTR24 = R3FIXED;    /* SET DELIMIT BUFFER RESIDUE 2 TO THE
*                                 LENGTH OF THE BUFFER MINUS 1.  DURING
*                                 THE EXECUTION OF THIS ROUTINE THIS
*                                 VARIABLE SHOULD CONTAIN THE NUMBER
*                                 OF BYTES REMAINING TO BE SCANNED
*                                 MINUS 1.                           */
         LR    @6,@3                                              0359
*        R2FIXED = 0;          /* THE CHARACTER CODE IS SET BY THE
*                                 TRANSLATE AND TEST INSTRUCTION TO
*                                 THE CODE FOR THE DELIMITER.  THIS
*                                 IS INITIALLY ZERO, A VALUE WHICH
*                                 WILL BE RETAINED IF NO DELIMITER IS
*                                 ENCOUNTERED DURING THE TRANSLATE AND
*                                 TEST OPERATION                     */
         SR    @2,@2                                              0360
*        GO TO DLMT0270;       /* ENTER THE SCAN LOOP                */
         BC    15,DLMT0270                                        0361
*DLMT0050:/***********************************************************/
*        /*   IF THE REMAINING BUFFER EQUAL TO 256 BYTES IN LENGTH,  */
*        /*   SET A TRANSLATE AND TEST TO SCAN ONLY THE REMAINING    */
*        /*   BYTES OF THE BUFFER                                    */
*        /************************************************************/
*        IF R6PTR24 < 256 THEN
DLMT0050 CH    @6,@D4                                             0362
         BC    10,@9DA                                            0362
*DLMT0100:    DO;
*             R1PTR24 = R5PTR24 + R6PTR24 + 1;     /* SET THE DELIMI-
*                                 TER POINTER AS IF THE SCAN HAD ENDED
*                                 ON THE BYTE FOLLOWING THE BUFFER   */
DLMT0100 LA    @1,1(@6,@5)                                        0364
*             GENERATE(EX    R6PTR24,DLMT9990); /* EXECUTE A TRANSLATE
*                                 AND TEST INSTRUCTION TO ATTEMPT TO
*                                 LOCATE A DELIMITER WITHIN THE FINAL
*                                 BYTES OF THE BUFFER                */
         EX    R6PTR24,DLMT9990
         DS    0H
         BC    15,@9D9                                            0367
*             END DLMT0100;
*        /************************************************************/
*        /*   IF THE REMAINING BUFFER CONTAINS AT LEAST 256 BYTES    */
*        /*   OF DATA, TRANSLATE AND TEST THE NEXT 256 BYTES OF THE  */
*        /*   BUFFER IN SEARCH OF A DELIMITER.                       */
*        /************************************************************/
*        ELSE
*DLMT0200:    DO;
@9DA     EQU   *                                                  0367
*             R1PTR24 = R4PTR24 + 256;       /* SET THE DELIMITER
*                                 POINTER TO POINT TO THE BYTE
*                                 FOLLOWING THE LAST ONE TO BE
*                                 TRANSLATED.                        */
DLMT0200 LA    @1,256(0,@4)                                       0368
*             GENERATE(TRT   0(256,R5PTR24),TRTTAB); /* TRANSLATE AND
*                                 TEST OVER 256 BYTES OF THE BUFFER
*                                 IN SEARCH OF A DELIMITER           */
         TRT   0(256,R5PTR24),TRTTAB
         DS    0H
*             END DLMT0200;
*        /************************************************************/
*        /*   COMMON ROUTINE TO PROCESS THE RESULTS OF BOTH          */
*        /*   TRANSLATE AND TEST BRANCHES                            */
*        /************************************************************/
*        IF R2FIXED ^= 0 THEN        /* IF A NON-ZERO FUNCTION BYTE
*                                 WAS LOCATED BY THE TRANSLATE AND
*                                 TEST INSTRUCTION, RETURN THE
*                                 RESULT TO THE INVOKER              */
@9D9     LTR   @2,@2                                              0371
*             RETURN;          /* RETURN TO THE INVOKER              */
         BC    07,@EL04                                           0372
*        R6PTR24 = R6PTR24 + R5PTR24 - R1PTR24;    /* CALCULATE THE
*                                 NUMBER OF BYTES IN THE BUFFER WHICH
*                                 REMAIN TO BE SCANNED.  PLACE THE
*                                 RESULT, LESS 1 INTO DELIMITER BUFFER
*                                 RESIDUE 2.                         */
@9D8     LCR   @F,@1                                              0373
         AR    @F,@5                                              0373
         AR    @6,@F                                              0373
*DLMT0270:/***********************************************************/
*        /*   IF BYTES REMAIN TO BE SCANNED IN THE BUFFER, ITERATE   */
*        /*   THE SEARCH FOR A DELIMITER CHARACTER                   */
*        /************************************************************/
*        IF R6PTR24 >= 0 THEN
DLMT0270 LTR   @6,@6                                              0374
         BC    04,@9D7                                            0374
*DLMT0300:    DO;
*             R5PTR24 = R1PTR24;  /* SET DELIMIT BUFFER POINTER 2 TO
*                                 THE ADDRESS OF THE FIRST BYTE WHICH
*                                 HAS NOT BEEN SCANNED AS YET        */
DLMT0300 LR    @5,@1                                              0376
*             GO TO DLMT0050;  /* LOOP BACK TO SCAN MORE OF THE BUFFER
*                                 FOR A DELIMITER                    */
         BC    15,DLMT0050                                        0377
*             END DLMT0300;
*        /************************************************************/
*        /*   IF THE ENTIRE BUFFER HAS BEEN SCANNED WITHOUT          */
*        /*   LOCATING A DELIMITER, RETURN TO THE INVOKER WITH A     */
*        /*   CHARACTER CODE OF ZERO.                                */
*        /************************************************************/
*        ELSE RETURN;
*DLMT9990: GENERATE(TRT 0(1,R5PTR24),TRTTAB); /* TRANSLATE AND TEST
*                                 INSTRUCTION FOR REMOTE EXECUTION   */
DLMT9990 TRT 0(1,R5PTR24),TRTTAB
         DS    0H
*        END DELIMIT;          /* END OF THE DELIMIT SUBROUTINE      */
@EL04    LM    @E,@0,12(@D)                                       0381
         LM    @3,@C,32(@D)                                       0381
         BCR   15,@E                                              0381
*
*/*IEFVSCAN:  END */
*
*        END IEFVSCAN          /* END OF IEFVSCAN                    */
*/* THE FOLLOWING INCLUDE STATEMENTS WERE FOUND IN THIS PROGRAM.      *
*/*%INCLUDE SYSLIB  (IEFDCL1 )                                        *
*/*%INCLUDE SYSLIB  (IEFDCL2 )                                        *
*;
@DATA1   EQU   *
@0       EQU   00                  EQUATES FOR REGISTERS 0-15
@1       EQU   01
@2       EQU   02
@3       EQU   03
@4       EQU   04
@5       EQU   05
@6       EQU   06
@7       EQU   07
@8       EQU   08
@9       EQU   09
@A       EQU   10
@B       EQU   11
@C       EQU   12
@D       EQU   13
@E       EQU   14
@F       EQU   15
@D1      DC    H'4'
@D2      DC    H'-1'
@D3      DC    H'6'
@D4      DC    H'256'
@D5      DC    H'2044'
@D6      DC    H'24'
@D7      DC    H'16'
@D8      DC    H'5'
@D9      DC    H'2'
@D10     DC    H'1'
@CLC     CLC   0(1,@A),0(@E)
         DS    0F
@SIZ001  DC    AL1(&SPN)
         DC    AL3(@DATEND-@DATD)
         DS    0F
         DS    0D
@DATA    EQU   *
R0FIXED  EQU   00000000            FULLWORD POINTER REGISTER
R1PTR24  EQU   00000001            3  BYTE  POINTER REGISTER
R2FIXED  EQU   00000002            FULLWORD INTEGER REGISTER
R3FIXED  EQU   00000003            FULLWORD INTEGER REGISTER
R4PTR24  EQU   00000004            3  BYTE  POINTER REGISTER
R5PTR24  EQU   00000005            3  BYTE  POINTER REGISTER
R6PTR24  EQU   00000006            3  BYTE  POINTER REGISTER
R7PTR24  EQU   00000007            3  BYTE  POINTER REGISTER
R8       EQU   00000008            FULLWORD POINTER REGISTER
R9       EQU   00000009            FULLWORD POINTER REGISTER
R10      EQU   00000010            FULLWORD POINTER REGISTER
R11      EQU   00000011            FULLWORD POINTER REGISTER
R12      EQU   00000012            FULLWORD POINTER REGISTER
R13      EQU   00000013            FULLWORD POINTER REGISTER
R14      EQU   00000014            FULLWORD POINTER REGISTER
R15      EQU   00000015            FULLWORD POINTER REGISTER
SAVEAREA EQU   00000000            80 BYTE(S) ON WORD
SAVEWRD1 EQU   SAVEAREA+00000000   FULLWORD POINTER
SAVEPFLG EQU   SAVEAREA+00000000   1  BYTE  POINTER
SAVEPLGH EQU   SAVEAREA+00000001   3  BYTE  POINTER ON WORD+1
SAVELAST EQU   SAVEAREA+00000004   FULLWORD POINTER
SAVENEXT EQU   SAVEAREA+00000008   FULLWORD POINTER
SAVER14  EQU   SAVEAREA+00000012   FULLWORD POINTER
SAVERETF EQU   SAVEAREA+00000012   1  BYTE  POINTER
SAVER15  EQU   SAVEAREA+00000016   FULLWORD POINTER
SAVER0   EQU   SAVEAREA+00000020   FULLWORD POINTER
SAVER1   EQU   SAVEAREA+00000024   FULLWORD POINTER
SAVER2   EQU   SAVEAREA+00000028   FULLWORD POINTER
SAVER3   EQU   SAVEAREA+00000032   FULLWORD POINTER
SAVER4   EQU   SAVEAREA+00000036   FULLWORD POINTER
SAVER5   EQU   SAVEAREA+00000040   FULLWORD POINTER
SAVER6   EQU   SAVEAREA+00000044   FULLWORD POINTER
SAVER7   EQU   SAVEAREA+00000048   FULLWORD POINTER
SAVER8   EQU   SAVEAREA+00000052   FULLWORD POINTER
SAVER9   EQU   SAVEAREA+00000056   FULLWORD POINTER
SAVER10  EQU   SAVEAREA+00000060   FULLWORD POINTER
SAVER11  EQU   SAVEAREA+00000064   FULLWORD POINTER
SAVER12  EQU   SAVEAREA+00000068   FULLWORD POINTER
SAVEXTNT EQU   SAVEAREA+00000072   8 BYTE(S)
PARAM    EQU   00000000            120 BYTE(S) ON WORD
PARAM1   EQU   PARAM+00000000      FULLWORD POINTER
PARAM2   EQU   PARAM+00000004      FULLWORD POINTER
PARAM3   EQU   PARAM+00000008      FULLWORD POINTER
PARAM4   EQU   PARAM+00000012      FULLWORD POINTER
PARAM5   EQU   PARAM+00000016      FULLWORD POINTER
PARAM6   EQU   PARAM+00000020      FULLWORD POINTER
PARAM7   EQU   PARAM+00000024      FULLWORD POINTER
PARAM8   EQU   PARAM+00000028      FULLWORD POINTER
PARAM9   EQU   PARAM+00000032      FULLWORD POINTER
PARAM10  EQU   PARAM+00000036      FULLWORD POINTER
PARAM11  EQU   PARAM+00000040      FULLWORD POINTER
PARAM12  EQU   PARAM+00000044      FULLWORD POINTER
PARAM13  EQU   PARAM+00000048      FULLWORD POINTER
PARAM14  EQU   PARAM+00000052      FULLWORD POINTER
PARAM15  EQU   PARAM+00000056      FULLWORD POINTER
PARAM16  EQU   PARAM+00000060      FULLWORD POINTER
PARAM17  EQU   PARAM+00000064      FULLWORD POINTER
PARAM18  EQU   PARAM+00000068      FULLWORD POINTER
PARAM19  EQU   PARAM+00000072      FULLWORD POINTER
PARAM20  EQU   PARAM+00000076      FULLWORD POINTER
PARAM21  EQU   PARAM+00000080      FULLWORD POINTER
PARAM22  EQU   PARAM+00000084      FULLWORD POINTER
PARAM23  EQU   PARAM+00000088      FULLWORD POINTER
PARAM24  EQU   PARAM+00000092      FULLWORD POINTER
PARAM25  EQU   PARAM+00000096      FULLWORD POINTER
PARAM26  EQU   PARAM+00000100      FULLWORD POINTER
PARAM27  EQU   PARAM+00000104      FULLWORD POINTER
PARAM28  EQU   PARAM+00000108      FULLWORD POINTER
PARAM29  EQU   PARAM+00000112      FULLWORD POINTER
PARAM30  EQU   PARAM+00000116      FULLWORD POINTER
PROCCA   EQU   00000000            32767*HALFWORD INTEGER
NUM      EQU   00000000            12 BYTE(S) ON HWORD
NUMA     EQU   NUM+00000000        8 BYTE(S) ON HWORD
NUMLEVEL EQU   NUM+00000000        HALFWORD INTEGER
NUMOPER  EQU   NUM+00000002        HALFWORD INTEGER
NUMPOPER EQU   NUM+00000004        HALFWORD INTEGER
NUMSNTX  EQU   NUM+00000006        HALFWORD INTEGER
NUMB     EQU   NUM+00000008        4 BYTE(S) ON HWORD
NUMSCAN  EQU   NUM+00000008        HALFWORD INTEGER
NUMRCODE EQU   NUM+00000010        HALFWORD INTEGER
BDV      EQU   00000000            8 BYTE(S) ON WORD
BDVBUF   EQU   BDV+00000000        FULLWORD POINTER
BDVMX    EQU   BDV+00000004        HALFWORD POINTER
BDVLEN   EQU   BDV+00000006        HALFWORD POINTER
BUFFER   EQU   00000000            32767 BYTE(S)
OPERAND  EQU   00000000            32767 BYTE(S)
TRTTAB   EQU   *                   256*1  BYTE  POINTER
         DC    00064AL1(255)
         DC    AL1(0)
         DC    00012AL1(255)
         DC    AL1(4)
         DC    00013AL1(255)
         DC    AL1(0)
         DC    AL1(255)
         DC    AL1(5)
         DC    00013AL1(255)
         DC    AL1(2)
         DC    00015AL1(255)
         DC    AL1(0)
         DC    AL1(0)
         DC    AL1(6)
         DC    AL1(3)
         DC    00066AL1(255)
         DC    00009AL1(0)
         DC    00007AL1(255)
         DC    00009AL1(0)
         DC    00008AL1(255)
         DC    00008AL1(0)
         DC    00006AL1(255)
         DC    00010AL1(0)
         DC    00006AL1(255)
SCADV    EQU   00000000            4 BYTE(S) ON HWORD
SCADVSCA EQU   SCADV+00000000      HALFWORD POINTER
SCADVMX  EQU   SCADV+00000002      HALFWORD POINTER
SCA      EQU   00000000            32767*8 BYTE(S) ON HWORD
SCAPD    EQU   SCA+00000000        4 BYTE(S) ON HWORD
SCAPDO   EQU   SCA+00000000        HALFWORD INTEGER
SCAPDMX  EQU   SCA+00000002        HALFWORD POINTER
SCAKLD   EQU   SCA+00000004        4 BYTE(S) ON HWORD
SCAKLDO  EQU   SCA+00000004        HALFWORD INTEGER
SCAKLDMN EQU   SCA+00000006        1  BYTE  POINTER
SCAKLDMX EQU   SCA+00000007        1  BYTE  POINTER
SCE      EQU   00000000            8 BYTE(S) ON HWORD
SCEPD    EQU   SCE+00000000        4 BYTE(S) ON HWORD
SCEPDO   EQU   SCE+00000000        HALFWORD INTEGER
SCEPDMX  EQU   SCE+00000002        HALFWORD POINTER
SCEKLD   EQU   SCE+00000004        4 BYTE(S) ON HWORD
SCEKLDO  EQU   SCE+00000004        HALFWORD INTEGER
SCEKLDMN EQU   SCE+00000006        1  BYTE  POINTER
SCEKLDMX EQU   SCE+00000007        1  BYTE  POINTER
PCA      EQU   00000000            32767*4 BYTE(S)
PCAPROC  EQU   PCA+00000000        2  BYTE  POINTER
PCASNO   EQU   PCA+00000002        2  BYTE  POINTER
KLCA     EQU   00000000            32767*4 BYTE(S) ON HWORD
KLCAKCA  EQU   KLCA+00000000       HALFWORD INTEGER
KLCAMX   EQU   KLCA+00000002       HALFWORD POINTER
KCA      EQU   00000000            32765 BYTE(S)
KCAPROC  EQU   KCA+00000000        2  BYTE  POINTER
KCASNO   EQU   KCA+00000002        2  BYTE  POINTER
KCAIMAG  EQU   KCA+00000004        32767 BYTE(S)
         ORG   @DATA
         DS    00000256C
@L       EQU   2
@DATD    DSECT
@SAV001  EQU   @DATD+00000000      72 BYTE(S) ON WORD
PARM     EQU   @DATD+00000072      24 BYTE(S) ON WORD
PARMBDV  EQU   PARM+00000000       FULLWORD POINTER
PARMPROC EQU   PARM+00000004       FULLWORD POINTER
PARMSCAD EQU   PARM+00000008       FULLWORD POINTER
PARMNUM  EQU   PARM+00000012       FULLWORD POINTER
PARMCOMM EQU   PARM+00000016       FULLWORD POINTER
PARMODV  EQU   PARM+00000020       FULLWORD POINTER
LNUM     EQU   @DATD+00000096      12 BYTE(S) ON HWORD
LNUMA    EQU   LNUM+00000000       8 BYTE(S) ON HWORD
LNUMLEVL EQU   LNUM+00000000       HALFWORD INTEGER
LNUMOPER EQU   LNUM+00000002       HALFWORD INTEGER
LNUMPOPR EQU   LNUM+00000004       HALFWORD INTEGER
LNUMSNTX EQU   LNUM+00000006       HALFWORD INTEGER
LNUMB    EQU   LNUM+00000008       4 BYTE(S) ON HWORD
LNUMSCAN EQU   LNUM+00000008       HALFWORD INTEGER
LNUMRCOD EQU   LNUM+00000010       HALFWORD INTEGER
LBDV     EQU   @DATD+00000108      8 BYTE(S) ON WORD
LBDVBUF  EQU   LBDV+00000000       FULLWORD POINTER
LBDVMX   EQU   LBDV+00000004       HALFWORD POINTER
LBDVLEN  EQU   LBDV+00000006       HALFWORD POINTER
ODV      EQU   @DATD+00000116      8 BYTE(S) ON WORD
ODVOPER  EQU   ODV+00000000        FULLWORD POINTER
ODVMX    EQU   ODV+00000004        HALFWORD POINTER
ODVLEN   EQU   ODV+00000006        HALFWORD POINTER
SCEPTR   EQU   @DATD+00000124      FULLWORD POINTER
KCAPTR2  EQU   @DATD+00000128      FULLWORD INTEGER
         DS    00000132C
@TEMPS   DS    0F
@TEMP2   DC    F'0'
@DATEND  EQU   *
IEFVSCAN CSECT ,
SCN10100 EQU   SCN12120
@9FC     EQU   SCN12300
@9EA     EQU   SCN1RSCN
@9DC     EQU   SCN10020
@9D7     EQU   @EL04
         END   IEFVSCAN
