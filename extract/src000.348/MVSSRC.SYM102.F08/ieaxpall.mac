         MACRO
&NAME    AXR#  &REG1,&REG2
         CNOP  0,4
&NAME    B     *+8 ..........RECURSIVE CALL TO QSIM TO SIMULATE AXR
         DC    H'0'
         ADR   &REG1,&REG2 ........'AXR  REG1,REG2'  IS MEANT
         ORG   *-2
         DC    X'36'
         ORG   *+1
         L     GR0,*-4
         BALR  GRR,GRL
         LR    GRL,GR4 ........RESTORE GRL
         MEND
         MACRO
&NAME    SXR#  &REG1,&REG2
         CNOP  0,4
&NAME    B     *+8 ..........RECURSIVE CALL TO QSIM TO SIMULATE SXR
         DC    H'0'
         SDR   &REG1,&REG2 ........'SXR  REG1,REG2'  IS MEANT
         ORG   *-2
         DC    X'37'
         ORG   *+1
         L     GR0,*-4
         BALR  GRR,GRL
         LR    GRL,GR4 ........RESTORE GRL
         MEND
         MACRO
&NAME    MXDR# &REG1,&REG2
         CNOP  0,4
&NAME    B     *+8 ..........RECURSIVE CALL TO QSIM TO SIMULATE MXDR
         DC    H'0'
         MER   &REG1,&REG2 ........'MXDR  REG1,REG2'  IS MEANT
         ORG   *-2
         DC    X'27'
         ORG   *+1
         L     GR0,*-4
         BALR  GRR,GRL
         LR    GRL,GR4 ........RESTORE GRL
         MEND
         MACRO
&NAME    MXD#  &REG1,&OPND2
         CNOP  0,4
&NAME    LD    &REG1+2,&OPND2 ....MACRO FOR 'MXD  REG1,OPND2'
         B     *+8 ..........RECURSIVE CALL TO QSIM TO SIMULATE MXDR
         DC    H'0'
         MER   &REG1,&REG1+2 ........'MXDR REG1,REG1+2'  IS MEANT
         ORG   *-2
         DC    X'27'
         ORG   *+1
         L     GR0,*-4
         BALR  GRR,GRL
         LR    GRL,GR4 ........RESTORE GRL
         MEND
         EJECT
IEAXPALL CSECT
         PRINT ON,NOGEN,DATA
         SPACE
***********************************************************************
*                                                                     *
* MODULE NAME - IEAXPALL                                              *
*                                                                     *
* TITLE - SIMULATOR INTERFACE FOR EXTENDED PRECISION INSTRUCTIONS     *
*                                                                     *
* FUNCTION OPERATION - IEAXPALL HANDLES OPERATION INTERRUPTS. IF THE  *
*        OP-CODE INTERRUPT OCCURRED AS A RESULT OF AN EXTENDED        *
*        PRECISION INSTRUCTION, CONTROL IS PASSED TO THE SIMULATOR    *
*        KERNEL. THE PSW IS MODIFIED APPROPRIATELY AFTER SIMULATION.  *
*                                                                     *
* STATUS - CHANGE LEVEL 0                                             *
*                                                                     *
* ENTRY POINT - IEAXPALL                                              *
*                                                                     *
* INPUT - REGISTER 1 CONTAINS THE POINTER TO A PARAMETER LIST WHICH   *
*        CONTAINS A PTR TO THE PIE, A PTR TO AN AREA WITH REGS AT     *
*        INTERRUPT TIME (0-15), A PTR TO A WORK AREA, A PTR TO A BYTE *
*        WHICH IS NON-ZERO IF THE LAST BIT OF DXR IS NOT TO BE        *
*        GUARANTEED.                                                  *
*                                                                     *
* TABLES/WORK AREAS -                                                 *
*        1 - RC - REG CODE EXTRACTED FROM THE INSTRUCTION TO BE       *
*        SIMULATED.                                                   *
*                                                                     *
* EXITS - RETURN IS ALWAYS TO THE CALLING ROUTINE VIA REG 14. A RETURN*
*        CODE IS PLACED IN REG 15.                                    *
*        CODE    MEANING                                              *
*        X'00'   OPERATION SUCCESSFUL AND NO EXCEPTIONAL CONDITIONS   *
*        OCCURRED.                                                    *
*        X'FF'   1 - AN EXTENDED PRECISION INSTRUCTION WAS NOT        *
*                    ENCOUNTERED.                                     *
*                2 - AN INCORRECT FLOATING POINT REGISTER WAS         *
*                    SPECIFIED (SPECIFICATION).                       *
*                3 - A PROTECTION, ADDRESSING OR SPECIFICATION        *
*                    INTERRUPT OCCURRED IN FETCHING THE ARGUMENT      *
*                    OF AN MXD INSTRUCTION.                           *
*                4 - OVERFLOW, UNDERFLOW, FLOATING POINT DIVIDE OR    *
*                    SIGNIFICANCE OCCURRED IN SIMULATING.             *
*                5 - THIRD BYTE OF DXR NOT X'00' (SPECIFICATION)      *
*                                                                     *
* EXTERNAL ROUTINES - THE SIMULATOR KERNEL IEAXKALL                   *
*                                                                     *
* ATTRIBUTES - THIS MODULE IS REENTRANT.                              *
*                                                                     *
***********************************************************************
         EJECT
* REGISTER DEFINITIONS
PARM     EQU   1                   PARAMETER REG
R2       EQU   2                   UTILITY REG
R3       EQU   3                   UTILITY REG
R4       EQU   4                   UTILITY REG
INST     EQU   5                   PTR TO INSTRUCTION
PIEAD    EQU   6                   PTR TO PIE
WRK      EQU   7
BASE     EQU   8                   BASE REG
LINK     EQU   9                   BRANCHING REG
CODE1    EQU   15                  RETURN CODE REG
         SPACE 3
* MISCELLANEOUS CODES
LRDRINST EQU   X'25'               EXTENDED OP CODES - LOAD LONG RNDED
MXDRINST EQU   X'27'                                   MULTIPLY LONG
LRERINST EQU   X'35'                                   LOAD SHORT RNDED
SXRINST  EQU   X'37'                                   SUBTRACT
MXDINST  EQU   X'67'                                   MULTIPLY LONG
DIVOP    EQU   X'2D'               HALF OF EXTENDED DIVIDE OPCODE
LOWBY    EQU   X'0F'               SETS OFF HIGH 4 BITS OF A BYTE
RESULT0  EQU   X'02'               SIMULATED MXD REGS: 0=ARG 2=RESULT
RESULT4  EQU   X'46'               SIMULATED MXD REGS: 4=ARG 6=RESULT
XOV      EQU   X'0C'               ERROR CODES - EXPONENT OVERFLOW
XUN      EQU   X'0D'                             EXPONENT UNDERFLOW
SIGNIF   EQU   X'0E'                             SIGNIFICANCE
DCK      EQU   X'0F'                             FLOATING POINT DIVIDE
ADSUB    EQU   X'F0'               SETS SWITCH TO INDICATE ADD OR SUB
R2OR6    EQU   X'0F'               SETS SWITCH IF REGS 2 OR 6 ALLOWED
BADOP    EQU   X'FF'               ERROR RETURN CODE
ON       EQU   X'FF'               SETS SOME SWITCHES ON
         EJECT
         USING XPALL,15
         USING WRKAREA,WRK
         SPACE
XPALL    B     PROLOG
         DC    X'08'
         DC    CL8'IEAXPALL'
PROLOG   STM   14,12,12(13)        SAVE REGS
         BALR  BASE,0              SET UP ADDRESSABILITY
         USING *,BASE
         L     WRK,8(PARM)
         ST    13,SAVESIM+4
         LA    R2,SAVESIM          SAVE AREA FOR KERNEL
         ST    R2,8(13)            LINK SAVE AREAS
         SPACE
         MVI   72(WRK),X'00'
         MVC   73(10,WRK),72(WRK)  INITIALIZE WORK AREA
         L     PIEAD,0(PARM)       PICK UP ADDRESS OF PIE
         SPACE
* CALCULATE PTR TO INSTRUCTION CAUSING INTERRUPT
         L     INST,8(PIEAD)
         LA    INST,0(INST)        NEXT INSTRUCTION ADDRESS
         SH    INST,FOUR           ILC ADJUSTMENT
         TM    8(PIEAD),X'80'      ILC 2 ?
         BZ    ADD2                YES - ADD 2 TO ADDRESS
         TM    8(PIEAD),X'C0'      ILC 6 ?
         BM    EXTEST              NO - ILC IS 4
         SH    INST,TWO            ILC 6 - SUBTRACT 2
         B     EXTEST              GO TEST FOR EX
ADD2     AH    INST,TWO            ILC 4
         SPACE 3
* THIS ROUTINE TESTS FOR AN EXECUTE INSTRUCTION. IF THE INTERRUPT WAS
* CAUSED BY AN EXECUTE, THE ADDRESS OF THE EXECUTED INSTRUCTION IS
* CALCULATED AND THE MASK IS SET.
         SPACE
EXTEST   CLI   0(INST),X'44'       IS INSTRUCTION AN EXECUTE ?
         BNE   DIVCK               NO - CHECK FOR DIVIDE
         BAL   LINK,ADCALC         CALC ADDRESS OF INTERRUPT INST
         SR    R2,R2
         IC    R2,1(INST)          PICK UP REG USED FOR EX
         SRL   R2,4
         SLL   R2,2
         LTR   R2,R2               IS EX REG 0 ?
         BZ    LOADREG             YES - DO NOT SET MASK
         L     R2,0(R2,R4)         GET CONTENTS OF REG
         STC   R2,BYTES
         MVC   EXSV,1(R3)          SAVE ORIGINAL FIELD
         OI    EXSW,ON             INDICATE EXECUTE INSTRUCTION
         OC    1(1,R3),BYTES       SET MASK IN INST TO BE EXECUTED
LOADREG  LR    INST,R3             PICK UP ADDRESS OF INST
         SPACE 2
DIVCK    CLC   0(2,INST),DIV       EXTENDED DIVIDE ?
         BNE   OPTST               NO - CHECK FOR OTHER EXT INSTS
         CLI   2(INST),X'00'       THIRD BYTE ZERO ?
         BNE   SETSPEC             INDICATE SPECIFICATION ERROR
         MVI   RC+2,DIVOP          SET DIVIDE OPCODE
         MVC   RC+3(1),3(INST)     SET REGISTER CODE
         SR    R2,R2
         IC    R2,3(INST)
         BAL   LINK,SPECTST2       CHECK FOR CORRECT REG SPEC
         MVC   BYTES(1),3(INST)
         B     REGTST2             CHECK CORRECT R2 SPEC
         SPACE 2
* THIS ROUTINE TESTS FOR THE EXTENDED PRECISION INSTRUCTIONS.
         SPACE
OPTST    CLI   0(INST),LRDRINST
         BL    ERRRET              NOT TO BE HANDLED
         BE    LRDRRTN             HANDLE LRDR INSTRUCTION
         CLI   0(INST),MXDRINST
         BL    REGTST              HANDLE MXR INSTRUCTION
         BE    MXDRRTN             HANDLE MXDR INSTRUCTION
         CLI   0(INST),LRERINST
         BL    ERRRET              NOT TO BE HANDLED
         BE    LRERRTN
         CLI   0(INST),SXRINST
         BH    MXDTST              TEST FOR MXD INSTRUCTION
         OI    SWITCH,ADSUB        INDICATE ADD OR SUBTRACT
         B     REGTST              HANDLE ADD OR SUBTRACT
         EJECT
MXDTST   CLI   0(INST),MXDINST
         BNE   ERRRET              NOT TO BE HANDLED
         SPACE
* THIS ROUTINE EXAMINES THE ADDRESS PORTION OF AN MXD INSTRUCTION. IF
* A SPECIFICATION, PROTECTION, OR ADDRESSING INTERRUPT OCCURS IN
* FETCHING THE ARGUMENT, THE PSW INDICATES THE CONDITION.
         SPACE
         BAL   LINK,ADCALC         CALCULATE ARGUMENT ADDRESS
         BAL   LINK,SPECTST        TEST R1 FOR PROPER REG SPECIFICATION
         MVC   APSW(4),8(PIEAD)
         MVC   PIEREGS(20),12(PIEAD)
         LA    R4,MXDERR           SPIE EXIT FOR FETCHING ARGUMENT
         SPIE  (4),(4,5,6)         CATCH PROTECTION, ADDRESSNG AND SPEC
         LTR   R2,R2
         MVI   RC+2,MXDRINST       INDICATE MXDR FOR SIMULATOR
         BZ    ZER
         MVI   RC+3,RESULT4        INDICATE ARG AND RESULT REGS
         LD    6,0(R3)             PICK UP ARGUMENT
         B     CANCEL
ZER      MVI   RC+3,RESULT0        INDICATE ARG AND RESULT REGS
         LD    2,0(R3)             PICK UP ARGUMENT
CANCEL   EQU   *
         SPIE MF=(E,(1))           RESTORE PREVIOUS PICA
         TM    MXDSW,ON            ERROR ON LOAD ?
         BZ    PROGMSK             NO - SET UP FOR KERNEL
         MVC   8(4,PIEAD),APSW
         MVC   12(20,PIEAD),PIEREGS
         B     ERRRET              RETURN WITH ERROR CODE
         SPACE 3
* SPIE EXIT FOR ERROR IN FETCHING THE ARGUMENT OF MXD.
MXDERR   OI    MXDSW,ON            INDICATE ERROR IN FETCHING THE ARG
         BR    14                  RETURN TO SUPERVISOR
         SPACE 3
* THESE ROUTINES INSURE PROPER REG SPECIFICATIONS.
         SPACE
LRERRTN  OI    SWITCH,R2OR6        INDICATE 0,2,4 OR 6 ALLOWED
MXDRRTN  BAL   LINK,SPECTST        CHECK R1
         OI    SWITCH,R2OR6        INDICATE 0,2,4 OR 6 ALLOWED
         B     REGTST1             GO TEST R2
LRDRRTN  OI    SWITCH,R2OR6        INDICATE 0,2,4 OR 6 ALLOWED
REGTST   BAL   LINK,SPECTST        TEST FOR CORRECT REG
REGTST1  MVC   BYTES(1),1(INST)
REGTST2  NI    BYTES,LOWBY
         IC    R2,BYTES            PICK UP R2
         BAL   LINK,SPEC2          TEST FOR CORRECT ARGUMENT REG
         EJECT
* THIS ROUTINE SETS UP THE PARAMETER AREA FOR THE KERNEL: X'PM0SOPRA',
* WHERE PM IS THE PROGRAM MASK, S IS DXR SWITCH, OP IS OPCODE OR 2D,
* R IS REG 1, AND A IS REG 2.
         SPACE
PROGMSK  IC    R2,8(PIEAD)         GET PROGRAM MASK FROM THE PSW
         SLL   R2,4
         STC   R2,RC               SET PROGRAM MASK IN PARM FOR SIM
         LA    13,SAVESIM          SAVE AREA FOR SIMULATOR
         CLI   RC+2,X'00'          MXD OR DIVIDE ?
         BNZ   QBR                 YES - BRANCH
         MVC   RC+2(2),0(INST)     SET OP CODE
QBR      LA    R2,RC               SET INSTRUCTION AND REG CODE
         ST    R2,LIST                  IN PARAMETER LIST
         LA    R2,SIMWRK           SET ADDRESS OF SIM WORKAREA
         ST    R2,LIST+4                IN PARAMETER LIST
         LA    R2,EXCEP            SET ADDRESS OF ERROR RETURN
         ST    R2,LIST+8                 IN PARAMETER LIST
         L     R2,12(PARM)         PICK UP DXR ADJUST SW
         TM    0(R2),X'FF'         SHOULD ADJUST BE DONE?
         BZ    TOSIM               YES BRANCH
         MVI   RC+1,X'01'          INDICATE TO KERNEL NOT TO ADJUST
TOSIM    LA    PARM,LIST           ADDRESS OF PARAMETER LIST
         L     15,=V(IEAXKALL)
         BALR  14,15               BRANCH TO SIMULATOR
         SPACE
         LA    LINK,OUT            BRANCH POINT
         SR    15,15               INDICATE GOOD RETURN CODE
SETCC    TM    SWITCH,ADSUB        ADD OR SUBTRACT ?
         BCR   8,LINK              NO - RETURN
         L     R2,RETCD            PICK UP RETURN CODE
         SRL   R2,6                SET UP MASK
         SLL   R2,4                    USE TO SET CC
         STC   R2,CODE2
         NI    8(PIEAD),X'CF'
         OC    8(1,PIEAD),CODE2    SET CONDITION CODE
         BR    LINK                RETURN
         SPACE
* USING RETURN CODE FROM SIMULATOR, SET PSW APPROPRIATELY
EXCEP    CLI   RETCD+3,BADOP       DID KERNEL FIND OPCODE ERROR ?
         BE    ERRRET              GIVE ERROR RETURN CODE
         BAL   LINK,SETCC          SET CC IF ANY
         NI    RETCD+3,X'3F'       ADJUST RETURN CODE
         L     15,RETCD            PICK UP RETURN CODE
         EX    0,SETINT(15)        ADJUST INTERRUPT CODE
ERRRET   LA    CODE1,255           SET X'FF' RETURN CODE
OUT      TM    EXSW,ON             WAS INST AN EXECUTE ?
         BZ    RETURN              NO - RETURN
         MVC   1(1,INST),EXSV      RESTORE FIELD MODIFIED FOR EXECUTE
         SPACE
RETURN   L     13,SAVESIM+4        RESTORE CALLER'S SAVE AREA POINTER
         L     14,12(13)           GET RETURN LOCATION
         LM    0,12,20(13)         RESTORE REGISTERS
         MVI   12(13),X'FF'        INDICATE RETURN
         BR    14                  RETURN
         SPACE 3
SETINT   EQU   *-4
         MVI   7(PIEAD),XOV
         MVI   7(PIEAD),XUN
         MVI   7(PIEAD),DCK
         MVI   7(PIEAD),DCK
         MVI   7(PIEAD),SIGNIF
         EJECT
* THIS ROUTINE CALCULATES THE ADDRESS SPECIFIED AS AN ARGUMENT IN AN
* RX INSTRUCTION.
         SPACE
ADCALC   SR    R2,R2
         MVC   BYTES(1),1(INST)
         NI    BYTES,LOWBY
         IC    R2,BYTES            INDEX REGISTER
         L     R4,4(PARM)          PTR TO REGS AT INTERRUPT TIME
         LTR   R2,R2               REG 0 NOT INDEX REG
         BZ    ADD
         SLL   R2,2
         L     R2,0(R2,R4)         CONTENTS OF INDEX REG
         LA    R2,0(R2)
ADD      SR    R3,R3
         IC    R3,2(INST)          BASE REGISTER
         SRL   R3,4
         LTR   R3,R3               REG 0 NOT BASE REG
         BZ    ADD1
         SLL   R3,2
         L     R3,0(R3,R4)         CONTENTS OF BASE REG
         LA    R3,0(R3)
ADD1     AR    R3,R2               BASE, INDEX
         MVC   BYTES(2),2(INST)    DISPLACEMENT
         NI    BYTES,LOWBY
         AH    R3,BYTES            ADDRESS
         BR    LINK
         EJECT
* THIS ROUTINE EXAMINES REGISTER FIELDS OF EXTENDED PRECISION
* INSTRUCTION. IF AN INCORRECT REGISTER IS SPECIFIED, THE PSW IN PIE
* WILL BE SET TO INDICATE SPECIFICATION.
        SPACE
SPECTST  SR    R2,R2
         IC    R2,1(INST)          PICK UP REGISTERS TO BE EXAMINED
SPECTST2 SRA   R2,4
SPEC2    LTR   R2,R2               IS REG 0 ?
         BZ    BACK                YES - RETURN
         CH    R2,FOUR             IS REG 4 ?
         BE    BACK                YES - RETURN
         TM    SWITCH,R2OR6        REG 2 OR REG 6 VALID?
         BZ    SETSPEC             NO - RETURN WITH ERROR CODE
         CH    R2,TWO              IS REG 2 ?
         BE    BACK                YES - RETURN
         CH    R2,SIX              IS REG 6 ?
         BNE   SETSPEC             NO - RETURN WITH ERROR CODE
BACK     NI    SWITCH,X'F0'
         BR    LINK
SETSPEC  LA    R2,6                SPECIFICATION ERROR CODE
         STH   R2,6(PIEAD)         SET INTERRUPT CODE IN PSW
         B     ERRRET
         EJECT
* CONSTANT DATA AREAS
      SPACE
TWO      DC    H'2'
FOUR     DC    H'4'
SIX      DC    H'6'
DIV      DC    X'B22D'             EXTENDED DIVIDE OPCODE - DXR
      SPACE    3
* VARIABLE DATA AREAS
         SPACE
WRKAREA  DSECT
SAVESIM  DS    18F                 SAVE AREA FOR KERNEL
RC       DC    F'0'                PARAMETER AREA FOR KERNEL
BYTES    DC    H'0'                SCRATCH AREA
SWITCH   DC    X'00'               ADSUB AND R2OR6 SWITCHES
CODE2    DC    X'00'               SCRATCH TO BUILD CONDITION CODE
EXSW     DC    X'00'               INDICATES EXECUTE INSTRUCTION
EXSV     DC    X'00'               ORIGINAL FIELD OF INST EXECUTED
MXDSW    DC    X'00'               SWITCH FOR MXD INSTRUCTION
LIST     DC    A(RC)               PARAMETER LIST FOR KERNEL
         DC    A(SIMWRK)
         DC    X'80',AL3(EXCEP)
         DS    0D
RETCD    DS    0F                  RETURN CODE FROM KERNEL
SIMWRK   DS    35D                 WORK AREA FOR KERNEL
PAD      DS    6F                  NOT USED - RESERVED FOR MAINTAINENCE
APSW     EQU   SIMWRK   DS 1F      SAVE OLD PSW FROM ORIGINAL INTERRUPT
PIEREGS  EQU   SIMWRK+4 DS 5F      SAVE REGS FROM ORIGINAL INTERRUPT
SIZ      EQU   *
         EJECT
* THE SIMULATOR KERNEL
GRS      EQU   13 ...........SAVE AREA POINTER
GRR      EQU   14 ...........RETURN REGISTER
GRL      EQU   15 ...........LINK REGISTER
GR0      EQU   0 ............CONTAINS CODE FOR OPERATION AT ENTRY
GR1      EQU   1 ............SCRATCH REGISTERS
GR2      EQU   2
GR3      EQU   3
GR4      EQU   4
GR5      EQU   5
GR6      EQU   6
GRM      EQU   7 ............MASK REGISTER TO HOLD MASK '7F'
GR8      EQU   8 ............ADJUST SWITCH FOR DXR
GR9      EQU   9 ............RECURSIVE CALL SWITCH
GRW      EQU   12 ...........WORK AREA POINTER
FR0      EQU   0 ............FLOATING POINT REGISTERS
FR2      EQU   2
FR4      EQU   4
FR6      EQU   6
         SPACE
SAVEAREA DSECT
         SPACE
CODE     EQU   * ............INSTRUCTION CODE
SAVEGRW  EQU   *+4*17 .......DISPLACEMENT FOR SAVE BUFFER OF GRW
         DS    18F
         SPACE
WORKAREA DSECT
         SPACE
SAVEFR0  DS    D ............SAVE BUFFER FOR FR0
SAVEFR2  DS    D ............SAVE BUFFER FOR FR2
SAVEFR4  DS    D ............SAVE BUFFER FOR FR4
SAVEFR6  DS    D ............SAVE BUFFER FOR FR6
OPND1    DS    D ............HIGH-ORDER 14 DIGITS OF OPERAND 1
         DS    D ............LOW-ORDER 14 DIGITS OF OPERAND 1
         DS    D ............GUARD DIGIT OF OPERAND1
OPND2    DS    D ............HIGH-ORDER 14 DIGITS OF OPERAND 2
         DS    D ............LOW-ORDER 14 DIGITS OF OPERAND 2
         DS    D ............GUARD DIGIT OF OPERAND2
CHAR1    DS    H ............SIGN/CHAR OF HIGH PART OF OPERAND 1
HCHAR    DS    H ............MAX(/CHAR1/,/CHAR2/)
CHAR2    DS    H ............SIGN/CHAR OF HIGH PART OF OPERAND 2
ERRFLAG  DS    H ............RETURN CODE
PADK     DS    D ............NOT USED - RESERVED FOR MAINTAINENCE
BUFF1    DS    D ............TEMPORARY STORAGES, USED BY DXR ONLY
BUFF2    DS    D
         EJECT
SAVE     DS    18F ..........SAVE AREA FOR RECURSIVE CALL
NEWWK    EQU   * ............WORKAREA FOR RECURSIVE CALL
INCR     EQU   NEWWK-SAVEFR0 INCREMENT TO POINT TO NEW WORKAREA
RSAVEFR0 DS    D ............SAVE BUFFER FOR FR0
RSAVEFR2 DS    D ............SAVE BUFFER FOR FR2
RSAVEFR4 DS    D ............SAVE BUFFER FOR FR4
RSAVEFR6 DS    D ............SAVE BUFFER FOR FR6
ROPND1   DS    D ............HIGH-ORDER 14 DIGITS OF OPERAND 1
         DS    D ............LOW-ORDER 14 DIGITS OF OPERAND 1
         DS    D ............GUARD DIGIT OF OPERAND1
ROPND2   DS    D ............HIGH-ORDER 14 DIGITS OF OPERAND 2
         DS    D ............LOW-ORDER 14 DIGITS OF OPERAND 2
         DS    D ............GUARD DIGIT OF OPERAND2
RCHAR1   DS    H ............SIGN/CHAR OF HIGH PART OF OPERAND 1
RHCHAR   DS    H ............MAX(/CHAR1/,/CHAR2/)
RCHAR2   DS    H ............SIGN/CHAR OF HIGH PART OF OPERAND 2
RERRFLAG DS    H ............RETURN CODE
RPADK    DS    D ............NOT USED - RESERVED FOR MAINTAINENCE
SIZE     EQU   *
         EJECT
IEAXKALL CSECT
         ENTRY IEAXKALL
         SPACE
         USING WORKAREA,GRW
         USING SAVEAREA,GRS
         USING *,GRL
         SPACE
         B     PROLOGA ............NORMAL ENTRY POINT
         DC    X'08'
         DC    CL8'IEAXKALL'
         SPACE
PROLOGA  STM   GRR,GRW,12(GRS) .SAVE REGISTERS
         L     GRW,4(GR1) ...WORK AREA ADDRESSABILITY
         L     GR2,0(GR1)
         L     0,0(GR2) .....INSTRUCTION CODE
         ST    0,CODE
         SR    GR8,GR8 ......CLEAR PROGRAM MASK
         SPM   GR8
         IC    GR8,CODE+1 ...PICK UP ADJUST SWITCH
         SR    GR9,GR9 ......INDICATE NOT RECURSIVE CALL
         BAL   GRL,PROLOGC ..ADJUST BASE REGISTER AND MERGE
         SPACE
         USING *,GRL
         SPACE
QSIM     B     PROLOGB ......ENTRY POINT FOR RECURSIVE ENTRY
         DC    X'04'
         DC    CL5'QSIM'
PROLOGB  STM   GRR,GRW,12(GRS) .SAVE REGISTERS
         LA    GRW,INCR(GRW) ADVANCE WORK AREA POINTER
         ST    GR0,CODE            SAVE REGISTER CODE
         LR    GR9,GR0 ......INDICATE RECURSIVE CALL
*
*     PROLOG SECTION: DETERMINE OPERATION TO BE SIMULATED,
*                     STORE OPERANDS, SAVE SIGN AND CHAR. OF
*                     OPERANDS, AND SCALE OPERANDS
*
PROLOGC  STD   FR0,SAVEFR0 ..SAVE FLOATING POINT REGISTERS
         STD   FR2,SAVEFR2
         STD   FR4,SAVEFR4
         STD   FR6,SAVEFR6
         MVI   ERRFLAG,X'00' CLEAR RETURN CODE FLAG
         LA    GRM,X'7F' ....SET UP MASK REGISTER FOR X'7F'
         LR    GR1,GR0 ......DETERMINE 1ST OPERAND REGISTER
         SRL   GR1,4
         SLL   GR1,4
         EX    GR1,STORE1 ...STORE HIGH PART OPERAND 1 IN OPND1
         MVC   CHAR1(1),OPND1 SAVE SIGN/CHARACTERISTIC OF OPERAND 1
         MVI   OPND1,X'40' ..FORCE + AND CHARACTERISTIC OF X'40'
         LR    GR2,GR0 ......DETERMINE 2ND OPERAND REGISTER
         SLL   GR2,4
         EX    GR2,STORE2 ...STORE HIGH PART OPERAND 2 IN OPND2
         MVC   CHAR2(1),OPND2 SAVE SIGN/CHARACTERISTIC OF OPERAND 2
         MVI   OPND2,X'40' ..FORCE + AND CHARACTERISTIC OF X'40'
         SPACE
         CLI   CODE+2,X'35' .IF OP CODE = '35', GO TO LRER SECTION
         BE    LRER
         CLI   CODE+2,X'27' .IF OP CODE = '27', GO TO MXDR SECTION
         BE    MXDR
         SPACE
         LA    GR2,X'20'(GR2)
         EX    GR2,STORE3 ...STORE LOW PART OPERAND 2 IN OPND2+8
         MVI   OPND2+8,X'32' FORCE SIGN + AND CHAR. OF X'32'
         SPACE
         CLI   CODE+2,X'25' .IF OP CODE = '25', GO TO LRDR SECTION
         BE    LRDR
         SPACE
         LA    GR1,X'20'(GR1)
         EX    GR1,STORE4 ...STORE LOW PART OPERAND 1 IN OPND1+8
         MVI   OPND1+8,X'32' FORCE SIGN + AND CHAR. OF X'32'
         SPACE
         CLI   CODE+2,X'36' .IF OP CODE = '36', GO TO AXR SECTION
         BE    AXR
         CLI   CODE+2,X'37' .IF OP CODE = '37', GO TO SXR SECTION
         BE    SXR
         SPACE
         SDR   FR0,FR0 ......PRENORMALIZE OPERANDS
         STD   FR0,OPND1+16 ...CLEAR GUARD DIGIT
         BAL   GRR,NORM .......NORMALIZE 1ST OPERAND
         LM    GR3,GR6,OPND1 ..SAVE 1ST OPERAND, AND MOVE 2ND
         MVC   OPND1(16),OPND2 ..OPERAND FOR NORMALIZATION
         BAL   GRR,NORM .......NORMALIZE 2ND OPERAND
         MVC   OPND2(16),OPND1 SWITCH BACK OPERANDS SINCE DXR
         STM   GR3,GR6,OPND1 ....IS NOT COMMUTATIVE
         SPACE
         CLI   CODE+2,X'26' .IF OP CODE = '26', GO TO MXR SECTION
         BE    MXR
         CLI   CODE+2,X'2D' .IF OP CODE = '2D', GO TO DXR SECTION
         BE    DXR
         MVI   ERRFLAG,X'FF' IF OP CODE IS NONE OF THE ABOVE,
         B     EPILOG6 ........ILLEGAL OP CODE.  SET FLAG AND RETURN
         SPACE 3
EPILOGA  IC    GR1,OPND1 ....PRE-EPILOG FOR DXR
         NR    GR1,GRM ........CHAR. OF SCALED RESULT IN GR1
         IC    GR2,CHAR2 ......CHAR. OF 2ND OPERAND IN GR2
         NR    GR2,GRM
         B     EPILOGB1
         SPACE
EPILOGB  IC    GR1,CHAR2 ....PRE-EPILOG FOR MXR AND MXDR
         NR    GR1,GRM
         IC    GR2,OPND1
         NR    GR2,GRM ........SUM OF CHAR. OF SCALED RESULT
         AR    GR1,GR2 ..........AND CHAR. OF 2ND OPERAND IN GR1
         LA    GR2,X'80' ......TWICE CHAR. BIAS IN GR2
         SPACE
EPILOGB1 LA    GR4,EPILOG5 ..PRE-EPILOG FOR DXR, MXR, MXDR MERGE HERE
         IC    GR0,CHAR1 ......CHAR. OF 1ST OPERAND TO GR0
         NR    GR0,GRM
         XC    CHAR1(1),CHAR2 .MULTIPLY SIGNS OF THE 2 OPERANDS
         B     EPILOG
         SPACE
EPILOGC  LA    GR4,EPILOG5 ..PRE-EPILOG FOR AXR AND SXR
         CLI   OPND1+1,X'00'
         BNE   EPILOGC1 .......IF SCALED RESULT NOT 0, SKIP
         NI    CHAR1,X'7F' ....IF SCALED RESULT 0, SET SIGN +
         TM    CODE,X'10'
         BNO   EPILOG4 ........IF SIGNIF. MASK OFF, SKIP
         MVI   ERRFLAG,X'14' ..IF SIGNIF. MASK ON, REPORT THE
         MVI   OPND1,X'40' ......EXCEPTION, AND FORCE CHAR. OF X'40'
         B     EPILOGD1 .......SKIP
         SPACE
EPILOGC1 MVI   ERRFLAG,X'40' ..IF SIGN OF RESULT IS NEGATIVE,
         TM    CHAR1,X'80' ......SET THE FLAG OF X'40'
         BO    EPILOGD1 .......IF SIGN OF RESULT IS POSITIVE,
         MVI   ERRFLAG,X'80' ....SET THE FLAG OF X'80'
         B     EPILOGD1 .......SKIP
         SPACE
EPILOGD  LA    GR4,EPILOG6 ..PRE-EPILOG FOR LRER AND LRDR.  IN THIS
*                            CASE, SET TO SKIP LOADING 2ND REGISTER
         MVC   CHAR1(1),CHAR2 .MOVE SIGN/CHAR OF 2ND TO THAT OF 1ST
         SPACE
EPILOGD1 IC    GR0,CHAR1 ....PRE-EPILOG FOR AXR, SXR, LRER, LRDR
         NR    GR0,GRM ........MERGE HERE
         IC    GR1,OPND1 ......CHAR OF BIGGER OR ONLY OPERAND IN GR0
         NR    GR1,GRM ........CHAR OF SCALED RESULT IN GR1
         LA    GR2,X'40' ......CHAR BIAS IN GR2
         SPACE
*
*     EPILOG NUCLEUS: DETERMINE CHAR. AND SIGN OF RESULT
*                     TEST EXPONENT OVERFLOW AND UNDERFLOW
*                     PROVIDE EXPONENT WRAP-AROUND IF CALLED FOR
*                     LOAD RESULT INTO CORRECT REGISTER(S)
*                     RESTORE OTHER REGISTERS AND PROGRAM MASK
*
EPILOG   CLC   OPND1(4),ZERO IF SCALED RESULT IS NORMAL 0, SKIP
         BE    EPILOG4
         AR    GR1,GR0 ......OTHERWISE, CHAR. OF ANS = GR0+GR1-GR2
         SR    GR1,GR2
         BNM   EPILOG2 ......IF CHAR. IS NOT NEGATIVE, SKIP
         SPACE
         TM    CODE,X'20' ...UNDERFLOW CASE
         BO    EPILOG1
         SDR   FR0,FR0 ......IF UNDERFLOW MASK IS OFF, WE SHOULD
         STD   FR0,OPND1 ......GIVE NORMAL ZERO SILENTLY
         STD   FR0,OPND1+8
         B     EPILOG4 ........SKIP
EPILOG1  OI    ERRFLAG,X'08' IF UNDFLOW MASK IS ON, SET FLAG
         SPACE
EPILOG2  CR    GR1,GRM
         BNH   EPILOG3 ......IF CHAR. IS HIGHER THAN X'7F',
         OI    ERRFLAG,X'04' ..OVERFLOW CASE.   SET FLAG FOR THIS
         SPACE
EPILOG3  NR    GR1,GRM ......CUT DOWN TO NORMAL CHAR. RANGE
         LA    GR2,X'FF2'(GR1)
         NR    GR2,GRM ......FIX UP LOW ORDER CHARACTERISTIC
         NI    CHAR1,X'80'
         IC    GR0,CHAR1 ....SIGN BIT FOR THE ANSWER
         OR    GR1,GR0 ......SIGN AND CHAR. OF HIGH PART ANS
         STC   GR1,OPND1
         OR    GR2,GR0 ......SIGN AND CHAR. OF LOW PART ANS
         STC   GR2,OPND1+8
         SPACE
EPILOG4  IC    GRM,CODE+3 ...LOCATE RESULT (1ST OPERAND) REGISTER
         SRL   GRM,4
         SLL   GRM,2 ........MULTIPLY REG DESIGNATION BY 4
         LD    FR0,OPND1 ....OVERLAY SAVE BUFFER OF RESULT REGISTER
         STD   FR0,SAVEFR0(GRM) WITH HIGH PART RESULT
         BR    GR4 ..........IF LRER OR LRDR, WE SKIP TO EPILOG6
EPILOG5  LD    FR0,OPND1+8 ..OVERLAY SAVE BUFFER OF COMPANION RESULT
         STD   FR0,SAVEFR2(GRM) REGISTER WITH LOW PART RESULT
         SPACE
EPILOG6  LD    FR0,SAVEFR0 ..RESTORE ALL FLOATING POINT REGISTERS
         LD    FR2,SAVEFR2
         LD    FR4,SAVEFR4
         LD    FR6,SAVEFR6
         LM    GRR,GR8,12(GRS) RESTORE OTHER REGISTERS
         SPM   GRR ............RESTORE PROGRAM MASK
         SR    GRL,GRL
         IC    GRL,ERRFLAG ....PICK UP ERRFLAG IN GRL
         LTR   GR9,GR9 ........IS THIS A RECURSIVE CALL ?
         L     GR9,56(GRS) ....RESTORE REGISTER 9
         L     GRW,SAVEGRW ....RESTORE REGISTER POINTING TO WORK AREA
         MVI   12(GRS),X'FF' ..RETURN
         BCR   7,GRR ..........BRANCH IF RECURSIVE CALL
         L     GRW,4(GR1) .....AREA TO STORE RETURN CODE
         ST    GRL,0(GRW) .....SAVE RETURN CODE
         TM    3(GRW),X'1C' ...EXCEPTIONAL CONDITION ?
         L     GRW,SAVEGRW ....RESTORE REGISTER POINTING TO WORK AREA
         BCR   8,GRR ..........IF RETURN CODE ZERO, TAKE NORMAL RETURN
         L     GRL,8(GR1) .....GET LOCATION OF ERROR RETURN
         BR    GRL ............TAKE ERROR RETURN
         EJECT
LRER     LE    FR0,OPND2 ....DOUBLE TO SHORT ROUNDING
         CLI   OPND2+4,X'80' ..TEST THE ROUND BIT
         BL    LRER1
         AU    FR0,INCR1 ......IF ROUND-UP, ADD 1 IN THE LAST BIT
LRER1    STE   FR0,OPND1 ......OVERLAY RESULT OVER 1ST OPERAND
         B     EPILOGD ........DONE
         SPACE 2
LRDR     LD    FR0,OPND2 ....EXTENDED TO DOUBLE ROUNDING
         CLI   OPND2+9,X'80' ..TEST THE ROUND BIT
         BL    LRDR1
         AW    FR0,INCR2 ......IF ROUND-UP, ADD 1 IN THE LAST BIT
LRDR1    STD   FR0,OPND1 ......OVERLAY RESULT OVER 1ST OPERAND
         B     EPILOGD ........DONE
         SPACE 2
SXR      XI    CHAR2,X'80' ..SUBTRACTION.   INVERT SIGN OF OPERAND 2
         SPACE
AXR      SDR   FR4,FR4 ......ADDITION
         STD   FR4,OPND1+16 ...CLEAR GUARD DIGIT OF BOTH OPERANDS
         STD   FR4,OPND2+16
         IC    GR0,CHAR1 ......COMPARE CHAR. OF OPERAND 1 AND
         IC    GR1,CHAR2 ........OPERAND 2.   HIGHER CHAR. IS STORED
         NR    GR0,GRM ..........IN HCHAR, AND SET GR2 POINTING TO
         NR    GR1,GRM ..........OPERAND WITH LOWER CHAR
         STC   GR0,HCHAR
         LA    GR2,OPND2
         SR    GR0,GR1
         BP    AXR1
         BZ    AXR3 ...........IF BOTH CHAR'S ARE SAME, SKIP
         STC   GR1,HCHAR
         LA    GR2,OPND1
         SPACE
AXR1     LNR   GR1,GR0 ........NEGATIVE OF CHAR DIFFERENCE
         C     GR1,LLIM
         BNL   AXR2 ...........IF DIFFERENCE IN CHAR'S IS GREATER
         STD   FR4,0(GR2) .......THAN 28, ZERO OUT OPERAND TO BE
         STD   FR4,8(GR2) .......SHIFTED
         B     AXR3 ...........SKIP
         SPACE
AXR2     LA    GR1,X'40'(GR1) .SUBTRACT DIFFERENCE IN CHAR'S FROM
         STC   GR1,0(GR2) .......X'40' AND AFFIX IT TO SMALLER OPERAND
         LA    GR1,X'FF2'(GR1) AFFIX CORRESPONDING CHAR. TO LOW PART
         STC   GR1,8(GR2) .....NOW WE ALIGN THE SMALLER OPERAND WITH
         LD    FR0,0(GR2) .......THE LARGER OPERAND, BY UNNORMALIZING
         LDR   FR2,FR0 ..........THE FORMER WITH CHAR. OF X'40'
         AW    FR0,CH40 .......SHIFT HIGH ORDER FRACTION
         STD   FR0,0(GR2) .....HIGH ORDER PART OF ALIGNED RESULT
         ADR   FR0,FR4 ........NORMALIZE HIGH ORDER PART
         SDR   FR2,FR0 ........GET DIGITS OF H.O. FRACTION SHIFTED
         LDR   FR0,FR2 ..........OUT OF H.O. FIELD
         AW    FR0,CH32 .......IF NECESSARY SHIFT H.O. PART FURTHER
         ADR   FR4,FR0 ........NORMALIZE IT
         SDR   FR2,FR4 ........GET DIGITS OF H.O. FRACTION SHIFTED
         LD    FR6,8(GR2) .......OUT OF L.O. PART OF OPERAND
         AWR   FR0,FR6 ........SHIFTED L.O. FRAC + LOST H.O. DIGITS
         AW    FR0,CH32 .......THIS IS NECESSARY IF THE LATTER WAS 0
         STD   FR0,8(GR2) .....LOW ORDER PART OF ALIGNED RESULT
         SDR   FR0,FR4
         SDR   FR6,FR0 ........GET DIGITS OF L.O. OPERAND SHIFTED
         ADR   FR2,FR6 ..........OUT OF L.O. PART OF OPERAND
         AW    FR2,CH31 .......SHIFT REMAINING DIGITS INTO GUARD
         STD   FR2,16(GR2) ......DIGIT
         SPACE
AXR3     L     GR0,CHAR1 ......COMBINE SIGN OF 2 OPERANDS
         X     GR0,CHAR2
         LTR   GR0,GR0 ........IF THEY ARE OF OPPOSITE SIGN, JUMP
         BM    AXR8
         SPACE
         MVI   OPND1+8,X'00' ..CASE OF LIKE SIGN.   ADD MAGNITUDE
         MVI   OPND2+8,X'00' ..CLEAR CHAR OF L.O. PARTS OF OPERANDS
         LD    FR0,OPND1 ......HIGH PART ACCUMULATED IN FR0
         LM    GR0,GR1,OPND1+8 LOW PART ACCUMULATED IN GR0, GR1
         AL    GR1,OPND2+12 ...LOW 8 DIGITS OF L.O. SUM
         BC    12,AXR4 ........ADD ANY CARRY TO H.O. 6 DIGITS
         AL    GR0,INCR3 ........OF L.O. SUM
AXR4     AL    GR0,OPND2+8 ....H.O. 6 DIGITS OF L.O. SUM
         C     GR0,ULIM1
         BL    AXR5 ...........IF THERE WAS ANY CARRY INTO BIT 7,
         AW    FR0,INCR2 ........ADD LOW BIT TO H.O. SUM IN FR0
AXR5     AW    FR0,OPND2 ......H.O. SUM
         BNZ   AXR6 ...........ENSURE THAT H.O. SUM HAS CHAR. X'40'
         LD    FR0,CH40 .........IF FRACTION IS ZERO
AXR6     CE    FR0,ULIM2
         BL    AXR7 ...........IF SUM LESS THAN 1.0, OK.   JUMP
         SPACE
         L     GR2,OPND1+4 ....IF SUM IS GE 1.0, CHAR. WAS RAISED
         AL    GR2,OPND2+4 ....RECONSTRUCT LOST 15TH DIGIT BY ADDING
         SLL   GR2,24 ...........14TH DIGITS OF OPERANDS, ADD IT ON
         ALR   GR0,GR2 ..........TO HEAD OF L.O. SUM, AND SHIFT THE
         SRDL  GR0,4 ............RESULT 1 DIGIT TO RIGHT
         SPACE
AXR7     STD   FR0,OPND1 ......STORE H.O. SUM
         STM   GR0,GR1,OPND1+8 STORE L.O. SUM
         IC    GR1,OPND1 ......COMPUTE AND AFFIX L.O. CHAR
         LA    GR1,X'FF2'(GR1)
         STC   GR1,OPND1+8
         LD    FR4,OPND1+16 ...ADD GUARD DIGITS IN PREPARATION FOR
         AW    FR4,OPND2+16 .....NORMALIZATION.   IF SUM IS GE 1.0
         B     AXR14 ............THIS IS IRRELEVANT.   JUMP TO MERGE
         SPACE
AXR8     LA    GR0,3 ..........CASE OF UNLIKE SIGN.   WE SUBTRACT
         SR    GR1,GR1 ..........SMALLER OPERAND FROM LARGER OPERAND
AXR9     LD    FR0,OPND1(GR1) .DETERMINE WHICH OPERAND HAS LARGER
         CD    FR0,OPND2(GR1) ...MAGNITUDE.   WE MUST COMPARE ALL
         BL    AXR10 ............3 COMPONENTS
         BH    AXR11
         LA    GR1,8(GR1)
         BCT   GR0,AXR9
         B     AXR11
AXR10    LM    GR0,GR5,OPND1 ..IF /OPERAND 2/ IS GREATER THAN
         MVC   OPND1(24),OPND2 ../OPERAND 1/, SWITCH THEM, SO THAT
         STM   GR0,GR5,OPND2 ....THE LATTE IS ALWAYS LARGER
         MVC   CHAR1(1),CHAR2 .ALSO REPLACE CHAR1 WITH CHAR2 FOR SIGN
         SPACE
AXR11    LD    FR0,OPND1 ....../OPERAND 1/ - /OPERAND 2/ STARTS HERE
         LD    FR2,OPND1+8
         LD    FR4,OPND1+16
         SW    FR4,OPND2+16 ...SUBTRACT GUARD DIGIT
         BNM   AXR12
         AW    FR4,INCR4 ......BORROW FROM L.O. DIFFERENCE IF NEEDED
         SW    FR2,INCR4
AXR12    SW    FR2,OPND2+8 ....SUBTRACT L.O. OPERANDS
         BNM   AXR13
         AW    FR2,INCR5 ......BORROW FROM H.O. DIFFERENCE IF NEEDED
         AW    FR2,INCR5 ........DO THIS IN 2 STEPS TO PRESERVE CHAR
         SW    FR0,INCR2 ........OF X'32'
AXR13    SW    FR0,OPND2 ......SUBTRACT H.O. OPERANDS
         STD   FR0,OPND1
         STD   FR2,OPND1+8
AXR14    STD   FR4,OPND1+16
         BAL   GRR,NORM .......NORMALIZE THE SUM/DIFFERENCE
         NI    CHAR1,X'80' ....RECONSTRUCT SIGN AND CHAR. OF OPERAND
         OC    CHAR1(1),HCHAR ...WITH HIGHER MAGNITUDE
         B     EPILOGC ........DONE
         SPACE 2
MXDR     LD    FR0,OPND1 ....DOUBLE BY DOUBLE MULTIPLY
         MD    FR0,OPND2 ......H.O. 14 DIGITS OF PRODUCT, NORMALIZED
         LM    GR0,GR1,OPND1 ..PICK UP 1ST OPERAND IN GR0, GR1, AND
         SLDL  GR0,4 ............DECOMPOSE IT INTO H.O. 7 DIGITS
         SRL   GR1,4 ............AND L.O. 7 DIGITS
         LM    GR2,GR3,OPND2 ..PICK UP 2ND OPERAND IN GR2, GR3, AND
         SLDL  GR2,4 ............DECOMPOSE IT INTO H.O. 7 DIGITS
         SRL   GR3,4 ............AND L.O. 7 DIGITS
         LR    GR5,GR0
         LR    GR0,GR2
         MR    GR4,GR3 ........H.O. 7 DGT OPND1 * L.O. 7 DGT OPND2
         MR    GR2,GR1 ........L.O. 7 DGT OPND1 * L.O. 7 DGT OPND2
         MR    GR0,GR0 ........L.O. 7 DGT OPND1 * H.O. 7 DGT OPND2
         SLDL  GR2,4 ..........SUM UP THESE PRODUCT WITH CORRECT
         ALR   GR2,GR1 ..........SCALING, AND IGNORE CARRY INTO H.O.
         ALR   GR2,GR5 ..........14 DIGITS
         SRDL  GR2,4
         SPACE
         STM   GR2,GR3,OPND1+8 STORE L.O. UNNORMALIZED RESULT
         MVI   OPND1+8,X'32' ..FLOAT IT WITH PROPER CHAR.
         STD   FR0,OPND1 ......STORE H.O. NORMALIZED RESULT
         LD    FR2,CH40 .......SHIFT OUT FROM H.O. RESULT THE FIELD
         AWR   FR2,FR0  .........WHICH OVERLAPS WITH L.O. RESULT
         AD    FR2,ZERO .......NORMALIZE IT
         SDR   FR2,FR0  .......NEGATIVE OF OVERLAPPING FIELD
         AD    FR2,OPND1+8 ....REMOVE OVERLAPPING PART FROM L.O. PART
         BAL   GRR,NORM1 ......GO TO NORM1 TO ALIGN L.O. PART
         B     EPILOGB ........DONE
         SPACE 2
MXR      LR    GR4,GRL ......EXTENDED BY EXTENDED MULTIPLY
         DROP  GRL ............SWITCH BASE REGISTER
         USING QSIM,GR4
         LR    GR3,GRS ........SWITCH SAVE AREA POINTER
         LA    GRS,SAVE
         ST    GR3,4(GRS)
         ST    GRS,8(GR3)
         SPACE
         LD    FR0,OPND1+8 ....(A1+A2)*(B1+B2)
         MXD#  FR0,OPND2+8 ....A2*B2
         LD    FR4,OPND1
         MXD#  FR4,OPND2+8 ....A1*B2
         AXR#  FR0,FR4 ........A1*B2+A2*B2
         LD    FR4,OPND1+8
         MXD#  FR4,OPND2 ......A2*B1
         AXR#  FR0,FR4 ........A2*B1+A1*B2+A2*B2
         LD    FR4,OPND1
         MXD#  FR4,OPND2 ......A1*B1
         AXR#  FR0,FR4 ........A1*B1+A2*B1+A1*B2+A2*B2
         SPACE
         STD   FR0,OPND1
         STD   FR2,OPND1+8
         DROP  GR4 ............RESTORE BASE REGISTER
         USING QSIM,GRL
         LR    GRS,GR3 ........RESTORE SAVEAREA POINTER
         B     EPILOGB ........DONE
         SPACE 2
DXR      CLI   OPND2+1,X'00' DIVIDE SIMULATION
         BNZ   DXR1 ...........IF DIVISOR NE 0, SKIP AND CONTINUE
         MVI   ERRFLAG,X'0C' ..IF DIVIDE CHECK, SET FLAG OF '0C'
         CLI   OPND1+1,X'00' ....OR '10' DEPENDING ON WHETHER  THE
         BNZ   EPILOG6 ..........DIVIDEND IS NON-ZERO OR ZERO
         MVI   ERRFLAG,X'10'
         B     EPILOG6 ........ABORT THE OPERATION
         SPACE
DXR1     EQU   *
         LR    GR4,GRL ........DIVISOR IS NOT ZERO
         DROP  GRL ............SWITCH BASE REGISTER
         USING QSIM,GR4
         LR    GR3,GRS ........SWITCH SAVEAREA POINTER
         LA    GRS,SAVE
         ST    GR3,4(GRS)
         ST    GRS,8(GR3)
         SPACE
         LD    FR4,OPND1 ......(A1+A2)/(B1+B2) WITH EXACT TRUNCATION
         LD    FR6,OPND1+8
         LDR   FR0,FR4
         DD    FR0,OPND2 ......Q1=A1/B1 APPROX. H.O. 14 DIGITS OF A/B
         MD    FR0,DECR .......UNDERESTIMATE Q1 BY Q1*16**-12.
         STD   FR0,BUFF1 ........THIS DONE SO THAT Q1 AND Q2+Q3 WILL
         MXD#  FR0,OPND2 ........HAVE THE SAME SIGN
         SXR#  FR4,FR0 ........(A1+A2)-Q1*B1  EXACT
         LD    FR0,BUFF1
         MXD#  FR0,OPND2+8
         SXR#  FR4,FR0 ........(A1+A2)-Q1*(B1+B2)  CALL THIS A3+A4
         SPACE
         LDR   FR0,FR4
         DD    FR0,OPND2 ......Q2=A2/B1  ESTIMATE FOR NEXT 14 DIGIT
         STD   FR0,BUFF2
         MXD#  FR0,OPND2
         SXR#  FR4,FR0 ........(A3+A4)-Q2*B1
         LD    FR0,BUFF2
         MD    FR0,OPND2+8
         SDR   FR4,FR0 ........(A3+A4)-Q2*(B1+B2)=A-(Q1+Q2)*B SET =A5
         SPACE
         DD    FR4,OPND2 ......Q3=A5/B1  REL. ACCURACY ABOUT 16**-38
         LE    FR0,BUFF1
         ME    FR0,INCR6 ......CRANK Q3 BY Q1*16**-35, SO THAT
         ADR   FR4,FR0 ..........Q1+Q2+Q3 IS NEVER UNDERESTIMATE
         LD    FR0,BUFF2
         SDR   FR2,FR2
         AXR#  FR4,FR0 ........Q2+Q3
         LD    FR0,BUFF1
         AXR#  FR4,FR0 ........Q=Q1+Q2+Q3 TRUNCATED
         LTR   GR8,GR8 ........SHOULD WE ADJUST ?
         BNZ   DXR2 ...........NO - BRANCH
         SPACE
         STD   FR4,BUFF1 ......THERE IS A FAINT CHANCE THAT Q IS
         STD   FR6,BUFF2 ........ROUNDED UP WHERE IT SHOULDN'T
         MXD#  FR4,OPND2 ......SO WE VERIFY THE EXACTNESS OF TRUNC.
         LD    FR0,OPND1 ......CALL Q=Q1+Q2 ANEW
         LD    FR2,OPND1+8
         SXR#  FR0,FR4 ........A-Q1*B1
         LD    FR4,BUFF1
         MXD#  FR4,OPND2+8
         SXR#  FR0,FR4 ........A-Q1*B1-Q1*B2=A-Q1*B
         LD    FR4,BUFF2
         MXD#  FR4,OPND2
         SXR#  FR0,FR4 ........A-Q1*B-Q2*B1
         LD    FR4,BUFF2
         MXD#  FR4,OPND2+8 ....Q2*B2
         SXR#  FR0,FR4 ........A-Q*B COMPUTED EXACTLY
         LD    FR4,BUFF1 ......RELOAD Q1 AND Q2
         LD    FR6,BUFF2
         LTDR  FR0,FR0
         BNM   DXR2 ...........IF Q WAS NOT OVERESTIMATE, OK.  SKIP
         SPACE
         MVC   BUFF2+1(7),ZERO+1 IF Q WAS OVER-ESTIMATE, PREPARE
         LD    FR0,BUFF2 ........DECREMENTER WITH CHAR = CHAR(Q)-14
         LE    FR2,INCR6 ........AND FRACTION OF 1 IN THE 15TH DIGIT
         SXR#  FR4,FR0 ........DECREMENT Q
         SPACE
DXR2     STD   FR4,OPND1
         STD   FR6,OPND1+8
         DROP  GR4
         USING QSIM,GRL .......RESTORE BASE REGISTER
         LR    GRS,GR3 ........RESTORE SAVEAREA POINTER
         B     EPILOGA ........DONE
         SPACE 2
NORM     TM    OPND1+1,X'F0' NORMALIZATION SECTION
         BCR   7,GRR ..........IF OPND1 ALREADY NORMAL, RETURN
         LD    FR0,OPND1 ......LOAD OPND1 IN FR0-FR2-FR4
         LD    FR2,OPND1+8
         LD    FR4,OPND1+16
         AD    FR0,ZERO .......NORMALIZE H.O. PART
         LDR   FR6,FR0
         ADR   FR0,FR2 ........NORMAL SUM OF H.O. AND L.O. PART
         ADR   FR4,FR0 ........ADD GUARD DIGIT TO COMPLETE H.O. PART
         STD   FR4,OPND1 ......STORE IT
         SDR   FR4,FR0 ........CONTRIBUTION TO H.O. PART BY GUARD DGT
         SDR   FR0,FR6 ........CONTRIBUTION TO H.O. PART BY L.O. PART
         SDR   FR2,FR0 ........L.O. PART YET TO BE ACCOUNTED FOR
         LTDR  FR4,FR4 ........IF GUARD DIGIT ALREADY HAS CONTRIBUTED
         BNZ   NORM1 ............TO H.O. SUM, SKIP
         AD    FR2,OPND1+16 ...OTHERWISE ADD GUARD DIGIT TO L.O. SUM
         SPACE
NORM1    IC    GR1,OPND1 ......PREPARE UNNORMALIZER WITH CHAR 14 LESS
         LA    GR1,X'FF2'(GR1) ..THAN THAT OF NORMALIZED H.O. PART
         SLL   GR1,24
         SR    GR2,GR2
         STM   GR1,GR2,OPND1+8
         AW    FR2,OPND1+8 ....UNNORMALIZE L.O. SUM SO AS TO BE
         STD   FR2,OPND1+8 ......ALIGNED WITH H.O. SUM
         BR    GRR ..........DONE
         SPACE 3
STORE1   STD   FR0,OPND1 ......INSTRUCTIONS TO BE EXECUTED TO BRING
STORE2   STD   FR0,OPND2 ........IN THE OPERANDS
STORE3   STD   FR0,OPND2+8
STORE4   STD   FR0,OPND1+8
         DS    0F
INCR6    DC    X'1E100000' ....16**-35
INCR1    DC    X'40000001' ....FOR ROUNDING
INCR3    DC    X'00000001' ....FOR CARRY BIT
LLIM     DC    F'-28'      ....TO LIMIT SHIFT
ULIM1    DC    X'01000000' ....TO TEST CARRY
ULIM2    DC    X'41100000' ....TO TEST CARRY   1.0
ZERO     DC    D'0' ..................NORMAL ZERO
DECR     DC    X'40FFFFFFFFFFFF00' ...1-16**-12
CH31     DC    X'3100000000000000' ...GUARD DGT SCALING CHAR
CH32     DC    X'3200000000000000' ...L.O. OPERAND SCALING CHAR
CH40     DC    X'4000000000000000' ...H.O. OPERAND SCALING CHAR
INCR2    DC    X'4000000000000001' ...FOR ROUNDING
INCR4    DC    X'3100000000000010' ...FOR BORROW BY GUARD DIGIT
INCR5    DC    X'3280000000000000' ...FOR BORROW BY L.O. DIGIT
         END
