         TITLE 'IEAVSY50....WAIT * POST * TCB SWITCHING'
*ROUTINE NAME-           IGC001, WAIT SVC ROUTINE
*
*FUNCTIONS-            1.CAUSES THE ISSUING RB CONTROL LEVEL TO
*                        STOP PROCESSING AND WAIT ON THE OCCURANCE
*                        OF ONE OR MORE EVENTS.
*
*ENTRY POINT NAMES-      IGC001, WAIT SVC ENTRY POINT
*                        IEAVWAIT - WAIT BRANCH ENTRY
*
*CONTAINED IN MODULE-    IEAVSY50- WAIT/POST SYNCHRONIZATION MODULE
*
*ATTRIBUTES-             RESIDENT,RE-ENTRANT,SUPERVISOR STATE,
*                        LOCAL LOCK, KEY 0, TYPE 1 SVC.
*
*
*EXTERNAL REFERENCES    IEA0VL01- VALIDITY CHECK ROUTINE
*
*                        SYSTEM RESOURCES MANAGER
*
*                        WHEN ASCBTCBS GOES TO ZERO (ALL TCBS IN
*                        ADDRESS SPACE NON-DISPATCHABLE OR IN WAIT)
*                        BECAUSE OF A LONGWAIT BEING ISSUED, THE
*                        NIOWAIT SYSEVENT IS ISSUED.
*
*                        MACRO CALL -
*
*                        SYSEVENT NIOWAIT,ENTRY=BRANCH
*
*                        INPUT - REGISTER 13 HAS ADDR OF 72 BYTE SAVE
*                        AREA
*                        _ REGISTER 0 HAS  NIOWAIT CODE AND
*                        DEFAULT ASID = 0 IN HIGH TWO BYTES
*
*INPUT-                  REGISTER 0 CONTAINS A COUNT OF THE NUMBER
*                        OF EVENTS THAT MUST OCCUR BEFORE THE
*                        ISSUING TASK CAN CONTINUE IN CONTROL. IF THE
*                        SIGN BIT IS ON, THE REQUEST IS A LONGWAIT.
*
*                        REGISTER 1 CONTAINS 0, OR THE ADDRESS OF A
*                        SINGLE ECB(EVENT CONTROL BLOCK) OR
*                        THE ADDRESS OF A LIST OF ECB'S TO BE
*                        WAITED UPON.  A COMPLEMENTED REGISTER, IF SET
*                        SIGNALS THE PRESENCE OF A LIST.  0 INDICATES
*                        WAIT WITHOUT ECB AND IS VALID ONLY FOR
*                        BRANCH ENTRY.
*
*
*OUTPUT-                 NONE
*
*ENTRY POINTS-         1.IGC001,GIVEN CONTROL VIA THE SVC
*                        INTERRUPT HANDLER(FLIH).
*
*                      2. IEAVWAIT, BRANCH ENTRY, LOCAL LOCK,
*                         KEY 0.
*
*EXIT POINT-           1.TO TYPE I EXIT PROLOGUE FORCE DISP ENTRY
*                        IF SVC CALLER AND RB IS PUT INTO WAIT STATE
*
*                      2.TO TYPE 1 EXIT PROLOGUE IF SVC CALLER AND RB
*                        IS NOT PUT IN WAIT (REG 14 ON ENTRY)
*
*                      3.TO THE DISPATCHER IF BRANCH ENTRY
*                        THE LOCAL LOCK IS FREED AND THE PSW
*                        IS DISABLED PRIOR TO DISPATCHER ENTRY.
*
*ERROR EXIT POINTS-    1.TO ABEND
*
*                        THE ERROR CODES ARE.
*                        X'0101' ERROR CODE #1 NUMBER OF ECBS TO
*                                              BE WAITED UPON EX-
*                                              CEEDS THE NUMBER OF
*                                              ECBS GIVEN.
*                        X'0201' ERROR CODE #2 THE ECB ADDRESS IS
*                                              INVALID.
*                        X'0301' ERROR CODE #3 AN ATTEMPT IS BEING
*                                              MADE TO SET THE WAIT
*                                              FLAG IN AN ECB WHICH
*                                              IS ALREADY SET.
*
*
         EJECT
*
IGC001   START
         USING *,R6
         MODID BR=YES
         DROP  R6
         SPACE 2
*WAITING ECB
*************************
* S     *               *
*  BIT  * WAITING RB'S  *
*   ON  *   ADDRESS     *
*************************
         SPACE 1
*POSTED ECB
*************************
* 1       BITS 2-31     *
*  BIT     COMPLETION   *
*   ON      CODE        *
*************************
         SPACE 2
         SPACE 1                                                   MTS0
* GENERAL EQUATES
ERRWAIT1 EQU   X'0101'               WAIT'S, WAIT COUNT TO BIG
ERRWAIT2 EQU   X'0201'               WAIT ECB ADDRESS INVALID
ERRWAIT3 EQU   X'0301'               TRYING TO PUT WAITING ECB IN WAIT
ERRPOST1 EQU   X'0102'               POST ECB ADDRESS INVALID
ERRPOST2 EQU   X'0202'               POST ECB'S RB ADDRESS INVALID
ECBPTFLG EQU   X'40'                 ECB POST FLAG
RECBWTF  EQU   X'7F'                 RESET ECB WAIT FLAG/LAST ECB PT
LSTIND   EQU   X'80'                 LAST ECB INDICATOR
TCBIND   EQU   X'80'                 RBLINK INDICATES TCB ADDRESS
ECBWTFLG EQU   X'80'                 ECB WAIT FLAG
SUPTST   EQU   X'80'                 PSW PROTECT KEY FIELD       Y02139
RRBECBWT EQU   X'FE'                 RESET RB'S ECB SEARCH FLAG
ANYONE   EQU   X'FF'                 TEST FOR ANY BIT IN A BYTE
XFF      EQU   X'FF'                 ALL ONES                  @Z40EPVD
M0011    EQU   B'0011'               MASK USED IN ICM INST     @Z40EPVD
L2       EQU   2                     LENG OF 2
L3       EQU   3                     LENGTH OF 3
L8       EQU   8                     VALUE OF 8                  Y02139
C12      EQU 12                      CONST OF 12
WDBOUND  EQU   X'03'                 TO TEST FOR WD BOUNDARY
FOUR     EQU   4                     FOUR                         20021
ZERO     EQU   0                     CONSTANT                     20021
LAST     EQU   1                     TESTS FOR LAST PARM IN A LIST
ON2      EQU   1                     CONDITION FOR ALL BITS ON
OFF2     EQU   12                    CONDITION FOR ALL BITS NOT ON
KEY0     EQU   8                     CONDITION FOR ALL BITS OFF
ECBADDR  EQU   0                     ADDRESS OF ECB IN PARMLIST
ERRTADDR EQU   8                     ADDR OF ERRET IN PARMS      Y02139
ASCBADDR EQU   4                     ADDR OF ASCB IN PARMS       Y02139
ENABON   EQU   X'03'                 TESTS FOR ENABLED PSW
DISABLE  EQU   X'FC'                 DISABLE MASK                Y02139
XWTOFF   EQU   X'BF'                 TURNS OFF RBXWAIT BIT
DISAB    EQU   12                    CONDITION FOR DISABLED PSW
HBYTE    EQU   4                     SHIFT OF 4 BITS
NOTKEY0  EQU   5                     CONDITION FOR NOT KEY ZERO
ABNDALGN EQU   12                    SHIFTS ABEND CODE 12 BITS
ABENINST EQU   13                    FOR ISSUEING SVC 13 FOR ABEND
XMASASID EQU   4                     MASTER SCHED ASID X 4      @Y02752
ONE      EQU   1                     CONST OF 1                  Y02139
SRBSV    EQU   0                     DISP IN SAVE AREA FOR SRB @YM01534
SPOSTRT  EQU   4                     DISP IN SV AREA-RET ADDR  @YM01534
         SPACE 1
*        INPUT PARAMETER LIST FORMAT FOR                       @ZA15373
*        SVC ENTRY CROSS MEMORY POST REQUESTS                  @ZA15373
         SPACE 1
ECBPTR   EQU   0                     OFFSET TO ECB ADDRESS     @ZA15373
ASCBPTR  EQU   4                     OFFSET TO TARGET ASCB ADDR@ZA15373
ERRETPTR EQU   8                     OFFSET TO ERRET ADDRESS   @ZA15373
ECBKEY   EQU   12                    OFFSET TO ECB VAL CHK KEY @ZA15373
         SPACE 1
CCODE    EQU   4                     CREATE FUNCTION CODE      @Z40EPVD
DCODE    EQU   8                     DELETE FUNCTION CODE      @Z40EPVD
EIGHT    EQU   8                     NUMERIC 8                 @Z40EPVD
HIGHBIT  EQU   1                     WAIT BIT                  @Z40EPVD
LOWBITS  EQU   3                     EXTENDED ECB INDICATORS   @Z40EPVD
RC0      EQU   0                     REASON CODE 0             @Z40EPVD
RC4      EQU   4                     REASON CODE 0             @Z40EPVD
RC8      EQU   8                     REASON CODE 8             @Z40EPVD
RCC      EQU   12                    REASON CODE C             @Z40EPVD
RC10     EQU   16                    REASON CODE 10            @Z40EPVD
RC14     EQU   20                    REASON CODE 14            @Z40EPVD
         SPACE 2
* REGISTER EQUATES.
         SPACE 1
* WAIT AND POST
R0       EQU   0                   INPUT REG 0                   Y02139
WS0      EQU   4*R0                SA OFFSET FOR R0              Y02139
R1       EQU   1                   INPUT REG 1                   Y02139
WS1      EQU   4*R1                SA OFFSET FOR R1              Y02139
XRSCRTCH EQU   2                   SCRATCH PAD REG                20002
R2       EQU   2                   REG 2
ECBE2    EQU   2                   ADDR OF ECB EXT             @Z40EPVD
FRRWA3   EQU   3                   FRR WORK AREA ADDR          @Z40EPVD
XRWORK   EQU   3                   WORK REG
R3       EQU   3                   REG 3
XRTCB    EQU   4                   ADDRESS OF  TCB               Y02139
R4       EQU   4                   REG 4
XRRB     EQU   5                   ADDRESS OF  RB                Y02139
R5       EQU   5                   REG 5
XRECB    EQU   6                   ECB ADDR REG
R6       EQU   6                   REG 6
XRASCB   EQU   7                   ASCB POINTER                  Y02139
R7       EQU   7                   REG 7
XRWAITCT EQU   8                   WAIT COUNT
R8       EQU   8                   REG 8
XRPTCODE EQU   9                   INPUT POST CODE
XRECBCTR EQU   9                   COUNT OF ECBS
R9       EQU   9                   UPPER REG SAVED IN POST       Y02139
XRECBPTR EQU   10                  UPDATED ECB ADDRESS
R10      EQU   10                  BR ENTRY POST INPUT REG       Y02139
XRSAVE   EQU   11                  SAVE REGISTER FOR REG. 1      Y02139
R11      EQU   11                  BR ENTRY POST INPUT REG       Y02139
XRLINKR  EQU   12                  LINK REGISTER                 Y02139
R12      EQU   12                  REG 12
R13      EQU   13                  SAVE AREA PTR                 Y02139
XRRETURN EQU   14                  TYPE 1 SVC HANDLER ADDRESS (SVCXT)
R14      EQU   14                  SUBRTN LINK REG               Y02139
XRBASE   EQU   15                  BASE REGISTER
R15      EQU   15                  SUBRTN BASE REG               Y02139
         SPACE 2
* ENTRY AND EXTRN STATMENTS.
         ENTRY IEAVWAIT             WAIT BRANCH ENTRY            Y02139
         ENTRY IEA0PT01             POST 1
         ENTRY IEA0PT02             POST 2
         ENTRY IEA0PT03             POST EXIT ROUTINE E.P.     @Z40EPVD
         ENTRY IEA0PT0E             EXIT IDENTIFY/DELETE E.P.  @Z40EPVD
         ENTRY IGC002               POST
         ENTRY IEASPOST             PURGEDQ PARAMETER LIST FOR SPOST
         ENTRY IEARPOST             POST RMTR
         EXTRN IEA0DS               DISPATCHER                   Y02139
         EXTRN IEA0VL01             VAL CHECK                    Y02139
         EJECT
* WAIT SVC ROUTINE.
*     THE WAIT SVC ROUTINE WILL PLACE THE RB (REQUEST BLOCK)
*  OF THE REQUESTING ROUTINE INTO A WAIT STATE.  THIS IS
*  ACCOMPLISHED BY SETTING THE WAIT COUNT FIELD IN THE RB.
*  AN RB WAIT STATE WILL PREVAIL UNTIL THE WAIT COUNT IS REDUCED
*  TO ZERO BY THE SVC POST ROUTINE.  THE WAIT FLAG AND REQUESTING
*  RB ADDRESS ARE SET IN EACH ECB.  FOR EVERY ECB WHOSE POST
*  FLAG IS ALREADY SET, THE WAIT COUNT IN REGISTER 0 IS
*  DECREMENTED.  IF THIS COUNT GOES TO ZERO,(INDICATING THAT
*  POSTING HAS ALREADY COMPLETED) WAIT RESETS ALL PROCESSED ECBS
*  AND RETURNS.  THE WAIT COUNT IS ALWAYS STORED IN THE REQUESTORS
*  RB.
*/*WAIT: CHART*/
*/*IGC001: E SVC ENTRY*/
IGC001   CSECT
*/* P SET UP BASE REG*/
         BALR  XRBASE,ZERO             ADDRESSABILITY
         USING *,XRBASE                PROGRAM BASE
WAITBAS  EQU   *                       BASE STARTING POINT
         USING RBSECT,XRRB             RB BASE                   Y02139
         USING TCB,XRTCB               TCB BASE                  Y02139
         USING FLC,0                   FIXED LOW CORE BASE       Y02139
         USING ASCB,XRASCB             ASCB BASE REG             Y02139
*/* P SET R14 TO EXIT PROLOG FORCE DISPATCHER ENTRY ADDR*/
         L     R14,CVTEXP1-CVTMAP(,R3) GET FORCE ENTRY ADDR
*/*BRENTRY: P ENABLE RB OLD PSW*/
BRENTRY  OI    RBOPSW,ENABON           ENABLE OLD PSW
*/* P ADDRESS LOCAL SAVE AREA AND SAVE REGS*/
         L     XRSAVE,ASCBASXB         ADDRESS OF ASXB           Y02139
         USING ASXB,XRSAVE             BASE FOR ASXB             Y02139
         L     XRSAVE,ASXBSPSA         ADDR OF LOCAL WSAVT       Y02139
         USING WSAL,XRSAVE             ADDR OF WSAVT             Y02139
         L     XRSAVE,WSALWAIT         ADDR OF WAIT WSA          Y02139
         DROP  XRSAVE                                            Y02139
         STM   R0,R1,WS0(XRSAVE)       SAVE INPUT REGS           Y02139
*/* P ENSURE POSITIVE WAIT COUNT*/
*
*              ALL THIS CODE IS NECESSARY AS WAIT HAS A DOUBLE
*              INTERFACE.  THE COUNT OF EVENTS MAY BE (FOR LONG WAIT
*              ONLY) IN COMPLEMENTED FORM OR SIMPLY WITH THE HIGH
*              ORDER BIT ON.  THE FOLLOWING CODE ASSURES THE CORRECT
*              WAIT COUNT.
*
         LR    XRECB,R1                SET UP ECB REG            Y02139
         LR    XRWAITCT,R0             DUPLICATE WAIT CT
         ALR   XRWAITCT,XRWAITCT       DOUBLE WAIT COUNT
         LPR   XRWAITCT,XRWAITCT       MAKE COUNT POSITIVE
         SRL   XRWAITCT,ONE            DIVIDE BY 2
*/*ENDWTCT: D (YES,WAITEXIT,NO,) WAIT COUNT IS ZERO*/
ENDWTCT  LTR   XRWAITCT,XRWAITCT       Q.REQUESTOR WAIT COUNT ZERO
         BC    8,WAITEXIT              *YES RETURN TO CALLER
         LA    XRECBCTR,ONE            INITIALIZE ECB COUNTER TO 1
         SPACE
         LR    XRWORK,XRWAITCT         DUPLICATE WAIT COUNT    @Y30HPVA
         SPACE
*/* D (BR,WSUPENT,SVC,) BR OR SVC ENTRY*/
         LTR   XRRETURN,XRRETURN       BRANCH ENTRY              Y02139
         BM    WSUPENT                 BR IF SO                  Y02139
*/* D (YES,WSUPENT,NO,) CALLER IS SUPVR KEY*/
         TM    RBOPSW+ONE,SUPTST       ENTRY FROM A SUPERVISOR KEY CALL
         BZ    WSUPENT                 YES - TAKE BRANCH
*/* D (YES,WNON0ENT,NO,) ECBLIST SPECIFIED*/
         LCR   XRECBPTR,XRECB          Q. LIST REQUEST ?
         BP    WNON0ENT                YES - BRANCH
*/* S ADDROK: VALIDITY CHECK ECB*/
         BAL   XRLINKR,ADDROK          GO CHECK ADDRESS OUT
*/* D (GOOD,ECBWT,FAIL,) RESULTS OF VALIDITY CHECK*/
*/* S (,ECBWT) CHKCOMTS: CHECK FOR COMM TASK ECB*/
         BNE   CHKCOMTS                INVALID - CHECK FOR CSCB ECB
         B     ECBWT                   GO EXIT FROM PREFIX
*/*WNON0ENT: S ADDROK: VALIDITY CHECK LIST WORD*/              @YM32396
WNON0ENT DS    0H                      LIST REQUEST            @Y30HPVA
         LR    R1,XRECBPTR             ADDR IN R1 FOR VAL CHK  @YM32396
         BAL   XRLINKR,ADDROK          SUBRTN INVOKES VAL CHK  @YM32396
*/* D (FAIL,ERROR201,GOOD,) RESULTS OF VALIDITY CHECK*/        @YM32396
         BNE   ERROR201                INVALID ECBLIST
*/* S ADDROK: VALIDITY CHECK ECB*/
         L     XRECB,ZERO(,XRECBPTR)   GET ECB ADDRESS         @YM01876
         LR    R1,XRECB                SAVE ADDR TO CHK LIST END  AS2PR
         BAL   XRLINKR,ADDROK          VALIDATE IT
*/* D (GOOD,%W1,FAIL,) RESULTS OF VALIDITY CHECK*/
*/* S CHKCOMTS: CHECK FOR COMM TASK ECB*/
         BNE   CHKCOMTS                CHK FOR CSCB ECB
         SPACE
*/*%W1: D (NO,NEXT1,YES,) ECB POSTED*/                         @Y30HPVA
         TM    0(XRECB),ECBPTFLG       ECB POSTED              @Y30HPVA
         BZ    NEXT1                   NO. DO NOT COUNT IT     @Y30HPVA
*/* P COUNT POSTED ECB*/                                       @Y30HPVA
*/* D (YES,GETOUT,NO,) REQUESTED WAIT CT. = POSTED CT.*/       @Y30HPVA
         BCTR  XRWORK,R0               DECR REQ # ECBS POSTED  @ZA05968
         LTR   XRWORK,XRWORK           COUNT GONE TO ZERO?     @ZA05968
         BZ    GETOUT                  YES, TERMINATE PROCESS  @ZA05968
NEXT1    EQU   *                       BYPASSES COUNTING ECB   @Y30HPVA
         SPACE
*/*NEXT1: P COUNT ECB- GET NEXT ECBLIST ENTRY*/
         TM    0(XRECBPTR),LSTIND      CHK FOR END-OF-LIST IND
         BC    1,ECBWT                 BR IF SO
*/* D (YES,ECBWT,NO,WNON0ENT) END OF ECBLIST*/
         LA    XRECBCTR,ONE(XRECBCTR)  INCR ECB COUNTER
         LA    XRECBPTR,FOUR(XRECBPTR) POINT TO NEXT ECB IN LIST
         B     WNON0ENT                GO HANDLE NEXT ELEMENT IN LIST
*/*WSUPENT: D (ZERO,NOZERO,ECB,ECBWT,LIST,) TEST HOW ECB SPECIFIED*/
WSUPENT  DS    0H
         LCR   XRECBPTR,XRECB          Q. LIST REQUEST
         BM    ECBWT                   IF NOT A LIST - BRANCH
         BZ    NOZERO                  BR IF WAIT WITHOUT ECB
         SPACE
*/*WSLIST: D (NO,NEXT2,YES,) ECB POSTED*/                      @Y30HPVA
WSLIST   EQU   *                       LOOP THRU ECB LIST      @Y30HPVA
         L     XRECB,ZERO(,XRECBPTR)   GET ECB ADDRESS         @Y30HPVA
         TM    0(XRECB),ECBPTFLG       ECB POSTED              @Y30HPVA
         BZ    NEXT2                   NO. DO NOT COUNT IT     @Y30HPVA
*/* P COUNT POSTED ECB*/                                       @Y30HPVA
*/* D (YES,GETOUT,NO,) REQ. WAIT CT. = POSTED CT.*/            @Y30HPVA
         BCTR  XRWORK,R0               DECR REQ # ECBS POSTED  @ZA05968
         LTR   XRWORK,XRWORK           COUNT GONE TO ZERO?     @ZA05968
         BZ    GETOUT                  YES, TERMINATE PROCESS  @ZA05968
*/*NEXT2: P COUNT ECB AND GET NEXT LIST ENTRY*/                @Y30HPVA
NEXT2    EQU   *                       BYPASS COUNTING ECB     @Y30HPVA
         SPACE
WSLIST1  TM    0(XRECBPTR),LSTIND      TEST FOR LAST ECB ADDR
         BC    1,ECBWT                 BR IF SO
*/* D (NO,WSLIST,YES,) END OF LIST*/
         LA    XRECBCTR,ONE(XRECBCTR)  INCREASE ECB COUNTER (SEE ABOVE)
         LA    XRECBPTR,FOUR(XRECBPTR) BUMP TO NEXT ECB ADDR
         B     WSLIST                  BRANCH
         EJECT
*/*ECBWT: D (EQ,ECBWT1,GT,ERROR101,LT,) WAIT COUNT VS # ECBS*/
ECBWT    DS    0H
         L     XRECBPTR,WS1(XRSAVE)     ESTABLISH ORIG ECBPTR
         CR    XRECBCTR,XRWAITCT        Q.ECB CT. LT WAIT CT.
         BE    ECBWT1                   EQUAL, TAKE BRANCH        AS2PR
         BL    ERROR101                 *** YES, TAKE BRANCH
*/* P SET ON RB SEARCH BIT*/
         OI    RBSTAB2,RBECBWT          SET RB'S ECB SEARCH FLAG
*/*ECBWT1: P INITIALIZE ECB POINTER*/
ECBWT1   LCR   XRECBPTR,XRECBPTR        ECB OR ECBLIST            AS2PR
         BM    PKEY1                    BR IF ECB
PKEY     L     XRECB,0(XRECBPTR)        GET ECB ADDR FRM LIST
*/*PKEY1: P PICK UP ECB FOR LATER COMPARE AND SWAP*/
PKEY1    L     R0,ZERO(,XRECB)          GET ECB NOW            @YM02795
*/*PKEY2: D (YES,CFLAGON,NO,) ECB ALREADY POSTED*/
PKEY2    TM    0(XRECB),ECBPTFLG        Q.ECB'S POST FLAG SET
         BO    CFLAGON                  YES,TAKE BRANCH
*/* D (YES,ERROR301,NO,) IS ECB ALREADY WAITED UPON*/
         TM    ZERO(XRECB),ECBWTFLG     Q.IS ECB WAIT FLAG SET
         BO    ERROR301                 *** YES TAKE BRANCH TO ABTERM
*/* P CS RB ADDR AND WAIT BIT IN ECB*/
         LR    R1,XRRB                  SET RB ADR IN REG       @Y02752
         O     R1,TIDBIT                SET WAIT BIT            @Y02752
         CS    R0,R1,ZERO(XRECB)      CS RB ADDR/WAIT BIT TO ECB@Y02752
*/* D (NO,PKEY2,YES,) COMPARE AND SWAP GO */
         BNZ   PKEY2                    GO CHECK WHAT HAPPENED  @Y02752
         SPACE 2
*/*UPDATE: P UPDATE ECB LIST POINTER*/
UPDATE   LA    XRECBPTR,FOUR(XRECBPTR)  UPDATE ECB LIST ADR
*/* D (MORE,PKEY1,DONE,) BCT CHECK FOR MORE ECBS*/
         BCT   XRECBCTR,PKEY            Q.DECREMENT ECB CTR (NOT 0 BR)
*/*NOZERO: P SET EXPLICIT WAIT BIT IN RB*/
NOZERO   S     XRRB,WPRBPREL            GET PREFIX ADDRESS       AS2708
         OI    RBFLAGS1-RBPREFIX(XRRB),RBXWAIT SET RBXWAIT BIT   AS2708
         A     XRRB,WPRBPREL            RESET RB BASE REG
*/* P DECR ASCBTCBS USING CS*/
         L     XRWORK,ASCBTCBS          GET TCB RDY CT
CSTCBSDN LR    XRSCRTCH,XRWORK          DUPLICATE VALUE
         BCTR  XRSCRTCH,R0              DECREMENT
         CS    XRWORK,XRSCRTCH,ASCBTCBS  COMP/SWAP CT
         BNZ   CSTCBSDN                 BR IF DID NOT GO
*/* P SET RB WAIT COUNT*/
         STC   XRWAITCT,RBWCF           ST WAIT COUNT IN REQUESTING RB
*/* D (NO,LONGWAIT,YES,) ALL TCBS IN A.S. NOT READY*/
         LTR   XRSCRTCH,XRSCRTCH        TEST FOR CT GO TO ZERO @YM01524
         BNZ   LONGWAIT                 BR IF AS NOT ALL IN WAIT
*/* P INCREMENT ASCB SHORT WAIT COUNT*/
         LH    XRWORK,ASCBSWCT          GET AS SHORT WAIT CTR
         LA    XRWORK,ONE(XRWORK)       INCR CTR
         STH   XRWORK,ASCBSWCT          RESET CTR
*/*LONGWAIT: D (NO,WAITEXIT,YES,) LONG WAIT SPECIFIED*/
LONGWAIT TM    WS0(XRSAVE),LSTIND      TEST FOR LONG WAIT IND
         BZ    WAITEXIT                BR IF NOT LONG WAIT
*/* P SET LONG WAIT BIT IN RB*/
         S     XRRB,WPRBPREL           ADDR RB PREFIX
         OI    RBFLAGS1-RBPRFX(XRRB),RBLONGWT  SET LONG WAIT  IND
*/* D (YES,,NO,WAITEXIT) HAS COUNT OF READY TCBS GONE TO ZERO */
         LTR   XRSCRTCH,XRSCRTCH       TEST COUNT              @YM02607
         BNZ   WAITEXIT                BR IF STILL ANY RDY TCBS@YM02607
LONGRBCK DS    0H                      TESTING LABEL
*/* S SYSEVENT: NOTIFY LONGWAIT*/
         LR    XRSCRTCH,XRRETURN       SAVE REG14 ACROSS
         LR    R13,XRSAVE              SET REG 13 SAVE AREA PTR@YM01599
         LR    XRWORK,XRBASE           SAVE BASE REG ACROSS SRM CALL
         LM    R5,R6,WS0(XRSAVE)       SAVE REGS 0 AND 1       @YM01682
         SYSEVENT NIOWAIT,ENTRY=BRANCH
         STM   R5,R6,WS0(XRSAVE)       SET REGS 0&1            @YM01682
         LR    XRBASE,XRWORK           RESTORE BASE REG
         LR    XRRETURN,XRSCRTCH       RESTORE RETURN REG
*/*WAITEXIT: D (BR,%Q1,SVC,) ENTRY TYPE*/
WAITEXIT DS    0H                      COMMON EXIT ROUTINE
         LM    R0,R1,WS0(XRSAVE)       RESTORE REGS 0 AND 1    @YM01682
         LTR   XRRETURN,XRRETURN       TEST BR OR SVC ENTRY
*/* R BPR 14*/
         BPR   XRRETURN                SVC, AND AWAY WE GO
*/*%Q1: P DISABLE CPU USING STNSM*/
         STNSM WOS,DISABLE             DISABLE SYSTEM MASK
*/* S SETFRR: PURGE FRR STACK*/
         SETFRR P,WRKREGS=(XRWORK,XRSCRTCH)  PURGE FRR STACK
*/* S SETLOCK: RELEASE LOCAL LOCK*/
         SETLOCK RELEASE,TYPE=LOCAL,RELATED='INPUT PARAM'
*/* R IEA0DS*/
         L     XRBASE,DISPTCHR         GET DISP ENTRY ADDR
         BR    XRBASE                  GO THERE
*/*CFLAGON: D (MORE,UPDATE,ZERO,) BCT WAITCOUNT*/
CFLAGON  BCT   XRWAITCT,UPDATE         Q.DECREMENT WAIT COUNT NOT 0 BR
*/* D (YES,TISWBR,NO,) BRANCH ENTRY */
         LTR   R14,R14                 TEST HIGH BIT ON FOR BR ENTRY
         BM    TISWBR                  BRANCH IF BRANCH ENTRY
*/* P RESET R14 TO NORMAL EXIT PROLOG ADDR*/
         L     R14,CVTPTR              GET CVT POINTER
         L     R14,CVTEXPRO-CVTMAP(,R14)  ADDR OF EXIT PROLOGUE
*/*TISWBR: D (NO,WAITEXIT,YES,) RB SEARCH BIT IS ON*/
TISWBR   TM    RBSTAB2,RBECBWT         Q.IS RB'S ECB SEARCH FLAG SET
         BZ    WAITEXIT                *NO GO TO EXIT POINT
*/* P RESET RB SEARCH BIT*/
         NI    RBSTAB2,RRBECBWT        RESET RB ECB SEARCH FLAG
         LA    XRWORK,ZERO(,XRECB)     SET LAST ECB ADDR       @YM07244
         L     XRECBPTR,WS1(XRSAVE)    GET ORIG ECBLIST PTR
         LCR   XRECBPTR,XRECBPTR       MAKE POSITIVE
*/* P (,WAITEXIT) RESET WAIT BIT IN EACH ECB IN LIST*/
LOOP1    L     XRECB,ZERO(,XRECBPTR)   OBTAIN ECB ADDRESS
         LA    XRECB,ZERO(,XRECB)      CLEAR                   @YM07244
         CLR   XRECB,XRWORK            TEST FOR LAST TO CLEAR  @YM07244
         BE    WAITEXIT                EXIT IF LAST            @YM07244
         NI    0(XRECB),RECBWTF        RESET ECB'S WAIT FLAG
         LA    XRECBPTR,FOUR(XRECBPTR) UPDATE LIST POINTER
         B     LOOP1                   BRANCH UNCONDITIONALLY
         SPACE
*/*GETOUT: D (YES,WAITEXIT,NO,) BRANCH ENTRY */                @Y30HPVA
GETOUT   SR    XRWAITCT,XRWAITCT       ZERO WAIT COUNT         @Y30HPVA
         NI    RBSTAB2,RRBECBWT        TURN OFF SEARCH FLAG    @Y30HPVA
         LTR   R14,R14                 HI BIT ON FOR BR ENTRY  @Y30HPVA
         BM    WAITEXIT                BRANCH IF BRANCH ENTRY  @Y30HPVA
*/* P (,WAITEXIT) RESET R14 TO NORMAL EXIT PROLOG ADDR*/       @Y30HPVA
         L     R14,CVTPTR              GET CVT POINTER         @Y30HPVA
         L     R14,CVTEXPRO-CVTMAP(,R14)  ADDR OF EXIT PROL    @Y30HPVA
         B     WAITEXIT                                        @Y30HPVA
         EJECT
*/* E ADDROK */
*/*ADDROK: P INITIALIZE FOR CALL TO VALIDITY CHECK*/
ADDROK   DS    0H
         LA    XRSCRTCH,L3(,R1)        LOAD END ADDR OF ECB
         STM   R14,R15,FOUR*R14(XRSAVE) SAVE REGS 14-15
*/* S IEA0VL01: CHECK ADDRESS*/
         L     R15,CHECK               GET VAL CHK RTN ADDR
         BALR  R14,R15                 GO TO VAL CHK RTN
*/* R RETURN WITH CCODE SET*/
         LM    R14,R15,FOUR*R14(XRSAVE) RESTORE REGS 14 -15
         BR    XRLINKR                 RETURN
*/* E CHKCOMTS */
*/*CHKCOMTS: P GET CSCB ADDR VIA JSCB*/
CHKCOMTS DS    0H
         L     XRSCRTCH,TCBJSCB        GET JSCB ADDRESS
         USING IEZJSCB,XRSCRTCH
         L     XRSCRTCH,JSCBCSCB       GET CSCB ADDRESS
         USING CSCB,XRSCRTCH
         LA    XRECB,0(XRECB)          CLEAR HI ORDER BYTE/USE SCR REG
*/* D (NO,ERROR201,YES,) INVALID ECB OWNED BY COMM TASK*/
         C     XRECB,CHECBP            Q. IS ECB EQUAL TO ECB OF COM
         BNE   ERROR201                NO - THAT IS BAD GO TO ERROR RTN
*/* R RETURN*/
         B     FOUR(XRLINKR)           ADDR THOUGH INVALID - IS OK
         EJECT
*   ERROR EXITS FROM WAIT
**********************************************************************
*/*ERROR101: P (,ERRORALL) SET ABEND CODE 101*/
ERROR101 DS    0H                      *
         LA    R1,ERRWAIT1             NO TO WAIT ON GRT THAN NO GIVEN
         B     ERRORALL                GO TO COMMON ABEND CODE
*/*ERROR201: P (,ERRORALL) SET ABEND CODE 201*/
ERROR201 DS    0H                      *
         LA    R1,ERRWAIT2             INVALID ECB ADDRESS CODE
         B     ERRORALL                GO TO COMMON ABEND CODE
*/*ERROR301: P SET ABEND CODE 301*/
ERROR301 DS    0H                      *
         LA    R1,ERRWAIT3             WAIT FLAG ALREADY SET
         B     ERRORALL                GO TO COMMON ABEND CODE
*
*/*ERRORALL: R ABEND*/
ERRORALL SLL   R1,ABNDALGN             MOVE COMP CODE LEFT/ SHOW SYSTEM
         ICM   R1,L8,ERRORFLG          TAKE DUMP
         SVC   ABENINST                ISSUE SVC 13
*
**********************************************************************
         EJECT
*
*        BRANCH ENTRY TO WAIT
*
*        THE CALLER HAS ESTABLISHED HIS RESUME ENVIRONMENT (REGS/PSW)
*        IN HIS TCB/PSW. REGS 0,1 ARE THE SAME AT ENTRY AS FOR THS SVC
*        WITH THE POSSIBILITY THAT THE USER MAY SPECIFY NO ECB (REG1
*        IS ZERO).
*
*/* E IEAVWAIT*/
IEAVWAIT DS    0H
         USING *,XRBASE                BR ENTRY BASE REG
*/* P INITIALIZE ENVIRONMENTAL REGS*/
         L     XRASCB,PSAAOLD          CURRENT ASCB ADDR
         L     XRTCB,PSATOLD           CURRENT TCB ADDR
         ST    R1,TCBGRS1              SAVE ECBLIST ADDR FOR POST
         L     XRRB,TCBRBP             CURRENT RB ADDR
         L     XRBASE,BASEWT           COMMON WAIT BASE VALUE
         USING WAITBAS,XRBASE          COMMON WAIT BASE ADDR
*/* P (,BRENTRY) SET BR ENTRY SW- REG 14 NEGATIVE*/
         O     XRRETURN,TIDBIT         SET SIGN BIT AS BR ENTRY SW
         B     BRENTRY                 GO TO MAINLINE
*/*WAIT: END*/
         EJECT
***********************************************************************
*
*ROUTINE NAME-           IGC002,POST SVC SERVICE ROUTINE
*
*FUNCTIONS-            1.POST WILL SIGNAL THE COMPLETION OF AN EVENT
*                          SPECIFIED BY AN EVENT CONTROL BLOCK(ECB)
*                          BY SETTING IT APPROPRIATELY.
*
*                      2.POST WILL SIGNAL THE COMPLETION OF AN EVENT
*                          TYPE ECB BY STORING ITS ADDRESS IN THE
*                          ADDRESS IN THE APPROPIATE EVENT TABLE
*                          AND SETTING THE COMPLETE BIT AND COMPLETION
*                          CODE IN THE ECB.
*
*                      3.POST WILL DETERMINE IF THE TASK IN A WAIT
*                          STATE HAS BEEN MADE READY.
*
*                      4.GIVE AN AUTHORIZED USER EXIT ROUTINE
*                          CONTROL WHEN AN EXTENDED ECB IS
*                          POSTED.
*
*                      5.POST EXIT INTERFACE SERVICE
*                          A. IDENTIFY POST EXIT ROUTINES TO POST
*                             MAINLINE BY QUEUEING A BLOCK NO THE
*                             POST EXIT QUEUE, HEADED BY ASXBPT0E.
*                          B. DELETE POST EXITS BY DEQUEING THE
*                             BLOCK IDENTIFIED WITH THE EXIT
*                             FROM THE POST EXIT QUEUE.
*
*ENTRY POINT NAMES-    1.IGC002,ENTRY POINT VIA SVC 02
*
*                      2. IEA0PT01,  BRANCH ENTRY
*
*                      3. IEA0PT02, BRANCH ENTRY
*
*                      4. IEA0PT03, BRANCH ENTRY - USED FOR
*                           REINVOCATION OF POST FROM A POST
*                           EXIT ROUTINE
*
*                      5. IEA0PT0E, BRANCH ENTRY TO
*                           IDENTIFY/DELETE POST EXITS
*
*CONTAINED IN MODULE-    IEAVSY50- WAIT/POST SYNCHRONIZATION MODULE
*
*ATTRIBUTES-            LOCAL LOCK, ENABLED, KEY0, SUPERVISOR STATE
*
*EXTERNAL REFERENCES-
*                         IEA0VL01--VALIDITY CHECK ROUTINE
*
*                         POST EXIT ROUTINES - INTERFACE AS FOLLOWS:
*                           ENTRY TO EXIT - KEY 0,SUP STATE,LOCAL LOC
*                             R0 POSTED ECB ADDR
*                             R1 ECBREXTENSION ADDR
*                             R14 RETURN ADDR
*                             R15 ENTRY POINT ADDR
*                             REMAINING REGS IRRELEVANT
*                           RETURN - KEY 0,SUP STATE,LOCAL LOCK
*                             R11 UNCHANGED
*                             R14 UNCHANGED
*                             REMAINING REGS IRRELEVANT
*INPUT-                  SVC ENTRY
*                        R0 CONTAINS THE POST CODE.
*
*                        R1 CONTAINS THE ADDRESS OF THE ECB TO BE
*                        POSTED.
*
*                        IF HI ORDER BIT OF REG 1 IS ON, THEN
*                        REGISTER ONE POINTS TO A PARAMETER LIST.
*                        THE PARAMETER LIST IS THREE FULLWORDS
*                        AS FOLLOWS:
*                          WORD ONE---ADDRESS OF ECB
*                          WORD TWO---ADDRESS OF ASCB
*                          WORD THREE---ADDRESS OF ERRET
*
*                        IF HIGH ORDER BIT OF REG 0 IS ON, THE
*                        PARAMETER LIST CONTAINS A FOURTH WORD:
*                          WORD FOUR--BYTE 0 - ECBKEY IN FORMAT X'K0'
*                                     BYTES 1-3 - RESERVED
*                        (REG 0 CONTAINS THE POST CODE)
*                        THIS PARAMETER LIST IS USED FOR
*                        CROSS-MEMORY POST
*
*                        IEA0PT0E -BRANCH ONLY,SVC NOT AVAILABLE
*                          R0 FUNCTION CODE
*                             4 - EXIT CREATION REQUEST
*                             8 - EXIT DELETION REQUEST
*                          R1 EXIT ROUTINE ADDR TO BE CREATED OR
*                            DELETED
*                          R14 RETURN ADDR
*                          R15 ENTRY POINT ADDR (IEA0PT0E)
*
*OUTPUT-                 NONE
*
*ENTRY POINTS-        1A.IGC002,POST SVC ROUTINE ENTRY POINT
*
*                        2. (IEA0PT01) BRANCH ENTRY
*                       THE USER MUST PROVIDE THE FOLLOWING.
*                        1. ADDRESS OF IEA0PT01 IN REGISTER 15.
*                        2. RETURN ADDRESS IN REGISTER 14.
*                        3. THE COMPLETION CODE IN REGISTER 10.
*                           IF POST WITHOUT ECB,
*                           THEN R10 CONTAINS THE RB ADDRESS.
*                           THE HIGH ORDER BIT ON IN R10 FOR CROSS
*                           MEMORY POSTS INDICATES ECBKEY OPTION
*                           HAS BEEN REQUESTED.
*                        4. THE ECB ADDRESS IN REGISTER 11,
*                           WITH X'00' IN HI ORDER BYTE IF NORMAL POST,
*                           AND X'80' IF CROSS-MEMORY POST.
*                           IF REG 11 IS ALL ZERO, THEN POST
*                           WITHOUT ECB (SEE REG 10).
*                        5. IF XMPOST, REG 12 HAS ERRET ADDR
*                        6.  REG 13 HAS ASCB ADDR IF XMPOST
*                        7. IF ECBKEY OPTION HAS BEEN REQUESTED THEN
*                           BYTE 3 OF REG 0 CONTAINS THE KEY IN
*                           FORMAT X'K0'.
*
*
*                     B. (IEA0PT02) BRANCH ENTRY
*                        PERFORMS THE SAME
*                        FUNCTION AS IEA0PT01 WITH NO XMPOST
*                        AND NO POST WITHOUT ECB.
*
*                     C. (IEA0PT03) BRANCH ENTRY
*                        PERFORMS SAME FUNCTION AS IEA0PT01
*                        AND HAS SAME INPUT REQUIREMENTS.
*                        THIS ENTRY POINT USES THE LOCAL
*                        SAVE AREA EXTENSION.
*                     D. (IEA0PT0E) BRANCH ENTRY - CVT0PT0E
*                        CALLER MUST HAVE LOCAL LOCK, KEY 0,
*                        SUPERVISOR STATE
*                        THIS ENTRY USES MAIN SAVE AREA
*
*EXIT POINT-           1.TO TYPE I EXIT PROLOGUE FORCE DISPATCHER
*                        ENTRY IF SVC CALLER
*
*                      2.TO REG 14 IF BRANCH ENTRY
*
*                        IEA0PT01 BRANCH ENTRY FOR NORMAL POST
*                        LOCAL LOCK HELD
*                        REGISTERS 0-9 AND 12-14 ARE TRANSPARENT
*                        REGISTERS 10-11 AND 15 ARE VOLATILE
*
*                        IEA0PT01 BRANCH ENTRY FOR XMPOST
*                        NO LOCK REQUIRED
*                        REGS 9,14 ARE SAVED OTHERS ARE LOST
*                        IF LOCAL LOCK IS NOT HELD
*
*                        REGS 0-9 AND 14 ARE SAVED IF
*                        LOCAL LOCK IS HELD & MEM RELETED AT BR ENTRY
*
*                        (IEA0PT02) BRANCH ENTRY
*                        LOCAL LOCK HELD
*                        REGISTERS 0-9 AND 12-14 ARE TRANSPARENT
*                        REGISTERS 10-11 AND 15 ARE VOLATILE
*
*
*                        IEA0PT03 BRANCH ENTRY FOR POST
*                        REINVOCATION, LOCAL LOCK HELD.
*                        REGISTERS 1-14 ARE TRANSPARENT
*                        REGISTER 15 IS UNPREDICTABLE
*
*                      3.IEAV0PT0E, RETURN VIA CALLERS REG14,
*                        LOCAL LOCK HELD,KEY 0,SUPR STATE
*
*ERROR EXIT POINTS-    1. TO ABEND
*
*                       THE ERROR CODES ARE.
*                        X'0102' ERROR CODE #1 POST ECB ADDRESS
*                                              INVALID.
*                        X'0202' ERROR CODE #2 POST ECB'S RB
*                                              ADDRESS INVALID.
*                        X'0402' ERROR CODE #4 EVENTS ECB EVENTS
*                                              TABLE ADDRESS INVALID
*                        X'0502' ERROR CODE #5 POST TO FULL
*                                              EVENTS TABLE
*
*                        X'702' ERROR CODE #7 INVALID ECB
*                                             EXTENSION
*                                             RELATED DATA
*                               REASON CODE
*                                  0 - INVALID FUNCTION CODE FOR
*                                      ENTRY TO IEA0PT0E
*                                  4 - INVALID EXIT ROUTINE ADDR
*                                      FOR DELETE REQUEST AT
*                                      ENTRY TO IEA0PT0E
*                                  8 - INVALID VALUE OR
*                                      RESERVED FIELDS USED
*                                      IN ECB EXTENSION
*                                  C - INVALID EXIT ROUTINE
*                                      ADDRESS IN ECB EXTENSION
*                                 10 - ATTEMPT TO POST
*                                      EXTENDED ECB FROM
*                                      POST EXIT ROUTINE
*                                 14 - INVALID ECB EXTENSION
*                                      ADDRESS IN ECB
*
*CHANGE ACTIVITY-                                              @ZA30491
*  OZ11895--CHANGE TO MARK THE ECB POSTED BEFORE UPDATING THE  @ZA30491
*           EVENTS TABLE.                                      @ZA30491
*  OZ15375--PROVIDE NEW OPTION ECBKEY FOR XMPOST.              @ZA30491
*  OZ20188--CHANGE TO MAKE EVNTFRR (EVENTS FRR) SAVE REG 14    @ZA30491
*           ACROSS SETRP.                                      @ZA30491
*  OZ30491--REGISTERS 12 AND 13 WEREN'T SAVED WHEN A POST EXIT @ZA30491
*           ROUTINE WAS INVOKED. IF THEY ARE UPDATED BY THE    @ZA30491
*           EXIT, THE ORIGINAL VALUES OF REGS 12 AND 13 WILL   @ZA30491
*           NOT BE RETURNED TO A BRANCH ENTRY CALLER OF POST.  @ZA30491
*  OZ33186--FOR POST, IEAVSY50 CURRENTLY ASSUMES AS ECB WITH   @ZA33186
*           THE 2 LOW ORDER BITS OFF WILL BE UPDATED USING THE @ZA33186
*           LOCAL LOCK FOR SERIALIZATION. HOWEVER, CS SHOULD   @ZA33186
*           BE SUFFICIENT SERIALIZATION TO POINT TO AN         @ZA33186
*           EXTENDED ECB. THIS MAY RESULT IN A LOST POST.      @ZA33186
*
***********************************************************************
         EJECT
* SVC POST (SVC 2)
*  ENTER WITH ECB ADDRESS IN REGISTER 1.
*  ENTER WITH POST CODE IN REGISTER 0.
* FUNCTION.
*  POST WILL SET COMPLETION FLAG AND CODE IN ECB. IF POST TRIES TO POST
*  A POSTED TCB, IT IGNORES POSTING AND EXITS.
*  INPUT ECB'S PROTECT KEY IS TESTED IF EQUAL TO WAITING TCB, IF ENTRY
*  BY NON SUPERVISER. IF ECB'S PROTECT KEY IS NOT CORRECT GO TO ABEND.
*  STORE POST CODE AND POST FLAG IS ECB. THEN DECREMENT WAITING RB'S
*  WAIT COUNT. IF DECREMENTED WAIT COUNT IS ZERO, CHECK THE SEARCH ECB
*  FLAG IN THE RB. IF THE FLAG IS ON, FIND OUT THE POSITION OF THE RB
*  IN ITS QUEUE. IF RB IS THE TOP RB, GET ECB LIST ADDRESS FROM TCB
*  SAVE REGISTER 1. IF RB IS NOT TOP OF IT'S QUEUE, GET THE RB JUST
*  ABOVE THE REQUESTING RB. FIND OUT THE TYPE OF RB IT IS, AND GET THE
*  ECB LIST ADDRESS FROM REGISTER 1 SAVE AREA ACCORDANTLY. AFTER LIST
*  ADDRESS HAS BEEN FOUND, RESET ALL ECB WAIT FLAG.
         SPACE 2
*/*POST: CHART*/
IGC001   CSECT
         SPACE 2
         CNOP  0,8
*        SET UP BASE REGISTERS FOR DSECTS
         USING RBSECT,XRRB             RB
         USING TCB,XRTCB               TCB
*/* E IGC002*/
IGC002   BALR  XRBASE,ZERO             SET UP ADDRESSABILITY
*/* P INITIALIZE REGISTERS*/
         USING *,XRBASE                INCLUDING THE BASE REG
         L     XRRETURN,CVTEXP1-CVTMAP(,R3)  GET EXIT PROL FORCE ENTRY
         USING ASCB,XRASCB             ASCB BASE REG
         L     XRSAVE,ASCBASXB         GET ASXB ADDR
         USING ASXB,XRSAVE             ASXB BASE
         L     XRSAVE,ASXBSPSA         ADDR OF SAVT
         USING WSAL,XRSAVE
         L     XRSAVE,WSALPOST         POST WSA
         DROP  XRSAVE
         LR    XRECB,R1
         LR    XRPTCODE,R0             SAVE INPUT REGS
*/* D (NO,AUTHXMP,YES,) SUPVR KEY CALLER*/
         TM    RBOPSW+ONE-RBSECT(XRRB),SUPTST  SUPERVISOR KEY CALLER
         BC    ONE,AUTHXMP          NO,BRANCH
*/* D (YES,XMPROC,NO,RBCHECK) XMPOST REQUEST*/
         LTR   XRECB,XRECB              IS THIS AN XMP REQUEST?
         BM    XMPROC                   YES, GO TO PROCESS IT
         B     RBCHECK                  NO, GO TO MAINLINE CODE
*/*TESTADOM: D (YES,XMPROC,NO,ECBVALID) XMPOST REQUEST*/
TESTADOM LTR   XRECB,XRECB              IS THIS AN XMP REQUEST?  SRB467
         BM    XMPROC                   YES, GO TO PROCESS IT  @YM02645
         B     ECBVALID                 ELSE, PROCESS NORMALLY   SRB467
*/*AUTHXMP: S TESTAUTH: PP CALLER*/
AUTHXMP  DS    0H
* GO TO TEST HIS AUTHORITY TO SEE IF HE CAN ISSUE A CROSS MEMORY POST
         STM   XRRETURN,XRBASE,FOUR*XRRETURN(XRSAVE) SAVE RET AND BASE
*/* D (AUTH,TESTADOM,FAIL,) RESULTS OF TESTAUTH*/
         TESTAUTH RBLEVEL=1,FCTN=1,STATE=YES,BRANCH=YES
* RETURN CODE OF 0 OR 4 IN REG 15 TELLS THE STORY                SRB467
         LR    XRWORK,XRBASE           GET RETURN CODE
         LM    XRRETURN,XRBASE,FOUR*XRRETURN(XRSAVE)
*  THE FOLLOWING BRANCH TABLE WILL HANDLE THE RETURN CODE FROM TESTAUTH
TESTAUBR B     TESTAUBR+FOUR(XRWORK)   CHECK THE RETURN CODE     SRB467
         B     TESTADOM                IF ZERO, HE IS AUTHORIZED SRB467
*                                      IF NOT-IGNORE THE XMP REQ SRB467
*                                      AND FALL THROUGH          SRB467
*/*ECBVALID: S IEA0VL01: VALIDITY CHECK ADDRESS*/
ECBVALID DS    0H
         LR    R1,XRECB                SET UP REGISTER 1
         LA    XRSCRTCH,L3(,R1)        GET WORD END ADDR
         STM   R14,R15,FOUR*R14(XRSAVE) SAVE REGS 14-15
         L     R15,CHECK               GET VAL CHK ADR
         BALR  R14,R15                 BR TO VAL CHK RTN
         LM    R14,R15,FOUR*R14(XRSAVE) RESTORE REGS
*/* D (OK,RBCHECK,FAIL,ERROR1) RESULTS OF VALIDITY CHECK*/
         BNE   ERROR1                  BRANCH TO ABTERM
         B     RBCHECK                 UNCONDITIONALLY BRANCH
         EJECT
*  ENTRY POINT IEA0PT01
         SPACE 1
         USING *,XRBASE
*/* E IEA0PT01*/
*
*              FOR LOCAL POST, THE CODE IS SUCH THAT REGS 12-13
*              ARE IMPLICITLY SAVED. SEE COMMENT ON IEA0PT02
*              ENTRY.
*              NOTE THAT ONLY REGS 0-9 ARE SAVED ON A XMPOST
*              BRANCH ENTRY (WITH THE LOCAL LOCK AND MEMORY RELATED).
*
*/*IEA0PT01: P SET BRANCH ENTRY SWITCH- REG 14 NEG*/
IEA0PT01 O     XRRETURN,TIDBIT         SET BR ENTRY SW
*/* D (YES,XMPOST,NO,) XMPOST REQUEST*/
         LTR   R11,R11                 TEST FOR XMPOST REQ
         BM    XMPOST                  BR IF SO
*/* P GET ADDR OF LOCAL SAVE AREA- SAVE REGS*/
         L     XRBASE,PSAAOLD          GET CURRENT ASCB ADDR
         L     XRBASE,ASCBASXB-ASCB(,XRBASE)  GET ADDR OF ASXB
         L     XRBASE,ASXBSPSA-ASXB(,XRBASE)  GET ADDR OF LCL WSAVT
         L     XRBASE,WSALPOST-WSAL(,XRBASE)  GET ADDR OF POST WSA
         STM   R0,R9,0(XRBASE)         SAVE REGS 0-9
         LR    XRECB,R11               ECB ADDR
         LR    XRSAVE,XRBASE           SAVE AREA BASE REG
         BALR  XRBASE,R0               ESTABLISH BASE REG
         USING *,XRBASE                ADDRESSABILITY
         L     XRBASE,BASE             GET COMMON BASE ADDR
         USING IGC002+2,XRBASE         COMMON BASE
*/*SETMREGS: P INITIALIZE MAINLINE REGS*/
SETMREGS EQU   *                       SET MAINLINE REGS       @Z40EPVD
         LR    XRPTCODE,R10            POST CODE               @Z40EPVD
         L     XRASCB,PSAAOLD          ADDR OF CURR ASCB
*/*ECBCHECK: D (NO,RBCHECK,YES,) POST WITHOUT ECB*/
ECBCHECK LTR   XRECB,XRECB             TEST FOR POST W/O ECB
         BNZ   RBCHECK                 NO, GO TO MAINLINE
*/* P GET WAITING RB ADDR*/
         LR    XRRB,XRPTCODE           INSTEAD OF POST CODE, RB ADDR
         LR    XRTCB,XRRB              DUPLICATE
*/*TCBLOOP: P FIND TCB ADDR FROM RBCHAIN*/
TCBLOOP  TM    RBSTAB2-RBSECT(XRTCB),TCBIND  NEXT RB OR TCB
         L     XRTCB,RBLINK-RBSECT(XRTCB)    GET CHAIN PTR FROM RB
         BZ    TCBLOOP                 BR IF RB LINK
*/* EVSWCF: D (YES,EXIT,NO,) WAIT COUNT ALREADY ZERO */
EVSWCF   SR    XRWAITCT,XRWAITCT       CLEAR REG               @Y30HPVA
         CLI   RBWCF,ONE               WAIT COUNT IS ALREADY ZERO
         BL    EXIT                    YES, BR
*/* EVNTLP1: D (YES,,NO,EVNTCK1) ARE THERE ANY MORE EVENT TABLES */
         LA    XRRB,0(,XRRB)           CLEAR HIGH BYTE         @Y30HPVA
         L     XRWORK,TCBEXT2-TCB(,XRTCB) GET PTR TO EXTENSION @Y30HPVA
         L     XRWORK,TCBEVENT-TCBXTNT2(,XRWORK) GET POINTER   @Y30HPVA
*                                      TO FIRST EVENT TABLE    @Y30HPVA
EVNTLP1  LTR   XRWORK,XRWORK          ARE THERE ANY MORE TABLES@Y30HPVA
         BZ    EVNTCK1                 NO, BRANCH              @Y30HPVA
*/* EVN1:   D (YES,,NO,EVNTCT1) IS TABLE WAITING ON POSTED RB*/
         CL    XRRB,EVNTRBP-EVNT(,XRWORK) IS TABLE WAITING ON  @Y30HPVA
*                                      POSTED RB               @Y30HPVA
         BNE   EVNTCT1                 NO, BRANCH              @Y30HPVA
*/* EVN2: P ZERO TABLE WAITING RB POINTER */
         ST    XRWAITCT,EVNTRBP-EVNT(,XRWORK)  ZERO RB POINTER @Y30HPVA
*/* EVNTCT1: P (,EVNTLP1) POINT TO NEXT EVENT TABLE */
EVNTCT1  L     XRWORK,EVNTLNK-EVNT(,XRWORK) POINT TO NEXT TABLE@Y30HPVA
         B     EVNTLP1                 LOOP TILL NO            @Y30HPVA
*                                      MORE TABLES             @Y30HPVA
*/*EVNTCK1: P DECREMENT WAIT COUNT IN RB*/
EVNTCK1  IC    XRWAITCT,RBWCF          GET RB WAIT COUNT
         BCTR  XRWAITCT,R0             DECREMENT IT
         STC   XRWAITCT,RBWCF          RESET IT IN RB
*/*  D (YES,SETRBPFX,NO,EXIT)WAIT COUNT IS NOW ZERO */
         LTR   XRWAITCT,XRWAITCT       IS WAIT COUNT ZERO      @Y30HPVA
         BNZ   EXIT                    BR IF COUNT STILL NOT ZERO
         B     SETRBPFX                COUNT ZERO, CLEAN UP
         SPACE 2
         USING IEA0PT01,XRBASE
*/*XMPOST: D (YES,,NO,XMPOSTNL) LOCAL LOCK HELD AT ENTRY */
XMPOST   SETLOCK TEST,TYPE=LOCAL,BRANCH=(NOTHELD,XMPOSTNL)     @Y02752
*/* D (YES,,NO,XMPOSTNL) IS XMPOST REQ MEMORY RELATED */
         LTR    R12,R12                TEST ERRET ADDRESS HI BIT@Y02752
         BM     XMPOSTNL               BR IF NOT MEMORY RELATED @Y02752
*/* P SET BR ENTRY FLAG TO ZERO FOR LATER FLIP*/
         LA     XRRETURN,0(,XRRETURN)  RESET HI BIT FOR XOR
*/* P SAVE REGS 0-9 */
QJ10     L     XRBASE,PSAAOLD          GET SAVE AREA ADDRESS
         L     XRBASE,ASCBASXB-ASCB(,XRBASE)  GET ADDR OF ASXB
         L     XRBASE,ASXBSPSA-ASXB(,XRBASE)  GET ADDR OF SPSA
         L     XRBASE,WSALPOST-WSAL(,XRBASE)  GET ADDR OF SAVE AREA
         STM   R0,R9,0(XRBASE)         SAVE REGS 0-9
         LR    R9,XRBASE               SAVE ADDR OF SAVE AREA
*/*XMPOSTNL: P FLIP BRANCH ENTRY FLAG*/
XMPOSTNL DS    0H                      INITIALIZE BASE REG
         BALR  XRBASE,R0               ESTAB ADDRESSABILITY
         USING *,XRBASE
         L     XRBASE,BASE             GET MODULE BASE
         USING IGC002+2,XRBASE
         X     XRRETURN,TIDBIT         FLIP BR ENTRY FLAG       @Y02752
*/*XMPOST1: P (,XMPPROC) INITIALIZE MAINLINE REGS*/
XMPOST1  L     XRASCB,PSAAOLD          CURRENT ASCB ADDR       @Z40EPVD
         LR    R5,R11                  SAVE ECB ADDR
         LR    R6,R12                  SAVE ERRET ADDR
         LR    R8,R13                  SAVE TARGET ASCB ADDR
         B     XMPPROC                 TO MAINLINE XMPOST
         SPACE 2
*/* E IEA0PT02 */
*   ENTRY POINT IEA0PT02
         SPACE 1
         USING *,XRBASE                SET TEMP BASE
*/*IEA0PT02: P FIND LOCAL SAVE AREA AND SAVE REGS*/
*              ACROSS THIS INTERFACE REGISTERS 0-9 ARE
*              SAVED, BUT THE NON-USE OF REGS 12-13 IS SUFFICIENT
*              TO ALLOW THAT THEY ARE SAVED...IF THE REGISTER USAGE
*              IS CHANGED, THE POST LOCAL SAVE AREA MUST BE
*              UTILIZED TO SAVE REGS 12-13.
*
IEA0PT02 L     XRBASE,PSAAOLD          GET CURRENT ASCB
         L     XRBASE,ASCBASXB-ASCB(,XRBASE)  ASXB ADDR
         L     XRBASE,ASXBSPSA-ASXB(,XRBASE)  LCL WSAVT
         L     XRBASE,WSALPOST-WSAL(,XRBASE)  POST WSA
         STM   R0,R9,0(XRBASE)         SAVE REGS
*/* P SET UP MAINLINE REGS*/
         LR    XRECB,R11               ECB ADDR
         LR    XRPTCODE,R10            POST CODE
         LR    XRSAVE,XRBASE           WSA BASE REG
         BALR  XRBASE,R0               EST ADDR
         USING *,XRBASE                EST BASE REG
         L     XRBASE,BASE             COMMON BASE ADDR
         USING IGC002+2,XRBASE         COMMON BASE ADDR
Q72Z     L     XRASCB,PSAAOLD          ADDR OF CURR ASCB
*/* P SET BR ENTRY SW- REG 14 NEG*/
         O     XRRETURN,TIDBIT         SET BR ENTRY SW
         EJECT
*/*RBCHECK: P LOAD ECB BEFORE IT IS CHECKED*/                  @ZA33186
RBCHECK  EQU   *                                               @ZA33186
*        LOAD ECB BEFORE IT IS CHECKED, IN CASE IT IS          @ZA33186
*        INITIALLY NEITHER WAITING OR POSTED BUT IT            @ZA33186
*        IS INITIALIZED TO POINT TO AN ECB EXTENSION BEFORE IT @ZA33186
*        IS POSTED.                                            @ZA33186
         L     R1,ZERO(,XRECB)         GET ECB                 @ZA33186
*/*RBCHECK2: D (YES,EVN3,NO,) IS ECB ALREADY WAITED UPON*/     @ZA33186
RBCHECK2 TM    ECBCC-ECB(XRECB),ECBWAIT  Q.IS ECB WAITING      @ZA33186
         BO    EVN3                    YES, GO PROCESS         @ZA33186
*/* D (YES,EXIT,NO,) IS ECB ALREADY POSTED*/                   @ZA33186
         TM    ECBCC-ECB(XRECB),ECBPOST  Q. IS ECB POSTED      @ZA33186
         BO    EXIT                    YES, EXIT               @ZA33186
*/* P MARK ECB POSTED USING CS*/                               @ZA33186
*        THE ECB IS NOT WAITING OR POSTED                      @ZA33186
         N     XRPTCODE,OFFWAIT        RESET WAIT BIT          @ZA33186
         O     XRPTCODE,ONCOMPL        SET POST BIT            @ZA33186
         CS    R1,XRPTCODE,ZERO(XRECB) POST IT                 @ZA33186
*/* D (YES,EXIT,NO,RBCHECK2) WAS CS SUCCESSFUL*/               @ZA33186
         BZ    EXIT                    EXIT IF SUCCESSFUL      @ZA33186
         B     RBCHECK2                ECB WAS MODIFIED, TRY   @ZA33186
*                                      AGAIN                   @ZA33186
*/*  EVN3: D (YES,,NO,TCBRBCHN) IS ECB EVENTS ECB*/
EVN3     TM    ECBBYTE3-ECB(XRECB),ECBEVNT ECB EVENTS ECB?     @ZA15373
         BZ    NOEVENTS                NO, BRANCH              @Y30HPVA
*/* D (YES,EXTECB,NO,) DOES ECB EXTENSION EXIST*/
         TM    ECBBYTE3-ECB(XRECB),ECBEXTND EXTENSION EXIST?   @Z40EPVD
         BO    EXTECB                  YES, EXT EXISTS         @Z40EPVD
***********************************************************************
*                                                                     *
*        THE FOLLOWING CODE PROCESSES THE EVENT TYPE ECB              *
*                                                                     *
***********************************************************************
*/* EVN4: S SETFRR: SET FRR FOR EVENTS PROCESSING */
         LA    R1,EVNTFRR              LOAD FRR ADDRESS        @Y30HPVA
         SETFRR A,FRRAD=(1),WRKREGS=(XRWORK,XRSCRTCH)          @Y30HPVA
*
*        DETERMINE IF TABLE POINTER IN ECB IS VALID
*        ENTRY TO FRR WILL CAUSE A 402 ABEND CODE
*
*/* EVN5: N CHECK IF TCB ADDR IN TABLE POINTED TO BY ECB IS VALID TCB*/
*/* EVN6: D (YES,,NO,ABEND402) TCB ADDR VALID*/
         L     XRSCRTCH,ZERO(,XRECB)   GET TABLE POINTER       @Y30HPVA
         BCTR  XRSCRTCH,ZERO           CLEAR LOW BIT           @Y30HPVA
         L     XRTCB,ASCBASXB          GET ASXB ADDR           @Y30HPVA
         L     XRTCB,ASXBLTCB-ASXB(,XRTCB)  GET LAST TCB ADDR  @Y30HPVA
         L     XRWORK,EVNTTCBP-EVNT(,XRSCRTCH) GET TCB ADDR    @Y30HPVA
*                                 FROM TABLE                   @Y30HPVA
EVNTTCBL CLR   XRWORK,XRTCB       TABLE TCB POINTER ON READY   @Y30HPVA
*                                 QUEUE                        @Y30HPVA
         BE    TCBOK              YES, BR FOR GOOD TCB         @Y30HPVA
         L     XRTCB,TCBBACK-TCB(,XRTCB)    BACK ONE TCB       @Y30HPVA
         LTR   XRTCB,XRTCB        END OF READY QUEUE           @Y30HPVA
         BNZ   EVNTTCBL           NO, CONTINUE LOOKING         @Y30HPVA
         B     ABEND402           YES, BAD TABLE ABEND         @Y30HPVA
*/* EVN7: N CHECK VALID TCB FOR VALID TABLE OFF THAT TCB */
*/*  TCBOK: D (YES,,NO,ABEND402) IS TABLE VALID FOR TCB */
TCBOK    LA    XRSCRTCH,ZERO(,XRSCRTCH)     CLEAR HIGH BYTE    @Y30HPVA
         L     XRWORK,TCBEXT2-TCB(,XRTCB) GET PTR TO EXTENSION @Y30HPVA
         L     XRWORK,TCBEVENT-TCBXTNT2(,XRWORK) GET FIRST     @Y30HPVA
*                                 TABLE ADDRESS                @Y30HPVA
EVNTTLP1 CLR   XRWORK,XRSCRTCH    TABLE ADDR MATCH             @Y30HPVA
         BE    TABLEOK            YES, TABLE IS GOOD           @Y30HPVA
         LTR   XRWORK,XRWORK      END OF TABLE QUEUE FOR TCB   @Y30HPVA
         BZ    ABEND402           YES, ABEND 402               @Y30HPVA
         L     XRWORK,EVNTLNK-EVNT(,XRWORK) NO, GET NEXT TABLE @Y30HPVA
*                                 IN QUEUE                     @Y30HPVA
         B     EVNTTLP1           CHECK FOR END                @Y30HPVA
*
*        TABLE AND TCB POINTER ARE VALID
*        NEXT CHECK FOR WAITING RB ON TABLE - IF NOT WAITING
*        UPDATE TABLE AND ECB THEN EXIT
*        IF WAITING AND VALID RB UPDATE TABLE AND ECB AND USE
*        POST W/O ECB TO UPDATE THE RB AND ASCB
*
*/* TABLEOK: D (YES,,NO,EVCKSP) DOES TABLE HAVE RB POINTER */
TABLEOK  L     XRRB,EVNTRBP-EVNT(,XRSCRTCH) RB POINTER FROM    @Y30HPVA
*                                 TABLE                        @Y30HPVA
         L     XRWORK,TCBRBP-TCB(,XRTCB) RB POINTER FORM TCB   @Y30HPVA
         LTR   XRRB,XRRB          IS RB IN TABLE               @Y30HPVA
         BZ    UPDEVT             NO, NOT WAITING              @Y30HPVA
EVRBCHK  LA    XRWORK,ZERO(,XRWORK)    CLEAR HIGH              @Y30HPVA
         CLR   XRWORK,XRRB        TEST FOR GOOD RB             @Y30HPVA
         BE    EVRBOK             BR IF RB OK                  @Y30HPVA
         TM    RBSTAB2-RBSECT(XRWORK),TCBIND TEST FOR LAST RB  @Y30HPVA
         L     XRWORK,RBLINK-RBSECT(,XRWORK) GET NEXT RB       @Y30HPVA
         BZ    EVRBCHK            CONTINUE CHECKING RB'S       @Y30HPVA
         B     ABEND402           ABEND FOR BAD RB PTR         @Y30HPVA
*
*        NOW HAVE GOOD RB. NEED TO CHECK FOR P.P. POSTEE
*        IF P.P. POSTEE, CHECK FOR SAME KEY ETC.
*
*/* EVRBOK: D (YES,,NO,ABEND402) RB ENABLED */
EVRBOK   TM    RBOPSW,ENABON      TEST FOR ENABLED             @Y30HPVA
         BNO   ABEND402           BR TO ABEND                  @Y30HPVA
*
*/* EVN8: D (YES,,NO,EVALCK) IS POSTEE SUPERVISOR KEY */
         TM    RBOPSW+ONE,SUPTST  CHECK FOR SUPV WAITER        @Y30HPVA
         BO    EVALCK             BR IF PROB PROG              @Y30HPVA
*/* EVCKSP: D (YES,UPDEVT,NO,EVALCK) IS POSTER SUPERVISOR */
EVCKSP   LTR   XRRETURN,XRRETURN  TEST FOR BRANCH ENTRY        @Y30HPVA
         BM    UPDEVT             BR IF BR                     @Y30HPVA
         L     XRWORK,PSATOLD     TEST FOR SRB                 @Y30HPVA
         LTR   XRWORK,XRWORK      CALLER                       @Y30HPVA
         BZ    UPDEVT             BR IF SRB CALLER             @Y30HPVA
         L     XRWORK,TCBRBP-TCB(,XRWORK) TEST IF SUPVR SVC    @Y30HPVA
         TM    RBOPSW+ONE-RBSECT(XRWORK),SUPTST  WAITER        @Y30HPVA
         BZ    UPDEVT             BR IF SUPVR WAITER           @Y30HPVA
*/* EVALCK: D (YES,UPDEVT,NO,) COM TASK ECB */
EVALCK   L     XRSCRTCH,TCBJSCB   GET JSCB ADDR                @Y30HPVA
         USING IEZJSCB,XRSCRTCH                                @Y30HPVA
         L     XRSCRTCH,JSCBCSCB  GET CSCB ADDR                @Y30HPVA
         USING CSCB,XRSCRTCH                                   @Y30HPVA
         L     XRSCRTCH,CHECBP    GET COMMUNICATION'S          @Y30HPVA
*                                 ECB ADDRESS                  @Y30HPVA
         DROP  XRSCRTCH                                        @Y30HPVA
         LA    R1,ZERO(,R6)       CLEAR THE HIGH BYTE          @ZA08089
         CLR   XRSCRTCH,R1        CHECK ADDRS                  @Y30HPVA
         BE    UPDEVT             BRANCH IF EQUAL              @Y30HPVA
         SPACE
*/*      L     CHECK VALIDITY OF ECB AGAINST USER KEY */
*
*        GOING TO USER KEY TO TEST ECB
*        IF STORE FAILS FRR WILL GET CONTROL
*
         SR    XRSCRTCH,XRSCRTCH       CLEAR REGISTER          @Y30HPVA
         IC    XRSCRTCH,TCBPKF         GET USER PROTECT KEY    @Y30HPVA
         SPKA  ZERO(XRSCRTCH)          GO TO USER PROTECT KEY  @ZA08089
         L     XRSCRTCH,ZERO(,XRECB)   GET CONTENTS OF ECB     @Y30HPVA
EVNTLPC  CS    XRSCRTCH,XRSCRTCH,ZERO(XRECB) STORE INTO ECB    @Y30HPVA
         BNE   EVNTLPC                 LOOP TILL STORE COMPLETE@Y30HPVA
         SR    XRSCRTCH,XRSCRTCH       CLEAR REGISTER          @Y30HPVA
         SPKA  ZERO(XRSCRTCH)          GO TO KEY ZERO          @ZA08089
         SPACE
*/* UPDEVT: P UPDATE TABLE POINTERS AND ECB */
UPDEVT   L     XRWORK,ZERO(,XRECB)     GET TABLE ADDRESS       @Y30HPVA
         BCTR  XRWORK,ZERO             CLEAR LOW BIT           @Y30HPVA
         LA    XRWORK,ZERO(XRWORK)     CLEAR HIGH BYTE         @Y30HPVA
         L     XRSCRTCH,EVNTLSTA-EVNT(,XRWORK) GET PTR TO LAST @Y30HPVA
*                                      ACTIVE EVENT ENTRY      @Y30HPVA
*/* D (NO,,YES,ABEND502) IS TABLE FULL */
         CL    XRSCRTCH,EVNTLST-EVNT(,XRWORK) CHECK FOR NO MORE@Y30HPVA
*                                 EVENT ENTRIES IN THIS TABLE  @Y30HPVA
         BE    ABEND502           TABLE FULL ABEND             @Y30HPVA
         SPACE 2
*        THE ORDER IN WHICH THE EVENTS TABLE AND ECB WERE      @ZA11895
*        PROCESSED WAS CHANGED TO POST THE ECB FIRST AND THEN  @ZA11895
*        UPDATE THE EVENTS TABLE.                              @ZA11895
         SPACE 2
         SR    R1,R1              INDICATE PROCES COMP         @Y30HPVA
         N     XRPTCODE,OFFWAIT   TURN OFF WAIT BIT            @Y30HPVA
         O     XRPTCODE,ONCOMPL   TURN ON POST IND             @Y30HPVA
         ST    XRPTCODE,ZERO(,XRECB)   UPDATE ECB              @Y30HPVA
         O     XRECB,TIDBIT       SET END OF LIST IND          @Y30HPVA
         ST    XRECB,FOUR(,XRSCRTCH) STOR PTR TO COMP ECB      @Y30HPVA
         MVI   ZERO(XRSCRTCH),ZERO   ZERO PREV END OF LIST IND @Y30HPVA
         LA    XRSCRTCH,FOUR(,XRSCRTCH) UPDATE PTR TO LAST     @Y30HPVA
*                                    EVENT ENTRY               @Y30HPVA
         ST    XRSCRTCH,EVNTLSTA-EVNT(,XRWORK) STORE PTR IN    @Y30HPVA
*                                 EVENT TABLE HEADER           @Y30HPVA
*/* EVN11: S DELETEFRR: DELETE FRR FOR EVENTS */
DFRR     SETFRR D,WRKREGS=(XRWORK,XRSCRTCH) DELETE FRR         @Y30HPVA
         LTR   R1,R1              TEST FOR GOOD POST           @Y30HPVA
         BNE   EVSVC13            NO GOOD ISSUE ABEND          @Y30HPVA
*/* EVN12: D (NO,EXIT,YES,EVSWCF) CHECK IF RB WAITING */
         LTR   XRRB,XRRB          CHECK FOR WAITING RB         @Y30HPVA
         BZ    EXIT               NO RB EXIT                   @Y30HPVA
         B     EVSWCF             BRANCH TO POST W / O ECB     @Y30HPVA
*/* ABEND402: S DELETEFRR: DELETE FRR FOR EVENTS*/
*/* EVN13: R ABEND 402*/
ABEND402 L     R1,ABND402         LOAD 402 ABEND CODE          @Y30HPVA
         B     DFRR               GO DELETE FRR                @Y30HPVA
*/* ABEND502: S DELETEFRR: DELETE FRR FOR EVENTS*/
*/* EVN14: R ABEND 502*/
ABEND502 L     R1,ABND502         LOAD 502 ABEND CODE          @Y30HPVA
         B     DFRR               GO DELETE FRR                @Y30HPVA
EVSVC13  SVC   ABENINST           CALL ABEND                   @Y30HPVA
         EJECT
*/* TCBRBCHN: L CHECK TCB/RB Q TO FIND WAITING RB */
NOEVENTS L     XRRB,ZERO(,XRECB)   GET WAITING RB ADDRESS      @Y30HPVA
         LA    XRRB,0(XRRB)        PERFECT ADDR
         L     XRWORK,ASCBASXB     ADDR OF ASXB
         L     XRTCB,ASXBLTCB-ASXB(XRWORK)  ADDR OF LOWEST TCB
TCBRBCHN L     XRWORK,TCBRBP       ADDR OF TOP RB
*/*RBADDR: D (NO,ERROR2,YES,) RB IS ON TCB/RB QUEUES*/
RBADDR   CR    XRRB,XRWORK         CHK IF ADDR SAME AS ADDR IN ECB
         BE    RBOK                BR IF SO
         TM    RBSTAB2-RBSECT(XRWORK),TCBIND  BACK TO TCB YET
         L     XRWORK,RBLINK-RBSECT(,XRWORK) ADDR OF NEXT BLOCK
         LA    XRWORK,ZERO(,XRWORK)   PERFECT ADDR
         BZ    RBADDR              BR IF RB IS NEXT
         L     XRTCB,TCBBACK       NEXT TCB IN RDY Q
         LTR   XRTCB,XRTCB         TEST FOR TOP OF Q
         BNZ   TCBRBCHN            BR IF NOT
         B     ERROR2              RB NOT FOUND - ERROR
*/*RBOK: D (NO,ERROR2,YES,) WAITING RB OPSW IS ENABLED*/
RBOK     TM    RBOPSW,ENABON       IS WAITER ENABLED
         BC    DISAB,ERROR2        NO,ABEND
*/* D (YES,SUPKEY1,NO,) WAITING RB OPSW IS SUPVR KEY*/
         TM    RBOPSW+ONE,SUPTST   RBOPSW=KEY 0?
         BZ    SUPKEY1             YES,BR
*/* S IEA0VL01: VALIDITY CHECK ADDRESS*/
         LR    R1,XRECB            START ADDR
         LA    XRSCRTCH,L3(,R1)    END ADDR
         STM   R14,R15,FOUR*R14(XRSAVE)  SAVE 14-15
         L     R15,CHECK           ADDR OF VAL CHK RTN
         BALR  R14,R15             GO WITH WAITING TCB ADDR IN 4
         LM    R14,R15,FOUR*R14(XRSAVE)  RESET 14-15
*/* D (FAIL,,OK,SUPKEY) RESULTS OF VALIDITY CHECK*/
         BZ    SUPKEY              BR IF OK                    @YM04972
         L     XRSCRTCH,TCBJSCB    GET JSCB ADDR               @YM04972
         USING IEZJSCB,XRSCRTCH                                @YM04972
         L     XRSCRTCH,JSCBCSCB   GET CSCB ADDR               @YM04972
         USING CSCB,XRSCRTCH                                   @YM04972
         L     XRSCRTCH,CHECBP     GET COMMUNICATION'S         @YM04972
*                                  ECB ADDRESS                 @YM04972
         DROP  XRSCRTCH
         LA    R1,ZERO(,R1)        CLEAR THE HIGH BYTE         @YM04972
*/* D (YES,SUPKEY,NO,ERROR2) COMM. ECB */
         CLR   XRSCRTCH,R1         CHECK ADDRS                 @YM04972
         BNE   ERROR2              BRANCH IFF ERROR            @YM04972
*/*SUPKEY: D (YES,POSTTEST,NO,) EXPLICIT WAIT BIT IS ON IN RB*/
SUPKEY   DS    0H
         S     XRRB,WPRBPREL       SUBTRACT FROM BASE
         TM    RBFLAGS1-RBPREFIX(XRRB),RBXWAIT    DID RB ISSUE A WAIT?
         LA    XRRB,RBPRFXLN(XRRB) RESTORE BASE
         BO    POSTTEST            YES,BRANCH TO MAINLINE CODE
*/*SUPPL: P (,QENTRY2) SET TO POST ECB */
*              THE RB THE ECB POINTS TO IS NOT WAITING. SET
*              UP TO MAKE THE ECB LOOK POSTED.
SUPPL    L     R1,ZERO(,XRECB)     GET ECB FOR CS              @YM02496
         B     QENTRY2             GO TO SET IT POSTED         @YM02496
         SPACE 1
*/*SUPKEY1: D (YES,SUPKEY,NO,)   SUPERVISOR (KEY) CALLER*/
*              THESE TESTS ASSURE THAT A SUPERVISOR KEY WAITER
*              IS POSTED ONLY BY A SUPERVISOR KEY POSTER OR THE
*              ECB TO BE POSTED IS THE SAME AS THE ECB WAITED ON.
SUPKEY1  LTR   XRRETURN,XRRETURN   TEST IF BR ENTRY            @YM00429
         BM    SUPKEY              BR IF BRANCH ENTRY          @YM00429
SUPKEYX  L     R1,PSATOLD          GET CURRENT TCB POINTER     @YM00429
         LTR   R1,R1               TEST IF SRB MODE FOR XMPOST @YM00429
         BZ    SUPKEY              BR IF XMPOST                @YM00429
         L     R1,TCBRBP-TCB(,R1)  GET TOP RB POINTER          @YM00429
         TM    RBOPSW+ONE-RBSECT(R1),SUPTST CALLER SUPER KEY   @YM00429
         BZ    SUPKEY              BR IF SUPER CALLER          @YM04247
*/* D (NO,SUPPL,YES,) IS RB IN EXPLICIT WAIT*/
         S     XRRB,WPRBPREL       SUBTRACT FROM BASE
         TM    RBFLAGS1-RBPREFIX(XRRB),RBXWAIT    DID RB ISSUE A WAIT?
         LA    XRRB,RBPRFXLN(XRRB) RESTORE BASE
         BZ    SUPPL               BR NOT EXPLICIT WAIT        @YM02496
*/* D (YES,POSTTEST,NO,ERROR2) ECB ADDRESSES MATCH */
         L     R1,TCBGRS1          SET ECB ADDR REG            @YM04247
         LA    XRECB,ZERO(,XRECB)  CLEAR HIGH                  @YM04247
         CL    XRRB,TCBRBP         WAITER TOP RB               @YM04247
         BE    SUPKEY2             YES, TCBGRS1 IS OK          @YM04247
         L     R1,TCBRBP           GET TOP RB                  @YM04247
SUPKEYN  L     XRWORK,RBLINK-RBSECT(,R1)    GET NEXT RB        @YM04247
         LA    XRWORK,ZERO(,XRWORK)  CLEAR HIGH BYTE           @YM04247
         CLR   XRWORK,XRRB         CHECK FOR WAITER RB         @YM04247
         BE    SUPKEYR             BR IF MATCH(R1 HAS IRB ADDR)@YM04247
         LR    R1,XRWORK           SET FOR NEXT CHECK          @YM04247
         B     SUPKEYN             CHECK NEXT RB               @YM04247
SUPKEYR  L     R1,RBGRS1-RBSECT(,R1) GET ADDR OF ECB           @YM04247
SUPKEY2  LCR   XRWORK,R1           TEST FOR LIST               @YM04247
         BP    SUPKGL              BR IF LIST                  @YM04247
         LA    R1,ZERO(,R1)        CLEAR HIGH                  @YM04247
         CLR   R1,XRECB            TEST FOR SAME ECB           @YM04247
         BE    POSTTEST            SAME ECB IS OK              @YM04247
         B     ERROR2              ABEND THE BAD GUY           @YM04247
SUPKGL   L     R1,ZERO(,XRWORK)    GET ECB ADDR                @YM04247
         LA    R1,ZERO(,R1)        CLEAR HIGH                  @YM04247
         CLR   R1,XRECB            CHECK FOR SAME              @YM04247
         BE    POSTTEST            BR IF OK                    @YM04247
         TM    ZERO(XRWORK),TCBIND TEST FOR LAST               @YM04247
         BO    ERROR2              ABEND IF END OF LIST        @YM04247
         LA    XRWORK,FOUR(,XRWORK) INCR LIST ADDR             @YM04247
         B     SUPKGL              CONTINUE                    @YM04247
         EJECT
*/* E IEA0PT03*/
IEA0PT03 EQU   *                   BRANCH ENTRY LABEL          @Z40EPVD
*/* P GET ADDR OF LOCAL SAVE AREA - SAVE REGS*/
         L     XRBASE,PSAAOLD      GET CURRENT ASCB ADDR       @Z40EPVD
         L     XRBASE,ASCBASXB-ASCB(XRBASE) ASXB ADDR          @Z40EPVD
         L     XRBASE,ASXBSPSA-ASXB(XRBASE) LOCAL WSAVT ADDR   @Z40EPVD
         L     XRBASE,WSALPOST-WSAL(XRBASE) POST WSA ADDR      @Z40EPVD
         STM   R0,R14,LSAEXT-LSA(XRBASE)    SAVE CALLERS REGS  @Z40EPVD
*/* P INDICATE EXT SAVE AREA IN USE*/
         OI    LSAFLGS-LSA(XRBASE),EXTSA  EXTSAVE AREA IN USE  @Z40EPVD
         LR    R9,XRBASE                SAVE AREA BASE REG     @Z40EPVD
         BALR  XRBASE,R0                ESTABLISH BASE REG     @Z40EPVD
         USING *,XRBASE                 ESTAB ADDRESSABILITY   @Z40EPVD
         L XRBASE,BASE                  GET COMMON BASE ADDR   @Z40EPVD
         USING IGC002+2,XRBASE          COMMON BASE            @Z40EPVD
*/* P SET BRANCH ENTRY SWITCH - REG 14 NEGATIVE*/
         O     XRRETURN,TIDBIT          SET BR ENTRY SWITCH    @Z40EPVD
*/* D (YES,XMPOST1,NO,SETMREGS) XMPOST REQUEST*/
         LTR   R11,R11                  XMPOST REQUEST         @Z40EPVD
         BM    XMPOST1                  YES GO PROCESS         @Z40EPVD
         LR    XRECB,R11                SAVE INPUT ECB ADDR    @Z40EPVD
         LR    XRSAVE,R9                INIT SAVE AREA BASE    @Z40EPVD
         B     SETMREGS                 GO INIT MAINLINE REGS  @Z40EPVD
         EJECT
*  TEST IF POST FLAG IN ECB ON. YES ON, GO TO EXIT SECTION. NO NOT ON,
* STORE POST CODE AND SET POST FLAG IN ECB.
*  DECREMENT RB'S WAIT COUNT. DECREMENTED WAIT COUNT ZERO GO TO EXIT
* SECTION. COUNT NOT ZERO CONTINUE PROCESS.
         SPACE 2
*/*POSTTEST: P PICK UP ECB FOR LATER COMPARE AND SWAP*/
POSTTEST L     R1,ZERO(,XRECB)         GET OLD ECB             @YM02795
*/* D (YES,EXIT,NO,) ECB'S POST BIT IS ALREADY ON*/
         TM    0(XRECB),ECBPTFLG       Q. ECB'S POST FLAG SET
         BO    EXIT                    YES,EXIT
*/* D (NO,QENTRY2,YES,) SOMEONE IS WAITING ON THIS ECB*/
         TM    0(XRECB),ECBWTFLG       Q. POST BEFOR WAIT
         BZ    QENTRY2                 YES,BRANCH
*/* D (YES,QENTRY2,NO,) RB WAIT COUNT IS ALREADY ZERO*/
         TM    RBWCF,ANYONE            Q. IS WAIT COUNT ZERO
         BZ    QENTRY2                 YES.BRANCH                 19472
*/* P DECREMENT WAIT COUNT*/
         SR    XRWAITCT,XRWAITCT       INIT REG TO ZERO           19472
         IC    XRWAITCT,RBWCF          LOAD ECBS RB WAIT COUNT
*/* D (NO,QENTRY,YES,) WAIT COUNT IS NOW ZERO*/
         BCT   XRWAITCT,QENTRY         DECR WAIT CT.NOT 0,BR     A33247
         EJECT
*  WAIT COUNT IS ZERO. TEST RB'S ECB SEARCH FLAG. IF FLAG NOT ON GO TO
* NEXT SECTION. IF FLAG IS ON RESET IT AND TEST IF RB ON TOP OF IT'S
* QUEUE. IF RB IS TOP OF IT'S QUEUE GET ECB LIST ADDRESS FROM TCB'S
* REGISTER 1 SAVE AREA. IF RB NOT TOP OF IT'S QUEUE FIND OUT WHAT TYPE
* OF RB IS ON TOP OF IT. THEN GET ECB LIST ADDRESS FROM WHEREVER THE
* REGISTER 1 IS SAVED IN THAT TYPE OF RB. AFTER GETTING ECB LIST
* ADDRESS, GO AND RESET  ALL THE ECB'S WAIT FLAGS TO ZERO.
         SPACE 2
*/* D (NO,TCBREADY,YES,) RB SEARCH BIT IS ON*/
         TM    RBSTAB2,RBECBWT          Q.ECB'S SEARCH FLAG SET
         BZ    TCBREADY                 NO BRANCH
*/*LOOP3: P FIND TCB- GET SAVED ECBLIST ADDRESS*/
         C     XRRB,TCBRBP              Q.ECB'S RB TOP OF QUEUE
         BE    TCBXR1                   YES BRANCH
         L     XRWORK,TCBRBP            LD TOP RB'S ADR
LOOP3    L     XRECBPTR,RBGRS1-RBSECT(XRWORK)   LD RB REG 1
         L     XRWORK,RBLINK-RBSECT(XRWORK)     LD NEXT RB'S ADR
         LA    XRWORK,0(XRWORK)         ZERO BITS S-7
         CR    XRWORK,XRRB              Q.FOUND WAITING RB
         BNE   LOOP3                    NO, BRANCH
         B     RESETWT                  AVOID NEXT INST
TCBXR1   L     XRECBPTR,TCBGRS1         LD TCB REG 1
RESETWT  LCR   XRECBPTR,XRECBPTR        LD TRUE ECB LIST ADR
         EJECT
         LR    XRWORK,XRECBPTR          SAVE ECB PTR REG
*/* D (YES,NOCHECK,NO,) WAITER IS SUPVR KEY*/
         TM    RBOPSW+ONE,SUPTST        IS WAITER SUPVR KEY?
         BC    KEY0,NOCHECK             YES,BYPASS VALIDTY CHECK
*/*LOOP4: S IEA0VL01: VALIDITY CHECK ALL ADDRS IN ECBLIST*/
LOOP4    L     R1,ZERO(XRECBPTR)        GET ECB ADDRESS
         LA    XRSCRTCH,L3(,R1)         END ADDR FOR VAL CHK
         STM   R14,R15,FOUR*R14(XRSAVE) SAVE REGS 14-15
         L     R15,CHECK                GET RTN ADDR
         BALR  R14,R15                  GO TO VAL CHK
         LM    R14,R15,FOUR*R14(XRSAVE) RESTORE REGS 14-15
*/* D (FAIL,COMMCHEK,OK,) RESULTS OF VALIDITY CHECK*/
         BNZ   COMMCHEK                 BRANCH IF NOT VALID
*/*LSTWRD: D (END,NOCHECK,MORE,LOOP4) NEXT ECB IN LIST, IF ANY*/
LSTWRD   TM    ZERO(XRECBPTR),LSTIND    Q. LAST WORD OF LIST?
         BC    LAST,NOCHECK             YES, BRANCH
         LA    XRECBPTR,FOUR(XRECBPTR)  NO,INCREMENT POINTER
         B     LOOP4                    CHECK NEXT ECB
         EJECT
*/*NOCHECK: P  TURN OFF WAIT BIT IN EACH ECB IN LIST*/
*/* N (,TCBREADY) THE ECB BEING POSTED DOES NOT HAVE ITS WAIT BIT
*/*TURNED OFF*/
*              THE WAIT BIT IN THE ECB BEING POSTED BECAUSE OF THE MP
*              CONSIDERATIONS ON UPDATING ECBS.  THAT IS, ONCE THE WAIT
*              BIT IS TURNED OFF, ANOTHER CPU MAY UPDATE THE ECB.
NOCHECK  LR    XRECBPTR,XRWORK          RESET POINTER
LOOP9    L     XRWORK,ZERO(XRECBPTR)    SET PTR TO ECB
         CLR   XRWORK,XRECB             THIS THE POSTING ECB   @YM02795
         BE    LOOP9A                   YES, BRANCH PAST NI    @YM02795
         NI    ZERO(XRWORK),RECBWTF     TURN OFF WAIT BIT
LOOP9A   TM    ZERO(XRECBPTR),LSTIND    Q.  LAST ECB?
         BC    LAST,TCBREADY            YES, BRANCH
         LA    XRECBPTR,FOUR(XRECBPTR)  NO, INCREMENT PTR TO NEXT ECB
         B     LOOP9                    PROCESS NEXT ECB
***********************************************************************
*/*COMMCHEK: P GET CSCB VIA JSCB*/
COMMCHEK L     XRSCRTCH,TCBJSCB         GET JSCB ADDR             20002
         USING IEZJSCB,XRSCRTCH                                   20002
         L     XRSCRTCH,JSCBCSCB        GET CSCB ADDR             20002
         USING CSCB,XRSCRTCH                                      20002
         L     XRSCRTCH,CHECBP          GET COMMUNICATION'S       20002
*                                       ECB ADDRESS               20002
         LA    R1,ZERO(,R1)             CLEAR THE HIGH BYTE       20002
*/* D (YES,LSTWRD,NO,) INVALID ECB BELONGS TO CSCB*/
         CR    XRSCRTCH,R1              Q.ECB EQUAL TO COMM. ECB  20002
         BE    LSTWRD                   YES.CONTINUE              20002
*/*ERROR1: P SET ABEND CODE TO 102*/
ERROR1   LA    R1,ERRPOST1              GET ABEND CODE
*/*ABND2: R ABEND*/
ABND2    SLL   R1,ABNDALGN              MOVE IT OVER
         O     R1,TIDBIT                TURN ON DUMP BIT
         SVC   ABENINST                 ABEND
***********************************************************************
         SPACE 1
*            RB'S WAIT COUNT HAS GONE TO ZERO
*
*/*TCBREADY: P STORE POST CODE  AND POST BIT IN ECB*/
*/* N COMPARE AND SWAP NOT NECESSARY AS ECB CANNOT BE CHANGED */
*/* N WITH THE WAIT BIT ON. SUFFICE TO CHANGE IN ONE INSTRUCTION.*/
TCBREADY LA    XRTCB,0(XRTCB)           LOAD TCB ADDRESS
         N     XRPTCODE,OFFWAIT         REST WAIT BIT           @Y02752
         O     XRPTCODE,ONCOMPL         SET POST BIT            @Y02752
         ST    XRPTCODE,ZERO(,XRECB)    SET CODE AND BIT       @YM02795
*/*SETRBPFX: P RESET RB LONG-WAIT AND EXPLICIT WAIT BITS*/
SETRBPFX S     XRRB,WPRBPREL            SUBTRACT FROM BASE
         NI    RBFLAGS1-RBPREFIX(XRRB),ANYONE-RBXWAIT-RBLONGWT
         LA    XRRB,RBPRFXND-RBPREFIX(,XRRB) RESET RBSECT ADDR @YM04158
*/* P RESET RB SEARCH BIT*/
         NI    RBSTAB2,RRBECBWT         RESET RB ECB SEARCH FLAG
*/* D (NO,SETWTCT,YES,) READIED RB IS TOP RB ON TCB CHAIN*/
         C     XRRB,TCBRBP              IS READIED RB TOP RB
         BNE   SETWTCT                  BR IF NOT
*/* D (YES,SETWTCT,NO,) TCB IS NON-DISP*/
         CH    XRWAITCT,TCBFLGS4        TEST NON-DISP FLGS FOR ZERO
         BNZ   SETWTCT                  BR IF NOT ZERO
*/*CSTCBSUP: P INCREMENT # READY TCBS IN A.S.*/
         L     XRWORK,ASCBTCBS          GET TCB COUNT
CSTCBSUP LA    XRSCRTCH,ONE(XRWORK)     BUMP
         CS    XRWORK,XRSCRTCH,ASCBTCBS STORE CT
         BNZ   CSTCBSUP                 BR IF DID NOT GO
*/*SETWTCT: P (,EXIT) STORE RESULTANT WAIT COUNT IN RB*/
SETWTCT  STC   XRWAITCT,RBWCF           STORE WAIT COUNT
         B     EXIT                     DONE
         SPACE 1                                                 A33247
*/*QENTRY: P STORE RESULTANT WAIT COUNT IN RB*/
QENTRY   STC   XRWAITCT,RBWCF           STORE WAIT COUNT
*/*QENTRY2: P SET POST CODE AND COMPL BIT IN REG FOR CS*/
QENTRY2  N     XRPTCODE,OFFWAIT         REST WAIT BIT           @Y02752
         O     XRPTCODE,ONCOMPL         SET POST BIT            @Y02752
*/*QENTRY3: P COMPARE AND SWAP COMPLETION CODE AND POST BIT TO ECB*/
QENTRY3  CS    R1,XRPTCODE,ZERO(XRECB)  SET CODE AND BIT        @Y02752
*/* D (YES,EXIT,NO,) COMPARE AND SWAP GO*/
         BZ    EXIT                     BR CS GOES OK           @Y02752
*/* D (YES,,NO,QENTRY3)  POST BIT ON NOW */
*        IF THE POST BIT IS ON NOW, THAT IS OK AND NO
*        FURTHER CHANGE OF THE ECB IS REQUIRED.
*        IF THE WAIT BIT IS ON, SOMETHING BAD (A WAIT IN
*        ANOTHER MEMORY ON THE ECB OR AN INVALID USER
*        UPDATE) HAS HAPPENED. IN EITHER CASE, SET THE ECB
*        TO LOOK VALID FOR THE VALID CALLER AND WE'LL CATCH
*        THE INVALID CALLER LATER.
*        THE ECB MAY HAVE BEEN CHANGED TO HAVE NEITHER
*        WAIT OR POST BIT SET, IN WHICH CASE THE ECB SHOULD REFLECT
*        THE POSTED CONDITION.
         TM    ZERO(XRECB),ECBPTFLG    IS NOW POSTED           @YM02795
         BZ    QENTRY3                 NO,PUT IN NEW POST CODE @YM02795
*/*EXIT: D (POS,SRBEXIT,NEG,) TEST R14 ENTRY SW*/
EXIT     LTR   XRRETURN,XRRETURN       TEST BR/SVC SW
         BP    SRBEXIT                 BR IF SVC ENTRY
*/* D (YES,RESTALL,NO,) EXTENDED SAVE AREA IN USE*/
         TM    LSAFLGS-LSA(XRSAVE),EXTSA EXT SA IN USE         @Z40EPVD
         BO    RESTALL                 YES GO PROCESS          @Z40EPVD
*/* R RESTORE 0-9 RETURN 14*/
         LM    R0,R9,WS0(XRSAVE)       RESTORE REGS 0-9           M0113
         BR    XRRETURN                LEAVE
*/*RESTALL: P RESET EXT SA IN USE FLAG; RESTORE REGS 0-14*/
RESTALL  EQU   *                       EXT SAVE AREA IN USE    @Z40EPVD
         NI    LSAFLGS-LSA(XRSAVE),XFF-EXTSA RESET IN USE FLAG @ZA30491
         LM    R0,R14,LSAEXT-LSA(XRSAVE) RESTORE REGS          @Z40EPVD
         BR    XRRETURN                RETURN TO CALLER        @Z40EPVD
*/* R RETURN ON 14*/
*/*SRBEXIT: D (SRB,%Q2,TCB,) RUNNING UNDER TCB OR XMPOST SRB*/
SRBEXIT  L     XRWORK,PSATOLD          ADDR OF CURRENT TCB
         LTR   XRWORK,XRWORK           TEST FOR TCB ADDR
*/* R REG 14*/
         BNZR  XRRETURN                BR IF TCB MODE
*/*%Q2: S SETFRR: DELETE XMPOST FRR*/
QPFY9    SETFRR D,WRKREGS=(XRWORK,XRSCRTCH)
         LR    R1,R0                   ADDR OF XMPOST SRB
         USING SRBSECT,R1              SRB BASE
*/* S SETLOCK: OBTAIN SALLOC LOCK*/
         LR    XRSCRTCH,R14            SAVE REG 14 ACROSS      @YM02663
LK3      SETLOCK OBTAIN,TYPE=SALLOC,MODE=UNCOND,RELATED=LK4    @YM02663
*/* D (YES,EXITGONE,NO,) ORIG ASCB HAS GONE AWAY*/
         L     R0,XMPQ                 XMPOST SRB CHAIN FLD
         LTR   R0,R0                   SRBS ARE ORPHANS
         BM    EXITGONE                BR IF ORIG ASCB GONE
         L     XRWORK,XMASCB           ADDR OF ORIG ASCB
         LA    XRWORK,ASCBXMPQ-ASCB(XRWORK)     ADDR OF CHAIN HEADER
*/*EXITLOOP: D (YES,EXITDEQ,NO,) THIS IS OUR SRB*/
EXITLOOP C     R1,ZERO(,XRWORK)        IS THIS OUR SRB
         BE    EXITDEQ                 BR IF SO
*/* P (,EXITLOOP) GET NEXT SRB*/
         L     XRWORK,ZERO(,XRWORK)    GET TO NEXT SRB
         LA    XRWORK,XMPQ-SRBSECT(,XRWORK) ADDR OF NEXT CHAIN
         B     EXITLOOP                DO IT AGAIN
*/*EXITDEQ: P DEQ XMPOST SRB FROM ITS PARENT ASCB*/
EXITDEQ  ST    R0,0(,XRWORK)           DEQ OUR SRB
*/*EXITGONE: P PUT XMPOST SRB BACK ON CHAIN */
EXITGONE L     R13,CHAINHD             GETCHAIN HEADER         @YM02663
         ST    R13,ZERO(,R1)           SAVE OLD CHAIN PTR IN   @YM02663
*                                      THIS SRBS POINTER FIELD @YM02663
         ST    R1,CHAINHD              CHAIN THIS SRB ON TOP   @YM02663
*/* S SETLOCK: RELEASE SALLOC LOCK*/
LK4      SETLOCK RELEASE,TYPE=SALLOC,RELATED=LK3
*/* S SETLOCK: RELEASE LOCAL LOCK*/
LK5      SETLOCK RELEASE,TYPE=LOCAL,RELATED=LK10
*/* R DISPATCHER SRB EXIT*/
         BR    XRSCRTCH                RETURN TO DISP
*  ERROR EXIT
*/*ERROR2: R ABEND 202*/
ERROR2   LA    R1,ERRPOST2             LOAD ERROR CODE
         B     ABND2                   BRANCH
         EJECT
*
*  PROCESS ECB EXTENSION
*
         SPACE
EXTECB   EQU   *                      ECB EXTENSION PROCESSING @Z40EPVD
*/*EXTECB: S SETFRR: ESTABLISH RECOVERY ENVIRONMENT*/
         LA    R1,EXECBFRR            GET FRR ADDR             @Z40EPVD
         SETFRR A,FRRAD=(R1),WRKREGS=(XRWORK,XRSCRTCH),PARMAD=(FRRWA3)
*/* P PRIME FRR WORK AREA WITH FAILURE CODE - 14*/
         LA    R1,RC14                GET REASON CODE 14       @Z40EPVD
         ST    R1,ZERO(FRRWA3)        PUT RC IN WORK AREA      @Z40EPVD
*/* D (NO,CHNGRC1,YES,) EXIT ROUTINE REQUEST*/
         L     ECBE2,ECB-ECB(XRECB)   ADDR OF ECB EXT          @Z40EPVD
         SLL   ECBE2,HIGHBIT          CLEAR WAIT BIT           @Z40EPVD
         SRL   ECBE2,LOWBITS          CLEAR EXT ECB BITS       @Z40EPVD
         SLL   ECBE2,LOWBITS-HIGHBIT  PURE ECB EXT ADDR        @Z40EPVD
         CLC   ZERO(FOUR,ECBE2),PXITCODE VALID FIRST WORD      @Z40EPVD
         BNE   CHNGRC1                NO, PREPARE TO ABEND     @Z40EPVD
*/* MOREEXIT: D (NO,CHNGRC2,YES,) ANY MORE EXIT ROUTINES*/
         L     R1,ASCBASXB-ASCB(XRASCB) ASXB ADDR              @Z40EPVD
         L     R1,ASXBPT0E-ASXB(R1)   POST EXIT QUEUE HEADER   @Z40EPVD
MOREEXIT EQU   *                      EXIT QUEUE LOOP LABEL    @Z40EPVD
         LTR   R1,R1                  ANY MORE EXITS?          @Z40EPVD
         BZ    CHNGRC2                NO PREPARE TO ABEND      @Z40EPVD
*/* D (YES,VALEXIT,NO,) EXIT ROUTINE ADDRESSES MATCH*/
         CLC   FOUR(FOUR,ECBE2),FOUR(R1) EXIT ADDRS MATCH      @Z40EPVD
         BE    VALEXIT                YES, EXIT LOOP           @Z40EPVD
*/* P (,MOREEXIT) GET ADDR OF NEXT BLOCK*/
         L     R1,ZERO(R1)            NO, GET NEXT BLOCK ADDR  @Z40EPVD
         B     MOREEXIT               LOOP BACK                @Z40EPVD
*/*VALEXIT: D (YES,CHNGRC3,NO,) EXTENDED SAVE AREA IN USE*/
VALEXIT  EQU   *                      VALID EXIT ADDR          @Z40EPVD
         TM    LSAFLGS-LSA(XRSAVE),EXTSA+PEXITSA SA IN USE     @Z40EPVD
         BNZ   CHNGRC3                YES, PREPARE TO ABEND    @Z40EPVD
*/* P SET COMPLETE BIT AND COMPLETION CODE IN ECB*/
         N     XRPTCODE,OFFWAIT       TURN OFF WAIT BIT        @Z40EPVD
         O     XRPTCODE,ONCOMPL       TURN ON COMPLETE BIT     @Z40EPVD
         ST    XRPTCODE,ECB-ECB(,XRECB) UPDATE ECB             @Z40EPVD
*/* P SAVE POST REGS ACROSS INTERFACE - MARK EXIT SA IN USE*/
         OI    LSAFLGS-LSA(XRSAVE),PEXITSA TEMP SA IN USE      @Z40EPVD
         STM   R12,R1,LSAPEXI2-LSA(XRSAVE) SAVE REGS NEEDED    @ZA30491
*        THE ABOVE INSTRUCTION WAS CHANGED TO ALSO SAVE R12-13 @ZA30491
*/* P RESET FAILURE CODE IN FRR WORK AREA*/
         LA    R15,RC0                GET ZERO REASON CODE     @Z40EPVD
         ST    R15,ZERO(FRRWA3)       PUT RC IN WORK AREA      @Z40EPVD
*/* P PREPARE INTERFACE FOR EXIT ROUTINE*/
         L     R15,FOUR(R1)           EXIT ENTRY PT ADDR       @Z40EPVD
         ST    R15,LSAXITEP-LSA(,XRSAVE) SAVE E.P. ADDR        @Z40EPVD
         LR    R1,ECBE2               ECB EXTENSION ADDR       @Z40EPVD
         LR    R0,XRECB               PASS POSTED ECB ADDR     @Z40EPVD
*/* S EXIT RTN: INVOKE EXIT ROUTINE*/
         BALR  R14,R15                CALL EXIT ROUTINE        @Z40EPVD
*/* P RESET POST REGS*/
         LM    R12,R1,LSAPEXI2-LSA(XRSAVE) RESTORE REGS        @ZA30491
*/* P INDICATE EXTENDED AND EXIT SAVE AREAS NOT IN USE*/
         NI    LSAFLGS-LSA(XRSAVE),XFF-EXTSA-PEXITSA NOT USED  @Z40EPVD
*/* S (,EXIT) SETFRR: DELETE POST EXIT FRR*/
         SETFRR D,WRKREGS=(XRWORK,XRSCRTCH) DELETE FRR         @Z40EPVD
         B     EXIT                   MAINLINE EXIT CODE       @Z40EPVD
*/*CHNGRC1: P (,ABEND702) SET ABEND REASON CODE TO 8*/
CHNGRC1  LA    R1,RC8                 SET REASON CODE TO 8     @Z40EPVD
         B     ABEND702               GO ISSUE ABEND           @Z40EPVD
*/* CHNGRC2: P (,ABEND702) SET ABEND REASON CODE TO C*/
CHNGRC2  LA    R1,RCC                 SET REASON CODE TO C     @Z40EPVD
         B     ABEND702               GO ISSUE ABEND           @Z40EPVD
*/*CHNGRC3: P SET ABEND REASON CODE TO 10*/
CHNGRC3  LA    R1,RC10                SET REASON CODE TO 10    @Z40EPVD
*/*ABEND702: S SETFRR: DELETE FRR BEFORE ABENDING*/
ABEND702 EQU   *                      PREPARE FOR 702 ABEND    @Z40EPVD
         LR    R0,ECBE2               SAVE ECB EXT ADDR        @Z40EPVD
         SETFRR D,WRKREGS=(XRWORK,XRSCRTCH) DELETE FRR         @Z40EPVD
*/* R ABEND 702*/
         LR    R3,R1                  SAVE REASON CODE         @Z40EPVD
         L     R1,ABND702             GET 702 ABEND CODE       @Z40EPVD
         LR    R15,R3                 SET REASON CODE          @Z40EPVD
         SVC   ABENINST               ISSUE ABEND              @Z40EPVD
         EJECT
***********************************************************************
***********************************************************************
*     THE FOLLOWING CODE IS ENTERED IF A PARAMETER LIST FOR AN        *
*       CROSS MEMORY POST WAS SPECIFIED.                             *
*
*/*XMPROC: P SET UP REGS FROM XMPOST PARM LIST*/
XMPROC   LR    R10,XRPTCODE        SAVE POST CODE
         LTR   R10,R10             CHECK FOR ECBKEY OPTION     @ZA15373
         BNM   XMPECBAD            NOT REQ, SKIP ECBKEY SAVE   @ZA15373
         IC    R0,ECBKEY(,XRECB)   SAVE ECBKEY FOR VAL CHK     @ZA15373
XMPECBAD L     R5,ECBPTR(,XRECB)   SAVE ECB ADDR               @ZA15373
         L     R8,ASCBPTR(,XRECB)  SAVE TARGET ASCB ADDR       @ZA15373
         L     R6,ERRETPTR(,XRECB) SAVE ERRET ADDR             @ZA15373
         LA    R6,ZERO(,R6)        SKIP MEM RELATED TESTS       @Y02752
*/*XMPPROC: D (YES,XMPEROK,NO,) THIS REQUEST MEMORY RELATED*/   @Y02752
XMPPROC  LR    XRSCRTCH,XRRETURN   SAVE RETURN ADDR ACROSS MACROS
         LTR   R6,R6               TEST FOR NOT MEMORY RELATED  @Y02752
         BP    XMPEROK             BR IF MEMORY RELATED         @Y02752
*/* P GET ADDRESS OF MASTER SCHED ASCB */                       @Y02752
         LA    XRASCB,XMASASID     MASTER SCHED  ASID TIMES 4   @Y02752
QJ11     L     R3,CVTPTR           GET POINTER TO CVT           @Y02752
         L     R3,CVTASVT-CVTMAP(,R3) ADDR OF ASVT              @Y02752
         L     XRASCB,ASVTENTY-ASVT-FOUR(R3,XRASCB)   HAVE ADDR @Y02752
*                                  OF MASTER SCHED ASCB         @Y02752
*/*XMPEROK: S SETLOCK: GET SALLOC LOCK */                       @Y02752
XMPEROK  EQU   *                   TESTING LABEL                @Y02752
LK6      SETLOCK OBTAIN,TYPE=SALLOC,MODE=UNCOND,RELATED=LK7
*/* D (NO,,YES,HAVEIT) ARE THERE ANY SRBS ON CHAIN */
         L     R1,CHAINHD          GET CHAIN HEADER            @YM02663
         LTR   R1,R1               ANY THERE                   @YM02663
         BNZ   HAVEIT              YES, BRANCH                 @YM02663
         LR    XRLINKR,XRBASE      SAVE BASE REG ACROSS GM
         LR    XRSAVE,R0           SAVE ECBKEY BY GM INTERFACE @ZA15373
         LA    R0,SRBLENTH         SRB LENGTH
*/* S (,GOTTEN) GETMAIN: XMPOST SRB*/
QJ12     GETMAIN RU,LV=(0),SP=245,BRANCH=(YES,GLOBAL)  GET SRB
         LR    R0,XRSAVE           RESTORE ECBKEY AFTER GM     @ZA15373
         LR    XRBASE,XRLINKR      RESET BASE REG
         B     GOTTEN              GO AROUND CHAIN UPDATE      @YM02663
*/*HAVEIT: P UPDATE CHAIN - TAKE OFF GOTTEN SRB */
HAVEIT   L     XRWORK,ZERO(,R1)    GET NEXT ONE IN CHAIN       @YM02663
         ST    XRWORK,CHAINHD      SAVE POINTER TO NEXT        @YM02663
         USING SRBSECT,R1          BASE REG FOR GOTTEN CORE
*/*GOTTEN: P CHAIN NEW SRB TO ASCB XMPOST SRB LIFO Q*/
GOTTEN   L     XRWORK,ASCBXMPQ     GET XMPOST SRB Q ANCHOR     @YM02663
         ST    R1,ASCBXMPQ         ADDR OF NEW SRB TO TOP
         ST    XRWORK,XMPQ         CHAIN NEW TO REST OF Q
*/* D (YES,NORLSE,NO,) CALLER ALREADY HAD SALLOC LOCK*/
         LTR   R13,R13             WAS SALLOC LOCK ALREADY HELD
         BNZ   NORLSE              YES - NO RELEASE
*/* S SETLOCK: RELEASE SALLOC LOCK*/
LK7      SETLOCK RELEASE,TYPE=SALLOC,RELATED=LK6
*/*NORLSE: P SET UP XMPOST SRB FIELDS*/
NORLSE   LR    XRRETURN,XRSCRTCH   RESET RETURN REG
         XC    SRBSECT(SRBSIZE),SRBSECT  ZERO SRB BASE
         ST    R8,SRBASCB          TARGET ADDR SPC
         LA    XRSCRTCH,SRBPOST    ADDR OF EP
         LA    XRWORK,SPOST        RMTR ADDR
         STM   XRSCRTCH,XRWORK,SRBEP  SET EP AND RMTR
QK18Z    L     XRWORK,PSATOLD      GET CURRENT TCB ADDR
         LH    XRSCRTCH,ASCBASID   CURRENT ASID
         LTR   XRWORK,XRWORK       TEST FOR TCB MODE
         BNZ   MODETCB             IF NOT ZERO, TCBMODE
         L     XRWORK,PSALCCAV     ADDR OF LCCA
         LM    XRSCRTCH,XRWORK,LCCASRBF-LCCA(XRWORK)  SRB'S ASID/TCB
MODETCB  STM   XRSCRTCH,XRWORK,SRBFLC  SET FIELDS
         STM   R5,R6,XMECB         SET ECB,ERRET ADDRS
         NI    XMECB,RECBWTF       TURN OFF HI BIT
         ST    R10,XMCCODE         SET POST CODE
         STC   R0,XMECBKEY         SET ECBKEY FOR VAL CHECK    @ZA15373
         ST    XRASCB,XMASCB       SAVE ORIG ASCB ADDR
         LA    XRWORK,SRBEND       ADDR OF PARMS
         ST    XRWORK,SRBPARM      SET PARM POINTER
         LR    XRWORK,R15          SAVE REG OVER SCHEDULE
         DROP  R1,R15
         USING IGC002+2,XRWORK
*/* S SCHEDULE: SRB TO TARGET A.S. EP=SRBPOST*/
QK19Z    SCHEDULE SRB=(1),SCOPE=LOCAL
*/* D (YES,XMP00,NO,) SVC OR BR CALLER W/O LOCAL LOCK */
QK20Z    LTR   XRRETURN,XRRETURN   TEST FOR SVC ENTRY
         BPR   XRRETURN            RETURN IF SVC
*/* D (NO,,YES,XMPLKH) LOCAL LOCK HELD */
QK21Z    SETLOCK TEST,TYPE=LOCAL,BRANCH=(HELD,XMPLKH)
*/* R RETURN ON REG 14*/
         BR    XRRETURN            RETURN IF REGS NOT SAVED
*/*XMPLKH: D (YES,EXTSAVE,NO,) EXTENDED SAVE AREA IN USE */
XMPLKH   TM    LSAFLGS-LSA(R9),EXTSA   EXT SA IN USE           @Z40EPVD
         BO    EXTSAVE             YES, RESET FROM EXT SA      @Z40EPVD
*/* P RESTORE REGS 0-9 */
         LM    R0,R9,0(R9)         RESTORE REGS
*/* XMP00: R  RETURN ON REG 14 */
XMP00    BR    XRRETURN            RETURN
*/*EXTSAVE: P (,RESTALL) RESET BASE REG FOR LOCAL SAVE AREA */
EXTSAVE  LR    XRSAVE,R9           RESET DATA REG              @Z40EPVD
         B     RESTALL             GO RESTORE REGS             @Z40EPVD
         DROP  XRWORK
         EJECT
         USING *,R15
*/* E SRBPOST*/
*/* P SET REG 14 POSITIVE FOR XMPOST SW*/
SRBPOST  LA    R10,0(,R14)         POSITIVE RETURN ADDRESS     @ZA15373
*/* S SETLOCK: OBTAIN LOCAL LOCK*/
LK10     SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,RELATED=(LK5,LK16)
*/* P FIND LOCAL SAVE AREA- SAVE REGS*/
QPFYZ    L     XRASCB,PSAAOLD      CURRENT ASCB
         L     XRSAVE,ASCBASXB     ASXB ADDR
         L     XRSAVE,ASXBSPSA-ASXB(,XRSAVE) WSA TABLE
         L     XRSAVE,WSALPOST-WSAL(,XRSAVE) POST WSA
         ST    R0,0(XRSAVE)        STASH SRB ADDR
         LR    R14,R10             RESTORE R14 WITH POS ADDR   @ZA15373
         LA    R1,SRBFRR           FRR ADDRESS
*/* S SETFRR: ESTABLISH XMPOST FRR*/
QJ14Z    SETFRR A,FRRAD=(R1),WRKREGS=(XRWORK,XRSCRTCH)
*/* P SET UP MAINLINE REGS*/                                   @ZA15373
         L     XRBASE,BASE         COMMON ADDRESSABILITY POINT
         USING IGC002+2,XRBASE
         LR    XRWORK,R0           ADDR OF SRB
         L     XRECB,XMECB-SRBSECT(XRWORK) GET ECB ADDR FOR POST
         L     XRPTCODE,XMCCODE-SRBSECT(XRWORK)  POST CODE
*/* D (YES,,NO,ECBCHECK) ECBKEY OPTION SPECIFIED*/             @ZA15373
ECBVALCK LTR   XRPTCODE,XRPTCODE   TEST ECBKEY OPTION          @ZA15373
         BNM   ECBCHECK            NOT REQ, ENTER IEAVPT01     @ZA15373
         SPACE 2
*        CODE TO SUPPORT ECBKEY OPTION FOR XMPST REQUESTS.     @ZA15373
*        ECB WILL BE VALIDITY CHECKED WITH ECBKEY ONLY WHEN    @ZA15373
*        THE ECB HAS NOT BEEN WAITED ON. (NORMAL VALIDITY      @ZA15373
*        CHECK IS DONE OTHERWISE).                             @ZA15373
         SPACE 1
*/* D (YES,EVN3,NO,) ECB WAITED ON */                          @ZA15373
         TM    ZERO(XRECB),ECBWAIT CHECK FOR WAITING ECB       @ZA15373
         BO    EVN3                WAITING, ENTER IEAVPT01     @ZA15373
*/* P GET ECBKEY FROM XMPOST SRB*/                             @ZA15373
         IC    R4,XMECBKEY-SRBSECT(,R3) GET ECBKEY FROM SRB    @ZA15373
*/* P SET UP INTERFACE TO IEAVEVAL TO VAL CHK ECB*/            @ZA15373
         O     R4,TIDBIT           INDICATE KEY, NOT TCB       @ZA15373
         LR    R1,XRECB            ADDRESS OF ECB AND          @ZA15373
         LA    R2,L3(,XRECB)       END ADDR FOR IEAVEVAL       @ZA15373
         LR    R12,R15             SAVE BASE REG 15            @ZA15373
         L     R15,CHECK           ENTER AT IEA0VL01           @ZA15373
*/* S IEA0VL01: CALL IEAVEVAL */                               @ZA15373
         BALR  R14,R15             CALL IEAVEVAL               @ZA15373
         LR    R15,R12             RESTORE BASE REG 15         @ZA15373
         LR    R14,R10             RESTORE POS RETURN REG      @ZA15373
*/* D (FAIL,ERROR1,PASS,RBCHECK)   RESULTS OF VAL CHK*/        @ZA33186
         BNZ   ERROR1              FAIL VAL CHK, ABEND         @ZA15373
*        BRANCH TO RBCHECK INSTEAD OF POSTTEST, IN CASE AN ECB @ZA33186
*        WHOSE TWO HIGH ORDER BITS HAD INITIALLY BEEN ZERO     @ZA33186
*        HAS BEEN INITIALIZED TO POINT TO AN ECB EXTENSION.    @ZA33186
         B     RBCHECK             ECBVALID, ENTER PT01        @ZA33186
*/* POST: END */
         EJECT
*/* POSTR: CHART */
         USING *,15
*/* E SPOST*/
*/* P SET UP ADDRESSABILITY TO POST CODE*/                     @ZA15373
SPOST    L     XRBASE,BASE          COMMON ADDRESSABILITY      @ZA15373
         USING IGC002+2,XRBASE      POINT FOR POST CODE        @ZA15373
*/* P PICK UP POST PARMS FROM XMPOST SRB*/                     @ZA15373
         LR    R3,R1                SAVE SRB ADDR              @ZA15373
         USING SRBSECT,R3                                      @ZA15373
         LR    R8,R14               SAVE RETURN ADDR           @ZA15373
*/* D (YES,,NO,NOPOST) TASK TERM; IE ASCBS MATCH */
Q45      L     R7,PSAAOLD           GET CURRENT ASCB ADDR      @YM01534
         CL    R7,SRBASCB           COMPARE TO ASCB ADDR IN SRB@YM01534
         BNE   NOPOST               DONT POST IF MEM TERM      @YM01534
*/* D (YES,SPRESCH,NO,) IS THIS AN ERRET SRB */
         LA    R5,ERRET             GET POSTS ERRET ADDR       @YM01534
         CL    R5,SRBEP             COMPARE TO ENTRY POINT     @YM01534
         BE    SPRESCH              BR IF ERRET TO RESCHEDULE  @YM01534
*/* S SETLOCK: OBTAIN LOCAL LOCK */
SPQ1     SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,RELATED=(SPQ2,QK16)
*/* S SETFRR: SET FRR COVERAGE FOR LOCAL POST */
         LA    R1,SPOSTFRR          SET ADDR OF FRR RTN        @YM01534
QSP0     SETFRR A,FRRAD=(R1),WRKREGS=(R11,R12),PARMAD=(R10)    @YM01534
*/* P SET PARM AREA FOR POSSIBLE FRR ENTRY */
         ST    R3,SRBSV(,R10)       SET SAVED SRB ADDR         @YM01534
         ST    R8,SPOSTRT(,R10)     SET SAVED RETR ADDR        @ZA15373
*/* P SET UP INTERFACE FOR BRANCH ENTRY TO IEAVPT01*/          @ZA15373
         L     R10,XMCCODE          SET COMPLETION CODE        @ZA15373
         L     R11,XMECB            SET ADDR OF ECB            @ZA15373
*/* D (YES,,NO,GOXMPOST) WAS ECBKEY OPTION IN EFFECT*/         @ZA15373
         LTR   R10,R10              TEST ECBKEY OPTION         @ZA15373
         BNM   GOXMPOST             NOT REQ, GO COMPLETE XMPOST@ZA15373
*/* D (YES,GOXMPOST,NO,) ECB WAITED ON*/                       @ZA15373
         TM    ZERO(R11),ECBWTFLG   CHK IF ECB WAITING         @ZA15373
         BO    GOXMPOST             WAITING, GO COMPLETE XMPOST@ZA15373
*/* P GET ECBKEY FROM XMPOST SRB*/                             @ZA15373
         IC    R4,XMECBKEY          GET ECBKEY FROM SRB        @ZA15373
*/* P SET UP INTERFACE TO IEAVEVAL TO VAL CHK ECB*/            @ZA15373
         O     R4,TIDBIT           INDICATE KEY, NOT TCB       @ZA15373
         LR    R1,R11               ADDR OF ECB AND            @ZA15373
         LA    R2,L3(,R11)          END ADDR FOR IEAVEVAL      @ZA15373
         LR    R12,R15              SAVE BASE REG 15           @ZA15373
         L     R15,CHECK            ENTER AT IEAOVL01          @ZA15373
*/* S IEA0VL01: CALL IEAVEVAL*/                                @ZA15373
         BALR  R14,R15              CALL IEAVEVAL              @ZA15373
         LR    R15,R12              RESTORE BASE REG 15        @ZA15373
*/* D (FAIL,ERROR1,PASS,) RESULTS OF VAL CHK */                @ZA15373
         BNZ   ERROR1               FAIL VAL CHK, ABEND        @ZA15373
*/*GOXMPOST: S IEA0PT01: ENTER TO COMPLETE XMPOST*/            @ZA15373
GOXMPOST L     R15,ADDRPT01         GET ADDR OF BR ENTRY       @ZA15373
         BALR  R14,R15              CALL IEAVPT01              @ZA15373
         SPACE 2
*        NOTE: BASE REG 15 IS STILL VALID ON RETURN FROM       @ZA15373
*        IEAVPT01 (IEAVPT01 ESTABLISHES ADDRESSABILITY BY      @ZA15373
*        REG 15 FROM IGC002+2 ALSO).                           @ZA15373
         SPACE 1
*/*SPFRRT: S SETFRR:  DELETE FRR COVERAGE  */
SPFRRT   SETFRR D,WRKREGS=(R11,R12)                            @YM01534
*/* S SETLOCK: RELEASE LOCAL LOCK */
SPQ2     SETLOCK RELEASE,TYPE=LOCAL,RELATED=(SPQ1)             @YM01534
SPQG     L     R7,PSAAOLD           GET ADDR OF ASCB           @YM01534
*/*NOPOST: S SETLOCK: OBTAIN SALLOC LOCK*/
NOPOST   DS    0H                                              @ZA10133
LK11     SETLOCK OBTAIN,TYPE=SALLOC,MODE=UNCOND,RELATED=(LK12,LK012)
*/* D (YES,SPSTGONE,NO,) ORIG ASCB HAS GONE AWAY*/
         L     R4,XMPQ              XMPOST SRB CHAIN FLD
         LTR   R4,R4                SRBS ARE ORPHANS
         BM    SPSTGONE             BR IF ORIG ASCB GONE
         L     XRSCRTCH,XMASCB      ORIG ASCB ADDR
         LA    XRSCRTCH,ASCBXMPQ-ASCB(XRSCRTCH) ADDR OF CHAIN HEADER
*/*SPSTLOOP: D (YES,SPSTDEQ,NO,) THIS IS OUR SRB*/
SPSTLOOP C     R3,0(XRSCRTCH)       IS THIS OUR SRB
         BE    SPSTDEQ              BR IF SO
*/* P (,SPSTLOOP) GET NEXT SRB*/
         L     XRSCRTCH,0(XRSCRTCH) GET TO NEXT SRB
         LA    XRSCRTCH,XMPQ-SRBSECT(XRSCRTCH) ADDR OF NEXT CHAIN
         B     SPSTLOOP             DO IT AGAIN
*/*SPSTDEQ: P DEQ XMPOST SRB FROM ITS PARENT ASCB*/
SPSTDEQ  ST    R4,0(XRSCRTCH)       DEQ OUR SRB
*/* D (YES,SCHERRET,NO,) SRB DEQ'ED ERRET SRB */
         SR    R4,R4                ERRET SRB INDICATED BY ZERO@ZA10133
         CL    R4,SRBEP             SRB EPA SET BY SPOST FRR   @ZA10133
         BE    SCHERRET             GO SCHED SRB IF ERRET      @ZA10133
*/*SPSTGONE: P PUT XMPOST SRB BACK ON CHAIN*/
SPSTGONE L     R13,CHAINHD          GETCHAIN HEADER            @YM02663
         ST    R13,ZERO(,R3)        SAVE OLD CHAIN PTR IN THIS @ZA10133
*                                   SRBS POINTER FIELD         @YM02663
         ST    R3,CHAINHD           CHAIN THIS SRB TO TOP      @ZA10133
*/* S SETLOCK: RELEASE SALLOC LOCK*/
LK12     SETLOCK RELEASE,TYPE=SALLOC,RELATED=LK11
*/*SPRT: R RETURN TO PURGEDQ*/
         BR    R8                   RETURN                     @ZA15373
         SPACE 2
*/*SCHERRET: P INIT SRB TO SCHEDULE POST ERRET IN USER ASCB */
SCHERRET DS    0H                                              @ZA10133
         LA    XRSCRTCH,ERRET       ERRET ADDR                 @YM01534
         ST    XRSCRTCH,SRBEP       ENTRY POINT                @YM01534
         MVC   SRBASCB,XMASCB       ADDR OF ORIGINATING ASCB   @YM01534
         ST    XRASCB,XMASCB        SAVE FAILING ASCB ADDR     @YM01534
*/* S SETLOCK: RELEASE SALLOC */
LK012    SETLOCK RELEASE,TYPE=SALLOC,RELATED=LK11              @ZA10133
         SPACE 2
*/*SPRESCH: S (,SPRT) SCHEDULE: RESCHEDULE ERRET SRB */
         DROP  R15
SPRESCH  LR    R1,R3                SET REG                    @YM01534
         BALR  R4,R0                NEW ADDRESSABLIITY
         USING *,R4                 NEW BASE
         SCHEDULE SRB=(1),SCOPE=LOCAL                          @YM01534
         BR    R8                   RETURN                     @ZA15373
         DROP  R3
         DROP  R4
*/*ERROR1: P SET ABEND CODE TO 102 */                          @ZA15373
*/* R ABEND */                                                 @ZA15373
         EJECT
         USING *,15
*/* E IEARPOST*/
IEARPOST STM   R14,R12,C12(R13)     SAVE REGS
*/* D (MEM,RMEMTERM,TASK,) TYPE TERMINATION */
         L     R1,0(,R1)            GET ADDR OF RMPL           @YM01534
         USING RMPL,R1                                         @YM01534
         TM    RMPLFLG1,RMPLTERM    TEST TYPE TERMINATION      @YM01534
         BO    RMEMTERM             BR IF MEM TERM             @YM01534
*/* S (,RPRETR) PURGEDQ: PURGE ALL INCOMING XMPOST AND ERRET SRBS*/
QSZ17    PURGEDQ MF=(E,IEASPOST)  CLEAR XMPOST SRBS COMING HERE
         BALR  R15,R0               SET UP BASE                @YM01534
         USING *,R15                                           @YM01534
         B     RPRETR               GO TO RETURN               @YM01534
*/*RMEMTERM: P SET UP TO CLEANUP POSTS XMPQ */
RMEMTERM BALR  R15,R0               RESET BASE
         USING *,R15
         LR    R4,R13               SAVE SAVE AREA REG
*/* S SETLOCK: OBTAIN SALLOC LOCK*/
LK13     SETLOCK OBTAIN,TYPE=SALLOC,MODE=UNCOND,RELATED=RPSTEND
*/* P ZERO Q HEADER FOR XMPOST SRBS FROM THIS A.S.*/
         L     R7,RMPLASCB          GET TERMINATING ASCB ADDR  @YM01534
         L     R2,ASCBXMPQ          GET XMPOST SRB Q ANCHOR
         XC    ASCBXMPQ,ASCBXMPQ    ZERO IT
         USING SRBSECT,R1           SRB BASE
*/*RPSTLOOP: D (YES,RPSTEND,NO,) Q IS EMPTY*/
RPSTLOOP LTR   R1,R2                TEST FOR EMPTY Q
         BZ    RPSTEND              BR IF SO
*/* P SET FLAG IN EACH SRB INDICATING ORIG ASCB HAS GONE AWAY*/
         L     R2,XMPQ              GET Q CHAIN ADDR
         OI    XMPQ,LSTIND          INDICATE SRB IS ADRIFT
         B     RPSTLOOP             LOOP
*/*RPSTEND: S SETLOCK: RELEASE SALLOC LOCK*/
RPSTEND  SETLOCK RELEASE,TYPE=SALLOC,RELATED=LK13
*/*RPRETR: R RETURN*/
         LR    R13,R4               RESET SAVE AREA ADDR
RPRETR   LM    R14,R12,C12(R13)     RESTORE REGS               @YM01534
         SR    R15,R15              CLEAR CONDITION CODE       @YM01534
         BR    R14                  RETURN
         DROP  R1                   DROP RMPL ADDRESSABILITY
         EJECT
IEASPOST PURGEDQ RMTR=SPOST,MF=L,ASIDTCB=DBLZERO LST FOR SPOST @YM01534
         DS    0D                   ALIGHN                     @YM01534
DBLZERO  DC    2F'0'                PARM FOR SPOST MACRO       @YM01534
         EJECT
*/*SPOSTFRR: E FRR FOR SPOST */
         DROP  R15
*/* S SETRP: RETRY TO SCHEDULE ERRET */
         USING *,R4
         USING SDWA,R1
SPOSTFRR L     XRSAVE,SDWAPARM      GET PARM AREA ADDR         @YM01534
         L     R3,SRBSV(,XRSAVE)    GET SRB ADDR               @YM01534
         LR    R4,R15               SET BASE REG               @YM01534
         ST    R3,SDWASR03          SET IN REGISTER AREA       @YM01534
         L     R3,SPOSTRT(,XRSAVE)  GET RETURN ADDRESS         @YM01534
         ST    R3,SDWASR08          SAVE IN REGISTER AREA      @ZA15373
         L     R3,PSAAOLD           GET ASCB ADDR              @YM01534
         ST    R3,SDWASR07          SET IN RETRY REG 7         @YM01534
         SETRP RETADDR=SPOSTFR0,RC=4,RETREGS=YES,              @YM01534X
               RECPARM=POSTRPRM                                @YM01534
*/* R BACK TO RTM */
         BR    R14                  RETURN                     @YM01534
         DROP  R4
         SPACE 3
*/* E SPOST RETRY  */
*/*SPOSTFR0: N SCHEDULE ERRET BACK TO CALLER */
SPOSTFR0 BALR  R15,R0               BOOTSTRAP ADDRESSABILITY   @YM01534
         USING *,R15                ASSUME NOTHING ABOUT REGS  @YM01534
         L     R15,BASE             COMMON ADDRESSABILITY      @ZA15373
         USING IGC002+2,XRBASE      POINT FOR POST CODE        @ZA15373
*/* P (,SPFRRT) INDICATE SRB TO BE SCHEDULED FOR POST ERRET */
         USING SRB,R3
         SR    R4,R4                ERRET INDICATOR IS         @ZA10133
         ST    R4,SRBEP             ZERO SRB EPA               @ZA10133
         B     SPFRRT               GO TO SCHEDULE ERRET SRB   @ZA10133
         DROP  R3
         EJECT
         USING *,R4
*/* E SRBFRR*/
*/* S SETRP: SPECIFY RETRY AT SRBRETRY*/
SRBFRR   LR    R4,R15              SET BASE
         L     R3,SDWAABCC-SDWA(,R1)   GET ABEND CODE          @Y30HPVA
         ST    R3,SDWASR10-SDWA(,R1)   STORE SYSTEM COMPLETION CODE
*                                      TO PASS TO ERRET        @Y30HPVA
         SETRP RETADDR=SRBRETRY,RC=4,RECPARM=POSTRPRM RETRY FOR ERROR
*/* R RETURN*/
         BR    R14                 BACK TO RTM-WILL SEE YOU AT SRBRETRY
         DROP  R4
         SPACE 3
*/* E SRBRETRY*/
*/* P BOOTSTRAP ALL ENVIRONMENTAL REGS*/
SRBRETRY BALR  R15,R0              BOOTSTRAP ADDRESSABILITY
         USING *,R15               ASSUME NOTHING ABOUT REGS
         L     XRASCB,PSAAOLD      CURRENT ASCB
         L     XRSAVE,ASCBASXB     ASXB ADDR
         L     XRSAVE,ASXBSPSA-ASXB(,XRSAVE) WSA TABLE
         L     XRSAVE,WSALPOST-WSAL(,XRSAVE) POST WSA
         L     R1,0(XRSAVE)        RELOAD SRB ADDR
         LR    R8,XRSAVE           SAVE SAVE AREA POINTER
         USING SRBSECT,R1
*/* S SETLOCK: OBTAIN SALLOC LOCK*/
LK14     SETLOCK OBTAIN,TYPE=SALLOC,MODE=UNCOND,RELATED=(LK15,RLK14)
*/* D (YES,RTRYGONE,NO,) ORIG ASCB HAS GONE AWAY*/
         L     R3,XMPQ             XMPOST SRB CHAIN FLD
         LTR   R3,R3               SRBS ARE ORPHANS
         BM    RTRYGONE            BR IF ORIG ASCB GONE
         L     R4,XMASCB           ORIG ASCB ADDR
         LA    R4,ASCBXMPQ-ASCB(,R4) ADDR OF CHAIN HEADER
*/*RTRYLOOP: D (YES,RTRYDEQ,NO,) THIS IS OUR SRB*/
RTRYLOOP C     R1,0(,R4)           IS THIS OUR SRB
         BE    RTRYDEQ             BR IF SO
*/* P (,RTRYLOOP) GET NEXT SRB*/
         L     R4,ZERO(,R4)        GET TO NEXT SRB
         LA    R4,XMPQ-SRBSECT(,R4) ADDR OF NEXT CHAIN
         B     RTRYLOOP            DO IT AGAIN
*/*RTRYGONE: P PUT XMPOST SRB BACK ON CHAIN*/
RTRYGONE L     R13,CHAINHD         GETCHAIN HEADER             @YM02663
         ST    R13,ZERO(,R1)       SAVE OLD CHAIN PTR IN THIS  @YM02663
*                                  SRBS POINTER FIELD          @YM02663
         ST    R1,CHAINHD          PUT THIS SRB IN CHAIN AS TOP@YM02663
*/* S SETLOCK: RELEASE SALLOC LOCK*/
LK15     SETLOCK RELEASE,TYPE=SALLOC,RELATED=LK14
*/* S SDUMP: DUMP SQA AND LSQA */
         LH    R4,ASCBASID         GET ASID
         LR    R13,R8              SET SAVE AREA ADDR
SDU5C    SDUMP HDRAD=POSTHDRL,                                         X
               ASID=(R4),SDATA=(TRT,SQA,LSQA),BRANCH=YES
*/* S SETLOCK: RELEASE LOCAL LOCK */                           @YA02708
LK19     SETLOCK RELEASE,TYPE=LOCAL,RELATED=LK10               @YA02708
*/* R SRB EXIT*/
         L     R14,CVTPTR          GET ADDR OF CVT             @YM02645
         L     R14,CVTSRBRT-CVTMAP(,R14) GET ADDR OF DISP      @YM02645
         BR    R14                 RETURN TO DISP              @YM02645
*/*RTRYDEQ: P DEQ XMPOST SRB FROM ITS PARENT ASCB*/
RTRYDEQ  ST    R3,0(,R4)           DEQ OUR SRB
*/* S SETLOCK: RELEASE SALLOC LOCK*/
RLK14    SETLOCK RELEASE,TYPE=SALLOC,RELATED=LK14
*/* P SET UP SRB FOR SCHEDULE TO ERRET*/
         LA    XRWORK,ERRET
         ST    XRWORK,SRBEP        ENTRY POINT
         MVC   SRBASCB,XMASCB      ADDR OF ORIGINATING ASCB
         ST    XRASCB,XMASCB       SAVE FAILING ASCB ADDR
         ST    R10,XMPQ            PASS SYS COMP CODE          @Y30HPVA
*/* S SCHEDULE: SRB TO USERS ERRET*/
         DROP  R15
         BALR  R4,R0               SET NEW BASE
         USING *,R4                USE NEW BASE
         SCHEDULE SRB=(1),SCOPE=LOCAL
*/* S SETFRR: DELETE XMPOST SRB FRR*/
         SETFRR D,WRKREGS=(XRWORK,XRSCRTCH)  DELETE FRR
*/* S SETLOCK: RELEASE LOCAL LOCK*/
LK16     SETLOCK RELEASE,TYPE=LOCAL,RELATED=LK10
*/* R SRB EXIT*/
         L     R14,CVTPTR          ADDR OF CVT
         L     R14,CVTSRBRT-CVTMAP(,R14) SRB EXIT TO DISP
         BR    R14                 NEXT STOP, ERRET IN ORIG ADDR SPACE
         DROP  R4
         SPACE 3
         USING *,R15
*/* E ERRET*/
*/* P PICK UP XMPOST PARMS FROM SRB*/
ERRET    LR    R1,R0               ADDR OF SRB
         LR    R5,R14              SAVE R14 ACROSS FM
         LM    R6,R10,SRBEND       SAVE PARMS                  @Y30HPVA
*/* S SETLOCK: OBTAIN SALLOC LOCK*/
LK17     SETLOCK OBTAIN,TYPE=SALLOC,MODE=UNCOND,RELATED=LK18
*/* P PUT XMPOST SRB BACK ON CHAIN*/
         L     R13,CHAINHD         GETCHAIN HEADER             @YM02663
         ST    R13,ZERO(,R1)       SAVE OLD CHAIN PTR IN THIS  @YM02663
*                                  SRBS POINTER FIELD          @YM02663
         ST    R1,CHAINHD          PUT THIS SRB IN CHAIN AS TOP@YM02663
*/* S SETLOCK: RELEASE SALLOC LOCK*/
LK18     SETLOCK RELEASE,TYPE=SALLOC,RELATED=LK17
*/* P SET UP REGS FOR ENTRY TO USERS ERRET*/
         LR    R1,R6               ASCB ADDR
         LR    R0,R7               ECB ADDR
         LR    R14,R5              DISPATCHER SRB EXIT ADDR
         LR    R2,R9               CCODE
         LR    R3,R10              SYSTEM COMP CODE            @Y30HPVA
         LR    R15,R8              ERRET ADDR
*/* R REG 15*/
         BR    R15                 TO USER ERRET
         EJECT
         USING *,R4                                            @Y30HPVA
*/* E EVNTFRR */
EVNTFRR  LR    R4,R15              SET BASE                    @Y30HPVA
         LR    R5,R14              SAVE RTM RETURN ADDRESS     @ZA20188
*/* P CHANGE COMPLETION CODE TO 402 ABEND */
*/* S SETRP: PERCOLATE TO CALLER */
         SETRP RECORD=NO,RC=0,COMPCOD=(X'402',SYSTEM),DUMP=YES @Y30HPVA
*/* R RETURN */
         LR    R14,R5              RESTORE RTM RETURN ADDRESS  @ZA20188
         BR    R14                 BACK TO RTM                 @Y30HPVA
         DROP  R4                                              @Y30HPVA
         EJECT
CHECK    DC    A(IEA0VL01)         ADDRESS OF VALIDITY CHECK
ADDRPT01 DC    A(IEA0PT01)         ADDR OF POST BR ENTRY       @YM01534
DISPTCHR DC    A(IEA0DS)           ADDR OF DISPATCHER
BASE     DC    A(IGC002+2)         POST BASE
BASEWT   DC    A(WAITBAS)          WAIT BASE                       MTS0
POSTHDRL DC    AL1(PSTMSE-POSTRPRM)  LENGTH OF SDUMP HEADER
POSTRPRM DC    CL8'IEAVSY50'       MODULE NAME FOR RECPARM
         DC    CL8'IGC001'         CSECT NAME FOR RECPARM
         DC    CL8'IGC002'         POST AS FRR NAME
         DC    C'XMPOST FAIL-NO ERRET'   MSG FOR SDUMP
PSTMSE   EQU   *                   LABEL FOR SETUP OF ADCON
CHAINHD  DC    F'0'                CHAIN HEADER FOR XMPOST SRBS@YM02663
RBVALID  DC    X'0000000F'         USED TO ZERO ALL BUT LAST 4 BITS
WPRBPREL DC    AL4(RBPRFXND-RBPREFIX)    LENGTH OF RB PREFIX
OFFWAIT  DC    XL4'7FFFFFFF'       MASK TO SET OFF WAIT BIT
ONCOMPL  DC    XL4'40000000'       MASK TO T
ABND402  DC    XL4'80402000'       ABEND CODE 402              @Y30HPVA
ABND502  DC    XL4'80502000'       ABEND CODE 502              @Y30HPVA
ABND702  DC    XL4'80702000'       ABEND CODE 702              @Z40EPVD
PXITCODE DC    XL4'01000000'       POST EXIT FUNCTION CODE     @Z40EPVD
TIDBIT   DC    X'80000000'         WORD WITH HIGH ORDER BIT
ERRORFLG DC    X'80'               TO TELL ABEND TO DUMP
WOS      DS    X                   WRITE-ONLY-STORAGE FOR STNSM
         EJECT
*     EXECBFRR - RECOVERY FOR POST EXIT FUNCTION
         SPACE 2
*/* E EXECBFRR*/
EXECBFRR EQU   *                        POST EXIT RECOVERY     @Z40EPVD
         BALR  R12,ZERO                 ESTABLISH BASE REG     @Z40EPVD
         USING *,R12                    ESTAB ADDRESSABILITY   @Z40EPVD
*/* D (NO,NOTREF,YES,) LSQA REFERENCEABLE*/
         ICM   R0,M0011,SDWAFMID-SDWA(R1) LSQA REFERENCEABLE   @Z40EPVD
         BNZ   NOTREF                   NO, SKIP PROCESSING    @Z40EPVD
*/* D (YES,SURPRISE,NO,) WAS ERROR EXPECTED*/
         L     R5,SDWAPARM-SDWA(R1)     GET FRR WORK AREA      @Z40EPVD
         L     R6,ZERO(R5)              GET FAILURE CODE       @Z40EPVD
         LTR   R6,R6                    ZERO REASON CODE       @Z40EPVD
         BZ    SURPRISE                 YES, ERROR NOT EXPTD   @Z40EPVD
*/* P SET FAILURE REASON CODE*/
         ST    R6,SDWAGR15-SDWA(R1)     SET RC IN SDWA         @Z40EPVD
*/* S SETRP: NO RECORD, DUMP, 702 ABEND CODE, PERC*/
         LR    R6,R14                   SAVE RETURN ADDR       @ZM40133
         SETRP RECORD=NO,RC=0,COMPCOD=(X'702',SYSTEM),DUMP=YES @Z40EPVD
*/* R RETURN*/
         LR    R14,R6                   RESET RETURN ADDR      @ZM40133
         BR    R14                      RETURN TO RTM          @Z40EPVD
*/*SURPRISE: P PRIME SDWA WITH PERTINENT DATA */
SURPRISE EQU   *                        UNEXPECTED ERROR       @Z40EPVD
*        ALTHOUGH A CHANGE WAS MADE TO SAVE REGS 12 AND 13,    @ZA30491
*        THOSE REGISTERS WOULD NOT BE USEFUL IF SAVED IN THE   @ZA30491
*        VRA. (THEY CONTAIN USER DATA WHICH IS MEANINGLESS TO  @ZA30491
*        POST.) THEREFORE, NO CHANGE WAS MADE HERE IN THE FRR. @ZA30491
         L     XRSAVE,PSAAOLD           CURRENT ASCB           @Z40EPVD
         L     XRSAVE,ASCBASXB-ASCB(XRSAVE) ASXB ADDR          @Z40EPVD
         L     XRSAVE,ASXBSPSA-ASXB(,XRSAVE) LOCAL WSAVT ADDR  @Z40EPVD
         L     XRSAVE,WSALPOST-WSAL(,XRSAVE) POST WSA ADDR     @Z40EPVD
         OI    SDWADPVA-SDWA(R1),SDWAHEX VRA CONTAINS HEX DATA @Z40EPVD
         SR    R5,R5                     ZERO WORK REG         @Z40EPVD
         IC    R5,SDWAURAL-SDWA(R1)      GET USED VRA          @Z40EPVD
         LA    R6,LSAEND-LSAPEXIT(,R0)   SIZE OF DATA          @Z40EPVD
         ICM   R7,M0011,SDWAVRAL-SDWA(R1) POSSIBLE SIZE        @Z40EPVD
         CR    R5,R7                     VRA FULL              @Z40EPVD
         BE    SAVENONE                  YES, SKIP SAVE        @Z40EPVD
         SR    R7,R5                     AVAILABLE SIZE        @Z40EPVD
         CR    R6,R7                     WILL MAX DATA FIT     @Z40EPVD
         BH    STORESUM                  NO, GO STORE SOME     @Z40EPVD
         EX    R6,MVC4FRR                MOVE DATA TO VRA      @Z40EPVD
         AR    R5,R6                     UPDATE USED SIZE      @Z40EPVD
         B     SAVEIT                    GO SAVE IT            @Z40EPVD
STORESUM EQU   *                         STORE MAX POSSIBLE    @Z40EPVD
         LR    R2,R1                     SAVE SDWA ADDR        @Z40EPVD
         LA    R1,ZERO(R5,R1)            RESET REG1 - EX INST  @Z40EPVD
         EX    R7,MVC4FRR                PUT DATA IN VRA       @Z40EPVD
         LR    R1,R2                     RESET SDWA ADDR       @Z40EPVD
         AR    R5,R7                     UPDATE SIZE USED      @Z40EPVD
SAVEIT   EQU   *                         SAVE SIZE USED        @Z40EPVD
         STC   R5,SDWAURAL-SDWA(R1)      DITTO                 @Z40EPVD
*/* P CLEAR TEMP AND EXT SAVE AREA IN USE FLAGS */
SAVENONE EQU   *                         VRA FULL LABEL        @Z40EPVD
         NI    LSAFLGS-LSA(XRSAVE),XFF-EXTSA-PEXITSA  NOT USED @Z40EPVD
*/*NOTREF: S SETRP: RECORD, DUMP, PERC*/
NOTREF   EQU   *                         PREPARE TO EXIT       @Z40EPVD
         SETRP RECORD=YES,RC=0,DUMP=YES,RECPARM=MODCID         @Z40EPVD
*/* R RETURN*/
         BR    R14                       RETURN TO RTM         @Z40EPVD
MVC4FRR  MVC   SDWAVRA-SDWA(1,R1),LSAPEXIT-LSA(XRSAVE) SAVE    @Z40EPVD
MODCID   DC    CL24'IGC001  IGC002  EXECBFRR' MOD CSECT FRR ID @Z40EPVD
         DROP  R12                       DROP BASE
*/* POSTR: END*/
         EJECT
*/*EXITCD: CHART*/
*     ENTRY POINT - IEA0PT0E                                   @Z40EPVD
         SPACE
IEA0PT0E EQU   *                         IDENTIFY/DELETE EXITS @Z40EPVD
         USING *,XRBASE                                        @Z40EPVD
*/* E IEA0PT0E*/
*    IEA0PT0E - IDENTIFIES/DELETES POST EXIT ROUTINE ADDRESSES @Z40EPVD
*               FROM THE POST EXIT ROUTINE QUEUE (ASXBPT0E)    @Z40EPVD
         SPACE
*               REGISTER USAGE                                 @Z40EPVD
*                 0 - FUNCTION CODE AND GET FREE LENGTH        @Z40EPVD
*                 1,11 - POST EXIT ROUTINE ADDR                @Z40EPVD
*                 3,6 - WORK REGS                              @Z40EPVD
*                 4 - TCB ADDRESS                              @Z40EPVD
*                 7 - ASCB ADDRESS                             @Z40EPVD
*                 8 - ASXB ADDRESS                             @Z40EPVD
*                 9 - POST EXIT QUEUE HEADER OR ACTIVE BLOCK   @Z40EPVD
*                 12 - BASE REG                                @Z40EPVD
*                 13 - POST WSA ADDRESS                        @Z40EPVD
*                 14,15 - GETMAIN/FREEMAIN INTERFACE REGS      @Z40EPVD
         SPACE 2
*/* P GET ADDRESS OF LOCAL SAVE AREA - SAVE REGS*/
         L     XRBASE,PSAAOLD           CURRENT ASCB ADDR      @Z40EPVD
         L     XRBASE,ASCBASXB-ASCB(,XRBASE) ASXB ADDR         @Z40EPVD
         L     XRBASE,ASXBSPSA-ASXB(,XRBASE) LOCAL WSAVT ADDR  @Z40EPVD
         L     XRBASE,WSALPOST-WSAL(,XRBASE) POST WSA ADDR     @Z40EPVD
         STM   R0,R14,LSAMAIN-LSA(XRBASE) SAVE CALLERS REGS    @Z40EPVD
         LR    R13,XRBASE               RETAIN WSA ADDR        @Z40EPVD
         BALR  R12,R0                   ESTAB BASE REG         @Z40EPVD
         USING *,R12                    ESTAB ADDRESSABILITY   @Z40EPVD
*/* P INIT MAINLINE REGS*/
         L     R7,PSAAOLD               CURRENT ASCB ADDR      @Z40EPVD
         L     R8,ASCBASXB-ASCB(,R7)    ASXB ADDR              @Z40EPVD
         L     R9,ASXBPT0E-ASXB(,R8)    POST EXIT QUEUE HEADER @Z40EPVD
         LR    R11,R1                   SAVE EXIT ROUTINE ADDR @Z40EPVD
         L     R4,ASXBFTCB-ASXB(,R8)    NEED A TCB ADDR        @Z40EPVD
*/* D (YES,CREATE,NO,) EXIT CREATION REQUEST*/
         LA    R3,CCODE                 GET CREATE CODE        @Z40EPVD
         CR    R0,R3                    CREATE REQUEST         @Z40EPVD
         BE    CREATE                   YES, GO PROCESS        @Z40EPVD
*/* D (YES,DELETE,NO,) EXIT DELETION REQUEST*/
         LA    R3,DCODE                 GET DELETE CODE        @Z40EPVD
         CR    R0,R3                    DELETE REQUEST         @Z40EPVD
         BE    DELETE                   YES, GO PROCESS        @Z40EPVD
*/* P ABEND REASON CODE - 0*/
         LA    R6,RC0                   SET ABEND REASON CODE  @Z40EPVD
*/*AB702: R ABEND 702*/
AB702    EQU   *                        ABEND CALLER           @Z40EPVD
         L     R1,ABNDC702              GET 702 ABEND CODE     @Z40EPVD
         LR    R15,R6                   ESTABLISH REASON CODE  @Z40EPVD
         SVC   ABENINST                 ABEND                  @Z40EPVD
*/*CREATE: S GETMAIN: GET 8 BYTES FROM SUBPOOL 255*/
CREATE   EQU   *                        PROCESS CREATE REQUEST @Z40EPVD
         LA    R0,EIGHT                 PRIME LENGTH - 8       @Z40EPVD
         GETMAIN RU,LV=(0),SP=255,BRANCH=YES,RELATED=(GOTEXIT) @Z40EPVD
*/* P INITIALIZE EXIT ADDRESS IN BLOCK*/
         ST    R11,FOUR(R1)             INIT EXIT ADDR         @Z40EPVD
*/* P (,PT0EDONE) PLACE BLOCK ON TOP OF POST EXIT QUEUE*/
         ST    R9,ZERO(,R1)             CURRENT HEADER INTO BLK@Z40EPVD
         ST    R1,ASXBPT0E-ASXB(,R8)    POINT HEAD TO NEW BLK  @Z40EPVD
         B     PT0EDONE                 GO EXIT                @Z40EPVD
*/*DELETE: D (NO,AB702RC4,YES,) ANY MORE EXITS*/
DELETE   EQU   *                        PROCESS DELETE REQUEST @Z40EPVD
         LA    R10,ASXBPT0E-ASXB(,R8)   GET HEADER ADDR        @Z40EPVD
DELLOOP  EQU   *                        LOOP LABEL             @Z40EPVD
         LTR   R9,R9                    ANY MORE EXITS         @Z40EPVD
         BZ    AB702RC4                 NO, GO ABEND           @Z40EPVD
*/* D (YES,GOTEXIT,NO,) EXIT ADDRESSES MATCH*/
         C     R11,FOUR(R9)             EXIT ADDRESSES MATCH   @Z40EPVD
         BE    GOTEXIT                  YES, EXIT LOOP         @Z40EPVD
*/* P (,DELETE) GET ADDR OF NEXT BLOCK*/
         LR    R10,R9                   NO, SAVE CURRENT ADDR  @Z40EPVD
         L     R9,ZERO(,R9)             GET NEXT BLOCK ADDR    @Z40EPVD
         B     DELLOOP                  LOOP BACK              @Z40EPVD
*/*AB702RC4: P (,AB702) SET REASON CODE TO 4*/
AB702RC4 LA    R6,RC4                   SET RC TO 4            @Z40EPVD
         B     AB702                    GO ABEND               @Z40EPVD
*/*GOTEXIT: P REMOVE BLOCK FROM QUEUE*/
GOTEXIT  EQU   *                        FOUND BLK TO DELETE    @Z40EPVD
         L     R6,ZERO(,R9)             GET FORWARD PTR        @Z40EPVD
         ST    R6,ZERO(,R10)            CHAIN AROUND SUBJECT   @Z40EPVD
*/* S FREEMAIN: FREE BLOCK STORAGE*/
         LA    R0,EIGHT                 PRIME LENGTH - 8       @Z40EPVD
         FREEMAIN RU,LV=(0),A=(R9),SP=255,BRANCH=YES,RELATED=(CREATE)
*/*PT0EDONE: P RESTORE CALLERS REGS*/
PT0EDONE EQU   *                        EXIT CODE              @Z40EPVD
         LM    R0,R14,LSAMAIN-LSA(R13)  RESET CALLERS REGS     @Z40EPVD
*/* R RETURN*/
         BR    R14                      RETURN TO CALLER       @Z40EPVD
         SPACE
         DS    0F                       FULL WORD ALIGN        @Z40EPVD
ABNDC702 DC    XL4'80702000'            ABEND CODE 702         @Z40EPVD
*/*EXITCD: END*/
         TITLE 'IEAVSY50.. ..LOCAL.SAVE.AREA'
LSA      DSECT
LSAMAIN  DS    0F                     MAIN SAVE AREA           @Z40EPVD
         DS    16F                    NORMAL SAVE AREA         @ZA30491
LSAPEXI2 DS    0F                     ADDITION TO POST EXT S.A.@ZA30491
         DS    F                      SLOT FOR REG 12          @ZA30491
         DS    F                      SLOT FOR REG 13          @ZA30491
LSAPEXIT DS    0F                     POST EXIT SAVE AREA      @Z40EPVD
         DS    4F                     EXIT INTERFACE SAVE AREA @Z40EPVD
LSAFLGS  DS    B                      POST FLAGS BYTES         @Z40EPVD
EXTSA    EQU   X'80'                  EXT SAVE AREA IN USE     @Z40EPVD
PEXITSA  EQU   X'40'                  POST EXIT SA IN USE      @Z40EPVD
LSARES1  DS    B                      RESERVED                 @Z40EPVD
LSARES2  DS    B                      RESERVED                 @Z40EPVD
LSARES3  DS    B                      RESERVED                 @Z40EPVD
LSAXITEP DS    1F                     EXIT ENTRY POINT         @Z40EPVD
LSAEXT   DS    0F                     EXTENDED SAVE AREA       @Z40EPVD
         DS    15F                    REGS 0-14                @Z40EPVD
LSAEND   DS    0B                     END OF WSA               @Z40EPVD
         TITLE 'IEAVSY50....ECB'
         IHAECB EXT=YES
         TITLE 'IEAVSY50....EVNT'
         IHAEVNT
         TITLE 'IEAVSY50....CSCB'
CSCB     DSECT                                                    20002
         IEECHAIN                                                 20002
         TITLE 'IEAVSY50....RMPL '
         IHARMPL
         TITLE 'IEAVSY50....RTCA'
         IHASDWA
         TITLE 'IEAVSY50....CVT'
         CVT   DSECT=YES
         TITLE 'IEAVSY50....JSCB'
         IEZJSCB                                                  20002
         TITLE 'IEAVSY50....ASCB'
         IHAASCB
         TITLE 'IEAVSY50....ASXB'
         IHAASXB
         TITLE 'IEAVSY50....SRB'
         IHASRB
XMASCB   DS    F                   ASCB ADDR
XMECB    DS    F                   ECB ADDR
XMERRET  DS    F                   ERROR RETURN ADDR
XMCCODE  DS    F                   ECBKEY BIT; COMPLETION CODE @ZA15373
XMPQ     DS    F                   ORIGINATING ASCB XMP Q
XMECBKEY DS    B                   ECB STORAGE KEY FOR VAL CHK @ZA15373
         DS    BL3                 RESERVED                    @ZA15373
SRBLENTH EQU   *-SRBSECT           LENGTH OF POST SRB
         TITLE 'IEAVSY50....FIXED LOW CORE'
         IHAPSA
         TITLE 'IEAVSY50....LCCA'
         IHALCCA
         TITLE 'IEAVSY50....FRRSTACK'
         IHAFRRS
         TITLE 'IEAVSY50....GLOBAL SAVE AREA'
         IHAWSAVT CLASS=GLOBAL
         TITLE 'IEAVSY50....WSAVT'
         IHAWSAVT
         TITLE 'IEAVSY50....ASVT'
         IHAASVT
         TITLE 'IEAVSY50....RB'
         IHARB
         TITLE 'IEAVSY50....TCB'
         IKJTCB
         END
