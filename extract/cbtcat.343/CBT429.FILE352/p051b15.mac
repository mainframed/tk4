*          DATA SET S051B15    AT LEVEL 004 AS OF 04/08/80
*          DATA SET S051B15    AT LEVEL 003 AS OF 03/09/77
*          DATA SET S051B15    AT LEVEL 001 AS OF 06/22/76
S051B15 TITLE 'D D S T A R  COMMAND - SPOOL CLIST LINES TO DATASET'
***   COPYRIGHT 1976 - REGENTS OF THE UNIVERSITY OF CALIFORNIA,     ***
***   CAMPUS COMPUTING NETWORK   (SHARE CODE 'UR')  -  1/15/76      ***
***   ALTHOUGH WE ARE RUNNING THIS MODULE IN OUR PRODUCTION SYSTEM, ***
***   NO WARRANTY, EXPRESSED OR IMPLIED, IS MADE BY CCN AS TO THE   ***
***   FUNCTIONING OR CORRECTNESS OF THE FOLLOWING CODE.             ***
***********************************************************************
*                                                                     *
*        DDSTAR -                                                     *
*                                                                     *
*           DESIGNED TO BE USED WITHIN A COMMAND PROCEDURE.           *
*           ALLOCATES THE REQUESTED FILE, AND SPOOLS INTO IT THE      *
*           CARDS FOLLOWING THE 'DDSTAR' COMMAND UNTIL A '!EOD'  (KMT)*
*           OR OTHER GIVEN EOF STRING IS ENCOUNTERED.                 *
*                                                                     *
*        SYNTAX -                                                     *
*           DDSTAR FILE('FILENAME') DATASET('DSNAME')                 *
*                  NEW/OLD/NOALLOC  DELETE/CATLG   DUMMY              *
*                  UNIT('UNITNAME')  VOLUME('VOLUME')                 *
*                  SPACE('NUM','INC') BLOCK('SIZE')  EOF('EOFSTRING') *
*                                                                     *
*        DEFAULTS -                                                   *
*                   NEW,DELETE  (APPEND USER PREFIX TO UNQUAL DSNAMES)*
*           SPACE - 3,3                                         KMT   *
*           BLOCK - 6160     OPT FOR 3350 DISK                  KMT   *
*           EOF   - !EOD                                        KMT   *
*                                                                     *
* FCI MODS - K TRUE 6/21/76 .. DEFAULTS, DAIR INTF..                  *
*          - NEW SYNONYMS (BLOCKS,BLKSIZE) (DATASET,DSNAME),          *
*                         (FILE,DDNAME)                               *
*          - APPEND USER PREFIX TO UNQUALIFIED DSNAMES    KT          *
*          - ALLOW CHARACTER '@' TO BE CHAR 1 ON CARD.   TWO          *
*            '@@' INDICATES A LITERAL @ AS CHAR 1.  OTHERWISE,        *
*            THE CARD STARTS WITH THE FIRST NON-BLANK CHAR.           *
*                                                                     *
* MOD 2 - KEN TRUE - APR 7,1980 - INTERNALIZED MACROS AND STUFF       *
*         SO ASSEMBLY COULD BE DONE WITHOUT URMACROS LIBRARY.         *
*                                                                     *
** WDD - 5/27/75 ********************************** LPR - 02/21/74 ****
         EJECT
         MACRO
         TSWORK
OPENCLSE DS    F
DOUBLE   DS    D
GTPB     DS    F
GTPTR    DS    F
CARD     DS    80C
CARDL    EQU   *-CARD
DCB      DCB   DEVD=DA,DSORG=PS,LRECL=CARDL,MACRF=PM,RECFM=FBS
DCBL     EQU   *-DCB
EOFSTR   DS    D                        END OF FILE STRING
DATASET  DS    0H                       DATASET NAME BUFFER ON HW BDRY
DSNLEN   DS    H                        LENGTH OF DSNAME
DSNAME   DS    CL44                     DATASET NAME
MEMBER   DS    CL8                      MEMBER NAME
FILE     DS    CL8                      FILE NAME
UNIT     DS    CL8                      UNITNAME
VOLUME   DS    CL8
DISP     DS    XL1                      * 3 ORDERED FIELDS *
DISP2    DS    XL1                      DISPOSITION KEYWORD
DISP3    DS    XL1
RELEASE  DS    CL1                      RELEASE KEYWORD
         MEND
         PRINT OFF                 MACRO DEFINITIONS FOLLOW
         MACRO
&NAME    TPUTX &BFF,&SIZE,&EDIT,&WAIT,&HOLD,&BRKI,&PRTY,&TJID=,        *
               &TJIDLOC=,&MF=I
         GBLA  &GETLENL
         LCLA  &K,&I,&BITS
         LCLA  &N,&MAXLEN
         LCLC  &NFS
         LCLB  &ED,&WA,&HO,&BR,&PR
&NFS     SETC  '&NAME'
&K       SETA  3                        NORMAL PLACE TO START SCAN
         AIF   ('&BFF' NE '').HAVEBFF
         MNOTE 8,'*** MESSAGE OR MESSAGE ADDR OMMITTED.'
         MEXIT
.*       AIF   ('&NAME' EQ '').NOLAB
.*&NAME  DS    0H
.*NOLAB  ANOP
.HAVEBFF AIF   ('&BFF'(1,1) NE '''').NOTQ
&K       SETA  K'&BFF-2                 LENGTH OF CHAR STRING
&N       SETA  2                        START AT FIRST TEXT CHAR
&MAXLEN  SETA  &K                       SET LENGTH OF CHAR STRING
.QLOOP   ANOP
       AIF  ('&BFF'(&N,2) NE '''''' AND '&BFF'(&N,2) NE '&&').QCONT
&K       SETA  &K-1                     ACCOUNT FOR DBLE CHAR
&N       SETA  &N+1                     FUDGE PAST
.QCONT   ANOP
&N       SETA  &N+1
         AIF   (&N LE &MAXLEN).QLOOP
&NFS     LA    0,&K -                   GET STRING LENGTH
&NFS     SETC  ''                       NAME FIELD SYMBOL DONE
         LA    1,=C&BFF
&K       SETA  2                        ONLY ONE OPERAND FOR STRING
         AGO   .GOTPTRS
.NOTQ    ANOP
&NFS     ICTINNRA &BFF,&SIZE            LOAD BUFFER PTR AND LENGTH
&NFS     SETC  ''                       NAME FIELD SYMBOL DONE
.GOTPTRS AIF   ('&TJID' EQ '' AND '&TJIDLOC' EQ '').NOTJID
         AIF   ('&TJID' EQ '').LOADTJ
         ICTINNRA ,,&TJID               GET TJID
         AGO   .ORTJ
.LOADTJ  ICTINNRA ,,&TJIDLOC            INDIRECT TJID
         LH    15,0(15) .               LOAD TJID
.ORTJ    SLL   15,16 .                  TJID INTO TOP HALF
         OR    0,15 .                   ADD TO PARM REG 0
.NOTJID  ANOP
&I       SETA  &K                       FIRST OPERAND TO CHECK
.LOOP    AIF   (&I GT N'&SYSLIST).SETOP IF ALL ARE PROCESSED, JUMP OUT
         AIF   ('&SYSLIST(&I)' EQ 'EDIT').EDIT
         AIF   ('&SYSLIST(&I)' EQ 'ASIS').ASIS
         AIF   ('&SYSLIST(&I)' EQ 'CONTROL').CONTROL
         AIF   ('&SYSLIST(&I)' EQ 'FULLSCR').FULLS
         AIF   ('&SYSLIST(&I)' EQ 'WAIT').WAIT
         AIF   ('&SYSLIST(&I)' EQ 'NOWAIT').NOWAIT
         AIF   ('&SYSLIST(&I)' EQ 'NOHOLD').NOHOLD
         AIF   ('&SYSLIST(&I)' EQ 'HOLD').HOLD
         AIF   ('&SYSLIST(&I)' EQ 'NOBREAK').NOBREAK
         AIF   ('&SYSLIST(&I)' EQ 'BREAKIN').BREAKIN
         AIF   ('&SYSLIST(&I)' EQ 'HIGHP').HIGHP
         AIF   ('&SYSLIST(&I)' EQ 'LOWP').LOWP
         AIF   ('&SYSLIST(&I)' EQ 'R').NEXTI
         AIF   ('&SYSLIST(&I)'(1,4) EQ 'TJID').SETOP
         MNOTE 8,'INVALID OPTION &SYSLIST(&I) - IGNORED'
.NEXTI   ANOP
&I       SETA  &I+1                     INCREMENT COUNTER
         AGO   .LOOP                    GET NEXT OPTION IF ANY
.MUTEX   MNOTE 8,'MUTUALLY EXCLUSIVE KEYWORDS'
         AGO   .NEXTI
.FULLS   ANOP
&BITS    SETA  &BITS+3                  SET ASIS+CONTROL FOR FULL SCRN
         AGO   .EDIT                    MAKE IT MUTUALLY EXCLUSIVE
.ASIS    ANOP
&BITS    SETA  &BITS+1                  SET ASIS OPTION
         AGO   .EDIT                    MAKE IT MUTUALLY EXCLUSIVE
.CONTROL ANOP
&BITS    SETA  &BITS+2                  SET CONTROL OPTION
.EDIT    AIF   (&ED).MUTEX
&ED      SETB  1                        EDIT,ASIS OR CONTROL SET
         AGO   .NEXTI
.NOWAIT  ANOP
&BITS    SETA  &BITS+16                 SET NOWAIT OPTION
.WAIT    AIF   (&WA).MUTEX
&WA      SETB  1                        WAIT OR NOWAIT SET
         AGO   .NEXTI
.HOLD    ANOP
&BITS    SETA  &BITS+8                  SET HOLD OPTION
.NOHOLD  AIF   (&HO).MUTEX
&HO      SETB  1                        HOLD OR NOHOLD SET
         AGO   .NEXTI
.BREAKIN ANOP
&BITS    SETA  &BITS+4                  SET BREAKIN OPTION
.NOBREAK AIF   (&BR).MUTEX
&BR      SETB  1                        BREAKIN OR NOBREAK SET
         AGO   .NEXTI
.LOWP    ANOP
&BITS    SETA  &BITS+X'20'              FORCE LOW PRTY (EVEN IF KEY0)
.HIGHP   AIF   (&PR).MUTEX
&PR      SETB  1                        HIGHP OR LOWP SET
         AGO   .NEXTI
.SETOP   AIF   ('&BFF'(1,1) NE '(').NOTREG I MUST HAVE DONE LA
         LA    1,0(,1) -                MAKE HIGH BYTE 0
.NOTREG  AIF   (&BITS EQ 0).CALL
         LA    15,&BITS -               GET OPTIONS
         SLL   15,24 -                  SHIFT TO TOP BYTE
         OR    1,15 -                   OR IN OPTIONS
.CALL    ANOP
         AIF   ('&MF' EQ 'I' OR '&MF' EQ 'B').CHK2
         MNOTE 4,'*** INVALID MF OPTION'
         MEXIT
.CHK2    AIF   ('&MF' EQ 'I').CALLIT
         MEXIT
.CALLIT  SVC   93 -                     ISSUE TPUT SVC
         MEND
         MACRO
         USNGX  &ADDR,&REG
         GBLC  &REGADDR(16),&REGREG(16)
         LCLA  &LOOP
&LOOP    SETA  1
         USING &ADDR,&REG
.FIND    AIF   ('&REGADDR(&LOOP)' EQ '').GOT
&LOOP    SETA  &LOOP+1
         AIF   (&LOOP LE 16).FIND
         MNOTE *,'REGISTER TABLE OVERFLOW'
         MEXIT
.GOT     ANOP
&REGADDR(&LOOP) SETC '&ADDR'
&REGREG(&LOOP) SETC '&REG'
         MEND
         MACRO
         DROPX &REG
         GBLC  &REGADDR(16),&REGREG(16)
         LCLA  &LOOP
&LOOP    SETA  1
         AIF   (T'&REG EQ 'O').ALLDROP
         DROP  &REG
.FIND    AIF   ('&REGREG(&LOOP)' EQ '&REG').GOTIT
&LOOP    SETA  &LOOP+1
         AIF   (&LOOP LE 16).FIND
         MNOTE 8,'REGISTER &REG WAS NOT AN OPERAND ON A USNGX '
         MEXIT
.GOTIT   ANOP
&REGADDR(&LOOP) SETC ''
&REGREG(&LOOP) SETC ''
         MEXIT
.ALLDROP AIF   ('&REGREG(&LOOP)'  EQ '').SKIP
         DROP  &REGREG(&LOOP)
&REGADDR(&LOOP) SETC ''
&REGREG(&LOOP) SETC ''
.SKIP    ANOP
&LOOP    SETA  &LOOP+1
         AIF   (&LOOP                   LE 16).ALLDROP
         MEND
         MACRO
         INUSE
         GBLC  &REGADDR(16),&REGREG(16)
         LCLA  &LOOP
&LOOP    SETA  1
         SPACE
         MNOTE *,'THE FOLLOWING REGISTERS ARE IN USE:'
.LOOK    AIF   ('&REGADDR(&LOOP)' EQ '').SKIP
         MNOTE *,'          &REGADDR(&LOOP),&REGREG(&LOOP)'
.SKIP    ANOP
&LOOP    SETA  &LOOP+1
         AIF   (&LOOP LE 16).LOOK
         MNOTE *,'**********'
         SPACE
         MEND
         MACRO
&NAME    ICTINNRA &A,&B,&C,&D
         GBLC  &R
         LCLC  &N
&N       SETC  '&NAME'
         AIF   ('&A' EQ '').CHKB
         AIF   ('&A'(1,1) EQ '(').REGA
&N       LA    &R.1,&A .                LOAD PARAMETER REG 1
&N       SETC  ''
         AGO   .CHKB
.REGA    AIF   (('&A' EQ '(1)')OR('&A' EQ '(R1)')).CHKB
&N       LR    &R.1,&A(1) .             LOAD PARAMETER REG 1
&N       SETC  ''
.CHKB    AIF   ('&B' EQ '').CHKC
         AIF   ('&B'(1,1) EQ '(').REGB
&N       LA    &R.0,&B .                LOAD PARAMETER REG 0
&N       SETC  ''
         AGO   .CHKC
.REGB    AIF   (('&B' EQ '(0)')OR('&B' EQ '(R0)')).CHKC
&N       LR    &R.0,&B(1) .             LOAD PARAMETER REG 0
&N       SETC  ''
.CHKC    AIF   ('&C' EQ '').CHKD
         AIF   ('&C'(1,1) EQ '(').REGC
&N       LA    &R.15,&C .               LOAD PARAMETER REG 15
&N       SETC  ''
         AGO   .CHKD
.REGC    AIF   (('&C' EQ '(15)')OR('&C' EQ '(R15)')).CHKD
&N       LR    &R.15,&C(1) .            LOAD PARAMETER REG 15
&N       SETC  ''
.CHKD    AIF   ('&D' EQ '').CHKN
         AIF   ('&D'(1,1) EQ '(').REGD
&N       LA    &R.14,&D .               LOAD PARAMETER REG 14
&N       SETC  ''
         AGO   .CHKN
.REGD    AIF   (('&D' EQ '(14)')OR('&D' EQ '(R14)')).CHKN
&N       LR    &R.14,&D(1) .            LOAD PARAMETER REG 14
&N       SETC  ''
.CHKN    AIF   ('&N' EQ '').END
&N       DS    0H .                     DEFINE NAME
.END     MEND
         PRINT ON           END OF MACRO DEFINITIONS
         PRINT NOGEN
         DCBD  DEVD=DA,DSORG=PS
         PRINT GEN
*        PDEDSECT
    SPACE
***********************************************************************
*
* PDEDSN       MAPPING FOR DSNAME OR DSTHING PARSE DESCRIPOR ELEMENT
*
***********************************************************************
    SPACE
PDEDSN   DSECT
PDSNAME  DS    A                        PTR TO DSNAME
PDSNAMEL DS    H                        LENGTH OF DSNAME
PDSNAMEF DS    XL1                      DSNAME FLAGS
PRESENT  EQU   X'80'                    DSNAME WAS PRESENT
PQUOTED  EQU   X'40'                    DSNAME WAS QUOTED
         DS    XL1                      RESERVED
PMEMBER  DS    A                        PTR TO MEMBER NAME
PMEMBERL DS    H                        MEMBER NAME LENGTH
PMEMBERF DS    XL1                      MEMBER NAME FLAGS (SEND)
         DS    XL1                      RESERVED
PASSWRD  DS    A                        PTR TO PASSWORD            KMT
PASSWRDL DS    H                        PASSWORD LENGTH            KMT
PASSWRDF DS    XL1                      PASSWORD FLAGS             KMT
         DS    XL1                      RESERVED                   KMT
PDSNNEXT DS    A                        PTR TO NEXT DSNAME PDE
PDEDSNL  EQU   *-PDEDSN                 LENGTH OF THE DSNAME PDE
     EJECT   ,
***********************************************************************
*
* PDEDDN       MAPPING FOR DDNAME PARSE DESCRIPTOR ELEMENT
*
***********************************************************************
    SPACE
PDEDDN   DSECT
PDDNAME  DS    A                        PTR TO DDNAME
PDDNAMEL DS    H                        LENGTH OF DDNAME
PDDNAMEF DS    XL1                      DDNAME FLAGS
PRESENTB EQU   X'80'                    DDNAME WAS PRESENT
         DS    XL1                      RESERVED
PDDNNEXT DS    A                        PTR TO NEXT DDNAME PDE
PDEDDNL  EQU   *-PDEDDN                 LENGTH OF THE DDNAME PDE
     SPACE 2
***********************************************************************
*                                                                     *
*        SYMBOLIC REGISTER DEFINITIONS AND OTHER EQUATES              *
*                                                                     *
***********************************************************************
    SPACE
REGW     EQU   3                        AN ALWAYS AVAILABLE SCRATCH REG
SEND     EQU   7                        SENDING FIELD PTR FOR EXECUTES
PDEBASE  EQU   9                        BASE FOR PDE'S
PDLBASE  EQU   11
    SPACE
     EJECT   ,
*DDSTAR  TSENTRY PL=(PARSE,MESSAGE,IO,DAIRM),MACRO=YES ENTRY
TSDSECT  DSECT
TSAVE    DS    18F                      SAVE AREA
    SPACE
***********************************************************************
*    THE COMMAND PROCESSOR PARAMETER LIST (CPPL) IS A LIST OF         *
*    ADDRESSES PASSED FROM THE TMP TO THE CP VIA REGISTER 1           *
***********************************************************************
    SPACE
CPPL     DS    0A
CPPLCBUF DS    A        PTR TO COMMAND BUFFER
CPPLUPT  DS    A        PTR TO UPT
CPPLPSCB DS    A        PTR TO PSCB
CPPLECT  DS    A        PTR TO ECT
CPPLL    EQU   *-CPPL
TSECB    DS    F                        ECB FOR THE TSO SERVICES
    SPACE
***********************************************************************
*    THE PARSE PARAMETER LIST (PPL) IS A LIST OF ADDRESSES PASSED     *
*    FROM THE INVOKER TO PARSE VIA REGISTER 1                         *
***********************************************************************
    SPACE
PPL      DS    0A
PPLUPT   DS    A        PTR TO UPT
PPLECT   DS    A        PTR TO ECT
PPLECB   DS    A        PTR TO CP'S ECB
PPLPCL   DS    A        PTR TO PCL
PPLANS   DS    A        PTR TO ANS PLACE
PPLCBUF  DS    A        PTR TO CMD BUFFER
PPLUWA   DS    A        PTR TO USER WORK AREA (FOR VALIDITY CK RTNS)
PPLL     EQU   *-PPL
TSPARANS DS    F                        PARSE RETURNS PTR TO PDL HERE
    SPACE
***********************************************************************
*    THE DYNAMIC ALLOCATION INTERFACE ROUTINE (DAIR) PARAMETER LIST   *
*    (DAPL) IS A LIST OF ADDRESSES PASSED FROM THE INVOKER TO DAIR    *
*    VIA REGISTER 1
***********************************************************************
    SPACE
DAPL     DS    0F
DAPLUPT  DS    A        PTR TO UPT
DAPLECT  DS    A        PTR TO ECT
DAPLECB  DS    A        PTR TO CP'S ECB
DAPLPSCB DS    A        PTR TO PSCB
DAPLDAPB DS    A        PTR TO DAIR PARAMETER BLOCK
DAPLL    EQU   *-DAPL
DAPBAREA DS    22F *                    AREA FOR DAIR PARAMETER BLOCK
     EJECT   ,
***********************************************************************
*
* (DMPL)       DAIR MESSAGE PARAMETER LIST
*
* FUNCTION     THE ADDRESS OF THIS PARAMETER LIST IS PASSED IN
*              REGISTER 1 BY THE INVOKER OF IKJEFF18 TO DIAGNOSE DAIR
*              ERRORS AND PRINT APPROPRIATE MESSAGES.
*
***********************************************************************
    SPACE
DMPL     DS    0F *                     DAIR MESSAGE PARAMETER LIST
DMPLDAPL DS    A *                      PTR TO THE DAPL ADDRESS
DMPLRC   DS    A *                      PTR TO THE DAIR RETURN CODE
DMPLMSG  DS    A *                      PTR TO A(IKJEFT02) IF LOADED
DMPLCALL DS    A *                      PTR TO THE CALLER NUMBER
DMPLCODE DS    0F *                     R15 SAVE IS DAIR RETURN CODE
DMPLSAVE DS    3F *                     REGISTER SAVEAREA FOR 15-1
DMPLL    EQU   *-DMPL *                 LENGTH OF THE DMPL
    SPACE 2
***********************************************************************
*    THE I/O SERVICE ROUTINE PARAMETER LIST (IOPL) IS A LIST OF       *
*    FULLWORD ADDRESSES PASSED BY THE INVOKER OF ANY I/O SERVICE      *
*    ROUTINE TO THE APPROPRIATE SERVICE ROUTINE VIA REGISTER ONE.     *
***********************************************************************
    SPACE
IOPL     DS    0A
IOPLUPT  DS    A        PTR TO UPT
IOPLECT  DS    A        PTR TO ECT
IOPLECB  DS    A        PTR TO USER'S ECB
IOPLIOPB DS    A        PTR TO THE I/O SERVICE RTN PARM BLOCK
IOPLL    EQU   *-IOPL
    SPACE
***********************************************************************
*        THE MESSAGE PARAMETER LIST (MPL) IS A PARAMETER LIST WHOSE   *
*        ADDRESS IS PASSED BY THE INVOKER OF THE MESSAGE PROCESSING   *
*        ROUTINE (IKJEFF02) VIA REGISTER 1.                           *
***********************************************************************
    SPACE
MPL      DS    0A .                     MESSAGE PARAMETER LIST
MPLCSECP DS    A .                      PTR TO ADRS OF MESSAGE CSECT
MPLCPPL  DS    A .                      PTR TO CPPL
MPLECB   DS    A .                      PTR TO USER'S ECB (TSECB)
MPLCSECT DS    A .                      ADDRESS OF MESSAGE CSECT
MPLSW    DS    X .                      MESSAGE OPTION FLAGS
MPLINFO  EQU   X'80' .                  BIT 0, NO MESSAGE IDENTIFIER
MPLREV   EQU   X'40' .                  BIT 1, MESSAGE REVERSAL
MPLWTO   EQU   X'20' .                  BIT 2, INDICATES WRITE TO OPR
MPLHEX   EQU   X'10' .                  BIT 3, CONVERT NO'S TO HEX
     EJECT   ,
MPLREPLY DS    AL3 .                    ADDRESS OF REPLY MESSAGE
MPLMSGID DS    CL4 .                    4 CHARACTER MESSAGE ID
MPLLEN1  DS    X .                      LENGTH OF VAR TEXT INSERT 1
MPLVAR1  DS    AL3 .                    ADRS OF VARIABLE TEXT INSERT 1
MPLLEN2  DS    X .                      LENGTH OF VAR TEXT INSERT 2
MPLVAR2  DS    AL3 .                    ADRS OF VARIABLE TEXT INSERT 2
MPLLEN3  DS    X .                      LENGTH OF VAR TEXT INSERT 3
MPLVAR3  DS    AL3 .                    ADRS OF VARIABLE TEXT INSERT 3
MPLLEN4  DS    X .                      LENGTH OF VAR TEXT INSERT 4
MPLVAR4  DS    AL3 .                    ADRS OF VARIABLE TEXT INSERT 4
MPLL     EQU   *-MPL .                  LENGTH OF MPL
MPLZL    EQU   *-MPLSW
    SPACE
***********************************************************************
*                                                                     *
*        DYNAMIC STORAGE DEFINED BY USER TSWORK MACRO                 *
*                                                                     *
***********************************************************************
    SPACE
         DS    0D                       BEGIN ON DOUBLE WORD BOUNDARY
         TSWORK
TSDSECTL DS    0D
         EJECT
         IKJDAP08
DAPB08L  EQU   *-DAPB08 *               LENGTH OF DAPB08 BLOCK
         EJECT
         IKJDAP18
DAPB18L  EQU   *-DAPB18 *               LENGTH OF DAPB18 BLOCK
         SPACE
         IKJDAP1C
DAPB1CL  EQU   *-DAPB1C *               LENGTH OF DAPB1C BLOCK
         EJECT
         IKJDAP30
DAPB30L  EQU   *-DAPB30 *               LENGTH OF DAPB30 BLOCK
         SPACE
***********************************************************************
*                                                                     *
*                   DEFINE SYMBOLIC REGISTERS                         *
*                                                                     *
***********************************************************************
         SPACE
R0       EQU   0                        THE SYMBOLIC REGISTERS
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         EJECT
DDSTAR   CSECT
         B     20(0,15)                          BRANCH AROUND ID
         DC    AL1(6+8)
         DC    CL6'DDSTAR'                       IDENTIFIER
         DC    C' ',CL7'04/03/80'                DATE OF ASMBLY
    SPACE
         STM   14,12,12(13)                      SAVE REGISTERS
         USNGX DDSTAR,12
         LR    12,15                    ESTABLISH ADDRESSABILITY
         LR    5,1                      SAVE PTR TO CPPL
         GETMAIN R,LV=TSDSECTL-TSDSECT,SP=1
         ST    13,4(1)                  DO SAVE AREA CHAINING
         ST    1,8(13)
         LR    13,1                     ESTABLISH ADDRESSABILITY
         USNGX TSDSECT,13
         MVC   CPPL(CPPLL),0(5)         COPY CPPL TO TS AREA
         L     1,CPPLUPT                GET PTR TO UPT
         L     2,CPPLECT                GET PTR TO ECT
         LA    3,TSECB                  GET PTR TO ECB
         SR    0,0                      CLEAR ECB
         ST    0,TSECB
         STM   1,3,PPL                  INITIALIZE PPL. UPT,ECT,ECB
         LA    4,TSPARANS               ADRS OF PARSE ANSWER PLACE
         ST    4,PPLANS                 POINTER TO ADRS OF PARSE ANSWER
         ST    13,PPLUWA                PARSE USER WORK AREA POINTER
         XC    TSPARANS(4),TSPARANS     TO AVOID DUPLICATE IKJRLSA
         STM   1,3,DAPL                 INITIALIZE DAPL
         L     4,CPPLPSCB               GET PTR TO PSCB
         ST    4,DAPLPSCB               SET POINTER TO PSCB
         STM   1,3,IOPL                 INITIALIZE IOPL
         ST    3,MPLECB                 INITIALIZE MPL, PTR TO ECB
         LA    4,CPPL                   ADDRESS OF CPPL
         ST    4,MPLCPPL                PTR TO CPPL
         LA    4,MPLCSECT               PTR TO MESSAGE CSECT
         ST    4,MPLCSECP               PTR TO MESSAGE CSECT ADDRESS
         XC    MPLSW(MPLZL),MPLSW       INITIALIZE REMAINING MPL TO 0
         INUSE
         EJECT
***********************************************************************
*                                                                     *
*        INITIALIZATION                                               *
*                                                                     *
***********************************************************************
    SPACE
         MVI   VOLUME,C' '
         MVC   VOLUME+1(L'VOLUME-1),VOLUME
         MVI   UNIT,C' '
         MVC   UNIT+1(L'UNIT-1),UNIT
         XC    DSNLEN(L'DSNLEN),DSNLEN
         MVI   DSNAME,C' '
         MVC   DSNAME+1(L'DSNAME-1),DSNAME
         MVI   MEMBER,C' '
         MVC   MEMBER+1(L'MEMBER-1),MEMBER
         MVI   FILE,C' '
         MVC   FILE+1(L'FILE-1),FILE
         MVC   DISP(3),=AL1(DA08NEW,DA08DEL,DA08DELE)
         MVI   EOFSTR,C' '
         MVC   EOFSTR+1(L'EOFSTR-1),EOFSTR
         XC    OPENCLSE(4),OPENCLSE     CLEAR OPEN/CLOSE PARM
         OI    OPENCLSE,X'80'           SET END OF LIST FLAG
         MVC   DCB(DCBL),DCBR           MOVE IN DUMMY DCB
     EJECT   ,
         INUSE
    SPACE
*        TSPARSE CBUF=(CPPLCBUF,I),PCL=(=V(PCL),I),SYNAD=RETURN
         L     0,=V(PCL)
         ST    0,PPLPCL
         L     0,CPPLCBUF
         ST    0,PPLCBUF
         LA    1,PPL
         LINK  EP=IKJPARS
         LTR   15,15
         BZ    TSP0030+4
         LA    0,RETURN
         L     14,TSP0030
         BR    14
    SPACE
TSP0030    DC A(TSPARERR)
    SPACE
         L     PDLBASE,TSPARANS         ADDRESSABILITY FOR
         USNGX PDL,PDLBASE              PARSE DESCRIPTOR LIST
    SPACE
         BAL   R14,$DSNAME              PROCESS THE DSNAME PDE
    SPACE
         BAL   R14,$FILE                PROCESS FILE KEYWORD
    SPACE
         BAL   R14,$EOF                 PROCESS EOF STRING
    SPACE
         BAL   R14,$VOLUME              PROCESS VOLUME KEYWORD
    SPACE
         BAL   R14,$UNIT                PROCESS UNIT KEYWORD
    SPACE
         BAL   R14,$TYPE                PROCESS MISC. KEYWORDS
     EJECT   ,
         L     R4,NUM                   LOAD NUMBER STRING ADDRESS
         LH    R5,NUM+4                 AND LENGTH
         BCTR  R5,0                     -1 FOR EXECUTE
PACK     PACK  DOUBLE(8),0(0,R4)        PACK THE AMOUNT
         EX    R5,PACK                  PACK THE NUMBER
         CVB   R2,DOUBLE                NUMBER TO BINARY
         L     R4,INC                   LOAD INCREMENT STRING ADDRESS
         LH    R5,INC+4                 AND LENGTH
         BCTR  R5,0                     -1 FOR EXECUTE
         EX    R5,PACK                  PACK THE INCREMENT
         CVB   R3,DOUBLE                INCREMENT TO BINARY
         L     R4,BLKSIZE               LOAD BLKSIZE STRING ADDRESS
         LH    R5,BLKSIZE+4             AND LENGTH
         BCTR  R5,0                     -1 FOR EXECUTE
         EX    R5,PACK                  PACK THE BLKSIZE
         CVB   R1,DOUBLE                BLKSIZE TO BINARY
         SR    R0,R0                    CLEAR FOR DIVIDE
         D     R0,=A(CARDL)             DIVIDE BY LRECL
         LTR   R1,R1                    ANYTHING THERE ?
         BNZ   *+8                      YES, SKIP NEXT
         LA    R1,1                     BLKSIZE=LRECL
         MH    R1,=AL2(CARDL)           COMPUTE A VALID BLKSIZE
         STH   R1,DCB+DCBBLKSI-IHADCB   AND INTO DCB
         MVC   DCB+DCBDDNAM-IHADCB(8),FILE SET FILE NAME OR BLANKS
         CLI   FILE,C' '                FILE NAME GIVEN ?
         BE    ALLOC                    NO
    SPACE
         CLI   DISPK+1,3                SHOULD WE DO ALLOCATION
         BE    NOALLOC                  NO
    SPACE
*        FREE  FILE=FILE                YES FREE THE FILE NAME
         LA    15,DAPBAREA
         USING  DAPB18,15               ADDRESSIBILITY
         XC    DAPB18(DAPB18L),DAPB18   INITIALIZE DAIR BLOCK TO ZERO
         MVI   DA18CD+1,X'18'           DAIR ENTRY CODE FOR FREE
         MVC   DA18DDN,FILE
         MVC   DA18JBNM,=CL8' '         NOT SPECIFIED
         MVC   DA18SCLS,=CL2' '         NOT SPECIFIED
         MVC   DA18MNM,=CL8' '          NOT SPECIFIED
         OI    DA18CTL,X'10'            FREE PERMANENTLY ALLOCATED DS
**       DISPOSITION SPECIFIED WHEN ALLOCATED WILL BE USED
         ST    15,DAPLDAPB
         LA    1,DAPL
         LINK  EP=IKJDAIR
         DROP  15               DROP ADDRESSIBLITY TO DAIR BLOCK
    SPACE
         SR    R1,R1                    CLEAR FOR BLKSIZE         KMT
         LH    R1,DCB+DCBBLKSI-IHADCB   RESTORE BLKSIZE           KMT
     EJECT   ,
*ALLOC   ALLOC FILE=FILE,SPACE=((1),(2),(3)),
*              MF=(L,DAPBAREA),DSN=DATASET,UNIT=UNIT,VOL=VOLUME
ALLOC    LA    15,DAPBAREA
         USING  DAPB08,15               ADDRESSIBILITY
         XC    DAPB08(DAPB08L),DAPB08   INITIALIZE DAIR BLOCK TO ZERO
         MVI   DA08CD+1,X'08'           DAIR ENTRY CODE FOR ALLOCATE
         LA    0,DATASET
         ST    0,DA08PDSN
         MVC   DA08DDN,FILE
         MVC   DA08UNIT,UNIT
         MVC   DA08SER,VOLUME
         MVC   DA08SER+6(2),=CL2' '     CLEAR LAST 2 BYTES OF VOLUME
         MVC   DA08MNM,=CL8' '          NOT SPECIFIED
         MVC   DA08PSWD,=CL8' '         NOT SPECIFIED
         ST    (1),DA08BLK
**       ALLOCATION BY AVERAGE BLOCK LENGTH
         ST    (2),DA08PQTY
         ST    (3),DA08SQTY
**       DATASET MUST BE SPECIFICALLY FREED
         OI    DA08CTL,0+DA08ABKL+DA08PERM
**       DEFAULT DISPOSITION IS DISP=(NEW,KEEP)
         MVC   DA08ALN,=CL8' '          NOT SPECIFIED
         DROP  15                 DROP ADDRESSIBILITY TO DAIR BLOCK
    SPACE 2
         LA    R15,DAPBAREA             POINT AT THE DAIR BLOCK
         USNGX DAPB08,R15
         MVC   DA08DSP1(3),DISP         SET THE DISPOSITIONS
         OC    DA08CTL,RELEASE          AND OTHER FIELDS
         CLI   DA08SER,C' '             VOLUME SPECIFIED
         BE    *+10                     NO
         MVC   DA08UNIT,=CL8' '         YES, SET UNIT TO BLANKS
*                                       TO AVOID CONFLICT
         CLI   DSNAME,C' '              DSNAME PRESENT ?
         BNE   YESDSN                   YES
         XC    DA08PDSN,DA08PDSN        NO, CLEAR DSNAME POINTER
         MVC   DA08DSP1(3),=AL1(DA08NEW,DA08DEL,DA08DELE)  NO DSNAME
*              IMPLIES TEMPORARY DATASET WHICH MUST BE NEW,DEL,DEL
         CLI   FILE,C' '                FILE NAME PRESENT ?
         BNE   YESDSN                   YES
*                                       NO FILENAME OR DATASET NAME
         TPUTX 'MISSING FILE/DDNAME KEYWORD'                       KMT
         B     RC12                     GIVE RETURN CODE 12
         DROPX R15
     EJECT   ,
*YESDSN  TSDAIR DAPB=DAPBAREA,SYNAD=RC12
YESDSN   LA    0,DAPBAREA
         ST    0,DAPLDAPB
         LA    1,DAPL
         LINK  EP=IKJDAIR
         LTR   15,15
         BZ    TSD0065+4
         LA    0,RC12
         L     14,TSD0065
         BR    14
    SPACE
***********************************************************************
*              DAIR ERROR ANALYSIS SUBROUTINE                         *
***********************************************************************
    SPACE
         USNGX TSDAIRER,14
TSDAIRER STM   15,1,DMPLSAVE            RC, RTN ADRS AND DAPL ADRS
         LTR   15,15                    RETURN CODE FROM DAIR
         BZ    TSD0069                  ON ZERO RETURN CODE
         ST    1,DMPLDAPL               PTR TO DAPL
         LA    1,DMPLCODE               ADDRESS OF RETURN CODE
         ST    1,DMPLRC                 PTR TO RETURN CODE
         LA    1,TSM0069                ADDRESS OF LOADED IKJEFT02 IS 0
         ST    1,DMPLMSG                PTR TO A F'0'
         LA    1,TSC0069                ADDRESS OF CALLER NUMBER
         ST    1,DMPLCALL               PTR TO CALLER NUMBER
         LA    1,DMPL                   ADRS OF DAIR MSG PARM LIST
         LINK  EP=IKJEFF18
         LM    15,1,DMPLSAVE            RESTORE REGISTERS
TSD0069    LR  14,0                     RETURN ADDRESS TO USABLE REG.
         BR    14                       RETURN TO CALLER
    SPACE
TSC0069    DC  H'1'                     GENERAL CALLER NUMBER
TSM0069    DC  F'0'                     IKJEFT02 NOT LOADED
         DROPX 14                       DROP ADDRESSIBLITY
    SPACE
TSD0065    DC  A(TSDAIRER)
     EJECT   ,
         LA    R15,DAPBAREA             ADRS OF DAIR BLOCK
         MVC   DCB+DCBDDNAM-IHADCB(8),DA08DDN-DAPB08(R15)
NOALLOC  OPEN  (DCB,(OUTPUT)),MF=(E,OPENCLSE) AND OPEN THE FILE
    SPACE
         TM    DCB+DCBOFLGS-IHADCB,DCBOFOPN DID IT OPEN ?
         BO    LOOP                     YES
         TPUTX 'FILE/DDNAME FAILED TO OPEN'
         B     RC12                     RETURN WITH ERROR
    SPACE
     EJECT   ,
LOOP     XC    GTPB(8),GTPB             CLEAR GETLINE PARM BLK
         GETLINE PARM=GTPB,INPUT=(ISTACK,LOGICAL),TERMGET=(EDIT,WAIT), X
               MF=(E,IOPL)
    SPACE
         L     R14,BTBL(R15)            ANALYZE RETURN
         BR    R14                      BRANCH VIA TABLE
BTBL     DC    A(TERMERR)               LINE OBTAINED FROM TERMINAL
         DC    A(SCAN)                  LINE OBTAINED FROM STACK
         DC    A(RC12)                  ATTENTION SIGNALED, RETURN
         DC    A(SYSERR)                NOWAIT AND NO INPUT FOUND
         DC    A(EOD)                   EOD ON CURRENT STACK ELEMENT
         DC    A(SYSERR)                INVALID PARMS TO GETLINE
         DC    A(SYSERR)                NO CORE FOR BUFFER
         DC    A(SYSERR)                TERMINAL HAS BEEN DISCONNECTED
    SPACE
SCAN     L     R4,GTPTR                 GET PTR TO CMD STRING
         LA    R2,1                     BXLE INCREMENT
         LH    R3,0(R4)                 LENGTH OF STRING
         BCTR  R3,0                     -1 FOR BXLE LOOP
         LA    R3,0(R3,R4)              GET PTR TO END OF STR
         LA    R4,4(R4)                 POINT TO TRUE BEGINNING
SCANLOOP CLI   0(R4),C' '               BLANK ?
         BNE   *+12                     NO
         BXLE  R4,R2,SCANLOOP           ON TO NEXT
         B     SCANRLSE                 EMPTY STRING GO WRITE IT
         CLC   EOFSTR,0(R4)             THIS THE END ?
         BE    FREEBUF                  YES
    SPACE
     EJECT   ,
SCANRLSE L     R1,GTPTR                 POINTER TO GETLINE STORAGE
         LH    R2,0(R1)                 LENGTH OF STRING
         SH    R2,=H'5'                 LESS CONTROL BLOCK AND 1 FOR EX
         CLC   4(2,R1),=C'@@'           LITERAL '@'  AS CHAR 1?     FCI
         BNE   CHKSTRT                  NO -> CHECK FOR SINGLE      FCI
         LA    R1,1(R1)                 YES-> POINT TO SECOND '@'   FCI
         BCTR  R2,0                        AND SAY LENGTH IS LESS   FCI
         B     CHKLEN                   GO CHECK LENGTH OF CARD     FCI
CHKSTRT  CLI   4(R1),C'@'               MARKER TO SAY CHAR 1?       FCI
         BNE   CHKLEN                   NO -> GO CHECK LEN OF CARD  FCI
         MVI   4(R1),C' '               YES -> OVERWRITE WITH BLANK FCI
CHKLEN   CH    R2,=AL2(CARDL-1)         GREATER THAN MAX LENGTH ?   FCI
         BNH   *+8                      NO
         LH    R2,=AL2(CARDL-1)         ONLY MOVE 80 CHARACTERS
         MVI   CARD,C' '                CLEAR THE
         MVC   CARD+1(CARDL-1),CARD       OUTPUT CARD
         MVC   CARD(0),4(R1)            MOVE IN THE CARD
         EX    R2,*-6                     BY THIS EXECUTE
         PUT   DCB,CARD                 WRITE THE CARD
         L     R1,GTPTR                 RETURN GETLINE STORAGE
         LA    R0,1                     LOAD SUBPOOL
         SLL   R0,24                    SHIFT TO HIGH ORDER BYTE
         AH    R0,0(R1)                 ADD IN LENGTH
    SPACE
         FREEMAIN R,LV=(0),A=(1)        FREE THE CORE
         B     LOOP                     GO FOR NEXT COMMAND
    SPACE
     EJECT   ,
FREEBUF  L     R1,GTPTR                 RETURN GETLINE STORAGE
         LA    R0,1                     LOAD SUBPOOL
         SLL   R0,24                    TO LOW BYTE
         AH    R0,0(R1)                 ADD IN LENGTH
    SPACE
         FREEMAIN R,LV=(0),A=(1)        FREE THE CORE
    SPACE
RC0      SR    R15,R15
    SPACE
RETURN   LR    R2,R15                   SAVE RETURN CODE
         IKJRLSA TSPARANS               RELEASE PARSE STORAGE
    SPACE
CLOSE    CLOSE (DCB,REWIND),MF=(E,OPENCLSE) CLOSE THE FILE
    SPACE
         LR    R15,R2                   RESTORE RETURN CODE
*        EXIT  RC=(15),LV=TSDSECTL-TSDSECT AND EXIT
         LR    1,13                     SAVE FREEMAIN ADD
         L     13,4(13)                 UNCHAIN
         ST    15,16(13)                 SAVE RETURN CODE
         FREEMAIN R,LV=TSDSECTL-TSDSECT,A=(1),SP=1
         LM    14,12,12(13)
         BR    14
    SPACE 2
TERMERR  TPUTX TERMSG,TERMSGL
    SPACE
EOD      TPUTX EODMSG,EODMSGL           TO TERMINAL
TSPARERR DS    0H
RC12     LA    R15,12
         B     RETURN
    SPACE
SYSERR   TPUTX 'DDSTAR ENDED DUE TO ERROR'
         B     RC12                     RETURN
         TITLE '$DSNAME - SUBROUTINE TO PROCESS DSNAME PDE S'
         INUSE
***********************************************************************
*
* NAME         $DSNAME
*
* FUNCTION     PROCESSES DATASET NAME PDES AND PREPARES THE DSNAME
*              BUFFER.
*
* OUTPUT       'DATASET' THE DATASET NAME BUFFER
*              'MEMBER'  THE MEMBER NAME IF ONE WAS PRESENT
*              RETURN CODES
*              0      DATASET BUFFER PREPARED
*              4      DATASET NAME NOT PRESENT, MEMBER MAY BE PRESENT
*
***********************************************************************
    SPACE
         USNGX PDEDSN,PDEBASE           ADDRESSABLILITY
    SPACE
$DSNAME  LA    PDEBASE,INPUT            ADRSIBLILITY TO PDE
         LA    R15,4                    INITIALIZE RETURN CODE
***      ZERO  DSNLEN                   DSNAME LENGTH = 0
***      BLANK DSNAME                   DSNAME = BLANKS
***      BLANK MEMBER                   MEMBER NAME = BLANKS
         CLI   DSNK+1,0                 DATASET KEYWORD PRESENT ?
         BER   R14                      NO
         TM    PDSNAMEF,PRESENT         DSNAME PRESENT ?           KMT
         BNO   $DSNAMEM                 NO, SEE IF MEMBER NAME PRESENT
         LH    REGW,PDSNAMEL            LENGTH OF DSNAME
         STH   REGW,DSNLEN              SET DSNAME LEN IN DSNAME BUFFER
         L     SEND,PDSNAME             ADDRESS OF DSNAME FROM PDE
         BCTR  REGW,0                   -1 FOR EXECUTED MOVE
         EX    REGW,MOVEDSN             MOVE DSNAME TO BUFFER
         XR    R15,R15                  DSNAME IS IN BUFFER
    SPACE
$DSNAMEM TM    PMEMBERF,PRESENT         MEMBER NAME PRESENT ?
         BZR   R14                      NO, RETURN TO CALLER
         LH    REGW,PMEMBERL            LENGTH OF MEMBER NAME
         L     SEND,PMEMBER             ADDRESS OF MEMBER FROM PDE
         BCTR  REGW,0                   -1 FOR EXECUTED MOVE
         EX    REGW,MOVEMEM             MOVE MEMBER TO BUFFER
         BR    R14                      RETURN TO CALLER
    SPACE
MOVEDSN  MVC   DSNAME(0),0(SEND)        EXECUTED MOVE
MOVEMEM  MVC   MEMBER(0),0(SEND)
*        DROP  R0                                                  KMT
         DROPX PDEBASE                  DROP ADDRESSIBILITY TO PDE
         TITLE '$FILE  - SUBROUTINE TO PROCESS FILENAME PDE'
         INUSE
***********************************************************************
*
* NAME         $FILE
*
* FUNCTION     PROCESSES FILENAME PDE  AND PREPARES THE FILENAME
*
***********************************************************************
    SPACE
***      BLANK FILE
$FILE    TM    FILENAME+6,X'80'         FILENAME PRESENT
         BNOR  R14                      NO, RETURN
         LH    REGW,FILENAME+4          YES, LENGTH OF FILENAME
         L     SEND,FILENAME            ADDRESS OF FILENAME FROM PDE
         BCTR  REGW,0                   -1 FOR EXECUTED MOVE
         EX    REGW,MOVEFILE            MOVE FILENAME TO BUFFER
         BR    R14
    SPACE
MOVEFILE MVC   FILE(0),0(SEND)          EXECUTED MOVE
         TITLE '$EOF - SUBROUTINE TO PROCESS EOF PDE'
         INUSE
***********************************************************************
*
* NAME         $EOF
*
* FUNCTION     PROCESSES EOF PDE AND PREPARES THE EOF STRING
*
***********************************************************************
    SPACE
***      BLANK EOFSTR
$EOF     TM    EOF+6,X'80'                 EOF PRESENT?
         BNOR  R14                      NO, RETURN
         LH    REGW,EOF+4               YES, LENGTH OF EOF STRING
         L     SEND,EOF                 ADDRESS OF EOF STRING FROM PDE
         BCTR  REGW,0                   -1 FOR EXECUTED MOVE
         EX    REGW,MOVEEOF             MOVE VOLUME TO BUFFER
         BR    R14
    SPACE
MOVEEOF  MVC   EOFSTR(0),0(SEND)        EXECUTED MOVE
         TITLE '$VOLUME - SUBROUTINE TO PROCESS VOLUME PDE'
         INUSE
***********************************************************************
*
* NAME         $VOLUME
*
* FUNCTION     PROCESSES VOLUME NAME PDES AND PREPARES THE VOLUME
*
***********************************************************************
    SPACE
***      BLANK VOLUME
$VOLUME  TM    VOLNAME+6,X'80'          VOLUME PRESENT?
         BNOR  R14                      NO, RETURN
         LH    REGW,VOLNAME+4           YES, LENGTH OF VOLUME
         L     SEND,VOLNAME             ADDRESS OF VOLUME FROM PDE
         BCTR  REGW,0                   -1 FOR EXECUTED MOVE
         EX    REGW,MOVEVOL             MOVE VOLUME TO BUFFER
         BR    R14
    SPACE
MOVEVOL  MVC   VOLUME(0),0(SEND)        EXECUTED MOVE
         TITLE '$UNIT   - SUBROUTINE TO PROCESS UNIT PDE'
         INUSE
***********************************************************************
*
* NAME         $UNIT
*
* FUNCTION     PROCESSES UNIT NAME PDES AND PREPARES THE UNIT
*
***********************************************************************
    SPACE
***      BLANK UNIT
$UNIT    TM    UNITNAME+6,X'80'         UNIT PRESENT?
         BNOR  R14                      NO, RETURN
         LH    REGW,UNITNAME+4          YES, LENGTH OF UNIT
         L     SEND,UNITNAME            ADDRESS OF UNIT FROM PDE
         BCTR  REGW,0                   -1 FOR EXECUTED MOVE
         EX    REGW,MOVEUNIT            MOVE VOLUME TO BUFFER
         BR    R14
    SPACE
MOVEUNIT MVC   UNIT(0),0(SEND)          EXECUTED MOVE
         TITLE '$TYPE - MISC KEYWORDS'
         INUSE
***********************************************************************
*
* NAME         $TYPE
*
***********************************************************************
    SPACE
$TYPE    CLI   DISPK+1,3                NOALLOC KEYWORD ?
         BER   R14                      YES
         CLI   DISPK+1,1                WAS OLD ENTERED ?
         BNE   TYPE020                  NO
         MVC   DISP(3),=AL1(DA08OLD,DA08KEEP,DA08KEP)
         B     TYPE030
TYPE020  MVI   DISP2,DA08DEL
         CLI   DISP2K+1,2               WAS CATLG  ENTERED ?
         BNE   TYPE030                  NO
         MVC   DISP2(2),=AL1(DA08CAT,DA08KEP)
    SPACE
TYPE030  MVI   RELEASE,DA08RLSE
         CLI   DUMMYK+1,0               DUMMY ENTERED ?
         BE    TYPE050                  NO
         OI    RELEASE,DA08DMMY         YES
TYPE050  BR    R14
    SPACE
         TITLE 'MISC MESSAGES AND STUFF'
TERMSG   DC    C'THE LAST LINE INPUT FROM THE TERMINAL WAS INGORED'
         DC    C' BECAUSE:'
TERMSGL  EQU   *-TERMSG
EODMSG   DC    C'''EOF'' NOT FOUND IN CURRENT STACK BLOCK'
EODMSGL  EQU   *-EODMSG
    SPACE
         PRINT NOGEN
DCBR     DCB   DEVD=DA,DSORG=PS,LRECL=CARDL,MACRF=PM,RECFM=FBS
         PRINT GEN
    SPACE 2
**       TSPARERR
         LTORG
         DROPX
         TITLE 'PARSE PARAMETER LIST'
         PRINT NOGEN
***********************************************************************
*
*              SYNTAX DEFINITION
*
***********************************************************************
    SPACE
PCL      IKJPARM  DSECT=PDL
DSNK     IKJKEYWD
         IKJNAME 'DATASET',SUBFLD=DSNSF
         IKJNAME 'DSNAME',SUBFLD=DSNSF                             KMT
FILEK    IKJKEYWD
         IKJNAME  'FILE',SUBFLD=FILESF
         IKJNAME 'F',SUBFLD=FILESF
         IKJNAME 'DDNAME',SUBFLD=FILESF                            KMT
EOFK     IKJKEYWD DEFAULT='EOF'
         IKJNAME 'EOF',SUBFLD=EOFSF
SPACE    IKJKEYWD DEFAULT='SPACE'
         IKJNAME 'SPACE',SUBFLD=SIZES
BLOCK    IKJKEYWD DEFAULT='BLOCK'
         IKJNAME 'BLOCK',SUBFLD=BLKS
         IKJNAME 'BLKSIZE',SUBFLD=BLKS                             KMT
VOL      IKJKEYWD
         IKJNAME  'VOLUME',SUBFLD=VOLSF
UN       IKJKEYWD
         IKJNAME  'UNITNAME',SUBFLD=UNITSF
DISPK    IKJKEYWD   DEFAULT='NEW'
         IKJNAME    'OLD'
         IKJNAME    'NEW'
         IKJNAME    'NOALLOC'
DISP2K   IKJKEYWD   DEFAULT='DELETE'
         IKJNAME    'DELETE'
         IKJNAME    'CATLG'
DUMMYK   IKJKEYWD
         IKJNAME    'DUMMY'
     EJECT
*
* SUBFIELD DEFINITIONS
*
DSNSF    IKJSUBF
INPUT    IKJPOSIT DSNAME,USID,PROMPT='NAME OF DATASET TO CREATE'  KMT
FILESF   IKJSUBF
FILENAME IKJIDENT  'FILE NAME',                                        X
               FIRST=ALPHA,OTHER=ALPHANUM,MAXLNTH=8,                   X
               PROMPT='FILE/DDNAME',                               KMT X
               HELP='A DDNAME TO ASSOCIATE WITH THE DATASET'
EOFSF    IKJSUBF
EOF      IKJIDENT  'EOF STRING',                                       X
               FIRST=ANY,OTHER=ANY,MAXLNTH=8,DEFAULT='!EOD'        KMT
VOLSF    IKJSUBF
VOLNAME  IKJIDENT  'VOLUME NAME',                                      X
               FIRST=ALPHANUM,OTHER=ALPHANUM,                          X
               MAXLNTH=6,                                              X
               PROMPT='SERIAL NUMBER OF DIRECT ACCESS VOLUME'
UNITSF   IKJSUBF
UNITNAME IKJIDENT  'UNIT NAME',                                        X
               FIRST=ALPHANUM,OTHER=ALPHANUM,                          X
               MAXLNTH=8,                                              X
               PROMPT='UNIT NAME'
SIZES    IKJSUBF
NUM      IKJIDENT 'NUMBER',FIRST=NUMERIC,OTHER=NUMERIC,DEFAULT='3',    $
               MAXLNTH=3
*
INC      IKJIDENT 'INCREMENT',FIRST=NUMERIC,OTHER=NUMERIC,DEFAULT='3', $
               MAXLNTH=3
*
BLKS     IKJSUBF
BLKSIZE  IKJIDENT 'BLOCK SIZE',FIRST=NUMERIC,OTHER=NUMERIC,            $
               MAXLNTH=5,DEFAULT='6160'                            KMT
         IKJENDP
         END
