         TITLE 'PARTITIONED DATA SET SCAN ROUTINE                     '
         PRINT  ON,NODATA,GEN
*
*      IDENTIFICATION DIVISION.
*      PROGRAM-ID.     CXYPSCAN
*      AUTHOR.         FRANK JOHNSTON
*      DATE WRITTEN.   FEB. 1976
*      DATE COMPILED.  FEB. 1976
*      SECURITY.       U
*      REMARKS.
*          PRODUCT-NO.
*          JOB-NO.     7108
*          TITLE.      PDS SCAN ROUTINE
*          AUTHORITY.
*          FREQUENCY.  AS REQUIRED
*          LINKAGE.    DATETIME SUB-ROUTINE
*          PURPOSE.    TO SCAN PARTITIONED DATA SETS FOR MATCHES TO
*                      CHARACTER STRING ARGUMENTS ENTERED VIA CONTROL
*                      CARDS OR BY THE MASTER CONSOLE OPERATER IN REPLY
*                      TO WTORS ISSUED BY THIS PROGRAM. THE PROGRAM
*                      SCANS ANY F FB V OR VB PDS WITH LRECL FROM 50
*                      TO 255 BYTES. ANY NUMBER OF PDSES CAN BE
*                      SCANNED IN ONE RUN FOR UP TO 255 ARGUMENTS.
*                      ALL PDSES TO BE SCANNED MUST HAVE A DDNAME
*                      BEGINNING WITH EITHER PDS OR PROC. EACH DATA SET
*                      TO BE SEARCHED MUST HAVE A SEP DDNAME OF PDSXXX
*                      OR PROCYYY(NO CONCATONATED DATA SETS). MEMBERS
*                      WILL BE IDENTIFIED AND PRINTED USING 'AND'  OR
*                      'OR' LOGIC.
*      CONSOLE MESSAGE. WTORS WILL BE ISSUED PROMPTING THE CONSOLE
*                       OPERATOR TO ENTER ARGUMENTS IF THIS PROGRAM
*                       IS RUN WITH PARM=CONSOLE.
*
*
*
*
         EJECT
*      REGISTER USAGE.
         MACRO
         EQUAT
R0        EQU   0
R1        EQU   1
R2        EQU   2
R3        EQU   3
R4        EQU   4
R5        EQU   5
R6        EQU   6
R7        EQU   7
R8        EQU   8
R9        EQU   9
R10       EQU   10
R11       EQU   11
R12       EQU   12
R13       EQU   13
R14       EQU   14
R15       EQU   15
         MEND
*          R0.  WORK
*          R1.  WORK
*          R2.  WORK
*          R3.  WORK
*          R4.  WORK
*          R5.  WORK
*          R6.  WORK
*          R7.  WORK
*          R8.  ARGUMENT TABLE DSECT
*          R9.  NO. OF BYTES IN DIR REC
*          R10. BASE
*          R11. BASE
*          R12. BASE
*          R13. SAVE
*          R14. RETURN
*          R15. ENTRY
*
         EJECT
CXYPSCAN CSECT
         EQUAT
         EJECT
         SAVE  (14,12)
         BALR  R10,R0              FIRST BASE REG
         USING *,R10,R11,R12
         LA    R11,2048(R10)       SECOND
         LA    R11,2048(R11)         BASE REG
         LA    R12,2048(R11)       THIRD
         LA    R12,2048(R12)         BASE REG
         LR    R7,R1               SAVE PARM POINTER
         LR    R8,R13              SAVE CALLER SAVE AREA POINTER
         LA    R0,WORKSIZE
         GETMAIN R,LV=(R0)         GET A SAVE/WORK AREA
         USING WORK,R13            ADDRESSABILITY
         LR    R13,R1                 SAVE/WORK AREA
         STM   R0,R1,WORKSAVE      SAVE INFO ON GOTTEN CORE
         ST    R13,8(R8)           POINT TO NEW SAVE AREA IN OLD
         ST    R8,4(R13)           POINT TO OLD SAVE AREA IN NEW
         LR    R1,R7               RESTORE PARM POINTER
         MVI   CC,C' '                  CLEAR PRINT
         MVC   CC+1(CLEARSZE-1),CC        WORK AREAS
         MVI   BLANKS,C' '              CLEAR AN AREA TO CHECK
         MVC   BLANKS+1(72),BLANKS        FOR ALL BLANK ARGUMENTS
         L     R2,0(R1)            LOAD ADDRESS OF PARMS
         LH    R1,0(R2)            LOAD LENGTH OF PARMS
         LTR   R1,R1               ANY PARMS SPECIFIED
         BZ    OPENFLS             NO PARMS
         LA    R2,2(R2)            POINT PAST LENGTH FIELD
         LA    R1,1(R1)            ADD 1 TO PARMS CNT FOR
*                                  BYPASS OF , BETWEEN PARMS
         MVC   MEMLSTTB,BLANKS     CLEAR
         MVC   MEMFROM,HEXZEROS      MEMBER
         MVC   MEMTO,FS                LISTS
PARMSCAN EQU   *
         BCTR  R1,R0               BYPASS , BETWEEN PARMS
         LA    R3,PARMHOLD         POINT R3 TO PARMHOLD
         XR    R4,R4               ZERO THE
         XR    R5,R5                 COUNTERS
SCANLOOP EQU   *
         CLI   0(R2),C','          IS CHAR A ,
         BE    PARMSRC             YES - GO SEARCH PARM TABLE
         CH    R4,=H'19'           IS PARM GT 19 CHARS
         BE    ERROR0              YES - PARM ERROR
         MVC   0(1,R3),0(R2)       SAVE PARM CHARACTER
         LA    R2,1(R2)            UPDATE
         LA    R3,1(R3)              POINTERS
         LA    R4,1(R4)                COUNTER
         BCT   R1,SCANLOOP         END OF PARM LIST
PARMSRC  EQU   *
         LA    R6,PARMTAB          POINT TO PARM TABLE
SCRLOOP  EQU   *
         CLI   0(R6),X'FF'         IS THIS END OF TABLE
         BE    ERROR0              YES
         IC    R5,0(R6)            GET LENGTH OF ENTERED PARM
         CR    R4,R5               IS THIS ENTRY CORRECT LENGTH
         BNE   SRCBUMP             NO
         IC    R5,1(R6)            GET LENGTH OF COMPARE IN PARMTAB
         BCTR  R5,R0               REDUCE LENGTH BY 1 FOR COMPARE
         EX    R5,PARMCOMP         IS THIS CORRECT ENTRY
         BNE   SRCBUMP             NO
         OC    PARMSWIT,2(R6)      YES SET SWIT FOR THIS PARM
         TM    3(R6),X'F0'         IS THIS A MEMBER LIST PARM
         BZ    *+24                NO
         ST    R7,FWORD            SAVE POINTER TO PARMS
         BAL   R7,MEMLSTRT         GO VALIDATE REST OF MEMBER PARM
         L     R7,FWORD            RESTORE POINTER TO PARMS
         TM    SWIT+3,X'01'        IS IT VALID
         BO    ERROR0              NO
         LTR   R1,R1               ANY MORE CHAR
         BZ    OPENFLS
         LA    R2,1(R2)            GO PAST ,
         B     PARMSCAN
SRCBUMP  EQU   *
         IC    R5,1(R6)            RESTORE LENGTH FOR UPDATE OF PARMTAB
         AR    R6,R5               GO TO THE
         LA    R6,4(R6)              NEXT ENTRY
         B     SCRLOOP                 IN PARM TAB
PARMCOMP EQU   *
         CLC   PARMHOLD(0),4(R6)
ERROR0   EQU   *
         MVI   CC,C'1'
         MVC   PRNTWRK(L'ERR0),ERR0     ERROR MESSAGE
         L     R1,0(R7)            GET ADDRESS OF PARMS
         LH    R2,0(R1)            LENGTH OF PARMS
         BCTR  R2,R0               REDUCE BY 1 FOR MOVE
         EX    R2,PRMERMOV         MOVE PARMS TO PRINT
         OI    SWIT+1,X'02'        SET INVALID PARM SWITCH
         B     OPENFLS
PRMERMOV MVC   PRNTWRK+22(0),2(R1)
         EJECT
OPENFLS  EQU   *
         OPEN  (LIST,(OUTPUT),MESSAGE,(OUTPUT),INDEX,(OUTPUT))
         TM    PARMSWIT,X'01'      WAS LIST ALL SPECIFIED
         BNO   *+12                NO
         NI    PARMSWIT,X'EF'      YES - TURN OFF LIST HIT BIT
         B     *+8                   EVEN IF SPECIFIED BY A PARM
         OI    PARMSWIT,X'10'      MAKE LIST HIT THE DEFAULT
         TM    SWIT+1,X'02'        IS INVALID PARM SW ON
         BNO   GETARG              NO
         PUT   MESSAGE,CC
         MVI   RETCODE,X'18'
         B     CLOSEUR
GETARG   EQU   *
         TM    PARMSWIT,X'20'      ARE ARGS TO BE ENTERED VIA CONSOLE
         BNO   OPENCARD            NO
         MVC   HDRM1+1(3),HDRM1A   CHANGE PRINT HEADING
*                                    TO SHOW CONSOLE ENT
         B     GETCONSL            GO GET FIRST CONSOLE ENT
OPENCARD EQU   *
         OPEN  (CARD)              OPEN CARD FILE
         B     GETCARD             GO GET FIRST CONTROL CARD
GETCONSL EQU   *
         MVI   CARDIN,C' '         CLEAR CARD I/O
         MVC   CARDIN+1(79),CARDIN   AREA FOR CONSOLE
         UNPK  CONSLENT+40(3),NEXTARG   SHOW ARGUMENT NUM
         OI    CONSLENT+42,X'F0'          TO BE ENTERED NEXT
         XC    CONSLECB,CONSLECB   CLEAR ECB
         CNOP  0,4
CONSLENT EQU   *
         WTOR  'CXYPSCAN ENTER ARGUMENT XXX; ENTER /* OR HIT EOB TO PROX
               CESS ',CARDIN,80,CONSLECB
         WAIT  ECB=CONSLECB
         CLC   CARDIN(2),=C'/*'    IS THIS /*
         BE    ENDCARD             YES - END OF INPUT
         CLC   CARDIN(2),=C'  '    IS THIS EOB
         BE    ENDCARD             YES - END OF INPUT
         B     ADDARGCT
GETCARD  EQU   *
         GET   CARD,CARDIN
ADDARGCT EQU   *
         AP    CRDCT,=P'1'         ADD TO CARD COUNT
         CP    CRDCT,=P'1'         IS THIS FIRST CONTROL CARD
         BNE   PROCESCD            NO
         LA    R1,ARGENTSZ         YES - STORE SIZE FOR
         STH   R1,ARGSZHLD           LATTER REFERENCE AND
         MH    R1,=H'256'              MULTIPLY BY NUMBER OF
         LR    R0,R1                     ARGUMENTS FOR A TABLE
         GETMAIN R,LV=(R0)
         LR    R8,R1               SET UP ADDRESSABILITY
         USING ARGTAB,R8             TO THE ARGUMENT TABLE
         STM   R0,R1,ARGSAVE       SAVE POINTERS TO GOTTEN CORE
         OI    SWIT+1,X'08'        CORE GOTTEN FOR ARGUMENT TABLE
         TM    PARMSWIT,X'04'      WAS PATTERNS ENTERED AS PARM
         BNO   PROCESCD            NO
         OI    SWIT+2,X'80'        YES - FORCE ALL ARGUMENTS
*                                    TO BE CHECKED FOR PATTERNS
PROCESCD EQU   *
         XC    SEARCHLD,SEARCHLD   CLEAR SEARCH LIMIT FIELDS
         CLC   CARDIN(2),=C'00'    TREAT 00 IN
         BNE   *+10                  COLUMN 1 + 2
         MVC   CARDIN(2),=C'01'        SAME AS 01
         CLC   CARDIN(4),=C'0100'  DO WE WANT TO SEARCH WHOLE RECORD
         BE    CHECKOPT            YES
         OI    SWIT+3,X'80'        GO VALIDATE SEARCH
         BAL   R7,LIMITRTE           LIMIT ENTRY
         TM    SWIT+3,X'40'        IS IT VALID
         BO    ERROR1              NO
CHECKOPT EQU   *
         CLI   CARDIN+4,C'0'
         BE    CHECKNUM
         CLI   CARDIN+4,C'E'       IN AND PROCESSING AN E IN
         BNE   *+22                   POSITION 5 INDICATES THAT
         TM    PARMSWIT,X'08'           IF THIS ARGUMENT IS FOUND
         BO    CHECKNUM                   IT WILL CAUSE MEM NOT FOUND
         MVC   ERR1RC,=C'04'       EXCLUDE INVALID IN OR PROCCESSING
         B     ERROR1
         CLI   CARDIN+4,C'P'       IS THIS ARGUMENT A PATTERN
         BE    *+14
         MVC   ERR1RC,=C'05'       SHOW INVALID ENTRY IN COLUMN 5
         B     ERROR1
         OI    SWIT+2,X'40'        FLAG ARGUMENT ENTERED AS PATTERN
CHECKNUM EQU   *
         CLC   CARDIN+5(2),ASTERICS     CALCULATE LENGTH ?
         BNE   VALNUM                   NO
         LA    R1,CARDIN+6         CHECK FOR A
         LA    R2,CARDIN+70          NON BLANK CHAR
         CLI   0(R2),C' '              TO INDICATE THE
         BNE   *+8                       END OF ARGUMENT
         BCT   R2,*-8
         CR    R1,R2               TREAT ALL BLANKS
         BNE   *+14           AS ERROR CONDITION
BLANKARG EQU   *
         MVC   ERR1RC,=C'06'
         B     ERROR1
         SR    R2,R1               CALCULATE LENGTH
         CVD   R2,DWORD              OF ARGUMENT AND
         OI    DWORD+7,X'0F'           PUT IN CARDIN AREA
         UNPK  CARDIN+5(2),DWORD
         LR    R1,R2               LENGTH TO R1
         B     CHKSRLIM
VALNUM   EQU   *
         CLI   CARDIN+5,C'0'       MAKE
         BL    INVARGCH              SURE
         CLI   CARDIN+5,C'9'           THAT
         BH    INVARGCH                  ARG
         CLI   CARDIN+6,C'0'               LENGTH
         BL    INVARGCH                      IS VALID
         CLI   CARDIN+6,C'9'                   NUMERIC
         BNH   *+14
INVARGCH EQU   *
         MVC   ERR1RC,=C'07'       SHOW INVALID ARGUMENT LENGTH
         B     ERROR1
         PACK  DWORD,CARDIN+5(2)
         CVB   R1,DWORD            LENGTH OF SEARCH ARGUMEMT
         CH    R1,=H'0'            IS SA GREATER THAN 0
         BNH   INVARGLN            NO - ERROR
         CH    R1,=H'73'           IS SA LESS THAN 74
         BNH   *+14
INVARGLN EQU   *
         MVC   ERR1RC,=C'08'       SHOW INVALID ARGUMENT LENGTH
         B     ERROR1
         BCTR  R1,0
         STC   R1,*+5              TREAT ARGUMENT
         CLC   CARDIN+7(0),BLANKS    OF ALL BLANKS
         BE    BLANKARG
         LA    R1,1(R1)
CHKSRLIM EQU   *
         CLC   SEARCHLD,=F'0'      WERE SEARCH LIMITS ENTERED
         BE    CHECKPAT            NO
         CLC   SRLGNBIN,=H'0'      WAS EOR SPECFIFIED FOR LIMIT
         BNE   *+16                NO
         LA    R2,255              YES - CALCULATE LENGTH
         SH    R2,SRBEGBIN           OF ARGUMT LIMIT RANGE
         B     *+8
         LH    R2,SRLGNBIN         LENGTH OF
         CR    R1,R2                 ARGUMENT MUST
         BNH   CHECKPAT                BE EQUAL TO OR
         MVC   ERR1RC,=C'03'             LOWER THAN THE
         B     ERROR1                      SEARCH LIMIT RANGE
CHECKPAT EQU   *
         TM    SWIT+2,X'C0'        WAS ARGUMENT ENTERED AS PATTERN
         BZ    *+32
         LR    R2,R1               POINT R2 TO LENGTH
         LA    R5,CARDIN+7         POINT R5 TO ARGUMENT
         BAL   R4,PATTRTNE         GO CHECK FOR A PATTERN
         TM    SWIT+2,X'20'        IF 1ST CHARACTER IS SHOWN
         BNO   *+14                  AS PATTERN IT IS AN ERROR
         MVC   ERR1RC,=C'09'
         B     ERROR1
         AP    ARGCT,=P'1'         ADD 1 TO ARGUMENT COUNT
         CP    ARGCT,=P'255'       OVER 255 ARGUMENTS ENTERED
         BH    ERROR5              YES
         AP    NEXTARG,=P'1'       UP COUNT FOR NEXT CONSOLE MSG
         TM    PARMSWIT,X'08'      IS THIS AND PROCESSING
         BNO   ARGTBBLD            NO - CONTINUE
         CP    ARGCT,=P'1'         YES - IS THIS FIRST ARGUMENT
         BNE   ARGTBBLD            NO - CONTINUE
         ST    R1,FWORD            SAVE BINARY LENGTH OF ARG
         LA    R0,64               YES - GET CORE FOR A BIT PATTERN
         GETMAIN R,LV=(R0)           TABLE TO BE USED TO CHECK FOR HITS
         XC    0(64,R1),0(R1)      CLEAR TABLE
         STM   R0,R1,PTRNSAVE      SAVE TABLE INFO
         OI    SWIT+1,X'01'        SHOW CORE GOTTEN
         L     R1,FWORD            RESTORE BINARY LENGTH OF ARG
ARGTBBLD EQU   *
         MVI   ARGFL,X'00'                   CLEAR 2
         MVC   ARGFL+1(ARGENTSZ*2-1),ARGFL     ENTRIES
         BCTR  R1,R0               SAVE SA LENGTH IN
         STC   R1,ARGLNG             THE ARGUMENT TABLE
         STC   R1,*+5              MOVE ARGUMENT TO
         MVC   ARG(0),CARDIN+7       THE ARGUMEMT TABLE
         STC   R1,MOVEARGP+1       TO MOVE ARGUMENT TO PRINT
         UNPK  ARGNO,ARGCT         USE ARGUMENT COUNT AS THE
         OI    ARGNO+2,X'F0'         ARGUMENT NUMBER IN TABLE
         ZAP   DWORD,ARGCT         SAVE ARGUMENT
         CVB   R6,DWORD              NUM TO BINARY
         STC   R6,ARGNOBIN             AND SAVE IN TAB
         TM    PARMSWIT,X'08'      IS THIS AND PROCESSING
         BNO   *+38                NO
         CLI   CARDIN+4,C'E'       IS THIS ARG TO BE EXCLUDED
         BNE   *+18                NO
         OI    ARGFL,X'10'         YES - FLAG ARG AS EXCLUSION
         AP    EXCCT,=P'1'         ADD 1 TO EXCLUSION COUNT
         B     *+16                DO NOT SET CONTROL BITS FOR
*                                    ARGUMENTS THAT ARE EXCLUDED
*                                      IF EXCLUDED ARGUMENT(S) ARE
*                                        FOUND MEMBER COMP WILL FAIL
         L     R5,PTRNSAVE+4       GO SET BIT FOR THIS
         LA    R5,32(R5)             ARGUMENT IN CONTROL
         BAL   R7,BITSETR              FIELD OF BIT PAT TAB
         TM    SWIT+2,X'40'        ARE THERE +!@#(S) IN PATTERN
         BNO   *+12                NO
         OI    ARGFL,X'08'         YES FLAG IN ARGUMENT TABLE
         NI    SWIT+2,X'BF'
         BAL   R2,CHKMSGHD         GO CHECK FOR HEADING
         UNPK  PRNTWRK(3),CRDCT    CARD COUNT
         OI    PRNTWRK+2,X'F0'       TO PRINT.
         UNPK  PRNTWRK+4(3),ARGCT  ARG COUNT
         OI    PRNTWRK+6,X'F0'       TO PRINT
         MVI   PRNTWRK+7,C' '                CLEAR REST
         MVC   PRNTWRK+8(123),PRNTWRK+7        OF WORK AREA
         CLC   SEARCHLD,=F'0'      WERE SEARCH LIMITS ENTERED
         BNE   *+20                YES
         MVC   PRNTWRK+8(3),=C'001'     SHOW COLUMN 1 TO EOR
         MVC   PRNTWRK+12(3),=C'EOR'      FOR NO SEARCH LIMITS
         B     MOVEARGO
         OI    ARGFL,X'04'         SET FLAG FOR SEARCH LIMITS
         LH    R2,SRBEGBIN         PUT BEGINNING
         CVD   R2,DWORD              COLUMN OF SEARCH
         OI    DWORD+7,X'0F'           LIMIT TO PRINTER
         UNPK  PRNTWRK+8(3),DWORD
         LA    R3,RECWORKA         PUT BEGINNING
         BCTR  R3,R0                 BYTE OF SEARCH
         AR    R3,R2                   LIMIT INTO THE
         ST    R3,ARGLOLIM               TABLE ENTRY
         CLC   SRLGNBIN,=H'0'           DOES LENGTH HAVE 0
         BNE   *+22                     NO
         MVC   PRNTWRK+12(3),=C'EOR'    YES -SHOW
         LA    R3,RECWORKA+254            EOR AS SEARCH
         ST    R3,ARGUPLIM                  UPPER LIMIT IN
         B     MOVEARGO                       BOTH PRINT + TABLE
         LH    R3,SRLGNBIN         CALCULATE SEARCH
         AR    R3,R2                 UPPER LIMIT
         BCTR  R3,R0
         CVD   R3,DWORD            PUT SEARCH
         OI    DWORD+7,X'0F'         UPPER LIMIT
         UNPK  PRNTWRK+12(3),DWORD     TO PRINTER
         L     R2,ARGLOLIM         PUT SEARCH
         AH    R2,SRLGNBIN           UPPER LIMIT
         BCTR  R2,R0                   INTO THE TABLE
         ST    R2,ARGUPLIM               ENTRY FOR ARG
MOVEARGO EQU   *
         TM    ARGFL,X'18'         EXCLUSION AND/OR PATTERN
         BNZ   *+14                YES
         MVC   PRNTWRK+16(3),BLANKS     CLEAR OPT FIELD
         B     MOVECNTP
         XR    R2,R2
         IC    R2,ARGFL            ISOLATE BITS FOR
         N     R2,MASK1F             EXCLUDING ARGUMENTS
         SRL   R2,3                    AND SEARCH BY PATTERN
         MH    R2,=H'3'
         SH    R2,=H'3'
         LA    R3,PRNTTAB          SHOW EXCLUSION
         AR    R3,R2                 AND PATTERN SEARCH
         MVC   PRNTWRK+16(3),0(R3)      OPTION ON PRINTER
MOVECNTP EQU   *
         MVC   PRNTWRK+20(2),CARDIN+5   LENGTH TO PRINT
MOVEARGP EQU   *
         MVC   PRNTWRK+23(0),CARDIN+7   ARGUMENT TO PRINT
         ZAP   ARGTARG,=P'0'       ZERO COUNTERS
         ZAP   ARGTMEM,=P'0'         IN THE ARGUMENT
         ZAP   ARGTPDS,=P'0'           TABLE
         LA    R8,ARGENTSZ(R8)     POINT TO NEXT TABLE ENTRY
PRTMSGDT EQU   *
         PUT   MESSAGE,CC          PRINT DETAIL LINE
         IC    R1,LINCTM           INCREMENT
         LA    R1,1(R1)              PRINT LINE
         STC   R1,LINCTM               COUNT BY 1
         TM    PARMSWIT,X'20'      ARE ARGS BEING ENTERED VIA CONSOLE
         BO    GETCONSL            YES
         B     GETCARD             NO
ERROR1   EQU   *
         BAL   R2,CHKMSGHD         GO CHECK FOR HEADING
         UNPK  PRNTWRK(3),CRDCT    CARD COUNT
         OI    PRNTWRK+2,X'F0'       TO PRINT.
         MVC   PRNTWRK+4(3),ASTERICS
         MVC   PRNTWRK+8(2),ASTERICS
         MVC   PRNTWRK+8(L'ERR1),ERR1        ERROR MESSAGE 1 TO PRINT
         MVC   PRNTWRK+8+L'ERR1(80),CARDIN   ERROR CARD TO PRINT
         B     PRTMSGDT
CHKMSGHD EQU   *
         CLI   LINCTM,X'3A'        IS LINE COUNT GREATER THAN 58
         BH    *+10                YES - GO PRINT HEADING
         MVI   CC,C' '             NO - SET SINGLE
         BR    R2                    SPACE AND RETURN
         MVI   PRNTWRK,C' '
         MVC   PRNTWRK+1(131),PRNTWRK
         MVC   CC(L'HDRM1),HDRM1   MOVE IN HEADING
         PUT   MESSAGE,CC          PRINT HEADING
         MVC   CC(L'HDRM2),HDRM2   MOVE IN HEADING
         PUT   MESSAGE,CC          PRINT HEADING
         MVI   CC,C'0'             DOUBLE SPACE FOR 1ST DETAIL LINE
         MVI   LINCTM,X'03'        RESET LINE COUNT
         BR    R2                  RETURN
         EJECT
FINDDD   EQU   *
         EXTRACT TIOTHOLD,FIELDS=TIOT   GET TIOT ADDRESS
         L     R3,TIOTHOLD         TASK I/O TABLE ADDRESS
         LA    R3,24(R3)           FIRST DD ENTRY
         XR    R4,R4
TIOTLOOP EQU   *
         IC    R4,0(R3)            LENGTH OF DD ENTRY
         LTR   R4,R4               IS IT 0 LENGTH
         BC    7,*+16              NO - CHECK FOR ELIGIBLE DD CARD
         TM    SWIT+1,X'10'        HAVE WE HAD A GOOD DD CARD IN RUN
         BZ    ERROR4              NO - ERROR
         B     OPTPRINT            YES - GO PRINT OPTIONS FOR RUN
         CLC   4(4,R3),=C'PROC'    IS THIS AN ELIGIBLE DD CARD
         BE    PROCESDD            YES - GO PROCESS
         CLC   4(3,R3),=C'PDS'     IS THIS AN ELIGIBLE DD CARD
         BE    PROCESDD            YES - GO PROCESS
         AR    R3,R4               NO - GO CHECK
         B     TIOTLOOP              THE NEXT ENTRY
PROCESDD EQU   *
         MVC   DIR+40(8),4(R3)     MOVE DDNAME TO DIR DCB
         MVC   MEM+40(8),4(R3)     MOVE DDNAME TO MEM DCB
         MVI   PRNTWRK,C' '
         MVC   PRNTWRK+1(131),PRNTWRK
         MVC   PRNTWRK(L'STUBDDN),STUBDDN
         MVC   PRNTWRK+L'STUBDDN(8),4(R3)
         MVC   DDNAME,4(R3)
         OI    SWIT+1,X'10'        INDICATE AT LEAST ONE GOOD DD CARD
         AR    R3,R4               POINT TO NEXT TIOT ENTRY
         ST    R3,TIOTHOLD         SAVE POINTER TO NEXT TIOT ENTRY
         CLI   LINCTM,X'2D'        GO TO
         BNL   *+12                  NEW PAGE
         MVI   CC,C'0'                 IF LINCNTM
         B     *+12                      EXCEEDS 45
         MVI   CC,C'1'                     AND RESET
         MVI   LINCTM,X'00'                  TO ZERO
         PUT   MESSAGE,CC
         LA    R5,JFCB             POINT TO
         LR    R6,R5                 THE JFCB
         ST    R6,F1DSCB+4         DSN POINTER TO OBTAIN CAMLST
         LA    R6,118(R6)          VOL SER POINTER
         ST    R6,F1DSCB+8           TO OBTAIN CAMLST
         LA    R6,F1WORK           I/O AREA POINTER
         ST    R6,F1DSCB+12          TO OBTAIN CAMLST
         ST    R5,XLIST            JFCB POINTER TO
         MVI   XLIST,X'87'           THE DCB EXIT LIST
         RDJFCB MEM
         MVC   PRNTWRK(L'STUBDSN),STUBDSN
         MVC   PRNTWRK+L'STUBDSN(44),JFCB
         MVI   CC,C' '
         PUT   MESSAGE,CC
         MVI   PRNTWRK+L'STUBDSN,C' '
         MVC   PRNTWRK+L'STUBDSN+1(43),PRNTWRK+L'STUBDSN
         MVC   PRNTWRK(L'STUBVOL),STUBVOL
         MVC   PRNTWRK+L'STUBVOL(6),JFCB+118
         MVI   CC,C' '
         PUT   MESSAGE,CC
         OBTAIN F1DSCB
         STC   R15,OBTNRCHD        SAVE OBTAIN RETURN CODE
         MVC   PRNTWRK(L'STUBATTR),STUBATTR
         LH    R6,F1WORK+44
         OI    SWIT+2,X'08'       GO TO SUB ROUTINE
         BAL   R7,PRNTBRTE          TO BUILD PRINT TABLE
         LH    R6,F1WORK+44
         CVD   R6,DWORD
         TM    F1WORK+38,X'42'     IS DSORG PO OR PS
         BNZ   *+18                YES
         MVC   PRNTWRK+L'STUBATTR(3),=C'UNS' SHOW NOT SUPPORTED
         OI    SWIT+1,X'40'                    AND SET FILE ERROR
         B     DISRECFM
         TM    F1WORK+38,X'02'     IS DSORG PO
         BNO   *+18                NO
         MVC   PRNTWRK+L'STUBATTR(3),=C'PO ' SHOW PARTITIONED ORG
         NI    SWIT+4,X'DF'                    CLEAR SEQ FILE SWIT
         B     DISRECFM
         MVC   PRNTWRK+L'STUBATTR(3),=C'PS ' SHOW SEQUENTIAL
         OI    SWIT+4,X'20'        SET SEQUENTIAL FILE SWIT
         MVI   JFCB+98,X'40'       SET JFCB TO SEQUENTIAL
         OI    JFCB+52,X'08'       DO NOT WRITE JFCB BACK
DISRECFM EQU   *
         MVI   PRNTWRK+L'STUBATTR+3,C'-'
         TM    F1WORK+40,X'C0'     IS RECFM EITHER
         BM    *+18                  FIXED OR VARIABLE
         MVC   PRNTWRK+L'STUBATTR+4(3),=C'UNS' SHOW NOT SUPPORTED
         OI    SWIT+1,X'40'                      AND SET FILE ERROR
         B     DISLRECL
         TM    F1WORK+40,X'80'     IS RECFM FIXED
         BNO   *+36                NO
         MVC   PRNTWRK+L'STUBATTR+4(3),=C'F  ' SHOW FIXED RECFM
         NI    SWIT+3,X'FB'                  CLEAR VARIABLE SWITCH
         MVC   HDRS21+130(3),BLANKS
         TM    F1WORK+40,X'10'     ARE RECORDS BLOCKED
         BNO   DISLRECL            NO
         MVI   PRNTWRK+L'STUBATTR+5,C'B'      YES - SHOW IT
         B     DISLRECL
         MVC   PRNTWRK+L'STUBATTR+4(3),=C'V  ' SHOW VARIABLE RECFM
         OI    SWIT+3,X'04'                  SET VARIABLE SWITCH
         MVC   HDRS21+130(3),HDRS21A
         LA    R3,PRNTWRK+L'STUBATTR+5
         TM    F1WORK+40,X'10'     ARE RECORDS BLOCKED
         BNO   *+12                NO
         MVI   0(R3),C'B'          YES - SHOW IT
         LA    R3,1(R3)
         TM    F1WORK+40,X'08'     ARE RECORDS SPANNED
         BNO   DISLRECL            NO
         MVI   0(R3),C'S'          YES - SHOW IT
         OI    SWIT+1,X'40'        SET FILE ERROR SWITCH
DISLRECL EQU   *
         MVI   PRNTWRK+L'STUBATTR+7,C'-'          SHOW
         UNPK  PRNTWRK+L'STUBATTR+8(5),DWORD        LRECL
         OI    PRNTWRK+L'STUBATTR+12,X'F0'            OF THE
         MVI   PRNTWRK+L'STUBATTR+13,C'-'               DATA SET
         LTR   R6,R6
         BC    7,*+12
         OI    SWIT+1,X'40'
         B     DISBLKSZ
         LH    R5,F1WORK+42
         LTR   R5,R5
         BC    7,*+12
         OI    SWIT+1,X'40'
         B     DISBLKSZ
         TM    SWIT+3,X'04'        IS RECFM VARIABLE
         BO    DISBLKSZ            YES
         XR    R4,R4
         DR    R4,R6
         LTR   R4,R4
         BC    8,DISBLKSZ
         OI    SWIT+1,X'40'
DISBLKSZ EQU   *
         LH    R5,F1WORK+42
         CVD   R5,DWORD
         UNPK  PRNTWRK+L'STUBATTR+14(5),DWORD      SHOW BLKSIZE
         OI    PRNTWRK+L'STUBATTR+18,X'F0'            OF THE DATA SET
         PUT   MESSAGE,CC
         CLI   OBTNRCHD,X'00'      DID OBTAIN FIND DATA SET ON VOLUME
         BE    *+16                YES
         LA    R5,ERR2C            POINT TO MSG FOR DATA SET NOT FOUND
         OI    SWIT+1,X'40'        SET INVALID FILE SWITCH
         B     ERROR2
         TM    F1WORK+38,X'42'     IS DSORG PO OR PS
         BNZ   *+18                YES
         MVC   ERR2(L'ERR2A),ERR2A      POINT TO BAD
         LA    R5,ERR2                    DSORG MESSAGE
         B     ERROR2
         MVC   ERR2(L'ERR2B),ERR2B      POINT TO INVALIB
         LA    R5,ERR2                    LRECL/BLKSIZE MSG
         TM    SWIT+1,X'40'        WAS INVALID FILE SWITCH ALREADY
*                                    SET BECAUSE OF BAD LRECL/BLKSIZE
*                                      OR BECAUSE DSORG NOT SUPPORTED.
         BO    ERROR2
         MVC   NOLNEHLD,SWIT+2    ISOLATE LENTH OF
         NI    NOLNEHLD,X'03'       RECORDS BITS FOR PRINT
         B     GO
         EJECT
ENDCARD  EQU   *
         MVI   LINCTM,X'36'        RESET MESSAGE LINE COUNTER
         CP    CRDCT,=P'0'         DID WE GET ANY CARDS OR CONSOLE ENTS
         BE    ERROR3              NO
         CP    ARGCT,=P'0'         DID WE GET ANY VALID ARGUMENTS
         BNE   *+12                YES - CONTINUE
         MVI   RETCODE,X'0C'       NO - GO
         B     CLOSEUR               TO EOJ
         CP    ARGCT,EXCCT         WERE ALL ARGS EXCLUDED
         BNE   *+12                NO
         MVI   RETCODE,X'1C'       YES - ERROR COND
         B     CLOSEUR               WITH RETURN CODE 28
         NI    SWIT+2,X'3F'        TURN OFF PATTERN ENTERED FLAGS
         XC    TRTTAB,TRTTAB
         CP    ARGCT,=P'1'         IS THERE 1 VALID ARGUMENT
         BNE   SORTBARG            NO - GO SORT BY ARGUMENT
         NI    PARMSWIT,X'F7'      TURN OFF AND PROCESSING SWIT
         NI    PARMSWIT+1,X'F7'    TURN OFF RECORD PROCESSING SWIT
         B     BLDTRTTB              AND BYPASS SORT BECAUSE WE ONLY
*                                      HAVE ONE ARGUMENT FOR THIS RUN
SORTBARG EQU   *
         BAL   R2,SORTRTNE
BLDTRTTB EQU   *
         L     R8,ARGSAVE+4        GET BEGINNING OF ARGUMENT TABLE
         LA    R1,1                BINARY NUMBER OF 1ST ENT IN ARG TAB
BTLOOP1  EQU   *
         XR    R2,R2
         IC    R2,ARG              PLACE BINARY NO. OF THE TABLE
         STC   R1,TRTTAB(R2)         IN TRT FOR FIRST CHAR. OF ARG.
BTLOOP2  EQU   *
         CLC   ARG(1),ARG+ARGENTSZ      IS FIRST CHAR OF NEXT ARG SAME
         BNE   *+16                NO
         LA    R1,1(R1)            YES - UP BIN NO OF ARG TAB ENTRY
         LA    R8,ARGENTSZ(R8)     POINT TO
         B     BTLOOP2               NEXT ENTRY
         OI    ARGFL,X'80'         FLAG THIS AS LAST ARGUMENT
*                                    BEGINNING WITH THIS CHARACTER
         CLI   ARG+ARGENTSZ,X'00'  IS THIS LAST ENT IN TABLE
         BE    *+16                YES
         LA    R1,1(R1)            NO - UP BIN NO OF ARG TAB ENTRY
         LA    R8,ARGENTSZ(R8)     GO BUILD NEXT
         B     BTLOOP1               ENTRY IN TRT
         MVC   STOPPER,ARG         USE 1ST CHAR OF LAST ARG
         B     FINDDD
         EJECT
ERROR3   EQU   *
         MVI   CC,C'1'
         MVC   PRNTWRK(L'ERR3),ERR3
         PUT   MESSAGE,CC
         MVI   RETCODE,X'0C'
         B     CLOSEUR
ERROR4   EQU   *
         MVI   CC,C'0'
         MVC   PRNTWRK(L'ERR4),ERR4
         PUT   MESSAGE,CC
         MVI   RETCODE,X'14'
         B     CLOSEUR
ERROR5   EQU   *
         MVI   CC,C'0'
         MVI   PRNTWRK,C' '
         MVC   PRNTWRK+1(131),PRNTWRK
         MVC   PRNTWRK(L'ERR5),ERR5
         PUT   MESSAGE,CC
         MVI   RETCODE,X'10'
         B     CLOSEUR
         EJECT
GO       EQU   *
         CALL  DATETIME,(STARTTME,JULDT,DODDT,STARTCDT,CMPLCD)
         TM    SWIT+4,X'20'       IS DSORG PS
         BO    OPENJMEM           YES - BYPASS OPEN OF DIR FILE
         OPEN  (DIR)
OPENJMEM EQU   *
         OPEN (MEM),TYPE=J
         LH    R0,MEM+62           BLOCK SIZE
         SLL   R0,1                DOUBLE FOR TWO BUFFERS
         AH    R0,=H'512'          ADD STORAGE FOR DIR BUFFERS
         GETMAIN R,LV=(R0)         GET BUFFERS
         STM   R0,R1,IOARSAVE      SAVE FOR FREEMAIN
         OI    SWIT,X'02'          INDICATE WE GOT BUFFERS
         TM    SWIT+4,X'20'       IS DSORG PS
         BNO   *+16               NO
         MVC   SEQDIRN2,DDNAME    USE # AND FIRST 7 BYTES OF
         MVC   0(22,R1),SEQDIR      DDNAME AS A DUMMY DIR ENTRY
         ST    R1,DIRBADDR         STORE ADRESS OF FIRST DIR BUFFER
         LA    R1,256(R1)
         ST    R1,DIRBADDR+4       STORE ADRESS OF SECOND DIR BUFFER
         LA    R1,256(R1)
         SH    R0,=H'512'          BACK OUT SIZE OF DIR BUFFERS
         ST    R1,MEMBADDR         STORE ADDRESS OF FIRST BUFFER
         SRL   R0,1                COMPUTE ADDRESS OF
         AR    R1,R0                 SECOND BUFFER
         ST    R1,MEMBADDR+4       STORE ADDRESS OF SECOND BUFFER
         LA    R1,DIR              READ DIRECTORY
         BAL   R2,READ
         OI    SWIT,X'20'          SUB READS FOR DIR DCB
FRSTDIR  EQU   *
         LR    R4,R1               POINT TO DIR I/O AREA
         LH    R9,0(R4)            NO. OF BYTES
         SH    R9,=H'2'              USED
         LA    R4,2(R4)            POINT TO FIRST ENTRY
         ST    R4,DIRRECAD         SAVE ADD OF CURRENT DIR RECORD
PROCESSD EQU   *
         CLC   0(8,R4),FS          IS THIS SENT RECORD
         BNE   *+20                NO
         OI    SWIT,X'10'          YES GO
         LA    R1,DIR                FLUSH
         BAL   R2,READ                 LAST I/0
         B     ENDUP
         MVC   MEMBER,0(R4)        SAVE MEMBER NAME
         MVC   TTRN(3),8(R4)       SAVE TTR FOR FIND AND CONVERT
         TM    11(R4),X'80'        IS MEMBER AN ALIAS
         BNO   *+12                NO
         TM    PARMSWIT+1,X'02'    ARE WE PROCCESSING ALIASES
         BNO   GNEXTDIR            NO
         TM    PARMSWIT+1,X'F0'    ARE THERE MEMBER LIST PARM/S
         BZ    *+20                NO
         OI    SWIT+3,X'02'        YES GO CHECK FOR A
         BAL   R7,MEMLSTRT           MATCH WITH MEMBER
         TM    SWIT+3,X'01'        DOES IT MATCH
         BNO   GNEXTDIR            NO
         AP    SCANMEMS,=P'1'      ADD 1 TO NUMBER OF MEMBERS
         B     SRCHMEM
GNEXTDIR EQU   *
         L     R4,DIRRECAD         RESTORE ADD OF LAST DIR RECORD
         XR    R3,R3
         IC    R3,11(R4)           NO. OF
         N     R3,MASK1F             USER
         SLL   R3,1                    HALFWORDS
         AH    R3,=H'12'           SIZE OF BASIC ENTRY
         AR    R4,R3               POINT TO NEXT ENTRY IN PDS
         SR    R9,R3               SUBTRACT NO. OF BYTES USED
         ST    R4,DIRRECAD         SAVE ADD OF CURRENT DIR RECORD
         BC    2,PROCESSD          NOT END OF BLOCK
         LA    R1,DIR              READ NEXT
         BAL   R2,READ               DIR BLOCK
         B     FRSTDIR
ENDDIR   EQU   *
         LM    R5,R9,READSAVE
         B     ENDUP
         EJECT
SRCHMEM  EQU   *
         BAL   R2,FIND
         OI    SWIT,X'80'          MEMBER DCB
         LA    R1,MEM
         BAL   R2,READ
         OI    SWIT,X'40'          SUB READS FOR MEM DCB
RESCNT   EQU   *
         LH    R0,MEM+62           SUBTRACT
         L     R2,IOBADDR            RESIDUAL
         SH    R0,14(R2)               COUNT
         TM    SWIT+3,X'04'        IS RECFM VARIABLE
         BO    *+12                YES
         LH    R2,RECLEN           NO - PROCESS
         B     PROCESSM              AS FIXED LENGTH
         SH    R0,=H'4'            POINT TO FIRST RECORD
         LA    R1,4(R1)              IN A VARIABLE LENGTH BLOCK
PROCESSM EQU   *
         TM    SWIT+3,X'04'        IS RECFM VARIABLE
         BNO   SCANRECM            NO
         MVC   RECLENV,0(R1)       GET ACTUAL LENGTH
         LH    R2,RECLENV            OF THE DATA IN THIS
         SH    R2,=H'4'                RECORD TO BE USED IN
         STH   R2,RECLENV                SCAN PROCESS AND SAVE
         SH    R0,=H'4'            REDUCE BLOCK COUNT BY RDW
         LA    R1,4(R1)            POINT TO DATA FOR THIS RECORD
         CLC   RECLENV,=H'0'       IS THIS A NULL RECORD
         BE    *+12                YES
         NI    SWIT+4,X'7F'        NO TURN OFF NULL SWIT
         B     SCANRECM
         MVC   RECWORKA(6),=C'(NULL)'   YES MOVE PHONY
         MVC   RECWORKA+6(1),STOPPER      RECORD TO WORKAREA
         OI    SWIT+4,X'80'        SET NULL RECORD SWIT
         B     SAVERECP
SCANRECM EQU   *
         LR    R3,R2               LENGTH OF VARIABLE REC
         BCTR  R3,R0               REDUCE FOR MOVE
         CH    R3,=H'254'          IS LENGTH GT 255
         BNH   *+8                 NO
         LH    R3,=H'254'          YES - MOVE FIRST 255
         EX    R3,*+8              MOVE THE
         B     SAVERECP              REC TO WORKAREA
         MVC   RECWORKA(0),0(R1)       FOR THE FIRST SCAN
SAVERECP EQU   *
         STM   R0,R1,CNTADDR       SAVE BLK CNT/BUFF ADDRESS
         AP    SCANCNT,=P'1'        ADD 1 TO TOTAL RECORDS SCANNED
         BAL   R4,SCANRTNE
         TM    PARMSWIT+1,X'08'    IS THIS RECORD LEVEL LOGIC
         BNO   *+28                NO
         L     R5,PTRNSAVE+4       WERE ALL ARGS FOUND
         CLC   0(32,R5),32(R5)       IN THE RECORD SCANNED
         BNE   *+8                 NO
         OI    SWIT,X'0C'          YES - SHOW HITS FOR MEMBER AND PDS
         XC    0(32,R5),0(R5)      CLEAR ARGUMENT FOUND PART OF TABLE
         TM    SWIT,X'04'
         BNO   NEXTMREC
         TM    PARMSWIT,X'08'      IS THIS AND PROCESSING
         BNO   *+20                NO
         TM    PARMSWIT+1,X'08'    IS THIS RECORD LEVEL LOGIC
         BNO   NEXTMREC            NO
         LA    R5,*+26             CHANGE EOF ADDRESS OF MEM FILE
         STCM  R5,B'0111',MEM+33    IN CASE FLUSH CAUSES EOF CONDITION
         AP    HITSMEMS,=P'1'      ADD 1 TO COUNT OF MEMBER W/HITS
         OI    SWIT,X'10'          SET FLUSH BIT
         LA    R1,MEM              GO TO READ ROUT.
         BAL   R2,READ               TO FLUSH LAST READ
         LM    R5,R9,READSAVE      RESET REAL EOF
         LA    R5,ENDMEM             ADDRESS FLUSH
         STCM  R5,B'0111',MEM+33       OF I/O FOR MEM
         B     COPY                GO PRINT MEMBER
NEXTMREC EQU   *
         LM    R0,R1,CNTADDR
         TM    SWIT+3,X'04'        IS RECFM VARIABLE
         BO    *+12                YES
         LH    R2,RECLEN           LRECL - FIXED
         B     *+8
         LH    R2,RECLENV          LRECL - VARIABLE
         AR    R1,R2               POINT TO NEXT RECORD
         SR    R0,R2               REDUCE BLOCK COUNT BY LAST RECORD
         BC    4,ABND2             ERROR IF BLOCK COUNT GOES TO NEG
         BC    2,PROCESSM
         LA    R1,MEM              GET NEXT
         BAL   R2,READ               BLOCK
         B     RESCNT
ABND2    EQU  *
         ABEND 002,DUMP
         EJECT
COPY     EQU   *
         NI    SWIT,X'AB'          CLEAR SWITCH
         OI    SWIT,X'01'          IN COPY OPERATION
         OI    SWIT+3,X'08'        SHOW A HIT WAS MADE IN THIS RUN
         BAL   R2,RESETADD         RESET DECB AND BUFFER ADDRESSES
         BAL   R2,FIND
         CLI   LINCTI,X'3A'        DO WE PRINT HEADINGS FOR INDEX LIST
         BNH   BYPINDHD            NO
         MVC   CCI(53),HDRI1       YES - SET UP FIRST HEADING
         PUT   INDEX,CCI           PRINT FIRST HEADING
         MVI   CCI,C' '
         MVI   PRNTWRKI,C'('            SET UP VOL SER
         MVC   PRNTWRKI+7(2),=C')-'       AND DATA SET NAME
         MVC   PRNTWRKI+1(6),JFCB+118       AS SECOND HEADING
         MVC   PRNTWRKI+9(44),JFCB            FOR THE INDEX LIST
         PUT   INDEX,CCI           PRINT SECOND HEADING
         MVC   CCI(53),HDRI3       SET UP THIRD HEADING
         TM    PARMSWIT,X'40'      DO WE PRINT DISK ADDRESS
         BNO   *+10                NO
         MVC   CCI+44(8),HDRI3A    YES - ADJUST HEADING
         PUT   INDEX,CCI           PRINT THIRD HEADING
         MVI   LINCTI,X'04'        SET LINE CNT TO 4 AFTER HEADINGS
         MVI   CCI,C'0'            DOUBLE SPACE FOR FIRST DETAIL LINE
BYPINDHD EQU   *
         MVC   PRNTWRKI(8),MEMBER
         MVI   PRNTWRKI+8,X'40'
         MVC   PRNTWRKI+9(44),PRNTWRKI+8
         LA    R2,COPYFSRD         SET EXIT FOR FIRST PASS OF HEADINGS
NEWPG    EQU   *
         MVC   HDRS1VOL,JFCB+118   MOVE VOLSER TO 1ST SYSPRINT HEADING
         MVC   HDRS1DSN,JFCB       MOVE DSN TO 1ST SYSPRINT HEADING
         MVC   CC(133),HDRS1       MOVE 1ST SYSPRINT HEADING
         AP    PAGECNT,=P'1'       ADD 1 TO PAGE COUNT
         ED    PRNTWRK+126(6),PAGECNT   PUT PAGE CNT TO PRINT
         TM    PARMSWIT,X'80'      IS NO LIST SWIT ON
         BO    BYLISTHD            YES - BYPASS SYSPRINT HEADINGS
         TM    SWIT+1,X'20'        HAS PAGE # BEEN PUT IN INDEX LIST
         BO    *+20                YES
         MVC   PRNTWRKI+8(6),ZSUPMASK   PUT PAGE NO.
         ED    PRNTWRKI+8(6),PAGECNT      TO INDEX LIST
         OI    SWIT+1,X'20'
         PUT   LIST,CC
         MVC   CC(133),HDRS21      MOVE 2ND SYSPRINT HEADING
         PUT   LIST,CC
         MVI   PRNTWRK,C' '             CLEAR PRINT
         MVC   PRNTWRK+1(131),PRNTWRK     WORK AREA
         TM    SWIT+2,X'02'        IS REC LEN GT 85
         BZ    BYLISTHD            NO
         MVC   PRNTWRK+16(85),HDRS22    MOVE 3RD SYSPRINT HEADING
         PUT   LIST,CC
         TM    SWIT+2,X'01'        IS REC LEN GT 170
         BZ    BYLISTHD            NO
         MVC   PRNTWRK+16(85),HDRS23    MOVE 4TH SYSPRINT HEADING
         PUT   LIST,CC
BYLISTHD EQU   *
         XR    R6,R6              USE PRINT
         IC    R6,NOLNEHLD          LENGTH BITS
         LA    R6,2(R6)               TO CONTROL
         STC   R6,LINCT                 PRT OVERFLOW
         NI    SWIT+1,X'7F'        CLEAR HEADING SWITCH
         MVI   CC,C'0'
         MVC   PRNTWRK(8),MEMBER
         MVI   PRNTWRK+9,C' '
         BR    R2
COPYFSRD EQU   *
         TM    SWIT,X'40'          IS THIS 1ST TIME
         BO    NEXREC              NO
         LA    R1,MEM
         BAL   R2,READ
         OI    SWIT,X'40'          SUB READ FOR MEM
RESCNT2  EQU   *
         LH    R0,MEM+62           SUBTRACT
         L     R2,IOBADDR            RESIDUAL
         SH    R0,14(R2)               COUNT
         TM    SWIT+3,X'04'        IS RECFM VARIABLE
         BNO   PRINT               NO
         SH    R0,=H'4'            POINT TO FIRST RECORD
         LA    R1,4(R1)              IN A VARIABLE LENGTH BLOCK
PRINT    EQU   *
         TM    SWIT+1,X'80'        DO WE PRINT HEADINGS
         BNO   *+16                NO
         STM   R0,R1,CNTADDR       SAVE BLK CNT/BUFF ADDRESS
         BAL   R2,NEWPG            GO PRINT HEADINGS
         LM    R0,R1,CNTADDR
         AP    COPYCNT,=P'1'       ADD 1 TO TOTAL RECORDS COPIED
         UNPK  PRNTWRK+9(6),COPYCNT     USE COPYCNT AS
         OI    PRNTWRK+14,X'F0'           RELATIVE RECORD
         TM    SWIT+3,X'04'        IS RECFM VARIABLE
         BO    *+12                YES
         LH    R2,RECLEN           NO - PROCESS
         B     PRTRECMV              AS FIXED LENGTH
         LH    R3,RECLEN           TRUNCATE RECORD
         CH    R3,=H'255'            IF THE LENGTH OF
         BNH   *+8                     MAX REC GT 255
         LH    R3,RECLEN           USE THE
         MVI   RECWORKA,C' '         MAXIMUM
         SH    R3,=H'2'                LRECL FOR
         EX    R3,*+8                    THIS FILE
         B     *+10                        TO CLEAR
         MVC   RECWORKA+1(0),RECWORKA        WORK AREA
         MVC   RECLENV,0(R1)       GET ACTUAL LENGTH
         LH    R2,RECLENV            OF THE DATA IN THIS
         SH    R2,=H'4'                RECORD TO BE USED IN
         STH   R2,RECLENV                COPY PROCESS AND SAVE
         SH    R0,=H'4'            REDUCE BLOCK COUNT BY RDW
         LA    R1,4(R1)            POINT TO DATA FOR THIS RECORD
         CH    R2,=H'255'          IF RECORD IS
         BNH   *+8                   OVER 255 BYTES
         LH    R2,=H'255'              TRUNCATE FOR MOVE
         CLC   RECLENV,=H'0'       IS THIS A NULL RECORD
         BE    *+12                NO
         NI    SWIT+4,X'7F'        NO TURN OFF NULL SWIT
         B     PRTRECMV
         MVC   RECWORKA(6),=C'(NULL)'   YES MOVE PHONY
         MVC   RECWORKA+6(1),STOPPER      RECORD TO WORKAREA
         OI    SWIT+4,X'80'        SET NULL RECORD SWIT
         B     *+22
PRTRECMV EQU   *
         LR    R3,R2               MOVE
         BCTR  R3,R0                 CURRENT
         EX    R3,*+8                   RECORD
         B     *+10                       TO THE
         MVC   RECWORKA(0),0(R1)            WORK AREA
         STM   R0,R1,CNTADDR       SAVE BLK CNT/BUFF ADDRESS
         ZAP   HITSWIRE,=P'0'      ZERO NUM OF HITS IN RECORD
         ZAP   PRTTABE1+10(2),=P'0'     ZERO NUM OF HITS IN 1ST SEG
         ZAP   PRTTABE2+10(2),=P'0'     ZERO NUM OF HITS IN 2ND SEG
         ZAP   PRTTABE3+10(2),=P'0'     ZERO NUM OF HITS IN 3RD SEG
         TM    PARMSWIT+1,X'08'    IS THIS RECORD LEVEL LOGIC
         BNO   RESCAN              NO
         OI    SWIT+4,X'40'        SET 1ST PASS SWITCH
         BAL   R4,SCANRTNE         GO TO SCANRTNE TO BUILD ARGUMENT
*                                    FOUND PORTION OF THE BIT TABLE
         NI    SWIT+4,X'BF'        TURN OFF 1ST PASS SWITCH
         L     R5,PTRNSAVE+4       WERE ALL ARGS FOUND
         CLC   0(32,R5),32(R5)       IN THE RECORD SCANNED
         BNE   *+14                NO
         XC    0(32,R5),0(R5)      CLEAR ARGUMENT FOUND PART OF TABLE
         B     RESCAN              GO RESCAN FOR HITS AND COUNTS
         XC    0(32,R5),0(R5)      CLEAR ARGUMENT FOUND PART OF TABLE
         B     RESCAN+4            NO HITS NO RESCAN
RESCAN   EQU   *
         BAL   R4,SCANRTNE         CHECK FOR HIT/S
         XR    R6,R6               GET NUM OF LINES TO
         IC    R6,NOLNEHLD           BE PRINTED PER RECORD
         LA    R5,PRTTABLE         POINT TO PRINT TABLE
         LA    R1,RECWORKA         POINT TO CURRENT RECORD
         TM    SWIT+3,X'04'        IS RECFM VARIABLE
         BNO   SETPHTSW
         TM    SWIT+4,X'80'        IS THIS A NULL RECORD
         BNO   *+12                NO
         MVI   RECWORKA+6,C' '     YES CLEAR STOPPER
         B     SETPHTSW
         LH    R2,RECLENV          IS THIS MAX
         CH    R2,=H'255'            RECORD SIZE
         BNL   SETPHTSW            YES
         AR    R2,R1               IF NOT CLEAR THE STOPPER
         MVI   0(R2),C' '              CHARACTER FROM WORK AREA
SETPHTSW EQU   *
         OI    SWIT+2,X'04'        SET SWIT TO PRINT HITS/RECORD
RECPRTLP EQU   *
         LH    R3,8(R5)            MOVE
         BCTR  R3,R0                 THIS
         EX    R3,*+8                  PART
         B     *+10                      OF REC
         MVC   PRNTWRK+16(0),0(R1)         TO PRINT
         LA    R3,1(R3)                      AREA AND
         AR    R1,R3                           POINT PAST
         LA    R3,PRTTABLE         IS THIS 1ST
         CR    R3,R5                 SEG OF REC
         BNE   CHKHITRE            NO
         TM    SWIT+3,X'04'        IS RECFM VARIABLE
         BO    *+14                YES
         MVC   PRNTWRK+129(3),BLANKS    NO - BLANK OUT LENGTH
         B     CHKHITRE                   FIELD IN RECORD PRINT
         LH    R3,RECLENV          PRINT OUT
         CVD   R3,DWORD              LENGTH OF
         UNPK  PRNTWRK+129(3),DWORD    RECORD IN
         OI    PRNTWRK+131,X'F0'         1ST LINE
CHKHITRE EQU   *
         TM    SWIT,X'04'          ANY HITS IN REC
         BNO   CLEARST             NO
         TM    SWIT+2,X'04'        PRINT HITS/REC ?
         BZ    CHKHITSG            NO
         AP    HITSRECS,HITSWIRE   ADD NUM OF HITS/RECORD TO TOT PDS
         AP    HITSWIRT,HITSWIRE   ADD NUM OF HITS/RECORD TO TOT MEM
         AP    HITWIMEM,=P'1'      ADD 1 TO RECORDS HIT THIS MEMBER
         UNPK  PRNTWRK+102(3),HITSWIRE  SEND NUM OF HITS
         OI    PRNTWRK+104,X'F0'          IN RECORD TO PRINT
         NI    SWIT+2,X'FB'        TURN OFF SWIT FOR HITS/RECORD
CHKHITSG EQU  *
         CP    10(2,R5),=P'0'      ANY HITS IN THIS REC SEGMENT
         BNE   *+14                YES
         MVC   PRNTWRK+106(22),PRNTWRK+105
         B     CLEARST+6
         UNPK  PRNTWRK+107(2),10(2,R5)  NUM OF HITS IN THE
         OI    PRNTWRK+108,X'F0'          REC SEGMENT TO PRINT
         L     R3,0(R5)            RESTORE ADDRESS OF FIRST HIT IN SEG
         LA    R2,RECWORKA-1       SHOW
         SR    R3,R2                 STARTING
         CVD   R3,DWORD                LOCATION
         UNPK  ARGLOC+2(3),DWORD         OF FIRST
         OI    ARGLOC+4,X'F0'              ARG FOUND
         XR    R2,R2
         IC    R2,7(R5)            GET LENGTH OF FOUND ARGUMENT
         AR    R3,R2               ENDING
         CVD   R3,DWORD              LOCATION
         UNPK  ARGLOC+6(3),DWORD       OF FIRST
         OI    ARGLOC+8,X'F0'            ARG FOUND
         MVC   PRNTWRK+110(11),ARGLOC   MOVE LOC OF FIRST ARG TO PRINT
         MVC   PRNTWRK+123(3),4(R5)     MOVE NUM OF FIRST ARG TO PRINT
         B     *+10
CLEARST  EQU   *
         MVC   PRNTWRK+102(27),PRNTWRK+101
         TM    PARMSWIT,X'10'      ARE WE ONLY PRINTING HITS
         BNO   *+12                NO
         TM    SWIT,X'04'          YES - DID LINE HAVE A HIT
         BNO   NEXREC              NO - BYPASS PRINT
         ST    R1,FWORD            SAVE RECORD POINTER
         TM    SWIT+2,X'02'        IS REC LEN GT 85
         BZ    CLEARHS             NO - SINGLE LINE RECORD
         TM    PARMSWIT,X'80'      IS NO LIST SWIT ON
         BO    CLEARHS             YES - BYPASS SYSPRINT DETAILS
         PUT   LIST,CC             YES - PRINT
         L     R1,FWORD            RESTORE RECORD POINTER
         MVI   CC,C' '                  CLEAR
         MVC   PRNTWRK(106),CC            RESIDUAL
         MVC   PRNTWRK+129(3),BLANKS        PRINT INFO
         XR    R3,R3               UPDATE PRINT
         IC    R3,LINCT              LINE COUNTER
         LA    R3,1(R3)                AND SAVE FOR
         STC   R3,LINCT                  OVERFLOW CNTL
         LA    R5,12(R5)           LOOP BACK TO PRINT SEGMENTS
         BCT   R6,RECPRTLP            2 AND 3 DEPENDING ON CNT IN R6
CLEARHS  EQU   *
         NI    SWIT,X'FB'          CLEAR HIT SWITCH
         AP    RECSDSP,=P'1'       ADD 1 TO TOTAL RECORDS DISPLAYED
         TM    PARMSWIT,X'80'      IS NO LIST SWIT ON
         BO    BYLISTDT            YES - BYPASS SYSPRINT DETAILS
         TM    SWIT+2,X'02'        IS REC LEN GT 85
         BZ    *+14                NO GO PRINT SINGLE LINE
         XR    R1,R1               PICK UP LINE
         IC    R1,LINCT               COUNT AND GO
         B     CHKDETOV                 CHECK OVERFLOW
         PUT   LIST,CC
BYLISTDT EQU   *
         MVI   CC,C' '
         MVC   PRNTWRK(8),CC
         XR    R1,R1
         IC    R1,LINCT
         LA    R1,1(R1)
CHKDETOV EQU   *
         CH    R1,=H'56'
         BNH   *+8
         OI    SWIT+1,X'80'        SWITCH FOR HEADINGS
         STC   R1,LINCT
NEXREC   EQU   *
         LM    R0,R1,CNTADDR
         TM    SWIT+3,X'04'        IS RECFM VARIABLE
         BO    *+12                YES
         LH    R2,RECLEN           LRECL - FIXED
         B     *+8
         LH    R2,RECLENV          LRECL - VARIABLE
         AR    R1,R2               POINT TO NEXT RECORD
         SR    R0,R2               REDUCE BLOCK COUNT BY LAST RECORD
         BC    4,ABND2             ERROR IF BLOCK COUNT GOES TO NEG
         BC    2,PRINT
         LA    R1,MEM
         BAL   R2,READ
         B     RESCNT2
ENDMEM   EQU   *
         LM    R5,R9,READSAVE
         TM    SWIT,X'01'          COPY OPERATION
         BO    RESETMAD            YES COPY COMPLETE
         TM    PARMSWIT,X'08'      IS THIS AND OPERATION
         BNO   CHKHTLSR            NO - CHECK FOR HIT ON LAST READ
         L     R5,PTRNSAVE+4       DID WE FIND ALL ARGUMENTS IN
         CLC   0(32,R5),32(R5)       AND OPERATION OR DID PATTERNS
*                                      MATCH IF WE HAD ARGS EXCLUDED
         BNE   RESETMAD            NO
         OI    SWIT,X'0C'          YES SET HIT SWITS FOR PDS AND MEM
         AP    HITSMEMS,=P'1'      ADD 1 TO COUNT OF MEMBERS
         B     COPY                  WITH HITS AND GO TO COPY
CHKHTLSR EQU   *
         TM    SWIT,X'04'          WAS HIT ON LAST RECORD
         BO    COPY                YES
RESETMAD EQU   *
         BAL   R2,RESETADD
         TM    SWIT,X'01'          DID WE COPY
         BO    *+14                YES
         AP    SCANRECS,SCANCNT    USE SCAN COUNT FOR TOTAL RECORD CNT
         B     CLEARCTS
         AP    SCANRECS,COPYCNT    USE COPY COUNT FOR TOTAL RECORD CNT
         UNPK  PRNTWRKI+15(6),COPYCNT   PUT # RECORDS
         OI    PRNTWRKI+20,X'F0'          TO INDEX LIST
         UNPK  PRNTWRKI+22(6),HITWIMEM  PUT LINES HIT
         OI    PRNTWRKI+27,X'F0'          TO INDEX LIST
         UNPK  PRNTWRKI+29(7),HITSWIRT  PUT TOTAL HITS FOR
         OI    PRNTWRKI+35,X'F0'          MEM TO INDEX LIST
         UNPK  PRNTWRKI+37(4),ARGWIMEM  PUT ARGS FOUND
         OI    PRNTWRKI+40,X'F0'          TO INDEX LIST
         TM    PARMSWIT,X'80'      IS NO LIST SWIT ON
         BNO   *+10                NO
         MVC   PRNTWRKI+9(5),ASTERICS   YES - SHOW ***** FOR PAGE NO
         TM    PARMSWIT,X'40'      IS DISK ADDRESS SWIT ON
         BNO   WRINDEX             NO
         LA    R1,MEM              GET DCB ADDRESS OF MEM DCB
         L     R1,44(R1)           GET DEB ADDRESS
         L     R0,TTRN             PICK UP TTR OF RECORD
         LA    R2,DWORD            POINT TO AREA WHERE CONVERT
*                                    ROUTINE WILL STORE DISK ADDR
         LA    R15,16              CVT
         L     R15,0(R15)            ADDR
         L     R15,28(R15)         ADDRESS CONVERT ROUTINE(IECPCNVT)
         STM   R9,R13,TTMSAVE      SAVE REGS
         CNOP  2,4                 ALIGN
         BALR  R14,R15             GO TO CONVERT ROUTINE
         LM    R9,R13,8(R14)       RESTORE REGS
         B     *+24
TTMSAVE  DS    5F
         UNPK  PRNTWRKI+42(11),DWORD+3(6)    PUT ADDRESS
         TR    PRNTWRKI+42(10),TRTAB-240       OF MEMBER TO
         MVI   PRNTWRKI+52,X'40'                 PRINT BUFFER
WRINDEX  EQU   *
         PUT   INDEX,CCI           WRITE INDEX RECORD
         MVI   CCI,C' '            RESET SINGLE SPACE
         NI    SWIT+1,X'DF'        TURN OFF PAGE # SWITCH
         XR    R3,R3               UPDATE THE
         IC    R3,LINCTI             LINE COUNT
         LA    R3,1(R3)                FOR INDEX
         STC   R3,LINCTI                 LISTING
CLEARCTS EQU   *
         ZAP   SCANCNT,=P'0'
         ZAP   COPYCNT,=P'0'
         ZAP   HITWIMEM,=P'0'
         ZAP   ARGWIMEM,=P'0'
         ZAP   HITSWIRT,=P'0'
         NI    SWIT,X'2A'
         TM    PARMSWIT,X'08'      IS THIS AND OPERATION
         BNO   GNEXTDIR            NO
         L     R5,PTRNSAVE+4       YES - CLEAR HITS FOR THIS
         XC    0(32,R5),0(R5)        MEMBER IN BIT PATTERN TABLE
         B     GNEXTDIR
         EJECT
ERROR2   EQU   *
         MVI   CC,C'0'
         MVI   PRNTWRK,X'40'
         MVC   PRNTWRK+1(131),PRNTWRK
         MVC   PRNTWRK(32),0(R5)
         PUT   MESSAGE,CC
         IC    R1,LINCTM           BUMP LINCTM
         LA    R1,7(R1)              UP BY 7 FOR
         STC   R1,LINCTM               ERROR2 COND
         MVI   RETCODEF,X'08'
         MVI   RETCODE,X'08'
         TM    SWIT+1,X'40'
         BO    BUMPTIOT
ENDUP    EQU   *
         MVI   PRNTWRK,C' '
         MVC   PRNTWRK+1(131),PRNTWRK
         MVC   PRNTWRK(35),TOTSMSG
         UNPK  PRNTWRK+36(7),SCANMEMS
         OI    PRNTWRK+42,X'F0'
         MVI   CC,C'0'
         PUT   MESSAGE,CC
         MVC   PRNTWRK(35),TOTSMSG+35
         UNPK  PRNTWRK+36(7),SCANRECS
         OI    PRNTWRK+42,X'F0'
         MVI   CC,C' '
         PUT   MESSAGE,CC
         TM    SWIT,X'02'          DID WE GET BUFFERS
         BNO   CHECKHIT            NO
         LM    R0,R1,IOARSAVE      YES
         FREEMAIN R,LV=(R0),A=(R1)      FREE GOTTEN CORE
CHECKHIT EQU   *
         TM    SWIT,X'08'          DID WE HAVE A HIT IN THIS PDS
         BO    PRNTHITS            YES
         MVI   RETCODEF,X'04'      NO - SHOW NO HITS THIS PDS
         CLI   RETCODE,X'04'       IS A PREV RET CODE HIGHER
         BH    *+8                 YES - BYPASS
         MVI   RETCODE,X'04'       NO - SET RETURN CODE
         MVI   PRNTWRK,C' '
         MVC   PRNTWRK+1(131),PRNTWRK
         MVI   CC,C'0'
         MVC   PRNTWRK(L'NOHITSM),NOHITSM
         PUT   MESSAGE,CC
         IC    R1,LINCTM           BUMP LINCTM
         LA    R1,13(R1)             UP BY 13 FOR
         STC   R1,LINCTM               NO HIT COND
         B     CLOSEDA
PRNTHITS EQU   *
         MVI   RETCODEF,X'00'      SHOW RC FOR HITS THIS PDS
         MVI   PRNTWRK,C' '
         MVC   PRNTWRK+1(131),PRNTWRK
         MVC   PRNTWRK(27),HITSMSG
         UNPK  PRNTWRK+28(7),HITSMEMS
         OI    PRNTWRK+34,X'F0'
         MVI   CC,C'0'
         PUT   MESSAGE,CC
         MVC   PRNTWRK(27),HITSMSG+27
         UNPK  PRNTWRK+28(7),HITSRECS
         OI    PRNTWRK+34,X'F0'
         MVI   CC,C' '
         PUT   MESSAGE,CC
         MVC   PRNTWRK(27),ARGSMSG
         UNPK  PRNTWRK+28(7),ARGTOTAL
         OI    PRNTWRK+34,X'F0'
         PUT   MESSAGE,CC
         MVC   PRNTWRK(27),RECDISPM
         UNPK  PRNTWRK+28(7),RECSDSP
         OI    PRNTWRK+34,X'F0'
         TM    PARMSWIT,X'80'      IS NO LIST SWITCH ON
         BNO   *+10                NO
         MVC   PRNTWRK+28(7),ASTERICS   YES - SHOW ******* FOR
*                                         NO OF RECORDS DISPLAYED
         PUT   MESSAGE,CC
         ZAP   PAGESPDS,PAGECNT
         SP    PAGESPDS,PAGEBEGP
         AP    PAGESPDS,=P'1'
         MVC   PRNTWRK(27),PGSDISPM
         UNPK  PRNTWRK+28(7),PAGESPDS
         OI    PRNTWRK+34,X'F0'
         TM    PARMSWIT,X'80'      IS NO LIST SWITCH ON
         BNO   *+10                NO
         MVC   PRNTWRK+28(7),ASTERICS   YES - SHOW ******* FOR
*                                         PAGES PRINTED IN PDS
         PUT   MESSAGE,CC
         MVC   PRNTWRK(27),PGRANGES
         UNPK  PRNTWRK+28(7),PAGEBEGP
         OI    PRNTWRK+34,X'F0'
         TM    PARMSWIT,X'80'      IS NO LIST SWITCH ON
         BNO   *+10                NO
         MVC   PRNTWRK+28(7),ASTERICS   YES - SHOW ******* FOR
*                                         FIRST PAGE IN THIS PDS
         PUT   MESSAGE,CC
         MVC   PRNTWRK(5),PGRANGEE
         UNPK  PRNTWRK+28(7),PAGECNT
         OI    PRNTWRK+34,X'F0'
         TM    PARMSWIT,X'80'      IS NO LIST SWITCH ON
         BNO   *+10                NO
         MVC   PRNTWRK+28(7),ASTERICS   YES - SHOW ******* FOR
*                                         LAST PAGE IN THIS PDS
         PUT   MESSAGE,CC
         IC    R1,LINCTM           BUMP LINCTM
         LA    R1,19(R1)             UP BY 19 FOR
         STC   R1,LINCTM               NORMAL COND
         ZAP   PAGEBEGP,=P'1'      POINT TO NEXT PAGE
         AP    PAGEBEGP,PAGECNT      TO PROCESS NEXT PDS
CLOSEDA  EQU   *
         CLOSE (DIR)
         CLOSE (MEM)
         CALL  DATETIME,(STOPTIME,JULDT,DODDT,STOPCLDT,CMPLCD)
         MVI   PRNTWRK,C' '
         MVC   PRNTWRK+1(131),PRNTWRK
         MVC   PRNTWRK(L'STARTMSG),STARTMSG
         MVC   PRNTWRK+L'STARTMSG(L'STARTSTS),STARTSTS
         MVI   CC,C'0'
         PUT   MESSAGE,CC
         MVC   PRNTWRK(L'STOPMSG),STOPMSG
         MVC   PRNTWRK+L'STARTMSG(L'STOPSTS),STOPSTS
         MVI   CC,C' '
         PUT   MESSAGE,CC
BUMPTIOT EQU   *
         XC    SWIT(1),SWIT        RESET SWITCHES FOR
         NI    SWIT+1,X'1F'          POSSIBLE NEXT PASS
         ZAP   SCANMEMS,=P'0'      ZERO OUT
         ZAP   SCANRECS,=P'0'        COUNTERS
         ZAP   SCANCNT,=P'0'           FOR NEXT
         ZAP   COPYCNT,=P'0'             PASS IF
         ZAP   HITSMEMS,=P'0'              MORE PDS
         ZAP   HITWIMEM,=P'0'                CARDS ARE
         ZAP   HITSRECS,=P'0'                  IN JCL WITH
         ZAP   ARGWIMEM,=P'0'                    DDNAME PROCXXXX
         ZAP   ARGTOTAL,=P'0'                      OR WITH DDNAME
         ZAP   RECSDSP,=P'0'                         IN FORM PDSXXXX
         MVI   LINCTI,X'3B'        REST LINE COUNT - INDEX LISTING
         BAL   R2,RESETADD         GO RESET I/O BLOCK POINTERS
         TM    PARMSWIT,X'20'      IS THIS CONSOLE ENTRY
         BNO   NEXTDDEN            NO - CONTINUE
         XR    R1,R1               YES
         IC    R1,RETCODEF           PUT
         CVD   R1,DWORD                RC
         UNPK  WTORC,DWORD+6(2)          TO
         OI    WTORC+1,X'F0'               WTO
         XC    WTODSN,WTODSN       PUT DSN
         MVC   WTODSN,JFCB           TO WTO
         LA    R1,WTOMSG           PUT OUT
         WTO   MF=(E,(R1))           END WTO
NEXTDDEN EQU   *
         L     R3,TIOTHOLD         POINT TO NEXT DD ENTRY
         XR    R4,R4               CHECK FOR MORE PDS
         B     TIOTLOOP              DD CARDS IN THE JCL
OPTPRINT EQU   *
         L     R3,16               POINT TO CVT. ADDR IS IN LOW STORAGE
         L     R3,0(,R3)           POINT TO TCB/ASCB WORDS, "0" OFF CVT
         L     R3,4(,R3)           POINT TO TCB, "4" OFF TCB/ASCB WORDS
         L     R3,X'B4'(,R3)       POINT TO JSCB. X'B4' OFF CURRENT TCB
         L     R3,X'108'(,R3)      POINT TO PSCB. X'108' OFF THE JSCB
         LTR   R3,R3               IS THERE A PSCB
         BZ    *+14                NO
         MVC   OPTNSARG,0(R3)      MOVE USERID IN FROM 0 OFF THE PSCB
         B     OPTPRCHK
         TM    PARMSWIT,X'A9'      DID ANY DEFAULTS CHANGE
         BZ    OPTWRITE            NO - GO WRITE OPTIONS MESSAGE
         TM    PARMSWIT,X'20'      WERE ARG ENTERED VIA CONSOLE
         BZ    *+10                NO
         MVC   OPTNSARG,=C'CONSOLE'     YES - SHOW ARGS ENT VIA CONS
OPTPRCHK EQU   *
         TM    PARMSWIT,X'81'      WAS PRINT DEFAULT CHANGED
         BZ    *+28                NO
         TM    PARMSWIT,X'80'      WAS NOLIST OR DS(*) SPECIFIED
         BZ    *+14                NO
         MVC   OPTNSPRT,=C'NONE'   SHOW NO SYSPRINT
         B     *+10
         MVC   OPTNSPRT,=C'FULL'   SHOW FULL LIST
         TM    PARMSWIT,X'08'      IS THIS AND LOGIC
         BZ    OPTWRITE            NO
         TM    PARMSWIT+1,X'08'    IS THIS RECORD LEVEL LOGIC
         BZ    *+14                NO
         MVC   OPTNSLOG,=C'REC'    YES SHOW RECORD LOGIC
         B     OPTWRITE
         MVC   OPTNSLOG,=C'AND'    SHOW AND LOGIC
OPTWRITE EQU   *
         MVC   PRNTWRK(L'OPTNSMSG),OPTNSMSG
         MVI   CC,C'0'
         PUT   MESSAGE,CC
         MVI   PRNTWRK+L'STUBMEML,C' '
         MVC   PRNTWRK+L'STUBMEML+1(38),PRNTWRK+L'STUBMEML
         MVC   PRNTWRK(L'STUBMEML),STUBMEML
         TM    PARMSWIT+1,X'F0'
         BNZ   *+14
         MVC   PRNTWRK+L'STUBMEML(11),=C'ALL MEMBERS'
         B     CHKARGTB
         LA    R7,PRNTWRK+L'STUBMEML
         LR    R8,R7
         TM    PARMSWIT+1,X'80'
         BNO   PRTRANGE
         MVC   0(7,R7),=C'FROMTO='
         CLC   MEMFROM,HEXZEROS
         BNE   *+14
         MVC   7(8,R7),=C'**START*'
         B     *+10
         MVC   7(8,R7),MEMFROM
         MVI   15(R7),C':'
         LA    R7,16(R7)
         CLC   MEMTO,FS
         BNE   *+14
         MVC   0(8,R7),=C'***END**'
         B     *+10
         MVC   0(8,R7),MEMTO
         LA    R7,8(R7)
PRTRANGE EQU   *
         TM    PARMSWIT+1,X'40'
         BNO   *+34
         CR    R7,R8
         BE    *+12
         MVI   0(R7),C','
         LA    R7,1(R7)
         MVC   0(6,R7),=C'RANGE='
         MVC   6(3,R7),MEMRANGE
         LA    R7,9(R7)
         TM    PARMSWIT+1,X'20'
         BNO   *+34
         CR    R7,R8
         BE    *+12
         MVI   0(R7),C','
         LA    R7,1(R7)
         MVC   0(8,R7),=C'PATTERN='
         MVC   8(8,R7),MEMPATRN
         LA    R7,16(R7)
         TM    PARMSWIT+1,X'10'
         BNO   CHKARGTB
         CR    R7,R8
         BE    *+12
         MVI   0(R7),C','
         LA    R7,1(R7)
         MVC   0(7,R7),=C'STRING='
         XR    R8,R8
         IC    R8,MEMSTRNL
         EX    R8,*+8
         B     CHKARGTB
         MVC   7(0,R7),MEMSTRNG
CHKARGTB EQU   *
         MVI   CC,C' '
         PUT   MESSAGE,CC
         MVI   PRNTWRK+L'STUBMEML,C' '
         MVC   PRNTWRK+L'STUBMEML+1(67),PRNTWRK+L'STUBMEML
         TM    PARMSWIT,X'02'      WAS TOTALS BY ARG ASKED FOR
         BNO   CLOSEUR             NO
         TM    SWIT+3,X'08'        WERE THERE ANY HITS IN RUN
         BNO   CLOSEUR             NO
         CP    ARGCT,=P'1'         IS THERE ONLY 1 VALID ARGUMENT
         BNE   *+12                NO - SORT
         L     R8,ARGSAVE+4        YES - BYPASS THE
         B     PARGTABL              RESORT OF ARG TABLE
         OI    SWIT+3,X'10'        GO SORT AGUMENT TABLE
         BAL   R2,SORTRTNE           BY ARGUMENT NUMBER
         L     R8,ARGSAVE+4
PARGTABL EQU   *
         CLI   ARGNO,X'00'         IS THIS END OF ARGUMENT TABLE
         BE    CLOSEUR             YES
         CP    ARGTARG,=P'0'       DID THIS ARGUMENT HAVE ANY HITS
         BE    PARGTABB            NO - BYPASS
         TM    ARGFL,X'10'         WAS THIS AN EXCLUDE ARGUMENT
         BO    PARGTABB            YES - BYPASS
         BAL   R2,CHKARGTH         GO CHECK FOR OVERFLOW
         MVC   PRNTWRK(L'ARGNO),ARGNO   ARGUMENT TO PRINT
         UNPK  PRNTWRK+4(7),ARGTARG     TOTAL NUMBER OF
         OI    PRNTWRK+10,X'F0'           HITS TO PRINT
         UNPK  PRNTWRK+12(5),ARGTMEM    TOTAL MEMBERS WITH HITS
         OI    PRNTWRK+16,X'F0'           FOR THIS ARGUMENT TO PRINT
         UNPK  PRNTWRK+18(5),ARGTPDS    TOTAL PDSES WITH HITS
         OI    PRNTWRK+22,X'F0'           FOR THIS ARGUMENT TO PRINT
         MVC   PRNTWRK+24(108),PRNTWRK+23    CLEAR REST OT PRINT AREA
         TM    ARGFL,X'08'         DOES ARGUMENT CONTAIN PATTERN/S
         BNO   *+10                NO
         MVC   PRNTWRK+24(3),PRNTTAB    YES - SHOW IT
         XR    R3,R3
         IC    R3,ARGLNG           MOVE THE
         STC   R3,*+5                ARGUMENT
         MVC   PRNTWRK+31(0),ARG       TO PRINT
         LA    R3,1(R3)
         CVD   R3,DWORD            MOVE THE
         OI    DWORD+7,X'0F'         ARG LENGTH
         UNPK  PRNTWRK+28(2),DWORD     TO PRINT
         PUT   MESSAGE,CC          PRINT THE ARGUMENT
         IC    R3,LINCTM2
         LA    R3,1(R3)
         STC   R3,LINCTM2
PARGTABB EQU   *
         LA    R8,ARGENTSZ(R8)     POINT TO NEXT ARG IN TABLE
         B     PARGTABL
CHKARGTH EQU   *
         CLI   LINCTM2,X'38'       IF LINE COUNT
         BH    *+10                  IS LESS THAN
         MVI   CC,C' '                 57 SET SINGLE
         BR    R2                        SPACE AND RET
         MVI   PRNTWRK,C' '
         MVC   PRNTWRK+1(131),PRNTWRK
         MVC   CC(L'HDRM2T1),HDRM2T1
         PUT   MESSAGE,CC          PRINT 1ST HEADING
         MVC   CC(L'HDRM2T2),HDRM2T2
         PUT   MESSAGE,CC          PRINT 2ND HEADING
         MVC   CC(L'HDRM2T3),HDRM2T3
         PUT   MESSAGE,CC          PRINT 3RD HEADING
         MVI   PRNTWRK,C' '
         MVC   PRNTWRK+1(131),PRNTWRK
         MVI   CC,C'0'             SET DOUBLE SPACE FOR NEXT LINE
         MVI   LINCTM2,X'05'       RESET OVERFLOW COUNT
         BR    R2
CLOSEUR  EQU   *
         CLOSE (LIST,,MESSAGE,,INDEX)   CLOSE PRINT FILES
         TM    PARMSWIT,X'20'      WERE ARGS ENTERED VIA CONSOLE
         BO    FREETAB             YES - BYPASS CLOSE
         CLOSE (CARD)              NO - CLOSE CARD FILE
FREETAB  EQU   *
         TM    SWIT+1,X'08'        DID WE GET AN AREA FOR ARG. TAB.
         BNO   FREEBITT            NO - GET CHECK FOR BIT TABLE
         LM    R0,R1,ARGSAVE            YES FREE
         FREEMAIN R,LV=(R0),A=(R1)        THE AREA
FREEBITT EQU   *
         TM    SWIT+1,X'01'        DID WE GET AREA FOR BIT TABLE
         BNO   FREEWRK             NO
         LM    R0,R1,PTRNSAVE           YES FREE
         FREEMAIN R,LV=(R0),A=(R1)        THE AREA
FREEWRK  EQU   *
         L     R8,SAVE+4           RESTORE CALLER SAVE AREA
         LM    R0,R1,WORKSAVE
         FREEMAIN R,LV=(R0),A=(R1)      FREE SAVE/WORK AREA
         LR    R13,R8              POINT TO CALLER SAVE ARE
         XR    R15,R15             PICK UP HIGH
         IC    R15,RETCODE           RETURN CODE
         RETURN (14,12),RC=(15)
         EJECT
READ     EQU   *
         STM   R5,R9,READSAVE      SAVE REGS
         LR    R7,R1               DCB TO BE READ
         TM    SWIT,X'80'          ARE WE READING MEMBER DCB
         BO    READMEM             YES
         LM    R5,R6,DIRDECBS      DECB ADDRESSES FOR DIRECTORY
         LM    R8,R9,DIRBADDR      DIRECTORY BUFFERS
         TM    SWIT+4,X'20'        IS DSORG PS
         BNO   *+12                NO
         L     R1,IOARSAVE+4       YES R1 TO DUMMY DIR ENTRY
         B     READRTN               AND EXIT ROUTINE WITHOUT READ
         TM    SWIT,X'20'          SUB ENTRY FOR DIRECTORY
         BO    READSUB             YES
         B     READFRST
READMEM  EQU   *
         LM    R5,R6,MEMDECBS      DECB ADDRESSES FOR MEMBER DCB
         LM    R8,R9,MEMBADDR      MEMBER BUFFERS
         TM    SWIT,X'40'          SUB ENTRY FOR MEMBER DCB
         BO    READSUB             YES
READFRST EQU   *
         READ  (R5),SF,(R7),(R8),'S',MF=E    READ FIRST BLOCK
READSUB  EQU   *
         TM    SWIT,X'10'          IS THIS FLUSH MODE
         BO    CHECK               YES
         READ  (R6),SF,(R7),(R9),'S',MF=E    ALL READS BUT FIRST
CHECK    EQU   *
         CHECK (R5)
         TM    SWIT,X'10'          IS THIS FLUSH MODE
         BC    1,READRTN           YES
         TM    SWIT,X'80'          ARE WE READING MEMBER DCB
         BC    1,*+12              YES
         LA    R1,DIRDECBS         NO
         B     *+16
         LA    R1,MEMDECBS
         L     R7,16(R5)           SAVE IOB
         ST    R7,IOBADDR            ADDRESS
         XR    R5,R6               REVERSE THE
         XR    R6,R5                 DECB ADDRESSES
         XR    R5,R6                   FOR THE NEXT
         STM   R5,R6,0(R1)               PASS
         XR    R8,R9               REVERSE THE
         XR    R9,R8                 BUFFER ADDRESSES
         XR    R8,R9                   FOR THE NEXT
         STM   R8,R9,8(R1)               PASS
         LR    R1,R9               MAKE R1 POINT TO BLOCK
READRTN  EQU   *
         LM    R5,R9,READSAVE      RESTORE REGS
         BR    R2                  RETURN
         EJECT
FIND     EQU   *
         TM    SWIT+4,X'20'        IS DSORG PS
         BNO   FINDMEM             NO USE FIND FOR BPAM
         POINT MEM,TTRN
         B     TESTPFRC
FINDMEM  EQU   *
         FIND  MEM,TTRN,C
TESTPFRC EQU   *
         LTR   R15,R15             WAS FIND/POINT SUCCESFULL
         BCR   8,R2                YES
         ABEND 001,DUMP
         EJECT
SCANRTNE EQU   *
         LA    R1,RECWORKA         POINT R1 TO AREA TO BE SCANNED
         TM    SWIT+4,X'80'        IS THIS A NULL RECORD
         BNO   *+12                NO
         LA    R3,RECWORKA+6       YES BYPASS MOVE OF
         B     TRTLOOP1-2            STOPPER TO WORKAREA
         LR    R3,R1               MOVE
         TM    SWIT+3,X'04'          STOPPER
         BO    *+12                    CHARACTER
         AH    R3,RECLEN                 ONE BYTE
         B     *+26                        BEYOND REC
         CLC   RECLENV,=H'255'               AND POINT
         BNH   *+12                            R3 THERE
         AH    R3,=H'255'                        TO COMPARE
         B     *+8                                  END OF SCAN
         AH    R3,RECLENV                             WHEN RECORD
         MVC   0(1,R3),STOPPER                          LEN EXCEEDED
         XR    R2,R2
TRTLOOP1 EQU   *
         TRT   0(256,R1),TRTTAB    TRANSLATE AND TEST
         CR    R1,R3               DID WE HIT STOPPER
         BCR   8,R4                YES - NO HITS
         BCTR  R2,R0               REDUCE FUNCTION BYTE BY 1
         MH    R2,ARGSZHLD         POINT TO FIRST ENTRY IN
         L     R8,ARGSAVE+4          THE ARGUMENT TABLE THAT
         AR    R8,R2                   BEGINS WITH THIS CHARACTER
         XR    R2,R2
TRTLOOP2 EQU   *
         IC    R2,ARGLNG           GET LENGTH OF ARGUMENT
         TM    ARGFL,X'08'         IS ARGUMENT A PATTERN
         BNO   EXCOMP              NO USE REGULAR COMPARE
         NI    SWIT+2,X'EF'        TURN OFF UNEQUAL COMPARE SWITCH
         ST    R4,PTRTSAVE         SAVE SCANRTNE RETURN
         LA    R5,ARG              POINT R5 TO ARGUMENT
         BAL   R4,PATTRTNE         GO COMPARE DATA TO PATTERENED ARG
         L     R4,PTRTSAVE         RESTORE SCANRTNE RETURN
         TM    SWIT+2,X'10'        IS UNEQUAL COMPARE SWITCH ON
         BO    TRTLOOP3            YES - CONTINUE SEARCH
         B     *+12                NO - ARG MATCHES WITH DATA
EXCOMP   EQU   *
         EX    R2,COMPARE          IS THIS THE ARGUMENT
         BNE   TRTLOOP3            NO
         TM    ARGFL,X'04'         DOES ARGUMENT HAVE SEARCH LIMITS
         BNO   *+16                NO
         BAL   R7,LIMITRTE         YES - GO SEE IF W/I LIMITS
         TM    SWIT+3,X'20'        WAS FOUMD ARGUMENT W/I LIMITS
         BNO   TRTLOOP3            NO
         TM    SWIT+4,X'80'        IS THIS A NULL RECORD
         BNO   *+22                NO
         CLI   ARGLNG,X'05'        IF NULL
         BNE   TRTLOOP3              RECORD ALLOW
         CLC   ARG(6),=C'(NULL)'       ONLY THIS
         BNE   TRTLOOP3                  ARGUMENT
         TM    SWIT,X'01'          ARE WE COPYING
         BO    PROCESSH            YES
         TM    PARMSWIT,X'08'      IS THIS AND PROCESSING
         BO    SETBITSF            YES GO SET BIT FOUND
         OI    SWIT,X'0C'          SET HIT SWITS FOR PDS AND MEM
         BR    R4                  RETURN
SETBITSF EQU   *
         L     R5,PTRNSAVE+4       POINT TO FOUND
         XR    R6,R6                 PART OF BIT TABLE
         IC    R6,ARGNOBIN         GET ARG NUM OF FOUND ARG
         BAL   R7,BITSETR          GO SET BIT
         B     TRTLOOP3            CONTINUE SEARCH
PROCESSH EQU   *
         TM    SWIT+4,X'40'        IS THIS FIRST PASS IN COPY
         BO    SETBITSF              TO SET BIT TABLE FOR RECORD LOGIC
         OI    SWIT,X'04'          SET HIT SWITCH FOR MEM
         AP    HITSWIRE,=P'1'      ADD 1 TO NUM OF HITS IN THIS REC
         BAL   R7,PRNTBRTE         GO FILL IN PRINT SEGMENT TABLE
         AP    ARGTARG,=P'1'       ADD 1 TO THE TOTAL NUMBER OF
*                                    TIMES ARGUMENT WAS FOUND IN RUN
         CLC   ARGDDNAM,DDNAME     ARE WE IN SAME PDS AS
*                                    LAST HIT FOR THIS ARG.
         BE    *+26                YES - GO CHECK HIT FLAG
         MVC   ARGDDNAM,DDNAME     NO - PUT PDS DDNAME IN
*                                    THIS ARG. TABLE ENTRY
         AP    ARGTPDS,=P'1'       ADD 1 TO THE TOTAL NUMBER OF PDSES
*                                    THAT HAVE A HIT FOR THIS ARGUMENT
         XC    ARGMEM,ARGMEM       CLEAR MEM NAME FOR NEW PDS
         NI    ARGFL,X'DF'         CLEAR ARGUMENT FOUND FLAG
         TM    ARGFL,X'20'         IS ARGUMENT FOUND FLAG ON
         BO    *+14                YES - BYPASS
         AP    ARGTOTAL,=P'1'      ADD 1 TO COUNT OF ARGUMENTS
*                                    FOUND WITHIN CURRENT DDNAME
         OI    ARGFL,X'20'         TURN ON ARGUMENT FOUND FLAG
         CLC   ARGMEM,MEMBER       ARE WE IN SAME MEMBER AS
*                                    LAST HIT FOR THIS ARGUMENT
         BE    *+20                YES - GO CHECK HIT FLAG
         MVC   ARGMEM,MEMBER       NO - PUT MEMBER NAME IN
*                                    THIS ARGUMENT TAB ENTRY
         AP    ARGTMEM,=P'1'       ADD 1 TO THE TOTAL NUMBER OF MEMBERS
*                                    THAT HAVE A HIT FOR THIS ARGUMENT
         NI    ARGFL,X'BF'         CLEAR ARGUMENT FOUND FLAG
         TM    ARGFL,X'40'         IS ARGUMENT FOUND FLAG ON
         BC    1,TRTLOOP3          YES - CONTINUE LINE SEARCH
         AP    ARGWIMEM,=P'1'      ADD 1 TO COUNT OF ARGUMENTS
*                                    FOUND WITHIN CURRENT MEMBER
         OI    ARGFL,X'40'         TURN ON ARGUMENT FOUND FLAG
TRTLOOP3 EQU   *
         TM    ARGFL,X'80'         IS THIS THE LAST ENTRY IN ARGUMENT
*                                    TABLE BEGINNING WITH THE CHARACTER
         BO    *+12                YES
         LA    R8,ARGENTSZ(R8)     NO - GO LOOK
         B     TRTLOOP2              AT NEXT ARG.
         LA    R1,1(R1)            RESUME THE SCAN
         B     TRTLOOP1              AT NEXT CHARACTER
COMPARE  EQU   *
         CLC   0(0,R1),ARG
         EJECT
BITSETR  EQU   *
         ST    R7,FWORD            SAVE RETURN ADDRESS
         BCTR  R6,R0               REDUCE ARGUMENT NUMBER BY ONE TO
*                                    MAKE RELATIVE TO BEGINING OF TAB
         XR    R7,R7               DIV ARGUMENT BY
         SRDL  R6,3                  EIGHT FOR BYTE
         SRL   R7,29               USE LO-ORDER THREE BITS AS
*                                    AN INDEX TO SET CORRECT BIT
*                                      000-111 WILL  SET BITS 1 T0 8
         AR    R5,R6               PICK UP CORRECT
         IC    R6,0(R5)              BYTE FOR ARGUMENT
         IC    R7,BITSETTB(R7)     TURN ON BIT AND
         OR    R6,R7                 RESTORE THE BTYE
         STC   R6,0(R5)                IN THE PAT TABLE
         L     R7,FWORD            RESTORE RETURN ADDRESS
         BR    R7                  RETURN
         EJECT
PATTRTNE EQU   *
         TM    SWIT+2,X'C0'        DID WE ENTER TO CHECK FOR PATTERN
         BZ    COMPPATT            NO - GO COMPARE
         NI    SWIT+2,X'9F'        TURN OFF 40 BIT AND THE 20 BIT.
*                                    40 INDICATES THAT +!@#(S) FOUND.
*                                      20 INDICATES THEY ARE IN POS 1.
         LR    R3,R2               SAVE LENGTH
CHKPLOOP EQU   *
         LA    R6,PATRNTAB
CHKPTLOP EQU   *
         CLC   0(1,R5),0(R6)       IS THIS A PATTERN CHARACTER
         BE    *+20                YES
         LA    R6,2(R6)            GET NEXT PATTERN TABLE ENTRY
         CLI   0(R6),C'*'          IS IT END OF TABLE
         BE    CHKPBUMP            YES
         B     CHKPTLOP            NO NEXT ENTRY IN PATTERN TABLE
         CR    R3,R2               YES - IF FIRST BYTE
         BNE   *+10                  OF ARGUMENT HAS PATT
         OI    SWIT+2,X'20'            CHARACTER IT WILL BE
         BR    R4                        TREATED AS AN ERROR
         OI    SWIT+2,X'40'        SHOW ARG CONTAINS PATT CHAR/S(+!@#)
         BR    R4
CHKPBUMP EQU   *
         LA   R5,1(R5)             CHECK NEXT BYTE
         BCT  R2,CHKPLOOP            FOR PATTERN CHAR
         BR   R4
COMPPATT EQU  *
         STM  R1,R4,PTRTSAVE+4     SAVE REGS FOR SUB ROUTINE
         LR   R3,R1                ADDRESS OF DATA
         LR   R4,R2                LENGTH OF DATA
         LA   R4,1(R4)             UP LENGTH BY ONE BECAUSE IT IS
*                                    STORED MINUS 1 IN ARGUMENT TAB
CMPPLOOP EQU *
         LA   R1,PATRNTAB          POINT TO PATTERN TABLE
CMPTLOOP EQU  *
         CLC  0(1,R5),0(R1)        DOES ARGUMENT BYTE HAVE PAT CHAR
         BE   *+20                 YES
         LA   R1,2(R1)             NO - LOOP
         CLI  0(R1),C'*'             THRU PATTERN
         BNE  CMPTLOOP                 TABLE ENTRIES
         B    *+16                 NOT A PATTERN
         CLI  0(R1),C'+'           IS THIS PATTERN CHARACTER FOR ALL
         BE   CMPPBUMP             YES - BYPASS COMPARE
         B    CMPALPNU             NO - GO CHECK ALPHA/NUMERIC
         CLC  0(1,R3),0(R5)        IS BYTE IN DATA EQUAL TO
*                                    THE BYTE IN ARGUMENT TABLE
         BE   CMPPBUMP             IF EQUAL GO TO NEXT BYTE
CMPNTFND EQU  *
         OI   SWIT+2,X'10'         IF NOT TURN ON UNEQUAL SWIT
         B    COMPEXIT             EXIT ROUTINE
CMPALPNU EQU  *
         MVC  TRTTABHD,TRTTAB      SAVE ARGUMENTS TRTTAB
         MVI  TRTTAB,X'01'
         MVC  TRTTAB+1(255),TRTTAB
         TM   1(R1),X'80'          DOES PATTERN INDICATE NUMERIC
         BNO  *+10                 NO
         XC   TRTAB09,TRTAB09      YES - CLEAR NUMERICS
         TM   1(R1),X'40'          DOES PATTERN INDICATE ALPHA
         BNO  *+40                 NO
         XC   TRTABAIL,TRTABAIL    CLEAR
         XC   TRTABJRL,TRTABJRL      LOWER
         XC   TRTABSZL,TRTABSZL        CASE
         XC   TRTABAIU,TRTABAIU    CLEAR
         XC   TRTABJRU,TRTABJRU      UPPER
         XC   TRTABSZU,TRTABSZU        CASE
         XR   R2,R2                CLEAR R2
         TRT  0(1,R3),TRTTAB       IS CHAR NUMERIC(!)
*                                    ALPHA(@) OR EITHER(#)
         MVC  TRTTAB,TRTTABHD      RESTORE ARGUMENTS TRTTAB
         LTR  R2,R2                R2 NOT ZERO SHOWS
         BNZ  CMPNTFND               CONDITION NOT MET
CMPPBUMP EQU  *
         LA   R3,1(R3)             NEXT DATA BYTE
         LA   R5,1(R5)             NEXT ARGUMENT BTYE
         BCT  R4,CMPPLOOP          LOOP
COMPEXIT EQU  *
         LM   R1,R4,PTRTSAVE+4     RESTORE REGS FOR SUB ROUTINE
         BR   R4
         EJECT
PRNTBRTE EQU   *
         TM    SWIT+2,X'08'        IS THIS ENTRY TO BUILD PRINT TABLE
         BNO   PRNTBREC            NO - GO FILL IN HIT DATA
         NI    SWIT+2,X'F4'        CLEAR ENTRY SWITCH AND LENGTH BITS
         CH    R6,=H'49'           CHECK REC LENGTH
         BH    *+10                   FOR A VALID ENTY
RECLNERR EQU   *
         OI    SWIT+1,X'40'              OF 50 BYTES MINIMUM
         BR    R7                           255 BYTES MAXIMUM.
         CH    R6,=H'255'                     IF OUT OF THIS RANGE
         BNH   *+32                IF TRUNCATE
         TM    F1WORK+40,X'40'       IS SPECIFIED
         BNO   RECLNERR                AS A PARAMETER
         TM    PARMSWIT+1,X'04'          JOB WILL ALLOW
         BNO   RECLNERR                     264 BYTE MAX
         CH    R6,=H'264'                     LRECL BUT WILL
         BH    RECLNERR                         ONLY SCAN AND
         LH    R6,=H'255'                         PRINT FIRST 255
         STH   R6,RECLEN           SAVE RECORD LENGTH
         XC    PRTTABLE,PRTTABLE   CLEAR TABLE
         LA    R4,PRTTABLE         POINT TO TABLE
         LR    R5,R6
         CH    R6,=H'85'           IS REC LEN GT 85
         BH    *+14                YES
         STH   R6,8(R4)            NO - STORE IN FIRST SEG IN TABLE
         OI    SWIT+2,X'01'        SET FLAG FOR LEN 00-85
         BR    R7
         MVC   8(2,R4),=H'85'      SHOW FULL LEN FOR SEG 1
         LA    R4,12(R4)           POINT TO NEXT SEG
         CH    R6,=H'170'          IS REC LEN GT 170
         BH    *+18                YES
         SH    R5,=H'85'           NO - DET LENGTH OF
         STH   R5,8(R4)              SEG AND SAVE IN TABLE
         OI    SWIT+2,X'02'        SET FLAG FOR LEN 85-170
         BR    R7
         MVC   8(2,R4),=H'85'      SHOW FULL LEN FOR SEG 2
         LA    R4,12(R4)           POINT TO NEXT SEG
         SH    R5,=H'170'          NO - DET LENGTH OF
         STH   R5,8(R4)              SEG AND SAVE IN TABLE
         OI    SWIT+2,X'03'        SET FLAG FOR LEN 171-255
         BR    R7
PRNTBREC EQU  *
         LA    R5,RECWORKA         DET OFFSET OF
         LR    R6,R1                 FIRST BYTE OF
         SR    R6,R5                    THE FOUND ARGU
         LA    R5,PRTTABLE         POINT TO TABLE
         CH    R6,=H'85'           WAS FIRST BYTE OF HIT IN FIRST
*                                  SEGMENT(00-85) OF RECORD
         BNH   *+24                YES
         CH    R6,=H'170'          WAS FIRST BYTE OF HIT IN SECOND
*                                  SEGMENT(86-170) OF RECORD
         BH    *+12                NO ASSUME THIRD SEGMENT (171-255)
         LA    R5,12(R5)           POINT TO SECOND SEGMENT
         B     *+8
         LA    R5,24(R5)           POINT TO THIRD SEGMENT
         AP    10(2,R5),=P'1'      ADD 1 TO NUM OF HITS IN SEGMENT
         CP    10(2,R5),=P'1'      IS THIS FIRST HIT IN SEGMENT
         BNER  R7
         ST    R1,0(R5)            SAVE ADDRESS OF FIRST HIT IN SEG
         MVC   4(3,R5),ARGNO       SAVE ARG NO OF FIRST HIT IN SEG
         MVC   7(1,R5),ARGLNG      SAVE LENGTH OF FIRST HIT IN SEG
         BR    R7                  SAVE ADDRESS OF FIRST HIT IN SEG
         EJECT
LIMITRTE EQU   *
         TM    SWIT+3,X'80'        IS THIS ENTRY TO VALIDATE LIMITS
         BNO   LIMITCHK            NO - GO CHECK LIMIT
         NI    SWIT+3,X'3F'        TURN OFF VALIDATE AND ERROR BITS
         MVI   TRTTAB,X'01'             USE TRT
         MVC   TRTTAB+1(255),TRTTAB       INSTRUCTION
         XC    TRTABAF,TRTABAF              TO VALIDATE
         XC    TRTAB09,TRTAB09                 FIRST 4 COLS
         TRT   CARDIN(4),TRTTAB                  FOR HEX DATA
         BC    8,*+16
         MVC   ERR1RC,=C'01'       SHOW INVALID SEARCH LIMITS
LIMITSRX EQU   *
         OI    SWIT+3,X'40'        INVALID SEARCH LIMIT ENTRY
         BR    R7
         MVC   SEARCHLD,CARDIN     MOVE HEX CHARACTERS TO WORK AREA
         MVC   TRTABAF,TRTABAFH    SET TRT TABLE TO TRANSLATE
         MVC   TRTAB09,TRTAB09H      COLUMN SEARCH LIMIT ENTRIES
         TR    SEARCHLD,TRTTAB     TRANSLATE TO BINARY CHARACTERS
         XR    R5,R5
         XR    R6,R6
         IC    R5,SRBEGBIN         MAKE SEARCH
         IC    R6,SRBEGBIN+1         BEGIN ENTRY
         SLL   R5,4                    USABLE TO DO
         OR    R6,R5                     BINARY OPERATIONS
         STH   R6,SRBEGBIN
         IC    R5,SRLGNBIN         MAKE SEARCH
         IC    R6,SRLGNBIN+1         LENGTH ENTRY
         SLL   R5,4                    USABLE TO DO
         OR    R6,R5                     BINARY OPERATIONS
         STH   R6,SRLGNBIN
         LH    R5,SRBEGBIN         IF THE BEGINNING OF
         AH    R5,SRLGNBIN           THE SEARCH LIMIT PLUS
         CH    R5,=H'256'               THE LENGTH EXCEEDS 255
         BCR   13,R7                      TREAT AS AN ERROR COND
         MVC   ERR1RC,=C'02'
         B     LIMITSRX
LIMITCHK EQU   *
         C     R1,ARGLOLIM         IS BEGINNING OF FOUND
         BNL   *+10                  ARGUMENT BELOW LOWER
LIMITCRX EQU   *                       LIMIT OF SEARCH
         NI    SWIT+3,X'DF'        YES - ERROR
         BR    R7
         XR    R5,R5
         IC    R5,ARGLNG           IS THE END OF FOUND
         AR    R5,R1                 ARGUMENT ABOVE UPPER
         C     R5,ARGUPLIM             LIMIT OF SEARCH
         BH    LIMITCRX            YES - ERROR
         OI    SWIT+3,X'20'        SET SWITCH TO SHOW
         BR    R7                    ARG FOUND W/I LIMITS
         EJECT
MEMLSTRT EQU   *
         TM    SWIT+3,X'02'        IS THIS ENTRY TO CHECK FOR A MATCH
*                                  OF CURRENT MEMBER WITH MEMBER LISTS
         BO    MEMMATCH            YES
*                                  NO - ENTRY IS DURING PROCEESING OF
*                                  EXEC PARMS AND A TABLE OF MEMBER
*                                  PARMS WILL BE BUILT AT MEMLSTTB
         TM    3(R6),X'80'         IS IT FROM/TO
         BNO   CHKRANGE            NO - GO CHECK FOR RANGE
         CLC   PARMHOLD(7),=C'MEMFROM'  IS IT FROM
         BNE   *+22                NO
         CLC   MEMFROM,HEXZEROS    IS IT FIRST ENTRY FOR FROM
         BNE   MEMLSTER            NO ERROR
         MVC   MEMFROM,PARMHOLD+8  SAVE FROM PARM
         BR    R7                  RETURN
         CLC   PARMHOLD(5),=C'MEMTO'    IS IT TO
         BNE   CHKRANGE            NO
         CLC   MEMTO,FS            IS IT FIRST ENTRY FOR TO
         BNE   MEMLSTER            NO ERROR
         MVC   MEMTO,PARMHOLD+6    SAVE TO PARM
         BR    R7                  RETURN
MEMLSTER EQU   *
         OI    SWIT+3,X'01'        ERROR IN MEMBER LIST PARM
         BR    R7                  RETURN
CHKRANGE EQU   *
         TM    3(R6),X'40'         IS IT RANGE
         BNO   CHKPATRN            NO - GO CHECK FOR PATTERN
         CLC   MEMRANGE,BLANKS     IS IT FIRST ENTRY FOR RANGE
         BNE   MEMLSTER            NO
         CLI   PARMHOLD+10,C':'    IS HI AND LO RANGE SEP BY :
         BNE   MEMLSTER            NO - ERROR
         CLC   PARMHOLD+9,PARMHOLD+11   IS B GREATER THAN A
         BNL   MEMLSTER            NO - ERRROR
         MVC   MEMRANGE,PARMHOLD+9      SAVE RANGE PARM
         BR    R7                  RETURN
CHKPATRN EQU   *
         TM    3(R6),X'20'         IS IT PATTERN
         BNO   CHKSTRNG            NO - GO CHECK FOR STRING
         CLC   MEMPATRN,BLANKS     IS IT FIRST ENTRY FOR PATTERN
         BNE   MEMLSTER            NO - ERROR
         MVC   MEMPATRN,PARMHOLD+11     SAVE PATTERN PARM
         BR    R7                  RETURN
CHKSTRNG EQU   *
         TM    3(R6),X'10'         IS IT STRING
         BNOR  R7                  NO - RETURN
         CLC   MEMSTRNG,BLANKS     IS IT FIRST ENTRY FOR STRING
         BNE   MEMLSTER            NO - ERROR
         XR    R8,R8          CALCULATE
         XR    R9,R9            THE LENGTH
         IC    R8,0(R6)           OF THE STRING
         IC    R9,1(R6)             TO BE USED AS
         SR    R8,R9                  A MEMBER LIST
         BCTR  R8,R0          SAVE THE
         STC   R8,MEMSTRNL      LENGTH
         EX    R8,*+6         SAVE STRING
         BR    R7
         MVC   MEMSTRNG(0),PARMHOLD+10
MEMMATCH EQU   *
         NI    SWIT+3,X'FE'        TURN OFF HIT SWITCH
         TM    PARMSWIT+1,X'80'    IS THERE A FROM/TO PARM
         BNO   SRCMEMRG            NO - GO CHECK FOR RANGE
         CLC   MEMBER,MEMFROM      IS MEMBER LOWER THAN START
         BL    SRCMEMRG            YES - NO HIT
         CLC   MEMBER,MEMTO        IS MEMBER HIGHER THAN TO
         BH    SRCMEMRG            YES - NO HIT
         OI    SWIT+3,X'01'        SHOW HIT
SRCMEMRG EQU   *
         TM    PARMSWIT+1,X'40'    IS THERE A RANGE PARM
         BNO   SRCMEMPT            NO - GO CHECK FOR PATTERN
         CLC   MEMBER(1),MEMRANGE       IS THE FIRST CHAR OF THE MEM
*                                       LOWER THAN BEGINNING OF RANGE
         BL    SRCMEMPT            YES - NO HIT
         CLC   MEMBER(1),MEMRANGE+2     IS THE FIRST CHAR OF THE MEM
*                                       HIGHER THAN END OF THE RANGE
         BH    SRCMEMPT            YES - NO HIT
         OI    SWIT+3,X'01'        SHOW HIT
SRCMEMPT EQU   *
         TM    PARMSWIT+1,X'20'    IS THERE A PATTERN PARM
         BNO   SRCMEMST            NO - GO CHECK FOR STRING
         LA    R3,8                LENGTH
         LA    R4,MEMBER           POINT TO CURRENT MEMBER
         LA    R5,MEMPATRN         POINT TO PATTERN
SRCMEMLP EQU   *
         CLI   0(R5),C'+'          IS THIS POSITION IN THE MEMBER
*                                  NAME TO BE TREATED AS A PATTERN
         BE    SRCMEMBP            YES BYPASS COMPARE
         CLC   0(1,R4),0(R5)       IS THE BYTE IN THIS POSITION OF
*                                  MEMBER NAME EQUAL TO THE PATTERN
         BNE   SRCMEMST            NO - NOT A MATCH
SRCMEMBP EQU    *
         LA    R4,1(R4)            NEXT MEMBER POSITION
         LA    R5,1(R5)            NEXT PATTERN POSITION
         BCT   R3,SRCMEMLP         LOOP
         OI    SWIT+3,X'01'        SHOW HIT
SRCMEMST EQU   *
         TM    PARMSWIT+1,X'10'    IS THERE A STRING PARM
         BO    *+6                 YES - CHECK FOR STRING
         BR    R7                  NO - RETURN
         LA    R3,MEMBER           BEGINNING OF MEMBER NAME
         LA    R4,MEMBER+8         END OF MEMBER NAME PLUS 1
         XR    R6,R6
         IC    R6,MEMSTRNL         LENGTH OF STRING
SRCSTRLP EQU   *
         EX    R6,MEMSTRCP         DO THE NEXT XX BYTES IN MEMBER
*                                  MATCH THE STRING IN MEMSTRNG
         BNE   *+10
         OI    SWIT+3,X'01'        SHOW HIT
         BR    R7                  RETURN
         LA    R3,1(R3)            WHEN LENGTH OF
         LR    R5,R3                 STRING PLUS NEXT
         AR    R5,R6                   CHARACTER IN MEMBER
         CR    R5,R4                     EXCEEDS EIGHT THE
         BNLR  R7                          STRING IS NOT PRESENT
         B     SRCSTRLP
MEMSTRCP EQU   *
         CLC   0(0,R3),MEMSTRNG
         EJECT
SORTRTNE EQU   *
SORT1    EQU   *
         L     R8,ARGSAVE+4        START OF TABLE
         OI    SWIT+1,X'04'        SET SORTED SWITCH
         LA    R3,ARGFL+ARGENTSZ   SECOND ENTRY
SORT2    EQU   *
         CLI   2(R3),X'00'         IS THIS END OF TABLE
         BE    SORT4               YES - GO CHECK FOR SORTED CONDITION
         TM    SWIT+3,X'10'        IS THIS SORT BY ARGNO
         BNO   *+14                NO
         CLC   2(L'ARGNO,R3),ARGNO IS SECOND ENTRY GREATER THAN 1ST
         B     *+10
         CLC   6(L'ARG,R3),ARG     IS SECOND ENTRY GREATER THAN 1ST
         BNL   SORT3               YES - GO UPDATE POINTERS
         NI    SWIT+1,X'FB'        NO - CLEAR SORTED SWITCH AS
*                                    ENTRIES HAD TO BE REVERSED
         XC    0(ARGENTSZ,R3),ARGENT    REVERSE
         XC    ARGENT(ARGENTSZ),0(R3)     THESE 2
         XC    0(ARGENTSZ,R3),ARGENT        ENTRIES
SORT3    EQU   *
         LR    R8,R3               MAKE 2ND ENTRY 1ST
         LA    R3,ARGFL+ARGENTSZ   GET NEXT ENTRY AS 2ND
         B     SORT2               GO COMPARE THEM
SORT4    EQU   *
         TM    SWIT+1,X'04'        IS TABLE SORTED SWITCH STILL SET
         BNO   SORT1               NO - GO BACK AND RE-DO
         BR    R2
         EJECT
RESETADD EQU   *
         LA    R1,MEM1             RESET
         ST    R1,MEMDECBS           DECB ADDRESSES
         LA    R1,MEM2                 FOR MEMBER
         ST    R1,MEMDECBS+4             DCB
         LM    R0,R1,IOARSAVE      GET I/O AREA SIZE AND ADDRESS
         SH    R0,=H'512'          RESET
         LA    R1,512(R1)            BUFFER
         ST    R1,MEMBADDR             ADDRESSES
         SRL   R0,1                      FOR I/O AREAS
         AR    R1,R0                       USED BY THIS
         ST    R1,MEMBADDR+4                 MEM DATA SET
         BR    R2
         EJECT
SWIT     DC    X'0000000000'
*        SWITCH SETTINGS
*        80 READ MEMBER DCB
*        40 SUB READS MEM.
*        20 SUB READS DIR.
*        10 FLUSH
*        08 HIT-THIS PDS
*        04 HIT-THIS MEMBER
*        02 BUFFERS GOTTEN
*        01 COPY IN EFFECT
*        SECOND BYTE
*        80 PRINT HEADINGS
*        40 INVALID FILE
*        20 PAGE # IN INDEX
*        10 PDS CARD TO SCAN IN RUN
*        08 CORE GOTTEN FOR ARGUMENT TABLE
*        04 ARGUMENT TABLE SORTED
*        02 INVALID PARAMETRS/S
*        01 CORE GOTTEN FOR BIT TABLE
*        THIRD BTYE
*        80 ALL ARGUMENTS ENTERED AS PATTERNS
*        40 ARG ENTERED AS PATTERN/ARG CONTAINS +!@#(S)
*        20 ERROR IN ARGUMENTS PATTERN
*        10 UNEQUAL COMPARE DATA VS ARGUMENT
*        08 BUILD RECORD SEGMENT TABLE
*        04 PRINT HITS/RECORD
*        02 + 01 RECORD LENGTH
*             01   00-85 BYTES
*             10   86-170 BYTES
*             11   171-255 BYTES
*        FOURTH BYTE
*        80 VALIDATE ARGUMENT SEARCH LIMITS
*        40 INVALID ARGUMENT SEARCH LIMITS
*        20 ARGUMENT FOUND W/I SEARCH LIMITS
*        10 SORT ARG TAB BY ARG
*        08 HIT-RUN
*        04 VARIABLE LENGTH RECORDS
*        02 CHECK FOR MATCH IN MEMLSTRT
*        01 ERROR IN A MEMPARM/HIT IN MEMLSTRT
*        FIFTH BYTE
*        80 VARIABLE LENGTH NULL RECORD
*        04 1ST PASS IN SCANRTNE (RECORD LOGIC IN COPY)
*        02 SEQUENTIAL DATA SET
*        10 UNUSED
*        08 UNUSED
*        04 UNUSED
*        02 UNUSED
*        01 UNUSED
PARMSWIT DC    X'0000'
*        SWITCH SETTINGS
*        80 DO NOT PRINT MEMBER LIST
*        40 SHOW DISK ADDRESS OF MEMBER
*        20 ENTER ARGUMENTS VIA CONSOLE
*        10 PRINT ONLY HIT LINES (NEW DEFAULT)
*        08 AND PROCESSING
*        04 ALL ARGUMENTS ARE PATTERNS
*        02 PRINT TOTALS BY ARGUMENT
*        01 PRINT ALL LINES (OLD DEFAULT)
*        SECOND BYTE
*        80 MEMBER LIST FROM/TO
*        40 MEMBER LIST RANGE
*        20 MEMBER LIST PATTERN
*        10 MEMBER LIST STRING
*        08 AND LOGIC AT RECORD LEVEL
*        04 TRUNCATE (ALLOW LRECL(264) BUT ONLY PROCESS 255)
*        02 PROCESS ALIASES
*        01 UNUSED
PARMHOLD DS    CL19
PARMTAB  EQU   *
         DC    X'06068000'
         DC    CL6'NOLIST'
         DC    X'02028000'
         DC    CL2'NL'
         DC    X'05058000'
         DC    CL5'DS(*)'
         DC    X'08084000'
         DC    CL8'DISKADDR'
         DC    X'02024000'
         DC    CL2'DA'
         DC    X'07072000'
         DC    CL7'CONSOLE'
         DC    X'08081000'
         DC    CL8'LISTHITS'
         DC    X'02021000'
         DC    CL2'LH'
         DC    X'07070100'
         DC    CL7'LISTALL'
         DC    X'02020100'
         DC    CL2'LA'
         DC    X'03030800'
         DC    CL3'AND'
         DC    X'06060808'
         DC    CL6'RECORD'
         DC    X'03030808'
         DC    CL3'REC'
         DC    X'08080400'
         DC    CL8'PATTERNS'
         DC    X'04040400'
         DC    CL4'PATS'
         DC    X'07070200'
         DC    CL7'ARGTOTS'
         DC    X'02020200'
         DC    CL2'AT'
         DC    X'05050002'
         DC    CL5'ALIAS'
         DC    X'08080004'
         DC    CL8'TRUNCATE'
         DC    X'02020004'
         DC    CL2'TR'
         DC    X'10080080'
         DC    CL8'MEMFROM='
         DC    X'0E060080'
         DC    CL6'MEMTO='
         DC    X'0C090040'
         DC    CL9'MEMRANGE='
         DC    X'130B0020'
         DC    CL11'MEMPATTERN='
         DC    X'0B0A0010'
         DC    CL10'MEMSTRING='
         DC    X'0C0A0010'
         DC    CL10'MEMSTRING='
         DC    X'0D0A0010'
         DC    CL10'MEMSTRING='
         DC    X'0E0A0010'
         DC    CL10'MEMSTRING='
         DC    X'0F0A0010'
         DC    CL10'MEMSTRING='
         DC    X'100A0010'
         DC    CL10'MEMSTRING='
         DC    X'110A0010'
         DC    CL10'MEMSTRING='
         DC    X'120A0010'
         DC    CL10'MEMSTRING='
         DC    X'FF'
         EJECT
TIOTHOLD DS    F
HDRM1    DC    CL32'1CRD ARG BEG END ARG LN ARGUMENT'
HDRM1A   DC    CL3'ENT'
HDRM2    DC    CL32' NO. NO. COL COL OPT GT   TEXT  '
HDRM2T1  DC    CL40'1 ARGUMENT HIT TOTALS BY ARGUMENT NUMBER'
HDRM2T2  DC    CL40'0ARG  TOTAL  MEMBS PDSES ARG LN ARGUMENT'
HDRM2T3  DC    CL40' NO. FOR ARG  HIT   HIT  OPT GT   TEXT  '
HDRS1    DS    0CL133
         DC    CL23'1SYSPRINT LISTING FOR ('
HDRS1VOL DS    CL6
         DC    CL2')-'
HDRS1DSN DS    CL44
         DC    CL50'                                                PA'
         DC    CL2'GE'
ZSUPMASK DC    XL6'402020202020'
HDRS21   DS    0CL133
         DC    CL48' -MEMBER- RECORD 1...5...10....5...20....5...30.'
         DC    CL48'...5...40....5...50....5...60....5...70....5...8'
         DC    CL37'0....5 REC LINE  LOC-1ST  ARG-1ST    '
HDRS21A  DC    CL3'LGN'
HDRS22   DS    0CL85
         DC    CL48'...90....5..100....5..110....5..120....5..130...'
         DC    CL37'.5..140....5..150....5..160....5..170'
HDRS23   DS    0CL85
         DC    CL48'....5..180....5..190....5..200....5..210....5..2'
         DC    CL37'20....5..230....5..240....5..250....5'
HDRI1    DC    CL54'1                  INDEX LISTING                   X
                  '
HDRI3    DC    CL54' -MEMBER-  PAGE RECRDS W/HITS  T HITS ARGS         X
                  '
HDRI3A   DC    CL8'DISKADDR'
PRNTTAB  EQU   *
         DC    CL3'PAT'
         DC    CL3'EXC'
         DC    CL3'E/P'
CARDIN   DS    CL80
TRTAB    DC    CL16'0123456789ABCDEF'
TRTABAFH DC    XL6'0A0B0C0D0E0F'
TRTAB09H DC    XL10'00010203040506070809'
PATRNTAB EQU   *
         DC    CL1'+'
         DC    XL1'00'
         DC    CL1'!'
         DC    XL1'80'
         DC    CL1'@'
         DC    XL1'40'
         DC    CL1'#'
         DC    XL1'C0'
         DC    CL1'*'
BITSETTB EQU   *
         DC    BL1'10000000'
         DC    BL1'01000000'
         DC    BL1'00100000'
         DC    BL1'00010000'
         DC    BL1'00001000'
         DC    BL1'00000100'
         DC    BL1'00000010'
         DC    BL1'00000001'
XLIST    DS    0F
         DS    F
F1DSCB   CAMLST SEARCH,0,0,0
         DS    0H
SEQDIR   DS    0CL22
SEQDIRLN DC    H'22'
SEQDIRN1 DC    CL1'#'
SEQDIRN2 DS    CL7
SEQDIRTT DC    X'00000100'
SEQDIRST DC    X'FFFFFFFFFFFFFFFF'
CONSLECB DS    F
         CNOP  0,4
WTOMSG   DS    55C
         ORG   WTOMSG
WTOMSGLN DC    H'55'
WTOMFLGS DC    H'00'
         DC    CL20'**CXYPSCAN ENDED RC('
WTORC    DS    CL2
         DC    CL6') PDS('
WTODSN   DS    CL20
         DC    CL3')**'
ERR0     DC    CL22'INVALID PARAMETER/S - '
ERR1     DS    0CL33
         DC    CL21'INVALID ARGUMENT RC=('
ERR1RC   DC    CL2'XX'
         DC    CL10') ENT WAS '
ERR2     DC    CL32'              INCORRECT FOR SCAN'
ERR2A    DC    CL13'DATA SET ORG.'
ERR2B    DC    CL13'LRECL/BLKSIZE'
ERR2C    DC    CL32'REQUESTED DATA SET NOT ON VOLUME'
ERR3     DC    CL21'NO ARGUMENT/S ENTERED'
ERR4     DC    CL43'NO PDS OR PROC DD CARD IN JCL FOR THIS STEP'
ERR5     DC    CL31'MORE THAN 255 ARGUMENTS ENTERED'
NOHITSM  DC    CL18'NO HITS IN FILE - '
CRDCT    DC    PL2'0'
ARGCT    DC    PL2'0'
EXCCT    DC    PL2'0'
NEXTARG  DC    PL2'1'
SCANMEMS DC    PL4'0'
SCANRECS DC    PL4'0'
SCANCNT  DC    PL4'0'
COPYCNT  DC    PL4'0'
HITSMEMS DC    PL3'0'
HITWIMEM DC    PL4'0'
HITSRECS DC    PL4'0'
HITSWIRE DS    PL3
HITSWIRT DC    PL4'0'
ARGWIMEM DC    PL3'0'
ARGTOTAL DC    PL3'0'
RECSDSP  DC    PL4'0'
PAGESPDS DS    PL3
PAGEBEGP DC    PL3'1'
PAGECNT  DC    PL3'0'
STARTSTS DS    CL25
         ORG   STARTSTS
STARTCDT DS    CL11
         DC    CL4' AT '
STARTTME DS    CL6
         DS    CL4
STOPSTS  DS    CL25
         ORG   STOPSTS
STOPCLDT DS    CL11
         DC    CL4' AT '
STOPTIME DS    CL6
         DS    CL4
JULDT    DS    CL7
DODDT    DS    CL8
CMPLCD   DS    CL1
OPTNSMSG DS    CL47
         ORG   OPTNSMSG
         DC    CL16'OPTNS:ARG INPUT='
OPTNSARG DC    CL7'SYSIN  '
         DC    CL10',SYSPRINT='
OPTNSPRT DC    CL4'HITS'
         DC    CL7',LOGIC='
OPTNSLOG DC    CL3'OR '
STUBMEML DC    CL9'MEMLST/S:'
TOTSMSG  DC    CL70'MEMBERS PROCESSED PDS WITH MEMLST/SRECORDS PROCESSEX
               D PDS WITH MEMLST/S'
HITSMSG  DC    CL54'NUMBER OF MEMBERS WITH HITSNUMBER OF HITS IN THIS PX
               DS '
ARGSMSG  DC    CL27'NUMBER OF ARGUMENTS FOUND  '
STARTMSG DC    CL22'START TIME FOR PDS IS '
STOPMSG  DC    CL5'STOP '
RECDISPM DC    CL27'NUMBER OF RECORDS DISPLAYED'
PGSDISPM DC    CL27'PAGES IN SYSPRINT/THIS PDS '
PGRANGES DC    CL27'FIRST PAGE IN SYSPRINT/PDS '
PGRANGEE DC    CL5'FINAL'
ARGLOC   DC    CL11' (XXX-YYY) '
STUBDDN  DC    CL14'DATA DEF NAME:'
STUBDSN  DC    CL14'DATA SET NAME:'
STUBVOL  DC    CL14'VOLUME SERIAL:'
STUBATTR DC   CL14'ORG-RF-LR-BLK:'
LINCTM   DC    XL1'3B'
LINCTM2  DC    XL1'39'
LINCTI   DC    XL1'3B'
LINCT    DS    CL1
OBTNRCHD DS    CL1
RETCODEF DC    X'00'               RETURN CODE LAST FILE PROCESSED
RETCODE  DC    X'00'               RETURN CODE HIGHEST IN RUN
*        RC SETTINGS
*        00 HITS ON ALL SEARCHED FILES
*        04 NO HITS ON SOME OR ALL FILES
*        08 BAD LRECL/BLKSIZE OR NOT PDS
*        0C NO ARGUMENT/S ENTERED
*        10 MORE THAN 255 ARGUMENTS EMTERED
*        14 NO PDS OR PROC DD CARD/S
*        18 BAD PARAMETER/S ENTERED
*        1C ALL ARGUMENTS EXCLUDED
HEXZEROS DC    X'0000000000000000'
FS       DC    X'FFFFFFFFFFFFFFFF'
MASKS    DS    0F
MASK1F   DC    X'0000001F'
MASK03   DC    X'00000003'
ASTERICS DC    CL7'*******'
         DS    0F
PRTTABLE DS    0CL36
PRTTABE1 EQU   *
         DS    F         ADDRESS OF 1ST HIT THIS SEGMENT OF RECORD
         DS    CL3       ARG NO. OF 1ST HIT THIS SEGMENT OF RECORD
         DS    BL1       LENGTH OF 1ST HIT THIS SEGMENT OF RECORD
         DS    H         LENGTH OF THIS SEGMENT OF RECORD
         DS    PL2       NUMBER OF HITS THIS SEGMENT OF RECORD
PRTTABE2 EQU   *
         DS    F         ADDRESS OF 1ST HIT THIS SEGMENT OF RECORD
         DS    CL3       ARG NO. OF 1ST HIT THIS SEGMENT OF RECORD
         DS    BL1       LENGTH OF 1ST HIT THIS SEGMENT OF RECORD
         DS    H         LENGTH OF THIS SEGMENT OF RECORD
         DS    PL2       NUMBER OF HITS THIS SEGMENT OF RECORD
PRTTABE3 EQU   *
         DS    F         ADDRESS OF 1ST HIT THIS SEGMENT OF RECORD
         DS    CL3       ARG NO. OF 1ST HIT THIS SEGMENT OF RECORD
         DS    BL1       LENGTH OF 1ST HIT THIS SEGMENT OF RECORD
         DS    H         LENGTH OF THIS SEGMENT OF RECORD
         DS    PL2       NUMBER OF HITS THIS SEGMENT OF RECORD
ARGSZHLD DS    H
NOLNEHLD DS    CL1
TTRN     DC    F'0'
         EJECT
         LTORG *
         EJECT
         DS    0F
         READ  MEM1,SF,,,,MF=L
         READ  MEM2,SF,,,,MF=L
MEMDECBS DS    0D
         DC    A(MEM1)
         DC    A(MEM2)
MEMBADDR DS    0D
         DS    F   ADDRESS OF FIRST BUFFER
         DS    F   ADDRESS OF FSECOND BUFFER
         READ  DIR1,SF,,,,MF=L
         READ  DIR2,SF,,,,MF=L
DIRDECBS DS    0D
         DC    A(DIR1)
         DC    A(DIR2)
DIRBADDR DS    0D
         DS    F ADDRESS OF FIRST BUFFER
         DS    F ADDRESS OF SECOND BUFFER
IOBADDR  DS    0F
         DS    F
         EJECT
DIR      DCB   DSORG=PS,MACRF=(R),DDNAME=PDS,EODAD=ENDDIR,             X
               BLKSIZE=256,NCP=2
         EJECT
MEM      DCB   DSORG=PO,MACRF=(R),DDNAME=PDS,EODAD=ENDMEM,NCP=2,       X
               EXLST=XLIST
         EJECT
LIST     DCB   DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA,DDNAME=SYSPRINT
         EJECT
MESSAGE  DCB   DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA,DDNAME=MESSAGE
         EJECT
INDEX    DCB   DSORG=PS,MACRF=PM,LRECL=53,RECFM=FA,DDNAME=INDEX
         EJECT
CARD     DCB   DSORG=PS,MACRF=GM,LRECL=80,DDNAME=SYSIN,EODAD=ENDCARD
         EJECT
ARGTAB   DSECT
ARGENT   EQU   *
ARGFL    DS    CL1
*        80 LAST ENTRY BEGIN/W THIS CHARACTER
*        40 ARGUMENT FOUND IN CURRENT MEMBER
*        20 ARGUMENT FOUND IN CURRENT DDNAME
*        10 EXCLUDE THIS ARGUMENT
*        08 ARGUMENT CONTAINS PATTERN
*        04 ARGUMENT HAS SEARCH LIMITS
ARGLNG   DS    CL1
ARGNO    DS    CL3
ARGNOBIN DS    CL1
ARG      DS    CL73
ARGLOLIM DS    F
ARGUPLIM DS    F
ARGMEM   DS    CL8
ARGDDNAM DS    CL8
ARGTARG  DS    PL4
ARGTMEM  DS    PL3
ARGTPDS  DS    PL3
ARGEND   EQU   *
ARGENTSZ EQU   ARGEND-ARGENT
         EJECT
WORK     DSECT
SAVE     DS    18F
WORKSAVE DS    D
IOARSAVE DS    D
ARGSAVE  DS    D
PTRNSAVE DS    D
CNTADDR  DS    D
DIRRECAD DS    F
TRTTAB   DS    0CL256
         DS    CL129
TRTABAIL DS    CL9
         DS    CL7
TRTABJRL DS    CL9
         DS    CL8
TRTABSZL DS    CL8
         DS    CL23
TRTABAF  DS    CL6
         ORG   TRTABAF
TRTABAIU DS    CL9
         DS    CL7
TRTABJRU DS    CL9
         DS    CL8
TRTABSZU DS    CL8
         DS    CL6
TRTAB09  DS    CL10
         DS    CL6
TRTTABHD DS    CL256
JFCB     DS    44F
F1WORK   DS    0D
         DS    96C
SEARCHLD DS    F
         ORG   *-4
SRBEGBIN DS    H
SRLGNBIN DS    H
READSAVE DS    5F
PTRTSAVE DS    5F
FWORD    DS    F
DWORD    DS    D
DDNAME   DS    CL8
MEMBER   DS    CL8
MEMLSTTB DS    0CL36
MEMFROM  DS    CL8
MEMTO    DS    CL8
MEMRANGE DS    CL3
MEMPATRN DS    CL8
MEMSTRNG DS    CL8
MEMSTRNL DS    CL1
CC       DS    CL1
PRNTWRK  DS    CL132
CCI      DS    CL1
PRNTWRKI DS    CL53
CLEARWRK EQU   *
CLEARSZE EQU   CLEARWRK-CC
BLANKS   DS    CL73
RECLEN   DS    H
RECLENV  DS    H
RECWORKA DS    CL255
STOPPER  DS    CL1
WORKEND  EQU   *
WORKSIZE EQU   WORKEND-WORK
         EJECT
         END
