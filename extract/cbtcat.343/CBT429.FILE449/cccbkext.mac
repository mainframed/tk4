BKEXT    TITLE 'BOOKMANAGER INFORMATION DATA EXTRACT PROGRAM'
***********************************************************************
*                                                                     *
*        BOOKMANAGER INFORMATION DATA EXTRACT PROGRAM                 *
*                                                                     *
*        PARAMETERS                                                   *
*                                                                     *
*        ACTIVE,BOOKSHELFLISTS                                        *
*        VOLUME,BOOKSHELFLISTS                                        *
*                                                                     *
*        THE PARM FIELD IS A LIST OF ONE OR MORE BOOKMANAGER          *
*        BOOKSHELF LIST DATA SETS, FULLY QUALIFIED WITHOUT            *
*        APOSTROPHES.                                                 *
*                                                                     *
*        INFO,BOOKSHELFPDS                                            *
*                                                                     *
*        THE PARM FIELD IS A SINGLE PDS DATA SET NAME WHICH           *
*        CONTAINS ONE OR MORE BOOKSHELVES AS MEMBERS.  THE DATA       *
*        SET NAME IS FULLY QUALIFIED WITHOUT APOSTROPHES.             *
*                                                                     *
***********************************************************************
*
         PUNCH '         PAGE  CCCBKEXT'  MAKE DEBUGGING EASIER
*
CCCBKEXT CSECT
CCCBKEXT AMODE 31
CCCBKEXT RMODE 24
*
         USING CCCBKEXT,R15        INITIAL BASE REGISTER
         B     AROUNDID
         DC    CL8'CCCBKEXT'       MODULE ID
         DC    CL8'V 1.5.1'        MODULE LEVEL
         DC    CL8'&SYSDATC'
         DC    CL8' &SYSTIME'
*
AROUNDID DS    0H
         STM   R14,R12,12(R13)     SAVE REGISTERS
         LR    R12,R15             SET THE BASE REGISTER
         LA    R11,2048            PREP THE SECOND
         LA    R11,2048(R11,R12)    BASE REGISTER
         DROP  R15
         USING CCCBKEXT,R12,R11
*
         L     R14,=A(SAVEAREA)    POINT AT NEW SAVE AREA
         ST    R14,8(,R13)         FORWARD CHAIN
         ST    R13,4(,R14)         BACK CHAIN
         LR    R13,R14             SET NEW SAVE AREA
         USING SAVEAREA,R13        PROVIDE ADDITIONAL ADDRESSABILITY
*
         LR    R2,R1               SAVE THE PARM FIELD ADDRESS
*
         EJECT
***********************************************************************
*                                                                     *
*        LOAD THE CELL POOL SUBROUTINE                                *
*                                                                     *
***********************************************************************
*
         LOAD  EPLOC=CPSNAME,ERRET=LOADERR0 LOAD THE CELL POOL ROUTINE
         ST    R0,CPSADDR
*
***********************************************************************
*                                                                     *
*        EXTRACT THE PARM FIELD TO CREATE THE INITIAL LIST            *
*        OF BOOKSHELF LIST DATA SET NAMES.                            *
*                                                                     *
***********************************************************************
*
         L     R2,0(,R2)           LOAD FIRST PARM ADDRESS
         LH    R3,0(,R2)           LOAD THE PARM LENGTH
         LTR   R3,R3               TEST THE PARM LENGTH
         BZ    PARMINVL            IF NONE, PARM IS INVALID
         LA    R2,2(,R2)           INCREMENT PAST THE LENGTH FIELD
*
         CH    R3,=H'6'            CHECK MINIMUM LENGTH THAT'S VALID
         BL    PARMINVL            ERROR IF TOO SMALL
         CLC   0(5,R2),=C'INFO,'   IS THE PARM INFO
         BNE   PARMNINF            BRANCH IF NOT
*
         OI    PROCFLAG,PROCINFO   INDICATE INFO PROCESSING
         LA    R2,5(,R2)           INCREMENT PAST THE INFO PARM
         SH    R3,=H'5'            DECREMENT THE LENGTH LEFT
*
         MVC   DSNHOLD,BLANKS      BLANK THE DATA SET NAME AREA
         LA    R1,DSNHOLD          POINT AT START OF DSN
         LA    R15,DSNHOLD+44      POINT AT END OF DSN
*
PARMINFM DS    0H
         CR    R1,R15              HAVE WE GONE TOO FAR
         BE    PARMERR1            BAD NEWS IF WE HAVE
*
         MVC   0(1,R1),0(R2)       MOVE ONE DSNAME CHARACTER
         LA    R1,1(,R1)           INCREMENT TO NEXT CHARACTER
         LA    R2,1(,R2)           INCREMENT TO NEXT CHARACTER
         BCT   R3,PARMINFM         GO MOVE THE NEXT CHARACTER
*
         B     PARMDONE            AND WE HAVE ONLY ONE DATA SET NAME
*
PARMNINF DS    0H
         CH    R3,=H'8'            CHECK THIS MINIMUM LENGTH
         BL    PARMINVL            STILL BAD ....
         CLC   0(7,R2),=C'ACTIVE,' CHECK FOR ACTIVE DATA SETS
         BE    PARMACTV            BRANCH IF ACTIVE
         CLC   0(7,R2),=C'VOLUME,' CHECK FOR ALTERNATE ACTIVE
         BNE   PARMNACT            BRANCH IF NOT ACTIVE
*
         OI    PROCFLAG,PROCVOL    INDICATE VOLUME PROCESSING AS WELL
*
PARMACTV DS    0H
         OI    PROCFLAG,PROCACTV   INDICATE ACTIVE PROCESSING
         LA    R2,7(,R2)           INCREMENT PAST THE ACTIVE PARM
         SH    R3,=H'7'            DECREMENT THE LENGTH LEFT
*
PARMACTL DS    0H
         MVC   DSNHOLD,BLANKS      BLANK THE DATA SET NAME AREA
         LA    R1,DSNHOLD          POINT AT START OF DSN
         LA    R15,DSNHOLD+44      POINT AT END OF DSN
*
PARMACTM DS    0H
         CLI   0(R2),C','          IS THIS A DELIMITER
         BE    PARMACTE            IF SO, THIS IS THE END OF THE DSN
         CR    R1,R15              HAVE WE GONE TOO FAR
         BE    PARMERR1            BAD NEWS IF WE HAVE
*
         MVC   0(1,R1),0(R2)       MOVE ONE DSNAME CHARACTER
         LA    R1,1(,R1)           INCREMENT TO NEXT CHARACTER
         LA    R2,1(,R2)           INCREMENT TO NEXT CHARACTER
         BCT   R3,PARMACTM         GO MOVE THE NEXT CHARACTER
*
PARMACTE DS    0H
         LA    R0,48               SIZE OF STORAGE
         LA    R1,BKLBLOCK         POINT AT CELL POOL BLOCK
         L     R15,CPSADDR         LOAD CELL POOL ROUTINE ADDRESS
         BASSM R14,R15             GET STORAGE BLOCK
         LR    R1,R15              COPY ADDRESS
         XC    0(4,R1),0(R1)       CLEAR THE CHAIN POINTER
         MVC   4(44,R1),DSNHOLD    COPY THE DATA SET NAME
*
         LA    R15,BKLFIRST        POINT AT FIRST ANCHOR WORD
*
PARMADDL DS    0H
         ICM   R14,15,0(R15)       LOAD THE CHAIN POINTER
         BZ    PARMADDC            BRANCH IF WE'RE AT THE END
         LR    R15,R14             CHAIN AWAY
         B     PARMADDL            AND CONTINUE LOOKING
*
PARMADDC DS    0H
         ST    R1,0(,R15)          ADD TO THE DATA SET NAME CHAIN
*
         LA    R0,1                LOAD 1
         A     R0,BKLCOUNT         ADD OLD COUNT
         ST    R0,BKLCOUNT         STORE NEW COUNT
*
         LTR   R3,R3               DID WE REACH THE END
         BZ    PARMDONE            BRANCH IF SO
         LA    R2,1(,R2)           SKIP THE COMMA
         BCT   R3,PARMACTL         AND LOOP THROUGH THE PARM
*
         B     PARMDONE            AND WE BE DONE
*
PARMNACT DS    0H
         B     PARMINVL            NOT A NICE THING TO HAPPEN
*
PARMDONE DS    0H
*
         EJECT
***********************************************************************
*                                                                     *
*        LOAD THE PUBLICATION NUMBER ROUTINE                          *
*                                                                     *
***********************************************************************
*
         LOAD  EPLOC=PUBNONAM,ERRET=LOADERR1 LOAD PUB NUMBER SUBROUTINE
         ST    R0,PUBNOADR
*
***********************************************************************
*                                                                     *
*        LOAD THE DATA SET NAME ROUTINE                               *
*                                                                     *
***********************************************************************
*
         LOAD  EPLOC=DSNSUB,ERRET=LOADERR2 LOAD DATA SET NAME SUBR
         ST    R0,DSNADDR
*
***********************************************************************
*                                                                     *
*        LOAD THE DATA TABLE                                          *
*                                                                     *
***********************************************************************
*
         LOAD  EPLOC=DATTBL,ERRET=LOADERR3 LOAD DATA TABLE
*
***********************************************************************
*                                                                     *
*        LOAD THE DEFINITION ROUTINE                                  *
*                                                                     *
***********************************************************************
*
         LOAD  EPLOC=DEFSUB,ERRET=LOADERR4 LOAD DATA TABLE
*
*
***********************************************************************
*                                                                     *
*        GET THE CURRENT DATE IN YYYY/MM/DD FORMAT.                   *
*                                                                     *
***********************************************************************
*
         TIME  DEC
         ST    R1,THEDATE          STORE TODAY'S DATE
         AP    THEDATE,=P'1900000' CORRECT THE CENTURY
*
         TM    THEDATE+1,X'01'     TEST FOR ODD YEAR
         BO    DONTLEAP            BRANCH IF SO
         TM    THEDATE+1,X'12'     TEST FOR FOR MULTIPLE OF 4
         BM    DONTLEAP            BRANCH IF NOT
         AP    DAYSFEB,=P'1'       ADJUST THE CALENDAR
*
DONTLEAP DS    0H
         UNPK  DOUBLE(5),THEDATE(3)     GET THE CHARACTER YEAR
         MVC   TODAYYYY,DOUBLE     CAPTURE THE YEAR
         XC    THEDATE(2),THEDATE  KILL THE YEAR
*
         LA    R14,DAYSOOL         POINT AT LIST OF MONTHS
         LA    R15,1               COUNT THE MONTHS
*
MONTHLP  DS    0H
         SP    THEDATE,0(L'DAYSOOL,R14) DECREMENT THE DAYS
         BNP   MONTHGOT            BRANCH WHEN ZERO OR NEGATIVE
         LA    R15,1(,R15)         INCREMENT THE MONTH
         LA    R14,L'DAYSOOL(,R14) INCREMENT THE MONTH POINTER
         B     MONTHLP             AND TRY AGAIN
*
MONTHGOT DS    0H
         AP    THEDATE,0(L'DAYSOOL,R14) PUT THIS MONTH'S DAYS BACK
         OI    THEDATE+3,X'0F'     FIX THE DAY SIGN
         UNPK  TODAYDD,THEDATE+2(2)     STORE THE DAYS OF OUR MONTHS
         CVD   R15,DOUBLE          GET THE MONTH NUMBER OR SOMETHING
         OI    DOUBLE+7,X'0F'      FIX THE MONTH SIGN
         UNPK  TODAYMM,DOUBLE+6(2) STORE THE MONTH OF OUR YEARS
*
         EJECT
***********************************************************************
*                                                                     *
*        IF WE ARE IN INFORMATION MODE, ALLOCATE THE BOOKSHELF        *
*        PDS AND EXTRACT ALL OF THE MEMBER NAMES.                     *
*                                                                     *
***********************************************************************
*
         TM    PROCFLAG,PROCINFO   ARE WE IN INFORMATION MODE
         BZ    NOINFOML            BRANCH IF NOT
*
         LA    R1,DSNHOLD          POINT AT DATA SET NAME
         BAL   R8,ALLOCDSN         ALLOCATE THE BOOKSHELF PDS
*
         LTR   R1,R1               DO WE HAVE A DDNAME RETURNED
         BZ    BKSPALOC            IF NOT, WE HAVE A BIG PROBLEM
*
         MVC   DCBDDNAM-IHADCB+BKSDIRCT,0(R1) COPY THE DDNAME
         MVC   DCBDDNAM-IHADCB+BKSHELF,0(R1) COPY THE DDNAME
*
         OPEN  (BKSDIRCT,(INPUT))  OPEN THE BOOKSHELF PDS
         LTR   R15,R15             TEST FOR ANY OPEN ERRORS
         BNZ   BKSPDSER            BAD IF ANY ERRORS
*
         LA    R4,BKSFIRST         POINT AT FIRST CHAIN POINTER
*
PDSDREAD DS    0H
         GET   BKSDIRCT            READ ONE DIRECTORY BLOCK
         LR    R2,R1               COPY THIS BLOCK ADDRESS
*
         LH    R3,0(,R2)           LOAD THE USED SPACE
         LTR   R3,R3               IS IT USED AT ALL
         BZ    PDSDREAD            SKIP BLOCK IF NOT
         LA    R2,2(,R2)           INCREMENT TO FIRST ENTRY
         SH    R3,=H'2'            SUBTRACT OVERHEAD
         BNP   PDSDREAD            GO READ ANOTHER BLOCK IF EMPTY
*
PDSDMEML DS    0H
         CLC   0(8,R2),=8X'FF'     ARE WE AT THE END
         BE    BKSEODIR            IF SO, PRETEND END OF DATA
*
         TM    11(R2),X'80'        IS THIS AN ALIAS MEMBER
         BO    PDSDMEMN            SKIP IT IF SO
*
         LA    R0,16               SIZE OF STORAGE
         LA    R1,MEMBLOCK         POINT AT CELL POOL BLOCK
         L     R15,CPSADDR         LOAD CELL POOL ROUTINE ADDRESS
         BASSM R14,R15             GET STORAGE BLOCK
         LR    R1,R15              COPY ADDRESS
         XC    0(4,R1),0(R1)       CLEAR THE CHAIN POINTER
         MVC   4(8,R1),0(R2)       COPY THE MEMBER NAME
*
         ST    R1,0(,R4)           CHAIN ONTO THE PREVIOUS MEMBER NAME
         LR    R4,R1               UPDATE THE CURRENT CHAIN POINTER
*
         LA    R0,1                LOAD A ONE
         A     R0,BKSCOUNT         ADD PREVIOUS COUNT
         ST    R0,BKSCOUNT         STORE UPDATED COUNT
*
PDSDMEMN DS    0H
         IC    R15,11(,R2)         LOAD THE DATA COUNT
         N     R15,=X'0000007F'    CLEAR THE ALIAS BIT (IF ANY)
         LA    R15,12(,R15)        DOUBLE IT AND ADD OVERHEAD
*
         AR    R2,R15              INCREMENT TO NEXT MEMBER NAME
         SR    R3,R15              DECREMENT LENGTH LEFT
         BP    PDSDMEML            GO GET NEXT MEMBER IF MORE LEFT
         B     PDSDREAD            GO GET NEXT DIRECTORY BLOCK IF NOT
*
BKSEODIR DS    0H
         CLOSE (BKSDIRCT)          CLOSE THE DIRECTORY READER
         FREEPOOL BKSDIRCT         FREE THE BUFFER STORAGE
*
         RDJFCB (BKSHELF)          READ THE JFCB FOR THE BOOKSHELF PDS
*
         OI    JFCBTSDM-JFCB+BKSJFCB,JFCNWRIT INDICATE NO WRITE BACK
         OI    JFCBIND1-JFCB+BKSJFCB,JFCPDS INDICATE PDS MEMBER
*
NOINFOML DS    0H
*
         EJECT
***********************************************************************
*                                                                     *
*        SCAN THE BOOKSHELF LIST DATA SET NAMES AND BUILD A LIST      *
*        OF ALL UNIQUE BOOKSHELVES.                                   *
*                                                                     *
***********************************************************************
*
         TM    PROCFLAG,PROCINFO   TEST IF WE ARE IN INFORMATION MODE
         BO    BKLISTND            IF SO, DON'T PROCESS BOOKSHELF LIST
*
         L     R2,BKLFIRST         POINT AT FIRST BOOKSHELF LIST
*
BKLLOOP1 DS    0H
         CLI   4(R2),C'*'          HAS THE DATA SET BEEN EXCLUDED
         BE    BKLNEXT             IF SO, SKIP IT
*
         LA    R1,4(,R2)           POINT AT DATA SET NAME
         BAL   R8,ALLOCDSN         ALLOCATE THE BOOKSHELF
*
         LTR   R1,R1               DO WE HAVE A DDNAME RETURNED
         BZ    BKLALOCE            IF NOT, ALLOCATION FAILED
*
         MVC   DCBDDNAM-IHADCB+BKLSHELF,0(R1) COPY THE DDNAME
*
         OPEN  (BKLSHELF,(INPUT))  OPEN THE BOOKSHELF LIST
         LTR   R15,R15             TEST FOR ANY OPEN ERRORS
         BNZ   BKLOPENE            BAD IF ANY ERRORS
*
***********************************************************************
*                                                                     *
*        MAIN READ LOOP FOR SCANNING ONE BOOKSHELF LIST               *
*                                                                     *
***********************************************************************
*
BKLREAD1 DS    0H
         GET   BKLSHELF            READ ONE BOOKSHELF LIST RECORD
         LA    R3,4(,R1)           COPY THE RECORD ADDRESS
         LH    R4,0(,R1)           LOAD THE RECORD LENGTH
         SH    R4,=H'4'            ELIMINATE THE RDW
         BZ    BKLREAD1            SKIP A NULL RECORD
*
         CLI   0(R3),C'*'          CHECK FOR A COMMENT STATEMENT
         BE    BKLREAD1            SKIP IT IF SO
*
BKLEADBL DS    0H
         CLI   0(R3),C' '          SKIP ANY LEADING BLANKS
         BNE   BKLSCANV            GO SCAN FOR VERB WHEN PASSED
         LA    R3,1(,R3)           INCREMENT POINTER
         BCT   R4,BKLEADBL         CONTINUE SCAN FOR BLANKS
         B     BKLREAD1            SKIP THIS RECORD IF NULL
*
BKLSCANV DS    0H
         LR    R15,R3              COPY STARTING ADDRESS
*
BKLSCAN1 DS    0H
         CLI   0(R15),C' '         SCAN UNTIL WE FIND A BLANK
         BE    BKLVERB
         LA    R15,1(,R15)         POINT TO NEXT CHARACTER
         BCT   R4,BKLSCAN1         SCAN THROUGH THE STRING
         B     BKLREAD1            REACH THE END HERE AND WE FORGET IT
*
***********************************************************************
*                                                                     *
*        EXTRACT THE BOOKSHELF LIST VERB                              *
*                                                                     *
*        ALL WE ARE INTERESTED IN ARE "SHELF", "INCLUDE", AND         *
*        "XINCLUDE".                                                  *
*                                                                     *
***********************************************************************
*
BKLVERB  LR    R14,R15             COPY BLANK ADDRESS
         SR    R14,R3              GET LENGTH OF VERB
         BCTR  R14,0               DECREMENT FOR OC
         EX    R14,BKLOCVRB        UPPER CASE THE VERB
         LA    R14,1(,R14)         RESTORE THE LENGTH
*
         CH    R14,=H'5'           CHECK THE LENGTH FOR 5
         BL    BKLREAD1            SKIP IF TOO LOW
         BH    BKLVERB1            BRANCH IF TOO HIGH
*
         CLC   0(5,R3),=C'SHELF'   IS THIS A SHELF STATEMENT
         BNE   BKLREAD1            SHIP IT IF NOT
         MVI   VERBTYPE,C'S'       SET THE VERB TYPE
         B     BKLVERBN            AND WE ARE DONE WITH THE VERB
*
BKLVERB1 DS    0H
         CH    R14,=H'7'           CHECK FOR LENGTH OF 7
         BL    BKLREAD1            SKIP IT IF TOO LOW
         BH    BKLVERB2            BRANCH IF TOO HIGH
*
         CLC   0(7,R3),=C'INCLUDE' CHECK FOR INCLUDE
         BNE   BKLREAD1            WE AREN'T INTERESTED IN ANY OTHERS
         MVI   VERBTYPE,C'I'       SET THE VERB TYPE
         B     BKLVERBN            AND CONTINUE ON
*
BKLVERB2 DS    0H
         CH    R14,=H'8'           CHECK FOR LENGTH OF 8
         BNE   BKLREAD1            SKIP IF NOT 8
*
         CLC   0(8,R3),=C'XINCLUDE'     CHECK FOR INCLUDE
         BNE   BKLREAD1            WE AREN'T INTERESTED IN ANY OTHERS
         MVI   VERBTYPE,C'X'       SET THE VERB TYPE
         B     BKLVERBN            AND CONTINUE ON
*
BKLVERBN DS    0H
         LTR   R4,R4               IS THERE ANYTHING LEFT
         BZ    BKLREAD1            FORGET RECORD IF NOT
*
***********************************************************************
*                                                                     *
*        NOW THAT WE HAVE AN INTERESTING VERB, EXTRACT THE DATA       *
*        SET NAME.  FOR "INCLUDE" AND "XINCLUDE", THE DATA SET        *
*        NAME IS THE FIRST PARAMETER.  FOR "SHELF", IT IS THE         *
*        SECOND PARAMETER AND THE FIRST PARAMETER IS THE BOOKSHELF    *
*        NAME DISPLAYED BY BOOKMANAGER, WHICH WE AREN'T INTERESTED    *
*        IN (AT THIS TIME).                                           *
*                                                                     *
***********************************************************************
*
BKLPARM0 DS    0H
         CLI   0(R15),C' '         NOW LET'S FIND ANOTHER NON-BLANK
         BNE   BKLPARM1            BRANCH WHEN WE GET IT
         LA    R15,1(,R15)         INCREMENT POINTER
         BCT   R4,BKLPARM0         SCAN THROUGH THE STATEMENT
         B     BKLREAD1            SKIP STATEMENT IF NO PARMS
*
BKLPARM1 DS    0H
         LR    R3,R15              SAVE THIS PARM STARTING ADDRESS
*
BKLPARM2 DS    0H
         CLI   0(R15),C' '         NOW WE LOOK FOR A BLANK
         BE    BKLPARM3            BRANCH WHEN WE FIND ONE
         LA    R15,1(,R15)         INCREMENT POINTER
         BCT   R4,BKLPARM2         LOOP THROUGH THIS PARAMETER
*
BKLPARM3 DS    0H
         LR    R14,R15             COPY THE ENDING ADDRESS
         SR    R14,R3              CALCULATE THE LENGTH
*
         CH    R14,=H'44'          CHECK FOR MAXIMUM LENGTH
         BH    BKLREAD1            SKIP THE RECORD IF TOO BIG
*
         MVC   DSNHOLD,BLANKS      BLANK THE DATA SET NAME HOLDER
         BCTR  R14,0               DECREMENT FOR THE MVC
         EX    R14,BKLMVCP1        MOVE THE FIRST PARAMETER
*
         CLI   VERBTYPE,C'S'       IS THIS A SHELF VERB
         BNE   BKLHVDSN            IF NOT, WE HAVE
*
         CH    R14,=H'7'           CHECK IF THIS IS A VALID BKSNAME
         BH    BKLREAD1            SKIP IT IF NOT
*
         MVC   BKSHOLD,DSNHOLD     COPY THE SHELF NAME
         OC    BKSHOLD,BLANKS      UPPER CASE IT JUST IN CASE
*
         LTR   R4,R4               DO WE HAVE ANYTHING LEFT
         BZ    BKLREAD1            SKIP STATEMENT IF NOT
*
BKLPARM4 DS    0H
         CLI   0(R15),C' '         NOW LET'S FIND ANOTHER NON-BLANK
         BNE   BKLPARM5            BRANCH WHEN WE GET IT
         LA    R15,1(,R15)         INCREMENT POINTER
         BCT   R4,BKLPARM4         SCAN THROUGH THE STATEMENT
         B     BKLREAD1            SKIP STATEMENT IF NO PARMS
*
BKLPARM5 DS    0H
         LR    R3,R15              SAVE THIS PARM STARTING ADDRESS
*
BKLPARM6 DS    0H
         CLI   0(R15),C' '         NOW WE LOOK FOR A BLANK
         BE    BKLPARM7            BRANCH WHEN WE FIND ONE
         LA    R15,1(,R15)         INCREMENT POINTER
         BCT   R4,BKLPARM6         LOOP THROUGH THIS PARAMETER
*
BKLPARM7 DS    0H
         LR    R14,R15             COPY THE ENDING ADDRESS
         SR    R14,R3              CALCULATE THE LENGTH
*
         CH    R14,=H'44'          CHECK FOR MAXIMUM LENGTH
         BH    BKLREAD1            SKIP THE RECORD IF TOO BIG
*
         MVC   DSNHOLD,BLANKS      BLANK THE DATA SET NAME HOLDER
         BCTR  R14,0               DECREMENT FOR THE MVC
         EX    R14,BKLMVCP1        MOVE THE FIRST PARAMETER
*
BKLHVDSN DS    0H
         OC    DSNHOLD,BLANKS      UPPER CASE THE DATA SET NAME
*
         EJECT
***********************************************************************
*                                                                     *
*        FOR "XINCLUDE", WE FIND THE DATA SET NAME IN THE CURRENT     *
*        BOOKSHELF LIST DATA SET NAME LIST AND SPLAT IT OUT TO        *
*        CAUSE IT TO BE IGNORED.  NO ERROR IS NOTED IF THE            *
*        BOOKSHELF LIST DATA SET NAME IS NOT FOUND.                   *
*                                                                     *
***********************************************************************
*
         CLI   VERBTYPE,C'X'       IS THIS AN EXCLUDE FUNCTION
         BNE   BKLNOTEX            BRANCH IF NOT
*
         L     R15,0(,R2)          LOOK FORWARD ON THE BOOKSHELF LIST
BKLEXCLL LTR   R15,R15             DO WE HAVE ANY BOOKSHELF LISTS LEFT?
         BZ    BKLREAD1            IF NOT, SKIP FURTHER PROCESSING
*
         CLC   DSNHOLD,4(R15)      MATCH DSNAMES
         BE    BKLEXCLD            IF MATCH, GO EXCLUDE IT
         L     R15,0(,R15)         GET THE NEXT BOOKSHELF LIST ENTRY
         B     BKLEXCLL            AND TRY AGAIN
*
BKLEXCLD DS    0H
         MVI   4(R15),C'*'         EXCLUDE THIS DATA SET
         B     BKLREAD1            AND GET THE NEXT RECORD
*
***********************************************************************
*                                                                     *
*        FOR "INCLUDE", WE ADD THE DATA SET NAME TO THE BOOKSHELF     *
*        LIST DATA SET NAME LIST, PROVIDED IT ISN'T ALREADY THERE.    *
*                                                                     *
***********************************************************************
*
BKLNOTEX DS    0H
         CLI   VERBTYPE,C'I'       IS THIS AN INCLUDER
         BNE   BKLNOTIN            BRANCH IF NOT
*
         L     R3,BKLFIRST         POINT AT FIRST BOOKSHELF LIST
*
BKLINCLL DS    0H
         CLC   DSNHOLD,4(R3)       DO WE ALREAD HAVE THE BOOKSHELF LIST
         BE    BKLREAD1            IF SO, SKIP ADDING IT
*
         ICM   R15,15,0(R3)        CHAIN TO NEXT BOOKSHELF LIST
         BZ    BKLINCLA            IF AT THE END, GO ADD IT
         LR    R3,R15              COPY ADDRESS
         B     BKLINCLL            AND CHECK NEXT BOOKSHELF LIST
*
BKLINCLA DS    0H
         LA    R0,48               SIZE OF STORAGE
         LA    R1,BKLBLOCK         POINT AT CELL POOL BLOCK
         L     R15,CPSADDR         LOAD CELL POOL ROUTINE ADDRESS
         BASSM R14,R15             GET STORAGE BLOCK
         LR    R1,R15              COPY ADDRESS
         XC    0(4,R1),0(R1)       CLEAR THE CHAIN POINTER
         MVC   4(44,R1),DSNHOLD    COPY THE DATA SET NAME
*
         ST    R1,0(,R3)           ADD ON TO BOOKSHELF LIST CHAIN
*
         LA    R0,1                LOAD 1
         A     R0,BKLCOUNT         ADD OLD COUNT
         ST    R0,BKLCOUNT         STORE NEW COUNT
*
         B     BKLREAD1            AND GO READ NEXT RECORD
*
***********************************************************************
*                                                                     *
*        FOR "SHELF", WE ADD THE DATA SET NAME TO THE BOOKSHELF       *
*        DATA SET NAME LIST, PROVIDED IT ISN'T ALREADY THERE.         *
*                                                                     *
***********************************************************************
*
BKLNOTIN DS    0H                  IT MUST BE A BOOKSHELF DATA SET
         LA    R3,BKSFIRST         POINT AT BOOKSHELF DSNAME ANCHOR
*
BKLBKSLP DS    0H
         ICM   R15,15,0(R3)        GET NEXT BOOKSHELF DSNAME
         BZ    BKLBKSND            IF ZERO, WE ARE AT THE END
*
         CLC   DSNHOLD,4(R15)      MATCH THE BOOKSHELF DSNAMES
         BE    BKLREAD1            IF WE ALREADY HAVE IT, SKIP IT
*
         LR    R3,R15              COPY THE ADDRESS FOR CHAINING
         B     BKLBKSLP            AND GO CHECK THE NEXT ONE
*
BKLBKSND DS    0H
         LA    R0,56               SIZE OF STORAGE
         LA    R1,BKSBLOCK         POINT AT CELL POOL BLOCK
         L     R15,CPSADDR         LOAD CELL POOL ROUTINE ADDRESS
         BASSM R14,R15             GET STORAGE BLOCK
         LR    R1,R15              COPY ADDRESS
         XC    0(4,R1),0(R1)       CLEAR THE CHAIN POINTER
         MVC   4(44,R1),DSNHOLD    COPY THE DATA SET NAME
         MVC   48(8,R1),BKSHOLD    COPY THE BOOKSHELF NAME
*
         ST    R1,0(,R3)           ADD ON TO BOOKSHELF LIST CHAIN
*
         LA    R0,1                LOAD 1
         A     R0,BKSCOUNT         ADD OLD COUNT
         ST    R0,BKSCOUNT         STORE NEW COUNT
*
         B     BKLREAD1            AND GO READ NEXT RECORD
*
BKLMVCP1 MVC   DSNHOLD(*-*),0(R3)  *** EXECUTE ONLY ***
BKLOCVRB OC    0(*-*,R3),BLANKS    *** EXECUTE ONLY ***
*
         EJECT
***********************************************************************
*                                                                     *
*        END OF DATA FOR A BOOKSHELF LIST DATA SET                    *
*                                                                     *
***********************************************************************
*
BKLEOD   DS    0H
         CLOSE (BKLSHELF,FREE)     CLOSE AND FREE THIS BOOKSHELF LIST
         FREEPOOL BKLSHELF         FREE THE BUFFER POOL
*
BKLNEXT  DS    0H
         ICM   R2,15,0(R2)         CHAIN TO THE NEXT BOOKSHELF LIST
         BNZ   BKLLOOP1            LOOP IF WE AREN'T DONE
*
BKLISTND DS    0H
*
         EJECT
***********************************************************************
*                                                                     *
*        OPEN THE OUTPUT INFORMATION DATA SET                         *
*                                                                     *
***********************************************************************
*
         OPEN  (INFOFILE,(OUTPUT)) OPEN THE OUTPUT FILE
         LTR   R15,R15             TEST FOR ANY OPEN ERRORS
         BNZ   INFOPENE            BAD IF ANY ERRORS
*
***********************************************************************
*                                                                     *
*        SCAN EACH BOOKSHELF DATA SET TO EXTRACT THE DETAILED         *
*        BOOK, BOOKSHELF, AND BOOKSHELF INDEX INFORMATION.            *
*                                                                     *
***********************************************************************
*
         L     R2,BKSFIRST         POINT AT FIRST BOOKSHELF DATA SET
*
BKSLOOP1 DS    0H
         MVC   BKSID,ALLSTARS      INITIAL ALL
         MVC   BKINAME,ALLSTARS     OF THE
         MVC   BKSTITLL,=H'8'        VARIOUS
         MVC   BKSTITLE(8),ALLSTARS   DATA
         MVC   BKSBDATE,STARDATE       FIELDS
         MVC   BKSBTIME,STARTIME        THAT WE
         MVC   BKIBDATE,STARDATE         COLLECT
         MVC   BKIBTIME,STARTIME          FOR EVERY
         MVC   BKIDSN,ALLSTARS             BOOKSHELF
         MVC   BKSDSN,ALLSTARS              *
         MVC   BKSLNAME,ALLSTARS             *
*
         TM    PROCFLAG,PROCINFO   ARE WE IN INFORMATION MODE
         BO    BKSINFO1            IF SO, GO DO THE MEMBER THING
*
         MVC   BKSDSN,4(R2)        SAVE THE BOOKSHELF DSNAME
         MVC   BKSLNAME,48(R2)     SAVE THE BOOKSHELF LIST SHELF NAME
*
         LA    R15,BKSDSN+36       POINT AT LAST POSSSIBLE ".BKSHELF"
         LA    R0,37               MAXIMUM LENGTH TO SCAN
*
BKSSCAN1 DS    0H
         CLC   0(8,R15),=C'.BKSHELF'    FIND END OF DATA SET NAME
         BE    BKSSHLF1            BRANCH IF FOUND
         BCTR  R15,0               SET BACKWARDS IN THE DATA SET NAME
         BCT   R0,BKSSCAN1         SCAN THE DATA SET NAME
         B     BKSNEXT             IF THIS ISN'T A BOOKSHELF, SKIP IT
*
BKSSHLF1 DS    0H
         LR    R14,R15             SAVE THIS POSITION
BKSSHLF2 DS    0H
         BCTR  R15,0               BACK UP ONE MORE
         CLI   0(R15),C'.'         LOOK FOR PREVIOUS PERIOD
         BE    BKSSHLF3            BRANCH WHEN FOUND
         BCT   R0,BKSSHLF2         BACKTRACK THROUGH THE DATA SET NAME
         B     BKSNEXT             IF WE RUN OUT, CONSIDER IT INVALID
*
BKSSHLF3 DS    0H
         CLC   0(4,R15),=C'.LVL'   DETERMINE IF THIS IS JUST THE
         BNE   BKSSHLFN            LVL** QUALIFIER
         TM    4(R15),X'F0'        CHECK FOR NUMERIC
         BNO   BKSSHLFN            IF NOT, NOT LVL**
         TM    5(R15),X'F0'        CHECK FOR NUMERIC
         BNO   BKSSHLFN            IF NOT, NOT LVL**
         CLI   6(R15),C'.'         CHECK FOR EXACTLY 2 PLACES AFTER LVL
         BNE   BKSSHLFN            IF NOT, NOT LVL**
*
         B     BKSSHLF1            LET'S GO BACK ONE MORE QUALIFIER
*
BKSSHLFN DS    0H
         SR    R14,R15             CALCULATE LENGTH OF BOOKSHELF NAME
         BCTR  R14,0               SUBTRACT 1 TO GET TRUE LENGTH
         BCTR  R14,0               SUBTRACT 1 MORE FOR MVS INSTRUCTION
*
         MVC   BKSNAME,BLANKS      PRE BLANK THE FIELD
         EX    R14,BKSMVCID        MOVE THE BOOKSHELF NAME FROM DSN
*
         LA    R1,4(,R2)           POINT AT DATA SET NAME
         BAL   R8,ALLOCDSN         ALLOCATE THE BOOKSHELF
*
         LTR   R1,R1               DO WE HAVE A DDNAME RETURNED
         BZ    BKSALOCE            IF NOT, WE CAN'T ALLOCATE - IS BAD
*
         MVC   DCBDDNAM-IHADCB+BKSHELF,0(R1) COPY THE DDNAME
*
         OPEN  (BKSHELF,(INPUT))   OPEN THE BOOKSHELF DATA SET
         LTR   R15,R15             TEST FOR ANY OPEN ERRORS
         BNZ   BKSOPENE            BAD IF ANY ERRORS
*
         B     BKSREAD1            GO PROCESS THIS BOOKSHELF DATA SET
*
BKSMVCID MVC   BKSNAME(*-*),1(R15) *** EXECUTE ONLY ***
*
         EJECT
***********************************************************************
*                                                                     *
*        OPEN THE BOOKSHELF DATA SET TO THE CURRENT MEMBER NAME       *
*                                                                     *
***********************************************************************
*
BKSINFO1 DS    0H
         MVC   JFCBELNM-JFCB+BKSJFCB,4(R2) COPY THE MEMBER NAME
*
         MVC   BKSNAME,4(R2)       SET THE CURRENT BOOKSHELF NAME
*
         OPEN  (BKSHELF,(INPUT)),TYPE=J OPEN THE SPECIFIC PDS MEMBER
         LTR   R15,R15             TEST FOR ANY OPEN ERRORS
         BNZ   BKSOPENE            BAD IF ANY ERRORS
*
         B     BKSREAD1            AND GO SCAN THIS MEMBER
*
         EJECT
***********************************************************************
*                                                                     *
*        MAIN READ LOOP FOR SCANNING ONE BOOKSHELF DATA SET           *
*                                                                     *
***********************************************************************
*
BKSREAD1 DS    0H
         BAL   R8,BKSBKSRD         READ ONE BOOKSHELF LIST RECORD
         LTR   R1,R1               DID WE HIT END OF DATA
         BZ    BKSISBAD            THIS IS AN INVALID BOOKSHELF
*
         LR    R3,R1               SAVE THE RECORD ADDRESS
         LR    R4,R0               SAVE THE RECORD LENGTH
*
         CLC   0(2,R1),=C'SH'      CHECK FOR FIRST BOOK HEADER
         BE    BKSHDEND            IF SO, WE ARE DONE COLLECTING HEADER
*
***********************************************************************
*                                                                     *
*        COLLECT BOOKSHELF HEADER INFORMATION                         *
*                                                                     *
***********************************************************************
*
         BAL   R8,BKSEQUAL         SCAN FOR AN EQUAL SIGN
         LTR   R15,R15             DID WE FIND ONE
         BZ    BKSREAD1            SKIP THIS RECORD IF NOT FOUND
*
         LR    R14,R15             COPY THE EQUAL SIGN ADDRESS
         SR    R14,R1              CALCULATE LENGTH OF KEYWORD
*
         CH    R14,=H'7'           CHECK LENGTH
         BNE   BKSNBKSH            BRANCH IF IT CAN'T BE
         CLC   0(7,R1),=C'BKSHELF' IS THIS BKSHELF=
         BNE   BKSNBKSH            BRANCH IF IT ISN'T
*
         MVC   BKSID,BLANKS        BLANK IT OUT
         SH    R0,=H'9'            CALCULATE LENGTH FOR MVC
         LR    R14,R0              MOVE FOR USE BY EXECUTE
         EX    R14,BKSMVCNM        MOVE THE BOOKSHELF NAME
*
         B     BKSREAD1            GO GET THE NEXT RECORD
*
BKSMVCNM MVC   BKSID(*-*),1(R15) *** EXECUTE ONLY ***
*
BKSNBKSH DS    0H
         CH    R14,=H'8'           CHECK LENGTH
         BNE   BKSNBKST            BRANCH IF IT CAN'T BE
         CLC   0(8,R1),=C'BKSTITLE'     IS THIS BKSTITLE=
         BNE   BKSNBKST            BRANCH IF IT ISN'T
*
         SH    R0,=H'9'            CALCULATE LENGTH OF TITLE
         BNP   BKSREAD1            SKIP THIS IF TITLE IS NULL
*
BKSTITBL DS    0H
         CLI   1(R15),C' '         DO WE HAVE A LEADING BLANK
         BNE   BKSTITNB            BRANCH IF NOT
         LA    R15,1(,R15)         INCREMENT PAST ANY LEADING BLANKS
         BCT   R0,BKSTITBL         LOOP THROUGH LEADING BLANKS
         B     BKSREAD1            TITLE IS ALL BLANKS
*
BKSTITNB DS    0H
         LR    R14,R0              MOVE FOR USE BY EXECUTE
         CH    R14,=Y(L'BKSTITLE)  CHECK FOR MAXIMUM LENGTH
         BNH   *+10                BRANCH IF WITHIN SPEC
         LA    R14,L'BKSTITLE      LOAD THE MAXIMUM LENGTH
         LR    R0,R14              COPY THIS LENGTH
*
         BCTR  R14,0               DECREMENT FOR USE BY MVC
         EX    R14,BKSMVCBT        MOVE THE BOOKSHELF TITLE
         STH   R0,BKSTITLL         STORE THE TITLE LENGTH
*
         B     BKSREAD1            GO GET THE NEXT RECORD
*
BKSMVCBT MVC   BKSTITLE(*-*),1(R15)     *** EXECUTE ONLY ***
*
BKSNBKST DS    0H
         CH    R14,=H'8'           CHECK LENGTH
         BNE   BKSNBKIN            BRANCH IF IT CAN'T BE
         CLC   0(8,R1),=C'BKSINDEX'     IS THIS BKSINDEX=
         BNE   BKSNBKIN            BRANCH IF IT ISN'T
*
         MVC   BKINAME,BLANKS      BLANK IT OUT
         SH    R0,=H'10'           CALCULATE LENGTH FOR MVC
         BL    BKSREAD1            IF IT GOES NEGATIVE, THERE IS NONE
         LR    R14,R0              MOVE FOR USE BY EXECUTE
         EX    R14,BKSMVCIN        MOVE THE BOOKSHELF INDEX NAME
*
         B     BKSREAD1            GO GET THE NEXT RECORD
*
BKSMVCIN MVC   BKINAME(*-*),1(R15) *** EXECUTE ONLY ***
*
BKSNBKIN DS    0H
         CH    R14,=H'8'           CHECK LENGTH
         BNE   BKSNBKDI            BRANCH IF IT CAN'T BE
         CLC   0(8,R1),=C'BKSIMDSN'     IS THIS BKSIMDSN=
         BNE   BKSNBKDI            BRANCH IF IT ISN'T
*
         MVC   BKIDSN,BLANKS       BLANK IT OUT
         SH    R0,=H'10'           CALCULATE LENGTH FOR MVC
         LR    R14,R0              MOVE FOR USE BY EXECUTE
         EX    R14,BKSMVCDI        MOVE THE BOOKSHELF INDEX DSNAME
*
         B     BKSREAD1            GO GET THE NEXT RECORD
*
BKSMVCDI MVC   BKIDSN(*-*),1(R15)  *** EXECUTE ONLY ***
*
BKSNBKDI DS    0H
         CH    R14,=H'11'          CHECK LENGTH
         BNE   BKSNBKSD            BRANCH IF IT CAN'T BE
         CLC   0(11,R1),=C'BKSDATETIME'  IS THIS BKSDATETIME=
         BNE   BKSNBKSD            BRANCH IF IT ISN'T
*
         LA    R14,0(R3,R4)        ADD REC ADDR & LENGTH
         LA    R1,BKSBDATE         POINT AT DATE FIELD
         LA    R0,BKSBTIME         POINT AT TIME FIELD
         BAL   R8,BKSMVDTE         GO CONVERT THE DATE AND TIME
*
         B     BKSREAD1            GO GET THE NEXT RECORD
*
BKSNBKSD DS    0H
         CH    R14,=H'11'          CHECK LENGTH
         BNE   BKSNBKID            BRANCH IF IT CAN'T BE
         CLC   0(11,R1),=C'BKIDATETIME'  IS THIS BKIDATETIME=
         BNE   BKSNBKID            BRANCH IF IT ISN'T
*
         LA    R14,0(R3,R4)        ADD REC ADDR & LENGTH
         LA    R1,BKIBDATE         POINT AT DATE FIELD
         LA    R0,BKIBTIME         POINT AT TIME FIELD
         BAL   R8,BKSMVDTE         GO CONVERT THE DATE AND TIME
*
         B     BKSREAD1            GO GET THE NEXT RECORD
*
BKSNBKID DS    0H
         B     BKSREAD1            GO GET THE NEXT RECORD
*
         EJECT
***********************************************************************
*                                                                     *
*        THE FIRST BOOK HEADER RECORD (SH) HAS BEEN READ, SO          *
*        CONSTRUCT THE RECORDS FOR THE BOOKSHELF AND INDEX.           *
*                                                                     *
***********************************************************************
*
BKSHDEND DS    0H
         CLI   BKSDSN,C'*'         DO WE HAVE A DATA SET NAME
         BH    BKSHHDSN            BRANCH IF WE DO
*
         MVC   DSNNAME,BKSNAME     BOOKSHELF NAME (GENERIC)
         MVC   DSNTYPE,=CL8'BKSHELF'
         LA    R1,DSNPARMS         POINT AT THE PARM LIST
         L     R15,DSNADDR         LOAD THE SUBROUTINE ADDRESS
         BASSM R14,R15             GO CONVERT THE DATA SET NAME
*
         LTR   R15,R15             TEST FOR SUCCESSFUL CONVERSION
         BNZ   BADDSN              BRANCH IF NO GOOD
*
         MVC   BKSDSN,DSNDSN       COPY RETURNED DATA SET NAME
*
BKSHHDSN DS    0H
         LA    R1,BKSDSN           POINT AT BOOKSHELF DATA SET NAME
         BAL   R8,INFOSTAT         GO DETERMINE THE BOOKSHELF DS STATUS
*
         BAL   R8,INFOINIT         INITIALIZE THE ACTIVE RECORD
*
         USING BKNDSECT,INFOWORK   ESTABLISH EXTRACT AREA MAPPING
*
         MVC   BKNNAME,BKSNAME     COPY THE GENERIC BOOKSHELF NAME
         MVC   BKNTYPE,=CL8'BKSHELF'    SET THAT THIS IS A BOOKSHELF
*
         MVC   BKNBKDTE,BKSBDATE   COPY THE BOOKSHELF BUILD DATE
         MVC   BKNBKTIM,BKSBTIME   COPY THE BOOKSHELF BUILD TIME
*
         MVC   BKNSTAT,0(R1)       COPY STATUS RETURNED EARLIER
*
         MVC   BKNBKSID,BKSID      COPY THE BOOKSHELF NAME (ESOTERIC)
*
         TM    PROCFLAG,PROCINFO   ARE WE IN INFORMATION MODE
         BO    BKSHNMIS            IF SO, DON'T SCREW WITH THE STATUS
*
         CLC   BKSID,BKSLNAME      CHECK THE INTERNAL TO EXTERNAL NAME
         BE    BKSHNMIS            BRANCH IF IT MATCHES
         MVC   BKNSTAT,=C'MISMATCH'     INDICATE A NAME MISMATCH
BKSHNMIS DS    0H
*
         MVC   BKNDSNME,BKSDSN     COPY THE BOOKSHELF DATA SET NAME
*
         LA    R1,BKSTITLL         POINT AT BOOKSHELF TITLE
         BAL   R8,INFOTITL         GO COPY THE TITLE
*
         BAL   R8,INFOWRIT         WRITE OUT THE ACTIVE RECORD
*
         CLI   BKINAME,C' '        IS THE INDEX NAME NULL
         BNE   *+10                BRANCH IF NOT
         MVC   BKINAME,BKSNAME     COPY THE BOOKSHELF NAME IF NULL
*
         CLI   BKIDSN,C'*'         DO WE HAVE A DATA SET NAME
         BH    BKSIHDSN            BRANCH IF WE DO
*
         MVC   DSNNAME,BKINAME     BOOKSHELF INDEX NAME
         MVC   DSNTYPE,=CL8'BKINDEX'
         LA    R1,DSNPARMS         POINT AT THE PARM LIST
         L     R15,DSNADDR         LOAD THE SUBROUTINE ADDRESS
         BASSM R14,R15             GO CONVERT THE DATA SET NAME
*
         LTR   R15,R15             TEST FOR SUCCESSFUL CONVERSION
         BNZ   BADDSN              BRANCH IF NO GOOD
*
         MVC   BKIDSN,DSNDSN       COPY RETURNED DATA SET NAME
*
BKSIHDSN DS    0H
         LA    R1,BKIDSN           POINT AT BOOKSHELF INDEX DSN
         BAL   R8,INFOSTAT         GO DETERMINE THE BOOKSHELF INDEX ST
*
         BAL   R8,INFOINIT         INITIALIZE THE ACTIVE RECORD
*
         MVC   BKNNAME,BKINAME     COPY THE BOOKSHELF INDEX NAME
         MVC   BKNTYPE,=CL8'BKINDEX'    SET THAT THIS IS AN INDEX
*
         MVC   BKNBKDTE,BKIBDATE   COPY THE BOOKSHELF INDEX BUILD DATE
         MVC   BKNBKTIM,BKIBTIME   COPY THE BOOKSHELF INDEX BUILD TIME
*
         MVC   BKNSTAT,0(R1)       COPY STATUS RETURNED EARLIER
*
         MVC   BKNBKSID,BKSID      COPY THE BOOKSHELF NAME (ESOTERIC)
*
         MVC   BKNDSNME,BKIDSN     COPY THE BOOKSHELF INDEX DS NAME
*
         LA    R1,BKSTITLL         POINT AT BOOKSHELF TITLE
         BAL   R8,INFOTITL         GO COPY THE TITLE
*
         BAL   R8,INFOWRIT         WRITE OUT THE ACTIVE RECORD
*
         EJECT
***********************************************************************
*                                                                     *
*        NOW LOOP THROUGH THE VARIOUS BOOK INFORMATION RECORDS.       *
*        AN OUTPUT RECORD IS BUILT WHEN A NEW BOOK HEADER (OR         *
*        END OF DATA) IS ENCOUNTERED.                                 *
*                                                                     *
***********************************************************************
*
BKSBOOKI DS    0H
         MVC   BOOKSH,ALLSTARS     INITIALIZE ALL
         MVC   BOOKNAME,ALLSTARS    OF THE
         MVC   BOOKTTLL,=H'8'        VARIOUS
         MVC   BOOKTITL(8),ALLSTARS   DATA
         MVC   BOOKDATE,STARDATE       FIELDS
         MVC   BOOKTIME,STARTIME        THAT A
         MVC   BOOKDSN,ALLSTARS          BOOK HAS
*
BKSBOOKL DS    0H
         CLC   0(2,R3),=C'SH'      IS THIS THE BOOK HEADER (PUB NUMBER)
         BNE   BKSBNSH             BRANCH IF NOT
*
         LR    R15,R4              COPY THE LENGTH
         SH    R15,=H'3'           SUBTRACT THE HEADER LENGTH AND 1
         CH    R15,=Y(L'PUBNOIN-1) CHECK FOR MAXIMUM LENGTH VIOLATION
         BNH   *+8                 BRANCH IF NOT
         LA    R15,L'PUBNOIN-1     SET MAXIMUM MOVE LENGTH
         MVC   PUBNOIN,BLANKS      BLANK OUT THE PUB NUMBER FIELD
         EX    R15,BKSPUBNO        COPY THE PUBLICATION NUMBER
*
         LA    R1,PUBNOPRM         POINT AT PARAMETER LIST
         L     R15,PUBNOADR        LOAD SUBROUTINE ADDRESS
         BASSM R14,R15             GO CONVERT THE PUB NUMBER
*
         MVC   BOOKSH,PUBNOOUT     COPY THE (REFORMATED) PUBLICATION NO
         B     BKSBOOKN            AND GO GET THE NEXT RECORD
*
BKSPUBNO MVC   PUBNOIN(*-*),2(R3)  *** EXECUTE ONLY ***
*
BKSBNSH  DS    0H
         CLC   0(2,R3),=C'ST'      IS THIS THE BOOK TITLE
         BNE   BKSBNST             BRANCH IF NOT
*
         XC    BOOKTTLL,BOOKTTLL   ZERO THE TITLE LENGTH (NULL TITLE)
*
         LA    R1,2(,R3)           POINT TO POSSIBLE TITLE BEGINNING
         LR    R14,R4              COPY THE LENGTH
         SH    R14,=H'2'           ADJUST FOR THE ST
         BNP   BKSBOOKN            IF NO TITLE, GO GET NEXT RECORD
*
BKSBTITL DS    0H
         CLI   0(R1),C' '          SCAN FOR FIRST NON BLANK IN TITLE
         BNE   BKSBTITB            BRANCH WHEN FOUND
         LA    R1,1(,R1)           INCREMENT TO NEXT TITLE CHARACTER
         BCT   R14,BKSBTITL        LOOP THROUGH THE TITLE HEADER
         B     BKSBOOKN            NULL TITLE
*
BKSBTITB DS    0H
         CH    R14,=Y(L'BOOKTITL)  CHECK FOR MAXIMUM LENGTH
         BNH   *+8                 BRANCH IF WITHIN SPEC
         LA    R14,L'BOOKTITL      LOAD THE MAXIMUM LENGTH
*
         STH   R14,BOOKTTLL        STORE THE TITLE LENGTH
         BCTR  R14,0               DECREMENT FOR MVC
         EX    R14,BKSBTITM        MOVE THE TITLE TO SAVE IT
         B     BKSBOOKN            AND GO GET THE NEXT RECORD
*
BKSBTITM MVC   BOOKTITL(*-*),0(R1) *** EXECUTE ONLY ***
*
BKSBNST  DS    0H
         BAL   R8,BKSEQUAL         SCAN FOR AN EQUAL SIGN
         LTR   R15,R15             DID WE FIND ONE
         BZ    BKSBOOKN            SKIP THIS RECORD IF NOT FOUND
*
         LR    R14,R15             COPY THE EQUAL SIGN ADDRESS
         SR    R14,R1              CALCULATE LENGTH OF KEYWORD
*
         CH    R14,=H'6'           CHECK LENGTH
         BNE   BKSBNBOO            BRANCH IF IT CAN'T BE
         CLC   0(6,R1),=C'BKNAME'  IS THIS BKNAME=
         BNE   BKSBNBOO            BRANCH IF IT ISN'T
*
         MVC   BOOKNAME,BLANKS     BLANK IT OUT
         SH    R0,=H'8'            CALCULATE LENGTH FOR MVC
         LR    R14,R0              MOVE FOR USE BY EXECUTE
         EX    R14,BKSMVCBO        MOVE THE BOOK NAME
*
         B     BKSBOOKN            GO GET THE NEXT RECORD
*
BKSMVCBO MVC   BOOKNAME(*-*),1(R15)     *** EXECUTE ONLY ***
*
BKSBNBOO DS    0H
         CH    R14,=H'6'           CHECK LENGTH
         BNE   BKSBNDSN            BRANCH IF IT CAN'T BE
         CLC   0(6,R1),=C'BKMDSN'  IS THIS BKMDSN=
         BNE   BKSBNDSN            BRANCH IF IT ISN'T
*
         MVC   BOOKDSN,BLANKS      BLANK IT OUT
         SH    R0,=H'8'            CALCULATE LENGTH FOR MVC
         LR    R14,R0              MOVE FOR USE BY EXECUTE
         EX    R14,BKSMVCBD        MOVE THE BOOK NAME
*
         B     BKSBOOKN            GO GET THE NEXT RECORD
*
BKSMVCBD MVC   BOOKDSN(*-*),1(R15) *** EXECUTE ONLY ***
*
BKSBNDSN DS    0H
         CH    R14,=H'10'          CHECK LENGTH
         BNE   BKSBNDTT            BRANCH IF IT CAN'T BE
         CLC   0(10,R1),=C'BKDATETIME'  IS THIS BKDATETIME=
         BNE   BKSBNDTT            BRANCH IF IT ISN'T
*
         LA    R14,0(R3,R4)        ADD REC ADDR & LENGTH
         LA    R1,BOOKDATE         POINT AT DATE FIELD
         LA    R0,BOOKTIME         POINT AT TIME FIELD
         BAL   R8,BKSMVDTE         GO CONVERT THE DATE AND TIME
*
         B     BKSBOOKN            GO GET THE NEXT RECORD
*
BKSBNDTT DS    0H
*
         EJECT
***********************************************************************
*                                                                     *
*        READ THE NEXT BOOK SPECIFIC RECORD AND BUILD AN OUTPUT       *
*        RECORD IF THE NEXT BOOK HEADER OR END OF DATA IS REACHED.    *
*                                                                     *
***********************************************************************
*
BKSBOOKN DS    0H
         BAL   R8,BKSBKSRD         READ ONE BOOKSHELF LIST RECORD
         LTR   R3,R1               DID WE HIT END OF DATA
         LR    R4,R0               COPY THE LENGTH
         BZ    BKSBOOKB            IF SO, GO BUILD THE LAST RECORD
*
         CLC   0(2,R1),=C'SH'      CHECK FOR FIRST BOOK HEADER
         BNE   BKSBOOKL            IF NOT, CONTINUE COLLECTION
*
BKSBOOKB DS    0H
         CLI   BOOKDSN,C'*'        DO WE HAVE A DATA SET NAME
         BH    BKSBHDSN            BRANCH IF WE DO
*
         MVC   DSNNAME,BOOKNAME    BOOK NAME
         MVC   DSNTYPE,=CL8'BOOK'
         LA    R1,DSNPARMS         POINT AT THE PARM LIST
         L     R15,DSNADDR         LOAD THE SUBROUTINE ADDRESS
         BASSM R14,R15             GO CONVERT THE DATA SET NAME
*
         LTR   R15,R15             TEST FOR SUCCESSFUL CONVERSION
         BNZ   BADDSN              BRANCH IF NO GOOD
*
         MVC   BOOKDSN,DSNDSN      COPY RETURNED DATA SET NAME
*
BKSBHDSN DS    0H
         LA    R1,BOOKDSN          POINT AT BOOK DATA SET NAME
         BAL   R8,INFOSTAT         GO DETERMINE THE BOOK DATA SET STAT
*
         BAL   R8,INFOINIT         INITIALIZE THE ACTIVE RECORD
*
         MVC   BKNNAME,BOOKNAME    COPY THE GENERIC BOOK NAME
         MVC   BKNTYPE,=CL8'BOOK'  SET THAT THIS IS A BOOK
*
         MVC   BKNBKDTE,BOOKDATE   COPY THE BOOK BUILD DATE
         MVC   BKNBKTIM,BOOKTIME   COPY THE BOOK BUILD TIME
*
         MVC   BKNSTAT,0(R1)       COPY STATUS RETURNED EARLIER
*
         MVC   BKNPUBNO,BOOKSH     COPY THE PUBLICATION NUMBER
*
         MVC   BKNBKSID,BKSID      COPY THE BOOKSHELF NAME (ESOTERIC)
*
         MVC   BKNDSNME,BOOKDSN    COPY THE BOOK DATA SET NAME
*
         LA    R1,BKNDSNME         POINT AT BOOK DATA SET NAME
         BAL   R8,GETUSMLV         DETERMINE IF THIS BOOK IS A USM BOOK
         LTR   R1,R1               TEST IF IT IS
         BZ    BKSNUSMB            BRANCH IF NOT
*
         MVC   BKNPUBNO+10(2),0(R1)     COPY THE RETURNED USM LEVEL
*
BKSNUSMB DS    0H
*
         LA    R1,BOOKTTLL         POINT AT BOOK TITLE
         BAL   R8,INFOTITL         GO COPY THE TITLE
*
         BAL   R8,INFOWRIT         WRITE OUT THE ACTIVE RECORD
*
         LTR   R3,R3               DID WE REACH END OF DATA
         BNZ   BKSBOOKI            GO INITIALIZE A NEW BOOK
*
         EJECT
***********************************************************************
*                                                                     *
*        END OF BOOKSHELF DATA SET                                    *
*                                                                     *
***********************************************************************
*
         TM    PROCFLAG,PROCINFO   ARE WE IN INFORMATION MODE
         BO    BKSNEXTI            BRANCH IF SO
*
         CLOSE (BKSHELF,FREE)      CLOSE AND FREE THIS BOOKSHELF
         FREEPOOL BKSHELF          FREE THE BUFFER POOL
*
BKSNEXT  DS    0H
*        LR    R1,R2               COPY THE BOOKSHELF DATA SET FOR FREE
         L     R2,0(,R2)           CHAIN TO THE NEXT BOOKSHELF DATA SET
         LTR   R2,R2               DO WE HAVE ANOTHER BOOKSHELF DATASET
         BNZ   BKSLOOP1            LOOP IF WE AREN'T DONE
*
         SLR   R0,R0               INDICATE FREE
         LA    R1,BKSBLOCK         POINT AT CELL POOL BLOCK
         L     R15,CPSADDR         LOAD CELL POOL ROUTINE ADDRESS
         BASSM R14,R15             GET STORAGE BLOCK
         ST    R0,BKSFIRST         ZERO FOR POSTERITY
*
         B     ALLDONE             AND WE ARE THROUGH
*
BKSNEXTI DS    0H
         L     R2,0(,R2)           CHAIN TO THE NEXT MEMBER
         LTR   R2,R2               DO WE HAVE ANOTHER MEMBER
         BZ    BKSINFOZ            BRANCH IF NOT
*
         CLOSE (BKSHELF)           CLOSE THE CURRENT MEMBER INPUT
*
         B     BKSLOOP1            AND GO PROCESS THE NEXT MEMBER
*
BKSINFOZ DS    0H
         CLOSE (BKSHELF,FREE)      CLOSE AND FREE THE DATA SET
         FREEPOOL BKSHELF          FREE THE BUFFER POOL
*
         SLR   R0,R0               INDICATE FREE
         LA    R1,MEMBLOCK         POINT AT CELL POOL BLOCK
         L     R15,CPSADDR         LOAD CELL POOL ROUTINE ADDRESS
         BASSM R14,R15             GET STORAGE BLOCK
         ST    R0,BKSFIRST         ZERO FOR POSTERITY
*
         B     ALLDONE             AND WE ARE THROUGH
*
         EJECT
***********************************************************************
*                                                                     *
*        CLOSE THE OUTPUT INFORMATION FILE                            *
*                                                                     *
***********************************************************************
*
ALLDONE  DS    0H
         CLOSE (INFOFILE)          CLOSE THE OUTPUT FILE
         FREEPOOL INFOFILE         FREE THE BUFFER POOL
*
***********************************************************************
*                                                                     *
*        FREE THE BOOKSHELF LIST DATA SET NAME LIST                   *
*                                                                     *
***********************************************************************
*
         SLR   R0,R0               INDOCATE FREE
         LA    R1,BKLBLOCK         POINT AT CELL POOL BLOCK
         L     R15,CPSADDR         LOAD CELL POOL ROUTINE ADDRESS
         BASSM R14,R15             GET STORAGE BLOCK
         ST    R0,BKLFIRST         ZERO FOR POSTERITY
*
***********************************************************************
*                                                                     *
*        DELETE ALL THE SUBROUTINES                                   *
*                                                                     *
***********************************************************************
*
         DELETE EPLOC=CPSNAME      DELETE THE CELL POOL SUBROUTINE
*
         DELETE EPLOC=PUBNONAM     DELETE THE PUB NUMBER SUBROUTINE
*
         DELETE EPLOC=DSNSUB       DELETE THE DATA SET NAME SUBROUTINE
*
         DELETE EPLOC=DATTBL       DELETE THE DATA TABLE
*
         DELETE EPLOC=DEFSUB       DELETE THE DEFINITION ROUTINE
*
***********************************************************************
*                                                                     *
*        RETURN TO CALLER                                             *
*                                                                     *
***********************************************************************
*
         L     R13,4(,R13)         UNCHAIN THE SAVE AREA
         LM    R14,R12,12(R13)     RELOAD THE REGISTERS
         SLR   R15,R15             SET THE RETURN CODE
         BR    R14                 RETURN TO CALLER
*
         EJECT
***********************************************************************
*                                                                     *
*        DYNAMIC ALLOCATION SUBROUTINE                                *
*                                                                     *
*        ON ENTRY, REGISTER 1 POINTS TO THE 44 CHARACTER DATA         *
*        SET NAME.  THE DATA SET MUST EXIST.                          *
*                                                                     *
*        ON EXIT, R1 POINTS TO THE DDNAME IF THE ALLOCATION IS        *
*        SUCCESSFUL.  OTHERWISE, R1 WILL BE ZERO.                     *
*                                                                     *
***********************************************************************
*
ALLOCDSN DS    0H
         MVC   DYNDSN,0(R1)        COPY THE DATA SET NAME
*
         LA    R1,DYNPTR           POINT AT DYNAMIC ALLOC PARM LIST
         DYNALLOC ,                ISSUE THE DYNAMIC ALLOCATION
*
         SLR   R1,R1               INDICATE ALLOCATION FAILURE
         LTR   R15,R15             DID WE HAVE ANY ERROR
         BNZR  R8                  RETURN IF ANY ERROR
*
         LA    R0,1                LOAD 1
         A     R0,DYNCOUNT         ADD OLD COUNT
         ST    R0,DYNCOUNT         STORE NEW COUNT
*
         LA    R1,DYNDDNAM         POINT AT RETURN DDNAME
         BR    R8                  RETURN TO CALLER
*
         EJECT
***********************************************************************
*                                                                     *
*        SUBROUTINE TO READ THE NEXT VALID RECORD IN A                *
*        BOOKSHELF DATA SET.                                          *
*                                                                     *
*        ON RETURN, REGISTER 1 POINTS TO THE FIRST DATA BYTE          *
*        AFTER THE RDW AND REGISTER 0 CONTAINS THE LENGTH.            *
*                                                                     *
*        AT END OF DATA, BOTH REG 1 AND REG 0 WILL BE ZERO.           *
*                                                                     *
***********************************************************************
*
BKSBKSRD DS    0H
         GET   BKSHELF             READ ONE BOOKSHELF LIST RECORD
         LA    R0,1                LOAD 1
         A     R0,BOOKCNT          ADD PREVIOUS RECORD COUNT
         ST    R0,BOOKCNT          STORE UPDATED COUNT
*
         LH    R0,0(,R1)           LOAD THE RECORD LENGTH
         SH    R0,=H'4'            ELIMINATE THE RDW
         BZ    BKSBKSRD            SKIP A NULL RECORD
         LA    R1,4(,R1)           COPY THE RECORD ADDRESS
*
         LR    R15,R0              COPY THE LENGTH
         AR    R15,R1              POINT PAST THE RECORD
*
BKSBLOOP DS    0H
         BCTR  R15,0               DECREMENT TO PREVIOUS CHARACTER
         CLI   0(R15),C' '         SCAN FOR TRAILING BLANKS
         BNE   BKSBLNOT            BRANCH WHEN NON BLANK FOUND
         BCT   R0,BKSBLOOP         LOOP THROUGH TRAILING BLANKS
         B     BKSBKSRD            SKIP A TOTALLY BLANK RECORD
*
BKSBLNOT DS    0H
         CLI   0(R1),C' '          NOW CHECK FOR A LEADING BLANK
         BNE   BKSBLEAD            BRANCH IF NOT A LEADING BLANK
         LA    R1,1(,R1)           INCREMENT PAST THE LEADING BLANK
         BCT   R0,BKSBLNOT         LOOP THROUGH LEADING BLANKS
*
BKSBLEAD DS    0H
         CLI   0(R1),C'*'          CHECK FOR A COMMENT STATEMENT
         BE    BKSBKSRD            SKIP IT IF SO
*
         BR    R8                  RETURN TO CALLER
*
BKSEOD   DS    0H
         SLR   R1,R1               INDICATE END OF DATA
         SLR   R0,R0
         BR    R8
*
         EJECT
***********************************************************************
*                                                                     *
*        SCAN FOR AN EQUAL SIGN                                       *
*                                                                     *
*        THE STRING POINTED TO BY REGISTER 1 WITH LENGTH IN           *
*        REGISTER 0 IS SCANNED FOR AN EQUAL SIGN.  THE ADDRESS        *
*        OF THE EQUAL SIGN IS RETURNED IN REGISTER 15.  IF NO         *
*        EQUAL SIGN IS FOUND, REGISTER 15 WILL BE ZERO.               *
*                                                                     *
***********************************************************************
*
BKSEQUAL DS    0H
         LR    R15,R1              COPY THE STARTING ADDRESS
         LR    R14,R0              COPY THE LENGTH
*
BKSEQSCN CLI   0(R15),C'='         LOOK FOR AN EQUAL SIGN
         BER   R8                  RETURN IF EQUAL SIGN FOUND
*
         LA    R15,1(,R15)         INCREMENT TO NEXT CHARACTER
         BCT   R14,BKSEQSCN        SCAN THE STRING
*
         SLR   R15,R15             INDICATE NO EQUAL SIGN
         BR    R8                  RETURN TO CALLER
*
***********************************************************************
*                                                                     *
*        EXTRACT AND REFORMAT THE BOOKSHELF DATE/TIME FIELD           *
*                                                                     *
*        REGISTER 1 POINTS TO THE 10 BYTE TARGET FOR THE DATE.        *
*        REGISTER 0 POINTS TO THE 8 BYTE TARGET FOR THE TIME.         *
*        REGISTER 15 POINTS TO 1 BYTE IN FRONT OF THE BOOKMANAGER     *
*        DATE/TIME FIELD.  REGISTER 14 POINT AT THE BYTE              *
*        FOLLOWING THE DATE/TIME FIELD.                               *
*                                                                     *
*                                                                     *
***********************************************************************
*
BKSMVDTE DS    0H
         CLC   1(8,R15),=C'00000000'    CHECK FOR NO DATE/TIME AVAIL
         BNE   BKSMVDOK            BRANCH IF OK
         MVC   0(10,R1),=C'0000/00/00'  SET A NULL DATE
         LR    R1,R0               COPY THE TIME ADDRESS
         MVC   0(8,R1),=C'00:00:00'     SET A NULL TIME
         BR    R8                  RETURN WITH A NULL DATE/TIME
*
BKSMVDOK DS    0H
         MVC   0(10,R1),=C'0000/00/00'  INITIALIZE THE DATE FIELD
*
         MVC   5(2,R1),1(R15)      COPY THE MM, ASSUMING MM
         CLI   2(R15),C'/'         CHECK FOR ONE DIGIT MONTH (UGH!)
         BNE   BKSMVMOK            BRANCH IF MONTH OK
*
         MVI   5(R1),C'0'          SET THE LEADING ZERO
         MVC   6(1,R1),1(R15)      COPY THE M
         BCTR  R15,0               BACK UP ONE TO COMPENSATE
*
BKSMVMOK DS    0H
         LA    R15,3(,R15)         INCREMENT TO SLASH BETWEEN MM & DD
*
         MVC   8(2,R1),1(R15)      COPY THE DD, ASSUMING DD
         CLI   2(R15),C'/'         CHECK FOR ONE DIGIT DAY (UGH!)
         BNE   BKSMVYOK            BRANCH IF DAY OK
*
         MVI   5(R1),C'0'          SET THE LEADING ZERO
         MVC   6(1,R1),1(R15)      COPY THE D
         BCTR  R15,0               BACK UP ONE TO COMPENSATE
*
BKSMVYOK DS    0H
         LA    R15,3(,R15)         INCREMENT TO SLASH BETWEEN DD & YY
*
         MVC   2(2,R1),1(R15)      COPY THE YY
         MVC   0(2,R1),OCENTURY    SEED THE CENTURY AS OLD
         CLC   2(2,R1),WCENTURY    CHECK WINDOWING
         BH    *+10                BRANCH IF HIGH
         MVC   0(2,R1),NCENTURY    SET THE NEW CENTURY
*
         LA    R15,4(,R15)         INCREMENT THE DATE/TIME POINTER
*
         LR    R1,R0               COPY THE TIME ADDRESS
         MVC   0(8,R1),=C'00:00:00'     INITIALIZE THE TIME FIELD
*
         CR    R14,R15             MATCH AGAINST END OF THE DATE/TIME
         BNHR  R8                  RETURN IF NO TIME
*
         MVC   0(8,R1),0(R15)      COPY THE HH:MM:SS
         BR    R8                  RETURN
*
***********************************************************************
*                                                                     *
*        INITIALIZE THE OUTPUT RECORD IN THE WORK AREA                *
*                                                                     *
***********************************************************************
*
INFOINIT DS    0H
         LA    R0,BKNLNGTH         LOAD THE BASE LENGTH
         STH   R0,BKNLENG          STORE IN THE RDW LENGTH
         MVI   BKNNAME,C' '        BLANK OUT THE
         MVC   BKNNAME+1(BKNLNGTH-5),BKNNAME BASE RECORD AREA
*
         MVC   BKNBKDTE,STARDATE   INITIALIZE THE BOOK BUILD DATE
         MVC   BKNBKTIM,STARTIME   INITIALIZE THE BOOK BUILD TIME
*
         MVC   BKNSTAT,ALLSTARS    INITIALIZE THE BOOK STATUS
*
         MVC   BKNCKIT,STARPUBN    INITIALIZE THE COLLECTION KIT ID
         MVC   BKNPUBNO,STARPUBN   INITIALIZE THE PUBLICATION NUMBER
*
         MVC   BKNBKSID,ALLSTARS   INITIALIZE THE BOOKSHELF ID
         MVC   BKNDSNME,ALLSTARS   INITIALIZE THE DATA SET NAME
*
         MVC   BKNTITLE(8),ALLSTARS     INITIALIZE THE TITLE
*
         BR    R8                  RETURN TO CALLER
*
***********************************************************************
*                                                                     *
*        CONSTRUCT THE TITLE                                          *
*                                                                     *
*        REGISTER 1 POINTS TO THE HALFWORD LENGTH OF THE TITLE        *
*        IMMEDIATELY FOLLOWED BY THE TITLE.  THE RECORD CONTAINED     *
*        IN THE RECORD WORK AREA IS UPDATED.                          *
*                                                                     *
***********************************************************************
*
INFOTITL DS    0H
         LH    R0,0(,R1)           LOAD THE TITLE LENGTH
         LTR   R0,R0               TEST IF THE TITLE EVEN EXISTS
         BNZ   INFOTITG            BRANCH IF TITLE PRESENT
*
         LA    R1,NOTITLEL         POINT AT NO TITLE LENGTH
         LH    R0,NOTITLEL         LOAD THE NO TITLE LENGTH
*
INFOTITG DS    0H
         LA    R14,1(,R1)          GET THE POINTER TO THE LAST
         AR    R14,R0               CHARACTER IN THE TITLE
*
INFOTITB DS    0H
         CLI   0(R14),C' '         CHECK FOR A TRAILING BLANK
         BNE   INFOTITZ            BRANCH IF NOT
         BCTR  R14,0               BACK UP ONE CHARACTER
         BCT   R0,INFOTITB         LOOP THROUGH THE END OF THE TITLE
*
         LA    R1,NOTITLEL         POINT AT NO TITLE LENGTH
         LH    R0,NOTITLEL         LOAD THE NO TITLE LENGTH
*
INFOTITZ DS    0H
         LR    R14,R0              COPY THE TITLE LENGTH
         CH    R14,=Y(L'INFOWORK-BKNLNGTH)  CHECK IF TOO BIG
         BNH   *+8                 BRANCH IF OK
         LA    R14,L'INFOWORK-BKNLNGTH  SET MAX LENGTH
*
         LH    R0,BKNLENG          LOAD THE EXISTING RECORD LENGTH
         AR    R0,R14              ADD THE TITLE LENGTH
         STH   R0,BKNLENG          STORE IN THE RDW LENGTH
         CH    R0,=Y(L'INFOWORK)   CHECK MAXIMUM LENGTH
         BNH   *+6                 BRANCH IF OK
         DC    H'0'                BLOW UP FOR NOW....
*
         BCTR  R14,0               DECREMENT LENGTH FOR MVC
         EX    R14,INFOTITM        MOVE THE TITLE
*
         BR    R8                  RETURN TO CALLER
*
INFOTITM MVC   BKNTITLE(*-*),2(R1) *** EXECUTE ONLY ***
*
         EJECT
***********************************************************************
*                                                                     *
*        DETERMINE STATUS OF DATA SET NAME                            *
*                                                                     *
*        REGISTER 1 POINTS TO THE DATA SET NAME TO DETERMINE THE      *
*        STATUS OF.  ON RETURN, REGISTER 1 POINTS TO THE 8 CHARACTER  *
*        DATA SET NAME STATUS:                                        *
*                                                                     *
*        ACTIVE   - DATA SET IS CATALOGUED                            *
*        ARCHIVED - DATA SET HAS BEEN ARCHIVED                        *
*        MISSING  - DATA SET IS NOT CATALOGUED AND NOT ARCHIVED       *
*                                                                     *
***********************************************************************
*
INFOSTAT DS    0H
         TM    PROCFLAG,PROCINFO   ARE WE IN INFORMATION MODE
         BZ    INFOSTAI            BRANCH IF NOT
         LA    R1,ALLSTARS         ALWAYS SET ******** FOR INFORMATION
         BR    R8                  AND RETURN
*
INFOSTAI DS    0H
         CLI   0(R1),C'*'          DO WE HAVE NO DATA SET NAME
         BNE   INFOSTNS            BRANCH IF IT'S NOT
         LA    R1,=CL8'NOTAVAIL'   INDICATE WE DON'T HAVE IT AT ALL
         BR    R8                  AND RETURN
*
INFOSTNS DS    0H
         MVC   LOCDSN,0(R1)        COPY THE DATA SET NAME
*
         LOCATE CAMLST             DO THE LOCATE
*
         LTR   R15,R15             TEST RETURN CODE
         BNZ   INFOSNCT            BRANCH IF NOT FOUND IN CATALOG
*
         TM    PROCFLAG,PROCVOL    IS VOLUME INFO WANTED
         BZ    INFOSTNV            BRANCH IF NOT
         MVC   LOCVOLSQ,=C'  '     BLANK OUT SEQUENCE NUMBER
         LA    R1,LOCVOLSR         POINT AT VOLUME SERIAL NUMBER
         BR    R8                  RETURN TO CALLER
*
INFOSTNV DS    0H
         LA    R1,=CL8'ARCHIVED'   INDICATE THE DATA SET IS ARCHIVED
         CLC   LOCVOLSR,=C'MIGRAT' CHECK FOR HSM ARCHIVE VOL SER
         BER   R8                  RETURN IF SO
*
         LA    R1,=CL8'ACTIVE'     ASSUME WE FOUND IT
         BR    R8                  RETURN IF WE HAVE A REAL DATA SET
*
INFOSNCT DS    0H
         LA    R1,=CL8'MISSING'    INDICATE WE CAN'T FIND THIS ANYWHERE
         BR    R8                  AND RETURN TO CALLER
*
***********************************************************************
*                                                                     *
*        DETERMINE THE USM LEVEL OF A BOOK DATA SET                   *
*                                                                     *
*        THE DATA SET NAME POINTED TO BY REGISTER 1 IS SCANNED        *
*        FOR STRINGS THAT INDICATE THAT THE BOOK IS FROM THE          *
*        UNIVERSAL SALES MANUAL.  IF SO, REGISTER 1 WILL BE           *
*        RETURNED POINTING TO THE TWO CHARACTER USM BOOK LEVEL.       *
*                                                                     *
*        IF THE BOOK IS NOT A UNIVERSAL SALES MANUAL BOOK,            *
*        REGISTER 1 WILL BE ZERO.                                     *
*                                                                     *
***********************************************************************
*
GETUSMLV DS    0H
         LA    R0,44               LENGTH OF THE DATA SET NAME
*
GETUSMLP DS    0H
         CLI   0(R1),C' '          ARE WE AT THE END OF THE DATA SET
         BE    GETUSMZR            RETURN IF SO
*
         CLI   0(R1),C'.'          CHECK FOR A DELIMITER
         BNE   GETUSMNX            GO TO NEXT STRING IF NOT
*
         CLC   1(3,R1),=C'LVL'     CHECK FOR OLD NAME FORMAT
         BNE   GETUSMNL            BRANCH IF NOT
         CLI   6(R1),C'.'          CHECK ENDING DELIMITER
         BNE   GETUSMNX            BRANCH IF NOT - CAN'T BE USM (YET)
*
         LA    R1,4(,R1)           POINT AT USM LEVEL NUMBER
         BR    R8                  RETURN IF USM LEVEL FOUND
*
GETUSMNL DS    0H
         CLC   1(3,R1),=C'USM'     CHECK FOR NEW NAME FORMAT
         BNE   GETUSMNU            BRANCH IF NOT
*
         CLC   4(2,R1),=C'HW'      CHECK FOR HARDWARE
         BE    GETUSMNH            BRANCH IF SO
         CLC   4(2,R1),=C'SW'      CHECK FOR SORTWARE
         BE    GETUSMNS            BRANCH IF SO
         CLC   4(2,R1),=C'PR'      CHECK FOR PRICES
         BE    GETUSMNP            BRANCH IF SO
*
         B     GETUSMNU            CAN'T BE USM BOOK
*
GETUSMNH DS    0H
GETUSMNS DS    0H
GETUSMNP DS    0H
         LA    R1,6(,R1)           POINT AT USM BOOK LEVEL
         BR    R8                  RETURN TO CALLER WITH USM LEVEL
*
GETUSMNU DS    0H
*
GETUSMNX DS    0H
         LA    R1,1(,R1)           INCREMENT TO NEXT DATA SET NAME CHAR
         BCT   R0,GETUSMLP         LOOP THROUGH THE DATA SET NAME
*
GETUSMZR DS    0H
         SLR   R1,R1               INDICATE IT'S NOT A USM BOOK
         BR    R8                  RETURN TO CALLER
*
***********************************************************************
*                                                                     *
*        WRITE OUT THE ACTIVE RECORD                                  *
*                                                                     *
***********************************************************************
*
INFOWRIT DS    0H
         LA    R0,1                LOAD A 1
         A     R0,INFOCNT          ADD THE PREVIOUS COUNT
         ST    R0,INFOCNT          STORE THE UPDATED COUNT
*
         PUT   INFOFILE,INFOWORK   WRITE OUT THE NEWLY BUILT RECORD
*
         BR    R8                  RETURN TO CALLER
*
         EJECT
***********************************************************************
*                                                                     *
*        VARIOUS ABEND ROUTINES                                       *
*                                                                     *
***********************************************************************
*
PARMINVL DS    0H
         ABEND 10,DUMP
*
PARMERR1 DS    0H
         ABEND 20,DUMP
*
BKLALOCE DS    0H
         ABEND 30,DUMP
*
BKLOPENE DS    0H
         ABEND 35,DUMP
*
BKSALOCE DS    0H
         ABEND 40,DUMP
*
BKSOPENE DS    0H
         ABEND 45,DUMP
*
BKSPALOC DS    0H
         ABEND 50,DUMP
*
BKSPDSER DS    0H
         ABEND 55,DUMP
*
INFOPENE DS    0H
         ABEND 60,DUMP
*
BKSISBAD DS    0H
         ABEND 70,DUMP
*
LOADERR0 DS    0H
         ABEND 75,DUMP
*
LOADERR1 DS    0H
         ABEND 80,DUMP
*
LOADERR2 DS    0H
         ABEND 90,DUMP
*
LOADERR3 DS    0H
         ABEND 95,DUMP
*
LOADERR4 DS    0H
         ABEND 97,DUMP
*
BADDSN   DS    0H
         ABEND 100,DUMP
*
         EJECT
LITERALS LTORG ,
*
         EJECT
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
*
CCCBKEXD CSECT
CCCBKEXD AMODE 24
CCCBKEXD RMODE 24
*
SAVEAREA DC    9D'0'               REGISTER SAVE AREA
*
DOUBLE   DS    D                   DOUBLE WORD WORK AREA
*
BKLFIRST DC    A(0)                ADDRESS OF FIRST BOOKSHELF LIST DSN
BKLCOUNT DC    F'0'                COUNT OF BOOKSHELF LIST DATA SETS
*
BKSFIRST DC    A(0)                ADDRESS OF FIRST BOOKSHELF DSNAME
BKSCOUNT DC    F'0'                COUNT OF BOOKSHELF DATA SETS
*
BOOKCNT  DC    F'0'                COUNT OF BOOKSHELF RECORDS READ
*
INFOCNT  DC    F'0'                COUNT OF EXTRACT RECORDS CREATED
*
DYNCOUNT DC    F'0'                COUNT OF DYNAMIC ALLOCATIONS
*
DSNHOLD  DS    CL44                AREA TO HOLD THE DATA SET NAME
BKSHOLD  DS    CL8                 AREA TO HOLD THE BOOKSHELF NAME
*
CPSNAME  DC    CL8'CCCBKCPS'       CELL POOL ROUTINE NAME
CPSADDR  DC    A(0)                CELL POOL SUBROUTINE ADDRESS
*
BKLBLOCK BKMGRCPS ID=BKL,SP=22,SIZE=16
*
MEMBLOCK BKMGRCPS ID=MEM,SP=44,SIZE=4
*
BKSBLOCK BKMGRCPS ID=BKS,SP=33,SIZE=128
*
DSNSUB   DC    CL8'CCCBKDSN'       DATA SET NAME SUBROUTINE NAME
DSNADDR  DC    A(0)                DATA SET NAME SUBROUTINE ADDRESS
*
DATTBL   DC    CL8'CCCBKDAT'       DATA TABLE MODULE
DEFSUB   DC    CL8'CCCBKDEF'       DEFINITION SUBROUTINE
*
DSNPARMS DS    0A
         DC    A(DSNNAME)          NAME OF BOOK
         DC    A(DSNTYPE)          TYPE OF BOOK
         DC    X'80',AL3(DSNDSN)   RETURNED DATA SET NAME
*
DSNNAME  DS    CL8                 NAME OF BOOK
DSNTYPE  DS    CL8                 TYPE OF BOOK
DSNDSN   DS    CL44                RETURNED DATA SET NAME
*
TODAY    DS    0CL10               TODAY'S DATE FOR UPDATING
TODAYYYY DS    C'YYYY'             THE YEAR
         DC    C'/'
TODAYMM  DS    C'MM'               THE MONTH
         DC    C'/'
TODAYDD  DS    C'DD'               THE DAY
*
THEDATE  DS    0F,PL4              THE DATE FROM THE TIME MACRO
*
DAYSOOL  DC    PL2'31,28,31,30,31,30,31,31,30,31,30,31'
DAYSFEB  EQU   DAYSOOL+L'DAYSOOL
*
VERBTYPE DS    C                   TYPE OF BOOKSHELF LIST VERB
*
PROCFLAG DC    X'00'               TYPE OF BOOKSHELF PROCESSING
PROCACTV EQU   X'80'               ACTIVE BOOKSHELF PROCESSING
PROCINFO EQU   X'40'               INFORMATION BOOKSHELF PROCESSING
PROCVOL  EQU   X'20'               VOLUME INFORMATION WANTED
*
         DS    0D
BKSNAME  DS    CL8                 BOOKSHELF NAME ID (FROM DATA SET)
BKSID    DS    CL8                 BOOKSHELF NAME (FROM BKSHELF=)
BKINAME  DS    CL8                 BOOKSHELF NAME (FROM BKSINDEX=)
BKSTITLL DS    H                   BOOKSHELF TITLE LENGTH
BKSTITLE DS    CL256               BOOKSHELF TITLE (FROM BKSTITLE=)
BKSBDATE DS    CL10                BOOKSHELF DATE (FROM BKSDATETIME=)
BKSBTIME DS    CL8                 BOOKSHELF TIME (FROM BKSDATETIME=)
BKIBDATE DS    CL10                BKSHELFINDX DATE (FROM BKSDATETIME=)
BKIBTIME DS    CL8                 BKSHELFINDX TIME (FROM BKSDATETIME=)
BKSDSN   DS    CL44                BOOKSHELF DATA SET NAME
BKSLNAME DS    CL8                 BOOKSHELF NAME FROM BOOKSHELF LIST
BKIDSN   DS    CL44                BOOKSHELF INDEX DSN (FROM BKSIMDSN=)
*
         DS    0D
BOOKSH   DS    CL12                BOOK PUBLICATION NUMBER (FROM SH)
BOOKNAME DS    CL8                 BOOK NAME (FROM BKNAME=)
BOOKTTLL DS    H                   BOOK TITLE LENGTH
BOOKTITL DS    CL256               BOOK TITLE (FROM ST)
BOOKDSN  DS    CL44                BOOK DATA SET NAME (FROM BKMDSN=)
BOOKDATE DS    CL10                BOOK BUILD DATE (FROM BKDATETIME=)
BOOKTIME DS    CL8                 BOOK BUILT TIME (FROM BKDATETIME=)
*
         DS    0D
BLANKS   DC    CL256' '            AREA FOR BLANKING AND UPPERCASING
ALLSTARS DC    44C'*'              FILLER FOR UNDEFINED FIELDS
STARDATE DC    C'****/**/**'       FILLER FOR UNDEFINED DATE
STARTIME DC    C'**:**:**'         FILLER FOR UNDEFINED TIME
STARPUBN DC    C'****-****-**'     FILLER FOR UNDEFINED PUB NUMBER
*
NOTITLEL DC    Y(L'NOTITLE)        LENGTH OF NO TITLE STRING
NOTITLE  DC    C'(No Title Found)' NO TITLE FOUND STRING
*
OCENTURY DC    C'19'               DEFINE THE CURRENT CENTURY FOR DATES
NCENTURY DC    C'20'               DEFINE THE CURRENT CENTURY FOR DATES
WCENTURY DC    C'80'               DATE WINDOW (UGH!)
*
PUBNOOUT DS    CL12                WORKING PUBLICATION NUMBER
PUBNOIN  DS    CL12                EXTRACTED PUBLICATION NUMBER
*
PUBNONAM DC    CL8'CCCBKPUB'       PUBLICATION NUMBER SUBROUTINE NAME
PUBNOADR DC    A(0)                PUBLICATION NUMBER SUBROUTINE ADDR
*
PUBNOPRM DC    A(PUBNOIN),X'80',AL3(PUBNOOUT)
*
CAMLST   CAMLST NAME,LOCDSN,,LOCWORK
*
         DS    0D
LOCDSN   DS    CL44
*
         DS    0D
LOCWORK  DS    CL265
         ORG   LOCWORK
LOCCOUNT DS    H
LOCDEVT  DS    XL4
LOCVOLSR DS    CL6
LOCVOLSQ DS    H
         ORG   ,
*
DYNPTR   DC    0F'0',X'80',AL3(DYNBLOCK) DYNAMIC ALLOC BLOCK POINTER
*
DYNBLOCK DS    0F
         DC    AL1(20),AL1(S99VRBAL)    LENGTH AND ALLOC VERB
         DC    H'0',H'0',H'0'      FLAGS, ERROR, INFO
         DC    A(DYNTEXTP)         TEXT UNIT POINTERS
         DC    A(0)                EXTENSION POINTER
         DC    XL4'00'             MORE FLAGS
*
DYNTEXTP DS    0A
         DC    A(DYNDSNTX)         DATA SET NAME
         DC    A(DYNSHRTX)         DISP=SHR
         DC    X'80',AL3(DYNRDDTX) RETURN DDNAME
*
         DS    0F
DYNDSNTX DC    Y(DALDSNAM)         DATA SET NAME
         DC    H'1'
         DC    H'44'
DYNDSN   DS    CL44                DATA SET NAME
*
         DS    0F
DYNSHRTX DC    Y(DALSTATS)         DISPOSITION
         DC    H'1'
         DC    H'1'
         DC    AL1(8)              DISP=SHR
*
         DS    0F
DYNRDDTX DC    Y(DALRTDDN)         RETURN DDNAME
         DC    H'1'
         DC    H'8'
DYNDDNAM DS    CL8                 RETURN DDNAME
*
         DS    0D
INFOWORK DS    CL259               RECORD BUILD WORK AREA
*
         EJECT
         PUSH  PRINT
         PRINT NOGEN
*
BKLSHELF DCB   DSORG=PS,                                               X
               DDNAME=********,                                        X
               MACRF=GL,                                               X
               RECFM=VB,                                               X
               EODAD=BKLEOD
*
BKSDIRCT DCB   DSORG=PS,                                               X
               DDNAME=********,                                        X
               MACRF=GL,                                               X
               RECFM=FB,                                               X
               LRECL=256,                                              X
               BLKSIZE=256,                                            X
               EODAD=BKSEODIR
*
BKSHELF  DCB   DSORG=PS,                                               X
               DDNAME=********,                                        X
               MACRF=GL,                                               X
               EXLST=BKSEXLST,                                         X
               RECFM=VB,                                               X
               EODAD=BKSEOD
*
BKSEXLST DC    0F'0',X'87',AL3(BKSJFCB)
*
BKSJFCB  DS    CL176
*
INFOFILE DCB   DSORG=PS,                                               X
               DDNAME=INFOFILE,                                        X
               MACRF=PM,                                               X
               RECFM=VB
*
         POP   PRINT
*
CCCBKEXL EQU   *-CCCBKEXD          LENGTH OF DATA AREA
*
         EJECT
*
         PUSH  PRINT
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=DA
*
         IEFZB4D0
*
         IEFZB4D2
*
JFCB     DSECT
         IEFJFCBN
*
         BKMGRINF
*
         POP   PRINT
*
         END   CCCBKEXT
