COMMAND  TITLE 'PROGRAM TO ISSUE O/S COMMANDS FROM A DATASET'
***********************************************************************
*                                                                     *
* STATUS - CHANGE LEVEL 1  JAW  05-17-1999 - PROVIDE SYSPLEX SUPPORT  *
*                          ISSUE FIND '*JAW*' FOR CHANGES             *
*                          C O M M A N D                              *
*                                                                     *
*        THIS PROGRAM WILL USE THE SVC 34 INTERFACE TO ISSUE O/S OR   *
*        JES2 COMMANDS.                                               *
*                                                                     *
*        CALLERS OF THIS PROGRAM REQUIRE SPECIAL ACCESS               *
*        AUTHORITY AS FOLLOWS:                                        *
*                                                                     *
*           THE USER MUST BE AUTHORIZED THROUGH A SPECIAL             *
*           SECURITY CALL TO SAF FOR RESOURCE CLASS "FACILITY"        *
*           AND ENTITY NAME "COMMAND".                                *
*                                                                     *
*                                                                     *
*        WHAT MAKES THIS PROGRAM DIFFERENT FROM MOST PROGRAMS         *
*        WHAT ISSUE COMMANDS ARE FOUR SPECIAL COMMANDS:               *
*                                                                     *
*        1)  DELAY=NNN - THIS COMMAND MAKES THE PROGRAM DELAY         *
*            NNN SECONDS PRIOR TO ISSUING THE NEXT COMMAND IN         *
*            THE LIST.                                                *
*                                                                     *
*        2)  REPLY JOBNAME MESSAGEID REPLYTEXT - THIS GIVES           *
*            THE ABILITY TO REPLY TO OUTSTANDING REPLIES FOR          *
*            SPECIFIED JOBS WITHOUT HAVING TO KNOW THE REPLY          *
*            ID.                                                      *
*                                                                     *
*        3)  STARTED JOBNAME - THIS GIVES THE ABILITY TO WAIT         *
*            FOR A SPECIFIC BATCH JOB OR STARTED TASK TO START        *
*            OR TO INSURE THAT IT IS EXECUTING AT THE PRESENT         *
*            TIME.                                                    *
*                                                                     *
*        4)  STOPPED JOBNAME - THIS GIVES THE ABILITY TO WAIT         *
*            FOR A SPECIFIC BATCH JOB OR STARTED TASK TO END          *
*            OR TO INSURE THAT IT IS NOT EXECUTING AT THE             *
*            PRESENT TIME.                                            *
*                                                                     *
*        THE COMMANDS CAN COME FROM TWO INPUT SOURCES.  THE FIRST     *
*        IS THE PARM VALUE ON THE EXECUTE CARD FOR THE STEP.  THE     *
*        OTHER IS FROM THE INPUT DATA SET IEFRDER.  IF THE SOURCE     *
*        IS THE PARM FIELD, MULTIPLE COMMANDS CAN BE ENTERED BY       *
*        SEPARATING EACH COMMAND WITH A ";".  IF THE SOURCE IS THE    *
*        INPUT DATA SET, EACH RECORD WILL CONTAIN A SINGLE COMMAND    *
*        STARTING IN COLUMN 1 THROUGH COLUMN 72 OF EACH RECORD.       *
*        IF BOTH THE PARM AND INPUT DATASET ARE USED, THE COMMANDS    *
*        IN THE PARM ARE EXECUTED FIRST.                              *
*                                                                     *
*        ONLY THE FIRST 72 CHARACTERS OF EACH COMMAND WILL BE USED    *
*        WHEN ACTUALLY ISSUING THE COMMAND.                           *
*                                                                     *
*        COMMENTS CAN BE ENTERED WITH THE COMMANDS BY STARTING        *
*        THE COMMAND WITH A '*'.  THIS CAUSES THE COMMAND TO BE       *
*        BYPASSED.                                                    *
*                                                                     *
*        IF THE COMMAND IS "DELAY=NNN", THE PROGRAM WILL ENTER A      *
*        WAIT FOR THE NUMBER OF SECONDS SPECIFIED BY "NNN".  IF       *
*        MORE THAN A THREE DIGIT DELAY TIME IS SPECIFIED, ONLY        *
*        THE FIRST THREE DIGITS WILL BE USED.                         *
*                                                                     *
*        IF THE COMMAND IS "REPLY JOBNAME MESSAGEID REPLYTEXT"        *
*        THE PROGRAM WILL SEARCH FOR OUTSTANDING REPLIES FOR          *
*        THE SPECIFIED JOBNAME AND CONTAINING THE OPTIONAL            *
*        MESSAGE TEXT.                                                *
*                                                                     *
*        THE FULL JOBNAME MUST BE SPECIFIED.  THE USE IF THE          *
*        MESSAGEID FIELD IS OPTIONAL.  IF MULTIPLE REPLIES MAY        *
*        BE OUTSTANDING FOR THE JOB, THIS PARAMETER CAN BE USED       *
*        TO SPECIFY A MESSAGEID OR CHARACER STRING CONTAINED IN       *
*        THE MESSAGE.  IF NO MESSAGEID IS TO BE SPECIFIED, A          *
*        '*' MUST BE SPECIFIED.  SINGLE QUOTES MAY BE USED IF         *
*        THE STRING CONTAINS IMBEDDED BLANKS.                         *
*                                                                     *
*        THE REPLY TEXT MUST BE SPECIFIED.  SINGLE QUOTES MAY         *
*        BE USED IF THE STRING CONTAINS IMBEDDED BLANKS.              *
*                                                                     *
*        IF THE COMMAND IS "STOPPED JOBNAME" THE PROGRAM WILL         *
*        SEARCH ALL ACTIVE JOBS AND TASKS TO INSURE THAT THE          *
*        SPECIFIED JOB OR TASK NAME IS NOT EXECUTING.  IF IT          *
*        IS EXECUTING, A NON-ROLLABLE MESSAGE WILL BE SEND TO         *
*        THE CONSOLE STATING THAT THE PROGRAM IS WAITING FOR          *
*        THAT JOB TO STOP.  WHEN THE JOB OR TASK STOPS, THE           *
*        MESSAGE WILL BE DELETED AND PROCESSING WILL CONTINUE.        *
*                                                                     *
*        IF THE COMMAND IS "STARTED JOBNAME" THE PROGRAM WILL         *
*        SEARCH ALL ACTIVE JOBS AND TASKS TO INSURE THAT THE          *
*        SPECIFIED JOB OR TASK NAME IS EXECUTING.  IF IT IS NOT       *
*        EXECUTING, A NON-ROLLABLE MESSAGE WILL BE SEND TO THE        *
*        CONSOLE STATING THAT THE PROGRAM IS WAITING FOR THAT         *
*        JOB TO START.  WHEN THE JOB OR TASK STARTS, THE              *
*        MESSAGE WILL BE DELETED AND PROCESSING WILL CONTINUE.        *
*                                                                     *
*                                                                     *
*        BECAUSE THIS PROGRAM ISSUES THE MODESET MACRO AND USES       *
*        CROSS MEMORY SERVICES, IT MUST BE APF AUTHORIZED TO DO       *
*        SO.                                                          *
*                                                                     *
*        ESA VERSION 4 ALLOWS A REPLYID TO BE UP TO 4 CHARACTERS      *
*        LONG.  THIS PROGRAM DOES NOT SUPPORT THIS.  IF THAT          *
*        SUPPORT IS REQUIRED, THE REPLYID CAN BE EXTRACTED FROM       *
*        THE BINARY REPLY ID IN FIELD WQERPYIB USING THE              *
*        VERSION OF THE IHAWQE MACRO AND THE LENGTH OF THE            *
*        REPLY IN THE COMMAND BUFFER CAN BE CHANGED.  SOME            *
*        OTHER CHANGES WOULD LIKELY BE NEEDED FOR SYSPLEX AS          *
*        WELL.   THIS CHANGE WAS NOT MADE TO KEEP COMPATIBILITY       *
*        WITH ESA VERSION 3.                                          *
*                                                                     *
*                                                                     *
*        WRITTEN BY:                                                  *
*                   JOHN V. HOOPER                                    *
*                   FOOD LION, INC.                                   *
*                   2110 EXECUTIVE DRIVE                              *
*                   SALISBURY, N.C.  28145-1330                       *
*                                                                     *
*                                                                     *
*                           DISCLAIMER                                *
*                                                                     *
*      THE AUTHORS INCLUDING FOOD LION, ITS OFFICERS,                 *
*      DIRECTORS, AND EMPLOYEES MAKE NO REPRESENTATION OR             *
*      WARRANTY OF ANY KIND WHATSOEVER, INCLUDING, BUT NOT            *
*      LIMITED TO, REPRESENTATIONS OR WARRANTIES, EXPRESS OR          *
*      IMPLIED, OR MERCHANTABILITY, FITNESS FOR USE OR PURPOSE,       *
*      ACCURACY OR COMPLETENESS OF PROCESSES, PROCEDURES,             *
*      DESIGNS, DEFINITIONS, INSTRUCTIONS, INFORMATION, OR            *
*      FUNCTIONING OF ANY PROGRAMS, DOCUMENTS, OR RELATED             *
*      MATERIALS; THE AUTHORS FURTHER EXPRESSLY DISCLAIM ANY          *
*      KNOWLEDGE OF PURPOSE FOR WHICH THESE PROGRAMS,                 *
*      DOCUMENTS, OR RELATED MATERIAL MAY BE UTILIZED OR THEIR        *
*      APPLICABILITY FOR SUCH USE, NOR SHALL THE FACT OF MAKING       *
*      THEM AVAILABLE CONSTITUTE ANY SUCH REPRESENTATION,             *
*      WARRANTY, OR KNOWLEDGE; NOR DO THE AUTHORS ASSUME ANY          *
*      LIABILITY, RESPONSIBILITY, OR OBLIGATION ARISING FROM          *
*      THE USE OR MALFUNCTIONING OF OF THESE COMPUTER PROGRAMS,       *
*      DOCUMENTATION, OR RELATED MATERIALS.                           *
*                                                                     *
*                                                                     *
***********************************************************************
         SPACE 3
***********************************************************************
*                                                                     *
*                        SAMPLE JCL                                   *
*                                                                     *
*       //JOBNAME ...                                                 *
*       //COMMAND  EXEC PGM=COMMAND,REGION=4M                         *
*       //IEFRDER  DD  *                                              *
*       D R,R                                                         *
*       DELAY=10                                                      *
*       STARTED CICS                                                  *
*       DELAY=10                                                      *
*       REPLY TESTJOB 'WAITING FOR' 'STOP'                            *
*       DELAY 10                                                      *
*       REPLY TESTJOB * YES                                           *
*       DELAY 10                                                      *
*       D R,R                                                         *
*                                                                     *
*       IN THE ABOVE EXAMPLE, THE DELAY COMMAND IS USED TO            *
*       PAUSE THE PROGRAM FOR 10 SECONDS BETWEEN COMMANDS TO          *
*       ALLOW TIME FOR THE PREVIOUS COMMAND TO BE EXECUTED.           *
*                                                                     *
*       THE STARTED COMMAND WILL INSURE THAT THE JOB OR TASK          *
*       CICS IS EXECUTING.                                            *
*                                                                     *
*       THE FIRST REPLY COMMAND WILL REPLY 'STOP' TO THE FIRST        *
*       OUTSTANDING REPLY FOR JOB TESTJOB WHICH CONTAINS              *
*       THE CHARACTERS 'WAITING FOR'.                                 *
*                                                                     *
*       THE SECOND REPLY COMMAND WILL REPLY 'YES' TO THE              *
*       FIRST OUTSTANDING REPLY FOR JOB TESTJOB NO                    *
*       MATTER WHAT REPLY MESSAGE IS OUTSTANDING.                     *
*                                                                     *
***********************************************************************
         EJECT
***********************************************************************
*                                                                     *
*            M A C R O S   U S E D   I N   C O M M A N D              *
*                                                                     *
*        01)  ABEND        SYS1.MACLIB                                *
*        02)  AXSET        SYS1.MACLIB                                *
*        03)  CALL         SYS1.MACLIB                                *
*        04)  CLOSE        SYS1.MACLIB                                *
*        05)  CVT          SYS1.MODGEN                                *
*        06)  DCB          SYS1.MACLIB                                *
*        07)  DOM          SYS1.MACLIB                                *
*        08)  EXTRACT      SYS1.MACLIB                                *
*        09)  FREEMAIN     SYS1.MACLIB                                *
*        10)  GET          SYS1.MACLIB                                *
*        11)  GEMAIN       SYS1.MACLIB                                *
*        12)  IEECUCM      SYS1.MODGEN                                *
*        13)  IEFTIOT1     SYS1.MACLIB                                *
*        14)  IHAASCB      SYS1.MODGEN                                *
*        15)  IHAASVT      SYS1.MODGEN                                *
*        16)  IHAORE       SYS1.MODGEN                                *
*        17)  IHAPSA       SYS1.MACLIB                                *
*        18)  IHAWQE       SYS1.MODGEN                                *
*        19)  MGCR         SYS1.MODGEN                                *
*        20)  MODESET      SYS1.MACLIB                                *
*        21)  OPEN         SYS1.MACLIB                                *
*        22)  RETURN       SYS1.MACLIB                                *
*        23)  SAVE         SYS1.MACLIB                                *
*        24)  SETLOCK      SYS1.MACLIB                                *
*        25)  STIMER       SYS1.MACLIB                                *
*        26)  WTO          SYS1.MACLIB                                *
*                                                                     *
*                                                                     *
*               L I N K A G E    E D I T O R    I N F O               *
*                                                                     *
*        SIZE:       3K                                               *
*        ATTRIBUTES: AUTHORIZED NORENT NOREUS NOREFR                  *
*                    AMODE24    RMODE24                               *
*                                                                     *
***********************************************************************
         EJECT
*
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         EJECT
***********************************************************************
*                                                                     *
*        START OF PROGRAM                                             *
*                                                                     *
***********************************************************************
COMMAND  CSECT
COMMAND  AMODE 24
COMMAND  RMODE 24
         SAVE  (14,12)             SAVE REGISTERS
         LR    R12,R15             SET BASE REGISTER
         USING COMMAND,R12         SET ADDRESSABILITY
         LA    R15,SAVEAREA        LOAD ADDRESS OF NEW SAVE
         ST    R15,8(R13)          STORE NEW SAVE ADDR IN OLD
         ST    R13,4(R15)          STORE OLD SAVE ADDR IN NEW
         LR    R13,R15             SET NEW SAVE ADDRESS
         LR    R2,R1               SAVE INPUT PARM ADDRESS
         EJECT
***********************************************************************
*                                                                     *
*  CHECK THE AUTHORITY OF THE USER TO SAF CLASS "FACILITY' FOR        *
*  ENTITY "COMMAND".  NOTE THAT FASTAUTH IS USED.  TO AVOID THE       *
*  SITUATION WHERE SPECIAL ATTRIBUTES OF THE USER MAY ALLOW THE       *
*  ACCESS WITH LOGGING, A CHECK IS MADE FOR A NON-ZERO REASON         *
*  CODE.  THIS CONDITION WILL BE CONSIDERED A FAILURE.                *
*                                                                     *
***********************************************************************
AUTHTST  RACROUTE REQUEST=FASTAUTH,WORKA=RACWORK,WKAREA=FRACWORK,      X
               ENTITY=RESOURCE,CLASS=FACILITY,ATTR=READ,               X
               MF=(E,RACROUTE)
         CH    R15,=H'4'           TEST THE RETURN CODE
         BE    EXTRACT             NO DECISION POSSIBLE, OK
         BH    NOTAUTH             GREATER THAN 4, NOT AUTHORIZED
         CLC   RACROUTE+4(4),=F'0' TEST THE REASON CODE
         BE    EXTRACT             ZERO, AUTHORIZED
NOTAUTH  WTO   'CMD913E UNAUTHORIZED USE OF THE COMMAND PROGRAM - JOB AX
               BORTED',ROUTCDE=(2,11)
         ABEND X'913',,,SYSTEM,REASON=0  ABEND THE JOB
***********************************************************************
*                                                                     *
*        EXTRACT MY JOB NAME FOR THE WTO MESSAGES                     *
*                                                                     *
***********************************************************************
EXTRACT  EXTRACT TIOTADDR,'S',FIELDS=TIOT EXTRACT THE ADDR OF THE TIOT
         L     R3,TIOTADDR         LOAD ADDRESS OF THE TIOT
         USING TIOT,R3             SET ADDRESSABILITY TO THE TIOT
         MVC   MYNAME,TIOCNJOB     SAVE THE JOBNAME
         DROP  R3                  DROP ADDRESSABILITY TO THE TIOT
         SPACE 3
***********************************************************************
*                                                                     *
*        GET STORAGE FOR AN OUTSTANDING REPLY TABLE                   *
*                                                                     *
***********************************************************************
         GETMAIN R,LV=13801        GET STORAGE FOR TABLE
         ST    R1,GETADDR          SAVE TABLE ADDRESS
         EJECT
***********************************************************************
*                                                                     *
*        SEE IF A PARM HAS BEEN ENTERED.  IF SO, PROCESS EACH         *
*        COMMAND WITHIN THE PARM.                                     *
*                                                                     *
***********************************************************************
CKPARM   LR    R1,R2               RESTORE INPUT PARM ADDRESS
         LTR   R1,R1               SEE IF INPUT PARM
         BZ    OPEN                NONE, GO OPEN FILE
         L     R9,0(R1)            LOAD PARM ADDRESS
         LTR   R9,R9               TEST PARM ADDRESS
         BZ    OPEN                ZERO, NO PARM, GO OPEN FILE
         LH    R8,0(R9)            LOAD PARM LENGTH
         LTR   R8,R8               TEST PARM LENGTH
         BZ    OPEN                ZERO, NO PARM, GO OPEN FILE
         LA    R9,2(R9)            POINT TO ACTUAL PARM
CKPARM1  LR    R1,R9               SAVE START ADDRESS OF PARM
         SLR   R15,R15             SET LENGTH OF COMMAND
CKPARM2  CLI   0(R1),C';'          SEE IF END OF COMMAND
         BE    CKPARM3             YES, BRANCH
         LA    R15,1(R15)          ADD 1 TO LENGTH
         LA    R1,1(R1)            INCREMENT TO NEXT CHAR OF PARM
         BCT   R8,CKPARM2          LOOP FOR NEXT CHAR OF PARM
CKPARM3  LTR   R15,R15             TEST FOR ZERO LENGTH
         BZ    CKPARM5             ZERO, NULL COMMAND, BRANCH
         CH    R15,=H'72'          SEE IF EXCEEDS MAX LENGTH
         BNH   CKPARM4             NO, BRANCH
         LA    R15,72              SET TO MAX LENGTH
CKPARM4  MVI   COMDATA+4,C' '      BLANK THE ENTIRE
         MVC   COMDATA+4+1(79),COMDATA+4  COMMAND AREA
         BCTR  R15,0               MAKE MACHINE LENGTH
         EX    R15,PARMCMD         MOVE PARM COMMAND TO BUFFER
         LR    R9,R1               SET NEW START OF CMD POINTER
         BAL   R10,DOCMD           GO ISSUE THE COMMAND
CKPARM5  CLI   0(R9),C';'          IS THERE ANOTHER COMMAND
         BNE   OPEN                NO, GET OUT
         LA    R9,1(R9)            INCREMENT PAST SEMICOLON
         BCTR  R8,0                REDUCE REMAINING PARM LENGTH BY 1
         LTR   R8,R8               TEST REMAINING PARM LENGTH
         BZ    OPEN                ZERO, FINISHED
         B     CKPARM1             GO PROCESS THIS COMMAND
PARMCMD  MVC   COMDATA+4(0),0(R9)  **** EXECUTE ONLY ****
         EJECT
***********************************************************************
*                                                                     *
*        OPEN THE IEFRDER DATA SET (IF SPECIFIED).                    *
*                                                                     *
***********************************************************************
OPEN     SLR   R15,R15        CLEAR REGISTER FOR ICM
         L     R14,16         POINT TO CVT
         L     R14,0(,R14)    POINT TO TCB POINTERS
         L     R14,4(,R14)    POINT TO CURRENT TCB
         L     R14,12(,R14)   POINT TO TIOT
         LA    R14,24(,R14)   POINT TO TIOT DD ENTRIES
OPEN1    ICM   R15,1,0(R14)   LOAD ENTRY LENGTH
         BZ    RETURN         END OF TIOT, END OF PROCESSING
         CLC   4(8,R14),=CL8'IEFRDER' SEE IF DD STATEMENT SPECIFIED
         BE    OPEN2          YES, GET OUT
         LA    R14,0(R15,R14) INCREMENT TO NEXT ENTRY
         B     OPEN1          LOOP
***********************************************************************
*                                                                     *
*        READ INPUT FILE.  PASS THE FIRST 72 CHARACTERS OF EACH       *
*        RECORD TO O/S AS A COMMAND.                                  *
*                                                                     *
***********************************************************************
OPEN2    OPEN  (IEFRDER,(INPUT))   OPEN INPUT FILE
READ     GET   IEFRDER             READ INPUT FILE
         MVI   COMDATA+4,C' '      BLANK THE ENTIRE
         MVC   COMDATA+4+1(79),COMDATA+4  COMMAND AREA
         MVC   COMDATA+4(72),0(R1) MOVE IN JES OR O/S COMMAND
         BAL   R10,DOCMD           GO ISSUE THE COMMAND
         B     READ
         EJECT
***********************************************************************
*                                                                     *
*        END OF THE PROGRAM                                           *
*                                                                     *
***********************************************************************
EOF      CLOSE (IEFRDER)           CLOSE INPUT FILE
RETURN   L     R1,GETADDR          LOAD ADDRESS OF GETMAINED TABLE
         FREEMAIN R,LV=13801,A=(1) FREE STORAGE USED BY THE TABLE
         L     R13,4(,R13)         LOAD ADDRESS OF OLD SAVE AREA
         RETURN (14,12),RC=0       RETURN TO O/S
         EJECT
***********************************************************************
*                                                                     *
*        EITHER ISSUE THE COMMAND WHICH HAS BEEN STORED AT            *
*        COMDATA+4 OR IF IT IS A DELAY COMMAND, WAIT THE SPECIFIED    *
*        INTERVAL OF TIME BEFORE CONTINUING WITH OTHER COMMANDS.      *
*                                                                     *
*        INPUT:  COMMAND AT COMDATA+4                                 *
*                R10 - RETURN ADDRESS                                 *
*                                                                     *
***********************************************************************
         SPACE 1
***********************************************************************
*        SEE IF THE COMMAND IS A DELAY COMMAND TO THE PROGRAM TO      *
*        WAIT A SPECIFIED INTERVAL OF TIME BEFORE CONTINUING WITH     *
*        OTHER INPUT COMMANDS.                                        *
***********************************************************************
DOCMD    CLI   COMDATA+4,C'*'      SEE IF A COMMENT STATEMENT
         BER   R10                 YES, BYPASS THIS COMMAND
         CLC   COMDATA+4(6),=CL6'DELAY=' SEE IF A DELAY COMMAND
         BNE   DOCMD2              NO, GO SEE IF REPLY COMMAND
DOCMD1   WTO   MF=(E,COMDATA)      ECHO THE COMMAND ON THE CONSOLE
         LA    R2,COMDATA+10       POINT TO START OF "DELAY=" VALUE
         LA    R3,8                SET MAXIMUM LENGTH OF DELAY VALUE
         SLR   R4,R4               SET LENGTH COUNTER
DOCMD1A  CLI   0(R2),C' '          END OF DELAY VALUE
         BE    DOCMD1B             YES, BRANCH
         LA    R4,1(,R4)           ADD 1 TO LENGTH COUNTER
         CLI   0(R2),C'0'          SEE IF LT 0
         BL    DOCMD1C             YES, NOT NUMERIC
         CLI   0(R2),C'9'          SEE IF GT 9
         BH    DOCMD1C             YES, NOT NUMERIC
         LA    R2,1(,R2)           INCREMENT TO NEXT INPUT CHARACTER
         BCT   R3,DOCMD1A          LOOP UP TO 8 TIMES
         CLI   0(R2),C' '          END OF DELAY VALUE
         BNE   DOCMD1C             NO, TOO LONG
DOCMD1B  LTR   R4,R4               TEST LENGTH
         BZ    DOCMD1C             ZERO, BLANK
         BCTR  R4,0                MAKE MACHINE LENGTH
         EX    R4,PACKTIME         PACK THE DELAY VALUE
         CVB   R5,DOUBLE           CONVERT DELAY TO BINARY
         LTR   R5,R5               CHECK VALUE
         BZ    DOCMD1C             ZERO, INVALID
         CH    R5,=H'999'          SEE IF EXCEEDS MAXIMUM VALUE
         BH    DOCMD1C             YES, ERROR
         MH    R5,=H'100'          MULTIPLY BY 100
         ST    R5,WAITIME          SAVE WAIT TIME IN HUNDRETHS OF A SEC
         STIMER WAIT,BINTVL=WAITIME WAIT THE SPECIFIED TIME
         B     DOCMD6              GO GET ANOTHER COMMAND
DOCMD1C  WTO   'CMD001E ILLEGAL VALUE SPECIFIED ON THE DELAY CONTROL STX
               ATEMENT - JOB ABORTED',ROUTCDE=(2,11)
         ABEND 0001,DUMP           ABEND THE STEP
         EJECT
***********************************************************************
*                                                                     *
*        PROCESS A REPLY COMMAND                                      *
*                                                                     *
***********************************************************************
DOCMD2   CLC   COMDATA+4(6),=CL6'REPLY ' SEE IF A REPLY COMMAND
         BNE   DOCMD3              NO, GO SEE IF WAIT COMMAND
***********************************************************************
*                                                                     *
*        PARSE THE REPLY COMMAND                                      *
*                                                                     *
***********************************************************************
         MVC   REPLYWK(72),COMDATA+4   SAVE REPLY COMMAND
         LA    R1,REPLYWK+5        POINT TO START OF REPLY DATA
         LA    R14,72-5            LOAD LENGTH OF REPLY DATA
         MVI   DELIM,C' '          SET DELIMETER TO BLANK
         LA    R2,PARMS            POINT TO PARM TABLE
         SLR   R15,R15             SET PARM COUNT TO ZERO
DOCMD2A  CLC   0(1,R1),DELIM       SEE IF START OF PARM
         BNE   DOCMD2B             NO, BRANCH
         LA    R1,1(,R1)           INCREMENT TO NEXT CHAR OF PARMS
         BCT   R14,DOCMD2A         LOOP
         B     DOCMD2F             END OF PARM, BRANCH
DOCMD2B  CH    R15,=H'3'           SEE IF ALREADY FOUND MAX PARMS
         BNL   DOCMD2F             YES, IGNORE ANY OTHERS
         LA    R15,1(,R15)         ADD 1 TO PARM COUNTER
         CLI   0(R1),C''''         SEE IF QUOTED STRING
         BNE   DOCMD2C             NO, BRANCH
         MVC   DELIM,0(R1)         SET DELIMETER
         LA    R1,1(,R1)           INCREMENT PAST DELIMETER
         BCTR  R14,0               DECREMENT REMAINING CHARACTER COUNT
         LTR   R14,R14             TEST REMAINING CHARACTER COUNT
         BNP   DOCMD2F             DONE, GET OUT
DOCMD2C  ST    R1,0(R2)            SAVE START ADDRESS OF PARM
DOCMD2D  CLC   0(1,R1),DELIM       SEE IF END OF PARM
         BE    DOCMD2E             YES, BRANCH
         LA    R1,1(,R1)           INCREMENT TO NEXT CHAR OF PARMS
         BCT   R14,DOCMD2D         LOOP
DOCMD2E  S     R1,0(R2)            SUBTRACT START ADDR FROM ENDING
         ST    R1,4(R2)            SAVE PARM LENGTH
         A     R1,0(R2)            RESTORE END ADDRESS
         LA    R1,1(,R1)           INCREMENT PAST DELIMETER
         BCTR  R14,0               DECREMENT REMAINING CHARACTER COUNT
         LTR   R14,R14             TEST REMAINING CHARACTER COUNT
         BNP   DOCMD2F             DONE, GET OUT
         MVI   DELIM,C' '          SET DEFAULT DELIMETER
         LA    R2,8(,R2)           INCREMENT TO NEXT PARM POINTER
         B     DOCMD2A             GO PROCESS NEXT PARM
DOCMD2F  CH    R15,=H'3'           SEE IF THREE PARMS
         BE    DOCMD2G             YES, BRANCH
         MVC   COMDATA+4+72(8),=CL8' ERROR01' SET ERROR FLAG
         B     DOCMD2P             GO ECHO THE COMMAND
DOCMD2G  CLC   JOBNL,=F'0'         TEST LENGTH OF THE JOBNAME
         BNZ   DOCMD2H             NOT ZERO, BRANCH
         MVC   COMDATA+4+72(8),=CL8' ERROR02' SET ERROR FLAG
         B     DOCMD2P             GO ECHO THE COMMAND
DOCMD2H  CLC   JOBNL,=F'8'         TEST LENGTH OF THE JOBNAME
         BNH   DOCMD2I             NOT GREATER THAN 8, BRANCH
         MVC   COMDATA+4+72(8),=CL8' ERROR03' SET ERROR FLAG
         B     DOCMD2P             GO ECHO THE COMMAND
***********************************************************************
*                                                                     *
*        GO GET A LIST OF OUTSTANDING REPLIES                         *
*                                                                     *
***********************************************************************
DOCMD2I  L     R1,GETADDR          LOAD ADDRESS OF REPLY TABLE
         CALL  REPLY               CALL THE SUBROUTINE
***********************************************************************
*                                                                     *
*        FIND AN OUTSTANDING REPLY FOR THE SPECIFIED JOBNAME          *
*                                                                     *
***********************************************************************
DOCMD2J  MVC   JOBNAME,=CL8' '     BLANK THE JOBNAME
         L     R14,JOBN            LOAD ADDRESS OF JOBNAME
         L     R15,JOBNL           LOAD LENGTH OF JOBNAME
         BCTR  R15,0               MAKE MACHINE LENGTH
         EX    R15,SETNAME         SET THE FULL JOB NAME
         L     R3,GETADDR          LOAD ADDRESS OF REPLY TABLE
         USING MSGENT,R3           SET ADDRESSABILITY TO REPLY TABLE
DOCMD2K  CLI   0(R3),X'FF'         END OF TABLE, BRANCH
         BNE   DOCMD2L             NO, BRANCH
         MVC   COMDATA+4+72(8),=CL8' ERROR04' SET ERROR FLAG
         B     DOCMD2P             GO ECHO THE COMMAND
DOCMD2L  CLC   JNAME,JOBNAME       SEE IF MATCH ON JOB NAME
         BE    DOCMD2N             YES, BRANCH
DOCMD2M  LA    R3,L'MSGENT(,R3)    INCREMENT TO NEXT REPLY TABLE ENTRY
         B     DOCMD2K             LOOP
***********************************************************************
*                                                                     *
*        SEE IF THIS REPLY CONTAINS THE SPECIFIED TEXT (IF ANY)       *
*                                                                     *
***********************************************************************
DOCMD2N  LA    R14,MSG             POINT TO MESSAGE TEST
         LA    R15,128             LOAD MESSAGE LENGTH
         S     R15,MATCHL          CALCULATE LOOP COUNTER
         L     R1,MATCHL           LOAD LENGTH OF MATCH TEXT
         BCTR  R1,0                MAKE MACHINE LENGTH
         L     R2,MATCH            LOAD ADDRESS OF MATCH TEXT
         CLC   MATCHL,=F'0'        SEE IF LENGTH OF TEXT = 0
         BE    DOCMD2P             YES, USE THIS OUTSTANDING REPLY
         CLC   MATCHL,=F'1'        SEE IF LENGTH OF TEXT = 1
         BH    DOCMD2O             NO, BRANCH
         CLI   0(R2),C'*'          SEE IF NULL MATCH TEXT
         BE    DOCMD2P             YES, USE THIS OUTSTANDING REPLY
DOCMD2O  EX    R1,COMPTEXT         SEE IF MATCH MESSAGE TEXT
         BE    DOCMD2P             YES, BRANCH
         LA    R14,1(,R14)         POINT TO NEXT CHARACTER OF TEXT
         BCT   R15,DOCMD2O         LOOP
         B     DOCMD2M             NO MATCH FOR TEXT, FIND ANOTHER MSG
DOCMD2P  WTO   MF=(E,COMDATA)      ECHO THE COMMAND ON THE CONSOLE
         CLC   COMDATA+4+72(8),=CL8' ' SEE IF ERROR HAS OCCURRED
         BNE   DOCMD6              YES, DROP THIS REPLY COMMAND
         MVI   COMDATA+4,C' '      BLANK THE ENTIRE
         MVC   COMDATA+4+1(79),COMDATA+4  COMMAND AREA
         MVI   COMDATA+4,C'R'      SET REPLY CHARACTER
         MVC   COMDATA+4+2(4),RID  SET REPLY ID          *JAW*
         MVI   COMDATA+4+6,C','    SET THE END OF THE REPLY ID *JAW*
         L     R1,REPLYTX          LOAD ADDRESS OF THE REPLY TEXT
         ICM   R15,B'1111',REPLYTXL LOAD LENGTH OF REPLY TEXT
         BZ    DOCMD5              ZERO, GO ISSUE THE NULL REPLY
         MVI   COMDATA+4+7,C''''   SET START QUOTE FOR REPLY   *JAW*
         BCTR  R15,0               MAKE MACHINE LENGTH
         EX    R15,SETREPLY        SET THE REPLY TEXT
         LA    R15,COMDATA+4+8+1(R15) POINT PAST REPLY         *JAW*
         MVI   0(R15),C''''        SET ENDING QUOTE FOR REPLY
         WTO   MF=(E,COMDATA)      ECHO THE COMMAND ON THE CONSOLE
         B     DOCMD5              GO ISSUE THE REPLY
COMPTEXT CLC   0(0,R14),0(R2)      **** EXECUTE ONLY ****
SETREPLY MVC   COMDATA+4+8(0),0(R1) *** EXECUTE ONLY ****     *JAW*
         DROP  R3                  DROP ADDRESSABILITY TO REPLY TABLE
         EJECT
***********************************************************************
*                                                                     *
*        PROCESS A STOPPED COMMAND                                    *
*                                                                     *
***********************************************************************
DOCMD3   CLC   COMDATA+4(8),=CL8'STOPPED' SEE IF A STOPPED COMMAND
         BNE   DOCMD4              NO, GO SEE IF STARTED COMMAND
         WTO   MF=(E,COMDATA)      ECHO THE COMMAND ON THE CONSOLE
***********************************************************************
*                                                                     *
*        PARSE THE STOPPED COMMAND                                    *
*                                                                     *
***********************************************************************
         MVC   REPLYWK(72),COMDATA+4   SAVE STOPPED COMMAND
         LA    R1,REPLYWK+8        POINT TO START OF STOPPED DATA
         LA    R15,72-8            LOAD LENGTH OF STOPPED DATA
         SLR   R14,R14             SET LENGTH OF JOBNAME TO ZERO
DOCMD3A  CLC   0(1,R1),C' '        SEE IF START OF JOBNAME
         BNE   DOCMD3B             NO, BRANCH
         LA    R1,1(,R1)           INCREMENT TO NEXT CHAR OF PARMS
         BCT   R15,DOCMD3A         LOOP
         B     DOCMD3Z             END OF PARM, NO JOBNAME, BYPASS
DOCMD3B  LR    R14,R1              SAVE START ADDRESS OF JOBNAME
DOCMD3C  CLC   0(1,R1),C' '        SEE IF END OF JOBNAME
         BE    DOCMD3D             YES, BRANCH
         LA    R1,1(,R1)           INCREMENT TO NEXT CHAR OF JOBNAME
         BCT   R15,DOCMD3C         LOOP
DOCMD3D  SR    R1,R14              SUBTRACT START ADDR FROM ENDING
         CH    R1,=H'8'            TEST LENGTH OF THE JOBNAME
         BNH   DOCMD3E             NOT GREATER THAN 8, BRANCH
         LA    R1,8                SET LENGTH TO 8
DOCMD3E  MVC   JOBNAME,=CL8' '     BLANK THE JOBNAME
         BCTR  R1,0                MAKE MACHINE LENGTH
         EX    R1,SETNAME          SET THE FULL JOB NAME
***********************************************************************
*                                                                     *
*        SEE IF THE REQUESTED JOB/TASK IS RUNNING                     *
*                                                                     *
***********************************************************************
DOCMD3F  LA    R1,JOBNAME          POINT TO JOBNAME
         BAL   R14,JOBSRCH         GO SEE IF JOB IS EXECUTING
         LTR   R15,R15             TEST THE RETURN CODE
         BNZ   DOCMD3Z             NOT ZER0, NOT EXECUTING, EXIT
***********************************************************************
*                                                                     *
*        ISSUE THE WTO MESSAGE IF NOT ALREADY ISSUED                  *
*                                                                     *
***********************************************************************
         CLC   WTOMSGID,=XL8'00'   SEE IF MESSAGE ALREADY ISSUED
         BNE   DOCMD3G             YES, GO WAIT A BIT
         MVC   WAITMSG1+4+08(8),MYNAME  MOVE MY JOBNAME TO MESSAGE
         MVC   WAITMSG1+4+29(8),JOBNAME MOVE JOBNAME TO MESSAGE
         WTO   MF=(E,WAITMSG1)     ISSUED THE WTO MESSAGE
         ST    R1,WTOMSGID         SAVE THE WTO MESSAGE ID FOR DOM
***********************************************************************
*                                                                     *
*        WAIT 15 SECONDS AND TRY AGAIN                                *
*                                                                     *
***********************************************************************
DOCMD3G  STIMER WAIT,BINTVL=SEC15  WAIT 15 SECONDS
         B     DOCMD3F             GO SEE IF JOB HAS COMPLETED YET
***********************************************************************
*                                                                     *
*        DELETE THE WTO MESSAGE IF IT HAS BEEN ISSUED                 *
*        AND EXIT                                                     *
*                                                                     *
***********************************************************************
DOCMD3Z  ICM   R1,B'1111',WTOMSGID LOAD WTO MESSAGE ID
         BZ    DOCMD6              ZERO, NO MESSAGE, GET OUT
         DOM   MSG=(1)             DELETE OPERATOR MESSAGE
         XC    WTOMSGID,WTOMSGID   CLEAR THE WTO MESSAGE ID
         B     DOCMD6              GO GET ANOTHER COMMAND
         SPACE 3
WAITMSG1 WTO   'CMD002I ........ WAITING FOR ........ TO COMPLETE',    X
               ROUTCDE=(2,11),DESC=2,MF=L
         EJECT
***********************************************************************
*                                                                     *
*        PROCESS A STARTED COMMAND                                    *
*                                                                     *
***********************************************************************
DOCMD4   CLC   COMDATA+4(8),=CL8'STARTED' SEE IF A STARTED COMMAND
         BNE   DOCMD5              NO, GO ISSUE THE COMMAND
         WTO   MF=(E,COMDATA)      ECHO THE COMMAND ON THE CONSOLE
***********************************************************************
*                                                                     *
*        PARSE THE STARTED COMMAND                                    *
*                                                                     *
***********************************************************************
         MVC   REPLYWK(72),COMDATA+4   SAVE STARTED COMMAND
         LA    R1,REPLYWK+8        POINT TO START OF STARTED DATA
         LA    R15,72-8            LOAD LENGTH OF STARTED DATA
         SLR   R14,R14             SET LENGTH OF JOBNAME TO ZERO
DOCMD4A  CLC   0(1,R1),C' '        SEE IF START OF JOBNAME
         BNE   DOCMD4B             NO, BRANCH
         LA    R1,1(,R1)           INCREMENT TO NEXT CHAR OF PARMS
         BCT   R15,DOCMD4A         LOOP
         B     DOCMD4Z             END OF PARM, NO JOBNAME, BYPASS
DOCMD4B  LR    R14,R1              SAVE START ADDRESS OF JOBNAME
DOCMD4C  CLC   0(1,R1),C' '        SEE IF END OF JOBNAME
         BE    DOCMD4D             YES, BRANCH
         LA    R1,1(,R1)           INCREMENT TO NEXT CHAR OF JOBNAME
         BCT   R15,DOCMD4C         LOOP
DOCMD4D  SR    R1,R14              SUBTRACT START ADDR FROM ENDING
         CH    R1,=H'8'            TEST LENGTH OF THE JOBNAME
         BNH   DOCMD4E             NOT GREATER THAN 8, BRANCH
         LA    R1,8                SET LENGTH TO 8
DOCMD4E  MVC   JOBNAME,=CL8' '     BLANK THE JOBNAME
         BCTR  R1,0                MAKE MACHINE LENGTH
         EX    R1,SETNAME          SET THE FULL JOB NAME
***********************************************************************
*                                                                     *
*        SEE IF THE REQUESTED JOB/TASK IS RUNNING                     *
*                                                                     *
***********************************************************************
DOCMD4F  LA    R1,JOBNAME          POINT TO JOBNAME
         BAL   R14,JOBSRCH         GO SEE IF JOB IS EXECUTING
         LTR   R15,R15             TEST THE RETURN CODE
         BZ    DOCMD4Z             ZER0, EXECUTING, EXIT
***********************************************************************
*                                                                     *
*        ISSUE THE WTO MESSAGE IF NOT ALREADY ISSUED                  *
*                                                                     *
***********************************************************************
         CLC   WTOMSGID,=XL8'00'   SEE IF MESSAGE ALREADY ISSUED
         BNE   DOCMD4G             YES, GO WAIT A BIT
         MVC   WAITMSG2+4+08(8),MYNAME  MOVE MY JOBNAME TO MESSAGE
         MVC   WAITMSG2+4+29(8),JOBNAME MOVE JOBNAME TO MESSAGE
         WTO   MF=(E,WAITMSG2)     ISSUED THE WTO MESSAGE
         ST    R1,WTOMSGID         SAVE THE WTO MESSAGE ID FOR DOM
***********************************************************************
*                                                                     *
*        WAIT 15 SECONDS AND TRY AGAIN                                *
*                                                                     *
***********************************************************************
DOCMD4G  STIMER WAIT,BINTVL=SEC15  WAIT 15 SECONDS
         B     DOCMD4F             GO SEE IF JOB HAS COMPLETED YET
***********************************************************************
*                                                                     *
*        DELETE THE WTO MESSAGE IF IT HAS BEEN ISSUED                 *
*        AND EXIT                                                     *
*                                                                     *
***********************************************************************
DOCMD4Z  ICM   R1,B'1111',WTOMSGID LOAD WTO MESSAGE ID
         BZ    DOCMD6              ZERO, NO MESSAGE, GET OUT
         DOM   MSG=(1)             DELETE OPERATOR MESSAGE
         XC    WTOMSGID,WTOMSGID   CLEAR THE WTO MESSAGE ID
         B     DOCMD6              GO GET ANOTHER COMMAND
         SPACE 3
WAITMSG2 WTO   'CMD003I ........ WAITING FOR ........ TO START',       X
               ROUTCDE=(2,11),DESC=2,MF=L
         EJECT
***********************************************************************
*                                                                     *
*        ISSUE THE COMMAND                                            *
*                                                                     *
***********************************************************************
DOCMD5   SLR   R0,R0               CLEAR REG ZERO
         MODESET KEY=ZERO          GET INTO KEY ZERO
         MGCR  COMDATA             ISSUE THE COMMAND
         WTO   MF=(E,COMDATA)      ECHO THE COMMAND ON THE CONSOLE
         MODESET KEY=NZERO         GET OUT OF KEY ZERO
DOCMD6   BR    R10                 GO GET ANOTHER COMMAND
         SPACE 1
PACKTIME PACK  DOUBLE,COMDATA+10(0) *** EXECUTE ONLY ****
SETNAME  MVC   JOBNAME(0),0(R14)   **** EXECUTE ONLY ****
         EJECT
***********************************************************************
*                                                                     *
*                          J O B S R C H                              *
*                                                                     *
*        SEARCH THE ADDRESS SPACES IN THE SYSTEM TO SEE IF THE        *
*        JOBNAME OR TASK NAME POINTED TO BY REGISTER 1 UPON           *
*        ENTRY TO THIS ROUTINE IS EXECUTING.  THE RETURN CODE         *
*        WILL BE SET AS FOLLOWS:                                      *
*                                                                     *
*        R15 = 0  - THE REQUESTED JOB IS EXECUTING                    *
*        R15 = 4  - THE REQUESTED JOB IS NOT EXECUTING                *
*                                                                     *
*        RETURN IS MADE TO THE ADDRESS IN REGISTER 14 UPON ENTRY.     *
*                                                                     *
***********************************************************************
JOBSRCH  STM   R0,R15,SAVESRCH     SAVE REGISTERS
JOBSRCH1 L     R5,16               LOAD ADDR OF CVT
         USING CVT,R5              SET ADDRESSABILITY TO CVT
         L     R5,CVTASVT          POINT TO ADDRESS SPACE VECTOR TABLE.
         DROP  R5                  DROP ADDRESSABILITY TO CVT
         USING ASVT,R5             SET ADDRESSABILITY TO ASVT
         L     R14,ASVTMAXU        LOAD MAX. NUMBER OF ADDRESS SPACES.
         LA    R5,ASVTENTY         LOAD ADDRESS OF FIRST ASCB POINTER
         DROP  R5                  DROP ADDRESSABILITY TO ASVT
JOBSRCH2 ICM   R6,B'1111',0(R5)    POINT TO ASCB
         BNP   JOBSRCH5            ZERO OR NEGATIVE, BYPASS THIS ONE
         USING ASCB,R6             SET ADDRESSABILITY TO ASCB
         ICM   R15,B'1111',ASCBJBNI LOAD ADDRESS OF JOB NAME
         BZ    JOBSRCH3            ZERO, NOT A BATCH JOB
         MVC   SRCHNAME,0(R15)     SAVE JOB NAME
         B     JOBSRCH4            GO SEE IF REQUESTED JOB/TASK NAME
JOBSRCH3 ICM   R15,B'1111',ASCBJBNS LOAD ADDRESS OF TASK NAME
         MVC   SRCHNAME,0(R15)     SAVE TASK NAME
JOBSRCH4 CLC   SRCHNAME,0(R1)      SEE IF REQUESTED JOB/TASK NAME
         BE    JOBSRCH6            YES, GET OUT
JOBSRCH5 LA    R5,4(R5)            POINT TO NEXT ASCB POINTER.
         BCT   R14,JOBSRCH2        LOOP THROUGH ASCBS
         LA    R15,4               NOT FOUND, SET RETURN CODE TO 4
         B     JOBSRCH7            GO RETURN TO CALLER
JOBSRCH6 LA    R15,0               FOUND, SET RETURN CODE TO 0
JOBSRCH7 LM    R0,R14,SAVESRCH     RESTORE REGISTERS
         BR    R14                 RETURN TO CALLER
         DROP  R6                  DROP ADDRESSABILITY TO ASCB
         EJECT
***********************************************************************
*                                                                     *
*        CONSTANTS AND WORK AREAS.                                    *
*                                                                     *
***********************************************************************
         SPACE 3
         LTORG
         SPACE 3
SAVEAREA DS    18F                 REGISTER SAVE AREA
SAVESRCH DS    16F                 SAVE AREA FOR JOBSRCH ROUTINE
SEC15    DC    A(15*100)           15 SECOND BINARY WAIT INTERVAL
TIOTADDR DS    F                   EXTRACT ANSWER AREA
GETADDR  DS    F                   ADDRESS OF OUTSTANDING REPLY TABLE
REPLYWK  DC    CL80' '             REPLY COMMAND WORK AREA
PARMS    DS    0F                  REPLY PARM PARSE LIST
JOBN     DS    F                   ADDRESS OF JOB NAME
JOBNL    DS    F                   LENGTH OF JOB NAME
MATCH    DS    F                   ADDRESS OF REPLY TEXT TO MATCH
MATCHL   DS    F                   LENGTH OF REPLY TEXT TO MATCH
REPLYTX  DS    F                   ADDRESS OF ACTUAL REPLY TEXT
REPLYTXL DS    F                   LENGTH OF ACTUAL REPLY TEXT
WTOMSGID DC    F'0'                WTO MESSAGE ID FOR DOM PROCESSING
DELIM    DC    C' '                TEXT SCAN DELIMETER
MYNAME   DS    CL8                 NAME OF THIS JOB OR TASK
JOBNAME  DS    CL8                 JOBNAME FOR REPLY SEARCH
SRCHNAME DS    CL8                 JOB/TASK NAME FROM ASCB
COMDATA  DS    0F
         DC    X'00'
         DC    AL1(84)
         DC    X'0000'
         DC    C'123456789 123456789 123456789 123456789 123456789 1234X
               56789 123456789 12        '
DOUBLE   DS    D                   DOUBLE WORK WORK AREA
WAITIME  DS    F                   DELAY TIME IN 1/100 SECONDS
FACILITY DC    CL8'FACILITY'       RACROUTE CLASS NAME
RESOURCE DC    CL44'COMMAND'       RACROUTE RESOURCE NAME
RACROUTE RACROUTE REQUEST=FASTAUTH,MF=L RACROUTE LIST FORM
RACWORK  DS    CL512               RACROUTE WORK AREA 1
FRACWORK DS    16F                 RACROUTE WORK AREA 2
         PRINT NOGEN
IEFRDER  DCB   DDNAME=IEFRDER,DSORG=PS,MACRF=GL,EODAD=EOF
         EJECT
***********************************************************************
*                                                                     *
*                           R E P L Y                                 *
*                                                                     *
*        RETURN A LIST OF THE OUTSTANDING REPLIES IN A TABLE          *
*        POINTED TO BY REGISTER 1 ON ENTRY.  THERE IS ROOM FOR        *
*        100 OUTSTANDING REPLIES IN THE TABLE.  AN ENTRY WHICH        *
*        STARTS WITH X'FF' WILL FLAG THE END OF THE REPLIES.          *
*                                                                     *
*        BECAUSE SOME OF THE STORAGE AREAS ARE ABOVE THE 16           *
*        MEG LINE, THE ROUTINE WILL SWITCH TO AMODE31 IN THE          *
*        BEGINNING AND SWITCH BACK TO AMODE 24 WHEN FINISHED.         *
*                                                                     *
*                                                                     *
*                                                                     *
*        REGISTERS ON ENTRY                                           *
*           R1  - ADDRESS OF THE REPLY TABLE                          *
*           R13 - ADDRESS OF A SAVE AREA                              *
*           R15 - ENTRY POINT ADDRESS                                 *
*                                                                     *
*        REGISTERS ON ENTRY                                           *
*           SAME AS ON ENTRY                                          *
*                                                                     *
***********************************************************************
REPLY    CSECT
         SAVE  (14,12)             SAVE REGISTERS
         LR    R12,R15             INITIALIZE FIRST BASE REGISTER
         USING REPLY,R12           SET PROGRAM ADDRESSABILITY
         LR    R15,R13             SAVE CALLING'S SAVE AREA ADDR
         LA    R13,REPSAVE         LOAD ADDR OF NEW SAVE AREA
         ST    R13,8(R15)          STORE NEW SAVE ADDR IN OLD
         ST    R15,4(R13)          STORE OLD SAVE ADDR IN NEW
         LA    R15,*+10            SET BRANCH ADDRESS
         O     R15,=X'80000000'    SET AMODE31 BIT ON
         BASSM R14,R15             GO TO AMODE 31
***********************************************************************
*                                                                     *
*        FLAG END OF REPLY TABLE                                      *
*                                                                     *
***********************************************************************
         MVI   0(R1),X'FF'         SET END OF TABLE INDICATOR
         ST    R1,TBLADDR          SAVE REPLY TABLE ADDRESS
***********************************************************************
*                                                                     *
*        DETERMINE THE ASID NUMBER OF THE CONSOLE ADDRESS SPACE       *
*                                                                     *
***********************************************************************
REPLY01  L     R4,16               R4 = ADDR OF CVT
         USING CVT,R4              SET ADDRESSABILITY TO CVT
         L     R5,CVTASVT          POINT TO ADDRESS SPACE VECTOR TABLE.
         USING ASVT,R5             SET ADDRESSABILITY TO ASVT
         L     R4,ASVTMAXU         LOAD MAX. NUMBER OF ADDRESS SPACES.
         LA    R2,1                SET ADDRESS SPACE NUMBER TO ONE
         LA    R5,ASVTENTY         LOAD ADDRESS OF FIRST ASCB POINTER
REPLY02  ICM   R6,B'1111',0(R5)    POINT TO ASCB
         BNP   REPLY03             ZERO OR NEGATIVE, BYPASS THIS ONE
         USING ASCB,R6             SET ADDRESSABILITY TO ASCB
         ICM   R15,B'1111',ASCBJBNS LOAD ADDRESS OF JOBNAME FIELD.
         BZ    REPLY03             ZERO, BYPASS THIS ONE
         CLC   0(8,R15),=C'CONSOLE ' IS THIS THE CONSOLE ADDRESS SPACE?
         BE    REPLY04             YES, EXIT FROM LOOP.
REPLY03  LA    R2,1(R2)            ADD 1 TO THE ASID
         LA    R5,4(R5)            POINT TO NEXT ASCB POINTER.
         BCT   R4,REPLY02          LOOP
         B     REPLY13             ERROR, GET OUT
REPLY04  ST    R2,CONSASID         SAVE ASID OF CONSOLE ADDRESS SPACE.
         DROP  R4                  DROP ADDRESSABILITY TO CVT
         DROP  R5                  DROP ADDRESSABILITY TO ASVT
         DROP  R6                  DROP ADDRESSABILITY TO ASCB
         EJECT
***********************************************************************
*                                                                     *
*        SET UP CROSS MEMORY SERVICES                                 *
*                                                                     *
***********************************************************************
REPLY05  L     R10,TBLADDR         GET START OF REPLY TABLE
         USING MSGDSECT,R10        SET ADDRESSABILITY TO REPLY ENTRY
         SLR   R7,R7               SET MESSAGE COUNT TO ZERO
         MODESET MODE=SUP,KEY=ZERO AUTHORIZE OURSELVES
         ESAR  R9                  GET SECONDARY ASID
         ST    R9,SASID            AND SAVE IT
         AXSET AX=ONE              SET AX TO ALLOW SSAR
         L     R9,CONSASID         GET 'CONSOLE' ASID
         SSAR  R9                  SET 'CONSOLE' AS SECONDARY ASID
***********************************************************************
*                                                                     *
*        GET THE CMS LOCK SO THAT THE OUTSTANDING REPLY               *
*        ELEMENT (ORE) CHAIN WILL NOT BE ALTERED DURING               *
*        OUR PROCESSING.                                              *
*                                                                     *
***********************************************************************
REPLY06  AL    R13,=F'12'          CHANGE R13 FOR SETLOCK
         SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,REGS=SAVE
         SETLOCK OBTAIN,TYPE=CMS,MODE=UNCOND,REGS=SAVE
         SL    R13,=F'12'          PUT R13 BACK TO NORMAL
***********************************************************************
*                                                                     *
*          GET THE ADDRESS OF THE FIRST OUTSTANDING REPLY             *
*          ELEMENT (ORE)                                              *
*                                                                     *
***********************************************************************
REPLY07  L     R4,16               R4 = ADDR OF CVT
         USING CVT,R4              SET ADDRESSABILITY TO CVT
         L     R4,CVTCUCB          R4 = ADDR OF 'CUCB' (UCM BASE)
         DROP  R4                  DROP ADDRESSABILITY TO CVT
         USING UCM,R4              SET ADDRESSABILITY TO UCM BASE
         L     R2,UCMRPYQ          LOAD ADDRESS OF FIRST ORE
         LTR   R2,R2               TEST ORE ADDRESS
         BZ    REPLY12             ZERO, NO OUTSTANDING REPLIES
         DROP  R4                  DROP ADDRESSABILITY TO UCM BASE
         USING OREF,R2             SET ADDRESSABILITY TO ORE
***********************************************************************
*                                                                     *
*          COPY THE WTO QUEUE ELEMENT (WQE) FROM THE CONSOLE          *
*          ADDRESS SPACE FOR THE CURRENT ORE                          *
*                                                                     *
***********************************************************************
REPLY08  L     R8,ORERWQE          R8 = ADDR OF WQE
         LA    R4,WQECOPY          R4 = ADDR OF COPY OF WQE
         LA    R5,WQESIZE          R5 = SET LENGTH OF WQE
         SLR   R15,R15             SET 'FROM' KEY TO ZERO
REPLY09  MVCP  0(R5,R4),0(R8),R15  MOVE UP TO 256 BYTES
         BZ    REPLY10             CC=0 - DONE
         LA    R4,256(,R4)         INCREMENT 'TO' ADDRESS
         LA    R8,256(,R8)         INCREMENT 'FROM' ADDRESS
         SH    R5,=H'256'          SUBTRACT LENGTH OF LAST MOVE
         B     REPLY09             GO GET REST OF AREA
REPLY10  LA    R4,WQECOPY          RESTORE ADDRESS OF COPY OF WQE
         USING WQE,R4              SET ADDRESSABILITY TO WQE
***********************************************************************
*                                                                     *
*          SAVE THE REPLY JOBNAME, MSGID, AND ACTUAL MESSAGE          *
*          FROM THE WQE                                               *
*                                                                     *
***********************************************************************
REPLY11  MVI   MSGENT,C' '         BLANK THE ENTIRE
         MVC   MSGENT+1(L'MSGENT-1),MSGENT   MESSAGE AREA
         MVC   JNAME,WQEOJBNM      SAVE JOB NAME
         ST    R7,SAVEREG          USE R7 TEMP             *JAW*
         L     R7,WQERPYIB         GET THE SYSPLEX ID      *JAW*
         CVD   R7,DWORD            CONVERT ID TO DECIMAL   *JAW*
         UNPK  RID,DWORD           CONVERT ID TO ZONED DEC *JAW*
         OI    RID+3,X'F0'         GET RID OF SIGN BIT     *JAW*
         L     R7,SAVEREG          RETURN PREIOUS VALUE    *JAW*
*        MVC   RID,WQERPYIB        SAVE REPLY ID           *JAW*
         MVC   MSG,WQETXT          SAVE MESSAGE TEXT
         LA    R10,L'MSGENT(,R10)  INCREMENT TO NEXT MESSAGE AREA
         MVI   0(R10),X'FF'        SET END OF TABLE INDICATOR
         LA    R7,1(,R7)           ADD 1 TO MESSAGE COUNT
         CH    R7,=H'100'          SEE IF REACHED MAXIMUM
         BNL   REPLY12             YES, GET OUT
         L     R2,ORELKP           LOAD ADDRESS OF NEXT ORE
         LTR   R2,R2               SEE IF ANY MORE ORE'S
         BNZ   REPLY08             YES, LOOP
         DROP  R2                  DROP ADDRESSABILITY TO ORE
         DROP  R4                  DROP ADDRESSABILITY TO WQE
         DROP  R10                 DROP ADDRESSABILITY TO REPLY TABLE
***********************************************************************
*                                                                     *
*        FREE THE CMS LOCK SO THAT NORMAL CONSOLE MESSAGE             *
*        PROCESSING CAN CONTINUE                                      *
*                                                                     *
***********************************************************************
REPLY12  AL    R13,=F'12'          CHANGE R13 FOR SETLOCK
         SETLOCK RELEASE,TYPE=CMS,REGS=SAVE
         SETLOCK RELEASE,TYPE=LOCAL,REGS=SAVE
         SL    R13,=F'12'          PUT R13 BACK TO NORMAL
***********************************************************************
*                                                                     *
*        GET OUT OF CROSS MEMORY MODE                                 *
*                                                                     *
***********************************************************************
         L     R9,SASID            RESTORE PREVIOUS SECONDARY ASID
         SSAR  R9                  SHOULD BE SAME AS PRIMARY
         AXSET AX=ZERO             SET AUTHORIZATION INDEX BACK TO ZERO
         MODESET MODE=PROB,KEY=NZERO UNAUTHORIZE OURSELVES
***********************************************************************
*                                                                     *
*        RETURN TO THE CALLER                                         *
*                                                                     *
***********************************************************************
         SPACE 3
REPLY13  LA    R15,*+6             SET BRANCH ADDRESS
         BASSM R14,R15             GO TO AMODE 24
         L     R13,4(R13)          RESTORE ORIG SAVE AREA ADDRESS
         RETURN (14,12)            RETURN TO CALLER
         EJECT
***********************************************************************
*                                                                     *
*                         C O N S T A N T S                           *
*                                                                     *
***********************************************************************
         LTORG
REPSAVE  DS    18F                 PROGRAM SAVE AREA
CONSASID DC    F'0'                ASID OF CONSOLE ADDRESS SPACE
TBLADDR  DS    F                   ADDRESS OF REPLY TABLE
SASID    DS    F                   SAVE PREVIOUS SECONDARY ASID
ONE      DC    H'1'                TO SET AX 1
ZERO     DC    H'0'                TO SET AX 0
         DS    0F
WQECOPY  DS    CL512               LOCAL COPY OF WQE
         EJECT
MSGDSECT DSECT
MSGENT   DS    0CL138
JNAME    DS    CL8
RID      DS    CL4
DWORD    DS    D            *JAW*
SAVEREG  DS    F            *JAW*
MSG      DS    CL128
         EJECT
         CVT   DSECT=YES
         EJECT
         IEECUCM DSECT=YES,FORMAT=NEW,LIST=YES
         EJECT
         IHAASVT DSECT=YES
         EJECT
         IHAASCB DSECT=YES
         EJECT
         IHAORE DSECT=YES
         EJECT
         IHAWQE DSECT=YES,FORMAT=OLD
         EJECT
         IHAPSA DSECT=YES,LIST=YES
         EJECT
TIOT     DSECT
         IEFTIOT1
         END
