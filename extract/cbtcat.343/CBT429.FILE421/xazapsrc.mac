  TITLE 'INCORZAP  --  MAIN STORAGE SUPERZAP FOR MVS/XA AND MVS/370'
***********************************************************************
*                                                                     *
*     'INCORZAP' PROGRAM                                              *
*                                                                     *
*         MAIN STORAGE SUPERZAP PROGRAM FOR BOTH MVS/370 AND MVS/XA.  *
*                                                                     *
*         NOTE:  THIS SOURCE PROGRAM USES MVS/XA MACROS AND MUST BE   *
*                ASSEMBLED USING AN MVS/XA MACLIB.                    *
*                                                                     *
***********************************************************************
*
*      -- MODULE HISTORY:
*
*         1974 - ORIGINAL WRITTEN BY R. BUDGE, IBM CORP.
*         IN PL/S LANGUAGE.
*
*         1979-81 - ASSEMBLER SOURCE GENERATED AND COMMENTED BY
*         BILL GODFREY, PRC (PLANNING RESEARCH CORPORATION), MCLEAN VA,
*         ALSO MADE PARM FIELD INPUT INDEPENDENT OF ENTRY POINT NAME.
*
*         1983 - XA AND SP1.3 CHANGES ADDED, ALONG WITH ADDITIONAL
*         COMMENTS BY R. BUDGE, NAS CORP.
*                                                             12/90 JEB
*         1990 - CHANGED HARD CODED LOAD (SVC 8) TO STANDARD  12/90 JEB
*         MACRO FORM TO SUPPORT LSEARCH=YES SO THAT LPA       12/90 JEB
*         MODULES WILL LOAD WHEN 'LOCAL' IS SPECIFIED.        12/90 JEB
*         THIS CHANGED WORKED ON BOTH SP1.3.5 AND XA2.2.0     12/90 JEB
*         JOHN E. BRYANT, COMPUSOURCE, CARY NC                12/90 JEB
*                                                             12/90 JEB
*
*      -- COMPLETE DOCUMENTATION IS IN A SEPARATE FILE.
*
*      -- BRIEF DOCUMENTATION.
*
*          THIS PROGRAM MODIFIES LOAD MODULES IN THE NUCLEUS OR
*          IN THE LINK PACK AREA.  MODIFIED PAGES IN LPA WILL BE
*          FIXED TO PREVENT PAGE-INS THAT WOULD UN-MODIFY THE
*          MODIFIED PAGE.  CONTROL STATEMENT INPUT IS COMPATIBLE
*          WITH THE 'AMASPZAP' SERVICE AID PROGRAM, EXCEPT THE
*          PRESENCE OF A SLASH ('/') ANYWHERE IN A CARD IS USED
*          AS AN INDICATION OF MULTIPLE STATEMENTS PER CARD.
*          A 'RES' IS LIKE A 'REP' EXCEPT IT FREES A FIXED LPA PAGE.
*
*          DDNAMES USED:
*           SYSPRINT - MESSAGE AND DUMP OUTPUT.
*           SYSLIB   - SYS1.LPALIB FOR LPA ZAPS,
*                      SYS1.NUCLEUS FOR NUCLEUS ZAPS.
*                      OPENED FOR UPDATE, BUT NOT ACTUALLY UPDATED.
*           SYSIN    - CONTROL STATEMENT INPUT.
*
*           IF DDNAMES PROGLIST, PROGLIB, AND PROGIN ARE PRESENT,
*           THEY WILL BE USED INSTEAD OF THE OTHERS.
*
*          CONTROL STATEMENTS MAY OPTIONALLY BE SPECIFIED IN
*          THE PARM FIELD INSTEAD OF SYSIN.
*
*          'VER' 'REP' AND 'RES' COMMANDS MAY USE PROGRAM LABELS
*          INSTEAD OF HEX OFFSETS IF DESIRED.  ANY ENTRY POINT
*          MAY BE USED AS A LABEL. OTHER LABELS CAN BE USED ONLY
*          IF PROGRAM IS COMPILED AND LINKED WITH THE 'TEST'
*          ATTRIBUTE.  (DOES NOT APPLY NUCLEUS MODULES IN MVS/XA.
*          TELL INCORZAP YOU ARE USING A LABEL INSTEAD
*          OF A HEX OFFSET BY ENCLOSING IT IN SINGLE QUOTES.
*
*          THE PROGRAM MUST BE LINK-EDITED AS AUTHORIZED IN ORDER
*          TO MODIFY STORAGE, BUT OTHER FUNCTIONS WILL WORK EVEN
*          IF IT IS NOT AUTHORIZED.
*-------------------------------------------------------------------*
         EJECT
INCORZAP CSECT
INCORZAP AMODE 24
INCORZAP RMODE 24
         SPLEVEL SET=1
         B     START-*(,R15)
         DC    AL1(16)
         DC    C'INCORZAP  &SYSDATE '
START    STM   R14,R12,12(R13)
         BALR  R12,R0              BASE REGISTER
         USING *,R12
         USING *+4095,R6
         LA    R6,4095(,R12)       BASE REGISTER
         LA    R12,0(,R12)         CLEAR BAL STUFF FOR 31-BIT
         L     R0,SIZE
         GETMAIN R,LV=(0)
         LR    R10,R1              WORKAREA BASE
         USING @DATA,R10
         LA    R5,4095(,R10)       WORKAREA BASE
         USING @DATA+4095,R5
         ST    R13,4(,R10)         PUT OLD ADDRESS IN NEW SAVEAREA
         LM    R0,R1,20(R13)       RESTORE R0 AND R1
         ST    R10,8(,R13)         PUT NEW ADDRESS IN OLD SAVEAREA
         LR    R13,R10             SWITCH TO NEW SAVEAREA
         MVC   @PARMPTR,0(R1)      SAVE ADDRESS OF PARM FIELD
         BAL   R14,INIT            INITIALIZE
         EJECT
*
*   MAINLINE ROUTINE
*
*               DO WHILE XFEOD=0
*                  CALL GETREC
*                  IF XFEOD=0 THEN
*                     CALL PRINTREC
*                     CALL VERBSCN
*                     END
*                  END
*               CLOSE FILES
*               RETURN
*
         SPACE
         B     DOTEST01
DOLOOP01 BAL   R14,GETREC          GET A LOGICAL RECORD
         TM    XFLAGS,XFEOD
         BNZ   DOTEST01
         MVI   @LINE+2,C' '
         MVC   @LINE+3(118),@LINE+2
         L     R14,XFLDSTRT        POINT TO DATA TO BE MOVED
         L     R11,XENDREC         GET ADDRESS OF END OF DATA
         SLR   R11,R14             COMPUTE LENGTH
         EX    R11,LOGMVC          MOVE R14 TO @LINE01
         OI    @SWB,XFNOWTO        FOR PRINT BUT NOT FOR XFCON
         BAL   R14,PUTLINE         LOG THE STATEMENT
         NI    @SWB,255-XFNOWTO
         BAL   R14,VERBSCN
DOTEST01 TM    XFLAGS,XFEOD
         BZ    DOLOOP01
         MVC   XDCBCLS(12),CLOSE
*        CLOSE (XDCBL,,XDCBIN,,XDCBO),MF=(E,XDCBCLS)
         LA    R1,XDCBCLS
         IC    R14,0(R1)
         LA    R0,XDCBL
         ST    R0,0(R1)
         STC   R14,0(R1)
         IC    R14,4(R1)
         LA    R0,XDCBIN
         ST    R0,4(R1)
         STC   R14,4(R1)
         IC    R14,8(R1)
         LA    R0,XDCBO
         ST    R0,8(R1)
         STC   R14,8(R1)
         SVC   20                  CLOSE
         L     R11,XCODE           SAVE RC ACROSS FREEMAIN
         L     R13,4(,R13)         SWITCH TO OLD SAVEAREA
         L     R0,SIZE             LENGTH FOR FREEMAIN
         LR    R1,R10              ADDRESS FOR FREEMAIN
         FREEMAIN R,LV=(0),A=(1)
         LR    R15,R11             RETURN CODE
         L     R14,12(,R13)
         LM    R0,R12,20(R13)
         BR    R14                 EXIT PROGRAM
         EJECT
*
*   ROUTINE TO DUMP MAIN STORAGE
*
*        INPUT: XCSADDR=ADDRESS OF CSECT TO BE DUMPED
*               XCSLEN = LENGTH TO DUMP
*
         SPACE
DUMP     STM   R14,R12,@SAVE13
         L     R14,XCSLEN          IS
         LA    R14,0(,R14)          AN
         LTR   R14,R14               ENDING ADDRESS SPECIFIED
         BNZ   A00012A             YES, BRANCH
         MVC   XCSLEN+1(3),ONE+1
A00012A  L     R14,MINUS032        FFFFFFE0
         L     R11,XCSADDR         GET STARTING ADDRESS
         L     R7,XCSLEN           GET LENGTH
         LA    R7,0(,R7)
         ALR   R7,R11              ADD TO START ADDRESS
         BCTR  R7,R0
         NR    R7,R14              ROUND DOWN TO MULTIPLE OF 32
         ST    R7,XDUMPEND         SAVE DUMP END ADDRESS
         OI    @SWB,XFNOWTO        DON'T DUMP TO CONSOLE
         MVI   @LINE02,C' '
         MVC   @LINE03(118),@LINE02
         MVI   @LINE01,C' '
         MVC   XHEXL,FOUR
         NR    R11,R14             ROUND DOWN TO MULTIPLE OF 32
         ST    R11,XDP             DUMP START ADDRESS
         B     DUMPGO
DUMPLP   LA    R14,@LINE01
         ST    R14,XEBAD
         LA    R14,XDP
         ST    R14,XHEX
         BAL   R14,HEXCV           PUT HEX ADDRESS IN LINE
         L     R14,XDP
         ST    R14,XHEX
         LA    R14,1
         ST    R14,I               SET SUBSCRIPT TO 1
DUMPLLP  MH    R14,H9              ADD SUBSCRIPT*9
         LA    R14,@LINE03(14)      TO LINE+3
         ST    R14,XEBAD           SAVE RESULT IN HEX TO ADDRESS
         BAL   R14,HEXCV           PERFORM HEX CONVERSION
         L     R14,XHEX          ADD
         AL    R14,XHEXL          HEXLEN
         ST    R14,XHEX            TO HEXFR
         LA    R14,1               ADD 1
         AL    R14,I                TO
         ST    R14,I                 SUBSCRIPT
         C     R14,FOUR            IS SUBSCRIPT GT 4
         BNH   DUMPLLP             NO, LOOP (LEFT HALF OF PAGE)
         SPACE
         LA    R14,1               YES,
         ST    R14,I                RESET SUBSCRIPT TO 1
DUMPRLP  MH    R14,H9
         LA    R14,@LINE41(14)
         ST    R14,XEBAD
         BAL   R14,HEXCV
         L     R14,XHEX
         AL    R14,XHEXL
         ST    R14,XHEX
         LA    R14,1
         AL    R14,I
         ST    R14,I
         C     R14,FOUR            IS SUBSCRIPT GT 4
         BNH   DUMPRLP             NO, LOOP (RIGHT HALF OF PAGE)
         SPACE
         MVI   @LINE87,C'*'
         MVI   @LIN120,C'*'
         BAL   R14,MODESET1        GET INTO KEY 0
         BAL   R14,BIT31           GET INTO 31-BIT MODE
         L     R14,XDP
         MVC   @LINE88(32),0(R14)  MOVE IN CHAR PORTION
         BAL   R14,BIT24           GET BACK TO 24-BIT MODE
         BAL   R14,MODESET2        GET BACK TO USER KEY
         TR    @LINE88(32),EBCDIC
         BAL   R14,PUTLINE
         LA    R11,32              ADD 32
         AL    R11,XDP              TO
         ST    R11,XDP               DUMP ADDRESS
DUMPGO   C     R11,XDUMPEND
         BNH   DUMPLP
         NI    @SWB,255-XFNOWTO
         LM    R14,R12,@SAVE13
         BR    R14
         EJECT
*
*   FIND MODULE ON PROGRAM LIBRARY
*
         SPACE
FIND     STM   R14,R12,@SAVE14
         LA    R1,XDCBL
         LA    R0,XEBLM
         LCR   R1,R1
         SVC   18                  FIND
         LTR   R15,R15             WAS MEMBER FOUND
         BZ    FINDOK              YES, BRANCH
         LA    R14,MSG08           MEMBER NOT FOUND IN LIBRARY
         ST    R14,XMSE
         BAL   R14,GENERR
         B     FINDX
FINDOK   EQU   *
FINDX    LM    R14,R12,@SAVE14
         BR    R14
         EJECT
*
*   PGFIX/FREE ROUTINE
*
*        INPUT:
*              XZADDR = ADDR OF STORAGE TO BE CHANGED
*              XHL = LENGTH OF STORAGE
*              XEBV = VERB
*
         SPACE
FIXER    STM   R14,R12,@SAVE16
         L     R14,16              CVT ADDRESS
         TM    XFLAGS,XFLOCSW
         BNZ   PAGEX
         CLC   XEBLM(6),IEANUC     IS THIS A NUCLEUS ZAP
         BE    PAGEX               YES, NO NEED TO FIX/FREE
         BAL   R14,MODESET1        SUP STATE, KEY ZERO
         AL    R13,TWELVE          CHANGE R13 FOR SETLOCK
         SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,REGS=SAVE,RELATED=X
         SLR   R4,R4               NO TCB - PGFIX NOT TO BE OWNED
         SLR   R14,R14             CLEAR
         ST    R14,XPECB           THE ECB
         LA    R0,XPECB            ECB ADDRESS
         L     R14,XZADDR          GET STARTING ADDRESS
         LR    R1,R14              STARTING ADDRESS
         AL    R14,XHL             COMPUTE ENDING ADDRESS
         LR    R2,R14              ENDING ADDRESS+1
         BCTR  R14,0               ENDING ADDRESS
         CLC   XEBV(3),RESET       IS THIS A RES
         BE    FREEPG              YES, FREE THE PAGE
         L     15,16
         TM    CVTDCB-CVT(R15),CVTMVSE IS THIS MVS/XA
         BZ    PASTFIX1            NO, SKIP XA PGFIX
FIXPAGE  PGSER R,FIX,A=(1),EA=(R14),TCB=0,ECB=(0),LONG=Y,BRANCH=Y, XXXXX
               RELATED=FREEPAGE
         B     SVPSRC
PASTFIX1 EQU   *
         O     R1,PGFIX            NO, FIX THE PAGE
         B     MVS370BR            SKIP OVER FREE
*
FREEPG   EQU   *
         L     R15,16
         TM    CVTDCB-CVT(R15),CVTMVSE IS THIS MVS/XA
         BZ    PASTFRE1
FREEPAGE PGSER R,FREE,A=(1),EA=(R14),TCB=0,BRANCH=Y,RELATED=FIXPAGE
         B     SVPSRC
*
PASTFRE1 EQU   *
         O     R1,PGFREE           FREE THE PAGE
MVS370BR EQU   *
         L     R11,16              CVT ADDRESS
         L     R15,804(,R11)       CVTVPSIB - PAGE SERVICES
         BALR  R14,R15             CALL PAGE SERVICES
SVPSRC   EQU   *
         ST    R15,XPSRC           SAVE RETURN CODE
         SETLOCK RELEASE,TYPE=LOCAL,REGS=SAVE,RELATED=X
         SL    R13,TWELVE          PUT R13 BACK TO NORMAL
         BAL   R14,MODESET2        PROB STATE, KEY NZERO
         CLC   XPSRC,EIGHT         DID PAGE SERVICES RETURN AN 8
         BNE   PAGEX               NO, NO NEED TO WAIT
         WAIT  ECB=XPECB
PAGEX    LM    R14,R12,@SAVE16
         BR    R14
         EJECT
*
*   GENERAL ERROR ROUTINE
*
*        INPUT:  XMSE = ADDR OF MESSAGE LIST
*
         SPACE
GENERR   STM   R14,R12,@SAVE15
         MVI   @LINE02,C' '
         MVC   @LINE03(118),@LINE02
         L     R14,XMSE            GET ADDRESS OF MESSAGE
         L     R11,0(,R14)         GET LENGTH OF MESSAGE
         BCTR  R11,R0              LENGTH MINUS 1 FOR EX
         EX    R11,PUTMSGM         MOVE R14+4 TO @LINE01
         BAL   R14,PUTLINE         WRITE THE MESSAGE
         MVC   XCODE,TWELVE        SET RETURN CODE
         OI    XFLAGS,XFEOD        XFEOD
         LM    R14,R12,@SAVE15
         BR    R14
         EJECT
*
*    FIELD FETCHING ROUTINE
*
*        INPUT:
*              XRCVADDR = ADDR OF RECEIVING FIELD
*              XRCVLEN = LENGTH OF RECEIVING FIELD
*        OUTPUT:
*              XFLDALEN = ACTUAL LENGTH OF FETCHED FIELD
*                  (BLANKS ARE RETURNED IF NO FIELD IS FOUND)
*
         SPACE
GETFLD   STM   R14,R12,@SAVE19
         L     R14,XFLDSTRT
         ST    R14,XFLDCUR         SET CURRENT = STARTING
         SLR   R14,R14             SET
         ST    R14,XSCANSW         SW = 0
*
*   SCAN PAST LEADING DELIMITERS
*
         B     PARGO1              DO UNTIL SW NE 0
PARLP1   CLC   XFLDCUR,XENDREC     STILL WITHIN STATEMENT
         BNH   PARIN1              YES, BRANCH
*                                  IS BEYOND END OF STMT
         LA    R14,1               SET
         ST    R14,XSCANSW         SW = 1
         B     PARGO1
PARIN1   L     R14,XFLDCUR
         CLI   0(R14),C' '         BLANK
         BE    PARNX1
         CLI   0(R14),X'7D'        QUOTE
         BNE   PARFN1
PARNX1   LA    R14,1               QUOTE OR BLANK
         AL    R14,XFLDCUR         POINT TO
         ST    R14,XFLDCUR          NEXT CHARACTER
         B     PARGO1
*                                  NEITHER QUOTE NOR BLANK
*                                  SET TO EXIT LOOP
PARFN1   LA    R14,1               SET
         ST    R14,XSCANSW          SW = 1
PARGO1   SLR   R14,R14
         C     R14,XSCANSW
         BE    PARLP1              END OF DO LOOP (SKIPPING LEADING
*                                  DELIMITERS
*
*   SCAN FOR END OF FIELD
*
         L     R11,XFLDCUR         GET TRUE START OF FIELD
         ST    R11,XFLDSTRT
         ST    R14,XSCANSW         SET SW = 0
         B     PARGO2              DO UNTIL SW NE 0
PARLP2   CLC   XFLDCUR,XENDREC     STILL WITHIN STATEMENT
         BNH   PARIN2              YES, BRANCH
         LA    R14,1               SET
         ST    R14,XSCANSW          SW = 1
         B     PARGO2
PARIN2   LA    R14,1               POINT XFLDCUR TO
         AL    R14,XFLDCUR          NEXT
         ST    R14,XFLDCUR           CHARACTER
         CLI   0(R14),C' '         BLANK
         BE    PARFN2
         CLI   0(R14),X'7D'        QUOTE
         BNE   PARGO2
PARFN2   LA    R14,1               SET
         ST    R14,XSCANSW          SW = 1
PARGO2   L     R14,XSCANSW
         LTR   R14,R14
         BZ    PARLP2              END OF DO LOOP (FOUND END)
*
*   CALCULATE LENGTH AND CHECK FOR A TOO LONG FIELD
*
         L     R14,XFLDCUR         GET ADDRESS OF BLANK OR QUOTE
         SL    R14,XFLDSTRT        COMPUTE LENGTH
         ST    R14,XFLDALEN        SAVE LENGTH
         C     R14,XRCVLEN         WILL IT FIT IN RESULT
         BNH   PAROKL              YES, BRANCH
         LA    R14,MSG01           FIELD IS TOO LONG
         ST    R14,XMSE
         BAL   R14,SYNERR          SYNTAX ERROR
         B     PARMOV              GO TRUNCATE MOVE
*
*   MOVE IN FETCHED FIELD (IF ANY)
*
PAROKL   L     R14,XRCVADDR        GET ADDRESS OF GETFLD RESULT
         L     R11,XRCVLEN
         BCTR  R11,R0
         EX    R11,PARBLNK         MOVE BLANKS TO GETFLD RESULT
PARMOV   L     R14,XFLDALEN        IF LENGTH
         LTR   R14,R14              GREATER THAN
         BZ    PARNUL                ZERO
         L     R11,XRCVADDR        GET ADDRESS OF GETFLD RESULT
         BCTR  R14,R0
         L     R7,XFLDSTRT
         EX    R14,PARMVC          MOVE R7 TO R11
PARNUL   L     R14,XFLDCUR         GET ADDR OF TRAILING DELIMITER
         ST    R14,XFLDSTRT        READY FOR NEXT CALL
         CLI   0(R14),X'7D'        QUOTE
         BNE   PARX                BRANCH IF NOT QUOTED
         AL    R14,ONE             POINT BEYOND QUOTE
         ST    R14,XFLDSTRT
PARX     LM    R14,R12,@SAVE19
         BR    R14                 RETURN
         EJECT
*
*   HEXADECIMAL FIELD FETCHING ROUTINE
*
*        INPUT:
*              XFLDSTRT = ADDR OF START OF FIELD
*        OUTPUT:
*              XHS = HEX STRING
*              XHSL = LENGTH OF HEX STRING
*
GETHEX   STM   R14,R12,@SAVE21
         SLR   R14,R14
         ST    R14,XHSW         SET SW = 0
         ST    R14,XHL          SET LEN = 0
         L     R14,XFLDSTRT
         ST    R14,XHP
*
*   MOVE FIELD TO 'XHW' AND STRIP OUT COMMAS
*
         B     HPAGO1           DO UNTIL XHSW NE 0
HPALP1   CLC   XHP,XENDREC      STILL WITHIN STATEMENT
         BNH   HPAIN1           YES, BRANCH
         MVC   XHSW,ONE
         B     HPAGO1
HPAIN1   L     R14,XHP
         CLI   0(R14),C' '      IS IT A BLANK
         BNE   A0004DC          NO, BRANCH
         L     R14,XHL
         LTR   R14,R14
         BNP   A0004CC
         MVC   XHSW,ONE
         B     HPAGO1
A0004CC  LA    R14,1
         AL    R14,XHP
         ST    R14,XHP
         B     HPAGO1
*                                  NOT A BLANK
A0004DC  L     R14,XHP
         CLI   0(R14),X'6B'        IS IT A COMMA
         BE    HPAINCR             YES, GO IGNORE IT
         LA    R11,1               ADD 1
         AL    R11,XHL              TO
         ST    R11,XHL               MODLEN
         LA    R7,XHW-1(R11)
         MVC   0(1,R7),0(R14)      COPY THE CHARACTER TO WORK AREA
HPAINCR  LA    R14,1               POINT
         AL    R14,XHP              TO
         ST    R14,XHP               NEXT CHARACTER
HPAGO1   SLR   R14,R14
         C     R14,XHSW
         BE    HPALP1
*
*   CHECK FOR MISSING FIELD
*
         L     R11,XHP
         ST    R11,XFLDSTRT
         C     R14,XHL             IS LENGTH ZERO
         BNE   HPAOK1              NO, BRANCH
         LA    R14,MSG11           REQUIRED FIELD MISSING
         ST    R14,XMSE
         BAL   R14,SYNERR          SYNTAX
         B     HPAX
*
*   CHECK FOR INVALID (NON-HEX) CHARACTERS
*
HPAOK1   SLR   R2,R2
         L     R1,XHL
         BCTR  R1,R0
         EX    R1,HPRTRT           TRT WORK AREA
         LTR   R2,R2               ARE ALL CHARACTERS HEX
         BZ    HPAOK2              YES, BRANCH
         LA    R14,MSG03           INVALID HEX CHARACTER
         ST    R14,XMSE
         BAL   R14,SYNERR          SYNTAX
         B     HPAX
*
*   TRANSLATE FROM EBCDIC TO HEXADECIMAL
*
HPAOK2   TR    XHW,HEXTR-193       TRANSLATE TO 'UNPACKED' HEX
         LA    R14,XHS
         ST    R14,XHSPTR
         LA    R14,XHW             SET
         ST    R14,XHWPTR           PTR = ADDR(WORK AREA)
         B     HPAGO2              DO WHILE PTR LE ADDR(WRK AREA)+LEN
HPALP2   L     R14,XHWPTR
         PACK  XHPW,0(16,R14)      PACK 16 BYTES AT A TIME
         L     R11,XHSPTR
         MVO   0(9,R11),XHPW SHIFT TO GET RID OF SIGN
         AL    R11,EIGHT           ADD 8 TO
         ST    R11,XHSPTR           HEX RESULT ADDRESS
         AL    R14,SIXTEEN         ADD 16 TO
         ST    R14,XHWPTR           PTR
HPAGO2   L     R14,XHL
         LA    R11,XHW
         ALR   R11,R14
         C     R11,XHWPTR
         BH    HPALP2              END OF DO LOOP
*
*   CHECK FOR EVEN NUMBER OF HEX DIGITS
*
         ST    R14,Y
         LR    R2,R14              PREPARE TO DIVIDE
         SRDA  R2,32               PREPARE TO DIVIDE
         D     R2,TWO              HALVE THE LENGTH
         ST    R3,XHL              SAVE LENGTH
         ALR   R3,R3               DOUBLE IT
         CR    R14,R3              AND COMPARE TO ORIGINAL
         BE    HPAX                IF EQUAL, THERE WERE AN EVEN NUMBER
         LA    R14,MSG12           UNEVEN NUMBER OF HEX DIGITS
         ST    R14,XMSE
         BAL   R14,SYNERR          SYNTAX
HPAX     LM    R14,R12,@SAVE21
         BR    R14
HPRTRT   TRT   XHW(1),HEXTRT     (EXECUTED)
         B     HPAX
         EJECT
*
*   GET OFFSET ROUTINE
*
*        INPUT:
*              XFLDSTRT
*        OUTPUT:
*              XZADDR = IN-CORE ADDR CORRESPONDING TO OFFSET
*
GETOFF   STM   R14,R12,@SAVE08
         SLR   R14,R14
         ST    R14,XGOS
         MVI   XGOC,C' '
*
*   SCAN FOR 1ST CHAR OF OFFSET
*
         B     BASGO1
BASLP1   L     R14,XFLDSTRT
         C     R14,XENDREC
         BNH   BASOK1
         ST    R14,XGOS
         B     BASGO1
BASOK1   L     R14,XFLDSTRT
         CLI   0(R14),C' '
         BNE   BASOK2
         AL    R14,ONE
         ST    R14,XFLDSTRT
         B     BASGO1
BASOK2   L     R14,XFLDSTRT
         MVC   XGOC,0(R14)
         ST    R14,XGOS
BASGO1   L     R14,XGOS
         LTR   R14,R14
         BZ    BASLP1
*
*   CHECK FIRST CHARACTER TO DETERMINE TYPE OF OFFSET (HEX OR LBL)
*
         CLI   XGOC,X'7D'          QUOTE (LABEL OFFSET)
         BE    BASQOT              YES, BRANCH
*
*   PROCESS A HEXADECIMAL OFFSET
*
         BAL   R14,GETHEX          GET HEX OFFSET
         L     R14,XHL
         C     R14,FOUR
         BNH   BASOK3
         LA    R14,MSG02           OFFSET FIELD IS TOO LONG
         ST    R14,XMSE
         BAL   R14,SYNERR          SYNTAX
         B     BASX
BASOK3   L     R14,XHL
         SLR   R11,R11
         CR    R14,R11             IS XHL ZERO
         BE    BASNUL              YES, BRANCH
         ST    R11,XHOP            LEADING ZEROES
         LCR   R14,R14             1,2,3, OR 4 BECOME -1,-2,-3,-4
         AL    R14,FIVE            BECOME +4 +3 +2 +1
         LA    R11,XHOP-1(R14)
         LCR   R14,R14             BECOME -4 -3 -2 -1
         AL    R14,FOUR            BECOME 0 1 2 3 LENGTH CODE
         EX    R14,A001638         MOVE REPDATA TO R11
         CLC   XEBV(3),LITBAS      IS THIS A BASE STATEMENT
         BNE   BASINN              NO, ITS A VER OR REP, BRANCH
         L     R14,XHOP
         ST    R14,XBASE           STORE BASE VALUE
         B     BASX
BASINN   L     R14,XCSADDR         GET ADDRESS OF CSECT
         AL    R14,XHOP            ADD OFFSET
         SL    R14,XBASE           SUBTRACT VALUE FROM 'BASE' VERB
         ST    R14,XZADDR          SAVE THIS AS ADDRESS TO ZAP
BASNUL   B     BASX                GO EXIT
*
*   PROCESS A SYMBOLIC (LABEL) OFFSET
*
BASQOT   MVI   XEBLBL+1,C' '
         MVC   XEBLBL+2(6),XEBLBL+1
         MVI   XEBLBL,C' '
         LA    R14,XEBLBL
         ST    R14,XRCVADDR
         MVC   XRCVLEN,EIGHT
         BAL   R14,GETFLD         GO GET LABEL
         CLC   XEBLBL(8),BLANKS
         BE    BASMISS
         BAL   R14,SCANMOD        GO SCAN MOD FOR VALUE OF LABEL
         L     R14,XLMADDR        GET ADDRESS OF MODULE
         AL    R14,XOFFSET        ADD OFFSET TO CSECT
         ST    R14,XZADDR         STORE ADDR TO ZAP
         ST    R14,XLOC
         TM    XFLAGS,XFEOD
         BNZ   BASX               BR IF NOT EOD
         BAL   R14,PRADDR         GO PRINT ADDRESS
         B     BASX               GO EXIT
BASMISS  LA    R14,MSG11          REQUIRED FIELD MISSING
         ST    R14,XMSE
         BAL   R14,SYNERR         SYNTAX
BASX     LM    R14,R12,@SAVE08
         BR    R14
         EJECT
*
*   RECORD FETCHING ROUTINE
*
         SPACE
GETREC   STM   R14,R12,@SAVE10
         TM    XFLAGS,XFCON       ARE WE IN CONSOLE MODE
         BNO   GETSIN             NO, BRANCH
*
*   CONSOLE INPUT SECTION
*
         BAL   R14,GLREC          TRY TO GET A LOGICAL RECORD
         B     GETCGO1            DO WHILE LOGICAL REC NOT GOTTEN
*                                 (USE WTOR TO GET ANOTHER PHYS REC)
GETCLP1  SLR   R14,R14
         ST    R14,XWECB          CLEAR ECB
         MVI   XREPLY+1,C' '      CLEAR WTO AREA
         MVC   XREPLY+2(128),XREPLY+1
         MVI   XREPLY,C' '
         LA    R1,XWTOR
         LA    R15,XREPLY
         ST    R15,0(R1)
         MVI   0(R1),130           LENGTH OF REPLY
         LA    R14,XWECB
         ST    R14,4(R1)
         SVC   35                          WTOR
         LA    R0,1
         LA    R1,XWECB
         SVC   1                           WAIT
         TR    XREPLY(130),EBCDIC  TRANSLATE TO UPPER CASE
         LA    R14,XREPLY
         LR    R11,R14
         BCTR  R11,R0
         ST    R11,XENDREC         SET END OF LAST LOGICAL
*                                  REC TO BEGINNING OF REPLY AREA - 1
         SL    R14,MINUS129
         ST    R14,XPENDREC        SET END OF PHYSICAL RECORD
         BAL   R14,GLREC           NOW EXTRACT A LOGICAL REC
GETCGO1  CLC   XENDREC,XPENDREC
         BH    GETCLP1             END OF DO LOOP
         B     GETCX
*
*   PROCESS PARM FIELD INPUT
*
GETSIN   TM    XFLAGS,XFMAIN       IS THERE PARM FIELD INPUT
         BNZ   GETCSYIN            NO, BRANCH
         CLC   XENDREC,XPENDREC    MORE IN PARM
         BL    GETCPARM            YES, BRANCH
         OI    XFLAGS,XFEOD        XFEOD
         B     GETCX
GETCPARM BAL   R14,GLREC           EXTRACT LOGICAL REC FROM PARM
         B     GETCX
*
*   INPUT IS FROM SYSIN DD
*
GETCSYIN BAL   R14,GLREC           TRY TO GET A LOGICAL RECORD
         B     GETCGO2             DO WHILE NO LOGICAL REC GOTTEN
GETCLP2  EQU   *
         GET   XDCBIN,XCARD        READ A PHYSICAL RECORD
         LA    R14,XCARD
         LR    R11,R14
         BCTR  R11,R0
         ST    R11,XENDREC         POINT TO BYTE PRECEDING COL 1
         SL    R14,=F'-71'         POINT TO COLUMN 72
         ST    R14,XPENDREC        THIS IS END OF PHYSICAL RECORD
         BAL   R14,GLREC           NOW GO GET LOGICAL RECORD
GETCGO2  CLC   XENDREC,XPENDREC    IS THERE MORE PHYS REC LEFT
         BH    GETCLP2             BR IF NOT
*
GETCX    LM    R14,R12,@SAVE10
         BR    R14
*
*   END-OF-DATA (EODAD) FOR SYSIN
*
CTLEOD   OI    XFLAGS,XFEOD          XFEOD
         B     GETCX
         EJECT
*
*    LOGICAL RECORD EXTRACTION ROUTINE (CALLED BY 'GETREC')
*
         SPACE
GLREC    STM   R14,R12,12(R13)
         L     R14,XENDREC
         C     R14,XPENDREC
         BH    SEPX
         AL    R14,ONE             ADD 1 TO
         ST    R14,XENDREC          END POINTER
         ST    R14,XFLDSTRT        INITIALIZE GETFLD BEGIN ADDRESS
         SLR   R14,R14             SET
         ST    R14,XPS              SW = 0
         B     SEPGO1              DO UNTIL SW NE 0
SEPLP1   CLC   XENDREC,XPENDREC
         BL    SEPOK1
         LA    R14,1               SET
         ST    R14,XPS              SW = 1
         B     SEPGO1
SEPOK1   L     R14,XENDREC
         CLI   0(R14),C'/'         MULTIPLE STATEMENTS PER CARD
         BNE   SEPNXT              NO
         MVI   0(R14),C' '         YES, CHANGE SLASH TO BLANK
         LA    R14,1               SET
         ST    R14,XPS              SW = 1
         B     SEPGO1
SEPNXT   LA    R14,1               ADD 1
         AL    R14,XENDREC          TO
         ST    R14,XENDREC           END POINTER
SEPGO1   L     R14,XPS
         LTR   R14,R14
         BZ    SEPLP1
SEPX     LM    R14,R12,12(R13)
         BR    R14
         EJECT
*
*   HEX TO EBCDIC CONVERSION ROUTINE
*
*        INPUT:
*              XHEX = ADDR OF HEX DATA TO BE CONVERTED
*              XHEXL = LENGTH OF HEX DATA
*              XEBAD = ADDR OF TARGET AREA TO RECEIVE EBCDIC DATA
*
         SPACE
HEXCV    STM   R14,R12,12(R13)
         BAL   R14,MODESET1          GET INTO KEY 0
         LA    R14,1                 SET UP LOOP VARIABLE
         B     HEXCT
HEXLP    L     R11,XEBAD             GET ADDR OF TARGET EBCDIC AREA
         L     R7,XHEX               GET ADDR OF 'FROM' FIELD
         ALR   R7,R14
         BCTR  R7,R0                 POINT AT CURRENT CHARACTER
*
         LR    R4,R14                SAVE LOOP COUNTER
         BAL   R14,BIT31             GET 31-BIT MODE IF XA
         MVC   1(1,R11),0(R7)        MOVE CHARACTER TO TARGET AREA
         BAL   R14,BIT24             GET BACK TO 24-BIT MODE
         LR    R14,R4
*
         UNPK  0(1,R11),1(1,R11)     GET FIRST NIBBLE INTO NEXT BYTE
         NC    0(2,R11),HEX0F0F      STRIP ZONE BITS
         TR    0(2,R11),HEXTAB       TRANSLATE INTO EBCDIC
         AL    R11,TWO               BUMP TARGET CHAR POINTER
         ST    R11,XEBAD
         AL    R14,ONE               INCREMENT LOOP COUNTER
HEXCT    ST    R14,XX
         C     R14,XHEXL             ARE THERE MORE CHAR'S TO CONVERT
         BNH   HEXLP
         BAL   R14,MODESET2          GET BACK TO USER KEY
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
*
*   HOUSEKEEPING ROUTINE (PERFORMS PROGRAM INITIALIZATION)
*
         SPACE
INIT     STM   R14,R12,@SAVE09
         MVI   XWTO+127,C' '
         MVC   XWTO+128(16),XWTO+127
         MVC   XWTO(127),BLINE
         MVC   XWTOR,WTORM
         XC    XDCBCLS(12),XDCBCLS
         XC    XHW,XHW
         SLR   R14,R14
         ST    R14,XCODE
         XC    XFLAGS(2),XFLAGS
         L     R14,16              CVTPTR
         L     R14,0(,R14)         CVTTCBP
         L     R14,4(,R14)         CURRENT TCB
         L     R14,0(,R14)         TCBRBP
*        L     R14,12(,R14)        RBCDE                          .***.
*        CLC   8(8,R14),LINKZAP    CDNAME LINKZAP                 .***.
*        BE    INIT1               YES, NO CONTROL XFMAIN         .***.
         L     R14,@PARMPTR        PARM FIELD                     .PRC.
         LH    R14,0(,R14)         LENGTH OF PARM                 .PRC.
         LTR   R14,R14             IS THERE A PARM                .PRC.
         BNZ   INIT1               YES, NO CONTROL XFMAIN         .PRC.
         OI    XFLAGS,XFMAIN         CONTROL XFMAIN
INIT1    LA    R14,PRTDEF
         ST    R14,XDDN
         LA    R14,XDCBO
         ST    R14,XDCBA
         BAL   R14,OPEN            OPEN PRT
         LTR   R15,R15             WAS OPEN SUCCESSFUL
         BNZ   INIT2
         OI    XFLAGS,XFOOP          PRT IS OPEN
INIT2    LA    R14,LIBDEF
         ST    R14,XDDN
         LA    R14,XDCBL
         ST    R14,XDCBA
         BAL   R14,OPEN            OPEN LIB
         LTR   R15,R15
         BZ    INIT3
         LA    R14,MSG07           DD STATEMENT FOR LIBRARY NOT FOUND
         ST    R14,XMSE
         BAL   R14,GENERR
         B     INITX
INIT3    TM    XFLAGS,XFMAIN       IS INPUT FROM PARM FIELD
         BNO   INITPARM            YES, GO GET PARM FIELD
         LA    R14,CTLDEF
         ST    R14,XDDN
         LA    R14,XDCBIN
         ST    R14,XDCBA
         BAL   R14,OPEN            OPEN SYSIN
         LTR   R15,R15
         BZ    INIT4
         LA    R14,MSG06           INPUT DD STATEMENT NOT FOUND
         ST    R14,XMSE
         BAL   R14,GENERR
         B     INITX
INIT4    L     R14,XPENDREC
         ST    R14,XENDREC
         B     INITX
INITPARM LA    R14,@PARMCPY
         BCTR  R14,R0
         ST    R14,XENDREC
         L     R11,@PARMPTR
         LH    R7,0(,R11)          GET LENGTH OF PARM
         ALR   R14,R7              GET ADDRESS OF LAST CHAR IN PARM
         ST    R14,XPENDREC         SAVE IT
         LTR   R7,R7               IS THERE A PARM
         BNP   INITX               NO, BRANCH
         BCTR  R7,R0               LENGTH MINUS 1 FOR EX
         EX    R7,PARMMVC          MOVE PARM TO PARMCPY
INITX    LM    R14,R12,@SAVE09
         BR    R14
         EJECT
*
*   ROUTINE TO OPEN FILES
*
         SPACE
OPEN     STM   R14,R12,@SAVE24
         L     R14,XDCBA
         L     R11,XDDN
         L     R7,0(,R11)
         MVC   0(100,R14),0(R7)            MOVE DCB PROTOTYPE
         LR    R1,R11
         LA    R1,8(,R1)                   PRIMARY DDNAME
*        DEVTYPE (1),XCARD
         LA    R0,XCARD
         SVC   24                          DEVTYPE
         LTR   R15,R15                     IS DDNAME PRESENT
         BNZ   A000A02                     NO, BRANCH
         L     R14,XDCBA
         L     R11,XDDN
         MVC   40(8,R14),8(R11)            USE PRIMARY DDNAME
         B     A000A10
A000A02  L     R14,XDCBA
         L     R11,XDDN
         MVC   40(8,R14),16(R11)           USE SECONDARY DDNAME
A000A10  L     R14,XDDN
         L     R14,4(,R14)         POINT TO OPEN MF=L IMAGE
         L     R11,XDCBA
         ICM   R7,15,0(R14)        LOAD OPEN MF=L IMAGE
         OR    R11,R7              OR IMAGE OVER R11
         ST    R11,XDCBA           STORE COMBINED IMAGE IN OPEN MF=L
         LA    R1,XDCBA
*        OPEN
         SVC   19                  OPEN
         L     R14,XDCBA
         TM    48(R14),X'10'       WAS OPEN SUCCESSFUL
         BNO   OPENRC4             NO, BRANCH
         SLR   R14,R14
         ST    R14,XOCODE
         B     OPENRET
OPENRC4  MVC   XOCODE,FOUR
OPENRET  L     R15,XOCODE
         L     R14,@SAVE24
         LM    R0,R12,@SAVE24+8
         BR    R14
         EJECT
*
*   PRINT ADDRESS OF SYMBOL (CSECT, LABEL, ETC.)
*
*        INPUT:
*              XLOC = FOUR-BYTE ADDRESS TO BE DISPLAYED
*
PRADDR   STM   R14,R12,@SAVE23
         MVI   @LINE47,C' '
         MVC   @LINE48(73),@LINE47
         MVC   @LINE01(46),WHEREMSG
         LA    R14,XLOC
         ST    R14,XHEX            ADDR OF WHERE HEX IS COMING FROM
         MVC   XHEXL,FOUR
         LA    R14,@LINE01
         ST    R14,XEBAD           ADDR WHERE WE WANT EBCDIC ADDR
         BAL   R14,HEXCV           CONVERT HEX ADDR TO EBCDIC
         BAL   R14,PUTLINE         GO PRINT IT OUT
         LM    R14,R12,@SAVE23
         BR    R14
         EJECT
*
*   OUTPUT RECORD PRINTING ROUTINE
*
         SPACE
PUTLINE  STM   R14,R12,@SAVE11
         TM    XFLAGS,XFOOP                  PRT OPEN
         BNO   A000ACE
         TM    @SWB,XF1ST
         BNZ   A000ABC
         OI    @SWB,XF1ST
         PUT   XDCBO,HEADING
         MVI   @LINE,C'0'
         B     A000AC0
A000ABC  MVI   @LINE,C' '
A000AC0  EQU   *
         PUT   XDCBO,@LINE
A000ACE  TM    XFLAGS,XFCON
         BNO   A000AEA
         TM    @SWB,XFNOWTO        FOR PRINT ONLY
         BNZ   A000AEA             YES, BYPASS WTO
         MVC   XWTO+4(120),@LINE01
         WTO   MF=(E,XWTO)
A000AEA  LM    R14,R12,@SAVE11
         BR    R14
         EJECT
*
*   READ RECORD FROM LIBRARY
*
         SPACE
READLIB  STM   R14,R12,@SAVE25
         READ  @DECB,SF,XDCBL,XLREC,248,MF=E
         SPACE
         CHECK @DECB
         SPACE
         LM    R14,R12,@SAVE25
         BR    R14
         EJECT
*
*   SCAN LPA/JPA LOOKING FOR LOAD MODULE
*
*        INPUT:
*              XEBLM = NAME OF LOAD MODULE
*        OUTPUT:
*              XLMADDR = ADDR OF LOAD MODULE
*
SCANLPA  STM   R14,R12,@SAVE26
         TM    XFLAGS,XFLOCSW      IS IT LOCAL MODE
         BNZ   A000B4E             YES, GO LOOK IN JPA
         L     R8,16               CVT ADDRESS
         LA    R8,188(,R8)         CVTQLPAQ
         B     A000B64
A000B4E  L     R14,16              CVT ADDRESS
         L     R14,0(,R14)
         L     R14,4(,R14)
         L     R8,124(,R14)        TCBJSTCB
         LA    R14,44(,R8)         TCBJPQ - LAST CDE
         LR    R8,R14
A000B64  LA    R9,XEBLM
         LR    R4,R9
         SL    R4,FORTY8
         L     R7,16               CVT ADDRESS
         L     R15,184(,R7)        CVTQCDSR - CDE SEARCH RTN
         BALR  R14,R15             STD LINKAGE
*                                  (RETURNS AT +4 IF NAME NOT FOUND)
         LA    R0,0                INDICATE NAME WAS FOUND
         LTR   R0,R0
         BNZ   A000BD6             BR IF NAME NOT FOUND
         TM    28(R11),X'04'       IS THIS A MINOR CDE
         BZ    GETEXTL             NO, SKIP OBTAINING MAJOR CDE
         L     R11,20(,R11)        GET ADDR OF MAJOR CDE
GETEXTL  L     R14,20(,R11)        GET ADDR OF EXTENT LIST
         L     R7,12(,R14)         GET ADDR OF LOAD MOD
         ST    R7,XLMADDR          ADDRESS OF MODULE
         L     R7,XCSLEN
         LA    R7,0(,R7)
         LTR   R7,R7               IS CSECT LENGTH CURRENTLY 0
         BNZ   A000BD2             NO, SKIP
         MVC   XCSLEN+1(3),9(R14)  USE LOAD MODULE LENGTH
A000BD2  B     A000BDC
A000BD6  SLR   R14,R14
         ST    R14,XLMADDR         INDICATE NO CDE FOUND
*
*   SCAN LPA DIRECTORY (LPDE'S)
*
A000BDC  L     R14,XLMADDR
         LTR   R14,R14
         BNZ   A000C68             BRANCH IF MODULE ALREADY FOUND
         TM    XFLAGS,XFLOCSW
         BNZ   A000C68             BR IF LOCAL MODE (SKIP SEARCH)
         L     R14,16              CVT ADDRESS
         TM    116(R14),X'01'      CVTDCB - MVS BIT ON
         BNO   A000C68
         SLR   R0,R0               SET
         BCTR  R0,R0                R0 NEGATIVE
         L     R1,360(,R14)        CVTLPDIR - LPA DIRECTORY
         LA    R1,0(,R1)
         B     LOCATGO1            DO WHILE R0 NEGATIVE
LOCATLP1 CLC   8(8,R1),XEBLM
         BNE   A000C4E
         TM    28(R1),X'04'        ALIAS
         BNO   A000C32             NO
         MVC   XEBLM,32(R1)        YES, GET REAL NAME AND START OVER
         L     R14,16              CVT ADDRESS
         L     R1,360(,R14)        CVTLPDIR - LPA DIRECTORY
         LA    R1,0(,R1)
         B     LOCATINC
A000C32  L     R0,36(,R1)          SET R0 TO MODULE ADDRESS
         L     R14,XCSLEN
         LA    R14,0(,R14)
         LTR   R14,R14             IS THERE A CSECT LENGTH YET
         BNZ   LOCATINC            YES, BRANCH
         MVC   XCSLEN+1(3),33(R1)  USE LOAD MOD LEN AS CSECT LEN
         B     LOCATINC
A000C4E  CLC   8(8,R1),FFFFFFFF    HAVE WE LOOKED AT ALL LPDE'S
         BNE   LOCATINC            NO, BRANCH
         SLR   R0,R0               END OF DIRECTORY, SET R0 NON NEG
LOCATINC AL    R1,FORTY            POINT AT NEXT LPDE
LOCATGO1 LTR   R0,R0
         BM    LOCATLP1
         ST    R0,XLMADDR          SAVE LOCATION OF MODULE
A000C68  L     R14,XLMADDR
         LTR   R14,R14             WAS END OF DIRECTORY HIT
         BNZ   SCANLPAX            NO, BRANCH
         LA    R14,MSG04           MODULE NOT FOUND IN MAIN STORAGE
         ST    R14,XMSE
         BAL   R14,GENERR
SCANLPAX LM    R14,R12,@SAVE26
         BR    R14
         EJECT
*
*   ROUTINE TO CONTROL SCANNING OF A MODULE FOR A DESIRED LABEL
*
*        INPUT:
*              XEBLM = LOAD MODULE TO SCAN
*              XEBLBL = CESD LABEL WHOSE OFFSET IS TO BE RETURNED
*              XEBCS = CSECT WHEREIN THE LABEL RESIDES
*                      (BLANK MEANS FIRST CSECT)
*        OUTPUT:
*              XOFFSET = OFFSET IN LOAD MODULE TO LABEL
*              XCSLEN = LENGTH OF SPECIFIED CSECT
*
SCANMOD  STM   R14,R12,@SAVE22
         BAL   R14,FIND           GO FIND MODULE ON LIBRARY
         TM    XFLAGS,XFEOD
         BNZ   SCMEXIT
         SLR   R14,R14
         BCTR  R14,R0
         ST    R14,XOFFSET        SHOW LABEL REMAINS TO BE FOUND
         ST    R14,XSYMOFF        SHOW SYMBOL REMAINS TO BE FOUND
         SLR   R14,R14
         ST    R14,XCESDN
*
*   PERFORM SPECIAL PROCESSING FOR THE NUCLEUS LOAD MODULE
*
         CLC   XEBLM(6),IEANUC
         BNE   A000CB8
         L     R14,16             GET CVT ADDR
         TM    CVTDCB-CVT(R14),CVTMVSE IS THIS XA
         BZ    PASTXANC           NO, SKIP XA CODE
         BAL   R14,BIT31          GET INTO 31-BIT MODE
         CLC   XEBCS,=C'IEAVFX00' IS THIS PSA CSECT
         BNE   PASTCS0            NO, SKIP
         SR    R2,R2              CLEAR REGISTER
         ST    R2,XLMADDR         ADDR IS ZERO
         B     PASTLKU1           SKIP LOOKUP STUFF
*
PASTCS0  EQU   *
         NUCLKUP BYNAME,NAME='IEAVBK00',ADDR=(R2)  ADDR OF 1ST CSECT
         LA    R2,0(,R2)          CLEAR HI-ORDER BIT
         ST    R2,XLMADDR         SAVE AS ADDR OF LOAD MOD
PASTLKU1 EQU   *
         NUCLKUP BYNAME,NAME=XEBLBL,ADDR=(R3)  GET ADDR OF LABEL
         LTR   R15,R15
         BNZ   LBLNTFND           BR IF LABEL NOT FOUND
         LA    R3,0(,R3)          CLEAR HI-ORDER BIT
         SLR   R3,R2              GET OFFSET INTO NUC LOAD MOD
         ST    R3,XOFFSET         SAVE THIS OFFSET
         NUCLKUP BYNAME,NAME=XEBCS,ADDR=(R3)  GET LENGTH OF CSECT
         LTR   R15,R15
         BNZ   LBLNTFND           BR IF LABEL NOT FOUND
         ST    R1,XCSLEN          SAVE CSECT LENGTH
         BAL   R14,BIT24          GET BACK TO 24-BIT MODE
         B     SCMEXIT            EXIT THIS ROUTINE
PASTXANC EQU   *
         OI    XFLAGS,XFSKIP1     SKIP 1ST CESD (IEAVNIP0)
         B     A000CBC
A000CB8  NI    XFLAGS,255-XFSKIP1
*
*   CLEAR THE CSECT DESCRIPTOR ARRAY
*
A000CBC  SLR   R14,R14
         ST    R14,XSDCNT
         LA    R14,1
         ST    R14,@ESDSUB
A000CCA  LR    R11,R14
         MH    R11,FIVE+2
         LA    R7,XSDNO(R11)
         XC    1(4,R7),1(R7)
         MVI   0(R7),X'00'
         AL    R14,ONE
         ST    R14,@ESDSUB
         C     R14,F400
         BNH   A000CCA
*
*   READ AND PROCESS CESD RECORDS
*
         SLR   R14,R14
         ST    R14,XCRSW         CLEAR LOOP SWITCH
         B     A000DF0
A000CF8  BAL   R14,READLIB
         CLI   XLREC,C' '        SYM RECORD
         BNE   A000D08           NO, BRANCH
         BAL   R14,SYMCHK        GO PROCESS SYM RECORD
A000D08  CLI   XLREC,X'20'       CESD RECORD
         BE    A000D1C           YES, BRANCH
         LA    R14,1
         ST    R14,XCRSW
*
*   SCAN CESD ENTRIES ON CESD RECORD
*
         B     A000DF0
A000D1C  LH    R2,XLREC+6        GET LENGTH OF ESD DATA
         SRDA  R2,32
         D     R2,SIXTEEN        GET NUMBER OF ENTRIES
         ST    R3,XNUMCESD
*
         LA    R14,1             START WITH ENTRY NUMBER 1
         B     ESDGO
A000D34  LA    R14,1
         AL    R14,XCESDN
         ST    R14,XCESDN
         TM    XFLAGS,XFSKIP1
         BNO   A000D50
         NI    XFLAGS,255-XFSKIP1
         B     ESDINCR
A000D50  L     R14,@ESDSUB
         SLA   R14,4             MULTIPLY BY 16
         LA    R11,XLREC(14)     ACTUALLY XLREC+16-16
         TM    0(R11),X'0F'      IS IT AN SD
         BZ    GOTSD             YES, BRANCH
         LA    R11,XLREC(14)
         TM    0(R11),X'03'      COULD IT BE AN LR
         BNO   ESDINCR           NO, BRANCH
         TM    0(R11),X'0C'      MAYBE, IS IT AN LR
         BNZ   ESDINCR           NO, BRANCH
GOTSD    L     R14,@ESDSUB
         ST    R14,XCESDX        SET INDEX TO CESD ENTRY
         BAL   R14,SECTMAP       USE THIS CESD TO MAP LOAD MODULE
         L     R14,@ESDSUB
         SLA   R14,4
         LA    R11,XLREC-8(14)   ACTUALLY BUFFER+8-16
         CLC   0(8,R11),XEBLBL   IS THIS THE RIGHT LABEL
         BNE   A000DA6           NO, BRANCH
         L     R14,XLREC(14)     ACTUALLY BUFFER+16-16
         LA    R14,0(,R14)       ZERO HI ORDER BYTE OF ADDRESS
         ST    R14,XOFFSET       SAVE CSECT ADDRESS
A000DA6  L     R14,@ESDSUB
         SLA   R14,4
         LA    R11,XLREC(14)     ACTUALLY BUFFER+8-16
         TM    0(R11),X'0F'      IS THIS AN SD
         BNZ   ESDINCR           NO, BRANCH
         LA    R11,XLREC-8(14)
         CLC   0(8,R11),XEBCS    IS THIS THE REQUESTED CSECT
         BNE   ESDINCR           NO, BRANCH
         L     R14,XLREC(14)     ACTUALLY BUFFER+16-16
         LA    R14,0(,R14)       ZERO HI ORDER BYTE OF ADDRESS
         ST    R14,XCSDADR       SAVE CSECT ADDRESS
         L     R14,XSDX
         ST    R14,XCSECNO
ESDINCR  LA    R14,1             ADD 1 TO
         AL    R14,@ESDSUB       ESD SUBSCRIPT
ESDGO    ST    R14,@ESDSUB
         C     R14,XNUMCESD      HAS SUBSCRIPT HIT SIZE YET
         BNH   A000D34           NO, BRANCH
*
*   CHECK FOR SUCCESSFUL SCAN
*
A000DF0  SLR   R14,R14
         C     R14,XCRSW
         BE    A000CF8
         CLC   XEBCS,BLANKS
         BNE   A000E0E           IF NO CSECT SPECIFIED
         MVC   XCSECNO,ONE       USE THE FIRST CSECT
         ST    R14,XCSDADR       AND RELATIVE ADDRESS IS 0
A000E0E  L     R14,XSYMOFF
         LTR   R14,R14           WAS LABEL FOUND IN A SYM REC
         BM    A000E20           NO, BR
         AL    R14,XCSDADR       GET POSITION WITHIN LOAD MOD
         ST    R14,XOFFSET       STORE SYM OFFSET + CSECT ADDR
A000E20  SLR   R14,R14
         C     R14,XSDCNT        WAS AT LEAST ONE CSECT FOUND
         BNL   LBLNTFND          BR IF NO
         L     R11,XCSECNO
         CR    R11,R14           WAS OWNING CSECT FOUND
         BNH   LBLNTFND          BR IF NO
         C     R14,XOFFSET       WAS DESIRED LABEL FOUND
         BH    LBLNTFND          BR IF NO
         MH    R11,FIVE+2
         LA    R7,XSDLEN(R11)
         MVC   XCSLEN+1(3),0(R7) MOVE IN CSECT LENGTH
*
*   SCATTER LOAD PROCESSING FOR NUCLEUS
*
*        GO THROUGH TABLE ADDING UP LENGTH OF EACH CSECT
*        (ROUNDED UP TO NEAREST DOUBLE WORD) PREVIOUS
*        TO DESIRED CSECT.
*
         CLC   XEBLM(6),IEANUC
         BNE   A000E9E
         ST    R14,XACCUM        CLEAR ACCUMULATED LENGTH
         LA    R14,1             SET CSECT COUNTER
         B     A000E8E           GO DO LOOP TEST
A000E60  L     R11,XACCUM        GET ACCUMULATED LENGTH
         ST    R11,XSMCSD        SAVE IT
         LR    R7,R14            GET CSECT NUMBER
         MH    R7,FIVE+2         GET OFFSET INTO TABLE
         SR    R4,R4             CLEAR REG.
         LA    R7,XSDLEN(R7)     POINT AT CSECT LENGTH
         ICM   R4,X'7',0(R7)     LOAD CSECT LENGTH
         LA    R4,7(,R4)         ADD IN ROUNDUP VALUE
         N     R4,MINUS008       GET DBL WORD ROUNDED UP VALUE
         ST    R4,XWORK
         ALR   R11,R4            ADD TO ACCUMULATED VALUE
         ST    R11,XACCUM
         AL    R14,ONE           INCREMENT CSECT COUNTER
A000E8E  ST    R14,@ESDSUB
         C     R14,XCSECNO       ALL PREV CSECTS PROCESSED
         BNH   A000E60           NO, BRANCH
         B     A000EA6
*
*   NON-SCATTER-LOAD PROCESSING
*
A000E9E  L     R14,XCSDADR
         ST    R14,XSMCSD          DISK ADDR IS SAME AS IN-CORE
A000EA6  L     R14,XOFFSET
         SL    R14,XCSDADR         GET OFFSET WITHIN CSECT
         ST    R14,XOFFSET
         AL    R14,XSMCSD          GET OFFSET WITHIN LOAD MOD
         ST    R14,XOFFSET
         B     SCMEXIT
*
LBLNTFND EQU   *
         BAL   R14,BIT24           BE SURE WE ARE IN 24 BIT MODE
         LA    R14,MSG09           SYMBOL NOT FOUND IN LOAD MODULE
         ST    R14,XMSE
         BAL   R14,GENERR
SCMEXIT  LM    R14,R12,@SAVE22
         BR    R14
         EJECT
*
*   CSECT MAPPING ROUTINE
*
*        INPUT:
*              XCESDX = INDEX INTO ARRAY OF CESD ENTRIES IN A CESD REC
*              XCESDN = CESD NO. OF CURRENT CESD ENTRY
*              CESD = A CESD RECORD
*              XEBLM = LOAD MODULE NAME
*        OUTPUT:
*              XSDNO = ARRAY OF CESD NO.S FRO CSECTS (SD'S) IN LD MOD
*              XSDLEN = ARRAY OF CSECT LENGTHS
*              XSDCNT = COUNT OF CSECTS IN LOAD MODULE (THUS FAR)
*              XSDX = FOR A SD ENTRY, THE RELATIVE CSECT NUMBER
*                     WITHIN THE IN-CORE VERSION OF THE LOAD MODULE
*
SECTMAP  STM   R14,R12,12(R13)
         L     R14,XCESDX          GET ESD SUBSCRIPT
         SLA   R14,4               MULTIPLY BY 16
         LA    R11,XLREC(14)       POINT TO ESD ENTRY + 8
         TM    0(R11),X'03'        IS IT AN LR
         BNO   A000F70             NO, BRANCH
         TM    0(R11),X'0C'        IS IT AN LR
         BNZ   A000F70             NO, BRANCH
*
*   IF CESD ENTRY IS A LABEL REFERENCE (ENTRY POINT) CHECK FOR
*   SCATTER LOADING (IE. NUCLEUS). SINCE THE SCATTER-LOADED
*   NUCLEUS IS LOADED AS CESD ENTRIES (SD'S OR LR'S) OCCUR IN THE
*   CESD RECORDS, ADD THE CESD NUMBER OF THE LABEL'S CSECT TO
*   THE SD (CSECT) ARRAY
*
         CLC   XEBLM(6),IEANUC   IS THIS A NUCLEUS ZAP
         BNE   A000F70             NO, BRANCH
         MVC   XSDX,ONE
         B     A000F46
A000F04  L     R14,XSDX
         L     R11,XSDCNT
         CR    R14,R11
         BNH   A000F3A
         AL    R11,ONE
         ST    R11,XSDCNT
         MH    R14,FIVE+2
         L     R11,XCESDX
         SLA   R11,4
         LH    R11,XLREC+6(R11)
         N     R11,X000FFFF
         LA    R7,XSDNO(14)
         STCM  R11,3,0(R7)
         B     A000F46
A000F3A  LA    R14,1
         AL    R14,XSDX
         ST    R14,XSDX
A000F46  L     R14,XSDX
         MH    R14,FIVE+2
         L     R11,XCESDX
         SLA   R11,4
         LH    R11,XLREC+6(R11)
         N     R11,X000FFFF
         LA    R7,XSDNO(14)
         ICM   R14,12,0(R7)
         SRA   R14,16
         CR    R11,R14
         BNE   A000F04
*
*   IF CESD ENTRY IS A SECTION DEFINITION (SD OR CSECT), ADD THE
*   CESD NO. FOR THE CSECT TO THE ARRAY.  IF LOAD MOD IS THE NUCLEUS
*   CHECK FIRST THAT AN ENTRY MIGHT ALREADY BE IN THE ARRAY FOR
*   THIS CESD NO. FROM AN EARLIER 'LR' ENTRY.  ONCE THE PROPER
*   CESD ENTRY HAS BEEN FOUND OR ADDED TO THE ARRAY, PUT IN THE
*   LENGTH OF THIS CSECT.
*
A000F70  L     R14,XCESDX          GET ESD SUBSCRIPT
         SLA   R14,4               MULTIPLY BY 16
         LA    R11,XLREC(14)       POINT TO ESD ENTRY + 8
         TM    0(R11),X'0F'        IS IT AN SD
         BNZ   A00102C             NO, BRANCH
         CLC   XEBLM(6),IEANUC     IS THIS A NUCLEUS ZAP
         BNE   A000FEE             NO, BRANCH
         MVC   XSDX,ONE
         B     A000FCE
A000F98  L     R14,XSDX
         L     R11,XSDCNT
         CR    R14,R11
         BNH   A000FC2
         AL    R11,ONE
         ST    R11,XSDCNT
         MH    R14,FIVE+2
         L     R11,XCESDN
         LA    R7,XSDNO(14)
         STCM  R11,3,0(R7)
         B     A000FCE
A000FC2  LA    R14,1
         AL    R14,XSDX
         ST    R14,XSDX
A000FCE  L     R14,XSDX
         MH    R14,FIVE+2
         LA    R11,XSDNO(14)
         ICM   R14,12,0(R11)
         SRA   R14,16
         C     R14,XCESDN
         BNE   A000F98
         B     A00100E
A000FEE  LA    R14,1
         AL    R14,XSDCNT
         ST    R14,XSDCNT
         ST    R14,XSDX
         MH    R14,FIVE+2
         L     R11,XCESDN
         LA    R7,XSDNO(14)
         STCM  R11,3,0(R7)
A00100E  L     R14,XSDX
         MH    R14,FIVE+2
         L     R11,XCESDX          GET SUBSCRIPT
         SLA   R11,4               MULTIPLY BY 16
         LA    R7,XSDLEN(14)
         LA    R14,XLREC+4+1(R11)
         MVC   0(3,R7),0(R14)
A00102C  LM    R14,R12,12(R13)
         BR    R14
         EJECT
*
*   SYM REC PROCESSING ROUTINE
*
*        INPUT:
*              XEBCS = CSECT CONTAINING LABEL
*              XEBLBL = LABEL BEING SEARCHED FOR
*              XLREC = FIRST SYMREC
*        OUTPUT:
*              XSYMOFF = OFFSET OF LABEL IN CSECT
*              XLREC = NEXT LIBRARY RECORD AFTER ALL SYMREC'S
*
SYMCHK   STM   R14,R12,@SAVE27
         SLR   R14,R14
         ST    R14,XSYMTOTX
         LA    R14,XLREC+4
         ST    R14,XSYMCPT
         OI    @SWB,XFSYMSKP
         OI    XFLAGS,XFSYMGO
         BAL   R14,SYMNEW
         B     A00118A
A001054  LA    R14,@WAY08
         B     A001068
A00105C  BAL   R14,SYMFETCH
         LA    R14,1
         AL    R14,XSYMFAD
A001068  ST    R14,XSYMFAD
         LA    R11,@WAY08
         SL    R11,MINUS003
         CR    R14,R11
         BNH   A00105C
         TM    XFLAGS,XFSYMGO
         BNO   A00118A
         TM    @WAY08,X'88'
         BO    A00113A
         MVC   @WAY08A(8),BLANKS
         LA    R14,@WAY08A
         B     A0010A4
A001098  BAL   R14,SYMFETCH
         LA    R14,1
         AL    R14,XSYMFAD
A0010A4  ST    R14,XSYMFAD
         LA    R11,@WAY08A
         LA    R7,7
         SLR   R4,R4
         IC    R4,@WAY08
         NR    R7,R4
         ALR   R11,R7
         CR    R14,R11
         BNH   A001098
         TM    @SWB,XFSYMSKP
         BNO   A0010FC
         TM    @WAY08,X'80'
         BNZ   A0010F8
         TM    @WAY08,X'10'
         BNO   A0010F8
         TM    @WAY08,X'60'
         BNZ   A0010F8
         CLC   @WAY08A(8),XEBCS
         BE    A0010F4
         CLC   XEBCS,BLANKS
         BNE   A0010F8
A0010F4  NI    @SWB,255-XFSYMSKP
A0010F8  B     A00113A
A0010FC  TM    @WAY08,X'80'
         BNZ   A001126
         TM    @WAY08,X'10'
         BNO   A001126
         TM    @WAY08,X'60'
         BNZ   A001126
         CLC   XEBCS,BLANKS
         BE    A001122
         OI    @SWB,XFSYMSKP
A001122  B     A00113A
A001126  CLC   @WAY08A(8),XEBLBL
         BNE   A00113A
         SLR   R14,R14
         ICM   R14,7,@WAY08Z
         ST    R14,XSYMOFF
A00113A  TM    @WAY08,X'80'
         BNO   A00118A
         LA    R14,@WAY08B
         ST    R14,XSYMFAD
         BAL   R14,SYMFETCH
         LA    R14,@WAY08C
         ST    R14,XSYMFAD
         BAL   R14,SYMFETCH
         CLI   @WAY08B,X'10'
         BNL   A001166
         BAL   R14,SYMFETCH
A001166  TM    @WAY08,X'40'
         BNO   A00117A
         BAL   R14,SYMFETCH
         BAL   R14,SYMFETCH
         BAL   R14,SYMFETCH
A00117A  TM    @WAY08,X'10'
         BNO   A00118A
         BAL   R14,SYMFETCH
         BAL   R14,SYMFETCH
A00118A  TM    XFLAGS,XFSYMGO
         BO    A001054
         LM    R14,R12,@SAVE27
         BR    R14
         EJECT
*
*   CHARACTER FETCHING ROUTINE FOR SYMREC PROCESSING
*
*        INPUT:
*              XSYMFAD = ADDR OF BYTE TO RECEIVE FETCHED CHARACTER.
*        OUTPUT:
*              XSYMFAD->BYTE = FETCHED CHARACTER
*              XSYMFGO = ON IF DATA IS EXHAUSTED
*
SYMFETCH  STM   R14,R12,@SAVE29
         L     R14,XSYMRECX
         L     R11,XSYMCPT
         ICM   R11,12,10(R11)
         SRA   R11,16
         CR    R14,R11
         BL    A0011B6
         BAL   R14,SYMNEW
A0011B6  TM    XFLAGS,XFSYMGO
         BNO   A0011E0
         L     R14,XSYMFAD
         L     R11,XSYMFPT
         MVC   0(1,R14),0(R11)
         LA    R14,1
         L     R7,XSYMRECX
         ALR   R7,R14
         ST    R7,XSYMRECX
         ALR   R11,R14
         ST    R11,XSYMFPT
A0011E0  LM    R14,R12,@SAVE29
         BR    R14
         EJECT
*
*   ROUTINE TO GET A NEW SYMREC LOGICAL RECORD
*
SYMNEW  STM   R14,R12,@SAVE28
         SLR   R14,R14
         ST    R14,XSYMRECX
         ST    R14,XSYMFPT       SET PNTR = 0
         B     A001268           DO WHILE PNTR = 0 AND XFSYMGO ON
A0011F8  L     R14,XSYMTOTX
         CH    R14,XLREC+2
         BL    A001226
         SLR   R14,R14
         ST    R14,XSYMTOTX
         BAL   R14,READLIB
         CLI   XLREC,C' '        SYM
         BNE   A001222             NO, BRANCH
         LA    R14,XLREC+4
         ST    R14,XSYMCPT
         B     A001226
A001222  NI    XFLAGS,255-XFSYMGO    SET XFSYMGO OFF
A001226  L     R14,XSYMTOTX
         LTR   R14,R14
         BZ    A00123C
         LA    R14,80
         AL    R14,XSYMCPT
         ST    R14,XSYMCPT
A00123C  LA    R14,80
         AL    R14,XSYMTOTX
         ST    R14,XSYMTOTX
         L     R14,XSYMCPT
         CLC   1(3,R14),SYM
         BNE   A001268
         L     R11,XSYMOFF
         LTR   R11,R11
         BNM   A001268
         LA    R14,16(,R14)
         ST    R14,XSYMFPT
A001268  L     R14,XSYMFPT
         LTR   R14,R14
         BNZ   A00127A
         TM    XFLAGS,XFSYMGO
         BO    A0011F8
A00127A  LM    R14,R12,@SAVE28
         BR    R14
         EJECT
*
*    SYNTAX ERROR MESSAGE ROUTINE
*
         SPACE
SYNERR STM   R14,R12,@SAVE20
         MVI   @LINE02,C' '
         MVC   @LINE03(118),@LINE02
         MVI   @LINE01,C' '
         MVC   @LINE01(15),SYNTAX
         L     R14,XMSE
         L     R11,0(,R14)
         EX    R11,PUTM8MV         MOVE 4(R14) TO LINE+16
         BAL   R14,PUTLINE
         MVC   XCODE,EIGHT
         OI    XFLAGS,XFEOD          XFEOD
         LM    R14,R12,@SAVE20
         BR    R14
         SPACE
*
*   ROUTINE TO GAIN SUPERVISOR STATE, KEY ZERO
*
         SPACE
MODESET1 STM   R14,R12,@SAVE17
         MODESET KEY=ZERO,MODE=SUP
         LM    R14,R12,@SAVE17
         BR    R14
         SPACE
*
*   ROUTINE TO RETURN TO PROBLEM STATE AND KEY
*
         SPACE
MODESET2 STM   R14,R12,@SAVE18
         MODESET KEY=NZERO,MODE=PROB
         LM    R14,R12,@SAVE18
         BR    R14
         EJECT
*
*    VERB SCANNING AND ROUTING ROUTINE
*
         SPACE
VERBSCN  STM   R14,R12,@SAVE12
         LA    R14,XEBV
         ST    R14,XRCVADDR
         MVC   XRCVLEN,EIGHT
         BAL   R14,GETFLD
         SLR   R14,R14
         ST    R14,XVXSW           SET SW OFF
         LA    R14,1
         ST    R14,XVX             SET SUBSCRIPT TO 1
PROCLOOP L     R11,XVXSW
         LTR   R11,R11             HAS SW BEEN SET ON
         BNZ   PROCDONE            YES, JUMP OUT
         LR    R11,R14
         MH    R11,THREE+2
         LA    R7,OPCODES-3(R11)   GET ADDRESS OF VERB TABLE ENTRY
         CLC   XEBV(3),0(R7)       IS THIS THE RIGHT VERB
         BNE   PROCINCR            NO, GO INCREMENT TO NEXT ONE
         SLA   R14,2
         L     R15,OPENTRY-4(14)
         BALR  R14,R15             CALL THE ROUTINE FOR THIS OPERATION
         LA    R14,1
         ST    R14,XVXSW           SET SW ON
PROCINCR LA    R14,1
         AL    R14,XVX
         ST    R14,XVX
         C     R14,SIXTEEN         HAVE ALL VERBS BEEN CHECKED
         BNH   PROCLOOP            NO, KEEP CHECKING
PROCDONE L     R14,XVXSW           WAS SW EVER SET ON
         LTR   R14,R14             YES, BRANCH
         BNZ   VERBSCNX
         LA    R14,MSG10           OPERATION REQUESTED IS INVALID
         ST    R14,XMSE
         BAL   R14,SYNERR          SYNTAX
VERBSCNX LM    R14,R12,@SAVE12
         BR    R14
         EJECT
*
*   ROUTINE TO HANDLE COMMENT STATEMENTS
*
         SPACE
COMMENT  BR    R14
         SPACE
*
*   CONSOLE VERB ROUTINE
*
         SPACE
CON      STM   R14,R12,12(R13)
         OI    XFLAGS,XFCON
         L     R14,XENDREC
         ST    R14,XCSER
         L     R14,XPENDREC
         ST    R14,XCSPER
         ST    R14,XENDREC
         LM    R14,R12,12(R13)
         BR    R14
         SPACE
*
*   END VERB ROUTINE
*
         SPACE
END      STM   R14,R12,12(R13)
         NI    XFLAGS,255-XFCON
         L     R14,XCSER
         ST    R14,XENDREC
         L     R14,XCSPER
         ST    R14,XPENDREC
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
*
*   DUMP VERB ROUTINE
*
         SPACE
DUM      STM   R14,R12,@SAVE05
         BAL   R14,NAM
         BAL   R14,DUMP
         LM    R14,R12,@SAVE05
         BR    R14
         SPACE
*
*   GLOBAL VERB ROUTINE
*
         SPACE
GLO      NI    XFLAGS,255-XFLOCSW
         BR    R14
         SPACE
*
*   LOCAL VERB ROUTINE
*
         SPACE
LOC      OI    XFLAGS,XFLOCSW
         BR    R14
         EJECT
*
*   NAME VERB ROUTINE
*
         SPACE
NAM      STM   R14,R12,@SAVE04
         NI    XFLAGS,255-XFNOGO
         SLR   R14,R14
         STCM  R14,7,XCSLEN+1
*
*   GET OPERANDS
*
         ST    R14,XBASE
         MVC   XRCVLEN,EIGHT
         LA    R14,XEBLM            PUT ADDRESS OF MEMBER
         ST    R14,XRCVADDR          IN GETFLD RESULT POINTER
         B     NAMGO1               DO UNTIL POINTER GT MEMBER+8
NAMLP1   BAL   R14,GETFLD           CALL GETFLD TO GET NEXT OPERAND
         LA    R14,8                ADD 8
         AL    R14,XRCVADDR          TO
         ST    R14,XRCVADDR           GETFLD RESULT ADDRESS
NAMGO1   LA    R11,XEBCS            IF R14 GT MEMBER+8
         CR    R14,R11               THEN
         BNH   NAMLP1                 EXIT DO LOOP
*
*   CHECK FOR A GLOBAL MODULE IN LOCAL MODE
*
         TM    XFLAGS,XFLOCSW        LOCAL MODE
         BNO   NAMOK1                NO, BRANCH
         CLC   XEBLM(6),IEANUC       YES, DOES NAME LOOK GLOBAL
         BE    NAMWARN               YES, ISSUE WARNING
         CLC   XEBLM(5),IGC00        DOES NAME LOOK GLOBAL
         BNE   NAMOK1                NO, BRANCH
NAMWARN  MVI   @LINE58,C' '          ISSUE WARNING
         MVC   @LINE59(62),@LINE58
         MVC   @LINE01(57),WARNMSG
         BAL   R14,PUTLINE
*
*   IF A CSECT WAS SPECIFIED, GET THE OFFSET TO THIS CSECT FROM
*   THE BEGINNING OF THE LOAD MODULE
*
NAMOK1   TM    XFLAGS,XFEOD
         BNZ   A001468
         CLC   XEBCS,BLANKS
         BNE   A001456
         SLR   R14,R14               CSECT OMITTED
         ST    R14,XCSOFF            OFFSET ZERO INTO MODULE
         B     A001468
A001456  MVC   XEBLBL(8),XEBCS       MAKE CSECT THE LABEL TO LOOKUP
         BAL   R14,SCANMOD           GO SCAN MODULE FOR THIS LABEL
         L     R14,XOFFSET
         ST    R14,XCSOFF            OFFSET INTO MODULE
*
*   GET IN-CORE ADDRESS OF LOAD MODULE
*
A001468  TM    XFLAGS,XFEOD
         BNZ   NAMEX
         TM    XFLAGS,XFLOCSW
         BNO   A00148A               BR IF NOT LOCAL MODE
*                                                             12/90 JEB
*   LOAD A COPY FOR LOCAL MODE                                12/90 JEB
*                                                             12/90 JEB
         MVC   XLOADPL(LOADLEN),LOADPL                        12/90 JEB
         LOAD  EPLOC=XEBLM,DCB=XDCBL,SF=(E,XLOADPL)           12/90 JEB
         BAL   R14,SCANLPA           GO FIND LOADED MODULE IN JPA
         B     NAMEEOD
A00148A  CLC   XEBLM(6),IEANUC
         BNE   NAMSCNL
         CLC   XEBCS,BLANKS          NUCLEUS, IS CSECT SPECIFIED
         BNE   PASTNCSE              YES, BRANCH
         LA    R14,MSG05             NO, CSECT REQUIRED WITH NUCLEUS
         ST    R14,XMSE
         BAL   R14,GENERR
         B     NAMEX                 EXIT
*
PASTNCSE EQU   *
         L     R14,16
         TM    CVTDCB-CVT(R14),CVTMVSE   IS THIS MVS/XA
         BO    NAMEEOD               YES, SKIP SETTING LM ADDR (SET
*                                    BY SCANMOD ROUTINE)
         SLR   R14,R14
         ST    R14,XLMADDR           NUCLEUS LOCATION IS ZERO
         B     NAMEEOD
NAMSCNL  BAL   R14,SCANLPA
NAMEEOD  TM    XFLAGS,XFEOD
         BNZ   NAMEX
         L     R14,XLMADDR
         AL    R14,XCSOFF
         ST    R14,XCSADDR           ADDRESS OF CSECT
         ST    R14,XLOC
         BAL   R14,PRADDR
NAMEX    LM    R14,R12,@SAVE04
         BR    R14
         EJECT
*
*   RETURN CODE ROUTINE
*
         SPACE
RC       STM   R14,R12,@SAVE06
         MVI   @LINE17,C' '
         MVC   @LINE18(103),@LINE17
         MVC   @LINE01(16),EQRC    = RETURN CODE
         LA    R14,XCODE
         AL    R14,THREE
         ST    R14,XHEX
         LA    R14,@LINE01
         ST    R14,XEBAD
         MVC   XHEXL,ONE
         BAL   R14,HEXCV
         BAL   R14,PUTLINE
         LM    R14,R12,@SAVE06
         BR    R14
         EJECT
*
*    REP OR RES OR RESET
*
         SPACE
REP      STM   R14,R12,@SAVE03
         CLC   XEBV,RESET          IS IT RESET
         BNE   REPIN               NO, BRANCH IF REP OR RES
         NI    XFLAGS,255-XFNOGO   RESET, JUST SET XFNOGO OFF
         B     REPX
REPIN    TM    XFLAGS,XFNOGO       IS XFNOGO SWITCH ON
         BNO   REPGO               NO, BRANCH
         MVI   @LINE37,C' '
         MVC   @LINE38(83),@LINE37
         MVC   @LINE01(36),IGNORED
         BAL   R14,PUTLINE
         B     REPX
REPGO    BAL   R14,GETOFF
         BAL   R14,GETHEX
         TM    XFLAGS,XFEOD
         BO    REPX
         CLC   XEBV,=CL8'REP'      IS THIS A REP
         BNE   RESTOREX            NO, GO DO RESTORE PROCESSING
         BAL   R14,FIXER           FIX PAGE IF REP
         BAL   R14,MODIFY          GO MODIFY STORAGE
         B     REPX                SKIP RESTORE PROCESSING
RESTOREX EQU   *
         BAL   R14,MODIFY          GO MODIFY STORAGE
         BAL   R14,FIXER           GO UNFIX STORAGE
REPX     LM    R14,R12,@SAVE03
         BR    R14
         EJECT
*
*   VERIFY ROUTINE
*
         SPACE
VER      STM   R14,R12,@SAVE02
         BAL   R14,GETOFF          GO GET VALUE OF OFFSET
         BAL   R14,GETHEX          GO GET HEX STRING
         BAL   R14,BIT31           GET INTO 31-BIT MODE
         TM    XFLAGS,XFEOD
         BNZ   VERX
         L     R14,XHL
         BCTR  R14,R0
         L     R11,XZADDR
         EX    R14,VERCLC          VERIFY THE DATA
         BE    VERX                EXIT IF IT VERIFIES OK
         OI    XFLAGS,XFNOGO       SET XFNOGO SWITCH
         MVC   XCODE,FOUR
         MVI   @LINE33,C' '
         MVC   @LINE34(87),@LINE33
         MVC   @LINE01(32),REJECT
         BAL   R14,BIT24           GET BACK TO 24-BIT MODE
         BAL   R14,PUTLINE         ISSUE REJECT MESSAGE
         BAL   R14,DUMP            DUMP THE MODULE
VERX     EQU   *
         BAL   R14,BIT24           INSURE BACK TO 24-BIT MODE
         LM    R14,R12,@SAVE02
         BR    R14
         EJECT
*
*   ZERO (AND PGFIX) STORAGE ROUTINE
*
         SPACE
ZAP      STM   R14,R12,@SAVE07
         BAL   R14,VER
         TM    XFLAGS,XFEOD+XFNOGO
         BNZ   ZAPX
         BAL   R14,FIXER           FIX PAGE IF LPA
         L     R14,XHL
         BCTR  R14,R0              LENGTH MINUS 1 FOR EX
         EX    R14,ZAPXC           MAKE REP DATA ALL ZEROS
         BAL   R14,MODIFY
ZAPX     LM    R14,R12,@SAVE07
         BR    R14
*
*   ROUTINE TO OBTAIN 24-BIT ADDRESSING MODE
*
BIT24    EQU   *
         L     R15,16              GET CVT ADDR
         TM    CVTDCB-CVT(R15),CVTMVSE IS THIS MVS/XA
         BZR   R14                 NO, RETURN TO CALLER
         LA    R14,0(,R14)         CLEAR HI-ORDER PORTION
         BSM   0,R14               RETURN IN 24-BIT MODE
*
*   ROUTINE TO OBTAIN 31-BIT ADDRESSING MODE
*
BIT31    EQU   *
         L     R15,16              GET CVT ADDR
         TM    CVTDCB-CVT(R15),CVTMVSE IS THIS MVS/XA
         BZR   R14                 NO, RETURN TO CALLER
         LA    R14,0(,R14)         CLEAR OUT BAL STUFF, ETC.
         O     R14,HIORDBIT        TURN ON AMODE-31 BIT
         BSM   0,R14               RETURN IN 31-BIT MODE
         EJECT
*
*   ROUTINE TO MODIFY STORAGE
*
*        INPUT:
*              XHS = HEX STRING
*              XHL = LENGTH OF HEX STRING
*              XZADDR = ADDRESS OF CORE TO BE OVERLAYED
*
MODIFY   STM   R14,R12,@SAVE30
         MVI   @LINE14,C' '
         MVC   @LINE15(106),@LINE14
         MVC   @LINE01(13),OLDWAS
         L     R14,XHL            LENGTH OF DATA TO BE MODIFIED
         ST    R14,XHEXL
         L     R14,XZADDR         ADDRESS OF DATA TO BE MODIFIED
         ST    R14,XHEX
         LA    R14,@LINE01
         AL    R14,THIRTEEN
         ST    R14,XEBAD          PUT HEX DUMP AT LINE+1+13
         BAL   R14,HEXCV          CONVERT OLD DATA TO HEX
         BAL   R14,PUTLINE        DISPLAY OLD DATA
         BAL   R14,MODESET1       SUPV STATE KEY ZERO
         BAL   R14,BIT31          GET 31-BIT MODE
         L     R14,XZADDR         GET ADDRESS TO BE MODIFIED
         L     R11,XHL            GET LENGTH OF DATA
         B     MODLPTST           GO DO LOOP TEST
*
MODLOOP  EQU   *
         LA    R8,0(R11,R14)      POINT AT BYTE TO MOVE
         L     R2,PSAAOLD         GET ADDR OF CURRENT ASCB
         N     R8,MASKPAGE        GET LOWER PAGE BOUNDARY
         STCTL 1,1,I              GET SET TABLE ORIGIN
         L     R2,I               GET CONTENTS OF STO REG
         L     R15,16             GET ADDR OF CVT
         TM    CVTDCB-CVT(R15),CVTMVSE  IS THIS MVS/XA
         BO    MODXA              YES, GO DO XA PROCESSING
*
*   TEMPORARILY TURN OFF SEGMENT PROTECTION
*
         SRL   R8,16              ISOLATE SEG INDEX (SX)
         SLL   R8,2               MULT SX*4 TO GET OFFSET
         N     R2,MASKSTO3        ISOLATE ADDR OF SEG TBL
         BAL   R15,REAL2VIR       CONVERT TO VIRTUAL ADDR
         ALR   R2,R8              GET ADDR OF SEG TBL ENTRY
         L     R8,MASKSPBT        GET MASK FOR SEG PROT BIT
         LA    R9,3(,R2)          POINT AT BYTE CONTAINING SP BIT
         N     R8,0(,R2)          ISOLATE SEG PROT BIT
         BZ    MODIT              BR IF NOT PROTECTED
         NI    0(R9),X'FB'        TURN OFF SEG PROT
         B     MODPTLB            SKIP XA PROCESSING
*
*   TURN OFF PAGE PROTECTION FOR XA
*
MODXA    EQU   *
         SR    R9,R9              CLEAR SECOND REG OF PAIR
         SRDL  R8,20              ISOLATE SX & PUT PX IN R9
         SLL   R8,2               GET SEG TBL OFFSET (SX*4)
         N     R2,MASKSTOX        ISOLATE ADDR OF SEG TABLE
         BAL   R15,REAL2VIR       GET VIRTUAL ADDR
         ALR   R2,R8              GET ADDR OF SEG TBL ENTRY
         SRL   R9,22              GET PAGE TABLE OFFSET (PX*2)
         L     R2,0(,R2)          GET CONTENT OF SEG TBL ENTRY
         N     R2,MASKSTE         ISOLATE ADDR OF PAGE TBL ORIGIN
         BAL   R15,REAL2VIR       GET VIRTUAL ADDR
         ALR   R9,R2              GET ADDR OF PAGE TBL ENTRY
         L     R8,0(,R9)          GET CONTENTS OF PAGE TABLE ENTRY
         N     R8,MASKPPBT        ISOLATE PAGE PROT BIT
         BZ    MODIT              BR IF NO PAGE PROT
         SRL   R8,8               SHIFT BYTE TO LO-ORDER
         LA    R9,2(,R9)          GET ADDR OF BYTE WITH PP BIT IN IT
         NI    0(R9),X'FD'        TURN OFF PAGE PROT
MODPTLB  EQU   *
         PTLB  ,                  ELIM PROT BIT FROM TLB
*
*   MODIFY STORAGE A BYTE AT A TIME
*
MODIT    EQU   *
         IC    R0,XHS(R11)        GET FROM BYTE
         STC   R0,0(R11,R14)      MODIFY STORAGE
         EX    R8,ORPROT          TURN PROT BIT BACK ON
MODLPTST EQU   *
         S     R11,ONE            DECREMENT
         BNM   MODLOOP            BRANCH UNTIL DONE
         BAL   R14,BIT24          GET BACK TO 24-BIT MODE
*
         BAL   R14,MODESET2       PROB STATE KEY NZERO
         LM    R14,R12,@SAVE30
         BR    R14
         EJECT
*
*   REAL TO VIRTUAL CONVERSION SUBROUTINE
*
*        INPUT
*              R2 - REAL ADDR
*              R15 - RETURN ADDR
*        OUTPUT
*              R1,R3 - ALTERED
*              R2 - CONVERTED VIRTUAL ADDRESS
*
REAL2VIR EQU   *
         LR    R1,R2              COPY INPUT ADDR
         SRL   R1,12              SHIFT OFF DISPLACEMENT
         L     R3,CVTPTR          GET ADDR OF CVT
         TM    CVTDCB-CVT(R3),CVTMVSE IS THIS MVS/XA
         L     R3,CVTPVTP-CVT(,R3)  GET ADDR OF PVT
         BO    R2VXA              YES, BRANCH
*
         L     R3,PVTPFTP(,R3)    GET ADDR OF PFT
         SLL   R1,4               GET PFT DISPLACEMENT
         AR    R3,R1              GET PFTE ADDR
         SR    R1,R1              CLEAR
         ICM   R1,6,PFTVBN(R3)    GET VIRT BLK NO.
         B     R2VB               SKIP XA PROCESSING
*
R2VXA    EQU   *
         L     R3,PVTRIT(,R3)     GET ADDR IF RIT
         L     R3,RITPFT(,R3)     GET ADDR OF PFT
         SLL   R1,5               GET PFT DISPLACEMENT
         L     R1,PFTVSA(R1,R3)   GET VIRT PAGE ADDR
*
R2VB     EQU   *
         N     R2,MASKPGDP        GET PAGE DISPLACEMENT
         OR    R2,R1              COMBINE WITH VIRT PAGE NO.
         BR    R15                RETURN
         EJECT
*
*   EXECUTED INSTRUCTIONS
*
         SPACE
H9       DC    H'0009'
LOGMVC   MVC   @LINE01,0(R14)
PUTMSGM  MVC   @LINE01,4(R14)
PARBLNK  MVC   0(1,R14),BLANKS
PARMVC   MVC   0(1,R11),0(R7)
A001638  MVC   0(1,R11),XHS
PARMMVC  MVC   @PARMCPY(1),2(R11)
PUTM8MV  MVC   @LINE16,4(R14)
VERCLC   CLC   0(1,R11),XHS
ZAPXC    XC    XHS(1),XHS
ORPROT   OI    0(R9),*-*
         EJECT
***********************************************************************
*                                                                     *
*         CONSTANTS                                                   *
*                                                                     *
***********************************************************************
         SPACE
ONE      DC    F'1'
TWO      DC    F'2'
THREE    DC    F'3'
FOUR     DC    F'4'
FIVE     DC    F'5'
EIGHT    DC    F'8'
TWELVE   DC    F'12'
THIRTEEN DC    F'13'
FOURTEEN DC    F'14'
SIXTEEN  DC    F'16'
FORTY    DC    F'40'
FORTY8   DC    F'48'
F400     DC    F'400'
MINUS129 DC    F'-129'
MINUS079 DC    F'-79'
MINUS032 DC    F'-32'
MINUS008 DC    F'-8'
MINUS003 DC    F'-3'
PGFIX    EQU   *
         DC    X'42000000'
PGFREE   EQU   *
         DC    X'20000000'
X000FFFF DC    F'65535'
MASKPAGE DC    X'FFFFF000'           PAGE BOUNDARY MASK
MASKPGDP DC    X'00000FFF'           PAGE DISPLACEMENT MASK
MASKSTO3 DC    X'00FFFFC0'           370-MODE STO REG MASK
MASKSTOX DC    X'7FFFF000'           XZ-MODE STO REG MASK
MASKSPBT DC    X'00000004'           SEG PROT BIT MASK
MASKSTE  DC    X'7FFFFFC0'           SEG TBL ENTRY MASK
MASKPPBT DC    X'00000200'           PAGE PROT BIT MASK
HIORDBIT DC    X'80000000'           HI-ORDER BIT MASK
SIZE     DC    A(@DATAL)             LENGTH OF GETMAINED AREA
         DC    F'0'
BLANKS   DC    C'        '
LINKZAP  DC    C'LINKZAP '
RESET    DC    C'RESET   '
IEANUC   DC    C'IEANUC'
IGC00    DC    C'IGC00'
LITBAS   DC    C'BAS'
SYM      DC    C'SYM'
FFFFFFFF DC    XL8'FFFFFFFFFFFFFFFF'
HEX0F0F  DC    X'0F0F'
HEXTR    EQU   *
         DC    X'0A0B0C0D0E0F'
         DC    41X'00'             C7-EF
         DC    X'00010203040506070809'
         DC    6X'00'              FA-FF
         DC    X'00'
BLINE    DC    H'127,0'
         DC    CL123' '
EBCDIC   DC    74C' '              00-49
         DC    X'4A4B4C4D4E4F50'
         DC    C'         '        51-59
         DC    X'5A5B5C5D5E5F6061'
         DC    C'        '         62-69
         DC    X'6A6B6C6D6E6F'
         DC    C'         '        70-78
         DC    X'797A7B7C7D7E7F'
         DC    C' '                80
         DC    C'ABCDEFGHI'        81-89
         DC    C' '                8A
         DC    X'8B8C8D8E8F'
         DC    C' '                90
         DC    C'JKLMNOPQR'        91-99
         DC    C' '                9A
         DC    X'9B9C9D9E9FA0A1'
         DC    C'STUVWXYZ'         A2-A9
         DC    X'AAABACADAEAF'     AA-AF
         DC    X'B0B1B2B3B4B5B6B7B8B9'
         DC    C' '                BA
         DC    X'BBBCBDBEBFC0'
         DC    C'ABCDEFGHI'        C1-C9
         DC    C'      '           CA-CF
         DC    X'D0'
         DC    C'JKLMNOPQR'        D1-D9
         DC    C'      '           DA-DF
         DC    X'E0'
         DC    C' '                E1
         DC    C'STUVWXYZ'         E2-E9
         DC    C'      '           EA-EF
         DC    C'0123456789'       F0-F9
         DC    X'FA'
         DC    C'     '            FB-FF
         LTORG
*
*   MESSAGES
*
WHEREMSG DC    C'         = IN-CORE ADDRESS OF PRECEDING SYMBOL'
IGNORED  EQU   *,36
         DC    C'OPERATION IGNORED - NO GO SWITCH SET'
REJECT   EQU   *,32
         DC    C'VERIFY REJECT - SET NO GO SWITCH'
OLDWAS   EQU   *,13
         DC    C'OLD DATA WAS '
EQRC     EQU   *,16
         DC    C'   = RETURN CODE'
SYNTAX   EQU   *,15
         DC    C'SYNTAX ERROR - '
WARNMSG  EQU   *,57
         DC    C'WARNING -- LOCAL MODE IS PROBABLY INVALID '
         DC    C'FOR THIS MODULE'
HEADING  EQU   *,121
         DC    CL121'1MAIN STORAGE ZAP SERVICE AID PROGRAM'
         DC    X'00'
MSG01    DC    F'00017'
         DC    C'FIELD IS TOO LONG'
         DC    X'00'
         DC    H'0'
MSG02    DC    F'00024'
         DC    C'OFFSET FIELD IS TOO LONG'
MSG03    DC    F'00029'
         DC    C'INVALID HEXADECIMAL CHARACTER'
         DC    X'00'
         DC    H'0'
MSG04    DC    F'00032'
         DC    C'MODULE NOT FOUND IN MAIN STORAGE'
MSG05    DC    F'00046'
         DC    C'CSECT MUST BE SUPPLIED FOR NUCLEUS LOAD MODULE'
         DC    H'0'
MSG06    DC    F'00028'
         DC    C'INPUT DD STATEMENT NOT FOUND'
MSG07    DC    F'00042'
         DC    C'DD STATEMENT FOR PROGRAM LIBRARY NOT FOUND'
         DC    H'0'
MSG08    DC    F'00035'
         DC    C'MEMBER NOT FOUND ON PROGRAM LIBRARY'
         DC    X'00'
MSG09    DC    F'00031'
         DC    C'SYMBOL NOT FOUND IN LOAD MODULE'
         DC    X'00'
MSG10    DC    F'00030'
         DC    C'OPERATION REQUESTED IS INVALID'
         DC    H'0'
MSG11    DC    F'00022'
         DC    C'REQUIRED FIELD MISSING'
         DC    H'0'
MSG12    DC    F'00035'
         DC    C'UNEVEN NUMBER OF HEXADECIMAL DIGITS'
         DC    X'00'
WTORM    EQU   *,44
         DC    F'0'
         DC    F'0'
         DC    AL2(36,0)
         DC    C'ENTER INCORZAP STATEMENTS OR END'
*
*   LIBRARY DEFINITION TABLES
*
LIBDEF   EQU   *,24
         DC    A(LIBDCB)           POINTER TO DCB IMAGE
         DC    A(LIBOPEN)          POINTER TO OPEN MF=L
         DC    C'PROGLIB '         PRIMARY DDNAME
         DC    C'SYSLIB  '         SECONDARY DDNAME
PRTDEF   EQU   *,24
         DC    A(PRTDCB)           POINTER TO DCB IMAGE
         DC    A(PRTOPEN)          POINTER TO OPEN MF=L
         DC    C'PROGLIST'         PRIMARY DDNAME
         DC    C'SYSPRINT'         SECONDARY DDNAME
CTLDEF   EQU   *,24
         DC    A(CTLDCB)           POINTER TO DCB IMAGE
         DC    A(CTLOPEN)          POINTER TO OPEN MF=L
         DC    C'PROGIN  '         PRIMARY DDNAME
         DC    C'SYSIN   '         SECONDARY DDNAME
*
*   HEXADECIMAL VALIDATION TRANSLATE TABLE
*
HEXTRT   DC    193X'01'            00-C0
         DC    6X'00'              C1-C6 (A-F)
         DC    41X'01'             C7-EF
         DC    10X'00'             F0-F9
         DC    6X'01'              FA-FF
*
*   VERB NAME TABLE
*
OPCODES  DC    C'VER'                      01
         DC    C'REP'                      02
         DC    C'NAM'                      03
         DC    C'DUM'                      04
         DC    C'RES'                      05
         DC    C'   '                      06
         DC    C'*  '                      07
         DC    C'CON'                      08
         DC    C'END'                      09
         DC    C'RC '                      10
         DC    C'ZAP'                      11
         DC    C'GLO'                      12
         DC    C'LOC'                      13
         DC    C'BAS'                      14
         DC    C'IDR'                      15
         DC    C'SET'                      16
         DC    H'0'
*
*   VERB ROUTINE ADDRESS TABLS
*
OPENTRY  DC    A(VER)
         DC    A(REP)
         DC    A(NAM)
         DC    A(DUM)
         DC    A(REP)
         DC    A(COMMENT)
         DC    A(COMMENT)
         DC    A(CON)
         DC    A(END)
         DC    A(RC)
         DC    A(ZAP)
         DC    A(GLO)
         DC    A(LOC)
         DC    A(GETOFF)
         DC    A(COMMENT)
         DC    A(COMMENT)
*
HEXTAB   DC    C'0123456789ABCDEF'
         SPACE
CLOSE    EQU   *,12
         DC    F'0'
         DC    F'0'
         DC    X'80000000'
LOADPL   LOAD  EPLOC=0,DCB=0,LSEARCH=YES,SF=L                 12/90 JEB
LOADLEN  EQU   *-LOADPL                                       12/90 JEB
LIBDCB   DCB   DDNAME=0,DSORG=PO,MACRF=R
LIBDCBL  EQU   *-LIBDCB
         SPACE
PRTDCB   DCB   DDNAME=0,DSORG=PS,MACRF=PM,                             +
               RECFM=FA,LRECL=121,BLKSIZE=121
PRTDCBL  EQU   *-PRTDCB
         SPACE
CTLDCB   DCB   DDNAME=0,DSORG=PS,MACRF=GM,EODAD=CTLEOD,LRECL=80
CTLDCBL  EQU   *-CTLDCB
         SPACE
LIBOPEN  DC    X'84000000'
CTLOPEN  DC    X'80000000'
PRTOPEN  DC    X'8F000000'
         EJECT
*
*   FLAG MAPPINGS
*
XFMAIN   EQU   X'80'               INPUT NOT FROM PARM FIELD
XFEOD    EQU   X'40'
XFLOCSW  EQU   X'20'
XFNOGO   EQU   X'10'
XFCON    EQU   X'08'
XFSKIP1  EQU   X'04'               SKIP 1ST CESD (NUC MOD)
XFOOP    EQU   X'02'               OUTPUT DATASET OPEN
XFSYMGO  EQU   X'01'               SW FOR SYMREC PROCESSING
XFSYMSKP EQU   X'80'               SKIP SYMBOLS (WRONG CSECT)
XF1ST    EQU   X'40'               1ST TIME SW FOR PRINTING
XFNOWTO  EQU   X'20'
SWB10    EQU   X'10'
         EJECT
*
*   REGISTERS
*
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5                   DATA BASE REG NO. 2
R6       EQU   6                   PROG BASE REG NO. 2
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10                  DATA BASE REG NO. 1
R11      EQU   11
R12      EQU   12                  PROG BASE REG NO. 1
R13      EQU   13
R14      EQU   14
R15      EQU   15
*
*   CONTROL BLOCK MAPPINGS
*
PVTRIT   EQU   X'04'               POINTER TO RIT (XA)
PVTPFTP  EQU   X'0C'               POINTER TO APPARENT PFT (370)
RITPFT   EQU   X'D0'               POINTER TO APPARENT PFT (XA)
PFTVBN   EQU   X'2'                VIRT BLK NUMBER (370)
PFTVSA   EQU   X'14'               VIRT STORAGE ADDR (XA)
CVT      DSECT
         CVT   DSECT=YES
*
*        IHAPSA
FLC      DSECT                     USED BY SETLOCK
PSAAOLD  EQU   X'224'              ADDR OF CURRENT ASCB
PSALITA  EQU   FLC+764             USED BY SETLOCK
         EJECT
***********************************************************************
*                                                                     *
*         MAP OF GETMAINED WORK AREA                                  *
*                                                                     *
***********************************************************************
         SPACE
@DATA    DSECT
@SAVE01  DS    18F
@PARMPTR DS    F
@SAVE02  DS    15F                 SUBROUTINE SAVE AREAS
@SAVE03  DS    15F
@SAVE04  DS    15F
@SAVE05  DS    15F
@SAVE06  DS    15F
@SAVE07  DS    15F
@SAVE08  DS    15F
@SAVE09  DS    15F
@SAVE10  DS    15F
@SAVE11  DS    15F
@SAVE12  DS    15F
@SAVE13  DS    15F
@SAVE14  DS    15F
@SAVE15  DS    15F
@SAVE16  DS    15F
@SAVE17  DS    15F
@SAVE18  DS    15F
@SAVE19  DS    15F
@SAVE20  DS    15F
@SAVE21  DS    15F
@SAVE22  DS    15F
@SAVE23  DS    15F
@SAVE24  DS    15F
@SAVE25  DS    15F
@SAVE26  DS    15F
@SAVE27  DS    15F
@SAVE28  DS    15F
@SAVE29  DS    15F
@SAVE30  DS    15F
@ESDSUB  DS    0F
I        DS    F                    WORK VARIABLE
XACCUM   DS    F                    ACCUMULATED CSECT LENGTH
XBASE    DS    F                    BASE VALUE FOR OFFSET ADJ
XCESDN   DS    F                    CESD NUMBER
XCSECNO  DS    F                    CSECT NO. FOR 'XEBLBL'
XCESDX   DS    F                    INDEX TO CESD ENTRY
XCRSW    DS    F                    CESD RECORD SCAN SW
XCSADDR  DS    F                    ADDRESS OF CSECT
XCSDADR  DS    F                    REL ADDR OF CSECT ON DISK
XCSER    DS    F                    LENGTH OF CSECT
XCSPER   DS    F                    SAVE XPENDREC - CONSOLE MODE
XCSOFF   DS    F                    OFFSET TO CSECT IN LOAD MOD
XCODE    DS    F                    RETURN CODE
XDCBA    DS    F                    ADDR OF DCB
XDDN     DS    F                    PNTR TO DD NAME TABLE
XDUMPEND DS    F                    END OF DUMP
XDP      DS    F                    DUMP POINTER
XEBAD    DS    F                    ADDR OF EBCDIC DATA
XENDREC  DS    F                    ADDR OF END OF LOGICAL DATA
XFLDCUR  DS    F                    CURRENT CHARACTER POINTER
XRCVADDR DS    F                    ADDR OF RECEIVING FIELD
XFLDALEN DS    F                    ACTUAL FIELD LENGTH
XFLDSTRT DS    F                    START OF FIELD
XGOS     DS    F                    'GET OFFSET' ROUTINE SW
XHEX     DS    F                    ADDR OF HEX DATA
XHEXL    DS    F                    LENGTH OF HEX DATA
XHL      DS    F                    LENGTH OF HEX STRING
XHP      DS    F                    POINTER TO HEX STRING
XHSPTR   DS    F                    HEX STRING POINTER
XHSW     DS    F                    SWITCH
XHWPTR   DS    F                    HEX WORK AREA POINTER
XLMADDR  DS    F                    IN-CORE ADDR OF LOAD MOD
XLOC     DS    F                    LOCATION TO BE DISPLAYED
XMSE     DS    F                    ADDR OF SYNTAX ERR MSG
XNUMCESD DS    F                    NO. OF ENTRIES IN CESD REC
XOCODE   DS    F
XOFFSET  DS    F                    OFFSET TO CESD IN LOAD MOD
XPECB    DS    F
XPENDREC DS    F                    POINTER TO END OF PHYSICAL REC
XPS      DS    F                    LOOP SWITCH
XPSRC    DS    F                    PAGE SERVICE RETURN CODE
XRCVLEN  DS    F                    RECEIVING FIELD LEN
XSCANSW  DS    F                    SW TO CONTROL SCAN
XSDCNT   DS    F                    COUNT OF CSECTS IN MODULE
XSDX     DS    F                    ARRAY INDEX FOR XSD
XSMCSD   DS    F
XSYMCPT  DS    F
XSYMFAD  DS    F
XSYMFPT  DS    F
XSYMOFF  DS    F
XSYMRECX DS    F
XSYMTOTX DS    F
XVX      DS    F                    VERB INDEX
XVXSW    DS    F
XWECB    DS    F
XWORK    DS    F
XX       DS    F
XZADDR   DS    F                    IN-CORE STORAGE ADDR
Y        DS    F
@FILL01  DS    CL12
XCSLEN   DS    F
XCARD    DS    CL80
         DS    0F
XDCBL    DS    CL100
         DS    0F
XDCBO    DS    CL100
         DS    0F
XDCBIN   DS    CL100
XDCBCLS  DS    3F
         DS    F
XLOADPL  DS    (LOADLEN)X                                     12/90 JEB
XEBLM    DS    CL8
XEBCS    DS    CL8
         DS    CL8
XEBLBL   DS    CL8
XEBV     DS    CL8
XFLAGS   DS    C
@SWB     DS    C
XGOC     DS    C
         DS    C                   XHOP-1
XHOP     DS    F
XHPW     DS    CL9
XHS      DS    CL40
         DS    C                   XHW-1
XHW      DS    CL80
@DECB    DS    5F
         SPACE
@LINE    DS    CL121               @DATA+2642
         ORG   @LINE
         DS    C
@LINE01  DS    C
@LINE02  DS    C
@LINE03  DS    CL11
@LINE14  DS    C
@LINE15  DS    C
@LINE16  DS    C
@LINE17  DS    C
@LINE18  DS    CL15
@LINE33  DS    C
@LINE34  DS    CL3
@LINE37  DS    C
@LINE38  DS    CL3
@LINE41  DS    CL6
@LINE47  DS    C
@LINE48  DS    CL10
@LINE58  DS    C
@LINE59  DS    CL28
@LINE87  DS    C
@LINE88  DS    CL26
         DS    CL6
@LIN120  DS    C
         SPACE
         DS    C
XLREC    DS    0F,CL248
@PARMCPY DS    CL200
XREPLY   DS    CL130
@FILL9C  DS    CL2
XWTO     DS    CL144
XWTOR    DS    CL44
@WAY08   DS    CL1
@WAY08Z  DS    CL3
@WAY08A  DS    CL5
*
*   CSECT MAPPING ARRAY (912 ENTRIES)
*
XSDNO    DS    C                     CSECT NUMBER (2 BYTES)
         DS    C
XSDLEN   DS    C                     CSECT LENGTH (3 BYTES)
@WAY08B  DS    C
@WAY08C  DS    C
         DS    2000C
         DS    2560C
@DATAL   EQU   *-@DATA
         END
