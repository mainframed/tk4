//ASQCCBRO JOB (X0002,QCC,ASQCC),'X-COOK, BRIAN',
//   MSGCLASS=X,CLASS=X,NOTIFY=ASQCC,MSGLEVEL=(1,1)
/*JOBPARM L=99,SYSAFF=MVSA
//*
//* TECH.ASQCC.SOURCE(ETPSBRO3)
//*
//ASM     EXEC PGM=IEV90,REGION=1024K,
//             PARM='TERM,NODECK,OBJECT,RENT,XREF(SHORT)'
//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR
//         DD  DSN=SYS1.AMODGEN,DISP=SHR
//         DD  DISP=SHR,DSN=SYS2.MACLIB  <== TCBUVTAM, ETPSMACS
//SYSUT1   DD  SPACE=(CYL,(5,1)),
//             UNIT=SYSDA
//SYSTERM  DD  SYSOUT=*
//SYSPRINT DD  SYSOUT=*
//SYSPUNCH DD  DUMMY
//SYSLIN   DD   DSN=&&OBJSET,UNIT=SYSDA,SPACE=(80,(200,50)),
//             DISP=(MOD,PASS)
//SYSIN    DD  *
ETPSBRO3 TITLE 'ETPS - BROWSE3     '
         PRINT OFF
         COPY  ETPSMACS
         PRINT ON
ETPSBRO3 CSECT
         USING *,12,11
         USING SAVE3,13
*
         STM   R14,R12,12(R13)    SAVE INPUT REGS
         LR    R12,R15            SET PROGRAM BASE REGISTER 1
         L     R2,0(,R1)          SAVE PARM POINTER
         LA    R11,72(,R13)       LEVEL 3 MODULE, SO BUMP TO SAVE3
         ST    R13,4(,R11)       STORE BACKWARDS POINTER
         ST    R11,8(R13)         STORE FORWARD POINTER
         LR    R13,R11            SET DSECT BASE 1
         LA    R3,1
         LA    R11,4095(R3,R12)   SET PROGRAM BASE REGISTER 2
         LA    R10,SPLITWRK       SET DSECT FOR SPLIT-SCREEN
         USING SPLTAREA,10
*
* PARM LIST FOR BROWSE IS : DCB, DSN, MEMBER NAME, DSORG
*    FOR JES2 DSID'S, ADD : LRECL RECFM
*
         LM    R2,R7,0(R1)              PICK UP THE REGISTERS
*
*  R2=DCB ADDRESS, OR FOR JES2 DSID, ADDRESS OF MTTR
*  R3=DSN ADDRESS
*  R4=MEMBER NAME ADDRESS
*  R5=DSORG ADDRESS
*  R6=LRECL ADDRESS
*  R7=RECFM ADDRESS
*
         ST    R2,EDTDCB                SAVE DCB ADDRESS
         MVC   EDTDSN(44),0(R3)         SAVE DSNAME
         MVC   EDTMEM(8),0(R4)          SAVE MEMBER NAME
         MVC   EDTORG(3),0(R5)          SAVE DSORG
*
************************************************************
*                                                          *
*        SET UP THE DCB                                    *
*                                                          *
************************************************************
*
         MVI   JESFLAG,X'FF'                NOT A JES DSID
         CLC   EDTORG(3),=C'JES'       IS THIS A JES DSID?
         BE    BROJES1                      DO INITIALIZATION
*
         LR    R4,R2
         USING IHADCB,R4
         LM    R0,R1,DCBDDNAM        SAVE DDNAME
         MVC   0(BRODCBL,R4),BRODCB
         STM   R0,R1,DCBDDNAM         SET DDNAME
*
         LA    R15,DYNEOD
         ICM   R15,8,DCBEODAD
         ST    R15,DCBEODAD
*
         LA    R15,DYNSYNAD
         ICM   R15,8,DCBSYNAD
         ST    R15,DCBSYNAD
*
         LA    R15,DYNEXLST
         ICM   R15,8,DCBEXLST
         ST    R15,DCBEXLST
*
         LA    R1,DYNDCBEX
         ST    R1,0(,R15)
         MVI   0(R15),X'05'
         LA    R1,DYNABEND
         ST    R1,4(,R15)
         MVI   4(R15),128+X'11'    OPEN ABEND EXIT (MVS)
*
         OI    STATUS,STOPEN       TELL CLEANUP TO CLOSE DCB
         MVI   OPEND,X'80'
*
         OPEN  ((R4),INPUT),MF=(E,OPEND)
*
         TM    DCBOFLGS,X'10'
         BO    OKOPEN
         LA    R1,MSG08
         TM    STATUS,STABEND      MEMBER NOT FOUND?
         BO    DYNOPENM            YES, BRANCH
         LA    R1,MSG04
DYNOPENM DS    0H
         ST    R1,MSGADD
         B     EXIT12
*
DYNDCBEX EQU   *
*              TESTING THE RECFM FOR RECFM V OR F
*              REQUIRES AT LEAST 2 TESTS BECAUSE BOTH THE
*              V AND F BITS ARE ON WHEN RECFM IS U.
*              THIS ROUTINE MAKES A COPY OF THE RECFM BITS
*              AND ZEROES BOTH THE V AND F BITS IN THE COPY
*              IF THE RECFM IS U.  NOW WE CAN DETERMINE
*              RECFM V OR F IN ONE TEST INSTEAD OF TWO.
         MVC   WRKRECFM,DCBRECFM   COPY RECFM
         MVC   TSTRECFM,DCBRECFM   COPY RECFM
         TM    WRKRECFM,X'C0'      RECFM U
         BNOR  R14                 NO, BRANCH
         NI    TSTRECFM,255-X'C0'  YES, SET BOTH BITS OFF
         BR    R14
*
DYNABEND EQU   *
         L     R8,0(,R1)           GET COMPLETION CODE
         N     R8,=A(X'FFF0FF00')
         CL    R8,=A(X'01301800')  IS IT AN 013-18 ABEND
         BE    *+10                YES, BRANCH
         MVI   4(R1),0             ABNORMALLY TERMINATE
         BR    R14
         OI    STATUS,STABEND      INDICATE MEMBER NOT FOUND
         MVI   3(R1),4             IGNORE THE ABEND
         BR    R14
         EJECT
BROJES1  DS    0H
         MVI   JESFLAG,X'00'               IT'S A JES DSID
*
*
* FOR JES SYSOUTS, THE DSN=JES2.JOBNNNN.DSIDNNN
* AND:
*  R2=MTTR ADDRESS
*  R6=LRECL ADDRESS
*  R7=RECFM ADDRESS
         MVC   JESMTTR(4),0(R2)        SAVE DSID START
         MVC   TOPMTTR(4),0(R2)        SAVE DSID START
         MVC   JESLRECL(2),0(R6)       SAVE LRECL
         MVC   WRKRECFM,0(R7)          SAVE RECFM
         MVC   TSTRECFM,0(R7)          SAVE RECFM
         TM    WRKRECFM,X'C0'      RECFM U
         BNO   OKOPEN              NO, BRANCH
         NI    TSTRECFM,255-X'C0'  YES, SET BOTH BITS OFF
         B     OKOPEN
*
BROWJQEX DS    0H
         B     NOCLOSE
FOURK    DC    H'4096'
         EJECT
OKOPEN   DS    0H
         MVC   DYNDECBW(DYNDECBL),DYNDECB
*
************************************************************
*                                                          *
*        SET UP THE BUFFER AREA                            *
*                                                          *
************************************************************
*
         LH    R0,FOURK
         CLI   JESFLAG,X'00'              IS IT A JES DSID
         BE    *+8                        YES
         LH    R0,DCBBLKSI
         AH    R0,=H'7'            ROUND
         N     R0,=A(X'FFFFFFF8')   UPWARDS TO MULTIPLE OF 8
         ST    R0,SAVBLKSI         SAVE FOR PARTITIONING
*
         SLR   R0,R0
         TM    TSTRECFM,X'48'      VS OR VBS
         BNO   NOTSPAN             NO, BRANCH
         LH    R0,JESLRECL         YES, GET LRECL
         CLI   JESFLAG,X'00'              IS IT A JES DSID
         BE    *+8                        YES
         LH    R0,DCBLRECL         YES, GET LRECL
         AH    R0,=H'7'            ROUND
         N     R0,=A(X'FFFFFFF8')   UPWARDS TO MULTIPLE OF 8
         LTR   R0,R0               WAS LRECL ZERO
         BNZ   *+8                 NO, SKIP NEXT INSTR
         L     R0,SAVBLKSI         YES, USE BLKSIZE ROUNDED
         A     R0,=A(2048)         ADD 2K IN CASE LRECL IS WRONG
NOTSPAN  ST    R0,SAVSPANL         SAVE FOR PARTITIONING
*
         LH    R0,JESLRECL         YES, GET LRECL
         CLI   JESFLAG,X'00'              IS IT A JES DSID
         BE    *+8                        YES
         LH    R0,DCBLRECL
         LTR   R0,R0
         BNZ   *+8
         LH    R0,FOURK            JES BLKSIZE
         CLI   JESFLAG,X'00'              IS IT A JES DSID
         BE    *+8                        YES
         LH    R0,DCBBLKSI
         STH   R0,RECSIZE
         AH    R0,=H'7'            ROUND
         N     R0,=A(X'FFFFFFF8')   UPWARDS TO MULTIPLE OF 8
         CH    R0,=H'1000'         IS LRECL GREATER THAN MAX
         BNH   *+8                 NO, SKIP NEXT INSTR
         LH    R0,=H'1000'         YES, HELD RECORDS MUST BE TRUNCATED
         ST    R0,SAVLRECL         SAVE FOR HOLD AREA DIVISION
         MH    R0,SCROWS+2
*        MH    R0,SCROWS1+2
         ST    R0,SAVHOLDL         SAVE FOR PARTITIONING
*
         A     R0,SAVSPANL         COMBINE LENGTHS FOR GETMAIN
         A     R0,SAVBLKSI         COMBINE LENGTHS FOR GETMAIN
         A     R0,=A(20*200)       PLUS ROOM FOR 200 CHECKPOINTS
         LA    R7,RANGE
         ST    R0,0(,R7)
         A     R0,=A(20*824)       OPTIONAL ROOM FOR 1024 CHECKPOINTS
*        L     R0,=A(16*1024*1024-8) 16 MEG
         ST    R0,4(,R7)
         LA    R8,ANSWER
         MVC   GMVUW(GMVUL),GMVU
         GETMAIN VU,LA=(R7),A=(R8),MF=(E,GMVUW)
         OI    STATUS,STGMVU
*        L     R0,ANSWER+4         LENGTH
*        L     R1,ANSWER           ADDRESS
*        FREEMAIN R,LV=(0),A=(1)
         L     R1,ANSWER
         LR    R0,R1
         A     R0,ANSWER+4
         ST    R0,ENDPTR           END OF GETMAINED AREA
         ST    R1,BLOCKPTR
         A     R1,SAVBLKSI         POINT PAST BLOCK AREA
         ST    R1,SPANPTR
         A     R1,SAVSPANL         POINT PAST SPANNED RECORD AREA
         ST    R1,HOLDPTR
         A     R1,SAVHOLDL         POINT PAST HOLD AREA
         ST    R1,CHKPTTOP
         XC    0(16,R1),0(R1)      FIRST ENTRY IN TABLE
         XC    DEBLOCKS(12),DEBLOCKS
         XC    OFFSET,OFFSET
         LH    R0,SCROWS1+2        LINES PER PAGE SCREEN 1
         CLI   SPLIT,2             AM I ON SCREEN 2
         BNE   *+8                 NO
         LH    R0,SCROWS2+2        LINES PER PAGE SCREEN2
         LA    R15,4
         SR    R0,R15
         ST    R0,SCROLL
         SLR   R0,R0
         ST    R0,FNDNUM
         STH   R0,FNDOFF
         ST    R0,CHKPTBOT
         MVI   CAPSASIS,C'C'      DEFAULT IS CAPS
*
         CLI   JESFLAG,0          IS THIS A JES DSID?
         BNE   HOLDINIT           NOPE
*
         LA    R2,HEXFOX           INDICATE END OF BLOCK
         SR    R1,1
         SR    R0,0
         STM   R0,R2,DEBLOCKS
*
************************************************************
*                                                          *
*         INITIALIZE HOLD AREA DIRECTORY                   *
*                                                          *
************************************************************
HOLDINIT DS    0H
         LA    R7,HOLDDIR
         SLR   R0,R0
         L     R15,HOLDPTR
         TM    TSTRECFM,X'40'      RECFM V
         BZ    *+8                 NO
         LA    R15,4(,R15)         YES, POINT 4 BYTES INTO EACH RECORD
         L     R8,SCROWS           MAX ROWS PER SCREEN
HOLDLOOP ST    R0,BRDIRNUM(,R7)    PUT ZERO IN RECORD LENGTH
         ST    R0,DIRLEN(,R7)      PUT ZERO IN RECORD NUMBER
         ST    R15,DIRREC(,R7)     STORE ADDRESS OF HELD RECORD
         A     R15,SAVLRECL        POINT TO NEXT HELD RECORD
         LA    R1,DIRSIZ(,R7)      POINT TO NEXT ENTRY
         ST    R1,DIRNXT(,R7)      STORE ITS ADDRESS IN THIS ENTRY
         LR    R14,R7              SAVE LAST ENTRY
         LR    R7,R1               MAKE NEXT ENTRY THIS ENTRY
         BCT   R8,HOLDLOOP         DO IT FOR ALL BUT LAST ENTRY
         LA    R1,HOLDDIR          ADDRESS OF FIRST ENTRY
         ST    R1,DIRNXT(,R14)     CLOSE THE CIRCLE
         ST    R1,HOLDTOP          START WITH FIRST AS TOP
*
         BAL   R14,FILLHOLD
         B     FILLSCR
*
************************************************************
*                                                          *
*         READ ENOUGH RECORDS TO FILL HOLD AREA            *
*                                                          *
************************************************************
*
FILLHOLD ST    R14,HOLDR
         L     R6,HOLDPTR
         LR    R0,R6
         L     R1,SAVHOLDL
         SLR   R14,R14
         L     R15,=A(X'40000000')
         MVCL  R0,R14              FILL HOLD AREA WITH BLANKS
         L     R7,HOLDTOP          POINT TO HOLD AREA DIRECTORY
         LH    R8,SCROWS1+2        NUMBER OF DATA LINES PER SCREEN
HILLOOP  EQU   *
         BAL   R14,GET
         LA    R0,1                COMPUTE
         A     R0,COUNT             THE
         ST    R0,COUNT              RECORD NUMBER
         ST    R0,BRDIRNUM(,R7)    STORE THE RECORD NUMBER
         ST    R1,DIRLEN(,R7)      LENGTH IN DIRECTORY
         LTR   R1,R1               END OF FILE
         BM    HILLED              YES BRANCH
         C     R1,SAVLRECL         IS RECORD LONGER THAN MAX
         BNH   *+8                 NO, SKIP NEXT INSTR
         L     R1,SAVLRECL         YES, TRUNCATE TO MAX
         LR    R0,R2               ADDRESS TO MOVE FROM
         L     R14,DIRREC(,R7)     ADDRESS TO MOVE TO
         TM    TSTRECFM,X'40'      RECFM V
         BZ    HILLNOTV            NO
         SH    R14,=H'4'           YES, MOVE TO PTR MINUS 4
         L     R15,DIRLEN(,R7)
         SH    R15,=H'4'
         ST    R15,DIRLEN(,R7)
HILLNOTV LR    R15,R1              LENGTH FOR MOVE
         MVCL  R14,R0
         LR    R1,R7               SAVE PTR TO MOST CURRENT ENTRY
         L     R7,DIRNXT(,R7)      POINT TO NEXT DIRECTORY ENTRY
         BCT   R8,HILLOOP
         LR    R7,R1               GET MOST CURRENT ENTRY
HILLED   EQU   *
         ST    R7,HOLDEND          SAVE LAST RECORD ENTRY
         L     R14,HOLDR
         BR    R14
SAV3     DS    3F
*
************************************************************
*                                                          *
*         SET UP THE SCREEN HEADER LINE 1                  *
*                                                          *
************************************************************
*
FILLSCR  DS    0H
*
         LA    R15,TERMOUT+16    FIRST DATA LINE ADDRESS
         LA    R1,TERMOUT+4      POINT TO START
*
         CLI   SPLIT,2           AM I ON SCREEN 2?
         BNE   BROSHOW1          NOPE, JUST GO DO IT
*
         L     R14,SCROWS1       PICK UP NUMBER OF ROWS ON SCRN1
         SLL   R14,2             MULTIPLY BY 4
         LA    R1,TERMOUT+4(R14) POINT TO START
         LA    R15,12(,R1)       FIRST DATA LINE ADDRESS
*
BROSHOW1 DS    0H
*
         ST    R1,TERMTOP        FIRST ROW
         ST    R15,TERMDATA      FIRST DATA ROW ADDRESS
*
         NI    0(R1),X'7F'       NOT LAST PARM
         NI    4(R1),X'7F'       NOT LAST PARM
         NI    8(R1),X'7F'       NOT LAST PARM
*
         L     R14,0(,R1)        PICK UP ADDRESS OF LINE 1
*
         MVC   0(SCREENL,R14),SCREEN SET LINE 1 OF HEADING
         MVC   3(44,R14),EDTDSN  MOVE IN DSN
*
*
         LA    R15,SCRCOL-SCREEN(,R14)
         MVC   0(8,R15),=CL8' '
         LH    R1,OFFSET
         LA    R1,1(,R1)
         LA    R0,79(,R1)
         TM    MODE,MODEX
         BZ    *+8
         SH    R0,=H'40'
         CH    R0,RECSIZE
         BNH   *+8
         LH    R0,RECSIZE
         CVD   R1,DOUBLE
         OI    DOUBLE+7,X'0F'
         CH    R1,=H'1000'
         BL    FILL3DIG
         UNPK  0(4,R15),DOUBLE+5(3)
         CVD   R0,DOUBLE
         OI    DOUBLE+7,X'0F'
         UNPK  5(3,R15),DOUBLE+6(2)
         B     BRHEAD2
FILL3DIG UNPK  0(3,R15),DOUBLE+6(2)
         CVD   R0,DOUBLE
         OI    DOUBLE+7,X'0F'
         UNPK  4(3,R15),DOUBLE+6(2)
BRHEAD2  EQU   *
*
************************************************************
*                                                          *
*         SET UP THE COMMAND LINE                          *
*                                                          *
************************************************************
*
         L     R1,TERMTOP        FIRST ROW
         LA    R1,4(,R1)         POINT TO SECOND ROW
         L     R14,0(,R1)        PICK UP ADDRESS OF LINE 2
*
         MVC   0(81,R14),BROHEAD2
         B     FILLCOLX
*
BROHEAD2 DC    AL1(80)
         DC    X'05'
         DC    CL19'COMMAND INPUT ===> '
         DC    X'01'
         DC    CL40' '
         DC    X'05'
         DC    CL13' SCROLL ===> '
         DC    X'01'
         DC    CL5'PAGE'
*
FILLCOLX DS    0H
*
************************************************************
*                                                          *
*         SET UP THE COLUMN HEADER LINE2                   *
*                                                          *
************************************************************
*
*               IT WOULD BE MORE EFFICIENT TO DO MOST OF THIS WORK
*               ONLY WHEN THE OFFSET IS INITIALIZED OR CHANGED
*               AND SAVE THE RESULTS.
*
*
         L     R1,TERMTOP        FIRST ROW
         LA    R1,8(,R1)         POINT TO THIRD  ROW
         L     R14,0(,R1)        PICK UP ADDRESS OF LINE 3
*
         MVI   0(R14),X'50'      SET LENGTH =79
         MVI   1(R14),C' '
         MVC   2(79,R14),1(R14)
         MVI   1(R14),X'05' ATTRIBUTES
*
         LA    R6,2(,R14)
         L     R1,BRDIRNUM(,R7)    GET NUMBER OF FIRST LINE
         CVD   R1,DOUBLE
         OI    DOUBLE+7,X'0F'
         UNPK  73(5,R6),DOUBLE+5(3)
*
         MVI   0(R6),C' '
         MVC   1(79,R6),0(R6)
         LH    R1,OFFSET
         LTR   R1,R1               IS OFFSET ZERO
         BNZ   *+8                 NO
         MVI   0(R6),C'1'          YES, SPECIAL CASE, 1
         SR    R0,R0
         LA    R14,10
         DR    R0,R14
         SR    R14,R0              10 MINUS REMAINDER
         LTR   R0,R0               WAS REMAINDER 0
         BZ    *+6                 YES, USE 0, NOT 10
         LR    R0,R14
*
         LR    R14,R6
         AR    R14,R0              ADD (0 TO 9) TO LINE
         BCTR  R14,0               START AT LINE-1 FOR OFFSET 0
*                                  LINE+8 FOR OFFSET 1
*                                  LINE+7 FOR OFFSET 2
*                                  LINE+6 FOR OFFSET 3
*                                  LINE+0 FOR OFFSET 9
         LH    R1,OFFSET
         AR    R1,R0               ADD (0 TO 9) TO OFFSET
         LA    R0,9
COLNUML  CH    R1,RECSIZE
         BH    COLNUMX
         CVD   R1,DOUBLE
         MVC   COLNUM,=X'402020202120'
         ED    COLNUM,DOUBLE+5
         CH    R1,=H'10000'        10000-32768
         BNL   COLNUMN             YES, USE NNNNN
*        MVC   COLNUM(5),COLNUM+1
*        MVI   COLNUM+5,C' '
*        CH    R1,=H'1000'         1000-9999
*        BNL   COLNUMN             YES, USE NNNNX
         MVC   COLNUM(5),COLNUM+1
         MVI   COLNUM+5,C' '
         CH    R1,=H'100'          100-999
         BNL   COLNUMN             YES, USE XNNNX
         MVC   COLNUM(5),COLNUM+1  USE XNNXX
         MVI   COLNUM+5,C' '
COLNUMN  EQU   *
         SH    R14,=H'2'
         CR    R14,R6
         BL    *+10
         MVC   0(5,R14),COLNUM+1
         LA    R14,12(,R14)
         AH    R1,=H'10'
         BCT   R0,COLNUML
COLNUMX  EQU   *
*
*      DONE SETTING UP THE COLUMNS, NOW SET THE "+++++" MARKS
*
         L     R5,TERMDATA       FIRST ROW
*
         NI    0(R5),X'7F'  NOT LAST PARM
*
         L     R6,0(,R5)    PICK UP TERMOUT POINTER
*
         MVI   0(R6),C' '
         MVC   1(84,R6),0(R6)      FILL LINE WITH BLANKS
         MVC   0(3,R6),=X'5105'
         LA    R6,3(,R6)           POINT TO DATA LINE
*
         LH    R1,OFFSET
         SR    R0,R0
         LA    R14,10
         DR    R0,R14
         LR    R1,R0
         LA    R14,MARKS(R1)
         LH    R1,RECSIZE
         SH    R1,OFFSET
         CH    R1,=H'80'
         BL    MARKE
         MVC   00(80,R6),0(R14)
         B     MARKX
MARKE    MVI   00(R6),C' '
         MVC   01(79,R6),00(R6)
         BCTR  R1,0
         B     *+10
         MVC   00(00,R6),0(R14)
         EX    R1,*-6
MARKX    EQU   *
*
************************************************************
*                                                          *
*         FILL IN THE DATA AREA OF THE SCREEN              *
*                                                          *
************************************************************
*
         L     R7,HOLDTOP
         L     R8,SCROWS1         PICK UP NUMBER OF ROWS
         CLI   SPLIT,2           AM I IN SPLIT SCREEN
         BNE   *+8               NOPE, JUST GO DO IT
         L     R8,SCROWS2        MUST BE SCREEN 2
*
         LA    R1,4               SUBTRACT FIRST 4 ROWS
         SR    R8,R1   MAX LINES ON SCREEN
*
FILLOOP  EQU   *
*
         NI    0(R5),X'7F'  NOT LAST PARM
         LA    R5,4(,R5)
*
         L     R6,0(,R5)    PICK UP TERMOUT POINTER
*
         MVI   0(R6),C' '
         MVC   1(80,R6),0(R6)      FILL LINE WITH BLANKS
         MVC   0(2,R6),=X'5004'
         LA    R6,2(,R6)           BUMP PAST LENGTH AND ATTRIB
*
*
         LM    R1,R2,DIRLEN(R7)    GET LENGTH AND ADDRESS
         LTR   R1,R1
         BM    FILBOT
         BZ    FILNUL              BRANCH IF R1 ZERO
         SH    R1,OFFSET           IS OFFSET BEYOND END OF RECORD
         BNP   FILLNEXT            YES, LEAVE LINE BLANK
         AH    R2,OFFSET
         TM    MODE,MODEX
         BO    FILLHEX
         CH    R1,=H'80'
         BNH   *+8
         LA    R1,80
         BCTR  R1,0
         B     *+10
         MVC   0(0,R6),0(R2)
         EX    R1,*-6
CAPSTST1 DS    0H
         CLI   CAPSASIS,C'C'       CAPS
         BE    CAPSTRT
ASISTRT  DS    0H
         TR    0(80,R6),ASIST
         B     FILLNEXT
CAPSTRT  DS    0H
         TR    0(80,R6),CAPST
         B     FILLNEXT
FILLHEX  CH    R1,=H'40'
         BNH   *+8
         LA    R1,40
         LR    R0,R1
         LR    R1,R2
         LR    R15,R6
         BAL   R14,HEX
         B     FILLNEXT
FILNUL   MVC   0(6,R6),=C'(NULL)'
FILLNEXT DS    0H
         L     R7,DIRNXT(,R7)
         BCT   R8,FILLOOP
         B     FILLED
FILBOT   MVI   0(R6),C'*'
         MVC   1(79,R6),0(R6)
         MVC   32(16,R6),=C' BOTTOM OF DATA '
FILLED   EQU   *
*
         CLI   SPLIT,1           AM I ON SCREEN 1
         BE    BROCOMM           YES, DON'T SET PARM FLAG
         OI    0(R5),X'80'  SET LAST PARM
         B     BROCOMM          GO SHOW THE SCREEN
*
BROCOMM  DS    0H
PROMPT   DS    0H
*
         L     R15,=A(BROHELP)     DEFAULT HELP SCREEN
         ST    R15,HELPADD
*
         MVI   AIDROW,1
         MVI   AIDCOL,21
         MVC   HOMEAID(2),AIDADDR
*
         L     R15,COMMA4
         BALR  R14,R15
*
         LTR   R15,15                   BAD RC
         BNZ   END                      OUT
*
*                                  SCREEN MAY HAVE CHANGED
*
         LH    R0,SCROWS1+2        LINES PER PAGE SCREEN 1
         CLI   SPLIT,2             AM I ON SCREEN 2
         BNE   *+8                 NO
         LH    R0,SCROWS2+2        LINES PER PAGE SCREEN2
         LA    R15,4
         SR    R0,R15
         ST    R0,SCROLL
*
************************************************************
*                                                          *
*        CHECK REPLY FROM THE TERMINAL                     *
*                                                          *
************************************************************
*
         L     R2,TERMINPT         POINT TO AID
         CLI   0(R2),X'F3'         PFK 3
         BE    END
         CLI   0(R2),X'C3'         PFK 15
         BE    END
         CLI   0(R2),X'6E'         PA 2
         BE    FILLSCR
         CLI   PFKFLAG,0           PFKEY
         BNE   PFK
*
         L     R3,TERMINPT+8       COMMAND LINE
         CLI   SPLIT,2                  AM I ON SCREEN 2
         BNE   CKPROMP2                 NOPE
         L     R3,SCROWS1          PICK UP SIZE OF SCREEN1
         SLL   R3,2                MULTIPLY BY 4
         L     R3,TERMINPT+8(R3)   PICK UP RESPONSES
*
CKPROMP2 DS    0H
         CLI   0(R3),X'00'         COMMAND ENTERED
         BE    FILLSCR             NOPE, JUST RESHOW THE SCREEN
*
*
* PUT TESTS FOR COMMAND LINE HERE
*
         CLC   22(5,R3),=C'LEFT '
         BE    LEFT
         CLC   22(2,R3),=C'< '
         BE    LEFT
         CLC   22(6,R3),=C'RIGHT '
         BE    RIGHT
         CLC   22(2,R3),=C'> '
         BE    RIGHT
         CLC   22(3,R3),=C'UP '
         BE    UP
         CLC   22(2,R3),=C'- '
         BE    UP
         CLC   22(5,R3),=C'DOWN '
         BE    DOWN
         CLC   22(2,R3),=C'D '
         BE    DOWN
         CLC   22(2,R3),=C'+ '
         BE    DOWN
         CLC   22(4,R3),=C'TOP '
         BE    TOP
         CLC   22(7,R3),=C'BOTTOM '
         BE    BOTTOM
         CLC   22(4,R3),=C'BOT '
         BE    BOTTOM
         CLC   22(5,R3),=C'LIST '
         BE    LIST
         CLC   22(2,R3),=C'L '
         BE    LIST
         CLC   22(5,R3),=C'FIND '
         BE    FIND
         CLC   22(2,R3),=C'F '
         BE    FIND
         CLC   22(4,R3),=C'END '
         BE    END
         CLI   22(R3),C'M'          MAX
         BE    PFK
         CLC   22(5,R3),=C'ASIS '
         BE    ASIS
         CLC   22(5,R3),=C'CAPS '
         BE    CAPS
         CLC   22(4,R3),=C'HEX '
         BE    HEXMODE
         LA    R1,MSG20
         ST    R1,MSGADD
         B     FILLSCR
*
************************************************************
*                                                          *
*         INTERPRET PROGRAM FUNCTION KEY                   *
*                                                          *
************************************************************
*
*               NOTE - IF A COMMAND IS TYPED IN THEN
*               IT OVERRIDES THE PF KEY.
PFK      DS    0H
         LA    R14,22(,R3)
         OI    0(R2),X'30'         MAKE PFK 13-24 LOOK LIKE 1-12
         CLI   0(R2),X'F5'        PF5
         BE    FIND
         CLI   0(R2),X'7A'        PF10
         BE    LEFT
         CLI   0(R2),X'7B'        PF11
         BE    RIGHT
         CLI   0(R2),X'F7'        PF7
         BE    UP14
         CLI   0(R2),X'F8'        PF8
         BE    DOWN14
         LA    R1,MSG20
         ST    R1,MSGADD
         B     FILLSCR
NOTPFK   EQU   *
         LA    R1,MSG21
         ST    R1,MSGADD
         B     FILLSCR
************************************************************
*                                                          *
*         RIGHT                                            *
*                                                          *
************************************************************
*
RIGHT    EQU   *
         LA    R15,80
         TM    MODE,MODEX
         BZ    *+8
         LA    R15,40
         LH    R0,OFFSET
         AR    R0,R15
         LH    R1,RECSIZE
         CH    R1,=H'1000'
         BNH   *+8
         LH    R1,=H'1000'
         SR    R1,R15              GET RECSIZE-80
         BNM   *+6                 IF RECSIZE IS LESS THAN 80
         SLR   R1,R1                  THEN RECSIZE-80 IS ZERO
         CR    R0,R1               IF OFFSET+80 GT RECSIZE-80
         BNH   *+6                    THEN
         LR    R0,R1                  USE RECSIZE-80
         STH   R0,OFFSET
         B     FILLSCR
*
************************************************************
*                                                          *
*         LEFT                                             *
*                                                          *
************************************************************
*
LEFT     EQU   *
         LA    R15,80
         TM    MODE,MODEX
         BZ    *+8
         LA    R15,40
         LH    R0,OFFSET
         SR    R0,R15              REDUCE OFFSET BY 80
         BNM   *+6                 IF RESULT IS NEGATIVE
         SLR   R0,R0                  THEN MAKE IT ZERO
         STH   R0,OFFSET
         B     FILLSCR
*
************************************************************
*                                                          *
*         DOWN                                             *
*                                                          *
************************************************************
*
DOWN     EQU   *
         LA    R14,30(,R3)         POINT TO POSSIBLE OPERAND
         CLC   25(5,R3),=C'DOWN '
         BE    *+8
         LA    R14,27(,R3)         POINT TO POSSIBLE OPERAND
*
DOWN14   DS    0H
         CLI   0(R14),X'F0'        NUMERIC
         BL    DOWNDEF             NO, USE DEFAULT RANGE
*
*                                  OK, SOME NUMERIC VALUE WAS
*                                  ENTERED, FIND OUT WHAT IT IS.
*
         LA    R15,1(R14)
         LA    R1,1
*
         CLI   0(R15),C' '         SEARCH FOR END
         BE    *+16
         LA    R1,1(,R1)           BUMP 1
         LA    R15,1(,R15)         BUMP 1
         B     *-16                LOOP
*
         BCTR  R1,0
         EX    R1,PACKBRO          PACK INTO "DOUBLE"
         OI    DOUBLE+7,X'0F'      MAKE POSITIVE
         CVB   R0,DOUBLE           PUT BINARY VALUE IN R0
         B     DOWNRGE             USE RANGE IN R0
*
PACKBRO  PACK  DOUBLE(8),0(1,R14)
*
DOWNDEF  DS    0H
         L     R0,SCROLL
*
DOWNRGE  DS    0H
         ST    R0,DOWNAMT
         BAL   R14,DOWNER
         B     FILLSCR             FILL THE SCREEN
DOWNER   EQU   *
*
*              SEE IF EOF IS ON SCREEN AND WOULD BE FORCED OFF
*
         LA    R15,4
         L     R7,HOLDEND          POINT TO ENTRY FOR LAST RECORD
         TM    DIRLEN(R7),X'80'    IS EOF ON SCREEN
         BZ    DOWNNEOF            NO, DOWN IS POSSIBLE
         L     R7,HOLDTOP
         L     R0,DOWNAMT          GET DOWN AMOUNT
         CH    R0,SCROWS1+2        OR SCREEN SIZE IF SMALLER
         BNH   *+8
         LH    R0,SCROWS1+2
DOWNTEST TM    DIRLEN(R7),X'80'    IS THIS END OF DATA
         BO    0(R14)              YES, CANT GO DOWN
         L     R7,DIRNXT(,R7)      GET ENTRY FOR NEXT RECORD
         BCT   R0,DOWNTEST
         L     R7,HOLDEND          POINT TO ENTRY FOR LAST RECORD
DOWNNEOF ST    R14,DOWNR
         L     R8,DOWNAMT          GET NUMBER OF LINES TO GO DOWN
DOWNLOOP L     R15,HOLDTOP         POINT TO TOP ENTRY
         L     R15,DIRNXT(,R15)    GET ADDRESS OF ENTRY AFTER TOP
         ST    R15,HOLDTOP         MAKE IT NEW TOP
         TM    DIRLEN(R7),X'80'    IS EOF ON SCREEN
         BO    DOWNNXT             YES, BYPASS GET
*
*  THERE IS A BUG SOMEWHERE IN THE CODE THAT CLOBBERS THE FIRST
*  HALF-WORD OF DIRNXT.
*
         SR    R14,R14
         CH    R14,DIRNXT(,R7)     IS THIS BABY ZEROS?
         BNE   *+12                NO, IT'S OK.
         LA    R14,DIRSIZ(,R7)     POINT TO NEXT ENTRY
         ST    R14,DIRNXT(,R7)     STORE IT IN THIS ONE
*
         L     R7,DIRNXT(,R7)      POINT TO NEXT ENTRY
         BAL   R14,GET
         LA    R0,1                COMPUTE
         A     R0,COUNT             THE
         ST    R0,COUNT              RECORD NUMBER
         ST    R0,BRDIRNUM(,R7)    STORE THE RECORD NUMBER
         ST    R1,DIRLEN(,R7)      STORE LENGTH
         LTR   R1,R1               END OF FILE
         BM    DOWNX               YES BRANCH
         C     R1,SAVLRECL         IS RECORD LONGER THAN MAX
         BNH   *+8                 NO, SKIP NEXT INSTR
         L     R1,SAVLRECL         YES, TRUNCATE TO MAX
         LR    R0,R2               ADDRESS TO MOVE FROM
         L     R14,DIRREC(,R7)     ADDRESS TO MOVE TO
         TM    TSTRECFM,X'40'      RECFM V
         BZ    DOWNNOTV            NO
         SH    R14,=H'4'           YES, MOVE TO PTR MINUS 4
         L     R15,DIRLEN(,R7)
         SH    R15,=H'4'
         ST    R15,DIRLEN(,R7)
DOWNNOTV L     R15,SAVLRECL        LENGTH OF RECEIVING FIELD
         O     R1,=A(X'40000000')  PAD WITH BLANKS
         MVCL  R14,R0
DOWNNXT  BCT   R8,DOWNLOOP
DOWNX    ST    R7,HOLDEND          NEW END POINTER
         SLR   R15,R15
         L     R14,DOWNR
         BR    R14
*
************************************************************
*                                                          *
*         UP                                               *
*                                                          *
************************************************************
*
UP       EQU   *
         LA    R14,28(,R3)         POINT TO POSSIBLE OPERAND
         CLC   25(3,R3),=C'UP '
         BE    *+8
         LA    R14,27(,R3)         POINT TO POSSIBLE OPERAND
*
UP14     DS    0H
         CLI   0(R14),X'F0'        NUMERIC
         BL    UPDEF               NO, USE DEFAULT RANGE
*
*                                  OK, SOME NUMERIC VALUE WAS
*                                  ENTERED, FIND OUT WHAT IT IS.
*
         LA    R15,1(R14)
         LA    R1,1
*
         CLI   0(R15),C' '         SEARCH FOR END
         BE    *+16
         LA    R1,1(,R1)           BUMP 1
         LA    R15,1(,R15)         BUMP 1
         B     *-16                LOOP
*
         BCTR  R1,0
         EX    R1,PACKBRO          PACK INTO "DOUBLE"
         OI    DOUBLE+7,X'0F'      MAKE POSITIVE
         CVB   R0,DOUBLE           PUT BINARY VALUE IN R0
         B     UPRANGE             USE RANGE IN R0
*
UPDEF    DS    0H
         L     R0,SCROLL
*
UPRANGE  DS    0H
         ST    R0,DOWNAMT
         L     R7,HOLDTOP
*
*  "HOLDTOP" SOMEHOW GETTING SET TO ZEROS, DON'T KNOW WHERE
*
         LTR   R7,7                IS IT ZEROS
         BNZ   UPTOPOK             NO, IT'S OK
         L     R7,HOLDEND          NO, IT'S OK
         LA    R7,16(,7)           BUMP TO NEXT ENTRY
         ST    R7,HOLDTOP          RESET IT
*
UPTOPOK  DS    0H
         CLC   BRDIRNUM(4,R7),=F'1' ARE WE AT TOP ALREADY
         BNH   FILLSCR             YES, BRANCH
         TM    DIRLEN(R7),X'80'    IS FIRST LINE EOF
         BZ    UPTOP               NO, BRANCH
         NC    COUNT,COUNT         IS DATA SET EMPTY
         BZ    FILLSCR             YES, BRANCH
UPTOP    EQU   *
         L     R0,BRDIRNUM(,R7)    GET RECORD NUMBER OF TOP LINE
         S     R0,DOWNAMT          GET RECORD NUMBER TO GO BACK TO
         BP    *+8                 IF NEGATIVE
         LA    R0,1                   THEN MAKE IT 1
         B     LISTAT
*
************************************************************
*                                                          *
*         TOP                                              *
*                                                          *
************************************************************
*
TOP      EQU   *
         L     R1,CHKPTTOP
         CLI   JESFLAG,0           DOING JES
         BE    TOPJES
         MVC   TTR,4(R1)           TTR OF FIRST BLOCK
         MVC   TTRZ(3),TTR         TTR OF FIRST BLOCK
         POINT (R4),TTRZ
         XC    DEBLOCKS(12),DEBLOCKS
         B     TOPGOT
TOPJES   DS    0H
         MVC   JESMTTR(4),TOPMTTR  TTR OF FIRST BLOCK
         LA    R2,HEXFOX           INDICATE END OF BLOCK
         SR    R1,1
         SR    R0,0
         STM   R0,R2,DEBLOCKS
TOPGOT   DS    0H
         XC    COUNT,COUNT
         L     R14,SPANPTR
         SLR   R0,R0
         STH   R0,0(,R14)          RESET SPAN BUFFER LENGTH
         ST    R0,FNDNUM           RESET LAST-FOUND NUMBER
         STH   R0,FNDOFF           RESET LAST-FOUND OFFSET
         BAL   R14,FILLHOLD
         B     FILLSCR
HEXFOX   DC    X'FF'
*
************************************************************
*                                                          *
*         BOTTOM                                           *
*                                                          *
************************************************************
*
BOTTOM   DS    0H
         L     R0,BOTNINES
         B     LISTAT
BOTRET   L     R0,SCROLL
         B     UPRANGE
*
************************************************************
*                                                          *
*         LIST                                             *
*                                                          *
************************************************************
*
LIST     EQU   *
         B     ERRMISS             NO, MISSING OPERAND
*        LA    R15,OPD1            GET FIRST OPERAND ENTRY
         TM    6(R15),PRESENT      ARE THERE ANY OPERANDS
         BZ    ERRMISS             NO, MISSING OPERAND
         TM    6(R15),QUOTED       IS OPERAND QUOTED
         BO    ERRINV              YES, INVALID
         LH    R1,4(,R15)          GET LENGTH
         LTR   R1,R1               IS IT NULL STRING
         BZ    ERRINV              YES, ERROR
         CH    R1,=H'7'            IS LENGTH MORE THAN 7
         BH    ERRINV              YES, ERROR
         L     R14,0(,R15)         GET ADDRESS OF DATA
         BCTR  R1,0
         B     *+10
         TRT   0(0,R14),NUMERIC
         EX    R1,*-6              IS IT NUMERIC
         BNZ   ERRINV              NO, ERROR
         B     *+10
         PACK  DOUBLE(8),0(0,R14)
         EX    R1,*-6
         CVB   R1,DOUBLE
         LTR   R0,R1
         BZ    TOP
*
LISTAT   ST    R0,LISTNUM
         AH    R0,SCROWS1+2        GET RECORD NUMBER TO READ UP TO
         BCTR  R0,0
         ST    R0,AIMFOR           SAVE FOR DOWNTO
*
         LA    R15,20              LENGTH OF CHKPT ENTRY
         L     R1,CHKPTBOT
         TM    0(R1),X'80'         IS IT EOF
         BZ    LISTNB
         C     R1,CHKPTTOP         IS DATA SET EMPTY
         BE    FILLSCR             YES
         SR    R1,R15              NO, BACK UP ONE ENTRY
LISTNB   L     R0,LISTNUM
LISTCK   C     R0,0(,R1)           DOES THIS BLOCK PRECEDE OUR RECORD
         BH    LISTPNT             YES, GO POINT TO IT
         SR    R1,R15              NO, BACK UP ONE BLOCK ENTRY
         L     R14,CHKPTTOP        POINT TO CHECKPOINT
         CR    R1,R14              HAVE I BACKED UP TO TOP?
         BNH   LISTPNT             YES, GO POINT TO IT
         B     LISTCK
LISTPNT  MVC   COUNT,0(R1)
         MVC   DEBLOCKS(12),8(R1)
         MVC   TTR,4(R1)           TTR OF FIRST BLOCK
         MVC   TTRZ(3),TTR
         CLI   JESFLAG,0           JES DSID?
         BE    LISTNPNT            YES, DON'T DO POINT
         POINT (R4),TTRZ
         B     LISTNJES
LISTNPNT DS    0H
*
         CLC   4(4,R1),FZEROS     IS THIS A VALID BLOCK MTTR?
         BNE   *+14               ASSUME SO
         MVC   JESMTTR(4),TOPMTTR ELSE RESET TO TOP OF DSID
         B     *+10               AND SKIP CHECKPOINT MTTR
         MVC   JESMTTR(4),4(R1)   TTR OF FIRST BLOCK
*
         LA    R2,HEXFOX           INDICATE END OF BLOCK
         SR    R1,1
         SR    R0,0
         STM   R0,R2,DEBLOCKS
LISTNJES DS    0H
         L     R14,SPANPTR
         SLR   R0,R0
         STH   R0,0(,R14)          RESET SPAN BUFFER LENGTH
         ST    R0,FNDNUM           RESET LAST-FOUND NUMBER
         STH   R0,FNDOFF           RESET LAST-FOUND OFFSET
*
         BAL   R14,FILLHOLD        READ NEXT 20 RECORDS
*
LISTFINE L     R7,HOLDTOP          GET ENTRY FOR TOP OF HOLD AREA
         TM    DIRLEN(R7),X'80'    IS EOF ON TOP OF SCREEN
         BO    LISTRDY             YES, WE ARE FINISHED
         CLC   LISTNUM,BRDIRNUM(R7) IS REQUESTED NUMBER AT TOP
         BNH   FILLSCR             YES, BRANCH
         MVC   DOWNAMT,=F'1'       DOWN 1
         BAL   R14,DOWNER
         B     LISTFINE
LISTRDY  CLC   LISTNUM,BOTNINES    WAS THIS A LIST 99999999
         BE    BOTRET              YES, BRANCH
         B     FILLSCR
ERRMISS  DS    0H
         LA    R1,MSG35
         ST    R1,MSGADD
         B     FILLSCR
*
************************************************************
*                                                          *
*         FIND                                             *
*                                                          *
************************************************************
*
FIND     EQU   *
         MVI   FINDSW,0
         B     FINDSAME            NO, USE PREVIOUS STRING
*        LA    R15,OPD1            GET FIRST OPERAND ENTRY
         TM    6(R15),PRESENT      ARE THERE ANY OPERANDS
         BZ    FINDSAME            NO, USE PREVIOUS STRING
         XC    STRING,STRING       ERASE OLD STRING
         SLR   R0,R0
         ST    R0,FNDNUM           RESET LAST-FOUND NUMBER
         STH   R0,FNDOFF           RESET LAST-FOUND OFFSET
         STH   R0,FINDCOL          RESET COLUMN
         LH    R1,4(,R15)          GET LENGTH
         LTR   R1,R1               IS IT NULL STRING
         BZ    FINDNULL            YES, ERROR
         L     R14,0(,R15)         GET ADDRESS OF DATA
         BCTR  R1,0
         STH   R1,STRINGL          SAVE LENGTH CODE
         B     *+10
         MVC   STRING(0),0(R14)
         EX    R1,*-6
         B     FINDSAME            NO, LEAVE FINDCOL NULL
*        LA    R15,OPD2
         TM    6(R15),PRESENT      IS THERE A SECOND OPERAND
         BZ    FINDSAME            NO, LEAVE FINDCOL NULL
         TM    6(R15),QUOTED       IS OPERAND QUOTED
         BO    ERRINV              YES, INVALID
         LH    R1,4(,R15)          GET LENGTH
         LTR   R1,R1               IS IT NULL STRING
         BZ    ERRINV              YES, ERROR
         CH    R1,=H'3'            IS LENGTH MORE THAN 3
         BH    ERRINV              YES, ERROR
         L     R14,0(,R15)         GET ADDRESS OF DATA
         BCTR  R1,0
         B     *+10
         TRT   0(0,R14),NUMERIC
         EX    R1,*-6              IS IT NUMERIC
         BNZ   ERRINV              NO, ERROR
         B     *+10
         PACK  DOUBLE(8),0(0,R14)
         EX    R1,*-6
         CVB   R1,DOUBLE
         LTR   R1,R1               IS IT ZERO
         BZ    ERRINV              YES, ERROR
         C     R1,SAVLRECL         IS IT GREATER THAN LRECL
         BH    ERRINV              YES, ERROR
         STH   R1,FINDCOL
FINDSAME EQU   *
         NC    STRING,STRING       HAS A STRING BEEN ENTERED
         BZ    FINDNULL            NO, ERROR
         LH    R6,FINDCOL
         L     R7,HOLDTOP          GET INFO FOR FIRST HELD RECORD
         L     R0,BRDIRNUM(,R7)    GET RECORD NUMBER OF FIRST HELD
         L     R1,FNDNUM           GET RECORD NUMBER WHERE LAST FOUND
         LTR   R1,R1               HAS IT BEEN FOUND
         BNP   FINDSCR             NO, START WITH HELD RECORDS
         CR    R0,R1               ARE WE PAST LAST FOUND REC
         BH    FINDSCR             YES, START WITH HELD RECORDS
         L     R14,HOLDEND
         L     R15,BRDIRNUM(,R14)  GET RECORD NUMBER OF LAST HELD
         CR    R1,R15              IS LAST FOUND REC ON SCREEN
         BH    FINDDOWN            NO, BRANCH
FINDPREV C     R1,BRDIRNUM(,R7)    IS THIS RECORD WHERE LAST FOUND
         BE    FINDPCOL            YES, BRANCH
         C     R7,HOLDEND          IS THIS LAST RECORD ON SCREEN
         BE    FINDDOWN            SHOULD NOT HAPPEN
         L     R7,DIRNXT(,R7)      POINT TO NEXT RECORD
         B     FINDPREV
FINDPCOL L     R15,DIRREC(,R7)     POINT TO RECORD
         LTR   R6,R6               WAS A COLUMN SPECIFIED
         BZ    FINDPOFF            NO, LOOK AT SAME RECORD
         C     R7,HOLDEND          IS THIS LAST RECORD ON SCREEN
         BE    FINDDOWN            YES, BRANCH
         L     R7,DIRNXT(,R7)      NO, POINT TO NEXT RECORD
         B     FINDSCR             GO EXAMINE RECORD
FINDPOFF AH    R15,FNDOFF          POINT TO LAST FOUND STRING
         LA    R15,1(,R15)         POINT PAST LAST FOUND STRING
         B     FINDSTR
FINDCLC  CLC   0(0,R15),STRING     (EXECUTED)
FINDSCR  TM    DIRLEN(R7),X'80'    ARE WE AT EOF
         BO    FINDBOT             YES, BRANCH
         L     R15,DIRREC(,R7)     POINT TO FIRST BYTE TO EXAMINE
         LTR   R6,R6               WAS A COLUMN SPECIFIED
         BZ    FINDSTR             NO, BRANCH
         AR    R15,R6              YES, POINT TO COLUMN PLUS 1
         BCTR  R15,0               POINT TO COLUMN
         LH    R14,STRINGL
         EX    R14,FINDCLC
         BE    FOUND
         B     FINDNEXT
FINDSTR  L     R0,DIRLEN(,R7)      GET LENGTH OF RECORD
         C     R0,SAVLRECL         IS RECORD TRUNCATED
         BNH   *+8                 NO, SKIP NEXT INSTR
         L     R0,SAVLRECL         YES, USE TRUNCATED LENGTH
         L     R1,DIRREC(,R7)      GET ADDRESS OF RECORD
         AR    R0,R1               POINT PAST LAST BYTE OF RECORD
         LH    R14,STRINGL         GET LENGTH CODE OF STRING
         AR    R15,R14             POINT TO LAST BYTE TO BE COMPARED
         SR    R0,R15              GET NUMBER OF COMPARISONS
         BNP   FINDNEXT            STRING TOO LONG FOR REMAINING TEXT
         SR    R15,R14             PUT STRING ADDRESS BACK
FINDCOMP EX    R14,FINDCLC         COMPARE STRING TO DATA
         BE    FOUND
         LA    R15,1(,R15)         INCREMENT DATA POINTER
         BCT   R0,FINDCOMP         GO COMPARE AGAIN
FINDNEXT C     R7,HOLDEND          WAS THAT LAST HELD RECORD
         BE    FINDDOWN            YES, BRANCH
         L     R7,DIRNXT(,R7)      POINT TO NEXT RECORD
         B     FINDSCR             GO PROCESS NEXT RECORD
FINDBOT  EQU   *
         LA    R1,MSG32
         ST    R1,MSGADD
         B     FILLSCR
FINDDOWN EQU   *
         LA    R1,1
         ST    R1,DOWNAMT
         BAL   R14,DOWNER
         L     R7,HOLDEND
         OI    FINDSW,1
         B     FINDSCR
FINDNULL DS    0H
         LA    R1,MSG33
         ST    R1,MSGADD
         B     FILLSCR
ERRINV   DS    0H
         LA    R1,MSG34
         ST    R1,MSGADD
         B     FILLSCR
FOUND    DS    0H
         LA    R1,MSG31
         ST    R1,MSGADD
         MVC   FNDNUM,BRDIRNUM(R7) SAVE RECORD NUMBER
         S     R15,DIRREC(,R7)     GET OFFSET TO FOUND LOCATION
         STH   R15,FNDOFF          SAVE OFFSET
         LA    R15,1(,R15)         MAKE IT COLUMN NUMBER
         CVD   R15,DOUBLE
         OI    DOUBLE+7,X'0F'
         TM    FINDSW,1
         BZ    FILLSCR
         LH    R6,SCROWS1+2
         SH    R6,=H'2'
FINDLN2  LA    R1,1
         ST    R1,DOWNAMT
         BAL   R14,DOWNER
         BCT   R6,FINDLN2
         B     FILLSCR
************************************************************
*                                                          *
*         HEX                                              *
*                                                          *
************************************************************
*
HEXMODE  EQU   *
         B     HEXFLIP             NO, FLIP FLOP
*        LA    R15,OPD1            GET FIRST OPERAND ENTRY
         TM    6(R15),PRESENT      ARE THERE ANY OPERANDS
         BZ    HEXFLIP             NO, FLIP FLOP
         L     R14,0(,R15)         POINT TO OPERAND
         CLI   5(R15),2            IS LENGTH 2
         BNE   HEXOFF              NO, TRY OFF
         CLC   0(2,R14),=C'ON'     YES, IS IT 'ON'
         BNE   ERRKW               NO, INVALID OPERAND
         OI    MODE,MODEX
         B     FILLSCR
HEXOFF   CLI   5(R15),3            IS LENGTH 3
         BNE   ERRKW
         CLC   0(3,R14),=C'OFF'
         BNE   ERRKW
         NI    MODE,255-MODEX
         B     FILLSCR
HEXFLIP  XI    MODE,MODEX          FLIP FLOP THE SWITCH
         B     FILLSCR
ERRKW    DS    0H
         LA    R1,MSG34
         ST    R1,MSGADD
         B     FILLSCR
*
************************************************************
*                                                          *
*         CAPS / ASIS                                      *
*                                                          *
************************************************************
*
CAPS     MVI   CAPSASIS,C'C'
         B     FILLSCR
*
ASIS     MVC   CAPSASIS,C'A'
         B     FILLSCR
************************************************************
*                                                          *
*         SUBROUTINE TO CONVERT DATA TO HEX                *
*                                                          *
************************************************************
*
HEX      MVC   1(1,R15),0(R1)      MOVE BYTE
         UNPK  0(3,R15),1(2,R15)   UNPACK
         TR    0(2,R15),HEXTAB-240
         LA    R15,2(,R15)         INCREMENT OUTPUT PTR
         LA    R1,1(,R1)           INCREMENT INPUT PTR
         BCT   R0,HEX              DECREMENT LENGTH, THEN LOOP
         MVI   0(R15),C' '         BLANK THE TRAILING BYTE
         BR    R14                 RETURN TO CALLER
*
HEXTAB   DC    C'0123456789ABCDEF' TRANSLATE TABLE
         EJECT
************************************************************
*                                                          *
*         SUBROUTINE TO GET A LOGICAL RECORD               *
*                                                          *
************************************************************
*
*
*               INPUT
*                R4 DCB ADDRESS
*                CHKPTTOP  -  TOP OF CHECKPOINT TABLE
*                CHKPTBOT  -  BOTTOM OF CHECKPOINT TABLE, ZERO 1ST TIME
*                COUNT     -  LAST LOGICAL RECORD NUMBER READ
*                BLOCKPTR  -  ADDRESS OF BUFFER
*                DEBLOCKS  -  DEBLOCKING INFO (ZEROS FIRST TIME)
*                SPANPTR   -  ADDRESS OF AREA TO COMBINE
*                             SPANNED RECORD SEGMENTS
*
*               OUTPUT
*                 R1 CONTAINS LENGTH OF RECORD (OR -1 IF END OF FILE)
*                 R2 CONTAINS ADDRESS OF RECORD (OR 0 IF END OF FILE)
*
GET      ST    R14,READR
         STM   R6,R7,JESRSAV1 I AM GOING TO CLOBBER THESE REGS
         LM    R0,R2,DEBLOCKS      GET DEBLOCKING STATUS
         CLI   JESFLAG,X'00'              IS IT A JES DSID
         BE    READJB                     YES
         TM    WRKRECFM,X'10'      BLOCKED
         BZ    READI               NO, BRANCH
         AR    R2,R1               POINT TO NEXT RECORD
         CR    R2,R0               END OF BLOCK (OR FIRST TIME)
         BNL   READI               YES, BRANCH
         TM    TSTRECFM,X'40'      VARIABLE LENGTH
         BO    READVB              YES, BRANCH
         ST    R2,DEBLOCKS+8       FIXED BLOCKED
         B     READX
READI    L     R5,CHKPTBOT         GET LAST CHECKPOINT
         LTR   R5,R5               IS THIS FIRST READ
         BNZ   READNF              BRANCH IF NOT FIRST
         L     R5,CHKPTTOP
         B     READNEW             READING A RECORD NOT READ BEFORE
READNF   L     R1,0(,R5)           GET NUMBER OF HIGHEST RECORD READ
         LTR   R1,R1               WAS IT EOF
         BM    READOLD             YES, BRANCH
         C     R1,COUNT            HAVE WE READ THIS RECORD BEFORE
         BNH   READADD             NO, BRANCH
READOLD  LA    R5,CHKPTDUM         YES, DONT CHANGE CHKPT TABLE
         B     READBRO
READADD  LA    R5,20(,R5)          ADD AN ENTRY TO THE CHKPT TABLE
         C     R5,ENDPTR           IS TABLE FILLED UP
         BL    *+8                 NO, SKIP NEXT INSTR
         BAL   R14,READHALF        YES, HALVE THE TABLE
READNEW  ST    R5,CHKPTBOT         SAVE NEW CURRENT CHECKPOINT POINTER
         MVC   0(4,R5),COUNT
         XC    4(4,R5),4(R5)
         MVC   8(12,R5),DEBLOCKS
READBRO  TM    STATUS,STNOMEM      ARE WE IN MEMBER-NOT-FOUND STATUS
         BO    DYNEOD              YES, JUST GO TO END OF FILE
         L     R2,BLOCKPTR
         READ  DYNDECBW,SF,(R4),(R2),'S',MF=E
         CHECK DYNDECBW
         CLI   SYNADSW,0           WAS SYNAD EXIT TAKEN?
         BNE   IOERR               YES, BRANCH
         LH    R1,DCBBLKSI
         L     R14,DYNDECBW+16
         SH    R1,14(,R14)         SUBTRACT RESIDUAL COUNT
         TM    TSTRECFM,X'40'      VARIABLE LENGTH RECORDS
         BZ    OKREAD              NO, BRANCH
         LH    R1,0(,R2)           YES, USE BLKSIZE IN BDW
*        SH    R1,=H'4'                                              $V
*        LA    R2,4(,R2)                                             $V
OKREAD   LA    R0,0(R1,R2)         END OF BLOCK
         STM   R0,R2,DEBLOCKS      SAVE STATUS INFO
         CLC   4(4,R5),=F'0'       IS THIS 2ND READ PER GET
         BNZ   NOTED               YES, BYPASS NOTE
         NOTE  (R4)
         ST    R1,4(,R5)           SAVE TTR IN TABLE
NOTED    EQU   *
         L     R1,DEBLOCKS+4       RESTORE LENGTH
         TM    WRKRECFM,X'10'      BLOCKED?
         BO    READB               YES, BRANCH
         TM    TSTRECFM,X'48'      VARIABLE UNBLOCKED SPANNED
         BNO   READX               NO
         B     READVBS             YES, SAME AS BLOCKED
READB    TM    WRKRECFM,X'C0'      UNDEFINED
         BO    READX
         TM    WRKRECFM,X'40'      VARIABLE LENGTH
         BO    READVBI
READFB   LH    R1,DCBLRECL         FIXED BLOCKED
         ST    R1,DEBLOCKS+4       SAVE STATUS INFO
         B     READX
READVBI  LA    R2,4(,R2)           POINT PAST BDW
READVB   TM    WRKRECFM,X'08'      SPANNED
         BO    READVBS
READVBR  LH    R1,0(,R2)
         STM   R1,R2,DEBLOCKS+4    SAVE STATUS INFO
         B     READX
READVBS  CLI   2(R2),0             SEGMENT
         BE    READVBR             NO, BRANCH
*               THIRD BYTE IS X'01' FOR FIRST SEGMENT
*                             X'03' FOR MIDDLE SEGMENT
*                             X'02' FOR LAST SEGMENT
         CLI   2(R2),1             FIRST SEGMENT
         BNE   READSEG2
         L     R14,SPANPTR         ADDRESS TO MOVE TO
         LH    R15,0(,R2)          LENGTH TO MOVE
         LR    R1,R15              LENGTH TO MOVE
         LR    R0,R2               ADDRESS TO MOVE FROM
         MVCL  R14,R0              MOVE SEGMENT RDW AND DATA
         B     READSEGD            GO DEBLOCK NEXT SEGMENT
READSEG2 L     R14,SPANPTR         ADDRESS OF PRIOR SEGMENTS
         LH    R0,0(,R14)          LENGTH OF PRIOR SEGMENTS
         LH    R15,0(,R2)          LENGTH+4 OF NEW SEGMENT
         SH    R15,=H'4'           LENGTH OF NEW SEGMENT
         LR    R1,R15              LENGTH TO BE MOVED
         AR    R15,R0              COMBINE LENGTHS
         STH   R15,0(,R14)         STORE COMBINED LENGTHS
         LR    R15,R1              LENGTH TO ME MOVED
         AR    R14,R0              ADDRESS TO MOVE TO
         LA    R0,4(,R2)           ADDRESS TO MOVE FROM
         MVCL  R14,R0              MOVE SEGMENT DATA
         CLI   2(R2),2             LAST SEGMENT
         BNE   READSEGD            NO, GO DEBLOCK NEXT SEGMENT
         LH    R1,0(,R2)           GET LENGTH OF THIS SEGMENT
         STM   R1,R2,DEBLOCKS+4    SAVE LENGTH AND ADDRESS
         L     R2,SPANPTR          POINT TO COMBINED RECORD
         LH    R1,0(,R2)           GET COMBINED LENGTH
*        SH    R1,=H'4'                                              $V
*        LA    R2,4(,R2)                                             $V
         B     READX               EXIT
READSEGD EQU   *                   NOT NECESSARY TO CHECK RECFM X'10'
         LH    R1,0(,R2)           LENGTH
         AR    R2,R1               POINT TO NEXT SEGMENT
         C     R2,DEBLOCKS         END OF BLOCK
         BNL   READBRO             YES, BRANCH
         B     READVBS             GO PROCESS NEW SEGMENT
         EJECT
READJB   DS    0H
         LA    R2,0(R1,R2)    BUMP PAST FLAGS
         CLI   0(R2),X'FF'    IS LENGTH BYTE FF?
         BE    JES2RDI        YES. END OF BLOCK.
         TM    1(R2),X'10'    IS THIS A SPANNED RECORD?
         BO    SPANSKIP       YES. SKIP IT.
         SR    R6,R6          ZERO OUT REG
         IC    R6,0(R2)       INSERT LENGTH
         LR    R7,R6          SAVE RECORD LENGTH
         LR    R1,R2          SAVE RECORD LOCATION
         TM    1(R2),X'80'    IS THERE CARRIAGE CONTROL?
         BZ    *+8            NO.
         LA    R1,1(,1)       BUMP 1
         TM    1(R2),X'08'    IS THIS RECORD TO BE IGNORED?
         LR    R2,R1          UPDATE RECORD POINTER
         BNZ   SKIP1REC       YES. SKIP IT.
         LTR   R7,R7          LENGTH ZERO
         BZ    SKIP1REC       YES. SKIP IT.
         LR    R1,R7          RECORD LENGTH
READ1RTN DS    0H
         LA    R2,3(,R2)      BUMP PAST FLAGS
         STM   R1,R2,DEBLOCKS+4    SAVE STATUS INFO
         B     READX
SKIP1REC DS    0H
         LA    R2,3(R6,R2)    INCREMENT TO NEXT RECORD
         SR    R1,1           ZERO LENGTH CODE
         B     READJB         PROCESS NEXT RECORD
SPANSKIP LH    R6,2(R2)       LENGTH OF SEGMENT
         TM    1(R2),X'08'    IS THIS THE FIRST SEGMENT?
         BO    SPAN1STR       YES. USE HEADER LENGTH OF 6.
         LA    R2,4(R6,R2)    UPDATE RECORD POSITION
         SR    R1,1           ZERO LENGTH CODE
         B     READJB         PROCESS NEXT RECORD
SPAN1STR LA    R2,6(R6,R2)    UPDATE RECORD POSITION
         SR    R1,1           ZERO LENGTH CODE
         B     READJB         PROCESS NEXT RECORD
*
*
*
*
JES2RDI  DS    0H
         L     R5,CHKPTBOT         GET LAST CHECKPOINT
         LTR   R5,R5               IS THIS FIRST READ
         BNZ   JES2NF              BRANCH IF NOT FIRST
         L     R5,CHKPTTOP
         B     JES2NEW             READING A RECORD NOT READ BEFORE
JES2NF   L     R1,0(,R5)           GET NUMBER OF HIGHEST RECORD READ
         LTR   R1,R1               WAS IT EOF
         BM    JES2OLD             YES, BRANCH
         C     R1,COUNT            HAVE WE READ THIS RECORD BEFORE
         BNH   JES2ADD             NO, BRANCH
JES2OLD  LA    R5,CHKPTDUM         YES, DONT CHANGE CHKPT TABLE
         B     JES2RNEW
JES2ADD  LA    R5,20(,R5)          ADD AN ENTRY TO THE CHKPT TABLE
         C     R5,ENDPTR           IS TABLE FILLED UP
         BL    *+8                 NO, SKIP NEXT INSTR
         BAL   R14,READHALF        YES, HALVE THE TABLE
JES2NEW  DS    0H
         ST    R5,CHKPTBOT         SAVE NEW CURRENT CHECKPOINT POINTER
         MVC   0(4,R5),COUNT
JES2RNEW DS    0H
         L     R2,BLOCKPTR
         LR    R0,R2
         LA    R1,88
         SR    R0,R1
         L     R1,JESMTTR
         CLC   JESMTTR(4),FZEROS   EOF
         BE    JES2EOD
         LA    R15,3               READ A BLOCK FROM SPOOL
         SVC   242
         MVC   4(4,R5),JESMTTR     SET MTTR OF THIS BLOCK
         MVC   JESMTTR(4),0(R2)    SET MTTR OF NEXT BLOCK
         CLC   IXTJOBID(4),FZEROS  FIRST READ
         BNE   *+10
         MVC   IXTJOBID(4),4(R2)  SET THE JOBID
         CLC   IXTJOBID(4),4(R2) DOES THE JOBID MATCH?
         BNE   JES2EOD        NO. END OF DATASET.
         SR    R1,1
         LA    R2,10(,2)           BUMP TO FIRST RECORD
         LA    R0,4086(,R2)        END OF BLOCK
         STM   R0,R2,DEBLOCKS
         MVC   8(12,R5),DEBLOCKS
         B     READJB              CONTINUE
*
JES2EOD  DS    0H
         L     R1,=F'-1'           EOF
         ST    R1,0(,R5)           SAVE EOF IN CHKPT TABLE
         SLR   R2,R2
READX    DS    0H
         LM    R6,R7,JESRSAV1 RESTORE THESE REGS
         L     R14,READR
         BR    R14
FZEROS   DC    F'0'
         EJECT
DYNEOD   EQU   *
         L     R1,=F'-1'           EOF
         ST    R1,0(,R5)           SAVE EOF IN CHKPT TABLE
         SLR   R2,R2
         B     READX
*
READHALF LA    R0,20               LENGTH OF EACH ENTRY
         L     R15,CHKPTTOP        POINT TO FIRST ENTRY
         AR    R15,R0              POINT TO SECOND ENTRY
         LR    R1,R15
         AR    R1,R0               POINT TO THIRD ENTRY
READHMOV MVC   0(20,R15),0(R1)     MOVE 3RD TO 2ND
*                                       5TH TO 3RD
*                                       7TH TO 4TH, ETC
         AR    R15,R0              RECEIVING FIELD DOWN 1
         AR    R1,R0               SENDING FIELD DOWN 1
         AR    R1,R0               SENDING FIELD DOWN 2
         CR    R1,R5               ARE WE PAST THE LAST ENTRY
         BL    READHMOV            NO, BRANCH
         LR    R5,R15              YES, NEW CURRENT POINTER
         BR    R14                 RETURN
*
************************************************************
*                                                          *
*         END OF PROGRAM                                   *
*                                                          *
************************************************************
*
END      DS    0H
         LA    R15,0
         B     EXITRC
*
IOERR    LA    R1,SYNADMSG
         ST    R1,MSGADD
*
EXIT12   LA    R15,12
*
EXITRC   CH    R15,RC
         BNH   *+8
         STH   R15,RC              SET HIGHEST RC
         TM    STATUS,STGMVU
         BZ    NOGMVU
         L     R0,ANSWER+4         LENGTH
         L     R1,ANSWER           ADDRESS
         FREEMAIN R,LV=(0),A=(1)
         NI    STATUS,255-STGMVU
NOGMVU   EQU   *
         TM    STATUS,STOPEN
         BZ    NOCLOSE
         TM    DCBOFLGS,X'10'      IS IT OPEN?
         BZ    NOCLOSE             NO, BRANCH
         MVI   CLOSED,X'80'
         CLOSE ((R4)),MF=(E,CLOSED)
         NI    STATUS,255-STOPEN   CLOSED
         DROP  R4                  IHADCB
NOCLOSE  EQU   *
*
         L     R13,4(,R13)
         LM    R14,R12,12(R13)
         SR    R15,15
         BR    R14                 RETURN TO ETPS
*
************************************************************
*                                                          *
*        SYNAD EXIT                                        *
*                                                          *
************************************************************
*
*        THIS ROUTINE IS ENTERED DURING THE 'CHECK' MACRO
*        IF AN I/O ERROR OCCURS.
*
DYNSYNAD EQU   *
         SYNADAF ACSMETH=BSAM
         MVC   SYNADMSG(78),50(R1)
         MVI   SYNADSW,X'FF'
         SYNADRLS
         BR    R14
*
************************************************************
*                                                          *
*        CONSTANTS                                         *
*                                                          *
************************************************************
*
         LTORG
*
BOTNINES DC    F'99999999'
*
         PRINT NOGEN
*
BRODCB   DCB   DDNAME=DYNAM,DSORG=PS,MACRF=(RP),                       +
               EODAD=0,SYNAD=0
BRODCBL  EQU   *-BRODCB
*
         PRINT GEN
*
DYNREAD  READ  DYNDECB,SF,0,0,'S',MF=L
DYNDECBL EQU   *-DYNDECB
*
GMVU     GETMAIN VU,MF=L
GMVUL    EQU   *-GMVU
*
MSG04    DC    CL20'UNABLE TO OPEN DATASET'
MSG08    DC    CL20'SPECIFIED MEMBER NOT FOUND IN DATASET'
MSG20    DC    CL20'INVALID COMMAND'
MSG21    DC    CL20'INVALID PF KEY'
MSG31    DC    CL20'FOUND IN LINE XXXXX COL XXXXX'
MSG32    DC    CL20'BOTTOM OF DATA REACHED'
MSG33    DC    CL20'STRING NOT SPECIFIED'
MSG34    DC    CL20'INVALID OPERAND'
MSG35    DC    CL20'MISSING OPERAND'
MSG36    DC    CL20'MEMBER NOT FOUND'
MSG40    DC    CL20'PFK HAS BEEN RESET'
MSG41    DC    CL20'INVALID PFK COMMAND'
ASIST    DC    64X'4B',X'40',9X'4B'
         DC    X'4A4B4C4D4E4F'       CENT,PERIOD,LESS,LPAREN,PLUS,BAR
         DC    X'50',9X'4B'          AMPERSAND
         DC    X'5A5B5C5D5E5F'       EXCL,$,DOT,RPAREN,SEMI,NOT
         DC    X'6061',8X'4B'        HYPHEN,SLASH
         DC    X'6A6B6C6D6E6F'       WHAT,COMMA,PERCENT,UNDLN,GT,QM
         DC    9X'4B',X'79'          70-78
         DC    X'7A7B7C7D7E7F'       COLON,POUND,AT,APOST,EQ,DBLQUOTE
         DC    X'4B'
         DC    X'818283848586878889',7X'4B'
         DC    X'919293949596979899',8X'4B'
         DC    X'A2A3A4A5A6A7A8A9',23X'4B'
         DC    C'ABCDEFGHI',7X'4B'
         DC    C'JKLMNOPQR',8X'4B'
         DC    C'STUVWXYZ',06X'4B'
         DC    C'0123456789',6X'4B'
CAPST    DC    64X'4B',X'40',9X'4B'
         DC    X'4A4B4C4D4E4F'       CENT,PERIOD,LESS,LPAREN,PLUS,BAR
         DC    X'50',9X'4B'          AMPERSAND
         DC    X'5A5B5C5D5E5F'       EXCL,$,DOT,RPAREN,SEMI,NOT
         DC    X'6061',8X'4B'        HYPHEN,SLASH
         DC    X'6A6B6C6D6E6F'       WHAT,COMMA,PERCENT,UNDLN,GT,QM
         DC    9X'4B',X'79'          70-78
         DC    X'7A7B7C7D7E7F'       COLON,POUND,AT,APOST,EQ,DBLQUOTE
         DC    X'4B'
         DC    C'ABCDEFGHI',7X'4B'
         DC    C'JKLMNOPQR',8X'4B'
         DC    C'STUVWXYZ',23X'4B'
         DC    C'ABCDEFGHI',7X'4B'
         DC    C'JKLMNOPQR',8X'4B'
         DC    C'STUVWXYZ',06X'4B'
         DC    C'0123456789',6X'4B'
SCREEN   DC    X'5005'
SCRDSN   DC    53C'-'
         DC    C' LINE '
SCRLINE  DC    C'00000'
         DC    C' COL '
SCRCOL   DC    C'001 080   '
SCREENL  EQU   *-SCREEN
SCRDATA  EQU   *
*
MARKS    DC    18C'----+'
*
*
*               TRANSLATE TABLES
*
FINDSBA  DC    17X'00',X'11',238X'00'
NUMERIC  DC    240X'FF',10X'00',6X'FF'
HEXDATA  DC    193X'FF',6X'00',41X'FF',10X'00',6X'FF'
*
TABNONBL DC    64X'FF'
         DC    X'00'               BLANK
         DC    42X'FF'
         DC    X'FF'               COMMA
         DC    148X'FF'
TABBLANK DC    64X'00'
         DC    X'40'               BLANK
         DC    42X'00'
         DC    X'00'               COMMA
         DC    148X'00'
TABQUOTE DC    125X'00',X'7D',130X'00'
*
KAPS     DC    129AL1(*-KAPS)      00-80
         DC    9AL1(*-KAPS+X'40')  81-89 BECOME C1-C9
         DC    7AL1(*-KAPS)        8A-90
         DC    9AL1(*-KAPS+X'40')  91-99 BECOME D1-D9
         DC    8AL1(*-KAPS)        9A-A1
         DC    8AL1(*-KAPS+X'40')  A2-A9 BECOME E2-E9
         DC    86AL1(*-KAPS)       AA-FF
*
*
*
QUOTE    EQU   X'7D'
         PRINT NOGEN
         DCBD  DSORG=PS,DEVD=DA
*
ACBSIZ   EQU   56
MODSIZ   EQU   36
RPLSIZ   EQU   72
*
         PRINT GEN
         SPLTAREA
         MYSAVE
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12                  1ST BASE REG
R13      EQU   13                  WORK AREA
R14      EQU   14
R15      EQU   15
*
         CNOP  0,8
         TITLE 'ETPS - BROWSE HELP SCREEN'
BROHELP  CSECT
         DC    A(BROHELP1)
         DC    A(BROBLANK)
         DC    A(BROHELP2)
         DC    A(BROHELP3)
         DC    A(BROHELP4)
         DC    A(BROHELP5+X'80000000')
BROHELP1 DC    AL1(80)                  ROW 01, COL 01
         DC    X'05'                  PROTECT, HIGH-LIGHT
         DC    24C'-'
         DC    CL21' BROWSE INTERFACE    '
         DC    34C'-'
*        123456789012345678901234567890123456789012345678901234567890
BROHELP2 DC    AL1(61),X'05'
 DC CL62'ETPS BROWSE IS BASED ON BILL GODFREY''S "REVIEW" COMMAND ON '
BROHELP3 DC    AL1(61),X'05'
 DC CL62'    FILE 300 OF THE CBT TAPE. PF7/PF8 SCROLL UP/DOWN, AND   '
BROHELP4 DC    AL1(61),X'05'
 DC CL62'    PF10/PF11 SCROLL LEFT/RIGHT. I HAVE UNDOUBTEDLY CREATED '
BROHELP5 DC    AL1(61),X'05'
 DC CL62'    A FEW BUGS IN MY VERSION, SO DON''T BLAME BILL FOR THIS.'
BROBLANK DC    AL1(10),X'05',CL12' '
         CNOP  0,8
         EJECT
         END
/*
//LKED1    EXEC PGM=IEWL,PARM='XREF,LET,LIST,NCAL,RENT',
//             COND=(2,LT,ASM),REGION=1024K
//SYSLIN   DD   DSN=&&OBJSET,DISP=(OLD,PASS)
//         DD   DDNAME=SYSIN
//SYSLIB   DD   DSN=SYS1.LINKLIB,DISP=SHR
//SYSLMOD  DD   DISP=SHR,DSN=SYS1.LINKLIB,UNIT=SYSDA,VOL=SER=MVSTGT
//SYSUT1   DD   DSN=&&SYSUT1,UNIT=SYSDA,SPACE=(1024,(50,20))
//SYSPRINT DD   SYSOUT=*
//SYSIN    DD   *
  SETCODE AC(1)
     NAME ETPSBRO3(R)
/*
//LKED2    EXEC PGM=IEWL,PARM='XREF,LET,LIST,NCAL,RENT',
//             COND=(2,LT,ASM),REGION=1024K
//SYSLIN   DD   DSN=&&OBJSET,DISP=(OLD,PASS)
//         DD   DDNAME=SYSIN
//SYSLIB   DD   DSN=SYS1.LINKLIB,DISP=SHR
//SYSLMOD  DD   DISP=SHR,DSN=SYS1.LINKLIB,UNIT=SYSDA,VOL=SER=MVSYSA
//SYSUT1   DD   DSN=&&SYSUT1,UNIT=SYSDA,SPACE=(1024,(50,20))
//SYSPRINT DD   SYSOUT=*
//SYSIN    DD   *
  SETCODE AC(1)
     NAME ETPSBRO3(R)
/*
