//SACJICON JOB  (16403,CAL12,225,4288),'WHALEY, MIKE     ',
// MSGCLASS=X,CLASS=A,NOTIFY=SACJI
//*
//*
//*******************************************************************
//* JCL AND SOURCE TO ASSEMBLE AND LINK CONCAT VERSION 5.1
//* CHANGES MADE TO ALLOW FOR THE SWA TO MOVE ABOVE THE LINE.
//*******************************************************************
//C      EXEC  PGM=IEV90,PARM='OBJECT,RENT,TEST',REGION=2000K
//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR
//         DD  DSN=SYS1.AMODGEN,DISP=SHR
//SYSUT1   DD  UNIT=(SYSDA,SEP=SYSLIB),SPACE=(CYL,(10,5)),DSN=
//SYSPUNCH DD  DUMMY
//SYSPRINT DD  SYSOUT=*,DCB=(BLKSIZE=3509)
//*YSPRINT DD  SYSOUT=*,DCB=(BLKSIZE=3509),DEST=U9,UCS=GF15,
//*        FCB=L60C
//SYSLIN   DD  DISP=(,PASS),UNIT=SYSDA,SPACE=(CYL,(5,5,0)),            *
//             DCB=(BLKSIZE=400),DSN=&LOADSET
//SYSIN    DD  *
          TITLE 'CONCAT COMMAND PROCESSOR   SWA ABOVE THE LINE!'
***********************************************************************
*** TO DO LIST:                                                     ***
***  CHECK OTHER EXECUTED INSTRUCTIONS                              ***
***  MOVE IKJPARM DATA AREAS TO RENT STORAGE!                       ***
***        4. CHECK OUT AND DOCUMENT THE 'VERIFY' OPTION.           ***
***                                                                 ***
***                                                                 ***
***  VERSION 5.1   M. WHALEY                                        ***
***        1. IS THE 31 BIT VERSION FOR THE SWA MOVE 1/27/89        ***
***        2. 'LIST' PROCESSING ADDED FOR DATASET NAMES.            ***
***              - ALLOWS: CONCAT ISPPLIB (DA1,DA2,DA3)             ***
***              - CHECK FOR 'ONLY' PROCESSING                      ***
***                   WITH THIS FUNCTION I PUT AN X'AAAAAAAA'       ***
***                   VALUE IN THE PDE MEMBER POINTER FIELD IF      ***
***                   THIS DATASET IS TO BE EXCLUDED FROM           ***
***                   PROCESSING.  OTHERWISE IT IS ZERO.            ***
***              - CATALOG CHECK OF ALL DSN'S ENTERED               ***
***              - CHECK IF ALL DSN'S ARE REAL ON VOLUMES           ***
***              - MODIFY NEW TSO ALLOC COMMAND                     ***
***        3. IF OUR DATASET NAME IS FURTHER DOWN IN THE LIST AND   ***
***              WE HAVE 'EVEN', DELETE THE NAME FARTHER DOWN....   ***
***        4. CHECK OUT AND DOCUMENT THE 'VERIFY' OPTION.           ***
***        5. READ JFCB CALL CHANGED TO NEW FORMAT USING THE        ***
***              (ARL) ALLOCATION RETRIEVAL LIST.                   ***
***              - REMEMBER TO FREEMAIN THE RETURNED STORAGE        ***
***        6. DUMBDCB MOVED TO RE-ENTRANT STORAGE                   ***
***        7. A NEW CSECT WAS SET UP (DATASECT) TO HOLD OVERFLOW    ***
***              DATA THAT TWO BASE REGISTERS CAN'T ADDRESS.        ***
***              LOT'S OF JUNK MAY BE MOVED THERE.                  ***
***        8. ADDED 'TRACE' MACRO FOR DEBUGGING.                    ***
***        9. CREATED THE INSSECT CSECT BECAUSE THE CODE SECTION    ***
***              OF CONCAT WAS JUST TOO BIG FOR TWO BASE REGS.      ***
***       10. FIXED UP 'REMOVE' FUNCTION TO WORK.                   ***
***       11. ADDED ALIAS 'L' & 'LAST' TO 'AFTER' PARM              ***
***       12. ADDED ALIAS 'F' & 'FIRST' TO 'BEFORE' PARM            ***
***       13. 'POS' PARAMETER NO LONGER SUPPORTED...                ***
***       14. VOL PARAMETER NO LONGER SUPPORTED ......(NEVER WAS)   ***
***       15. RCX MADE THE DEFAULT                                  ***
***                                                                 ***
***********************************************************************
***  PROGRAM NAME:CONCAT            VERSION 4.0           03/10/87  ***
***  AUTHOR: EDWARD TISCHOFER                                       ***
***  COMMAND FORMAT:                                                ***
***      CONCAT DDNAME DSN BEFORE  EVEN   MSG   NODEBUG RC  VOLUME()***
***                        AFTER   ONLY   NOMSG DEBUG   RCX         ***
***                        POS(XX) VERIFY                           ***
***                                REMOVE                           ***
***                                                                 ***
***  REGISTER USAGE:                                                ***
***        R1 SYSTEM & PROGRAM MACROS, TEMP WORK REGISTER           ***
***        R2 PROGRAM MACROS, TEMP WORK REGISTER                    ***
***        R3 TEMP WORK REGISTER                                    ***
***        R4 WORK REGISTER                                         ***
***        R5 WORK REGISTER                                         ***
***        R6 LOADV ADDRESS REGISTER <<< EXECUTED >>>               ***
***        R7 LOADV LENGTH REGISTER  <<< EXECUTED >>>               ***
***        R8 LOADV ADDRESS REGISTER/DSN LIST POINTER               ***
***        R9  CPPL POINTER                                         ***
***        R10 PARSE WORK AREA DSECT                                ***
***        R11,R12 BASE REGISTERS                                   ***
***        R13 SAVE AREA AND DYNAMIC DATA AREA POINTER              ***
***        R14 SUBROUTINE RETURN REGISTER                           ***
***        R15 SUBROUTINE RETURN CODE REGISTER                      ***
***                                                                 ***
***  REVISIONS: 23290 -- 08/14/86    INITIAL WRITING                ***
***             23290 -- 08/29/86    ADD ENHANCMENTS                ***
***             23290 -- 03/10/87    MAKE RE-ENTERENT               ***
***********************************************************************
***    SOME EQUATES                                                ****
***********************************************************************
CVTTVTO  EQU     X'9C'
***********************************************************************
***    DEFINE ALL CUSTOM MACROS USED IN CONCAT                     ****
***********************************************************************
***********************************************************************
***    DEFINE LINKAGE MACROS                                       ****
***      EDOPEN   -START OF ASM PROGRAM                            ****
***      EDCLOSE  -END OF ASM PROGRAM                              ****
***      PROC     -START OF RE-ENTERENT PROCEDURE                  ****
***      EDDATA   -START OF DYNAMIC DATA AREA                      ****
***********************************************************************
         MACRO
&NAME    EDOPEN &B1,&B2,&B3,&B4,&B5,&PROCS=20,&DATA=3000,&MODE=ANY
         GBLA  &PROCSX
         GBLA  &DATAX
&PROCSX  SETA  &PROCS*4
&DATAX   SETA  &DATA
         AIF   ('&B2' NE '').OK
         AIF   ('&B3' NE '').OK
         AIF   ('&B4' NE '').OK
         AIF   ('&B5' EQ '').OK
         MNOTE 8,' ** REQUIRED BASE REGISTER SPECIFICATION OMITTED'
         MNOTE *,' ** MACRO EXPANSION TERMINATED'
         MEXIT
.OK      ANOP
         AIF   ('&NAME' NE '').CHECK
         MNOTE 8,' ** CSECT NAME IN LABEL FIELD OMITTED'
         MNOTE *,' ** MACRO EXPANSION TERMINATED'
         MEXIT
.CHECK   ANOP
&NAME    CSECT
&NAME    AMODE 31
&NAME    RMODE ANY
         AIF   ('&B5' EQ '').FOUR
         USING *,&B1,&B2,&B3,&B4,&B5
         AGO   .CONT
.FOUR    AIF   ('&B4' EQ '').THREE
         USING *,&B1,&B2,&B3,&B4
         AGO   .CONT
.THREE   AIF   ('&B3' EQ '').TWO
         USING *,&B1,&B2,&B3
         AGO   .CONT
.TWO     AIF   ('&B2' EQ '').ONE
         USING *,&B1,&B2
         AGO   .CONT
.ONE     AIF   ('&B1' EQ '').ERROR
         USING *,&B1
         AGO   .CONT
.ERROR   ANOP
         MNOTE 16,' ** NO BASE REGISTER SPECIFIED'
         MNOTE *,' ** MACRO EXPANSION TERMINATED'
         MEXIT
.CONT    ANOP
R0       EQU   0                     E
R1       EQU   1                       Q
R2       EQU   2                         U
R3       EQU   3                           A
R4       EQU   4                             T
R5       EQU   5                               E
R6       EQU   6                      R
R7       EQU   7                        E
R8       EQU   8                          G
R9       EQU   9                            I
R10      EQU   10                             S
R11      EQU   11                               T
R12      EQU   12                                 E
R13      EQU   13                                   R
R14      EQU   14                                     S
R15      EQU   15
*
         STM   R14,R12,12(R13)         SAVE CALLERS REGISTERS
         LR    &B1,R15                 LOAD BASE REGISTER
         LR    R9,R1                   SAVE ORIGINAL PASSED PARM (MW)
******** GETMAIN R,LV=72+&PROCSX+&DATAX,LOC=BELOW
         GETMAIN R,LV=72+&PROCSX+&DATAX,LOC=BELOW
         XC    0(72+&PROCSX,R1),0(R1)
         ST    R13,4(,R1)              SAVE BACKWARD CHAIN POINTER
         ST    R1,8(,R13)              SAVE FORWARD CHAIN POINTER
         L     R1,24(,R13)             RESTORE PARM POINTER
         L     R13,8(,R13)             POINT TO NEW SAVE AREA
         USING DATAAREA,R13            ADDRESSABILITY TO DSECT
* MW     LA    R2,DATA                 THE DATA ADDRESS
* MW     LA    R3,&DATAX               LENGTH OF THE DATA AREA
* MW     LA    R5,0                    0 PAD AND ZERO LENGTH
* MW     MVCL  R2,R4                   ZAP THE DATA AREA
.BASES   AIF   ('&B2' EQ '').END
         LA    &B2,4095(&B1)           LOAD THE SECOND REGISTER
         LA    &B2,1(&B2)              BASE REGISTER
         AIF   ('&B3' EQ '').END
         LA    &B3,4095(&B2)           LOAD THE THIRD
         LA    &B3,1(&B3)              BASE REGISTER
         AIF   ('&B4' EQ '').END
         LA    &B4,4095(&B3)           LOAD THE FOURTH
         LA    &B4,1(&B4)              BASE REGISTER
         AIF   ('&B5' EQ '').END
         LA    &B5,4095(&B4)           LOAD THE FIFTH
         LA    &B5,1(&B5)              BASE REGISTER
.END     ANOP
         MEND
***********************************************************************
         MACRO
&NAME    EDCLOSE
         GBLA  &PROCSX
         GBLA  &DATAX
&NAME.99 DS    0H
         LR    R2,R15                 SAVE RETURN CODE
         LR    R1,R13                 POINT AT DYNAMIC STORAGE
         L     R13,4(,R13)            CHAIN TO OLD SAVE AREA
         FREEMAIN R,LV=72+&PROCSX+&DATAX,A=(1)
         LR    R15,R2                 RESTORE RETURN CODE
         L     R14,12(,R13)           RESTORE RETURN REGISTER
         LM    R0,R12,20(R13)         RESTORE OTHER REGISTERS
         BR    R14                    RETURN TO CALLER
         MEND
***********************************************************************
         MACRO
         EDDATA
         GBLA &PROCSX
         GBLA &DATAX
***********************************************************************
DATAAREA DSECT
SAVEAREA DS   18F        REGISTER SAVE AREA
R14STACK DS   CL&PROCSX  SAVE AREA FOR R14 STACK FOR SUBROUTINES
DATA     DS   0CL&DATAX
***********************************************************************
*** DSECT DATA AREA                                                 ***
***********************************************************************
         MEND
***********************************************************************
         MACRO
&NAME    GOSUB &ENTRY,&ERROR
&NAME    BAL   R14,&ENTRY              EXECUTE SUBROUTINE
         LTR   R15,R15                 NORMAL COMPLETION?
         BNE   &ERROR                  NO BRANCH TO ERROR ROUTINE
         MEND
***********************************************************************
**
**  T R A C E   M A C R O
**  STICK TRACE 'ANYTHING'  IN CODE TO TPUT IT OUT
**  MAX LENGTH OF 40
***********************************************************************
         MACRO
&NAME    TRACE &MESSAGE
&NAME    DS    0H      TRACE MACRO
*  MOVE MESSAGE TO 24 BIT STORAGE
         MVC   TPUTNAME(L'DK&SYSNDX),DK&SYSNDX
***      TPUT  '&NAME',L'&NAME       WHALEY MOD FOR DEBUGGING!
         TPUT  TPUTNAME,L'DK&SYSNDX
         B     MW&SYSNDX
DK&SYSNDX DC   C'&MESSAGE'
MW&SYSNDX DS 0H
         MEND
***********************************************************************
**
**  WITH 'PROC' MACRO YOU MAY USE   PROC BEGIN
**
***********************************************************************
         MACRO
&NAME    PROC  &TYPE
         GBLA  &R14OFF
         AIF   ('&TYPE' EQ 'BEGIN').BEGIN
         AIF   ('&TYPE' EQ 'END').END
         MNOTE 8,'*** ERROR INVALID TYPE OF SUBROUTINE MACRO'
         MEXIT
.BEGIN   ANOP
&R14OFF  SETA  &R14OFF+4
&NAME    DS    0H
         ST    R14,72+&R14OFF.(,R13)
         MEXIT
.END     ANOP
&NAME.99 DS    0H
         L     R14,72+&R14OFF.(,R13)
         BR    R14
         MEXIT
.TRACE   ANOP
         MEND
***********************************************************************
***    DEFINE DEBUG MACRO                                          ****
***    CHECKS FOR DEBUG PARM AND BRANCHES AROUND CODE IF NOT FOUND ****
***********************************************************************
         MACRO
&NAME    DEBUG   &TYPE
         GBLC    &ENDD
         AIF     ('&TYPE' EQ 'BEGIN').BEGIN
         AIF     ('&TYPE' EQ 'END').END
         MNOTE   8,'*** ERROR INVALID DEBUG TYPE &TYPE'
         MEXIT
.BEGIN   ANOP
&ENDD    SETC    '&SYSNDX'
         LH      R1,DEBUG
         CH      R1,=H'2'
         BNE     D&ENDD
         MEXIT
.END     ANOP
D&ENDD   DS      0H
         MEND
***********************************************************************
*** DEFINE MESSAGE MACROS                                           ***
***   PUTMSG   - OUTPUTS A MESSAGE "RE-ENTERENT"                    ***
***   FINE MESSAGE MACROS                                           ***
***********************************************************************
***********************************************************************
***    OUTPUT A MESSAGE TO THE USER MACRO                          ****
***      23290 - 03/10/87 USE IKJEFF02 TO ISSUE  THE MESSAGES      ****
***********************************************************************
         MACRO
&NAME    PUTMSG &O1,&O2,&O3,&O4,&O5
         GBLC    &ENDM
&ENDM    SETC    '&SYSNDX'
&NAME    DS      0H
         USING   DATASECT,R15      CSECT WITH DATA
         L       R15,=V(DATASECT)
         LH      R1,MSG
         CH      R1,=H'2'
         BNE     M&ENDM
         AIF    ('&O1' EQ '').ERROR1
         LA     R2,1
         LA     R1,&O1
         ST     R1,PARMMSG+4
         AIF    ('&O2' EQ '').END1
         LA     R2,1(R2)
         LA     R1,&O2
         ST     R1,PARMMSG+8
         AIF    ('&O3' EQ '').END1
         LA     R2,1(R2)
         LA     R1,&O3
         ST     R1,PARMMSG+12
         AIF    ('&O4' EQ '').END1
         LA     R2,1(R2)
         LA     R1,&O4
         ST     R1,PARMMSG+16
         AIF    ('&O5' EQ '').END1
         LA     R2,1(R2)
         LA     R1,&O5
         ST     R1,PARMMSG+16
.END1    ANOP
         DROP   R15
         ST     R2,PARMMSG
         L       R1,CPPLUPT
         L       R0,CPPLECT
         PUTLINE PARM=PUTBLOCK,UPT=(R1),ECT=(R0),                      X
               ECB=ECBADS,OUTPUT=(PARMMSG,TERM,SINGLE,INFOR),          X
               MF=(E,IOPLADS)
.*
M&ENDM   DS      0H         BR TO HERE IF NO 'MSG' OPTION OR 'DEBUG'
         MEND
***********************************************************************
*** DEFINE PARMLIST FOR PUTMSG MACRO                                ***
***********************************************************************
        MACRO
&NAME   PARMMSG &MAX=6
&NAME   DS     &MAX.F
        MEND
***********************************************************************
*** DEFINE A VARIABLE MESSAGE AREA                                  ***
***********************************************************************
        MACRO
&NAME   VARMSG &LEN
&NAME   DS     0H
&NAME.L DS     H
&NAME.O DS     H
&NAME.M DS     CL&LEN
        MEND
***********************************************************************
*** DEFINE A LITERAL MESSAGE AREA                                   ***
***********************************************************************
        MACRO
&NAME   TSOMSG &MSG,&OFFSET=0
        LCLA   &L
&L      SETA   K'&MSG-2
&L      SETA   &L+4
&NAME   DS     0H
&NAME.L DC     H'&L'
&NAME.O DC     H'&OFFSET'
&NAME.M DC     C&MSG
*
        MEND
        EJECT
***********************************************************************
***********************************************************************
***********************************************************************
***   --------------------------                                    ***
***   START OF COMMAND PROCESSER                                    ***
***   --------------------------                                    ***
***********************************************************************
CONCAT   EDOPEN  R12,R11,PROCS=40
*
         MVC     0(4,R13),=CL4'MIKE'   EYE CATCHER FOR MAIN DATA AREA
*
* ORIGINAL R1 IS NOW SAVED IN R9 AS PART OF EDOPEN   (MW)
*
*****    LR      R9,R1                 SAVE CPPL POINTER
         LH      R8,0(,R9)             GET LENGTH OF PASSED PARM
         USING   CPPL,R9               ADDRESSABILITY TO CPPL
         MVC     PPLCBUF,CPPLCBUF      GET COMMAND BUFFER
         MVC     PPLUPT,CPPLUPT
         MVC     PPLECT,CPPLECT
         BAL     R14,INIT
******   GOSUB   INIT,CONE12  NO NEED TO CHECK RETURN CODE
         CALLTSSR EP=IKJPARS,MF=(E,PPL)
         LTR     R15,R15               THINGS WORK OUT OK?
         BNZ     CONE12                END DUE TO ERROR
         L       R10,ANSPL             POINT AT PARSE WORK AREA
         USING   IKJPARMD,R10          ESTABLISH ADDRESSABILITY
         DEBUG   BEGIN
         PUTMSG  D1000
         DEBUG   END
*
* ---- MAIN LINE LOGIC ----
*
         DEBUG   BEGIN
         GOSUB   VPARMS,CONE12
         DEBUG   END
*
         GOSUB   VERDD,CON100          IS THE DDNAME ALLOCATED?
         BAL     R14,GETDSNS           YES GET DATA SETS CONCATENATED
****************************************************************
*** SO FAR - IF DDNAME ALLOCATED THEN +                      ***
***    CHECK FOR VERIFY AND CALL VERIFY CODE                 ***
***    CHECK FOR REMOVE AND CALL REMOVE CODE                 ***
****************************************************************
         LH      R7,EVON
         CH      R7,=H'3'              IS THIS VERIFY?
         BNE     CON010                NO CHECK FOR REMOVE
         GOSUB   VERIT,CONE8           YES DO VERIFY CODE
         B       CONE0
CON010   DS      0H
         LH      R7,EVON
         CH      R7,=H'4'              IS THIS REMOVE
         BNE     CON020                NO PROCESS REQUEST
*
*  REMOVE THE DSN FROM THE CONCATENATION
*
         GOSUB   REMIT,CONE8           YES TO REMOVE CODE
         L       R1,FCELLADR           CHECK FOR NO DSN'S
         LTR     R1,R1
         BZ      FREEIT
*
*  DUMMY UP 'NEW' LIST OF DSN'S, THEN CALL INSSECT TO BUILD
*  POOL AREA 'DOCMD' EXPECTS TO USE TO BUILD THE TSO COMMAND.
*
         MVC     DSNAME+8(4),=XL4'AAAAAAAA'  DUMMY 'DELETED' FLAG
         MVC     DSNAME+24(4),=XL4'FF000000' DUMMY END OF LIST FLAG
         L       R15,=V(INSSECT)       BUILD NEW DSN POOL
         BALR    R14,R15
         BAL     R14,DOCMD
         B       CONE0
FREEIT   DS      0H
         BAL     R14,FREECMD
         B       CONE0
CON020   DS      0H                    CHECK FOR ONLY ERRORS
         LH      R7,EVON               GET PARM
         CH      R7,=H'1'              IS THIS ONLY?
         BNE     CON030                NO PROCESS REQUEST
* ооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооо
* о "ONLY" PROCESSING:  CALL FINDDSN TO LOOK IN THE TIOT AT ALL
* о THE DATASETS IN THE CONCAT PARMS.   IF ONE IS FOUND IT'S
* о MEMBER POINTER IS CHANGED TO X'AAAAAAAA' TO INDICATE THAT YOU
* о ARE NOT TO RE-ALLOCATE THIS DATASET.  IF THEY ALL TURN OUT TO
* о BE 'NO' THEN YOU STILL GET THE RC=8.
* ооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооо
*
         LA      R5,DSNAME             FIRST DATASET NAME PDE
CON021   EQU     *
         MVC     OURDSN,BLANK44        PADD OURDSN
         L       R8,0(,R5)             GET DSN PTR ADDRESS IN R8
         LH      R7,4(,R5)             FOR THIS LENGTH
         LA      R6,OURDSN             TO OURDSN
         BCTR    R7,0                  ADJUST FOR MACHINE
         EX      R7,LOADV              DO MOVE
         GOSUB   FINDDSN,CON026        IS OUR DSN HERE ALREADY?
*
         MVC     8(4,R5),=X'AAAAAAAA'  MARK AS BAD ENTRY
         BAL     R14,R150              PUT OUT ERROR MESSAGE
*
CON026   EQU     *
         CLC     24(4,R5),=X'FF000000'  END OF LIST OF DSN'S?
         BE      CON028                YES THE END
         L       R5,24(,R5)            POINT TO NEXT DSN ENTRY
         B       CON021
*
* HAVE WE FOUND ANY GOOD ONES?
*
CON028   EQU     *
         LA      R5,DSNAME             FIRST DATASET NAME PDE
CON029   EQU     *
         CLC     8(4,R5),=X'AAAAAAAA'   USE THIS ENTRY?
         BNE     CON030                AT LEAST ONE GOOD ONE SO USE...
         CLC     24(4,R5),=X'FF000000'  END OF LIST OF DSN'S?
         BE      CONE8                 NO MORE AND NO GOOD ONE'S RC=8
         L       R5,24(,R5)            POINT TO NEXT DSN ENTRY
         B       CON029
*
*  SOME DID PASS THE 'ONLY' PROCESSING....
*
CON030   DS      0H
         BAL     R14,VERDSN            IS DSN/VOLUME OK
         CL      R15,RC0
         BE      CON31                 YES DSN/VOL OK
         CL      R15,RC8               IS IT CATALOG PROBLEM?
         BE      CON30A                YES IT IS CATALOG PROBLEM
         BAL     R14,R130              NO MUST BE VOLUME PROBLEM
         B       CONE8
CON30A   BAL     R14,R120
         B       CONE8
CON31    DS      0H
****************************************************************
*** AT THIS POINT WE NEED TO INSERT OUR DSN BEFORE/AFTER/POS ***
****************************************************************
         LH      R1,AFTBEF
         CH      R1,=H'1'
         BE     CON032
         CH      R1,=H'2'
         BE     CON033
         L       R15,POS                GET THE POS FROM PARS
         L       R1,0(,R15)            INTG IS FULLWORD BIN INTEGER
         B       CON034
CON032   LA      R1,1                   INDICATE BEFORE
         B       CON034
CON033   LA      R1,X'FF'               INDICATE AFTER
CON034   EQU     *
         L       R15,=V(INSSECT)        CREATE DSN CHAIN CSECT
         BALR    R14,R15                INSERT DATA SET
         BAL     R14,DOCMD
         LR      R2,R15
         B       CON99
****************************************************************
*** THE DDNAME IS NOT ALLOCATED                              ***
***     IF REMOVE KEYWORD THEN ERROR R100                    ***
***     IF VERIFY KEYWORD THEN ERROR R102                    ***
***     IF VERDSN=0 THEN ALLOCATED DDNAME TO DSN             ***
****************************************************************
CON100   DS      0H
         LH      R7,EVON               DDNAME NOT IN TIOT
         CH      R7,=H'4'              IS THIS REMOVE?
         BNE     CON110                NO CHECK FOR VERIFY?
         BAL     R14,R100              YES PROCESS ERROR AND BAIL
         B       CONE8                 &LASTCC=8
CON110   DS      0H
         CH      R7,=H'3'              IS THIS VERIFY?
         BNE     CON120
         BAL     R14,R102              YES PROCESS ERROR AND BAIL
         B       CONE8
CON120   DS      0H
         BAL     R14,VERDSN            IS DSN/VOLUME OK
         CL      R15,RC0
         BNE     CON130                NO WHICH ONE DSN OR VOLUME?
****************************************************************
* THE DATA SET IS CATALOGED OR ON THE VOLUME BUT DDNAME NOT    *
* ALLOCATED. JUST ALLOCATE THE DDNAME TO THE DSN WITH SHR      *
****************************************************************
*
         SR      R1,R1
         ST      R1,FCELLADR       INDICATE NO PREVIOUS DATASETS
*
         LA      R1,1                   INDICATE BEFORE
         L       R15,=V(INSSECT)        CREATE DSN CHAIN CSECT
         BALR    R14,R15                INSERT DATA SET
         BAL     R14,DOCMD
         LR      R2,R15
         B       CON99
*        L       R2,CMDBUFAD
*        TPUT    (R2),(R5)             DISPLAY COMMAND
         B       CONE0
*
*
CON130   CL      R15,RC8               IS IT NOT CATALOGED?
         BNE     CON140                NO MUST BE VOLUME PROBLEM
****************************************************************
* THE DATA SET IS NOT CATALOGED ISSUE MESSAGE AND QUIT         *
****************************************************************
         BAL     R14,R120              YES ISSUE NOT CATALOGED MSG
         B       CONE8
CON140   DS      0H
****************************************************************
* THE DATA SET IS NOT ON SPECIFIED VOLUME ISSUE MESSAGE/QUIT   *
****************************************************************
         BAL     R14,R130              NOT ON VOLUME SPEC
         B       CONE8
****************************************************************
*                                                              *
****************************************************************
CON200   DS      0H
CONE0    L       R2,RC0
         B       CON99
CONE8    L       R2,RC8
         B       CON99
CONE12   L       R2,RC12               SET RETURN CODE = 12
         B       CON99
CONE24   LA      R2,24                 SET RETURN CODE = 24
         B       CON99
CON99    IKJRLSA ANSPL                 RELEASE PARSE STORAGE
         CPOOL   DELETE,CPID=POOLADR
         LR      R15,R2                RESTORE RETURN CODE
CONCAT   EDCLOSE
         EJECT
***********************************************************************
***  THIS IS THE 'VERIFY' OPTION                                    ***
***                                                                 ***
***  VERIT PROCEDURE SCANS THE DSNLIST FOR OURDSN                   ***
***    RC=0 IF OUR DSN FOUND IN LIST                                ***
***    RC=8 IF OUR DSN NOT FOUND IN LIST                            ***
***  MODIFIED TO CHECK FOR ALL DSN'S IN THE LIST                    ***
***********************************************************************
VERIT    PROC    BEGIN
         MVC     HIGHRC(4),=F'0'       HIGHEST RETURN CODE
         LA      R5,DSNAME             GET FIRST NAME IN THE LIST
VER02    EQU     *
         MVC     OURDSN,BLANK44        PADD OURDSN
         L       R8,0(,R5)             GET DATASET NAME
         LH      R7,4(,R5)             FOR THIS LENGTH
         LA      R6,OURDSN             TO OURDSN
         BCTR    R7,0                  ADJUST FOR MACHINE
         EX      R7,LOADV              DO MOVE
         GOSUB   FINDDSN,VERITE8
*
*        OK SO FAR, FOUND THE LAST ONE
*
VER50    CLC     24(4,R5),=X'FF000000'  END OF LIST OF DSN'S?
         BE      VER98                 YES THE END
         L       R5,24(,R5)            POINT TO NEXT DSN ENTRY
         B       VER02                 DO IT ALL AGAIN
*
*        NOT FOUND IN THE LIST
*
VERITE8  BAL     R14,R140
         MVC     HIGHRC(4),RC8         RC=8 IS HIGHEST SO FAR...
         B       VER50                 TRY NEXT IN LIST
*
*        LOAD HIGHEST RETURN CODE
*
VER98    L       R15,HIGHRC
VERIT    PROC    END
***********************************************************************
***  REMOVE DATASET(S) FROM CONCATENATION                           ***
***  REMIT PROCEDURE SCANS THE DSNLIST FOR OURDSN AND REMOVES IT    ***
***    RC=0 IF OUR DSN FOUND IN LIST AND REMOVED                    ***
***    RC=8 IF OUR DSN NOT FOUND IN LIST                            ***
***********************************************************************
REMIT    PROC    BEGIN
***      TRACE   REMIT
         SR      R5,R5
         ST      R5,HIGHRC             HIGHEST RETURN CODE SO FAR
         LA      R5,DSNAME             FIRST DSN IN THE LIST
REMIT10  EQU     *
         MVC     OURDSN,BLANK44        PADD OURDSN
         L       R8,0(,R5)             GET DSN USER SPECIFIED
         LH      R7,4(,R5)             FOR THIS LENGTH
         LA      R6,OURDSN             TO OURDSN
         BCTR    R7,0                  ADJUST FOR MACHINE
         EX      R7,LOADV              DO MOVE
         GOSUB   DELLST,REMITE8        DELETE THIS ENTRY
REMIT20  EQU     *
         CLC     24(4,R5),=X'FF000000' END OF DSN'S?
         BE      REMIT98               BR IF END OF LIST
         L       R5,24(,R5)            POINT AT NEXT DSN
         B       REMIT10               CHECK NEXT ONE
REMITE8  DS      0H
         BAL     R14,R140              NOT IN LIST
         L       R15,RC8
         ST      R15,HIGHRC
         B       REMIT20
REMIT98  DS      0H
         L       R15,HIGHRC            GET HIGHEST RETURN CODE
REMIT    PROC    END
***********************************************************************
***  STORAGE AND VARIABLE INITIALIZATION ROUTINES                   ***
***********************************************************************
INIT     PROC    BEGIN
****     TRACE   INIT
*--- GET CPOOL STORAGE FOR DATA SET LIST
         CPOOL   BUILD,PCELLCT=15,SCELLCT=15,CSIZE=72,CPID=POOLADR,    X
               SP=2
         XR      R15,R15               ZAP RETURN CODE REG
INIT10   DS      0H
*
*--- INIT LOCAL CPPL
         LA      R1,CPECB
         ST      R1,PPLECB
         L       R1,=V(CMDEF)
         ST      R1,PPLPCL
         LA      R1,ANSPL
         ST      R1,PPLANS
*
*  INITIALIZE THE DUMBDCB FOR RDJFCB
*
         L     R15,=V(DATASECT)    ADDRESSIBILITY TO 'READDCB'
         USING DATASECT,R15
         MVC   DUMBDCB(REALEND-REALDCB),REALDCB  MOVE SKELETON DCB
         DROP  R15
         LA    R2,ARL
         ST    R2,RDJFCBP
         MVI   RDJFCBP,X'93'       OPTION FOR NEW RDJFCB READ
         LA    R2,RDJFCBP          GET ADDRESS OF THIS GOOD STUFF
         ST    R2,DUMBDCB+36       EXLST PARM IN DCB, OVERLAY
         MVI   DUMBDCB+36,X'00'    FIX RECFM JUST OVERLAYED
*
*  INITIALIZE THE RDJFCB PARAMETER LIST IN THE ARL
*
         LA    R2,ARLEND-ARL          LENGTH OF ALL OF ARL BLOCK
         STH   R2,ARLLEN              SAVE LEN OF ARL
         MVC   ARLIDENT(2),=C'AR'     BECAUSE IBM SAYS SO....
         MVI   ARLOPT1,X'80'          ARL MAY BE ABOVE OR BELOW LINE
         MVC   ARLRSVD1(7),=XL7'00000000000000' RESERVED AREA
         MVC   ARLRETRV(2),=H'00'     RETURN ALL DSN'S IN CONCAT LST
         MVC   ARLFIRST(2),=H'00'     START WITH FIRST DSN
*
* INIT CAMLST PARAMETER LIST
         MVI   GETVO1,68
         MVI   SEACAM1,193
         LA    R1,OURDSN
         ST    R1,GETDSNP
         ST    R1,SEADSN
         LA    R1,CAMBUF1
         ST    R1,GETBUF1
         ST    R1,SEABUF1
         LA    R1,OURVOL
         ST    R1,SEAVOL
         MVI     ABFLAGS,X'00'         DON'T DUMP IF ABEND
         MVI     FNCFLAGS,X'01'        TELL TSR TO EXECUTE THE COMMAND
*
* INIT FLAG TO SHOW THAT THE 'NEW POOL' WAS NEVER USED
*
         SR    R1,R1
         ST    R1,NEWPOOL
*
INIT     PROC  END
***********************************************************************
***  VERDD ROUTINE WILL MOVE THE DDNAME FROM PARS TO THE PADDED     ***
***  VARIABLE OURDD. THEN IT WILL SCAN THE TIOT FOR DDNAME.         ***
***   IT WILL RETURN:                                               ***
***      R15=0 - DDNAME IS FOUND IN THE TIOT                        ***
***      R15=8 - DDNAME IS NOT FOUND IN THE TIOT                    ***
***********************************************************************
VERDD    PROC  BEGIN
****     TRACE VERDD
         MVC     OURDD,BLANK8          PADD DDNAME
         L       R8,DDNAME             MOVE DDNAME
         LH      R7,DDNAME+4           FOR THIS LENGTH
         LA      R6,OURDD              TO OURDD
         BCTR    R7,0                  ADJUST FOR MACHINE
         EX      R7,LOADV              DO THE MOVE
         LA      R7,5(,R7)             ADJUST FOR HEADER
         STH     R7,D1050CL            SAVE FOR MESSAGE
         MVC     D1050CM(8),OURDD      SAVE FOR MESSAGE
*
*   MOVE EXTRACT PARM LIST BELOW THE LINE FROM OUR DATA CSECT
*
         L       R15,=V(DATASECT)      ADDRESSIBILITY TO 'EXTRACT'
         USING   DATASECT,R15
         MVC     EXTPARM(EXTEND-EXTRACT),EXTRACT
         DROP    R15
         LA      R2,TIOTADDR
         EXTRACT (R2),,FIELDS=TIOT,MF=(E,EXTPARM)
         L       R3,TIOTADDR           GET TIOTADDRESS
         LA      R3,24(,R3)            POINT PAST JOB INFO
VERDD10  MVC     TIOTELEN+3(1),0(R3)
         CLC     OURDD,4(R3)           THIS OUR DDNAME?
         BE      VERDDE0               YES RETURN CODE=0
         L       R4,TIOTELEN           GET DDNAME ENTRY LENGTH
         AR      R3,R4                 POINT TO NEXT ENTRY
         CLI     TIOTELEN+3,X'00'      END OF TIOT?
         BE      VERDDE8               YES RETURN CODE=8
         B       VERDD10
VERDDE0  ST      R3,TIOTDD             SAVE DDNAME ADDRESS FROM TIOT
         L       R15,RC0
         B       VERDD99
VERDDE8  L       R15,RC8
VERDD    PROC  END
***********************************************************************
***  99RDSN ROUTINE WILL MOVE THE DSN FROM PARS TO THE PADDED       ***
***  VARIABLE OURDSN. THEN IT WILL VERIFY THAT THE DSN IS CATALOGED ***
***  OR ON THE VOLUME PASSED FROM PARS.                             ***
***   IT WILL RETURN:                                               ***
***      R15=0 - DSN FOUND AND VOLUME FILLED IN                     ***
***      R15=8 - DSN NOT CATALOGED OR DSN NOT ON VOLUME.            ***
***********************************************************************
VERDSN   PROC  BEGIN
****     TRACE  VERDSN
         LA      R5,DSNAME             GET ADDRESS OF THE FIRST DSN BLK
*
VERDSN1  MVC     OURDSN,BLANK44        PADD OURDSN
         L       R8,0(,R5)             GET DSN PTR, GET READY TO MOVE
         LH      R7,4(,R5)             FOR THIS LENGTH
         LA      R6,OURDSN             TO OURDSN
         BCTR    R7,0                  ADJUST FOR MACHINE
         EX      R7,LOADV              DO MOVE
         LA      R7,5(,R7)             SAVE LENGTH
         STH     R7,D1010AL            FOR MESSAGE
         MVC     D1010AM,OURDSN        SAVE FOR MESSAGE
         LH      R7,VOLUME
         CH      R7,=H'2'              VOLUME HERE?
         BE      VERDSN20              YES SKIP LOCATE MACRO
VERDSN10 DS      0H
*--- DO CAMLIST LOCATE ON DSN
*
         LOCATE  GETVOLD               GET DSN VOLUME
         LTR     R15,R15               DSN CATALOGED?
         BNZ     VERDSE8               NO PROCESS ERROR
         LA      R1,CAMBUF1+6          POINTER TO VOLUME
         MVC     OURVOL(6),0(R1)       MOVE TO OURVOL
         B       VERDSN30
VERDSN20 DS      0H                    MOVE VOLUME TO OURVOL
         LH      R7,VOL+4
         L       R8,VOL
         LA      R6,OURVOL
         BCTR    R7,0
         EX      R7,LOADV
VERDSN30 DS      0H
         LA      R2,SEACAM
         OBTAIN  SEACAM
VERDSN40 LTR     R15,R15
         BNZ     VERDSE12
         MVC     OURBLK(2),CAMBUF1+86  GET THE BLOCKSIZE
         B       VERDSE0
*
VERDSE0  L       R15,RC0
         B       VERDSN98              CONTINUE WITH NEXT VIEW!
VERDSE8  L       R15,RC8               DSN NOT CATALOGED
         B       VERDSN99
VERDSE12 L       R15,RC12              DSN NOT ON VOLUME
         B       VERDSN99
*
* SEVERAL DSN'S MAY HAVE BEEN SPECIFIED
*
VERDSN98 CLC     24(4,R5),=X'FF000000' END OF DSN BLOCK CHAIN LIST
         BE      VERDSN99
         L       R5,24(,R5)            NEXT DSN BLOCK
         B       VERDSN1               START NEXT ONE
VERDSN   PROC  END
***********************************************************************
***  GETDSNS SUBROUTINE GETS ALL DATA SETS CONCATENATED TO DDNAME   ***
***********************************************************************
GETDSNS  PROC    BEGIN
*****    TRACE   GETDSNS
         DEBUG   BEGIN
         PUTMSG  D1080
         DEBUG   END
*
* MOVE IN OUR DDNAME AND READ IN THE JFCB INFORMATION
*
         L       R3,TIOTDD             POINT AT OUR DD IN TIOT
         MVC     DUMBDCB+40(8),4(R3)   MOVE OUR DDNAME TO DUMMY DCB
         LA      R1,DUMBDCB
         ST      R1,TISCH
         MVI     TISCH,128
         LA      R1,TISCH         MONKEY WITH THIS TO MAKE IT 'RENT'
******   RDJFCB  (DUMBDCB)   DON'T USE MACRO BECAUSE NOT 'RENT'
         SVC     64                    RDJFCB SVC
         LTR     R15,R15               WORK OK?
         BZ      GETD20                CONTINUE...
*
*  THERE IS NO EXISTING DD CARD FOR THIS GUY....
         SR      R2,R2
         ST      R2,FCELLADR           SHOW NO DSN'S WILL BE IN LIST
         B       GETDE99
*
* THE ARL AREA IS NOW FILLED IN....
* 1. FIND OUT IF ANOTHER DSN
* 2. IF SO GET CPOOL CELL AND CHAIN IT
* 3. GO TO GETDSN TO LOAD NAME AND DISPLAY DEBUG MESSAGES
* 4. DO AGAIN UNTIL NO MORE DATASETS
*
*
GETD20   LH      R2,ARLRTRVD      LOAD NUMBER OF DSN'S RETRIVED
         ST      R2,BCTSAVE       SAVE NUMBER OF DSN'S RETRIVED
         L       R3,ARLAREA       START OF THE AREA
*
GETD25   EQU     *                START GET ALL DSN'S FROM JFCB
         CPOOL   GET,U,CELL=(R8),CPID=POOLADR   GET FIRST POOL CELL
         ST      R8,FCELLADR           SAVE FIRST CELL ADDRESS
         USING   D_DSND,R8             ADDRESSIBILITY TO CELL
*
* BCTSAVE  SAVE COUNT OF DSN'S TO GO
* R3 = ALLOC RET AREA
* R8 = CURRENT POOL CELL TO PUT DSN + BLOCK INFORMATION
*
GETL10   EQU     *
         BAL     R14,GETDSN
         L       R2,BCTSAVE            RETRIEVE BCT REG VALUE
         BCT     R2,GETDGON            MORE DSN'S TO GO?
         B       GETD99                END CHASE
*
* SET UP TO GET NEXT JFCB AREA IN ALLOC RET AREA
*
GETDGON  ST      R2,BCTSAVE            SAVE TO LIVE ANOTHER DAY...
         LH      R1,0(,R3)             GET LEN OF THIS ENTRY
         LA      R3,0(R1,R3)           GET NEXT ADDRESS IN ALLOC AREA
         LR      R7,R8                 SAVE PREV CELL POINTER
         CPOOL   GET,U,CELL=(R8),CPID=POOLADR
         ST      R8,4(R7)              SAVE NEXT IN PREV
         B       GETL10                NEXT DSN
GETD99   DS      0H
         SR      R3,R3
         LA      R5,ARLAREA
         IC      R3,16(,R5)     SUBPOOL TO FREE
         L       R4,16(,R5)     GET LENGTH
         ST      R4,DWORD       FIX UP LENGTH
         MVI     DWORD,X'80'    SHOW AS LAST OF LIST
         LA      R4,DWORD
         FREEMAIN RC,A=ARLAREA,LV=(4),SP=(3)
GETDE    PROC    END
***********************************************************************
***  GETDSN SUBROUTINE GETS 1 DATA SET IN CONCATENATION            ***
***  1. PUTS DSN  FOUND IN JSCB &  BLOCK SIZE TO CPOOL'S AREA.     ***
***  2. IF DEBUG ON, DISPLAY DATASET FOUND.                        ***
***                                                                ***
***********************************************************************
GETDSN   PROC    BEGIN
*****    TRACE   GETDSN
GETDSN10 EQU     *
         MVC     D_DSN(44),4(R3)       MOVE THE DSN
         MVC     D_BLKS(2),4+102(R3) MOVE BLKSIZE
         LH      R1,D_BLKS             DEBUGGING
AFTERB   DS      0H
         XR      R1,R1
         ST      R1,D_NDSN             ZAP NEXT DSN POINTER
         DEBUG   BEGIN                 ISSUE DEBUG MSGS
         MVC     D1010AM,D_DSN         .
         LH      R1,=H'48'              .
         STH     R1,D1010AL              .
         LH      R1,=H'10'                .
         STH     R1,D1010AO                .
         PUTMSG  D1090,D1010A          DSN=DATA.SET.NAME
         DEBUG   END
GETDSN   PROC    END
***********************************************************************
***  DISPLAY CURRENT DSN LIST                                      ***
***********************************************************************
DISPDSN  PROC    BEGIN
****     TRACE   DISPDSN
         PUTMSG  D1080
         L       R8,FCELLADR           FIRST CELL ADDRESS
         USING   D_DSND,R8             ADDRESSIBILITY TO CELL
DISP10   DS      0H
         LTR     R8,R8                 IS THIS NULL ENTRY?
         BE      DISPE0                YES END OF LIST
         MVC     D1010AM,D_DSN
         LH      R1,=H'48'
         STH     R1,D1010AL
         LH      R1,=H'10'
         STH     R1,D1010AO
         PUTMSG  D1090,D1010A          DSN=DATA.SET.NAME
         L       R8,D_NDSN             NO CHECK NEXT DSN
         B       DISP10                DO LOOP AGAIN
DISPE0   L       R15,RC0
DISPDSN  PROC    END
***********************************************************************
***  DELLST SCANS THE DATA SET LIST FOR OURDSN AND DELETES IT      ***
***********************************************************************
DELLST   PROC    BEGIN
         BAL     R14,FINDDSN
         LTR     R15,R15               DID WE FIND IT?
         BNE     DELE8                 NO BAIL OUT
         USING   D_DSND,R8             ADDRESSIBILITY TO CELL
         CL      R6,RC12               IS DSN ONLY ONE IN LIST?
         BNE     DEL10                 NO CHECK NEXT TYPE
         XR      R1,R1                 ZAP REG
         ST      R1,FCELLADR           AND ZAP LIST
         B       DELFREE               GO KILL CELL->R8
DEL10    DS      0H
         CL      R6,RC8                IS DSN LAST IN LIST?
         BNE     DEL20                 NO CHECK NEXT TYPE
         XR      R1,R1                 ZAP REG
         ST      R1,4(,R7)             ZAP PREV POINTER TO CURRENT
         B       DELFREE               GO KILL CELL ->R8
DEL20    DS      0H
         CL      R6,RC0                IS DSN FIRST?
         BNE     DEL30                 NO MUST BE MIDDLE
         L       R1,D_NDSN             GET POINTER TO NEXT DSN
         ST      R1,FCELLADR           SAVE AS FIRST DSN IN LIST
         B       DELFREE               GO KILL CELL ->R8
DEL30    DS      0H                    MUST BE MIDDLE
         L       R1,D_NDSN             GET NEXT POINTER
         ST      R1,4(,R7)             SAVE IN PREV DSN
DELFREE  DS      0H                    FREE CURRENT CELL
         CPOOL   FREE,CPID=POOLADR,CELL=(R8)
         B       DELE0
DELE8    L       R15,RC8
         B       DELLST99
DELE0    L       R15,RC0
         B       DELLST99
DELLST   PROC    END
***********************************************************************
***  FINDDSN SCANS THE DATA SET LIST LOOKING FOR OURDSN            ***
***  FINDDSN RETURNS R8=POINTER TO DSN OR NULL                     ***
***                  R6=0 - DSN IS FIRST IN LIST                   ***
***                  R6=4 - DSN IS IN MIDDLE OF LIST               ***
***                  R6=8 - DSN IS LAST IN LIST                    ***
***                  R6=12- DSN IS ONLY ONE IN LIST                ***
***                  R7=  - PREVIOUS DATA SET POINTER              ***
***                  R15=0  DSN FOUND                              ***
***                  R15=8  DSN NOT FOUND                          ***
***                                                                ***
***  IN THE 'GETDSNS' SECTION OF THE CODE WE HAVE BUILT A SERIES   ***
***  OF CONTROL BLOCKS (WITH THE HELP OF CPOOL) WHICH CONTAIN      ***
***  ALL THE DSN'S IN THE DDNAME'S CONCATENATION.                  ***
***  IN THIS SECTION (FINDDSN), I WILL LOOK AT THIS LIST OF        ***
***  DSN'S, COMPARING TO THE LIST SPECIFIED ON THE COMMAND LINE.   ***
***                                                                ***
***  THIS ROUTINE VALIDATES THE 'FIRST', 'LAST' JUNK.  IF YOU      ***
***  HAVE SPECIFIED MORE THAN ONE DATASET ON THE COMMAND LINE      ***
***  I HAVE NO IDEA WHAT THIS DOES....   HONEST WHALEY             ***
***                                                                ***
***********************************************************************
FINDDSN  PROC    BEGIN
         L       R8,FCELLADR           GET FIRST CELL POINTER
         L       R7,RC0                PREV CELL POINTER NULL
         USING   D_DSND,R8             ADDRESSABILITY
FIND10   DS      0H                    START OF LIST LOOP
         LTR     R8,R8                 THIS ENTRY NULL?
         BZ      FINDE8                YES - DSN NOT FOUND
         CLC     D_DSN,OURDSN          IS THIS OUR DSN?
         BE      FIND20                YES CONTINUE PROCESSING
         LR      R7,R8                 PREV CELL POINTER
         L       R8,D_NDSN             NEXT DSN POINTER
         B       FIND10
FIND20   DS      0H                    DSN HAS BEEN FOUND!
         L       R15,RC0               SET 0 RETURN CODE
         L       R6,4(,R8)             POINT AT NEXT DSN
         LTR     R6,R6                 ANY MORE DATA SETS?
         BNZ     FIND30                YES MUST BE FIRST OR MIDDLE
         LTR     R7,R7                 IT'S LAST DSN IS IT FIRST ALSO?
         BNZ     FIND40                NOT FIRST ALSO
         L       R6,RC12               LAST DATA SET IS ALSO FIRST
         B       FIND99
FIND30   DS      0H                    MORE DATA SETS IN LIST
         LTR     R7,R7                 IS IT FIRST DATA SET?
         BNZ     FIND50                NO MUST BE MIDDLE
         L       R6,RC0                SET FIRST DATA SET IN LIST
         B       FIND99
FIND40   DS      0H                    LAST DSN BUT NOT FIRST
         L       R6,RC8                SET LAST DATA SET
         B       FIND99
FIND50   DS      0H                    NOT FIRST AND NOT LAST
         L       R6,RC4                SET MIDDLE DSN
         B       FIND99
FINDE8   L       R15,RC8
FIND99   DS      0H
FINDDSN  PROC    END
         EJECT
***********************************************************************
*** FREECMD WILL ISSUE A FREE COMMAND ON OURDSN                     ***
***********************************************************************
FREECMD  PROC    BEGIN
         BAL     R14,GETBUFF
         BAL     R14,MOVE0             FREE  F(
         BAL     R14,MOVE2             OURDD
         BAL     R14,MOVE3A            )
         BAL     R14,EXCMD
*        L       R2,CMDBUFAD
*        TPUT    (R2),(R5)             DISPLAY COMMAND
         L       R15,RC0
         BAL     R14,RELBUFF
FREECMD  PROC    END
         EJECT
***********************************************************************
***  BUILD TSO ALLOCATE COMMAND                                     ***
***     R8 WILL POINT AT THE CURRENT DSN                            ***
***     R7 WILL CONTAIN THE LENGTH OF THE DSN OR SOURCE DATA        ***
***     R6 WILL POINT AT THE NEXT POSITION IN THE BUFFER TO USE     ***
***     R5 WILL CONTAIN THE TOTAL LENGTH OF THE BUFFER              ***
***     R4 WILL POINT AT CURRENT 'NEWPOOL' POOL BLOCK               ***
***********************************************************************
DOCMD    PROC    BEGIN
         BAL     R14,GETBUFF
         BAL     R14,MOVE1             ALLOC F(
         BAL     R14,MOVE2             OURDD
         BAL     R14,MOVE3             ) DA(
         L       R4,NEWFIRST           FIRST CELL ADDRESS
         USING   N_DSECT,R4            ADDRESSIBILITY TO CELL
*
DOCMD15  EQU     *
         ST      R4,SAVECUR            SAVE CURRENT POOL
         BAL     R14,MOVE4              MOVE "'"
         LA      R8,N_DSN              POINT AT DATA SET
         BAL     R14,MOVE5             DATA SET IS MOVED
         BAL     R14,MOVE4             MOVE "'"
         BAL     R14,MOVE7             MOVE " "
*
         L       R4,SAVECUR            RESTORE R4 TO POOL PTR
         L       R4,N_PTR              GET 'NEXT' POINTER
         LTR     R4,R4                 IS THIS NULL ENTRY?
         BNZ     DOCMD15               NO, DO NEXT DSN
         DROP    R4
*
         BAL     R14,MOVE6             ) SHR REUSE
***      L       R2,CMDBUFAD
***      TPUT    (R2),(R5)      DEBUG  DISPLAY COMMAND
         BAL     R14,EXCMD
         L       R15,RC0
         BAL     R14,RELBUFF
DOCMD    PROC    END
***********************************************************************
***  GET THE STORAGE BELOW THE LINE FOR THE TSO COMMAND BUFFER      ***
***********************************************************************
GETBUFF  PROC    BEGIN
         GETMAIN R,LV=4095,SP=0,LOC=BELOW
         ST      R1,CMDBUFAD
         LR      R6,R1                 POINT AT BUFFER
         XR      R5,R5                 ZAP THE LENGTH
GETBUFF  PROC    END
***********************************************************************
***  RELEASE THE TSO COMMAND STORAGE                                ***
***********************************************************************
RELBUFF  PROC    BEGIN
         L       R1,CMDBUFAD
         FREEMAIN R,LV=4095,A=(1)
*
*  POOL USED FOR DSN'S
*
         L       R1,NEWPOOL           WAS IT EVER USED?
         LTR     R1,R1                IF ZERO, NO
         BZ      RELBUF99             SKIP POOL DELETE
         CPOOL   DELETE,CPID=NEWPOOL
*
RELBUF   PROC    END
***********************************************************************
***  MOVE 'FREE  F(' TO START OF BUFFER                             ***
***********************************************************************
MOVE0    PROC    BEGIN
         MVC     0(8,R6),=CL8'FREE  F('
         LA      R5,8(,R5)
         LA      R6,8(,R6)
MOVE0    PROC    END
***********************************************************************
***  MOVE 'ALLOC F(' TO START OF BUFFER                             ***
***********************************************************************
MOVE1    PROC    BEGIN
         MVC     0(8,R6),=CL8'ALLOC F('
         LA      R5,8(,R5)
         LA      R6,8(,R6)
MOVE1    PROC    END
***********************************************************************
***  MOVE OURDD TO THE BUFFER                                       ***
***********************************************************************
MOVE2    PROC    BEGIN
         MVC     0(8,R6),OURDD
         LA      R5,8(,R5)
         LA      R6,8(,R6)
MOVE2    PROC    END
***********************************************************************
***  MOVE ') DA(' TO THE BUFFER                                     ***
***********************************************************************
MOVE3    PROC    BEGIN
         MVC     0(5,R6),=CL5') DA('
         LA      R5,5(,R5)
         LA      R6,5(,R6)
MOVE3    PROC    END
***********************************************************************
***  MOVE ')'     TO THE BUFFER                                     ***
***********************************************************************
MOVE3A   PROC    BEGIN
         MVC     0(1,R6),=CL1')'
         LA      R5,1(,R5)
         LA      R6,1(,R6)
MOVE3A   PROC    END
***********************************************************************
***  MOVE "'" TO THE BUFFER                                         ***
***********************************************************************
MOVE4    PROC    BEGIN
         MVI     0(R6),X'7D'           A QUOTE
         LA      R5,1(,R5)
         LA      R6,1(,R6)
MOVE4    PROC    END
***********************************************************************
***  MOVE THE DATA SET POINTED TO BY R8 TO THE BUFFER UNTIL A ' '   ***
***********************************************************************
MOVE5    PROC    BEGIN
         XR      R7,R7                 CURRENT LENGTH
MOVE510  LA      R4,0(R7,R8)           POINT AT POSITION IN STRING
         CLI     0(R4),C' '            DID WE HIT A SPACE?
         BE      MOVE520               YES DO MOVE
         LA      R7,1(,R7)             NO BUMP POSITION
         B       MOVE510               AND TRY AGAIN
MOVE520  DS      0H                    BUMP LENGTH DOWN BY 1
         EX      R7,LOADV              DO THE MOVE
         AR      R6,R7                 BUMP THE BUFFER POSITION
         AR      R5,R7                 BUMP TNE BUFFER LENGTH
MOVE5    PROC    END
***********************************************************************
***  MOVE ') SHR REUSE' TO THE BUFFER                               ***
***********************************************************************
MOVE6    PROC    BEGIN
         MVC     0(11,R6),=CL11') SHR REUSE'
         LA      R5,11(,R5)
         LA      R6,11(,R6)
MOVE6    PROC    END
***********************************************************************
***  MOVE ' ' TO THE BUFFER                                         ***
***********************************************************************
MOVE7    PROC    BEGIN
         MVC     0(1,R6),=CL1' '
         LA      R5,1(,R5)
         LA      R6,1(,R6)
MOVE7    PROC    END
***********************************************************************
***  EXECUTE THE TSO COMMAND AT CMDBUFAD FOR LENGTH R5              ***
***********************************************************************
EXCMD    PROC    BEGIN
         L       R15,CVTPTR            GET CVT POINTER
         L       R15,CVTTVTO(,R15)     TSO CVT
         L       R15,TSVTASF-TSVT(,R15)
         L       R6,CMDBUFAD           GET COMMAND BUFFER ADDRESS
         ST      R5,CMDLEN             SAVE NEW LENGTH
         MVI     ABFLAGS,X'00'   DUMP THIS SUCKER IF SHE ABENDS!
         MVI     FNCFLAGS,X'01'  SIGNAL THIS IS A TSO COMMAND!
         SR      R1,R1
         STH     R1,RESFLAGS     MUST BE ZERO FOR FUNCTION TO WORK
         CALL    (15),(FLAGS,(R6),CMDLEN,                              X
               RETCODE,RSNCODE,ABNDCODE),VL,                           X
               MF=(E,CALLP1)
EXCMD    PROC    END
***********************************************************************
***  THESE SUBROUTINES ARE FOR ERROR MESSAGES AND EXTENDED RETURN CD***
***********************************************************************
* DDNAME (DDNAME) NOT ALLOCATED AND REMOVE KEYWORD DETECTED
***********************************************************************
RCX100   DC      CL4'0100'            (R100L1,D1020A,R100L2)
R100L1   TSOMSG  ' DDNAME '
R100L2   TSOMSG  ' NOT ALLOCATED AND REMOVE KEYWORD DETECTED',OFFSET=8
*
R100     PROC    BEGIN
         LA      R7,8
         STH     R7,D1020AO            SAVE OFFSET OF DDNAME
         PUTMSG  R100L1,D1020A,R100L2
         MVC     CONRCX,RCX100
         BAL     R14,RCCODE
R100     PROC    END
***********************************************************************
* DDNAME (DDNAME) NOT ALLOCATED AND VERIFY KEYWORD DETECTED
***********************************************************************
RCX102   DC      CL4'0102'            (R102L1,D1020A,R102L2)
R102L1   TSOMSG  ' DDNAME '
R102L2   TSOMSG  ' NOT ALLOCATED AND VERIFY KEYWORD DETECTED',OFFSET=8
R102     PROC    BEGIN
         LA      R7,8
         STH     R7,D1020AO
         PUTMSG  R102L1,D1020A,R102L2   DDNAME NOT FOUND AND VERIFY
         MVC     CONRCX,RCX102           KEYWORD DETECTED
         BAL     R14,RCCODE
R102     PROC    END
***********************************************************************
* DDNAME (DDNAME) NOT FOUND HAS BEEN ALLOCATED
***********************************************************************
RCX110   DC      CL4'0110'
R110L1   TSOMSG  ' DDNAME '
R110L2   TSOMSG  ' NOT FOUND. HAS BEEN ALLOCATED',OFFSET=8
R110     PROC    BEGIN
         LA      R7,8
         STH     R7,D1020AO
         PUTMSG  R110L1,D1020A,R110L2
         MVC     CONRCX,RCX110         DDNAME NOT FOUND ALLOCATED
         BAL     R14,RCCODE
R110     PROC    END
***********************************************************************
* DSNAME (DSNAME) NOT CATALOGED
***********************************************************************
RCX120   DC      CL4'0120'
R120L1   TSOMSG  ' DSNAME '
R120L2   TSOMSG  ' NOT CATALOGED ',OFFSET=8
R120     PROC    BEGIN
         LA      R7,8
         STH     R7,D1010AO
         PUTMSG  R120L1,D1010A,R120L2   DSNAME NOT CATALOGED
         MVC     CONRCX,RCX120
         BAL     R14,RCCODE
R120     PROC    END
***********************************************************************
* DSNAME (DSNAME) NOT ON VOLUME
***********************************************************************
RCX130   DC      CL4'0130'
R130L1   TSOMSG  ' DSNAME '
R130L2   TSOMSG  ' NOT ON VOLUME ',OFFSET=8
R130     PROC    BEGIN
         LA      R7,8
         STH     R7,D1010AO
         MVC     D1050CM,OURVOL
         STH     R7,D1050CO
         LA      R7,10
         STH     R7,D1050CL
         PUTMSG  R130L1,D1010A,R130L2,D1050C   DSNAME NOT ON VOLUME
         MVC     CONRCX,RCX130
         BAL     R14,RCCODE
R130     PROC    END
***********************************************************************
* DSNAME (DSNAME) NOT IN CONCATENATION LIST FOR DDNAME (DDNAME)
***********************************************************************
RCX140   DC      CL4'0140'
R140L1   TSOMSG  ' DSNAME '
R140L2   TSOMSG  ' NOT IN CONCATENATION LIST FOR DDNAME ',OFFSET=8
R140     PROC    BEGIN
         L       R8,0(,R5)             GET DATA SET ADDRESS
         LH      R7,4(,R5)             GET LENGTH OF DATA SET
         BCTR    R7,0                  ADJUST FOR MACHINE
         LA      R6,D1010AM            POINT AT DESTINATION
         EX      R7,LOADV              MOVE IN THE DATA SET
         LA      R7,5(R7)              FOR PUTLINE HEADER
         STH     R7,D1010AL            SAVE LENGTH
         LA      R7,10
         STH     R7,D1010AO            SAVE OFFSET
         LA      R7,8
         STH     R7,D1010AO
         MVC     D1020AM,OURDD
         LA      R7,8
         STH     R7,D1020AO
         LA      R7,12
         STH     R7,D1020AL
         PUTMSG  R140L1,D1010A,R140L2,D1020A
         MVC     CONRCX,RCX140
         BAL     R14,RCCODE
R140     PROC    END
***********************************************************************
* DSNAME (DSNAME) ALREAY IN CONCATENATION AND "ONLY" KEYWORD DETECTED
***********************************************************************
RCX150   DC      CL4'0150'
R150L1   TSOMSG  ' DSNAME '
R150L2   TSOMSG  ' ALREADY IN CONCATENATION AND "ONLY" DETECTED',      X
               OFFSET=8
*
*  THIS SUBROUTINE EXPECTS THE CURRENT DSN PDE ADDRESS IN R5
*
R150     PROC    BEGIN
         L       R8,0(,R5)             GET DSN NAME ADDRESS
         LH      R7,4(,R5)             GET LENGTH OF DATA SET NAME
         BCTR    R7,0                  ADJUST FOR MACHINE
         LA      R6,D1010AM            POINT AT DESTINATION
         EX      R7,LOADV              MOVE IN THE DATA SET
         LA      R7,5(R7)              FOR PUTLINE HEADER
         STH     R7,D1010AL            SAVE LENGTH
         LA      R7,10
         STH     R7,D1010AO            SAVE OFFSET
         LA      R7,8
         STH     R7,D1010AO
         MVC     D1020AM,OURDD
         LA      R7,8
         STH     R7,D1020AO
         LA      R7,12
         STH     R7,D1020AL
         PUTMSG  R150L1,D1010A,R150L2
         MVC     CONRCX,RCX150
         BAL     R14,RCCODE
R150     PROC    END
***********************************************************************
***  CHECK FOR RCX AND IF PRESENT CREATE RCX RETURN CODE            ***
***********************************************************************
RCCODE   PROC    BEGIN
         LH      R7,RC
         CH      R7,=H'2'
         BNE     RCCODE99
         LA      R7,CONRCX
         ST      R7,VALUEPTR
         L       R15,CVTPTR            ACCESS THE CVT
         L       R15,CVTTVTO(,R15)     ACCESS THE TSVT
         L       R15,TSVTVACC-TSVT(,R15)
         CALL    (15),                                                 X
               (ECODE,                                                 X
               NAMEPTR,                                                X
               RCXLEN,                                                 X
               VALUEPTR,                                               X
               RCVLEN,                                                 X
               TOKEN),                                                 X
               VL,MF=(E,CLISTV)
RCCODE   PROC    END
***********************************************************************
***  VERIFY AND DISPLAY THE PARAMETERS PASSED TO CONCAT             ***
***********************************************************************
VPARMS   PROC    BEGIN
         L       R8,DDNAME             GET DDNAME ADDRESS
         LH      R7,DDNAME+4           GET LENGTH OF DDNAME
         BCTR    R7,0                  ADJUST FOR MACHINE
         LA      R6,D1020AM            POINT AT DESTINATION
         EX      R7,LOADV              MOVE IT IN
         LA      R7,5(R7)              ADJUST FOR PUTLINE HEADER
         STH     R7,D1020AL            SAVE IN LENGTH AREA
         LA      R7,13                 OFFSET INTO DDNAME= MSG
         STH     R7,D1020AO            SAVE OFFSET
*---"D1020 DDNAME=",(D1020A)
         PUTMSG  D1020,D1020A
*
* DISPLAY ALL THE DATASETS IN THE LIST
* REG R10 POINTS TO IKJPARM DSECT AREA WITH A USING
*
         LA      R5,DSNAME             POINTER TO FIRST(?) DSN BLOCK
MW0001   EQU     *
         L       R8,0(,R5)             GET DATA SET NAME ADDRESS
         LH      R7,4(,R5)             GET LENGTH OF DATA SET NAME
         BCTR    R7,0                  ADJUST FOR EXECUTE LEN (-1)
         LA      R6,D1010AM            POINT AT DESTINATION
         EX      R7,LOADV              MOVE IN THE DATA SET
         LA      R7,5(R7)              FOR PUTLINE HEADER
         STH     R7,D1010AL            SAVE LENGTH
         LA      R7,10
         STH     R7,D1010AO            SAVE OFFSET
*---"D1010 DSN=",(D1010A)
         PUTMSG  D1010,D1010A
         CLC     24(4,R5),=XL4'FF000000'  END OF DSN CHAIN FLAG
         BE      MW0002                NO MORE DATASETS
         L       R5,24(,R5)            GET NEXT DSN PDE CNTL BLOCK
         B       MW0001                PROCESS NEXT DSN
MW0002   EQU     *
*
*
*
*
         LH      R1,EVON
         CH      R1,=H'1'
         BNE     VPARM20
*---"D1030 KEYWORD=,ONLY
         PUTMSG  D1030,D1030A
         B       VPARM30
VPARM20  CH      R1,=H'2'
         BNE     VPARM21
*---"D1030 KEYWORD=,EVEN
         PUTMSG  D1030,D1030B
         B       VPARM30
VPARM21  CH      R1,=H'3'
         BNE     VPARM22
*---"D1030 KEYWORD=,VERIFY
         PUTMSG  D1030,D1030C
         B       VPARM30
*---"D1030 KEYWORD=,REMOVE
VPARM22  PUTMSG  D1030,D1030D
VPARM30  DS      0H
         LH      R1,AFTBEF
         CH      R1,=H'1'
         BNE     VPARM31
         PUTMSG  D1030,D1040A
         B       VPARM40
VPARM31  CH      R1,=H'2'
         BNE     VPARM32
         PUTMSG  D1030,D1040B
         B       VPARM40
VPARM32  L       R7,POS                GET THE POS FROM PARS
         L       R7,0(,R7)             INTG IS FULLWORD BIN INTEGER
         CVD     R7,DWORD              CONVERT FOR DISPLAY
         OI      DWORD+7,X'0F'         FIX SIGN
         UNPK    D1040EM(3),DWORD(8)   UNPACK IT
         LA      R7,7                  LENGTH OF PARM
         STH     R7,D1040EL            SAVE IT
         LA      R7,14                 OFFSET INTO TEXT
         STH     R7,D1040EO            SAVEIT
*---D1030 KEYWORD=,POS, SUBFIELD=(D1040E)
         PUTMSG  D1030,D1040C,D1040D,D1040E
VPARM40  LH      R1,VOLUME
         CH      R1,=H'1'
         BNE     VPARM41
         PUTMSG  D1030,D1050A
         B       VPARM50
VPARM41  LH      R7,VOL+4
         L       R8,VOL
         LA      R6,D1050CM
         BCTR    R7,0
         EX      R7,LOADV
         LA      R7,5(,R7)
         STH     R7,D1050CL
         LA      R7,14
         STH     R7,D1050CO
         PUTMSG  D1030,D1050B,D1040D,D1050C
VPARM50  DS      0H
         LH      R1,MSG
         CH      R1,=H'1'
         BNE     VPARM61
         PUTMSG  D1030,D1060A
         B       VPARM70
VPARM61  PUTMSG  D1030,D1060B
VPARM70  DS      0H
         LH      R1,DEBUG
         CH      R1,=H'1'
         BNE     VPARM71
         PUTMSG  D1030,D1070A
         B       VPARM80
VPARM71  PUTMSG  D1030,D1070B
VPARM80  DS      0H
VPARMS   PROC    END
***********************************************************************
***  EXECUTED INSTRUCTIONS                                          ***
***********************************************************************
***  LOAD A DATABUFFER WITH A VARIABLE AMOUNT OF DATA               ***
*** R8=SOURCE, R6=DESTINATION, R7= LENGTH, EX R7,LOADV
***
LOADV    MVC   0(0,R6),0(R8)           <<<< EXECUTED >>>>
***********************************************************************
***  CONSTANTS                                                      ***
***********************************************************************
RC0      DC      F'0'                  0 RETURN CODE
RC4      DC      F'4'                  4 RETURN CODE
RC8      DC      F'8'                  8 RETURN CODE
RC12     DC      F'12'                12 RETURN CODE
*
BLANK80  DC      CL80' '
         ORG     BLANK80
BLANK8   DS      CL8
BLANK44  DS      CL44
         ORG
*
ECODE    DC      A(TSVEUPDT)
NAMEPTR  DC      A(RCXNAME)
RCXNAME  DC      CL3'RCX'
RCXLEN   DC      F'3'
RCVLEN   DC      F'4'
         LTORG
         EJECT
***********************************************************************
***********************************************************************
***  I N S S E C T    CSECT                                         ***
***    THIS CSECT WAS STARTED BECAUSE THE MAIN ONE 'CONCAT'         ***
***    RAN OUT OF TWO BASE REGISTERS WORTH OF ROOM.     -WHALEY     ***
***                                                                 ***
***  ON ENTRY, R13 POINTS TO THE DATAAREA DSECT AREA                ***
***                                                                 ***
***********************************************************************
***  READY WITH THE DSN NAMES!                                      ***
***                                                                 ***
***  - OLD DSN'S:  CELLS DESCRIBED BY THE D_DSND DSECT, ONE         ***
***                'CELL' PER DSN.  THE FIRST ONE IS POINTED TO     ***
***                BY ADDRESS FCELLADR.  THE CHAIN AND POINT TO     ***
***                EACH OTHER....                                   ***
***  - NEW DSN'S:  AT THE START A CALL IS MADE TO IKJPARS.          ***
***                THIS FILLS IN THE CONTROL BLOCKS IN THE CMDEF    ***
***                CSECT AREA.  ONE OF THESE IS A PDE DESCRIBING    ***
***                THE DSNAME.  EACH DSNAME PDE IS 24 BYTES.        ***
***                AT +24 IN EACH IS A POINTER TO THE NEXT          ***
***                PDE OR IS X'FF000000'.                           ***
***              * IF THE MEMBER NAME FIELD IN THE DSN PDE IS SET   ***
***                TO X'AAAAAAAA' THEN 'ONLY' PROCESSING HAS        ***
***                DECIDED NOT TO USE THIS ENTRY.  SKIP IT.         ***
***                                                                 ***
***                                                                 ***
***********************************************************************
***                                                                 ***
***  INSDSN WILL INSERT OURDSN IN THE RIGHT PLACE                   ***
***    R15=POSITION 1= FIRST/ FF=LAST                               ***
***                                                                 ***
***********************************************************************
INSSECT  CSECT   ,
INSSECT  AMODE   31
INSSECT  RMODE   ANY
*
         STM     R14,R12,12(R13)       SAVE 'CONCAT'S REGS
         LR      R12,R15               GET ADDRESSIBILITY TO INSSECT
         USING   INSSECT,R12
         LR      R11,R13               GET ADDRESSIBILITY TO DATAAREA
         DROP    R13
         USING   DATAAREA,R11
         LA      R13,INSSAVE           NEW SAVE AREA
         LR      R2,R1                 SAVE REG 1! PAST CPOOL EXEC
*
******   TRACE   INSSECT
         SR      R3,R3
         ST      R3,NEWFIRST           NO CELLS AT THIS TIME IN NEWPOOL
         CPOOL   BUILD,PCELLCT=15,SCELLCT=15,CSIZE=N_LEN,              X
               CPID=NEWPOOL,SP=2
*
         C       R2,=F'1'              NEW ONE'S FIRST?
         BE      FIRST
*
*   INSERT THE NEW NAMES LAST
*
         BAL     R14,OLDONES
         BAL     R14,NEWONES
         B       INSDSN99               END
*
*   PUT NEW NAMES FIRST
*
FIRST    BAL     R14,NEWONES
         BAL     R14,OLDONES
*
*  LET'S GO HOME....
*
INSDSN99 EQU     *
****     TRACE   INS_DONE
         LR      R13,R11          REMEMBER R11 WAS R13 --> DATAAREA
         LM      R14,R12,12(R13)
         BR      R14
*
***********************************************************************
***  THIS ROUTINE ADDS A POOL ENTRY AND SET R3 POINTING TO IT       ***
***********************************************************************
NEW_ADD  PROC    BEGIN                 ADD A NEW POOL CELL AND INIT
****     TRACE   NEW_ADD
         CPOOL   GET,UNCOND,CPID=NEWPOOL,CELL=(R3),REGS=SAVE GET BLOCK
         USING   N_DSECT,R3            ADDRESSIBILITY TO VARIABLES
         LA      R4,NEWFIRST           POINT AT FIRST ONE
NEW_A10  EQU     *                     CHECK CHAIN
         L       R5,0(,R4)             GET NEXT ADDRESS POINTER
         LTR     R5,R5                 IF ZERO, AT END OF CHAIN
         BZ      NEW_A50               GO INIT THE NEW ONE.
         L       R4,0(,R4)             FIRST WORD IS ADDR TO NEXT ONE
         B       NEW_A10               LOOK AGAIN
*
* HERE R4 POINTS TO PREV POOL ENTRY, R3 AT THE ONE JUST OBTAINED
NEW_A50  EQU     *
         ST      R3,0(,R4)             SAVE NEXT POINTER
         MVI     N_DSN,C' '
         MVC     N_DSN+1(45),N_DSN     BLANK OUT DSN FIELD
         SR      R5,R5
         ST      R5,N_PTR              CLEAR 'NEXT' POINTER
         MVI     N_YESNO,C'Y'          USE THIS ENTRY, FOR NOW
         MVC     N_BLKSZ(2),=H'00'     ONLY ZAP FOR NOW
         DROP    R3
NEW_A    PROC    END
         EJECT
***********************************************************************
***                                                                 ***
***  INSERT THE OLD NAMES INTO THE CHAIN                            ***
***  ALSO CALC THE LENGTH OF THE NAME, IT'S NOT IN THE JFCB...      ***
***                                                                 ***
***********************************************************************
EX_MOVEO MVC     4(0,R3),D_DSN-D_DSND(R8) EXECUTED MOVE INSTRUCTION
*
OLDONES  PROC    BEGIN
****     TRACE   OLDONES
         MVC     EX_MOVER(6),EX_MOVEO  TO MAKE RE-ENTRANT.....
         LA      R8,FCELLADR-4   (-4 SO FIRST LOAD WILL WORK, SORRY!)
         USING   D_DSND,R8             ADDRESSIBILITY TO CELL
OLD_10   EQU     *
         L       R8,D_NDSN             GET NEXT POINTER
         LTR     R8,R8
         BZ      OLD_END99             END THE CRUEL SEARCH!
*
*  CHECK TO SEE IF THE NAME IS ALREADY IN THE LIST
*
         LA      R2,43         MAX LENGTH TO CHECK FOR MATCH
         LA      R3,D_DSN-D_DSND(R8)   DSN TO CHECK
         BAL     R14,INLIST            CHECK FOR DUPLICATE
         LTR     R15,R15               ZERO= NOT DUP
         BNZ     OLD_10                SKIP TO NEXT ONE
*
*  ADD ANOTHER DSN, GET A NEW CELL,   R3 POINTS TO CELL ON RETURN
*
         BAL     R14,NEW_ADD           ADD AND INIT NEW CELL
         USING   N_DSECT,R3            ADDRESSIBILITY TO NEW CELL
         LA      R2,44                 LENGTH OF DSN
         BCTR    R2,0                  DROP BY 1 FOR EXEC LEN
         EX      R2,EX_MOVER           MOVE IN NEW DSN FROM R8
         MVC     N_BLKSZ,D_BLKS        MOVE IN BLOCK SIZE
*
         DROP    R3
         B       OLD_10                PROCESS NEXT ONE
         DROP    R8
*
OLD_END  PROC    END
*
*
         EJECT
***********************************************************************
***                                                                 ***
***  INSERT THE NEW NAMES INTO THE CHAIN                            ***
***                                                                 ***
***********************************************************************
EX_MOVEN MVC     4(0,R3),0(R7) EXECUTED MOVE INSTRUCTION
*
NEWONES  PROC    BEGIN
****     TRACE   NEWONES
         MVC     EX_MOVER(6),EX_MOVEN  TO MAKE RE-ENTRANT.....
         LA      R8,DSNAME             GET FIRST 'USER' DSN
*
NEW_20   CLC     8(4,R8),=X'AAAAAAAA'  COMPARE MEMBER NAME SKIP FLAG
         BE      NEW_40                SKIP THIS GUY
*
*  CHECK FOR DUPICATES ALREADY IN THE LIST
*
         LH      R2,4(,R8)             MAX LENGTH TO COMPARE
         L       R3,0(,R8)             GET DSN ADDRESS
         CLI     0(R3),X'7D'           CHECK FOR STARTING QUOTE
         BNE     NEW_NOQ
         LA      R3,1(,R3)             GET PAST THE STARTING QUOTE...
NEW_NOQ  BAL     R14,INLIST
         LTR     R15,R15
         BNZ     NEW_40                BYPASS HIM
*
*  ADD ANOTHER DSN, GET A NEW CELL,   R3 POINTS TO CELL ON RETURN
*
         BAL     R14,NEW_ADD           ADD AND INIT NEW CELL
         USING   N_DSECT,R3            ADDRESSIBILITY TO NEW CELL
         LH      R2,4(,R8)             LENGTH OF DSN
         BCTR    R2,0                  DROP BY 1 FOR EXEC LEN
         L       R7,0(,R8)             GET DSN ADDRESS
*******  TM      6(R8),B'01000000'     DSN IN QUOTES?
         CLI     0(R7),X'7D'           CHECK FOR STARTING QUOTE
         BNE     NEW_EX
         LA      R7,1(,R7)             GET PAST THE STARTING QUOTE...
NEW_EX   EX      R2,EX_MOVER           MOVE IN NEW DSN FROM R7
****     MVC     N_BLKSZ,D_BLKS        MOVE IN BLOCK SIZE
*
         DROP    R3
NEW_40   CLC     24(4,R8),=X'FF000000' IS THERE A NEXT ONE?
         BE      NEW_E99               IT IS DONE.......
         L       R8,24(,R8)            ADDRESS OF NEXT ONE
         B       NEW_20                PROCESS NEXT ONE
NEW_E    PROC    END
         EJECT
***********************************************************************
* COMPARE TO SEE IF THE DSN IS ALREADY IN THE LIST
* R2=MAX LEN TO CHECK    R3=PTR TO NEW NAME
***********************************************************************
INLIST   DS      0H
         STM     R14,R12,12(R13)       SAVE REGISTERS
*
         LA      R4,NEWFIRST           POINT AT FIRST ONE
INL_10   EQU     *
         L       R4,0(,R4)             GET NEXT ADDRESS POINTER
         USING   N_DSECT,R4            ADDRESSIBILITY!
         LTR     R4,R4                 DONE?
         BZ      INLDONE               ALL DONE!
*
         LR      R6,R3        NEW DSN
         LA      R7,N_DSN     PREV NAME
         LR      R8,R2        MAX LEN
INL_CLC  CLC     0(1,R6),0(R7)         COMPARE
         BNZ     INL_10       BRANCH NOT DUPLICATE, GET NEXT CELL
         CLI     0(R6),C' '   HIT BLANK?
         BNE     INL_CONT     CHECK IF BOTH BLANK...
         CLI     0(R7),C' '   ANOTHER BLANK?
         BE      INLBAD       THEY WERE DUPLICATES!
INL_CONT EQU     *
         LA      R6,1(,R6)    ADD ONE -NEW DSN
         LA      R7,1(,R7)    ADD ONE -ALREADY IN THE POOL
         BCT     R8,INL_CLC   BR WHEN NOT ZERO
*****    B       INLBAD
*
*
INLBAD   EQU     *   THIS GUY IS A DUPLICATE!
         CLI     0(R7),C' '   ALREADY IN POOL END HERE ALSO?
         BNE     INL_10       NO, JUST WAS DUP TO THAT POINT!
         LM      R14,R12,12(R13)       RESTORE
         LA      R15,4        DUP FLAG
         BR      R14
*
INLDONE EQU      *   THIS GUY IS NOT A DUPLICATE!
         LM      R14,R12,12(R13)       RESTORE
         LA      R15,0        OK FLAG!!!
         BR      R14
*
*
         DROP    R4
*
         LTORG
         DROP    R11
         DROP    R12
         EJECT
***********************************************************************
***********************************************************************
***********************************************************************
***  DATA CSECT FOR OVERFLOW CONSTANT DATA AREAS                    ***
***********************************************************************
***********************************************************************
***********************************************************************
*
*
DATASECT CSECT  ,
*
*
***********************************************************************
***  MESSAGE DEFINITIONS FOR PUTLINE                                ***
***********************************************************************
* DIAGNOSTIC MESSAGES
*
D1000 TSOMSG 'D1000 CONCAT COMMAND VERSION 5.1   (&SYSDATE &SYSTIME)'
D1010    TSOMSG  'D1010 DSN='
D1020    TSOMSG  'D1020 DDNAME='
D1030    TSOMSG  'D1030 KEYWORD='
D1030A   TSOMSG  ' ONLY',OFFSET=14
D1030B   TSOMSG  ' EVEN',OFFSET=14
D1030C   TSOMSG  ' VERIFY',OFFSET=14
D1030D   TSOMSG  ' REMOVE',OFFSET=14
D1040A   TSOMSG  ' BEFORE',OFFSET=14
D1040B   TSOMSG  ' AFTER',OFFSET=14
D1040C   TSOMSG  ' POS',OFFSET=14
D1040D   TSOMSG  ' SUBFIELD=',OFFSET=14
D1050A   TSOMSG  ' NOVOLUME',OFFSET=14
D1050B   TSOMSG  ' VOLUME',OFFSET=14
D1060A   TSOMSG  ' NOMSG',OFFSET=14
D1060B   TSOMSG  ' MSG',OFFSET=14
D1070A   TSOMSG  ' NODEBUG',OFFSET=14
D1070B   TSOMSG  ' DEBUG',OFFSET=14
D1080 TSOMSG 'D1080 *--- DATA SETS IN CONCATENATION ARE (BEFORE) ---*'
D1090    TSOMSG  'D1090 DSN='
*
*
***********************************************************************
***  SAMPLE CONTROL BLOCK, MOVE BELOW LINE BEFORE USE!!!            ***
***********************************************************************
EXTRACT  EXTRACT DINKS,,FIELDS=TIOT,MF=L   SAMPLE CNTL BLOCK
EXTEND   EQU     *
DINKS    DS    F          JUST A FULL WORD TO POINT RE-ENTRANT STUFF TO
*
***********************************************************************
***  SAMPLE DCB BLOCK      MOVE BELOW LINE BEFORE USE!!!            ***
***********************************************************************
REALDCB  DCB   DSORG=PS,MACRF=GM,DDNAME=WHALEY,EXLST=DINKS
REALEND  EQU   *
*
*
CONCAT   CSECT   ,
*
*
***********************************************************************
***  COMMAND SYNTAX DEFINTION                                       ***
***********************************************************************
CMDEF    IKJPARM
DDNAME   IKJPOSIT DSNAME,DDNAM,PROMPT='DDNAME',                        X
               HELP=('DDNAME TO CONCAT')
DSNAME   IKJPOSIT DSNAME,LIST,USID,PROMPT='DSNAME',                    X
               HELP=('DATA SET NAME (OR NAME LIST) TO CONCAT')
*
EVON     IKJKEYWD DEFAULT='ONLY'
         IKJNAME  'ONLY',ALIAS=('O','ON')
         IKJNAME  'EVEN',ALIAS=('E','EV')
         IKJNAME  'VERIFY',ALIAS=('V','VER')
         IKJNAME  'REMOVE',ALIAS=('R','REM')
AFTBEF   IKJKEYWD DEFAULT='BEFORE'
         IKJNAME  'BEFORE',ALIAS=('B','BEF','F','FIRST')
         IKJNAME  'AFTER',ALIAS=('A','AF','AFT','L','LAST')
         IKJNAME  'POS',SUBFLD=SUBPOS
VOLUME   IKJKEYWD DEFAULT='NOVOLUME'
         IKJNAME  'NOVOLUME'
         IKJNAME  'VOLUME',SUBFLD=SUBVOL,ALIAS=('VOL','VOLSER')
DEBUG    IKJKEYWD DEFAULT='NODEBUG'
         IKJNAME  'NODEBUG'
         IKJNAME  'DEBUG',ALIAS=('D','DE')
MSG      IKJKEYWD DEFAULT='MSG'
         IKJNAME  'NOMSG'
         IKJNAME  'MSG',ALIAS=('M','MESSAGE')
RC       IKJKEYWD DEFAULT='RCX'
         IKJNAME  'RC'
         IKJNAME  'RCX'
*
SUBPOS   IKJSUBF
POS      IKJIDENT 'POSITION',MAXLNTH=2,FIRST=NUMERIC,OTHER=NUMERIC,    X
               PROMPT='POSITION OF DATA SET IN CONCATENATION',         X
               INTEG,                                                  X
               HELP=('POS ASSUMES YOU WANT TO MANUALY POSITION DSN')
SUBVOL   IKJSUBF
VOL      IKJPOSIT DSNAME,VOLSER,PROMPT='VOLUME SERIAL NUMBER',         X
               HELP=('VOLSER OF DATA SET TO CONCAT')
         IKJENDP
         EJECT
***********************************************************************
         LTORG
***********************************************************************
***  DSECT AREA FOR READ JFCB CONTROL BLOCK                         ***
***********************************************************************
         DSECT ,
         IEFJFCBN
***********************************************************************
***  DSECT AREA                                                     ***
***********************************************************************
         EDDATA
INSSAVE  DS    18F    SAVE AREA FOR INSSECT CSECT
HIGHRC   DS    F      HIGH RC VALUE USED IN A FEW ROUTINES
DWORD    DS    D
EX_MOVER MVC   0(0,0),0(0)    EXECUTED STORAGE
TPUTNAME DS    CL40   AREA FOR TPUT NAME WITH 'TRACE' MACRO
***********************************************************************
*--- EXTENDED RETURN CODE VARIABLE DATA AND PARMLIST
***********************************************************************
CLISTV   DS    6F                      PARM LIST FOR VARIABLE ACCESS
TOKEN    DS    F
VALUEPTR DS    F
CONRCX   DS    CL4                     EXTENDED RETURN CODE
*
CPECB    DS    F                       COMMAND ECB
*
***********************************************************************
*--- AREA OF STORAGE FOR THE EXTRACT PARAMETER LIST
***********************************************************************
         DS    0H
EXTPARM  EXTRACT TIOTADDR,,FIELDS=TIOT,MF=L AREA BELOW LINE
*
***********************************************************************
*--- DATA FOR EXECUTING A TSO COMMAND FRON ANOTHER COMMAND
***********************************************************************
CALLP1   CALL    ,(,,,,,),MF=L
ZERO     DS    F
FLAGS    DS    0F                      MAPS FIRST PARM TO IKJEFTSR
RESFLAGS DS    H                       FLAG WORD
ABFLAGS  DS    X                       DUMP IF ABEND FLAG
FNCFLAGS DS    X
RETCODE  DS    F                       RETURN CODE FROM COMMAND
RSNCODE  DS    F                       REASON CODE
ABNDCODE DS    F                       ABEND CODE
CMDLEN   DS    F
***********************************************************************
*** VARS TO KEEP TRACK OF OUR DATA WERE ARE WORKIN ON NOW            **
***********************************************************************
OURDD    DS    CL8                     PADDED DDNAME
OURDSN   DS    CL44                    PADDED DSN
OURBLK   DS    H                       OUR BLOCKSIZE
OURVOL   DS    CL6                     PADDED VOLUME VARIABLE
*
         DS    0F                      ALIGN FULL WORD
TIOTADDR DS    F                       ADDRESS OF THE TIOT
TIOTELEN DS    F                       LENGTH OF EACH TIOT ENTRY
TIOTDD   DS    F                       ADDRESS OF DDNAME IN TIOT
CMDBUFAD DS    F
***********************************************************************
***                                                                 ***
***  DUMMY DCB AREA AND STUFF RELATED TO RDJFCB PROCESSING          ***
***                                                                 ***
***********************************************************************
DUMBDCB  DCB   DSORG=PS,MACRF=GM,DDNAME=WHALEY,EXLST=DINKS
         DS    0H
RDJFCBP  DS    XL1'13'     NEW FORMAT READ JFCB CODE  X'13' + X'80'EOF
         DS    AL3(000)    ARL CNTL BLOCK PTR. MUST BE BELOW THE LINE
TISCH    DS    F     NEEDED TO KEEP RDJFCB RE-ENTRANT
BCTSAVE  DS    F     SAVE AREA FOR BCT REGISTER
***********************************************************************
***                                                                 ***
***  ARL CONTROL BLOCK USED IN READ JFCB PROCESSING  (FOR SWA ABOVE)***
***                                                                 ***
***********************************************************************
         IHAARL  DSECT=NO,DESCR=YES
***********************************************************************
***                                                                 ***
***  CELL POOL MANAGEMENT VARIABLES                                 ***
***                                                                 ***
***********************************************************************
POOLADR  DS    F                       ADDRESS OF CELL POOL
CELLADR  DS    F                       ADDRESS OF CURRENT CELL
FCELLADR DS    F                       FIRST CELL ADDRESS
*
NEWPOOL  DS    F                       ADDRESS OF NEW DSN CELL POOL
NEWFIRST DS    F                       ADDRESS OF FIRST IN POOL
SAVECUR  DS    F                       ADDRESS OF CURRENT POOL ENTRY
***********************************************************************
***  VARIABLE MESSAGE AREA FOR PUTLINE                              ***
***********************************************************************
D1010A   VARMSG 44                     DSNAME
D1020A   VARMSG 8                      DDNAME
D1040E   VARMSG 3                      POS SUBFIELD
D1050C   VARMSG 6                      VOLUME SUBFIELD
***********************************************************************
***  PARSE WORK AREA                                                ***
***********************************************************************
ANSPL    DS    F                       PARS WORK AREA POINTER
PPL      DS    0F                      LOCAL PROCESSOR PARAMETER LIST
PPLUPT   DS    F                       PTR TO UPT
PPLECT   DS    F                       PTR TO ECT
PPLECB   DS    F                       PTR TO CPECB
PPLPCL   DS    F                       ADDRESS OF CMDEF
PPLANS   DS    F                       ADDRESS OF PARS WORK AREA
PPLCBUF  DS    F                       PTR TO COMMAND BUFFER
PPLUWA   DS    F                       PTR TO USER WORK AREA
***********************************************************************
***  PUTLINE PARAMETER BLOCK                                        ***
***********************************************************************
PARMMSG  PARMMSG                       MSG TEXT DESCRIPTOR
ECBADS   DS      F
IOPLADS  DS      4F
PUTBLOCK PUTLINE MF=L
***********************************************************************
***  CAMLIST WORK AREA                                              ***
***********************************************************************
CAMBUF1  DS    CL265
*
GETVOLD  DS    0D                      FOR CAMLIST LOCATE
GETVO1   DS    X                       INIT TO 68
GETVO2   DS    X
GETVO3   DS    X
GETVO4   DS    X
GETDSNP  DS    A                       ADDRESS OF OURDSN
         DS    A
GETBUF1  DS    A                       ADDRESS OF CAMBUF1
*
SEACAM   DS    0D                      FOR CAMLST SEARCH
SEACAM1  DS    X                       INIT TO 193
SEACAM2  DS    X
SEACAM3  DS    X
SEACAM4  DS    X
SEADSN   DS    A                       INIT TO OURDSN
SEAVOL   DS    A                       INIT TO OURVOL
SEABUF1  DS    A                       INIT TO CAMBUF1
***********************************************************************
***  DSECT DESCRIBING THE NEW DATASET CONTROL BLOCK LIST            ***
***********************************************************************
N_DSECT  DSECT
N_PTR    DS    F            ADDRESS OF NEXT ONE
N_DSN    DS    CL46         DSN
N_YESNO  DS    C            USE THIS ONE 'Y' 'N'
N_BLKSZ  DS    H            BLOCK SIZE
N_LEN    EQU   *-N_DSECT    LENGTH FOR POOL BUILD
***********************************************************************
***  DATA SET TABLE WORK AREA AND DSECT                             ***
***  CPOOL MACRO IS USED TO GET STORAGE FOR THESE CHAINED ENTRIES   ***
***  I BUILD A CHAIN OF ALL DSN'S ALREADY IN THE CONCATENATION      ***
***********************************************************************
D_DSND   DSECT
D_NCELL  DS    F                       NEXT CELL POINTER
D_NDSN   DS    F                       POINTER TO THE NEXT DATASET
D_DSNLN  DS    H                       LENGTH OF DATA SET
D_DSN    DS    CL44                    THE DATA SET NAME
D_VOL    DS    CL8                     THE VOLSER
D_RECFM  DS    CL2                     THE RECORD FORMAT
D_LRECL  DS    F                       THE LRECL
D_BLKS   DS    H                       THE BLOCKSIZE
D_DSORG  DS    CL2                     THE DSORG
D_END    DS    0C
*
D_DSNL   EQU   (D_END-D_DSND)
*
         PRINT   GEN
         IKJCPPL
         IKJTSVT
         CVT DSECT=YES
***********************************************************************
         END
//*
//* VERSION 5.1 CHANGED TO LINK AS AMODE(31)
//*
//L    EXEC  PGM=IEWL,PARM='MAP,LET,LIST,AMODE(31),RMODE(ANY),TEST',
//         REGION=800K,COND=(5,LT,C)
//SYSLIN   DD  DSN=&LOADSET,DISP=(OLD,DELETE)
//SYSLMOD  DD  DSN=SACJI.PGMLIB.LOAD(CONCATDD),DISP=SHR
//SYSUT1   DD  UNIT=SYSDA,SPACE=(CYL,(3,2)),DSN=
//**SLIB   DD DSN=PGMSUP.LOAD,DISP=SHR
//SYSLIB   DD DSN=SYS1.LINKLIB,DISP=SHR
//SYSPRINT DD  SYSOUT=*,DCB=(RECFM=FB,BLKSIZE=3509)
