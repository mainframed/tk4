NETTRACK TITLE ' - NETTRACK SYSTEM - GUIDE ISPF TAPE - STATE OF MONTA'
***********************************************************************
*                                                                     *
*    THIS PROGRAM ESSENTIALLY DOES TWO THINGS: FIRST IT ACTS AS A     *
* PANEL MANAGER, ALLOWING EACH PANEL DISPLAYED TO DETERMINE THE NEXT  *
* PANEL TO BE DISPLAYED; A CHAIN OF ANY NUMBER OF PANELS, IN ANY      *
* ORDER, AND OF ANY LEVEL OF COMPLEXITY CAN BE BUILT. SECOND, IT      *
* SAVES DATA RETURNED FROM THE VARIOUS PANELS, AND AT TERMINATION     *
* WILL WRITE THAT DATA AS A NEW MEMBER OF AN EXISTING PDS.            *
*                                                                     *
*    THIS PROGRAM RUNS UNDER THE DIALOGUE MANAGER FEATURE OF ISPF. IT *
* IS CALLED DIRECTLY BY DIALOGUE MANAGER, AND IMMEDIATELY DISPLAYS    *
* PANEL "NT1STPNL", TO GET THE USER STARTED. EACH PANEL CAN PASS THE  *
* NAME OF THE NEXT PANEL TO BE DISPLAYED, VIA THE VARIABLE NAMED      *
* "NTNXTPNL". IF A PANEL WANTS TO RETURN INFORMATION OF ANY KIND      *
* TO BE SAVED IN THE LOG DATASET BY THIS PROGRAM, THEN IT MUST PASS   *
* THAT DATA VIA ONE OF THE 240 BYTE VARIABLES NAMED "NTDATA00"        *
* THROUGH "NTDATAXX"; AT THE TIME THIS PROGRAM WAS WRITTEN, "XX"      *
* WAS "09" WHICH GIVES A TOTAL OF TEN 240 VARIABLES FOR PASSING       *
* DATA. THESE VARIABLES CAN BE BE USED OVER AND OVER IN ANY           *
* COMBINATION BY ANY PANEL IN THE USER'S CHAIN. SOMETIMES, THE        *
* PANEL DEVELOPER DOES NOT HAVE ENOUGH ROOM TO FURNISH HIS END USER   *
* A BIG ENOUGH FIELD, REGARDLESS OF THE NUMBER OR SIZE OF THE PASSED  *
* VARIABLES AVAILABLE. A TYPICAL EXAMPLE OF THIS WOULD BE A PANEL     *
* SECTION WHERE THE END USER IS ASKED TO TYPE IN A DESCRIPTION OF HIS *
* PROBLEM; THERE IS NO WAY OF KNOWING IN ADVANCE JUST HOW MUCH THE    *
* USER WILL HAVE TO SAY. TO SOLVE THIS, ANYTIME A PANEL RETURNS A     *
* "Y" TO THIS PROGRAM IN VARIABLE "NTCONTIN", A SPECIAL CONTINUATION  *
* PANEL WILL BE DISPLAYED WHICH CONTAINS FOUR 240 BYTE VARIABLES,     *
* WHICH WILL BE RETRIEVED AND BUILT INTO THE LOG. THIS CONTINUATION   *
* PANEL CAN BE INVOKED ANY NUMBER OF TIMES, WHICH EFFECTIVELY GIVES   *
* THE END USER UNLIMITED TYPING ROOM FOR COMMENTS. AFTER THE USER     *
* BREAKS THE CONTINUATION CYCLE, THE NEXT PANEL REQUESTED IS          *
* DISPLAYED.                                                          *
*                                                                     *
*    THE POINT OF THIS SYSTEM IS TO FURNISH THE TELEPROCESSING USER   *
* WITH A STEP BY STEP GUIDE TO DETERMINING A NETWORK PROBLEM, AND     *
* ALSO TO FURNISH NETWORK CONTROL WITH SOME USEFUL COMMENTS SPECIFIC  *
* TO THAT PROBLEM. NETWORK CONTROL, IN TURN, GETS A RECORD OF WHICH   *
* STEPS THE USER WENT THROUGH, AND WHAT HE DID AT EACH STEP. THE USER *
* CAN USE THE SYSTEM HIMSELF, OR NETWORK CONTROL CAN USE IT WHILE     *
* WORKING WITH THE USER OVER THE PHONE. ALTHOUGH THIS PROGRAM IS      *
* MAINTAINED BY TECH, ALL PANEL BUILDING AND MODIFYING CAN BE DONE    *
* BY NETWORK CONTROL, WITH NO HELP FROM TECH, AND NO PROGRAM CHANGES. *
*                                                                     *
*    THIS PROGRAM WILL SAVE ANY DATA TRANSFERRED VIA THE GENERALIZED  *
* 240 BYTE VARIABLES IN A HUGE IN-CORE SAVE AREA. WHEN THE USER       *
* TERMINATES, THIS AREA IS BROKEN UP INTO 80 BYTE RECORDS AND WRITTEN *
* OUT TO A NEW MEMBER OF THE NETWORK PROBLEM LOG PDS. BEFORE DOING    *
* SO, THE PROGRAM READS THE PDS DIRECTORY LOOKING FOR THE HIGHEST     *
* SEQUENTIAL MEMBER NAME OF THE FORM "PRBNNNNN"; IT THEN ADDS 1 TO    *
* THIS AND USES THIS DEVELOPED VALUE AS THE NAME OF THE NEW MEMBER    *
* BEING WRITTEN. SINCE THE USER'S DATA IS STRUNG OUT IN ONE LONG      *
* STRING, SOME MEANS OF BREAKING IT UP FOR READABILITY HAD TO BE      *
* USED. THIS IS DONE BY INSERTING AN EYE-CATCHER WITH THE NAME OF     *
* THE PANEL THAT FURNISHED THE DATA, JUST BEFORE THE DATA ITSELF.     *
* WHEN SCANNING THE IN-CORE DATA AND BREAKING IT INTO 80 BYTE PIECES, *
* ANY PIECE THAT IS TOTALLY BLANK IS DROPPED. IF A BLANK LINE IS      *
* DESIRED, SIMPLY INSERTING ANY NON-BLANK CHARACTER THAT IS NOT TOO   *
* NOTICEABLE ("UNDERSCORE", "OR-BAR", ETC) WILL NULLIFY THE BLANK     *
* TEST, AND CAUSE THE ALMOST-BLANK LINE TO BE INCLUDED FOR PURPOSES   *
* OF SEPARATION OR READABILITY. THIS MUST BE DONE IN THE PANEL,       *
* PRIOR TO RETURNING CONTROL TO THIS PROGRAM.                         *
*    THE REASON FOR THIS TWO PHASE (IN-CORE FOLLOWED BY WRITING       *
* RECORDS LATER) APPROACH IS TO AVOID THE PROBLEM THAT WOULD OCCUR    *
* WHEN TWO END USERS ARE USING THIS SYSTEM SIMULTANEOUSLY - I.E. BOTH *
* WOULD BE TRYING TO ADD NEW MEMBERS TO THE NETWORK LOG DATASET AT    *
* THE SAME TIME, AND BOTH WOULD NEED TO HAVE THE DATASET OPEN FOR A   *
* LONG PERIOD. SINCE THE DATA IS SAVED IN STORAGE FOR THE RELATIVELY  *
* LONG INTERVAL WHEN THEY'RE GOING THROUGH THE SYSTEM, AND THEN IS    *
* COPIED TO THE DATASET BY A HIGH SPEED WRITE LOOP, THE DATASET IS    *
* OPEN AND IN USE FOR A VERY SHORT PERIOD OF TIME. THIS REDUCES THE   *
* CHANCES OF ANY CONFLICT BETWEEN TWO OR MORE SIMULTANEOUS USERS.     *
* HOWEVER, IT COULD STILL HAPEN, SO THIS PROGRAM CALLS A CLIST TO     *
* DYNAMICALLY ALLOCATE THE DATASET, AND IF THE DATASET IS IN USE, THE *
* CLIST SETS THE RETURN CODE HIGH TO ALERT THE PROGRAM, WHICH IN TURN *
* DISPLAYS A SPECIAL PANEL REQUESTING THE USER TO WAIT ONE MINUTE     *
* THEN HIT ENTER/END, AT WHICH TIME THE PROGRAM TRIES THE ALLOCATE    *
* CLIST AGAIN.                                                        *
*    ANOTHER POTENTIAL PROBLEM IS THAT THE NETWORK LOG DATASET CAN    *
* RUN OUT OF ROOM FOR NEW MEMBERS, OR RUN OUT OF DIRECTORY ROOM. THIS *
* HAS BEEN TAKEN CARE OF BY PLACING IT IN THE "TSO" POOL OF DISK      *
* PACKS, SO THAT DMS/OS WILL AUTOMATICALLY COMPRESS AND RE-ALLOCATE   *
* IT AS THE NEED ARISES, JUST LIKE IT DOES FOR TSO LIBRARIES.         *
*                                                                     *
*    NATURALLY, IT IS POSSIBLE FOR A PANEL TO RETURN THE NAME OF A    *
* PANEL THAT DOESN'T EXIST, OR ONE THAT HAS VARIOUS ERRORS IN IT,     *
* IN "NTNXTPNL". IF SO, THIS PROGRAM WILL DISPLAY A SPECIAL "ERROR    *
* PANEL PANEL", WHICH ALLOWS THE DEVELOPER TO TYPE IN A SUBSTITUTE    *
* PANEL NAME, AND TEST FARTHER DOWN HIS CHAIN. THIS SPECIAL PANEL     *
* ALSO ATTEMPTS TO IDENTIFY THE CAUSE OF THE ERROR FOR HIM. NATURALLY,*
* THIS SHOULD ONLY HAPPEN DURING DEVELOPMENT; THE END USER SHOULD     *
* NEVER SEE THE ERROR PANEL PANEL.                                    *
*                                                                     *
*    ANY TIME THE DEVELOPER WISHES TO TERMINATE THE DIALOGUE,         *
* RETURNING THE WORD "EXIT" IN THE VARIABLE "NTNXTPNL" WILL CAUSE     *
* THIS PROGRAM TO PERFORM FINAL HOUSEKEEPING AND END. JUST BEFORE     *
* TERMINATING, THE PROGRAM DISPLAYS ONE LAST SPECIAL PANEL TO         *
* INFORM THE USER OF THE PROBLEM NUMBER THAT WAS ASSIGNED TO HIM.     *
*                                                                     *
*    THE ONLY UNUSUAL THINGS ABOUT THIS DIALOGUE ARE THAT IT OBTAINS  *
* THE NAME OF THE NEXT PANEL TO BE DISPLAYED FROM THE LAST PANEL,     *
* AND THAT ONLY TWO SPECIFIC AND TEN (AT THE MOMENT, SEE ABOVE)       *
* GENERALIZED VARIABLES ARE RETRIEVED BY THIS PROGRAM. (THE DEVELOPER *
* CAN HAVE ANY NUMBER OF LOCAL VARIABLES WITHIN A PANEL, OR SHARED    *
* VARIABLES THAT CAN BE PASSED BETWEEN HIS VARIOUS PANELS, BUT THESE  *
* MUST BE TRANSFERRED OR CONCATENATED INTO ONE OF THE GENERAL PURPOSE *
* VARIABLES IF THE PANEL DEVELOPER WANTS THAT PARTICULAR INFORMATION  *
* ENTERED INTO THE LOG DATASET.                                       *
* THE REASON FOR THIS IS TO ALLOW FREQUENT AND HEAVY MODIFICATION     *
* TO THE PANEL CHAIN WITHOUT MODIFYING/REASSEMBLING THIS PROGRAM.     *
* IT GIVES THE DEVELOPER A LOT OF FREEDOM IN MODIFYING HIS PANEL      *
* CHAINS WITHOUT REQUIRING PROGRAM CHANGES AND TESTING.               *
*                                                                     *
*                                                                     *
*               - DENNIS BUSWELL, 02/05/85                            *
*                                                                     *
***********************************************************************
         EJECT
***********************************************************************
*                                                                     *
*                                                                     *
*                     INITIALIZATION                                  *
*                                                                     *
*                                                                     *
***********************************************************************
         SPACE 2
NETTRACK PROC LINKAGE=(OS,CSECT),ID='NETTRACK V 1.0',BASE=(11,12)
         SPACE 2
         ST    R1,PARMADDR         * SAVE A(EXEC PARM)
         SPACE 2
***********************************************************************
* MAKE INITIAL CALLS TO "ISPLINK" TO SET CONDITIONS WE WANT TO RUN    *
* UNDER - RETURN TO US IF RET CODE > 12                               *
***********************************************************************
         SPACE 2
         CALL  ISPLINK,(CONTROL1,ERRORS,RETURN),VL
         SPACE 3
***********************************************************************
* CHECK FOR EXEC PARM TO ALLOW SCREEN SPLITTING (DEVELOPMENT ONLY)    *
* FOR PRODUCTION USE, WE MUST RUN WITH SCREEN SPLIT DISABLED          *
***********************************************************************
         SPACE 2
         L     R1,PARMADDR         * PICK UP A(A(EXEC PARM))
         L     R1,0(R1)            * GET A(EXEC PARM)
         CLC   2(5,R1),=C'SPLIT'   * USER TESTING/DEVELOPING ?
         BE    SPLITOK             * - YES, LEAVE SPLIT SCREEN AS IS
         SPACE 1
         CALL  ISPLINK,(CONTROL1,SPLIT,DISABLE),VL *-NO, DISABLE SPLIT
         LTR   R15,R15             * SCREEN ALREADY SPLIT ?
         BZ    NOTSPLIT            * - NO, EVERYTHING IS OK
         SPACE 1
         MVC   NTERRPNL(8),=C'NTNOSPLT' * SET UP ERROR MESSAGE
         CALL  ISPLINK,(DISPLAY,NTERRPNL),VL * DISPLAY ERROR PANEL
         B     TERME                  *    & GO FINISH UP
         SPACE 1
SPLITOK  EQU   *
NOTSPLIT EQU   *
         SPACE 3
***********************************************************************
* ISSUE GETMAIN TO SEE IF USER LOGGED ON WITH BIG ENOUGH REGION TO    *
* ALLOW US A 512K GETMAIN; IF NOT, DISPLAY A SPECIAL PANEL AND MAKE   *
* HIM LOGON AGAIN WITH A LARGER REGION SIZE.                          *
***********************************************************************
         SPACE 3
         GETMAIN EC,LV=524288,A=STRGADDR,SP=2 * ASK FOR 512 K
         SPACE 1
         LTR   R15,R15             * DID WE GET 512K OK ?
         BZ    GOTMAIN             * - YES, WE'RE IN BUSINESS
         SPACE 1
         MVC   NTERRPNL(8),=C'NTMORSTG' * FORCE IN NAME OF "RE-LOGON
*                                  * WITH-MORE-STORAGE" PANEL
         CALL  ISPLINK,(DISPLAY,NTERRPNL),VL * - NO, TOUGH LUCK
         B     TERME               * NOW GO QUIT
GOTMAIN  EQU   *
         L     R1,STRGADDR         * PICK UP A(STORAGE WE GOT)
         ST    R1,NEXTNTRY         * PRIME A(NEXT ENTRY TO USE)
         A     R1,=F'524128'       * ADD 512K MINUS 160 BYTES
         ST    R1,LASTNTRY         * SAVE THIS AS LAST POSSIBLE ENTRY
         SPACE 3
***********************************************************************
* NOW DO VDEFINES TO INITIALIZE AND SET LENGTHS OF ALL VARIABLES WE   *
* WILL BE USING LATER ON                                              *
***********************************************************************
         SPACE 2
*                                    ***** 1ST DEFINE ALL OF THE 240
*                                        * BYTE VARIABLES AT 1 CRACK
         SPACE 1
         MVI   LFTPAREN,C'('             * TEMPORARILY MAKE NAMELIST
*                                        *    ONE LARGE LIST
         MVI   RTPAREN,C')'              *
         SPACE 1
         CALL  ISPLINK,(VDEFINE,NAMELST1,GENVARS,CHAR,L240),VL
         SPACE 1
         MVI   LFTPAREN,C' '             * RESET TO INDIVIDUAL ITEMS
*                                        *
         MVI   RTPAREN,C' '              *
         SPACE 2
*                                    ***** NEXT DEFINE "NTCONTIN"
         SPACE 1
         CALL  ISPLINK,(VDEFINE,NMCONTIN,NTCONTIN,CHAR,L1),VL
         SPACE 1
         SPACE 2
*                                    ***** THEN DEFINE "NTCONTIN"
         SPACE 1
         CALL  ISPLINK,(VDEFINE,VDEF8LST,VDEF8VAL,CHAR,L8),VL
         SPACE 1
***********************************************************************
* NOW "VPUT" ALL OF THE VARIABLES WE JUST DEFINED, WHICH WILL COPY   *
* THEM FROM THIS PROGRAM'S FUNCTION POOL TO THE SHARED POOL.         *
***********************************************************************
         SPACE 2
         MVC   VPUTLIST(075),=C'(NTCONTIN NTNXTPNL NTBADPNL NTERRPNL NTX
               PROB# NTDATA00 NTDATA01 NTDATA02)      '
         SPACE 1
         CALL  ISPLINK,(VPUT,VPUTLIST,SHARED),VL * PUT VARIABLES IN
*                                   * SHARED POOL SO ERROR PANEL CAN
*                                   * USE IT
         MVC   VPUTLIST(075),=C'(NTDATA03 NTDATA04 NTDATA05 NTDATA06 NTX
               DATA07 NTDATA08 NTDATA09)              '
         SPACE 1
         CALL  ISPLINK,(VPUT,VPUTLIST,SHARED),VL * PUT VARIABLES IN
*                                   * SHARED POOL SO ERROR PANEL CAN
*                                   * USE IT
         EJECT
***********************************************************************
*                                                                     *
*                                                                     *
*                        MAINLINE                                     *
*                                                                     *
*                                                                     *
***********************************************************************
         SPACE 3
***********************************************************************
* DISPLAY PANEL "NT1STPNL" TO GET THINGS STARTED; THIS AND ONLY THIS  *
* PANEL NAME IS FROZEN IN THE DEVELOPER'S NORMAL PANEL CHAIN; PANELS  *
* BEYOND THIS CAN BE NAMED WHATEVER THE DEVELOPER WANTS. TRUE, THERE  *
* ARE SEVERAL "SPECIAL SITUATION PANELS" WHOSE NAMES ARE LIKEWISE     *
* HARD CODED IN THIS PROGRAM, AND WHOSE NAMES HAVE TO REMAIN AS IS    *
* BUT THESE PANELS MUST BE PRESENT REGARDLESS OF THE SIZE OR DESIGN   *
* OF THE DEVELOPER'S PANEL CHAIN, AND DON'T REALLY EFFECT HIM.        *
***********************************************************************
         SPACE 1
         MVC   PANLNAME(8),=C'NT1STPNL' * FORCE IN FIRST PANEL NAME
         B     FRSTPANL             * NOW BRANCH DIRECTLY TO CALL
         SPACE 4
***********************************************************************
* DISPLAY NEW PANEL REQUESTED BY LAST PANEL DISPLAYED.                *
***********************************************************************
         SPACE 1
NEXTPANL MVC   PANLNAME(8),NTNXTPNL * FORCE IN CORRECT PANEL NAME
FRSTPANL EQU   *
         CLC   PANLNAME(8),=C'$NONAME$' * USER FORGET TO SET
*                                   * "NTNXTPNL" ?
         BE    NOPNLNAM             * - YES, GO HANDLE
         SPACE 1
         CALL  ISPLINK,(DISPLAY,PANLNAME),VL * DISPLAY PANEL
         SPACE 4
***********************************************************************
* IF PANEL DISPLAYED WAS BAD FOR ANY REASON, NOTIFY DEVELOPER VIA     *
* A SPECIAL "ERROR-PANEL PANEL" AND LET HIM TYPE IN ANOTHER PANEL     *
* NAME AND KEEP GOING. THIS IS FOR PANEL DEVELOPMENT PURPOSES ONLY -  *
* THE END USER SHOULD NEVER GET IN THIS POSITION.                     *
***********************************************************************
         SPACE 1
         CH    R15,=H'8'            * PANEL DISPLAY OK ?
         BNH   PANELSOK             * - YES, GO HANDLE
         SPACE 1
         SPACE 1
         CH    R15,=H'12'           * PANEL NOT FOUND ?
         BNE   NOT12                * - NO, GO HANDLE
         MVI   MSGNAME+7,C'1'       * - YES, SET APPROPRIATE MESSAGE
         B     ERRORRDY             *    & GO DISPLAY ERROR PANEL
         SPACE 1
NOT12    EQU   *
         CH    R15,=H'16'           * VARIABLE TRUNCATION ?
         BNE   NOT16                * - NO, GO HANDLE
         MVI   MSGNAME+7,C'2'       * - YES, SET APPROPRIATE MESSAGE
         B     ERRORRDY             *    & GO DISPLAY ERROR PANEL
         SPACE 1
NOT16    EQU   *
         MVI   MSGNAME+7,C'3'       * - YES, SET APPROPRIATE MESSAGE
         B     ERRORRDY             *    & GO DISPLAY ERROR PANEL
         SPACE 2
NOPNLNAM EQU   *
         MVI   MSGNAME+7,C'7'       * - YES, SET APPROPRIATE MESSAGE
         SPACE 2
ERRORRDY EQU   *
         MVC   NTBADPNL,PANLNAME    * SAVE NAME OF LAST PANEL
         CALL  ISPLINK,(VREPLACE,VREPNAMS,REPLNTHS,REPDATA),VL
         SPACE 2
         MVC   VPUTLIST,=C'(NTBADPNL) ' *
         CALL  ISPLINK,(VPUT,VPUTLIST,SHARED),VL * PUT VARIABLES IN
*                                   * SHARED POOL SO ERROR PANEL CAN
*                                   * USE IT
         SPACE 1
         CALL  ISPLINK,(DISPLAY,NTERRPNL,MSGNAME),VL * ERROR PANEL
*                                   * WHAT USER WANTS US TO DO
         SPACE 4
***********************************************************************
* NOW ISSUE VGET AND VCOPY TO GET USER'S DATA                         *
***********************************************************************
         SPACE 2
PANELSOK EQU   *                    *
         MVC   L8(4),=F'8'          * RESET ALL OUR LENGTH
         MVC   L240(4),=F'240'      *    INDICATORS
         MVC   L1(4),=F'1'          *
         SPACE 2
         MVC   VGETNAME(44),=C'NTNXTPNL NTCONTIN NTDATA00 NTDATA01 NTDAX
               02) '
         CALL  ISPLINK,(VGET,VGETLIST,SHARED),VL * PUT IN SHARED POOL
         SPACE 2
         MVC   VGETNAME(64),=C'NTDATA03 NTDATA04 NTDATA05 NTDATA06 NTDAX
               TA07 NTDATA08 NTDATA09) '
         CALL  ISPLINK,(VGET,VGETLIST,SHARED),VL * PUT IN SHARED POOL
         SPACE 2
         MVC   VGETNAME(80),=CL255' ' * NOW CLEAR OUT NAME AREA
         SPACE 3
*                               ***** ===> NOTE <=== DO NOT TRY TO
*                                   * COMBINE THE MULTIPLE VCOPIES
*                                   * BELOW INTO ONE LARGE CALL FOR
*                                   * EFFICIENCY'S SAKE; IF YOU DO
*                                   * AND ONE VCOPY HAS AN ERROR DUE
*                                   * TO LENGTH TRUNCATION, THE FOLLOW-
*                                   * ING VCOPIES WILL BE BYPASSED, AND
*                                   * THEIR DATA LOST
         SPACE 1
         MVC   L8(4),=F'8'          * RESET LENGTH AGAIN
         CALL  ISPLINK,(VCOPY,NMNXTPNL,L8,NTNXTPNL,MOVE),VL
         SPACE 2
         MVC   L1(4),=F'1'          *
         CALL  ISPLINK,(VCOPY,NMCONTIN,L1,NTCONTIN,MOVE),VL
         SPACE 2
         MVC   L240(4),=F'240'      * RESET LENGTH
         CALL  ISPLINK,(VCOPY,NMDATA00,L240,NTDATA00,MOVE),VL
         SPACE 2
         MVC   L240(4),=F'240'      * RESET LENGTH
         CALL  ISPLINK,(VCOPY,NMDATA01,L240,NTDATA01,MOVE),VL
         SPACE 2
         MVC   L240(4),=F'240'      * RESET LENGTH
         CALL  ISPLINK,(VCOPY,NMDATA02,L240,NTDATA02,MOVE),VL
         SPACE 2
         MVC   L240(4),=F'240'      * RESET LENGTH
         CALL  ISPLINK,(VCOPY,NMDATA03,L240,NTDATA03,MOVE),VL
         SPACE 2
         MVC   L240(4),=F'240'      * RESET LENGTH
         CALL  ISPLINK,(VCOPY,NMDATA04,L240,NTDATA04,MOVE),VL
         SPACE 2
         MVC   L240(4),=F'240'      * RESET LENGTH
         CALL  ISPLINK,(VCOPY,NMDATA05,L240,NTDATA05,MOVE),VL
         SPACE 2
         MVC   L240(4),=F'240'      * RESET LENGTH
         CALL  ISPLINK,(VCOPY,NMDATA06,L240,NTDATA06,MOVE),VL
         SPACE 2
         MVC   L240(4),=F'240'      * RESET LENGTH
         CALL  ISPLINK,(VCOPY,NMDATA07,L240,NTDATA07,MOVE),VL
         SPACE 2
         MVC   L240(4),=F'240'      * RESET LENGTH
         CALL  ISPLINK,(VCOPY,NMDATA08,L240,NTDATA08,MOVE),VL
         SPACE 2
         MVC   L240(4),=F'240'      * RESET LENGTH
         CALL  ISPLINK,(VCOPY,NMDATA09,L240,NTDATA09,MOVE),VL
         SPACE 4
*                               ***** NOW LET'S VREPLACE THE VALUE
*                                   * OF "NTNXTPNL" WITH A VALUE
*                                   * OF "$NONAME$" SO WE CAN CATCH
*                                   * THE SITUATION WHERE USER FORGETS
*                                   * TO SET OR VPUT "NTNXTPNL"
         CLI   NTCONTIN,C'Y'        * USER IN CONTINUATION MODE ?
         BE    NOREPYET             * - YES, SKIP VREPLACE FOR NOW
         SPACE 1
         CALL  ISPLINK,(VREPLACE,VRNMNPAN,REPLNTHS,VRNONAME),VL
         SPACE 2
         MVC   VPUTLIST,=C'(NTNXTPNL) ' *
         CALL  ISPLINK,(VPUT,VPUTLIST,SHARED),VL * VPUT "NO-NAME"
         SPACE 1
NOREPYET EQU   *
         SPACE 2
***********************************************************************
* BUILD HIS INFO INTO OUR IN-CORE TABLE                               *
***********************************************************************
         SPACE 2
BUILDNFO EQU   *
         L     R1,NEXTNTRY          * PICK UP A(NEXT TABLE ENTRY)
         CLC   PANLNAME(8),=C'NTEXTEND' * COMMENT EXTENSION PANEL ?
         BE    SKIPNAME             * - YES, FORGET PANEL NAME FLAG
         MVC   0(80,R1),=CL240' '   * CLEAR OUT TRASH
         MVC   0(10,R1),=C'PANEL ===>' * FORCE IN LEGEND
         MVC   11(8,R1),PANLNAME    * PUT IN NEXT PANEL CHOICE
         LA    R1,80(R1)            * POINT TO NEXT SPOT
         C     R1,LASTNTRY          * GOING TO OVERRUN IN-CORE TABLE?
         BNL   NOMOROOM             * - YES, NO OTHER CHOICE
         SPACE 1
SKIPNAME EQU   *
         LA    R15,NTDATA00         * POINT TO USER'S DATA
         LA    R14,30               * INIT BCT REG
         SPACE 1
NEXTSECT EQU   *                    *
         CLC   0(80,15),=CL255' '   * BLANK LINE ?
         BE    ITSBLANK             * - YES, DON'T MOVE IT IN
         MVC   0(80,R1),0(R15)      * MOVE IN THIS SECTION
         MVC   0(80,R15),=CL255' '  * BLANK OUT SENDING FIELD
         LA    R1,80(R1)            * BUMP UP
         C     R1,LASTNTRY          * GOING TO OVERRUN IN-CORE TABLE?
         BNL   NOMOROOM             * - YES, NO OTHER CHOICE
ITSBLANK LA    R15,80(R15)          *    POINTERS
         BCT   R14,NEXTSECT         * DO ALL OF THEM
         SPACE 2
         CLC   NTNXTPNL,=C'EXIT    ' * USER QUITTING ?
         BNE   SAVENTRY
         CLI   NTCONTIN,C'Y'         * - YES, BUT ARE WE CONTINUING ?
         BE    SAVENTRY              * - YES, SKIP FINAL FLAG FOR NOW
         MVC   0(80,R1),=CL255' '    * CLEAR EXTRA SPOT
         MVC   80(80,R1),=CL80'===> USER QUIT AT THIS POINT <==='
         LA    R1,160(R1)           * BUMP POINTER UP
         C     R1,LASTNTRY          * GOING TO OVERRUN IN-CORE TABLE?
         BNL   NOMOROOM             * - YES, NO OTHER CHOICE
         SPACE 1
SAVENTRY ST    R1,NEXTNTRY          * SAVE A(NEXT ENTRY)
         SPACE 2
***********************************************************************
* NOW PICK UP USER'S CHOICE FOR NEXT PANEL AND DISPLAY IT             *
***********************************************************************
         SPACE 2
         CLI   NTCONTIN,C'Y'          * USER WANT "ADDITIONAL DATA
*                                     *   SCREEN"
         BNE   TESTEXIT               * - NO, GO SEE IF ALL DONE
         MVC   PANLNAME(8),=C'NTEXTEND' * - NO, HE HAS MORE TO SAY
         B     FRSTPANL               * GO DO IT
         SPACE 1
TESTEXIT EQU   *
         CLC   NTNXTPNL(4),=C'EXIT'   * USER WANT COMPLETELY OUT ?
         BE    ALLDONE                * - YES, GO CLEAN UP AND END
         B     NEXTPANL               * - NO, KEEP GOING
         SPACE 5
***********************************************************************
*    WE RAN OUT OF IN-CORE STORAGE ROOM; DISPLAY SPECIAL WARNING      *
* SCREEN FOR USER, THEN GO SAVE WHAT WE CAN AND FINISH UP.            *
***********************************************************************
         SPACE 2
NOMOROOM EQU   *
         MVC   NTERRPNL(8),=C'NTNOROOM' * SET UP ERROR MESSAGE
         CALL  ISPLINK,(DISPLAY,NTERRPNL),VL * ERROR PANEL
         B     ALLDONE                *    & GO FINISH UP
         EJECT
         SPACE 3
***********************************************************************
*                                                                     *
*                                                                     *
*                         TERMINATION                                 *
*                                                                     *
*                                                                     *
*                                                                     *
***********************************************************************
         SPACE 2
ALLDONE  EQU   *
         SPACE 4
***********************************************************************
* 1ST CALL CLIST "NTRKCLST" TO ALLOCATE NETWORK TRACKING LOG FILE     *
***********************************************************************
         SPACE 1
ALLOCATE EQU   *
         MVC   CMDBUF(23),=C'CMD(%NTRKCLST ALLOCATE) '
         CALL  ISPLINK,(SELECT,CMDBUFLN,CMDBUF),VL * CALL CLIST TO
         SPACE 2
         LTR   R15,R15            * ALLOCATE GO OK ?
         BZ    OPENUP             * - YES, GO OPEN
         MVC   PANLNAME(8),=C'NTALFAIL' * PUT IN NAME OF WAIT PANEL
         CALL  ISPLINK,(DISPLAY,PANLNAME),VL * GET USER TO WAIT 1 MIN
         B     ALLOCATE           * NOW GO TRY AGAIN
         SPACE 2
***********************************************************************
* THEN OPEN "NETRKDIR" AND READ IN THE ENTIRE DIRECTORY OF OUR LOG    *
* DATASET, AND FIND THE HIGHEST PROBLEM NUMBER THAT WAS ASSIGNED      *
* LAST; ASSIGN NEXT NUMBER IN SEQUENCE TO THIS PROBLEM                *
***********************************************************************
         SPACE 1
OPENUP   EQU   *                   *
         OPEN  (NETRKDIR,INPUT)    * OPEN DIRECTORY DCB
         SPACE 3
GETDRBLK GET   NETRKDIR
         LA    R2,2(R1)            * POINT TO 1ST ENTRY IN BLOCK
         LA    R3,6                * MAX # SPF ENTRIES PER BLOCK
         SPACE 1
CHECKENT CLC   0(8,R2),=8XL1'FF'   * END-OF-ENTRIES FLAG
         BE    EODDIRCT            * - YES, ALL DONE
         CLC   0(42,R2),=42XL1'00' * EMPTY ENTRY ?
         BE    EODDIRCT            * - YES, ALL DONE
*                              ***** FOLLOWING MAKES SURE THAT MEMBER
*                                  * NAME IS OF THE FORM "PROBNNNN" -
*                                  * BEFORE WE USE IT; LIBRARY MAY
*                                  * CONTAIN MEMBERS THAT DON'T FOLLOW
*                                  * THE PATTERN.
         LA    R1,3(R2)            * POINT TO LAST 5 BYTES OF MEMB NAME
         LA    R15,5               * INIT BCT REG
         SPACE 1
TESTNUM  TM    0(R1),X'F0'         * NUMERIC DIGIT ?
         BNO   TRYNEXT             * - NO, DROP THIS ONE
         LA    R1,1(R1)            * - YES, POINT TO NEXT BYTE
         BCT   R15,TESTNUM         *    & KEEP TRYING
         SPACE 1
         CLC   0(3,R2),=C'PRB'     * THIS NAME HAVE RIGHT PREFIX ?
         BNE   TRYNEXT             * - NO, FORGET IT
         SPACE 1
         MVC   STOWNAME(8),0(R2)   * -YES, SAVE THIS NAME AS HIGHEST
         SPACE 1
TRYNEXT  EQU   *
         LA    R2,42(R2)           * POINT TO NEXT ENTRY
         BCT   R3,CHECKENT         *   & KEEP TRYING
         B     GETDRBLK            * GET NEXT DIRECTORY BLOCK
         SPACE 1
EODDIRCT EQU   *
         PACK  DOUB(8),STOWNAME+3(5) * PACK C'NNNN' SECTION OF
*                                    * LAST (HIGHEST) NAME IN DIRECT
         AP    DOUB,=P'1'            * UP IT BY ONE
         UNPK  STOWNAME+5(3),DOUB+5(3) * NOW UNPK IT
         OI    STOWNAME+7,X'F0'      * CORRECT SIGN
         SPACE 2
***********************************************************************
* NEXT, CLOSE QSAM DIRECTORY INPUT DCB AND THEN USING THE SAME        *
* DDNAME, OPEN THE BPAM DCB SO WE CAN WRITE OUT RECORDS WE'VE SAVED.  *
***********************************************************************
         SPACE 1
         CLOSE NETRKDIR              * CLOSE INPUT (EXCP)
         SPACE 2
         OPEN  (NETRKOUT,OUTPUT)     * OPEN OUTPUT (BPAM)
         SPACE 2
         MVC   OUTLRECL(2),NETRKOUT+82 * SAVE LRECL AND BLKSIZE
         MVC   OUTBLKSZ(2),NETRKOUT+62 *   FOR WRITE SUBROUTINE
         SPACE 2
***********************************************************************
* NOW LOOP THROUGH IN-CORE DATA AND WRITE IT OUT TO THE LOG DATASET.  *
***********************************************************************
         SPACE 1
         LA    R1,=CL255' '        * POINT TO BLANK LINE
         BAL   R9,WRITEREC         *    & GO WRITE A SPACER  LINE
         SPACE 1
         BAL   R9,BLDDTTIM         * GO BUILD FANCY DATE/TIME REC
         SPACE 1
         LA    R1,DATEREC          * POINT TO FANCY DATE/TIME REC
         BAL   R9,WRITEREC         *    & GO WRITE IT OUT
         SPACE 1
         LA    R1,=CL255' '        * POINT TO BLANK LINE
         BAL   R9,WRITEREC         *    & GO WRITE A SPACER  LINE
         SPACE 3
         L     R2,STRGADDR         * GET A(AREA WHERE WE SAVED INFO)
         SPACE 1
NEXTLOG  EQU   *
         CLC   0(10,R2),=C'PANEL ===>' * NEW PANEL LEGEND PRESENT ?
         BNE   SAMEPANL            * - NO, KEEP WRITING THIS GROUP
         CLC   0(19,R2),=C'PANEL ===> NTEXTEND' * COMMENT EXTENSION ?
         BE    SAMEPANL                * - YES, SKIP SEPARATOR
         LA    R1,=CL255' '        * POINT TO BLANK LINE
         BAL   R9,WRITEREC         *    & GO WRITE A
         LA    R1,=CL255' '        *       COUPLE OF
         BAL   R9,WRITEREC         *          THEM
         LA    R1,SEPLINE          * POINT TO SEPARATOR LINE
         BAL   R9,WRITEREC         *    & GO WRITE IT OUT
         SPACE 1
SAMEPANL EQU   *
         LA    R1,0(R2)            * POINT TO CURRENT DATA REC
         BAL   R9,WRITEREC         *    & GO WRITE IT OUT
         CLC   0(19,R2),=C'PANEL ===> NTEXTEND' * COMMENT EXTENSION ?
         BE    NOSPACER                * - YES, SKIP SEPARATOR
         CLC   0(10,R2),=C'PANEL ===>' * NEW PANEL LEGEND PRESENT ?
         BNE   NOSPACER            * - YES,
         LA    R1,SEPLINE          * POINT TO SEPARATOR LINE
         BAL   R9,WRITEREC         *    & GO WRITE IT OUT
NOSPACER EQU   *
         LA    R2,80(R2)           * POINT TO NEXT REC
         C     R2,NEXTNTRY         * HIT END OF TABLE ?
         BL    NEXTLOG             * - NO, KEEP GOING
         SPACE 1
         SR    R1,R1               * INDICATE "LAST TIME THROUGH"
         BAL   R9,WRITEREC         *    & GO LET SUBROUTINE WRITE
*                                  *       OUT ANY REMAINING SHORT BLK
         SPACE 4
***********************************************************************
* FOLLOWING LOGIC FAKES IN THE SPF STATISTICS FIELD FOR THE NEW       *
* MEMBER, AND THEN ISSUES A "STOW" MACRO TO ADD IT TO THE PDS.        *
***********************************************************************
         SPACE 2
***********************************************************************
* PUT USER'S ID INTO THE SPF DIRECTORY EXTENSION FIELD FOR IT.        *
***********************************************************************
         SPACE 1
         MVC   VGETNAME(8),=C'ZUSER   ' * INDICATE VARIABLE NAME NEEDED
         CALL  ISPLINK,(VGET,VGETLIST,SHARED),VL * PUT IN SHARED POOL
         SPACE 2
         MVC   L8(4),=F'8'         * RESET LENGTH 8 FIELD
         SPACE 2
         CALL  ISPLINK,(VCOPY,NMUSERID,L8,STUSERID,MOVE),VL
*                                  * NOW COPY IT INTO OUR STORAGE,
*                                  * IN THE SPF DIRECTORY EXTENSION
*                                  * EXTENSION FIELD FOR USERID
         SPACE 2
***********************************************************************
* ISSUE TIME MACRO AND BUILD IN SPF STATISTICS SECTION IN THE         *
* DIRECTORY EXTENSION.                                                *
***********************************************************************
         SPACE 1
         TIME  DEC                 * RESULT= P'HHMMSSTH' - NO PKD SIGN
         ST    R1,STCRDAT          * BUILD SPF CREATE DATE
         ST    R1,STMODDAT         * MAKE SPF LAST MODIFIED THE SAME
         SRL   R0,16               * GET RID OF SECONDS & HUNDRETHS
         STH   R0,STMODTIM         * PUT IN SPF LAST MOD TIME FIELD
         SPACE 1
***********************************************************************
* ISSUE STOW MACRO TO FORCE NAME OF NEW PROBLEM/MEMBER INTO THE       *
* NETWORK PROBLEM LOG DIRECTORY.                                      *
***********************************************************************
         STOW  NETRKOUT,STOWLIST,A
         LTR   R2,R15              * STOW WORK OK?
         BNZ   ABEND2              * - NO, GO ABEND
         SPACE 2
         CLOSE NETRKOUT              * CLOSE UP OUTPUT
         SPACE 2
***********************************************************************
* LAST CALL CLIST "NTRKCLST" TO FREE NETWORK TRACKING LOG FILE        *
***********************************************************************
         SPACE 1
         MVC  CMDBUF(23),=C'CMD(%NTRKCLST FREE)     '
         CALL ISPLINK,(SELECT,CMDBUFLN,CMDBUF),VL * CALL CLIST TO
         SPACE 2
***********************************************************************
* DISPLAY FINAL PANEL TO GIVE USER PROBLEM NUMBER ASSIGNED            *
***********************************************************************
         SPACE 1
         MVC   VREPNAMS(10),=C'(NTPROB#) ' * FORCE IN VARIABLE NAME
         SPACE 1
         CALL  ISPLINK,(VREPLACE,VREPNAMS,REPLNTHS,STOWNAME),VL
         SPACE 2
         MVC   VPUTLIST,=C'(NTPROB#) ' *
         SPACE 1
         CALL  ISPLINK,(VPUT,VPUTLIST,SHARED),VL * "VPUT" PROBLEM
*                                   * NUMBER VARIABLE
         SPACE 1
         MVC   PANLNAME(8),=C'NTPR#PNL' * PUT IN PROB# PANEL NAME
         CALL  ISPLINK,(DISPLAY,PANLNAME),VL * DISPLAY PANEL TO SEE
         SPACE 3
FREEMAIN EQU   *
         CLC   STRGADDR(4),=F'0'    * WE GET ANY STORAGE EARLIER ?
         BE    NOGOT                * - NO, FORGET FREEMAIN
         SPACE 1
         FREEMAIN E,LV=524288,A=STRGADDR,SP=2 * FREE ANY STG WE GOT
         SPACE 1
NOGOT    EQU   *
TERME    EQU   *
         SPACE 1
         CALL  ISPLINK,(CONTROL1,SPLIT,ENABLE),VL * RE-ENABLE SPLIT
         SPACE 1
         CORP  RC=(15)
         EJECT
***********************************************************************
*                                                                     *
*                                                                     *
*                    INTERNAL SUBROUTINES                             *
*                                                                     *
*                                                                     *
***********************************************************************
         SPACE 2
BLDDTTIM EQU   *              ****** THIS SUBROUTINE BUILDS THE DATE
*                                  * AND TIME OF THE RUN INTO A
*                                  * FANCY DATE/TIME HEADING RECORD
*                                  * FOR LATER USE
         SPACE 1
         STM   R8,R9,BLDTSAVE      * SAVE REGS WE'LL ALTER
         SPACE 1
*                        ********** FOLLOWING LOGIC BUILDS IPL DATE IN
*                                 *    OUR PRINT HEADING
         XC    DATEPARM(15),DATEPARM * INDICATE IPL DATE DESIRED
         L     R15,=V(DATECNVT)   * GET ADDR OF DATE CONVERT/RETRIEVAL
         LA    R1,DATEPARM        *     SUBROUTINE & PNT TO PARM LIST
         BALR  R14,R15            * GO GET TODAY'S DATE
         LTR   R15,R15            * WORK OK ?
         BNZ   BLDDRETN           * - NO, FORGET IT
         SPACE 1
         MVC   DAY(9),DAYNAME     * MOVE NAME OF DAY OF WEEK TO HEAD
         SR    R1,R1              * CLEAR WORK REG
         IC    R1,DAYLNTH         * GET LENGTH OF LAST FIELD
         LA    R15,DAY(R1)        * POINT TO 1ST BYTE PAST THAT
         MVI   0(R15),C','        * MOVE IN PUNCTUATION
         MVC   2(9,R15),MNTHNAME  * NOW MOVE IN NAME OF MONTH
         IC    R1,MNTHLNTH        * GET IT'S LENGTH
         LA    R15,3(R15,R1)      * POINT TO 1ST BYTE PAST RESULT
         CLI   PRNTCAL+3,C'0'     * IS THERE ONLY ONE SIGNIFICANT
*                                 *    DIGIT IN DAY OF MONTH ?
         BE    SHORTDAY           * - YES, GO HANDLE SEPARATELY
         MVC   0(2,R15),PRNTCAL+3 * - NO, MOVE IN BOTH DIGITS
         LA    R15,2(R15)         *    & POINT TO NEXT FREE SPOT
         B     RESTDATE           * NOW GO FINISH UP
SHORTDAY MVC   0(1,R15),PRNTCAL+4 * MOVE IN ONLY SIGNIFICANT DIGIT
         LA    R15,1(R15)         * POINT AROUND IT,
RESTDATE MVI   0(R15),C','        * MOVE IN PUNCTUATION
         MVC   2(2,R15),=C'19'    * FORCE IN CENTURY
         MVC   4(2,R15),PRNTCAL+6 *    & THEN PUT IN YEAR
         LA    R8,7(R15)          * SAVE A(NEXT AVAIL SPOT)
         SPACE 3
*                        ********** FOLLOWING BUILDS TIME OF DAY IN
*                                 * PRINT HEADING
         TIME
         SRL   R0,12              * GET RID OF SECONDS & HUNDRETHS,
*                                 *   BUT LEAVE ROOM FOR PACKED SIGN
         ST    R0,DOUB+4          * PUT IN CORE,
         OI    DOUB+7,X'0F'       * FORCE IN PACKED DECIMAL SIGN
         SRL   R0,12              * GET RID OF EVERYTHING IN R0
*                                 *   EXCEPT THE HOURS
         CH    R0,=X'0012'        * IS THIS 12 NOON ?
         BE    PM12               * - YES, GO ALTER PRINT LEGEND
         BL    CHKMIDNT           * - NO, GO SEE IF IT'S MIDNIGHT
         SP    DOUB+4(4),=P'1200' * IT'S 13:00 OR GREATER, SO LET'S
*                                 *    CONVERT IT TO HUMAN TIME
PM12     MVI   AMPM+1,C'P'        * CHANGE "AM" TO "PM"
         B     EDTIME             *    & GO FINISH UP
         SPACE 1
CHKMIDNT LTR   R0,R0              * IS IT MIDNIGHT ?
         BNZ   EDTIME             * - NO, LEAVE ALONE
         AP    DOUB+4(4),=P'1200' * CHANGE "00" TO "12"
EDTIME   MVC   FIELDWK(7),=X'402020207A2120' * MOVE IN EDIT PATTERN
         LA    R1,FIELDWK+6        * PRE-POINT EDMK REG TO LAST BYTE
         LR    R15,R1              * SAVE THIS VALUE
         EDMK  FIELDWK(7),DOUB+5      * EDIT IN  TIME
         SR    R15,R1              * CALC LENGTH OF RESULT
         STC   R15,TIMEMVC+1       * ALTER OUR "MVC" LENGTH WITH IT
         MVC   0(2,R8),=C'AT'      * MOVE IN LEGEND SECTION
TIMEMVC  MVC   3(0,R8),0(R1)       * MOVE RESULT INTO HEADING
         LA    R8,4(R8,R15)        * POINT TO NEXT FREE SPOT AND
         MVC   0(4,R8),AMPM        * THEN MOVE IN AM/PM INDICATOR
         SPACE 2
BLDDRETN LM    R8,R9,BLDTSAVE      * RESTORE REGS WE USED
         BR    R9                  *    & RETURN TO CALLER
         SPACE 2
BLDTSAVE DS    2F                  * SAVE AREA FOR ABOVE SUBROUTINE
         SPACE 5
         SPACE 5
WRITEREC EQU    *              ***** SUBROUTINE TO WRITE OUT RECORDS
*                                  * AS A MEW MEMBER OF THE LOG PDS.
*                                  * ON ENTRY IF R1 IS >0, THEN IT
*                                  * MUST POINT TO A RECORD (NOT A
*                                  * BLOCK); IF R1 =0 THEN IT INDICATES
*                                  * THAT NO MORE RECORDS WILL BE
*                                  * PASSED FOR THIS MEMBER. THIS
*                                  * ALLOWS THIS SUBROUTINE TO WRITE
*                                  * OUT ANY PARTIAL (SHORT) BLOCK,
*                                  * AND THEREFORE SHOULD BE USED ONLY
*                                  * ONCE, AFTER THE LAST RECORD WAS
*                                  * PASSED.
         SPACE 1
         STM   R6,R9,WRTMSAVE      * SAVE REGS WE'LL ALTER
         SPACE 1
         LTR   R1,R1               * R1 ACTUALLY POINT TO A REC ?
         BZ    DONTADD             * - NO, DON'T UPDATE SPF STATS
*                                  * 1ST UPDATE SPF REC COUNT
         LH    R15,STINIT          * PICK UP CURRENT TOTAL RECS
*                                  * (WILL BE SPF INITIAL SIZE)
         LA    R15,1(R15)          * UPDATE BY ONE REC
         STH   R15,STINIT          * PUT IT BACK
         STH   R15,STSIZE          * ALSO UPDATE SPF SIZE
         SPACE 1
DONTADD  EQU   *                   *
         LTR   R6,R1               * TRANSFER REC ADDR & SEE WHAT KIND
         BNZ   NOTLSTBK            * IF IT CONTAINS A REC ADDR, GO
*                                  *    BUILD THIS RECORD INTO OUR
*                                  *       OUTPUT BLOCK
         SPACE 1
*                         ********** LOGIC TO WRITE OUT LAST BLOCK
*                                  * FOR A MEMBER
*                                  * - IF NOT, IT MEANS LAST RECORD IS
*                                  *     ALREADY IN ON THIS BLOCK FOR
*                                  * THIS MEMBER, SO WRITE BLOCK OUT
         LH    R8,NOOFRECS         * GET NO OF RECS IN BLOCK
         LTR   R8,R8               * WAS BLOCK ALREADY WRITTEN ANYWAY ?
         BZ    WRITERTN            * - YES, SO GET OUT NOW
         MH    R8,OUTLRECL         * MULTIPLY BY LRECL TO GET # OF
*                                  *    BYTES ALREADY IN BLOCK
         STH   R8,NETRKOUT+62      * MODIFY DCB BLKSIZE WITH THIS VALUE
*                                  * NOW LET'S WRITE OUT FINAL SHORT
*                                  *    BLOCK FOR THIS MEMBER
         WRITE OUTLECB1,SF,NETRKOUT,OUTAREA
         CHECK OUTLECB1            * WAIT & MAKE SURE WRITE WORKED OK
         XC    NOOFRECS,NOOFRECS   * NOW RESET # OF RECORDS TO 0
         B     WRITERTN            *    & GO RETURN
         SPACE 2
NOTLSTBK EQU   *         *********** NORMAL  RECORD/BLOCK LOGIC
         SPACE 1
         LH    R8,NOOFRECS         * GET # OF RECORDS CURRENTLY IN BLK
         MH    R8,NETRKOUT+82      * CALC # OF BYTES IN BLOCK NOW
         CH    R8,NETRKOUT+62      * IS THIS BLOCK FULL ?
         BL    NOTFULL             * - NO, GO PUT REC IN CURR BLOCK
WRITEBLK WRITE OUTLECB2,SF,NETRKOUT,OUTAREA
*                                  * - YES, WRITE OUT FULL BLOCK
         CHECK OUTLECB2            * WAIT & CHECK FOR NORMAL COMPLETION
         SR    R8,R8               * CLEAR OUR # OF BYTES IN BLOCK REG
         STH   R8,NOOFRECS         * RESET # OF RECORDS TO ZERO
         SPACE 1
NOTFULL  L     R1,=A(OUTAREA)      * GET A(OUTPUT AREA)
         AR    R8,R1               * DEVELOP ADDR OF NEXT SPOT IN BLOCK
*                                  *    TO PUT A RECORD
         LH    R7,OUTLRECL         * GET LRECL & PUT IT IN
         LR    R9,R7               *     "MVCL" LENGTH REGS
         MVCL  R8,R6               * MOVE THIS REC TO BLOCK
         LA    R1,1                * NOW UPDATE OUR
         AH    R1,NOOFRECS         *    # OF RECORDS
         STH   R1,NOOFRECS         *       ACCUMULATOR
         SPACE 1
WRITERTN EQU   *
         MVC   NETRKOUT+62(2),OUTBLKSZ * RESET DCB BLOCKSIZE TO FULL
*                                  *      BLOCKS
         LM    R6,R9,WRTMSAVE      * RESTORE REGS WE USED
         BR    R9                  *    & RETURN
         SPACE 2
WRTMSAVE DS    4F                  * SAVE AREA FOR ABOVE SUBROUTINE
         SPACE 5
         EJECT
***********************************************************************
*                                                                     *
*                      USER ABENDS                                    *
*                                                                     *
***********************************************************************
         SPACE 2
ABEND1   ABEND 101                 * UNCRECOVERABLE BPAM WRITE ERROR
ABEND2   ABEND 102                 * STOW MACRO FAILED
         EJECT
***********************************************************************
*                                                                     *
*                                                                     *
* FOLLOWING ARE THE CONSTANTS AND VARIABLE FIELDS PASSED TO THE       *
* "ISPLINK" MODULE BY US FOR THE VARIOUS "DISPLAY", "VGET", AND       *
* "VPUT" SERVICES THAT WE NEED.                                       *
*                                                                     *
*                                                                     *
***********************************************************************
         SPACE 2
VGET     DC    C'VGET    '         * NOTE RIGHT BLANK PAD TO 8 CHARS
VGETLIST EQU   *                   * NAME OF VARIABLE TO "VGET"
VGETNAME DC    CL80' '             *
         SPACE 1
VPUT     DC    C'VPUT    '         *
VPUTLIST DC    CL250' '            * NAMES OF VARIABLES TO "VPUT"
         SPACE 1
DISPLAY  DC    C'DISPLAY  '        *
PANLNAME DC    CL8' '              * NAME OF PANEL WE'LL USE
NTERRPNL DC    C'NTERRPNL'         * NAME OF ERROR PANEL
MSGNAME  DC    C'NETM00X'          *   & MESSAGE # TO GO WITH IT
CONTROL1 DC    C'CONTROL '         *
ERRORS   DC    C'ERRORS  '         *
RETURN   DC    C'RETURN  '         *
SPLIT    DC    C'SPLIT   '         * DON'T ALLOW
DISABLE  DC    C'DISABLE '         *    USE TO SPLIT SCREEN ON US
ENABLE   DC    C'ENABLE  '         * RE-ENABLE SPLIT BEFORE WE END
         SPACE 1
SHARED   DC    C'SHARED  '         *
         SPACE 1
VCOPY    DC    C'VCOPY   '         *
MOVE     DC    C'MOVE    '         *
L1       DC    F'1'                * LENGTH OF 1 FOR "VCOPY"
L8       DC    F'8'                * LENGTH OF 8 FOR "VCOPY"
L240     DC    F'240'              * LENGTH OF 240 FOR "VCOPY"
CHAR     DC    C'CHAR    '         *
         SPACE 1
SELECT   DC    C'SELECT  '         * KEYWORD FOR "SELECT"
CMDBUFLN DC    F'23'               * LENGTH OF "CMDBUF" BELOW
CMDBUF   DC    CL23' '             * BUFFFER CMD TO CALL CLIST
         SPACE 1
VDEFINE  DC    C'VDEFINE '         * NAMES OF "VDEFINE" FUNCTION
VDEF8LST DC    C'('                * VDEFINE NAMES BUILT HERE FOR
         DC    C'NTNXTPNL '        *
         DC    C'NTBADPNL '        *
         DC    C'NTERRPNL '        *
         DC    C'NTPROB#) '        *
*                                  *    LENGTH 8 VARIABLES
VDEF8VAL DC    CL80' '             * ALL LENGTH 8 VARS INIT TO BLANK
         SPACE 1
VREPLACE DC    C'VREPLACE '        *
VREPNAMS DC    C'(NTBADPNL) '      * VARIABLE FOR VREPLACE
REPLNTHS DC    F'8'                * LNTH OF VARIABLE NAME FOR VREPLACE
VRNMNPAN DC    C'(NTNXTPNL) '      * VARIABLE FOR VREPLACE
VRNONAME DC    C'$NONAME$'         * INVALID NAME - ON PURPOSE
         SPACE 1
NMUSERID DC    C'ZUSER    '        * NAMES OF THE
NMCONTIN DC    C'NTCONTIN '        *
NMNXTPNL DC    C'NTNXTPNL '        *
NAMELST1 EQU   *    (USED ONLY BY VDEFINE)
LFTPAREN DC    C' '                *
NMDATA00 DC    C'NTDATA00 '        *        VARIABLE FIELDS
NMDATA01 DC    C'NTDATA01 '        *
NMDATA02 DC    C'NTDATA02 '        *
NMDATA03 DC    C'NTDATA03 '        *               WE'LL NEED
NMDATA04 DC    C'NTDATA04 '        *
NMDATA05 DC    C'NTDATA05 '        *
NMDATA06 DC    C'NTDATA06 '        *
NMDATA07 DC    C'NTDATA07 '        *
NMDATA08 DC    C'NTDATA08 '        *
NMDATA09 DC    C'NTDATA09 '        *
RTPAREN  DC    C' '                *
ENDNMLST DC    CL10' '             * THIS TERMINATES NAMELIST SCAN
         SPACE 3
*                              ***** FIELDS BELOW ARE THE ONLY
*                                  * VARIABLES WE'LL RETRIEVE; THESE
*                                  * ARE THE STORAGE AREAS WHERE THE
*                                  * DATA IS ACTUALLY PLACED
         SPACE 1
NTNXTPNL DC    CL8' '              * NAME OF NEXT PANEL
NTCONTIN DC    C' '                * C'Y' INDICATES USER NEEDS ADDIT-
*                                  *   IONAL ROOM FOR COMMENTS
GENVARS  EQU   *                   * "VDEFINE"
NTDATA00 DC    CL240' '            * FIRST DATA FIELD
NTDATA01 DC    CL240' '            * 2ND DATA FIELD
NTDATA02 DC    CL240' '            * 3RD DATA FIELD,
NTDATA03 DC    CL240' '            *
NTDATA04 DC    CL240' '            *    ETC
NTDATA05 DC    CL240' '            *
NTDATA06 DC    CL240' '            *
NTDATA07 DC    CL240' '            *
NTDATA08 DC    CL240' '            *
NTDATA09 DC    CL240' '            *
*                                  *
         SPACE 1
REPDATA  DS    0CL8            ***** FOLLOWING FIELD FOR VREPLACE
NTBADPNL DC    CL8' '              * NAME OF PANEL IN ERROR
         SPACE 5
DOUB     DC    D'0'                * WORK AREA
         SPACE 1
PARMADDR DC    F'0'                * A(PARM PASSED - IF ANY)
         SPACE 3
OUTLRECL DS    H                   * PDS LRECL
OUTBLKSZ DS    H                   * PDS FULL BLOCK SIZE
NOOFRECS DC    H'0'                * # OF RECS CURRENTLY IN BLOCK
         SPACE 3
         DS    0D                  *
STOWLIST EQU   *                   * LIST FOR "STOW" TO UPDATE PDS
*                                  * DIRECTORY FOR "SYS1.AUTHOR.IZED.
*                                  * DATASETS".
STOWNAME DC    CL8'PRB00000'       * PROTOTYPE NAME OF MEMBER
STOWTTR  DC    CL3' '              * TTR ADDR; FILLED IN BY SYSTEM
STOWC    DC    X'0F'               * FLAG BYTE - SPF # OF USER HALF
*                                  *    WORDS IN DIRECTORY EXTENSION
STOWUSRD DS    0CL62               * MAXIMUM POSSIBLE USER DATA XTNSN
*                                  *   SPF USES 15 HALFWORDS
STVERMOD DC    X'0100'             * SPF VER/MOD LEVEL
         DC    XL2'00'             * NOT USED
STCRDAT  DC    PL4'0'              * SPF CREATE DATE - P'YYDDD' JULIAN
STMODDAT DC    PL4'0'              * SPF LAST MOD DATE - P'YYDDD' JUL
STMODTIM DC    XL2'00'             * SPF LAST MOD TIME P'HHMM' WITH
*                                  *    PACKED SIGN DROPPED
STSIZE   DC    XL2'00'             * SPF CURRENT # RECS, BINARY
STINIT   DC    XL2'00'             * SPF INITIAL # RECS, BINARY
STMODLVL DC    XL2'00'             * SPF MOD LEVEL - FORCE TO 0
STUSERID DC    CL8' '              * SPF USER ID
         DC    CL2' '              * FILLER
         SPACE 3
NETRKDIR DCB   DSORG=PS,MACRF=GL,DDNAME=NETRKLOG,RECFM=U,BLKSIZE=32760,X
               EODAD=EODDIRCT
         SPACE 3
NETRKOUT DCB   DSORG=PO,MACRF=W,DDNAME=NETRKLOG,SYNAD=ABEND1
         SPACE 3
         LTORG
         SPACE 3
FIELDWK  DC    CL12' '             * WORK AREA FOR EDMK
         SPACE 3
AMPM     DC    C' AM.'             * AM/PM INDICATOR
         SPACE 3
         DS    0D                  * MUST DOUBLEWORD ALIGN PARM BELOW
DATEPARM EQU   *                   ***** PARM LIST FOR EXTERNAL DATE
*                                  * CONVERSION/RETRIEVAL SUBROUTINE
PACKJUL  DS    PL3                 * PACKED JULIAN - P'YYDDD'
PACKCAL  DS    PL4                 * PACKED CALENDAR - P'MMDDYY'
PRNTCAL  DS    CL8                 * PRINTABLE DATE - C'MM/DD/YY'
MNTHLNTH DS    XL1                 * LENGTH OF NAME OF MONTH FOLLOWING
MNTHNAME DS    CL9                 * NAME OF MONTH - E.G. C'JUNE     '
DAYLNTH  DS    XL1                 * LENGTH OF NAME OF DAY FOLLOWING
DAYNAME  DS    CL9                 * NAME OF DAY - E.G. C'MONDAY   '
DATEWORK DS    CL21                * WORK AREA REQUIRED BY SUBROUTINE
         SPACE 3
*                                  *    DATE IN CHARACTER
         SPACE 1
SEPLINE  DC    CL80'--------------------'
         SPACE 1
DATEREC DS     0CL80           *****  AREA TO BUILD FANCY DATE/TIME
         DC    C'THIS PROBLEM WAS LOGGED ON '
DAY      DC    CL80' '             *
         SPACE 3
STRGADDR DC    F'0'                * A(GETMAINED 512K TO BUILD DATA)
NEXTNTRY DC    F'0'                * A(SPOT FOR NEXT ENTRY IN STG)
LASTNTRY DC    F'0'                * A(LAST SAFE SPOT TO USE)
         SPACE 3
OUTAREA  DS    CL32760             * AREA FOR BUILDING OUTPUT BLOCKS
         SPACE 3
         SPACE 3
**************************************************************
*   ABSOLUTE REGISTER EQUATES
**************************************************************
          SPACE
R0        EQU   0
R1        EQU   1           PARAMETER REGISTER
R2        EQU   2
R3        EQU   3
R4        EQU   4
R5        EQU   5
R6        EQU   6
R7        EQU   7
R8        EQU   8
R9        EQU   9
R10       EQU   10
R11       EQU   11
R12       EQU   12
R13       EQU   13          ADDRESS OF SAVE-AREA
R14       EQU   14          RETURN REGISTER
R15       EQU   15
          SPACE
**************************************************************
*   CONDITIONAL VALUES
**************************************************************
          SPACE
*   AFTER COMPARE INSTRUCTIONS (A:B)
          SPACE
H         EQU   2           A HIGH
L         EQU   4           A LOW
E         EQU   8           A EQUAL B
NH        EQU   13          A NOT HIGH
NL        EQU   11          A NOT LOW
NE        EQU   7           A NOT EQUAL B
          SPACE
*   AFTER ARITHMETIC INSTRUCTIONS
          SPACE
O         EQU   1           OVERFLOW     (AFTER TM - ALL ONES)
P         EQU   2           PLUS
M         EQU   4           MINUS        (AFTER TM - MIXED   )
Z         EQU   8           ZERO         (AFTER TM - ALL ZERO)
NP        EQU   13          NOT PLUS
NM        EQU   11          NOT MINUS
NZ        EQU   7           NOT ZERO
          SPACE
*   AFTER TEST UNDER MASK INSTRUCTIONS
          SPACE
NO        EQU   14          NOT ONES     (SEE ABOVE FOR O, M, & Z)
          SPACE
**************************************************************
         END   NETTRACK
