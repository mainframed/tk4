***********************************************************************
*    BOB ZIMMERMAN                                                    *
*    CNA INSURANCE                                                    *
*    (312) 822-5719                                                   *
*    LAST MODIFIED 8412                                               *
*                                                                     *
***********************************************************************
*                                                                     *
*    WRITTEN AND MAINTAINED BY BRUCE LOMAR, BOB ZIMMERMAN             *
*    CNA INSURANCE                                                    *
*                                                                     *
***********************************************************************
***********************************************************************
*                                                                     *
*  AUTHORS AND DATES:                                                 *
*                                                                     *
*      MIKE AMLING - ORIGINAL CODE                       ??/??/80 N/A *
*                                                                     *
*                                                                     *
*  MAINTENANCE SUMMARY:                                               *
*                                                                     *
*    MIKE AMLING - REVISE TO USE &INUSE(13)               5/ 5/83 MA01*
*                                                                     *
*                                                                     *
***********************************************************************
         MACRO
         RF
         GBLB  &INUSE(13)                                         MA01
         GBLC  &EQU(12),&USING(12)
         LCLA  &A,&X
         LCLC  &C
&X       SETA  N'&SYSLIST
.LOOPX   AIF   (&X LE 0).MEXIT
&C       SETC  '&SYSLIST(&X)'
&X       SETA  &X-1
         AIF   ('&C' EQ '').LOOPX      SKIP NULL ENTRIES
.*
.*  FREE THE REGISTER CURRENTLY IN USE AS &C
.*
&A       SETA  2                       LOWEST SUPPORTED REGISTER - 1
.LOOPA   AIF   (&A GE 12).ERRINUS      12 IS HIGHEST SUPPORTED REGISTER
&A       SETA  &A+1
         AIF   ('&EQU(&A)' NE '&C').LOOPA
.*
&INUSE(&A) SETB 0                      INDICATE REG NO LONGER IN USE
&EQU(&A) SETC  ''                      RESET FOR LATER RF MACROS
         AIF   ('&USING(&A)' EQ '').LOOPX
&USING(&A) SETC ''
         DROP  &C                                                     $
         AGO   .LOOPX
.*
.* ERROR MNOTES
.*
.ERRINUS MNOTE 4,'REGISTER &C NOT IN USE.'
         AGO   .LOOPX
.MEXIT   MEND
***********************************************************************
*                                                                     *
*  AUTHORS AND DATES:                                                 *
*                                                                     *
*      MIKE AMLING - ORIGINAL CODE                       ??/??/80 N/A *
*                                                                     *
*                                                                     *
*  MAINTENANCE SUMMARY:                                               *
*                                                                     *
*    MIKE AMLING - REVISE TO USE &INUSE(13)               5/ 5/83 MA01*
*                                                                     *
*                                                                     *
***********************************************************************
         MACRO
         RG    &S,&T
         GBLB  &INUSE(13)                                         MA01
         GBLC  &EQU(12),&USING(12)
         LCLA  &A
         LCLC  &C
         AIF   (N'&SYSLIST LE 2).MULTIX
         MNOTE 8,'ALL BUT FIRST 2 POSITIONAL PARAMETERS IGNORED.'
.MULTIX  AIF   (T'&T NE 'O').PAIR
         AIF   ('&S(3)' NE '').SPEC
.*
.*  SEARCH FOR 1 AVAILABLE REGISTER
.*
&A       SETA  2                ONE LESS THAN LOWEST SUPPORTED REGISTER
.LOOP1   ANOP                                                     MA01
&A       SETA  &A+1
         AIF   (&INUSE(&A)).LOOP1
         AIF   (&A GT 12).ERRNORE      IF 3..12 NOT AVAILABLE     MA01
.*
.*  SET UP LONE REGISTER OR EVEN REGISTER OF PAIR
.*
.TAKEA   ANOP
&INUSE(&A) SETB 1                      NOTE REGISTER IN USE
&EQU(&A) SETC  '&S(1)'                 NOTE NAME FOR RF MACRO
&C       SETC  '&S(1)       '(1,8)
         MNOTE *,'&C EQU   &A'
&S(1)    EQU   &A                      DEFINE SYMBOL FOR REGISTER     $
         AIF   ('&S(2)' EQ '').MEXIT
         USING &S(2),&S(1)             TELL ASSEMBLER ABOUT CONTENTS  $
&USING(&A) SETC '&S(2)'                NOTE DSECT NAME FOR RCALL MACRO
.MEXIT   MEXIT
.*
.*  SEARCH FOR AN AVAILABLE EVEN/ODD REGISTER PAIR
.*
.PAIR    AIF   (N'&S LE 2 AND N'&T LE 2).PAIROVX
         MNOTE 8,'ASSIGNMENT OVERRIDE IGNORED WHEN REQUESTING PAIR.'
.PAIROVX ANOP
&A       SETA  3                       ODD REG OF 1ST PAIR - 2
.LOOP2   ANOP                                                     MA01
&A       SETA  &A+2
         AIF   (&INUSE(&A) OR &INUSE(&A-1)).LOOP2
         AIF   (&A GT 11).ERRNOPA   11 IS ODD REG OF HIGHEST PAIR MA01
.*
.*  SET UP ODD REGISTER OF PAIR
.*
&INUSE(&A) SETB 1                      NOTE REGISTER IN USE
&EQU(&A) SETC  '&T(1)'                 NOTE ODD REG NAME FOR RF MACRO
&C       SETC  '&T(1)       '(1,8)
         MNOTE *,'&C EQU   &A'
&T(1)    EQU   &A                      DEFINE SYMBOL FOR REGISTER     $
&A       SETA  &A-1                    PRESET FOR DEFINING EVEN REG
         AIF   ('&T(2)' EQ '').TAKEA
&USING(&A+1) SETC '&T(2)'              NOTE DSECT NAME FOR RCALL MACRO
         USING &T(2),&T(1)             TELL ASSEMBLER ABOUT CONTENTS  $
         AGO   .TAKEA
.*
.*  CHECK USER-SPECIFIED REGISTER
.*
.SPEC    ANOP
&A       SETA  K'&S(3)
.SPCLOOP AIF   (&A LE 0).SPCOK
         AIF   ('&S(3)'(&A,1) LT '0').ERRSPEC
&A       SETA  &A-1
         AGO   .SPCLOOP
.SPCOK   ANOP
&A       SETA  &S(3)
         AIF   (&A LT 3 OR &A GT 12).ERRS312
         AIF   (NOT &INUSE(&A)).TAKEA
         AIF   ('&EQU(&A)' EQ '').ERRINU2
         MNOTE 12,'SPECIFIED REGISTER &A IN USE AS &EQU(&A)'
         MEXIT
.ERRINU2 MNOTE 12,'SPECIFIED REGISTER &A IN USE BY CALLING CODE'
         MEXIT
.ERRSPEC MNOTE 8,'SPECIFIED REGISTER &S(3) NOT NUMERIC.'
         MEXIT
.ERRS312 MNOTE 8,'SPECIFIED REGISTER NOT IN RANGE 3-12.'
         MEXIT
.ERRNOPA MNOTE 8,'NO REGISTER PAIR AVAILABLE.'
         MEXIT
.ERRNORE MNOTE 8,'NO REGISTER AVAILABLE.'
         MEND
         MACRO
         CNASEND
         GBLC  &GBLSTRG                NAME OF STORAGE LENGTH
         GBLC  &GBLSAVE                NAME OF SAVE AREA
         GBLC  &GBLCNAM                NAME OF CSECT
         GBLC  &GBLRENT                REENTRANCY OPTION
         AIF   ('&GBLRENT' EQ 'NO' OR '&GBLRENT' EQ 'NOSAVE').DONE
         AIF   ('&SYSECT' EQ '&GBLSAVE').GEN
         SPACE 1
&GBLSAVE DSECT ,                       RESUME SAVE AREA DSECT
.GEN     ANOP
         SPACE 1
WORKEND$ DS    0D                      FORCE LENGTH TO DOUBLEWORD
&GBLSTRG EQU   WORKEND$-&GBLSAVE       SET UP LENGTH EQUATE
         SPACE 2
&GBLCNAM CSECT ,                       RESUME CSECT
.DONE    ANOP
         MEND
         MACRO
         CNASTRG
         GBLC  &GBLRENT
         GBLC  &GBLSAVE
         GBLC  &GBLWTG
         GBLC  &GBLCESV            DEFINES SAVE AREA FOR NSL'S
         AIF   ('&GBLRENT' EQ 'NO').DONE
         AIF   ('&GBLRENT' EQ 'NOSAVE').DONE
*
*        WORK AREA DSECT BEGINNING WITH CNASTRG MACRO GENERATION
*
&GBLSAVE DSECT
         DS    18F                 STANDARD SAVE AREA
         AIF   ('&GBLRENT' NE 'STACK' AND '&GBLRENT' NE 'NEWSTACK').CCH
         DS    F                   NEXT FREE STACK LOCATION
         AGO   .DONE
.CCH     AIF   ('&GBLRENT' NE 'COM' OR '&GBLWTG' EQ '').DONE
&GBLWTG  DS    F                   NEXT EXECUTION ADDRESS
.DONE    AIF   ('&GBLCESV' NE 'NSL').NONSL
         DS    F                   DUMMY FOR STAE EXIT ROUTINE
         DS    13F                 SAVE AREA FOR NSL ENTRY OPTION
.NONSL   ANOP
         MEND
         MACRO
&MNAME   CNAEXIT  &RC,&XCTL=,&SPKA=,&EXIT=YES
.*
.*       THIS MACRO PROVIDES A COMPANION EXIT MACRO TO
.*       THE ENTRY MACRO CNAENTER.
.*
.*
.*       DECLARE GLOBAL SYMBOLS USED FOR CNAENTER AND CNAEXIT
.*
         GBLA  &GBLREG#            NUMBER OF BASE REGISTERS
         GBLB  &GBLACTV            MACRO HAS BEEN INVOKED BEFORE
         GBLC  &GBLREGS(5)         BASE REGISTER VALUES
         GBLC  &GBLUSNG            BASE REGS WITH COMMAS FOR USING
         GBLC  &GBLRENT            RENT OPTION
         GBLC  &GBLSAVE            SNAME OPTION
         GBLC  &GBLSTRG            STORAGE OPTION
         GBLC  &GBLSTCK            SIZE OF STACK
         GBLC  &GBLCNAM            CSECT NAME
         GBLC  &GBLCESP            SUBPOOL FOR SAVEAREA FREEMAIN
         GBLC  &GBLCESV            SVC TYPE FOR RENT=(NEWSTACK,TYPE)
.*
.*       LOCAL VARIABLES
.*
         LCLA  &LCLBASE            NUMBER OF REG TO GEN R.C. HOLD
         LCLA  &LCLLOOP            LOOP CONTROL WHILE GENNING ABOVE
         LCLC  &LCLLABL            STATEMENT LABEL
         LCLC  &LCLRREG            CHARACTER FORM OF LCLBASE WITH R
         LCLC  &LCLXNAM            NAME TO XCTL TO
         LCLC  &LCLXLST            NAME OF XCTL PARM LIST
         LCLC  &LCLXREG            NAME OF REGISTER FOR MODULE ADDR
.*
.*       CHECK THE XCTL= OPERAND
.*       IT CANNOT BE USED WITH THE RC OPERAND
.*       THERE ARE THREE FORMS OF THE OPERAND
.*       XCTL=MODULE-NAME   (OBSOLETE VERSION)
.*       XCTL=(SF,PLIST-NAME,ROUTINE-ADDRESS-LOCATION)
.*       XCTL=(I,MODULE-NAME)
.*
         AIF   ('&XCTL' EQ '').XCTL1OK          NO XCTL= OPERAND
         AIF   ('&RC' EQ '').XCTL1A             NO RC OPERAND
         MNOTE 4,'RETURN CODE AND XCTL= INCOMPATIBLE. RETURN CODE IGNORE
               ED'
.XCTL1A  AIF   (N'&XCTL NE 1).XCTL1B
&LCLXNAM SETC  '&XCTL'                          SET MODULE NAME
         AGO   .XCTL1OK                         AND END CHECKS
.XCTL1B  AIF   ('&XCTL(1)' NE 'I').XCTL1C       IS IT INLINE PLIST
&LCLXNAM SETC  '&XCTL(2)'                       SET MODULE NAME
         AIF   (N'&XCTL NE 2).XCTL1E1           GENERATE ERROR MESSAGE
         AGO   .XCTL1OK
.XCTL1C  AIF   ('&XCTL(1)' NE 'SF' AND '&XCTL(1)' NE 'E').XCTL1E2
         AIF   ('&XCTL(2)' EQ '').XCTL1D        CHECK IF XCTL PLIST
&LCLXLST SETC  '&XCTL(2)'                       SET XCTL PARM LIST ADDR
.XCTL1D  AIF   ('&XCTL(3)' EQ '').XCTL1E        IS A REGISTER SET
&LCLXREG SETC  '&XCTL(3)'                       SET REGISTER NAME
.XCTL1E  AIF   (N'&XCTL GT 3).XCTL1E3           TOO MANY OPERANDS
         AGO   .XCTL1OK                         END CHECKS
.XCTL1E1 MNOTE 4,'XCTL=(I,PLIST-NAME) MUST HAVE 2 OPERANDS'
         AGO   .XCTL1OK
.XCTL1E2 MNOTE 4,'XCTL= FORMS ARE I AND E. XCTL=&XCTL(1) INVALID'
         AGO   .XCTL1OK
.XCTL1E3 MNOTE 4,'XCTL= TOO MANY OPERANDS'
.XCTL1OK ANOP
.*
.*       CHECK USAGE OF SPKA OPERAND
.*
         AIF   ('&SPKA' EQ '').SPKA1OK    NO SPKA= OPERAND
         AIF   ('&GBLCESV' NE '').SPKA1OK MUST BE RENT=(NEWSTACK,X)
         MNOTE 4,'SPKA=&SPKA VALID ONLY FOR RENT=(NEWSTACK,NSL)'
.SPKA1OK ANOP
.*
.***     CHECK USAGE OF THE EXIT=NO OPERAND
.*
         AIF   ('&EXIT' EQ 'YES').EXITOK
         AIF   ('&EXIT' EQ 'NO').EXITC1
         MNOTE 8,'EXIT=&EXIT VALUE INVALID'
.EXITC1  ANOP
         AIF   ('&XCTL' EQ '').EXITC2
         MNOTE 8,'EXIT=NO INVALID WITH XCTL=&XCTL'
.EXITC2  AIF   ('&RC' EQ '').EXITOK
         MNOTE 8,'EXIT=NO INVALID WITH RETURN CODE OPERAND &RC'
.EXITOK  ANOP
.*
.*       RESUME CSECT IF WE HAVE LEFT IT
.*
         AIF   ('&GBLCNAM' EQ '&SYSECT').READY
&GBLCNAM CSECT ,                   RESUME ORIGINAL CSECT
         SPACE 2
.READY   ANOP
.*
.*       SET STATEMENT LABEL
.*
&LCLLABL SETC  '&MNAME'
.*
.*       SET UP GLOBALS TO CAUSE DEFAULT IF CNAENTER NOT USED
.*
         AIF   (&GBLACTV).ACTIVE
&GBLRENT SETC  'NO'
&GBLSAVE SETC  'SAVEAREA'
         MNOTE 4,'CNAENTER NOT USED - WILL GENERATE FOR NON-REENTRANT'
.ACTIVE  ANOP
.*
.*       THERE ARE TWO FUNDAMENTAL CASES - 1 REQUIRING A FREEMAIN
.*       AND THE OTHER NOT.  THE FIRST CASE OCCURS WHEN &GBLRENT
.*       IS 'YES' OR 'NEWSTACK'.  THE OTHER OCCURS WHEN &GBLRENT
.*       IS 'NO' 'NOSAVE' 'STACK' OR 'COM'.  FIRST SECTION OF MACRO
.*       DETERMINES WHICH CASE IS PRESENT.
.*
         AIF   ('&GBLRENT' EQ 'YES' OR '&GBLRENT' EQ 'NEWSTACK').FREE
         AIF   ('&XCTL' NE '').GENXCTL
.*
.*       NOW GET THE RETURN CODE INTO R15 IF IT IS NOT IN 15 OR A
.*       SELF-DEFINING TERM.
.*
         AIF   ('&EXIT' EQ 'NO').NFRCSET    CASE - EXIT=NO
         AIF   ('&RC' EQ '0').NFRCSET       CASE - CNAEXIT 0 OPTIMIZE
         AIF   ('&XCTL' NE '').NFRCSET      CASE - XCTL OPERAND PRESENT
         AIF   ('&RC' EQ '').NFRCSET        CASE - NULL DEFAULT 0
         AIF   ('&RC' EQ '(R15)').NFRCSET   CASE - RC PRESET
         AIF   ('&RC' EQ '(15)').NFRCSET    CASE - RC PRESET
         AIF   ('&RC'(1,1) EQ '(').NFREG    CASE - REG FORM
         AIF   (T'&RC EQ 'N').NFRCSET       CASE - SELF-DEFINING
&LCLLABL L     R15,&RC             LOAD RETURN CODE VALUE
&LCLLABL SETC  ''                  NULIFY LABEL COPY
         AGO   .NFRCSET
.NFREG   ANOP
&LCLLABL LR    R15,&RC(1)          LOAD RETURN CODE VALUE
&LCLLABL SETC  ''
.*
.***     R15 LOADED UNLESS SR OR LA TO BE GENERATED
.*
.NFRCSET ANOP
.*
.*       RESTORE REGISTER 13 FOR NON-REENTRANT CASE
.*
         AIF   ('&GBLRENT' EQ 'NOSAVE').NFLR14
&LCLLABL L     R13,&GBLSAVE+4      RESTORE CALLER'S SAVE AREA
&LCLLABL SETC  ''
.*
.***     REENTER HERE FROM REENTRANT CASE
.*
.NFLR14  ANOP
         AIF   ('&RC' EQ '').NFLR14A           SKIP SUBSTRING IF NO PRM
         AIF   ('&RC'(1,1) EQ '(').NFLRN0      ALREADY LOADED IF REG.
         AIF   ('&EXIT' EQ 'NO' OR '&XCTL' NE '').NFLRN0
         AIF   ('&RC' NE '' AND T'&RC NE 'N').NFLRN0
.NFLR14A ANOP
&LCLLABL LM    R14,R12,12(R13)     RESTORE REGISTERS
         AIF   ('&RC' EQ '' OR '&RC' EQ '0').NFLRY0
         LA    R15,&RC             SET RETURN CODE NOT ZERO
         AGO   .NFLRN0A
.NFLRY0  ANOP
         SR    R15,R15             SET RETURN CODE ZERO
         AGO   .NFLRN0A
.*
.***     NEXT 2 INSTRUCTIONS IF RETURN CODE WAS LEFT IN R15
.*
.NFLRN0  ANOP
&LCLLABL L     R14,12(,R13)        RESTORE RETURN ADDRESS
         LM    R0,R12,20(R13)      RESTORE REMAINING REGISTERS
.NFLRN0A ANOP
         MVI   12(R13),X'FF'       FLAG AS RETURNED FOR SNAP SVC
         AIF   ('&EXIT' EQ 'NO').EXITNFN
         BR    R14                 RETURN TO CALLER
.EXITNFN ANOP
         MEXIT
.*
.*       REENTRANT CASE - FIRST GET RETURN CODE INTO A REGISTER
.*       WHICH IS NOT R15 AND IS NOT A BASE REGISTER.  DETERMINE
.*       WHICH REGISTER FIRST
.*
.FREE    AIF   ('&GBLCESV' NE '').GENNSL GO GENERATE SYSTEM CONV.
         AIF   ('&XCTL' NE '').FRSET   AVOID RETURN CODE LOGIC
&LCLRREG SETC  '&RC(1)'
         AIF   ('&RC' EQ '').FRNEED
         AIF   ('&RC'(1,1) EQ '(' AND '&RC' NE '(R15)').FRSET
.FRNEED  ANOP
&LCLBASE SETA  2
.FRCHECK ANOP
&LCLLOOP SETA  1
&LCLRREG SETC  'R&LCLBASE'
.FRLOOP  ANOP
         AIF   ('&LCLRREG' EQ '&GBLREGS(&LCLLOOP)').FRRETRY
&LCLLOOP SETA  &LCLLOOP+1
         AIF   (&LCLLOOP LE &GBLREG#).FRLOOP
         AGO   .FRLRC
.FRRETRY ANOP
&LCLBASE SETA  &LCLBASE+1
         AGO   .FRCHECK
.FRLRC   ANOP
         AIF   ('&EXIT' EQ 'NO').FRLR SAVE R15 AGAINST FREEMAIN
         AIF   ('&RC' EQ '0').FRSET  CASE - CNAEXIT 0 OPTIMIZED
         AIF   ('&XCTL' NE '').FRSET        CASE - XCTL= NO R15
         AIF   ('&RC' EQ '').FRSET          CASE - NULL DEFAULTS TO 0
         AIF   ('&RC'(1,1) EQ '(').FRLR     CASE - REGISTER OPERAND
         AIF   (T'&RC EQ 'N').FRSET         CASE - GENERATE LA INSTRUCT
&LCLLABL L     &LCLRREG,&RC        LOAD RETURN CODE VALUE
&LCLLABL SETC ''
         AGO   .FRSET
.FRLR    ANOP
&LCLLABL LR    &LCLRREG,&RC(1)     SAVE RETURN CODE OVER FREEMAIN
&LCLLABL SETC  ''
.FRSET   ANOP
&LCLLABL LR    R1,R13              SET ADDRESS TO FREE
&LCLLABL SETC  ''
         L     R13,&GBLSAVE+4      GET CALLER'S SAVE AREA
         AIF   ('&GBLRENT' EQ 'NEWSTACK').FRSTACK
 DC 0C'  FREEMAIN R,A=(1),LV=&GBLSTRG,SP=&GBLCESP' FREEMAIN ISSUED
         FREEMAIN R,A=(1),LV=&GBLSTRG,SP=&GBLCESP
         AGO   .NFSET15
.FRSTACK ANOP
 DC 0C'  FREEMAIN R,A=(1),LV=&GBLSTCK,SP=&GBLCESP' FREEMAIN ISSUED
         FREEMAIN R,A=(1),LV=&GBLSTCK,SP=&GBLCESP
.NFSET15 AIF   ('&XCTL' NE '').GENXCTL     GENERATE XCTL EXIT CODE
         AIF   ('&RC' EQ '' OR '&RC' EQ '0').NFLR14
         AIF   ('&RC'(1,1) EQ '(').FRSET15
         AIF   (T'&RC EQ 'N').NFLR14
.FRSET15 ANOP
         LR    R15,&LCLRREG        SET RETURN CODE INTO PROPER REG
         AGO   .NFLR14
.*
.*       GENERATE FOR RENT=(NEWSTACK,NSL),SPKA=
.*
.GENNSL  ANOP
&LCLLABL CNOP  0,4
&LCLLABL SETC  ''
         L     R0,*+8              LOAD SUBPOOL AND LENGTH
         B     *+8                 SKIP INLINE CONSTANT
         DC    AL1(&GBLCESP),AL3(&GBLSTCK)
         LA    R1,0(,R13)          POINT AT STACK
         LM    R2,R14,80(R13)      RESTORE OPEN/CLOSE/EOV REGS
         SVC   10                  ISSUE FREEMAIN SVC DIRECTLY
         AIF   ('&SPKA' EQ '').NSL1B
         SPKA  &SPKA               RETURN TO SUPERVISOR KEY
.NSL1B   AIF   ('&EXIT' EQ 'NO').MEND  IF EXIT=NO, GET OUT QUICKLY
         AIF   ('&LCLXREG' EQ '').NSL1C SKIP BRANCH TEST IF NOT REQ
         ICM   R15,15,&LCLXREG     CHECK FOR EP IN THIS LOAD MODULE
         BNZR  R15                 AND GO TO IT IF PRESENT
.NSL1C   AIF   ('&LCLXNAM' NE '').XCTL2B GEN INLINE LIST XCTL
   DC 0C'XCTL  SF=(E,&LCLXLST)'
         XCTL  SF=(E,&LCLXLST)
         MEXIT
.*
.*       GENERATE ERROR MESSAGE FOR RENT=(NEWSTACK,SVC6)
.*
.SVC6GEN AIF   ('&GBLCESV' NE 'SVC6').SVC5GEN TRY SVC15
         MNOTE 12,'RENT=(NEWSTACK,SVC6) NOT SUPPORTED BY CNAEXIT'
         MEXIT
.*
.*       GENERATE ERROR MESSAGE FOR RENT=(NEWSTACK,SVC15)
.*
.SVC5GEN AIF   ('&GBLCESV' NE 'SVC15').SVCXGEN TRY NEW PARM
         MNOTE 12,'RENT=(NEWSTACK,SVC15) NOT SUPPORTED BY CNAEXIT'
         MEXIT
.*
.*       GENERATE ERROR MESSAGE FOR UNRECOGNIZED &GBLCESV VALUE'
.*
.SVCXGEN MNOTE 12,'RENT=(NEWSTACK,&GBLCESV) NOT SUPPORTED BY CNAEXIT'
         MEXIT
.*
.*       GENERATE XCTL=(I,MODULE-NAME) VERSION OF XCTL
.*
.GENXCTL LM    R14,R12,12(R13)     RESTORE CALLERS REGISTERS
.XCTL2B  CNOP  2,4                 INSURE CONSTANT ALIGNMENT
         BALR  R15,0               SET NEW ADDRESSABILITY
         PUSH  USING               SAVE PREVIOUS ENVIRONMENT
         DROP  ,                   AVOID ADDRESSING PROBLEMS
         USING *,R15               AND TELL THE ASSEMBLER THE TRUTH
         L     R15,*+16            GET ADDRESS OF NEXT ROUTINE
         LTR   R15,R15             IS IT IN THIS MODULE
         BNZR  R15                 YES, GO TO IT DIRECTLY
         BALR  R15,0               NO, RESET ADDRESSABILITY
         USING *,R15               TELL THE ASSEMBLER AGAIN
         LA    R15,*+10            POINT AT XCTL SF= LIST
         XCTL  SF=(E,(15))         AND GO TO PROGRAM WITH ASSIST
         WXTRN &LCLXNAM            DECLARE AS WEAK EXTERNAL REFERENCE
         DC    A(&LCLXNAM)         IF LINKEDITED IN
         XCTL  EP=&LCLXNAM,SF=L    BUILD XCTL PARAMETER LIST
         POP   USING               GET USERS ENVIRONMENT BACK
.MEND    ANOP                        WAY TO BRANCH OUT
         MEND
         MACRO
&MNAME   CNAENTER  &BASES,         BASE REGISTER LIST                  X
               &CBASE=DR12,        REGISTER ADDRESSING COMMON          X
               &ENTRY=DYES,        GENERATE ENTRY STATEMENT (WITH NAME)X
               &ID=DYES,           FULL, NONE OR DATELESS ID           X
               &PARM=DR2,          WHERE TO PUT PARM LIST POINTER      X
               &PLOAD=,            HOW TO SET UP PARAMETER POINTERS    X
               &RENT=DYES,         REENTRANCY OR NOT AND TYPE          X
               &SAVE=YES,          SHOULD REGISTERS BE SAVED           X
               &SCLEAR=DNO,        SHOULD SAVE AREA BE CLEARED?        X
               &SNAME=,            NAME OF SAVE/WORK AREA              X
               &SP=,               SUBPOOL FOR SAVE AREA               X
               &SPKA=,             SET PROTECT KEY                     X
               &STACK=D2048,       SIZE OF STACK FOR NEWSTACK OPTION   X
               &STORAGE=DWORKLEN,  LENGTH OF STORAGE TO OBTAIN         X
               &WCLEAR=DNO,        SHOULD WORK AREA BE CLEARED?        X
               &WTG=D              WHERE TO GO FIELD NAME
.*
.*       DECLARE GLOBAL SYMBOLS USED FOR MULTIPLE INVOCATIONS AND
.*       THE CNAEXIT MACRO
.*
         GBLA  &GBLREG#            NUMBER OF BASE REGISTERS
         GBLA  &GBLQCNT            NUMBER OF Q ADDRESS CONSTANTS
         GBLB  &GBLACTV            MACRO HAS BEEN INVOKED BEFORE
         GBLB  &GBLSCLR            CLEAR SAVE AREA OPTION
         GBLB  &GBLWCLR            WORK AREA CLEAR OPTION
         GBLC  &GBLREGS(5)         BASE REGISTER VALUES
         GBLC  &GBLUSNG            BASE REGS WITH COMMAS FOR USING
         GBLC  &GBLID              ID OPTION
         GBLC  &GBLPARM            PARM OPTION
         GBLC  &GBLRENT            RENT OPTION
         GBLC  &GBLRSVE            SAVE REGISTERS OPTION (YES OR NO)
         GBLC  &GBLSAVE            SNAME OPTION
         GBLC  &GBLSTRG            STORAGE OPTION
         GBLC  &GBLSTCK            SIZE OF STACK
         GBLC  &GBLCNAM            CSECT NAME
         GBLC  &GBLQNAM(20)        UP TO 20 Q NAMES
         GBLC  &GBLWTG             WTG OPERAND OF 1ST ENTRY
         GBLC  &GBLCBAS            COMMON BASE REGISTER
         GBLC  &GBLCESP            SUBPOOL FOR GETMAIN AND FREEMAIN
         GBLC  &GBLCESV            SVC TYPE - SVCR6, SVCR15, NSL, NULL
         GBLC  &CNASPFL            LEVEL NUMBER FROM SPF LIBRARY
         GBLC  &CNASPFD            DATE OF LAST MODIFICATION
         GBLC  &CNASPFU            USERID OF LAST UPDATER
.*
.*       LOCAL SYMBOLS USED
.*
         LCLA  &LCLREG#            NUMBER OF ENTRIES IN &BASES
         LCLA  &LCLSUB1            DESTINATION SUBSCRIPT
         LCLA  &LCLSUB2            SOURCE SUBSCRIPT
         LCLA  &LCLIDSZ            SIZE OF ID CONSTANTS
         LCLA  &LCLIDLN            &LCLIDSZ-1
         LCLA  &LCLCONS            LENGTH OF ALL CONSTANTS
         LCLA  &LCLFILL            SIZE TO ALIGN SAVE AREA
         LCLA  &LCLWORK            ARITHMETIC WORK
         LCLA  &LCLPLUS            OFFSET CALCULATIONS
         LCLA  &LCLOFFS            OFFSET TO ENTRY OFFSET
         LCLA  &LCLSTRL            OFFSET TO STORAGE VALUE FOR STACKING
         LCLA  &LCLPRML            NUMBER OF VALUES TO PLOAD OPERAND
         LCLB  &LCLOFF             ON FOR 2ND-NTH ENTRIES
         LCLB  &LCLRENT            IS SOME FORM OF REENTRANCY IN?
         LCLB  &LCLENTR            IS ENTRY STATEMENT NEEDED?
         LCLB  &LCLSCLR            CLEAR SAVE AREA THIS ENTRY?
         LCLB  &LCLWCLR            CLEAR WORK AREA THIS ENTRY?
         LCLC  &LCLENAM            NAME FOR ENTRY STATEMENT
         LCLC  &LCLPARM            NAME FOR KEEPING R1
         LCLC  &LCLCHAR            CHARACTER WORK FIELD
         LCLC  &LCLSTRG            STORAGE THIS TIME THHROUGH
         LCLC  &LCLID              ID OPTION FOR THIS CALL
         LCLC  &LCLSVCT            SVC TYPE - SVCR6, SVCR15, NSL, NULL
         LCLC  &LCLTBAS            ENTRY POINT BASE FOR FIRST INSTRS.
.*
.*       IF THIS IS THE FIRST ENTRY, EDIT THE VALUES GIVEN
.*
         AIF   (&GBLACTV).NTH
&GBLACTV SETB  (1)               SET FOR NEXT TIME IN
&GBLCNAM SETC  '&SYSECT'           SET CSECT NAME
.*
.*       EDIT THE REENTRANCY OPTION  (FIRST SUBPARAMETER)
.*
         AIF   ('&RENT(1)' EQ 'DYES').DRENT
&LCLCHAR SETC  '&RENT(1)'
&LCLRENT SETB  ('&LCLCHAR' EQ 'YES'   OR '&LCLCHAR' EQ 'NEWSTACK' OR   *
                '&LCLCHAR' EQ 'STACK' OR '&LCLCHAR' EQ 'NOSAVE'   OR   *
                '&LCLCHAR' EQ 'COM')
         AIF   (&LCLRENT OR '&LCLCHAR' EQ 'NO').RENTOK
         MNOTE 4,'&RENT IS AN INVALID REENTRANCY OPTION - YES USED.'
.DRENT   ANOP
&GBLRENT SETC  'YES'
&LCLRENT SETB  (1)
         AGO   .RENTOVR
.RENTOK  ANOP
&GBLRENT SETC  '&RENT(1)'
.*
.*       EDIT THE WTG OPERAND IF &GBLRENT=COM
.*
         AIF   ('&GBLRENT' NE 'COM').RENTOVR
         AIF   ('&WTG' EQ 'D').RENTWTX     NO WTG TYPE PROCESSING
&GBLWTG  SETC  '&WTG'
         AIF   ('&GBLWTG' NE '').RENTWTX
         MNOTE *,'WTG OPERAND NULLIFIED - NO WTG CODE GENERATED'
.RENTWTX ANOP
         AIF   ('&CBASE' EQ 'DR12').DEFCBAS
         AIF   ('&CBASE' NE '').ASGNCBS
         MNOTE 8,'COMMON BASE NEEDED TO RELOCATE WORK AREA - R12 USED.'
.DEFCBAS ANOP
&GBLCBAS SETC  'R12'
         AGO   .RENTOVR
.ASGNCBS ANOP
&GBLCBAS SETC  '&CBASE'
.RENTOVR ANOP
.*
.*       EDIT THE SECOND RENT OPERAND.  THIS IS VALID ONLY IF THE
.*       RENT=NEWSTACK OPERAND IS CODED, AND MUST HAVE ONE OF THE
.*       VALUES 'SVCR6' 'SVCR15' 'NSL' OR NULL.
.*
&LCLTBAS SETC  'R15'                           ASSUME R15 AS ENTRY
         AIF   ('&RENT(2)' EQ '').RNT2END      NO SVC OPTION CODED
         AIF   ('&RENT(1)' NE 'NEWSTACK').RNT2E1 ERROR IF NOT NEWSTACK
         AIF   ('&RENT(2)' NE 'SVCR6' AND '&RENT(2)' NE 'SVCR15' AND   X
               '&RENT(2)' NE 'NSL').RNT2E2     NOT VALID ENTRYS
&GBLCESV SETC  '&RENT(2)'                      SET TYPE OF SVC ENTRY
&LCLSVCT SETC  '&RENT(2)'                      SET IT IN LOCAL
         AIF   ('&LCLSVCT' NE 'SVCR6').RNT2END R15 IS RIGHT
&LCLTBAS SETC  'R6'                            SET R6 AS ENTRY BASE
         AGO   .RNT2END
.RNT2E1  MNOTE 8,'SECOND RENT= OPERAND ONLY VALID WITH NEWSTACK'
         AGO   .RNT2END
.RNT2E2  MNOTE 8,'SECOND RENT= OPERAND MUST BE SVCR6, SVCR15, OR NSL'
.RNT2END ANOP
.*
.*       EDIT THE SPKA OPERAND.  IT IS ONLY VALID IF SECOND RENT
.*       OPTION IS USED.  IT IS USED ONLY IF SPECIFIED ON THE MACRO
.*
         AIF   ('&SPKA' EQ '').RNT3END
         AIF   ('&GBLCESV' NE '').RNT3END  SKIP IF 2ND RENT SPEC'D
         MNOTE 4,'SPKA= OPERAND NOT VALID IF 2ND RENT OPTION OMITTED'
.RNT3END ANOP
.*
.*       EDIT THE SAVE OPERAND.  THIS MUST BE YES UNLESS RENT=
.*       NO OR NOSAVE WAS ENTERED.  THEN IT MAY BE NO.
.*
&GBLRSVE SETC  'YES'                FORCE DEFAULT VALUE
         AIF ('&SAVE' EQ 'YES').RSAVEOK
         AIF ('&SAVE' NE 'NO').RSAVEX1
         AIF ('&GBLRENT' EQ 'NO' OR '&GBLRENT' EQ 'NOSAVE').RSAVEOK
         MNOTE 8,'SAVE=NO ONLY ALLOWED WITH RENT=NO OR RENT=NOSAVE'
         AGO   .RSAVEXL
.RSAVEX1 MNOTE 8,'SAVE= MUST BE YES OR NO'
         AGO   .RSAVEXL
.RSAVEOK ANOP
&GBLRSVE SETC  '&SAVE'
.RSAVEXL ANOP
.*
.*       EDIT THE STACK OPERAND - SHOULD BE D2048 UNLESS
.*       &GBLRENT=NEWSTACK.  IN THAT CASE, SET &GBLSTCK
.*       TO VALUE OF STACK OPERAND.  MULTIPLY BY 1024 IF
.*       ALL NUMERIC EXCEPT TERMINAL K.
.*
         AIF   ('&GBLRENT' EQ 'NEWSTACK').NSEDIT
         AIF   ('&STACK' EQ 'D2048').STACKX
         MNOTE 4,'STACK= IGNORED SINCE RENT=NEWSTACK NOT SPECIFIED'
         AGO   .STACKX
.NSEDIT  ANOP
&LCLWORK SETA  K'&STACK
         AIF   ('&STACK'(&LCLWORK,1) EQ 'K' AND &LCLWORK GT 1).KVAL
         AIF   ('&STACK' NE 'D2048').ASGNSTK
&GBLSTCK SETC  '2048'
         AGO   .STACKX
.KVAL    ANOP
&LCLCHAR SETC  '&STACK'(1,&LCLWORK-1)
.KVALOOP ANOP
&LCLWORK SETA  &LCLWORK-1
         AIF   ('&LCLCHAR'(&LCLWORK,1) LT '0').ASGNSTK
         AIF   (&LCLWORK GT 1).KVALOOP
&GBLSTCK SETC  '&LCLCHAR*1024'
         AGO   .STACKX
.ASGNSTK ANOP
&GBLSTCK SETC  '&STACK'
.STACKX  ANOP
.*
.*       EDIT THE BASE REGISTER SET AND SET UP GBLREG#, GBLREGS AND
.*       GBLUSNG.
.*
&LCLREG# SETA  N'&BASES
&GBLREG# SETA  &LCLREG#
&LCLSUB1 SETA  1
&LCLSUB2 SETA  1
         AIF   (&LCLRENT).OK#
&GBLREG# SETA  &GBLREG#+1          INCREMENT FOR R13 ADDITION
&GBLREGS(1) SETC 'R13'
&LCLSUB1 SETA  2
.OK#     ANOP
         AIF   (&GBLREG# GT 0).OKCOPY
         MNOTE 8,'NO BASE REGISTERS SPECIFIED - WILL USE R11'
&GBLREG# SETA  1
&GBLREGS(1) SETC 'R11'
.OKCOPY  AIF   (&LCLSUB2 GT &LCLREG#).COPUSNG
&GBLREGS(&LCLSUB1) SETC '&BASES(&LCLSUB2)'
&LCLSUB1 SETA  &LCLSUB1+1
&LCLSUB2 SETA  &LCLSUB2+1
         AGO   .OKCOPY
.COPUSNG ANOP
&GBLUSNG SETC  ',&GBLREGS(1)'
         AIF   (&GBLREG# LE 1).ID
&LCLSUB1 SETA  2
         AIF   ('&LCLSVCT' NE '').ERRSVC1
.UCOPY   AIF   (&LCLSUB1 GT &GBLREG#).ID
&GBLUSNG SETC  '&GBLUSNG,&GBLREGS(&LCLSUB1)'
&LCLSUB1 SETA  &LCLSUB1+1
         AGO   .UCOPY
.ERRSVC1 MNOTE 4,'ONLY 1 BASE REGISTER SUPPORTED FOR SVC TYPE &LCLSVCT'
.*
.*       EDIT THE IDENTIFICATION OPTION - DEFAULT IS DYES(YES)-IF SPEC
.*       IS NOT YES, NO, NODATE OR SHORT, SET TO SHORT
.*
.ID      AIF   ('&ID' EQ 'DYES').DID
         AIF   ('&ID' EQ 'YES').IDOK
         AIF   ('&ID' EQ 'NO').IDOK
         AIF   ('&ID' EQ 'NODATE').IDOK
         AIF   ('&ID' EQ 'SHORT').IDOK
         MNOTE 4,'&ID IS AN INVALID IDENTIFICATION OPTION - SHORT USED'
&GBLID   SETC  'SHORT'
&LCLID   SETC  'SHORT'
         AGO   .PRM
.DID     ANOP
&GBLID   SETC  'YES'
&LCLID   SETC  'YES'
         AGO   .PRM
.IDOK    ANOP
&GBLID   SETC  '&ID'
&LCLID   SETC  '&ID'
.*
.*       EDIT THE PARM OPERAND - SET R2 IF OMITTED
.*
.PRM     AIF   ('&PARM' EQ 'DR2').DPARM
         AIF   ('&PARM' NE '').SETPRM
         MNOTE *,'INPUT PARAMETER LIST POINTER WILL BE IN R2'
.DPARM   ANOP
&GBLPARM SETC  'R2'
&LCLPARM SETC  'R2'
         AGO   .ENT
.SETPRM  ANOP
&GBLPARM SETC  '&PARM'
&LCLPARM SETC  '&PARM'
.*
.*       EDIT THE ENTRY= OPERAND - VALID VALUES ARE YES, NO AND
.*       (YES,NAME) - IF YES, &MNAME MUST NOT BE NULL - SET NO
.*       IF INVALID VALUE OR YES AND NO &MNAME
.*
.ENT     ANOP
&LCLENAM SETC  '&MNAME'                  SET LOCAL NAME TO MACRO
         AIF   ('&MNAME' NE '').ENTNOK   YES, LET IT DEFAULT
&LCLENAM SETC  '&SYSECT'                 MUST BE AT START OF MACRO
.ENTNOK  AIF   ('&ENTRY' EQ 'DYES').EYES
         AIF   ('&ENTRY' EQ 'YES').EYES
         AIF   ('&ENTRY' EQ 'NO').SNAME
         AIF   ('&ENTRY(1)' EQ 'YES').ENAME
         MNOTE 4,'&ENTRY INVALID ENTRY OPTION - NO USED'
         AGO   .SNAME
.EOMIT   MNOTE 8,'ENTRY NAME OMITTED - WILL USE NAME FIELD OF CNAENTER X
               MACRO IF PRESENT'
.EYES    AIF   ('&MNAME' EQ '').ENONE
&LCLENAM SETC  '&MNAME'
&LCLENTR SETB  (1)
         AGO   .SNAME
.ENAME   AIF   ('&ENTRY(2)' EQ '').EOMIT
&LCLENAM SETC  '&ENTRY(2)'
&LCLENTR SETB  (1)
         AGO   .SNAME
.ENONE   MNOTE 8,'ENTRY=YES CANCELLED BECAUSE THERE IS NO NAME ON THE MX
               ACRO'
.*
.*       SET THE GLOBAL SAVEVAL TO BE SAVE/WORK AREA NAME FROM
.*       SNAME= OPERAND.  DEFAULT TO WORKAREA OR SAVEAREA
.*       DEPENDING ON REENTRANCY OPTION
.*
.SNAME   AIF   ('&SNAME' EQ '').SNDEF
&GBLSAVE SETC  '&SNAME'
         AGO   .QCONCK
.SNDEF   ANOP
&GBLSAVE SETC  'WORKAREA'
         AIF   (&LCLRENT).QCONCK
&GBLSAVE SETC  'SAVEAREA'
.QCONCK  AIF   ('&GBLRENT' NE 'COM').SCLR
         CNADXD &GBLSAVE
&GBLSAVE SETC  '&GBLQNAM(&GBLQCNT)'
.*
.*       SET THE GLOBAL CLEARS
.*
.SCLR    ANOP
&GBLSCLR SETB  ('&SCLEAR' EQ 'YES')
&LCLSCLR SETB  (&GBLSCLR)
.*
.*       SET THE GLOBAL CLEARW
.*
&GBLWCLR SETB  ('&WCLEAR' EQ 'YES')
&LCLWCLR SETB  (&GBLWCLR)
.*
.*       SET GLOBAL STRGVAL FROM STORAGE= - NULL ALLOWED FOR NON-RENT
.*
&GBLSTRG SETC  'WORKLEN'
&LCLSTRG SETC  'WORKLEN'
         AIF   ('&STORAGE' EQ 'DWORKLEN').EDITSP
&GBLSTRG SETC  '&STORAGE'
&LCLSTRG SETC  '&STORAGE'
         AIF   ('&GBLSTRG' NE '').EDITSP
         AIF   (NOT &LCLRENT).CALC
         AIF   ('&RENT(1)' EQ 'NOSAVE').EDITSP
&GBLSTRG SETC  'WORKLEN'
&LCLSTRG SETC  'WORKLEN'
         MNOTE 8,'STORAGE= NULLIFIED BUT VALUE REQUIRED - WORKLEN USED'
.*
.*  EDIT THE SP= PARAMETER (SUBPOOL = )
.*
.EDITSP  ANOP
&GBLCESP SETC '0'            DEFAULT IT TO SUBPOOL 0
         AIF  ('&SP' EQ '').CALC  ACCEPT THE DEFAULT
&GBLCESP SETC '&SP'          SET THE OPERAND VALUE
         AGO  .CALC
.*
.*
.*
.*       EDIT SUPPLIED OPERANDS AGAINST GLOBAL VALUES USED IN FIRST
.*       INVOCATION OF CNAENTER
.*
.*
.*
.NTH     ANOP
.*
.*       SET UP LOCAL ITEMS TO MATCH GLOBALS FOR FIRST APPROXIMATION
.*
&LCLSCLR SETB  (&GBLSCLR)
&LCLWCLR SETB  (&GBLWCLR)
&LCLPARM SETC  '&GBLPARM'
&LCLID   SETC  '&GBLID'
&LCLSTRG SETC  '&GBLSTRG'
&LCLOFF  SETB  (1)
&LCLSVCT SETC  '&GBLCESV'             SVC TYPE
&LCLTBAS SETC  'R15'                  TEMPORARY BASE IS R15
         AIF   ('&LCLSVCT' NE 'SVCR6').RNT2L1
&LCLTBAS SETC  'R6'                   TEMPORARY BASE IS R6 FOR SVCR6
.RNT2L1  ANOP
.*
.*       IGNORE ANY DESIGNATION OF BASE REGISTERS
.*
         AIF   (N'&BASES EQ 0).RENTR
         MNOTE 4,'BASE REGISTERS IGNORED - WILL USE SAME AS ON 1ST CALLX
                TO CNAENTER - &GBLREGS(1) IS FIRST BASE'
.*
.*       THE ENTRY ATTRIBUTE MUST BE ASSUMED ELSE WHY ANOTHER ENTRY?
.*
.RENTR   AIF   ('&ENTRY' EQ 'DYES' OR '&ENTRY' EQ 'YES').RSETM
         AIF   ('&ENTRY(2)' NE '').RSET2
         MNOTE 8,'&ENTRY INVALID FOR THIS CALL - YES USED AND NAME ON MX
               ACRO WILL BE ENTRY NAME'
.RSETM   AIF   ('&MNAME' NE '').RSETM2
         MNOTE 8,'MACRO NAME REQUIRED FOR ENTRY POINT - ####$$$$ USED'
&LCLENAM SETC  '####$$$$'
         AGO   .RENTSET
.RSET2   ANOP
&LCLENAM SETC  '&ENTRY(2)'
         AGO   .RENTSET
.RSETM2  ANOP
&LCLENAM SETC  '&MNAME'
.RENTSET ANOP
&LCLENTR SETB  (1)
.*
.*       ID VALUE RESET TO CONTAIN NO DATE SPECIFICATION IF YES
.*       CURRENTLY IN EFFECT
.*
         AIF   ('&LCLID' NE 'YES').CKIDOVR
&LCLID   SETC  'NODATE'
.CKIDOVR AIF   ('&ID' EQ 'DYES').RPRM
         AIF   ('&ID' EQ 'YES').LCLYES
         AIF   ('&ID' EQ 'SHORT').LCLYES
         AIF   ('&ID' EQ 'NODATE').LCLYES
         AIF   ('&ID' EQ 'NO').LCLYES
         MNOTE 4,'&ID INVALID FOR ID= - VALUE &LCLID USED.'
         AGO   .RPRM
.LCLYES  ANOP
&LCLID   SETC  '&ID'
.*
.*       SEE IF PARM REGISTER TO BE OVERRIDEN FOR THIS ENTRY
.*
.RPRM    ANOP
         AIF   ('&PARM' EQ 'DR2').RRENT
&LCLPARM SETC  '&PARM'
.*
.*       FLUSH RENT OPTION IF CODED - USE ORIGINAL
.*
.RRENT   AIF   ('&RENT(1)' EQ 'DYES').RSWRCK
         AIF   ('&RENT(1)' EQ '&GBLRENT').RSWRCK
         MNOTE 4,'&RENT REENTRANCY OPTION IGNORED - &GBLRENT FROM FIRSTX
               USE OF CNAENTER USED.'
.RSWRCK  ANOP
.*
.*       SET &LCLRENT FOR PROPER GEN TYPE
.*
&LCLRENT SETB  ('&GBLRENT' EQ 'YES'   OR '&GBLRENT' EQ 'NEWSTACK' OR   *
                '&GBLRENT' EQ 'STACK' OR '&GBLRENT' EQ 'NOSAVE' OR     *
                '&GBLRENT' EQ 'COM')
.*
.*       EDIT SPKA OPTION. ONLY VALID IF 2ND RENT OPTION CODED
.*
         AIF  ('&SPKA' EQ '' OR '&GBLCESV' NE '').RNT4OK
         MNOTE 4,'SPKA=&SPKA IGNORED IF 2ND RENT OPTION NOT CODED'
.RNT4OK  ANOP
.*
.*       EDIT WTG OPERAND IF GBLRENT=COM
.*
         AIF   ('&GBLRENT' NE 'COM').NOCBAS
         AIF   ('&GBLWTG' EQ '').NLWTG
         AIF   ('&WTG' EQ 'D' OR '&WTG' EQ '&GBLWTG').NOWTGE
         MNOTE 8,'&WTG WTG ENTRY IGNORED - &GBLWTG USED'
         AGO   .NOWTGE
.NLWTG   ANOP
         AIF   ('&WTG' EQ 'D' OR '&WTG' EQ '').NOWTGE
         MNOTE 8,'NO WTG CODE GENERATED DUE TO FIRST ENTRY CONDITIONS'
.NOWTGE  ANOP
         AIF   ('&CBASE' EQ 'DR12' OR '&CBASE' EQ '&GBLCBAS').NOCBAS
         MNOTE 8,'COMMON BASE CODED IGNORED - &GBLCBAS USED'
.NOCBAS  ANOP
.*
.*       RESET LOCAL VALUE OF CLEAR SWITHCES IF NOT DEFAULTED
.*
         AIF   ('&SCLEAR' EQ 'DNO').CKWCLR
&LCLSCLR SETB  ('&SCLEAR' EQ 'YES')
.CKWCLR  AIF   ('&WCLEAR' EQ 'DNO').RSN
&LCLWCLR SETB  ('&WCLEAR' EQ 'YES')
.*
.*       SAVE AREA NAME MUST REMAIN CONSTANT OVER INVOCATIONS
.*
.RSN     AIF   ('&SNAME' EQ '').RSTRG
         AIF   ('&SNAME' EQ '&GBLSAVE').RSTRG
         MNOTE 8,'&SNAME WILL NOT BE USED FOR SAVE/WORK AREA NAME - &GBL
               LSAVE WILL BE USED INSTEAD'
.*
.*       STORAGE VALUE CAN ONLY CHANGE FOR RENT=NEWSTACK OR RENT=STACK
.*
.RSTRG   AIF   ('&STORAGE' EQ 'DWORKLEN').CALC
         AIF   ('&STORAGE' EQ '&GBLSTRG').CALC
         AIF   ('&GBLRENT' EQ 'NEWSTACK' OR '&GBLRENT' EQ 'STACK').REST
        MNOTE 8,'UNABLE TO CHANGE STORAGE LENGTH - VALUE &GBLSTRG USED'
         AGO   .CALC
.REST    ANOP
&LCLSTRG SETC  '&STORAGE'
.*
.*
.*
.*       COMMON MACRO SET UP AND OFFSET CALCULATION
.*
.*
.*    ID=    NO     SHORT   NODATE    YES     ENTRY=  (SPFID)  FIRST?
.*
.*            0       10      10       24       NO       NO      ---
.*
.*                            28       28       YES      ---     NO
.*
.*                            28       42       YES      NO      YES
.*
.*                            34       48       NO       YES     ---
.*
.*                            52       66       YES      YES     YES
.*
.*
.CALC    ANOP
&LCLIDSZ SETA  0
         AIF   ('&LCLID' EQ 'NO').NOSPFID
&LCLIDSZ SETA  10
         AIF   ('&LCLID' EQ 'SHORT').NOSPFID  NO ID OR DATES
         AIF   (NOT &LCLENTR AND NOT &LCLOFF).IDLEN
&LCLIDSZ SETA  &LCLIDSZ+18           FOR ENTRY=YES
.IDLEN   AIF   (&LCLOFF).NOSPFID     NO DATES FOR 2ND ENTRY
         AIF   ('&LCLID' EQ 'NODATE').CALCND  NO DATE - MAY BE SPF
&LCLIDSZ SETA  &LCLIDSZ+14           FOR ASSEMBLY DATE AND TIME
.CALCND  AIF   ('&CNASPFL' EQ '').NOSPFID       SKIP IF NO SPF DATA
&LCLIDSZ SETA  &LCLIDSZ+24         LENGTH OF SPF SOURCE DATA
.NOSPFID ANOP
&LCLIDLN SETA  &LCLIDSZ-1
.*
.*       SIZE OF ID CONSTANTS CALCULATED - CALCULATE TOTAL
.*       CONSTANT SIZE BY ADDING 2 FOR STORAGE CALCULATION
.*       FOR STACKING, 2 FOR OFFSET FOR BASE 1 CALCULATION
.*       AND 72 PLUS ALIGNMENT FILLER FOR IN-LINE SAVE AREAS.
.*
&LCLCONS SETA  &LCLIDSZ
&LCLPLUS SETA  4
         AIF   (NOT &LCLOFF).NOFF
&LCLCONS SETA  &LCLCONS+2         ADD FOR BASE 1 OFFSET
&LCLOFFS SETA  &LCLIDSZ+&LCLPLUS
&LCLPLUS SETA  &LCLPLUS+2
.NOFF    AIF   ('&GBLRENT' NE 'STACK' AND '&GBLRENT' NE 'NEWSTACK').N
&LCLCONS SETA  &LCLCONS+2         ADD FOR STORAGE OFFSET
&LCLSTRL SETA  &LCLIDSZ+&LCLPLUS
&LCLPLUS SETA  &LCLPLUS+2
.N       AIF   ('&GBLRENT' NE 'NO' OR &LCLOFF).NOSAVE
&LCLWORK SETA  &LCLCONS/4
&LCLWORK SETA  &LCLWORK*4
&LCLFILL SETA  &LCLWORK+4-&LCLCONS
         AIF   (&LCLFILL LT 4).FSET
&LCLFILL SETA  0
.FSET    ANOP
&LCLCONS SETA  &LCLCONS+&LCLFILL+72
.*
.*
.*       CALCULATIONS ARE DONE ... BEGIN CODE GENERATION
.*
.*
.NOSAVE  ANOP
         AIF   (NOT &LCLOFF).NOALGN
         CNOP  0,8                 FORCE DOUBLE WORD ALIGNMENT
.NOALGN  AIF   (NOT &LCLENTR).NEGE
&LCLENAM DS    0H                  ENTRY POINT NAME
         ENTRY &LCLENAM            EXTERNAL DECLARATION
.NEGE    AIF   ('&MNAME' EQ '').NNAME
         AIF   ('&LCLENAM' EQ '&MNAME' AND &LCLENTR).NNAME
&MNAME   DS    0H                  ENTRY POINT NAME
.NNAME   ANOP
         USING *,&LCLTBAS          TEMPORARY BASE
         AIF   (&LCLCONS EQ 0).NOCONS
&LCLWORK SETA  &LCLCONS+4
         B     *+&LCLWORK          BRANCH AROUND ALL CONSTANTS
         AIF   (&LCLIDSZ EQ 0).NOIDSZ
         DC    AL1(&LCLIDLN)       LENGTH OF ID FIELDS
         AIF   (NOT &LCLENTR).NOECON
         DC    CL9'&LCLENAM'       ENTRY NAME IN ID FIELDS
         AIF   (&LCLIDSZ EQ 10).NOIDSZ
         DC    CL9'IN CSECT '
.NOECON  DC    CL9'&SYSECT'        CSECT NAME IN ID FIELDS
         AIF   (&LCLIDSZ EQ 10).NOIDSZ
         AIF   (&LCLOFF).NOIDSZ    SKIP BOTH TIME AND SPF DATA FOR 2ND
         AIF   ('&LCLID' EQ 'NODATE').SPFID1
         DC    CL9'&SYSDATE'       ASSEMBLY DATE IN ID FIELDS
         DC    CL5'&SYSTIME'       ASSEMBLY TIME IN ID FIELDS
.SPFID1  AIF   ('&CNASPFD' EQ '').NOIDSZ INSERT SPF DATA
         DC    CL8' &CNASPFD'      DATE OF THIS MODIFICATION
         DC    CL8'&CNASPFL'       LEVEL NUMBER OF THIS VERSION
         DC    CL8'&CNASPFU'       TSO USERID OF LAST UPDATER
.NOIDSZ  AIF   (NOT &LCLOFF).STCKCK
         AIF   ('&GBLRENT' EQ 'NO').SAOFF
         DC    Y(&LCLENAM-&SYSECT) OFFSET TO MODULE BASE
         AGO   .STCKCK
.SAOFF   DC    Y(&LCLENAM-&GBLSAVE) OFFSET TO MODULE BASE
.STCKCK  AIF   ('&GBLRENT' NE 'STACK' AND '&GBLRENT' NE 'NEWSTACK').F
         DC    Y(&LCLSTRG)         WORK AREA SIZE FROM STACK
.F       AIF   ('&GBLRENT' NE 'NO' OR &LCLOFF).NOCONS
         AIF   (&LCLFILL EQ 0).NOFILL
         DC    XL(&LCLFILL)'00'    FILLER TO ALIGN SAVE AREA
.NOFILL  ANOP
&GBLSAVE DC    18F'0'              MODULE'S SAVE AREA
.NOCONS  ANOP
         SPACE 2
.*
.*             GENERATE CODE FOR SVC ENTRY OPTIONS
.*
         AIF   ('&LCLSVCT' EQ '').RNT2GND   NO SVC ENTRY, GO TO STD.
         AIF   ('&LCLSVCT' EQ 'SVCR6').RNT2G1 DON'T SAVE BASE REGISTER
         AIF   ('&LCLSVCT' EQ 'NSL').RNT2G1  LIKEWISE FOR NSL OPTION
         LR    R3,&LCLTBAS         SAVE TEMPORARY BASE
         DROP  &LCLTBAS
         USING &LCLENAM,R3
&LCLTBAS SETC  'R3'                RESET TEMPORARY BASE
.RNT2G1  AIF   ('&SPKA' EQ '').RNT2G1A      SKIP IF NO SPKA OPTION
         AIF   ('&SPKA' NE 'DATAMGT').USERSPK
         SPKA  80                  SET DATAMGT PROTECT KEY
         AGO   .RNT2G1A
.USERSPK SPKA  &SPKA               SET PROTECT KEY FOR USER
.RNT2G1A ANOP
  DS  0C'GETMAIN R,LV=&GBLSTCK,SP=&GBLCESP' GET NEW STACK
         GETMAIN R,LV=&GBLSTCK,SP=&GBLCESP
         AIF   ('&LCLSVCT' NE 'NSL').RNT2G2  SKIP SAVE IF NOT NSL
         STM   R2,R14,80(R1)       SAVE OPEN/CLOSE/EOV REGS (EX. R3)
         LR    R13,R1              SET SAVEAREA IN PROPER BASE
         BALR  &GBLREGS(1),0       GET LOCATION
         LA    R15,*-&SYSECT       CALCULATE CORRECT BASE
         SLR   &GBLREGS(1),R15      --> 4K MODULE LIMIT <--
         AGO   .RNT2G3             SKIP OTHER OPTION FIDDLING
.RNT2G2  LR    R13,R1              SET SAVEAREA IN PROPER BASE
         AIF   ('&GBLREGS(1)' EQ '&LCLTBAS' AND NOT &LCLOFF).RNT2G3A
         AIF   ('&GBLREGS(1)' EQ '&LCLTBAS').RNT2G2A
         LR    &GBLREGS(1),&LCLTBAS SET PERMANENT BASE REGISTER
.RNT2G2A AIF   (NOT &LCLOFF).RNT2G3      SKIP IF NOT SECOND ENTRY
         SH    &GBLREGS(1),&LCLENAM+&LCLOFFS ADJUST THE BASE REGISTER
.RNT2G3  DROP  &LCLTBAS            RESET ADDRESSING
         USING &SYSECT&GBLUSNG     SET USING FOR PROGRAM
.RNT2G3A LH    R15,&LCLENAM+&LCLSTRL SET ADDRESS OF NEXT
         AR    R15,R13              WORKAREA IN THE STACK
         ST    R15,72(,R13)         FOR RENT=STACK PROCESSING
         XC    4(8,R13),4(R13)      CLEAR BACK AND FOREWARD POINTERS
         USING &GBLSAVE,R13         DECLARE DSA
         AIF   ('&LCLSVCT' NE 'SVCR6').RNT2G4 IS IT R6 ENTRY
         LM    R0,R1,32(R5)         RESTORE PARAMETER REGS FROM
         L     R15,92(R5)           SVRB SAVEAREA
.RNT2G4  SPACE 2
         MEXIT
.RNT2GND ANOP
.*
.*             NOW GENERATE FOR NON SVC ENTRY OPTIONS
.*
         AIF   ('&GBLRSVE' EQ 'NO').RSVE#1
         STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS
         AGO   .RSVE#2
.RSVE#1  LR    R3,R14              SAVE R14 FOR RETURN
.RSVE#2  LR    &LCLPARM,R1         SAVE INPUT PARAMETER LIST PTR.
         AIF   (&LCLRENT).RBASES
         AIF   (&LCLOFF).SOFFBAS
         LA    R15,&GBLSAVE        WILL BE BASE AND S.A. POINTER
.NRBAS   ST    R13,4(,R15)         SET BACK CHAIN
         ST    R15,8(,R13)         SET FORWARD CHAIN
         LR    R13,R15             SET BASE AND S.A. POINTER
         DROP  R15                 END TEMPORARY ADDRESSING
         USING &GBLSAVE&GBLUSNG    PERMANENT ADDRESSING
         AGO   .NTHBASE
.SOFFBAS ANOP
         SH    R15,&LCLENAM+&LCLOFFS WILL BE BASE AND S.A. POINTER
         AGO   .NRBAS
.RBASES  LR    &GBLREGS(1),R15     SET 1ST BASE REGISTER
         AIF   (NOT &LCLOFF).ROFFBAS
         SH    &GBLREGS(1),&LCLENAM+&LCLOFFS RESET BACK TO ORIGIN
.ROFFBAS DROP  R15                 END TEMPORARY ADDRESSING
         USING &SYSECT&GBLUSNG     PERMANENT ADDRESSING
.NTHBASE AIF   (&GBLREG# LE 1).NTHSET
&LCLSUB1 SETA  2
&LCLSUB2 SETA  1
         LA    R14,2048            CONSTANT FOR NTH BASE GENERATION
.NTHGENR AIF   (&LCLSUB1 GT &GBLREG#).NTHSET
         LA    &GBLREGS(&LCLSUB1),2048(R14,&GBLREGS(&LCLSUB2).)
&LCLSUB2 SETA  &LCLSUB1
&LCLSUB1 SETA  &LCLSUB1+1
         AGO   .NTHGENR
.NTHSET  ANOP
         SPACE 2
         AIF   ('&GBLRENT' EQ 'NO').PL
         AIF   ('&GBLRENT' EQ 'NOSAVE').PL
         AIF   ('&GBLRENT' EQ 'YES').GET
         AIF   ('&GBLRENT' EQ 'STACK').STACK
         AIF   ('&GBLRENT' EQ 'COM').COMGET
*                                  GET STACK
         GETMAIN  R,LV=&GBLSTCK,SP=&GBLCESP
         AGO   .FWDCHN
.STACK   ANOP
         L     R1,72(,R13)         GET NEXT AREA ORIGIN IN STACK
         AGO   .FWDCHN
.GET     ANOP
*                                  GET WORKING STORAGE
         GETMAIN  R,LV=&LCLSTRG,SP=&GBLCESP
         AGO   .FWDCHN
.COMGET  ANOP
         L     R1,Q&GBLQNAM(1)     GET OFFSET TO WORK AREA
         AR    R1,&GBLCBAS         ADJUST TO ADDRESS
.FWDCHN  ST    R1,8(,R13)          SET FORWARD CHAIN
         AIF   (NOT &LCLWCLR).SCLRCK
         LR    R14,R1              ADDRESS TO BEGIN CLEAR
         AIF   ('&GBLRENT' EQ 'YES').CLRLC
         AIF   (&LCLENTR).LHENTR
         LH    R15,&SYSECT+&LCLSTRL LENGTH OF CLEAR
         AGO   .CLRCMN
.CLRLC   LH    R15,*+8             LENGTH OF CLEAR
         B     *+6                 AROUND CONSTANT
         DC    Y(&LCLSTRG)         SIZE OF WORK AREA
         AGO   .CLRCMN
.LHENTR  LH    R15,&LCLENAM+&LCLSTRL LENGTH OF CLEAR
.CLRCMN  SR    R1,R1               FILL CHARACTER IS X'00'
         MVCL  R14,R0              CLEAR THE WORK AREA
         L     R1,8(,R13)          RELOAD CURRENT WORK POINTER
         AGO   .CLRD
.SCLRCK  AIF   (NOT &LCLSCLR).CLRD
         XC    0(72,R1),0(R1)      CLEAR THE SAVE AREA
.CLRD    AIF   ('&GBLRENT' EQ 'YES' OR '&GBLRENT' EQ 'COM').NOSTKS
         AIF   (&LCLENTR).LENENTR
         LH    R15,&SYSECT+&LCLSTRL SIZE OF AREA NEEDED IN STACK
         AGO   .BLDSTKN
.LENENTR LH    R15,&LCLENAM+&LCLSTRL SIZE OF AREA NEEDED IN STACK
.BLDSTKN AR    R15,R1              R15 IS NEXT FREE SLOT IN STACK
         ST    R15,72(,R1)         SET FOR NEXT MODULE TO FIND
.NOSTKS  AIF   ('&GBLRSVE' EQ 'NO').NRSV#3
         ST    R13,4(,R1)          SET BACK CHAIN
         LM    R13,R1,8(R13)       RESTORE CLOBBERED REGISTERS
         USING &GBLSAVE,R13        TELL ASSEMBLER ABOUT REGISTER
         AGO   .PL                 GO CHECK FOR PARAMETER LIST SAVE
.NRSV#3  LR    R13,R1              SET WORK AREA REGISTER
         USING &GBLSAVE,R13        TELL ASSEMBLER ABOUT REGISTER
.PL      AIF   ('&PLOAD' EQ '').DONE
&LCLPRML SETA  N'&PLOAD
&LCLWORK SETA  1
         SPACE 2
.PLLOOP  CNAPLOAD &PLOAD(&LCLWORK),&LCLWORK,&LCLPARM
&LCLWORK SETA  &LCLWORK+1
         AIF   (&LCLWORK LE &LCLPRML).PLLOOP
.DONE    AIF   ('&GBLRENT' NE 'COM').DONE1
         AIF   ('&GBLWTG' EQ '').DONE1
         ICM   R15,15,&GBLWTG         PICK UP WHERE TO GO ADDRESS
         BNZR  R15                    GO THERE IF INITIALIZED
.DONE1   ANOP
         SPACE 2
         MEND
DDNLIST  TITLE 'SUBROUTINE: RETURN ALL ALLOCATED DDNAMES'
DDNLIST  CSECT
         RG    (RBASE,,12)
         RG    (RCOUNT)
         RG    (RARRAY)
         RG    (RPARM)
*                                                                     *
*  TECHNICAL NOTES:                                                   *
*     1. PROGRAM IS REENTRANT.                                        *
*     2. RETURN-CODES:                                                *
*              0 = SUCCESSFUL SEARCH ("HITS" FOUND).                  *
*              4 = SUCCESSFUL SEARCH ("HITS" FOUND); ARRAY OVERFLOW.  *
*              8 = UNSUCCESSFUL SEARCH (NO "HITS" FOUND).             *
         EJECT
*                                                                     *
*     DDNLIST PARAMETERS ARE:                                         *
*           ARRAY ROW-COUNTER (HALFWORD BINARY; UPDATED TO NUMBER OF  *
*                              DSNAMES FOUND)                         *
*           ARRAY             (N X 8-BYTE ARRAY FOR DSNAMES)          *
         CNAENTER RBASE,PARM=RPARM,RENT=YES,ENTRY=NO
         XC    RC4,RC4
         LM    RCOUNT,RARRAY,0(RPARM)        GRAB 3 ENTRY PARAMETERS
         RF    RPARM                         FREE PARM-POINTER
*              CLEAR RESULTS-ARRAY
         RG    (RWORK1A),(RWORK1B)
         RG    (RWORK2A),(RWORK2B)
         XR    RWORK2A,RWORK2A
         XR    RWORK2B,RWORK2B
         ICM   RWORK2B,8,=C' '               BLANK-FILL CHAR
         LH    RWORK1B,0(RCOUNT)             GET ARRAY COUNTER
         LA    RWORK1A,8                     MULTIPLY BY 8
         MR    RWORK1A,RWORK1A               MULTIPLY BY ARRAY COUNTER
         LR    RWORK1A,RARRAY                SET ARRAY ADDRESS
         MVCL  RWORK1A,RWORK2A               CLEAR RESULTS ARRAY
*
         RF    RWORK1A,RWORK1B
         RF    RWORK2A,RWORK2B
         RG    (RTALLY)
*
         SPACE 2
         RG    (RTCB)                        TCB MAP
         RG    (RTIOT)                       TIOT MAP
         L     RTCB,540(R0)                  POINT TO TCBOLD
         L     RTIOT,12(RTCB)                POINT TO TIOT (TCBTIO)
         RF    RTCB                          DONE WITH TCB
         RG    RTIOTLN                       TCB DDNAME ENTRY LENGTH
         XR    RTIOTLN,RTIOTLN
         LA    RTIOT,24(RTIOT)               POINT TO 1ST DDNAME ENTRY
         XR    R0,R0                         CLEAR FOR RESULTS COUNT
         LH    RTALLY,0(RCOUNT)              ARRAY COUNTER
         LA    RTALLY,1(RTALLY)                PLUS 1 FOR BCT
         SPACE 2
DDLOOK   DS    0H
         CLI   0(RTIOT),X'00'
         BE    DONEDDN                       BR IF DDNAME NOT FOUND
         IC    RTIOTLN,0(RTIOT)              PICK UP TIOELNGH
         TM    1(RTIOT),X'80'                TEST FOR FREED TIOT ENTRY
         BO    NEXTDDN                       BR IF FOUND
         CLI   4(RTIOT),C' '                 TEST FOR CONCAT ENTRY
         BNE   GOTDDN                        BR IF NOT CONCAT
NEXTDDN  DS    0H
         LA    RTIOT,0(RTIOTLN,RTIOT)        SET TO NEXT ENTRY
         B     DDLOOK
GOTDDN   DS    0H
         BCT   RTALLY,*+8                    DECREASE ARRAY COUNT
         B     NOROOM                        BR IF NO ROOM IN ARRAY
         A     R0,=F'1'                      ADD TO "HIT" COUNT
         MVC   0(8,RARRAY),4(RTIOT)          COPY DDNAME TO ARRAY
         LA    RARRAY,8(RARRAY)              BUMP TO NEXT DDN SLOT
         B     NEXTDDN                       LOOP TO NEXT ENTRY
         EJECT
*
*** SEARCH ARRAY FILLED ... PREPARE FOR EXIT
*
NOROOM   DS    0H
         RF    RTIOT,RTIOTLN
         MVI   RC1,4                         SET OVERFLOW RETURN-CODE
DONEDDN  DS    0H
         STH   R0,0(RCOUNT)                  SAVE DSN COUNT
         LTR   R0,R0                         ANY HITS?
         BNZ   FASTEXIT                      BR IF YES
         MVI   RC1,8                         SET NO-HIT RETURN-CODE
         B     FASTEXIT
         EJECT
         RF    RTALLY,RCOUNT,RARRAY
         EJECT
*
*** PROGRAM EXIT
*
FASTEXIT CNAEXIT RC4
         TITLE '- CONSTANTS'
         LTORG *
         TITLE '- WORKING STORAGE'
         CNASTRG
RC4      DS    F
RC1      EQU   RC4+3,1
*
         CNASEND
         EJECT
**************************************************************
*   ABSOLUTE REGISTER EQUATES
**************************************************************
          SPACE
R0        EQU   0
R1        EQU   1           PARAMETER REGISTER
R2        EQU   2
R3        EQU   3
R4        EQU   4
R5        EQU   5
R6        EQU   6
R7        EQU   7
R8        EQU   8
R9        EQU   9
R10       EQU   10
R11       EQU   11
R12       EQU   12
R13       EQU   13          ADDRESS OF SAVE-AREA
R14       EQU   14          RETURN REGISTER
R15       EQU   15
          SPACE
**************************************************************
*   CONDITIONAL VALUES
**************************************************************
          SPACE
*   AFTER COMPARE INSTRUCTIONS (A:B)
          SPACE
H         EQU   2           A HIGH
L         EQU   4           A LOW
E         EQU   8           A EQUAL B
NH        EQU   13          A NOT HIGH
NL        EQU   11          A NOT LOW
NE        EQU   7           A NOT EQUAL B
          SPACE
*   AFTER ARITHMETIC INSTRUCTIONS
          SPACE
O         EQU   1           OVERFLOW     (AFTER TM - ALL ONES)
P         EQU   2           PLUS
M         EQU   4           MINUS        (AFTER TM - MIXED   )
Z         EQU   8           ZERO         (AFTER TM - ALL ZERO)
NP        EQU   13          NOT PLUS
NM        EQU   11          NOT MINUS
NZ        EQU   7           NOT ZERO
          SPACE
*   AFTER TEST UNDER MASK INSTRUCTIONS
          SPACE
NO        EQU   14          NOT ONES     (SEE ABOVE FOR O, M, & Z)
          SPACE
**************************************************************
         END
