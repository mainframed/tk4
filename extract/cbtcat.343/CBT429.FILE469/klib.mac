***********************************************************************
*    BOB ZIMMERMAN                                                    *
*    CNA INSURANCE                                                    *
*    (312) 822-5719                                                   *
*    LAST MODIFIED 8504                                               *
***********************************************************************
***********************************************************************
*                                                                     *
*  AUTHORS AND DATES:                                                 *
*                                                                     *
*      MIKE AMLING - ORIGINAL CODE                       ??/??/80 N/A *
*                                                                     *
*                                                                     *
*  MAINTENANCE SUMMARY:                                               *
*                                                                     *
*    MIKE AMLING - REVISE TO USE &INUSE(13)               5/ 5/83 MA01*
*                                                                     *
*                                                                     *
***********************************************************************
         MACRO
         RNOTE &SUBRTN
         GBLA  &#SUB
         GBLB  &INUSE(13),&SINUSE(200),&SDOWN(20)                 MA01
         GBLC  &USING(12),&SNAME(20),&SUSING(200)
         LCLA  &N,&A
.*
.* FIND THE NUMBER ASSIGNED TO THIS SUBROUTINE
.*
.LOOPN1  AIF   (&N GE &#SUB).NEWSUB
&N       SETA  &N+1
         AIF   ('&SNAME(&N)' NE '&SUBRTN').LOOPN1
         AIF   (&SDOWN(&N)).ERRDOWN
.*
.* SUBSCRIPTS FOR THIS SUBROUTINE'S REGISTERS ARE &N*10-9 THRU &N*10
.*
.* NOTE THE REGISTER ENVIRONMENT
.*
&N       SETA  &N*10-10                LOWEST SUBSCRIPT MINUS 1
&A       SETA  2                       LOWEST SUPPORTED REGISTER - 1
.LOOPA1  AIF   (&A GE 12).EXIT         12 IS HIGHEST SUPPORTED REGISTER
&N       SETA  &N+1
&A       SETA  &A+1
&SINUSE(&N) SETB (&SINUSE(&N) OR &INUSE(&A))  NOTE WHETHER REG IN USE
         AIF   ('&SUSING(&N)' EQ '&USING(&A)').LOOPA1  IF STILL USING,
.*                                     LEAVE AS IS,
&SUSING(&N) SETC ''                    ELSE SET TO NOT USING
         AGO   .LOOPA1
.*
.* ASSIGN NUMBER TO NEWLY REFERENCED SUBROUTINE
.*
.NEWSUB  AIF   (&#SUB GE 20).ERR#SUB
         AIF   (T'&SUBRTN EQ 'O').ERRSUB
&N       SETA  &#SUB*10                LOWEST SUBCRIPT FOR NEXT SUB - 1
&#SUB    SETA  &#SUB+1                 GET NEW SUBROUTINE NUMBER
&SNAME(&#SUB) SETC '&SUBRTN'           NOTE SUBROUTINE NAME
.*
.* NOTE THE REGISTER ENVIRONMENT
.*
&A       SETA  2                       LOWEST SUPPORTED REG MINUS 1
.LOOPA2  AIF   (&A GE 12).EXIT
&N       SETA  &N+1
&A       SETA  &A+1
&SINUSE(&N) SETB (&INUSE(&A))          NOTE REGISTERS IN USE
&SUSING(&N) SETC '&USING(&A)'          AND DSECT NAMES
         AGO   .LOOPA2
.EXIT    ANOP
         MEXIT
.*
.* ERROR MNOTES
.*
.ERRSUB  MNOTE 12,'SUBROUTINE NAME REQUIRED BUT MISSING'
         MEXIT
.ERRDOWN MNOTE 12,'ONLY DOWNWARD CALLS SUPPORTED'
         MEXIT
.ERR#SUB MNOTE 12,'ONLY 20 SUBROUTINES SUPPORTED'
         MEND
***********************************************************************
*                                                                     *
*  AUTHORS AND DATES:                                                 *
*                                                                     *
*      MIKE AMLING - ORIGINAL CODE                       ??/??/80 N/A *
*                                                                     *
*                                                                     *
*  MAINTENANCE SUMMARY:                                               *
*                                                                     *
*    MIKE AMLING - REVISE TO USE &INUSE(13)               5/ 5/83 MA01*
*                                                                     *
*                                                                     *
***********************************************************************
         MACRO
&NAME    RSUB  &OPERAND
         GBLA  &#SUB
         GBLB  &INUSE(13),&SINUSE(200),&SDOWN(20)                 MA01
         GBLC  &EQU(12),&USING(12),&SNAME(20),&SUSING(200)
         LCLA  &N,&A
&NAME    DS    0H                      DEFINE SYMBOL FOR ENTRY POINT  $
         AIF   ('&OPERAND' EQ '').OPX
         AIF   ('&OPERAND' NE 'RECURSIVE').NORECUR
         ST    R14,0(,RSTACK)          SAVE RETURN ADRESS             $
         SH    RSTACK,=Y(4)            PUSH STACK DOWN                $
.OPX     ANOP
.*
.* FIND THE NUMBER ASSIGNED TO THIS SUBROUTINE.
.*
.LOOPN1  AIF   (&N GE &#SUB).NOCALL
&N       SETA  &N+1
         AIF   ('&SNAME(&N)' NE '&NAME').LOOPN1
.SETUP   AIF   (&SDOWN(&N)).ERRDOWN
.*
.* ESTABLISH THE CALLERS' REGISTER ENVIRONMENT
.*
&SDOWN(&N) SETB 1
&N       SETA  &N*10-10                LOWEST SUBSCRIPT FOR THIS
.*                                     SUBROUTINE MINUS 1
&A       SETA  2                       LOWEST SUPPORTED REG - 1
.LOOPA1  AIF   (&A GE 12).MEXIT
&N       SETA  &N+1
&A       SETA  &A+1
&INUSE(&A) SETB (&SINUSE(&N))          MARK CALLERS' REGISTERS IN USE
&EQU(&A) SETC  ''                      NULL SO RF MACRO CAN'T FREE REG
         AIF   ('&USING(&A)' EQ '').DROPX
         DROP  &A                      DROP REG USED BY PRECEDING CODE
.DROPX   ANOP
&USING(&A) SETC '&SUSING(&N)'          SET TO CALLERS' DSECT NAME
         AIF   ('&USING(&A)' EQ '').LOOPA1
         USING &USING(&A),&A           RE-ESTABLISH CALLERS' USING    $
         AGO   .LOOPA1
.MEXIT   MEXIT
.*
.* ASSIGN A NEW NUMBER TO AN UNCALLED SUBROUTINE
.*
.NOCALL  AIF   ('&NAME' EQ '').ERRNAME
         AIF   (&#SUB GE 20).ERR#SUB
&#SUB    SETA  &#SUB+1                 INCREASE # OF REFERENCED SUBRTNS
&N       SETA  &#SUB
&SNAME(&N) SETC '&NAME'                SAVE NAME IN CASE REFERRED TO
         AGO   .SETUP
.*
.* ERROR MSGS
.*
.NORECUR MNOTE 4,'&OPERAND IS INVALID OPERAND. IGNORED.'          MA01
         AGO   .OPX                                               MA01
.ERRDOWN MNOTE 8,'SUBROUTINE NAME &NAME ALREADY USED'
         MEXIT
.ERRNAME MNOTE 8,'SPECIFY SUBROUTINE NAME AS LABEL'
         MEXIT
.ERR#SUB MNOTE 8,'ONLY 20 SUBROUTINES SUPPORTED'
         MEND
         MACRO
&NAME    RCALL &SUBRTN
         RNOTE &SUBRTN
&NAME    BAL   14,&SUBRTN              LINK TO SUBROUTINE             $
         MEND
         MACRO
&MNAME   CNAEXIT  &RC,&XCTL=,&SPKA=,&EXIT=YES
.*
.*       THIS MACRO PROVIDES A COMPANION EXIT MACRO TO
.*       THE ENTRY MACRO CNAENTER.
.*
.*
.*       DECLARE GLOBAL SYMBOLS USED FOR CNAENTER AND CNAEXIT
.*
         GBLA  &GBLREG#            NUMBER OF BASE REGISTERS
         GBLB  &GBLACTV            MACRO HAS BEEN INVOKED BEFORE
         GBLC  &GBLREGS(5)         BASE REGISTER VALUES
         GBLC  &GBLUSNG            BASE REGS WITH COMMAS FOR USING
         GBLC  &GBLRENT            RENT OPTION
         GBLC  &GBLSAVE            SNAME OPTION
         GBLC  &GBLSTRG            STORAGE OPTION
         GBLC  &GBLSTCK            SIZE OF STACK
         GBLC  &GBLCNAM            CSECT NAME
         GBLC  &GBLCESP            SUBPOOL FOR SAVEAREA FREEMAIN
         GBLC  &GBLCESV            SVC TYPE FOR RENT=(NEWSTACK,TYPE)
.*
.*       LOCAL VARIABLES
.*
         LCLA  &LCLBASE            NUMBER OF REG TO GEN R.C. HOLD
         LCLA  &LCLLOOP            LOOP CONTROL WHILE GENNING ABOVE
         LCLC  &LCLLABL            STATEMENT LABEL
         LCLC  &LCLRREG            CHARACTER FORM OF LCLBASE WITH R
         LCLC  &LCLXNAM            NAME TO XCTL TO
         LCLC  &LCLXLST            NAME OF XCTL PARM LIST
         LCLC  &LCLXREG            NAME OF REGISTER FOR MODULE ADDR
.*
.*       CHECK THE XCTL= OPERAND
.*       IT CANNOT BE USED WITH THE RC OPERAND
.*       THERE ARE THREE FORMS OF THE OPERAND
.*       XCTL=MODULE-NAME   (OBSOLETE VERSION)
.*       XCTL=(SF,PLIST-NAME,ROUTINE-ADDRESS-LOCATION)
.*       XCTL=(I,MODULE-NAME)
.*
         AIF   ('&XCTL' EQ '').XCTL1OK          NO XCTL= OPERAND
         AIF   ('&RC' EQ '').XCTL1A             NO RC OPERAND
         MNOTE 4,'RETURN CODE AND XCTL= INCOMPATIBLE. RETURN CODE IGNORE
               ED'
.XCTL1A  AIF   (N'&XCTL NE 1).XCTL1B
&LCLXNAM SETC  '&XCTL'                          SET MODULE NAME
         AGO   .XCTL1OK                         AND END CHECKS
.XCTL1B  AIF   ('&XCTL(1)' NE 'I').XCTL1C       IS IT INLINE PLIST
&LCLXNAM SETC  '&XCTL(2)'                       SET MODULE NAME
         AIF   (N'&XCTL NE 2).XCTL1E1           GENERATE ERROR MESSAGE
         AGO   .XCTL1OK
.XCTL1C  AIF   ('&XCTL(1)' NE 'SF' AND '&XCTL(1)' NE 'E').XCTL1E2
         AIF   ('&XCTL(2)' EQ '').XCTL1D        CHECK IF XCTL PLIST
&LCLXLST SETC  '&XCTL(2)'                       SET XCTL PARM LIST ADDR
.XCTL1D  AIF   ('&XCTL(3)' EQ '').XCTL1E        IS A REGISTER SET
&LCLXREG SETC  '&XCTL(3)'                       SET REGISTER NAME
.XCTL1E  AIF   (N'&XCTL GT 3).XCTL1E3           TOO MANY OPERANDS
         AGO   .XCTL1OK                         END CHECKS
.XCTL1E1 MNOTE 4,'XCTL=(I,PLIST-NAME) MUST HAVE 2 OPERANDS'
         AGO   .XCTL1OK
.XCTL1E2 MNOTE 4,'XCTL= FORMS ARE I AND E. XCTL=&XCTL(1) INVALID'
         AGO   .XCTL1OK
.XCTL1E3 MNOTE 4,'XCTL= TOO MANY OPERANDS'
.XCTL1OK ANOP
.*
.*       CHECK USAGE OF SPKA OPERAND
.*
         AIF   ('&SPKA' EQ '').SPKA1OK    NO SPKA= OPERAND
         AIF   ('&GBLCESV' NE '').SPKA1OK MUST BE RENT=(NEWSTACK,X)
         MNOTE 4,'SPKA=&SPKA VALID ONLY FOR RENT=(NEWSTACK,NSL)'
.SPKA1OK ANOP
.*
.***     CHECK USAGE OF THE EXIT=NO OPERAND
.*
         AIF   ('&EXIT' EQ 'YES').EXITOK
         AIF   ('&EXIT' EQ 'NO').EXITC1
         MNOTE 8,'EXIT=&EXIT VALUE INVALID'
.EXITC1  ANOP
         AIF   ('&XCTL' EQ '').EXITC2
         MNOTE 8,'EXIT=NO INVALID WITH XCTL=&XCTL'
.EXITC2  AIF   ('&RC' EQ '').EXITOK
         MNOTE 8,'EXIT=NO INVALID WITH RETURN CODE OPERAND &RC'
.EXITOK  ANOP
.*
.*       RESUME CSECT IF WE HAVE LEFT IT
.*
         AIF   ('&GBLCNAM' EQ '&SYSECT').READY
&GBLCNAM CSECT ,                   RESUME ORIGINAL CSECT
         SPACE 2
.READY   ANOP
.*
.*       SET STATEMENT LABEL
.*
&LCLLABL SETC  '&MNAME'
.*
.*       SET UP GLOBALS TO CAUSE DEFAULT IF CNAENTER NOT USED
.*
         AIF   (&GBLACTV).ACTIVE
&GBLRENT SETC  'NO'
&GBLSAVE SETC  'SAVEAREA'
         MNOTE 4,'CNAENTER NOT USED - WILL GENERATE FOR NON-REENTRANT'
.ACTIVE  ANOP
.*
.*       THERE ARE TWO FUNDAMENTAL CASES - 1 REQUIRING A FREEMAIN
.*       AND THE OTHER NOT.  THE FIRST CASE OCCURS WHEN &GBLRENT
.*       IS 'YES' OR 'NEWSTACK'.  THE OTHER OCCURS WHEN &GBLRENT
.*       IS 'NO' 'NOSAVE' 'STACK' OR 'COM'.  FIRST SECTION OF MACRO
.*       DETERMINES WHICH CASE IS PRESENT.
.*
         AIF   ('&GBLRENT' EQ 'YES' OR '&GBLRENT' EQ 'NEWSTACK').FREE
         AIF   ('&XCTL' NE '').GENXCTL
.*
.*       NOW GET THE RETURN CODE INTO R15 IF IT IS NOT IN 15 OR A
.*       SELF-DEFINING TERM.
.*
         AIF   ('&EXIT' EQ 'NO').NFRCSET    CASE - EXIT=NO
         AIF   ('&RC' EQ '0').NFRCSET       CASE - CNAEXIT 0 OPTIMIZE
         AIF   ('&XCTL' NE '').NFRCSET      CASE - XCTL OPERAND PRESENT
         AIF   ('&RC' EQ '').NFRCSET        CASE - NULL DEFAULT 0
         AIF   ('&RC' EQ '(R15)').NFRCSET   CASE - RC PRESET
         AIF   ('&RC' EQ '(15)').NFRCSET    CASE - RC PRESET
         AIF   ('&RC'(1,1) EQ '(').NFREG    CASE - REG FORM
         AIF   (T'&RC EQ 'N').NFRCSET       CASE - SELF-DEFINING
&LCLLABL L     R15,&RC             LOAD RETURN CODE VALUE
&LCLLABL SETC  ''                  NULIFY LABEL COPY
         AGO   .NFRCSET
.NFREG   ANOP
&LCLLABL LR    R15,&RC(1)          LOAD RETURN CODE VALUE
&LCLLABL SETC  ''
.*
.***     R15 LOADED UNLESS SR OR LA TO BE GENERATED
.*
.NFRCSET ANOP
.*
.*       RESTORE REGISTER 13 FOR NON-REENTRANT CASE
.*
         AIF   ('&GBLRENT' EQ 'NOSAVE').NFLR14
&LCLLABL L     R13,&GBLSAVE+4      RESTORE CALLER'S SAVE AREA
&LCLLABL SETC  ''
.*
.***     REENTER HERE FROM REENTRANT CASE
.*
.NFLR14  ANOP
         AIF   ('&RC' EQ '').NFLR14A           SKIP SUBSTRING IF NO PRM
         AIF   ('&RC'(1,1) EQ '(').NFLRN0      ALREADY LOADED IF REG.
         AIF   ('&EXIT' EQ 'NO' OR '&XCTL' NE '').NFLRN0
         AIF   ('&RC' NE '' AND T'&RC NE 'N').NFLRN0
.NFLR14A ANOP
&LCLLABL LM    R14,R12,12(R13)     RESTORE REGISTERS
         AIF   ('&RC' EQ '' OR '&RC' EQ '0').NFLRY0
         LA    R15,&RC             SET RETURN CODE NOT ZERO
         AGO   .NFLRN0A
.NFLRY0  ANOP
         SR    R15,R15             SET RETURN CODE ZERO
         AGO   .NFLRN0A
.*
.***     NEXT 2 INSTRUCTIONS IF RETURN CODE WAS LEFT IN R15
.*
.NFLRN0  ANOP
&LCLLABL L     R14,12(,R13)        RESTORE RETURN ADDRESS
         LM    R0,R12,20(R13)      RESTORE REMAINING REGISTERS
.NFLRN0A ANOP
         MVI   12(R13),X'FF'       FLAG AS RETURNED FOR SNAP SVC
         AIF   ('&EXIT' EQ 'NO').EXITNFN
         BR    R14                 RETURN TO CALLER
.EXITNFN ANOP
         MEXIT
.*
.*       REENTRANT CASE - FIRST GET RETURN CODE INTO A REGISTER
.*       WHICH IS NOT R15 AND IS NOT A BASE REGISTER.  DETERMINE
.*       WHICH REGISTER FIRST
.*
.FREE    AIF   ('&GBLCESV' NE '').GENNSL GO GENERATE SYSTEM CONV.
         AIF   ('&XCTL' NE '').FRSET   AVOID RETURN CODE LOGIC
&LCLRREG SETC  '&RC(1)'
         AIF   ('&RC' EQ '').FRNEED
         AIF   ('&RC'(1,1) EQ '(' AND '&RC' NE '(R15)').FRSET
.FRNEED  ANOP
&LCLBASE SETA  2
.FRCHECK ANOP
&LCLLOOP SETA  1
&LCLRREG SETC  'R&LCLBASE'
.FRLOOP  ANOP
         AIF   ('&LCLRREG' EQ '&GBLREGS(&LCLLOOP)').FRRETRY
&LCLLOOP SETA  &LCLLOOP+1
         AIF   (&LCLLOOP LE &GBLREG#).FRLOOP
         AGO   .FRLRC
.FRRETRY ANOP
&LCLBASE SETA  &LCLBASE+1
         AGO   .FRCHECK
.FRLRC   ANOP
         AIF   ('&EXIT' EQ 'NO').FRLR SAVE R15 AGAINST FREEMAIN
         AIF   ('&RC' EQ '0').FRSET  CASE - CNAEXIT 0 OPTIMIZED
         AIF   ('&XCTL' NE '').FRSET        CASE - XCTL= NO R15
         AIF   ('&RC' EQ '').FRSET          CASE - NULL DEFAULTS TO 0
         AIF   ('&RC'(1,1) EQ '(').FRLR     CASE - REGISTER OPERAND
         AIF   (T'&RC EQ 'N').FRSET         CASE - GENERATE LA INSTRUCT
&LCLLABL L     &LCLRREG,&RC        LOAD RETURN CODE VALUE
&LCLLABL SETC ''
         AGO   .FRSET
.FRLR    ANOP
&LCLLABL LR    &LCLRREG,&RC(1)     SAVE RETURN CODE OVER FREEMAIN
&LCLLABL SETC  ''
.FRSET   ANOP
&LCLLABL LR    R1,R13              SET ADDRESS TO FREE
&LCLLABL SETC  ''
         L     R13,&GBLSAVE+4      GET CALLER'S SAVE AREA
         AIF   ('&GBLRENT' EQ 'NEWSTACK').FRSTACK
 DC 0C'  FREEMAIN R,A=(1),LV=&GBLSTRG,SP=&GBLCESP' FREEMAIN ISSUED
         FREEMAIN R,A=(1),LV=&GBLSTRG,SP=&GBLCESP
         AGO   .NFSET15
.FRSTACK ANOP
 DC 0C'  FREEMAIN R,A=(1),LV=&GBLSTCK,SP=&GBLCESP' FREEMAIN ISSUED
         FREEMAIN R,A=(1),LV=&GBLSTCK,SP=&GBLCESP
.NFSET15 AIF   ('&XCTL' NE '').GENXCTL     GENERATE XCTL EXIT CODE
         AIF   ('&RC' EQ '' OR '&RC' EQ '0').NFLR14
         AIF   ('&RC'(1,1) EQ '(').FRSET15
         AIF   (T'&RC EQ 'N').NFLR14
.FRSET15 ANOP
         LR    R15,&LCLRREG        SET RETURN CODE INTO PROPER REG
         AGO   .NFLR14
.*
.*       GENERATE FOR RENT=(NEWSTACK,NSL),SPKA=
.*
.GENNSL  ANOP
&LCLLABL CNOP  0,4
&LCLLABL SETC  ''
         L     R0,*+8              LOAD SUBPOOL AND LENGTH
         B     *+8                 SKIP INLINE CONSTANT
         DC    AL1(&GBLCESP),AL3(&GBLSTCK)
         LA    R1,0(,R13)          POINT AT STACK
         LM    R2,R14,80(R13)      RESTORE OPEN/CLOSE/EOV REGS
         SVC   10                  ISSUE FREEMAIN SVC DIRECTLY
         AIF   ('&SPKA' EQ '').NSL1B
         SPKA  &SPKA               RETURN TO SUPERVISOR KEY
.NSL1B   AIF   ('&EXIT' EQ 'NO').MEND  IF EXIT=NO, GET OUT QUICKLY
         AIF   ('&LCLXREG' EQ '').NSL1C SKIP BRANCH TEST IF NOT REQ
         ICM   R15,15,&LCLXREG     CHECK FOR EP IN THIS LOAD MODULE
         BNZR  R15                 AND GO TO IT IF PRESENT
.NSL1C   AIF   ('&LCLXNAM' NE '').XCTL2B GEN INLINE LIST XCTL
   DC 0C'XCTL  SF=(E,&LCLXLST)'
         XCTL  SF=(E,&LCLXLST)
         MEXIT
.*
.*       GENERATE ERROR MESSAGE FOR RENT=(NEWSTACK,SVC6)
.*
.SVC6GEN AIF   ('&GBLCESV' NE 'SVC6').SVC5GEN TRY SVC15
         MNOTE 12,'RENT=(NEWSTACK,SVC6) NOT SUPPORTED BY CNAEXIT'
         MEXIT
.*
.*       GENERATE ERROR MESSAGE FOR RENT=(NEWSTACK,SVC15)
.*
.SVC5GEN AIF   ('&GBLCESV' NE 'SVC15').SVCXGEN TRY NEW PARM
         MNOTE 12,'RENT=(NEWSTACK,SVC15) NOT SUPPORTED BY CNAEXIT'
         MEXIT
.*
.*       GENERATE ERROR MESSAGE FOR UNRECOGNIZED &GBLCESV VALUE'
.*
.SVCXGEN MNOTE 12,'RENT=(NEWSTACK,&GBLCESV) NOT SUPPORTED BY CNAEXIT'
         MEXIT
.*
.*       GENERATE XCTL=(I,MODULE-NAME) VERSION OF XCTL
.*
.GENXCTL LM    R14,R12,12(R13)     RESTORE CALLERS REGISTERS
.XCTL2B  CNOP  2,4                 INSURE CONSTANT ALIGNMENT
         BALR  R15,0               SET NEW ADDRESSABILITY
         PUSH  USING               SAVE PREVIOUS ENVIRONMENT
         DROP  ,                   AVOID ADDRESSING PROBLEMS
         USING *,R15               AND TELL THE ASSEMBLER THE TRUTH
         L     R15,*+16            GET ADDRESS OF NEXT ROUTINE
         LTR   R15,R15             IS IT IN THIS MODULE
         BNZR  R15                 YES, GO TO IT DIRECTLY
         BALR  R15,0               NO, RESET ADDRESSABILITY
         USING *,R15               TELL THE ASSEMBLER AGAIN
         LA    R15,*+10            POINT AT XCTL SF= LIST
         XCTL  SF=(E,(15))         AND GO TO PROGRAM WITH ASSIST
         WXTRN &LCLXNAM            DECLARE AS WEAK EXTERNAL REFERENCE
         DC    A(&LCLXNAM)         IF LINKEDITED IN
         XCTL  EP=&LCLXNAM,SF=L    BUILD XCTL PARAMETER LIST
         POP   USING               GET USERS ENVIRONMENT BACK
.MEND    ANOP                        WAY TO BRANCH OUT
         MEND
         MACRO
&MNAME   CNAENTER  &BASES,         BASE REGISTER LIST                  X
               &CBASE=DR12,        REGISTER ADDRESSING COMMON          X
               &ENTRY=DYES,        GENERATE ENTRY STATEMENT (WITH NAME)X
               &ID=DYES,           FULL, NONE OR DATELESS ID           X
               &PARM=DR2,          WHERE TO PUT PARM LIST POINTER      X
               &PLOAD=,            HOW TO SET UP PARAMETER POINTERS    X
               &RENT=DYES,         REENTRANCY OR NOT AND TYPE          X
               &SAVE=YES,          SHOULD REGISTERS BE SAVED           X
               &SCLEAR=DNO,        SHOULD SAVE AREA BE CLEARED?        X
               &SNAME=,            NAME OF SAVE/WORK AREA              X
               &SP=,               SUBPOOL FOR SAVE AREA               X
               &SPKA=,             SET PROTECT KEY                     X
               &STACK=D2048,       SIZE OF STACK FOR NEWSTACK OPTION   X
               &STORAGE=DWORKLEN,  LENGTH OF STORAGE TO OBTAIN         X
               &WCLEAR=DNO,        SHOULD WORK AREA BE CLEARED?        X
               &WTG=D              WHERE TO GO FIELD NAME
.*
.*       DECLARE GLOBAL SYMBOLS USED FOR MULTIPLE INVOCATIONS AND
.*       THE CNAEXIT MACRO
.*
         GBLA  &GBLREG#            NUMBER OF BASE REGISTERS
         GBLA  &GBLQCNT            NUMBER OF Q ADDRESS CONSTANTS
         GBLB  &GBLACTV            MACRO HAS BEEN INVOKED BEFORE
         GBLB  &GBLSCLR            CLEAR SAVE AREA OPTION
         GBLB  &GBLWCLR            WORK AREA CLEAR OPTION
         GBLC  &GBLREGS(5)         BASE REGISTER VALUES
         GBLC  &GBLUSNG            BASE REGS WITH COMMAS FOR USING
         GBLC  &GBLID              ID OPTION
         GBLC  &GBLPARM            PARM OPTION
         GBLC  &GBLRENT            RENT OPTION
         GBLC  &GBLRSVE            SAVE REGISTERS OPTION (YES OR NO)
         GBLC  &GBLSAVE            SNAME OPTION
         GBLC  &GBLSTRG            STORAGE OPTION
         GBLC  &GBLSTCK            SIZE OF STACK
         GBLC  &GBLCNAM            CSECT NAME
         GBLC  &GBLQNAM(20)        UP TO 20 Q NAMES
         GBLC  &GBLWTG             WTG OPERAND OF 1ST ENTRY
         GBLC  &GBLCBAS            COMMON BASE REGISTER
         GBLC  &GBLCESP            SUBPOOL FOR GETMAIN AND FREEMAIN
         GBLC  &GBLCESV            SVC TYPE - SVCR6, SVCR15, NSL, NULL
         GBLC  &CNASPFL            LEVEL NUMBER FROM SPF LIBRARY
         GBLC  &CNASPFD            DATE OF LAST MODIFICATION
         GBLC  &CNASPFU            USERID OF LAST UPDATER
.*
.*       LOCAL SYMBOLS USED
.*
         LCLA  &LCLREG#            NUMBER OF ENTRIES IN &BASES
         LCLA  &LCLSUB1            DESTINATION SUBSCRIPT
         LCLA  &LCLSUB2            SOURCE SUBSCRIPT
         LCLA  &LCLIDSZ            SIZE OF ID CONSTANTS
         LCLA  &LCLIDLN            &LCLIDSZ-1
         LCLA  &LCLCONS            LENGTH OF ALL CONSTANTS
         LCLA  &LCLFILL            SIZE TO ALIGN SAVE AREA
         LCLA  &LCLWORK            ARITHMETIC WORK
         LCLA  &LCLPLUS            OFFSET CALCULATIONS
         LCLA  &LCLOFFS            OFFSET TO ENTRY OFFSET
         LCLA  &LCLSTRL            OFFSET TO STORAGE VALUE FOR STACKING
         LCLA  &LCLPRML            NUMBER OF VALUES TO PLOAD OPERAND
         LCLB  &LCLOFF             ON FOR 2ND-NTH ENTRIES
         LCLB  &LCLRENT            IS SOME FORM OF REENTRANCY IN?
         LCLB  &LCLENTR            IS ENTRY STATEMENT NEEDED?
         LCLB  &LCLSCLR            CLEAR SAVE AREA THIS ENTRY?
         LCLB  &LCLWCLR            CLEAR WORK AREA THIS ENTRY?
         LCLC  &LCLENAM            NAME FOR ENTRY STATEMENT
         LCLC  &LCLPARM            NAME FOR KEEPING R1
         LCLC  &LCLCHAR            CHARACTER WORK FIELD
         LCLC  &LCLSTRG            STORAGE THIS TIME THHROUGH
         LCLC  &LCLID              ID OPTION FOR THIS CALL
         LCLC  &LCLSVCT            SVC TYPE - SVCR6, SVCR15, NSL, NULL
         LCLC  &LCLTBAS            ENTRY POINT BASE FOR FIRST INSTRS.
.*
.*       IF THIS IS THE FIRST ENTRY, EDIT THE VALUES GIVEN
.*
         AIF   (&GBLACTV).NTH
&GBLACTV SETB  (1)               SET FOR NEXT TIME IN
&GBLCNAM SETC  '&SYSECT'           SET CSECT NAME
.*
.*       EDIT THE REENTRANCY OPTION  (FIRST SUBPARAMETER)
.*
         AIF   ('&RENT(1)' EQ 'DYES').DRENT
&LCLCHAR SETC  '&RENT(1)'
&LCLRENT SETB  ('&LCLCHAR' EQ 'YES'   OR '&LCLCHAR' EQ 'NEWSTACK' OR   *
                '&LCLCHAR' EQ 'STACK' OR '&LCLCHAR' EQ 'NOSAVE'   OR   *
                '&LCLCHAR' EQ 'COM')
         AIF   (&LCLRENT OR '&LCLCHAR' EQ 'NO').RENTOK
         MNOTE 4,'&RENT IS AN INVALID REENTRANCY OPTION - YES USED.'
.DRENT   ANOP
&GBLRENT SETC  'YES'
&LCLRENT SETB  (1)
         AGO   .RENTOVR
.RENTOK  ANOP
&GBLRENT SETC  '&RENT(1)'
.*
.*       EDIT THE WTG OPERAND IF &GBLRENT=COM
.*
         AIF   ('&GBLRENT' NE 'COM').RENTOVR
         AIF   ('&WTG' EQ 'D').RENTWTX     NO WTG TYPE PROCESSING
&GBLWTG  SETC  '&WTG'
         AIF   ('&GBLWTG' NE '').RENTWTX
         MNOTE *,'WTG OPERAND NULLIFIED - NO WTG CODE GENERATED'
.RENTWTX ANOP
         AIF   ('&CBASE' EQ 'DR12').DEFCBAS
         AIF   ('&CBASE' NE '').ASGNCBS
         MNOTE 8,'COMMON BASE NEEDED TO RELOCATE WORK AREA - R12 USED.'
.DEFCBAS ANOP
&GBLCBAS SETC  'R12'
         AGO   .RENTOVR
.ASGNCBS ANOP
&GBLCBAS SETC  '&CBASE'
.RENTOVR ANOP
.*
.*       EDIT THE SECOND RENT OPERAND.  THIS IS VALID ONLY IF THE
.*       RENT=NEWSTACK OPERAND IS CODED, AND MUST HAVE ONE OF THE
.*       VALUES 'SVCR6' 'SVCR15' 'NSL' OR NULL.
.*
&LCLTBAS SETC  'R15'                           ASSUME R15 AS ENTRY
         AIF   ('&RENT(2)' EQ '').RNT2END      NO SVC OPTION CODED
         AIF   ('&RENT(1)' NE 'NEWSTACK').RNT2E1 ERROR IF NOT NEWSTACK
         AIF   ('&RENT(2)' NE 'SVCR6' AND '&RENT(2)' NE 'SVCR15' AND   X
               '&RENT(2)' NE 'NSL').RNT2E2     NOT VALID ENTRYS
&GBLCESV SETC  '&RENT(2)'                      SET TYPE OF SVC ENTRY
&LCLSVCT SETC  '&RENT(2)'                      SET IT IN LOCAL
         AIF   ('&LCLSVCT' NE 'SVCR6').RNT2END R15 IS RIGHT
&LCLTBAS SETC  'R6'                            SET R6 AS ENTRY BASE
         AGO   .RNT2END
.RNT2E1  MNOTE 8,'SECOND RENT= OPERAND ONLY VALID WITH NEWSTACK'
         AGO   .RNT2END
.RNT2E2  MNOTE 8,'SECOND RENT= OPERAND MUST BE SVCR6, SVCR15, OR NSL'
.RNT2END ANOP
.*
.*       EDIT THE SPKA OPERAND.  IT IS ONLY VALID IF SECOND RENT
.*       OPTION IS USED.  IT IS USED ONLY IF SPECIFIED ON THE MACRO
.*
         AIF   ('&SPKA' EQ '').RNT3END
         AIF   ('&GBLCESV' NE '').RNT3END  SKIP IF 2ND RENT SPEC'D
         MNOTE 4,'SPKA= OPERAND NOT VALID IF 2ND RENT OPTION OMITTED'
.RNT3END ANOP
.*
.*       EDIT THE SAVE OPERAND.  THIS MUST BE YES UNLESS RENT=
.*       NO OR NOSAVE WAS ENTERED.  THEN IT MAY BE NO.
.*
&GBLRSVE SETC  'YES'                FORCE DEFAULT VALUE
         AIF ('&SAVE' EQ 'YES').RSAVEOK
         AIF ('&SAVE' NE 'NO').RSAVEX1
         AIF ('&GBLRENT' EQ 'NO' OR '&GBLRENT' EQ 'NOSAVE').RSAVEOK
         MNOTE 8,'SAVE=NO ONLY ALLOWED WITH RENT=NO OR RENT=NOSAVE'
         AGO   .RSAVEXL
.RSAVEX1 MNOTE 8,'SAVE= MUST BE YES OR NO'
         AGO   .RSAVEXL
.RSAVEOK ANOP
&GBLRSVE SETC  '&SAVE'
.RSAVEXL ANOP
.*
.*       EDIT THE STACK OPERAND - SHOULD BE D2048 UNLESS
.*       &GBLRENT=NEWSTACK.  IN THAT CASE, SET &GBLSTCK
.*       TO VALUE OF STACK OPERAND.  MULTIPLY BY 1024 IF
.*       ALL NUMERIC EXCEPT TERMINAL K.
.*
         AIF   ('&GBLRENT' EQ 'NEWSTACK').NSEDIT
         AIF   ('&STACK' EQ 'D2048').STACKX
         MNOTE 4,'STACK= IGNORED SINCE RENT=NEWSTACK NOT SPECIFIED'
         AGO   .STACKX
.NSEDIT  ANOP
&LCLWORK SETA  K'&STACK
         AIF   ('&STACK'(&LCLWORK,1) EQ 'K' AND &LCLWORK GT 1).KVAL
         AIF   ('&STACK' NE 'D2048').ASGNSTK
&GBLSTCK SETC  '2048'
         AGO   .STACKX
.KVAL    ANOP
&LCLCHAR SETC  '&STACK'(1,&LCLWORK-1)
.KVALOOP ANOP
&LCLWORK SETA  &LCLWORK-1
         AIF   ('&LCLCHAR'(&LCLWORK,1) LT '0').ASGNSTK
         AIF   (&LCLWORK GT 1).KVALOOP
&GBLSTCK SETC  '&LCLCHAR*1024'
         AGO   .STACKX
.ASGNSTK ANOP
&GBLSTCK SETC  '&STACK'
.STACKX  ANOP
.*
.*       EDIT THE BASE REGISTER SET AND SET UP GBLREG#, GBLREGS AND
.*       GBLUSNG.
.*
&LCLREG# SETA  N'&BASES
&GBLREG# SETA  &LCLREG#
&LCLSUB1 SETA  1
&LCLSUB2 SETA  1
         AIF   (&LCLRENT).OK#
&GBLREG# SETA  &GBLREG#+1          INCREMENT FOR R13 ADDITION
&GBLREGS(1) SETC 'R13'
&LCLSUB1 SETA  2
.OK#     ANOP
         AIF   (&GBLREG# GT 0).OKCOPY
         MNOTE 8,'NO BASE REGISTERS SPECIFIED - WILL USE R11'
&GBLREG# SETA  1
&GBLREGS(1) SETC 'R11'
.OKCOPY  AIF   (&LCLSUB2 GT &LCLREG#).COPUSNG
&GBLREGS(&LCLSUB1) SETC '&BASES(&LCLSUB2)'
&LCLSUB1 SETA  &LCLSUB1+1
&LCLSUB2 SETA  &LCLSUB2+1
         AGO   .OKCOPY
.COPUSNG ANOP
&GBLUSNG SETC  ',&GBLREGS(1)'
         AIF   (&GBLREG# LE 1).ID
&LCLSUB1 SETA  2
         AIF   ('&LCLSVCT' NE '').ERRSVC1
.UCOPY   AIF   (&LCLSUB1 GT &GBLREG#).ID
&GBLUSNG SETC  '&GBLUSNG,&GBLREGS(&LCLSUB1)'
&LCLSUB1 SETA  &LCLSUB1+1
         AGO   .UCOPY
.ERRSVC1 MNOTE 4,'ONLY 1 BASE REGISTER SUPPORTED FOR SVC TYPE &LCLSVCT'
.*
.*       EDIT THE IDENTIFICATION OPTION - DEFAULT IS DYES(YES)-IF SPEC
.*       IS NOT YES, NO, NODATE OR SHORT, SET TO SHORT
.*
.ID      AIF   ('&ID' EQ 'DYES').DID
         AIF   ('&ID' EQ 'YES').IDOK
         AIF   ('&ID' EQ 'NO').IDOK
         AIF   ('&ID' EQ 'NODATE').IDOK
         AIF   ('&ID' EQ 'SHORT').IDOK
         MNOTE 4,'&ID IS AN INVALID IDENTIFICATION OPTION - SHORT USED'
&GBLID   SETC  'SHORT'
&LCLID   SETC  'SHORT'
         AGO   .PRM
.DID     ANOP
&GBLID   SETC  'YES'
&LCLID   SETC  'YES'
         AGO   .PRM
.IDOK    ANOP
&GBLID   SETC  '&ID'
&LCLID   SETC  '&ID'
.*
.*       EDIT THE PARM OPERAND - SET R2 IF OMITTED
.*
.PRM     AIF   ('&PARM' EQ 'DR2').DPARM
         AIF   ('&PARM' NE '').SETPRM
         MNOTE *,'INPUT PARAMETER LIST POINTER WILL BE IN R2'
.DPARM   ANOP
&GBLPARM SETC  'R2'
&LCLPARM SETC  'R2'
         AGO   .ENT
.SETPRM  ANOP
&GBLPARM SETC  '&PARM'
&LCLPARM SETC  '&PARM'
.*
.*       EDIT THE ENTRY= OPERAND - VALID VALUES ARE YES, NO AND
.*       (YES,NAME) - IF YES, &MNAME MUST NOT BE NULL - SET NO
.*       IF INVALID VALUE OR YES AND NO &MNAME
.*
.ENT     ANOP
&LCLENAM SETC  '&MNAME'                  SET LOCAL NAME TO MACRO
         AIF   ('&MNAME' NE '').ENTNOK   YES, LET IT DEFAULT
&LCLENAM SETC  '&SYSECT'                 MUST BE AT START OF MACRO
.ENTNOK  AIF   ('&ENTRY' EQ 'DYES').EYES
         AIF   ('&ENTRY' EQ 'YES').EYES
         AIF   ('&ENTRY' EQ 'NO').SNAME
         AIF   ('&ENTRY(1)' EQ 'YES').ENAME
         MNOTE 4,'&ENTRY INVALID ENTRY OPTION - NO USED'
         AGO   .SNAME
.EOMIT   MNOTE 8,'ENTRY NAME OMITTED - WILL USE NAME FIELD OF CNAENTER X
               MACRO IF PRESENT'
.EYES    AIF   ('&MNAME' EQ '').ENONE
&LCLENAM SETC  '&MNAME'
&LCLENTR SETB  (1)
         AGO   .SNAME
.ENAME   AIF   ('&ENTRY(2)' EQ '').EOMIT
&LCLENAM SETC  '&ENTRY(2)'
&LCLENTR SETB  (1)
         AGO   .SNAME
.ENONE   MNOTE 8,'ENTRY=YES CANCELLED BECAUSE THERE IS NO NAME ON THE MX
               ACRO'
.*
.*       SET THE GLOBAL SAVEVAL TO BE SAVE/WORK AREA NAME FROM
.*       SNAME= OPERAND.  DEFAULT TO WORKAREA OR SAVEAREA
.*       DEPENDING ON REENTRANCY OPTION
.*
.SNAME   AIF   ('&SNAME' EQ '').SNDEF
&GBLSAVE SETC  '&SNAME'
         AGO   .QCONCK
.SNDEF   ANOP
&GBLSAVE SETC  'WORKAREA'
         AIF   (&LCLRENT).QCONCK
&GBLSAVE SETC  'SAVEAREA'
.QCONCK  AIF   ('&GBLRENT' NE 'COM').SCLR
         CNADXD &GBLSAVE
&GBLSAVE SETC  '&GBLQNAM(&GBLQCNT)'
.*
.*       SET THE GLOBAL CLEARS
.*
.SCLR    ANOP
&GBLSCLR SETB  ('&SCLEAR' EQ 'YES')
&LCLSCLR SETB  (&GBLSCLR)
.*
.*       SET THE GLOBAL CLEARW
.*
&GBLWCLR SETB  ('&WCLEAR' EQ 'YES')
&LCLWCLR SETB  (&GBLWCLR)
.*
.*       SET GLOBAL STRGVAL FROM STORAGE= - NULL ALLOWED FOR NON-RENT
.*
&GBLSTRG SETC  'WORKLEN'
&LCLSTRG SETC  'WORKLEN'
         AIF   ('&STORAGE' EQ 'DWORKLEN').EDITSP
&GBLSTRG SETC  '&STORAGE'
&LCLSTRG SETC  '&STORAGE'
         AIF   ('&GBLSTRG' NE '').EDITSP
         AIF   (NOT &LCLRENT).CALC
         AIF   ('&RENT(1)' EQ 'NOSAVE').EDITSP
&GBLSTRG SETC  'WORKLEN'
&LCLSTRG SETC  'WORKLEN'
         MNOTE 8,'STORAGE= NULLIFIED BUT VALUE REQUIRED - WORKLEN USED'
.*
.*  EDIT THE SP= PARAMETER (SUBPOOL = )
.*
.EDITSP  ANOP
&GBLCESP SETC '0'            DEFAULT IT TO SUBPOOL 0
         AIF  ('&SP' EQ '').CALC  ACCEPT THE DEFAULT
&GBLCESP SETC '&SP'          SET THE OPERAND VALUE
         AGO  .CALC
.*
.*
.*
.*       EDIT SUPPLIED OPERANDS AGAINST GLOBAL VALUES USED IN FIRST
.*       INVOCATION OF CNAENTER
.*
.*
.*
.NTH     ANOP
.*
.*       SET UP LOCAL ITEMS TO MATCH GLOBALS FOR FIRST APPROXIMATION
.*
&LCLSCLR SETB  (&GBLSCLR)
&LCLWCLR SETB  (&GBLWCLR)
&LCLPARM SETC  '&GBLPARM'
&LCLID   SETC  '&GBLID'
&LCLSTRG SETC  '&GBLSTRG'
&LCLOFF  SETB  (1)
&LCLSVCT SETC  '&GBLCESV'             SVC TYPE
&LCLTBAS SETC  'R15'                  TEMPORARY BASE IS R15
         AIF   ('&LCLSVCT' NE 'SVCR6').RNT2L1
&LCLTBAS SETC  'R6'                   TEMPORARY BASE IS R6 FOR SVCR6
.RNT2L1  ANOP
.*
.*       IGNORE ANY DESIGNATION OF BASE REGISTERS
.*
         AIF   (N'&BASES EQ 0).RENTR
         MNOTE 4,'BASE REGISTERS IGNORED - WILL USE SAME AS ON 1ST CALLX
                TO CNAENTER - &GBLREGS(1) IS FIRST BASE'
.*
.*       THE ENTRY ATTRIBUTE MUST BE ASSUMED ELSE WHY ANOTHER ENTRY?
.*
.RENTR   AIF   ('&ENTRY' EQ 'DYES' OR '&ENTRY' EQ 'YES').RSETM
         AIF   ('&ENTRY(2)' NE '').RSET2
         MNOTE 8,'&ENTRY INVALID FOR THIS CALL - YES USED AND NAME ON MX
               ACRO WILL BE ENTRY NAME'
.RSETM   AIF   ('&MNAME' NE '').RSETM2
         MNOTE 8,'MACRO NAME REQUIRED FOR ENTRY POINT - ####$$$$ USED'
&LCLENAM SETC  '####$$$$'
         AGO   .RENTSET
.RSET2   ANOP
&LCLENAM SETC  '&ENTRY(2)'
         AGO   .RENTSET
.RSETM2  ANOP
&LCLENAM SETC  '&MNAME'
.RENTSET ANOP
&LCLENTR SETB  (1)
.*
.*       ID VALUE RESET TO CONTAIN NO DATE SPECIFICATION IF YES
.*       CURRENTLY IN EFFECT
.*
         AIF   ('&LCLID' NE 'YES').CKIDOVR
&LCLID   SETC  'NODATE'
.CKIDOVR AIF   ('&ID' EQ 'DYES').RPRM
         AIF   ('&ID' EQ 'YES').LCLYES
         AIF   ('&ID' EQ 'SHORT').LCLYES
         AIF   ('&ID' EQ 'NODATE').LCLYES
         AIF   ('&ID' EQ 'NO').LCLYES
         MNOTE 4,'&ID INVALID FOR ID= - VALUE &LCLID USED.'
         AGO   .RPRM
.LCLYES  ANOP
&LCLID   SETC  '&ID'
.*
.*       SEE IF PARM REGISTER TO BE OVERRIDEN FOR THIS ENTRY
.*
.RPRM    ANOP
         AIF   ('&PARM' EQ 'DR2').RRENT
&LCLPARM SETC  '&PARM'
.*
.*       FLUSH RENT OPTION IF CODED - USE ORIGINAL
.*
.RRENT   AIF   ('&RENT(1)' EQ 'DYES').RSWRCK
         AIF   ('&RENT(1)' EQ '&GBLRENT').RSWRCK
         MNOTE 4,'&RENT REENTRANCY OPTION IGNORED - &GBLRENT FROM FIRSTX
               USE OF CNAENTER USED.'
.RSWRCK  ANOP
.*
.*       SET &LCLRENT FOR PROPER GEN TYPE
.*
&LCLRENT SETB  ('&GBLRENT' EQ 'YES'   OR '&GBLRENT' EQ 'NEWSTACK' OR   *
                '&GBLRENT' EQ 'STACK' OR '&GBLRENT' EQ 'NOSAVE' OR     *
                '&GBLRENT' EQ 'COM')
.*
.*       EDIT SPKA OPTION. ONLY VALID IF 2ND RENT OPTION CODED
.*
         AIF  ('&SPKA' EQ '' OR '&GBLCESV' NE '').RNT4OK
         MNOTE 4,'SPKA=&SPKA IGNORED IF 2ND RENT OPTION NOT CODED'
.RNT4OK  ANOP
.*
.*       EDIT WTG OPERAND IF GBLRENT=COM
.*
         AIF   ('&GBLRENT' NE 'COM').NOCBAS
         AIF   ('&GBLWTG' EQ '').NLWTG
         AIF   ('&WTG' EQ 'D' OR '&WTG' EQ '&GBLWTG').NOWTGE
         MNOTE 8,'&WTG WTG ENTRY IGNORED - &GBLWTG USED'
         AGO   .NOWTGE
.NLWTG   ANOP
         AIF   ('&WTG' EQ 'D' OR '&WTG' EQ '').NOWTGE
         MNOTE 8,'NO WTG CODE GENERATED DUE TO FIRST ENTRY CONDITIONS'
.NOWTGE  ANOP
         AIF   ('&CBASE' EQ 'DR12' OR '&CBASE' EQ '&GBLCBAS').NOCBAS
         MNOTE 8,'COMMON BASE CODED IGNORED - &GBLCBAS USED'
.NOCBAS  ANOP
.*
.*       RESET LOCAL VALUE OF CLEAR SWITHCES IF NOT DEFAULTED
.*
         AIF   ('&SCLEAR' EQ 'DNO').CKWCLR
&LCLSCLR SETB  ('&SCLEAR' EQ 'YES')
.CKWCLR  AIF   ('&WCLEAR' EQ 'DNO').RSN
&LCLWCLR SETB  ('&WCLEAR' EQ 'YES')
.*
.*       SAVE AREA NAME MUST REMAIN CONSTANT OVER INVOCATIONS
.*
.RSN     AIF   ('&SNAME' EQ '').RSTRG
         AIF   ('&SNAME' EQ '&GBLSAVE').RSTRG
         MNOTE 8,'&SNAME WILL NOT BE USED FOR SAVE/WORK AREA NAME - &GBL
               LSAVE WILL BE USED INSTEAD'
.*
.*       STORAGE VALUE CAN ONLY CHANGE FOR RENT=NEWSTACK OR RENT=STACK
.*
.RSTRG   AIF   ('&STORAGE' EQ 'DWORKLEN').CALC
         AIF   ('&STORAGE' EQ '&GBLSTRG').CALC
         AIF   ('&GBLRENT' EQ 'NEWSTACK' OR '&GBLRENT' EQ 'STACK').REST
        MNOTE 8,'UNABLE TO CHANGE STORAGE LENGTH - VALUE &GBLSTRG USED'
         AGO   .CALC
.REST    ANOP
&LCLSTRG SETC  '&STORAGE'
.*
.*
.*
.*       COMMON MACRO SET UP AND OFFSET CALCULATION
.*
.*
.*    ID=    NO     SHORT   NODATE    YES     ENTRY=  (SPFID)  FIRST?
.*
.*            0       10      10       24       NO       NO      ---
.*
.*                            28       28       YES      ---     NO
.*
.*                            28       42       YES      NO      YES
.*
.*                            34       48       NO       YES     ---
.*
.*                            52       66       YES      YES     YES
.*
.*
.CALC    ANOP
&LCLIDSZ SETA  0
         AIF   ('&LCLID' EQ 'NO').NOSPFID
&LCLIDSZ SETA  10
         AIF   ('&LCLID' EQ 'SHORT').NOSPFID  NO ID OR DATES
         AIF   (NOT &LCLENTR AND NOT &LCLOFF).IDLEN
&LCLIDSZ SETA  &LCLIDSZ+18           FOR ENTRY=YES
.IDLEN   AIF   (&LCLOFF).NOSPFID     NO DATES FOR 2ND ENTRY
         AIF   ('&LCLID' EQ 'NODATE').CALCND  NO DATE - MAY BE SPF
&LCLIDSZ SETA  &LCLIDSZ+14           FOR ASSEMBLY DATE AND TIME
.CALCND  AIF   ('&CNASPFL' EQ '').NOSPFID       SKIP IF NO SPF DATA
&LCLIDSZ SETA  &LCLIDSZ+24         LENGTH OF SPF SOURCE DATA
.NOSPFID ANOP
&LCLIDLN SETA  &LCLIDSZ-1
.*
.*       SIZE OF ID CONSTANTS CALCULATED - CALCULATE TOTAL
.*       CONSTANT SIZE BY ADDING 2 FOR STORAGE CALCULATION
.*       FOR STACKING, 2 FOR OFFSET FOR BASE 1 CALCULATION
.*       AND 72 PLUS ALIGNMENT FILLER FOR IN-LINE SAVE AREAS.
.*
&LCLCONS SETA  &LCLIDSZ
&LCLPLUS SETA  4
         AIF   (NOT &LCLOFF).NOFF
&LCLCONS SETA  &LCLCONS+2         ADD FOR BASE 1 OFFSET
&LCLOFFS SETA  &LCLIDSZ+&LCLPLUS
&LCLPLUS SETA  &LCLPLUS+2
.NOFF    AIF   ('&GBLRENT' NE 'STACK' AND '&GBLRENT' NE 'NEWSTACK').N
&LCLCONS SETA  &LCLCONS+2         ADD FOR STORAGE OFFSET
&LCLSTRL SETA  &LCLIDSZ+&LCLPLUS
&LCLPLUS SETA  &LCLPLUS+2
.N       AIF   ('&GBLRENT' NE 'NO' OR &LCLOFF).NOSAVE
&LCLWORK SETA  &LCLCONS/4
&LCLWORK SETA  &LCLWORK*4
&LCLFILL SETA  &LCLWORK+4-&LCLCONS
         AIF   (&LCLFILL LT 4).FSET
&LCLFILL SETA  0
.FSET    ANOP
&LCLCONS SETA  &LCLCONS+&LCLFILL+72
.*
.*
.*       CALCULATIONS ARE DONE ... BEGIN CODE GENERATION
.*
.*
.NOSAVE  ANOP
         AIF   (NOT &LCLOFF).NOALGN
         CNOP  0,8                 FORCE DOUBLE WORD ALIGNMENT
.NOALGN  AIF   (NOT &LCLENTR).NEGE
&LCLENAM DS    0H                  ENTRY POINT NAME
         ENTRY &LCLENAM            EXTERNAL DECLARATION
.NEGE    AIF   ('&MNAME' EQ '').NNAME
         AIF   ('&LCLENAM' EQ '&MNAME' AND &LCLENTR).NNAME
&MNAME   DS    0H                  ENTRY POINT NAME
.NNAME   ANOP
         USING *,&LCLTBAS          TEMPORARY BASE
         AIF   (&LCLCONS EQ 0).NOCONS
&LCLWORK SETA  &LCLCONS+4
         B     *+&LCLWORK          BRANCH AROUND ALL CONSTANTS
         AIF   (&LCLIDSZ EQ 0).NOIDSZ
         DC    AL1(&LCLIDLN)       LENGTH OF ID FIELDS
         AIF   (NOT &LCLENTR).NOECON
         DC    CL9'&LCLENAM'       ENTRY NAME IN ID FIELDS
         AIF   (&LCLIDSZ EQ 10).NOIDSZ
         DC    CL9'IN CSECT '
.NOECON  DC    CL9'&SYSECT'        CSECT NAME IN ID FIELDS
         AIF   (&LCLIDSZ EQ 10).NOIDSZ
         AIF   (&LCLOFF).NOIDSZ    SKIP BOTH TIME AND SPF DATA FOR 2ND
         AIF   ('&LCLID' EQ 'NODATE').SPFID1
         DC    CL9'&SYSDATE'       ASSEMBLY DATE IN ID FIELDS
         DC    CL5'&SYSTIME'       ASSEMBLY TIME IN ID FIELDS
.SPFID1  AIF   ('&CNASPFD' EQ '').NOIDSZ INSERT SPF DATA
         DC    CL8' &CNASPFD'      DATE OF THIS MODIFICATION
         DC    CL8'&CNASPFL'       LEVEL NUMBER OF THIS VERSION
         DC    CL8'&CNASPFU'       TSO USERID OF LAST UPDATER
.NOIDSZ  AIF   (NOT &LCLOFF).STCKCK
         AIF   ('&GBLRENT' EQ 'NO').SAOFF
         DC    Y(&LCLENAM-&SYSECT) OFFSET TO MODULE BASE
         AGO   .STCKCK
.SAOFF   DC    Y(&LCLENAM-&GBLSAVE) OFFSET TO MODULE BASE
.STCKCK  AIF   ('&GBLRENT' NE 'STACK' AND '&GBLRENT' NE 'NEWSTACK').F
         DC    Y(&LCLSTRG)         WORK AREA SIZE FROM STACK
.F       AIF   ('&GBLRENT' NE 'NO' OR &LCLOFF).NOCONS
         AIF   (&LCLFILL EQ 0).NOFILL
         DC    XL(&LCLFILL)'00'    FILLER TO ALIGN SAVE AREA
.NOFILL  ANOP
&GBLSAVE DC    18F'0'              MODULE'S SAVE AREA
.NOCONS  ANOP
         SPACE 2
.*
.*             GENERATE CODE FOR SVC ENTRY OPTIONS
.*
         AIF   ('&LCLSVCT' EQ '').RNT2GND   NO SVC ENTRY, GO TO STD.
         AIF   ('&LCLSVCT' EQ 'SVCR6').RNT2G1 DON'T SAVE BASE REGISTER
         AIF   ('&LCLSVCT' EQ 'NSL').RNT2G1  LIKEWISE FOR NSL OPTION
         LR    R3,&LCLTBAS         SAVE TEMPORARY BASE
         DROP  &LCLTBAS
         USING &LCLENAM,R3
&LCLTBAS SETC  'R3'                RESET TEMPORARY BASE
.RNT2G1  AIF   ('&SPKA' EQ '').RNT2G1A      SKIP IF NO SPKA OPTION
         AIF   ('&SPKA' NE 'DATAMGT').USERSPK
         SPKA  80                  SET DATAMGT PROTECT KEY
         AGO   .RNT2G1A
.USERSPK SPKA  &SPKA               SET PROTECT KEY FOR USER
.RNT2G1A ANOP
  DS  0C'GETMAIN R,LV=&GBLSTCK,SP=&GBLCESP' GET NEW STACK
         GETMAIN R,LV=&GBLSTCK,SP=&GBLCESP
         AIF   ('&LCLSVCT' NE 'NSL').RNT2G2  SKIP SAVE IF NOT NSL
         STM   R2,R14,80(R1)       SAVE OPEN/CLOSE/EOV REGS (EX. R3)
         LR    R13,R1              SET SAVEAREA IN PROPER BASE
         BALR  &GBLREGS(1),0       GET LOCATION
         LA    R15,*-&SYSECT       CALCULATE CORRECT BASE
         SLR   &GBLREGS(1),R15      --> 4K MODULE LIMIT <--
         AGO   .RNT2G3             SKIP OTHER OPTION FIDDLING
.RNT2G2  LR    R13,R1              SET SAVEAREA IN PROPER BASE
         AIF   ('&GBLREGS(1)' EQ '&LCLTBAS' AND NOT &LCLOFF).RNT2G3A
         AIF   ('&GBLREGS(1)' EQ '&LCLTBAS').RNT2G2A
         LR    &GBLREGS(1),&LCLTBAS SET PERMANENT BASE REGISTER
.RNT2G2A AIF   (NOT &LCLOFF).RNT2G3      SKIP IF NOT SECOND ENTRY
         SH    &GBLREGS(1),&LCLENAM+&LCLOFFS ADJUST THE BASE REGISTER
.RNT2G3  DROP  &LCLTBAS            RESET ADDRESSING
         USING &SYSECT&GBLUSNG     SET USING FOR PROGRAM
.RNT2G3A LH    R15,&LCLENAM+&LCLSTRL SET ADDRESS OF NEXT
         AR    R15,R13              WORKAREA IN THE STACK
         ST    R15,72(,R13)         FOR RENT=STACK PROCESSING
         XC    4(8,R13),4(R13)      CLEAR BACK AND FOREWARD POINTERS
         USING &GBLSAVE,R13         DECLARE DSA
         AIF   ('&LCLSVCT' NE 'SVCR6').RNT2G4 IS IT R6 ENTRY
         LM    R0,R1,32(R5)         RESTORE PARAMETER REGS FROM
         L     R15,92(R5)           SVRB SAVEAREA
.RNT2G4  SPACE 2
         MEXIT
.RNT2GND ANOP
.*
.*             NOW GENERATE FOR NON SVC ENTRY OPTIONS
.*
         AIF   ('&GBLRSVE' EQ 'NO').RSVE#1
         STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS
         AGO   .RSVE#2
.RSVE#1  LR    R3,R14              SAVE R14 FOR RETURN
.RSVE#2  LR    &LCLPARM,R1         SAVE INPUT PARAMETER LIST PTR.
         AIF   (&LCLRENT).RBASES
         AIF   (&LCLOFF).SOFFBAS
         LA    R15,&GBLSAVE        WILL BE BASE AND S.A. POINTER
.NRBAS   ST    R13,4(,R15)         SET BACK CHAIN
         ST    R15,8(,R13)         SET FORWARD CHAIN
         LR    R13,R15             SET BASE AND S.A. POINTER
         DROP  R15                 END TEMPORARY ADDRESSING
         USING &GBLSAVE&GBLUSNG    PERMANENT ADDRESSING
         AGO   .NTHBASE
.SOFFBAS ANOP
         SH    R15,&LCLENAM+&LCLOFFS WILL BE BASE AND S.A. POINTER
         AGO   .NRBAS
.RBASES  LR    &GBLREGS(1),R15     SET 1ST BASE REGISTER
         AIF   (NOT &LCLOFF).ROFFBAS
         SH    &GBLREGS(1),&LCLENAM+&LCLOFFS RESET BACK TO ORIGIN
.ROFFBAS DROP  R15                 END TEMPORARY ADDRESSING
         USING &SYSECT&GBLUSNG     PERMANENT ADDRESSING
.NTHBASE AIF   (&GBLREG# LE 1).NTHSET
&LCLSUB1 SETA  2
&LCLSUB2 SETA  1
         LA    R14,2048            CONSTANT FOR NTH BASE GENERATION
.NTHGENR AIF   (&LCLSUB1 GT &GBLREG#).NTHSET
         LA    &GBLREGS(&LCLSUB1),2048(R14,&GBLREGS(&LCLSUB2).)
&LCLSUB2 SETA  &LCLSUB1
&LCLSUB1 SETA  &LCLSUB1+1
         AGO   .NTHGENR
.NTHSET  ANOP
         SPACE 2
         AIF   ('&GBLRENT' EQ 'NO').PL
         AIF   ('&GBLRENT' EQ 'NOSAVE').PL
         AIF   ('&GBLRENT' EQ 'YES').GET
         AIF   ('&GBLRENT' EQ 'STACK').STACK
         AIF   ('&GBLRENT' EQ 'COM').COMGET
*                                  GET STACK
         GETMAIN  R,LV=&GBLSTCK,SP=&GBLCESP
         AGO   .FWDCHN
.STACK   ANOP
         L     R1,72(,R13)         GET NEXT AREA ORIGIN IN STACK
         AGO   .FWDCHN
.GET     ANOP
*                                  GET WORKING STORAGE
         GETMAIN  R,LV=&LCLSTRG,SP=&GBLCESP
         AGO   .FWDCHN
.COMGET  ANOP
         L     R1,Q&GBLQNAM(1)     GET OFFSET TO WORK AREA
         AR    R1,&GBLCBAS         ADJUST TO ADDRESS
.FWDCHN  ST    R1,8(,R13)          SET FORWARD CHAIN
         AIF   (NOT &LCLWCLR).SCLRCK
         LR    R14,R1              ADDRESS TO BEGIN CLEAR
         AIF   ('&GBLRENT' EQ 'YES').CLRLC
         AIF   (&LCLENTR).LHENTR
         LH    R15,&SYSECT+&LCLSTRL LENGTH OF CLEAR
         AGO   .CLRCMN
.CLRLC   LH    R15,*+8             LENGTH OF CLEAR
         B     *+6                 AROUND CONSTANT
         DC    Y(&LCLSTRG)         SIZE OF WORK AREA
         AGO   .CLRCMN
.LHENTR  LH    R15,&LCLENAM+&LCLSTRL LENGTH OF CLEAR
.CLRCMN  SR    R1,R1               FILL CHARACTER IS X'00'
         MVCL  R14,R0              CLEAR THE WORK AREA
         L     R1,8(,R13)          RELOAD CURRENT WORK POINTER
         AGO   .CLRD
.SCLRCK  AIF   (NOT &LCLSCLR).CLRD
         XC    0(72,R1),0(R1)      CLEAR THE SAVE AREA
.CLRD    AIF   ('&GBLRENT' EQ 'YES' OR '&GBLRENT' EQ 'COM').NOSTKS
         AIF   (&LCLENTR).LENENTR
         LH    R15,&SYSECT+&LCLSTRL SIZE OF AREA NEEDED IN STACK
         AGO   .BLDSTKN
.LENENTR LH    R15,&LCLENAM+&LCLSTRL SIZE OF AREA NEEDED IN STACK
.BLDSTKN AR    R15,R1              R15 IS NEXT FREE SLOT IN STACK
         ST    R15,72(,R1)         SET FOR NEXT MODULE TO FIND
.NOSTKS  AIF   ('&GBLRSVE' EQ 'NO').NRSV#3
         ST    R13,4(,R1)          SET BACK CHAIN
         LM    R13,R1,8(R13)       RESTORE CLOBBERED REGISTERS
         USING &GBLSAVE,R13        TELL ASSEMBLER ABOUT REGISTER
         AGO   .PL                 GO CHECK FOR PARAMETER LIST SAVE
.NRSV#3  LR    R13,R1              SET WORK AREA REGISTER
         USING &GBLSAVE,R13        TELL ASSEMBLER ABOUT REGISTER
.PL      AIF   ('&PLOAD' EQ '').DONE
&LCLPRML SETA  N'&PLOAD
&LCLWORK SETA  1
         SPACE 2
.PLLOOP  CNAPLOAD &PLOAD(&LCLWORK),&LCLWORK,&LCLPARM
&LCLWORK SETA  &LCLWORK+1
         AIF   (&LCLWORK LE &LCLPRML).PLLOOP
.DONE    AIF   ('&GBLRENT' NE 'COM').DONE1
         AIF   ('&GBLWTG' EQ '').DONE1
         ICM   R15,15,&GBLWTG         PICK UP WHERE TO GO ADDRESS
         BNZR  R15                    GO THERE IF INITIALIZED
.DONE1   ANOP
         SPACE 2
         MEND
***********************************************************************
*                                                                     *
*  AUTHORS AND DATES:                                                 *
*                                                                     *
*      MIKE AMLING - ORIGINAL CODE                       ??/??/80 N/A *
*                                                                     *
*                                                                     *
*  MAINTENANCE SUMMARY:                                               *
*                                                                     *
*    MIKE AMLING - REVISE TO USE &INUSE(13)               5/ 5/83 MA01*
*                                                                     *
*                                                                     *
***********************************************************************
         MACRO
         RF
         GBLB  &INUSE(13)                                         MA01
         GBLC  &EQU(12),&USING(12)
         LCLA  &A,&X
         LCLC  &C
&X       SETA  N'&SYSLIST
.LOOPX   AIF   (&X LE 0).MEXIT
&C       SETC  '&SYSLIST(&X)'
&X       SETA  &X-1
         AIF   ('&C' EQ '').LOOPX      SKIP NULL ENTRIES
.*
.*  FREE THE REGISTER CURRENTLY IN USE AS &C
.*
&A       SETA  2                       LOWEST SUPPORTED REGISTER - 1
.LOOPA   AIF   (&A GE 12).ERRINUS      12 IS HIGHEST SUPPORTED REGISTER
&A       SETA  &A+1
         AIF   ('&EQU(&A)' NE '&C').LOOPA
.*
&INUSE(&A) SETB 0                      INDICATE REG NO LONGER IN USE
&EQU(&A) SETC  ''                      RESET FOR LATER RF MACROS
         AIF   ('&USING(&A)' EQ '').LOOPX
&USING(&A) SETC ''
         DROP  &C                                                     $
         AGO   .LOOPX
.*
.* ERROR MNOTES
.*
.ERRINUS MNOTE 4,'REGISTER &C NOT IN USE.'
         AGO   .LOOPX
.MEXIT   MEND
***********************************************************************
*                                                                     *
*  AUTHORS AND DATES:                                                 *
*                                                                     *
*      MIKE AMLING - ORIGINAL CODE                       ??/??/80 N/A *
*                                                                     *
*                                                                     *
*  MAINTENANCE SUMMARY:                                               *
*                                                                     *
*    MIKE AMLING - REVISE TO USE &INUSE(13)               5/ 5/83 MA01*
*                                                                     *
*                                                                     *
***********************************************************************
         MACRO
         RL
         GBLB  &INUSE(13)                                         MA01
         GBLC  &EQU(12),&USING(12)
         LCLA  &A
         LCLC  &C
         PUSH  PRINT                                                  $
         PRINT ON,GEN                                                 $
&A       SETA  2                       1ST SUPPORTED REGISTER - 1
.LOOP    AIF   (&A GE 12).LISTX
&A       SETA  &A+1
         AIF   (NOT &INUSE(&A)).LOOP
&C       SETC  '&EQU(&A)        '(1,8).' EQU   &A                      *
                                                       '(1,60)
         MNOTE *,'&C.$'
         AIF   ('&USING(&A)' EQ '').LOOP
&C       SETC  '         USING &USING(&A),&A                           *
                                                       '(1,68)
         MNOTE *,'&C.$'
         AGO   .LOOP
.LISTX   POP   PRINT                                                  $
         MEND
***********************************************************************
*                                                                     *
*  AUTHORS AND DATES:                                                 *
*                                                                     *
*      MIKE AMLING - ORIGINAL CODE                       ??/??/80 N/A *
*                                                                     *
*                                                                     *
*  MAINTENANCE SUMMARY:                                               *
*                                                                     *
*    MIKE AMLING - REVISE TO USE &INUSE(13)               5/ 5/83 MA01*
*                                                                     *
*                                                                     *
***********************************************************************
         MACRO
         RG    &S,&T
         GBLB  &INUSE(13)                                         MA01
         GBLC  &EQU(12),&USING(12)
         LCLA  &A
         LCLC  &C
         AIF   (N'&SYSLIST LE 2).MULTIX
         MNOTE 8,'ALL BUT FIRST 2 POSITIONAL PARAMETERS IGNORED.'
.MULTIX  AIF   (T'&T NE 'O').PAIR
         AIF   ('&S(3)' NE '').SPEC
.*
.*  SEARCH FOR 1 AVAILABLE REGISTER
.*
&A       SETA  2                ONE LESS THAN LOWEST SUPPORTED REGISTER
.LOOP1   ANOP                                                     MA01
&A       SETA  &A+1
         AIF   (&INUSE(&A)).LOOP1
         AIF   (&A GT 12).ERRNORE      IF 3..12 NOT AVAILABLE     MA01
.*
.*  SET UP LONE REGISTER OR EVEN REGISTER OF PAIR
.*
.TAKEA   ANOP
&INUSE(&A) SETB 1                      NOTE REGISTER IN USE
&EQU(&A) SETC  '&S(1)'                 NOTE NAME FOR RF MACRO
&C       SETC  '&S(1)       '(1,8)
         MNOTE *,'&C EQU   &A'
&S(1)    EQU   &A                      DEFINE SYMBOL FOR REGISTER     $
         AIF   ('&S(2)' EQ '').MEXIT
         USING &S(2),&S(1)             TELL ASSEMBLER ABOUT CONTENTS  $
&USING(&A) SETC '&S(2)'                NOTE DSECT NAME FOR RCALL MACRO
.MEXIT   MEXIT
.*
.*  SEARCH FOR AN AVAILABLE EVEN/ODD REGISTER PAIR
.*
.PAIR    AIF   (N'&S LE 2 AND N'&T LE 2).PAIROVX
         MNOTE 8,'ASSIGNMENT OVERRIDE IGNORED WHEN REQUESTING PAIR.'
.PAIROVX ANOP
&A       SETA  3                       ODD REG OF 1ST PAIR - 2
.LOOP2   ANOP                                                     MA01
&A       SETA  &A+2
         AIF   (&INUSE(&A) OR &INUSE(&A-1)).LOOP2
         AIF   (&A GT 11).ERRNOPA   11 IS ODD REG OF HIGHEST PAIR MA01
.*
.*  SET UP ODD REGISTER OF PAIR
.*
&INUSE(&A) SETB 1                      NOTE REGISTER IN USE
&EQU(&A) SETC  '&T(1)'                 NOTE ODD REG NAME FOR RF MACRO
&C       SETC  '&T(1)       '(1,8)
         MNOTE *,'&C EQU   &A'
&T(1)    EQU   &A                      DEFINE SYMBOL FOR REGISTER     $
&A       SETA  &A-1                    PRESET FOR DEFINING EVEN REG
         AIF   ('&T(2)' EQ '').TAKEA
&USING(&A+1) SETC '&T(2)'              NOTE DSECT NAME FOR RCALL MACRO
         USING &T(2),&T(1)             TELL ASSEMBLER ABOUT CONTENTS  $
         AGO   .TAKEA
.*
.*  CHECK USER-SPECIFIED REGISTER
.*
.SPEC    ANOP
&A       SETA  K'&S(3)
.SPCLOOP AIF   (&A LE 0).SPCOK
         AIF   ('&S(3)'(&A,1) LT '0').ERRSPEC
&A       SETA  &A-1
         AGO   .SPCLOOP
.SPCOK   ANOP
&A       SETA  &S(3)
         AIF   (&A LT 3 OR &A GT 12).ERRS312
         AIF   (NOT &INUSE(&A)).TAKEA
         AIF   ('&EQU(&A)' EQ '').ERRINU2
         MNOTE 12,'SPECIFIED REGISTER &A IN USE AS &EQU(&A)'
         MEXIT
.ERRINU2 MNOTE 12,'SPECIFIED REGISTER &A IN USE BY CALLING CODE'
         MEXIT
.ERRSPEC MNOTE 8,'SPECIFIED REGISTER &S(3) NOT NUMERIC.'
         MEXIT
.ERRS312 MNOTE 8,'SPECIFIED REGISTER NOT IN RANGE 3-12.'
         MEXIT
.ERRNOPA MNOTE 8,'NO REGISTER PAIR AVAILABLE.'
         MEXIT
.ERRNORE MNOTE 8,'NO REGISTER AVAILABLE.'
         MEND
KLIB     TITLE 'TSO COMMAND KDSN (DISPL/TRAP/RESET DSNAMES FOR DDNAME)'
*  COMMAND SYNTAX:  KLIB (DDNAME:MEMBER LIST) SAVE                    *
*  COMMAND ACTION:                                                    *
*     1. PARSE THE DDNAME-LIST (LOOPING FOR EACH DDNAME).             *
*     2. EXTRACT DSNAMES INTO A TABLE (KDSNSUB).                      *
*     3. BLDL MEMBER-NAME AGAINST EACH LIBRARY IN DSNAME TABLE;       *
*        BLANK OUT "NO-HIT" DSNAMES (KMEMSUB).                        *
*     4. IF 'SAVE' OMITTED, TPUT REMAINING DSNAMES FROM TABLE.        *
*     5. IF 'SAVE':                                                   *
*        A.  ALLOCATE A 'SAVE'-DATASET.                               *
*        B.  WRITE MEMBER/DDNAME RECORD.                              *
*        C.  WRITE DSNAME RECORDS.                                    *
*  TECHNICAL NOTES:                                                   *
*     1. PROGRAM IS NOT REENTRANT.                                    *
*     2. IKJDAIR SERVICE USED FOR ALLOCATE/FREE OF 'SAVE'-DATASET.    *
*        'SAVE'-DATASET ALLOCATED BY DYNAMICALLY-DETERMINED DDNAME.   *
*     3. 'SAVE' FUNCTION IS INSENSITIVE TO DDNAMES IN COMMAND INPUT   *
*        WHICH ARE NOT ALLOCATED.                                     *
*     4. RETURN-CODES:                                                *
*              0 = SUCCESSFUL DISPLAY/'RESET' FUNCTION                *
*             20 = (UNANTICIPATED) COMMAND FAILURE                    *
*            100 = NO DDNAME/MEMBER HITS DURING 'SAVE' FUNCTION       *
*        (100+N) = SUCCESSFUL 'SAVE' FUNCTION;                        *
*                  'N' = NUMERIC QUALIFIER OF LAST 'SAVE'-DATASET DDN *
*                                                                     *
KLIB     CSECT
         RG    (RBASE,,12)
         RG    (RBASE2,,11)
         RG    (RCPPL,CPPL)
         CNAENTER PARM=RCPPL,ENTRY=NO,RENT=NO
* RESET PROGRAM BASE FOR READABILITY
         L     RBASE,=V(KLIB)
         DROP  R13
         USING KLIB,RBASE
         LA    RBASE2,4095(RBASE)
         LA    RBASE2,1(RBASE2)
         USING KLIB+4096,RBASE2
         B     TOP
         EJECT
TOP      DS    0H
*
**  PARSE THE OPERAND LIST
*
         XC    RC4,RC4        INITIALIZE RETURN-CODE
         RG    (RPPL,PPL)
         LA    RPPL,PPLAREA
         RG    (RPARSED,IKJPARMD)
         L     RPARSED,=V(PARSECT)
         SPACE
*
**  ESTABLISH VALUES IN THE PARSE PARAMETER LIST
*
         MVC   PPLCBUF,CPPLCBUF
         MVC   PPLUPT,CPPLUPT
         ST    RPARSED,PPLPCL
         MVC   PPLECT,CPPLECT
         XC    CPECB,CPECB
         LA    R0,CPECB
         ST    R0,PPLECB
         XC    CPANS,CPANS
         LA    R0,CPANS
         ST    R0,PPLANS
         LA    R0,WORK
         ST    R0,PPLUWA
*
**  INVOKE PARSE
*
         CALLTSSR EP=IKJPARS,MF=(E,(RPPL))
         SPACE
         LTR   15,15                         TEST PARSE RETURN-CODE
         BZ    PARSEOK                       PARSE OK
* TPUT MESSAGE AND SET RETURN CODE ON PARSE FAILURE *
         LA    R1,=C'COMMAND-PARSE FAILURE'
         LA    R0,21
         SVC   93
         MVI   RC1,20
         B     FASTEXIT
         RF    RPPL
         EJECT
*
**  AFTER SUCCESSFUL PARSE, PROCESS EACH DDNAME PARAMETER
*
PARSEOK  DS    0H
         L     RPARSED,CPANS
         RG    RDDN                          DDNAME-ALLOCATED ARRAY
         LA    RDDN,DDNAME1                  SET DDNAME BASE
         LA    R1,50                         CLEAR DDNAME ARRAY
DDNCLR   MVC   0(8,RDDN),=CL8' '
         LA    RDDN,8(RDDN)
         BCT   R1,DDNCLR
         LA    RDDN,DDNAME1                  RESET DDNAME BASE
*
**  FIND A DDNAME FROM INPUT LIST
*
         RG    (RPDE,PDE)
         LA    RPDE,IDDN
         SPACE
DDNLOOP  DS    0H                            LOOPS THRU "LOOPRET"
         LTR   RPDE,RPDE
         BZ    EXIT                          NO MORE DDNAMES
         MVI   MESSAGE,C' '                  CLEAR TPUT-OUTPUT LINE
         MVC   MESSAGE+1(L'MESSAGE-1),MESSAGE
         MVC   REALDD,=CL8' '
         MVC   REALMEM,=CL8' '
         L     R15,PDEADDR
         LH    R1,PDELEN                     LENGTH OF DDNAME
         BCTR  R1,R0                           MINUS 1 FOR "EX"
         EX    R1,MVDD
         EX    R1,MVDD2
*
         L     R15,PDEADDR2
         LH    R1,PDELEN2                    LENGTH OF DDNAME
         BCTR  R1,R0                           MINUS 1 FOR "EX"
         EX    R1,MVMEM
         LA    R2,OMEM+7                     MOVE RIGHT-JUSTIFIED
         SR    R2,R1                           TO TPUT-OUTPUT LINE
         EX    R1,MVMEM2
         B     GOTDD
MVDD     MVC   REALDD(0),0(R15)              EXTRACT DDNAME
MVDD2    MVC   ODDN(0),0(R15)                EXTRACT DDNAME
MVMEM    MVC   REALMEM(0),0(R15)             EXTRACT MEMBERNM
MVMEM2   MVC   0(0,R2),0(R15)                EXTRACT MEMBERNM
*
*
GOTDD    DS    0H
         MVC   DSNAMECT,=AL2(DSNAME#)
*        LINK  EP=KDSNSUB,PARAM=(REALDD,DSNAMECT,DSNAME1),VL=1
         CALL  KDSNSUB,(REALDD,DSNAMECT,DSNAME1),VL
         MVC   DSNCTH,DSNAMECT               SAVE DSNAME COUNT
         LTR   R15,R15
         BZ    DONEDDN
BADDDN   DS    0H
         MVI   MEMSW,C'X'                    SET 'NO DSNS FOUND'
         B     ENDMEM                        BR TO OUTPUT ROUTINE
*
*** DSNAMES NOW IN TABLE ... CHECK FOR MEMBER "HITS"
*
DONEDDN  DS    0H
         MVI   MEMSW,C'N'                    SET SWITCH TO 'NOT FOUND'
*        LINK  EP=KMEMSUB,PARAM=(REALMEM,DSNAMECT,DSNAME1),VL
         CALL  KMEMSUB,(REALMEM,DSNAMECT,DSNAME1),VL
         LTR   R15,R15
         BNZ   ENDMEM
         MVI   MEMSW,C'Y'
*
*** ALL DSNAMES ALLOCATED TO DDNAME NOW TESTED FOR MEMBER-NAME HIT.
*
ENDMEM   DS    0H
         RG    RDSN                          DSNAME RESULTS ARRAY
         RG    RCOUNT                        ARRAY COUNTER
         LH    RCOUNT,DSNCTH                 SET DSNAME COUNT
         LA    RDSN,DSNAME1                  SET DSNAME REGISTER
         CLC   ISAVE(2),=H'0'                'SAVE' KEYWORD?
         BNE   DOGRAB                        BR IF YES TO PROCESS
*
***      STD   TPUT   RESPONSE
*
         MVC   OTEXT1,MESSAGE1
         CLI   MEMSW,C'Y'                    ANY MEMBER HITS?
         BNE   TNODDN                        BR IF NO TO NOTFOUND MSG
*
         MVC   OTEXT2,MESSAGEF
         LA    R1,MESSAGE
         L     R0,=A(L'MESSAGE)
         SVC   93
TOUTDSN  DS    0H
         CLI   0(RDSN),C' '
         BE    TOUTDSN2                      LOOP TO TPUT NEXT DSNAME
         LA    R0,44
         LR    R1,RDSN
         SVC   93                            TPUT DSNAME
TOUTDSN2 DS    0H
         LA    RDSN,44(RDSN)
         BCT   RCOUNT,TOUTDSN                LOOP TO TPUT NEXT DSNAME
         B     LASTLINE                      LOOP TO CHECK FOR NEXT DDN
TNODDN   DS    0H                            DDNAME NOT FOUND MESSAGE
         CLI   MEMSW,C'X'
         BE    TNODSN
         MVC   OTEXT2,MESSAGEN
         B     ONELINE                       LOOP TO CHECK FOR NEXT DDN
TNODSN   DS    0H
         MVC   OTEXT1,MESSAGE2
         MVC   OMEM,=CL8' '
*
ONELINE  DS    0H
         L     R0,=A(L'MESSAGE)
         LA    R1,MESSAGE
         SVC   93
LASTLINE DS    0H
         LA    R1,=CL8' '                    WRITE BLANK LINE FOR
         LA    R0,8                             READABILITY ON SCREEN
         SVC   93
         B     LOOPRET
         EJECT
*
*** END OF LOOP FOR DDNAME-LIST PROCESSING
*
LOOPRET  DS    0H
         ICM   RPDE,B'0111',PDECHAIN+1       SET TO NEXT PDE ENTRY
         B     DDNLOOP
         EJECT
*
*** PROCESSING FOR 'SAVE' KEYWORD
*
DOGRAB   DS    0H
         CLI   MEMSW,C'Y'                    ANY MEMBER HITS?
         BNE   LOOPRET                       BR IF NO TO AVOID 'SAVE'
*                                                PROCESSING
DOGRAB1  RCALL SETDD
         RCALL DYNALLOC
         LTR   R15,R15                       TEST DYNALLOC RC
         BZ    DOGRAB2                       BR IF OK
         C     R15,=F'20'                    TEST FOR DUPLICATE DD
         BNE   DYNABORT                      BR IF NO TO CLEANUP
         CLC   GRABDDNN,=C'99'               TOO MANY DYNALLOCS?
         BE    DYNABORT                      BR IF TRUE
         B     DOGRAB1                       BR TO TRY ANOTHER DD
DOGRAB2  DS    0H
         MVC   0(8,RDDN),GRABDD              SAVE ALLOCATED DDNAME
         LA    RDDN,8(RDDN)                  SET ARRAY BASE TO NEXT ENT
*
***      WRITE RECORDS TO OUTPUT DATASET
***      (1ST = MEMBER; 2-N=UNQUOTED DSNAME)
*
         USING IHADCB,R1
         LA    R1,DYNAMDCB
         MVC   DCBDDNAM,GRABDD
         DROP  R1
         OPEN  (DYNAMDCB,(OUTPUT))
         MVC   RECMEM,REALMEM
         MVC   RECDDN,REALDD
         PUT   DYNAMDCB,RECORD               WRITE 1ST 'SAVE' RECORD
DOGRAB3  DS    0H
         CLI   0(RDSN),C' '
         BE    DOGRAB4                       BR TO BYPASS BLANK DSNAME
         PUT   DYNAMDCB,(RDSN)               WRITE DSNAME 'SAVE' RECORD
DOGRAB4  DS    0H
         LA    RDSN,44(RDSN)
         BCT   RCOUNT,DOGRAB3                LOOP TO PUT NEXT DSNAME
*
         CLOSE (DYNAMDCB)
*
*** SET RETURN CODE
*
         CVB   R0,GRABDDNR
         A     R0,=F'100'
         ST    R0,RC4
         B     LOOPRET                       LOOP TO NEXT DDNAME
         EJECT
*
***      FREE  ALL DYNAMICALLY ALLOCATED DATASETS ON DYNALLOC ERROR
*
DYNABORT DS    0H
         LR    RDSN,RDDN                     SAVE CURRENT RDDN
         LA    RDDN,DDNAME1                  RESET TO 1ST DDN
DYNAB1   CR    RDDN,RDSN                     ANY ALLOC SUCCESSFUL?
         BE    BADEND                        BR IF NO
         MVC   GRABDD,0(RDDN)
         RCALL DYNFREE
         LA    RDDN,8(RDDN)                  BUMP TO NEXT DDN
         B     DYNAB1
BADEND   DS    0H
         LA    R1,=C'DYNAMIC-ALLOCATE FAILURE'
         LA    R0,25
         SVC   93
         MVI   RC1,20
         B     EXIT
         EJECT
         RF    RDSN,RDDN,RCOUNT
         EJECT
*
*** PROGRAM EXIT ANY TIME AFTER PARSE SERVICE INVOKED
*
EXIT     DS    0H
         CLC   ISAVE,=H'0'                   'SAVE' KEYWORD
         BE    EXIT2                         BR IF NOT PRESENT
         CLC   RC4,=F'0'                     TEST RETURN-CODE
         BNE   EXIT2                         'SAVE' PROCESSING DONE
         MVI   RC1,100                       SET 'NOT SAVED' RET CODE
EXIT2    DS    0H
         RF    RPDE
         IKJRLSA CPANS
*
*** PROGRAM EXIT ANY TIME BEFORE PARSE SERVICE INVOKED
*
FASTEXIT CNAEXIT RC4
         RF    RPARSED
         TITLE '- SUBROUTINES'
DYNALLOC RSUB  ,                             DYNAMIC-ALLOCATE (NEW)
         ST    R14,DYNRET
         STM   R0,R12,DYNREG
*
         RG    (RDAPL,DAPL)
         LA    RDAPL,DAPLAREA
         RG    (RDAP08,DAPB08)
         LA    RDAP08,DA08AREA
*        BUILD ALLOC VALUES
         MVC   DA08CD,=X'0008'
         XC    DA08PDSN,DA08PDSN
         MVC   DA08DDN,GRABDD
         MVI   DA08DSP1,DA08NEW
         MVI   DA08DPS2,DA08DEL
         MVI   DA08DPS3,DA08DELE
         MVI   DA08CTL,DA08PERM
         OI    DA08CTL,DA08TRKS
         MVC   DA08UNIT,=C'SYSDA   '
         MVC   DA08SER,=CL8' '
         XC    DA08BLK,DA08BLK
         MVC   DA08PQTY,=F'1'
         XC    DA08SQTY,DA08SQTY
         XC    DA08DQTY,DA08DQTY
         XC    DA08CTL+1(4),DA08CTL+1
         MVC   DA08MNM,=CL8' '
         MVC   DA08PSWD,=CL8' '
         MVC   DA08ALN,=CL8' '
*        BUILD DAPL VALUES
         MVC   DAPLUPT,CPPLUPT
         MVC   DAPLECT,CPPLECT
         LA    R0,CPECB
         ST    R0,DAPLECB
         MVC   DAPLPSCB,CPPLPSCB
*
         ST    RDAP08,DAPLDAPB
         CALLTSSR EP=IKJDAIR,MF=(E,(RDAPL))  ALLOCATE
         RF    RDAP08,RDAPL
*
         B     DYNEXIT
         SPACE 3
DYNFREE  RSUB  ,                             DYNAMIC-FREE (SHR)
         ST    R14,DYNRET
         STM   R0,R12,DYNREG
*
         RG    (RDFPL,DAPL)
         LA    RDFPL,DAPLAREA
         RG    (RDAP18,DAPB18)
         LA    RDAP18,DA18AREA
*        BUILD FREE VALUES
         MVC   DA18CD,=X'0018'
         MVC   DA18DDN,=C'KLIBTEMP'          SPECIAL DDNAME
         MVC   DA18MNM,=CL8' '
         MVC   DA18SCLS,=CL2' '
         MVI   DA18CTL,DA18PERM
*        BUILD DAPL VALUES
         MVC   DAPLUPT,CPPLUPT
         MVC   DAPLECT,CPPLECT
         LA    R0,CPECB
         ST    R0,DAPLECB
         MVC   DAPLPSCB,CPPLPSCB
*
         ST    RDAP18,DAPLDAPB
         CALLTSSR EP=IKJDAIR,MF=(E,(RDFPL))  FREE PREVIOUS ALLOCATE
         RF    RDAP18,RDFPL
*
         B     DYNEXIT
         SPACE 3
*        SET GRAB-DATASET DDNAME AS FOLLOWS (FOR UNIQUENESS):
*              "KLIBXX.."  WHERE ".." IS NUMBERED 1-UP
*                    FROM "1 " TO "99".
*
SETDD    RSUB
         ST    R14,DYNRET
         STM   R0,R12,DYNREG
*
         CLI   GRABDDNN+1,C' '
         BNE   SETDD2
         CLI   GRABDDNN,C'9'
         BNE   SETDD1
         MVC   GRABDDNN,=C'09'
         B     SETDD2
SETDD1   PACK  GRABDDNP,GRABDDNN(1)
         AP    GRABDDNP,=P'+1'
         UNPK  GRABDDNN(1),GRABDDNP
         OI    GRABDDNN,X'F0'                CLEAR THE SIGN
         B     SETDD3
SETDD2   DS    0H
         PACK  GRABDDNP,GRABDDNN
         AP    GRABDDNP,=P'+1'
         UNPK  GRABDDNN,GRABDDNP
         OI    GRABDDNN+1,X'F0'              CLEAR THE SIGN
SETDD3   DS    0H
         B     DYNEXIT
         TITLE '- COMMON SUBROUTINE EXIT'
DYNEXIT  DS    0H
         L     R14,DYNRET
         LM    R0,R12,DYNREG
         BR    R14
DYNRET   DS    F                             SUBROUTINE RETURN ADDRESS
DYNREG   DS    13F                           SUBROUTINE RETURN REGS
         DROP  ,
         TITLE '- PARSE VALIDITY-CHECK ON DDN(MEMBER) SYNTAX'
MEMCK    DS    0H                            VALIDITY-CHECK EXIT
         USING *,R15
         USING PDE,R1
         L     R1,0(R1)                      PDE ADDRESS
         CLC   PDELEN2,=H'0'                 CHECK FOR MEMBER-NAME
         BE    MEMCK2
         CLC   PDELEN,=H'8'
         BH    MEMCK2
         XR    R15,R15                       SET GOOD RETURN-CODE
         BR    R14
MEMCK2   DS    0H
         LA    R15,4                         SET ERROR RETURN-CODE
         BR    R14
         DROP  R15,R1
         TITLE '- CONSTANTS'
         RL
*
MESSAGE  DS    0CL(MLTH)
ODDN     DS    CL8
         DS    C
OTEXT1   DS    CL(L'MESSAGE1)
OMEM     DS    CL8
         DS    C
OTEXT2   DS    CL(L'MESSAGEF)
MLTH     EQU   *-ODDN
MESSAGE1 DC    C'DATASETS SEARCHED - '
MESSAGEF DC    C'FOUND ON:'
MESSAGEN DC    C'NOT FOUND'
MESSAGE2 DC    C'NOT ALLOCATED       '
*
         ORG
         LTORG *
         TITLE '- WORKING STORAGE'
RC4      DS    F
RC1      EQU   RC4+3,1
CPECB    DS    F
CPANS    DS    F
CPUWA    DS    F
*
PPLAREA  DS    0A,XL(PPLLEN)
CPPLAREA DS    0A,XL(CPPLLEN)
*
DAPLAREA DS    0A,XL(DAPLLEN)
DA08AREA DS    0A,XL(DAP08LEN)
DA18AREA DS    0A,XL(DAP18LEN)
*
WORK     DS    CL30                          PPLUWA (NOT USED)
*
         ORG   WORK                          REUSE WORK FIELD
DSNCT    DS    F                             COUNT OF DSNAME1 ARRAY
DSNH     DS    F                             PROCESS COUNT OF DSNAME1
HOLDPROF DS    X                             TSO-PROFILE HOLD AREA
MEMSW    DS    C                             MEMBER FOUND (Y/N)
*                                                (X=NO DDNAME FOUND)
         ORG
*
REALDD   DC    CL8' '                        TRUE DDNAME
REALMEM  DC    CL8' '                        TRUE MEMBERNAME
         DS    0D
GRABDD   DS    0CL8                          DYNAMIC-ALLOCATE DDNAME
         DC    CL6'KLIBXX'                   * FIXED PORTION
GRABDDNN DC    C'0 '                         * VARIABLE DIGITS
*
GRABDDNR DS    0PL8                          WORK FIELD FOR SAVE-RC
         DC    XL6'000000000000'
GRABDDNP DS    PL2                           WORK FIELD FOR GRABDDNN
*
DDNAME1  DS    CL8                           ARRAY FOR 50 DDNAMES
         DS    49CL8                         * HOLDS KDSNXX.. FOR SAVE
*                                            * HOLDS DDNLIST FOR RESET
*
         DS    0D                            ALIGNMENT FOR COBOL CALL
DSNAME#  EQU   50
DSNCTH   DS    H
DSNAMECT DS    H
DSNAME1  DS    (DSNAME#)CL44                 ARRAY FOR DSNAME
*
         DS    0D                            ALIGNMENT FOR COBOL CALL
RECORD   DS    0CL44                         INPUT/OUTPUT 'SAVE' RECORD
RECMEM   DS    CL8                           MEMBER-NAME
RECDDN   DS    CL8                           ORIGINAL DDNAME
         DC    CL31' '
*
         PRINT NOGEN
*    DCB FOR SAVE AND RESET PROCESSING (BOTH)
DYNAMDCB DCB   DDNAME=X,DSORG=PS,MACRF=(PM),RECFM=FB,LRECL=44,         X
               BLKSIZE=6204
         PRINT GEN
         TITLE '- PARSE MACROS'
PARSECT  IKJPARM
IDDN     IKJPOSIT DSNAME,LIST,DDNAM,                                   *
               PROMPT='DDNAME(MEMBER)',VALIDCK=MEMCK,                  *
               HELP='MEMBER SOUGHT ON LIBRARIES ALLOCATED TO DDNAME'
ISAVE    IKJKEYWD
         IKJNAME 'SAVE',ALIAS=('SA')
         IKJENDP
         TITLE '- DSECTS'
PDE      DSECT
PDEADDR  DS    A              ADDRESS OF DDNAME
PDELEN   DS    H              LENGTH OF  DDNAME
PDEFLAG  DS    X              FLAGS
         DS    X              (ALIGNMENT)
PDEADDR2 DS    A              ADDRESS OF DDNAME
PDELEN2  DS    H              LENGTH OF  DDNAME
PDEFLAG2 DS    X              FLAGS
         DS    X              (ALIGNMENT)
         DS    CL(8)                         (DSNAME PASSWORD IGNORED)
PDECHAIN DS    A              ADDRESS OF NEXT PDE IN LIST
         SPACE
DEVNAMET DSECT
DEVNUM   DS    F
DEVNAME  DS    CL8
DEVUNIT  DS    XL4
         SPACE
         IKJCPPL
CPPLLEN  EQU   *-CPPL
         SPACE
         IKJPPL
PPLLEN   EQU   *-PPL
         SPACE
         IKJUPT
         SPACE
         IKJDAPL
DAPLLEN  EQU   *-DAPL
         SPACE
         IKJDAP08
DAP08LEN EQU   *-DAPB08
         SPACE
         IKJDAP18
DAP18LEN EQU   *-DAPB18
         SPACE
         PRINT NOGEN
         CVT   DSECT=YES
         IHADCB DEVD=DA,DSORG=PS
         EJECT
*        COPY  EQUATES
**************************************************************
*   ABSOLUTE REGISTER EQUATES
**************************************************************
          SPACE
R0        EQU   0
R1        EQU   1           PARAMETER REGISTER
R2        EQU   2
R3        EQU   3
R4        EQU   4
R5        EQU   5
R6        EQU   6
R7        EQU   7
R8        EQU   8
R9        EQU   9
R10       EQU   10
R11       EQU   11
R12       EQU   12
R13       EQU   13          ADDRESS OF SAVE-AREA
R14       EQU   14          RETURN REGISTER
R15       EQU   15
          SPACE
**************************************************************
*   CONDITIONAL VALUES
**************************************************************
          SPACE
*   AFTER COMPARE INSTRUCTIONS (A:B)
          SPACE
H         EQU   2           A HIGH
L         EQU   4           A LOW
E         EQU   8           A EQUAL B
NH        EQU   13          A NOT HIGH
NL        EQU   11          A NOT LOW
NE        EQU   7           A NOT EQUAL B
          SPACE
*   AFTER ARITHMETIC INSTRUCTIONS
          SPACE
O         EQU   1           OVERFLOW     (AFTER TM - ALL ONES)
P         EQU   2           PLUS
M         EQU   4           MINUS        (AFTER TM - MIXED   )
Z         EQU   8           ZERO         (AFTER TM - ALL ZERO)
NP        EQU   13          NOT PLUS
NM        EQU   11          NOT MINUS
NZ        EQU   7           NOT ZERO
          SPACE
*   AFTER TEST UNDER MASK INSTRUCTIONS
          SPACE
NO        EQU   14          NOT ONES     (SEE ABOVE FOR O, M, & Z)
          SPACE
**************************************************************
         END
