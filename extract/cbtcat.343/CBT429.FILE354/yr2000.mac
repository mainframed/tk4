//YR2000   JOB
//*
//*    DSN=CBT.SOURCE(YR2000)
//*
/*ROUTE PRINT R7
//S EXEC HLASMCL,PARMC='NOALIGN,NORLD',CLASS='*',COND.LKED=(7,LT,ASM),
//  PARML=REUS
//ASM.SYSLIB DD DSN=SYS1.MACLIB
//   DD DSN=SYS1.MODGEN,DISP=SHR
//   DD DSN=SYS1.AMODGEN,DISP=SHR
//ASM.SYSIN DD *
*
* JAN    26/99 FIX PROCESSING OF //SYSIN MODULE NAMES..
*              ALSO CHECK FOR X'8015' RECORD IN LOAD MODULE.
*
* SEP    19/96 ADDED //SYSIN CODE TO READ UP TO 40 MODULE NAMES
*              TO BE SCANNED FOR IN THE MODULE.
*              HEX DATA (UP TO 4 BYTES) CAN BE SPECIFIED WITH X'..'
*              HEX DATA IS IN MULTIPLES OF 2..
*                ..EG.. X'0A10' IS THE CODE FOR SVC 10.
*
*
*              I AM TRYING TO DETERMINE IF THE MODULES IN THE
*              SPECIFIED LIBRARY CONTAIN THE 'TIME' SVC 11, OR USE
*              THE 'STCK' INSTRUCTION TO GET THE DATE......
*
*              OR, IF A PARM IS PASSED, I TRY TO FIND THE PARM IN
*              THE MODULES. THE PARM WOULD BE THE NAME OF A DATE
*              ROUTINE THAT IS CALLED BY OTHER ROUTINES
*
*              IF PARM=OFFSET, THE OFFSET OF STCK AND STCKC IS SHOWN.
*              IF PARM=DEBUG, ADDITIONAL INFO IS DISPLAYED.
*              IF PARM='DEBUG=MODNAME', THE PROGRAM WILL ABEND WHEN
*                 MODULE MODNAME IS FOUND.
*              IF PARM=NAME, THE NAME WILL BE SEARCHED FOR IN
*                 THE MODULE.
*
*              PARM ORDER MUST BE OFFSET,DEBUG,NAME
*
*
*        REGISTER EQUATES
*
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4                  BASE REG 2
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12                 BASE REG 1
R13      EQU   13
R14      EQU   14
R15      EQU   15
*
*        ENTRY POINT
*
YR2000   CSECT
YR2000   AMODE 31
YR2000   RMODE 24
         USING *,R15      GET TEMP ADDRESSABILITY
         B     AROUND             BRANCH AROUND DUMP TITLE
         DC    AL1(EYELTH)        LTH OF EYE CATCHER
EYECATCH DS    0C
         DC    C'YR2000 '         PROGRAM NAME
         DC    C' VERSION 4.0 '   VERSION
         DC    CL8'&SYSDATE'      DATE WRITTEN
         DC    CL6'&SYSTIME'      TIME WRITTEN
         DC    C'..ADD CHECK FOR CVTDATE ACCESS'    COMMENT
*        DC    C'..ADD //SYSIN INPUT AND HEX DATA'    COMMENT
*        DC    C'..HANDLE AMODE 31 MODULES'    COMMENT
EYELTH   EQU   *-EYECATCH         LTH OF EYE CATCHER
         SPACE 1
AROUND   DS    0H
         LA    R1,0(0,R1)         CLEAR HI-ORDER BYTE FOR 31 BIT
         LA    R13,0(0,R13)       CLEAR HI-ORDER BYTE FOR 31 BIT
         BSM   R14,0              SAVE CURRENT AMODE
         STM   R14,R12,12(R13)  SAVE REGISTERS
*        LR    R12,R15            LOAD 1ST BASE REG.
*        LR    R14,R13            SAVE R13
*        BAL   R13,AROUND2        SET R13 AS 1ST BASE ALSO...
         BAL   R14,AROUND2        R14 -> AT OUR SAVE AREA...
         SPACE 1
SAVEAREA DC    18F'0'
         SPACE 1
AROUND2  DS    0H
         ST    R13,4(R14)      SAVE REGS 13 AND
         ST    R14,8(R13)      BACK CHAIN
         LR    R13,R14         GET SAVE AREA ADDRESS
         LA    R13,0(0,R13)       CLEAR HI-ORDER BYTE SET BY BAL..
         DROP  R15
*        USING YR2000,R13,R12,R4  SET ADDRESSABILITY
         USING SAVEAREA,R13,R12,R4 SET ADDRESSABILITY
         LA    R12,4095(0,R13)    LOAD 2ND BASE REG
         LA    R12,1(0,R12)       ''
         LA    R4,4095(0,R12)     LOAD 3RD BASE REG
         LA    R4,1(0,R4)         ''
*        ST    R14,4(R13)      SAVE REGS 13 AND
*        LA    R14,SAVEAREA
*        ST    R14,8(R13)      BACK CHAIN
*
****     LA    R14,SAVEAREA
*        ST    R13,4(R14)      SAVE REGS 13 AND
*        ST    R14,8(R13)      BACK CHAIN
*        LR    R13,R14         GET SAVE AREA ADDRESS
         ST    R1,SAVER1          SAVE REG 1
*
*        OPEN OUTPUT DATASET
*
         OPEN  (PRINT,(OUTPUT)),MODE=31  OPEN PRINT FILE
         TM    PRINT+48,X'10'     DID IT OPEN?
         BZ    BADBAD             NO, ABEND
*
*        PRINT DISCLAIMER....
*
         LA    R5,DISCLAIM        R5 -> AT DISCLAIMER
         SPACE 1
DISMSG   DS    0H
         MVC   MBRNAME(LDIS),0(R5) PUT MSG IN PRINT LINE
         PUT   PRINT,SCRCARD      PRINT IT
         LA    R5,LDIS(0,R5)      R5 -> AT NEXT LINE
         CLC   =C'END OF DISLAIM',0(R5) END OF DISCLAIMER?
         BNE   DISMSG             NO, GO PRINT NEXT LINE
         MVI   MBRNAME,C' '       CLEAR PRINT LINE
         MVC   MBRNAME+1(CLRLTH1),MBRNAME ''
*
*        PRINT HEADING 1
*
         LA    R5,HEADING         R5 -> AT HEADING
         SPACE 1
HEADMSG  DS    0H
         MVC   MBRNAME(LHEAD),0(R5) PUT MSG IN PRINT LINE
         PUT   PRINT,SCRCARD      PRINT IT
         LA    R5,LHEAD(0,R5)     R5 -> AT NEXT LINE
         CLC   =C'END OF HEADING',0(R5) END OF HEADING?
         BNE   HEADMSG            NO, GO PRINT NEXT LINE
         MVI   MBRNAME,C' '       CLEAR PRINT LINE
         MVC   MBRNAME+1(CLRLTH1),MBRNAME ''
*
*        GET DATASET NAME AND PRINT IT
*
*
         RDJFCB INPDSA            GET JFCB INFO
         LTR   R15,R15            WELL???
         BNZ   NOMBRS             NO, NOTHING TO PROCESS
*
         MVC   PRTDSN,JFCBDSNM    YES, PUT DSNAME INTO MSG
         MVC   MBRNAME(LDSNMSG),DSNMSG PUT MSG IN PRINT LINE
         PUT   PRINT,SCRCARD      PRINT IT
         MVI   MBRNAME,C' '       CLEAR PRINT LINE
         MVC   MBRNAME+1(CLRLTH1),MBRNAME ''
*
*        GET PARM, IF ANY
*
GETPARM  DS    0H
         L     R1,SAVER1     RESTORE REG 1
         L     R2,0(0,R1)    SET ADDRESS OF PARAMETER STRING
         SR    R3,R3         ZERO R3 (LENGTH OF PARAMETER STRING)
         ICM   R3,3,0(R2)    LOAD PARAMETER LENGTH IN R3
         BZ    NOPARM             AIN'T NONE, ON WE GO
         LA    R2,2(0,R2)         R2 -> AT PARMS
*
         CLC   =C'OFFSET',0(R2)   WANT OFFSET INFO?
         BNE   NOFFSET            NO
         OI    FLAG1,X'20'        YES, SAY SHOW OFFSET
         LA    R2,7(0,R2)         R2 -> PAST "OFFSET,"
         SH    R3,=H'7'           R3 = LTH LEFT
*        LTR   R3,R3              ANY LTH LEFT ?
         BNP   NOPARM             NONE LEFT...
*
NOFFSET  DS    0H
         CLC   =C'DEBUG',0(R2)    WANT DEBUG INFO?
         BNE   NOTDEBUG           NO
         OI    FLAG1,X'80'        YES, SAY DEBUG
*
         CLC   =C'DEBUG=',0(R2)   WANT DEBUG INFO AND ABEND?
         BNE   DEBUG1             NO
         OI    FLAG1,X'40'        YES, SAY ABEND
         LA    R2,1(0,R2)         R2 -> PAST = SIGN
         SH    R3,=H'1'           R3 = LTH LEFT
*
DEBUG1   DS    0H
         LA    R2,6(0,R2)         R2 -> PAST "DEBUG,"
         SH    R3,=H'6'           R3 = LTH LEFT
         BNP   NOPARM             NONE LEFT...
*
NOTDEBUG DS    0H
         CH    R3,=H'8'   IF LENGTH OF PARAMETER IS TOO LONG,
         BH    BADPARM    THEN ERROR
*
*        LA    R2,2(0,R2)         R2 -> TO START OF PARAMETER
         MVC   SCRDATE,0(R2)      SAVE IT
         STC   R3,PARMLTH         SAVE ITS LTH
*
NOPARM   DS    0H
*
*        OPEN LIBRARY DIRECTORY TO GET ALL MEMBERS OF THE PDS
*
         OPEN  (INPDS,(INPUT)),MODE=31
*
*        ISSUE GETMAIN FOR MEMBER AREA
*
         SR    R5,R5           ZERO REG 5
         L     R5,=F'9000'     WANT ROOM FOR MAXIMUM MEMBERS
         SLL   R5,3        TIMES 8 PER MEMBER NAME
         GETMAIN R,LV=(R5),SP=10,LOC=BELOW
         ST    R1,MBRAREA  SAVE AREA ADDRESS
         LR    R7,R1       AND LOAD INTO R7
         SRL   R5,3        RESET TO NUMBER OF MEMBERS ALLOWED
         SR    R9,R9       ZERO MEMBER COUNTER
         SR    R11,R11     ZERO MEMBER COUNTER
*
*        GET DIRECTORY BLOCK
*
DIRREAD  EQU   *
*
*            GO TO 24 BIT MODE ADDRESSING
*
*        LA    R1,*+4+2           GET INTO 24 BIT MODE
*        BSM   0,R1               ''
*
         LA    R6,DIRREC
         READ  UT1DECB,SF,INPDS,(R6),,S
         CHECK UT1DECB
*
*        GET BACK TO 31 BIT MODE ADDRESSING
*
*        CNOP  0,4                ALIGN ON A FULLWORD BOUNDARY      RH
*        L     R1,*+8             GET 31 BIT MODE ADDRESS           RH
*        BSM   0,R1               GET INTO 31 BIT MODE              RH
*        BSM   0,R1               TO FILL 4 BYTES                   RH
**       DS    0F                 ALIGN ON A FULLWORD BOUNDARY      RH
*        DC    X'80',AL3(*+3)     NEXT ADDRESS IS 31 BIT MODE       RH
*
         CLC   0(2,R6),=H'0'  IF LENGTH IS ZERO END DIRECTORY SEARCH
         BE    LOADMBR
*
         LR    R1,R6          SAVE BEGINNING OF BLOCK
         AH    R1,0(R6)       POINT TO END OF BLOCK
         SH    R1,=H'2'           -2 FOR LTH FIELD....
         ST    R1,ENDADDR         SAVE END ADDRESS
         LA    R6,2(0,R6)    POINT PAST LENGTH FIELD
*
THISMBR  EQU   *
*        CR    R6,R1         IF AT END OF BLOCK
         C     R6,ENDADDR    IF AT END OF BLOCK
         BNL   DIRREAD       GET ANOTHER ONE
         CLI   0(R6),X'FF'   IF MEMBER HAS HIGH VALUES END DIR. SEARCH
         BE    LOADMBR
         CLI   0(R6),X'00'   IF MEMBER HAS LOW VALUES BYPASS SAVE
         BE    NEXTMBR
         LA    R11,1(0,R11)       COUNT ALL MEMBERS
         TM    11(R6),X'80'   IF MEMBER IS AN ALIAS, BYPASS SAVE
         BO    ALIASMBR
*
         MVC   0(8,R7),0(R6) SAVE MEMBER NAME IN MEMBER AREA
         LA    R7,8(0,R7)      POINT TO NEXT ENTRY IN MEMBER AREA
         LA    R9,1(0,R9)      INCREMENT MEMBER COUNT
         CR    R9,R5         IS MEMBERS UP TO MAXIMUM?
         BL    NEXTMBR            NOT YET, ON WE GO...
         MVC   MBRNAME(LMAXMBR),MAXMBR PUT MSG IN PRINT LINE
         PUT   PRINT,SCRCARD      PRINT IT
         MVI   MBRNAME,C' '       CLEAR PRINT LINE
         MVC   MBRNAME+1(CLRLTH1),MBRNAME ''
         B     LOADMBR       END DIRECTORY SEARCH
*        BNL   LOADMBR       IF YES, END DIRECTORY SEARCH
*        B     NEXTMBR            ON WE GO...
*
ALIASMBR DS    0H
         TM    FLAG1,X'80'        DEBUGGING?
         BZ    NEXTMBR            NO
         MVC   MBRNAME,0(R6)     SAVE MEMBER NAME
         MVC   ALIASNAM,36(R6)    SAVE ALIAS MEMBER NAME
         MVC   PSDATE(LALIASMS),ALIASMSG PUT MSG IN PRINT
         PUT   PRINT,SCRCARD      PRINT IT
         MVI   MBRNAME,C' '       CLEAR PRINT LINE
         MVC   MBRNAME+1(CLRLTH1),MBRNAME ''
*        MVC   PSTYPE(L'ALIASMSG),ALIASMSG PUT MSG IN PRINT
*        PUT   PRINT,SCRCARD      PRINT IT
*        MVI   PSTYPE,C' '        CLEAR PRINT LINE
*        MVC   PSTYPE+1(CLRLTH2),PSTYPE ''
*
NEXTMBR  EQU   *
         NI    11(R6),31      LOOK AT ONLY THE "C" FIELD IN ENTRY
         SR    R8,R8
         IC    R8,11(R6)       MOVE "C" FIELD TO R8
         SLL   R8,1           MULTIPLY BY 2
         LA    R6,12(R8,R6)     POINT TO NEXT ENTRY IN DIRECTORY BLOCK
         B     THISMBR        BRANCH TO PROCESS NEXT ENTRY
*
*        THIS ROUTINE LOADS EACH MEMBER OF THE PDS
*
LOADMBR  EQU   *
         CLOSE INPDS,MODE=31    CLOSE DIRECTORY DCB
*
         LTR   R9,R9          IF NO MEMBERS THEN
         BZ    NOMBRS         LEAVE ROUTINE WITH MESSAGE
*
*        PRINT NUMBER OF ALIAS MEMBERS, IF ANY
*
PRTCOUNT DS    0H
         CR    R11,R9             ANY ALIAS MEMBERS?
         BE    PRTHEAD2           NO, NO MSG
         SR    R11,R9             R11 = NBR ALIAS MEMBERS
         CVD   R11,WORKD          PUT NBR MBRS IN MSG
         MVC   PRTCNT,PATTERN
         ED    PRTCNT,WORKD+4
*
         MVC   MBRNAME(LCNTMSG),CNTMSG PUT MSG IN PRINT LINE
         PUT   PRINT,SCRCARD      PRINT IT
         MVI   MBRNAME,C' '       CLEAR PRINT LINE
         MVC   MBRNAME+1(CLRLTH1),MBRNAME ''
*
*        PRINT HEADING 2
*
PRTHEAD2 DS    0H
         LA    R5,HEADING2        R5 -> AT HEADING 2
         SPACE 1
HEADMSG2 DS    0H
         MVC   MBRNAME(LHEAD),0(R5) PUT MSG IN PRINT LINE
         PUT   PRINT,SCRCARD      PRINT IT
         LA    R5,LHEAD(0,R5)     R5 -> AT NEXT LINE
         CLC   =C'END OF HEADING',0(R5) END OF HEADING?
         BNE   HEADMSG2           NO, GO PRINT NEXT LINE
         MVI   MBRNAME,C' '       CLEAR PRINT LINE
         MVC   MBRNAME+1(CLRLTH1),MBRNAME ''
*
*
*        ISSUE GETMAIN TO HOLD BLOCKS
*
LOADMBR1 EQU   *
         SR    R5,R5           ZERO REG 5
         L     R5,=F'32000'    WANT ROOM FOR MAXIMUM
         GETMAIN R,LV=(R5),SP=10,LOC=BELOW
         ST    R1,BLKAREA  SAVE AREA ADDRESS
*
         OPEN  (INPDSA,(INPUT)),MODE=31 OPEN PDS DATASET
*                                                                     *
*
         OPEN  (SYSIN,(INPUT)),MODE=31   OPEN INPUT DCB
         TM    SYSIN+48,X'10'     DID IT OPEN ?
         BZ    NOSYSIN            NO
         LA    R6,MODTABLE        R6 -> AT MOD NAME TABLE
         USING MODENTRY,R6        SET TABLE BASE
         CLI   MODLTH,X'00'       WAS THERE A PARM?
         BE    READSYS            NO
         LA    R6,MODTBLTH(0,R6)  R6 -> AT NEXT ENTRY
         SPACE 1
READSYS  DS    0H
         GET   SYSIN,MBRNAME           GET INPUT RECORD
         LA    R1,MBRNAME         R1 -> TO INPUT DATA
         SPACE 1
         CLI   MODLTH,X'FF'       STILL ROOM IN TABLE?
         BE    EOFREAD            NO
         CLC   =C'X''',0(R1)      IS INPUT HEX?
         BE    GETHEX             YES, GO SET IT UP
         SPACE 1
READSYS1 DS    0H
         LA    R2,MBRNAME         R2 -> TO INPUT DATA
         SPACE 1
READSYS2 DS    0H
         CLI   0(R2),C' '         END OF MODULE NAME?
         BE    READSYS3           YES
         LA    R2,1(0,R2)         NO, R2 -> AT NEXT CHAR
         B     READSYS2           GO CHECK IT
         SPACE 1
READSYS3 DS    0H
         SR    R2,R1              R2 = MODULE NAME LTH
         CH    R2,=H'8'   IF LENGTH OF INPUT IS TOO LONG,
         BH    BADINPUT   THEN ERROR
*
         MVC   MODNAME,0(R1)      PUT NAME IN TABLE
         MVC   MODCTR,=H'0'       SET COUNT TO ZERO
         SPACE 1
READSYS4 DS    0H
         STC   R2,MODLTH          SAVE IT
         LA    R6,MODTBLTH(0,R6)  R6 -> AT NEXT ENTRY
         B     READSYS            GET NEXT NAME
         SPACE 1
BADINPUT DS    0H
*        MVC   MBRNAME,=CL8'BADINP*'
*        MVC   PSDATE(8),0(R1)    PUT 1ST 8 BYTES IN MSG
         MVC   PSTYPE+9(L'INPMSG),INPMSG PUT ERROR MSG IN PRINT
         B     BADPARM2           THEN ERROR
INPMSG   DC    C'SYSIN DATA OVER 8 BYTES'
         SPACE 1
GETHEX   DS    0H
         LA    R1,MBRNAME+2       R1 -> TO INPUT DATA
         LA    R2,MBRNAME+2       R2 -> TO INPUT DATA
         SPACE 1
GETHEX2  DS    0H
         CLI   0(R2),C''''        END OF HEX DATA?
         BE    GETHEX3            YES
         LA    R2,1(0,R2)         NO, R2 -> AT NEXT CHAR
         B     GETHEX2            GO CHECK IT
         SPACE 1
GETHEX3  DS    0H
         SR    R2,R1              R2 = HEX DATA LTH
*
*        STC   R2,MODLTH          SAVE IT
         LR    R7,R2              R7 = LTH
         SRL   R7,1               DIVIDE BY 2
         SLL   R7,1               MULTIPLY BY 2
         CR    R7,R2              STILL THE SAME?
*        BE    GETHEX4            YES, GO SAVE IT
         BNE   BADHEX             NO, TOO BAD
         SPACE 1
GETHEX4  DS    0H
         CH    R2,=H'8'           TOO MANY HEX DIGITS?
         BH    BADHEX2            YES
*
         XC    DWORD,DWORD        CLEAR DOUBLE WORD....
         SR    R14,R14            CLEAR R14
*        LA    R15,DWORD          R15 -> AT DWORD
         BCTR  R7,0               R7 = HEX LTH
         EX    R7,HEXMVC          PUT DATA IN DWORD
         EX    R7,HEXTR           TRANSLATE TO PACKABLE DATA
         EX    R2,HEXPACK         PACK IT TO MAKE HEX...
         SRL   R2,1               R2/2 = LTH OF PACKED DATA...
         LA    R14,DWORD2+7       R14 -> AT DWORD2
         SR    R14,R2             R14 S/B -> AT HEX DATA...
         SRL   R7,1               DIVIDE BY 2
*        BCTR  R7,0               R7 = HEX LTH OF HEX DATA
         EX    R7,HEXMVC2         PUT DATA IN TABLE
         MVI   MODTYPE,C'H'       SAY DATA IS HEX
         B     READSYS4           GO SAVE IT
         SPACE 1
DWORD    DC    D'0'
DWORD2   DC    D'0'
HEXMVC   MVC   DWORD(0),0(R1)     SET UP DATA
HEXMVC2  MVC   MODNAME(0),0(R14)  PUT NAME IN TABLE
HEXTR    TR    DWORD(0),TRTAB-193 TRANSLATE
HEXPACK  PACK  DWORD2,DWORD(0)    PACK IT
HEXMSG   DC    C'HEX DATA MUST BE A MULTIPLE OF 2'
HEXMSG2  DC    C'HEX DATA MUST BE LESS THAN 9 BYTES LONG'
*RTAB    DC    C' 0123456789ABCDEF'
TRTAB    DC    X'0A0B0C0D0E0F'    A - F
         DC    41X'00'            G - 0-1
         DC    X'00010203040506070809'    0 - 9
         SPACE 1
BADHEX   DS    0H
*        MVC   MBRNAME,=C'BADHEX*'
*        MVC   PSDATE(8),0(R1)    PUT 1ST 8 BYTES IN MSG
         MVC   PSTYPE+9(L'HEXMSG),HEXMSG PUT ERROR MSG IN PRINT
         B     BADPARM2           THEN ERROR
*        PUT   PRINT,SCRCARD      PRINT IT
*        MVI   MBRNAME,C' '       CLEAR PRINT LINE
*        MVC   MBRNAME+1(CLRLTH1),MBRNAME ''
*        B     BADPARM    THEN ERROR
*        B     READSYS          GET NEXT MEMBER
         SPACE 1
BADHEX2  DS    0H
*        MVC   MBRNAME,=C'BADHEX*'
*        MVC   PSDATE(8),0(R1)    PUT 1ST 8 BYTES IN MSG
         MVC   PSTYPE+9(L'HEXMSG2),HEXMSG2 PUT ERROR MSG IN PRINT
         B     BADPARM2           THEN ERROR
*        MVC   PSTYPE(L'HEXMSG2),HEXMSG2 PUT ERROR MSG IN PRINT
*        PUT   PRINT,SCRCARD      PRINT IT
*        MVI   MBRNAME,C' '       CLEAR PRINT LINE
*        MVC   MBRNAME+1(CLRLTH1),MBRNAME ''
*        B     BADPARM    THEN ERROR
*        B     READSYS          GET NEXT MEMBER
         SPACE 1
         AGO   .HEX1
GETHEX5  DS    0H
         IC    R14,0(R1)          R14 = CHAR TO CONVERT
         STC   R14,2(R15)         SAVE IT
         SRL   R14,4              DROP HI ORDER HALF OF BYTE
         STC   R14,1(R15)         SAVE IT
         SH    R2,=H'2'           R2 = LTH LEFT
         LTR   R2,R2              ANY LEFT?
         BZ    GETHEX6            NO
         LA    R1,1(0,R1)         R1 -> AT NEXT BYTE
         LA    R15,2(0,R15)       R15 -> AT NEXT DWORD BYTE
         B     GETHEX5            GO SET IT UP
         SPACE 1
GETHEX9  DS    0H
         LA    R6,MODTBLTH(0,R6)  R6 -> AT NEXT ENTRY
         B     READSYS1           GET NEXT NAME
.HEX1    ANOP
         SPACE 1
EOFREAD  DS    0H
         CLOSE (SYSIN),MODE=31    CLOSE INPUT DCB
*
NOSYSIN  DS    0H
         L     R6,MBRAREA    SET ADDRESS OF MEMBER AREA
         ST    R6,MBRADDR    SET ADDRESS OF MEMBER
         SR    R7,R7             ZERO REGISTER 7
         SPACE 1
*
*        FOR EACH MEMBER IN AREA WE WANT ISSUE FIND FOR IT IN PDS
*
FINDMBR2 DS    0H
         MVC   MBRNAME,0(R6)     SAVE MEMBER NAME
         MVC   DELNAME,0(R6)     SAVE MEMBER NAME FOR DELETE...
         FIND  INPDSA,(R6),D
         LTR   R15,R15
         BZ    READBLK            OKAY, ON WE GO
         MVC   PSTYPE(L'BADFIND),BADFIND PUT ERROR MSG IN PRINT
         PUT   PRINT,SCRCARD      PRINT IT
         MVI   MBRNAME,C' '       CLEAR PRINT LINE
         MVC   MBRNAME+1(CLRLTH1),MBRNAME ''
         B     GETNEXT          GET NEXT MEMBER
*
*        READ A BLOCK FROM PDS MEMBER
*        WE ARE TRYING TO GET THE LINK DATE...
*
READBLK  EQU   *
         L     R8,BLKAREA        RESTORE BLOCK AREA ADDRESS
         READ  UT1ADECB,SF,INPDSA,(R8),19069,S
         CHECK UT1ADECB
*
*        DETERMINE IF CORRECT RECORD - LOOK FOR X'8011'
*
         CLC   0(2,R8),=X'8011'
         BE    GOT8011            IF GOT THE RIGHT RECORD
         CLC   0(2,R8),=X'8015'   PISS-ASS L2?
         BE    GOT8011            YES,  GOT THE RIGHT RECORD
         CLC   0(2,R8),=X'0100'   GOT TO EXECUTABLE CODE?
         BE    LOADMEM            YES, CAN'T GET LINK DATE
         B     READBLK
*
*        IF HAVE THE X'8011' RECORD THEN SAVE THE DATE
*
GOT8011  EQU   *
         UNPK  WORKD,15(3,R8)
         MVC   PSDATE,WORKD+3
*
*        LOAD THE MODULE SO WE CAN SCAN IT
*
LOADMEM  EQU   *
         TM    FLAG1,X'80'        DEBUGGING?
         BZ    AAA                NO
         MVC   PSTYPE(L'LOADMSG),LOADMSG PUT MSG IN PRINT
         PUT   PRINT,SCRCARD      PRINT IT
         MVI   PSTYPE,C' '        CLEAR PRINT LINE
         MVC   PSTYPE+1(CLRLTH2),PSTYPE ''
*
AAA      DS    0H
         LA    R0,MBRNAME         R0 -> AT MEMBER NAME
*                                 LOAD THE MODULE
         LOAD  EPLOC=(0),DCB=INPDSA,ERRET=XXX
*
XXX      DS    0H
         LTR   R15,R15            WAS LOAD OKAY?
         BZ    GOTREC             YES, ON WE GO
*
BBB      DS    0H
         MVC   PSTYPE(L'BADLOAD),BADLOAD  PUT ERROR MSG IN PRINT
         PUT   PRINT,SCRCARD      PRINT IT
         MVI   MBRNAME,C' '       CLEAR PRINT LINE
         MVC   MBRNAME+1(CLRLTH1),MBRNAME ''
         B     GETNEXT          GET NEXT MEMBER
*
*        SET UP TO LOAD NEXT MEMBER
*
GETNEXT  EQU   *
         L     R6,MBRADDR    SET ADDRESS OF MEMBER
         LA    R6,8(0,R6)
         ST    R6,MBRADDR    SET ADDRESS OF MEMBER
         BCT   R9,FINDMBR2    IF MORE MEMBERS
         B     CLOSPDS
*
*        NOW  THE MODULE IS LOADED, GO FIND THE LOAD ADDRESS,
*        AS R1 IS THE LTH IN DOUBLEWORDS, AND R0 IS THE ENTRY
*        ADDRESS, NOT THE LOAD ADDRESS.
*
*
GOTREC   EQU   *
*
*        CHAIN  THROUGH OUR CDE CHAIN TO GET THE LOAD ADDRESS....
*
         L     R10,PSATOLD-PSA    R10 -> TO OUR TCB
*        ICM   R10,7,TCBJPQ-TCB(R10) R10 -> TO OUR LAST CDE
*        BP    CHKNAME            THERE IS ONE, SO USE IT
         ICM   R10,15,TCBLLS-TCB(R10) R10 -> TO OUR LAST LLE
         BZ    BBB                NONE, TOO BAD
*
CHKNAME  DS    0H
         USING LLE,R10            SET LLE BASE
         ICM   R11,15,LLECDPT     R11 -> TO THIS LLE'S CDE
*
         USING CDENTRY,R11        SET CDE BASE
         CLC   MBRNAME,CDNAME     IS IT THE MODULE WE LOADED?
         BE    GOTCDE             YES, CONTINUE
         ICM   R10,15,LLECHN      NO, R10 -> AT NEXT LLE
*        ICM   R10,7,CDCHAIN      NO, R10 -> AT NEXT CDE
         BNZ   CHKNAME            GO CHECK IT
         B     BBB                NOT FOUND, WE BLEW IT....
*
GOTCDE   DS    0H
         DROP  R10                DROP LLE BASE
         ICM   R10,15,CDXLMJP     R10 -> TO THE MODULES EXTENT CB
         BNZ   GOTXLMJP           GOT IT, GO CHECK IT
*                                 NO XLMJP.....
         TM    CDATTRB,CDELPDE    IS THIS A CDE OR AN LPDE?
         BZ    NOTLPDE            CDE, USE THE LOAD ADDRESS & LTH
         DROP  R11                DROP CDE BASE
*
*                                 IT'S AN LPDE...
*
GOTLPDE  DS    0H
         USING LPDE,R11           SET LPDE BASE
         L     R8,LPDEXTAD        R8 -> TO LOADED MEMBER
         L     R5,LPDEXTLN        R5 = IT'S LTH IN BYTES
         DROP  R11                DROP LPDE BASE
         B     READBLK2           ON WE GO....
*
*                                 NOT FOUND, USE R0 AND R1 VALUES
*
NOTLPDE  DS    0H
         LR    R8,R0              R8 -> TO LOADED MEMBER
         LR    R5,R1              R5 = IT'S LTH IN DOUBLEWORDS
         MH    R5,=H'8'           R5 = IT'S LTH IN BYTES
         B     READBLK2           ON WE GO...
*
GOTXLMJP DS    0H
         USING XTLST,R10          SET XTLST BASE
         ICM   R5,7,XTLMSBLN      R5 = LTH OF LOADED MODULE
         L     R8,XTLMSBAD        R8 -> TO LOADED MODULE
         DROP  R10                DROP XTLST BASE
*        MH    R1,=H'8'           CHANGE LTH FROM DOUBLEWORDS TO BYTES
*
READBLK2 DS    0H
         ST    R8,LOADADDR        SAVE ADDR OF LOADED MEMBER
         LR    R10,R8             R10 -> TO LOADED MEMBER
         AR    R10,R5             R10 -> TO END OF MEMBER
         BCTR  R10,0              R10 -> TO LAST BYTE TO TEST
         TM    FLAG1,X'40'        ABEND AT SPECIFIC MODULE?
         BZ    TESTTYPE           NO
         CLC   SCRDATE,MBRNAME    SCRDATE WILL ABEND BE MODULE NAME
         BNE   TESTTYPE
         DC    H'0'
         SPACE 1
TESTTYPE DS    0H
*
*            GO TO ADDRESSING MODE OF LOADED PROGRAM
*
*        ST    R8,LOADADDR        SAVE ADDR OF LOADED MEMBER
*        ICM   R1,1,LOADADDR      GET MODE OF LOADED MODULE
*        LA    R1,*+4+2           GET INTO 24 BIT MODE
**             GET INTO PROPER MODE FOR TESTS                       RH
*        BSM   0,R1               ''
*
*
*        GET INTO 31 BIT MODE ADDRESSING
*
         BAS  R14,@AMODE31
*
*        CNOP  0,4                ALIGN ON A FULLWORD BOUNDARY      RH
*        L     R1,*+8             GET 31 BIT MODE ADDRESS           RH
*        BSM   0,R1               GET INTO 31 BIT MODE              RH
*        BSM   0,R1               TO FILL 4 BYTES                   RH
**       DS    0F                 ALIGN ON A FULLWORD BOUNDARY      RH
*        DC    X'80',AL3(*+3)     NEXT ADDRESS IS 31 BIT MODE       RH
*
*              SEE IF PAST END OF MODULE
*
         LA    R1,2(0,R8)         R1 -> END OF INSTRUCTION...
         CR    R1,R10             PAST END OF MODULE?
*        BH    NEXTBYTE           YES, CAN'T TEST
         BL    CHKALIGN           NO, CHECK ALIGNMENT
         LA    R5,1               SET R5 SO BCT AT LABEL NEXTBYT2
*                                 DOESN'T BRANCH...
         B     NEXTBYTE           END OF MODULE...
*
CHKALIGN DS    0H
*
*              SEE IF ADDRESS IS DIVISIBLE BY 2
*
*        L     R11,LOADADDR       R11 = ADDR OF LOADED MEMBER
*        SR    R11,R8             R11 = OFFSET TO INST
         LR    R11,R8             R11 = ADDR OF INST
         S     R11,LOADADDR       R11 = OFFSET TO INST
         LR    R1,R11             R1 = OFFSET TO INST
         SRL   R1,1               DIVIDE BY 2
         SLL   R1,1               MULTIPLY BY 2
         CR    R1,R11             STILL THE SAME?
*                                 NO, NOT AN INSTRUCTION
         BNE   TESTDATA           BUT GO SEE IF IT IS A NAME/DATA..
*
*
*        SCAN THE MODULE TO SEE IF TIME IS INVOLVED...
*
TEST1    DS    0H
         CLC   0(2,R8),=X'0A0B'   POSSIBLE CALL TO SVC 11?
         BNE   TEST2              NO, DO NEXT TEST
*
*              OKAY, WE HAVE AN SVC 11. CHECK PREVIOUS
*              INSTRUCTIONS FOR VALIDITY...
*
*                                 CHECK FOR SR OR LR INST
*
         LR    R11,R8             R11 -> AT SVC 11
         SH    R11,=H'2'          R11 -> BACK 2 BYTES
         CLC   0(2,R11),=X'1B11'  PREV INST SR 1,1 ?
         BE    GOTSVC11           YES, PROBABLY A REAL SVC11
         CLC   0(1,R11),=X'18'    PREV INST LR ?
         BE    GOTSVC11           YES, PROBABLY A REAL SVC11
*
*                                 CHECK FOR LA R0 OR LA R1 INST
*
         SH    R11,=H'2'          R11 -> BACK 2 MORE BYTES
         CLC   0(2,R11),=X'4100'  PREV INST LA R0,XX ?
         BE    GOTSVC11           YES, PROBABLY A REAL SVC11
         CLC   0(2,R11),=X'4110'  PREV INST LA R1,XX ?
         BNE   TEST2              NO, DO NEXT TEST
*        BE    GOTSVC11           YES, PROBABLY A REAL SVC11
*
GOTSVC11 DS    0H
         LR    R11,R8             R11 = ADDR OF INST IN CASE DEBUG
         LA    R8,2(0,R8)         R8 -> TO NEXT INST.
         BCTR  R5,0               SET R5 FOR BCT LATER...
*
*        SEE IF NEXT BYTE COULD BE A VALID INSTRUCTION
*
         TRT   0(1,R8),INSTTAB    LOOK FOR VALID INSTRUCTION
         BZ    NEXTBYT2           NOT VALID, CHECK NEXT BYTE...
         LH    R1,SVCCTR          VALID, COUNT IT
         LA    R1,1(0,R1)         ADD ONE
         STH   R1,SVCCTR          SAVE NEW COUNT
         L     R1,SVCCTR2         VALID, COUNT IT
         LA    R1,1(0,R1)         ADD ONE
         ST    R1,SVCCTR2         SAVE NEW COUNT
         TM    FLAG1,X'20'        WANT OFFSET INFO?
         BZ    NEXTBYT2           NO
*        LR    R11,R8             R11 = ADDR OF INST IN CASE DEBUG
         S     R11,LOADADDR       R11 = OFFSET TO INST
         ST    R11,DWORD          SAVE OFFSET
         MVC   SHOWMSG(20),=C'TIME MACRO AT OFFSET'
         BAL   R11,SHOWOFF        GO PRINT IT
         B     NEXTBYT2           CHECK FOR MORE
*                                 SAY POSSIBLE TIME MACRO
*        MVC   PSTYPE(19),=C'TIME MACRO (SVC 11)'
*        B     CHKINST            YES, RECORD IS FINISHED
*
TEST2    DS    0H
         CLC   =X'B205',0(R8)     POSSIBLE STCK INSTRUCTION?
         BNE   TEST3              NO, DO NEXT TEST
*
*              SEE IF ADDRESS IS DIVISIBLE BY 2
*
****     L     R11,LOADADDR       R11 = ADDR OF LOADED MEMBER
****     SR    R11,R8             R11 = OFFSET TO INST
*        LR    R11,R8             R11 = ADDR OF INST
*        S     R11,LOADADDR       R11 = OFFSET TO INST
*        LR    R1,R11             R1 = OFFSET TO INST
*        SRL   R1,1               DIVIDE BY 2
*        SLL   R1,1               MULTIPLY BY 2
*        CR    R1,R11             STILL THE SAME?
*        BNE   NEXTBYTE           NO, NOT AN INSTRUCTION
*
*              OKAY, WE HAVE AN STCK. CHECK PREVIOUS
*              INSTRUCTIONS FOR VALIDITY...
*
*              SEE IF WE ARE THE BACK END OF A 4 BYTE INSTRUCTION
*
         LR    R11,R8             R11 -> AT CODE
         SH    R11,=H'2'          R11 -> BACK 2 BYTES
         TRT   0(1,R11),INSTTAB4  LOOK FOR VALID INSTRUCTION
         BNZ   TEST3              VALID, SO STCK IS NOT....
*
*              SEE IF WE ARE THE MIDDLE OF A 6 BYTE INSTRUCTION
*
         TRT   0(1,R11),INSTTAB6  LOOK FOR VALID INSTRUCTION
         BNZ   TEST3              VALID, SO STCK IS NOT....
*
*              SEE IF WE ARE THE BACK END OF A 6 BYTE INSTRUCTION
*
         LR    R11,R8             R11 -> AT CODE
         SH    R11,=H'4'          R11 -> BACK 4 BYTES
         TRT   0(1,R11),INSTTAB6  LOOK FOR VALID INSTRUCTION
         BNZ   TEST3              VALID, SO STCK IS NOT....
*
*                                 CHECK FOR 2 BYTE INST.
*
         LR    R11,R8             R11 -> AT CODE
         SH    R11,=H'2'          R11 -> BACK 2 BYTES
         TRT   0(1,R11),INSTTAB   LOOK FOR VALID INSTRUCTION
         BNZ   GOTSTCK            VALID, CHECK NEXT BYTE...
*
*                                 CHECK FOR 4 BYTE INST.
*
         SH    R11,=H'2'          R11 -> BACK 2 MORE BYTES
         TRT   0(1,R11),INSTTAB4  LOOK FOR VALID INSTRUCTION
         BNZ   GOTSTCK            VALID, CHECK NEXT BYTE...
*
*                                 CHECK FOR 6 BYTE INST.
*
         SH    R11,=H'2'          R11 -> BACK 2 MORE BYTES
         TRT   0(1,R11),INSTTAB6  LOOK FOR VALID INSTRUCTION
         BZ    TEST3              NOT VALID, DO NEXT TEST
*
GOTSTCK  DS    0H
         LR    R11,R8             R11 = ADDR OF INST IN CASE DEBUG
         LA    R8,4(0,R8)         R8 -> TO NEXT INST.
         BCTR  R5,0               SET R5 FOR BCT LATER...
         BCTR  R5,0               SET R5 FOR BCT LATER...
         BCTR  R5,0               SET R5 FOR BCT LATER...
*
*        SEE IF NEXT BYTE COULD BE A VALID INSTRUCTION
*
         TRT   0(1,R8),INSTTAB    LOOK FOR VALID INSTRUCTION
         BZ    NEXTBYT2           NOT VALID, CHECK NEXT BYTE...
*
*        IT LOOKS REAL, SO COUNT IT
*
         LH    R1,STCKCTR         VALID, COUNT IT
         LA    R1,1(0,R1)         ADD ONE
         STH   R1,STCKCTR         SAVE NEW COUNT
         L     R1,STCKCTR2        VALID, COUNT IT
         LA    R1,1(0,R1)         ADD ONE
         ST    R1,STCKCTR2        SAVE NEW COUNT
         TM    FLAG1,X'20'        WANT OFFSET INFO?
         BZ    NEXTBYT2           NO
*        LR    R11,R8             R11 = ADDR OF INST
         S     R11,LOADADDR       R11 = OFFSET TO INST
         ST    R11,DWORD          SAVE OFFSET
         MVC   SHOWMSG(20),=CL20'STCK INST AT OFFSET'
         BAL   R11,SHOWOFF        GO PRINT IT
         B     NEXTBYT2           CHECK FOR MORE
*
DECOFFST DC    CL9' '             OFFSET IN DECIMAL
SHOWMSG  DC    CL20' '            OFFSET MSG
*
*                                 SAY POSSIBLE STCK INSTRUCTION
*        MVC   PSTYPE(16),=C'STCK INSTRUCTION'
*        B     CHKINST            YES, RECORD IS FINISHED
*
TEST3    DS    0H
         CLC   =X'B207',0(R8)     POSSIBLE STCKC INSTRUCTION?
         BNE   TEST4              NO, DO NEXT TEST
*
*              SEE IF ADDRESS IS DIVISIBLE BY 2
*
****     L     R11,LOADADDR       R11 = ADDR OF LOADED MEMBER
****     SR    R11,R8             R11 = OFFSET TO INST
*        LR    R11,R8             R11 = ADDR OF INST
*        S     R11,LOADADDR       R11 = OFFSET TO INST
*        LR    R1,R11             R1 = OFFSET TO INST
*        SRL   R1,1               DIVIDE BY 2
*        SLL   R1,1               MULTIPLY BY 2
*        CR    R1,R11             STILL THE SAME?
*        BNE   NEXTBYTE           NO, NOT AN INSTRUCTION
*
*              OKAY, WE HAVE AN STCKC. CHECK PREVIOUS
*              INSTRUCTIONS FOR VALIDITY...
*
*              SEE IF WE ARE THE BACK END OF A 4 BYTE INSTRUCTION
*
         LR    R11,R8             R11 -> AT SVC 11
         SH    R11,=H'2'          R11 -> BACK 2 BYTES
         TRT   0(1,R11),INSTTAB4  LOOK FOR VALID INSTRUCTION
         BNZ   TEST4              VALID, SO STCKC IS NOT....
*
*              SEE IF WE ARE THE MIDDLE OF A 6 BYTE INSTRUCTION
*
         TRT   0(1,R11),INSTTAB6  LOOK FOR VALID INSTRUCTION
         BNZ   TEST4              VALID, SO STCKC IS NOT....
*
*              SEE IF WE ARE THE BACK END OF A 6 BYTE INSTRUCTION
*
         LR    R11,R8             R11 -> AT SVC 11
         SH    R11,=H'4'          R11 -> BACK 4 BYTES
         TRT   0(1,R11),INSTTAB6  LOOK FOR VALID INSTRUCTION
         BNZ   TEST4              VALID, SO STCKC IS NOT....
*
*                                 CHECK FOR 2 BYTE INST.
*
         LR    R11,R8             R11 -> AT SVC 11
         SH    R11,=H'2'          R11 -> BACK 2 BYTES
         TRT   0(1,R11),INSTTAB   LOOK FOR VALID INSTRUCTION
         BNZ   GOTSTCKC           VALID, CHECK NEXT BYTE...
*
*                                 CHECK FOR 4 BYTE INST.
*
         SH    R11,=H'2'          R11 -> BACK 2 MORE BYTES
         TRT   0(1,R11),INSTTAB4  LOOK FOR VALID INSTRUCTION
         BNZ   GOTSTCKC           VALID, CHECK NEXT BYTE...
*
*                                 CHECK FOR 6 BYTE INST.
*
         SH    R11,=H'2'          R11 -> BACK 2 MORE BYTES
         TRT   0(1,R11),INSTTAB6  LOOK FOR VALID INSTRUCTION
         BZ    TEST4              NOT VALID, DO NEXT TEST
*
GOTSTCKC DS    0H
         LR    R11,R8             R11 = ADDR OF INST IN CASE DEBUG
         LA    R8,4(0,R8)         R8 -> TO NEXT INST.
         BCTR  R5,0               SET R5 FOR BCT LATER...
         BCTR  R5,0               SET R5 FOR BCT LATER...
         BCTR  R5,0               SET R5 FOR BCT LATER...
*
*        SEE IF NEXT BYTE COULD BE A VALID INSTRUCTION
*
         TRT   0(1,R8),INSTTAB    LOOK FOR VALID INSTRUCTION
         BZ    NEXTBYT2           NOT VALID, CHECK NEXT BYTE...
*
*        IT LOOKS REAL, SO COUNT IT
*
         LH    R1,STCKCCTR        VALID, COUNT IT
         LA    R1,1(0,R1)         ADD ONE
         STH   R1,STCKCCTR        SAVE NEW COUNT
         L     R1,STCKCCT2        VALID, COUNT IT
         LA    R1,1(0,R1)         ADD ONE
         ST    R1,STCKCCT2        SAVE NEW COUNT
         TM    FLAG1,X'20'        WANT OFFSET INFO?
         BZ    NEXTBYT2           NO
*        LR    R11,R8             R11 = ADDR OF INST IN CASE DEBUG
         S     R11,LOADADDR       R11 = OFFSET TO INST
         ST    R11,DWORD          SAVE OFFSET
         MVC   SHOWMSG(20),=CL20'STCKC INST AT OFFSET'
         BAL   R11,SHOWOFF        GO PRINT IT
         B     NEXTBYT2           CHECK FOR MORE
*                                 SAY POSSIBLE STCKC INSTRUCTION
*        MVC   PSTYPE(17),=C'STCKC INSTRUCTION'
*        B     CHKINST            YES, RECORD IS FINISHED
*                                 SAY POSSIBLE STCKC INSTRUCTION
*
*              SEE IF WE CAN FIND POSSIBLE CVTDATE ACCESS...
*
TEST4    DS    0H
         CLI   0(R8),X'58'        LOAD INSTRUCTION?
         BNE   TEST5              NO, DO NEXT TEST
         CLC   =X'0010',2(R8)     ACCESSING CVT ?
         BNE   TEST5              NO, DO NEXT TEST
*
*              OKAY, WE HAVE CVT ACCESS. CHECK PREVIOUS
*              INSTRUCTIONS FOR VALIDITY...
*
*              SEE IF WE ARE THE BACK END OF A 4 BYTE INSTRUCTION
*
         LR    R11,R8             R11 -> AT CODE
         SH    R11,=H'2'          R11 -> BACK 2 BYTES
*        TRT   0(1,R11),INSTTAB4  LOOK FOR VALID INSTRUCTION
*        BNZ   TEST5              VALID, SO STCK IS NOT....
*
*              SEE IF WE ARE THE MIDDLE OF A 6 BYTE INSTRUCTION
*
         TRT   0(1,R11),INSTTAB6  LOOK FOR VALID INSTRUCTION
         BNZ   TEST5              VALID, SO CVT IS NOT....
*
*              SEE IF WE ARE THE BACK END OF A 6 BYTE INSTRUCTION
*
         LR    R11,R8             R11 -> AT CODE
         SH    R11,=H'4'          R11 -> BACK 4 BYTES
         TRT   0(1,R11),INSTTAB6  LOOK FOR VALID INSTRUCTION
         BNZ   TEST5              VALID, SO CVT IS NOT....
*
*                                 CHECK FOR 2 BYTE INST.
*
         LR    R11,R8             R11 -> AT CODE
         SH    R11,=H'2'          R11 -> BACK 2 BYTES
         TRT   0(1,R11),INSTTAB   LOOK FOR VALID INSTRUCTION
         BNZ   GOTCVT             VALID, CHECK NEXT BYTE...
*
*                                 CHECK FOR 4 BYTE INST.
*
         SH    R11,=H'2'          R11 -> BACK 2 MORE BYTES
         TRT   0(1,R11),INSTTAB4  LOOK FOR VALID INSTRUCTION
         BNZ   GOTCVT             VALID, CHECK NEXT BYTE...
*
*                                 CHECK FOR 6 BYTE INST.
*
         SH    R11,=H'2'          R11 -> BACK 2 MORE BYTES
         TRT   0(1,R11),INSTTAB6  LOOK FOR VALID INSTRUCTION
         BZ    TEST5              NOT VALID, DO NEXT TEST
*
GOTCVT   DS    0H
         MVC   CVTDATET(1),1(R8)  SAVE REG AS BASE TO CVTDATE OFFSET
         MVC   CVTDATE2(1),1(R8)  SAVE REG AS BASE TO CVTDATE OFFSET
         LR    R11,R8             R11 = ADDR OF INST IN CASE DEBUG
         LA    R8,4(0,R8)         R8 -> TO NEXT INST.
         BCTR  R5,0               SET R5 FOR BCT LATER...
         BCTR  R5,0               SET R5 FOR BCT LATER...
         BCTR  R5,0               SET R5 FOR BCT LATER...
*
*        SEE IF NEXT BYTE COULD BE A VALID INSTRUCTION
*
         TRT   0(1,R8),INSTTAB    LOOK FOR VALID INSTRUCTION
         BZ    NEXTBYT2           NOT VALID, CHECK NEXT BYTE...
*
*        SEE IF WE ARE ACCESSING CVTDATE....
*
         CLC   CVTDATET,2(R8)     LOADING CVTDATE?
         BE    GOTCVT2            YES
         CLC   CVTDATET,4(R8)     MOVING CVTDATE?
         BE    GOTCVT2            YES
         CLC   CVTDATE2,2(R8)     LOADING CVTDATE+1?
         BE    GOTCVT2            YES
         CLC   CVTDATE2,4(R8)     MOVING CVTDATE+1?
         BNE   GOTCVT4            NO
*
*        IT LOOKS REAL, SO COUNT IT
*
GOTCVT2  DS    0H
         LH    R1,CVTDCTR         VALID, COUNT IT
         LA    R1,1(0,R1)         ADD ONE
         STH   R1,CVTDCTR         SAVE NEW COUNT
         L     R1,CVTDCTR2        VALID, COUNT IT
         LA    R1,1(0,R1)         ADD ONE
         ST    R1,CVTDCTR2        SAVE NEW COUNT
         TM    FLAG1,X'20'        WANT OFFSET INFO?
         BZ    NEXTBYT2           NO
*        LR    R11,R8             R11 = ADDR OF INST
         S     R11,LOADADDR       R11 = OFFSET TO INST
         ST    R11,DWORD          SAVE OFFSET
         MVC   SHOWMSG(20),=CL20'CVTDATE AT OFFSET'
         BAL   R11,SHOWOFF        GO PRINT IT
         B     NEXTBYT2           CHECK FOR MORE
*
*
*        SAY WE ACCESSED THE CVT ANYWAY...
*
GOTCVT4  DS    0H
         LH    R1,CVTCTR          VALID, COUNT IT
         LA    R1,1(0,R1)         ADD ONE
         STH   R1,CVTCTR          SAVE NEW COUNT
         L     R1,CVTCTR2         VALID, COUNT IT
         LA    R1,1(0,R1)         ADD ONE
         ST    R1,CVTCTR2         SAVE NEW COUNT
         TM    FLAG1,X'20'        WANT OFFSET INFO?
         BZ    NEXTBYT2           NO
*        LR    R11,R8             R11 = ADDR OF INST
         S     R11,LOADADDR       R11 = OFFSET TO INST
         ST    R11,DWORD          SAVE OFFSET
         MVC   SHOWMSG(20),=CL20'CVT ACCESS AT OFFSET'
         BAL   R11,SHOWOFF        GO PRINT IT
         B     NEXTBYT2           CHECK FOR MORE
*
CVTDATET DC    X'0038'            OFFSET TO CVTDATE IN INST
CVTDATE2 DC    X'0038'            OFFSET TO CVTDATE IN INST
*ECOFFST DC    CL9' '             OFFSET IN DECIMAL
*HOWMSG  DC    CL20' '            OFFSET MSG
*
*
TEST5    DS    0H
*
*              SEE IF WE CAN FIND ANY NAMES/DATA WE WANT...
*
*
TESTDATA DS    0H
         TM    FLAG1,X'40'        ABEND AT SPECIFIC MODULE?
         BO    NEXTBYTE           YES, DON'T DO PARM CHECK
*
         ST    R6,SAVE6           SAVE R6
         LA    R6,MODTABLE        R6 -> AT MOD NAME TABLE
         USING MODENTRY,R6        SET TABLE BASE
         B     NEXTMOD2           ON WE GO...
         SPACE 1
NEXTMOD  DS    0H
         LA    R6,MODTBLTH(0,R6)  R6 -> AT NEXT ENTRY
         SPACE 1
NEXTMOD2 DS    0H
         CLI   MODLTH,X'FF'       END OF TABLE?
         BE    NEXTBYTE           YES
         SPACE 1
*        ICM   R3,3,PARMLTH       R3 = LTH OF PARM
         SR    R3,R3              R3 = 0
         ICM   R3,1,MODLTH        R3 = LTH OF PARM/MODULE NAME
         BZ    NEXTBYTE           NO PARM, CHECK NEXT BYTE
*
         LA    R1,0(R3,R8)        R1 -> END OF INSTRUCTION...
         CR    R1,R10             PAST END OF MODULE?
         BH    NEXTMOD            YES, CAN'T TEST. TRY NEXT TABLE ENT
*
         BCTR  R3,0               R3 = HEX LTH
         EX    R3,TESTPARM        CHECK FOR PARM
         BNE   NEXTMOD            NO, CHECK NEXT TABLE ENTRY
         LR    R11,R8             R11 = ADDR OF INST IN CASE DEBUG
         LA    R8,1(R3,R8)        R8 -> TO NEXT INST.
*        BCTR  R5,0               SET R5 FOR BCT LATER...
         SR    R5,R3              SET R5 FOR BCT LATER...
*
*        LH    R1,PGMCTR          VALID, COUNT IT
         LH    R1,MODCTR          VALID, COUNT IT
         LA    R1,1(0,R1)         ADD ONE
         STH   R1,MODCTR          SAVE NEW COUNT
*        STH   R1,PGMCTR          SAVE NEW COUNT
         L     R1,PGMCTR2         VALID, COUNT IT
         LA    R1,1(0,R1)         ADD ONE
         ST    R1,PGMCTR2         SAVE NEW COUNT
         TM    FLAG1,X'20'        WANT OFFSET INFO?
         BZ    NEXTBYT2           NO
*        LR    R11,R8             R11 = ADDR OF INST IN CASE DEBUG
         MVC   SHOWMSG(20),=CL20'MODNAME    AT OFFSET'
         MVC   SHOWMSG(08),MODNAME
         CLI   MODTYPE,C'H'       IS DATA HEX?
         BNE   NOTHEX             NO
         ICM   R3,1,MODLTH        R3 = LTH OF PARM/MODULE NAME
         BZ    NOTHEX             NO LTH, END OF MODULE
         EX    R3,HEXUNPK         UNPACK HEX DATA
         EX    R3,HEXTR2          TRANSLATE TO DISPLAY
         SLL   R3,1               R3*2 = HEX LTH OF UNPACKED DATA..
         LA    R14,DWORD+8        R14 -> AT DWORD
         SR    R14,R3             R14 S/B -> AT HEX DATA...
*        SRL   R7,1               DIVIDE BY 2
         BCTR  R3,0               R3 = LTH TO MOVE
         MVI   SHOWMSG,C' '       CLEAR SHOWMSG...
         MVC   SHOWMSG+1(7),SHOWMSG
         EX    R3,HEXMVC4         PUT DATA IN MESSAGE
*
NOTHEX   DS    0H
         S     R11,LOADADDR       R11 = OFFSET TO INST
         ST    R11,DWORD          SAVE OFFSET
         BAL   R11,SHOWOFF        GO PRINT IT
         B     NEXTBYT2           CHECK FOR MORE
*        MVC   PSTYPE(13),=C'CALLS MODULE ' SET UP MESSAGE
*        MVC   PSTYPE+13(8),SCRDATE         JUST IN CASE...
*        B     WRITEREC           WE FOUND IT, GO TELL USER
         SPACE 1
HEXMVC4  MVC   SHOWMSG(0),0(R14)  SET UP DATA
*
TESTPARM CLC   0(0,R8),MODNAME    CHECK FOR PARM
*ESTPARM CLC   0(0,R8),SCRDATE    CHECK FOR PARM
*
SHOWOFF  DS    0H
*
*              CONVERT OFFSET TO DECIMAL
*
*        MVC   LOCRC(3),DWORD+1   PUT IN HEX RC
         UNPK  DECOFFST(9),DWORD(5) UNPACK OFFSET         DEBUG
         MVI   DECOFFST+8,X'EF'   TRANSLATES TO BLANK     DEBUG
         TR    DECOFFST(9),TRTAB2-239 TRANSLATE TO DISPLAY DEBUG
         SPACE 1
         MVC   PSTYPE(20),SHOWMSG
         MVC   PSTYPE+21(8),DECOFFST
         SPACE 1
         ST    R5,SAVER5          SAVE R5
         BAL   R5,PRINTLNE        GO PRINT IT
         L     R5,SAVER5          LOAD R5
         BR    R11                RETURN TO CALLER
*
NEXTBYTE DS    0H
         LA    R8,1(0,R8)         R8 -> TO NEXT CHAR
*
*            GO TO 24 BIT MODE ADDRESSING
*
*        LA    R1,*+4+2           GET INTO 24 BIT MODE
*        BSM   0,R1               ''
         BAS  R14,@AMODE24
*
*
NEXTBYT2 DS    0H
         DROP  R6                 DROP MODTABLE BASE
         L     R6,SAVE6           LOAD R6
         BCT   R5,TESTTYPE        CHECK NEXT BYTE
*
*              FINISHED WITH THIS MODULE, SO RELEASE IT
*
         LA    R0,DELNAME         R0 -> AT MEMBER NAME
         DELETE EPLOC=(0)         DELETE THE MEMBER
*
*        SEE IF WE FOUND ANY TIME INSTRUCTIONS
*
*
*            GO TO 24 BIT MODE ADDRESSING
*
         LA    R1,*+4+2           GET INTO 24 BIT MODE
         BSM   0,R1               ''
*
CHKSVC   DS    0H
         SR    R7,R7              CLEAR R7
         ICM   R7,3,SVCCTR        R7 = NBR OF TIMES SVC 11 FOUND
         BZ    CHKSTCK            NONE, CHECK FOR STCK
*        CLC   SVCCTR,=H'0'       ANY SVC 11'S FOUND?
*        BE    CHKSTCK            NO, CHECK FOR STCK
         MVC   PSTYPE(20),=CL20'TIME MACRO (SVC 11)'
*        LH    R7,SVCCTR          R7 = COUNTER
         CVD   R7,WORKD
         MVC   PSCOUNT,PATTERN
         ED    PSCOUNT,WORKD+4
         PUT   PRINT,SCRCARD      PRINT IT
         MVI   MBRNAME,C' '       CLEAR PRINT LINE
         MVC   MBRNAME+1(CLRLTH1),MBRNAME ''
         MVC   SVCCTR,=H'0'       CLEAR COUNTER
*
CHKSTCK  DS    0H
*        CLC   STCKCTR,=H'0'      ANY STCK'S FOUND?
*        BE    CHKSTCKC           NO, CHECK FOR STCKC
         ICM   R7,3,STCKCTR       R7 = NBR OF TIMES STCK FOUND
         BZ    CHKSTCKC           NONE, CHECK FOR STCK
         MVC   PSTYPE(20),=CL20'STCK INSTRUCTION'
*        LH    R7,STCKCTR         R7 = COUNTER
         CVD   R7,WORKD
         MVC   PSCOUNT,PATTERN
         ED    PSCOUNT,WORKD+4
         PUT   PRINT,SCRCARD      PRINT IT
         MVI   MBRNAME,C' '       CLEAR PRINT LINE
         MVC   MBRNAME+1(CLRLTH1),MBRNAME ''
         MVC   STCKCTR,=H'0'      CLEAR COUNTER
*
CHKSTCKC DS    0H
*        CLC   STCKCCTR,=H'0'     ANY STCKC'S FOUND?
*        BE    CHKPGM             NO, CHECK FOR PROGRAM NAME
         ICM   R7,3,STCKCCTR      R7 = NBR OF TIMES STCKC FOUND
         BZ    CHKCVTD            NONE, CHECK FOR CVTDATE ACCESS
         MVC   PSTYPE(20),=CL20'STCKC INSTRUCTION'
*        LH    R7,STCKCCTR        R7 = COUNTER
         CVD   R7,WORKD
         MVC   PSCOUNT,PATTERN
         ED    PSCOUNT,WORKD+4
         PUT   PRINT,SCRCARD      PRINT IT
         MVI   MBRNAME,C' '       CLEAR PRINT LINE
         MVC   MBRNAME+1(CLRLTH1),MBRNAME ''
         MVC   STCKCCTR,=H'0'     CLEAR COUNTER
*
CHKCVTD  DS    0H
         ICM   R7,3,CVTDCTR       R7 = NBR OF TIMES CVTDATE FOUND
         BZ    CHKCVT2            NONE, CHECK FOR PGM'S
         MVC   PSTYPE(20),=CL20'CVTDATE ACCESS'
         CVD   R7,WORKD
         MVC   PSCOUNT,PATTERN
         ED    PSCOUNT,WORKD+4
         PUT   PRINT,SCRCARD      PRINT IT
         MVI   MBRNAME,C' '       CLEAR PRINT LINE
         MVC   MBRNAME+1(CLRLTH1),MBRNAME ''
         MVC   CVTDCTR,=H'0'      CLEAR COUNTER
*
CHKCVT2  DS    0H
         ICM   R7,3,CVTCTR        R7 = NBR OF TIMES CVTDATE FOUND
         BZ    CHKPGM             NONE, CHECK FOR PGM'S
         MVC   PSTYPE(20),=CL20'CVT ACCESS'
         CVD   R7,WORKD
         MVC   PSCOUNT,PATTERN
         ED    PSCOUNT,WORKD+4
         PUT   PRINT,SCRCARD      PRINT IT
         MVI   MBRNAME,C' '       CLEAR PRINT LINE
         MVC   MBRNAME+1(CLRLTH1),MBRNAME ''
         MVC   CVTCTR,=H'0'       CLEAR COUNTER
*
CHKPGM   DS    0H
*
         ST    R6,SAVE6A          SAVE R6
         LA    R6,MODTABLE        R6 -> AT MOD NAME TABLE
         USING MODENTRY,R6        SET TABLE BASE
         SPACE 1
NEXTPGM  DS    0H
         CLI   MODLTH,X'FF'       END OF TABLE?
         BE    NOTIME             YES, END OF MODULE
         SPACE 1
         ICM   R3,1,MODLTH        R3 = LTH OF PARM/MODULE NAME
         BZ    NOTIME             NO LTH, END OF MODULE
*
*
*        LH    R1,MODCTR          VALID, COUNT IT
         SPACE 1
*        CLC   PGMCTR,=H'0'       ANY PGM'S FOUND?
*        CLC   MODCTR,=H'0'       ANY PGM'S FOUND?
*        BE    NOCOUNT            NO, CHECK NEXT ENTRY
         ICM   R7,3,MODCTR        R7 = NBR OF TIMES FOUND
         BZ    NOCOUNT            NONE, CHECK NEXT ENTRY
*
         CLI   MODTYPE,C'H'       IS DATA HEX?
         BE    HEXDATA            YES.
*
CHARDATA DS    0H
         MVC   PSTYPE(13),=C'CALLS MODULE ' SET UP MESSAGE
         MVC   PSTYPE+13(8),MODNAME         JUST IN CASE...
         B     RESTDATA           SET UP REST OF DATA
*
HEXDATA  DS    0H
*        MVC   PSTYPE+13(8),MODNAME         JUST IN CASE...
         EX    R3,HEXUNPK         UNPACK HEX DATA
         EX    R3,HEXTR2          TRANSLATE TO DISPLAY
****
         SLL   R3,1               R3*2 = HEX LTH OF UNPACKED DATA..
         LA    R14,DWORD+8        R14 -> AT DWORD
         SR    R14,R3             R14 S/B -> AT HEX DATA...
*        SRL   R7,1               DIVIDE BY 2
         BCTR  R3,0               R3 = LTH TO MOVE
         MVC   PSTYPE(11),=C'FOUND DATA ' SET UP MESSAGE
         EX    R3,HEXMVC3         PUT DATA IN MESSAGE
         B     RESTDATA           SET UP REST OF DATA
         SPACE 1
HEXUNPK  UNPK  DWORD(9),MODNAME(0) UNPACK DATA
HEXTR2   TR    DWORD(8),TRTAB2-239 TRANSLATE TO DISPLAY
HEXMVC3  MVC   PSTYPE+11(0),0(R14) SET UP DATA
TRTAB2   DC    C' 0123456789ABCDEF'
         SPACE 2
*
RESTDATA DS    0H
*        MVC   PSTYPE+13(8),SCRDATE         JUST IN CASE...
*        LH    R7,PGMCTR          R7 = COUNTER
*        LH    R7,MODCTR          R7 = COUNTER
         CVD   R7,WORKD
         MVC   PSCOUNT,PATTERN
         ED    PSCOUNT,WORKD+4
         PUT   PRINT,SCRCARD      PRINT IT
         MVI   MBRNAME,C' '       CLEAR PRINT LINE
         MVC   MBRNAME+1(CLRLTH1),MBRNAME ''
         MVC   MODCTR,=H'0'       CLEAR COUNTER
*        MVC   PGMCTR,=H'0'       CLEAR COUNTER
*
NOCOUNT  DS    0H
         LA    R6,MODTBLTH(0,R6)  R6 -> AT NEXT ENTRY
         B     NEXTPGM            SEE IF ANOTHER MODULE NAME
         DROP  R6                 DROP MODTABLE BASE
*        B     NOTIME             END OF MODULE..
*
*
*        SEE IF NEXT BYTE COULD BE A VALID INSTRUCTION
*
CHKINST  DS    0H
         TRT   0(1,R8),INSTTAB         LOOK FOR VALID INSTRUCTION
         BNZ   WRITEREC           VALID, GO PRINT NAME
*
CLEARREC DS    0H
         MVI   PSTYPE,C' '        CLEAR PRINT LINE
         MVC   PSTYPE+1(CLRLTH2),PSTYPE ''
*        MVI   MBRNAME,C' '       CLEAR PRINT LINE
*        MVC   MBRNAME+1(CLRLTH1),MBRNAME ''
         B     NEXTBYT2
*
*
*        WRITE OUT DEBUG INFORMATION
*
PRINTLNE DS    0H
*
*            GO TO 24 BIT MODE ADDRESSING
*
         LA    R1,*+4+2           GET INTO 24 BIT MODE
         BSM   0,R1               ''
*
         PUT   PRINT,SCRCARD      PRINT IT
*
*        GET BACK TO 31 BIT MODE ADDRESSING
*
         CNOP  0,4                ALIGN ON A FULLWORD BOUNDARY      RH
         L     R1,*+8             GET 31 BIT MODE ADDRESS           RH
         BSM   0,R1               GET INTO 31 BIT MODE              RH
         BSM   0,R1               TO FILL 4 BYTES                   RH
**       DS    0F                 ALIGN ON A FULLWORD BOUNDARY      RH
         DC    X'80',AL3(*+3)     NEXT ADDRESS IS 31 BIT MODE       RH
*
*        MVI   PSTYPE,C' '        CLEAR PRINT LINE
*        MVC   PSTYPE+1(CLRLTH2),PSTYPE ''
         MVI   MBRNAME,C' '       CLEAR PRINT LINE
         MVC   MBRNAME+1(CLRLTH1),MBRNAME ''
         BR    R5                 RETURN TO CALLER
*
*
*
*        WRITE OUT MEMBER CONTROL STATEMENT
*
WRITEREC DS    0H
*
*            GO TO 24 BIT MODE ADDRESSING
*
         LA    R1,*+4+2           GET INTO 24 BIT MODE
         BSM   0,R1               ''
*
         PUT   PRINT,SCRCARD      PRINT IT
*
*        GET BACK TO 31 BIT MODE ADDRESSING
*
*        CNOP  0,4                ALIGN ON A FULLWORD BOUNDARY      RH
*        L     R1,*+8             GET 31 BIT MODE ADDRESS           RH
*        BSM   0,R1               GET INTO 31 BIT MODE              RH
*        BSM   0,R1               TO FILL 4 BYTES                   RH
**       DS    0F                 ALIGN ON A FULLWORD BOUNDARY      RH
*        DC    X'80',AL3(*+3)     NEXT ADDRESS IS 31 BIT MODE       RH
*
         MVI   MBRNAME,C' '       CLEAR PRINT LINE
         MVC   MBRNAME+1(CLRLTH1),MBRNAME ''
*
NOTIME   DS    0H
         L     R6,SAVE6A          RELOAD R6
         L     R7,MBRCNT
         LA    R7,1(0,R7)         INCREMENT COUNTER
         ST    R7,MBRCNT
         B     GETNEXT          GET NEXT MEMBER
*
*        ERROR ROUTINES
*
BADPARM  EQU   *
         MVC   MBRNAME,=CL8'BADPARM*'
         MVC   PSDATE(15),=C' PARM TOO LONG.'
*
BADPARM2 EQU   *
         PUT   PRINT,SCRCARD      PRINT IT
         LA    R15,16
         ST    R15,RETCODE        SAVE RC
         B     BADEND           LEAVE
*
NOMBRS   EQU   *
         MVC   MBRNAME,=CL8'NOMBRS**'
         MVC   PSDATE(18),=C' //INLIB IS EMPTY.'
*        MVC   PSDATE(8),SCRDATE
         B     BADPARM2         LEAVE
*        PUT   PRINT,SCRCARD      PRINT IT
*        LA    R15,16
*        ST    R15,RETCODE        SAVE RC
*        B     BADEND           LEAVE
*
*        CLOSE PDS
*
CLOSPDS  EQU   *
         CLOSE (INPDSA),MODE=31
*
*        FREE STORAGE AREA
*
         FREEMAIN R,SP=10
*
*        AND RETURN
*
RETURN   EQU   *
         MVI   MBRNAME,C' '       CLEAR PRINT LINE
         MVC   MBRNAME+1(CLRLTH1),MBRNAME ''
         PUT   PRINT,SCRCARD      PRINT A BLANK LINE
*
         L     R7,MBRCNT
         CVD   R7,WORKD
         MVC   OUTCNT,PATTERN
         ED    OUTCNT,WORKD+4
         PUT   PRINT,OUTPRT       PRINT IT
         LA    R15,0
*
         MVI   MBRNAME,C' '       CLEAR PRINT LINE
         MVC   MBRNAME+1(CLRLTH1),MBRNAME ''
         PUT   PRINT,SCRCARD      PRINT A BLANK LINE
*
         ICM   R7,15,SVCCTR2
         BZ    NOSVC
         CVD   R7,WORKD
         MVC   TIMERCNT,PATTERN
         ED    TIMERCNT,WORKD+4
         PUT   PRINT,TIMERMSG     PRINT IT
         LA    R15,0
*
NOSVC    DS    0H
         ICM   R7,15,STCKCTR2
         BZ    NOSTCK
         CVD   R7,WORKD
         MVC   STCKCNT,PATTERN
         ED    STCKCNT,WORKD+4
         PUT   PRINT,STCKMSG      PRINT IT
         LA    R15,0
*
NOSTCK   DS    0H
         ICM   R7,15,STCKCCT2
         BZ    NOSTCK2
         CVD   R7,WORKD
         MVC   STCKCCNT,PATTERN
         ED    STCKCCNT,WORKD+4
         PUT   PRINT,STCKCMSG     PRINT IT
         LA    R15,0
*
NOSTCK2  DS    0H
         ICM   R7,15,CVTDCTR2
         BZ    NOCVTD2
         L     R7,CVTDCTR2
         CVD   R7,WORKD
         MVC   CVTDCNT,PATTERN
         ED    CVTDCNT,WORKD+4
         PUT   PRINT,CVTDMSG      PRINT IT
         LA    R15,0
*
NOCVTD2  DS    0H
         ICM   R7,15,CVTCTR2
         BZ    NOCVT2
         L     R7,CVTCTR2
         CVD   R7,WORKD
         MVC   CVTCNT,PATTERN
         ED    CVTCNT,WORKD+4
         PUT   PRINT,CVTMSG       PRINT IT
         LA    R15,0
*
NOCVT2   DS    0H
         ICM   R7,15,PGMCTR2
         BZ    NOPGM2
         L     R7,PGMCTR2
         CVD   R7,WORKD
         MVC   PGMCNT,PATTERN
         ED    PGMCNT,WORKD+4
         PUT   PRINT,PGMMSG       PRINT IT
         LA    R15,0
*
NOPGM2   DS    0H
*
BADEND   EQU   *
         CLOSE PRINT,MODE=31
         L     R15,RETCODE        LOAD RC
         L     R13,4(R13)         R13 -> TO CALLERS SAVE AREA
         L     R14,12(R13)        SET R14 TO WHAT CALLER'S R14
         LM    R0,R12,20(R13)     SET R0-R12 TO CALLERS REGS
*        BR    R14                RETURN TO CALLING PROGRAM
*              GET INTO PROPER MODE AND GO BACK TO CALLER
         BSM   0,R14              RETURN TO CALLING PROGRAM
*
*        ABEND
*
BADBAD   EQU   *
         ABEND 799,DUMP,STEP
*
*      THIS ROUTINE SWITCHES THE AMODE TO 24
*      ENTRY TO THIS ROUTINE IS THROUGH A BAS  R14,@AMODE24
*
         DS    0F
         DC    X'7FFFFFFF'
@AMODE24 EQU   *
         N     R14,*-4
         BSM   0,R14
*
*      THIS ROUTINE SWITCHES THE AMODE TO 31
*      ENTRY TO THIS ROUTINE IS THROUGH A BAS  R14,@AMODE31
*
         DS    0F
         DC    X'80000000'
@AMODE31 EQU   *
         O     R14,*-4
         BSM   0,R14
*
*
*
*        DEFINE VARIABLES
*
*
***************************WORK AREAS *********************************
*
WORKD    DS   D
RETCODE  DC    F'0'
LOADADDR DC    F'0'
*AVEAREA DS   18F
*
SAVER1   DS    F
SAVER5   DS    F
SAVE6    DC    F'0'
SAVE6A   DC    F'0'
SVCCTR   DC    H'0'
STCKCTR  DC    H'0'
STCKCCTR DC    H'0'
CVTCTR   DC    H'0'
CVTDCTR  DC    H'0'
*
SVCCTR2  DC    F'0'
STCKCTR2 DC    F'0'
STCKCCT2 DC    F'0'
PGMCTR2  DC    F'0'
CVTCTR2  DC    F'0'
CVTDCTR2 DC    F'0'
         SPACE 2
MBRTYPE  DC    C' '
STARTMBR DC    CL8' '
ENDMBR   DC    CL8' '
DELNAME  DC    CL8' '             READ AREA FOR GET AT READSYS
SYSDATA  DS    CL80
SMBRLTH  DC    H'0'
EMBRLTH  DC    H'0'
SAVEALL  DC    18F'0'
         CNOP  0,8
*
BLKAREA  DS    F
MBRCNT   DC    F'0'
MBRAREA  DS    F
MBRADDR  DS    F
ENDADDR  DS    F
DIRREC   DC    XL256'00'
*
SCRCARD  DS    0CL81              81 LONG TO READ 80 INTO MBRNAME..
CARRCTL  DC    CL1' '
MBRNAME  DS    CL8                READ AREA FOR GET AT READSYS
         DC    CL2'  '
PSDATE   DS    CL6
         DC    CL2'  '
PSTYPE   DS    CL21
*PSDASH  DC    CL2'  '
PSCOUNT  DS    CL8
         DC    CL(81-(*-SCRCARD))' '
CLRLTH1  EQU   *-MBRNAME-1
CLRLTH2  EQU   *-PSTYPE-1
*        DC    CL55' '
*
************** ************** CONSTANTS *******************************
*
FLAG1    DC    X'00'
*        EQU   X'80'              SHOW DEBUG INFO
*        EQU   X'40'              ABEND AT SPECIFIC MODULE
*        EQU   X'20'              SHOW OFFSET OF STCK AND STCKC
         SPACE 2
OUTPRT   DS    0CL80
CCO      DC    CL1' '
         DC    CL29'NUMBER OF MEMBERS CHECKED : '
OUTCNT   DS    CL8
         DC    CL(80-(*-OUTPRT))' '
*        DC    CL95' '
*
CNTMSG   DS    0CL80
         DC    CL1' '
         DC    C'NUMBER OF ALIAS MEMBERS NOT PROCESSED : '
PRTCNT   DS    CL8
         DC    CL(80-(*-CNTMSG))' '
LCNTMSG  EQU   *-CNTMSG
*
TIMERMSG DS    0CL80
         DC    CL1' '
         DC    C'          NUMBER OF TIME MACROS (SVC 11) FOUND : '
TIMERCNT DS    CL8
         DC    CL(80-(*-TIMERMSG))' '
LTMRMSG  EQU   *-TIMERMSG
*
STCKMSG  DS    0CL80
         DC    CL1' '
         DC    C'    NUMBER OF POSSIBLE STCK INSTRUCTIONS FOUND : '
STCKCNT  DS    CL8
         DC    CL(80-(*-STCKMSG))' '
LSTCKMSG EQU   *-STCKMSG
*
STCKCMSG DS    0CL80
         DC    CL1' '
         DC    C'   NUMBER OF POSSIBLE STCKC INSTRUCTIONS FOUND : '
STCKCCNT DS    CL8
         DC    CL(80-(*-STCKCMSG))' '
LSTCKCMS EQU   *-STCKCMSG
*
PGMMSG   DS    0CL80
         DC    CL1' '
         DC    C'  NUMBER OF TIMES PARM/SYSIN KEYWORD WAS FOUND : '
PGMCNT   DS    CL8
         DC    CL(80-(*-PGMMSG))' '
LPGMMSG  EQU   *-PGMMSG
*
CVTDMSG  DS    0CL80
         DC    CL1' '
         DC    C'     NUMBER OF POSSIBLE CVTDATE ACCESSES FOUND : '
CVTDCNT  DS    CL8
         DC    CL(80-(*-CVTDMSG))' '
LCVTDMSG EQU   *-CVTDMSG
*
CVTMSG   DS    0CL80
         DC    CL1' '
         DC    C'                  NUMBER OF CVT ACCESSES FOUND : '
CVTCNT   DS    CL8
         DC    CL(80-(*-CVTMSG))' '
LCVTMSG EQU    *-CVTMSG
*
BADFIND  DC    C'ERROR DOING FIND FOR MEMBER. '
*
BADLOAD  DC    C'ERROR DOING LOAD FOR MEMBER..PROBABLY NOT EXECUTABLE'
LOADMSG  DC    C'BEING LOADED FOR CHECKING'
MAXMBR   DC    C'MAX MBRS REACHED. FIRST 9000 WILL BE PROCESSED'
LMAXMBR  EQU   *-MAXMBR
*LIASMSG DC    C'IS AN ALIAS AND WILL NOT BE TESTED'
ALIASMSG DC    C'IS AN ALIAS OF '
ALIASNAM DC    CL8' '
         DC    C' AND WILL NOT BE TESTED'
LALIASMS EQU   *-ALIASMSG
*
SCRATCHD DS    PL3
TODAY    DS    PL3
*
MODTABLE DS    0H                 MODULE NAMES
PARMLTH  DC    X'0'               1ST IS FROM PARM
         DC    C'A'               PARM MUST BE ALPHA
PGMCTR   DC    H'0'
SCRDATE  DC    CL8' '
MODTBLTH EQU   *-MODTABLE         LTH OF EACH ENTRY
*        DC    H'0',H'0',CL8' '   ROOM FOR 40 MODULE NAMES
         DC    X'0',C'A',H'0',CL8' '   ROOM FOR 40 MODULE NAMES
         DC    X'0',C'A',H'0',CL8' '
         DC    X'0',C'A',H'0',CL8' '
         DC    X'0',C'A',H'0',CL8' '
         DC    X'0',C'A',H'0',CL8' '
         DC    X'0',C'A',H'0',CL8' '
         DC    X'0',C'A',H'0',CL8' '
         DC    X'0',C'A',H'0',CL8' '
         DC    X'0',C'A',H'0',CL8' '
         DC    X'0',C'A',H'0',CL8' '
         DC    X'0',C'A',H'0',CL8' '
         DC    X'0',C'A',H'0',CL8' '
         DC    X'0',C'A',H'0',CL8' '
         DC    X'0',C'A',H'0',CL8' '
         DC    X'0',C'A',H'0',CL8' '
         DC    X'0',C'A',H'0',CL8' '
         DC    X'0',C'A',H'0',CL8' '
         DC    X'0',C'A',H'0',CL8' '
         DC    X'0',C'A',H'0',CL8' '
         DC    X'0',C'A',H'0',CL8' '
         DC    X'0',C'A',H'0',CL8' '
         DC    X'0',C'A',H'0',CL8' '
         DC    X'0',C'A',H'0',CL8' '
         DC    X'0',C'A',H'0',CL8' '
         DC    X'0',C'A',H'0',CL8' '
         DC    X'0',C'A',H'0',CL8' '
         DC    X'0',C'A',H'0',CL8' '
         DC    X'0',C'A',H'0',CL8' '
         DC    X'0',C'A',H'0',CL8' '
         DC    X'0',C'A',H'0',CL8' '
         DC    X'0',C'A',H'0',CL8' '
         DC    X'0',C'A',H'0',CL8' '
         DC    X'0',C'A',H'0',CL8' '
         DC    X'0',C'A',H'0',CL8' '
         DC    X'0',C'A',H'0',CL8' '
         DC    X'0',C'A',H'0',CL8' '
         DC    X'0',C'A',H'0',CL8' '
         DC    X'0',C'A',H'0',CL8' '
         DC    X'0',C'A',H'0',CL8' '
         DC    X'0',C'A',H'0',CL8' '
         DC    X'0',C'A',H'0',CL8' '
MODEND   DC    12X'FF'
*
*
PATTERN  DC    XL8'4020202020202020'
*
*              TRANSLATE TABLE OF  VALID INSTRUCTIONS
*
INSTTAB  DS    0CL256
*                   0 1 2 3 4 5 6 7 8 9 A B C D E F
         DC    XL16'00000000010101010000010101010101' 0
         DC    XL16'01010101010101010101010101010101' 1
         DC    XL16'01010101010101010101010101010101' 2
         DC    XL16'01010101010101010101010101010101' 3
         DC    XL16'01010101010101010101010101010101' 4
         DC    XL16'01010000010101010101010101010101' 5
         DC    XL16'01000000000000010101010101010101' 6
         DC    XL16'01000000000000000101010101010101' 7
         DC    XL16'01000101010101010101010101010101' 8
         DC    XL16'01010101010101010101010101010101' 9
         DC    XL16'00000000010101000000000001010101' A
         DC    XL16'00010100000001010000010100010101' B
         DC    XL16'00000000000000000000000000000000' C
         DC    XL16'00010101010101010001010101010101' D
         DC    XL16'00000000010100000100000000000000' E
         DC    XL16'01010101000000000101010101010000' F
*                   0 1 2 3 4 5 6 7 8 9 A B C D E F
*
*              TRANSLATE TABLE OF  VALID 6 BYTE INSTRUCTIONS
*
INSTTAB6 DS    0CL256
*                   0 1 2 3 4 5 6 7 8 9 A B C D E F
         DC    XL16'00000000000000000000000000000000' 0
         DC    XL16'00000000000000000000000000000000' 1
         DC    XL16'00000000000000000000000000000000' 2
         DC    XL16'00000000000000000000000000000000' 3
         DC    XL16'00000000000000000000000000000000' 4
         DC    XL16'00000000000000000000000000000000' 5
         DC    XL16'00000000000000000000000000000000' 6
         DC    XL16'00000000000000000000000000000000' 7
         DC    XL16'00000000000000000000000000000000' 8
         DC    XL16'00000000000000000000000000000000' 9
         DC    XL16'00000000000000000000000000000000' A
         DC    XL16'00000000000000000000000000000000' B
         DC    XL16'00000000000000000000000000000000' C
         DC    XL16'00010101010101010000000001010101' D
         DC    XL16'00000000000000000000000000000000' E
         DC    XL16'01010101000000000101010101010000' F
*                   0 1 2 3 4 5 6 7 8 9 A B C D E F
*
*              TRANSLATE TABLE OF  VALID 4 BYTE INSTRUCTIONS
*
INSTTAB4 DS    0CL256
*                   0 1 2 3 4 5 6 7 8 9 A B C D E F
         DC    XL16'00000000000000000000000000000000' 0
         DC    XL16'00000000000000000000000000000000' 1
         DC    XL16'00000000000000000000000000000000' 2
         DC    XL16'00000000000000000000000000000000' 3
         DC    XL16'01010101010101010101010101000101' 4
         DC    XL16'01000000010101010101010101010101' 5
         DC    XL16'01000000000000010101010101010101' 6
         DC    XL16'01000000000000000101010101010101' 7
         DC    XL16'01000100010101010101010101010101' 8
         DC    XL16'01010101010101010100000001010101' 9
         DC    XL16'00000000000000000000000001010101' A
         DC    XL16'00010100000001010000010100010101' B
         DC    XL16'00000000000000000000000000000000' C
         DC    XL16'00000000000000000000000000000000' D
         DC    XL16'00000000000000000000000000000000' E
         DC    XL16'00000000000000000000000000000000' F
*                   0 1 2 3 4 5 6 7 8 9 A B C D E F
*
*              TRANSLATE TABLE OF  VALID 2 BYTE INSTRUCTIONS
*
INSTTAB2 DS    0CL256
*                   0 1 2 3 4 5 6 7 8 9 A B C D E F
         DC    XL16'00000000010101010101010000000101' 0
         DC    XL16'01010101010101010101010101010101' 1
         DC    XL16'01010101010101010101010101010101' 2
         DC    XL16'01010101010100010101010001010101' 3
         DC    XL16'00000000000000000000000000000000' 4
         DC    XL16'00000000000000000000000000000000' 5
         DC    XL16'00000001000000000000000000000000' 6
         DC    XL16'00000000000000000000000100000000' 7
         DC    XL16'00000000000000000000000000000000' 8
         DC    XL16'00000000000000000000000000000000' 9
         DC    XL16'00000000000000000000000000000000' A
         DC    XL16'00000000000000000000000000000000' B
         DC    XL16'00000000000000000000000000000000' C
         DC    XL16'00000000000000000000000000000000' D
         DC    XL16'00000000000000000000000000000000' E
         DC    XL16'00000000000000000000000000000000' F
*                   0 1 2 3 4 5 6 7 8 9 A B C D E F
*
*              HEADING.....
*
HEADING  DS    0H
         DC    CL80' '
LHEAD    EQU   *-HEADING
         ORG   *-80
         DC    C'THE FOLLOWING LOAD MODULES MAY CONTAIN THE TIME'
         DC    C' OR STCK INSTRUCTION,'
         ORG
*
         DC    CL80' '
         ORG   *-80
         DC    C'OR CALLS A TIME ROUTINE SPECIFIED IN THE PARM...'
         ORG
*
*        DC    CL80' '
*        ORG   *-80
*        DC    C'THE CHECK ENDS WITH THE FIRST SUCCESSFUL MATCH.'
*        DC    C' '
*        DC    C'THE WHOLE MODULE IS NOT SCANNED.'
*        ORG
*
         DC    CL80' '            A BLANK LINE...
*
         DC    CL80'END OF HEADING'
*
         DC    CL80' '
         ORG   *-80
         DC    CL8'MBRNAME'
         DC    CL2'  '
         DC    CL6'LINKED'
         DC    CL2'  '
         DC    CL11'INSTRUCTION'
         DC    CL10'   '
         DC    CL9'NBR FOUND'
         ORG
*
         DC    CL80' '
         ORG   *-80
         DC    CL8'--------'
         DC    CL2'  '
         DC    CL6'------'
         DC    CL2'  '
         DC    CL11'-----------'
         DC    CL10'   '
         DC    CL9'---------'
         ORG
*
         DC    CL80'END OF HEADING'
*
*
*              DATASET NAME MESSAGE...
*
DSNMSG   DS    0H
         DC    C'PROCESSING DATASET '
PRTDSN   DC    CL44' '
         DC    CL(80-(*-DSNMSG))' '
LDSNMSG  EQU   *-DSNMSG
*
*
*              HEADING 2 .....
*
HEADING2 DS    0H
         DC    CL80' '            A BLANK LINE...
LHEAD2   EQU   *-HEADING2
*
*        DC    CL80' '            A BLANK LINE...
*
         DC    CL80' '
         ORG   *-80
         DC    CL8'MBRNAME'
         DC    CL2'  '
         DC    CL6'LINKED'
         DC    CL2'  '
         DC    CL11'INSTRUCTION'
         DC    CL10'   '
         DC    CL9'NBR FOUND'
         ORG
*
         DC    CL80' '
         ORG   *-80
         DC    CL8'--------'
         DC    CL2'  '
         DC    CL6'------'
         DC    CL2'  '
         DC    CL11'-----------'
         DC    CL10'   '
         DC    CL9'---------'
         ORG
*
         DC    CL80'END OF HEADING2'
*
*
*
*              DISCLAIMER..
*
DISCLAIM DS    0H
         DC    CL80' '
LDIS     EQU   *-DISCLAIM
         ORG   *-80
         DC    CL20' '
         DC    C'YR2000 UTILITY, VERSION 2.0'
         ORG
*
         DC    CL80' '
         ORG   *-80
         DC    C'THIS UTILITY MAY NOT FUNCTION IN ALL ENVIRONMENTS,'
         DC    C' '
         DC    C'AND IS MADE AVAILABLE ASIS.'
         ORG
*
         DC    CL80' '
         ORG   *-80
         DC    C'NO GUARANTEES OF ANY KIND ARE WARRANTED OR IMPLIED.'
         ORG
*
         DC    CL80' '
         ORG   *-80
         DC    C'USE OF THIS UTILITY DOES NOT GUARANTEE YEAR 2000'
         DC    C' '
         DC    C'COMPLIANCE.           '
         ORG
         DC    CL80' '            A BLANK LINE...
*
         DC    CL80'END OF DISLAIM'
*
         LTORG
*
*
SYSIN    DCB   DSORG=PS,MACRF=(GM),EODAD=EOFREAD,                      +
               DDNAME=SYSIN
SYSINL   EQU   *-SYSIN
*
PRINT    DCB   DDNAME=SYSPRINT,DSORG=PS,RECFM=FBA,BLKSIZE=8880,        X
               MACRF=(PM),LRECL=80
INPDS    DCB   DDNAME=INLIB,DSORG=PS,RECFM=F,BLKSIZE=256,MACRF=(R),    X
               EODAD=LOADMBR
INPDSA   DCB   DDNAME=INLIB,DSORG=PO,EODAD=GETNEXT,MACRF=(R),          X
               RECFM=U,LRECL=256,BLKSIZE=19069,                        X
               EXLST=JFCBADD
         SPACE 1
JFCBADD  DS    0F
         DC    X'87'              JFCB ADDRESS
         DC    AL3(JFCB)
         DS    0H                 PUT JFCB ON HALFWORD BOUNDARY
JFCB     DS    0CL176' '
         IEFJFCBN  LIST=NO
MODENTRY DSECT
*        DC    X'0',C'A',H'0',CL8' '   ROOM FOR 40 MODULE NAMES
MODLTH   DC    X'0'
MODTYPE  DC    C'A'
MODCTR   DC    H'0'
MODNAME  DC    CL8' '
         SPACE 1
*
*BLANKS  DC    256CL1' '
         IKJTCB
         IHACDE
         IHALPDE
         IHAPSA DSECT=YES,LIST=YES
         IHAXTLST
         IHALLE
         END   YR2000
//LKED.SYSLMOD DD DISP=SHR,DSN=HALL.LINKLIB
//SYSIN   DD *
 ENTRY   YR2000
 SETCODE AC(0)
 MODE AMODE(31) RMODE(24)
 NAME    YR2000(R)
//
