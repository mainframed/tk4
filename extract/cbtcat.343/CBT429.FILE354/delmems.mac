//DELMEMS  JOB
//*
//*    DSN=CBT.SOURCE(DELMEMS)
//*
/*ROUTE PRINT R7
//*
//*
//DELMEMS EXEC HLASMCL,
//             MAC='SYS1.AMODGEN',
//             PARMC='ALIGN,NORLD,XREF',
//             CLASS='*',COND.LKED=(7,LT,ASM)
//ASM.SYSIN DD *
DELMEMS  TITLE 'DELETE LIST OF MEMBERS FROM PDS'
*
***********************************************************************
*                                                                     *
*             MODULE NAME = DELMEMS                                   *
*                                                                     *
*             DESCRIPTIVE NAME =  PROGRAM TO DELETE LIST OF MEMBER    *
*                NAMES FROM A PDS.                                    *
*                                                                     *
*             COPYRIGHT = DIVERSIFIED DEVELOPMENTS, VICTORIA          *
*                                                                     *
*             STATUS = RELEASE 01.0                                   *
*                                                                     *
*             FUNCTION =                                              *
*                READS SYSIN TO GET A LIST OF MEMBER NAMES TO BE      *
*                DELETED FROM THE PARTITIONED DATASET IN //PDS.       *
*                                                                     *
*                OPERATION =                                          *
*                   READ SYSIN.                                       *
*                   READ PDS DIRECTORY AND COMPARE MEMBER NAME FROM   *
*                   SYSIN TO MEMBER NAME FROM DIRECTORY.              *
*                   IF MEMBER NAME MEETS CRITERIA, IT WILL BE         *
*                   DELETED.                                          *
*                   LIST MEMBER NAMES DELETED.                        *
*                   PROCESS NEXT SYSIN RECORD.                        *
*                   AT END OF LIST CLOSE DATASETS AND FREE ANY        *
*                      AQUIRED AREAS.S.                               *
*                                                                     *
*              NOTES =                                                *
*                                                                     *
*                 DEPENDENCIES = CHARACTER SET IS EBCDIC.  REASSEMBLE *
*                    IF A DIFFERENT CHARACTER SET IS NEEDED.          *
*                                                                     *
*                 RESTRICTIONS = DATASETS MUST HAVE LRECL LESS THAN   *
*                    255 AND MUST BE EITHER FIXED OR VARIABLE FORMAT. *
*                                                                     *
*                 REGISTER CONVENTIONS = STANDARD CONVENTIONS.        *
*                    REGISTERS 0 TO 10 = WORK REGISTERS               *
*                    REGISTER  11      = SECOND BASE REGISTER         *
*                    REGISTER  12      = ADDRESSABILITY TO DELMEMS    *
*                                        CSECT                        *
*                    REGISTER  13      = SAVE AREA REGISTER AND       *
*                                        ADDRESSABILITY TO GETMAINED  *
*                                        WORK AREA                    *
*                    REGISTERS 14,15   = WORK REGISTERS               *
*                                                                     *
*                SYSIN SYNTAX = - MEMBER NAME, OR                     *
*                               - PARTIAL MEMBER NAME* TO DELETE      *
*                                 ALL MEMBERS IN GROUP, OR            *
*                               - MEMBER NAME-MEMBER NAME TO DELETE   *
*                                 ALL MEMBERS IN GROUP, OR            *
*                               - PARTIAL MBR NAME-PARTIAL MBR NAME   *
*                                 TO DELETE ALL MEMBERS IN GROUP      *
*                                                                     *
*             MODULE TYPE = PROCEDURE                                 *
*                                                                     *
*                PROCESSOR = ASM                                      *
*                                                                     *
*                MODULE SIZE = 5K BYTES                               *
*                                                                     *
*                ATTRIBUTES = SCHEDULER KEY 8, NON-REENTRANT,         *
*                   PROBLEM PROGRAM STATE                             *
*                                                                     *
*             ENTRY POINTS = DELMEMS (ONLY ENTRY POINT)               *
*                                                                     *
*                LINKAGE =                                            *
*                   FROM SYSTEM                                       *
*                                                                     *
*             INPUT = MEMBER NAMES IN SYSIN                           *
*                                                                     *
*             OUTPUT = LIST OF DELETED MEMBERS                        *
*                                                                     *
*             EXIT - NORMAL = AT PROGRAM END VIA BRANCH REGISTER 14   *
*                                                                     *
*                OUTPUT = LIST OF DELETED MEMBERS                     *
*                                                                     *
*                RETURN CODE = ZERO                                   *
*                                                                     *
*             EXIT - ERROR = NONE - PROGRAM WILL DISPLAY DECIMAL      *
*                RETURN CODE AND RETURN VIA BRANCH REGISTER 14        *
*                                                                     *
*                OUTPUT = NONE                                        *
*                                                                     *
*                RETURN CODE = ZERO                                   *
*                                                                     *
*             EXTERNAL REFERENCES =                                   *
*                                                                     *
*                ROUTINES = NONE?                                     *
*                                                                     *
*                DATA AREAS = NONE                                    *
*                                                                     *
*                CONTROL BLOCKS = DCB, RDJFCB, ETC.                   *
*                                                                     *
*             TABLES = DATA AREA TO BE GETMAINED.  MAPPED BY DSECT    *
*                BEGINNING AT LABEL RDATD.                            *
*                                                                     *
*             MACROS = SAVE, GETMAIN, FREEMAIN,                       *
*                   OPEN, PUT, GET, CLOSE, RDJFCB,                    *
*                   DCB, DCBD                                         *
*                                                                     *
*             CHANGE ACTIVITY = NONE                                  *
*                                                                     *
*             MESSAGES =                                              *
*                                                                     *
*                THOSE ISSUED BY THE PROGRAM ARE FOUND FOLLOWING THE  *
*                LABEL GNRLERR AND ARE ISSUED USING PUT.              *
*                                                                     *
*             ABEND CODES = NONE                                      *
*                                                                     *
***********************************************************************
*
DELMEMS  CSECT
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         SAVE  (14,12),,DELMEMS.&SYSDATE.&SYSTIME SAVE REGISTERS
         LR    R12,R15                 LOAD REGISTER 12 WITH ENTRY
*                                      ADDRESS
         USING DELMEMS,R12             ESTABLISH ADDRESSABILITY TO
*                                      PROGRAM CSECT
         LA    R11,4095(R12)           LOAD REGISTER 11 WITH ENTRY
*                                      ADDRESS 4095
         USING DELMEMS+4095,R11        ESTABLISH ADDRESSABILITY TO THE
*                                      REST OF THE PROGRAM CSECT
         LR    R8,R1                   LOAD REGISTER 8 TO PRESERVE
*                                      POINTER TO COMMAND PROCESSOR
*                                      PARAMETER LIST
         GETMAIN R,LV=LDYNAMIC         GETMAIN DYNAMIC WORKAREA
         LR    R10,R1                  LOAD REGISTER 10 TO PRESERVE
*                                      POINTER TO WORKAREA
         ST    R13,4(R10)              STORE ADDRESS OF PREVIOUS
*                                      SAVEAREA
         ST    R10,8(,R13)             STORE ADDRESS OF CURRENT
*                                      SAVEAREA IN PREVIOUS SAVEAREA
         LR    R13,R10                 LOAD REGISTER 13 WITH ADDRESS OF
*                                      CURRENT SAVEAREA
         USING WORKAREA,R13            ESTABLISH ADDRESSABILITY TO
*                                      DYNAMIC WORKAREA
*
***********************************************************************
*                                                                     *
*        SEE IF A PARM WAS PASSED....                                 *
*                                                                     *
***********************************************************************
*
         L     R8,0(0,R8)         R8 -> TO PARM
         LH    R1,2(0,R8)         R1 = PARM LTH
         LTR   R1,R1              IS THERE A PARM?
         BZ    NOPARM             NO
         CLC   =X'0A15',STOWDEL+8 FIND SVC 21?
         BE    ZAPSVC             YES
         ABEND 21,,,USER          NO, ABEND
         SPACE 1
ZAPSVC   MVC   STOWDEL+8(2),=X'1BFF'  CHANGE SVC TO SR 15,15
         MVC   HEADER3W,=C'WOULD  BE '  CHANGE MSG 1
         MVC   NOTDEL,=C'NOT '          CHANGE MSG 2
*
***********************************************************************
*                                                                     *
*        INITIALIZE OUTPUT DATA CONTROL BLOCKS IN WORKAREA            *
*                                                                     *
***********************************************************************
*
NOPARM   DS    0H
         MVC   OUTPUTA(OUTPUTAL),OUTPUTAC  MOVE ASA DCB CONSTANT INTO
*                                      ASA DCB IN WORKAREA
*        MVC   OUTPUTM(OUTPUTML),OUTPUTMC  MOVE MACHINE DCB CONSTANT
*                                      INTO MACHINE DCB IN WORKAREA
*
         OPEN  (SYSIN,(INPUT))    OPEN INPUT DCB
         LA    R14,SCROLLIT       SET R14 FOR 1ST TIME THRU
         SPACE 1
READSYS  DS    0H
         STM   R0,R15,SAVEALL     SAVE ALL REGS
         GET   SYSIN,MBRNAME           GET INPUT RECORD
         LA    R1,MBRNAME         R1 -> TO INPUT DATA
         LA    R2,MBRNAME         R2 -> TO INPUT DATA
         SPACE 1
         MVC   STARTMBR,BLANKS    CLEAR START MBR NAME
         MVC   ENDMBR,BLANKS      CLEAR END MEMBER NAME
         MVI   MBRTYPE,C' '       CLEAR FLAG BYTE
         XC    SMBRLTH,SMBRLTH    CLEAR START MBR LTH
         XC    EMBRLTH,EMBRLTH    CLEAR END MEMBER LTH
         XC    WILDSLTH,WILDSLTH  CLEAR NBR WILD CHARS (BACKSLASH)
         XC    WILDELTH,WILDELTH  CLEAR NBR WILD CHARS (BACKSLASH)
         SPACE 1
CHKBYTE  DS    0H
         CLI   0(R2),C' '         AT END OF DATA ?
         BE    END1               YES
         CLI   0(R1),C'A'         IF 1ST CHAR IS NOT ALPHA,
         BL    NXTBYTE            THIS MUST BE AN IMS FORMAT LIB
         CLI   0(R2),C'\'         FIND WILD CHAR ?
         BE    GOTWILD            YES
         CLI   0(R2),C'*'         FIND * ?
         BE    GOTAST             YES
         CLI   0(R2),C'-'         FIND - ?
         BE    GOTDASH            YES
         SPACE 1
NXTBYTE  DS    0H
         LA    R2,1(0,R2)         R2 -> TO NEXT DATA CHAR
         B     CHKBYTE            GO CHECK IT
         SPACE 1
END1     DS    0H
         LR    R3,R2              SAVE R2
         SR    R2,R1              R2 = LTH OF DATA
         CH    R2,=H'8'           OVER 8?
         BH    BADATA             YES
         SPACE 1
*        CLI   MBRTYPE,C'-'       ARE WE PROCESSING 2ND MEMBER NAME ?
*        BE    GOTDASH2           YES
*        STH   R2,SMBRLTH         SAVE MBR LTH
         MVI   EMBRLTH+1,8        SET END MBR LTH TO 8
         BCTR  R2,0               R2 = HEX LTH
         STC   R2,MOVE1+1         SAVE MBR NAME LTH
MOVE1    MVC   ENDMBR(0),0(R1)    SAVE END MBR NAME
*OVE1    MVC   STARTMBR(0),0(R1)  SAVE START MBR NAME
         CLI   SMBRLTH+1,0        IS THERE A START MEMBER?
         BH    ENDREAD            YES, ON WE GO
         MVC   STARTMBR,ENDMBR    NO, SET UP START MBR NAME
         MVI   SMBRLTH+1,8        SET START MBR LTH TO 8
         B     ENDREAD            ON WE GO
         SPACE 1
GOTWILD  DS    0H
         CLI   MBRTYPE,C' '       ARE WE PROCESSING 2ND MEMBER NAME ?
         BNE   GOTWILD1           YES
         LH    R4,WILDSLTH        R4 = NBR START WILD CARDS
         LA    R4,1(0,R4)         ADD 1
         STH   R4,WILDSLTH        SAVE NBR
         B     NXTBYTE            GO CHECK NEXT BYTE...
         SPACE 1
GOTWILD1 DS    0H
         LH    R4,WILDELTH        R4 = NBR START WILD CARDS
         LA    R4,1(0,R4)         ADD 1
         STH   R4,WILDELTH        SAVE NBR
         B     NXTBYTE            GO CHECK NEXT BYTE...
         SPACE 1
GOTAST   DS    0H
         CLI   MBRTYPE,C' '       ARE WE PROCESSING 2ND MEMBER NAME ?
         BNE   GOTAST1            YES
         MVI   MBRTYPE,C'*'       SAY WE GOT * TYPE
         SPACE 1
GOTAST1  DS    0H
         LR    R3,R2              SAVE R2
         SR    R2,R1              R2 = LTH OF DATA
         CH    R2,=H'8'           OVER 8?
         BH    BADATA             YES
         SPACE 1
         CLI   SMBRLTH+1,0        IS THERE A START MEMBER?
         BH    GOTAST2            YES, ON WE GO
         STH   R2,SMBRLTH         SAVE MBR LTH
         BCTR  R2,0               R2 = HEX LTH
         STC   R2,MOVE2+1         SAVE MBR NAME LTH
MOVE2    MVC   STARTMBR(0),0(R1)  SAVE START MBR NAME
         CLI   1(R3),C'-'         NEXT CHAR DASH(-) ?
         BE    GOTEND1            YES
         MVC   ENDMBR,STARTMBR    SET UP END MBR NAME
         MVC   EMBRLTH,SMBRLTH    SET END MBR LTH
         B     ENDREAD            ON WE GO
         SPACE 1
GOTEND1  DS    0H
         LA    R1,2(0,R3)         R1 -> TO SECOND MEMBER
         LR    R2,R1              R2 -> TO SECOND MEMBER
         B     CHKBYTE            GO CHECK SECOND MEMBER NAME
         SPACE 1
GOTAST2  DS    0H
         STH   R2,EMBRLTH         SET END MBR LTH
         BCTR  R2,0               R2 = HEX LTH
         STC   R2,MOVE2A+1        SAVE MBR NAME LTH
MOVE2A   MVC   ENDMBR(0),0(R1)    SAVE END MBR NAME
         B     ENDREAD            ON WE GO
         SPACE 1
GOTDASH  DS    0H
         MVI   MBRTYPE,C'-'       SAY WE GOT - TYPE
         LR    R3,R2              SAVE R2
         SR    R2,R1              R2 = LTH OF DATA
         CH    R2,=H'8'           OVER 8?
         BH    BADATA             YES
         SPACE 1
*        STH   R2,SMBRLTH         SAVE MBR LTH
         BCTR  R2,0               R2 = HEX LTH
         STC   R2,MOVE3+1         SAVE MBR NAME LTH
MOVE3    MVC   STARTMBR(0),0(R1)  SAVE START MBR NAME
         MVI   SMBRLTH+1,8        SET START MBR LTH TO 8
         LA    R1,1(0,R3)         R1 -> TO SECOND MEMBER
         LR    R2,R1              R2 -> TO SECOND MEMBER
         B     CHKBYTE            GO CHECK SECOND MEMBER NAME
         SPACE 1
GOTDASH2 DS    0H
         LR    R3,R2              SAVE R2
         STH   R2,EMBRLTH         SAVE MBR LTH
         BCTR  R2,0               R2 = HEX LTH
         STC   R2,MOVE4+1         SAVE MBR NAME LTH
MOVE4    MVC   ENDMBR(0),0(R1)    SAVE END MBR NAME
*        B     ENDREAD            ON WE GO
         SPACE 1
ENDREAD  DS    0H
         LM    R0,R15,SAVEALL     RELOAD ALL REGS
         BR    R14                RETURN TO CALLER
         SPACE 1
BADATA   DS    0H
         ABEND 999
*
EOFREAD  DS    0H
         CLOSE (SYSIN)                 CLOSE INPUT DCB
         MVI   STARTMBR,X'FF'     SIGNAL END OF SYSIN
         B     ENDREAD            RETURN TO CALLER
*                                                                     *
***********************************************************************
*                                                                     *
*        OPEN THE DIRECTORY OF THE PDS                                *
*                                                                     *
***********************************************************************
*
SCROLLIT DS    0H
         CLI   STARTMBR,X'FF'     END OF SYSIN?
         BE    RETURN             YES, JUST RETURN
*        ST    R6,SAVER6               SAVE REGISTER 6
         LA    R8,DIRECT               LOAD POINTER TO DIRECTORY DCB
         USING IHADCB,R8               ESTABLISH ADDRESSABILITY TO DCB
         MVC   DIRECT(DIRECTL),DIRECTC MOVE DIRECTORY DCB CONSTANT INTO
*                                      DIRECTORY DCB IN WORKAREA
         MVC   OPENLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT
*                                      INTO OPEN LIST IN WORKAREA
         OPEN  ((R8),INPUT),MF=(E,OPENLST)  OPEN DIRECTORY DCB
         TM    DCBOFLGS,DCBOFOPN       SEE IF DCB OPENED SUCCESSFULLY
         BNO   NOTPMESS                NO.....GO PUT OUT NOT PRINTED
*                                      MESSAGE
         DROP  R8                      DROP ADDRESSABILITY TO DCB
*                                                                     *
***********************************************************************
*                                                                     *
*        GETMAIN MEMBER TABLE FOR STORAGE OF DIRECTORY NAMES, ETC.    *
*           INITIALIZE TABLE                                          *
*                                                                     *
***********************************************************************
*
         L     R0,MEMDATL              LOAD LENGTH OF GETMAIN FOR
*                                      MEMBER TABLE
         LR    R2,R0                   SAVE IN REGISTER 2
         GETMAIN R,LV=(0)              GETMAIN MEMBER TABLE STORAGE
         ST    R1,MEMTABLE             SAVE ADDRESS OF MEMBER TABLE
         ST    R1,PRESENT              ALSO SAVE ADDRESS AS TABLE
*                                      IN USE
         LA    R3,0(R2,R1)             LOAD ADDRESS OF END OF TABLE
         ST    R3,ENDTABLE             STORE ADDRESS OF TABLE END
         SLR   R4,R4                   ZERO REGISTER 4
         ST    R4,0(R1)                STORE AS FIRST WORD OF MEMBER
*                                      TABLE
         LA    R4,8(R1)                LOAD REGISTER 4 AS POINTER TO
*                                      THE FIRST ENTRY
         USING MEMDSECT,R4             ESTABLISH ADDRESSABILITY TO
*                                      MEMBER TABLE DSECT
         SLR   R5,R5                   INITIALIZE MEMBER COUNT TO ZERO
*                                                                     *
***********************************************************************
*                                                                     *
*        READ DIRECTORY AND BUILD MEMBER TABLE                        *
*                                                                     *
***********************************************************************
*
GETDIR   EQU   *
         GET   (R8),DATA               GET A DIRECTORY BLOCK
         CLC   DATA(2),HALF12          SEE IF BLOCK IS UNUSED
         BL    FREEBLK                 YES....GO HANDLE DIRECTORY END
         LA    R9,DATA+2               LOAD POINTER TO FIRST DIRECTORY
*                                      ENTRY
         SLR   R7,R7                   ZERO REGISTER 7 FOR INSERT
         ICM   R7,3,DATA               INSERT LENGTH USED OF THIS BLOCK
         LA    R7,DATA-1(R7)           LOAD LAST USED BYTE OF BLOCK
UNBLOCK  DS    0H
         MVC   MEMNTTR,0(R9)           PUT NAME AND TTR IN TABLE
         MVC   CFIELD,11(R9)           PUT C FIELD IN TABLE
         CLI   MEMBER,HEXFF            SEE IF LAST MEMBER
         BE    FREEBLK                 YES....GO HANDLE DIRECTORY END
         IC    R6,CFIELD               INSERT CFIELD INTO REGISTER 6
         SLL   R6,27                   SHIFT OUT HIGH ORDER BITS
         SRL   R6,26                   SHIFT RIGHT TO GET LENGTH OF
*                                      USER DATA
         LA    R6,12(R6)               ADD STANDARD ENTRY LENGTH
         SPACE 1
         LH    R1,SMBRLTH         R1 = START MEMBER NAME LTH
         LH    R14,WILDSLTH       R14 = NBR WILD CHARS IN START MBR
         LTR   R14,R14            ARE THERE ANY?
         BZ    NOWILDS            NO
         LA    R14,STARTMBR       R14 -> TO START MBR NAME
         LA    R10,STARTMBR       R10 -> TO END   MBR NAME
         LA    R15,MEMBER         R15 -> TO DIR MEMBER NAME
         SPACE 1
CHKWILD1 DS    0H
         CLI   0(R14),C'\'        WILD CARD?
         BNE   CHKWILD3           NO
         SPACE 1
CHKWILD2 DS    0H
         LA    R14,1(0,R14)       ADD 1 TO R14
         LA    R10,1(0,R10)       ADD 1 TO R10
         LA    R15,1(0,R15)       ADD 1 TO R15
         BCT   R1,CHKWILD1        CHECK FOR MORE....
         B     NOTWANT            DELETE THIS MEMBER...
         SPACE 1
CHKWILD3 DS    0H
         CLC   0(1,R15),0(R14)    IS THIS A CHAR WE WANT ?
         BL    NEXTNTRY           NO
         CLC   0(1,R15),0(R10)    IS THIS A CHAR WE WANT ?
         BH    NEXTNTRY           NO, BUT CHECK ALL MEMBERS....
*        BH    GETMBR             NO
         B     CHKWILD2           YES, CHECK NEXT BYTE...
         SPACE 1
NOWILDS  DS    0H
         BCTR  R1,0               R1 = HEX LTH
         STC   R1,CLC1+1          PUT IT IN CLC INST
CLC1     CLC   MEMBER,STARTMBR    DO WE WANT THIS MEMBER?
*LC1     CLC   0(0,R9),STARTMBR   DO WE WANT THIS MEMBER?
         BL    NEXTNTRY           NO
         SPACE 1
         LH    R1,EMBRLTH         R1 = END MEMBER NAME LTH
         BCTR  R1,0               R1 = HEX LTH
         STC   R1,CLC2+1          PUT IT IN CLC INST
CLC2     CLC   MEMBER,ENDMBR      DO WE WANT THIS MEMBER?
*LC2     CLC   0(0,R9),ENDMBR     DO WE WANT THIS MEMBER?
         BH    GETMBR             NO
         B     NOTWANT            YES, ON WE GO
         SPACE 1
GETMBR   DS    0H
         BAL   R14,READSYS        GO GET NEXT SYSIN CONTROL CARD
         CLI   STARTMBR,X'FF'     END OF SYSIN?
         BE    FREEBLK            YES, GO HANDLE DIRECTORY END
         B     UNBLOCK            NO, SEE IF WE WANT IT/THEM
         SPACE 1
NOTWANT  DS    0H
         LA    R4,MEMSECTN        LOAD POINTER TO NEXT TABLE ENTRY
         LA    R5,1(R5)                INCREMENT NUMBER OF MEMBERS IN
*                                      TABLE
         C     R4,ENDTABLE             SEE IF END OF TABLE
         BL    NEXTNTRY                LOW.....GO PROCESS NEXT ENTRY
         LR    R0,R2                   LOAD LENGTH OF TABLE FOR GETMAIN
         GETMAIN R,LV=(0)              GET NEXT TABLE
         L     R14,PRESENT             LOAD REGISTER 14 WITH ADDRESS OF
*                                      LAST TABLE
         ST    R1,0(R14)               CHAIN MEMBER TABLES TOGETHER
         ST    R1,PRESENT              ALSO SAVE ADDRESS AS TABLE
*                                      IN USE
         LA    R3,0(R2,R1)             LOAD ADDRESS OF TABLE END
         ST    R3,ENDTABLE             STORE ADDRESS OF TABLE END
         SLR   R4,R4                   ZERO REGISTER 4
         ST    R4,0(R1)                STORE AS FIRST WORD OF MEMBER
*                                      TABLE
         LA    R4,8(R1)                LOAD REGISTER 4 AS POINTER TO
*                                      THE FIRST ENTRY
         STH   R5,4(R14)               STORE MEMBER COUNT IN OLD TABLE
         SLR   R5,R5                   INITIALIZE MEMBER COUNT TO ZERO
NEXTNTRY DS    0H
         BXLE  R9,R6,UNBLOCK           INCREMENT REGISTER 9 WITH
*                                      REGISTER 6 AND BRANCH
*                                      LESS THAN OR EQUAL TO
*                                      REGISTER 7 TO UNBLOCK
         B     GETDIR                  NO.....GO GET NEXT DIRECTORY
*                                      BLOCK
         DROP  R4                      DROP ADDRESSABILITY TO TABLE
*
***********************************************************************
*                                                                     *
*        CLOSE PDS DIRECTORY                                          *
*        OPEN SYSPRINT DCB                                            *
*        OPEN PDS DATASET FOR OUTPUT WITH A MEMBER NAME OF 99999999   *
*        LIST MEMBERS IF:                                             *
*           LIST SPECIFIED OR                                         *
*           BOTH PRINT AND NOLIST WERE NOT SPECIFIED                  *
*                                                                     *
***********************************************************************
*
FREEBLK  DS    0H
         MVC   OPENLST,OPENCLOS        MOVE CONSTANT INTO CLOSE LIST
         CLOSE ((R8),),MF=(E,OPENLST)  CLOSE DIRECTORY DCB
         L     R2,PRESENT              LOAD POINTER TO LAST TABLE
         STH   R5,4(R2)                STORE COUNT OF MEMBERS
         L     R4,MEMTABLE             LOAD POINTER TO FIRST TABLE
         CLC   4(2,R4),HALF0           SEE IF THERE WERE ANY MEMBERS
         BE    ENDMEMB                 ZERO...GO FREE MEMBER TABLE
         LA    R8,INPUT                LOAD POINTER TO INPUT DCB
         USING IHADCB,R8               ESTABLISH ADDRESSABILITY TO DCB
         MVC   INPUT(INPUTL),INPUTC    MOVE INPUT DCB CONSTANT INTO
*                                      INPUT DCB IN WORKAREA
         MVC   OPENLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT
*                                      INTO OPEN LIST IN WORKAREA
         LA    R1,XLIST                LOAD ADDRESS OF EXIT LIST
         ST    R1,DCBEXLST             STORE ADDRESS OF EXIT LIST IN
*                                      DCB
         LA    R2,JFCBAREA             LOAD ADDRESS OF JFCBAREA
         ST    R2,XLIST                STORE ADDRESS IN EXIT LIST
         MVI   XLIST,X'87'             SET END OF LIST AND JFCB BYTE
         MVC   RDJL,OPENCLOS           MOVE OPEN(CLOSE) LIST CONSTANT
*                                      INTO READJFCB LIST IN
*                                      WORKAREA
         RDJFCB ((8),),MF=(E,RDJL)   READ JFCB INTO JFCBAREA
         MVC   JFCBELNM,=C'99999999'   MOVE MEMBER NAME INTO JFCB
         OI    JFCBIND1,JFCPDS         SET JFCB TO INDICATE PDS MEMBER
         MVI   JFCDSRG1,HEX00          SET JFCB TO REMOVE OTHER DSORG
*                                      INDICATORS
         OPEN  ((R8),(OUTPUT)),TYPE=J,MF=(E,OPENLST)  OPEN INPUT DCB
         MVC   HEADER,HEADERM          MOVE HEADER INTO DATA AREA
SUSEA    DS    0H
         LA    R5,OUTPUTA              LOAD ADDRESS OF OUTPUT DCB FOR
*                                      ASA CODE
         LA    R4,EJECTA               LOAD ADDRESS OF EJECT DATA
         TM    48(R5),DCBOFOPN         SEE IF DCB IS ALREADY OPEN
         BO    SPUTDSN                 YES....GO PUT OUT HEADERS
         LA    R3,PRINTA               LOAD POINTER TO PRINTA
         OPEN  ((R5),(OUTPUT)),MF=(E,OPENLST)
*        BAL   R14,ALLOCOUT            LOAD ADDRESS FOR RETURN AND GO
*                                      DO SYSOUT ALLOCATION
SPUTDSN  DS    0H
         PUT   (R5),(R4)               PUT OUT PAGE EJECT
         PUT   (R5),HEADER             PUT OUT PAGE 1 HEADER
         MVC   HEADER2,LDSNAME         MOVE LENGTH AND 'DSNAME=' INTO
*                                      INTO SECOND HEADER
         MVC   DSNAME,JFCBAREA         MOVE DSNAME INTO DATA AREA
         MVC   HEADER2+4(1),HDRCNTL    MOVE IN CONTROL BYTE
         MVI   OPENPRN,BLANK           BLANK OUT MEMBER NAME
         MVC   MEMNAME(9),OPENPRN      FINISH BLANKING OUT MEMBER NAME
         PUT   (R5),HEADER2            PUT OUT PAGE 1 HEADER 2
         PUT   (R5),HEADER3            PUT OUT PAGE 1 HEADER 3
         L     R2,MEMTABLE             LOAD ADDRESS OF FIRST TABLE
         MVC   LENGTH,HALF85           SET LENGTH TO 85 BYTES
         MVC   LENGTH+2,HALF0          ZERO RESERVED BYTES
         MVC   CNTLBYTE,HDRCNTL        MOVE IN HEADER CONTROL BYTE
*
***********************************************************************
*                                                                     *
*        DELETE AND LIST MEMBER NAMES                                 *
*                                                                     *
***********************************************************************
*
SCROLLER DS    0H
         LA    R10,LINECNT             LOAD LINE COUNT
         ST    R2,PRESENT              SAVE ADDRESS OF CURRENT TABLE
         LH    R7,4(R2)                LOAD NUMBER OF MEMBERS IN TABLE
         LTR   R7,R7                   SEE IF THERE ARE ENTRIES
         BZ    NOLIST                  NO.....END OF DELETE PROGRAM
         LA    R2,8(R2)                LOAD ADDRESS OF FIRST MEMBER
         USING MEMDSECT,R2             ESTABLISH ADDRESSABILITY TO
*                                      MEMBER TABLE ENTRY
LOOP1    DS    0H
         LA    R6,DATA                 LOAD ADDRESS OF OUTPUT BUFFER
         MVI   DATA,BLANK              BLANK OUT OUTPUT BUFFER
         MVC   DATA+1(79),DATA         FINISH BLANKING BUFFER
         SPACE 1
DEL1     DS    0H
         TM    CFIELD,HIGH             SEE IF THIS IS AN ALIAS
         BZ    NOTALIAS                NO.....CONTINUE WITH MAIN NAME
         BAL   R14,LOOKLOOP            GO LOOK FOR MAIN NAME
NOTALIAS DS    0H
*
*              DELETE MEMBER HERE
*
         LA    R8,INPUT           LOAD POINTER TO PDS DCB
STOWDEL  STOW  (8),MEMBER,D       DELETE MEMBER
         LTR   R15,R15            WAS DELETE OKAY?
         BNZ   NODEL1             NO, DON'T PUT NAME IN LIST
         MVC   2(8,R6),MEMBER          PUT MEMBER NAME IN OUTPUT BUFFER
         AP    DELETED,ONE        ADD 1 TO COUNTER
         SPACE 1
NODEL1   DS    0H
         ST    R2,SAVER2               SAVE REGISTER 2
         LA    R6,10(R6)               LOAD POINTER TO NEXT OUTPUT
         LA    R2,DATA+70         R2 -> TO LAST PRINT ENTRY
         CR    R6,R2              IS LINE FULL?
         BH    END2               YES, GO PRINT LINE
         L     R2,SAVER2               RELOAD REGISTER 2
         LA    R2,MEMSECTN             LOAD POINTER TO NEXT MEMBER NAME
*                                      BUFFER LOCATION
         BCT   R7,DEL1                 DECREMENT MEMBER COUNT FOR
*                                 CURRENT TABLE AND GO DELETE MBR
         B     LOOP3              GO GET NEXT TABLE, IF ANY
         SPACE 1
END2     DS    0H
         PUT   (R5),LINE               PUT OUT OUTPUT LINE
         LA    R6,DATA                 LOAD ADDRESS OF OUTPUT BUFFER
         MVI   DATA,BLANK              BLANK OUT OUTPUT BUFFER
         MVC   DATA+1(79),DATA         FINISH BLANKING BUFFER
         SPACE 1
         SPACE 1
END3     DS    0H
         L     R2,SAVER2               RELOAD REGISTER 2
         LA    R2,MEMSECTN             LOAD POINTER TO NEXT MEMBER NAME
         BCT   R10,MOREROW             DECREMENT ROW COUNT
         PUT   (R5),(R4)               PUT OUT PAGE EJECT WHEN ZERO
         LA    R10,LINECNT             LOAD LINE COUNT
         SPACE 1                       RESET COUNTERS
MOREROW  DS    0H
         BCT   R7,DEL1                 DECREMENT MEMBER COUNT FOR
*        BCT   R7,LOOP1                DECREMENT MEMBER COUNT FOR
*                                      CURRENT TABLE
LOOP3    L     R2,PRESENT              LOAD POINTER TO CURRENT TABLE
         L     R2,0(R2)                LOAD POINTER TO NEXT TABLE
         LTR   R2,R2                   SEE IF IT WAS THE LAST TABLE
         BZ    NOROLLER           YES
         ST    R2,PRESENT              SAVE ADDRESS OF CURRENT TABLE
         LH    R7,4(R2)                LOAD NUMBER OF MEMBERS IN TABLE
         LTR   R7,R7                   SEE IF THERE ARE ENTRIES
         BZ    NOROLLER                NO.....END OF DELETE PROGRAM
         LA    R2,8(R2)                LOAD ADDRESS OF FIRST MEMBER
         B     DEL1               GO DELETE MEMBERS
*        BNZ   SCROLLER                NO.....GO LIST OUT NEXT TABLE
*
NOROLLER DS    0H
         PUT   (R5),LINE               PUT OUT LAST OUTPUT LINE
         ED    DELCOUNT,DELETED   CONVERT DELETE COUNT TO DISPLAY
         PUT   (R5),HEADER4            PUT OUT NBR DELETED
*
***********************************************************************
*                                                                     *
*        END OF DELETE PROGRAM                                        *
*                                                                     *
***********************************************************************
*
NOTPMESS DS    0H
NOLIST   DS    0H
CONTPRT  DS    0H
         L     R6,SAVER6               RESTORE REGISTER 6
ENDMEMB  DS    0H
         L     R2,MEMTABLE             LOAD POINTER TO FIRST TABLE
FREETABS DS    0H
         LR    R1,R2                   LOAD AREA TO BE FREED
         L     R2,0(R2)                LOAD POINTER TO NEXT TABLE
         L     R0,MEMDATL              LOAD SIZE OF AREA TO BE FREED
         FREEMAIN R,LV=(0),A=(1)       FREE STORAGE GETMAINED FOR TABLE
         LTR   R2,R2                   SEE IF THERE WAS ANOTHER TABLE
         BNZ   FREETABS                YES....GO FREE NEXT TABLE
         L     R6,SAVER6               RESTORE REGISTER 6
         LA    R8,INPUT                LOAD POINTER TO INPUT DCB
         USING IHADCB,R8               ESTABLISH ADDRESSABILITY TO DCB
         TM    DCBOFLGS,DCBOFOPN       SEE IF INPUT DCB IS STILL OPEN
         BNO   RETURN                  NO.....GO RETURN
         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT
*                                      INTO CLOSE LIST IN WORKAREA
         CLOSE ((R8),),MF=(E,CLOSLST)  CLOSE INPUT DCB
         DROP  R8                      DROP ADDRESSABILITY TO DCB
         B     RETURN                  RETURN
*                                                                     *
***********************************************************************
*                                                                     *
*        PUT OUT SYNAD ERROR MESSAGE,                                 *
*           GO FREE MEMBER TABLES, AND                                *
*           CONTINUE WITH NEXT DATASET                                *
*                                                                     *
***********************************************************************
*
SERRI    DS    0H
*        PUTLINE OUTPUT=(SYNADI,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      DATASET NOT PRINTED DUE TO SYNAD
*                                      ERROR ON INPUT DATASET MESSAGE
         B     ENDMEMB                 GO FREE MEMBER TABLES
*                                                                     *
***********************************************************************
*                                                                     *
*        SEARCH FOR MAIN NAME,                                        *
*           SAME TTR AND NOT AN ALIAS                                 *
*                                                                     *
***********************************************************************
*
LOOKLOOP DS    0H
         STM   R3,R4,SAVER3            SAVE REGISTERS 3 AND 4
         L     R3,MEMTABLE             LOAD ADDRESS OF FIRST TABLE
         USING MEMDSECT,R3             ESTABLISH ADDRESSABILITY TO
*                                      MEMBER ENTRY
LOOP4    DS    0H
         ST    R3,CURRENT              SAVE ADDRESS OF PRESENT TABLE
         LH    R4,4(R3)                LOAD NUMBER OF ELEMENTS IN TABLE
         LTR   R4,R4                   SEE IF THERE ARE ZERO ELEMENTS
         BZ    NOMAIN                  YES....GO HANDLE MAIN NOT FOUND
         LA    R3,8(R3)                LOAD ADDRESS OF FIRST MEMBER
LOOP5    DS    0H
         CLC   MEMTTR,8(R2)            SEE IF TTRS ARE THE SAME
         BE    SAMETTR                 YES....GO SEE IF IT IS AN ALIAS
ENDLP5   DS    0H
         LA    R3,MEMSECTN             LOAD ADDRESS OF NEXT MEMBER
         BCT   R4,LOOP5                DECREMENT MEMBER COUNT
         L     R3,CURRENT              LOAD ADDRESS OF THIS TABLE
         L     R3,0(R3)                LOAD ADDRESS OF NEXT TABLE
         LTR   R3,R3                   SEE IF IT WAS THE LAST TABLE
         BNZ   LOOP4                   NO.....GO CHECK NEXT TABLE
         B     NOMAIN                  GO HANDLE MAIN NOT FOUND
SAMETTR  DS    0H
         TM    CFIELD,HIGH             SEE IF THIS IS ALSO AN ALIAS
         BO    ENDLP5                  YES....GO LOOK FOR ANOTHER TTR
         MVC   11(8,R6),MEMBER         MOVE MEMBER NAME INTO OUTPUT
         B     ENDLOOK                 GO TO RETURN TO CALLER
NOMAIN   DS    0H
         MVC   11(8,R6),ALIAS          INDICATE THIS IS AN ALIAS
ENDLOOK  DS    0H
         LM    R3,R4,SAVER3            RESTORE REGISTERS 3 AND 4
         BR    R14                     RETURN TO CALLER
         DROP  R3                      DROP ADDRESSABILITY TO TABLE
*
         AGO   .BYPASS2
CONTINUE DS    0H
*        L     R6,24(R6)               LOAD POINTER TO NEXT DSNAME ON
*                                      CHAIN
*        C     R6,ENDCHAIN             SEE IF END OF CHAIN IS REACHED
*        BNE   NEXT                    NO.....GO DO NEXT DATASET NAME
CLOSDCBS DS    0H
         TM    INPUT+48,DCBOFOPN       SEE IF INPUT DCB IS STILL OPEN
         BNO   CHKOUTA                 NO.....GO CHECK DCB FOR ASA CODE
         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT
*                                      INTO CLOSE LIST WORKAREA
         LA    R5,INPUT                LOAD POINTER TO INPUT DCB
         CLOSE ((R5),),MF=(E,CLOSLST)  CLOSE INPUT DCB
CHKOUTA  DS    0H
         TM    OUTPUTA+48,DCBOFOPN     SEE IF OUTPUT DCB FOR ASA WAS
*                                      OPENED
         BNO   CHKOUTM                 NO.....GO CHECK DCB FOR MACHINE
*                                      CODE
         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT
*                                      INTO CLOSE LIST WORKAREA
         LA    R5,OUTPUTA              LOAD POINTER TO ASA CODE DCB
         CLOSE ((R5),),MF=(E,CLOSLST)  CLOSE ASA CODE OUTPUT DCB
         LA    R1,PRINTA               LOAD ADDRESS OF PRINT DDNAME
*        BAL   R2,FREEDD               GO FREE ASA CODE OUTPUT DDNAME
CHKOUTM  DS    0H
         TM    OUTPUTM+48,DCBOFOPN     SEE IF OUTPUT DCB FOR MACHINE
*                                      CODE WAS OPENED
         BNO   RETURN                  NO.....GO FREE GETMAINED AREAS
*                                      AND RETURN
         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT
*                                      INTO CLOSE LIST WORKAREA
         LA    R5,OUTPUTM              LOAD POINTER TO MACHINE CODE DCB
         CLOSE ((R5),),MF=(E,CLOSLST)  CLOSE MACHINE CODE OUTPUT DCB
         LA    R1,PRINTM               LOAD ADDRESS OF PRINT DDNAME
*        BAL   R2,FREEDD               GO FREE MACHINE CODE OUTPUT
*                                      DDNAME
.BYPASS2 ANOP
*
***********************************************************************
*                                                                     *
*        CLEANUP AREAS GETMAINED,                                     *
*           SET RETURN CODE, RESTORE REGISTERS AND                    *
*           RETURN TO CALLER                                          *
*                                                                     *
***********************************************************************
*
RETURN   DS    0H
         LR    R1,R13                  LOAD ADDRESS OF GETMAINED AREA
         L     R13,4(,R13)             RELOAD ADDRESS OF PREVIOUS SAVE
*                                      AREA
         LA    R0,LDYNAMIC             LOAD LENGTH OF GETMAINED AREA
         FREEMAIN R,LV=(0),A=(1)       FREE GETMINED AREA
         SLR   R15,R15                 ZERO REGISTER 15.  RETURN CODE
*                                      CODE WILL ALWAYS BE ZERO
         L     R14,12(,R13)            LOAD REGISTER 14 WITH RETURN
*                                      ADDRESS
         LM    R0,R12,20(R13)          RESTORE REGISTERS
         BR    R14                     RETURN
         AGO   .BYPASS3
*
***********************************************************************
*                                                                     *
*        ROUTINE TO CONVERT NONZERO RETURN CODES TO DECIMAL           *
*           FOR DISPLAY                                               *
*                                                                     *
***********************************************************************
*
SETCODE  DS    0H
         CVD   R8,DEC                  CONVERT RETURN CODE TO DECIMAL
         UNPK  CONV(8),DEC(8)          UNPACK RETURN CODE
         MVZ   CONV+1(7),CONV          MOVE ZONES IN CONVERTED RETURN
*                                      CODE
         MVC   RETNCD(2),HALF12        MOVE LENGTH OF DATA FOR PUTLINE
         MVC   RETNCD+2(2),HALF0       MOVE IN ZEROES FOR PUTLINE
         BR    R14                     RETURN
.BYPASS3 ANOP
         AGO   .BYPASS4
*
***********************************************************************
*                                                                     *
*        READS RECORDS USING GET MOVE                                 *
*           AND ATTRIBUTES OF GIVEN DATASET                           *
*        WRITES THESE SAME RECORDS USING PUT MOVE                     *
*           AND THE INPUT DATASET ATTRIBUTES                          *
*                                                                     *
***********************************************************************
*
PRINTIT  DS    0H
         LA    R8,INPUT                LOAD POINTER TO INPUT DCB
         USING IHADCB,R8               ESTABLISH ADDRESSABILITY TO DCB
         MVC   INPUT(INPUTL),INPUTC    MOVE INPUT DCB CONSTANT INTO
*                                      INPUT DCB IN WORKAREA
         MVC   OPENLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT
*                                      INTO OPEN LIST IN WORKAREA
         OPEN  ((R8),INPUT),MF=(E,OPENLST)  OPEN INPUT DCB
PRINTS   DS    0H                      BRANCH ADDRESS FOR PRINTING
*                                      MEMBERS
         TM    DCBOFLGS,DCBOFOPN       SEE IF DCB OPENED SUCCESSFULLY
         BNO   NOTPMESS                NO.....GO PUT OUT NOT PRINTED
*                                      MESSAGE
         TM    DCBRECFM,DCBRECU        SEE IF RECFM IS UNDEFINED
         BO    ERRORU                  NO.....GO PUT OUT ERROR MESSAGE
         BZ    ERRORU                  ZERO...NOT FIXED OR VARIABLE SO
*                                      GO PUT OUT ERROR MESSAGE
         CLC   DCBLRECL,HALF256        SEE IF LRECL IS GREATER THAN 256
         BH    ERRORL                  YES....GO PUT OUT RECORD LENGTH
*                                      MESSAGE
         LA    R9,LINE                 LOAD ADDRESS FOR INPUT
         SLR   R4,R4                   ZERO OUT REGISTER 4
         ST    R4,LENGTH               STORE ZERO IN LENGTH (PLUS 2
*                                      RESERVED BYTES) FIELD
         TM    DCBRECFM,DCBRECV        SEE IF RECFM IS VARIABLE
         BO    CHKCNTRL                YES....GO PUT OUT DSNAME
*                                      NO.....RECFM MUST BE FIXED
*                                      SO CONTINUE
         A     R9,FULL4                SET TO HAVE FIXED LENGTH
         LH    R4,DCBLRECL             LOAD LOGICAL RECORD LENGTH
         A     R4,FULL4                ADD 4 FOR LENGTH FIELD PREFIX
         STH   R4,LENGTH               STORE IN LENGTH FIELD
CHKCNTRL DS    0H
         MVC   HEADER,HEADERC          MOVE HEADER INTO DATA AREA
         TM    DCBRECFM,DCBRECCM       SEE IF CONTROL IS MACHINE
         BNO   USEA                    NO.....GO TO USE ASA CONTROL
         LA    R5,OUTPUTM              LOAD ADDRESS OF OUTPUT DCB FOR
*                                      MACHINE CODE
         LA    R4,EJECTM               LOAD ADDRESS OF EJECT DATA
         MVI   HDRCNTL,SKIPM           MOVE INTO HEADER MACHINE CODE
*                                      FOR SPACE
         TM    48(R5),DCBOFOPN         SEE IF DCB IS ALREADY OPEN
         BO    PUTDSN                  YES....GO PUT OUT HEADERS
         LA    R3,PRINTM               LOAD POINTER TO PRINTM
         LA    R14,PUTDSN              LOAD ADDRESS FROM RETURN FROM
*                                      SYSOUT ALLOCATION
*        B     ALLOCOUT                GO TO ALLOCATE SYSOUT
USEA     DS    0H
         TM    DCBRECFM,DCBRECCA       SEE IF CONTROL IS ASA
         BO    GOODLENA                YES....GO SEE IF DCB IS OPEN
         A     R9,FULL1                SET GET AREA TO ALLOW FOR NO
*                                      CONTROL
         A     R4,FULL1                ADD ONE FOR A CONTROL BYTE
         STH   R4,LENGTH               STORE LENGTH IN PUT AREA
GOODLENA DS    0H
         LA    R5,OUTPUTA              LOAD ADDRESS OF OUTPUT DCB FOR
*                                      ASA CODE
         LA    R4,EJECTA               LOAD ADDRESS OF EJECT DATA
         TM    48(R5),DCBOFOPN         SEE IF DCB IS ALREADY OPEN
         BO    PUTDSN                  YES....GO PUT OUT HEADERS
         LA    R3,PRINTA               LOAD POINTER TO PRINTA
*        BAL   R14,ALLOCOUT            LOAD ADDRESS FOR RETURN AND GO
*                                      DO SYSOUT ALLOCATION
PUTDSN   DS    0H
         PUT   (R5),(R4)               PUT OUT PAGE EJECT
         PUT   (R5),HEADER             PUT OUT PAGE 1 HEADER
         MVC   HEADER2,LDSNAME         MOVE LENGTH AND 'DSNAME=' INTO
*                                      INTO SECOND HEADER
         MVC   HEADER2+4(1),HDRCNTL    MOVE IN CONTROL BYTE
         CLI   MEMNAME,BLANK           SEE IF MEMBER NAME IS BLANK
         BE    NOMEM                   YES....NO NEED TO PUT IN PARENS
         MVI   OPENPRN,C'('            MOVE OPEN PAREN INTO DSNAME
         MVI   CLOSEPRN,C')'           MOVE CLOSE PAREN INTO DSNAME
         B     PUTHDR2                 GO PUT OUT HEADER 2
NOMEM    DS    0H
         MVI   OPENPRN,BLANK           MOVE BLANK INSTEAD OF OPEN AND
         MVI   CLOSEPRN,BLANK          CLOSE PARENS
PUTHDR2  DS    0H
         PUT   (R5),HEADER2            PUT OUT PAGE 1 HEADER 2
         MVC   HEADER2(4),SPACE        CHANGE HEADER 2 FOR PUT OF BLANK
*                                      LINE
         PUT   (R5),HEADER2            PUT OUT BLANK LINE
         MVC   CNTLBYTE,HDRCNTL        MOVE IN SPACE AS CONTROL
*                                      CHARACTER
         TM    VOLBIT,LOW              SEE IF FOLD IS REQUESTED
         BO    FOLDIT                  YES....GO FOLD OUTPUT
         TM    DCBRECFM,DCBRECV        SEE IF RECFM IS VARIABLE
         BNO   COPYF                   NO.....GO HANDLE FIXED INPUT
         TM    DCBRECFM,DCBRECCC       SEE IF THERE IS A CONTROL BYTE
         BZ    COPYVNO                 NO.....GO TO ADD CONTROL FOR
*                                      VARIABLE
COPYV    DS    0H
         GET   INPUT,(R9)              GET INPUT RECORD
         PUT   (R5),LINE               PUT OUT OUTPUT LINE
         B     COPYV                   GO GET NEXT RECORD
*
COPYVNO  DS    0H
         GET   INPUT,(R9)              GET INPUT RECORD
         SLR   R15,R15                 ZERO REGISTER 15 FOR INSERT
         ICM   R15,7,LENGTH+1          INSERT LENGTH AND RESERVED BYTE
         A     R15,FULL256             ADD 1 TO LENGTH
         STCM  R15,7,LENGTH            STORE LENGTH AND RESERVED BYTE
         MVC   CNTLBYTE,HDRCNTL        MOVE IN CONTROL SAVED IN HEADER
         PUT   (R5),LINE               PUT OUT LINE
         B     COPYVNO                 GO GET NEXT INPUT RECORD
*
COPYF    DS    0H
         GET   INPUT,(R9)              GET INPUT RECORD
         PUT   (R5),LINE               PUT OUT OUTPUT LINE
         B     COPYF                   GO GET NEXT RECORD
*
FOLDIT   DS    0H
         TM    DCBRECFM,DCBRECV        SEE IF RECFM IS VARIABLE
         BNO   FOLDF                   NO.....GO HANDLE FIXED INPUT
         TM    DCBRECFM,DCBRECCC       SEE IF THERE IS A CONTROL BYTE
         BZ    FOLDVNO                 NO.....GO TO ADD CONTROL FOR
*                                      VARIABLE
FOLDV    DS    0H
         GET   INPUT,(R9)              GET INPUT RECORD
         LH    R15,LENGTH              LOAD LENGTH OF LINE
         SH    R15,HALF6               DECREMENT FOR EXECUTE
         EX    R15,FOLDLINE            EXECUTE FOLD OF LINE
         PUT   (R5),LINE               PUT OUT OUTPUT LINE
         B     FOLDV                   GO GET NEXT RECORD
*
FOLDVNO  DS    0H
         GET   INPUT,(R9)              GET INPUT RECORD
         SLR   R15,R15                 ZERO REGISTER 15 FOR INSERT
         ICM   R15,7,LENGTH+1          INSERT LENGTH AND RESERVED BYTE
         A     R15,FULL256             ADD 1 TO LENGTH
         STCM  R15,7,LENGTH            STORE LENGTH AND RESERVED BYTE
         MVC   CNTLBYTE,HDRCNTL        MOVE IN CONTROL SAVED IN HEADER
         LH    R15,LENGTH              LOAD LENGTH OF LINE
         SH    R15,HALF6               DECREMENT FOR EXECUTE
         EX    R15,FOLDLINE            EXECUTE FOLD OF LINE
         PUT   (R5),LINE               PUT OUT LINE
         B     FOLDVNO                 GO GET NEXT INPUT RECORD
*
FOLDF    DS    0H
         LH    R4,LENGTH               LOAD LENGTH INTO REGISTER 4
         SH    R4,HALF6                SUBTRACT TO SET UP FOR EXECUTE
FOLDFLP  DS    0H
         GET   INPUT,(R9)              GET INPUT RECORD
         EX    R4,FOLDLINE             FOLD DATA
         PUT   (R5),LINE               PUT OUT OUTPUT LINE
         B     FOLDFLP                 GO GET NEXT RECORD
FOLDLINE OC    DATA(0),BLANKS          OC INSTRUCTION TO BE EXECUTED
*
EXIT     DS    0H
         TM    DCBOFLGS,DCBOFOPN       SEE IF INPUT DCB IS OPEN
         BNO   EXITMSG                 NO....GO PUT OUT DATASET AND
*                                      MEMBER NAMES
         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT
*                                      INTO CLOSE LIST IN WORKAREA
         CLOSE ((R8),),MF=(E,CLOSLST)  CLOSE INPUT DCB
EXITMSG  DS    0H
         PUTLINE OUTPUT=(DSNMSG,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      DATA SET NAME MESSAGE
         LH    R4,4(R6)                LOAD LENGTH OF DSNAME
         A     R4,FULL4                INCREMENT LENGTH FOR PUTLINE
         SLL   R4,16                   SHIFT LENGTH TO HIGH ORDER BYTES
         STCM  R4,15,DSNLENP           STORE LENGTH OF PUTLINE
         PUTLINE OUTPUT=(DSNLENP,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      DATA SET NAME MESSAGE
         TM    14(R6),HIGH             SEE IF MEMBER NAME IS PRESENT
         BNO   CONTINUE                NO.....GO CHECK FOR ANOTHER
*                                      DATASET NAME
         PUTLINE OUTPUT=(MEMMSG,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      DATA SET NAME MESSAGE
         LH    R4,12(R6)               LOAD LENGTH OF MEMBER NAME
         A     R4,FULL4                INCREMENT LENGTH FOR PUTLINE
         SLL   R4,16                   SHIFT LENGTH TO HIGH ORDER BYTES
         STCM  R4,15,MEMNAMEL          STORE LENGTH OF PUTLINE
         PUTLINE OUTPUT=(MEMNAMEL,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      MEMBER NAME
         B     CONTINUE                GO CONTINUE WITH NEXT DATASET
         DROP  R8                      DROP ADDRESSABILITY TO INPUT DCB
ERRORL   DS    0H
         PUTLINE OUTPUT=(DSNISL,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      DATASET NOT PRINTED DUE TO
*                                      RECORD LENGTH TOO LONG MESSAGE
         B     EXIT                    GO SEE IF INPUT DCB IS OPEN
ERRORU   DS    0H
         PUTLINE OUTPUT=(DSNISU,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      DATASET NOT PRINTED DUE TO
*                                      UNDEFINED RECORD FORMAT MESSAGE
         B     EXIT                    GO SEE IF INPUT DCB IS OPEN
ERRI     DS    0H
         PUTLINE OUTPUT=(SYNADI,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      DATASET NOT PRINTED DUE TO SYNAD
*                                      ERROR ON INPUT DATASET MESSAGE
         B     EXIT                    GO SEE IF INPUT DCB IS OPEN
ERRO     DS    0H
         PUTLINE OUTPUT=(SYNADO,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      DATASET NOT PRINTED DUE TO
*                                      UNDEFINED RECORD FORMAT MESSAGE
         B     CLOSDCBS                GO CLOSE OPEN DCBS AND RETURN
.BYPASS4 ANOP
.BYPASS1 ANOP
*
***************************WORK AREAS *********************************
*
         SPACE 2
MBRTYPE  DC    C' '
STARTMBR DC    CL8' '
ENDMBR   DC    CL8' '
MBRNAME  DS    CL80
SMBRLTH  DC    H'0'
EMBRLTH  DC    H'0'
WILDSLTH DC    H'0'               NBR WILD CHARS IN 1ST NAME...
WILDELTH DC    H'0'               NBR WILD CHARS IN END NAME...
SAVEALL  DC    18F'0'
*
***************************** CONSTANTS *******************************
*
         SPACE 2
         PRINT NOGEN
SYSIN    DCB   DSORG=PS,MACRF=(GM),EODAD=EOFREAD,                      +
               DDNAME=SYSIN
SYSINL   EQU   *-SYSIN
*
*NPUTC   DCB   DSORG=PS,MACRF=(GM),EODAD=EXIT,SYNAD=ERRI,DDNAME=PDS
*NPUTL   EQU   *-INPUTC
INPUTC   DCB   DSORG=PO,MACRF=(W),DDNAME=PDS
INPUTL   EQU   *-INPUTC
*
*UTPUTAC DCB   DSORG=PS,MACRF=(PM),SYNAD=ERRO,DDNAME=SYSPRINT,
OUTPUTAC DCB   DSORG=PS,MACRF=(PM),DDNAME=SYSPRINT,                    X
               LRECL=256,BLKSIZE=3120,RECFM=VBA
OUTPUTAL EQU   *-OUTPUTAC
*
*UTPUTMC DCB   DSORG=PS,MACRF=(PM),SYNAD=ERRO,DDNAME=SYSPRINT,         X
               LRECL=256,BLKSIZE=3120,RECFM=VBM
*UTPUTML EQU   *-OUTPUTMC
*
DIRECTC  DCB   DDNAME=PDS,MACRF=(GM),RECFM=U,BLKSIZE=256,              X
               SYNAD=SERRI,EODAD=FREEBLK,DSORG=PS
DIRECTL  EQU   *-DIRECTC
         PRINT GEN
*
DELETED  DC    PL3'0'
ONE      DC    P'1'
OPENCLOS OPEN  (,),MF=L
         SPACE 2
HEADERC  DS    0F
         DC    H'48'
         DC    H'0'
HDRCNTLC DC    C' '
         DC    CL43'**** TSO FOREGROUND HARDCOPY ****'
HEADERM  DS    0F
         DC    H'62'              LTH OF DATA + 4
         DC    H'0'
         DC    C' '               DATA STARTS HERE
         DC    CL46'DIVERSIFIED DEVELOPMENTS DELETE MEMBER UTILITY'
         DC    CL11', VERSION 2'
HEADERML EQU   *-HEADERM
*        DC    CL43'*** TSO FOREGROUND MEMBER LIST **'
HEADER3  DS    0F
         DC    H'44'              LTH OF DATA + 4
         DC    H'0'
         DC    C' '               DATA STARTS HERE
         DC    C'THE FOLLOWING MEMBERS '
HEADER3W DC    C'HAVE BEEN'
         DC    C' DELETED'
HEADER3L EQU   *-HEADER3
HEADER4  DS    0F
         DC    H'32'              LTH OF DATA + 4
         DC    H'0'
         DC    C'0'               DATA STARTS HERE
DELCOUNT DC    X'402020202021'
         DC    C' MEMBERS '
NOTDEL   DC    C'WERE'
         DC    C' DELETED'
HEADER4L EQU   *-HEADER4
LDSNAME  DS    0CL12
         ORG   LDSNAME
         DC    H'66'
         DC    H'0'
         DC    CL8' DSNAME='
EJECTM   DS    0F
         DC    H'5'
         DC    H'0'
         DC    X'8B'
EJECTA   DS    0F
         DC    H'5'
         DC    H'0'
         DC    C'1'
SPACE    EQU   EJECTA
         SPACE 2
FULL0    DC    F'0'
FULL1    DC    F'1'
FULL4    DC    F'4'
FULL20   DC    F'20'
FULL28   DC    F'28'
FULL256  DC    F'256'
PRINTILN DC    H'12',H'0'
PRINTI   DC    CL8'PRINTI'
PRINTALN DC    H'12',H'0'
PRINTA   DC    CL8'PRINTA'
PRINTMLN DC    H'12',H'0'
PRINTM   DC    CL8'PRINTM'
BLANKS   DC    256CL1' '
ALIAS    DC    CL8' *ALIAS*'
ENDCHAIN DS    0F
         DC    X'FF000000'
MEMDATL  DC    X'00'                   SUBPOOL NUMBER
         DC    AL3(LINECNT*36+8)       CALC TABLE SPACE
LINECNT  EQU   50                      DEFAULT LINES PER PAGE FOR
*                                      MEMBER NAME LIST.  MODIFY
*                                      ABOVE STATEMENT TO CHANGE
*                                      NUMBER OF LINES PER PAGE
*                                      IN MEMBER NAME LIST.
HALF0    DC    H'0'
HALF1    DC    H'1'
HALF2    DC    H'2'
HALF6    DC    H'6'
HALF12   DC    H'12'
HALF85   DC    H'85'
HALF256  DC    H'256'
HEXFF    EQU   X'FF'
HIGH     EQU   X'80'
BLANK    EQU   X'40'
LOW      EQU   X'01'
JFCPDS   EQU   X'01'
HEX00    EQU   X'00'
SCLSA    EQU   C'A'
SKIPM    EQU   X'09'
DSOPS    EQU   X'40'
DSOPO    EQU   X'02'
NOWTP    EQU   X'00'
         SPACE 2
****************************** MESSAGES *******************************
OPENMSG  DC    AL2(OPENMSGL),AL2(0)
         DC    C'OUPUT PROCESSING IS BEING TERMINATED.  AN ERROR WAS ENX
               COUNTERED ATTEMPTING TO OPEN THE OUTPUT DATASET ASSOCIATX
               ED WITH DDNAME: '
OPENMSGL EQU   *-OPENMSG
*
DSNMSG   DC    AL2(DSNMSGL),AL2(0)
         DC    C'PROCESSING HAS BEEN COMPLETED FOR DATASET: '
DSNMSGL  EQU   *-DSNMSG
*
MEMMSG   DC    AL2(MEMMSGL),AL2(0)
         DC    C' MEMBER: '
MEMMSGL  EQU   *-MEMMSG
*
SYNADI   DC    AL2(SYNADIL),AL2(0)
         DC    C'A SYNAD ERROR OCURRED READING YOU INPUT DATASET AND ONX
               LY PART OF YOUR DATASET MAY HAVE BEEN PRINTED.'
SYNADIL  EQU   *-SYNADI
*
SYNADO   DC    AL2(SYNADOL),AL2(0)
         DC    C'A SYNAD ERROR OCURRED WRITING THE OUTPUT DATASET AND NX
               O MORE DATASETS WILL BE PRINTED.'
SYNADOL  EQU   *-SYNADO
*
DSNISU   DC    AL2(DSNISUL),AL2(0)
         DC    C'DATASET HAS UNDEFINED RECORD LENGTH AND WILL NOT BE PRX
               INTED.'
DSNISUL  EQU   *-DSNISU
*
DSNISL   DC    AL2(DSNISLL),AL2(0)
         DC    C'DATASET HAS RECORD LENGTH GREATER THAN 256.'
DSNISLL  EQU   *-DSNISL
         SPACE 2
************************ DSECTS (MAPPING MACROS) **********************
MEMDSECT DSECT
MEMNTTR  DS    CL11
         ORG   MEMNTTR
MEMBER   DS    CL8
MEMTTR   DS    CL3
CFIELD   DS    CL1
MEMSECTN EQU   *
         AGO   .BYPASS5
         IKJDAP08
DAP08LEN EQU   *-DAPB08
         IKJDAP18
DAP18LEN EQU   *-DAPB18
         IKJDAPL
DAPLLEN  EQU   *-DAPL
         IKJCPPL
CPPLLEN  EQU   *-CPPL
         IKJPPL
PPLLEN   EQU   *-PPL
         IKJIOPL
IOPLLEN  EQU   *-IOPL
         IHADSAB
TIOEDDNM EQU   4           X'1C'(OFFSET) - X'18'(JOB STEP)
         CVT
         IEFZB4D0
         IEFZB4D2
RBLEN    EQU   S99RBEND-S99RB
.BYPASS5 ANOP
         PRINT NOGEN
         DCBD  DSORG=(PS,PO)
         PRINT GEN
         EJECT
*********************** DSECT FOR DYNAMIC WORKAREA ********************
WORKAREA DSECT
SAVEAREA DS    18F
ALCSAVE  DS    12F
         DS    0D
DEC      DS    2F
RETNCD   DS    F
CONV     DS    2F
         AGO   .BYPASS6
IOPB     PUTLINE MF=L
DAP08    DS    0F
         ORG   DAP08+DAP08LEN
DAP18    DS    0F
         ORG   DAP18+DAP18LEN
DAPLSECT DS    0F
         ORG   DAPLSECT+DAPLLEN
PPLSECT  DS    0F
         ORG   PPLSECT+PPLLEN
IOPLSECT DS    0F
         ORG   IOPLSECT+IOPLLEN
ECB      DS    F
PARSBACK DS    F
.BYPASS6 ANOP
LINE     DS    0H
LENGTH   DS    H
         DS    H
CNTLBYTE DS    CL1
DATA     DS    CL256
HEADER2  DS    CL12
DSNAME   DS    CL44
OPENPRN  DS    CL1
MEMNAME  DS    CL8
CLOSEPRN DS    CL1
         ORG   DSNAME-4
DSNLENP  DS    CL2
DSNLEN   DS    CL2
DSNBUF   DS    CL44
         ORG   MEMNAME-4
MEMNAMEL DS    CL2
         ORG
*EADER   DS    CL62               SAME LTH AS HEADERM
HEADER   DS    CL(HEADERML)       SAME LTH AS HEADERM
         ORG   HEADER+4
HDRCNTL  DS    CL1
DFID     DS    CL2
         ORG
VOLBIT   DS    CL1
VOLUME   DS    CL8
MEMTABLE DS    F
ENDTABLE DS    F
CURRENT  DS    F
PRESENT  DS    F
COLUMN   DS    F
XLIST    DS    F
RDJL     RDJFCB (,),MF=L
JFCBAREA DS    44F
         ORG   JFCBAREA+44
JFCBELNM DS    CL8
         ORG   JFCBAREA+86
JFCBIND1 DS    CL1
         ORG   JFCBAREA+98
JFCDSRG1 DS    CL1
         ORG
SAVER6   DS    F
SAVER2   DS    2F
SAVER3   DS    2F
*
         PRINT NOGEN
*
INPUT    DCB   DSORG=PS,MACRF=(GM),DDNAME=PRINTI
*NPUT    DCB   DSORG=PS,MACRF=(GM),EODAD=EXIT,SYNAD=ERRI,DDNAME=PRINTI
*
OUTPUTA  DCB   DSORG=PS,MACRF=(PM),DDNAME=PRINTA,RECFM=VBA,            +
               LRECL=256,BLKSIZE=3120
*UTPUTA  DCB   DSORG=PS,MACRF=(PM),SYNAD=ERRO,DDNAME=PRINTA,RECFM=VBA, X
               LRECL=256,BLKSIZE=3120
*
*UTPUTM  DCB   DSORG=PS,MACRF=(PM),SYNAD=ERRO,DDNAME=PRINTM,RECFM=VBM, X
               LRECL=256,BLKSIZE=3120
*
DIRECT   DCB   DDNAME=PRINTI,DSORG=PS,MACRF=(GM),RECFM=U,BLKSIZE=256,  X
               SYNAD=SERRI,EODAD=FREEBLK
*
OPENLST  OPEN  (,),MF=L
*
CLOSLST  CLOSE (,),MF=L
*
         PRINT GEN
*
RETCODE  DS    F
GFPARMP  DS    F
LDYNAMIC EQU   *-WORKAREA
         END
/*
//LKED.SYSLMOD DD DSN=SYS9.IMSUTIL.LOAD,DISP=SHR
//LKED.SYSIN DD *
    SETCODE AC(0)
    NAME DELMEMS(R)
/*
//
