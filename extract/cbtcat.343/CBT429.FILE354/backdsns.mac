//BACKDSNS JOB
/*ROUTE PRINT R7
//*
//* JOB(BACKDSNS) - ASSEMBLE BACKDSNS AND HALLDUMP...
//*
//*
//*  DSN=CBT.SOURCE(BACKDSNS)
//*
//* JOB(BACKDSNS) - ASSEMBLE BACKDSNS AND HALLDUMP...
//*
//*  BEFORE RUNNING THIS JOB, CHANGE RH87944.SOURCE.CNTL AND
//*  HALL.LINKLIB TO YOUR DATASET NAMES.
//*
//*            NOTE...HALLDUMP IS  ASSEMBLED HERE TO MAKE SURE IT
//*            IS 24 BIT MODE, AS  BACKDSNS IS STILL 24 BIT MODE!
//*            ALSO, HDUMP MACRO  IS INCLUDED, AS IT IS A BIT
//*            DIFFERENT FROM THE 31-BIT VERSION.
//*
//S1     EXEC  HLASMC,PARMC='ESD',CLASS='*'    ,PARML='AC=1',
//*  COND.LKED=(7,LT,ASM)
//ASM.SYSLIB DD DSN=SYS1.MACLIB,DISP=SHR
//   DD DSN=SYS1.AMODGEN,DISP=SHR
//*  DD DSN=RH87944.SOURCE.CNTL,DISP=SHR
//ASM.SYSLIN   DD DSN=&&OBJECT(HALLDUMP),DISP=(,PASS),
//             UNIT=DISK,SPACE=(TRK,(1,1,5)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=8880)
//ASM.SYSIN DD *
*
*      COPYRIGHT
*  THE METHODS AND CODE IN THIS PROGRAM ARE COPYRIGHTED BY:
*  RANDY HALL,
*  1151 PALMER ROAD,
*  VICTORIA, B.C. CANADA, V8P-2H5
*  E-MAIL...BITRON@ISLANDNET.COM
*
*  YOU MUST LEAVE IT AS IS, AND CANNOT SELL IT TO ANYONE,
*  OR MODIFY IT, WITHOUT MY PERMISSION.
*
*                                                                   RH
*              MACRO TO DUMP CORE                                   RH
*                                                                   RH
*        COPY  HDUMP                                                RH
******************************************************************* RH
*                                                                   RH
*              MACRO TO DUMP CORE                                   RH
*              REMEMBER TO STEPLIB TO HALL.LINKLIB FOR HALLDUMP     RH
*              IF YOU USE AN EXISTING DCB, IT SHOULD BE             RH
*              RECFM=FBA,LRECL=133.                                 RH
*                                                                   RH
         MACRO                                                      RH
&L       HDUMP &DCB,&START,&STOP,&DISPO,&DISPC,&V=NO,&TITLE=,       RH +
               &GENDCB=YES                                          RH
         GBLA  &N                                                   RH
         GBLC  &L0,&L1,&L2,&L3,&L4,&L5,&L6                          RH
.*&N     SETA  1                                                    RH
.*                                                                  RH
.******* ***** ****************** ********************************* RH
.*                                                                  RH
.*       HDUMP IS USED TO DYNAMICALLY DUMP CORE IN A PROGRAM        RH
.*             &DCB   IS THE NAME FOR THE SYSOUT DCB                RH
.*             &START IS A REGISTER CONTAINING THE ADDRESS TO DUMP, RH
.*                    OR 0 TO DUMP JUST THE REGISTERS               RH
.*             &STOP  IS THE LENGTH TO DUMP, MAX IS 4095,           RH
.*                    OR 0 TO DUMP JUST THE REGISTERS               RH
.*             &DISPO IS THE DISPOSITION OF THE DUMP DCB            RH
.*             &DISPC IS THE DISPOSITION AT THE END OF THE MACRO    RH
.*             &V=YES WILL GENERATE A CONTROL BLOCK SET(EXCEPT DCB) RH
.*                    EVERY TIME THE MACRO IS CALLED                RH
.*             &TITLE IS A TITLE TO BE PRINTED BEFORE THE DUMP      RH
.*         &GENDCB=NO WILL USE THE EXISTING &DCB                    RH
.*                                                                  RH
.*       AN EXAMPLE USAGE WOULD BE:                                 RH
.*                                                                  RH
.*       1)    DUMP 1024 BYTES STARTING AT MESSAGES. (A DCB)        RH
.*             THE 'OUTDCB' FILE IS NOT OPEN, AND SHOULD BE LEFT    RH
.*             OPEN AT END OF THE MACRO.                            RH
.*                                                                  RH
.*       LA    R3,MESSAGES        R3 = ADDRESS TO DUMP       DEBUG  RH
.*       HDUMP OUTDCB,R3,1024,NOTOPEN,OPEN                   DEBUG  RH
.*       ...                                                        RH
.*       ...   MORE OF YOUR CODE                                    RH
.*       ...                                                        RH
.*                                                                  RH
.*       2)    DUMP 1024 BYTES STARTING AT THE ADDRESS STORED       RH
.*             AT MESSAGES+44. (A DEB)                              RH
.*             THE 'OUTDCB' FILE IS OPEN, AND SHOULD BE CLOSED      RH
.*             AT END OF THE MACRO.                                 RH
.*                                                                  RH
.*       L     R3,MESSAGES+44     R3 -> TO DEB               DEBUG  RH
.*       HDUMP OUTDCB,R3,1024,OPEN,CLOSE                     DEBUG  RH
.*                                                                  RH
.******* ***** ****************** ********************************* RH
.*                                                                  RH
         AIF   (&STOP LT 4096).STOPOK                               RH
         MNOTE 'STOP MUST BE LESS THAN 4096'                        RH
         MEXIT                                                      RH
.STOPOK  ANOP                                                       RH
.*       AIF   (&N EQ 1).FRST                                       RH
         AIF   (&N EQ 0).FRST                                       RH
         AIF   ('&V' EQ 'NO').NDC1                                  RH
.FRST    ANOP                                                       RH
&L0      SETC  'SREG&SYSNDX'                                        RH
&L1      SETC  'HREG&SYSNDX'                                        RH
&L2      SETC  'REGA&SYSNDX'                                        RH
&L3      SETC  'DCBA&SYSNDX'                                        RH
&L4      SETC  'STRT&SYSNDX'                                        RH
&L5      SETC  'STPA&SYSNDX'                                        RH
&L6      SETC  'TITL&SYSNDX'                                        RH
         AIF   (&N GT 1).LBL2                                       RH
*&L      B     BPAS&SYSNDX                                   DEBUG  RH
&L       B     LOADHDMP                                      DEBUG  RH
         AGO   .LBL9                                         DEBUG  RH
.LBL2    ANOP                                                DEBUG  RH
&L       B     HDMP&SYSNDX                                   DEBUG  RH
.LBL9    ANOP                                                DEBUG  RH
         SPACE 1                                             DEBUG  RH
&L0      DC    18F'-1'            SAVE AREA FOR HALLDUMP RTN DEBUG  RH
&L1      DC    16F'-1'            SAVE AREA FOR CALLERS REGS DEBUG  RH
&L2      DC    A(&L1)             ADDRESS OF CALLERS REGS    DEBUG  RH
&L3      DC    A(&DCB)            ADDRESS OF OUTPUT DCB      DEBUG  RH
&L4      DC    A(0)               ADDRESS OF START OF DUMP   DEBUG  RH
&L5      DC    A(0)               ADDRESS OF END OF DUMP     DEBUG  RH
&L6      DC    A(0)               ADDRESS OF TITLE           DEBUG  RH
         AIF   (&N GT 1).NDC1                                DEBUG  RH
         ENTRY DMPRADDR                                      DEBUG  RH
DMPRADDR DC    F'0'               DUMP FORMATTER ADDRESS     DEBUG  RH
         AIF   ('&GENDCB' EQ 'NO').NODCB                            RH
         ENTRY &DCB                                          DEBUG  RH
*&DCB    DCB   DDNAME=SYSOUT,RECFM=FBA,LRECL=133,BLKSIZE=3990,      RHXX
               DSORG=PS,MACRF=(PM)                           DEBUG  RH
&DCB     DCB   DDNAME=&DCB,RECFM=FBA,LRECL=133,BLKSIZE=3990,        RHXX
               DSORG=PS,MACRF=(PM)                           DEBUG  RH
.NODCB   ANOP                                                DEBUG  RH
         SPACE 1                                             DEBUG  RH
*PAS&SYSNDX DS    0H                                         DEBUG  RH
LOADHDMP DS       0H                                         DEBUG  RH
         STM   0,15,&L1           SAVE CALLERS REGS          DEBUG  RH
*        L     1,=V(DMPRADDR)     R1 -> TO DUMPER CODE       DEBUG  RH
*        ICM   1,15,0(1)          IS DUMP FORMATTER LOADED?  DEBUG  RH
         ICM   1,15,=V(HALLDUMP)  IS DUMP FORMATTER LOADED?  DEBUG  RH
         BNZ   LOADHEND           YES                        DEBUG  RH
         DC    H'0'               NO, ABEND                  DEBUG  RH
         SPACE 1                                             DEBUG  RH
LOADHEND DS    0H                                            DEBUG  RH
         LM    0,15,&L1           RELOAD CALLERS REGS        DEBUG  RH
.NDC1    ANOP                                                DEBUG  RH
         SPACE 1                                             DEBUG  RH
*PAS&SYSNDX DS    0H                                         DEBUG  RH
HDMP&SYSNDX DS    0H                                         DEBUG  RH
         STM   0,15,&L1           SAVE CALLERS REGS          DEBUG  RH
*        LR    15,&START          R15 -> TO START ADDRESS    DEBUG  RH
         AIF   ('&START'(1,1) LT '0').STARTR1                       RH
         LA    15,0               R15 = 0 IF DUMP ONLY REGS  DEBUG  RH
         AGO   .STARTR9
.STARTR1 ANOP                                                DEBUG  RH
         LR    15,&START          R15 -> TO START ADDRESS    DEBUG  RH
.STARTR9 ANOP                                                DEBUG  RH
         ST    15,&L4             SAVE IT                    DEBUG  RH
         LA    15,&STOP.(0,15)    R15 -> TO STOP ADDRESS     DEBUG  RH
         ST    15,&L5             SAVE IT                    DEBUG  RH
         AIF   ('&TITLE' EQ '').NTTL                         DEBUG  RH
         LA    15,=CL80&TITLE     R15 -> TO TITLE            DEBUG  RH
         ST    15,&L6             SAVE IT                    DEBUG  RH
.NTTL    ANOP                                                DEBUG  RH
         LA    13,&L0             GIVE HALLDUMP ITS OWN SA   DEBUG  RH
         AIF   (&N GT 1).NDC2                                DEBUG  RH
&N       SETA  2                                             DEBUG  RH
         L     2,=V(&DCB)         R2 -> TO OUTPUT DCB        DEBUG  RH
         ST    2,&L3              SAVE IT                    DEBUG  RH
         AGO   .NDC3                                                RH
.NDC2    ANOP                                                DEBUG  RH
         SPACE 1                                             DEBUG  RH
         L     2,=V(&DCB)         R2 -> TO OUTPUT DCB        DEBUG  RH
         ST    2,&L3              SAVE IT                    DEBUG  RH
         AIF   ('&DISPO' EQ '').NDC3                                RH
         AIF   ('&DISPO' EQ 'OPEN').NDC4                            RH
.NDC3    ANOP                                                       RH
         TM    48(2),X'10'        IS DEBUG FILE OPEN ?       DEBUG  RH
         BO    OPEN&SYSNDX        YES, DON'T OPEN IT AGAIN   DEBUG  RH
*        OPEN  ((2),(OUTPUT)),MODE=24                        DEBUG  RH
         OPEN  ((2),(OUTPUT)),MODE=24                        DEBUG  RH
         SPACE 1                                             DEBUG  RH
OPEN&SYSNDX DS 0H                                            DEBUG  RH
*        L     R15,=V(DMPRADDR)   R15 -> TO DUMPER CODE      DEBUG  RH
*        ICM   1,15,0(R15)        IS DUMP FORMATTER LOADED?  DEBUG  RH
         ICM   1,15,=V(HALLDUMP)  IS DUMP FORMATTER LOADED?  DEBUG  RH
         BNZ   LOAD&SYSNDX        YES                        DEBUG  RH
         DC    H'0'               NO, ABEND                  DEBUG  RH
         SPACE 1                                             DEBUG  RH
LOAD&SYSNDX DS 0H                                            DEBUG  RH
.NDC4    ANOP                                                       RH
         TM    48(2),X'10'        IS DEBUG FILE OPEN ?       DEBUG  RH
         BZ    DBUG&SYSNDX        NO                         DEBUG  RH
         LA    1,&L2              R1 -> TO PARM LIST         DEBUG  RH
*        ICM   15,15,=V(HALLDUMP) R15 -> TO DUMP ROUTINE     DEBUG  RH
*        L     R15,=V(DMPRADDR)   R15 -> TO DUMPER CODE      DEBUG  RH
*        ICM   15,15,0(R15)       R15 -> TO DUMP ROUTINE     DEBUG  RH
         ICM   15,15,=V(HALLDUMP) IS DUMP FORMATTER LOADED?  DEBUG  RH
         BZ    DBUG&SYSNDX        NO, DUMP ROUTINE, EXIT     DEBUG  RH
         BALR  14,15              GO TO IT                   DEBUG  RH
         AIF   ('&DISPC' EQ '').NDC5                                RH
         AIF   ('&DISPC' EQ 'OPEN').NDC6                            RH
.NDC5    ANOP                                                       RH
*        CLOSE ((2)),MODE=24      CLOSE THE O/P FILE         DEBUG  RH
         CLOSE ((2)),MODE=24      CLOSE THE O/P FILE         DEBUG  RH
.NDC6    ANOP                                                       RH
         SPACE 1                                             DEBUG  RH
DBUG&SYSNDX DS    0H                                         DEBUG  RH
         LM    0,15,&L1           RELOAD CALLERS REGS        DEBUG  RH
         MEND                                                       RH
*                                                                   RH
*              END OF MACRO                                  DEBUG  RH
*                                                                   RH
*                                                                   RH
*                                                                   RH
*              EXAMPLE OF JCL TO  USE HDUMP                         RH
*                                                                   RH
*        JCL MUST STEPLIB TO HALL.LINKLIB                           RH
*                                                                   RH
*                  THIS IS CODE TO DUMP CORE                 DEBUG  RH
*        SPACE 4                                             DEBUG  RH
*                                 DUMP 1024 BYTES AT R12     DEBUG  RH
*        HDUMP OUTDCB,R12,1024,NOTOPEN,OPEN                  DEBUG  RH
*        L     R3,DSSEJFCB        R3 -> TO JFCB              DEBUG  RH
*                                 DUMP 1024 BYTES AT JFCB    DEBUG  RH
*        HDUMP OUTDCB,R3,1024,OPEN,CLOSE                     DEBUG  RH
*        HDUMP OUTDCB,0,0,TITLE='DUMP REGS ONLY'             DEBUG  RH
*        SPACE 1                                             DEBUG  RH
*                  THIS IS END OF CODE TO DUMP CORE          DEBUG  RH
*                                                                   RH
*
* DUMP THE REGS AND SPECIFIED MEMORY LOCATIONS
*
* ON ENTRY:
*    R1 = ADDR PASSED PARMS
*       1) ADDR OF SAVED CALLERS REGS
*       2) ADDR OF SYSPRINT DCB
*       3) ADDR OF FIRST BYTE TO DUMP
*       4) ADDR OF LAST BYTE (PLUS ONE) TO DUMP
*       5) ADDR OF A TITLE, OR 0
*                                                                   RH
         EJECT                                                      RH
HALLDUMP CSECT
HALLDUMP AMODE 24
HALLDUMP RMODE 24
         SPACE 2
*
* PERFORM STANDARD LINKAGE
*
         BSM   R14,0              SAVE CURRENT AMODE
         PRINT NOGEN
         STM   R14,R12,12(R13)         SAVE HIS REGS
         USING HALLDUMP,R15            TEMP BASE ADDR
         B     CONTINUE                BR AROUND MODULE NAME & DATE
         DC    AL1(EYELTH)        LTH OF EYE CATCHER
EYECATCH DC    CL8'HALLDUMP'           MODULE NAME
         DC    CL8'&SYSDATE'           DATE ASSEMBLED
         DC    CL8'&SYSTIME'           TIME ASSEMBLED
         DC    C' VERSION 4...MAKE 24-BIT MODE FOR BACKDSNS'
*        DC    C' VERSION 3...ADDED TITLE OPTION'
EYELTH   EQU   *-EYECATCH
         DROP  R15                     RELEASE TEMP BASE REG
         SPACE 1
CONTINUE DS    0H
         LR    R12,R15                 BASE REG
         USING HALLDUMP,R12            EST. ADDR.
         CNOP  0,4                     ALIGNMENT
         BAL   R11,*+76                BR AROUND SAVE AREA
SAVEAREA DS    18F                     SAVE AREA
         ST    R13,4(0,R11)            HIS 4 PAST MINE
         ST    R11,8(0,R13)            MINE 8 PAST HIS
         LR    R13,R11                 ADDR MY SAVE AREA
*
* LOAD UP SOME  REGISTERS..
*
*                                 R1 -> TO PARMS                    RH
         L     R5,0(0,R1)         R5 -> TO REG SAVE AREA
         MVC   DUMPREGS(64),0(R5)  MOVE REGS TO WORK AREA
         L     R2,4(0,R1)         R2 -> TO OUTPUT PRINT DCB
         LM    R3,R5,8(R1)        R3 -> TO START ADDR TO DUMP
*                                 R4 -> TO STOP ADDR TO DUMP
*                                 R5 -> TO TITLE, IF ANY
*
* DUMP OUT THE TITLE IF THERE IS ONE...
*
         LTR   R5,R5              IS THERE A TITLE?
         BZ    NOTITLE            NO
         MVC   DUMPLINE+1(80),0(R5)  MOVE HEADING TO PRINT LINE
         PUT   (R2),DUMPLINE      PRINT THE TITLE
*
* DUMP OUT THE VALUES OF THE REGISTERS
*
NOTITLE  DS    0H
         MVC   DUMPRGLO(64),DUMPREGS COPY THE REGS
         TR    DUMPREGS(64),DUMPTBHI  CONVERT HI ORDER DIGITS
         TR    DUMPRGLO(64),DUMPTBLO   CONVERT LO ORDER DIGITS
         MVC   DUMPLINE+1(10),DUMPREG0  LINE HEADING
         MVC   DUMPLINE+11(72),DUMPSELR DIGITS TO SELECT
         TR    DUMPLINE+11(72),DUMPREGS REG CONTENTS => O/P LINE
         PUT   (R2),DUMPLINE           WRITE THE O/P LINE
         MVC   DUMPLINE+1(10),DUMPREG8  LINE HEADING
         MVC   DUMPLINE+11(72),DUMPSELR DIGITS TO SELECT
         TR    DUMPLINE+11(72),DUMPREGS+32 REG CONTENTS => O/P LINE
         PUT   (R2),DUMPLINE           WRITE THE O/P LINE
         MVI   DUMPLINE,C'0'      DOUBLE SPACE NEXT LINE
*
* DUMP THE DATA FROM THE SPECIFIED STORAGE AREA
*
         MVI   DUMPLINE+85,X'5C'       DELIMETER OF CHARS
         MVI   DUMPLINE+118,X'5C'      DELIMETER OF CHARS
         LTR   R5,R3                   STARTING ADDR
         BZ    DUMPEND            IF START = 0, END OF DUMP
         SRL   R3,5                    ROUND ADDR TO ...
         SLL   R3,5                    ... A MULTIPLE OF 32
* COMPUTE NUMBER BYTES TO BLANK OUT
         SR    R5,R3                   # BYTES TO BLANK
         LR    R7,R5              # BYTES TO BLANK ON RIGHT SIDE...
         SLL   R5,1                    DOUBLE THE NUMBER
         LR    R6,R5                   SAVE THIS VALUE
         SRL   R6,3                    # ADD'NL BLANKS
         AR    R5,R6                   SUBTOTAL # BLANK BYTES
         SRL   R6,2                    # ADD'NL DOUBLE BLANKS
         AR    R5,R6                   TOTAL # BLANKS
DUMPRINT EQU   *
         MVC   DUMPDATA(32),0(R3)      GET DATA TO TRANSLATE
         MVC   DUMPDALO(32),0(R3)      GET DATA TO TRNASLATE
         TR    DUMPDATA(32),DUMPTBHI   CONVERT HO ORDER HEX
         TR    DUMPDALO(32),DUMPTBLO   CONVERT LO ORDER HEX
         ST    R3,DUMPADHI             SAVE STARTING ADDR
         ST    R3,DUMPADLO             SAVE STARTING ADDR
         TR    DUMPADHI(4),DUMPTBHI    CONVERT HI OEDER HEX
         TR    DUMPADLO(4),DUMPTBLO    CONVERT LO ORDER HEX
         MVC   DUMPLINE+1(8),DUMPSELA  HEX DIGIT SELECT PATTERN
         TR    DUMPLINE+1(8),DUMPADHI  SELECT THE HEX DIGITS
         MVC   DUMPLINE+11(72),DUMPSELD DIGITS TO SELECT
         TR    DUMPLINE+11(72),DUMPDATA DATA => O/P LINE
         MVC   DUMPLINE+86(32),0(R3)   DATA BEING DUMPED
         LTR   R5,R5                   ANY BLANKS ?
         BZ    DUMPNXT1                NO, SKIP IT
         BCTR  R5,0                    REAL LEN FOR MOVE
         EX    R5,DUMPMVC              MOVE IN THE BLANKS
*        SRL   R5,2               NBR OF BLANKS ON RIGHT SIDE....
         BCTR  R7,0                    REAL LEN FOR MOVE
         EX    R7,DUMPMVC2             MOVE IN THE BLANKS
         SLR   R5,R5                   NO BLANKS !
DUMPNXT1 EQU   *
         PUT   (R2),DUMPLINE           WRITE THE O/P LINE
DUMPEND  DS    0H
         MVI   DUMPLINE,C' '           SINGLE SPACE
         LA    R3,32(0,R3)             PT @ NEXT DATUM
         CR    R3,R4                   DATA EXHAUSTED ?
         BL    DUMPRINT                NO, CONTINUE PROCESSING IT
*
* PRINT END OF DUMP SEPARATOR
*
         MVI   DUMPLINE,X'F0'          DOUBLE SPACE
         MVI   DUMPLINE+1,X'5C'        SET THE O/P LINE ...
         MVC   DUMPLINE+2(131),DUMPLINE+1  ... TO ASTERISKS
         PUT   (R2),DUMPLINE           WRITE THE O/P LINE
         MVI   DUMPLINE,X'40'          SINGLE SPACE
         MVC   DUMPLINE+1(132),DUMPLINE  CLR O/P LINE TO BLANKS
         PUT   (R2),DUMPLINE           WRITE THE O/P LINE
*
* GET BACK TO THE CALLING ROUTINE
*
         L     R13,4(0,R13)            ADDR HIS SAVE AREA
         LM    R14,R12,12(R13)         RESTORE HIS REGS
*              GET INTO PROPER MODE AND GO BACK TO CALLER
         BSM   0,R14              RETURN TO CALLING PROGRAM
*        BR    R14                     RETURN TO HIM
*
* DEFINE STORAGE
*
DUMPMVC  MVC   DUMPLINE+11(1),DUMPBLNK
DUMPMVC2 MVC   DUMPLINE+86(1),DUMPBLNK
DUMPREGS DS    16F
DUMPRGLO DS    16F
DUMPBLNK DC    CL80' '
DUMPREG0 DC    CL10'  R0-R7   '
DUMPREG8 DC    CL10'  R8-R15  '
DUMPDATA DS    8F
DUMPDALO DS    8F
DUMPBLK2 DC    CL8' '
DUMPADHI DS    F
DUMPADLO DS    F
DUMPTBHI DC    16X'F0'
         DC    16X'F1'
         DC    16X'F2'
         DC    16X'F3'
         DC    16X'F4'
         DC    16X'F5'
         DC    16X'F6'
         DC    16X'F7'
         DC    16X'F8'
         DC    16X'F9'
         DC    16X'C1'
         DC    16X'C2'
         DC    16X'C3'
         DC    16X'C4'
         DC    16X'C5'
         DC    16X'C6'
DUMPTBLO DC    16X'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
DUMPSELR DC    X'00400141024203438004440545064607'
         DC    X'4780084809490A4A0B4B800C4C0D4D0E'
         DC    X'4E0F4F80801050115112521353801454'
         DC    X'15551656175780185819591A5A1B5B80'
         DC    X'1C5C1D5D1E5E1F5F'
DUMPSELD DC    X'00200121022203234004240525062607'
         DC    X'2740082809290A2A0B2B400C2C0D2D0E'
         DC    X'2E0F2F40401030113112321333401434'
         DC    X'15351636173740183819391A3A1B3B40'
         DC    X'1C3C1D3D1E3E1F3F'
DUMPSELA DC    X'0004010502060307'
DUMPLINE DC    C' '
         DC    CL132' '
*
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         END
/*
//*
//STEP1  EXEC HLASMCL,CLASS='*',MAC1='SYS1.AMODGEN',
//            PARMC='SYSPARM(1,ESD)'
//*           PARMC='SYSPARM=1,ESD'
//ASM.SYSLIB  DD DSN=SYS1.MACLIB
//  DD DSN=SYS1.MODGEN,DISP=SHR
//  DD DSN=SYS1.AMODGEN,DISP=SHR
//* DD DSN=RH87944.SOURCE.CNTL,DISP=SHR
//ASM.SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,(5,5))
//ASM.SYSIN DD *
*
*      COPYRIGHT
*  THE METHODS AND CODE IN THIS PROGRAM ARE COPYRIGHTED BY:
*  RANDY HALL,
*  1151 PALMER ROAD,
*  VICTORIA, B.C. CANADA, V8P-2H5
*  E-MAIL...BITRON@ISLANDNET.COM
*
*  YOU MUST LEAVE IT AS IS, AND CANNOT SELL IT TO ANYONE, OR MODIFY IT,
*  WITHOUT MY  PERMISSION.
*
         MACRO
&LABEL   REQUATE &SAVE=NO,&REGS=YES,&E=YES
         AIF   ('&REGS'(1,1) NE 'Y').SAVETS
***********************************************************************
*                                                                     *
*                 REGISTER EQUATES                                    *
*                                                                     *
***********************************************************************
         SPACE 3
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         AIF   ('&E'(1,1) EQ 'N').SAVETS
         EJECT
.SAVETS  AIF   ('&SAVE'(1,1) EQ 'Y').SAVEOK
         MEXIT
.SAVEOK  ANOP
***********************************************************************
*                                                                     *
*                  SAVE AREA DESCRIPTOR SECTION                       *
*                                                                     *
***********************************************************************
         SPACE 3
SAVEAREA DSECT ,
SAVEWRD1 DS    F .            PL1 WORD
SAVELAST DS    F .            CHAIN POINTER TO LAST SAVE AREA
SAVENEXT DS    F .            CHAIN POINTER TO NEXT SAVE AREA
SAVEREGS DS    0CL60 .        WORKING REGISTER STORAGE AREA
SAVER14  DS    F .            R14 SLOT
SAVER15  DS    F .            R15 SLOT
SAVER0   DS    F .            R0 SLOT
SAVER1   DS    F .            R1 SLOT
SAVER2   DS    F .            R2 SLOT
SAVER3   DS    F .            R3 SLOT
SAVER4   DS    F .            R4 SLOT
SAVER5   DS    F .            R5 SLOT
SAVER6   DS    F .            R6 SLOT
SAVER7   DS    F .            R7 SLOT
SAVER8   DS    F .            R8 SLOT
SAVER9   DS    F .            R9 SLOT
SAVER10  DS    F .            R10 SLOT
SAVER11  DS    F .            R11 SLOT
SAVER12  DS    F .            R12  SLOT
SAVESIZE EQU   *-SAVEAREA
        AIF   ('&E'(1,1) EQ 'N').ENDMAC
         EJECT
.ENDMAC  ANOP
         MEND
*                                                                   RH
*        COPY  HDUMP                                                RH
******************************************************************* RH
*                                                                   RH
*              MACRO TO DUMP CORE                                   RH
*              REMEMBER TO STEPLIB TO HALL.LINKLIB FOR HALLDUMP     RH
*              IF YOU USE AN EXISTING DCB, IT SHOULD BE             RH
*              RECFM=FBA,LRECL=133.                                 RH
*                                                                   RH
         MACRO                                                      RH
&L       HDUMP &DCB,&START,&STOP,&DISPO,&DISPC,&V=NO,&TITLE=,       RH +
               &GENDCB=YES                                          RH
         GBLA  &N                                                   RH
         GBLC  &L0,&L1,&L2,&L3,&L4,&L5,&L6                          RH
.*&N     SETA  1                                                    RH
.*                                                                  RH
.******* ***** ****************** ********************************* RH
.*                                                                  RH
.*       HDUMP IS USED TO DYNAMICALLY DUMP CORE IN A PROGRAM        RH
.*             &DCB   IS THE NAME FOR THE SYSOUT DCB                RH
.*             &START IS A REGISTER CONTAINING THE ADDRESS TO DUMP, RH
.*                    OR 0 TO DUMP JUST THE REGISTERS               RH
.*             &STOP  IS THE LENGTH TO DUMP, MAX IS 4095,           RH
.*                    OR 0 TO DUMP JUST THE REGISTERS               RH
.*             &DISPO IS THE DISPOSITION OF THE DUMP DCB            RH
.*             &DISPC IS THE DISPOSITION AT THE END OF THE MACRO    RH
.*             &V=YES WILL GENERATE A CONTROL BLOCK SET(EXCEPT DCB) RH
.*                    EVERY TIME THE MACRO IS CALLED                RH
.*             &TITLE IS A TITLE TO BE PRINTED BEFORE THE DUMP      RH
.*         &GENDCB=NO WILL USE THE EXISTING &DCB                    RH
.*                                                                  RH
.*       AN EXAMPLE USAGE WOULD BE:                                 RH
.*                                                                  RH
.*       1)    DUMP 1024 BYTES STARTING AT MESSAGES. (A DCB)        RH
.*             THE 'OUTDCB' FILE IS NOT OPEN, AND SHOULD BE LEFT    RH
.*             OPEN AT END OF THE MACRO.                            RH
.*                                                                  RH
.*       LA    R3,MESSAGES        R3 = ADDRESS TO DUMP       DEBUG  RH
.*       HDUMP OUTDCB,R3,1024,NOTOPEN,OPEN                   DEBUG  RH
.*       ...                                                        RH
.*       ...   MORE OF YOUR CODE                                    RH
.*       ...                                                        RH
.*                                                                  RH
.*       2)    DUMP 1024 BYTES STARTING AT THE ADDRESS STORED       RH
.*             AT MESSAGES+44. (A DEB)                              RH
.*             THE 'OUTDCB' FILE IS OPEN, AND SHOULD BE CLOSED      RH
.*             AT END OF THE MACRO.                                 RH
.*                                                                  RH
.*       L     R3,MESSAGES+44     R3 -> TO DEB               DEBUG  RH
.*       HDUMP OUTDCB,R3,1024,OPEN,CLOSE                     DEBUG  RH
.*                                                                  RH
.******* ***** ****************** ********************************* RH
.*                                                                  RH
         AIF   (&STOP LT 4096).STOPOK                               RH
         MNOTE 'STOP MUST BE LESS THAN 4096'                        RH
         MEXIT                                                      RH
.STOPOK  ANOP                                                       RH
.*       AIF   (&N EQ 1).FRST                                       RH
         AIF   (&N EQ 0).FRST                                       RH
         AIF   ('&V' EQ 'NO').NDC1                                  RH
.FRST    ANOP                                                       RH
&L0      SETC  'SREG&SYSNDX'                                        RH
&L1      SETC  'HREG&SYSNDX'                                        RH
&L2      SETC  'REGA&SYSNDX'                                        RH
&L3      SETC  'DCBA&SYSNDX'                                        RH
&L4      SETC  'STRT&SYSNDX'                                        RH
&L5      SETC  'STPA&SYSNDX'                                        RH
&L6      SETC  'TITL&SYSNDX'                                        RH
         AIF   (&N GT 1).LBL2                                       RH
*&L      B     BPAS&SYSNDX                                   DEBUG  RH
&L       B     LOADHDMP                                      DEBUG  RH
         AGO   .LBL9                                         DEBUG  RH
.LBL2    ANOP                                                DEBUG  RH
&L       B     HDMP&SYSNDX                                   DEBUG  RH
.LBL9    ANOP                                                DEBUG  RH
         SPACE 1                                             DEBUG  RH
&L0      DC    18F'-1'            SAVE AREA FOR HALLDUMP RTN DEBUG  RH
&L1      DC    16F'-1'            SAVE AREA FOR CALLERS REGS DEBUG  RH
&L2      DC    A(&L1)             ADDRESS OF CALLERS REGS    DEBUG  RH
&L3      DC    A(&DCB)            ADDRESS OF OUTPUT DCB      DEBUG  RH
&L4      DC    A(0)               ADDRESS OF START OF DUMP   DEBUG  RH
&L5      DC    A(0)               ADDRESS OF END OF DUMP     DEBUG  RH
&L6      DC    A(0)               ADDRESS OF TITLE           DEBUG  RH
         AIF   (&N GT 1).NDC1                                DEBUG  RH
         ENTRY DMPRADDR                                      DEBUG  RH
DMPRADDR DC    F'0'               DUMP FORMATTER ADDRESS     DEBUG  RH
         AIF   ('&GENDCB' EQ 'NO').NODCB                            RH
         ENTRY &DCB                                          DEBUG  RH
*&DCB    DCB   DDNAME=SYSOUT,RECFM=FBA,LRECL=133,BLKSIZE=3990,      RHXX
               DSORG=PS,MACRF=(PM)                           DEBUG  RH
&DCB     DCB   DDNAME=&DCB,RECFM=FBA,LRECL=133,BLKSIZE=3990,        RHXX
               DSORG=PS,MACRF=(PM)                           DEBUG  RH
.NODCB   ANOP                                                DEBUG  RH
         SPACE 1                                             DEBUG  RH
*PAS&SYSNDX DS    0H                                         DEBUG  RH
LOADHDMP DS       0H                                         DEBUG  RH
         STM   0,15,&L1           SAVE CALLERS REGS          DEBUG  RH
*        L     1,=V(DMPRADDR)     R1 -> TO DUMPER CODE       DEBUG  RH
*        ICM   1,15,0(1)          IS DUMP FORMATTER LOADED?  DEBUG  RH
         ICM   1,15,=V(HALLDUMP)  IS DUMP FORMATTER LOADED?  DEBUG  RH
         BNZ   LOADHEND           YES                        DEBUG  RH
         DC    H'0'               NO, ABEND                  DEBUG  RH
         SPACE 1                                             DEBUG  RH
LOADHEND DS    0H                                            DEBUG  RH
         LM    0,15,&L1           RELOAD CALLERS REGS        DEBUG  RH
.NDC1    ANOP                                                DEBUG  RH
         SPACE 1                                             DEBUG  RH
*PAS&SYSNDX DS    0H                                         DEBUG  RH
HDMP&SYSNDX DS    0H                                         DEBUG  RH
         STM   0,15,&L1           SAVE CALLERS REGS          DEBUG  RH
*        LR    15,&START          R15 -> TO START ADDRESS    DEBUG  RH
         AIF   ('&START'(1,1) LT '0').STARTR1                       RH
         LA    15,0               R15 = 0 IF DUMP ONLY REGS  DEBUG  RH
         AGO   .STARTR9
.STARTR1 ANOP                                                DEBUG  RH
         LR    15,&START          R15 -> TO START ADDRESS    DEBUG  RH
.STARTR9 ANOP                                                DEBUG  RH
         ST    15,&L4             SAVE IT                    DEBUG  RH
         LA    15,&STOP.(0,15)    R15 -> TO STOP ADDRESS     DEBUG  RH
         ST    15,&L5             SAVE IT                    DEBUG  RH
         AIF   ('&TITLE' EQ '').NTTL                         DEBUG  RH
         LA    15,=CL80&TITLE     R15 -> TO TITLE            DEBUG  RH
         ST    15,&L6             SAVE IT                    DEBUG  RH
.NTTL    ANOP                                                DEBUG  RH
         LA    13,&L0             GIVE HALLDUMP ITS OWN SA   DEBUG  RH
         AIF   (&N GT 1).NDC2                                DEBUG  RH
&N       SETA  2                                             DEBUG  RH
         L     2,=V(&DCB)         R2 -> TO OUTPUT DCB        DEBUG  RH
         ST    2,&L3              SAVE IT                    DEBUG  RH
         AGO   .NDC3                                                RH
.NDC2    ANOP                                                DEBUG  RH
         SPACE 1                                             DEBUG  RH
         L     2,=V(&DCB)         R2 -> TO OUTPUT DCB        DEBUG  RH
         ST    2,&L3              SAVE IT                    DEBUG  RH
         AIF   ('&DISPO' EQ '').NDC3                                RH
         AIF   ('&DISPO' EQ 'OPEN').NDC4                            RH
.NDC3    ANOP                                                       RH
         TM    48(2),X'10'        IS DEBUG FILE OPEN ?       DEBUG  RH
         BO    OPEN&SYSNDX        YES, DON'T OPEN IT AGAIN   DEBUG  RH
*        OPEN  ((2),(OUTPUT)),MODE=24                        DEBUG  RH
         OPEN  ((2),(OUTPUT)),MODE=24                        DEBUG  RH
         SPACE 1                                             DEBUG  RH
OPEN&SYSNDX DS 0H                                            DEBUG  RH
*        L     R15,=V(DMPRADDR)   R15 -> TO DUMPER CODE      DEBUG  RH
*        ICM   1,15,0(R15)        IS DUMP FORMATTER LOADED?  DEBUG  RH
         ICM   1,15,=V(HALLDUMP)  IS DUMP FORMATTER LOADED?  DEBUG  RH
         BNZ   LOAD&SYSNDX        YES                        DEBUG  RH
         DC    H'0'               NO, ABEND                  DEBUG  RH
         SPACE 1                                             DEBUG  RH
LOAD&SYSNDX DS 0H                                            DEBUG  RH
.NDC4    ANOP                                                       RH
         TM    48(2),X'10'        IS DEBUG FILE OPEN ?       DEBUG  RH
         BZ    DBUG&SYSNDX        NO                         DEBUG  RH
         LA    1,&L2              R1 -> TO PARM LIST         DEBUG  RH
*        ICM   15,15,=V(HALLDUMP) R15 -> TO DUMP ROUTINE     DEBUG  RH
*        L     R15,=V(DMPRADDR)   R15 -> TO DUMPER CODE      DEBUG  RH
*        ICM   15,15,0(R15)       R15 -> TO DUMP ROUTINE     DEBUG  RH
         ICM   15,15,=V(HALLDUMP) IS DUMP FORMATTER LOADED?  DEBUG  RH
         BZ    DBUG&SYSNDX        NO, DUMP ROUTINE, EXIT     DEBUG  RH
         BALR  14,15              GO TO IT                   DEBUG  RH
         AIF   ('&DISPC' EQ '').NDC5                                RH
         AIF   ('&DISPC' EQ 'OPEN').NDC6                            RH
.NDC5    ANOP                                                       RH
*        CLOSE ((2)),MODE=24      CLOSE THE O/P FILE         DEBUG  RH
         CLOSE ((2)),MODE=24      CLOSE THE O/P FILE         DEBUG  RH
.NDC6    ANOP                                                       RH
         SPACE 1                                             DEBUG  RH
DBUG&SYSNDX DS    0H                                         DEBUG  RH
         LM    0,15,&L1           RELOAD CALLERS REGS        DEBUG  RH
         MEND                                                       RH
*                                                                   RH
*
         TITLE '  --- CHANGE HISTORY FOR BACKDSNS'
*
*        FEB   1999..CHANGED THE WAY THE UCB NAME IS CALCULATED...
*                    4 DIGIT UCB NAMES ARE NOT STORED IN THE UCB
*                    LIKE A 3 DIGIT UCB IS...I NOW COVERT THE
*                    BINARY DEVICE NUMBER TO CHAR...FIND TRTAB.
*
*        OCT   1998..DFSMSRMM TAPE MANAGEMENT SYSTEM DOESN'T ALLOW
*                    YOU TO USE THE LAST 17 CHARS OF A TAPE DATASET
*                    NAME...YOU MUST USE THE CORRECT FULL NAME.
*                    SO WE WILL AGAIN USE THE SYSUT2 DSN TO CREATE
*                    THE DATASET NAME ON THE TAPE BY ADDING F001,
*                    F002, ETC. TO CREATE A UNIQUE DATASET NAME
*                    FOR ALL THE TAPE DATASET NAMES.
*                    OTHERWISE WE GET RC=4, REASON=220 WHEN ALLOCATING
*                    THE DISK DATASET.
*                  ..THIS FORCED A CHANGE TO THE LRECL OF THE
*                    //RESTORE FILE FROM 133 TO 200, MAKING THIS
*                    VERSION INCOMPATIBLE WITH THE PREVIOUS VERSION.
*                  ..FIX CODE THAT DETERMINES IF WE ARE STARTING AT
*                    A SEQUENCE NBR > 1.
*                  ..CHECK FOR BLKSIZE ON //RESTORE, DEFAULT=LRECL*50
*
*        FEB   1998..ADD CODE AT LABEL NEXTUSR AND NEXTUSR3 TO CHECK
*                    FOR * IN 1ST COLUMN.AND IGNORE COMMENTS.
*
*        AUG   1997..LOT'S OF CHANGES TO TRY TO GET IT TO RUN ON Y2K
*                  ..ADD 'IEBCOPY' PARM TO SAY ALWAYS USE IEBCOPY,
*                    NOT PDSFAST. PDSFAST GETS 713'S UNDER Y2K.
*                  ..ADDED CODE TO DUMP DCB'S AND JFCB'S TO //OUTDCB
*                    IF //DEBUG DD IS FOUND.
*              NOTE..LINK WITH AC(1) INTO AN AUTHORIZED LIBRARY
*                    TO AVOID IEBCOPY ERROR MSG THAT SAYS...
*                    *** IEBCOPY IS NOT APF AUTHORIZED ***
*
*        OCT   1996..BUILDDSN...FIX BUG SAYING CREATING DSN ON BACKUP
*                    IF DATASET IS NOT CATALOGED.
*
*        JUNE  1996..CHANGE UCB LOOKUP TO USE UCBSCAN MACRO
*
*                  ..ADD CODE (EXPALLOC SECTION) TO CREATE A DUMMY
*                    FILE 1 TO AVOID S713 ABENDS ON THE FIRST FILE.
*                    THAT WAY, FILE 1 WILL HAVE ANY EXPIRY DATE AND
*                    THEN A MULTIPLE OPEN ON THE FIRST FILE IS NOT
*                    NECESSARY.  THIS APPEARS TO BE A RECENT SYSTEM
*                    CHANGE PROBLEM.
*
*                  ..ALSO WE WILL NO LONGER ADD THE SYSUT2 DSN TO THE
*                    DISK FILE DSN, BUT THE DATASET NAME ON THE TAPE
*                    MUST BE DIFFERENT THAN THE DISK DATASET NAME, SO
*                    START ALL THE TAPE DATASET NAMES WITH "BACKUP.",
*                    OTHERWISE WE GET RC=4, REASON=220 WHEN ALLOCATING
*                    THE DISK DATASET.
*
*                  ..ALSO RACF WON'T LET US USE "NONE" AS THE FIRST
*                    TAPE DSN NOW THE 1ST FILE DSN IS NOT CHANGED.
*
*        NOV   1995..ADD CODE TO RECALL A MIGRATED DATASET IN SECTION
*                    BUILDDSN...
*
*        APR   1995..DON'T FREE VSAM FILES AS IT SEEMS IDCAMS DOES IT.
*                    FIX BUG IN ABOVE CODE....
*
*        JULY  1990..CHECK FOR PDSFAST, AND IF NOT FOUND, USE IEBCOPY
*                  ..CHECK FOR RACF, AND BYPASS IF NOT ACTIVE
*                  ..CHECK FOR BLKSIZE ON //RESTORE, DEFAULT=9044
*                  ..ADD 'KEEP' PARM TO ALLOW ALLOCATE BUT NOT CATLG
*                  ..ADD 'ALLOC' PARM TO USE ALLOCATED SPACE, NOT USED
*                  ..ADD 'VOL=' PARM TO ALLOW UP TO 4 VOLS FOR
*                    ALLOCATION OF NEW FILES.
*                  ..ADD 'UNIT=' PARM TO ALLOW ALLOCATION OF NEW
*                    FILES TO A SPECIFIC UNIT TYPE.
*                  ..ADD 'TUNIT=' PARM TO SPECIFY TAPE UNIT
*
*        JUNE  1990..ADD CODE TO READ DSCB4 TO CONVERT TRKS TO CYLS
*                  ..ALLOCATE VSAM FILES TO SYSUT1 TO BE ABLE TO COPY
*                    ALLOCATED FILES.
*
*        FEB   1990..ADD CODE TO RESTORE FILES FROM TAPE
*
*        JUNE  1989..ADD CHECK FOR DSN=NONE, TO USE JUST DISK NAME
*                    ON TAPE
*                  ..AFTER 1ST FILE ON TAPE, SET EXPIRY DATE TO NULL
*                  ..CREATE //RESTORE FILE
*
*
         SPACE    2
* SAVESET MACRO:
*
*        USED - TO DEFINE THE SAVE AREAS
*
         MACRO
&LABEL   SAVESET &NBR
         PRINT GEN
&N1      SETA  1
&N2      SETA  2
&N3      SETA  3
&LABEL   DS    0F
SAVE&N1  DC    F'0'
         DC    A(0)        PTR TO  PREV
         DC    A(SAVE&N2)  PTR TO NEXT
         DC    15F'0'      FOR R14 TO R12
.LOOP    ANOP
SAVE&N2  DC    F'0'
         DC    A(SAVE&N1)  PTR TO  PREV
         DC    A(SAVE&N3)  PTR TO NEXT
         DC    15F'0'      FOR R14 TO R12
&N1      SETA  &N1+1
&N2      SETA  &N2+1
&N3      SETA  &N3+1
         AIF   (&N2 LT &NBR).LOOP
SAVE&N2  DC    F'0'
         DC    A(SAVE&N1)  PTR TO  PREV
         DC    A(0)        PTR TO NEXT
         DC    15F'0'      FOR R14 TO R12
         MEND
         SPACE    2
* SECTION MACRO:
*
*        USED - TO DEFINE THE VARIOUS SECTIONS OF CODE HEREIN
*
         MACRO
&LABEL   SECTION &GEN=NO,&DROP=YES,&SAVE=NO,&AMODE=24,&RMODE=24
         PRINT GEN
&LABEL   CSECT
&LABEL   AMODE &AMODE
&LABEL   RMODE &RMODE
         PRINT &GEN.GEN
.*       PRINT NOGEN
         SAVE     (14,12),,&LABEL   SAVE CALLER'S REGISTERS
         AIF ('&DROP' EQ 'NO').NODROP
         DROP  R12                DROP PREVIOUS SECTION BASE
.NODROP  ANOP
         USING    &LABEL,R12        ESTABLISH ADDRESABILITY
         LR       R12,R15
         AIF ('&SAVE' EQ 'NO').NOSAVE
         BAL      R15,PS&SYSNDX     BRANCH AROUND SAVE AREA         RH
SV&SYSNDX DS      18F'0'            SAVE AREA                       RH
PS&SYSNDX DS      0H                                                RH
         USING    SAVEAREA,R15      SET SAVE AREA BASE              RH
         ST       R13,SAVELAST      CHAIN SYSTEM SAVE AREA TO MINE  RH
         DROP     R15               DROP SAVE AREA BASE             RH
         USING    SAVEAREA,R13      SET SAVE AREA BASE              RH
         ST       R15,SAVENEXT      CHAIN MY SAVE AREA TO SYSTEMS   RH
         LR       R13,R15           R13 -> TO MY SAVE AREA          RH
         AGO      .GOTSAVE
.NOSAVE  ANOP
         USING    SAVEAREA,R13
*        L        R13,SAVENEXT      POINT TO NEXT SAVE AREA IN CHAIN
         ICM      R13,15,SAVENEXT   POINT TO NEXT SAVE AREA IN CHAIN
         BZ    *+2                ABEND IF NO SAVE AREA
.GOTSAVE ANOP
         AIF ('&LABEL' EQ 'DEBUGRTN').NDB
         LR       R2,R0             SAVE REGS OVER DEBUG
         LR       R3,R1
         LA       R1,=CL8'&LABEL'
         SR       R0,R0             R0=0 MEANS SECTION ENTRY
         PERFORM  DEBUGRTN
         LR       R0,R2
         LR       R1,R3
.NDB     ANOP
         MEND
         AGO   .MYMAC
         MACRO
&LABEL   SECTION
&LABEL   CSECT
         SAVE     (14,12),,&LABEL   SAVE CALLER'S REGISTERS
         USING    &LABEL,R12        ESTABLISH ADDRESABILITY
         LR       R12,R15
         BAL      R15,A&SYSNDX      BRANCH AROUND SAVE AREA         RH
SAVE&SYSNDX DS    18F'0'            SAVE AREA                       RH
A&SYSNDX DS       0H                                                RH
         USING    SAVEAREA,R15      SET SAVE AREA BASE              RH
         ST       R13,SAVELAST      CHAIN SYSTEM SAVE AREA TO MINE  RH
         DROP     R15               DROP SAVE AREA BASE             RH
         USING    SAVEAREA,R13      SET SAVE AREA BASE              RH
         ST       R15,SAVENEXT      CHAIN MY SAVE AREA TO SYSTEMS   RH
         LR       R13,R15           R13 -> TO MY SAVE AREA          RH
         AIF ('&LABEL' EQ 'DEBUGRTN').NDB
         LR       R2,R0             SAVE REGS OVER DEBUG
         LR       R3,R1
         LA       R1,=CL8'&LABEL'
         SR       R0,R0             R0=0 MEANS SECTION ENTRY
         PERFORM  DEBUGRTN
         LR       R0,R2
         LR       R1,R3
.NDB     ANOP
         MEND
.MYMAC   ANOP
         SPACE    2
         MACRO
&LABEL   SECEXIT
.* PUT RET CODE IN R15 BEFORE CALLING
         PRINT GEN
&LABEL   DS    0H
         PRINT NOGEN
         AIF ('&LABEL' EQ 'DEBUGRET').NDB
         LR       R4,R15            SAVE RETURN CODE
         LR       R2,R0             SAVE REGS OVER DEBUG
         LR       R3,R1
         LA       R1,=CL8'&LABEL'
         LA       R0,1              R0 NOT= 0 MEANS SECTION EXIT
         PERFORM  DEBUGRTN
         LR       R0,R2
         LR       R1,R3
         LR       R15,R4            RESTORE RETURN CODE
.NDB     ANOP
         L        R13,SAVELAST      POINT TO CALLER'S SAVEAREA
         LM       R0,R12,SAVER0     RESTORE REGISTERS 0 TO 12
         L        R14,SAVER14       RESTORE R14
         MVI      SAVER14,X'FF'     MARK THAT WE'VE EXITED UP 1 LEVEL
         BR       R14               RETURN TO CALLER
         LTORG
         MEND
         EJECT
         MACRO
&LABEL   PERFORM  &ROUTINE,&ERR=
.**********************************************************************
*
&LABEL   ICM   R15,15,=V(&ROUTINE)  GET ADDRESS OF ROUTINE TO CALL
         BZ    X&SYSNDX           EXIT IF BAD ADDRESS
         BALR     R14,R15           BRANCH TO IT
X&SYSNDX DS       0H                                                RH
         AIF ('&ERR' EQ '').PEXIT   ANY ERROR ROUTINE SPECIFIED?
         LTR      R15,R15           CHECK THE RETURN CODE
         BNZ      &ERR
.PEXIT   ANOP
***********************************************************************
         MEND
         SPACE    2
* OLCMSG MACRO:
*
*        USED - TO WRITE MSG TO OLCPRINT DDNAME,
*             - TO WRITE MSG TO THE JOB LOG
*             - TO WRITE MSG TO THE CONSOLE
*             - TO START THE "SIGNAL" MESSAGE REGION TO NOTIFY TAF AND
*               IMF/SM OF COMPLETION OF THIS PROGRAM
*             - TO ABEND THIS PROGRAM IF NECESSARY AFTER MSG HAVE BEEN
*               WRITTEN.
*
MSGPOINT EQU      1                   REGISTER TO POINT TO ERROR MSG
         SPACE    2
         MACRO
&LABEL   OLCMSG   &MSG                MACRO PARM MAPPED BY MSGDSECT
&LABEL   DS       0H
         LA       MSGPOINT,&MSG       POINT AT THE ERROR MSG
*        L        R15,=V(MSGRTN)      LOAD ADDRESS OF OLCMSG ROUTINE
*        BALR     R14,R15             GO TO MSG ROUTINE
         ICM   R15,15,=V(MSGRTN)   GET ADDRESS OF OLCMSG ROUTINE
         BZ    OL&SYSNDX           EXIT IF BAD ADDRESS
         BALR     R14,R15           BRANCH TO IT
OL&SYSNDX DS      0H                                                RH
         MEND
         EJECT
BACKDSNS CSECT
BACKDSNS AMODE 24
BACKDSNS RMODE 24
*
*        M A I N L I N E :
*
         PRINT NOGEN
*
*  ON ENTRY :
*                 R1  = A(PARM LIST)
*                 R13 = A(SAVEAREA)
*                 R14 = RETURN ADDRESS
*                 R15 = A(BACKDSNS)
*
*  PARM  LIST :
*                 NONE
*
*        SAVE REGS ON ENTRY IN SYSTEMS SAVEAREA
         SAVE     (14,12),,BACKDSNS-V1R2M0-&SYSDATE-&SYSTIME
*
         USING    BACKDSNS,R12        R12 IS BASE REGISTER
         LR       R12,R15             SET IT UP
*
         L        R15,=V(SAVE)        R15 <-- ADDR OF OUR SAVEAREA
         USING    SAVEAREA,R13
         ST       R15,SAVENEXT        R15 --> HIS SAVEAREA, PT TO NEXT
*
         DROP     R13
         USING    SAVEAREA,R15        SET SAVEAREA DSECT ON OUR SA
         ST       R13,SAVELAST        HIS SA --> OUR SA PTR TO PREV
         LR       R13,R15             R13 <-- OUR SAVEAREA
         DROP     R15
         USING    SAVEAREA,R13
         ST       R1,PARMADDR         SAVE PARM ADDRESS
         SPACE 2
*
         PERFORM  OPENSYSP    OPEN OLCPRINT,DEBUG AND PUT DATE TIME MSG
*
         PERFORM  EDITPARM    GO EDIT THE PARM LIST
         LTR      R15,R15     IS THIS A PROPER INVOCATION?
         BNZ      EXITLOGC
*
*        MVC   USRDDNAM,USRDFMT   SET UP DDNAME OF USER LIB LIST
         PERFORM  DETUSER     DETERMINE & COPY USER LIBS TO TAPE
*
         PERFORM  CLOSSYSP    CLOSE OLCPRINT
         SPACE 2
*
* MAINLINE EXIT LOGIC :
*
*              NOW PUT THE ORIGINAL JFCB INFO FOR SYSUT2 BACK
*              IN CASE THEY CATALOG THE DATASET NAME...
*
*        L     R2,=V(SYSUT2)      R2 -> TO SYSUT2 DCB               RH
*        RDJFCB ((2))             GET THE SYSUT2 JFCB               RH
*        LTR   R15,R15            GET IT?                           RH
*        BNZ   EXITLOGC           NO, TOO BAD                       RH
*        L     R2,=V(UT2JFCB)     R2 -> TO SYSUT2 JFCB              RH
*        L     R1,=V(FIRSTJFC)    R1 -> TO FIRST SYSUT2 JFCB        RH
*        MVC   0(176,R2),0(R1)    RE-LOAD 1ST JFCB
*
EXITLOGC DS    0H
*        L        R15,=V(SAVE)        R15 <-- ADDR OF OUR SAVEAREA
*        USING    SAVEAREA,R15        SET SAVEAREA DSECT ON OUR SA
         L        R13,SAVELAST        RETURN TO HIS SAVEAREA
         RETURN   (14,12),RC=(15)     RETURN TO SUPERVISOR
         DROP     R13
         LTORG
 TITLE 'BACKDSNS - LOCAL STORAGE '
         ENTRY IEBSYSIN
         ENTRY IEBHLDIN
*
*                   THE IEBCOPY SYSIN DDNAME FOR COPYING USER LIBS
IEBSYSIN DC  CL8'SYSIN'
*
*
* THE FIELD BELOW WILL BE DETERMINED BY READDIR
IEBHLDIN DC    CL8'SYSUT1  ' WILL MOVE IN CORRECT DDNAME WHEN KNOWN
*
         ENTRY    USRDDNAM
USRDDNAM DC       CL8'DSNS   ' DDNAME FOR LIST OF USR LIBS TO BACK UP
*
         ENTRY PARMADDR,PARMOLC,PARMFLAG
PARMADDR DC       F'0'   SAVE AREA FOR PARAMETER LIST POINTER
*                        ON THE START REGION TO SIGNAL TAF AND IMF/SM
PARMOLC  DC    CL8' '             PARM SAVE AREA (RESTORE)
PARMFLAG DC    X'00'              PARM FLAG AREA
KEEPFLG  EQU   X'80'              'KEEP' PARM WAS SPECIFIED
ALLOCFLG EQU   X'40'              'ALLOC' PARM WAS SPECIFIED
VOLFLAG  EQU   X'20'              'VOL=' PARM WAS SPECIFIED
OLC061   DC    CL81' '
         ORG   *-81
         DC    AL1(MSGPRT)
         DC    C'DSB061 - DATA SET BACKUP DONE'
         ORG   OLC061+81
*
         SPACE 3
*
* PRECHAINED IMS TYPE SAVEAREAS NEEDED TO CALL DFSMODE0 AND DFSMODS0
* THESE IMS TYPE SAVEAREAS ARE USED EXTENSIVELY HEREIN BY SECTION MACRO
*
         ENTRY    SAVE     DEFINE ENTRY POINT USED OUTSIDE THIS CSECT
SAVE     SAVESET 15
         AGO   .SKIPSAV
SAVE     DC       F'0'
         DC       F'0'     PTR TO PREV
         DC       A(SAVE2) PTR TO NEXT
         DC       15F'0'   FOR R14 TO R12
SAVE2    DC       F'0'
         DC       A(SAVE)  PTR TO PREV
         DC       A(SAVE3) PTR TO NEXT
         DC       15F'0'   FOR R14 TO R12
SAVE3    DC       F'0'
         DC       A(SAVE2) PTR TO PREV
         DC       A(SAVE4) PTR TO NEXT
         DC       15F'0'   FOR R14 TO R12
SAVE4    DC       F'0'
         DC       A(SAVE3) PTR TO PREV
         DC       A(SAVE5) PTR TO NEXT
         DC       15F'0'   FOR R14 TO R12
SAVE5    DC       F'0'
         DC       A(SAVE4) PTR TO PREV
         DC       A(SAVE6) PTR TO NEXT
         DC       15F'0'   FOR R14 TO R12
SAVE6    DC       F'0'
         DC       A(SAVE5) PTR TO PREV
         DC       A(SAVE7) PTR TO NEXT
         DC       15F'0'   FOR R14 TO R12
SAVE7    DC       F'0'
         DC       A(SAVE6) PTR TO PREV
         DC       A(SAVE8) PTR TO NEXT
         DC       15F'0'   FOR R14 TO R12
SAVE8    DC       F'0'
         DC       A(SAVE7) PTR TO PREV
         DC       A(SAVE9) PTR TO NEXT
         DC       15F'0'   FOR R14 TO R12
SAVE9    DC       F'0'
         DC       A(SAVE8) PTR TO PREV
         DC       F'0'     PTR TO NEXT   - END
         DC       15F'0'   FOR R14 TO R12
.SKIPSAV ANOP
 TITLE 'OPENSYSP - OPEN OLCPRINT DATASET AND WRITE HEADING'
*
* OPEN THE OLCPRINT DATASET, PUT OUT TIME AND DATE MSG
*
         DS    0H
OPENSYSP SECTION
         OPEN     (OLCPRINT,(OUTPUT))          OPEN IT
         LA       R1,OLCPRINT
         USING    IHADCB,R1
         TM       DCBOFLGS,DCBOFOPN            DID IT OPEN ?
         BZ       ERROPENP                     NO, GO TO ERR RTN
         DROP     R1
*
         LA    R1,OLC000D
         PERFORM  GETTOD          GO GET DATE, TIME
         OLCMSG   OLC000          PUT OUT 1ST MSG
         OLCMSG   OLC098          PUT OUT COMPILED DATE MSG
         SPACE 1
         RDJFCB RESTORE           IS RESTORE DD CARD THERE?
         LTR   R15,R15            WELL?
         BNZ   NOREST             NO, DON'T TRY TO OPEN IT THEN
         LA    R5,DEBUGE          R5 -> TO JFCB
         USING INFMJFCB,R5        SET DSECT
         TM    JFCBIND2,X'48'     DISP=OLD OR SHR?
         BM    RESTOPEN           YES
         OC    JFCBLKSI,JFCBLKSI  BLKSIZE SPECIFIED ?
         BNZ   RESTOPEN           YES
         LA    R1,RESTORE         R1 -> TO DCB
         USING IHADCB,R1          SET DCB BASE REG
         LH    R15,DCBLRECL       R15 = DCB LRECL
         MH    R15,=H'50'         BLKSIZE = LRECL*50
         DROP  R1                 DROP DCB BASE
         STH   R15,JFCBLKSI       SET DEFAULT BLKSIZE
         DROP  R5                 DROP JFCB ADDRESSABILITY
         SPACE 1
RESTOPEN DS    0H
         OPEN  (RESTORE,(OUTPUT)),TYPE=J   OPEN IT
         LA    R1,RESTORE         R1 -> TO DCB
         USING IHADCB,R1          SET DCB BASE REG
         TM    DCBOFLGS,DCBOFOPN  DID IT OPEN ?
         BO    NOREST             YES
         DROP  R1                 DROP DCB BASE
         OLCMSG   OLC041          SAY OPEN FAILED
         SPACE 1
NOREST   DS    0H
         RDJFCB DEBUG             IS THE DEBUG DD CARD THERE?
         LTR   R15,R15
         BNZ   RETOPNP            IF NOT  NO TRACE
         OPEN  (DEBUG,(OUTPUT)),TYPE=J
         LA    R1,DEBUG
         USING IHADCB,R1
         TM    DCBOFLGS,DCBOFOPN            DID IT OPEN ?
         BZ    ERROPEND                     NO, GO TO ERR RTN
         DROP  R1
         OLCMSG   OLC039
         B     RETOPNP                      RETURN TO CALLER
         SPACE    2
ERROPEND DS       0H
         OLCMSG   OLC040
         B     RETOPNP                      RETURN TO CALLER
ERROPENP DS       0H
         OLCMSG   OLC005
RETOPNP  SECEXIT                               RETURN TO CALLER
         SPACE 2
* OPENSYSP DATA:
*
         DC    CL81' '
         ORG   *-81
OLC000   DS    0A
         DC    AL1(MSGPRT)
         DC    C'DSB000 - DIVERSIFIED DEVELOPMENTS '
         DC    C'BACKUP UTILITY STARTING - '
OLC000D  DC       CL6'YY.DDD'
         DC       CL2' '
OLC000T  DC       CL8'HH:MM:SS'
         DC       CL7' '
         ORG   OLC000+81
         DC    CL81' '
         ORG   *-81
OLC098   DS    0A
         DC    AL1(MSGPRT)
         DC    C'DSB098 - BACKDSNS VERSION 7.0 COMPILED ON '
         DC    CL8'&SYSDATE'
         DC    CL2' '
         DC    CL8'&SYSTIME'
         ORG   OLC098+81
         SPACE
         DC    CL81' '
         ORG   *-81
OLC039   DS    0A
         DC    AL1(MSGPRT)
         DC    C'DSB039 - DEBUG OPTION IN EFFECT - '
         DC    C'A TRACE WILL BE PRODUCED IN FILE ''DEBUG'' '
         ORG   OLC039+81
         DC    CL81' '
         ORG   *-81
OLC040   DS    0A
         DC    AL1(MSGPRT)
         DC    C'DSB040 - DEBUG OPTION CANCELLED - '
         DC    C'OPEN ERROR ON FILE ''DEBUG'' '
         ORG   OLC040+81
         SPACE 1
OLC041   DS    0CL81
         DC    AL1(MSGPRT)
         DC    C'DSB041 - RESTORE LIST CANCELLED - '
         DC    C'OPEN ERROR ON FILE ''RESTORE'' '
         DC    CL(81-(*-OLC041))'  '
         SPACE 1
         DC    CL81' '
         ORG   *-81
OLC005   DS    0A
         DC    AL1(MSGPRT+MSGSGNL+MSGABND)
         DC    C'DSB005 - ABEND, CANNOT OPEN SYSPRINT DD'
         ORG   OLC005+81
         PRINT   NOGEN
         ENTRY OLCPRINT
OLCPRINT DCB   MACRF=(PM),DSORG=PS,RECFM=FB,LRECL=80,BLKSIZE=800,      +
               DDNAME=REPORT
         ENTRY RESTORE
RESTORE  DCB   MACRF=(PM),DSORG=PS,RECFM=FB,LRECL=200,  BLKSIZE=9044,  +
               DDNAME=RESTORE,EXLST=DEBUGE
         ENTRY DEBUG
DEBUG    DCB   MACRF=(PM),DSORG=PS,RECFM=FB,LRECL=80,BLKSIZE=800,      +
               DDNAME=DEBUG,EXLST=DEBUGE
DEBUGE   DC    0F'0',X'87',AL3(*+3),XL176'00'
*
*
 TITLE 'DEBUGRTN - PRODUCE A TRACE IN FILE ''DEBUG'' '
*
* PRODUCE A TRACE OF SECTION ENTRIES AND EXITS
*
*   NOTE - SINCE DEBUG DCB OPEN BY OPENSYSP, WE GET NO TRACE UNTIL
*          AFTER THAT SECTION HAS RUN
*
         DS    0H
DEBUGRTN SECTION
*
*              ON ENTRY, RC IS IN  R4
*
         ST    R4,SAVERC          SAVE RETURN CODE
         L     R2,=V(DEBUG)     IS DEBUG IN EFFECT
         USING IHADCB,R2
         TM    DCBOFLGS,DCBOFOPN  DID IT OPEN ?
         BZ    DEBUGRET           NO
         LR    R5,R1              R5 -> TO CSECT NAME               RH
         SPACE 1
         LTR   R0,R0            WAS IT A SECTION OR SECEXIT.
         BNZ   DEBUGEX            SECEXIT
         MVI   DEBUGN1,C' '       CLEAR MODULE NAME AREA
         MVC   DEBUGN1+1(68),DEBUGN1 ''
         L     R3,OFFSET        OFFSET MODULE NAME TO SHOW NESTING
         LA    R3,4(R3)         AND INCREMENT
         ST    R3,OFFSET
         CH    R3,=H'69'        MAX LINE LENGTH
         BNH   *+8
         LA    R3,61
         LA    R3,DEBUGN1(R3)
         MVC   0(8,R3),0(R5)    MOVE SECTION NAME TO TEXT           RH
         PUT   (R2),DEBUGN
         B     DEBUGRET
DEBUGEX  EQU   *
         MVI   DEBUGM1,C' '       CLEAR MODULE NAME AREA
         MVC   DEBUGM1+1(68),DEBUGM1 ''
         L     R3,OFFSET        OFFSET MODULE NAME TO SHOW NESTING
         LR    R4,R3
         SH    R4,=H'4'         AND DECRMENT
         BP    *+6
         SR    R4,R4            DO NOT LET IT GO NEG.
         ST    R4,OFFSET
         CH    R3,=H'69'        MAX LINE LENGTH
         BNH   *+8
         LA    R3,61
         LA    R3,DEBUGM1(R3)
         MVC   0(8,R3),0(R5)    MOVE SECTION NAME TO TEXT           RH
         L     R1,SAVERC          R1 = PREV SECTIONS RETURN CODE
         LTR   R1,R1              WAS THERE A RETURN CODE?
         BZ    NORC               NO
         CVD   R1,DWORD2          CONVERT TO DECIMAL
         UNPK  DWORD2(5),DWORD2+5(3) CONVERT TO DISPLAY
         MVZ   DWORD2+4(1),DWORD2 FIX SIGN BITS
         MVC   8(5,R3),=C', RC='  SET UP RC PART OF MSG             RH
         MVC   13(3,R3),DWORD2+2  PUT RC IN MSG                     RH
         SPACE 1
NORC     DS    0H
         PUT   (R2),DEBUGM
DEBUGRET SECEXIT
         DROP   R2
DWORD2   DC    D'0'
OFFSET   DC    F'0'
SAVERC   DC    F'0'
DEBUGN   DC    CL11' ENTRY TO:'
DEBUGN1  DC    CL69' '
DEBUGM   DC    CL11'EXIT FROM:'
DEBUGM1  DC    CL69' '
*
*
 TITLE 'CLOSESYSP - CLOSE OLCPRINT DATASET AND WRITE HEADING'
*
* PUT OUT LAST MSG AND CLOSE OLCPRINT
*
         DS    0H
CLOSSYSP SECTION
         LA    R1,OLC999D
         PERFORM  GETTOD                       GO GET DATE, TIME
         L     R2,MAXCC           R2 = MAX CC
         CVD   R2,MAXWORD         CONVERT TO DECIMAL
         UNPK  MAXWORD(5),MAXWORD+5(3) CONVERT TO DISPLAY
         MVZ   MAXWORD+4(1),MAXWORD FIX SIGN BITS
         MVC   OLC999C,MAXWORD+1  SET UP RETURN CODE
*
*
         L     R3,=V(OLCBLNK)     R3 -> TO BLANKS
         OLCMSG 0(0,R3)           PRINT A BLANK LINE BEFORE OLC999
         OLCMSG OLC999                       PUT OUT LAST MSG
         L     R5,=V(RESTORE)     R5 -> TO RESTORE DCB
         USING IHADCB,R5          SET DCB BASE
         TM    DCBOFLGS,DCBOFOPN  DID IT OPEN ?
         BZ    CLOSE1             NO, DON'T CLOSE IT
         CLOSE (R5)               CLOSE RESTORE FILE
         DROP  R5                 DROP DCB BASE
         SPACE 1
CLOSE1   DS    0H
         L     R5,=V(DEBUG)                  LOAD ADDRESS OF DCB
         USING IHADCB,R5          SET DCB BASE
         TM    DCBOFLGS,DCBOFOPN  DID IT OPEN ?
         BZ    CLOSE2             NO, DON'T CLOSE IT
         CLOSE (R5)               CLOSE DEBUG FILE
         DROP  R5                 DROP DCB BASE
         SPACE 1
CLOSE2   DS    0H
         L     R4,=V(OLCPRINT)               LOAD ADDRESS OF DCB
         USING IHADCB,R4          SET DCB BASE
         TM    DCBOFLGS,DCBOFOPN  DID IT OPEN ?
         BZ    SETRC              NO, DON'T CLOSE IT
         CLOSE (R4)               CLOSE OLCPRINT FILE
         DROP  R4                 DROP DCB BASE
         SPACE 1
SETRC    DS    0H
         L     R15,MAXCC          R15 = MAX CC
CLOSSYSE SECEXIT                               RETURN TO CALLER
         SPACE    2
         DC    CL81' '
         ORG   *-81
OLC999   DS    0A
         DC    AL1(MSGPRT)
         DC    C'DSB999 - DATA SET BACKUP UTILITY END  '
OLC999D  DC    CL6'YY.DDD'
         DC    CL2' '
OLC999T  DC    CL8'HH:MM:SS'
         DC    C'    RETURN CODE = '
OLC999C  DC    CL4'0000'
         ORG   OLC999+81
         ENTRY MAXCC
MAXCC    DC    F'0'
MAXWORD  DC    D'0'
 TITLE 'GETTOD - GET TIME OF DAY AND DATE'
         DS    0H
GETTOD   SECTION
*
* GET TIME OF DAY (TOD) AND FORMAT IT INTO TODDATE AND TODTIME FIELDS
*
* ON ENTRY R1 WILL POINT TO A 17 CHAR TEXT AREA WHICH WILL BE SET UP AS
* FOLLOWS:
*
*                  'YY.DDD  HH:MM:SS '
*
         LR    R2,R1              TOD OUTPUT AREA
         USING TIMEPARM,R2
         TIME  DEC
         STM   R0,R1,TIME
         MVC   TODDATE(7),DATEDIT  SET UP EDIT FIELD
         MVC   TODTIME(10),TIMEEDIT  SET UP EDIT FIELD
         ED    TODDATE(7),DATE+1 MAKE DATE PRINTABLE
         ED    TODTIME(10),TIME  MAKE TIME PRINTABLE
         MVI   TODTIME+9,C' '
         DROP  R2
         B     RETTOD
         SPACE    2
DATEDIT  DC    X'4021204B202020'
TIMEEDIT DC    X'4021207A21207A212020'
TIME     DC    F'0'
DATE     DC    F'0'
CL6      DC       CL6' '
TOD      DC       D'0'          TODTIME OF DAY FROM STCK
RETTOD   SECEXIT                           RETURN TO CALLER
TIMEPARM DSECT
TODDATE  DC    CL6'YY.DDD',C'  '
TODTIME  DC    CL8'HH:MM:SS',C' '
 TITLE 'EDITPARM - EXAMINE AND SAVE PARM PASSED TO PROGRAM'
*
* EDIT THE PARM WE WERE PASSED :
*
* ASSUMPTION: R1 IS AS ON ENTRY TO PROGRAM AFTER CALL BY SUPERVISOR
*
         DS    0H
EDITPARM SECTION
         L     R4,=V(PARMADDR)    GET A(PARM ADDRESS)
         L     R4,0(0,R4)         R4 -> TO A(PARM)
         L     R2,0(0,R4)         R2 -> TO PARM
         SPACE 1
***********************************************************************
*
*              SEE IF THERE IS A  PARM
*
*        VALID PARMS ARE:
*              IEBCOPY   USE IEBCOPY, NOT PDSFAST
*              RESTORE   THIS IS A RESTORE RUN
*                 VOL=   VOLUME FOR DISK RESTORE
*                        UP TO 4 VOLS CAN BE SPECIFIED, AS (V1,V2..)
*                UNIT=   UNIT FOR DISK RESTORE
*               TUNIT=   UNIT FOR TAPE
*                 KEEP   DON'T CATALOG NEW DATASETS
*                ALLOC   GET ALLOCATED SPACE, NOT USED SPACE
*
*        ANY OTHER PARMS ARE INVALID
*        IF NO PARMS ARE SPECIFIED, THE DEFAULTS WILL BE
*              PARM='UNIT=SYSDA,TUNIT=TAPE,VOL='
*
***********************************************************************
         SPACE 1
*              GET PARM, IF ANY
         SPACE 1
PARM0    DS    0H
         LA    R10,2(0,R2)        R10 -> TO PARM
         LH    R2,0(0,R2)         R2 = PARM LTH
         LTR   R2,R2              IS THERE A PARM ?
         BZ    ENDPARM            NO
         LR    R4,R10             YES, R4 -> TO PARM
         SPACE 1
PARM1    DS    0H
         CLC   =C'VOL=',0(R4)     IS IT THE 'VOL=' PARM?
         BNE   PARM2              NO, CHECK FOR NEXT PARM
         SPACE 1
         L     R5,=V(PARMFLAG)    R5 -> TO PARM FLAG                RH
         OI    0(R5),VOLFLAG      SAY VOL= WAS SPECIFIED            RH
         LA    R4,4(0,R4)         R4 -> PAST VOL=
         SH    R2,=H'4'           R2 = LTH OF REST OF PARM
         LR    R5,R4              R5 -> TO VOLSERS
         SPACE 1
PARM1B   DS    0H
         CLI   0(R4),C','         AT END OF VOL ?
         BE    PARM1C             YES, GO GET NEXT PARM
         LA    R4,1(0,R4)         R4 -> TO NEXT VOL BYTE, IF ANY
         BCT   R2,PARM1B          CHECK ALL CHARS LEFT
         SPACE 1
PARM1C   DS    0H
GOTVOL2  DS    0H
         L     R7,=V(TUPAR2)      R7 -> WHERE VOLSER GOES
         L     R14,=V(TUNUM2)     R14 -> TO  NBR OF VOLSERS
         MVI   1(R14),X'01'       DEFAULT TO 1 VOLSER
         SPACE 1
         CLI   0(R5),C'('         MORE THAN 1 VOL?
         BE    MULTVOL            YES
         MVC   0(6,R7),0(R5)      MOVE VOLSER TO TEXT UNIT 2
         B     ENDVOL             ON WE GO
         SPACE 1
MULTVOL  DS    0H
         LA    R5,1(0,R5)         R5 -> TO 1ST VOL
         LA    R15,4              R15 = MAX VOLSERS
         B     MOVVOL2            MOVE 1ST VOLSER
         SPACE 1
MOVVOL   DS    0H
         L     R14,=V(TUNUM2)     R14 -> TO  NBR OF VOLSERS
         LH    R8,0(0,R14)        R8 = NBR OF VOLSERS
         LA    R8,1(0,R8)         ADD ONE TO NBR OF VOLSERS
         STH   R8,0(0,R14)        SAVE IT
         SPACE 1
MOVVOL2  DS    0H
         MVC   0(6,R7),0(R5)      MOVE VOLSER TO TEXT UNIT 2
         LA    R5,6(0,R5)         R5 -> PAST VOLSER
         CLI   0(R5),C')'         END OF MULT VOLS?
         BE    ENDVOL             YES
         LA    R5,1(0,R5)         R5 -> TO NEXT VOLSER
         LA    R7,8(0,R7)         R7 -> TO WHERE NEXT VOLSER GOES
         BCT   R15,MOVVOL         SAVE NEXT VOLSER, TO MAX OF 4
         SPACE 1
ENDVOL   DS    0H
         B     NEXTPARM           GO CHECK FOR ANOTHER PARM
         SPACE 1
PARM2    DS    0H
         CLC   =C'UNIT=',0(R4)    IS IT THE 'UNIT=' PARM?
         BNE   PARM3              NO, CHECK FOR NEXT PARM
         SPACE 1
         LA    R4,5(0,R4)         R4 -> PAST UNIT=
         SH    R2,=H'5'           R2 = LTH OF REST OF PARM
         LR    R5,R4              R5 -> TO UNIT NAME
         SPACE 1
PARM2B   DS    0H
         CLI   0(R4),C','         AT END OF UNIT?
         BE    PARM2C             YES, GO GET NEXT PARM
         LA    R4,1(0,R4)         R4 -> TO NEXT KEY BYTE, IF ANY
         BCT   R2,PARM2B          CHECK ALL CHARS LEFT
         SPACE 1
PARM2C   DS    0H
         LR    R6,R4              R6 -> TO END OF UNIT
         SR    R6,R5              R6 = LTH OF UNIT
         L     R7,=V(TULNG3)      R7 -> TO UNIT LTH FIELD
         STH   R6,0(0,R7)         PUT UNIT LTH IN SVC99 FIELD
         BCTR  R6,0               R6 = HEX LTH
         L     R7,=V(TUPAR3A)     R7 -> TO UNIT NAME FIELD
         MVC   0(8,R7),=CL8' '    CLEAR UNIT NAME FIELD
         EX    R6,MVCUNIT         SET UP UNIT NAME
         B     NEXTPARM           GO CHECK FOR ANOTHER PARM
         SPACE 1
*VCUNIT  MVC   0(0,R7),0(R5)      MOVE UNIT NAME
         SPACE 1
PARM3    DS    0H
         CLC   =C'TUNIT=',0(R4)   IS IT THE TUNIT= PARM?
         BNE   PARM4              NO, CHECK FOR NEXT PARM
         SPACE 1
         LA    R4,6(0,R4)         R4 -> PAST TUNIT=
         SH    R2,=H'6'           R2 = LTH OF REST OF PARM
         LR    R5,R4              R5 -> TO TAPE UNIT NAME
         SPACE 1
PARM3B   DS    0H
         CLI   0(R4),C','         AT END OF UNIT?
         BE    PARM3C             YES, GO GET NEXT PARM
         LA    R4,1(0,R4)         R4 -> TO NEXT KEY BYTE, IF ANY
         BCT   R2,PARM3B          CHECK ALL CHARS LEFT
         SPACE 1
PARM3C   DS    0H
         LR    R6,R4              R6 -> TO END OF UNIT
         SR    R6,R5              R6 = LTH OF UNIT
         L     R7,=V(TULNG6)      R7 -> TO UNIT LTH FIELD
         STH   R6,0(0,R7)         PUT UNIT LTH IN SVC99 FIELD
         BCTR  R6,0               R6 = HEX LTH
         L     R7,=V(TUPAR6)      R7 -> TO TAPE UNIT NAME FIELD
         MVC   0(8,R7),=CL8' '    CLEAR UNIT NAME FIELD
         EX    R6,MVCUNIT         SET UP UNIT NAME
         B     NEXTPARM           GO CHECK FOR ANOTHER PARM
         SPACE 1
MVCUNIT  MVC   0(0,R7),0(R5)      MOVE UNIT NAME
         SPACE 1
PARM4    DS    0H
         CLC   =C'RESTORE',0(R4)  IS PARM RESTORE?
         BNE   PARM5              NO, GO CHECK FOR NEXT PARM        RH
         SPACE 1
         L     R5,=V(PARMOLC)     R5 -> TO OLC NAME                 RH
         MVC   0(7,R5),0(R4)      SAVE PARM                         RH
         SPACE 1
         LA    R4,7(0,R4)         R4 -> TO NEXT PARM, IF ANY
         SH    R2,=H'7'           R2 = LTH OF REST OF PARM
         B     NEXTPARM           LOOK AT ALL CHARS IN PARM
         SPACE 1
PARM5    DS    0H
         CLC   =C'KEEP',0(R4)     IS PARM KEEP ?
         BNE   PARM6              NO, GO CHECK FOR NEXT PARM        RH
         SPACE 1
         L     R5,=V(PARMFLAG)    R5 -> TO PARM FLAG                RH
         OI    0(R5),KEEPFLG      SAY KEEP WAS SPECIFIED            RH
         L     R5,=V(TUPAR7A)     R5 -> TO S99 PARM                 RH
         MVI   0(R5),X'08'        CHANGE DISP TO NEW,KEEP           RH
         SPACE 1
         LA    R4,4(0,R4)         R4 -> TO NEXT PARM, IF ANY
         SH    R2,=H'4'           R2 = LTH OF REST OF PARM
         B     NEXTPARM           LOOK AT ALL CHARS IN PARM
         SPACE 1
PARM6    DS    0H
         CLC   =C'ALLOC',0(R4)    IS PARM ALLOC ?
         BNE   PARM7              NO, GO CHECK FOR NEXT PARM        RH
         SPACE 1
         L     R5,=V(PARMFLAG)    R5 -> TO PARM FLAG                RH
         OI    0(R5),ALLOCFLG     SAY ALLOC WAS SPECIFIED           RH
         SPACE 1
         LA    R4,5(0,R4)         R4 -> TO NEXT PARM, IF ANY
         SH    R2,=H'5'           R2 = LTH OF REST OF PARM
         B     NEXTPARM           LOOK AT ALL CHARS IN PARM
         SPACE 1                                                    RH
PARM7    DS    0H
         CLC   =C'IEBCOPY',0(R4)  IS PARM IEBCOPY?
         BNE   PARM99             NO, GO CHECK FOR NEXT PARM        RH
         SPACE 1
         L     R5,=V(MBRNAME)     R5 -> TO LINK NAME                RH
         MVC   0(8,R5),=CL8'IEBCOPY' ALWAYS USE IEBCOPY
         SPACE 1
         LA    R4,7(0,R4)         R4 -> TO NEXT PARM, IF ANY
         SH    R2,=H'7'           R2 = LTH OF REST OF PARM
         B     NEXTPARM           LOOK AT ALL CHARS IN PARM
         SPACE 1                                                    RH
PARM99   DS    0H
         B     ERRPARM            GO TO ERROR ROUTINE FOR NOW
         SPACE 1                                                    RH
NEXTPARM DS    0H
         LTR   R2,R2              ANY PARM LEFT?
         BNP   ENDPARM            NO
         LA    R4,1(0,R4)         YES, R4 -> TO NEXT BYTE
         BCTR  R2,0               TAKE 1 OFF PARM LTH
         CLI   0(R4),C','         COMMA?
         BNE   PARM1              NO, GO SEE WHAT IT IS
         B     NEXTPARM           LOOK AT ALL CHARS IN PARM
         SPACE 1
ENDPARM  DS    0H
         SR    R15,R15            SET RETURN CODE
         B     EXITEDIT           RETURN TO MAINLINE                RH
         SPACE 1                                                    RH
ERRPARM  OLCMSG OLC001
         LA    R15,4              SET BAD RETURN CODE
         B     EXITEDIT           GO TO RETURN TO MAINLINE
         SPACE 1                                                    RH
EXITEDIT SECEXIT                      RETURN TO MAINLINE
*
* EDITPARM DATA:
*
         DC    CL81' '
         ORG   *-81
OLC001   DS    0A
         DC    AL1(MSGPRT+MSGSGNL)
         DC    C'DSB001 - PARM INFORMATION INVALID'
         ORG   OLC001+81
         SPACE 1                                                    RH
PARMIN   DSECT
PARMLEN  DS    H
PARMF3   DS    CL7                FIRST 7 CHARS OF PARM
PARMF4   DS    C                  NBR OF REGIONS TO START           RH
PARM     DS    CL4                PARM IS AT MAX 8 CHARS LONG
 TITLE 'IEBCOPY - LINK TO IEBCOPY'
         DS    0H
IEBCOPY  SECTION
*
*  ON ENTRY TO THIS SECTION R1 POINTS TO 8 CHAR IEBCOPY SYSIN DDNAME
*
*  SET UP IEBCOPY PARMS
         MVC     IEBDDNAM,0(R1)      PASS SYSIN DDNAME TO COPY
*        MVC     OLC025DD,0(R1)      IN CASE OF ERRORS
*        L     R1,=V(PARMOLC)     R1 -> TO INPUT PARM
*        CLC   =C'RESTORE',0(R1)  IS THIS A RESTORE?
*        BNE   NOSCRCH            NO
         PERFORM SCRATCHU         GO SCRATCH DIRECTORY OF SYSUT2
*                                 OR READ DIRECTORY OF SYSUT1
         SPACE 1
NOSCRCH  DS    0H
*
*  GIVE IEBCOPY ITS OWN SAVE AREA AND CHAIN IT TO THE SUPERV.
*  SAVE AREA. OTHERWISE, IEBCOPY WILL DESTROY OUR IMS TYPE
*  SAVE AREA CHAIN
        ST       R13,OURSA           OUR SAVE AREA POINTER
        LA       R13,IEBSAVE         GIVE IEBCOPY ITS OWN
        L        R5,=V(SAVE)         GET ADDR OF OUR SAVE AREA
        L        R6,4(,R5)           GET ADDR OF SUP'S SAVE AREA
        ST       R6,IEBSAVE+4        CHAIN SUP'S SAVEAREA TO IEBSAVE
*
*        SEE IF WE CAN FIND PDSFAST
*
BLDLNOP  NOP   NOFIND             B AFTER FIRST TIME
         MVI   BLDLNOP+1,X'F0'    CHANGE NOP TO B
         CLC   MBRNAME,=CL8'IEBCOPY' USE IEBCOPY ?
         BE    NOFIND             YES, WE DON'T NEED BLDL...
         BLDL  0,BLDLIST
         LTR   R15,R15
         BZ   NOFIND              WE FOUND PDSFAST
         MVC   MBRNAME,=CL8'IEBCOPY' CAN'T FIND PDSFAST, USE IEBCOPY
         SPACE 1
NOFIND   DS    0H
*                                                                   RH
*                  THIS IS CODE TO DUMP CORE                 DEBUG  RH
*                                                                   RH
         L     R2,=V(DEBUG)     IS DEBUG IN EFFECT
         USING IHADCB,R2
         TM    DCBOFLGS,DCBOFOPN  DID IT OPEN ?
         BZ    LINKINA            NO
         DROP  R2                 DROP BASE...
         SPACE 4                                             DEBUG  RH
         L     R3,=V(JFCB)        R3 -> TO SYSUT1 JFCB       DEBUG  RH
         PRINT   GEN
         HDUMP OUTDCB,R3,200,NOTOPEN,OPEN,V=YES,             DEBUG  RH +
               TITLE='SYSUT1 JFCB FOR IEBCOPY',GENDCB=YES
         L     R3,=V(JFCBXLSJ)    R1 -> TO SYSUT2 JFCB EXIT LIST
         HDUMP OUTDCB,R3,200,OPEN,CLOSE,                     DEBUG  RH +
               TITLE='SYSUT2 JFCB FOR IEBCOPY'
         SPACE 1                                             DEBUG  RH
         PRINT NOGEN
*                                                                   RH
*                  THIS IS END OF CODE TO DUMP CORE          DEBUG  RH
*                                                                   RH
LINKINA  DS    0H                                                   RH
         SR    R15,R15            MAKE SURE R15 IS 0
*
*  CALL IEBCOPY
*
         LINK  EPLOC=MBRNAME,PARAM=(IEBLIST,IEBDD),VL=1
*
*  CHECK RETURN CODE FROM PREVIOUS IEBCOPY CALL
*
         L        R13,OURSA          PLUG BACK INTO OUR SAVE AREA CHAIN
         CH       R15,=H'8'          RC OVER 8?
         BNH      *+4+4              NO, IT'S OKAY
         LA       R15,4              YES, CHANGE IT TO 4
         LR       R9,R15             SAVE RETURN CODE
         SPACE    2
         CVD      R15,IEBHRC
         OI       IEBHRC+7,X'0F'     MAKE POSITIVE
         UNPK     OLC025RC,IEBHRC
         OLCMSG   OLC025
         LR       R15,R9             SET RETURN CODE
IEBCOPYE SECEXIT
         SPACE 2
* IEBCOPY DATA:
*
         DC    CL81' '
         ORG   *-81
OLC025   DC    AL1(MSGPRT)
         DC    C'DSB025 - PDSFAST RETURN CODE ==> '
OLC025RC DC    CL7' '          ,C' FOR SYSIN DDNAME '
         ORG   OLC025+81
IEBHRC   DC    D'0'
*
* PARMS FOR CALLING IEBCOPY
*
         CNOP     2,4                HALFWORD NOT FW BOUNDARY
IEBDD    DC       AL2(IEBDDE-IEBDD-2) DDNAMES FOR IEBCOPY
         DC       32X'00'
IEBDDNAM DC       CL8' '             SYSIN DDNAME FOR IEBCOPY
IEBDDE   EQU      *                  IEBDD END
*
         CNOP     2,4                HW, NOT FW BOUNDARY
IEBLIST  DC       H'0'               NULL LIST
OURSA    DC       F'0'            SAVE OUR S.A. POINTER OVER IEBCOPY
IEBSAVE  DC       18F'0'          SPECIAL SAVE AREA FOR IEBCOPY
*
         ENTRY MBRNAME
MBRNAME  DC    CL8'PDSFAST '
*
BLDLIST  DS    0F
         DC    H'1',H'74'
BLDLNAME DC    CL8'PDSFAST'       DEFAULT TO PDSFAST
TTRC     DS    CL4
USERDATA DS    0CL62
         DS    CL12
MBRLTH   DS    CL3
         DS    CL13
         DS    CL34
*
*
         SPACE 2
 TITLE 'SEQCOPY - SEQUENTIAL COPY '
         DS    0H
SEQCOPY  SECTION
*
*
*        SET SYSUT2 DCB BLKSIZE AND LRECL                           RH1
*                                                                   RH1
         L     R1,=V(PARMOLC)     R1 -> TO INPUT PARM
         CLC   =C'RESTORE',0(R1)  IS THIS A RESTORE?
         BNE   BACKSET            NO
         SPACE 1
         L     R5,=V(UT2JFCB)     R5 -> TO SYSUT2 JFCB
         USING INFMJFCB,R5              SET DSECT
*        XC    0(176,R5),0(R5)    MAKE SURE JFCB IS CLEAN
         L     R4,=V(SYSUT2)      R4 -> TO SYSUT2 DCB
         USING IHADCB,R4                SET DCB DSECT
         RDJFCB ((4))
         LTR   R15,R15            WAS RDJFCB OKAY?
         BNZ   FAIL1              NO
*
*              MAKE SURE JFCB IS  CLEAN TO FORCE SYSTEM TO USE
*              INFO FROM DISK DSCB
*
         XC    JFCRECFM,JFCRECFM  SET JFCB RECFM TO 0
         XC    JFCBLKSI,JFCBLKSI  SET JFCB BLKSIZE TO 0
         XC    JFCLRECL,JFCLRECL  SET JFCB LRECL TO 0
*
*              MAKE SURE DCB  IS  CLEAN
*
         XC    DCBBLKSI,DCBBLKSI  SET SYSUT2 BLKSIZE TO 0
         XC    DCBLRECL,DCBLRECL  SET SYSUT2 LRECL TO 0
         XC    DCBRECFM,DCBRECFM  SET SYSUT2 RECFM TO 0
         XC    DCBDSORG,DCBDSORG  SET SYSUT2 DSORG TO 0
*
         SPACE 1
         DROP  R4                 DROP R4 AS DCB BASE
*
*              MAKE SURE SYSUT1 DCB  IS  CLEAN
*
         LA    R1,INFILE          R1 -> TO SYSUT1 DCB
         USING IHADCB,R1          SET R1 AS DCB DSECT
         XC    DCBBLKSI,DCBBLKSI  SET SYSUT1 BLKSIZE TO 0
         XC    DCBLRECL,DCBLRECL  SET SYSUT1 LRECL TO 0
         XC    DCBRECFM,DCBRECFM  SET SYSUT1 RECFM TO 0
         MVI   DCBDSORG,X'40'     SET SYSUT1 DSORG TO PS
         DROP  R1                 DROP R1 AS DCB BASE
         B     OPENCOPY           ON WE GO
         B     SETDCB             ON WE GO
         SPACE 1
BACKSET  DS    0H
         LA    R5,JFCB            R5 -> TO SYSUT1 JFCB
         USING INFMJFCB,R5              SET DSECT
         XC    0(176,R5),0(R5)    MAKE SURE JFCB IS CLEAN
         LA    R4,INFILE          R4 -> TO SYSUT1 DCB
         USING IHADCB,R4                SET DCB DSECT
         RDJFCB ((4))
         LTR   R15,R15            WAS RDJFCB OKAY?
         BNZ   FAIL1              NO
         L     R4,=V(SYSUT2)      R4 -> TO SYSUT2 DCB
         SPACE 1
SETDCB   DS    0H
         MVC   DCBBLKSI,JFCBLKSI  SET SYSUT2 BLKSIZE
         MVC   DCBLRECL,JFCLRECL  SET SYSUT2 LRECL
         DROP  R4,R5
         SPACE 1                                                    RH1
OPENCOPY DS    0H
         PRINT GEN
         OPEN  ((4),(OUTPUT))     OPEN NEW FILE
         TM    48(R4),X'10'       DID SYSUT2 OPEN OKAY ?
         BZ    FAIL2              NO, TOO BAD
         SPACE 1
OPENOK   DS    0H
         ICM   R1,15,INREC        R1 = ADDRESS OF WORK AREA
         BNZ   GOTAREA            WE HAVE ONE ALREADY
         GETMAIN R,LV=32768       GET A RECORD WORK AREA
         ST    R1,INREC           SAVE ADDRESS OF RECORD AREA
         SPACE 1
GOTAREA  DS    0H
*                                                                   RH
*                  THIS IS CODE TO DUMP CORE                 DEBUG  RH
*                                                                   RH
         L     R2,=V(DEBUG)     IS DEBUG IN EFFECT
         USING IHADCB,R2
         TM    DCBOFLGS,DCBOFOPN  DID IT OPEN ?
         BZ    OPENINA            NO
         DROP  R2                 DROP BASE...
         SPACE 4                                             DEBUG  RH
         LA    R3,INFILE          R3 -> TO INFILE DCB        DEBUG  RH
         PRINT   GEN
         HDUMP OUTDCB,R3,100,NOTOPEN,OPEN,V=YES,             DEBUG  RH +
               TITLE='SYSUT1 DCB FOR COPY',GENDCB=YES
         LA    R3,OPENINA         R3 -> TO OPEN CODE         DEBUG  RH
         HDUMP OUTDCB,R3,100,OPEN,OPEN,                      DEBUG  RH +
               TITLE='SYSUT1 OPEN CODE'
         L     R3,=V(JFCB)        R3 -> TO JFCB              DEBUG  RH
         HDUMP OUTDCB,R3,200,OPEN,OPEN,                      DEBUG  RH +
               TITLE='SYSUT1 JFCB FOR COPY'
         HDUMP OUTDCB,0,0,OPEN,CLOSE, DUMP REGS ONLY         DEBUG  RH +
               TITLE='REGS AT OPEN INFILE,INPUT'
         SPACE 1                                             DEBUG  RH
*        PRINT NOGEN
*                                                                   RH
*                  THIS IS END OF CODE TO DUMP CORE          DEBUG  RH
*                                                                   RH
OPENINA  DS    0H                                                   RH
         OPEN  (INFILE,(INPUT)),TYPE=J   OPEN SYSUT1
         PRINT NOGEN
         TM    INFILE+48,X'10'    DID SYSUT1 OPEN OKAY ?
         BZ    FAIL3              NO, TOO BAD
*                                                                   RH
         SPACE 1
FPROCESS DS    0H
         SPACE 1
         L     R0,INREC           R0 -> TO INPUT RECORD AREA        VBS
         GET   INFILE,(0)          READ RECORD                      VBS
         L     R0,INREC           R0 -> TO INPUT RECORD             VBS
         PUT   (4),(0)            WRITE RECORD ON TO NEW FILE
         B     FPROCESS
         SPACE 1
FENDJOB  EQU   *
         CLOSE ((4))              CLOSE NEW FILE
         USING IHADCB,R4          SET R4 AS DCB DSECT
         L     R15,DCBBUFCB       R15 = A(BUFFER)
         BCTR  R15,0              -1
         LTR   R15,R15            IS THERE A BUFFER?
         BZ    NOPOOL1            NO
         DROP  R4                 DROP R4 AS DCB DSECT
         FREEPOOL (4)             FREE BUFFER POOL BECAUSE DUMB
*                                 IBM DON'T
         SPACE
NOPOOL1  DS    0H
         TM    INFILE+48,X'10'    DID SYSUT1 OPEN ?
         BZ    NOCLOSE3           NO, DON'T CLOSE IT THEN
         CLOSE INFILE             YES, CLOSE IT
         LA    R4,INFILE          R4 -> TO INFILE DCB
         USING IHADCB,R4          SET R4 AS DCB DSECT
         L     R15,DCBBUFCB       R15 = A(BUFFER)
         BCTR  R15,0              -1
         LTR   R15,R15            IS THERE A BUFFER?
         BZ    NOCLOSE3           NO, DON'T TRY TO FREE IT
         DROP  R4                 DROP R4 AS DCB DSECT
         FREEPOOL INFILE          FREE BUFFER POOL BECAUSE DUMB
*                                 IBM DON'T
         SPACE 1
NOCLOSE3 DS    0H
         SPACE 2
SEQCOPYE SECEXIT
         SPACE 1                                                    RH1
FAIL1    DS    0H
         OLCMSG   OLC015          PRINT ERROR MSG
         LA    R15,40             SET RC=40
         B     SEQCOPYE           END FOR NOW
         SPACE 1                                                    RH1
FAIL2    DS    0H
         OLCMSG   OLC016          PRINT ERROR MSG
         LA    R15,40             SET RC=40
         B     SEQCOPYE           END FOR NOW
         SPACE 1                                                    RH1
FAIL3    DS    0H
         OLCMSG   OLC018          PRINT ERROR MSG
*        L     R4,=V(SYSUT2)      R4 -> TO SYSUT2 DCB
         CLOSE ((4))              CLOSE SYSUT2 FILE
         USING IHADCB,R4          SET R4 AS DCB DSECT
         L     R15,DCBBUFCB       R15 = A(BUFFER)
         BCTR  R15,0              -1
         LTR   R15,R15            IS THERE A BUFFER?
         BZ    NOPOOL2            NO, DON'T TRY TO FREE IT
         DROP  R4                 DROP R4 AS DCB DSECT
         FREEPOOL ((4))           FREE BUFFER POOL BECAUSE DUMB
*                                 IBM DON'T
         SPACE 1
NOPOOL2  DS    0H
         LA    R15,40             SET RC=40
         B     SEQCOPYE           END FOR NOW
         SPACE 1
* SEQCOPY  DATA:
*
         SPACE 1
OLC015   DS    0CL81
         DC    AL1(MSGPRT)
         DC    CL75'DSB015 - RDJFCB OF SYSUT1 FAILED'
         DC    C'ERROR'
         SPACE 1
OLC016   DS    0CL81
         DC    AL1(MSGPRT)
         DC    CL75'DSB016 - OPEN FAILED FOR SYSUT2'
         DC    C'ERROR'
         SPACE 1
OLC018   DS    0CL81
         DC    AL1(MSGPRT)
         DC    CL75'DSB018 - OPEN FAILED FOR SYSUT1'
         DC    C'ERROR'
*
INREC    DC    F'0'               ADDRESS OF INPUT RECORD AREA      VBS
         SPACE
         LTORG
         SPACE 1
         ENTRY INFILE,JFCB
INFILE   DCB   DDNAME=SYSUT1,DSORG=PS,MACRF=GM,EODAD=FENDJOB,       VBS+
               SYNAD=FREADER,EROPT=ACC,EXLST=JFCBADD                VBS
*              RECFM=U,BLKSIZE=31768,    FOR BLK COPIES             VBS+
               INSERT BEFORE SYNAD ABOVE
         SPACE 1
         DS    0F
         DC    C'JFCB'                                              RH1
JFCB     DC    176X'00'
JFCBADD  DC    X'05'              DCB OPEN EXIT                     RH1
         DC    AL3(DCBEXIT)       *                                 RH1
         DC    X'87'              JFCB ADDRESS                      RH1
         DC    AL3(JFCB)          *                                 RH1
         SPACE 2
FREADER EQU    *
         BR    R14                      RETURN TO GET ROUTINE
         SPACE 3                                                    RH1
*        IF RECFM=U ON SYSUT1, MAKE SURE CHAINED SCHEDULING BIT     RH1
*        IN DCBOPTCD IS TURNED OFF BECAUSE STUPID OS WILL LEAVE     RH1
*        IT ON AND THEN DCBLRECL IS NOT SET CORRECTLY.              RH1
         SPACE 1                                                    RH1
DCBEXIT  DS    0H                OPEN EXIT TO CHECK RECFM AND OPTCD RH1
         USING IHADCB,R1          SET DCB DSECT BASE                RH1
         TM    DCBRECFM,DCBRECU   IS IT A RECFM U FILE?             RH1
         BNOR  R14                NO, RETURN TO OPEN                RH1
         SPACE 1                                                    RH1
         NI    DCBOPTCD,255-DCBOPTC  MAKE SURE CHAIN BIT IS OFF     RH1
         SPACE 1                                                    RH1
EXITEND  DS    0H                                                   RH1
         BR    R14                RETURN TO OPEN ROUTINE            RH1
         DROP  R1                 DROP DCB DSECT BASE               RH1
         SPACE 1
         LTORG
         SPACE 2
 TITLE 'IDCCOPY - LINK TO IDCAMS'
         DS    0H
IDCCOPY  SECTION
*
*              SEE IF THIS IS A RESTORE
*
         L     R1,=V(PARMOLC)     R1 -> TO INPUT PARM
         CLC   =C'RESTORE',0(R1)  IS THIS A RESTORE?
         BNE   NOTRSTOR           NO
*
*              SET UP THE DELETE COMMAND
*
         LA    R1,DELLTH          R1 -> TO DELETE CMD
         ST    R1,EXREC           SAVE IT FOR IDCAMS
         ST    R1,EXITREC         SAVE IT FOR IDCAMS OPEN EXIT
         MVI   DELNAME,C' '       CLEAR DSN PART OF CMD AREA
         MVC   DELNAME+1(CLRLTHD-1),DELNAME   ''
         L     R1,=V(USRDSN)      R1 -> TO VSAM DSNAME
         MVC   DELNAME,0(R1)      PUT DSN INTO DELETE CMD
         MVC   IMPNAME,0(R1)      PUT DSN INTO IMPORT CMD
         MVC   OBJNAME,0(R1)      PUT DSN INTO OBJECTS CMD
         L     R1,=V(DYNTUNT1)    R1 -> TO VSAM DSNAME LTH
         LH    R2,4(0,R1)         R2 = DSNAME LTH
         LA    R1,DELNAME(R2)     R1 -> TO WHERE REST OF CMD GOES
         MVC   0(L'PART4,R1),PART4 PUT REST OF DELETE CMD IN
*
*              SET UP THE IMPORT COMMAND
*
*        MVI   IMPNAME,C' '       CLEAR DSN PART OF CMD AREA
*        MVC   IMPNAME+1(CLRLTH3-1),IMPNAME   ''
*        L     R1,=V(USRDSN)      R1 -> TO VSAM DSNAME
*        MVC   IMPNAME,0(R1)      PUT DSN INTO IMPORT CMD
*        L     R1,=V(DYNTUNT1)    R1 -> TO VSAM DSNAME LTH
*        LH    R1,4(0,R1)         R1 = DSNAME LTH
         LA    R1,IMPNAME(R2)     R1 -> TO WHERE REST OF CMD GOES
         MVI   0(R1),C')'         PUT ENDING ) ON
         L     R5,=V(PARMFLAG)    R5 -> TO PARM FLAG
         TM    0(R5),VOLFLAG      WAS THE VOL= PARM SPECIFIED?
         BZ    GETOBJ             NO, WE ARE FINISHED
         MVI   2(R1),C'-'         PUT ENDING - ON
         B     GETOBJ2            GO GET VOLS
         SPACE 1
GETOBJ   DS    0H
         MVC   IMLTH3(4),ENDREC   CHANGE TO /*
         SPACE 1
GETOBJ2  DS    0H
*        MVC   0(L'PART3,R1),PART3 PUT REST OF IMPORT CMD IN
*
*        MVI   OBJNAME,C' '       CLEAR DSN PART OF OBJ AREA
*        MVC   OBJNAME+1(CLRLTH4-1),OBJNAME   ''
*        L     R1,=V(USRDSN)      R1 -> TO VSAM DSNAME
*        MVC   OBJNAME,0(R1)      PUT DSN INTO OBJECTS CMD
*        L     R1,=V(DYNTUNT1)    R1 -> TO VSAM DSNAME LTH
*        LH    R1,4(0,R1)         R1 = DSNAME LTH
         LA    R1,OBJNAME(R2)     R1 -> TO WHERE REST OF CMD GOES
         MVI   1(R1),C'-'         PUT DASH IN
*
SKIPVOLS NOP   NOSMCA             B AFTER FIRST PASS
         MVI   SKIPVOLS+1,X'F0'   WE ONLY NEED TO MOVE VOLS ONCE
         MVI   VOLNAME,C' '       CLEAR VOL PART OF OBJ AREA
         MVC   VOLNAME+1(CLRLTH5-1),VOLNAME   ''
         LA    R7,VOLNAME         R7 -> WHERE VOLSERS GO
         L     R1,=V(PARMFLAG)    R1 -> TO PARM FLAG
         TM    0(R1),VOLFLAG      WAS THE VOL= PARM SPECIFIED?
         BZ    ENDVOLO            NO, GO CALL IDCAMS
         L     R5,=V(TUPAR2)      R5 -> WHERE VOLSERS ARE
         L     R14,=V(TUNUM2)     R14 -> TO  NBR OF VOLSERS
         LH    R8,0(0,R14)        R8 = NBR OF VOLSERS
         SPACE 1
MOVVOLO  DS    0H
         MVC   0(6,R7),0(R5)      MOVE VOLSER TO VOLUME PARM
         LA    R5,8(0,R5)         R5 -> TO NEXT VOLSER
         LA    R7,6(0,R7)         R7 -> TO WHERE COMMA GOES
         BCT   R8,MOVVOL1         SAVE NEXT VOLSER, TO MAX OF 4
         B     ENDVOLO            ALL 4 MOVED...
         SPACE 1
MOVVOL1  DS    0H
         MVI   0(R7),C','         PUT IN A COMMA
         LA    R7,1(0,R7)         R7 -> TO WHERE NEXT VOLSER GOES
         B     MOVVOLO            MOVE NEXT VOL
         SPACE 1
ENDVOLO  DS    0H
         MVC   0(3,R7),=C')))'    PUT ON ENDING PARENS
         B     NOSMCA             GO TRY TO IMPORT IT
         SPACE 1
*
*              PUT THE VSAM DSN INTO THE EXPORT COMMAND
*
NOTRSTOR DS    0H
         MVI   IDCNAME,C' '       CLEAR REST OF CMD AREA
         MVC   IDCNAME+1(CLRLTH-1),IDCNAME   ''
         L     R1,=V(USRDSN)      R1 -> TO VSAM DSNAME
         MVC   IDCNAME,0(R1)      PUT DSN INTO EXPORT CMD
*        L     R1,=V(DYNTUNT1)    R1 -> TO VSAM DSNAME LTH
*        LH    R1,4(0,R1)         R1 = DSNAME LTH
*        LA    R1,IDCNAME(R1)     R1 -> TO WHERE REST OF CMD GOES
*        MVC   0(L'PART3,R1),PART3 PUT REST OF EXPORT CMD IN
         SPACE 1
NOSMCA   DS    0H
*
*  GIVE IDCAMS ITS OWN SAVE AREA  AND CHAIN IT TO THE SUPERV.
*  SAVE AREA. OTHERWISE, IDCAMS WILL DESTROY OUR IMS TYPE
*  SAVE AREA CHAIN
        ST       R13,OURSA2          OUR SAVE AREA POINTER
        LA       R13,IDCSAVE         GIVE IDCAMS ITS OWN
        L        R5,=V(SAVE)         GET ADDR OF OUR SAVE AREA
        L        R6,4(,R5)           GET ADDR OF SUP'S SAVE AREA
        ST       R6,IDCSAVE+4        CHAIN SUP'S SAVEAREA TO IDCSAVE
*
*  CALL IDCAMS
*
         LINK  EP=IDCAMS,PARAM=(OPTIONS,DNAMES,PGNO,IOLIST),VL=1
*
*  CHECK RETURN CODE FROM ABOVE IDCAMS CALL
*
         L        R13,OURSA2         PLUG BACK INTO OUR SAVE AREA CHAIN
         LR       R9,R15             SAVE RETURN CODE
         CVD      R15,IDCHRC
         OI       IDCHRC+7,X'0F'     MAKE POSITIVE
         UNPK     OLC026RC,IDCHRC
         OLCMSG   OLC026          PRINT RETURN CODE MSG
         LR       R15,R9             SET RETURN CODE
         SPACE 1
IDCCOPYE SECEXIT
         SPACE 3
*
* IDCCOPY DATA:
*
         DC    CL81' '
         ORG   *-81
OLC026   DC    AL1(MSGPRT)
         DC    C'DSB026 - IDCAMS  RETURN CODE ==> '
OLC026RC DC    CL7' '
         ORG   OLC026+81
IDCHRC   DC    D'0'
OURSA2   DC    F'0'               SAVE OUR S.A. POINTER OVER IDCAMS
IDCSAVE  DC    18F'0'             SPECIAL SAVE AREA FOR IDCAMS
         SPACE 1
OPTIONS  DC    H'0'
DNAMES   DC    H'0'
PGNO     DC    H'0'
IOLIST   DC    F'1'               NBR OF GROUPS OF 3
         DC    A(ASYSIN)          CONTROLLER FOR SYSIN (GROUP 1)
         DC    A(INRTN)
         DC    A(AUDATA)
ASYSIN   DC    CL10'DDSYSIN'
AUDATA   DC    CL100' '
*
         SPACE 1
INRTN    DS    0H
         STM    14,12,12(13)
         BALR  R12,0
         USING *,R12,R11
         LA    R11,4095(0,R12)   LOAD SECOND BASE REGISTER
         LA    R11,1(0,R11)      LOAD SECOND BASE REGISTER
         LA    15,INSAVE
         ST    13,4(15)
         ST    15,8(13)
         LR    13,15
         B     CONT2
         SPACE
INSAVE   DC    18A(0)
         SPACE
CONT2    DS    0H
         L     R2,4(0,R1)         R2 -> TO IOFLAGS                  RH
         USING IOFLAGS,R2         SET BASE                          RH
         CLI   IOFLAG1,IOFOPEN    OPENING SYSIN?
         BE    OPENIN             YES, SAY OPEN WAS OK
         CLI   IOFLAG1,IOFCLOS    CLOSE SYSIN?
         BE    RETRC0             YES, SAY CLOSE WAS OKAY
         TM    IOFLAG1,IOFGET     DOES IDCAMS WANT A RECORD?
         BO    GIVEREC            YES, PASS IT AN EXPORT CMD
         B     RETRC12            IGNORE EVERYTHING ELSE
         SPACE 1
GIVEREC  DS    0H
         L     R3,8(0,R1)         R3 -> TO RECORD AREA
         USING IOINFO,R3          SET BASE                          RH
         L     R15,EXREC          R15 -> TO EXPORT CTL RECORD
         LH    R14,0(0,R15)       R14 = LTH OF RECORD
         ST    R14,IOIRECL        PASS IT TO IDCAMS
         LA    R1,2(0,R15)        R1 -> TO RECORD
         ST    R1,IOIREC          PASS IT TO IDCAMS
         AR    R15,R14            ADD REC LTH TO R15
         LA    R15,2(0,R15)       R15 -> TO NEXT REC
         ST    R15,EXREC          SAVE ITS ADDRESS
         CLC   0(2,R1),ENDATA     END OF INPUT TO IDCAMS?
         BE    RETRC4             YES
         SPACE 1
RETRC0   DS    0H
         LA    R15,0              SAY  GET WAS OK                   RH
         B     RET2               GO BACK TO IDCAMS                 RH
RETRC4   DS    0H
         LA    R15,4              SAY  NO MORE SYSIN                RH
         B     RET2               GO BACK TO IDCAMS                 RH
         SPACE 1
CLOSIN   DS    0H
         SPACE 1
OPENIN   DS    0H
         L     R15,EXITREC        R15 -> TO 1ST INPUT AREA
         ST    R15,EXREC          RESET INPUT REC ADDRESS
         B     RETRC0             GO SET RC AND RETURN
         SPACE 1
RETRC12  DS    0H
         LA    R15,12             SAY CALL WAS BAD                  RH
         B     RET2               GO BACK TO IDCAMS                 RH
         SPACE 1
RET      LA    15,0          GET RETURN CODE
         ORG   *-2
RETRC    DS    H             HALF WORD RETURN CODE, INITIALY ZERO
RET2     DS    0H
         L     13,4(13)      GET OLD SAVE AREA
         L     14,12(13)     GET REG 14
         LM    0,12,20(13)   GET REST OF REGS
         BR    14
         SPACE 1
PART3    DC    C' OUTFILE(SYSUT2) TEMPORARY'
PART4    DC    C'''  PURGE'
         SPACE 1
EXREC    DC    A(INLTH)           -> TO DELLTH FOR RESTORE
EXITREC  DC    A(INLTH)           -> TO DELLTH FOR RESTORE
         SPACE 1
*
*                                 1ST PART OF EXPORT CMD
*
INLTH    DC    AL2(INCTLL)
INCTL    DC    C' EXPORT '
IDCNAME  DC    CL44' '
CLRLTH   EQU   *-IDCNAME
         DC    C' -'
         DC    CL(80-(*-INCTL))'  '
INCTLL   EQU   *-INCTL
*
*                                 2ND PART OF EXPORT CMD
*
INLTH2   DC    AL2(INCTLL2)
INCTL2   DC    CL5' '
         DC    C' INFILE(SYSUT1)'
         DC    C' OUTFILE(SYSUT2) TEMPORARY'
         DC    CL(80-(*-INCTL2))' '
INCTLL2  EQU   *-INCTL2
*
*                                 /* TO END INPUT
*
         DC    H'2'
ENDATA   DC    C'/*'
         SPACE 2
*
*                                 DELETE COMMAND
*
DELLTH   DC    AL2(DELCTLL)
DELCTL   DS    0C
         DC    C'  DELETE '''
DELNAME  DC    CL44' '                       44
*        DC    C''' PURGE'
         DC    CL(80-(*-DELCTL))' '
CLRLTHD  EQU   *-DELNAME
DELCTLL  EQU   *-DELCTL
*
*                                 1ST PART OF IMPORT CMD
*
IMLTH    DC    AL2(IMCTLL)
IMCTL    DC    C' IMP '                      5
         DC    C'IFILE(SYSUT1) IEMPTY PURGE -' 28
         DC    CL(80-(*-IMCTL))'  '
CLRLTH2  EQU   *-IMPNAME
IMCTLL   EQU   *-IMCTL
*
*                                 2ND PART OF IMPORT CMD
*
IMLTH2   DC    AL2(IMCTLL2)
IMCTL2   DS    0C
         DC    C'    ODS('
IMPNAME  DC    CL44' '                       44
*        DC    C') -'
         DC    CL(80-(*-IMCTL2))' '
CLRLTH3  EQU   *-IMPNAME
IMCTLL2  EQU   *-IMCTL2
*
*                                 3RD PART OF IMPORT CMD
*
IMLTH3   DC    AL2(IMCTLL3)
IMCTL3   DS    0C
         DC    C'    OBJ(('
OBJNAME  DC    CL44' '                       44
*        DC    C'-'                          1
         DC    CL(80-(*-IMCTL3))' '
CLRLTH4  EQU   *-OBJNAME
IMCTLL3  EQU   *-IMCTL3
*
*                                 4TH PART OF IMPORT CMD
*
IMLTH4   DC    AL2(IMCTLL4)
IMCTL4   DS    0C
         DC    C'       VOLUMES('
VOLNAME  DC    CL27' '                       44
         DC    C')))'
         DC    CL(80-(*-IMCTL4))' '
CLRLTH5  EQU   *-VOLNAME
IMCTLL4  EQU   *-IMCTL4
*
*                                 /* TO END INPUT
*
ENDREC   DC    H'2'
ENDATA2  DC    C'/*'
         SPACE 2
         LTORG
IOFLAGS  DSECT
IOFLAG1  DS    X
IOFOPEN  EQU   X'00'
IOFCLOS  EQU   X'04'
IOFGET   EQU   X'08'
IOFPUT   EQU   X'0C'
IOFLAG2  DS    X
IOFIN    EQU   X'80'
IOFOUT   EQU   X'40'
IOFLAG3  DS    X
IOFLAG4  DS    X
         SPACE 1
IOINFO   DSECT
IOIREC   DS    F
IOIRECL  DS    F
         SPACE 1
         SPACE 1
 TITLE 'DETUSER - OPEN AND READ THE APPROPRIATE LIB CONTROL MEMBER'
DETUSER SECTION
*
*           //DSNS GIVES US THE NAMES OF THE USER LIBRARIES
*
* READ //DSNS, GO PROCESS THE USER LIBS SPECIFIED THEREIN
*
*        ON ENTRY, OUTPUT DDNAME IS IN VARIABLE IEBHLDIN
*
DCBPT    EQU     8
         LA      DCBPT,USRCNTL            GET ADDR OF DCB
         USING   IHADCB,DCBPT             ESTABLISH DCB ADDRESABILITY
         L       R4,=V(USRDDNAM)          GET ADDR OF USR LIB LIST MEM
         MVC     DCBDDNAM,0(R4)           MOVE DDNAME INTO DCB
         MVC     OLC042DD,0(R4)           MOVE IT IN CASE OF ERR MSG
         L     R1,=V(PARMOLC)     R1 -> TO INPUT PARM
         CLC   =C'RESTORE',0(R1)  IS THIS A RESTORE?
         BE    RSTOR              YES, DON'T GET SYSUT2 INFO
*
         PERFORM HOLDBLKS,ERR=SEND71   GET SOME INFO ON SYSUT2
*
         L     R2,=V(UT2JFCB)     R2 -> TO SYSUT2 JFCB              RH
         USING IHAJFCB,R2
         LH    R5,JFCBFLSQ        R5 = STARTING SEQ NBR
         DROP  R2                 DROP JFCB BASE
         CH    R5,=H'1'           STARTING AT FILE 1?
         BH    RSTOR              NO, DON'T CREATE EXPIRY DATE FILE
*
         PERFORM EXPALLOC ERR=ESTAEOFF  GO CREATE EXPIRY DATE FILE
*
RSTOR    DS    0H
         OPEN    ((DCBPT),(INPUT))
         TM      DCBOFLGS,DCBOFOPN        DID IT OPEN ?
         BO      NEXTUSR                  YES
         OLCMSG  OLC042                   PUT OUT MSG AND ABEND
         SPACE 1
NEXTUSR  L       R2,=V(USRDSN)
         GET     (DCBPT),(R2)       ON EOF, WILL BRANCH TO EOFUSRC
         CLI   0(R2),C'*'         COMMENT RECORD?
         BE    NEXTUSR            YES, IGNORE IT
         L     R1,=V(PARMOLC)     R1 -> TO INPUT PARM
         CLC   =C'RESTORE',0(R1)  IS THIS A RESTORE?
         BNE   NOTREST            NO, DON'T COPY THIS RECORD
         SPACE 1
         L     R1,=V(RESTREC)     R1 -> TO RESTORE RECORD AREA
         MVC   0(L'RESTREC,R1),0(R2) MOVE RECORD TO RESTORE AREA
         USING RESTRECD,R1        SET BASE
*
*              SEE IF THERE IS ANOTHER VOLSER
*
         L     R3,=V(VOLSER2)     R3 -> TO MULTIPLE VOLSER NBR
         LA    R4,7(0,R3)         R4 -> TO MULTIPLE VOLSER AREA
         LA    R5,1               SAY AT LEAST 1 VOLSER
         MVC   1(6,R3),RESTVSER   SAVE FIRST VOLSER
         SPACE 1
NEXTUSR2 DS    0H
         CLI   RESTVSER+6,C' '    IS THERE ANOTHER VOLSER?
         BE    NOVOL2F            NO
         SPACE 1
NEXTUSR3 DS    0H
         GET   (DCBPT),NEXTREC    READ 2ND LINE, ON EOF -> EOFUSRC
         LA    R1,NEXTREC         R1 -> TO NEXT RESTORE RECORD
         CLI   0(R1),C'*'         COMMENT RECORD?
         BE    NEXTUSR3           YES, IGNORE IT
         MVC   0(6,R4),RESTVSER   SAVE NEXT VOLSER
         LA    R4,6(0,R4)         R4 -> TO WHERE NEXT VOLSER GOES
         LA    R5,1(0,R5)         R5 = NBR OF VOLS
         B     NEXTUSR2           GO SEE IF THERES ANOTHER ONE
*
*              NOW SET UP THE DSORG FOR SYSUT2
*
NOVOL2F  DS    0H
         STC   R5,0(0,R3)         SAVE NBR OF VOLS
         L     R1,=V(RESTREC)     R1 -> TO RESTORE RECORD AREA AGAIN
         L     R14,=V(SYSDSORG)   R14 -> TO SYSUT2 DSORG
         MVC   0(2,R14),=X'0008'  ASSUME IT'S VSAM
         CLC   RESTTYPE,=C'VS'    IS IT A VSAM FILE?
         BE    DSORGSET           YES, DSORG IS SET
         MVC   0(2,R14),=X'0200'  ASSUME IT'S PO
         CLC   RESTTYPE,=C'PO'    IS IT A PO FILE?
         BE    DSORGSET           YES, DSORG IS SET
         MVC   0(2,R14),=X'2000'  ASSUME IT'S DA
         CLC   RESTTYPE,=C'DA'    IS IT A DA FILE?
         BE    DSORGSET           YES, DSORG IS SET
         MVC   0(2,R14),=X'4000'  ASSUME IT'S SEQ
         CLC   RESTTYPE,=C'PS'    IS IT A SEQ FILE?
         BE    DSORGSET           YES, DSORG IS SET
         SPACE 1
DSORGSET DS    0H
         DROP  R1                 DROP BASE
         SPACE 1
NOTREST  DS    0H
         PERFORM USRPROC            GO PROCESS THE USERS LIBRARY
         L     R2,=V(MAXCC)       ADDRESS OF MAX RC
         C     R15,0(0,R2)        THIS RC BIGGER THAN THE LAST ONE?
         BNH   NOTBIG             NO
         ST    R15,0(0,R2)        YES, SAVE THIS RC
         SPACE 1
NOTBIG   DS    0H
         CH      R15,=H'20'         ANY SERIOUS ERRORS?
         BNH     NEXTUSR            IF NOT, CONTINUE WITH USER DSN LIST
         SPACE 1
SEND71   DS    0H
         OLCMSG  OLC071             PUT OUT MSG AND ABEND
         B     EOFUSRC2           END OF BACKDSNS...
         SPACE   2
EOFUSRC  DS      0H                 BRANCH HERE ON EOF FILE FMTCNTL
*
*              RE-WRITE FIRST DSN  IN CASE THEY SPECIFIED
*              NEW,CATLG.....     DOESN'T WORK YET...OCT 1/98       RH
*
*        L     R2,=V(FREEFLAG)    R2 -> TO FREEFLAG
*        OI    0(R2),LASTDSN      SAY WRITE LAST DSN
*        PERFORM EXPALLOC ERR=ESTAEOFF  GO CREATE EXPIRY DATE FILE
*
         SPACE   2
EOFUSRC2 DS      0H                 BRANCH HERE ON EOF FILE FMTCNTL
         CLOSE   ((DCBPT))          CLOSE THE FMT CONTROL DATASET
         USING IHADCB,DCBPT       SET DCBPT AS DCB DSECT
         L     R15,DCBBUFCB       R15 = A(BUFFER)
         BCTR  R15,0              -1
         LTR   R15,R15            IS THERE A BUFFER?
         BZ    NOPOOL3            NO, DON'T TRY TO FREE IT
         DROP  DCBPT              DROP DCBPT AS DCB DSECT
         FREEPOOL (DCBPT)         FREE BUFFER POOL BECAUSE DUMB     RH
*                                 IBM DON'T                         RH
         SPACE 1
NOPOOL3  DS    0H
         SR      R15,R15
DETUSERE SECEXIT                    RETURN
         SPACE   2
OLC042   DC      CL81' '
         ORG     *-81
         DC      AL1(MSGPRT+MSGSGNL+MSGABND)
         DC    C'DSB042 - UNABLE TO OPEN COPY CONTROL DDCARD '
OLC042DD DC      CL8'UNKNOWN'
         ORG     OLC042+75
         DC      CL5'ERROR'
         ORG     OLC042+81
OLC071   DC      CL81' '
         ORG     *-81
         DC      AL1(MSGPRT+MSGABND)
         DC    C'DSB071 - SERIOUS ERROR PROCESSING USER LIBRARY'
         ORG     OLC071+75
         DC      CL5'ERROR'
         ORG     OLC071+81
         SPACE 1
         DS    0F                 PUT ON FULLWORD BOUNDARY
NEXTREC  DS    CL200              INPUT AREA FOR MULT VOLS
         SPACE 1
         PRINT     NOGEN
USRCNTL  DCB     MACRF=(GM),DSORG=PS,DDNAME=DCBDDNAM,EODAD=EOFUSRC
         SPACE 2
 TITLE 'HOLDBLKS - GET SYSUT2 INFORMATION'
*
*
*        ON ENTRY, OUTPUT DDNAME IS IN VARIABLE IEBHLDIN
*
*
HOLDBLKS SECTION
*
*              GET THE DEVICE TYPE
*
*
*  SEARCH THROUGH THE TIOT TO FIND THE DDNAME 'SYSUT2'.
*
CHEKTIOT L         R1,16               A(CVT)
         L         R1,0(R1)            A(TCB ADDRESSES)
         L         R1,4(R1)            A(OUT TCB)
         L         R1,12(R1)           A(TIOT)
         LA        R3,24               OFFSET OF FIRST DDNAME ENTRY
*
*   NOW CHECK THE NEXT ENTRY IN THE TIOT. AN ENTRY LENGTH OF
*   ZERO SIGNALS THE END.
*
TIOLOOP  AR        R1,R3               GO ON TO NEXT ENTRY
         IC        R3,0(R1)            LENGTH OF ENTRY
         LTR       R3,R3               LENGTH OF ZERO?
         BZ        TIOEND              YES, SO MUST BE END OF TABLE
         CLC       4(6,R1),=C'SYSUT2'  SYSUT2 ENTRY?
         BNE       TIOLOOP             NO, SO BACK FOR NEXT ONE
*
*   WE'VE FOUND SYSUT2 DD ENTRY, SO PLACE THE UNIT ADDRESS INTO
*   THE SVC99  FIELD.
*
*        L     R5,16(0,R1)        R5 -> TO UCB
*        LA    R5,1(0,R5)         CLEAR HI BYTE
*        L     R7,=V(TUPAR6)      R7 -> TO UNIT FIELD FOR SVC99
*        MVC   0(3,R7),12(R5)     PUT UNIT NAME INTO SVC99 BLOCK
*        MVC   3(5,R7),=CL5' '    BLANK OUT REST OF UNIT NAME
*
*   THE ONLY PROBLEM IS THAT THE ABOVE CODE DOESN'T WORK FOR
*   4 DIGIT UCB ADDRESSES, AS THE UCBNAME FIELD CONTAINS 'UCB'.
*   SO WE MUST CONVERT THE REAL UCB ADDRESS FROM THE HEX ADDRESS
*   AT OFFSET +4 IN THE UCB...FEB 10/99
*
*   ALSO, IF YOU ARE ALLOCATING BY UNIT, IT MUST BE PRECEDED BY /   RH
*              ..EG../190A.....
*
         L     R5,16(0,R1)        R5 -> TO UCB
*        LA    R5,1(0,R5)         CLEAR HI BYTE
*        L     R7,=V(TUPAR6)      R7 -> TO UNIT FIELD FOR SVC99
         L     R7,=V(TULNG6)      R7 -> TO UNIT FIELD FOR SVC99
*
*              CONVERT UCB ADDRESS FOR UNIT NAME
*
*        MVI   2(R7),C'/'         SAY WE ARE USING A 4-DIGIT UCB    RH
*        MVI   TULNG3+1,X'05'     MAKE SURE LTH IS 5                RH
         MVI   1(R7),X'04'        MAKE SURE LTH IS 4                RH
         UNPK  2(5,R7),4(3,R5)    UNPACK 4 DIGIT UNIT ADDRESS
         MVI   6(R7),X'EF'        TRANSLATES TO BLANK
         TR    2(5,R7),TRTAB-239  TRANSLATE TO DISPLAY
         MVC   7(3,R7),=CL5' '    BLANK OUT REST OF UNIT NAME
*
*                                                                   RH
*                  THIS IS CODE TO DUMP CORE                 DEBUG  RH
*                                                                   RH
         L     R2,=V(DEBUG)     IS DEBUG IN EFFECT
         USING IHADCB,R2
         TM    DCBOFLGS,DCBOFOPN  DID IT OPEN ?
         BZ    TIOT2              NO
         DROP  R2                 DROP BASE...
         SPACE 1                                             DEBUG  RH
         PRINT   GEN
         HDUMP OUTDCB,R1,200,NOTOPEN,OPEN,V=YES,             DEBUG  RH +
               TITLE='TIOT FOR SYSUT2'        ,GENDCB=YES
         HDUMP OUTDCB,R5,200,NOTOPEN,OPEN,V=NO,              DEBUG  RH +
               TITLE='UCB FROM TIOT'          ,GENDCB=YES
         HDUMP OUTDCB,R7,20,NOTOPEN,OPEN,V=NO,              DEBUG   RH +
               TITLE='TUPAR6 AT TIOT'          ,GENDCB=YES
         SPACE 1                                             DEBUG  RH
         PRINT NOGEN
*                                                                   RH
*                  THIS IS END OF CODE TO DUMP CORE          DEBUG  RH
*                                                                   RH
         SPACE 1                                             DEBUG  RH
TIOT2    DS    0H                                            DEBUG  RH
         SPACE 1
HB20     DS    0H
         L     R2,=V(SYSUT2)      R2 -> TO SYSUT2 DCB               RH
         RDJFCB ((2))             GET THE SYSUT2 JFCB               RH
         LTR   R15,R15            GET IT?                           RH
         BNZ   FAIL4              IF NOT  NO BLKSIZE                RH
         L     R2,=V(UT2JFCB)     R2 -> TO SYSUT2 JFCB              RH
         USING IHAJFCB,R2
         MVC   FIRSTJFC,0(R2)     SAVE 1ST JFCB
*
*   PUT SOME OF THE JFCB INFO INTO THE SVC99 PARMS
*
*       NOTE...THE DATASET NAME ON THE TAPE MUST BE DIFFERENT
*              THAN THE DISK DATASET NAME, SO START ALL THE TAPE
*              DATASET NAMES WITH "BACKUP.".
*
         L     R6,=V(TUPAR1)      R6 -> WHERE DSN GOES FOR SVC99
*        MVC   0(6,R6),=C'BACKUP' START BACKED UP DSN WITH BACKUP.
         MVC   0(44,R6),JFCBDSNM  PUT DSN IN
*
         L     R6,=V(FIRSTDSN)    R6 -> WHERE DSN GETS SAVED
         MVC   0(44,R6),JFCBDSNM  PUT DSN IN
         CLI   JFCBVLSQ,X'00'     IS THERE A VOLSEQ IN JFCB?
         BE    NOVLSQ             NO, DON'T SAVE IT
         L     R5,=V(VOLSEQ)      R5 -> WHERE VOL SEQ NBR GOES
         MVC   0(2,R5),JFCBVLSQ   SAVE JFCB VOL SEQ NBR
         SPACE 1
NOVLSQ   DS    0H
         LH    R5,JFCBFLSQ        R5 = STARTING SEQ NBR
*        DC    H'0'                                           DEBUG
*        B     NOVLSQ2                               WHY???   DEBUG
         CH    R5,=H'1'           FILE SEQ NBR = 0?
         BL    NOVLSQ2            YES, DON'T SUBTRACT 1
         BCTR  R5,0               -1 FOR NEWALLOC SECTION
         SPACE 1
NOVLSQ2  DS    0H
         L     R6,=V(TUPAR7)      R6 -> WHERE SEQNBR GOES
         STH   R5,0(0,R6)         SAVE 1ST SEQ NBR FOR OPEN TYPE J
*
*              FIND LTH OF DSN START
*
         L     R6,=V(TUPAR1)      R6 -> TO DSN
         SR    R5,R5              R5 = 0
         CLC   0(4,R6),=C'NONE '  DSN=NONE ?
         BE    OUT9A              YES, MAKE SURE HLILTH = 0
         SPACE 1
LOOP1    DS    0H
         CLI   0(R6),C' '         AT END OF DSN ?
         BE    OUT1               YES, CHECK LTH
         LA    R6,1(0,R6)         ADD 1 DSN POSITION REG
         LA    R5,1(0,R5)         ADD 1 TO LTH CTR
         B     LOOP1              LOOK AT NEXT CHAR
         SPACE 1
OUT1     DS    0H
         CH    R5,=H'39'          DSN TOO LONG TO ADD TRAILER?
         BL    PUTDOT             NO, ADD PERIOD
         SPACE 1
LOOP1A   DS    0H                 YES, FIND PREVIOUS PERIOD
         BCTR  R6,0               SUBT 1 FROM DSN POSITION REG
         BCTR  R5,0               SUBT 1 FROM LTH CTR
         CLI   0(R6),C'.'         AT PREV PERIOD?
         BE    OUT1               YES, CHECK LTH
         MVI   0(R6),C' '         BLANK CHAR
         B     LOOP1A             LOOK AT NEXT CHAR
         SPACE 1
         SPACE 1
PUTDOT   DS    0H
         MVI   0(R6),C'.'         PUT THE PERIOD IN
         L     R7,=V(TULNG1)      R7 -> LTH SAVE AREA FOR SVC99
         STH   R5,0(0,R7)         SET UP LTH FIELD FOR FREE
         LA    R5,1(0,R5)         ADD 1 TO LTH CTR
         SPACE 1
OUT9A    DS    0H
         L     R7,=V(HLILTH)      R7 -> LTH SAVE AREA
         STH   R5,0(0,R7)         SET UP LTH FIELD OF HLI
         B     HBRETN             END FOR NOW
         SPACE 2
TIOEND   DS    0H
         OLCMSG   OLC020          SEND DD STATEMENT MISSING MSG     RH
         LA    R15,44             SET RC=44
         B     HBRETN2            ABEND FOR NOW
         SPACE 1
FAIL4    DS    0H
         OLCMSG   OLC060          SEND RDJFCB FAILED MSG            RH
         LA    R15,44             SET RC=44
         B     HBRETN2            ABEND FOR NOW
         SPACE 1
HBRETN   DS    0H
         SR    R15,R15            RC = 0
         SPACE 1
HBRETN2  SECEXIT                               RETURN TO CALLER
         SPACE 2
*
* HOLDBLKS DATA:
*
         SPACE 3
TRTAB    DC    C' 0123456789ABCDE '
         SPACE 2
         ENTRY FIRSTJFC
         DS    0F
         DC    C'FIRSTJFCB'                                         RH1
FIRSTJFC DC    XL176'00'
         SPACE 1
         DC    CL81' '
         ORG   *-81
OLC020   DS    0A
         DC    AL1(MSGPRT)
         DC    C'DSB020 - '
         DC    CL6'SYSUT2 DD STATEMENT MISSING '
         ORG   OLC020+75
         DC    CL5'ERROR'
         ORG   OLC020+81
         SPACE 1
         DC    CL81' '
         ORG   *-81
OLC060   DS    0A
         DC    AL1(MSGPRT)
         DC    C'DSB060 - '
OLC060A  DC    C'INITIAL READ OF JFCB FOR SYSUT2 FAILED'
         ORG   OLC060+75
         DC    CL5'ERROR'
         ORG   OLC060+81
         SPACE 2
 TITLE 'USRPROC - PROCESS THE FORMAT/PGM LIBRARY FOR A GIVEN USER'
USRPROC SECTION
*
* PROCESS THE LIBRARY NAME OBTAINED IN DETUSER SECTION
*
         PERFORM BUILDDSN,ERR=RETUPROC  GO BUILD THE USR LIB DSNAME
*
         MVI   FREEFLAG,X'00'     TURN FREE FLAG OFF
         L     R1,=V(PARMOLC)     R1 -> TO INPUT PARM
         CLC   =C'RESTORE',0(R1)  IS THIS A RESTORE?
         BNE   NOTREST2           NO
         L     R3,=V(RESTREC)     R3 -> TO RESTORE RECORD
         USING RESTRECD,R3        SET RECORD BASE
         CLC   RESTTYPE,=C'DA'    IS IT A DA FILE?
         BE    CANTREST           YES, WE CAN'T RESTORE IT
         PERFORM TAPALLOC,ERR=RETUPROC  GO DYNALLOC THE TAPE FILE
         CLC   RESTTYPE,=C'VS'    IS IT A VSAM FILE?
         BNE   PERFDYN            NO, GO ALLOCATE IT
         L     R1,=V(DYNTUNT4)    R1 -> TO VOLSER TEXT UNIT
         MVC   6(6,R1),RESTVOL    PUT IN THE CATALOG VOLSER
         SPACE 1
PERFDYN  DS    0H
         PERFORM DYNALLOC         GO DYNALLOC THE USER LIB
         LTR   R15,R15            WAS ALLOC OKAY?
         BZ    ALLOK2             YES, ON WE GO
         CH    R15,=H'99'         SHOULD WE CREATE THE DSN?
         BNE   RETUPROC           NO, END FOR NOW
         CLC   RESTTYPE,=C'VS'    IS IT A VSAM FILE?
         BE    ALLOK4             YES, SAY WE DIDN'T ALLOCATE IT
         SPACE 1
         L     R1,=V(DSNFLAG)     R1 -> TO ALLOCATE FLAG
         OI    0(R1),X'08'        SAY ALLOCATE NEW DATASET
         PERFORM GETDS,ERR=RETUPROC  GO CREATE THE USER LIB
*        LTR   R15,R15            DID WE ALLOC IT?
*        BNZ   NOALLOC            NO, TOO BAD
         L     R14,=V(TUPL2D)     PUT IT HERE
         ST    R15,0(0,R14)       CLEAR DCB TEXT UNIT ADDRESS
         B     ALLOK2             ON WE GO IF IT WORKED
         SPACE 1
NOTREST2 DS    0H
         PERFORM DYNALLOC,ERR=RETUPROC  GO DYNALLOC THE USER LIB
*
ALLOK2   DS    0H
         CLC   RESTTYPE,=C'VS'    IS IT A VSAM FILE?
         BE    ALLOK4             YES, SAY WE DIDN'T ALLOCATE IT
         DROP  R3                 DROP RECORD BASE
         OI    FREEFLAG,X'80'     SAY WE ALLOCATED THE DATASET
*
ALLOK4   DS    0H
         L     R14,=V(SYSDSORG)   R14 -> TO SYSUT1 DSORG
         CLC   0(2,R14),=X'0008'  IS IT VSAM?
         BE    DSORGOK            YES, ON WE GO
         TM    0(R14),X'02'       IS IT PO OR POU?
         BO    DSORGOK            YES, WE CAN HANDLE IT
         TM    0(R14),X'20'       IS IT DA OR DAU?
         BO    DSORGOK            YES, WE CAN HANDLE IT
         TM    0(R14),X'40'       IS IT PS OR PSU?
         BO    DSORGOK            YES, WE CAN HANDLE IT
         SPACE 1
BADDSORG DS    0H
*        L     R3,=V(USRDSN)      GET ADDRESS OF INPUT DSNAME
*        MVC   OLC100DS(44),0(R3) MOVE DSNAME TO ERROR TEXT
         OLCMSG OLC100            PRINT BAD DSORG MSG
         LA    R15,4              SET RC=4
         B     IGNORLIB           END FOR NOW
         SPACE 1
CANTREST DS    0H
         OLCMSG CANTMSG           SAY WE CAN'T RESTORE DA FILES
         OLCMSG OLC100            PRINT BAD DSORG MSG
         LA    R15,4              SET RC=4
         B     RETUPROC           END FOR NOW
         SPACE 1
DSORGOK  DS    0H
*
         PERFORM RACCHECK,ERR=IGNORLIB  CHECK AUTH TO ACCESS LIBRARY
*
         NI      RECOFLG,255-RECOYES    CLEAR RECOVERY IN PROGRESS FLAG
         PERFORM SYNCRECO               INIT THE RECOVERY REGS
         TM      RECOFLG,RECOYES        ARE WE IN RECOVERY MODE ?
         BO      IGNORLIB               IF SO, IGNORE THE CURRENT LIB
*
*        PERFORM ESTAEON                GO TURN RECOVERY TRAP ON
*
         L     R1,=V(PARMOLC)     R1 -> TO INPUT PARM
         CLC   =C'RESTORE',0(R1)  IS THIS A RESTORE?
         BE    NOEMPTY2           YES
         PERFORM EMPTYCHK,ERR=ESTAEOFF  GO CHECK IF LIB IS EMPTY
*
         PERFORM NEWALLOC,ERR=ESTAEOFF  GO FIX SYSUT2 JFCB
*
NOEMPTY2 DS    0H
         PERFORM COPYUSER,ERR=ESTAEOFF  GO COPY USR LIB TO HOLD
*
ESTAEOFF DS    0H
         LR    R4,R15             SAVE RC
*        PERFORM ESTAEOF                GO TURN ESTAE OFF
         LR    R15,R4             LOAD RC
*
IGNORLIB DS    0H
         AGO   .SKIPVS
         L     R1,=V(PARMOLC)     R1 -> TO INPUT PARM
         CLC   =C'RESTORE',0(R1)  IS THIS A RESTORE?
         BNE   IGNORLB1           NO
         L     R3,=V(RESTREC)     R3 -> TO RESTORE RECORD
         USING RESTRECD,R3        SET RECORD BASE
         CLC   RESTTYPE,=C'VS'    IS IT A VSAM FILE?
         BE    RETUPROC           YES, WE DIDN'T ALLOCATE IT
         DROP  R3                 DROP RECORD BASE
         SPACE 1
IGNORLB1 DS    0H
.SKIPVS  ANOP
         LR    R4,R15             SAVE RC OVER FREE
         PERFORM DYNFREE,ERR=RETUPROC  GO DYNFREE THE USER LIB
         LR    R15,R4             LOAD RC OVER FREE
*
RETUPROC SECEXIT                        RETURN TO CALLER
         ENTRY   RECOFLG
RECOFLG  DC      X'00'
RECOYES  EQU     1
         ENTRY FREEFLAG
FREEFLAG DC    X'00'              ALLOCATION FLAG
*        EQU   X'80'              DATASET WAS ALLOCATED
LASTDSN  EQU   X'40'              WRITE LAST DATASET ON TAPE
         SPACE 1
         DC    CL81' '
         ORG   *-81
OLC100   DS    0A
         DC    AL1(MSGPRT)
         DC    C'DSB100 - DATASET NOT COPIED. DSORG INVALID: '
         ORG   OLC100+75
         DC    CL5'ERROR'
         ORG   OLC100+81
         SPACE 1
CANTMSG  DC    CL81' '
         ORG   *-81
         DC    AL1(MSGPRT)
         DC    C'CANTMSG- DA FILES MUST BE RESTORED WITH A DA'
         DC    C' LOAD PROGRAM'
         ORG   OLC100+75
         DC    CL5'ERROR'
         ORG   OLC100+81
         SPACE 2
 TITLE 'ESTAEON - SET STAE ROUITNE'
*
* PROCESS THE LIBRARY FOR A GIVEN USER
*
* --------------------------------------------------------------------
         DS    0H
ESTAEON  SECTION
         L        R8,=V(STAEEXIT)     POINT AT THE ESTAE EXIT ROUTINE
         ESTAE    (R8),CT             PUT ON ESTAE
         LTR      R15,R15             WENT ON OK?
         BZ       ESEXIT              GO RETURN TO CALLER
         ABEND    1213,DUMP           TAKE A USER 1213 ABEND WITH DUMP
ESEXIT   SECEXIT                      RETURN TO CALLER
 TITLE 'SYNCRECO - RECOVERY POINT FROM AN ERROR DURING A COPY PROCESS'
         DS    0H
SYNCRECO SECTION
* --------------------------------------------------------------------
* THIS SECTION IS ENTERED IN TWO DIFFERENT WAYS:
*
*  IT IS ENTERED FROM THE USRPROC MAINLINE TO STORE STATUS, IE) TO
*    TAKE A SYNC POINT WHICH HERE MEANS TO SAVE ALL REGS.
*
*  IT IS ALSO ENTERED AFTER AN ERROR CONDITION TO RESYNCRONIZE
*    PROCESSING. IE) THE ESTAE EXIT ROUTINE JUMPS TO LABEL STAERTRY
*    DIRECTLY AFTER RESTORING ALL REGISTERS EXCEPT R7 TO WHAT THEY WERE
*    THE LAST TIME THIS SECTION WAS ENTERED NORMALLY.
* --------------------------------------------------------------------
         LA       R7,0                INIT R7 TO SAY NOT IN ABEND
         STM      R0,R15,SYNCSAVE     SAVE THE REGISTERS AS THEY ARE
         B        OVERSAVE
         ENTRY    SYNCSAVE
SYNCSAVE DC       16F'0'              THE RECOVERY SAVE AREA
OVERSAVE DS       0H
         ENTRY    STAERTRY
STAERTRY DS       0H                  THIS IS THE ESTAE RETRY LABEL
         LA    R15,0              RC=0
         LTR      R7,R7          TEST R7 TO SEE IF WE CAME FROM RETRY
         BZ       SYNCRECE       IF 0 THEN WE DID NOT COME FROM RETRY
*
* WE ARE IN RETRY, IE) THE ESTAE EXIT SENT US HERE
* WE KNOW BECAUSE IT SET R7 IN THE RUB TO NON-ZERO EG) X'FFFFABED'
*
* USE OLCMSG TO PUT OUT MSG TO USER THAT WE ARE SKIPPING HIS DATASET.
* ABEND CODE IS IN ABENDCDE BELOW, THE ADDRESS OF ABEND IS IN ABENDADR
*
* WE SET THE RECOVERY FLAG ON TO TELL MAINLINE TO SKIP THE DATASET
         L     R5,=V(RECOFLG)          GET ADDRESS OF RECOVERY FLG
         OI    0(R5),RECOYES           SET TO IN_RECOVERY
         UNPK  OLC019W(16),ABENDCDE(8) MAKE HEX RETURN CODE PRINTABLE
         TR    OLC019W(17),HEXTRANA
         MVC   OLC019IN(8),OLC019W+1   MOVE ADDRESS OF ABEND TO MSG
         MVC   OLC019ER(3),OLC019W+11  MOVE ABEND CODE TO MSG
         MVC   OLC019CS(8),ABENDCST    MOVE CSECT NAME TO MSG
         OLCMSG OLC019
SYNCRECE SECEXIT                      RETURN TO CALLER
         SPACE 1
OLC019   DC    CL81' '
         ORG   *-81
         DC    AL1(MSGPRT)
         DC    C'DSB019 - ABEND '
OLC019ER DC    CL3' ',C', OFF='
OLC019IN DC    CL8' ',C' IN CSECT '
OLC019CS DC    CL8' '
         DC    C' WHILE COPYING DATASET'
         ORG   OLC019+75
         DC    CL5'ERROR'
         ORG   OLC019+81
OLC019W  DC    XL17'00'
HEXTRANA EQU   *-240
         DC    C'0123456789ABCDEF'
         ENTRY ABENDCDE
         DS    0D
ABENDCDE DC    XL8'00'     ABEND CODE AND ADDRESS SET BY ESTAE EXIT
ABENDCST DC    CL8'??'     ABEND CSECT NAME..MUST FOLLOW ABENDCDE
 TITLE 'BUILDDSN - ISOLATE DSNAME FROM CONTROL CARD'
*
*  ISOLATE DSNAME FROM CONTROL CARD'
*
         DS    0H
BUILDDSN SECTION
*
*
*
*              FIND LTH OF DSN
*
         SR    R5,R5              R5 = 0
         LA    R6,USRDSN          R6 -> TO DSN
LOOP2    DS    0H
         CLI   0(R6),C' '         AT END OF DSN ?
         BE    OUT2               YES, MOVE IT TO SVC 99 FIELD
         LA    R6,1(0,R6)         ADD 1 DSN POSITION REG
         LA    R5,1(0,R5)         ADD 1 TO LTH CTR
         B     LOOP2              LOOK AT NEXT CHAR
         SPACE 1
OUT2     DS    0H
         CH    R5,=H'44'          LTH OVER 44?
         BH    BADCARD            YES
*
         CLI   USRDSN,C' '        FIRST CHAR A BLANK?
         BE    NODSNAME
         L     R2,=V(DYNT1LTH)    R2 -> DSNAME LTH FIELD
         STH   R5,0(0,R2)         STORE LENGTH FOR DYNALLOC
         LA    R2,USRDSN          R2 -> TO START OF DSNAME
         AR    R2,R5              R2 -> TO END OF DSNAME
         LH    R3,=H'44'          CALC LENGTH OF AREA TO BLANK
         SR    R3,R5              LENGTH OF REST OF DSN AREA
         BNP   NOCLEAR            NOTHING TO CLEAR
         BCTR  R3,0               -1 TO MAKE HEX
         BCTR  R3,0               -1 MORE JUST BECAUSE
         EX    R3,BUILDCLR        CLEAR OUT REST OF DSN AREA
         SPACE 1
NOCLEAR  DS    0H
         LA    R15,USRDSN         R15 -> TO DSN
         ST    R15,TCAMDSN        PUT A(DSN) INTO TCAM LIST
         L     R2,=V(DYNT1DSN)    R2 -> DSNAME FIELD
         MVC   0(44,R2),0(R15)    PUT DSN INTO DYNALLOC FIELD
         MVC   TVOL,=CL6' '       BLANK OUT TVOL
         LOCATE TCAML             FIND IT
         LTR   R0,R15             LOCATE OK?
         BZ    CHKMIG             YES, SEE IF MIGRATED
         L     R1,=V(PARMOLC)     R1 -> TO INPUT PARM
         CLC   =C'RESTORE',0(R1)  IS THIS A RESTORE?
         BNE   NOTCAT             NO, DON'T SAY CREATING...
         MVC   OLC043A,OLC043C    NO, SAY CREATING DATASET
         B     NOTCAT             THEY BETTER HAVE GIVEN A VOLSER
*
*              SEE IF DATASET IS MIGRATED
*
         SPACE 1
CHKMIG   DS    0H
         MVC   OLC043A,OLC043P    SAY PROCESSING DATASET
         CLC   =C'MIGRAT',TVOL    IS DSN MIGRATED?
         BNE   NOTMIG             NO
*
*              BEFORE WE CONTINUE, RECALL THE DATASET....
*
*        CLC   OLC008M,=CL40' RECALLING' BEEN HERE ALREADY?
*        BE    NOVOL2             YES, DON'T RECALL AGAIN....
*        MVC   OLC043M,=CL44' RECALLING DATASET FROM MIGRAT'
*        OLCMSG OLC043
*
*  GIVE ARCHRCAL ITS OWN SAVE AREA AND CHAIN IT TO THE SUPERV.
*  SAVE AREA. OTHERWISE, IT WILL DESTROY OUR IMS TYPE
*  SAVE AREA CHAIN
         ST      R13,HSMSA           OUR SAVE AREA POINTER
         LA      R13,HSMSAVE         GIVE IEBCOPY ITS OWN
         L       R5,=V(SAVE)         GET ADDR OF OUR SAVE AREA
         L       R6,4(,R5)           GET ADDR OF SUP'S SAVE AREA
         ST      R6,HSMSAVE+4        CHAIN SUP'S SAVEAREA TO IEBSAVE
         L     R3,=V(USRDSN)      GET ADDRESS OF DISK DSNAME
         ARCHRCAL DSN=(R3),WKAREA=HSMWORK,WAIT=YES
         L        R13,HSMSA          PLUG BACK INTO OUR SAVE AREA CHAIN
         MVI   OLC033F,X'01'      SAY WE RECALLED THE DSN...
         LTR   R15,R15            WAS RECALL SUCCESSFUL?
         BZ    NOCLEAR            YES, GO GET THE REAL VOLSER...
         SPACE 1
NOTMIG   DS    0H
         MVC   INKEY,USRDSN       PUT DSN INTO OBTAIN KEY
         OBTAIN INCAM             GET FORMAT 1
         LTR   R0,R15             OBTAIN OK?
         BZ    OBTNOK             YES
         L     R15,=V(SYSDSORG)   R15 -> TO DSORG FIELD
         MVC   0(2,R15),=X'0008'  ASSUME IT IS A VSAM DATASET
         B     NOTCAT             AS WE CAN'T DETERMINE DSORG
         SPACE 1
OBTNOK   DS    0H
         USING IECSDSL1,R2             ESTABLISH DSCB ADDRESSABILITY
         LA    R2,INDSCB               POINT TO DSCB
         CLI   DS1FMTID,C'1'           IS THIS A FORMAT 1 DSCB
         BNE   NOTCAT             NO, CAN'T DETERMINE DSORG
         SPACE 1
         L     R15,=V(SYSDSORG)   R15 -> TO DSORG FIELD
         MVC   0(2,R15),DS1DSORG  PUT DSORG INTO FIELD
         DROP  R2                 DROP DSCB BASE
         SPACE 1
NOTCAT   DS    0H
         MVC   OLC043M,USRDSN     MOVE DSN INTO MSG
         OLCMSG OLCBLNK           PRINT A BLANK LINE BEFORE OLC043
         TM    OLC033F,X'01'      DID WE RECALL THE DSN?
         BZ    NORCAL             NO, DON'T PRINT MESSAGE
         MVI   OLC033F,X'00'      CLEAR FLAG
         OLCMSG OLC033            SAY IT WAS RECALLED
         SPACE 1
NORCAL   DS    0H
         OLCMSG OLC043            PRT OUT THE DSN IN OLCPRINT AND WTL
         SR    R15,R15            NO ERRORS
         B     BUILDRET
         SPACE 1
BUILDCLR MVC   1(0,R2),0(R2)      CLEAR REST OF CARD
         SPACE 1
NODSNAME MVC   OLC002M,USRDSN     DISPLAY CARD IN ERROR
         OLCMSG OLC002
         B     BADRC1             INDICATE MINOR ERROR
         SPACE 1
BADCARD  DS    0H
         MVC   OLC003M,USRDSN     DISPLAY CARD IN ERROR
         OLCMSG OLC003
         SPACE 1
BADRC1   DS    0H
         LA    R15,4              INDICATE A MINOR ERROR
BUILDRET SECEXIT                  RETURN TO CALLER
         SPACE 2
*
* BUILDRET DATA:
*
         SPACE 2
HSMSA    DC       F'0'            SAVE OUR S.A. POINTER OVER ARCHRCAL
HSMSAVE  DC       18F'0'          SPECIAL SAVE AREA FOR ARCHRCAL
*
*        TCAM   LIST
TCAML    DS     0F
TCFLGS   DC     X'44000000'              TCAM ON DSN
TCAMDSN  DC     A(0)                     A(DSN)
         DC     A(0)                     VOL POINTER
         DC     A(TWORK)                 A(256 BYTE WORK AREA)
         DS    0D                 PUT ON DOUBLE WORD BOUNDARY
TWORK    DS     0CL256
VOLCNT   DC     H'0'                     VOL COUNT
DEVTYP   DC     XL4'00'                  DEVICE TYPE
         ENTRY TVOL
TVOL     DC     CL6' '                   FIRST VOL SER
         DC     CL244' '                 REST OF TCAML DATA
         DC     CL12' '                  REST OF TCAML DATA
         SPACE 2
HSMWORK  DS    0D                 PUT HSM WORAKAREA ON DOUBLE WORD
         DC    XL200'00'
*
* DSCB I/O AREA AND CONTROL BLOCKS
*
INDSCB   DS    0C
INKEY    DC    CL44' '
DSCBIN   DC    XL140'00'
         SPACE
INCAM    CAMLST SEARCH,INKEY,TVOL,DSCBIN
         SPACE 3
         DC    CL81' '
         ORG   *-81
OLC002   DS    0A
         DC    AL1(MSGPRT)
         DC    C'DSB002 - NO DSNAME ON CONTROL CARD: '
OLC002M  DC    CL44' '
         ORG   OLC002+75
         DC    CL5'ERROR'
         ORG   OLC002+81
         DC    CL81' '
         ORG   *-81
OLC003   DS    0A
         DC    AL1(MSGPRT)
         DC    C'DSB003 - INVALID CONTROL CARD:'
OLC003M  DC    CL44' '
         ORG   OLC003+75
         DC    CL5'ERROR'
         ORG   OLC003+81
*
OLC043   DC    AL1(MSGPRT)
         DC    C'DSB043 - '
OLC043A  DC    C'PROCESSING '
         DC    C'DATASET = '
OLC043M  DC    CL44' '
         DC    CL(81-(*-OLC043))' '
*
OLC043C  DC    C'CREATING   '
OLC043P  DC    C'PROCESSING '
*
OLC033F  DC    X'00'              01 IF RECALL DONE....
OLC033   DC    AL1(MSGPRT)
         DC    CL80'DSB033 - DATASET RECALLED FROM MIGRAT'
         ENTRY OLCBLNK
OLCBLNK  DC    AL1(MSGPRT)
         DC    CL81' '
         ENTRY USRDSN,USRVOL
USRDSN   DS    0CL200             BUFFER FOR INPUT/RESTORE CARD
         DC    CL44' '            DATASET NAME
         DC    C' '               BLANK
USRVOL   DC    CL6' '             DATASET VOLUME
         DC    CL(200-(*-USRDSN))' '
         SPACE 1
 TITLE 'DYNALLOC - DYNAMICALLY ALLOCATE A DATASET'
*
         DS    0H
DYNALLOC SECTION
*
         LA    R2,DYNRB1          R2 -> TO SVC 99 PARMS
         USING S99RB,R2           SET BASE
         XC    S99RSC,S99RSC      CLEAR OUT RETURN AREA
         SR    R1,R1              CLEAR R1
         ST    R1,DYNTUPLB        ASSUME NO VOLSER
         MVC   DYNTVOL6(6),BLANK  CLEAR VOLSER FIELD
         MVC   DYNTVOL4(6),BLANK  CLEAR RETURNED VOLSER FIELD
         L     R1,=V(PARMOLC)     R1 -> TO INPUT PARM
         CLC   =C'RESTORE',0(R1)  IS THIS A RESTORE?
         BE    RSTOR2             YES, DON'T USE A VOL
         L     R14,=V(SYSDSORG)   R14 -> TO SYSUT1 DSORG
         CLC   0(2,R14),=X'0008'  IS IT VSAM?
         BE    NOVOL0             YES, DON'T USE A VOL
         L     R3,=V(TVOL)        GET ADDRESS OF LOCATE VOLSER
         MVC   DYNTVOL6(6),0(R3)  PUT IT IN TEXT UNIT
         B     NOVOL0             ON WE GO
         SPACE 1
RSTOR2   DS    0H
         MVI   SYSNUM,C'2'        CHANGE SYSUT TO 2
         SPACE 1
NOVOL0   DS    0H
         MVC   OLC006M(ALOCVOLL),BLANK CLEAR VOL MSG
         CLI   DYNTVOL6,C' '      IS THERE A VOLSER?
         BE    NOVOL1             NO
         LA    R1,DYNTUNT6        YES, SET TEXT UNIT ADDRESS
         ST    R1,DYNTUPLB        SAVE ADDRESS
         MVC   ALOCVOL,DYNTVOL6   PUT VOLSER INTO MSG
         MVC   OLC006M(ALOCVOLL),ALOCVOLM ''
         SPACE 1
NOVOL1   DS    0H
         LA    R1,DYNPTR1            POINTER TO PARM LIST FOR DYNALLOC
         DYNALLOC
         LTR   R10,R15               SAVE RET CODE OVER MSG PRINT
         BZ    DYNARET               RETURN IF NO ERRORS
         DC    X'0700'            ZAP TO ABEND
         CLI   DYNTVOL4,C' '      DID DYNALLOC GET A VOLSER?
         BE    NOVOL2             NO
         MVC   ALOCVOL,DYNTVOL4   PUT VOLSER INTO MSG
         MVC   OLC006M(ALOCVOLL),ALOCVOLM ''
         SPACE 1
NOVOL2   DS    0H
         OLCMSG OLC006
         UNPK  OLC007W(9),S99RSC(5)  MAKE HEX RETURN CODE PRINTABLE
         TR    OLC007W(8),HEXTRANS
         MVC   OLC007ER(4),OLC007W   MOVE ERROR CODE TO TEXT LINE
         MVC   OLC007IN(4),OLC007W+4 MOVE INFO CODE TO TEXT LINE
         OLCMSG OLC007
         CLC   S99ERROR,=X'020C'     DS UNAVAILBLE FOR DISP=SHR
         BE    DISPOLD
         CLC   S99ERROR,=X'0210'     DS UNAVAILBLE FOR DISP=SHR
         BE    DISPOLD
         CLC   S99ERROR,=X'0218'     VOLUME NOT MOUNTED
         BE    NOVOL
         CLC   S99ERROR,=X'0220'     VOLUME NOT MOUNTED
         BE    NOVOL
         CLC   S99ERROR,=X'1708'     DS NOT FOUND
         BE    CHKRSTOR              YES
         CLC   S99ERROR,=X'6708'     DS NOT FOUND ON CAT VOL
         BNE   DYNRETRC           NO, JUST SET RETURN CODE
         SPACE 1
CHKRSTOR DS    0H
         L     R1,=V(PARMOLC)     R1 -> TO INPUT PARM
         CLC   =C'RESTORE',0(R1)  IS THIS A RESTORE?
         BNE   NOTFOUND           NO, SAY NOT FOUND
         LA    R10,99             SAY WE MUST TRY A CREATE ALLOC
         B     DYNRETRC           RETURN TO CALLER
         SPACE 1
NOTFOUND MVC   OLC008M,=CL40' DATASET DOES NOT EXIST'
         B     PRTOLC8
         SPACE 1
DISPOLD  MVC   OLC008M,=CL40' DATASET ALLOCATED TO SOME OTHER JOB'
         B     PRTOLC8
         SPACE 1
NOVOL    MVC   OLC008M,=CL40' DATASET ON AN OFFLINE VOLUME'
         SPACE 1
PRTOLC8  OLCMSG OLC008
         SPACE 1
DYNRETRC LR    R15,R10               RESTORE RETURN CODE
         SPACE 1
DYNARET  SECEXIT
         SPACE 2
*
* DYNALLOC  DATA:
*
         ENTRY BLANK
BLANK    DC    CL80'  '
         SPACE 1                                                    RH
OLC008   DC    CL81' '
         ORG   *-81
         DC    AL1(MSGPRT)
         DC    C'DSB008 - PROBABLE CAUSE: '
OLC008M  DC    CL40' '
         ORG   OLC008+75
         DC    CL5'ERROR'
         ORG   OLC008+81
         ENTRY OLC007,OLC007ER,OLC007IN,OLC007W,HEXTRANS
OLC007   DC    CL81' '
         ORG   *-81
         DC    AL1(MSGPRT)
         DC    C'DSB007 - ERROR REASON CODE: '
OLC007ER DC    CL4' ',C'   INFORMATION REASON CODE: '
OLC007IN DC    CL4' ',CL5' '
         ORG   OLC008+75
         DC    CL5'ERROR'
         ORG   OLC007+81
OLC007W  DC    XL9'00'
HEXTRANS EQU   *-240
         DC    C'0123456789ABCDEF'
OLC006   DC    CL81' '
         ORG   *-81
         DC    AL1(MSGPRT)
         DC    C'DSB006 - ALLOCATE FAILED FOR DSN '
OLC006M  DC    C' '               VOLSER IF VOL SER SPECIFIED
*LC006M  DC    CL40' '            ONLY USE 1ST 40 BYTES OF DSN
         ORG   OLC006+75
         DC    CL5'ERROR'
         ORG   OLC006+81
         SPACE 1
ALOCVOLM DC    C' ON VOLUME '
ALOCVOL  DC    CL6' '
ALOCVOLL EQU   *-ALOCVOLM
         SPACE 2
         AGO   .DYN1
         DS    0F                 PUT ON FULLWORD BOUNDARY
DYNPTR1  DC    0F'0',X'80',AL3(DYNRB1)
DYNRB1   DC    0F'0',AL1(20,S99VRBAL,S99NOMNT,0),AL4(0,DYNTUPLA,0,0)
DYNTUPLA DC    AL4(DYNTUNT1,DYNTUNT2,DYNTUNT3),AL4(DYNTUNT4)
DYNTUPLB DC    A(DYNTUNT6)
         DC    X'80',AL3(DYNTUNT5)
*YNTUNT1 DC    0F'0',AL2(DALDSNAM,1,0) DYNAMIC ALLOCATION TEXT FIELD
         DS    0F                 PUT ON FULLWORD BOUNDARY
DYNTUNT2 DC    AL2(DALSTATS,1,1),X'08'  DISP=SHR
         DS    0F                 PUT ON FULLWORD BOUNDARY
DYNTUNT3 DC    AL2(DALDDNAM,1,6),C'SYSUT'
SYSNUM   DC    C'1'
         ENTRY DYNTUNT4
         DS    0F                 PUT ON FULLWORD BOUNDARY
DYNTUNT4 DC    AL2(DALRTVOL,1,6),C'      '    RETURNED VOLSER
DYNTVOL4 EQU   DYNTUNT4+6
         DS    0F                 PUT ON FULLWORD BOUNDARY
DYNTUNT5 DC    AL2(DALRTORG,1,2),AL2(0)
         ENTRY SYSDSORG
SYSDSORG EQU   DYNTUNT5+6
         DS    0F                 PUT ON FULLWORD BOUNDARY
DYNTUNT6 DC    AL2(DALVLSER,1,6),CL6' ' VOLSER UNIT,VOLSER
DYNTVOL6 EQU   DYNTUNT6+6
.DYN1    ANOP
*
*              CONTROL BLOCKS FOR  SVC 99 (DYNALLOC)
*
         SPACE 1
         DS    0F                 PUT ON FULLWORD BOUNDARY
DYNPTR1  DC    XL1'80'
         DC    AL3(DYNRB1)
DYNRB1   DS    0F
DYNRBLN  DC    AL1(20)
DYNVERB  DC    AL1(1)             ALLOCATE BY DSNAME
DYNFLAG1 DC    XL2'2000'          DON'T MOUNT VOLS OR CONSIDER OFFLINES
DYNERROR DC    AL2(0)
DYNINFO  DC    AL2(0)
DYNTXTPP DC    A(DYNTUPLA)
DYNRES1  DC    A(0)
DYNFLAG2 DC    A(0)
         SPACE 1
DYNTUPLA DS    0F
         DC    A(DYNTUNT1)        DSNAME
         DC    A(DYNTUNT2)        DISP
         DC    A(DYNTUNT3)        DDNAME
         DC    A(DYNTUNT4)        RETURNED VOLSER
         SPACE 1
DYNTUPLB DC    A(DYNTUNT6)        VOLSER UNIT
         DC    XL1'80'            END OF PARMS FOR DYNALLOC
         DC    AL3(DYNTUNT5)      DSORG
         SPACE 1
*
         ENTRY DYNTUNT1,DYNT1LTH,DYNT1DSN
DYNTUNT1 DS    0F
         DC    AL2(2)             ALLOCATE BY DSNAME
         DC    AL2(1)
         DS    0C
DYNT1LTH DC    AL2(00)            LTH OF DSNAME
DYNT1DSN DC    CL44' '            REQUEST QUEUE DSNAME
         SPACE 1
DYNTUNT2 DS    0F
TUKEY62  DC    XL2'0004'          STATUS OF UNIT
TUNUM62  DC    AL2(1)
TUENT62  DS    0C
TULNG62  DC    AL2(1)             LTH OF STATUS
TUPAR62  DC    X'08'              STATUS = SHR
*        DC    X'02'              STATUS = MOD
*        DC    X'04'              STATUS = NEW
*        DC    X'01'              STATUS = OLD
         SPACE 1
DYNTUNT3 DS    0F
TUKEY23  DC    AL2(DALDDNAM)      ALLOCATE BY DDNAME (1)
TUNUM23  DC    AL2(1)
TUENT23  DS    0C
TULNG23  DC    AL2(6)             LTH OF DDNAME
TUPAR23  DC    CL5'SYSUT'         DDNAME
SYSNUM   DC    CL1'1'
         DC    CL2' '             MAKE DDNAME 8 LONG...
         SPACE 1
         ENTRY DYNTUNT4
         DS    0F                 PUT ON FULLWORD BOUNDARY
DYNTUNT4 DS    0F
         DC    AL2(DALRTVOL)      SAY RETURN VOLSER
         DC    AL2(1)
DYNTVL4L DC    AL2(6)             LTH OF RETURNED VOLSER
DYNTVOL4 DC    CL6' '             VOLSER RETURNED
         SPACE 1
         DS    0F                 PUT ON FULLWORD BOUNDARY
DYNTUNT5 DC    AL2(DALRTORG,1,2),AL2(0)
         ENTRY SYSDSORG
SYSDSORG EQU   DYNTUNT5+6
*
         DS    0F                 PUT ON FULLWORD BOUNDARY
*                                 VOLSER UNIT,VOLSER
DYNTUNT6 DS    0F
         DC    AL2(DALVLSER)      SAY UNIT ID
         DC    AL2(1)
DYNTVL6L DC    AL2(6)             LTH OF UNIT
DYNTVOL6 DC    CL6' '             UNIT NAME ?
         SPACE 1
TUNIT77  DS    0C
TUKEY77  DC    XL2'0005'          STATUS 2..DISP=(OLD,KEEP)
TUNUM77  DC    AL2(1)
TUENT77  DS    0C
TULNG77  DC    AL2(1)             LTH OF STATUS 2
TUPAR77  DC    X'08'              DISP= KEEP
         SPACE 1
.DYN2    ANOP
         SPACE 2
 TITLE 'EXPALLOC - ALLOCATE FIRST OUTPUT DATASET WITH EXPDT'
*                  USING DSNAME FROM JCL
*
         DS    0H
EXPALLOC SECTION
*
*
*              FIND LTH OF DSN
*
         SPACE 1
LTHLOOPE DS    0H
         SR    R5,R5              R5 = 0
         L     R6,=V(FIRSTDSN)    R6 -> WHERE DSN GETS SAVED
         MVC   INFO03M,0(R6)      PUT IT IN MSG
         SPACE 1
LOOP3E   DS    0H
         CLI   0(R6),C' '         AT END OF DSN ?
         BE    OUT3E              YES, MOVE IT TO SVC 99 FIELD
         LA    R6,1(0,R6)         ADD 1 DSN POSITION REG
         LA    R5,1(0,R5)         ADD 1 TO LTH CTR
         B     LOOP3E             LOOK AT NEXT CHAR
         SPACE 1
OUT3E    DS    0H
         L     R6,=V(TULNG1)      R6 -> TO SVC99 FIELD
         STH   R5,0(0,R6)         SET UP LTH FIELD FOR SVC99
*
*              ADD 1 TO SEQ NBR
*
         L     R6,=V(TUPAR7)      R6 -> TO SVC99 FIELD
         LH    R5,0(0,R6)         R5 = SEQ NBR
         LA    R5,1(0,R5)         R5 = NEXT SEQ NBR
         STH   R5,0(0,R6)         SAVE NEXT SEQ NBR
*
*              MODIFY THE DCB
*
*
*        COPY SYSUT2 DCB/JFCB INFO
*
*                                 NO, TREAT AS PS
*
         SPACE 1
         L     R4,=V(SYSUT2)      R4 -> TO SYSUT2 DCB
         USING IHADCB,R4          SET DCB DSECT
         MVC   DCBBLKSI,=H'800'   SET SYSUT2 BLKSIZE TO 800
         SPACE 1
BLKSIOKE DS    0H
         MVC   DCBLRECL,=H'80'    SYSUT2 LRECL = 80
         SPACE 1
LRECOKE  DS    0H
         MVC   DCBRECFM,=X'90'    SET SYSUT2 RECFM TO FB
         MVI   DCBDSORG,X'40'     SET SYSUT2 DSORG TO PS
         DROP  R4
*                                                                   RH1
         SPACE 1
DCBSETE  DS    0H
*
*              MODIFY THE JFCB
*
         L     R2,=V(UT2JFCB)     R2 -> TO SYSUT2 JCFB              RH
         USING IHAJFCB,R2
*
*        MVC   JFCBDSNM,TUPAR1    PUT DSN IN
*        MVC   JFCBFLSQ,TUPAR7    PUT NEW SEQ NBR IN
*        MVC   JFCBVLSQ,VOLSEQ    PUT VOLUME SEQUENCE NBR IN
         MVI   JFCBIND2,X'C0'     PUT DISP=NEW IN
*
         AGO   .CAT1
*
*              THIS DOESN'T WORK. ..OCT 1/98...
*
         L     R6,=V(FREEFLAG)    R6 -> TO FREEFLAG
         TM    0(R6),LASTDSN      WRITING LAST FILE?
         BO    OUT3E2             YES, JFCB DSN IS OKAY
         L     R6,=V(TULNG1)      R6 -> TO SVC99 FIELD
         LH    R5,0(0,R6)         R5 = 1ST DSN LTH
         LA    R1,JFCBDSNM        R1 -> AT JFCB DSNAME
         AR    R1,R5              R1 -> AT END OF NAME
         MVC   0(5,R1),=CL5'.F001'
         LA    R5,5(0,R5)         ADD 5 TO LTH CTR
         STH   R5,0(0,R6)         SET UP LTH FIELD FOR SVC99
         SPACE 1
OUT3E2   DS    0H
         L     R6,=V(FREEFLAG)    R6 -> TO FREEFLAG
         TM    0(R6),LASTDSN      WRITING LAST FILE?
         BZ    JFCSETE            NO, JFCB DSN IS OKAY
         L     R6,=V(FIRSTDSN)    R6 -> WHERE 1ST DSN WAS SAVED
         MVC   JFCBDSNM,0(R6)     PUT IT IN JFCB
*        MVC   JFCBDSNM,INFO03M   PUT DSN IN
         L     R6,=V(TUPAR7)      R6 -> TO SVC99 FIELD
         LH    R5,0(0,R6)         R5 = SEQ NBR
         STH   R5,JFCBFLSQ        PUT NEW SEQ NBR IN
         MVI   JFCBIND2,X'80'     PUT DISP=MOD IN
*
JFCSETE  DS    0H
.CAT1    ANOP
*
*              ALSO PUT BLKSIZE, LRECL AND RECFM IN JFCB
*
         L     R4,=V(SYSUT2)      R4 -> TO SYSUT2 DCB
         USING IHADCB,R4          SET DCB DSECT
         MVC   JFCBLKSI,DCBBLKSI  SET JFCB BLKSIZE
         MVC   JFCLRECL,DCBLRECL  SET JFCB LRECL
         MVC   JFCRECFM,DCBRECFM  SET JFCB RECFM
         DROP  R4
         AGO   .CAT2
*                                                                   RH
*                  THIS IS CODE TO DUMP CORE                 DEBUG  RH
*                                                                   RH
         L     R2,=V(DEBUG)     IS DEBUG IN EFFECT
         USING IHADCB,R2
         TM    DCBOFLGS,DCBOFOPN  DID IT OPEN ?
         BZ    OPENINE            NO
         DROP  R2                 DROP BASE...
         SPACE 1                                             DEBUG  RH
         PRINT   GEN
         L     R2,=V(SYSUT2)      R2 -> TO SYSUT2 DCB        DEBUG  RH
         HDUMP OUTDCB,R4,100,NOTOPEN,OPEN,V=YES,             DEBUG  RH +
               TITLE='SYSUT2 DCB AT EXPALLOC',GENDCB=NO
         L     R2,=V(UT2JFCB)     R2 -> TO SYSUT2 JCFB       DEBUG  RH
         HDUMP OUTDCB,R2,200,OPEN,OPEN,                      DEBUG  RH +
               TITLE='SYSUT2 JFCB AT EXPALLOC'
         HDUMP OUTDCB,0,0,OPEN,CLOSE,  DUMP REGS ONLY        DEBUG  RH +
               TITLE='REGS AT EXPALLOC'
         SPACE 1                                             DEBUG  RH
         PRINT NOGEN
*                                                                   RH
*                  THIS IS END OF CODE TO DUMP CORE          DEBUG  RH
*                                                                   RH
         SPACE 1
OPENINE  DS    0H                                                   RH
.CAT2    ANOP
         SPACE 1
         OPEN  ((4),(OUTPUT)),TYPE=J   OPEN IT
         L     R1,=V(SYSUT2)      R1 -> TO DCB
         USING IHADCB,R1
         TM    DCBOFLGS,DCBOFOPN            DID IT OPEN ?
         BZ    FAIL8E             NO, GO TO ERR RTN
*
*              IN CASE WE SWITCHED TO ANOTHER UNIT, CHAIN THRU THE
*              DEB TO THE UCB AND  SAVE THE UNIT NAME
*
         L     R4,DCBDEBAD        R4 -> TO THE DEB
         LA    R4,0(0,R4)         CLEAR FLAG BYTE
         USING DEBBASIC,R4        SET DEB BASE
         L     R4,DEBSUCBA        R4 -> TO THE DEB UCB
         LA    R4,0(0,R4)         CLEAR FLAG BYTE
         DROP  R4                 DROP DEB BASE
         USING UCBOB,R4           SET UCB BASE
         L     R6,=V(TUPAR6)      R6 -> TO SVC99 FIELD
*        MVC   0(3,R6),UCBNAME    SAVE THIS UNIT ADDRESS
*
*   THE ONLY PROBLEM IS THAT THE ABOVE CODE DOESN'T WORK FOR
*   4 DIGIT UCB ADDRESSES, AS THE UCBNAME FIELD CONTAINS 'UCB'.
*   SO WE MUST CONVERT THE REAL UCB ADDRESS FROM THE HEX ADDRESS
*   AT OFFSET +4 IN THE UCB...FEB 10/99
*
*
*   ALSO, IF YOU ARE ALLOCATING BY UNIT, IT MUST BE PRECEDED BY /   RH
*              ..EG../190A.....
*
*              CONVERT UCB ADDRESS FOR UNIT NAME
*
         UNPK  0(5,R6),4(3,R4)    UNPACK 4 DIGIT UNIT ADDRESS
         MVI   4(R6),X'EF'        TRANSLATES TO BLANK
         TR    0(5,R6),TRTAB2-239 TRANSLATE TO DISPLAY
         MVC   5(3,R6),=CL5' '    BLANK OUT REST OF UNIT NAME
*
         DROP  R1,R4
*
         L     R4,=V(SYSUT2)      R4 -> TO SYSUT2 DCB
         PUT   (R4),DUMMYREC      WRITE RECORD
*
CLOSFIL  DS    0H
*        L     R4,=V(SYSUT2)      R4 -> TO SYSUT2 DCB
         CLOSE ((4))              CLOSE IT                          RH
         USING IHADCB,R4          SET R4 AS DCB DSECT
         L     R15,DCBBUFCB       R15 = A(BUFFER)
         BCTR  R15,0              -1
         LTR   R15,R15            IS THERE A BUFFER?
         BZ    NOPOOL4E           NO
         DROP  R4                 DROP R4 AS DCB DSECT
         FREEPOOL ((4))           FREE BUFFER POOL BECAUSE DUMB
*                                 IBM DON'T
         SPACE
NOPOOL4E DS    0H
*        L     R2,=V(FREEFLAG)    R2 -> TO FREEFLAG
*        TM    0(R2),LASTDSN      WRITING LAST FILE?
*        BO    EXPARET            YES, END OF EXPALLOC
*
*              MODIFY THE JFCB AGAIN. IF THERE IS NO VOLSER,
*              READ IT AGAIN INTO  A DIFFERENT AREA AND SAVE THE
*              VOLSER IN THE FIRST JFCB.
*
*        LA    R2,UT2JFCB         R2 -> TO SYSUT2 JCFB              RH
         USING IHAJFCB,R2         SET JFCB BASE AGAIN
         CLI   JFCBVOLS,C' '      IS THERE A VOLSER?
         BE    BADVOLE            NO, DO RDJFCB AGAIN
         CLI   JFCBVOLS,C'A'      IS IT ALPHANUMERIC?
         BL    BADVOLE            NO, DO RDJFCB AGAIN
         CLI   JFCBVOLS,C'9'      IS IT ALPHANUMERIC?
         BNH   JFCBOKE            YES, DON'T GET JFCB AGAIN
         SPACE 1
BADVOLE  DS    0H
         L     R4,=V(UT2JFCB2)    R4 -> TO JFCB AREA 2
         L     R15,=V(JFCBXLSJ)   R15 -> TO JFCB EXIT LIST
         STCM  R4,7,0(R15)        PUT IT IN EXIT LIST
*        XC    0(176,R4),0(R4)    MAKE SURE JFCB IS CLEAN
         RDJFCB SYSUT2            GET THE SYSUT2 JFCB               RH
         L     R2,=V(UT2JFCB)     R1 -> TO JFCB AREA
         L     R1,=V(JFCBXLSJ)    R15 -> TO JFCB EXIT LIST
         STCM  R2,7,0(R1)         PUT IT IN EXIT LIST
         LTR   R15,R15            GET IT?                           RH
         BNZ   FAIL6E             IF NOT  NO BLKSIZE                RH
         MVC   JFCBVOLS,JFCBVOLS-IHAJFCB(R4) PUT VOLSER IN JFCB 1
         CLI   JFCBVOLS,C' '      IS THERE A VOLSER?
         BE    UT2ABENE           NO, ABEND
         SPACE 1
JFCBOKE  DS    0H
         MVC   INFO04B,JFCBVOLS   PUT VOLSER IN MSG
         L     R3,=V(OLCBLNK)     R3 -> TO BLANKS
         OLCMSG 0(0,R3)           PRINT A BLANK LINE
         OLCMSG   INFO01          PRINT MSG
         OLCMSG   INFO02          PRINT MSG
         OLCMSG   INFO03          PRINT MSG
         OLCMSG   INFO04          PRINT MSG
         AGO   .ESKIP1
*
*              IF WE ARE PAST THE  1ST FILE, WE MUST OPEN THE FILE
*              AGAIN WITH DISP=MOD SO PDSFAST ETC. CAN 'ADD TO IT'
*
         CH    R5,=H'1'           PAST 1ST FILE?
         BH    OPEN2AE            YES, ON WE GO
         MVC   JFCBXPDT,SAVEXPDT  SET  JFCB EXPIRY DATE
         B     OPEN4E             END FOR NOW
         SPACE 1
OPEN2AE  DS    0H
         MVI   JFCBIND2,X'80'     PUT DISP=MOD IN
         DROP  R2
         SPACE 1
OPEN2E   DS    0H
         OPEN  (SYSUT2,(OUTPUT)),TYPE=J   OPEN IT
         LA    R1,SYSUT2          R1 -> TO DCB
         USING    IHADCB,R1
         TM       DCBOFLGS,DCBOFOPN            DID IT OPEN ?
         BZ    FAIL8E             NO, GO TO ERR RTN
         DROP     R1
         CLOSE (SYSUT2)           CLOSE IT                          RH
         LA    R4,SYSUT2          R4 -> TO SYSUT2 DCB
         USING IHADCB,R4          SET R4 AS DCB DSECT
         L     R15,DCBBUFCB       R15 = A(BUFFER)
         BCTR  R15,0              -1
         LTR   R15,R15            IS THERE A BUFFER?
         BZ    NOPOOL5            NO
         DROP  R4                 DROP R4 AS DCB DSECT
         FREEPOOL ((4))           FREE BUFFER POOL BECAUSE DUMB
*                                 IBM DON'T
         SPACE
NOPOOL5E DS    0H
.ESKIP1  ANOP
         SPACE 1
OPEN4E   DS    0H
         SR    R15,R15            R15 = 0
         B     EXPARET            END FOR NOW
         SPACE 1
FAIL5E   DS    0H
*        OLCMSG   OLC022          PRINT ERROR MSG
         LA    R15,48             SET RC=40
         B     EXPARET            END FOR NOW
         SPACE 1                                                    RH1
FAIL6E   DS    0H
*        OLCMSG   OLC023          PRINT ERROR MSG
         LA    R15,48             SET RC=40
         B     EXPARET            END FOR NOW
         SPACE 1                                                    RH1
FAIL7E   DS    0H
*        OLCMSG   OLC024          PRINT ERROR MSG
         LA    R15,48             SET RC=40
         B     EXPARET            END FOR NOW
         SPACE 1                                                    RH1
FAIL8E   DS    0H
*        OLCMSG   OLC027          PRINT ERROR MSG
         DC    H'0'               ABEND FOR NOW
         LA    R15,48             SET RC=40
         B     EXPARET            END FOR NOW
         SPACE 1
UT2ABENE DS    0H
*        OLCMSG NEW006
*        DC    H'0'               0C1 FOR NOW
         LA    R15,16             R15 = 16
*        B     EXPARET            END FOR NOW
         SPACE 1
EXPARET  SECEXIT
         DROP  R2
         SPACE 2
*
* EXPALLOC  DATA:
*
         SPACE 3
TRTAB2   DC    C' 0123456789ABCDE '
         SPACE 2
DUMMYREC DC    CL80'DUMMY RECORD FOR EXPIRY DATE FILE'
*
INFO01   DC    AL1(MSGPRT)
         DC    C'INFO01 - FILE 1 IS USED FOR SYSTEM INFORMATION'
         DC    C' LIKE CATALOG NAME,'
         DC    CL(81-(*-INFO01))'  '
*
INFO02   DC    AL1(MSGPRT)
         DC    C'INFO02 -        EXPIRY DATE, OR GDG NAME'
         DC    CL(81-(*-INFO02))'  '
*
INFO03   DC    AL1(MSGPRT)
         DC    C'INFO03 - PROCESSING DATASET = '
INFO03M  DC    CL44' '
         DC    CL(81-(*-INFO03))'  '
*
INFO04   DS    0CL81' '
         DC    AL1(MSGPRT)
         DC    C'INFO04 - ABOVE '
INFO04A  DC    CL2'PS'            DEFAULT FILE TYPE IS PO
         DC    C' DATASET CREATED IN FILE '
INFO04F  DC    CL4'0001'
         DC    C' ON TAPE '
INFO04B  DC    CL6' '             TAPE VOLSER GOES HERE
         DC    CL(81-(*-INFO04))'  '
*
         SPACE 2
 TITLE 'NEWALLOC - ALLOCATE OUTPUT DATASET WITH JFCB MODS'
*
         DS    0H
NEWALLOC SECTION GEN=
*
         LH    R14,TUPAR7         R14 = FILE NBR
         LA    R14,1(0,R14)       R15 = NEXT SEQ NBR
         CVD   R14,DWORDE         CONVERT TO DECIMAL
         UNPK  DWORDE(5),DWORDE+5(3) CONVERT TO DISPLAY
         MVZ   DWORDE+4(1),DWORDE FIX SIGN
         MVC   ENDDSNN(3),DWORDE+2 MOVE FILE NBR TO ENDDSN...
         LA    R3,ENDDSN          GET ADDRESS OF DISK DSNAME
         LA    R6,4               R6 = LTH OF DSN ENDING
         B     LTHOKAY2           DSN IS OKAY
*
*
         L     R3,=V(USRDSN)      GET ADDRESS OF DISK DSNAME
         L     R6,=V(DYNTUNT1)    R6 -> TO LTH TEXT UNIT
         LH    R6,4(0,R6)         R6 = LTH INPUT DSN
         AH    R6,HLILTH          R6 = LTH INPUT DSN + HLILTH
         CH    R6,=H'44'          OVER MAX OF 44?
         BNH   LTHOKAY            NO, DSN IS OKAY
         LA    R6,44              R6 = MAX DSN LTH
         SH    R6,HLILTH          R6 = LTH INPUT DSN TO USE
         LA    R3,44(0,R3)        R3 -> TO END INPUT DSN
         SR    R3,R6              R3 -> TO START OF DSN TO USE
         SPACE 1
CHKALPHA DS    0H                 FIND 1ST ALPHA CHAR
         CLI   0(R3),C'0'         IS CHAR NUMERIC?
         BL    CHKDOT             NO, CHECK FOR A DOT
         LA    R3,1(0,R3)         R3 -> TO NEXT INPUT DSN CHAR
         BCT   R6,CHKALPHA        GO SEE IF ALPHA
         SPACE 1
CHKDOT   DS    0H
         CLI   0(R3),C'.'         IS CHAR A PERIOD ?
         BNE   LTHOKAY2           NO, DSN IS OKAY
         LA    R3,1(0,R3)         R3 -> TO NEXT INPUT DSN CHAR
         BCTR  R6,0               R6 = LTH OF DSN LEFT
         B     LTHOKAY2           DSN IS OKAY
         SPACE 1
LTHOKAY  DS    0H
         LA    R6,44              R6 = MAX DSN LTH
         SH    R6,HLILTH          R6 = MAX LTH - HLI LTH
         SPACE 1
LTHOKAY2 DS    0H
         LA    R5,TUPAR1          R5 -> TO SVC99 DSN
         AH    R5,HLILTH          R5 -> TO WHERE REST OF DSN GOES
         BCTR  R6,0               R6 = HEX LTH
         STC   R6,NEWMVC+1        SET MVC LTH
NEWMVC   MVC   0(0,R5),0(R3)      PUT DSNAME BESIDE HLI.
*
*              FIND LTH OF DSN
*
         SPACE 1
LTHLOOP  DS    0H
         SR    R5,R5              R5 = 0
         LA    R6,TUPAR1          R6 -> TO DSN
         SPACE 1
LOOP3    DS    0H
         CLI   0(R6),C' '         AT END OF DSN ?
         BE    OUT3               YES, MOVE IT TO SVC 99 FIELD
         LA    R6,1(0,R6)         ADD 1 DSN POSITION REG
         LA    R5,1(0,R5)         ADD 1 TO LTH CTR
         B     LOOP3              LOOK AT NEXT CHAR
         SPACE 1
MVCDSN   MVC   TUPAR1(0),0(R1)    MVC DSN TO S99 BLOCK
         SPACE 1
OUT3     DS    0H
         STH   R5,TULNG1          SET UP LTH FIELD FOR SVC99
*
*              ADD 1 TO SEQ NBR
*
         LH    R5,TUPAR7          R5 = SEQ NBR
         LA    R5,1(0,R5)         R5 = NEXT SEQ NBR
         STH   R5,TUPAR7          SAVE NEXT SEQ NBR
*
*              MODIFY THE JFCB
*
*
*        COPY SYSUT2 DCB/JFCB INFO FROM SYSUT1
*
*
*
         L     R14,=V(SYSDSORG)   R14 -> TO SYSUT1 DSORG
         CLC   0(2,R14),=X'0008'  IS IT VSAM?
         BE    SETDCBVS           YES, SET UP DCB FOR EXPORT
         TM    0(R14),X'02'       IS IT PO OR POU?
         BO    SETDCBPO           YES, SET DCB FOR PDSFAST
         TM    0(R14),X'20'       IS IT DA OR DAU?
         BO    SETDCBDA           YES
*                                 NO, TREAT AS PS
*
*        TM    0(R14),X'40'       IS IT PS OR PSU?
*        BZ    UT2ABEND           NO, END FOR NOW
         SPACE 1
SETDCBPS DS    0H
SETDCBDA DS    0H
         L     R5,=V(JFCB)        R5 -> TO SYSUT1 JFCB
         USING INFMJFCB,R5              SET DSECT
         XC    0(176,R5),0(R5)    MAKE SURE JFCB IS CLEAN
         L     R4,=V(INFILE)      R4 -> TO SYSUT1 DCB
         RDJFCB ((4))             READ SYSUT1 JFCB
         LTR   R15,R15            WAS RDJFCB OKAY?
         BNZ   FAIL5              NO
         LA    R4,SYSUT2          R4 -> TO SYSUT2 DCB
         USING IHADCB,R4          SET DCB DSECT
         MVC   DCBBLKSI,JFCBLKSI  SET SYSUT2 BLKSIZE TO SYSUT1
         CLC   DCBBLKSI,=H'0'     SYSUT2 BLKSIZE = 0?
         BNE   BLKSIOK            NO
         MVC   DCBBLKSI,=H'32767' SET SYSUT2 BLKSIZE TO 32767
         SPACE 1
BLKSIOK  DS    0H
         MVC   DCBLRECL,JFCLRECL  SET SYSUT2 LRECL TO SYSUT1
         CLC   DCBLRECL,=H'0'     SYSUT2 LRECL = 0?
         BNE   LRECOK             NO
         MVC   DCBLRECL,DCBBLKSI  YES, SYSUT2 LRECL = BLKSIZE
         SPACE 1
LRECOK   DS    0H
         MVC   DCBRECFM,JFCRECFM  SET SYSUT2 RECFM TO SYSUT1
         DROP  R4,R5
         B     DCBSET             ON WE GO
         SPACE 1
SETDCBVS DS    0H                 SET UP DCB FOR VSAM EXPORT
         LA    R4,SYSUT2          R4 -> TO SYSUT2 DCB
         USING IHADCB,R4          SET DCB DSECT
         MVC   DCBBLKSI,=H'23220' SET SYSUT2 BLKSIZE TO 23220
         MVC   DCBLRECL,=H'0'     SET SYSUT2 LRECL TO 0
         MVI   DCBRECFM,X'58'     SET SYSUT2 RECFM TO VBS
         DROP  R4
         B     DCBSET             ON WE GO
         SPACE 1
SETDCBPO DS    0H                 SET UP DCB FOR PDSFAST
         LA    R4,SYSUT2          R4 -> TO SYSUT2 DCB
         USING IHADCB,R4          SET DCB DSECT
         MVC   DCBBLKSI,=H'19089' SET SYSUT2 BLKSIZE TO 19089
         MVC   DCBLRECL,=H'19085' SET SYSUT2 LRECL TO 19085
         MVI   DCBRECFM,X'48'     SET SYSUT2 RECFM TO VS
         DROP  R4
*        B     DCBSET             ON WE GO
*                                                                   RH1
         SPACE 1
DCBSET   DS    0H
         LA    R2,UT2JFCB         R2 -> TO SYSUT2 JCFB              RH
         USING IHAJFCB,R2
*
         MVC   JFCBDSNM,TUPAR1    PUT DSN IN
         MVC   JFCBFLSQ,TUPAR7    PUT NEW SEQ NBR IN
         MVC   JFCBVLSQ,VOLSEQ    PUT VOLUME SEQUENCE NBR IN
         MVI   JFCBIND2,X'C0'     PUT DISP=NEW IN
*
*              ALSO PUT BLKSIZE, LRECL AND RECFM IN JFCB
*
         LA    R4,SYSUT2          R4 -> TO SYSUT2 DCB
         USING IHADCB,R4          SET DCB DSECT
         MVC   JFCBLKSI,DCBBLKSI  SET JFCB BLKSIZE
         MVC   JFCLRECL,DCBLRECL  SET JFCB LRECL
         MVC   JFCRECFM,DCBRECFM  SET JFCB RECFM
         DROP  R4
         SPACE 1
         LH    R5,TUPAR7          R5 = SEQ NBR
         CH    R5,=H'1'           PAST 1ST FILE?
         BH    OPEN1              YES
         MVI   JFCBIND2,X'80'     PUT DISP=MOD IN
         MVC   SAVEXPDT,JFCBXPDT  SAVE JFCB EXPIRY DATE
         XC    JFCBXPDT,JFCBXPDT  SET JFCB EXPIRY DATE TO NULL
         B     UCBFOUND           BYPASS UCB SEARCH IF LABEL=1
         SPACE 1
*
OPEN1    DS    0H
         XC    JFCBXPDT,JFCBXPDT  SET JFCB EXPIRY DATE TO NULL
*                                 BYPASS UCB SEARCH THE 1ST TIME
OPENNOP  NOP   FINDUCB            B AFTER 1ST TIME
         MVI   OPENNOP+1,X'F0'    CHANGE NOP TO B
         B     UCBFOUND           BYPASS UCB SEARCH THE 1ST TIME
*
*      SEARCH THE UCB TABLE TO GET THE VOLSER
*
         SPACE 1                                                    RH
FINDUCB  DS    0H                                                   RH
         XC    WORKAREA,WORKAREA  CLEAR UCBSCAN WORKAREA
         SPACE 1
NEXTUCB  DS    0H
         PRINT GEN
*        UCBSCAN COPY,WORKAREA=WORKAREA,UCBAREA=UCBAREA,               +
               DYNAMIC=YES,DEVCLASS=TAPE      ,VOLSER=TUPAR6
         UCBSCAN COPY,WORKAREA=WORKAREA,UCBAREA=UCBAREA,               +
               DYNAMIC=YES,DEVCLASS=TAPE,  VOLSER=TUPAR1,              +
               RANGE=ALL,CMXTAREA=CMXTAREA,DCEAREA=DCEAREA,            +
               DCELEN=DCELEN
         PRINT NOGEN
         LTR   R15,R15            HAS A UCB BEEN RETURNED?
         BZ    UCBOK              YES
         MVC   OLC024A(3),=C'UCB' SAY NO UCB
         B     FAIL7              NO, AT END OF DEVICE CLASS AND
*                                 NO MATCH FOUND.
         SPACE 1
UCBOK    DS    0H
         LA    R3,UCBAREA         R3 -> TO UCB THAT THE SCAN
*                                 SERVICE RETURNED.
         USING UCBOB,R3           SET UP ADDRESSIBILITY TO UCB
*                                                                   RH
*                  THIS IS CODE TO DUMP CORE                 DEBUG  RH
*                                                                   RH
         L     R2,=V(DEBUG)     IS DEBUG IN EFFECT
         USING IHADCB,R2
         TM    DCBOFLGS,DCBOFOPN  DID IT OPEN ?
         BZ    LINKUCB            NO
         DROP  R2                 DROP BASE...
         SPACE 1                                             DEBUG  RH
         PRINT   GEN
         HDUMP OUTDCB,R3,200,NOTOPEN,OPEN,V=YES,             DEBUG  RH +
               TITLE='UCB RETURNED BY UCBSCAN' ,GENDCB=YES
         SPACE 1                                             DEBUG  RH
         PRINT NOGEN
*                                                                   RH
*                  THIS IS END OF CODE TO DUMP CORE          DEBUG  RH
*                                                                   RH
         SPACE 1                                             DEBUG  RH
LINKUCB  DS    0H                                            DEBUG  RH
*        CLC   UCBNAME,TUPAR6     IS THIS OUR UCB?
*        BNE   NEXTUCB            NO, DON'T USE IT THEN
*
*   THE ONLY PROBLEM IS THAT THE ABOVE CODE DOESN'T WORK FOR
*   4 DIGIT UCB ADDRESSES, AS THE UCBNAME FIELD CONTAINS 'UCB'.
*   SO WE MUST CONVERT THE REAL UCB ADDRESS FROM THE HEX ADDRESS
*   AT OFFSET +4 IN THE UCB...FEB 10/99
*
*   ALSO, IF YOU ARE ALLOCATING BY UNIT, IT MUST BE PRECEDED BY /   RH
*              ..EG../190A.....
*
*              CONVERT UCB ADDRESS FOR UNIT NAME
*
         UNPK  TESTUCB(5),4(3,R3) UNPACK 4 DIGIT UNIT ADDRESS
         MVI   TESTUCB+4,X'EF'    TRANSLATES TO BLANK
         TR    TESTUCB(5),TRTAB3-239  TRANSLATE TO DISPLAY
         MVC   TESTUCB+5(3),=CL5' '    BLANK OUT REST OF UNIT NAME
*
*                                                                   RH
*                  THIS IS CODE TO DUMP CORE                 DEBUG  RH
*                                                                   RH
         L     R2,=V(DEBUG)     IS DEBUG IN EFFECT
         USING IHADCB,R2
         TM    DCBOFLGS,DCBOFOPN  DID IT OPEN ?
         BZ    LINKUCB2           NO
         DROP  R2                 DROP BASE...
         SPACE 1                                             DEBUG  RH
         LA    R2,TESTUCB         R2 -> AREA TO DUMP
         PRINT   GEN
         HDUMP OUTDCB,R2,20,NOTOPEN,OPEN,V=NO,               DEBUG  RH +
               TITLE='TESTUCB'                 ,GENDCB=YES
         LA    R2,TUPAR6          R2 -> AREA TO DUMP
         HDUMP OUTDCB,R2,20,NOTOPEN,OPEN,V=NO,               DEBUG  RH +
               TITLE='TUPAR6'                  ,GENDCB=YES
         SPACE 1                                             DEBUG  RH
         PRINT NOGEN
*                                                                   RH
*                  THIS IS END OF CODE TO DUMP CORE          DEBUG  RH
*                                                                   RH
         SPACE 1                                             DEBUG  RH
LINKUCB2 DS    0H                                            DEBUG  RH
         CLC   TESTUCB,TUPAR6     IS THIS OUR UCB?
         BNE   NEXTUCB            NO, DON'T USE IT THEN
*
         CLI   UCBVOLI,X'00'      IS THERE A VOL SER?
         BNE   UCBOK2             YES
         MVC   OLC024A(3),=C'VOL' SAY NO VOL
         B     FAIL7              NO, AT END OF DEVICE CLASS AND
*                                 NO MATCH FOUND.
TESTUCB  DC    CL8' '
         SPACE 3
TRTAB3   DC    C' 0123456789ABCDE '
         SPACE 3
         SPACE 1
UCBOK2   DS    0H
         LA    R2,UT2JFCB         R2 -> TO SYSUT2 JCFB              RH
         USING IHAJFCB,R2         SET JFCB BASE AGAIN
         MVC   JFCBVOLS(6),UCBVOLI PUT VOLSER IN JFCB 1
         SPACE 1
UCBFOUND DS    0H
         SPACE 1
NOMORE   DS    0H
         DROP  R3                 DROP UCB BASE
         OPEN  (SYSUT2,(OUTPUT)),TYPE=J   OPEN IT
         LA    R1,SYSUT2          R1 -> TO DCB
         USING    IHADCB,R1
         TM       DCBOFLGS,DCBOFOPN            DID IT OPEN ?
         BZ    FAIL8              NO, GO TO ERR RTN
*
*              IN CASE WE SWITCHED TO ANOTHER UNIT, CHAIN THRU THE
*              DEB TO THE UCB AND  SAVE THE UNIT NAME
*
         L     R4,DCBDEBAD        R4 -> TO THE DEB
         LA    R4,0(0,R4)         CLEAR FLAG BYTE
         USING DEBBASIC,R4        SET DEB BASE
         L     R4,DEBSUCBA        R4 -> TO THE DEB UCB
         LA    R4,0(0,R4)         CLEAR FLAG BYTE
         DROP  R4                 DROP DEB BASE
         USING UCBOB,R4           SET UCB BASE
*        MVC   TUPAR6(3),UCBNAME  SAVE THIS UNIT ADDRESS
*
*   THE ONLY PROBLEM IS THAT THE ABOVE CODE DOESN'T WORK FOR
*   4 DIGIT UCB ADDRESSES, AS THE UCBNAME FIELD CONTAINS 'UCB'.
*   SO WE MUST CONVERT THE REAL UCB ADDRESS FROM THE HEX ADDRESS
*   AT OFFSET +4 IN THE UCB...FEB 10/99
*
*
*   ALSO, IF YOU ARE ALLOCATING BY UNIT, IT MUST BE PRECEDED BY /   RH
*              ..EG../190A.....
*
*              CONVERT UCB ADDRESS FOR UNIT NAME
*
         LA    R6,TUPAR6          R6 -> WHERE UCB NAME GETS SAVED
         UNPK  0(5,R6),4(3,R4)    UNPACK 4 DIGIT UNIT ADDRESS
         MVI   4(R6),X'EF'        TRANSLATES TO BLANK
         TR    0(5,R6),TRTAB4-239 TRANSLATE TO DISPLAY
         MVC   5(3,R6),=CL5' '    BLANK OUT REST OF UNIT NAME
*
         DROP  R1,R4
*
*              IF WE AT THE 1ST FILE, CREATE A DUMMY FILE TO
*              CONTAIN THE EXPIRY DATE....
*
         CH    R5,=H'1'           PAST 1ST FILE?
         BH    CLOSFILE           YES, ON WE GO
         MVC   JFCBXPDT,SAVEXPDT  SET  JFCB EXPIRY DATE
         B     OPEN4              END FOR NOW
*
*              ADD 1 TO SEQ NBR
*
         LH    R5,TUPAR7          R5 = SEQ NBR
         LA    R5,1(0,R5)         R5 = NEXT SEQ NBR
         STH   R5,TUPAR7          SAVE NEXT SEQ NBR
*
*        LA    R2,UT2JFCB         R2 -> TO SYSUT2 JCFB              RH
*        USING IHAJFCB,R2
         MVC   JFCBDSNM,TUPAR1    PUT DSN IN
         MVC   JFCBFLSQ,TUPAR7    PUT NEW SEQ NBR IN
         MVC   JFCBVLSQ,VOLSEQ    PUT VOLUME SEQUENCE NBR IN
         MVI   JFCBIND2,X'C0'     PUT DISP=NEW IN
         SPACE 1
CLOSFILE DS    0H
         CLOSE (SYSUT2)           CLOSE IT                          RH
         LA    R4,SYSUT2          R4 -> TO SYSUT2 DCB
         USING IHADCB,R4          SET R4 AS DCB DSECT
         L     R15,DCBBUFCB       R15 = A(BUFFER)
         BCTR  R15,0              -1
         LTR   R15,R15            IS THERE A BUFFER?
         BZ    NOPOOL4            NO
         DROP  R4                 DROP R4 AS DCB DSECT
         FREEPOOL ((4))           FREE BUFFER POOL BECAUSE DUMB
*                                 IBM DON'T
         SPACE
NOPOOL4  DS    0H
*
*              MODIFY THE JFCB AGAIN. IF THERE IS NO VOLSER,
*              READ IT AGAIN INTO  A DIFFERENT AREA AND SAVE THE
*              VOLSER IN THE FIRST JFCB.
*
*        LA    R2,UT2JFCB         R2 -> TO SYSUT2 JCFB              RH
         USING IHAJFCB,R2         SET JFCB BASE AGAIN
         CLI   JFCBVOLS,C' '      IS THERE A VOLSER?
         BE    BADVOL             NO, DO RDJFCB AGAIN
         CLI   JFCBVOLS,C'A'      IS IT ALPHANUMERIC?
         BL    BADVOL             NO, DO RDJFCB AGAIN
         CLI   JFCBVOLS,C'9'      IS IT ALPHANUMERIC?
         BNH   JFCBOK             YES, DON'T GET JFCB AGAIN
         SPACE 1
BADVOL   DS    0H
         LA    R4,UT2JFCB2        R4 -> TO JFCB AREA 2
         STCM  R4,7,JFCBXLSJ      PUT IT IN EXIT LIST
*        XC    0(176,R4),0(R4)    MAKE SURE JFCB IS CLEAN
         RDJFCB SYSUT2            GET THE SYSUT2 JFCB               RH
         LA    R1,UT2JFCB         R1 -> TO JFCB AREA
         STCM  R1,7,JFCBXLSJ      PUT IT BACK IN EXIT LIST
         LTR   R15,R15            GET IT?                           RH
         BNZ   FAIL6              IF NOT  NO BLKSIZE                RH
         MVC   JFCBVOLS,JFCBVOLS-IHAJFCB(R4) PUT VOLSER IN JFCB 1
         CLI   JFCBVOLS,C' '      IS THERE A VOLSER?
         BE    UT2ABEND           NO, ABEND
         SPACE 1
JFCBOK   DS    0H
*
*              IF WE ARE PAST THE  1ST FILE, WE MUST OPEN THE FILE
*              AGAIN WITH DISP=MOD SO PDSFAST ETC. CAN 'ADD TO IT'
*
         CH    R5,=H'1'           PAST 1ST FILE?
         BH    OPEN2A             YES, ON WE GO
         MVC   JFCBXPDT,SAVEXPDT  SET  JFCB EXPIRY DATE
         B     OPEN4              END FOR NOW
         SPACE 1
OPEN2A   DS    0H
         MVI   JFCBIND2,X'80'     PUT DISP=MOD IN
         DROP  R2
         SPACE 1
OPEN2    DS    0H
         OPEN  (SYSUT2,(OUTPUT)),TYPE=J   OPEN IT
         LA    R1,SYSUT2          R1 -> TO DCB
         USING    IHADCB,R1
         TM       DCBOFLGS,DCBOFOPN            DID IT OPEN ?
         BZ    FAIL8              NO, GO TO ERR RTN
         DROP     R1
         CLOSE (SYSUT2)           CLOSE IT                          RH
         LA    R4,SYSUT2          R4 -> TO SYSUT2 DCB
         USING IHADCB,R4          SET R4 AS DCB DSECT
         L     R15,DCBBUFCB       R15 = A(BUFFER)
         BCTR  R15,0              -1
         LTR   R15,R15            IS THERE A BUFFER?
         BZ    NOPOOL5            NO
         DROP  R4                 DROP R4 AS DCB DSECT
         FREEPOOL ((4))           FREE BUFFER POOL BECAUSE DUMB
*                                 IBM DON'T
         SPACE
NOPOOL5  DS    0H
         SPACE 1
OPEN4    DS    0H
         SR    R15,R15            R15 = 0
         B     NEWARET            END FOR NOW
         SPACE 1
FAIL5    DS    0H
         OLCMSG   OLC022          PRINT ERROR MSG
         LA    R15,48             SET RC=40
         B     NEWARET            END FOR NOW
         SPACE 1                                                    RH1
FAIL6    DS    0H
         OLCMSG   OLC023          PRINT ERROR MSG
         LA    R15,48             SET RC=40
         B     NEWARET            END FOR NOW
         SPACE 1                                                    RH1
FAIL7    DS    0H
         OLCMSG   OLC024          PRINT ERROR MSG
         LA    R15,48             SET RC=40
         B     NEWARET            END FOR NOW
         SPACE 1                                                    RH1
FAIL8    DS    0H
         OLCMSG   OLC027          PRINT ERROR MSG
         DC    H'0'               ABEND FOR NOW
         LA    R15,48             SET RC=40
         B     NEWARET            END FOR NOW
         SPACE 1
UT2ABEND DS    0H
         OLCMSG NEW006
*        DC    H'0'               0C1 FOR NOW
         LA    R15,16             R15 = 16
*        B     NEWARET            END FOR NOW
         SPACE 1
NEWARET  SECEXIT
         SPACE 2
*
* NEWALLOC  DATA:
*
*
         SPACE 3
TRTAB4   DC    C' 0123456789ABCDE '
         SPACE 2
         SPACE 1
ENDDSN   DS    0CL4
ENDDSNA  DC    C'F'
ENDDSNN  DC    CL3'001'
DWORDE   DC    D'0'
         SPACE 1
SAVEXPDT DC    XL3'0'
         ENTRY FIRSTDSN
FIRSTDSN DC    CL44' '
         SPACE 1
OLC022   DS    0CL81
         DC    AL1(MSGPRT)
         DC    CL75'DSB022 - RDJFCB OF SYSUT1 FAILED'
         DC    C'ERROR'
         SPACE 1
OLC023   DS    0CL81
         DC    AL1(MSGPRT)
         DC    CL75'DSB023 - SECOND READ OF SYSUT2 JFCB FAILED'
         DC    C'ERROR'
         SPACE 1
OLC024   DS    0CL81
         DC    AL1(MSGPRT)
         DC    CL9'DSB024 - '
OLC024A  DC    CL66'UCB NOT FOUND FOR SYSUT2'
         DC    C'ERROR'
         SPACE 1
OLC027   DC    CL81' '
         ORG   *-81
         DC    AL1(MSGPRT)
         DC    C'DSB027 - ERROR OPENING SYSUT2'
         ORG   OLC027+75
         DC    CL5'ERROR'
         ORG   OLC027+81
         SPACE 1
NEW006   DC    CL81' '
         ORG   *-81
         DC    AL1(MSGPRT)
         DC    C'DSB06N - NO VOLSER IN JFCB FOR SYSUT2 '
         ORG   NEW006+75
         DC    CL5'ERROR'
         ORG   NEW006+81
*
OLC010   DC    CL81' '
         ORG   *-81
         DC    AL1(MSGPRT)
         DC    C'DSB010 - MAX OF 5 TAPES EXCEEDED. '
         DC    C'RUN AS 2 JOBS'
         ORG   OLC010+75
         DC    CL5'ERROR'
         ORG   OLC010+81
         SPACE 2
         SPACE 1
PARMLST2 DS    3F                 PARMLIST MAPPING
         ORG   PARMLST2
PARMWA   DC    A(WORKAREA)        ADDRESS OF 100-BYTE WORKAREA
PARMDEVT DC    A(DEVCLASS)        ADDRESS OF BYTE CONTAINING
*                                 THE DEVICE TYPE TO BE SEARCHED
PARMUCB  DC    AL1(80)            ADDRESS OF WORD TO CONTAIN THE
         DC    AL3(ADDRUCB)       THE UCB ADDRESS
         SPACE 1
DEVCLASS DC    XL1'80'            BYTE CONTAINING DEVICE CLASS
*                                 TO BE SEARCHED FOR
*                                 X'80' IS TAPE
ADDRUCB  DS    F                  WORD IN WHICH UCBSCAN WILL
*                                 PLACE THE ADDRESS OF THE UCB
         DS    0D                 ALIGN TO DOUBLE-WORD BOUNDARY
*                                 THE WORKAREA FOR SCAN SERVICE
*                                 MUST BE ON A DOUBLE-WORD BOUNDARY
WORKAREA DS    CL100              WORKAREA
UCBAREA  DS    CL48               WORKAREA FOR UCB
CMXTAREA DS    CL32               WORKAREA FOR UCB
DCELEN   DC    AL2(128)           WORKAREA FOR UCB
DCEAREA  DS    CL128              WORKAREA FOR UCB
         SPACE 1
         SPACE 1
         ENTRY TUPAR1,TULNG1,HLILTH,TUPAR3,TULNG6,TUPAR6,TUPAR7
         ENTRY VOLSEQ
HLILTH   DC    H'0'               LTH OF HLI
         SPACE 1
TULNG1   DC    AL2(44)            LTH OF DSNAME
TUPAR1   DC    CL44' '            DSNAME
         SPACE 1
TUPAR3   DC    CL6' '             1ST VOLSER
         SPACE 1
TULNG6   DC    AL2(4)             LTH OF UNIT
TUPAR6   DC    CL8'TAPE'          UNIT=TAPE
         SPACE 1
TULNG7   DC    AL2(2)             LTH OF SEQ
TUPAR7   DC    AL2(1)             LABEL=1 TO START
VOLSEQ   DC    AL2(1)             VOLSQ=1 TO START
         SPACE 2
         ENTRY SYSUT2,JFCBXLS2,JFCBXLSJ,UT2JFCB,UT2JFCB2
SYSUT2   DCB   MACRF=(PM),DSORG=PS,DDNAME=SYSUT2,EXLST=JFCBXLS2
         SPACE 1
JFCBXLS2 DS    0F
         DC    X'17',AL3(DCBOPEN2) OPEN EXIT
         DC    X'11',AL3(DCBTRAP2) OPEN ABEND EXIT
         DC    X'87'               JFCB EXIT
JFCBXLSJ DC    AL3(UT2JFCB)        JFCB ADDRESS
         DS    0F
         DC    C'JFCB'                                              RH1
UT2JFCB  DC    XL176'00'
         DS    0F
         DC    C'JFCB'                                              RH1
UT2JFCB2 DC    XL176'00'
         SPACE 1
         DROP  R12                DROP SECTION BASE
DCBTRAP2 DS    0H
         USING *,R15
         CLI   3(1),X'00'         MUST ABEND ?
         BER   R14                YES, LET ESTAE CATCH THIS ABEND
         MVI   3(1),X'04'         TRY TO IGNORE ABEND CONDITION
         BR    R14
         DROP  R15
         SPACE 1
DCBOPEN2 DS    0H
         USING *,R15
         SR    R15,R15            CONTINUE WITH OPEN
         BR    R14
         DROP  R15
         SPACE 2
 TITLE 'TAPALLOC - ALLOCATE INPUT TAPE FILE WITH JFCB MODS'
*
*              HERE WE WILL OPEN AND CLOSE SYSUT1 IN ORDER TO
*              MODIFY THE JFCB.
*
         DS    0H
TAPALLOC SECTION DROP=NO
*
         L     R3,=V(RESTREC)     R3 -> TO RESTORE RECORD
         USING RESTRECD,R3        SET RECORD BASE
*
*              MODIFY THE JFCB WITH OPEN/CLOSE
*
         SPACE 1
         L     R5,=V(JFCB)        R5 -> TO SYSUT1 JFCB
         USING INFMJFCB,R5              SET DSECT
         XC    0(176,R5),0(R5)    MAKE SURE JFCB IS CLEAN
         L     R4,=V(INFILE)      R4 -> TO SYSUT1 DCB
         RDJFCB ((4))             READ SYSUT1 JFCB
         LTR   R15,R15            WAS RDJFCB OKAY?
         BNZ   FAIL5T             NO
*
*              MAKE SURE JFCB IS  CLEAN TO FORCE SYSTEM TO USE
*              INFO FROM TAPE HDR
*
         XC    JFCRECFM,JFCRECFM  SET JFCB RECFM TO 0
         XC    JFCBLKSI,JFCBLKSI  SET JFCB BLKSIZE TO 0
         XC    JFCLRECL,JFCLRECL  SET JFCB LRECL TO 0
         MVI   JFCBDSNM,C' '      CLEAR DSN AREA
         MVC   JFCBDSNM+1(43),JFCBDSNM ''
         MVC   JFCBDSNM(44),RESTDSN  PUT DSN IN   ... WAS (17)...
         OI    JFCBFLG2,X'80'     TREAT INOUT AS INPUT              V2
         MVI   JFCBIND2,X'08'     MAKE SURE DISP=SHR                V2
         OI    JFCDSORG,X'40'     TAPE HAS TO BE PS                 V2
*
*              MAKE SURE DCB  IS  CLEAN
*
         USING IHADCB,R4          SET R4 AS DCB DSECT
         XC    DCBBLKSI,DCBBLKSI  SET SYSUT1 BLKSIZE TO 0
         XC    DCBLRECL,DCBLRECL  SET SYSUT1 LRECL TO 0
         XC    DCBRECFM,DCBRECFM  SET SYSUT1 RECFM TO 0
         XC    DCBDSORG,DCBDSORG  SET SYSUT1 DSORG TO 0
         DROP  R4                 DROP R4 AS DCB BASE
*
         PACK  DWORDV,RESTVSEQ    PACK SEQUENCE NBR
         CVB   R15,DWORDV         CONVERT TO BINARY
         STH   R15,JFCBFLSQ       PUT NEW SEQ NBR IN JFCB
         DROP  R3                 DROP RECORD BASE
*
*              PUT VOLSERS INTO JFCB
*
         SR    R14,R14            CLEAR R14
         L     R3,=V(VOLSER2)     R3 -> VOLSERS
         IC    R14,0(0,R3)        R14 = NBR OF VOLSERS
         STC   R14,JFCBNVOL       PUT NBR IN JFCB
         LA    R15,JFCBVOLS       R15 -> TO WHERE JFCB VOLSERS GO
         LA    R3,1(0,R3)         R3 -> TO VOLSERS
         SPACE 1
MVCVOLS  DS    0H
         MVC   0(6,R15),0(R3)     PUT VOLUME SERIAL NBR IN JFCB
         LA    R15,6(0,R15)       R15 -> TO WHERE NEXT VOLSER GOES
         LA    R3,6(0,R3)         R3 -> TO NEXT VOLSER
         BCT   R14,MVCVOLS        PUT ALL VOLS INTO JFCB
         SPACE 1
         MVI   JFCBIND2,X'08'     PUT DISP=SHR IN
*                                                                   RH
*                  THIS IS CODE TO DUMP CORE                 DEBUG  RH
*                                                                   RH
         L     R2,=V(DEBUG)     IS DEBUG IN EFFECT
         USING IHADCB,R2
         TM    DCBOFLGS,DCBOFOPN  DID IT OPEN ?
         BZ    OPENINB            NO
         DROP  R2                 DROP BASE...
         SPACE 1                                             DEBUG  RH
         L     R2,=V(INFILE)      R2 -> TO INFILE DCB        DEBUG  RH
         PRINT   GEN
         HDUMP OUTDCB,R4,100,NOTOPEN,OPEN,V=YES,             DEBUG  RH +
               TITLE='SYSUT1 DCB AT JFCB SETUP',GENDCB=NO
         L     R2,=V(JFCB)        R2 -> TO JFCB              DEBUG  RH
         HDUMP OUTDCB,R2,200,OPEN,OPEN,                      DEBUG  RH +
               TITLE='SYSUT1 JFCB AT SETUP'
         HDUMP OUTDCB,0,0,OPEN,CLOSE,  DUMP REGS ONLY         DEBUG RH +
               TITLE='REGS AT SETUP'
         SPACE 1                                             DEBUG  RH
*                                                                   RH
*                  THIS IS END OF CODE TO DUMP CORE          DEBUG  RH
*                                                                   RH
         SPACE 1
OPENINB  DS    0H                                                   RH
         OPEN  ((R4),(INPUT)),TYPE=J   OPEN IT
         PRINT NOGEN
         USING IHADCB,R4          SET DCB BASE
         TM    DCBOFLGS,DCBOFOPN  DID IT OPEN ?
         BZ    FAIL8T             NO, GO TO ERR RTN
*
         CLOSE ((R4))             CLOSE IT                          RH
         L     R15,DCBBUFCB       R15 = A(BUFFER)
         BCTR  R15,0              -1
         LTR   R15,R15            IS THERE A BUFFER?
         BZ    NOPOOL6            NO
         FREEPOOL ((4))           FREE BUFFER POOL BECAUSE DUMB
*                                 IBM DON'T
         SPACE
NOPOOL6  DS    0H
         SPACE 1
OPEN4T   DS    0H
         SR    R15,R15            R15 = 0
         B     TAPARET            END FOR NOW
         SPACE 1
FAIL5T   DS    0H
         OLCMSG   OLC022T         PRINT ERROR MSG
         LA    R15,48             SET RC=40
         B     TAPARET            END FOR NOW
         SPACE 1                                                    RH1
FAIL8T   DS    0H
         OLCMSG   OLC027T         PRINT ERROR MSG
         DC    H'0'               ABEND FOR NOW
         LA    R15,48             SET RC=48
         B     TAPARET            END FOR NOW
         SPACE 1
         SPACE 1
TAPARET  SECEXIT
         DROP  R4,R5              DROP BASE REGS
         SPACE 2
*
* TAPALLOC  DATA:
*
*
DWORDV   DS    D
         SPACE 1
OLC022T  DS    0CL81
         DC    AL1(MSGPRT)
         DC    CL75'DSB022T - RDJFCB OF SYSUT1 FAILED'
         DC    C'ERROR'
         SPACE 1
OLC027T  DC    CL81' '
         ORG   *-81
         DC    AL1(MSGPRT)
         DC    C'DSB027T - ERROR OPENING SYSUT2'
         ORG   OLC027T+75
         DC    CL5'ERROR'
         ORG   OLC027T+81
         SPACE 1
         SPACE 2
 TITLE 'CREATDSN - ALLOCATE NEW DATASET ON DISK'
*
         DS    0H
CREATDSN SECTION
*
         SPACE 1
CREATERC LA    R15,16             FAIL FOR NOW
         SPACE 1
DYNARETC SECEXIT
         SPACE 2
         SPACE 2
 TITLE 'RACCHECK - MAKE SURE WE HAVE ACCESS TO DATASET'
*
*  MAKE SURE WE HAVE READ ACCESS TO DS FOR BACKUP, UPDATE
*  ACCESS FOR RESTORE, AND ALTER  ACCESS FOR VSAM
*  ALSO, FOR VSAM, THE VOLUME SPECIFIED MUST BE THE CATALOG VOLUME
*
         DS    0H
RACCHECK SECTION
*
         RACSTAT ,                IS RACF ACTIVE?
         BZ    RACHEK2            YES
         SR    R15,R15            NO, SAY ACCESS IS OKAY
         B     RACRET             ON WE GO
         SPACE 1
RACHEK2  DS    0H
         LA    R3,2               R3 = 2, FOR READ ACCESS
         MVC   OLC11A,=C'READ  '  SAY ACCESS IS READ
         L     R1,=V(PARMOLC)     R1 -> TO INPUT PARM
         CLC   =C'RESTORE',0(R1)  IS THIS A RESTORE?
         BNE   NOTREST3           NO
         LA    R3,4               R3 = 4, FOR UPDATE ACCESS
         MVC   OLC11A,=C'UPDATE'  SAY ACCESS IS UPDATE
         SPACE 1
NOTREST3 DS    0H
         L     R4,=V(USRDSN)      ADDRESS OF DSNAME
         L     R5,=V(DYNTUNT4)    ADDRESS OF VOLSER TEXT UNIT
         LA    R5,6(,R5)          ADDRESS OF VOLUME = ADDR UNIT + 6
         SPACE 1
         L     R14,=V(SYSDSORG)   R14 -> TO SYSUT1 DSORG
         CLC   0(2,R14),=X'0008'  IS IT VSAM?
         BE    VSAMCHK            YES
         SPACE 1
         PRINT NOGEN
*        RACHECK ENTITY=((R4)),VOLSER=(R5),CLASS='DATASET',ATTR=READ
*              LOG=NONE,DSTYPE=N
*                WHEN THIS RUNS AUTHORIZED, TURN OFF ERROR LOGGING
         RACHECK ENTITY=((R4)),VOLSER=(R5),CLASS='DATASET',ATTR=(R3),  +
               DSTYPE=N
         LTR   R15,R15        ARE WE OKAY?
         BZ    RACRET
         B     SENDMSG            GO SEND ERROR MSG
         SPACE 1
VSAMCHK  DS    0H
*        L     R3,=V(TVOL)        GET ADDRESS OF LOCATE VOLSER
         LA    R3,X'80'           R3 = 80, FOR ALTER ACCESS
         L     R5,=V(USRVOL)      GET ADDRESS OF CATALOG VOL, IF THERE
         MVC   OLC11A,=C'ALTER '  SAY ACCESS IS ALTER
         RACHECK ENTITY=((R4)),VOLSER=(R5),CLASS='DATASET',ATTR=(R3),  +
               DSTYPE=V
         PRINT NOGEN
         LTR   R15,R15        ARE WE OKAY?
         BZ    RACRET
         B     SENDMSG            GO SEND ERROR MSG
         SPACE 1
SENDMSG  DS    0H
         OLCMSG OLC011        IF NOT PRINT OUT ERROR MSG
         LA    R15,4
RACRET   SECEXIT
         SPACE 2
         DC    CL81' '
         ORG   *-81
OLC011   DS    0A
         DC    AL1(MSGPRT)
         DC    C'DSB011 - RACF '
OLC11A   DC    C'UPDATE'
         DC    C' ACCESS DENIED '
         ORG   OLC011+75
         DC    CL5'ERROR'
         ORG   OLC011+81
 TITLE 'EMPTYCHK - DETERMINE IF LIBRARY IS EMPTY'
         DS    0H
EMPTYCHK SECTION
*
         L     R14,=V(SYSDSORG)   R14 -> TO SYSUT1 DSORG
         CLC   0(2,R14),=X'0008'  IS IT VSAM?
         BE    BADORG             YES, ERROR
         TM    0(R14),X'02'       IS IT PO OR POU?
         BO    DSORGPO            YES, WE CAN HANDLE IT
         TM    0(R14),X'20'       IS IT DA OR DAU?
         BO    DSORGPS            YES, TREAT LIKE PS FOR NOW
         TM    0(R14),X'40'       IS IT PS OR PSU?
         BO    DSORGPS            YES, WE CAN HANDLE IT
         SPACE 1
BADORG   DS    0H
         OLCMSG OLC110            PRINT BAD DSORG MSG
         SR    R15,R15            RC = 0
         B     EMPRET             END FOR NOW
         SPACE 1
DSORGPS  DS    0H
         OPEN  (DCB2,(INPUT))     OPEN SYSUT1
         TM    DCB2+48,X'10'         OPEN OKAY?
         BZ    EMPERR                NO  TERMINATE WITH RC=8
         GET   DCB2               GO READ A RECORD
         CLOSE (DCB2)             CLOSE FILE
         LA    R4,DCB2            R4 -> TO DCB
         USING IHADCB,R4          SET R4 AS DCB DSECT
         L     R15,DCBBUFCB       R15 = A(BUFFER)
         BCTR  R15,0              -1
         LTR   R15,R15            IS THERE A BUFFER?
         BZ    NOPOOL7            NO
         DROP  R4                 DROP R4 AS DCB DSECT
         FREEPOOL ((4))           FREE BUFFER POOL BECAUSE DUMB
*                                 IBM DON'T
         SPACE
NOPOOL7  DS    0H
         SR    R15,R15            CLEAR FOR RETURN CODE
         B     EMPRET             NOT EMPTY
         SPACE 1
DSORGPSE DS    0H
         CLOSE (DCB2)             CLOSE FILE
         LA    R4,DCB2            R4 -> TO DCB
         USING IHADCB,R4          SET R4 AS DCB DSECT
         L     R15,DCBBUFCB       R15 = A(BUFFER)
         BCTR  R15,0              -1
         LTR   R15,R15            IS THERE A BUFFER?
         BZ    NOPOOL8            NO
         DROP  R4                 DROP R4 AS DCB DSECT
         FREEPOOL ((4))           FREE BUFFER POOL BECAUSE DUMB
*                                 IBM DON'T
         SPACE
NOPOOL8  DS    0H
         B     DSEMPTY            SAY FILE EMPTY
         SPACE 1
DSORGPO  DS    0H
         OPEN  (DIRECTRY,(INPUT))
         TM    DIRECTRY+48,X'10'     OPEN OKAY?
         BZ    EMPERR                NO  TERMINATE WITH RC=8
         READ  DIRDECB,SF,DIRECTRY,DIRECTAR,'S'
         CHECK DIRDECB               WAIT FOR COMPLETION
         CLOSE (DIRECTRY)
         SR    R15,R15               CLEAR FOR RETURN CODE
*  R1 POINTS TO NEXT MEMBER IN DIRECTORY BLOCK
         LA    R1,DIRECTAR+2
         USING PDS2,R1
         CLI   PDS2NAME,X'FF'        NO MEMBERS?
         BNE   EMPRET
         SPACE 1
DSEMPTY  DS    0H
         L     R2,=V(USRDSN)      GET ADDRESS OF INPUT DSNAME
         CLC   0(6,R2),=CL6' '    ANY DSNAME?
         BE    SETRC4             NO
         OLCMSG OLC013
         SPACE 1
SETRC4   DS    0H
         LA    R15,4              INDICATE EMPTY LIBRARY
         B     EMPRET
EMPRDER  CLOSE (DIRECTRY)
         LA    R4,DIRECTRY        R4 -> TO DCB
         USING IHADCB,R4          SET R4 AS DCB DSECT
         L     R15,DCBBUFCB       R15 = A(BUFFER)
         BCTR  R15,0              -1
         LTR   R15,R15            IS THERE A BUFFER?
         BZ    NOPOOL9            NO
         DROP  R4                 DROP R4 AS DCB DSECT
         FREEPOOL ((4))           FREE BUFFER POOL BECAUSE DUMB
*                                 IBM DON'T
         SPACE
NOPOOL9  DS    0H
EMPERR   EQU   *
         OLCMSG OLC012
         LA    R15,8              INDICATE ERROR
EMPRET   SECEXIT
         DROP  R1
         SPACE 2
OLC012   DC    CL81' '
         ORG   *-81
         DC    AL1(MSGPRT)
         DC    C'DSB012 - DIRECTORY READ FAILED FOR DSNAME IN DSB043'
         ORG   OLC012+75
         DC    CL5'ERROR'
         ORG   OLC012+81
         SPACE 1
OLC013   DC    CL81' '
         ORG   *-81
         DC    AL1(MSGPRT)
         DC    C'DSB013 - LIBRARY EMPTY : '
OLC013M  DC    CL44' '
         ORG   OLC013+75
         DC    CL5'ERROR'
         ORG   OLC013+81
         SPACE 1
         DC    CL81' '
         ORG   *-81
OLC110   DS    0A
         DC    AL1(MSGPRT)
         DC    C'DSB110 - EMPTY CHECK NOT DONE: '
OLC110DS DC    CL44' '
         ORG   OLC110+81
         ENTRY DIRECTRY
         PRINT   NOGEN
DCB2     DCB   MACRF=(GL),DSORG=PS,EODAD=DSORGPSE,DDNAME=SYSUT1
DIRECTRY DCB   MACRF=R,RECFM=F,BLKSIZE=256,                          XXX
               LRECL=256,DSORG=PS,DEVD=DA,EODAD=EMPRDER,DDNAME=SYSUT1
DIRECTAR DC    256X'00'
         PRINT   NOGEN
 TITLE 'COPYUSER - SET UP COPY FOR USER LIB MEMBERS'
         DS    0H
COPYUSER SECTION
*
         XC    COPYRC,COPYRC      RETURN CODE = 0
*
         MVI   OLC122M,C' '       CLEAR RESTORE MSG
         MVC   OLC122M+1(43),OLC122M  ''
*
         L     R14,=V(SYSDSORG)   R14 -> TO SYSUT1 DSORG
         CLC   0(2,R14),=X'0008'  IS IT VSAM?
         BE    COPYVS             YES, CALL IDCAMS
         TM    0(R14),X'02'       IS IT PO OR POU?
         BO    COPYPO             YES, WE CAN HANDLE IT
         TM    0(R14),X'20'       IS IT DA OR DAU?
         BO    COPYDA             YES, COPY LIKE PS
         TM    0(R14),X'40'       IS IT PS OR PSU?
         BZ    RESTM8             NO, END FOR NOW
         SPACE 1
COPYPS   DS    0H
         PERFORM SEQCOPY          CALL THE SEQUENTIAL COPIER
         MVC   OLC120A,=C'PS'     SAY IT WAS A PS FILE
         B     COPYDONE           END FOR NOW
         SPACE 1
COPYDA   DS    0H
         PERFORM SEQCOPY          CALL THE SEQUENTIAL COPIER
         MVC   OLC120A,=C'DA'     SAY IT WAS A DA FILE
         MVC   OLC122M(L'DAREST),DAREST  FINISH RESTORE MSG
         B     COPYDONE           END FOR NOW
         SPACE 1
COPYVS   DS    0H
         PERFORM IDCCOPY          CALL IDCAMS FOR EXPORT TEMPORARY
         MVC   OLC120A,=C'VS'     SAY IT WAS A VSAM FILE
         B     COPYDONE           END FOR NOW
         SPACE 1
COPYPO   DS    0H
         L       R1,=V(IEBSYSIN)    SET THE IEBCOPY SYSIN POINTER
         PERFORM IEBCOPY
         MVC   OLC120A,=C'PO'     SAY IT WAS A PO FILE
         SPACE 1
COPYDONE DS    0H
*        L     R2,=V(MAXCC)       ADDRESS OF MAX RC
*        C     R15,0(0,R2)        THIS RC BIGGER THAN THE LAST ONE?
*        BNH   NOTBIG2            NO
*        ST    R15,0(0,R2)        YES, SAVE THIS RC
         ST    R15,COPYRC         SAVE THIS RC
         SPACE 1
NOTBIG2  DS    0H
         LTR   R15,R15            WAS COPY RC = 0 ?
         BZ    COPYDON2           YES
         OLCMSG OLC120E           NO, PRINT A WARNING MSG
         SPACE 1
COPYDON2 DS    0H
         L     R1,=V(PARMOLC)     R1 -> TO INPUT PARM
         CLC   =C'RESTORE',0(R1)  IS THIS A RESTORE?
         BNE   COPYBACK           NO
         SPACE 1
         L     R6,=V(RESTREC)     R6 -> TO RESTORE RECORD
         USING RESTRECD,R6        SET BASE
         MVC   OLC120FR(4),RESTVSEQ MOVE FILE NBR TO MSG
*        MVC   OLC120BR,RESTVSER  PUT VOLSER IN MSG
         MVC   OLC120AR,RESTTYPE  PUT TYPE IN MSG
         DROP  R6                 DROP RESTREC BASE
*
*              PUT VOLSERS INTO MSG
*
         SR    R4,R4              CLEAR R4
         L     R1,=V(VOLSER2)     R1 -> TO VOLSERS
         IC    R4,0(0,R1)         R4 = NBR VOLS
         LA    R14,1(0,R1)        R14 -> TO VOLSERS
         LA    R1,OLC120BR        R1 -> TO WHERE VOLSERS GO
         SPACE 1
VLOOP4   DS    0H
         MVC   0(6,R1),0(R14)     PUT VOLSER IN MSG
         MVI   6(R1),C','         PUT IN A COMMA
         LA    R14,6(0,R14)       R14 -> TO NEXT VOLSER
         LA    R1,7(0,R1)         R1 -> TO WHERE NEXT VOL GOES
         BCT   R4,VLOOP4          PUT ALL VOLS IN
         BCTR  R1,0               R1 -> TO LAST COMMA
         MVI   0(R1),C' '         TAKE IT OFF
         SPACE 1
         OLCMSG  OLC120R          PRINT MSG
         B     RESTM8             ON WE GO
         SPACE 1
COPYBACK DS    0H
         L     R1,=V(TUPAR7)      R1 -> TO OUTPUT FILE NBR
         LH    R14,0(0,R1)        R14 = FILE NBR
         CVD   R14,DWORD          CONVERT TO DECIMAL
         UNPK  DWORD(5),DWORD+5(3) CONVERT TO DISPLAY
         MVZ   DWORD+4(1),DWORD   FIX SIGN
         MVC   OLC120F(4),DWORD+1 MOVE FILE NBR TO MSG
*
*              PUT TAPE VOLSER IN  MSG
*
         L     R2,=V(UT2JFCB)     R2 -> TO SYSUT2 JCFB              RH
         USING IHAJFCB,R2         SET JFCB BASE AGAIN
         SR    R1,R1              CLEAR R1
         IC    R1,JFCBNVOL        R1 = NBR VOLUMES
         BCTR  R1,0               -1 FOR HEX
         MH    R1,=H'6'           R1 = OFFSET TO LAST VOL SLOT
         LA    R1,JFCBVOLS(R1)    R1 -> TO LAST VOL
         MVC   OLC120B,0(R1)      PUT VOLSER IN MSG
         DROP  R2                 DROP JFCB BASE
*
*              READ THE SYSUT2 JFCB  AGAIN TO SEE IF THE VOLSER
*              CHANGED DURING THE COPY....
*
         MVI   VOLSER2,X'01'      SAY ONLY 1 VOLSER
         MVI   VOLSER2+1,X'40'    CLEAR VOLSERS AREA
         MVC   VOLSER2+2(29),VOLSER2+1   ''
         MVI   OLC120D,X'40'      CLEAR VOLSERS AREA
         MVC   OLC120D+1(27),OLC120D  ''
         L     R1,=V(JFCBXLSJ)    R1 -> TO JFCB EXIT LIST
         L     R4,=V(UT2JFCB2)    R4 -> TO JFCB AREA 2
         STCM  R4,7,0(R1)         PUT IT IN EXIT LIST
*        XC    0(176,R4),0(R4)    MAKE SURE JFCB IS CLEAN
         L     R2,=V(SYSUT2)      R2 -> SYSUT2 DCB
         RDJFCB ((2))             GET THE SYSUT2 JFCB               RH
         L     R1,=V(JFCBXLSJ)    R1 -> TO JFCB EXIT LIST
         L     R2,=V(UT2JFCB)     R2 -> TO JFCB AREA 1
         STCM  R2,7,0(R1)         PUT IT BACK IN EXIT LIST
         LTR   R15,R15            WAS RDJFCB OKAY?                  RH
         BNZ   NOVOL2A            IF NOT, NO VOLSER                 RH
         MVC   VOLSER2,JFCBNVOL-IHAJFCB(R4) SAVE COUNT AND VOLSERS
         IC    R15,VOLSER2        R15 = NBR VOLS
         LA    R14,VOLSER2+1      R14 -> TO VOLSERS
         LA    R1,OLC120B         R1 -> TO WHERE VOLSERS GO
         SPACE 1
VLOOP1   DS    0H
         MVC   0(6,R1),0(R14)     PUT VOLSER IN MSG
         MVI   6(R1),C','         PUT IN A COMMA
         LA    R14,6(0,R14)       R14 -> TO NEXT VOLSER
         LA    R1,7(0,R1)         R1 -> TO WHERE NEXT VOL GOES
         BCT   R15,VLOOP1         PUT ALL VOLS IN
         SPACE 1
NOVOL2A  DS    0H
         OLCMSG  OLC120           PRINT MSG
         L       R1,=V(TUPAR1)    R1 -> TO OUTPUT DSN
         MVC     OLC121M,0(R1)    PUT DSN INTO MSG
         OLCMSG  OLC121           PRINT DSN PART OF MSG
         CLC   OLC122M(5),=CL5' ' IS THERE A RESTORE MSG?
         BE    RESTM1             NO
         OLCMSG  OLC122           PRINT RESTORE MSG
         SPACE 1
RESTM1   NOP   RESTM8             B IF NO RESTORE FILE
         SPACE 1
         L     R5,=V(RESTORE)     R5 -> TO RESTORE DCB
         USING IHADCB,R5          SET DCB BASE
         TM    DCBOFLGS,DCBOFOPN  DID IT OPEN ?
         BZ    RESTM7             NO, DON'T SET UP AND WRITE RECORD
         SPACE 1
         MVI   SPCFLAG,0          ASSUME WE WILL GET SPACE
         L     R14,=V(SYSDSORG)   R14 -> TO SYSUT1 DSORG
         CLC   0(2,R14),=X'0008'  IS IT VSAM?
         BE    NOMORE1            YES, CAN'T FIND SPACE USED
*
         L     R1,=V(VTOCDDN)     R1 -> TO VTOC DDNAME FIELD
         MVC   0(6,R1),=C'SYSUT1' MOVE DDNAME TO VTOC DDN
*
         PERFORM RDVTOC           GO GET SPACE FOR SYSUT1
         LTR   R15,R15            DID WE GET IT?
         BZ    NOMORE2            YES, ON WE GO
         SPACE 1
NOMORE1  DS    0H
         MVI   SPCFLAG,1          SAY NO SPACE
         SPACE 1
NOMORE2  DS    0H
         LA    R1,OLC121M+43      R1 -> TO END OF TAPE DSN
         LA    R14,44             R14 MAX DSN LTH
         SPACE 1
DSNLOOP  DS    0H
         CLI   0(R1),C' '         FOUND END OF DSN?
         BNE   DSNLOOP2           YES
         BCTR  R14,0              NO, SUBT 1 FROM R14
         BCT   R1,DSNLOOP         CHECK NEXT PREV CHAR
         SPACE 1
DSNLOOP2 DS    0H
         LA    R1,OLC121M         NO, R1 -> TO START OF DSN
         SPACE 1
DSNLOOP4 DS    0H
         LA    R6,RESTREC         R6 -> TO RESTORE RECORD
         USING RESTRECD,R6        SET RECORD BASE
         MVC   RESTDSN,0(R1)      PUT TAPE DSN IN RECORD
         MVC   RESTTYPE,OLC120A   PUT TYPE IN RECORD
         MVC   RESTVSER,OLC120B   PUT VOLSER IN RECORD
         CLI   VOLSER2,X'01'      IS THERE A 2ND VOLSER?
         BE    NOVOL2B            NO, ON WE GO
         MVI   RESTVSER+6,C'*'    FLAG FOR 2ND VOLSER
         SPACE 1
NOVOL2B  DS    0H
         MVC   RESTVSEQ,OLC120F   PUT VOL SEQ NBR IN RESTORE RECORD
         L     R1,=V(USRDSN)      R1 -> TO DISK DSN
         MVC   RESTDSN2,0(R1)     PUT DISK DSN IN RECORD
         SPACE 1
         CLI   SPCFLAG,1          DID WE GET SPACE ?
         BE    NOSPACE            NO, CAN'T FILL IN RESTORE RECORD
         L     R1,=V(SPCUSED)     R1 -> TO TRACKS USED
         LH    R1,0(0,R1)         R1 =     TRACKS USED
         CVD   R1,DWORD           CONVERT TO DECIMAL
         UNPK  DWORD(5),DWORD+5(3) CONVERT TO DISPLAY
         MVZ   DWORD+4(1),DWORD   FIX SIGN
         MVC   RESTUSED,DWORD+1   PUT IT IN RECORD
         SPACE 1
         L     R1,=V(SPCSECN)     R1 -> TO SECONDARY ALLOCATION
         LH    R1,0(0,R1)         R1 =     TRACKS USED
         CVD   R1,DWORD           CONVERT TO DECIMAL
         UNPK  DWORD(5),DWORD+5(3) CONVERT TO DISPLAY
         MVZ   DWORD+4(1),DWORD   FIX SIGN
         MVC   RESTSECN,DWORD+1   PUT IT IN RECORD
         SPACE 1
         MVC   RESTDIR,=CL4' '    CLEAR OUT DIRECTORY SIZE FIELD
         CLC   RESTTYPE,=C'PO'    IS IT A PDS?
         BNE   NOTPDS             NO, CAN'T BE ANY DIR BLKS THEN
         L     R1,=V(DIRBLKS)     R1 -> TO DIRECTORY BLOCKS, IF ANY
         LH    R1,0(0,R1)         R1 = NBR DIRECTORY BLKS
         CVD   R1,DWORD           CONVERT TO DECIMAL
         UNPK  DWORD(5),DWORD+5(3) CONVERT TO DISPLAY
         MVZ   DWORD+4(1),DWORD   FIX SIGN
         MVC   RESTDIR,DWORD+1    PUT IT IN RECORD
         SPACE 1
NOTPDS   DS    0H
         L     R1,=V(SPCBLK)      R1 -> TO BLKSIZE
         LH    R1,0(0,R1)         R1 =     TRACKS USED
         CVD   R1,DWORD           CONVERT TO DECIMAL
         UNPK  DWORD(5),DWORD+5(3) CONVERT TO DISPLAY
         MVZ   DWORD+4(1),DWORD   FIX SIGN
         MVC   RESTBLK,DWORD      PUT IT IN RECORD
         SPACE 1
         L     R1,=V(SPCLRECL)    R1 -> TO LRECL
         LH    R1,0(0,R1)         R1 =     TRACKS USED
         CVD   R1,DWORD           CONVERT TO DECIMAL
         UNPK  DWORD(5),DWORD+5(3) CONVERT TO DISPLAY
         MVZ   DWORD+4(1),DWORD   FIX SIGN
         MVC   RESTLREC,DWORD     PUT IT IN RECORD
         SPACE 1
         L     R1,=V(DSNRECFM)    R1 -> TO RECFM
         MVC   DWORD(1),0(R1)     SAVE RECFM
         LA    R1,DWORD           R1 -> TO WORK RECFM
         MVC   RESTRCFM,=C'   '   CLEAR OUT RECFM
         MVI   RESTRCFM,C'U'      DEFAULT TO U
         TM    0(R1),X'C0'        IS IT U?
         BO    RECFMSET           YES
*
         LA    R14,RESTRCFM       R14 -> TO 1ST RECFM FIELD BYTE
         BAL   R15,SETREC         GO SET RECFM...
         LA    R14,RESTRCFM+1     R14 -> TO 2ND RECFM FIELD BYTE
         BAL   R15,SETREC         GO SET RECFM...
         LA    R14,RESTRCFM+2     R14 -> TO 3RD RECFM FIELD BYTE
         BAL   R15,SETREC         GO SET RECFM...
         B     RECFMSET           END OF RECFM STUFF...
         SPACE 1
SETREC   DS    0H
         TM    0(R1),X'80'        IS IT FIXED?
         BZ    SETRECA            NO
         MVI   0(R14),C'F'        PUT F IN RECFM
         NI    0(R1),255-X'80'    TURN OFF BIT
         BR    R15                RETURN
         SPACE 1
SETRECA  DS    0H
         TM    0(R1),X'40'        IS IT VARIABLE?
         BZ    SETRECB            NO
         NI    0(R1),255-X'40'    TURN OFF BIT
         MVI   0(R14),C'V'        PUT V IN RECFM
         BR    R15                RETURN
         SPACE 1
SETRECB  DS    0H
         TM    0(R1),X'10'        IS IT BLOCKED?
         BZ    SETRECC            NO
         NI    0(R1),255-X'10'    TURN OFF BIT
         MVI   0(R14),C'B'        PUT B IN RECFM
         BR    R15                RETURN
         SPACE 1
SETRECC  DS    0H
         TM    0(R1),X'08'        IS IT SPANNED?
         BZ    SETRECD            NO
         NI    0(R1),255-X'08'    TURN OFF BIT
         MVI   0(R14),C'S'        PUT S IN RECFM
         BR    R15                RETURN
         SPACE 1
SETRECD  DS    0H
         TM    0(R1),X'04'        IS IT ANSI CONTROL?
         BZ    SETRECE            NO
         NI    0(R1),255-X'04'    TURN OFF BIT
         MVI   0(R14),C'A'        PUT A IN RECFM
         BR    R15                RETURN
         SPACE 1
SETRECE  DS    0H
         TM    0(R1),X'02'        IS IT MACHINE CONTROL?
         BZ    SETRECF            NO, END OF TESTS
*        BZ    *+4+4+4            NO, END OF TESTS
         NI    0(R1),255-X'02'    TURN OFF BIT
         MVI   0(R14),C'M'        PUT M IN RECFM
         SPACE 1
SETRECF  DS    0H
         BR    R15                RETURN
         SPACE 1
RECFMSET DS    0H
         L     R1,=V(SPCTYPE)     R1 -> TO SPACE TYPE
         MVC   RESTALOC,0(R1)     PUT IT IN RECORD
         SPACE 1
NOSPACE  DS    0H
         L     R1,=V(USRVOL)      R1 -> TO INPUT VOLSER
         MVC   RESTVOL,0(R1)      PUT VOLSER IN RECORD IN CASE VSAM
         SPACE 1
         PUT   (R5),RESTREC       WRITE RECORD
         MVI   RESTREC,C' '       CLEAR RESTORE RECORD AREA
         MVC   RESTREC+1(132),RESTREC  ''
         CLI   VOLSER2,X'01'      IS THERE A 2ND VOLSER?
         BE    NOVOL2C            NO, ON WE GO
*
         SR    R2,R2              CLEAR R2
         IC    R2,VOLSER2         R2 = NBR VOLS
         BCTR  R2,0               -1 CAUSE WE DID THE 1ST ONE
         LA    R3,VOLSER2+7       R3 -> TO 2ND VOLSER
         SPACE 1
VLOOP2   DS    0H
         MVC   RESTVSER,0(R3)     PUT VOLSER IN MSG
         CH    R2,=H'1'           ONLY 1 LEFT?
         BE    VLOOP3             YES, DON'T TURN ON MULT FLAG
         MVI   RESTVSER+6,C'*'    FLAG FOR 2ND VOLSER
         SPACE 1
VLOOP3   DS    0H
         PUT   (R5),RESTREC       WRITE RECORD
         MVI   RESTVSER+6,C' '    TURN FLAG FOR 2ND VOLSER OFF
         LA    R3,6(0,R3)         R3 -> TO NEXT VOLSER
         BCT   R2,VLOOP2          -1 FOR THIS VOLSER
*
         SPACE 1
NOVOL2C  DS    0H
         B     RESTM8             END FOR NOW
         DROP  R5                 DROP DCB BASE
         DROP  R6                 DROP RECORD BASE
         SPACE 1
RESTM7   DS    0H
         MVI   RESTM1+1,X'F0'     SAY NO FILE
         SPACE 1
RESTM8   DS    0H
         L     R15,COPYRC         LOAD RETURN CODE
         SPACE 1
COPYUSRE SECEXIT
         SPACE 2
SPCFLAG  DC    C'0'
DWORD    DS    D
COPYRC   DC    F'0'
*
         ENTRY VOLSER2,OLC120B
VOLSER2  DC    CL31' '            ROOM FOR 5 VOLSERS
PATN     DC    X'4020202020'      SET UP EDIT PATTERN
OLC120   DC    CL81' '
         ORG   *-81
         DC    AL1(MSGPRT)
         DC    C'DSB120 - ABOVE '
OLC120A  DC    CL2'PO'            DEFAULT FILE TYPE IS PO
         DC    C' DATASET COPIED TO FILE '
OLC120F  DC    CL4'0001'
         DC    C' ON TAPE '
OLC120B  DC    CL6' '             TAPE VOLSER GOES HERE
OLC120C  DC    C','
OLC120D  DC    4CL7' '            ROOM FOR 4 MORE VOLSERS
         ORG   OLC120+81
*
OLC120E  DC    CL81' '
         ORG   *-81
         DC    AL1(MSGPRT)
         DC    C'DSB120E - WARNING.... THIS COPY HAD A NON-ZERO'
         DC    C' RETURN CODE. CHECK OUTPUT......'
         ORG   OLC120E+75
         DC    CL5'ERROR'
         ORG   OLC120E+81
         SPACE 1
OLC120R  DS    0CL81
         DC    AL1(MSGPRT)
         DC    C'DSB120R - ABOVE '
OLC120AR DC    CL2'PO'            DEFAULT FILE TYPE IS PO
         DC    C' DATASET RESTORED FROM FILE '
OLC120FR DC    CL4'0001'
         DC    C' ON TAPE '
OLC120BR DC    CL6' '             TAPE VOLSER GOES HERE
         DC    CL(81-(*-OLC120R))' '
*
OLC121   DC    CL81' '
         ORG   *-81
         DC    AL1(MSGPRT)
         DC    CL14' '
         DC    C' DSN='
OLC121M  DC    CL44' '
         ORG   OLC121+81
*
OLC122   DC    CL81' '
         ORG   *-81
         DC    AL1(MSGPRT)
         DC    C'DSB122 - FOR RESTORE, USE '
OLC122M  DC    CL54' '
         ORG   OLC122+81
PSREST   DC    C'IEBGENER OR ANY SEQUENTIAL COPY PGM'
DAREST   DC    C'A DIRECT ACCESS LOAD PROGRAM'
POREST   DC    C'PDSFAST OR IEBCOPY'
VSREST   DC    C'IDCAMS IMPORT COMMAND'
         SPACE 1
         ENTRY RESTREC    ,RESTTYPE,RESTVSEQ,RESTDSN
         DS    0F                 PUT ON FULLWORD BOUNDARY...
RESTREC  DC    CL200' '
RESTRECD DSECT
RESTDSN2 DC    CL44' '            DISK DATASET NAME
         DC    C' '
RESTTYPE DC    CL2' '
         DC    C' '
RESTVSER DC    CL6' '
         DC    C' '
RESTVSEQ DC    CL4' '
         DC    C' '
RESTUSED DC    CL4' '             NBR OF TRKS USED
         DC    C' '
RESTSECN DC    CL4' '             SECONDARY ALLOCATION
         DC    C' '
RESTDIR  DC    CL4' '             NUMBER OF DIR BLOCKS IF PDS
         DC    C' '
RESTBLK  DC    CL5' '             BLKSIZE
         DC    C' '
RESTLREC DC    CL5' '             LRECL
         DC    C' '
RESTRCFM DC    CL3' '             DATASET RECFM
         DC    C' '
RESTALOC DC    CL3'CYL'           TYPE OF ALLOCATION
         DC    C' '
RESTVOL  DC    CL6' '             VOLSER FOR UNCATALOGUED DATASETS,
         DC    C' '
RESTDSN  DC    CL44' '            TAPE DATASET NAME
*                                 OR THE VOLSER OF THE CATALOG FOR VSAM
         DC    CL(L'RESTREC-(*-RESTDSN2))' ' FOR FUTURE EXPANSION.. RH
*
 TITLE 'DYNFREE - FREE A USER LIBRARY'
*
*  FREE A USER LIBRARY'
*
         DS    0H
DYNFREE  SECTION
*
         L     R4,=V(INFILE)      R4 -> TO SYSUT1 DCB
         TM    48(R4),X'10'       DID SYSUT1 GET CLOSED?
         BZ    NOCLOSE4           YES
         CLOSE ((4))              NO, CLOSE IT
         USING IHADCB,R4          SET R4 AS DCB DSECT
         L     R15,DCBBUFCB       R15 = A(BUFFER)
         BCTR  R15,0              -1
         LTR   R15,R15            IS THERE A BUFFER?
         BZ    NOPOOL10           NO
         DROP  R4                 DROP R4 AS DCB DSECT
         FREEPOOL ((4))           FREE BUFFER POOL BECAUSE DUMB
*                                 IBM DON'T
         SPACE
NOPOOL10 DS    0H
         SPACE 1
NOCLOSE4 DS    0H
         L     R4,=V(SYSUT2)      R4 -> TO SYSUT2 DCB
         TM    48(R4),X'10'       DID SYSUT2 GET CLOSED?
         BZ    NOCLOSE5           YES
         CLOSE ((4))              NO, CLOSE IT THEN
         USING IHADCB,R4          SET R4 AS DCB DSECT
         L     R15,DCBBUFCB       R15 = A(BUFFER)
         BCTR  R15,0              -1
         LTR   R15,R15            IS THERE A BUFFER?
         BZ    NOPOOL11           NO
         DROP  R4                 DROP R4 AS DCB DSECT
         FREEPOOL ((4))           FREE BUFFER POOL BECAUSE DUMB
*                                 IBM DON'T
         SPACE
NOPOOL11 DS    0H
         SPACE 1
NOCLOSE5 DS    0H
         SR    R15,R15            MAKE SURE R15 = 0
         L     R2,=V(FREEFLAG)    R2 -> TO FREEFLAG
         TM    0(R2),X'80'        DID THE ALLOCATE WORK?
         BZ    DYNFRET            NO, DON'T TRY TO FREE IT
*
*              APR 4/95...IT LOOKS LIKE SOMETHING HAS CHANGED AND
*              THE VSAM DATASET IS NOT ALLOCATED, SO DON'T TRY
*              TO FREE IT....
*
         L     R3,=V(RESTREC)     R3 -> TO RESTORE RECORD
         USING RESTRECD,R3        SET RECORD BASE
         CLC   RESTTYPE,=C'VS'    IS IT A VSAM FILE?
         BE    DYNFRET            YES, DON'T TRY TO FREE IT
         DROP  R3                 DROP RECORD BASE
         SPACE 1
         LA    R2,DYNRB2          CLEAR OUT RETURN AREA
         USING S99RB,R2
         XC    S99RSC,S99RSC
         LA    R1,DYNPTR2         POINTER TO PARM LIST FOR DYNALLOC
         DYNALLOC
         LTR   R11,R15            SAVE RET CODE OVER MSG PRINT
         BZ    DYNFRET            IT WAS OKAY
         SPACE 1
         AGO   .SKIP99
         L     R1,=V(PARMOLC)     R1 -> TO INPUT PARM
         CLC   =C'RESTORE',0(R1)  IS THIS A RESTORE?
         BNE   SENDMSG            NO
         SPACE 1
         L     R4,=V(SYSUT2)      R4 -> TO SYSUT2 DCB
*        USING IHADCB,R4          SET DCB DSECT
         TM    48(R4),X'10'       IS SYSUT2 OPEN ?
         BZ    SENDMSG            NO, TOO BAD
         CLOSE ((4))              CLOSE IT THEN
         USING IHADCB,R4          SET R4 AS DCB DSECT
         L     R15,DCBBUFCB       R15 = A(BUFFER)
         BCTR  R15,0              -1
         LTR   R15,R15            IS THERE A BUFFER?
         BZ    NOPOOL12           NO
         DROP  R4                 DROP R4 AS DCB DSECT
         FREEPOOL ((4))           FREE BUFFER POOL BECAUSE DUMB
*                                 IBM DON'T
         SPACE
NOPOOL12 DS    0H
*                                 TRY FREEING IT AGAIN
         LA    R2,DYNRB2          CLEAR OUT RETURN AREA
         USING S99RB,R2
         XC    S99RSC,S99RSC
         LA    R1,DYNPTR2         POINTER TO PARM LIST FOR DYNALLOC
         DYNALLOC
         LTR   R11,R15            SAVE RET CODE OVER MSG PRINT
         BZ    DYNFRET            IT WAS OKAY
         SPACE 1                                                    RH1
SENDMSG  DS    0H
.SKIP99  ANOP
         L     R2,=V(USRDSN)      GET ADDRESS OF INPUT DSNAME
         MVC   OLC009M,0(R2)       MOVE DSNAME TO ERROR MSG
         OLCMSG OLC009
         L     R2,=V(OLC007W)     GET ADDRESS OF MSG
         L     R3,=V(HEXTRANS)    GET ADDRESS OF TRANS TABLE
         L     R4,=V(OLC007ER)    GET ADDRESS OF MSG
         L     R5,=V(OLC007IN)    GET ADDRESS OF MSG
         UNPK  0(9,R2),S99RSC(5)  MAKE HEX RETURN CODE PRINTABLE
         TR    0(8,R2),0(R3)      TRANSLATE
         MVC   0(4,R4),0(R2)      MOVE ERROR CODE TO TEXT LINE
         MVC   0(4,R5),4(R2)      MOVE INFO CODE TO TEXT LINE
         L     R2,=V(OLC007)      GET ADDRESS OF MSG
         OLCMSG 0(0,R2)
         LA    R15,36             END FOR NOW
*        SR    R15,R15            IGNORE DE-ALLOC ERRORS (FOR NOW)
         SPACE 1
DYNFRET  SECEXIT
         DROP  R2                 DROP RB BASE
         SPACE 2
OLC009   DC    CL81' '
         ORG   *-81
         DC    AL1(MSGPRT)
         DC    C'DSB009 - DE-ALLOCATE FAILED FOR DSN: '
OLC009M  DC    CL44' '
         ORG   OLC009+81
DYNPTR2  DC    0F'0',X'80',AL3(DYNRB2)
DYNRB2   DC    0F'0',AL1(20,S99VRBUN,0,0),AL4(0,DYNTUPLU,0,0)
DYNTUPLU DC    X'80',AL3(DYNTUNT3)
*
 TITLE 'ESTAEOF  - TURN OFF ESTAE'
*
*  TURN OFF ESTAE
*
         DS    0H
ESTAEOF  SECTION
         ESTAE    0               TURN OFF MOST CURRENT ESTAE
         LTR   R15,R15            WENT OFF OK?
         BZ    RETESTH            GO RETURN TO CALLER
         LR    R9,R15             ESTAE RETURN CODE WAS NOT = 0
         CVD   R15,ESTHRC
         OI    ESTHRC+7,X'0F'     MAKE POSITIVE
         UNPK  OLC017RC,ESTHRC
         OLCMSG OLC017
         LR    R15,R9             SET RETURN CODE
RETESTH  SECEXIT
         SPACE    2
OLC017   DC    CL81' '
         ORG   *-81
         DC    AL1(MSGPRT)
         DC    C'DSB017 - NON-ZERO RETURN CODE FROM ESTAE CANCEL. RC='
OLC017RC DC    CL7' '
         ORG   OLC017+75
         DC    CL5'ERROR'
         ORG   OLC017+81
ESTHRC   DC       D'0'
 TITLE 'STAEEXIT - RECEIVE CONTROL IF AN ABEND OCCURS'
STAEEXIT CSECT
STAEEXIT AMODE 24
STAEEXIT RMODE 24
**********************************************************************
***                                                                ***
***             S T A E   E X I T   R O U T I N E                  ***
***                                                                ***
**********************************************************************
         SPACE    2
         USING    STAEEXIT,R10
         LR       R10,R15          SET UP BASE REGISTER R10
         LR       R8,R14           R8 <--- RETURN ADDRESS TO RTM
         LM       R4,R7,=V(RUBAREA,ABENDCDE,STAERTRY,SYNCSAVE)
         C        R0,=F'12'        NO SDWA ALLOCATED ?
         BE       NOSDWA
         SPACE    1
* PREPARE THE REGISTER UPDATE BLOCK USED TO SET UP REGS FOR RETRY:
         MVC      2(L'RUBREGS,R4),0(R7)  SET UP THE RUB REGISTERS
*                                        FROM SYNCSAVE
         MVC      RUBREG7,=X'FFFFABED' SET R7 IN RUB TO SHOW THAT
*                                      WE ARE IN ABEND
         USING    SDWA,R1
         PRINT   GEN
         SETRP    RETADDR=(R6),RC=4,FRESDWA=YES,RETREGS=YES,           +
               RUB=(R4),DUMP=NO
         PRINT NOGEN
         MVC      5(3,R5),SDWACMPC     GET ABEND CODE
         MVC      0(4,R5),SDWACTL1+4   GET ABEND ADDRESS
         MVI      0(R5),X'00'     CLEAR 1ST BYTE
         L     R2,SDWAGR12        R2 = CSECT BASE REG
         MVC   8(8,R5),=CL8'??'   ASSUME NO CSECT NAME
         CLI   5(R2),C'A'         IS THERE A CSECT NAME?
         BL    NOCSECT            NO
         CLI   5(R2),C'Z'         IS THERE A CSECT NAME?
         BH    NOCSECT            NO
         MVC   8(8,R5),5(R2)      SAVE CSECT NAME
         L     R15,0(0,R5)        R15 = ABEND ADDRESS
         SR    R15,R2             R15 = OFFSET IN CSECT
         ST    R15,0(0,R5)        PASS OFFSET TO RETRY RTN
         SPACE 1
NOCSECT  DS    0H
         BR       R8              RETURN TO RTM SO HE CAN GO TO RETRY
         SPACE    2
NOSDWA   LA       R15,4                ASK FOR RETRY ANYWAY ????
*                                      WHAT ABOUT MY REGS AT RETRY????
         LA       R0,0(,R6)            SET UP RETRY ADDRESS
         ST       R1,4(0,R5)           STORE THE ABEND CODE
         MVC      0(4,R5),=XL4'AAAAAAAA'  ABEND ADDRESS UNKNOWN
*        ST       R1,0(,R5)            STORE THE ABEND CODE
*        MVC      4(4,R5),=XL4'AAAAAAAA'  ABEND ADDRESS UNKNOWN
         BR       R8              RETURN TO RTM SO HE CAN GO TO EXIT
         LTORG
         SPACE 2
**********************************************************************
*
*  STAEEXIT:
*
*        S T A E   R E G I S T E R   U P D A T E   B L O C K  (RUB)
*
**********************************************************************
         SPACE    1
         ENTRY  RUBREGS,RUBAREA
         CNOP   2,4                   GUARANTEE NOT FULLWORD ALLIGN
RUBAREA  DC     XL2'FFFF'           SET UP TO RESTORE ALL REGS
RUBREGS  DS     0CL64
RUBREG0  DC     F'1311'  THIS ARE SET BY ESTAE EXIT TO CORRECT VALUE
RUBREG1  DC     F'1311'     "       RUB FOR SEGMENT ADDRESS
RUBREG2  DC     F'1311'             RUB FOR SEGMENT ADDRESS
RUBREG3  DC     F'1311'             RUB FOR SEGMENT ADDRESS
RUBREG4  DC     F'1311'             RUB FOR SEGMENT ADDRESS
RUBREG5  DC     F'1311'             RUB FOR SEGMENT ADDRESS
RUBREG6  DC     F'1311'             RUB FOR SEGMENT ADDRESS
RUBREG7  DC     F'1311'             RUB FOR SEGMENT ADDRESS
RUBREG8  DC     F'1311'             RUB FOR SEGMENT ADDRESS
RUBREG9  DC     F'1311'             RUB FOR SEGMENT ADDRESS
RUBREG10 DC     F'1311'             RUB FOR SEGMENT ADDRESS
RUBREG11 DC     F'1311'             RUB FOR SEGMENT ADDRESS
RUBREG12 DC     F'1311'             RUB FOR SEGMENT ADDRESS
RUBREG13 DC     F'1311'             RUB FOR SEGMENT ADDRESS
RUBREG14 DC     F'1311'             RUB FOR SEGMENT ADDRESS
RUBREG15 DC     F'1311'             RUB FOR SEGMENT ADDRESS
**********************************************************************
         DROP  R1,R10
 TITLE 'MSGRTN - MESSAGE PRINT ROUTINE'
         DS    0H
MSGRTN   SECTION
*
* ERROR RTN. PUT OUT ALL SORTS OF ERROR MSGS. ABEND IF NECESSARY.
*    WARNING - THIS CODE IS NOT REENTRANT. IN CASE OF MULTI-TCB IMPL.
*
         USING MSGDSECT,R2        R1 POINTS TO MSG
         LR    R2,R1              CANNOT USE R1 OVER SYSTEM CALLS
         TM    MSGCODE,MSGWTL     REQUESTED TO WRITE TO LOG ?
         BNO   MSGLPUT            NO, JUMP OVER
         MVC   WTLL+8(L'MSGBLK),MSGBLK BLANK OUT THE MSG AREA WTLL
         MVC   WTLL+8(L'MSGTEXT),MSGTEXT
         WTO   MF=(E,WTLL)        WRITE MSG TO THE JOB LOG
MSGLPUT  TM    MSGCODE,MSGPRT     REQUESTED TO WRITE TO OLCPRINT ?
         BNO   MSGLWTOG           NO, JUMP OVER
         L     R5,=V(OLCPRINT)     LOAD DCB ADDRESS
         PUT   (R5),MSGTEXT       WRITE MSG ON OLCPRINT
MSGLWTOG TM    MSGCODE,MSGWTOLG   REQ TO WRITE CONSOLE EYECATCHER ?
         BNO   MSGLWTO            NO, JUMP OVER
         MVC   WTOL+8(L'MSGBLK),MSGBLK BLANK OUT THE MSG AREA WTOL
         MVC   WTOL+8(L'WTOEYE1),WTOEYE1
         WTO   MF=(E,WTOL)        WRITE EYECATCHER TO CONSOLE
         MVC   WTOL+8(L'MSGBLK),MSGBLK BLANK OUT THE MSG AREA WTOL
         MVC   WTOL+8(L'WTOEYE2),WTOEYE2
         WTO   MF=(E,WTOL)        WRITE EYECATCHER TO CONSOLE
         MVC   WTOL+8(L'MSGBLK),MSGBLK BLANK OUT THE MSG AREA WTOL
         MVC   WTOL+8(L'WTOEYE3),WTOEYE3
         WTO   MF=(E,WTOL)        WRITE EYECATCHER TO CONSOLE
         MVC   WTOL+8(L'MSGBLK),MSGBLK BLANK OUT THE MSG AREA WTOL
         MVC   WTOL+8(L'WTOEYE2),WTOEYE2
         WTO   MF=(E,WTOL)        WRITE EYECATCHER TO CONSOLE
MSGLWTO  TM    MSGCODE,MSGWTO     REQUESTED TO WRITE TO CONSOLE ?
         BNO   MSGWTOG2           NO, JUMP OVER
         MVC   WTOL+8(L'MSGBLK),MSGBLK BLANK OUT THE MSG AREA WTOL
         MVC   WTOL+8(L'MSGTEXT),MSGTEXT
         WTO   MF=(E,WTOL)        WRITE MSG TO CONSOLE
MSGWTOG2 TM    MSGCODE,MSGWTOLG   REQ TO WRITE CONSOLE EYECATCHER ?
         BNO   MSGLSGNL           NO, JUMP OVER
         MVC   WTOL+8(L'MSGBLK),MSGBLK BLANK OUT THE MSG AREA WTOL
         MVC   WTOL+8(L'WTOEYE2),WTOEYE2
         WTO   MF=(E,WTOL)        WRITE EYECATCHER TO CONSOLE PART 2
         MVC   WTOL+8(L'MSGBLK),MSGBLK BLANK OUT THE MSG AREA WTOL
         MVC   WTOL+8(L'WTOEYE1),WTOEYE1
         WTO   MF=(E,WTOL)        WRITE EYECATCHER TO CONSOLE PART 2
MSGLSGNL DS    0H
         SPACE 1                                                    RH
MSGLABND TM    MSGCODE,MSGABND    REQUESTED TO ABEND ?
         BNO   MSGRC0             NO - THEN RETURN WITH RC=0
         ABEND 1211,DUMP
         SPACE 1                                                    RH
MSGRC0   DS    0H
         LA    R15,0              RC = 0                            RH
         SPACE 1                                                    RH
MSGEXIT  SECEXIT                  RETURN TO CALLER
         DROP  R2
* WTLL BELOW MUST BE 88 LONG TO HANDLE 80 BYTE MSGS.
WTLL     WTO      '                                                    +
                                                    ',MF=L,  LEN=88    +
               ROUTCDE=11
* WTOL BELOW MUST BE 88 LONG TO HANDLE 80 BYTE MSGS.
WTOL     WTO      '                                                    +
                                                    ',MF=L,  LEN=88    +
               ROUTCDE=11         ROUTCDE=1 WHEN TO CONSOLE
WTOEYE1  DC       CL45'**********************************************'
WTOEYE2  DC       CL45'***                                        ***'
WTOEYE3  DC       CL45'***        ATTENTION - IMSTEST MTO         ***'
*
MSGBLK   DC       CL80' '    TO BLANK OUT THE WTOL AND WTLL AREAS
*                 CL80  ABOVE MUST BE LENGTH 80 IF WTOL AND WTLL LISTS
*                       ARE 88 LONG. ALL MSG HAVE 1ST 4 CHARS AS BLANK
*                       SO AS NOT TO CLOBBER STUPID WTL MACRO.
*-----------------------------------------------------------------
*
         SPACE 2
MSGDSECT DSECT
MSGCODE  DS       X
MSGPRT   EQU      X'01' PRINT THE MSG ON DDNAME=OLCPRINT
MSGWTL   EQU      X'02' WRITE THE MSG TO THE JOB LOG
MSGWTO   EQU      X'04' WRITE THE MSG TO THE OPERATOR CONSOLE/SYSLOG
MSGWTOLG EQU      X'08' WRITE A LARGE EYE CATCHER ON THE CONSOLE/SYSLOG
MSGSGNL  EQU      X'10' START THE "SIGNAL" MESSAGE REGION
MSGABND  EQU      X'80' ABEND AFTER PUTTING OUT MSGS AND SIGNAL MPR
MSGTEXT  DS       CL80  THE TEXT OF THE ERROR MSG
         SPACE    2
         AGO   .NOBLKS
 TITLE 'USERBLKS - GET BLKSIZE OF USER DATASET'
*
*
USERBLKS SECTION
         L     R1,=V(HOLDDCB)     R1 -> TO HOLD DCB                 RH
         USING IHADCB,R1
         MVC   DCBDDNAM,=C'USERLIB ' PUT USER DDNAME INTO DCB       RH
         DROP  R1
         STCM  R1,7,USRJFCB       PUT A(DCB) INTO RDJFCB BLOCK      RH
         L     R2,=V(USRDSN)      R2 -> TO USER DATASET NAME        RH
         SPACE 1
*        RDJFCB (1)               GET THE USER JFCB                 RH
         CNOP  0,4                GET ON TO A FULLWORD BOUNDARY     RH
         BAL   R1,JFCBSVC         POINT R1 TO DCB ADDRESS, DO SVC   RH
         DC    X'80'              1ST BYTE IS 80                    RH
USRJFCB  DC    AL3(0)             DCB ADDRESS, SET ABOVE            RH
JFCBSVC  SVC   64                 DO RDJFCB                         RH
         LTR   R15,R15            GET IT?                           RH
         BNZ   USRABEND           IF NOT  NO BLKSIZE                RH
         L     R1,=V(HOLDJFCB)    R1 -> TO USER JCFB                RH
         USING IHAJFCB,R1
         L     R2,=V(HBLKSIZE)    R2 -> TO HOLD BLKSIZE             RH
         LH    R2,0(0,R2)         R2 = HOLD BLKSIZE                 RH
         CH    R2,JFCBLKSI        HOLD BLKSIZE >= LIB BLKSIZE       RH
         BNL   USRRETN            YES, BLKSIZE IS OKAY              RH
         DROP     R1
         OLCMSG   OLC080          SEND MSG                          RH
         B     USRERR             GO SET RC AND RETURN              RH
         SPACE    2
USRABEND DS       0H
         OLCMSG   OLC070          SEND MSG AND SET RC               RH
USRERR   DS    0H
         LA    R15,4              SET RC = 4
         B     USRRETN2           RETURN
USRRETN  DS    0H
         SR    R15,R15            SET RC = 0
USRRETN2 DS    0H
USRRETN9 SECEXIT                  RETURN TO CALLER
         EJECT
*
* USERBLKS DATA:
*
OLC070   DC    AL1(MSGWTL+MSGWTOLG+MSGWTO+MSGSGNL+MSGABND)
         DC    C'OLC070 - RDJFCB FAILED, DATASET NOT PROCESSED'
         DC    CL(81-(*-OLC070))'  '
OLC080   DC    AL1(MSGWTL+MSGPRT)
         DC    C'OLC080 - BLKSIZE TOO LARGE, DATASET NOT PROCESSED'
         DC    CL(81-(*-OLC080))'  '
.NOBLKS  ANOP
         PRINT     GEN
 TITLE 'SCRATCHU - READ/CLEAR OUT LIBRARY DIRECTORY'
         DS    0H
SCRATCHU SECTION
*
         USING    IHADCB,R5          DCB BASE
         L     R1,=V(PARMOLC)     R1 -> TO INPUT PARM
         CLC   =C'RESTORE',0(R1)  IS THIS A RESTORE?
         BE    SCRCHU             YES
         MVI   SCRFLAG,C'B'       NO, SET FLAG
         LA       R5,IDCB         R5 -> TO INPUT DCB
         MVI   DCBDDNAM+5,C'1'    CHANGE DDNAME TO SYSUT1
         SPACE 1
SCRCHU   DS    0H
***********************************************************************
* SET UP THE OUTPUT DATASET
***********************************************************************
*
* FILL IN THE DCB
*
         LA       R5,ODCB
*
* ISSUE DEVTYPE TO GET DEVICE INFO
*
         DEVTYPE  DCBDDNAM,DEVINFO,DEVTAB
         LTR      R15,R15            ANY ERRORS?
         BNZ      SCRERR1            THEN PRINT MSG AND RETURN
*
* OPEN THE DIRECTORY FOR INPUT
*
         OPEN     (IDCB,(INPUT))
         LA       R5,IDCB            INPUT DCB
         TM       DCBOFLGS,DCBOFOPN  OPEN OKAY?
         BZ       SCRERR2            IF NOT THEN PRINT MSG AND RETURN
         CLI   SCRFLAG,C'B'       IS THIS A BACKUP?
         BE    READDIR1           YES
*
* OPEN THE DIRECTORY FOR OUTPUT
*
         OPEN     (ODCB,(OUTPUT))
         LA       R5,ODCB            OUTPUT DCB
         TM       DCBOFLGS,DCBOFOPN  OPEN OKAY?
         BZ       SCRERR1            IF NOT THEN PRINT MSG AND RETURN
         DROP     R5
*
* POINT TO THE FIRST DIRECTORY RECORD
*
         POINT    ODCB,=F'512'       POINT TO DIRECTORY
*
* ISSUE XDAP MACRO WRITE A RECORD OF ALL 'FF' TO INDICATE EMPTY PDS
*
         XDAP     XDAPECB,WI,ODCB,FOX,8+256,,DCBFDAD-IHADCB+ODCB
         WAIT     ECB=XDAPECB        WAIT FOR COMPLETION OF XDAP
READDIR1 DS       0H
         POINT    IDCB,=F'512'       POINT TO DIRECTORY
         LA    R2,1               SET R2 TO 1
*        SR    R2,R2              CLEAR R2
*
* LOOP TO COUNT DIRECTORY RECORDS
*
READLOOP DS       0H
*
* READ DIRECTORY BLOCKS
*
         READ     RDECB,SF,IDCB,DUMMY,256   READ
         CHECK    RDECB              WAIT FOR COMPLETION OF READ
         LA    R2,1(0,R2)         ADD 1 TO COUNTER
         B        READLOOP           DO IT AGAIN
*
* GET HERE VIA EODAD AT END OF DIRECTORY
*
ENDREAD  DS       0H
         CLI   SCRFLAG,C'B'       IS THIS A BACKUP?
         BE    READDIR2           YES
         NOTE     IDCB             GET TTR OF LAST DIRRECTORY BLOCK
         STH      R1,DEVCYLS       SAVE NUM RECS ON THIS TRK
         AH       R1,=H'256'       INCREMENT RECORD # TO POINT TO EOF
         ST       R1,DCBRELAD-IHADCB+ODCB STORE TTR IN DCB SO THAT
*                                  NEXT STOW WILL POINT TO FIRST MEMBER
*                                  - IT WILL ALSO BE USED AS POINT PARM
         EJECT
**************************************************************
*       CALL STAR ROUTINE TO CALCULATE THE TRACK BALANCE     *
*       REMAINING AFTER THE LAST DIRECTORY BLOCK.            *
**************************************************************
         LA       R0,STARDEND-STARDSEC SIZE OF STAR AREA
         GETMAIN  R,LV=(0)         GET STORAGE
         STM      R2,R13,STARSAVE-STARDSEC(R1) SAVE REGISTERS
         LR       R2,R1            SET STAR AREA BASE
         USING    STARDSEC,R2
         XC       STARDSEC(12),STARDSEC CLEAR STAR AREA
         L        R4,DCBDVTBL-IHADCB+ODCB DEV CHAR ENTRY
         LA       R4,0(R4)
         SR       R0,R0            CLEAR RKDD REGISTER
         ICM      R0,8,DCBRELAD+2-IHADCB+ODCB LAST R +1
         ICM      R0,4,=X'08'      SET KEY LENGTH (8)
         ICM      R0,3,=H'256'     SET DATA LENGTH (256)
         LA       R1,STARDSEC      ADDRESS OF STAR AREA
         TRKCALC  FUNCTN=TRKBAL,DEVTAB=(R4),RKDD=(R0),                 X
               MF=(E,(1))
         STH      R0,DCBTRBAL-IHADCB+ODCB TRACK BALANCE
         LR       R1,R2            STAR AREA BASE
         LM       R2,R13,STARSAVE-STARDSEC(R1) RELOAD REGS
         DROP     R2
         LA       R0,STARDEND-STARDSEC SIZE TO FREE
         FREEMAIN R,LV=(0),A=(1)   FREE STORAGE
         L        R1,DCBRELAD-IHADCB+ODCB     RELOAD ADJ TTR
         MVI      DCBDIRCT+1-IHADCB+ODCB,0 INDICATE THAT LAST
*                                  DIRECTORY BLOCK IS UNUSED
         CL       R1,=F'512'       ONLY ONE DIRECTORY BLOCK?
         BH       NOTONEB          NO
         MVI      DCBDIRCT+1-IHADCB+ODCB,12 INDICATE 12 BYTES USED
NOTONEB  DS       0H               POINT TO START OF MEMBER SPACE
         POINT    ODCB,DCBRELAD-IHADCB+ODCB
         OI       DCBOFLGS-IHADCB+ODCB,X'80' SET WRITE BIT IN DCB SO
*                                  THAT DCBFDAD IS USED TO UPDATE DSCB
*                                  AND DCBTRBAL IS CONSIDERED VALID
*
* CLOSE THE OUTPUT DATASET
*
         CLOSE    ODCB
         SPACE 1
CLOSIDCB DS    0H
         CLOSE    IDCB
         SR    R15,R15            ZERO RETURN CODE
         B     SCRRET
         SPACE 1
READDIR2 DS    0H
         STH   R2,DIRBLKS         SAVE NBR DIRECTORY BLKS
         B     CLOSIDCB           GO CLOSE DCB
         SPACE 1
SCRERR2  EQU   *
         CLOSE ODCB
SCRERR1  EQU   *
         L     R2,=V(USRDSN)      GET ADDRESS OF INPUT DSNAME
         MVC   OLC004M,0(R2)      MOVE DSNAME TO ERROR MSG
         OLCMSG OLC004
         LA    R15,4              INDICATE EMPTY LIBRARY
SCRRET   SECEXIT
         EJECT
***********************************************************************
* SCRATCHU CONSTANTS AND DEFINITIONS
***********************************************************************
OLC004   DC    CL81' '
         ORG   *-81
         DC    AL1(MSGWTL+MSGPRT)
         DC    C'OLC004 - ERROR IN CLEARING DS: '
OLC004M  DC    CL44' '
         ORG   OLC004+81
*
* DUMMY DIRECTORY ENTRY FOR XDAP
*
FOX      DC       8X'FF'           HARDWARE DEFINED KEY
         DC       AL2(14)          LENGTH OF DUMMY ENTRY
         DC       8X'FF'           NAME OF DUMMY ENTRY
         DC       4X'0'            TTRC
DUMMY    DC       256X'00'         256 BYTE DUMMY RECORD
         PRINT   NOGEN
ODCB     DCB   MACRF=(W),DSORG=PO,EXLST=EXLST,DDNAME=SYSUT2
IDCB     DCB   MACRF=(R),DSORG=PO,EODAD=ENDREAD,EXLST=EXLST,RECFM=U,   +
               DDNAME=SYSUT2
EXLST    DS    0F
         DC    AL1(133)
         DC    AL3(DCBEXI2)        ADDR OF EXIT ROUTINE
         DROP  R12                DROP SECTION BASE
DCBEXI2  DS    0H
         USING IHADCB,R1
         USING *,R15
         L     R5,DEVBLKSZ         GET MAX BLOCK SIZE
         OC    DCBBLKSI,DCBBLKSI   DO WE HAVE A BLOCK SIZE?
         BNZ   DCBEXI2A            YES - BRANCH
         STH   R5,DCBBLKSI         NO - USE TRACK CAPACITY
DCBEXI2A DS    0H
         BR    R14
         SPACE 1
SCRFLAG  DC    C' '               BACKUP/RESTORE FLAG
         ENTRY DIRBLKS
DIRBLKS  DC    H'0'               NUMBER OF DIR BLKSG
DEVINFO  DS    0D
         DS    F
DEVBLKSZ DS    F                   MAX TRACK CAPACITY
DEVCYLS  DS    H                   NUMBER OF CYLS ON DEVICE
DEVTRKS  DS    H                   NUMBER OF TRKS ON DEVICE
DEVMTRKL DS    H                   MAXIMUM TRACK LENGTH
DEVKBNL  DS    X                   KEYED BLOCK OVERHEAD - NOT LAST
DEVKBL   DS    X                   KEYED BLOCK OVERHEAD - LAST
DEVNKB   DS    X                   NON KEYED BLOCK OVERHEAD
DEVTOLFG DS    X                   DEVICE TOLERANCE FLAG
DEVTOLRQ EQU   X'01'                  TOLERANCE FACTOR REQUIRED
DEVOHHWD EQU   X'08'                  BLOCK OVERHEAD HALFWORD
DEVTOLFT DS    H                   TOLERANCE FACTOR AMOUNT
STARDSEC DSECT
         TRKCALC MF=D              STAR PARAMETER AREA
STARSAVE DS    12F                 REGISTER SAVEAREA
STARDEND DS    0F                  SIZE DELIMITER
         DROP  R15
*
*
 TITLE 'READ VTOC TO GET DSCB FOR DATA SET'
         DS    0H
RDVTOC   SECTION DROP=NO
*
*/*
***********************************************************************
*                                                                     *
*             MODULE NAME = VTOCRD                                    *
*                                                                     *
*             DESCRIPTIVE NAME =  VRH SUPPLIED ROUTINE TO READ A      *
*                RECORD FROM A VTOC USING THE DATASET NAME AS THE     *
*                KEY.                                                 *
*                                                                     *
*                 REGISTER CONVENTIONS = STANDARD CONVENTIONS.        *
*                    REGISTERS 0 - 2   = WORK REGISTERS               *
*                    REGISTERS 3 - 11  = UNUSED                       *
*                    REGISTERS 12      = BASE REGISTER                *
*                    REGISTER  13 -15  = STANDARD OS USAGE            *
*                                                                     *
*                ATTRIBUTES = PROBLEM STATE                           *
*                                                                     *
*             ENTRY POINTS = VTOCRD                                   *
*                                                                     *
*             INPUT = DATASET NAM E                                   *
*                                                                     *
*             OUTPUT = NONE                                           *
*                                                                     *
*             EXIT - NORMAL = AT PROGRAM END VIA BRANCH REGISTER 14   *
*                                                                     *
*                OUTPUT = NONE                                        *
*                                                                     *
*                RETURN CODE = ZERO                                   *
*                                                                     *
*             EXIT - ERROR = NONE                                     *
*                                                                     *
*                OUTPUT = NONE                                        *
*                                                                     *
*                RETURN CODE = 16  DD-STATEMENT 'VTOC' IS MISSING     *
*                                                                     *
*             EXTERNAL REFERENCES =                                   *
*                                                                     *
*                ROUTINES = NONE                                      *
*                                                                     *
*                DATA AREAS = NONE                                    *
*                                                                     *
*                CONTROL BLOCKS = DSCB, JFCB, TIOT, DCB               *
*                                                                     *
*             TABLES = NONE                                           *
*                                                                     *
*             MACROS = SAVE, RETURN, RDJFCB, OPEN, CLOSE, EXTRACT,    *
*                      RESERVE, DEQ, DCB, DCBD                        *
*                                                                     *
*             CHANGE ACTIVITY = NONE                                  *
*                                                                     *
*             MESSAGES = NONE                                         *
*                                                                     *
*             ABEND CODES = NONE                                      *
*                                                                     *
***********************************************************************
         EJECT
         B     AROUND             BRANCH AROUND DUMP TITLE
         DC    C'VTOCRD'          PROGRAM NAME
         DC    CL8'&SYSDATE'      DATE WRITTEN
         DC    CL6'&SYSTIME'      TIME WRITTEN
PROGID   DC    C'VTOCRD_R01.0_&SYSDATE'
$$$CODD  DC    C'$$$CODD: COPYRIGHT DIVERSIFIED DEVELOPMENTS'
         SPACE 1
AROUND   DS    0H
*        GETMAIN R,LV=LDYNAMIC    GET CORE FOR WORK AREA
*        LR    R3,R1              R3 -> TO WORK AREA
*        USING WORK,R3            SET WORK BASE
         SPACE 3
***********************************************************************
*                                                                     *
*              UPDATE THE JFCB WITH VTOC NAME                         *
*                                                                     *
***********************************************************************
         L     R2,=V(VTOCDDN)     R2 -> TO DDNAME TO READ           RH
         MVC   VTOC+40(8),0(R2)   MOVE DDNAME TO VTOC DCB
         RDJFCB VTOC                   READ THE JFCB
         USING INFMJFCB,R2             ESTABLISH ADDRESSABILITY
         LA    R2,JFCBAREA             POINT TO JFCB
         LTR   R15,R15                 TEST IF DD CARD PRESENT
         BNZ   CLOSEIT2                NO DD CARD - BAD RETURN
         MVC   KEY,JFCBDSNM       SAVE DSNAME AS KEY
         MVC   RNAME,JFCBVOLS          SAVE VOLUME SERIAL NUMBER
         L     R15,=V(OUTDISP)    R15 -> TO OUTPUT FILE DISP        RH
         MVC   0(1,R15),JFCBIND2  SAVE DISP                         RH
         DROP  R2
         SPACE 1
OBTAIN1  DS    0H
         OBTAIN F1CAM             GET FORMAT 1
         USING IECSDSL1,R2             ESTABLISH DSCB ADDRESSABILITY
         LA    R2,FULLDSCB             POINT TO DSCB
         CLI   DS1FMTID,C'1'           IS THIS A FORMAT 1 DSCB
         BNE   NOMORE3            NO, CAN'T GET SPACE
         SPACE 1
         LH    R4,DS1LSTAR        R4 = NBR TRKS USED
         CLI   DS1LSTAR+2,X'00'   USING PART OF NEXT TRACK
         BE    *+8                NO, DON'T ADD 1
         LA    R4,1(0,R4)         + 1 IN CASE PARTIAL USED
         STH   R4,SPCUSED         SAVE SPACE USED
         L     R1,=V(VTOCSPC)     R1 -> TO SAVE SPACE FIELD
         MVC   1(2,R1),SPCUSED    PUT SPACE USED IN IT
         MVC   TRKUSED,DS1LSTAR   SAVE SPACE USED FROM DSCB
         MVC   TRKBAL,DS1TRBAL    SAVE TRACK BALANCE FROM DSCB
         MVC   SPCBLK,DS1BLKL     SAVE BLKSIZE
         MVC   SPCLRECL,DS1LRECL  SAVE LRECL
         MVC   SPCSECN,DS1SCALO+2 SAVE SECONDARY ALLOC
         MVC   DSNRECFM,DS1RECFM  SAVE RECFM                        RH
         MVC   SPCTYPE,=C'CYL'    DEFAULT TO CYLS
         CLI   DS1SCALO,X'C0'     IS IT CYLS?
         BE    CHKALLOC           YES, SEE IF SPACE ALLOC'D WANTED
         MVC   SPCTYPE,=C'TRK'    CHANGE TO TRKS
*        B     NOMORE3            ON WE GO
         SPACE 1
CHKALLOC DS    0H
         L     R5,=V(PARMFLAG)    R5 -> TO PARM FLAG                RH
         TM    0(R5),ALLOCFLG     WAS ALLOC SPECIFIED               RH
         BZ    CHKFILE            NO, USED SPACE IS WANTED
         SPACE 1
         OBTAIN F4CAM             GET FORMAT 4
         USING IECSDSL4,R5        ESTABLISH DSCB ADDRESSABILITY
         LA    R5,DSCB4           POINT TO DSCB
         CLI   DS4IDFMT,C'4'      IS THIS A FORMAT 4 DSCB
         BNE   NOF4A              NO, CAN'T GET TRKS/CYL
         SPACE 1
         LH    R3,DS4DEVSZ+2      R3 = NBR TRKS/CYL
         STH   R3,TRKPCYL         SAVE IT FOR LATER
         SPACE 1
NOF4A    DS    0H
         DROP  R5                 DROP DSCB4 ADDRESSABILITY
         BAL   R14,ALOCSPC1       GO GET SPACE ALLOCATED
         SPACE 1
         CLC   DS1PTRDS,=CL5'00'  IS THERE A FORMAT 3 DSCB ?
         BE    CHKFILE2           NO, END OF ALLOCATED SPACE
         OBTAIN F3CAM             GET FORMAT 3
         LA    R2,DSCB3           POINT TO DSCB3
*        USING IECSDSL1,R2             ESTABLISH DSCB ADDRESSABILITY
         CLI   DS1FMTID,C'3'      IS THIS A FORMAT 3 DSCB
         BNE   CHKFILE2           NO, END OF ALLOCATED SPACE
         BAL   R14,ALOCSPC3       GO GET SPACE ALLOCATED
         SPACE 1
CHKFILE2 DS    0H
         STH   R11,SPCUSED        SAVE TRKS ALLOCATED
         L     R1,=V(VTOCSPC)     R1 -> TO SAVE SPACE FIELD
         MVC   1(2,R1),SPCUSED    PUT SPACE ALLOCATED IN IT
         B     CHKFILE            END OF ALLOCATED SPACE
         DROP  R2
         SPACE 3
***********************************************************************
*                                                                     *
*              CALCULATE SPACE ALLOCATED                              *
*                                                                     *
***********************************************************************
         SPACE 3
ALOCSPC1 SR    R11,R11            CLEAR ACCUM REG
         ST    R14,RETSAVE        SAVE RETURN ADDRESS
*        LA    R2,FULLDSCB             POINT TO DSCB
         USING IECSDSL1,R2        ESTABLISH DSCB1  ADDRESSABILITY
         LA    R1,DS1EXT1         F1 FIRST EXTENT
         SR    R5,R5              CLEAR R5
         IC    R5,DS1NOEPV        NUMBER OF EXTENTS
         ST    R5,EXTKNT          SAVE NUMBER OF EXTENTS
         LTR   R5,R5              TEST FOR AN EMPTY DATA SET
         BZ    DS1RET             JUMP IF EMPTY
         C     R5,=F'4'           CHECK FOR ALL EXTENTS IN F1
         BL    EXTSS1
         LA    R5,3               SET FOR LAST 3
EXTSS1   BAL   R14,ALLSUM         SUM UP ALLOCATION
         SPACE 1
DS1RET   DS    0H
         L     R14,RETSAVE        LOAD RETURN ADDRESS
         BR    R14                RETURN TO CALLER
         DROP  R2                 DROP DSCB1 BASE
         SPACE 1
ALOCSPC3 DS    0H
         ST    R14,RETSAVE        SAVE RETURN ADDRESS
*        LA    R2,DSCB3           POINT TO DSCB3
         USING IECSDSL3,R2        ESTABLISH DSCB3 ADDRESSABILITY
         LA    R1,DS3EXTNT        START OF GROUP
         L     R5,EXTKNT          EXTENT COUNT BACK
         S     R5,=F'3'           REDUCE BY THOSE ALREADY DONE
         C     R5,=F'5'           FOUR MORE FIELDS
         BL    EXTSS2
         LA    R5,4               SET TO 4
EXTSS2   BAL   R14,ALLSUM         SUM UP SOME MORE
         L     R5,EXTKNT          GET EXTENT COUNT BACK
         S     R5,=F'7'           SET TO DO LAST 9
         BNH   EXTSS3             THRU
         LA    R1,DS3ADEXT
         BAL   R14,ALLSUM         DO LAST OF THEM
         SPACE 1
EXTSS3   DS    0H
         L     R14,RETSAVE        LOAD RETURN ADDRESS
         BR    R14                RETURN TO CALLER
         DROP  R2                 DROP DSCB BASE
         SPACE 1
ALLSUM   ST    R14,HOLD8          TAKE CARE OF FETCHING ALLOCATIONS
ALLSUM1  BAL   R14,ABTOREL        CONVERT TO RELATIVE TRACKS
         BAL   R14,LENGTH         GET LENGTH IN R7
         AR    R11,R7             TOTAL UP ALL LENGTHS FOR DS
         LA    R1,10(R1)          SET FOR NEXT
         BCT   R5,ALLSUM1         LOOP
         L     R14,HOLD8          RESTORE
         BR    R14                BACK OUT
         SPACE 1
ABTOREL  MVC   HOLD(8),2(R1)      MOVE FOR BOUNDRIES
         LH    R8,HOLD            CC
         MH    R8,TRKPCYL          CHANGE TO TRACKS
         AH    R8,HOLD+2          HH
ABTOREL2 EQU   *
         LH    R7,HOLD4           CC SECOND
         MH    R7,TRKPCYL          CHANGE TO TRACKS
         AH    R7,HOLD4+2         HH FOR SECOND
         SPACE 1
ABTOREL3 EQU   *
         SLL   R8,16              MOVE TO TOP
         ALR   R8,R7              PUT TOGETHER
         BR    R14                EXIT
         SPACE 1
LENGTH   ST    R8,HOLD            SAVE VALUE FOR TEMP
         LH    R7,HOLD+2          BRING IN LAST POSITION
         A     R7,=F'1'           UPDATE
         STH   R7,HOLD12          SAVE LAST TRACK FOR NEXT CHECK
         SH    R7,HOLD            TAKE OFF START TRACK VALUE
         BR    R14                GO ON BACK
         SPACE 1
CHKFILE  DS    0H
         CLC   SPCTYPE,=C'CYL'    SPACE ALLOCATED IN CYLS?
         BNE   NOMORE3            NO, WE ARE DONE
*
*              IF SPACE WAS ALLOCATED IN CYLS, WE MUST CONVERT
*              THE SPACE TO ALLOC FROM TRK TO CYL....
*
         SPACE 1
OBTAIN4  DS    0H
         USING IECSDSL4,R2        ESTABLISH DSCB ADDRESSABILITY
         LA    R2,DSCB4           POINT TO DSCB4
         CLI   DS4IDFMT,C'4'      IS THIS A FORMAT 4 DSCB
         BNE   NOF4               NO, CAN'T CHANGE TRK TO CYL
         SPACE 1
         SR    R4,R4              R4 = 0
         LH    R5,SPCUSED         R5 = SPACE IN TRKS
         LH    R3,DS4DEVSZ+2      R3 = NBR TRKS/CYL
         DR    R4,R3              CONVERT TRKS TO CYLS
         LTR   R4,R4              IS THERE A REMAINDER?
         BZ    OB4A               NO
         LA    R5,1(0,R5)         YES, + 1 IN CASE PARTIAL USED
         SPACE 1
OB4A     DS    0H
         LA    R5,1(0,R5)         ADD 1 FOR GOOD LUCK....
         STH   R5,SPCUSED         SAVE SPACE USED IN CYLS
         L     R1,=V(VTOCSPC)     R1 -> TO SAVE SPACE FIELD
         MVC   1(2,R1),SPCUSED    PUT SPACE USED IN IT
         SPACE 1
         SR    R4,R4              R4 = 0
         LH    R5,DS4DEVSZ+2      R5 = NBR TRKS/CYL
         LH    R3,SPCSECN         R3 = SECONDARY SPACE IN TRKS
         LTR   R3,R3              IS THERE A SEC SPACE?
         BZ    NOMORE3            NO
         DR    R4,R3              CONVERT TRKS TO CYLS
         LTR   R4,R4              IS THERE A REMAINDER?
         BZ    OB4B               NO
         LA    R5,1(0,R5)         YES, + 1 IN CASE PARTIAL USED
         SPACE 1
OB4B     DS    0H
         STH   R5,SPCSECN         SAVE SECONDARY SPACE IN CYLS
         B     NOMORE3            END FOR NOW
         SPACE 1
NOF4     DS    0H
         MVC   SPCTYPE,=C'TRK'    MUST ALLOC NEW DSN IN TRKS
         SPACE 1
CLOSEIT2 DS    0H
         SPACE 1
NOMORE3  DS    0H
*        FREEMAIN R,LV=LDYNAMIC,A=(3)  FREE GOTTEN CORE
         SPACE 3
***********************************************************************
*                                                                     *
*              RETURN TO CALLER                                       *
*                                                                     *
***********************************************************************
*
ENDVTOC  SECEXIT                  RETURN TO CALLER
         SPACE 3
* $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
*        WORK AREAS
* $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
DUMPTITL DC    C'WORKING STORAGE SECTION'
         SPACE 3
*
* MISC FIELDS
*
RETSAVE  DC    F'0'
HOLD     DC    F'0'               TEMPORARY HOLD OF R14 AND VALUES
HOLD4    DC    F'0'               TEMP WORK AREA
HOLD8    DC    F'0'               TEMP R14
HOLD12   DC    F'0'               TEMP FL   CHECK
HOLD16   DC    F'0'               TEMP R14
EXTKNT   DC    F'0'               SAVE EXTENT COUNT OF F1
TRKPCYL  DC    H'0'               SAVE TRKS/CYL
         SPACE 3
*
* DSCB I/O AREA AND CONTROL BLOCKS
*
         ENTRY RNAME
RNAME    DC    CL6' '
BLKA     DC    XL8'00'
FULLDSCB DS    0C
KEY      DC    CL44' '
DSCB     DC    XL140'00'
DSCB3    DC    XL140'00'
KEY4     DC    44X'04'
DSCB4    DC    XL140'00'
         SPACE
F1CAM    CAMLST SEARCH,KEY,RNAME,DSCB
F3CAM    CAMLST SEEK,FULLDSCB+135,RNAME,DSCB3
F4CAM    CAMLST SEEK,KEY4,RNAME,DSCB4
         SPACE
         ENTRY SPCSECN,SPCBLK,SPCLRECL,SPCUSED,SPCTYPE
         ENTRY DSNRECFM,TRKUSED,TRKBAL
SPCSECN  DC    H'0'               SECONDARY ALLOCATION
SPCBLK   DC    H'0'               BLKSIZE
SPCLRECL DC    H'0'               LRECL
SPCUSED  DC    H'0'               NBR OF TRKS USED
SPCTYPE  DC    CL3'CYL'           TYPE OF ALLOCATION
DSNRECFM DC    X'00'              DATASET RECFM
TRKUSED  DC    XL3'00'            DS1LSTAR DATA
TRKBAL   DC    H'0'               DS1TRBAL DATA
         SPACE 1
         ENTRY DSNIN,DSNINSP,DSNOUT,DSNOUTSP,VTOCDDN,VTOCSPC
         ENTRY DSNFLAG,OUTDISP
*                                 THESE MUST STAY IN THIS ORDER
DSNIN    DC    CL8'SYSUT1'        1   DEFAULT INPUT FILE NAME
DSNIFLG  DC    X'00'              2
DSNINSP  DC    XL3'000000'        3
DSNOUT   DC    CL8'SYSUT2'        4   DEFAULT OUTPUT FILE NAME
DSNOFLG  DC    X'00'              5
DSNOUTSP DC    XL3'000000'        6
VTOCDDN  DC    CL8'SYSUT1'        7
DSNFLAG  DC    X'00'              8
*              01                   DS CAN BE DELETED AND REALLOCATED
*              02                   DS MUST BE COPIED
*              04                   DELETE DATASET
*              08                   ALLOCATE DATASET
*              10                   OUTPUT DATASET IS EMPTY
*              20                   ALLOCATE WITH DISP=(MOD,KEEP)
*              40                   FREE
*              80                   FREE
VTOCSPC  DC    XL3'000000'        9
OUTDISP  DC    X'00'              10
*
         ENTRY SAVEDDN,SAVEDSN,SAVEDSN2,SAVEVOL
SAVEDDN  DC    CL8'SYSUT2'        SAVE AREA FOR OUTPUT DDN
SAVEDSN  DC    CL44' '            SAVE AREA FOR DSNAME
SAVEDSN2 DC    CL44' '            SAVE AREA FOR NEW DSNAME
SAVEVOL  DC    CL6' '             SAVE AREA FOR OLD VOLSER
TRAPDATA DS    CL80
ATTANAME DC    CL8' '
ATTAPARM DS    0H
PARMLTH  DC    H'0'
PARMDATA DC    CL100' '
         SPACE 1
         ENTRY VOLADDR
VOLADDR  DC    A(VOLDATA)
VOLDATA  DC    4XL31'00'     VOL=VOLSER,VOLSER,VOLSER,VOLSER
VOLDEF   DC    XL31'00'           VOL CURRENT DSN IS ON
VOLTH    EQU   *-VOLDEF           LTH OF EACH ENTRY
VOLEND   DC    X'FF'
         SPACE 1
         PRINT NOGEN
VTOC     DCB   DDNAME=VTOC,DSORG=DA,RECFM=U,KEYLEN=44,BLKSIZE=96,      X
               MACRF=(RKIC),EODAD=CLOSEIT2,EXLST=RDJFLIST,             X
               OPTCD=E,LIMCT=255
         SPACE
OPENBIT  EQU   X'10'
RDJFLIST DC    X'07',AL3(JFCBAREA)
JFCBAREA DC    176X'0'
         SPACE 3
         LTORG
         SPACE 1
*ORK     DSECT                    IF DO GETMAIN AT START...
*AVEW    DC    18F'-1'
*AVECHG  DC    F'0'
*        DS    A
*        DS    CL6
*        DS    CL60
*DYNAMIC EQU   *-WORK
         SPACE 1
         EJECT
*
 TITLE 'REALLOCATE OUTPUT FILE TO  SYSUT2'
         DS    0H
GETDS    SECTION
         B     AROUND2            BRANCH AROUND DUMP TITLE
         DC    C'GETDS'           PROGRAM NAME
         DC    CL8'&SYSDATE'      DATE WRITTEN
         DC    CL6'&SYSTIME'      TIME WRITTEN
         SPACE 1
AROUND2  DS    0H
         LA    R3,S99RBS          R3 -> TO SVC99 PARMS
         USING S99RB,R3           SET ADDRESSABILITY
         L     R6,=V(USRDSN)      R6 -> TO DSNAME
         L     R1,=V(USRDSN)      R1 -> TO DSNAME
         SR    R5,R5              R5 = 0
         MVI   TUPAR11,C' '       CLEAR DSN TEXT UNIT
         MVC   TUPAR11+1(43),TUPAR11
         SPACE 1
NOVOL2D  DS    0H
         CLI   0(R6),C' '         AT END OF DSN ?
         BE    OUT4               YES, MOVE IT TO SVC 99 FIELD
         LA    R6,1(0,R6)         ADD 1 TO DSN POSITION REG
         LA    R5,1(0,R5)         ADD 1 TO LTH CTR
         B     NOVOL2D            LOOK AT NEXT CHAR
         SPACE 1
OUT4     DS    0H
         STH   R5,TULNG11         SET UP LTH FIELD
         BCTR  R5,0               LTH - 1 FOR EX
*        STC   R5,MVCLTH+1        SET MVC LTH
*        LA    R5,TUPAR11         R5 -> TO TUPAR11 UNIT
*MVCLTH  MVC   0(0,R5),0(R1)      MVC DSN TO TEXT UNIT
         EX    R5,MVCDSN11        MOVE DSN TO TEXT UNIT
*VCDSN11 MVC   TUPAR11(0),0(R1)   MVC DSN TO TEXT UNIT
         SPACE 1
FREEUNIT DS    0H
         L     R1,=V(DSNFLAG)     R1 -> TO ALLOCATE TYPE FLAG
         TM    0(R1),X'04'        DELETE DATASET?
         BZ    NODELETE           NO, BYPASS DELETE
         SPACE 1
         MVI   S99VERB,X'02'      CHANGE TO UNALLOCATE
         LA    R1,S99TUPL2        R1 -> TO SVC 99 PARMS FOR FREE
         ST    R1,S99TXTPP        PUT IT IN SVC 99 RB
         LA    R1,S99PARMS        R1 -> TO SVC 99 PARMS
         SVC   99
         LTR   R15,R15            WAS SVC OKAY ?
         BZ    SVCOKAY2           YES
         SPACE 1
         MVC   LINKTYPE,SVCTYP3   SAY ITS A DEALLOCATE
         BAL   R6,SVCMSG          PRINT RETURN CODES
         SPACE 1
*        LA    R15,12             SET RETURN CODE
         ST    R15,RETCODE        ''
         OLCMSG LOCMSG4           GO PRINT MSG
         B     GETEND             END OF GETDS
         SPACE 1
SVCOKAY2 DS    0H                                                   RH
         MVC   MSG(44),TUPAR11    MOVE DSNAME TO MSG                RH
         LA    R6,MSG             R6 -> TO DSNAME
         SPACE 1
NEXTCHR2 DS    0H
         CLI   0(R6),C' '         AT END OF DSN ?
         BE    ENDSN2             YES, ADD REST OF MSG
         LA    R6,1(0,R6)         ADD 1 TO DSN POSITION REG
         B     NEXTCHR2           LOOK AT NEXT CHAR
         SPACE 1
ENDSN2   DS    0H
         L     R1,=V(RNAME)       R1 -> TO OLD VOLSER
         MVC   DELVOL,0(R1)       MOVE VOLSER TO MSG                RH
         OLCMSG DELMSG            GO PRINT MSG
         L     R1,=V(DSNFLAG)     R1 -> TO ALLOCATE TYPE FLAG
         SPACE 1
NODELETE DS    0H                                                   RH
         TM    0(R1),X'08'        ALLOCATE DATASET?
         BZ    NOALLOC2           NO, BYPASS ALLOCATE
         SPACE 1
         MVI   S99VERB,X'01'      CHANGE TO ALLOCATE
         SPACE 1
         TM    0(R1),X'20'        ALLOCATE DISP=(MOD,KEEP) ?
         BZ    ALLOCNEW           NO, DISP=(NEW,KEEP)
         SPACE 1
         LA    R1,S99TUPL3        R1 -> TO SVC 99 PARMS FOR ALLOCATE
         ST    R1,S99TXTPP        PUT IT IN SVC 99 RB
         B     DOSVC99            GO DO SVC 99
         SPACE 1
ALLOCNEW DS    0H
         LA    R1,S99TUPL1        R1 -> TO SVC 99 PARMS FOR ALLOCATE
         ST    R1,S99TXTPP        PUT IT IN SVC 99 RB
*
*              GET PARM, IF ANY
*
         SPACE 1
GETCTL   DS    0H
GETCTL1  NOP   GETCTL2            B AFTER 1ST ENTRY
         SPACE 1
LOOP4    DS    0H
         SPACE 1
ENDLOOP4 DS    0H
         SPACE 1
ENDLOOP5 DS    0H
         B     GETSPACE           GO SET UP SPACE, ETC.
         SPACE 1
GETCTL2  DS    0H
GETCTL3  NOP   GETVOL             B AFTER 2ND ENTRY
         MVI   GETCTL3+1,X'F0'    CHANGE NOP TO B
         LR    R10,R11            R10 -> TO VOL= PARM
         CLC   =C'VOL=',0(R10)    IS IT VOL= PARM?
         BNE   GETVOL             NO, IGNORE IT
         BCTR  R2,0               -1 TO GET HEX LTH
         EX    R2,SETJCLC         SET UP VOL= PARM
         B     GETVOL             GO SET UP VOL= PAMRS
         SPACE 1
SETJCLC  MVC   JCLCARD(0),0(R10)  MOVE PARM TO JCLCARD AREA
         SPACE 1
GETCTL4  MVI   GETCTL3+1,X'F0'    CHANGE NOP TO B
         SPACE 1
GETSPACE DS    0H
         L     R8,=V(RESTREC)     R8 -> TO RESTORE RECORD
         USING RESTRECD,R8        SET BASE
         SPACE 1
         LA    R1,0               DEFAULT TO 0 TRK
         CLC   RESTUSED,=C'0000'  IS THERE A PRIMARY SPACE?
         BL    GETSEC             NO, TRY FOR A SECONDARY
         PACK  DUB,RESTUSED       PACK SPACE USED IN A DWORD
         CVB   R1,DUB             CONVERT TO BINARY
         SPACE 1
GETSEC   DS    0H
         STCM  R1,7,TUPAR10       PUT PRIMARY SPACE IN TEXT UNIT
         SPACE 1
         LA    R1,1               DEFAULT TO 1 TRK
         CLC   RESTSECN,=C'0000'  IS THERE A SECONDARY SPACE?
         BL    GETSEC2            NO, DEFAULT TO 1
         PACK  DUB,RESTSECN       PACK SECONDARY SPACE IN A DWORD
         CVB   R1,DUB             CONVERT TO BINARY
         SPACE 1
GETSEC2  DS    0H
         STCM  R1,7,TUPAR12       PUT SECONDARY SPACE IN TEXT UNIT
         SPACE 1
         SR    R1,R1              R1 = 0
         ST    R1,TUPL13          ASSUME NO DIR
         CLC   =C'PO',RESTTYPE    IS IT A PO FILE?
         BNE   NODIR              NO
         LA    R1,TUNIT13         YES, WE NEED DIR BLKS
         ST    R1,TUPL13          SAY SO IN S99 PARMS
         SPACE 1
         LA    R1,1               DEFAULT TO 1 DIR BLK
         CLC   RESTDIR,=C'0000'   IS THERE A DIRECTORY SPACE?
         BL    GETSEC3            NO, USE THE DEFAULT
         PACK  DUB,RESTDIR        PACK DIRECTORY BLOCKS IN A DWORD
         CVB   R1,DUB             CONVERT TO BINARY
         SPACE 1
GETSEC3  DS    0H
         STCM  R1,7,TUPAR13       PUT DIRECTORY SPACE IN TEXT UNIT
         SPACE 1
NODIR    DS    0H
         LA    R1,3120            DEFAULT TO BLKSIZE OF 3120
         CLC   RESTBLK,=C'00000'  IS THERE A BLKSIZE?
         BL    GETSEC4            NO, DEFAULT TO 3120
         PACK  DUB,RESTBLK        PACK BLKSIZE IN A DWORD
         CVB   R1,DUB             CONVERT TO BINARY
         SPACE 1
GETSEC4  DS    0H
         STH   R1,DUB             PUT BLKSIZE IN TEXT UNIT
         MVC   TUPAR30,DUB        PUT BLKSIZE IN TEXT UNIT
         SPACE 1
         LA    R1,80              DEFAULT TO LRECL=80
         CLC   RESTBLK,=C'00000'  IS THERE AN LRECL ?
         BL    GETSEC5            NO, DEFAULT TO 80
         PACK  DUB,RESTLREC       PACK LRECL IN A DWORD
         CVB   R1,DUB             CONVERT TO BINARY
         SPACE 1
GETSEC5  DS    0H
         STH   R1,DUB             PUT LRECL IN TEXT UNIT
         MVC   TUPAR42,DUB        PUT LRECL IN TEXT UNIT
         SPACE 1
         LA    R1,TUPAR49         R1 -> TO RECFM TEXT UNIT
         MVI   TUPAR49,X'C0'      DEFAULT TO U
         CLI   RESTRCFM,C'U'      IS IT U?
         BE    TUNITSET           YES
         MVI   TUPAR49,X'00'      NO RECFM
         LA    R14,RESTRCFM       R14 -> TO 1ST RECFM FIELD BYTE
         CLI   RESTRCFM,C' '      IS IT BLANK?
         BE    TUNITSET           YES
         BAL   R15,SETREC2        GO SET RECFM...
         LA    R14,RESTRCFM+1     R14 -> TO 2ND RECFM FIELD BYTE
         CLI   RESTRCFM,C' '      IS IT BLANK?
         BE    TUNITSET           YES
         BAL   R15,SETREC2        GO SET RECFM...
         LA    R14,RESTRCFM+2     R14 -> TO 3RD RECFM FIELD BYTE
         CLI   RESTRCFM,C' '      IS IT BLANK?
         BE    TUNITSET           YES
         BAL   R15,SETREC2        GO SET RECFM...
         B     TUNITSET           END OF RECFM STUFF...
         SPACE 1
SETREC2  DS    0H
         CLI   0(R14),C'F'        IS F IN RECFM
         BNE   SETREC2A           NO
*        BNE   *+4+4+0            NO
         OI    0(R1),X'80'        SAY IT'S FIXED
         SPACE 1
SETREC2A DS    0H
         CLI   0(R14),C'V'        IS V IN RECFM
         BNE   SETREC2B           NO
         OI    0(R1),X'40'        SAY IT'S VARIABLE
         SPACE 1
SETREC2B DS    0H
         CLI   0(R14),C'B'        B IN RECFM
         BNE   SETREC2C           NO
         OI    0(R1),X'10'        SAY IT'S BLOCKED
         SPACE 1
SETREC2C DS    0H
         CLI   0(R14),C'S'        S IN RECFM
         BNE   SETREC2D           NO
         OI    0(R1),X'08'        SAY IT'S SPANNED
         SPACE 1
SETREC2D DS    0H
         CLI   0(R14),C'A'        A IN RECFM
         BNE   SETREC2E           NO
         OI    0(R1),X'04'        SAY IT'S ANSI CONTROL
         SPACE 1
SETREC2E DS    0H
         CLI   0(R14),C'M'        M IN RECFM
         BNE   SETREC2F           NO
         OI    0(R1),X'02'        SAY IT'S MACHINE CONTROL
         SPACE 1
SETREC2F DS    0H
         BR    R15                END OF THIS RECFM BYTE....
         SPACE 1
TUNITSET DS    0H
         CLI   0(R1),X'00'        DID WE SET THE RECFM?
         BH    *+4+4              YES, ON WE GO
         MVI   0(R1),X'90'        NO, DEFAULT TO RECFM=FB
         SPACE 1
         MVI   TUKEY9+1,X'08'     ASSUME ALLOCATE IN CYLS
         CLC   RESTALOC,=C'CYL'   ALLOCATE IN CYLINDERS?
         BE    GETVOL             YES, WE ARE DONE
         SPACE 1
VOLSET   DS    0H
         MVI   TUKEY9+1,X'07'     CHANGE TO TRK ALLOCATE
*        B     GETVOL             GO ALLOCATE NEW DSN
         DROP  R8                 DROP RESTREC BASE
         SPACE 1
GETVOL   DS    0H                 ALLOCATE NEW DSN
         XC    TUPL2,TUPL2        DEFAULT TO NO VOLSER TEXT UNIT
         L     R5,=V(PARMFLAG)    R5 -> TO PARM FLAG                RH
         TM    0(R5),VOLFLAG      WAS VOL= SPECIFIED                RH
         BZ    NOMORE4            NO
*
*
         AGO   .SKIP87
*
         L     R2,=V(VOLADDR)     R2 -> TO VOL TABLE
         L     R1,0(0,R2)         R1 -> TO VOL ENTRY
         CLI   0(R1),X'00'        IS THERE A VOLSER?
         BE    NOMORE4            NO, TRY SYSTEM VOLS
         CLI   0(R1),X'FF'        END OF VOL TABLE?
         BE    NOMORE4            YES, TRY SYSTEM VOLS
         MVC   JCLCARD(VOLTH),0(R1)   PUT VOL SER IN PARM
         LA    R1,VOLTH(0,R1)     R1 -> TO NEXT VOL TABLE ENTRY
         ST    R1,0(0,R2)         SAVE NEXT VOL TABLE ENTRY ADDRESS
*        L     R2,=V(RNAME)       R2 -> TO OLD VOLSER
*        MVC   JCLCARD(4),=C'VOL=' SET UP VOL PARM
*        MVC   JCLCARD+4(6),0(R2)  PUT VOL SER IN PARM
         SPACE 1
*        GET   SYSIN,JCLCARD      READ NEXT CARD TO GET VOL PARM
         CLC   =C'VOL=',JCLCARD   IS IT A VOL= PARM?
         BNE   GETVOL             NO, READ NEXT CARD
         SPACE 1
GOTVOL   DS    0H
         LA    R1,JCLCARD+4       R1 -> TO VOLSER 1
         LA    R7,TUPAR2          R7 -> WHERE VOLSER GOES
         LA    R15,4              R15 -> = MAX VOLSERS
         SPACE 1
MOVVOL   DS    0H
         LH    R8,TUNUM2          R8 = NBR OF VOLSERS
         LA    R8,1(0,R8)         ADD ONE TO NBR OF VOLSERS
         STH   R8,TUNUM2          SAVE IT
         MVC   0(6,R7),0(R1)      MOVE VOLSER TO TEXT UNIT 2
         LA    R1,6(0,R1)         R1 -> TO COMMA
         CLI   0(R1),C' '         IS THERE ONE?
         BE    ENDVOL             NO
         LA    R1,1(0,R1)         R1 -> TO NEXT VOLSER
         LA    R7,8(0,R7)         R7 -> TO WHERE NEXT VOLSER GOES
         BCT   R15,MOVVOL         SAVE NEXT VOLSER
         SPACE 1
ENDVOL   DS    0H
*
.SKIP87  ANOP
*
*
         LA    R7,TUNIT2          R7 -> TO VOLSER TEXT UNIT
         ST    R7,TUPL2           PUT IT IN SVC99 LIST
         SPACE 1
NOMORE4  DS    0H
*        B     DOSVC99            GO ALLOCATE DATASET
*
         SPACE 1
DOSVC99  DS    0H                 ALLOCATE DATASET
         LA    R1,S99PARMS        R1 -> TO SVC 99 PARMS
         SVC   99
         LTR   R15,R15            WAS SVC OKAY ?
         BZ    SVCOKAY            YES
         SPACE 1
         MVC   LINKTYPE,SVCTYP2   SAY ITS AN ALLOCATE
         BAL   R6,SVCMSG          PRINT RETURN CODES
         SPACE 1
PHEAD    DS    0H
         LA    R7,0               R7 = 0
         C     R7,TUPL2           DID WE SPECIFY A VOLUME?
         BNE   PHEAD2             YES, SAY NO SPACE ON THIS VOLUME  RH
         SPACE 1
         OLCMSG LOCMSG3           GO PRINT MSG
         LA    R15,12             SET RETURN CODE
         ST    R15,RETCODE        ''
         B     GETEND             END OF GETDS
         SPACE 1
PHEAD2   DS    0H
         ST    R7,TUPL2           SAY TRY ANY PACK
         MVC   VOLMSG2,TUPAR2     MOVE VOLSER TO MSG                RH
         OLCMSG LOCMSG2           GO PRINT MSG
         B     DOSVC99            GO TRY ON ANY PACK
         SPACE 1
SVCOKAY  DS    0H                                                   RH
         MVC   MSG(44),TUPAR11    MOVE DSNAME TO MSG                RH
         LA    R6,MSG             R6 -> TO DSNAME
         SPACE 1
NEXTCHAR DS    0H
         CLI   0(R6),C' '         AT END OF DSN ?
         BE    ENDSN              YES, ADD REST OF MSG
         LA    R6,1(0,R6)         ADD 1 DSN POSITION REG
         B     NEXTCHAR           LOOK AT NEXT CHAR
         SPACE 1
ENDSN    DS    0H
         MVC   VOLMSG,TUPAR14     MOVE VOLSER TO MSG                RH
         OLCMSG LOCMSG            GO PRINT MSG
         SPACE 1
GETEND   DS    0H
NOALLOC2 DS    0H
         L     R15,RETCODE        R15 = RETURN CODE
*        ST    R15,16(0,R13)      PUT RC IN SYSTEM SAVEAREA
*        FREEMAIN R,LV=LDYNAMIC,A=(3)  FREE GOTTEN CORE
         SPACE 3
***********************************************************************
*                                                                     *
*              RETURN TO CALLER                                       *
*                                                                     *
***********************************************************************
*
ENDGETDS SECEXIT                  RETURN TO CALLER
         SPACE 2                                                   RH
SVCMSG   DS    0H               BAD READ OF VSAM DATA SET
         CVD   R15,DUB            CONVERT RC TO DECIMAL
         ED    LINKRC,DUB+6       CONVERT TO DISPLAY
         UNPK  LINKERR(5),S99ERROR(3) CONVERT ERROR CODE TO DECIMAL RH
         TR    LINKERR(4),TRTBL-240  TRANS TO DISPLAY               RH
         MVI   LINKERR+4,C' '     CLEAR GARBAGE BYTE                RH
         UNPK  LINKINFO(5),S99INFO(3) CONVERT INFO CODE TO DECIMAL  RH
         TR    LINKINFO(4),TRTBL-240  TRANS TO DISPLAY              RH
         MVI   LINKINFO+4,C' '    CLEAR GARBAGE BYTE                RH
         OLCMSG LINKMSG           GO PRINT MSG
         BR    R6                 GO BACK TO CALLER
         SPACE 1
MVCDSN11 MVC   TUPAR11(0),0(R1)   MVC DSN TO TEXT UNIT
         SPACE 1
* $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
*        WORK AREAS
* $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
         SPACE 1
         DC    C'WORKING STORAGE SECTION'
         SPACE 1
DUB      DC    D'0'
LINKMSG  DC    CL81' '
         ORG   *-81
         DC    AL1(MSGPRT)
         DC    C'SVC 99 WAS UNSUCCESSFUL FOR '
LINKTYPE DC    C'UNALLOCATE '
         DC    C', RC = '
LINKRC   DC    X'40202020'
         DC    C' S99ERROR = '
LINKERR  DC    CL5' '
         DC    C' S99INFO = '
LINKINFO DC    CL5' '
LINKMSGL EQU   *-LINKMSG
         ORG   LINKMSG+81
         SPACE 1
SVCTYP2  DC    CL11'ALLOCATE   '
SVCTYP3  DC    CL11'UNALLOCATE '
TRTBL    DC    C'0123456789ABCDEF '   TRANSLATE TABLE               RH
         SPACE 1
* ------ INPUT AREA               ------------------------------------
JCLCARD  DC    CL80' '            CARD INPUT AREA
         SPACE 1
* ------ WORK  AREAS              ------------------------------------
         SPACE 1
DELMSG   DC    CL81' '
         ORG   *-81
         DC    AL1(MSGPRT)
         DC    C'DELETED SUCCESSFULLY FROM '
DELVOL   DC    CL6' '
LDELMSG  EQU   *-DELMSG
         ORG   DELMSG+81
         SPACE 1
LOCMSG   DC    CL81' '
         ORG   *-81
         DC    AL1(MSGPRT)
         DC    C'LOCMSG - ALLOCATED SUCCESSFULLY ON '
VOLMSG   DC    CL6' '
LLOCMSG  EQU   *-LOCMSG
         ORG   LOCMSG+81
         SPACE 1
LOCMSG2  DC    CL81' '
         ORG   *-81
         DC    AL1(MSGPRT)
         DC    C'NO SPACE FOR DATASET ON '
VOLMSG2  DC    CL6' '
LLOCMS2  EQU   *-LOCMSG2
         ORG   LOCMSG2+81
         SPACE 1
LOCMSG3  DC    CL81' '
         ORG   *-81
         DC    AL1(MSGPRT)
         DC    C'NO SPACE IN SYSTEM FOR DATASET. '
         DC    C'CHANGE VOL= PARMS IN //SYSIN DATASET.'
LLOCMS3  EQU   *-LOCMSG3
         ORG   LOCMSG2+81
         SPACE 1
LOCMSG4  DC    CL81' '
         ORG   *-81
         DC    AL1(MSGPRT)
         DC    C'SVC 99 WAS UNSUCCESSFUL FOR UNALLOCATE'
         ORG   LOCMSG4+81
INFO1    DS    0CL133
         DC    C'0'
MSG      DC    CL44' '
CTLTOTAL DC    CL8' '
         DC    CL80' '
         EJECT
DWORD3   DS    D
RSAVE    DS    9D
RETCODE  DC    F'0'
         SPACE 1
*              CONTROL BLOCKS FOR  SVC 99
S99PARMS DS    0F                 PUT ON FULLWORD BOUNDARY
         DC    XL1'80'
         DC    AL3(S99RBS)
S99RBS   DS    0F
         DC    AL1(20)
         DC    AL1(1)             ALLOCATE BY DSNAME
         DC    XL2'2000'          DON'T MOUNT VOLS OR CONSIDER OFFLINES
         DC    AL2(0)
         DC    AL2(0)
         DC    A(S99TUPL1)
         DC    A(0)
         DC    A(0)
         SPACE 1
         ENTRY TUPL2D
S99TUPL1 DS    0F
TUPL1    DC    A(TUNIT1)          DDNAME
TUPL11   DC    A(TUNIT11)         DSNAME
TUPL2    DC    A(TUNIT2)          VOLSER
TUPL3    DC    A(TUNIT3)          UNIT TYPE
TUPL4    DC    A(TUNIT4)          NBR OF DEVICES TO ALLOC = 1
TUPL5    DC    A(0)               DUMMY
TUPL6    DC    A(TUNIT6)          STATUS..DISP=(NEW,
TUPL7    DC    A(TUNIT7)          STATUS..DISP=(NEW,CATLG)
TUPL9    DC    A(TUNIT9)          SPACE IN CYLS
TUPL10   DC    A(TUNIT10)         PRIMARY SPACE (DEFAULT=50)
TUPL12   DC    A(TUNIT12)         SECONDARY SPACE (DEFAULT=10)
TUPL13   DC    A(TUNIT13)         DIRECTORY BLOCKS, IF PO
TUPL14   DC    A(TUNIT14)         RETURN VOLSER IF ALLOCATED
TUPL2D   DC    A(0)               GET DCB INFO FROM DDNAME
TUPL30   DC    A(TUNIT30)         BLKSIZE
TUPL3C   DC    A(TUNIT3C)         DSORG
TUPL42   DC    A(TUNIT42)         LRECL
TUPL49   DC    A(TUNIT49)         RECFM
TUPLAST  DC    XL1'80'            END OF TEXT UNITS
         DC    AL3(0)
         SPACE 1
S99TUPL2 DS    0F
TUPL21   DC    A(TUNIT1)          DDNAME
TUPL16   DC    A(TUNIT11)         DSNAME
TUPL15   DC    A(TUNIT15)         DISP=(OLD,DELETE)
TUPL22   DC    A(TUNIT22)         UNALLOC EVEN IF PERM ALLOC
TUPL27   DC    XL1'80'
         DC    AL3(0)
         SPACE 1
S99TUPL3 DS    0F
TUPL31   DC    A(TUNIT1)          DDNAME
TUPL311  DC    A(TUNIT11)         DSNAME
*UPL32   DC    A(TUNIT2)          VOLSER
TUPL36   DC    A(TUNIT6M)         STATUS..DISP=(MOD,
TUPL37   DC    A(TUNIT7K)         STATUS..DISP=(MOD,KEEP)
TUPL314  DC    A(TUNIT14)         RETURN VOLSER IF ALLOCATED
TUPLAST3 DC    XL1'80'            END OF TEXT UNITS
         DC    AL3(0)
         SPACE 1
TUNIT1   DS    0C
TUKEY1   DC    AL2(1)             ALLOCATE BY DDNAME
TUNUM1   DC    AL2(1)
TUENT1   DS    0C
TULNG1A  DC    AL2(8)             LTH OF DDNAME
TUPAR1A  DC    CL8'SYSUT2  '      DDNAME
         SPACE 1
TUNIT11  DS    0C
TUKEY11  DC    AL2(2)             DSNAME
TUNUM11  DC    AL2(1)
TUENT11  DS    0C
TULNG11  DC    AL2(8)             LTH OF DSNAME
TUPAR11  DC    CL44'NULLFILE'     DSNAME = NULLFILE
         SPACE 1
         ENTRY TUPAR2,TUPAR2A,TUPAR2B,TUPAR2C,TUNUM2
TUNIT2   DS    0C
TUKEY2   DC    XL2'0010'          VOL SER
TUNUM2   DC    AL2(1)
TUENT2   DS    0H
TULNG2   DC    XL2'0006'          LTH OF VOL SER
TUPAR2   DC    CL6' '             VOL SER 1
TULNG2A  DC    XL2'0006'          LTH OF VOL SER
TUPAR2A  DC    CL6' '             VOL SER 2
TULNG2B  DC    XL2'0006'          LTH OF VOL SER
TUPAR2B  DC    CL6' '             VOL SER 3
TULNG2C  DC    XL2'0006'          LTH OF VOL SER
TUPAR2C  DC    CL6' '             VOL SER 4
         SPACE 1
         ENTRY TULNG3,TUPAR3A
TUNIT3   DS    0C
TUKEY3   DC    XL2'0015'          UNIT TYPE
TUNUM3   DC    AL2(1)
TUENT3   DS    0C
TULNG3   DC    AL2(5)             LTH OF UNIT TYPE
TUPAR3A  DC    CL8'SYSDA'         UNIT TYPE IS DISK
         SPACE 1
TUNIT4   DS    0C
TUKEY4   DC    XL2'0016'          UNIT COUNT
TUNUM4   DC    AL2(1)
TUENT4   DS    0C
TULNG4   DC    AL2(1)             LTH OF UNIT COUNT
TUPAR4   DC    XL1'01'            UNIT COUNT IS 1
         SPACE 1
TUNIT5   DS    0C
TUKEY5   DC    XL2'0024'          ALLOCATE DUMMY
TUNUM5   DC    AL2(0)
         SPACE 1
TUNIT6   DS    0C
TUKEY6   DC    XL2'0004'          STATUS OF UNIT
TUNUM6   DC    AL2(1)
TUENT6   DS    0C
TULNG6A  DC    AL2(1)             LTH OF STATUS
TUPAR6A  DC    X'04'              STATUS = NEW
*        DC    X'08'              STATUS = SHR
*        DC    X'04'              STATUS = NEW
*        DC    X'02'              STATUS = MOD
*        DC    X'01'              STATUS = OLD
         SPACE 1
TUNIT6M  DS    0C
TUKEY6M  DC    XL2'0004'          STATUS OF UNIT
TUNUM6M  DC    AL2(1)
TUENT6M  DS    0C
TULNG6M  DC    AL2(1)             LTH OF STATUS
TUPAR6M  DC    X'04'              STATUS = NEW
*        DC    X'08'              STATUS = SHR
*        DC    X'04'              STATUS = NEW
*        DC    X'02'              STATUS = MOD
*        DC    X'01'              STATUS = OLD
         SPACE 1
         ENTRY TUPAR7A
TUNIT7   DS    0C
TUKEY7   DC    XL2'0005'          STATUS 2..DISP=(NEW,CATLG)
TUNUM7   DC    AL2(1)
TUENT7   DS    0C
TULNG7A  DC    AL2(1)             LTH OF STATUS 2
TUPAR7A  DC    X'02'              DISP= CATLG
*        DC    X'08'              DISP= KEEP
*        DC    X'04'              DISP= DELETE
*        DC    X'02'              DISP= CATLG
*        DC    X'01'              DISP= UNCATLG
         SPACE 1
         ENTRY TUPAR7K
TUNIT7K  DS    0C
TUKEY7K  DC    XL2'0005'          STATUS 2..DISP=(MOD,KEEP)
TUNUM7K  DC    AL2(1)
TUENT7K  DS    0C
TULNG7K  DC    AL2(1)             LTH OF STATUS 2
TUPAR7K  DC    X'02'              DISP= CATLG
*        DC    X'08'              DISP= KEEP
*        DC    X'04'              DISP= DELETE
*        DC    X'02'              DISP= CATLG
*        DC    X'01'              DISP= UNCATLG
         SPACE 1
TUNIT8   DS    0C
TUKEY8   DC    XL2'0055'          RETURN DDNAME
TUNUM8   DC    AL2(1)
TUENT8   DS    0C
TULNG8   DC    AL2(8)             LTH OF DDNAME
TUPAR8   DC    CL8' '             DDNAME
         SPACE 1
TUNIT9   DS    0C
TUKEY9   DC    XL2'0008'          SPACE IN CYLS
TUNUM9   DC    AL2(0)
         SPACE 1
TUNIT10  DS    0C
TUKEY10  DC    XL2'000A'          PRIMARY SPACE
TUNUM10  DC    AL2(1)
TUENT10  DS    0C
TULNG10  DC    AL2(3)             LTH OF SPACE PARM
TUPAR10  DC    XL3'000032'        QUANTITY IN HEX (DEFAULT = 50)
         SPACE 1
TUNIT12  DS    0C
TUKEY12  DC    XL2'000B'          SECONDARY SPACE
TUNUM12  DC    AL2(1)
TUENT12  DS    0C
TULNG12  DC    AL2(3)             LTH OF SPACE PARM
TUPAR12  DC    XL3'00000A'        QUANTITY IN HEX (DEFAULT = 10)
         SPACE 1
TUNIT13  DS    0C
TUKEY13  DC    XL2'000C'          DIRECTORY SPACE
TUNUM13  DC    AL2(1)
TUENT13  DS    0C
TULNG13  DC    AL2(3)             LTH OF SPACE PARM
TUPAR13  DC    XL3'00000A'        QUANTITY IN HEX (DEFAULT = 10)
         SPACE 1
TUNIT14  DS    0C
TUKEY14  DC    XL2'005D'          RETURN VOLSER IF ALLOCATED
TUNUM14  DC    AL2(1)
TUENT14  DS    0C
TULNG14  DC    AL2(6)
TUPAR14  DC    CL6' '             VOLSER OF ALLOCATED DSN
         SPACE 1
TUNIT15  DS    0C
TUKEY15  DC    XL2'0005'          STATUS 2..DISP=(OLD,DELETE)
TUNUM15  DC    AL2(1)
TUENT15  DS    0C
TULNG15  DC    AL2(1)             LTH OF STATUS 2
TUPAR15  DC    X'04'              DISP= DELETE
*        DC    X'08'              DISP= KEEP
*        DC    X'04'              DISP= DELETE
*        DC    X'02'              DISP= CATLG
*        DC    X'01'              DISP= UNCATLG
         SPACE 1
TUNIT30  DS    0C
TUKEY30  DC    XL2'0030'          BLKSIZE
TUNUM30  DC    AL2(1)
TUENT30  DS    0C
TULNG30  DC    AL2(2)             LTH OF BLKSIZE
TUPAR30  DC    XL2'0000'          BLKSIZE
         SPACE 1
TUNIT3C  DS    0C
TUKEY3C  DC    XL2'003C'          DSORG
TUNUM3C  DC    AL2(1)
TUENT3C  DS    0C
TULNG3C  DC    AL2(2)             LTH OF DSORG
TUPAR3C  DC    XL2'4000'          DSORG = PS
         SPACE 1
TUNIT42  DS    0C
TUKEY42  DC    XL2'0042'          LRECL
TUNUM42  DC    AL2(1)
TUENT42  DS    0C
TULNG42  DC    AL2(2)             LTH OF LRECL
TUPAR42  DC    XL2'0000'          LRECL
         SPACE 1
TUNIT49  DS    0C
TUKEY49  DC    XL2'0049'          RECFM
TUNUM49  DC    AL2(1)
TUENT49  DS    0C
TULNG49  DC    AL2(1)             LTH OF RECFM
TUPAR49  DC    X'90'              RECFM = FB
         SPACE 1
TUNIT22  DS    0C
TUKEY22  DC    XL2'0007'          UNALLOC EVEN IF PERM ALLOC
TUNUM22  DC    AL2(0)
         SPACE 1
         ENTRY TUNIT2D,TUPAR2D
TUNIT2D  DS    0C
TUKEY2D  DC    XL2'002D'          GET DCB INFO FROM SPECIFIED DDNAME
TUNUM2D  DC    AL2(1)
TUENT2D  DS    0C
TULNG2D  DC    AL2(8)             LTH OF DDNAME
TUPAR2D  DC    CL8'DSN     '      DDNAME
         SPACE 1
         SPACE 1
         LTORG
         SPACE 1
*ORK     DSECT                    IF GETMAIN AT START...
*AVE     DC    18F'-1'
*AVECHG  DC    F'0'
*        DS    A
*        DS    CL6
*        DS    CL60
*DYNAMIC EQU   *-WORK
         SPACE 1
*
* DUMMY SECTIONS
*
         SPACE 3
         SPACE 3
* DUMMY DSCB
DSCB1    DSECT
         IECSDSL1 (1,3)
         SPACE 3
DSCB4D   DSECT
         IECSDSL1 4               DSCB4 LAYOUT
         SPACE    2
         REQUATE  SAVE=YES
         PRINT    NOGEN
SDWA     IHASDWA
         DCBD     DSORG=(PS,PO),DEVD=DA
         IEFZB4D0
         IEFZB4D2
         IHAPDS   PDSBLDL=NO
IHAJFCB  DSECT
         IEFJFCBN
         SPACE 1
         PRINT GEN
UCBDSECT DSECT
*        IEFUCBOB                 UCB MAPPING MACRO
         IEFUCBOB LIST=YES  ,PREFIX=NO,SSMD=NO,DEVCLAS=TAPE
         PRINT    NOGEN
* DUMMY DEB
         IEZDEB LIST=NO           DEB MAPPING MACRO
         CVT   DSECT=YES
*              NOTE..THE ABOVE MACROS ARE IN SYS1.AMODGEN
         SPACE 1
*
         END
/*
//LKED.IN1     DD DSN=&&OBJECT,DISP=(SHR,PASS)
//*            UNIT=DISK,SPACE=(TRK,(1,1,5)),
//*            DCB=(RECFM=FB,LRECL=80,BLKSIZE=8880)
//LKED.SYSLMOD  DD DISP=SHR,DSN=HALL.LINKLIB
//LKED.SYSIN DD *
 INCLUDE IN1(HALLDUMP)
 ENTRY BACKDSNS
 SETCODE AC(1)
 MODE    AMODE(24) RMODE(24)
 NAME    BACKDSNS(R)
/*
//
