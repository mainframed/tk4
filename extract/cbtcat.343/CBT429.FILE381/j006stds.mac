         TITLE 'JES2 INTERNAL TEXT STDS ENFORCEMENT EXIT'
***********************************************************************
*                                                                     *
*        ENVIRONMENT   MVS SP S.S.0                                   *
*                                                                     *
*        THIS JES2 EXIT PROGRAM IS DESIGNED TO RUN AT CONVERTER       *
*        TIME TO ENFORCE INSTALLATION JCL STANDARDS AND TO DETERMINE  *
*        THE APPROPRIATE JOB CLASS BASED ON DEVICE UTILIZATION.       *
*                                                                     *
*        VIOLATIONS OF JCL STANDARDS ARE DOCUMENTED BY MESSAGES       *
*        WRITTEN TO THE JES2 MESSAGE DATA SET FOR THE JOB AND         *
*        FLAGGED FOR JCL ERROR BY THE USE OF THE JES2 EXIT RETURN     *
*        CODE TO THE JES2 CONVERTER SUB-TASK.                         *
*                                                                     *
*        THIS EXIT USES THE INTERNAL TEXT DATA SET FOR ITS            *
*        PROCESSING.  JES2 PASSES EACH INTERNAL TEXT STATEMENT        *
*        TO THIS EXIT FOR EXAMINATION AND/OR MODIFICATION.  THE       *
*        EXIT WILL MAINTAIN A TABLE OF DATASET NAMES AND DEVICE       *
*        COUNTS TO BE USED AT END OF PROCESSING FOR DETERMINING       *
*        JOB CLASS.  THE ACB FOR THE MESSAGE DATA SET IS IN THE       *
*        DTE FOR SP 1.3.6 AND 2.1.5 AND CAN BE USED TO ISSUE          *
*        ERROR MESSAGES TO THE JOB MESSAGE PORTION OF THE             *
*        LISTING.                                                     *
*                                                                     *
*        ALSO, THE CONVERTER IS A DUMB ANIMAL WHEN IT COMES TO        *
*        SYNTAX CHECKING.  CHECKING IS MADE FOR KEYWORD VALUES,       *
*        BUT NONE IS MADE ON THE VALUE FOR THE KEYWORD.  IE.,         *
*        50 CHARACTER DATA SET NAMES, 20 CHARACTER VOLUME SERIAL      *
*        NUMBERS, AND NUMEROUS SYNTAX ERRORS CAN PASS UNDETECTED      *
*        THROUGH THE CONVERTER.  THESE ERRORS WILL BE CAUGHT BY       *
*        THE INTERPRETER WHEN THE JOB GOES INTO EXECUTION, BUT        *
*        THIS EXIT MUST PROCESS THEM.  CURRENTLY, ALL ERRORS OF       *
*        THIS TYPE WILL ISSUE A MESSAGE TO THE EFFECT OF AN INTERNAL  *
*        ERROR AND SET THE JOB TO CLASS=A.  THE ESTAE ROUTINE,        *
*        WHEN ENTERED FOR AN ABEND, WILL ALSO SET THE CLASS TO        *
*        'A' AND RECOVER TO PROTECT THE CONVERSION SUBTASK FROM       *
*        ABEND AND CONSEQUENT LOSS OF THE JOB.                        *
*                                                                     *
***********************************************************************
         EJECT
***********************************************************************
*                                                                     *
*        CLASS DETERMINATION IS MADE BY KEEPING A COUNT OF ALL        *
*        OF THE MOUNTABLE DEVICES USED PER STEP.  THESE COUNTS        *
*        ARE SAVED IN AN INTERNAL TABLE TO BE PROCESSED AT END        *
*        OF INTERNAL TEXT.  ALSO SAVED IN THE TABLE ARE ENTRIES       *
*        FOR DD STATEMENTS WHICH USED MOUNTABLE DEVICES               *
*        FOR USE IN REFERBACKS AND UNIT=AFF.  IF THE UNIT             *
*        HAS NOT BEEN DETERMINED AT THE END OF PROCESSING             *
*        FOR A DD STATEMENT, THE CATALOG IS SEARCHED.  IF THE         *
*        CATALOGED DEVICE IS SYSDA, THE UCBS ARE SEARCHED             *
*        TO DETERMINE IF THE PACK IS MOUNTED AS PRIVATE,              *
*        RESERVED, OR PERMANENTLY RESIDENT.  IF THE PACK              *
*        IS NOT FOUND, A PRIV DISK MOUNT WILL BE CHARGED.             *
*        CLASS IS SET ON THE BASIS OF THE MAXIMUM NUMBER OF TAPES     *
*        PER STEP, MAXIMUM NUMBER OF PRIV DASD DEVICES PER STEP,      *
*        TOTAL MAXIMUM MOUNTABLE DEVICES PER STEP, MAXIMUM REGION     *
*        PER STEP, AND ESTIMATED EXECUTION TIME FOR JOB.              *
*                                                                     *
*        WHEN TESTING THIS EXIT UNDER THE TSO INTERFACE, THE LOCAL    *
*        VARIABLE &&TSO SHOULD BE CHANGED TO 'YES' FROM 'NO' TO       *
*        CHANGE THE $$WTO INSTRUCTIONS TO WTO INSTRUCTIONS AND        *
*        BYPASS THE ESTAE MACROS SO THAT THE TEST COMMAND CAN         *
*        DETERMINE THE ADDRESS OF THE ABEND.                          *
*                                                                     *
*                                                                     *
*        WRITTEN BY:                                                  *
*                        JOHN V. HOOPER                               *
*                        FIRST UNION NATIONAL BANK                    *
*                        301 SOUTH TRYON STREET                       *
*                        CHARLOTTE, N.C.  28288                       *
*                        (704) 374-2427                               *
*                                                                     *
***********************************************************************
         EJECT
***********************************************************************
*                                                                     *
*              M A C R O S   U S E D   I N   J 0 0 6 S T D S          *
*                                                                     *
*        01)  $$WTO        SYS1.HASPSRC                               *
*        02)  $BUFFER      SYS1.HASPSRC                               *
*        03)  $CAT         SYS1.HASPSRC                               *
*        04)  $CNVWORK     SYS1.HASPSRC                               *
*        05)  $DCT         SYS1.HASPSRC                               *
*        06)  $DTE         SYS1.HASPSRC                               *
*        07)  $DTECNV      SYS1.HASPSRC                               *
*        08)  $ENTRY       SYS1.HASPSRC                               *
*        09)  $ERA         SYS1.HASPSRC                               *
*        10)  $HASPEQU     SYS1.HASPSRC                               *
*        11)  $HASPGBL     SYS1.HASPSRC                               *
*        12)  $HCT         SYS1.HASPSRC                               *
*        13)  $JCT         SYS1.HASPSRC                               *
*        14)  $JOE         SYS1.HASPSRC                               *
*        15)  $JQE         SYS1.HASPSRC                               *
*        16)  $MID         SYS1.HASPSRC                               *
*        17)  $MIT         SYS1.HASPSRC                               *
*        18)  $MODEND      SYS1.HASPSRC                               *
*        19)  $MODULE      SYS1.HASPSRC                               *
*        20)  $PADDR       SYS1.HASPSRC                               *
*        21)  $PCE         SYS1.HASPSRC                               *
*        22)  $TQE         SYS1.HASPSRC                               *
*        23)  $XECB        SYS1.HASPSRC                               *
*        24)  CAMLST       SYS1.MACLIB                                *
*        25)  CVT          SYS1.MACLIB                                *
*        26)  ESTAE        SYS1.MACLIB                                *
*        27)  FREEMAIN     SYS1.MACLIB                                *
*        28)  GETMAIN      SYS1.MACLIB                                *
*        29)  IEFNEL       SYS1.AMODGEN                               *
*        30)  IEFTXTFT     SYS1.AMODGEN                               *
*        31)  IEFUCBOB     SYS1.AMODGEN                               *
*        32)  IEFVKEYS     SYS1.AMODGEN                               *
*        33)  IEZDEB       SYS1.AMODGEN                               *
*        34)  IEZWPL       SYS1.AMODGEN                               *
*        35)  IFGRPL       SYS1.MACLIB                                *
*        36)  IHASDWA      SYS1.MACLIB                                *
*        37)  LOCATE       SYS1.MACLIB                                *
*        38)  RETURN       SYS1.MACLIB                                *
*        39)  SAVE         SYS1.MACLIB                                *
*        40)  SDUMP        SYS1.MACLIB                                *
*        41)  SETRP        SYS1.MACLIB                                *
*        42)  WTO          SYS1.MACLIB                                *
*                                                                     *
*                                                                     *
*              L I N K A G E    E D I T O R    I N F O                *
*                                                                     *
*        SIZE:       20K                                              *
*        ATTRIBUTES: REENTRANT, REUSEABLE, REFRESHABLE                *
*                                                                     *
*                                                                     *
***********************************************************************
         EJECT
***********************************************************************
*                                                                     *
*        SET CONDITIONAL ASSEMBLY VARIABLES                           *
*                                                                     *
***********************************************************************
         LCLC &TSO
         LCLC &CAMLST
         LCLC &ERRMSG
         LCLC &WRNMSG
         LCLC &STATMSG
         LCLC &SDUMP
         LCLC &FLUSH
         LCLC &MODIFY
         LCLC &UCBSEAR
         LCLC &BINREQD
         LCLC &ESTAE
&TSO     SETC 'NO'                 ASSEMBLE FOR TSO TESTING
&CAMLST  SETC 'NO'                 SEARCH CATALOG FOR DATASETS
&ERRMSG  SETC 'YES'                PRODUCE JOBFAILED BY EXIT MESSAGE
&WRNMSG  SETC 'YES'                PRODUCE WARNED    BY EXIT MESSAGE
&STATMSG SETC 'NO'                 PRODUCE STATISTICS        MESSAGE
&SDUMP   SETC 'YES'                PRODUCE CONSOLE DUMP FOR ABENDS
&FLUSH   SETC 'YES'                FLUSH JOB FOR STANDARDS VIOLATIONS
&MODIFY  SETC 'YES'                MODIFY JOB CLASS IN JCT AND JQE
&UCBSEAR SETC 'NO'                 SEARCH UCBS FOR UNMOUNTED VOLUMES
&BINREQD SETC 'NO'                 IS BIN NUMBER REQUIRED
&ESTAE   SETC 'YES'                CREATE ESTAE ENVIRONMENT
         EJECT
***********************************************************************
*                                                                     *
*        JES2 MACRO EXPANSIONS                                        *
*                                                                     *
***********************************************************************
         COPY  $HASPGBL
J006STDS $MODULE SYSP=(GEN,GEN,DATA,GEN,GEN),                          X
               ENVIRON=SUBTASK,                                        X
               TITLE='JES2 INTERNAL TEXT STDS ENFORCEMENT EXIT',       X
               $BUFFER,            GENERATE HASP BUFFER DSECT          X
               $CAT,               GENERATE HASP CAT DSECT             X
               $CNVWORK,           GENERATE HASP CNVWORK DSECT         X
               $DTE,               GENERATE HASP DTE DSECT             X
               $DTECNV,            GENERATE HASP CNV DTE EXTEN         X
               $ERA,               GENERATE HASP ERA DSECT             X
               $HASPEQU,           GENERATE HASP EQUATES               X
               $HCT,               GENERATE HASP HCT DSECT             X
               $JCT,               GENERATE HASP JCT DSECT             X
               $JOE,               GENERATE HASP JOE DSECT             X
               $JQE,               GENERATE HASP JQE DSECT             X
               $MIT,               GENERATE HASP MIT DSECT             X
               $PADDR,             GENERATE HASP PADDR DSECT           X
               $PCE,               GENERATE HASP PCE DSECT             X
               $TQE,               GENERATE HASP TQE DSECT             X
               $XECB,              GENERATE HASP EXT ECB DSECT         X
               CVT,                GENERATE MVS  CVT DSECT             X
               DEB,                GENERATE MVS  DEB DSECT             X
               KEYS,               GENERATE MVS  TEXT KEYS EQUATES     X
               NEL,                GENERATE MVS  NEL DSECT             X
               RPL,                GENERATE MVS  RPL DSECT             X
               SDWA,               GENERATE MVS  SDWA DSECT            X
               TEXT,               GENERATE MVS  TEXT DSECT            X
               UCB,                GENERATE MVS  UCB DSECT             X
               WPL                 GENERATE MVS  WPL DSECT
               SPACE 3
         TITLE 'JES2 INTERNAL TEXT STDS ENFORCEMENT EXIT'
         SPACE 3
***********************************************************************
*                                                                     *
*        ACTUAL JES2 EXIT ENTRY POINT                                 *
*                                                                     *
***********************************************************************
E006STDS $ENTRY  BASE=(R12,R9,R10)
         SAVE  (14,12)             SAVE CALLERS REGISTERS
         LR    R5,R1               SAVE INPUT PARM LIST ADDRESS
         L     R2,12(R1)           LOAD JCT ADDRESS
         USING JCT,R2              SET ADDRESSABILITY TO JCT
         LR    R12,R15             ESTABLISH BASE REGISTER
         LA    R9,2048(R12)        SET SECOND
         LA    R9,2048(R9)             BASE REGISTER
         LA    R10,2048(R9)        SET THIRD
         LA    R10,2048(R10)           BASE REGISTER
         LR    R4,R0               SAVE REG 0
         TM    JCTJBOPT,JCTXBACH   IS THIS AN XBATCH JOB
         BO    QUICKOUT            YES, GET OUT IMMEDIATELY
         L     R6,4(R1)            LOAD ADDRESS OF INTERNAL TEXT RECORD
         USING TEXT,R6             SET ADDRESSABILITY TO TEXT RECORD
         L     R15,0(R5)           LOAD ADDRESS OF EXIT WORK AREA
         ICM   R1,15,0(R15)        LOAD GETMAINED AREA ADDRESS (IF ONE)
         BZ    GETMAIN             ZERO, GO DO REQUIRED GETMAINS
         ST    R13,4(R1)           SAVE OLD SAVE ADDR IN NEW
         ST    R1,8(R13)           SAVE NEW SAVE ADDR IN OLD
         LR    R13,R1              SAVE NEW SAVE AND WORKAREA ADDRESS
         USING WORKAREA,R13        SET ADDRESSABILITY
         L     R7,SUBTABLE         RESTORE SUB TABLE AREA
         USING SAVTABLE,R7         SET ADDRESSABILITY
         B     ENDGETM             BYPASS GETMAINS
         EJECT
***********************************************************************
*                                                                     *
*        GET STORAGE FOR WORK AREAS ON FIRST ENTRY TO EXIT FOR        *
*        THE JOB                                                      *
*                                                                     *
***********************************************************************
GETMAIN  DS    0H
         LH    R0,GETLEN           LOAD GETMAIN SIZE
         GETMAIN R,LV=(0)          GET CORE FOR DYNAMIC SAVE AREA
         LR    R3,R1               SAVE GETMAINED ADDRESS
         LR    R0,R1               CLEAR
         LH    R1,GETLEN               ENTIRE
         SLR   R15,R15                     GETMAINED
         MVCL  R0,R14                          TO ZEROS
         ST    R13,4(R3)           SAVE OLD SAVE ADDR IN NEW
         ST    R3,8(R13)           SAVE NEW SAVE ADDR IN OLD
         LR    R13,R3              SAVE NEW SAVE AND WORKAREA ADDRESS
         L     R15,0(R5)           LOAD ADDRESS OF EXIT WORK AREA
         ST    R13,0(R15)          SAVE GETMAINED ADDRESS IN EXIT WA
         L     R0,F#16384          LOAD GETMAIN SIZE
         GETMAIN R,LV=(0)          GET CORE FOR JCL TABLE
         LR    R7,R1               SAVE GETMAIN ADDRESS
         ST    R7,SUBTABLE         STORE ADDR OF SUB TABLE AREA
         LR    R0,R7               CLEAR
         L     R1,F#16384              ENTIRE
         SLR   R15,R15                     GETMAINED
         MVCL  R0,R14                          TO ZEROS
         LA    R15,MSGRPL          LOAD OUTPUT RPL ADDRESS
         ST    R15,OUTRPL          SAVE OUTPUT RPL ADDRESS
         L     R15,8(R5)           LOAD DTE ADDRESS
         USING DTE,R15             SET ADDRESSABILITY TO DTE
         LA    R15,DCNVMSG         LOAD OUTPUT ACB ADDRESS
         ST    R15,OUTACB          SAVE OUTPUT ACB ADDRESS
         DROP  R15                 DROP ADDRESSABILITY TO DTE
ENDGETM  ST    R2,JCTADDR          SAVE JCT ADDRESS
         ST    R5,WORKADDR         SAVE EXIT PARM LIST ADDRESS
         ST    R6,TEXTSTAR         SAVE TEXT STARTING ADDRESS
         L     R1,JCTJQE           LOAD JQE OFFSET
         N     R1,$ZEROFFF         CLEAR HIGH ORDER BYTE
         AL    R1,$JOBQPTR         GET ACTUAL JQE ADDRESS
         ST    R1,JQEADDR          SAVE JQE ADDRESS
         DROP  R2                  DROP ADDRESSABILITY TO JCT
         EJECT
***********************************************************************
*        ESTABLISH ESTAE ENVIRONMENT                                  *
***********************************************************************
         MVC   ESTAEL(LESTAEL),ESTAE INITIALIZE ESTAE LIST FORM
         STM   R14,R12,STAEREGS+12 SAVE CURRENT REGISTERS
         LA    R1,ESTAEL           LOAD ADDRESS OF ESTAE LIST FORM
         AIF   ('&TSO' EQ 'YES').TSO9
         AIF   ('&ESTAE' NE 'YES').TSO9
         ESTAE STAEXIT,CT,PARAM=(13),XCTL=NO,PURGE=NONE,ASYNCH=NO,     X
               RECORD=YES,TERM=NO,MF=(E,(1))
.TSO9    ANOP
         LR    R0,R4               RESTORE REG 0
         LTR   R0,R0               INDIVIDUAL ENTRY FOR INTERNAL TEXT
         BZ    CHECKJCT            YES, BRANCH
         B     EOF                 GET OUT
         EJECT
***********************************************************************
*        SOME TYPES OF ERRORS DETECTED BY THE CONVERTER TURN ON BITS  *
*        IN THE JCTCNVRC FIELD WHICH WILL FAIL THE JOB WHEN THE       *
*        CONVERTER COMPLETES.  THESE BITS WILL BE TESTED, AND IF      *
*        THE JOB IS TO BE FAILED, A QUICK PATH THROUGH THE EXIT       *
*        WILL BE MADE.                                                *
***********************************************************************
CHECKJCT TM    JOBIND2,SEVERE      SEE IF SEVERE ERROR HAS OCCURRED
         BO    GETNEXT             YES, IGNORE THIS ENTRY
         L     R14,JCTADDR         LOAD JCT ADDRESS
         USING JCT,R14             SET ADDRESSABILITY TO JCT
         LA    R15,JCTCJCL         SET JCL ERROR IN CONVERTER RTN CODE
         C     R15,JCTCNVRC        TEST CONVERTER RETURN CODE
         BE    BADERROR            BAD, GO PROCESS SEVERE ERROR
         DROP  R14                 DROP ADDRESSABILITY TO JCT
         EJECT
***********************************************************************
*        WE MUST DETERMINE IF THE CURRENT STATEMENT IS THE LAST       *
*        STATEMENT FOR THE STEP.  IF THE STATEMENT IS A DD STATEMENT  *
*        AND IT IS THE LAST STATEMENT OF THE STEP, THE TEXT INDICATOR *
*        WILL REFLECT LAST STATEMENT OF THE STEP.  IF, HOWEVER, THE   *
*        CURRENT STATEMENT IS AN EXEC STATEMENT AND IT HAS NO DD      *
*        STATEMENTS, THIS INDICATOR WILL NOT BE ON, SO WE HAVE TO     *
*        CHECK FOR THIS CONDITION ALSO.                               *
***********************************************************************
RECORD1  TM    STRINDCS,LASTSTMT   LAST STMT FOR STEP?
         BO    RECORD3             YES, BRANCH
         TM    STRINDCS,EXECSTR    EXEC STMT?
         BNO   RECORD2             NO, BRANCH
         TM    STREINDC,ETXNODD    STEP HAS NO DD STMTS?
         BO    RECORD3             TRUE, ALSO LAST STMT FOR STEP
***********************************************************************
*        AT THIS POINT THE STMT IS NOT THE LAST STMT FOR STEP         *
***********************************************************************
RECORD2  NI    EOFIND,X'FE'        TURN OFF LAST STMT IND
         B     RECORD4             GET OUT
***********************************************************************
*        AT THIS POINT THE STMT IS THE LAST STMT FOR STEP             *
***********************************************************************
RECORD3  OI    EOFIND,ENDSTEP      TURN ON LAST STMT IND
RECORD4  TM    STRINDCS,JOBSTR     JOB STATEMENT?
         BO    JOBCARD             YES, BRANCH
         TM    STRINDCS,EXECSTR    EXEC STATEMENT?
         BO    EXECARD             YES, BRANCH
         TM    STRINDCS,DDSTR      DD STATEMENT?
         BO    DDCARD              YES, BRANCH
         TM    STRINDCS,PROCSTR    PROC STATEMENT?
         BO    GETNEXT             YES, BRANCH
         TM    STRINDCS,JDVBSTR    JDT OUTPUT STATEMENT?
         BO    JDTCARD             YES, BRANCH
         LA    R15,1               SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     GETNEXT             GO GET ANOTHER STATEMENT
         EJECT
***********************************************************************
*        THE TEXT OF THE JOBCARD IS AS FOLLOWS:                       *
*            1)  2 BYTE LENGTH OF TEXT STRING INCLUDING ITSELF        *
*            2)  1 BYTE INDICATOR COMMON TO ALL TEXT RECORDS          *
*            3)  3 BYTES OF MISCELLANEOUS INDICATORS                  *
*            4)  1 BYTE INDICATOR X'B4' INDICATING JOB POS PARAMS     *
*            5)  1 BYTE NUMBER OF POSITIONAL PARAMETERS               *
*                1ST POS PARAM IS JOBNAME                             *
*                2ND POS PARAM IS ACCT PARAM LIST                     *
*                3RD POS PARAM IS PGMR NAME                           *
*            5A) JOBNAME PRECEDED BY A 1 BYTE LENGTH FIELD            *
*            5B) HASP ACCOUNTING PARAMETERS PRECEDED BY A             *
*                1 BYTE LENGTH FIELD LOOKS LIKE THE FOLLOWING         *
*                THE 1ST HALF BYTE IS '8' IF MORE THAN 1 ACCT ENTRY   *
*                IF MORE THAN 1 ACCT ENTRY -                          *
*                THE 2ND HALF BYTE IS THE NUMBER OF ACCT ENTRIES      *
*                FOLLOWED BY A VARIABLE LENGTH LIST OF HASP PARAMETERS*
*                EACH PRECEDED BY A 1 BYTE LENGTH FIELD               *
*                IF ONLY 1 ACCT ENTRY -                               *
*                THE 2ND HALF BYTE IS THE LENGTH OF THE ACCT ENTRY    *
*                FOLLOWED BY THE ACCOUNTING ENTRY                     *
*            5C) PGMR NAME PRECEDED BY A 1 BYTE LENGTH FIELD          *
*            6)  VARIABLE LENGTH LIST OF KEYWORD PARAMETERS           *
*                EACH IS PRECEDED BY A 1 BYTE KEY, 1 BYTE NUMBER OF   *
*                POSITIONAL SUBPARAMETERS PRESENT, AND A LIST OF      *
*                SUBPARAMETERS EACH PRECEDED BY A 1 BYTE LENGTH FIELD *
*                WHICH MAY BE ZERO IF OMITTED AND FOLLOWED BY ANOTHER *
*                POSITIONAL PARAMETER.                                *
***********************************************************************
         EJECT
JOBCARD  EQU   *
***********************************************************************
*        INITIALIZE ENTRY IN TABLE SINCE ONE MUST ALWAYS BE CREATED   *
***********************************************************************
JOBINIT  L     R14,JCTADDR         LOAD JCT ADDRESS
         USING JCT,R14             SET ADDRESSABILITY TO JCT
         MVI   ENTRYTYP,TYPJOB     SET TO JOB ENTRY
         MVI   JENTRY,C' '         BLANK FIRST BYTE OF JOB INFO
         MVC   JENTRY+1(30),JENTRY BLANK ENTIRE JOB INFO
         ST    R7,LASTENT          SAVE ADDR OF LAST ENTRY IN TABLE
         ST    R7,FIRSTENT         SAVE ADDR OF FIRST ENTRY IN TABLE
         XC    CLASSFLD,CLASSFLD   ZERO DETERMINED JOB CLASS
         XC    MAXTIME,MAXTIME     CLEAR MAXIMUM CPU TIME
         TM    JCTJOBFL,JCTSTCJB   IS THIS A STARTED TASK?
         BNO   JOBINIT1            NO, BRANCH
         OI    JOBIND,JOBSTC       TURN ON STC INDICATOR
JOBINIT1 TM    JCTJOBFL,JCTTSUJB   IS THIS A TSO USER?
         BNO   JOBINIT2            NO, BRANCH
         OI    JOBIND,JOBTSO       TURN ON TSO INDICATOR
         DROP  R14                 DROP ADDRESSABILITY TO JCT
***********************************************************************
*        INITIALIZE MSG HANDLER PARAMETERS ON FIRST ENTRY             *
***********************************************************************
JOBINIT2 LA    R15,1               SET REG TO 1
         ST    R15,CARDNO          SET CARD COUNT TO 1
         XC    MSGCOUNT,MSGCOUNT   ZERO MESSAGE COUNTER
         XC    RESOURCE,RESOURCE   CLEAR JES2 RESOURCES
         MVI   INCLASS,C'A'        SET INPUT DEFAULT CLASS TO 'A'
         MVI   U7TEST,C'N'         SET UCC7 LOAD JOB TO 'N' FOR NO
         EJECT
***********************************************************************
*        START SCAN OF JOB CARD POSITIONAL PARAMETERS                 *
*            1ST POS PARAM IS ACCT NUMBER UNLESS ONLY 1 ENTRY         *
*            2ND POS PARAM IS BIN LOC UNLESS ONLY 2 ENTRIES           *
*            3RD POS PARAM IS EST TIME UNLESS ONLY 3 ENTRIES          *
*            LAST ENTRY IS ALWAYS PROGRAMMER NAME                     *
***********************************************************************
JOBSTART XC    LASTEXEC,LASTEXEC NO PREVIOUS EXEC CARD
         LA    R2,STRJKEY          LOAD START OF TRUE TEXT
         ST    R2,PARMADDR         SAVE START OF PARAMETER ADDRESS
         LA    R2,1(,R2)           INCR PAST JOB POSIT PARAM KEYWORD
         SLR   R15,R15             CLEAR REGISTER FOR IC
         IC    R15,0(R2)           LOAD NUMBER OF POS SUBPARAMS
         CH    R15,H#3             SEE IF THREE (JOBNAME, ACCT, PRMRNM)
         BNL   JOBCK1              YES, BRANCH
         TM    JOBIND,JOBSTC+JOBTSO ARE ALL PARAMETERS REQUIRED?
         BM    JOBCK1              NO, BRANCH
         LA    R15,2               SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     JOBLOOP             BYPASS FIELDS
JOBCK1   LA    R2,1(,R2)           INCR PAST NUM OF POS SUBPARAMS
JOBNM    SLR   R3,R3               CLEAR REG FOR ICM
         ICM   R3,1,0(R2)          LOAD JOB NAME LENGTH
         BZ    JOBNM2              LENGTH ZERO, DO NOT MOVE
         CH    R3,H#8              SEE IF LENGTH > 8
         BNH   *+16                NO, CONTINUE
         LA    R15,3               SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     JOBLOOP             BYPASS FIELDS
         MVC   JNAME,BLANKS        BLANK THE JOB NAME
         BCTR  R3,0                MAKE MACHINE LENGTH
         EX    R3,MOVE1            MOVE JOB NAME TO SAVE TABLE
         LA    R3,1(,R3)           RESTORE LENGTH
         MVC   JOBNAME,JNAME       SAVE JOB NAME
         CLC   JNAME,C#MOUNT       SEE IF MOUNT
         BNE   JOBNM2              NO, BRANCH
         OI    JOBIND2,MOUNT       SET MOUNT AUTHORITY
JOBNM2   LA    R2,1(R3,R2)         INCREMENT PAST JOB NAME
         TM    JOBIND,JOBSTC+JOBTSO ARE ACCOUNTING/PGMR NAME REQUIRED?
         BM    JOBLOOP             NO, BRANCH
         EJECT
JOBACT   SLR   R4,R4               CLEAR REGISTER FOR ICM
         ICM   R4,1,0(R2)          INSERT CONTROL BYTE
         BNM   JOBACT1             HIGH ORDER BIT NOT ON, ONLY 1 PARAME
         N     R4,F#127            'AND' OUT THE HIGH ORDER BIT
         LA    R2,1(,R2)           INCREMENT PAST CONTROL BYTE
         LTR   R4,R4               TEST NUMBER OF ACCOUNTING PARMS
         BNZ   JOBACT2             NOT ZERO, BRANCH
         LA    R15,29              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         AIF   ('&BINREQD' NE 'YES').BIN1
         LA    R15,33              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
.BIN1    ANOP
         B     JOBPGMR             BYPASS ACCOUNTING PROCESSING
JOBACT1  LA    R4,1                SET NUMBER OF ACCOUNTING FIELDS TO 1
         EJECT
***********************************************************************
*                                                                     *
*        WE ARE CHECKING THE FIRST ACCOUNTING FIELD.  AN SVC          *
*        WILL BE CALLED TO DO THE DETAILED VALIDATION OF THE          *
*        VALUES.                                                      *
*                                                                     *
***********************************************************************
JOBACT2  ICM   R3,1,0(R2)          LOAD PARAMETER LENGTH
         BNZ   *+16                NOT ZERO, BRANCH
         LA    R15,29              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     JOBACT10            BYPASS ACCT NUM
***********************************************************************
*        SAVE THE JOB ACCOUNTING FIELD                                *
***********************************************************************
JOBACT3  BCTR  R3,0                MAKE MACHINE LENGTH
         MVC   JACCTNO,BLANKS      BLANK JOB ACCOUNTING
         MVC   JACCT,BLANKS        BLANK JOB ACCOUNTING
         EX    R3,MOVE2            MOVE ACCT NUM TO SAVE TABLE
         EX    R3,MOVE16           MOVE ACCT NUM TO WORK AREA
         LA    R3,1(,R3)           RESTORE LENGTH
         STC   R3,JACCTLEN         SAVE LENGTH OF ACCT NUM
***********************************************************************
*        CHECK THE FIRST POSITION OF THE FIRST ACCOUNTING FIELD       *
*        FOR ONE OF THE FOLLOWING:                                    *
*        "S"  - TSD - SYSTEMS SUPPORT                                 *
*        "O"  - OPD - OPERATIONS                                      *
*        "D"  - SDD - SYSTEMS DEVELOPMENT                             *
*        "F"  - FCS - TRUE PRODUCTION                                 *
*        REST - PSEUDO PRODUCTION                                     *
***********************************************************************
         CLI   JACCTNO,C'S'        SYSTEMS SUPPORT JOB?
         BE    JOBACT4             YES, BYPASS RESOURCE SETTING
         CLI   JACCTNO,C'O'        OPERATIONS SUPPORT JOB?
         BE    JOBACT5             YES, BRANCH
         CLI   JACCTNO,C'F'        PRODUCTION JOB?
         BE    JOBACT7             YES, BRANCH
         B     JOBACT6             MUST BE TEST
***********************************************************************
*                                                                     *
*                    T E C H     S U P P O R T                        *
*                                                                     *
***********************************************************************
JOBACT4  OI    JOBIND,JOBTECH      TURN ON SYSTEMS SUPPORT INDICATOR
         B     JOBACT8             BYPASS CHECK
***********************************************************************
*                                                                     *
*                      O P E R A T I O N S                            *
*                                                                     *
***********************************************************************
JOBACT5  OI    JOBIND,JOBOPER      TURN ON OPERATIONS JOB INDICATOR
         B     JOBACT8             BYPASS CHECK
***********************************************************************
*                                                                     *
*                        T E S T I N G                                *
*                                                                     *
***********************************************************************
JOBACT6  OI    JOBIND,JOBTEST      TURN ON TEST JOB INDICATOR
         OI    RESOURCE,TESTING    YES, ADD 'TESTING' RESOURCE
         B     JOBACT8             BYPASS CHECK
***********************************************************************
*                                                                     *
*                     P R O D U C T I O N                             *
*                                                                     *
***********************************************************************
JOBACT7  OI    JOBIND,JOBPROD      TURN ON PRODUCTION JOB INDICATOR
         OI    RESOURCE,PROD       ADD 'PRODUCTION' RESOURCE
***********************************************************************
*                                                                     *
*                     A L L    J O B S                                *
*                                                                     *
***********************************************************************
JOBACT8  GETMAIN R,LV=256          GET 256 BYTE WORK AREA
         ST    R1,ACTWORK          SAVE GETMAIN ADDRESS
         LA    R0,JACCT            POINT TO 20 BYTE JOB ACCT FIELD
         SVC   250                 CALL ACCOUNTING CHECK SVC
         LR    R5,R15              SAVE RETURN CODE
         L     R1,ACTWORK          LOAD ADDRESS OF WORK AREA
         FREEMAIN R,LV=256,A=(1)   FREE THE WORK AREA
         LTR   R5,R5               TEST RETURN CODE FROM ACCT RTN
         BZ    JOBACT10            ZERO, OK
JOBACT9  LA    R15,30              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
JOBACT10 LA    R2,1(R3,R2)         INCREMENT PAST ACCT
         BCTR  R4,0                REDUCE ACCOUNT PARM COUNT BY 1
         CH    R4,H#1              SEE IF ANOTHER ACCT PARM (BIN NBR)
         BL    JOBACT11            NO, ERROR
         IC    R3,0(R2)            LOAD LENGTH OF BIN NUMBER
         LTR   R3,R3               TEST LENGTH OF BIN NUMBER
         BZ    JOBACT11            ZERO, NOT ENTERED
         B     JOBACT12            NOT ZERO, GOOD, BRANCH
JOBACT11 DS    0H                  SET MISSING BIN NUMBER MESSAGE
         AIF   ('&BINREQD' NE 'YES').BIN3
         LA    R15,33              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
.BIN3    ANOP
         B     JOBPGMR             DONE WITH ACCOUNTING PARMS
JOBACT12 LA    R2,1(R3,R2)         INCREMENT PAST PARM
         IC    R3,0(R2)            LOAD LENGTH OF NEXT PARM
JOBACT13 BCT   R4,JOBACT12         LOOP UNTIL PROCESSED ALL ACCT FIELDS
         EJECT
***********************************************************************
*        SAVE THE PROGRAMMER NAME                                     *
***********************************************************************
JOBPGMR  ICM   R3,1,0(R2)          LOAD PGMR NAME LENGTH
         BZ    PGMREND             ZERO LENGTH, MISSING PARAM
         CH    R3,H#20             SEE IF LENGTH > 20
         BNH   *+16                NO, CONTINUE
         LA    R15,4               SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     JOBLOOP             BYPASS FIELDS
         CH    R3,H#10             SEE IF LENGTH > 10
         BNH   PGMR10              IF NOT > 10, OK
         LH    R3,H#10             MAKE LENGTH = 10
PGMR10   BCTR  R3,0                MAKE MACHINE LENGTH
         EX    R3,MOVE3            MOVE PGMR NAME TO SAVE TABLE
         ICM   R3,1,0(R2)          RELOAD PGMR NAME LENGTH
PGMREND  B     JOBLOOP             LOOP FOR NEXT PARAMETER
         EJECT
***********************************************************************
*        WE ARE LOOKING FOR INVALID KEYWORDS OR KEYWORDS HAVING       *
*        ILLEGAL VALUES OR OTHER THAN DEFAULT                         *
***********************************************************************
*
***********************************************************************
*        KEYWORD ENTRIES ARE NORMALLY AS FOLLOWS:                     *
*            1)  1 BYTE HEX KEYWORD                                   *
*            2)  1 BYTE NUMBER OF SUBPARAMETERS                       *
*            3)  LIST OF POSITIONAL SUBPARAMETERS EACH PRECEDED BY A  *
*                1 BYTE LENGTH FIELD                                  *
*        THERE ARE OCCASIONS WHEN THE POSITIONAL SUBPARAMETERS WILL   *
*        HAVE POSITIONAL SUBPARAMETERS THEMSELVES                     *
*        THIS WILL BE FLAGGED IN THE LENGTH FIELD FOR THAT SUBPARAM   *
*        BY A HIGH ORDER BIT IN THE FIELD.  IN THIS CASE, THIS IS NOT *
*        A LENGTH FIELD, BUT A COUNT OF SUBPARAMETERS, WHICH WILL BE  *
*        A LIST OF PARAMETERS, EACH PRECEDED BY A 1 BYTE LENGTH FIELD.*
*        THUS THE ENTRY FOR A SUBPARAMETER WITH SUBPARAMETERS WILL    *
*        APPEAR AS FOLLOWS:                                           *
*            1)  A 1 BYTE NUMBER OF SUBPARAMS AS INDICATED BY A       *
*                HIGH ORDER BIT                                       *
*            2)  A LIST OF SUBPARAMETERS EACH PRECEDED BY A 1 BYTE    *
*                LENGTH FIELD                                         *
***********************************************************************
*
JOBPARMS CLI   0(R2),ENDK          END OF TEXT STRING?????
         BNE   JCLASS              NO, BRANCH
***********************************************************************
*        IF THE JOB CPU TIME LIMIT WAS NOT SPECIFIED ON THE JOB       *
*        CARD, AN INTERNAL TEXT KEY WITH 2 MINUTES OF CPU TIME        *
*        WILL BE ADDED TO THE TEXT FOR THE JOB CARD TO SET THE        *
*        JOBS DEFAULT TIME TO 2 MINUTES.                              *
***********************************************************************
         L     R15,MAXTIME         LOAD TIME FROM JOB CARD
         LTR   R15,R15             SEE IF DEFAULT (NOT ENTERED)
         BNZ   GETNEXT             NO, BRANCH
         TM    JOBIND,JOBSTC+JOBTSO SEE IF STC OR TSO
         BM    GETNEXT             YES, DO NOT RESET CPU TIME
         MVC   MAXTIME,F#120       SET DEFAULT CPU TIME
         MVC   0(8,R2),DEFTIME     SET DEFAULT CPU TIME TO 2
         L     R6,TEXTSTAR         RELOAD START OF TEXT STRING
         SLR   R3,R3               CLEAR REG FOR ICM
         ICM   R3,3,STRLTH         LOAD TEXT STRING LENGTH
         AH    R3,H#7              ADD LENGTH OF CPU TIME FIELD
         STCM  R3,3,STRLTH         SAVE NEW STRING LENGTH
         B     GETNEXT             YES, GO GET ANOTHER STRING
         EJECT
***********************************************************************
*        JOB CLASS                                                    *
***********************************************************************
JCLASS   CLI   0(R2),CLASSJK       SEE IF CLASS=KEY
         BNE   JESTIME             NO, BRANCH
         MVC   INCLASS,3(R2)       SAVE INPUT CLASS
         B     JOBLOOP             GO GET NEXT PARAM
         EJECT
***********************************************************************
*        JOB TIME                                                     *
***********************************************************************
JESTIME  CLI   0(R2),TIMEJK        SEE IF TIME= KEY
         BNE   JOBLOOP             NO, BRANCH
         LA    R2,1(,R2)           INCREMENT PAST KEYWORD DESCR
         SLR   R14,R14             CLEAR REGISTER FOR ICM
         ICM   R14,1,0(R2)         INSERT NUMBER OF SUBPARAMETERS
         BZ    JOBLOOP             NONE, IGNORE
         LA    R2,1(,R2)           INCREMENT PAST CONTROL BYTE
         SLR   R3,R3               CLEAR REGISTER FOR ICM
         ICM   R3,1,0(R2)          LOAD LENGTH OF FIRST TIME FIELD
         BZ    JESTIME2            ZERO, GO PROCESS SECONDS
         LA    R4,1(,R2)           SAVE LOCATION OF TIME
         LR    R5,R3               SAVE LENGTH OF TIME
JESTIME1 CLI   0(R4),C'0'          SEE IF LESS THAN ZERO
         BL    JESTIME6            YES, NOT NUMERIC, ERROR
         CLI   0(R4),C'9'          SEE IF GREATER THAN NINE
         BH    JESTIME6            YES, NOT NUMERIC, ERROR
         LA    R4,1(,R4)           INCREMENT TO NEXT DIGIT OF TIME
         BCT   R5,JESTIME1         LOOP UNTIL DONE
         BCTR  R3,0                MAKE MACHINE LENGTH
         EX    R3,PACK5            PACK TIME
         LA    R3,1(R3)            MAKE TRUE LENGTH AGAIN
         CVB   R15,DOUBLE          CONVERT TO BINARY
         MH    R15,H#60            MULTIPLY BY 60 FOR SECONDS
         ST    R15,MAXTIME         SAVE TIME
JESTIME2 LA    R2,1(R3,R2)         INCREMENT TO NEXT PARM
         BCTR  R14,0               REDUCE PARM COUNT BY 1
         LTR   R14,R14             TEST PARM COUNT
         BZ    JESTIME4            ZERO, DONE WITH TIME
         SLR   R3,R3               CLEAR REGISTER FOR ICM
         ICM   R3,1,0(R2)          LOAD LENGTH OF SECOND TIME FIELD
         BZ    JESTIME4            ZERO, DONE WITH TIME
         LA    R4,1(,R2)           SAVE LOCATION OF TIME
         LR    R5,R3               SAVE LENGTH OF TIME
JESTIME3 CLI   0(R4),C'0'          SEE IF LESS THAN ZERO
         BL    JESTIME6            YES, NOT NUMERIC, ERROR
         CLI   0(R4),C'9'          SEE IF GREATER THAN NINE
         BH    JESTIME6            YES, NOT NUMERIC, ERROR
         LA    R4,1(,R4)           INCREMENT TO NEXT DIGIT OF TIME
         BCT   R5,JESTIME3         LOOP UNTIL DONE
         BCTR  R3,0                MAKE MACHINE LENGTH
         EX    R3,PACK5            PACK TIME
         LA    R3,1(R3)            MAKE TRUE LENGTH AGAIN
         CVB   R15,DOUBLE          CONVERT TO BINARY
         A     R15,MAXTIME         ADD MINUTES TO SECONDS
         ST    R15,MAXTIME         SAVE CPU TIME
JESTIME4 L     R15,MAXTIME         RELOAD CPU TIME
         LTR   R15,R15             TEST FOR ZERO TIME
         BZ    JESTIME5            ZERO, BRANCH
         C     R15,F#86400         SEE IF TIME = 1440 (IN SECONDS)
         BNE   JOBLOOP             NO, BRANCH
         TM    JOBIND,JOBSTC+JOBTECH+JOBPROD SEE IF ALLOWED
         BM    JOBLOOP             YES, TIME=1440 OK ON JOB CARD
         LA    R15,7               SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     JOBLOOP             GET OUT
JESTIME5 MVC   MAXTIME,F#120       SET DEFAULT CPU TIME
         B     JOBLOOP             GET OUT
JESTIME6 LA    R15,6               SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     JOBLOOP             GET OUT
         EJECT
***********************************************************************
*        THIS ROUTINE WILL INCREMENT PAST THE STRING(S) BEING         *
*        PROCESSED.  NOTE THAT FOLLOWING THE KEYWORD DESCRIPTOR       *
*        FIELD IS A COUNT OF SUBPARAMETERS.  FOLLOWING THE COUNT      *
*        WILL BE A LENGTH OR DESCRIPTOR FIELD.  IF THE HIGH ORDER     *
*        BIT IS ON, THE FIELD IS A COUNT FIELD OF THE NUMBER OF       *
*        SUBPARAMETERS WHICH THE SUBPARAMETER ITSELF MAY HAVE.        *
*        IF THIS IS TRUE, THE DESCRIPTOR FIELD WILL BE FOLLOWED BY    *
*        A LENGTH FIELD FOR THE FIRST SUBPARAMETER.  IF THE HIGH      *
*        ORDER BIT IS NOT ON, IT IS ONLY A LENGTH FIELD FOR A         *
*        SINGLE SUBPARAMETER.                                         *
***********************************************************************
JOBLOOP  L     R2,PARMADDR         RESTORE START OF PARAMETER ADDRESS
         SLR   R5,R5               CLEAR REGISTER FOR ICM
         LA    R2,1(,R2)           INCREMENT PAST KEYWORD
         ICM   R5,1,0(R2)          LOAD SUBPARAMETER COUNT
         BNZ   JOBLOOP1            OK, BRANCH INTO ROUTINE
         LA    R2,1(,R2)           NONE, INCREMENT PAST COUNT
         B     JOBLOOP5            AND GET OUT OF ROUTINE
JOBLOOP1 LA    R2,1(,R2)           INCREMENT PAST KEYWORD DESCR
JOBLOOP2 SLR   R4,R4               CLEAR REGISTER FOR ICM
         ICM   R4,1,0(R2)          LOAD PARAMETER LENGTH
         BNM   JOBLOOP3            HIGH BIT NOT ON, ONLY 1 PARAMETER
         N     R4,F#127            'AND' OUT THE HIGH ORDER BIT
         LA    R2,1(,R2)           INCREMENT PAST CONTROL BYTE
         B     JOBLOOP4            BRANCH
JOBLOOP3 LA    R4,1                SET PARAM COUNT TO 1
JOBLOOP4 SLR   R3,R3               CLEAR REGISTER FOR ICM
         ICM   R3,1,0(R2)          LOAD PARAMETER LENGTH
         LA    R2,1(R3,R2)         INCREMENT PAST PARM
         BCT   R4,JOBLOOP4         LOOP UNTIL PROCESSED ALL PARMS
         BCT   R5,JOBLOOP2         LOOP UNTIL PROCESSED ALL PARMS
JOBLOOP5 ST    R2,PARMADDR         SAVE START OF PARAMETER ADDRESS
         B     JOBPARMS            CONTINUE
         EJECT
***********************************************************************
*        THE TEXT OF THE EXEC CARD TEXT IS AS FOLLOWS                 *
*            1)  2 BYTE LENGTH OF TEXT STRING INCLUDING ITSELF        *
*            2)  1 BYTE INDICATOR COMMON TO ALL TEXT RECORDS          *
*            3)  1 BYTE OF MISCELLANEOUS INDICATORS                   *
*            4)  1 BYTE INDICATOR X'94' INDICATING EXEC POS INFORMATN *
*            5)  1 BYTE NUMBER OF EXEC POSITIONAL PARAMETERS          *
*                THE 1ST POS PARAMETER IS THE STEP NAME               *
*                ALL OTHER POS PARAMETERS WILL BE IGNORED             *
*            6)  VARIABLE LENGTH LIST OF EXEC POS PARAMETERS          *
*                EACH PRECEDED BY A 1 BYTE LENGTH FIELD               *
*            7)  VARIABLE LENGTH LIST OF KEYWORD PARAMETERS           *
*                EACH IS PRECEDED BY A 1 BYTE KEY, 1 BYTE NUMBER OF   *
*                POSITIONAL SUBPARAMETERS PRESENT, AND A LIST OF      *
*                SUBPARAMETERS EACH PRECEDED BY A 1 BYTE LENGTH FIELD *
*                WHICH MAY BE ZERO IF OMITTED AND FOLLOWED BY ANOTHER *
*                POSITIONAL PARAMETER.                                *
***********************************************************************
         EJECT
EXECARD  EQU   *
***********************************************************************
*        UPDATE LAST EXEC TABLE (IF NEEDED) WITH UNIT INFO            *
***********************************************************************
EXECUPDT L     R7,LASTEXEC         LOAD ADDR OF LAST EXEC ENTRY
         LTR   R7,R7               SEE IF ADDR = 0
         BZ    EUPDT1              IF ZERO, NO UPDATE, BRANCH
         MVC   ETAPES,TAPECNT      MOVE STEP TAPE UNIT CNT TO TABLE
         MVC   EPRIVS,PRIVCNT      MOVE STEP PRIV UNIT CNT TO TABLE
         XC    TAPECNT,TAPECNT     ZERO TAPE UNIT CNT
         XC    PRIVCNT,PRIVCNT     ZERO PRIV UNIT CNT
         XC    LASTEXEC,LASTEXEC   ZERO ADDR OF LAST EXEC ENTRY
EUPDT1   TM    STREINDC,ETXPRCV    STATEMENT INVOKE A PROCEDURE?
         BO    PROCARD             YES, BRANCH
         EJECT
***********************************************************************
*        INITIALIZE NEW STEP ENTRY IN TABLE                           *
***********************************************************************
EXECINIT LH    R15,ENTCOUNT        LOAD TABLE ENTRY COUNT
         LA    R15,1(,R15)         ADD 1 TO COUNT
         CH    R15,MAXENTS         SEE IF MAXIMUM REACHED
         BNL   TBLFULL             MAXIMUM REACHED, BAG THE JOB AND EXI
         STH   R15,ENTCOUNT        STORE NEW ENTRY COUNT
         L     R7,LASTENT          LOAD ADDR OF LAST ENTRY IN TABLE
         LA    R7,ENTLEN(,R7)      INCREMENT TO NEXT ENTRY
         ST    R7,LASTENT          SAVE ADDR OF LAST ENTRY IN TABLE
         ST    R7,LASTEXEC         SAVE ADDR OF LAST EXEC ENTRY
         MVI   ENTRYTYP,TYPEXEC    SET TO EXEC ENTRY
         MVI   EENTRY,C' '         BLANK 1ST BYTE OF EXEC INFO
         MVC   EENTRY+1(23),EENTRY BLANK MOST OF EXEC INFO
         XC    ELIBIND(7),ELIBIND  ZERO REST OF EXEC INFO
         MVC   EREGION,H#512       SET DEFAULT REGION SIZE TO 512K
         TM    STREINDC,ETXPROC    STATEMENT FROM A PROC??
         BNO   EINIT1              NO, BRANCH
         MVC   EJSTEP,SAVEPROC     MOVE JOB STEP NAME TO TABLE
EINIT1   TM    STREINDC,ETXSTPLB   STEP HAVE STEPLIB DD??
         BNO   EINIT2              NO, BRANCH
         OI    ELIBIND,ESTEPLIB    SET INDICATOR IN TABLE
EINIT2   TM    JOBIND,JOBLIB       DOES JOB HAVE JOBLIB??
         BNO   EXECSTAR            NO, BRANCH
         OI    ELIBIND,EJOBLIB     SET INDICATOR IN TABLE
         EJECT
EXECSTAR MVC   ECARDNO,CARDNO      SAVE CARD NUMBER OF THIS STATEMENT
         LA    R2,STREKEY          LOAD START OF TRUE TEXT
         ST    R2,PARMADDR         SAVE START OF PARAMETER ADDRESS
EXECPARM CLI   0(R2),ENDK          END OF TEXT STRING?????
         BE    PROCSEAR            YES, GO SEE IF FROM A PROC
         EJECT
***********************************************************************
*        EXEC STEPNAME                                                *
***********************************************************************
ESTEPN   CLI   0(R2),EXECK         SEE IF STEPNAME KEY
         BNE   EPGM                NO, BRANCH
         SLR   R4,R4               CLEAR REG FOR ICM
         ICM   R4,1,1(R2)          LOAD NUMBER OF SUBPARAMS
         BZ    EXELOOP             ZERO, NO STEP NAME
         SLR   R3,R3               CLEAR REG FOR ICM
         ICM   R3,1,2(R2)          LOAD LENGTH OF 1ST POS SUBPARAM
         BZ    EXELOOP             ZERO, NO STEP NAME, BRANCH
         CH    R3,H#8              SEE IF MAX LENGTH EXCEEDED
         BNH   *+16                NO, CONTINUE
         LA    R15,8               SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     EXELOOP             GET OUT
         BCTR  R3,0                MAKE MACHINE LENGTH
         TM    STREINDC,ETXPROC    STATEMENT FROM A PROC
         BO    ESTEPN1             YES, THEN NAME IS PROC STEP NAME
         EX    R3,MOVE5            MOVE NAME TO JOBSTEP NAME
         B     EXELOOP             BRANCH
ESTEPN1  EX    R3,MOVE6            MOVE NAME TO PROCSTEP NAME
         B     EXELOOP             BRANCH
         EJECT
***********************************************************************
*        EXEC PGM                                                     *
***********************************************************************
EPGM     CLI   0(R2),PGMEK         SEE IF PGM= KEY
         BNE   EREGN               NO, BRANCH
         SLR   R3,R3               CLEAR REG FOR ICM
         ICM   R3,1,2(R2)          LOAD LENGTH OF PGM NAME
         BZ    EXELOOP             ZERO, NULL, BRANCH
         BM    EXELOOP             HIGH BIT ON, REFERBACK, IGNORE
         CH    R3,H#8              SEE IF LENGTH > 8
         BNH   *+16                NO, CONTINUE
         LA    R15,9               SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     EXELOOP             GET OUT
         BCTR  R3,0                MAKE MACHINE LENGTH
         EX    R3,MOVE7            MOVE PGM NAME TO TABLE
         SPACE
         CLC   PGMCICS,3(R2)       Q. CICS PGM NAME ?
         BNE   CHK7074             NO, TRY 7074
         OI    RESOURCE+1,PCICS    YES, ATTACH 'CICS' RESOURCE
         B     EXELOOP             & GET NEXT EXEC PARM
CHK7074  CLC   PGM7074,3(R2)       Q. PGM NAME 7074 ?
         BNE   CHK1401             NO, TRY 1401
         OI    RESOURCE+1,P7074    YES,ATTACH '7074' RESOURCE
         B     EXELOOP             & GET NEXT EXEC PARM
CHK1401  CLC   PGM1401,3(R2)       Q. PGM NAME 1401 ?
         BNE   CHKXMIT             NO, TRY XMISSIONS
         OI    RESOURCE,P1401      YES, ATTACH '1401' RESOURCE
         B     EXELOOP             & GET NEXT EXEC PARM
CHKXMIT  CLC   PGMNDM,3(R2)        Q. PGM NAME FOR NDM   ?
         BNE   U7LOAD              NO, GET NEXT EXEC PARM
         OI    RESOURCE,NDM        YES, ATTACH 'NDM' RESOURCE
         B     EXELOOP             BRANCH
U7LOAD   CLC   PGMUC7,3(R2)        Q. PGM NAME FOR UCC7 LOAD PROG ?
         BNE   EXELOOP             NO, GET NEXT EXEC PARM
         MVI   U7TEST,C'Y'         MOVE TO UCC7 LOAD PROGRAM
         B     EXELOOP             BRANCH
         EJECT
***********************************************************************
*        EXEC REGION                                                  *
***********************************************************************
EREGN    CLI   0(R2),REGINEEK      SEE IF REGION= KEY
         BNE   EREGN@              NO, BRANCH
         LA    R2,1(,R2)           INCREMENT PAST KEYWORD
         SLR   R3,R3               CLEAR REG FOR ICM
         ICM   R3,1,0(R2)          LOAD SUBPARAMETER COUNT
         BZ    EXELOOP             NO SUBPARAMETERS, BRANCH
         LA    R2,1(,R2)           INCREMENT PAST NUMBER OF FIELDS
         ICM   R3,1,0(R2)          LOAD LENGTH OF REGION PARAM
         BZ    EXELOOP             ZERO, NULL, BRANCH
         CH    R3,H#8              SEE IF MAX LENGTH EXCEEDED
         BNH   *+16                NO, CONTINUE
         LA    R15,10              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     EXELOOP             GET OUT
         CH    R3,H#3              SEE IF AT LEAST 3 CHARACTERS
         BL    EXELOOP             NO, MAX IS 99K, IGNORE
         LA    R15,0(R3,R2)        POINT TO LAST CHAR OF REGION SIZE
         NI    ELIBIND,255-EREGIONK-EREGIONM TURN OFF REGION INDS
         CLI   0(R15),C'K'         END IN 'K'
         BE    EREGNK              YES, BRANCH
         CLI   0(R15),C'M'         END IN 'M'
         BE    EREGNM              YES, BRANCH
         B     EREGN1              NO, REGION MUST BE NUMERIC
EREGNK   BCTR  R3,0                REDUCE REGION LENGTH BY 1
         OI    ELIBIND,EREGIONK    REMEMBER REGION SIZE IN 'K'
         B     EREGN1              GO PROCESS NUMERIC PORTION
EREGNM   BCTR  R3,0                REDUCE REGION LENGTH BY 1
         OI    ELIBIND,EREGIONM    REMEMBER REGION SIZE IN 'M'
EREGN1   LA    R4,1(,R2)           SAVE LOCATION OF REGION
         LR    R5,R3               SAVE LENGTH OF REGION
EREGN2   CLI   0(R4),C'0'          SEE IF LESS THAN ZERO
         BL    EREGN5              YES, NOT NUMERIC, ERROR
         CLI   0(R4),C'9'          SEE IF GREATER THAN NINE
         BH    EREGN5              YES, NOT NUMERIC, ERROR
         LA    R4,1(,R4)           INCREMENT TO NEXT DIGIT OF REGION
         BCT   R5,EREGN2           LOOP UNTIL DONE
         BCTR  R3,0                MAKE MACHINE LENGTH
         EX    R3,PACK1            PACK REGION SIZE
         CVB   R15,DOUBLE          CONVERT REGION SIZE TO BINARY
         TM    ELIBIND,EREGIONK    WAS REGION SPECIFIED IN 'K'
         BO    EREGN4              YES, BRANCH
         TM    ELIBIND,EREGIONM    WAS REGION SPECIFIED IN 'M'
         BO    EREGN3              YES, BRANCH
         SRA   R15,10              DIVIDE BY 1024 FOR 'K' VALUE
         B     EREGN4              BRANCH
EREGN3   SLA   R15,10              MULTIPLY BY 1024 FOR 'M' VALUE
EREGN4   STH   R15,EREGION         STORE REGION SIZE IN TABLE
         B     EXELOOP             BRANCH
EREGN5   LA    R15,11              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     EXELOOP             GET OUT
         EJECT
***********************************************************************
*        EXEC REGION.                                                 *
***********************************************************************
EREGN@   CLI   0(R2),REGINPEK      SEE IF REGION. KEY
         BNE   ETIME               NO, BRANCH
         LA    R2,1(,R2)           INCREMENT PAST KEYWORD
         SLR   R4,R4               ZERO REGISTER
         ICM   R4,1,0(R2)          LOAD NUMBER OF SUBPARAMS
         BNZ   *+16                NOT ZERO, BRANCH
         LA    R15,10              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     EXELOOP             GET OUT
         CH    R4,H#2              CHECK NUMBER OF SUBPARAMS
         BNH   *+16                NOT > 2, OK
         LA    R15,10              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     EXELOOP             GET OUT
         LA    R2,1(,R2)           INCREMENT PAST NUMBER OF SUBPARAMETE
         SLR   R3,R3               ZERO REGISTER
         ICM   R3,1,0(R2)          LOAD LENGTH OF STEPNAME
         BNZ   *+16                NOT ZERO, BRANCH
         LA    R15,10              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     EXELOOP             GET OUT
         CH    R3,H#8              SEE IF MAX LENGTH EXCEEDED
         BNH   *+16                NO, CONTINUE
         LA    R15,10              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     EXELOOP             GET OUT
         BCTR  R3,0                MAKE MACHINE LENGTH
         EX    R3,COMPARE3         SEE IF OVERRIDE FOR CURRENT STEP
         BNE   EXELOOP             NO, GET OUT
         LA    R2,2(R2,R3)         SET REG TO START OF 2ND PARAM
         ICM   R3,1,0(R2)          LOAD LENGTH OF 2ND PARAM
         BZ    EXELOOP             ZERO, NULL, BRANCH
         CH    R3,H#8              SEE IF MAX LENGTH EXCEEDED
         BNH   *+16                NO, CONTINUE
         LA    R15,10              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     EXELOOP             GET OUT
         CH    R3,H#3              SEE IF AT LEAST 3 CHARACTERS
         BL    EXELOOP             NO, MAX IS 99K, IGNORE
         LA    R15,0(R3,R2)        POINT TO LAST CHAR OF REGION SIZE
         NI    ELIBIND,255-EREGIONK-EREGIONM TURN OFF REGION INDS
         CLI   0(R15),C'K'         END IN 'K'
         BE    EREGN@K             YES, BRANCH
         CLI   0(R15),C'M'         END IN 'M'
         BE    EREGN@M             YES, BRANCH
         B     EREGN@1             NO, REGION MUST BE NUMERIC
EREGN@K  BCTR  R3,0                REDUCE REGION LENGTH BY 1
         OI    ELIBIND,EREGIONK    REMEMBER REGION SIZE IN 'K'
         B     EREGN@1             GO PROCESS NUMERIC PORTION
EREGN@M  BCTR  R3,0                REDUCE REGION LENGTH BY 1
         OI    ELIBIND,EREGIONM    REMEMBER REGION SIZE IN 'M'
EREGN@1  LA    R4,1(,R2)           SAVE LOCATION OF REGION
         LR    R5,R3               SAVE LENGTH OF REGION
EREGN@2  CLI   0(R4),C'0'          SEE IF LESS THAN ZERO
         BL    EREGN@5             YES, NOT NUMERIC, ERROR
         CLI   0(R4),C'9'          SEE IF GREATER THAN NINE
         BH    EREGN@5             YES, NOT NUMERIC, ERROR
         LA    R4,1(,R4)           INCREMENT TO NEXT DIGIT OF REGION
         BCT   R5,EREGN@2          LOOP UNTIL DONE
         BCTR  R3,0                MAKE MACHINE LENGTH
         EX    R3,PACK4            PACK REGION SIZE
         CVB   R15,DOUBLE          CONVERT REGION SIZE TO BINARY
         TM    ELIBIND,EREGIONK    WAS REGION SPECIFIED IN 'K'
         BO    EREGN@4             YES, BRANCH
         TM    ELIBIND,EREGIONM    WAS REGION SPECIFIED IN 'M'
         BO    EREGN@3             YES, BRANCH
         SRA   R15,10              DIVIDE BY 1024 FOR 'K' VALUE
         B     EREGN@4             BRANCH
EREGN@3  SLA   R15,10              MULTIPLY BY 1024 FOR 'M' VALUE
EREGN@4  STH   R15,EREGION         STORE REGION SIZE IN TABLE
         B     EXELOOP             BRANCH
EREGN@5  LA    R15,11              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     EXELOOP             GET OUT
         EJECT
***********************************************************************
*        EXEC TIME                                                    *
***********************************************************************
ETIME    CLI   0(R2),TIMEEEK       SEE IF TIME= KEY
         BNE   ETIME@              NO, BRANCH
         LA    R2,1(,R2)           INCREMENT PAST KEYWORD DESCR
         SLR   R4,R4               CLEAR REGISTER FOR ICM
         ICM   R4,1,0(R2)          LOAD NUMBER OF SUBPARAMETERS
         BZ    EXELOOP             ZERO, IGNORE
         LA    R2,1(,R2)           INCREMENT PAST CONTROL BYTE
ETIME1   SLR   R3,R3               CLEAR REGISTER FOR ICM
         ICM   R3,1,0(R2)          LOAD LENGTH OF FIRST TIME FIELD
         CH    R3,H#4              COMPARE LENGTH TO 4
         BL    EXELOOP             LT 4, GET OUT
         BE    *+16                EQ 4, COMPARE
         LA    R15,12              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     EXELOOP             GET OUT
         CLC   1(4,R2),C#1440      SEE IF TIME = 1440
         BNE   EXELOOP             NO, BRANCH
         TM    JOBIND,JOBSTC+JOBTECH+JOBPROD SEE IF ALLOWED
         BM    EXELOOP             YES, TIME=1440 OK ON JOB CARD
         LA    R15,13              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     EXELOOP             GET OUT
         EJECT
***********************************************************************
*        EXEC TIME.                                                   *
***********************************************************************
ETIME@   CLI   0(R2),TIMEPEK       SEE IF TIME. KEY
         BNE   EXELOOP             NO, BRANCH
         SLR   R3,R3               ZERO WORK REG
         SLR   R4,R4               ZERO WORK REG
         LA    R2,1(,R2)           INCREMENT PAST KEYWORD
         ICM   R4,1,0(R2)          LOAD NUMBER OF SUBPARAMS
         BZ    EXELOOP             NO SUBPARAMS, BRANCH
         CH    R4,H#3              SEE IF MORE THAN 3 SUBPARAMS
         BNH   *+16                NO, BRANCH
         LA    R15,12              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     EXELOOP             GET OUT
         LA    R2,1(,R2)           INCREMENT PAST NUMBER OF SUBPARAMETE
         CH    R4,H#2              SEE IF AT LEAST 2 SUBPARAMS
         BL    EXELOOP             ONLY ONE, IGNORE STEPNAME
         ICM   R3,1,0(R2)          LOAD LENGTH OF STEPNAME
         BZ    EXELOOP             NO STEPNAME, BRANCH
         CH    R3,H#8              SEE IF MAX LENGTH EXCEEDED
         BNH   *+16                NO, BRANCH
         LA    R15,12              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     EXELOOP             GET OUT
         BCTR  R3,0                MAKE MACHINE LENGTH
         EX    R3,COMPARE3         SEE IF CORRECT STEPNAME
         BNE   EXELOOP             NO, GET OUT
         LA    R2,2(R2,R3)         LOAD ADDR OF 2ND SUBPARAM
         IC    R3,0(R2)            LOAD LENGTH OF MINUTES PORTION
         CH    R3,H#4              COMPARE LENGTH TO 4
         BL    EXELOOP             LT 4, GET OUT
         BE    *+16                EQ 4, COMPARE
         LA    R15,12              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     EXELOOP             GET OUT
         CLC   1(4,R2),C#1440      SEE IF TIME = 1440
         BNE   EXELOOP             NO, BRANCH
         TM    JOBIND,JOBSTC+JOBTECH+JOBPROD SEE IF ALLOWED
         BM    EXELOOP             YES, TIME=1440 OK ON EXECUTE CARD
         LA    R15,13              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     EXELOOP             GET OUT
         EJECT
***********************************************************************
*        THIS ROUTINE WILL INCREMENT PAST THE STRING(S) BEING         *
*        PROCESSED.  NOTE THAT FOLLOWING THE KEYWORD DESCRIPTOR       *
*        FIELD IS A COUNT OF SUBPARAMETERS.  FOLLOWING THE COUNT      *
*        WILL BE A LENGTH OR DESCRIPTOR FIELD.  IF THE HIGH ORDER     *
*        BIT IS ON, THE FIELD IS A COUNT FIELD OF THE NUMBER OF       *
*        SUBPARAMETERS WHICH THE SUBPARAMETER ITSELF MAY HAVE.        *
*        IF THIS IS TRUE, THE DESCRIPTOR FIELD WILL BE FOLLOWED BY    *
*        A LENGTH FIELD FOR THE FIRST SUBPARAMETER.  IF THE HIGH      *
*        ORDER BIT IS NOT ON, IT IS ONLY A LENGTH FIELD FOR A         *
*        SINGLE SUBPARAMETER.                                         *
***********************************************************************
EXELOOP  L     R2,PARMADDR         RESTORE START OF PARAMETER ADDRESS
         SLR   R5,R5               CLEAR REGISTER FOR ICM
         LA    R2,1(,R2)           INCREMENT PAST KEYWORD
         ICM   R5,1,0(R2)          LOAD SUBPARAMETER COUNT
         BNZ   EXELOOP1            OK, BRANCH INTO ROUTINE
         LA    R2,1(,R2)           NONE, INCREMENT PAST COUNT
         B     EXELOOP5            AND GET OUT OF ROUTINE
EXELOOP1 LA    R2,1(,R2)           INCREMENT PAST KEYWORD DESCR
EXELOOP2 SLR   R4,R4               CLEAR REGISTER FOR ICM
         ICM   R4,1,0(R2)          LOAD PARAMETER LENGTH
         BNM   EXELOOP3            HIGH BIT NOT ON, ONLY 1 PARAMETER
         N     R4,F#127            'AND' OUT THE HIGH ORDER BIT
         LA    R2,1(,R2)           INCREMENT PAST CONTROL BYTE
         B     EXELOOP4            BRANCH
EXELOOP3 LA    R4,1                SET PARAM COUNT TO 1
EXELOOP4 SLR   R3,R3               CLEAR REGISTER FOR ICM
         ICM   R3,1,0(R2)          LOAD PARAMETER LENGTH
         LA    R2,1(R3,R2)         INCREMENT PAST PARM
         BCT   R4,EXELOOP4         LOOP UNTIL PROCESSED ALL PARMS
         BCT   R5,EXELOOP2         LOOP UNTIL PROCESSED ALL PARMS
EXELOOP5 ST    R2,PARMADDR         SAVE START OF PARAMETER ADDRESS
         B     EXECPARM            CONTINUE
         EJECT
***********************************************************************
*        THE TEXT OF THE DD CARD TEXT IS AS FOLLOWS                   *
*            1)  2 BYTE LENGTH OF TEXT STRING INCLUDING ITSELF        *
*            2)  1 BYTE INDICATOR COMMON TO ALL TEXT RECORDS          *
*            3)  1 BYTE OF MISCELLANEOUS INDICATORS                   *
*            4)  1 BYTE INDICATOR X'6E' INDICATING DD POS INFORMATION *
*            5)  1 BYTE NUMBER OF DD POSITIONAL PARAMETERS            *
*                THE 1ST POS PARAMETER IS THE DDNAME IF PRESENT       *
*                ALL OTHER POS PARAMETERS WILL BE IGNORED             *
*            6)  VARIABLE LENGTH LIST OF DD POS PARAMETERS            *
*                EACH PRECEDED BY A 1 BYTE LENGTH FIELD               *
*            7)  VARIABLE LENGTH LIST OF KEYWORD PARAMETERS           *
*                EACH IS PRECEDED BY A 1 BYTE KEY, 1 BYTE NUMBER OF   *
*                POSITIONAL SUBPARAMETERS PRESENT, AND A LIST OF      *
*                SUBPARAMETERS EACH PRECEDED BY A 1 BYTE LENGTH FIELD *
*                WHICH MAY BE ZERO IF OMITTED AND FOLLOWED BY ANOTHER *
*                POSITIONAL PARAMETER.                                *
***********************************************************************
DDCARD   TM    STRDINDC,DTXDDNM    SEE IF DD DDNAME= STATEMENT
         BO    GETNEXT             YES, BYPASS
         TM    STRDINDC,DTXDYNAM   SEE IF DD DYNAM STATEMENT
         BO    GETNEXT             YES, BYPASS
         TM    STRDINDC,DTXSYSIN   SEE IF DD INPUT SPOOL FILE
         BO    GETNEXT             YES, BYPASS
         EJECT
***********************************************************************
*        INITIALIZE TEMPORARY ENTRY WHICH WILL BE USED                *
*        IF PRIV OR TAPE UNIT                                         *
***********************************************************************
         XC    UNITIND,UNITIND     ZERO UNIT TYPE IND
         XC    DISPIND,DISPIND     ZERO DISP IND
         MVI   UNITCOUN,X'01'      SET DEFAULT UNIT COUNT TO 1
         MVI   TENTRY,C' '         BLANK FIRST BYTE OF TEMP ENTRY
         MVC   TENTRY+1(58),TENTRY BLANK ENTIRE TEMP ENTRY
         XC    TTYPE,TTYPE         ZERO TEMPORARY UNIT TYPE
         XC    TVOLSER,TVOLSER     ZERO TEMP 1ST VOLSER
DDSTART  LA    R2,STRDKEY          LOAD START OF TRUE TEXT
         ST    R2,PARMADDR         SAVE START OF PARAMETER ADDRESS
         OI    DDIND,DDBEGIN       TURN ON FIRST ENTRY INDICATOR
DDPARM   CLI   0(R2),ENDK          END OF TEXT STRING??
         BE    DDEND               YES, GO CHECK FOR UPDATE
         EJECT
***********************************************************************
*        DD DDNAME                                                    *
***********************************************************************
DDDNAME  CLI   0(R2),DDK           SEE IF DDNAME KEY
         BNE   DDDUMMY             NO, BRANCH
         SLR   R4,R4               CLEAR REG FOR ICM
         ICM   R4,1,1(R2)          LOAD NUMBER OF SUBPARAMS
         BZ    DDLOOP1             ZERO, NO SUBPARAMS
         SLR   R3,R3               CLEAR REG FOR ICM
         ICM   R3,1,2(R2)          LOAD LENGTH OF DDNAME
         BZ    DDLOOP1             YES, CONCATINATED DD, LOOP
         CH    R3,H#8              SEE IF MAX LENGTH EXCEEDED
         BNH   *+16                NO, CONTINUE
         LA    R15,14              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     DDLOOP1             GET OUT
         BCTR  R3,0                MAKE MACHINE LENGTH
         EX    R3,MOVE8            MOVE DDNAME TO TEMP ENTRY
         B     DDLOOP1             GO GET NEXT PARAM
         EJECT
***********************************************************************
*                                                                     *
*        DD DUMMY                                                     *
*                                                                     *
*        THIS KEYWORD WILL BE IN THE INTERNAL TEXT EVEN IF            *
*        OVERRIDDEN IN A PROCEDURE.  IT WILL BE THE FIRST             *
*        ENTRY IN THE STRING AFTER THE DDNAME IF TRUELY A             *
*        DUMMY FILE.  IT WILL BE LAST IF OVERRIDDEN.                  *
*                                                                     *
***********************************************************************
DDDUMMY  CLI   0(R2),DUMMK         SEE IF DUMMY KEY
         BNE   DDSNAME             NO, BRANCH
         TM    DDIND,DDBEGIN       TEST FIRST ENTRY SWITCH
         BO    GETNEXT             FIRST PARM, REALLY A DUMMY
         B     DDLOOP              NOT FIRST, IGNORE IT
         EJECT
***********************************************************************
*        DD DSNAME                                                    *
***********************************************************************
DDSNAME  CLI   0(R2),DSNAMEK       SEE IF DSNAME KEY
         BNE   DDISP               NO, BRANCH
         SLR   R3,R3               CLEAR REG FOR ICM
         ICM   R3,1,2(R2)          LOAD LENGTH OF DSN
         BZ    DDLOOP              ZERO, NULL, BRANCH
         BNM   DSNSTD              HIGH BIT NOT ON, STANDARD DSN
         CLI   4(R2),C'*'          SEE IF 1ST PARAM = * (REFERBACK)
         BE    DSNREFBK            YES, REFERBACK
***********************************************************************
*        DSNAME PROBABLY A GDG                                        *
***********************************************************************
DSNGDG   N     R3,F#127            TURN OFF HIGH ORDER BIT
         CH    R3,H#2              SEE IF TWO SUBPARAMS
         BE    *+16                YES, BRANCH
         LA    R15,15              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     DDLOOP              GET OUT
         LA    R4,3(,R2)           LOAD ADDR OF START OF 1ST ENTRY
         IC    R3,0(R4)            LOAD LENGTH OF 1ST ENTRY
         CH    R3,H#35             SEE IF MAX LENGTH EXCEEDED
         BNH   *+16                NOT EXCEEDED, BRANCH
         LA    R15,16              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     DDLOOP              GET OUT
         BCTR  R3,0                MAKE MACHINE LENGTH
         EX    R3,MOVE14           MOVE 1ST PART DSN TO TEMP ENTRY
         LA    R3,1(,R3)           MAKE TRUE LENGTH AGAIN
         LA    R4,1(R3,R4)         INCREMENT TO 2ND ENTRY
         LA    R5,TDSN             LOAD ADDR OF TEMPORARY DSN
         AR    R5,R3               LOAD ADDR WITHIN TDSN FOR GEN #
         LR    R15,R3              SAVE LENGTH OF 1ST PART DSN
         ICM   R3,1,0(R4)          LOAD LENGTH OF 2ND PART DSN
         BNZ   *+16                NOT ZERO, BRANCH
         LA    R15,15              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     DDLOOP              GET OUT
         AR    R15,R3              ADD NEW LENGTH OF 2ND PART TO 1ST
         CH    R15,H#42            SEE IF TOTAL LENGTH EXCEEDS MAX
         BNH   *+16                NO, BRANCH
         LA    R15,16              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     DDLOOP              GET OUT
         MVI   0(R5),C'('          PUT PARENS FOR GEN #
         LA    R5,1(,R5)           INCREMENT TO START TRUE GEN #
         BCTR  R3,0                MAKE MACHINE LENGTH
         EX    R3,MOVE15           MOVE GEN # TO TDSN
         LA    R5,1(R3,R5)         INCREMENT TO END OF TDSN FIELD
         MVI   0(R5),C')'          FINISH PARENS FOR GEN #
         B     DDLOOP              GO GET NEXT ENTRY
***********************************************************************
*        DSNAME PROBABLY A REFERBACK                                  *
***********************************************************************
DSNREFBK BAL   R14,REFBACK         GO TO REFERBACK RTN
         MVC   TDSN,REFDSN         SAVE REFERBACK DSNAME
         B     DDLOOP              GO GET NEXT ENTRY
***********************************************************************
*        DSNAME PROBABLY STANDARD                                     *
***********************************************************************
DSNSTD   CH    R3,H#44             SEE IF > MAX LENGTH
         BNH   *+16                NO, BRANCH
         LA    R15,16              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     DDLOOP              GET OUT
         CLC   3(8,R2),NULLFILE    SEE IF DSN=NULLFILE
         BE    GETNEXT             YES, DUMMY, IGNORE STATEMENT
         BCTR  R3,0                MAKE MACHINE LENGTH
         EX    R3,MOVE9            MOVE DSN TO TEMP ENTRY
         B     DDLOOP              GO GET NEXT ENTRY
         EJECT
***********************************************************************
*        DD DISP                                                      *
***********************************************************************
DDISP    CLI   0(R2),DISPK         SEE IF DISP= KEYWORD
         BNE   DUNIT               NO, BRANCH
         SLR   R4,R4               CLEAR REG FOR ICM
         ICM   R4,1,1(R2)          LOAD NUMBER SUBPARAMS
         BZ    DDLOOP              ZERO, NULL, BRANCH
         LA    R2,2(,R2)           LOAD START ADDR OF SUBPARAMS
         CH    R4,H#3              SEE IF NUMBER > 3
         BNH   *+16                NO, CONTINUE
         LA    R15,17              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     DDLOOP              GET OUT
         SLR   R5,R5               ZERO WORK REG
DSPLOO1  LA    R5,1(,R5)           ADD 1 TO COUNTER
         CR    R5,R4               SEE IF ALL PROCESSED
         BH    DISPCHK             YES, GO CHECK RESULTS
         SLR   R3,R3               ZERO WORK REG
         IC    R3,0(R2)            LOAD LEN OF PARAM
         CH    R5,H#1              SEE IF 1ST PARAM
         BE    DSPLOO2             YES, BRANCH TO PROCESS
         CH    R5,H#2              SEE IF 2ND PARAM
         BE    DSPLOO7             YES, BRANCH TO PROCESS
         B     DSPLOO9             BRANCH TO PROCESS
***********************************************************************
*         FIRST DISP PARAMETER                                        *
***********************************************************************
DSPLOO2  LTR   R3,R3               SEE IF LENGTH = 0
         BZ    DSPLOO3             YES, GO SET TO NEW
         CLC   1(3,R2),C#NEW       SEE IF NEW
         BNE   DSPLOO4             NO, BRANCH
DSPLOO3  OI    DISPIND,NEW         SET TO NEW
         B     DSPLOO14            GO GET NEXT
DSPLOO4  CLC   1(3,R2),C#SHR       SEE IF SHR
         BNE   DSPLOO5             NO, BRANCH
         OI    DISPIND,SHR         SET TO SHR
         B     DSPLOO14            GO GET NEXT
DSPLOO5  CLC   1(3,R2),C#OLD       SEE IF OLD
         BNE   DSPLOO6             NO, MUST BE "MOD", BRANCH
         OI    DISPIND,OLD         SET TO OLD
         B     DSPLOO14            GO GET NEXT
DSPLOO6  OI    DISPIND,MOD         SET TO MOD
         B     DSPLOO14            GO GET NEXT
***********************************************************************
*         SECOND DISP PARAMETER                                       *
***********************************************************************
DSPLOO7  LTR   R3,R3               SEE IF LENGTH = 0
         BNZ   DSPLOO9             NOT ZERO, NO DEFAULT
         TM    DISPIND,OLD         SEE IF OLD
         BO    DSPLOO8             YES, GO SET DEFAULT TO KEEP
         TM    DISPIND,SHR         SEE IF SHR
         BO    DSPLOO8             YES, GO SET DEFAULT TO KEEP
         TM    DISPIND,MOD         SEE IF MOD
         BO    DSPLOO8             YES, GO SET DEFAULT TO KEEP
         OI    DISPIND,DELETE      SET DEFAULT TO DELETE FOR "NEW"
         B     DSPLOO14            GO GET NEXT
DSPLOO8  OI    DISPIND,KEEP        SET TO KEEP
         B     DSPLOO14            GO GET NEXT
***********************************************************************
*         THIRD DISP PARAMETER                                        *
***********************************************************************
DSPLOO9  LTR   R3,R3               SEE IF LENGTH = 0
         BZ    DSPLOO14            YES, USE DEFAULT OF PREVIOUS PARAMET
         CLC   1(4,R2),C#KEEP      SEE IF KEEP
         BNE   DSPLOO10            NO, BRANCH
         OI    DISPIND,KEEP        SET TO KEEP
         B     DSPLOO14            GO GET NEXT
DSPLOO10 CLC   1(4,R2),C#PASS      SEE IF PASS
         BNE   DSPLOO11            NO, BRANCH
         OI    DISPIND,PASS        SET TO PASS
         B     DSPLOO14            GO GET NEXT
DSPLOO11 CLC   1(5,R2),C#CATLG     SEE IF CATLG
         BNE   DSPLOO12            NO, BRANCH
         OI    DISPIND,CATLG       SET TO CATLG
         B     DSPLOO14            GO GET NEXT
DSPLOO12 CLC   1(6,R2),C#DELETE    SEE IF DELETE
         BNE   DSPLOO13            NO, GO SET TO "UNCATLG"
         OI    DISPIND,DELETE      SET TO DELETE
         B     DSPLOO14            GO GET NEXT
DSPLOO13 OI    DISPIND1,UNCATLG    SET TO UNCATLG
DSPLOO14 LA    R2,1(R3,R2)         INCREMENT TO NEXT ENTRY
         B     DSPLOO1             LOOP
***********************************************************************
*         CHECK RESULTS OF PROCESSING ALL DISP PARAMETERS             *
*         IF ONLY 1 DISP PARAMETER WAS ENTERED, THE DEFAULT           *
*         FOR THE SECOND PARAMETER MUST BE DETERMINED.                *
***********************************************************************
DISPCHK  CH    R4,H#1              SEE IF ONLY 1 ENTRY
         BNE   DISPEND             NO, DO NOT SET DEFAULT
         TM    DISPIND,OLD         SEE IF OLD
         BO    DISPCHK2            YES, BRANCH
         TM    DISPIND,SHR         SEE IF SHR
         BO    DISPCHK2            YES, BRANCH
         TM    DISPIND,MOD         SEE IF MOD
         BO    DISPCHK2            YES, BRANCH
***********************************************************************
*        DISP=NEW  DEFAULT TO DELETE                                  *
***********************************************************************
DISPCHK1 OI    DISPIND,DELETE      SET TO DELETE
         B     DISPEND             GET OUT
***********************************************************************
*        DISP=OLD, MOD, OR SHR  DEFAULT TO KEEP                       *
***********************************************************************
DISPCHK2 OI    DISPIND,KEEP        SET TO KEEP
DISPEND  B     DDLOOP              GO GET NEXT PARAM
         EJECT
***********************************************************************
*        DD UNIT                                                      *
***********************************************************************
DUNIT    CLI   0(R2),UNITK         SEE IF UNIT= PARAM
         BNE   DAFF                NO, BRANCH
         ICM   R4,1,1(R2)          GET NUMBER OF POS SUBPARAMS
         BZ    DDLOOP              ZERO, NO POS SUBPARAMS
         CH    R4,H#3              SEE IF NUMBER > 3
         BNH   *+16                NO, CONTINUE
         LA    R15,18              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     DDLOOP              GET OUT
         LA    R2,2(,R2)           LOAD START OF POS PARAMS
         SLR   R5,R5               ZERO WORK REG
***********************************************************************
*        LOOP ON NUMBER OF PARAMETERS.  NOTE THAT THE FIRST           *
*        PARAMETER (UNITNAME) AND THE SECOND PARAMETER (UNIT          *
*        COUNT) ARE ALL WE ARE INTERESTED IN.                         *
***********************************************************************
UNITLOO1 LA    R5,1(,R5)           ADD 1 TO COUNT
         CR    R5,R4               SEE IF PROCESSED ALL SUBPARAMS
         BH    DDLOOP              YES, GO GET NEXT PARM
         SLR   R3,R3               ZERO WORK REG
         ICM   R3,1,0(R2)          LOAD LENGTH OF SUBPARAM
         BZ    UNITLOO2            ZERO, GO GET NEXT SUBPARAM
         CH    R3,H#8              SEE IF LENGTH > 8
         BNH   *+16                NO, CONTINUE
         LA    R15,18              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     DDLOOP              GET OUT
         CH    R5,H#1              SEE IF 1ST POS SUBP
         BE    UNITNM1             YES, BRANCH
         CH    R5,H#2              SEE IF 2ND POS SUBP
         BE    UNITCT              YES, BRANCH
         B     UNITLOO2            ANYTHING ELSE NOT WANTED
***********************************************************************
*        PROCESS UNIT NAME                                            *
***********************************************************************
UNITNM1  SLR   R15,R15             CLEAR REG 15
         LA    R1,DEVTABLE         LOAD ADDR OF DEV TABLE
         BCTR  R3,0                MAKE MACHINE LENGTH
         CH    R3,H#2              Q. POSSIBLE ABSOLUTE ALLOC(CUU)?
         BNE   UNITNM2             NO, CHK FOR CLASS DEVICES
         CLI   1(R2),C'0'          Q. CHAN NOS  NUMERIC?
         BL    UNITNM2             NO, CAN'T BE DEDICATED DEVICE
         OI    RESOURCE+1,DEDICATE YES, ADD 'DEDICATE' RESOURCE
***********************************************************************
*        SEARCH THE DEVICE TABLE FOR A MATCH ON UNIT NAME TO          *
*        DETERMINE THE ATTRIBUTES OF THE UNIT NAME.                   *
***********************************************************************
UNITNM2  CLI   1(R1),X'00'         SEE IF END OF TABLE
         BE    UNITNM3             YES, BRANCH
         IC    R15,1(R1)           INSERT LENGTH OF UNIT NAME
         EX    R15,COMPARE2        SEE IF UNIT NAME MATCH
         BE    UNITNM3             YES, BRANCH
         LA    R1,10(,R1)          INCREMENT TO NEXT ENTRY
         B     UNITNM2             LOOP
UNITNM3  LA    R3,1(,R3)           MAKE ORIG LENGTH
         OC    UNITIND,0(R1)       'OR' IN THE UNIT TYPE BITS
         B     UNITLOO2            GO PROCESS NEXT POS PARAM
UNITCT   CLI   1(R2),C'P'          PARALLEL MOUNTING?
         BNE   UNITCT1             NO, BRANCH
         MVI   UNITCOUN,C'P'       SET UNIT COUNT TO 'P'
         B     UNITLOO2
***********************************************************************
*        PROCESS UNIT COUNT                                           *
***********************************************************************
UNITCT1  LR    R15,R3              SAVE LENGTH OF UNIT COUNT
         LA    R14,1(,R2)          LOAD ADDRESS OF UNIT COUNT
UNITCT2  CLI   0(R14),C'0'         SEE IF NUMERIC
         BL    UNITLOO3            NO, ERROR
         CLI   0(R14),C'9'         SEE IF NUMERIC
         BH    UNITLOO3            NO, ERROR
         LA    R14,1(,R14)         INCREMENT TO NEXT CHAR UNIT COUNT
         BCT   R15,UNITCT2         LOOP UNTIL DONE
         BCTR  R3,0                MAKE MACHINE LENGTH
         EX    R3,PACK2            PACK UNIT COUNT
         LA    R3,1(,R3)           MAKE ORIG LENGTH
         CVB   R15,DOUBLE          CONVERT UNIT COUNT TO BIN
         STC   R15,UNITCOUN        SAVE UNIT COUNT
UNITLOO2 LA    R2,1(R3,R2)         INCREMENT TO NEXT ENTRY
         B     UNITLOO1            GO PROCESS NEXT SUBPARAM
UNITLOO3 LA    R15,19              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     DDLOOP              GET OUT
         EJECT
***********************************************************************
*        DD UNIT=AFF                                                  *
***********************************************************************
DAFF     CLI   0(R2),AFFMK         SEE IF UNIT=AFF= KEY
         BNE   DVOL                NO, BRANCH
         MVI   REFERBCK,C' '       BLANK START OF REFERBACK WORK AREA
         MVC   REFERBCK+1(23),REFERBCK BLANK ENTIRE FIELD
         LA    R2,2(,R2)           LOAD ADDR OF AFF FIELD
         SLR   R3,R3               CLEAR REG FOR ICM
         ICM   R3,1,0(R2)          LOAD LENGTH OF DDNAME
         BZ    DDLOOP              YES, GO PROCESS NEXT PARAM
         CH    R3,H#8              SEE IF LENGTH > 8
         BNH   *+16                NO, CONTINUE
         LA    R15,18              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     DDLOOP              GET OUT
         BCTR  R3,0                MAKE MACHINE LENGTH
         EX    R3,MOVE10           MOVE DDNAME TO REFERBACK FIELD
         L     R7,LASTEXEC         LOAD ADDR LAST EXEC ENTRY
         OI    UNITIND,UNITFND     SET UNIT FOUND IND
AFFLOOP  LA    R7,ENTLEN(,R7)      INCREMENT TO NEXT DD ENTRY
         CLI   ENTRYTYP,TYPEND     END OF TABLE?
         BE    AFFEND              YES, BRANCH
         CLC   REFDDN,DDDN         MATCH DDNAME?
         BE    AFFOUND             YES, BRANCH
         B     AFFLOOP             LOOP
AFFOUND  OC    UNITIND,DTYPE       SET UNIT TYPE FROM PREV
         OI    UNITIND,AFF         TURN ON FOUND BY AFF IND
AFFEND   B     DDLOOP              GO PROCESS NEXT ENTRY
         EJECT
***********************************************************************
*        DD VOL                                                       *
***********************************************************************
DVOL     CLI   0(R2),VOLUMEK       SEE IF VOL= KEYWORD
         BNE   DSER                NO, BRANCH
         ICM   R4,1,1(R2)          LOAD NUM OF SUBPARAMS
         BZ    DDLOOP              YES, GO GET NEXT PARAM
         CH    R4,H#4              SEE IF AT LEAST 4 PARAMS
         BL    DDLOOP              LESS THAN 4, NONE NEEDED
         BNH   *+16                NO, CONTINUE
         LA    R15,20              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     DDLOOP              GET OUT
***********************************************************************
*        WE NEED ONLY THE 4TH PARAM (VOL COUNT)                       *
***********************************************************************
         SR    R5,R5               ZERO WORK REG
         LA    R2,2(,R2)           LOAD START OF SUBPARAMS
VOLOOP1  LA    R5,1(,R5)           ADD 1 TO COUNTER
         SLR   R3,R3               CLEAR REG FOR IC
         IC    R3,0(R2)            LOAD LENGTH OF SUBPARAM
         CH    R5,H#4              SEE IF 4TH PARAM
         BL    VOLOOP3             LESS THAN 4, GO GET NEXT
         BH    VOLEND              GREATER THAN 4, GET OUT
         LTR   R3,R3               TEST LENGTH
         BZ    VOLEND              ZERO, GET OUT
         CH    R3,H#8              SEE IF LENGTH > 8
         BNH   *+16                NO, CONTINUE
         LA    R15,20              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     DDLOOP              GET OUT
         LR    R15,R3              SAVE LENGTH OF VOL COUNT
         LA    R14,1(,R2)          LOAD ADDRESS OF VOL COUNT
***********************************************************************
*        CHECK VOLUME COUNT FOR NUMERIC                               *
***********************************************************************
VOLOOP2  CLI   0(R14),C'0'         SEE IF NUMERIC
         BL    VOLOOP4             NO, ERROR
         CLI   0(R14),C'9'         SEE IF NUMERIC
         BH    VOLOOP4             NO, ERROR
         LA    R14,1(,R14)         INCREMENT TO NEXT CHAR VOL COUNT
         BCT   R15,VOLOOP2         LOOP UNTIL DONE
         BCTR  R3,0                MAKE MACHINE LENGTH
         EX    R3,PACK3            PACK VOLUME COUNT
         LA    R3,1(,R3)           RESTORE LENGTH
         CVB   R15,DOUBLE          CONVERT VOL COUNT TO BIN
         STC   R15,VOLCNT          SAVE VOL CNT
VOLOOP3  LA    R2,1(R3,R2)         INCRMENT TO NEXT POS SUBPARAM
         B     VOLOOP1             LOOP
VOLOOP4  LA    R15,21              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     DDLOOP              GET OUT
VOLEND   B     DDLOOP              GO GET NEXT PARAM
         EJECT
***********************************************************************
*        DD VOL=SER                                                   *
***********************************************************************
DSER     CLI   0(R2),SERMK         SEE IF VOL=SER= KEYWORD
         BNE   DREF                NO, BRANCH
***********************************************************************
*        ALL WE NEED IS THE NUMBER OF VOL/SER'S                       *
*        AND THE 1ST VOLSER IN THE LIST IF PRESENT                    *
***********************************************************************
         ICM   R4,1,1(R2)          LOAD NUMBER OF SUBPARAMS
         STC   R4,SERCNT           SAVE NUMBER OF VOL/SER'S
         BZ    DDLOOP              ZERO SUBPARAMS, GET OUT
         ICM   R3,1,2(R2)          LOAD LEN OF 1ST VOLSER
         BZ    DDLOOP              NULL VOLSER, GET OUT
         CH    R3,H#6              SEE IF MAX LEN EXCEEDED
         BNH   *+16                NO, BRANCH
         LA    R15,22              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     DDLOOP              GET OUT
         BCTR  R3,0                MAKE MACHINE LENGTH
         EX    R3,MOVE13           MOVE 1ST VOLSER TO SAVE
         B     DDLOOP              GO GET NEXT PARAM
         EJECT
***********************************************************************
*        DD VOL=REF                                                   *
***********************************************************************
DREF     CLI   0(R2),REFMK         SEE IF VOL=REF= KEYWORD
         BNE   DINTRDR             NO, BRANCH
         SLR   R4,R4               CLEAR REG FOR ICM
         ICM   R4,1,2(R2)          LOAD 'LENGTH' OF REFERBACK
         BZ    DDLOOP              ZERO LENGTH, NULL, BRANCH
         BP    DREF00              HIGH BIT NOT ON, NOT A REFERBACK
         BAL   R14,REFBACK         GO TO REFERBACK ROUTINE
         OI    UNITIND,UNITFND     SET UNIT FOUND IND
         OC    UNITIND,REFUNIT     SAVE UNIT OF PREV DD
         MVC   TVOLSER,REFVOL      SAVE REFERBACK VOLSER
         B     DDLOOP              GO GET NEXT PARAM
***********************************************************************
*        AT THIS POINT, THE REFERBACK IS PROBABLY TO A CATALOGED      *
*        DATA SET.                                                    *
***********************************************************************
DREF00   CH    R4,H#44             SEE IF LENGTH OF DSNAME EXCEEDS MAX
         BNH   *+16                NO, BRANCH
         LA    R15,28              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     DDLOOP              GET OUT
         MVC   LDSN,BLANKS         BLANK DSNAME
         BCTR  R4,0                MAKE MACHINE LENGTH
         EX    R4,MOVE17           MOVE DSNAME TO SAVE
         L     R7,FIRSTENT         LOAD START OF TABLE
         LA    R7,ENTLEN(,R7)      INCREMENT PAST JOB ENTRY
DREF01   CLI   ENTRYTYP,TYPEDD     SEE IF DD ENTRY
         BE    DREF02              YES, GO SEE IF MATCH
         CLI   ENTRYTYP,TYPEND     SEE IF END OF TABLE
         BE    DREF05              NOT FOUND, GO CHECK CATALOG
         B     DREF03              LOOP
DREF02   CLC   DDSN,3(R2)          SEE IF SAME DSNAME
         BE    DREF04              YES, CHARGE FOR THE DSNAME
DREF03   LA    R7,ENTLEN(,R7)      INCREMENT TO NEXT DD ENTRY
         B     DREF01              LOOP UNTIL DONE
DREF04   OI    UNITIND,UNITFND     SET UNIT FOUND IND
         OC    UNITIND,DTYPE       SAVE UNIT TYPE FROM TABLE
         MVC   TVOLSER,DVOLSER     SAVE VOLSER FROM TABLE
         B     DDLOOP              GO GET NEXT PARAM
DREF05   BAL   R5,LOCATE           GO READ CATALOG
         LTR   R15,R15             TEST RETURN CODE
         BNZ   DDLOOP              NOT CATALOGED, IGNORE IT
         CLC   CAMLCNT,H#0         ANY VOLUME ENTRIES?
         BE    DDLOOP              NO, IGNORE IT
         CLI   CAMVOL,X'00'        MAKE USER THAT THERE IS A VOLSER
         BE    DDLOOP              NO, VSAM LIED AGAIN, IGNORE THIS ENT
         MVC   VOLCNT,CAMLCNT+1    SAVE VOLUME COUNT
         MVC   TVOLSER,CAMVOL      SAVE VOLSER FROM CATALOG
         TM    UCBTYP3,X'80'       TAPE UNIT?
         BO    DREF06              YES, BRANCH
         BAL   R5,UCBSEAR          NO, GO SEARCH UCBS FOR PRIV MOUNT
         B     DDLOOP              GO GET NEXT PARAM
DREF06   OI    UNITIND,TAPE        TURN ON TAPE IND
         B     DDLOOP              GO GET NEXT PARAM
         EJECT
***********************************************************************
*        DD SYSOUT                                                    *
***********************************************************************
DINTRDR  CLI   0(R2),SYSOUTK       SEE IF SYSOUT= KEYWORD
         BNE   DDLOOP              NO, BRANCH
         SLR   R4,R4               CLEAR REG FOR ICM
         ICM   R4,1,1(R2)          LOAD NUMBER SUBPARAMS
         BZ    DDLOOP              NONE, BRANCH
         SLR   R3,R3               CLEAR REG FOR ICM
         ICM   R3,1,2(R2)          LOAD LENGTH OF FIRST SUBPARAM
         CH    R4,H#2              SEE IF AT LEAST 2 SUBPARAMETERS
         BL    DDLOOP              NO, BRANCH
         LA    R2,3(R3,R2)         LOAD START ADDR OF SECOND SUBPARAMET
         ICM   R3,1,0(R2)          LOAD LENGTH OF SECOND SUBPARAM
         CH    R3,H#6              SEE IF LENGTH = 6
         BNE   GETNEXT             NO, GET OUT
         CLC   1(6,R2),C#INTRDR    SEE IF INTERNAL READER
         BNE   GETNEXT             NO, BYPASS REST OF SYSOUT STATEMENT
***********************************************************************
*        DO NOT ALLOW INTERNAL READER                                 *
***********************************************************************
         TM    JOBIND,JOBPROD      SEE IF PRODUCTION
         BNO   GETNEXT             YES, BYPASS REST OF SYSOUT STATEMENT
         LA    R15,32              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     GETNEXT             BYPASS REST OF SYSOUT STATEMENT
         EJECT
***********************************************************************
*        THIS ROUTINE WILL INCREMENT PAST THE STRING(S) BEING         *
*        PROCESSED.  NOTE THAT FOLLOWING THE KEYWORD DESCRIPTOR       *
*        FIELD IS A COUNT OF SUBPARAMETERS.  FOLLOWING THE COUNT      *
*        WILL BE A LENGTH OR DESCRIPTOR FIELD.  IF THE HIGH ORDER     *
*        BIT IS ON, THE FIELD IS A COUNT FIELD OF THE NUMBER OF       *
*        SUBPARAMETERS WHICH THE SUBPARAMETER ITSELF MAY HAVE.        *
*        IF THIS IS TRUE, THE DESCRIPTOR FIELD WILL BE FOLLOWED BY    *
*        A LENGTH FIELD FOR THE FIRST SUBPARAMETER.  IF THE HIGH      *
*        ORDER BIT IS NOT ON, IT IS ONLY A LENGTH FIELD FOR A         *
*        SINGLE SUBPARAMETER.                                         *
***********************************************************************
DDLOOP   NI    DDIND,255-DDBEGIN   TURN OFF FIRST ENTRY SWITCH
DDLOOP1  L     R2,PARMADDR         RESTORE START OF PARAMETER ADDRESS
         SLR   R5,R5               CLEAR REGISTER FOR ICM
         LA    R2,1(,R2)           INCREMENT PAST KEYWORD
         ICM   R5,1,0(R2)          LOAD SUBPARAMETER COUNT
         BNZ   DDLOOP2             OK, BRANCH INTO ROUTINE
         LA    R2,1(,R2)           NONE, INCREMENT PAST COUNT
         B     DDLOOP6             AND GET OUT OF ROUTINE
DDLOOP2  LA    R2,1(,R2)           INCREMENT PAST KEYWORD DESCR
DDLOOP3  SLR   R4,R4               CLEAR REGISTER FOR ICM
         ICM   R4,1,0(R2)          LOAD PARAMETER LENGTH
         BNM   DDLOOP4             HIGH BIT NOT ON, ONLY 1 PARAMETER
         N     R4,F#127            'AND' OUT THE HIGH ORDER BIT
         LA    R2,1(,R2)           INCREMENT PAST CONTROL BYTE
         B     DDLOOP5             BRANCH
DDLOOP4  LA    R4,1                SET PARAM COUNT TO 1
DDLOOP5  SLR   R3,R3               CLEAR REGISTER FOR ICM
         ICM   R3,1,0(R2)          LOAD PARAMETER LENGTH
         LA    R2,1(R3,R2)         INCREMENT PAST PARM
         BCT   R4,DDLOOP5          LOOP UNTIL PROCESSED ALL PARMS
         BCT   R5,DDLOOP3          LOOP UNTIL PROCESSED ALL PARMS
DDLOOP6  ST    R2,PARMADDR         SAVE START OF PARAMETER ADDRESS
         B     DDPARM              CONTINUE
         EJECT
***********************************************************************
*        THIS IS WHERE WE LOOK AT WHAT WE HAVE FOUND OUT ABOUT THE    *
*        DD STATEMENT WE HAVE JUST FINISHED PROCESSING.               *
*        THE FOLLOWING ARE LOOKED AT                                  *
*          1)  THE DISPOSITION FOR SOME DATA SETS                     *
*              MUST BE AUTHORIZED FOR OTHER THAT SHR                  *
*          2)  THE TEMPORARY ENTRY MUST BE SAVED IF UNIT IS A TAPE    *
*              OR A PRIV UNIT.                                        *
*          3)  IF THE ENTRY IS A TAPE OR PRIV, THE UNIT COUNT MUST BE *
*              ADDED TO THE RUNNING COUNT FOR THE STEP.               *
***********************************************************************
*
***********************************************************************
*        DO NOT ALLOW A DISP OF "DELETE" FOR SYSTEM DATA SETS.        *
***********************************************************************
DDEND    LA    R14,SDSNTBL         LOAD ADDRESS OF SYSTEM DSNS
         SLR   R15,R15             CLEAR REG FOR IC
DDEND10  CLI   0(R14),X'FF'        SEE IF END OF TABLE
         BE    DDEND40             YES, GET OUT
         IC    R15,0(R14)          LOAD MCH LEN OF DSN
         EX    R15,CLCSDSN         SEE IF A SYSTEM DATA SET
         BE    DDEND20             YES, BRANCH
         LA    R14,2(R15,R14)      INCREMENT TO NEXT TABLE ENTRY
         B     DDEND10             LOOP
CLCSDSN  CLC   TDSN(0),1(R14)      **** EXECUTE ONLY ****
DDEND20  TM    DISPIND,DELETE      SEE IF DISP=DELETE
         BNO   DDEND30             NO, BRANCH
         TM    JOBIND,JOBSTC+JOBTECH IS JOB AUTHORIZED
         BM    DDEND30             YES, BRANCH
         LA    R15,23              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     DDEND40             GET OUT
***********************************************************************
*        DO NOT ALLOW A DISP OTHER THAN "SHR" FOR SYSTEM DATA         *
*        SETS.                                                        *
***********************************************************************
DDEND30  TM    DISPIND,SHR         SEE IF DISP=SHR
         BO    DDEND40             YES, BRANCH
*        IF DISP NOT = SHR, MUST BE AUTHORIZED
         TM    JOBIND,JOBSTC+JOBTECH IS JOB AUTHORIZED
         BM    DDEND40             YES, BRANCH
         LA    R15,23              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
***********************************************************************
*        IF UNIT HAS NOT BEEN DETERMINED, THE UNIT TYPE MUST          *
*        BE SEARCHED FOR IN THE FOLLOWING ORDER:                      *
*                                                                     *
*        1)  THE DSNAME TABLE MAINTAINED BY THIS EXIT SINCE THE       *
*            DATASET MAY HAVE BEEN CATALOGED OR PASSED BY A           *
*            PREVIOUS DD STATEMENT.                                   *
*        2)  THE SYSTEM CATALOG                                       *
*                                                                     *
***********************************************************************
DDEND40  CLI   UNITIND,X'00'       SEE IF UNIT HAS BEEN DETERMINED
         BE    DDEND45             NO, BRANCH
         CLI   TVOLSER,X'00'       SEE IF VOLSER SPECIFIED
         BE    DDEND45             NO, GO SEARCH TABLE AND/OR CATALOG
         TM    UNITIND,TAPE        SEE IF TAPE
         BO    DDEND150            YES, GET OUT
         BAL   R5,UCBSEAR          NO, GO SEARCH UCBS FOR PRIV MOUNT
         B     DDEND150            GET OUT
DDEND45  CLI   TDSN,C' '           SEE IF DSN SPECIFIED
         BE    DDEND150            NOT SPECIFIED, GET OUT
         TM    DISPIND,NEW         SEE IF THIS IS A NEW DATASET
         BO    DDEND150            YES, VOLSER WILL BE A WORK PACK
         L     R7,FIRSTENT         LOAD ADDR OF START OF TABLE
***********************************************************************
*        SEARCH THE DSNAME TABLE MAINTAINED BY THIS EXIT              *
***********************************************************************
DDEND50  LA    R7,ENTLEN(,R7)      INCREMENT TO NEXT ENTRY
         CLI   ENTRYTYP,TYPEND     END OF TABLE?
         BE    DDEND60             YES, GO CHECK CATALOG
         TM    ENTRYTYP,TYPEDD     DD ENTRY?
         BNO   DDEND50             NO, LOOP
         CLC   DDSN,TDSN           DSN MATCH?
         BNE   DDEND50             NO, LOOP
         OC    UNITIND,DTYPE       SAVE UNIT INFO
         MVC   TVOLSER,DVOLSER     SAVE VOLSER INFO
         B     DDEND150            GET OUT
***********************************************************************
*        SEARCH CATALOG FOR UNIT INFO                                 *
***********************************************************************
DDEND60  DS    0H
         AIF   ('&CAMLST' EQ 'YES').CAML1
         B     DDEND150            BYPASS CAMLST NOP
.CAML1   ANOP
         CLC   TDSN(5),C#SYS1      SEE IF SYS1. DATA SET
         BE    DDEND150            YES, NO NEED TO CAMLST
         TM    STRDINDC,DTXSYOUT   SEE IF DD OUTPUT SPOOL FILE
         BO    DDEND150            YES, NO NEED TO CAMLST
         MVC   LDSN,TDSN           SAVE DSNAME
         BAL   R5,LOCATE           GO READ CATALOG
         LTR   R15,R15             TEST RETURN CODE
         BZ    DDEND70             ZERO, BRANCH
         CH    R15,H#8             DSNAME NOT FOUND OR GDG LEVEL?
         BE    DDEND90             YES, BRANCH
DDEND70  CLC   CAMLCNT,H#0         ANY VOLUME ENTRIES?
         BE    DDEND150            NO, BRANCH
         CLI   CAMVOL,X'00'        MAKE USER THAT THERE IS A VOLSER
         BE    DDEND150            NO, VSAM LIED AGAIN, IGNORE THIS ENT
         MVC   VOLCNT,CAMLCNT+1    SAVE VOLUME COUNT
         MVC   TVOLSER,CAMVOL      SAVE VOLSER FROM CATALOG
         TM    UCBTYP3,X'80'       TAPE UNIT?
         BO    DDEND80             YES, BRANCH
         BAL   R5,UCBSEAR          NO, GO SEARCH UCBS FOR PRIV MOUNT
         B     DDEND150            GET OUT
DDEND80  OI    UNITIND,TAPE        TURN ON TAPE IND
         B     DDEND150            BYPASS ROUTINES
         EJECT
***********************************************************************
*        DATA SET NOT FOUND, MAY BE GDG LEVEL                         *
*        DO A GENERIC LOCATE FOR THE DSNAME INDEX GIVEN               *
***********************************************************************
DDEND90  MVC   SVC26DS,LDSN        MOVE DSNAME TO SVC26 AREA
         LA    R1,43               LOAD MAXIMUM LENGTH OF DSN
         LA    R14,SVC26DS+42      LOAD ADDRESS OF END OF DSN
DDEND100 CLI   0(R14),C' '         SEE IF LAST CHAR DSN
         BNE   DDEND110            YES, BRANCH
         BCTR  R14,0               BACK UP DSN POINTER 1 POSITION
         BCT   R1,DDEND100         LOOP UNTIL FOUND
DDEND110 LTR   R1,R1               TEST LENGTH
         BZ    DDEND150            ZERO, NO DSN, BRANCH
         STC   R1,SVC26DSL         SAVE LENGTH OF DSN
         XC    CTGPL,CTGPL         ZERO PARM LIST
         MVI   CTGPL,B'00000111'   SET CTGOPTN1
         MVI   CTGPL+2,B'00010001' SET CTGOPTN3
         LA    R1,SVC26DSN         LOAD ADDRESS OF DSNAME
         ST    R1,CTGPL+4          SET CTGENT
         XC    CTGPL+8(4),CTGPL+8  ZERO CTGCAT
         XC    CTGPL+18(4),CTGPL+18 ZERO CTGPSWD
         LH    R1,H#5000           LOAD LENGTH OF WORK AREA
         STH   R1,SVC26WRK         AND SAVE IT WORK AREA
         LA    R1,SVC26WRK         LOAD ADDRESS OF WORK AREA
         ST    R1,CTGPL+12         SET CTGWKA
         LA    R1,CTGPL            LOAD ADDRESS OF WORK AREA
         SVC   26                  CALL CATALOG GENERIC SEARCH
         LTR   R15,R15             TEST RETURN CODE
         BNZ   DDEND150            NOT ZERO, BRANCH
***********************************************************************
*        FOUND DATA SETS AT THE GIVEN INDEX LEVEL.  CHECK TO SEE      *
*        IF GDG LEVEL.                                                *
***********************************************************************
         LH    R14,SVC26WRK+2      LOAD LENGTH OF AREA+4
         SH    R14,H#4             SUBTRACT LENGTH OF PREFIX
         SRDA  R14,32              SHIFT TO ODD REGISTER OF PAIR
         D     R14,F#45            DIVIDE BY LENGTH OF EACH ENTRY
         LTR   R4,15               TEST NUMBER OF DSNAMES RETURNED
         BZ    DDEND150            ZERO, NONE
         BM    DDEND150            NEGATIVE, ERROR
         LA    R2,SVC26WRK+4       POINT TO FIRST DSN
         CLI   0(R2),C'B'          IS THIS A GDG BASE (VSAM CATALOG ONL
         BE    DDEND140            YES, BRANCH
         CLI   0(R2),C'A'          IS THIS A NONVSAM ENTRY
         BNE   DDEND150            NO, BRANCH
         SLR   R15,R15             ZERO, REGISTER FOR IC
         IC    R15,SVC26DSL        LOAD BASE DSN LENGTH
         LA    R15,2(R15,R2)       POINT PAST TYPE, BASE, AND '.'
         CLI   0(R15),C'G'         POSSIBLE GDG
         BNE   DDEND150            NO, BRANCH
         CLI   5(R15),C'V'         POSSIBLE GDG
         BNE   DDEND150            NO, BRANCH
         CLI   8(R15),C' '         POSSIBLE GDG
         BNE   DDEND150            NO, BRANCH
         MVC   DOUBLE,0(R15)       SAVE DSN SUFFIX
         OC    DOUBLE,GDGMASK      TEST NUMERIC POSITIONS
         CLC   DOUBLE,0(R15)       SEE IF CHANGED
         BNE   DDEND150            YES, NOT GDG, BRANCH
         OI    UNITIND,UNITGDG     UNIT INFORMATION FROM GDG PROCESSING
***********************************************************************
*        LOCATE INDIVIDUAL DATA SETS RETURNED FROM THE GENERIC        *
*        LOCATE FROM SVC26.  ALL ENTRIES ARE LOCATED TO GET THE       *
*        VOLUME COUNT IF 'PARALLEL' MOUNTING IS REQUESTED.            *
***********************************************************************
DDEND120 MVC   LDSN,1(R2)          SAVE DSNAME
         BAL   R5,LOCATE           GO READ CATALOG
         LTR   R15,R15             TEST RETURN CODE
         BNZ   DDEND140            NOT ZERO, SOMETHINGS WRONG, LOOP
         CLC   CAMLCNT,H#0         ANY VOLUME ENTRIES?
         BE    DDEND140            NO, BYPASS ENTRY
         CLI   CAMVOL,X'00'        MAKE USER THAT THERE IS A VOLSER
         BE    DDEND140            NO, VSAM LIED AGAIN, IGNORE THIS ENT
         MVC   TVOLSER,CAMVOL      SAVE VOLSER FROM CATALOG
         MVC   VOLCNT,CAMLCNT+1    SAVE VOLUME COUNT
         TM    UCBTYP3,X'80'       TAPE UNIT?
         BO    DDEND130            YES, BRANCH
         BAL   R5,UCBSEAR          NO, GO SEARCH UCBS FOR PRIV MOUNT
         B     DDEND140            GET OUT
DDEND130 OI    UNITIND,TAPE        TURN ON TAPE IND
DDEND140 LA    R2,45(,R2)          INCREMENT TO NEXT ENTRY
         BCT   R4,DDEND120         LOOP UNTIL DONE
***********************************************************************
*        PROCESS ONLY DD STATEMENTS WHICH ARE FOR MOUNTABLE           *
*        DEVICES.                                                     *
***********************************************************************
DDEND150 TM    UNITIND,TAPE        IS THIS A TAPE DD?
         BO    DDEND160            YES, BRANCH
         TM    UNITIND,PRIV        IS THIS A PRIV DD?
         BNO   DDEND240            NO, DO NOT SAVE
***********************************************************************
*        IF THE UNIT WAS DETERMINED BY UNIT=AFF, DO NOT CHARGE        *
*        FOR THE DEVICE BUT SAVE THE TABLE ENTRY FOR POSSIBLE         *
*        REFERBACKS BY SUBSEQUENT STATEMENTS.                         *
***********************************************************************
DDEND160 TM    UNITIND,AFF         UNIT=AFF DD STATEMENT
         BO    DDEND230            YES, DO NOT ADD TO UNIT COUNTS
         CLI   TVOLSER,X'00'       VOLSER SPECIFIED??
         BE    DDEND180            NO, BRANCH
         L     R7,LASTEXEC         LOAD ADDR LAST EXEC ENTRY
***********************************************************************
*        SEE IF THE VOLSER WAS USED PREVIOUSLY IN THIS STEP.          *
*        IF SO, DO NOT CHARGE FOR THE DEVICE BUT AGAIN SAVE THE       *
*        TABLE ENTRY FOR POSSIBLE REFERBACKS BY FOLLOWING             *
*        STATEMENTS.                                                  *
***********************************************************************
DDEND170 LA    R7,ENTLEN(,R7)      INCREMENT TO NEXT ENTRY
         CLI   ENTRYTYP,TYPEND     SEE IF END OF TABLE
         BE    DDEND180            YES, NO MATCH, BRANCH
         CLC   TVOLSER,DVOLSER     SEE IF VOLSER ALREADY REFERENCED
         BE    DDEND230            YES, DO NOT CHARGE FOR IT
         B     DDEND170            LOOP
***********************************************************************
*        IF PARALLEL MOUNTING WAS REQUESTED, CHARGE THE GREATER       *
*        OF THE DEVICES SPECIFIED BY THE UNITCOUNT FIELD OR THE       *
*        NUMBER OF VOLUMES.                                           *
***********************************************************************
DDEND180 CLI   UNITCOUN,C'P'       SEE IF PARALLEL MOUNTING
         BE    DDEND190            YES, BRANCH
         MVC   ADDCOUNT,UNITCOUN   MOVE UNIT COUNT TO COMMON
         B     DDEND210            BRANCH
DDEND190 CLC   VOLCNT,SERCNT       COMPARE VOL COUNT & SERIAL CNT
         BL    DDEND200            SERIAL COUNT GREATER
         MVC   ADDCOUNT,VOLCNT     MOVE VOLUME COUNT TO COMMON
         B     DDEND205            BRANCH
DDEND200 MVC   ADDCOUNT,SERCNT     MOVE SERIAL COUNT TO COMMON
DDEND205 CLI   ADDCOUNT,X'00'      SEE IF COUNT IS ZERO
         BNE   DDEND210            NO, BRANCH
         MVI   ADDCOUNT,X'01'      SET COUNT TO 1
***********************************************************************
*        ADD THE DEVICE COUNT TO THE APPROPRIATE ACCUMULATOR.         *
***********************************************************************
DDEND210 SLR   R15,R15             ZERO WORK REG
         IC    R15,ADDCOUNT        MOVE UNIT COUNT TO REG
         TM    UNITIND,TAPE        IS THIS A TAPE DD?
         BO    DDEND220            YES, BRANCH
         AH    R15,PRIVCNT         ADD RUNNING COUNT TO THIS ONE
         STH   R15,PRIVCNT         SAVE NEW RUNNING COUNT
         B     DDEND230            BRANCH
DDEND220 AH    R15,TAPECNT         ADD RUNNING COUNT TO THIS ONE
         STH   R15,TAPECNT         SAVE NEW RUNNING COUNT
***********************************************************************
*        SAVE THE CURRENT TEMPORARY ENTRY SINCE IT SPECIFIES A        *
*        MOUNTABLE DEVICE TYPE.                                       *
***********************************************************************
DDEND230 OC    TTYPE,UNITIND       SAVE UNIT INFO
         LH    R14,ENTCOUNT        LOAD TABLE ENTRY COUNT
         LA    R14,1(,R14)         ADD 1 TO COUNT
         CH    R14,MAXENTS         SEE IF MAXIMUM REACHED
         BNL   TBLFULL             MAXIMUM REACHED, BAG THE JOB AND EXI
         STH   R14,ENTCOUNT        STORE NEW ENTRY COUNT
         L     R7,LASTENT          LOAD ADDR OF LAST ENTRY
         LA    R7,ENTLEN(,R7)      INCREMENT TO NEXT ENTRY
         MVI   ENTRYTYP,TYPEDD     SET ENTRY TO DD
         MVC   DENTRY,TENTRY       MOVE TEMPORARY ENTRY TO TABLE
         MVC   DTYPE,UNITIND       SAVE UNIT INDICATOR
         ST    R7,LASTENT          SAVE ADDR OF LAST ENTRY
***********************************************************************
*        IF THE DD STATEMENT IS FOR A JOBLIB, STEPLIB, JOBCAT,        *
*        OR A STEPCAT, THE DISPOSITION MUST BE "SHR".                 *
***********************************************************************
DDEND240 CLC   TDDN,C#JOBLIB       SEE IF JOBLIB DD
         BE    DDEND250            YES, BRANCH
         CLC   TDDN,C#STEPLI       SEE IF STEPLIB DD
         BE    DDEND260            YES, BRANCH
         CLC   TDDN,C#JOBCAT       SEE IF JOBCAT DD
         BE    DDEND270            YES, BRANCH
         CLC   TDDN,C#STEPCA       SEE IF STEPCAT DD
         BE    DDEND270            YES, BRANCH
         B     DDALLDON            NO, GET OUT
DDEND250 OI    JOBIND,JOBLIB       TURN ON JOBLIB INDICATOR
DDEND260 TM    DISPIND,SHR         SEE IF DISP=SHR
         BO    DDALLDON            YES, BRANCH
         LA    R15,27              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     DDALLDON            GET OUT
***********************************************************************
*        IF THE DD STATEMENT IS FOR A JOBCAT OR A STEPCAT, THE        *
*        JOB MUST BE AUTHORIZED.                                      *
***********************************************************************
DDEND270 TM    JOBIND,JOBSTC+JOBTECH SEE IF JOBCAT/STEPCAT ALLOWED
         BM    DDEND280            YES, BRANCH
         LA    R15,31              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
DDEND280 TM    DISPIND,SHR         SEE IF DISP=SHR
         BO    DDALLDON            YES, BRANCH
         LA    R15,27              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
DDALLDON B     GETNEXT             GO GET NEXT TEXT RECORD
         EJECT
***********************************************************************
*        THE TEXT OF THE EXEC CARD WHICH CALLS A PROC IS AS FOLLOWS   *
*            1)  2 BYTE LENGTH OF TEXT STRING INCLUDING ITSELF        *
*            2)  1 BYTE INDICATOR COMMON TO ALL TEXT RECORDS          *
*            3)  1 BYTE OF MISCELLANEOUS INDICATORS                   *
*            4)  1 BYTE INDICATOR X'94' INDICATING EXEC POS INFORMATN *
*            5)  1 BYTE NUMBER OF EXEC POSITIONAL PARAMETERS          *
*                THE 1ST POS PARAMETER IS THE JOB STEP NAME           *
*                THE 2ND POS PARAMETER IS THE PROC NAME               *
*            6)  VARIABLE LENGTH LIST OF EXEC POS PARAMETERS          *
*                EACH PRECEDED BY A 1 BYTE LENGTH FIELD               *
*            7)  THE REST OF THE RECORD WILL BE IGNORED               *
***********************************************************************
*
***********************************************************************
*        THE TEXT OF THE PROC CARD WILL BE SAVED FOR SUBSEQUENT       *
*        EXEC CARD PROCESSING.  THE STEP NAME WILL BE SAVED FROM      *
*        THE PROC CARD AND AND A POINTER SAVED TO THE START OF        *
*        THE FIRST KEYWORD PARM.  AFTER THE NORMAL EXEC CARD HAS      *
*        BEEN PROCESSED, THE PROC CARD TEXT WILL BE PROCESSED         *
*        WHICH WILL OVERRIDE ANY PREVIOUSLY PROCESSED PARAMETERS      *
*        ON THE EXEC CARD.                                            *
***********************************************************************
         EJECT
***********************************************************************
*        SAVE THE ENTIRE TEXT OF THE EXECUTE STATEMENT WHICH          *
*        CALLS A PROCEDURE SO THAT ALL PROC OVERRIDES MAY BE          *
*        PROCESSED.                                                   *
***********************************************************************
PROCARD  EQU   *
PROCSTAR LR    R14,R6              SAVE ADDRESS OF CURRENT RECORD
         LH    R15,STRLTH          LOAD LENGTH OF TEXT RECORD
         CH    R15,H#512           SEE IF LENGTH EXCEEDS 512 BYTES
         BNH   *+16                NO, BRANCH
         LA    R15,24              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     GETNEXT             GET OUT
         LA    R0,PROCTXT          LOAD ADDR OF TEXT SAVE AREA
         LR    R1,R15              LET REG 1 ALSO CONTAIN THE LENGTH
         MVCL  R0,R14              MOVE TEXT STRING TO SAVE
         LA    R6,PROCTXT          POINT TO START OF COPIED TEXT
         LA    R2,STREKEY          LOAD START OF TRUE TEXT
         ST    R2,PARMADDR         SAVE START OF PARAMETER ADDRESS
         LA    R2,1(,R2)           INCR PAST EXEC POS IND
         SLR   R4,R4               CLEAR REG FOR ICM
         ICM   R4,1,0(R2)          LOAD NUMBER OF SUBPARAMETERS
         BNZ   PROCEND1            NOT ZERO, BRANCH
         LA    R2,1(,R2)           ZERO, INCREMENT PAST COUNT
         B     PROCEND3            GET OUT
***********************************************************************
*        SAVE THE PROC STEP NAME                                      *
***********************************************************************
PROCEND1 LA    R2,1(,R2)           INCREMENT PAST COUNT
         MVI   SAVEPROC,C' '       MOVE BLANK TO 1ST POS SAVE
         MVC   SAVEPROC+1(7),SAVEPROC BLANK ENTIRE STEP NAME SAVE
         SLR   R3,R3               CLEAR REG FOR ICM
         ICM   R3,1,0(R2)          LOAD LENGTH OF JOB STEP NAME
         BZ    PROCEND2            IF ZERO, NO JOB STEP NAME
         CH    R3,H#8              SEE IF LENGTH > 8
         BNH   *+16                NO, CONTINUE
         LA    R15,25              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     GETNEXT             GET OUT
         BCTR  R3,0                MAKE MACHINE LENGTH
         EX    R3,MOVE4            MOVE STEP NAME TO SAVE AREA
PROCEND2 ICM   R3,1,0(R2)          LOAD LENGTH OF SUBPARAMETER
         LA    R2,1(R3,R2)         INCREMENT TO NEXT SUBPARAMETER
         BCT   R4,PROCEND2         LOOP UNTIL DONE
***********************************************************************
*        SAVE POINTER TO THE FIRST KEYWORD ON THE STATEMENT           *
***********************************************************************
PROCEND3 ST    R2,PROCTEXT         SAVE ADDRESS OF FIRST KEYWORD PARM
         B     GETNEXT             GET OUT
         EJECT
***********************************************************************
*        IF THE CURRENT EXECUTE STATEMENT IS FROM A PROCEDURE,        *
*        LOAD THE ADDRESS OF THE PREVIOUS STATEMENT WHICH CALLED      *
*        THE PROCEDURE AND RETURN TO THE EXECUTE CARD PROCESSOR       *
*        TO PROCESS THE OVERRIDES WHICH MAY HAVE BEEN ENTERED         *
*        ON THAT STATEMENT.                                           *
***********************************************************************
PROCSEAR TM    STREINDC,ETXPROC    STATEMENT FROM A PROCEDURE?
         BNO   GETNEXT             NO, GET OUT
         XI    PROCIND,X'01'       FLIP-FLOP SWITCH
         BZ    GETNEXT             NOW ZERO, ALREADY PROCESSED PROC TEX
         L     R2,PROCTEXT         LOAD ADDR OF PROC TEXT
         ST    R2,PARMADDR         SAVE START OF PARAMETER ADDRESS
         B     EXECPARM            GO PROCESS ADDITIONAL TEXT
         EJECT
***********************************************************************
*        THE TEXT OF THE JDT OUTPUT STATEMENT IS AS FOLLOWS           *
*            1)  2 BYTE LENGTH OF TEXT STRING INCLUDING ITSELF        *
*            2)  1 BYTE INDICATOR COMMON TO ALL TEXT RECORDS          *
*            3)  1 BYTE OF MISCELLANEOUS INDICATORS                   *
*            4)  1 BYTE INDICATOR X'BE' INDICATING JDT VERB (OUTPUT)  *
*            5)  1 BYTE NUMBER OF POSITIONAL PARAMETERS               *
*                THE 1ST POS PARAMETER IS 'OUTPUT'                    *
*                THE 2ND POS PARAMETER IS THE OUTPUT NAME             *
*            6)  VARIABLE LENGTH LIST OF KEYWORDS AND VALUES          *
*                1 BYTE INDICATOR X'1A' INDICATING JDT KEYWORD        *
*                1 BYTE NUMBER OF PARAMETERS IN KEYWORD               *
*                1 BYTE PARAMETER LENGTH FOLLOWED BY THE PARAMETER    *
*                       FOR EACH OF THE KEYWORD PARAMETERS            *
***********************************************************************
         EJECT
***********************************************************************
*        THE JDT STATEMENT IS CURRENTLY USED TO PROCESS THE           *
*        OUTPUT STATEMENT.  ANY SUCH STATEMENT IS ASSUMED TO          *
*        BE FOR AN OUTPUT JCL CARD AND DOES NOT TAKE THE TIME         *
*        TO CHECK THE JDT VERB TO VERIFY THAT FACT.  THE JDT          *
*        KEYS ARE SCANNED FOR A CLASS KEYWORD TO VERIFY THE           *
*        JOBS AUTHORITY TO USE PRODUCTION CLASSES.                    *
***********************************************************************
JDTCARD  EQU   *
JDTSTART LA    R2,STRSKEY          LOAD START OF TRUE TEXT
         ST    R2,PARMADDR         SAVE START OF PARAMETER ADDRESS
JDTPARM  CLI   0(R2),ENDK          END OF TEXT STRING??
         BE    JDTEND              YES, GET OUT
         EJECT
***********************************************************************
*        JDT VERB                                                     *
***********************************************************************
JDTVERB  CLI   0(R2),JDTVERBK      SEE IF JDT VERB KEY
         BE    JDTLOOP             YES, IGNORE IT
         EJECT
***********************************************************************
*        JDT KEYWORD                                                  *
***********************************************************************
JDTKEY   CLI   0(R2),JDTKWDK       SEE IF JDT KEYWORD KEY
         BNE   JDTLOOP             NO, UNKNOWN BUT IGNORE IT
         EJECT
***********************************************************************
*        CHECK JDT KEYWORD FOR SYSOUT CLASS                           *
***********************************************************************
JDTCLASS CLI   1(R2),X'02'         DO BOTH KEYWORD AND VALUE EXIST
         BNE   JDTLOOP             NO, IGNORE
         CLI   2(R2),X'04'         SEE IF LENGTH OF KEYWORD IS 4
         BNE   JDTLOOP             NO, CANNOT BE "PRTY"
         CLC   3(4,R2),C#PRTY       SEE IF PRTY KEYWORD
         BNE   JDTLOOP             NO, IGNORE THIS KEYWORD
         B     JDTLOOP             ***** BYPASS *****
         TM    JOBIND,JOBTECH+JOBPROD+JOBSTC+JOBOPER
         BM    JDTLOOP             YES, NOT AN ERROR
         LA    R15,34              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     JDTLOOP             LOOP TO NEXT PARAMETER
         EJECT
***********************************************************************
*        THIS ROUTINE WILL INCREMENT PAST THE STRING(S) BEING         *
*        PROCESSED.  NOTE THAT FOLLOWING THE KEYWORD DESCRIPTOR       *
*        FIELD IS A COUNT OF SUBPARAMETERS.  FOLLOWING THE COUNT      *
*        WILL BE A LENGTH OR DESCRIPTOR FIELD.  IF THE HIGH ORDER     *
*        BIT IS ON, THE FIELD IS A COUNT FIELD OF THE NUMBER OF       *
*        SUBPARAMETERS WHICH THE SUBPARAMETER ITSELF MAY HAVE.        *
*        IF THIS IS TRUE, THE DESCRIPTOR FIELD WILL BE FOLLOWED BY    *
*        A LENGTH FIELD FOR THE FIRST SUBPARAMETER.  IF THE HIGH      *
*        ORDER BIT IS NOT ON, IT IS ONLY A LENGTH FIELD FOR A         *
*        SINGLE SUBPARAMETER.                                         *
***********************************************************************
JDTLOOP  L     R2,PARMADDR         RESTORE START OF PARAMETER ADDRESS
         SLR   R5,R5               CLEAR REGISTER FOR ICM
         LA    R2,1(,R2)           INCREMENT PAST KEYWORD
         ICM   R5,1,0(R2)          LOAD SUBPARAMETER COUNT
         BNZ   JDTLOOP1            OK, BRANCH INTO ROUTINE
         LA    R2,1(,R2)           NONE, INCREMENT PAST COUNT
         B     JDTLOOP5            AND GET OUT OF ROUTINE
JDTLOOP1 LA    R2,1(,R2)           INCREMENT PAST KEYWORD DESCR
JDTLOOP2 SLR   R4,R4               CLEAR REGISTER FOR ICM
         ICM   R4,1,0(R2)          LOAD PARAMETER LENGTH
         BNM   JDTLOOP3            HIGH BIT NOT ON, ONLY 1 PARAMETER
         N     R4,F#127            'AND' OUT THE HIGH ORDER BIT
         LA    R2,1(,R2)           INCREMENT PAST CONTROL BYTE
         B     JDTLOOP4            BRANCH
JDTLOOP3 LA    R4,1                SET PARAM COUNT TO 1
JDTLOOP4 SLR   R3,R3               CLEAR REGISTER FOR ICM
         ICM   R3,1,0(R2)          LOAD PARAMETER LENGTH
         LA    R2,1(R3,R2)         INCREMENT PAST PARM
         BCT   R4,JDTLOOP4         LOOP UNTIL PROCESSED ALL PARMS
         BCT   R5,JDTLOOP2         LOOP UNTIL PROCESSED ALL PARMS
JDTLOOP5 ST    R2,PARMADDR         SAVE START OF PARAMETER ADDRESS
         B     JDTPARM             CONTINUE
JDTEND   B     GETNEXT             GO GET NEXT TEXT RECORD
         EJECT
***********************************************************************
*                                                                     *
*                         L O C A T E                                 *
*                                                                     *
*        ISSUE THE LOCATE MACRO TO OBTAIN THE REQUESTED UNIT TYPE     *
*        AND VOLSER INFORMATION.                                      *
*                                                                     *
***********************************************************************
LOCATE   LA    R15,68              LOAD OPTION VALUE
         SLL   R15,24              SHIFT OPTION TO HIGH BYTE
         ST    R15,CAMLST          STORE INTO CAMLST AREA
         LA    R15,LDSN            LOAD ADDR OF DSN
         ST    R15,CAMLST+4        STORE INTO CAMLST AREA
         XC    CAMLST+8(4),CAMLST+8 ZERO 3RD PARAM CAMLST AREA
         XC    LOCAREA(12),LOCAREA CLEAR FIRST PART OF THE WORK AREA
         LA    R15,LOCAREA         LOAD ADDR OF LOCATE WORK AREA
         ST    R15,CAMLST+12       STORE INTO CAMLST AREA
         LOCATE CAMLST             READ CATALOG
         BR    R5                  RETURN TO CALLER
         EJECT
***********************************************************************
*                                                                     *
*                         U C B S E A R                               *
*                                                                     *
*        SEARCH THE SYSTEM UCBS TO SEE IF THE REQUESTED DASD VOLUME   *
*        IS MOUNTED OR ONLY MOUNTED PRIVATE IN WHICH CASE IT WILL     *
*        BE DISMOUNTED AT END OF JOB.  IF NOT FOUND OR PRIVATE, IT    *
*        IS A 'PRIV' UNIT.                                            *
*                                                                     *
***********************************************************************
UCBSEAR  DS    0H
         AIF   ('&UCBSEAR' EQ 'YES').UCBS1
         BR    R5                  RETURN TO CALLER
         AGO   .UCBS2
.UCBS1   ANOP
         SPACE 3
*        SCAN UCB TABLE
         SPACE 1
         STM   R14,R12,SAVEREGS    SAVE REGISTERS
         L     R1,CVTPTR           GET CVT ADDRESS
         L     R6,CVTUCBSC-CVT(R1) POINT TO UCB SCAN SERVICE RTN
         ST    R6,IOSVSUCB         SAVE ADDR OF UCB SCAN ROUTINE
         MVI   DEVCLASS,UCB3DACC   SET FOR DASD UCBS ONLY
         LA    R1,SCANWORK         LOAD ADDRESS OF SCAN WORK AREA
         ST    R1,SCANP1           SAVE IN PARM LIST
         LA    R1,DEVCLASS         LOAD ADDRESS OF DEVICE CLASS
         ST    R1,SCANP2           SAVE IN PARM LIST
         LA    R1,UCBADDR          LOAD ADDRESS OF UCB RETURN
         ST    R1,SCANP3           SAVE IN PARM LIST
         OI    SCANP3,X'80'        TURN ON HIGH ORDER BIT
         XC    SCANWORK,SCANWORK   CLEAR SCAN SERVICE WORK AREA
UCBSEAR1 L     R15,IOSVSUCB        LOAD ADDR OF UCB SCAN ROUTINE
         LA    R1,SCANPARM         LOAD ADDRESS OF UCB SCAN PARM
         BALR  R14,R15             GO TO UCB SCAN SERVICE ROUTINE
         LTR   R15,R15             TEST RETURN CODE
         BNZ   UCBSEAR2            NOT ZERO, END OF UCBS
         L     R2,UCBADDR          LOAD UCB ADDRESS
         USING UCBCMSEG,R2         SET ADDRESSABILITY TO UCB
         TM    UCBTBYT3,UCB3DACC   DIRECT ACCESS?
         BZ    UCBSEAR1            NO
         TM    UCBSTAT,UCBONLI     ONLINE?
         BNO   UCBSEAR1            NO, IGNORE DEVICE
         TM    UCBVOLI,X'FF'       ANY NAME?
         BZ    UCBSEAR1            NO, IGNORE IT
         CLC   TVOLSER,UCBVOLI     SEE IF OUR VOLSER
         BE    UCBSEAR3            YES, FOUND IT
         B     UCBSEAR1            NO, LOOK AT ANOTHER UCB
UCBSEAR2 OI    UNITIND,PRIV        SINCE VOLUME NOT MOUNTED, PRIV
         MVC   WTOLIST(LWTO5),WTO5 SET WTO LIST FORM
         MVC   WTOLIST+34(6),TVOLSER SET VOLSER IN MESSAGE
         MVC   WTOLIST+63(8),JOBNAME SET JOBNAME IN MESSAGE
         AIF   ('&TSO' NE 'YES').TSO12
         WTO   MF=(E,WTOLIST)
         AGO   .TSO13
.TSO12   ANOP
         $$WTO WTOLIST             WRITE ERROR MESSAGE
.TSO13   ANOP
         B     GETNEXT             SKIP PROCESSING OF THIS STATEMENT
         $MID  905
WTO5     WTO   '&MID.REQUIRED DASD VOLUME XXXXXX NOT AVAILABLE FOR JOB X
               XXXXXXXX',ROUTCDE=(2),DESC=(4),MF=L
LWTO5    EQU   *-WTO5
UCBSEAR3 LM    R14,R12,SAVEREGS    RESTORE REGISTERS
         BR    R5                  RETURN TO CALLER
         DROP  R2                  DROP ADDRESSABILITY TO UCB
.UCBS2   ANOP
         EJECT
***********************************************************************
*        UPDATE LAST EXEC TABLE (IF NEEDED) WITH UNIT INFO            *
***********************************************************************
EOF      TM    JOBIND,JOBFAIL      WAS JOB FAILED BY EXIT?
         BO    JOBERROR            YES, BRANCH
         L     R7,LASTEXEC         LOAD ADDR OF LAST EXEC ENTRY
         LTR   R7,R7               SEE IF ADDR = 0
         BZ    EOF1                IF ZERO, NO UPDATE, BRANCH
         MVC   ETAPES,TAPECNT      MOVE STEP TAPE UNIT CNT TO TABLE
         MVC   EPRIVS,PRIVCNT      MOVE STEP PRIV UNIT CNT TO TABLE
         XC    TAPECNT,TAPECNT     ZERO TAPE UNIT CNT
         XC    PRIVCNT,PRIVCNT     ZERO PRIV UNIT CNT
         EJECT
***********************************************************************
*        THIS ROUTINE SEARCHES THE TABLE SAVED FOR JOB, EXEC AND DD   *
*        ENTRIES TO DETERMINE THE MAXIMUM RESOURCES USED BY THE JOB   *
*        THIS INFORMATION WILL BE USED TO COMPARE AGAINST A CLASS     *
*        TABLE TO DETERMINE THE CLASS WHICH SHOULD BE SET FOR THE JOB.*
***********************************************************************
EOF1     MVC   STEPM,MSG0          INITIALIZE STEP MESSAGE
         MVC   JOBM,MSG1           INITIALIZE JOB CLASS MESSAGE
         MVC   JOBMSG(10),BLANKS   BLANK MESSAGE PREFIX
         XC    STEPCNTR,STEPCNTR   ZERO STEP COUNTER FIELD
         XC    MAXTAPE,MAXTAPE     ZERO MAX FIELD
         XC    MAXPRIV,MAXPRIV     ZERO MAX FIELD
         XC    MAXTOTAL,MAXTOTAL   ZERO MAX FIELD
         XC    MAXREGN,MAXREGN     ZERO MAX FIELD
         L     R7,FIRSTENT         LOAD START OF TABLE
         CLC   ENTLEN(2,R7),H#0    SEE IF ONLY JOB ENTRY
         BE    JOBERROR            ZEROS, NO OTHER ENTRIES, FLUSH JOB
EOFLOOP1 CLI   ENTRYTYP,TYPJOB     SEE IF JOB ENTRY
         BE    EOFLOOP2            YES, BRANCH
         CLI   ENTRYTYP,TYPEXEC    SEE IF EXEC ENTRY
         BE    EOFEXEC             YES, BRANCH
         CLI   ENTRYTYP,TYPEND     SEE IF END OF TABLE
         BE    EOFSCAN             YES, BRANCH
         B     EOFLOOP2            LOOP
***********************************************************************
*        PRODUCE A STEP RESOURCE STATISTICS MESSAGE FOR EACH STEP     *
*        TO BE WRITTEN TO THE JES2 MESSAGE DATA SET.                  *
***********************************************************************
EOFEXEC  LH    R4,STEPCNTR         LOAD STEP COUNTER
         LA    R4,1(R4)            ADD ONE TO STEP COUNTER
         STH   R4,STEPCNTR         SAVE STEP COUNTER
         L     R4,ECARDNO          LOAD CARD NUMBER
         CVD   R4,DOUBLE           CONVERT CARD NUMBER TO PACKED
         MVC   STEPMSG-1(11),PREFIX MOVE MSG PREFIX TO MESSAGE
         ED    STEPMSG-1(6),DOUBLE+5 EDIT CARD NUMBER TO PREFIX
         MVC   STEPM+8(8),EJSTEP   MOVE JOB STEP TO MESSAGE
         MVC   STEPM+17(8),EPSTEP  MOVE PROC STEP TO MESSAGE
         LH    R4,ETAPES           LOAD NUMBER OF TAPES FOR STEP
         CVD   R4,DOUBLE           CONVERT TO PACKED
         MVC   STEPM+32(6),EDMASK  SET MESSAGE EDIT MASK
         ED    STEPM+32(6),DOUBLE+5 EDIT NUMBER OF TAPES TO MESSAGE
         LH    R4,EPRIVS           LOAD NUMBER OF PACK MOUNTS FOR STEP
         CVD   R4,DOUBLE           CONVERT TO PACKED
         MVC   STEPM+45(6),EDMASK  SET MESSAGE EDIT MASK
         ED    STEPM+45(6),DOUBLE+5 EDIT NUMBER OF PACK MOUNTS TO MSG
         LH    R4,EREGION          LOAD REGION SIZE FOR STEP
         CVD   R4,DOUBLE           CONVERT TO PACKED
         MVC   STEPM+59(6),EDMASK  SET MESSAGE EDIT MASK
         ED    STEPM+59(6),DOUBLE+5 EDIT REGION SIZE TO MESSAGE
         L     R4,MAXTIME          LOAD MAXIMUM CPU JOB CPU TIME
         CVD   R4,DOUBLE           CONVERT TO PACKED
         MVC   STEPM+73(6),EDMASK  SET MESSAGE EDIT MASK
         ED    STEPM+73(6),DOUBLE+5 EDIT JOB TIME TO MESSAGE
         LA    R15,STEPMSG         LOAD ADDRESS OF STEP MESSAGE
         AIF   ('&STATMSG' NE 'YES').STATMSG
         BAL   R14,MSGRTN          GO PUT MSG TO JES MESSAGE DATA SET
.STATMSG ANOP
***********************************************************************
*        COMPARE THE RESOURCES USED BY THIS STEP TO THE MAXIMUM       *
*        RESOURCES USED BY PREVIOUS STEPS.  RETAIN THE GREATER        *
*        OF THE NUMBER OF RESOURCES.                                  *
***********************************************************************
EOFCONT1 CLC   ETAPES,MAXTAPE      COMPARE STEP TAPES TO PREV MAX
         BNH   EOFEXEC1            NOT GREATER, BRANCH
         MVC   MAXTAPE,ETAPES      MAKE CURR COUNT NEW COUNT
EOFEXEC1 CLC   EPRIVS,MAXPRIV      COMPARE STEP PRIVS TO PREV MAX
         BNH   EOFEXEC2            NOT GREATER, BRANCH
         MVC   MAXPRIV,EPRIVS      MAKE CURR COUNT NEW COUNT
EOFEXEC2 LH    R4,EPRIVS           LOAD NUMBER OF PRIVS IN STEP
         AH    R4,ETAPES           ADD NUMBER OF TAPES
         CH    R4,MAXTOTAL         COMPARE STEP TOT CNT TO PREV MAX
         BNH   EOFEXEC3            NOT GREATER, BRANCH
         STH   R4,MAXTOTAL         MADE CURR TOTAL CNT NEW MAX
EOFEXEC3 CLC   EREGION,MAXREGN     COMPARE STEP REGION TO PREV MAX
         BNH   EOFLOOP2            NOT GREATER, BRANCH
         MVC   MAXREGN,EREGION     MAKE CURR REGION NEW MAX
EOFLOOP2 LA    R7,ENTLEN(,R7)      INCREMENT TO NEXT ENTRY
         B     EOFLOOP1            LOOP
EOFSCAN  CLC   MAXTAPE,H#0         SEE IF ANY TAPES
         BE    EOFPACK             NO TAPES, GO CHECK FOR PRIV
         OI    RESOURCE,TAPES      TURN ON TAPES RESOURCE
EOFPACK  CLC   MAXPRIV,H#0         SEE IF ANY PRIV
         BE    EOFLJOB             NO, BRANCH
         OI    RESOURCE,USERPACK   TURN ON USERPACK RESOURCE
EOFLJOB  CLC   MAXTIME,F#900       SEE IF CPU TIME > 15 MINUTES
         BNH   CLASSEAR            NO, BRANCH
         OI    RESOURCE+1,LONGJOB  TURN ON LONGJOB RESOURCE
         EJECT
***********************************************************************
*        THIS ROUTINE SEARCHES THE APPROPRIATE CLASS TABLES FOR       *
*        MATCHES ON RESOURCES USED TO DETERMINE THE CORRECT CLASS     *
*        FOR A JOB.  NOTE THAT EACH GROUP (TEST, PRODUCTION,          *
*        OPERATIONS, AND SYSTEMS SUPPORT HAVE CLASSES WHICH MAY BE    *
*        SPECIFIED IN ORDER TO BYPASS THE TABLES OR USED TO SINGLE    *
*        THREAD A SERIES OF JOBS BECAUSE THERE WILL ONLY BE ONE       *
*        INITIATOR SET TO THAT CLASS.                                 *
***********************************************************************
CLASSEAR TM    JOBIND,JOBSTC+JOBTSO STC OR TSO
         BM    NOCHANGE            YES, NO CHANGE OF CLASS
         TM    RESOURCE,NDM        IS THIS AN NDM JOB ?
         BZ    NOTNDM              NO BRANCH
         CLC   U7TEST,=C'Y'        SEE IF UCC7 IS LOADING THIS JOB
         BE    CLASSEA1            BR AROUND COMPARE FOR 1 STEP JOB
         CLC   STEPCNTR,H#1        SEE IF SINGLE STEP JOB
         BNE   CLASSEA2            GREATER THAN MAX FOR NDM
*        MVI   CLASSFLD,C'U'       SET TO CLASS=U
*        B     SETCLASS            GO SET CLASS U
         B     NOTNDM              TREAT IT LIKE IT IS NOT AN NDM JOB
CLASSEA1 CLC   STEPCNTR,H#2        SEE IF 2 STEP JOB
         BNE   CLASSEA2            GREATER THAN MAX FOR NDM
*        MVI   CLASSFLD,C'U'       SET TO CLASS=U
*        B     SETCLASS            GO SET CLASS U
         B     NOTNDM              TREAT IT LIKE IT IS NOT AN NDM JOB
CLASSEA2 MVC   ERRORM,MSG5         INITIALIZE ERROR MESSAGE
         MVC   ERRORMSG(10),BLANKS BLANK MESSAGE PREFIX
         LA    R15,ERRORMSG        LOAD ADDRESS OF MESSAGE
         BAL   R14,MSGRTN          GO ISSUE ERROR MSG
         CLI   ERRORM+6,C'I'       IS THIS AN INFORMATIONAL MESSAGE
         BE    CLASSEA4            YES, JUST GET OUT
         CLI   ERRORM+6,C'E'       IS THIS AN ERROR MESSAGE
         BE    CLASSEA3            YES, GO TURN ON ERROR INDICATOR
         OI    JOBIND2,WARNING     TURN ON JOB WARNED IND
         B     CLASSEA4            GET OUT
CLASSEA3 OI    JOBIND,JOBFAIL      TURN ON JOB FAILED IND
CLASSEA4 DS    0H
NOTNDM   L     R7,FIRSTENT         LOAD START OF TABLE
         LA    R4,JCLASST          LOAD ADDR OF TEST CLASS TABLE
         TM    JOBIND,JOBPROD      SEE IF PRODUCTION JOB
         BO    CLASSPRD            YES, BRANCH
         TM    JOBIND,JOBTEST      SEE IF TEST JOB
         BO    CLASST              YES, BRANCH
         TM    JOBIND,JOBTECH      SEE IF SYSTEMS SUPPORT JOB
         BO    CLASSTS             YES, BRANCH
         TM    JOBIND,JOBOPER      SEE IF OPERATIONS JOB
         BNO   EOFSCAN1            NO, USE TEST CLASS TABLE
***********************************************************************
*                     O P E R A T I O N S                             *
***********************************************************************
CLASSOP  LA    R4,JCLASST          LOAD ADDR OF TEST CLASS TABLE
         CLI   INCLASS,C'*'        SPECIAL CLASS FOR OPERATIONS
         BNE   CLASST1             NO, USE TEST CLASS TABLE
         MVI   CLASSFLD,C'M'       SET NEW CLASS TO 'M'
         LA    R4,JCLASSM          POINT TO SPECIAL CLASS TABLE
         B     CKCLASS             BYPASS TABLE SEARCH
***********************************************************************
*                 T E C H    S U P P O R T                            *
***********************************************************************
CLASSTS  LA    R4,JCLASST          LOAD ADDR OF TEST CLASS TABLE
         CLI   INCLASS,C'*'        SPECIAL CLASS FOR SYSTEMS SUPPORT
         BNE   CLASST1             NO, USE TEST CLASS TABLE
         MVI   CLASSFLD,C'S'       SET NEW CLASS TO 'S'
         LA    R4,JCLASSS          POINT TO SPECIAL CLASS TABLE
         B     CKCLASS             BYPASS TABLE SEARCH
***********************************************************************
*                       T E S T                                       *
***********************************************************************
*
***********************************************************************
*        TEST JOBS HAVE SEVERAL JOB CLASSES WHICH MAY BE USED         *
*        FOR SPECIAL REASONS.  THE CLASS SPECIFIED IN THE JOB         *
*        CARD WILL BE USED TO SEARCH A TABLE TO SEE IF ONE OF         *
*        THOSE CLASSES WAS ENTERED.  THE ALLOWABLE RESOURCES          *
*        FOR THAT JOB CLASS WILL BE COMPARED TO THE RESOURCES         *
*        ACTUALLY USED BY THE JOB.  IF THE RESOURCES USED ARE         *
*        GREATER THAN THOSE ALLOWED BY THE SPECIAL CLASS, THE         *
*        JOB WILL BE GIVEN A JCL ERROR.                               *
***********************************************************************
CLASST   LA    R4,JCLASST          LOAD ADDR OF TEST CLASS TABL
CLASST1  CLI   0(R4),X'00'         END OF TABLE
         BE    CLASST7             YES, GO SET DEFAULT CLASS
         CLC   INCLASS,0(R4)       SPECIAL CLASS MATCH
         BE    CLASST3             YES, BRANCH
CLASST2  LA    R4,16(,R4)          INCREMENT TO NEXT ENTRY
         B     CLASST1             LOOP
CLASST3  OI    JOBIND2,LEGALCLS    TURN ON LEGAL CLASS INDICATOR
         TM    1(R4),MUSTSPEC      SEE IF THIS MUST BE SPECIFIED
         BNO   CLASST7             NO, NOT A SPECIAL CLASS
         MVC   CLASSFLD,INCLASS    SET PROBABLE NEW JOB CLASS
         CLC   MAXTAPE,4(R4)       MATCH TAPE COUNT
         BH    CLASST4             COUNT EXCEEDS TABLE, BRANCH
         CLC   MAXPRIV,6(R4)       MATCH PRIV COUNT
         BH    CLASST4             COUNT EXCEEDS TABLE, BRANCH
         CLC   MAXTOTAL,8(R4)      MATCH TOTAL COUNT
         BH    CLASST4             COUNT EXCEEDS TABLE, BRANCH
         CLC   MAXREGN,10(R4)      MATCH REGION VALUES
         BH    CLASST4             REGION EXCEEDS TABLE, BRANCH
         CLC   MAXTIME,12(R4)      MATCH MAXIMUM CPU TIME
         BH    CLASST4             CPU TIME EXCEEDS TABLE, BRANCH
         MVC   CLASSFLD,0(R4)      MOVE CLASS TO SAVE AREA
         B     CKCLASS             GET OUT OF SEARCH
CLASST4  MVC   ERRORM,MSG3         INITIALIZE ERROR MESSAGE
         MVC   ERRORMSG(10),BLANKS BLANK MESSAGE PREFIX
         LA    R15,ERRORMSG        LOAD ADDRESS OF MESSAGE
         BAL   R14,MSGRTN          GO ISSUE ERROR MSG
         CLI   ERRORM+6,C'I'       IS THIS AN INFORMATIONAL MESSAGE
         BE    CLASST6             YES, CONTINUE PROCESSING WITH IT
         CLI   ERRORM+6,C'E'       IS THIS AN ERROR MESSAGE
         BE    CLASST5             YES, GO TURN ON ERROR INDICATOR
         OI    JOBIND2,WARNING     TURN ON JOB WARNED IND
         B     CLASST6             CONTINUE PROCESSING WITH IT
CLASST5  OI    JOBIND,JOBFAIL      TURN ON JOB FAILED IND
CLASST6  DS    0H
CLASST7  LA    R4,JCLASST          RELOAD ADDR OF TEST CLASS TABLE
         TM    JOBIND2,LEGALCLS    SEE IF LEGAL CLASS FOUND
         BO    EOFSCAN1            YES, GO USE TEST CLASS TABLE
         MVC   ERRORM,MSG6         INITIALIZE ERROR MESSAGE
         MVC   ERRORMSG(10),BLANKS BLANK MESSAGE PREFIX
         LA    R15,ERRORMSG        LOAD ADDRESS OF MESSAGE
         BAL   R14,MSGRTN          GO ISSUE ERROR MSG
         CLI   ERRORM+6,C'I'       IS THIS AN INFORMATIONAL MESSAGE
         BE    CLASST9             YES, JUST GET OUT
         CLI   ERRORM+6,C'E'       IS THIS AN ERROR MESSAGE
         BE    CLASST8             YES, GO TURN ON ERROR INDICATOR
         OI    JOBIND2,WARNING     TURN ON JOB WARNED IND
         B     CLASST9             RESET THE CLASS
CLASST8  OI    JOBIND,JOBFAIL      TURN ON JOB FAILED IND
CLASST9  B     EOFSCAN1            CONTINUE WITH TEST CLASS TABLE
***********************************************************************
*                     P R O D U C T I O N                             *
***********************************************************************
CLASSPRD LA    R4,JCLASSP          LOAD ADDR OF PROD CLASS TABLE
         CLI   0(R4),X'00'         SEE IF ANY TABLE ENTRIES
         BE    CKCLASS             NO, BRANCH
CLASSP1  CLI   0(R4),X'00'         END OF TABLE
         BE    CLASSP4             YES, GO SCAN REGULAR TABLE
         CLC   INCLASS,0(R4)       SPECIAL CLASS MATCH
         BE    CLASSP3             YES, BRANCH
CLASSP2  LA    R4,16(,R4)          INCREMENT TO NEXT ENTRY
         B     CLASSP1             LOOP
CLASSP3  MVC   CLASSFLD,INCLASS    SET NEW CLASS FIELD
         TM    1(R4),MUSTSPEC      SEE IF THIS MUST BE SPECIFIED
         BO    CKCLASS             YES, GOOD SPECIAL CLASS
CLASSP4  LA    R4,JCLASSP          RELOAD ADDR OF PROD CLASS TABLE
***********************************************************************
*        SCAN THE APPROPRIATE CLASS TABLE FOR THE CLASS WHICH         *
*        MATCHES THE RESOURCES USED BY THE JOB.                       *
***********************************************************************
EOFSCAN1 CLI   0(R4),X'00'         END OF TABLE
         BNE   EOFSCAN2            NO, CONTINUE
         MVC   ERRORM,MSG4         INITIALIZE ERROR MESSAGE
         MVC   ERRORMSG(10),BLANKS BLANK MESSAGE PREFIX
         LA    R15,ERRORMSG        LOAD ADDRESS OF MESSAGE
         BAL   R14,MSGRTN          GO ISSUE ERROR MSG
         MVI   CLASSFLD,C'A'       SET TO CLASS=A
         LA    R4,JCLASSDF         LOAD ADDRESS OF DEFAULT CLASS TABLE
         B     CKCLASS             GO SET DEFAULT CLASS
EOFSCAN2 TM    1(R4),MUSTSPEC      SEE IF THIS MUST BE SPECIFIED
         BO    EOFSCAN3            YES, IGNORE THIS ENTRY
         CLC   MAXTAPE,4(R4)       MATCH TAPE COUNT
         BH    EOFSCAN3            COUNT EXCEEDS TABLE, BRANCH
         CLC   MAXPRIV,6(R4)       MATCH PRIV COUNT
         BH    EOFSCAN3            COUNT EXCEEDS TABLE, BRANCH
         CLC   MAXTOTAL,8(R4)      MATCH TOTAL COUNT
         BH    EOFSCAN3            COUNT EXCEEDS TABLE, BRANCH
         CLC   MAXREGN,10(R4)      MATCH REGION VALUES
         BH    EOFSCAN3            REGION EXCEEDS TABLE, BRANCH
         CLC   MAXTIME,12(R4)      MATCH MAXIMUM CPU TIME
         BH    EOFSCAN3            CPU TIME EXCEEDS TABLE, BRANCH
         MVC   CLASSFLD,0(R4)      MOVE CLASS TO SAVE AREA
         B     CKCLASS             GET OUT OF SEARCH
EOFSCAN3 LA    R4,16(,R4)          INCREMENT TO NEXT ENTRY
         B     EOFSCAN1            LOOP
***********************************************************************
*                                                                     *
*        IF THE JOB IS NOT A PRODUCTION JOB, R4 WILL STILL            *
*        POINT TO THE CLASS TABLE ENTRY.                              *
*                                                                     *
***********************************************************************
CKCLASS  TM    JOBIND3,HOLD        SEE IF THIS CLASS REQUIRES HOLD
         BZ    SETCLASS            NO, BRANCH
         MVC   ERRORM,MSG7         INITIALIZE MESSAGE AREA
         MVC   ERRORMSG(10),BLANKS BLANK MESSAGE PREFIX
         LA    R15,ERRORMSG        LOAD ADDRESS OF MESSAGE
         BAL   R14,MSGRTN          GO ISSUE HELD MESSAGE
SETCLASS MVC   JOBM+21(1),CLASSFLD MOVE NEW CLASS TO MESSAGE
         LA    R15,JOBMSG          LOAD ADDRESS OF JOB CLASS MESSAGE
         BAL   R14,MSGRTN          GO WRITE MESSAGE TO JES MESSAGE DATA
         EJECT
***********************************************************************
*                                                                     *
*    SET JOBS PRIORITY BASED ON CPU TIME                              *
*                                                                     *
*    * * *  SEE THE NOTE FARTHER DOWN FOR A DESCRIPTION OF  * * *     *
*    * * *  HOW $RTIMTAB IS INTREPRETED BY THIS ROUTINE     * * *     *
*                                                                     *
*        THE PRIORITY FIELD, JCTPRIO, IS  A ONE BYTE FIELD            *
*        CONTAINING THE PRIORITY GROUP (DISPLAYED PRIORITY) IN        *
*        THE LEFTMOST 4 BITS AND THE AGING BITS IN THE RIGHTMOST      *
*        4 BITS.  THIS MOD ASSIGNS THE PRIORITY GROUP BASED ON        *
*        THE $RTIMTAB VALUES.  IN ADDITION, THE AGING BITS ARE        *
*        USED TO ASSIGN A SUB-PRIORITY BASED ON THE CPU TIME FOR      *
*        THAT GROUP.  THE ALGORITHM FOR THIS IS                       *
*                                                                     *
*                                                                     *
*                     15                                              *
*        ----------------------------- * ($RTIMTAB(X) - CPUTIME)      *
*        ($RTIMTAB(X) - $RTIMTAB(X-1))                                *
*                                                                     *
*        WHERE X IS THE ENTRY WHERE $RTIMTAB > =  CPUTIME             *
*              X-1 IS THE PREVIOUS $RTIMTAB ENTRY OR 0.               *
*                                                                     *
*        EX. $RTIMTAB 1 030 - 6 (PRIORITY GROUP)                      *
*                     2 045 - 5                                       *
*                     3 060 - 4                                       *
*                     4 120 - 3                                       *
*                                                                     *
*        CPU TIME = 70 SECS                                           *
*                                                                     *
*        PRIORITY GROUP IS 3  (120 > =  CPUTIME)                      *
*                                                                     *
*        SUB-PRIORITY CALCULATION IS...                               *
*                                                                     *
*             15                                                      *
*         ---------- * (120 - 70)  = 12 OR X'0C'                      *
*         (120 - 60)                                                  *
*                                                                     *
*        FINAL PRIORITY IS 3C                                         *
*                                                                     *
*    NOTE:                                                            *
*        $RTIMTAB CAN PROCESS ONLY WHOLE MINUTES.  SINCE WE           *
*        DESIRE A FINER BREAKDOWN, THE VALUES IN JESPARM ARE IN       *
*        SECONDS.  JES WILL MULTIPLY THESE VALUES BY 60 BEFORE        *
*        STORING THEM IN THE TABLE.  IN THIS EXIT WE WILL             *
*        MULTIPLY THE VALUE IN MAXTIME BY 60 BEFORE USING IT IN       *
*        THE COMPUTATIONS.                                            *
*                                                                     *
*        THE $RTIMTAB TABLE IS A SERIES OF 4 BYTE ENTRIES WHICH       *
*        IS FORMATTED AS FOLLOWS:                                     *
*        1)  A 1 BYTE PRIORITY                                        *
*        2)  A 3 BYTE TIME VALUE                                      *
*                                                                     *
***********************************************************************
PRIRTN   L     R14,JCTADDR         LOAD JCT ADDRESS
         USING JCT,R14             SET ADDRESSABILITY TO JCT
         TM    JCTJBOPT,JCTPRICD   WAS PRIORITY SPECIFIED?
         BO    NOCPRIO             YES, DEFAULT PRIORITY
         MVI   PRTY,X'50'          SET DEFAULT PROD INPUT PRIORITY
         TM    JOBIND,JOBPROD      SEE IF PRODUCTION JOB
         BO    NOCPRIO             YES, LEAVE DEFAULT PRIORITY
         MVI   PRTY,X'10'          SET DEFAULT TEST INPUT PRIORITY
         L     R7,MAXTIME          LOAD MAX CPU TIME FOR JOB
         MH    R7,H#60             MAKE IT COMPATIBLE WITH $RTIMTAB
         SLR   R0,R0               CLEAR WORK REGISTER
         SLR   R2,R2               CLEAR WORK REGISTER
         L     R6,$RTIMTAB         LOAD ADDRESS OF PRTY/CPUTIME TABLE
         B     RTIM1ST             GO PROCESS FIRST ENTRY
RTIMLOOP ICM   R0,B'0111',1(R6)    SAVE CURRENT AS PREVIOUS
         LA    R6,4(R6)            POINT TO NEXT RTIMTAB ENTRY
RTIM1ST  CLM   R7,B'0111',1(R6)    COMPARE NEW ENTRY TO ESTIM. TIME
         BH    RTIMLOOP            STILL TOO LOW, LOOP
         ICM   R2,B'0111',1(R6)    COMPUTE DIFF BETWEEN THIS RTIMTBL
         SR    R2,R0                 ENTRY AND LAST RTIMTBL ENTRY
         BZ    NOCPRIO             PROTECT OURSELVES FROM ZERODIVIDE
         L     R0,=F'150000'       LOAD 15 X WEIGHTING VALUE
         SRDA  R0,32(0)            SHIFT TO ODD REG OF PAIR
         DR    R0,R2               DIVIDE 15 BY THE DIFFERENCE
         ICM   R2,B'0111',1(R6)    COMPUTE DIFF BETWEEN EST TIME
         SR    R2,R7                 AND THIS RTIMTBL ENTRY
         MR    R0,R2               APPLY THE WEIGHT
         D     R0,=F'10000'        REMOVE THE SCALING FACTOR
         STC   R1,PRTY             SAVE THE SUB-PRIORITY
         SLR   R2,R2               CLEAR REG FOR IC
         IC    R2,0(R6)            LOAD PRIORITY FOR THIS RTIMTBL ENTRY
         SLL   R2,4                SHIFT TO FIRST NIBBLE
         NI    PRTY,X'0F'          PURIFY THE SUB-PRIORITY IN JCT
         SLR   R0,R0                 AND 'OR'
         IC    R0,PRTY                 IT WITH
         OR    R2,R0                     THE PRIORITY GROUP
         STC   R2,PRTY             PUT IT BACK IN THE JCT
         DROP  R14                 DROP ADDRESSABILITY TO JCT
NOCPRIO  EQU   *
         EJECT
***********************************************************************
*                                                                     *
*              S E T     T H E    N E W    C L A S S                  *
*                    A N D    P R I O R I T Y                         *
*                                                                     *
***********************************************************************
CHGCL    CLI   CLASSFLD,C'A'       TEST NEW CLASS
         BNL   CHGCL1              NEW, GO RESET TO NEW CLASS
DEFAULT  MVI   CLASSFLD,C'A'       SET NEW CLASS TO 'A'
CHGCL1   DS    0H
         AIF   ('&MODIFY' NE 'YES').MODIFY1
         L     R14,JCTADDR         LOAD JCT ADDRESS
         USING JCT,R14             SET ADDRESSABILITY TO JCT
         L     R15,JQEADDR         LOAD ADDRESS OF JQE
         USING JQE,R15             SET ADDRESSABILITY TO JQE
         MVC   JCTJCLAS,CLASSFLD   CHANGE CLASS IN JCT
         MVC   JCTCLASS,CLASSFLD   CHANGE CLASS IN JCT
CHGCL2   TM    JOBIND3,HOLD        SEE IF NEED OPERATOR HOLD
         BZ    CHGCL3              NO, BRANCH
         MVI   JCTUSER0,C'O'       SET FOR HOLD IN ANOTHER EXIT
CHGCL3   TM    JOBIND3,NOPRTY      SEE IF ALLOW OVERRIDE PRIO
         BO    CHGCL4              NO, BRANCH
         TM    JCTJBOPT,JCTPRICD   WAS PRIORITY SPECIFIED?
         BO    CHGCL5              YES, DO NOT CHANGE IT
CHGCL4   MVC   JCTPRIO,PRTY        MODIFY EXECUTION PRIORITY
CHGCL5   DS    0H
         DROP  R14                 DROP ADDRESSABILITY TO JCT
         DROP  R15                 DROP ADDRESSABILITY TO JQE
.MODIFY1 ANOP
         EJECT
NOCHANGE XC    RETCODE,RETCODE     SET RETURN CODE TO ZERO
         TM    JOBIND,JOBFAIL      WAS JOB FAILED BY EXIT?
         BO    JOBERROR            YES, BRANCH
         TM    JOBIND2,WARNING     WAS JOB WARNED BY EXIT?
         BO    JOBWARN             YES, BRANCH
         B     ENDOFIT             BRANCH
JOBWARN  DS    0H
         AIF   ('&WRNMSG' EQ 'YES').WRNMSG1
         B     ENDOFIT             BYPASS WTO FOR WARNING
         AGO   .WRNMSG2
.WRNMSG1 ANOP
         MVC   WTOLIST(LWTO6),WTO6 SET WTO LIST FORM
         MVC   WTOLIST+13+4(8),JOBNAME  MOVE JOBNAME TO MESSAGE
         AIF   ('&TSO' NE 'YES').TSO14
         WTO   MF=(E,WTOLIST)
         AGO   .TSO15
.TSO14   ANOP
         $$WTO WTOLIST             WRITE ERROR MESSAGE
.TSO15   ANOP
         B     ENDOFIT             BYPASS WTO LIST FORM
         $MID  906
WTO6     WTO   '&MID.JOB XXXXXXXX CONTAINED WARNINGS FOR STANDARDS VIOLX
               ATIONS',                                                X
               ROUTCDE=(2),DESC=(4),MF=L
LWTO6    EQU   *-WTO6
.WRNMSG2 ANOP
JOBERROR DS    0H
         AIF   ('&ERRMSG' EQ 'YES').ERRMSG1
         B     JOBERR1             BYPASS WTO FOR FAILURE
.ERRMSG1 ANOP
         MVC   WTOLIST(LWTO2),WTO2 SET WTO LIST FORM
         MVC   WTOLIST+13+4(8),JOBNAME  MOVE JOBNAME TO MESSAGE
         AIF   ('&TSO' NE 'YES').TSO1
         WTO   MF=(E,WTOLIST)
         AGO   .TSO2
.TSO1    ANOP
         $$WTO WTOLIST             WRITE ERROR MESSAGE
.TSO2    ANOP
         B     JOBERR1             BYPASS WTO LIST FORM
         $MID  902
WTO2     WTO   '&MID.JOB XXXXXXXX TERMINATED FOR STANDARDS VIOLATIONS',X
               ROUTCDE=(2),DESC=(4),MF=L
LWTO2    EQU   *-WTO2
JOBERR1  DS    0H
         AIF   ('&FLUSH' EQ 'YES').FLUSH1
         B     ENDOFIT             BYPASS SETTING OF FAILURE RETURN COD
.FLUSH1  ANOP
         LA    R15,8               SET JOB FAIL RETURN CODE
         ST    R15,RETCODE         AND SAVE IT
         EJECT
***********************************************************************
*                        C L E A N    U P                             *
***********************************************************************
ENDOFIT  DS    0H                  END OF EXIT
         LA    R1,ESTAEL           LOAD ADDRESS OF ESTAE LIST FORM
         AIF   ('&TSO' EQ 'YES').TSO10
         AIF   ('&ESTAE' NE 'YES').TSO10
         ESTAE 0,MF=(E,(1))        CANCEL ESTAE ENVIRONMENT
.TSO10   ANOP
         L     R1,WORKADDR         LOAD ADDRESS OF EXIT PARM LIST
         L     R1,0(R1)            LOAD ADDRESS OF EXIT WORK AREA
         XC    0(16,R1),0(R1)      CLEAR EXIT WORK AREA
         L     R0,F#16384          LOAD FREEMAIN LENGTH
         L     R1,SUBTABLE         LOAD JCL SUB TABLE AREA ADDRESS
         FREEMAIN R,LV=(0),A=(1)
         L     R2,RETCODE          SAVE RETURN CODE
         LH    R0,GETLEN           LOAD FREEMAIN SIZE
         LR    R1,R13              SAVE WORKAREA ADDRESS
         L     R13,4(,R13)         RESTORE ORIG REG 13
         FREEMAIN R,LV=(0),A=(1)
         LR    R15,R2              SET RETURN CODE
         RETURN (14,12),RC=(15)    GO BACK TO JES2
         EJECT
***********************************************************************
*        RETURN TO JES REQUESTING THE NEXT INTERNAL TEXT STATEMENT    *
***********************************************************************
GETNEXT  L     R4,CARDNO           LOAD CARD NUMBER FIELD
         LA    R4,1(,R4)           ADD 1 TO CARD NUMBER
         ST    R4,CARDNO           STORE NEW CARD NUMBER
         XC    RETCODE,RETCODE     SET RETURN CODE TO ZERO
         LA    R1,ESTAEL           LOAD ADDRESS OF ESTAE LIST FORM
         AIF   ('&TSO' EQ 'YES').TSO11
         AIF   ('&ESTAE' NE 'YES').TSO11
         ESTAE 0,MF=(E,(1))        CANCEL ESTAE ENVIRONMENT
.TSO11   ANOP
         L     R13,4(,R13)         RESTORE ORIG REG 13
QUICKOUT SLR   R15,R15             SET RETURN CODE TO ZERO
         RETURN (14,12),RC=(15)    GO BACK TO JES2
         EJECT
***********************************************************************
*                                                                     *
*                        E R R O R T N                                *
*                                                                     *
*        THIS ROUTINE WILL WRITE A MESSGE TO THE JES MESSAGE DATA     *
*        SET USING THE INDEX INTO THE MESSAGE TABLE PASSED BY         *
*        REGISTER 15 TO THE ROUTINE AND USE THE CARDNO FOR THE        *
*        STATEMENT NUMBER IN THE MESSAGE PREFIX.                      *
*                                                                     *
***********************************************************************
         PUSH  USING
ERRORTN  STM   R14,R12,SAVEREGS    SAVE REGISTERS
         L     R6,OUTRPL           GET BASE FOR RPL
         USING IFGRPL,R6           SET ADDRESSABILITY
         LR    R2,R15              SAVE ERROR NUMBER
         BCTR  R2,0                MAKE ERROR NUMBER REL TO ZERO
         MH    R2,H#90             MULTIPLY BY 90 FOR OFFSET
         L     R3,CARDNO           LOAD CARD NUMBER
         CVD   R3,DOUBLE           CONVERT CARD NUMBER TO PACKED
         L     R4,MSGCOUNT         LOAD MESSAGE COUNTER
         LTR   R4,R4               SEE IF FIRST MESSAGE
         BNZ   MSGOUT              NO, DO NOT PUT HEADERS
         MVC   BUFFER,HEADER1      MOVE HEADER LINE1 TO JES2 BUFFER
         BAL   R5,PUTMSG           GO WRITE TO MSG DATA SET
         MVC   BUFFER,HEADER2      MOVE HEADER LINE2 TO JES2 BUFFER
         BAL   R5,PUTMSG           GO WRITE TO MSG DATA SET
MSGOUT   LA    R4,1(,R4)           ADD 1 TO MESSAGE COUNT
         ST    R4,MSGCOUNT         SAVE MESSAGE COUNTER
         MVC   MSGPREF,PREFIX      MOVE MSG PREFIX TO JES2 BUFFER
         ED    MSGPREF(6),DOUBLE+5 EDIT CARD NUMBER TO PREFIX
         LA    R3,MESSAGES         LOAD ADDR OF MESSAGE TABLE
         AR    R3,R2               ADD OFFSET OF MSG TO TBL ADDR
         MVC   MSGTEXT,0(R3)       MOVE PROPER MSG TO JES2 BUFFER
         BAL   R5,PUTMSG           GO WRITE TO MSG DATA SET
         CLI   MSGTEXT+6,C'I'      IS THIS AN INFORMATIONAL MESSAGE
         BE    MSGOUT2             YES, JUST GET OUT
         CLI   MSGTEXT+6,C'E'      IS THIS AN ERROR MESSAGE
         BE    MSGOUT1             YES, JUST GET OUT
         OI    JOBIND2,WARNING     TURN ON JOB WARNED IND
         B     MSGOUT2             GET OUT
MSGOUT1  OI    JOBIND,JOBFAIL      TURN ON JOB FAILED IND
MSGOUT2  LM    R14,R12,SAVEREGS    RESTORE REGISTERS
         BR    R14                 RETURN TO CALLER
         EJECT
***********************************************************************
*                                                                     *
*                          M S G R T N                                *
*                                                                     *
*        THIS ROUTINE WILL WRITE THE MESSAGE WHICH IS POINTED TO      *
*        BY REGISTER 15 TO THE JES MESSAGE DATA SET.                  *
*                                                                     *
***********************************************************************
         PUSH  USING
MSGRTN   STM   R14,R12,SAVEREGS    SAVE REGISTERS
         LR    R2,R15              SAVE BUFFER ADDRESS
         L     R6,OUTRPL           GET BASE FOR RPL
         USING IFGRPL,R6           SET ADDRESSABILITY
         L     R3,CARDNO           LOAD CARD NUMBER
         CVD   R3,DOUBLE           CONVERT CARD NUMBER TO PACKED
         L     R4,MSGCOUNT         LOAD MESSAGE COUNTER
         LTR   R4,R4               SEE IF FIRST MESSAGE
         BNZ   MSGRTN1             NO, DO NOT PUT HEADERS
         MVC   BUFFER,HEADER1      MOVE HEADER LINE1 TO JES2 BUFFER
         BAL   R5,PUTMSG           GO WRITE TO MSG DATA SET
         MVC   BUFFER,HEADER2      MOVE HEADER LINE2 TO JES2 BUFFER
         BAL   R5,PUTMSG           GO WRITE TO MSG DATA SET
MSGRTN1  LA    R4,1(,R4)           ADD 1 TO MESSAGE COUNT
         ST    R4,MSGCOUNT         SAVE MESSAGE COUNTER
         MVC   BUFFER,0(R2)        MOVE MESSAGE FROM BUFFER
         BAL   R5,PUTMSG           GO WRITE TO MSG DATA SET
         LM    R14,R12,SAVEREGS    RESTORE REGISTERS
         BR    R14                 RETURN TO CALLER
         EJECT
***********************************************************************
*                                                                     *
*                          P U T M S G                                *
*                                                                     *
*        WRITE MESSAGE TO JES MESSAGE DATA SET                        *
*                                                                     *
***********************************************************************
PUTMSG   DS    0H
         MVI   RPLREQ,RPLPUT       OPERATION TO BE A PUT
         L     R0,OUTACB           LOAD OUTPUT ACB ADDRESS
         ST    R0,RPLDACB          SET IN ACB POINTER IN RPL
         LA    R0,BUFFER           LOAD ADDR OF BUFFER
         ST    R0,RPLAREA          POINT TO BUFFER
         XC    RPLARG(4),RPLARG    ZERO FIELD
         MVI   RPLOPT1,RPLSEQ      OPERATION TO BE SEQUENTIAL
         MVI   RPLOPT2,X'00'       ZERO FIELD
         LA    R0,100              LOAD MESSAGE LENGTH
         ST    R0,RPLRLEN          STORE MESSAGE LENGTH
         XC    RPLBUFL(4),RPLBUFL  ZERO FIELD
         XC    RPLDDDD(4),RPLDDDD  ZERO FIELD
         ST    R13,PUTSAVE+72      SAVE SAVE AREA POINTER
         LA    R13,PUTSAVE         SAVE AREA FOR ACCESS METHOD
         LA    R1,IFGRPL           LOAD ADDR OF RPL
         PUT   RPL=(1)             WRITE TO MESSAGE DATA SET
         L     R13,72(R13)         RESTORE SAVE AREA POINTER
         LTR   R15,R15             TEST RETURN CODE
         BNZ   MSGERROR            BAD, GO BAG JOB
         BR    R5                  RETURN TO CALLER
         EJECT
MSGERROR MVC   WTOLIST(LWTO1),WTO1 SET WTO LIST FORM
         AIF   ('&TSO' NE 'YES').TSO3
         WTO   MF=(E,WTOLIST)
         AGO   .TSO4
.TSO3    ANOP
         $$WTO WTOLIST             WRITE ERROR MESSAGE
.TSO4    ANOP
         B     JOBERROR            GET OUT
         $MID  901
WTO1     WTO   '&MID.PUT TO JOB MESSAGE DATA SET FAILED',              X
               ROUTCDE=(2),DESC=(4),MF=L
LWTO1    EQU   *-WTO1
         DROP  R6
         POP   USING
         EJECT
***********************************************************************
*                                                                     *
*                          R E F B A C K                              *
*                                                                     *
*        THIS ROUTINE HANDLES DSN AND VOLSER REFERBACKS.  THE SAVE    *
*        TABLE WILL BE SEARCHED FROM THE BEGINNING FOR JOBSTEP AND/OR *
*        PROCSTEP ENTRY AND THEN WITHIN THE DD ENTRIES FOR THAT STEP. *
*        IF THE ENTRY IS FOUND, THE UNIT AND DSNAME INFORMATION WILL  *
*        BE SAVED, IF NOT, A RETURN IS MADE TO THE CALLING RTN.       *
*                                                                     *
***********************************************************************
*
REFBACK  SLR   R3,R3               CLEAR WORK REGISTER
         SLR   R4,R4               CLEAR WORK REGISTER
         SLR   R5,R5               CLEAR WORK REGISTER
         IC    R5,2(R2)            LOAD NUMBER OF DSN SUBPARAMETERS
         N     R5,F#127            'AND' OUT THE HIGH ORDER BIT
         LA    R2,3(,R2)           LOAD START OF REFBK ENTRIES
         CLI   0(R2),X'01'         SEE IF LEN OF 1ST POS = 1
         BNE   DDLOOP              NO, DSN(MEMBER) PDS DISK ONLY, IGNOR
         CLI   1(R2),C'*'          SEE IF REFERBACK
         BNE   DDLOOP              NO, DSN(MEMBER) PDS DISK ONLY, IGNOR
         CH    R5,H#4              SEE IF NUMBER PARAMS > 4
         BNH   *+16                NO, CONTINUE
         LA    R15,26              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     DDLOOP              GET OUT
         MVI   REFERBCK,C' '       BLANK START OF REFBACK WORK AREA
         MVC   REFERBCK+1(23),REFERBCK BLANK ENTIRE WORK AREA
         XC    REFUNIT,REFUNIT     ZERO REFERBACK UNIT FEEDBACK
         XC    REFVOL,REFVOL       ZERO REFERBACK VOLSER FIELD
         MVI   REFDSN,C' '         BLANK ENTIRE
         MVC   REFDSN+1(43),REFDSN  REFERBACK DSNAME FIELD
REFLOOP1 LA    R4,1(,R4)           ADD 1 TO COUNT
         CR    R4,R5               SEE IF COUNT EXCEEDED
         BH    REFSEAR             YES, GO SEARCH BACK
         ICM   R3,1,0(R2)          LOAD LENGTH OF ENTRY
         BNZ   *+16                NOT ZERO, OK
         LA    R15,26              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     DDLOOP              GET OUT
         CH    R3,H#8              SEE IF LENGTH > 8
         BNH   *+16                NO, CONTINUE
         LA    R15,26              SET ERROR NUMBER
         BAL   R14,ERRORTN         GO ISSUE ERROR MSG
         B     DDLOOP              GET OUT
         BCTR  R3,0                MAKE MACHINE LENGTH
         CH    R4,H#1              SEE IF 1ST ENTRY
         BE    REFLOOP2            YES, IGNORE
         CH    R4,H#2              SEE IF 2ND ENTRY
         BE    REF#2               YES, GO PROCESS IT
         CH    R4,H#3              SEE IF 3RD ENTRY
         BE    REF#3               YES, GO PROCESS IT
*        THIS MUST BE THE 4TH ENTRY
REF#4    EX    R3,MOVE10           MOVE DDN TO SEARCH FIELD
         B     REFLOOP2            BRANCH
REF#3    CH    R5,H#3              SEE IF ONLY 3 ENTRIES
         BE    REF#3B              YES, MUST BE DDNAME
*        IF NOT DDNAME, MUST BE PROCSTEP NAME
REF#3A   EX    R3,MOVE11           MOVE ENTRY TO PSTEP ENTRY
         B     REFLOOP2            BRANCH
REF#3B   EX    R3,MOVE10           MOVE ENTRY TO DDNAME
         B     REFLOOP2            BRANCH
REF#2    CH    R5,H#2              SEE IF ONLY 2 ENTRIES
         BE    REF#2B              ONLY 2, MUST BE DDNAME
*        IF 3 OR 4 ENTRIES, THIS ENTRY MUST BE FOR JOBSTEP
REF#2A   EX    R3,MOVE12           MOVE ENTRY TO JSTEP
         B     REFLOOP2            BRANCH
REF#2B   EX    R3,MOVE10           MOVE ENTRY TO DDNAME
REFLOOP2 LA    R2,2(R3,R2)         INCREMENT TO NEXT ENTRY
         B     REFLOOP1            LOOP
REFSEAR  L     R7,LASTEXEC         LOAD ADDR OF LAST EXEC CARD
*        IF REFERBACK WITHIN CURRENT STEP, THIS ADDR WILL BE
*        USED FOR START OF SEARCH
         CLI   REFJSTEP,C' '       SEE IF JSTEP PART OF SEARCH
         BE    REFSEAR5            NO, SAME STEP WE ARE IN
         CLI   REFPSTEP,C' '       SEE IF PROCSTEP PART OF SEARCH
         BE    REFSEAR1            BLANK, NO PROCSTEP
         LA    R3,15               SET COMPARE LENGTH FOR JS & PS
         B     REFSEAR2            BRANCH
REFSEAR1 LA    R3,7                SET COMPARE LENGTH FOR JS ONLY
REFSEAR2 L     R7,FIRSTENT         LOAD START OF TABLE
REFSEAR3 LA    R7,ENTLEN(,R7)      INCREMENT PAST JOB ENTRY
         CLI   ENTRYTYP,TYPEXEC    SEE IF EXEC ENTRY
         BE    REFSEAR4            YES, GO COMPARE
         CLI   ENTRYTYP,TYPEND     SEE IF END OF TABLE
         BE    REFNO               NOT FOUND, PROBABLE JCL ERROR, EXIT
         B     REFSEAR3            LOOP
REFSEAR4 EX    R3,COMPARE1         SEE IF RIGHT STEP
         BE    REFSEAR5            YES, GO SEARCH FOR DDNAME
         B     REFSEAR3            LOOP FOR NEXT ENTRY
REFSEAR5 LA    R7,ENTLEN(,R7)      INCREMENT TO NEXT DD ENTRY
         TM    ENTRYTYP,TYPEDD     SEE IF DD ENTRY
         BNO   REFNO               DDNAME NOT FOUND, EXIT
REFSEAR6 CLC   REFDDN,DDDN         MATCH DDNAME????
         BNE   REFSEAR5            NO, LOOP FOR NEXT DD
REFOUND  MVC   REFDSN(L'DDSN),DDSN SAVE DSNAME
         MVC   REFUNIT,DTYPE       SAVE UNIT INFO
         MVC   REFVOL,DVOLSER      SAVE VOLSER INFO
REFNO    BR    R14                 RETURN
         EJECT
***********************************************************************
*                                                                     *
*                          B A D E R R O R                            *
*                                                                     *
*        A BAD ERROR HAS OCCURRED, AND A FAST PATH THROUGH THE        *
*        EXIT MUST BE FACILITATED.                                    *
*                                                                     *
***********************************************************************
BADERROR OI    JOBIND2,SEVERE      TURN ON SEVERE INDICATOR
         OI    JOBIND,JOBFAIL      TURN ON JOB FAILED INDICATOR
         B     GETNEXT             GO GET NEXT CARD
         SPACE 3
***********************************************************************
*                                                                     *
*                          T B L F U L L                              *
*                                                                     *
*        THE INTERNAL DD TABLE IS FULL.  ISSUE THE APPROPRIATE        *
*        MESSAGE AND EXIT WITH A JCL ERROR.                           *
*                                                                     *
***********************************************************************
TBLFULL  OI    JOBIND2,SEVERE      TURN ON SEVERE INDICATOR
         OI    JOBIND,JOBFAIL      TURN ON JOB FAILED INDICATOR
         MVC   WTOLIST(LWTO3),WTO3 SET WTO LIST FORM
         AIF   ('&TSO' NE 'YES').TSO5
         WTO   MF=(E,WTOLIST)
         AGO   .TSO6
.TSO5    ANOP
         $$WTO WTOLIST             WRITE ERROR MESSAGE
.TSO6    ANOP
         B     GETNEXT             SKIP PROCESSING OF THIS STATEMENT
         $MID  903
WTO3     WTO   '&MID.MAXIMUM ENTRIES IN INTERNAL TABLE EXCEEDED',      X
               ROUTCDE=(2),DESC=(4),MF=L
LWTO3    EQU   *-WTO3
         EJECT
***********************************************************************
*                                                                     *
*                          S T A E X I T                              *
*                                                                     *
*        THIS ROUTINE GETS CONTROL FOR EVERY ABEND OCCURRING IN       *
*        THE EXIT.  THIS ROUTINE WILL ISSUE AN APPROPRIATE MESSAGE    *
*        TO THE OPERATOR AND TAKE A CONSOLE DUMP FOR PROBLEM          *
*        RESOLUTION.  RETRY WILL BE ATTEMPTED FOR ALL ABENDS          *
*        WHICH WILL SET A FAST PATH THROUGH THE EXIT AND              *
*        TERMINATE THE JOB.  NOTE THAT THERE IS A RECURSION           *
*        CHECK TO PROTECT FROM ABEND LOOPS.                           *
*                                                                     *
***********************************************************************
         PUSH  USING
STAEXIT  LR    R8,R15              SET NEW BASE ADDR
         USING STAEXIT,R8          SET ADDRESSABILITY
         CH    R0,H#12             SEE IF CORE AVAILABLE
         BE    STAENO              NO, BRANCH
         SAVE  (14,12)             SAVE REGISTERS
         SPACE 1
         L     R2,0(R1)            LOAD PARAMETER ADDRESS
         L     R11,STAEREGS+64-WORKAREA(R2) RESTORE HCT ADDRESS
         LA    R3,STAESAVE-WORKAREA(R2) LOAD ADDRESS OF NEW SAVE
         ST    R3,8(,R13)          SAVE NEW SAVE ADDRESS IN OLD
         ST    R13,4(,R3)          SAVE OLD SAVE ADDRESS IN NEW
         LR    R13,R3              SET NEW SAVE ADDRESS
         LR    R3,R1               SAVE SDWA ADDRESS
         LA    R0,L'WTO4           LOAD LENGTH OF MESSAGE
         LA    R1,WTOLIST-WORKAREA(R2) LOAD ADDRESS OF WTO LIST FORM
         MVC   0(LWTO4,R1),WTO4    SET WTO LIST FORM
         AIF   ('&TSO' NE 'YES').TSO7
         WTO   MF=(E,(R1))
         AGO   .TSO8
.TSO7    ANOP
         $$WTO (R1)                WRITE ERROR MESSAGE
.TSO8    ANOP
         CLI   RECURS-WORKAREA(R2),X'FF'   SEE IF RECURSIVE ABEND
         BE    STAENO              YES, TELL ABEND NOT TO RETRY
         AIF   ('&SDUMP' EQ 'YES').SDUMP1
         B     STAE1               BYPASS SDUMP SWITCH
.SDUMP1  ANOP
         LA    R1,SDUMPL-WORKAREA(R2) LOAD ADDRESS OF SDUMP LIST FORM
         MVC   0(LSDUMPL,R1),SDUMP INITIALIZE SDUMP LIST FORM
         SDUMP MF=(E,(1))          TAKE SYSTEM DUMP
STAE1    DS    0H
         L     R13,4(,R13)         RESTORE ORIGINAL REG 13
         LR    R1,R3               RESTORE SDWA ADDRESS
         SETRP REGS=(14,12),DUMP=IGNORE,RC=4,FRESDWA=YES,              X
               RETADDR=STAERTRY
STAENO   LA    R0,STAERTRY         LOAD RETRY ADDRESS
         LA    R15,4               SET RETURN CODE TO RETRY
         BR    R14                 GO RETRY
         SPACE 2
         $MID  904
WTO4     WTO   '&MID.JES J006STDS ABEND',                              X
               ROUTCDE=(2),DESC=(4),MF=L
LWTO4    EQU   *-WTO4
         SPACE 1
         DROP  R8                  DROP LOCAL ADDRESSABILITY
         SPACE 2
         POP   USING
***********************************************************************
*                                                                     *
*                          S T A E R T R Y                            *
*                                                                     *
*        RESTORE ORIGINAL REGISTERS AND GET OUT                       *
*                                                                     *
***********************************************************************
STAERTRY LR    R13,R1              RESTORE GETMAINED AREA ADDRESS
         LM    R14,R12,STAEREGS+12 RESTORE REGISTERS
         B     BADERROR            GET OUT
         EJECT
         LTORG
         EJECT
***********************************************************************
*        TABLES USED BY EXIT                                          *
***********************************************************************
*
***********************************************************************
*                                                                     *
*    SYSTEM DATA SET NAME TABLE                                       *
*                                                                     *
*        FORMAT OF TABLE IS AS FOLLOWS                                *
*                                                                     *
*        1)  A 1 BYTE MACHINE LENGTH OF DSNAME                        *
*        2)  A 1-44 BYTE DATA SET NAME OR PREFIX                      *
*            TABLE ENDS WITH HEX 'FF'                                 *
*                                                                     *
***********************************************************************
SDSNTBL  EQU   *                   SYSTEM DATA SET NAMES
         DC    AL1(4),C'SYS1.'
         DC    AL1(3),C'LIB.'
         DC    AL1(3),C'LNK.'
         DC    AL1(3),C'LNS.'
         DC    X'FF'
*
***********************************************************************
*        FORMAT OF TABLE IS AS FOLLOWS                                *
*        1)  A 1 BYTE UNIT ATTRIBUTE TYPE                             *
*            X'01'  UNIMPORTANT DEVICE TYPE                           *
*            X'02'  TAPE DEVICE                                       *
*            X'04'  PRIVATE MOUNT DISK DEVICE                         *
*            X'08'  VIO                                               *
*        2)  A 1 BYTE MACHINE LENGTH OF ENTRY                         *
*        3)  AN 8 BYTE FIELD CONTAINING THE DEVICE NAME LEFT JUSTIFIED*
***********************************************************************
DEVTABLE EQU   *              DEVICE NAME TABLE
         DC    X'01',X'04',CL8'SYSDA'    SYSDA
         DC    X'01',X'04',CL8'SYSSQ'    SYSDA
         DC    X'01',X'03',CL8'DISK'     SYSDA
         DC    X'01',X'07',CL8'SYSALLDA' SYSDA
         DC    X'01',X'06',CL8'SCRATCH'  SYSDA
         DC    X'01',X'03',CL8'3330'     SYSDA
         DC    X'01',X'03',CL8'3350'     SYSDA
         DC    X'01',X'03',CL8'3380'     SYSDA
         DC    X'02',X'03',CL8'TAPE'     TAPE
         DC    X'02',X'04',CL8'TAPE9'    TAPE
         DC    X'02',X'04',CL8'TAPEC'    TAPE
         DC    X'02',X'04',CL8'T6250'    TAPE
         DC    X'02',X'04',CL8'T1600'    TAPE
         DC    X'02',X'03',CL8'3400'     TAPE
         DC    X'02',X'03',CL8'3480'     TAPE
         DC    X'02',X'03',CL8'2400'     TAPE
         DC    X'02',X'04',CL8'T3480'    TAPE
         DC    X'04',X'03',CL8'PRIV'     PRIV
         DC    X'08',X'02',CL8'VIO'      VIO
         DC    X'08',X'03',CL8'VIOD'     VIO
         DC    X'02',X'02',CL8'480'      TAPE
         DC    X'02',X'02',CL8'481'      TAPE
         DC    X'02',X'02',CL8'482'      TAPE
         DC    X'02',X'02',CL8'483'      TAPE
         DC    X'02',X'02',CL8'484'      TAPE
         DC    X'02',X'02',CL8'485'      TAPE
         DC    X'02',X'02',CL8'486'      TAPE
         DC    X'02',X'02',CL8'487'      TAPE
         DC    X'02',X'02',CL8'488'      TAPE
         DC    X'02',X'02',CL8'489'      TAPE
         DC    X'02',X'02',CL8'48A'      TAPE
         DC    X'02',X'02',CL8'48B'      TAPE
         DC    X'02',X'02',CL8'48C'      TAPE
         DC    X'02',X'02',CL8'48D'      TAPE
         DC    X'02',X'02',CL8'48E'      TAPE
         DC    X'02',X'02',CL8'48F'      TAPE
         DC    X'02',X'02',CL8'490'      TAPE
         DC    X'02',X'02',CL8'491'      TAPE
         DC    X'02',X'02',CL8'492'      TAPE
         DC    X'02',X'02',CL8'493'      TAPE
         DC    X'02',X'02',CL8'494'      TAPE
         DC    X'02',X'02',CL8'495'      TAPE
         DC    X'02',X'02',CL8'496'      TAPE
         DC    X'02',X'02',CL8'497'      TAPE
         DC    X'02',X'02',CL8'498'      TAPE
         DC    X'02',X'02',CL8'499'      TAPE
         DC    X'02',X'02',CL8'49A'      TAPE
         DC    X'02',X'02',CL8'49B'      TAPE
         DC    X'02',X'02',CL8'49C'      TAPE
         DC    X'02',X'02',CL8'49D'      TAPE
         DC    X'02',X'02',CL8'49E'      TAPE
         DC    X'02',X'02',CL8'49F'      TAPE
         DC    X'02',X'02',CL8'4A0'      TAPE
         DC    X'02',X'02',CL8'4A1'      TAPE
         DC    X'02',X'02',CL8'4A2'      TAPE
         DC    X'02',X'02',CL8'4A3'      TAPE
         DC    X'02',X'02',CL8'4A4'      TAPE
         DC    X'02',X'02',CL8'4A5'      TAPE
         DC    X'02',X'02',CL8'4A6'      TAPE
         DC    X'02',X'02',CL8'4A7'      TAPE
         DC    X'02',X'02',CL8'4A8'      TAPE
         DC    X'02',X'02',CL8'4A9'      TAPE
         DC    X'02',X'02',CL8'4AA'      TAPE
         DC    X'02',X'02',CL8'4AB'      TAPE
         DC    X'02',X'02',CL8'4AC'      TAPE
         DC    X'02',X'02',CL8'4AD'      TAPE
         DC    X'02',X'02',CL8'4AE'      TAPE
         DC    X'02',X'02',CL8'4AF'      TAPE
         DC    X'02',X'02',CL8'660'      TAPE
         DC    10X'00'         END OF TABLE
         EJECT
***********************************************************************
*        FORMAT OF TABLES IS AS FOLLOWS                               *
*            1)  1 BYTE CLASS CODE APPLYING TO ENTRY                  *
*            2)  1 BYTE MISC BIT SWITCHES                             *
*            3)  2 BYTE FILLER                                        *
*            4)  HALFWORD MAXIMUM TAPES PER STEP                      *
*            5)  HALFWORD MAXIMUM PRIV UNITS PER STEP                 *
*            6)  HALFWORD MAXIMUM TOTAL DEVICES PER STEP              *
*            7)  HALFWORD MAXIMUM REGION PER STEP                     *
*            8)  FULLWORD MAXIMUM CPU TIME FOR JOB IN SECONDS         *
*                                                                     *
*                                                                     *
*       A CLASS MAY BE A SPECIAL "MUST BE SPECIFIED" CATAGORY         *
*       AND ALSO BE A DEFAULT CLASS.  THIS ALLOWS A USER TO           *
*       BE ABLE TO SELECT A MORE RESTRICTIVE CLASS THAN THE           *
*       DEFAULT (IF HE WANTS TO).  IF THIS IS DONE, THE               *
*       ENTRY CONTAINING THE "MUSTSPEC" FLAG MUST BE FIRST            *
*       IN THE TABLE.                                                 *
*                                                                     *
***********************************************************************
MUSTSPEC EQU   X'80'          THIS JOB CLASS MUST BE SPECIFIED
HOLD     EQU   X'40'          THIS JOB CLASS REQUIRES OPERATOR HOLD
NOPRTY   EQU   X'20'          THIS JOB CLASS DOES NOT ALLOW PRTY
JCLASST  DS    0F             NORMAL TEST CLASS TABLE
         DC    C'T',AL1(0),C'  '
         DC         H'0',H'0',H'0',X'FFFF',F'120'
         DC    C'X',AL1(0),C'  '
         DC         H'0',H'0',H'0',X'FFFF',X'FFFFFFFF'
         DC    C'A',AL1(0),C'  '
         DC         X'FFFF',X'FFFF',X'FFFF',X'FFFF',X'FFFFFFFF'
         DC    C'U',AL1(MUSTSPEC),C'  '
         DC         H'0',H'0',H'0',X'FFFF',X'FFFFFFFF'
         DC    C'Z',AL1(MUSTSPEC),C'  '
         DC         X'FFFF',X'FFFF',X'FFFF',X'FFFF',X'FFFFFFFF'
         DC    C'M',AL1(MUSTSPEC+HOLD),C'  '
         DC         X'FFFF',X'FFFF',X'FFFF',X'FFFF',X'FFFFFFFF'
         DC    4F'0'          END OF TABLE
         SPACE 3
JCLASSP  DS    0F             PRODUCTION CLASS TABLE
         DC    C'B',AL1(0),C'  '
         DC         X'FFFF',X'FFFF',X'FFFF',X'FFFF',X'FFFFFFFF'
         DC    C'C',AL1(MUSTSPEC),C'  '
         DC         X'FFFF',X'FFFF',X'FFFF',X'FFFF',X'FFFFFFFF'
         DC    C'D',AL1(MUSTSPEC),C'  '
         DC         X'FFFF',X'FFFF',X'FFFF',X'FFFF',X'FFFFFFFF'
         DC    C'E',AL1(MUSTSPEC),C'  '
         DC         X'FFFF',X'FFFF',X'FFFF',X'FFFF',X'FFFFFFFF'
         DC    C'F',AL1(MUSTSPEC),C'  '
         DC         X'FFFF',X'FFFF',X'FFFF',X'FFFF',X'FFFFFFFF'
         DC    C'G',AL1(MUSTSPEC),C'  '
         DC         X'FFFF',X'FFFF',X'FFFF',X'FFFF',X'FFFFFFFF'
         DC    C'H',AL1(MUSTSPEC),C'  '
         DC         X'FFFF',X'FFFF',X'FFFF',X'FFFF',X'FFFFFFFF'
         DC    C'I',AL1(MUSTSPEC),C'  '
         DC         X'FFFF',X'FFFF',X'FFFF',X'FFFF',X'FFFFFFFF'
         DC    C'J',AL1(MUSTSPEC),C'  '
         DC         X'FFFF',X'FFFF',X'FFFF',X'FFFF',X'FFFFFFFF'
         DC    C'K',AL1(MUSTSPEC),C'  '
         DC         X'FFFF',X'FFFF',X'FFFF',X'FFFF',X'FFFFFFFF'
         DC    C'L',AL1(MUSTSPEC),C'  '
         DC         X'FFFF',X'FFFF',X'FFFF',X'FFFF',X'FFFFFFFF'
         DC    C'M',AL1(MUSTSPEC),C'  '
         DC         X'FFFF',X'FFFF',X'FFFF',X'FFFF',X'FFFFFFFF'
         DC    C'N',AL1(MUSTSPEC),C'  '
         DC         X'FFFF',X'FFFF',X'FFFF',X'FFFF',X'FFFFFFFF'
         DC    C'O',AL1(MUSTSPEC),C'  '
         DC         X'FFFF',X'FFFF',X'FFFF',X'FFFF',X'FFFFFFFF'
         DC    C'P',AL1(MUSTSPEC),C'  '
         DC         X'FFFF',X'FFFF',X'FFFF',X'FFFF',X'FFFFFFFF'
         DC    C'Q',AL1(MUSTSPEC),C'  '
         DC         X'FFFF',X'FFFF',X'FFFF',X'FFFF',X'FFFFFFFF'
         DC    C'R',AL1(MUSTSPEC),C'  '
         DC         X'FFFF',X'FFFF',X'FFFF',X'FFFF',X'FFFFFFFF'
         DC    C'S',AL1(MUSTSPEC),C'  '
         DC         X'FFFF',X'FFFF',X'FFFF',X'FFFF',X'FFFFFFFF'
         DC    C'U',AL1(MUSTSPEC),C'  '
         DC         X'FFFF',X'FFFF',X'FFFF',X'FFFF',X'FFFFFFFF'
         DC    C'V',AL1(MUSTSPEC),C'  '
         DC         X'FFFF',X'FFFF',X'FFFF',X'FFFF',X'FFFFFFFF'
         DC    C'W',AL1(MUSTSPEC),C'  '
         DC         X'FFFF',X'FFFF',X'FFFF',X'FFFF',X'FFFFFFFF'
         DC    C'Y',AL1(MUSTSPEC),C'  '
         DC         X'FFFF',X'FFFF',X'FFFF',X'FFFF',X'FFFFFFFF'
         DC    4F'0'          END OF TABLE
         SPACE 3
JCLASSS  DS    0F             SPECIAL TECH SUPPORT CLASS TABLE
         DC    C'S',AL1(MUSTSPEC),C'  '
         DC         X'FFFF',X'FFFF',X'FFFF',X'FFFF',X'FFFFFFFF'
         DC    4F'0'          END OF TABLE
         SPACE 3
JCLASSM  DS    0F             SPECIAL OPNS SUPPORT CLASS TABLE
         DC    C'M',AL1(MUSTSPEC),C'  '
         DC         X'FFFF',X'FFFF',X'FFFF',X'FFFF',X'FFFFFFFF'
         DC    4F'0'          END OF TABLE
         SPACE 3
JCLASSDF DS    0F             SPECIAL DEFAULT CLASS TABLE
         DC    C'A',AL1(0),C'  '
         DC         X'FFFF',X'FFFF',X'FFFF',X'FFFF',X'FFFFFFFF'
         DC    4F'0'          END OF TABLE
         EJECT
***********************************************************************
*        CONSTANTS USED BY EXIT                                       *
***********************************************************************
*
BINZEROS DC    2F'0'               FULLWORD BINARY ZEROS
BLANKS   DC    44C' '              CONSTANT STRING OF BLANKS
MOVE1    MVC   JNAME(0),1(R2)      MOVE JOBNAME TO SAVE TABLE
MOVE2    MVC   JACCTNO(0),1(R2)    MOVE ACCOUNT NO TO SAVE TABLE
MOVE3    MVC   JPGMRNM(0),1(R2)    MOVE PROGRAMMER NAME TO SAVE TABLE
MOVE4    MVC   SAVEPROC(0),1(R2)   MOVE JOB STEP NAME TO SAVE AREA
MOVE5    MVC   EJSTEP(0),3(R2)     MOVE JOB STEP NAME TO TABLE
MOVE6    MVC   EPSTEP(0),3(R2)     MOVE PROC STEP NAME TO TABLE
MOVE7    MVC   EPGMNM(0),3(R2)     MOVE STEP PGM NAME TO TABLE
MOVE8    MVC   TDDN(0),3(R2)       MOVE DDNAME TO TEMP DD ENTRY
MOVE9    MVC   TDSN(0),3(R2)       MOVE DSN TO TEMP DD ENTRY
MOVE10   MVC   REFDDN(0),1(R2)     MOVE DDNAME TO REFERBACK
MOVE11   MVC   REFPSTEP(0),1(R2)   MOVE PROCSTEP NAME TO REFERBACK
MOVE12   MVC   REFJSTEP(0),1(R2)   MOVE JOBSTEP NAME TO REFERBACK
MOVE13   MVC   TVOLSER(0),3(R2)    SAVE 1ST VOLSER FROM DD
MOVE14   MVC   TDSN(0),1(R4)       MOVE 1ST PART GDG DSN TO TEMP
MOVE15   MVC   0(0,R5),1(R4)       MOVE 2ND PART GDG DSN TO TEMP
MOVE16   MVC   JACCT(0),1(R2)      MOVE ACCOUNT NO TO WORK AREA
MOVE17   MVC   LDSN(0),3(R2)       MOVE VOL=SER DSNAME TO SAVE
PACK1    PACK  DOUBLE,1(0,R2)      PACK STEP REGION SIZE
PACK2    PACK  DOUBLE,1(0,R2)      PACK UNIT COUNT
PACK3    PACK  DOUBLE,1(0,R2)      PACK VOLUME COUNT
PACK4    PACK  DOUBLE,1(0,R2)      PACK PROC STEP REGION OVERRIDE
PACK5    PACK  DOUBLE,1(0,R2)      PACK JOB CPU TIME
COMPARE1 CLC   REFERBCK(0),EENTRY  SEE IF REFERBACK STEPS MATCH
COMPARE2 CLC   1(0,R2),2(R1)       SEE IF UNIT NAME IN TABLE
COMPARE3 CLC   1(0,R2),EPSTEP      SEE IF PROC OVERRIDE STEPNAME MATCH
DEFTIME  DC    X'A9',X'01',X'04',CL4'0002',X'FE' DFLT CPU TIME INTEXT
ZEROES   DC    8C'0'               CHARACTER CONSTANT 8 ZEROES
EDMASK   DC    X'402020202120'     EDIT MASK FOR MESSAGES
GDGMASK  DC    C'G0000V00'         GDG SUFFIX MASK
X#FFFF   DC    F'65535'            FULLWORD CONSTANT X'0000FFFF'
MAXENTS  DC    Y(16384/ENTLEN)     MAX ENTRIES IN 16K TABLE
GETLEN   DC    AL2(GETSIZE)        SIZE OF GETMAIN AREA
F#2      DC    F'2'                FULLWORD CONSTANT '2'
F#45     DC    F'45'               FULLWORD CONSTANT '45'
F#120    DC    F'120'              FULLWORD CONSTANT '120'
F#127    DC    F'127'              FULLWORD CONSTANT '127'
F#900    DC    F'900'              FULLWORD CONSTANT '900'
F#16384  DC    F'16384'            CONSTANT FULLWORD '16384'
F#86400  DC    F'86400'            CONSTANT FULLWORD '86400'
H#0      DC    H'0'                HALFWORD CONSTANT '0'
H#1      DC    H'1'                HALFWORD CONSTANT '1'
H#2      DC    H'2'                HALFWORD CONSTANT '2'
H#3      DC    H'3'                HALFWORD CONSTANT '3'
H#4      DC    H'4'                HALFWORD CONSTANT '4'
H#5      DC    H'5'                HALFWORD CONSTANT '5'
H#6      DC    H'6'                HALFWORD CONSTANT '6'
H#7      DC    H'7'                HALFWORD CONSTANT '7'
H#8      DC    H'8'                HALFWORD CONSTANT '8'
H#10     DC    H'10'               HALFWORD CONSTANT '10'
H#12     DC    H'12'               HALFWORD CONSTANT '12'
H#20     DC    H'20'               HALFWORD CONSTANT '20'
H#32     DC    H'32'               HALFWORD CONSTANT '32'
H#35     DC    H'35'               HALFWORD CONSTANT '35'
H#42     DC    H'42'               HALFWORD CONSTANT '42'
H#44     DC    H'44'               HALFWORD CONSTANT '44'
H#60     DC    H'60'               HALFWORD CONSTANT '60'
H#90     DC    H'90'               HALFWORD CONSTANT '90'
H#512    DC    H'512'              HALFWORD CONSTANT '512'
H#5000   DC    H'5000'             HALFWORD CONSTANT '5000'
P#0      DC    P'0'                PACKED CONSTANT '0'
C#1440   DC    C'1440'             CHARACTER CONSTANT '1440'
C#SYS1   DC    C'SYS1.'            SYS1. PREFIX CONSTANT
C#JOBLIB DC    CL8'JOBLIB'         CHARACTER CONSTANT 'JOBLIB'
C#STEPLI DC    CL8'STEPLIB'        CHARACTER CONSTANT 'STEPLIB'
C#JOBCAT DC    CL8'JOBCAT'         CHARACTER CONSTANT 'JOBCAT'
C#STEPCA DC    CL8'STEPCAT'        CHARACTER CONSTANT 'STEPCAT'
C#MOUNT  DC    CL8'MOUNT'          CHARACTER CONSTANT 'MOUNT'
C#OLD    DC    CL3'OLD'            CHARACTER CONSTANT 'OLD'
C#SHR    DC    CL3'SHR'            CHARACTER CONSTANT 'SHR'
C#NEW    DC    CL3'NEW'            CHARACTER CONSTANT 'NEW'
C#MOD    DC    CL3'MOD'            CHARACTER CONSTANT 'MOD'
C#KEEP   DC    CL4'KEEP'           CHARACTER CONSTANT 'KEEP'
C#PASS   DC    CL4'PASS'           CHARACTER CONSTANT 'PASS'
C#CATLG  DC    CL5'CATLG'          CHARACTER CONSTANT 'CATLG'
C#DELETE DC    CL6'DELETE'         CHARACTER CONSTANT 'DELETE'
C#UNCAT  DC    CL7'UNCATLG'        CHARACTER CONSTANT 'UNCATLG'
C#98000  DC    CL5'98000'          CHARACTER CONSTANT '98000'
C#INTRDR DC    CL6'INTRDR'         CHARACTER CONSTANT 'INTRDR'
C#BLP    DC    CL3'BLP'            CHARACTER CONSTANT 'BLP'
C#HOLD   DC    CL4'HOLD'           CHARACTER CONSTANT 'HOLD'
C#CLASS  DC    CL5'CLASS'          CHARACTER CONSTANT 'CLASS'
C#PRTY   DC    CL4'PRTY'           CHARACTER CONSTANT 'PRTY'
NULLFILE DC    CL8'NULLFILE'       CHARACTER CONSTANT NULLFILE
         SPACE
*              PGM NAME THAT ADD JES2 RESOURCES
PGMCICS  DC    C'DFHSIP'           CICS PGMNAME
PGM7074  DC    C'IIOEM74'          7074 PGMNAME
PGM1401  DC    C'IIQE14'           1401 PGMNAME
PGMNDM   DC    C'APIFUN'           NDM PGMNAME
PGMUC7   DC    C'SASSJJCL'         UCC7 LOAD PGMNAME
         SPACE
DUMPMSG1 DC    CL40'MAX ENTRIES IN CONVERTER TABLE EXCEEDED '
HEADER1  DC    CL100' STMT NO. MESSAGE'
HEADER2  DC    CL100'-                '
PREFIX   DS    0CL11               NORMAL MESSAGE PREFIX
         DC    X'402020202120',CL5' '
ESTAE    ESTAE STAEXIT,CT,XCTL=NO,PURGE=NONE,ASYNCH=NO,RECORD=YES,     X
               TERM=NO,MF=L
SDUMP    SDUMP HDR='JES2 J006STDS CONVERTER TIME ESTAE',MF=L
         EJECT
WORKAREA DSECT
SAVEAREA DS    18F                 NEW SAVE AREA
SAVEREGS DS    18F                 ROUTINE REGISTER SAVE AREA
STAEREGS DS    18F                 REGISTERS FOR ESTAE RECOVERY
STAESAVE DS    18F                 SAVE AREA FOR ESTAE ROUTINE
PUTSAVE  DS    19F                 PUT SAVE AREA
ACTWORK  DS    F                   ACCOUNTING ROUTINE WORK AREA ADDRESS
WORKADDR DS    F                   EXIT PARM LIST ADDRESS
JCTADDR  DS    F                   ADDRESS OF JCT
JQEADDR  DS    F                   ADDRESS OF JQE
TEXTSTAR DS    F                   START ADDRESS OF INTERNAL TEXT
SAVER13  DS    F                   SAVE AREA FOR REG 13 ON PUT RPL
SUBWORK  DS    F                   ADDR OF TEXT PROCESSER WORK AREA
SUBTABLE DS    F                   ADDRESS OF AREA FOR JCL STMT TABLE
EOFIND   DS    C                   END OF FILE INDICATORS
ENDSTEP  EQU   1                   LAST STATEMENT OF STEP IND
LASTBLK  EQU   2                   BLOCK WITH LAST EXEC STMT PROCESSED
WTOSAVE  DS    4F                  SAVE AREA FOR REG 14 - 1 BEFORE WTO'
DOUBLE   DS    D                   DOUBLE WORD FOR PACK & CVB
FIRSTENT DS    F                   SAVE AREA FOR FIRST SAVE TABLE ENTRY
LASTENT  DS    F                   SAVE AREA FOR LAST SAVE TABLE ENTRY
LASTEXEC DS    F                   ADDR OF LAST EXEC TABLE ENTRY
TAPECNT  DS    H                   COUNT OF TAPE UNITS USED IN STEP
PRIVCNT  DS    H                   COUNT OF PRIV UNITS USED IN STEP
ENTCOUNT DS    H                   NUMBER OF ACTIVE ENTRIES IN TABLE
UNITCOUN DS    XL1                 COUNT OF UNITS FOR THIS DD
*        THIS MAY ALSO BE 'P' FOR PARALLEL MOUNTING
SAVEPROC DS    CL8                 STEPNAME WHICH CALLS PROC
PROCTEXT DS    F                   ADDR OF SAVED KEYWORD TEXT FROM PROC
RETCODE  DS    F                   SAVE AREA FOR RETURN CODE
PROCIND  DS    C                   PROCESS PROCEDURE TEXT INDICATOR
*        X'01' INDICATES NEED TO PROCESS PROCEDURE OVERRIDE TEXT
DDIND    DS    C                   DD RELATED INDICATORS
DDBEGIN  EQU   1                   DD FIRST KEYWORD INDICATOR
JOBIND   DS    C                   JOB RELATED INDICATORS
JOBLIB   EQU   1                   JOB HAD A JOBLIB STMT
JOBFAIL  EQU   2                   JOB FAILED EXIT TESTING
JOBSTC   EQU   4                   JOB IS A STARTED TASK
JOBTSO   EQU   8                   JOB IS A TSO LOGON
JOBTECH  EQU   16                  JOB IS FOR SYSTEMS SUPPORT
JOBPROD  EQU   32                  JOB IS A PRODUCTION JOB
JOBTEST  EQU   64                  JOB IS A TEST JOB
JOBOPER  EQU   128                 JOB IS A OPERATIONS JOB
JOBIND2  DS    C                   JOB RELATED INDICATORS
MOUNT    EQU   1                   JOB HAS DASD MOUNT AUTHORITY
SEVERE   EQU   2                   A SEVERE ERROR HAS OCCURRED
WARNING  EQU   4                   JOB WARNING MESSAGES WRITTEN
LEGALCLS EQU   8                   JOB HAS A LEGAL CLASS
JOBIND3  DS    X                   JOB CLASS INDICATORS FROM TABLE
DISPIND  DS    C                   DD ENTRY DISPOSITION
NEW      EQU   1                   DISP=NEW
OLD      EQU   2                   DISP=OLD
SHR      EQU   4                   DISP=SHR
MOD      EQU   8                   DISP=MOD
CATLG    EQU   16                  STEP COMPLETION DISP=CATLG
PASS     EQU   32                  STEP COMPLETION DISP=PASS
KEEP     EQU   64                  STEP COMPLETION DISP=KEEP
DELETE   EQU   128                 STEP COMPLETION DISP=DELETE
DISPIND1 DS    C                   DD ENTRY DISPOSITION
UNCATLG  EQU   1                   STEP COMPLETION DISP=UNCATLG
UNITIND  DS    C                   DD ENTRY UNIT TYPE
TAPE     EQU   2                   UNIT USED WAS A TAPE
PRIV     EQU   4                   UNIT USED WAS A PRIV DISK PACK
VIO      EQU   8                   UNIT WAS VIO
AFF      EQU   16                  UNIT WAS DETERMINED BY AFF
UNITGDG  EQU   32                  UNIT TYPE(S) FROM GDG PROCESSING
UNITFND  EQU   128                 UNIT TYPE HAS BEEN FOUND
JACCT    DS    CL20                ACCOUNT NUMBER (1ST ACCT INFO FIELD)
JOBNAME  DS    CL8                 JOB NAME
TENTRY   DS    0CL59               TEMPORARY DD TEXT TABLE ENTRY
TDDN     DS    CL8                 TEMP DDNAME
TTYPE    DS    C                   TEMP UNIT TYPE
TDSN     DS    CL44                TEMP DSN (FULL)
TVOLSER  DS    CL6                 TEMP 1ST VOLSER OF DATA SET
LDSN     DS    CL44                DSNAME USED BY LOCATE
SVC26DSN DS    0CL44               DSNAME USED BY SVC26
SVC26DSL DS    CL1                 LENGTH OF DSN
SVC26DS  DS    CL43                ACTUAL DSNAME INDEX
REFERBCK DS    0CL25               REFERBACK WORK AREA
REFJSTEP DS    CL8                 REFERBACK JOBSTEP NAME
REFPSTEP DS    CL8                 REFERBACK PROCSTEP NAME
REFDDN   DS    CL8                 REFERBACK DDNAME
REFUNIT  DS    C                   REFERBACK PREV UNIT TYPE
REFDSN   DS    CL44                REFERBACK DSN
REFVOL   DS    CL6                 REFERBACK PREF DD 1ST VOLSER
VOLCNT   DS    XL1                 VOLUME COUNT FROM UNIT=
SERCNT   DS    XL1                 SERIAL COUNT FROM VOL=SER=
ADDCOUNT DS    XL1                 WILL CONTAIN # OF UNITS FOR DD
RECURS   DS    CL1                 RECURSIVE ABEND INDICATOR
CARDNO   DS    F                   CARD NUMBER FOR MSG ROUTINE
MSGCOUNT DS    F                   MESSAGE COUNT FOR MSG ROUTINE
OUTRPL   DS    F                   ADDR OF OUTPUT RPL
OUTACB   DS    F                   ADDR OF JOB MESSAGE DATASET ACB
PARMADDR DS    F                   ADDR OF START OF CURRENT TEXT ENTRY
STEPCNTR DS    H                   MAX TAPES PER STEP USED
MAXTAPE  DS    H                   MAX TAPES PER STEP USED
MAXPRIV  DS    H                   MAX PRIVS PER STEP USED
MAXTOTAL DS    H                   MAX TOTAL DEVICES PER STEP USED
MAXREGN  DS    H                   MAX STEP REGION SIZE
MAXTIME  DS    F                   MAXIMUM CPU TIME IN SECONDS
DEVCLASS DS    X                   IOSVSUCB DEVICE TYPE
SCANWORK DS    CL100               IOSVSUCB SCAN WORK AREA
UCBADDR  DS    F                   ADDRESS OF UCB
IOSVSUCB DS    F                   ADDRESS OF IOSVSUCB ROUTINE
SCANPARM DS    0F                  IOSVSUCB PARM LIST
SCANP1   DS    F                   ADDRESS OF WORK AREA
SCANP2   DS    F                   ADDRESS OF DEVICE TYPE FIELD
SCANP3   DS    F                   ADDRESS OF UCB RETURN AREA
         SPACE
RESOURCE DS    XL2                 JES2 RESOURCES
*              RESOURCE BYTE ZERO
TESTING  EQU   128                 JES2 'TESTING' RESOURCE
PROD     EQU   64                  JES2 'PROD'  RESOURCE
TAPES    EQU   32                  JES2 'TAPES' RESOURCE
USERPACK EQU   8                   JES2 'USERPACK' RESOURCE
P1401    EQU   2                   JES2 '1401' RESOURCE
NDM      EQU   1                   JES2 'NDM' RESOURCE
*              RESOURCE - BYTE ONE(1)
PCICS    EQU   128                 JES2 'CICS' RESOURCE
P7074    EQU   64                  JES2 '7074' RESOURCE
LONGJOB  EQU   8                   JES2 'LONGJOB' RESOURCE
DEDICATE EQU   4                   JES2 'DEDICATE' RESOURCE
*
CLASSFLD DS    C                   CLASS AS DETERMINED FROM TABLE
PRTY     DS    X                   PRTY AS DETERMINED FROM CPU TIME
         SPACE
INCLASS  DS    C                   CLASS FROM JOB TEXT RECORD
U7TEST   DC    C' '                TEST FOR UCC7 LOAD JOB
AUTHJOB  DS    CL8                 JOBNAME USED IN AUTHORIZATION CHECK
CAMLST   CAMLST NAME,TDSN,,LOCAREA LOCATE PARAM AREA
         DS    0D
LOCAREA  DS    0CL266              LOCATE CAMLST WORK AREA
CAMLCNT  DS    H                   VOLUMES IN LIST
CAMLUNIT DS    0CL4                UNIT TYPE FOR 1ST VOLUME
UCBTYP1  DS    CL1                 UCB TYPE BYTE 1
UCBTYP2  DS    CL1                 UCB TYPE BYTE 2
UCBTYP3  DS    CL1                 UCB TYPE BYTE 3
*        X'80' IN UCBTYP3 INDICATES TAPE DEVICE
UCBTYP4  DS    CL1                 UCB TYPE BYTE 4
CAMVOL   DS    CL6                 1ST VOLSER IN DATA SET
         DS    CL254               REST OF WORK AREA
LASTUCB  DS    F                   SAVE AREA FOR LAST UCB ADDR PROCESSE
         DS    CL1                 EDIT FILL CHAR FOR MSG PREFIX
STEPMSG  DS    0CL100              STEP RESOURCE MESSAGE
         DS    CL10                MESSAGE PREFIX
STEPM    DC    CL90'FUN000I XXXXXXXX XXXXXXXX TAPES= XXXXX PACKS= XXXXXX
                REGION= NNNNNK JTIME= XXXXX           '
         DS    CL1                 EDIT FILL CHAR FOR MSG PREFIX
JOBMSG   DS    0CL100              JOB CLASS MESSAGE
         DS    CL10                MESSAGE PREFIX
JOBM     DC    CL90'FUN000I CLASS SET TO X                             X
                                                      '
ERRORMSG DS    0CL100              ERROR MESSAGE
         DS    CL10                MESSAGE PREFIX
ERRORM   DC    CL90' '
MSGPREF  DS    0CL11               ERROR MESSAGE PREFIX
         DS    C                   EDIT FILL CHARACTER
BUFFER   DS    0CL100              JES2 MESSAGE AREA
         DS    CL10                REST OF MESSAGE PREFIX
MSGTEXT  DS    CL90                TEXT OF ERROR MESSAGE
MSGRPL   DS    19F                 SKELETON RPL FOR OUTPUT MSG DATA SET
WTOLIST  DS    CL120               SET WTO LIST FORM
PROCTXT  DS    CL512               SAVE AREA FOR PROC CARD TEXT
CTGPL    DS    XL40                CATALOG MANAGEMENT PARAMETER LIST
ESTAEL   ESTAE STAEXIT,CT,XCTL=NO,PURGE=NONE,ASYNCH=NO,RECORD=YES,     X
               TERM=NO,MF=L
LESTAEL  EQU   *-ESTAEL
SDUMPL   SDUMP HDR='JES2 J006STDS CONVERTER TIME ESTAE',MF=L
LSDUMPL  EQU   *-SDUMPL
         CNOP  0,4
SVC26WRK DS    CL5000              SVC26 WORK AREA
GETSIZE  EQU   *-WORKAREA          LENGTH OF WORK AREA
         EJECT
SAVTABLE DSECT
***********************************************************************
*        THIS TABLE HAS 3 ENTRY TYPES                                 *
*            THE 1ST ENTRY IN THE TABLE WILL BE FOR THE JOB CARD      *
*            THE 2ND ENTRY IN THE TABLE WILL BE FOR THE 1ST EXEC CARD *
*            FOLLOWING THE EXEC ENTRY WILL BE ANY DD ENTRIES FOR THE  *
*                STEP WHICH PASS OR CATLG PRIVATE DISK PACKS OR TAPES *
*            THE EXEC CARD ENTRY AND SUBSEQUENT DD ENTRIES WILL BE    *
*                REPEATED FOR ALL STEPS OF THE JOB.                   *
***********************************************************************
ENTLEN   EQU   60                  LENGTH OF EACH TABLE ENTRY
ENTRYTYP DS    C                   TABLE ENTRY TYPE
TYPEND   EQU   0                   SIGNIFIES END OF TABLE
TYPJOB   EQU   1                   SIGNIFIES A JOB ENTRY
TYPEXEC  EQU   2                   SIGNIFIES AN EXEC ENTRY
TYPEDD   EQU   4                   SIGNIFIES A DD ENTRY
***********************************************************************
*                                                                     *
*                      J O B                                          *
*                                                                     *
***********************************************************************
JENTRY   DS    0CL59               JOB STATEMENT ENTRY
JNAME    DS    CL8                 JOB NAME
JPGMRNM  DS    CL10                PROGRAMMER NAME (1ST 10 BYTES ONLY)
JACCTNO  DS    CL14                ACCOUNT NUMBER (1ST ACCT INFO FIELD)
JACCTLEN DS    C                   ACCOUNT NUMBER LENGTH
         ORG   JENTRY
***********************************************************************
*                                                                     *
*                     E X E C                                         *
*                                                                     *
***********************************************************************
EENTRY   DS    0CL59               EXEC STATEMENT ENTRY
EJSTEP   DS    CL8                 JOB STEP NAME
EPSTEP   DS    CL8                 PROC STEP NAME
EPGMNM   DS    CL8                 PGM NAME
ELIBIND  DS    C                   STEP HAD JOBLIB OR STEPLIB
ESTEPLIB EQU   1                   STEPLIB PRESENT
EJOBLIB  EQU   2                   JOBLIB PRESENT
EREGIONK EQU   4                   REGION SPECIFIED IN 'K'
EREGIONM EQU   8                   REGION SPECIFIED IN 'M'
EREGION  DS    H                   STEP REGION SIZE
ETAPES   DS    H                   TAPE UNITS USED IN STEP
EPRIVS   DS    H                   PRIV UNITS USED IN STEP
ECARDNO  DS    F                   CARD NUMBER OF THIS STATEMENT
         ORG   JENTRY
***********************************************************************
*                                                                     *
*                       D D                                           *
*                                                                     *
***********************************************************************
DENTRY   DS    0CL59               DD STATEMENT ENTRY
DDDN     DS    CL8                 DDNAME
DTYPE    DS    C                   TYPE OF UNIT FOR THIS FILE
DTAPE    EQU   2                   UNIT = TAPE
DPRIV    EQU   4                   UNIT = PRIV OR PRIV-1
DDSN     DS    CL44                DSN FOR THIS FILE
DVOLSER  DS    CL6                 FIRST VOL/SER OF DATA SET
         EJECT
J006STDS CSECT
MSG0     DC    CL90'FUN100I XXXXXXXX XXXXXXXX TAPES= XXXXX PACKS= XXXXXX
                REGION= NNNNNK JTIME= XXXXX           '
MSG1     DC    CL90'FUN101I CLASS SET TO X                             X
                                                      '
MSG2     DC    CL90'FUN102I                                            X
                                                       '
MSG3     DC    CL90'FUN103I RESOURCES REQUIRED BY THE JOB EXCEED THOSE X
               ALLOWED FOR THE SPECIFIED JOB CLASS     '
MSG4     DC    CL90'FUN104I INTERNAL ERROR - MATCH WITHIN CLASS TABLE NX
               OT FOUND                               '
MSG5     DC    CL90'FUN105W NDM REQUESTS MUST BE ISSUED ONLY FROM A SINX
               GLE STEP JOB                            '
MSG6     DC    CL90'FUN106W ILLEGAL JOB CLASS REQUESTED BY A TEST JOB  X
                                                       '
MSG7     DC    CL90'FUN107I JOB BEING PLACED IN THE OPERATOR HOLD QUEUEX
                 BECAUSE OF JOB REQUIREMENTS           '
MESSAGES DS    0CL90               MESSAGE TABLE
M1       DC    CL90'FUN001E INTERNAL ERROR - INVALID TEXT STATEMENT TYPX
               E DETECTED                             '
M2       DC    CL90'FUN002E JOBNAME, ACCOUNTING INFORMATION, OR JOBNAMEX
                MISSING ON THE JOB CARD               '
M3       DC    CL90'FUN003E LENGTH OF JOBNAME EXCEEDS MAXIMUM OF 8 CHARX
               ACTERS                                 '
M4       DC    CL90'FUN004E LENGTH OF PROGRAMMER NAME FIELD ON THE JOB X
               CARD EXCEEDS MAXIMUM OF 20 CHARACTERS  '
M5       DC    CL90'                                                   X
                                                      '
M6       DC    CL90'FUN006E TIME VALUE ON THE JOB CARD IS NOT NUMERIC  X
                                                      '
M7       DC    CL90'FUN007E UNAUTHORIZED USE OF TIME=1440 ON THE JOB CAX
               RD                                     '
M8       DC    CL90'FUN008E LENGTH OF THE STEP NAME ON THE EXECUTE CARDX
                EXCEEDS MAXIMUM OF 8 CHARACTERS       '
M9       DC    CL90'FUN009E LENGTH OF THE PROGRAM NAME ON THE EXECUTE CX
               ARD EXCEEDS MAXIMUM OF 8 CHARACTERS    '
M10      DC    CL90'FUN010E INVALID FORMAT FOR THE REGION PARAMETER ON X
               THE EXECUTE CARD                       '
M11      DC    CL90'FUN011E REGION SIZE ON THE EXECUTE CARD IS NOT NUMEX
               RIC                                    '
M12      DC    CL90'FUN012E INVALID FORMAT FOR THE TIME PARAMETER ON THX
               E EXECUTE CARD                         '
M13      DC    CL90'FUN013E UNAUTHORIZED USE OF TIME=1440 ON THE EXECUTX
               E CARD                                 '
M14      DC    CL90'FUN014E LENGTH OF THE DDNAME ON THE DD CARD EXCEEDSX
                MAXIMUM OF 8 CHARACTERS               '
M15      DC    CL90'FUN015E INVALID FORMAT FOR THE DSNAME PARAMETER ON X
               THE DD CARD                            '
M16      DC    CL90'FUN016E LENGTH OF THE DSNAME ON THE DD CARD EXCEEDSX
                MAXIMUM OF 44 CHARACTERS              '
M17      DC    CL90'FUN017E INVALID FORMAT FOR THE DISP PARAMETER ON THX
               E DD CARD                              '
M18      DC    CL90'FUN018E INVALID FORMAT FOR THE UNIT PARAMETER ON THX
               E DD CARD                              '
M19      DC    CL90'FUN019E UNIT COUNT WITHIN THE UNIT PARAMETER ON THEX
                DD CARD IS NOT NUMERIC                '
M20      DC    CL90'FUN020E INVALID FORMAT FOR THE VOLUME PARAMETER ON X
               THE DD CARD                            '
M21      DC    CL90'FUN021E VOLUME COUNT WITHIN THE VOLUME PARAMETER ONX
                THE DD CARD IS NOT NUMERIC            '
M22      DC    CL90'FUN022E LENGTH OF THE VOLSER PARAMETER(S) ON THE DDX
                CARD EXCEEDS MAXIMUM OF 6 CHARACTERS  '
M23      DC    CL90'FUN023W UNAUTHORIZED DISPOSITION SPECIFIED FOR A SYX
               STEM DATA SET                          '
M24      DC    CL90'FUN024E INTERNAL ERROR - LENGTH OF THE INTERNAL TEXX
               T OF AN EXECUTE CARD EXCEEDS 512 CHARS '
M25      DC    CL90'FUN025E LENGTH OF THE PROC STEP NAME ON THE EXECUTEX
                CARD EXCEEDS MAXIMUM OF 8 CHARACTERS  '
M26      DC    CL90'FUN026E INVALID FORMAT FOR THE REFERBACK SUBPARAMETX
               ER ON THE DD CARD                      '
M27      DC    CL90'FUN027W INVALID DISPOSITION ON A JOBLIB, STEPLIB, JX
               OBCAT, OR STEPCAT DD CARD              '
M28      DC    CL90'FUN028E THE LENGTH OF THE DSNAME ON A VOLUME REFERBX
               ACK EXCEEDS A MAXIMUM OF 44 CHARACTERS '
M29      DC    CL90'FUN029E THE REQUIRED ACCOUNTING FIELD ON THE JOB CAX
               RD WAS NOT SPECIFIED                   '
M30      DC    CL90'FUN030E INVALID FIRST UNION ACCOUNTING CODE SPECIFIX
               ED ON THE JOB CARD                     '
M31      DC    CL90'FUN031W UNAUTHORIZED USE OF JOBCAT OR STEPCAT DD STX
               ATEMENT                                 '
M32      DC    CL90'FUN032W UNAUTHORIZED ATTEMPT TO ALLOCATE THE JES2 IX
               NTERNAL READER                          '
M33      DC    CL90'FUN033W BIN NUMBER MUST BE SPECIFIED ON THE JOB CARX
               D                                       '
M34      DC    CL90'FUN034W UNAUTHORIZED USE OF PRTY PARAMETER ON OUTPUX
               T STATEMENT                             '
         $MODEND
         END
