         TITLE 'JES2 PRE INITIALIZATION EXIT'
***********************************************************************
*                                                                     *
*        ENVIRONMENT   MVS SP 2.2.0                                   *
*                                                                     *
*        ENTRY EXIT0A                                                 *
*                                                                     *
*        THIS JES2 EXIT ROUTINE IS DESIGNED TO RUN RIGHT BEFORE       *
*        JES2 INITIALIZATION OPTIONS ARE PROCESSED WHICH WILL         *
*        ALLOW US TO MODIFY SOME JES2 CONTROL BLOCKS AS WELL          *
*        AS CREATE OUR OWN.                                           *
*                                                                     *
*        THIS EXIT WILL CREATE A 4K UCT FOR INSTALLATION              *
*        PURPOSES.  IT WILL THEN SET UP USER INITIALIZATION           *
*        PARAMETERS SCAN CONTROL BLOCKS AND USER WORK SELECTION       *
*        CRITERIA CONTROL BLOCKS AND ANCHOR THEM OFF OF THE           *
*        MCT.                                                         *
*                                                                     *
*                                                                     *
*        ENTRY E005$TD                                                *
*                                                                     *
*        THIS JES2 EXIT PROGRAM IS DESIGNED TO SEARCH FOR ALL         *
*        $T DEV COMMANDS FOR PRINTERS AND PUNCHES FOR THE JTYPE=      *
*        KEYWORD.  THE JTYPE KEYWORD WILL BE AUTOMATICALLY HANDLED    *
*        FOR OFFLOAD DEVICES.  IF THE KEYWORD IS NOT FOUND, THE       *
*        COMMAND WILL BE ALLOWED TO CONTINUE NORMALLY.  IF IT IS      *
*        FOUND, THIS ROUTINE WILL EXTRACT THE PARAMETER FROM THE      *
*        COMMAND LIST, PROCESS IT, AND REFORMAT THE COMMAND           *
*        BUFFER TO ELIMINATE THE UNSUPPORTED KEYWORD.  THIS EXIT      *
*        CANNOT CHANGE THE NUMBER OF OPERANDS IN THE COMMAND          *
*        BUFFER, SO A DUMMY WS=(/) PARAMETER IS SUBSTITUTED FOR       *
*        JTYPE= KEYWORD.  NOTE THAT THIS TECHNIQUE MAY ALLOW          *
*        THE JTYPE= OPERAND TO BE PROCESSED AND THE REST OF THE       *
*        COMMAND TO BE REJECTED BY THE NORMAL $T DEV COMMAND          *
*        PROCESSOR.                                                   *
*                                                                     *
*                                                                     *
*        ENTRY E010$DU                                                *
*                                                                     *
*        THIS JES2 EXIT PROGRAM IS DESIGNED EXAMINE AND/OR            *
*        MODIFY ALL JES2 MESSAGES.  THE PURPOSE OF THIS ROUTINE       *
*        IS TO EXAMINE ALL $HASP628 MESSAGES WHICH ARE THE            *
*        RESULT OF A $DU COMMAND TO SEE IF THE UNIT BEING             *
*        DISPLAYED IS ONE TO WHICH WE HAVE ADDED THE JTYPE=           *
*        ATTRIBUTE.  SOME OF THE NEWER DEVICES SUCH AS OFFLOAD        *
*        DEVICES HANDLE THE NEW KEYWORD AUTOMATICALLY.  OTHERS        *
*        SUCH AS PRINTERS AND PUNCHES DO NOT.  UNTIL THEY ARE         *
*        PROCESSED IN THE NEW FASHION, WE WILL HAVE TO PLAY           *
*        THESE GAMES.  THUS FOR PRINTERS AND PUNCHES WE WILL          *
*        APPEND THE VALUE OF JTYPE ON THE DISPLAYED MESSAGE.          *
*                                                                     *
***********************************************************************
         EJECT
***********************************************************************
*                                                                     *
*                                                                     *
*        WRITTEN BY:                                                  *
*                        JOHN V. HOOPER                               *
*                        FIRST UNION NATIONAL BANK                    *
*                        301 SOUTH TRYON STREET                       *
*                        CHARLOTTE, N.C.  28288                       *
*                        (704) 374-2427                               *
*                                                                     *
***********************************************************************
         EJECT
***********************************************************************
*                                                                     *
*              M A C R O S   U S E D   I N   H A S P X I T 0          *
*                                                                     *
*        01)  $BUFFER      SYS1.HASPSRC                               *
*        02)  $CAT         SYS1.HASPSRC                               *
*        03)  $CMB         SYS1.HASPSRC                               *
*        04)  $COMWORK     SYS1.HASPSRC                               *
*        05)  $DCT         SYS1.HASPSRC                               *
*        06)  $ENTRY       SYS1.HASPSRC                               *
*        07)  $ERA         SYS1.HASPSRC                               *
*        08)  $FCSUCT      SYS1.HASPSRC (USER)                        *
*        09)  $FCSUHDR     SYS1.HASPSRC (USER)                        *
*        10)  $FREEBUF     SYS1.HASPSRC                               *
*        11)  $GETBUF      SYS1.HASPSRC                               *
*        12)  $HASPEQU     SYS1.HASPSRC                               *
*        13)  $HASPGBL     SYS1.HASPSRC                               *
*        14)  $HCT         SYS1.HASPSRC                               *
*        15)  $MCT         SYS1.HASPSRC                               *
*        16)  $MIT         SYS1.HASPSRC                               *
*        17)  $JCT         SYS1.HASPSRC                               *
*        18)  $JOE         SYS1.HASPSRC                               *
*        19)  $JQE         SYS1.HASPSRC                               *
*        20)  $MODEND      SYS1.HASPSRC                               *
*        21)  $MODULE      SYS1.HASPSRC                               *
*        22)  $PADDR       SYS1.HASPSRC                               *
*        23)  $PCE         SYS1.HASPSRC                               *
*        24)  $RETURN      SYS1.HASPSRC                               *
*        25)  $SAVE        SYS1.HASPSRC                               *
*        26)  $SCANTAB     SYS1.HASPSRC                               *
*        27)  $STORE       SYS1.HASPSRC                               *
*        28)  $WSTAB       SYS1.HASPSRC                               *
*        29)  $XECB        SYS1.HASPSRC                               *
*        30)  GETMAIN      SYS1.MACLIB                                *
*        31)  IAZRESPA     SYS1.AMODGEN                               *
*        32)  IEZWPL       SYS1.AMODGEN                               *
*        33)  IFGRPL       SYS1.MACLIB                                *
*                                                                     *
*                                                                     *
*              L I N K A G E    E D I T O R    I N F O                *
*                                                                     *
*        SIZE:       2K                                               *
*        ATTRIBUTES: REENTRANT, REUSEABLE, REFRESHABLE                *
*                                                                     *
*                                                                     *
***********************************************************************
         EJECT
         COPY  $HASPGBL
HASPXIT0 $MODULE SYSP=(GEN,GEN,DATA,GEN,GEN),                          X
               ENVIRON=JES2,                                           X
               TITLE='JES2 PRE INITIALIZATION EXIT',                   X
               $HASPEQU,           GENERATE HASP EQUATES               X
               $BUFFER,            GENERATE HASP BUFFER DSECT          X
               $CAT,               GENERATE HASP CAT DSECT             X
               $CMB,               GENERATE HASP CMB DSECT             X
               $COMWORK,           GENERATE HASP COMWORK DSECT         X
               $DCT,               GENERATE HASP DCT DSECT             X
               $ERA,               GENERATE HASP ERA DSECT             X
               $HCT,               GENERATE HASP HCT DSECT             X
               $JCT,               GENERATE HASP JCT DSECT             X
               $JOE,               GENERATE HASP JOE DSECT             X
               $JQE,               GENERATE HASP JQE DSECT             X
               $MCT,               GENERATE HASP MCT DSECT             X
               $MIT,               GENERATE HASP MIT DSECT             X
               $PADDR,             GENERATE HASP PADDR DSECT           X
               $PCE,               GENERATE HASP PCE DSECT             X
               $SCANTAB,           GENERATE HASP SCANTABL TABLE DSECT  X
               $WSTAB,             GENERATE HASP WSTAB    TABLE DSECT  X
               $XECB,              GENERATE HASP EXT ECB DSECT         X
               RESPA,              GENERATE MVS  RESPA DSECT           X
               RPL,                GENERATE MVS  RPL DSECT             X
               WPL                 GENERATE MVS  WPL DSECT
         TITLE 'JES2 PRE INITIALIZATION EXIT'
         $FCSUCT ,                 GENERATE THE UCT DSECT
HASPXIT0 CSECT ,                   RESTORE THE CSECT ENVIRONMENT
         EJECT
         $FCSUHDR ,                GENERATE USER NJE JOB HEADER DSECT
HASPXIT0 CSECT ,                   RESTORE THE CSECT ENVIRONMENT
         EJECT
***********************************************************************
*                                                                     *
*        $T DEV COMMAND PREPROCESSOR WORK AREA                        *
*                                                                     *
***********************************************************************
         SPACE 3
$TDWORK  DSECT                     COMMAND WORK AREA
         DS    CL(BUFSTART-BFPDSECT) ***** RESERVED BY JES2 *****
DEVICE   DS    CL8                 FULL DEVICE NAME
VALUE    DS    CL4                 VALUE OF JTYPE= PARAMETER
HASPXIT0 CSECT ,                   RESTORE THE CSECT ENVIRONMENT
         EJECT
***********************************************************************
*                                                                     *
*        ACTUAL EXIT0 ENTRY POINT                                     *
*                                                                     *
***********************************************************************
EXIT0A   $ENTRY  BASE=R12
         $SAVE
         LR    R12,R15             ESTABLISH BASE REGISTER
         USING HCT,R11             ESTABLISH ADDRESSABILITY TO HCT
         ICM   R9,15,$UCT          GET UCT ADDRESS
         BNZ   EXIT0EN             NOT ZERO, NOT FIRST ENTRY, GET OUT
         USING UCT,R9              ESTABLISH ADDRESSABILITY TO UCT
         EJECT
***********************************************************************
*                                                                     *
*        GET STORAGE FOR UCT                                          *
*                                                                     *
***********************************************************************
         GETMAIN R,LV=4096,SP=7    GET CORE FOR UCT
         LR    R9,R1               SET UCT BASE REG
         ST    R1,$UCT             SAVE UCT ADDRESS
         LR    R0,R1               CLEAR
         LH    R1,=H'4096'             ENTIRE
         SLR   R15,R15                     GETMAINED
         MVCL  R0,R14                          TO ZEROS
         MVC   UCTID,=C'UCT '      SET EYECATCHER
***********************************************************************
*                                                                     *
*        SAVE USER PARAMETER SCANTAB ADDRESS IN MCT AND UCT           *
*                                                                     *
*        WE WOULD LIKE TO USE THIS TECHNIQUE FOR REMOTE DEVICES       *
*        BUT THERE IS NO USER WORK SELECTION MCT ENTRY FOR            *
*        THEM YET.  MAYBE THERE WILL BE IN THE FUTURE.  SO            *
*        FOR NOW, WE WILL ONLY PROCESS PRINTERS, PUNCHES, AND         *
*        OFFLOAD DEVICES.                                             *
*                                                                     *
***********************************************************************
         L     R8,$MCT             LOAD ADDRESS OF MASTER CONTROL TABLE
         USING MCT,R8              ESTABLISH ADDRESSABILITY TO MCT
         LA    R1,SCANT1           LOAD ADDRESS OF JTYPE SCAN ENTRY
         ST    R1,MCTPRTTU         SAVE ADDRESS IN MCT PRINTER
         ST    R1,MCTPUNTU         SAVE ADDRESS IN MCT PUNCH
         ST    R1,MCTOSRTU         SAVE ADDRESS IN MCT OFF.SR
         ST    R1,MCTOSTTU         SAVE ADDRESS IN MCT OFF.ST
         ST    R1,MCTOJRTU         SAVE ADDRESS IN MCT OFF.JR
         ST    R1,MCTOJTTU         SAVE ADDRESS IN MCT OFF.JT
         LA    R1,WSTAB1           LOAD ADDRESS OF WORK SELECTION ENTRY
         ST    R1,MCTPRWTU         SAVE ADDRESS IN MCT WS PRINTER
         ST    R1,MCTPUWTU         SAVE ADDRESS IN MCT WS PUNCH
         ST    R1,MCTSRWTU         SAVE ADDRESS IN MCT WS OFF.SR
         ST    R1,MCTSTWTU         SAVE ADDRESS IN MCT WS OFF.ST
         ST    R1,MCTJRWTU         SAVE ADDRESS IN MCT WS OFF.JR
         ST    R1,MCTJTWTU         SAVE ADDRESS IN MCT WS OFF.JT
         LA    R1,SCANT2           LOAD ADDRESS OF MAIN SCANTAB ENTRY
         ST    R1,MCTMPSTU         SAVE ADDRESS IN MCT
         LA    R1,SCANT3           LOAD ADDRESS OF SUB  SCANTAB ENTRY
         ST    R1,UCTJITST         SAVE ADDRESS IN UCT
         DROP  R8                  DROP ADDRESSABILITY TO MCT
***********************************************************************
*                                                                     *
*        CREATE NULL TRANSLATE TABLE IN THE UCT.                      *
*                                                                     *
*        SOME OF OUR RJE PRINTERS NEET THE PRINTDEF TRANS=YES         *
*        PARAMETER CODED TO PREVENT GARBAGE FROM BEING SENT TO        *
*        THEM.  EXIT 15 CAN BE USED TO PROVIDE AN ALTERNATE           *
*        TRANSLATE TABLE FOR INDIVIDUAL DEVICE.  THIS TABLE           *
*        WILL TRANSLATE EVERYTHING TO ITSELF AND EFFECTIVELY          *
*        NULLIFY THE ENTIRE PROCESS FOR THAT DEVICE.                  *
*                                                                     *
***********************************************************************
         LA    R15,UCTXLAT         POINT TO TRANSLATE TABLE AREA
         LA    R14,256             SET LOOP COUNTER
         SLR   R1,R1               CLEAR REGISTER
XLATLOOP STC   R1,0(R15)           STORE CHARACTER
         LA    R1,1(R1)            ADD 1 TO COUNTER
         LA    R15,1(R15)          INCREMENT TO NEXT TABLE ENTRY
         BCT   R14,XLATLOOP        LOOP
***********************************************************************
*                        C L E A N    U P                             *
***********************************************************************
EXIT0EN $RETURN RC=0
         EJECT
***********************************************************************
*                                                                     *
*           WORK SELECTION ROUTINE FOR "JTYPE"                        *
*                                                                     *
*        REGISTERS ON ENTRY:                                          *
*                                                                     *
*        R2  - POINTER TO CURRENT CRITERIA                            *
*        R3  - POINTER TO TABLE PAIR                                  *
*        R4  - POINTER TO CURRENT WORK VALUE IN TABLE                 *
*        R5  - WST ADDRESSABILITY                                     *
*        R6  - *** AVAILABLE ***                                      *
*        R7  - COMPARISON LENGTH REGISTER                             *
*        R8  - DEVICE CB ADDRESS                                      *
*        R9  - *** RESERVED ****                                      *
*        R10 - COMPARISON CB ADDRESS                                  *
*        R11 - HCT                                                    *
*        R12 - HASPSERV ADDRESSABILITY                                *
*                                                                     *
*              RETURN FROM WORK SELECTION ROUTINE                     *
*                                                                     *
*        RC = 00 - DO NOT SELECT THIS WORK                            *
*        RC = 04 - YES BUT CONTINUE WITH NEXT CRITERIA                *
*        RC = 08 - SELECT THIS WORK                                   *
*        RC = 12 - NO, UNLESS AFTER SLASH                             *
*                                                                     *
*        IT APPEARS THAT ONLY REGISTERS 1, 6, 7, AND 15 CAN           *
*        BE MODIFIED BY THE WORK SELECTION EXIT ROUTINE               *
*        SINCE THE REGISTERS ARE NOT SAVED PRIOR TO CALLING           *
*        THE ROUTINE.                                                 *
*                                                                     *
***********************************************************************
         PUSH USING                SAVE CURRENT BASE REGISTERS
JTSEL    LR    R6,R15              SET ROUTINE BASE REGISTER
         USING JTSEL,R6            SET ROUTINE ADDRESSABILITY
         USING DCT,R8              SET ADDRESSABILITY TO DCB (DEVCB)
         USING JQE,R10             SET ADDRESSABILITY TO JQE (CB)
         LA    R15,255             SET PRTY
         CLI   DCTUSER0,C' '       SEE IF USER FIELD = ZEROS OR BLANKS
         BNH   JTSELR04            YES, NO CRITERIA, SELECT THIS JOB
         LA    R1,DCTUSER0         POINT TO START OF FIELDS
         LA    R7,4                SET LENGTH OF FIELDS
JTSEL01  CLI   0(R1),C' '          SEE IF END OF JTYPE LIST
         BE    JTSELR12            YES, NO MATCH
         CLI   0(R1),C'P'          SEE IF PRODUCTION REQUESTED
         BE    JTSEL03             YES, BRANCH
         CLI   0(R1),C'T'          SEE IF TEST REQUESTED
         BE    JTSEL02             YES, BRANCH
         BE    JTSEL04             NO, SKIP THIS CATEGORY
JTSEL02  CLI   JQEXFLG1,JQEXPROD   SEE IF PRODUCTION
         BE    JTSEL04             YES, DO NOT SELECT IT YET
         B     JTSEL05             NO, SELECT THIS JOB
JTSEL03  CLI   JQEXFLG1,JQEXPROD   SEE IF PRODUCTION
         BE    JTSEL05             YES, SELECT THIS JOB
JTSEL04  BCTR  R15,0               REDUCE PRIORITY BY 1
         LA    R1,1(R1)            INCREMENT TO NEXT CLASS IN LIST
         BCT   R7,JTSEL01          LOOP FOR NEXT JTYPE IN LIST
         B     JTSELR12            END OF LIST, NO MATCH
JTSEL05  STC   R15,0(R4)           SAVE WORK SELECTION VALUE
         B     JTSELR04            OK TO SELECT THIS JOB
         SPACE 3
***********************************************************************
*                                                                     *
*              RETURN FROM WORK SELECTION ROUTINE                     *
*                                                                     *
*        RC = 00 - DO NOT SELECT THIS WORK                            *
*        RC = 04 - YES BUT CONTINUE WITH NEXT CRITERIA                *
*        RC = 08 - SELECT THIS WORK                                   *
*        RC = 12 - NO, UNLESS AFTER SLASH                             *
*                                                                     *
***********************************************************************
JTSELR00 LA    R15,0               SET RETURN CODE TO ZERO
         B     JTSELEND            GO RETURN TO CALLER
JTSELR04 LA    R15,4               SET RETURN CODE TO FOUR
         B     JTSELEND            GO RETURN TO CALLER
JTSELR08 LA    R15,8               SET RETURN CODE TO EIGHT
         B     JTSELEND            GO RETURN TO CALLER
JTSELR12 LA    R15,12              SET RETURN CODE TO TWELVE
JTSELEND BR    R14                 RETURN TO CALLER WITH RC IN R15
         DROP  R6,R8,R10           DROP BASE REGS FROM ROUTINE
         POP   USING               RESTORE ORIGINAL BASE REGISTERS
         EJECT
***********************************************************************
*                     C O N S T A N T S                               *
***********************************************************************
         LTORG
         SPACE 3
SCANT1   $SCANTAB TABLE=(USER,NOENTRY)
         $SCANTAB NAME=JTYPE,MINLEN=2,CB=PARENT,DSECT=DCT,             X
               FIELD=(DCTUSER0,4),RANGE=(1,8),                         X
               CONV=CHARA
         $SCANTAB TABLE=END
         SPACE 3
SCANT2   $SCANTAB TABLE=(USER,NOENTRY)
         $SCANTAB NAME=JIT,CONV=SUBSCAN,MSGID=900,                     X
               SCANTAB=(UCTJITST,UCT),                                 X
               CALLERS=($SCIRPL,$SCIRPLC,$SCDCMDS)
         $SCANTAB TABLE=END
         SPACE 3
SCANT3   $SCANTAB TABLE=(USER,NOENTRY)
         $SCANTAB NAME=DSNAME,MINLEN=3,CB=UCT,FIELD=UCTJITDS,          X
               CONV=(CHARJANS,.),RANGE=(1,L'UCTJITDS)
         $SCANTAB NAME=START,CB=UCT,FIELD=UCTJITOP,                    X
               CONV=FLAG,VALUE=(,0,FF-UCTJITDR)
         $SCANTAB NAME=STOP,CB=UCT,FIELD=UCTJITOP,                     X
               CONV=FLAG,VALUE=(,UCTJITDR,FF)
         $SCANTAB TABLE=END
         SPACE 3
WSTAB1   $WSTAB TABLE=(USER,NOENTRY)
         $WSTAB NAME=JTYPE,MINLEN=2,RTN=JTSEL,                         X
               CB=JQE,DEVCB=DCT
         $WSTAB TABLE=END
         TITLE 'JES2 $T DEV COMMAND PREPROCESSOR EXIT'
***********************************************************************
*                                                                     *
*        $T DEV EXIT MAIN ENTRY POINT                                 *
*                                                                     *
***********************************************************************
         PUSH USING
E005$TD  $ENTRY BASE=R12           SAVE CALLERS REGS AND GET NEW SAVE
         $SAVE ,                   SAVE CALLER'S REGISTERS
         LR    R12,R15             LOAD BASE REGISTER
         SPACE 3
***********************************************************************
*                                                                     *
*        REGISTER CONTENTS ON ENTRY TO THIS EXIT ROUTINE:             *
*                                                                     *
*        R5       - ADDRESS OF THE CURRENT OPERAND                    *
*        R6       - INCREMENT VALUE OF 4                              *
*        R7       - ADDRESS OF THE LAST OPERAND                       *
*        R11      - ADDRESS OF THE HCT                                *
*        R13      - ADDRESS OF THE HASPCOMM PCE                       *
*        R14      - RETURN ADDRESS                                    *
*        R15      - ENTRY ADDRESS                                     *
*                                                                     *
***********************************************************************
         EJECT
***********************************************************************
*                                                                     *
*        SEE IF $T (SET) COMMAND.  IF NOT, GET OUT                    *
*                                                                     *
***********************************************************************
         CLI   COMVERB,C'T'        SEE IF SET COMMAND
         BNE   $MPXIT              NO, GET OUT
***********************************************************************
*                                                                     *
*        SEE IF A PRINTER OR A PUNCH IS BEING SET.                    *
*                                                                     *
*        THE DEVICE NAME FOR A PRINTER IS PRT..                       *
*        THE DEVICE NAME FOR A PUNCH   IS PUN..                       *
*                                                                     *
*        JES2 COMMANDS ALLOW ALIAS NAMES TO BE USED.  PRINTERS        *
*        CAN USE PRINTR.. AND PRINTER.. WHERE PUNCHES CAN USE         *
*        PUNCH..  THIS CODE HAS TO ALLOW FOR THE ALIAS NAMES.         *
*                                                                     *
***********************************************************************
         $GETBUF TYPE=HASP,WAIT=YES GET A WORK AREA
         LR    R9,R1               SAVE WORK AREA ADDRESS
         USING $TDWORK,R9          SET ADDRESSABILITY TO WORK AREA
         MVC   DEVICE,$BLANKS      BLANK OUT THE DEVICE NAME
         CLC   COMOPRND(7),=C'PRINTER' SEE IF A PRINTER
         BE    $TDCK1A             YES, BRANCH
         CLC   COMOPRND(6),=C'PRINTR' SEE IF A PRINTER
         BE    $TDCK1B             YES, BRANCH
         CLC   COMOPRND(3),=C'PRT' SEE IF A PRINTER
         BE    $TDCK2              YES, BRANCH
         CLC   COMOPRND(5),=C'PUNCH' SEE IF A PUNCH
         BE    $TDCK1              YES, BRANCH
         CLC   COMOPRND(3),=C'PUN' SEE IF A PUNCH
         BE    $TDCK2              YES, BRANCH
         B     $MPXIT00            NO, GET OUT
$TDCK1   MVC   DEVICE(3),=C'PUN'   SET REAL DEVICE NAME
         LA    R2,COMOPRND+5       POINT PAST ALIAS NAME
         B     $TDCK1C             BRANCH
$TDCK1A  MVC   DEVICE(3),=C'PRT'   SET REAL DEVICE NAME
         LA    R2,COMOPRND+7       POINT PAST ALIAS NAME
         B     $TDCK1C             BRANCH
$TDCK1B  MVC   DEVICE(3),=C'PRT'   SET REAL DEVICE NAME
         LA    R2,COMOPRND+6       POINT PAST ALIAS NAME
$TDCK1C  LA    R3,DEVICE+3         POINT PAST REAL DEVICE NAME
         LA    R15,2               SET MAX LOOP COUNTER
$TDCK1D  CLI   0(R2),C','          END OF DEVICE NUMBER
         BE    $TDCK3              YES, BRANCH
         MVC   0(1,R3),0(R2)       SAVE THIS DIGIT OF THE DEVICE NBR
         LA    R2,1(R2)            INCREMENT TO NEXT DIGIT OF INPUT
         LA    R3,1(R3)            INCREMENT TO NEXT DIGIT OF OUTPUT
         BCT   R15,$TDCK1D         LOOP
         CLI   0(R2),C','          SEE IF END OF DEVICE NUMBER
         BNE   $MPXIT00            NO, ERROR, LET JES2 DECIDE IT
         B     $TDCK3              GO PROCESS THE DEVICE NAME
$TDCK2   LA    R2,COMOPRND         LOAD START ADDRESS OF DEVICE NAME
         SLR   R15,R15             SET DEVICE NAME LENGTH TO ZERO
$TDCK2A  CLI   0(R2),C' '          END OF DEVICE NAME
         BNH   $TDCK2B             YES, BRANCH
         CLI   0(R2),C','          END OF DEVICE NAME
         BE    $TDCK2B             YES, BRANCH
         LA    R2,1(R2)            INCR TO NEXT CHAR OF DEVICE NAME
         LA    R15,1(R15)          ADD 1 TO LENGTH
         B     $TDCK2A             LOOP
$TDCK2B  CH    R15,=H'8'           TEST DEVICE NAME LENGTH
         BH    $MPXIT00            GT 8, ERROR, BUT LET JES2 DECIDE IT
         BCTR  R15,0               MAKE MACHINE LENGTH
         EX    R15,MVDEVNM         SAVE DEVICE NAME
         B     $TDCK3              GET OUT
MVDEVNM  MVC   DEVICE(0),COMOPRND  *** EXECUTE ONLY ***
***********************************************************************
*                                                                     *
*                 SEARCH THE DCT CHAIN FOR OUR DEVICE                 *
*                                                                     *
***********************************************************************
$TDCK3   ICM   R8,15,$DCTPOOL      LOAD START ADDRESS OF 1ST DCT POOL
         BZ    $TDCK3B             ZERO, NONE IN POOL, BRANCH
         USING DCT,R8              SET ADDRESSABILITY TO DCT
$TDCK3A  CLC   DCTDEVN,DEVICE      SEE IF THIS IS THE DCT WE WANT
         BE    $TDCK3D             YES, BRANCH
         ICM   R8,15,DCTCHAIN      LOAD NEXT ADDRESS IN CHAIN
         BNZ   $TDCK3A             NOT ZERO, LOOP
$TDCK3B  ICM   R8,15,$DCTPOL2      LOAD START ADDRESS OF 2ND DCT POOL
         BZ    $MPXIT00            ZERO, NO DCT, JUST GET OUT
$TDCK3C  CLC   DCTDEVN,DEVICE      SEE IF THIS IS THE DCT WE WANT
         BE    $TDCK3D             YES, BRANCH
         ICM   R8,15,DCTCHAIN      LOAD NEXT ADDRESS IN CHAIN
         BNZ   $TDCK3C             NOT ZERO, LOOP
         BZ    $MPXIT00            ZERO, JUST GET OUT
         SPACE 3
***********************************************************************
*                                                                     *
*                 SEE IF OUR OPERAND IS PRESENT                       *
*                                                                     *
***********************************************************************
$TDCK3D  LR    R4,R5               SAVE ADDRESS OF FIRST OPERAND
$TDSEAR  BXH   R5,R6,$MPXIT00      GET NEXT OPERAND POINTER UNTIL END
         L     R1,0(R5)            POINT TO ACTUAL OPERAND
         LA    R14,KEYWTBL         POINT TO KEYWORD TABLE
$TDSEAR1 LH    R15,0(R14)          LOAD MACHINE LENGTH OF OUR OPERAND
         EX    R15,KEYCOMP         SEE IF THIS IS OUR OPERAND
         BE    $TDGVAL             YES, BRANCH
         LA    R14,8(R14)          INCREMENT TO NEXT KEYWORD TBL ENTRY
         CLI   0(R14),X'FF'        SEE IF END OF TABLE
         BE    $TDSEAR             YES, GO PROCESS NEXT OPERAND
         B     $TDSEAR1            NO, LOOP FOR NEXT KEYWORD IN TABLE
KEYCOMP  CLC   0(0,R1),2(R14)      *** EXECUTE ONLY ***
         SPACE 3
***********************************************************************
*                                                                     *
*                          KEYWORD TABLE                              *
*                                                                     *
*        EACH ENTRY HAS A HALFWORD MACHINE LENGTH FOLLOWED BY         *
*        THE 1 TO 6 CHARACTER KEYWORD OR ABBREVIATION.  THE           *
*        END OF TABLE IS FLAGGED BY A X'FF' ENTRY                     *
*                                                                     *
***********************************************************************
KEYWTBL  DC    H'2',CL6'JT=   '
         DC    H'3',CL6'JTY=  '
         DC    H'4',CL6'JTYP= '
         DC    H'5',CL6'JTYPE='
         DC    8X'FF'
***********************************************************************
*                                                                     *
*        GET VALUE OF OUR OPERAND                                     *
*                                                                     *
***********************************************************************
$TDGVAL  LA    R2,1(R15,R1)        INCREMENT PAST "JTYPE="
         LR    R1,R2               SAVE START OF VALUE
         SLR   R15,R15             SET LENGTH TO ZERO
$TDGVALA CLI   0(R2),C','          END OF OPERAND
         BE    $TDGVALB            YES, BRANCH
         CLI   0(R2),C' '          END OF OPERAND
         BE    $TDGVALB            YES, BRANCH
         LA    R2,1(R2)            INCREMENT TO NEXT CHAR OF OPERAND
         CH    R15,=H'4'           SEE IF MAX LENGTH EXCEEDED
         BE    $TDERR01            YES, ERROR
         LA    R15,1(R15)          ADD 1 TO LENGTH
         B     $TDGVALA            LOOP
$TDGVALB MVC   VALUE,$BLANKS       BLANK THE RECEIVING FIELD
         LTR   R15,R15             SEE IF LENGTH = ZERO
         BZ    $TDREF              YES, NULL OPERAND, BRANCH
         BCTR  R15,0               MAKE MACHINE LENGTH
         EX    R15,MVOPND          MOVE THE OPERAND TO A SAVE AREA
         B     $TDREF              GO REFORMAT COMMAND BUFFER
MVOPND   MVC   VALUE(0),0(R1)      *** EXECUTE ONLY ***
BLNKOPND MVC   0(0,R1),=CL20' '    *** EXECUTE ONLY ***
***********************************************************************
*                                                                     *
*        REFORMAT THE COMMAND BUFFER TO EXCLUDE OUR KEYWORD           *
*        AND VALUE                                                    *
*                                                                     *
***********************************************************************
***********************************************************************
*        BLANK OUR KEYWORD AND VALUE AREA WITHIN THE BUFFER           *
***********************************************************************
$TDREF   MVC   DCTUSER0(4),VALUE   SET NEW VALUE IN DCT
         DROP  R8                  DROP ADDRESSABILITY TO DCT
         L     R1,0(R5)            GET ADDRESS OF OUR OPERAND
         BCTR  R1,0                BACK UP 1 CHARACTER FOR THE COMMA
         LA    R2,4(R5)            GET NEXT POINTER ADDRESS
         L     R2,0(R2)            GET ADDRESS OF NEXT OPERAND
         BCTR  R2,0                BACK UP 1 CHARACTER FOR THE COMMA
         LR    R3,R2               SAVE ADDRESS OF NEXT OPERAND
         SR    R3,R1               GET LENGTH OF OUR KEYWORD AND VALUE
         BCTR  R3,0                MAKE MACHINE LENGTH
         EX    R3,BLNKOPND         BLANK THE KEYWORD AND VALUE AREA
         LA    R3,COMMAND+L'COMMAND  GET END ADDRESS OF COMMAND BUFFER
***********************************************************************
*        SHIFT THE REST OF THE COMMAND BUFFER TO THE VACATED          *
*        AREA ONE BYTE AT A TIME.                                     *
***********************************************************************
$TDREFA  CR    R2,R3               SEE IF END OF COMMAND BUFFER
         BE    $TDREFB             YES, DONE
         CLI   0(R2),C' '          END OF SEND FIELD
         BE    $TDREFB             YES, DONE
         MVC   0(1,R1),0(R2)       SHIFT 1 CHARACTER
         MVI   0(R2),C' '          BLANK THIS CHARACTER
         LA    R1,1(R1)            INCREMENT TO NEXT CHAR RECEIVE FLD
         LA    R2,1(R2)            INCREMENT TO NEXT CHAR SEND    FLD
         B     $TDREFA             LOOP
         SPACE 3
***********************************************************************
*        ADD A DUMMY WS=(/) PARAMETER TO THE COMMAND LIST.  THE       *
*        EXIT FACILITY DOES NOT ALLOW CHANGING OF REGISTERS AND       *
*        THE LAST OPERAND POINTER ADDRESS IN REGISTER 7 WOULD         *
*        HAVE TO CHANGE TO HAVE FEWER PARAMETERS.  THE ADDITION       *
*        OF THIS DUMMY PARAMETER ELIMINATES THIS PROBLEM.             *
***********************************************************************
$TDREFB  MVC   0(7,R1),=C',WS=(/)' MOVE DUMMY PARM TO END OF STRING
         SPACE 3
***********************************************************************
*        RECALCULATE THE OPERAND ADDRESSES AND BXH REGISTERS          *
***********************************************************************
$TDREFC  XC    COMPNTER(80),COMPNTER CLEAR POINTER LIST
         LA    R1,COMPNTER         POINT TO FIRST POINTER
         LR    R5,R1               SAVE AS FIRST BXH REGISTER
         LR    R7,R1               SET AS LAST BXH REGISTER
         LA    R2,COMOPRND         POINT TO FIRST OPERAND
         ST    R2,0(R1)            SAVE ADDRESS IN POINTER LIST
         LA    R1,4(R1)            POINT TO NEXT ENTRY IN POINTER LIST
$TDREFD  CLI   0(R2),C' '          END OF COMMAND
         BE    $TDREFE             YES, BRANCH
         CLI   0(R2),C','          END OF OPERAND
         BE    $TDREFE             YES, BRANCH
         LA    R2,1(R2)            INCREMENT TO NEXT CHAR OF OPERAND
         B     $TDREFD             LOOP
$TDREFE  LA    R2,1(R2)            POINT PAST ','
         ST    R2,0(R1)            SAVE ADDRESS IN POINTER LIST
         LA    R1,4(R1)            POINT TO NEXT ENTRY IN POINTER LIST
         CLI   0(R2),C' '          END OF COMMAND
         BE    $TDREFF             YES, GET OUT
         LA    R7,4(R7)            INCREMENT END OF POINTER LIST ADDR
         B     $TDREFD             LOOP
$TDREFF  B     $MPXIT00            GET OUT
         EJECT
***********************************************************************
*                                                                     *
*                  E R R O R     R O U T I N E S                      *
*                                                                     *
***********************************************************************
$TDERR01 MVC   COMMAND(L$MPMSG1),$MPMSG1 MOVE MESSAGE TO PCE WORK AREA
         LA    R0,L$MPMSG1         SET MESSAGE LENGTH IN REG 0
         B     $MPXIT16            GO EXIT ROUTINE
         SPACE 3
         EJECT
***********************************************************************
*                                                                     *
*                    E X I T     R O U T I N E S                      *
*                                                                     *
*        RC = 00 - CONTINUE USING ANY ADDITIONAL EXITS                *
*        RC = 04 - CONTINUE WITHOUT USING ANY ADDITIONAL EXITS        *
*        RC = 08 - TERMINATE WITHOUT ANY MESSAGE                      *
*        RC = 12 - TERMINATE ISSUING THE "OK" MESSAGE                 *
*        RC = 16 - TERMINATE USING A USER SUPPLIED MESSAGE            *
*                                                                     *
***********************************************************************
$MPXIT00 $FREEBUF (R9)             FREE OUR WORK AREA
$MPXIT   LA    R15,0               SET RETURN CODE TO 0
         $RETURN RC=(R15)          RETURN TO JES2
$MPXIT16 $STORE R0                 SAVE MESSAGE LENGTH
         $FREEBUF (R9)             FREE OUR WORK AREA
         LA    R15,16              SET RETURN CODE TO 16
         $RETURN RC=(R15)          RETURN TO JES2
         EJECT
***********************************************************************
*                                                                     *
*        CONSTANTS USED BY THIS JES2 EXIT                             *
*                                                                     *
***********************************************************************
$MPMSG1  DC    C'THE VALUE FOR JTYPE= OPERAND EXCEEDS EIGHT CHARACTERS'
L$MPMSG1 EQU   *-$MPMSG1
         SPACE 3
         LTORG
         TITLE 'JES2 JTYPE WTO MESSAGE MODIFICATION EXIT'
***********************************************************************
*                                                                     *
*        E010$DU MAIN ENTRY POINT                                     *
*                                                                     *
***********************************************************************
         PUSH USING
E010$DU  $ENTRY BASE=R12
         SPACE 1
         $SAVE                     SAVE CALLERS REGISTERS
         LR    R12,R15             LOAD BASE REGISTER
         EJECT
***********************************************************************
*                                                                     *
*        REGISTER CONTENTS ON ENTRY TO THIS EXIT ROUTINE:             *
*                                                                     *
*        R1  - ADDRESS OF THE CMB                                     *
*        R11 - ADDRESS OF THE HCT                                     *
*        R13 - ADDRESS OF THE PCE                                     *
*        R14 - RETURN ADDRESS                                         *
*        R15 - ENTRY ADDRESS                                          *
*                                                                     *
***********************************************************************
         LR    R8,R1               SAVE CMB ADDRESS
         USING CMB,R8              SET ADDRESSABILITY TO COMMAND BFR
***********************************************************************
*                                                                     *
*        OFFLOAD DEVICES DO NOT HAVE TO BE HANDLED BY THIS EXIT.      *
*        THE $T AND @DU ROUTINES FOR THOSE DEVICES HANDLES THEM       *
*        FOR US.  THE PRINTERS AND PUNCHES WILL PROBABLY BE           *
*        HANDLED THE SAME WAY IN THE FUTURE, BUT FOR NOW, WE WILL     *
*        HAVE TO DO IT OURSELVES.                                     *
*                                                                     *
***********************************************************************
         CLC   CMBMID+1(4),=C'HASP' SEE IF STANDARD JES2 MESSAGE
         BNE   EXIT10A             NO, GO PROCESS OUT-OF-LINE MESSAGE
         CLC   CMBMID+1(7),=C'HASP628' SEE IF $DU MESSAGE REPLY
         BNE   EXIT10R0            NO, JUST GET OUT
         MVC   PCEUSER0(8),CMBJOBN SAVE DEVICE ID
         B     EXIT10B             GO SEE IF ONE OF OUR DEVICES
EXIT10A  MVC   PCEUSER0(8),CMBMID  SAVE POSSIBLE DEVICE ID
EXIT10B  CLC   PCEUSER0(5),=C'PRINT' SEE IF FOR A PRINTER
         BE    EXIT10C             YES, BRANCH
         CLC   PCEUSER0(3),=C'PRT'   SEE IF FOR A PRINTER
         BE    EXIT10C             YES, BRANCH
         CLC   PCEUSER0(3),=C'PUN' SEE IF FOR A PUNCH
         BE    EXIT10C             YES, BRANCH
         B     EXIT10R0            NO, NOT ONE OF OUR DEVICES
EXIT10C  SLR   R5,R5               CLEAR REG FOR IC
         IC    R5,CMBML            LOAD MESSAGE LENGTH
         CH    R5,=H'50'           SEE IF MESSAGE LENGTH GT 50
         BL    EXIT10R0            NO, MUST BE SHORT FORM OF COMMAND
         ICM   R2,15,$DCTPOOL      LOAD START ADDRESS OF 1ST DCT POOL
         BZ    EXIT10E             ZERO, NONE IN POOL, BRANCH
         USING DCT,R2              SET ADDRESSABILITY TO DCT
EXIT10D  CLC   DCTDEVN,PCEUSER0    SEE IF THIS IS THE DCT WE WANT
         BE    EXIT10G             YES, BRANCH
         ICM   R2,15,DCTCHAIN      LOAD NEXT ADDRESS IN CHAIN
         BZ    EXIT10E             ZERO, BRANCH
         B     EXIT10D             LOOP
EXIT10E  ICM   R2,15,$DCTPOL2      LOAD START ADDRESS OF 2ND DCT POOL
         BZ    EXIT10R0            ZERO, NO DCT, JUST GET OUT
EXIT10F  CLC   DCTDEVN,PCEUSER0    SEE IF THIS IS THE DCT WE WANT
         BE    EXIT10G             YES, BRANCH
         ICM   R2,15,DCTCHAIN      LOAD NEXT ADDRESS IN CHAIN
         BZ    EXIT10R0            ZERO, NO DCT, JUST GET OUT
         B     EXIT10F             LOOP
EXIT10G  LA    R3,CMBMSG           LOAD START ADDRESS OF MESSAGE
         AR    R3,R5               ADD LENGTH OF MESSAGE
         MVC   0(7,R3),=C' JT='    SET FIELD NAME
         LA    R3,4(R3)            INCREMENT PAST FIELD NAME
         MVC   0(4,R3),DCTUSER0    MOVE JTYPE VALUES TO LINE
         MVI   5(R3),C' '          FLAG END OF LIST
         CLI   0(R3),C' '          SEE IF ANY
         BH    EXIT10H             YES, BRANCH
         MVI   0(R3),C','          FLAG END OF LIST
         LA    R3,1(R3)            INCREMENT PAST ','
         B     EXIT10I             BRANCH
EXIT10H  CLI   0(R3),C' '          SEE IF END OF LIST
         BNH   EXIT10I             YES, BRANCH
         LA    R3,1(R3)            INCREMENT TO NEXT ENTRY IN LIST
         B     EXIT10H             LOOP
EXIT10I  LA    R4,CMBMSG           LOAD START ADDRESS OF MESSAGE
         SR    R3,R4               CALCULATE LENGTH OF MESSAGE
         STC   R3,CMBML            SAVE NEW LENGTH OF MESSAGE
         EJECT
***********************************************************************
*                                                                     *
*                    E X I T     R O U T I N E S                      *
*                                                                     *
*        RC = 00 - CONTINUE USING ANY ADDITIONAL EXITS                *
*        RC = 04 - CONTINUE WITHOUT USING ANY ADDITIONAL EXITS        *
*        RC = 08 - DISCARD THE MESSAGE                                *
*                                                                     *
***********************************************************************
EXIT10R0 LA    R15,0               SET RETURN CODE TO 0
         $RETURN RC=(R15)          RETURN TO JES2
EXIT10R4 LA    R15,4               SET RETURN CODE TO 4
         $RETURN RC=(R15)          RETURN TO JES2
EXIT10R8 LA    R15,8               SET RETURN CODE TO 8
         $RETURN RC=(R15)          RETURN TO JES2
         EJECT
         $MODEND
         END
