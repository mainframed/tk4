  Exemples de programmes assembleurs extraits
  du livre "Le syst}me MVS", T.Falissard, EYROLLES

1) Exemple 1 : programme utilisant le cross-memory
2) Exemple 2 : programme utilisant l'interface sous-syst}me
3) Exemple 3 : programme avec SCHEDULE de SRB
4) Exemple 4 : programme effectuant des EXCPs
5) Exemple 5 : programme invoquant la m{thode d'acc}s BSAM pour un PDS
6) Exemple 6 : programme cr{ant un dataspace ESA


* BUT DU PROGRAMME : AFFICHER LA DERNIERE COMMANDE ENTREE A LA CONSOLE
* PAR LE PUPITREUR ; IL FAUT POUR CELA CHERCHER L'INFORMATION DANS
* L'ESPACE-ADRESSE MVS "CONSOLE" PAR CROSS-MEMORY
*     (RDCM ET TDCM SONT DANS LA LSQA DE L'ESPACE-ADRESSE 'CONSOLE')
* CVT -> UCM BASE -> UCM PREFIX -> UCME MASTER CONSOLE -> RDCM -> TDCM
EXEMPLE1 CSECT
         SAVE (14,12),,EXEMPLE1-&SYSDATE-&SYSTIME
         LR   R12,R15          R12 = R15 = ADRESSE POINT ENTREE
         USING EXEMPLE1,R12    R12 EST LE REGISTRE DE BASE DE LA CSECT
         LR   R9,R13           SAUVEGARDER LE R13 INITIAL
         LA   R13,SAVE         MAINTENANT R13 POINTE SUR NOTRE SAVE
         ST   R13,8(R9)        ADRESSE DE NOTRE SAVE MISE CHEZ APPELANT
         ST   R9,4(R13)        ADRESSE SAVE APPELANT MISE CHEZ NOUS
* ACCES @ LA CVT
         L    R1,CVTPTR         PRENDRE L'ADRESSE DE LA CVT
         USING CVT,R1           ADRESSER LA CVT
         L    R1,CVTCUCB        POINTER VERS UCM BASE
* ACCES @ L'UCM BASE
         DROP R1                R1 N'EST PLUS UTILISE POUR L'ADRESSAGE
         USING UCM,R1           ADRESSER UCM BASE
         LH   R2,UCMCTID        PRENDRE ASID ADDRESS-SPACE CONSOLE
         ST   R2,ASIDF          LE STOCKER CHEZ NOUS
         DROP R1                R1 N'EST PLUS UTILISE POUR L'ADRESSAGE
* ACCES @ L'UCM PREFIX
         SH   R1,=H'4'          RECULER DE 4 OCTETS
         L    R1,0(R1)          POUR PRENDRE ADRESSE UCM MCS PREFIX
         L    R1,0(R1)          PRENDRE ADRESSE UCM MASTERCONS UCMMCENT
* ACCES @ L'UCME DE LA MASTER (UCM INDIVIDUAL DEVICE ENTRY MAP)
         USING UCMECB,R1        ADRESSER L'UCME
         L    R4,UCMXB          PRENDRE ADRESSE DU RDCM
         DROP R1                R1 N'EST PLUS UTILISE POUR L'ADRESSAGE
* ACCES AU RDCM QUI EST DANS L'A.S. "CONSOLE"
         MODESET KEY=ZERO,MODE=SUP   PASSER EN MODE SUPERVISEUR CLE 0
         ESAR R2                OBTENIR L'ASID DE NOTRE ESPACE-ADRESSE
         ST   R2,NOTRASID       LE SAUVER
         LA   R2,1              AUTORISATION INDEX DE 1 (TOUT PERMIS)
         AXSET AX=(2)           AUTORISER NOTRE ESPACE-ADRESSE
         L    R2,ASIDF          PRENDRE L'ASID DE L'ESPACE-ADRESSE VIS{
         SSAR R2                L'ETABLIR COMME ESPACE-ADR. SECONDAIRE
* ACCES AUX DONNEES DE L'AUTRE ESPACE-ADRESSE
         XR   R2,R2             R2 = 0
         LA   R2,4              4 OCTETS A MOUVEMENTER
         XR   R1,R1             R1 = 0
         MVCP ADDR1(R2),0(R4),R1    PRENDRE ADRESSE DU TDCM
* ACCES AU TDCM DANS L'A.S. CONSOLE
         L    R5,ADDR1          ADRESSE TDCM DANS A.S. CONSOLE
         LA   R2,128            LONGUEUR DE LA COMMANDE
         XR   R1,R1             R1 = 0
         MVCP LASTCMD(R2),640(R5),R1    COPIER  DERNIERE COMMANDE
* SORTIR DU MODE CROSS-MEMORY
         L    R2,NOTRASID       PRENDRE ASID DE NOTRE ESPACE-ADRESSE
         SSAR R2
         XR   R2,R2             R2 = 0
         AXSET AX=(2)
         MODESET KEY=NZERO,MODE=PROB      REPASSER EN MODE PROBLEME
* AFFICHER LES 30 PREMIERS CARACTERES
         MVC  WTO1+8(30),LASTCMD  INDIQUER LA ZONE A AFFICHER
WTO1     WTO  '                                        ',ROUTCDE=11
FIN      L       R13,4(R13)     REPRENDRE ADRESSE SAVE DE L'APPELANT
         RETURN  (14,12),T,RC=0
SAVE     DS   18F    18 MOTS DE SAVE AREA
NOTRASID DC   F'0'   NUMERO DE NOTRE ESPACE-ADRESSE
ASIDF    DC   F'0'   NUMERO D'ESPACE-ADRESSE VISE
ADDR1    DC   F'0'   ADRESSE TDCM
LASTCMD  DS   CL128  DERNIERE COMMANDE PASSEE PAR LE PUPITREUR
         CVT   DSECT=YES
         IEECUCM
         IEECDCM
         END


*
* EXEMPLE D'APPEL DE L'INTERFACE SOUS-SYSTEME
* LISTER TOUS LES JOBS COMMENCANT PAR LE NOM D'UN USER
*
         IEFJESCT
         CVT  DSECT=YES
EXEMPLE2 CSECT
         SAVE (14,12),,EXEMPLE2-&SYSDATE-&SYSTIME
         LR   R12,R15          R12 = R15 = ADRESSE POINT ENTREE
         USING EXEMPLE2,R12    R12 EST LE REGISTRE DE BASE DE LA CSECT
         LR   R9,R13           SAUVEGARDER LE R13 INITIAL
         LA   R13,SAVE         MAINTENANT R13 POINTE SUR NOTRE SAVE
         ST   R13,8(R9)        ADRESSE DE NOTRE SAVE MISE CHEZ APPELANT
         ST   R9,4(R13)        ADRESSE SAVE APPELANT MISE CHEZ NOUS
* PRENDRE LE PARAMETRE PASSE AU PROGRAMME : EXEC PGM=EXEMPLE2,PARM=ZZZZ
         L    R1,0(R1)
         LH   R2,0(R1)         PRENDRE LA LONGUEUR DU PARAMETRE
         BCTR R2,0             R2 - 1 POUR INSTRUCTION EXECUTE (MOVE)
         EX   R2,MOVE          FAIRE UN MOVE DE LONGUEUR VARIABLE
*
         MODESET MODE=SUP,KEY=ZERO
         LA    R1,PARAM        ADRESSER LE PARAMETRE
         OI    PARAM,X'80'     SIGNER L'ADRESSE
         IEFSSREQ              APPEL DU SSI
         ST    R15,RETCODE     STOCKER LE CODE RETOUR
         MODESET MODE=PROB,KEY=NZERO
*
         L       R13,4(R13)
         RETURN  (14,12),T,RC=0
*
MOVE     MVC  SSCSJOBN(1),2(R1)   MOVE USERID INDIQUE EN PARAMETRE
RETCODE  DC  F'0'
PARAM    DC  A(SSOB)
*
SSOB     DS  0F
SSOBID   DC  C'SSOB'   IDENTIFIEUR DU BLOC DE CONTROLE SSOB
SSOBLEN  DC  H'20'     LONGUEUR DU SSOB
SSOBFUNC DC  H'3'      FONCTION DEMANDEE : STATUS
SSOBSSIB DC  F'0'      ADRESSE DE SSIB = 0
SSOBRETN DC  F'0'      CODE RETOUR SOUS-SYSTEME
* RC=4  JOBNAME NOT FOUND     RC=8   INVALID JOBNAME/JOBID COMBINAISON
* RC=12 JOB NOT CANCELLED     RC=16  ARRAY TOO SMALL
SSOBINDV DC  A(SSCS)   ADRESSE EXTENSION
         DC  D'0'      2 MOTS DE TRAVAIL SSI
*
SSCS     DS  0F        EXTENSION DU SSOB POUR FONCTION CANCEL/STATUS
SSCSLEN  DC  H'184'    LONGUEUR DU SSCS
SSCSFLGS DC  X'80'     FLAG : USERID IS IN JOBNAME FIELD
SSCSULEN DC  X'07'     LONGUEUR DU USERID
SSCSJOBN DC  CL8' '    JOBNAME
SSCSJOBI DC  CL8' '    JOBID
SSCSDIMP DC  H'160'    TAILLE DE TABLE MISE A DISPOSITION DU SSI
SSCSDIMR DC  H'0'      POSITIONNE PAR SSI POUR DIRE SI TAILLE SUFFIT
SSCSARAY DS  0CL160    16*10
ARAY1    DS  CL80
ARAY2    DS  CL80
SAVE     DS  18F
         LTORG
         END




* CE PGM REND UN ESP.-ADR. NON SWAPPABLE (SCHEDULE DE SRB, APPEL A SRM)
         CVT   DSECT=YES
         IHASRB
EXEMPLE3 CSECT
         SAVE (14,12),,EXEMPLE3-&SYSDATE-&SYSTIME
         LR   R12,R15          R12 = R15 = ADRESSE POINT ENTREE
         USING EXEMPLE3,R12    R12 EST LE REGISTRE DE BASE DE LA CSECT
         LR   R9,R13           SAUVEGARDER LE R13 INITIAL
         LA   R13,SAVE         MAINTENANT R13 POINTE SUR NOTRE SAVE
         ST   R13,8(R9)        ADRESSE DE NOTRE SAVE MISE CHEZ APPELANT
         ST   R9,4(R13)        ADRESSE SAVE APPELANT MISE CHEZ NOUS
* LE PROGRAMME  RECOIT DANS R1 LE NUMERO D'ASID DE L'ESPACE-ADRESSE
         ST   R1,THEASCB       STOCKER L'ASID NUMBER
         USING SRBSECT,R5      ADRESSER LE SRB, COMMENCER A LE PREPARER
         LA   R5,MYSRB
         XC   MYSRB,MYSRB      MISE DU SRB A ZERO BINAIRE
         MVC  SRBID,=CL4'SRB'  ACRONYME
         MVC  SRBASCB,THEASCB  ASCB DE L'A.S. VISE POUR EXEC SRB
* ACQUISITION UNE PAGE EN SQA  (POUR SRB ET ROUTINE SRB)
         MODESET MODE=SUP,KEY=ZERO         PASSAGE MODE SUPERVISEUR
         GETMAIN  RC,LV=4096,BNDRY=PAGE,SP=226   GETMAIN EN SQA
         LR   R8,R1            ADRESSE DE LA ZONE EN SQA
         ST   R8,ADDSRB        LA SAUVEGARDER
         LA   R1,(ENTREE-PAGE) LONGUEUR DU SRB
         AR   R1,R8            ADRESSE ROUTINE SRB
         ST   R1,SRBEP         ENTRY POINT
         NI   SRBEP,B'01111111'   1ER BIT FORCE A ZERO (AMODE 24)
* MOVE DU SRB ET DE LA ROUTINE SRB EN SQA
         L    R9,=F'4096'      LONGUEUR DE ZONE A MOUVEMENTER
         LR   R11,R9           EGALE LONGUEUR ZONE EMETTRICE
         LA   R10,PAGE         ADRESSE ZONE ORIGINE
         MVCL R8,R10           'MOVE CHARACTERS' LONG : MOVE CODE + SRB
         L    R8,ADDSRB        RESTAURER R8
* ENVOI DU SRB AU DISPATCHER
         SCHEDULE SRB=(8),SCOPE=GLOBAL,LLOCK=YES,FRR=NO
         MODESET MODE=PROB,KEY=NZERO       RETOUR MODE PROBLEME
FIN      L       R13,4(R13)
         RETURN  (14,12),T,RC=0
ADDSRB   DS   F                ADRESSE DU SRB EN SQA
THEASCB  DS   F                ASCB DE L'A.S. A METTRE NON SWAPPABLE
PAGE     DS   CL4096           DEFINIR L'IMAGE SRB + ROUTINE SUR 1 PAGE
         ORG  PAGE
MYSRB    DS   CL(SRBSIZE)      ********   S  R  B   *******
ENTREE   DS   0F               ** R O U T I N E    S R B **
* A L'ENTREE DANS LA ROUTINE SRB, LES REGISTRES SONT UTILISES AINSI :
* R0 = ADRESSE DU SRB, R1 = USER DATA, R14 = RETURN ADD, R15 = ENTREE
         USING ENTREE,R7       R7 REGISTRE DE BASE
         LR   R6,R0            SAUVER R0
         LR   R7,R15           SAUVER ADRESSE D'ENTREE DE LA ROUTINE
         LR   R8,R14           SAUVER ADRESSE DE RETOUR
         XR   R0,R0            R0 = 0
         ICM  R0,3,CODE        CODE POUR LE SYSEVENT DE TRANSWAP
         XR   R1,R1            R1 = 0  (PAS DE ECB)
         L    R15,CVTPTR       ADRESSE DE LA CVT
         L    R15,CVTOPTE-CVT(,R15)   SRM ENTRY
* APPEL SRM
         LA   R13,SAVEAREA     SAVE AREA DE 72 OCTETS POUR SYSEVENT
         BALR R14,R15          ON INVOQUE L'INTERFACE SRM
         FREEMAIN R,LV=4096,A=(6),BRANCH=YES,SP=226  LIBERER MEMOIRE
         BR   R8               RETOUR APPELANT
SAVEAREA DS   18F              SAVE AREA POUR SRM
CODE     DC   X'000E'          TRANSWAP SYSEVENT
LONGROUT EQU  *-ENTREE         LONGUEUR DE LA ROUTINE SRB
         ORG
         LTORG
         END



*  CE PROGRAMME LIT UN BLOC D'UN FICHIER BANDE (EXCP)
EXEMPLE4 CSECT
         SAVE (14,12),,EXEMPLE4-&SYSDATE-&SYSTIME
         LR   R12,R15          R12 = R15 = ADRESSE POINT ENTREE
         USING EXEMPLE4,R12    R12 EST LE REGISTRE DE BASE DE LA CSECT
         LR   R9,R13           SAUVEGARDER LE R13 INITIAL
         LA   R13,SAVE         MAINTENANT R13 POINTE SUR NOTRE SAVE
         ST   R13,8(R9)        ADRESSE DE NOTRE SAVE MISE CHEZ APPELANT
         ST   R9,4(R13)        ADRESSE SAVE APPELANT MISE CHEZ NOUS
* OBTENIR UNE ZONE MEMOIRE DE LONGUEUR = BLKSIZE (AU MOINS)
         LH   R3,MAXCNT        NOMBRE D'OCTETS A OBTENIR
         GETMAIN  RU,LV=(3)    NB: ON NE FERA PAS DE FREEMAIN
         LR   R5,R1            PRENDRE ADRESSE DE LA ZONE OBTENUE
         ST   R5,CCW1          DATA ADDRESS
         MVI  CCW1,X'02'       COMMAND CODE : LECTURE
         OPEN (TAPEIN,(INPUT)) OUVRIR LE FICHIER
         MVC  CCW1CNT,MAXCNT   MAXIMUM A TRANSFERER
         EXCP IOB1             DECLENCHER L'EXCP
         WAIT ECB=ECB          ATTENDRE LA FIN DE L'OPERATION
         TM   ECB,X'7F'        TESTER SI IO-ERROR
         BO   NOERROR          PAS D'ERREUR, ON CONTINUE
         ABEND 99,DUMP         SI ERREUR, ON FAIT ABEND
NOERROR  DS   0H
         CLOSE (TAPEIN)
* NOMBRE D'OCTETS TRANSFERES = X'7FFF' MOINS LE "RESIDUAL COUNT"
         LH   R15,MAXCNT       R15 = X'7FFF'
         LH   R2,IOBCSWBC      R2 = RESIDUAL BYTE COUNT DU CSW
         SR   R15,R2           MAX - RESIDUAL BYTE COUNT DU CSW
RET      L    R13,4(R13)
         RETURN  (14,12),T,RC=(15)   CODE RETOUR DANS LE REGISTRE 15
*
TAPEIN   DCB  MACRF=(E),DDNAME=TAPEIN,DSORG=PS
ECB      DC   F'0'
BIDON    DS   0D
CCW1     CCW  X'02',BIDON,X'20',80   LECTURE BANDE/ZONE POINTEE PAR R5
         ORG  CCW1             ** CCW DE FORMAT 0 **
CCW1CMD  DS   CL1              CCW - COMMAND CODE
CCW1ADDR DS   CL3              CCW - DATA ADDRESS
CCW1FLAG DS   CL1              CCW - FLAGS
CCW1RES  DS   CL1              CCW - INUTILISE
CCW1CNT  DS   H                CCW - BYTE COUNT
         ORG
         CNOP 0,4
IOB1     DS   0CL32            ** IOB **
IOBFLAG1 DS   CL1
IOBFLAG2 DS   CL1
IOBSENS0 DS   CL1
IOBSENS1 DS   CL1
IOBECB   DC   A(ECB)           ADRESSE DE L'ECB
IOBFLAG3 DS   CL1
IOBCSW   DS   0CL7             CHANNEL STATUS WORD (7 DERNIERS OCTETS)
         DS   CL5
IOBCSWBC DS   CL2              CSW : RESIDUAL BYTE COUNT
IOBSTART DC   A(CCW1)          ADRESSE DU CCW
IOBDCB   DC   A(TAPEIN)        ADRESSE DU DCB
         DS   CL12             LE RESTE DE L'IOB
MAXCNT   DC   H'32767'         MAXIMUM BLOCKSIZE POSSIBLE SUR 2 OCTETS
SAVE     DS   18F
         LTORG
         END



* CE PROGRAMME LIT UN FICHIER PARTITIONNE MEMBRE PAR MEMBRE
* IL AFFICHE (SOUS TSO) LE NOM DU MEMBRE, LA LONGUEUR
* ET LES PREMIERS OCTETS DE CHAQUE BLOC DE MEMBRE
* LE PDS DOIT ETRE ALLOUE EN SYSLIB
EXEMPLE5 CSECT
         SAVE (14,12),,EXEMPLE5-&SYSDATE-&SYSTIME
         LR    R12,R15          R12 = R15 = ADRESSE POINT ENTREE
         USING EXEMPLE5,R12     R12 EST LE REGISTRE DE BASE DE LA CSECT
         LR    R9,R13           SAUVEGARDER LE R13 INITIAL
         LA    R13,SAVE         MAINTENANT R13 POINTE SUR NOTRE SAVE
         ST    R13,8(R9)        ADRESSE NOTRE SAVE MISE CHEZ APPELANT
         ST    R9,4(R13)        ADRESSE SAVE APPELANT MISE CHEZ NOUS
         USING IHADCB,R5
         LA    R5,SYSLIB        DCB DU PDS
         OPEN  (SYSLIB,,LIB)    OUVRIR LES FICHIERS
* OBTENIR DYNAMIQUEMENT UNE ZONE DE MEMOIRE (POUR UN BLOC D'UN MEMBRE)
         L     R6,LONG
         GETMAIN RU,LV=(6)      DEMANDE DE MEMOIRE
         ST    R1,BUFAD         STOCKER ADRESSE DE LA ZONE OBTENUE
NEXTMBR  DS    0H
         XC    TTRN,TTRN
         CLC   LONGBLK,OFFSET   COMPARER TOTAL AVEC COMPTEUR
         BH    TRAITER          BLOC DE DIRECTORY DEJA LU, L'EXPLOITER
* LIRE UN BLOC DE DIRECTORY
         GET   LIB,DIRZONE      LECTURE
         LA    R1,DIRZONE       POINTER DEBUT ZONE
         MVC   LONGBLK,0(1)     MOVE LONGUEUR TOTALE UTILE DU BLOC
         MVC   OFFSET,=H'2'     OFFSET = 2 OCTETS A CAUSE COUNT
* EXPLOITER UNE ENTREE DU BLOC DE DIRECTORY
TRAITER  DS    0H               EXPLOITATION BLOC DE DIRECTORY
         LA    R1,DIRZONE       POINTER DEBUT ZONE
         LH    R0,OFFSET        CHARGER COMPTEUR
         AR    R1,R0            ACCEDER MEMBRE SUIVANT
         MVC   MBRNAME(8),0(R1) ** NOM DU MEMBRE **
         MVC   TTRN(3),8(R1)    ** TTR DU MEMBRE **
         XR    R0,R0            REG 0 = 0
         IC    R0,11(R1)        CHARGER LONGUEUR USER DATA EN 1/2 MOTS
         N     R0,=X'0000001F'  GARDER LES 5 DERNIERS BITS
         SLL   R0,1             R0*2 = NOMBRE D'OCTETS DE USER DATA
         LR    R1,R0            LONGUEUR DES USER DATA
         LA    R1,12(0,R1)      +12 OCTETS : NAME, TTR, LONGUEUR UDATA
         LH    R0,OFFSET        CHARGER COMPTEUR ANCIEN
         AR    R1,R0            AJOUTER OFFSET
         STH   R1,OFFSET        STOCKER COMPTEUR NOUVEAU
         CLC   FF,MBRNAME
         BE    CLOSE
         POINT SYSLIB,TTRN         POSITIONNEMENT SUR LE MEMBRE
         L     R6,BUFAD            CHARGER ADRESSE BUFFER PREVU
* LIRE UN BLOC DU MEMBRE : R6 POINTE SUR LE BLOC
NEXTBLK  READ  DECB1,SF,SYSLIB,(6),'S'   LIRE UN BLOC
         CHECK DECB1               ATTENDRE LA FIN DE L'E/S
         LH    R1,DCBBLKSI         BLOCKSIZE
         L     R2,DECB1+16         IOB ADDRESS
         SH    R1,14(R2)           BLKSIZE-RESIDUAL COUNT=LONGUEUR
         ST    R1,LONGBLOC         LONGUEUR UTILE DE CE BLOC
         CVD   R1,DBLEWORD         CONVERTIR LONGUEUR EN PACKE
         UNPK  LONGBL,DBLEWORD     PUIS EN DECIMAL ZONE
         OI    LONGBL+L'LONGBL-1,X'F0'    NORMALISER LE SIGNE
         MVC   DEBUTBL,0(R6)       COPIER LE DEBUT DU BLOC POUR INFO
         TPUT  MESSAGE,L'MESSAGE   AFFICHER A L'ECRAN TSO LES INFOS
         B     NEXTBLK             LIRE LE BLOC SUIVANT
FINMEMBR DS    0H
         B     NEXTMBR             PASSER AU MEMBRE SUIVANT
CLOSE    DS    0H
         CLOSE (SYSLIB)
         CLOSE (LIB)
FIN      L     R13,4(R13)
         RETURN  (14,12),T,RC=0
DBLEWORD DS    D
SAVE     DS    18F
TTRN     DS    CL4
LONG     DC    F'32767'         LONGUEUR MAXIMALE D'UN BLOC DE FICHIER
LONGBLOC DC    F'0'             LONGUEUR UTILE DU BLOC DE MEMBRE
BUFAD    DC    F'0'
OFFSET   DC    H'99'            OFFSET MBR DEPUIS DEBUT BLOC DIRECTORY
LONGBLK  DC    H'0'             LONGUEUR DU BLOC DE DIRECTORY (BINAIRE)
DIRZONE  DS    CL256            ZONE IO BLOC DIRECTORY
LIB      DCB   DDNAME=SYSLIB,MACRF=GM,BLKSIZE=256,                     X
               RECFM=F,DSORG=PS,LRECL=256
SYSLIB   DCB   DDNAME=SYSLIB,MACRF=R,DSORG=PO,EODAD=FINMEMBR
FF       DC    X'FFFFFFFFFFFFFFFF'  MARQUE DE FIN DE DIRECTORY
*
MESSAGE  DS    0CL70
         DC    C'MEMBRE '
MBRNAME  DS    CL8              NOM DU MEMBRE
         DC    C'  BLOC DE LONGUEUR '
LONGBL   DC    CL5' '           LONGUEUR DU BLOC DE MEMBRE
         DC    C' '             BLANC SEPARATEUR
DEBUTBL  DC    CL(70-*+MESSAGE)' '   DEBUT DONNEES DU BLOC
*
         LTORG
         DCBD  DSORG=PS
         END




* CE PROGRAMME CREE UN DATASPACE ESA, Y ACCEDE, PUIS LE DETRUIT
EXEMPLE6 CSECT
EXEMPLE6 AMODE 31
EXEMPLE6 RMODE ANY
         SAVE (14,12),,EXEMPLE6-&SYSDATE-&SYSTIME
         LR   R12,R15          R12 = R15 = ADRESSE POINT ENTREE
         USING EXEMPLE6,R12    R12 EST LE REGISTRE DE BASE DE LA CSECT
         LR   R9,R13           SAUVEGARDER LE R13 INITIAL
         LA   R13,SAVE         MAINTENANT R13 POINTE SUR NOTRE SAVE
         ST   R13,8(R9)        ADRESSE DE NOTRE SAVE MISE CHEZ APPELANT
         ST   R9,4(R13)        ADRESSE SAVE APPELANT MISE CHEZ NOUS
* CREER UN DATA SPACE
         DSPSERV   CREATE,         CREATION D'UN DATASPACE             *
               NAME=NOM,           NOM DU DATASPACE                    *
               BLOCKS=TAILLE,      TAILLE EN NOMBRE DE BLOCS           *
               ORIGIN=ORIGINE,     OU COMMENCE-T-IL (A RETOURNER)      *
               SCOPE=SINGLE,       DATASPACE A USAGE PRIVE             *
               STOKEN=JETON        JETON POUR Y ACCEDER (A RETOURNER)
         LTR  R15,R15          CREATION EFFECTUEE ?
         BNZ  FIN
         WTO  'DSPSERV CREATE SUCCESSFUL',ROUTCDE=11
* RENDRE ACCESSIBLE LE DATASPACE PAR MISE A JOUR DE NOTRE ACCESS-LIST
         ALESERV   ADD,            AJOUTER UNE ENTREE EN ACCESS-LIST   *
               ALET=ALET,          ALET (A RETOURNER)                  *
               STOKEN=JETON        JETON DE L'ESPACE-ADRESSE
         LTR  R15,R15
         BNZ  FIN
         WTO  'ALESERV ADD SUCCESSFUL',ROUTCDE=11
* PASSAGE A L'"ACCESS MODE REGISTER" POUR ACCES AU DATASPACE (VIA R4)
         SAC  512               PASSAGE A L'AR MODE
         LAM  R4,R4,ALET        CHARGER L'ACCESS-REGISTER 4
         L    R4,ORIGINE        DEBUT DU DATA-SPACE
         L    R5,TAILLE         TAILLE EN BLOCS DE 4K
         SLL  R5,12             X (2 PUISSANCE 12) C'EST-A-DIRE X 4096
         XR   R0,R0             PAS DE DONNEES ORIGINE
         XR   R1,R1             PAS DE DONNEES ORIGINE
         MVCL R4,R0             REMISE A ZERO DE TOUT LE DATA-SPACE
* ACCEDER AU DATASPACE (LES 500 PREMIERES PAGES)
         LA   R9,500
LOOP     OC   0(8,R4),0(R4)     DONNEES INCHANGEES
         LA   R4,4095(0,R4)     PAGE SUIVANTE
         LA   R4,1(0,R4)
         BCT  R9,LOOP
* SORTIE DE L'"ACCESS MODE REGISTER"
         SAC  0                 RETOUR AU PRIMARY MODE
* SUPPRIMER LES DONNEES QUE CONTIENT LE DATASPACE (= MVCL)
         DSPSERV   RELEASE,                                            *
               BLOCKS=TAILLE,                                          *
               STOKEN=JETON,                                           *
               START=ORIGINE
* SUPPRIMER LE DATASPACE
         DSPSERV   DELETE,                                             *
               STOKEN=JETON
         XR   R15,R15
*
FIN      L       R13,4(R13)
         RETURN  (14,12),T,RC=(15)
SAVE     DS   18F               SAVE AREA
NOM      DC   CL8'TSTDATSP'     NOM DU DATA-SPACE
TAILLE   DC   F'400000'         TAILLE = 400000 BLOCS DE 4K = 1600M
ALET     DC   F'0'
* ZONES RENVOYEES PAR DSPSERV (ADD) :
ORIGINE  DC   F'0'
JETON    DS   CL8
         END
