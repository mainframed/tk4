BROW     TITLE '--- E T P S -- ETPSBROW - DATA-SET BROWSE ---'
         PRINT OFF
         COPY  ETPS$O1             "ETPS" SYSPARM SELECTION
         COPY  ETPSMACS            "ETPS" MACROS
         COPY  ETPSDEFS            "ETPS" DEFINITIONS
         PRINT ON
ETPSBROW START 0
         SPACE 1
ETPSBROW AMODE 24
ETPSBROW RMODE 24
        MIDENT
         EJECT
*------- AT ENTRY, R1 = A(PARM.LIST) -> (DCB,
*                                        DS-NAME,
*                                        MEMBER-NAME)
         SPACE 1
         PRINT GEN
         USING *,R12,R11
         USING SAVE3,R13      ************************** R13 ==> SAVE3
         USING SPLTAREA,R10   AT ENTRY : R10 MUST POINT TO "SPLTAREA"
         B     32(,R15)
         DC    CL28'  ETPSBROW &SYSDATE &SYSTIME'
         PRINT &PRF
         STM   R14,R12,12(R13)     SAVE INPUT REGISTERS
         LR    R12,R15             SET PROGRAM BASE REGISTER 1
         LA    R3,1
         LA    R11,4*KB-1(R3,R12)  SET PROGRAM BASE REGISTER 2
         LR    R3,R10              SPLIT-SCREEN DSECT
         SH    R3,=Y(SPLITWRK-SAVE3) POINT TO SAVE3
         ST    R13,4(,R3)          STORE BACKWARD POINTER
         ST    R3,8(R13)           STORE FORWARD POINTER
         LR    R13,R3              SET DSECT BASE
         LM    R2,R4,0(R1)         PICK UP ALL PARMS
*                                  R2=DCB ADDRESS
*                                  R3=DS-NAME ADDRESS
*                                  R4=MEMBER-NAME ADDRESS
         XR    R14,R14
         CLI   0(R3),C' '          IS THERE A DSNAME?
         BE    BBHLT1              NO
         LA    R14,44              YES, FIND LENGTH
         LA    R1,43(R3)
         CLI   0(R1),C' '
         BNE   *+L'*+6
         BCTR  R1,0
         BCT   R14,*-10
BBHLT1   XR    R15,R15
         CLI   0(R4),C' '          IS THERE A MEMBER NAME?
         BE    BBHLT2              NO
         LA    R15,8               YES, FIND LENGTH
         LA    R1,7(R4)
         CLI   0(R1),C' '
         BNE   *+L'*+6
         BCTR  R1,0
         BCT   R15,*-10
BBHLT2   LA    R1,BRHDLN           BUILD BROWSE HEAD LINE TEXT
         LTR   R14,R14
         BZ    BBHLT3
         BCT   R14,*+L'*+6
         MVC   0(*-*,R1),0(R3)     <<EXECUTED>>
         EX    R14,*-6
         LA    R1,1(R1,R14)
BBHLT3   LTR   R15,R15
         BZ    BBHLT4
         MVI   0(R1),C'('
         BCT   R15,*+L'*+6
         MVC   1(*-*,R1),0(R4)     <<EXECUTED>>
         EX    R15,*-6
         LA    R1,2(R1,R15)
         MVI   0(R1),C')'
         LA    R1,1(R1)
BBHLT4   LA    R0,BRHDLN+L'BRHDLN-1
         CLR   R1,R0
         BH    *+L'*+12
         MVI   0(R1),C'-'
         LA    R1,1(R1)
         B     *-14
         MVI   BRSTSW,0
         MVI   BRFSSW,0
         MVI   BRFUSW,0
*- - - - DO INITIALIZATION
         LR    R4,R2               SET UP THE DCB
         USING IHADCB,R4
         LM    R0,R1,DCBDDNAM      SAVE DDNAME
         MVC   0(BRODCBL,R4),BRODCB
         STM   R0,R1,DCBDDNAM      SET DDNAME
         LA    R15,DYNEOD
         STCM  R15,B'0111',DCBEODA
         LA    R15,DYNSYNAD
         STCM  R15,B'0111',DCBSYNA
         LA    R15,DYNEXLST
         STCM  R15,B'0111',DCBEXLSA
         LA    R1,DYNDCBEX
         ST    R1,0(,R15)
         MVI   0(R15),X'05'
         LA    R1,DYNABEND
         ST    R1,4(,R15)
         MVI   4(R15),X'91'        OPEN ABEND EXIT (MVS)
         OI    BRSTSW,STOPEN       TELL CLEANUP TO CLOSE DCB
         MVI   OPCLPL,VLB          SET "VL" BIT
        OPEN   ((R4),INPUT),MF=(E,OPCLPL)
         TM    DCBOFLGS,DCBOFOPN
         BO    OKOPEN
         LA    R1,MSG11
         TM    BRSTSW,STNOMEM      MEMBER NOT FOUND?
         BO    XSETSM              YES, BRANCH
         LA    R1,MSG10
         B     XSETSM
*- - - - TESTING THE RECFM FOR RECFM V OR F REQUIRES AT LEAST 2 TESTS
*              BECAUSE BOTH THE V AND F BITS ARE ON WHEN RECFM IS U.
*        THIS ROUTINE MAKES A COPY OF THE RECFM BITS AND ZEROES BOTH
*              THE V AND F BITS IN THE COPY IF THE RECFM IS U.
*        NOW WE CAN DETERMINE RECFM V OR F IN ONE TEST INSTEAD OF TWO.
         CNOP  0,4
DYNDCBEX MVC   WRKRECFM,DCBRECFM   COPY RECFM
         MVC   TSTRECFM,DCBRECFM   COPY RECFM
         TM    WRKRECFM,DCBRECU    RECFM U?
         BNOR  R14                 NO, BRANCH
         NI    TSTRECFM,255-DCBRECU YES, SET BOTH BITS OFF
         BR    R14
         CNOP  0,4
*- - - - DCB ABEND ROUTINE         R2 -> R13 = AS OPEN ... ISSUED.
DYNABEND TM    3(R1),B'00000100'   OPTION MASK = OK TO IGNORE?
         BZ    ABENDX              NO, BRANCH
         L     R8,0(,R1)           YES, GET COMPLETION CODE
         N     R8,=A(X'FFF0FF00')
         CL    R8,=A(X'01301800')  IS IT AN 013-18 ABEND?
         BNE   ABENDX              NO, BRANCH
         OI    BRSTSW,STNOMEM      YES, INDICATE MEMBER NOT FOUND
         NI    3(R1),B'11110101'   OK TO IGNORE ONLY
         BR    R14                 RETURN
ABENDX   NI    3(R1),B'11110001'   NO, IMMMEDIATE ABEND
         BR    R14                 RETURN
*- - - - SET UP THE BUFFER AREA
OKOPEN   MVC   DYNDECBW(DYNDECBL),DYNDECB
         LH    R0,DCBBLKSI
         AH    R0,=H'7'            ROUND
         N     R0,=A(X'FFFFFFF8')  UPWARDS TO MULTIPLE OF 8
         ST    R0,SAVBLKSI         SAVE FOR PARTITIONING
         XR    R0,R0
         TM    TSTRECFM,DCBRECV+DCBRECSB VS OR VBS?
         BNO   NOTSPAN             NO, BRANCH
         LH    R0,DCBLRECL         GET LRECL
         AH    R0,=H'7'            ROUND
         N     R0,=A(X'FFFFFFF8')  UPWARDS TO MULTIPLE OF 8
         LTR   R0,R0               WAS LRECL ZERO?
         BNZ   *+L'*+4             NO, SKIP NEXT INSTR
         L     R0,SAVBLKSI         YES, USE BLKSIZE ROUNDED
         A     R0,=A(2*KB)         ADD 2K IN CASE LRECL IS WRONG
NOTSPAN  ST    R0,SAVSPANL         SAVE FOR PARTITIONING
         LH    R0,DCBBLKSI
         LTR   R0,R0
         BNZ   *+L'*+4
         LH    R0,DCBLRECL
         STH   R0,RECSIZE
         AH    R0,=H'7'            ROUND
         N     R0,=A(X'FFFFFFF8')  UPWARDS TO MULTIPLE OF 8
         CH    R0,=H'1000'         IS LRECL GREATER THAN MAX?
         BNH   *+L'*+4             NO, SKIP NEXT INSTR
         LH    R0,=H'1000'         YES, HELD RECORDS MUST BE TRUNCATED
         ST    R0,SAVLRECL         SAVE FOR HOLD AREA DIVISION
         MH    R0,SCROWS+2
         ST    R0,SAVHOLDL         SAVE FOR PARTITIONING
         A     R0,SAVSPANL         COMBINE LENGTHS FOR GETMAIN
         A     R0,SAVBLKSI         COMBINE LENGTHS FOR GETMAIN
         A     R0,=A(200*CHKPTLEN) PLUS ROOM FOR 200 CHECKPOINTS
         LA    R7,BRRANGE
         ST    R0,0(,R7)
         A     R0,=A(824*CHKPTLEN) OPTIONAL ROOM UP TO 1024 CHECKPOINTS
         ST    R0,4(,R7)
         LA    R8,BRANSWER
         MVC   GMVCW(GMVCL),GMVC
        GETMAIN VC,LA=(R7),A=(R8),MF=(E,GMVCW)
         LTR   R15,R15             HOW COMPLETE?
         BNZ   GMERR               ERROR
         OI    BRSTSW,STGMVC
         LM    R0,R1,BRANSWER      ADDRESS - LENGTH
         LA    R14,*
         XR    R15,R15
         MVCL  R0,R14              CLEAR ALL TO BINARY ZEROS
         L     R1,BRANSWER
         LR    R0,R1
         A     R0,BRANSWER+4
         ST    R0,ENDPTR           END OF GETMAINED AREA
         ST    R1,BLOCKPTR
         A     R1,SAVBLKSI         POINT PAST BLOCK AREA
         ST    R1,SPANPTR
         A     R1,SAVSPANL         POINT PAST SPANNED RECORD AREA
         ST    R1,HOLDPTR
         A     R1,SAVHOLDL         POINT PAST HOLD AREA
         ST    R1,CHKPTTOP
         XC    0(CHKPTLEN,R1),0(R1) FIRST ENTRY IN TABLE
         XC    CHKPTDUM(CHKPTLEN),CHKPTDUM
         XC    DEBLOCKS(3*L'DEBLOCKS),DEBLOCKS
         XC    BRCOUNT,BRCOUNT
         XC    BROFFSET,BROFFSET
         L     R0,SCROWS1          LINES PER PAGE SCREEN 1
         CLI   SPLIT,2             AM I ON SCREEN 2?
         BNE   *+L'*+4             NO
         L     R0,SCROWS2          LINES PER PAGE SCREEN 2
         SH    R0,=Y(CRBWDT)
         STH   R0,BRSCROLL
         XR    R0,R0
         ST    R0,FNDNUM
         STH   R0,FNDOFF
         ST    R0,CHKPTBOT
         OI    BRFUSW,BRASSW       SET DEFAULT ASIS
*- - - - INITIALIZE HOLD AREA DIRECTORY
         LA    R7,HOLDDIR
         XR    R0,R0
         L     R15,HOLDPTR
         TM    TSTRECFM,DCBRECV    RECFM V?
         BZ    *+L'*+4             NO
         LA    R15,4(,R15)         YES, POINT 4 BYTES INTO EACH RECORD
         L     R8,SCROWS           MAX ROWS PER SCREEN
HOLDLOOP ST    R0,DIRNUM(,R7)      PUT ZERO IN RECORD NUMBER
         ST    R0,DIRLEN(,R7)      PUT ZERO IN RECORD LENGTH
         ST    R15,DIRREC(,R7)     STORE ADDRESS OF HELD RECORD
         A     R15,SAVLRECL        POINT TO NEXT HELD RECORD
         LA    R1,DIRSIZE(R7)      POINT TO NEXT ENTRY
         ST    R1,DIRNXT(,R7)      STORE ITS ADDRESS IN THIS ENTRY
         LR    R14,R7              SAVE LAST ENTRY
         LR    R7,R1               MAKE NEXT ENTRY THIS ENTRY
         BCT   R8,HOLDLOOP         DO IT FOR ALL BUT LAST ENTRY
         LA    R1,HOLDDIR          ADDRESS OF FIRST ENTRY
         ST    R1,DIRNXT(,R14)     CLOSE THE CIRCLE
         ST    R1,HOLDTOP          START WITH FIRST AS TOP
         BAL   R14,FILLHOLD
*- - - - SET UP THE SCREEN HEADER LINE 1
FILLSCR  LA    R1,TERMOUT+4        POINT TO START
         CLI   SPLIT,2             AM I ON SCREEN 2?
         BNE   *+L'*+12            NOPE, JUST GO DO IT
         L     R14,SCROWS1         PICK UP NUMBER OF ROWS ON SCREEN 1
         SLL   R14,2               MULTIPLY BY 4
         LA    R1,TERMOUT+4(R14)   POINT TO START
         ST    R1,TERMTOP          FIRST ROW (HEADING LINE)
         NI    0(R1),255-EOS       CLEAR END-OF-SCREEN
         L     R14,0(,R1)          PICK UP ADDRESS OF LINE 1
         MVC   0(BROSHLL,R14),BROSHL SET LINE 1 OF HEADING
         MVC   DSNMNM(L'DSNMNM,R14),BRHDLN MOVE IN DSN(MEM) NAME
         LA    R15,SCRCOL(,R14)    SET COLUMNS NUMBERS DISPLAYED
         MVC   0(8,R15),=CL8' '
         LH    R1,BROFFSET
         LA    R0,80(,R1)
         LA    R1,1(,R1)
         TM    BRMODE,MODEX
         BZ    *+L'*+4
         SH    R0,=H'40'
         CH    R0,RECSIZE
         BNH   *+L'*+4
         LH    R0,RECSIZE
         CVD   R1,BRDBLW
         OI    BRDBLW+7,X'0F'
         CH    R1,=H'1000'
         BL    FILLDIG
         UNPK  0(4,R15),BRDBLW+5(3)
         CVD   R0,BRDBLW
         OI    BRDBLW+7,X'0F'
         UNPK  5(3,R15),BRDBLW+6(2)
         B     BRHEAD
FILLDIG  UNPK  0(3,R15),BRDBLW+6(2)
         CVD   R0,BRDBLW
         OI    BRDBLW+7,X'0F'
         UNPK  4(3,R15),BRDBLW+6(2)
*- - - - SET UP THE COMMAND LINE
BRHEAD   L     R1,TERMTOP          FIRST ROW
         LA    R5,4(,R1)           POINT TO SECOND ROW
         NI    0(R5),255-EOS       CLEAR END-OF-SCREEN
         L     R14,0(,R5)          PICK UP ADDRESS OF LINE 4
         MVC   0(BROHDL,R14),BROHD
         TM    BRFSSW,BRINSW
         BZ    STSCRLL
         L     R3,TERMINPT+ZIBD    COMMAND LINE
         CLI   SPLIT,2             AM I ON SCREEN 2?
         BNE   *+L'*+12            NOPE
         L     R3,SCROWS1          PICK UP SIZE OF SCREEN 1
         SLL   R3,2                MULTIPLY BY 4
         L     R3,TERMINPT+ZIBD(R3) PICK UP RESPONSES
         CLI   0(R3),0             COMMAND ENTERED?
         BE    STSCRLL             NO
         TM    BWSCF1-1(R3),INFMOD COMMAND ENTERED?
         BZ    STSCRLL             NO
         MVC   BWSCF1(L'BWSCF1,R14),BWSCF1(R3) YES, COPY INPUT COMMAND
STSCRLL  TM    BRFUSW,BRCRSW
         BZ    *+L'*+10
         MVC   BWSCF2(L'BWSCF2,R14),=CL4'CSR'
         B     *+L'*+24
         TM    BRFUSW,BRHLSW
         BZ    *+L'*+10
         MVC   BWSCF2(L'BWSCF2,R14),=CL4'HALF'
         B     *+L'*+6
         MVC   BWSCF2(L'BWSCF2,R14),=CL4'PAGE'
*- - - - SET UP THE COLUMN HEADER LINE
         L     R1,TERMTOP          FIRST ROW
         LA    R1,4*2(,R1)         POINT TO THIRD ROW
         NI    0(R1),255-EOS       CLEAR END-OF-SCREEN
         L     R14,0(,R1)          PICK UP ADDRESS OF LINE 2
         MVI   0(R14),80           SET LENGTH = 80
         MVI   1(R14),C' '
         MVC   2(79,R14),1(R14)
         LA    R6,1(,R14)
         LH    R1,BROFFSET
         LTR   R1,R1               IS OFFSET ZERO?
         BNZ   *+L'*+4             NO
         MVI   0(R6),C'1'          YES, SPECIAL CASE, 1
         XR    R0,R0
         LA    R14,10
         DR    R0,R14
         SR    R14,R0              10 MINUS REMAINDER
         LTR   R0,R0               WAS REMAINDER 0?
         BZ    *+L'*+2             YES, USE 0, NOT 10
         LR    R0,R14
         LR    R14,R6
         AR    R14,R0              ADD (0 TO 9) TO LINE
         BCTR  R14,0               START AT LINE-1 FOR OFFSET 0
*                                  LINE+8 FOR OFFSET 1
*                                  LINE+7 FOR OFFSET 2
*                                  LINE+6 FOR OFFSET 3
*                                  LINE+0 FOR OFFSET 9
         LH    R1,BROFFSET
         AR    R1,R0               ADD (0 TO 9) TO OFFSET
         LA    R0,9
COLNUML  CH    R1,RECSIZE
         BH    COLNUMX
         CVD   R1,BRDBLW
         MVC   COLNUM,=XL6'402020202120'
         ED    COLNUM,BRDBLW+5
         CH    R1,=H'10000'        10000-32768?
         BNL   COLNUMN             YES, USE NNNNN
         MVC   COLNUM(5),COLNUM+1
         MVI   COLNUM+5,C' '
         CH    R1,=H'100'          100-999?
         BNL   COLNUMN             YES, USE XNNNX
         MVC   COLNUM(5),COLNUM+1  USE XNNXX
         MVI   COLNUM+5,C' '
COLNUMN  SH    R14,=H'2'
         CR    R14,R6
         BL    *+L'*+6
         MVC   0(5,R14),COLNUM+1
         LA    R14,12(,R14)
         TM    BRMODE,MODEX
         BO    *+L'*+8
         AH    R1,=H'10'
         B     *+L'*+4
         AH    R1,=H'5'
         BCT   R0,COLNUML
*- - - - DONE SETTING UP THE COLUMNS, NOW DRAW THE SCALE LINE
COLNUMX  L     R1,TERMTOP          FIRST ROW
         LA    R5,4*3(,R1)         POINT TO FOURTH ROW
         NI    0(R5),255-EOS       CLEAR END-OF-SCREEN
         L     R6,0(,R5)           PICK UP ADDRESS OF LINE 3
         MVI   0(R6),80            SET LENGTH = 80
         MVI   1(R6),C' '
         MVC   2(79,R6),1(R6)      FILL LINE WITH BLANKS
         LH    R1,BROFFSET
         XR    R0,R0
         TM    BRMODE,MODEX
         BO    *+L'*+8
         LA    R14,10
         B     *+L'*+4
         LA    R14,5
         CLR   R1,R14
         BL    *+L'*+4
         DR    R0,R14
         LR    R1,R0
         LR    R14,R1
         TM    BRMODE,MODEX
         BO    *+L'*+8
         AL    R14,=A(MARKS)
         B     *+L'*+6
         AR    R14,R1
         AL    R14,=A(MARKH)
         LH    R1,RECSIZE
         SH    R1,BROFFSET
         CH    R1,=H'80'
         BNH   *+L'*+4
         LH    R1,=H'80'
         BCT   R1,*+L'*+6
         MVC   1(*-*,R6),0(R14)    <<EXECUTED>>
         EX    R1,*-6
*- - - - FILL IN THE DATA AREA OF THE SCREEN
         L     R7,HOLDTOP
         L     R8,SCROWS1          PICK UP NUMBER OF ROWS
         CLI   SPLIT,2             AM I IN SPLIT SCREEN?
         BNE   *+L'*+4             NOPE, JUST GO DO IT
         L     R8,SCROWS2          MUST BE SCREEN 2
         SH    R8,=Y(CRBWDT)       MINUS FIRST 4 ROWS = MAX LINES
FILLOOP  LA    R5,4(,R5)
         NI    0(R5),255-EOS       CLEAR END-OF-SCREEN
         L     R6,0(,R5)           PICK UP TERMOUT POINTER
         MVI   0(R6),80            SET LENGTH = 80
         MVI   1(R6),C' '
         MVC   2(80,R6),1(R6)      FILL LINE WITH BLANKS
         LA    R6,1(,R6)           BUMP PAST LENGTH
         LM    R1,R2,DIRLEN(R7)    GET LENGTH AND ADDRESS
         LTR   R1,R1
         BM    FILBOT
         BNZ   *+L'*+10
         MVC   0(6,R6),=CL6'(NULL)'
         B     FILLNEXT
         SH    R1,BROFFSET         IS OFFSET BEYOND END OF RECORD
         BNP   FILLNEXT            YES, LEAVE LINE BLANK
         AH    R2,BROFFSET
         TM    BRMODE,MODEX
         BO    FILLHEX
         CH    R1,=H'80'
         BNH   *+L'*+4
         LH    R1,=H'80'
         BCT   R1,*+L'*+6
         MVC   0(*-*,R6),0(R2)     <<EXECUTED>>
         EX    R1,*-6
         TM    BRFUSW,BRASSW       ASIS?
         BO    *+L'*+8             YES
         L     R15,=A(CAPST)       NO
         B     *+L'*+4
         L     R15,=A(ASIST)
         TR    0(80,R6),0(R15)     TRANSLATE UNVIEWABLE CHARACTERS
         B     FILLNEXT
FILLHEX  CH    R1,=H'40'
         BNH   *+L'*+4
         LH    R1,=H'40'
         LR    R0,R1
         LR    R1,R2
         LR    R15,R6
HEXLOOP  MVC   1(1,R15),0(R1)      MOVE BYTE
         UNPK  0(3,R15),1(2,R15)   UNPACK
         TR    0(2,R15),HEXTAB-C'0'
         LA    R15,2(,R15)         INCREMENT OUTPUT PTR
         LA    R1,1(,R1)           INCREMENT INPUT PTR
         BCT   R0,HEXLOOP          DECREMENT LENGTH, THEN LOOP
         MVI   0(R15),C' '         BLANK THE TRAILING BYTE
FILLNEXT L     R7,DIRNXT(,R7)
         BCT   R8,FILLOOP
FILLED   CLI   SPLIT,1             AM I ON SCREEN 1?
         BE    FILLEND             YES, DON'T SET FLAG
FILSETL  OI    0(R5),EOS           SET END-OF-SCREEN
         B     FILLEND
FILBOT   MVI   0(R6),C'*'
         MVC   1(79,R6),0(R6)
         MVC   32(16,R6),=CL16' BOTTOM OF DATA '
         BCT   R8,*+L'*+4
         B     FILLED
         CLI   SPLIT,1             AM I ON SCREEN 1?
         BNE   FILSETL             NO
FILBOTL  LA    R5,4(,R5)           YES, COMPLETE SCREEN
         NI    0(R5),255-EOS       CLEAR END-OF-SCREEN
         L     R6,0(,R5)           PICK UP TERMOUT POINTER
         MVI   0(R6),80            SET LENGTH = 80
         MVI   1(R6),C' '
         MVC   2(80,R6),1(R6)      FILL LINE WITH BLANKS
         BCT   R8,FILBOTL
FILLEND  L     R15,=A(BROHELP)     DEFAULT HELP SCREEN
         ST    R15,HELPADD
         MVI   CURROW,CRBWSC       CURSOR ROW
         MVI   CURCOL,CCBWSC       CURSOR COLUMN
         TM    BRFUSW,BRASSW       ASIS?
         BZ    *+L'*+4             NO
         OI    PRCSSW,ASISFLG      YES, SET ASIS FOR INPUT
         L     R15,ARCOMM          GO COMMUNICATE
*- - - - ETPSCOMM PARM.LIST : NONE
        CALL   (15)
         NI    PRCSSW,255-ASISFLG  RESET ASIS FOR INPUT
         LTR   R15,R15             BAD RC?
         BNZ   XEND                OUT
*- - - - SCREEN MAY HAVE CHANGED
         L     R0,SCROWS1          LINES PER PAGE SCREEN 1
         CLI   SPLIT,2             AM I ON SCREEN 2?
         BNE   *+L'*+4             NO
         L     R0,SCROWS2          LINES PER PAGE SCREEN 2
         SH    R0,=Y(CRBWDT)
         STH   R0,BRSCROLL
*- - - - CHECK REPLY FROM THE TERMINAL
         L     R2,TERMINPT         PICK UP AID ADDRESS
         CLI   0(R2),X'F3'         IS IT PF3?
         BE    XEND                YES
         CLI   0(R2),X'C3'         IS IT PF15?
         BE    XEND                YES
         CLI   0(R2),X'6C'         IS IT PA1?
         BE    XEND                YES
         CLI   0(R2),X'6D'         IS IT "CLEAR"?
         BE    FILLSCR             YUP, RESHOW
         CLI   0(R2),X'6E'         IS IT PA2?
         BE    FILLSCR             YUP, RESHOW
*- - - - CHECK IF SCROLL MODE MODIFIED
         L     R3,TERMINPT+ZIBD    COMMAND LINE
         CLI   SPLIT,2             AM I ON SCREEN 2?
         BNE   *+L'*+12            NOPE
         L     R3,SCROWS1          PICK UP SIZE OF SCREEN 1
         SLL   R3,2                MULTIPLY BY 4
         L     R3,TERMINPT+ZIBD(R3) PICK UP RESPONSES
         CLI   0(R3),0             COMMAND ENTERED?
         BE    NOSCRLL             NO
         TM    BWSCF2-1(R3),INFMOD SCROLL ENRERED?
         BZ    NOSCRLL             NO
         LA    R14,BWSCF2(,R3)
         LA    R0,L'BWSCF2
         CLI   0(R14),C' '
         BNE   *+L'*+12
         LA    R14,1(,R14)
         BCT   R0,*-12
         B     *+L'*+18            NONE, CLEARED
         MVI   BRDBLW,C' '
         OC    BRDBLW(1),0(R14)
         NI    BRFUSW,255-BRHLSW-BRCRSW RESET TO PAGE
         CLI   BRDBLW,C'H'
         BNE   *+L'*+8
         OI    BRFUSW,BRHLSW       SET HALF
         B     NOSCRLL
         CLI   BRDBLW,C'C'
         BNE   NOSCRLL
         OI    BRFUSW,BRCRSW       SET CURSOR
NOSCRLL  NI    BRFSSW,255-BRINSW-FPFKSW-MAXUSW-MAXDSW
         TM    COMMSW,PFKFLAG      PF-KEY?
         BZ    NOPFK
*------- INTERPRET PROGRAM FUNCTION KEY -----------------------------*
         OI    0(R2),X'30'         MAKE PFK 13-24 LOOK LIKE 1-12
         CLI   0(R2),X'7A'         PF10-22?
         BE    LEFT
         CLI   0(R2),X'7B'         PF11-23?
         BE    RIGHT
         CLI   0(R2),X'F5'         PF5-17?
         BNE   *+L'*+8
         OI    BRFSSW,FPFKSW
         B     NOPFK
         CLI   0(R2),X'F7'         PF7-19?
         BNE   *+L'*+8
         OI    BRFSSW,MAXUSW
         B     NOPFK
         CLI   0(R2),X'F8'         PF8-20?
         BNE   *+L'*+8
         OI    BRFSSW,MAXDSW
         B     NOPFK
         LA    R1,MSG21
SETMSGA  ST    R1,MSGADD
         B     FILLSCR
NOPFK    CLI   0(R3),0             COMMAND ENTERED?
         BE    GOBACK              NO
         TM    BWSCF1-1(R3),INFMOD COMMAND ENRERED?
         BO    CKCMDIN             YES
GOBACK   TM    BRFSSW,FPFKSW+MAXUSW+MAXDSW PF5-PF7-PF8?
         BZ    FILLSCR             NOPE, JUST RESHOW THE SCREEN
         TM    BRFSSW,FPFKSW
         BO    FINDDEF
         TM    BRFSSW,MAXUSW
         BO    UPDEF
         B     DOWNDEF
CKCMDIN  LA    R14,BWSCF1(,R3)
         LA    R0,L'BWSCF1
         CLI   0(R14),C' '
         BNE   *+L'*+12
         LA    R14,1(,R14)
         BCT   R0,*-12
         B     GOBACK              NONE
         TM    BRFSSW,FPFKSW       PF5?
         BO    FINDTST             YES
         TM    BRFSSW,MAXUSW       PF7?
         BO    UPTST               YES
         TM    BRFSSW,MAXDSW       PF8?
         BO    DOWNTST             YES
         MVC   BRDBLW,=CL8' '
         OC    BRDBLW(L'BRDBLW),0(R14)
*- - - - PUT TESTS FOR COMMAND LINE HERE BELOW
         CLC   BRDBLW(4),=CL4'LEFT'
         BE    LEFT
         CLI   BRDBLW,C'L'
         BE    LEFT
         CLI   BRDBLW,C'<'
         BE    LEFT
         CLC   BRDBLW(5),=CL5'RIGHT'
         BE    RIGHT
         CLI   BRDBLW,C'R'
         BE    RIGHT
         CLI   BRDBLW,C'>'
         BE    RIGHT
         CLC   BRDBLW(2),=CL2'UP'
         BE    UP1
         CLI   BRDBLW,C'U'
         BE    UP2
         CLI   BRDBLW,C'-'
         BE    UP2
         CLC   BRDBLW(4),=CL4'DOWN'
         BE    DOWN1
         CLI   BRDBLW,C'D'
         BE    DOWN2
         CLI   BRDBLW,C'+'
         BE    DOWN2
         CLC   BRDBLW(4),=CL4'TOP '
         BE    TOP
         CLI   BRDBLW,C'T'
         BE    TOP
         CLC   BRDBLW(7),=CL7'BOTTOM '
         BE    BOTTOM
         CLC   BRDBLW(4),=CL4'BOT '
         BE    BOTTOM
         CLI   BRDBLW,C'B'
         BE    BOTTOM
         CLC   BRDBLW(5),=CL5'FIND '
         BE    FIND1
         CLC   BRDBLW(2),=CL2'F '
         BE    FIND2
         CLC   BRDBLW(4),=CL4'END '
         BE    XEND
         CLI   BRDBLW,C'X'
         BE    XEND
         CLC   BRDBLW(5),=CL5'ASIS '
         BE    ASIS
         CLI   BRDBLW,C'A'
         BE    ASIS
         CLC   BRDBLW(5),=CL5'CAPS '
         BE    CAPS
         CLI   BRDBLW,C'C'
         BE    CAPS
         CLC   BRDBLW(4),=CL4'HEX '
         BE    HEXMODE
         CLI   BRDBLW,C'H'
         BE    HEXMODE
INVLCMD  LA    R1,MSG20
         B     SETMSGA
*- - - - RIGHT - - - - - - - - - - - - - - - - - - - - - - - - - - - -*
RIGHT    LH    R15,=H'80'
         TM    BRMODE,MODEX
         BZ    *+L'*+4
         LH    R15,=H'40'
         LH    R0,BROFFSET
         AR    R0,R15              NEW-OFFSET
         LH    R1,RECSIZE
         CH    R1,=H'1000'
         BNH   *+L'*+4
         LH    R1,=H'1000'
         SR    R1,R15              GET RECSIZE-OFFSET
         BNM   *+L'*+2             IF RECSIZE IS LESS THAN OFFSET
         XR    R1,R1                 THEN RECSIZE-OFFSET IS ZERO
         CLR   R0,R1               IF NEW-OFFSET GT RECSIZE-OFFSET
         BNH   *+L'*+2               THEN
         LR    R0,R1                   USE RECSIZE-OFFSET
         STH   R0,BROFFSET
         B     FILLSCR
*- - - - LEFT  - - - - - - - - - - - - - - - - - - - - - - - - - - - -*
LEFT     LH    R15,=H'80'
         TM    BRMODE,MODEX
         BZ    *+L'*+4
         LH    R15,=H'40'
         LH    R0,BROFFSET
         SR    R0,R15              NEW-OFFSET
         BNM   *+L'*+2             IF RESULT NOT NEGATIVE, OK
         XR    R0,R0               OTHERWISE, MAKE IT ZERO
         STH   R0,BROFFSET
         B     FILLSCR
*- - - - BOTTOM  - - - - - - - - - - - - - - - - - - - - - - - - - - -*
BOTTOM   XR    R0,R0
         ST    R0,FNDNUM           RESET LAST-FOUND NUMBER
         STH   R0,FNDOFF           RESET LAST-FOUND OFFSET
         L     R0,=F'99999999'     BOTTOM NINES
         B     LISTAT
*- - - - DOWN  - - - - - - - - - - - - - - - - - - - - - - - - - - - -*
DOWN1    LA    R1,4
         B     DOWNCK
DOWN2    LA    R1,1
DOWNCK   AR    R14,R1              POINT TO POSSIBLE OPERAND
         SR    R0,R1
         BNP   DOWNDEF
         CLI   0(R14),C' '
         BNE   DOWNTST
         LA    R14,1(,R14)
         BCT   R0,*-12
         B     DOWNDEF             NONE, USE DEFAULT RANGE
DOWNTST  MVI   BRDBLW,C' '
         OC    BRDBLW(1),0(R14)
         CLI   BRDBLW,C'M'         OK, MAX?
         BE    BOTTOM              YES
         CLI   0(R14),C'0'         NO, NUMERIC?
         BL    INVLCMD             NO
         LA    R15,1(R14)          OK, SOME NUMERIC VALUE WAS
         LA    R1,1                ENTERED, FIND OUT WHAT IT IS...
DOWNLP   BCT   R0,*+L'*+4
         B     DOWNDO
         CLI   0(R15),C' '         SEARCH FOR END?
         BE    DOWNDO              YES
         CLI   0(R15),C'0'         NO, NUMERIC?
         BL    INVLCMD             NO
         LA    R1,1(,R1)           BUMP 1
         LA    R15,1(,R15)         BUMP 1
         B     DOWNLP              LOOP IF MORE
DOWNDO   CH    R1,=H'6'            EXPRESSED NUMBER TOO HIGH?
         BH    DOWNDEF             YES, USE DEFAULT RANGE
         BCTR  R1,0
         EX    R1,PACKBRO          PACK INTO "BRDBLW"
         OI    BRDBLW+7,X'0F'      MAKE POSITIVE
         CVB   R0,BRDBLW           PUT BINARY VALUE IN R0
         B     DOWNRGE             USE RANGE IN R0
DOWNDEF  LH    R0,BRSCROLL
         TM    BRFUSW,BRCRSW       CURSOR?
         BZ    DOWNHLF             NO
         L     R14,TERMINPT        PICK UP AID/ROW/COL ADDRESS
         XR    R15,R15
         IC    R15,1(R14)          GET ROW NUMBER
         SH    R15,=Y(CRBWDT)
         BNP   DOWNRGE
         LR    R0,R15
         B     DOWNRGE
DOWNHLF  TM    BRFUSW,BRHLSW       HALF PAGE?
         BZ    DOWNRGE             NO
         SRL   R0,1                YES
DOWNRGE  ST    R0,DOWNAMT
         XR    R0,R0
         ST    R0,FNDNUM           RESET LAST-FOUND NUMBER
         STH   R0,FNDOFF           RESET LAST-FOUND OFFSET
         BAL   R14,DOWNER
         B     FILLSCR             FILL THE SCREEN
*- - - - TOP   - - - - - - - - - - - - - - - - - - - - - - - - - - - -*
TOP      BAL   R14,DOTOP           GO TO DO IT
         B     FILLSCR
*- - - - UP    - - - - - - - - - - - - - - - - - - - - - - - - - - - -*
UP1      LA    R1,2
         B     UPCK
UP2      LA    R1,1
UPCK     AR    R14,R1              POINT TO POSSIBLE OPERAND
         SR    R0,R1
         BNP   UPDEF
         CLI   0(R14),C' '
         BNE   UPTST
         LA    R14,1(,R14)
         BCT   R0,*-12
         B     UPDEF               NONE, USE DEFAULT RANGE
UPTST    MVI   BRDBLW,C' '
         OC    BRDBLW(1),0(R14)
         CLI   BRDBLW,C'M'         OK, MAX?
         BE    TOP                 YES
         CLI   0(R14),C'0'         NO, NUMERIC?
         BL    INVLCMD             NO
         LA    R15,1(R14)          OK, SOME NUMERIC VALUE WAS
         LA    R1,1                ENTERED, FIND OUT WHAT IT IS...
UPLP     BCT   R0,*+L'*+4
         B     UPDO
         CLI   0(R15),C' '         SEARCH FOR END?
         BE    UPDO                YES
         CLI   0(R15),C'0'         NO, NUMERIC?
         BL    INVLCMD             NO
         LA    R1,1(,R1)           BUMP 1
         LA    R15,1(,R15)         BUMP 1
         B     UPLP                LOOP IF MORE
UPDO     CH    R1,=H'6'            EXPRESSED NUMBER TOO HIGH?
         BH    UPDEF               YES, USE DEFAULT RANGE
         BCTR  R1,0
         EX    R1,PACKBRO          PACK INTO "BRDBLW"
         OI    BRDBLW+7,X'0F'      MAKE POSITIVE
         CVB   R0,BRDBLW           PUT BINARY VALUE IN R0
         B     UPRANGE             USE RANGE IN R0
UPDEF    LH    R0,BRSCROLL
         TM    BRFUSW,BRCRSW       CURSOR?
         BZ    UPHALF              NO
         L     R14,TERMINPT        PICK UP AID/ROW/COL ADDRESS
         XR    R15,R15
         IC    R15,1(R14)          GET ROW NUMBER
         LA    R14,CRBWDT-1
         SR    R15,R14
         BNP   UPRANGE
         SR    R0,R15
         B     UPRANGE
UPHALF   TM    BRFUSW,BRHLSW       HALF PAGE?
         BZ    UPRANGE             NO
         SRL   R0,1                YES
UPRANGE  ST    R0,DOWNAMT
         XR    R0,R0
         ST    R0,FNDNUM           RESET LAST-FOUND NUMBER
         STH   R0,FNDOFF           RESET LAST-FOUND OFFSET
         L     R7,HOLDTOP
         CLC   DIRNUM(4,R7),=F'1'  ARE WE AT TOP ALREADY?
         BNH   FILLSCR             YES, BRANCH
         TM    DIRLEN(R7),EOL      IS FIRST LINE END-OF-LIST?
         BZ    *+L'*+10            NO, BRANCH
         OC    BRCOUNT,BRCOUNT     IS DATA SET EMPTY?
         BZ    FILLSCR             YES, BRANCH
         L     R0,DIRNUM(,R7)      GET RECORD NUMBER OF TOP LINE
         S     R0,DOWNAMT          GET RECORD NUMBER TO GO BACK TO
         BP    LISTAT              IF POSITIVE, OK
         LA    R0,1                ELSE THEN MAKE IT 1
LISTAT   ST    R0,LISTNUM
         LA    R15,CHKPTLEN        LENGTH OF CHKPT ENTRY
         L     R1,CHKPTBOT
         TM    0(R1),EOL           IS IT END-OF-LIST?
         BZ    LISTCK
         CL    R1,CHKPTTOP         IS DATA SET EMPTY?
         BE    FILLSCR             YES
         SR    R1,R15              NO, BACK UP ONE ENTRY
LISTCK   CL    R0,0(,R1)           DOES THIS BLOCK CONTAIN OUR RECORD?
         BNL   LISTPNT             YES, GO POINT TO IT
         CL    R1,CHKPTTOP         HAVE I BACKED UP TO TOP?
         BE    FILLSCR             YES
         SR    R1,R15              NO, BACK UP ONE BLOCK ENTRY
         B     LISTCK              CONTINUE
LISTPNT  MVC   BRCOUNT,0(R1)
         MVC   DEBLOCKS(3*L'DEBLOCKS),8(R1)
         MVC   BRTTR,4(R1)         TTR OF FIRST BLOCK
         MVC   BRTTRZ(3),BRTTR
        POINT  (R4),BRTTRZ
         L     R14,SPANPTR
         XR    R0,R0
         STH   R0,0(,R14)          RESET SPAN BUFFER LENGTH
         ST    R0,FNDNUM           RESET LAST-FOUND NUMBER
         STH   R0,FNDOFF           RESET LAST-FOUND OFFSET
         BAL   R14,FILLHOLD        READ NEXT RECORDS
LISTFINE L     R7,HOLDTOP          GET ENTRY FOR TOP OF HOLD AREA
         TM    DIRLEN(R7),EOL      IS END-OF-LIST ON TOP OF SCREEN?
         BZ    LISTCONT            NO, WE ARE NOT FINISHED
         CLC   LISTNUM,=F'99999999' WAS THIS A LIST 99999999?
         BNE   FILLSCR             NO
         LH    R0,BRSCROLL         YES
         TM    BRFUSW,BRHLSW       HALF PAGE?
         BZ    *+L'*+4             NO
         SRL   R0,1                YES
         BCTR  R0,0
         B     UPRANGE
LISTCONT CLC   LISTNUM,DIRNUM(R7)  IS REQUESTED NUMBER AT TOP?
         BNH   FILLSCR             YES, BRANCH
         MVC   DOWNAMT,=F'1'       SET DOWN 1
         BAL   R14,DOWNER
         B     LISTFINE
*- - - - FIND  - - - - - - - - - - - - - - - - - - - - - - - - - - - -*
FIND1    LA    R1,5
         B     FINDCK
FIND2    LA    R1,2
FINDCK   AR    R14,R1              POINT TO POSSIBLE OPERAND
         SR    R0,R1
         BNP   FINDDEF
         CLI   0(R14),C' '
         BNE   FINDTST
         LA    R14,1(,R14)
         BCT   R0,*-12
FINDDEF  TM    BRFSSW,FSTRSW       HAS A STRING BEEN ENTERED?
         BO    FINDGO              YES
         LA    R1,MSG31            NO, ERROR
         B     SETMSGA
FINDTST  LA    R15,BWSCF1+L'BWSCF1-1(R3) FIND END OF STRING DEFINITION
         CLI   0(R15),C' '
         BNE   *+L'*+4
         BCT   R15,*-8
         NI    BRFSSW,255-FSTRSW   NULLIFY PREVIOUS
         MVC   BRDBLW(2),=CL8' '
         OC    BRDBLW(2),0(R14)
         CLC   BRDBLW(2),=CL2'X''' HEX-STRING?
         BE    FINDHEX             YES
         CLI   0(R14),X'80'        NO, CHAR-STRING
         BNL   *+L'*+16
         CLC   0(1,R14),0(R15)
         BNE   *+L'*+6
         LA    R14,1(R14)
         BCTR  R15,0
         SR    R15,R14
         BNP   STRNLL
         LA    R0,L'BRSTRNG
         CLR   R15,R0
         BH    STLONG
         MVI   BRSTRNG,C' '
         MVC   BRSTRNG+1(L'BRSTRNG-1),BRSTRNG
         EX    R15,*+L'*+8
         STH   R15,BRSTRNGL
         B     FINDSET
         MVC   BRSTRNG(*-*),0(R14) <<EXECUTED>>
STRNLL   LA    R1,MSG34
         B     SETMSGI
STLONG   LA    R1,MSG35
         B     SETMSGI
INVHXD   LA    R1,MSG36
         B     SETMSGI
HXSMIS   LA    R1,MSG37
         B     SETMSGI
NHXSTR   LA    R1,MSG38
         B     SETMSGI
HXSTRO   LA    R1,MSG39
SETMSGI  OI    BRFSSW,BRINSW
         B     SETMSGA
VHXRTN   XR    R1,R1               VERIFY HEX-DIGIT LOCAL ROUTINE
         LA    R14,1(R14)          R7 = LOCAL LINK REGISTER
         IC    R1,0(R14)
         OR    R1,R5
         STC   R1,BRDBLW
         CLI   BRDBLW,C'A'
         BL    INVHXD
         CLI   BRDBLW,C'F'
         BH    *+L'*+8
         LA    R1,9(R1)
         B     VHXRTN1
         CLI   BRDBLW,C'0'
         BL    INVHXD
         CLI   BRDBLW,C'9'
         BH    INVHXD
VHXRTN1  NR    R1,R6
         BR    R7
FINDHEX  CLI   0(R15),C''''        LAST QUOTE TYPED?
         BNE   *+L'*+2             NO
         BCTR  R15,0               YES, BACK ONE
         LA    R14,1(R14)
         CLR   R15,R14
         BL    HXSMIS
         BE    NHXSTR
         SR    R15,R14
         LA    R0,2*L'BRSTRNG
         CLR   R15,R0
         BH    STLONG
         LR    R0,R15
         SRL   R0,1
         SLL   R0,1
         CLR   R15,R0
         BNE   HXSTRO
         SRL   R0,1
         LR    R15,R0
         BCTR  R15,0
         STH   R15,BRSTRNGL
         MVI   BRSTRNG,C' '
         MVC   BRSTRNG+1(L'BRSTRNG-1),BRSTRNG
         LA    R15,BRSTRNG
         LA    R5,X'40'
         LA    R6,X'0F'
FINDHXL  BAL   R7,VHXRTN
         LR    R2,R1
         SLL   R2,4
         BAL   R7,VHXRTN
         OR    R1,R2
         STC   R1,0(R15)
         LA    R15,1(R15)
         BCT   R0,FINDHXL
FINDSET  OI    BRFSSW,FSTRSW
         XR    R0,R0
         ST    R0,FNDNUM           RESET LAST-FOUND NUMBER
         STH   R0,FNDOFF           RESET LAST-FOUND OFFSET
FINDGO   TM    FNDOFF,EOL          BOTTOM (END-OF-LIST) REACHED?
         BZ    *+L'*+4             NO
         BAL   R14,DOTOP           YES, RESTART FROM TOP
         MVI   FNDWA,C' '          PREPARE COMPARE STRING
         MVC   FNDWA+1(L'FNDWA-1),FNDWA
         MVI   CRDWA,C' '
         LH    R14,BRSTRNGL        GET LENGTH CODE OF STRING
         TM    BRFUSW,BRASSW       ASIS?
         BZ    *+L'*+8             NO
         EX    R14,CUCFSTR         YES, COPY AND UPPERCASE
         B     *+L'*+4
         EX    R14,CPYFSTR         COPY
         L     R7,HOLDTOP          GET INFO FOR FIRST HELD RECORD
         L     R0,DIRNUM(,R7)      GET RECORD NUMBER OF FIRST HELD
         L     R1,FNDNUM           GET RECORD NUMBER WHERE LAST FOUND
         LTR   R1,R1               HAS IT BEEN FOUND?
         BNP   FINDSCR             NO, START WITH HELD RECORDS
         CLR   R0,R1               ARE WE PAST LAST FOUND REC?
         BH    FINDSCR             YES, START WITH HELD RECORDS
         L     R14,HOLDEND
         L     R15,DIRNUM(,R14)    GET RECORD NUMBER OF LAST HELD
         CLR   R1,R15              IS LAST FOUND REC ON SCREEN?
         BH    FINDDOWN            NO, BRANCH
FINDPREV CL    R1,DIRNUM(,R7)      IS THIS RECORD WHERE LAST FOUND?
         BE    FINDPCOL            YES, BRANCH
         CL    R7,HOLDEND          IS THIS LAST RECORD ON SCREEN?
         BE    FINDDOWN            SHOULD NOT HAPPEN
         L     R7,DIRNXT(,R7)      POINT TO NEXT RECORD
         B     FINDPREV
FINDPCOL L     R15,DIRREC(,R7)     POINT TO RECORD
         AH    R15,FNDOFF          POINT TO LAST FOUND STRING
         LA    R15,1(,R15)         POINT PAST LAST FOUND STRING
         B     FINDSTR
FINDDOWN MVC   DOWNAMT,=F'1'       SET DOWN 1
         BAL   R14,DOWNER
         L     R7,HOLDEND
FINDSCR  TM    DIRLEN(R7),EOL      ARE WE AT END-OF-LIST?
         BO    FINDNOTF            YES
         L     R15,DIRREC(,R7)     POINT TO FIRST BYTE TO EXAMINE
FINDSTR  L     R0,DIRLEN(,R7)      GET LENGTH OF RECORD
         CL    R0,SAVLRECL         IS RECORD TRUNCATED?
         BNH   *+L'*+4             NO, SKIP NEXT INSTR
         L     R0,SAVLRECL         YES, USE TRUNCATED LENGTH
         L     R1,DIRREC(,R7)      GET ADDRESS OF RECORD
         AR    R0,R1               POINT PAST LAST BYTE OF RECORD
         LH    R14,BRSTRNGL        GET LENGTH CODE OF STRING
         AR    R15,R14             POINT TO LAST BYTE TO BE COMPARED
         SR    R0,R15              GET NUMBER OF COMPARISONS
         BNP   FINDNEXT            STRING TOO LONG FOR REMAINING TEXT
         SR    R15,R14             PUT STRING ADDRESS BACK
FINDLOOP MVC   CRDWA+1(L'FNDWA),CRDWA
         EX    R14,UPPERDT         SET DATA
         EX    R14,FINDCLC         COMPARE DATA TO STRING
         BE    FOUND
         LA    R15,1(,R15)         INCREMENT DATA POINTER
         BCT   R0,FINDLOOP         GO COMPARE AGAIN
FINDNEXT CL    R7,HOLDEND          WAS THAT LAST HELD RECORD?
         BE    FINDDOWN            YES, BRANCH
         L     R7,DIRNXT(,R7)      POINT TO NEXT RECORD
         B     FINDSCR             GO PROCESS NEXT RECORD
FOUND    MVC   BROWMSG(MSG33L),MSG33
         LA    R1,BROWMSG
         ST    R1,MSGADD
         MVC   FNDNUM,DIRNUM(R7)   SAVE RECORD NUMBER
         S     R15,DIRREC(,R7)     GET OFFSET TO FOUND LOCATION
         STH   R15,FNDOFF          SAVE OFFSET
         A     R15,=F'1'           COMPUTE COLUMN NUMBER
         CVD   R15,BRDBLW
         OI    BRDBLW+7,X'0F'
         CH    R15,=H'1000'
         BL    *+L'*+10
         UNPK  BROWMSG+MSG33L-4(4),BRDBLW+5(3)
         B     *+L'*+10
         UNPK  BROWMSG+MSG33L-4(3),BRDBLW+6(2)
         MVI   BROWMSG,MSG33L-2
         L     R6,FNDNUM
         L     R7,HOLDTOP          POINT TO TOP ENTRY
         S     R6,DIRNUM(,R7)      COMPUTE DOWN COUNT
         BNP   FILLSCR
         MVC   DOWNAMT,=F'1'       SET DOWN 1
         BAL   R14,DOWNER
         BCT   R6,*-10
         B     FILLSCR
FINDNOTF OI    FNDOFF,EOL          SAY BOTTOM (END-OF-LIST) REACHED
         LA    R1,MSG32            YES, ERROR
         B     SETMSGA
*- - - - HEX   - - - - - - - - - - - - - - - - - - - - - - - - - - - -*
HEXMODE  XI    BRMODE,MODEX        FLIP FLOP THE SWITCH
         B     FILLSCR
*- - - - CAPS / ASIS - - - - - - - - - - - - - - - - - - - - - - - - -*
CAPS     NI    BRFUSW,255-BRASSW   SET CAPS
         B     FILLSCR
ASIS     OI    BRFUSW,BRASSW       SET ASIS
         B     FILLSCR
         SPACE 1
PACKBRO  PACK  BRDBLW,0(*-*,R14)   <<EXECUTED>>
CPYFSTR  MVC   FNDWA(*-*),BRSTRNG  <<EXECUTED>>
CUCFSTR  OC    FNDWA(*-*),BRSTRNG  <<EXECUTED>>
UPPERDT  OC    CRDWA+1(*-*),0(R15) <<EXECUTED>>
FINDCLC  CLC   CRDWA+1(*-*),FNDWA  <<EXECUTED>>
         EJECT
*------- SUBROUTINE TO EXECUTE TOP COMMAND
*              R14 = LINK REGISTER
DOTOP    ST    R14,TOPXR14
         L     R1,CHKPTTOP
         MVC   BRTTR,4(R1)         TTR OF FIRST BLOCK
         MVC   BRTTRZ(3),BRTTR
        POINT  (R4),BRTTRZ
         XC    DEBLOCKS(3*L'DEBLOCKS),DEBLOCKS
         XC    BRCOUNT,BRCOUNT
         L     R14,SPANPTR
         XR    R0,R0
         STH   R0,0(,R14)          RESET SPAN BUFFER LENGTH
         ST    R0,FNDNUM           RESET LAST-FOUND NUMBER
         STH   R0,FNDOFF           RESET LAST-FOUND OFFSET
         BAL   R14,FILLHOLD
         L     R14,TOPXR14
         BR    R14                 RETURN
         SPACE 1
*------- SUBROUTINE TO READ ENOUGH RECORDS TO FILL HOLD AREA
*              R14 = LINK REGISTER
FILLHOLD ST    R14,HOLDR14
         L     R0,HOLDPTR
         L     R1,SAVHOLDL
         XR    R14,R14
         L     R15,=A(X'40000000')
         MVCL  R0,R14              FILL HOLD AREA WITH BLANKS
         L     R7,HOLDTOP          POINT TO HOLD AREA DIRECTORY
         L     R8,SCROWS           MAX ROWS PER SCREEN
HILLOOP  BAL   R14,GETREC          GET A RECORD
         LA    R0,1                COMPUTE
         A     R0,BRCOUNT            THE
         ST    R0,BRCOUNT              RECORD NUMBER
         ST    R0,DIRNUM(,R7)      STORE THE RECORD NUMBER
         ST    R1,DIRLEN(,R7)      LENGTH IN DIRECTORY
         LTR   R1,R1               END OF FILE
         BM    HILLED              YES BRANCH
         CL    R1,SAVLRECL         IS RECORD LONGER THAN MAX
         BNH   *+L'*+4             NO, SKIP NEXT INSTR
         L     R1,SAVLRECL         YES, TRUNCATE TO MAX
         LR    R0,R2               ADDRESS TO MOVE FROM
         L     R14,DIRREC(,R7)     ADDRESS TO MOVE TO
         TM    TSTRECFM,DCBRECV    RECFM V
         BZ    HILLNOTV            NO
         SH    R14,=H'4'           YES, MOVE TO PTR MINUS 4
         L     R15,DIRLEN(,R7)
         SH    R15,=H'4'
         ST    R15,DIRLEN(,R7)
HILLNOTV LR    R15,R1              LENGTH FOR MOVE
         MVCL  R14,R0
         LR    R1,R7               SAVE PTR TO MOST CURRENT ENTRY
         L     R7,DIRNXT(,R7)      POINT TO NEXT DIRECTORY ENTRY
         BCT   R8,HILLOOP
         LR    R7,R1               GET MOST CURRENT ENTRY
HILLED   ST    R7,HOLDEND          SAVE LAST RECORD ENTRY
         L     R14,HOLDR14
         BR    R14                 RETURN
         SPACE 1
*------- SUBROUTINE TO SEE IF EOF IS ON SCREEN AND WOULD BE FORCED OFF
*              R14 = LINK REGISTER
DOWNER   L     R7,HOLDEND          POINT TO ENTRY FOR LAST RECORD
         TM    DIRLEN(R7),EOL      IS END-OF-LIST ON SCREEN?
         BZ    DOWNNEOF            NO, DOWN IS POSSIBLE
         L     R7,HOLDTOP
         L     R0,DOWNAMT          GET DOWN AMOUNT
         LTR   R0,R0               IS IT VALID?
         BNPR  R14                 NO, DON'T GO DOWN, RETURN
         CH    R0,BRSCROLL         OR SCREEN SIZE IF HIGHER
         BNH   *+L'*+4
         LH    R0,BRSCROLL
         TM    DIRLEN(R7),EOL      IS THIS END OF DATA (END-OF-LIST)?
         BOR   R14                 YES, CANT GO DOWN, RETURN
         L     R7,DIRNXT(,R7)      GET ENTRY FOR NEXT RECORD
         BCT   R0,*-10
         L     R7,HOLDEND          POINT TO ENTRY FOR LAST RECORD
DOWNNEOF ST    R14,DOWNR14
         L     R8,DOWNAMT          GET NUMBER OF LINES TO GO DOWN
DOWNLOOP L     R15,HOLDTOP         POINT TO TOP ENTRY
         L     R15,DIRNXT(,R15)    GET ADDRESS OF ENTRY AFTER TOP
         ST    R15,HOLDTOP         MAKE IT NEW TOP
         TM    DIRLEN(R7),EOL      IS END-OF-LIST ON SCREEN?
         BO    DOWNNXT             YES, BYPASS GET
         L     R7,DIRNXT(,R7)      POINT TO NEXT ENTRY
         BAL   R14,GETREC          GET A RECORD
         LA    R0,1                COMPUTE
         A     R0,BRCOUNT            THE
         ST    R0,BRCOUNT              RECORD NUMBER
         ST    R0,DIRNUM(,R7)      STORE THE RECORD NUMBER
         ST    R1,DIRLEN(,R7)      STORE LENGTH
         LTR   R1,R1               END OF FILE?
         BNM   DOWNSTR             NO
DOWNFWD  BCT   R8,*+L'*+4          YES, END OF DATA
         B     DOWNX               OR END OF DOWN REQUEST
         L     R15,HOLDTOP         POINT TO TOP ENTRY
         L     R15,DIRNXT(,R15)    GET ADDRESS OF ENTRY AFTER TOP
         ST    R15,HOLDTOP         MAKE IT NEW TOP
         B     DOWNFWD
DOWNSTR  CL    R1,SAVLRECL         IS RECORD LONGER THAN MAX?
         BNH   *+L'*+4             NO, SKIP NEXT INSTR
         L     R1,SAVLRECL         YES, TRUNCATE TO MAX
         LR    R0,R2               ADDRESS TO MOVE FROM
         L     R14,DIRREC(,R7)     ADDRESS TO MOVE TO
         TM    TSTRECFM,DCBRECV    RECFM V?
         BZ    DOWNNOTV            NO
         SH    R14,=H'4'           YES, MOVE TO PTR MINUS 4
         L     R15,DIRLEN(,R7)
         SH    R15,=H'4'
         ST    R15,DIRLEN(,R7)
DOWNNOTV L     R15,SAVLRECL        LENGTH OF RECEIVING FIELD
         O     R1,=A(X'40000000')  PAD WITH BLANKS
         MVCL  R14,R0
DOWNNXT  BCT   R8,DOWNLOOP
DOWNX    ST    R7,HOLDEND          NEW END POINTER
         L     R14,DOWNR14
         BR    R14                 RETURN
         SPACE 1
*------- SUBROUTINE TO GET A LOGICAL RECORD
*              R14 = LINK REGISTER
*        INPUT :  R4 DCB ADDRESS
*                 CHKPTTOP -  TOP OF CHECKPOINT TABLE
*                 CHKPTBOT -  BOTTOM OF CHECKPOINT TABLE, ZERO 1ST TIME
*                 COUNT    -  LAST LOGICAL RECORD NUMBER READ
*                 BLOCKPTR -  ADDRESS OF BUFFER
*                 DEBLOCKS -  DEBLOCKING INFO (ZEROS FIRST TIME)
*                 SPANPTR  -  ADDRESS OF AREA TO COMBINE SPANNED RECORD
*                             SEGMENTS
*        OUTPUT : R1 CONTAINS LENGTH OF RECORD (OR -1 IF END OF FILE)
*                 R2 CONTAINS ADDRESS OF RECORD (OR 0 IF END OF FILE)
GETREC   ST    R14,READR14
         LM    R0,R2,DEBLOCKS      GET DEBLOCKING STATUS
         TM    WRKRECFM,DCBRECBR   BLOCKED
         BZ    READI               NO, BRANCH
         AR    R2,R1               POINT TO NEXT RECORD
         CLR   R2,R0               END OF BLOCK (OR FIRST TIME)?
         BNL   READI               YES, BRANCH
         TM    TSTRECFM,DCBRECV    VARIABLE LENGTH?
         BO    READVB              YES, BRANCH
         ST    R2,DEBLOCKS+2*L'DEBLOCKS FIXED BLOCKED
         B     READX
READI    L     R5,CHKPTBOT         GET LAST CHECKPOINT
         LTR   R5,R5               IS THIS FIRST READ?
         BNZ   *+L'*+8             BRANCH IF NOT FIRST
         L     R5,CHKPTTOP
         B     READNEW             READING A RECORD NOT READ BEFORE
         L     R1,0(,R5)           GET NUMBER OF HIGHEST RECORD READ
         LTR   R1,R1               WAS IT EOF?
         BM    *+L'*+8             YES, BRANCH
         CL    R1,BRCOUNT          HAVE WE READ THIS RECORD BEFORE?
         BNH   *+L'*+8             NO, BRANCH
         LA    R5,CHKPTDUM         YES, DONT CHANGE CHKPT TABLE
         B     READBRO
         LA    R5,CHKPTLEN(R5)     ADD AN ENTRY TO THE CHKPT TABLE
         CL    R5,ENDPTR           IS TABLE FILLED UP?
         BL    READNEW             NO, SKIP NEXT INSTR
         LA    R0,CHKPTLEN         YES, HALVE THE TABLE, ENTRY LENGTH
         L     R15,CHKPTTOP        POINT TO FIRST ENTRY
         AR    R15,R0              POINT TO SECOND ENTRY
         LR    R1,R15
         AR    R1,R0               POINT TO THIRD ENTRY
READHMOV MVC   0(CHKPTLEN,R15),0(R1) MOVE 3RD TO 2ND, 5TH TO 3RD,
*                                         7TH TO 4TH, ETC...
         AR    R15,R0              RECEIVING FIELD DOWN 1
         AR    R1,R0               SENDING FIELD DOWN 1
         AR    R1,R0               SENDING FIELD DOWN 2
         CLR   R1,R5               ARE WE PAST THE LAST ENTRY
         BL    READHMOV            NO, BRANCH
         LR    R5,R15              YES, NEW CURRENT POINTER
READNEW  ST    R5,CHKPTBOT         SAVE NEW CURRENT CHECKPOINT POINTER
         MVC   0(4,R5),BRCOUNT
         XC    4(4,R5),4(R5)
         MVC   8(3*L'DEBLOCKS,R5),DEBLOCKS
READBRO  L     R2,BLOCKPTR
        READ   DYNDECBW,SF,(R4),(R2),'S',MF=E
        CHECK  DYNDECBW
         TM    BRFSSW,SYNADSW      WAS SYNAD EXIT TAKEN?
         BO    IOERR               YES, BRANCH
         LH    R1,DCBBLKSI
         L     R14,DYNDECBW+(DECIOBPT-DECB)
         SH    R1,IOBCSW+5-IOBSTDRD(,R14) SUBTRACT RESIDUAL COUNT
         TM    TSTRECFM,DCBRECV    VARIABLE LENGTH RECORDS?
         BZ    *+L'*+4             NO, BRANCH
         LH    R1,0(,R2)           YES, USE BLKSIZE IN BDW
         LA    R0,0(R1,R2)         END OF BLOCK
         STM   R0,R2,DEBLOCKS      SAVE STATUS INFO
         CLC   4(4,R5),=F'0'       IS THIS 2ND READ PER GET?
         BNZ   NOTED               YES, BYPASS NOTE
        NOTE   (R4)
         ST    R1,4(,R5)           SAVE TTR IN TABLE
NOTED    L     R1,DEBLOCKS+L'DEBLOCKS RESTORE LENGTH
         TM    WRKRECFM,DCBRECBR   BLOCKED?
         BO    READB               YES, BRANCH
         TM    TSTRECFM,DCBRECV+DCBRECSB VARIABLE UNBLOCKED SPANNED?
         BNO   READX               NO
         B     READVBS             YES, SAME AS BLOCKED
READB    TM    WRKRECFM,DCBRECU    UNDEFINED?
         BO    READX
         TM    WRKRECFM,DCBRECV    VARIABLE LENGTH?
         BO    READVBI
         LH    R1,DCBLRECL         FIXED BLOCKED
         ST    R1,DEBLOCKS+L'DEBLOCKS SAVE STATUS INFO
         B     READX
READVBI  LA    R2,4(,R2)           POINT PAST BDW
READVB   TM    WRKRECFM,DCBRECSB   SPANNED?
         BO    READVBS
READVBR  LH    R1,0(,R2)
         STM   R1,R2,DEBLOCKS+L'DEBLOCKS SAVE STATUS INFO
         B     READX
READVBS  CLI   2(R2),0             SEGMENT?
         BE    READVBR             NO, BRANCH
*                             THIRD BYTE IS X'01' FOR FIRST SEGMENT
*                                           X'03' FOR MIDDLE SEGMENT
*                                           X'02' FOR LAST SEGMENT
         CLI   2(R2),1             FIRST SEGMENT?
         BNE   READSEGN
         L     R14,SPANPTR         ADDRESS TO MOVE TO
         LH    R15,0(,R2)          LENGTH TO MOVE
         LR    R1,R15              LENGTH TO MOVE
         LR    R0,R2               ADDRESS TO MOVE FROM
         MVCL  R14,R0              MOVE SEGMENT RDW AND DATA
         B     READSEGD            GO DEBLOCK NEXT SEGMENT
READSEGN L     R14,SPANPTR         ADDRESS OF PRIOR SEGMENTS
         LH    R0,0(,R14)          LENGTH OF PRIOR SEGMENTS
         LH    R15,0(,R2)          LENGTH+4 OF NEW SEGMENT
         SH    R15,=H'4'           LENGTH OF NEW SEGMENT
         LR    R1,R15              LENGTH TO BE MOVED
         AR    R15,R0              COMBINE LENGTHS
         STH   R15,0(,R14)         STORE COMBINED LENGTHS
         LR    R15,R1              LENGTH TO ME MOVED
         AR    R14,R0              ADDRESS TO MOVE TO
         LA    R0,4(,R2)           ADDRESS TO MOVE FROM
         MVCL  R14,R0              MOVE SEGMENT DATA
         CLI   2(R2),2             LAST SEGMENT?
         BNE   READSEGD            NO, GO DEBLOCK NEXT SEGMENT
         LH    R1,0(,R2)           GET LENGTH OF THIS SEGMENT
         STM   R1,R2,DEBLOCKS+L'DEBLOCKS SAVE LENGTH AND ADDRESS
         L     R2,SPANPTR          POINT TO COMBINED RECORD
         LH    R1,0(,R2)           GET COMBINED LENGTH
         B     READX               EXIT
*                             NOT NECESSARY TO CHECK RECFM FOR DCBRECBR
READSEGD LH    R1,0(,R2)           LENGTH
         AR    R2,R1               POINT TO NEXT SEGMENT
         CL    R2,DEBLOCKS         END OF BLOCK?
         BNL   READBRO             YES, BRANCH
         B     READVBS             GO PROCESS NEW SEGMENT
         CNOP  0,4
DYNEOD   L     R1,=F'-1'           EOF
         ST    R1,0(,R5)           SAVE EOF IN CHKPT TABLE
         XR    R2,R2
READX    L     R14,READR14
         BR    R14
         EJECT
*------- END OF PROGRAM ---------------------------------------------*
GMERR   XMESS  1601,R15
         LA    R1,BRGMMSG
         B     XSETSM
IOERR    LA    R1,BROWMSG
XSETSM   ST    R1,MSGADD
XEND     TM    BRSTSW,STGMVC
         BZ    NOGMVC
         L     R0,BRANSWER+4       LENGTH
         L     R1,BRANSWER         ADDRESS
        FREEMAIN R,LV=(0),A=(1)
NOGMVC   TM    BRSTSW,STOPEN
         BZ    NOCLOSE
         TM    DCBOFLGS,DCBOFOPN   IS IT OPEN?
         BZ    NOCLOSE             NO, BRANCH
         MVI   OPCLPL,VLB          SET "VL" BIT
        CLOSE  ((R4)),MF=(E,OPCLPL)
         DROP  R4
NOCLOSE  L     R13,4(,R13)         PICK UP CALLING SAVE-AREA
         LM    R14,R12,12(R13)     RESTORE CALLING REGSITERS
         XR    R15,R15             SET RC=0
         BR    R14                 RETURN
         SPACE 1
*------- SYNAD EXIT - THIS ROUTINE IS ENTERED DURING THE "CHECK" MACRO
*              IF AN I/O ERROR OCCURS.
         CNOP  0,4
DYNSYNAD SYNADAF ACSMETH=BSAM
         MVI   BROWMSG,15
         MVC   BROWMSG+1(15),91(R1) ERROR DESCRIPTION ONLY
         OI    BRFSSW,SYNADSW
        SYNADRLS
         BR    R14
         EJECT
*------- CONSTANTS --------------------------------------------------*
BROSHL   DC    AL1(BROSHLL-1)
DSNMNM   EQU   (*-BROSHL)+1,54
         DC    XL1'05',CL54' ',12CL1'-'
SCRCOL   EQU   (*-BROSHL)+5,8
         DC    CL13' COL ... ... '
BROSHLL  EQU   *-BROSHL
CRBWSC   EQU   01                  CURSOR ROW ON LINE BELOW
ZIBD     EQU   (CRBWSC+1)*4        "TERMINPT" DISPLACEMENT
BROHD    DC    AL1(BROHDL-1)
         DC    XL1'05',CL12'COMMAND ===>'
CCBWSC   EQU   *-BROHD             CURSOR COLUMN ON FIELD BELOW
BWSCF1   EQU   (*-BROHD)+1,46      INPUT FIELD 1
         DC    XL1'01',CL46' '
         DC    XL1'05',CL11'< SCROLL =>'
BWSCF2   EQU   (*-BROHD)+1,4       INPUT FIELD 2
         DC    XL1'01',CL4' ',XL1'05',CL1'<',XL1'04'
BROHDL   EQU   *-BROHD
CRBWDT   EQU   04             ROW OF FIRST DATA LINE
         SPACE 1
HEXTAB   DC    CL16'0123456789ABCDEF' TRANSLATE TABLE
BRGMMSG  MSG   'GETMAIN FAILED'
MSG10    MSG   'UNABLE TO OPEN'
MSG11    MSG   'MEMBER NOT FOUND'
MSG20    MSG   'INVALID COMMAND'
MSG21    MSG   'INVALID PF-KEY'
MSG31    MSG   'STRING NOT SPECIFIED'
MSG32    MSG   'BOTTOM DATA REACHED'
MSG33    MSG   'FOUND AT COL. ....'
MSG33L   EQU   *-MSG33
MSG34    MSG   'STRING NULL'
MSG35    MSG   'STRING TOO LONG'
MSG36    MSG   'INVALID HEX-DIGIT'
MSG37    MSG   'HEX-STRING MISSING'
MSG38    MSG   'NULL HEX-STRING'
MSG39    MSG   'HEX-STRING ODD'
         SPACE 1
GMVC    GETMAIN VC,MF=L
BRODCB  DCB    DSORG=PS,MACRF=(RP),DDNAME=DUMMY,EODAD=*-*,SYNAD=*-*
BRODCBL  EQU   *-BRODCB
        READ   DYNDECB,SF,*-*,*-*,'S',MF=L
         PRINT &PRS
        LTORG
         PRINT &PRF
         SPACE 1
         DROP  R10,R11,R12,R13
         EJECT
*- - - - TRANSLATE TABLES
ASIST    DC    64X'4B',X'40',9X'4B'
         DC    X'4A4B4C4D4E4F'     CENT,PERIOD,LESS,LPAREN,PLUS,BAR
         DC    X'50',9X'4B'        AMPERSAND
         DC    X'5A5B5C5D5E5F'     EXCL,$,DOT,RPAREN,SEMI,NOT
         DC    X'6061',8X'4B'      HYPHEN,SLASH
         DC    X'6A6B6C6D6E6F'     WHAT,COMMA,PERCENT,UNDLN,GT,QM
         DC    9X'4B',X'79'
         DC    X'7A7B7C7D7E7F'     COLON,POUND,AT,QUOTE,EQ,DBLQUOTE
         DC    X'4B',X'818283848586878889',6X'4B'
         DC    X'4B',X'919293949596979899',6X'4B'
         DC    X'4B',X'A1A2A3A4A5A6A7A8A9',6X'4B'
         DC    16X'4B'
         DC    X'C0',C'ABCDEFGHI',6X'4B'
         DC    X'D0',C'JKLMNOPQR',6X'4B'
         DC    X'E0',X'4B',C'STUVWXYZ',6X'4B'
         DC    C'0123456789',6X'4B'
CAPST    DC    64X'4B',X'40',9X'4B'
         DC    X'4A4B4C4D4E4F'     CENT,PERIOD,LESS,LPAREN,PLUS,BAR
         DC    X'50',9X'4B'        AMPERSAND
         DC    X'5A5B5C5D5E5F'     EXCL,$,DOT,RPAREN,SEMI,NOT
         DC    X'6061',8X'4B'      HYPHEN,SLASH
         DC    X'6A6B6C6D6E6F'     WHAT,COMMA,PERCENT,UNDLN,GT,QM
         DC    9X'4B',X'79'
         DC    X'7A7B7C7D7E7F'     COLON,POUND,AT,QUOTE,EQ,DBLQUOTE
         DC    X'4B',C'ABCDEFGHI',6X'4B'
         DC    X'4B',C'JKLMNOPQR',6X'4B'
         DC    2X'4B',C'STUVWXYZ',6X'4B'
         DC    16X'4B'
         DC    X'C0',C'ABCDEFGHI',6X'4B'
         DC    X'D0',C'JKLMNOPQR',6X'4B'
         DC    X'E0',X'4B',C'STUVWXYZ',6X'4B'
         DC    C'0123456789',6X'4B'
         SPACE 1
MARKS    DC    9CL10'----+----+'
MARKH    DC    9CL10' - - - - +'
         EJECT
*------- BROWSE INTERFACE HELP SCREEN -------------------------------*
         CNOP  0,4
BROHELP  DC    A(BROHL1)
         DC    A(BROENT)
         DC    A(BROHL2)
         DC    A(BROHL3)
         DC    A(BROHL4)
         DC    A(BROHL5)
         DC    A(BROHL6)
         DC    A(BROHL7)
         DC    A(BROHL8)
         DC    A(BROBLK)
         DC    A(BROHL9)
         DC    A(EML+BROHL10)
         SPACE 1
BROHL1   DC    AL1(BROHL1L-1)
         DC    XL1'05',10CL1'-'    PROTECT, HIGH-LIGHT
         DC    CL18' BROWSE INTERFACE ',51CL1'-'
BROHL1L  EQU   *-BROHL1
*                ----+----1----+----2----+----3----+----4----+----5----
*              +----6----+----7----+----
BROHL2   DC    AL1(BROHL2L-1),XL1'05'
         DC    C'COMMANDS ARE :'
BROHL2L  EQU   *-BROHL2
BROHL3   DC    AL1(BROHL3L-1),XL1'05'
         DC    C' LEFT, L OR <         / RIGHT, R OR >        SCREEN SHX
               IFTED BY 80-C OR 40-HEX'
BROHL3L  EQU   *-BROHL3
BROHL4   DC    AL1(BROHL4L-1),XL1'05'
         DC    C' UP, U OR -           / DOWN, D OR +         FOLLOWED X
               BY "M" OR A NUMBER'
BROHL4L  EQU   *-BROHL4
BROHL5   DC    AL1(BROHL5L-1),XL1'05'
         DC    C' TOP OR T             / BOTTOM, BOT OR B'
BROHL5L  EQU   *-BROHL5
BROHL6   DC    AL1(BROHL6L-1),XL1'05'
         DC    C' CAPS OR C            / ASIS OR A'
BROHL6L  EQU   *-BROHL6
BROHL7   DC    AL1(BROHL7L-1),XL1'05'
         DC    C' HEX OR H (FLIP-FLOP BETWEEN NORMAL AND HEX DISPLAY)'
BROHL7L  EQU   *-BROHL7
BROHL8   DC    AL1(BROHL8L-1),XL1'05'
         DC    C' FIND OR F ...STRING... OR X''...HEX-STRING...'
BROHL8L  EQU   *-BROHL8
BROHL9   DC    AL1(BROHL9L-1),XL1'05'
         DC    C'SCROLL : P(AGE) BY DEFAULT, H(ALF) OR C(SR)'
BROHL9L  EQU   *-BROHL9
BROHL10  DC    AL1(BROHL10L-1),XL1'05'
         DC    C'PFK''S :  3-4=END, 5=FIND, 7=UP, 8=DOWN, 10=LEFT AND 1X
               1=RIGHT'
BROHL10L EQU   *-BROHL10
BROENT   DC    AL1(BROENTL-1),XL1'01',CL1' ',XL1'05',CL7' '
BROENTL  EQU   *-BROENT
BROBLK   DC    AL1(BROBLKL-1),XL1'05',CL9' '
BROBLKL  EQU   *-BROBLK
         EJECT
         PRINT &PRS
        SPLTAREA
         SPACE 1
        MYSAVE
         PRINT &PRF
        IEFZB4D0
        DCBD   DSORG=(PS,PO),DEVD=DA
        IHADECB
        IEZIOB
         PRINT GEN
         END
