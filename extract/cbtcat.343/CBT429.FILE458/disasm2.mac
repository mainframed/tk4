DIS2     TITLE '*** DISASSEMBLY PHASE 2 ***'
         PRINT OFF                                                 -EU-
         COPY  DISASMM                                             -EU-
         PRINT ON                                                  -EU-
DISASM2  SVLNK R3,R4
         EJECT
         PRINT NOGEN
* THIS SUB-PROGRAM IS CALLED BY DISASM AFTER THE DIRECTORY
* ENTRY AND LOAD MODULE ARE PROCESSED. THE ESD AND RLD
* ENTRIES HAVE BEEN USED TO CREATE A PROGRAM LABEL TABLE,
* AND MODULE TEXT IS IN AN AREA OF STORAGE. A COMMON PARAMETER
* AREA IS DEFINED IN DISASM, AND PASSED TO THIS PROGRAM.
*
* TEXT BYTES ARE USED TO CREATE ASSEMBLY LANGUAGE STATEMENTS,
* AND MACHINE INSTRUCTION STATEMENTS. OUTPUT IS WRITTEN
* TO THE WORK1 DATASET FOR FURTHER PROCESSING BY OTHER
* MODULES.
*   A TEXT BYTE IS CONSIDERED TO BE AN INSTRUCTION IF
* IT OCCURS ON A HALFWORD BOUNDARY, IS A VALID OP-CODE,
* AND IS FOLLOWED BY A VALID OP-CODE. UNCONDITIONAL BRANCHES
* NEED NOT BE FOLLOWED BY A VALID OP-CODE, HOWEVER. THE
* PRIVILEGED AND FLOATING POINT INSTRUCTIONS ARE NOT
* TREATED AS INSTRUCTIONS UNLESS THE USER SPECIFIED
* THEIR INCLUSION AT EXEC TIME.
*
*
* AUTHOR R THORNTON - NOV 1977
*        UPDATES (MARKED -EU- IN COLUMNS 68-71) DONE BY            -EU-
*        MOINIL P.A. , COMPUTING CENTRE                            -EU-
*                      J.R.C. - ISPRA ESTABLISHMENT                -EU-
*                      21020 ISPRA (VA), ITALY                     -EU-
         EJECT
******************************************************************
*                                                                *
* MAINLINE ROUTINE FOR DISASSEMBLY. EACH BYTE OF TEXT IS CHECKED *
* TO DETERMINE WHETHER IT MAY BE AN INSTRUCTION OP-CODE. IF NOT, *
* THE CONST ROUTINE IS PERFORMED TO HANDLE CONSTANT DATA. IF IT  *
* APPEARS TO BE AN OP-CODE, THE INSTR ROUTINE IS PERFORMED.      *
* WHEN TEXT IS EXHAUSTED, THIS PHASE TERMINATES.                 *
*                                                                *
******************************************************************
         SPACE 1
         L     R5,0(R1)                GET PARM FIELD ADDRESS
         USING COMMPARM,R5
         L     R6,LBLTBL               @ LABEL TABLE
         USING LABELD,R6
         MVC   TXTCURR,TXTSTRT         COPY TEXT START ADDR
GETCURR  L     R7,TXTCURR              @ CURRENT TXT BYTE
         C     R7,TXTEND               END OF TEXT
         BNL   EOJ                     YES          FIX******
         LR    R12,R7                  COPY TEXT ADDR
         S     R12,TXTSTRT             COMPUTE OFFSET
         ST    R12,TXTOFST             SAVE OFFSET TO THIS BYTE
         CLC   NEXCHG,TXTOFSET         TIME TO CHANGE BASES
         BH    CKDARNG                 NO
         BAS   R9,NEXUSG               YES, GO DO IT
CKDARNG  L     R12,DATONLY             GET DATA ONLY TBL ADDR
         CLC   TXTOFSET,0(R12)         RANGE BEGINS LATER
         BL    CKLOSEQ                 YES
         CLC   TXTOFSET,3(R12)         THIS BYTE IN THE RANGE
         BNH   CONST                   YES
         LA    R12,6(R12)              PAST THIS ENTRY, STEP OVER 1
         ST    R12,DATONLY             SAVE UPDATED ADDR
         B     CKDARNG                 GO CHECK AGAIN
CKLOSEQ  CLC   TXTOFSET,LBLADR         LABEL ENTRY OUT OF SEQ
         BNH   GCKODD                  NO, CONTINUE
         BAS   R9,FORCONST             YES, FORCE ANY CONSTANT OUT
         MVC   NAME,LBLNAME            NAME TO OUTPUT
         MVC   MNEMONIC,=CL5'EQU'      MNEMONIC
         MVI   OPNDS,C'*'              OPERAND
         MVC   COMMENT(14),=14C'?'     SHOW ERROR
         BAS   R9,WRTOUT               WRITE ERROR RECORD
         BAS   R9,PRINT                GO PRINT IT
         LA    R6,L'LABEL(R6)          TO NEXT LABEL
         B     CKLOSEQ                 CONTINUE SEQ CHK
GCKODD   TM    TXTCURR+3,1             ODD ADDRESS
         BO    CONST                   YES, NOT INSTR
         CLC   1(3,R7),0(R7)           4 CONSEC IDENTICAL BYTES
         BE    CONST                   YES, NOT INSTR
         L     R8,=A(CHARTRAN)                                     -EU-
         TRT   0(1,R7),0(R8)           TEST TEXT BYTE              -EU-
         BNZ   CKINSTR                 NOT CHARACTER
         CLI   CONPROG,1               IS CONSTANT IN PROGRESS
         BNE   CK6                     NO
         CLI   CONTYPE,C'C'            IS IT CHARACTER TYPE
         BE    CONST                   YES, ADD THIS TO CONSTANT
CK6      TRT   0(6,R7),0(R8)           6 CONSECUTIVE CHARACTERS    -EU-
         BZ    CONST                   YES, NOT INSTRUCTION
CKINSTR  XR    R8,R8                   CLEAR WORK
         IC    R8,0(R7)                PICK UP TXT BYTE
         MH    R8,SGLOPL               TIMES TABLE LENGTH          -EU-
         AL    R8,SGLOPAD              @ INSTR TBL ENTRY           -EU-
         MVC   INSTENT,0(R8)           SAVE INSTRUCTION TBL ENTRY
         CLI   INAME,0                 IS IT AN INSTR OP-CODE
         BE    CONST                   NO
         CLI   ITYPE,TWO               TWO-BYTE OP-CODE
         BNE   INSTR                   NO
         L     R8,DBLOPAD              YES, GET 2-BYTE TBL ADDR
DBLND    CLI   0(R8),X'FF'             END OF TABLE
         BE    CONST                   YES, NOT INSTR
         CLC   0(2,R8),0(R7)           THIS ENTRY MATCHES TXT
         BE    GOTDBLI                 YES
         AH    R8,DBLOPL               TO NEXT ENTRY               -EU-
         B     DBLND                   LOOP THRU TBL
GOTDBLI  LA    R8,2(R8)                PASS OP-CODE BYTES
         MVC   INSTENT,0(R8)           SAVE INSTR TBL ENTRY
         EJECT
******************************************************************
*                                                                *
* THIS ROUTINE IS ENTERED WHEN CURSORY CHECKS IN THE MAINLINE    *
* INDICATE THIS TEXT BYTE IS AN INSTRUCTION OP-CODE. FURTHER     *
* TESTING IS DONE BY THE IVERFY (NON-FLOATING POINT), OR FPVERFY *
* (FLOATING POINT) ROUTINES. BYTES PASSING THESE TESTS ARE       *
* ACCEPTED AS OP-CODES, AND ARE PASSED TO THE APPROPRIATE FORMAT *
* ROUTINES. FORMAT ROUTINES ARE ENTERED VIA A BRANCH TABLE USING *
* A BYTE IN THE INSTRUCTION OP-CODE TABLE ENTRY.                 *
*                                                                *
******************************************************************
         SPACE 1
INSTR    MVC   ILENG+1(1),INLNG        SET INSTR LENGTH
         LH    R12,ILENG               PICK UP LENGTH
         AR    R12,R7                  ADDR OF NEXT OP CODE
         XR    R15,R15                 CLEAR WORK
         IC    R15,0(R12)              PICK UP NEXT OP-CODE
         MH    R15,SGLOPL              TIMES TBL ENTRY LENG        -EU-
         AL    R15,SGLOPAD             INSTR TBL ENTRY ADDR        -EU-
         CLI   INAME-INSTENT(R15),0    IS IT AN OP-CODE
         BNE   ICKSEC                  YES
POSSB    CLI   0(R7),X'45'             IS IT BAL                   -EU-
         BE    ICKTBL                  YES, CONTINUE
         CLI   0(R7),X'07'             NO, IS IT BRANCH
         BE    POSSB1                  YES
         CLI   0(R7),X'47'             IS IT BRANCH
         BNE   CONST                   NO, THEN THIS NOT INSTR
POSSB1   TM    1(R7),X'F0'             IS IT UNCOND BRANCH
         BNO   CONST                   NO, THEN THIS NOT INSTR
         B     ICKTBL                  ACCEPT UNCOND BRANCHES
ICKSEC   XR    R1,R1                   CLEAR WORK
         IC    R1,INLNG-INSTENT(R15)   GET INSTR LENGTH
         AR    R1,R12                  ADDR OF NEXT OP CODE
         XR    R14,R14                 CLEAR WORK
         IC    R14,0(R1)               PICK UP NEXT OP-CODE
         MH    R14,SGLOPL              TIMES TBL ENTRY LENG        -EU-
         AL    R14,SGLOPAD             INSTR TBL ENTRY ADDR        -EU-
         CLI   INAME-INSTENT(R14),0    IS IT AN OP-CODE
         BNE   ICKTBL                  YES
         CLI   0(R12),X'45'            IS IT BAL
         BE    ICKTBL                  YES, CONTINUE
         CLI   0(R12),X'07'            NO, IS IT BRANCH
         BE    POSSB2                  YES
         CLI   0(R12),X'47'            IS IT BRANCH
         BNE   POSSB                   NO, BUT SEE CURRENT INSTR   -EU-
POSSB2   TM    1(R12),X'F0'            IS IT UNCOND BRANCH
         BNO   CONST                   NO, THEN THIS NOT INSTR
ICKTBL   LH    R12,ILENG               GET INSTR LENGTH
         AR    R12,R7                  @ NEXT TEXT LOC
         BCTR  R12,0                   BACK UP 1
         S     R12,TXTSTRT             RELATIVIZE IN CSECT
         CLM   R12,B'0111',LBLADR      LBL TBL ADDR HERE
         BL    NOILBL                  NO
         CLC   TXTOFSET,LBLADR         LABEL AT INSTR START
         BNE   NOTINST                 NO, MUST BE CONSTANT      FIX***
         CLI   LBLTYP,C'L'             IS IT A LABEL ONLY
         BNE   NOTINST                 NO                        FIX***
         CLI   CONPROG,1               CONSTANT IN PROGRESS
         BNE   CKLBLNG                 NO
         BAS   R9,FORCONST             YES, FORCE IT OUT
CKLBLNG  CLC   LBLLEN,INLNG            LENGTHS SAME
         BE    SETLBL                  YES
         CLI   LBLLEN,0                DON'T CARE LENGTH
         BE    SETLBL                  YES
         BAS   R9,EQUSTMT              NO, BUILD EQU STATEMENT
         B     ISTPLBL                 CONTINUE
SETLBL   MVC   NAME,LBLNAME            LABEL ENTRY NAME TO INSTR
         MVC   CONLEN,LBLLEN           SET CONSTANT LENGTH IN CASE
ISTPLBL  LA    R6,L'LABEL(R6)          TO NEXT LABEL TBL ENTRY
         CLM   R6,B'0111',LBLADR       THIS ENTRY SAME ADDR
         BNE   ICKTBL                  NO
         SH    R6,LBLLGTH              BACK UP TO 1ST ENTRY
         BAS   R9,EQUSTMT              GO BUILD EQU STATEMENT
         LA    R6,L'LABEL(R6)          TO NEXT ENTRY
         B     ICKTBL                  GO CHECK NEXT LABEL
NOILBL   CLI   CONPROG,1               CONSTANT IN PROGRESS
         BNE   MVMNE                   NO
         BAS   R9,FORCONST             YES, FORCE IT OUT
MVMNE    MVC   MNEMONIC,0(R8)          SET INSTR MNEMONIC
         MVC   OFFSET,TXTOFSET         SET OFFSET
         MVC   INSTYP,5(R8)            SET INSTR TYPE
         MVI   TYPE,X'0D'              SHOW IT IS AN INSTRUCTION
         MVC   LEN,ILENG+1             SHOW LENGTH
         MVC   TEXT(6),0(R7)           MOVE ACTUAL TEXT
         TM    ICLASS,FLTPT            FLOATING POINT OP-CODE
         BO    FPVERFY                 YES, GO VERIFY
         CLI   IEDT,0                  ANY EDIT REQUIRED
         BNE   IVERFY                  YES, GO EDIT
PFMFMT   XR    R1,R1                   CLEAR WORK
         IC    R1,INSTYP               GET INSTRUCTION TYPE
         L     R9,OPND9                GET FORMAT ROUTINE RETURN ADDR
         B     *+L'*(R1) ------------- TO APPROPRIATE FORMAT ROUTINE
         B     RROPND                  TYPE=0, RR
         B     RXOPND                  TYPE=4, RX
         B     SOPND                   TYPE=8, S
         B     SIOPND                  TYPE=12, SI
         B     RSOPND                  TYPE=16, RS
         B     SS1OPND                 TYPE=20, 1-LENGTH SS
         B     SS2OPND                 TYPE=24, 2-LENGTH SS
         B     SOPND                   TYPE=28, 2-BYTE OP-CODES
         B     BCOPND                  TYPE=32, CONDITIONAL BRANCH
         B     SVCOPND                 TYPE=36, SVC
         B     SSROPND                 TYPE=40, 2 REGISTERS SS     -EU-
         B     RREOPND                 TYPE=44, 2 REGISTERS RRE    -EU-
         B     SSEOPND                 TYPE=48, SSE                -EU-
         SPACE 1                                                   -EU-
OPNDRTN  B     INSTOUT                 NORMAL OPERAND FORMAT RETURN
         MVC   CONNAME,NAME            ANY NAME TO CONSTANT AREA
         B     CONST                   ERROR INSTRUCTION, TREAT AS CONS
NOTINST  CLC   NAME,BLANX              IS NAME FILLED IN?        FIX***
         BE    CONST                                             FIX***
         SH    R6,LBLLGTH              BACK UP                   FIX***
         B     CONST                                             FIX***
INSTOUT  BAS   R9,WRTOUT               WRITE INSTRUCTION RECORD
         BAS   R9,TXTFMT               FORMAT HEX DATA
         BAS   R9,PRINT                GO PRINT IT
         AH    R7,ILENG                STEP TO NEXT TEXT BYTE
         ST    R7,TXTCURR              SAVE NEXT ADDR
         CLI   ICCSET,0                ANY COND CODE SET TYPE      -EU-
         BE    GETCURR                 NO, CONTINUE TXT PROCESSING -EU-
         MVC   CCTYPE,ICCSET           SHOW COND CODE SET TYPE
         B     GETCURR                 CONTINUE TXT PROCESSING
         EJECT
******************************************************************
*                                                                *
* THIS ROUTINE IS ENTERED FROM THE INSTR ROUTINE FOR NON FLOATING*
* POINT INSTRUCTIONS. VARIOUS EDITS ARE PERFORMED TO INSURE THE  *
* INPUT TEXT BYTE IS AN OP-CODE. IF IT IS, RETURN IS TO LABEL    *
* PFMFMT, OTHERWISE THE CONST ROUTINE IS PERFORMED.              *
*                                                                *
******************************************************************
         SPACE 1
IVERFY   TM    IEDT,EPR                EVEN-ODD REG PAIR
         BZ    IVE2                    NO
         TM    1(R7),X'10'             R1 IS ODD
         BO    CONST                   YES, NOT INSTR
         CLI   0(R7),X'0E'             IS IT MVCL
         BE    IVTRG2                  YES
         CLI   0(R7),X'0F'             IS IT CLCL
         BNE   IVE2                    NO
IVTRG2   TM    1(R7),X'01'             R2 IS ODD
         BO    CONST                   YES, NOT INSTR
         XR    R1,R1                   CLEAR WORK
         XR    R2,R2                   CLEAR WORK
         IC    R1,1(R7)                GET R1R2
         SRL   R1,4                    SHIFT OUT R2
         PACK  DBLWD(1),1(1,R7)        FLIP R1R2 BYTE
         IC    R2,DBLWD                PICK UP R2R1
         SRL   R2,4                    SHIFT OUT R1
         CR    R1,R2                   R1=R2
         BE    CONST                   YES, NOT INSTR
         B     PFMFMT                  NO, GOOD INSTR
IVE2     TM    IEDT,E2                 HALFWORD STORAGE ALIGNMENT
         BZ    IVE4                    NO
         TM    3(R7),X'01'             DISPL IS ODD
         BZ    IVES2                   NO, O.K.
         TM    2(R7),X'F0'             BASE REG = 0
         BNZ   IVES2                   NO, CONTINUE
         CLI   0(R7),X'44'             EX OP CODE
         BE    CONST                   YES, NOT INSTR
         CLI   0(R7),X'47'             BC OP CODE
         BE    CONST                   YES, NOT INSTR
         CLI   ITYPE,RS                RS INSTRUCTION
         BE    CONST                   YES, NOT INSTR
         TM    1(R7),X'0F'             INDEX REG IS 0
         BZ    CONST                   YES, NOT INSTR
         B     IVES2                   CONTINUE
IVE4     TM    IEDT,E4                 2ND OPND ON FULLWORD BOUND
         BZ    IVE8                    NO
         TM    3(R7),X'03'             DISPL DIV BY 4
         BZ    IVES2                   YES, O.K.
         TM    2(R7),X'F0'             BASE REG = 0
         BNZ   IVES2                   NO, CONTINUE
         CLI   ITYPE,RS                RS INSTRUCTION OP CODE
         BE    CONST                   YES, NOT INSTR
         TM    1(R7),X'0F'             INDEX REG = 0
         BZ    CONST                   YES, NOT INSTR
         B     IVES2                   NO, CONTINUE
IVE8     TM    IEDT,E8                 2ND OPND ON DBLWD BOUND
         BZ    IVES2                   NO
         TM    3(R7),X'07'             DISPL DIV BY 8
         BZ    IVES2                   YES, O.K.
         TM    2(R7),X'F0'             BASE REG = 0
         BNZ   IVES2                   NO
         CLI   ITYPE,S                 S INSTRUCTION OP CODE       -EU-
         BE    CONST                   YES, NOT INSTRUCTION        -EU-
         CLI   ITYPE,SSE               SSE INSTRUCTION OP CODE     -EU-
         BE    CONST                   YES, NOT INSTRUCTION        -EU-
         TM    1(R7),X'0F'             INDEX REG = 0
         BZ    CONST                   YES, NOT INSTR
IVES2    CLI   PRIVASM,1               PRIVILEGED INSTR O.K.
         BE    PFMFMT                  YES
         TM    IEDT,S2                 OPND2 MUST HAVE BASE
         BZ    IVES1                   NO
         TM    2(R7),X'F0'             BASE REG = 0
         BNZ   PFMFMT                  NO, O.K.
         CLI   ITYPE,RS                RS INSTRUCTION
         BE    CONST                   YES, NOT INSTR
         CLI   ITYPE,S                 S INSTRUCTION               -EU-
         BE    CONST                   YES, NOT INSTR              -EU-
         CLI   0(R7),X'92'             IS IT MVI OP CODE
         BE    CONST                   YES, NOT INSTR
         TM    1(R7),X'0F'             INDEX REG = 0
         BZ    CONST                   YES, NOT INSTR
         B     PFMFMT                  NO, GOOD INSTR
IVES1    TM    IEDT,S1                 1ST OPND MUST HAVE BASE
         BZ    PFMFMT                  NO, CONTINUE
         TM    2(R7),X'F0'             1ST OPND HAS BASE
         BZ    CONST                   NO, NOT INSTR
         B     PFMFMT                  YES, INSTR O.K.
         EJECT
******************************************************************
*                                                                *
* THIS ROUTINE IS ENTERED FROM THE INSTR ROUTINE FOR FLOATING    *
* POINT INSTRUCTIONS. VARIOUS EDITS ARE PERFORMED TO INSURE THE  *
* INPUT TEXT BYTE IS AN OP-CODE. IF IT IS, RETURN IS TO LABEL    *
* PFMFMT, OTHERWISE THE CONST ROUTINE IS PERFORMED.              *
*                                                                *
******************************************************************
         SPACE 1
FPVERFY  TM    ICLASS,FLEXR            EXTENDED FLT PT INSTR       -EU-
         BZ    FPVERFP                 NO                          -EU-
         TM    3(R7),X'BB'             0 OR 4 ONLY                 -EU-
         BZ    PFMFMT                  YES, GOOD INSTR             -EU-
         B     CONST                   NO, NOT INSTR               -EU-
FPVERFP  TM    1(R7),X'90'             R1 IS 0, 2, 4, OR 6         -EU-
         BNZ   CONST                   NO, NOT INSTR
         CLI   0(R7),X'27'             MXDR OP-CODE
         BE    FPR1EXT                 YES
         CLI   0(R7),X'67'             MXD OP-CODE
         BNE   FPCKTYP                 NO
FPR1EXT  TM    1(R7),X'B0'             R1 IS 0 OR 4
         BNZ   CONST                   NO, NOT INSTR
FPCKTYP  CLI   ITYPE,RR                RR TYPE INSTRUCTION
         BNE   FPRXVER                 NO
         TM    1(R7),X'09'             R2 IS 0, 2, 4, 6
         BNZ   CONST                   NO, NOT INSTR
         CLI   0(R7),X'25'             LRDR OP CODE
         BE    FPR2EXT                 YES
         CLI   0(R7),X'37'             SXR OP-CODE
         BE    FPR2EXT                 YES
         CLI   0(R7),X'26'             MXR OP-CODE
         BE    FPR2EXT                 YES
         CLI   0(R7),X'36'             AXR OP-CODE
         BNE   PFMFMT                  NO, GOOD INSTR
FPR2EXT  TM    1(R7),X'0B'             R2 IS 0 OR 4
         BZ    PFMFMT                  YES, GOOD INSTR
         B     CONST                   NO, NOT INSTR
FPRXVER  CLI   PRIVASM,1               PRIVILEGED INSTRUCTIONS O.K.
         BE    FPALIGN                 YES
         TM    2(R7),X'F0'             ANT BASE REG
         BNZ   FPALIGN                 YES
         TM    1(R7),X'0F'             ANY INDEX REG
         BZ    CONST                   NO, NOT INSTR
FPALIGN  TM    2(R7),X'F0'             ANY BASE REG
         BNZ   PFMFMT                  YES, ACCEPT INSTR
         TM    1(R7),X'0F'             ANY INDEX REG
         BNZ   PFMFMT                  YES, ACCEPT INSTR
         TM    3(R7),X'03'             DISPL DIV BY 4
         BNZ   CONST                   NO, NOT INSTR
         TM    ICLASS,FLSHT            SHORT PRECISION
         BO    PFMFMT                  YES, ACCEPT INSTRUCTION
         TM    3(R7),X'07'             DISPL DIV BY 8
         BZ    PFMFMT                  YES, ACCEPT INSTR
         B     CONST                   NO, NOT INSTR
         EJECT
******************************************************************
*                                                                *
* THIS ROUTINE IS ENTERED FROM VARIOUS OTHER ROUTINES WHEN THE   *
* CURRENT TEXT BYTE IS DETERMINED NOT TO BE AN INSTRUCTION OP    *
* CODE. A CONSTANT AREA IS BUILT TO CONTAIN THE CONSTANT, IT'S   *
* DATA TYPE, SYMBOL TO BE USED FOR ADCONS, LABEL TO BE USED, IF  *
* ANY, ETC. THE CONSTANT IS BUILT BYTE BY BYTE, AND IS TERMINATED*
* FOR OUTPUT BY THE FORCONST ROUTINE. THIS ROUTINE DETECTS END OF*
* CONSTANT WHEN THE CONSTANT IN PROGRESS EXCEEDS 2 BYTES FOR A   *
* HALFWORD, 4 BYTES FOR A FULLWORD, OR 8 BYTES AS A MAXIMUM. IT  *
* IS ALSO TERMINATED WHEN A CHANGE IN DATA TYPE OCCURS.          *
*                                                                *
******************************************************************
         SPACE 1
CONST    MVC   WORKREC,BLANX           CLEAR WORK RECORD AREA
         CLI   CONPROG,1               CONSTANT IN PROGRESS
         BNE   CCNEW                   NO
         CLC   TXTOFSET,LBLADR         LABEL ENTRY HAS THIS OFFSET
         BNE   CGETYP                  NO
CSTNEW   BAS   R9,FORCONST             FORCE IT OUT
         B     CCNEW                   GO START A NEW ONE
CGETYP   L     R11,=A(CHARTRAN)                                    -EU-
         TRT   0(1,R7),0(R11)          CHECK DATA TYPE OF BYTE     -EU-
         BNZ   CHEX                    IT'S HEX
         MVI   CCKTYP+1,C'C'           SET TYPE IN COMPARE
         B     CCKTYP                  GO COMPARE
CHEX     MVI   CCKTYP+1,C'X'           SET TYPE IN COMPARE
CCKTYP   CLI   CONTYPE,C' '            TYPE IN PROG SAME AS THIS BYTE
         BNE   CSTNEW                  NO
CUPDCON  LH    R11,CONLEN              GET CURRENT LENGTH
         LA    R11,1(R11)              ADD 1
         STH   R11,CONLEN              UPDATE LENGTH
         L     R11,CONLOC              GET CURRENT LOC IN CONST DATA
         MVC   0(1,R11),0(R7)          MOVE BYTE TO DATA
         LA    R11,1(R11)              STEP OVER ONE BYTE
         ST    R11,CONLOC              SAVE UPDATED DATA ADDR
         CLI   CONTYPE,C'C'            CHARACTER CONSTANT
         BE    CCK8                    YES
         TM    CONOFST+3,1             OFFSET IS ODD
         BO    CCFIN1                  YES
         TM    CONOFST+3,2             HALFWORD OFFSET
         BZ    CCFWD                   NO
         CLI   CONLEN+1,1              HALFWORD, IS LENGTH = 1
         BE    CCXIT1                  YES
         B     CCFIN1                  NO
CCFWD    CLI   CONLEN+1,4              NO, IS HEX CONST 4 BYTES
         BL    CCXIT1                  NOT YET
CCFIN1   BAS   R9,FORCONST             MAX LENG, FORCE IT OUT
         B     CCXIT1                  FINISH
CCK8     CLC   CONLEN,H8               CHAR CONSTANT 8 BYTES
         BNL   CCFIN1                  YES
CCXIT1   LA    R7,1(R7)                STEP OVER 1 BYTE IN TEXT
         ST    R7,TXTCURR              UPDATE TEXT ADDR
         B     GETCURR                 CONTINUE TEXT PROCESSING
CCNEW    MVI   CONPROG,1               SHOW CONSTANT IN PROGRESS
         MVC   CONOFST,TXTOFST         SET OFFSET TO 1ST BYTE
         MVC   CONNAME,BLANX           CLEAR NAME
         XC    CONDATA,CONDATA         CLEAR DATA AREA
         MVC   CONSYM,BLANX            CLEAR SYMBOL NAME
         MVC   CONLEN,XZROS            CLEAR LENGTH
         LA    R11,CONDATA             GET 1ST DATA BYTE ADDR
         ST    R11,CONLOC              SET STARTING ADDRESS OF DATA
         CLC   TXTOFSET,LBLADR         LABEL AT THIS OFFSET
         BE    CLBLD                   YES
TRTYPE   L     R11,=A(CHARTRAN)                                    -EU-
         TRT   0(1,R7),0(R11)          CHECK DATA TYPE OF BYTE     -EU-
         BNZ   CCSHX                   IT'S HEX
         MVI   CONTYPE,C'C'            IT'S CHAR, SO INDICATE
         B     CUPDCON                 GO COMPLETE
CCSHX    MVI   CONTYPE,C'X'            IT'S HEX, SO INDICATE
         B     CUPDCON                 GO COMPLETE
CLBLD    CLI   LBLTYP,C'L'             IS IT A LABEL ONLY
         BNE   CDATACON                NO
         MVC   CONNAME,LBLNAME         NAME TO CONSTANT WORK AREA
         MVC   CONLLEN,LBLLEN         SAVE LENGTH
         LA    R6,L'LABEL(R6)          TO NEXT LABEL ENTRY
         CLC   TXTOFSET,LBLADR         THIS LABEL AT SAME ADDR
         BNE   TRTYPE                  NO
         CLI   LBLTYP,C'L'             THIS ANOTHER LABEL ONLY
         BNE   CDATACON                NO
         SH    R6,LBLLGTH             BACK UP TO LABEL ENTRY
         BAS   R9,EQUSTMT             GO BUILD EQU STATEMENT
         LA    R6,L'LABEL(R6)          TO NEXT LABELENTRY
         B     CCNEW                   GO TO NEXT LABEL
CDATACON MVC   CONTYPE,LBLTYP          TYPE TO CONSTANT AREA
         XR    R1,R1                   CLEAR WORK
         IC    R1,LBLLEN               PICK UP CONSTNT LENGTH
         STH   R1,CONLEN               SAVE CONSTANT LENGTH
         BCTR  R1,0                    COMPUTE CONSTANT LENGTH CODE
         STC   R1,*+L'*+1              SET MOVE LENGTH CODE
         MVC   CONDATA(*-*),0(R7)      MOVE DATA TO RECORD
         MVC   CONSYM,LBLNAME          SYMBOL TO CONSTANT AREA
         XR    R11,R11                 CLEAR WORK REG
         IC    R11,LBLLEN              PICK UP LENGTH
         AR    R7,R11                  STEP PAST TEXT
         ST    R7,TXTCURR              UPDATE TEXT ADDRESS
         BAS   R9,FORCONST             FORCE CONSTANT OUT
         LA    R6,L'LABEL(R6)          STEP TO NEXT LABEL ENTRY
         B     GETCURR                 CONTINUE TEXT PROCESS
         EJECT
******************************************************************
*                                                                *
* THIS ROUTINE IS ENTERED BY VARIOUS ROUTINES WHEN IT IS         *
* NECESSARY TO WRITE THE CONSTANT CURRENTLY IN PROGRESS, AND     *
* CLEAR FIELDS FOR THE NEXT CONSTANT TO BE CREATED.              *
*                                                                *
******************************************************************
         SPACE 1
FORCONST ST    R9,FC9                  SAVE RETURN ADDR
         CLC   CONNAME,BLANX           ANY LABEL NAME SET UP
         BE    CKCNPRG                 NO, CONTINUE
         CLC   CONLLEN,CONLEN+1        LENGTHS SAME
         BE    CKCNPRG                 YES, CONTINUE
         ST    R6,FC6                  SAVE LABEL TABLE ADDR
         LA    R6,CONPSLBL             @ PSEUDO LABEL ENTRY
         BAS   R9,EQUSTMT              GO BUILD EQU STATEMENT
         MVC   CONNAME,BLANX           CLEAR STATEMENT LABEL FIELD
         L     R6,FC6                  RESTORE LABEL TABLE POINTER
CKCNPRG  CLI   CONPROG,1               CONSTANT IN PROGRESS
         BNE   FCCLR                   NO
         CLI   CONLEN+1,0              ANY DATA LENGTH
         BE    FCCLR                   NO
         XC    TEXT,TEXT               CLEAR TEXT FIELD
         MVC   MNEMONIC(2),=C'DC'      SET MNEMONIC
         MVC   OPNDS(1),CONTYPE        SET TYPE
         MVI   OPNDS+1,C''''           OPERAND DELIMITER
         MVC   NAME,CONNAME            NAME TO RECORD
         MVC   OFFSET,CONOFST+1        OFFSET TO RECORD
         MVI   INSTYP,0                NOT AN INSTRUCTION
         MVI   TYPE,2                  NON-ADDRESS CONSTANT
         MVC   LEN,CONLEN+1            DATA LENGTH
         LH    R11,CONLEN              DATA LENGTH
         BCTR  R11,0                   DATA LENGTH CODE
         STC   R11,*+L'*+1             MOVE LENGTH TO MVC
         MVC   TEXT(*-*),CONDATA       DATA TO RECORD
         CLI   CONTYPE,C'C'            CHARACTER TYPE
         BE    FCHAR                   YES
         CLI   CONTYPE,C'X'            HEX TYPE
         BNE   FSYMBOL                 NO
         TM    CONOFST+3,1             OFFSET TO CONSTANT IS ODD
         BO    FHEX                    YES
         TM    CONLEN+1,1              LENGTH IS ODD
         BO    FHEX                    YES
         TM    CONOFST+3,2             OFFSET DIVISIBLE BY 4
         BO    FHWD                    NO
         CLI   CONLEN+1,4              IS IT 4-BYTES
         BNE   FHWD                    NO, JUST HALFWORD
         CLC   CONDATA(4),XZROS        CONSTANT IS ALL ZEROS
         BNE   FFCKNEG                 NO
         MVC   OPNDS(4),=C'F''0'''     BUILD OPERANDS
         B     FCWRT                   CONTINUE
FFCKNEG  ICM   R11,B'1111',CONDATA     GET DATA
         BM    FHEX                    NEG, TREAT AS HEX
         C     R11,=F'99999'           VALUE EXCEEDS 99,999
         BH    FHEX                    YES, TREAT AS HEX
         MVC   OPNDS(2),=C'F'''        OPERAND DATA TYPE IS F
         CVD   R11,DBLWD               CONVERT VALUE TO PACKED
         UNPK  OPNDS+2(5),DBLWD+5(3)   UNPACK INTO OPERAND
         OI    OPNDS+6,C'0'            SET SIGN = F
         MVI   OPNDS+7,C''''           ENDING QUOTE
         B     FCWRT                   CONTINUE
FHWD     LH    R11,CONDATA             PICK UP HALFWORD
         LTR   R11,R11                 TEST CONSTANT VALUE
         BM    FHEX                    NEGATIVE, TREAT AS HEX
         BNZ   FHCMAX                  NOT ZERO, CHECK MAX VALUE
         MVC   OPNDS(4),=C'H''0'''     SET OPERAND FOR ZERO
         B     FCWRT                   CONTINUE
FHCMAX   CH    R11,=H'9999'            VALUE EXCEEDS 9,999
         BH    FHEX                    YES, TREAT AS HEX
         CVD   R11,DBLWD               CONVERT TO PACKED
         OI    DBLWD+7,X'0F'           CLEAR SIGN TO F
         MVC   OPNDS(2),=C'H'''        SET DELIMITER IN OPERAND
         UNPK  OPNDS+2(4),DBLWD+5(3)   UNPACK VALUE TO OPERAND
         MVI   OPNDS+6,C''''           ENDING DELIMITER
         B     FCWRT                   CONTINUE
FCHAR    MVC   OPNDS(2),=C'C'''        OPERAND DELIMITER FOR CHARACTER
         LH    R11,CONLEN              GET DATA LENGTH
         BCTR  R11,0                   LENGTH CODE
         STC   R11,*+L'*+1             SET MOVE LENGTH
         MVC   OPNDS+2(*-*),CONDATA    DATA TO OPERAND
         LA    R11,OPNDS+3(R11)        STEP PAST OPERAND DATA
         MVI   0(R11),C''''            ENDING QUOTE
         B     FCWRT                   CONTINUE
FSYMBOL  CLC   CONSYM,BLANX            IS IT BLANK
         BE    FHEX                    YES, TREAT AS HEX
         CLI   CONLEN+1,4              LENGTH IS 4
         BH    FHEX                    NO, GREATER
         BE    AC4                     YES, 4 BYTES
         CLI   CONLEN+1,3              LENGTH IS 3
         BE    AC3                     YES
         CLI   CONLEN+1,2              LENGTH IS 2
         BE    AC2                     YES
         MVC   OPNDS+1(2),=C'L1'       OPND LENGTH
         B     FSLHE1                  CONTINUE
AC2      MVC   OPNDS+1(2),=C'L2'       OPND LGTH
         B     FSLHE1                  CONTINUE
AC3      MVC   OPNDS+1(2),=C'L3'       OPND LENGTH
         B     FSLHE1                  CONTINUE
AC4      LA    R11,OPNDS+1             STEP TO ( POS
         B     FSLHE                   CONTINUE
FSLHE1   LA    R11,OPNDS+3             STEP TO ( POS
FSLHE    MVI   0(R11),C'('             DELIMITER
         MVC   1(8,R11),CONSYM         SYMBOL TO RECORD
         LA    R11,9(R11)              @ RHE SYMBOL IN OPERAND
FRHE     CLI   0(R11),C' '             CHARACTER IS BLANK
         BNE   SETRPAR                 NO
         BCT   R11,FRHE                LOOP TO FIND RHE
SETRPAR  MVI   1(R11),C')'             SET CLOSING PAREN
         B     FCWRT                   CONTINUE
FHEX     MVC   OPNDS(2),=C'X'''        TYPE AND BEGIN QUOTE
         LA    R12,CONDATA             @ CONSTANT DATA
         BAS   R9,HEXPRT4              CONVERT TO PRINTABLE
         LH    R12,CONLEN              GET DATA LENGTH
         SLL   R12,1                   DOUBLE IT
         BCTR  R12,0                   -1 = LENGTH CODE
         STC   R12,*+L'*+1             SET MOVE LENGTH
         MVC   OPNDS+2(*-*),PRTABL     HEX CHARS TO OPERAND
         LA    R12,OPNDS+2(R12)        OPERAND END ADDRESS
         MVI   1(R12),C''''            ENDING QUOTE
         B     FCWRT                   CONTINUE
FCWRT    BAS   R9,WRTOUT               WRITE RECORD
         BAS   R9,TXTFMT               GO FORMAT HEX DATA
         BAS   R9,PRINT                GO PRINT IT
FCCLR    MVI   CONPROG,0               RESET CONSTANT IN PROGRESS
         MVC   CONNAME,BLANX           CLEAR NAME
         MVI   CONTYPE,0               RESET TYPE
         XC    CONDATA,CONDATA         CLEAR CONSTANT DATA
         MVC   CONSYM,BLANX            CLEAR SYMBOL
         XC    CONLEN,CONLEN           CLEAR LENGTH
         MVC   CONLOC,XZROS            CLEAR LOCATION
         MVC   CONOFST,XZROS           CLEAR OFFSET TO CONSTANT
         L     R9,FC9                  GET RETURN ADDR
         BR    R9                      EXIT
         EJECT
******************************************************************
*                                                                *
* THIS ROUTINE FORMATS RR-FORMAT INSTRUCTIONS FOR OUTPUT.        *
*                                                                *
******************************************************************
         SPACE 1
RROPND   CLI   0(R7),X'05'             IS IT BALR
         BE    RRBL                    YES                         -EU-
         CLI   0(R7),X'0C'             IS IT BASSM                 -EU-
         BE    RRBL                    YES                         -EU-
         CLI   0(R7),X'0D'             IS IT BASR                  -EU-
         BNE   RRSTRT                  NO
RRBL     CLI   1(R7),X'EF'             IS IT 14,15                 -EU-
         BE    RRSTDL                  YES
         TM    1(R7),X'0F'             NO, IS R2 = 0
         BNZ   RRNSTD                  NO
         MVC   COMMENT(11),=C'ADDRESS SET'
         B     RRSTRT                  CONTINUE
RRSTDL   MVC   COMMENT(11),=C'STD LINKAGE'
         B     RRSTRT                  CONTINUE
RRNSTD   MVC   COMMENT(14),=C'NONSTD LINKAGE'
RRSTRT   XR    R1,R1                   CLEAR WORK
         IC    R1,TEXT+1               GET 2ND BYTE
         SRL   R1,4                    SHIFT OUT R2
         CVD   R1,DBLWD                CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         MVI   OPNDS,C'R'              BEGIN R1 OPERAND
         CH    R1,H10                  REG NBR > 9
         BL    RR1T                    NO, 0-9                     -EU-
         MVC   OPNDS+1(2),DBLWD        YES, 10-15
         LA    R1,OPNDS+3              TO NEXT POS
         B     RRCMA                   CONTINUE
RR1T     CLI   DBLWD+1,C'0'            R1 = 0                      -EU-
         BNE   RR11                    NO                          -EU-
         CLI   0(R7),X'0B'             IS IT BSM                   -EU-
         BNE   RR11                    NO                          -EU-
         MVI   OPNDS,C'0'              SET ONLY 0                  -EU-
         LA    R1,OPNDS+1              TO NEXT POS                 -EU-
         B     RRCMA1                  CONTINUE                    -EU-
RR11     MVC   OPNDS+1(1),DBLWD+1      MOVE REG NBR
         LA    R1,OPNDS+2              TO NEXT POS
RRCMA    CLI   TEXT,X'04'              IS IT SPM
         BNE   RRCMA1                  NO
         TM    1(R7),X'0F'             YES, IS R2 FIELD = 0
         BZ    RRXIT                   YES, GOOD INSTR
         B     4(R9)                   ERROR RETURN (NOT INSTR)
RRCMA1   MVC   0(2,R1),=C',R'          DELIMITERS
         PACK  DBLWD(1),TEXT+1(1)      FLIP 2ND BYTE
         XR    R15,R15                 CLEAR WORK
         IC    R15,DBLWD               GET R2R1
         SRL   R15,4                   SHIFT OUT R1
         CVD   R15,DBLWD               CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         CH    R15,H10                 R2 > 9
         BL    RR2T                    NO, 0-9                     -EU-
         MVC   2(2,R1),DBLWD           YES, MOVE REG 10-15
         BR    R9                      EXIT
RR2T     CLI   DBLWD+1,C'0'            R2 = 0                      -EU-
         BNE   RR21                    NO                          -EU-
         CLI   0(R7),X'05'             IS IT BALR                  -EU-
         BE    RR20                    YES                         -EU-
         CLI   0(R7),X'06'             IS IT BCTR                  -EU-
         BE    RR20                    YES                         -EU-
         CLI   0(R7),X'0B'             IS IT BSM                   -EU-
         BE    RR20                    YES                         -EU-
         CLI   0(R7),X'0C'             IS IT BASSM                 -EU-
         BE    RR20                    YES                         -EU-
         CLI   0(R7),X'0D'             IS IT BASR                  -EU-
         BNE   RR21                    NO                          -EU-
RR20     MVI   1(R1),C'0'              SET ONLY 0                  -EU-
         BR    R9                      EXIT                        -EU-
RR21     MVC   2(1,R1),DBLWD+1         MOVE REG 0-9
RRXIT    BR    R9                      EXIT
         EJECT
******************************************************************
*                                                                *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT RX-TYPE  *
* INSTRUCTIONS. THE BDXADR ROUTINE IS CALLED TO FORMAT THE       *
* STORAGE OPERAND.                                               *
*                                                                *
******************************************************************
         SPACE 1
RXOPND   CLI   0(R7),X'45'             IS IT BAL OP CODE
         BNE   RXSTRT                  NO
         MVC   COMMENT(7),=C'PERFORM'
         TM    1(R7),X'E0'             R1 = 0 OR 1
         BNZ   RXSTRT                  NO
         MVC   COMMENT(13),=C'PARM SET BRCH'
RXSTRT   XR    R1,R1                   CLEAR WORK
         IC    R1,TEXT+1               GET R1X2
         SRL   R1,4                    SHIFT OUT X2
         CVD   R1,DBLWD                CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         MVI   OPNDS,C'R'              BEGIN 1ST OPERAND
         CH    R1,H10                  R1 < 10
         BL    RXR1T                   YES, 0-9
         MVC   OPNDS+1(2),DBLWD        NO, MOVE REG 10-15
         LA    R15,OPNDS+3             TO NEXT POS
         B     RXCMA                   CONTINUE
RXR1T    CLI   0(R7),X'44'             IS IT EX OP CODE            -EU-
         BNE   RXR11                   NO                          -EU-
         CLI   DBLWD+1,C'0'            REG = 0                     -EU-
         BNE   RXR11                   NO                          -EU-
         MVI   OPNDS,C'0'              SET ONLY 0                  -EU-
         LA    R15,OPNDS+1             TO NEXT POS                 -EU-
         B     RXCMA                   CONTINUE                    -EU-
RXR11    MVC   OPNDS+1(1),DBLWD+1      MOVE REG 0-9
         LA    R15,OPNDS+2             TO NEXT POS
RXCMA    MVI   0(R15),C','             DELIMITER
         PACK  DBLWD(1),TEXT+1(1)      FLIP 2ND BYTE
         XR    R10,R10                 CLEAR WORK
         IC    R10,DBLWD               PICK UP X2R1
         SRL   R10,4                   SHIFT OUT R1
         XR    R11,R11                 CLEAR WORK
         ICM   R11,B'0011',TEXT+2      GET BDDD
         TM    TEXT+2,X'F0'            IS B SPECIFIED              -EU-
         BNZ   RXCONV                  YES                         -EU-
         SLL   R10,12                  POSITION X2 AS B            -EU-
         OR    R11,R10                 BUILD NEW BDDD              -EU-
         XR    R10,R10                 CLEAR X2                    -EU-
RXCONV   BAS   R9,BDXADR               CONVERT RX ADDRESS
         STC   R10,*+L'*+1             SET MOVE LENGTH
         MVC   1(*-*,R15),OPNDWK       MOVE RX OPERAND
         L     R9,OPND9                GET RETURN ADDR
         BR    R9                      EXIT
         EJECT
******************************************************************
*                                                                *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT S-TYPE   *
* INSTRUCTIONS. THE BDADR ROUTINE IS CALLED TO FORMAT THE        *
* STORAGE OPERAND.                                               *
*                                                                *
******************************************************************
         SPACE 1
SOPND    CLI   1(R7),0                 BYTE 2 OF INSTR IS ZERO
         BE    SCHECK                  YES
         CLI   0(R7),X'80'             NO, IS IT SSM
         BE    4(R9)                   YES, NOT INSTR
         CLI   0(R7),X'82'             NO, IS IT LPSW
         BE    4(R9)                   YES, NOT INSTR
         CLI   0(R7),X'93'             NO, IS IT TS
         BE    4(R9)                   YES, NOT INSTR
SCHECK   CLI   0(R7),X'B2'             OP-CODE IS B2
         BNE   SSTRT                   NO
         TM    ICLASS,IOP              IGNORE OPERAND INSTR        -EU-
         BZ    SST3A                   NO                          -EU-
         CLC   2(2,R7),XZROS           3RD AND 4TH BYTES ZERO      -EU-
         BNE   4(R9)                   NO, NOT INSTRUCTION         -EU-
         BR    R9                      YES, EXIT                   -EU-
SST3A    CLI   1(R7),X'3A'             'STCPS' INST                -EU-
         BNE   SSTRT                   NO                          -EU-
         TM    3(R7),X'1F'             32-BYTE BOUNDARY            -EU-
         BZ    SSTRT                   YES                         -EU-
         TM    2(R7),X'F0'             BASE REG = 0                -EU-
         BZ    4(R9)                   YES, NOT INSTR              -EU-
SSTRT    XR    R11,R11                 CLEAR WORK
         ICM   R11,B'0011',TEXT+2      GET BDDD
         BAS   R9,BDADR                CONVERT BDDD ADDRESS
         STC   R10,*+L'*+1             SET MOVE LENGTH
         MVC   OPNDS(*-*),OPNDWK       MOVE OPERAND
         L     R9,OPND9                GET RETURN ADDR
         BR    R9                      EXIT
         EJECT
******************************************************************
*                                                                *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT SI-TYPE  *
* INSTRUCTIONS. THE BDADR ROUTINE IS CALLED TO FORMAT THE        *
* STORAGE OPERAND.                                               *
*                                                                *
******************************************************************
         SPACE 1
SIOPND   XR    R11,R11                 CLEAR WORK
         ICM   R11,B'0011',TEXT+2      GET BDDD ADDRESS
         BAS   R9,BDADR                CONVERT ADDRESS
         STC   R10,*+L'*+1             SET MOVE LENGTH
         MVC   OPNDS(*-*),OPNDWK       MOVE BDDD OPERAND
         LA    R15,OPNDS+1(R10)        TO NEXT POS
         MVI   0(R15),C','             DELIMITER
         L     R9,=A(CHARTRAN)                                     -EU-
         TRT   TEXT+1(1),0(R9)         TEST IF CHARACTER           -EU-
         BNZ   HEXIMM                  NO, HEX
         CLI   TEXT,X'95'              IS IT CLI
         BE    CHIMM                   YES
         CLI   TEXT,X'92'              IS IT MVI
         BNE   HEXIMM                  NO
CHIMM    MVC   1(2,R15),=C'C'''        DELIMITER
         MVC   3(1,R15),TEXT+1         CHARACTER TO OPERAND
         MVI   4(R15),C''''            ENDING DELIMITER
         L     R9,OPND9                GET RETURN ADDR
         BR    R9                      EXIT
HEXIMM   MVC   1(2,R15),=C'X'''        DELIMITER FOR HEX
         LA    R12,TEXT+1              @ HEX BYTE
         BAS   R9,HEXPRT1              CONVERT
         MVC   3(2,R15),PRTABL         PRINTABLE HEX TO OPERAND
         MVI   5(R15),C''''            FINAL QUOTE
         L     R9,OPND9                GET RETURN ADDR
         BR    R9                      EXIT
         EJECT
******************************************************************
*                                                                *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT RS-TYPE  *
* INSTRUCTIONS. THE BDADR ROUTINE IS CALLED TO FORMAT THE        *
* STORAGE OPERAND.                                               *
*                                                                *
******************************************************************
         SPACE 1
RSOPND   CLI   TEXT,X'90'              IS IT STM
         BE    RSSTM                   YES
         CLI   TEXT,X'98'              IS IT LM
         BNE   RSCLR1                  NO
         MVC   COMMENT(12),=C'RESTORE REGS'
         B     RSCLR1                  CONTINUE
RSSTM    MVC   COMMENT(9),=C'SAVE REGS'
RSCLR1   XR    R1,R1                   CLEAR WORK
         IC    R1,TEXT+1               PICK UP R1R3
         SRL   R1,4                    SHIFT OUT R3
         CVD   R1,DBLWD                CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         MVI   OPNDS,C'R'              BEGINNING OPERAND 1
         CH    R1,H10                  REG NBR < 10
         BL    RSR11                   YES
         MVC   OPNDS+1(2),DBLWD        MOVE REG 10-15
         LA    R15,OPNDS+3             TO NEXT POS
         B     RSCMA                   CONTINUE
RSR11    MVC   OPNDS+1(1),DBLWD+1      MOVE REG 0-9
         LA    R15,OPNDS+2             TO NEXT POS
RSCMA    CLI   0(R7),X'88'             IS IT SHIFT INSTR
         BL    RSCMA1                  NO
         CLI   0(R7),X'8F'             IS IT SHIFT INSTR
         BH    RSCMA1                  NO
         TM    1(R7),X'0F'             SHIFT, IS R3 POS = 0
         BZ    RSBDD                   YES, GOOD SHIFT
         B     4(R9)                   NO, NOT INSTR
RSCMA1   CLI   0(R7),X'BD'             CLM, STCM, OR ICM           -EU-
         BL    RSPK2                   NO
         CLI   0(R7),X'BF'             CLM, STCM, OR ICM
         BH    RSPK2                   NO
* CLM, STCM, ICM HAVE MASK IN R3 POSITION
         MVC   0(3,R15),=C',B'''       DELIMITERS                  -EU-
         PACK  DBLWD(1),TEXT+1(1)      FLIP 2ND BYTE               -EU-
         XR    R1,R1                   CLEAR WORK                  -EU-
         IC    R1,DBLWD                GET MR1                     -EU-
         SRL   R1,4                    SHIFT OUT R1                -EU-
         SLL   R1,2                    MULTIPLY BY 4               -EU-
         AL    R1,=A(RSMASKS)          COMPUTE MASK BITS ADDRESS   -EU-
         MVC   3(4,R15),0(R1)          SET MASK BITS               -EU-
         MVI   7(R15),C''''            MASK DELIMITER              -EU-
         LA    R15,8(R15)              TO NEXT POS                 -EU-
         B     RSBDD                   CONTINUE                    -EU-
RSPK2    MVC   0(2,R15),=C',R'         DELIMITERS                  -EU-
         PACK  DBLWD(1),TEXT+1(1)      FLIP 2ND BYTE               -EU-
         XR    R1,R1                   CLEAR WORK
         IC    R1,DBLWD                GET R3R1
         SRL   R1,4                    SHIFT OUT R1
         CVD   R1,DBLWD                CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         CH    R1,H10                  REG NBR < 10
         BL    RSR31                   YES, 0-9
         MVC   2(2,R15),DBLWD          MOVE REG 10-15
         LA    R15,4(R15)              TO NEXT POS
         B     RSBDD                   CONTINUE
RSR31    MVC   2(1,R15),DBLWD+1        MOVE REG 0-9
         LA    R15,3(R15)              TO NEXT POS
RSBDD    MVI   0(R15),C','             DELIMITER
         XR    R11,R11                 CLEAR WORK
         ICM   R11,B'0011',TEXT+2      GET BDD ADDRESS
         BAS   R9,BDADR                CONVERT BDDD ADDRESS
         STC   R10,*+L'*+1             SET MOVE LENGTH
         MVC   1(*-*,R15),OPNDWK       MOVE BDDD ADDRESS
         L     R9,OPND9                GET RETURN ADDR
         BR    R9                      EXIT
         EJECT
******************************************************************
*                                                                *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT SS-TYPE  *
* INSTRUCTIONS OF THE SINGLE LENGTH VARIETY. THE BDLADR ROUTINE  *
* IS CALLED TO FORMAT THE 1ST STRG OPND, AND BDADR FOR THE 2ND.  *
*                                                                *
******************************************************************
         SPACE 1
SS1OPND  XR    R10,R10                 CLEAR WORK
         IC    R10,TEXT+1              GET LENGTH CODE
         XR    R11,R11                 CLEAR WORK
         ICM   R11,B'0011',TEXT+2      GET BDDD ADDRESS
         BAS   R9,BDLADR               CONVERT ADDRESS
         STC   R10,*+L'*+1             SET MOVE LENGTH
         MVC   OPNDS(*-*),OPNDWK       MOVE ADDRESS
         LA    R15,OPNDS+1(R10)        TO NEXT POS
         MVI   0(R15),C','             DELIMITER
         XR    R11,R11                 CLEAR WORK
         ICM   R11,B'0011',TEXT+4      GET SECOND BDDD ADDRESS
         BAS   R9,BDADR                CONVERT ADDRESS
         STC   R10,*+L'*+1             SET MOVE LENGTH
         MVC   1(*-*,R15),OPNDWK       MOVE 2ND OPERAND
         L     R9,OPND9                GET RETURN ADDR
         BR    R9                      EXIT
         EJECT
******************************************************************
*                                                                *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT SS-TYPE  *
* INSTRUCTIONS OF THE DOUBLE LENGTH VARIETY. THE BDLADR ROUTINE  *
* IS CALLED TO FORMAT THE STORAGE OPERANDS.                      *
*                                                                *
******************************************************************
         SPACE 1
SS2OPND  XR    R10,R10                 CLEAR WORK
         IC    R10,TEXT+1              GET L1L2
         SRL   R10,4                   SHIFT OUT L2
         XR    R11,R11                 CLEAR WORK
         ICM   R11,B'0011',TEXT+2      GET BDDD ADDRESS
         BAS   R9,BDLADR               CONVERT ADDRESS
         STC   R10,*+L'*+1             SET MOVE LENGTH
         MVC   OPNDS(*-*),OPNDWK       MOVE 1ST OPERAND
         LA    R15,OPNDS+1(R10)        TO NEXT POS
         MVI   0(R15),C','             DELIMITER
         XR    R11,R11                 CLEAR WORK
         ICM   R11,B'0011',TEXT+4      GET 2ND BDDD ADDR
         PACK  DBLWD(1),TEXT+1(1)      FLIP LENGTH BYTE
         XR    R10,R10                 CLEAR WORK
         IC    R10,DBLWD               PICK UP L2L1
         SRL   R10,4                   SHIFT OUT L1
         CLI   TEXT,X'F0'              SRP OP-CODE
         BE    SRPOP2                  YES
         BAS   R9,BDLADR               CONVERT ADDRESS
         STC   R10,*+L'*+1             SET MOVE LENGTH
         MVC   1(*-*,R15),OPNDWK       MOVE 2ND OPERAND
SS2XIT   L     R9,OPND9                GET RETURN ADDR
         BR    R9                      EXIT
SRPOP2   BAS   R9,BDADR                GO BUILD OPERAND 2
         STC   R10,*+L'*+1             SET MOVE LENGTH
         MVC   1(*-*,R15),OPNDWK       MOVE OPERAND 2
         LA    R15,2(R10,R15)          TO NEXT OPERAND POS  FIX***
         PACK  DBLWD(1),TEXT+1(1)      FLIP LENGTH BYTE
         XR    R10,R10                 CLEAR WORK
         IC    R10,DBLWD               PICK UP I3L1
         SRL   R10,4                   SHIFT OUT L1
         CVD   R10,DBLWD               CONVERT I3
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         MVI   0(R15),C','             OPERAND SEPARATOR    FIX***
         UNPK  1(1,R15),DBLWD+7(1)     UNPACK I3 TO OPERAND FIX***
         CH    R10,H10                 I3 < 10                     -EU-
         BL    SS2XIT                  YES
         UNPK  1(2,R15),DBLWD+6(2)     NO, UNPACK MORE
         B     SS2XIT                  CONTINUE
         EJECT ,                                                   -EU-
****************************************************************** -EU-
*                                                                * -EU-
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT SS-TYPE  * -EU-
* INSTRUCTIONS OF THE 2 REGISTERS VARIETY. THE BDLADR ROUTINE IS * -EU-
* CALLED TO FORMAT THE 1ST STRG OPND, AND BDADR FOR THE 2ND.     * -EU-
*                                                                * -EU-
****************************************************************** -EU-
         SPACE 1                                                   -EU-
SSROPND  XR    R10,R10                 CLEAR WORK                  -EU-
         IC    R10,TEXT+1              GET R1R3                    -EU-
         SRL   R10,4                   SHIFT OUT R3                -EU-
         XR    R11,R11                 CLEAR WORK                  -EU-
         ICM   R11,B'0011',TEXT+2      GET BDDD ADDRESS            -EU-
         BAS   R9,BDLADR               CONVERT ADDRESS             -EU-
         STC   R10,*+L'*+1             SET MOVE LENGTH             -EU-
         MVC   OPNDS(*-*),OPNDWK       MOVE 1ST OPERAND            -EU-
         LA    R15,OPNDS+1(R10)        TO NEXT POS                 -EU-
         MVI   0(R15),C','             DELIMITER                   -EU-
         XR    R11,R11                 CLEAR WORK                  -EU-
         ICM   R11,B'0011',TEXT+4      GET 2ND BDDD ADDR           -EU-
         BAS   R9,BDADR                CONVERT ADDRESS             -EU-
         STC   R10,*+L'*+1             SET MOVE LENGTH             -EU-
         MVC   1(*-*,R15),OPNDWK       MOVE 2ND OPERAND            -EU-
         LA    R15,2(R10,R15)          TO NEXT POS                 -EU-
         PACK  DBLWD(1),TEXT+1(1)      FLIP R1R3 BYTE              -EU-
         XR    R10,R10                 CLEAR WORK                  -EU-
         IC    R10,DBLWD               PICK UP R3R1                -EU-
         SRL   R10,4                   SHIFT OUT R1                -EU-
         CVD   R10,DBLWD               CONVERT R3                  -EU-
         OI    DBLWD+7,X'0F'           CLEAR SIGN                  -EU-
         MVC   0(2,R15),=C',R'         OPERAND SEPARATOR           -EU-
         UNPK  2(1,R15),DBLWD+7(1)     UNPACK R3 TO OPERAND        -EU-
         CH    R10,H10                 R3 < 10                     -EU-
         BL    SSRXIT                  YES                         -EU-
         UNPK  2(2,R15),DBLWD+6(2)     NO, UNPACK MORE             -EU-
SSRXIT   L     R9,OPND9                GET RETURN ADDR             -EU-
         BR    R9                      EXIT                        -EU-
         EJECT ,                                                   -EU-
****************************************************************** -EU-
*                                                                * -EU-
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT SSE-TYPE * -EU-
* INSTRUCTIONS. THE BDADR ROUTINE IS CALLED TO FORMAT THE BOTH   * -EU-
* OPERANDS.                                                      * -EU-
*                                                                * -EU-
****************************************************************** -EU-
         SPACE 1                                                   -EU-
SSEOPND  XR    R11,R11                 CLEAR WORK                  -EU-
         ICM   R11,B'0011',TEXT+2      GET BDDD ADDRESS            -EU-
         BAS   R9,BDADR                CONVERT ADDRESS             -EU-
         STC   R10,*+L'*+1             SET MOVE LENGTH             -EU-
         MVC   OPNDS(*-*),OPNDWK       MOVE 1ST OPERAND            -EU-
         LA    R15,OPNDS+1(R10)        TO NEXT POS                 -EU-
         MVI   0(R15),C','             DELIMITER                   -EU-
         XR    R11,R11                 CLEAR WORK                  -EU-
         ICM   R11,B'0011',TEXT+4      GET 2ND BDDD ADDR           -EU-
         BAS   R9,BDADR                CONVERT ADDRESS             -EU-
         STC   R10,*+L'*+1             SET MOVE LENGTH             -EU-
         MVC   1(*-*,R15),OPNDWK       MOVE 2ND OPERAND            -EU-
         L     R9,OPND9                GET RETURN ADDR             -EU-
         BR    R9                      EXIT                        -EU-
         EJECT
******************************************************************
*                                                                *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT COND-    *
* ITIONAL BRANCH INSTRUCTIONS. AN ATTEMPT IS MADE TO USE THE     *
* EXTENDED MNEMONICS WHERE POSSIBLE. FOR RR-TYPE BRANCHES, ONLY  *
* THE BR AND NOPR MNEMONICS ARE USED. FOR RX-TYPE BRANCHES, THE  *
* FULL SET OF EXTENDED MNEMONICS IS USED. THE TYPES USED ARE     *
* ARITHMETIC, COMPARE, AND 8=ZERO TYPES. THE SET TO BE USED IS   *
* DETERMINED BY THE TYPE SAVED BY THE LAST CONDITION-CODE-SETTING*
* INSTRUCTION GENERATED.                                         *
*
******************************************************************
         SPACE 1
BCOPND   TM    TEXT+1,X'F0'            UNCONDITIONAL BRANCH
         BZ    NOPS                    NO, NOP
         BO    UNCNDS                  YES, UNCONDITIONAL
         XR    R11,R11                 CLEAR WORK
         IC    R11,TEXT+1              PICK UP M1X2
         SRL   R11,4                   SHIFT OUT ALL BUT M1
         CLI   BREMASM,1               IS BR EXT.MNEMONICS ALLOWED -EU-
         BE    *+L'*+8                 YES                         -EU-
         CLI   TEXT,X'07'              BCR OP CODE
         BE    NOEXTND                 YES, NO EXTENDED MNEMONICS
         CLI   CCTYPE,0                LAST INSTR SET CC
         BE    NOEXTND                 NO
         TM    CCTYPE,ARITH            YES, WAS IT ARITHMETIC
         BO    EXTARITH                YES
         TM    CCTYPE,CPR              WAS IT COMPARE
         BO    EXTCPR                  YES
         TM    CCTYPE,ZRO8             IS IT VALID FOR 8 = BZ
         BO    EXTZRO                  YES
NOEXTND  CVD   R11,DBLWD               CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         CH    R11,H10                 MASK < 10
         BL    BCM1                    YES, SINGLE DIGIT MASK
         MVC   OPNDS(2),DBLWD          2-DIGIT MASK TO OPERAND
         LA    R15,OPNDS+2             TO NEXT POS
         B     BCCMA                   CONTINUE
BCM1     MVC   OPNDS(1),DBLWD+1        SINGLE DIGIT MASK TO OPERAND
         LA    R15,OPNDS+1             TO NEXT POS
BCCMA    MVI   0(R15),C','             DELIMITER
         CLI   TEXT,X'07'              RR BRANCH
         BE    BCROPND                 YES
BCXOPND  PACK  DBLWD(1),TEXT+1(1)      PACK 2ND BYTE
         XR    R10,R10                 CLEAR WORK
         IC    R10,DBLWD               PICK UP X2M1
         SRL   R10,4                   SHIFT OUT M1
         XR    R11,R11                 CLEAR WORK
         ICM   R11,B'0011',TEXT+2      PICK UP BDDD ADDRESS
         BNZ   BCXTEST                 BRANCH IF NOT ZERO          -EU-
         CLC   MNEMONIC,=CL5'NOP'      NOP                         -EU-
         BNE   BCXTEST                 NO                          -EU-
         MVI   1(R15),C'0'             SET ONLY 0                  -EU-
         B     BCOXIT                  GO TO EXIT                  -EU-
BCXTEST  TM    TEXT+2,X'F0'            IS B SPECIFIED              -EU-
         BNZ   BCXCONV                 YES                         -EU-
         SLL   R10,12                  POSITION X2 AS B            -EU-
         OR    R11,R10                 BUILD NEW BDDD              -EU-
         XR    R10,R10                 CLEAR X2                    -EU-
BCXCONV  BAS   R9,BDXADR               CONVERT ADDRESS
         STC   R10,*+L'*+1             SET MOVE LENGTH
         MVC   1(*-*,R15),OPNDWK       MOVE OPERAND
         B     BCOXIT                  GO TO EXIT
BCROPND  MVI   1(R15),C'R'             REGISTER DELIMITER
         XR    R10,R10                 CLEAR WORK
         PACK  DBLWD(1),TEXT+1(1)      FLIP 2ND BYTE
         IC    R10,DBLWD               PICK UP R2M1
         SRL   R10,4                   SHIFT OUT M1
         CVD   R10,DBLWD               CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         CH    R10,H10                 REG NBR < 10
         BL    BCRRT                   YES, 0-9
         MVC   2(2,R15),DBLWD          MOVE 2-DIGIT REG NBR
         B     BCOXIT                  GO TO EXIT
BCRRT    CLI   DBLWD+1,C'0'            REG NBR = 0                 -EU-
         BNE   BCRR1                   NO                          -EU-
         CLC   MNEMONIC,=CL5'NOPR'     NOPR                        -EU-
         BNE   BCRR1                   NO                          -EU-
         MVI   1(R15),C'0'             SET ONLY 0                  -EU-
         B     BCOXIT                  GO TO EXIT                  -EU-
BCRR1    MVC   2(1,R15),DBLWD+1        MOVE 1-DIGIT REG NBR        -EU-
         B     BCOXIT                  GO TO EXIT
NOPS     CLI   TEXT,X'07'              RR NOP
         BNE   BCXNOP                  NO, RX
         MVC   MNEMONIC,=CL5'NOPR'     SET MNEMONIC
BCRTFIN  LA    R15,OPNDS-1             TO OPND POS                 -EU-
         B     BCROPND                 FINISH
BCXNOP   MVC   MNEMONIC,=CL5'NOP'      SET MNEMONIC
         LA    R15,OPNDS-1             TO OPND POS                 -EU-
         B     BCXOPND                 FINISH
UNCNDS   CLI   TEXT,X'07'              IS IT RR BRANCH
         BNE   BCXBRCH                 NO, RX
         MVC   MNEMONIC,=CL5'BR'       SET MNEMONIC
         LA    R15,OPNDS-1             OPERAND ADDR
         CLI   TEXT+1,X'FE'            IS IT BR 14
         BNE   BCROPND                 NO
         MVC   COMMENT(4),=C'EXIT'     COMMENT
         B     BCROPND                 FINISH FORMATTING
BCXBRCH  MVC   MNEMONIC(5),=CL5'B'     SET MNEMONIC
BCXTFIN  LA    R15,OPNDS-1             SET OPND POS
         B     BCXOPND                 FINISH FORMAT
BCOXIT   L     R9,OPND9                GET RETURN ADDR
         BR    R9                      EXIT
EXTARITH CH    R11,H8                  COND CODE = 8
         BE    ARBZ                    YES
         BL    ARLOW                   NO, LOWER
         CH    R11,H14                 COND CODE = 14
         BE    ARBNO                   YES
         CH    R11,H13                 COND CODE = 13
         BE    ARBNP                   YES
         CH    R11,H11                 COND CODE = 11
         BE    ARBNM                   YES
         B     NOEXTND                 NO, NOT EXTENDED
ARLOW    CH    R11,H7                  COND CODE = 7
         BE    ARBNZ                   YES
         CH    R11,H1                  COND CODE = 1
         BE    ARBO                    YES
         CH    R11,H2                  COND CODE = 2
         BE    ARBP                    YES
         CH    R11,H4                  COND CODE = 4
         BE    ARBM                    YES
         B     NOEXTND                 NO, NOT EXTENDED
ARBZ     MVC   MNEMONIC(3),=C'BZ '     SET EXT MNEMONIC            -EU-
         B     BCXBRTS                 CONTINUE                    -EU-
ARBNO    MVC   MNEMONIC(3),=C'BNO'     SET EXTENDED MNEMONIC
         B     BCXBRTS                 CONTINUE                    -EU-
ARBNP    MVC   MNEMONIC(3),=C'BNP'     SET EXT MNEMONIC
         B     BCXBRTS                 CONTINUE                    -EU-
ARBNM    MVC   MNEMONIC(3),=C'BNM'     SET EXT MNEMONIC
         B     BCXBRTS                 CONTINUE                    -EU-
ARBNZ    MVC   MNEMONIC(3),=C'BNZ'     SET EXT MNEMONIC
         B     BCXBRTS                 CONTINUE                    -EU-
ARBO     MVC   MNEMONIC(3),=C'BO '     SET EXT MNEMONIC            -EU-
         B     BCXBRTS                 CONTINUE                    -EU-
ARBP     MVC   MNEMONIC(3),=C'BP '     SET EXT MNEMONIC            -EU-
         B     BCXBRTS                 CONTINUE                    -EU-
ARBM     MVC   MNEMONIC(3),=C'BM '     SET EXT MNEMONIC            -EU-
         B     BCXBRTS                 CONTINUE                    -EU-
EXTZRO   CH    R11,H8                  COND CODE = 8
         BE    ARBZ                    YES, USE BZ MNEMONIC
         CH    R11,H7                  COND CODE IS 7
         BE    ARBNZ                   YES
         B     NOEXTND                 NO, NOT EXTENDED
EXTCPR   CH    R11,H8                  COND CODE = 8
         BE    CPBE                    YES
         CH    R11,H7                  COND CODE = 7
         BE    CPBNE                   YES
         BL    CPLOW                   NO, LOWER
         CH    R11,H13                 COND CODE = 13
         BE    CPBNH                   YES
         CH    R11,H11                 COND CODE = 11
         BE    CPBNL                   YES
         B     NOEXTND                 NO, NOT EXTENDED
CPLOW    CH    R11,H4                  COND CODE = 4
         BE    CPBL                    YES
         CH    R11,H2                  COND CODE = 2
         BE    CPBH                    YES
         B     NOEXTND                 NO, NOT EXTENDED
CPBE     MVC   MNEMONIC(3),=C'BE '     SET EXT MNEMONIC            -EU-
         B     BCXBRTS                 CONTINUE                    -EU-
CPBNE    MVC   MNEMONIC(3),=C'BNE'     SET EXT MNEMONIC
         B     BCXBRTS                 CONTINUE                    -EU-
CPBNH    MVC   MNEMONIC(3),=C'BNH'     SET EXT MNEMONIC
         B     BCXBRTS                 CONTINUE                    -EU-
CPBNL    MVC   MNEMONIC(3),=C'BNL'     SET EXT MNEMONIC
         B     BCXBRTS                 CONTINUE                    -EU-
CPBL     MVC   MNEMONIC(3),=C'BL '     SET EXT MNEMONIC            -EU-
         B     BCXBRTS                 CONTINUE                    -EU-
CPBH     MVC   MNEMONIC(3),=C'BH '     SET EXTENDED MNEMONIC       -EU-
BCXBRTS  CLI   TEXT,X'07'              IS BCR OP CODE              -EU-
         BNE   BCXTFIN                 NO, CONTINUE                -EU-
         CLI   MNEMONIC+2,C' '         SET REGISTER MNEMONIC       -EU-
         BNE   *+L'*+8                                             -EU-
         MVI   MNEMONIC+2,C'R'                                     -EU-
         B     BCRTFIN                 CONTINUE                    -EU-
         MVI   MNEMONIC+3,C'R'                                     -EU-
         B     BCRTFIN                 CONTINUE
         EJECT ,                                                   -EU-
****************************************************************** -EU-
*                                                                * -EU-
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT RRE-TYPE * -EU-
* INSTRUCTIONS OF THE 2 REGISTERS VARIETY.                       * -EU-
*                                                                * -EU-
****************************************************************** -EU-
         SPACE 1                                                   -EU-
RREOPND  CLI   TEXT+2,0                BYTE 2 OF INSTR IS ZERO     -EU-
         BNE   4(R9)                   NO, NOT INSTRUCTION         -EU-
         TM    IEDT,E1R                1 REGISTER                  -EU-
         BZ    *+L'*+8                 NO                          -EU-
         TM    TEXT+3,X'0F'            R2 IS ZERO                  -EU-
         BNZ   4(R9)                   NO, NOT INSTRUCTION         -EU-
         XR    R1,R1                   CLEAR WORK                  -EU-
         IC    R1,TEXT+3               GET R1R2                    -EU-
         SRL   R1,4                    SHIFT OUT R2                -EU-
         CVD   R1,DBLWD                CONVERT                     -EU-
         OI    DBLWD+7,X'0F'           CLEAR SIGN                  -EU-
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK                      -EU-
         MVI   OPNDS,C'R'              BEGIN 1ST OPERAND           -EU-
         LA    R15,OPNDS+1             SET 1ST OPERAND POS         -EU-
         CH    R1,H10                  R1 < 10                     -EU-
         BL    RRE11                   YES, 0-9                    -EU-
         MVC   0(2,R15),DBLWD          NO, MOVE REG 10-15          -EU-
         LA    R15,2(R15)              TO NEXT POS                 -EU-
         B     RRE1T                   CLEAR WORK                  -EU-
RRE11    MVC   0(1,R15),DBLWD+1        MOVE REG 0-9                -EU-
         LA    R15,1(R15)              TO NEXT POS                 -EU-
RRE1T    TM    IEDT,E1R                1 REGISTER                  -EU-
         BO    0(R9)                   YES, EXIT                   -EU-
         MVC   0(2,R15),=C',R'         DELIMITERS 2ND OPERAND      -EU-
         PACK  DBLWD(1),TEXT+3(1)      FLIP 4TH BYTE               -EU-
         XR    R1,R1                   CLEAR WORK                  -EU-
         IC    R1,DBLWD                GET R2R1                    -EU-
         SRL   R1,4                    SHIFT OUT R1                -EU-
         CVD   R1,DBLWD                CONVERT                     -EU-
         OI    DBLWD+7,X'0F'           CLEAR SIGN                  -EU-
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK                      -EU-
         CH    R1,H10                  R2 < 10                     -EU-
         BL    RRE21                   YES, 0-9                    -EU-
         MVC   2(2,R15),DBLWD          NO, MOVE REG 10-15          -EU-
         BR    R9                      EXIT                        -EU-
RRE21    MVC   2(1,R15),DBLWD+1        MOVE REG 0-9                -EU-
         BR    R9                      EXIT                        -EU-
         EJECT
******************************************************************
*                                                                *
* VALIDATE AND FORMAT SVC INSTRUCTIONS. IF THE SVC OP-CODE IS    *
* FOUND IN THE SVC TABLE, IT IS ACCEPTED AS AN SVC, AND THE TABLE*
* LITERAL IS MOVED TO THE COMMENTS FIELD OF THE INSTRUCTION.     *
*                                                                *
******************************************************************
         SPACE 1
SVCOPND  L     R1,SVCOPAD              GET SVC TABLE ADDRESS       -EU-
SVCKND   CLI   0(R1),X'FF'             END OF SVC TABLE
         BE    NOTSVC                  YES, MUST NOT BE SVC
         CLC   0(1,R1),TEXT+1          THIS THE ENTRY
         BE    GOTSVC                  YES
         BH    NOTSVC                  NO, MUST NOT BE SVC         -EU-
         AH    R1,SVCOPL               STEP TO NEXT ENTRY          -EU-
         B     SVCKND                  LOOP THRU TABLE
NOTSVC   B     4(R9)                   ERROR RETURN
GOTSVC   MVC   COMMENT(14),1(R1)       COMMENT TO WORK AREA
         XR    R1,R1                   CLEAR WORK
         IC    R1,TEXT+1               GET SVC OPERAND
         CVD   R1,DBLWD                CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(3),DBLWD+6(2)     UNPACK
         CH    R1,H100                 OPERAND > 100
         BL    SVCK10                  YES
         MVC   OPNDS(3),DBLWD          MOVE 3-DIGIT OPERAND
         B     SVCXIT                  EXIT
SVCK10   CH    R1,H10                  OPERAND < 10
         BL    SVCL10                  YES
         MVC   OPNDS(2),DBLWD+1        MOVE 2-DIGIT OPERAND
         B     SVCXIT                  EXIT
SVCL10   MVC   OPNDS(1),DBLWD+2        MOVE 1-DIGIT OPERAND
SVCXIT   BR    R9                      EXIT
         EJECT
******************************************************************
*                                                                *
* BUILD EQU STATEMENTS USING THE LABEL TABLE ENTRY ADDRESSED BY  *
* REG 6 ON ENTRY.                                                *
*                                                                *
******************************************************************
         SPACE 1                                                 *
EQUSTMT  ST    R9,EQU9                 SAVE RETURN ADDR
         USING LABELD,R6
         MVC     NAME,LBLNAME          NAME TO EQU STMT
         MVC   MNEMONIC,=CL5'EQU'      BUILD EQU STATEMENT
         MVI   OPNDS,C'*'              SET EQU OPERAND
         CLI   LBLLEN,1                LENGTH 0 OR 1
         BNH   CCXEQU                  YES
         XR    R9,R9                   CLEAR WORK
         IC    R9,LBLLEN               GET LENGTH
         CVD   R9,DBLWD                CONVERT
         UNPK  DBLWD(3),DBLWD+6(2)     UNPACK
         OI    DBLWD+2,C'0'            CLEAR SIGN
         CH    R9,H100                 LENGTH < 100
         BL    CCXQ10                  YES
         MVC   OPNDS+2(3),DBLWD        MOVE LENGTH
         B     CCXEQC                  GO SET COMMA
CCXQ10   CH    R9,H10                  LENGTH < 10
         BL    CCXQ1                   YES
         MVC   OPNDS+2(2),DBLWD+1      MOVE 2-DIGIT LENGTH
         B     CCXEQC                  GO SET COMMA
CCXQ1    MVC   OPNDS+2(1),DBLWD+2      MOVE 1-DIGIT LENGTH
CCXEQC   MVI   OPNDS+1,C','            SET COMMA
CCXEQU   BAS   R9,WRTOUT               OUTPUT EQU STATEMENT
         BAS   R9,PRINT                GO PRINT IT
         L     R9,EQU9                 GET RETURN ADDR
         BR    R9                      RETURN
         DROP  R6
         EJECT
******************************************************************
*                                                                *
* BUILDS STORAGE OPERANDS CONTAINING BASE, DISPLACEMENT, AND     *
* LENGTH. ON ENTRY, REG 11 CONTAINS THE BDDD ADDRESS, AND REG 10 *
* CONTAINS THE LENGTH. THE SCHLBL ROUTINE IS CALLED TO CREATE A  *
* LABEL REFERENCE, IF THE BASE REG IS CURRENT, AND A LABEL EXISTS*
* IF SCHLBL IS UNSUCCESSFUL, AN EXPLICIT ADDRESS OF THE FORM     *
* DDDD(LLL,RRR) IS CREATED.                                      *
* IF 2-REGS SS FORMAT, LLL IS A REGISTER, NOT A LENGTH.          * -EU-
*                                                                *
******************************************************************
         SPACE 1
BDLADR   ST    R9,BDL9                 SAVE RETURN ADDR
         XR    R0,R0                   CLEAR WORK REG
         LR    R1,R11                  COPY BDDD ADDRESS
         SLDL  R0,20                   BASE REG TO R0
         LTR   R0,R0                   IS BASE REG 0
         BNZ   BDLSCHL                 NO
         SRL   R1,20                   RIGHT JUSTIFY DISPL
         CH    R1,H16                  REFERENCE TO CVT ADDR
         BE    BDLCVTR                 YES
         CH    R1,H76                  REF TO ALTERNATE CVT ADDR
         BE    BDLCVTR                 YES
         MVC   COMMENT(13),=C'PSA REFERENCE'
         B     BDLSCHL                 CONTINUE
BDLCVTR  MVC   COMMENT(11),=C'CVT ADDRESS'
BDLSCHL  BAS   R9,SCHLBL               SEARCH FOR LABEL
         B     BDLGLBL                 BRANCH IF LABEL FOUND
         LR    R1,R11                  COPY BDDD ADDRESS
         SLL   R1,20                   SHIFT OUT B
         SRL   R1,20                   RIGHT JUSTIFY DDD
         CVD   R1,DBLWD                CONVERT DDD
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(4),DBLWD+5(3)     UNPACK
         MVC   OPNDWK,BLANX            CLEAR WORK AREA
         CH    R1,H1000                DISPL < 1000
         BL    BDLD100                 YES
         MVC   OPNDWK(4),DBLWD         MOVE 4-DIGIT DISPL
         LA    R1,OPNDWK+4             TO NEXT POS
         B     BDLLPN                  CONTINUE
BDLD100  CH    R1,H100                 DISPL < 100
         BL    BDLD10                  YES
         MVC   OPNDWK(3),DBLWD+1       MOVE 3-DIGIT DISPL
         LA    R1,OPNDWK+3             TO NEXT POS
         B     BDLLPN                  CONTINUE
BDLD10   CH    R1,H10                  DISPL < 10
         BL    BDLD1                   YES
         MVC   OPNDWK(2),DBLWD+2       MOVE 2-DIGIT DISPL
         LA    R1,OPNDWK+2             TO NEXT POS
         B     BDLLPN                  CONTINUE
BDLD1    MVC   OPNDWK(1),DBLWD+3       MOVE 1-DIGIT DISPL
         LA    R1,OPNDWK+1             TO NEXT POS
BDLLPN   MVI   0(R1),C'('              LEFT PAREN DELIMITER
         CLI   INSTYP,SSR              2-REGS SS FORMAT            -EU-
         BNE   BDLLGEN                 NO                          -EU-
         LA    R1,1(R1)                TO NEXT POSITION            -EU-
         MVI   0(R1),C'R'              SET REGISTER                -EU-
         B     BDLSET                                              -EU-
BDLLGEN  LA    R10,1(R10)              COMPUTE ACTUAL LENGTH       -EU-
BDLSET   CVD   R10,DBLWD               CONVERT                     -EU-
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(3),DBLWD+6(2)     UNPACK
         CH    R10,H100                LENGTH < 100
         BL    BDLL10                  YES
         MVC   1(3,R1),DBLWD           MOVE 3-DIGIT LENGTH
         LA    R1,4(R1)                TO NEXT POS
         B     BDLCMA                  CONTINUE
BDLL10   CH    R10,H10                 LENGTH < 10
         BL    BDLL1                   YES
         MVC   1(2,R1),DBLWD+1         MOVE 2-DIGIT LENGTH
         LA    R1,3(R1)                TO NEXT POS
         B     BDLCMA                  CONTINUE
BDLL1    MVC   1(1,R1),DBLWD+2         MOVE 1-DIGIT LENGTH
         LA    R1,2(R1)                TO NEXT POS
BDLCMA   MVC   0(2,R1),=C',R'          DELIMITERS
         SRL   R11,12                  RT JUSTIFY BASE REG
         CVD   R11,DBLWD               CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         CH    R11,H10                 REG < 10
         BL    BDLR1                   YES
         MVC   2(2,R1),DBLWD           MOVE 2-DIGIT REGISTER
         LA    R1,4(R1)                TO NEXT POS
         B     BDLRPN                  CONTINUE
BDLR1    MVC   2(1,R1),DBLWD+1         MOVE 1-DIGIT REG
         CLI   INSTYP,SSR              2-REGS SS FORMAT            -EU-
         BE    BDLB1                   YES                         -EU-
         CLI   2(R1),C'0'              IS REG = 0
         BNE   BDLB1                   NO
         MVC   0(2,R1),BLANX           YES, BLANK IT
***      BCTR  R1,0                    BACK UP 1            FIX***
         B     BDLRPN                  CONTINUE
BDLB1    LA    R1,3(R1)                TO NEXT POS
BDLRPN   MVI   0(R1),C')'              FINAL DELIMITER
         LR    R10,R1                  COPY END ADDRESS
         S     R10,OWSTRT              COMPUTE OPERAND LENGTH CODE
         L     R9,BDL9                 GET RETURN ADDR
         BR    R9                      EXIT
         USING LABELD,R12
BDLGLBL  MVC   OPNDWK(8),LBLNAME       LABEL ENTRY NAME TO WORK
         LA    R1,OPNDWK+7             @ LAST POSS CHARACTER
BDLGRHE  CLI   0(R1),C' '              AT RHE
         BNE   BDLGCKLN                YES
         BCT   R1,BDLGRHE              LOOP TO RHE
BDLGCKLN CLI   INSTYP,SSR              2-REGS SS FORMAT            -EU-
         BNE   BDLLGGN                 NO                          -EU-
         MVC   1(2,R1),=C'(R'          YES, DELIMITER              -EU-
         LA    R1,1(R1)                ONE POSITION MORE           -EU-
         B     BDLRGN                                              -EU-
BDLLGGN  LA    R10,1(R10)              COMPUTE ACTUAL LENGTH       -EU-
         CLM   R10,B'0001',LBLLEN      LBL AND INSTR LENGTHS SAME  -EU-
         BE    BDLGCMP                 YES
         MVI   1(R1),C'('              NO, DELIMITER
BDLRGN   CVD   R10,DBLWD               CONVERT LENGTH              -EU-
         UNPK  DBLWD(3),DBLWD+5(3)     UNPACK
         OI    DBLWD+2,C'0'            CLEAR SIGN
         CH    R10,H100                LENGTH < 100
         BL    BDLG10                  YES
         MVC   2(3,R1),DBLWD           MOVE 3-DIGIT LENGTH
         LA    R1,5(R1)                TO NEXT POS
         B     BDLGRPN                 CONTINUE
BDLG10   CH    R10,H10                 LENGTH < 10
         BL    BDLG1                   YES
         MVC   2(2,R1),DBLWD+1         MOVE 2-DIGIT LENGTH
         LA    R1,4(R1)                TO NEXT POS
         B     BDLGRPN                 CONTINUE
BDLG1    MVC   2(1,R1),DBLWD+2         MOVE 1-DIGIT LENGTH
         LA    R1,3(R1)                TO NEXT POS
BDLGRPN  MVI   0(R1),C')'              FINAL DELIMITER
BDLGCMP  LR    R10,R1                  COPY END ADDRESS
         S     R10,OWSTRT              COMPUTE LENGTH CODE
         L     R12,SLSAV+12            RESTORE R12
         L     R9,BDL9                 GET RETURN ADDR
         BR    R9                      EXIT
         DROP  R12
         EJECT
******************************************************************
*                                                                *
* BUILDS STORAGE OPERANDS CONTAINING BASE AND DISPLACEMENT.      *
* THE SCHLBL ROUTINE IS CALLED TO SEE WHETHER A LABEL REFERENCE  *
* MAY BE USED, RATHER THAN AN EXPLICIT ADDRESS. IF LBLSCH IS NOT *
* SUCCESSFUL, AN EXPLICIT ADDRESS OF THE FORM DDDD(RRR) IS FORMED*
* ON ENTRY, REG 11 CONTAINS THE BDDD ADDRESS.                    *
*                                                                *
******************************************************************
         SPACE 1
BDADR    ST    R9,BD9                  SAVE RETURN ADDR
         XR    R0,R0                   CLEAR WORK REG
         LR    R1,R11                  COPY BDDD ADDRESS
         SLDL  R0,20                   BASE REG TO R0
         LTR   R0,R0                   IS BASE REG 0
         BNZ   BDSCHL                  NO
         CLI   TEXT,X'9F'              I/O OPERATION?              -EU-
         BH    BDSADR1                 NO                          -EU-
         CLI   TEXT,X'9C'              I/O OPERATION?              -EU-
         BNL   BDAIO                   YES                         -EU-
         CLI   TEXT,X'8F'              SHIFT OPERATION?          FIX***
         BH    BDSADR1                 NO                        FIX***
         CLI   TEXT,X'88'              SHIFT OPERATION?          FIX***
         BNL   BDSCHL                  YES                       FIX***
BDSADR1  SRL   R1,20                   RIGHT JUSTIFY DISPL       FIX***
         CH    R1,H16                  REFERENCE TO CVT ADDR
         BE    BDCVTR                  YES
         CH    R1,H76                  REF TO ALTERNATE CVT ADDR
         BE    BDCVTR                  YES
         MVC   COMMENT(13),=C'PSA REFERENCE'
         B     BDSCHL                  CONTINUE
BDCVTR   MVC   COMMENT(11),=C'CVT ADDRESS'
BDSCHL   BAS   R9,SCHLBL               GO SEARCH FOR LABEL
         B     BDGLBL                  BRANCH IF FOUND
         LR    R1,R11                  COPY BDDD ADDRESS
         SLL   R1,20                   SHIFT OUT B
         SRL   R1,20                   RIGHT JUSTIFY DDD
         CVD   R1,DBLWD                CONVERT DISPL
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(4),DBLWD+5(3)     UNPACK
         CH    R1,H1000                DISPL < 1000
         BL    BDAD100                 YES
         MVC   OPNDWK(4),DBLWD         MOVE 4-DIGIT DISPL
         LA    R1,OPNDWK+4             TO NEXT POS
         B     BDALPN                  CONTINUE
BDAD100  CH    R1,H100                 DISPL < 100
         BL    BDAD10                  YES
         MVC   OPNDWK(3),DBLWD+1       MOVE 3-DIGIT DISPL
         LA    R1,OPNDWK+3             TO NEXT POS
         B     BDALPN                  CONTINUE
BDAD10   CH    R1,H10                  DISPL < 10
         BL    BDAD1                   YES
         MVC   OPNDWK(2),DBLWD+2       MOVE 2-DIGIT DISPL
         LA    R1,OPNDWK+2             TO NEXT POS
         B     BDALPN                  CONTINUE
BDAD1    MVC   OPNDWK(1),DBLWD+3       MOVE 1-DIGIT DISPL
         LA    R1,OPNDWK+1             TO NEXT POS
BDALPN   MVC   0(2,R1),=C'(R'          DELIMITERS
         SRL   R11,12                  RT JUSTIFY BASE REG
         CVD   R11,DBLWD               CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         CH    R11,H10                 BASE REG < 10
         BL    BDAR1                   YES
         MVC   2(2,R1),DBLWD           MOVE 2-DIGIT BASE REG
         LA    R1,4(R1)                TO NEXT POS
         B     BDARPN                  CONTINUE
BDAR1    MVC   2(1,R1),DBLWD+1         MOVE 1-DIGIT BASE REG
         LA    R1,3(R1)                TO NEXT POS
BDARPN   MVI   0(R1),C')'              FINAL DELIMITER
         LR    R2,R1                   COPY END ADDRESS
         SH    R2,H4                   BACK UP 4
         CLC   1(4,R2),=C'(R0)'        BASE REG IS ZERO
         BNE   BDCE                    NO
         MVC   1(4,R2),BLANX           CLEAR BASE REG
         LR    R1,R2                   COPY NEW END ADDR
BDCE     LR    R10,R1                  COPY END ADDR
         S     R10,OWSTRT              COMPUTE LENGTH CODE
         L     R9,BD9                  GET RETURN ADDR
         BR    R9                      EXIT
         USING LABELD,R12
BDGLBL   MVC   OPNDWK(8),LBLNAME       LABEL ENTRY NAME TO WORK
         LA    R1,OPNDWK+7             @ LAST POSS CHARACTER
BDGRHE   CLI   0(R1),C' '              AT RHE
         BNE   BDGCMP                  YES
         BCT   R1,BDGRHE               LOOP TO RHE
BDGCMP   LR    R10,R1                  COPY END ADDRESS
         S     R10,OWSTRT              COMPUTE LENGTH CODE
         L     R12,SLSAV+12            RESTORE R12
         L     R9,BD9                  GET RETURN ADDR
         BR    R9                      EXIT
BDAIO    MVC   OPNDWK(2),=C'X'''       DELIMITERS                  -EU-
         LA    R12,TEXT+2              @ OPERAND                   -EU-
         BAS   R9,HEXPRT2              CONVERT TO PRINTABLE        -EU-
         MVC   OPNDWK+2(3),PRTABL+1    HEX TO OPERAND              -EU-
         MVI   OPNDWK+5,C''''          ENDING QUOTE                -EU-
         LA    R10,5                   LENGTH CODE                 -EU-
         L     R12,SLSAV+12            RESTORE R12                 -EU-
         L     R9,BD9                  GET RETURN ADDR             -EU-
         BR    R9                      EXIT                        -EU-
         EJECT
******************************************************************
*                                                                *
* BUILDS STORAGE OPERANDS CONTAINING BASE, DISPLACEMENT, AND     *
* INDEX. ON ENTRY, REG 11 CONTAINS THE BDDD ADDRESS, AND REG 10  *
* CONTAINS THE INDEX. THE SCHLBL ROUTINE IS CALLED TO CREATE A   *
* LABEL REFERENCE, IF THE BASE REG IS CURRENT, AND A LABEL EXISTS*
* IF SCHLBL IS UNSUCCESSFUL, AN EXPLICIT ADDRESS OF THE FORM     *
* DDDD(XXX,RRR) IS CREATED.                                      *
*                                                                *
******************************************************************
         SPACE 1
BDXADR   ST    R9,BDX9                 SAVE RETURN ADDR
         LTR   R10,R10                 ANY INDEX REG
         BNZ   BDXSCHL                 YES
         XR    R0,R0                   CLEAR WORK REG
         LR    R1,R11                  COPY BDDD ADDRESS
         SLDL  R0,20                   BASE REG TO R0
         LTR   R0,R0                   IS BASE REG 0
         BNZ   BDXSCHL                 NO
         CLI   TEXT,X'41'              IS IT LA
         BE    BDXSCHL                 YES
         SRL   R1,20                   RIGHT JUSTIFY DISPL
         CH    R1,H16                  REFERENCE TO CVT ADDR
         BE    BDXCVTR                 YES
         CH    R1,H76                  REF TO ALTERNATE CVT ADDR
         BE    BDXCVTR                 YES
         MVC   COMMENT(13),=C'PSA REFERENCE'
         B     BDXSCHL                 CONTINUE
BDXCVTR  MVC   COMMENT(11),=C'CVT ADDRESS'
BDXSCHL  BAS   R9,SCHLBL               GO SEARCH FOR LABEL
         B     BDXGLBL                 BRANCH IF FOUND
         LR    R1,R11                  COPY BDDD ADDRESS
         SLL   R1,20                   SHIFT OUT BASE REG
         SRL   R1,20                   RIGHT JUSTIFY DISPL
         SRL   R11,12                  RT JUSTIFY BASE REG
         CVD   R1,DBLWD                CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(4),DBLWD+5(3)     UNPACK
         CH    R1,H1000                DISPL < 1000
         BL    BDXD100                 YES
         MVC   OPNDWK(4),DBLWD         MOVE 4-DIGIT DISPL
         LA    R1,OPNDWK+4             TO NEXT POS
         B     BDXLPN                  CONTINUE
BDXD100  CH    R1,H100                 DISPL < 100
         BL    BDXD10                  YES
         MVC   OPNDWK(3),DBLWD+1       MOVE 3-DIGIT DISPL
         LA    R1,OPNDWK+3             TO NEXT POS
         B     BDXLPN                  CONTINUE
BDXD10   CH    R1,H10                  DISPL < 10
         BL    BDXD1                   YES
         MVC   OPNDWK(2),DBLWD+2       MOVE 2-DIGIT DISPL
         LA    R1,OPNDWK+2             TO NEXT POS
         B     BDXLPN                  CONTINUE
BDXD1    MVC   OPNDWK(1),DBLWD+3       MOVE 1-DIGIT DISPL
         LA    R1,OPNDWK+1             TO NEXT POS
BDXLPN   LTR   R10,R10                 ANY INDEX REG
         BNZ   BDXLPNR                 YES
         LTR   R11,R11                 ANY BASE REG
         BNZ   PREPB                   YES
         BCTR  R1,0                    NO, BACK UP TO RHE
         B     BDXCE                   CONTINUE
PREPB    TM    TEXT+2,X'F0'            REALLY B REG                -EU-
         BZ    PREPX                   NO                          -EU-
         MVC   0(3,R1),=C'(,R'         DELIMITERS
         LA    R1,1(R1)                STEP OVER 1 BYTE
         B     BDXCBAS                 CONTINUE
PREPX    LR    R10,R11                 REVERSE                     -EU-
         XR    R11,R11                                             -EU-
BDXLPNR  MVC   0(2,R1),=C'(R'          DELIMITERS
         CVD   R10,DBLWD               CONVERT INDEX REG
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         CH    R10,H10                 INDEX REG < 10
         BL    BDXX1                   YES
         MVC   2(2,R1),DBLWD           MOVE 2-DIGIT INDEX REG
         LA    R1,4(R1)                TO NEXT POS
         B     BDXCMA                  CONTINUE
BDXX1    MVC   2(1,R1),DBLWD+1         MOVE 1-DIGIT INDEX REG
         LA    R1,3(R1)                TO NEXT POS
BDXCMA   LTR   R11,R11                 ANY BASE REG
         BZ    BDXRPN                  NO
         MVC   0(2,R1),=C',R'          DELIMITERS
BDXCBAS  CVD   R11,DBLWD               CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         CH    R11,H10                 BASE REG < 10
         BL    BDXB1                   YES
         MVC   2(2,R1),DBLWD           MOVE 2-DIGIT BASE REG
         LA    R1,4(R1)                TO NEXT POS
         B     BDXRPN                  CONTINUE
BDXB1    MVC   2(1,R1),DBLWD+1         MOVE 1-DIGIT BASE REG
         LA    R1,3(R1)                TO NEXT POS
BDXRPN   MVI   0(R1),C')'              FINAL DELIMITER
BDXCE    LR    R10,R1                  COPY END ADDR
         S     R10,OWSTRT              COMPUTE LENGTH CODE
         L     R9,BDX9                 GET RETURN ADDR
         BR    R9                      EXIT
         USING LABELD,R12
BDXGLBL  MVC   OPNDWK(8),LBLNAME       LABEL ENTRY NAME TO WORK
         LA    R1,OPNDWK+7             @ LAST POSS CHARACTER
BDXGRHE  CLI   0(R1),C' '              AT RHE
         BNE   BDXGCKLN                YES
         BCT   R1,BDXGRHE              LOOP TO RHE
BDXGCKLN LTR   R10,R10                 ANY INDEX REGISTER
         BZ    BDXGCMP                 NO
         MVI   1(R1),C'('              YES, DELIMITER
         CVD   R10,DBLWD               CONVERT LENGTH
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         OI    DBLWD+1,C'0'            CLEAR SIGN
BDXG10   CH    R10,H10                 LENGTH < 10
         BL    BDXG1                   YES
         MVC   2(2,R1),DBLWD           MOVE 2-DIGIT LENGTH
         LA    R1,4(R1)                TO NEXT POS
         B     BDXGRPN                 CONTINUE
BDXG1    MVC   2(1,R1),DBLWD+1         MOVE 1-DIGIT LENGTH
         LA    R1,3(R1)                TO NEXT POS
BDXGRPN  MVI   0(R1),C')'              FINAL DELIMITER
BDXGCMP  LR    R10,R1                  COPY END ADDRESS
         S     R10,OWSTRT              COMPUTE LENGTH CODE
         L     R12,SLSAV+12            RESTORE R12
         L     R9,BDX9                 GET RETURN ADDR
         BR    R9                      EXIT
         SPACE 2
******************************************************************
*                                                                *
* WRITE OUTPUT TO SYSPUNCH.                                      *
*                                                                *
******************************************************************
         SPACE 1
WRTOUT   L     R1,PUNCHDCB             @ SYSPUNCH DCB
         MVC   PRT(80),WORKREC         SAVE IN PRINT
         TM    48(R1),X'10'            IS FILE OPEN
         BZ    CLRWKR                  NO
         AP    CARDNO,=P'10'           INCREMENT CARD NO
         UNPK  SEQNBR,CARDNO           UNPACK INTO CARD
         OI    SEQNBR+7,C'0'           CLEAR SIGN
         PUT   (1),WORKREC             WRITE SOURCE CARD
CLRWKR   MVC   WORKREC,BLANX           CLEAR OUTPUT RECORD
         BR    R9                      RETURN
         EJECT
******************************************************************
*                                                                *
* SEARCHES THE BASE REGISTER TABLE TO FIND THE BASE REGISTER     *
* ASSOCIATED WITH THE BDDD OPERAND ADDRESS PASSED IN REG 11 ON   *
* ENTRY. IF THE BASE REGISTER GIVEN IS NOT A CURRENT BASE REG    *
* THE UNSUCCESSFUL RETURN IS MADE TO 4 BYTES PAST THE ADDRESS    *
* IN REG 9 ON ENTRY. WHEN THE CURRENT BASE REGISTER ENTRY IS FOR *
* A PROGRAM BASE REG, THE DISPLACEMENT IS ADDED TO THE ASSUMED   *
* BASE REGISTER VALUE IS ADDED TO THE DISPLACEMENT TO GIVE AN    *
* OFFSET IN THE PROGRAM. THE LABEL TABLE IS SEARCHED FOR AN ENTRY*
* WITH THIS OFFSET, AND IF FOUND, IS RETURNED TO THE CALLER. WHEN*
* THE BASE REGISTER FOUND IS FOR A DSECT, THE DSECT HEADER ENTRY *
* ADDRESS IS GIVEN IN THE BASE TABLE ENTRY. THE DSECT HEADER HAS *
* THE ADDRESS OF THE FIELD DEFINITION TABLE FOR THE DSECT. THE   *
* FIELD DEFINITION TABLE IS SEARCHED FOR AN ENTRY HAVING THE     *
* DISPLACEMENT IN THE BDDD INSTRUCTION, AND IF FOUND IS PASSED   *
* BACK TO THE CALLER. IF THE LABEL/FIELD TABLE SEARCHES ARE      *
* UNSUCCESSFUL, RETURN IS TO 4 BYTES PAST REG 9.                 *
*                                                                *
******************************************************************
         SPACE 1
SCHLBL   TM    MORUSG,X'80'            ANY BASES ACTIVE
         BZ    4(R9)                   NO, UNSUCCESSFUL EXIT
         STM   R9,R12,SLSAV            YES, SAVE REGS USED
         LR    R12,R11                 COPY BDDD ADDRESS
         SRL   R12,12                  CLEAR WORK REG
         LTR   R12,R12                 IS BASE REG ZERO
         BZ    SCHNF                   YES, NO LABEL
         MH    R12,USGLEN              BASE X BASE TBL ENTRY LENG
         AL    R12,=A(BASES)           @ BASE TBL ENTRY
         USING USINGD,R12
         CLI   USTYPE,0                ENTRY IN USE
         BE    SCHNF                   NO, EXIT
         LR    R9,R11                  COPY BDDD ADDRESS
         SLL   R9,20                   SHIFT OUT BASE
         SRL   R9,20                   RIGHT JUSTIFY DDD
         ICM   R11,B'0111',USVALU      GET BASE REG VALUE
         LA    R11,0(R11)              CLEAR HI-ORDER
         CLI   USTYPE,C'P'             PROGRAM BASE REG
         BE    PGMBASE                 YES
         DROP  R12
         LR    R12,R11                 COPY DSECT FIELD TBL ADDRESS
         USING DSECTD,R12
CKDSCTND CLM   R9,B'0111',DSOFSET      THIS THE ENTRY
         BE    SCHFD                   YES
         CLC   DSOFSET,HIVAL           NO, AT TABLE END
         BE    SCHNF                   YES, NO LABEL FOUND
         LA    R12,L'DSECT(R12)        STEP TO NEXT ENTRY
         B     CKDSCTND                LOOP THRU DSECT FIELDS
PGMBASE  AR    R9,R11                  COMPUTE OFFSET
         DROP  R12
         L     R12,LBLTBL              @ LABEL TABLE
         USING LABELD,R12
CKENTFD  CLM   R9,B'0111',LBLADR       THIS THE ENTRY
         BE    SCHFD                   YES
         LA    R12,L'LABEL(R12)        TO NEXT ENTRY
         C     R12,CURRLBL             END OF TBL
         BNL   SCHNF                   YES, NO LABEL
         B     CKENTFD                 NO, CONTINUE SEARCH
SCHNF    LM    R9,R12,SLSAV            NOT FOUND, RESTORE REGS
         B     4(R9)                   NOT FOUND RETURN
SCHFD    LM    R9,R11,SLSAV            FOUND RESTORE ALL BUT 12
         BR    R9                      FOUND RETURN
         DROP  R12
         SPACE 2
******************************************************************
*                                                                *
* PRINT A LINE USING THE SYSPRINT DCB DEFINED IN DISASM PHASE 0. *
*                                                                *
******************************************************************
         SPACE 1
PRINT    L     R1,PRINTDCB             @ SYSPRINT DCB
         USING IHADCB,R1                                           -EU-
         TM    DCBOFLGS,DCBOFOPN       IS SYSPRINT OPEN
         BNO   CLRPRT                  NO
         DROP  R1                                                  -EU-
         PUT   (1),PRTLINE             WRITE PRINT LINE
CLRPRT   MVC   PRT,BLANX               CLEAR PRINT LINE
         AP    LINECT,P1               INCR LINE COUNTER
         CLI   PCC,C' '                SINGLE SPACED
         BE    SETSGL                  YES
         AP    LINECT,P1               INCR LINE COUNTER
         CLI   PCC,C'0'                DOUBLE SPACED
         BE    SETSGL                  YES
         AP    LINECT,P1               INCR LINE COUNTER
         CLI   PCC,C'-'                TRIPLE SPACED
         BE    SETSGL                  YES
         ZAP   LINECT,P0               NO, MUST BE NEW PAGE
SETSGL   MVI   PCC,C' '                SET SINGLE SPACING
         CP    LINECT,P58              PAST END OF PAGE
         BH    NEWPAGE                 YES
         BR    R9                      EXIT
NEWPAGE  MVI   PCC,C'1'                SET SKIP TO HOF
         ZAP   LINECT,P0               RESET LINE COUNTER
         BR    R9                      EXIT
         EJECT
******************************************************************
*                                                                *
* CONVERT HEX DATA TO PRINTABLE FORM: 2 CHARACTERS PER BYTE. ON  *
* ENTRY, REG 12 CONTAINS THE ADDRESS OF THE LEFT END OF THE FIELD*
* TO BE CONVERTED, AND THE ENTRY POINT USED DETERMINES THE LENGTH*
* FORMATTED OUTPUT IS PLACED IN THE PRTABL FIELD.                *
*                                                                *
******************************************************************
         SPACE 1
HEXPRT1  UNPK  PRTABL(3),0(2,R12)      UNPACK HEX
         B     HEXCLTR                 CONTINUE
HEXPRT2  UNPK  PRTABL(5),0(3,R12)      UNPACK HEX
         B     HEXCLTR                 CONTINUE
HEXPRT3  UNPK  PRTABL(7),0(4,R12)      UNPACK HEX
         B     HEXCLTR                 CONTINUE
HEXPRT4  UNPK  PRTABL(9),0(5,R12)      UNPACK HEX
HEXCLTR  MVZ   PRTABL(8),XZROS         CLEAR FOR TRANSLATE
         TR    PRTABL(8),TRTBL         MAKE PRINTABLE
         BR    R9                      EXIT
         SPACE 2
******************************************************************
*                                                                *
* FORMATS THE HEX DATA CORRESPONDING TO THE FORMATTED INSTRUCTION*
* BEING OUTPUT. PRINTABLE HEX IS PLACED AT THE RIGHT OF THE LINE *
* ON THE SYSPRINT OUTPUT.                                        *
*                                                                *
******************************************************************
         SPACE 1
TXTFMT   ST    R9,TX9                  SAVE RETURN ADDR
         LA    R11,PRT                 @ PRINT LINE
         CLI   TYPE,1                  ADCON
         BE    TFOFST                  YES
         CLI   TYPE,2                  CONSTANT
         BE    TFOFST                  YES
         CLI   TYPE,X'0D'              INSTRUCTION
         BNE   TXTCLEAN                NO
TFOFST   LA    R12,OFFSET              @ OFFSET TO INSTR
         BAS   R9,HEXPRT3              CONVERT TO PRINTABLE
         MVC   PRT+80(6),PRTABL        OFFSET TO PRINT
         LA    R12,LEN                 @ DATA LENGTH
         BAS   R9,HEXPRT1              MAKE PRINTABLE
         MVC   PRT+88(2),PRTABL        LENGTH TO PRINT
         LA    R12,TEXT                @ TEXT TO PRINT
         BAS   R9,HEXPRT4              CONVERT 1ST 4 BYTES
         CLI   LEN,4                   IS IT 4 BYTES
         BNL   TXT4                    YES, OR MORE
         CLI   LEN,3                   IS IT 3 BYTES
         BE    TXT3                    YES
         CLI   LEN,2                   IS IT 2 BYTES
         BE    TXT2                    YES
         MVC   PRT+94(2),PRTABL        TEXT TO PRINT
         B     TXTCLEAN                FINISH
TXT2     MVC   PRT+94(4),PRTABL        TEXT TO PRINT
         B     TXTCLEAN                FINISH
TXT3     MVC   PRT+94(6),PRTABL        TEXT TO PRINT
         B     TXTCLEAN                FINISH
TXT4     MVC   PRT+94(8),PRTABL        TEXT TO PRINT
         CLI   LEN,4                   IS IT 4 BYTES
         BE    TXTCLEAN                YES, FINISH
         LA    R12,TEXT+4              @ TEXT
         BAS   R9,HEXPRT4              CONVERT
         CLI   LEN,8                   8 BYTES OF TEXT
         BE    TXT8                    YES
         CLI   LEN,7                   7 BYTES OF TEXT
         BE    TXT7                    YES
         CLI   LEN,6                   6 BYTES OF TEXT
         BE    TXT6                    YES
         MVC   PRT+98(2),PRTABL        TEXT TO PRINT
         B     TXTCLEAN                FINISH
TXT6     MVC   PRT+102(4),PRTABL       TEXT TO PRINT
         B     TXTCLEAN                FINISH
TXT7     MVC   PRT+102(6),PRTABL       TEXT TO PRINT
         B     TXTCLEAN                FINISH
TXT8     MVC   PRT+102(8),PRTABL       TEXT TO PRINT
TXTCLEAN XC    OFFSET,OFFSET           CLEAR
         L     R9,TX9                  GET RETURN ADDR
         BR    R9                      EXIT
         EJECT
******************************************************************
*                                                                *
* ENTERED WHENEVER THE CURRENT TEXT OFFSET IS PAST THE NEXCHG    *
* FIELD VALUE. THIS ROUTINE CREATES DROP CARDS FOR EXHAUSTED BASE*
* REGISTERS, AND USING STATEMENTS FOR NEW BASE REGISTERS. THE    *
* BASES TABLE IS SCANNED, AND ANY ENTRY WHICH IS NO LONGER IN USE*
* IS ZEROED OUT, AND A DROP RECORD IS CREATED. NEXT, THE USING   *
* TABLE IS SCANNED. WHEN AN ENTRY IS FOUND WHICH IS VALID AT THE *
* CURRENT OFFSET, THE BASE TABLE IS CHECKED. IF THE ENTRY IS NOT *
* IN USE, A USING STATEMENT IN CREATED, AND THE USING TABLE ENTRY*
* IS MOVED TO THE BASES TABLE. THE NEXCHG FIELD IS CHANGED TO    *
* CONTAIN THE OFFSET AT WHICH THE NEXT SCAN MUST BE MADE. AN IND-*
* ICATOR CALLED MORUSG IS SET TO SHOW WHEN ANY BASE REGISTERS ARE*
* CURRENTLY IN USE. WHEN NO MORE REGISTERS ARE AVAILABLE, THE    *
* NEXCHG FIELD IS SET TO HEX FF'S.                               *
*                                                                *
******************************************************************
         SPACE 1
NEXUSG   MVC   NEXCHG,HIVAL            RESET NEXT CHANGE ADDR
         MVI   MORUSG,0                CLEAR BASE REG AVAIL INDIC
         ST    R9,USG9                 SAVE RETURN ADDR
         L     R2,=A(BASES)                                        -EU-
         XC    0(L'USING,R2),0(R2)     CLEAR R0 ELEMENT            -EU-
         MVC   16*L'USING(4,R2),HIVAL  SET TABLE STOPPER           -EU-
         USING USINGD,R2
         LA    R2,L'USING(R2)          @ R1'S ELEMENT              -EU-
DRPCKND  CLI   0(R2),X'FF'             END OF TABLE
         BE    USGUSG                  YES
         CLC   USEND,XZROS             ENTRY USED
         BE    DRPSTEP                 NO
         CLC   TXTOFSET,USEND          PAST END OF THIS ONE
         BL    DRPSTEP                 NO
         MVC   MNEMONIC(4),=C'DROP'    OPERATION IS DROP
         MVI   OPNDS,C'R'              DELIMITER FOR REGS
         XR    R12,R12                 CLEAR WORK
         IC    R12,USREG               GET REG
         CVD   R12,DBLWD               CONVERT TO PACKED
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         OI    DBLWD+1,C'0'            CLEAR SIGN
         CH    R12,H10                 REG < 10
         BL    DPR1                    YES
         MVC   OPNDS+1(2),DBLWD        MOVE REG NBR
         B     WRTDROP                 GO WRITE DROP
DPR1     MVC   OPNDS+1(1),DBLWD+1      MOVE 1-DIGIT REG
WRTDROP  BAS   R9,WRTOUT               WRITE DROP RECORD
         BAS   R9,PRINT                PRINT DROP RECORD
         XC    USING,USING             CLEAR THE ENTRY
DRPSTEP  LA    R2,L'USING(R2)          TO NEXT BASE ELEMENT
         B     DRPCKND                 LOOP
USGUSG   L     R2,USGSTRT              GET FIRST USING TBL ADDR
ENDUS    CLI   0(R2),X'FF'             END OF TABLE
         BE    XITUS                   YES
         CLC   TXTOFSET,USEND          PAST END OF THIS ONE
         BNL   ECSTEP                  YES
         OI    MORUSG,X'01'            SHOW MORE BASES AVAIL
USBGCK   CLC   TXTOFSET,USBGN          CURR LOC BEFORE THIS
         BNL   CKNEWLO                 NO
         CLC   USBGN,NEXCHG            BEGINS BEFORE NEXT CHANGE
         BNL   ECSTEP                  NO
         MVC   NEXCHG,USBGN            YES, SET LOWER CHANGE OFFSET
         B     ECSTEP                  CONTINUE
CKNEWLO  CLC   USEND,NEXCHG            THIS ENTRY ENDS EARLIER
         BNL   ECMVC                   NO
         MVC   NEXCHG,USEND            YES, SET NEW END
ECMVC    XR    R1,R1                   CLEAR WORK
         IC    R1,USREG                PICK UP REG
         MH    R1,USGLEN               TIMES ENTRY LENGTH
         AL    R1,=A(BASES)            @ BASE TABLE ENTRY          -EU-
         OI    MORUSG,X'80'            SHOW BASE IN USE
         CLC   USING,0(R1)             OLD AND NEW IDENTICAL
         BE    ECSTEP                  YES
MAKUSG   MVC   0(L'USING,R1),USING     NEW USING TO TABLE
         MVC   MNEMONIC(5),=C'USING'   OPERATION IS USING
         CLI   USTYPE,C'D'             IS IT A DSECT
         BNE   CKUTPS                  NO
         ICM   R12,B'0111',USVALU      YES, GET DSECT HEADER ADDR
         L     R11,DTBSTRT             @ 1ST DSECT HEADER ENTRY
DSCTEND  C     R11,DTBCURR             END OF TABLE
         BH    MVDSNAME                YES
         USING DTDS,R11                                            -EU-
         CLM   R12,B'0111',DTADDR      THIS THE HEADER ENTRY       -EU-
         BE    MVNAME                  YES                         -EU-
         LA    R11,L'DTL(R11)          TO NEXT HEADER ENTRY        -EU-
         B     DSCTEND                 LOOP THRU TABLE
MVNAME   MVC   OPNDS(8),DTNAME         NAME TO OPERANDS            -EU-
         B     MVDSNAME+L'MVDSNAME     CONTINUE                    -EU-
         DROP  R11                                                 -EU-
MVDSNAME MVC   OPNDS(8),0(R12)         DSECT NAME TO OPERANDS
         LA    R12,OPNDS+7             TO END OF NAME
USFRHED  CLI   0(R12),C' '             FOUND RHE
         BNE   USFMADD                 YES
         BCT   R12,USFRHED             BACK UP 1 AND LOOP
USFMADD  LA    R12,1(R12)              TO NEXT BYTE
USFMCMA  MVC   0(2,R12),=C',R'         DELIMITERS
         XR    R11,R11                 CLEAR WORK
         IC    R11,USREG               GET REGISTER NBR
         CVD   R11,DBLWD               CONVERT TO PACKED
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK REG NBR
         OI    DBLWD+1,C'0'            CLEAR SIGN
         CH    R11,H10                 REG < 10
         BL    USFMR1                  YES
         MVC   2(2,R12),DBLWD          MOVE 2-DIGIT REG NBR
         B     USINGOUT                GO WRITE USING
USFMR1   MVC   2(1,R12),DBLWD+1        MOVE 1-DIGIT REG NBR
USINGOUT BAS   R9,WRTOUT               WRITE USING STMT
         BAS   R9,PRINT                PRINT USING STMT
         B     ECSTEP                  CONTINUE
CKUTPS   CLC   USVALU,TXTOFSET         USING AT CURR LOC
         BNE   USFMLBL                 NO
         MVI   OPNDS,C'*'              SET CURRENT LOC SYMBOL IN OPERAN
         LA    R12,OPNDS+1             GET NEXT POS ADDR
         B     USFMCMA                 GO FORMAT REG
USFMLBL  L     R12,LBLTBL              @ LABEL TABLE               -EU-
         USING LABELD,R12                                          -EU-
USLBSCH  CLC   USVALU,LBLADR           THIS THE ENTRY              -EU-
         BNE   USLBNXT                 YES                         -EU-
         CLI   LBLTYP,C'L'             TYPE LABEL                  -EU-
         BE    USLBFND                 YES                         -EU-
USLBNXT  LA    R12,L'LABEL(R12)        TO NEXT ENTRY               -EU-
         C     R12,CURRLBL             END OF TBL                  -EU-
         BNL   USLBSCN                 YES, NO LABEL               -EU-
         B     USLBSCH                 NO, CONTINUE SEARCH         -EU-
USLBFND  MVC   OPNDS(8),LBLNAME                                    -EU-
         DROP  R12                                                 -EU-
         LA    R12,OPNDS               SET NEXT LOC                -EU-
USLBSNL  CLI   0(R12),C' '                                         -EU-
         BE    USFMCMA                 GO FORMAT REG               -EU-
         LA    R12,1(R12)                                          -EU-
         B     USLBSNL                                             -EU-
USLBSCN  MVI   OPNDS,C'A'              SET 1ST CHAR OF LABEL NAME
         LA    R12,USVALU              GET OFFSET
         BAS   R9,HEXPRT3              CONVERT TO PRINTABLE
         MVC   OPNDS+1(6),PRTABL       PRINTABLE HEX TO LABEL
         LA    R12,OPNDS+7             TO NEXT LOC
         B     USFMCMA                 FORMAT REG
ECSTEP   LA    R2,L'USING(R2)          TO NEXT USING ENTRY
         B     ENDUS                   CONTINUE SCAN
         DROP  R2                                                  -EU-
XITUS    L     R9,USG9                 GET RETURN ADDR
         BR    R9                      EXIT
         EJECT
******************************************************************
*                                                                *
* END OF PHASE 2 - RETURN TO PHASE 0                             *
*                                                                *
******************************************************************
         SPACE 1
         PRINT GEN                                                 -EU-
EOJ      BAS   R9,FORCONST             YES, FORCE IT OUT
         SVBCK ,                       RETURN TO CALLER            -EU-
         EJECT
         DEFCOM DSECT=YES                                          -EU-
         EJECT  ,                                                  -EU-
         DEFCDS ,                                                  -EU-
         EJECT
DISASM2  CSECT
         SPACE 1
OWSTRT   DC    A(OPNDWK)               @ OPERAND WORK AREA
OPND9    DC    A(OPNDRTN)              RETURN ADDR FOR OPERAND ROUTINES
USG9     DC    F'0'                    RETURN SAVE
EQU9     DC    F'0'                    RETURN ADDR FOR EQUSTMT
FC6      DC    F'0'                    SAVE AREA FOR R6
FC9      DC    F'0'                    FORCONST RETURN ADDR
TX9      DC    F'0'                    RETURN ADDR FOR TXTFMT
BD9      DC    F'0'                    RETURN FOR BDADR
BDX9     DC    F'0'                    RETURN FOR BDXADR
BDL9     DC    F'0'                    RETURN FOR BDLADR
SLSAV    DC    4F'0'                   SAVE FOR SCHLBL
ILENG    DC    H'0'                    INSTRUCTION LENGTH  FIX***
CONPROG  DC    X'00'                   CONSTANT IN PROGRESS INDIC
CONPSLBL DC    0CL13' '                PSEUDO LABEL ENTRY FOR CONSTANTS
         DC    XL4'0'
CONNAME  DC    CL8' '                  CONSTANT NAME
CONLLEN  DC    XL1'0'                  LABEL LENGTH
CONTYPE  DC    CL1' '                  TYPE
CCTYPE   DC    X'00'                   CC SET TYPE OF INSTR SETTING
CONDATA  DC    0H'0',XL8'0'            CONSTANT DATA
CONSYM   DC    CL8' '                  CONSTANT SYMBOL
CONLEN   DC    H'0'                    CONSTANT LENGTH
CONOFST  DC    F'0'                    RELATIVE OFFSET TO CONSTANT
CONLOC   DC    F'0'                    @ CURRENT BYTE IN CONSTANT
TXTOFST  DS    0F
         DC    X'0'
TXTOFSET DC    XL3'0'                  OFFSET TO TEXT BYTE
OPNDWK   DC    CL13' '                 OPERAND BUILD AREA
OFFSET   DC    XL3'0'                  OFFSET FROM PGM START
INSTYP   DC    CL1' '                  INSTRUCTION TYPE
TYPE     DC    XL1'0'                  TYPE CODE
*                                       0=CSECT, 1=ADCON, 2=CONST
*                                       E=USING, D=INSTRUCTION
*                                       C=COMMENT, 9=ENTRY
*                                       A=EQU
LEN      DC    XL1'0'                  TEXT LENGTH
TEXT     DC    XL8'0'                  TEXT
MORUSG   DC    X'00'                   80=CURRENT BASE, 01=MORE BASES
H1       DC    H'1'                    CONSTANT 1
H2       DC    H'2'                    CONSTANT 2
H4       DC    H'4'                    CONSTANT 4
H7       DC    H'7'                    CONSTANT 7
H8       DC    H'8'                    CONSTANT 8
H10      DC    H'10'                   CONSTANT 10
H11      DC    H'11'                   CONSTANT 11
H13      DC    H'13'                   CONSTANT 13
H14      DC    H'14'                   CONSTANT 14
H16      DC    H'16'                   CONSTANT 16
H76      DC    H'76'                   CONSTANT 76
H100     DC    H'100'                  CONSTANT 100
H1000    DC    H'1000'                 CONSTANT 1000
P0       DC    P'0'                    CONSTANT 0
P1       DC    P'1'                    CONSTANT 1
P58      DC    P'58'                   CONSTANT 58
USGLEN   DC    0H'0',AL2(L'USING)      LENGTH OF USING TBL ENTRIES
XZROS    DC    16X'00'                 CONSTANT ZEROS
HIVAL    DC    4X'FF'                  CONSTANT X F'S
NEXCHG   DC    XL3'00'                 OFFSET TO NEXT BASE REG CHG
BLANX    DC    CL121' '                CONSTANT BLANKS
TRTBL    DC    C'0123456789ABCDEF'     TRANSLATE TBL
PRTABL   DC    CL9' '                  PRINTABLE HEX WORK
         SPACE 2                                                   -EU-
         DEFINS ,                                                  -EU-
         EJECT
         LTORG
         EJECT ,                                                   -EU-
* END OF BASE REGISTERS ADDRESSABILITY - - - - - - - - - - - - - - -EU-
         SPACE 1                                                   -EU-
RSMASKS  DC    C'0000',C'0001',C'0010',C'0011'   MASK BITS TABLE   -EU-
         DC    C'0100',C'0101',C'0110',C'0111'                     -EU-
         DC    C'1000',C'1001',C'1010',C'1011'                     -EU-
         DC    C'1100',C'1101',C'1110',C'1111'                     -EU-
BASES    DC    XL256'00'               BASE REG TABLE
CHARTRAN DC    256X'FF'           TRT TABLE FOR CHAR/HEX DETERMINATION
         ORG   CHARTRAN+C' '
         DC    X'00'                   BLANK IS CHARACTER
         ORG   CHARTRAN+C'A'
         DC    9X'00'                  A-I ARE CHARACTERS
         ORG   CHARTRAN+C'J'
         DC    9X'00'                  J-R ARE CHARACTERS
         ORG   CHARTRAN+C'S'
         DC    8X'00'                  S-Z ARE CHARACTERS
         ORG   CHARTRAN+C'0'
         DC    10X'00'                 0-9 ARE CHARACTERS
         ORG
         SPACE 2
         END
