LICF     TITLE 'LISTICAT - LIST AN ICF CATALOG.'                   -EU-
         PRINT OFF                                                 -EU-
         COPY  LISTICMC                                            -EU-
         PRINT ON                                                  -EU-
         SPACE 2                                                   -EU-
LISTICAT START 0                                                   -EU-
         SPACE 2                                                   -EU-
         COPY  LISTICDC                                            -EU-
         SPACE 2                                                   -EU-
&NAME    SETC  'LISTICAT'
&VERSION SETC  '1.2.2'
         EJECT ,                                                   -EU-
         $REGS
         EJECT ,                                                   -EU-
*        LIST AN ICF CATALOG.                                      -EU-
         SPACE 1                                                   -EU-
         $PROLOG R10,R11,R12                                       -EU-
         L     R4,=V(DATASECT)     COMMON DATA AREA
         USING DATASECT,R4
         L     R1,0(0,R1)          GET PARM POINTER
         LH    R3,0(0,R1)          GET PARM SIZE
         LTR   R3,R3               ANY PARM GIVEN?
         BZ    NOPARM              NO, ASSUME LIST
         CLC   2(4,R1),=C'DUMP'    HEX LISTING WANTED
         BNE   NOPARM              NO, ASSUME LIST
         B     HEXPRINT            DO A HEX LISTING
NOPARM   DS    0H
        $MESSAGE 1                                                 @122
         XPROPEN PWA,                                                  X
               PAGELEN=PAGELEN,                                        X
               DDNAME=SYSPRINT     OPEN LISTING FILE.
         LTR   R15,R15             DID SYSPRINT OPEN?
         BNZ   EODICAT             IF NOT, NO REPORT.
         BAS   R9,ALLVVDS          ALLOCATE ALL VVDS'S
         BAS   R9,OPICAT           OPEN REQUESTED CATALOG (SYSUT1) -EU-
         BAS   R9,GENRPL           GENERATE RPL FOR BCS.           @120
         EJECT ,                                                   -EU-
*        READ BCS RECORDS AND SCAN FOR CELL TYPES.                 -EU-
         SPACE 1                                                   -EU-
GETNEXT  L     R1,RPLICAT          PICK UP RPL ADDRESS.
         GET   RPL=(1)             READ A BCS RECORD.
         AP    BCSGETS,ONE         KEEP TRACK OF GETS ISSUED.
         LTR   R15,R15             RECORD READ OK?
         BZ    GETOK               GO PROCESS IT.
         ABEND 15,DUMP             TOO BAD!
GETOK    L     R3,BUFPTR           ADDR OF CATALOG RECORD
         L     R1,RPLICAT          ADDR OF BCS RPL.
         L     R1,48(0,R1)         LENGTH OF RECORD READ
         AR    R1,R3               POINT TO END OF CATALOG RECORD
         ST    R1,ENDBCS           SAVE END OF RECORD.
         LA    R3,2(,R3)           SKIP OVER PREFIX
NEXTCELL CLI   2(R3),C'A'          A = NONVSAM
         BE    NONVSAM
         CLI   2(R3),C'C'          C = CLUSTER
         BE    CLUSTER
         CLI   2(R3),C'D'          D = DATA
         BE    DATA
         CLI   2(R3),C'I'          I = INDEX
         BE    INDEX
         CLI   2(R3),C'B'          B = GDG BASE
         BE    GDGBASE
         CLI   2(R3),C'H'          H = GDG ENTRY
         BE    GDGENT
         CLI   2(R3),C'G'          G = ALTERNATE INDEX
         BE    AIX
         CLI   2(R3),C'R'          R = PATH
         BE    PATH
ENDCELL  XC    BLKSIZE,BLKSIZE     RESET BLKSIZE
         XC    LRECL,LRECL         RESET LRECL
         XC    TRACKS,TRACKS       RESET TRACKS.
         XR    R1,R1               CLEAR REGISTER.
         ICM   R1,3,0(R3)          PICK UP CELL LENGTH
         AR    R3,R1               POINT TO NEXT CELL
         C     R3,ENDBCS           ANY MORE CELLS IN THIS RECORD?
         BL    NEXTCELL            YES, KEEP GOING
         B     GETNEXT             READ ANOTHER RECORD.
EODICAT  EQU   *                   LAST BCS RECORD READ.
         CLOSE ACBICAT
         CLI   MCDSOPEN,255        DID WE OPEN THE MCDS?           @122
         BNE   EODICAT1            NO.                             @122
         CLOSE ACBMCDS             IF OPEN, CLOSE IT.              @122
EODICAT1 BAS   R9,COUNTS           PRINT THE STATS.                @122
         XPRCLOSE  PWA             CLOSE THE PRINT FILE.
        $MESSAGE 0                                                 @122
         $EPILOG ,                 AND GO HOME.
         EJECT ,                                                   -EU-
*- - - - LIST A NONVSAM RECORD.                                    -EU-
         SPACE 1                                                   -EU-
         USING NVNC,R3
NONVSAM  AP    CNTNVSAM,ONE        COUNT OFF A NONVSAM.
         CLI   BASESW,255          WAS A GDGBASE JUST BEFORE THIS.
         BNE   NONVSAM1            NO.
         AP    CNTNOENT,ONE        COUNT A GDGBASE WITH NO ENTRIES.
         MVI   BASESW,0            SWITCH OFF.
NONVSAM1 MVC   L1DSNAME,NVNAME     SETUP DSNAME
         MVC   L1TYPE,=C'NONVSAM'  SAY WHAT TYPE IT IS.
         BAS   R9,SETCREDT         FORMAT CREATION DATE.
         ICM   R0,1,=XL1'04'       VOLUME CELL TO BE FOUND.
         BAS   R9,FINDBCS          SO GO LOOK FOR IT.
         DROP  R3
         USING VOLCELL,R3
         MVC   L1VOLUME,VOLSERN    SETUP VOLUME SERIAL NUMBER
         LA    R5,VOLDEVTP         DEVICE TYPE                     -EU-
        $DVTYUN (R5),L1UNIT        GET UNIT NAME                   -EU-
         LTR   R15,R15             OK?                             -EU-
         BZ    NONVSAM3            YES                             -EU-
         MVC   L1UNIT(4),=C'????'  NO, CALL IT ???? (NOT FOUND)    -EU-
         B     NONVSAM5                                            -EU-
NONVSAM3 XR    R5,R5                                               -EU-
         TM    VOLDEVTP+2,X'20'    IS IT A DASD DEVICE?            -EU-
         BZ    NONVSAM4            NO                              -EU-
         L     R1,CVTPTR           GET CVT ADDRESS                 -EU-
         USING CVT,R1                                              -EU-
         L     R1,CVTZDTAB         DEV. CONSTANT TABLE ADDRESS     -EU-
         DROP  R1                                                  -EU-
         XR    R14,R14                                             -EU-
         LR    R15,R14                                             -EU-
         IC    R14,VOLDEVTP+3      GET DEVICE TYPE                 -EU-
         IC    R15,0(R14,R1)       GET DISPLACEMENT OF TABLE       -EU-
         LA    R15,0(R15,R1)       COMPUTE ADDRESS OF TABLE        -EU-
         CLR   R15,R1                                              -EU-
         BE    NONVSAM4            DEVICE NOT IN 'IECZDTAB' TABLE  -EU-
         ICM   R5,B'0011',2(R15)   NUMBER OF TRACKS PER CYLINDER   -EU-
NONVSAM4 ST    R5,TRKCYL           SAVE FOR LATER CALCULATION      -EU-
         TM    VOLDEVTP+2,X'20'    IS IT A DASD DEVICE?            -EU-
         BZ    NONVSAM5            IF NOT, NO VTOC TO SEARCH.
         BAS   R9,VTOC             GET DSCB FIELDS
NONVSAM5 CLC   L1VOLUME,=C'MIGRAT' IS IT MIGRATED BY HSM
         BNE   NONVSAM6            IF NOT, SKIP MCDS CHECK.
         BAS   R9,CHKHSM           SETUP MCDS FIELDS.
NONVSAM6 L     R1,LRECL            PICK UP LRECL VALUE.
         CVD   R1,WORK             CONVERT LRECL TO PACKED
         EDIT  L1LRECL,DWK3,ZZZZZ  FORMAT IT NICELY
         L     R1,BLKSIZE          PICK UP BLOCK SIZE.
         CVD   R1,WORK             CONVERT BLKSIZE TO PACKED
         EDIT  L1BLKSIZ,DWK3,ZZZZZ FORMAT IT NICELY
         L     R1,TRACKS           PICK UP ALLOCATED TRACKS
         CVD   R1,WORK             CONVERT TRACKS TO PACKED
         EDIT  L1TRACKS,DWK4,ZZZZZZZ    FORMAT IT NICELY.
         LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1
         BAS   R9,PRINT            PRINT LINE DESCRIBING THIS DATASET.
         B     ENDCELL             PROCESS NEXT BCS CELL.
         DROP  R3
         EJECT ,                                                   -EU-
*- - - - LIST A CLUSTER RECORD.                                    -EU-
         SPACE 1                                                   -EU-
         USING VCNC,R3
CLUSTER  AP    CNTCLUST,ONE        COUNT A CLUSTER.
         CLI   BASESW,255          WAS A GDGBASE JUST BEFORE THIS.
         BNE   CLUSTER1            NO.
         AP    CNTNOENT,ONE        COUNT A GDGBASE WITH NO ENTRIES.
         MVI   BASESW,0            SWITCH OFF.
CLUSTER1 MVC   L1DSNAME,CLNAME     SETUP CLUSTER NAME.
         MVC   L1TYPE,=C'CLUSTER'  CALL IT A CLUSTER.
         CLI   FIRST,0             FIRST CLUSTER CELL?
         BNE   NOTCL00             NO
         MVI   FIRST,255           THAT WAS THE ONE.
         ST    R3,SAVECL           FIRST CLUSTER HAS BCS NAME.
GETBCSD  XR    R1,R1               CLEAR A FEW BYTES.
         ICM   R1,3,0(R3)          PICK UP CELL LENGTH
         AR    R3,R1               POINT TO NEXT CELL
         CLI   2(R3),C'D'          IS IT A DATA CELL?
         BNE   GETBCSD             KEEP ON LOOKING.
         DROP  R3
**-EU-   USING DINC,R3
**-EU-   XR    R1,R1                                               @121
**-EU-   IC    R1,DIDKEYLN         GET LENGTH OF CATALOG NAME.     @121
**-EU-   B     *+10                                                @121
**-EU-   MVC   CATNAME(0),DIDKEY   SETUP CATNAME IN HEADING.       @121
**-EU-   EX    R1,*-6                                              @121
         BAS   R9,SETHEAD          DEFINE REPORT HEADING.
         L     R3,SAVECL           RESTORE CELL ADDR TO CLUSTER.
NOTCL00  BAS   R9,SETCREDT         FORMAT CREATION DATE.
         LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1
         BAS   R9,PRINT            PRINT LINE.
         B     ENDCELL             PROCESS NEXT BCS CELL.
**-EU-   DROP  R3
         USING DINC,R3
DATA     MVC   L1TYPE,=CL7'DATA'   DATA CELL (PARDON THE EXPRESSION)
         AP    CNTDATA,ONE         COUNT IT.
         B     SKIPDATA            GOTO COMMON FORMATTING LOGIC.
INDEX    MVC   L1TYPE,=CL7'INDEX'  CALL IT AN INDEX
         AP    CNTINDEX,ONE        AND COUNT IT.
SKIPDATA XR    R1,R1               CLEAR A REGISTER.
         IC    R1,DIDKEYLN         LENGTH OF INDEX/DATA NAME
         EX    R1,DIDMOVE          MOVE COMPONENT NAME FOR PRINT
         CLI   BASESW,255          WAS A GDGBASE JUST BEFORE THIS.
         BNE   CLUSTER2            NO.
         AP    CNTNOENT,ONE        COUNT A GDGBASE WITH NO ENTRIES.
         MVI   BASESW,0            SWITCH OFF.
CLUSTER2 BAS   R9,SETCREDT         FORMAT CREATION DATE.
         ICM   R0,1,=XL1'04'       VOLUME CELL TO BE FOUND.
         BAS   R9,FINDBCS          SO GO LOOK FOR IT.
         DROP  R3
         USING VOLCELL,R3
         MVC   L1VOLUME,VOLSERN    SETUP VOLUME SERIAL NUMBER
         LA    R5,VOLDEVTP         DEVICE TYPE                     -EU-
        $DVTYUN (R5),L1UNIT        GET UNIT NAME                   -EU-
         LTR   R15,R15             OK?                             -EU-
         BZ    CLUSTER3            YES                             -EU-
         MVC   L1UNIT(4),=C'????'  NO, CALL IT ???? (NOT FOUND)    -EU-
         B     CLUSTER5                                            -EU-
CLUSTER3 XR    R5,R5                                               -EU-
         TM    VOLDEVTP+2,X'20'    IS IT A DASD DEVICE?            -EU-
         BZ    CLUSTER4            NO                              -EU-
         L     R1,CVTPTR           GET CVT ADDRESS                 -EU-
         USING CVT,R1                                              -EU-
         L     R1,CVTZDTAB         DEV. CONSTANT TABLE ADDRESS     -EU-
         DROP  R1                                                  -EU-
         XR    R14,R14                                             -EU-
         LR    R15,R14                                             -EU-
         IC    R14,VOLDEVTP+3      GET DEVICE TYPE                 -EU-
         IC    R15,0(R14,R1)       GET DISPLACEMENT OF TABLE       -EU-
         LA    R15,0(R15,R1)       COMPUTE ADDRESS OF TABLE        -EU-
         CLR   R15,R1                                              -EU-
         BE    CLUSTER4            DEVICE NOT IN 'IECZDTAB' TABLE  -EU-
         ICM   R5,B'0011',2(R15)   NUMBER OF TRACKS PER CYLINDER   -EU-
CLUSTER4 ST    R5,TRKCYL           SAVE FOR LATER CALCULATION      -EU-
CLUSTER5 MVC   RBASAVE,VOLVVRBA    SAVE RBA OF CI CONTAINING VVR CELL.
         DROP  R3
         L     R5,VVDSTAD          GET VVDSTAB START ADDR
         USING VVDSTAB,R5
CLUSTER8 CLI   VVDSVOL,255         LAST ENTRY?
         BE    CLUSTER7            YES, OH WELL.
         CLC   VVDSVOL,L1VOLUME    IS THIS THE VVDS?
         BNE   CLUSTER6            NO, TRY AGAIN
         ICM   R1,15,RBASAVE       GET VVR RBA
         STCM  R1,15,VVDSARG       INSERT INTO ARG FIELD FOR RPL
         ICM   R8,15,VVDSRPL       PICK UP RPL ADDR
         POINT RPL=(R8)            POSITION TO DESIRED RECORD
         GET   RPL=(R8)            READ IN RECORD
         AP    VVDSGETS,ONE        KEEP A COUNT.
         LTR   R15,R15             RECORD READ OK?
         L     R6,VVDSBUF          ADDR OF CATALOG RECORD
         L     R1,VVDSRPL          GET ADDR OF RPL
         L     R1,48(0,R1)         LENGTH OF RECORD READ
         AR    R1,R6               POINT TO END OF CATALOG RECORD
         ST    R1,ENDVVD           SAVE END OF RECORD
         LA    R6,2(,R6)           SKIP OVER PREFIX
         BAS   R9,VVDS             PROCESS VVDS FIELDS.
         C     R15,=F'8'           DID WE GET THEM?                @122
         BNE   CLUSTER6            YES.                            @122
        $MESSAGE 4,DATA=L1DSNAME                                   @122
         B     CLUSTER9            PRINT WHAT WE GOT.              @122
CLUSTER6 LA    R5,VVDSTLEN(0,R5)   NEXT ENTRY
         B     CLUSTER8            TRY NEXT VVDS
         DROP  R5
CLUSTER7 L     R1,LRECL            PICK UP LOGICAL RECORD LENGTH.
         CVD   R1,WORK             CONVERT LRECL TO PACKED
         EDIT  L1LRECL,DWK3,ZZZZZ  FORMAT IT NICELY
         L     R1,BLKSIZE          GET PHYSICAL BLOCK LENGTH.
         CVD   R1,WORK             CONVERT BLKSIZE TO PACKED
         EDIT  L1BLKSIZ,DWK3,ZZZZZ FORMAT IT NICELY.
         L     R1,TRACKS           PICK UP ALLOCATED TRACKS.
         CVD   R1,WORK             CONVERT TRACKS TO PACKED
         EDIT  L1TRACKS,DWK4,ZZZZZZZ    FORMAT IT NICELY.
CLUSTER9 LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1    @122
         BAS   R9,PRINT            PRINT LINE.
         B     ENDCELL             PROCESS NEXT BCS CELL.
         USING DINC,R3
DIDMOVE  MVC   L1DSNAME(0),DIDKEY  -> (EXECUTED) <-
         DROP  R3
         EJECT ,                                                   -EU-
*- - - - LIST AN ALTERNATE INDEX RECORD.                           -EU-
         SPACE 1                                                   -EU-
         USING ANC,R3
AIX      AP    CNTAIX,ONE          COUNT AN AIX ENTRY.
         CLI   BASESW,255          WAS A GDGBASE JUST BEFORE THIS.
         BNE   AIX0                NO.
         AP    CNTNOENT,ONE        COUNT A GDGBASE WITH NO ENTRIES.
         MVI   BASESW,0            SWITCH OFF.
AIX0     MVC   L1TYPE,=CL7'AIX'    CALL IT AN AIX.
         XR    R1,R1               CLEAR A REGISTER.
         ICM   R1,1,AIXKEYLN       PICK UP AIX NAME LENGTH
         B     AIX1                BRANCH AROUND EXECUTED INSTRUCTION.
         MVC   L1DSNAME(0),AIXKEY  EXECUTED
AIX1     EX    R1,*-6              MOVE AIX NAME TO PRINT LINE.
         HEX   RPTLINE1+75,                                            X
               ANC,7,HEXTAB=TRHEX  HEX TRANSLATE AIX CELL CONTENTS.
         LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1
         BAS   R9,PRINT            PRINT LINE.
         B     ENDCELL             PROCESS NEXT CELL.
         SPACE 2                                                   -EU-
*- - - - LIST A PATH RECORD.                                       -EU-
         SPACE 1                                                   -EU-
         USING PNC,R3
PATH     AP    CNTPATH,ONE         COUNT A PATH CELL.
         CLI   BASESW,255          WAS A GDGBASE JUST BEFORE THIS.
         BNE   PATH0               NO.
         AP    CNTNOENT,ONE        COUNT A GDGBASE WITH NO ENTRIES.
         MVI   BASESW,0            SWITCH OFF.
PATH0    MVC   L1TYPE,=CL7'PATH'   CALL IT A PATH.
         XR    R1,R1               CLEAR A REGISTER.
         ICM   R1,1,PATHKYLN       PICK UP PATH NAME LENGTH
         B     PATH1               BRANCH AROUND EXECUTED INSTRUCTION.
         MVC   L1DSNAME(0),PATHNAME  EXECUTED
PATH1    EX    R1,*-6              MOVE PATH NAME TO PRINT LINE.
         LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1
         BAS   R9,PRINT            PRINT LINE.
         B     ENDCELL             PROCESS NEXT CELL.
         EJECT ,                                                   -EU-
*- - - - LIST A GDG BASE OR GDG ENTRY RECORD.                      -EU-
         SPACE 1                                                   -EU-
         USING GDGNC,R3
GDGBASE  AP    CNTGDGB,ONE         COUNT A BASE.
         CLI   BASESW,255          WAS A GDGBASE JUST BEFORE THIS.
         BNE   GDGBASE1            NO.
         AP    CNTNOENT,ONE        COUNT A GDGBASE WITH NO ENTRIES.
GDGBASE1 MVI   BASESW,255          IDENTIFY GDGBASE.
         MVC   L1TYPE,=CL7'GDGBASE'  IDENTIFY RECORD TYPE
         MVC   L1DSNAME,GDGNAME    SETUP GDGNAME.
         MVC   GDGSAVE,GDGNAME     SAVE GDGNAME.
         BAS   R9,SETCREDT         FORMAT CREATION DATE.
         LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1
         BAS   R9,PRINT            PRINT LINE.
         B     ENDCELL             PROCESS NEXT CELL.
         DROP  R3
         USING GDSNC,R3
GDGENT   AP    CNTGDGE,ONE         COUNT IT.
         CLI   BASESW,255          PRECEEDED BY GDGBASE?
         BNE   GDGENT0             ???????
         MVI   BASESW,0            SWITCH OFF
GDGENT0  MVC   L1TYPE,=CL7'GDG ENT'  IDENTIFY RECORD TYPE
         MVC   GDGWORK,GDGSAVE     START WITH BASE NAME.
         LA    R1,GDGWORK          GET ADDRESS OF BASE NAME
         LA    R8,44               44 BYTES AT MOST
GDGENT1  CLI   0(R1),C' '          SCAN FOR A BLANK
         BE    GDGENT2             YES.
         LA    R1,1(0,R1)          TRY NEXT CHARACTER.
         BCT   R8,GDGENT1          KEEP LOOKING
GDGENT2  XR    R8,R8               CLEAR A REGISTER.
         ICM   R8,3,GDSGENO        PICK UP GENERATION NUMBER.
         CVD   R8,GWORD            PACK IT.
         UNPK  2(4,R1),GWK3        UNPACK GENERATION NUMBER.
         OI    5(R1),X'F0'         FIX SIGN
         XR    R8,R8               CLEAR A REGISTER.
         ICM   R8,1,GDSVERNO       PICK UP VERSION NUMBER.
         CVD   R8,GWORD            PACK IT.
         UNPK  7(2,R1),GWK2        UNPACK VERSION NUMBER.
         OI    8(R1),X'F0'         FIX SIGN
         MVC   0(2,R1),=C'.G'      SET G0000
         MVI   6(R1),C'V'          G0000V00
         MVC   L1DSNAME,GDGWORK    MOVE IN DEVELOPED NAME
         BAS   R9,SETCREDT         FORMAT CREATION DATE.
         ICM   R0,1,=XL1'04'       VOLUME CELL TO BE FOUND.
         BAS   R9,FINDBCS          SO GO LOOK FOR IT.
         DROP  R3
         USING VOLCELL,R3
         MVC   L1VOLUME,VOLSERN    SETUP VOLUME SERIAL NUMBER
         LA    R5,VOLDEVTP         DEVICE TYPE                     -EU-
        $DVTYUN (R5),L1UNIT        GET UNIT NAME                   -EU-
         LTR   R15,R15             OK?                             -EU-
         BZ    GDGENT5             YES                             -EU-
         MVC   L1UNIT(4),=C'????'  NO, CALL IT ???? (NOT FOUND)    -EU-
         B     GDGENT7                                             -EU-
GDGENT5  XR    R5,R5                                               -EU-
         TM    VOLDEVTP+2,X'20'    IS IT A DASD DEVICE?            -EU-
         BZ    GDGENT6             NO                              -EU-
         L     R1,CVTPTR           GET CVT ADDRESS                 -EU-
         USING CVT,R1                                              -EU-
         L     R1,CVTZDTAB         DEV. CONSTANT TABLE ADDRESS     -EU-
         DROP  R1                                                  -EU-
         XR    R14,R14                                             -EU-
         LR    R15,R14                                             -EU-
         IC    R14,VOLDEVTP+3      GET DEVICE TYPE                 -EU-
         IC    R15,0(R14,R1)       GET DISPLACEMENT OF TABLE       -EU-
         LA    R15,0(R15,R1)       COMPUTE ADDRESS OF TABLE        -EU-
         CLR   R15,R1                                              -EU-
         BE    GDGENT6             DEVICE NOT IN 'IECZDTAB' TABLE  -EU-
         ICM   R5,B'0011',2(R15)   NUMBER OF TRACKS PER CYLINDER   -EU-
GDGENT6  ST    R5,TRKCYL           SAVE FOR LATER CALCULATION      -EU-
         TM    VOLDEVTP+2,X'20'    IS IT A DASD DEVICE?            -EU-
         BZ    GDGENT7             IF NOT, NO VTOC TO SEARCH.
         BAS   R9,VTOC             GET DSCB FIELDS
GDGENT7  CLC   L1VOLUME,=C'MIGRAT'  IS IT MIGRATED BY HSM?
         BE    GDGENT8             IF SO, THAT'S IT.
         L     R1,LRECL            PICK UP LOGICAL RECORD LENGTH
         CVD   R1,WORK             CONVERT LRECL TO PACKED
         EDIT  L1LRECL,DWK3,ZZZZZ  FORMAT IT NICELY
         L     R1,BLKSIZE          PICK UP BLOCK SIZE.
         CVD   R1,WORK             CONVERT BLKSIZE TO PACKED
         EDIT  L1BLKSIZ,DWK3,ZZZZZ FORMAT WITH ZERO SUPPRESSION.
         L     R1,TRACKS           PICK UP ALLOCATED TRACKS.
         CVD   R1,WORK             CONVERT TRACKS TO PACKED
         EDIT  L1TRACKS,DWK4,ZZZZZZZ    MAKE IT PRINTABLE.
         DROP  R3
GDGENT8  LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1
         BAS   R9,PRINT            PRINT LINE.
         B     ENDCELL             PROCESS NEXT BCS CELL.
         EJECT ,                                                   -EU-
*        READ FORMAT1 DSCB AND SETUP DCB AND SPACE INFO.           -EU-
         SPACE 1                                                   -EU-
* THIS CODE USES OBTAIN TO READ IN THE FORMAT 1 DSCB AND A FORMAT 3
* DSCB IF ONE EXISTS. INFORMATION IS EXTRACTED AND PLACED INTO THE
* FIELDS : LRECL, BLKSIZE AND TRACKS.
         SPACE 1                                                   -EU-
VTOC     $IN ,
         XC    BLKSIZE,BLKSIZE     RESET BLKSIZE
         XC    LRECL,LRECL         RESET LRECL
         XC    TRACKS,TRACKS       RESET TRACKS.
         MVC   CAMVOL,L1VOLUME     USE VOLSER FROM BCS VOLCELL.
         CLC   CAMVOL,=C'MIGRAT'   IS IT MIGRATED?
         BE    VTOC99              IF SO, WHY BOTHER.
         MVC   CAMDSN,L1DSNAME     USE DSNAME FROM BCS.
         OBTAIN  SEARCH            READ FORMAT 1 DSCB BY DSNAME.
         ST    R15,OBTAINRC        SAVE OBTAIN RETURN CODE.
         LTR   R15,R15             WAS IT THERE?
         BZ    VTOC1               YES.
         AP    CNTNF,ONE           OTHERWISE COUNT AN ORPHAN.
         B     VTOC99              AND LEAVE IT BLANK.
VTOC1    XR    R1,R1               CLEAR REGISTER 1.
         ICM   R1,3,FORMAT1+42     PICK UP BLKSIZE
         ST    R1,BLKSIZE          AND SAVE FOR PRINT OUT.
         ICM   R1,3,FORMAT1+44     PICK UP LRECL
         ST    R1,LRECL            AND SAVE FOR PRINT OUT.
         MVC   SV1EXT1(30),FORMAT1+61  SAVE EXTENTS 1 TO 3
         CLC   FORMAT1+91,=5X'00'  IS THERE A FORMAT 3?
         BE    VTOC2A              NO, SKIP IT.
         MVC   CCHHR3,FORMAT1+91   POINTER TO FORMAT 3 DSCB.
         OBTAIN  F3CAMLST          READ FORMAT 3 BY DISK ADDRESS.
         LTR   R15,R15             DID WE GET IT?
         BNZ   VTOC2A              OH WELL
         MVC   SV3EXT4(40),FORMAT3+4  EXTENTS 4,5,6 AND 7.
         MVC   SV3EXT8(90),FORMAT3+45  EXTENTS 8 TO 16.
VTOC2A   XR    R15,R15             ZERO LOOP REGISTER
         XR    R7,R7               ZERO INDEX REGISTER
         XR    R8,R8               ZERO COUNT OF TRACKS ALLOCATED.
         IC    R15,FORMAT1+15      GET NUMBER OF EXTENTS
         LTR   R15,R15             ARE THERE ANY EXTENTS?
         BZ    VTOC5A              SKIP IT IF ZERO EXTENT
VTOC5B   EX    R0,EXTLIST(R7)      GET AN EXTENT ADDR IN R5.
         CLI   0(R5),X'00'         IS THIS AN ACTIVE EXTENT?
         BE    VTOC5C              IF NOT, SKIP IT.
         XR    R0,R0               CLEAR A REGISTER.
         ICM   R0,3,2(R5)          STARTING CC
         XR    R14,R14             CLEAR A REGISTER.
         L     R14,TRKCYL          TRACKS PER CYLINDER
         SRDA  R0,32               SETUP FOR MULTIPLY.
         MR    R0,R14              R1 = TRKS IN FULL CYLINDERS.
         ICM   R14,3,4(R5)         STARTING TT
         AR    R1,R14              STARTING RELATIVE TRACK.
         ST    R1,STARTTRK         SAVE IT.
         XR    R0,R0               CLEAR A REGISTER.
         ICM   R0,3,6(R5)          ENDING CC
         XR    R14,R14             CLEAR A REGISTER.
         L     R14,TRKCYL          TRACKS PER CYLINDER
         SRDA  R0,32               SETUP FOR MULTIPLY.
         MR    R0,R14              R1 = TRKS IN FULL CYLINDERS.
         ICM   R14,3,8(R5)         ENDING TT
         AR    R1,R14              STARTING RELATIVE TRACK.
         S     R1,STARTTRK         TRACKS IN THIS EXTENT IN R1
         LA    R1,1(,R1)           KEEP IT HONEST
         AR    R8,R1               COUNT IT
         LA    R7,4(,R7)           SKIP TO NEXT LA INSTRUCTION.
VTOC5C   BCT   R15,VTOC5B          LOOP THROUGH ALL EXTENTS.
VTOC5A   LA    R8,0(0,R8)          PURIFY A REGISTER.
         STCM  R8,15,TRACKS        TRACKS ALLOCATED
VTOC99   $OUT  ,                   RETURN
EXTLIST  LA    R5,SV1EXT1
         LA    R5,SV1EXT2
         LA    R5,SV1EXT3
         LA    R5,SV3EXT4
         LA    R5,SV3EXT5
         LA    R5,SV3EXT6
         LA    R5,SV3EXT7
         LA    R5,SV3EXT8
         LA    R5,SV3EXT9
         LA    R5,SV3EXT10
         LA    R5,SV3EXT11
         LA    R5,SV3EXT12
         LA    R5,SV3EXT13
         LA    R5,SV3EXT14
         LA    R5,SV3EXT15
         LA    R5,SV3EXT16
         EJECT ,                                                   -EU-
*        ALLOCATE ALL ONLINE VVDS'S.                               -EU-
         SPACE 1                                                   -EU-
* PASS THROUGH THE UCB LOOKUP TABLE. USING UCBVOLI DEVELOP A DSNAME OF
* SYS1.VVDS.VVOLSER. TRY TO DYNAMICALLY ALLOCATE IT. IF SUCCESSFUL
* GENERATE AN ACB AND AN RPL AND SAVE THEIR ADDRESSES. FINALLY OPEN
* THE VVDS.
         SPACE 1                                                   -EU-
ALLVVDS  $IN ,
         LA    R0,VVDSGETL         LENGTH OF TABLE.
         GETMAIN R,LV=(0)
         ST    R1,VVDSTAD          SAVE TABLE START ADDRESS
         LR    R5,R1               R5 AS BASE REG FOR VVDS TABLE.
         USING VVDSTAB,R5
         L     R3,CVTPTR          GET CVT ADDRESS                  @120
         USING CVTMAP,R3          ADDRESS TO CVT                   @120
         XC    UCBWORK,UCBWORK    CLEAR WORK AREA                  @120
         LA    R1,UCBWORK         GET ADDRESS OF WORK AREA         @120
         ST    R1,PARMWA          STORE ADDR IN PARMLIST           @120
         LA    R1,DEVCLASS        ADDR OF DEVICE CLASS             @120
         ST    R1,PARMDEVT        STORE ADDR IN PARMLIST           @120
         MVI   DEVCLASS,UCB3DACC  SEARCH FOR DASD UCBS ONLY        @120
         LA    R1,ADDRUCB         ADDR OF RETURNED UCB             @120
         ST    R1,PARMUCB         STORE UCB IN PARMLIST            @120
         OI    PARMUCB,X'80'      END OF PARMLIST                  @120
         L     R1,CVTUCBSC        GET SCAN SERVICE ROUTINE         @120
         DROP  R3                                                  @120
         ST    R1,SCANSAVE        HOLD FOR LATER                   @120
UCBLOOP  LA    R1,PARMLIST        PUT ADDR INTO REG 1              @120
         L     R15,SCANSAVE       GET SCAN SERVICE RTN             @120
         BASR  R14,R15            GO TO SCAN SERVICE INTERFACE     @120
         LTR   R15,R15            WAS A UCB RETURNED?              @120
         BNZ   LASTUCB            NO.                              @120
         USING UCBOB,R2           ADDR TO UCB DSECT                @120
         L     R2,ADDRUCB         GET RETURNED UCB ADDR            @120
         TM    UCBSTAT,UCBONLI     IS IT ONLINE?                   @120
         BZ    UCBLOOP             NO, KEEP GOING                  @120
         B     ALLVVDS1            PROCESS DASD VOLUME.            @120
LASTUCB  B     ALLVVDS9                                            @120
ALLVVDS1 MVC   VVDSNAME,UCBVOLI    SET UP VOLSER IN DSNAME
         MVC   VVDDNAME,UCBVOLI    SET UP VOLSER IN DDNAME
         MVC   VVDSVOL,UCBVOLI     SAVE VOLSER IN TABLE.
         ALLOC DSN=LOCDSN,DISP=SHR,DDN=LOCDDN,ERROR=UCBLOOP
         GENCB BLK=ACB,AM=VSAM,BUFSP=32768,DDNAME=(*,VVDDN),           X
               MACRF=(ADR,SEQ)
         LTR   R15,R15             ACB GENERATED?
         BNZ   UCBLOOP             IF NOT, SKIP THIS VOLUME.
         STCM  R1,15,VVDSACB       STORE ACB ADDRESS
         GENCB BLK=RPL,AM=VSAM,ACB=(*,VVDSACB),AREA=(S,VVDSBUF),       X
               OPTCD=(ADR,SEQ,LOC),ARG=(S,VVDSARG)
         LTR   R15,R15             RPL GENERATED?
         BNZ   UCBLOOP             IF NOT, SKIP THIS VOLUME.
         STCM  R1,15,VVDSRPL       STORE RPL ADDRESS
        SETAUTH ,                                                  -EU-
**-EU-   LA    R0,1                AUTHORIZATION ON.
**-EU-   SVC   232                 **** INSTALLATION DEPENDANT. ****
         ICM   R8,15,VVDSACB       GET ACB ADDRESS
         OPEN  ((R8))              OPEN VVDS
         LTR   R15,R15             DID IT OPEN?                    @122
         BZ    ALLVVDS2            YES.                            @122
        RESAUTH ,                                                  -EU-
**-EU-   XR    R0,R0                                               @122
**-EU-   SVC   232                                                 @122
        $MESSAGE 5,DATA=UCBVOLI                                    @122
         B     UCBLOOP             TRY NEXT VOLUME.                @122
ALLVVDS2 RESAUTH ,                                             @122-EU-
**-EU-   XR    R0,R0               AUTHORIZATION OFF.
**-EU-   SVC   232                 **** INSTALLATION DEPENDANT. ****
         LA    R5,VVDSTLEN(0,R5)   NEXT VVDSTAB ENTRY
         B     UCBLOOP             TRY NEXT VOLUME                 @120
ALLVVDS9 MVI   0(R5),255           SET END OF TABLE.
         $OUT  ,                   ALL DONE.
         EJECT ,                                                   -EU-
*        COLLECT DATA FROM VVDS CELLS.                             -EU-
         SPACE 1                                                   -EU-
* I ENTER AT THIS POINT HAVING READ IN THE 1ST RECORD IN THE CI
* CONTAINING THE DATA I WANT. FIRSTLY I HAVE TO SKIP AHEAD TO FIND
* THE VVR FOR THE OBJECT I AM LISTING (NB: THE FIRST VVR I FIND MAY
* NOT BE IT, IE. A DATA VVR IF I'M LISTING AN INDEX).
         SPACE 1
VVDS     $IN ,
         XR    R15,R15             RESET RETURN CODE.              @122
         XC    BLKSIZE,BLKSIZE     RESET BLKSIZE
         XC    LRECL,LRECL         RESET LRECL
         XC    TRACKS,TRACKS       RESET TRACKS.
         USING VVR,R6
VVDS0    CLI   2(R6),C'Q'          Q = SECONDARY VVR
         BE    VVDS0B              YES, IS IT THE RIGHT ONE?
         CLI   2(R6),C'Z'          Z = PRIMARY VVR
         BE    VVDS0B              YES, IS IT THE RIGHT ONE?
VVDS0A   XR    R0,R0               NEXT CELL PLEASE
         BAS   R9,FINDVVDS         ADVANCE R6 TO NEXT CELL.
         C     R15,=F'8'           PROBLEMS?                       @122
         BNE   VVDS0               NO. IS IT A VVR?                @122
        $MESSAGE 3,DATA=L1DSNAME                                   @122
         LA    R15,8               RC=8 FOR CALLER.                @122
         B     VVDS99                                              @122
VVDS0B   XR    R1,R1
         ICM   R1,1,VVRCMPNL       PICK UP NAME LENGTH.
         BCTR  R1,0
         BCTR  R1,0
         B     VVDS0C
         CLC   L1DSNAME(0),VVRCMPNM  (EXECUTED)
VVDS0C   EX    R1,*-6              COMPARE VVR NAME TO BCS NAME.
         BNE   VVDS0A              NO, MUST BE A RELATED COMPONENT.
         CLI   2(R6),C'Q'          Q = SECONDARY VVR
         BE    VVDS1               YES, IS IT THE RIGHT ONE?
         CLI   2(R6),C'Z'          Z = PRIMARY VVR
         BE    VVDS2               YES, IS IT THE RIGHT ONE?
         B     VVDS99              SHOULD NEVER HAPPEN!
VVDS1    ICM   R0,1,=XL1'23'       VOLUME INFORMATION CELL
         BAS   R9,FINDVVDS         FIND NEXT VVDS CELL.
         USING VVRVOLIN,R6
         MVC   BLKSIZE,VVRBLKSZ    SAVE BLOCK SIZE.
         XR    R1,R1               COUNT OF TRACKS
         XR    R8,R8
         ICM   R8,1,VVRNOEXT       GET NUMBER OF EXTENTS
         LA    R6,40(0,R6)         SKIP AHEAD TO EXTENT DESCR.
         USING VVRXTENT,R6
VVDS1B   AH    R1,VVRXNTRK         COUNT TRACKS THIS EXTENT
         LA    R6,20(0,R6)         SKIP TO NEXT EXTENT DESCR.
         BCT   R8,VVDS1B
         ST    R1,TRACKS           SAVE ALLOCATED TRACKS.
         B     VVDS99
         DROP  R6
VVDS2    ICM   R0,1,=XL1'21'       DATASET INFORMATION CELL.
         BAS   R9,FINDVVDS         FIND NEXT VVDS CELL.
         USING VVRDSINF,R6
         MVC   LRECL,VVRLRECL      SAVE AVERAGE LRECL
         B     VVDS1               LOOK FOR VOLUME INFORMATION CELL
         DROP  R6
VVDS99   $OUT  ,
         EJECT ,                                                   -EU-
*        PRINT A HEX LISTING.                                      -EU-
         SPACE 1                                                   -EU-
HEXPRINT XPROPEN PWA,PAGELEN=PAGELEN,DDNAME=SYSPRINT
         LTR   R15,R15             DID SYSPRINT OPEN?
         BNZ   EODICAT             IF NOT, NO REPORT.
         XPRHEAD PWA,LIST=(HEADER1,HEADER3)
         BAS   R9,ALLVVDS          ALLOCATE ALL VVDS'S
         BAS   R9,OPICAT           OPEN REQUESTED CATALOG (SYSUT1) -EU-
         BAS   R9,GENRPL           GENERATE RPL ADDR.              @120
GETNEXTH L     R1,RPLICAT          GET RPL ADDR.
         GET   RPL=(1)
         LTR   R15,R15             RECORD READ OK?
         L     R3,BUFPTR           ADDR OF CATALOG RECORD
         L     R2,RPLICAT          GET RPL ADDR FROM LAST GET.
         L     R2,48(0,R2)         LENGTH OF RECORD READ
         AR    R2,R3               POINT TO END OF CATALOG RECORD
         ST    R2,ENDBCS           SAVE FOR FINDBCS ROUTINE
         LA    R3,2(,R3)           SKIP OVER PREFIX
HEXNEXT  CLI   2(R3),C'A'          A = NONVSAM
         BE    HEXNVSAM
         CLI   2(R3),C'C'          C = CLUSTER
         BE    HEXCLUST
         CLI   2(R3),C'D'          D = DATA COMPONENT
         BE    HEXDATA
         CLI   2(R3),C'I'          I = INDEX COMPONENT
         BE    HEXINDEX
ENDHEX   XR    R1,R1
         ICM   R1,3,0(R3)          PICK UP CELL LENGTH
         AR    R3,R1               POINT TO NEXT CELL
         C     R3,ENDBCS           ANY MORE CELLS IN THIS RECORD?
         BL    HEXNEXT             YES, KEEP GOING
         B     GETNEXTH            READ ANOTHER RECORD.
         EJECT ,                                                   -EU-
*- - - - HEX PRINT A NONVSAM CELL.                                 -EU-
         SPACE 1                                                   -EU-
         USING NVNC,R3
HEXNVSAM MVC   L2TYPE,=CL7'NONVSAM'
         AP    CNTNVSAM,ONE        COUNT OFF A NONVSAM             @120
         HEX   L2WORK,NVCELEN,2,HEXTAB=TRHEX      LENGTH OF NVNC
         HEX   L2WORK+5,NVTYPE,1,HEXTAB=TRHEX     TYPE 'A' FOR NONVSAM
         HEX   L2WORK+8,NVRESV,1,HEXTAB=TRHEX     RESERVED
         HEX   L2WORK+11,NVOLCNT,                                      X
               2,HEXTAB=TRHEX      NUMBER OF VOLUME CELLS (255 MAX)
         HEX   L2WORK+16,NVKEYLN,                                      X
               1,HEXTAB=TRHEX      LENGTH OF THE NONVSAM KEY
         MVC   L2WORK+19(44),NVNAME
         LM    R0,R1,PLINE2A       PARMS TO SKIP BEFORE RPTLINE2
         BAS   R9,PRINT            PRINT LINE.
         BAS   R9,HEXOWNER         OWNER CELL NEXT.
         BAS   R9,HEXASSOC         ASSOCIATION (IF PRESENT).
         BAS   R9,HEXVOL           VOLUME CELL(S).
         B     ENDHEX
         DROP  R3
         EJECT ,                                                   -EU-
*- - - - HEX PRINT A CLUSTER CELL.                                 -EU-
         SPACE 1                                                   -EU-
         USING VCNC,R3
HEXCLUST MVC   L2TYPE,=CL7'CLUSTER'
         AP    CNTCLUST,ONE        COUNT A CLUSTER                 @120
         HEX   L2WORK,CLCELLN,                                         X
               2,HEXTAB=TRHEX      LENGTH OF VCNC INCLUDING ITSELF
         HEX   L2WORK+5,CLTYPE,1,HEXTAB=TRHEX     TYPE 'C' FOR CLUSTER
         HEX   L2WORK+8,CLCOMPLN,                                      X
               2,HEXTAB=TRHEX      LENGTH OF THE CLUSTER COMPONENT
         HEX   L2WORK+13,CLNOEXT,                                      X
               1,HEXTAB=TRHEX      NUMBER OF EXTENSION RECORDS
         HEX   L2WORK+16,CLNMLEN,                                      X
               1,HEXTAB=TRHEX      LENGTH OF THE CLUSTER KEY (45)
         MVC   L2WORK+19(44),CLNAME
         LM    R0,R1,PLINE2A       PARMS TO SKIP BEFORE RPTLINE2
         BAS   R9,PRINT            PRINT LINE.
         BAS   R9,HEXOWNER         OWNER CELL NEXT.
         BAS   R9,HEXSECUR         SECURITY CELL (IF PRESENT).
         BAS   R9,HEXASSOC         ASSOCIATION (IF PRESENT).
         BAS   R9,HEXRELAT         RELATIONSHIP CELL (?)
         B     ENDHEX
         DROP  R3
         EJECT ,                                                   -EU-
*- - - - HEX PRINT A DATA OR INDEX CELL.                           -EU-
         SPACE 1                                                   -EU-
         USING DINC,R3
HEXDATA  MVC   L2TYPE,=CL7'DATA'
         AP    CNTDATA,ONE         COUNT IT                        @120
         B     HEXDATA1
HEXINDEX MVC   L2TYPE,=CL7'INDEX'
         AP    CNTINDEX,ONE        COUNT IT.                       @120
HEXDATA1 HEX   L2WORK,DIDLEN,2,HEXTAB=TRHEX  LENGTH OF DINC
         HEX   L2WORK+5,DIDTYPE,                                       X
               1,HEXTAB=TRHEX      TYPE 'D' FOR DATA OR INDEX
         HEX   L2WORK+8,DIDCMPLN,                                      X
               2,HEXTAB=TRHEX      LENGTH OF DINC COMPONENT
         HEX   L2WORK+13,DIDIRFLG,                                     X
               1,HEXTAB=TRHEX      INTERRUPT RECOGNITION FLAGS
         HEX   L2WORK+16,DIDKEYLN,1,HEXTAB=TRHEX  CONDENSED KEYLENGTH
         XR    R1,R1
         ICM   R1,1,DIDKEYLN       GET LENGTH OF NAME KEY.
         B     *+10
         MVC   L2WORK+19(0),DIDKEY
         EX    R1,*-6              MOVE IN NAME KEY.
         B     *+10
         MVC   SVCOMPN(0),DIDKEY   SAVE COMPONENT NAME
         EX    R1,*-6              MOVE IN NAME KEY.
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         BAS   R9,PRINT            PRINT LINE.
         BAS   R9,HEXOWNER         OWNER CELL NEXT.
         BAS   R9,HEXSECUR         SECURITY CELL (IF PRESENT).
         BAS   R9,HEXVOL           VOLUME CELL(S).
         B     ENDHEX
         DROP  R3
         EJECT ,                                                   -EU-
*        HEX AN OWNER CELL.                                        -EU-
         SPACE 1                                                   -EU-
HEXOWNER $IN ,
         ICM   R0,1,=XL1'01'       OWNER CELL TYPE.
         BAS   R9,FINDBCS          LOOK FOR IT.
         USING OWNERC,R3
         MVC   L2TYPE,=CL7' OWNER'
         HEX   L2WORK,OWNCELLN,                                        X
               2,HEXTAB=TRHEX      LENGTH OF OWNERSHIP CELL
         HEX   L2WORK+5,OWNTYPE,1,HEXTAB=TRHEX    TYPE X'01' FOR OWNER
         HEX   L2WORK+8,OWNID,4,HEXTAB=TRHEX      OWNER ID
         HEX   L2WORK+16,OWNID+4,4,HEXTAB=TRHEX   OWNER ID
         HEX   L2WORK+25,OWNFLAG,1,HEXTAB=TRHEX   FLAG
         HEX   L2WORK+28,OWNCREDT,3,HEXTAB=TRHEX  CREATION DATE
         HEX   L2WORK+35,OWNEXPDT,3,HEXTAB=TRHEX  EXPIRY DATE
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         BAS   R9,PRINT            PRINT LINE.
         $OUT  ,                   GET OUT.
         EJECT ,                                                   -EU-
*        HEX AN ASSOCIATION CELL.                                  -EU-
         SPACE 1                                                   -EU-
HEXASSOC $IN ,
         ICM   R0,3,=XL2'FF03'     TYPE X'03', OPTIONAL.
         BAS   R9,FINDBCS          IS THERE ONE?
         LTR   R0,R0               SO WAS THERE?
         BZ    HEXASS99            NO.
         USING ASSOCC,R3
         MVC   L2TYPE,=CL7' ASSOC'
         HEX   L2WORK,ASCLEN,                                          X
               2,HEXTAB=TRHEX      ASSOCIATION CELL LENGTH
         HEX   L2WORK+5,ASCTYPE,1,HEXTAB=TRHEX    TYPE X'03' FOR ASSOC
         HEX   L2WORK+8,ASCOUNT,2,HEXTAB=TRHEX    COUNT OF ASSOCIATIONS
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         BAS   R9,PRINT            PRINT LINE.
HEXASS99 $OUT  ,                   GET OUT
         EJECT ,                                                   -EU-
*        HEX A SECURITY CELL.                                      -EU-
         SPACE 1                                                   -EU-
HEXSECUR $IN ,
         ICM   R0,3,=XL2'FF02'     TYPE X'02', OPTIONAL.
         BAS   R9,FINDBCS          IS THERE ONE?
         LTR   R0,R0               SO WAS THERE?
         BZ    HEXSEC99            NO.
         USING SECURITY,R3
         MVC   L2TYPE,=CL7' SECUR'
         HEX   L2WORK,SECELLN,                                         X
               2,HEXTAB=TRHEX      LENGTH OF SECURITY CELL
         HEX   L2WORK+5,SECTYPE,                                       X
               1,HEXTAB=TRHEX      TYPE X'02' FOR SECURITY.
         HEX   L2WORK+8,SECMSTR,4,HEXTAB=TRHEX    MASTER PASSWORD.
         HEX   L2WORK+16,SECMSTR+4,4,HEXTAB=TRHEX MASTER PASSWORD.
         HEX   L2WORK+27,SECCI,                                        X
               4,HEXTAB=TRHEX      CONTROL INTERVAL PASSWORD.
         HEX   L2WORK+35,SECCI+4,                                      X
               4,HEXTAB=TRHEX      CONTROL INTERVAL PASSWORD.
         HEX   L2WORK+44,SECUPDTE,4,HEXTAB=TRHEX  UPDATE PASSWORD.
         HEX   L2WORK+52,SECUPDTE+4,4,HEXTAB=TRHEX     UPDATE PASSWORD.
         HEX   L2WORK+61,SECREAD,4,HEXTAB=TRHEX   READ PASSWORD.
         HEX   L2WORK+69,SECREAD+4,4,HEXTAB=TRHEX READ PASSWORD.
         HEX   L2WORK+78,SECPMTCD,                                     X
               4,HEXTAB=TRHEX      PASSWORD PROMPTING CODE.
         HEX   L2WORK+86,SECPMTCD+4,                                   X
               4,HEXTAB=TRHEX      PASSWORD PROMPTING CODE.
         HEX   L2WORK+95,SECATMP,                                      X
               2,HEXTAB=TRHEX      MAXIMUM NUMBER OF ATTEMPTS.
         HEX   L2WORK+100,SECVRMOD,                                    X
               4,HEXTAB=TRHEX      USER SECURITY VERIFICATION MOD.
         HEX   L2WORK+108,SECVRMOD+4,                                  X
               4,HEXTAB=TRHEX      USER SECURITY VERIFICATION MOD.
         HEX   L2WORK+117,SECRCDLN,                                    X
               2,HEXTAB=TRHEX      USER AUTHORIZATION RECORD LENGTH
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         BAS   R9,PRINT            PRINT LINE.
HEXSEC99 $OUT  ,                   GET OUT
         EJECT ,                                                   -EU-
*        HEX A RELATION CELL.                                      -EU-
         SPACE 1                                                   -EU-
HEXRELAT $IN ,
         ICM   R0,3,=XL2'FF06'     OPTIONAL RELAT CELL
         BAS   R9,FINDBCS          LOOK FOR IT.
         LTR   R0,R0               WAS IT THERE?
         BZ    HEXREL99            NO.
         USING RELCELL,R3
         MVC   L2TYPE,=CL7' RELAT'
         HEX   L2WORK,RELLEN,2,HEXTAB=TRHEX       CELL LENGTH.
         HEX   L2WORK+5,RELTYPE,1,HEXTAB=TRHEX    TYPE X'06'
         HEX   L2WORK+8,RELRESV,1,HEXTAB=TRHEX    RESERVED.
         HEX   L2WORK+11,RELCNT,1,HEXTAB=TRHEX    COUNT OF RELKEYS.
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         BAS   R9,PRINT            PRINT LINE.
HEXREL99 $OUT  ,                   GET OUT
         EJECT ,                                                   -EU-
*        HEX A VOLUME CELL.                                        -EU-
         SPACE 1                                                   -EU-
* THIS LOGIC IS ENTERED AT A POINT WHERE THERE MUST BE AT LEAST ONE
* VOLUME CELL POINTED TO BY R3. HOWEVER THERE COULD BE MORE THAN ONE.
* HENCE, AFTER THE FIRST NON-VOLUME CELL IS RECOGNIZED R3 MUST BE
* BACKED UP TO THE LAST VOLUME CELL SO THAT THE GENERAL CODE AT
* "ENDHEX" CAN SKIP OVER IT.
         SPACE 1                                                   -EU-
HEXVOL   $IN ,
HEXVOL0  ICM   R0,3,=XL2'FF04'     VOLUME CELL
         BAS   R9,FINDBCS
         LTR   R0,R0               WAS THAT THE LAST ONE?
         BZ    HEXVOL99            YES.
         USING VOLCELL,R3
         MVC   L2TYPE,=CL7' VOLUME'
         HEX   L2WORK,VOLLEN,2,HEXTAB=TRHEX       LENGTH OF VOLCELL
         HEX   L2WORK+5,VOLTYPE,                                       X
               1,HEXTAB=TRHEX      TYPE X'04' FOR VOLUME CELL
         HEX   L2WORK+8,VOLOFSET,1,HEXTAB=TRHEX   UNUSED
         MVC   L2WORK+11(6),VOLSERN
         HEX   L2WORK+18,VOLDEVTP,4,HEXTAB=TRHEX  DEVICE TYPE
         HEX   L2WORK+27,VOLFLAG1,1,HEXTAB=TRHEX  FLAG
         HEX   L2WORK+30,VOLFLAG2,1,HEXTAB=TRHEX  RESERVED
         HEX   L2WORK+33,VOLVVRBA,                                     X
               4,HEXTAB=TRHEX      RELATIVE BYTE ADDRESS OF VVR
         HEX   L2WORK+42,VOLFLSEQ,                                     X
               2,HEXTAB=TRHEX      NONVSAM FILE SEQUENCE NUMBER (TAPE)
         HEX   L2WORK+47,VOLKRQL,                                      X
               4,HEXTAB=TRHEX      KEYRANGE QUALIFIER (VSAM ONLY)
         HEX   L2WORK+56,VOLLKYLN,                                     X
               2,HEXTAB=TRHEX      LENGTH OF LOW KEY RANGE KEY
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         BAS   R9,PRINT            PRINT LINE.
         TM    VOLFLAG1,VOLNVSAM   IS IT NONVSAM?
         BO    HEXVOL99            IF SO, THAT'S ALL
         TM    VOLFLAG1,VOLCANDI   IS IT A CANDIDATE VOLUME?
         BO    HEXVOL99            IF SO, THAT'S ALL
         MVC   RBASAVE,VOLVVRBA    SAVE RBA OF VVR
         L     R5,VVDSTAD          GET VVDSTAB START ADDR
         USING VVDSTAB,R5
HEXVOL8  CLI   VVDSVOL,255         LAST ENTRY?
         BE    HEXVOL99            YES, OH WELL.
         CLC   VVDSVOL,VOLSERN     IS THIS THE VVDS?
         BNE   HEXVOL6             NO, TRY AGAIN
         ICM   R1,15,RBASAVE       GET VVR RBA
         STCM  R1,15,VVDSARG       INSERT TO ARG FIELD FOR THIS RPL
         ICM   R8,15,VVDSRPL       PICK UP RPL ADDR
         POINT RPL=(R8)            POSITION TO DESIRED RECORD
         GET   RPL=(R8)            READ IN RECORD
         LTR   R15,R15             RECORD READ OK?
         L     R6,VVDSBUF          ADDR OF CATALOG RECORD
         L     R1,VVDSRPL          GET ADDR OF RPL
         L     R1,48(0,R1)         LENGTH OF RECORD READ
         AR    R1,R6               POINT TO END OF CATALOG RECORD
         ST    R1,ENDVVD           SAVE END OF RECORD ADDR
         LA    R6,2(,R6)           SKIP OVER PREFIX
         BAS   R9,HEXVVR           PRIMARY OR 2NDARY VVR
         BAS   R9,HEXDSINF         DATASET INFORMATION CELL (MAYBE)
         BAS   R9,HEXAMDSB         AMDSB CELL (IF PRESENT)
         BAS   R9,HEXVOLIN         VOLUME INFORMATION CELL.
         B     HEXVOL0             COULD BE MORE THAN ONE.
HEXVOL6  LA    R5,VVDSTLEN(0,R5)   NEXT ENTRY
         B     HEXVOL8             WHAT IS IT JOHNNY?
HEXVOL99 $OUT  ,                   GET OUT.
         DROP  R3
         EJECT ,                                                   -EU-
*        HEX PRINT A VVR.                                          -EU-
         SPACE 1                                                   -EU-
* I ENTER AT THIS POINT HAVING READ IN THE 1ST RECORD IN THE CI
* CONTAINING THE DATA I WANT. FIRSTLY I HAVE TO SKIP AHEAD TO FIND
* THE VVR FOR THE OBJECT I AM LISTING (NB : THE FIRST VVR I FIND MAY
* NOT BE IT, IE. A DATA VVR IF I'M LISTING AN INDEX).
         SPACE 1                                                   -EU-
         USING VVR,R6
HEXVVR   $IN ,
         MVC   L2TYPE,=CL7' VVR'
HEXVVR0  CLI   2(R6),C'Q'          Q = SECONDARY VVR
         BE    HEXVVR0B            YES, IS IT THE RIGHT ONE?
         CLI   2(R6),C'Z'          Z = PRIMARY VVR
         BE    HEXVVR0B            YES, IS IT THE RIGHT ONE?
HEXVVR0A XR    R0,R0               NEXT CELL PLEASE.
         BAS   R9,FINDVVDS
         B     HEXVVR0             IS IT A VVR?
HEXVVR0B XR    R1,R1
         ICM   R1,1,VVRCMPNL       PICK UP NAME LENGTH.
         BCTR  R1,0
         BCTR  R1,0
         B     HEXVVR0C
         CLC   SVCOMPN(0),VVRCMPNM  (EXECUTED)
HEXVVR0C EX    R1,*-6              COMPARE VVR NAME TO BCS NAME.
         BNE   HEXVVR0A            NO, MUST BE A RELATED COMPONENT.
         HEX   L2WORK,VVRHDLEN,2,HEXTAB=TRHEX
         HEX   L2WORK+5,VVRTYPE,1,HEXTAB=TRHEX
         HEX   L2WORK+8,VVRFLAG,1,HEXTAB=TRHEX
         HEX   L2WORK+11,VVRKRQ,4,HEXTAB=TRHEX
         HEX   L2WORK+20,VVRCMPNL,1,HEXTAB=TRHEX
         XR    R1,R1
         ICM   R1,1,VVRCMPNL       GET LENGTH OF COMPONENT KEY.
         B     *+10
         MVC   L2WORK+23(0),VVRCMPNM
         EX    R1,*-6              MOVE IN COMPONENT KEY.
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         BAS   R9,PRINT            PRINT LINE.
         $OUT  ,                   GET OUT.
         DROP  R6
         EJECT ,                                                   -EU-
*        HEX A DATASET INFORMATION CELL.                           -EU-
         SPACE 1                                                   -EU-
HEXDSINF $IN ,
         ICM   R0,3,=XL2'FF21'     DATASET INFORMATION CELL.
         BAS   R9,FINDVVDS         LOOK FOR IT.
         LTR   R0,R0               WAS THERE ONE?
         BZ    HEXDSF99            NO.
         USING VVRDSINF,R6
         MVC   L2TYPE,=CL7' DSINFO'
         HEX   L2WORK,VVRDSLEN,2,HEXTAB=TRHEX     CELL LENGTH.
         HEX   L2WORK+5,VVRDSTYP,1,HEXTAB=TRHEX   TYPE CODE IS X'21'
         HEX   L2WORK+8,VVRATTR1,1,HEXTAB=TRHEX   DATASET ATTRIBUTES
         HEX   L2WORK+11,VVRATTR2,1,HEXTAB=TRHEX  DATASET ATTRIBUTES
         HEX   L2WORK+14,VVROPIND,1,HEXTAB=TRHEX  OPEN INDICATOR
         HEX   L2WORK+17,VVRBUFSZ,4,HEXTAB=TRHEX  MINIMUM BUFFER SIZE
         HEX   L2WORK+26,VVRPRISP,3,HEXTAB=TRHEX  PRIMARY SPACE ALLOC.
         HEX   L2WORK+33,VVRSECSP,3,HEXTAB=TRHEX  SECONDARY SPACE ALL.
         HEX   L2WORK+40,VVRSPCFG,1,HEXTAB=TRHEX  SPACE FLAGS
         HEX   L2WORK+43,VVRDSHU,4,HEXTAB=TRHEX   DATASET HIGH USED RBA
         HEX   L2WORK+52,VVRDSHA,                                      X
               4,HEXTAB=TRHEX      DATASET HIGH ALLOCATED RBA
         HEX   L2WORK+61,VVRLRECL,                                     X
               4,HEXTAB=TRHEX      AVERAGE LOGICAL RECORD LENGTH
         HEX   L2WORK+70,VVREXCPX,4,HEXTAB=TRHEX  EXCEPTION EXIT.
         HEX   L2WORK+78,VVREXCPX+4,4,HEXTAB=TRHEX     EXCEPTION EXIT.
         HEX   L2WORK+87,VVRDSHK,4,HEXTAB=TRHEX   DATASET HIGH KEY RBA.
         HEX   L2WORK+96,VVRCLSFG,                                     X
               1,HEXTAB=TRHEX      CLUSTER ATTRIBUTE FLAG
         HEX   L2WORK+99,VVRAIXFG,1,HEXTAB=TRHEX  AIX ATTRIBUTE FLAG
         HEX   L2WORK+102,VVRTMSTP,                                    X
               4,HEXTAB=TRHEX      TIMESTAMP (CATALOG ONLY).
         HEX   L2WORK+110,VVRTMSTP+4,                                  X
               4,HEXTAB=TRHEX      TIMESTAMP (CATALOG ONLY).
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         BAS   R9,PRINT            PRINT LINE.
HEXDSF99 $OUT  ,                   GET OUT
         EJECT ,                                                   -EU-
*        HEX AN AMDSB CELL.                                        -EU-
         SPACE 1                                                   -EU-
HEXAMDSB $IN ,
         ICM   R0,3,=XL2'FF60'     AMDSB CELL
         BAS   R9,FINDVVDS         LOOK FOR IT.
         LTR   R0,R0               WAS THERE ONE?
         BZ    HEXAMD99            NO.
         USING VVRAMDCL,R6
         MVC   L2TYPE,=CL7' AMDSB'
         HEX   L2WORK+00,VVRAMDCN,2,HEXTAB=TRHEX  LENGTH OF AMDSB CELL
         HEX   L2WORK+05,VVRAMID,1,HEXTAB=TRHEX   TYPE CODE IS X'60'
         HEX   L2WORK+08,VVRAMATR,1,HEXTAB=TRHEX  ATTRIBUTES:
         HEX   L2WORK+11,VVRAMLEN,2,HEXTAB=TRHEX  LENGTH OF AMDSB
         HEX   L2WORK+16,VVRAMNST,                                     X
               2,HEXTAB=TRHEX      NUMBER OF ENTRIES IN INDEX SECTION
         HEX   L2WORK+21,VVRAMRKP,2,HEXTAB=TRHEX  RKP
         HEX   L2WORK+26,VVRAMKNL,2,HEXTAB=TRHEX  KEY LENGTH
         HEX   L2WORK+31,VVRAMPCA,1,HEXTAB=TRHEX  % FREE CI IN CA
         HEX   L2WORK+34,VVRAMPCI,1,HEXTAB=TRHEX  % FREE BYTES IN CI
         HEX   L2WORK+37,VVRAMCCA,2,HEXTAB=TRHEX  CI'S PER CA
         HEX   L2WORK+42,VVRAMFCA,2,HEXTAB=TRHEX  FREE CI'S PER CA
         HEX   L2WORK+47,VVRAMFCI,4,HEXTAB=TRHEX  FREE BYTES PER CI
         HEX   L2WORK+56,VVRAMCIV,4,HEXTAB=TRHEX  CONTROL INTERVAL SIZE
         HEX   L2WORK+65,VVRAMLCL,4,HEXTAB=TRHEX  MAXIMUM RECORD SIZE
         HEX   L2WORK+74,VVRAMSLT,4,HEXTAB=TRHEX  SLOTS PER CI
         HEX   L2WORK+83,VVRAMMRR,                                     X
               4,HEXTAB=TRHEX      MAXIMUM RELATIVE RECORD NUMBER
         HEX   L2WORK+92,VVRAMARB,4,HEXTAB=TRHEX   POINTER TO 1ST ARDB
         HEX   L2WORK+101,VVRAMAT3,1,HEXTAB=TRHEX  ATTRIBUTES
         HEX   L2WORK+104,VVRAMSNO,                                    X
               1,HEXTAB=TRHEX      NUMBER OF CONCURRENT REQUESTS
         HEX   L2WORK+107,VVRAMBFD,2,HEXTAB=TRHEX  NO. OF DATA BUFFERS
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         BAS   R9,PRINT            PRINT LINE.
         HEX   L2WORK+00,VVRAMSTS,4,HEXTAB=TRHEX  SYSTEM TIMESTAMP
         HEX   L2WORK+08,VVRAMSTS+4,4,HEXTAB=TRHEX     SYSTEM TIMESTAMP
         HEX   L2WORK+17,VVRAMNIL,2,HEXTAB=TRHEX  NO. OF INDEX LEVELS
         HEX   L2WORK+22,VVRAMNXT,2,HEXTAB=TRHEX  NUMBER OF EXTENTS
         HEX   L2WORK+27,VVRAMNLR,4,HEXTAB=TRHEX  LOGICAL RECORDS NO.
         HEX   L2WORK+38,VVRAMDLR,4,HEXTAB=TRHEX  DELETED RECORDS NO.
         HEX   L2WORK+47,VVRAMINR,4,HEXTAB=TRHEX  INSERTED RECORDS NO.
         HEX   L2WORK+56,VVRAMUPR,4,HEXTAB=TRHEX  UPDATED RECORDS NO.
         HEX   L2WORK+65,VVRAMRTR,4,HEXTAB=TRHEX  RETRIEVED RECORDS NO.
         HEX   L2WORK+74,VVRAMASP,                                     X
               4,HEXTAB=TRHEX      BYTES OF FREE SPACE IN DATASET
         HEX   L2WORK+83,VVRAMCIS,4,HEXTAB=TRHEX  NUMBER OF CI SPLITS
         HEX   L2WORK+92,VVRAMCAS,4,HEXTAB=TRHEX  NUMBER OF CA SPLITS
         HEX   L2WORK+101,VVRAMEXC,4,HEXTAB=TRHEX NUMBER OF EXCPS
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         BAS   R9,PRINT            PRINT LINE.
HEXAMD99 $OUT  ,                   GET OUT
         EJECT ,                                                   -EU-
*        HEX A VOLUME INFORMATION CELL.                            -EU-
         SPACE 1                                                   -EU-
HEXVOLIN $IN ,
         ICM   R0,3,=XL2'FF23'     VOLUME INFORMATION CELL
         BAS   R9,FINDVVDS         LOOK FOR IT.
         LTR   R0,R0               WAS THERE ONE?
         BZ    HEXVLN99            NO.
         USING VVRVOLIN,R6
         MVC   L2TYPE,=CL7' VOLINF'
         HEX   L2WORK+00,VVRVOLLN,2,HEXTAB=TRHEX  LENGTH OF VOLUME CELL
         HEX   L2WORK+05,VVRVOLTP,1,HEXTAB=TRHEX  TYPE CODE IS X'23'
         HEX   L2WORK+08,VVRVOLFG,1,HEXTAB=TRHEX  VOLUME FLAGS
         HEX   L2WORK+11,VVRNOEXT,                                     X
               1,HEXTAB=TRHEX      NUMBER OF EXTENTS ON THIS VOLUME.
         HEX   L2WORK+14,VVRHKRBA,4,HEXTAB=TRHEX  HIGH KEY RBA
         HEX   L2WORK+23,VVRHURBA,4,HEXTAB=TRHEX  HIGH USED RBA
         HEX   L2WORK+32,VVRHARBA,4,HEXTAB=TRHEX  HIGH ALLOCATED RBA
         HEX   L2WORK+41,VVRBLKSZ,4,HEXTAB=TRHEX  BLOCK SIZE
         HEX   L2WORK+50,VVRBLKTK,                                     X
               2,HEXTAB=TRHEX      NUMBER OF BLOCKS PER TRACK
         HEX   L2WORK+55,VVRTRKAU,                                     X
               2,HEXTAB=TRHEX      NUMBER OF TRACKS PER ALLOCATION UNIT
         HEX   L2WORK+60,VVRTPEXT,1,HEXTAB=TRHEX  EXTENT TYPE FLAG
         HEX   L2WORK+63,VVRTKCYL,2,HEXTAB=TRHEX  TRACKS PER CYLINDER
         HEX   L2WORK+68,VVRBYTTK,4,HEXTAB=TRHEX  BYTES PER TRACK.
         HEX   L2WORK+77,VVRBYTAU,                                     X
               4,HEXTAB=TRHEX      BYTES PER ALLOCATION UNIT
         HEX   L2WORK+86,VVRLOKYL,2,HEXTAB=TRHEX  LOW KEY LENGTH
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         BAS   R9,PRINT            PRINT LINE.
         ST    R5,HEXR5            SAVE VVDSTAB BASE REG
         XR    R5,R5
         ICM   R5,1,VVRNOEXT       GET NUMBER OF EXTENTS
         LR    R8,R6
         LA    R8,40(0,R8)         POINT TO EXTENT DESCR.
         USING VVRXTENT,R8
HEXVLN97 HEX   L2WORK+00,VVRXSEQN,2,HEXTAB=TRHEX  SEQUENCE NUMBER
         HEX   L2WORK+05,VVRXSCH,4,HEXTAB=TRHEX   STARTING CCHH
         HEX   L2WORK+14,VVRXECH,4,HEXTAB=TRHEX   ENDING CCHH
         HEX   L2WORK+23,VVRXNTRK,2,HEXTAB=TRHEX  NUMBER OF TRACKS
         HEX   L2WORK+28,VVRXSRBA,4,HEXTAB=TRHEX  STARTING RBA
         HEX   L2WORK+37,VVRXERBA,4,HEXTAB=TRHEX  ENDING RBA
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         BAS   R9,PRINT            PRINT LINE.
         LA    R8,20(0,R8)         POINT TO NEXT EXTENT DESCR.
         BCT   R5,HEXVLN97         FORMAT ALL EXTENTS
         L     R5,HEXR5            RESTORE VVDSTAB BASE REG
HEXVLN99 $OUT  ,                   GET OUT
HEXR5    DC    F'0'                I'M RUNNING OUT OF REGISTERS
         DROP  R8
         EJECT ,                                                   -EU-
*        FINDBCS - ADVANCE R3 TO A SPECIFIED BCS CELL.             -EU-
         SPACE 1                                                   -EU-
* I ENTER HERE WITH R3 POINTING TO A CELL I HAVE JUST PROCESSED. THIS
* CODE EITHER MOVES AHEAD TO THE NEXT CELL BE IT WHATEVER OR SEARCHES
* FOR A PARTICULAR CELL TYPE.
* ON ENTRY THE NEXT-TO-RIGHT-MOST BYTE OF R0 CONTAINS X'FF' IF THE
* CELL TYPE THE CALLER WANTS IS OPTIONAL (IT'S EITHER THE NEXT ONE OR
* IT'S NOT THERE AT ALL) OR X'00' IF THE DESIRED CELL TYPE IS REQUIRED
* BUT MAY NOT BE THE NEXT ONE.
* THE RIGHT-MOST BYTE OF R0 CONTAINS THE ID OF THE CELL TYPE THE
* CALLER WANTS.
* IF R0 IS ALL ZEROS THE CALLER JUST WANTS THE NEXT CELL.
* IF THE REQUESTED CELL TYPE WAS FOUND R0 IS CLEARED.
         SPACE 1                                                   -EU-
FINDBCS  $IN ,
         ST    R3,BCS2             SAVE CELL ADDRESS.
FINDBCS1 XR    R1,R1               CLEAR REGISTER
         ICM   R1,3,0(R3)          PICK UP LENGTH OF CURRENT CELL.
         AR    R3,R1               AND SKIP OVER IT.
         C     R3,ENDBCS           ANY MORE CELLS IN THIS RECORD?
         BL    FINDBCS2            YES.
         ST    R0,BCS0             SAVE CALLERS PARMS
         L     R1,RPLICAT          GET RPL ADDR.
         GET   RPL=(1)
         AP    BCSGETS,ONE         COUNT OFF A GET.
         L     R0,BCS0             RESTORE CALLERS PARMS
         LTR   R15,R15             RECORD READ OK?
         L     R3,BUFPTR           ADDRESS OF RECORD JUST READ.
         L     R1,RPLICAT          GET RPL ADDR.
         L     R1,48(0,R1)         RECORD LENGTH.
         AR    R1,R3               END OF RECORD.
         ST    R1,ENDBCS           SAVE FOR NEXT TIME.
         LA    R3,2(0,R3)          SKIP OVER PREFIX.
FINDBCS2 CLM   R0,1,2(R3)          CHECK FOR REQUESTED CELL TYPE
         BE    FINDBCS9            YES.
         CLM   R0,2,=XL1'FF'       IS THIS CELL TYPE OPTIONAL?
         BNE   FINDBCS1            NO, SO KEEP LOOKING.
         L     R3,BCS2             BACKUP TO WHERE WE STARTED.
         XR    R0,R0               LET HIM KNOW ABOUT IT.
FINDBCS9 $OUT  ,
ENDBCS   DC    F'0'                BCS RECORD END ADDRESS
BCS2     DC    F'0'                SAVE R3 IN HERE.
BCS0     DC    F'0'                SAVE R0 IN HERE.
         EJECT ,                                                   -EU-
*        FINDVVDS - ADVANCE R6 TO A SPECIFIED VVDS CELL.           -EU-
         SPACE 1                                                   -EU-
* I ENTER HERE WITH R6 POINTING TO A CELL I HAVE JUST PROCESSED. THIS
* CODE EITHER MOVES AHEAD TO THE NEXT CELL BE IT WHATEVER OR SEARCHES
* FOR A PARTICULAR CELL TYPE.
* ON ENTRY THE NEXT-TO-RIGHT-MOST BYTE OF R0 CONTAINS X'FF' IF THE
* CELL TYPE THE CALLER WANTS IS OPTIONAL (IT'S EITHER THE NEXT ONE OR
* IT'S NOT THERE AT ALL) OR X'00' IF THE DESIRED CELL TYPE IS REQUIRED
* BUT MAY NOT BE THE NEXT ONE.
* THE RIGHT-MOST BYTE OF R0 CONTAINS THE ID OF THE CELL TYPE THE
* CALLER WANTS.
* IF R0 IS ALL ZEROS THE CALLER JUST WANTS THE NEXT CELL.
* IF THE REQUESTED CELL TYPE WAS FOUND R0 IS CLEARED.
         SPACE 1                                                   -EU-
FINDVVDS $IN ,
         ST    R6,VVD6             SAVE CELL ADDRESS
FINDVVD1 XR    R1,R1               CLEAR REGISTER
         XR    R15,R15             CLEAR PREVIOUS RETCODE.         @122
         ICM   R1,3,0(R6)          PICK UP LENGTH OF CURRENT CELL.
         AR    R6,R1               AND SKIP OVER IT.
         C     R6,ENDVVD           ANY MORE CELLS IN THIS RECORD?
         BL    FINDVVD2            YES.
         ICM   R8,15,VVDSRPL       PICK UP RPL ADDRESS
         ST    R0,VVD0             SAVE CALLERS PARM
         GET   RPL=(R8)
         LTR   R15,R15             GET OK?                         @122
         BZ    FINDVVD3            YUP.                            @122
         C     R15,=F'8'           LOGICAL ERROR?                  @122
         BE    FINDVVD4            YES.                            @122
         ABEND 16,DUMP             OTHERWISE CRASH AND BURN.       @122
FINDVVD4 XR    R2,R2                                               @122
         ICM   R2,1,RPLERRCD-IFGRPL(R1) GET REASON CODE.           @122
         CVD   R2,DTWORK           PACK IT.                        @122
         EDIT  FDBK,DWK3,ZZZ9      FORMAT NICELY.                  @122
        $MESSAGE 2,DATA=FDBK       SAY LOGICAL ERROR.              @122
         LA    R15,8                                               @122
         B     FINDVVD9            GO BACK WITH RC IN R15          @122
FINDVVD3 AP    VVDSGETS,ONE        COUNT IT.                       @122
         L     R0,VVD0             RESTORE CALLERS PARM
         L     R6,VVDSBUF          ADDRESS OF RECORD JUST READ.
         L     R1,VVDSRPL          ADDR OF RPL
         L     R1,48(0,R1)         LENGTH OF RECORD JUST READ.
         AR    R1,R6               END OF RECORD.
         ST    R1,ENDVVD           SAVE FOR NEXT TIME.
         LA    R6,2(0,R6)          SKIP OVER PREFIX.
FINDVVD2 LTR   R0,R0               IF ZERO, ANYTHING WILL DO.
         BZ    FINDVVD9
         CLM   R0,1,2(R6)          CHECK FOR REQUESTED CELL TYPE
         BE    FINDVVD9            YES.
         CLM   R0,2,=XL1'FF'       IS THIS CELL TYPE OPTIONAL?
         BNE   FINDVVD1            NO, THEN KEEP LOOKING.
         L     R6,VVD6             RESTORE INITIAL CELL ADDRESS
         XR    R0,R0               GIVE HIM THE SAD NEWS.
FINDVVD9 $OUT  ,
ENDVVD   DC    F'0'                BCS RECORD END ADDRESS
VVD6     DC    F'0'                SAVE R6 IN HERE.
VVD0     DC    F'0'                SAVE R0 IN HERE.
         DROP  R5
         EJECT ,                                                   -EU-
*        PRINT LINE SUBROUTINE.                                    -EU-
         SPACE 1                                                   -EU-
PRINT    $IN ,
         ST    R1,PRINT1
         XPRNTLIN  PWA,TEXT=(R1),LENGTH=132,SPB=((R0)),SPA=1
         L     R1,PRINT1
         MVI   0(R1),C' '
         MVC   1(132,R1),0(R1)
         $OUT  ,
PRINT1   DC    F'0'
         EJECT ,                                                   -EU-
*        DEFINE REPORT HEADING.                                    -EU-
         SPACE 1                                                   -EU-
SETHEAD  $IN ,
         XPRHEAD PWA,LIST=(HEADER1,HEADER2)
         $OUT
         EJECT ,                                                   -EU-
*        FORMAT THE CREATION DATE FROM AN OWNER CELL.              -EU-
         SPACE 1                                                   -EU-
SETCREDT $IN ,
         ICM   R0,1,=XL1'01'       OWNER CELL TO BE FOUND.
         BAS   R9,FINDBCS          SO GO LOOK FOR IT.
         USING OWNERC,R3
         XR    R0,R0               CLEAR R0.
         ICM   R0,7,OWNCREDT       PICK UP CREATION DATE.
         XC    DTWORK,DTWORK       CLEAR DOUBLE WORD
         ST    R0,DTWORK+4         STORE FOR DATE CONVERSION
         LA    R1,DTWORK           SETUP ADDRESS
         ST    R1,DTPARM           OF PACKED FIELD
         LA    R1,DTPARM           IN PARMLIST
         L     R15,=V(XDATEDIT)    ADDRESS OF DATE CONVERT ROUTINE
         BASR  R14,R15             CONVERT DATE
         MVC   L1CREDT,DTWORK      SETUP CONVERTED DATE
         $OUT
         EJECT ,                                                   -EU-
*        SETUP FIELDS FROM THE HSM MCD RECORD.                     -EU-
         SPACE 1                                                   -EU-
CHKHSM   CLI   MCDSOPEN,254        PREVIOUS OPEN FAILED?           @122
         BER   R9                  YES. GIVE UP HOPE.              @122
         CLI   MCDSOPEN,0          IS MCDS ALREADY OPEN?
         BNE   CHKHSM1A
         OPEN  (ACBMCDS)
         LTR   R15,R15             DID IT OPEN.                    @122
         BZ    CHKHSM1B            YES                             @122
        $MESSAGE 6                 NO. SAY SO.                     @122
         MVI   MCDSOPEN,254        FLAG NO SYSUT2.                 @122
         BR    R9                  AND GO HOME.                    @122
CHKHSM1B MVI   MCDSOPEN,255        FLAG IT OPEN                    @122
CHKHSM1A MVC   MCDSKEY,L1DSNAME    DSN AS MCDS KEY.
         GET   RPL=RPLMCDS
         LTR   R15,R15             RECORD READ OK?
         BNZR  R9                  RETURN
         L     R1,MCDSPTR          GET ADDRESS OF HSM MCD RECORD.
         USING MCD,R1
         CLC   MCDSIZE,=F'32760'   DATA AND INDEX ENTRIES NO GOOD.
         BH    CHKHSM2             SO LEAVE THEM AT ZERO
         MVC   TRACKS,MCDSIZE      ORIGINAL SIZE IN TRACKS.
CHKHSM2  MVC   BLKSIZE+2(2),MCDBLKSZ  ORIGINAL BLOCK SIZE.
         DROP  R1
         BR    R9                  EXIT
         EJECT ,                                                   -EU-
*        PRINT OUT STATISTICS AT EOD.                              -EU-
         SPACE 1                                                   -EU-
COUNTS   $IN ,
         XPREJECT  PWA
         XPRHEAD PWA,LIST=(HEADER1)
         EDIT  T1COUNT,CNTNVSAM,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1NVSAM),T1NVSAM
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=2,SPA=1
         EDIT  T1COUNT,CNTCLUST,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1CLUST),T1CLUST
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1
         EDIT  T1COUNT,CNTINDEX,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1INDEX),T1INDEX
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1
         EDIT  T1COUNT,CNTDATA,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1DATA),T1DATA
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1
         EDIT  T1COUNT,CNTAIX,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1AIX),T1AIX
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1
         EDIT  T1COUNT,CNTPATH,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1PATH),T1PATH
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1
         EDIT  T1COUNT,CNTGDGB,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1GDGB),T1GDGB
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1
         EDIT  T1COUNT,CNTGDGE,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1GDGE),T1GDGE
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1
         EDIT  T1COUNT,BCSGETS,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1BCS),T1BCS
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1
         EDIT  T1COUNT,VVDSGETS,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1VVDS),T1VVDS
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1
         EDIT  T1COUNT,CNTNF,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1NF),T1NF
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1
         EDIT  T1COUNT,CNTNOENT,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1NOENT),T1NOENT
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1
         $OUT
         EJECT ,                                                   -EU-
*        GENERATE AN RPL TO ACCESS THE BCS CLUSTER.                -EU-
         SPACE 1                                                   -EU-
GENRPL   $IN ,                                                     @120
         L     R0,BUFLEN           LENGTH TO GETMAIN
         GETMAIN R,LV=(0)          INPUT BUFFER FOR BCS RECORDS.
         ST    R1,BUFPTR           SAVE ADDRESS OF RECORD BUFFER.
         GENCB BLK=RPL,ACB=(S,ACBICAT),AM=VSAM,AREA=(*,BUFPTR),        X
               AREALEN=131072,OPTCD=(KEY,SEQ,MVE)
         ST    R1,RPLICAT          SAVE GENERATED RPL ADDR.
         $OUT                                                      @120
         EJECT ,                                                   -EU-
*        OPEN THE REQUESTED ICF CATALOG (SYSUT1).                  -EU-
         SPACE 1                                                   -EU-
OPICAT   $IN   ,                                                   -EU-
         L     R2,CVTPTR           A(CVT)
         L     R2,0(0,R2)          TCB WORDS
         L     R5,0(0,R2)          MY TCB.                         -EU-
         USING TCB,R5                                              -EU-
         L     R2,TCBJSCB          TCB -> JSCB.
         USING IEZJSCB,R2
         L     R2,JSCBACT          ACTIVE JSCB.
        SETAUTH ,                                                  -EU-
**-EU-   LA    R0,1                INDICATE AUTHORIZATION ON.
**-EU-   SVC   232                 ***** INSTALLATION DEPENDANT *******
         MODESET KEY=ZERO          JSCB IS IN KEY ZERO.
         SPACE 1
* OPENING A CATALOG AS A DATASET SEEMS TO CAUSE PASSWORD PROMPTING
* EVEN FOR READING. HERE I SET THE BYPASS PASSWORD BIT TO GIVE OPER
* A BREAK.
         SPACE 1
         OI    JSCBSWT1,JSCBPASS   SAY, NO PASSWORDS PLEASE.
         MODESET KEY=NZERO         BACK TO USER KEY.
         OPEN  ACBICAT             OPEN THE BCS CLUSTER.
         LR    R3,R15              SAVE OPEN R.C.                  -EU-
         MODESET KEY=ZERO          KEY ZERO TO MODIFY JSCB.        -EU-
         NI    JSCBSWT1,255-JSCBPASS  BYPASS PASSWORD OFF.
         MODESET KEY=NZERO         BACK TO USER KEY.
         DROP  R2
        RESAUTH ,                                                  -EU-
**-EU-   XR    R0,R0               INDICATE AUTHORIZATION OFF.
**-EU-   SVC   232                 ***** INSTALLATION DEPENDANT *******
         LTR   R3,R3               DID IT OPEN?                    -EU-
         BZ    OPENOK              YES.
         SHOWCB  ACB=ACBICAT,AREA=OPENERR,LENGTH=4,                    X
               FIELDS=(ERROR)      STORE OPEN ERROR CODE.
         L     R2,OPENERR          PICK ERROR CODE.                -EU-
         ABEND 14,DUMP             AND DIE.
OPENOK   LA    R2,ACBICAT                                          -EU-
         USING IFGACB,R2                                           -EU-
         TM    ACBINFL2,ACBCATX    CATX OPEN?                      -EU-
         BO    OPICAT1             YES, OK                         -EU-
         ABEND 17,DUMP             NO, DIE                         -EU-
OPICAT1  L     R1,TCBTIO           A(TIOT)                         -EU-
         DROP  R5                                                  -EU-
         AH    R1,ACBTIOT          + OFFSET -> DD ENTRY            -EU-
         DROP  R2                                                  -EU-
         XR    R2,R2                                               -EU-
         ICM   R2,B'0111',12(R1)   -> JFCB - SWA BLOCK             -EU-
         MVC   CATNAME(44),ZB502L(R2)   SET CATALOG NAME IN HEADING-EU-
         $OUT  ,                                                   -EU-
         EJECT ,                                                   -EU-
*        LITERAL POOL.                                             -EU-
         SPACE 1                                                   -EU-
         LTORG ,
         SPACE 2
         COPY  LISTICDS                                      @120  -EU-
         SPACE 2                                                   -EU-
         COPY  LISTICDA                                      @120  -EU-
         SPACE 2                                                   -EU-
         PRINT NOGEN                                               -EU-
         COPY  LISTICPR                                      @120  -EU-
         SPACE 2                                                   -EU-
         PRINT NOGEN                                               -EU-
         COPY  LISTICMS                                      @122  -EU-
         SPACE 2                                                   -EU-
         END   LISTICAT
