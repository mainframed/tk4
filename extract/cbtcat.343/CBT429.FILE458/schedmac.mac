         MACRO
&NME     #DIE  &O,&A,&B,&C,&TYPE=MSG
.*
.*
.*
.* LAST CHANGE DATE - OCTOBER 18, 1983
.*                  - MAILING ADDRESS CHANGE
.*
.* LAST CHANGE DATE - MARCH 16, 1983
.*                  - COMMENTARY ADJUSTMENTS
.*                  - MAILING ADDRESS CHANGE
.*
.* LAST CHANGE DATE - APRIL 21, 1981
.*                  - MACRO NAME CHANGED FROM $DIE TO #DIE.
.*
.* LAST CHANGE DATE - JAUNARY 27, 1981
.*                  - THE MACRO HAS BEEN REWRITTEN TO
.*                    GENERATE INLINE TRAPS WHENEVER
.*                    EXTENDED MNEMONICS FOR THE 'BC' AND
.*                    'BCR' INSTRUCTIONS ARE USED. THIS IS
.*                    ACCOMPLISHED BY USING THE INVERSE OF
.*                    OF THE GIVEN BRANCH CONDITION TO
.*                    SKIP AROUND THE INLINE TRAP.
.*                    IN THOSE CASES WHERE AN INLINE TRAP
.*                    IS NOT DESIRED (SUCH AS WITHIN A
.*                    BRANCH VECTOR TABLE), THE
.*                    NON-EXTENDED FORM OF THE 'BC'
.*                    INSTRUCTION CAN BE USED; E.G.:
.*                         #DIE C,8   INSTEAD OF   #DIE Z
.*                  - A UNIQUE NUMBER IS NOW APPENDED TO
.*                    GIVEN MESSAGES.
.*
.* LAST CHANGE DATE - FEBRUARY 12, 1980
.*                  - TYPE=CMD SUPPORT HAS BEEN ADDED. THIS
.*                    PROVIDES A MEANS OF COMMUNICATING
.*                    COMMANDS TO THE "DEBUGGING CONTROLLER"
.*                    PROGRAM.
.*                  - IF NO BRANCH CONDITIONALS ARE GIVEN,
.*                    THEN THE "DEAD" CODE IS NOW GENERATED
.*                    INLINE. BEFORE, AN UNCONDITIONAL BRANCH
.*                    TO A "DEAD" LITTERAL WAS MADE.
.*
.* LAST CHANGE DATE - APRIL 24, 1978
.*                  - THE MACRO HAS BEEN REWRITTED TO
.*                    GENERATE MESSAGE STRINGS (INSTEAD OF
.*                    JUST A SEQUENCE NUMBER) AT THE BRANCH
.*                    ADDRESS. SUCH MESSAGES COULD BE
.*                    REASONABLY DISPLAYED VIA AN ESTAE
.*                    ROUTINE.
.*
.* LAST CHANGE DATE - DECEMBER 16, 1977
.*                  - 2ND AND 3RD OPERANDS HAVE BEEN ADDED TO
.*                    THE MACRO PROTOTYPE SO AS TO SUPPORT
.*                    THE GENERATION OF BRANCH INSTRUCTIONS
.*                    OTHER THAN JUST CONDITIONAL-BRANCH.
.*                  - WHEN NO OPERANDS ARE GIVEN, AN
.*                    UNCONDITIONAL BRANCH IS NOW GENERATED.
.*
.* LAST CHANGE DATE - FEBRUARY 2, 1977
.*                  - MAILING ADDRESS CHANGE
.*
.* LAST CHANGE DATE - SEPTEMBER 10, 1976
.*
.* THIS MACRO WAS WRITTEN BY DAVID B. COLE.  ANY QUESTIONS
.* CONCERNING IT MAY BE ADDRESSED TO:
.*       RR#2 BOX 712
.*       AFTON, VA. 22920
.*
.*
.*
         GBLA  &#DIECOD
         GBLC  &#EBCDIC(256)
         LCLA  &L,&M
         LCLC  &MSG,&LAB,&OP,&N,&#
         AIF   ('&TYPE' EQ 'MSG' OR '&TYPE' EQ 'CMD').TYPEOK
         MNOTE 8,'TYPE=&TYPE NOT RECOGNIZED. TYPE=CMD ASSUMED.'
.TYPEOK  ANOP
&N       SETC  '&NME'
&#DIECOD SETA  &#DIECOD+1
&#       SETC  '000&#DIECOD'
&#       SETC  '&#'(K'&#-3,4)
&M       SETA  N'&SYSLIST+1
.MLP     ANOP
&M       SETA  &M-1
         AIF   (&M EQ 0).NOMSG
         AIF   (K'&SYSLIST(&M) EQ 0).MLP
         AIF   ('&SYSLIST(&M)' EQ '''''').NOMSG
&L       SETA  K'&SYSLIST(&M)-2
         AIF   (&L LE 0).NOMSG2
         AIF   ('&SYSLIST(&M)'(1,1) NE '''').NOMSG2
&MSG     SETC  '&SYSLIST(&M)'(2,&L)
         AIF   ('&TYPE' NE 'MSG').MSGDONE
&MSG     SETC  '&#DIECOD &MSG'
&L       SETA  &L+1+K'&#DIECOD
         AGO   .COMN
.*
.NOMSG2  ANOP
&M       SETA  &M+1
.NOMSG   AIF   ('&TYPE' NE 'MSG').MSGDONE
&MSG     SETC  '&#DIECOD'
&L       SETA  K'&MSG
.*
.COMN    AIF   (&L/2*2 EQ &L).MSGDONE
&L       SETA  &L+1
&MSG     SETC  '&MSG '
.MSGDONE ANOP
.*
         AIF   (&M LE 1 OR '&O' EQ '').INLINE
         AIF   (&M EQ 2).INVERT
         AIF   (&M NE 3).GENLIT
         AIF   ('&O'(K'&O,1) NE 'R').GENLIT
.*
.INVERT  ANOP
&OP      SETC  'BN&O'
         AIF   ('&O'(1,1) NE 'N').NVRTDON
&OP      SETC  'B'.'&O'(2,K'&O-1)
.NVRTDON ANOP
.*
         AIF   (&M EQ 2).SETLAB
&N       &OP   &A                  BRANCH IF OK
&N       SETC  ''
         AGO   .INLINE
.SETLAB  ANOP
&LAB     SETC  'DIE&#.Z'
&N       &OP   &LAB                SKIP IF OK
&N       SETC  ''
.INLINE  ANOP
&N       DC    X'00DEAD'           TRAP CODE
         AIF   ('&TYPE' EQ 'MSG').INLMSG
         DC    X'0100'             DBC COMMAND SIGNAL
         DC    C'&MSG'
         DC    X'00'               DBC COMMAND TERMINATOR
         AGO   .TRAIL
.INLMSG  DC    AL1(&L)             MESSAGE LENGTH
         DC    C'&MSG'
.TRAIL   AIF   ('&LAB' EQ '').MEND
&LAB     DS    0H                  RECEIVE SKIP AROUND TRAP
         AGO   .MEND
.*
.GENLIT  AIF   ('&TYPE' EQ 'MSG').LITMSG
&MSG     SETC  '
         AGO   .GOTLIT
.LITMSG  #TEST GEN=EBCDIC
&MSG     SETC  '
.GOTLIT  ANOP
.*
         AIF   (&M NE 3).OP4
&N       B&O   &A,=C'&MSG'
         AGO   .MEND
.OP4     ANOP
&N       B&O   &A,&B,=C'&MSG'
.MEND    MEND
         MACRO
&NME     #DSA  &D
.*
.*
.*
.* LAST CHANGE DATE - OCTOBER 18, 1983
.*                  - MAILING ADDRESS CHANGE
.*
.* LAST CHANGE DATE - APRIL 21, 1981
.*                  - MACRO NAME CHANGED FROM $DSA TO #DSA.
.*
.* LAST CHANGE DATE - FEBRUARY 2, 1977
.*                  - MAILING ADDRESS CHANGE
.*
.* LAST CHANGE DATE - JANUARY 27, 1976
.*
.* THIS MACRO WAS WRITTEN BY DAVID B. COLE.  ANY QUESTIONS CONCERNING
.* IT MAY BE ADDRESSED TO:
.*       RR#2 BOX 712
.*       AFTON, VA. 22920
.*
.*
.*
.*   THIS MACRO GENERATES A DSECT FOR A STANDARD REGISTER SAVE AREA.
.* FREQUENTLY, A REENTRANT PROGRAM NEEDS TO GETMAIN A "DATA STORAGE
.* AREA" AND USE THE BEGINNING OF IT AS A REGISTER SAVE AREA. IN THIS
.* SITUATION, THIS MACRO CAN BE USED TO MAP THE BEGINNING OF THE DSA.
.* THE REMAINDER OF THE DSA, OF COURSE, WOULD HAVE TO BE MAPPED
.* MANUALLY.
.*
.*   IF THE NAME FIELD ON THE MACRO CALLING STATEMENT IS OMITTED, THEN
.* THE GENERATED DSECT IS NAMED "DSA" AND ALL GENERATED FIELD NAMES ARE
.* PREFIXED WITH "DSA". IF THE NAME FIELD IS USED, THEN IT INSTEAD OF
.* "DSA" IS USED IN THE ABOVE MANNER.
.*
.*   INNER MACROS USED - NONE
.*
.*
.*
         LCLA  &A1
         LCLC  &N
&N       SETC  'DSA'
         AIF   (K'&NME EQ 0).GOTNME
&N       SETC  '&NME'
.GOTNME  ANOP
&N       DSECT  ,                  STANDARD REGISTER SAVE AREA
&N.WD1   DS    A -                 WORD-1 (USED BY PL/1)
&N.HSA   DS    A -                 HIGHER SAVE AREA POINTER
&N.LSA   DS    A -                 LOWER SAVE AREA POINTER
&N.R14   DS    A -                 REGISTER SAVE AREA (RETURN ADDRESS)
&N.R15   DS    A -                 REGISTER SAVE AREA (ENTRY POINT)
&A1      SETA  0-1
.LP      AIF   (&A1 EQ 12).END
&A1      SETA  &A1+1
&N.R&A1  DS    A -                 REGISTER SAVE AREA
         AGO   .LP
.END     MEND
         MACRO
&N       #ENTER &NME,&ESDTYPE=DEFAULT,&BASES=1,&SAVTYPE=LOCAL,&PFIX=
.*
.*
.*
.* LAST CHANGE DATE - OCTOBER 18, 1983
.*                  - MAILING ADDRESS CHANGE
.*
.* LAST CHANGE DATE - APRIL 27, 1983
.*                  - MAILING ADDRESS CHANGE.
.*                  - USE OF IBM'S "SAVE" MACRO HAS BEEN
.*                    REPLACED BY LOCAL CODE.
.*                  - THE ASSEMBLY DATE AND TIME ARE NOW
.*                    INCLUDED IN THE MODULE IDENTIFIER
.*                    TEXT.
.*
.* LAST CHANGE DATE - APRIL 21, 1981
.*                  - MACRO NAME CHANGED FROM $ENTER TO #ENTER.
.*
.* LAST CHANGE DATE - APRIL 15, 1981
.*                  - ADDED ENTRY LINKAGE FOR A PLI ENVIRONMENT.
.*                  - ADDED "#REGS GEN=NO" SUPPORT.
.*
.* LAST CHANGE DATE - JULY 18, 1980
.*                  - BUG FIXED: THE PRECEEDING MODIFICATION INTRODUCED
.*                    AN ERROR WHICH UNDER CERTAIN CIRCUMSTANCES
.*                    GENERATED ASSEMBLY ERRORS.
.*
.* LAST CHANGE DATE - JULY 10, 1980
.*                  - FOR GETMAINED REENTRANT SAVE AREAS, CODE HAS BEEN
.*                    ADDED TO CLEAR THE ENTIRE GETMAINED AREA TO ZEROS
.*                    BEFORE SETING THE CHAIN FIELD.
.*                  - INDIRECT ADDRESSING TO A REMOTE SAVE AREA IS NOW
.*                    SIGNALLED BY A TRAILING PERCENT SIGN RATHER THAN
.*                    A LEADING PERCENT SIGN.
.*
.* LAST CHANGE DATE - OCTOBER 3, 1979
.*                  - CODE HAS BEEN ALTERED SO THAT ADDRESSABILITY TO
.*                    A REMOTE SAVE AREA DOES NOT HAVE TO BE BASED ON
.*                    R15 (I.E., ON THE ENTRY ADDRESS).
.*
.* LAST CHANGE DATE - OCTOBER 3, 1978
.*                  - THE GETMAIN FOR THE RENTRANT SAVE AREA HAS BEEN
.*                    CHANGED SO THAT MORE THAN 4K BYTES CAN BE GOTTEN.
.*
.* LAST CHANGE DATE - FEBRUARY 28, 1978
.*                  - BUG FIXED IN REMOTE SAVE AREA HANDLING
.*
.* LAST CHANGE DATE - JANUARY 29, 1978
.*                  - IN MOST CASES IT IS LOGICALLY INCONSISTANT TO
.*                    CODE 'BASES=*' WHEN ONE OF THE OLD BASES IS R13.
.*                    THIS PROBLEM IS NOW RECOGNIZED AND FLAGGED.
.*
.*                  - A REMOTE SAVE AREA'S NAME CAN NOW BE GIVEN EITHER
.*                    WITH OR WITHOUT A PRECEEDING PERCENT (%) SIGN TO
.*                    INDICATE WHETHER THE NAMED ADDRESS MUST BE
.*                    REACHED BY INDIRECT ADDRESSING.
.*
.* LAST CHANGE DATE - NOVEMBER 4, 1977
.*                  - SUPPORT IS ADDED FOR DEFINING A LOCAL SAVE AREA
.*                    WHOSE LENGTH IS OTHER THAN 72 BYTES.
.*
.* LAST CHANGE DATE - JANUARY 13, 1977
.*                  - THE MF= AND SVID= OPERANDS ARE REPLACED BY THE
.*                    SAVTYPE= OPERAND.
.*                  - SUPPORT FOR THE HANDLING OF A REMOTELY ASSEMBLED
.*                    SAVE AREA.
.*                  - MAILING ADDRESS CHANGE.
.*
.* LAST CHANGE DATE - SEPTEMBER 14, 1976
.*                  - IMPLEMENT SUPPORT FOR "BASES=*" WHICH IMPLIES
.*                    THAT BOTH THE BASE ADDRESS AND BASE REGISTERS
.*                    DEFINED BY THE PHYSICALLY PREVIOUS USE OF THE
.*                    #ENTER MACRO ARE TO BE REUSED.
.*
.* LAST CHANGE DATE - AUGUST 23, 1976
.*
.* THIS MACRO WAS WRITTEN BY DAVID B. COLE.  ANY QUESTIONS CONCERNING
.* IT MAY BE ADDRESSED TO:
.*       RR#2 BOX 712
.*       AFTON, VA. 22920
.*
.*
.*
.*   THIS MACRO GENERATES OS STANDARD ENTRY LINKAGE. IT WAS WRITTEN TO
.* PROVIDE A SIMPLE, FLEXIBLE, AND COMPLETE METHOD OF GENERATING SUCH
.* LINKAGE. IN ADDITION, FOR ALMOST ALL OPERAND COMBINATIONS, #ENTER
.* WILL GENERATE THE ABSOLUTE MINIMUM AMOUNT OF CODE NECESSARY.
.*
.*   THE #ENTER MACRO WILL GENERATE THE FOLLOWING:
.*     - A CSECT OR ENTRY CARD (IF DESIRED)
.*     - A MODULE IDENTIFIER WHICH WILL INCLUDE THE ASSEMBLY
.*       DATE AND TIME.
.*     - CODE TO SAVE ALL REGISTERS IN THE HIGHER SAVE AREA
.*     - CODE TO LOAD R13 WITH A POINTER TO A LOWER SAVE AREA
.*     - CODE TO CROSS LINK THE LOWER SAVE AREA WITH THE HIGHER SAVE
.*       AREA
.*     - CODE TO LOAD ANY SET OF BASE REGISTERS
.*     - A USING STATEMENT DECLARING THE SET OF BASE REGISTERS
.*     - EITHER THE LOWER SAVE AREA ITSELF OR CODE TO GETMAIN A
.*       REENTRANT SAVE AREA OF 72 OR MORE BYTES OR CODE TO LOAD THE
.*       ADDRESS OF AN ASSEMBLED SAVE AREA THAT IS REMOTE FROM THE
.*       MACRO EXPANSION.
.*     - FOR A GETMAINED REENTRANT SAVE AREA, CODE TO CLEAR THE AREA TO
.*       ZEROS.
.*
.* &N
.*       THIS IS THE ONLY FIELD REQUIRED FOR THE MACRO CALL. IT MUST
.*       SPECIFY THE DESIRED CONTROL SECTION OR ENTRY NAME.
.*
.* &NME
.*       USE THIS FIELD TO SPECIFY OPTIONAL TEXT TO BE
.*       INCLUDED INTO THE MODULE IDENTIFIER. ENCLOSING
.*       QUOTES ARE OPTIONAL.
.*
.* &ESDTYPE=
.*       THIS OPERAND CONTROLS THE TYPE OF EXTERNAL SYMBOL (IF ANY) TO
.*       BE GENERATED USING &N. VALID VALUES FOR THIS OPERAND IMPLY THE
.*       FOLLOWING:
.*              -OMITTED-    ==> ESDTYPE=ENTRY IF SAVTYPE=PLI
.*              -OMITTED-    ==> ESDTYPE=CSECT OTHERWISE
.*             ESDTYPE=CSECT ==>
.*                     &N       CSECT
.*             ESDTYPE=START ==>
.*                     &N       START
.*             ESDTYPE=ENTRY ==>
.*                              ENTRY &N
.*                     &N       DS    0H
.*             ESDTYPE=     <==>
.*             ESDTYPE=NONE  ==>
.*                     &N       DS    0H
.*
.* &BASES=
.*       USE THIS OPERAND TO SPECIFY EITHER HOW MANY OR EXACTLY WHICH
.*       BASE REGISTERS TO DECLARE AND LOAD. VALID VALUES FOR THIS
.*       OPERAND ARE:
.*             BASES= -A SINGLE SELF DEFINING NUMERIC-
.*                   THIS REQUESTS THAT A SPECIFIC NUMBER OF BASES BE
.*                   LOADED AND DECLARED. THE MACRO IS ALLOWED TO
.*                   DETERMINE FOR ITSELF PRECISELY WHICH REGISERS TO
.*                   DECLARE AS FOLLOWS. FOR SAVTYPE=LOCAL (SEE BELOW)
.*                   THE FIRST BASE REGISTER WILL BE R13; OTHERWISE
.*                   (I.E. FOR SAVTYPE=RENT OR SAVTYPE=REMOTE), THE
.*                   FIRST BASE REGISTER WILL BE R12. IN EITHER CASE,
.*                   ADDITIONAL BASES WILL BE SUCCESSIVELY LOWER
.*                   NUMBERED REGISTERS. EXAMPLES:
.*                   BASES=3,SAVTYPE=RENT  ==> R12, R11, AND R10.
.*                   BASES=2,SAVTYPE=LOCAL ==> R13, AND R12.
.*             BASES= -A SUBLIST OF ONE OR MORE REGISTER NAMES-
.*                   THE LISTED REGISTERS ARE LOADED AND DECLARED AS
.*                   BASES. THE LEFTMOST LISTED REGISTER IS LOADED WITH
.*                   THE LOWEST ADDRESS. EXAMPLE:
.*                   BASES=(R5,6,4) ==> R5, R6, AND R4 IN THAT ORDER.
.*             BASES=*
.*                   THE BASE ADDRESS AND BASE REGISTERS DEFINED BY THE
.*                   PHYSICALLY PREVIOUS #ENTER MACRO ARE REUSED.
.*          THE BASES= OPERAND MAY BE NULLIFIED BY SPECIFYING EITHER:
.*             BASES=
.*             BASES=0
.*       IN THIS CASE, NO BASE REGISTERS ARE LOADED OR DECLARED.
.*          IF THE BASES= OPERAND IS OMITTED, THEN A DEFAULT OF BASES=1
.*       WILL BE USED.
.*
.* &SAVTYPE=
.*       THIS OPERAND IDENTIFIES THE TYPE OR LOCATION OF THE SAVE AREA
.*       TO BE GENERATED OR USED. VALID VALUES ARE:
.*             -OMITTED-
.*             SAVTYPE=
.*             SAVTYPE=LOCAL
.*             SAVTYPE=(,-SAVE AREA NAME-)
.*             SAVTYPE=(LOCAL,-SAVE AREA NAME-)
.*             SAVTYPE=(LOCAL,,-SAVE AREA LENGTH-)
.*             SAVTYPE=(LOCAL,-SAVE AREA NAME-,-SAVE AREA LENGTH-)
.*                     A STANDARD SAVE AREA IS GENERATED IN THE
.*                     THE MACRO EXPANSION AND ITS ADDRESS IS LOADED
.*                     INTO R13. NOTE, DEPENDING UPON THE BASES=
.*                     OPERAND (SEE ABOVE) R13 MAY ALSO BE DECLARED AS
.*                     A PROGRAM BASE.
.*                        IF A -SAVE AREA NAME- IS GIVEN, THEN IT IS
.*                     USED TO LABEL THE SAVE AREA; OTHERWISE, AN
.*                     INTERNAL NAME IS GENERATED.
.*                              IF -SAVE AREA LENGTH- IS GIVEN, THEN IT
.*                              IS USED TO SET THE LENGTH OF THE SAVE
.*                              AREA; OTHERWISE, THE DEFAULT LENGTH OF
.*                              72 BYTES IS USED.
.*             SAVTYPE=(REMOTE,-SAVE AREA ADDRESS-)
.*                     THE ADDRESS OF THE REMOTE SAVE AREA IS
.*                     LOADED INTO R13. NOTE, IN THIS CASE -SAVE AREA
.*                     ADDRESS- IS A REQUIRED SUB-OPERAND. IT MAY BE
.*                     EITHER AN ADDRESS LABEL OR A PARENTHESIZED
.*                     REGISTER NAME OR AN ADDRESS LABEL FOLLOWED BY A
.*                     PERCENT (%) SIGN. IF THE NAME IS JUST AN ADDRESS
.*                     LABEL, THEN A 'LA' INSTRUCTION IS USED TO LOAD
.*                     THE SAVE AREA'S ADDRESS. IF A PERCENT SIGN
.*                     FOLLOWS THE NAME, THEN AN ADDRESS CONSTANT IS
.*                     GENERATED AND A 'L' INSTRUCTION IS USED. IF A
.*                     REGISTER NAME IS GIVEN, THEN A 'LR' INSTRUCTION
.*                     IS USED UNLESS THE MACRO CAN DETERMINE THAT THE
.*                     NAMED REGISTER IS ACTUALLY R13 IN WHICH CASE IT
.*                     IS ASSUMED THAT THE LOWER SAVE AREA IS ALREADY
.*                     PRESENT AND INITIALIZED, SO THE SAVING OF
.*                     REGISTERS AND THE CROSS-CHAINING OF THE SAVE
.*                     AREAS IS BYPASSED.
.*             SAVTYPE=RENT
.*             SAVTYPE=(RENT,(-LENGTH-,-SUBPOOL-),-ERROR ADDRESS-)
.*             SAVTYPE=(RENT,(-LENGTH-,-SUBPOOL-),RETURN)
.*                     THE MACRO EXPANSION IS TO BE REENTRANT. THE SAVE
.*                     AREA IS TO BE GETMAINED. THE SUB-OPERANDS HAVE
.*                     THE FOLLOWING AFFECT:
.*                     -LENGTH- IS OPTIONAL. IF OMITTED, THEN A VALUE
.*                              OF 72 IS USED. IF GIVEN, THEN IT
.*                              INDICATES THE SIZE OF THE SAVE AREA TO
.*                              BE GOTTEN. WARNING, THE VALUE OF
.*                              -LENGTH- SHOULD NEVER BE LESS THAN 72.
.*                     -SUBPOOL- IS OPTIONAL. IF OMITTED, THEN A VALUE
.*                               OF 0 IS IMPLIED. IF GIVEN, THEN IT
.*                               SPECIFIES THE SUBPOOL OUT OF WHICH THE
.*                               SAVE AREA IS TO BE GOTTEN.
.*                     -ERROR ADDRESS- IS OPTIONAL. IF OMITTED, THEN
.*                                     THE SAVE AREA GETMAIN REQUEST IS
.*                                     UNCONDITIONAL. IF GIVEN, THEN
.*                                     THE GETMAIN IS CONDITIONAL, AND
.*                                     IF IT FAILS, THEN CONTROL IS
.*                                     PASSED TO THE INDICATED ADDRESS.
.*                                     NOTE, -ERROR ADDRESS- MAY BE
.*                                     EITHER A STATEMENT LABEL OR A
.*                                     PARENTHESIZED REGISTER NAME.
.*                                     WARNING, -ERROR ADDRESS- MAY BE
.*                                     USED ONLY IN A MVS ENVIRONMENT.
.*                                     IT IS NOT SUPPORTED UNDER MVT.
.*                     RETURN IS A SPECIAL FORM OF -ERROR ADDRESS-
.*                            WHICH, IF GIVEN, CAUSES CONTROL TO BE
.*                            RETURNED IMMEDIATELY TO THE CALLER IN THE
.*                            EVENT OF A GETMAIN FAILURE. ALL REGISTERS
.*                            ARE RESTORED EXCEPT R15 WHICH CONTAINS
.*                            THE RETURN CODE FROM GETMAIN.
.*             SAVTYPE=PLI
.*             SAVTYPE=(PLI,-LENGTH-)
.*                     THE MACRO IS TO EXPAND INTO THE FORMAT OF A PLI
.*                     PROLOG. THE EXPANSION IS REENTRANT. THE SAVE
.*                     AREA WILL BE A PLI DSA. IT WILL PROBABLY BE
.*                     OBTAINED FROM PLI'S ISA. IF -LENGTH- IS GIVEN,
.*                     THEN IT SPECIFIES THE DESIRED LENGTH OF THE DSA
.*                     THAT THIS EXPANSION OBTAINS. WARNING, THE VALUE
.*                     OF -LENGTH- MUST NEVER BE LESS THAN 88.
.*
.* &PFIX=
.*       THE #ENTER MACRO ATTEMPTS TO USE REGISTER EQUATES IN ITS
.*       EXPANSION WHEN REFERING TO REGISTERS. THIS IS SO THAT THE USE
.*       OF THE REGISTERS IS INDICATED IN THE ASSEMBLER'S CROSS
.*       REFERENCE LISTING. THE PFIX= OPERAND CAN BE USED TO CONTROL
.*       THE SET OF EQUATES USED. FOR EXAMPLE, IF "PFIX=GPR" IS GIVEN,
.*       THEN "GPR1" IS USED WHENEVER THE EXPANSION REFERS FO REGISTER
.*       1.
.*          IF THE PFIX= OPERAND IS OMITTED, THEN THE SET OF REGISTER
.*       EQUATES DEFINED BY THE NEXT PRIOR #REGS MACRO IS USED. IF
.*       THERE ARE NO PRIOR #REGS MACROS, THEN SELF-DEFINING NUMERICS
.*       ARE USED.
.*
.* MISCELLANIOUS CONSIDERATIONS
.*     - SINCE THE #ENTER MACRO EXPANSION USUALLY INCLUDES A CSECT
.*       CARD, THE MACRO CALL SHOULD BE PLACED AT THE PHYSICAL
.*       BEGINNING OF A CONTROL SECTION.
.*     - FOR LOCAL SAVE AREAS IT IS BOTH POSSIBLE AND REASONABLE FOR
.*       R13 TO SERVE AS BOTH THE SAVE AREA POINTER AND A PROGRAM BASE.
.*       THERE ARE, HOWEVER, CERTAIN PRECAUTIONS THAT HAVE TO BE TAKEN
.*       FOR VARIOUS SYSTEM EXIT ROUTINES IF THEY ARE INCLUDED IN THE
.*       PROGRAM. HERE ARE SOME EXAMPLES:
.*           - IOS APPENDAGE ROUTINES: NO BASE REGISTER FOR THE MAIN
.*             PROGRAM, INCLUDING R13, IS AVAILABLE FROM WITHIN AN IOS
.*             APPENDAGE.
.*           - DCB OPEN EXITS: R13 REMAINS A VALID BASE REGISTER.
.*           - EOD ROUTINES: R13 REMAINS A VALID BASE REGISTER.
.*           - SYNAD EXITS: R13 REMAINS A VALID BASE REGISTER UNTIL A
.*             SYNADAF MACRO IS ISSUED. AFTER A SUBSEQUENT SYNADRLS
.*             MACRO, R13 IS AGAIN A VALID PROGRAM BASE.
.*
.*
.*
.* INNER MACROS USED - #USING, #TEST, SAVE, GETMAIN
.*
         GBLA  &#TESERR
         GBLB  &#ENTRNT,&#ENTPLI
         GBLC  &#TESRET(20),&#ENTSIZ,&#ENTSP,&#BS(14)
         LCLA  &A1,&A2,&C1,&C2,&C3,&C4,&B(13),&RMTREGA
         LCLB  &REDUN(13),&OLDBASE,&REMOTE(5),&ALIGND,&LOCAL,&LENGTH
         LCLC  &LID,&@,&#,&N1,&N2,&W2,&W3,&R,&RMTREGC,&SAVLEN,&RMTNAME
         LCLC  &SPOOL,&TB,&ESDT
&#       SETC  '&SYSNDX'
&#ENTRNT SETB  (0)
&#ENTPLI SETB  (0)
&C1      SETA  11
         AIF   ('&SAVTYPE(1)' NE 'RENT').TYPNRNT
&#ENTRNT SETB  (1)
&#ENTSIZ SETC  '72'
&#ENTSP  SETC  ''
         #TEST DCODE=&SAVTYPE(2)
&A1      SETA  &#TESRET(1)
         AIF   (&A1 EQ 0).PFXTST
         AIF   ('&#TESRET(2)' EQ '').DFLTLEN
&#ENTSIZ SETC  '&#TESRET(2)'
.DFLTLEN AIF   (&A1 EQ 1).PFXTST
&#ENTSP  SETC  '&#TESRET(3)'
         AGO   .PFXTST
.TYPNRNT ANOP
.*
         AIF   ('&SAVTYPE(1)' NE 'REMOTE').TYPNRMT
&REMOTE(1) SETB (1)
         AIF   ('&SAVTYPE(2)' NE '').GOTRMT2
         MNOTE 12,'ERROR - SAVTYPE(2) (REMOTE AREA''S NAME) OMITTED.'
.GOTRMT2 AIF   ('&SAVTYPE(2)'(1,1) EQ '(').TYPLCL2
&REMOTE(2) SETB (1)
&RMTNAME SETC  '&SAVTYPE(2)'
         AIF   ('&SAVTYPE(2)'(K'&SAVTYPE(2),1) NE '%').PFXTST
&REMOTE(5) SETB (1)
&RMTNAME SETC  '&SAVTYPE(2)'(1,K'&SAVTYPE(2)-1)
         AGO   .PFXTST
.TYPLCL2 #TEST DCODE=&SAVTYPE(2)
&RMTREGC SETC  '&#TESRET(2)'
         #TEST REGS=&RMTREGC
         AIF   (&#TESERR NE 0).PFXTST
&RMTREGA SETA  &#TESRET(1)
         AIF   (&RMTREGA NE 13).PFXTST
&REMOTE(3) SETB (1)
         AGO   .PFXTST
.TYPNRMT ANOP
.*
         AIF   ('&SAVTYPE(1)' NE 'PLI').TYPNPLI
&#ENTPLI SETB  (1)
&C1      SETA  10
         AGO   .PFXTST
.TYPNPLI ANOP
.*
         AIF   ('&SAVTYPE(1)' EQ '' OR '&SAVTYPE(1)' EQ 'LOCAL').TYPLCL
         MNOTE 4,'SAVTYPE(1)=&SAVTYPE(1) IS INVALID.'
         MNOTE 4,'SAVTYPE(1)=LOCAL ASSUMED.'
.TYPLCL  ANOP
&LOCAL   SETB  (1)
&C1      SETA  12
&LID     SETC  'E&#.SVA'
         AIF   ('&SAVTYPE(2)' EQ '').GOTSLID
&LID     SETC  '&SAVTYPE(2)'
.GOTSLID ANOP
&SAVLEN  SETC  '72'
         AIF   ('&SAVTYPE(3)' EQ '').PFXTST
&SAVLEN  SETC  '&SAVTYPE(3)'
.*
.PFXTST  ANOP
&@       SETC  '&PFIX'
         AIF   (K'&PFIX NE 0).GOTPFIX
         #TEST PFIX=
&@       SETC  '&#TESRET(1)'
         AGO   .DONPFIX
.GOTPFIX #REGS &PFIX,GEN=NO
.DONPFIX ANOP
&A1      SETA  0
         AIF   ('&BASES' NE '*').BSCLR
.BSOLD   AIF   (&A1 EQ 13).BASEND
&A1      SETA  &A1+1
         AIF   ('&#BS(&A1)' EQ '').BSOLD
         #TEST REGS=&#BS(&A1)
&B(&A1)  SETA  16
         AIF   (&#TESERR NE 0).BSOLD
&B(&A1)  SETA  &#TESRET(1)
         AIF   (&B(&A1) NE 13).BSOLD
         AIF   (&A1 NE 13 OR '&#BS(14)' NE '&RMTNAME' OR &#ENTRNT OR &#*
               ENTPLI).BSERROR
&REMOTE(4) SETB (1)
         AGO   .BSOLD
.BSERROR ANOP
         MNOTE 4,'THE OLD BASE REGISTER &B(&A1) CANNOT ALSO FUNCTION'
         MNOTE 4,'AS A SAVE AREA POINTER IN THIS CONTEXT.'
         MNOTE 4,'THE CODE GENERATED BELOW WILL NOT FUNCTION CORRECTLY.*
               '
         AGO   .BSOLD
.BSCLR   AIF   (&A1 EQ 14).BSCLRD
&A1      SETA  &A1+1
&#BS(&A1) SETC ''
         AGO   .BSCLR
.BSCLRD  AIF   (K'&BASES EQ 0).BASEND
         AIF   ('&BASES' NE '&BASES(1)').TSTNBSE
         #TEST NUM=&BASES
         AIF   (&#TESERR EQ 0).BSEOKX
         MNOTE 4,'"BASES=&BASES" IS INVALID.'
         MNOTE 4,'"BASES=1" ASSUMED.'
&C3      SETA  1
         AGO   .BSESET
.BSEOKX  ANOP
&C3      SETA  &BASES
         AIF   (&C3 LE &C1).BSESET
         MNOTE 4,'"BASES=&BASES" IS OUTSIDE THE RANGE OF 0...&C1..'
         MNOTE 4,'THE CODE GENERATED BELOW WILL NOT FUNCTION CORRECTLY.*
               '
.BSESET  ANOP
&C1      SETA  &C1+1
&C3      SETA  &C1-&C3
&C4      SETA  13
.BOK     AIF   (&C1 LE &C3).BASEND
&#BS(&C4) SETC '&@&C1'
&B(&C4)  SETA  &C1
&C1      SETA  &C1-1
&C4      SETA  &C4-1
         AGO   .BOK
.TSTNBSE ANOP
&C3      SETA  N'&BASES
         AIF   (&C3 LE &C1).NBSOK
         MNOTE 4,'"BASES=&BASES" SPECIFIES TOO MAY REGISTERS.'
         MNOTE 4,'ONLY THE FIRST &C1 REGISTERS WILL BE USED.'
&C3      SETA  &C1
.NBSOK   ANOP
&C1      SETA  &C1+1
&C4      SETA  13
&C2      SETA  0
.GETBSE  AIF   (&C2 GE &C3).BASEND
&C2      SETA  &C2+1
         AIF   ('&BASES(&C2)' EQ '').IGNR
         #TEST REGS=&BASES(&C2)
&B(&C4)  SETA  16
         AIF   (&#TESERR EQ 16).REGUNK
         AIF   (&#TESRET(1) GE 2 AND &#TESRET(1) LE &C1).BSEOK2
         MNOTE 4,'"BASES(&C2)=&BASES(&C2)" IS OUTSIDE THE RANGE OF 2...*
               &C1..'
         MNOTE 4,'THE CODE GENERATED BELOW WILL NOT FUNCTION CORRECTLY.*
               '
         AGO   .BSEOK2
.IGNR    AIF   (&C3 GE N'&BASES).GETBSE
&C3      SETA  &C3+1
         AGO   .GETBSE
.BSEOK2  AIF   (NOT &REDUN(&#TESRET(1))).BSEOK3
         MNOTE 4,'"BASES(&C2)=&BASES(&C2) IS REDUNDANT.'
         MNOTE 4,'THE CODE GENERATED BELOW WILL NOT FUNCTION CORRECTLY.*
               '
.BSEOK3  ANOP
&REDUN(&#TESRET(1)) SETB (1)
&B(&C4)  SETA &#TESRET(1)
.REGUNK  ANOP
&C1      SETA  12
&#BS(&C4) SETC '&BASES(&C2)'
&C4      SETA  &C4-1
         AGO   .GETBSE
.BASEND  ANOP
.*
&R       SETC  '&@.1'
&C3      SETA  0
.WRLP    AIF   (&C3 GE 13).GOTWRG
&C3      SETA  &C3+1
         AIF   ('&#BS(&C3)' EQ '').WRLP
         AIF   (&B(&C3) EQ 13).GOTWRG
&R       SETC  '&#BS(&C3)'
.GOTWRG  ANOP
.*
&ESDT    SETC  '&ESDTYPE(1)'
         AIF   (&#ENTPLI).PLIGEN
.*
         AIF   ('&ESDT' NE 'DEFAULT').GOTESD
&ESDT    SETC  'CSECT'
.GOTESD  ANOP
&N2      SETC  '&N'
         AIF   ('&ESDT' EQ 'NONE' OR '&ESDT' EQ '' OR '&ESDT' EQ 'ENTRY*
               ').NCSCETC
         AIF   ('&ESDT' NE 'CSECT').ESDNCSC
&N       CSECT                     START CONTROL SECTION
         AGO   .ESDDONE
.ESDNCSC AIF   ('&ESDT' NE 'START').ESDNSTA
&N       START ,                   START CONTOL SECTION
         AGO   .ESDDONE
.ESDNSTA ANOP
&W2      SETC  '&ESDT'
&N       &W2   0H'0'               START
.ESDDONE ANOP
&N2      SETC  ''
.*
.NCSCETC AIF   ('&ESDT' NE 'ENTRY').NENTRY
         ENTRY &N                  MAKE NAME EXTERNALLY AVAILABLE
.NENTRY  ANOP
.*
         AIF   (K'&NME EQ 0 AND '&ESDT' NE 'CSECT' AND '&ESDT' NE 'STAR*
               T').NMODID
&N2      B     E&#.ZID-&N.(,&@.15) SKIP AROUND THE MODULE ID
&N2      SETC  'E&#.ZID'
         DC    AL1(&N2-E&#.MID)    LENGTH OF TEXT
E&#.MID  DC    C'&N '              ENTRY NAME
&W2      SETC  '&SYSDATE       '(1,8).' '
         DC    C'&W2'              ASSEMBLY DATE
&W2      SETC  '&SYSTIME    '(1,5)
         AIF   (K'&NME EQ 0).NMEZ1
&W2      SETC  '&W2 - '
.NMEZ1   DC    C'&W2'              ASSEMBLY TIME
         AIF   (K'&NME EQ 0).NMEZ2
         AIF   ('&NME'(1,1) EQ '''').QNME
         DC    C'&NME'
         AGO   .NMEZ2
.QNME    DC    C&NME
.NMEZ2   ANOP
.NMODID  ANOP
.*
         AIF   (&REMOTE(3)).RNTRNT1
&W2      SETC  '&@.14,&@.12,12(&@.13)'
&N2      STM   &W2                 SAVE CALLER'S REGISTERS
&N2      SETC  ''
.*
         AIF   (&#ENTRNT).RNTRNT1
         LR    &R,&@.13            POINT TO HIGHER SA
         AIF   (&REMOTE(1)).LRMTSV1
         LA    &@.13,&LID-&N.(,&@.15) POINT TO LOWER SA
         AGO   .LRMTSV2
.LRMTSV1 AIF   (&REMOTE(2)).LRMTSV3
         #TEST REGS=&R
         AIF   (&RMTREGA NE &#TESRET(1)).LRMTSV4
&A1      SETA  20+&RMTREGA*4-&RMTREGA/13*44
         L     &@.13,&A1.(,&@.13)  POINT TO LOWER SA
         AGO   .LRMTSV2
.LRMTSV4 LR    &@.13,&RMTREGC      POINT TO LOWER SA
         AGO   .LRMTSV2
.LRMTSV3 AIF   (&REMOTE(5)).LRMTSV5
         PUSH  USING               SAVE USING ENVIRONMENT
         USING &N,&@.15            DECLARE TEMP BASE
         LA    &@.13,&RMTNAME      POINT TO LOWER SA
         POP   USING               RESTORE USING ENVIRONMENT
         AGO   .LRMTSV6
.LRMTSV5 L     &@.13,E&#.SAP-&N.(,&@.15) POINT TO LOWER SA
.LRMTSV6 ANOP
         USING &RMTNAME,&@.13      DECLARE A BASE FOR IT
.LRMTSV2 ST    &@.13,8(,&R)        FORWARD CHAIN THE SAVE AREAS
         ST    &R,4(,&@.13)        BACK CHAIN THE SAVE AREAS
         AIF   ('&R' NE '&@.1').RNTRNT1
         L     &@.1,24(,&@.1)      RESTORE REGISTER 1
.RNTRNT1 AIF   ('&#BS(13)' EQ '').SKIPUSE
&C1      SETA  13
         AIF   ('&BASES' NE '*').BSEADR
         AIF   (&REMOTE(4)).EQUATE
&OLDBASE SETB  (1)
&N2      L     &#BS(13),E&#.BSE-&N.(,&@.15) LOAD FIRST BASE REGISTER
&N2      SETC  ''
         AGO   .EQUATE
.BSEADR  ANOP
&C2      SETA  15
&#BS(14) SETC  '&N'
         AIF   (&#ENTRNT OR &REMOTE(1)).FLDTST
&C2      SETA  13
&#BS(14) SETC  '&LID'
.FLDTST  AIF   (&B(13) EQ &C2).EQUATE
&N2      LR    &#BS(13),&@&C2      LOAD FIRST BASE REGISTER
&N2      SETC  ''
.EQUATE  ANOP
&W2      SETC  '&#BS(&C1)'
         AIF   (&C1 EQ 2).ENDLA
&C1      SETA  &C1-1
         AIF   ('&#BS(&C1)' EQ '').ENDLA
&N2      LA    &#BS(&C1),X'FFF'(,&W2) LOAD NEXT BASE
&N2      SETC  ''
         AGO   .EQUATE
.ENDLA   #USING
.SKIPUSE AIF   (NOT &#ENTRNT).DATACHK
&W2      SETC  ''
&TB      SETC  ''
         AIF   ('&#BS(13)' NE '').GETM2
&N2      LR    &@.14,&@.15         LOAD TEMPORARY BASE
&N2      SETC  ''
         PUSH  USING               SAVE BASES
         DROP  ,                   CLEAR BASES
         USING &N,&@.14            DECLARE TEMPORARY BASE
&TB      SETC  '-&N.(,&@.14)'
.GETM2   ANOP
&N2      L     &@.0,E&#.LEN        LOAD LENGTH (MAYBE SUBPOOL TOO)
&N2      SETC  ''
         AIF   ('&#ENTSP' EQ '' OR '&SAVTYPE(3)' EQ '').GETM4
&SPOOL   SETC  ''
         MNOTE '         GETMAIN RC,LV=(0),SP=&#ENTSP'
         GETMAIN RC,LV=(0),SP=&#ENTSP
         AGO   .GETM5
.GETM4   ANOP
&SPOOL   SETC  '&#ENTSP'
&W3      SETC  'R'
         AIF   ('&SAVTYPE(3)' EQ '').GETM4A
&W3      SETC  'RC'
.GETM4A  MNOTE '         GETMAIN &W3,LV=(0)'
         GETMAIN &W3,LV=(0)
.GETM5   AIF   ('&#BS(13)' NE '').GETM5A
         POP   USING               RESTURE BASES
.GETM5A  AIF   ('&SAVTYPE(3)' EQ '').GETM7
         LTR   &@.15,&@.15         GETMAIN OK?
         AIF   ('&SAVTYPE(3)' EQ 'RETURN').GETM8
         AIF   ('&SAVTYPE(3)'(1,1) EQ '(').GETM6
         BNZ   &SAVTYPE(3)         NO, TAKE ERROR EXIT
         AGO   .GETM7
.GETM6   #TEST DCODE=&SAVTYPE(3)
         BCR   7,&#TESRET(2)       NO, TAKE ERROR EXIT
         AGO   .GETM7
.GETM8   ANOP
&W2      SETC  'E&#.GO'
         BZ    &W2&TB              YES, PROCEED
         L     &@.14,12(,&@.13)    NO, RESTORE REGISTER
         LM    &@.0,&@.12,20(&@.13) RESTORE REGISTERS
         MVI   12(&@.13),X'FF'     SET RETURNED SIGNEL
         BR    &@.14               RETURN TO CALLER
.GETM7   ANOP
&W2      LR    &@.0,&@.1           POINT TO AREA TO CLEAR
         L     &@.1,E&#.LEN&TB     GET LENGTH TO CLEAR
         LR    &@.14,&@.0          SAVE AREA POINTER
         MVCL  &@.0,&@.14          CLEAR THE AREA (R15 SET BY GETMAIN)
         ST    &@.14,8(,&@.13)     FORWARD CHAIN THE SAVE AREAS
         ST    &@.13,4(,&@.14)     BACK CHAIN THE SAVE AREAS
         LM    &@.13,&@.1,8(&@.13) RESTORE REGS AND POINT TO LOWER SA
.DATACHK AIF   (NOT &OLDBASE AND NOT &#ENTRNT AND NOT &REMOTE(5) AND NO*
               T &LOCAL).ENDCHK
         AIF   ('&#BS(13)' EQ '').NOUSING
&N2      B     E&#.END             SKIP AROUND DATA AREA
&N2      SETC  ''
         AGO   .DFNDATA
.NOUSING ANOP
&N2      B     E&#.END-&N.(,&@.15) SKIP AROUND DATA AREA
&N2      SETC  ''
.DFNDATA AIF   (NOT &OLDBASE).NOLDBSE
E&#.BSE  DC    A(&#BS(14))         OLD BASE ADDRESS
&ALIGND  SETB  (1)
.NOLDBSE AIF   (NOT &#ENTRNT).NLENGTH
         AIF   ('&SPOOL' EQ '').NSUBPOO
         AIF   (&ALIGND).ALIGND1
         DS    0F                  ALIGNMENT
&ALIGND  SETB  (1)
.ALIGND1 ANOP
E&#.LEN  DC    AL1(&SPOOL),AL3(&#ENTSIZ) SAVE AREA SUBPOOL AND LENGTH
         AGO   .NLENGTH
.NSUBPOO ANOP
E&#.LEN  DC    A(&#ENTSIZ)         SAVE AREA LENGTH
&ALIGND  SETB  (1)
.NLENGTH AIF   (&#ENTRNT).NSVAREA
         AIF   (&REMOTE(1)).RMTSVPT
         AIF   (&ALIGND).ALIGND2
         DS    0F                  ALIGNMENT
&ALIGND  SETB  (1)
.ALIGND2 ANOP
&LID     DC    (&SAVLEN)X'00'      LOCAL SAVE AREA
         AGO   .NSVAREA
.RMTSVPT AIF   (NOT &REMOTE(5)).NSVAREA
E&#.SAP  DC    A(&RMTNAME)         PTR TO REMOTE SAVE AREA
.NSVAREA AGO   .END
.*
.PLIGEN  AIF   ('&ESDT' EQ 'DEFAULT').PESDSET
         AIF   (K'&N GT 0 OR '&ESDT' NE 'ENTRY').PESDOK1
         MNOTE 4,'"ESDTYPE=&ESDTYPE" IS INVALID WHEN THE NAME FIELD IS'
         MNOTE 4,'OMITTED FROM THE MACRO CALL.'
         MNOTE 4,'"ESDTYPE=NONE" WILL BE USED INSTEAD.'
&ESDT    SETC  'NONE'
.PESDOK1 ANOP
         AIF   ('&ESDT' EQ 'ENTRY' OR '&ESDT' EQ 'NONE' OR '&ESDT' EQ '*
               ').PESDOK
         MNOTE 4,'"ESDTYPE=&ESDTYPE" IS INVALID WHEN "SAVTYPE=PLI".'
.PESDSET ANOP
&ESDT    SETC  'ENTRY'
         AIF   (K'&N GT 0).PESDOK2
&ESDT    SETC  'NONE'
.PESDOK2 AIF   ('&ESDTYPE' EQ 'DEFAULT').PESDOK
         MNOTE 4,'"ESDTYPE=&ESDT" WILL BE USED INSTEAD.'
.PESDOK  ANOP
         AIF   ('&ESDT' NE 'ENTRY').PNOTENT
         ENTRY &N                  MAKE NAME EXTERNALLY AVAILABLE
.PNOTENT ANOP
.*
&N2      SETC  '&N'
&A1      SETA  K'&N
         AIF   (K'&NME EQ 0).GOTN2
&N2      SETC  '&NME'
&A1      SETA  K'&NME
.GOTN2   ANOP
&N2      SETC  ' '(1,1-(&A1-&A1/2*2)).'&N2'
         DS    0H                  ALIGNMENT
         DC    C'&N2'              ENTRY NAME
         DC    AL1(&A1)            LENGTH OF NAME
.*
&N1      SETC  '&N'
         AIF   (K'&N GT 0).PGOTN1
&N1      SETC  'E&#.ENT'
.PGOTN1  ANOP
         USING &N1,&@.15           DCL LOCAL BASE
&N1      STM   &@.14,&@.12,12(&@.13) SAVE CALLER'S REGISTERS
.*
         #TEST DCODE=&SAVTYPE(2)
&A1      SETA  &#TESRET(1)
&A2      SETA  120
         AIF   (&A1 EQ 0).DSALLA
         AIF   ('&#TESRET(2)' NE '&SAVTYPE(2)').DSALREG
         #TEST NUM=&#TESRET(2)
         AIF   (&#TESERR NE 0).DSALL
&A2      SETA  &#TESRET(2)
         AIF   (&A2 GE 4096-7).DSALL
         AIF   (&A2 GE 120-7).DSALLA
         MNOTE 4,'"SAVTYPE(2)=&SAVTYPE(2)" IS TOO SHORT A LENGTH.'
         MNOTE 4,'THE CODE GENERATED BELOW WILL NOT FUNCTION CORRECTLY.*
               '
.DSALLA  ANOP
         LA    &@.0,(&A2+7)/8*8    GET DESIRED DSA LENGTH
         AGO   .GOTDSAL
.DSALREG #TEST REGS=&#TESRET(2)
         AIF   (&#TESERR NE 0).DSALLR
         AIF   (&#TESRET(1) EQ 0).GOTLLR
.DSALLR  LR    &@.0,&#TESRET(2)    GET DESIRED DSA LENGTH
.GOTLLR  LA    &@.14,7             ROUND UP -
         AR    &@.0,&@.14           TO -
         OR    &@.0,&@.14            DOUBLE WORD -
         XR    &@.0,&@.14             LENGTH
         AGO   .GOTDSAL
.DSALL   ANOP
&LENGTH  SETB  (1)
         L     &@.0,E&#.LEN        GET DESIRED DSA LENGTH
.GOTDSAL ANOP
.*
         L     &@.1,76(,&@.13)     GET NXT AVAILABLE BLOCK POINTER
         ALR   &@.0,&@.1           --> PAST DESIRED AREA
         CL    &@.0,12(,&@.12)     WOULD THE ISA OVERFLOW?
         BNH   E&#.GOT             NO, PROCEED
         L     &@.15,116(,&@.12)   YES, --> SPECIAL HANDLER
         DROP  &@.15               RELEASE CLOBBERED BASE
         BASR  &@.14,&@.15         GO OBTAIN DESIRED DSA FROM ELSEWHERE
E&#.GOT  LR    &@.14,&@.1          SAVE PTR TO NEW DSA
         LR    &@.15,&@.0          SAVE HI-BYTE OF NAB POINTER REG
         SRL   &@.15,24            ISSOLATE IT
         SLL   &@.15,24            RESTORE ITS POSITION. SET MVCL
*                                  SOURCE LENGTH TO ZERO
         SR    &@.0,&@.1           GET LENGTH OF NEW DSA
         LR    &@.1,&@.0           COPY FOR MVCL SINK LENGTH
         LR    &@.0,&@.14          GET MVCL SINK POINTER
         MVCL  &@.0,&@.14          CLEAR THE NEW DSA
         OR    &@.0,&@.15          RESTORE HI-BYTE TO NAB POINTER REG
         LR    &@.1,&@.0           COPY NEXT AVAILABLE BLOCK POINTER
         L     &@.15,72(,&@.13)    GET LIBRARY WORKSPACE POINTER
         STM   &@.15,&@.1,72(&@.14) STORE INTO OUR NEW DSA
         ST    &@.5,88(,&@.14)     STORE PASSED PARAMETERS POINTER
         ST    &@.13,4(,&@.14)     BACK CHAIN THE DSA
         L     &@.1,24(,&@.13)     RESTORE PLIST POINTER
         LR    &@.13,&@.14         --> NEW DSA (R14 PURIFIED BY MVCL)
         MVI   0(&@.13),X'80'      SET FOR -
         MVI   1(&@.13),X'00'       PLI -
         MVI   86(&@.13),X'91'       ERROR -
         MVI   87(&@.13),X'C0'        HANDLING
.*
&N2      SETC  ''
         AIF   ('&#BS(13)' EQ '').PSKPUSE
&C1      SETA  13
         AIF   ('&BASES' NE '*').PBSEADR
&OLDBASE SETB  (1)
         BASR  &#BS(13),0          LOAD TEMP LOCAL BASE
         L     &#BS(13),E&#.BSE-*(,&#BS(13)) LOAD 1ST PROGRAM BASE
         AGO   .PEQUATE
.PBSEADR ANOP
&N2      SETC  'E&#.BSE'
&#BS(14) SETC  '&N2'
         BASR  &#BS(13),0          LOAD 1ST PROGRAM BASE
.PEQUATE ANOP
&W2      SETC  '&#BS(&C1)'
&C1      SETA  &C1-1
         AIF   (&C1 EQ 1 OR '&#BS(&C1)' EQ '').PENDLA
&N2      LA    &#BS(&C1),X'FFF'(,&W2) LOAD NEXT PROGRAM BASE
&N2      SETC  ''
         AGO   .PEQUATE
.PENDLA  #USING ,
.PSKPUSE ANOP
.*
         AIF   (NOT &LENGTH AND NOT &OLDBASE).ENDCHK
         AIF   ('&#BS(13)' NE '').PGOTBAS
&N2      BASR  &@.15,0             LOAD TEMP BASE
&N2      SETC  ''
         B     E&#.END-*(,&@.15)   SKIP DATA AREA
         AGO   .PDFNDAT
.PGOTBAS ANOP
&N2      B     E&#.END             SKIP DATA AREA
&N2      SETC  ''
.PDFNDAT AIF   (NOT &LENGTH).PNOLEN
E&#.LEN  DC    A((&SAVTYPE(2)+7)/8*8) DESIRED DSA LENGTH
.PNOLEN  AIF   (NOT &OLDBASE).PNOOBAS
E&#.BSE  DC    A(&#BS(14))         OLD BASE ADDRESS
.PNOOBAS ANOP
.*
.END     ANOP
E&#.END  DS    0H
.ENDCHK  AIF   ('&N2' EQ '').MEND
&N2      DS    0H
.MEND    MEND
         MACRO
&NME     #EXIT &R,&PFIX=,&RC=
.*
.*
.*
.* LAST CHANGE DATE - OCTOBER 18, 1983
.*                  - MAILING ADDRESS CHANGE
.*
.* LAST CHANGE DATE - APRIL 21, 1981
.*                  - CHANGE THE MACRO NAME FROM $EXIT TO #EXIT
.*
.* LAST CHANGE DATE - APRIL 15, 1981
.*                  - ADDED EXIT LINKAGE FOR A PLI ENVIRONMENT.
.*                  - "#REGS GEN=NO" SUPPORT ADDED.
.*
.* LAST CHANGE DATE - OCTOBER 3, 1978
.*                  - FOR REENTRANT SAVE AREAS, THE FREEMAIN HAS BEEN
.*                    CHANGED SO THAT MORE THAN 4K CAN BE FREED.
.*
.* LAST CHANGE DATE - FEBRUARY 2, 1977
.*                  - MAILING ADDRESS CHANGE.
.*
.* LAST CHANGE DATE - FEBRUARY 10, 1976
.*
.* THIS MACRO WAS WRITTEN BY DAVID B. COLE.  ANY QUESTIONS CONCERNING
.* IT MAY BE ADDRESSED TO:
.*       RR#2 BOX 712
.*       AFTON, VA. 22920
.*
.*
.*
.*   THIS MACRO GENERATES EITHER OS STANDARD OR PLI STANDARD EXIT
.* LINKAGE. IT WAS WRITTEN TO PROVIDE A SIMPLE, FLEXIBLE, AND COMPLETE
.* METHOD FOR GENERATING SUCH LINKAGE. IN ADDITION, FOR ALL POSSIBLE
.* OPERAND COMBINATIONS, #EXIT WILL GENERATE THE ABSOLUTE MINIMUM
.* AMOUNT OF CODE NECESSARY.
.*
.*   THE #EXIT MACRO WILL GENERATE THE FOLLOWING:
.* - CODE TO LOAD REGISTER 13 WITH A POINTER TO THE HIGHER OS SAVE AREA
.*   OR PLI DATA STORAGE AREA
.* - CODE TO SET THE RETURNED FLAG IN THE HIGHER SAVE AREA (X'FF' AT
.*   BYTE NUMBER 12) (OS ONLY)
.* - CODE TO RELEASE (VIA FREEMAIN) THE LOWER SAVE AREA IF THE
.*   PRECEEDING #ENTER MACRO CALL GENERATED A REENTRANT EXPANSION
.* - CODE TO RESTORE ANY PARTICULAR SET OF REGISTERS
.* - CODE TO LOAD REGISTER 15 WITH A RETURN CODE THAT IS EITHER AN
.*   ABSOLUTE VALUE OR A VALUE PRELOADED INTO ANY REGISTER
.* - CODE TO RETURN TO THE CALLING PROGRAM VIA REGISTER 14
.*
.*   THE NAME FIELD
.* USE THIS FIELD TO ASSIGN A STATEMENT LABEL TO THE FIRST MACHINE
.* INSTRUCTION OF THE EXPANSION. IF THE NAME FIELD IS OMITTED, THEN NO
.* STATEMENT LABEL IS ASSIGNED.
.*
.*   THE FIRST POSITIONAL OPERAND
.* THIS OPERAND MUST CONSIST OF A SUB-LIST OF ANY NUMBER OF ENTRIES.
.* EACH ENTRY MAY BE EITHER A SINGLE REGISTER NAME OR A PARENTHESIZED
.* PAIR (SEPERATED BY A COMMA) OF REGISTER NAMES - E.G.
.* " (1,11,(7,9),5) ". EACH SINGLE REGISTER NAME SPECIFIES A PARTICULAR
.* REGISTER TO BE RESTORED FROM THE HIGHER SAVE AREA. EACH
.* PARENTHESIZED PAIR OF REGISTER NAMES SPECIFIES A RANGE OF REGISTERS
.* TO BE RESTORED. THUS, THE ABOVE EXAMPLE WOULD CAUSE REGISTERS 1, 5,
.* 7, 8, 9, AND 11 TO BE RESTORED.
.*   SOME NOTES AND WARNINGS:
.* - A REQUEST TO RESTORE REGISTER 13 IS MEANINGLESS AND IS IGNORED.
.* - IF REGISTER 14 IS TO BE LOADED WITH THE RETURN ADDRESS FOUND IN
.*   THE HIGHER SAVE AREA, THEN YOU MUST SPECIFICALLY REQUEST THAT IT
.*   (REGISTER 14) BE RESTORED; OTHERWISE, WHATEVER VALUE IS FOUND IN
.*   REGISTER 14 PRIOR TO THE MACRO CALL WILL BE USED FOR THE RETURN
.*   ADDRESS.
.* - TO RESTORE ALL REGISTERS FROM 14 THROUGH 12, YOU MUST CODE
.*   " ((14,12)) ". CODING " (14,12) " WILL CAUSE ONLY REGISTERS 14 AND
.*   12 TO BE RESTORED.
.* - THE NUMERIC VALUES OF ALL REGISTER NAMES USED IN THIS OPERAND MUST
.*   BE DETERMINABLE AT MACRO PASS TIME. THUS, EACH REGISTER NAME USED
.*   MUST BE EITHER A SELF-DEFINING NUMERIC OR A NAME DEFINED VIA THE
.*   #REGS MACRO.
.* - IF ONLY A SINGLE REGISTER IS TO BE RESTORED, THEN IT NEED NOT BE
.*   ENCLOSED IN PARENTHESES.
.* - IF THE FIRST POSITIONAL OPERAND IS OMITTED, THEN NO REGISTERS ARE
.*   RESTORED.
.*
.*   THE RC= OPERAND
.* THIS OPERAND MUST CONSIST OF A SINGLE VALUE EITHER WITHIN OR NOT
.* WITHIN PARENTHESES. IF ENCLOSED WITHIN PARENTHESES, THEN THE VALUE
.* IS TREATED AS THE NAME OF A REGISTER CONTAINING A RETURN CODE. IF
.* NOT ENCLOSED WITHIN PARENTHESES, THEN THE VALUE IS TREATED AS BEING
.* THE RETURN CODE ITSELF.
.*   IF THE RC= OPERAND SPECIFIES A REGISTER NAME, THEN:
.* - THE VALUE OF THAT NAME NEED NOT BE DETERMINABLE AT MACRO PASS
.*   TIME;
.* - THE REGISTER NAME MAY IDENTIFY ANY REGISTER WHATSOEVER REGUARDLESS
.*   OF WHICH REGISTERS ARE TO BE RESTORED SINCE IN CASES OF POTENTIAL
.*   CONFLICT, THE RETURN CODE IS COPIED INTO REGISTER 15 PRIOR TO
.*   REGISTER RESTORATION;
.* - IT IS ILLOGICAL FOR THE RC= OPERAND TO SPECIFY REGISTER 13.
.* NOTE THAT IF THE RC= OPERAND IS SPECIFIED BUT THE FIRST POSITIONAL
.* OPERAND INDICATES THAT REGISTER 15 IS ALSO TO BE RESTORED, THEN
.* REGISTER 15 IS NOT RESTORED. INSTEAD, IT IS LOADED WITH THE RETURN
.* CODE VALUE.
.*   IF THE RC= OPERAND IS OMITTED, THEN NO CODE IS GENERATED TO LOAD
.* REGISTER 15 WITH A RETURN CODE.
.*
.*   THE PFIX= OPERAND
.* THE #EXIT MACRO ATTEMPTS TO USE REGISTER EQUATES IN ITS EXPANSION
.* WHEN REFERING TO REGISTERS. THIS IS SO THAT THE USE OF THE REGISTERS
.* WILL BE INDICATED IN THE CROSS REFERENCE LISTING. THE PFIX= OPERAND
.* CAN BE USED TO CONTROL THE SET OF EQUATES USED. FOR EXAMPLE, IF
.* "PFIX=GPR" IS SPECIFIED, THEN "GPR1" WILL BE USED WHENEVER THE
.* EXPANSION REFERS TO REGISTER 1.
.*   IF THE PFIX= OPERAND IS OMITTED, THEN THE SET OF EQUATES DEFINED
.* BY THE FIRST PRIOR #REGS MACRO WILL BE USED. IF THERE IS NO PRIOR
.* #REGS MACRO, THEN NO EQUATES WILL BE USED.
.*
.*   CONSIDERATIONS
.* THE #EXIT MACRO WILL GENERATE AN EXPANSION THAT WILL ACCURATELY
.* RESTORE ALL DESIRED REGISTERS AND SET THE RETURN CODE REGUARDLESS OF
.* WHETHER OR NOT A FREEMAIN SVC IS ISSUED TO RELEASE THE LOWER SAVE
.* AREA AND REGUARDLESS OF THE RELATIONSHIP BETWEEN THE RC= OPERAND AND
.* THE SET OF REGISTERS RESTORED.
.*
.*
.*
.* INNER MACROS USED - #REGS #TEST AND FREEMAIN
.*
         GBLA  &#TESERR
         GBLB  &#ENTRNT,&#ENTPLI
         GBLC  &#TESRET(20),&#ENTSIZ,&#ENTSP
         LCLA  &C1,&R1,&R2,&W1,&W2,&ERRCODE
         LCLB  &RCLA,&RCST,&RSW(16)
         LCLC  &LNME,&@,&RG(16),&REGNME,&RG2SAVE,&RG4SAVE,&RG5SAVE
&LNME    SETC  '&NME'
.*
&@       SETC  '&PFIX'
         AIF   (K'&PFIX NE 0).GOTPFIX
         #TEST PFIX=
&@       SETC  '&#TESRET(1)'
         AGO   .DONPFIX
.GOTPFIX #REGS &PFIX,GEN=NO
.DONPFIX ANOP
.*
.RLP     AIF   (&C1 GE N'&R).RFIN
&C1      SETA  &C1+1
         #TEST DCODE=&R(&C1)
         AIF   (&#TESERR NE 0).END
&W1      SETA  &#TESRET(1)
         AIF   (&W1 EQ 0).RLP
&REGNME  SETC  '&#TESRET(2)'
         #TEST REGS=&REGNME
&ERRCODE SETA  1
         AIF   (&#TESERR NE 0).REGERR
.REGOK1  ANOP
&R1      SETA  &#TESRET(1)
&R2      SETA  &R1+3-&R1/14*16
&RG(&R2) SETC  '&REGNME'
&RSW(&R1+1) SETB (1)
         AIF   (&W1 EQ 1).RLP
         AIF   (&W1 EQ 2).TWOND
         MNOTE 4,'"&R(&C1)" CONTAINS EXCESS INFORMATION.'
.TWOND   ANOP
&REGNME  SETC  '&#TESRET(3)'
         #TEST REGS=&REGNME
&ERRCODE SETA  2
         AIF   (&#TESERR NE 0).REGERR
.REGOK2  ANOP
&W2      SETA  &#TESRET(1)
&RSW(&W2+1) SETB (1)
.ENTLP   AIF   (&R1 EQ &#TESRET(1)).ENTEND
&R1      SETA  &R1+1
&R2      SETA  &R2+1
         AIF   (&R1 LE 15).R1OK
&R1      SETA  0
.R1OK    AIF   (&R2 LE 16).R2OK
&R2      SETA  1
.R2OK    ANOP
&RG(&R2) SETC  '&@&R1'
         AGO   .ENTLP
.ENTEND  ANOP
&RG(&R2) SETC  '&REGNME'
         AGO   .RLP
.REGERR  AIF   (&#TESRET(1) GE 0 OR &#TESRET(1) LT 0).REGVALU
         MNOTE 0,'THE ABOVE ERROR IS NOT DUE TO A BUG IN THE MACRO.'
         MNOTE 8,'THE VALUE OF "&REGNME" IS NOT DETERMINABLE.'
         MEXIT
.REGVALU AIF   (&#TESRET(1) GE 0 AND &#TESRET(1) LE 15).REGOK
         MNOTE 8,'THE VALUE OF "&REGNME" IS OUTSIDE THE RANGE OF 0 ... *
               15'
         MEXIT
.REGOK   AIF   (&ERRCODE EQ 1).REGOK1
         AGO   .REGOK2
.RFIN    AIF   (NOT &#ENTPLI).RGOK
         AIF   (NOT &RSW(1)).RG0OK
         MNOTE 4,'&RG(3) NEEDED BY THE EXIT LINKAGE - NOT RESTORED.'
.RG0OK   AIF   (NOT &RSW(2)).RG1OK
         MNOTE 4,'&RG(4) NEEDED BY THE EXIT LINKAGE - NOT RESTORED.'
.RG1OK   ANOP
&RG(3)   SETC  ''
&RG(4)   SETC  ''
.RGOK    ANOP
.*
&RG(16)  SETC  ''
.*
         AIF   (K'&RC EQ 0).NORC
&RG2SAVE SETC  '&RG(2)'
&RG(2)   SETC  ''
         AIF   ('&RG2SAVE' NE '').RG2SOK
&RG2SAVE SETC  '&@.15'
.RG2SOK  ANOP
.*
         AIF   (NOT &RSW(16)).NOPRBLM
         MNOTE 4,'&RG2SAVE SET TO THE RETURN CODE - NOT RESTORED.'
.NOPRBLM ANOP
.*
         AIF   ('&RC' EQ '&RC(1)').RCNTRG
         #TEST REGS=&RC(1)
         AIF   (&#TESERR NE 0).LOADRC
         AIF   ('&#TESRET(1)' NE '13').RCOK
         MNOTE 4,'"RC=&RC" IS ILLOGICAL.'
.RCOK    AIF   ('&#TESRET(1)' EQ '15').NORC
.LOADRC  AIF   ('&RG(1)' EQ '' OR '&RG(3)' EQ '' OR &#ENTPLI).RCLR
&RCST    SETB  (1)
         AGO   .NORC
.RCLR    ANOP
&LNME    LR    &@.15,&RC(1)     LOAD THE RETURN CODE
&LNME    SETC  ''
         AGO   .NORC
.RCNTRG  ANOP
&RCLA    SETB  (1)
         AIF   ('&RG(3)' EQ '' OR '&RG(1)' EQ '').NORC
&RG(2)   SETC  '&RG2SAVE'
.NORC    ANOP
.*
         AIF   (NOT &#ENTPLI).NOTPLI2
&LNME    LR    &@.0,&@.13          COPY OUR DSA POINTER
&LNME    SETC  ''
.NOTPLI2 ANOP
.*
         AIF   (NOT &#ENTRNT OR '&RG(4)' EQ '').NOLRR1
&LNME    LR    &@.1,&@.13          GET SAVE AREA ADDRESS FOR FREEMAIN
&LNME    SETC  ''
.NOLRR1  ANOP
.*
&LNME    L     &@.13,4(,&@.13)     POINT TO THE HIGHER SAVE AREA
         AIF   (NOT &RCST).NORCST
         ST    &RC(1),16(,&@.13)   STORE THE RETURN CODE FOR LATER
&RG(2)   SETC  '&RG2SAVE'
.NORCST  ANOP
.*
         AIF   (NOT &#ENTRNT).NTRENT
         AIF   (NOT &RCLA).RG2OK
&RG(2)   SETC  'X'
         AIF   ('&RG(1)&RG(3)' NE '').RG2OK
&RG(2)   SETC  ''
.RG2OK   ANOP
&RG4SAVE SETC  '&RG(4)'
&RG5SAVE SETC  '&RG(5)'
&RG(5)   SETC  'X'
&C1      SETA  0
.STMLP   AIF   (&C1 GE 4).STMEND
&C1      SETA  &C1+1
         AIF   ('&RG(&C1)' NE '').STMLP
&R1      SETA  &C1+13-(&C1+13)/16*16
&R2      SETA  &R1-1
&W1      SETA  &C1*4+8
.STMLP2  ANOP
&R2      SETA  &R2+1
         AIF   (&R2 LE 15).STMR2OK
&R2      SETA  0
.STMR2OK ANOP
&RG(&C1) SETC  '&@&R2'
&C1      SETA  &C1+1
         AIF   ('&RG(&C1)' EQ '').STMLP2
         AIF   (&R1 EQ &R2).ST
         STM   &@&R1,&@&R2,&W1.(&@.13) SAVE AGAINST FREEMAIN
         AGO   .STMLP
.ST      ST    &@&R1,&W1.(,&@.13)  SAVE AGAINST FREEMAIN
         AGO   .STMLP
.STMEND  ANOP
&RG(5)   SETC  '&RG5SAVE'
.GTR1M   AIF   ('&RG4SAVE' NE '').NOGTR1
         L     &@.1,8(,&@.13)      GET SAVE AREA ADDRESS FOR FREEMAIN
.NOGTR1  MNOTE '         FREEMAIN R,LV=&#ENTSIZ,A=(1),SP=&#ENTSP'
         FREEMAIN R,LV=&#ENTSIZ,A=(1),SP=&#ENTSP
.NTRENT  ANOP
.*
&C1      SETA  0
.LMLP    AIF   (&C1 GE 16).SETRCM
&C1      SETA  &C1+1
         AIF   ('&RG(&C1)' EQ '').LMLP
&R1      SETA  &C1
&W1      SETA  &C1*4+8
.LMLP2   ANOP
&C1      SETA  &C1+1
         AIF   ('&RG(&C1)' NE '').LMLP2
         AIF   (&R1 EQ &C1-1).L
         LM    &RG(&R1),&RG(&C1-1),&W1.(&@.13) RESTORE THE REGISTERS
         AGO   .LMLP
.L       L     &RG(&R1),&W1.(,&@.13) RESTORE THE REGISTER
         AGO   .LMLP
.SETRCM  ANOP
.*
         AIF   (NOT &RCLA).RETURN
         AIF   ('&RC' EQ '0').SR
         LA    &@.15,&RC           GET THE RETURN CODE
         AGO   .RETURN
.SR      SLR   &@.15,&@.15         ZERO THE RETURN CODE
.RETURN  ANOP
.*
         AIF   (NOT &#ENTPLI).NOTPLI3
         BASR  &@.1,&@.14          RETURN TO CALLER
         MEXIT
.NOTPLI3 ANOP
.*
         MVI   12(&@.13),X'FF'     SIGNEL RETURN MADE
         BR    &@.14               RETURN
.END     MEND
         MACRO
&NME     #PUT  &MSG,&PFIX=,&SUBAD=,&MF=
.*
.*
.*
.* LAST CHANGE DATE - OCTOBER 18, 1983
.*                  - MAILING ADDRESS CHANGE
.*
.* LAST CHANGE DATE - APRIL 21, 1981
.*                  - MACRO NAME CHANGED FROM $PUT TO #PUT.
.*
.* LAST CHANGE DATE - APRIL 20, 1981
.*                  - "#REGS GEN=NO" SUPPORT ADDED.
.*
.* LAST CHANGE DATE - JULY 18, 1980
.*                  - INDIRECT ADDRESSING IS NOW INDICATED BY A
.*                    TRAILING PERCENT SIGN (%) RATHER THAN A LEADING
.*                    ONE.
.*
.* LAST CHANGE DATE - JANUARY 12, 1977
.*                  - HANDLING OF THE SUBAD= OPERAND IS REWRITTEN.
.*                  - MAILING ADDRESS CHANGE.
.*
.* THIS MACRO WAS WRITTEN BY DAVID B. COLE. ANY QUESTIONS CONCERNING
.* IT MAY BE ADDRESSED TO:
.*       RR#2 BOX 712
.*       AFTON, VA. 22920
.*
         GBLA  &#TESERR
         GBLC  &#PUTSUB
         GBLC  &#TESRET(20)
         LCLA  &A1
         LCLC  &@,&C1,&N
         AIF   ('&SUBAD' EQ '').SUBOK
         AIF   ('&SUBAD(1)' NE '&SUBAD').SUBOK
&#PUTSUB SETC  '&SUBAD'
.SUBOK   AIF   ('&MF(1)' EQ 'INIT').MEND
&N       SETC  '&NME'
.*
&@       SETC  '&PFIX'
         AIF   ('&PFIX' NE '').PFIXOK
         #TEST PFIX=
&@       SETC  '&#TESRET(1)'
         AGO   .DONPFIX
.PFIXOK  #REGS &PFIX,GEN=NO
.DONPFIX ANOP
.*
         AIF   ('&MSG(1)' EQ '&MSG').NOTREG
         #TEST REGS=&MSG(1)
         AIF   (&#TESERR NE 0).LR
         AIF   (&#TESRET(1) EQ 1).BAS
.LR      ANOP
&N       LR    &@.1,&MSG(1)        --> MESSAGE LENGTH FIELD
&N       SETC  ''
         AGO   .BAS
.NOTREG  AIF   ('&MSG' EQ '').BAS
         AIF   ('&MSG'(K'&MSG,1) EQ '%').MSGINDR
&N       LA    &@.1,&MSG-1         --> MESSAGE LENGTH FIELD
         AGO   .MSGOK
.MSGINDR ANOP
&C1      SETC  '&MSG'(1,K'&MSG-1)
&N       L     &@.1,=A(&C1-1)      --> MESSAGE LENGTH FIELD
.MSGOK   ANOP
&N       SETC  ''
.BAS     AIF   ('&SUBAD(1)' NE '&SUBAD').BASR
         AIF   ('&#PUTSUB'(1,1) EQ '%').BASINDR
&N       BAS   &@.14,&#PUTSUB      GO DISPLAY THE MESSAGE
         AGO   .MEND
.BASR    ANOP
&N       BASR  &@.14,&SUBAD(1)     GO DISPLAY THE MESSAGE
         AGO   .MEND
.BASINDR ANOP
&A1      SETA  0
.LP1     ANOP
&A1      SETA  &A1+1
         AIF   ('&#PUTSUB'(1,&A1) NE '&#PUTSUB').LP1
&C1      SETC  '&#PUTSUB'(2,&A1-1)
&N       L     &@.15,=A(&C1)       --> MESSAGE PRINTING ROUTINE
         BASR  &@.14,&@.15         GO DISPLAY THE MESSAGE
.MEND    MEND
         MACRO
         #REGS &GEN=YES
.*
.*
.*
.* LAST CHANGE DATE - OCTOBER 18, 1983
.*                  - MAILING ADDRESS CHANGE
.*
.* LAST CHANGE DATE - APRIL 21, 1981
.*                  - MACRO NAME CHANGED FROM $REGS TO #REGS
.*
.* LAST CHANGE DATE - APRIL 20, 1981
.*                  - SUPPORT FOR THE "GEN={YESNO}" OPERAND IS ADDED.
.*
.* LAST CHANGE DATE - DECEMBER 5, 1977
.*                  - SINGLE REGISTER EQUATES NOW LINE UP CORRECTLY IN
.*                    THE LISTING.
.*
.* LAST CHANGE DATE - FEBRUARY 2, 1977
.*                  - MAILING ADDRESS CHANGE.
.*
.* LAST CHANGE DATE - APRIL 1, 1975
.*
.* THIS MACRO WAS WRITTEN BY DAVID B. COLE.  ANY QUESTIONS CONCERNING
.* IT MAY BE ADDRESSED TO:
.*       RR#2 BOX 712
.*       AFTON, VA. 22920
.*
.*
.*
.*   THE #REGS MACRO HAS TWO FUNCTIONS. ITS PRIMARY PURPOSE IS TO
.* PROVIDE A SIMPLE MEANS OF DEFINING SETS OF REGISTER NAME EQUATES.
.* ITS SECONDARY PURPOSE IS TO CREATE AN INTERNAL TABLE OF ALL REGISTER
.* NAMES COUPLED WITH THEIR NUMERIC VALUES. THIS TABLE IS THEN MADE
.* AVAILABLE TO CERTAIN OTHER MACROS (E.G. #ENTER AND #EXIT) SO THAT
.* THEY CAN DETERMINE (IF NECESSARY) THE VALUES OF ANY REGISTER NAMES
.* THAT MIGHT BE PASSED TO THEM AS OPERANDS AND SO THAT THEY CAN USE
.* REGISTER NAME EQUATES INSTEAD OF REGISTER NUMBERS IN THE CODE THAT
.* THEY GENERATE. THIS IS SO THAT ALL REFERENCES TO REGISTERS WILL BE
.* INDICATED IN THE ASSEMBLER'S CROSS REFERENCE LISTING.
.*   THE #REGS MACRO CAN BE USED ANY NUMBER OF TIMES IN AN ASSEMBLY.
.* EACH TIME THAT IT IS USED, IT CAN BE GIVEN ANYWHERE FROM 0 TO 35
.* POSITIONAL OPERANDS. EACH OPERAND CAN BE EITHER A SINGLE TERM OR A
.* SUB-LIST OF TWO TERMS.
.*   IF AN OPERAND IS A SUB-LIST OF TWO TERMS, THEN THE #REGS MACRO
.* TREATS IT AS A REQUEST TO DEFINE A SINGLE REGISTER NAME AND IT
.* GENERATES A STATEMENT OF THE FORM: " TERM1 EQU TERM2 ". THE FIRST
.* TERM MUST BE ANY VALID NAME NOT PREVIOUSLY DEFINED. THE SECOND TERM
.* MUST BE ANY SELF-DEFINING TERM OR ANY REGISTER NAME THAT HAS BEEN
.* PREVIOUSLY DEFINED BY THIS OR A PREVIOUS #REGS MACRO. IT SHOULD NOT
.* BE AN EXPRESSION, AND IT SHOULD NOT BE ANY NAME NOT PREVIOUSLY
.* DEFINED. THE VALUE OF THE SECOND TERM SHOULD FALL IN THE RANGE OF 0
.* THROUGH 15. IF THE SECOND TERM FITS THESE REQUIREMENTS, THEN THE
.* REGISTER NAME IS SAVED IN AN INTERNAL TABLE FOR USE BY OTHER MACROS.
.*   IF AN OPERAND IS ONLY A SINGLE TERM, THEN THE MACRO TREATS IT AS A
.* REQUEST TO DEFINE A FULL SET OF REGISTER NAME EQUATES WITH THE GIVEN
.* TERM USED AS THE REGISTER NAME PREFIX. AS AN EXAMPLE, ASSUME THAT
.* THE OPERAND IS "GPR". IN THIS CASE, THE #REGS MACRO WILL GENERATE
.* EQUATES DEFINING GPR0, GPR1, ---, GPR15 AND GPRA, GPRB, ---, GPRF
.* (EQUAVALENT TO GPR10, GPR11, ---, GPR15). IN ADDITION, THE GENERATED
.* REGISTER NAMES ARE SAVED IN AN INTERNAL TABLE FOR USE BY OTHER
.* MACROS.
.*   IF #REGS IS CALLED WITHOUT OPERANDS, THEN IT IS TREATED AS A
.* REQUEST TO GENERATE A FULL SET OF EQUATES USING "R" AS THE PREFIX.
.*
.*
.*
.* GEN={YESNO}    (DEFAULT IS GEN=YES)
.*       THIS CONTROLS WHETHER OR NOT THIS MACRO ACTUALLY GENERATES THE
.*       'EQU' STATEMENTS THAT CREATE THE DESIRED REGISTER NAMES. IF
.*       "GEN=NO" IS GIVEN, THEN PRESUMEDLY THE DESIRED NAMES ARE
.*       GENERATED ELSEWHERE. IN THIS CASE THE ONLY FUNCTION PERFORMED
.*       BY THIS MACRO IS TO UPDATE INTERNAL TABLES.
.*
.*
.*
.* INNER MACROS USED - #TEST
.*
         GBLA  &#REGVAL(255)
         GBLA  &#TESERR
         GBLC  &#REGNME(255)
         GBLC  &#TESRET(20)
         LCLA  &ARG,&CTR,&NEXT,&A1
         LCLB  &B1
         LCLC  &LPFX,&C1
&NEXT    SETA  0
.LP1     AIF   (&NEXT GE 255).END1
&NEXT    SETA  &NEXT+1
         AIF   ('&#REGNME(&NEXT)' NE '').LP1
&NEXT    SETA  &NEXT-1
.END1    ANOP
&ARG     SETA  0
.LP2     AIF   (&ARG GE N'&SYSLIST).DONE
&ARG     SETA  &ARG+1
         AIF   (N'&SYSLIST(&ARG) EQ 0).LP2
         AIF   (&NEXT LT 255).NOTFULL
         MNOTE 4,'THE REGISTER NAME SAVE TABLE IS FULL.'
         MNOTE 4,'THE MAXIMUM CAPACITY IS 255 ENTRIES.'
.NOTFULL ANOP
&C1      SETC  '&SYSLIST(&ARG,1)'
         AIF   (N'&SYSLIST(&ARG) GE 2).ONEREG
.NULL    ANOP
&B1      SETB  (1)
         #TEST PFIX=
&LPFX    SETC  '&#TESRET(1)'
         AIF   (&NEXT GE 255).NOSAVE1
&CTR     SETA  0
.LP2A    AIF   (&CTR GE &NEXT).PXSAVE
&CTR     SETA  &CTR+1
         AIF   (&#REGVAL(&CTR) LT 16 OR '&#REGNME(&CTR)' NE '&C1').LP2A
         AGO   .NOSAVE1
.PXSAVE  ANOP
&NEXT    SETA  &NEXT+1
&#REGNME(&NEXT) SETC '&C1'
&#REGVAL(&NEXT) SETA 16
.NOSAVE1 AIF   ('&GEN(1)'(1,1) NE 'Y').LP2
&CTR     SETA  0
.LP3     AIF   (&CTR GT 15).HEX
&C1&CTR  EQU   &LPFX&CTR
&CTR     SETA  &CTR+1
         AGO   .LP3
.HEX     ANOP
&C1.A    EQU   &C1.10
&C1.B    EQU   &C1.11
&C1.C    EQU   &C1.12
&C1.D    EQU   &C1.13
&C1.E    EQU   &C1.14
&C1.F    EQU   &C1.15
         AGO   .LP2
.ONEREG  ANOP
&B1      SETB  (1)
         AIF   (N'&SYSLIST(&ARG) EQ 2).NOXCESS
         MNOTE 4,'"&SYSLIST(&ARG)" CONTAINS EXCESS INFORMATION.'
         MNOTE 4,'THE EXCESS WILL BE IGNORED.'
.NOXCESS #TEST REGS=&SYSLIST(&ARG,2)
         AIF   (&#TESERR EQ 0).REGOK
         MNOTE 4,'THE VALUE OF "&SYSLIST(&ARG,2)" IS NOT DETERMINABLE.'
         AGO   .REGEQU
.REGOK   AIF   (&NEXT GE 255).REGEQU
&A1      SETA  &#TESRET(1)
&CTR     SETA  0
.LP3A    AIF   (&CTR GE &NEXT).RGSAVE
&CTR     SETA  &CTR+1
         AIF   (&#REGVAL(&CTR) NE &A1 OR '&#REGNME(&CTR)' NE '&C1').LP3*
               A
         AGO   .REGEQU
.RGSAVE  ANOP
&NEXT    SETA  &NEXT+1
&#REGNME(&NEXT) SETC '&C1'
&#REGVAL(&NEXT) SETA &A1
.REGEQU  AIF   ('&GEN(1)'(1,1) NE 'Y').LP2
&C1      EQU   &SYSLIST(&ARG,2)
         AGO   .LP2
.DONE    ANOP
&C1      SETC  'R'
         AIF   (NOT &B1).NULL
         MEND
         MACRO
&NME     #SEARCH &DUMMY,&PFIX=,&SVID=,&CMPRID=
.*
.*
.*
.* LAST CHANGE DATE - OCTOBER 18, 1983
.*                  - MAILING ADDRESS CHANGE
.*
.* LAST CHANGE DATE - SEPTEMBER 8, 1981
.*                  - THE PARAMETERIZATION OF THE SEARCH ROUTINE WAS
.*                    CHANGED FROM:
.*                       - R15 = L'LIST
.*                       - R0 = L'LIST ENTRY
.*                       - R1 --> SO-LIST
.*                    TO:
.*                       - R15 --> SO-LIST
.*                         R0 = L'LIST ENTRY
.*                         R1 --> EO-LIST
.*
.* LAST CHANGE DATE - APRIL 21, 1981
.*                  - MACRO NAME CHANGED FROM $SEARCH TO #SEARCH.
.*
.* LAST CHANGE DATE - APRIL 20, 1981
.*                  - "#REGS GEN=NO" SUPPORT ADDED.
.*
.* LAST CHANGE DATE - MARCH 12, 1980
.*                  - SUPPORT FOR AN EMPTY LIST HAS BEEN FIXED.
.*
.* LAST CHANGE DATE - SEPTEMBER 18, 1978
.*                  - IF THE LIST HAS MULTIPLE ENTRIES WITH THE SAME
.*                    KEY AS THE SEARCH OBJECT, THEN THIS ROUTINE NOW
.*                    RETURNS THE LAST (SEQUENTIALLY) SUCH LIST ENTRY.
.*
.* LAST CHANGE DATE - FEBRUARY 2, 1977
.*                  - MAILING ADDRESS CHANGE
.*
.* LAST CHANGE DATE - OCTOBER 28, 1975
.*
.* THIS MACRO WAS WRITTEN BY DAVID B. COLE.  ANY QUESTIONS CONCERNING
.* IT MAY BE ADDRESSED TO:
.*       RR#2 BOX 712
.*       AFTON, VA. 22920
.*
.*
.*
.*   THIS MACRO GENERATES A SUBROUTINE THAT SEARCHES A SORTED LIST.  A
.* BINARY SEARCH METHOD IS USED.
.*
.*   THE SEARCH SUBROUTINE REQUIRES THE FOLLOWING INPUTS:
.*       - R14 POINTS TO THE RETURN ADDRESS;
.*       - R15 POINTS TO THE START OF THE LIST TO BE SEARCHED;
.*       - R0 CONTAINS THE LENGTH (IN BYTES) OF EACH ENTRY IN
.*         THE LIST;
.*       - R1 POINTS PAST THE END OF THE LIST.
.*
.*   ON OUTPUT THE CONDITION CODE AND R1 ARE SET AS FOLLOWS:
.*       - CC=0 (EQUAL) MEANS THAT THE SEARCH OBJECT WAS FOUND. R1
.*         POINTS TO IT. IF THE LIST CONTAINS MORE THAN ONE OBJECT
.*         HAVING THE SAME KEY AS THE SEARCH OBJECT, THEN R1 POINTS TO
.*         THE LAST SUCH OBJECT IN THE LIST.
.*       - CC=2 (HIGH) MEANS THAT THE SEARCH OBJECT WAS NOT FOUND. R1
.*         POINTS TO WHERE IT SHOULD BE INSERTED.
.* ALL OTHER REGISTERS ARE RESTORED.
.*
.*   THE SEARCH SUBROUTINE IS NOT REENTRANT, BUT IT IS SERIALLY
.* REUSABLE.
.*
.*   THE NAME FIELD
.* THIS FIELD IS OPTIONAL. IT CAN BE USED TO DEFINE BOTH THE NAME OF
.* THE SUBROUTINE AND THE PREFIX USED IN ALL GENERATED STATEMENT
.* LABELS. IF OMITTED, THEN THE CHARACTERS "SRCH" WILL BE USED. IF
.* GIVEN, THEN NO MORE THAN FOUR CHARACTERS SHOULD BE SPECIFIED.
.*
.*   THE PFIX= OPERAND
.* THE #SEARCH MACRO ATTEMPTS TO USE REGISTER EQUATES IN ITS EXPANSION
.* WHEN REFERING TO REGISTERS. THIS IS SO THAT THE USE OF THE REGISTERS
.* WILL BE INDICATED IN THE CROSS REFERENCE LISTING. THE PFIX= OPERAND
.* CAN BE USED TO CONTROL THE SET OF EQUATES USED. FOR EXAMPLE, IF
.* "PFIX=GPR" IS SPECIFIED, THEN "GPR1" WILL BE USED WHENEVER THE
.* EXPANSION REFERS TO REGISTER 1.
.*   IF THE PFIX= OPERAND IS OMITTED, THEN THE SET OF EQUATES DEFINED
.* BY THE FIRST PRIOR #REGS MACRO WILL BE USED. IF THERE IS NO PRIOR
.* #REGS MACRO, THEN NO EQUATES WILL BE USED.
.*
.*   THE CMPRID= OPERAND
.* THIS OPERAND IS REQUIRED. IT INDICATES THE ADDRESS OF A SUBROUTINE
.* TO BE USED BY THE SEARCH ROUTINE FOR COMPARING THE SEARCH OBJECT
.* WITH A LIST ENTRY. EITHER A STATEMENT LABEL OR A REGISTER MAY BE
.* SPECIFIED.
.*   THE SPECIFIED COMPARISON ROUTINE IS GIVEN THE FOLLOWING INPUTS:
.*       - R14 POINTS TO THE RETURN ADDRESS.
.*       - R15 POINTS TO THE LIST ENTRY TO BE COMPARED AGAINST THE
.*         SEARCH OBJECT.
.*       - R0 THROUGH R6 CONTAIN DATA ON WHICH THE SEARCH ROUTINE IS
.*         DEPENDANT.
.*       - R7 THROUGH R13 CONTAIN WHAT WAS IN THEM PRIOR TO THE START
.*         OF THE SEARCH ROUTINE.
.* ON OUTPUT THE COMPARISON ROUTINE MUST PROVIDE THE FOLLOWING:
.*       - R14 THROUGH R6 MAY NOT BE ALTERED BY THE COMPARISON
.*         ROUTINE.
.*       - R7 THROUGH R13 (EXCEPT THOSE THAT ARE USED AS
.*         PROGRAM BASES) MAY BE USED FREELY SINCE THE SEARCH ROUTINE
.*         RESTORES ALL REGISTERS WHEN IT IS FINISHED.
.*       - THE CONDITION CODE MUST BE SET AS FOLLOWS:
.*             - CC=0 (EQUAL) MEANS THAT THE SEARCH OBJECT MATCHES THE
.*               CURRENT LIST ENTRY.
.*             - CC=1 (LOW) MEANS THAT THE SEARCH OBJECT IS LOWER THAN
.*               THE CURRENT LIST ENTRY.
.*             - CC=2 (HIGH) MEANS THAT THE SEARCH OBJECT IS HIGHER
.*               THAN THE CURRENT LIST ENTRY.
.*
.*   THE SVID= OPERAND
.* USE THIS OPERAND TO SPECIFY THE NAME OF A 16-WORD REGISTER SAVE
.* AREA. IF OMITTED, THEN THE MACRO WILL GENERATE A LOCAL SAVE AREA.
.*
.* INNER MACROS USED - #REGS #TEST #DIE
.*
.*
.*
         GBLA  &#TESERR
         GBLC  &#TESRET(20)
         LCLC  &N,&R,&SAVEA
&N       SETC  'SRCH'
         AIF   (K'&NME EQ 0).GOTNME
&N       SETC  '&NME'
.GOTNME  ANOP
.*
&R       SETC  '&PFIX'
         AIF   (K'&PFIX NE 0).GOTPFIX
         #TEST PFIX=
&R       SETC  '&#TESRET(1)'
         AGO   .DONPFIX
.GOTPFIX #REGS &PFIX,GEN=NO
.DONPFIX ANOP
.*
* BINARY SEARCH ROUTINE
*        INPUTS:
*        - R14 POINTS TO THE RETURN ADDRESS
*        - R15 POINTS TO THE START OF THE LIST TO BE SEARCHED
*        - R0 CONTAINS THE LENGTH OF EACH LIST ENTRY (IN BYTES)
*        - R1 POINTS PAST THE END OF THE LIST
         SPACE 1
* COMPARE ROUTINE INPUTS:
*        - R15 POINTS TO THE LIST ENTRY TO BE COMPARED AGAINST THE
*          SEARCH OBJECT.
*        - R14 POINTS TO THE RETURN ADDRESS.
*        - R14 THROUGH R6 CONTAIN DATA CRITICAL TO THE SEARCH ROUTINE.
*          THEY MUST NOT BE ALTERED BY THE COMPARE ROUTINE.
         SPACE 1
* COMPARE ROUTINE OUTPUTS:
*        - CC=0 (EQUAL) MEANS THAT THE SEARCH OBJECT MATCHES THE
*          CURRENT LIST ENTRY.
*        - CC=1 (LOW) MEANS THAT THE SEARCH OBJECT IS LOWER THAN THE
*          CURRENT LIST ENTRY.
*        - CC=2 (HIGH) MEANS THAT THE SEARCH OBJECT IS HIGHER THAN THE
*          CURRENT LIST ENTRY.
&SAVEA   SETC  '&N.SAVE'
         AIF   (K'&SVID EQ 0).GOTSAVE
&SAVEA   SETC  '&SVID'
.GOTSAVE ANOP
&N       STM   &R.14,&R.13,&SAVEA  SAVE ALL WORK REGISTERS
         AIF   ('&CMPRID' EQ '&CMPRID(1)').NOCMPR1
         #TEST REGS=&CMPRID(1)
         AIF   ( &#TESERR EQ 0 AND '&#TESRET(1)' EQ '2').NOCMPR2
         LR    &R.2,&CMPRID(1)     POINT TO COMPARISON ROUTINE
         AGO   .NOCMPR2
.NOCMPR1 LA    &R.2,&CMPRID        POINT TO COMPARISON ROUTINE
.NOCMPR2 ANOP
         LNR   &R.15,&R.15         GET NEGATIVE SO-LIST
         AR    &R.15,&R.1          GET L'LIST
         SR    &R.1,&R.15          GET SO-LIST
         XR    &R.14,&R.14         CLEAR FOR DIVIDE
         DR    &R.14,&R.0          GET LIST'S ENTRY COUNT
         LTR   &R.4,&R.14          GET INITIAL SEARCH INDEX; WAS THE
*                                  ABOVE DIVIDE EVEN?
         #DIE  NZ,'SEARCH LIST SIZE INCOMPATIBLE WITH LIST ENTRY SIZE'
         LTR   &R.3,&R.15          YES, GET LIST ENTRY COUNT; EMPTY?
         BZ    &N.NULL             YES, GO RETURN "NOT FOUND"
         LA    &R.5,1(,&R.3)       NO, GET INITIAL WIDTH; INSURE ^0
         LA    &R.6,1              GET COMBO OF "1" AND DIRECTION FLAG
         SPACE 1
&N.UP    LCR   &R.6,&R.6           COMPLEMENT FOR TEST
         CR    &R.5,&R.6           WAS PREV WIDTH 1 AND DIRECTION DOWN?
         BE    &N.NFND             YES, SEARCH OBJECT NOT FOUND
&N.UP2   LPR   &R.6,&R.6           NO, SET DIRECTION UP
         AR    &R.5,&R.6           FORCE WIDTH TO ROUND UP UPON DIVIDE
         SRL   &R.5,1              CUT WIDTH IN HALF (ROUND UP)
         AR    &R.4,&R.5           ADVANCE THE SEARCH INDEX
         B     &N.CMPR             PROCEED
         SPACE 1
&N.DOWN  LNR   &R.6,&R.6           SET DIRECTION DOWN
         SR    &R.5,&R.6           FORCE WIDTH TO ROUND UP UPON DIVIDE
         SRL   &R.5,1              CUT WIDTH IN HALF (ROUND UP)
         SR    &R.4,&R.5           RETREAT THE SEARCH INDEX
         SPACE 1
&N.CMPR  BM    &N.UP               SCAN UP IF BELOW THE LIST
         CR    &R.4,&R.3           ABOVE THE LIST?
         BNL   &N.DOWN             YES, MUST SCAN DOWN
         SPACE 1
         LR    &R.15,&R.4          GET CURRENT POSITION INDEX
         MR    &R.14,&R.0          CNVRT TO LIST DISPLACEMENT
         AR    &R.15,&R.1          CNVRT TO ABSOLUTE ENTRY POINTER
         BASR  &R.14,&R.2          LINK TO COMPARISON ROUTINE
         BL    &N.DOWN             TOO HIGH; MUST MOVE DOWN
         BH    &N.UP               TOO LOW; MUST MOVE UP
         SPACE 1
         LCR   &R.6,&R.6           A HIT; COMPLEMENT FOR TEST
         CR    &R.5,&R.6           WAS PREVIOUS WIDTH 1 AND DOWN?
         BE    &N.FND              YES, FOUND LAST OF DUPLICATE KEYS
         LA    &R.5,4              NO, SET TO FWD SCAN PAST DUP KEYS
         B     &N.UP2              LOOP TO SKIP PAST DUP KEYS
         SPACE 1
&N.NFND  LA    &R.15,1(,&R.4)      NOT FOUND; GET INDEX TO INSERT POINT
         MR    &R.14,&R.0          CNVRT TO DISPLACEMENT
&N.NULL  AR    &R.15,&R.1          CNVRT TO ABSOLUTE
         CLI   *,0                 SET CC^=0
&N.FND   ST    &R.15,&SAVEA+12     PRESERVE ENTRY PTR IN R1 SLOT
         LM    &R.14,&R.13,&SAVEA  RESTORE REGISTERS
         BR    &R.14               RETURN TO CALLER WITH CC SET
         AIF   (K'&SVID NE 0).MEND
         SPACE 1
&N.SAVE  DC    16A(0)              REGISTER SAVE AREA
.MEND    MEND
         MACRO
&N       #TEST &DCODE=OMITTED,&MEXCL=,&NUM=OMITTED,                    *
               &PFIX=OMITTED,&REGS=,&SIZE=,&GEN=
.*
.*
.*
.* LAST CHANGE DATE - OCTOBER 18, 1983
.*                  - MAILING ADDRESS CHANGE
.*
.* LAST CHANGE DATE - MARCH 16, 1983
.*                  - COMMENTARY CHANGES
.*                  - MAILING ADDRESS CHANGE
.*
.* LAST CHANGE DATE - DECEMBER 4, 1981
.*                  - THE "SIZE=" FUNCTION HAS BEEN ENHANCED
.*                    TO INCLUDE SUPPORT FOR THE "NE"
.*                    RELATION.
.*
.* LAST CHANGE DATE - APRIL 21, 1981
.*                  - MACRO NAME CHANGED FROM $TEST TO #TEST
.*
.* LAST CHANGE DATE - APRIL 15, 1981
.*                  - THE "NUM" FUNCTION NO LONGER ISSUES AN
.*                    ERROR MESSAGE WHEN IT ENCOUNTERS A
.*                    NON-DIGIT. IT ONLY SETS A RETURN CODE
.*                    OF 16 IN &#TESERR.
.*
.* LAST CHANGE DATE - APRIL 24, 1978
.*                    THE GEN=EBCDIC FUNCTION HAS BEEN ADDED
.*
.* LAST CHANGE DATE - FEBRUARY 2, 1977
.*                  - MAILING ADDRESS CHANGE.
.*
.* LAST CHANGE DATE - SEPTEMBER 10, 1976
.*                    THE &SIZE= OPERAND SUPPORT IS CHANGED
.*                    TO REQUIRE THREE SUB-OPERANDS WITH THE
.*                    SECOND SPECIFYING ONE OF THE RELATION
.*                    OPERATIONS: LT, LE, EQ, GE, OR GT.
.*                    NOTE, THIS IS NOT COMPATIBLE WITH THE
.*                    PREVIOUS IMPLEMENTATION.
.*
.* LAST CHANGE DATE - FEBRUARY 10, 1976
.*
.* THIS MACRO WAS WRITTEN BY DAVID B. COLE.  ANY QUESTIONS
.* CONCERNING IT MAY BE ADDRESSED TO:
.*       RR#2 BOX 712
.*       AFTON, VA. 22920
.*
.*
.*
.*                                 GENERAL INFORMATION
.*   THE #TEST MACRO IS INTENDED TO BE USED AS AN INNER
.* MACRO. IT PERFORMS A NUMBER OF DIFFERENT TESTS AND
.* MANIPULATIONS WHICH ARE WHOLELY INDEPENDANT OF EACH OTHER.
.* FOR EACH OF THESE FUNCTIONS, INPUT MIGHT BE SPECIFIED
.* EITHER VIA MACRO OPERANDS OR BOTH MACRO OPERANDS AND GLOBAL
.* SYMBOLS (DEPENDING UPON THE FUNCTION). OUTPUT IS USUALLY
.* COMMUNICATED VIA THE GLOBAL SYMBOLS &#TESERR AND &#TESRET.
.*   &#TESERR IS A SCALER SETA SYMBOL WHICH IS USED IN A
.* MANNER SIMILAR TO A PROGRAM'S COMPLETION CODE TO
.* COMMUNICATE A GROSS INDICATION OF AN UNUSUAL OR ERROR
.* CONDITION. IF UPON RETURN FROM #TEST &#TESERR EQUALS ZERO,
.* THEN THE MACRO FUNCTIONED "OK"; OTHERWISE, THE VALUE OF
.* &#TESERR VARIES DIRECTLY WITH THE SERIOUSNESS OF THE
.* UNUSUAL OR ERROR CONDITION, AND IT IS ALWAYS SET TO
.* REFLECT THE MOST SERIOUS CONDITION ENCOUNTERED DURING A
.* PARTICULAR INVOCATION OF THE #TEST MACRO.
.*   &#TESRET IS A SETC ARRAY WHICH IS USED TO CONTAIN
.* RETURN VALUES FOR THOSE FUNCTIONS FOR WHICH RETURN
.* VALUES ARE APPROPIATE. EACH ELEMENT OF THE ARRAY HOLDS ONE
.* RETURN VALUE. ONLY AS MANY ELEMENTS ARE USED AS ARE
.* NEEDED. THOSE ELEMENTS USED ALWAYS START WITH ELEMENT
.* NUMBER ONE. IF TWO OR MORE TEST FUNCTIONS ARE INVOKED ON
.* A SINGLE CALL AND IF EACH OF THEM GENERATE ONE OR MORE
.* RETURN VALUES, THEN THE FIRST FUNCTION PROCESSED WILL USE
.* THE LOW ORDER ENTRIES IN &#TESRET. THE NEXT FUNCTION WILL
.* USE THE NEXT ENTRIES, ETC. THE VARIOUS TEST FUNCTIONS
.* WILL ALWAYS BE PROCESSED IN THE SAME ORDER WITH WHICH
.* THEY APPEAR BELOW.
.*
.*
.*
.* INNER MACROS USED - NONE
.*
         GBLA  &#REGVAL(255),&#TESERR
         GBLC  &#REGNME(255),&#TESRET(20)
         GBLC  &#EBCDIC(256)
         LCLA  &CTR,&RETPTR,&P,&L,&K,&A1,&A2,&RV(22)
         LCLB  &MESW
         LCLC  &RN(22),&BASE
&#TESERR SETA  0
.*
.*
.*
.*                                 THE "DCODE" FUNCTION
.*   THIS FUNCTION WAS WRITTEN BECAUSE THE MACRO LANGUAGE
.* DOES NOT SUPPORT THE DECODING OF "SUB-SUB-LIST" NOTATION.
.*   THE INPUT IS COMMUNICATED VIA THE "DCODE=" OPERAND AS A
.* CHARACTER STRING TO BE DECODED. THIS STRING MUST BE
.* EITHER NULL, UNPARENTHESIZED, OR A PARENTHESIZED LIST OF
.* ELEMENTS SEPERATED FROM EACH OTHER BY COMMAS. THE
.* ELEMENTS THEMSELVES MAY BE NULL.
.*   FOR A STRING OF N ELEMENTS, THE OUTPUT CONSISTS OF N+1
.* ENTRIES IN &#TESRET. THE FIRST ENTRY CONTAINS THE VALUE
.* N. THE REMAINING ENTRIES CONTAIN EACH OF THE ELEMENTS
.* EXTRACTED FROM THE ORIGINAL STRING. IF THE ORIGINAL
.* STRING IS NULL, THEN IT IS TREATED AS A SUB-LIST
.* CONTAINING ZERO ELEMENTS. IF THE STRING IS
.* UNPARENTHESIZED, THEN IT IS TREATED AS A SUB-LIST
.* CONTAINING A SINGLE ELEMENT - NAMELY, ITSELF.
.*   THE DCODE FUNCTION WILL NOT PROPERLY HANDLE THE
.* FOLLOWING CONDITIONS:
.*       A.) A SUB-LIST ELEMENT LONGER THAN EIGHT CHARACTERS;
.*       B.) A SUB-LIST ELEMENT THAT ITSELF CONSISTS OF A
.*           SUB-LIST;
.*       C.) A SUB-LIST CONTAINING MORE THAN NINETEEN
.*           ELEMENTS.
.*
.DCODE   AIF   ('&DCODE' EQ 'OMITTED').DCODEND
&RETPTR  SETA  &RETPTR+1
&CTR     SETA  0
         AIF   (K'&DCODE EQ 0).DCDFIN
         AIF   ('&DCODE'(1,1) EQ '(').DCDSLST
&CTR     SETA  1
&#TESRET(&RETPTR+1) SETC '&DCODE'
         AGO   .DCDFIN
.DCDSLST ANOP
&K       SETA  K'&DCODE
         AIF   ('&DCODE'(&K,1) EQ ')').DCDOK
         MNOTE 8,'"&DCODE" HAS INVALID SUBLIST SYNTAX.'
&#TESERR SETA  16
         AGO   .DCDFIN
.DCDOK   ANOP
&P       SETA  1
&L       SETA  0
.DCDLP1  ANOP
&P       SETA  &P+&L+1
&L       SETA  0-1
&CTR     SETA  &CTR+1
&#TESRET(&RETPTR+&CTR) SETC ''
.DCDLP2  ANOP
&L       SETA  &L+1
         AIF   ('&DCODE'(&P+&L,1) NE ',' AND &P+&L NE &K).DCDLP2
         AIF   (&L EQ 0).DCDLPET
&#TESRET(&RETPTR+&CTR) SETC '&DCODE'(&P,&L)
         AIF   ('&#TESRET(&RETPTR+&CTR)' EQ '&DCODE'(&P,&L)).DCDLPET
         MNOTE 8,'ERROR - THE FOLLOWING TRUNCATION HAS OCCURED:'
         MNOTE *,'        &DCODE'
         MNOTE *,'        &#TESRET(&RETPTR+&CTR)'
.DCDLPET AIF   (&P+&L NE &K).DCDLP1
.DCDFIN  ANOP
&#TESRET(&RETPTR) SETC '&CTR'
&RETPTR  SETA  &RETPTR+&CTR
.DCODEND ANOP
.*
.*
.*
.*                            THE "MEXCL" FUNCTION
.*   THIS FUNCTION CAN BE USED TO DETERMINE IF TWO OR MORE
.* MUTUALLY EXCLUSIVE OPERANDS (OR WHATEVER) HAVE BEEN
.* PASSED TO THE CALLING MACRO.
.*   THE INPUT IS COMMUNICATED VIA THE "MEXCL=" OPERAND AS A
.* SUB-LIST WITH ANY NUMBER OF ENTRIES. IF THE MEXCL
.* FUNCTION FINDS MORE THAN ONE NON-NULL ENTRY IN THE
.* SUB-LIST, THEN IT ISSUES A SEVERITY 8 ERROR MESSAGE, AND
.* IT SETS &#TESERR TO A VALUE OF 16.
.*
.MEXCL   AIF   (N'&MEXCL LT 2).MEXCEND
&CTR     SETA  0
.MELP    AIF   (&CTR EQ N'&MEXCL).MEXCEND
&CTR     SETA  &CTR+1
         AIF   (K'&MEXCL(&CTR) EQ 0).MELP
         AIF   (&MESW EQ 1).MEERR
&MESW    SETB  (1)
         AGO   .MELP
.MEERR   MNOTE 8,'ERROR - MUTUALLY EXCLUSIVE OPERANDS HAVE BEEN USED:'
         MNOTE *,'        &MEXCL'
&#TESERR SETA  16
.MEXCEND ANOP
.*
.*
.*
.*                            THE "NUM" FUNCTION
.*   THIS FUNCTION CAN BE USED TO DETERMINE WHETHER OR NOT A
.* GIVEN VALUE CONSISTS ENTIRELY OF DIGITS.
.*   THE INPUT IS COMMUNICATED VIA THE "NUM=" OPERAND. IF
.* THE NUM FUNCTION FINDS THAT ANY CHARACTER IN THE GIVEN
.* STRING IS NOT A DIGIT, THEN IT SETS &#TESERR TO A VALUE
.* OF 16.
.*
.NUM     AIF   ('&NUM' EQ 'OMITTED').NUMEND
         AIF   (K'&NUM EQ 0).NUMERR
&CTR     SETA  0
.NUMLP   AIF   (&CTR EQ K'&NUM).NUMEND
&CTR     SETA  &CTR+1
         AIF   ('&NUM'(&CTR,1) LT '0').NUMERR
         AIF   ('&NUM'(&CTR,1) LE '9').NUMLP
.NUMERR  ANOP
&#TESERR SETA  16
.NUMEND  ANOP
.*
.*
.*
.*                            THE "PFIX" FUNCTION
.*   THIS FUNCTION CAN BE USED TO DETERMINE THE VALIDITY OF
.* A GIVEN REGISTER NAME PREFIX (E.G. "R" IN "R15").
.*   THE INPUT CONSISTS OF A REGISTER NAME PREFIX
.* COMMUNICATED VIA THE "PFIX=" OPERAND AND A TABLE OF VALID
.* REGISTER NAME PREFIXES GENERATED VIA PRIOR #REGS MACROS
.* AND CONTAINED IN THE &#REGNME AND &#REGVAL GLOBAL
.* SYMBOLS. IF THE GIVEN PREFIX IS NULL, THEN A DEFAULT IS
.* USED. IF THE GIVEN PREFIX IS INVALID, THEN A SEVERITY 4
.* ERROR MESSAGE IS ISSUED AND A DEFAULT PREFIX IS USED. THE
.* DEFAULT IS EITHER THE FIRST PREFIX DEFINED VIA A PRIOR
.* #REGS MACRO OR NULL IF NO PRIOR #REGS MACRO HAS DEFINED
.* ANY PREFIXES.
.*   FOR OUTPUT, THE NEXT AVAILABLE &#TESRET ENTRY IS FILLED
.* WITH EITHER THE GIVEN PREFIX OR THE DEFAULT PREFIX.
.*
.PFIX    AIF   ('&PFIX' EQ 'OMITTED').PFIXEND
&RETPTR  SETA  &RETPTR+1
&#TESRET(&RETPTR) SETC ''
&CTR     SETA  0
.PFXLP1  AIF   (&CTR GE 255).PFXGDEF
&CTR     SETA  &CTR+1
         AIF   ('&#REGNME(&CTR)' EQ '').PFXGDEF
         AIF   (&#REGVAL(&CTR) LE 15).PFXLP1
&#TESRET(&RETPTR) SETC '&#REGNME(&CTR)'
.PFXGDEF AIF   (K'&PFIX EQ 0).PFIXEND
&CTR     SETA  &CTR-1
.PFXLP2  AIF   (&CTR GE 255).PFXERR
&CTR     SETA  &CTR+1
         AIF   ('&#REGNME(&CTR)' EQ '').PFXERR
         AIF   (&#REGVAL(&CTR) LE 15).PFXLP2
         AIF   ('&PFIX' NE '&#REGNME(&CTR)').PFXLP2
&#TESRET(&RETPTR) SETC '&PFIX'
         AGO   .PFIXEND
.PFXERR  MNOTE 4,'WARNING - "&PFIX" HAS NOT BEEN PREDEFINED.'
         MNOTE *,'          A DEFAULT VALUE WILL BE USED.'
         MNOTE *,'          CHECK YOUR USAGE OF THE #REGS'
         MNOTE *,'          MACRO.'
.PFIXEND ANOP
.*
.*
.*
.*                            THE "REGS" FUNCTION
.*   THIS FUNCTION CAN BE USED TO CONVERT A CERTAIN CLASS OF
.* REGISTER NAMES TO THEIR CORRESPONDING NUMERIC VALUES. IN
.* ORDER FOR A GIVEN NAME TO BE CONVERTED, IT MUST BE EITHER
.* A SELF-DEFINING NUMERIC OR A NAME THAT HAS BEEN DEFINED
.* VIA A PRIOR #REGS MACRO. THE PURPOSE OF THIS FUNCTION IS
.* TO PROVIDE ARITHMETICLY MANIPULATABLE REGISTER NUMBERS.
.*   THE INPUT CONSISTS OF A SUB-LIST OF REGISTER NAMES
.* COMMUNICATED VIA THE "REGS=" OPERAND AND A TABLE OF VALID
.* REGISTER NAME PREFIXES GENERATED VIA PRIOR #REGS MACROS
.* AND COMMUNICATED VIA THE &#REGNME AND &#REGVAL GLOBAL
.* SYMBOLS.
.*   FOR A SUB-LIST OF N REGISTER NAMES, THE OUTPUT CONSISTS
.* OF N ENTRIES IN &#TESRET EACH CONTAINING THE NUMBER OF
.* THE REGISTER REPRESENTED BY THE CORRESPONDING NAME FROM
.* THE INPUT SUB-LIST.
.*   IF ANY REGISTER NAME CANNOT BE PROPERLY DECODED, THEN
.* &#TESERR IS SET TO A VALUE OF 16. NO ERROR MESSAGE IS
.* ISSUED.
.*
.REGS    AIF   (N'&REGS EQ 0).REGSEND
&CTR     SETA  0
.REGLP1  AIF   (&CTR GE 16).REGLP2
&RN(&CTR+1) SETC '&CTR'
&RV(&CTR+1) SETA &CTR
&CTR     SETA  &CTR+1
         AGO   .REGLP1
.REGLP2  AIF   (&CTR GE 22).REGND2
&CTR     SETA  &CTR+1
&RN(&CTR) SETC 'ABCDEF'(&CTR-16,1)
&RV(&CTR) SETA &CTR-7
         AGO   .REGLP2
.REGND2  ANOP
&CTR     SETA  0
.REGLP3  AIF   (&CTR GE N'&REGS).REGSEND
&CTR     SETA  &CTR+1
&RETPTR  SETA  &RETPTR+1
&#TESRET(&RETPTR) SETC ''
         AIF   (K'&REGS(&CTR) EQ 0).REGLP3
&#TESRET(&RETPTR) SETC '&REGS(&CTR)'
         AIF   (T'&REGS(&CTR) NE 'N').REGLP3A
         AIF   (&REGS(&CTR) LT 0 OR &REGS(&CTR) GT 15).REGERR
         AGO   .REGLP3
.REGLP3A ANOP
&A1      SETA  0
.REGLP4  AIF   (&A1 GE 255).REGND4
&A1      SETA  &A1+1
         AIF   ('&#REGNME(&A1)' EQ '').REGND4
         AIF   (&#REGVAL(&A1) GT 15).REGPFX
         AIF   ('&REGS(&CTR)' NE '&#REGNME(&A1)').REGLP4
&#TESRET(&RETPTR) SETC '&#REGVAL(&A1)'
         AGO   .REGLP3
.REGPFX  ANOP
&A2      SETA  0
.REGLP5  AIF   (&A2 GE 22).REGLP4
&A2      SETA  &A2+1
         AIF   ('&REGS(&CTR)' NE '&#REGNME(&A1)&RN(&A2)').REGLP5
&#TESRET(&RETPTR) SETC '&RV(&A2)'
         AGO   .REGLP3
.REGND4  ANOP
&A2      SETA  0
.REGLP6  AIF   (&A2 GE 16).REGERR
&A2      SETA  &A2+1
         AIF   ('&REGS(&CTR)' NE '&RN(&A2)').REGLP6
         AGO   .REGLP3
.REGERR  ANOP
&#TESERR SETA  16
         AGO   .REGLP3
.REGSEND ANOP
.*
.*
.*
.*                            THE "SIZE" FUNCTION
.*   THIS FUNCTION WAS WRITTEN BECAUSE OF THE LIMITATION
.* THAT MACRO CODE CANNOT ARITHMETICLY MANIPULATE OPERANDS
.* CONSISTING OF EITHER EXPRESSIONS OR EQUATE SYMBOLS.
.* BECAUSE OF THIS, IN SITUATIONS WHERE A PROGRAMMER WOULD
.* NORMALLY WANT TO USE AN EXPRESSION, ETC., HE MAY INSTEAD
.* BE FORCED TO USE A SELF DEFINING NUMERIC. THE PROBLEM IS
.* THAT IF SUBSEQUENT MODIFICATIONS AFFECT THE VALUE OF SUCH
.* AN EXPRESSION, THE PROGRAMMER MIGHT FORGET TO CHANGE THE
.* SELF DEFINING NUMERIC ACCORDINGLY. THE SIZE FUNCTION CAN
.* BE USED TO ALLEVIATE THIS PROBLEM.
.*   THE INPUT IS COMMUNICATED VIA THE "SIZE=" OPERAND AND
.* IT MUST CONSIST OF A THREE ELEMENT SUB-LIST. THE FIRST
.* AND THIRD ELEMENTS MUST BE SUCH THAT THEY RESULTS IN
.* NON-RELOCATABLE VALUES WHEN ASSEMBLED. THE SECOND OPERAND
.* MUST BE ONE OF THE FOLLOWING RELATIONAL OPERATORS:
.*       LT, LE, EQ, GE, GT, NE
.* MEANING "LESS THAN", "LESS THAN OR EQUAL", "EQUAL",
.* "GREATER THAN OR EQUAL", "GREATER THAN", AND "NOT EQUAL"
.* RESPECTIVELY.
.*   THE OUTPUT CONSISTS OF A GENERATED STATEMENT WHICH
.* PRODUCES NO OBJECT CODE BUT WHICH CAUSES AN ERROR
.* WHENEVER THE TWO GIVEN ELEMENTS VIOLATE THE INDICATED
.* RELATION.
.*
.SIZE    AIF   (N'&SIZE EQ 0).SIZEEND
         AIF   ('&SIZE(2)' EQ 'EQ' OR '&SIZE(2)' EQ 'GE' OR '&SIZE(2)' *
               EQ 'LE' OR '&SIZE(2)' EQ 'GT' OR '&SIZE(2)' EQ 'LT' OR '*
               &SIZE(2)' EQ 'NE').OPOK
         MNOTE 8,'ERROR - "&SIZE(2)" NOT A VALID RELATIONAL OPERATOR'
&#TESERR SETA  16
         AGO   .SIZEEND
.OPOK    AIF   ('&SIZE(2)' NE 'EQ').OPNTEQ
         DC    0YL2(X'7FFF'-(&SIZE(1))+&SIZE(3),X'7FFF'-(&SIZE(3))+&SIZ*
               E(1))
         AGO   .SIZEEND
.OPNTEQ  AIF   ('&SIZE(2)' NE 'NE').OPNTNE
         DC    0YL2(X'8000'-(&SIZE(3)-(&SIZE(1)))/(&SIZE(3)-(&SIZE(1)))*
               )
         AGO   .SIZEEND
.OPNTNE  ANOP
&BASE    SETC  '7FFF'
         AIF   ('&SIZE(2)'(2,1) EQ 'E').NOPLUS1
&BASE    SETC  '8000'
.NOPLUS1 AIF   ('&SIZE(2)'(1,1) EQ 'G').OPG
         DC    0YL2(X'&BASE'-(&SIZE(3))+&SIZE(1))
         AGO   .SIZEEND
.OPG     ANOP
         DC    0YL2(X'&BASE'-(&SIZE(1))+&SIZE(3))
.SIZEEND ANOP
.*
.*
.*
.*                                 THE "GEN" FUNCTION
.*    THIS FUNCTION CAN BE USED TO GENERATE VARIOUS SPECIFIC
.* OBJECTS. CURRENTLY, THE SUPPORTED OBJECTS ARE:
.*       EBCDIC - A GLOBAL TABLE CONTAINING THE ENTIRE
.*                256-ENTRY EBCDIC CHARACTER SET SUCH THAT
.*                THE VALUE OF THE ITH ENTRY IS I-1.
.*
.GEN     AIF   (N'&GEN EQ 0).GENEND
&A1      SETA  0
.GENLP   AIF   (&A1 EQ N'&GEN).GENEND
&A1      SETA  &A1+1
         AIF   ('&GEN(&A1)' EQ '').GENLP
         AIF   ('&GEN(&A1)' NE 'EBCDIC').GNTEBCD
         AIF   ('&#EBCDIC(194)' EQ 'A').GENLP
&#EBCDIC(001) SETC '
&#EBCDIC(002) SETC ''
&#EBCDIC(003) SETC ''
&#EBCDIC(004) SETC ''
&#EBCDIC(005) SETC ''
&#EBCDIC(006) SETC '	'
&#EBCDIC(007) SETC ''
&#EBCDIC(008) SETC ''
&#EBCDIC(009) SETC ''
&#EBCDIC(010) SETC ''
&#EBCDIC(011) SETC ''
&#EBCDIC(012) SETC ''
&#EBCDIC(013) SETC ''
&#EBCDIC(014) SETC ''
&#EBCDIC(015) SETC ''
&#EBCDIC(016) SETC ''
&#EBCDIC(017) SETC ''
&#EBCDIC(018) SETC ''
&#EBCDIC(019) SETC ''
&#EBCDIC(020) SETC ''
&#EBCDIC(021) SETC ''
&#EBCDIC(022) SETC '
'
&#EBCDIC(023) SETC ''
&#EBCDIC(024) SETC ''
&#EBCDIC(025) SETC ''
&#EBCDIC(026) SETC ''
&#EBCDIC(027) SETC ''
&#EBCDIC(028) SETC ''
&#EBCDIC(029) SETC ''
&#EBCDIC(030) SETC ''
&#EBCDIC(031) SETC ''
&#EBCDIC(032) SETC ''
&#EBCDIC(033) SETC ''
&#EBCDIC(034) SETC ''
&#EBCDIC(035) SETC ''
&#EBCDIC(036) SETC ''
&#EBCDIC(037) SETC ''
&#EBCDIC(038) SETC '
'
&#EBCDIC(039) SETC ''
&#EBCDIC(040) SETC ''
&#EBCDIC(041) SETC ''
&#EBCDIC(042) SETC ''
&#EBCDIC(043) SETC ''
&#EBCDIC(044) SETC ''
&#EBCDIC(045) SETC ''
&#EBCDIC(046) SETC ''
&#EBCDIC(047) SETC ''
&#EBCDIC(048) SETC ''
&#EBCDIC(049) SETC ''
&#EBCDIC(050) SETC ''
&#EBCDIC(051) SETC ''
&#EBCDIC(052) SETC ''
&#EBCDIC(053) SETC ''
&#EBCDIC(054) SETC ''
&#EBCDIC(055) SETC ''
&#EBCDIC(056) SETC ''
&#EBCDIC(057) SETC ''
&#EBCDIC(058) SETC ''
&#EBCDIC(059) SETC ''
&#EBCDIC(060) SETC ''
&#EBCDIC(061) SETC ''
&#EBCDIC(062) SETC ''
&#EBCDIC(063) SETC ''
&#EBCDIC(064) SETC ''
&#EBCDIC(065) SETC ' '
&#EBCDIC(066) SETC ''
&#EBCDIC(067) SETC ''
&#EBCDIC(068) SETC ''
&#EBCDIC(069) SETC ''
&#EBCDIC(070) SETC ''
&#EBCDIC(071) SETC ''
&#EBCDIC(072) SETC ''
&#EBCDIC(073) SETC ''
&#EBCDIC(074) SETC ''
&#EBCDIC(075) SETC ''
&#EBCDIC(076) SETC '.'
&#EBCDIC(077) SETC '<'
&#EBCDIC(078) SETC '('
&#EBCDIC(079) SETC '+'
&#EBCDIC(080) SETC ''
&#EBCDIC(081) SETC '&&'
&#EBCDIC(082) SETC ''
&#EBCDIC(083) SETC ''
&#EBCDIC(084) SETC ''
&#EBCDIC(085) SETC ''
&#EBCDIC(086) SETC ''
&#EBCDIC(087) SETC ''
&#EBCDIC(088) SETC ''
&#EBCDIC(089) SETC ''
&#EBCDIC(090) SETC ''
&#EBCDIC(091) SETC '!'
&#EBCDIC(092) SETC '$'
&#EBCDIC(093) SETC '*'
&#EBCDIC(094) SETC ')'
&#EBCDIC(095) SETC ';'
&#EBCDIC(096) SETC '^'
&#EBCDIC(097) SETC '-'
&#EBCDIC(098) SETC '/'
&#EBCDIC(099) SETC ''
&#EBCDIC(100) SETC ''
&#EBCDIC(101) SETC ''
&#EBCDIC(102) SETC ''
&#EBCDIC(103) SETC ''
&#EBCDIC(104) SETC ''
&#EBCDIC(105) SETC ''
&#EBCDIC(106) SETC ''
&#EBCDIC(107) SETC '|'
&#EBCDIC(108) SETC ','
&#EBCDIC(109) SETC '%'
&#EBCDIC(110) SETC '_'
&#EBCDIC(111) SETC '>'
&#EBCDIC(112) SETC '?'
&#EBCDIC(113) SETC ''
&#EBCDIC(114) SETC ''
&#EBCDIC(115) SETC ''
&#EBCDIC(116) SETC ''
&#EBCDIC(117) SETC ''
&#EBCDIC(118) SETC ''
&#EBCDIC(119) SETC ''
&#EBCDIC(120) SETC ''
&#EBCDIC(121) SETC ''
&#EBCDIC(122) SETC '`'
&#EBCDIC(123) SETC ':'
&#EBCDIC(124) SETC '#'
&#EBCDIC(125) SETC '@'
&#EBCDIC(126) SETC ''''''
&#EBCDIC(127) SETC '='
&#EBCDIC(128) SETC '"'
&#EBCDIC(129) SETC ''
&#EBCDIC(130) SETC 'a'
&#EBCDIC(131) SETC 'b'
&#EBCDIC(132) SETC 'c'
&#EBCDIC(133) SETC 'd'
&#EBCDIC(134) SETC 'e'
&#EBCDIC(135) SETC 'f'
&#EBCDIC(136) SETC 'g'
&#EBCDIC(137) SETC 'h'
&#EBCDIC(138) SETC 'i'
&#EBCDIC(139) SETC ''
&#EBCDIC(140) SETC ''
&#EBCDIC(141) SETC ''
&#EBCDIC(142) SETC ''
&#EBCDIC(143) SETC ''
&#EBCDIC(144) SETC ''
&#EBCDIC(145) SETC ''
&#EBCDIC(146) SETC 'j'
&#EBCDIC(147) SETC 'k'
&#EBCDIC(148) SETC 'l'
&#EBCDIC(149) SETC 'm'
&#EBCDIC(150) SETC 'n'
&#EBCDIC(151) SETC 'o'
&#EBCDIC(152) SETC 'p'
&#EBCDIC(153) SETC 'q'
&#EBCDIC(154) SETC 'r'
&#EBCDIC(155) SETC ''
&#EBCDIC(156) SETC ''
&#EBCDIC(157) SETC ''
&#EBCDIC(158) SETC ''
&#EBCDIC(159) SETC ''
&#EBCDIC(160) SETC ''
&#EBCDIC(161) SETC ''
&#EBCDIC(162) SETC '~'
&#EBCDIC(163) SETC 's'
&#EBCDIC(164) SETC 't'
&#EBCDIC(165) SETC 'u'
&#EBCDIC(166) SETC 'v'
&#EBCDIC(167) SETC 'w'
&#EBCDIC(168) SETC 'x'
&#EBCDIC(169) SETC 'y'
&#EBCDIC(170) SETC 'z'
&#EBCDIC(171) SETC ''
&#EBCDIC(172) SETC ''
&#EBCDIC(173) SETC ''
&#EBCDIC(174) SETC '['
&#EBCDIC(175) SETC ''
&#EBCDIC(176) SETC ''
&#EBCDIC(177) SETC ''
&#EBCDIC(178) SETC ''
&#EBCDIC(179) SETC ''
&#EBCDIC(180) SETC ''
&#EBCDIC(181) SETC ''
&#EBCDIC(182) SETC ''
&#EBCDIC(183) SETC ''
&#EBCDIC(184) SETC ''
&#EBCDIC(185) SETC ''
&#EBCDIC(186) SETC ''
&#EBCDIC(187) SETC ''
&#EBCDIC(188) SETC ''
&#EBCDIC(189) SETC ''
&#EBCDIC(190) SETC ']'
&#EBCDIC(191) SETC ''
&#EBCDIC(192) SETC ''
&#EBCDIC(193) SETC '{'
&#EBCDIC(194) SETC 'A'
&#EBCDIC(195) SETC 'B'
&#EBCDIC(196) SETC 'C'
&#EBCDIC(197) SETC 'D'
&#EBCDIC(198) SETC 'E'
&#EBCDIC(199) SETC 'F'
&#EBCDIC(200) SETC 'G'
&#EBCDIC(201) SETC 'H'
&#EBCDIC(202) SETC 'I'
&#EBCDIC(203) SETC ''
&#EBCDIC(204) SETC ''
&#EBCDIC(205) SETC ''
&#EBCDIC(206) SETC ''
&#EBCDIC(207) SETC ''
&#EBCDIC(208) SETC ''
&#EBCDIC(209) SETC '}'
&#EBCDIC(210) SETC 'J'
&#EBCDIC(211) SETC 'K'
&#EBCDIC(212) SETC 'L'
&#EBCDIC(213) SETC 'M'
&#EBCDIC(214) SETC 'N'
&#EBCDIC(215) SETC 'O'
&#EBCDIC(216) SETC 'P'
&#EBCDIC(217) SETC 'Q'
&#EBCDIC(218) SETC 'R'
&#EBCDIC(219) SETC ''
&#EBCDIC(220) SETC ''
&#EBCDIC(221) SETC ''
&#EBCDIC(222) SETC ''
&#EBCDIC(223) SETC ''
&#EBCDIC(224) SETC ''
&#EBCDIC(225) SETC '\'
&#EBCDIC(226) SETC ''
&#EBCDIC(227) SETC 'S'
&#EBCDIC(228) SETC 'T'
&#EBCDIC(229) SETC 'U'
&#EBCDIC(230) SETC 'V'
&#EBCDIC(231) SETC 'W'
&#EBCDIC(232) SETC 'X'
&#EBCDIC(233) SETC 'Y'
&#EBCDIC(234) SETC 'Z'
&#EBCDIC(235) SETC ''
&#EBCDIC(236) SETC ''
&#EBCDIC(237) SETC ''
&#EBCDIC(238) SETC ''
&#EBCDIC(239) SETC ''
&#EBCDIC(240) SETC ''
&#EBCDIC(241) SETC '0'
&#EBCDIC(242) SETC '1'
&#EBCDIC(243) SETC '2'
&#EBCDIC(244) SETC '3'
&#EBCDIC(245) SETC '4'
&#EBCDIC(246) SETC '5'
&#EBCDIC(247) SETC '6'
&#EBCDIC(248) SETC '7'
&#EBCDIC(249) SETC '8'
&#EBCDIC(250) SETC '9'
&#EBCDIC(251) SETC ''
&#EBCDIC(252) SETC ''
&#EBCDIC(253) SETC ''
&#EBCDIC(254) SETC ''
&#EBCDIC(255) SETC ''
&#EBCDIC(256) SETC ''
         AGO   .GENLP
.GNTEBCD MNOTE 8,'ERROR - &&GEN(&A1)=&GEN(&A1) IS UNRECOGNIZED'
         AGO   .GENLP
.GENEND  ANOP
.*
.*
.*
.END     MEND
         MACRO
         #USING &D
.*
.*
.*
.* LAST CHANGE DATE - OCTOBER 18, 1983
.*                  - MAILING ADDRESS CHANGE
.*
.* LAST CHANGE DATE - APRIL 21, 1981
.*                  - MACRO NAME CHANGED FROM $USING TO #USING.
.*
.* LAST CHANGE DATE - FEBRUARY 2, 1977
.*                  - MAILING ADDRESS CHANGE.
.*
.* LAST CHANGE DATE - AUGUST 23, 1976
.*
.* THIS MACRO WAS WRITTEN BY DAVID B. COLE. ANY QUESTIONS CONCERNING
.* IT MAY BE ADDRESSED TO:
.*       RR#2 BOX 712
.*       AFTON, VA. 22920
.*
.*
.*
.*   THIS MACRO GENERATES A USING INSTRUCTION THAT REDECLARES ALL BASES
.* (IF ANY) DECLARED BY A PRIOR #ENTER MACRO EXPANSION.
.*
.*
.*
.* INNER MACROS USED - NONE
.*
         GBLC  &#BS(14)
         LCLA  &A1,&DISPL
         AIF   ('&#BS(14)' EQ '').END
&DISPL   SETA  &DISPL-4095
&A1      SETA  14
.LP      AIF   (&A1 EQ 2).END
&A1      SETA  &A1-1
         AIF   ('&#BS(&A1)' EQ '').LP
&DISPL   SETA  &DISPL+4095
         USING &#BS(14)+&DISPL,&#BS(&A1)
         AGO   .LP
.END     MEND
         MACRO
&NAME    #XXC  &OP,&T,&F,&L,&SVID=,&PFIX=,&MF=INLINE
.*
.*
.*
.* LAST CHANGE DATE - OCTOBER 18, 1983
.*                  - MAILING ADDRESS CHANGE
.*
.* LAST CHANGE DATE - MARCH 8, 1982
.*                  - THE LENGTH VERIFICATION TEST ("#TEST SIZE=...")
.*                    HAS BEEN REMOVED. IT IS NOT REALLY NEEDED.
.*
.* LAST CHANGE DATE - DECEMBER 1, 1981
.*                  - "PFIX=(...,NOSAVE)" SUPPORT HAS BEEN ADDED. THIS
.*                    PROVIDES A MEANS OF BYPASSING THE ISSUENCE OF THE
.*                    #REGS MACRO. (SOMETIMES, THE #REGS MACRO THAT I
.*                    WOULD GET IS NOT THE ONE I WANT).
.*
.* LAST CHANGE DATE - JUNE 1, 1981
.*                  - BUG FIXED. NOW, IF MF=SUBROUTINE AND
.*                    OP=TRT, THEN R1 IS NOT RESTORED WHEN
.*                    THE SUBROUTINE COMPLETES.
.*
.* LAST CHANGE DATE - APRIL 21, 1981
.*                  - MACRO NAME CHANGED FROM $XXC TO #XXC.
.*
.* LAST CHANGE DATE - APRIL 20, 1981
.*                  - "#REGS GEN=NO" SUPPORT ADDED.
.*
.* LAST CHANGE DATE - DECEMBER 12, 1977
.*                  - SYNTAX BUG FIXED. A CONTINUATION CHARACTER WAS
.*                    NOT PLACE IN COLUMN 72.
.*
.* LAST CHANGE DATE - JANUARY 17, 1977
.*                  - FORM OF &MF= OPERAND REDESIGNED.
.*                  - DEFAULT MEANINGS OF &T AND &F AND (FOR
.*                    MF=SUBROUTINE) &L REMOVED.
.*                  - REGISTER FORM OF &SVID= SUPPORTED.
.*                  - COMMENTARY REWRITTEN.
.*                  - MAILING ADDRESS CHANGED.
.*
.* LAST CHANGE DATE - SEPTEMBER 27, 1976
.*                  - FIXED BUG: MISSING SEQUENCE SYMBOL - .TLR
.*                  - CHANGED LENGTH SIZE TEST TO BE GENERATED WHENEVER
.*                    &L(2) WAS GIVEN WITH THE NON-ROUTINE/SUBROUTINE
.*                    FORM OF THE MACRO CALL.
.*                  - IF THE CALL IS A KNOWN LENGTH FORM AND IF THE
.*                    LENGTH'S DERIVATIVE EXPRESSION IS GIVEN (&L(2))
.*                    THEN IT IS USED TO DERIVE THE LENGTH FIELD OF THE
.*                    LAST SS INSTRUCTION GENERATED.
.*
.* LAST CHANGE DATE - JUNE 6, 1975
.*
.* THIS MACRO WAS WRITTEN BY DAVID B. COLE. ANY QUESTIONS CONCERNING
.* IT MAY BE ADDRESSED TO:
.*       RR#2 BOX 712
.*       AFTON, VA. 22920
.*
.*
.*    THIS MACRO GENERATES ROUTINES TO PERFORM NON-DECIMAL
.* STORAGE-TO-STORAGE FUNCTIONS ON OPERANDS OF ARBITRARY LENGTH.
.* SUPPORTED "SS-FUNCTIONS" ARE:
.*       CLC      MVZ      TR
.*       MVC      NC       TRT
.*       MVN      OC       XC
.*
.*    THIS MACRO HAS TWO DIFFERENT MODES OF EXPANSION:
.*     - IF THE OPERAND LENGTHS ARE KNOWN AT ASSEMBLY TIME, THEN THE
.*       EXPANSION CAN CONSIST OF A SUFFICIENT NUMBER OF
.*       SS-INSTRUCTIONS TO ACCOMODATE THE GIVEN LENGTH. FOR EACH
.*       SUCCESSIVE SS-INSTRUCTION GENERATED, THE SINK OPERAND POINTER
.*       IS INCREMENTED BY 256. THE SOURCE OPERAND POINTER IS ALSO
.*       INCREMENTED BY 256 UNLESS THE OPERATOR IS EITHER "TR" OR
.*       "TRT". ADDITIONALLY FOR "CLC" AND "TRT", CONDITIONAL BRANCH
.*       INSTRUCTIONS ARE INSERTED IN THE EXPANSION SO THAT UPON THE
.*       FIRST OCCURANCE OF A NOT-EQUAL CONDITION THE REMAINING
.*       SS-INSTRUCTIONS ARE BYPASSED.
.*     - IF THE OPERAND LENGTHS CANNOT BE KNOWN UNTIL EXECUTION TIME,
.*       THEN THE EXPANSION IS A GENERALIZED SUBROUTINE CAPABLE OF
.*       PROCESSING ANY LENGTH.
.*
.* &NAME
.*       THIS OPERAND IS OPTIONAL. IF GIVEN, THEN, OF COURSE, IT LABELS
.*       THE GENERATED CODE.
.*
.* &MF=
.*       THIS OPERAND IS OPTIONAL. IF OMITTED, THEN MF=INLINE IS
.*       ASSUMED. &MF= CONTROLS THE OVERALL FORM OF THE MACRO
.*       EXPANSION. &MF= MAY BE GIVEN IN THE FOLLOWING FORMS:
.*       -OMITTED-
.*       MF=
.*       MF=INLINE
.*             THE SINK OPERAND LENGTH IS KNOWN AT ASSEMBLY TIME. THE
.*             MACRO EXPANDS INTO A SUFFICIENT REPETITION OF
.*             SS-INSTRUCTIONS TO PERFORM THE FUNCTION.
.*       MF=(SUBROUTINE, --- )
.*             THE SINK OPERAND LENGTH CANNOT BE KNOWN UNTIL ASSEMBLY
.*             TIME. THE MACRO EXPANDS INTO A GENERALIZED SUBROUTINE
.*             CAPABLE OF PERFORMING THE REQUIRED SS-FUNCTION ON
.*             OPERANDS OF ARBITRARY LENGTH.
.*       MF=SUBROUTINE
.*       MF=(SUBROUTINE,(14))
.*             WHEN THE SS-FUNCTION SUBROUTINE COMPLETES, A RETURN IS
.*             MADE TO THE ADDRESS POINTED TO BY REGISTER-14.
.*       MF=(SUBROUTINE,(-X-))
.*             -X- MUST BE AN ABSOLUTE EXPRESSION REPRESENTING THE NAME
.*             OF A REGISTER CONTAINING A RETURN ADDRESS.
.*       MF=(SUBROUTINE,-X-)
.*             -X- MUST BE AN ABSOLUTE OR RELOCATABLE EXPRESSION
.*             REPRESENTING A FIXED RETURN ADDRESS.
.*       MF=(SUBROUTINE,*)
.*             WHEN THE SS-FUNCTION SUBROUTINE COMPLETES, IT FALLS
.*             THROUGH TO CODE FOLLOWING THE MACRO EXPANSION.
.*
.* &OP
.*       THIS OPERAND IS REQUIRED. IT IDENTIFIES THE SS-FUNCTION TO BE
.*       PERFORMED. IF SHOULD BE EITHER:
.*          CLC      MVZ      TR
.*          MVC      NC       TRT
.*          MVN      OC       XC
.*       IF IT IS ANYTHING ELSE, THEN A SEVERITY-4 DIAGNOSTIC IS ISSUED
.*       BEFORE THE EXPANSION IS ATTEMPTED.
.*
.* &T
.*       THIS OPERAND IS REQUIRED. IT IDENTIFIES THE LOCATION OF THE
.*       SINK OPERAND. IT MAY BE EITHER AN ADDRESS, A REGISTER, OR A
.*       BASE/DISPLACEMENT COMBINATION AS FOLLOWS:
.*       -X- (ADDRESS FORM): -X- MAY BE EITHER AN ABSOLUTE OR
.*           RELOCATABLE EXPRESSION IDENTIFYING THE LOCATION OF THE
.*           SINK OPERAND.
.*       (-X-) (REGISTER FORM): -X- MUST BE AN ABSOLUTE EXPRESSION
.*             REPRESENTING THE NAME OF A REGISTER CONTAINING THE
.*             ADDRESS OF THE SINK OPERAND.
.*       (-X-,-Y-) (BASE/DISPLACEMENT FORM): -X- MUST BE AN ABSOLUTE
.*                 EXPRESSION REPRESENTING A DISPLACEMENT. -Y- MUST BE
.*                 AN ABSOLUTE EXPRESSION REPRESENTING A BASE (REGISTER
.*                 NAME). TOGETHER THE BASE AND DISPLACEMENT GIVE THE
.*                 ADDRESS OF THE SINK OPERAND.
.*
.* &F
.*       THIS OPERAND IS REQUIRED. IT IDENTIFIES THE LOCATION OF THE
.*       SOURCE OPERAND. IT MAY BE EITHER AN ADDRESS, A REGISTER, OR A
.*       BASE/DISPLACEMENT COMBINATION AS FOLLOWS:
.*       -X- (ADDRESS FORM): -X- MAY BE EITHER AN ABSOLUTE OR
.*           RELOCATABLE EXPRESSION IDENTIFYING THE LOCATION OF THE
.*           SOURCE OPERAND.
.*       (-X-) (REGISTER FORM): -X- MUST BE AN ABSOLUTE EXPRESSION
.*             REPRESENTING THE NAME OF A REGISTER CONTAINING THE
.*             ADDRESS OF THE SOURCE OPERAND.
.*       (-X-,-Y-) (BASE/DISPLACEMENT FORM): -X- MUST BE AN ABSOLUTE
.*                 EXPRESSION REPRESENTING A DISPLACEMENT. -Y- MUST BE
.*                 AN ABSOLUTE EXPRESSION REPRESENTING A BASE (REGISTER
.*                 NAME). TOGETHER THE BASE AND DISPLACEMENT GIVE THE
.*                 ADDRESS OF THE SOURCE OPERAND.
.*
.* &L
.*       THIS OPERAND RELATES TO THE LENGTH OF THE SINK (AND,
.*       THEREFORE, THE SOURCE) OPERAND. ITS PRECISE MEANING, HOWEVER,
.*       DIFFERS DEPENDING UPON THE VALUE OF THE &MF= OPERAND.
.*
.* &L    (MF ==> INLINE)
.*       HERE, &L IS AN OPTIONAL OPERAND REPRESENTING THE ACTUAL LENGTH
.*       OF THE SINK OPERAND. IT MAY BE GIVEN IN THE FOLLOWING FORMS:
.*       -OMITTED-: THE MACRO ATTEMPTS TO USE THE IMPLIED LENGTH OF THE
.*                  SINK OPERAND. IF THE IMPLIED LENGTH CAN BE KNOWN AT
.*                  MACRO PASS TIME, THEN IT IS USED TO CONTROL THE
.*                  NUMBER OF SS-INSTRUCTIONS GENERATED; OTHERWISE,
.*                  ONLY ONE SS-INSTRUCTION IS GENERATED.
.*       -X-: -X- MUST BE A SELF-DEFINING TERM (I.E. RESOLVABLE AT
.*            MACRO PASS TIME) REPRESENTING THE LENGTH OF THE SINK
.*            OPERAND. IT IS USED TO CONTROL THE NUMBER OF
.*            SS-INSTRUCTIONS GENERATED.
.*       (-X-,-Y-): -X- MUST BE AS ABOVE. -Y- MUST BE A ABSOLUTE
.*                  EXPRESSION (I.E. RESOLVABLE BY FINAL-PASS TIME)
.*                  ALSO REPRESENTING THE LENGTH OF THE SINK OPERAND.
.*                  IN OTHER WORDS, -X- AND -Y- MUST REPRESENT THE SAME
.*                  VALUE. THE DISTINCTION IS THAT -Y- CAN BE
.*                  RESPONSIVE TO SUCH THINGS AS LENGTH ATTRIBUTES AND
.*                  EQUATE VALUES WHEREAS -X- CANNOT. -Y- IS NOT USED
.*                  TO CONTROL THE MACRO EXPANSION. INSTEAD, IT IS USED
.*                  AS A VALIDITY CHECK ON -X-. WHEN -Y- IS GIVEN, A
.*                  STATEMENT OF THE FORM:
.*                        DC    0Y(X'7FFF'-(X-Y),X'7FFF'-(Y-X))
.*                  IS GENERATED. THIS STATEMENT DOES NOT CREATE ANY
.*                  OBJECT CODE, BUT IF -X- AND -Y- HAVE UNEQUAL
.*                  VALUES, THEN IT DOES GENERATE AN ASSEMBLY ERROR.
.*
.* &L    (&MF ==> SUBROUTINE)
.*       HERE, &L IS A REQUIRED OPERAND. IT REPRESENTS THE LOCATION OF
.*       THE LENGTH OF THE SINK OPERAND. IT MAY BE GIVEN IN THE
.*       FOLLOWING FORMS:
.*       -X- (ADDRESS FORM): -X- MUST BE EITHER AN ABSOLUTE OR
.*           RELOCATABLE EXPRESSION REPRESENTING THE ADDRESS OF A
.*           FULLWORD CONTAINING THE LENGTH OF THE SINK OPERAND.
.*       (-X-) (REGISTER FORM): -X- MUST BE AN ABSOLUTE EXPRESSION
.*             REPRESENTING THE NAME OF A REGISTER CONTAINING THE
.*             LENGTH OF THE SINK OPERAND.
.*
.* &SVID=
.*       THIS OPERAND IS OPTIONAL. IT IDENTIFIES THE LOCATION OF A
.*       4-WORD REGISTER SAVE AREA FOR USE BY THE SUBROUTINE FORM OF
.*       THE MACRO EXPANSION. (FOR THE INLINE FORM OF THE EXPANSION,
.*       THE &SVID= OPERAND IS IGNORED.) &SVID= MAY BE GIVEN IN THE
.*       FOLLOWING FORMS:
.*       -OMITTED-: A 4-WORD SAVE AREA IS INCLUDED IN THE EXPANSION
.*       SVID=-X- (ADDRESS FORM): -X- MUST BE EITHER AN ABSOLUTE OR
.*             RELOCATABLE EXPRESSION REPRESENTING THE ADDRESS OF A
.*             4-WORD SAVE AREA.
.*       SVID=(-X-) (REGISTER FORM): -X- MUST BE AN ABSOLUTE EXPRESSION
.*             REPRESENTING THE NAME OF A REGISTER CONTAINING THE
.*             ADDRESS OF A 4-WORD REGISTER SAVE AREA. WARNING, THE
.*             REGISTER CANNOT BE EITHER 14, 15, 0, OR 1.
.*
.* &PFIX=
.*       THE #XXC MACRO ATTEMPTS TO USE REGISTER EQUATES IN ITS
.*       EXPANSION WHEN REFERING TO REGISTERS. THIS IS SO THAT THE USE
.*       OF THE REGISTERS IS INDICATED IN THE ASSEMBLER'S CROSS
.*       REFERENCE LISTING. THE PFIX= OPERAND CAN BE USED TO CONTROL
.*       THE SET OF EQUATES USED. FOR EXAMPLE, IF "PFIX=GPR" IS GIVEN,
.*       THEN "GPR1" IS USED WHENEVER THE EXPANSION REFERS FO REGISTER
.*       1.
.*          IF THE PFIX= OPERAND IS OMITTED, THEN THE SET OF REGISTER
.*       EQUATES DEFINED BY THE NEXT PRIOR #REGS MACRO IS USED. IF
.*       THERE ARE NO PRIOR #REGS MACROS, THEN SELF-DEFINING NUMERICS
.*       ARE USED.
.*
.* &PFIX=(...,NOSAVE)
.*       THIS PREVENTS THIS MACRO FROM INVOKING THE #REGS MACRO.
.*
.*
.*
.*
.* INNER MACROS USED - #REGS #TEST
.*
         GBLA  &#TESERR
         GBLC  &#TESRET(20)
         LCLA  &TDI,&TRI,&TR
         LCLA  &FDI,&FRI,&FR
         LCLA  &A,&D1,&RE
         LCLB  &LOADR1
         LCLC  &TZ,&TC,&TLP,&TRP
         LCLC  &FZ,&FC,&FLP,&FRP
         LCLC  &#,&C,&CD1,&CD2,&N,&@,&SAVEA
&#       SETC  '&SYSNDX'
&N       SETC  '&NAME'
         AIF   ('&OP' EQ 'CLC' OR '&OP' EQ 'MVC' OR '&OP' EQ 'MVN' OR '*
               &OP' EQ 'MVZ' OR '&OP' EQ 'NC' OR '&OP' EQ 'OC' OR '&OP'*
                EQ 'TR' OR '&OP' EQ 'TRT' OR '&OP' EQ 'XC').OPCOK
         MNOTE 4,'WARNING - THE OPCODE IS "&OP".'
         MNOTE 4,'THIS EXPANSION WILL PROBABLY NOT BE USEFULL.'
.OPCOK   ANOP
&TDI     SETA  1
&TRI     SETA  2
         AIF   (N'&T GT 1).TREG
         AIF   ('&T' EQ '&T(1)').TDCODED
&TDI     SETA  2
&TRI     SETA  1
&TZ      SETC  '0'
.TREG    ANOP
&TC      SETC  ','
&TLP     SETC  '('
&TRP     SETC  ')'
.TDCODED ANOP
&FDI     SETA  1
&FRI     SETA  2
         AIF   (N'&F GT 1).FREG
         AIF   ('&F' EQ '&F(1)').FDCODED
&FDI     SETA  2
&FRI     SETA  1
&FZ      SETC  '0'
.FREG    ANOP
&FC      SETC  ','
&FLP     SETC  '('
&FRP     SETC  ')'
.FDCODED ANOP
         AIF   ('&MF(1)' EQ 'INLINE' OR '&MF(1)' EQ '').XXC
         AIF   ('&MF(1)' EQ 'SUBROUTINE').SUB
         MNOTE 8,'MF(1)=&MF(1) IS INVALID.'
         AGO   .MEND
.SUB     ANOP
.*
&@       SETC  '&PFIX(1)'
         AIF   ('&PFIX(2). '(1,1) EQ 'N').DONPFIX
         AIF   (K'&PFIX(1) NE 0).GOTPFIX
         #TEST PFIX=
&@       SETC  '&#TESRET(1)'
         AGO   .DONPFIX
.GOTPFIX #REGS &PFIX(1),GEN=NO
.DONPFIX ANOP
.*
&SAVEA   SETC  'X&#.SVA'
         AIF   ('&SVID(1)' EQ '').GOTSAVA
&SAVEA   SETC  '&SVID'
         AIF   ('&SVID(1)' EQ '&SVID').GOTSAVA
&SAVEA   SETC  '0(&SVID(1))'
.GOTSAVA AIF   ('&F(&FRI)' EQ '').GOTFR
         #TEST REGS=&F(&FRI)
         AIF   (&#TESERR NE 0).GOTFR
&FR      SETA  &#TESRET(1)
.GOTFR   ANOP
&N       STM   &@.14,&@.1,&SAVEA   SAVE WORK REGISTERS
         AIF   ('&TZ' EQ '').TLA
         #TEST REGS=&T(&TRI)
         AIF   (&#TESERR NE 0).TLR
&TR      SETA  &#TESRET(1)
         AIF   (&TR EQ 15).TDONE
.TLR     LR    &@.15,&T(&TRI)      LOAD SINK REGISTER
         AGO   .TDONE
.TLA     LA    &@.15,&T(&TDI)&TLP&TC&T(&TRI)&TRP LOAD SINK REGISTER
.TDONE   ANOP
&LOADR1  SETB  (('&OP' NE 'TR' AND '&OP' NE 'TRT') OR (&FR EQ 14 OR &FR*
                EQ 15))
         AIF   (NOT &LOADR1).FDONE
         AIF   ('&FZ' EQ '').FLA
         AIF   (&FR EQ 15).FLR15
         AIF   (&FR EQ 1).FDONE
.FLR     LR    &@.1,&F(&FRI)       LOAD SOURCE REGISTER
         AGO   .FDONE
.FLR15   AIF   (&TR EQ 15).FLR
         L     &@.1,&SAVEA+4       LOAD SOURCE REGISTER
         AGO   .FDONE
.FLA     AIF   (&FR EQ 15).FL15
&FR      SETA  0
.FLAA    LA    &@.1,&F(&FDI)&FLP&FC&F(&FRI)&FRP LOAD SOURCE REGISTER
         AGO   .FDONE
.FL15    AIF   (&TR EQ 15).FLAA
         L     &@.1,&SAVEA+4       LOAD -
         LA    &@.1,&F(&FDI)(,&@.1) SOURCE REGISTER
.FDONE   AIF   ('&L' EQ '&L(1)').LL
         #TEST REGS=&L(1)
         AIF   (&#TESERR NE 0).LLTR
&A       SETA  4
&D1      SETA  &TR
         AIF   (&#TESRET(1) EQ 15).LLSVA
         AIF   (&#TESRET(1) NE 1).LLTR
&A       SETA  12
&D1      SETA  &FR
.LLSVA   AIF   (&#TESRET(1) EQ &D1).LLTR
         L     &@.0,&SAVEA+&A      LOAD LENGTH REGISTER
         AGO   .LLTR0
.LLTR    LTR   &@.0,&L(1)          LOAD LENGTH REGISTER; > 0?
         AGO   .LDONE
.LL      L     &@.0,&L             LOAD LENGTH REGISTER
.LLTR0   LTR   &@.0,&@.0           LENGTH > 0?
.LDONE   BNP   X&#.RET             NO, EXIT
         LA    &@.14,256           YES, GET MAX SINGLE EXECUTE LENGTH
X&#.LP   CR    &@.14,&@.0          LENGTH NEARLY EXHAUSTED YET?
         BNH   X&#.EX              NO, GO EXECUTE MAX LENGTH
         LR    &@.14,&@.0          YES, GET LAST EXECUTE LENGTH
X&#.EX   BCTR  &@.14,0             CONVERT LENGTH TO MACHINE LENGTH
         EX    &@.14,X&#.XXC       EXECUTE THE FUNCTION
         AIF   ('&OP' NE 'TRT' AND '&OP' NE 'CLC').TSTSKIP
         BNE   X&#.RET             INEQUALITY; GO RETURN TO CALLER
.TSTSKIP LA    &@.14,1(,&@.14)     RESTORE ORIGINAL LENGTH
         AR    &@.15,&@.14         ADVANCE SINK REGISTER
         AIF   ('&OP' EQ 'TRT' OR '&OP' EQ 'TR').NOINCR
         AR    &@.1,&@.14          ADVANCE SOURCE REGISTER
.NOINCR  SR    &@.0,&@.14          DECRIMENT THE LENGTH; DONE YET?
         BP    X&#.LP              NO, KEEP LOOPING
         AIF   ('&OP' NE 'TRT' OR NOT &LOADR1).NOTTRTX
         L     &@.1,&SAVEA+12      YES, TRT MISSED; INSURE R1 RESTORED
.NOTTRTX ANOP
&RE      SETA  1
         AIF   ('&OP' NE 'TRT').GOTRE
&RE      SETA  0
.GOTRE   ANOP
X&#.RET  LM    &@.14,&@&RE,&SAVEA  RESTORE REGISTERS
         AIF   ('&MF(2)' EQ '').BR14
         AIF   ('&MF(2)' EQ '*').BEND
         AIF   ('&MF(2)'(1,1) EQ '(').BREG
         B     &MF(2)              EXIT
         AGO   .DATA
.BR14    BR    &@.14               RETURN
         AGO   .DATA
.BEND    B     X&#.END             EXIT
         AGO   .DATA
.BREG    #TEST DCODE=&MF(2)
         BR    &#TESRET(2)         RETURN
.DATA    AIF   ('&SVID(1)' NE '').NOSAVEA
X&#.SVA  DS    4A                  REGISTER SAVE AREA
.NOSAVEA AIF   (NOT &LOADR1).TRTRTO
X&#.XXC  &OP   0(*-*,&@.15),0(&@.1) (EXECUTED)
         AGO   .ENDTST
.TRTRTO  ANOP
X&#.XXC  &OP   0(*-*,&@.15),&FZ&F(&FDI)&FLP&F(&FRI)&FRP (EXECUTED)
.ENDTST  AIF   ('&MF(2)' NE '*').MEND
X&#.END  DS    0H
         AGO   .MEND
.XXC     ANOP
&C       SETC  T'&L(1)
         AIF   ('&C' NE 'O').GOTLEN
&C       SETC  T'&T(&TDI)
         AIF   ('&C' EQ 'M' OR '&C' EQ 'N' OR '&C' EQ 'O' OR '&C' EQ 'T*
               ' OR '&C' EQ 'U' OR '&C' EQ 'W' OR '&C' EQ '$').NOLNGTH
&A       SETA  L'&T(&TDI)
         AIF   (&A GT 256).LONGMVC
.NOLNGTH ANOP
&N       &OP   &TZ&T(&TDI)&TLP&TC&T(&TRI)&TRP,&FZ&F(&FDI)&FLP&F(&FRI)&F*
               RP
         AGO   .MEND
.GOTLEN  AIF   ('&C' NE 'N').SHORTMV
&A       SETA  &L(1)
         AIF   (&A GT 256).LONGMVC
.SHORTMV ANOP
&A       SETA  1
         AIF   (K'&L(2) EQ 0).SHORT2
&A       SETA  2
.SHORT2  ANOP
&N       &OP   &TZ&T(&TDI)(&L(&A)&TC&T(&TRI)),&FZ&F(&FDI)&FLP&F(&FRI)&F*
               RP
         AGO   .MEND
.LONGMVC ANOP
&N       &OP   &TZ&T(&TDI)&CD1.(256&TC&T(&TRI)),&FZ&F(&FDI)&CD2&FLP&F(&*
               FRI)&FRP
&N       SETC  ''
         AIF   ('&OP' NE 'TRT' AND '&OP' NE 'CLC').NOTEST
         BNE   X&#.END
.NOTEST  ANOP
&A       SETA  &A-256
&D1      SETA  &D1+256
&CD1     SETC  '+'.'&D1'
         AIF   ('&OP' EQ 'TR' OR '&OP' EQ 'TRT').TROP
&CD2     SETC  '&CD1'
.TROP    AIF   (&A GT 256).LONGMVC
         AIF   (K'&L(2) EQ 0).LAST2
         &OP   &TZ&T(&TDI)&CD1.(&L(2)-&D1&TC&T(&TRI)),&FZ&F(&FDI)&CD2&F*
               LP&F(&FRI)&FRP
         AGO   .LAST1
.LAST2   &OP   &TZ&T(&TDI)&CD1.(&A&TC&T(&TRI)),&FZ&F(&FDI)&CD2&FLP&F(&F*
               RI)&FRP
.LAST1   AIF   ('&OP' NE 'CLC' AND '&OP' NE 'TRT').MEND
X&#.END  DS    0H
.MEND    MEND
         MACRO
&LABEL   GSAMCALL &VERB,                                               *
               &MF=,                                                   *
               &POOL=,                                                 *
               &FILE=,                                                 *
               &OPTIONS=,                                              *
               &BUFFER=,                                               *
               &BUFFLEN=,                                              *
               &RECLEN=,                                               *
               &MSGAREA=,                                              *
               &RBA=,                                                  *
               &PASS=
.************************************************************
.*                                                          *
.* MACRO NAME = GSAMCALL                                    *
.*                                                          *
.* DESCRIPTIVE NAME = FAKE GSAM CALL MACRO.                 *
.*                                                          *
.* FUNCTION = MODIFIES A GSB AND "BASR"S TO A GSAM          *
.*            SIMULATION ROUTINE WHICH TRANSLATES THE GSAM  *
.*            CALL INTO A SIMPLE VSAM CALL.                 *
.*                                                          *
.* PROCESSOR = ASSEMBLER XF                                 *
.*                                                          *
.* DATA AREAS = GSB                                         *
.*                                                          *
.************************************************************
         LCLC  &SET
         LCLC  &RESET
         LCLA  &I,&GSAMSVC
         LCLB  &ZERO
         LCLC  &R
.************************************************************
.*       CHANGE THE FOLLOWING LINE IF A DIFFERENT SVC       *
.*       NUMBER IS ASSIGNED AT YOUR INSTALLATION            *
.************************************************************
&GSAMSVC SETA  999                 IMPLIES GSAM NOT AVAILABLE
         AIF   (K'&LABEL EQ 0).NOLAB
&LABEL   DS    0H
.NOLAB   ANOP
.*       LOCATE THE GSB
         AIF   ('&MF(1)' NE 'E').BADMF
         AIF   ('&MF(2)' EQ '').BADMF
         AIF   ('&MF(2)' EQ '(1)').GOTMF
         IHBSETR &MF(2),1
.GOTMF   ANOP
.*       PROCESS OPTIONS LOOP
&I       SETA  1
.OPTLOOP AIF   ('&OPTIONS(&I)' EQ '').ENDOPT
         AIF   ('&OPTIONS(&I)' NE 'RESET').NZERO
&ZERO    SETB  (1)
         AGO   .NEXTOPT
.NZERO   AIF   ('&OPTIONS(&I)' NE 'INITIAL').NA1
         MVC   GSBID-GSB(4,1),=CL4'GSB'
         XC    4(GSBLEN-4,1),4(1)
&ZERO    SETB  (1)
         AGO   .NEXTOPT
.NA1     AIF   ('&OPTIONS(&I)' NE 'WAIT').NA2
&SET     SETC  '&SET+GSBWAIT'
         AGO   .NEXTOPT
.NA2     AIF   ('&OPTIONS(&I)' NE 'NOWAIT').NB1
&RESET   SETC  '&RESET-GSBWAIT'
         AGO   .NEXTOPT
.NB1     AIF   ('&OPTIONS(&I)' NE 'UPDATE').NB2
&SET     SETC  '&SET+GSBUPD'
         AGO   .NEXTOPT
.NB2     AIF   ('&OPTIONS(&I)' NE 'NOUPDATE').NC1
&RESET   SETC  '&RESET-GSBUPD'
         AGO   .NEXTOPT
.NC1     AIF   ('&OPTIONS(&I)' NE 'ASYNC').NC2
&SET     SETC  '&SET+GSBASYNC'
         AGO   .NEXTOPT
.NC2     AIF   ('&OPTIONS(&I)' NE 'SYNC').ND1
&RESET   SETC  '&RESET-GSBASYNC'
         AGO   .NEXTOPT
.ND1     AIF   ('&OPTIONS(&I)' NE 'DIR').ND2
&SET     SETC  '&SET+GSBDIR'
         AGO   .NEXTOPT
.ND2     AIF   ('&OPTIONS(&I)' NE 'SEQ').NE1
&RESET   SETC  '&RESET-GSBDIR'
         AGO   .NEXTOPT
.NE1     AIF   ('&OPTIONS(&I)' NE 'BACK').NE2
&SET     SETC  '&SET+GSBBACK'
         AGO   .NEXTOPT
.NE2     AIF   ('&OPTIONS(&I)' NE 'FWD').NF1
&RESET   SETC  '&RESET-GSBBACK'
         AGO   .NEXTOPT
.NF1     AIF   ('&OPTIONS(&I)' NE 'PTY').NF2
&SET     SETC  '&SET+GSBPTY'
         AGO   .NEXTOPT
.NF2     AIF   ('&OPTIONS(&I)' NE 'NOPTY').NH1
&RESET   SETC  '&RESET-GSBPTY'
         AGO   .NEXTOPT
.NH1     AIF   ('&OPTIONS(&I)' NE 'ABTERM').NH2
&SET     SETC  '&SET+GSBABTRM'
         AGO   .NEXTOPT
.NH2     AIF   ('&OPTIONS(&I)' NE 'NOABTERM').NI1
&RESET   SETC  '&RESET-GSBABTRM'
         AGO   .NEXTOPT
.NI1     AIF   ('&OPTIONS(&I)' NE 'DEBUG').NI2
&SET     SETC  '&SET+GSBDEBUG'
         AGO   .NEXTOPT
.NI2     AIF   ('&OPTIONS(&I)' NE 'NODEBUG').NJ1
&RESET   SETC  '&RESET-GSBDEBUG'
         AGO   .NEXTOPT
.NJ1     MNOTE 8,'GSAM002E INVALID OPTION &OPTIONS(&I)'
.NEXTOPT ANOP
&I       SETA  &I+1
         AGO   .OPTLOOP
.ENDOPT  ANOP
.*       NOW EXPAND OUT OPTION BIT SETTING INSTRUCTIONS
         AIF   (&ZERO).SET2
         AIF   ('&SET' EQ '').SET1
&SET     SETC  '&SET'(2,K'&SET-1)
         OI    GSBFLGS-GSB(1),&SET
.SET1    AIF   ('&RESET' EQ '').SET3
         NI    GSBFLGS-GSB(1),X'FF'&RESET
         AGO   .SET3
.SET2    AIF   ('&SET' EQ '').SET3
&SET     SETC  '&SET'(2,K'&SET-1)
         MVI   GSBFLGS-GSB(1),&SET
.SET3    ANOP
         AIF   ('&POOL' EQ '').NOPOOL
&R       SETC  '&POOL(1)'
         AIF   ('&R' NE '&POOL').GOTPOOL
         LA    15,&POOL
&R       SETC  '15'
.GOTPOOL ANOP
         STH   &R,GSBPOOL-GSB(,1)
.NOPOOL  AIF   ('&FILE' EQ '').NOFILE
         AIF   ('&FILE'(1,1) NE '''').GETFILE
         MVC   GSBFILE-GSB(8,1),=CL8&FILE
         AGO   .NOFILE
.GETFILE ANOP
&R       SETC  '&FILE(1)'
         AIF   ('&R' NE '&FILE').GOTFILE
         LA    15,&FILE
&R       SETC  '15'
.GOTFILE ANOP
         MVC   GSBFILE-GSB(8,1),0(&R)
.NOFILE  AIF   ('&BUFFER' EQ '').NOBUF
&R       SETC  '&BUFFER(1)'
         AIF   ('&R' NE '&BUFFER').GOTBUF
         AIF   ('&BUFFER' NE '-1').GETBUF
         XR    15,15
         BCTR  15,0
         AGO   .GETBUF2
.GETBUF  ANOP
         LA    15,&BUFFER
.GETBUF2 ANOP
&R       SETC  '15'
.GOTBUF  ANOP
         ST    &R,GSBBUFA-GSB(,1)
.NOBUF   AIF   ('&BUFFLEN' EQ '').NOBUFL
&R       SETC  '&BUFFLEN(1)'
         AIF   ('&R' NE '&BUFFLEN').GOTBUFL
         LA    15,&BUFFLEN
&R       SETC  '15'
.GOTBUFL ANOP
         ST    &R,GSBBUFL-GSB(,1)
.NOBUFL  AIF   ('&RECLEN' EQ '').NORECL
&R       SETC  '&RECLEN(1)'
         AIF   ('&R' NE '&RECLEN').GOTRECL
         LA    15,&RECLEN
&R       SETC  '15'
.GOTRECL ANOP
         ST    &R,GSBRECL-GSB(,1)
.NORECL  AIF   ('&MSGAREA' EQ '').NOMSG
&R       SETC  '&MSGAREA(1)'
         AIF   ('&R' NE '&MSGAREA').GOTMSG
         LA    15,&MSGAREA
&R       SETC  '15'
.GOTMSG  ANOP
         ST    &R,GSBMSGA-GSB(,1)
.NOMSG   AIF   ('&RBA' EQ '').NORBA
&R       SETC  '&RBA(1)'
         AIF   ('&R' NE '&RBA').GOTRBA
         LA    15,&RBA
&R       SETC  '15'
.GOTRBA  ANOP
         MVC   GSBRBA-GSB(4,1),0(&R)
.NORBA   AIF   ('&PASS' EQ '').NOPASS
&R       SETC  '&PASS(1)'
         AIF   ('&R' NE '&PASS').GOTPASS
         LA    15,&PASS
&R       SETC  '15'
.GOTPASS ANOP
         ST    &R,GSBPASSW-GSB(,1)
.NOPASS  AIF   ('&VERB' EQ 'MODIFY').EXIT
         AIF   ('&VERB' NE 'READ').NREAD
         XR    0,0                 INDICATE READ
         AGO   .SVC
.NREAD   AIF   ('&VERB' NE 'WRITE').NWRITE
         LA    0,1                 INDICATE WRITE
         AGO   .SVC
.NWRITE  AIF   ('&VERB' NE 'REWRITE').NREWRIT
         LA    0,2                 INDICATE REWRITE
         AGO   .SVC
.NREWRIT AIF   ('&VERB' NE 'DELETE').NDEL
         LA    0,3                 INDICATE DELETE
         AGO   .SVC
.NDEL    AIF   ('&VERB' NE 'RELEASE').NRLSE
         LA    0,4                 INIDCATE RELEASE
         AGO   .SVC
.NRLSE   AIF   ('&VERB' NE 'MONITOR').NMON
         LA    0,5                 INDICATE MONITOR
         AGO   .SVC
.NMON    AIF   ('&VERB' NE 'MAINTAIN').NMAINT
         LA    0,6                 INDICATE MAINTAIN
         AGO   .SVC
.NMAINT  AIF   ('&VERB' NE 'FINISH').VERBERR
         LA    0,7
         AGO   .SVC
.VERBERR MNOTE 8,'GSAM001E UNRECOGNIZED VERB: &VERB'
.SVC     AIF   (&GSAMSVC GT 255).FAKEIT
         SVC   &GSAMSVC            ISSUE SVC
         MEXIT
.FAKEIT  ANOP
         L     R15,=V(FAKEGSAM)    --> SUBSTITUTE ROUTINE
         BASR  R14,R15             GO PERFORM THE VSAM I/O
         MEXIT
.BADMF   MNOTE 8,'GSAM003E IMPROPER OR OMITTED ''MF'' PARAMETER'
.EXIT    MEND
         MACRO
         GSB   &DSECT=YES
.************************************************************
.*                                                          *
.* MACRO NAME = GSB                                         *
.*                                                          *
.* DESCRIPTIVE NAME = GSAM SIMULATION ROUTINE'S PARAMETER   *
.*                    BLOCK.                                *
.*                                                          *
.* PROCESSOR = ASSEMBLER XF                                 *
.*                                                          *
.************************************************************
*************************************************************
*                                                           *
*        GSB -- GSAM SVC PARAMETER BLOCK                    *
*                                                           *
*************************************************************
         SPACE 1
         IEZBITS ,
         AIF   ('&DSECT' NE 'YES').NODSECT
GSB      DSECT ,
         AGO   .YESDSEC
.NODSECT ANOP
GSB      DS    0F                  ALIGNMENT
.YESDSEC ANOP
GSBID    DC    CL4'GSB'            MUST BE FILLED IN
GSBFILE  DS    CL8                 FILE NAME DEFINED TO GSRTASK
GSBPOOL  DS    H                   VALUES 0-7. KEY OF GSR POOL.
GSBFLGW  DS    0H                  OPTION BITS FOR USER -
GSBFLG1  DS    X                    IN HALFWORD SO THEY CAN -
GSBFLGS  DS    X                     BE SET IN FORTRAN AND COBOL
GSBWAIT  EQU   BIT0                INDICATION THAT USER
*                                  WANTS TO WAIT FOR A
*                                  RECORD. APPLICABLE ONLY
*                                  IF UPDATE INDICATOR SET.
GSBUPD   EQU   BIT1                USER WANTS TO UPDATE THE
*                                  RECORD. GSAM WILL OBTAIN
*                                  OWNERSHIP OF THE RECORD
GSBASYNC EQU   BIT2                THE USER WANTS TO
*                                  ASYNCHRONOUSLY CONTEND FOR
*                                  RECORD OWNERSHIP.
*                                  GSBUPD MUST BE ON,
*                                  GSBWAIT MUST BE OFF
GSBDIR   EQU   BIT3                THIS IS A DIRECT REQUEST.
*                                  FOR A KSDS, A KEY IS IN
*                                  THE BUFFER. OTHERWISE, IT
*                                  IS IN GSBRBA.
GSBBACK  EQU   BIT4                THIS IS A 'BACKWARDS'
*                                  OPERATION. THE USER WANTS
*                                  TO SEQUENTIALLY READ RECORDS
*                                  IN DESCENDING ORDER OF KEY OR
*                                  ADDRESS. GSBDIR MUST BE OFF.
GSBPTY   EQU   BIT5                PRIORITY REQUEST. CALLER
*                                  MUST BE IN SYSTEM KEY OR
*                                  SUPERVISOR STATE. UPDATE BIT
*                                  MUST BE ON. CALLER WILL
*                                  STEAL RECORD OWNERSHIP FROM
*                                  ANYONE WHO HOLDS IT.
GSBABTRM EQU   BIT6                ABEND MY TASK WHEN GSAM
*                                  GOES DOWN OR THIS FILE IS
*                                  PURGED
GSBDEBUG EQU   BIT7                INVOKE DBC (REQUIRES AUTH
*                                  LEVEL 2 AND DEBUG FLAG)
GSBINDX  DS    H                   INDEX OF OUR GSAM PLACEHOLDER
*                                  SET TO ZERO BEFORE FIRST CALL
*                                  USER MUST NOT SUBSEQUENTLY
*                                  MODIFY THIS FIELD
GSBRSV1  DS    H                   RESERVED
GSBBUFL  DS    F                   TOTAL LENGTH OF BUFFER WHOSE
*                                  ADDRESS IS SPECIFIED IN GSBBUFA.
*                                  SPECIFIED BY USER.
*                                  ON A READ REQUEST, BUFFER IS
*                                  PADDED WITH BLANKS FOR A LENGTH OF
*                                  GSBBUFL.
*                                  CANNOT BE GREATER THAN INSTALLATION
*                                  SPECIFIED MAX.
GSBBUFA  DS    A                   -> USER BUFFER FOR READS, REWRITES,
*                                  DELETES.
*                                  IF F'-1' THEN THE MSG AREA & BUFFER
*                                  FOLLOW THE GSB (FOR LANGUAGES THAT
*                                  DO NOT SUPPORT THE PTR DATA TYPE)
GSBRECL  DS    A                   FOR READ, LENGTH OF BUFFER RETURNED
*                                  TO USER. FOR REWRITE, WRITE, LENGTH
*                                  OF RECORD, SUPPLIED BY USER.
*                                  MUST BE >0, <=GSBBUFL
GSBMSGA  DS    A                   ->128 BYTE AREA FOR RETURNING I/O
*                                  ERROR MESSAGES, OR NULL.
GSBVSAM  DS    F                   VSAM FEEDBACK CODE THAT CAUSED
*                                  THE SVC'S NON-0 RETURN CODE. 0 IF
*                                  NONE APPLIES.
*                                  OR, ON SUCCESSFUL COMPLETION,
*                                  THE VSAM FEEDBACK CODE FOR 0
*                                  RETURN CODE. (SEE VSAM MANUAL).
GSBVSFN  DS    F                   VSAM FUNCTION CODE ON LOGICAL
*                                  OR PHYSICAL ERROR. -1 WHEN NONE
*                                  APPLIES.
GSBECB   DS    A                   ECB WHICH WILL BE POSTED
*                                  WHEN ASYNCHRONOUS REQUEST FOR
*                                  RECORD OWNERSHIP COMPLETES
GSBRBA   DS    F                   RBA OF RECORD FOR READ, REWRITE,
*                                  WRITE (RETURNED BY SVC).
*                                  ONLY TRUE WHEN GSBPATH IS OFF
*                                  RBAS ARE NOT RETURNED BY VSAM FOR
*                                  A PATH.
GSBPASSW DS    CL8                 PASSWORD-FOR EXAMINATION BY
*                                  INSTALLATION EXITS
*        THE GSBFIL.. FIELDS ARE RETURNED TO THE USER
*        WHENEVER THE GSAM FILE SPECIFIED IS FOUND BY THE SVC.
GSBFILKL DS    F                   KEY LENGTH OF FILE. 0 FOR ESDS.
GSBFILKO DS    F                   KEY OFFSET IN RECS. 0 FOR ESDS.
*                                  0-INDEXED.
GSBFILRL DS    F                   MAXINUM RECORD LENGTH FOR THE FILE.
GSBFILCL DS    F                   CONTROL INTERVAL LENGTH OF FILE
*                                  (RETURNED W/ OTHER GSBFIL.. FIELDS)
GSBFILAC DS    C                   ACCESS CODE OF FILE
*                                  RETURNED WITH OTHER GSBFIL.. INFO
GSBACC1  EQU   C'1'                READ-ONLY ACCESS.
GSBACC2  EQU   C'2'                UPDATE ACCESS.
GSBACC3  EQU   C'3'                WRITE-ONLY,TO AN ESDS.
GSBFILFG DS    C                   FLAGS RETURNED,DESCRIBING FILE
*                                  (ALONG WITH OTHER GSBFIL.. FIELDS)
GSBRD    EQU   C'R'                READ ONLY
GSBWT    EQU   C'W'                WRITE ONLY
GSBRDWT  EQU   C'*'                FULL ACCESS
GSBNO    EQU   C'C'                NO ACCESS
GSBLEN   EQU   *-GSB
         SPACE 3
*************************************************************
* OPTIONAL FIELDS (IF GSBBUFA IS F'-1')                     *
*************************************************************
         SPACE 1
GSBMSGX  DS    CL128               CONTIGUOUS MESSAGE AREA
GSBBUFX  DS    0C                  CONTIGUOUS BUFFER.
         SPACE 3
*************************************************************
*        RETURN CODES TO CALLER OF GSAM SVC:                *
*        (NOTE THAT MEANINGS OF RETURN CODES DEPEND ON      *
*        THE VSAM RETURN CODE-GSBVSAM).                     *
*************************************************************
         SPACE 1
GSAMEKEY EQU   4                   KEY OR ENDFILE CONDITION
GSAMEREC EQU   8                   RECORD CONDITION
GSAMENAV EQU   12                  SOME GSR OBJECT UNAVAILABLE
GSAMEFIL EQU   16                  UNDEFINEDFILE CONDITION.
GSAMEPOS EQU   20                  POSITIONING ERROR.
GSAMEDS  EQU   24                  DATASET FULL OR BAD.
GSAMEAUT EQU   28                  AUTHORIZATION ERROR.
GSAMEACC EQU   32                  WRONG KIND OF ACCESS FOR THISFILE.
GSAMECOR EQU   36                  NOT ENOUGH CORE AVAILABLE.
GSAMEPRM EQU   40                  PARMS BAD OR INCONSISTANT.
GSAMEIO  EQU   44                  I/O PHYSICAL ERROR
GSAMEBUG EQU   48                  BUG IN THE SVC
GSAMEUBG EQU   52                  BUG IN INSTALLATION EXIT
         MEND
         MACRO
&NME     SFR   &MF=D
.*
.*     MODIFICATION HISTORY
.*
.*     07/86 MDL ADDED EQUATES TO SUPPORT NEW WEEKDAY FEATURES:
.*               SFRWKXCT - WEEKDAY IS CURRENT DAY
.*               SFRWKNOT - WEEKDAY IS NOT CURRENT DAY
.*
         LCLC  &D
         AIF   ('&MF(1)' EQ 'L').MFL
         AIF   ('&MF(1)' EQ 'D').MFD
         MNOTE 8,'MF(1)=&MF(1) IS INVALID. MF(1)=D IS ASSUMED.'
.MFD     ANOP
&D       SETC  'DSECT'
         AIF   ('&MF(2)' EQ '').MFDOK3
         AIF   ('&MF(2)'(1,1) EQ 'Y').MFDOK3
&D       SETC  'DS'
         AIF   ('&MF(2)'(1,1) EQ 'N').MFDOK3
         MNOTE 8,'MF=&MF IS INVALID. MF=(&MF(1),N) IS ASSUMED.'
.MFDOK3  ANOP
*************************************************************
*                                                           *
*        SFR -- SCHEDULE FILE RECORD                        *
*                                                           * 02/84 DBC
*        ALL TIMESTAMPS IN THE SCHEDULE FILE ARE LOCAL      * 02/84 DBC
*        TIME.                                              * 02/84 DBC
*                                                           *
*        A NEW SCHEDULE FILE CAN BE ALLOCATED VIA AN AMS    *
*        COMMAND SUCH AS THE FOLLOWING:                     *
*                                                           *
*        DEF CL(NAME('SYSVSAM.SCHEDULE') VOL(SYSRES) -      *
*            ATT(3) CODE(SCHEDULE) ERAS KEYS(12 0) -        *
*            OWNER(DAVECOLE) TO(99365) UNQ MRPW(XYZZY) -    *
*            RDPW(SCHEDULE)) -                              *
*                                                           *
*            DATA(NAME('SYSVSAM.SCHEDULE.DATA')-            *
*            RECORDS(1000 100) RECSZ(X'48' X'12D')) -       *
*                                                           *
*            INDEX(NAME('SYSVSAM.SCHEDULE.INDEX'))          *
*                                                           *
*************************************************************
         SPACE 1
         AIF   ('&NME' EQ '').MFDOK1
&NME     &D    0H
SFR      DS    0H                  MAP NAME
         AGO   .MFDOK2
.MFDOK1  ANOP
SFR      &D    0H
.MFDOK2  ANOP
SFRYR    DS    H                   SCHEDULED YEAR
SFRMO    DS    H                   SCHEDULED MONTH
SFRDY    DS    H                   SCHEDULED DAY
SFRYMD   EQU   SFRYR,*-SFRYR       DATE SEGMENT
SFRHR    DS    H                   SCHEDULED HOUR
SFRMN    DS    H                   SCHEDULED MINUTE
SFRHM    EQU   SFRHR,*-SFRHR       TIME-OF-DAY SEGMENT
SFRTIME  EQU   SFRYR,*-SFRYR       SCHEDULED TIME
SFRID    DS    H                   UNIQUE IDENTIFICATION NUMBER
SFRKEY   EQU   SFRYR,*-SFRYR       RECORD'S KEY FIELD
SFRNAME  DS    CL8                 APPLICATION NAME
         SPACE 1
SFRWK    DS    H                   SCHEDULED DAY OF THE WEEK
         SPACE 1
SFRWKNOT EQU   B'10000000'            EXACT WEEKDAY MATCHING    7/86MDL
SFRWKXCT EQU   B'01000000'            EXACT WEEKDAY MATCHING    7/86MDL
         SPACE 1
SFRXYR   DS    H                   YEAR OF LAST EXECUTION
SFRXMO   DS    H                   MONTH OF LAST EXECUTION
SFRXDY   DS    H                   DAY OF LAST EXECUTION
SFRXYMD  EQU   SFRXYR,*-SFRXYR     DATE SEGMENT
SFRXHR   DS    H                   HOUR OF LAST EXECUTION
SFRXMN   DS    H                   MINUTE OF LAST EXECUTION
SFRXHM   EQU   SFRXHR,*-SFRXHR     TIME-OF-DAY SEGMENT
SFRXTIME EQU   SFRXYR,*-SFRXYR     LAST EXECUTION TIME
         SPACE 1
SFRWHR   DS    H                   LENGTH OF EXECUTION WINDOW: HOURS
SFRWMN   DS    H                   LENGTH OF EXECUTION WINDOW: MINUTES
         SPACE 1
SFRSYSID DS    CL4                 SMF-SYSID OF SYSTEM ON WHICH THIS
*                                  COMMAND MAY BE EXECUTED. X'0000'
*                                  IMPLIES "ANY" SYSTEM.
         SPACE 1
SFRFLAG  DS    B                   FLAG BYTE
SFRFIPLF EQU   B'10000000'         FORCE REEXECUTION OF THIS COMMAND
*                                  IF AN IPL OCCURS WITHIN THE CURRENT
*                                  WINDOW EVEN IF THIS COMMAND HAS
*                                  ALREADY BEEN EXECUTED IN THIS SAME
*                                  WINDOW.
SFRFOVRD EQU   B'01000000'         THIS COMMAND OVERRIDES ALL OTHER
*                                  COMMANDS FOR THIS APPLICATION FOR
*                                  THIS DATE FOR WHICH THIS FLAG IS
*                                  OFF.
SFRFOBSO EQU   B'00100000'         THIS COMMAND IS OBSOLETE. (SET BY
*                                  SCHEDRUN. CHECKED BY SCHEDULE).
         SPACE 1
SFRCMDL  DS    2H                  L'COMMAND TEXT, ZERO
SFRCMD   DS    CL255               COMMAND TEXT
         SPACE 1
SFREND   EQU   *                   MAX END OF SFR
SFRLEN   EQU   SFREND-SFR          MAX L'SFR
         SPACE 3
*************************************************************
*        SCHEDULE FILE'S MASTER RECORD                      *
*************************************************************
         SPACE 1
         ORG   SFR                 LOCATE TO START OF BUFFER
SFMR     DS    0H
SFMRKEY  DS    XL(L'SFRKEY)       KEY (ALL HEX-FF)
SFMRFID  DC    CL8'SCHEDULE'     V FILE ID
SFMRNXID DS    H                   NEXT DATA RECORD ID VALUE
SFMREND  EQU   *                   EO-SFMR
SFMRLEN  EQU   SFMREND-SFMR        L'SFMR
         ORG   SFREND              RELOCATE HIGH
         MEXIT
.*
.MFL     AIF   ('&MF(2)' EQ '').MFLD
         AIF   ('&MF(2)'(1,1) EQ 'M').MFLM
         MNOTE 8,'MF=&MF IS INVALID. MF=L IS ASSUMED'
.MFLD    ANOP
&NME     DS    0H
         DC    5H'0'               SCHEDULED TIME
         DC    2H'0'               SFRID, SFRWK
         DC    5H'0'               LAST EXECUTION TIME
         DC    2H'0'               EXECUTION WINDOW
         DC    CL4' '              APPLICATION NAME
         DC    B'00000000'         FLAG BYTE
         DC    2H'0'               SFRCMDL
         DC    CL255' '            SFRCMD
         MEXIT
.*
.MFLM    ANOP
&NME     DS    0H
         DC    (L'SFMRKEY)X'FF'    SFMRKEY
         DC    CL(L'SFMRFID)'SCHEDULE' SFMRFID
         DC    H'0'                SFMRNXID
         MEND
