DIS1     TITLE '*** DISASSEMBLY PHASE 1 ***'
         PRINT OFF                                                 -EU-
         COPY  DISASMM                                             -EU-
         PRINT ON                                                  -EU-
DISASM1  SVLNK R3,R4
         EJECT
         PRINT NOGEN
* THIS SUB-PROGRAM IS CALLED BY DISASM, AND IS PHASE 2 OF
* THE DISASSEMBLY PROCESS. A COMMON DATA
* AREA IS DEFINED IN DISASM, AND PASSED TO THIS PROGRAM.
*
*    THE SYSIN FILE IS READ TO EXHAUSTION. USING CARDS ARE
* REFORMATTED AND STORED IN A TABLE - UP TO 256 USING
* STATEMENTS MAY BE ENTERED. DSECT CARDS MAY FOLLOW THE
* USING STATEMENTS. WHEN USED, DSECT STATEMENTS ARE
* REFORMATTED, AND BUILT INTO TABLES. A MAXIMUM OF 256 DSECTS
* MAY BE ENTERED. DATA ONLY CARDS MAY BE INCLUDED BEFORE, BETWEEN,
* OR AFTER DSECTS TO SHOW AREAS IN THE PROGRAM WHERE NO INSTRUCTIONS
* OCCUR. UP TO 256 DATA ONLY AREAS MAY BE SPECIFIED.
*
*     AT EOF ON SYSIN, A PSEUDO DIS-ASSEMBLY PASS IS MADE
* USING THE TEXT STORED BY DISASM. ANY RESOLVABLE ADDRESS
* WITHIN THE TEXT IS USED TO CREATE A NEW ENTRY IN THE
* LABEL TABLE, WHICH WILL BE USED BY DISASM2 IN THE
* ACTUAL DIS-ASSEMBLY PASS.
*
* THE USING CARDS FOR BASE REGISTERS ASSOCIATED WITH DSECT DEFINITIONS
* MUST BE ENTERED AT SOME POINT AFTER THE DSECT CARDS HAVE BEEN
* INCLUDED. USING CARDS FOR PROGRAM BASE REGISTERS MAY BE ENTERED
* AT ANY POINT. THE USING CARD FORMAT IS:
*       COL 1-5   : LITERAL 'USING'
*       COL 6     : BLANK
*       COL 7-12  : OFFSET TO BEGIN LOCATION FOR USING RANGE (HEX)
*       COL 13    : BLANK
*       COL 14-19 : OFFSET TO ENDING LOCATION FOR USING RANGE (HEX)
*       COL 20    : BLANK
*       COL 21    : BASE RESISTER TO BE USED (HEX, 1-F)
*       COL 22    : BLANK
*       COL 23    : TYPE, P=PROGRAM BASE, D=DSECT BASE
*       COL 24    : BLANK
*       COL 25-30 : INITIAL BASE REGISTER VALUE IF TYPE P (HEX)
*       COL 25-32 : DSECT NAME IF TYPE D
*
*     A DSECT IS ENTERED USING A HEADER CARD,FOLLOWED BY
* ONE OR MORE FIELD DEFINITION CARDS. ALL FIELD DEFINITION
* CARDS MUST FOLLOW THE DSECT HEADER CARD. USING CARDS MAY
* NOT BE INTERSPERSED WITH DSECT DEFINITIONS, BUT MAY PRECEDE
* OR FOLLOW ANY DSECT.
*     DSECT HEADER CARD FORMAT:
*        COL 1-8    : DSECT NAME
*        COL 9      : BLANK
*        COL 10-14  : LITERAL 'DSECT'
*        COL 15     : BLANK
*        COL 16-19  : NUMBER OF FIELD CARDS TO FOLLOW (DECIMAL)
*
*     DSECT FIELD CARD FORMAT:
*        COL 1-8    : FIELD NAME
*        COL 9      : BLANK
*        COL 10-13  : OFFSET TO LEFT END OF FIELD (DECIMAL)
*        COL 14     : BLANK
*        COL 15-17  : LENGTH OF FIELD IN BYTES (DECIMAL)
*
*     A DATA ONLY CARD IS USED TO DESIGNATE A RANGE OF OFFSETS
* BETWEEN WHICH NO INSTRUCTIONS EXIST. USE OF THESE CARDS ELIMINATES
* THE CHANCE THAT DATA ELEMENTS WILL BE TREATED AS INSTRUCTIONS
* BETWEEN THE OFFSETS SPECIFIED. FORMAT IS:
*        COL 1-4    : LITERAL 'DATA'
*        COL 5      : BLANK
*        COL 6-11   : OFFSET TO BEGINNING OF AREA (HEX)
*        COL 12     : BLANK
*        COL 13-18  : OFFSET TO END OF AREA (HEX)
*
*
*     USER LABEL CARDS ARE USED TO PERMIT SPECIFICATION OF
* LABELS OTHER THAN THE AXXXXXX NAMES CREATED BY DISASM. THEY
* MAY APPEAR ANYWHERE IN THE SYSIN STREAM EXCEPT AS THE FIRST
* CARD, OR WITHIN A DSECT DEFINITION.
*        COL  1-5  : LITERAL 'ULABL'
*        COL   6   : BLANK
*        COL  7-14 : FIELD NAME
*        COL   15  : BLANK
*        COL 16-21 : OFFSET TO LEFT END OF AREA (HEX)
*        COL   22  : BLANK
*        COL 23-25 : FIELD LENGTH (DECIMAL)
*
*      DISASSEMBLY TABLES ARE SET UP IDENTICALLY TO THOSE USED BY
* DISASM2 FOR THE SIMULATED DISASSEMBLY PERFORMED IN THIS
* MODULE WHEN ANY PROGRAM BASE REGISTER USING STATEMENTS
* ARE ENTERED.
*
*     STORAGE IS OBTAINED FOR THE DSECT TABLE AND USING TABLE,
* AND ADDRESSES OF THESE TABLES ARE STORED IN THE COMMON PARAMETER
* AREA. USING AND DSECT CARDS ARE EDITED, REFORMATTED, AND PLACED
* IN THE APPROPRIATE TABLES. IF ANY ERRORS ARE FOUND, THEY ARE
* PRINTED, AND THE DISASSEMBLY WILL BE TERMINATED ON RETURN
* TO DISASM.
*
*     STORAGE IS OBTAINED FOR THE LABEL TABLE, AND A SIMULATED
* DIS-ASSEMBLY IS PERFORMED TO CREATE LABEL TABLE ENTRIES FOR
* LABELS WHICH WILL BE GENERATED FOR BASE-DISPLACEMENT ADDRESSES
* BY DISASM2. ON RETURN TO DISASM, THESE LABELS WILL BE SORTED
* WITH EXTERNAL SYMBOL AND RLD LABELS TO FORM THE FINAL LABEL
* TABLE TO BE USED BY DISASM2.
*
*
* AUTHOR R THORNTON - FEB 1978
*        UPDATES (MARKED -EU- IN COLUMNS 68-71) DONE BY            -EU-
*        MOINIL P.A. , COMPUTING CENTRE                            -EU-
*                      J.R.C. - ISPRA ESTABLISHMENT                -EU-
*                      21020 ISPRA (VA), ITALY                     -EU-
         EJECT
******************************************************************
*                                                                *
* GET STORAGE FOR USING AND DSECT POINTER TABLES.                *
*                                                                *
******************************************************************
         SPACE 1
         L     R5,0(R1)                GET PARM FIELD ADDRESS
         USING COMMPARM,R5
         L     R0,USGLGTH              USING TABLE LENGTH          -EU-
         GETMAIN R,LV=(0)              GET STORAGE FOR USING TABLE -EU-
         MVI   0(R1),X'FF'             SET TABLE END INDIC
         ST    R1,USGSTRT              SAVE TABLE START ADDRESS
         ST    R1,USGCUR               SET TABLE CURRENT ADDRESS
         A     R1,USGLGTH              COMPUTE TABLE END ADDRESS   -EU-
         SH    R1,H8                                               -EU-
         ST    R1,USGEND               SAVE USING TABLE END ADDRESS
         L     R0,DTBLGTH              DSECT TABLE LENGTH          -EU-
         GETMAIN R,LV=(0)              GET STORAGE FOR DSECT TABLE -EU-
         MVI   0(R1),X'FF'             SET TABLE END ADDRESS
         ST    R1,DTBSTRT              SAVE DSECT TABLE START ADDRESS
         ST    R1,DTBCURR              SAVE DSECT TABLE CURRENT ADDRESS
         A     R1,DTBLGTH              COMPUTE TABLE END ADDRESS   -EU-
         SH    R1,H8                                               -EU-
         ST    R1,DTBEND               SAVE DSECT TABLE END ADDRESS
         L     R2,INDCB                @ SYSIN DCB                 -EU-
         USING IHADCB,R2                                           -EU-
         LA    R1,EOFCARD              GET EOF ADDRESS
         STCM  R1,B'0111',DCBEODA      SET EOF ADDRESS IN DCB
         TM    DCBOFLGS,DCBOFOPN       IS IT OPEN
         BZ    EOFCARD                 NO
         DROP  R2                                                  -EU-
         EJECT
******************************************************************
*                                                                *
* READ SYSIN CARDS, AND DISTRIBUTE TO THE APPROPRIATE PROCESSING *
* ROUTINE: USINGS, DSECTS, OR DATAS. DETECT ANY ERRORS AND PRINT *
* ALL CARDS WITH MESSAGES AS NECESSARY.                          *
*                                                                *
******************************************************************
         SPACE 1
RDCARD   L     R1,INDCB                GET SYSIN DCB ADDR
         GET   (1)                     READ NEXT CARD
         MVC   WORKREC,0(R1)           MOVE IT TO WORK AREA
         NOP   MVPRT                   FIRST TIME SWITCH
         MVI   *-3,C'0'                RESET FIRST TIME SWITCH
         MVI   PCC,C'1'                SET SKIP TO HEAD
         MVC   PRT+10(26),=C'*** USER ENTERED CARDS ***'
         BAS   R9,PRINT                GO PRINT
MVPRT    MVC   PRT(80),WORKREC         CARD TO PRINT
RDGRTN   LA    R9,RCCKERR              GET RETURN ADDRESS
         CLC   WORKREC(5),=C'USING'    IS IT A USING CARD
         BE    USINGS                  YES
         CLC   WORKREC+9(5),=C'DSECT'  IS IT A DSECT HEADER
         BE    DSECTS                  YES
         CLC   WORKREC(4),=C'DATA'     IS IT DATA ONLY CARD
         BE    DATAS                   YES
         CLC   WORKREC(5),=C'ULABL'    IS IT A USER LABEL
         BE    ULABLS                  YES
         MVC   PRT+85(21),=C'UNIDENT OR OUT OF SEQ'
         MVI   USERR,X'FF'             SET ERROR FLAG
RCCKERR  NI    USERR,X'FE'             RESET CURRENT ERROR FLAG
         BAS   R9,PRINT                GO PRINT
         B     RDCARD                  CONTINUE
         EJECT
******************************************************************
*                                                                *
* EDIT USING CARDS FOR VALIDITY. PUT APPROPRIATE COMMENT IN PRINT*
* LINE WHEN INVALID. WHEN NO ERRORS FOUND, CREATE AN ENTRY IN THE*
* USING TABLE.                                                   *
*                                                                *
******************************************************************
         SPACE 1
USINGS   L     R12,USGCUR              GET CURRENT USING TBL ADDR
         C     R12,USGEND              END OF TBL
         BNL   UERR6                   YES, TABLE FULL
         USING USINGD,R12
         LM    R10,R11,=A(TRHEX,TRTHEX)                            -EU-
         TR    WORKREC+6(6),0(R10)     TRANSLATE TO MAKE HEX       -EU-
         TRT   WORKREC+6(6),0(R11)     CHECK VALID                 -EU-
         BNZ   UERR1                   INVALID BEGIN ADDR
         TR    WORKREC+13(6),0(R10)    TRANSLATE TO MAKE HEX       -EU-
         TRT   WORKREC+13(6),0(R11)    CHECK VALID                 -EU-
         BNZ   UERR2                   INVALID END ADDR
         TR    WORKREC+20(1),0(R10)    TRANSLATE TO MAKE HEX       -EU-
         TRT   WORKREC+20(1),0(R11)    CHECK VALID                 -EU-
         BNZ   UERR3                   INVALID BASE REG
         CLI   WORKREC+20,0            VALID BASE REG
         BE    UERR3                   NO
         CLI   WORKREC+22,C'P'         VALID TYPE
         BE    CKINIT                  YES, PROGRAM BASE
         CLI   WORKREC+22,C'D'         VALID TYPE
         BNE   UERR8                   NO, ERROR
         L     R1,DTBSTRT              GET DSECT TABLE STRT
         USING DTDS,R1                                             -EU-
CKDSEND  CLI   0(R1),X'FF'             END OF TABLE
         BE    UERR5                   YES, MISSING DSECT
         CLC   DTNAME(8),WORKREC+24    THIS THE DSECT ENTRY        -EU-
         BE    USDSMV                  YES
         LA    R1,L'DTL(R1)            TO NEXT ENTRY               -EU-
         B     CKDSEND                 LOOP THRU DSECT TABLE
USDSMV   MVC   USVALU,DTADDR           MOVE DSECT TBL ADDR
         B     USFINI                  CONTINUE
         DROP  R1                                                  -EU-
CKINIT   TR    WORKREC+24(6),0(R10)    TRANSLATE TO MAKE HEX       -EU-
         TRT   WORKREC+24(6),0(R11)    CHECK VALIDITY              -EU-
         BNZ   UERR4                   INVALID BASE REG VALUE
         PACK  DBLWD(4),WORKREC+24(7)  PACK TO MAKE HEX
         MVC   USVALU,DBLWD            BASE REG VALUE TO USING TBL
USFINI   PACK  DBLWD(4),WORKREC+6(7)   PACK TO MAKE HEX
         MVC   USBGN,DBLWD             BEGIN ADDR TO USING TABLE
         PACK  DBLWD(4),WORKREC+13(7)  PACK TO MAKE HEX
         MVC   USEND,DBLWD             END ADDR TO USING TABLE
         TM    USEND+2,1               IS IT ODD
         BO    UERR2                   YES, ERROR
         CLI   WORKREC+22,C'D'         DSECT BASE
         BE    USFREG                  YES
         CLC   USEND,LENGTH+1          WITHIN PROGRAM
         BH    UERR2                   YES, ERROR
USFREG   MVC   USREG,WORKREC+20        BASE REG TO USING TABLE
         MVC   USTYPE,WORKREC+22       TYPE TO USING TABLE
         CLC   USBGN,USEND             END < BEGIN
         BH    UERR7                   YES, ERROR
         LA    R12,L'USING(R12)        TO NEXT USING TBL ENTRY
         MVI   0(R12),X'FF'            SET TABLE END INDIC
         ST    R12,USGCUR              SAVE UPDATED TABLE ADDR
         BR    R9                      EXIT
UERR1    MVC   PRT+85(22),=C'INVALID BEGIN COL 7-12'
         B     UERRS                   CONTINUE
UERR2    MVC   PRT+85(21),=C'INVALID END COL 14-19'
         B     UERRS                   CONTINUE
UERR3    MVC   PRT+85(18),=C'INVALID REG COL 21'
         B     UERRS                   CONTINUE
UERR4    MVC   PRT+85(25),=C'INVALID ADDRESS COL 25-30'
         B     UERRS                   CONTINUE
UERR5    MVC   PRT+85(25),=C'UNDEFINED DSECT COL 25-32'
         B     UERRS                   CONTINUE
UERR6    MVC   PRT+85(20),=C'OVER 256 USING CARDS'
         B     UERRS                   CONTINUE
UERR7    MVC   PRT+85(16),=C'END BEFORE BEGIN'
         B     UERRS                   CONTINUE
UERR8    MVC   PRT+85(19),=C'INVALID TYPE COL 23'
UERRS    MVI   USBGN,X'FF'             INSURE TABLE END INDIC
         MVI   USERR,X'FF'             SHOW ERROR
         BR    R9                      EXIT
         DROP  R12
         EJECT
******************************************************************
*                                                                *
* EDIT ULABL CARDS FOR VALIDITY. PUT APPROPRIATE COMMENT IN PRINT*
* LINE WHEN INVALID. WHEN NO ERRORS FOUND, CREATE AN ENTRY IN THE*
* LABEL TABLE. SEARCH FOR ANY TYPE A (ADCON) ENTRIES HAVING A    *
* SYMBOL OF AXXXXXX, WHERE XXXXXX IS THE HEX OFFSET TO THE USER  *
* LABEL. IF AN A TYPE ENTRY IS FOUND, CHANGE ITS SYMBOLIC NAME TO*
* THAT OF THE USER LABEL.                                        *
*                                                                *
******************************************************************
         SPACE 1
ULABLS   STM   R6,R12,ULSAV            SAVE REGS
         CLI   WORKREC+6,C' '          NAME VALID
         BE    ULERR1                  NO, 1ST CHAR CANNOT BE BLANK
         MVC   UNAME+1(6),WORKREC+15   BUILD AXXXXXX NAME
         LM    R10,R11,=A(TRHEX,TRTHEX)                            -EU-
         TR    WORKREC+15(6),0(R10)    TRANSLATE TO MAKE HEX       -EU-
         TRT   WORKREC+15(6),0(R11)    CHECK VALID HEX             -EU-
         BNZ   ULERR2                  NOT VALID
         MVZ   NUMCK,WORKREC+22        ZONES FOR NUMERIC TEST
         CLC   NUMCK(3),ZEROS          LENGTH IS NUMERIC
         BNE   ULERR3                  NO, ERROR
         L     R6,CURRLBL              GET CURRENT LABEL TABLE ADDRESS
         USING LABELD,R6
         C     R6,ENDLBL               END OF TABLE
         BNL   ULERR4                  YES, ERROR
         MVC   LBLNAME,WORKREC+6       NAME TO LABEL ENTRY
         MVI   LBLTYP,C'U'             TYPE TO LABEL ENTRY
         PACK  DBLWD,WORKREC+22(3)     PACK LENGTH
         CP    DBLWD,P256              LENGTH > 256
         BH    ULERR2                  YES, ERROR
         CVB   R12,DBLWD               CONVERT TO BINARY
         STC   R12,LBLLEN              LENGTH TO LABEL ENTRY
         PACK  DBLWD(4),WORKREC+15(7)  PACK TO MAKE VALID HEX
         MVC   LBLADR,DBLWD            OFFSET TO LABEL
         LA    R7,L'LABEL(R6)          @ NEXT LABEL ENTRY
         MVC   0(3,R7),HIVAL           SET END INDIC
         ST    R7,CURRLBL              SET NEW TABLE END ADDR
         LR    R7,R6                   SAVE NEW ENTRY ADDRESS
         L     R6,LBLTBL               GET 1ST LABEL ENTRY ADDR
ULBCKND  C     R6,CURRLBL              END OF TABLE
         BNL   ULXIT                   YES, EXIT
         CLI   LBLTYP,C'A'             IS IT ADCON ENTRY
         BNE   ULBSTEP                 NO
         CLC   LBLNAME,UNAME           ADCON SYMBOL AT USER LBL ADDR
         BNE   ULBSTEP                 NO
         MVC   LBLNAME,LBLNAME-LABEL(R7) SET USER SYMBOL IN ADCON
ULBSTEP  LA    R6,L'LABEL(R6)          TO NEXT LABEL ENTRY
         B     ULBCKND                 LOOP THRU LABEL TABLE
         B     ULXIT                   EXIT
ULERR1   MVC   PRT+85(21),=C'INVALID NAME COL 7-14'
         B     ULERRS                  CONTINUE
ULERR2   MVC   PRT+85(28),=C'INVALID HEX OFFSET COL 16-21'
         B     ULERRS                  CONTINUE
ULERR3   MVC   PRT+85(32),=C'INVALID DECIMAL LENGTH COL 23-25'
         B     ULERRS                  CONTINUE
ULERR4   MVC   PRT+85(20),=C'LABEL TABLE OVERFLOW'
ULERRS   MVI   USERR,X'FF'             SET ERROR FLAG
ULXIT    LM    R6,R12,ULSAV            RESTORE REGS
         BR    R9                      EXIT
         EJECT
******************************************************************
*                                                                *
* EDIT DSECT CARDS FOR VALIDITY. PUT APPROPRIATE COMMENT IN PRINT*
* LINE WHEN INVALID. WHEN NO ERRORS FOUND, CREATE AN ENTRY IN THE*
* DSECT HEADER TABLE, GETMAIN AN AREA TO CONTAIN THE FIELD       *
* DESCRIPTION ENTRIES, READ AND BUILD FIELD ENTRIES FOR ALL FIELD*
* DESCRIPTION CARDS ENTERED.                                     *
*                                                                *
******************************************************************
         SPACE 1
DSECTS   ST    R9,DSCT9                SAVE RETURN ADDR
         CLI   WORKREC,C' '            NAME IS BLANK
         BE    DSERR1                  YES, ERROR
         MVZ   NUMCK,WORKREC+15        ZONES FOR CHECK
         CLC   NUMCK,ZEROS             IS NBR FIELDS NUMERIC
         BNE   DSERR2                  NO, ERROR
         L     R12,DTBCURR             GET CURRENT DSECT TBL ADDR
         C     R12,DTBEND              AT END OF TABLE
         BNL   DSERR5                  YES, ERROR                  -EU-
         USING DTDS,R12                                            -EU-
         MVC   DTNAME(8),WORKREC       NAME TO DSECT TABLE         -EU-
         PACK  DBLWD,WORKREC+15(4)     PACK NBR ENTRIES
         CVB   R10,DBLWD               CONVERT TO BINARY
         LA    R10,4(R10)              ADD FOR SAFETY
         MH    R10,DTBLEN              TIMES ENTRY LENGTH
         STCM  R10,B'0111',DTLGTH      FIELD TABLE LENGTH          -EU-
         GETMAIN R,LV=(R10)            GET STORAGE FOR FIELD TABLE -EU-
         STCM  R1,B'0111',DTADDR       SAVE FIELD TABLE ADDRESS    -EU-
         LA    R12,L'DTL(R12)          TO NEXT DSECT TABLE ENTRY   -EU-
         ST    R12,DTBCURR             UPDATE CURRENT DSECT TBL ADDR
         MVI   0(R12),X'FF'            SET END INDIC
         DROP  R12                                                 -EU-
         LR    R12,R1                  COPY FIELD TABLE ADDR
         BAS   R9,PRINT                PRINT DSECT RECORD
         USING DSECTD,R12
         CVB   R11,DBLWD               NBR ENTRIES IN LOOP REG
RDFLD    L     R1,INDCB                GET SYSIN DCB ADDR
         GET   (1)                     READ NEXT CARD
         MVC   WORKREC,0(R1)           MOVE RECORD TO WORK AREA
         MVC   PRT(80),WORKREC         MOVE RECORD TO PRINT AREA
         CLI   WORKREC,C' '            NAME FIELD BLANK
         BE    DSERR1                  YES, ERROR
         MVC   DSNAME,WORKREC          NAME TO ENTRY
         MVI   DSLBTYP,C'L'            SET LABEL TYPE
         MVZ   NUMCK,WORKREC+9         ZONES FOR TEST
         CLC   NUMCK,ZEROS             IS OFFSET NUMERIC
         BNE   DSERR3                  NO, ERROR
         PACK  DBLWD,WORKREC+9(4)      PACK OFFSET
         CP    DBLWD,P4096             OFFSET > 4096
         BH    DSERR3                  YES, ERROR
         CVB   R1,DBLWD                CONVERT
         STCM  R1,B'0111',DSOFSET      OFFSET TO TABLE ENTRY
         MVZ   NUMCK(3),WORKREC+14     ZONES FOR TEST
         CLC   NUMCK(3),ZEROS          IS LENGTH NUMERIC
         BNE   DSERR4                  NO, ERROR
         PACK  DBLWD,WORKREC+14(3)     PACK LENGTH
         CP    DBLWD,P256              LENGTH OVER 256
         BH    DSERR4                  YES, ERROR
         CVB   R1,DBLWD                CONVERT
         LTR   R1,R1                   LENGTH IS ZERO
         BZ    DSERR4                  YES, ERROR
         STC   R1,DSLENG               LENGTH TO TABLE ENTRY
         LA    R12,L'DSECT(R12)        TO NEXT ENTRY
         MVI   0(R12),X'FF'            SET TBL END INDIC
         BAS   R9,PRINT                GO PRINT CARD
         BCT   R11,RDFLD               LOOP THRU DSECT
         MVC   DSOFSET,HIVAL           TABLE STOPPER
         L     R9,DSCT9                GET RETURN ADDR
         BR    R9                      EXIT
DSERR1   MVC   PRT+85(20),=C'INVALID NAME COL 1-8'
         B     DSERRS                  CONTINUE
DSERR2   MVC   PRT+85(28),=C'INVALID NBR FIELDS COL 16-19'
         B     DSERRS                  CONTINUE
DSERR3   MVC   PRT+85(24),=C'INVALID OFFSET COL 10-13'
         B     DSERRS                  CONTINUE
DSERR4   MVC   PRT+85(24),=C'INVALID LENGTH COL 15-18'
         B     DSERRS                  CONTINUE
DSERR5   MVC   PRT+85(20),=C'OVER 256 DSECT CARDS'                 -EU-
DSERRS   MVI   USERR,X'FF'             SHOW ERROR FOUND
         L     R9,DSCT9                GET RETURN ADDR
         BR    R9                      EXIT
         DROP  R12
         EJECT
******************************************************************
*                                                                *
* EDIT DATA ONLY CARDS FOR VALIDITY. PLACE ERROR DESCRIPTION IN  *
* PRINT LINE IF ERRORS FOUND. CREATE DATA ONLY TABLE ENTRY IF NO *
* ERRORS ARE FOUND.                                              *
*                                                                *
******************************************************************
         SPACE 1
DATAS    LM    R10,R11,=A(TRHEX,TRTHEX)                            -EU-
         TR    WORKREC+5(6),0(R10)     TRANSLATE TO MAKE HEX       -EU-
         TRT   WORKREC+5(6),0(R11)     CHECK VALID                 -EU-
         BNZ   DERR1                   INVALID HEX
         TR    WORKREC+12(6),0(R10)    TRANSLATE TO MAKE HEX       -EU-
         TRT   WORKREC+12(6),0(R11)    CHECK VALID                 -EU-
         BNZ   DERR2                   INVALID HEX
         PACK  DBLWD(4),WORKREC+5(7)   PACK TO MAKE HEX
         PACK  DBLWD+4(4),WORKREC+12(7) PACK TO MAKE HEX
         CLC   DBLWD(3),DBLWD+4        CHECK 1ST LOW
         BNL   DERR3                   1ST NOT LOW, ERROR
         L     R1,DATOCUR              GET TBL ADDRESS
         CL    R1,DATOEND              END OF DATA ONLY TABLE      -EU-
         BNL   DERR4                   YES, ERROR                  -EU-
         MVC   0(3,R1),DBLWD           MOVE 1ST OFFSET TO TBL
         MVC   3(3,R1),DBLWD+4         MOVE 2ND OFFSET TO TBL
         LA    R1,6(R1)                TO NEXT ENTRY
         ST    R1,DATOCUR              SAVE CURRENT ENTRY ADDRESS
         BR    R9                      EXIT
DERR1    MVC   PRT+85(22),=C'1ST OFFSET INVALID HEX'
         B     DERRS                   CONTINUE
DERR2    MVC   PRT+85(22),=C'2ND OFFSET INVALID HEX'
         B     DERRS                   CONTINUE
DERR3    MVC   PRT+85(23),=C'END OFFSET BEFORE BEGIN'
         B     DERRS                   CONTINUE                    -EU-
DERR4    MVC   PRT+85(19),=C'OVER 256 DATA CARDS'                  -EU-
DERRS    MVI   USERR,X'FF'             FLAG ERROR
         BR    R9                      EXIT
         EJECT
******************************************************************
*                                                                *
* CHECK FOR ANY USING CARDS ENTERED. IF NOT, NO PRE-ASSEMBLY IS  *
* NECESSARY. IF ANY USING CARDS FOUND, CREATE LABEL TABLE ENTRIES*
* SO THAT USING STATEMENTS WILL BE VALID.                        *
*                                                                *
******************************************************************
         SPACE 1
EOFCARD  CLI   USERR,0                 ANY ERRORS FOUND
         BNE   EOJ                     YES, EXIT
         L     R1,DATOCUR              GET CURRENT DATA ONLY @
         MVC   NOINAD,DATONLY          SAVE DATA ONLY TBL ADDR
         MVC   0(3,R1),HIVAL           SET END
         L     R11,USGSTRT             GET USING TBL ADDR
CUSNGND  CLI   0(R11),X'FF'            END OF TABLE
         BE    CUSCKPRE                GO CHECK FOR PRE-DISASM
         L     R10,CURRLBL             GET LABEL ADDRESS
         USING USINGD,R11
         CLI   USTYPE,C'D'             IS IT A DSECT               -EU-
         BE    CUSNEXT                 YES, BYPASS                 -EU-
         USING LABELD,R10
         MVC   LBLADR,USVALU           OFFSET TO LABEL
         MVI   LBLTYP,C'L'             LABEL TYPE ENTRY
         MVI   LBLLEN,1                SET LENGTH TO 1
         MVI   LBLNAME,C'A'            1ST CHAR OF NAME
         LA    R12,USVALU              @ OFFSET
         BAS   R9,HEXPRT3              CONVERT
         MVC   LBLNAME+1(6),PRTABL     MIDDLE OF NAME
         MVI   LBLNAME+7,C' '          BLANK LAST POS
         LA    R10,L'LABEL(R10)        STEP TO NEXT LABEL
         ST    R10,CURRLBL             SAVE IN CURRLBL     FIX******
         MVC   0(3,R10),HIVAL          SET END VALUE       FIX******
CUSNEXT  LA    R11,L'USING(R11)        STEP TO NEXT USING          -EU-
         B     CUSNGND                 LOOP
         DROP  R10
         DROP  R11
CUSCKPRE L     R1,USGSTRT              GET USING TBL START ADDR
         CLI   0(R1),X'FF'             ANY ENTRIES
         BE    EOJ                     NO, GET OUT                 -EU-
         BAS   R9,COMPLBL              SORT/COMPRESS LABEL TBL     -EU-
         EJECT
******************************************************************
*                                                                *
* MAINLINE ROUTINE FOR THE PRE-DISASSEMBLY. PURPOSE OF THIS PART *
* OF THE PROGRAM IS TO ATTEMPT TO CREATE A LABEL ENTRY FOR INSTR-*
* UCTIONS HAVING STORAGE OPERANDS. THE RESULTING LABEL TABLE WILL*
* BE SORTED, AND DUPLICATE ENTRIES ELIMINATED BEFORE EXIT FROM   *
* THIS PHASE OF DISASSEMBLY.                                     *
*                                                                *
******************************************************************
         SPACE 1
         L     R6,LBLTBL               @ LABEL TABLE
         USING LABELD,R6
         MVC   TXTCURR,TXTSTRT         COPY TEXT START ADDR
GETCURR  L     R7,TXTCURR              @ CURRENT TXT BYTE
         C     R7,TXTEND               END OF TEXT
         BNL   EOJ                     YES             FIX********
         LR    R12,R7                  COPY TEXT ADDR
         S     R12,TXTSTRT             COMPUTE OFFSET
         ST    R12,TXTOFST             SAVE OFFSET TO THIS BYTE
         CLC   NEXCHG,TXTOFSET         TIME TO CHANGE USING TBLS
         BH    CKDARNG                 NO
         BAS   R9,NEXUSG               YES, GO DO IT
CKDARNG  L     R12,NOINAD              GET DATA ONLY ENTRY ADDRESS
         CLC   TXTOFSET,0(R12)         NOT YET TO THIS RANGE
         BL    CKLOSEQ                 TRUE
         CLC   TXTOFSET,3(R12)         NOW IN THE RANGE
         BNH   CONST                   TRUE, TREAT AS CONSTANT
         LA    R12,6(R12)              PAST THIS ONE, STEP TO NEXT
         ST    R12,NOINAD              SAVE NEW ADDRESS
         B     CKDARNG                 AND CHECK AGAIN
CKLOSEQ  CLC   TXTOFSET,LBLADR         LABEL ENTRY OUT OF SEQ
         BNH   GCKODD                  NO, CONTINUE
         BAS   R9,FORCONST             YES, FORCE ANY CONSTANT OUT
         LA    R6,L'LABEL(R6)          TO NEXT LABEL
         B     CKLOSEQ                 CONTINUE SEQ CHK
GCKODD   TM    TXTCURR+3,1             ODD ADDRESS
         BO    CONST                   YES, NOT INSTR
         CLC   1(3,R7),0(R7)           4 CONSEC IDENTICAL BYTES
         BE    CONST                   YES, NOT INSTR
         L     R8,=A(CHARTRAN)                                     -EU-
         TRT   0(1,R7),0(R8)           TEST TEXT BYTE              -EU-
         BNZ   CKINSTR                 NOT CHARACTER
         CLI   CONPROG,1               IS CONSTANT IN PROGRESS
         BNE   CK6                     NO
         CLI   CONTYPE,C'C'            IS IT CHARACTER TYPE
         BE    CONST                   YES, ADD THIS TO CONSTANT
CK6      TRT   0(6,R7),0(R8)           6 CONSECUTIVE CHARACTERS    -EU-
         BZ    CONST                   YES, NOT INSTRUCTION
CKINSTR  XR    R8,R8                   CLEAR WORK
         IC    R8,0(R7)                PICK UP TXT BYTE
         MH    R8,SGLOPL               TIMES TABLE LENGTH          -EU-
         AL    R8,SGLOPAD              @ INSTR TBL ENTRY           -EU-
         MVC   INSTENT,0(R8)           SAVE INSTRUCTION TBL ENTRY
         CLI   INAME,0                 IS IT AN INSTR OP-CODE
         BE    CONST                   NO
         CLI   ITYPE,TWO               TWO-BYTE OP-CODE
         BNE   INSTR                   NO
         L     R8,DBLOPAD              YES, GET 2-BYTE TBL ADDR
DBLND    CLI   0(R8),X'FF'             END OF TABLE
         BE    CONST                   YES, NOT INSTR
         CLC   0(2,R8),0(R7)           THIS ENTRY MATCHES TXT
         BE    GOTDBLI                 YES
         AH    R8,DBLOPL               TO NEXT ENTRY               -EU-
         B     DBLND                   LOOP THRU TBL
GOTDBLI  LA    R8,2(R8)                PASS OP-CODE BYTES
         EJECT
******************************************************************
*                                                                *
* CHECK TO SEE IF THIS BYTE OF THE PROGRAM IS AN INSTRUCTION OP  *
* CODE. IF SO, PERFORM THE APPROPRIATE PROCESSING ROUTINE.       *
*                                                                *
******************************************************************
         SPACE 1
INSTR    MVC   ILENG+1(1),INLNG        SET INSTR LENGTH
         LH    R12,ILENG               PICK UP LENGTH
         AR    R12,R7                  ADDR OF NEXT OP CODE
         XR    R15,R15                 CLEAR WORK
         IC    R15,0(R12)              PICK UP NEXT OP-CODE
         MH    R15,SGLOPL              TIMES TBL ENTRY LENG        -EU-
         AL    R15,SGLOPAD             INSTR TBL ENTRY ADDR        -EU-
         CLI   INAME-INSTENT(R15),0    IS IT AN OP-CODE
         BNE   ICKSEC                  YES
POSSB    CLI   0(R7),X'45'             IS IT BAL                   -EU-
         BE    ICKTBL                  YES, CONTINUE
         CLI   0(R7),X'07'             NO, IS IT BRANCH
         BE    POSSB1                  YES
         CLI   0(R7),X'47'             IS IT BRANCH
         BNE   CONST                   NO, THEN THIS NOT INSTR
POSSB1   TM    1(R7),X'F0'             IS IT UNCOND BRANCH
         BNO   CONST                   NO, THEN THIS NOT INSTR
         B     ICKTBL                  ACCEPT UNCOND BRANCHES
ICKSEC   XR    R1,R1                   CLEAR WORK
         IC    R1,INLNG-INSTENT(R15)   GET INSTR LENGTH
         AR    R1,R12                  ADDR OF NEXT OP CODE
         XR    R14,R14                 CLEAR WORK
         IC    R14,0(R1)               PICK UP NEXT OP-CODE
         MH    R14,SGLOPL              TIMES TBL ENTRY LENG        -EU-
         AL    R14,SGLOPAD             INSTR TBL ENTRY ADDR        -EU-
         CLI   INAME-INSTENT(R14),0    IS IT AN OP-CODE
         BNE   ICKTBL                  YES
         CLI   0(R12),X'45'            IS IT BAL
         BE    ICKTBL                  YES, CONTINUE
         CLI   0(R12),X'07'            NO, IS IT BRANCH
         BE    POSSB2                  YES
         CLI   0(R12),X'47'            IS IT BRANCH
         BNE   POSSB                   NO, BUT SEE CURRENT INSTR   -EU-
POSSB2   TM    1(R12),X'F0'            IS IT UNCOND BRANCH
         BNO   CONST                   NO, THEN THIS NOT INSTR
ICKTBL   LH    R12,ILENG               GET INSTR LENGTH
         AR    R12,R7                  @ NEXT TEXT LOC
         BCTR  R12,0                   BACK UP 1
         S     R12,TXTSTRT             RELATIVIZE IN CSECT
         CLM   R12,B'0111',LBLADR      LBL TBL ADDR HERE
         BL    NOILBL                  NO
         CLC   TXTOFSET,LBLADR         LABEL AT INSTR START
         BNE   CONST                   NO, MUST BE CONSTANT
         CLI   LBLTYP,C'L'             IS IT A LABEL ONLY
         BNE   CONST                   NO
         CLI   CONPROG,1               CONSTANT IN PROGRESS
         BNE   SETLBL                  NO
         BAS   R9,FORCONST             YES, FORCE IT OUT
SETLBL   LA    R6,L'LABEL(R6)          TO NEXT LABEL TBL ENTRY
         B     ICKTBL                  GO CHECK NEXT LABEL
NOILBL   CLI   CONPROG,1               CONSTANT IN PROGRESS
         BNE   MVMNE                   NO
         BAS   R9,FORCONST             YES, FORCE IT OUT
MVMNE    MVC   MNEMONIC,0(R8)          SET INSTR MNEMONIC
         MVC   OFFSET,TXTOFSET         SET OFFSET
         MVC   INSTYP,5(R8)            SET INSTR TYPE
         MVI   TYPE,X'0D'              SHOW IT IS AN INSTRUCTION
         MVC   LEN,ILENG+1             SHOW LENGTH
         MVC   TEXT(6),0(R7)           MOVE ACTUAL TEXT
         TM    ICLASS,FLTPT            FLOATING POINT OP-CODE
         BO    FPVERFY                 YES, GO VERIFY
         CLI   IEDT,0                  ANY EDIT REQUIRED
         BNE   IVERFY                  YES, GO EDIT
PFMFMT   XR    R1,R1                   CLEAR WORK
         IC    R1,INSTYP               GET INSTRUCTION TYPE
         L     R9,OPND9                GET FORMAT ROUTINE RETURN ADDR
         B     *+L'*(R1) ------------- TO APPROPRIATE FORMAT ROUTINE
         B     INSTOUT                 TYPE=0, RR
         B     RXOPND                  TYPE=4, RX
         B     SOPND                   TYPE=8, S
         B     SIOPND                  TYPE=12, SI
         B     RSOPND                  TYPE=16, RS
         B     SS1OPND                 TYPE=20, 1-LENGTH SS
         B     SS2OPND                 TYPE=24, 2-LENGTH SS
         B     SOPND                   TYPE=28, 2-BYTE OP-CODES
         B     BCOPND                  TYPE=32, CONDITIONAL BRANCH -EU-
         B     SVCOPND                 TYPE=36, SVC
         B     SS1OPND                 TYPE=40, 2 REGISTERS SS     -EU-
         B     RREOPND                 TYPE=44, 2 REGISTERS RRE    -EU-
         B     SS1OPND                 TYPE=48, SSE                -EU-
         SPACE 1                                                   -EU-
OPNDRTN  B     INSTOUT                 NORMAL OPERAND FORMAT RETURN
         B     CONST                   ERROR INSTRUCTION, TREAT AS CONS
INSTOUT  AH    R7,ILENG                STEP TO NEXT TEXT BYTE
         ST    R7,TXTCURR              SAVE NEXT ADDR
         B     GETCURR                 CONTINUE TXT PROCESSING
BCOPND   CLI   TEXT,X'07'              RR BRANCH                   -EU-
         BE    INSTOUT                 YES                         -EU-
         B     RXOPND                  NO, GO AS RX                -EU-
         EJECT
******************************************************************
*                                                                *
* GENERAL OP-CODE TESTS TO VERIFY THAT NON-FLOATING-POINT OP     *
* CODES ARE INDEED OP-CODES.                                     *
*                                                                *
******************************************************************
         SPACE 1
IVERFY   TM    IEDT,EPR                EVEN-ODD REG PAIR
         BZ    IVE2                    NO
         TM    1(R7),X'10'             R1 IS ODD
         BO    CONST                   YES, NOT INSTR
         CLI   0(R7),X'0E'             IS IT MVCL
         BE    IVTRG2                  YES
         CLI   0(R7),X'0F'             IS IT CLCL
         BNE   IVE2                    NO
IVTRG2   TM    1(R7),X'01'             R2 IS ODD
         BO    CONST                   YES, NOT INSTR
         XR    R1,R1                   CLEAR WORK
         XR    R2,R2                   CLEAR WORK
         IC    R1,1(R7)                GET R1R2
         SRL   R1,4                    SHIFT OUT R2
         PACK  DBLWD(1),1(1,R7)        FLIP R1R2 BYTE
         IC    R2,DBLWD                PICK UP R2R1
         SRL   R2,4                    SHIFT OUT R1
         CR    R1,R2                   R1=R2
         BE    CONST                   YES, NOT INSTR
         B     PFMFMT                  NO, GOOD INSTR
IVE2     TM    IEDT,E2                 HALFWORD STORAGE ALIGNMENT
         BZ    IVE4                    NO
         TM    3(R7),X'01'             DISPL IS ODD
         BZ    IVES2                   NO, O.K.
         TM    2(R7),X'F0'             BASE REG = 0
         BNZ   IVES2                   NO, CONTINUE
         CLI   0(R7),X'44'             EX OP CODE
         BE    CONST                   YES, NOT INSTR
         CLI   0(R7),X'47'             BC OP CODE
         BE    CONST                   YES, NOT INSTR
         CLI   ITYPE,RS                RS INSTRUCTION
         BE    CONST                   YES, NOT INSTR
         TM    1(R7),X'0F'             INDEX REG IS 0
         BZ    CONST                   YES, NOT INSTR
         B     IVES2                   CONTINUE
IVE4     TM    IEDT,E4                 2ND OPND ON FULLWORD BOUND
         BZ    IVE8                    NO
         TM    3(R7),X'03'             DISPL DIV BY 4
         BZ    IVES2                   YES, O.K.
         TM    2(R7),X'F0'             BASE REG = 0
         BNZ   IVES2                   NO, CONTINUE
         CLI   ITYPE,RS                RS INSTRUCTION OP CODE
         BE    CONST                   YES, NOT INSTR
         TM    1(R7),X'0F'             INDEX REG = 0
         BZ    CONST                   YES, NOT INSTR
         B     IVES2                   NO, CONTINUE
IVE8     TM    IEDT,E8                 2ND OPND ON DBLWD BOUND
         BZ    IVES2                   NO
         TM    3(R7),X'07'             DISPL DIV BY 8
         BZ    IVES2                   YES, O.K.
         TM    2(R7),X'F0'             BASE REG = 0
         BNZ   IVES2                   NO
         CLI   ITYPE,S                 S INSTRUCTION OP CODE       -EU-
         BE    CONST                   YES, NOT INSTRUCTION        -EU-
         CLI   ITYPE,SSE               SSE INSTRUCTION OP CODE     -EU-
         BE    CONST                   YES, NOT INSTRUCTION        -EU-
         TM    1(R7),X'0F'             INDEX REG = 0
         BZ    CONST                   YES, NOT INSTR
IVES2    CLI   PRIVASM,1               PRIVILEGED INSTR O.K.
         BE    PFMFMT                  YES
         TM    IEDT,S2                 OPND2 MUST HAVE BASE
         BZ    IVES1                   NO
         TM    2(R7),X'F0'             BASE REG = 0
         BNZ   PFMFMT                  NO, O.K.
         CLI   ITYPE,RS                RS INSTRUCTION
         BE    CONST                   YES, NOT INSTR
         CLI   ITYPE,S                 S INSTRUCTION               -EU-
         BE    CONST                   YES, NOT INSTR              -EU-
         CLI   0(R7),X'92'             IS IT MVI OP CODE
         BE    CONST                   YES, NOT INSTR
         TM    1(R7),X'0F'             INDEX REG = 0
         BZ    CONST                   YES, NOT INSTR
         B     PFMFMT                  NO, GOOD INSTR
IVES1    TM    IEDT,S1                 1ST OPND MUST HAVE BASE
         BZ    PFMFMT                  NO, CONTINUE
         TM    2(R7),X'F0'             1ST OPND HAS BASE
         BZ    CONST                   NO, NOT INSTR
         B     PFMFMT                  YES, INSTR O.K.
         EJECT
******************************************************************
*                                                                *
* GENERAL OP-CODE TESTS TO VERIFY THAT FLOATING-POINT OP-CODES   *
* ARE INDEED OP-CODES.                                           *
*                                                                *
******************************************************************
         SPACE 1
FPVERFY  TM    ICLASS,FLEXR            EXTENDED FLT PT INSTR       -EU-
         BZ    FPVERFP                 NO                          -EU-
         TM    3(R7),X'BB'             0 OR 4 ONLY                 -EU-
         BZ    PFMFMT                  YES, GOOD INSTR             -EU-
         B     CONST                   NO, NOT INSTR               -EU-
FPVERFP  TM    1(R7),X'90'             R1 IS 0, 2, 4, OR 6         -EU-
         BNZ   CONST                   NO, NOT INSTR
         CLI   0(R7),X'27'             MXDR OP-CODE
         BE    FPR1EXT                 YES
         CLI   0(R7),X'67'             MXD OP-CODE
         BNE   FPCKTYP                 NO
FPR1EXT  TM    1(R7),X'B0'             R1 IS 0 OR 4
         BNZ   CONST                   NO, NOT INSTR
FPCKTYP  CLI   ITYPE,RR                RR TYPE INSTRUCTION
         BNE   FPRXVER                 NO
         TM    1(R7),X'09'             R2 IS 0, 2, 4, 6
         BNZ   CONST                   NO, NOT INSTR
         CLI   0(R7),X'25'             LRDR OP CODE
         BE    FPR2EXT                 YES
         CLI   0(R7),X'37'             SXR OP-CODE
         BE    FPR2EXT                 YES
         CLI   0(R7),X'26'             MXR OP-CODE
         BE    FPR2EXT                 YES
         CLI   0(R7),X'36'             AXR OP-CODE
         BNE   PFMFMT                  NO, GOOD INSTR
FPR2EXT  TM    1(R7),X'0B'             R2 IS 0 OR 4
         BZ    PFMFMT                  YES, GOOD INSTR
         B     CONST                   NO, NOT INSTR
FPRXVER  CLI   PRIVASM,1               PRIVILEGED INSTRUCTIONS O.K.
         BE    FPALIGN                 YES
         TM    2(R7),X'F0'             ANT BASE REG
         BNZ   FPALIGN                 YES
         TM    1(R7),X'0F'             ANY INDEX REG
         BZ    CONST                   NO, NOT INSTR
FPALIGN  TM    2(R7),X'F0'             ANY BASE REG
         BNZ   PFMFMT                  YES, ACCEPT INSTR
         TM    1(R7),X'0F'             ANY INDEX REG
         BNZ   PFMFMT                  YES, ACCEPT INSTR
         TM    3(R7),X'03'             DISPL DIV BY 4
         BNZ   CONST                   NO, NOT INSTR
         TM    ICLASS,FLSHT            SHORT PRECISION
         BO    PFMFMT                  YES, ACCEPT INSTRUCTION
         TM    3(R7),X'07'             DISPL DIV BY 8
         BZ    PFMFMT                  YES, ACCEPT INSTR
         B     CONST                   NO, NOT INSTR
         EJECT
******************************************************************
*                                                                *
* PROCESS TEXT BYTES DETERMINED TO BE CONSTANT DATA.             *
*                                                                *
******************************************************************
         SPACE 1
CONST    MVC   WORKREC,BLANX           CLEAR WORK RECORD AREA
         CLI   CONPROG,1               CONSTANT IN PROGRESS
         BNE   CCNEW                   NO
         CLC   TXTOFSET,LBLADR         LABEL ENTRY HAS THIS OFFSET
         BNE   CGETYP                  NO
CSTNEW   BAS   R9,FORCONST             FORCE IT OUT
         B     CCNEW                   GO START A NEW ONE
CGETYP   L     R11,=A(CHARTRAN)                                    -EU-
         TRT   0(1,R7),0(R11)          CHECK DATA TYPE OF BYTE     -EU-
         BNZ   CHEX                    IT'S HEX
         MVI   CCKTYP+1,C'C'           SET TYPE IN COMPARE
         B     CCKTYP                  GO COMPARE
CHEX     MVI   CCKTYP+1,C'X'           SET TYPE IN COMPARE
CCKTYP   CLI   CONTYPE,C' '            TYPE IN PROG SAME AS THIS BYTE
         BNE   CSTNEW                  NO
CUPDCON  LH    R11,CONLEN              GET CURRENT LENGTH
         LA    R11,1(R11)              ADD 1
         STH   R11,CONLEN              UPDATE LENGTH
         CLI   CONTYPE,C'C'            CHARACTER CONSTANT
         BE    CCK8                    YES
         TM    CONOFST+3,1             OFFSET IS ODD
         BO    CCFIN1                  YES
         TM    CONOFST+3,2             HALFWORD OFFSET
         BZ    CCFWD                   NO
         CLI   CONLEN+1,1              HALFWORD, IS LENGTH = 1
         BE    CCXIT1                  YES
         B     CCFIN1                  NO
CCFWD    CLI   CONLEN+1,4              NO, IS HEX CONST 4 BYTES
         BL    CCXIT1                  NOT YET
CCFIN1   BAS   R9,FORCONST             MAX LENG, FORCE IT OUT
         B     CCXIT1                  FINISH
CCK8     CLC   CONLEN,H8               CHAR CONSTANT 8 BYTES
         BNL   CCFIN1                  YES
CCXIT1   LA    R7,1(R7)                STEP OVER 1 BYTE IN TEXT
         ST    R7,TXTCURR              UPDATE TEXT ADDR
         B     GETCURR                 CONTINUE TEXT PROCESSING
CCNEW    MVI   CONPROG,1               SHOW CONSTANT IN PROGRESS
         MVC   CONOFST,TXTOFST         SET OFFSET TO 1ST BYTE
         MVC   CONLEN,XZROS            CLEAR LENGTH
         CLC   TXTOFSET,LBLADR         LABEL AT THIS OFFSET
         BE    CLBLD                   YES
TRTYPE   L     R11,=A(CHARTRAN)                                    -EU-
         TRT   0(1,R7),0(R11)          CHECK DATA TYPE OF BYTE     -EU-
         BNZ   CCSHX                   IT'S HEX
         MVI   CONTYPE,C'C'            IT'S CHAR, SO INDICATE
         B     CUPDCON                 GO COMPLETE
CCSHX    MVI   CONTYPE,C'X'            IT'S HEX, SO INDICATE
         B     CUPDCON                 GO COMPLETE
CLBLD    CLI   LBLTYP,C'L'             IS IT A LABEL ONLY
         BNE   CDATACON                NO
         LA    R6,L'LABEL(R6)          TO NEXT LABEL ENTRY
         CLC   TXTOFSET,LBLADR         THIS LABEL AT SAME ADDR
         BNE   TRTYPE                  NO
         CLI   LBLTYP,C'L'             THIS ANOTHER LABEL ONLY
         BNE   CDATACON                NO
         LA    R6,L'LABEL(R6)          TO NEXT LABEL ENTRY
         B     CCNEW                   GO TO NEXT LABEL
CDATACON MVC   CONTYPE,LBLTYP          TYPE TO CONSTANT AREA
         XR    R1,R1                   CLEAR WORK
         IC    R1,LBLLEN               PICK UP CONSTNT LENGTH
         STH   R1,CONLEN               SAVE CONSTANT LENGTH
         XR    R11,R11                 CLEAR WORK REG
         IC    R11,LBLLEN              PICK UP LENGTH
         AR    R7,R11                  STEP PAST TEXT
         ST    R7,TXTCURR              UPDATE TEXT ADDRESS
         BAS   R9,FORCONST             FORCE CONSTANT OUT
         LA    R6,L'LABEL(R6)          STEP TO NEXT LABEL ENTRY
         B     GETCURR                 CONTINUE TEXT PROCESS
         DROP  R6
         SPACE 2
******************************************************************
*                                                                *
* CLEAR OUT AREAS SET UP FOR CONSTANT DATA.                      *
*                                                                *
******************************************************************
         SPACE 1
FORCONST MVI   CONPROG,0               RESET CONSTANT IN PROGRESS
         MVI   CONTYPE,0               RESET TYPE
         XC    CONLEN,CONLEN           CLEAR LENGTH
         MVC   CONOFST,XZROS           CLEAR OFFSET TO CONSTANT
         BR    R9                      EXIT
         EJECT
******************************************************************
*                                                                *
* PROCESS RX-FORMAT INSTRUCTIONS. THE BASE-DISPLACEMENT ADDRESS  *
* WILL BE SENT TO THE BDLADR ROUTINE FOR LABEL CREATION.         *
*                                                                *
******************************************************************
         SPACE 1
RXOPND   XR    R11,R11                 CLEAR WORK REG
         ICM   R11,B'0011',TEXT+2      GET BDDD
         TM    TEXT+2,X'F0'            IS B SPECIFIED              -EU-
         BNZ   RXDCD                   YES                         -EU-
         XR    R10,R10                 CLEAR WORK REG              -EU-
         ICM   R10,B'1000',TEXT+1      GET RX OR MX                -EU-
         SLL   R10,4                   RETAIN X ONLY               -EU-
         SRL   R10,16                  POSITION X AS B             -EU-
         OR    R11,R10                 BUILD NEW BDDD              -EU-
RXDCD    LA    R10,4                   SET LENGTH = 4
         TM    INLNG,E4                FULLWORD OPERAND
         BO    RXBDDD                  YES
         LA    R10,2                   SET LENGTH = 2
         TM    INLNG,E2                HALFWORD OPERAND
         BO    RXBDDD                  YES
         LA    R10,1                   SET LENGTH = 1
         TM    INLNG,E8                DOUBLEWORD OPERAND
         BZ    RXBDDD                  NO
         LA    R10,8                   YES, SET LENGTH = 8
RXBDDD   B     BDLADR                  CHECK LABEL
         EJECT
******************************************************************
*                                                                *
* PROCESS S-FORMAT INSTRUCTIONS. THE BASE-DISPLACEMENT ADDRESS   *
* WILL BE SENT TO THE BDLADR ROUTINE FOR LABEL CREATION.         *
*                                                                *
******************************************************************
         SPACE 1
SOPND    CLI   1(R7),0                 BYTE 2 OF INSTR IS ZERO
         BE    SCHECK                  YES
         CLI   0(R7),X'80'             NO, IS IT SSM
         BE    4(R9)                   YES, NOT INSTR
         CLI   0(R7),X'82'             NO, IS IT LPSW
         BE    4(R9)                   YES, NOT INSTR
         CLI   0(R7),X'93'             NO, IS IT TS
         BE    4(R9)                   YES, NOT INSTR
SCHECK   CLI   0(R7),X'B2'             OP-CODE IS B2
         BNE   SSTRT                   NO
         TM    ICLASS,IOP              IGNORE OPERAND INSTR        -EU-
         BZ    SST3A                   NO                          -EU-
         CLC   2(2,R7),XZROS           3RD AND 4TH BYTES ZERO      -EU-
         BNE   4(R9)                   NO, NOT INSTR               -EU-
         BR    R9                      YES, NO MORE TO DO          -EU-
SST3A    CLI   1(R7),X'3A'             'STCPS' INST                -EU-
         BNE   SSTRT                   NO                          -EU-
         TM    3(R7),X'1F'             32-BYTE BOUNDARY            -EU-
         BZ    SSTRT                   YES                         -EU-
         TM    2(R7),X'F0'             BASE REG = 0                -EU-
         BZ    4(R9)                   YES, NOT INSTR              -EU-
SSTRT    XR    R11,R11                 CLEAR WORK
         ICM   R11,B'0011',TEXT+2      GET BDDD
         LA    R10,4                   SET LENGTH = 4
         TM    INLNG,E4                FULLWORD OPERAND
         BO    SBDDD                   YES
         LA    R10,2                   SET LENGTH = 2
         TM    INLNG,E2                HALFWORD OPERAND
         BO    SBDDD                   YES
         LA    R10,1                   SET LENGTH = 1
         TM    INLNG,E8                DOUBLEWORD OPERAND
         BZ    SBDDD                   NO
         LA    R10,8                   YES, SET LENGTH = 8
SBDDD    B     BDLADR                  CHECK FOR LABEL
         EJECT
******************************************************************
*                                                                *
* PROCESS SI-FORMAT INSTRUCTIONS. THE BASE-DISPLACEMENT ADDRESS  *
* WILL BE SENT TO THE BDLADR ROUTINE FOR LABEL CREATION.         *
*                                                                *
******************************************************************
         SPACE 1
SIOPND   XR    R11,R11                 CLEAR WORK
         ICM   R11,B'0011',TEXT+2      GET BDDD ADDRESS
         LA    R10,0                   LENGTH=DON'T CARE
         B     BDLADR                  CHECK FOR LABEL
         SPACE 2
******************************************************************
*                                                                *
* PROCESS RS-FORMAT INSTRUCTIONS. THE BASE-DISPLACEMENT ADDRESS  *
* WILL BE SENT TO THE BDLADR ROUTINE FOR LABEL CREATION.         *
*                                                                *
******************************************************************
         SPACE 1
RSOPND   CLI   0(R7),X'88'             IS IT SHIFT INSTR
         BL    RSCMA1                  NO
         CLI   0(R7),X'8F'             IS IT SHIFT INSTR
         BH    RSCMA1                  NO
         TM    1(R7),X'0F'             SHIFT, IS R3 POS = 0
         BZ    0(R9)                   YES, GOOD SHIFT
         B     4(R9)                   NO, NOT INSTR
RSCMA1   XR    R11,R11                 CLEAR WORK
         ICM   R11,B'0011',TEXT+2      GET BDD ADDRESS
         LA    R10,4                   SET LENGTH = 4
         TM    INLNG,E4                FULLWORD OPERAND
         BO    RSBDDD                  YES
         LA    R10,2                   SET LENGTH = 2
         TM    INLNG,E2                HALFWORD OPERAND
         BO    RSBDDD                  YES
         LA    R10,1                   SET LENGTH = 1
         TM    INLNG,E8                DOUBLEWORD OPERAND
         BZ    RSBDDD                  NO
         LA    R10,8                   YES, SET LENGTH = 8
RSBDDD   B     BDLADR                  CHECK FOR LABEL
         EJECT
******************************************************************
*                                                                *
* PROCESS SS-FORMAT INSTRUCTIONS. THE BASE-DISPLACEMENT ADDRESSES*
* WILL BE SENT TO THE BDLADR ROUTINE FOR LABEL CREATION. THE     *
* 1-LENGTH OR 2-REGS SS FORMAT INSTRUCTIONS ARE HANDLED HERE.    * -EU-
*                                                                *
******************************************************************
         SPACE 1
SS1OPND  XR    R10,R10                 CLEAR WORK
         CLI   INSTYP,SSR              2 REGS SS FORMAT            -EU-
         BE    SS1L1                   YES, USE LENGTH = 1         -EU-
         CLI   INSTYP,SSE              SSE FORMAT                  -EU-
         BE    SS1L1                   YES, USE LENGTH = 1         -EU-
         IC    R10,TEXT+1              GET LENGTH CODE
SS1L1    LA    R10,1(R10)              COMPUTE ACTUAL LENGTH
         XR    R11,R11                 CLEAR WORK
         ICM   R11,B'0011',TEXT+2      GET BDDD ADDRESS
         LA    R1,SS1RTN               GET RTEURN ADDR
         MVC   SAVOP9,OPND9            SAVE NORMAL RETURN ADDR
         ST    R1,OPND9                CHANGE RETURN ADDR
         B     BDLADR                  CHECK LABEL
SS1RTN   MVC   OPND9,SAVOP9            RESTORE NORMAL RETURN ADDR
         XR    R11,R11                 CLEAR WORK
         ICM   R11,B'0011',TEXT+4      GET SECOND BDDD ADDRESS
         XR    R10,R10                 CLEAR LENGTH REG
         CLI   INSTYP,SSR              2 REGS SS FORMAT            -EU-
         BE    SS1L2                   YES, USE LENGTH = 1         -EU-
         CLI   INSTYP,SSE              SSE FORMAT                  -EU-
         BE    SS1L2                   YES, USE LENGTH = 1         -EU-
         IC    R10,TEXT+1              GET INSTR LENGTH
SS1L2    LA    R10,1(R10)              COMPUTE ACTUAL LENGTH
         B     BDLADR                  CHECK FOR LABEL
         EJECT
******************************************************************
*                                                                *
* PROCESS SS-FORMAT INSTRUCTIONS. THE BASE-DISPLACEMENT ADDRESSES*
* WILL BE SENT TO THE BDLADR ROUTINE FOR LABEL CREATION. THE     *
* DOUBLE-LENGTH SS FORMAT INSTRUCTIONS ARE HANDLED HERE.         *
*                                                                *
******************************************************************
         SPACE 1
SS2OPND  XR    R10,R10                 CLEAR WORK
         IC    R10,TEXT+1              GET L1L2
         SRL   R10,4                   SHIFT OUT L2
         LA    R10,1(R10)              COMPUTE ACTUAL LENGTH
         XR    R11,R11                 CLEAR WORK
         ICM   R11,B'0011',TEXT+2      GET BDDD ADDRESS
         LA    R1,SS2RTN               GET RETURN ADDR
         MVC   SAVOP9,OPND9            SAVE NORMAL RETURN ADDR
         ST    R1,OPND9                CHANGE RETURN ADDRESS
         B     BDLADR                  CHECK LABEL
SS2RTN   MVC   OPND9,SAVOP9            RESTORE NORMAL RETURN ADDR
         XR    R11,R11                 CLEAR WORK
         ICM   R11,B'0011',TEXT+4      GET 2ND BDDD ADDR
         PACK  DBLWD(1),TEXT+1(1)      FLIP LENGTH BYTE
         XR    R10,R10                 CLEAR WORK
         IC    R10,DBLWD               PICK UP L2L1
         SRL   R10,4                   SHIFT OUT L1
         CLI   TEXT,X'F0'              SRP OP-CODE
         BNE   SS2BDDD                 NO
         IC    R10,TEXT+1              GET INSTR LENGTH
         SRL   R10,4                   SHIFT OUT I3
SS2BDDD  LA    R10,1(R10)              COMPUTE ACTUAL LENGTH
         B     BDLADR                  CHECK LABEL
         EJECT ,                                                   -EU-
****************************************************************** -EU-
*                                                                * -EU-
* PROCESS RRE-FORMAT INSTRUCTIONS.                               * -EU-
*                                                                * -EU-
****************************************************************** -EU-
         SPACE 1                                                   -EU-
RREOPND  CLI   TEXT+2,0                BYTE 2 OF INSTR IS ZERO     -EU-
         BNE   4(R9)                   NO, NOT INSTRUCTION         -EU-
         TM    IEDT,E1R                1 REGISTER                  -EU-
         BZ    0(R9)                   NO                          -EU-
         TM    TEXT+3,X'0F'            R2 IS ZERO                  -EU-
         BNZ   4(R9)                   NO, NOT INSTRUCTION         -EU-
         BR    R9                      YES                         -EU-
         SPACE 2
******************************************************************
*                                                                *
* PROCESS SVC INSTRUCTIONS. THE SOLE PROCESSING IS TO VERIFY THAT*
* THIS IS A VALID SVC.                                           *
*                                                                *
******************************************************************
         SPACE 1
SVCOPND  L     R1,SVCOPAD              GET SVC TABLE ADDRESS       -EU-
SVCKND   CLI   0(R1),X'FF'             END OF SVC TABLE
         BE    NOTSVC                  YES, MUST NOT BE SVC
         CLC   0(1,R1),TEXT+1          THIS THE ENTRY
         BE    GOTSVC                  YES
         BH    NOTSVC                  NO, MUST NOT BE SVC         -EU-
         AH    R1,SVCOPL               STEP TO NEXT ENTRY          -EU-
         B     SVCKND                  LOOP THRU TABLE
NOTSVC   B     4(R9)                   ERROR RETURN
GOTSVC   BR    R9                      EXIT, NO STORAGE OPND
         EJECT
******************************************************************
*                                                                *
* SET UP CURRENT BASE REGISTERS IN THE BASE TABLE. THE USING     *
* TABLE IS SCANNED FOR ENTRIES VALID AT THE CURRENT TEXT OFFSET. *
* WHEN A BASE REGISTER ENTRY IS FOUND TO BE VALID AT THE CURRENT *
* TEXT OFFSET, THE USING ENTRY IS MOVED TO THE APPROPRIATE LOC-  *
* ATION IN THE BASE TABLE FOR USE BY THE BDLADR ROUTINE. THE TEXT*
* OFFSET TO THE NEXT BASE REGISTER CHANGE IS SET SO THAT THIS    *
* ROUTINE WILL AGAIN BE ENTERED WHEN THE CURRENT BASE REGISTERS  *
* ARE EXHAUSTED.                                                 *
*                                                                *
******************************************************************
         SPACE 1
NEXUSG   MVI   MORUSG,0                RESET INDICATOR
         L     R1,=A(BASES)                                        -EU-
         XC    0(L'BASES,R1),0(R1)     CLEAR OLD BASE REG VALUES   -EU-
         MVC   NEXCHG,HIVAL            SET NEXT CHANGE LOC HIGH
         L     R2,USGSTRT              GET USING TBL START
         USING USINGD,R2
ENDUS    CLI   0(R2),X'FF'             END OF TABLE
         BCR   8,R9                    YES, EXIT
         CLC   TXTOFSET,USEND          PAST THIS ONE
         BNL   ECSTEP                  YES
         OI    MORUSG,X'01'            SHOW MORE BASES AVAILABLE
USBGCK   CLC   TXTOFSET,USBGN          THIS STARTS LATER
         BNL   CKNEWLO                 NO
         CLC   USBGN,NEXCHG            BEGINS BEFORE NEXT CHG
         BNL   ECSTEP                  NO
         MVC   NEXCHG,USBGN            YES, SET NEW CHANGE OFFSET
         B     ECSTEP                  CONTINUE
CKNEWLO  CLC   USEND,NEXCHG            NEW LOW CHANGE ADDR
         BNL   ECMVC                   NO
         MVC   NEXCHG,USEND            YES, SET LOWER OFFSET
ECMVC    XR    R1,R1                   CLEAR WORK
         IC    R1,USREG                PICK UP REGISTER
         MH    R1,USGLEN               TIMES ENTRY LENGTH
         AL    R1,=A(BASES)            @ TABLE ENTRY               -EU-
         MVC   0(L'USING,R1),USING     ENTRY TO TABLE
         OI    MORUSG,X'80'            SHOW BASE REG CURRENT
ECSTEP   LA    R2,L'USING(R2)          TO NEXT USING TBL ENTRY
         B     ENDUS                   LOOP THRU USING TBL
         DROP  R2
         EJECT
******************************************************************
*                                                                *
* A BASE-DISPLACEMENT IS PROVIDED IN REG 11 ON ENTRY. IF ANY     *
* BASE REGISTERS ARE CURRENT, AND THE BASE REGISTER FOR THE GIVEN*
* ADDRESS IS A CURRENT PROGRAM BASE REGISTER, A LABEL ENTRY IS   *
* BUILT. OFFSET TO THE LABEL WILL BE FOUND BY ADDING THE ASSUMED *
* BASE REGISTER VALUE TO THE GIVEN DISPLACEMENT. THE LABEL NAME  *
* WILL BE THE LETTER 'A' FOLLOWED BY THE OFFSET.                 *
*                                                                *
******************************************************************
         SPACE 1
BDLADR   TM    MORUSG,X'01'            ANY BASES CURRENT
         BZ    BDLXIT                  NO
         LR    R2,R11                  COPY BDDD ADDRESS
         SRL   R2,12                   RIGHT JUSTIFY BASE REG
         MH    R2,USGLEN               TIMES ENTRY LENGTH
         AL    R2,=A(BASES)            @ BASE REG TABLE ENTRY      -EU-
         USING USINGD,R2
         CLI   USTYPE,C'P'             IS IT A PROGRAM BASE
         BNE   BDLXIT                  NO
         SLL   R11,20                  ISOLATE THE
         SRL   R11,20                  DDD IN R11
         XR    R1,R1                   CLEAR WORK
         ICM   R1,B'0111',USVALU       GET BASE REG VALUE
         AR    R11,R1                  COMPUTE PROGRAM OFFSET
         DROP  R2
         L     R1,CURRLBL              GET LBL TBL ADDR
         C     R1,ENDLBL               END OF TABLE
         BL    GOTHOLE                 NO
         BAS   R9,COMPLBL              YES, COMPRESS DUPLICATES
         L     R1,CURRLBL              GET NEW CURRENT LBL ADDR
         C     R1,ENDLBL               STILL AT END
         BNL   BDLXIT                  YES, TERMINATE THIS STAGE   -EU-
         USING LABELD,R1
GOTHOLE  STCM  R11,B'0111',LBLADR      SET LABEL ENTRY OFFSET
         MVI   LBLNAME,C'A'            BEGIN LABEL NAME
         LA    R12,LBLADR              @ OFFSET
         BAS   R9,HEXPRT3              GO CONVERT
         MVC   LBLNAME+1(6),PRTABL     REST OF NAME
         MVI   LBLNAME+7,C' '          FINAL BLANK IN NAME
         MVI   LBLTYP,C'L'             SET LABEL TYPE
         CLI   TEXT,X'47'              THIS A CONDITIONAL BRANCH
         BE    INSTREF                 YES
         CLI   TEXT,X'45'              BAL INSTR
         BE    INSTREF                 YES
         CLI   TEXT,X'46'              BCT INSTR
         BE    INSTREF                 YES
         CLI   TEXT,X'44'              EX INSTR
         BE    INSTREF                 YES
         CLI   TEXT,X'87'              BXLE INSTRUCTION
         BE    INSTREF                 YES
         CLI   TEXT,X'86'              BXH INSTRUCTION
         BNE   BDLSTP                  NO
INSTREF  XR    R12,R12                 CLEAR WORK REG
         A     R11,TXTSTRT             BRCH ADDR IN STORED TEXT
         LA    R10,4                   ASSUME LENGTH IS 4
         TM    0(R11),X'C0'            TEST HI 2-BITS OF OP-CODE
         BM    BDLSTP                  01 OR 10 IS 4-BYTE INSTR
         BO    BDLSIX                  YES, SIX-BYTE INSTR
         LA    R10,2                   BOTH OFF, 2-BYTE INSTR
         B     BDLSTP                  CONTINUE
BDLSIX   LA    R10,6                   SET LENGTH TO 6
BDLSTP   STC   R10,LBLLEN              LENGTH TO LABEL ENTRY
         LA    R1,L'LABEL(R1)          TO NEXT ENTRY
         ST    R1,CURRLBL              SAVE UPDATED TBL ADDR
BDLXIT   L     R9,OPND9                GET RETURN ADDR
         BR    R9                      EXIT
         DROP  R1
         EJECT
******************************************************************
*                                                                *
* SORT THE LABEL TABLE AND ELIMINATE ANY DUPLICATE ENTRIES.      *
*                                                                *
******************************************************************
         SPACE 1
         USING LABELD,R6
COMPLBL  L     R6,LBLTBL               GET LABEL TABLE ADDR
LBSTPASS LA    R7,L'LABEL(R6)          @ NEXT LABEL TABLE ENTRY
LBLND    C     R7,CURRLBL              AT TABLE END
         BL    LBSAMPS                 NO
NEXPAS0  LA    R6,L'LABEL(R6)          TO NEXT LABEL ENTRY
         C     R6,CURRLBL              END OF TABLE
         BL    LBSTPASS                NO
         B     LBFEND                  YES, FIND END
LBSAMPS  CLC   LBLADR,LBLADR-LABEL(R7) IDENTICAL OFFSETS
         BH    LBSWCH                  NO, FIRST HIGH, SWITCH
         BL    LBSTP                   NO, LOW, CONTINUE SCAN
         CLC   LABEL,0(R7)             ENTRIES ARE IDENTICAL
         BNE   LBCKLBL                 NO
LBNULL2  MVC   LBLADR-LABEL(3,R7),HIVAL YES, NULL 2ND
         B     LBSTP                   AND CONTINUE SCAN
LBCKLBL  CLC   LBLNAME,LBLNAME-LABEL(R7) IDENTICAL LABELS
         BNE   LBCKTYP                 NO, CHECK TYPES
LBCKLN   CLI   LBLLEN,0                THIS ENTRY LENGTH = 0
         BNE   LBCKLN2                 NO
         MVI   LBLLEN,X'FF'            YES, SET HIGH LENGTH
LBCKLN2  CLC   LBLLEN,LBLLEN-LABEL(R7) COMPARE LENGTHS
         BH    LBSWCH                  1ST LENGTH HIGH, SWITCH ENTRIES
         B     LBNULL2                 1ST LOW/=, NULL 2ND
LBCKTYP  CLC   LBLTYP,LBLTYP-LABEL(R7) SAME ENTRY TYPE
         BNE   LBCK1L                  NO, CHK TYPE ORDER
         CLI   LBLTYP,C'L'             ARE THEY TYPE L
         BE    LBSTP                   YES, CONTINUE SCAN
         CLI   LBLTYP,C'U'             USER LABEL
         BNE   LBNULL2                 NO
         B     LBSTP                   YES
LBCK1L   CLI   LBLTYP,C'U'             1ST IS USER LABEL
         BNE   LBCK2L                  NO
         CLI   LBLTYP-LABEL(R7),C'L'   2ND IS TYPE L
         BE    LBNULL2                 YES, NULL THE 2ND
         B     LBSTP                   CONTINUE SCAN
LBCK2L   CLI   LBLTYP-LABEL(R7),C'U'   2ND IS USER LABEL
         BE    LBSWCH                  YES
         CLI   LBLTYP,C'L'             1ST IS LABEL TYPE
         BE    LBSTP                   YES, CONTINUE SCAN
LBSWCH   MVC   WORKREC(L'LABEL),LABEL  HOLD 1ST ENTRY
         MVC   LABEL,0(R7)             MOVE 2ND ENTRY TO 1ST
         MVC   0(L'LABEL,R7),WORKREC   1ST ENTRY TO 2ND LOCATION
         B     LBSAMPS                 GO RECHECK
LBSTP    LA    R7,L'LABEL(R7)          TO NEXT LABEL ENTRY
         B     LBLND                   CONTINUE SCAN
LBFEND   L     R6,LBLTBL               @ LABEL TABLE
LBFCKFF  CLI   LABEL,X'FF'             NULL ENTRY
         BE    LBSTCURR                YES
         C     R6,CURRLBL              AT FORMER END
         BE    LBSTCURR                YES
         LA    R6,L'LABEL(R6)          TO NEXT ENTRY
         B     LBFCKFF                 LOOP TO FIND END
LBSTCURR ST    R6,CURRLBL              SAVE NEW TBL END ADDR
         BR    R9                      EXIT
         DROP  R6
         SPACE 2
******************************************************************
*                                                                *
* END OF PHASE 1. SORT/COMPRESS THE LABEL TABLE AND RETURN.      *
*                                                                *
******************************************************************
         SPACE 1
EOJ      BAS   R9,COMPLBL              SORT/COMPRESS LABEL TBL
         L     R6,LBLTBL               GET LABEL TABLE ADDR
         USING LABELD,R6
EOJCKND  C     R6,CURRLBL              END OF TABLE
         BNL   EOJ2                    YES
         CLI   LBLTYP,C'U'             USER LABEL
         BNE   EOJSTEP                 NO
         MVI   LBLTYP,C'L'             YES, CHANGE TO TYPE L
EOJSTEP  LA    R6,L'LABEL(R6)          TO NEXT ENTRY
         B     EOJCKND                 CONTINUE LOOP
         DROP  R6
         SPACE 2                                                   -EU-
         PRINT GEN                                                 -EU-
EOJ2     MVC   PRT,BLANX               CLEAR PRINT
         SVBCK ,                       RETURN TO CALLER            -EU-
         PRINT NOGEN                                               -EU-
         EJECT
******************************************************************
*                                                                *
* CONVERT HEX BYTES TO THEIR PRINTABLE EQUIVALENTS. ON ENTRY, REG*
* 12 CONTAINS THE ADDRESS OF THE FIRST BYTE TO BE CONVERTED. THE *
* NUMBER OF BYTES IS DETERMINED BY THE ENTRY SELECTED. PRINTABLE *
* HEX IS PLACED IN THE FIELD PRTABL, TWO CHARACTERS PER BYTE.    *
*                                                                *
******************************************************************
         SPACE 1
HEXPRT1  UNPK  PRTABL(3),0(2,R12)      UNPACK HEX
         B     HEXCLTR                 CONTINUE
HEXPRT2  UNPK  PRTABL(5),0(3,R12)      UNPACK HEX
         B     HEXCLTR                 CONTINUE
HEXPRT3  UNPK  PRTABL(7),0(4,R12)      UNPACK HEX
         B     HEXCLTR                 CONTINUE
HEXPRT4  UNPK  PRTABL(9),0(5,R12)      UNPACK HEX
HEXCLTR  MVZ   PRTABL(8),XZROS         CLEAR FOR TRANSLATE
         TR    PRTABL(8),TRTBL         MAKE PRINTABLE
         BR    R9                      EXIT
         SPACE 2
******************************************************************
*                                                                *
* PRINT A LINE USING THE SYSPRINT DCB DEFINED IN DISASM PHASE 0. *
*                                                                *
******************************************************************
         SPACE 1
PRINT    L     R1,PRINTDCB             @ SYSPRINT DCB
         USING IHADCB,R1                                           -EU-
         TM    DCBOFLGS,DCBOFOPN       IS SYSPRINT OPEN
         BNO   CLRPRT                  NO
         DROP  R1                                                  -EU-
         PUT   (1),PRTLINE             WRITE PRINT LINE
CLRPRT   MVC   PRT,BLANX               CLEAR PRINT LINE
         AP    LINECT,P1               INCR LINE COUNTER
         CLI   PCC,C' '                SINGLE SPACED
         BE    SETSGL                  YES
         AP    LINECT,P1               INCR LINE COUNTER
         CLI   PCC,C'0'                DOUBLE SPACED
         BE    SETSGL                  YES
         AP    LINECT,P1               INCR LINE COUNTER
         CLI   PCC,C'-'                TRIPLE SPACED
         BE    SETSGL                  YES
         ZAP   LINECT,P0               NO, MUST BE NEW PAGE
SETSGL   MVI   PCC,C' '                SET SINGLE SPACING
         CP    LINECT,P58              PAST END OF PAGE
         BH    NEWPAGE                 YES
         BR    R9                      EXIT
NEWPAGE  MVI   PCC,C'1'                SET SKIP TO HOF
         ZAP   LINECT,P0               RESET LINE COUNTER
         BR    R9                      EXIT
         EJECT
         PRINT GEN                                                 -EU-
         DEFCOM DSECT=YES                                          -EU-
         EJECT  ,                                                  -EU-
         DEFCDS ,                                                  -EU-
         EJECT
DISASM1  CSECT
         SPACE 1
OPND9    DC    A(OPNDRTN)              RETURN ADDR FOR OPERAND ROUTINES
DSCT9    DC    F'0'                    RETURN FOR DSECTS
SAVOP9   DC    F'0'                    SAVE AREA FOR OPND9
ULSAV    DC    7F'0'                   SAVE AREA FOR CKADCON
NOINAD   DC    F'0'                    DATA ONLY TABLE ADDRESS
DTBLEN   DC    AL2(L'DSECT)            DSECT TABLE ENTRY LENGTH
NUMCK    DC    C'0000'                 NUMERIC CHECK AREA
ZEROS    DC    C'0000'                 CONSTANT ZEROS
ILENG    DC    H'0'                    INSTRUCTION LENGTH  FIX***
HIVAL    DC    4X'FF'                  CONSTANT F'S
USGLEN   DC    0H'0',AL2(L'USING)      LENGTH OF USING TBL ENTRY
NEXCHG   DC    XL3'00'                 NEXT BASE REG CHG OFFSET
MORUSG   DC    X'00'                   80=CURRENT BASE, 01=MORE BASES
CONPROG  DC    X'00'                   CONSTANT IN PROGRESS INDIC
CONTYPE  DC    CL1' '                  TYPE
CONLEN   DC    H'0'                    CONSTANT LENGTH
H8       DC    H'8'                    CONSTANT 8
CONOFST  DC    F'0'                    RELATIVE OFFSET TO CONSTANT
TXTOFST  DS    0F
         DC    X'0'
TXTOFSET DC    XL3'0'                  OFFSET TO TEXT BYTE
OFFSET   DC    XL3'0'                  OFFSET FROM PGM START
INSTYP   DC    CL1' '                  INSTRUCTION TYPE
TYPE     DC    XL1'0'                  TYPE CODE
*                                       0=CSECT, 1=ADCON, 2=CONST
*                                       E=USING, D=INSTRUCTION
*                                       C=COMMENT, 9=ENTRY
*                                       A=EQU
LEN      DC    XL1'0'                  TEXT LENGTH
TEXT     DC    XL8'0'                  TEXT
P0       DC    P'0'                    CONSTANT 0
P1       DC    P'1'                    CONSTANT 1
P58      DC    P'58'                   CONSTANT 58
P256     DC    P'256'                  CONSTANT 256
P4096    DC    P'4096'                 CONSTANT 4096
BLANX    DC    CL121' '                CONSTANT BLANKS
UNAME    DC    CL8'A'                  USER NAME AREA
XZROS    DC    8X'00'                  CONSTANT ZEROS
TRTBL    DC    C'0123456789ABCDEF'     TRANSLATE TBL
PRTABL   DC    CL9' '                  PRINTABLE HEX WORK
         SPACE 2                                                   -EU-
         DEFINS ,                                                  -EU-
         EJECT
         LTORG
         EJECT ,                                                   -EU-
* END OF BASE REGISTERS ADDRESSABILITY - - - - - - - - - - - - - - -EU-
         SPACE 1                                                   -EU-
BASES    DC    XL256'00'               CURRENT BASE REGS
CHARTRAN DC    256X'FF'           TRT TABLE FOR CHAR/HEX DETERMINATION
         ORG   CHARTRAN+C' '
         DC    X'00'                   BLANK IS CHARACTER
         ORG   CHARTRAN+C'A'
         DC    9X'00'                  A-I ARE CHARACTERS
         ORG   CHARTRAN+C'J'
         DC    9X'00'                  J-R ARE CHARACTERS
         ORG   CHARTRAN+C'S'
         DC    8X'00'                  S-Z ARE CHARACTERS
         ORG   CHARTRAN+C'0'
         DC    10X'00'                 0-9 ARE CHARACTERS
         ORG
TRHEX    DC    256X'FF'                HEX TRANSLATION TABLE
         ORG   TRHEX+C'A'
         DC    X'0A0B0C0D0E0F'
         ORG   TRHEX+C'0'
         DC    X'00010203040506070809'
         ORG
TRTHEX   DS    0X                      VERIFY HEX TABLE
         DC    XL16'00'
         DC    XL240'FF'
         ORG
         SPACE 2
         END
