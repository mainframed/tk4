HEL      TITLE 'H E L -- A FULL-SCREEN HELP COMMAND.'
***********************************************************************
*                                                                     *
*        HEL - TSO COMMAND FOR DISPLAYING A HELP MEMBER               *
*              ON A 3270 DISPLAY STATION SCREEN                       *
*                                                                     *
*        WRITTEN BY A. BRUCE LELAND AT HITACHI AMERICA, LTD.          *
*                ON JUNE 18, 1984                                     *
*                                                                     *
*                                                                     *
* PLEASE REPORT ANY PROBLEMS, ENHANCEMENTS, SUGGESTIONS OR COMMENTS   *
* CONCERNING THE HEL COMMAND TO BRUCE LELAND AT:                      *
*                                                                     *
*     HITACHI AMERICA, LTD.    OR          6084 CRIMSON DRIVE         *
*     2210 O'TOOLE AVENUE                  SAN JOSE, CALIF 95120      *
*     SAN JOSE, CALIF. 95131                                          *
*     (408) 435-2143                       (408) 997-2366             *
*                                                                     *
*                                                                     *
***********************************************************************
*                                                                     *
* BASED ON THE REVIEW COMMAND:                                        *
*        WRITTEN BY. BILL GODFREY, PRC (PLANNING RESEARCH CORPORATION)*
*        INSTALLATION. AIR FORCE DATA SERVICES CENTER, PENTAGON.      *
*        DATE WRITTEN. JANUARY 19 1981.                               *
*        DATE UPDATED. MARCH 18 1982.                                 *
*        ATTRIBUTES. RE-ENTRANT.                                      *
*        LOCAL MACROS USED. DCS. (DEFINE CONSTANTS FOR SCREEN).       *
*        DESCRIPTION.                                                 *
*         THIS TSO COMMAND DISPLAYS A DATA-SET ON A 3270 TERMINAL     *
*         IN FULLSCREEN MODE.                                         *
*                                                                     *
***********************************************************************
*                                                                     *
* IBM HELP MODULE INTERFACE:                                          *
*                                                                     *
*   HEL WILL PASS CONTROL TO THE IBM HELP COMMAND (&IBMHELP) IN       *
*   ANY OF THE FOLLOWING SITUATIONS:                                  *
*     . THE TERMINAL HAS LESS THAN 24 LINES.                          *
*     . THE TERMINAL SCREEN IS NOT 80 CHARACTERS WIDE.                *
*     . THE XCTL TESTING SUBCOMMAND IS ENTERED.                       *
*     . THE MSG OPERAND IS USED.                                      *
*     . THE POSIT OPERAND IS USED (FOR TSO/E PARSE HELP).             *
*     . THE SUBCOMMAND IS NOT H OR HELP (FOR TSO/E PARSE HELP).       *
*                                                                     *
***********************************************************************
*                                                                     *
* NAMING RESTRICTION:                                                 *
*                                                                     *
*   DUE TO THE METHOD USED TO INVOKE HELP COMMANDS AND THE USE OF     *
*   THE ECTPCMD AND ECTSCMD FIELDS, THIS COMMAND MUST BE NAMED AS     *
*   H OR ANY NAME BEGINNING WITH THE LETTERS HE.                      *
*                                                                     *
***********************************************************************
          EJECT
***********************************************************************
*                                                                     *
* INSTALLATION CONSIDERATIONS:                                        *
*                                                                     *
*   THIS COMMAND MAY BE INSTALLED WITH OR WITHOUT ALIASES             *
*   (HELP AND/OR H) AS FOLLOWS:                                       *
*                                                                     *
*     1.  TO INSTALL THIS COMMAND WITH NO ALIASES, THE FOLLOWING      *
*         STEPS ARE RECOMMENDED:                                      *
*         A.  EDIT THIS MEMBER, INSURING &IBMHELP IS SET TO 'H'       *
*         B.  ASSEMBLE AND LINK HEL INTO ANY LINKLIST LIBRARY         *
*                                                                     *
*     2.  TO INSTALL THIS COMMAND WITH AN ALIAS OF HELP, THE          *
*         FOLLOWING STEPS ARE RECOMMENDED:                            *
*         A.  EDIT THIS MEMBER, INSURING &IBMHELP IS SET TO 'H'       *
*         B.  ASSEMBLE AND LINK HEL INTO A LINKLIST LIBRARY           *
*             IN FRONT OF 'SYS1.CMDLIB' ('SYS1.LINKLIB'?)             *
*         C.  USING THE PDS COMMAND IN THIS LINKLIST LIBRARY,         *
*             ENTER:  ALIAS HEL HELP                                  *
*                                                                     *
*     3.  TO INSTALL THIS COMMAND WITH AN ALIAS OF H, THE             *
*         FOLLOWING STEPS ARE RECOMMENDED:                            *
*         A.  EDIT THIS MEMBER, CHANGING &IBMHELP TO 'HELP'           *
*         B.  ASSEMBLE AND LINK HEL INTO A LINKLIST LIBRARY           *
*             IN FRONT OF 'SYS1.CMDLIB' ('SYS1.LINKLIB'?)             *
*         C.  USING THE PDS COMMAND IN THIS LINKLIST LIBRARY,         *
*             ENTER:  ALIAS HEL H                                     *
*                                                                     *
*     4.  TO INSTALL THIS COMMAND WITH ALIASES HELP AND H, THE        *
*         FOLLOWING STEPS ARE RECOMMENDED:                            *
*         A.  EDIT THIS MEMBER, CHANGING &IBMHELP TO 'HELPOLD'        *
*         B.  ASSEMBLE AND LINK HEL INTO A LINKLIST LIBRARY           *
*             IN FRONT OF 'SYS1.CMDLIB' ('SYS1.LINKLIB'?)             *
*         C.  USING THE PDS COMMAND IN THIS LINKLIST LIBRARY,         *
*             ENTER:  ALIAS HEL H                                     *
*                     ALIAS HEL HELP                                  *
*         D.  USING THE PDS COMMAND IN 'SYS1.CMDLIB', ENTER:          *
*             ALIAS  HELP HELPOLD                                     *
*             NOTE: THIS STEP SHOULD BE REDONE AFTER ANY              *
*                   SYSTEM MAINTENANCE TO THE HELP COMMAND.           *
*                                                                     *
*                                                                     *
*   SINCE MOST MVS SYSTEMS HAVE A BLDL FOR MEMBER NAMES H AND HELP,   *
*   ANY ASSIGNED ALIAS(ES) CAN NOT BE TESTED UNTIL AN IPL HAS BEEN    *
*   COMPLETED.                                                        *
*                                                                     *
*   THE COMMAND NAME HELP IS USED BY ACCOUNT, EDIT, OPER, REVIEW AND  *
*   SUBCOMMAND PARSE FOR TSO/E; THE COMMAND NAME H IS USED BY EDIT;   *
*   AND THE COMMAND NAME HEL IS USED BY PDS AND HEL ITSELF.           *
*                                                                     *
***********************************************************************
          EJECT
***********************************************************************
*                                                                     *
*   LOG OF CHANGES.                                                   *
*         27MAR81 - ALLOW PFK DEFINITIONS TO BE CHANGED.              *
*         10JUL81 - IKJRLSA SOON AFTER PARSE.                         *
*                   FIXED BUG OF IKJEFF18 BEING CALLED TWICE.         *
*                   MISCELLANEOUS INTERNAL RESTRUCTURING OF CODE TO   *
*                   TO ALLOW FUTURE CHANGES. OLD CODE HAD USED UP     *
*                   ALL 3 BASE REGISTERS.                             *
*         14JUL81 - HEX SUBCOMMAND WITHOUT OPERANDS WILL FLIP-FLOP    *
*                   BETWEEN HEX ON AND HEX OFF. PFK9 IS NOW HEX       *
*                   INSTEAD OF HEX ON. PFK12 IS NO LONGER HEX OFF.    *
*         29SEP81 - ACCEPT PFK 13-24 CORRESPONDING TO 1-12.           *
*         29JAN82 - SET UP IOPL BEFORE DOING GTSIZE/ERRTERM.          *
*         29JAN82 - ALLOW MEMBER TO BE SPECIFIED WITH DDNAME, SO USER *
*                   CAN DO THINGS LIKE REVIEW SYSPROC(MEMBER) FILE    *
*                   (AND SHOW DDNAME+NNN IF CONCATENATED).            *
*                   REPLACE 'POINT' WITH 'FIND' TO SUPPORT            *
*                   CONCATENATED PDS'S.                               *
*                                                                     *
*         21MAY84 - CONVERTED REVIEW TO DO FULL-SCREEN HELP FUNCTIONS *
*                 - ADDED SUBCOM SUBCOMMAND                           *
*                 - ADDED HELP SUBCOMMAND AND CHANGED PFK 1 DEFAULT   *
*                 - ADDED TSO SUBCOMMAND                              *
*                 - ADDED F1 SUBCOMMAND FOR SUBCOMMAND POSITIONING    *
*                 - ADDED M SUBCOMMAND FOR USE WITH PFK'S             *
*                 - MODIFIED FIND TO REPOSITION THE SCREEN            *
*                 - CHANGED DEFAULT TRANSLATION TO ASIS               *
*                 - DELETED SMF PROCESSING                            *
*                 - MODIFIED DEBUG TO OUTPUT THE LAST TGET INFO       *
*                 - MODIFIED THE SCREEN HEADER FOR FOUR INPUT FIELDS  *
*                 - MODIFIED BLANK ROUTINE TO CLEAR LAST SCREEN BYTE  *
*                 - MODIFIED FOR TERMINALS WITH MORE THAN 24 LINES    *
*                                                                     *
*                                                                     *
*         11JUL84 - TSO SUBCOMMAND: IF QUOTED, BACK UP ONE CHARACTER  *
*                 - TSO SUBCOMMAND: TURN FULLSCREEN OFF AND ON AGAIN  *
*                                                                     *
*         20NOV84 - ADDED SUPPORT FOR 3278-3, 3278-4 AND 3278-5       *
*                 - CHANGED DEFAULT PF KEYS (PF2 AND PF4)             *
*                                                                     *
*         06JAN85 - CHANGED 3278-5 SUPPORT TO PERFORM A STSIZE MACRO  *
*                 - DUE TO SPF INTERFACE ERRORS.                      *
*                                                                     *
*         08APR85 - CHANGED 3278-5 SUPPORT TO ALWAYS PERFORM A WRITE  *
*                 - ALTERNATE IF A WRITE WAS PERFORMED.               *
*                                                                     *
*         19SEP85 - MODIFIED PFK SUPPORT TO NOT BLANK THE TOP LINE    *
*                 - OF THE DISPLAY WHEN PFK12 IS SET.                 *
*                                                                     *
***********************************************************************
          EJECT
*=====================================================================*
*                                                                     *
*   EXTRACTED FROM THE CBT 89 FEB TAPE, FILE 296.                     *
*   CHANGES MADE BY MOINIL P.A.                                       *
*         31JAN90 - ALL PFK DEFINITIONS MOVED IN A SEPARATE MODULE    *
*                   TO ALLOW THE USE OF UPPER-LOWER CASE CHARACTERS.  *
*         01FEB90 - NOW THE PFK DEFINITIONS CHANGES ARE REFLECTED     *
*                   IN THE HELP SCREEN.                               *
*         02FEB90 - SNAP SUBCOMMAND RESTORED (USE DD-NAME 'SYSSNAP'   *
*                   WHICH MUST BE PRE-ALLOCATED).                     *
*                 - NEW CSECT 'HELEXT' CREATED TO EXTENT THE BASE     *
*                   REGISTERS USE OF CSECT 'HELXEQ'.                  *
*         07FEB90 - ADJUST THE SET UP OF THE HEXADECIMAL COLUMN       *
*                   HEADER DISPLAY.                                   *
*         08FEB90 - AFTER HELP MESSAGES DISPLAY INTERPRET THE END     *
*                   COMMAND AS A REFRESH (ENTER) AND NOT AS EXIT.     *
*   INSTALLED AT OUR SITE AS EXPLAINED IN NOTE 1 OF 'INSTALLATION     *
*                   CONSIDERATIONS' (SEE ABOVE).                      *
*                                                                     *
*=====================================================================*
         EJECT
***********************************************************************
*
*         SYNTAX -   HEL COMMAND
*
*         THE SCREEN WILL NORMALLY CONTAIN 20 RECORDS, ONE PER LINE,
*         80 CHARACTERS PER LINE.
*
*      SUBCOMMANDS :
*         ASIS     - LEAVE LOWER CASE LETTERS IN LOWER CASE
*         BOTTOM   - DISPLAY THE LAST RECORDS
*         CAPS     - TRANSLATE LOWER CASE LETTERS TO CAPS
*         COMMAND  - DISPLAY A DIFFERENT HELP COMMAND
*         DOWN     - DISPLAY RECORDS BELOW THOSE ON THE SCREEN
*         END      - END THE COMMAND
*         FIND     - DISPLAY A RECORD CONTAINING A SPECIFIED STRING
*         HELP     - DISPLAY HELP INFORMATION
*         HEX      - SWITCH HEXADECIMAL FORMATTING ON/OFF.
*         LEFT     - DISPLAY DATA TO THE LEFT
*         LIST     - DISPLAY A SPECIFIED RECORD NUMBER
*         MEMBER   - DISPLAY A DIFFERENT HELP COMMAND
*         PFKNN    - CHANGE DEFINITION OF PF KEY NN.
*         RIGHT    - DISPLAY DATA TO THE RIGHT
*         SUBCOM   - DISPLAY A SUBCOMMAND OF THE CURRENT MEMBER
*         TOP      - DISPLAY THE FIRST RECORDS
*         TSO      - ISSUE A TSO COMMAND
*         UP       - DISPLAY RECORDS ABOVE THOSE ON THE SCREEN
*
*         WHEN 'UP' OR 'DOWN' DOES NOT SPECIFY HOW FAR UP OR DOWN,
*         THE 'RANGE' VALUE IS USED.  THIS VALUE IS ALWAYS DISPLAYED
*         NEAR THE TOP OF THE SCREEN AND CAN BE CHANGED BY MOVING
*         THE CURSOR OVER THE VALUE AND TYPING IN A NEW VALUE.
*         THE NEW VALUE WILL REMAIN IN EFFECT UNTIL THE COMMAND
*         ENDS OR UNTIL YOU CHANGE IT AGAIN.
*
*
*
***********************************************************************
         EJECT
***********************************************************************
*
*         PROGRAM FUNCTION KEYS
*
*         SOME OF THE SUBCOMMANDS DO NOT HAVE TO BE TYPED IN
*         IF THE TERMINAL IS EQUIPPED WITH PROGRAM FUNCTION KEYS.
*         FOR EXAMPLE, HITTING KEY 'PF8' IS EQUIVALENT TO
*         TYPING IN 'DOWN' AND HITTING THE 'ENTER' KEY.
*
*         HERE ARE THE MEANINGS ASSIGNED TO EACH PF KEY.
*
*         ----------------------------------------------------
*         I                I                I                I
*         I      PF1       I      PF2       I      PF3       I
*         I                I                I                I
*         I      HELP      I                I      END       I
*         I                I                I                I
*         ----------------------------------------------------
*         I                I                I                I
*         I      PF4       I      PF5       I      PF6       I
*         I                I                I                I
*         I      END       I      FIND      I                I
*         I                I                I                I
*         ----------------------------------------------------
*         I                I                I                I
*         I      PF7       I      PF8       I      PF9       I
*         I                I                I                I
*         I      UP        I      DOWN      I      HEX       I
*         I                I                I                I
*         ----------------------------------------------------
*         I                I                I                I
*         I      PF10      I      PF11      I      PF12      I
*         I                I                I                I
*         I      LEFT      I      RIGHT     I                I
*         I                I                I                I
*         ----------------------------------------------------
*
*         THE SCREEN IS WRITTEN USING THE 'EXPANDED FULLSCREEN'
*         (EXPFLS=YES) FEATURE OF TCAM, WHICH REQUIRES THAT THE
*         FIRST ORDER IN THE BUFFER BE 'SBA,24,80' OR 'SBA,24,79'.
*         THE FIRST IS USED TO SUPPRESS LINE COUNTING, AND THE
*         LATTER IS USED TO RESET THE LINE COUNTER.
*
***********************************************************************
         EJECT
         PRINT OFF
         MACRO
&NAME    MSG   &MSG
&NAME    DC    AL2(&NAME.L-2),C&MSG
&NAME.L  EQU   *-&NAME
         MEND
         MACRO
&NAME    DCS
.**********************************************************************
.*                                                                    *
.*        DCS  -  DEFINE CONSTANT FOR SCREEN                          *
.*                                                                    *
.*        WRITTEN BY BILL GODFREY                                     *
.*        PLANNING RESEARCH CORPORATION                               *
.*        PRC COMPUTER CENTER, MCLEAN VA 22101                        *
.*        DATE WRITTEN. JANUARY 8 1981.                               *
.*        DATE UPDATED. MARCH 18 1982. (ROW AND COL IN PARENS)        *
.*                                                                    *
.*        THIS MACRO IS USED FOR CODING A FULLSCREEN 3270 DISPLAY.    *
.*                                                                    *
.*        SAMPLE                                                      *
.*           DCS    AL1(WCC),SBA,(1,1),RTA,(7,1),X'00',IC             *
.*                                                                    *
.*        IT SIMPLIFIES THE CODING OF A SCREEN IN THE FOLLOWING WAYS. *
.*        .  BUFFER ADDRESSES ARE SPECIFIED AS ROW AND COLUMN NUM-    *
.*           BER.  THE MACRO TRANSLATES THEM INTO THE 3270 CODE.      *
.*        .  ORDERS ARE SPECIFIED BY NAME, SUCH AS 'SBA' AND 'SF',    *
.*           SO YOU DONT HAVE TO KNOW THE HEX CODES FOR THEM,         *
.*        .  COMMONLY USED ATTRIBUTE BYTES ARE SPECIFIED BY NAME      *
.*           (A SET OF RESERVED NAMES) SO YOU DONT HAVE TO KNOW       *
.*           THE HEX CODES FOR THEM.                                  *
.*        .  IT SAVES A LOT OF DOCUMENTATION WORK, AND MAKES          *
.*           THE CODE EASIER FOR OTHERS TO UNDERSTAND.                *
.*                                                                    *
.*        THE USER OF THE MACRO MUST STILL UNDERSTAND HOW A SCREEN    *
.*        IS CONSTRUCTED BEFORE USING IT. THE MACRO MERELY MAKES IT   *
.*        EASIER TO SPECIFY THE VALUES.  IT DOES VERY LITTLE ERROR    *
.*        CHECKING.  FOR INSTANCE, IT DOES NOT CHECK TO SEE IF        *
.*        YOU FOLLOW AN 'SBA' WITH A BUFFER ADDRESS.  IT IS POSSIBLE  *
.*        TO CODE A THOROUGHLY INVALID SCREEN.                        *
.*                                                                    *
.*        THE MACRO MAY HAVE ANY NUMBER OF OPERANDS, CONSISTING OF    *
.*        ANY COMBINATION OF THE FOLLOWING.                           *
.*                                                                    *
.*        .  AN ORDER.                                                *
.*           VALID ORDERS ARE: SBA, SF, RTA, IC, PT, EUA.             *
.*        .  A BUFFER ADDRESS IN PARENTHESES.                         *
.*           IF AN OPERAND IS IN PARENTHESES, IT IS ASSUMED THAT      *
.*           THE ROW AND COLUMN NUMBER ARE BETWEEN THE PARENS,        *
.*           SEPARATED BY A COMMA.  EXAMPLE: (1,1)                    *
.*           THIS FORM OF BUFFER ADDRESS IS NEW AS OF MARCH 18 1982.  *
.*        .  A ROW OR COLUMN NUMBER OF A BUFFER ADDRESS (OLD FORMAT). *
.*           IF AN OPERAND IS NUMERIC, IT IS ASSUMED TO BE            *
.*           A ROW OR COLUMN NUMBER.  IT TAKES 2 OPERANDS TO          *
.*           SPECIFY THE BUFFER ADDRESS (ROW AND COLUMN) SO NUMERIC   *
.*           OPERANDS MUST ALWAYS BE SPECIFIED IN PAIRS, THE          *
.*           FIRST BEING THE ROW AND THE SECOND BEING THE COLUMN.     *
.*           THIS FORMAT IS SUPPORTED ONLY FOR COMPATIBILITY WITH     *
.*           THE ORIGINAL VERSION OF THIS MACRO.                      *
.*        .  AN ATTRIBUTE BYTE.                                       *
.*           VALID ATTRIBUTE BYTES ARE:                               *
.*           UNPLO -  UNPROTECTED NORMAL INTENSITY                    *
.*           UNPHI  - UNPROTECTED HIGH INTENSITY                      *
.*           UNPNP  - UNPROTECTED NO-DISPLAY                          *
.*           PROLO  - PROTECTED NORMAL INTENSITY                      *
.*           PROLOS - PROTECTED NORMAL INTENSITY AUTO-SKIP            *
.*           PROHI  - PROTECTED HIGH INTENSITY                        *
.*           PROHIS - PROTECTED HIGH INTENSITY AUTO-SKIP              *
.*        .  A HEX, CHARACTER, OR ADDRESS CONSTANT.                   *
.*           FOR EXAMPLE, X'00', OR C'ENTER SIGNON'                   *
.*           THIS CAN BE USED FOR DATA WITHIN FIELDS OR FOR           *
.*           ATTRIBUTE BYTES, ORDERS, THE 'WCC', OR BUFFER            *
.*           ADDRESSES (IF YOU WANT TO FIGURE THEM OUT).              *
.*                                                                    *
.*        IF THE OPERANDS DO NOT ALL FIT ON ONE LINE, YOU CAN         *
.*        EITHER CONTINUE THE LINE IN THE STANDARD ASSEMBLER WAY      *
.*        OR CODE THE MACRO AGAIN ON THE NEXT LINE WITH THE           *
.*        REMAINING OPERANDS.  THE RESULT IS THE SAME EITHER WAY.     *
.*                                                                    *
.*        THE BUFFER ADDRESS CONVERSIONS ARE FOR A                    *
.*        SCREEN SIZE OF 24 ROWS BY 80 COLUMNS. FOR SCREENS           *
.*        OF OTHER DIMENSIONS (43 BY 80, 12 BY 40) THE MACRO          *
.*        NEEDS ONLY A FEW CHANGES.                                   *
.*                                                                    *
.*        WARNING: IF YOU CODE THE MACRO WITH A LABEL IN COLUMN 1,    *
.*        AND YOU LIKE USING LENGTH ATTRIBUTES, BEWARE THAT THE       *
.*        LENGTH ATTRIBUTE OF THE LABEL IS NOT NECESSARILY THE        *
.*        TOTAL LENGTH OF THE DATA GENERATED BY THE MACRO.            *
.*                                                                    *
.**********************************************************************
.*
         LCLA  &R,&C,&P,&Q
         LCLA  &AN,&AS,&AL
         LCLB  &B,&NUMERIC,&INTEGER
         LCLC  &T(64)
         LCLC  &N,&ROW,&COL
         LCLC  &CS,&STRING
&T(1)    SETC  '40'
&T(2)    SETC  'C1'
&T(3)    SETC  'C2'
&T(4)    SETC  'C3'
&T(5)    SETC  'C4'
&T(6)    SETC  'C5'
&T(7)    SETC  'C6'
&T(8)    SETC  'C7'
&T(9)    SETC  'C8'
&T(10)   SETC  'C9'
&T(11)   SETC  '4A'
&T(12)   SETC  '4B'
&T(13)   SETC  '4C'
&T(14)   SETC  '4D'
&T(15)   SETC  '4E'
&T(16)   SETC  '4F'
.*
&T(17)   SETC  '50'
&T(18)   SETC  'D1'
&T(19)   SETC  'D2'
&T(20)   SETC  'D3'
&T(21)   SETC  'D4'
&T(22)   SETC  'D5'
&T(23)   SETC  'D6'
&T(24)   SETC  'D7'
&T(25)   SETC  'D8'
&T(26)   SETC  'D9'
&T(27)   SETC  '5A'
&T(28)   SETC  '5B'
&T(29)   SETC  '5C'
&T(30)   SETC  '5D'
&T(31)   SETC  '5E'
&T(32)   SETC  '5F'
.*
&T(33)   SETC  '60'
&T(34)   SETC  '61'
&T(35)   SETC  'E2'
&T(36)   SETC  'E3'
&T(37)   SETC  'E4'
&T(38)   SETC  'E5'
&T(39)   SETC  'E6'
&T(40)   SETC  'E7'
&T(41)   SETC  'E8'
&T(42)   SETC  'E9'
&T(43)   SETC  '6A'
&T(44)   SETC  '6B'
&T(45)   SETC  '6C'
&T(46)   SETC  '6D'
&T(47)   SETC  '6E'
&T(48)   SETC  '6F'
.*
&T(49)   SETC  'F0'
&T(50)   SETC  'F1'
&T(51)   SETC  'F2'
&T(52)   SETC  'F3'
&T(53)   SETC  'F4'
&T(54)   SETC  'F5'
&T(55)   SETC  'F6'
&T(56)   SETC  'F7'
&T(57)   SETC  'F8'
&T(58)   SETC  'F9'
&T(59)   SETC  '7A'
&T(60)   SETC  '7B'
&T(61)   SETC  '7C'
&T(62)   SETC  '7D'
&T(63)   SETC  '7E'
&T(64)   SETC  '7F'
.*
&N       SETC  '&NAME'
&AN      SETA  N'&SYSLIST          NUMBER OF OPERANDS
&AS      SETA  0
&B       SETB  0 FALSE
.EACH    AIF   (&AN EQ 0).EPILOG
&AS      SETA  &AS+1
&CS      SETC  '&AS'
&AL      SETA  K'&SYSLIST(&AS)
         AIF   (T'&SYSLIST(&AS) EQ 'O').NEXT
         AIF   ('&SYSLIST(&AS)'(1,1) EQ '(').PAIR
&NUMERIC SETB  (T'&SYSLIST(&AS) EQ 'N')
&INTEGER SETB  ('&SYSLIST(&AS)'(1,1) GE '0')
         AIF   (&NUMERIC AND &INTEGER).ROWCOL
         AIF   (NOT &B).ROWCOLX
         MNOTE 4,'             &CS.) MISSING COLUMN NUMBER'
&B       SETB  0 FALSE
.ROWCOLX ANOP
&STRING  SETC  '&SYSLIST(&AS)'
.*             ORDERS
         AIF   ('&STRING' EQ 'SBA').SBA
         AIF   ('&STRING' EQ 'SF').SF
         AIF   ('&STRING' EQ 'RTA').RTA
         AIF   ('&STRING' EQ 'IC').IC
         AIF   ('&STRING' EQ 'PT').PT
         AIF   ('&STRING' EQ 'EUA').EUA
.*             ATTRIBUTES
         AIF   ('&STRING' EQ 'UNPLO').UNPLO
         AIF   ('&STRING' EQ 'UNPHI').UNPHI
         AIF   ('&STRING' EQ 'UNPNP').UNPNP
         AIF   ('&STRING' EQ 'PROLO').PROLO
         AIF   ('&STRING' EQ 'PROLOS').PROLOS
         AIF   ('&STRING' EQ 'PROHI').PROHI
         AIF   ('&STRING' EQ 'PROHIS').PROHIS
.*             CONSTANTS
.*             IF THE OPERAND IS NONE OF THE ABOVE, IT IS
.*             PRESUMED TO BE ANY VALID 'DC' CONSTANT.
.DC      ANOP
&N       DC    &STRING
         AGO   .NEXT
.SBA     ANOP
&N       DC    X'11'               SET BUFFER ADDRESS
         AGO   .NEXT
.SF      ANOP
&N       DC    X'1D'               START FIELD
         AGO   .NEXT
.RTA     ANOP
&N       DC    X'3C'               REPEAT TO ADDRESS
         AGO   .NEXT
.IC      ANOP
&N       DC    X'13'               INSERT CURSOR
         AGO   .NEXT
.PT      ANOP
&N       DC    X'05'               PROGRAM TAB
         AGO   .NEXT
.EUA     ANOP
&N       DC    X'12'               ERASE UNPROTECTED TO ADDRESS
         AGO   .NEXT
.UNPLO   ANOP
&N       DC    X'40'               UNPROTECTED NORMAL INTENSITY
         AGO   .NEXT
.UNPHI   ANOP
&N       DC    X'C8'               UNPROTECTED HIGH INTENSITY
         AGO   .NEXT
.UNPNP   ANOP
&N       DC    X'4C'               UNPROTECTED NO-DISPLAY
         AGO   .NEXT
.PROLO   ANOP
&N       DC    X'60'               PROTECTED NORMAL INTENSITY
         AGO   .NEXT
.PROLOS  ANOP
&N       DC    X'F0'               PROTECTED NORMAL INTENSITY SKIP
         AGO   .NEXT
.PROHI   ANOP
&N       DC    X'E8'               PROTECTED HIGH INTENSITY
         AGO   .NEXT
.PROHIS  ANOP
&N       DC    X'F8'               PROTECTED HIGH INTENSITY SKIP
         AGO   .NEXT
.**********************************************************************
.PAIR    ANOP
         AIF   (N'&SYSLIST(&AS) NE 2).PERR1
&NUMERIC SETB  (T'&SYSLIST(&AS,1) EQ 'N')
&INTEGER SETB  ('&SYSLIST(&AS,1)'(1,1) GE '0')
         AIF   (NOT &NUMERIC OR NOT &INTEGER).PERR2
&R       SETA  &SYSLIST(&AS,1)
&NUMERIC SETB  (T'&SYSLIST(&AS,2) EQ 'N')
&INTEGER SETB  ('&SYSLIST(&AS,2)'(1,1) GE '0')
         AIF   (NOT &NUMERIC OR NOT &INTEGER).PERR2
&C       SETA  &SYSLIST(&AS,2)
         AIF   (&R LT 1 OR &R GT 43).ROWERR *** WAS 24
         AIF   (&C LT 1 OR &C GT 80).COLERR
&P       SETA  (&R-1)*80+&C-1
&Q       SETA  &P/64               QUOTIENT
&R       SETA  &P-&Q*64+1          REMAINDER+1
&Q       SETA  &Q+1                QUOTIENT+1
&N       DC    X'&T(&Q)&T(&R)'     ROW AND COLUMN
         AGO   .NEXT
.PERR1   MNOTE 4,'             &CS.) PARENS FOUND BUT NOT 2 NUMBERS'
         MEXIT
.PERR2   MNOTE 4,'             &CS.) NON NUMERIC ROW/COLUMN'
         MEXIT
.**********************************************************************
.ROWCOL  ANOP
         AIF   (&B).COL            BRANCH IF ROW HAS BEEN CAPTURED
&R       SETA  &SYSLIST(&AS)
&B       SETB  1 TRUE              SET ROW-HAS-BEEN-CAPTURED
         AGO   .NEXTR
.COL     ANOP
&C       SETA  &SYSLIST(&AS)
&B       SETB  0 FALSE             RESET SWITCH
         AIF   (&R LT 1 OR &R GT 43).ROWERR *** WAS 24
         AIF   (&C LT 1 OR &C GT 80).COLERR
&P       SETA  (&R-1)*80+&C-1
&Q       SETA  &P/64               QUOTIENT
&R       SETA  &P-&Q*64+1          REMAINDER+1
&Q       SETA  &Q+1                QUOTIENT+1
&N       DC    X'&T(&Q)&T(&R)'     ROW AND COLUMN
         AGO   .NEXT
.ROWERR  MNOTE 4,'             &CS.) VALUE &R INVALID, MUST BE 1 TO 43'
         AGO   .NEXT
.COLERR  MNOTE 4,'             &CS.) VALUE &C INVALID, MUST BE 1 TO 80'
.NEXT    ANOP
&N       SETC  ''                  TURN OFF NAME
.NEXTR   ANOP
&AN      SETA  &AN-1
         AGO   .EACH
.EPILOG  ANOP
         MEND
         PRINT ON
         SPACE 1
*   THE NAME OF THE IBM HELP COMMAND (&IBMHELP) IS SET IN THE
*   FOLLOWING STATEMENT:
         SPACE 1
         GBLC  &IBMHELP
&IBMHELP SETC  'H'                 'H', 'HELP' OR 'HELPOLD'
         SPACE 1
* SEE THE DISCUSSION IN THE INITIAL PROGRAM COMMENTS FOR DIRECTIONS
         SPACE 1
HEL      START
         SPACE 1
        $DEFREG
         EJECT
        $XENT  BASE=(R10,R11,R12),LV=@DATAL,SP=1,TYPE=RENT
         LR    R2,R1
         USING CPPL,R2
         LR    R9,R13
         USING @DATA,R9
         EJECT
         STM   R10,R12,BASE1
         L     R14,=A(HELXEQ)
         ST    R14,BASE2
         LA    R15,1
         LA    R14,4095(R15,R14)   BASE
         ST    R14,BASE2+4
         LA    R14,4095(R15,R14)   BASE
         ST    R14,BASE2+8
         ST    R2,CPPLPTR
         MVC   HELCBUF(16),0(R2)   HELCBUF, HELUPT, HELPSCB, HELECT
         L     R1,0(,R2)           START OF COMMAND TEXT
         MVC   COMMND(2),2(R1)     OFFSET TO START OF OPERANDS
         MVI   STATUS,0
         MVI   MDFL,0
         XC    LINKAREA(8),LINKAREA
         XR    R15,R15
         STH   R15,RC              SET RC = 0
         ST    R15,TTRZ            SET Z = 0
         XC    MSG(2),MSG
         XC    MYANS,MYANS         IN CASE IKJRLSA BEFORE PARSE
         LA    R1,PFKTAB-2048
         LA    R1,2048(,R1)
         ST    R1,APFKTB           POINT TO PFK TABLE START
         LA    R1,SCREENW-PFKTAB(R1)
         ST    R1,SCREENH          POINT TO SCREEN START
         SPACE 1
*----------------------------------------------------------*
*        SET UP IOPL FOR PUTLINE                           *
*----------------------------------------------------------*
         SPACE 1
         LA    R15,MYIOPL
         USING IOPL,R15
         MVC   IOPLUPT(4),CPPLUPT
         MVC   IOPLECT(4),CPPLECT
         LA    R0,MYECB
         ST    R0,IOPLECB
         XC    MYECB,MYECB
         LA    R0,MYPTPB
         ST    R0,IOPLIOPB
         DROP  R15                 IOPL
         L     R15,CVTPTR          CVT POINTER
         USING CVT,R15
         TM    CVTPUTL,X'80'       IS PUTLINE LOADED? (VS2)
         BNO   PUTLOAD             NO - BRANCH TO LOAD
         L     R0,CVTPUTL          YES - USE CVTPUTL
         B     PUTLOADX            BRANCH AROUND LOAD
         DROP  R15
PUTLOAD  LA    R0,=CL8'IKJPUTL '
        LOAD   EPLOC=(0)
PUTLOADX LR    R15,R0              GET ENTRY ADDRESS
         LA    R15,0(,R15)         CLEAR HI BYTE FOR DELETE ROUTINE
         ST    R15,MYPUTLEP        SAVE PUTLINE ENTRY ADDRESS
         SPACE 1
*----------------------------------------------------------*
*        CHECK IF COMMAND AND SUBCOMMAND CAN BE PROCESSED  *
*----------------------------------------------------------*
         SPACE 1
         L     R1,HELECT           START OF ECT
         USING ECT,R1
         MVI   FILEKV,C'N'         ASSUME COMMAND, NO SUBCOMMAND
         MVC   PCMD,ECTPCMD        SAVE COMMAND NAME
         MVC   SCMD,ECTSCMD        SAVE SUBCOMMAND NAME
         CLC   ECTPCMD(2),=CL8'HELP    ' HELP COMMAND?
         BE    GTSZE               YES, BRANCH
         CLC   ECTPCMD(2),=C'H '   H COMMAND?
         BE    GTSZE               YES, BRANCH
         MVI   FILEKV,C'S'         COMMAND WITH SUBCOMMANDS
         CLC   ECTSCMD(2),=CL20' ' NULL SUBCOMMAND?
         BE    GTSZE               YES, BRANCH
         CLC   ECTSCMD(2),=C'H '   H SUBCOMMAND?
         BE    GTSZE               YES, BRANCH
         CLC   ECTSCMD(2),=CL8'HELP    ' HELP SUBCOMMAND?
         BNE   ERRTERM             NO, CANNOT PROCESS
         CLI   ECTSCMD+4,C'X'      HELPX SUBCOMMAND?
         BNE   GTSZE               NO, BRANCH
         OI    MDFL,HELPX          YES, SET A FLAG
         DROP  R1
         SPACE 1
*----------------------------------------------------------*
*        CHECK TERMINAL SCREEN SIZE                        *
*----------------------------------------------------------*
         SPACE 1
GTSZE   GTSIZE
         CH    R0,=H'24'           AT LEAST 24 ROWS (LINES)
         BL    ERRTERM             NO, TERMINATE
         SPACE 1
*----------------------------------------------------------*
*        SET UP PFK DEFAULTS                               *
*----------------------------------------------------------*
         SPACE 1
         LA    R1,PFKDEF
         L     R15,APFKTB
         LA    R0,PFKDEFN
PFKINIT  MVI   0(R15),C' '
         MVC   1(L'PFKTAB-1,R15),0(R15) PAD WITH BLANKS
         MVC   0(L'PFKDEF,R15),0(R1) INSERT DEFAULT
         LA    R1,L'PFKDEF(,R1)    POINT TO NEXT DEFAULT
         LA    R15,L'PFKTAB(,R15)  POINT TO NEXT PFK ENTRY
         BCT   R0,PFKINIT          11 MORE TIMES
         MVI   0(R15),0            END OF TABLE
         SPACE 1
*----------------------------------------------------------*
*        SET UP PPL FOR PARSE                              *
*----------------------------------------------------------*
         SPACE 1
         LA    R15,MYPPL
         USING PPL,R15
         MVC   PPLUPT(4),CPPLUPT
         MVC   PPLECT(4),CPPLECT
         LA    R0,MYECB
         ST    R0,PPLECB
         XC    MYECB,MYECB
         L     R0,=A(HELCL)
         ST    R0,PPLPCL
         LA    R0,MYANS
         ST    R0,PPLANS
         MVC   PPLCBUF(4),CPPLCBUF
         ST    R9,PPLUWA
         DROP  R15                 PPL
         SPACE 1
*----------------------------------------------------------*
*        CALL THE PARSE SERVICE ROUTINE                    *
*----------------------------------------------------------*
         SPACE 1
         LR    R1,R15              POINT TO PPL
         L     R15,CVTPTR          CVT POINTER
         USING CVT,R15
         TM    CVTPARS,X'80'       IF HI ORDER BIT NOT ON
         BNO   PARSLNK             THEN DO LINK, NOT CALL
         L     R15,CVTPARS         CVTPARS
         DROP  R15
         BALR  R14,R15             CALL IKJPARS
         B     PARSEEXT            SKIP AROUND LINK
PARSLNK LINK   EP=IKJPARS,SF=(E,LINKAREA)
PARSEEXT LTR   R15,R15
         BZ    PARSEOK
         LA    R1,MSG01
         LA    R0,L'MSG01
         BAL   R14,PUTMSG1
         LA    R15,12
         B     EXIT
PARSEOK  L     R3,MYANS
         USING IKJPARMD,R3
         SPACE 1
*----------------------------------------------------------*
*        FILL IN ALL INFO FROM PARSE                       *
*----------------------------------------------------------*
         SPACE 1
         MVI   DEBUGSW,0           NO DEBUG MESSAGES YET
         MVI   FILEKV,C'N'         ASSUME COMMAND WITH NO SUBCOMMANDS
         MVI   FILEKV+1,X'01'      ASSUME FILE(SYSHELP)
         MVC   $SUBLINE,=F'0'
         MVI   $SUBLINE,C'Y'       SUBCOMMAND IS SATISFIED
         MVC   $SUBCOM(L'$SUBCOM),=CL20' '
         MVC   $MEMBER,=CL8'COMMANDS'
         LA    R6,MEMBRPO
         TM    6(R6),X'80'         MEMBER SPECIFIED?
         BZ    PARSEMX             NO, BRANCH
         MVC   $MEMBER(L'$MEMBER),=CL20' '
         L     R14,0(,R6)          POINT TO MEMBER VALUE
         LH    R1,4(,R6)           GET LENGTH
         BCT   R1,*+L'*+6          LENGTH MINUS 1 FOR EX
         MVC   $MEMBER(*-*),0(R14) <<EXECUTED>>
         EX    R1,*-6              MOVE VOLUME
PARSEMX  L     R1,HELECT           START OF ECT
         USING ECT,R1
         MVC   TGETREGS(8),ECTSWS2
         MVC   REPLY(8),ECTSWS2
         MVC   TGETREGS+8(4),=F'8'
         CLC   ECTPCMD(2),=CL8'HELP    ' HELP COMMAND?
         BE    PARSEO              YES, BRANCH
         CLC   ECTPCMD(2),=C'H '   HELP COMMAND?
         BE    PARSEO              YES, BRANCH
         MVI   FILEKV,C'S'         COMMAND WITH SUBCOMMANDS
         MVI   $SUBLINE,C'N'       SUBCOMMAND IS NOT SATISFIED
         MVC   $SUBCOM(8),$MEMBER  SUBCOMMAND IS MEMBER NAME
         MVC   $MEMBER(8),ECTPCMD  CHANGE MEMBER NAME
         DROP  R1
         CLC   $MEMBER(8),=C'HLHL    ' HELP FOR HEL?
         BNE   *+L'*+6             NO, BRANCH
         MVC   $MEMBER(8),=CL8'HEL' YES, CONVERT TO HEL
         CLC   $SUBCOM(8),$MEMBER  COMMAND NAME=SUBCOMMAND?
         BE    PARSEX              YES, BRANCH
         TM    6(R6),X'80'         SUBCOMMAND SPECIFIED?
         BO    PARSEO              YES, BRANCH
PARSEX   MVI   $SUBLINE,C'Y'       SUBCOMMAND IS SATISFIED
         MVC   $SUBCOM(L'$SUBCOM),=CL20' ' NO SUBCOMMAND NAME
PARSEO   LA    R0,7
         LA    R15,$SUBCOM+8
PARSEO1  BCTR  R15,0               SCAN
         CLI   0(R15),C' '           FOR
         BNE   PARSEO2                 LAST
         BCT   R0,PARSEO1                NON-BLANK
PARSEO2  STH   R0,$SUBLEN          MACHINE LENGTH OF SUBCOMMAND
         LA    R4,$OPERAND
         LA    R6,OPLIST
PARSELP  MVC   0(20,R4),=CL20' '   CLEAR THIS ELEMENT
         LA    R1,0(,R6)           ADDRESS OF PARAMETER START
         LTR   R1,R1               ANY PARAMETER?
         BZ    PARSEOX             NO, BRANCH
         TM    6(R6),X'80'         OPERAND SPECIFIED?
         BZ    PARSEOX             NO, BRANCH
         L     R14,0(,R6)          POINT TO MEMBER VALUE
         LH    R1,4(,R6)           GET LENGTH
         BCT   R1,*+L'*+6          LENGTH MINUS 1 FOR EX
         MVC   0(*-*,R4),0(R14)    <<EXECUTED>>
         EX    R1,*-6              MOVE VOLUME
         LA    R4,20(,R4)          NEXT OPERAND OUTPUT LOCATION
         L     R6,8(,R6)           NEXT OPERAND PARAMETER LOCATION
         B     PARSELP
PARSEOX  MVC   FKV,FKW             GET FUNCTION KEYWORD
         MVC   SKV,SKW             GET SYNTAX KEYWORD
         MVC   OKV,OKW             GET OPERANDS KEYWORD
         MVC   AKV,AKW             GET ALL KEYWORD
         MVC   MKV,MKW             GET MSGS KEYWORD
         MVC   MKV(1),PKW+1        GET POSIT KEYWORD
         CLC   PCMD(8),=C'HLHL    ' HEL HELP?
         BNE   *+L'*+6             NO, BRANCH
         XC    MKV(2),MKV          IGNORE MSGS AND POSIT KEYWORDS
         MVI   HELPFLG,0           NO HELP YET
         MVI   MEMBFLG,0           NO MEMBER OR SUBCOMMAND YET
         DROP  R3                  IKJPARMD
        IKJRLSA MYANS
         XC    MYANS,MYANS
         CLI   MKV,0               ANY POSIT KEYWORD?
         BH    ERRTERM             YES, INVOKE HELP INSTEAD
         CLI   MKV+1,0             ANY MSGS KEYWORD?
         BH    ERRTERM             YES, INVOKE HELP INSTEAD
         MVI   $DSNAME+1,7
         MVC   $DSNAME+2(8),=CL8'SYSHELP'
         DEVTYPE $DSNAME+2,DEVDATA GET DEVICE TYPE
         LTR   R15,R15             FILENAME VALID?
         BZ    GOTFILE             YES, BRANCH
         MVI   FILEKV+1,0
         MVI   $DSNAME+1,9
         MVC   $DSNAME+2(9),=CL9'SYS1.HELP'
         B     NOFILE              NO, TRY SYS1.HELP
GOTFILE  TM    DEVDATA+2,X'20'     DIRECT ACCESS
         BZ    FILERR              NO, BRANCH
         LA    R4,DYNDCBW
         L     R1,=A(SEQDCB)
         MVC   0(SEQDCBL,R4),0(R1)
         USING IHADCB,R4
         LA    R0,JFCB
         LA    R1,DYNEXLST
         ST    R0,0(,R1)
         MVI   0(R1),X'87'
         ST    R1,DCBEXLST
         MVC   DCBDDNAM(L'DCBDDNAM),$DSNAME+2
         MVC   $DDNAML(46),$DSNAME
         DROP  R4
         LA    R0,4                ADD 4
         AH    R0,$DDNAML            TO LENGTH OF DDNAME
         STH   R0,$DDNAML              FOR +NNN (CONCAT NUMBER)
         MVI   OPEND,X'80'
        RDJFCB ((R4)),MF=(E,OPEND)
         MVC   $DSNAME+2(44),JFCB
         LA    R1,$DSNAME+45       LAST CHAR OF DSNAME
         LA    R0,44               INITIAL LENGTH
FILEA    CLI   0(R1),C' '          IS THIS LAST NONBLANK
         BNE   FILEB               YES, BRANCH
         BCTR  R1,0                BACK UP 1 CHARACTER
         BCT   R0,FILEA            DECREMENT LENGTH AND BRANCH
FILEB    STH   R0,$DSNAME          STORE LENGTH OF DSNAME
         MVI   DSORG,DCBDSGPS      DSORG PS
         CLI   $MEMBER,C' '        DDNAME(MEMBER)
         BE    FILEC               NO
         MVI   DSORG,DCBDSGPO      YES, INDICATE PARTITIONED
         B     OKDSORG             DONT LOOK AT JFCB
FILEC    CLI   JFCB+44,C' '        DDNAME ALLOCATED TO A MEMBER
         BE    OKDSORG             NO
         MVC   $MEMBER,JFCB+44     YES, SAVE THE MEMBER NAME
         MVI   DSORG,DCBDSGPO      DSORG PO
         B     OKDSORG
FILERR   LA    R0,MSG14C
         MVC   MSG(L'MSG14),MSG14
         LA    R15,MSG+L'MSG14
         LA    R14,$DSNAME
         LH    R1,0(,R14)
         BCT   R1,*+L'*+6
         MVC   MSG+L'MSG14(*-*),2(R14)
         EX    R1,*-6
         LA    R15,1(R1,R15)
         LR    R14,R0              POINTS TO MSG14C
         MVC   0(L'MSG14C,R15),0(R14)
         LA    R0,L'MSG14+L'MSG14C+1(,R1)
         LA    R1,MSG
         BAL   R14,PUTMSG1
         B     EXITA12
         SPACE 1
*----------------------------------------------------------*
*        ALLOCATE THE DATASET                              *
*----------------------------------------------------------*
         SPACE 1
NOFILE   LA    R1,MYDAPL
         USING DAPL,R1
         MVC   DAPLUPT(4),CPPLUPT
         MVC   DAPLECT(4),CPPLECT
         LA    R0,MYECB
         ST    R0,DAPLECB
         MVC   DAPLPSCB(4),CPPLPSCB
         LA    R15,MYDAPB
         ST    R15,DAPLDAPB
         DROP  R1                  DAPL
         USING DAPB08,R15
         XC    0(84,R15),0(R15)
         MVI   DA08CD+1,X'08'
         LA    R0,$DSNAME
         ST    R0,DA08PDSN
         MVC   DA08DDN(L'DA08DDN),=CL20' '
         MVC   DA08UNIT(L'DA08UNIT),=CL20' '
         MVC   DA08SER(L'DA08SER),=CL20' '
         MVC   DA08MNM(L'DA08MNM),=CL20' ' NEVER ALLOCATE WITH MEMBER
         MVC   DA08PSWD(L'DA08PSWD),=CL20' '
         MVI   DA08DSP1,DA08SHR
         MVI   DA08DPS2,DA08KEEP
         MVI   DA08DPS3,DA08KEP
         LA    R1,MYDAPL
         BAL   R14,CALLDAIR
         LTR   R15,R15
         BZ    OKDAIR
         BAL   R14,DAIRFAIL
         B     EXITA12
OKDAIR   OI    STATUS,STALLOC      TELL CLEANUP TO FREE IT
         LA    R15,MYDAPB
         MVC   $DDNAME,DA08DDN
         MVC   DSORG,DA08DSO
         TM    DA08DSO,DCBDSGPO    IS DSORG PARTITIONED?
         BO    OKDSORG             YES, BRANCH
ERRDSORG LA    R1,MSG06            DSORG IS NOT PO
         LA    R0,L'MSG06            ISAM=X'80' DA=X'20'
         BAL   R14,PUTMSG1           VSAM=X'00' NONE=X'00'
         B     EXITA12
         DROP  R15                 DAPB08
         SPACE 1
*----------------------------------------------------------*
*        GET THE UCB ADDRESS AND VOLUME SERIAL             *
*----------------------------------------------------------*
         SPACE 1
OKDSORG  L     R1,CVTPTR           CVT POINTER
         USING CVT,R1
         L     R1,CVTTCBP          TCB WORDS
         DROP  R1
         L     R1,4(,R1)           CURRENT TCB
         USING TCB,R1
         L     R1,TCBTIO           TIOT
         DROP  R1
         XR    R15,R15
         USING TIODSECT,R1
DDLOOP   CLI   TIOENTRY,0          TIOENTRY - END OF TIOT?
         BE    EXITA12             YES, BRANCH (NEVER HAPPENS)
         CLC   TIOEDDNM,$DDNAME    DOES DDNAME MATCH
         BE    DDFOUND
         IC    R15,TIOELNGH
         ALR   R1,R15
         B     DDLOOP
DDFOUND  ICM   R15,B'0111',TIOEFSRT
         DROP  R1
         ST    R15,$UCBAD
         USING UCBDSECT,R15
         TM    UCBTBYT3,UCB3DACC   DIRECT ACCESS DEVICE?
         BZ    *+L'*+6             NO, BYPASS VOLSER
         MVC   $VOLSER,UCBVOLI
         SPACE 1
*----------------------------------------------------------*
*        OBTAIN THE DSCB FROM THE VTOC                     *
*----------------------------------------------------------*
         SPACE 1
         CLI   FILEKV+1,1          'FILE' SPECIFIED?
         BNE   OBTX                NO, BYPASS OBTAIN
         L     R15,$UCBAD          POINT TO UCB
         TM    UCBTBYT3,UCB3DACC   DIRECT ACCESS DEVICE?
         BZ    OBTX                NO, BYPASS OBTAIN
         DROP  R15
         LA    R1,OBTAINW
         MVC   0(OBTAINL,R1),OBTAIN
         LA    R0,$DSNAME+2        DSN FOR OBTAIN
         ST    R0,4(,R1)
         LA    R0,$VOLSER          VOLUME FOR OBTAIN
         ST    R0,8(,R1)
         LA    R0,MYDSCB           ANSWER AREA FOR OBTAIN
         ST    R0,12(,R1)
        OBTAIN (1)
         LTR   R15,R15             WAS OBTAIN SUCCESSFUL
         BZ    OKDSCB              YES, BRANCH
         LA    R1,MSG09            UNABLE TO OBTAIN DSCB
         LA    R0,L'MSG09
         BAL   R14,PUTMSG1
         B     EXITA12
OKDSCB   MVC   DSORG,MYDSCB-44+X'52'
         TM    DSORG,DCBDSGPS      DSORG = PS
         BO    OBTX
         TM    DSORG,DCBDSGPO      DSORG = PO
         BNO   ERRDSORG
         SPACE 1
*----------------------------------------------------------*
*        CALL PHASE 2 FOR MAIN PROCESSING                  *
*----------------------------------------------------------*
         SPACE 1
OBTX     L     R15,=A(HELXEQ)      GET ADDRESS OF PHASE 2
         BALR  R14,R15             GO TO PHASE 2
         B     EXITARC             PHASE 2 HAS SET RC
         SPACE 1
*----------------------------------------------------------*
*        RETURN FROM PHASE 2 TO TERMINATE                  *
*----------------------------------------------------------*
         SPACE 1
EXITA12  LA    R15,12
         STH   R15,RC
EXITARC  TM    STATUS,STALLOC      FREE REQUIRED?
         BZ    NOFREE
         LA    R1,MYDAPL
         LA    R15,MYDAPB
         USING DAPB18,R15
         XC    0(40,R15),0(R15)
         MVI   DA18CD+1,X'18'
         MVC   DA18DDN,$DDNAME
         MVC   DA18MNM(L'DA18MNM),=CL20' '
         MVC   DA18SCLS(L'DA18SCLS),=CL20' '
         BAL   R14,CALLDAIR        UNALLOCATE
         NI    STATUS,255-STALLOC  UNALLOCATED
         DROP  R15                 DAPB18
NOFREE  IKJRLSA MYANS
         CLI   RC+1,16             IS RC 16?
         BZ    ERRTERM             YES, XCTL TO HELP
         CLI   RC+1,0              IS RC ZERO?
         BZ    STACKDX             YES, BRANCH
         MVC   MYSTPB(STACKDL),STACKD
        STACK  DELETE=ALL,PARM=MYSTPB,MF=(E,MYIOPL)
        TCLEARQ
STACKDX  LH    R15,RC
         SPACE 1
*----------------------------------------------------------*
*        EXIT TO CALLER                                    *
*----------------------------------------------------------*
         SPACE 1
EXIT    $XRET  CC=(R15),LV=@DATAL,SP=1,TYPE=RENT
         SPACE 1
*----------------------------------------------------------*
*        XCTL TO THE IBM HELP COMMAND                      *
*----------------------------------------------------------*
ERRTERM  L     R1,HELECT
         USING ECT,R1
         CLI   FILEKV,C'S'         COMMAND WITH SUBCOMMANDS
         BE    *+L'*+6             YES, BRANCH
         MVC   ECTPCMD,IBMHELP     NO, HELP REQUEST ONLY
         MVC   ECTSCMD,SCMD        RESTORE SECONDARY COMMAND
         DROP  R1
         LR    R1,R13
         L     R0,@SIZE
         L     R13,4(,R13)
         ICM   R13,B'1000',COMMND+1 GET OFFSET TO OPERANDS
        FREEMAIN R,A=(1),LV=(0)
         LM    0,12,20(R13)
         L     R14,12(,R13)
         L     R14,0(,R1)
         STCM  R13,B'1000',3(R14)  RESET OFFSET TO OPERANDS
         L     R14,12(,R13)
         BALR  R15,0
         USING *,R15
        XCTL   ,EPLOC=IBMHELP
         DROP  R15
         SPACE 1
*----------------------------------------------------------*
*        CALL IKJDAIR SERVICE ROUTINE                      *
*----------------------------------------------------------*
         SPACE 1
CALLDAIR ST    R14,DAIRREGS
         L     R15,CVTPTR
         USING CVT,R15
         TM    CVTDAIR,X'80'       CVTDAIR
         BNO   DAIRLNK
         L     R15,CVTDAIR
         DROP R15
         BALR  R14,R15
         B     DAIRFIN
DAIRLNK LINK   EP=IKJDAIR,SF=(E,LINKAREA)
DAIRFIN  L     R14,DAIRREGS
         BR    R14
         SPACE 1
*----------------------------------------------------------*
*        DYNAMIC ALLOCATION FAILURE ROUTINE                *
*----------------------------------------------------------*
         SPACE 1
DAIRFAIL ST    R14,MYDFREGS
         LA    R1,MYDFPARM
         USING DFDSECTD,R1
         ST    R15,MYDFRC
         LA    R15,MYDFRC
         ST    R15,DFRCP
         LA    R15,MYDAPL
         ST    R15,DFDAPLP
         XR    R15,R15
         ST    R15,MYJEFF02
         LA    R15,MYJEFF02
         ST    R15,DFJEFF02
         LA    R15,DFDAIR
         STH   R15,MYDFID
         LA    R15,MYDFID
         ST    R15,DFIDP
         MVC   DFCPPLP,CPPLPTR
         DROP  R1
        LINK   EP=IKJEFF18,SF=(E,LINKAREA)
         L     R15,MYDFRC
         L     R14,MYDFREGS
         BR    R14
         SPACE 1
*----------------------------------------------------------*
*        PHASE 1 INTERFACES TO PHASE 2                     *
*----------------------------------------------------------*
         SPACE 1
PUTMSG1  ST    R14,BASE1+12
         L     R15,=A(PUTMSG)
         LM    R10,R12,BASE2       SWITCH BASE REGS
         BALR  R14,R15
         LM    R10,R12,BASE1       RESTORE BASE REGS
         L     R14,BASE1+12
         BR    R14
         EJECT
*----------------------------------------------------------*
*        PHASE 1 CONSTANTS                                 *
*----------------------------------------------------------*
         SPACE 1
         CNOP  0,4
PFKDEF   DS    0CL16               INITIAL VALUES OF PF KEYS
         DC    X'F1',CL15'HELP '   1
         DC    X'F2',CL15' '       2
         DC    X'F3',CL15'END '    3
         DC    X'F4',CL15'END '    4
         DC    X'F5',CL15'FIND '   5
         DC    X'F6',CL15' '       6
         DC    X'F7',CL15'UP '     7
         DC    X'F8',CL15'DOWN '   8
         DC    X'F9',CL15'HEX '    9
         DC    X'7A',CL15'LEFT '   10
         DC    X'7B',CL15'RIGHT '  11
         DC    X'7C',CL15' '       12
PFKDEFN  EQU   (*-PFKDEF)/L'PFKDEF
         SPACE 1
OBTAIN  CAMLST SEARCH,2,3,4
OBTAINL  EQU   *-OBTAIN
         SPACE 1
STACKD  STACK  DELETE=ALL,MF=L
STACKDL  EQU   *-STACKD
         SPACE 1
@SIZE    DC    0F'0',AL1(1),AL3(@DATAL) SIZE OF WORK AREAS
IBMHELP  DC    CL8'&IBMHELP'
         SPACE 1
MSG01    DC    C'ERROR IN PARSE SERVICE ROUTINE'
MSG06    DC    C'DATA-SET ORGANIZATION MUST BE PARTITIONED'
MSG09    DC    C'UNABLE TO OBTAIN DSCB FOR DATA-SET'
MSG14    DC    C'FILENAME '
MSG14C   DC    C' NOT ALLOCATED TO A DASD DATA-SET '
         EJECT
*------- LITERAL POOL
         SPACE 1
        LTORG
         SPACE 1
*        DC    (((*-C-1)/N)*N+N+C-*)X'00'
*                        WHERE N IS BOUNDARY (I.E. 256, 4096, ...)
*                        AND C IS THE BEGINNING OF THE CSECT.
         DC    (((*-HEL-1)/256)*256+256+HEL-*)X'00'
         DC    0D'0'
         SPACE 1
         DROP  R2
         SPACE 1
         DROP  R10,R11,R12
*= = = = END OF CSECT ADDRESSABILITY = = = = = = = = = = = = = = = = =*
         EJECT
*----------------------------------------------------------*
*        PHASE 2 INITIALIZATION                            *
*----------------------------------------------------------*
*
*        FROM THIS POINT ON, PROCESSING IS THE SAME
*        FOR BOTH DSNAME AND DDNAME OPTIONS.
*
*        $DSNAME  - CONTAINS THE FULLY QUALIFIED DSNAME,
*                   FROM THE USER OR FROM THE JFCB.
*        $MEMBER  - CONTAINS THE MEMBER NAME, IF SPECIFIED,
*                   FROM THE USER OR FROM THE JFCB.
*        $DDNAME  - CONTAINS THE DDNAME, FROM IKJDAIR OR
*                   FROM THE USER.
         SPACE 1
HELXEQ   CSECT
         USING *,R10,R11,R12
         LR    R10,R15             RESET BASE REGISTER
         LA    R15,1
         LA    R11,4095(R15,R10)   BASE
         LA    R12,4095(R15,R11)   BASE
         ST    R14,RETSV
        GTSIZE
         CH    R0,=H'27'           3278-5 TERMINAL?
         BNE   GTSZEX              NO, BRANCH
         OI    MDFL,STSIZEX        SET A FLAG FOR LATER
        STSIZE SIZE=80,LINE=24    SET SIZE TO 24X80
         LA    R1,INWRT            INITIAL WRITE
         LA    R0,INWRTL           LENGTH
        TPUT   (1),(0),FULLSCR     WRITE FULL SCREEN
        GTSIZE ,                   AT LEAST 24 ROWS (LINES)
GTSZEX   SH    R0,=H'4'            LESS HEADER INFORMATION
         STH   R0,PAGESIZE         SAVE THE PAGE SIZE
         ST    R1,SCROLL           SET NEW RANGE
         STH   R1,PAGEWIDT         SAVE THE LINE WIDTH
         SPACE 1
*----------------------------------------------------------*
*        SET UP THE DCB                                    *
*----------------------------------------------------------*
         SPACE 1
        STFSMODE ON,INITIAL=YES    TURN ON FULLSCREEN MODE
         MVC   DYNDCBW(SEQDCBL),SEQDCB
         TM    DSORG,DCBDSGPO
         BZ    *+L'*+6
         MVC   DYNDCBW(PDSDCBL),PDSDCB
         LA    R4,DYNDCBW
         USING IHADCB,R4
         MVC   DCBDDNAM(8),$DDNAME
         LA    R15,DYNEOD
         IC    R0,DCBEODAD
         ST    R15,DCBEODAD
         STC   R0,DCBEODAD
         LA    R15,DYSYNAD
         IC    R0,DCBSYNAD
         ST    R15,DCBSYNAD
         STC   R0,DCBSYNAD
         LA    R15,DYNEXLST
         IC    R0,DCBEXLSA-1
         ST    R15,DCBEXLSA-1
         STC   R0,DCBEXLSA-1
         LA    R1,DYNDCBEX
         ST    R1,0(,R15)
         MVI   0(R15),X'05'
         LA    R1,DYNABEND
         ST    R1,4(,R15)
         MVI   4(R15),128+X'11'    OPEN ABEND EXIT (MVS)
         OI    STATUS,STOPEN       TELL CLEANUP TO CLOSE DCB
         MVI   OPEND,X'80'
        OPEN   ((R4),INPUT),MF=(E,OPEND)
         TM    DCBOFLGS,DCBOFOPN
         BO    OKOPEN
         LA    R1,MSG08
         LA    R0,L'MSG08
         TM    STATUS,STABEND      MEMBER NOT FOUND?
         BO    DYNOPENM            YES, BRANCH
         LA    R1,MSG04
         LA    R0,L'MSG04
DYNOPENM BAL   R14,PUTMSG
         B     EXIT12
         SPACE 1
*----------------------------------------------------------*
*        DCB EXITS ROUTINES                                *
*----------------------------------------------------------*
         CNOP  0,4
*------- DCB OPEN EXIT
*              NOTE - TESTING THE RECFM FOR RECFM V OR F
*                     REQUIRES AT LEAST 2 TESTS BECAUSE BOTH THE
*                     V AND F BITS ARE ON WHEN RECFM IS U.
*                     THIS ROUTINE MAKES A COPY OF THE RECFM BITS
*                     AND ZEROES BOTH THE V AND F BITS IN THE COPY
*                     IF THE RECFM IS U. NOW WE CAN DETERMINE
*                     RECFM V OR F IN ONE TEST INSTEAD OF TWO.
DYNDCBEX MVC   TSTRECFM,DCBRECFM   COPY RECFM
         TM    DCBRECFM,DCBRECU    RECFM U
         BNOR  R14                 NO, BRANCH
         NI    TSTRECFM,255-DCBRECU YES, SET BOTH BITS OFF
         BR    R14
         CNOP  0,4
*------- DCB ABEND EXIT
DYNABEND L     R8,0(,R1)           GET COMPLETION CODE
         N     R8,=A(X'FFF0FF00')
         CL    R8,=A(X'01301800')  IS IT AN 013-18 ABEND
         BE    *+L'*+6             YES, BRANCH
         MVI   4(R1),0             ABNORMALLY TERMINATE
         BR    R14
         OI    STATUS,STABEND      INDICATE MEMBER NOT FOUND
         MVI   3(R1),4             IGNORE THE ABEND
         BR    R14
         CNOP  0,4
*------- DCB SYNAD EXIT
*        THIS ROUTINE IS ENTERED DURING THE 'CHECK' MACRO
*        IF AN I/O ERROR OCCURS.
DYSYNAD SYNADAF ACSMETH=BSAM
         MVC   SYNADMSG(78),50(R1)
         MVI   SYNADSW,255
        SYNADRLS
         BR    R14
         CNOP  0,4
*------- DCB EODAD EXIT
DYNEOD   L     R1,=F'-1'           EOF
         ST    R1,0(,R5)           SAVE EOF IN CHKPT TABLE
         XR    R2,R2
         L     R14,READR
         BR    R14
         SPACE 1
*----------------------------------------------------------*
*        SET UP THE BUFFER AREA                            *
*----------------------------------------------------------*
         SPACE 1
OKOPEN   MVC   DYNDECBW(DYNDECBL),DYNDECB
         LH    R0,DCBBLKSI
         AH    R0,=H'7'            ROUND
         N     R0,=A(X'FFFFFFF8')  UPWARDS TO MULTIPLE OF 8
         ST    R0,SAVBLKSI         SAVE FOR PARTITIONING
         XR    R0,R0
         TM    TSTRECFM,DCBRECV+DCBRECSB VS OR VBS
         BNO   NOTSPAN             NO, BRANCH
         LH    R0,DCBLRECL         YES, GET LRECL
         AH    R0,=H'7'            ROUND
         N     R0,=A(X'FFFFFFF8')  UPWARDS TO MULTIPLE OF 8
         LTR   R0,R0               WAS LRECL ZERO
         BNZ   *+L'*+4             NO, SKIP NEXT INSTR
         L     R0,SAVBLKSI         YES, USE BLKSIZE ROUNDED
         A     R0,=A(2048)         ADD 2K IN CASE LRECL IS WRONG
NOTSPAN  ST    R0,SAVSPANL         SAVE FOR PARTITIONING
         LH    R0,DCBLRECL
         LTR   R0,R0
         BNZ   *+L'*+4
         LH    R0,DCBBLKSI
         STH   R0,RECSIZE
         AH    R0,=H'7'            ROUND
         N     R0,=A(X'FFFFFFF8')  UPWARDS TO MULTIPLE OF 8
         CH    R0,=H'1000'         IS LRECL GREATER THAN MAX
         BNH   *+L'*+4             NO, SKIP NEXT INSTR
         LH    R0,=H'1000'         YES, HELD RECORDS MUST BE TRUNCATED
         ST    R0,SAVLRECL         SAVE FOR HOLD AREA DIVISION
         MH    R0,PAGESIZE
         ST    R0,SAVHOLDL         SAVE FOR PARTITIONING
         A     R0,SAVSPANL         COMBINE LENGTHS FOR GETMAIN
         A     R0,SAVBLKSI         COMBINE LENGTHS FOR GETMAIN
         A     R0,=A(20*200)       PLUS ROOM FOR 200 CHECKPOINTS
         LA    R7,RANGE
         ST    R0,0(,R7)
         A     R0,=A(20*824)       OPTIONAL ROOM FOR 1024 CHECKPOINTS
         ST    R0,4(,R7)
         LA    R8,ANSWER
         MVC   GMVUW(GMVUL),GMVU
         GETMAIN VU,LA=(R7),A=(R8),MF=(E,GMVUW)
         OI    STATUS,STGMVU
         L     R1,ANSWER
         LR    R0,R1
         A     R0,ANSWER+4
         ST    R0,ENDPTR           END OF GETMAINED AREA
         ST    R1,BLOCKPTR
         A     R1,SAVBLKSI         POINT PAST BLOCK AREA
         ST    R1,SPANPTR
         A     R1,SAVSPANL         POINT PAST SPANNED RECORD AREA
         ST    R1,HOLDPTR
         A     R1,SAVHOLDL         POINT PAST HOLD AREA
         ST    R1,CHKPTTOP
         XC    0(16,R1),0(R1)      FIRST ENTRY IN TABLE
         XC    DEBLOCKS(12),DEBLOCKS
         XC    OFFSET,OFFSET
         LH    R0,PAGESIZE         LINES PER PAGE
         ST    R0,SCROLL
         XR    R0,R0
         ST    R0,FNDNUM
         STH   R0,FNDOFF
         ST    R0,CHKPTBOT
         MVC   PERIODS,ASIST
         SPACE 1
*----------------------------------------------------------*
*        INITIALIZE HOLD AREA DIRECTORY                    *
*----------------------------------------------------------*
         SPACE 1
         LA    R7,HOLDDIR
         XR    R0,R0
         L     R15,HOLDPTR
         TM    TSTRECFM,DCBRECV    RECFM V
         BZ    *+L'*+4             NO
         LA    R15,4(,R15)         YES, POINT 4 BYTES INTO EACH RECORD
         LH    R8,PAGESIZE         LINES PER PAGE
HOLDINIT ST    R0,DIRNUM(,R7)      PUT ZERO IN RECORD LENGTH
         ST    R0,DIRLEN(,R7)      PUT ZERO IN RECORD NUMBER
         ST    R15,DIRREC(,R7)     STORE ADDRESS OF HELD RECORD
         A     R15,SAVLRECL        POINT TO NEXT HELD RECORD
         LA    R1,DIRSIZ(,R7)      POINT TO NEXT ENTRY
         ST    R1,DIRNXT(,R7)      STORE ITS ADDRESS IN THIS ENTRY
         LR    R14,R7              SAVE LAST ENTRY
         LR    R7,R1               MAKE NEXT ENTRY THIS ENTRY
         BCT   R8,HOLDINIT         DO IT FOR ALL BUT LAST ENTRY
         LA    R1,HOLDDIR          ADDRESS OF FIRST ENTRY
         ST    R1,DIRNXT(,R14)     CLOSE THE CIRCLE
         ST    R1,HOLDTOP          START WITH FIRST AS TOP
         SPACE 1
*----------------------------------------------------------*
*        POINT TO MEMBER                                   *
*----------------------------------------------------------*
         SPACE 1
         MVC   BLDL(4),=AL2(1,76)
         MVC   BLDL+4(8),$MEMBER
        BLDL   (R4),BLDL
         LTR   R15,R15             WAS BLDL SUCCESSFUL
         BNZ   NOMEM               NO, BRANCH
         MVC   TTR,BLDL+12
         MVC   TTRK,BLDL+12
        FIND   (R4),TTRK,C
         B     NEWNAME
NOMEM    MVC   MSG(MSG36L),MSG36   MEMBER NOT FOUND
         CH    R15,=H'4'
         BE    *+L'*+6
         MVC   MSG(MSG37L),MSG37   BLDL FAILED
         OI    STATUS,STNOMEM
         SPACE 1
*----------------------------------------------------------*
*        BUILD TOP LINE                                    *
*----------------------------------------------------------*
         SPACE 1
NEWNAME  L     R1,SCREENH
         MVC   0(SCREENL,R1),SCREEN
         LA    R15,SCRRTA+3-SCREEN(R1)
         CLI   PAGESIZE+1,23       3278-5?
         BNE   *+L'*+6             NO, BRANCH
         MVC   0(2,R15),=X'C2CA'   YES, ADD ADDRESS FOR 27X132
         LA    R15,SCRMEM+2-SCREEN(R1)
         MVC   0(8,R15),$MEMBER
         LA    R15,SCRSUB+2-SCREEN(R1)
         MVC   0(8,R15),$SUBCOM
         BAL   R14,FILLHOLD
         B     FILLSCR
         SPACE 1
*----------------------------------------------------------*
*        READ ENOUGH RECORDS TO FILL HOLD AREA ROUTINE     *
*----------------------------------------------------------*
         SPACE 1
FILLHOLD ST    R14,HOLDR
         L     R6,HOLDPTR
         LR    R0,R6
         L     R1,SAVHOLDL
         XR    R14,R14
         L     R15,=A(X'40000000')
         MVCL  R0,R14              FILL HOLD AREA WITH BLANKS
         L     R7,HOLDTOP          POINT TO HOLD AREA DIRECTORY
         LH    R8,PAGESIZE         NUMBER OF DATA LINES PER SCREEN
HILLOOP  BAL   R14,GET
         LA    R0,1                COMPUTE
         A     R0,COUNT              THE
         ST    R0,COUNT                RECORD NUMBER
         ST    R0,DIRNUM(,R7)      STORE THE RECORD NUMBER
         ST    R1,DIRLEN(,R7)      LENGTH IN DIRECTORY
         LTR   R1,R1               END OF FILE
         BM    HILLED              YES BRANCH
         C     R1,SAVLRECL         IS RECORD LONGER THAN MAX
         BNH   *+L'*+4             NO, SKIP NEXT INSTR
         L     R1,SAVLRECL         YES, TRUNCATE TO MAX
         LR    R0,R2               ADDRESS TO MOVE FROM
         L     R14,DIRREC(,R7)     ADDRESS TO MOVE TO
         TM    TSTRECFM,DCBRECV    RECFM V
         BZ    HILLNOTV            NO
         SH    R14,=H'4'           YES, MOVE TO PTR MINUS 4
         L     R15,DIRLEN(,R7)
         SH    R15,=H'4'
         ST    R15,DIRLEN(,R7)
HILLNOTV LR    R15,R1              LENGTH FOR MOVE
         MVCL  R14,R0
         LR    R1,R7               SAVE PTR TO MOST CURRENT ENTRY
         L     R7,DIRNXT(,R7)      POINT TO NEXT DIRECTORY ENTRY
         BCT   R8,HILLOOP
         LR    R7,R1               GET MOST CURRENT ENTRY
HILLED   ST    R7,HOLDEND          SAVE LAST RECORD ENTRY
         L     R14,HOLDR
         BR    R14
         SPACE 1
*----------------------------------------------------------*
*        SET UP THE SCREEN HEADER PRIOR TO DISPLAY         *
*----------------------------------------------------------*
         SPACE 1
FILLSCR  L     R1,SCREENH
         LA    R15,SCRERR+2-SCREEN(,R1)
         MVC   0(31,R15),SCRERR+2  RESET THE HEADER DATA
         L     R1,SCREENH
         LA    R1,SCRRGE+2-SCREEN(,R1)
         L     R0,SCROLL           DEFAULT SCROLL
         CVD   R0,DOUBLE
         OI    DOUBLE+7,X'0F'
         UNPK  0(2,R1),DOUBLE+6(2)
         L     R1,SCREENH
         LA    R15,SCRCOL-SCREEN(,R1)
         MVC   0(8,R15),BLANKS
         LH    R1,OFFSET
         LA    R1,1(,R1)
         LA    R0,79(,R1)
         TM    MDFL,MODEX
         BZ    *+L'*+4
         SH    R0,=H'40'
         CH    R0,RECSIZE
         BNH   *+L'*+4
         LH    R0,RECSIZE
         CVD   R1,DOUBLE
         OI    DOUBLE+7,X'0F'
         CH    R1,=H'1000'
         BL    FILL3DIG
         UNPK  0(4,R15),DOUBLE+5(3)
         CVD   R0,DOUBLE
         OI    DOUBLE+7,X'0F'
         UNPK  5(3,R15),DOUBLE+6(2)
         B     FILLCOLX
FILL3DIG UNPK  0(3,R15),DOUBLE+6(2)
         CVD   R0,DOUBLE
         OI    DOUBLE+7,X'0F'
         UNPK  4(3,R15),DOUBLE+6(2)
         SPACE 1
*----------------------------------------------------------*
*        SET UP THE COLUMN HEADER PRIOR TO DISPLAY         *
*----------------------------------------------------------*
         SPACE 1
*              IT WOULD BE MORE EFFICIENT TO DO MOST OF THIS WORK
*              ONLY WHEN THE OFFSET IS INITIALIZED OR CHANGED
*              AND SAVE THE RESULTS.
FILLCOLX L     R1,SCREENH
         LA    R6,SCRDATA-SCREEN(,R1)
         MVC   0(52,R6),BLANKS     BLANK THE FOLLOWING AREA
         CLI   PAGESIZE+1,23       3278-5?
         BNE   *+L'*+4             NO, BRANCH
         LA    R6,52(,R6)          YES, ADD 52 BLANKS
         MVC   0(132,R6),BLANKS    ADD 132 BLANKS
         MVC   132(132,R6),BLANKS  ADD 132 BLANKS
         LH    R1,OFFSET
         LTR   R1,R1               IS OFFSET ZERO
         BNZ   FILLCOLS            NO
         TM    MDFL,MODEX          YES, SPECIAL CASE, 1
         BZ    *+L'*+8
         MVI   1(R6),C'1'
         B     FILLCOLS
         MVI   0(R6),C'1'
FILLCOLS XR    R0,R0
         LA    R14,10
         DR    R0,R14
         SR    R14,R0              10 MINUS REMAINDER
         LTR   R0,R0               WAS REMAINDER 0
         BZ    *+L'*+2             YES, USE 0, NOT 10
         LR    R0,R14
         LR    R14,R6
         TM    MDFL,MODEX
         BZ    *+L'*+2
         ALR   R14,R0
         ALR   R14,R0              ADD (0 TO 9) TO LINE
         BCTR  R14,0               START AT LINE-1 FOR OFFSET 0
*                                  LINE+8 FOR OFFSET 1
*                                  LINE+7 FOR OFFSET 2
*                                  LINE+6 FOR OFFSET 3
*                                  LINE+0 FOR OFFSET 9
         LH    R1,OFFSET
         AR    R1,R0               ADD (0 TO 9) TO OFFSET
         LA    R0,9
COLNUML  CH    R1,RECSIZE
         BH    COLNUMX
         CVD   R1,DOUBLE
         MVC   COLNUM,=X'402020202120'
         ED    COLNUM,DOUBLE+5
         CH    R1,=H'10000'        10000-32768
         BNL   COLNUMN             YES, USE NNNNN
         MVC   COLNUM(5),COLNUM+1
         MVI   COLNUM+5,C' '
         CH    R1,=H'100'          100-999
         BNL   COLNUMN             YES, USE XNNNX
         MVC   COLNUM(5),COLNUM+1  USE XNNXX
         MVI   COLNUM+5,C' '
COLNUMN  SH    R14,=H'2'
         CR    R14,R6
         BL    *+L'*+6
         MVC   0(5,R14),COLNUM+1
         LA    R14,12(,R14)
         TM    MDFL,MODEX
         BZ    *+L'*+8
         AH    R1,=H'5'
         B     *+L'*+4
         AH    R1,=H'10'
         BCT   R0,COLNUML
COLNUMX  AH    R6,PAGEWIDT
         LH    R1,OFFSET
         CH    R1,RECSIZE
         BL    MARKC
         MVI   0(R6),C' '
         MVC   1(79,R6),0(R6)
         B     MARKX
MARKC    XR    R0,R0
         LA    R14,10
         DR    R0,R14
         TM    MDFL,MODEX
         BZ    MARKD
         L     R14,=A(MARKHS)
         ALR   R14,R0
         ALR   R14,R0
         LH    R1,RECSIZE
         SH    R1,OFFSET
         SLL   R1,1
         B     MARKL
MARKD    L     R14,=A(MARKS)
         ALR   R14,R0
         LH    R1,RECSIZE
         SH    R1,OFFSET
MARKL    CH    R1,=H'80'
         BL    MARKE
         MVC   0(80,R6),0(R14)
         B     MARKX
MARKE    MVI   0(R6),C' '
         MVC   1(79,R6),0(R6)
         BCT   R1,*+L'*+6
         MVC   0(*-*,R6),0(R14)
         EX    R1,*-6
MARKX    AH    R6,PAGEWIDT
         SPACE 1
*----------------------------------------------------------*
*        FILL IN THE DATA AREA OF THE SCREEN               *
*----------------------------------------------------------*
         SPACE 1
         XR    R5,R5
         L     R7,HOLDTOP
         L     R1,SCREENH
         LA    R15,SCRLINE-SCREEN(,R1)
         L     R1,DIRNUM(,R7)      GET NUMBER OF FIRST LINE
         CVD   R1,DOUBLE
         OI    DOUBLE+7,X'0F'
         UNPK  0(5,R15),DOUBLE+5(3)
         L     R1,SCREENH
         LA    R1,SCRERR+2-SCREEN(,R1)
         MVC   SAVELINE(31),0(R1)  SAVE LINE AND COLUMN
         LH    R8,PAGESIZE         NUMBER OF DATA LINES
         CLI   HELPFLG,C'H'        HELP REQUESTED?
         BNE   FILBUG              NO, BRANCH
         L     R15,=V(HELMSGS)     START OF HELP MESSAGES MODULE
         L     R1,0(R15)           HELP MESSAGES ADDRESS
         L     R14,APFKTB
FILHEL1  MVC   0(132,R6),BLANKS    INITIALIZE WITH BLANKS
         CLI   0(R1),X'FF'         END OF MESSAGES?
         BE    FILHEL3             YES, BRANCH
         MVC   0(80,R6),0(R1)      MOVE IN THE NEXT MESSAGE
         CL    R1,12(R15)          ARE WE PROCESSING PFK'S?
         BL    FILHEL2             NO
         CLC   1(L'PFKTAB-1,R14),BLANKS YES, FILL IN PFK'S VALUES
         BE    *+L'*+10
         MVC   6(L'PFKTAB-1,R6),1(R14)
         B     *+L'*+6
         MVC   6(8,R6),4(R15)      INSERT (NONE)
         LA    R14,L'PFKTAB(R14)
         CLC   1(L'PFKTAB-1,R14),BLANKS YES, FILL IN PFK'S VALUES
         BE    *+L'*+10
         MVC   46(L'PFKTAB-1,R6),1(R14)
         B     *+L'*+6
         MVC   46(8,R6),4(R15)      INSERT (NONE)
         LA    R14,L'PFKTAB(R14)
FILHEL2  LA    R1,80(,R1)          NEXT HELP TEXT
FILHEL3  AH    R6,PAGEWIDT         ADD LINE WIDTH
         LA    R5,1(,R5)           COUNT LINES FILLED IN
         BCT   R8,FILHEL1          DO ALL HELP MESSAGES
         B     FILLED
FILBUG   CLI   HELPFLG,C'D'        DEBUG REQUESTED?
         BNE   FILLOOP             NO, BRANCH
*------- DEBUG - TGET REGISTERS 15-1
         MVC   0(132,R6),BLANKS    INITIALIZE WITH BLANKS
         LA    R5,1(,R5)           COUNT LINES FILLED IN
         MVC   0(9,R6),=C'TGET R15:'
         LA    R1,TGETREG2         POINT TO R15, R0, R1
         LA    R0,4                FIRST 4 BYTES (R15)
         LA    R15,9(,R6)
         BAL   R14,HEX
         MVC   1(3,R15),=C'R0:'
         LA    R15,4(,R15)
         LA    R0,4                SECOND 4 BYTES (R0)
         BAL   R14,HEX
         MVC   1(3,R15),=C'R1:'
         LA    R15,4(,R15)
         LA    R0,4                THIRD 4 BYTES (R1)
         BAL   R14,HEX
         CLC   TGETREG2+8(4),=F'128'
         BNH   *+L'*+6
         MVC   1(10,R15),=C'/ TOO LONG'
*------- DEBUG - REPLY AREA (CHARACTERS)
         AH    R6,PAGEWIDT         ADD LINE WIDTH
         MVC   0(132,R6),BLANKS    INITIALIZE WITH BLANKS
         LA    R5,1(,R5)           COUNT LINES FILLED IN
         LA    R1,REPLY+128        REPLY AREA
         L     R14,TGETREG2+8      REPLY LENGTH RETURNED BY TGET
         CL    R14,=F'128'
         BNH   *+L'*+4
         L     R14,=F'128'
         LA    R15,0(,R6)
         S     R14,=F'1'
         BM    FILLED
         MVC   0(5,R15),=C'R-C.:'  CHARACTER HEADER
         CL    R14,=F'63'
         BNH   FILBUG1
         MVC   5(64,R15),0(R1)     MOVE IN THE CHARACTER VERSION
         TR    5(64,R15),ASIST     TRANSLATE UNPRINTABLES
         MVC   70(6,R15),=C'<<<-C-'
         AH    R6,PAGEWIDT         ADD LINE WIDTH
         MVC   0(132,R6),BLANKS    INITIALIZE WITH BLANKS
         LA    R5,1(,R5)           COUNT LINES FILLED IN
         LA    R1,64(R1)           FURTHER IN REPLY AREA
         S     R14,=F'63'
         LA    R15,0(,R6)
FILBUG1  EX    R14,FILBUGM         MOVE IN THE CHARACTER VERSION
         EX    R14,FILBUGT         TRANSLATE UNPRINTABLES
         LA    R15,7(R15,R14)
         MVC   0(6,R15),=C'<<<-E-'
*------- DEBUG - REPLY AREA (HEXADECIMAL)
         AH    R6,PAGEWIDT         ADD LINE WIDTH
         MVC   0(132,R6),BLANKS    INITIALIZE WITH BLANKS
         MVC   0(5,R6),=C'R-H.:'   HEXADECIMAL HEADER
         LA    R5,1(,R5)           COUNT LINES FILLED IN
         LA    R1,REPLY+128        REPLY AREA
         L     R2,TGETREG2+8       REPLY LENGTH RETURNED BY TGET
         CL    R2,=F'128'
         BNH   FILBUG2
         L     R2,=F'128'
FILBUG2  L     R0,=F'32'
         LA    R15,5(,R6)
         CLR   R2,R0
         BH    *+L'*+2
         LR    R0,R2
         BAL   R14,HEX             CONVERT REPLY TO HEX
         AH    R6,PAGEWIDT         ADD LINE WIDTH
         S     R2,=F'32'
         BNP   FILLED
         MVC   0(132,R6),BLANKS    INITIALIZE WITH BLANKS
         LA    R5,1(,R5)           COUNT LINES FILLED IN
         B     FILBUG2
FILBUGM  MVC   5(*-*,R15),0(R1)    <<EXECUTED>>
FILBUGT  TR    5(*-*,R15),ASIST    <<EXECUTED>>
FILLOOP  MVI   HELPFLG,0           REFRESH OF SCREEN NO LONGER REQUIRED
         LM    R1,R2,DIRLEN(R7)    GET LENGTH AND ADDRESS
         LTR   R1,R1
         BM    FILBOT
         MVC   0(132,R6),BLANKS    FILL LINE WITH BLANKS
         BZ    FILNUL              BRANCH IF R1 ZERO
         SH    R1,OFFSET           IS OFFSET BEYOND END OF RECORD
         BNP   FILLNEXT            YES, LEAVE LINE BLANK
         AH    R2,OFFSET
         TM    MDFL,MODEX
         BO    FILLHEX
         LA    R0,80
         CR    R1,R0
         BNH   *+L'*+2
         LR    R1,R0
         CR    R1,R0
         BNE   FILLN80
         CH    R1,RECSIZE          IF LRECL=80, USE ONLY 72
         BNE   FILLN80
         LA    R1,72
FILLN80  BCT   R1,*+L'*+6
         MVC   0(*-*,R6),0(R2)
         EX    R1,*-6
         TR    0(80,R6),PERIODS
         B     FILLNEXT
FILLHEX  CH    R1,=H'40'
         BNH   *+L'*+4
         LA    R1,40
         LR    R0,R1
         LR    R1,R2
         LR    R15,R6
         BAL   R14,HEX
         B     FILLNEXT
FILNUL   MVC   0(6,R6),=C'(NULL)'
         B     FILLNEXT
FILLNEXT LA    R5,1(,R5)           COUNT LINES FILLED IN
         AH    R6,PAGEWIDT         ADD LINE WIDTH
         L     R7,DIRNXT(,R7)
         BCT   R8,FILLOOP
         B     FILLED
FILBOT   MVI   0(R6),C'*'
         MVC   1(79,R6),0(R6)
         MVC   32(16,R6),=C' BOTTOM OF DATA '
         AH    R6,PAGEWIDT         ADD LINE WIDTH
         LA    R5,1(,R5)           COUNT LINES FILLED IN
FILLED   CH    R5,PAGESIZE         IS SCREEN FILLED UP
         BNL   NOPAD
         MVC   0(4,R6),SCRPAD      FILL REMAINING LINES WITH BLANKS
         LA    R6,4(,R6)
NOPAD    MVC   0(4,R6),SCRSUF      SET CURSOR ADDRESS
         CLI   PAGESIZE+1,23       3278-5?
         BNE   *+L'*+6             NO, BRANCH
         MVC   1(2,R6),=X'C2D4'    YES, ADD ADDRESS FOR 02X17
         LA    R6,4(,R6)
         ST    R6,SCREENF          STORE END-OF-SCREEN FOR TPUT
PROMPT   NI    MDFL,255-HELPFX
         CLI   HELPFLG,C'H'        HELP?
         BE    PROMPT1             YES, BRANCH
         CLI   HELPFLG,C'R'        REFRESH REQUIRED?
         BNL   FILLSCR             YES, BRANCH
         CLI   HELPFLG,C'D'        DEBUG?
         BNE   PROMPT2             NO, BRANCH
         MVI   HELPFLG,C'S'        REFRESH REQUIRED (NEXT TIME)
         B     PROMPT2
PROMPT1  MVI   HELPFLG,C'R'        REFRESH REQUIRED (NEXT TIME)
         OI    MDFL,HELPFX
PROMPT2  L     R1,SCREENH
         LA    R15,SCRMEM+2-SCREEN(R1)
         MVC   0(8,R15),$MEMBER    MOVE IN MEMBER NAME
         L     R1,SCREENH
         LA    R15,SCRSUB+2-SCREEN(R1)
         MVC   0(8,R15),$SUBCOM    MOVE IN SUBCOMMAND NAME
         L     R1,SCREENH
         LA    R15,SCRERR+2-SCREEN(,R1)
         MVC   0(31,R15),SAVELINE  RESET LINE AND COLUMN
         LH    R1,MSG              GET LENGTH OF MESSAGE
         LTR   R1,R1               IS THERE A MESSAGE
         BZ    PROMPT3             NO, BRANCH
         CH    R1,=H'28'           MSG TOO LONG?
         BNH   *+L'*+4             NO, BRANCH
         LA    R1,28               YES, TRUNCATE IT
         MVI   0(R15),C'-'
         MVC   1(30,R15),0(R15)
         BCT   R1,*+L'*+6          LENGTH-1 FOR EX
         MVC   2(*-*,R15),MSG+2
         EX    R1,*-6              PROPAGATE THE DASHES
         LA    R15,3(R1,R15)
         MVI   0(R15),C' '
         XC    MSG(2),MSG          SET OFF MESSAGE FLAG
PROMPT3  TM    MEMBFLG,MEMBFLGM+MEMBFLGS NEW COMMAND OR SUBCOMMAND?
         MVI   MEMBFLG,0
         BNZ   PARSED              YES, CONTINUE WITH PARSE
         L     R1,SCREENH
         L     R0,SCREENF
         SR    R0,R1               COMPUTE SIZE OF SCREEN
         CLI   SKV,X'FF'           INITIALIZATION PROCESSING COMPLETED?
         BE    PROMPT5             NO, BRANCH
         MVI   SKV,X'FF'
         TM    STATUS,STNOMEM      MEMBER FOUND?
         BO    PROMPT5             NO, BRANCH
         LA    R14,13
         LA    R15,REPLY           START OF REPLY AREA
         MVC   0(13,R15),=X'7DC16111C160C6F1405D4040F1'
         CLI   OKV+1,1             OPERAND CODED?
         BNE   *+L'*+4             NO, BRANCH
         MVI   REPLY+10,C'O'       YES, SUBSTITUTE THE SEARCH CHARACTER
         CLI   SKV+1,1             OPERAND CODED?
         BNE   *+L'*+4             NO, BRANCH
         MVI   REPLY+10,C'X'       YES, SUBSTITUTE THE SEARCH CHARACTER
         CLI   FKV+1,1             OPERAND CODED?
         BNE   *+L'*+4             NO, BRANCH
         MVI   REPLY+10,C'F'       YES, SUBSTITUTE THE SEARCH CHARACTER
         CLI   AKV+1,1             OPERAND CODED?
         BNE   *+L'*+4             NO, BRANCH
         MVI   REPLY+10,C'F'       YES, SUBSTITUTE THE SEARCH CHARACTER
         CLI   REPLY+10,C'O'       "O" OPERAND ONLY?
         BNE   PROMPT4             NO, BRANCH
         CLI   $OPERAND,C' '       ANY OPERANDS?
         BE    SKIPTGET            NO, BRANCH
         MVI   REPLY+10,C')'       YES, SUBSTITUTE THE SEARCH CHARACTER
PROMPT4  CLI   REPLY+10,C' '       ANY SEARCH CHARACTER?
         BH    SKIPTGET            YES, BRANCH
         CLI   $SUBLINE,C'Y'       ANY SUBCOMMAND?
         BNE   SKIPTGET            YES, BRANCH
         CLI   FILEKV,C'S'         COMMAND WITH SUBCOMMANDS?
         BNE   SKIPTGET            NO, BRANCH
         MVI   REPLY+10,C'S'       LIST THE SUBCOMMANDS
         B     SKIPTGET
PROMPT5 TPUT   (1),(0),FULLSCR
         SPACE 1
*----------------------------------------------------------*
*        READ REPLY FROM THE TERMINAL                      *
*----------------------------------------------------------*
         SPACE 1
         MVC   REPLY+128(128),REPLY FOR DEBUG
         MVC   TGETREG2(12),TGETREGS FOR DEBUG
         XC    REPLY(128),REPLY    TO SIMPLIFY DEBUGGING
         LA    R1,REPLY
         LA    R0,128
        TGET   (1),(0),ASIS        GET REPLY
         STM   R15,R1,TGETREGS
         CH    R15,=H'12'          WAS REPLY AREA LONG ENOUGH
         BNE   TGETOK              YES, BRANCH
        TCLEARQ INPUT
TGETOK   LA    R15,REPLY
*        REPLY AREA CONTENTS :
*              OFFSET 0 LENGTH 1  -  ID OF KEY
*              OFFSET 1 LENGTH 2  -  ADDRESS OF CURSOR
*              OFFSET 3 LENGTH 1  -  X'11' IF ANY FIELDS MODIFIED
*              OFFSET 4 LENGTH 2  -  SCREEN ADDRESS OF FIELD
*              OFFSET 6 LENGTH V  -  DATA FROM FIELD
*              DATA EXTENDS TO END OF BUFFER OR NEXT X'11'
         OI    REPLY,X'30'         MAKE PFK 13-24 LOOK LIKE 1-12
         L     R14,TGETREGS+8      GET LENGTH OF REPLY
         CH    R14,=H'3'           ANYTHING BEYOND CURSOR ADDRESS
         BNH   CMDNULL             NO, BRANCH
         CLI   3(R15),X'11'        SBA (SHOULD ALWAYS BE PRESENT)
         BNE   CMDNULL             NO
         SPACE 1
*----------------------------------------------------------*
*        PROCESS FIELDS IN TGET BUFFER                     *
*----------------------------------------------------------*
         SPACE 1
SKIPTGET MVI   MEMBFLG,0           CLEAR THE MEMBER FLAGS
         XR    R0,R0
         ST    R0,CMDPTR           START WITH COMMAND-NOT-PRESENT
         BCT   R14,TRTSBA+L'TRTSBA LENGTH-1 FOR EX
TRTSBA   TRT   0(*-*,R15),FINDSBA
         EX    R14,TRTSBA
         BZ    CMDNULL             NO FIELDS PRESENT
         LR    R0,R1               ADDRESS OF SBA
         SR    R0,R15              LENGTH OF PRECEDING DATA
         SR    R14,R0              LENGTH CODE OF REMAINING DATA
         BZ    PARSED              BRANCH IF NOTHING FOLLOWS SBA
LOOP     ST    R1,FLDPTR
         LA    R15,1(,R1)          POINT PAST SBA
         BCTR  R14,0               REDUCE LENGTH ACCORDINGLY
         EX    R14,TRTSBA          LOOK FOR SECOND SBA
         BZ    LAST                BRANCH IF NONE PRESENT
         LR    R0,R1               POINT TO NEXT SBA
         SR    R0,R15              GET LENGTH OF THIS DATA
         ST    R0,FLDLEN
         STM   R14,R1,SBASAVE
         BAL   R2,FIELD
         LM    R14,R1,SBASAVE
         SR    R14,R0              LENGTH CODE OF REMAINING DATA
         BNZ   LOOP                SOMETHING FOLLOWS SECOND SBA
         B     PARSED              NOTHING FOLLOWS SECOND SBA
LAST     LA    R0,1(,R14)          GET LENGTH OF THIS DATA
         ST    R0,FLDLEN
         BAL   R2,FIELD
         B     PARSED
         SPACE 1
*----------------------------------------------------------*
*        ANALYZE A TGET FIELD ROUTINE                      *
*----------------------------------------------------------*
         SPACE 1
FIELD    L     R15,FLDPTR          POINT TO SBA FOR FIELD
         L     R1,FLDLEN           GET LENGTH CODE
         SH    R1,=H'3'            GET LENGTH CODE OF DATA
         BMR   R2                  NO DATA PRESENT
         CLC   1(2,R15),FLD1AA     NEW MEMBER?
         BE    FLDA
         CLC   1(2,R15),FLD2AA     NEW SUBCOMMAND?
         BE    FLDB
         CLC   1(2,R15),FLD1BA     IS IT COMMAND?
         BE    FLD1
         CLC   1(2,R15),FLD1BB     IS IT COMMAND ON 3278-5?
         BE    FLD1
         CLC   1(2,R15),FLD2BA     IS IT RANGE?
         BE    FLD2
         CLC   1(2,R15),FLD2BB     IS IT RANGE ON 3278-5?
         BE    FLD2
         BR    R2                  USER MUST HAVE USED CLEAR KEY
FLDA     LA    R15,3(,R15)         POINT TO MEMBER NAME
FLDABL   MVC   DOUBLE(8),BLANKS
         EX    R1,FLDOC            MOVE AND UPPER-CASE
         CLC   DOUBLE(8),BLANKS    ALL BLANKS?
         BER   R2                  YES, BRANCH
         LA    R15,1(,R15)         NEXT CHARACTER
         SH    R1,=H'1'            ANY CHARACTERS?
         BMR   R2                  NO, BRANCH
         CLI   DOUBLE,C' '         BLANK FIRST CHARACTER?
         BE    FLDABL              YES, BRANCH
         MVC   BLDL+4(8),DOUBLE    NEW COMMAND NAME
         OI    MEMBFLG,MEMBFLGM    NEW MEMBER NAME
         BR    R2                  RETURN
FLDOC    OC    DOUBLE(*-*),0(R15)  <<EXECUTED>>
FLDB     LA    R15,3(,R15)         POINT TO SUBCOMMAND
FLDBBL   MVC   DOUBLE(8),BLANKS
         EX    R1,FLDOC            MOVE AND UPPER-CASE
         CLC   DOUBLE(8),BLANKS    ALL BLANKS?
         BER   R2                  YES, BRANCH
         LA    R15,1(,R15)         NEXT CHARACTER
         SH    R1,=H'1'            ANY CHARACTERS?
         BMR   R2                  NO, BRANCH
         CLI   DOUBLE,C' '         BLANK FIRST CHARACTER?
         BE    FLDBBL              YES, BRANCH
         MVC   $SUBCOM(8),DOUBLE   NEW SUBCOMMAND NAME
         OI    MEMBFLG,MEMBFLGS    NEW SUBCOMMAND
         MVI   $SUBLINE,C'N'       NOT YET SATISFIED
         BR    R2                  RETURN
FLD1     LA    R15,3(,R15)         POINT TO COMMAND
         ST    R15,CMDPTR          SAVE FOR LATER
         ST    R1,CMDLEN           SAVE LENGTH CODE FOR LATER
         BR    R2                  RETURN
FLD2     LA    R15,3(,R15)         POINT TO RANGE
         CH    R1,=H'1'            IS IT 2 BYTES
         BNE   FLD2A               NO, BRANCH
         CLC   0(2,R15),BLANKS     BLANK
         BER   R2                  YES, IGNORE
         CLI   0(R1),C' '          LEADING BLANK
         BNE   *+L'*+4             NO, BRANCH
         MVI   0(R1),C'0'          CHANGE TO LEADING ZERO
         CLI   1(R15),C' '         TRAILING BLANK
         BNE   FLD2A               NO, BRANCH
         BCTR  R1,0                YES, REDUCE LENGTH BY 1
FLD2A    LR    R14,R2              SAVE R2
         EX    R1,TRTNUM           IS DATA NUMERIC
         LR    R2,R14              RESTORE R2
         BNZR  R2                  NOT NUMERIC, BRANCH
         EX    R1,FLD2PACK         PACK IT
         CVB   R1,DOUBLE           CONVERT TO BINARY
         LTR   R1,R1               IS IT ZERO
         BZ    0(,R2)              YES, IGNORE
         CH    R1,PAGESIZE         IT IT GREATER THAN SCREEN SIZE
         BHR   R2                  YES, IGNORE
         ST    R1,SCROLL           SET NEW RANGE
         LR    R0,R1
         L     R1,SCREENH
         LA    R1,SCRRGE+2-SCREEN(,R1)
         CVD   R0,DOUBLE
         OI    DOUBLE+7,X'0F'
         UNPK  0(2,R1),DOUBLE+6(2)
         BR    R2
TRTNUM   TRT   0(*-*,R15),NUMERIC  <<EXECUTED>>
FLD2PACK PACK  DOUBLE(8),0(*-*,R15) <<EXECUTED>>
         SPACE 1
*----------------------------------------------------------*
*        PREPARE THE COMMAND FOR PARSE                     *
*----------------------------------------------------------*
         SPACE 1
PARSED   TM    MEMBFLG,MEMBFLGM    NEW MEMBER?
         BO    MEMBER1             YES, BRANCH
         TM    MEMBFLG,MEMBFLGS    NEW SUBCOMMAND?
         BO    SUBCOMO             YES, BRANCH
         L     R15,CMDPTR          POINT TO COMMAND
         LTR   R15,R15             IS THERE A COMMAND
         BZ    CMDNULL             NO, BRANCH TO CHECK PFK
         L     R14,CMDLEN          GET LENGTH CODE
         LA    R1,CMDAREA
         MVI   0(R1),C' '
         MVC   1(62,R1),0(R1)
         EX    R14,CMDMOVE
         LA    R0,30
CMDJUST  CLI   0(R1),C' '          IS COMMAND LEFT JUSTIFIED
         BNE   CMDJUSTX            YES, BRANCH
         MVC   0(62,R1),1(R1)      SHIFT IT LEFT
         MVI   62(R1),C' '         APPEND BLANK
         BCT   R0,CMDJUST          REPEAT
CMDJUSTX OC    0(63,R1),BLANKS     UPPER CASE
         B     CMDSCAN
CMDMOVE  MVC   0(*-*,R1),0(R15)    <<EXECUTED>>
CMDNULL  CLI   REPLY,X'7D'         ENTER
         BE    PROMPT              YES, NO ACTION
         SPACE 1
*----------------------------------------------------------*
*        INTERPRET PROGRAM FUNCTION KEY                    *
*----------------------------------------------------------*
         SPACE 1
*              NOTE - IF A COMMAND IS TYPED IN THEN
*                     IT OVERRIDES THE PF KEY.
         L     R1,APFKTB
PFKSRCH  CLI   0(R1),0             END OF PFK TABLE
         BE    NOTPFK              YES, NOT IN TABLE
         CLC   0(1,R1),REPLY       DOES PFK CODE MATCH
         BE    PFKMOVE             YES, BRANCH
         LA    R1,L'PFKTAB(,R1)    NO, POINT TO NEXT ENTRY IN TABLE
         B     PFKSRCH             KEEP SEARCHING THE TABLE
PFKMOVE  CLI   1(R1),C' '          IS PFK DEFINITION EMPTY
         BE    NOTPFK              YES, BRANCH
         MVC   CMDAREA(63),BLANKS  BLANK THE AREA
         MVC   CMDAREA(L'PFKTAB-1),1(R1) MOVE IN THE TEXT
         LA    R1,CMDAREA          POINT TO ASSOCIATED COMMAND
         SPACE 1
*----------------------------------------------------------*
*        PARSE THE COMMAND AND OPERANDS                    *
*----------------------------------------------------------*
         SPACE 1
CMDSCAN  LR    R15,R1              POINT TO COLUMN 1
         LA    R3,39               LENGTH CODE OF STATEMENT
         LA    R6,OPDL             POINT TO OPERAND DESCRIPTOR LIST
         XC    0(OPDLL,R6),0(R6)   ZERO THE OPDL
         XR    R1,R1               INSURE HI ORDER BYTE ZERO
         LA    R0,OPDLL/8-1        NUMBER OF ENTRIES IN O.D.L.
*                                  MINUS 1 (LAST ODE WILL REMAIN ZERO)
PARLOOP  XC    0(8,R6),0(R6)       ZERO THE OPERAND DESCRIPTOR ENTRY
         EX    R3,TRTNONBL         FIND A NONBLANK
         BZ    PARDONE             BRANCH IF ALL BLANKS
         LR    R14,R1              GET ADDRESS OF STRING
         SR    R14,R15             GET LENGTH OF PRECEDING BLANKS
         SR    R3,R14              GET LENGTH OF REMAINING TEXT
         LR    R15,R1              GET ADDRESS OF NONBLANK
         CLI   0(R15),C''''        DOES OPERAND BEGIN WITH A QUOTE
         BE    PARQUOTE            YES, BRANCH
         EX    R3,TRTBLANK         FIND A BLANK
         BZ    PARLAST             BRANCH IF NOT FOUND
         LR    R14,R1              GET ADDRESS OF BLANK
         SR    R14,R15             GET LENGTH OF FIELD
         OI    6(R6),PRESENT       OPERAND PRESENT
         ST    R15,0(,R6)          ADDRESS OF OPERAND
         STH   R14,4(,R6)          LENGTH OF OPERAND
         SR    R3,R14              GET LENGTH CODE OF REMAINING TEXT
         BZ    PARDONE             BRANCH IF ONE TRAILING BLANK
         LR    R15,R1              POINT TO BLANK
PARNEXT  LA    R6,8(,R6)           POINT TO NEXT O.D.E.
         BCT   R0,PARLOOP          GO PROCESS NEXT OPERAND
         B     PARDONE             MAX OPERANDS PROCESSED
TRTNONBL TRT   0(*-*,R15),TABNONBL <<EXECUTED>>
TRTBLANK TRT   0(*-*,R15),TABBLANK <<EXECUTED>>
TRTQUOTE TRT   0(*-*,R15),TABQUOTE <<EXECUTED>>
PARQUOTE LA    R15,1(,R15)         POINT PAST QUOTE
         LA    R1,1                VALUE 1
         SR    R3,R1               REDUCE LENGTH CODE BY 1
         BM    PARDONE             IGNORE QUOTE IN LAST COLUMN
         EX    R3,TRTQUOTE         FIND THE NEXT QUOTE
         BZ    PARLASTQ            NOT FOUND, USE ALL REM TEXT
         LR    R14,R1              GET ADDRESS OF QUOTE
         SR    R14,R15             GET LENGTH OF FIELD
         OI    6(R6),PRESENT+QUOTED OPERAND PRESENT AND IN QUOTES
         ST    R15,0(,R6)          ADDRESS OF OPERAND
         STH   R14,4(,R6)          LENGTH OF OPERAND
         SR    R3,R14              GET LENGTH CODE OF REM TEXT
         BZ    PARDONE             BRANCH IF QUOTE WAS FINAL CHAR
         LA    R15,1(,R1)          POINT TO CHAR AFTER ENDING QUOTE
         BCTR  R3,0                REDUCE LENGTH CODE BY 1
         B     PARNEXT             SET UP FOR NEXT OPERAND
PARLASTQ OI    6(R6),QUOTED        OPERAND IN QUOTES
PARLAST  LA    R14,1(,R3)          GET LENGTH
         OI    6(R6),PRESENT       OPERAND PRESENT
         ST    R15,0(,R6)          ADDRESS OF OPERAND
         STH   R14,4(,R6)          LENGTH OF OPERAND
PARDONE  L     R1,OPD0             POINT TO COMMAND
         CLC   0(2,R1),=C'M '      MAX + PFK UP-DOWN-LEFT RIGHT
         BE    PFALSO
         CLI   0(R1),C'0'          NN + PFK UP-DOWN-LEFT-RIGHT
         BNL   PFALSO
         CLC   0(5,R1),=C'XCTL '
         BE    XCTL
         CLC   0(5,R1),=C'LEFT '
         BE    LEFT
         CLC   0(2,R1),=C'< '
         BE    LEFT
         CLC   0(6,R1),=C'RIGHT '
         BE    RIGHT
         CLC   0(2,R1),=C'> '
         BE    RIGHT
         CLC   0(3,R1),=C'UP '
         BE    UP
         CLC   0(2,R1),=C'- '
         BE    UP
         CLC   0(5,R1),=C'DOWN '
         BE    DOWN
         CLC   0(2,R1),=C'+ '
         BE    DOWN
         CLC   0(4,R1),=C'TOP '
         BE    TOP
         CLC   0(7,R1),=C'BOTTOM '
         BE    BOTTOM
         CLC   0(4,R1),=C'BOT '
         BE    BOTTOM
         CLC   0(5,R1),=CL8'HELP    '
         BE    HELP
         CLC   0(4,R1),=C'HEL '
         BE    HELP
         CLC   0(2,R1),=C'H '
         BE    HELP
         CLC   0(5,R1),=C'LIST '
         BE    LIST
         CLC   0(2,R1),=C'L '
         BE    LIST
         CLC   0(5,R1),=C'FIND '
         BE    FIND
         CLC   0(2,R1),=C'F '
         BE    FIND
         CLC   0(3,R1),=C'F1 '
         BE    FND1
         CLC   0(7,R1),=C'MEMBER '
         BE    MEMBERP
         CLC   0(4,R1),=C'MEM '
         BE    MEMBERP
         CLC   0(8,R1),=C'COMMAND '
         BE    MEMBERP
         CLC   0(4,R1),=C'COM '
         BE    MEMBERP
         CLC   0(7,R1),=C'SUBCOM '
         BE    SUBCOMP
         CLC   0(4,R1),=C'SUB '
         BE    SUBCOMP
         CLC   0(4,R1),=C'END '
         BE    END0
         CLC   0(5,R1),=C'ASIS '
         BE    ASIS
         CLC   0(5,R1),=C'CAPS '
         BE    CAPS
         CLC   0(4,R1),=C'HEX '
         BE    HEXMODE
         CLC   0(3,R1),=C'PFK'
         BE    PFKSET
         CLC   0(6,R1),=C'DEBUG '
         BE    DEBUG
         L     R8,=A(HELEXT)
         CLC   0(4,R1),=C'TSO '
         BER   R8
         CLC   0(5,R1),=C'SNAP '
         BE    4(R8)
         MVC   MSG(MSG20L),MSG20
         B     PROMPT
NOTPFK   CLI   REPLY,X'7E'         RESHOW?
         BE    FILLSCR             YES, BRANCH
         MVC   MSG(MSG21L),MSG21
         CLI   DEBUGSW,C'D'
         BE    DEBUG
         B     PROMPT
         SPACE 1
*----------------------------------------------------------*
*        INTERPRET AMOUNT AND POSSIBLE PF KEY              *
*----------------------------------------------------------*
         SPACE 1
PFALSO   CLI   REPLY,X'7D'         ENTER ONLY?
         BE    PFABAD              YES, ERROR
         L     R15,APFKTB
PFASRCH  CLI   0(R15),0            END OF PFK TABLE
         BE    PFABAD              YES, NOT IN TABLE
         CLC   0(1,R15),REPLY      DOES PFK CODE MATCH
         BE    PFAMOVE             YES, BRANCH
         LA    R15,L'PFKTAB(,R15)  NO, POINT TO NEXT ENTRY IN TABLE
         B     PFASRCH             KEEP SEARCHING THE TABLE
PFAMOVE  CLI   1(R15),C' '         IS PFK DEFINITION EMPTY
         BE    PFABAD              YES, BRANCH
         LA    R15,1(,R15)         POINT TO ASSOCIATED COMMAND
         CLI   0(R1),C'M'          MAXIMUM?
         BNE   PFAMOUNT            NO, BRANCH
         CLC   0(3,R15),=C'UP '
         BE    TOP
         CLC   0(5,R15),=C'DOWN '
         BE    BOTTOM
         CLC   0(5,R15),=C'LEFT '
         BE    LEFTALL
         CLC   0(6,R15),=C'RIGHT '
         BE    RIGHTALL
         B     PFABAD
PFAMOUNT MVC   OPD1(8),OPD0        MOVE THE OPERANDS UP ONE
         LR    R1,R15              POINT TO THE PFK TEXT
         ST    R1,OPD0             POINT TO THE SUBCOMMAND
         CLC   0(3,R1),=C'UP '
         BE    PARDONE
         CLC   0(5,R1),=C'DOWN '
         BE    PARDONE
         CLC   0(5,R1),=C'LEFT '
         BE    PARDONE
         CLC   0(6,R1),=C'RIGHT '
         BE    PARDONE
PFABAD   MVC   MSG(MSG20L),MSG20
         B     PROMPT
         SPACE 1
*----------------------------------------------------------*
*        XCTL                                              *
*----------------------------------------------------------*
         SPACE 1
XCTL     LA    R15,16
         STH   R15,RC              SET RETURN CODE TO 16
         B     END1
         SPACE 1
*----------------------------------------------------------*
*        RIGHT                                             *
*----------------------------------------------------------*
         SPACE 1
RIGHT    LA    R15,OPD1            GET FIRST OPERAND ENTRY
         TM    6(R15),PRESENT      ARE THERE ANY OPERANDS
         BZ    RIGHTDEF            NO, USE DEFAULT
         TM    6(R15),QUOTED       IS OPERAND QUOTED
         BO    ERRINV              YES, INVALID
         LH    R1,4(,R15)          GET LENGTH
         LTR   R1,R1               IS IT NULL STRING
         BZ    ERRINV              YES, ERROR
         CH    R1,=H'7'            IS LENGTH MORE THAN 7
         BH    ERRINV              YES, ERROR
         L     R14,0(,R15)         GET ADDRESS OF DATA
         BCT   R1,*+L'*+6
         TRT   0(*-*,R14),NUMERIC
         EX    R1,*-6              IS IT NUMERIC
         BNZ   ERRINV              NO, ERROR
         B     *+L'*+6
         PACK  DOUBLE(8),0(*-*,R14)
         EX    R1,*-6
         CVB   R1,DOUBLE
         LTR   R15,R1
         BZ    PROMPT
         B     RIGHTR15
RIGHTALL MVI   OFFSET,X'7F'
         MVI   OFFSET+1,X'AF'      AFTER ADDING 80, VALUE IS X'7FFF'
RIGHTDEF LA    R15,40
         TM    MDFL,MODEX
         BZ    RIGHTR15
         LA    R15,20
RIGHTR15 LH    R0,OFFSET
         AR    R0,R15
         LH    R1,RECSIZE
         CH    R1,=H'1000'
         BNH   *+L'*+4
         LH    R1,=H'1000'         LIMIT OFFSET TO 1000 CHARACTERS
         CR    R0,R1               IF NEW OFFSET > RECSIZE, USE RECSIZE
         BNH   *+L'*+2
         LR    R0,R1
         STH   R0,OFFSET
         B     FILLSCR
         SPACE 1
*----------------------------------------------------------*
*        LEFT                                              *
*----------------------------------------------------------*
         SPACE 1
LEFT     LA    R15,OPD1            GET FIRST OPERAND ENTRY
         TM    6(R15),PRESENT      ARE THERE ANY OPERANDS
         BZ    LEFTDEF             NO, USE DEFAULT
         TM    6(R15),QUOTED       IS OPERAND QUOTED
         BO    ERRINV              YES, INVALID
         LH    R1,4(,R15)          GET LENGTH
         LTR   R1,R1               IS IT NULL STRING
         BZ    ERRINV              YES, ERROR
         CH    R1,=H'7'            IS LENGTH MORE THAN 7
         BH    ERRINV              YES, ERROR
         L     R14,0(,R15)         GET ADDRESS OF DATA
         BCT   R1,*+L'*+6
         TRT   0(*-*,R14),NUMERIC
         EX    R1,*-6              IS IT NUMERIC
         BNZ   ERRINV              NO, ERROR
         B     *+L'*+6
         PACK  DOUBLE(8),0(*-*,R14)
         EX    R1,*-6
         CVB   R1,DOUBLE
         LTR   R15,R1
         BZ    PROMPT
         B     LEFTR15
LEFTDEF  LA    R15,40
         TM    MDFL,MODEX
         BZ    LEFTR15
         LA    R15,20
LEFTR15  LH    R0,OFFSET
         SR    R0,R15              REDUCE OFFSET BY 80
         BNM   LEFTALL+L'LEFTALL   IF RESULT IS NEGATIVE
LEFTALL  XR    R0,R0                 THEN MAKE IT ZERO
         STH   R0,OFFSET
         B     FILLSCR
         SPACE 1
*----------------------------------------------------------*
*        DOWN                                              *
*----------------------------------------------------------*
         SPACE 1
DOWN     L     R0,SCROLL
         LA    R15,OPD1            GET FIRST OPERAND ENTRY
         TM    6(R15),PRESENT      ARE THERE ANY OPERANDS
         BZ    DOWNRGE             NO, USE RANGE
         TM    6(R15),QUOTED       IS OPERAND QUOTED
         BO    ERRINV              YES, INVALID
         LH    R1,4(,R15)          GET LENGTH
         LTR   R1,R1               IS IT NULL STRING
         BZ    ERRINV              YES, ERROR
         CH    R1,=H'7'            IS LENGTH MORE THAN 7
         BH    ERRINV              YES, ERROR
         L     R14,0(,R15)         GET ADDRESS OF DATA
         BCT   R1,*+L'*+6
         TRT   0(*-*,R14),NUMERIC
         EX    R1,*-6              IS IT NUMERIC
         BNZ   ERRINV              NO, ERROR
         B     *+L'*+6
         PACK  DOUBLE(8),0(*-*,R14)
         EX    R1,*-6
         CVB   R1,DOUBLE
         LTR   R0,R1
         BZ    PROMPT
DOWNRGE  ST    R0,DOWNAMT
         BAL   R14,DOWNER
         LTR   R15,R15             ACTION TAKEN
         BNZ   PROMPT              NO, BRANCH
         B     FILLSCR             YES, BRANCH
         SPACE 1
*----------------------------------------------------------*
*        EXECUTE DOWN ROUTINE                              *
*----------------------------------------------------------*
         SPACE 1
*                                  SEE IF EOF IS ON SCREEN AND
DOWNER   LA    R15,4                 WOULD BE FORCED OFF
         L     R7,HOLDEND          POINT TO ENTRY FOR LAST RECORD
         TM    DIRLEN(R7),X'80'    IS EOF ON SCREEN
         BZ    DOWNNEOF            NO, DOWN IS POSSIBLE
         L     R7,HOLDTOP
         L     R0,DOWNAMT          GET DOWN AMOUNT
         CH    R0,PAGESIZE         OR SCREEN SIZE IF SMALLER
         BNH   DOWNTEST
         LH    R0,PAGESIZE
DOWNTEST TM    DIRLEN(R7),X'80'    IS THIS END OF DATA
         BOR   R14                 YES, CANT GO DOWN
         L     R7,DIRNXT(,R7)      GET ENTRY FOR NEXT RECORD
         BCT   R0,DOWNTEST
         L     R7,HOLDEND          POINT TO ENTRY FOR LAST RECORD
DOWNNEOF ST    R14,DOWNR
         L     R8,DOWNAMT          GET NUMBER OF LINES TO GO DOWN
DOWNLOOP L     R15,HOLDTOP         POINT TO TOP ENTRY
         L     R15,DIRNXT(,R15)    GET ADDRESS OF ENTRY AFTER TOP
         ST    R15,HOLDTOP         MAKE IT NEW TOP
         TM    DIRLEN(R7),X'80'    IS EOF ON SCREEN
         BO    DOWNNXT             YES, BYPASS GET
         L     R7,DIRNXT(,R7)      POINT TO NEXT ENTRY
         BAL   R14,GET
         LA    R0,1                COMPUTE
         A     R0,COUNT              THE
         ST    R0,COUNT                RECORD NUMBER
         ST    R0,DIRNUM(,R7)      STORE THE RECORD NUMBER
         ST    R1,DIRLEN(,R7)      STORE LENGTH
         LTR   R1,R1               END OF FILE
         BM    DOWNX               YES BRANCH
         C     R1,SAVLRECL         IS RECORD LONGER THAN MAX
         BNH   *+L'*+4             NO, SKIP NEXT INSTR
         L     R1,SAVLRECL         YES, TRUNCATE TO MAX
         LR    R0,R2               ADDRESS TO MOVE FROM
         L     R14,DIRREC(,R7)     ADDRESS TO MOVE TO
         TM    TSTRECFM,DCBRECV    RECFM V
         BZ    DOWNNOTV            NO
         SH    R14,=H'4'           YES, MOVE TO PTR MINUS 4
         L     R15,DIRLEN(,R7)
         SH    R15,=H'4'
         ST    R15,DIRLEN(,R7)
DOWNNOTV L     R15,SAVLRECL        LENGTH OF RECEIVING FIELD
         O     R1,=A(X'40000000')  PAD WITH BLANKS
         MVCL  R14,R0
DOWNNXT  BCT   R8,DOWNLOOP
DOWNX    ST    R7,HOLDEND          NEW END POINTER
         XR    R15,R15
         L     R14,DOWNR
         BR    R14
         SPACE 1
*----------------------------------------------------------*
*        UP                                                *
*----------------------------------------------------------*
         SPACE 1
UP       L     R0,SCROLL
         LA    R15,OPD1            GET FIRST OPERAND ENTRY
         TM    6(R15),PRESENT      ARE THERE ANY OPERANDS
         BZ    UPRANGE             NO, USE RANGE
         TM    6(R15),QUOTED       IS OPERAND QUOTED
         BO    ERRINV              YES, INVALID
         LH    R1,4(,R15)          GET LENGTH
         LTR   R1,R1               IS IT NULL STRING
         BZ    ERRINV              YES, ERROR
         CH    R1,=H'7'            IS LENGTH MORE THAN 7
         BH    ERRINV              YES, ERROR
         L     R14,0(,R15)         GET ADDRESS OF DATA
         BCT   R1,*+L'*+6
         TRT   0(*-*,R14),NUMERIC
         EX    R1,*-6              IS IT NUMERIC
         BNZ   ERRINV              NO, ERROR
         B     *+L'*+6
         PACK  DOUBLE(8),0(*-*,R14)
         EX    R1,*-6
         CVB   R1,DOUBLE
         LTR   R0,R1
         BZ    PROMPT
UPRANGE  ST    R0,DOWNAMT
         L     R7,HOLDTOP
         CLC   DIRNUM(4,R7),=F'1'  ARE WE AT TOP ALREADY
         BNH   PROMPT              YES, BRANCH
         TM    DIRLEN(R7),X'80'    IS FIRST LINE EOF
         BZ    UPTOP               NO, BRANCH
         NC    COUNT,COUNT         IS DATA-SET EMPTY
         BZ    PROMPT              YES, BRANCH
UPTOP    L     R0,DIRNUM(,R7)      GET RECORD NUMBER OF TOP LINE
         S     R0,DOWNAMT          GET RECORD NUMBER TO GO BACK TO
         BP    LISTAT
         LA    R0,1                IF NEGATIVE THEN MAKE IT 1
         B     LISTAT
         SPACE 1
*----------------------------------------------------------*
*        TOP                                               *
*----------------------------------------------------------*
         SPACE 1
TOP      L     R1,CHKPTTOP
         MVC   TTR,4(R1)           TTR OF FIRST BLOCK
         MVC   TTRZ(3),TTR         TTR OF FIRST BLOCK
        POINT  (R4),TTRZ
         XC    COUNT,COUNT
         XC    DEBLOCKS(12),DEBLOCKS
         L     R14,SPANPTR
         XR    R0,R0
         STH   R0,0(,R14)          RESET SPAN BUFFER LENGTH
         ST    R0,FNDNUM           RESET LAST-FOUND NUMBER
         STH   R0,FNDOFF           RESET LAST-FOUND OFFSET
         BAL   R14,FILLHOLD
         B     FILLSCR
         SPACE 1
*----------------------------------------------------------*
*        BOTTOM                                            *
*----------------------------------------------------------*
         SPACE 1
BOTTOM   L     R0,BOTNINES
         B     LISTAT
BOTRET   L     R0,SCROLL
         BCTR  R0,0
         B     UPRANGE
         SPACE 1
*----------------------------------------------------------*
*        HELP                                              *
*----------------------------------------------------------*
         SPACE 1
HELP     LA    R15,OPD1            FIRST PARAMETER
         TM    6(R15),PRESENT      ANY OPERANDS?
         BO    HELP1               YES, BRANCH
         CLI   HELPFLG,C'R'        PREVIOUS HELP SCREEN?
         BE    HELP1               YES, PERFORM HELP CALL
         MVI   HELPFLG,C'H'        NEED HELP SCREEN
         B     FILLSCR
HELP1    LA    R1,CMDAREA          START OF HELP PARAMETERS
         LA    R0,63               LENGTH OF PARSE STRING
         SLL   R0,16               SHIFT AS REQUIRED
         STCM  R0,B'1111',0(R1)    SAVE FOR PARSE
         TM    6(R15),QUOTED       QUOTED?
         BO    ERRINV              YES, INVALID
         LA    R15,OPD1            START OF FIRST ODL
         L     R14,0(,R15)         START OF PARAMETER
         LH    R15,4(,R15)         LENGTH OF PARAMETER
         L     R6,HELECT           ECT ADDRESS
         USING ECT,R6
         OI    ECTSWS,ECTNOPD      ASSUME NO OPERAND
         MVC   ECTSCMD,=CL8'HELP    ' SUBCOMMAND IS HELP
         LTR   R15,R15             NULL STRING?
         BZ    HELP3               YES, BRANCH
         CH    R15,=H'8'           IS LENGTH MORE THAN 8
         BH    ERRINV              YES, ERROR
         MVC   BLDL+4(8),BLANKS
         BCT   R15,*+L'*+6         MACHINE LENGTH
         MVC   BLDL+4(*-*),0(R14)  <<EXECUTED>>
         EX    R15,*-6             COMMAND NAME
         LA    R15,OPD1            START OF FIRST ODL
         L     R14,0(,R15)         START OF FIRST PARAMETER
         LA    R14,0(,R14)         DROP TOP BYTE
         SR    R14,R1              OFFSET TO SECOND PARAMETER
         SH    R14,=H'4'           LESS TEXT LENGTH FIELDS
         NI    ECTSWS,255-ECTNOPD  ASSUME OPERANDS
         TM    6(R15),PRESENT      ANY OPERANDS?
         BO    HELP2               YES, BRANCH
         LA    R14,63              NO, USE DEFAULT
         OI    ECTSWS,ECTNOPD      ASSUME NO OPERAND
HELP2    STH   R14,2(,R1)          OFFSET TO OPERANDS
HELP3    MVC   ECTPCMD,=CL8'HLHL    ' COMMAND NAME IS CHANGED
         DROP  R6
         ST    R1,HELCBUF          START OF COMMAND TEXT
         LA    R1,HELCBUF          CPPL START
        LINK   EP=HEL
         L     R1,HELECT           START OF ECT
         USING ECT,R1
         MVC   ECTPCMD(3),PCMD     HELP COMMAND NAME
         B     FILLSCR
         DROP  R1
         SPACE 1
*----------------------------------------------------------*
*        LIST                                              *
*----------------------------------------------------------*
         SPACE 1
LIST     LA    R15,OPD1            GET FIRST OPERAND ENTRY
         TM    6(R15),PRESENT      ARE THERE ANY OPERANDS
         BZ    ERRMISS             NO, MISSING OPERAND
         TM    6(R15),QUOTED       IS OPERAND QUOTED
         BO    ERRINV              YES, INVALID
         LH    R1,4(,R15)          GET LENGTH
         LTR   R1,R1               IS IT NULL STRING
         BZ    ERRINV              YES, ERROR
         CH    R1,=H'7'            IS LENGTH MORE THAN 7
         BH    ERRINV              YES, ERROR
         L     R14,0(,R15)         GET ADDRESS OF DATA
         BCT   R1,*+L'*+6
         TRT   0(*-*,R14),NUMERIC
         EX    R1,*-6              IS IT NUMERIC
         BNZ   ERRINV              NO, ERROR
         B     *+L'*+6
         PACK  DOUBLE(8),0(*-*,R14)
         EX    R1,*-6
         CVB   R1,DOUBLE
         LTR   R0,R1
         BZ    TOP
LISTAT   ST    R0,LISTNUM
         AH    R0,PAGESIZE         GET RECORD NUMBER TO READ UP TO
         BCTR  R0,0
         ST    R0,AIMFOR           SAVE FOR DOWNTO
         LA    R15,20              LENGTH OF CHKPT ENTRY
         L     R1,CHKPTBOT
         TM    0(R1),X'80'         IS IT EOF
         BZ    LISTNB
         C     R1,CHKPTTOP         IS DATA-SET EMPTY
         BE    PROMPT              YES
         SR    R1,R15              NO, BACK UP ONE ENTRY
LISTNB   L     R0,LISTNUM
LISTCK   C     R0,0(,R1)           DOES THIS BLOCK PRECEDE OUR RECORD
         BH    LISTPNT             YES, GO POINT TO IT
         SR    R1,R15              NO, BACK UP ONE BLOCK ENTRY
         B     LISTCK
LISTPNT  MVC   COUNT,0(R1)
         MVC   DEBLOCKS(12),8(R1)
         MVC   TTR,4(R1)           TTR OF FIRST BLOCK
         MVC   TTRZ(3),TTR
        POINT  (R4),TTRZ
         L     R14,SPANPTR
         XR    R0,R0
         STH   R0,0(,R14)          RESET SPAN BUFFER LENGTH
         CLC   MSG(8),MSG31        FOUND STRING MESSAGE?
         BE    LISTFIN             YES, BRANCH
         ST    R0,FNDNUM           RESET LAST-FOUND NUMBER
         STH   R0,FNDOFF           RESET LAST-FOUND OFFSET
LISTFIN  BAL   R14,FILLHOLD        READ NEXT 20 RECORDS
LISTFINE L     R7,HOLDTOP          GET ENTRY FOR TOP OF HOLD AREA
         TM    DIRLEN(R7),X'80'    IS EOF ON TOP OF SCREEN
         BO    LISTRDY             YES, WE ARE FINISHED
         CLC   LISTNUM,DIRNUM(R7)  IS REQUESTED NUMBER AT TOP
         BNH   FILLSCR             YES, BRANCH
         MVC   DOWNAMT,=F'1'       DOWN 1
         BAL   R14,DOWNER
         B     LISTFINE
LISTRDY  CLC   LISTNUM,BOTNINES    WAS THIS A LIST 99999999
         BE    BOTRET              YES, BRANCH
         B     FILLSCR
ERRMISS  MVC   MSG(MSG35L),MSG35
         B     PROMPT
         SPACE 1
*----------------------------------------------------------*
*        FND1 (POSITION TO SUBCOMMAND AND ANY OPERAND)     *
*----------------------------------------------------------*
         SPACE 1
FND1     L     R1,CHKPTTOP
         MVC   TTR,4(R1)           TTR OF FIRST BLOCK
         MVC   TTRZ(3),TTR         TTR OF FIRST BLOCK
        POINT  (R4),TTRZ
         XC    COUNT,COUNT
         XC    DEBLOCKS(12),DEBLOCKS
         L     R14,SPANPTR
         XR    R0,R0
         STH   R0,0(,R14)          RESET SPAN BUFFER LENGTH
         ST    R0,FNDNUM           RESET LAST-FOUND NUMBER
         STH   R0,FNDOFF           RESET LAST-FOUND OFFSET
         BAL   R14,FILLHOLD        ** PERFORMS A TOP OPERATION
         MVI   FINDSW,0
         LA    R15,OPD1            GET FIRST OPERAND ENTRY
         TM    6(R15),PRESENT      ARE THERE ANY OPERANDS
         BZ    FND1SAME            NO, USE PREVIOUS STRING
         XC    STRING,STRING       ERASE OLD STRING
         XR    R0,R0
         ST    R0,FNDNUM           RESET LAST-FOUND NUMBER
         STH   R0,FNDOFF           RESET LAST-FOUND OFFSET
         STH   R0,FINDCOL          RESET COLUMN
         LH    R1,4(,R15)          GET LENGTH
         LTR   R1,R1               IS IT NULL STRING
         BZ    FINDNULL            YES, ERROR
         L     R14,0(,R15)         GET ADDRESS OF DATA
         BCT   R1,*+L'*+6
         MVC   STRING(*-*),0(R14)
         EX    R1,*-6
         STH   R1,STRINGL          SAVE LENGTH CODE
         LA    R15,OPD2
         TM    6(R15),PRESENT      IS THERE A SECOND OPERAND
         BZ    FND1SAME            NO, LEAVE FINDCOL NULL
         TM    6(R15),QUOTED       IS OPERAND QUOTED
         BO    ERRINV              YES, INVALID
         LH    R1,4(,R15)          GET LENGTH
         LTR   R1,R1               IS IT NULL STRING
         BZ    ERRINV              YES, ERROR
         CH    R1,=H'3'            IS LENGTH MORE THAN 3
         BH    ERRINV              YES, ERROR
         L     R14,0(,R15)         GET ADDRESS OF DATA
         BCT   R1,*+L'*+6
         TRT   0(*-*,R14),NUMERIC
         EX    R1,*-6              IS IT NUMERIC
         BNZ   ERRINV              NO, ERROR
         B     *+L'*+6
         PACK  DOUBLE(8),0(*-*,R14)
         EX    R1,*-6
         CVB   R1,DOUBLE
         LTR   R1,R1               IS IT ZERO
         BZ    ERRINV              YES, ERROR
         C     R1,SAVLRECL         IS IT GREATER THAN LRECL
         BH    ERRINV              YES, ERROR
         STH   R1,FINDCOL
FND1SAME NC    STRING,STRING       HAS A STRING BEEN ENTERED
         BZ    FINDNULL            NO, ERROR
         LH    R6,FINDCOL
         L     R7,HOLDTOP          GET INFO FOR FIRST HELD RECORD
         L     R0,DIRNUM(,R7)      GET RECORD NUMBER OF FIRST HELD
         L     R1,FNDNUM           GET RECORD NUMBER WHERE LAST FOUND
         LTR   R1,R1               HAS IT BEEN FOUND
         BNP   FND1SCR             NO, START WITH HELD RECORDS
         CR    R0,R1               ARE WE PAST LAST FOUND REC
         BH    FND1SCR             YES, START WITH HELD RECORDS
         L     R14,HOLDEND
         L     R15,DIRNUM(,R14)    GET RECORD NUMBER OF LAST HELD
         CR    R1,R15              IS LAST FOUND REC ON SCREEN
         BH    FND1DOWN            NO, BRANCH
FND1PREV C     R1,DIRNUM(,R7)      IS THIS RECORD WHERE LAST FOUND
         BE    FND1PCOL            YES, BRANCH
         C     R7,HOLDEND          IS THIS LAST RECORD ON SCREEN
         BE    FND1DOWN            SHOULD NOT HAPPEN
         L     R7,DIRNXT(,R7)      POINT TO NEXT RECORD
         B     FND1PREV
FND1PCOL L     R15,DIRREC(,R7)     POINT TO RECORD
         LTR   R6,R6               WAS A COLUMN SPECIFIED
         BZ    FND1POFF            NO, LOOK AT SAME RECORD
         C     R7,HOLDEND          IS THIS LAST RECORD ON SCREEN
         BE    FND1DOWN            YES, BRANCH
         L     R7,DIRNXT(,R7)      NO, POINT TO NEXT RECORD
         B     FND1SCR             GO EXAMINE RECORD
FND1POFF AH    R15,FNDOFF          POINT TO LAST FOUND STRING
         LA    R15,1(,R15)         POINT PAST LAST FOUND STRING
         B     FND1STR
FND1CLC  CLC   0(*-*,R15),STRING   <<EXECUTED>>
FND1CLK  CLC   0(*-*,R15),$SUBCOM  <<EXECUTED>>
FND1SCR  TM    DIRLEN(R7),X'80'    ARE WE AT EOF?
         BO    FND1BOT             YES, BRANCH
         L     R15,DIRREC(,R7)     POINT TO FIRST BYTE TO EXAMINE
         CLI   $SUBLINE,C'Y'       ANY SUBCOMMAND NAME?
         BE    FND1COL1            NO, BRANCH
         CLI   0(R15),C'='         START OF A SUBCOMMAND?
         BNE   FND1NEXT            NO, BRANCH
         LH    R14,$SUBLEN         MACHINE LENGTH OF SUBCOMMAND NAME
FND1CHK  LA    R15,1(,R15)         NEXT CHARACTER
         EX    R14,FND1CLK         THIS SUBCOMMAND IDENTIFIER?
         BNE   FND1CHK1            NO, BRANCH
         LA    R1,1(R14,R15)       POINT TO END OF STRING
         CLI   0(R1),C'='          ANOTHER SUBCOMMAND NAME?
         BE    FND1COL             YES, BRANCH
         CLI   0(R1),C' '          END OF SUBCOMMAND NAMES?
         BE    FND1COL             YES, BRANCH
FND1CHK1 LA    R15,1(,R15)         NEXT CHARACTER?
         CLI   0(R15),C'='         SEPARATOR CHARACTER?
         BE    FND1CHK             YES, BRANCH
         CLI   0(R15),C' '         SEPARATOR CHARACTER?
         BE    FND1NEXT            YES, NOT ON THIS CARD IMAGE
         B     FND1CHK1            NO, BRANCH
FND1COL  L     R15,DIRNUM(,R7)     CURRENT SUBCOMMAND POSITION
         ST    R15,$SUBLINE        SUBCOMMAND IS SATISFIED
         MVI   $SUBLINE,C'Y'       POSITIONING FOR SUBCOMMAND COMPLETED
         B     FND1NEXT            NOT ON THIS CARD IMAGE
FND1COL1 L     R15,DIRREC(,R7)     POINT TO FIRST BYTE TO EXAMINE
         CLI   0(R15),C'='         SUBCOMMAND DIVIDER?
         BE    FND1BOT             YES, DATA NOT FOUND
         LTR   R6,R6               WAS A COLUMN SPECIFIED
         BZ    FND1STR             NO, BRANCH
         AR    R15,R6              YES, POINT TO COLUMN PLUS 1
         BCTR  R15,0               POINT TO COLUMN
         LH    R14,STRINGL
         EX    R14,FND1CLC         THIS RECORD IMAGE?
         BNE   FND1NEXT            NO, LOOP FOR NEXT RECORD
         CLI   1(R15),C')'         "O" OPERAND IDENTIFIER?
         BNE   FND1FND             NO, FOUND IT
         LA    R1,$OPERAND         FIRST OPERAND START
FND1O1   LA    R0,19
         LA    R14,20(,R1)
         CLI   0(R1),C' '          ANY OPERAND?
         BE    FND1NEXT            NO, NOT THIS OPERAND
FND1O2   BCTR  R14,0               SCAN
         CLI   0(R14),C' '           FOR
         BNE   *+L'*+4                 LAST
         BCT   R0,FND1O2                 NON-BLANK
         LR    R14,R0              LENGTH
         EX    R14,FND1CKL         THIS OPERAND?
         LA    R1,20(,R1)
         BNE   FND1O1              NO, BRANCH FOR NEXT OPERAND
         B     FND1FND
FND1CKL  CLC   2(*-*,R15),0(R1)    <<EXECUTED>>
FND1STR  L     R0,DIRLEN(,R7)      GET LENGTH OF RECORD
         C     R0,SAVLRECL         IS RECORD TRUNCATED
         BNH   *+L'*+4             NO, SKIP NEXT INSTR
         L     R0,SAVLRECL         YES, USE TRUNCATED LENGTH
         L     R1,DIRREC(,R7)      GET ADDRESS OF RECORD
         AR    R0,R1               POINT PAST LAST BYTE OF RECORD
         LH    R14,STRINGL         GET LENGTH CODE OF STRING
         AR    R15,R14             POINT TO LAST BYTE TO BE COMPARED
         SR    R0,R15              GET NUMBER OF COMPARISONS
         BNP   FND1NEXT            STRING TOO LONG FOR REMAINING TEXT
         SR    R15,R14             PUT STRING ADDRESS BACK
FND1COMP EX    R14,FND1CLC         COMPARE STRING TO DATA
         BE    FND1FND
         LA    R15,1(,R15)         INCREMENT DATA POINTER
         BCT   R0,FND1COMP         GO COMPARE AGAIN
FND1NEXT C     R7,HOLDEND          WAS THAT LAST HELD RECORD
         BE    FND1DOWN            YES, BRANCH
         L     R7,DIRNXT(,R7)      POINT TO NEXT RECORD
         B     FND1SCR             GO PROCESS NEXT RECORD
FND1BOT  MVI   MEMBFLG,0           DO NOT CONTINUE PARSE
         MVC   MSG(MSG32L),MSG32F
         CLI   STRING+1,C'X'
         BNE   *+L'*+6
         MVC   MSG(MSG32L),MSG32X
         CLI   STRING+1,C'S'
         BNE   *+L'*+6
         MVC   MSG(MSG32L),MSG32SS
         CLI   STRING+1,C'O'
         BNE   *+L'*+6
         MVC   MSG(MSG32L),MSG32O
         CLI   STRING+1,C')'
         BNE   *+L'*+6
         MVC   MSG(MSG32L),MSG32OO
         CLI   $SUBLINE,C'Y'
         BE    *+L'*+6
         MVC   MSG(MSG32L),MSG32S
FND1DONE L     R1,$SUBLINE
         LA    R0,1(,R1)
         B     LISTAT
FND1DOWN LA    R1,1
         ST    R1,DOWNAMT
         BAL   R14,DOWNER
         L     R7,HOLDEND
         OI    FINDSW,1
         B     FND1SCR
FND1FND  TM    FINDSW,1
         BZ    FILLSCR
         LH    R6,PAGESIZE
         SH    R6,=H'1'
FND1LN2  LA    R1,1
         ST    R1,DOWNAMT
         BAL   R14,DOWNER
         BCT   R6,FINDLN
         B     FILLSCR
         SPACE 1
*----------------------------------------------------------*
*        FIND                                              *
*----------------------------------------------------------*
         SPACE 1
FIND     MVI   FINDSW,0
         LA    R15,OPD1            GET FIRST OPERAND ENTRY
         TM    6(R15),PRESENT      ARE THERE ANY OPERANDS
         BZ    FINDSAME            NO, USE PREVIOUS STRING
         XC    STRING,STRING       ERASE OLD STRING
         XR    R0,R0
         ST    R0,FNDNUM           RESET LAST-FOUND NUMBER
         STH   R0,FNDOFF           RESET LAST-FOUND OFFSET
         STH   R0,FINDCOL          RESET COLUMN
         LH    R1,4(,R15)          GET LENGTH
         LTR   R1,R1               IS IT NULL STRING
         BZ    FINDNULL            YES, ERROR
         L     R14,0(,R15)         GET ADDRESS OF DATA
         BCT   R1,*+L'*+6
         MVC   STRING(*-*),0(R14)
         EX    R1,*-6
         STH   R1,STRINGL          SAVE LENGTH CODE
         LA    R15,OPD2
         TM    6(R15),PRESENT      IS THERE A SECOND OPERAND
         BZ    FINDSAME            NO, LEAVE FINDCOL NULL
         TM    6(R15),QUOTED       IS OPERAND QUOTED
         BO    ERRINV              YES, INVALID
         LH    R1,4(,R15)          GET LENGTH
         LTR   R1,R1               IS IT NULL STRING
         BZ    ERRINV              YES, ERROR
         CH    R1,=H'3'            IS LENGTH MORE THAN 3
         BH    ERRINV              YES, ERROR
         L     R14,0(,R15)         GET ADDRESS OF DATA
         BCT   R1,*+L'*+6
         TRT   0(*-*,R14),NUMERIC
         EX    R1,*-6              IS IT NUMERIC
         BNZ   ERRINV              NO, ERROR
         B     *+L'*+6
         PACK  DOUBLE(8),0(*-*,R14)
         EX    R1,*-6
         CVB   R1,DOUBLE
         LTR   R1,R1               IS IT ZERO
         BZ    ERRINV              YES, ERROR
         C     R1,SAVLRECL         IS IT GREATER THAN LRECL
         BH    ERRINV              YES, ERROR
         STH   R1,FINDCOL
FINDSAME NC    STRING,STRING       HAS A STRING BEEN ENTERED
         BZ    FINDNULL            NO, ERROR
         LH    R6,FINDCOL
         L     R7,HOLDTOP          GET INFO FOR FIRST HELD RECORD
         L     R0,DIRNUM(,R7)      GET RECORD NUMBER OF FIRST HELD
         L     R1,FNDNUM           GET RECORD NUMBER WHERE LAST FOUND
         LTR   R1,R1               HAS IT BEEN FOUND
         BNP   FINDSCR             NO, START WITH HELD RECORDS
         CR    R0,R1               ARE WE PAST LAST FOUND REC
         BH    FINDSCR             YES, START WITH HELD RECORDS
         L     R14,HOLDEND
         L     R15,DIRNUM(,R14)    GET RECORD NUMBER OF LAST HELD
         CR    R1,R15              IS LAST FOUND REC ON SCREEN
         BH    FINDDOWN            NO, BRANCH
FINDPREV C     R1,DIRNUM(,R7)      IS THIS RECORD WHERE LAST FOUND
         BE    FINDPCOL            YES, BRANCH
         C     R7,HOLDEND          IS THIS LAST RECORD ON SCREEN
         BE    FINDDOWN            SHOULD NOT HAPPEN
         L     R7,DIRNXT(,R7)      POINT TO NEXT RECORD
         B     FINDPREV
FINDPCOL L     R15,DIRREC(,R7)     POINT TO RECORD
         LTR   R6,R6               WAS A COLUMN SPECIFIED
         BZ    FINDPOFF            NO, LOOK AT SAME RECORD
         C     R7,HOLDEND          IS THIS LAST RECORD ON SCREEN
         BE    FINDDOWN            YES, BRANCH
         L     R7,DIRNXT(,R7)      NO, POINT TO NEXT RECORD
         B     FINDSCR             GO EXAMINE RECORD
FINDPOFF AH    R15,FNDOFF          POINT TO LAST FOUND STRING
         LA    R15,1(,R15)         POINT PAST LAST FOUND STRING
         B     FINDSTR
FINDCLC  CLC   0(0,R15),STRING     <<EXECUTED>>
FINDSCR  TM    DIRLEN(R7),X'80'    ARE WE AT EOF
         BO    FINDBOT             YES, BRANCH
         L     R15,DIRREC(,R7)     POINT TO FIRST BYTE TO EXAMINE
         LTR   R6,R6               WAS A COLUMN SPECIFIED
         BZ    FINDSTR             NO, BRANCH
         AR    R15,R6              YES, POINT TO COLUMN PLUS 1
         BCTR  R15,0               POINT TO COLUMN
         LH    R14,STRINGL
         EX    R14,FINDCLC
         BE    FOUND
         B     FINDNEXT
FINDSTR  L     R0,DIRLEN(,R7)      GET LENGTH OF RECORD
         C     R0,SAVLRECL         IS RECORD TRUNCATED
         BNH   *+L'*+4             NO, SKIP NEXT INSTR
         L     R0,SAVLRECL         YES, USE TRUNCATED LENGTH
         L     R1,DIRREC(,R7)      GET ADDRESS OF RECORD
         AR    R0,R1               POINT PAST LAST BYTE OF RECORD
         LH    R14,STRINGL         GET LENGTH CODE OF STRING
         AR    R15,R14             POINT TO LAST BYTE TO BE COMPARED
         SR    R0,R15              GET NUMBER OF COMPARISONS
         BNP   FINDNEXT            STRING TOO LONG FOR REMAINING TEXT
         SR    R15,R14             PUT STRING ADDRESS BACK
FINDCOMP EX    R14,FINDCLC         COMPARE STRING TO DATA
         BE    FOUND
         LA    R15,1(,R15)         INCREMENT DATA POINTER
         BCT   R0,FINDCOMP         GO COMPARE AGAIN
FINDNEXT C     R7,HOLDEND          WAS THAT LAST HELD RECORD
         BE    FINDDOWN            YES, BRANCH
         L     R7,DIRNXT(,R7)      POINT TO NEXT RECORD
         B     FINDSCR             GO PROCESS NEXT RECORD
FINDBOT  MVC   MSG(MSG32L),MSG32
         B     FILLSCR
FINDDOWN LA    R1,1
         ST    R1,DOWNAMT
         BAL   R14,DOWNER
         L     R7,HOLDEND
         OI    FINDSW,1
         B     FINDSCR
FINDNULL MVC   MSG(MSG33L),MSG33
         B     PROMPT
ERRINV   MVC   MSG(MSG34L),MSG34
         B     PROMPT
FOUND    MVC   MSG(MSG31L),MSG31
         MVC   FNDNUM,DIRNUM(R7)   SAVE RECORD NUMBER
         S     R15,DIRREC(,R7)     GET OFFSET TO FOUND LOCATION
         STH   R15,FNDOFF          SAVE OFFSET
         LA    R15,1(,R15)         MAKE IT COLUMN NUMBER
         CVD   R15,DOUBLE
         OI    DOUBLE+7,X'0F'
         LA    R15,MSG+26
         UNPK  0(3,R15),DOUBLE+6(2)
         L     R15,FNDNUM
         CVD   R15,DOUBLE
         OI    DOUBLE+7,X'0F'
         LA    R15,MSG+16
         UNPK  0(5,R15),DOUBLE+5(3)
         L     R1,DIRNUM(,R7)
         LA    R0,0(,R1)
         TM    FINDSW,1
         BZ    LISTAT
         LH    R6,PAGESIZE
         SH    R6,=H'2'
FINDLN   LA    R1,1
         ST    R1,DOWNAMT
         BAL   R14,DOWNER
         BCT   R6,FINDLN
         B     FILLSCR
         SPACE 1
*----------------------------------------------------------*
*        HEX                                               *
*----------------------------------------------------------*
         SPACE 1
HEXMODE  LA    R15,OPD1            GET FIRST OPERAND ENTRY
         TM    6(R15),PRESENT      ARE THERE ANY OPERANDS
         BZ    HEXFLIP             NO, FLIP FLOP
         L     R14,0(,R15)         POINT TO OPERAND
         CLI   5(R15),2            IS LENGTH 2
         BNE   HEXOFF              NO, TRY OFF
         CLC   0(2,R14),=C'ON'     YES, IS IT 'ON'
         BNE   ERRKW               NO, INVALID OPERAND
         OI    MDFL,MODEX
         B     FILLSCR
HEXOFF   CLI   5(R15),3            IS LENGTH 3
         BNE   ERRKW
         CLC   0(3,R14),=C'OFF'
         BNE   ERRKW
         NI    MDFL,255-MODEX
         B     FILLSCR
HEXFLIP  XI    MDFL,MODEX          FLIP FLOP THE SWITCH
         B     FILLSCR
ERRKW    MVC   MSG(MSG34L),MSG34
         B     PROMPT
         SPACE 1
*----------------------------------------------------------*
*        PFK SET                                           *
*----------------------------------------------------------*
         SPACE 1
PFKSET   LA    R15,3(,R1)          POINT TO NN AFTER PFK
         TRT   0(1,R15),NUMERIC    PFKN
         BNZ   PFKSET2             ERROR, N NOT NUMERIC
         PACK  DOUBLE,0(1,R15)
         CLI   1(R15),C' '         SINGLE DIGIT
         BE    PFKSET1             YES, BRANCH
         TRT   1(1,R15),NUMERIC
         BNZ   PFKSET2             SECOND DIGIT NOT NUMERIC
         CLI   2(R15),C' '
         BNE   PFKSET2             MORE THAN 2 DIGITS
         PACK  DOUBLE,0(2,R15)
PFKSET1  CVB   R1,DOUBLE           GET VALUE OF N OR NN
         CH    R1,=H'1'
         BL    PFKSET2             ERROR, LESS THAN 1
         CH    R1,=H'12'
         BH    PFKSET2             ERROR, GREATER THAN 12
         BCTR  R1,0                CHANGE 1-12 TO 0-11
         LA    R0,L'PFKTAB         LENGTH OF EACH PFK ENTRY
         MR    R0,R0               COMPUTE OFFSET INTO TABLE
         L     R15,APFKTB
         ALR   R15,R1              POINT TO TABLE ENTRY
         LA    R1,OPD1             GET FIRST OPERAND ENTRY
         TM    6(R1),PRESENT       ARE THERE ANY OPERANDS
         BZ    PFKSETF             NO, BLANK IT
         CLI   5(R1),0             IS IT NULL LENGTH
         BE    PFKSETF             YES, BLANK IT
         L     R1,0(,R1)           POINT TO OPERAND
         CLC   0(3,R1),=C'PFK'     IS OPERAND ANOTHER PFK COMMAND
         BE    PFKSET2             YES, ERROR
         LA    R0,CMDAREA+30       POINT TO END OF COMMAND AREA
         SR    R0,R1               GET LENGTH CODE OF COMMAND
         BM    PFKSET2
         LR    R14,R0
         MVI   1(R15),C' '
         MVC   2(L'PFKTAB-2,R15),1(R15)
         B     *+L'*+6
         MVC   1(*-*,R15),0(R1)    <<EXECUTED>>
         EX    R14,*-6             MOVE COMMAND INTO PFK TABLE
         CLI   DEBUGSW,C'D'
         BNE   NOPFDB
         LA    R14,1(,R14)         BUILD DEBUG OF PFK (MSG)     D
         CVD   R14,DOUBLE          DISPLAY LENGTH               E    P
         OI    DOUBLE+7,X'0F'                                   B    F
         UNPK  MSG+2(3),DOUBLE+6(2)                             U    K
         MVI   MSG+5,C' '                                       G
         MVC   MSG+6(10),1(R15)    DISPLAY 10 CHARS OF VALUE         S
         LA    R0,14                                                 E
         STH   R0,MSG                                                T
NOPFDB   CLI   DEBUGSW,C'D'
         BNE   PFKSETX
         B     PROMPT              DEBUG REQUESTED
PFKSETF  MVI   1(R15),C' '
         MVC   2(L'PFKTAB-2,R15),1(R15)
PFKSETX  MVC   MSG(MSG40L),MSG40   HAS BEEN RESET
         B     PROMPT
PFKSET2  MVC   MSG(MSG41L),MSG41   INVALID PFK COMMAND
         B     PROMPT
         SPACE 1
*----------------------------------------------------------*
*        CAPS / ASIS                                       *
*----------------------------------------------------------*
         SPACE 1
CAPS     MVC   PERIODS,CAPST
         B     FILLSCR
ASIS     MVC   PERIODS,ASIST
         B     FILLSCR
         SPACE 1
*----------------------------------------------------------*
*        MEMBER                                            *
*----------------------------------------------------------*
         SPACE 1
MEMBERP  TM    DSORG,DCBDSGPO      IS DSORG PO
         BZ    MEMPDS              NO, BRANCH
         LA    R15,OPD1            GET FIRST OPERAND ENTRY
         TM    6(R15),PRESENT      ARE THERE ANY OPERANDS
         BZ    TOP                 NO, GO TO THE TOP OF THE SCREEN
         TM    6(R15),QUOTED       IS OPERAND QUOTED
         BO    ERRINV              YES, INVALID
         LH    R1,4(,R15)          GET LENGTH
         LTR   R1,R1               IS IT NULL STRING
         BZ    ERRMISS             YES, ERROR
         CH    R1,=H'8'            IS LENGTH MORE THAN 8
         BH    ERRINV              YES, ERROR
         MVC   BLDL+4(8),BLANKS
         L     R14,0(,R15)         GET ADDRESS OF DATA
         BCT   R1,*+L'*+6
         MVC   BLDL+4(*-*),0(R14)
         EX    R1,*-6
MEMBER1  MVC   BLDL(4),=AL2(1,76)
        BLDL   (R4),BLDL
         LTR   R15,R15
         BNZ   MEMERR
         NI    STATUS,255-STNOMEM
         MVC   $MEMBER,BLDL+4
         L     R1,CHKPTTOP
         MVC   4(4,R1),BLDL+12     COPY TTR
         ST    R15,CHKPTBOT        ZERO CHKPT TABLE
         MVC   TTR,BLDL+12         TTR OF FIRST BLOCK
         MVC   TTRK,BLDL+12        TTR OF FIRST BLOCK
        FIND   (R4),TTRK,C
         TM    MEMBFLG,MEMBFLGS    SUBCOMMAND CHANGE TOO?
         BO    SUBCOMO             YES, BRANCH
         MVC   $SUBLINE,=F'0'
         MVI   $SUBLINE,C'Y'
         MVC   $SUBCOM(8),BLANKS
         XC    COUNT,COUNT
         XC    DEBLOCKS(12),DEBLOCKS
         L     R14,SPANPTR
         XR    R0,R0
         STH   R0,0(,R14)          RESET SPAN BUFFER LENGTH
         ST    R0,FNDNUM           RESET LAST-FOUND NUMBER
         STH   R0,FNDOFF           RESET LAST-FOUND OFFSET
         B     NEWNAME
MEMERR   MVI   MEMBFLG,0           DO NOT CONTINUE PARSE
         CH    R15,=H'4'
         BNE   MEMERR1
         MVC   MSG(MSG36L),MSG36   MEMBER NOT FOUND
         B     PROMPT
MEMERR1  MVC   MSG(MSG37L),MSG37   BLDL FAILED
         B     PROMPT
MEMPDS   MVC   MSG(MSG38L),MSG38   NOT PARTITIONED
         B     PROMPT
         SPACE 1
*----------------------------------------------------------*
*        SUBCOMMAND                                        *
*----------------------------------------------------------*
         SPACE 1
SUBCOMP  TM    DSORG,DCBDSGPO      IS DSORG PO
         BZ    MEMPDS              NO, BRANCH
         LA    R15,OPD1            GET FIRST OPERAND ENTRY
         TM    6(R15),PRESENT      ARE THERE ANY OPERANDS
         BZ    FND1DONE            NO, REPOSITION TO SUBCOMMAND
         TM    6(R15),QUOTED       IS OPERAND QUOTED
         BO    ERRINV              YES, INVALID
         LH    R1,4(,R15)          GET LENGTH
         LTR   R1,R1               IS IT NULL STRING
         BZ    ERRMISS             YES, ERROR
         CH    R1,=H'8'            IS LENGTH MORE THAN 8
         BH    ERRINV              YES, ERROR
         MVC   $SUBCOM(8),BLANKS
         L     R14,0(,R15)         GET ADDRESS OF DATA
         BCT   R1,*+L'*+6
         MVC   $SUBCOM(*-*),0(R14)
         EX    R1,*-6              MOVE IN THE SUBCOMMAND NAME
         MVI   $SUBLINE,C'N'       NOT YET SATISFIED
SUBCOMO  LA    R0,7
         LA    R15,$SUBCOM+8
SUBCOMO1 BCTR  R15,0               SCAN
         CLI   0(R15),C' '           FOR
         BNE   *+L'*+4                 LAST
         BCT   R0,SUBCOMO1               NON-BLANK
         STH   R0,$SUBLEN          MACHINE LENGTH OF SUBCOMMAND
         SPACE 1
         XC    COUNT,COUNT
         XC    DEBLOCKS(12),DEBLOCKS
         L     R14,SPANPTR
         XR    R0,R0
         STH   R0,0(,R14)          RESET SPAN BUFFER LENGTH
         ST    R0,FNDNUM           RESET LAST-FOUND NUMBER
         STH   R0,FNDOFF           RESET LAST-FOUND OFFSET
         LA    R15,OPD1            GET FIRST OPERAND ENTRY
         LA    R1,=C')'            ONLY A PARENTHESIS
         ST    R1,0(,R15)          FIRST OPERAND
         LA    R1,1                LENGTH OF OPERAND
         STH   R1,4(,R15)          LENGTH OF OPERAND
         MVI   6(R15),PRESENT      OPERANDS ARE PRESENT
         LA    R15,OPD2            GET SECOND OPERAND ENTRY
         LA    R1,=C'1'            IN THE FIRST DATA POSITION
         ST    R1,0(,R15)          FIRST OPERAND
         LA    R1,1                LENGTH OF OPERAND
         STH   R1,4(,R15)          LENGTH OF OPERAND
         MVI   6(R15),PRESENT      OPERANDS ARE PRESENT
         B     FND1                CONTINUE WITH FND1
         SPACE 1
*----------------------------------------------------------*
*        DEBUG (SHOW TGET RESULTS ON SCREEN)               *
*----------------------------------------------------------*
         SPACE 1
DEBUG    MVI   DEBUGSW,C'D'        START DEBUG DISPLAYS IF ANY ERROR
         MVI   HELPFLG,C'D'        REFRESH OF SCREEN NEEDED
         B     FILLSCR
         EJECT
*----------------------------------------------------------*
*        END OF PROGRAM                                    *
*----------------------------------------------------------*
         SPACE 1
END0     TM    MDFL,HELPFX
         BZ    END1
         NI    MDFL,255-HELPFX
         B     FILLSCR
END1     LA    R1,ERAZE
         LA    R0,ERAZEL
        TPUT   (1),(0),FULLSCR     ERASE THE SCREEN
         TM    MDFL,STSIZEX        TERMINAL SIZE RESET?
         BNO   END2                NO, BRANCH
        STSIZE SIZE=132,LINE=27    YES, CHANGE THE SIZE BACK
         LA    R1,INWRTA           WRITE ALTERNATE
         LA    R0,INWRTAL          LENGTH
        TPUT   (1),(0),FULLSCR     WRITE FULL SCREEN
         XI    MDFL,STSIZEX        RESET STSIZE BIT
END2    STLINENO LINE=1,MODE=OFF   TURN OFF FULL SCREEN MODE
        TCLEARQ INPUT              CLEAR INPUT QUEUE FOR SYNCRONIZATION
         XR    R15,R15
         CLC   PCMD(2),=CL8'HELP    ' HELP COMMAND NAME?
         BE    EXITRC              YES, BRANCH
         CLC   PCMD(2),=C'H '      H COMMAND NAME?
         BE    EXITRC              YES, BRANCH
         TM    MDFL,HELPX          HELPX ENTRY?
         BO    EXITRC              YES, BRANCH
        TPUT   BLANKS,2            OUTPUT ONE BLANK LINE
         XR    R15,R15
         B     EXITRC
IOERR    LA    R1,SYNADMSG
         LA    R0,78
         BAL   R14,PUTMSG
EXIT12   LA    R15,12
EXITRC   CH    R15,RC
         BNH   *+L'*+4
         STH   R15,RC              SET HIGHEST RC
         TM    MDFL,STSIZEX        TERMINAL SIZE RESET?
         BNO   EXITRCX             NO, BRANCH
        STSIZE SIZE=132,LINE=27    YES, CHANGE THE SIZE BACK
         LA    R1,INWRTA           WRITE ALTERNATE
         LA    R0,INWRTAL          LENGTH
        TPUT   (1),(0),FULLSCR     WRITE FULL SCREEN
EXITRCX  TM    STATUS,STGMVU
         BZ    NOGMVU
         L     R0,ANSWER+4         LENGTH
         L     R1,ANSWER           ADDRESS
        FREEMAIN R,LV=(0),A=(1)
         NI    STATUS,255-STGMVU
NOGMVU   TM    STATUS,STOPEN
         BZ    NOCLOSE
         TM    DCBOFLGS,DCBOFOPN   IS IT OPEN?
         BZ    NOCLOSE             NO, BRANCH
         MVI   CLOSED,X'80'
        CLOSE ((R4)),MF=(E,CLOSED)
         NI    STATUS,255-STOPEN   CLOSED
NOCLOSE  LM    R10,R12,BASE1
         L     R14,RETSV
         BR    R14                 RETURN TO PHASE 1
         EJECT
*----------------------------------------------------------*
*        SUBROUTINE TO CONVERT DATA TO HEX                 *
*----------------------------------------------------------*
         SPACE 1
HEX      MVC   1(1,R15),0(R1)      MOVE BYTE
         UNPK  0(3,R15),1(2,R15)   UNPACK
         TR    0(2,R15),HEXTAB-240
         LA    R15,2(,R15)         INCREMENT OUTPUT PTR
         LA    R1,1(,R1)           INCREMENT INPUT PTR
         BCT   R0,HEX              DECREMENT LENGTH, THEN LOOP
         MVI   0(R15),C' '         BLANK THE TRAILING BYTE
         BR    R14                 RETURN TO CALLER
         SPACE 1
*----------------------------------------------------------*
*        SUBROUTINE TO GET A LOGICAL RECORD                *
*----------------------------------------------------------*
*              INPUT
*                R4 DCB ADDRESS
*                CHKPTTOP  -  TOP OF CHECKPOINT TABLE
*                CHKPTBOT  -  BOTTOM OF CHECKPOINT TABLE, ZERO 1ST TIME
*                COUNT     -  LAST LOGICAL RECORD NUMBER READ
*                BLOCKPTR  -  ADDRESS OF BUFFER
*                DEBLOCKS  -  DEBLOCKING INFO (ZEROS FIRST TIME)
*                SPANPTR   -  ADDRESS OF AREA TO COMBINE
*                             SPANNED RECORD SEGMENTS
*              OUTPUT
*                R1 CONTAINS LENGTH OF RECORD (OR -1 IF END OF FILE)
*                R2 CONTAINS ADDRESS OF RECORD (OR 0 IF END OF FILE)
*
         SPACE 1
GET      ST    R14,READR
         TM    DCBRECFM,DCBRECBR   BLOCKED
         BZ    READI               NO, BRANCH
         LM    R0,R2,DEBLOCKS      GET DEBLOCKING STATUS
         AR    R2,R1               POINT TO NEXT RECORD
         CR    R2,R0               END OF BLOCK (OR FIRST TIME)
         BNL   READI               YES, BRANCH
         TM    TSTRECFM,DCBRECV    VARIABLE LENGTH
         BO    READVB              YES, BRANCH
         ST    R2,DEBLOCKS+8       FIXED BLOCKED
         B     READX
READI    L     R5,CHKPTBOT         GET LAST CHECKPOINT
         LTR   R5,R5               IS THIS FIRST READ
         BNZ   READNF              BRANCH IF NOT FIRST
         L     R5,CHKPTTOP
         B     READNEW             READING A RECORD NOT READ BEFORE
READNF   L     R1,0(,R5)           GET NUMBER OF HIGHEST RECORD READ
         LTR   R1,R1               WAS IT EOF
         BM    READOLD             YES, BRANCH
         C     R1,COUNT            HAVE WE READ THIS RECORD BEFORE
         BNH   READADD             NO, BRANCH
READOLD  LA    R5,CHKPTDUM         YES, DONT CHANGE CHKPT TABLE
         B     READ
READADD  LA    R5,20(,R5)          ADD AN ENTRY TO THE CHKPT TABLE
         C     R5,ENDPTR           IS TABLE FILLED UP
         BL    READNEW             NO, SKIP NEXT INSTR
*                                  YES, HALVE THE TABLE
         LA    R0,20               LENGTH OF EACH ENTRY
         L     R15,CHKPTTOP        POINT TO FIRST ENTRY
         AR    R15,R0              POINT TO SECOND ENTRY
         LR    R1,R15
         AR    R1,R0               POINT TO THIRD ENTRY
READHMOV MVC   0(20,R15),0(R1)     MOVE 3RD TO 2ND
*                                       5TH TO 3RD
*                                       7TH TO 4TH, ETC
         AR    R15,R0              RECEIVING FIELD DOWN 1
         AR    R1,R0               SENDING FIELD DOWN 1
         AR    R1,R0               SENDING FIELD DOWN 2
         CR    R1,R5               ARE WE PAST THE LAST ENTRY
         BL    READHMOV            NO, BRANCH
         LR    R5,R15              YES, NEW CURRENT POINTER
READNEW  ST    R5,CHKPTBOT         SAVE NEW CURRENT CHECKPOINT POINTER
         MVC   0(4,R5),COUNT
         XC    4(4,R5),4(R5)
         MVC   8(12,R5),DEBLOCKS
READ     TM    STATUS,STNOMEM      ARE WE IN MEMBER-NOT-FOUND STATUS
         BO    DYNEOD              YES, JUST GO TO END OF FILE
         L     R2,BLOCKPTR
        READ   DYNDECBW,SF,(R4),(R2),'S',MF=E
        CHECK  DYNDECBW
         CLI   SYNADSW,0           WAS SYNAD EXIT TAKEN?
         BNE   IOERR               YES, BRANCH
         LH    R1,DCBBLKSI
         L     R14,DYNDECBW+16
         SH    R1,14(,R14)         SUBTRACT RESIDUAL COUNT
         TM    TSTRECFM,DCBRECV    VARIABLE LENGTH RECORDS
         BZ    *+L'*+4             NO, BRANCH
         LH    R1,0(,R2)           YES, USE BLKSIZE IN BDW
         LA    R0,0(R1,R2)         END OF BLOCK
         STM   R0,R2,DEBLOCKS      SAVE STATUS INFO
         CLC   4(4,R5),=F'0'       IS THIS 2ND READ PER GET
         BNZ   NOTED               YES, BYPASS NOTE
        NOTE   (R4)
         ST    R1,4(,R5)           SAVE TTR IN TABLE
NOTED    L     R1,DEBLOCKS+4       RESTORE LENGTH
         TM    DCBRECFM,DCBRECBR   BLOCKED?
         BO    READB               YES, BRANCH
         TM    TSTRECFM,DCBRECV+DCBRECSB VARIABLE UNBLOCKED SPANNED
         BNO   READX               NO
         B     READVBS             YES, SAME AS BLOCKED
READB    TM    DCBRECFM,DCBRECU    UNDEFINED
         BO    READX
         TM    DCBRECFM,DCBRECV    VARIABLE LENGTH
         BO    READVBI
         LH    R1,DCBLRECL         FIXED BLOCKED
         ST    R1,DEBLOCKS+4       SAVE STATUS INFO
         B     READX
READVBI  LA    R2,4(,R2)           POINT PAST BDW                    $V
READVB   TM    DCBRECFM,DCBRECSB   SPANNED
         BO    READVBS
READVBR  LH    R1,0(,R2)
         STM   R1,R2,DEBLOCKS+4    SAVE STATUS INFO
         B     READX
READVBS  CLI   2(R2),0             SEGMENT
         BE    READVBR             NO, BRANCH
*              THIRD BYTE IS X'01' FOR FIRST SEGMENT
*                            X'03' FOR MIDDLE SEGMENT
*                            X'02' FOR LAST SEGMENT
         CLI   2(R2),1             FIRST SEGMENT
         BNE   READSEG2
         L     R14,SPANPTR         ADDRESS TO MOVE TO
         LH    R15,0(,R2)          LENGTH TO MOVE
         LR    R1,R15              LENGTH TO MOVE
         LR    R0,R2               ADDRESS TO MOVE FROM
         MVCL  R14,R0              MOVE SEGMENT RDW AND DATA
         B     READSEGD            GO DEBLOCK NEXT SEGMENT
READSEG2 L     R14,SPANPTR         ADDRESS OF PRIOR SEGMENTS
         LH    R0,0(,R14)          LENGTH OF PRIOR SEGMENTS
         LH    R15,0(,R2)          LENGTH+4 OF NEW SEGMENT
         SH    R15,=H'4'           LENGTH OF NEW SEGMENT
         LR    R1,R15              LENGTH TO BE MOVED
         AR    R15,R0              COMBINE LENGTHS
         STH   R15,0(,R14)         STORE COMBINED LENGTHS
         LR    R15,R1              LENGTH TO ME MOVED
         AR    R14,R0              ADDRESS TO MOVE TO
         LA    R0,4(,R2)           ADDRESS TO MOVE FROM
         MVCL  R14,R0              MOVE SEGMENT DATA
         CLI   2(R2),2             LAST SEGMENT
         BNE   READSEGD            NO, GO DEBLOCK NEXT SEGMENT
         LH    R1,0(,R2)           GET LENGTH OF THIS SEGMENT
         STM   R1,R2,DEBLOCKS+4    SAVE LENGTH AND ADDRESS
         L     R2,SPANPTR          POINT TO COMBINED RECORD
         LH    R1,0(,R2)           GET COMBINED LENGTH
READX    L     R14,READR
         BR    R14
READSEGD LH    R1,0(,R2)           LENGTH
         AR    R2,R1               POINT TO NEXT SEGMENT
         C     R2,DEBLOCKS         END OF BLOCK
         BNL   READ                YES, BRANCH
         B     READVBS             GO PROCESS NEW SEGMENT
         DROP  R4                  IHADCB
         SPACE 1
*----------------------------------------------------------*
*        SUBROUTINE TO PUT OUT A MESSAGE                   *
*----------------------------------------------------------*
         SPACE 1
PUTMSG   STM   R14,R1,PUTLINS
         XC    MYOLD(8),MYOLD
         XC    MYSEG(4),MYSEG
         MVC   MYPTPB(12),MODLPTM
         LA    R14,1               NO. OF MESSAGE SEGMENTS
         ST    R14,MYOLD
         LA    R14,MYSEG           POINT TO 1ST SEGMENT
         ST    R14,MYOLD+4
         LR    R14,R0              LENGTH IN R0
         LA    R14,4(,R14)         ADD 4
         LA    R15,MYSEG+4
         CLC   0(3,R1),=C'IKJ'     IS DATA PRECEEDED BY MESSAGE ID?
         BE    *+L'*+12            YES - BRANCH
         LA    R14,1(,R14)         ADD 1 TO LENGTH
         MVI   0(R15),C' '         INSERT LEADING BLANK
         LA    R15,1(,R15)         BUMP POINTER
         STH   R14,MYSEG
         LR    R14,R0
         BCT   R14,*+L'*+6
         MVC   0(*-*,R15),0(R1)    MOVE MESSAGE IN
         EX    R14,*-6
         L     R15,MYPUTLEP
        PUTLINE PARM=MYPTPB,OUTPUT=(MYOLD),ENTRY=(15),MF=(E,MYIOPL)
         LM    R14,R1,PUTLINS
         BR    R14
         EJECT
*----------------------------------------------------------*
*        CONSTANTS                                         *
*----------------------------------------------------------*
         SPACE 1
MODLPTM PUTLINE OUTPUT=(1,TERM,SINGLE,INFOR),                          X
               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),MF=L
         SPACE 1
         PRINT NOGEN
SEQDCB  DCB    DDNAME=DYNAM,DSORG=PS,MACRF=(RP),                       X
               EODAD=0,SYNAD=0
SEQDCBL  EQU   *-SEQDCB
PDSDCB  DCB    DDNAME=DYNAM,DSORG=PO,MACRF=(R),                        X
               EODAD=0,SYNAD=0
PDSDCBL  EQU   *-PDSDCB
         PRINT GEN
         SPACE 1
DYNREAD READ   DYNDECB,SF,0,0,'S',MF=L
DYNDECBL EQU   *-DYNDECB
         SPACE 1
GMVU    GETMAIN VU,MF=L
GMVUL    EQU   *-GMVU
         SPACE 1
BOTNINES DC    F'99999999'
HEXTAB   DC    C'0123456789ABCDEF' EDIT HEX TRANSLATE TABLE
BLANKS   DC    CL132' '
         EJECT
*------- TRANSLATE TABLES
ASIST    DC    64X'4B',X'40',9X'4B'
         DC    X'4A4B4C4D4E4F'     CENT,PERIOD,LESS,LPAREN,PLUS,BAR
         DC    X'50',9X'4B'        AMPERSAND
         DC    X'5A5B5C5D5E5F'     EXCL,$,DOT,RPAREN,SEMI,NOT
         DC    X'6061',8X'4B'      HYPHEN,SLASH
         DC    X'6A6B6C6D6E6F'     WHAT,COMMA,PERCENT,UNDLN,GT,QM
         DC    9X'4B',X'79'        70-78
         DC    X'7A7B7C7D7E7F'     COLON,POUND,AT,APOST,EQ,DBLQUOTE
         DC    X'4B'
         DC    X'818283848586878889',7X'4B'
         DC    X'919293949596979899',8X'4B'
         DC    X'A2A3A4A5A6A7A8A9',23X'4B'
         DC    C'ABCDEFGHI',7X'4B'
         DC    C'JKLMNOPQR',8X'4B'
         DC    C'STUVWXYZ',06X'4B'
         DC    C'0123456789',6X'4B'
CAPST    DC    64X'4B',X'40',9X'4B'
         DC    X'4A4B4C4D4E4F'     CENT,PERIOD,LESS,LPAREN,PLUS,BAR
         DC    X'50',9X'4B'        AMPERSAND
         DC    X'5A5B5C5D5E5F'     EXCL,$,DOT,RPAREN,SEMI,NOT
         DC    X'6061',8X'4B'      HYPHEN,SLASH
         DC    X'6A6B6C6D6E6F'     WHAT,COMMA,PERCENT,UNDLN,GT,QM
         DC    9X'4B',X'79'        70-78
         DC    X'7A7B7C7D7E7F'     COLON,POUND,AT,APOST,EQ,DBLQUOTE
         DC    X'4B'
         DC    C'ABCDEFGHI',7X'4B'
         DC    C'JKLMNOPQR',8X'4B'
         DC    C'STUVWXYZ',23X'4B'
         DC    C'ABCDEFGHI',7X'4B'
         DC    C'JKLMNOPQR',8X'4B'
         DC    C'STUVWXYZ',06X'4B'
         DC    C'0123456789',6X'4B'
FINDSBA  DC    17X'00',X'11',238X'00'
NUMERIC  DC    240X'FF',10X'00',6X'FF'
TABNONBL DC    64X'FF'
         DC    X'00'               BLANK
         DC    42X'FF'
         DC    X'FF'               COMMA
         DC    148X'FF'
TABBLANK DC    64X'00'
         DC    X'40'               BLANK
         DC    42X'00'
         DC    X'00'               COMMA
         DC    148X'00'
TABQUOTE DC    125X'00',X'7D',130X'00'
         EJECT
*------- MESSAGES
MSG04    DC    C'UNABLE TO OPEN DATASET'
MSG08    DC    C'SPECIFIED MEMBER NOT FOUND IN DATASET'
MSG20   MSG    'INVALID SUBCOMMAND'
MSG21   MSG    'INVALID PF KEY'
MSG31   MSG    'FOUND IN LINE XXXXX COL XXX'
MSG32   MSG    'BOTTOM OF DATA REACHED '
MSG32S  MSG    'SUBCOMMAND NOT FOUND'
MSG32F  MSG    'FUNCTION DATA NOT FOUND'
MSG32SS MSG    'SUBCOMMANDS NOT FOUND'
MSG32X  MSG    'SYNTAX DATA NOT FOUND'
MSG32O  MSG    'OPERAND DATA NOT FOUND'
MSG32OO MSG    'OPERAND NOT FOUND'
MSG33   MSG    'STRING NOT SPECIFIED'
MSG34   MSG    'INVALID OPERAND'
MSG35   MSG    'MISSING OPERAND'
MSG36   MSG    'MEMBER NOT FOUND'
MSG37   MSG    'BLDL FAILED'
MSG38   MSG    'NOT A PDS'
MSG40   MSG    'PFK HAS BEEN RESET'
MSG41   MSG    'INVALID PFK COMMAND'
         SPACE 2
*------- SCREEN DATAS
SCREEN  DCS    X'40',SBA,24,80,SBA,1,1
        DCS    SF,PROHIS,C'HELP MEMBER==>'
SCRMEM  DCS    SF,UNPHI,CL8' '
        DCS    SF,PROHIS,C' SUBCOMMAND==>'
SCRSUB  DCS    SF,UNPHI,CL8' '
SCRERR  DCS    SF,PROHIS,C'        LINE '
SCRLINE DCS    C'00000'
        DCS    C' COL '
SCRCOL  DCS    C'001 080 '
SCRRTA  DCS    SF,PROHIS,RTA,02,07,X'40'
        DCS    SF,PROHIS,C'INPUT==>'
        DCS    SF,UNPHI,CL54' '
        DCS    SF,PROHIS,C'RANGE'
SCRRGE  DCS    SF,UNPHI,C'20'      START WITH RANGE EQUAL PAGE
        DCS    SF,PROLOS
SCREENL  EQU   *-SCREEN
SCRDATA  EQU   *
SCRPAD  DCS    RTA,1,1,C' '
SCRSUF  DCS    SBA,02,17,IC
         SPACE 1
FLD1AA  DCS    1,17
FLD2AA  DCS    1,41
FLD1BA  DCS    2,17
FLD2BA  DCS    2,78
FLD1BB   DC    X'C2D4'             R2,C17 ON 3278-5
FLD2BB   DC    X'C3D1'             R2,C78 ON 3278-5
         SPACE 1
INWRT    DC    X'27F5'                 CC = EW
        DCS    X'C1'                   WCC = RMDT
        DCS    SBA,1,1
        DCS    RTA,1,1,X'00'
        DCS    SF,UNPHI
        DCS    IC
INWRTL   EQU   *-INWRT
INWRTA   DC    X'277E'                 CC = EWA
        DCS    X'C1'                   WCC = RMDT
        DCS    SBA,1,1
        DCS    RTA,1,1,X'00'
        DCS    SF,UNPHI
        DCS    IC
INWRTAL  EQU   *-INWRTA
ERAZE   DCS    X'40',SBA,24,79,SBA,1,1
        DCS    RTA,7,1,X'00',RTA,13,1,X'00'
        DCS    RTA,19,1,X'00',RTA,1,1,X'00',IC
ERAZEL   EQU   *-ERAZE
         EJECT
*------- LITERAL POOL
         SPACE 1
        LTORG
         SPACE 1
         DC    0D'0'               END OF CSECT
         SPACE 1
         DROP  R10,R11,R12
*= = = = END OF CSECT ADDRESSABILITY = = = = = = = = = = = = = = = = =*
         SPACE 1
*------- COLUMN HEADER CONSTANTS
         SPACE 1
MARKS    DC    18C'----+'
MARKHS   DC    18C' - - - - +'
         EJECT
*----------------------------------------------------------*
*        HEL CSECT EXTENSIONS                              *
*----------------------------------------------------------*
         SPACE 1
HELEXT   CSECT
         USING *,R8
         USING HELXEQ,R10,R11,R12
         B     TSOE                +0 = TSO
         B     SNAPE               +4 = SNAP
         SPACE 1
*----------------------------------------------------------*
*        TSO                                               *
*----------------------------------------------------------*
         SPACE 1
TSOE     LA    R1,CMDAREA          START OF TSO PARAMETERS
         LA    R0,63               LENGTH OF PARSE STRING
         STH   R0,0(,R1)           SAVE FOR PARSE
         LA    R15,OPD1            FIRST PARAMETER
         TM    6(R15),PRESENT      ANY OPERANDS?
         BZ    FILLSCR             NO, IGNORE
         TM    6(R15),QUOTED       QUOTED?
         BO    ERRINV              YES, INVALID
         L     R14,0(,R15)         START OF PARAMETER
         LH    R15,4(,R15)         LENGTH OF PARAMETER
         LTR   R15,R15             IS IT NULL STRING
         BZ    ERRINV              YES, ERROR
         CH    R15,=H'8'           IS LENGTH MORE THAN 8
         BH    ERRINV              YES, ERROR
         MVC   BLDL(4),=AL2(1,76)
         MVC   BLDL+4(8),BLANKS
         BCT   R15,*+L'*+6         MACHINE LENGTH
         MVC   BLDL+4(*-*),0(R14)  <<EXECUTED>>
         EX    R15,*-6             MOVE IN THE COMMAND NAME
         L     R6,HELECT           ECT ADDRESS
         USING ECT,R6
         CLC   BLDL+4(2),=C'RX'    DUMPER?
         BE    *+L'*+6             YES, BRANCH
         MVC   ECTPCMD(L'ECTPCMD),BLDL+4 COMMAND NAME IS CHANGED
         MVC   ECTSCMD(L'ECTSCMD),BLANKS NO SUBCOMMAND NAME
         LA    R15,OPD2            START OF SECOND ODL
         L     R14,0(,R15)         START OF SECOND PARAMETER
         LA    R14,0(,R14)         DROP TOP BYTE
         SR    R14,R1              OFFSET TO SECOND PARAMETER
         SH    R14,=H'4'           LESS TEXT LENGTH FIELDS
         NI    ECTSWS,255-ECTNOPD  ASSUME OPERANDS
         TM    6(R15),PRESENT      ANY OPERANDS?
         BO    TSO1                YES, BRANCH
         LA    R14,63              NO, USE DEFAULT
         OI    ECTSWS,ECTNOPD      ASSUME NO OPERAND
         DROP  R6
TSO1     TM    6(R15),QUOTED       QUOTED?
         BNO   *+L'*+2             NO, BRANCH
         BCTR  R14,0               YES, POINT TO FIRST QUOTE
         STH   R14,2(,R1)          OFFSET TO OPERANDS
         ST    R1,HELCBUF          START OF COMMAND TEXT
         CLC   BLDL+4(5),=C'TIME ' TIME REQUEST?
         BNE   *+L'*+6             NO, BRANCH
         MVC   BLDL+4(8),=C'IKJEFT25' YES, USE IKJEFT25 INSTEAD
        BLDL   0,BLDL
         LTR   R15,R15             SUCCESSFUL BLDL?
         BZ    TSO2                YES, BRANCH
         MVC   MSG(MSG36L),MSG36   MEMBER NOT FOUND
         B     TSO3
TSO2    STLINENO LINE=1,MODE=OFF   TURN OFF FULLSCREEN MODE
         LA    R1,HELCBUF          CPPL START
         LA    R6,BLDL+4           START OF BLDL INFORMATION
        LINK  DE=(6),SF=(E,LINKAREA)
        STFSMODE ON,INITIAL=YES    TURN ON FULLSCREEN MODE
TSO3     L     R1,HELECT           START OF ECT
         USING ECT,R1
         MVC   ECTPCMD(3),PCMD     HELP COMMAND NAME
         DROP  R1
         B     FILLSCR
         SPACE 1
*----------------------------------------------------------*
*        SNAP                                              *
*----------------------------------------------------------*
         SPACE 1
SNAPE   GETMAIN R,LV=SNAPWKL,SP=1
         LR    R7,R1
         USING SNAPWK,R7
         LA    R0,@DATA
         ST    R0,SNAPR
         A     R0,=A(@DATAL)
         BCTR  R0,0
         ST    R0,SNAPR+4
         L     R0,CHKPTTOP
         ST    R0,SNAPR+8
         L     R0,CHKPTBOT
         AH    R0,=H'80'
         C     R0,ENDPTR
         BNH   *+L'*+4
         LH    R0,ENDPTR
         SH    R0,=H'4'
         ST    R0,SNAPR+12
         OI    SNAPR+12,X'80'
         MVC   SNAPDW(SNAPDL),SNAPD
         LA    R6,SNAPDW
        OPEN   ((R6),OUTPUT),MF=(E,OPEND)
         USING IHADCB,R6
         TM    DCBOFLGS,DCBOFOPN
         BO    SNAP1
         MVC   MSG+2(10),=C'OPEN RC = '
         CVD   R15,DOUBLE
         OI    DOUBLE+7,X'0F'
         UNPK  MSG+12(3),DOUBLE+6(2)
         LA    R0,14
         STH   R0,MSG
         B     SNAPX
         DROP  R6
SNAP1    MVC   SNAPLW(SNAPLL),SNAPL
        SNAP   DCB=(R6),ID=1,PDATA=(REGS),LIST=SNAPR,MF=(E,SNAPLW)
         LTR   R15,R15
         BZ    SNAP2
         MVC   MSG+2(10),=C'SNAP RC = '
         CVD   R15,DOUBLE
         OI    DOUBLE+7,X'0F'
         UNPK  MSG+12(3),DOUBLE+6(2)
         LA    R0,14
         STH   R0,MSG
SNAP2   CLOSE  ((R6)),MF=(E,OPEND)
         DROP  R7
         LTR   R15,R15
         BZ    SNAPX
         CLC   MSG+2(10),=C'SNAP RC = '
         BE    SNAPX
         MVC   MSG+2(11),=C'CLOSE RC = '
         CVD   R15,DOUBLE
         OI    DOUBLE+7,X'0F'
         UNPK  MSG+13(3),DOUBLE+6(2)
         LA    R0,15
         STH   R0,MSG
SNAPX   FREEMAIN R,A=(R7),LV=SNAPWKL,SP=1
         CLC   MSG+2(10),=C'OPEN RC = '
         BE    PROMPT
         CLC   MSG+2(10),=C'SNAP RC = '
         BE    PROMPT
         CLC   MSG+2(11),=C'CLOSE RC = '
         BE    PROMPT
         MVC   MSG+2(9),=C'SNAP DONE'
         LA    R0,9
         STH   R0,MSG
         B     PROMPT
         SPACE 1
         PRINT NOGEN
SNAPD   DCB   DSORG=PS,RECFM=VBA,MACRF=(W),BLKSIZE=1632,LRECL=125,     X
               DDNAME=SYSSNAP
SNAPDL   EQU   *-SNAPD
SNAPL   SNAP   DCB=0,ID=1,PDATA=(REGS),LIST=0,STRHDR=SNAPHP,MF=L
SNAPLL   EQU   *-SNAPL
         PRINT GEN
         SPACE 1
SNAPHP   DC    A(X'80000000'+SNAPHD)
SNAPHD   DC    AL1(L'SNAPHDT)
SNAPHDT  DC    C'H E L - DUMP OF THE WORK-AREA.'
         EJECT
*------- LITERAL POOL
         SPACE 1
        LTORG
         SPACE 1
         DC    0D'0'               END OF CSECT
         SPACE 1
         DROP  R8,R10,R11,R12
*= = = = END OF CSECT ADDRESSABILITY = = = = = = = = = = = = = = = = =*
         EJECT
*----------------------------------------------------------*
*        PARSE PARAMETERS                                  *
*----------------------------------------------------------*
         SPACE 1
         PRINT NOGEN
HELCL   IKJPARM
MEMBRPO IKJIDENT 'MEMBER OR SUBCOMMAND NAME',                          +
               FIRST=ALPHANUM,OTHER=ALPHANUM,MAXLNTH=8
FKW     IKJKEYWD
        IKJNAME 'FUNCTION'
SKW     IKJKEYWD
        IKJNAME 'SYNTAX'
OKW     IKJKEYWD
        IKJNAME 'OPERANDS',SUBFLD=OPLSTS
AKW     IKJKEYWD
        IKJNAME 'ALL'
MKW     IKJKEYWD
        IKJNAME 'MSGS',SUBFLD=MSGLSTS
PKW     IKJKEYWD
        IKJNAME 'POSIT',SUBFLD=POSITF
POSITF  IKJSUBF
POSITFF IKJIDENT 'HELP PARAMETER POSITION',                            +
               FIRST=NUMERIC,OTHER=NUMERIC,MAXLNTH=5
OPLSTS  IKJSUBF
OPLIST  IKJIDENT 'HELP OPERAND NAME',LIST,                             +
               FIRST=ALPHANUM,OTHER=ALPHANUM,MAXLNTH=20
MSGLSTS IKJSUBF
MSGLIST IKJIDENT 'HELP MSG IDENTIFIER',LIST,                           +
               FIRST=ALPHANUM,OTHER=ALPHANUM,MAXLNTH=20
        IKJENDP
         PRINT GEN
         EJECT
*----------------------------------------------------------*
*        WORK AREAS DSECTS                                 *
*----------------------------------------------------------*
         SPACE 1
@DATA    DSECT
         DS    18F                 REGISTER SAVEAREA
CPPLPTR  DS    F
LINKAREA DS    2F
BASE1    DS    4F
BASE2    DS    3F
RETSV    DS    F
MYPPL    DS    7F
MYANS    DS    F
MYECB    DS    F                   USED BY PUTLINE ROUTINE
HELCBUF  DS    F  ****             CPPL FOR CALLED ROUTINE
HELUPT   DS    F  ****             CPPL FOR CALLED ROUTINE
HELPSCB  DS    F  ****             CPPL FOR CALLED ROUTINE
HELECT   DS    F  ****             CPPL FOR CALLED ROUTINE
PCMD     DS    CL8                 PRIMARY COMMAND NAME
SCMD     DS    CL8                 SUBCOMMAND NAME
MYIOPL   DS    4F                  USED BY PUTLINE ROUTINE
MYPTPB   DS    3F                  USED BY PUTLINE ROUTINE
MYOLD    DS    2F                  USED BY PUTLINE ROUTINE
MYSEG    DS    2H,CL256            USED BY PUTLINE ROUTINE
PUTLINS  DS    4F                  USED BY PUTLINE ROUTINE
MYPUTLEP DS    F                   ADDRESS OF IKJPUTL
MYSTPB   DS    0F                  5 WORDS USED BY STACK DELETE
MYDAPL   DS    5F
MYDAPB   DS    21F
$DSNAME  DS    H,CL44
$MEMBER  DS    CL8
$SUBLEN  DS    XL2
$SUBCOM  DS    CL8
$SUBLINE DS    CL4
$OPERAND DS    21CL20              TWENTY OPERANDS (EACH MAX. 20 BYTES)
$DDNAML  DS    H                   THESE
$DDNAME  DS    CL8,CL36              THREE TOGETHER
$VOLSER  DS    CL6
$UCBAD   DS    F
PAGESIZE DS    H                   LINES PER SCREEN-4
PAGEWIDT DS    H                   CHARACTERS PER LINE (80 OR 132)
OBTAINW  DS    4F
MYDSCB   DS    CL140               96 BYTES OF DSCB, 5 BYTES CCHHR
MSG      DS    CL128
STATUS   DS    X
STALLOC  EQU   X'80'
STOPEN   EQU   X'40'
STABEND  EQU   X'20'
STGMVU   EQU   X'02'
STNOMEM  EQU   X'01'
MDFL     DS    X
MODEX    EQU   X'80'
HELPX    EQU   X'40'
STSIZEX  EQU   X'20'
HELPFX   EQU   X'01'
DSORG    DS    X
TSTRECFM DS    X
FINDSW   DS    X
RC       DS    H
FILEKV   DS    H
FKV      DS    H
SKV      DS    H
OKV      DS    H
AKV      DS    H
MKV      DS    H
COMMND   DS    H
HELPFLG  DS    X
DEBUGSW  DS    X
MEMBFLG  DS    X
MEMBFLGM EQU   X'80'               NEW MEMBER
MEMBFLGS EQU   X'08'               NEW SUBCOMMAND
MYDFPARM DS    5F                  USED BY DAIRFAIL
MYDFREGS DS    F                   USED BY DAIRFAIL
MYDFRC   DS    F                   USED BY DAIRFAIL
MYJEFF02 DS    F                   USED BY DAIRFAIL
MYDFID   DS    H                   USED BY DAIRFAIL
SVPFNA   DS    F
DOUBLE   DS    D
COLNUM   DS    CL6,CL2
DAIRREGS DS    F
OPEND    DS    0F
CLOSED   DS    F
DYNEXLST DS    2F
DYNDCBW  DS    0D,XL(SEQDCBL)
DYNDECBW DS    0F,XL(DYNDECBL)
RANGE    DS    2F
ANSWER   DS    2F
GMVUW    DS    0F,XL(GMVUL)
SAVSPANL DS    F
SAVLRECL DS    F
SAVBLKSI DS    F
SAVHOLDL DS    F
BLOCKPTR DS    F
SPANPTR  DS    F
HOLDPTR  DS    F
CHKPTTOP DS    F
CHKPTBOT DS    F
CHKPTDUM DS    2F
ENDPTR   DS    F
HOLDTOP  DS    F
HOLDEND  DS    F
HOLDDIR  DS    (16*66)X *** WAS 88F -- GOOD FOR UP TO 65 LINES
DIRNUM   EQU   0
DIRLEN   EQU   4
DIRREC   EQU   8
DIRNXT   EQU   12
DIRSIZ   EQU   16
OFFSET   DS    H
RECSIZE  DS    H
COUNT    DS    F
TTR      DS    F
TTRZ     DS    F                   TTR + 0 FOR POINT
TTRK     DS    F                   TTR + CONCAT FOR FIND
SCROLL   DS    F
DOWNAMT  DS    F
LISTNUM  DS    F
AIMFOR   DS    F
FLDPTR   DS    F
FLDLEN   DS    F
CMDPTR   DS    F
CMDLEN   DS    F
CMDAREA  DS    CL63
SAVELINE DS    CL33
SBASAVE  DS    4F
FINDCOL  DS    H
FNDNUM   DS    F
FNDOFF   DS    H
STRINGL  DS    H
STRING   DS    CL64
OPDL     DS    0F                  OPERAND DESCRIPTOR LIST
OPD0     DS    2F                  COMMAND DESCRIPTOR
OPD1     DS    2F                  OPERAND DESCRIPTOR 1
OPD2     DS    2F                  OPERAND DESCRIPTOR 2
OPD3     DS    2F                  OPERAND DESCRIPTOR 3
OPD4     DS    2F                  OPERAND DESCRIPTOR 4
OPD5     DS    2F                  OPERAND DESCRIPTOR 5
OPDLL    EQU   *-OPDL              LENGTH OF LIST
PRESENT  EQU   X'80'
QUOTED   EQU   X'40'
HOLDR    DS    F
READR    DS    F
DOWNR    DS    F
DEBLOCKS DS    3F
SCREENF  DS    F
TGETREGS DS    3F
TGETREG2 DS    3F                  FOR DEBUG
SYNADSW  DS    F
SYNADMSG DS    CL78
DEVDATA  DS    2F
JFCB     DS    0F,CL176
APFKTB   DS    F
SCREENH  DS    F
BLDL     DS    0H,CL80
         DS    0D
REPLY    DS    CL256
PERIODS  DS    CL256
PFKTAB   DS    12CL32,CL1
SCREENW  DS    0D,5400C
@DATAL   EQU   (((*-@DATA)+7)/8)*8
         SPACE 1
SNAPWK   DSECT
SNAPDW   DS    0F,(SNAPDL)X
SNAPLW   DS    0F,(SNAPLL)X
SNAPR    DS    4F
SNAPWKL  EQU   (((*-SNAPWK)+7)/8)*8
         SPACE 1
*----------------------------------------------------------*
*        DSECTS                                            *
*----------------------------------------------------------*
         SPACE 1
         PRINT NOGEN
        CVT    DSECT=YES,LIST=YES
        DCBD   DEVD=DA,DSORG=PO
TIODSECT DSECT
        IEFTIOT1
UCBDSECT DSECT
        IEFUCBOB LIST=YES
        IKJTCB LIST=YES
        IKJCPPL
        IKJPPL
        IKJECT
        IKJIOPL
        IKJDAPL
        IKJDAP08
        IKJDAP18
        IKJEFFDF DFDSECT=YES
         SPACE 2
         END
