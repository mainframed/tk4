         MACRO
&NME     #DIE  &O,&A,&B,&C,&TYPE=MSG
.*
.*
.*                                                            DBC 12/84
.* LAST CHANGE DATE - DECEMBER 6, 1964                        DBC 12/84
.*                  - ADDED "0H'0'," TO INSURE THAT GENERATED DBC 12/84
.*                    "00DEAD COMMANDS" ARE HWORD ALIGNED.    DBC 12/84
.*                                                            10/84 DBC
.* LAST CHANGE DATE - OCTOBER 25, 1984                        10/84 DBC
.*                  - MINOR CHANGE TO REDUCE THE NUMBER OF    10/84 DBC
.*                    LINES PRINTED BY THE MACRO EXPANSION.   10/84 DBC
.*                    THE OBJECT CODE REMAINS UNCHANGED.      10/84 DBC
.*
.* LAST CHANGE DATE - OCTOBER 18, 1983
.*                  - MAILING ADDRESS CHANGE
.*
.* LAST CHANGE DATE - MARCH 16, 1983
.*                  - COMMENTARY ADJUSTMENTS
.*                  - MAILING ADDRESS CHANGE
.*
.* LAST CHANGE DATE - APRIL 21, 1981
.*                  - MACRO NAME CHANGED FROM $DIE TO #DIE.
.*
.* LAST CHANGE DATE - JAUNARY 27, 1981
.*                  - THE MACRO HAS BEEN REWRITTEN TO
.*                    GENERATE INLINE TRAPS WHENEVER
.*                    EXTENDED MNEMONICS FOR THE 'BC' AND
.*                    'BCR' INSTRUCTIONS ARE USED. THIS IS
.*                    ACCOMPLISHED BY USING THE INVERSE OF
.*                    OF THE GIVEN BRANCH CONDITION TO
.*                    SKIP AROUND THE INLINE TRAP.
.*                    IN THOSE CASES WHERE AN INLINE TRAP
.*                    IS NOT DESIRED (SUCH AS WITHIN A
.*                    BRANCH VECTOR TABLE), THE
.*                    NON-EXTENDED FORM OF THE 'BC'
.*                    INSTRUCTION CAN BE USED; E.G.:
.*                         #DIE C,8   INSTEAD OF   #DIE Z
.*                  - A UNIQUE NUMBER IS NOW APPENDED TO
.*                    GIVEN MESSAGES.
.*
.* LAST CHANGE DATE - FEBRUARY 12, 1980
.*                  - TYPE=CMD SUPPORT HAS BEEN ADDED. THIS
.*                    PROVIDES A MEANS OF COMMUNICATING
.*                    COMMANDS TO THE "DEBUGGING CONTROLLER"
.*                    PROGRAM.
.*                  - IF NO BRANCH CONDITIONALS ARE GIVEN,
.*                    THEN THE "DEAD" CODE IS NOW GENERATED
.*                    INLINE. BEFORE, AN UNCONDITIONAL BRANCH
.*                    TO A "DEAD" LITTERAL WAS MADE.
.*
.* LAST CHANGE DATE - APRIL 24, 1978
.*                  - THE MACRO HAS BEEN REWRITTED TO
.*                    GENERATE MESSAGE STRINGS (INSTEAD OF
.*                    JUST A SEQUENCE NUMBER) AT THE BRANCH
.*                    ADDRESS. SUCH MESSAGES COULD BE
.*                    REASONABLY DISPLAYED VIA AN ESTAE
.*                    ROUTINE.
.*
.* LAST CHANGE DATE - DECEMBER 16, 1977
.*                  - 2ND AND 3RD OPERANDS HAVE BEEN ADDED TO
.*                    THE MACRO PROTOTYPE SO AS TO SUPPORT
.*                    THE GENERATION OF BRANCH INSTRUCTIONS
.*                    OTHER THAN JUST CONDITIONAL-BRANCH.
.*                  - WHEN NO OPERANDS ARE GIVEN, AN
.*                    UNCONDITIONAL BRANCH IS NOW GENERATED.
.*
.* LAST CHANGE DATE - FEBRUARY 2, 1977
.*                  - MAILING ADDRESS CHANGE
.*
.* LAST CHANGE DATE - SEPTEMBER 10, 1976
.*
.* THIS MACRO WAS WRITTEN BY DAVID B. COLE.  ANY QUESTIONS
.* CONCERNING IT MAY BE ADDRESSED TO:
.*       RR#2 BOX 712
.*       AFTON, VA. 22920
.*
.*
.*
         GBLA  &#DIECOD
         GBLC  &#EBCDIC(256)
         LCLA  &L,&M
         LCLC  &MSG,&LAB,&OP,&N,&#
         AIF   ('&TYPE' EQ 'MSG' OR '&TYPE' EQ 'CMD').TYPEOK
         MNOTE 8,'TYPE=&TYPE NOT RECOGNIZED. TYPE=CMD ASSUMED.'
.TYPEOK  ANOP
&N       SETC  '&NME'
&#DIECOD SETA  &#DIECOD+1
&#       SETC  '000&#DIECOD'
&#       SETC  '&#'(K'&#-3,4)
&M       SETA  N'&SYSLIST+1
.MLP     ANOP
&M       SETA  &M-1
         AIF   (&M EQ 0).NOMSG
         AIF   (K'&SYSLIST(&M) EQ 0).MLP
         AIF   ('&SYSLIST(&M)' EQ '''''').NOMSG
&L       SETA  K'&SYSLIST(&M)-2
         AIF   (&L LE 0).NOMSG2
         AIF   ('&SYSLIST(&M)'(1,1) NE '''').NOMSG2
&MSG     SETC  '&SYSLIST(&M)'(2,&L)
         AIF   ('&TYPE' NE 'MSG').MSGDONE
&MSG     SETC  '&#DIECOD &MSG'
&L       SETA  &L+1+K'&#DIECOD
         AGO   .COMN
.*
.NOMSG2  ANOP
&M       SETA  &M+1
.NOMSG   AIF   ('&TYPE' NE 'MSG').MSGDONE
&MSG     SETC  '&#DIECOD'
&L       SETA  K'&MSG
.*
.COMN    AIF   (&L/2*2 EQ &L).MSGDONE
&L       SETA  &L+1
&MSG     SETC  '&MSG '
.MSGDONE ANOP
.*
         AIF   (&M LE 1 OR '&O' EQ '').INLINE
         AIF   (&M EQ 2).INVERT
         AIF   (&M NE 3).GENLIT
         AIF   ('&O'(K'&O,1) NE 'R').GENLIT
.*
.INVERT  ANOP
&OP      SETC  'BN&O'
         AIF   ('&O'(1,1) NE 'N').NVRTDON
&OP      SETC  'B'.'&O'(2,K'&O-1)
.NVRTDON ANOP
.*
         AIF   (&M EQ 2).SETLAB
&N       &OP   &A                  BRANCH IF OK
&N       SETC  ''
         AGO   .INLINE
.SETLAB  ANOP
&LAB     SETC  'DIE&#.Z'
&N       &OP   &LAB                SKIP IF OK
&N       SETC  ''
.INLINE  ANOP
.*                                                            10/84 DBC
         AIF   ('&TYPE' EQ 'MSG').INLMSG
&N       DC    0H'0',X'00DEAD0100',C'&MSG',X'00'
         AGO   .TRAIL
.INLMSG  ANOP                                                 10/84 DBC
&N       DC    0H'0',X'00DEAD',AL1(&L),C'&MSG'
.*                                                            10/84 DBC
.TRAIL   AIF   ('&LAB' EQ '').MEND
&LAB     DS    0H                  RECEIVE SKIP AROUND TRAP
         AGO   .MEND
.*
.GENLIT  AIF   ('&TYPE' EQ 'MSG').LITMSG
&MSG     SETC  '
         AGO   .GOTLIT
.LITMSG  #TEST GEN=EBCDIC
&MSG     SETC  '
.GOTLIT  ANOP
.*
         AIF   (&M NE 3).OP4
&N       B&O   &A,=C'&MSG'
         AGO   .MEND
.OP4     ANOP
&N       B&O   &A,&B,=C'&MSG'
.MEND    MEND
         MACRO
&N       #ENTER &NME,&ESDTYPE=DEFAULT,&BASES=1,&SAVTYPE=LOCAL,&PFIX=
.*
.*
.*                                                            08/85 DBC
.* LAST CHANGE DATE - AUGUST 12, 1985                         08/85 DBC
.*                  - THIS MACRO NO LONGER ASSUMES THAT A     08/85 DBC
.*                    SATISFIED UNCONDITIONAL GETMAIN         08/85 DBC
.*                    REQUEST SETS R15 TO ZERO. ONE CUSTOMER  08/85 DBC
.*                    ACTUALLY HAD A MODIFIED GETMAIN SVC     08/85 DBC
.*                    ROUTINE THAT INSURED THAT R15 WAS       08/85 DBC
.*                    UNCHANGED BY GETMAIN. THIS LED TO       08/85 DBC
.*                    DISASTEROUS RESULTS WHEN HE ATTEMPTED   08/85 DBC
.*                    TO USE THIS MACRO IN THAT               08/85 DBC
.*                    ENVIRONMENT. NOW, CHANGING MY MACRO     08/85 DBC
.*                    WAS A LOT SIMPLER THAN CHANGING HIS     08/85 DBC
.*                    ENVIRONMENT, AND THERE WAS A LOT OF     08/85 DBC
.*                    MONEY AT STAKE, SO ...                  08/85 DBC
.*                                                            08/84 DBC
.* LAST CHANGE DATE - AUGUST 8, 1984                          08/84 DBC
.*                  - WHEN BASES=* IS SPECIFIED, #ENTER NOW   08/84 DBC
.*                    DERIVES THE DESIRED BASE ADDRESS BY     08/84 DBC
.*                    SUBTRACTING AN OFFSET FROM THE          08/84 DBC
.*                    CURRENT ENTRY ADDRESS. PREVIOUSLY, IT   08/84 DBC
.*                    WAS JUST LOADING AN ADCON FOR THE       08/84 DBC
.*                    DESIRED BASE ADDRESS. THIS CAUSED       08/84 DBC
.*                    PROBLEMS IF THE #ENTER MACRO WAS        08/84 DBC
.*                    LOCATED WITHIN DYNAMICALLY RELOCATED    08/84 DBC
.*                    CODE.                                   08/84 DBC
.*                  - SIMILARLY, WHEN SAVTYPE=(REMOTE,NME%)   08/84 DBC
.*                    IS SPECIFIED, THE DESIRED SAVE AREA     08/84 DBC
.*                    IS LOCATED BY ADDING AN OFFSET (WHICH   08/84 DBC
.*                    MAY BE NEGATIVE) TO THE CURRENT ENTRY   08/84 DBC
.*                    ADDRESS.                                08/84 DBC
.*                                                            06/84 DBC
.* LAST CHANGE DATE - JUNE 11, 1984                           06/84 DBC
.*                  - ADDED "SAVTYPE=NONE" SUPPORT.           06/84 DBC
.*                  - WHEN A REMOTE SAVE AREA WAS USED,       06/84 DBC
.*                    #ENTER USE TO GENERATE A "USING"        06/84 DBC
.*                    STATEMENT DECLARING R13 AS A BASE FOR   06/84 DBC
.*                    THAT SAVE AREA. THAT "USING" STATEMENT  06/84 DBC
.*                    IS NO LONGER GENERATED.                 06/84 DBC
.*
.* LAST CHANGE DATE - OCTOBER 18, 1983
.*                  - MAILING ADDRESS CHANGE
.*
.* LAST CHANGE DATE - APRIL 27, 1983
.*                  - MAILING ADDRESS CHANGE.
.*                  - USE OF IBM'S "SAVE" MACRO HAS BEEN
.*                    REPLACED BY LOCAL CODE.
.*                  - THE ASSEMBLY DATE AND TIME ARE NOW
.*                    INCLUDED IN THE MODULE IDENTIFIER
.*                    TEXT.
.*
.* LAST CHANGE DATE - APRIL 21, 1981
.*                  - MACRO NAME CHANGED FROM $ENTER TO #ENTER.
.*
.* LAST CHANGE DATE - APRIL 15, 1981
.*                  - ADDED ENTRY LINKAGE FOR A PLI ENVIRONMENT.
.*                  - ADDED "#REGS GEN=NO" SUPPORT.
.*
.* LAST CHANGE DATE - JULY 18, 1980
.*                  - BUG FIXED: THE PRECEEDING MODIFICATION INTRODUCED
.*                    AN ERROR WHICH UNDER CERTAIN CIRCUMSTANCES
.*                    GENERATED ASSEMBLY ERRORS.
.*
.* LAST CHANGE DATE - JULY 10, 1980
.*                  - FOR GETMAINED REENTRANT SAVE AREAS, CODE HAS BEEN
.*                    ADDED TO CLEAR THE ENTIRE GETMAINED AREA TO ZEROS
.*                    BEFORE SETING THE CHAIN FIELD.
.*                  - INDIRECT ADDRESSING TO A REMOTE SAVE AREA IS NOW
.*                    SIGNALLED BY A TRAILING PERCENT SIGN RATHER THAN
.*                    A LEADING PERCENT SIGN.
.*
.* LAST CHANGE DATE - OCTOBER 3, 1979
.*                  - CODE HAS BEEN ALTERED SO THAT ADDRESSABILITY TO
.*                    A REMOTE SAVE AREA DOES NOT HAVE TO BE BASED ON
.*                    R15 (I.E., ON THE ENTRY ADDRESS).
.*
.* LAST CHANGE DATE - OCTOBER 3, 1978
.*                  - THE GETMAIN FOR THE RENTRANT SAVE AREA HAS BEEN
.*                    CHANGED SO THAT MORE THAN 4K BYTES CAN BE GOTTEN.
.*
.* LAST CHANGE DATE - FEBRUARY 28, 1978
.*                  - BUG FIXED IN REMOTE SAVE AREA HANDLING
.*
.* LAST CHANGE DATE - JANUARY 29, 1978
.*                  - IN MOST CASES IT IS LOGICALLY INCONSISTANT TO
.*                    CODE 'BASES=*' WHEN ONE OF THE OLD BASES IS R13.
.*                    THIS PROBLEM IS NOW RECOGNIZED AND FLAGGED.
.*
.*                  - A REMOTE SAVE AREA'S NAME CAN NOW BE GIVEN EITHER
.*                    WITH OR WITHOUT A PRECEEDING PERCENT (%) SIGN TO
.*                    INDICATE WHETHER THE NAMED ADDRESS MUST BE
.*                    REACHED BY INDIRECT ADDRESSING.
.*
.* LAST CHANGE DATE - NOVEMBER 4, 1977
.*                  - SUPPORT IS ADDED FOR DEFINING A LOCAL SAVE AREA
.*                    WHOSE LENGTH IS OTHER THAN 72 BYTES.
.*
.* LAST CHANGE DATE - JANUARY 13, 1977
.*                  - THE MF= AND SVID= OPERANDS ARE REPLACED BY THE
.*                    SAVTYPE= OPERAND.
.*                  - SUPPORT FOR THE HANDLING OF A REMOTELY ASSEMBLED
.*                    SAVE AREA.
.*                  - MAILING ADDRESS CHANGE.
.*
.* LAST CHANGE DATE - SEPTEMBER 14, 1976
.*                  - IMPLEMENT SUPPORT FOR "BASES=*" WHICH IMPLIES
.*                    THAT BOTH THE BASE ADDRESS AND BASE REGISTERS
.*                    DEFINED BY THE PHYSICALLY PREVIOUS USE OF THE
.*                    #ENTER MACRO ARE TO BE REUSED.
.*
.* LAST CHANGE DATE - AUGUST 23, 1976
.*
.* THIS MACRO WAS WRITTEN BY DAVID B. COLE.  ANY QUESTIONS CONCERNING
.* IT MAY BE ADDRESSED TO:
.*       RR#2 BOX 712
.*       AFTON, VA. 22920
.*
.*
.*
.*   THIS MACRO GENERATES OS STANDARD ENTRY LINKAGE. IT WAS WRITTEN TO
.* PROVIDE A SIMPLE, FLEXIBLE, AND COMPLETE METHOD OF GENERATING SUCH
.* LINKAGE. IN ADDITION, FOR ALMOST ALL OPERAND COMBINATIONS, #ENTER
.* WILL GENERATE THE ABSOLUTE MINIMUM AMOUNT OF CODE NECESSARY.
.*
.*   THE #ENTER MACRO WILL GENERATE THE FOLLOWING:
.*     - A CSECT OR ENTRY CARD (IF DESIRED)
.*     - A MODULE IDENTIFIER WHICH WILL INCLUDE THE ASSEMBLY
.*       DATE AND TIME.
.*     - CODE TO SAVE ALL REGISTERS IN THE HIGHER SAVE AREA
.*     - CODE TO LOAD R13 WITH A POINTER TO A LOWER SAVE AREA
.*     - CODE TO CROSS LINK THE LOWER SAVE AREA WITH THE HIGHER SAVE
.*       AREA
.*     - CODE TO LOAD ANY SET OF BASE REGISTERS
.*     - A USING STATEMENT DECLARING THE SET OF BASE REGISTERS
.*     - EITHER THE LOWER SAVE AREA ITSELF OR CODE TO GETMAIN A
.*       REENTRANT SAVE AREA OF 72 OR MORE BYTES OR CODE TO LOAD THE
.*       ADDRESS OF AN ASSEMBLED SAVE AREA THAT IS REMOTE FROM THE
.*       MACRO EXPANSION.
.*     - FOR A GETMAINED REENTRANT SAVE AREA, CODE TO CLEAR THE AREA TO
.*       ZEROS.
.*
.* &N
.*       THIS IS THE ONLY FIELD REQUIRED FOR THE MACRO CALL. IT MUST
.*       SPECIFY THE DESIRED CONTROL SECTION OR ENTRY NAME.
.*
.* &NME
.*       USE THIS FIELD TO SPECIFY OPTIONAL TEXT TO BE
.*       INCLUDED INTO THE MODULE IDENTIFIER. ENCLOSING
.*       QUOTES ARE OPTIONAL.
.*
.* &ESDTYPE=
.*       THIS OPERAND CONTROLS THE TYPE OF EXTERNAL SYMBOL (IF ANY) TO
.*       BE GENERATED USING &N. VALID VALUES FOR THIS OPERAND IMPLY THE
.*       FOLLOWING:
.*              -OMITTED-    ==> ESDTYPE=ENTRY IF SAVTYPE=PLI
.*              -OMITTED-    ==> ESDTYPE=CSECT OTHERWISE
.*             ESDTYPE=CSECT ==>
.*                     &N       CSECT
.*             ESDTYPE=START ==>
.*                     &N       START
.*             ESDTYPE=ENTRY ==>
.*                              ENTRY &N
.*                     &N       DS    0H
.*             ESDTYPE=     <==>
.*             ESDTYPE=NONE  ==>
.*                     &N       DS    0H
.*
.* &BASES=
.*       USE THIS OPERAND TO SPECIFY EITHER HOW MANY OR EXACTLY WHICH
.*       BASE REGISTERS TO DECLARE AND LOAD. VALID VALUES FOR THIS
.*       OPERAND ARE:
.*             BASES= -A SINGLE SELF DEFINING NUMERIC-
.*                   THIS REQUESTS THAT A SPECIFIC NUMBER OF BASES BE
.*                   LOADED AND DECLARED. THE MACRO IS ALLOWED TO
.*                   DETERMINE FOR ITSELF PRECISELY WHICH REGISERS TO
.*                   DECLARE AS FOLLOWS. FOR SAVTYPE=LOCAL (SEE BELOW)
.*                   THE FIRST BASE REGISTER WILL BE R13; OTHERWISE
.*                   (I.E. FOR SAVTYPE=RENT OR SAVTYPE=REMOTE), THE
.*                   FIRST BASE REGISTER WILL BE R12. IN EITHER CASE,
.*                   ADDITIONAL BASES WILL BE SUCCESSIVELY LOWER
.*                   NUMBERED REGISTERS. EXAMPLES:
.*                   BASES=3,SAVTYPE=RENT  ==> R12, R11, AND R10.
.*                   BASES=2,SAVTYPE=LOCAL ==> R13, AND R12.
.*             BASES= -A SUBLIST OF ONE OR MORE REGISTER NAMES-
.*                   THE LISTED REGISTERS ARE LOADED AND DECLARED AS
.*                   BASES. THE LEFTMOST LISTED REGISTER IS LOADED WITH
.*                   THE LOWEST ADDRESS. EXAMPLE:
.*                   BASES=(R5,6,4) ==> R5, R6, AND R4 IN THAT ORDER.
.*             BASES=*
.*                   THE BASE ADDRESS AND BASE REGISTERS DEFINED BY THE
.*                   PHYSICALLY PREVIOUS #ENTER MACRO ARE REUSED.
.*          THE BASES= OPERAND MAY BE NULLIFIED BY SPECIFYING EITHER:
.*             BASES=
.*             BASES=0
.*       IN THIS CASE, NO BASE REGISTERS ARE LOADED OR DECLARED.
.*          IF THE BASES= OPERAND IS OMITTED, THEN A DEFAULT OF BASES=1
.*       WILL BE USED.
.*
.* &SAVTYPE=
.*       THIS OPERAND IDENTIFIES THE TYPE OR LOCATION OF THE SAVE AREA
.*       TO BE GENERATED OR USED. VALID VALUES ARE:
.*             -OMITTED-
.*             SAVTYPE=
.*             SAVTYPE=LOCAL
.*             SAVTYPE=(,-SAVE AREA NAME-)
.*             SAVTYPE=(LOCAL,-SAVE AREA NAME-)
.*             SAVTYPE=(LOCAL,,-SAVE AREA LENGTH-)
.*             SAVTYPE=(LOCAL,-SAVE AREA NAME-,-SAVE AREA LENGTH-)
.*                     A STANDARD SAVE AREA IS GENERATED IN THE
.*                     THE MACRO EXPANSION AND ITS ADDRESS IS LOADED
.*                     INTO R13. NOTE, DEPENDING UPON THE BASES=
.*                     OPERAND (SEE ABOVE) R13 MAY ALSO BE DECLARED AS
.*                     A PROGRAM BASE.
.*                        IF A -SAVE AREA NAME- IS GIVEN, THEN IT IS
.*                     USED TO LABEL THE SAVE AREA; OTHERWISE, AN
.*                     INTERNAL NAME IS GENERATED.
.*                              IF -SAVE AREA LENGTH- IS GIVEN, THEN IT
.*                              IS USED TO SET THE LENGTH OF THE SAVE
.*                              AREA; OTHERWISE, THE DEFAULT LENGTH OF
.*                              72 BYTES IS USED.
.*             SAVTYPE=(REMOTE,-SAVE AREA ADDRESS-)
.*                     THE ADDRESS OF THE REMOTE SAVE AREA IS
.*                     LOADED INTO R13. NOTE, IN THIS CASE -SAVE AREA
.*                     ADDRESS- IS A REQUIRED SUB-OPERAND. IT MAY BE
.*                     EITHER AN ADDRESS LABEL OR A PARENTHESIZED
.*                     REGISTER NAME OR AN ADDRESS LABEL FOLLOWED BY A
.*                     PERCENT (%) SIGN. IF THE NAME IS JUST AN ADDRESS
.*                     LABEL, THEN A 'LA' INSTRUCTION IS USED TO LOAD
.*                     THE SAVE AREA'S ADDRESS. IF A PERCENT SIGN
.*                     FOLLOWS THE NAME, THEN AN ADDRESS CONSTANT IS
.*                     GENERATED AND A 'L' INSTRUCTION IS USED. IF A
.*                     REGISTER NAME IS GIVEN, THEN A 'LR' INSTRUCTION
.*                     IS USED UNLESS THE MACRO CAN DETERMINE THAT THE
.*                     NAMED REGISTER IS ACTUALLY R13 IN WHICH CASE IT
.*                     IS ASSUMED THAT THE LOWER SAVE AREA IS ALREADY
.*                     PRESENT AND INITIALIZED, SO THE SAVING OF
.*                     REGISTERS AND THE CROSS-CHAINING OF THE SAVE
.*                     AREAS IS BYPASSED.
.*             SAVTYPE=RENT
.*             SAVTYPE=(RENT,(-LENGTH-,-SUBPOOL-),-ERROR ADDRESS-)
.*             SAVTYPE=(RENT,(-LENGTH-,-SUBPOOL-),RETURN)
.*                     THE MACRO EXPANSION IS TO BE REENTRANT. THE SAVE
.*                     AREA IS TO BE GETMAINED. THE SUB-OPERANDS HAVE
.*                     THE FOLLOWING AFFECT:
.*                     -LENGTH- IS OPTIONAL. IF OMITTED, THEN A VALUE
.*                              OF 72 IS USED. IF GIVEN, THEN IT
.*                              INDICATES THE SIZE OF THE SAVE AREA TO
.*                              BE GOTTEN. WARNING, THE VALUE OF
.*                              -LENGTH- SHOULD NEVER BE LESS THAN 72.
.*                     -SUBPOOL- IS OPTIONAL. IF OMITTED, THEN A VALUE
.*                               OF 0 IS IMPLIED. IF GIVEN, THEN IT
.*                               SPECIFIES THE SUBPOOL OUT OF WHICH THE
.*                               SAVE AREA IS TO BE GOTTEN.
.*                     -ERROR ADDRESS- IS OPTIONAL. IF OMITTED, THEN
.*                                     THE SAVE AREA GETMAIN REQUEST IS
.*                                     UNCONDITIONAL. IF GIVEN, THEN
.*                                     THE GETMAIN IS CONDITIONAL, AND
.*                                     IF IT FAILS, THEN CONTROL IS
.*                                     PASSED TO THE INDICATED ADDRESS.
.*                                     NOTE, -ERROR ADDRESS- MAY BE
.*                                     EITHER A STATEMENT LABEL OR A
.*                                     PARENTHESIZED REGISTER NAME.
.*                                     WARNING, -ERROR ADDRESS- MAY BE
.*                                     USED ONLY IN A MVS ENVIRONMENT.
.*                                     IT IS NOT SUPPORTED UNDER MVT.
.*                     RETURN IS A SPECIAL FORM OF -ERROR ADDRESS-
.*                            WHICH, IF GIVEN, CAUSES CONTROL TO BE
.*                            RETURNED IMMEDIATELY TO THE CALLER IN THE
.*                            EVENT OF A GETMAIN FAILURE. ALL REGISTERS
.*                            ARE RESTORED EXCEPT R15 WHICH CONTAINS
.*                            THE RETURN CODE FROM GETMAIN.
.*             SAVTYPE=PLI
.*             SAVTYPE=NONE                                   06/84 DBC
.*                     NO LOCAL LEVEL SAVEAREA IS DEFINED OR  06/84 DBC
.*                     USED.                                  06/84 DBC
.*             SAVTYPE=(PLI,-LENGTH-)
.*                     THE MACRO IS TO EXPAND INTO THE FORMAT OF A PLI
.*                     PROLOG. THE EXPANSION IS REENTRANT. THE SAVE
.*                     AREA WILL BE A PLI DSA. IT WILL PROBABLY BE
.*                     OBTAINED FROM PLI'S ISA. IF -LENGTH- IS GIVEN,
.*                     THEN IT SPECIFIES THE DESIRED LENGTH OF THE DSA
.*                     THAT THIS EXPANSION OBTAINS. WARNING, THE VALUE
.*                     OF -LENGTH- MUST NEVER BE LESS THAN 88.
.*
.* &PFIX=
.*       THE #ENTER MACRO ATTEMPTS TO USE REGISTER EQUATES IN ITS
.*       EXPANSION WHEN REFERING TO REGISTERS. THIS IS SO THAT THE USE
.*       OF THE REGISTERS IS INDICATED IN THE ASSEMBLER'S CROSS
.*       REFERENCE LISTING. THE PFIX= OPERAND CAN BE USED TO CONTROL
.*       THE SET OF EQUATES USED. FOR EXAMPLE, IF "PFIX=GPR" IS GIVEN,
.*       THEN "GPR1" IS USED WHENEVER THE EXPANSION REFERS FO REGISTER
.*       1.
.*          IF THE PFIX= OPERAND IS OMITTED, THEN THE SET OF REGISTER
.*       EQUATES DEFINED BY THE NEXT PRIOR #REGS MACRO IS USED. IF
.*       THERE ARE NO PRIOR #REGS MACROS, THEN SELF-DEFINING NUMERICS
.*       ARE USED.
.*
.* MISCELLANIOUS CONSIDERATIONS
.*     - SINCE THE #ENTER MACRO EXPANSION USUALLY INCLUDES A CSECT
.*       CARD, THE MACRO CALL SHOULD BE PLACED AT THE PHYSICAL
.*       BEGINNING OF A CONTROL SECTION.
.*     - FOR LOCAL SAVE AREAS IT IS BOTH POSSIBLE AND REASONABLE FOR
.*       R13 TO SERVE AS BOTH THE SAVE AREA POINTER AND A PROGRAM BASE.
.*       THERE ARE, HOWEVER, CERTAIN PRECAUTIONS THAT HAVE TO BE TAKEN
.*       FOR VARIOUS SYSTEM EXIT ROUTINES IF THEY ARE INCLUDED IN THE
.*       PROGRAM. HERE ARE SOME EXAMPLES:
.*           - IOS APPENDAGE ROUTINES: NO BASE REGISTER FOR THE MAIN
.*             PROGRAM, INCLUDING R13, IS AVAILABLE FROM WITHIN AN IOS
.*             APPENDAGE.
.*           - DCB OPEN EXITS: R13 REMAINS A VALID BASE REGISTER.
.*           - EOD ROUTINES: R13 REMAINS A VALID BASE REGISTER.
.*           - SYNAD EXITS: R13 REMAINS A VALID BASE REGISTER UNTIL A
.*             SYNADAF MACRO IS ISSUED. AFTER A SUBSEQUENT SYNADRLS
.*             MACRO, R13 IS AGAIN A VALID PROGRAM BASE.
.*
.*
.*
.* INNER MACROS USED - #USING, #TEST, SAVE, GETMAIN
.*
         GBLA  &#TESERR
         GBLB  &#ENTRNT,&#ENTPLI,&#ENTNUN                     06/84 DBC
         GBLC  &#TESRET(20),&#ENTSIZ,&#ENTSP,&#BS(14)
         LCLA  &A1,&A2,&C1,&C2,&C3,&C4,&B(13),&RMTREGA
         LCLB  &REDUN(13),&OLDBASE,&REMOTE(5),&ALIGND,&LOCAL,&LENGTH
         LCLC  &LID,&@,&#,&N1,&N2,&W2,&W3,&R,&RMTREGC,&SAVLEN,&RMTNAME
         LCLC  &SPOOL,&TB,&ESDT,&C                            06/84 DBC
&#       SETC  '&SYSNDX'
&#ENTRNT SETB  (0)
&#ENTPLI SETB  (0)
&#ENTNUN SETB  (0)
&C1      SETA  11
.*                                                            06/84 DBC
         AIF   ('&SAVTYPE' NE 'NONE').TYPNNON                 06/84 DBC
&#ENTNUN SETB  (1)                                            06/84 DBC
         AGO   .PFXTST                                        06/84 DBC
.TYPNNON ANOP                                                 06/84 DBC
.*                                                            06/84 DBC
         AIF   ('&SAVTYPE(1)' NE 'RENT').TYPNRNT
&#ENTRNT SETB  (1)
&#ENTSIZ SETC  '72'
&#ENTSP  SETC  ''
         #TEST DCODE=&SAVTYPE(2)
&A1      SETA  &#TESRET(1)
         AIF   (&A1 EQ 0).PFXTST
         AIF   ('&#TESRET(2)' EQ '').DFLTLEN
&#ENTSIZ SETC  '&#TESRET(2)'
.DFLTLEN AIF   (&A1 EQ 1).PFXTST
&#ENTSP  SETC  '&#TESRET(3)'
         AGO   .PFXTST
.TYPNRNT ANOP
.*
         AIF   ('&SAVTYPE(1)' NE 'REMOTE').TYPNRMT
&REMOTE(1) SETB (1)
         AIF   ('&SAVTYPE(2)' NE '').GOTRMT2
         MNOTE 12,'ERROR - SAVTYPE(2) (REMOTE AREA''S NAME) OMITTED.'
.GOTRMT2 AIF   ('&SAVTYPE(2)'(1,1) EQ '(').TYPLCL2
&REMOTE(2) SETB (1)
&RMTNAME SETC  '&SAVTYPE(2)'
         AIF   ('&SAVTYPE(2)'(K'&SAVTYPE(2),1) NE '%').PFXTST
&REMOTE(5) SETB (1)
&RMTNAME SETC  '&SAVTYPE(2)'(1,K'&SAVTYPE(2)-1)
         AGO   .PFXTST
.TYPLCL2 #TEST DCODE=&SAVTYPE(2)
&RMTREGC SETC  '&#TESRET(2)'
         #TEST REGS=&RMTREGC
         AIF   (&#TESERR NE 0).PFXTST
&RMTREGA SETA  &#TESRET(1)
         AIF   (&RMTREGA NE 13).PFXTST
&REMOTE(3) SETB (1)
         AGO   .PFXTST
.TYPNRMT ANOP
.*
         AIF   ('&SAVTYPE(1)' NE 'PLI').TYPNPLI
&#ENTPLI SETB  (1)
&C1      SETA  10
         AGO   .PFXTST
.TYPNPLI ANOP
.*
         AIF   ('&SAVTYPE(1)' EQ '' OR '&SAVTYPE(1)' EQ 'LOCAL').TYPLCL
         MNOTE 4,'SAVTYPE(1)=&SAVTYPE(1) IS INVALID.'
         MNOTE 4,'SAVTYPE(1)=LOCAL ASSUMED.'
.TYPLCL  ANOP
&LOCAL   SETB  (1)
&C1      SETA  12
&LID     SETC  'E&#.SVA'
         AIF   ('&SAVTYPE(2)' EQ '').GOTSLID
&LID     SETC  '&SAVTYPE(2)'
.GOTSLID ANOP
&SAVLEN  SETC  '72'
         AIF   ('&SAVTYPE(3)' EQ '').PFXTST
&SAVLEN  SETC  '&SAVTYPE(3)'
.*
.PFXTST  ANOP
&@       SETC  '&PFIX'
         AIF   (K'&PFIX NE 0).GOTPFIX
         #TEST PFIX=
&@       SETC  '&#TESRET(1)'
         AGO   .DONPFIX
.GOTPFIX #REGS &PFIX,GEN=NO
.DONPFIX ANOP
.*                                                            06/84 DBC
&A1      SETA  0
         AIF   ('&BASES' NE '*').BSCLR
.BSOLD   AIF   (&A1 EQ 13).BASEND
&A1      SETA  &A1+1
         AIF   ('&#BS(&A1)' EQ '').BSOLD
         #TEST REGS=&#BS(&A1)
&B(&A1)  SETA  16
         AIF   (&#TESERR NE 0).BSOLD
&B(&A1)  SETA  &#TESRET(1)
         AIF   (&B(&A1) NE 13).BSOLD
         AIF   (&A1 NE 13 OR '&#BS(14)' NE '&RMTNAME' OR &#ENTRNT OR &#*
               ENTPLI).BSERROR
&REMOTE(4) SETB (1)
         AGO   .BSOLD
.BSERROR ANOP
         MNOTE 4,'THE OLD BASE REGISTER &B(&A1) CANNOT ALSO FUNCTION'
         MNOTE 4,'AS A SAVE AREA POINTER IN THIS CONTEXT.'
         MNOTE 4,'THE CODE GENERATED BELOW WILL NOT FUNCTION CORRECTLY.*
               '
         AGO   .BSOLD
.BSCLR   AIF   (&A1 EQ 14).BSCLRD
&A1      SETA  &A1+1
&#BS(&A1) SETC ''
         AGO   .BSCLR
.BSCLRD  AIF   (K'&BASES EQ 0).BASEND
         AIF   ('&BASES' NE '&BASES(1)').TSTNBSE
         #TEST NUM=&BASES
         AIF   (&#TESERR EQ 0).BSEOKX
         MNOTE 4,'"BASES=&BASES" IS INVALID.'
         MNOTE 4,'"BASES=1" ASSUMED.'
&C3      SETA  1
         AGO   .BSESET
.BSEOKX  ANOP
&C3      SETA  &BASES
         AIF   (&C3 LE &C1).BSESET
         MNOTE 4,'"BASES=&BASES" IS OUTSIDE THE RANGE OF 0...&C1..'
         MNOTE 4,'THE CODE GENERATED BELOW WILL NOT FUNCTION CORRECTLY.*
               '
.BSESET  ANOP
&C1      SETA  &C1+1
&C3      SETA  &C1-&C3
&C4      SETA  13
.BOK     AIF   (&C1 LE &C3).BASEND
&#BS(&C4) SETC '&@&C1'
&B(&C4)  SETA  &C1
&C1      SETA  &C1-1
&C4      SETA  &C4-1
         AGO   .BOK
.TSTNBSE ANOP
&C3      SETA  N'&BASES
         AIF   (&C3 LE &C1).NBSOK
         MNOTE 4,'"BASES=&BASES" SPECIFIES TOO MAY REGISTERS.'
         MNOTE 4,'ONLY THE FIRST &C1 REGISTERS WILL BE USED.'
&C3      SETA  &C1
.NBSOK   ANOP
&C1      SETA  &C1+1
&C4      SETA  13
&C2      SETA  0
.GETBSE  AIF   (&C2 GE &C3).BASEND
&C2      SETA  &C2+1
         AIF   ('&BASES(&C2)' EQ '').IGNR
         #TEST REGS=&BASES(&C2)
&B(&C4)  SETA  16
         AIF   (&#TESERR EQ 16).REGUNK
         AIF   (&#TESRET(1) GE 2 AND &#TESRET(1) LE &C1).BSEOK2
         MNOTE 4,'"BASES(&C2)=&BASES(&C2)" IS OUTSIDE THE RANGE OF 2...*
               &C1..'
         MNOTE 4,'THE CODE GENERATED BELOW WILL NOT FUNCTION CORRECTLY.*
               '
         AGO   .BSEOK2
.IGNR    AIF   (&C3 GE N'&BASES).GETBSE
&C3      SETA  &C3+1
         AGO   .GETBSE
.BSEOK2  AIF   (NOT &REDUN(&#TESRET(1))).BSEOK3
         MNOTE 4,'"BASES(&C2)=&BASES(&C2) IS REDUNDANT.'
         MNOTE 4,'THE CODE GENERATED BELOW WILL NOT FUNCTION CORRECTLY.*
               '
.BSEOK3  ANOP
&REDUN(&#TESRET(1)) SETB (1)
&B(&C4)  SETA &#TESRET(1)
.REGUNK  ANOP
&C1      SETA  12
&#BS(&C4) SETC '&BASES(&C2)'
&C4      SETA  &C4-1
         AGO   .GETBSE
.BASEND  ANOP
.*
&R       SETC  '&@.1'
&C3      SETA  0
.WRLP    AIF   (&C3 GE 13).GOTWRG
&C3      SETA  &C3+1
         AIF   ('&#BS(&C3)' EQ '').WRLP
         AIF   (&B(&C3) EQ 13).GOTWRG
&R       SETC  '&#BS(&C3)'
.GOTWRG  ANOP
.*
&ESDT    SETC  '&ESDTYPE(1)'
         AIF   (&#ENTPLI).PLIGEN
.*
         AIF   ('&ESDT' NE 'DEFAULT').GOTESD
&ESDT    SETC  'CSECT'
.GOTESD  ANOP
&N2      SETC  '&N'
         AIF   ('&ESDT' EQ 'NONE' OR '&ESDT' EQ '' OR '&ESDT' EQ 'ENTRY*
               ').NCSCETC
         AIF   ('&ESDT' NE 'CSECT').ESDNCSC
&N       CSECT ,                   START CONTROL SECTION
         AGO   .ESDDONE
.ESDNCSC AIF   ('&ESDT' NE 'START').ESDNSTA
&N       START ,                   START CONTOL SECTION
         AGO   .ESDDONE
.ESDNSTA ANOP
&W2      SETC  '&ESDT'
&N       &W2   0H'0'               START
.ESDDONE ANOP
&N2      SETC  ''
.*
.NCSCETC AIF   ('&ESDT' NE 'ENTRY').NENTRY
         ENTRY &N                  MAKE NAME EXTERNALLY AVAILABLE
.NENTRY  ANOP
.*
         AIF   (K'&NME EQ 0 AND '&ESDT' NE 'CSECT' AND '&ESDT' NE 'STAR*
               T').NMODID
&N2      B     E&#.ZID-&N.(,&@.15) SKIP AROUND THE MODULE ID
&N2      SETC  'E&#.ZID'
         DC    AL1(&N2-E&#.MID)    LENGTH OF TEXT
E&#.MID  DC    C'&N '              ENTRY NAME
&W2      SETC  '&SYSDATE       '(1,8).' '
         DC    C'&W2'              ASSEMBLY DATE
&W2      SETC  '&SYSTIME    '(1,5)
         AIF   (K'&NME EQ 0).NMEZ1
&W2      SETC  '&W2 - '
.NMEZ1   DC    C'&W2'              ASSEMBLY TIME
         AIF   (K'&NME EQ 0).NMEZ2
         AIF   ('&NME'(1,1) EQ '''').QNME
         DC    C'&NME'
         AGO   .NMEZ2
.QNME    DC    C&NME
.NMEZ2   ANOP
.NMODID  ANOP
.*
         AIF   (&REMOTE(3)).RNTRNT1
&W2      SETC  '&@.14,&@.12,12(&@.13)'
&N2      STM   &W2                 SAVE CALLER'S REGISTERS
&N2      SETC  ''
.*
         AIF   (&#ENTRNT OR &#ENTNUN).RNTRNT1                 06/84 DBC
         LR    &R,&@.13            POINT TO HIGHER SA
         AIF   (&REMOTE(1)).LRMTSV1
&C       SETC  '&@.13,&LID-&N.(,&@.15)'                       06/84 DBC
         LA    &C                  POINT TO LOWER SA
         AGO   .LRMTSV2
.LRMTSV1 AIF   (&REMOTE(2)).LRMTSV3
         #TEST REGS=&R
         AIF   (&RMTREGA NE &#TESRET(1)).LRMTSV4
&A1      SETA  20+&RMTREGA*4-&RMTREGA/13*44
         L     &@.13,&A1.(,&@.13)  POINT TO LOWER SA
         AGO   .LRMTSV2
.LRMTSV4 LR    &@.13,&RMTREGC      POINT TO LOWER SA
         AGO   .LRMTSV2
.LRMTSV3 AIF   (&REMOTE(5)).LRMTSV5
         PUSH  USING               SAVE USING ENVIRONMENT
         USING &N,&@.15            DECLARE TEMP BASE
         LA    &@.13,&RMTNAME      POINT TO LOWER SA
         POP   USING               RESTORE USING ENVIRONMENT
         AGO   .LRMTSV2                                       06/84 DBC
.LRMTSV5 ANOP                                                 06/84 DBC
         LR    &@.13,&@.15         POINT TO LOWER SA          08/84 DBC
&C       SETC  '&@.13,E&#.SAP-&N.(,&@.15)'                    06/84 DBC
         AH    &C                                             08/84 DBC
.LRMTSV2 ST    &@.13,8(,&R)        FORWARD CHAIN THE SAVE AREAS
         ST    &R,4(,&@.13)        BACK CHAIN THE SAVE AREAS
         AIF   ('&R' NE '&@.1').RNTRNT1
         L     &@.1,24(,&@.1)      RESTORE REGISTER 1
.RNTRNT1 AIF   ('&#BS(13)' EQ '').SKIPUSE
&C1      SETA  13
         AIF   ('&BASES' NE '*').BSEADR
         AIF   (&REMOTE(4)).EQUATE
&OLDBASE SETB  (1)
&N2      LR    &#BS(13),&@.15      LOAD 1ST BASE REGISTER     08/84 DBC
&N2      SETC  ''                                             08/84 DBC
&C       SETC  '&#BS(13),E&#.BSE-&N.(,&@.15)'                 06/84 DBC
         SH    &C                                             08/84 DBC
         AGO   .EQUATE
.BSEADR  ANOP
&C2      SETA  15
&#BS(14) SETC  '&N'
         AIF   (&#ENTRNT OR &REMOTE(1) OR &#ENTNUN).FLDTST    06/84 DBC
&C2      SETA  13
&#BS(14) SETC  '&LID'
.FLDTST  AIF   (&B(13) EQ &C2).EQUATE
&N2      LR    &#BS(13),&@&C2      LOAD FIRST BASE REGISTER
&N2      SETC  ''
.EQUATE  ANOP
&W2      SETC  '&#BS(&C1)'
         AIF   (&C1 EQ 2).ENDLA
&C1      SETA  &C1-1
         AIF   ('&#BS(&C1)' EQ '').ENDLA
&N2      LA    &#BS(&C1),X'FFF'(,&W2) LOAD NEXT BASE
&N2      SETC  ''
         AGO   .EQUATE
.ENDLA   #USING
.SKIPUSE AIF   (NOT &#ENTRNT).DATACHK
&W2      SETC  ''
&TB      SETC  ''
         AIF   ('&#BS(13)' NE '').GETM2
&N2      LR    &@.14,&@.15         LOAD TEMPORARY BASE
&N2      SETC  ''
         PUSH  USING               SAVE BASES
         DROP  ,                   CLEAR BASES
         USING &N,&@.14            DECLARE TEMPORARY BASE
&TB      SETC  '-&N.(,&@.14)'
.GETM2   ANOP
&N2      L     &@.0,E&#.LEN        LOAD LENGTH (MAYBE SUBPOOL TOO)
&N2      SETC  ''
         AIF   ('&#ENTSP' EQ '' OR '&SAVTYPE(3)' EQ '').GETM4
&SPOOL   SETC  ''
         MNOTE '         GETMAIN RC,LV=(0),SP=&#ENTSP'
         GETMAIN RC,LV=(0),SP=&#ENTSP
         AGO   .GETM5
.GETM4   ANOP
&SPOOL   SETC  '&#ENTSP'
&W3      SETC  'R'
         AIF   ('&SAVTYPE(3)' EQ '').GETM4A
&W3      SETC  'RC'
.GETM4A  MNOTE '         GETMAIN &W3,LV=(0)'
         GETMAIN &W3,LV=(0)
.GETM5   AIF   ('&#BS(13)' NE '').GETM5A
         POP   USING               RESTURE BASES
.GETM5A  AIF   ('&SAVTYPE(3)' EQ '').GETM7
         LTR   &@.15,&@.15         GETMAIN OK?
         AIF   ('&SAVTYPE(3)' EQ 'RETURN').GETM8
         AIF   ('&SAVTYPE(3)'(1,1) EQ '(').GETM6
         BNZ   &SAVTYPE(3)         NO, TAKE ERROR EXIT
         AGO   .GETM7
.GETM6   #TEST DCODE=&SAVTYPE(3)
         BCR   7,&#TESRET(2)       NO, TAKE ERROR EXIT
         AGO   .GETM7
.GETM8   ANOP
&W2      SETC  'E&#.GO'
         BZ    &W2&TB              YES, PROCEED
         L     &@.14,12(,&@.13)    NO, RESTORE REGISTER
         LM    &@.0,&@.12,20(&@.13) RESTORE REGISTERS
         MVI   12(&@.13),X'FF'     SET RETURNED SIGNEL
         BR    &@.14               RETURN TO CALLER
.GETM7   ANOP
&W2      LR    &@.0,&@.1           POINT TO AREA TO CLEAR
         L     &@.1,E&#.LEN&TB     GET LENGTH TO CLEAR
         LR    &@.14,&@.0          SAVE AREA POINTER
         SLR   &@.15,&@.15         CLEAR SRC LEN AND PAD CHAR 08/85 DBC
         MVCL  &@.0,&@.14          CLEAR THE AREA (R15 SET BY GETMAIN)
         ST    &@.14,8(,&@.13)     FORWARD CHAIN THE SAVE AREAS
         ST    &@.13,4(,&@.14)     BACK CHAIN THE SAVE AREAS
         LM    &@.13,&@.1,8(&@.13) RESTORE REGS AND POINT TO LOWER SA
.DATACHK AIF   (NOT &OLDBASE AND NOT &#ENTRNT AND NOT &REMOTE(5) AND NO*
               T &LOCAL).ENDCHK
         AIF   ('&#BS(13)' EQ '').NOUSING
&N2      B     E&#.END             SKIP AROUND DATA AREA
&N2      SETC  ''
         AGO   .DFNDATA
.NOUSING ANOP
&N2      B     E&#.END-&N.(,&@.15) SKIP AROUND DATA AREA
&N2      SETC  ''
.DFNDATA ANOP                                                 08/84 DBC
.*                                                            08/84 DBC
         AIF   (NOT &OLDBASE).NOLDBSE                         08/84 DBC
E&#.BSE  DC    Y(&N-&#BS(14))       OLD BASE ADDRESS          08/84 DBC
.NOLDBSE ANOP                                                 08/84 DBC
.*                                                            08/84 DBC
         AIF   (NOT &#ENTRNT).NLENGTH                         08/84 DBC
         AIF   ('&SPOOL' EQ '').NSUBPOO
         AIF   (&ALIGND).ALIGND1
         DS    0F                  ALIGNMENT
&ALIGND  SETB  (1)
.ALIGND1 ANOP
E&#.LEN  DC    AL1(&SPOOL),AL3(&#ENTSIZ) SAVE AREA SUBPOOL AND LENGTH
         AGO   .NLENGTH
.NSUBPOO ANOP
E&#.LEN  DC    A(&#ENTSIZ)         SAVE AREA LENGTH
&ALIGND  SETB  (1)
.NLENGTH AIF   (&#ENTRNT OR &#ENTNUN).NSVAREA                 06/84 DBC
         AIF   (&REMOTE(1)).RMTSVPT
         AIF   (&ALIGND).ALIGND2
         DS    0F                  ALIGNMENT
&ALIGND  SETB  (1)
.ALIGND2 ANOP
&LID     DC    (&SAVLEN)X'00'      LOCAL SAVE AREA
         AGO   .NSVAREA
.RMTSVPT ANOP                                                 08/84 DBC
.*                                                            08/84 DBC
         AIF   (NOT &REMOTE(5)).NSVAREA                       08/84 DBC
E&#.SAP  DC    Y(&RMTNAME-&N)       PTR TO REMOTE SA          08/84 DBC
.NSVAREA ANOP                                                 08/84 DBC
.*                                                            08/84 DBC
         AGO   .END                                           08/84 DBC
.*
.PLIGEN  AIF   ('&ESDT' EQ 'DEFAULT').PESDSET
         AIF   (K'&N GT 0 OR '&ESDT' NE 'ENTRY').PESDOK1
         MNOTE 4,'"ESDTYPE=&ESDTYPE" IS INVALID WHEN THE NAME FIELD IS'
         MNOTE 4,'OMITTED FROM THE MACRO CALL.'
         MNOTE 4,'"ESDTYPE=NONE" WILL BE USED INSTEAD.'
&ESDT    SETC  'NONE'
.PESDOK1 ANOP
         AIF   ('&ESDT' EQ 'ENTRY' OR '&ESDT' EQ 'NONE' OR '&ESDT' EQ '*
               ').PESDOK
         MNOTE 4,'"ESDTYPE=&ESDTYPE" IS INVALID WHEN "SAVTYPE=PLI".'
.PESDSET ANOP
&ESDT    SETC  'ENTRY'
         AIF   (K'&N GT 0).PESDOK2
&ESDT    SETC  'NONE'
.PESDOK2 AIF   ('&ESDTYPE' EQ 'DEFAULT').PESDOK
         MNOTE 4,'"ESDTYPE=&ESDT" WILL BE USED INSTEAD.'
.PESDOK  ANOP
         AIF   ('&ESDT' NE 'ENTRY').PNOTENT
         ENTRY &N                  MAKE NAME EXTERNALLY AVAILABLE
.PNOTENT ANOP
.*
&N2      SETC  '&N'
&A1      SETA  K'&N
         AIF   (K'&NME EQ 0).GOTN2
&N2      SETC  '&NME'
&A1      SETA  K'&NME
.GOTN2   ANOP
&N2      SETC  ' '(1,1-(&A1-&A1/2*2)).'&N2'
         DS    0H                  ALIGNMENT
         DC    C'&N2'              ENTRY NAME
         DC    AL1(&A1)            LENGTH OF NAME
.*
&N1      SETC  '&N'
         AIF   (K'&N GT 0).PGOTN1
&N1      SETC  'E&#.ENT'
.PGOTN1  ANOP
         USING &N1,&@.15           DCL LOCAL BASE
&N1      STM   &@.14,&@.12,12(&@.13) SAVE CALLER'S REGISTERS
.*
         #TEST DCODE=&SAVTYPE(2)
&A1      SETA  &#TESRET(1)
&A2      SETA  120
         AIF   (&A1 EQ 0).DSALLA
         AIF   ('&#TESRET(2)' NE '&SAVTYPE(2)').DSALREG
         #TEST NUM=&#TESRET(2)
         AIF   (&#TESERR NE 0).DSALL
&A2      SETA  &#TESRET(2)
         AIF   (&A2 GE 4096-7).DSALL
         AIF   (&A2 GE 120-7).DSALLA
         MNOTE 4,'"SAVTYPE(2)=&SAVTYPE(2)" IS TOO SHORT A LENGTH.'
         MNOTE 4,'THE CODE GENERATED BELOW WILL NOT FUNCTION CORRECTLY.*
               '
.DSALLA  ANOP
         LA    &@.0,(&A2+7)/8*8    GET DESIRED DSA LENGTH
         AGO   .GOTDSAL
.DSALREG #TEST REGS=&#TESRET(2)
         AIF   (&#TESERR NE 0).DSALLR
         AIF   (&#TESRET(1) EQ 0).GOTLLR
.DSALLR  LR    &@.0,&#TESRET(2)    GET DESIRED DSA LENGTH
.GOTLLR  LA    &@.14,7             ROUND UP -
         AR    &@.0,&@.14           TO -
         OR    &@.0,&@.14            DOUBLE WORD -
         XR    &@.0,&@.14             LENGTH
         AGO   .GOTDSAL
.DSALL   ANOP
&LENGTH  SETB  (1)
         L     &@.0,E&#.LEN        GET DESIRED DSA LENGTH
.GOTDSAL ANOP
.*
         L     &@.1,76(,&@.13)     GET NXT AVAILABLE BLOCK POINTER
         ALR   &@.0,&@.1           --> PAST DESIRED AREA
         CL    &@.0,12(,&@.12)     WOULD THE ISA OVERFLOW?
         BNH   E&#.GOT             NO, PROCEED
         L     &@.15,116(,&@.12)   YES, --> SPECIAL HANDLER
         DROP  &@.15               RELEASE CLOBBERED BASE
         BASR  &@.14,&@.15         GO OBTAIN DESIRED DSA FROM ELSEWHERE
E&#.GOT  LR    &@.14,&@.1          SAVE PTR TO NEW DSA
         LR    &@.15,&@.0          SAVE HI-BYTE OF NAB POINTER REG
         SRL   &@.15,24            ISSOLATE IT
         SLL   &@.15,24            RESTORE ITS POSITION. SET MVCL
*                                  SOURCE LENGTH TO ZERO
         SR    &@.0,&@.1           GET LENGTH OF NEW DSA
         LR    &@.1,&@.0           COPY FOR MVCL SINK LENGTH
         LR    &@.0,&@.14          GET MVCL SINK POINTER
         MVCL  &@.0,&@.14          CLEAR THE NEW DSA
         OR    &@.0,&@.15          RESTORE HI-BYTE TO NAB POINTER REG
         LR    &@.1,&@.0           COPY NEXT AVAILABLE BLOCK POINTER
         L     &@.15,72(,&@.13)    GET LIBRARY WORKSPACE POINTER
         STM   &@.15,&@.1,72(&@.14) STORE INTO OUR NEW DSA
         ST    &@.5,88(,&@.14)     STORE PASSED PARAMETERS POINTER
         ST    &@.13,4(,&@.14)     BACK CHAIN THE DSA
         L     &@.1,24(,&@.13)     RESTORE PLIST POINTER
         LR    &@.13,&@.14         --> NEW DSA (R14 PURIFIED BY MVCL)
         MVI   0(&@.13),X'80'      SET FOR -
         MVI   1(&@.13),X'00'       PLI -
         MVI   86(&@.13),X'91'       ERROR -
         MVI   87(&@.13),X'C0'        HANDLING
.*
&N2      SETC  ''
         AIF   ('&#BS(13)' EQ '').PSKPUSE
&C1      SETA  13
         AIF   ('&BASES' NE '*').PBSEADR
&OLDBASE SETB  (1)
         BASR  &#BS(13),0          LOAD TEMP LOCAL BASE
         L     &#BS(13),E&#.BSE-*(,&#BS(13)) LOAD 1ST PROGRAM BASE
         AGO   .PEQUATE
.PBSEADR ANOP
&N2      SETC  'E&#.BSE'
&#BS(14) SETC  '&N2'
         BASR  &#BS(13),0          LOAD 1ST PROGRAM BASE
.PEQUATE ANOP
&W2      SETC  '&#BS(&C1)'
&C1      SETA  &C1-1
         AIF   (&C1 EQ 1 OR '&#BS(&C1)' EQ '').PENDLA
&N2      LA    &#BS(&C1),X'FFF'(,&W2) LOAD NEXT PROGRAM BASE
&N2      SETC  ''
         AGO   .PEQUATE
.PENDLA  #USING ,
.PSKPUSE ANOP
.*
         AIF   (NOT &LENGTH AND NOT &OLDBASE).ENDCHK
         AIF   ('&#BS(13)' NE '').PGOTBAS
&N2      BASR  &@.15,0             LOAD TEMP BASE
&N2      SETC  ''
         B     E&#.END-*(,&@.15)   SKIP DATA AREA
         AGO   .PDFNDAT
.PGOTBAS ANOP
&N2      B     E&#.END             SKIP DATA AREA
&N2      SETC  ''
.PDFNDAT AIF   (NOT &LENGTH).PNOLEN
E&#.LEN  DC    A((&SAVTYPE(2)+7)/8*8) DESIRED DSA LENGTH
.PNOLEN  AIF   (NOT &OLDBASE).PNOOBAS
E&#.BSE  DC    A(&#BS(14))         OLD BASE ADDRESS
.PNOOBAS ANOP
.*
.END     ANOP
E&#.END  DS    0H
.ENDCHK  AIF   ('&N2' EQ '').MEND
&N2      DS    0H
.MEND    MEND
         MACRO
&NME     #EXIT &R,&PFIX=,&RC=,&MODE=LEAVE                     DBC 04/85
.*
.*
.*                                                            DBC 04/85
.* LAST CHANGE DATE - APRIL 29, 1985                          DBC 04/85
.*                  - ADDED SUPPORT FOR THE "MODE=" OPERAND.  DBC 04/85
.*                                                            DBC 10/84
.* LAST CHANGE DATE - OCTOBER 1, 1984                         DBC 10/84
.*                  - DELETED CODE THAT SET A X'FF' "RETURN   DBC 10/84
.*                    INDICATOR" IN THE HI-BYTE OF DSAR14.    DBC 10/84
.*                    IT WAS NOT APPROPRIATE FOR MVS/XA.      DBC 10/84
.*                                                            DBC 06/84
.* LAST CHANGE DATE - JUNE 11, 1984                           DBC 06/84
.*                  - ADDED SUPPORT FOR "SAVTYPE=NONE" ON THE DBC 06/84
.*                    #ENTER MACRO.                           DBC 06/84
.*                  - FOR REENTRANT EXIT LINKAGE, CHANGED     DBC 06/84
.*                    THE FREEMAIN SO THAT IT WOULD NO        DBC 06/84
.*                    LONGER GENERATE AN INLINE PLIST.        DBC 06/84
.*
.* LAST CHANGE DATE - OCTOBER 18, 1983
.*                  - MAILING ADDRESS CHANGE
.*
.* LAST CHANGE DATE - APRIL 21, 1981
.*                  - CHANGE THE MACRO NAME FROM $EXIT TO #EXIT
.*
.* LAST CHANGE DATE - APRIL 15, 1981
.*                  - ADDED EXIT LINKAGE FOR A PLI ENVIRONMENT.
.*                  - "#REGS GEN=NO" SUPPORT ADDED.
.*
.* LAST CHANGE DATE - OCTOBER 3, 1978
.*                  - FOR REENTRANT SAVE AREAS, THE FREEMAIN HAS BEEN
.*                    CHANGED SO THAT MORE THAN 4K CAN BE FREED.
.*
.* LAST CHANGE DATE - FEBRUARY 2, 1977
.*                  - MAILING ADDRESS CHANGE.
.*
.* LAST CHANGE DATE - FEBRUARY 10, 1976
.*
.* THIS MACRO WAS WRITTEN BY DAVID B. COLE.  ANY QUESTIONS CONCERNING
.* IT MAY BE ADDRESSED TO:
.*       RR#2 BOX 712
.*       AFTON, VA. 22920
.*
.*
.*
.*   THIS MACRO GENERATES EITHER OS STANDARD OR PLI STANDARD EXIT
.* LINKAGE. IT WAS WRITTEN TO PROVIDE A SIMPLE, FLEXIBLE, AND COMPLETE
.* METHOD FOR GENERATING SUCH LINKAGE. IN ADDITION, FOR ALL POSSIBLE
.* OPERAND COMBINATIONS, #EXIT WILL GENERATE THE ABSOLUTE MINIMUM
.* AMOUNT OF CODE NECESSARY.
.*
.*   THE #EXIT MACRO WILL GENERATE THE FOLLOWING:
.* - CODE TO LOAD REGISTER 13 WITH A POINTER TO THE HIGHER OS SAVE AREA
.*   OR PLI DATA STORAGE AREA
.* - CODE TO RELEASE (VIA FREEMAIN) THE LOWER SAVE AREA IF THE
.*   PRECEEDING #ENTER MACRO CALL GENERATED A REENTRANT EXPANSION
.* - CODE TO RESTORE ANY PARTICULAR SET OF REGISTERS
.* - CODE TO LOAD REGISTER 15 WITH A RETURN CODE THAT IS EITHER AN
.*   ABSOLUTE VALUE OR A VALUE PRELOADED INTO ANY REGISTER
.* - CODE TO RETURN TO THE CALLING PROGRAM VIA REGISTER 14
.*
.*   THE NAME FIELD
.* USE THIS FIELD TO ASSIGN A STATEMENT LABEL TO THE FIRST MACHINE
.* INSTRUCTION OF THE EXPANSION. IF THE NAME FIELD IS OMITTED, THEN NO
.* STATEMENT LABEL IS ASSIGNED.
.*
.*   THE FIRST POSITIONAL OPERAND
.* THIS OPERAND MUST CONSIST OF A SUB-LIST OF ANY NUMBER OF ENTRIES.
.* EACH ENTRY MAY BE EITHER A SINGLE REGISTER NAME OR A PARENTHESIZED
.* PAIR (SEPERATED BY A COMMA) OF REGISTER NAMES - E.G.
.* " (1,11,(7,9),5) ". EACH SINGLE REGISTER NAME SPECIFIES A PARTICULAR
.* REGISTER TO BE RESTORED FROM THE HIGHER SAVE AREA. EACH
.* PARENTHESIZED PAIR OF REGISTER NAMES SPECIFIES A RANGE OF REGISTERS
.* TO BE RESTORED. THUS, THE ABOVE EXAMPLE WOULD CAUSE REGISTERS 1, 5,
.* 7, 8, 9, AND 11 TO BE RESTORED.
.*   SOME NOTES AND WARNINGS:
.* - A REQUEST TO RESTORE REGISTER 13 IS MEANINGLESS AND IS IGNORED.
.* - IF REGISTER 14 IS TO BE LOADED WITH THE RETURN ADDRESS FOUND IN
.*   THE HIGHER SAVE AREA, THEN YOU MUST SPECIFICALLY REQUEST THAT IT
.*   (REGISTER 14) BE RESTORED; OTHERWISE, WHATEVER VALUE IS FOUND IN
.*   REGISTER 14 PRIOR TO THE MACRO CALL WILL BE USED FOR THE RETURN
.*   ADDRESS.
.* - TO RESTORE ALL REGISTERS FROM 14 THROUGH 12, YOU MUST CODE
.*   " ((14,12)) ". CODING " (14,12) " WILL CAUSE ONLY REGISTERS 14 AND
.*   12 TO BE RESTORED.
.* - THE NUMERIC VALUES OF ALL REGISTER NAMES USED IN THIS OPERAND MUST
.*   BE DETERMINABLE AT MACRO PASS TIME. THUS, EACH REGISTER NAME USED
.*   MUST BE EITHER A SELF-DEFINING NUMERIC OR A NAME DEFINED VIA THE
.*   #REGS MACRO.
.* - IF ONLY A SINGLE REGISTER IS TO BE RESTORED, THEN IT NEED NOT BE
.*   ENCLOSED IN PARENTHESES.
.* - IF THE FIRST POSITIONAL OPERAND IS OMITTED, THEN NO REGISTERS ARE
.*   RESTORED.
.*
.*   THE RC= OPERAND
.* THIS OPERAND MUST CONSIST OF A SINGLE VALUE EITHER WITHIN OR NOT
.* WITHIN PARENTHESES. IF ENCLOSED WITHIN PARENTHESES, THEN THE VALUE
.* IS TREATED AS THE NAME OF A REGISTER CONTAINING A RETURN CODE. IF
.* NOT ENCLOSED WITHIN PARENTHESES, THEN THE VALUE IS TREATED AS BEING
.* THE RETURN CODE ITSELF.
.*   IF THE RC= OPERAND SPECIFIES A REGISTER NAME, THEN:
.* - THE VALUE OF THAT NAME NEED NOT BE DETERMINABLE AT MACRO PASS
.*   TIME;
.* - THE REGISTER NAME MAY IDENTIFY ANY REGISTER WHATSOEVER REGUARDLESS
.*   OF WHICH REGISTERS ARE TO BE RESTORED SINCE IN CASES OF POTENTIAL
.*   CONFLICT, THE RETURN CODE IS COPIED INTO REGISTER 15 PRIOR TO
.*   REGISTER RESTORATION;
.* - IT IS ILLOGICAL FOR THE RC= OPERAND TO SPECIFY REGISTER 13.
.* NOTE THAT IF THE RC= OPERAND IS SPECIFIED BUT THE FIRST POSITIONAL
.* OPERAND INDICATES THAT REGISTER 15 IS ALSO TO BE RESTORED, THEN
.* REGISTER 15 IS NOT RESTORED. INSTEAD, IT IS LOADED WITH THE RETURN
.* CODE VALUE.
.*   IF THE RC= OPERAND IS OMITTED, THEN NO CODE IS GENERATED TO LOAD
.* REGISTER 15 WITH A RETURN CODE.
.*                                                            DBC 04/85
.*   THE MODE= OPERAND                                        DBC 04/85
.* THIS FOR MVS/XA. IT CONTROLS WHETHER OR NOT THE #EXIT      DBC 04/85
.* MACRO IS TO GENERATE CODE TO RESTORE THE CALLER'S          DBC 04/85
.* ADDRESSING MODE. THE DEFAULT IS NOT TO DO SO.              DBC 04/85
.*                                                            DBC 04/85
.* - MODE=LEAVE                                               DBC 04/85
.*   THIS IS THE DEFAULT. NO EXPLICIT ATTEMPT IS MADE TO      DBC 04/85
.*   RESTORE THE CALLER'S ADDRESSING MODE.                    DBC 04/85
.*                                                            DBC 04/85
.* - MODE=RESTORE                                             DBC 04/85
.*   THE #EXIT MACRO ATTEMPTS TO RESTORE THE CALLER'S         DBC 04/85
.*   ADDRESSING MODE BASED ON THE HI-ORDER BIT OF THE         DBC 04/85
.*   CALLER'S R14.                                            DBC 04/85
.*
.*   THE PFIX= OPERAND
.* THE #EXIT MACRO ATTEMPTS TO USE REGISTER EQUATES IN ITS EXPANSION
.* WHEN REFERING TO REGISTERS. THIS IS SO THAT THE USE OF THE REGISTERS
.* WILL BE INDICATED IN THE CROSS REFERENCE LISTING. THE PFIX= OPERAND
.* CAN BE USED TO CONTROL THE SET OF EQUATES USED. FOR EXAMPLE, IF
.* "PFIX=GPR" IS SPECIFIED, THEN "GPR1" WILL BE USED WHENEVER THE
.* EXPANSION REFERS TO REGISTER 1.
.*   IF THE PFIX= OPERAND IS OMITTED, THEN THE SET OF EQUATES DEFINED
.* BY THE FIRST PRIOR #REGS MACRO WILL BE USED. IF THERE IS NO PRIOR
.* #REGS MACRO, THEN NO EQUATES WILL BE USED.
.*
.*   CONSIDERATIONS
.* THE #EXIT MACRO WILL GENERATE AN EXPANSION THAT WILL ACCURATELY
.* RESTORE ALL DESIRED REGISTERS AND SET THE RETURN CODE REGUARDLESS OF
.* WHETHER OR NOT A FREEMAIN SVC IS ISSUED TO RELEASE THE LOWER SAVE
.* AREA AND REGUARDLESS OF THE RELATIONSHIP BETWEEN THE RC= OPERAND AND
.* THE SET OF REGISTERS RESTORED.
.*
.*
.*
.* INNER MACROS USED - #REGS #TEST AND FREEMAIN
.*
         GBLA  &#TESERR
         GBLB  &#ENTRNT,&#ENTPLI,&#ENTNUN                     DBC 06/84
         GBLC  &#TESRET(20),&#ENTSIZ,&#ENTSP
         LCLA  &C1,&R1,&R2,&W1,&W2,&ERRCODE
         LCLB  &RCLA,&RCST,&RSW(16)
         LCLC  &LNME,&@,&RG(16),&REGNME,&RG2SAVE,&RG4SAVE,&RG5SAVE
         LCLC  &C,&#                                          DBC 06/84
&#       SETC  '&SYSNDX'                                      DBC 06/84
&LNME    SETC  '&NME'
.*
&@       SETC  '&PFIX'
         AIF   (K'&PFIX NE 0).GOTPFIX
         #TEST PFIX=
&@       SETC  '&#TESRET(1)'
         AGO   .DONPFIX
.GOTPFIX #REGS &PFIX,GEN=NO
.DONPFIX ANOP
.*
&C1      SETA  0                                              DBC 06/84
.RLP     AIF   (&C1 GE N'&R).RFIN
&C1      SETA  &C1+1
         #TEST DCODE=&R(&C1)
         AIF   (&#TESERR NE 0).END
&W1      SETA  &#TESRET(1)
         AIF   (&W1 EQ 0).RLP
&REGNME  SETC  '&#TESRET(2)'
         #TEST REGS=&REGNME
&ERRCODE SETA  1
         AIF   (&#TESERR NE 0).REGERR
.REGOK1  ANOP
&R1      SETA  &#TESRET(1)
&R2      SETA  &R1+3-&R1/14*16
&RG(&R2) SETC  '&REGNME'
&RSW(&R1+1) SETB (1)
         AIF   (&W1 EQ 1).RLP
         AIF   (&W1 EQ 2).TWOND
         MNOTE 4,'"&R(&C1)" CONTAINS EXCESS INFORMATION.'
.TWOND   ANOP
&REGNME  SETC  '&#TESRET(3)'
         #TEST REGS=&REGNME
&ERRCODE SETA  2
         AIF   (&#TESERR NE 0).REGERR
.REGOK2  ANOP
&W2      SETA  &#TESRET(1)
&RSW(&W2+1) SETB (1)
.ENTLP   AIF   (&R1 EQ &#TESRET(1)).ENTEND
&R1      SETA  &R1+1
&R2      SETA  &R2+1
         AIF   (&R1 LE 15).R1OK
&R1      SETA  0
.R1OK    AIF   (&R2 LE 16).R2OK
&R2      SETA  1
.R2OK    ANOP
&RG(&R2) SETC  '&@&R1'
         AGO   .ENTLP
.ENTEND  ANOP
&RG(&R2) SETC  '&REGNME'
         AGO   .RLP
.REGERR  AIF   (&#TESRET(1) GE 0 OR &#TESRET(1) LT 0).REGVALU
         MNOTE 0,'THE ABOVE ERROR IS NOT DUE TO A BUG IN THE MACRO.'
         MNOTE 8,'THE VALUE OF "&REGNME" IS NOT DETERMINABLE.'
         MEXIT
.REGVALU AIF   (&#TESRET(1) GE 0 AND &#TESRET(1) LE 15).REGOK
         MNOTE 8,'THE VALUE OF "&REGNME" IS OUTSIDE THE RANGE OF 0 ... *
               15'
         MEXIT
.REGOK   AIF   (&ERRCODE EQ 1).REGOK1
         AGO   .REGOK2
.RFIN    AIF   (NOT &#ENTPLI).RGOK
         AIF   (NOT &RSW(1)).RG0OK
         MNOTE 4,'&RG(3) NEEDED BY THE EXIT LINKAGE - NOT RESTORED.'
.RG0OK   AIF   (NOT &RSW(2)).RG1OK
         MNOTE 4,'&RG(4) NEEDED BY THE EXIT LINKAGE - NOT RESTORED.'
.RG1OK   ANOP
&RG(3)   SETC  ''
&RG(4)   SETC  ''
.RGOK    ANOP
.*
&RG(16)  SETC  ''
.*
         AIF   (K'&RC EQ 0).NORC
&RG2SAVE SETC  '&RG(2)'
&RG(2)   SETC  ''
         AIF   ('&RG2SAVE' NE '').RG2SOK
&RG2SAVE SETC  '&@.15'
.RG2SOK  ANOP
.*
         AIF   (NOT &RSW(16)).NOPRBLM
         MNOTE 4,'&RG2SAVE SET TO THE RETURN CODE - NOT RESTORED.'
.NOPRBLM ANOP
.*
         AIF   ('&RC' EQ '&RC(1)').RCNTRG
         #TEST REGS=&RC(1)
         AIF   (&#TESERR NE 0).LOADRC
         AIF   ('&#TESRET(1)' NE '13').RCOK
         MNOTE 4,'"RC=&RC" IS ILLOGICAL.'
.RCOK    AIF   ('&#TESRET(1)' EQ '15').NORC
.LOADRC  AIF   ('&RG(1)' EQ '' OR '&RG(3)' EQ '' OR &#ENTPLI).RCLR
&RCST    SETB  (1)
         AGO   .NORC
.RCLR    ANOP
&LNME    LR    &@.15,&RC(1)        LOAD THE RETURN CODE
&LNME    SETC  ''
         AGO   .NORC
.RCNTRG  ANOP
&RCLA    SETB  (1)
         AIF   ('&RG(3)' EQ '' OR '&RG(1)' EQ '').NORC
&RG(2)   SETC  '&RG2SAVE'
.NORC    ANOP
.*
         AIF   (NOT &#ENTPLI).NOTPLI2
&LNME    LR    &@.0,&@.13          COPY OUR DSA POINTER
&LNME    SETC  ''
.NOTPLI2 ANOP
.*
         AIF   (NOT &#ENTRNT OR '&RG(4)' EQ '').NOLRR1
&LNME    LR    &@.1,&@.13          GET SAVE AREA ADDRESS FOR FREEMAIN
&LNME    SETC  ''
.NOLRR1  ANOP
.*
         AIF   (&#ENTNUN).NOLSA                               DBC 06/84
&LNME    L     &@.13,4(,&@.13)     POINT TO THE HIGHER SAVE AREA
&LNME    SETC  ''                                             DBC 06/84
.NOLSA   ANOP                                                 DBC 06/84
         AIF   (NOT &RCST).NORCST
&LNME    ST    &RC(1),16(,&@.13)   STORE THE RC FOR LATER     DBC 06/84
&LNME    SETC  ''                                             DBC 06/84
&RG(2)   SETC  '&RG2SAVE'
.NORCST  ANOP
.*
         AIF   (NOT &#ENTRNT).NTRENT
         AIF   (NOT &RCLA).RG2OK
&RG(2)   SETC  'X'
         AIF   ('&RG(1)&RG(3)' NE '').RG2OK
&RG(2)   SETC  ''
.RG2OK   ANOP
&RG4SAVE SETC  '&RG(4)'
&RG5SAVE SETC  '&RG(5)'
&RG(5)   SETC  'X'
&C1      SETA  0
.STMLP   AIF   (&C1 GE 4).STMEND
&C1      SETA  &C1+1
         AIF   ('&RG(&C1)' NE '').STMLP
&R1      SETA  &C1+13-(&C1+13)/16*16
&R2      SETA  &R1-1
&W1      SETA  &C1*4+8
.STMLP2  ANOP
&R2      SETA  &R2+1
         AIF   (&R2 LE 15).STMR2OK
&R2      SETA  0
.STMR2OK ANOP
&RG(&C1) SETC  '&@&R2'
&C1      SETA  &C1+1
         AIF   ('&RG(&C1)' EQ '').STMLP2
         AIF   (&R1 EQ &R2).ST
&C       SETC  '&@&R1,&@&R2,&W1.(&@.13)'                      DBC 06/84
&LNME    STM   &C                  SAVE AGAINST FREEMAIN      DBC 06/84
&LNME    SETC  ''                                             DBC 06/84
         AGO   .STMLP
.ST      ANOP                                                 DBC 06/84
&LNME    ST    &@&R1,&W1.(,&@.13)  SAVE AGAINST FREEMAIN      DBC 06/84
&LNME    SETC  ''                                             DBC 06/84
         AGO   .STMLP
.STMEND  ANOP
&RG(5)   SETC  '&RG5SAVE'
.GTR1M   AIF   ('&RG4SAVE' NE '').NOGTR1
&LNME    L     &@.1,8(,&@.13)      GET RSA PTR FOR FREEMAIN   DBC 06/84
&LNME    SETC  ''                                             DBC 06/84
.NOGTR1  ANOP                                                 DBC 06/84
&LNME    L     &@.0,E&#.LEN        GET RSA LEN (AND SUBPOOL)  DBC 06/84
&LNME    SETC  ''                                             DBC 06/84
         MNOTE '         FREEMAIN R,A=(1),LV=(0)'             DBC 06/84
         FREEMAIN R,A=(1),LV=(0)                              DBC 06/84
.NTRENT  ANOP
.*
&C1      SETA  0
.LMLP    AIF   (&C1 GE 16).SETRCM
&C1      SETA  &C1+1
         AIF   ('&RG(&C1)' EQ '').LMLP
&R1      SETA  &C1
&W1      SETA  &C1*4+8
.LMLP2   ANOP
&C1      SETA  &C1+1
         AIF   ('&RG(&C1)' NE '').LMLP2
         AIF   (&R1 EQ &C1-1).L
&C       SETC  '&RG(&R1),&RG(&C1-1),&W1.(&@.13)'              DBC 06/84
&LNME    LM    &C                  RESTORE REGISTERS          DBC 06/84
&LNME    SETC  ''                                             DBC 06/84
         AGO   .LMLP
.L       ANOP                                                 DBC 06/84
&C       SETC  '&RG(&R1),&W1.(,&@.13)'                        DBC 06/84
&LNME    L     &C                  RESTORE THE REGISTER       DBC 06/84
&LNME    SETC  ''                                             DBC 06/84
         AGO   .LMLP
.SETRCM  ANOP
.*
         AIF   (NOT &RCLA).RETURN
         AIF   ('&RC' EQ '0').SR
&LNME    LA    &@.15,&RC           GET THE RETURN CODE        DBC 06/84
&LNME    SETC  ''                                             DBC 06/84
         AGO   .RETURN
.SR      ANOP                                                 DBC 06/84
&LNME    SLR   &@.15,&@.15         ZERO THE RETURN CODE       DBC 06/84
&LNME    SETC  ''                                             DBC 06/84
.RETURN  ANOP
.*
         AIF   (NOT &#ENTPLI).NOTPLI3
&LNME    BASR  &@.1,&@.14          RETURN TO CALLER           DBC 06/84
         MEXIT
.NOTPLI3 ANOP
.*
         AIF   ('&MODE '(1,1) EQ 'R').RETBSM                  DBC 04/85
         AIF   ('&MODE '(1,1) EQ 'L').RETBR                   DBC 04/85
         MNOTE 8,'"MODE=&MODE" NOT RECOGNIZED.'               DBC 04/85
         MNOTE *,'"MODE=RESTORE" OR "MODE=LEAVE" WAS EXPECTED.' C 04/85
.*                                                            DBC 04/85
.RETBR   ANOP                                                 DBC 04/85
&LNME    BR    &@.14               RETURN                     DBC 10/84
&LNME    SETC  ''                                             DBC 04/85
         AGO   .MODEZ                                         DBC 04/85
.RETBSM  ANOP                                                 DBC 04/85
&LNME    BSM   0,&@.14             RESTORE AMODE AND RETURN   DBC 04/85
&LNME    SETC  ''                                             DBC 04/85
.MODEZ   ANOP                                                 DBC 04/85
.*                                                            DBC 06/84
         AIF   (NOT &#ENTRNT).END                             DBC 06/84
         AIF   ('&#ENTSP' EQ '').NOSPOOL                      DBC 06/84
         DS    0F                  ALIGN                      DBC 06/84
&C       SETC  'AL1(&#ENTSP),AL3(&#ENTSIZ)'                   DBC 06/84
E&#.LEN  DC    &C                  RSA SUBPOOL AND LENGTH     DBC 06/84
         MEXIT                                                DBC 06/84
.NOSPOOL ANOP
E&#.LEN  DC    A(&#ENTSIZ)         RSA LENGTH                 DBC 06/84
.END     MEND
         MACRO
&NME     #PUT  &MSG,&PFIX=,&SUBAD=,&MF=
.*
.*
.*
.* LAST CHANGE DATE - OCTOBER 18, 1983
.*                  - MAILING ADDRESS CHANGE
.*
.* LAST CHANGE DATE - APRIL 21, 1981
.*                  - MACRO NAME CHANGED FROM $PUT TO #PUT.
.*
.* LAST CHANGE DATE - APRIL 20, 1981
.*                  - "#REGS GEN=NO" SUPPORT ADDED.
.*
.* LAST CHANGE DATE - JULY 18, 1980
.*                  - INDIRECT ADDRESSING IS NOW INDICATED BY A
.*                    TRAILING PERCENT SIGN (%) RATHER THAN A LEADING
.*                    ONE.
.*
.* LAST CHANGE DATE - JANUARY 12, 1977
.*                  - HANDLING OF THE SUBAD= OPERAND IS REWRITTEN.
.*                  - MAILING ADDRESS CHANGE.
.*
.* THIS MACRO WAS WRITTEN BY DAVID B. COLE. ANY QUESTIONS CONCERNING
.* IT MAY BE ADDRESSED TO:
.*       RR#2 BOX 712
.*       AFTON, VA. 22920
.*
         GBLA  &#TESERR
         GBLC  &#PUTSUB
         GBLC  &#TESRET(20)
         LCLA  &A1
         LCLC  &@,&C1,&N
         AIF   ('&SUBAD' EQ '').SUBOK
         AIF   ('&SUBAD(1)' NE '&SUBAD').SUBOK
&#PUTSUB SETC  '&SUBAD'
.SUBOK   AIF   ('&MF(1)' EQ 'INIT').MEND
&N       SETC  '&NME'
.*
&@       SETC  '&PFIX'
         AIF   ('&PFIX' NE '').PFIXOK
         #TEST PFIX=
&@       SETC  '&#TESRET(1)'
         AGO   .DONPFIX
.PFIXOK  #REGS &PFIX,GEN=NO
.DONPFIX ANOP
.*
         AIF   ('&MSG(1)' EQ '&MSG').NOTREG
         #TEST REGS=&MSG(1)
         AIF   (&#TESERR NE 0).LR
         AIF   (&#TESRET(1) EQ 1).BAL
.LR      ANOP
&N       LR    &@.1,&MSG(1)        --> MESSAGE LENGTH FIELD
&N       SETC  ''
         AGO   .BAL
.NOTREG  AIF   ('&MSG' EQ '').BAL
         AIF   ('&MSG'(K'&MSG,1) EQ '%').MSGINDR
&N       LA    &@.1,&MSG-1         --> MESSAGE LENGTH FIELD
         AGO   .MSGOK
.MSGINDR ANOP
&C1      SETC  '&MSG'(1,K'&MSG-1)
&N       L     &@.1,=A(&C1-1)      --> MESSAGE LENGTH FIELD
.MSGOK   ANOP
&N       SETC  ''
.BAL     AIF   ('&SUBAD(1)' NE '&SUBAD').BALR
         AIF   ('&#PUTSUB'(1,1) EQ '%').BALINDR
&N       BAS   &@.14,&#PUTSUB      GO DISPLAY THE MESSAGE
         AGO   .MEND
.BALR    ANOP
&N       BASR  &@.14,&SUBAD(1)     GO DISPLAY THE MESSAGE
         AGO   .MEND
.BALINDR ANOP
&A1      SETA  0
.LP1     ANOP
&A1      SETA  &A1+1
         AIF   ('&#PUTSUB'(1,&A1) NE '&#PUTSUB').LP1
&C1      SETC  '&#PUTSUB'(2,&A1-1)
&N       L     &@.15,=A(&C1)       --> MESSAGE PRINTING ROUTINE
         BASR  &@.14,&@.15         GO DISPLAY THE MESSAGE
.MEND    MEND
         MACRO
         #REGS &GEN=YES
.*
.*
.*                                                            09/84 DBC
.* LAST CHANGE DATE - SEPTEMBER 11, 1984                      09/84 DBC
.*                  - ADDED SUPPORT FOR PL/S STYLE REGISTER   09/84 DBC
.*                    NAMES (@00, @01, ---, @15).             09/84 DBC
.*                  - ATTEMPTS TO MULTIPLY DEFINE THE SAME    09/84 DBC
.*                    NAME TO THE SAME VALUE WILL NOW BE      09/84 DBC
.*                    SUPPRESSED WITHOUT ERROR.               09/84 DBC
.*
.* LAST CHANGE DATE - OCTOBER 18, 1983
.*                  - MAILING ADDRESS CHANGE
.*
.* LAST CHANGE DATE - APRIL 21, 1981
.*                  - MACRO NAME CHANGED FROM $REGS TO #REGS
.*
.* LAST CHANGE DATE - APRIL 20, 1981
.*                  - SUPPORT FOR THE "GEN={YESNO}" OPERAND IS ADDED.
.*
.* LAST CHANGE DATE - DECEMBER 5, 1977
.*                  - SINGLE REGISTER EQUATES NOW LINE UP CORRECTLY IN
.*                    THE LISTING.
.*
.* LAST CHANGE DATE - FEBRUARY 2, 1977
.*                  - MAILING ADDRESS CHANGE.
.*
.* LAST CHANGE DATE - APRIL 1, 1975
.*
.* THIS MACRO WAS WRITTEN BY DAVID B. COLE.  ANY QUESTIONS CONCERNING
.* IT MAY BE ADDRESSED TO:
.*       RR#2 BOX 712
.*       AFTON, VA. 22920
.*
.*
.*
.*   THE #REGS MACRO HAS TWO FUNCTIONS. ITS PRIMARY
.* PURPOSE IS TO PROVIDE A SIMPLE MEANS OF DEFINING SETS
.* OF REGISTER NAME EQUATES. ITS SECONDARY PURPOSE IS TO
.* CREATE AN INTERNAL TABLE OF ALL REGISTER NAMES
.* COUPLED WITH THEIR NUMERIC VALUES. THIS TABLE IS THEN
.* MADE AVAILABLE TO CERTAIN OTHER MACROS (E.G. #ENTER
.* AND #EXIT) SO THAT THEY CAN DETERMINE (IF NECESSARY)
.* THE VALUES OF ANY REGISTER NAMES THAT MIGHT BE PASSED
.* TO THEM AS OPERANDS AND SO THAT THEY CAN USE REGISTER
.* NAME EQUATES INSTEAD OF REGISTER NUMBERS IN THE CODE
.* THAT THEY GENERATE. THIS IS SO THAT ALL REFERENCES TO
.* REGISTERS WILL BE INDICATED IN THE ASSEMBLER'S CROSS
.* REFERENCE LISTING.
.*                                                            09/84 DBC
.*   THE #REGS MACRO CAN BE USED ANY NUMBER OF TIMES IN
.* AN ASSEMBLY. EACH TIME THAT IT IS USED, IT CAN BE
.* GIVEN ANY NUMBER OF POSITIONAL OPERANDS. EACH OPERAND      09/84 DBC
.* CAN BE EITHER A SINGLE TERM OR A SUB-LIST OF TWO
.* TERMS.
.*                                                            09/84 DBC
.*   IF AN OPERAND IS A SUB-LIST OF TWO TERMS, THEN THE
.* #REGS MACRO TREATS IT AS A REQUEST TO DEFINE A SINGLE
.* REGISTER NAME AND IT GENERATES A STATEMENT OF THE
.* FORM: " TERM1 EQU TERM2 ". THE FIRST TERM MUST BE ANY
.* VALID NAME NOT PREVIOUSLY DEFINED. THE SECOND TERM
.* MUST BE ANY SELF-DEFINING TERM OR ANY REGISTER NAME
.* THAT HAS BEEN PREVIOUSLY DEFINED BY THIS OR A
.* PREVIOUS #REGS MACRO. IT SHOULD NOT BE AN EXPRESSION,
.* AND IT SHOULD NOT BE ANY NAME NOT PREVIOUSLY DEFINED.
.* THE VALUE OF THE SECOND TERM SHOULD FALL IN THE RANGE
.* OF 0 THROUGH 15. IF THE SECOND TERM FITS THESE
.* REQUIREMENTS, THEN THE REGISTER NAME IS SAVED IN AN
.* INTERNAL TABLE FOR USE BY OTHER MACROS.
.*                                                            09/84 DBC
.*   IF AN OPERAND IS ONLY A SINGLE TERM, THEN THE MACRO
.* TREATS IT AS A REQUEST TO DEFINE A FULL SET OF
.* REGISTER NAME EQUATES WITH THE GIVEN TERM USED AS THE
.* REGISTER NAME PREFIX. AS AN EXAMPLE, ASSUME THAT THE
.* OPERAND IS "GPR". IN THIS CASE, THE #REGS MACRO WILL
.* GENERATE EQUATES DEFINING GPR0, GPR1, ---, GPR15 AND
.* GPRA, GPRB, ---, GPRF (EQUAVALENT TO GPR10, GPR11,
.* ---, GPR15). IN ADDITION, THE GENERATED REGISTER
.* NAMES ARE SAVED IN AN INTERNAL TABLE FOR USE BY OTHER
.* MACROS.
.*                                                            09/84 DBC
.*   A SPECIAL CASE. IF THE SINGLE TERM IS AN "AT SIGN"       09/84 DBC
.* (@), THEN THEN THE GENERATED NAMES WILL BE @00, @01,       09/84 DBC
.* ---, @15. THIS CONFORMS TO PL/S CONVENTIONS.               09/84 DBC
.*                                                            09/84 DBC
.*   IF #REGS IS CALLED WITHOUT OPERANDS, THEN IT IS
.* TREATED AS A REQUEST TO GENERATE A FULL SET OF
.* EQUATES USING "R" AS THE PREFIX.
.*
.*
.*
.* GEN={YESNO}    (DEFAULT IS GEN=YES)
.*       THIS CONTROLS WHETHER OR NOT THIS MACRO ACTUALLY GENERATES THE
.*       'EQU' STATEMENTS THAT CREATE THE DESIRED REGISTER NAMES. IF
.*       "GEN=NO" IS GIVEN, THEN PRESUMEDLY THE DESIRED NAMES ARE
.*       GENERATED ELSEWHERE. IN THIS CASE THE ONLY FUNCTION PERFORMED
.*       BY THIS MACRO IS TO UPDATE INTERNAL TABLES.
.*
.*
.*
.* INNER MACROS USED - #TEST
.*
         GBLA  &#REGVAL(255)
         GBLA  &#TESERR
         GBLC  &#REGNME(255)
         GBLC  &#TESRET(20)
         LCLA  &ARG,&CTR,&NEXT,&A1
         LCLB  &B1
         LCLC  &LPFX,&C1
&NEXT    SETA  0
.LP1     AIF   (&NEXT GE 255).END1
&NEXT    SETA  &NEXT+1
         AIF   ('&#REGNME(&NEXT)' NE '').LP1
&NEXT    SETA  &NEXT-1
.END1    ANOP
&ARG     SETA  0
.LP2     AIF   (&ARG GE N'&SYSLIST).DONE
&ARG     SETA  &ARG+1
         AIF   (N'&SYSLIST(&ARG) EQ 0).LP2
         AIF   (&NEXT LT 255).NOTFULL
         MNOTE 4,'THE REGISTER NAME SAVE TABLE IS FULL.'
         MNOTE 4,'THE MAXIMUM CAPACITY IS 255 ENTRIES.'
.NOTFULL ANOP
&C1      SETC  '&SYSLIST(&ARG,1)'
         AIF   (N'&SYSLIST(&ARG) GE 2).ONEREG
.NULL    ANOP
&B1      SETB  (1)
         #TEST PFIX=
&LPFX    SETC  '&#TESRET(1)'
.*                                                            09/84 DBC
         AIF   ('&C1' NE '@').NOT@                            09/84 DBC
&CTR     SETA  0-1                                            09/84 DBC
.LP@     AIF   (&CTR EQ 15).END@                              09/84 DBC
&CTR     SETA  &CTR+1                                         09/84 DBC
&C1      SETC  '0&CTR'                                        09/84 DBC
&C1      SETC  '&C1'(K'&C1-1,2)                               09/84 DBC
         #REGS (@&C1,&LPFX&CTR)                               09/84 DBC
         AGO   .LP@                                           09/84 DBC
.END@    AIF   (&NEXT GE 255).LP2                             09/84 DBC
&NEXT    SETA  &NEXT+1                                        09/84 DBC
         AIF   ('&#REGNME(&NEXT)' NE '').END@                 09/84 DBC
&NEXT    SETA  &NEXT-1                                        09/84 DBC
         AGO   .LP2                                           09/84 DBC
.NOT@    ANOP                                                 09/84 DBC
.*                                                            09/84 DBC
&CTR     SETA  0
.LP2A    AIF   (&CTR GE &NEXT).PXSAVE
&CTR     SETA  &CTR+1
         AIF   (&#REGVAL(&CTR) LT 16 OR '&#REGNME(&CTR)' NE '&C1').LP2A
         AGO   .LP2                                           09/84 DBC
.PXSAVE  AIF   (&NEXT GE 255).NOSAVE1                         09/84 DBC
&NEXT    SETA  &NEXT+1
&#REGNME(&NEXT) SETC '&C1'
&#REGVAL(&NEXT) SETA 16
.NOSAVE1 AIF   ('&GEN(1)'(1,1) NE 'Y').LP2
&CTR     SETA  0
.LP3     AIF   (&CTR GT 15).HEX
&C1&CTR  EQU   &LPFX&CTR
&CTR     SETA  &CTR+1
         AGO   .LP3
.HEX     ANOP
&C1.A    EQU   &C1.10
&C1.B    EQU   &C1.11
&C1.C    EQU   &C1.12
&C1.D    EQU   &C1.13
&C1.E    EQU   &C1.14
&C1.F    EQU   &C1.15
         AGO   .LP2
.ONEREG  ANOP
&B1      SETB  (1)
         AIF   (N'&SYSLIST(&ARG) EQ 2).NOXCESS
         MNOTE 4,'"&SYSLIST(&ARG)" CONTAINS EXCESS INFORMATION.'
         MNOTE 4,'THE EXCESS WILL BE IGNORED.'
.NOXCESS #TEST REGS=&SYSLIST(&ARG,2)
         AIF   (&#TESERR EQ 0).REGOK
         MNOTE 4,'THE VALUE OF "&SYSLIST(&ARG,2)" IS NOT DETERMINABLE.'
         AGO   .REGEQU
.REGOK   ANOP                                                 09/84 DBC
&A1      SETA  &#TESRET(1)
&CTR     SETA  0
.LP3A    AIF   (&CTR GE &NEXT).RGSAVE
&CTR     SETA  &CTR+1
         AIF   (&#REGVAL(&CTR) NE &A1 OR '&#REGNME(&CTR)' NE '&C1').LP3*
               A
         AGO   .LP2                                           09/84 DBC
.RGSAVE  AIF   (&NEXT GE 255).REGEQU                          09/84 DBC
&NEXT    SETA  &NEXT+1
&#REGNME(&NEXT) SETC '&C1'
&#REGVAL(&NEXT) SETA &A1
.REGEQU  AIF   ('&GEN(1)'(1,1) NE 'Y').LP2
&C1      EQU   &SYSLIST(&ARG,2)
         AGO   .LP2
.DONE    ANOP
&C1      SETC  'R'
         AIF   (NOT &B1).NULL
         MEND
         MACRO
&N       #TEST &DCODE=OMITTED,&MEXCL=,&NUM=OMITTED,                    *
               &PFIX=OMITTED,&REGS=,&SIZE=,&GEN=
.*
.*
.*
.* LAST CHANGE DATE - OCTOBER 18, 1983
.*                  - MAILING ADDRESS CHANGE
.*
.* LAST CHANGE DATE - MARCH 16, 1983
.*                  - COMMENTARY CHANGES
.*                  - MAILING ADDRESS CHANGE
.*
.* LAST CHANGE DATE - DECEMBER 4, 1981
.*                  - THE "SIZE=" FUNCTION HAS BEEN ENHANCED
.*                    TO INCLUDE SUPPORT FOR THE "NE"
.*                    RELATION.
.*
.* LAST CHANGE DATE - APRIL 21, 1981
.*                  - MACRO NAME CHANGED FROM $TEST TO #TEST
.*
.* LAST CHANGE DATE - APRIL 15, 1981
.*                  - THE "NUM" FUNCTION NO LONGER ISSUES AN
.*                    ERROR MESSAGE WHEN IT ENCOUNTERS A
.*                    NON-DIGIT. IT ONLY SETS A RETURN CODE
.*                    OF 16 IN &#TESERR.
.*
.* LAST CHANGE DATE - APRIL 24, 1978
.*                    THE GEN=EBCDIC FUNCTION HAS BEEN ADDED
.*
.* LAST CHANGE DATE - FEBRUARY 2, 1977
.*                  - MAILING ADDRESS CHANGE.
.*
.* LAST CHANGE DATE - SEPTEMBER 10, 1976
.*                    THE &SIZE= OPERAND SUPPORT IS CHANGED
.*                    TO REQUIRE THREE SUB-OPERANDS WITH THE
.*                    SECOND SPECIFYING ONE OF THE RELATION
.*                    OPERATIONS: LT, LE, EQ, GE, OR GT.
.*                    NOTE, THIS IS NOT COMPATIBLE WITH THE
.*                    PREVIOUS IMPLEMENTATION.
.*
.* LAST CHANGE DATE - FEBRUARY 10, 1976
.*
.* THIS MACRO WAS WRITTEN BY DAVID B. COLE.  ANY QUESTIONS
.* CONCERNING IT MAY BE ADDRESSED TO:
.*       RR#2 BOX 712
.*       AFTON, VA. 22920
.*
.*
.*
.*                                 GENERAL INFORMATION
.*   THE #TEST MACRO IS INTENDED TO BE USED AS AN INNER
.* MACRO. IT PERFORMS A NUMBER OF DIFFERENT TESTS AND
.* MANIPULATIONS WHICH ARE WHOLELY INDEPENDANT OF EACH OTHER.
.* FOR EACH OF THESE FUNCTIONS, INPUT MIGHT BE SPECIFIED
.* EITHER VIA MACRO OPERANDS OR BOTH MACRO OPERANDS AND GLOBAL
.* SYMBOLS (DEPENDING UPON THE FUNCTION). OUTPUT IS USUALLY
.* COMMUNICATED VIA THE GLOBAL SYMBOLS &#TESERR AND &#TESRET.
.*   &#TESERR IS A SCALER SETA SYMBOL WHICH IS USED IN A
.* MANNER SIMILAR TO A PROGRAM'S COMPLETION CODE TO
.* COMMUNICATE A GROSS INDICATION OF AN UNUSUAL OR ERROR
.* CONDITION. IF UPON RETURN FROM #TEST &#TESERR EQUALS ZERO,
.* THEN THE MACRO FUNCTIONED "OK"; OTHERWISE, THE VALUE OF
.* &#TESERR VARIES DIRECTLY WITH THE SERIOUSNESS OF THE
.* UNUSUAL OR ERROR CONDITION, AND IT IS ALWAYS SET TO
.* REFLECT THE MOST SERIOUS CONDITION ENCOUNTERED DURING A
.* PARTICULAR INVOCATION OF THE #TEST MACRO.
.*   &#TESRET IS A SETC ARRAY WHICH IS USED TO CONTAIN
.* RETURN VALUES FOR THOSE FUNCTIONS FOR WHICH RETURN
.* VALUES ARE APPROPIATE. EACH ELEMENT OF THE ARRAY HOLDS ONE
.* RETURN VALUE. ONLY AS MANY ELEMENTS ARE USED AS ARE
.* NEEDED. THOSE ELEMENTS USED ALWAYS START WITH ELEMENT
.* NUMBER ONE. IF TWO OR MORE TEST FUNCTIONS ARE INVOKED ON
.* A SINGLE CALL AND IF EACH OF THEM GENERATE ONE OR MORE
.* RETURN VALUES, THEN THE FIRST FUNCTION PROCESSED WILL USE
.* THE LOW ORDER ENTRIES IN &#TESRET. THE NEXT FUNCTION WILL
.* USE THE NEXT ENTRIES, ETC. THE VARIOUS TEST FUNCTIONS
.* WILL ALWAYS BE PROCESSED IN THE SAME ORDER WITH WHICH
.* THEY APPEAR BELOW.
.*
.*
.*
.* INNER MACROS USED - NONE
.*
         GBLA  &#REGVAL(255),&#TESERR
         GBLC  &#REGNME(255),&#TESRET(20)
         GBLC  &#EBCDIC(256)
         LCLA  &CTR,&RETPTR,&P,&L,&K,&A1,&A2,&RV(22)
         LCLB  &MESW
         LCLC  &RN(22),&BASE
&#TESERR SETA  0
.*
.*
.*
.*                                 THE "DCODE" FUNCTION
.*   THIS FUNCTION WAS WRITTEN BECAUSE THE MACRO LANGUAGE
.* DOES NOT SUPPORT THE DECODING OF "SUB-SUB-LIST" NOTATION.
.*   THE INPUT IS COMMUNICATED VIA THE "DCODE=" OPERAND AS A
.* CHARACTER STRING TO BE DECODED. THIS STRING MUST BE
.* EITHER NULL, UNPARENTHESIZED, OR A PARENTHESIZED LIST OF
.* ELEMENTS SEPERATED FROM EACH OTHER BY COMMAS. THE
.* ELEMENTS THEMSELVES MAY BE NULL.
.*   FOR A STRING OF N ELEMENTS, THE OUTPUT CONSISTS OF N+1
.* ENTRIES IN &#TESRET. THE FIRST ENTRY CONTAINS THE VALUE
.* N. THE REMAINING ENTRIES CONTAIN EACH OF THE ELEMENTS
.* EXTRACTED FROM THE ORIGINAL STRING. IF THE ORIGINAL
.* STRING IS NULL, THEN IT IS TREATED AS A SUB-LIST
.* CONTAINING ZERO ELEMENTS. IF THE STRING IS
.* UNPARENTHESIZED, THEN IT IS TREATED AS A SUB-LIST
.* CONTAINING A SINGLE ELEMENT - NAMELY, ITSELF.
.*   THE DCODE FUNCTION WILL NOT PROPERLY HANDLE THE
.* FOLLOWING CONDITIONS:
.*       A.) A SUB-LIST ELEMENT LONGER THAN EIGHT CHARACTERS;
.*       B.) A SUB-LIST ELEMENT THAT ITSELF CONSISTS OF A
.*           SUB-LIST;
.*       C.) A SUB-LIST CONTAINING MORE THAN NINETEEN
.*           ELEMENTS.
.*
.DCODE   AIF   ('&DCODE' EQ 'OMITTED').DCODEND
&RETPTR  SETA  &RETPTR+1
&CTR     SETA  0
         AIF   (K'&DCODE EQ 0).DCDFIN
         AIF   ('&DCODE'(1,1) EQ '(').DCDSLST
&CTR     SETA  1
&#TESRET(&RETPTR+1) SETC '&DCODE'
         AGO   .DCDFIN
.DCDSLST ANOP
&K       SETA  K'&DCODE
         AIF   ('&DCODE'(&K,1) EQ ')').DCDOK
         MNOTE 8,'"&DCODE" HAS INVALID SUBLIST SYNTAX.'
&#TESERR SETA  16
         AGO   .DCDFIN
.DCDOK   ANOP
&P       SETA  1
&L       SETA  0
.DCDLP1  ANOP
&P       SETA  &P+&L+1
&L       SETA  0-1
&CTR     SETA  &CTR+1
&#TESRET(&RETPTR+&CTR) SETC ''
.DCDLP2  ANOP
&L       SETA  &L+1
         AIF   ('&DCODE'(&P+&L,1) NE ',' AND &P+&L NE &K).DCDLP2
         AIF   (&L EQ 0).DCDLPET
&#TESRET(&RETPTR+&CTR) SETC '&DCODE'(&P,&L)
         AIF   ('&#TESRET(&RETPTR+&CTR)' EQ '&DCODE'(&P,&L)).DCDLPET
         MNOTE 8,'ERROR - THE FOLLOWING TRUNCATION HAS OCCURED:'
         MNOTE *,'        &DCODE'
         MNOTE *,'        &#TESRET(&RETPTR+&CTR)'
.DCDLPET AIF   (&P+&L NE &K).DCDLP1
.DCDFIN  ANOP
&#TESRET(&RETPTR) SETC '&CTR'
&RETPTR  SETA  &RETPTR+&CTR
.DCODEND ANOP
.*
.*
.*
.*                            THE "MEXCL" FUNCTION
.*   THIS FUNCTION CAN BE USED TO DETERMINE IF TWO OR MORE
.* MUTUALLY EXCLUSIVE OPERANDS (OR WHATEVER) HAVE BEEN
.* PASSED TO THE CALLING MACRO.
.*   THE INPUT IS COMMUNICATED VIA THE "MEXCL=" OPERAND AS A
.* SUB-LIST WITH ANY NUMBER OF ENTRIES. IF THE MEXCL
.* FUNCTION FINDS MORE THAN ONE NON-NULL ENTRY IN THE
.* SUB-LIST, THEN IT ISSUES A SEVERITY 8 ERROR MESSAGE, AND
.* IT SETS &#TESERR TO A VALUE OF 16.
.*
.MEXCL   AIF   (N'&MEXCL LT 2).MEXCEND
&CTR     SETA  0
.MELP    AIF   (&CTR EQ N'&MEXCL).MEXCEND
&CTR     SETA  &CTR+1
         AIF   (K'&MEXCL(&CTR) EQ 0).MELP
         AIF   (&MESW EQ 1).MEERR
&MESW    SETB  (1)
         AGO   .MELP
.MEERR   MNOTE 8,'ERROR - MUTUALLY EXCLUSIVE OPERANDS HAVE BEEN USED:'
         MNOTE *,'        &MEXCL'
&#TESERR SETA  16
.MEXCEND ANOP
.*
.*
.*
.*                            THE "NUM" FUNCTION
.*   THIS FUNCTION CAN BE USED TO DETERMINE WHETHER OR NOT A
.* GIVEN VALUE CONSISTS ENTIRELY OF DIGITS.
.*   THE INPUT IS COMMUNICATED VIA THE "NUM=" OPERAND. IF
.* THE NUM FUNCTION FINDS THAT ANY CHARACTER IN THE GIVEN
.* STRING IS NOT A DIGIT, THEN IT SETS &#TESERR TO A VALUE
.* OF 16.
.*
.NUM     AIF   ('&NUM' EQ 'OMITTED').NUMEND
         AIF   (K'&NUM EQ 0).NUMERR
&CTR     SETA  0
.NUMLP   AIF   (&CTR EQ K'&NUM).NUMEND
&CTR     SETA  &CTR+1
         AIF   ('&NUM'(&CTR,1) LT '0').NUMERR
         AIF   ('&NUM'(&CTR,1) LE '9').NUMLP
.NUMERR  ANOP
&#TESERR SETA  16
.NUMEND  ANOP
.*
.*
.*
.*                            THE "PFIX" FUNCTION
.*   THIS FUNCTION CAN BE USED TO DETERMINE THE VALIDITY OF
.* A GIVEN REGISTER NAME PREFIX (E.G. "R" IN "R15").
.*   THE INPUT CONSISTS OF A REGISTER NAME PREFIX
.* COMMUNICATED VIA THE "PFIX=" OPERAND AND A TABLE OF VALID
.* REGISTER NAME PREFIXES GENERATED VIA PRIOR #REGS MACROS
.* AND CONTAINED IN THE &#REGNME AND &#REGVAL GLOBAL
.* SYMBOLS. IF THE GIVEN PREFIX IS NULL, THEN A DEFAULT IS
.* USED. IF THE GIVEN PREFIX IS INVALID, THEN A SEVERITY 4
.* ERROR MESSAGE IS ISSUED AND A DEFAULT PREFIX IS USED. THE
.* DEFAULT IS EITHER THE FIRST PREFIX DEFINED VIA A PRIOR
.* #REGS MACRO OR NULL IF NO PRIOR #REGS MACRO HAS DEFINED
.* ANY PREFIXES.
.*   FOR OUTPUT, THE NEXT AVAILABLE &#TESRET ENTRY IS FILLED
.* WITH EITHER THE GIVEN PREFIX OR THE DEFAULT PREFIX.
.*
.PFIX    AIF   ('&PFIX' EQ 'OMITTED').PFIXEND
&RETPTR  SETA  &RETPTR+1
&#TESRET(&RETPTR) SETC ''
&CTR     SETA  0
.PFXLP1  AIF   (&CTR GE 255).PFXGDEF
&CTR     SETA  &CTR+1
         AIF   ('&#REGNME(&CTR)' EQ '').PFXGDEF
         AIF   (&#REGVAL(&CTR) LE 15).PFXLP1
&#TESRET(&RETPTR) SETC '&#REGNME(&CTR)'
.PFXGDEF AIF   (K'&PFIX EQ 0).PFIXEND
&CTR     SETA  &CTR-1
.PFXLP2  AIF   (&CTR GE 255).PFXERR
&CTR     SETA  &CTR+1
         AIF   ('&#REGNME(&CTR)' EQ '').PFXERR
         AIF   (&#REGVAL(&CTR) LE 15).PFXLP2
         AIF   ('&PFIX' NE '&#REGNME(&CTR)').PFXLP2
&#TESRET(&RETPTR) SETC '&PFIX'
         AGO   .PFIXEND
.PFXERR  MNOTE 4,'WARNING - "&PFIX" HAS NOT BEEN PREDEFINED.'
         MNOTE *,'          A DEFAULT VALUE WILL BE USED.'
         MNOTE *,'          CHECK YOUR USAGE OF THE #REGS'
         MNOTE *,'          MACRO.'
.PFIXEND ANOP
.*
.*
.*
.*                            THE "REGS" FUNCTION
.*   THIS FUNCTION CAN BE USED TO CONVERT A CERTAIN CLASS OF
.* REGISTER NAMES TO THEIR CORRESPONDING NUMERIC VALUES. IN
.* ORDER FOR A GIVEN NAME TO BE CONVERTED, IT MUST BE EITHER
.* A SELF-DEFINING NUMERIC OR A NAME THAT HAS BEEN DEFINED
.* VIA A PRIOR #REGS MACRO. THE PURPOSE OF THIS FUNCTION IS
.* TO PROVIDE ARITHMETICLY MANIPULATABLE REGISTER NUMBERS.
.*   THE INPUT CONSISTS OF A SUB-LIST OF REGISTER NAMES
.* COMMUNICATED VIA THE "REGS=" OPERAND AND A TABLE OF VALID
.* REGISTER NAME PREFIXES GENERATED VIA PRIOR #REGS MACROS
.* AND COMMUNICATED VIA THE &#REGNME AND &#REGVAL GLOBAL
.* SYMBOLS.
.*   FOR A SUB-LIST OF N REGISTER NAMES, THE OUTPUT CONSISTS
.* OF N ENTRIES IN &#TESRET EACH CONTAINING THE NUMBER OF
.* THE REGISTER REPRESENTED BY THE CORRESPONDING NAME FROM
.* THE INPUT SUB-LIST.
.*   IF ANY REGISTER NAME CANNOT BE PROPERLY DECODED, THEN
.* &#TESERR IS SET TO A VALUE OF 16. NO ERROR MESSAGE IS
.* ISSUED.
.*
.REGS    AIF   (N'&REGS EQ 0).REGSEND
&CTR     SETA  0
.REGLP1  AIF   (&CTR GE 16).REGLP2
&RN(&CTR+1) SETC '&CTR'
&RV(&CTR+1) SETA &CTR
&CTR     SETA  &CTR+1
         AGO   .REGLP1
.REGLP2  AIF   (&CTR GE 22).REGND2
&CTR     SETA  &CTR+1
&RN(&CTR) SETC 'ABCDEF'(&CTR-16,1)
&RV(&CTR) SETA &CTR-7
         AGO   .REGLP2
.REGND2  ANOP
&CTR     SETA  0
.REGLP3  AIF   (&CTR GE N'&REGS).REGSEND
&CTR     SETA  &CTR+1
&RETPTR  SETA  &RETPTR+1
&#TESRET(&RETPTR) SETC ''
         AIF   (K'&REGS(&CTR) EQ 0).REGLP3
&#TESRET(&RETPTR) SETC '&REGS(&CTR)'
         AIF   (T'&REGS(&CTR) NE 'N').REGLP3A
         AIF   (&REGS(&CTR) LT 0 OR &REGS(&CTR) GT 15).REGERR
         AGO   .REGLP3
.REGLP3A ANOP
&A1      SETA  0
.REGLP4  AIF   (&A1 GE 255).REGND4
&A1      SETA  &A1+1
         AIF   ('&#REGNME(&A1)' EQ '').REGND4
         AIF   (&#REGVAL(&A1) GT 15).REGPFX
         AIF   ('&REGS(&CTR)' NE '&#REGNME(&A1)').REGLP4
&#TESRET(&RETPTR) SETC '&#REGVAL(&A1)'
         AGO   .REGLP3
.REGPFX  ANOP
&A2      SETA  0
.REGLP5  AIF   (&A2 GE 22).REGLP4
&A2      SETA  &A2+1
         AIF   ('&REGS(&CTR)' NE '&#REGNME(&A1)&RN(&A2)').REGLP5
&#TESRET(&RETPTR) SETC '&RV(&A2)'
         AGO   .REGLP3
.REGND4  ANOP
&A2      SETA  0
.REGLP6  AIF   (&A2 GE 16).REGERR
&A2      SETA  &A2+1
         AIF   ('&REGS(&CTR)' NE '&RN(&A2)').REGLP6
         AGO   .REGLP3
.REGERR  ANOP
&#TESERR SETA  16
         AGO   .REGLP3
.REGSEND ANOP
.*
.*
.*
.*                            THE "SIZE" FUNCTION
.*   THIS FUNCTION WAS WRITTEN BECAUSE OF THE LIMITATION
.* THAT MACRO CODE CANNOT ARITHMETICLY MANIPULATE OPERANDS
.* CONSISTING OF EITHER EXPRESSIONS OR EQUATE SYMBOLS.
.* BECAUSE OF THIS, IN SITUATIONS WHERE A PROGRAMMER WOULD
.* NORMALLY WANT TO USE AN EXPRESSION, ETC., HE MAY INSTEAD
.* BE FORCED TO USE A SELF DEFINING NUMERIC. THE PROBLEM IS
.* THAT IF SUBSEQUENT MODIFICATIONS AFFECT THE VALUE OF SUCH
.* AN EXPRESSION, THE PROGRAMMER MIGHT FORGET TO CHANGE THE
.* SELF DEFINING NUMERIC ACCORDINGLY. THE SIZE FUNCTION CAN
.* BE USED TO ALLEVIATE THIS PROBLEM.
.*   THE INPUT IS COMMUNICATED VIA THE "SIZE=" OPERAND AND
.* IT MUST CONSIST OF A THREE ELEMENT SUB-LIST. THE FIRST
.* AND THIRD ELEMENTS MUST BE SUCH THAT THEY RESULTS IN
.* NON-RELOCATABLE VALUES WHEN ASSEMBLED. THE SECOND OPERAND
.* MUST BE ONE OF THE FOLLOWING RELATIONAL OPERATORS:
.*       LT, LE, EQ, GE, GT, NE
.* MEANING "LESS THAN", "LESS THAN OR EQUAL", "EQUAL",
.* "GREATER THAN OR EQUAL", "GREATER THAN", AND "NOT EQUAL"
.* RESPECTIVELY.
.*   THE OUTPUT CONSISTS OF A GENERATED STATEMENT WHICH
.* PRODUCES NO OBJECT CODE BUT WHICH CAUSES AN ERROR
.* WHENEVER THE TWO GIVEN ELEMENTS VIOLATE THE INDICATED
.* RELATION.
.*
.SIZE    AIF   (N'&SIZE EQ 0).SIZEEND
         AIF   ('&SIZE(2)' EQ 'EQ' OR '&SIZE(2)' EQ 'GE' OR '&SIZE(2)' *
               EQ 'LE' OR '&SIZE(2)' EQ 'GT' OR '&SIZE(2)' EQ 'LT' OR '*
               &SIZE(2)' EQ 'NE').OPOK
         MNOTE 8,'ERROR - "&SIZE(2)" NOT A VALID RELATIONAL OPERATOR'
&#TESERR SETA  16
         AGO   .SIZEEND
.OPOK    AIF   ('&SIZE(2)' NE 'EQ').OPNTEQ
         DC    0YL2(X'7FFF'-(&SIZE(1))+&SIZE(3),X'7FFF'-(&SIZE(3))+&SIZ*
               E(1))
         AGO   .SIZEEND
.OPNTEQ  AIF   ('&SIZE(2)' NE 'NE').OPNTNE
         DC    0YL2(X'8000'-(&SIZE(3)-(&SIZE(1)))/(&SIZE(3)-(&SIZE(1)))*
               )
         AGO   .SIZEEND
.OPNTNE  ANOP
&BASE    SETC  '7FFF'
         AIF   ('&SIZE(2)'(2,1) EQ 'E').NOPLUS1
&BASE    SETC  '8000'
.NOPLUS1 AIF   ('&SIZE(2)'(1,1) EQ 'G').OPG
         DC    0YL2(X'&BASE'-(&SIZE(3))+&SIZE(1))
         AGO   .SIZEEND
.OPG     ANOP
         DC    0YL2(X'&BASE'-(&SIZE(1))+&SIZE(3))
.SIZEEND ANOP
.*
.*
.*
.*                                 THE "GEN" FUNCTION
.*    THIS FUNCTION CAN BE USED TO GENERATE VARIOUS SPECIFIC
.* OBJECTS. CURRENTLY, THE SUPPORTED OBJECTS ARE:
.*       EBCDIC - A GLOBAL TABLE CONTAINING THE ENTIRE
.*                256-ENTRY EBCDIC CHARACTER SET SUCH THAT
.*                THE VALUE OF THE ITH ENTRY IS I-1.
.*
.GEN     AIF   (N'&GEN EQ 0).GENEND
&A1      SETA  0
.GENLP   AIF   (&A1 EQ N'&GEN).GENEND
&A1      SETA  &A1+1
         AIF   ('&GEN(&A1)' EQ '').GENLP
         AIF   ('&GEN(&A1)' NE 'EBCDIC').GNTEBCD
         AIF   ('&#EBCDIC(194)' EQ 'A').GENLP
&#EBCDIC(001) SETC '
&#EBCDIC(002) SETC ''
&#EBCDIC(003) SETC ''
&#EBCDIC(004) SETC ''
&#EBCDIC(005) SETC ''
&#EBCDIC(006) SETC '	'
&#EBCDIC(007) SETC ''
&#EBCDIC(008) SETC ''
&#EBCDIC(009) SETC ''
&#EBCDIC(010) SETC ''
&#EBCDIC(011) SETC ''
&#EBCDIC(012) SETC ''
&#EBCDIC(013) SETC ''
&#EBCDIC(014) SETC ''
&#EBCDIC(015) SETC ''
&#EBCDIC(016) SETC ''
&#EBCDIC(017) SETC ''
&#EBCDIC(018) SETC ''
&#EBCDIC(019) SETC ''
&#EBCDIC(020) SETC ''
&#EBCDIC(021) SETC ''
&#EBCDIC(022) SETC '
'
&#EBCDIC(023) SETC ''
&#EBCDIC(024) SETC ''
&#EBCDIC(025) SETC ''
&#EBCDIC(026) SETC ''
&#EBCDIC(027) SETC ''
&#EBCDIC(028) SETC ''
&#EBCDIC(029) SETC ''
&#EBCDIC(030) SETC ''
&#EBCDIC(031) SETC ''
&#EBCDIC(032) SETC ''
&#EBCDIC(033) SETC ''
&#EBCDIC(034) SETC ''
&#EBCDIC(035) SETC ''
&#EBCDIC(036) SETC ''
&#EBCDIC(037) SETC ''
&#EBCDIC(038) SETC '
'
&#EBCDIC(039) SETC ''
&#EBCDIC(040) SETC ''
&#EBCDIC(041) SETC ''
&#EBCDIC(042) SETC ''
&#EBCDIC(043) SETC ''
&#EBCDIC(044) SETC ''
&#EBCDIC(045) SETC ''
&#EBCDIC(046) SETC ''
&#EBCDIC(047) SETC ''
&#EBCDIC(048) SETC ''
&#EBCDIC(049) SETC ''
&#EBCDIC(050) SETC ''
&#EBCDIC(051) SETC ''
&#EBCDIC(052) SETC ''
&#EBCDIC(053) SETC ''
&#EBCDIC(054) SETC ''
&#EBCDIC(055) SETC ''
&#EBCDIC(056) SETC ''
&#EBCDIC(057) SETC ''
&#EBCDIC(058) SETC ''
&#EBCDIC(059) SETC ''
&#EBCDIC(060) SETC ''
&#EBCDIC(061) SETC ''
&#EBCDIC(062) SETC ''
&#EBCDIC(063) SETC ''
&#EBCDIC(064) SETC ''
&#EBCDIC(065) SETC ' '
&#EBCDIC(066) SETC ''
&#EBCDIC(067) SETC ''
&#EBCDIC(068) SETC ''
&#EBCDIC(069) SETC ''
&#EBCDIC(070) SETC ''
&#EBCDIC(071) SETC ''
&#EBCDIC(072) SETC ''
&#EBCDIC(073) SETC ''
&#EBCDIC(074) SETC ''
&#EBCDIC(075) SETC ''
&#EBCDIC(076) SETC '.'
&#EBCDIC(077) SETC '<'
&#EBCDIC(078) SETC '('
&#EBCDIC(079) SETC '+'
&#EBCDIC(080) SETC ''
&#EBCDIC(081) SETC '&&'
&#EBCDIC(082) SETC ''
&#EBCDIC(083) SETC ''
&#EBCDIC(084) SETC ''
&#EBCDIC(085) SETC ''
&#EBCDIC(086) SETC ''
&#EBCDIC(087) SETC ''
&#EBCDIC(088) SETC ''
&#EBCDIC(089) SETC ''
&#EBCDIC(090) SETC ''
&#EBCDIC(091) SETC '!'
&#EBCDIC(092) SETC '$'
&#EBCDIC(093) SETC '*'
&#EBCDIC(094) SETC ')'
&#EBCDIC(095) SETC ';'
&#EBCDIC(096) SETC '^'
&#EBCDIC(097) SETC '-'
&#EBCDIC(098) SETC '/'
&#EBCDIC(099) SETC ''
&#EBCDIC(100) SETC ''
&#EBCDIC(101) SETC ''
&#EBCDIC(102) SETC ''
&#EBCDIC(103) SETC ''
&#EBCDIC(104) SETC ''
&#EBCDIC(105) SETC ''
&#EBCDIC(106) SETC ''
&#EBCDIC(107) SETC '|'
&#EBCDIC(108) SETC ','
&#EBCDIC(109) SETC '%'
&#EBCDIC(110) SETC '_'
&#EBCDIC(111) SETC '>'
&#EBCDIC(112) SETC '?'
&#EBCDIC(113) SETC ''
&#EBCDIC(114) SETC ''
&#EBCDIC(115) SETC ''
&#EBCDIC(116) SETC ''
&#EBCDIC(117) SETC ''
&#EBCDIC(118) SETC ''
&#EBCDIC(119) SETC ''
&#EBCDIC(120) SETC ''
&#EBCDIC(121) SETC ''
&#EBCDIC(122) SETC '`'
&#EBCDIC(123) SETC ':'
&#EBCDIC(124) SETC '#'
&#EBCDIC(125) SETC '@'
&#EBCDIC(126) SETC ''''''
&#EBCDIC(127) SETC '='
&#EBCDIC(128) SETC '"'
&#EBCDIC(129) SETC ''
&#EBCDIC(130) SETC 'a'
&#EBCDIC(131) SETC 'b'
&#EBCDIC(132) SETC 'c'
&#EBCDIC(133) SETC 'd'
&#EBCDIC(134) SETC 'e'
&#EBCDIC(135) SETC 'f'
&#EBCDIC(136) SETC 'g'
&#EBCDIC(137) SETC 'h'
&#EBCDIC(138) SETC 'i'
&#EBCDIC(139) SETC ''
&#EBCDIC(140) SETC ''
&#EBCDIC(141) SETC ''
&#EBCDIC(142) SETC ''
&#EBCDIC(143) SETC ''
&#EBCDIC(144) SETC ''
&#EBCDIC(145) SETC ''
&#EBCDIC(146) SETC 'j'
&#EBCDIC(147) SETC 'k'
&#EBCDIC(148) SETC 'l'
&#EBCDIC(149) SETC 'm'
&#EBCDIC(150) SETC 'n'
&#EBCDIC(151) SETC 'o'
&#EBCDIC(152) SETC 'p'
&#EBCDIC(153) SETC 'q'
&#EBCDIC(154) SETC 'r'
&#EBCDIC(155) SETC ''
&#EBCDIC(156) SETC ''
&#EBCDIC(157) SETC ''
&#EBCDIC(158) SETC ''
&#EBCDIC(159) SETC ''
&#EBCDIC(160) SETC ''
&#EBCDIC(161) SETC ''
&#EBCDIC(162) SETC '~'
&#EBCDIC(163) SETC 's'
&#EBCDIC(164) SETC 't'
&#EBCDIC(165) SETC 'u'
&#EBCDIC(166) SETC 'v'
&#EBCDIC(167) SETC 'w'
&#EBCDIC(168) SETC 'x'
&#EBCDIC(169) SETC 'y'
&#EBCDIC(170) SETC 'z'
&#EBCDIC(171) SETC ''
&#EBCDIC(172) SETC ''
&#EBCDIC(173) SETC ''
&#EBCDIC(174) SETC '['
&#EBCDIC(175) SETC ''
&#EBCDIC(176) SETC ''
&#EBCDIC(177) SETC ''
&#EBCDIC(178) SETC ''
&#EBCDIC(179) SETC ''
&#EBCDIC(180) SETC ''
&#EBCDIC(181) SETC ''
&#EBCDIC(182) SETC ''
&#EBCDIC(183) SETC ''
&#EBCDIC(184) SETC ''
&#EBCDIC(185) SETC ''
&#EBCDIC(186) SETC ''
&#EBCDIC(187) SETC ''
&#EBCDIC(188) SETC ''
&#EBCDIC(189) SETC ''
&#EBCDIC(190) SETC ']'
&#EBCDIC(191) SETC ''
&#EBCDIC(192) SETC ''
&#EBCDIC(193) SETC '{'
&#EBCDIC(194) SETC 'A'
&#EBCDIC(195) SETC 'B'
&#EBCDIC(196) SETC 'C'
&#EBCDIC(197) SETC 'D'
&#EBCDIC(198) SETC 'E'
&#EBCDIC(199) SETC 'F'
&#EBCDIC(200) SETC 'G'
&#EBCDIC(201) SETC 'H'
&#EBCDIC(202) SETC 'I'
&#EBCDIC(203) SETC ''
&#EBCDIC(204) SETC ''
&#EBCDIC(205) SETC ''
&#EBCDIC(206) SETC ''
&#EBCDIC(207) SETC ''
&#EBCDIC(208) SETC ''
&#EBCDIC(209) SETC '}'
&#EBCDIC(210) SETC 'J'
&#EBCDIC(211) SETC 'K'
&#EBCDIC(212) SETC 'L'
&#EBCDIC(213) SETC 'M'
&#EBCDIC(214) SETC 'N'
&#EBCDIC(215) SETC 'O'
&#EBCDIC(216) SETC 'P'
&#EBCDIC(217) SETC 'Q'
&#EBCDIC(218) SETC 'R'
&#EBCDIC(219) SETC ''
&#EBCDIC(220) SETC ''
&#EBCDIC(221) SETC ''
&#EBCDIC(222) SETC ''
&#EBCDIC(223) SETC ''
&#EBCDIC(224) SETC ''
&#EBCDIC(225) SETC '\'
&#EBCDIC(226) SETC ''
&#EBCDIC(227) SETC 'S'
&#EBCDIC(228) SETC 'T'
&#EBCDIC(229) SETC 'U'
&#EBCDIC(230) SETC 'V'
&#EBCDIC(231) SETC 'W'
&#EBCDIC(232) SETC 'X'
&#EBCDIC(233) SETC 'Y'
&#EBCDIC(234) SETC 'Z'
&#EBCDIC(235) SETC ''
&#EBCDIC(236) SETC ''
&#EBCDIC(237) SETC ''
&#EBCDIC(238) SETC ''
&#EBCDIC(239) SETC ''
&#EBCDIC(240) SETC ''
&#EBCDIC(241) SETC '0'
&#EBCDIC(242) SETC '1'
&#EBCDIC(243) SETC '2'
&#EBCDIC(244) SETC '3'
&#EBCDIC(245) SETC '4'
&#EBCDIC(246) SETC '5'
&#EBCDIC(247) SETC '6'
&#EBCDIC(248) SETC '7'
&#EBCDIC(249) SETC '8'
&#EBCDIC(250) SETC '9'
&#EBCDIC(251) SETC ''
&#EBCDIC(252) SETC ''
&#EBCDIC(253) SETC ''
&#EBCDIC(254) SETC ''
&#EBCDIC(255) SETC ''
&#EBCDIC(256) SETC ''
         AGO   .GENLP
.GNTEBCD MNOTE 8,'ERROR - &&GEN(&A1)=&GEN(&A1) IS UNRECOGNIZED'
         AGO   .GENLP
.GENEND  ANOP
.*
.*
.*
.END     MEND
         MACRO
         #USING &D
.*
.*
.*
.* LAST CHANGE DATE - OCTOBER 18, 1983
.*                  - MAILING ADDRESS CHANGE
.*
.* LAST CHANGE DATE - APRIL 21, 1981
.*                  - MACRO NAME CHANGED FROM $USING TO #USING.
.*
.* LAST CHANGE DATE - FEBRUARY 2, 1977
.*                  - MAILING ADDRESS CHANGE.
.*
.* LAST CHANGE DATE - AUGUST 23, 1976
.*
.* THIS MACRO WAS WRITTEN BY DAVID B. COLE. ANY QUESTIONS CONCERNING
.* IT MAY BE ADDRESSED TO:
.*       RR#2 BOX 712
.*       AFTON, VA. 22920
.*
.*
.*
.*   THIS MACRO GENERATES A USING INSTRUCTION THAT REDECLARES ALL BASES
.* (IF ANY) DECLARED BY A PRIOR #ENTER MACRO EXPANSION.
.*
.*
.*
.* INNER MACROS USED - NONE
.*
         GBLC  &#BS(14)
         LCLA  &A1,&DISPL
         AIF   ('&#BS(14)' EQ '').END
&DISPL   SETA  &DISPL-4095
&A1      SETA  14
.LP      AIF   (&A1 EQ 2).END
&A1      SETA  &A1-1
         AIF   ('&#BS(&A1)' EQ '').LP
&DISPL   SETA  &DISPL+4095
         USING &#BS(14)+&DISPL,&#BS(&A1)
         AGO   .LP
.END     MEND
