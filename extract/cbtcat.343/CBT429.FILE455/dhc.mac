DHC      TITLE '---     H E X / D E C I M A L     CALCULATOR     ---'
DHC      START 0
         SPACE 1
***********************************************************************
*                                                                     *
*        DHC TSO COMMAND : HEX/DECIMAL CALCULATOR                     *
*                                                                     *
***********************************************************************
         SPACE 1
*        OBTAINED AT AFDSC/PENTAGON FROM SHARE MODS TAPE.
*        ATTRIBUTES : RE-ENTRANT.
*        CHANGES MADE AT AFDSC/PENTAGON, 13 MAY 81.
*        USER MACROS REMOVED AND REPLACED WITH EQUIVALENT CODE.
*        INPUT TRANSLATED TO UPPER CASE.
*        DESCRIPTION PARAGRAPH ADDED.
*
* DESCRIPTION : (SEE TSO HELP FOR DETAILED DESCRIPTION)
* -------------
*
* THIS COMMAND ACCEPTS EQUATIONS AND SUBCOMMANDS. A SEMI-COLON (;) OR
* A COMMA (,) MAY BE USED TO SEPARATE INPUT EQUATIONS OR SUBCOMMANDS.
* THE CALCULATOR BEGINS IN DECIMAL MODE. ENTER A LEADING ZERO ON HEX
* VALUES SO THEY WONT BE INTERPRETED AS A SYMBOLIC NAME. ALL SYMBOLIC
* NAMES LONGER THAN 8 CHARACTERS ARE TRUNCATED WITHOUT MESSAGE.
*
*        /HEX SUBCOMMAND : PUTS THE CALCULATOR IN A MODE WHERE ALL
*              VALUES ARE ASSUMED TO BE ENTERED IN HEX, EXCEPT THOSE
*              FOLLOWED BY A PERIOD, WHICH ARE DECIMAL.
*        /DEC SUBCOMMAND : PUTS THE CALCULATOR IN A MODE WHERE ALL
*              VALUES ARE ASSUMED TO BE ENTERED IN DECIMAL, EXCEPT
*              THOSE FOLLOWED BY AN 'H', WHICH ARE HEX.
*        /LIST SUBCOMMAND : DISPLAY ALL SYMBOLS AND THEIR VALUES.
*        /SORT SUBCOMMAND : SORT AND THEN DISPLAY ALL SYMBOLS AND
*              THEIR VALUES.
*        /DELETE SUBCOMMAND : DELETE ONE OR MORE SYMBOLS AND THEIR
*              VALUES.
*        /DISP SUBCOMMAND : DISPLAY ALL EQUATIONS AS PROCESSED.
*        /NODISP SUBCOMMAND : DISPLAY ONLY THE LAST RESULT UNLESS
*              THE INPUT ENDS BY A SUBCOMMAND.
*        /HELP SUBCOMMAND : SHORT HELP.
*        /END SUBCOMMAND : TERMINATES THE CALCULATOR.
*
* SAMPLE INPUT :   /HEX
* --------------   A=10;B=10
*                  C=A+B
*                  /END
*
* MODIFIED BY :    MOINIL P.A.
* -------------    COMPUTING CENTRE
*                  J.R.C. - ISPRA ESTABLISHMENT
*                  21020 ISPRA (VA), ITALY
         EJECT
        $DEFREG
         EJECT
        $XENT  BASE=(R11,R12),LV=TSOLEN,TYPE=RENT
         LR    R10,R13             SET ADDRESSABILITY
         USING TSODSECT,R10
         EJECT
         XC    EXTR(LEXTR),EXTR
        EXTRACT ATSO,'S',FIELDS=(TSO),MF=(E,EXTR)
         L     R1,ATSO
         TM    0(R1),X'80'
         BO    OKTSO               OK, TSO ADDRESS SPACE
        WTO    ' -> ONLY TSO FOREGROUND RUN ALLOWED.',ROUTCDE=11,DESC=7
         B     TSOQUIT
OKTSO    XR    R1,R1               SET MY OWN MASK
         SPM   R1
         XC    TSTRING(L'TSTRING),TSTRING    PUT FINISHER ON
         MVC   SYMTBL(8),=CL8'*'
         LA    R2,SYMTBLI
         LA    R3,SYMTBLE-SYMTBLI
         XR    R4,R4
         LR    R5,R4
         MVCL  R2,R4
         MVC   SYMTBLE(4),=XL4'FFFFFFFF'
         MVC   BLZR(8),=CL8'0'
         XC    BLZR+8(8),BLZR+8
         LA    R2,BLKSCR
         LA    R3,NLSCR*L'BLKSCR+L'TRES+L'CVDNR+L'CVHNR
         XR    R4,R4
         LR    R5,R4
         ICM   R5,B'1000',CAPS+C' '
         MVCL  R2,R4
         MVC   DEFDRM(L'DEFDRM),=C'           INVALID; 0 ASSUMED'
         MVC   DEFOVM(L'DEFOVM),=C'SYMBOL TABLE OVERFLOW;'
         MVC   DEFOVM1(L'DEFOVM1+L'DELERM),TRES
         MVC   DELERM1(L'DELERM1),=C'NOT PREVIOUSLY DEFINED - ERROR'
         MVC   DELMSG(L'DELMSG),=C'         DELETED'
         MVC   TLUNDM(L'TLUNDM),=C'         UNDEFINED - SET TO 0'
         MVC   ZRDVM(L'ZRDVM),=C'         = 0; DIVIDE SUPPRESSED'
         MVI   SWITCH,0
         XC    SCRSZ(L'SCRSZ+L'SCRLZ),SCRSZ
        GTSIZE ,                   GET TERMINAL SIZE
         LTR   R0,R0               IS IT A SCREEN?
         BZ    TLOOP               IF ZERO, NOT A SCREEN
         CH    R0,=H'24'           STANDARD NUMBER OF LINES?
         BL    TLOOP               NO, LESS
         BE    *+L'*+12            YES
         CH    R1,=H'80'           STANDARD LINE LENGTH?
         BL    TLOOP               LESS
         B     *+L'*+12
         CH    R1,=H'80'           STANDARD LINE LENGTH?
         BL    TLOOP               NO, LESS
         BE    *+L'*+8             YES
         ST    R0,SCRSZ            SAVE SCREEN SIZE
         ST    R1,SCRLZ            SAVE LINE SIZE
         OI    SWITCH,SWSCR        SAY RUNNING ON A VALID SCREEN
         L     R1,=A(SCRDLEN)
        GETMAIN R,LV=(1)
         LR    R8,R1
         USING SCRDSECT,R8
         LA    R2,SCRDATA
         ST    R2,SCRIPTR
         AL    R2,=A(SCRNL*L'SCRDATA-1)
         ST    R2,SCRXPTR
         XC    SCRCOPYL,SCRCOPYL
         XC    SCRRPLY,SCRRPLY
         XC    SCRCOPY,SCRCOPY
         MVI   SCRSTAT,0
         LA    R2,SCRFULL
        $FS    CC=W,WCC=(RMDT),SBA=(24,80),MF=(I,(R2))
        $FS    SBA=(1,1),RA=(1,1,00),MF=I
        $FS    SBA=(1,1),SF=(PROT),RA=(1,29,-),MF=I
        $FS    SF=(PROT,INT),TEXT='HEX/DECIMAL CALCULATOR',MF=I
        $FS    SF=(PROT),RA=(1,80,-),MF=I
        $FS    SF=(PROT),TEXT='ENTER',MF=I
        $FS    SF=(PROT,INT),TEXT='===>',MF=I
        $FS    SF=NORMAL,MF=I
        $FS    SBA=(4,1),SF=(PROT),MF=I
        $FS    TEXT='--- MODE =',MF=I
        $FS    SF=(PROT,INT),MF=I
        $FS    TEXT=(' ',3),MF=I
        $FS    SF=(PROT),TEXT='(PF 5/17) --- DISPLAY =',MF=I
        $FS    SF=(PROT,INT),MF=I
        $FS    TEXT=(' ',3),MF=I
        $FS    SF=(PROT),TEXT='(PF 6/18) ---',MF=I
        $FS    TEXT='----- <FLIP-FLOP> ---',MF=I
        $FS    SBA=(5,1),SF=(PROT),MF=I
        $FS    TEXT='--- HELP:1/13 - ',MF=I
        $FS    TEXT='END:3/15/4/16 - ',MF=I
        $FS    TEXT='LIST:9/21 - ',MF=I
        $FS    TEXT='SORT:10/22 - ',MF=I
        $FS    TEXT='RESHOW:12/24/PA2 ---',MF=I
        $FS    SBA=(6,1),SF=(PROT,INT),RA=(6,72,6D),MF=I
        $FS    TEXT=('________',8),MF=I
        $FS    SF=(PROT),MF=I
         LA    R2,SCRDATA
         LA    R3,SCRNL
         MVI   0(R2),C' '
         MVC   1(L'SCRDATA-1,R2),0(R2)
         LA    R2,L'SCRDATA(R2)
         BCT   R3,*-14
        STFSMODE ON,INITIAL=YES    TURN ON VTAM FULL SCREEN MODE
         OC    SCRSZ(L'SCRSZ+L'SCRLZ),SCRSZ  SCREEN SIZE TO BE SET?
         BZ    TLOOP               NO
        STSIZE SIZE=80,LINE=24     SET STANDARD SCREEN SIZE
TLOOP    TM    SWITCH,SWSCR+NODISP FULL SCREEN OR NO DISPLAY?
         BZ    *+L'*+6             NO, SAY ENTER ...
         XR    R0,R0               YES, JUST READ A LINE
         B     *+L'*+8
         LA    R1,MENTER
         LA    R0,L'MENTER
         BAS   R14,RDLNE           SEND A MESSAGE AND READ A LINE
TLNEW    XC    PRES(8),PRES        INITIALIZE
         MVC   TNAME(8),SYMTBL
         XC    TNAME+8(4),TNAME+8
         NI    SWITCH,255-EQYET
         MVI   PROP,C'+'
         LA    R3,TSTRING
         ST    R3,TLSTART          SAVE START
         LTR   R1,R1               TEST LENGTH
         BNP   TLO1                DON'T CHANGE OLD INPUT
         LA    R5,0(R3,R1)
         BCTR  R5,0
         CLI   0(R5),C';'          SEE IF LAST IS ;
         BE    *+L'*+8             IF SO, DO NOT INSERT
         MVI   1(R5),C';'          PUT A ; ON THE END
         LA    R5,1(R5)            POINT TO NEXT
         MVI   1(R5),0             AND A ZERO AFTER THAT
TLO1     CLI   0(R3),C' '          LOOK FOR NON-BLANK
         BNE   *+L'*+8
         LA    R3,1(R3)
         B     TLO1
         CLI   0(R3),0             SEE IF AT END
         BE    TLOOP               IF DO, GET MORE
         TM    SWITCH,EQYET        SEE IF DONE SOMETHING YET
         BO    TLO2                IF SO, NO CHECK FOR COMMANDS
         CLC   0(L'CLIST,R3),CLIST SEE IF ASKING FOR A LIST
         BE    LIST                IF SO, GIVE I TO HIM
         CLC   0(L'CDEC,R3),CDEC   SEE IF MODE TO BE DEC
         BE    SETMODED            IF SO, SET THE MODE
         CLC   0(L'CHEX,R3),CHEX   SAME FOR HEX MODE
         BE    SETMODEH
         CLC   0(L'CDELETE,R3),CDELETE  SEE IF TRYING TO DELETE
         BE    DELETE
         CLC   0(L'CDISP,R3),CDISP SEE IF SET DISPLAY MODE
         BE    YDISP
         CLC   0(L'CNODISP,R3),CNODISP  SEE IF SET NO DISPLAY MODE
         BE    NDISP
         CLC   0(L'CSORT,R3),CSORT SEE IF WANT A SORT
         BE    SORT
         CLC   0(L'CHELP,R3),CHELP SEE IF WANT HELP
         BE    HELP
TLO2     XR    R2,R2               CLEAR REG 2
         TRT   0(20,R3),TRTBL      EXECUTE THE TRT TO FIND A STOPPER
*                                  (1) -> BYTE, (2) = RESULT
         BZ    TNONE               NO STOPPER FOUND, COMPLAIN
         LR    R4,R1               PUT WHERE BYTE IS IN R4
         SR    R4,R3               (4) = # OF BYTES - 1
         MVI   TRES,C' '           BLANK RESULT
         MVC   TRES+1(49),TRES
TLO3     CLI   0(R1),C' '          LOOK AGAIN FOR NON-BLANK
         BNE   *+L'*+8
         LA    R1,1(R1)
         B     TLO3
         MVC   TRES(1),0(R1)       MOVE STOPPING CHAR
         LTR   R4,R4               SEE IF NULL CHAR STRING
         BNZ   TLO6
         CLI   TRES,C'*'           SEE IF PREV RESULT
         BE    TLO4                IF SO, SAY SO
         CLI   TRES,C'-'           SEE IF INITIAL
         BE    TLO5                FORCE A ZERO
         CLI   TRES,C'+'           LEADING +?
         BE    TLO5                YES, FORCE A ZERO
         CLI   TRES,C';'           ONLY A SEMICOLON?
         BNE   TLMOP               NO... MISSING OPERAND
         B     TLO5                ELSE FORCE A 0
TLO4     MVI   TRES+4,C'*'         SAY THIS IS A SYMBOL
         LA    R1,1(R1)            POINT 1 TO NEXT CHAR
         LA    R4,1                GIVE REG 4 A NICE VALUE
         B     TLO3                THEN CONTINUE
TLO5     MVI   TRES+4,C'0'         IF SO, FORCE A 0
         B     TLO7
TNONE    LA    R1,TNMESS           NO STOPPERS FOUND - COMPLAIN
         LA    R0,L'TNMESS
         BAS   R14,SDMSG           SEND A MESSAGE
         B     TLOOP
TLO6     BCT   R4,*+L'*+6          CHOP R4 DOWN
         MVC   TRES+4(*-*),0(R3)   << EXECUTED >>
         EX    R4,*-6              MOVE WITH EXECUTE
TLO7     LA    R3,1(R1)            POINT R3 PAST CHAR
         CLI   TRES,C'='           SEE IF STORE RESULT
         BE    TLEQ
         OI    SWITCH,EQYET        DO NOT ALLOW ANY MORE =
         TRT   0(1,R1),TRTBL       SEE IF OPERAND STOPPED THE SCAN
         BZ    TLNOP               IF NOT, ERROR
         LA    R1,TRES+4           IF YES, FIND WHAT THING IS
         LA    R2,SYMTBL           START AT BEGINNING
         BAS   R14,DEFSYM
         LTR   R1,R1               SEE IF DEFINED
         BP    TLOK
         MVC   TLUNDM(8),TRES+4    COMPLAIN ABOUT UNDEFINED
         LA    R1,TLUNDM
         LA    R0,L'TLUNDM
         BAS   R14,RDLNE           SEND A MESSAGE AND READ A LINE
         LTR   R1,R1
         BP    TLNEW
         LA    R2,BLZR             FAKE A NUMBER
TLOK     CLI   PROP,C'+'           SEE IF +
         BE    TLPL
         CLI   PROP,C'-'
         BE    TLMIN
         CLI   PROP,C'*'
         BE    TLMULT
         CLI   PROP,C'/'
         BNE   TLNOP
         L     R7,8(R2)            GET DIVISOR
         LTR   R7,R7               SEE IF ZERO
         BE    ZRDV                IF SO, COMPLAIN
         CH    R7,=H'-1'           SEE IF DIVIDING BY -1
         BE    DVM1                IF SO, DO A SUBTRACT
         L     R6,PRES+4           GET PREV RESULT
         SRDA  R6,32               PROPAGATE SIGN
         D     R6,8(R2)            DIVIDE BY THIS
         ST    R7,PRES+4           STORE RESULT
         B     NXTSYM              GO TO NEXT
DVM1     XR    R7,R7               DIVIDE BY -1
         S     R7,PRES+4           INSTEAD, SUBTRACT
         ST    R7,PRES+4
         B     NXTSYM              THEN CONTINUE
ZRDV     MVC   ZRDVM(8),TRES+4     ZERO DIVIDE COMPLAINT
         LA    R1,ZRDVM
         LA    R0,L'ZRDVM
         BAS   R14,RDLNE           SEND A MESSAGE AND READ A LINE
         LTR   R1,R1
         BP    TLNEW
         B     NXTSYM
TLNOP    LA    R1,TLMOCM           MISSING OPERATOR COMPLAINT
         LA    R0,L'TLMOCM
         BAS   R14,RDLNE           SEND A MESSAGE AND READ A LINE
         OI    SWITCH,EQYET        SET = OCCURED BIT
         LTR   R1,R1
         BP    TLNEW
         MVI   PROP,C'+'
         BCTR  R3,0
         B     TLO1
TLMOP    LA    R3,1(R1)            MISSING OPERAND COMPLAINT
         LA    R1,TLMMOP
         LA    R0,L'TLMMOP
         BAS   R14,RDLNE           SEND A MESSAGE AND READ A LINE
         OI    SWITCH,EQYET        SET = OCCURED BIT
         LTR   R1,R1
         BP    TLNEW
         B     NXTSYM
TLMULT   L     R7,PRES+4           DO MULTIPLY
         M     R6,8(R2)            DO IT
         ST    R7,PRES+4
         B     NXTSYM
TLPL     MVC   PRES+4(4),8(R2)     IF PREV WAS PLUS, SET
         B     NXTSYM
TLMIN    XR    R6,R6               IF -, STORE -
         S     R6,8(R2)
         ST    R6,PRES+4
         B     NXTSYM
TLEQ     TM    SWITCH,EQYET        FOUND AN =; SEE IF PREVIOUS
         BO    DUPEQ
         OI    SWITCH,EQYET        SET BIT
         MVC   TNAME(8),TRES+4
         ST    R4,TNAME+8
         B     TLO1
DUPEQ    LA    R1,DUMTOM           COMPLAIN OF MORE THAN 1
         LA    R0,L'DUMTOM
         BAS   R14,RDLNE           SEND A MESSAGE AND READ A LINE
         LTR   R1,R1               SEE IF ANYTHING ENTERED
         BP    TLNEW               IF SO, RESTART
         B     TLO1                ELSE, CONTINUE
NXTSYM   CLI   TRES,C';'           SEE IF END
         BE    NXTSYM1             IF SO, DO NOT REPLACE OP
         MVC   PROP(1),TRES        NOW SEE IF ADD TO BIG TERM
         CLI   TRES,C'*'           IS NEXT OP * OR /
         BE    TLO1                IF SO, JUST CONTINUE
         CLI   TRES,C'/'
         BE    TLO1
NXTSYM1  L     R6,PRES             IF NOT, ADD TO BIG TOTAL
         A     R6,PRES+4
         ST    R6,PRES
         CLI   TRES,C';'           SEE IF END
         BNE   TLO1                IF NOT, DO MORE
         L     R1,PRES             GET RESULT
         TM    SWITCH,EQYET        SEE IF STORING
         BZ    NOEQ                IF NOT, SKIP LOOKUP
         LA    R1,TNAME            IF SO, FIND WHERE RESULT GOES
         L     R4,TNAME+8
         LA    R2,SYMTBL           START SEARCH AT BEGINNING
         BAS   R14,DEFSYM          FIND WHERE IT GOES
         L     R1,PRES             GET TOTAL
         ST    R1,8(R2)            STORE IT
NOEQ     ST    R1,SYMTBL+8         STORE AT SYMBOL *
         BAS   R14,CVD             CONVERT TO DECIMAL
         MVC   TRES(L'CVDNR+L'CVHNR),CVDNR
         L     R1,TLSTART
         LR    R2,R3
         SR    R2,R1
         CH    R2,=Y(L'TRES-50)    SEE IF MOVING TOO MUCH
         BL    *+L'*+14            IF NOT, OK
         LH    R2,=Y(L'TRES-50)    MOVE MAX
         BCT   R2,*+L'*+6
         MVC   TRES+L'BLKSCR(*-*),0(R1) << EXECUTED >>
         EX    R2,*-6              MOVE THE DESIRED AMOUNT
         MVI   TRES+L'CVDNR+L'CVHNR,C' '     CLEAR OUT REST OF LINE
         MVC   TRES+L'CVDNR+L'CVHNR+1(L'BLKSCR-L'CVDNR-L'CVHNR-1),TRES+1
               L'CVDNR+L'CVHNR
         TM    SWITCH,NODISP       SEE IF DISPLAY
         BZ    *+L'*+10            IF YES, DO IT
         CLI   0(R3),0             IF NO, SEE IF AT END
         BNE   TLNFNB              IF NOT, SUPPRESS DISPLAY
         XR    R2,R2               IF YES, DISPLAY ONLY RESULT
         LA    R1,TRES             PUT IT OUT
         LA    R0,L'BLKSCR(R2)
         BAS   R14,SDMSG           SEND A MESSAGE
TLNFNB   CLI   0(R3),C' '          LOOK FOR NON-BLANK
         BNE   *+L'*+8
         LA    R3,1(R3)
         B     TLNFNB
         CLI   0(R3),C';'          CHECK FOR NULL STATEMENT
         BNE   *+L'*+8
TLNFNB1  LA    R3,1(R3)
         B     TLNFNB
         MVI   PROP,C'+'
         NI    SWITCH,255-EQYET    NUTTIN YET
         XC    PRES(8),PRES
         MVC   TNAME(8),SYMTBL
         XC    TNAME+8(4),TNAME+8
         ST    R3,TLSTART
         B     TLO1
TLFN     CLI   0(R3),C' '          LOOK FOR NON-BLANK
         BNE   *+L'*+8
         LA    R3,1(R3)
         B     TLFN
         CLI   0(R3),C';'          CHECK FOR NULL STATEMENT
         BE    TLNFNB1
         LA    R1,TLMSEP           MISSING SEPARATOR COMPLAINT
         LA    R0,L'TLMSEP
         BAS   R14,SDMSG           SEND A MESSAGE
         B     TLOOP
         SPACE 1
*        DELETE : REMOVE SYMBOLS FROM TABLE
         SPACE 1
DELETE   LA    R1,L'CDELETE(R3)    POINT 1 PAST KEYWORD
DEL1     CLI   0(R1),C' '          SCAN FOR NON-BLANK
         BNE   *+L'*+8
         LA    R1,1(R1)
         B     DEL1
         CLI   0(R1),C';'          SEE IF AT END
         BNE   DEL3
         B     TNONE               IF SO, KILL
DEL2     CLI   0(R1),C' '          SCAN FOR NON-BLANK
         BNE   *+L'*+8
         LA    R1,1(R1)
         B     DEL2
         CLI   0(R1),C';'          SEE IF AT END
         BE    TLNFNB              IF SO, QUIT
DEL3     LA    R3,1(R1)            SET 3 PAST NON-BLANK
         CLI   0(R3),C' '          SCAN FOR BLANK OR ;
         BE    DEL4
         CLI   0(R3),C';'
         BE    DEL4
         LA    R3,1(R3)            POINT TO NEXT
         B     DEL3+L'DEL3         TRY AGAIN
DEL4     LR    R4,R3
         SR    R4,R1               PUT LENGTH IN 4
         BCTR  R4,0                CHANGE TO LENGTH-1
         CH    R4,=H'8'            SEE IF REG 4 TOO BIG
         BL    *+L'*+4
         LA    R4,7                IF SO, SET TO 7
         MVI   DELERM,C' '         BLANK OUT MESSAGE
         MVC   DELERM+1(7),DELERM
         EX    R4,DELMVC           MOVE TO ERROR MESSAGE IN CASE
         LA    R1,DELERM           POINT 1 NICE
         LA    R2,SYMTBL+12        START PAST PREV RESULT
         BAS   R14,DEFSYM          FIND WHERE IT IS
         CH    R1,=H'1'            SEE IF OLD
         BNE   DELERR              IF NOT, ERROR
         MVC   DELMSG(8),DELERM    SAY  DELETED
         LA    R1,DELMSG
         LA    R0,L'DELMSG
         BAS   R14,SDMSG           SEND A MESSAGE
         MVI   0(R2),0             DELETE SYMBOL
         LR    R1,R3               CONTINUE
         B     DEL2
DELERR   LR    R4,R1               SAVE 1 IN 4
         LA    R1,DELERM
         LA    R0,L'BLKSCR
         BAS   R14,RDLNE           SEND A MESSAGE AND READ A LINE
         LTR   R4,R4               SEE IF NEW AND JUST DEFINED
         BNZ   *+L'*+4
         MVI   0(R2),0             DELETE SYMBOL
         LTR   R1,R1               SEE IF ANYTHING READ
         BP    TLNEW
         LR    R1,R3               CONTINUE
         B     DEL2
DELMVC   MVC   DELERM(*-*),0(R1)   << EXECUTED >>
         SPACE 1
*        SORT : SORT THE SYMBOLS TABLE
         SPACE 1
SORT     LA    R3,L'CSORT(R3)      POINT 3 PAST KEYWORD
         ST    R3,TLSTART
         LA    R1,SYMTBL+12        1 -> MAIN FIELD
SORT1    CLI   0(R1),0             SEE IF MAIN FIELD FREE
         BE    SORT4               IF SO, IGNORE IT
         CLI   0(R1),X'FF'         SEE IF AT END
         BE    LIST0               IF SO, TERMINATE SORT
         LA    R2,12(R1)           2 -> FIELD TO BE COMPARED
SORT2    CLI   0(R2),0             SEE IF SECONDARY FIELD FREE
         BE    SORT3               IF SO, IGNORE IT
         CLI   0(R2),X'FF'         SEE IF AT END
         BE    SORT4               IF SO, STOP THIS SCAN
         CLC   0(8,R1),0(R2)       WANT 1 <= 2
         BNH   SORT3               IF OK, SKIP EXCHANGE
         XC    0(12,R2),0(R1)      EXCHANGE
         XC    0(12,R1),0(R2)
         XC    0(12,R2),0(R1)
SORT3    LA    R2,12(R2)           POINT 2 TO NEXT ENTRY
         B     SORT2               CONTINUE SCAN
SORT4    LA    R1,12(R1)           IF SO, POINT 1 TO NEXT
         B     SORT1               THEN CONTINUE
         SPACE 1
*        LIST : DISPLAYS SYMBOLS FROM TABLE
         SPACE 1
LIST     LA    R3,L'CLIST(R3)      POINT 3 PAST KEYWORD
         ST    R3,TLSTART
LIST0    LA    R2,SYMTBL+12        2 -> SYMBOL TABLE
LIST1    LA    R3,BLKSCR           3 -> BLOCK-SCREEN
         LA    R4,NLSCR-1          4 = COUNTS
LIST2    CLI   0(R2),0             SEE IF EMPTY PLACE
         BNE   *+L'*+8             IF SO, DO NOT DISPLAY
         LA    R2,12(R2)           POINT 2 TO NEXT
         B     LIST2               TRY AGAIN
         CLI   0(R2),X'FF'
         BE    LIST3
         MVI   0(R3),C' '          CLEAR OUT A LINE
         MVC   1(L'BLKSCR-1,R3),0(R3)
         L     R1,8(R2)            GET THE VALUE
         STM   R2,R4,LISTSV
         BAS   R14,CVD             CONVERT TO A STRING
         LM    R2,R4,LISTSV
         MVC   0(8,R3),0(R2)       MOVE IN NAME
         MVI   9(R3),C'='          AN =
         MVC   11(L'CVDNR+L'CVHNR,R3),CVDNR  AND THE VALUE
         LA    R3,L'BLKSCR(R3)     SET FOR NEXT
         LA    R2,12(R2)
         BCT   R4,LIST2            TIMES PER BLOCK-SCREEN
LIST3    LA    R4,BLKSCR           FIND HOW MUCH TO DISPLAY
         SR    R3,R4
         BZ    LIST4               IF NONE, QUIT
         LA    R1,BLKSCR           PUT IT OUT
         LA    R0,0(R3)
         TM    SWITCH,SWSCR        RUNNING ON A SCREEN?
         BO    *+L'*+8             YES
         BAS   R14,RDLNE           SEND A MESSAGE AND READ A LINE
         B     *+L'*+4
         BAS   R14,SDMSG           SEND A MESSAGE
         LTR   R1,R1               SEE IF ANYTHING READ
         BNP   LIST1               IF NOT, CONTINUE LIST
         B     TLNEW               IF SO, GO TO PROCESS IT
LIST4    L     R3,TLSTART
         B     TLFN
         SPACE 1
*        DEC, HEX DISP, NODISP SUBCOMMANDS
         SPACE 1
SETMODED NI    SWITCH,255-MODE     SET THE MODE TO DECIMAL
         LA    R3,L'CDEC(R3)       POINT 3 PAST KEYWORD
         B     TLFN
SETMODEH OI    SWITCH,MODE         SET THE MODE TO HEX
         LA    R3,L'CHEX(R3)       POINT 3 PAST KEYWORD
         B     TLFN
YDISP    NI    SWITCH,255-NODISP   DISPLAY ALL ANSWERS
         LA    R3,L'CDISP(R3)      POINT 3 PAST KEYWORD
         B     TLFN
NDISP    OI    SWITCH,NODISP       DISPLAY ONLY LAST ANSWERS
         LA    R3,L'CNODISP(R3)    POINT 3 PAST KEYWORD
         B     TLFN
         SPACE 1
*        HELP SUBCOMMAND
         SPACE 1
HELP     LA    R3,L'CHELP(R3)      POINT 3 PAST KEYWORD
         ST    R3,TLSTART
         TM    SWITCH,SWSCR        RUNNING ON A SCREEN?
         BO    HELP10              YES
         L     R2,=A(HELPTXT)      2 -> HELP TEXT
HELP1    XR    R4,R4
         IC    R4,0(R2)            4 = COUNTS
         LTR   R4,R4               SEE IF END
         BZ    HELP20              YES
         LA    R2,1(R2)            SKIP COUNTS
HELP2    LR    R1,R2
         LA    R0,L'BLKSCR         0 -> HOW MUCH TO DISPLAY
         ALR   R2,R0               SET FOR NEXT
         BCT   R4,HELP3            TIMES BEFORE READ TEST
         BAS   R14,RDLNE           SEND A MESSAGE AND READ A LINE
         LTR   R1,R1               SEE IF ANYTHING READ
         BNP   HELP1               IF NOT, CONTINUE HELP
         B     TLNEW               IF SO, GO TO PROCESS IT
HELP3    BAS   R14,SDMSG           SEND A MESSAGE
         B     HELP2
HELP10   LA    R1,SCRDATA
         CL    R1,SCRIPTR          ANYTHING PENDING?
         BE    HELP11              NO
         XR    R0,R0               YES, PUT IT OUT
         BAS   R14,RDLNE           SEND A MESSAGE AND READ A LINE
         LTR   R1,R1               SEE IF ANYTHING READ
         BP    TLNEW               IF SO, GO TO PROCESS IT
HELP11   L     R2,=A(HELPFTX)      2 -> HELP TEXT
HELP12   CLI   0(R2),0             SEE IF END
         BE    HELP13              YES
         LR    R1,R2               PUT IT OUT
         LA    R0,L'BLKSCR         0 -> HOW MUCH TO DISPLAY
         ALR   R2,R0               SET FOR NEXT
         BAS   R14,SDMSG           SEND A MESSAGE
         LTR   R1,R1               SEE IF ANYTHING READ
         BNP   HELP12              IF NOT, CONTINUE HELP
         B     TLNEW               IF SO, GO TO PROCESS IT
HELP13   LA    R1,SCRDATA
         CL    R1,SCRIPTR          ANYTHING PENDING?
         BE    HELP20              NO
         XR    R0,R0               YES, PUT IT OUT
         BAS   R14,RDLNE           SEND A MESSAGE AND READ A LINE
         LTR   R1,R1               SEE IF ANYTHING READ
         BP    TLNEW               IF SO, GO TO PROCESS IT
HELP20   L     R3,TLSTART
         B     TLFN
         EJECT
TSOEXIT  TM    SWITCH,SWSCR        RUNNING ON A VALID SCREEN?
         BZ    TSOQUIT             NO
         MVC   SCRFULL(CLEARL),CLEAR    SET CLEAR SEQUENCE
         OC    SCRSZ(L'SCRSZ+L'SCRLZ),SCRSZ  SCREEN SIZE WAS SET?
         BZ    TSORESET            NO
        STSIZE SIZELOC=SCRLZ,LINELOC=SCRSZ   RESTORE ORIGINAL SIZE
        $FS    CC=EWA,MF=(I,SCRFULL)
TSORESET LA    R1,SCRFULL          CLEAR SCREEN
         LA    R0,CLEARL
         ICM   R1,B'1000',=X'03'   INDICATE FULL SCREEN
        TPUT   (1),(0),R
        STFSMODE OFF               TURN OFF FULL SCREEN MODE
         L     R14,=A(SCRDLEN)
        FREEMAIN R,A=(R8),LV=(R14)
TSOQUIT $XRET  CC=0,LV=TSOLEN,TYPE=RENT
         EJECT
* SDMSG OR RDLNE ARE CALLED BY :
*
*        LA    R1,... MESSAGE TEXT
*        LA    R0,... MESSAGE SIZE
*        BAS   R14,SDMSG
*     OR BAS   R14,RDLNE
*
*        ONLY AFTER RDLNE - (1) = NUMBER OF CHARACTERS READ
         SPACE 1
RDLNE    OI    SWITCH,RDREQ        SET READ REQUESTED
SDMSG    ST    R14,SRSR14          SAVE REG 14
         LTR   R15,R0              LENGTH
         BNP   SDMSG3              NONE, SKIP
         TM    SWITCH,SWSCR        RUNNING ON A SCREEN?
         BO    SDSCR1              YES
         LR    R14,R1              ADDRESS
SDMSG1   SH    R15,=Y(L'BLKSCR)    GET LENGTH
         BNP   SDMSG2              NO, LAST TIME
         STM   R14,R15,QQSAVE      SAVE THEM
        TPUT   (R14),L'BLKSCR      PUT IT OUT
         LM    R14,R15,QQSAVE      GET THEM BACK
         LA    R14,L'BLKSCR(,R14)  POINT AT NEXT
         B     SDMSG1              TRY AGAIN
SDMSG2   AH    R15,=Y(L'BLKSCR)    GET LENGTH BACK
         LR    R0,R15              GET LENTGH
        TPUT   (R14),(R0)          PUT IT OUT
SDMSG3   TM    SWITCH,RDREQ        READ REQUESTED?
         BO    RDLNE1              YES
         L     R14,SRSR14          RESTORE REG 14
         BR    R14
SDSCR1   L     R15,SCRIPTR         GET DATA LINES POINTER
         CL    R15,SCRXPTR         DATA LINES FULL FILLED
         BH    SDSCR3              YES
         SH    R0,=Y(L'BLKSCR)     GET LENGTH
         BNP   SDSCR2              NO, LAST TIME
         MVC   0(L'BLKSCR,R15),0(R1)    MOVE DATA
         LA    R1,L'BLKSCR(R1)     POINT AT NEXT
         LA    R15,L'BLKSCR(R15)
         B     SDSCR1+L'SDSCR1
SDSCR2   AH    R0,=Y(L'BLKSCR)     GET LENGTH BACK
         LR    R14,R0
         BCT   R14,*+L'*+6
         MVC   0(*-*,R15),0(R1)    <<EXECUTED>>
         EX    R14,*-6             MOVE LAST DATA
         LA    R15,L'BLKSCR(R15)
         ST    R15,SCRIPTR         SAVE DATA LINES POINTER
         XR    R1,R1               SET AS NO INPUT
         B     SDMSG3
SDSCR3   STM   R0,R1,QQSAVE        SAVE THEM
        $FS    TEXT=('* MORE *',8),MF=(I,SCRNXTT)
         OI    SCRSTAT,DTCNT       SAY DATA CONTINUE
         B     RDSCR1              GO DISPLAY THIS SECTION
SDSCR4   NI    SCRSTAT,255-DTCNT   RESET DATA CONTINUE
         LTR   R1,R1               SEE IF ANYTHING ENTERED
         BP    *+L'*+8             IF SO, RESTART
         LM    R0,R1,QQSAVE        GET THEM BACK
         B     SDSCR1              CONTINUE
         NI    SWITCH,255-RDREQ    RESET READ REQUEST (IF ANY)
         B     RDLNE3              GO PROCESS NEW INPUT
         EJECT
RDLNE1   NI    SWITCH,255-RDREQ    RESET READ REQUEST
         TM    SWITCH,SWSCR        RUNNING ON A SCREEN?
         BO    RDSCR1              YES
RDLNE2   XC    READINTO(L'READINTO),READINTO
         LA    R0,L'READINTO-1
        TGET   READINTO,(0)        GET INPUT
         LTR   R15,R15             TEST RETURN CODE
         BZ    RDLNE3              OK
        TCLEARQ INPUT              CLEAR OUT INPUT
         B     RDLNE2              TRY AGAIN
RDLNE3   TR    READINTO(L'READINTO),CAPS     UPPER CASE
         CH    R1,=H'3'            IS IT AT LEAST 3 LONG?
         BL    RDLNE4              NO
         CLC   READINTO(4),=CL4'/END'   IS IT END?
         BE    TSOEXIT             YES
RDLNE4   L     R14,SRSR14          RESTORE REG 14
         LTR   R15,R1              TEST FOR A LENGTH
         BNPR  R14                 NONE, FORGET IT
         XC    TSTRING(L'TSTRING),TSTRING    RESET
         BCTR  R15,0               SUBTRACT ONE
         EX    R15,*+L'*+2         DO IT
         BR    R14                 RETURN TO CALLER
         MVC   TSTRING(*-*),READINTO    <<EXECUTED>>
         SPACE 1
RDSCR1   TM    SWITCH,MODE         COMPLETE SCREEN
         BO    *+L'*+10
         MVC   SCRMODE,=CL3'DEC'
         B     *+L'*+6
         MVC   SCRMODE,=CL3'HEX'
         TM    SWITCH,NODISP
         BO    *+L'*+10
         MVC   SCRDISP,=CL3'ON '
         B     *+L'*+6
         MVC   SCRDISP,=CL3'OFF'
        $FS    SBA=(1,1),SF=(PT,IC),MF=(I,SCRIADD)
         LA    R0,SCRLEN+SCRPTICL  SCREEN FORMAT LENGTH
         TM    SCRSTAT,FIRST       FIRST TPUT DONE?
         BO    RDSCR2              YES
         OC    SCRSZ(L'SCRSZ+L'SCRLZ),SCRSZ  SCREEN SIZE TO BE SET?
         BZ    RDSCR2              NO
        $FS    CC=EW,MF=(I,SCRFULL)     SET ERASE/WRITE
RDSCR2   LA    R1,SCRFULL          SCREEN START ADDRESS
         ICM   R1,B'1000',=X'03'   INDICATE FULL SCREEN
        TPUT   (1),(0),R
         TM    SCRSTAT,FIRST       FIRST TPUT DONE?
         BO    RDSCR3              YES
         OC    SCRSZ(L'SCRSZ+L'SCRLZ),SCRSZ  SCREEN SIZE TO BE SET?
         BZ    *+L'*+6             NO
        $FS    CC=W,MF=(I,SCRFULL) RESTORE WRITE
         OI    SCRSTAT,FIRST       SAY FIRST TPUT DONE
RDSCR3   XC    SCRRPLY,SCRRPLY     RESET INPUT BUFFER
        TGET   SCRRPLY,L'SCRRPLY-1,ASIS
         LTR   R15,R15             TEST RETURN CODE
         BZ    RDSCR4              OK
        TCLEARQ INPUT              CLEAR OUT INPUT
         B     RDSCR3              TRY AGAIN
RDSCR4   CLI   SCRPFCD,X'F3'       PF-3 - END
         BE    TSOEXIT
         CLI   SCRPFCD,X'C3'       PF-15 (ALT. PF-3)
         BE    TSOEXIT
         CLI   SCRPFCD,X'F4'       PF-4 - END
         BE    TSOEXIT
         CLI   SCRPFCD,X'C4'       PF-16 (ALT. PF-4)
         BE    TSOEXIT
         CLI   SCRPFCD,X'6E'       PA2 (RESHOW)
         BE    *+L'*+16
         CLI   SCRPFCD,X'7C'       PF-12
         BE    *+L'*+8
         CLI   SCRPFCD,X'4C'       PF-24 (ALT. PF-12)
         BNE   RDSCR5
         ICM   R0,B'1111',SCRCOPYL
         BNZ   *+L'*+8
         LA    R0,SCRLEN+SCRPTICL  SCREEN FORMAT LENGTH
         B     RDSCR2
        $FS   SBA=(2,12),MF=(I,SCRIADD)
         MVC   SCRINAR,SCRCOPY     RE-DISPLAY SCREEN WITH LAST INPUT
         LA    R1,SCRINAR
         ALR   R1,R0
        $FS    SBA=(1,1),SF=(PT,IC),MF=(I,(R1))
         LA    R1,SCRLEN++L'SCRIADD+SCRPTICL SCREEN FORMAT LENGTH
         ALR   R0,R1
         B     RDSCR2
RDSCR5   TM    SCRSTAT,DTCNT
         BO    RDSCR6
         CLI   SCRPFCD,X'F5'       PF-5 - DEC/HEX
         BE    *+L'*+8
         CLI   SCRPFCD,X'C5'       PF-17 (ALT. PF-5)
         BNE   *+L'*+8
         XI    SWITCH,MODE         INVERT MODE
         B     RDSCR1
         CLI   SCRPFCD,X'F6'       PF-6 - DISP/NODISP
         BE    *+L'*+8
         CLI   SCRPFCD,X'C6'       PF-18 (ALT. PF-6)
         BNE   *+L'*+8
         XI    SWITCH,NODISP       INVERT DISPLAY
         B     RDSCR1
RDSCR6  $FS    TEXT=('________',8),MF=(I,SCRNXTT)
         LA    R14,SCRDATA         RESET LINES 5-24
         ST    R14,SCRIPTR
         LA    R0,SCRNL
         MVI   0(R14),C' '
         MVC   1(L'SCRDATA-1,R14),0(R14)
         LA    R14,L'SCRDATA(R14)
         BCT   R0,*-14
         CLI   SCRPFCD,X'F1'       PF-1 - HELP
         BE    *+L'*+8
         CLI   SCRPFCD,X'C1'       PF-13 (ALT. PF-1)
         BNE   *+L'*+14
         MVC   SCRTEXT(L'CHELP),CHELP
         LA    R1,L'CHELP
         B     RDSCR10
         CLI   SCRPFCD,X'F9'       PF-9 - LIST
         BE    *+L'*+8
         CLI   SCRPFCD,X'C9'       PF-21 (ALT. PF-9)
         BNE   *+L'*+14
         MVC   SCRTEXT(L'CLIST),CLIST
         LA    R1,L'CLIST
         B     RDSCR10
         CLI   SCRPFCD,X'7A'       PF-10 - SORT
         BE    *+L'*+8
         CLI   SCRPFCD,X'4A'       PF-22 (ALT. PF-10)
         BNE   *+L'*+14
         MVC   SCRTEXT(L'CSORT),CSORT
         LA    R1,L'CSORT
         B     RDSCR10
         SH    R1,=Y(L'SCRPFCD)
         BP    *+L'*+6
         XR    R1,R1
         B     RDSCR10
         LR    R15,R1
         XC    SCRCOPY,SCRCOPY
         BCT   R15,*+L'*+6
         MVC   SCRCOPY(*-*),SCRTEXT
         EX    R15,*-6
         ST    R1,SCRCOPYL
RDSCR10  XC    READINTO(L'READINTO),READINTO
         LTR   R15,R1
         BZ    RDSCR11
         BCT   R15,*+L'*+6
         MVC   READINTO(*-*),SCRTEXT
         EX    R15,*-6
RDSCR11  TM    SCRSTAT,DTCNT
         BZ    RDLNE3
         B     SDSCR4
         EJECT
* DEFSYM IS CALLED BY :
*
*        LA    R1,... SYMBOL
*        LA    R2,... START-OF-SEARCH
*        BAS   R14,DEFSYM
*
*        (1) = 0 IF SYMBOL NEW,
*              1 IF OLD, -1 IF COULD NOT FIT,
*              2 IF CONSTANT,
*              -1 IF COULD NOT FIT
*        (2) = LOC. OF SYMBOL
*
DEFSYM   MVC   DEFDRM(10),0(R1)    MOVE TO ERROR MESSAGE IN CASE
         CLI   0(R1),C'0'          SEE IF NUMBER
         BL    DEFSYM1
         CLI   0(R1),C'9'
         BH    DEFSYM1
         LA    R2,0(R1,R4)
         CLI   0(R2),C'.'          SEE IF ENDS IN A .
         BE    DEFDY               IF SO, ALWAYS DECIMAL
         CLI   0(R2),C'H'          SEE IF ENDS IN H
         BE    DEFH                IF SO, ALWAYS HEX
         TM    SWITCH,MODE         SEE WHAT THE MODE IS
         BZ    DEFD1               DECIMAL
         LA    R4,1(R4)            ADD 1 TO LENGTH COUNT
         B     DEFH                THEN GO TO CONVERT HEX
DEFDY    BCTR  R2,0                CUT 2 DOWN FOR CHECK
         BCTR  R4,0                CUT 4 DOWN FOR LENGTH
DEFD1    CH    R4,=H'8'            SEE IF TOO LONG
         BH    DEFDERR
DEFD2    CLI   0(R2),C'0'          CHECK FOR VALID #
         BL    DEFDERR
         BCTR  R2,0
         CLI   0(R2),C' '
         BNE   DEFD2
         EX    R4,DEFPACK          PACK THE NUMBER
         CVB   R2,DEFPK            CONVERT TO BINARY
DEFD3    ST    R2,DEFPK+8          MAKE CONSTANT LOOK LIKE SYMBOL
         LA    R2,DEFPK
         LA    R1,2
         BR    R14                 RETURN
DEFPACK  PACK  DEFPK(8),0(*-*,R1)  << EXECUTED >>
DEFDERR  ST    R14,DFSR14          BAD DATA - SAVE R14
         LA    R1,DEFDRM
         LA    R0,L'DEFDRM
         BAS   R14,RDLNE           SEND A MESSAGE AND READ A LINE
         LTR   R1,R1
         BNZ   TLNEW
         L     R14,DFSR14
         XR    R2,R2
         B     DEFD3
DEFH     XR    R0,R0
         LR    R2,R1
DEFH1    BCTR  R4,0
         IC    R1,0(R2)            GET A CHARACTER
         CLI   0(R2),C'0'          SEE IF 0-N
         BNL   DEFH2               IF SO, KEEP RIGHT 4 BITS
         CLI   0(R2),C'A'          MAKE SURE A-F
         BL    DEFDERR             IF NOT, COMPLAIN
         CLI   0(R2),C'F'
         BH    DEFDERR
         LA    R1,9(R1)            GET RIGHT 4 BITS + 9
DEFH2    SLL   R1,28
         LA    R2,1(R2)
         SLDL  R0,4
         LTR   R4,R4
         BP    DEFH1
         LR    R2,R0
         B     DEFD3
DEFSYM1  XR    R0,R0               ZERO REG 0 FOR TEST
DEFSYM2  CLI   0(R2),X'FF'         SEE IF AT END
         BE    DEFEND              IF SO, SEE IF FOUND ANYTHING
         LTR   R0,R0               SEE IF FOUND A PREVIOUS PLACE
         BNZ   DEFSYM3             IF SO, SKIP
         CLI   0(R2),0             SEE IF SPACE OPEN
         BNE   DEFSYM3
         LR    R0,R2               IF SO, SAVE R2
DEFSYM3  CLC   0(8,R2),0(R1)       SEE IF MATCH
         BE    DEFOLD
         LA    R2,12(R2)           IF NOT,
         B     DEFSYM2             TRY AGAIN
DEFEND   LTR   R2,R0               AT END - SEE IF FOUND SPACE
         BNZ   DEFNEW              IF SO, OK
         MVC   DEFOVM1(8),0(R1)    COULD NOT FIT
         ST    R14,DFSR14          SAVE R14
         LA    R1,DEFOVM           COMPLAIN
         LA    R0,L'DEFOVM+L'DEFOVM1
         BAS   R14,RDLNE           SEND A MESSAGE AND READ A LINE
         LTR   R1,R1
         BNZ   TLNEW
         L     R14,DFSR14
         LA    R2,SYMTBL
DEFOLD   LA    R1,1                OLD SYMBOL
         BR    R14                 RETURN
DEFNEW   MVC   0(8,R2),0(R1)       NEW - MOVE SYMBOL IN
         XC    8(4,R2),8(R2)       GIVE IT A VALUE OF ZERO
         XR    R1,R1
         BR    R14                 RETURN
         EJECT
*        CONVERT TO DECIMAL ROUTINE
*
*        AT ENTRY - (1) = VALUE
*        AT EXIT - CVDNR = EDITED DEC VALUE
*                  CVHNR = EDITED HEX VALUE
         SPACE 1
CVD      LR    R2,R1               SAVE VALUE
         LA    R4,CVHNR
         LA    R15,L'CVHNR
CVDL     XR    R0,R0
         SLDL  R0,4
         STC   R0,0(R4)
         LA    R4,1(R4)
         BCT   R15,CVDL
         TR    CVHNR(L'CVHNR),=CL16'0123456789ABCDEF'
         CVD   R2,CVDN
         LA    R1,CVDNR+L'CVDNR-2  POINT 1 FOR EDMK
         MVC   CVDNR(13),=XL13'40202020202020202020212040'  MOVE MASK
         EDMK  CVDNR(L'CVDNR-1),CVDN+2  DO THE EDIT
         LTR   R2,R2               SEE IF INPUT NEGATIVE
         BNMR  R14
         BCTR  R1,0
         MVI   0(R1),C'-'
         BR    R14
         EJECT
*        CONSTANTS.
         SPACE 1
CDEC     DC    C'/DEC'
CHEX     DC    C'/HEX'
CLIST    DC    C'/LIST'
CSORT    DC    C'/SORT'
CHELP    DC    C'/HELP'
CDISP    DC    C'/DISP'
CNODISP  DC    C'/NODISP'
CDELETE  DC    C'/DELETE'
TLMOCM   DC    C'MISSING OPERATOR'
TLMMOP   DC    C'MISSING OPERAND'
TLMSEP   DC    C'MISSING SEPARATOR'
TNMESS   DC    C'INVALID DATA - PLEASE RE-ENTER'
MENTER   DC    C'ENTER EQUATION(S) OR ''/END'''
DUMTOM   DC    C'ILLEGAL OCCURANCE OF ='
         SPACE 1
TRTBL    DC    C'%',XL15'0'                                 00-0F
         DC    XL48'0'                                      10-3F
         DC    C' ',XL13'0',C'+',XL1'0'                     40-4F
         DC    XL12'0',C'*',XL1'0',C';',XL1'0'              50-5F
         DC    C'-/',XL14'0'                                60-6F
         DC    XL14'0',C'=',XL1'0'                          70-7F
         DC    XL128'0'                                     80-FF
         SPACE 1
CAPS     DC    21AL1(*-CAPS)       00-14
         DC    CL1';'              15 (BECOME ;)
         DC    63AL1(*-CAPS)       16-54
         DC    CL1';'              55 (BECOME ;)
         DC    21AL1(*-CAPS)       56-6A
         DC    CL1';'              6B (, BECOME ;)
         DC    21AL1(*-CAPS)       6C-80
         DC    9AL1(*-CAPS+C' ')   81-89 BECOME C1-C9
         DC    7AL1(*-CAPS)        8A-90
         DC    9AL1(*-CAPS+C' ')   91-99 BECOME D1-D9
         DC    8AL1(*-CAPS)        9A-A1
         DC    8AL1(*-CAPS+C' ')   A2-A9 BECOME E2-E9
         DC    86AL1(*-CAPS)       AA-FF
         EJECT
* TURN OFF FULL SCREEN (SPF), CLEAR AND RESET CURSOR TO ROW 1/COL 1
         SPACE 1
CLEAR    $FS   CC=EW,WCC=(AL,KBR,RMDT),SBA=(24,79),MF=L
         $FS   SBA=(1,1),RA=(1,1,00),MF=L
         $FS   SBA=(1,1),SF=(IC),MF=L
CLEARL   EQU   *-CLEAR
         SPACE 2
        LTORG
         SPACE 1
*- - - - END OF BASE REGISTERS - - - - - - - - - - - - - - - - - - - -*
         EJECT
*        HELP INFORMATION.
         SPACE 1
HELPTXT  DC   AL1(11)
         DC   CL40'DHC IS A HEX/DECIMAL CALCULATOR.'                 1
         DC   CL40'IT IS STRICTLY ''FIXED-POINT'' AND IGNORES'       2
         DC   CL40'OVERFLOW CONDITIONS. DHC WILL ACCEPT'             3
         DC   CL40'JUST ABOUT ANYTHING FOR INPUT.'                   4
         DC   CL40'OPERATIONS THAT WILL BE ACCEPTED ARE :'           5
         DC   CL40'     + FOR ADD, - FOR SUBTRACT,'                  6
         DC   CL40'     * FOR MULTIPLY, / FOR DIVIDE'                7
         DC   CL40'     (EXPONENTIATION IS NOT SUPPORTED).'          8
         DC   CL40'A SEMI-COLON (;) OR A COMMA (,) MAY BE'           9
         DC   CL40'USED TO SEPARATE INPUT EQUATIONS OR'             10
         DC   CL40'COMMANDS.'                                       11
         DC   AL1(11)
         DC   CL40'SYNTAX : SYMBOL = VALUE;'                         1
         DC   CL40'         VALUE;'                                  2
         DC   CL40'         EQUATION;'                               3
         DC   CL40'E.G. : A=23; 126H; 33+3233H-323.+7'               4
         DC   CL40'       ARE ALL VALID.'                            5
         DC   CL40'       THE DEFAULT MODE IS DECIMAL.'              6
         DC   CL40'ALL HEX VALUES IN DECIMAL MODE MUST BE'           7
         DC   CL40'     FOLLOWED BY THE CHARACTER ''H''.'            8
         DC   CL40'ALL DECIMAL VALUES IN HEX MODE MUST BE'           9
         DC   CL40'     FOLLOWED BY THE CHARACTER ''.'''            10
         DC   CL40'     (PERIOD).'                                  11
         DC   AL1(11)
         DC   CL40'COMMANDS ARE :'                                   1
         DC   CL40'/SORT   = DISPLAY A SORTED SYMBOLS TABLE'         2
         DC   CL40'/LIST   = DISPLAY THE SYMBOLS TABLE'              3
         DC   CL40'/HEX    = SET MODE TO HEX'                        4
         DC   CL40'/DEC    = SET MODE TO DECIMAL'                    5
         DC   CL40'/DISP   = DISPLAY ALL EQUATIONS AS'               6
         DC   CL40'     PROCESSED'                                   7
         DC   CL40'/NODISP = DISPLAY ONLY THE LAST RESULT'           8
         DC   CL40'     UNLESS THE INPUT ENDS BY A COMMAND'          9
         DC   CL40'/DELETE = DELETE ONE OR MORE SYMBOLS AND'        10
         DC   CL40'     THEIR VALUES FROM THE SYMBOLS TABLE'        11
         DC   AL1(12)
         DC   CL40'EXAMPLES OF INPUT :'                              1
         DC   CL40'     /HEX; START=0ABBC0; ERROR=0AC000;'           2
         DC   CL40'     OFFSET=ERROR-START; /SORT'                   3
         DC   CL40'NOTE THAT HEX VALUES BEGINNING WITH A'            4
         DC   CL40'CHARACTER MUST BE PRECEEDED BY A ZERO'            5
         DC   CL40'TO PREVENT THEIR BEING INTERPRETED AS'            6
         DC   CL40'VARIABLES.'                                       7
         DC   CL40'1) SEMI-COLONS (OR COMMAS) SEPARATE'              8
         DC   CL40'   EQUATIONS;'                                    9
         DC   CL40'2) DIVISION BY ZERO YIELDS AN ERROR'             10
         DC   CL40'   MESSAGE;'                                     11
         DC   CL40'3) 0FFFFFFFFH + 1 YIELDS ZERO.'                  12
         DC   AL1(12)
         DC   CL40'4) A PRIMATIVE LOOPING CAPABILITY IS'             1
         DC   CL40'   PRESENT, IF NEW INPUT IS NOT ENTERED'          2
         DC   CL40'   AFTER ANY DISPLAY, THE LAST INPUT'             3
         DC   CL40'   WILL BE USED. EXAMPLE :'                       4
         DC   CL40'     YOU ENTER : A = 3;'                          5
         DC   CL40'     DHC RETURNS :   3 00000003'                  6
         DC   CL40'     YOU ENTER : A = A*3;'                        7
         DC   CL40'     DHC RETURNS :   9 00000009'                  8
         DC   CL40'     YOU ENTER : <CARRIER RETURN OR'              9
         DC   CL40'                  SHIFT/ENTER>'                  10
         DC   CL40'     DHC RETURNS :  27 0000001B'                 11
         DC   CL40'     ETC...'                                     12
         DC   AL1(6)
         DC   CL40'5) THE CURRENT RESULT IS KEPT IN THE'             1
         DC   CL40'   SYMBOL ''*''... THIS MEANS THAT TO GET'        2
         DC   CL40'   THE CURRENT RESULT TIMES 2 ONE COULD'          3
         DC   CL40'   ENTER **2; TO GET THE CURRENT RESULT'          4
         DC   CL40'   TO THE THIRD POWER, ONE COULD ENTER'           5
         DC   CL40'   *****.'                                        6
         DC   XL1'0'               STOP MARKER
HELPFTX  DC   CL40'DHC IS A HEX/DECIMAL CALCULATOR. IT IS S'         1
         DC   CL40'TRICTLY ''FIXED-POINT'' AND IGNORES'
         DC   CL40'     OVERFLOW CONDITIONS. DHC WILL ACCEP'         2
         DC   CL40'T JUST ABOUT ANYTHING FOR INPUT.'
         DC   CL40'     OPERATIONS THAT WILL BE ACCEPTED AR'         3
         DC   CL40'E : + FOR ADD, - FOR SUBTRACT, * FOR'
         DC   CL40'     MULTIPLY, / FOR DIVIDE (EXPONENTIAT'         4
         DC   CL40'ION IS NOT SUPPORTED). A SEMI-COLON (;)'
         DC   CL40'     OR A COMMA (,) MAY BE USED TO SEPAR'         5
         DC   CL40'ATE INPUT EQUATIONS OR COMMANDS.'
         DC   CL40'     SYNTAX : SYMBOL = VALUE; VALUE; EQU'         6
         DC   CL40'ATION;'
         DC   CL40'     E.G. : A=23; 126H; 33+3233H-323.+7 '         7
         DC   CL40'ARE ALL VALID.'
         DC   CL40'     THE DEFAULT MODE IS DECIMAL.'                8
         DC   CL40' '
         DC   CL40'     ALL HEX VALUES IN DECIMAL MODE MUST'         9
         DC   CL40' BE FOLLOWED BY THE CHARACTER ''H''. ALL'
         DC   CL40'     DECIMAL VALUES IN HEX MODE MUST BE '        10
         DC   CL40'FOLLOWED BY THE CHARACTER ''.'' (PERIOD).'
         DC   CL40'COMMANDS ARE :'                                  11
         DC   CL40' '
         DC   CL40'    /SORT   = DISPLAY A SORTED SYMBOLS T'        12
         DC   CL40'ABLE'
         DC   CL40'    /LIST   = DISPLAY THE SYMBOLS TABLE'         13
         DC   CL40' '
         DC   CL40'    /HEX    = SET MODE TO HEX'                   14
         DC   CL40' '
         DC   CL40'    /DEC    = SET MODE TO DECIMAL'               15
         DC   CL40' '
         DC   CL40'    /DISP   = DISPLAY ALL EQUATIONS AS P'        16
         DC   CL40'ROCESSED'
         DC   CL40'    /NODISP = DISPLAY ONLY THE LAST RESU'        17
         DC   CL40'LT UNLESS THE INPUT ENDS BY A COMMAND'
         DC   CL40'    /DELETE = DELETE ONE OR MORE SYMBOLS'        18
         DC   CL40' AND THEIR VALUES FROM THE SYMBOLS TABLE'
         DC   CL40'EXAMPLES OF INPUT : /HEX; START=0ABBC0; '         1
         DC   CL40'ERROR=0AC000; OFFSET=ERROR-START; /SORT'
         DC   CL40'     NOTE THAT HEX VALUES BEGINNING WITH'         2
         DC   CL40' A CHARACTER MUST BE PRECEEDED BY A ZERO'
         DC   CL40'     TO PREVENT THEIR BEING INTERPRETED '         3
         DC   CL40'AS VARIABLES.'
         DC   CL40'1) SEMI-COLONS (OR COMMAS) SEPARATE EQUA'         4
         DC   CL40'TIONS;'
         DC   CL40'2) DIVISION BY ZERO YIELDS AN ERROR MESS'         5
         DC   CL40'AGE;'
         DC   CL40'3) 0FFFFFFFFH + 1 YIELDS ZERO.'                   6
         DC   CL40' '
         DC   CL40'4) A PRIMATIVE LOOPING CAPABILITY IS PRE'         7
         DC   CL40'SENT, IF NEW INPUT IS NOT ENTERED AFTER'
         DC   CL40'   ANY DISPLAY, THE LAST INPUT WILL BE U'         8
         DC   CL40'SED. EXAMPLE :'
         DC   CL40'     YOU ENTER : A = 3;'                          9
         DC   CL40'     DHC RETURNS :   3 00000003'
         DC   CL40'     YOU ENTER : A = A*3;'                       10
         DC   CL40'     DHC RETURNS :   9 00000009'
         DC   CL40'     YOU ENTER : <ENTER>'                        11
         DC   CL40'     DHC RETURNS :  27 0000001B'
         DC   CL40'     ETC...'                                     12
         DC   CL40' '
         DC   CL40'5) THE CURRENT RESULT IS KEPT IN THE SYM'        13
         DC   CL40'BOL ''*''... THIS MEANS THAT TO GET THE'
         DC   CL40'   CURRENT RESULT TIMES 2 ONE COULD ENTE'        14
         DC   CL40'R **2; TO GET THE CURRENT RESULT TO THE'
         DC   CL40'   THIRD POWER, ONE COULD ENTER *****.'          15
         DC   CL40' '
         DC   XL1'0'               STOP MARKER
         EJECT
TSODSECT DSECT                     WORK AREAS DESCRIPTION
         SPACE 1
TSOSAVE  DS    18F                 SAVE AREA
DEFPK    DC    2D'0'
CVDN     DC    2D'0'
EXTR    EXTRACT *-*,'S',MF=L
ATSO     DC    A(0)
LEXTR    EQU   *-EXTR
LISTSV   DC    3F'0'
QQSAVE   DC    2F'0'
SRSR14   DC    F'0'
DFSR14   DC    F'0'
TLSTART  DC    F'0'
SCRSZ    DC    F'0'
SCRLZ    DC    F'0'
PRES     DC    2F'0'
BLZR     DC    0F'0',CL8'0',2F'0'
TNAME    DC    0F'0',CL8' ',F'0'
SYMTBL   DC    0F'0',CL8'*'
SYMTBLI  DC    223F'0'
SYMTBLE  DC    4X'FF'
TSTRING  DC    XL256'0'
READINTO DC    XL256'0'
BLKSCR   DC    11CL40' '
NLSCR    EQU   (*-BLKSCR)/L'BLKSCR
TRES     DC    CL250' '
CVDNR    DC    CL13' '             DEC EDIT
CVHNR    DC    CL8' '              HEX EDIT
PROP     DC    CL1'+'
SWITCH   DC    XL1'0'              FLAGS
EQYET    EQU   X'01'               OFF - CONTROL, ON - NO CONTROL
NODISP   EQU   X'02'               OFF - DISPLAY, ON - NO DISPLAY
MODE     EQU   X'04'               OFF - DECIMAL, ON - HEXADECIMAL
RDREQ    EQU   X'08'               ON - READ REQUESTED AFTER MSG
SWSCR    EQU   X'80'               ON - RUNNING ON A VALID SCREEN
DEFDRM   DC    C'           INVALID; 0 ASSUMED'
DEFOVM   DC    C'SYMBOL TABLE OVERFLOW;'
DEFOVM1  DC    CL9' '
DELERM   DC    CL9' '
DELERM1  DC    C'NOT PREVIOUSLY DEFINED - ERROR'
DELMSG   DC    C'         DELETED'
TLUNDM   DC    C'         UNDEFINED - SET TO 0'
ZRDVM    DC    C'         = 0; DIVIDE SUPPRESSED'
         SPACE 1
TSOLEN   EQU   (((*-TSOSAVE)+7)/8)*8    WORK AREAS LENGTH
         EJECT
SCRDSECT DSECT                     SCREEN AREAS DESCRIPTION
         SPACE 1
SCRIPTR  DC    F'0'                CURRENT DATA LINES POINTER
SCRXPTR  DC    F'0'                DATA LINES POINTER CONTROL
SCRCOPYL DC    F'0'                LENGTH COPY OF INPUT TEXT (RESHOW)
SCRRPLY  DS    0CL155              AREA TO HOLD TGET REPLY
SCRPFCD  DC    XL6'0'              AID + JUNK
SCRTEXT  DC    XL149'0'            REPLY TEXT
SCRCOPY  DC    XL148'0'            COPY OF INPUT TEXT (RESHOW)
SCRSTAT  DC    XL1'0'              FLAGS
FIRST    EQU   X'01'               ON - FIRST TPUT DONE
DTCNT    EQU   X'02'               ON - DATA CONTINUE
         SPACE 1
SCRFULL  $FS   CC=W,WCC=(RMDT),SBA=(24,80),MF=L   SET BUFFER/CLEAR
         $FS   SBA=(1,1),RA=(1,1,00),MF=L
         $FS   SBA=(1,1),SF=(PROT),RA=(1,29,-),MF=L        LINE 1
         $FS   SF=(PROT,INT),TEXT='HEX/DECIMAL CALCULATOR',MF=L
         $FS   SF=(PROT),RA=(1,80,-),MF=L
         $FS   SF=(PROT),TEXT='ENTER',MF=L                 LINE 2-3
         $FS   SF=(PROT,INT),TEXT='===>',MF=L
         $FS   SF=NORMAL,MF=L
         $FS   SBA=(4,1),SF=(PROT),MF=L                    LINE 4
         $FS   TEXT='--- MODE =',MF=L
         $FS   SF=(PROT,INT),MF=L
SCRMODE  $FS   TEXT=(' ',3),MF=L
         $FS   SF=(PROT),TEXT='(PF 5/17) --- DISPLAY =',MF=L
         $FS   SF=(PROT,INT),MF=L
SCRDISP  $FS   TEXT=(' ',3),MF=L
         $FS   SF=(PROT),TEXT='(PF 6/18) ---',MF=L
         $FS   TEXT='----- <FLIP-FLOP> ---',MF=L
         $FS   SBA=(5,1),SF=(PROT),MF=L                    LINE 5
         $FS   TEXT='--- HELP:1/13 - ',MF=L
         $FS   TEXT='END:3/15/4/16 - ',MF=L
         $FS   TEXT='LIST:9/21 - ',MF=L
         $FS   TEXT='SORT:10/22 - ',MF=L
         $FS   TEXT='RESHOW:12/24/PA2 ---',MF=L
         $FS   SBA=(6,1),SF=(PROT,INT),RA=(6,72,6D),MF=L   LINE 6
SCRNXTT  $FS   TEXT=('________',8),MF=L
         $FS   SF=(PROT),MF=L
SCRDATA  DC    18CL80' '           DATA LINES (36*40)      LINE 7-24
SCRNL    EQU   (*-SCRDATA)/L'SCRDATA    NUMBER OF LINES
SCRLEN   EQU   *-SCRFULL
SCRIADD  $FS   SBA=(2,12),MF=L     INPUT AREA BUFFER ADDR. LINE 2
SCRINAR  DC    XL148'0'            INPUT AREA
SCRPTIC  $FS   SBA=(1,1),SF=(PT,IC),MF=L
SCRPTICL EQU   *-SCRPTIC
         SPACE 1
SCRDLEN  EQU   (((*-SCRIPTR)+7)/8)*8    SCREEN AREAS LENGTH
         SPACE 2
         END
