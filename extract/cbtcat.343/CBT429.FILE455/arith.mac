ARTH     TITLE '--- TSO FULL-SCREEN ARITHMETIC COMMAND ---'
         PRINT OFF
* Here follows the Assembly SYSPARM(...) options process which allows
*        you to select :
*        1. NONE or omitted = no list of macros development
*           FULL = list all macros development
*        2. US or omitted = edit numbers as usual in USA
*           EU = edit numbers as European like it
*        How to define options : i.e - SYSPARM(FULL)
*                                      SYSPARM(,EU)
*        If you want add another selection, you can easily do it
*        adjusting below the statements marked "<===", define the new
*        OPT(n) default, and supply the new option coding just before
*        the comment card marked "---> Add option(s)".
         GBLC  &EULST,&EUEDN                                  <===
         LCLA  &CN,&CT,&LN,&MX,&SB,&ST
         LCLC  &OPT(2)                                        <===
&MX      SETA  2                                              <===
&OPT(1)  SETC  'NONE'
&OPT(2)  SETC  'US'
&CN      SETA  K'&SYSPARM
         AIF   (K'&SYSPARM EQ 0).SP99
&CT      SETA  1
&SB      SETA  1
&ST      SETA  &CT
.SP1     AIF   ('&SYSPARM'(&CT,1) EQ ',').SP2
&CT      SETA  &CT+1
         AIF   (&CT LE &CN).SP1
.SP2     ANOP
&LN      SETA  &CT-&ST
         AIF   (&LN EQ 0).SP3
&OPT(&SB) SETC '&SYSPARM'(&ST,&LN)
.SP3     ANOP
&SB      SETA  &SB+1
         AIF   (&SB GT &MX).SP99
&CT      SETA  &CT+1
         AIF   (&CT GT &CN).SP99
&ST      SETA  &CT
         AGO   .SP1
.SP99    ANOP
&EULST   SETC  'GEN'
         AIF   ('&OPT(1)' EQ 'FULL').SL1
&EULST   SETC  'NOGEN'
.SL1     ANOP
&EUEDN   SETC  'EUROPE'
         AIF   ('&OPT(2)' EQ 'EU').SL99
&EUEDN   SETC  'USA'
.SL99    ANOP
* ---> Add option(s)
         MACRO
&LABEL   #GO   &NAME,&AR=I
         AIF   ('&NAME' NE '').A
         MNOTE 8,'--- NAME of routine missing (it is mandatory) ---'
         AGO   .MEND
.A       AIF   ('&AR' EQ 'D').B
&LABEL   L     R15,=A(&NAME)
         AGO   .C
.B       ANOP
&LABEL   L     R15,&NAME
.C       BASR  R14,R15
.MEND    MEND
         PRINT ON
         SPACE 1
ARITH    START 0
*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*
*    Name :    ARITH (Alias : AR)                                     *
*                                                                     *
*    Author :  Ted BESTANI                                            *
*                                                                     *
*    Purpose : This command allows TSO users to enter DO decimal and  *
*              hex arithmetic on a 3270 terminal in full-screen mode. *
*                                                                     *
*    Attributes : Non-reusable                                        *
*                                                                     *
*    Requirements : ARITH requires that VTAM or TCAM support the      *
*              FULL-SCREEN option (macros used : TGET/TPUT).          *
*              It is designed for 3278-2 terminals. It will work on   *
*              bigger toobs, but it won't use the entire screen.      *
*                                                                     *
*    Origin :  Extracted from tape CBT 93 AUG, file 173.              *
*              Updates : 1. use of FSRTN routine (FULL-SCREEN).       *
*                        2. added ESPIE to handle interrupt 0C9.      *
*                   by : MOINIL P.A.                                  *
*                        Computing Centre (TP 361)                    *
*                        J.R.C. - Ispra Establishment                 *
*                        21020 Ispra (VA), Italy                      *
*                                                                     *
*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*
         SPACE 1
         PRINT &EULST
        $DEFREG
         EJECT
        $XENT  BASE=(R12)
         LM    R10,R11,=A(WORKDBLW,WORKDBLW+4*1024)
         USING WORKDBLW,R10,R11
*        --> CHECK IF WE ARE ENTERED AS TSO COMMAND
         LR    R2,R1               GET ENTRY R1
        EXTRACT ATIOT,'S',FIELDS=(TIOT,TSO,PSB)
*        Results : BATCH-exec       TSO-background   TSO-foreground
*                +----------------+----------------+----------------+
*          APSCB +     0          +     a.PSCB     +     a.PSCB     +
*           ATSO +     a.Flag     +     a.Flag     +     a.Flag     +
*           Flag +     X'00'      +     X'00'      +     x'80'      +
*                +----------------+----------------+----------------+
*        Initial R1 -> a.CPPL (IKJCPPL) if TSO-command
*                   -> a.Comm. Area (IKJEBECA) if TSO-subcommmand
*                   -> a.Parameters List in all other cases
         L     R1,ATSO             TSO-FLAG ADDRESS
         TM    0(R1),X'80'         TSO FOREGROUND?
         BZ    ERREX               NO, BACKGROUND, FLUSH
         L     R1,APSCB            YES, GET PSCB ADDRESS
         LTR   R1,R1               TSO RUNNING?
         BZ    ERREX               NO, WHAT'S THAT? FLUSH
         USING CPPL,R2
         USING PSCB,R1
         CLC   PSCBUPT,CPPLUPT     CPPL+4 = UPT ADDRESS?
         BNE   *+L'*+10            NO
         DROP  R1
         CLC   APSCB(L'APSCB),CPPLPSCB CPPL+8 = PSCB ADDRESS?
         BE    INITOK              YES, TSO COMMAND
         LR    R1,R2
         USING IKJEBECA,R1
         L     R2,CAPTTMP          CPPL ADDRESS
         DROP  R1
         CLC   APSCB(L'APSCB),CPPLPSCB CPPL+8 = PSCB ADDRESS?
         BE    INITOK              YES, TSO SUB-COMMAND
         DROP  R2
ERREX   WTO    ' -> Only TSO foreground command allowed',              X
               ROUTCDE=11,DESC=7
         B     SRC16
INITOK  @FSI   FSBFSZ,MF=(E,FSPARM) INITIALIZE FULL-SCREEN
         LTR   R15,R15
         BZ    INFSOK
         CVD   R15,WORKDBLW
         MVC   MSG1F1,=XL4'40202120'
         ED    MSG1F1,WORKDBLW+L'WORKDBLW-2
        TPUT   MSG1,L'MSG1         PUT OUT ERROR MESSAGE
         B     SRC16
INFSOK   L     R2,ATIOT            SEARCH DD IF SNAP AVAILABLE
         USING TIODSECT,R2
SCSNAP   CLC   TIOELNGH(4),=F'0'
         BE    MARITH
         CLC   TIOEDDNM(L'TIOEDDNM),=CL8'SYSSNAP '
         BNE   *+L'*+4
         OI    OPTFS,FSSNAP        SET USER WANT SNAP SCREEN INPUT
         XR    R1,R1
         IC    R1,TIOELNGH
         ALR   R2,R1
         B     SCSNAP
         DROP  R2
*        --> ARITHMETIC main process.
MARITH   MVC   INPUT,=CL50' '      INITIALIZE INPUT FIELDS
DRBYPASS MVC   SC1LN24,ENDLNE01    NORMAL END OF MENU MSG
        $FS    SF=NORMAL,MF=(I,SC1LN03) SET NORMAL INPUT
*        --> DISPLAY MENU SCREEN.
DRBPLOOP MVC   SC1LN04,INPUT+0     MOVE OPTION REQUESTED
DRBRSHOW LM    R0,R2,=A(SCREEN1,LSCREEN1,RSCRT1)
         STM   R0,R2,ASCRIPTR      STORE PTR'S
        #GO    FULLSCR             GO DO DEMO SCREEN WORK
         B     *+L'*(R15)          HOW COMPLETE?
         B     DRBPANAL            0 - RETURN TO MENU - WILD GOTO
         B     DRERROR             4 - ERROR
         LTR   R1,R1               8 - DID USER TYPE IN MENU OPTION?
         BZ    DRBRSHOW            NO, GO PAINT MENU AGAIN
         BM    DRCLEAR             YES, BUT GO CLEAR AND END
DRBPANAL CLI   INPUT+0,C' '        NO OPTION?
         BE    DRBYPASS            YES
         CLI   INPUT+0,C'0'        OR, END?
         BE    DRCLEAR             YES, GO HOME ...
         CLI   INPUT+0,C'H'        OR, HELP?
         BNE   DRBTO1              NO, TRY NEXT OPTION
DRHINIT $FS    SF=NORMAL,MF=(I,SCHLN24I) SET NORMAL INPUT
         MVI   INPUT+0,C' '        RESET INPUT FIELD
DRHSHOW  MVC   SCHLN24R,INPUT+0
         LM    R0,R2,=A(SCREENH,LSCREENH,RSCRTH)
         STM   R0,R2,ASCRIPTR      STORE PTR'S
        #GO    FULLSCR             GO DO DEMO SCREEN WORK
         B     *+L'*(R15)          HOW COMPLETE?
         B     DRHINIT             0 - RESHOW
         B     DRERROR             4 - ERROR
         LTR   R1,R1               8 - DID USER TYPE IN MENU OPTION?
         BZ    DRHINIT             NO, RESHOW
         BM    DRHQUIT             YES, RETURN TO OPTION MENU
        $FS    SF=(INT),MF=(I,SCHLN24I) SET ERROR INPUT
         B     DRHSHOW
DRHQUIT  MVI   INPUT+0,C' '        RESET OPTION MENU
         B     DRBYPASS            AND BACK TO MENU
DRBTO1   CLI   INPUT+0,C'1'        CVD?
         BNE   DRBTO2              NO, TRY NEXT OPTION
        #GO    RTN$CVD             YES, GO PROCESS
         B     DRFSANAL
DRBTO2   CLI   INPUT+0,C'2'        CVB?
         BNE   DRBTO3              NO, TRY NEXT OPTION
        #GO    RTN$CVB             YES, GO PROCESS
         B     DRFSANAL
DRBTO3   CLI   INPUT+0,C'3'        ADD?
         BNE   DRBTO4              NO, TRY NEXT OPTION
        #GO    RTN$ADD             YES, GO PROCESS
         B     DRFSANAL
DRBTO4   CLI   INPUT+0,C'4'        SUB?
         BNE   DRBTO5              NO, TRY NEXT OPTION
        #GO    RTN$SUB             YES, GO PROCESS
         B     DRFSANAL
DRBTO5   CLI   INPUT+0,C'5'        MUL?
         BNE   DRBTO6              NO, TRY NEXT OPTION
        #GO    RTN$MUL             YES, GO PROCESS
         B     DRFSANAL
DRBTO6   CLI   INPUT+0,C'6'        DIV?
         BNE   DRBTO7              NO, TRY NEXT OPTION
        #GO    RTN$DIV             YES, GO PROCESS
         B     DRFSANAL
DRBTO7   CLI   INPUT+0,C'7'        OPTION 7?
         BNE   DRBTO8              NO, TRY NEXT OPTION
        #GO    RTN$SCR             YES, GO PROCESS
         B     DRFSANAL
DRBTO8   CLI   INPUT+0,C'8'        OPTION 8?
         BE    DRNOTUSE            YES
         CLI   INPUT+0,C'9'        OPTION 9?
         BE    DRNOTUSE            YES
         MVC   SC1LN24,ENDLNE02    MOVE END LINE
         B     DRBSTIE             GIVE IT ANOTHER TRY
DRNOTUSE MVC   SC1LN24,ENDLNE03    MOVE END LINE
DRBSTIE $FS    SF=(INT),MF=(I,SC1LN03) SET ERROR INPUT
         B     DRBPLOOP            GIVE IT ANOTHER TRY
DRFSANAL B     *+L'*(R15)          HOW COMPLETE?
         B     DRBPANAL            0 - RETURN TO MENU - WILD GOTO
         B     DRERROR             4 - ERROR
         B     DRBYPASS            8 - GO PUT OUT MENU AGAIN
DRERROR  CVD   R15,WORKDBLW
         MVC   MSG2F2,=XL4'40202120'
         ED    MSG2F2,WORKDBLW+L'WORKDBLW-2
         XR    R0,R0
         IC    R0,OPTFS
         STC   R0,MSG2F1+1
         SRL   R0,4
         STC   R0,MSG2F1
         NC    MSG2F1,=XL2'0F0F'
         TR    MSG2F1,TRHEXCHR
         LA    R0,L'MSG2
         STH   R0,ERRMSL
         LA    R0,MSG2
         ST    R0,ERRMSA
DRCLEAR  MVI   OPTFS,FSEXIT        EXIT FULL-SCREEN MODE
        @FS    OPTFS,MF=(E,FSPARM)
         LR    R2,R15              RETAIN RETURN CODE
         XR    R0,R0
         ICM   R0,B'0011',ERRMSL
         BZ    NOMSGE
         L     R1,ERRMSA
        TPUT   (1),(0)             PUT OUT ERROR MESSAGE
NOMSGE   LTR   R15,R2
         BZ    QUIT
         CVD   R15,WORKDBLW
         MVC   MSG2F2,=XL4'40202120'
         ED    MSG2F2,WORKDBLW+L'WORKDBLW-2
         XR    R0,R0
         IC    R0,OPTFS
         STC   R0,MSG2F1+1
         SRL   R0,4
         STC   R0,MSG2F1
         NC    MSG2F1,=XL2'0F0F'
         TR    MSG2F1,TRHEXCHR
        TPUT   MSG2,L'MSG2
SRC16    LA    R15,16              SET RC=16
QUIT    $XRET  CC=(R15)
         SPACE 1
        LTORG
         SPACE 1
SCREEN1  $FS   CC=EW,WCC=(KBR,RMDT),SBA=(1,1),RA=(1,1,00),MF=L
         $FS   SBA=(1,1),SF=(SKIP,INT),MF=L
         $FS   SBA=(1,19),MF=L
         $FS   TEXT='T S O   A R I T H M E T I C   C O M M A N D',MF=L
         $FS   SBA=(2,1),RA=(3,1,-),MF=L
         $FS   SBA=(3,80),MF=L
SC1LN03  $FS   SF=NORMAL,MF=L
SC1LN04  $FS   TEXT=(' ',1),MF=L
         $FS   SF=(SKIP,INT),TEXT='<====',MF=L
         $FS   SF=(SKIP),TEXT='Enter',MF=L
         $FS   SF=(SKIP,INT),TEXT='option',MF=L
         $FS   SF=(SKIP),TEXT='desired from menu below',MF=L
         $FS   SBA=(5,8),TEXT='(or you may use the',MF=L
         $FS   SF=(SKIP,INT),TEXT='PF-keys 1-9',MF=L
         $FS   SF=(SKIP),MF=L
         $FS   TEXT='to select the corresponding option)',MF=L
         $FS   SF=(SKIP,INT),MF=L
         $FS   SBA=(7,1),RA=(8,1,-),MF=L
         $FS   SBA=(9,1),TEXT='H - HELP',MF=L
         $FS   SF=(SKIP),TEXT='(short write-up)',MF=L
         $FS   SBA=(10,80),SF=(SKIP,INT),TEXT='0 - END',MF=L
         $FS   SF=(SKIP),TEXT='the Arithmetic command',MF=L
         $FS   SBA=(11,40),SF=(SKIP,INT),TEXT='5',MF=L
         $FS   SF=(SKIP),TEXT='- Multiplication',MF=L
         $FS   SBA=(12,80),SF=(SKIP,INT),TEXT='1',MF=L
         $FS   SF=(SKIP),TEXT='- Convert Hex to Decimal',MF=L
         $FS   SBA=(13,40),SF=(SKIP,INT),TEXT='6',MF=L
         $FS   SF=(SKIP),TEXT='- Division',MF=L
         $FS   SBA=(14,80),SF=(SKIP,INT),TEXT='2',MF=L
         $FS   SF=(SKIP),TEXT='- Convert Decimal to Hex',MF=L
         $FS   SBA=(15,40),SF=(SKIP,INT),TEXT='7',MF=L
         $FS   SF=(SKIP),TEXT='- Convert 3270 Buffer Addresses',MF=L
         $FS   SBA=(16,80),SF=(SKIP,INT),TEXT='3',MF=L
         $FS   SF=(SKIP),TEXT='- Addition',MF=L
         $FS   SBA=(17,40),SF=(SKIP,INT),TEXT='8',MF=L
         $FS   SF=(SKIP),TEXT='- "not in use"',MF=L
         $FS   SBA=(18,80),SF=(SKIP,INT),TEXT='4',MF=L
         $FS   SF=(SKIP),TEXT='- Subtraction',MF=L
         $FS   SBA=(19,40),SF=(SKIP,INT),TEXT='9',MF=L
         $FS   SF=(SKIP),TEXT='- "not in use"',MF=L
         $FS   SBA=(20,80),SF=(SKIP,INT),MF=L
         $FS   TEXT='Note :',MF=L
         $FS   SF=(SKIP),TEXT='To',MF=L
         $FS   SF=(SKIP,INT),TEXT='terminate,',MF=L
         $FS   SF=(SKIP),TEXT='you may also use any one of the',MF=L
         $FS   SF=(SKIP,INT),TEXT='PA1-PA2-PA3',MF=L
         $FS   SF=(SKIP),TEXT='keys.',MF=L
         $FS   SBA=(23,80),MF=L
SC1LN24  $FS   TEXT=(' ',88),MF=L
SC1CSRP  $FS   SBA=(4,1),SF=(IC),MF=L
LSCREEN1 EQU   *-SCREEN1
         SPACE 1
         DROP  R12
         EJECT
*------> READ "SCREEN1" PROCESS ROUTINE.
*        AT EXIT : R1=INPUT TRUE LENGTH AND R3=INPUT SCAN LENGTH.
         SPACE 1
RSCRT1  $XENT  BASE=(R9)
         XR    R2,R2               INITIAL COUNT
R1LOOP  @FSR   ,                   GET REPLY TEXT
         LTR   R15,R15             NO MORE FIELDS MODIFIED?
         BNZ   R1PRCD              NO
         L     R1,4(R13)           YES, END, GET PREVIOUS SAVE AREA
         ST    R2,24(R1)           PASS BACK COUNT IN R1
         LA    R2,1                AND INPUT SCAN LENGTH IN R3
         ST    R2,32(R1)
         XR    R15,R15             EXIT
        $XRET  CC=(R15)
R1PRCD   CLC   SC1CSF1,0(R15)
         BNE   R1LOOP              UNEXPECTED (CHECK SCREEN IMAGE)
         LTR   R1,R1
         BZ    R1FC1               FIELD CLEARED (CANC FC)
         CH    R1,=H'1'
         BNE   R1LOOP              UNEXPECTED (CHECK SCREEN IMAGE)
         MVI   INPUT+0,C' '        FOR UPPERCASE
         OC    INPUT+0(1),3(R15)   COPY OPTION
         B     R1BF1
R1FC1    MVI   INPUT+0,C' '        OPTION CLEARED
R1BF1    LA    R2,1(R2)            BUMP COUNT
         B     R1LOOP
SC1CSF1  $FS   SBA=(4,1),MF=L
         SPACE 1
        LTORG
         SPACE 1
         DROP  R9
         EJECT
SCREENH  $FS   CC=EW,WCC=(KBR,RMDT),SBA=(1,1),RA=(1,1,00),MF=L
         $FS   SBA=(1,1),SF=(SKIP,INT),MF=L
         $FS   SBA=(1,19),MF=L
         $FS   TEXT='T S O   A R I T H M E T I C   C O M M A N D',MF=L
         $FS   SBA=(2,1),RA=(3,1,-),MF=L
         $FS   TEXT='Function :',MF=L
         $FS   SF=(SKIP),TEXT='To do',MF=L
         $FS   SF=(SKIP,INT),TEXT='HEX',MF=L
         $FS   SF=(SKIP),TEXT='and',MF=L
         $FS   SF=(SKIP,INT),TEXT='DECIMAL',MF=L
         $FS   SF=(SKIP),TEXT='integer arithmetic on',MF=L
         $FS   SF=(SKIP,INT),TEXT='3278/9 CRT',MF=L
         $FS   SF=(SKIP),TEXT='terminals in',MF=L
         $FS   SBA=(4,12),TEXT='full-screen mode.',MF=L
         $FS   SBA=(5,2),RA=(5,80,-),MF=L
         $FS   SF=(SKIP,INT),TEXT='Syntax :   ARITH',MF=L
         $FS   SF=(SKIP),TEXT='- Alias :',MF=L
         $FS   SF=(SKIP,INT),TEXT='AR',MF=L
         $FS   SBA=(7,12),TEXT='Description :',MF=L
         $FS   SF=(SKIP),MF=L
         $FS   TEXT='The main goal of this command is to do',MF=L
         $FS   SF=(SKIP,INT),TEXT='HEX',MF=L
         $FS   SF=(SKIP),TEXT='and',MF=L
         $FS   SF=(SKIP,INT),TEXT='DECIMAL',MF=L
         $FS   SBA=(8,25),SF=(SKIP),MF=L
         $FS   TEXT='integer arithmetic in full-screen mode on',MF=L
         $FS   SF=(SKIP,INT),TEXT='3278/9 CRT',MF=L
         $FS   SBA=(9,25),SF=(SKIP),TEXT='terminals. ',MF=L
         $FS   TEXT='The command is menu driven.',MF=L
         $FS   SBA=(10,12),TEXT='In addition',MF=L
         $FS   SF=(SKIP,INT),TEXT='HEX',MF=L
         $FS   SF=(SKIP),TEXT='and',MF=L
         $FS   SF=(SKIP,INT),TEXT='DECIMAL',MF=L
         $FS   SF=(SKIP),TEXT='arithmetic, an',MF=L
         $FS   SF=(SKIP,INT),TEXT='option',MF=L
         $FS   SF=(SKIP),TEXT='is available to do',MF=L
         $FS   SBA=(11,25),SF=(SKIP,INT),TEXT='HEX',MF=L
         $FS   SF=(SKIP),TEXT='to',MF=L
         $FS   SF=(SKIP,INT),TEXT='DECIMAL',MF=L
         $FS   SF=(SKIP),TEXT='and',MF=L
         $FS   SF=(SKIP,INT),TEXT='DECIMAL',MF=L
         $FS   SF=(SKIP),TEXT='to',MF=L
         $FS   SF=(SKIP,INT),TEXT='HEX',MF=L
         $FS   SF=(SKIP),TEXT='conversions.',MF=L
         $FS   SBA=(12,11),SF=(SKIP,INT),TEXT='Another option',MF=L
         $FS   SF=(SKIP),TEXT='gives the user ',MF=L
         $FS   TEXT='ability to convert',MF=L
         $FS   SF=(SKIP,INT),TEXT='3270 Screen Buffer',MF=L
         $FS   SBA=(13,25),TEXT='Addresses',MF=L
         $FS   SF=(SKIP),TEXT='to',MF=L
         $FS   SF=(SKIP,INT),TEXT='Row/Column Addresses,',MF=L
         $FS   SF=(SKIP),TEXT='and vice versa.',MF=L
         $FS   SBA=(14,12),TEXT='To get back to the menu ',MF=L
         $FS   TEXT='screen from any of the option screens,',MF=L
         $FS   SBA=(15,26),TEXT='simply press the',MF=L
         $FS   SF=(SKIP,INT),TEXT='PA1 (ATTN)',MF=L
         $FS   SF=(SKIP),TEXT='key. Another way of doing',MF=L
         $FS   SBA=(16,26),TEXT='this is to enter',MF=L
         $FS   SF=(SKIP,INT),TEXT='=X',MF=L
         $FS   SF=(SKIP),TEXT='and press',MF=L
         $FS   SF=(SKIP,INT),TEXT='ENTER.',MF=L
         $FS   SF=(SKIP),TEXT='In fact, you can',MF=L
         $FS   SBA=(17,26),TEXT='get around in',MF=L
         $FS   SF=(SKIP,INT),TEXT='ARITH',MF=L
         $FS   SF=(SKIP),TEXT='if you can remember the',MF=L
         $FS   SF=(SKIP,INT),TEXT='option',MF=L
         $FS   SBA=(18,26),TEXT='numbers',MF=L
         $FS   SF=(SKIP),TEXT='by entering an',MF=L
         $FS   SF=(SKIP,INT),TEXT='=',MF=L
         $FS   SF=(SKIP),TEXT='sign followed by the',MF=L
         $FS   SF=(SKIP,INT),TEXT='option',MF=L
         $FS   SBA=(19,26),TEXT='number',MF=L
         $FS   SF=(SKIP),TEXT='and pressing',MF=L
         $FS   SF=(SKIP,INT),TEXT='ENTER,',MF=L
         $FS   SF=(SKIP),TEXT='but',MF=L
         $FS   SF=(SKIP,INT),TEXT='=0',MF=L
         $FS   SF=(SKIP),TEXT='will return to',MF=L
         $FS   SF=(SKIP,INT),TEXT='TSO.',MF=L
         $FS   SBA=(20,11),SF=(SKIP),TEXT='Also',MF=L
         $FS   SF=(SKIP,INT),TEXT='PF-keys',MF=L
         $FS   SF=(SKIP),TEXT='for corresponding',MF=L
         $FS   SF=(SKIP,INT),TEXT='options (1-9)',MF=L
         $FS   SF=(SKIP),TEXT='are availables.',MF=L
         $FS   SBA=(21,2),RA=(21,80,-),MF=L
         $FS   SF=(SKIP,INT),TEXT='Operands :',MF=L
         $FS   SF=(SKIP),MF=L
         $FS   TEXT='None, other than as specified above.',MF=L
         $FS   SBA=(22,80),SF=(SKIP,INT),MF=L
         $FS   RA=(24,1,-),MF=L
         $FS   TEXT='====>',MF=L
SCHLN24I $FS   SF=NORMAL,MF=L
SCHLN24R $FS   TEXT=(' ',1),MF=L
         $FS   SF=(SKIP,INT),TEXT='<====',MF=L
         $FS   SF=(SKIP),TEXT='To',MF=L
         $FS   SF=(SKIP,INT),TEXT='return',MF=L
         $FS   SF=(SKIP),TEXT='to menu press',MF=L
         $FS   SF=(SKIP,INT),TEXT='PA1',MF=L
         $FS   SF=(SKIP),TEXT='key.',MF=L
         $FS   SBA=(24,7),SF=(IC),MF=L
LSCREENH EQU   *-SCREENH
         EJECT
*------> READ "SCREENH" PROCESS ROUTINE.
*        AT EXIT : R1=INPUT TRUE LENGTH AND R3=INPUT SCAN LENGTH.
         SPACE 1
RSCRTH  $XENT  BASE=(R9)
         XR    R2,R2               INITIAL COUNT
RHLOOP  @FSR   ,                   GET REPLY TEXT
         LTR   R15,R15             NO MORE FIELDS MODIFIED?
         BNZ   RHPRCD              NO
         L     R1,4(R13)           YES, END, GET PREVIOUS SAVE AREA
         ST    R2,24(R1)           PASS BACK COUNT IN R1
         LA    R2,1                AND INPUT SCAN LENGTH IN R3
         ST    R2,32(R1)
         XR    R15,R15             EXIT
        $XRET  CC=(R15)
RHPRCD   CLC   SCHCSF1,0(R15)
         BNE   RHLOOP              UNEXPECTED (CHECK SCREEN IMAGE)
         LTR   R1,R1
         BZ    RHFC1               FIELD CLEARED (CANC FC)
         CH    R1,=H'1'
         BNE   RHLOOP              UNEXPECTED (CHECK SCREEN IMAGE)
         MVI   INPUT+0,C' '        FOR UPPERCASE
         OC    INPUT+0(1),3(R15)   COPY OPTION
         B     RHBF1
RHFC1    MVI   INPUT+0,C' '        OPTION CLEARED
RHBF1    LA    R2,1(R2)            BUMP COUNT
         B     RHLOOP
SCHCSF1  $FS   SBA=(24,7),MF=L
         SPACE 1
        LTORG
         SPACE 1
         DROP  R9
         EJECT
*------> THIS ROUTINE PROCESSES THE CONVERT-TO-DECIMAL SCREEN.
*        AT EXIT : R15 = 0, 4 OR 8.
         SPACE 1
RTN$CVD $XENT  BASE=(R9)
         MVC   INPUT+0(8),=CL50' ' CLEAR INPUT
         MVC   SC2LN10,=CL50' '     " "  OUTPUT
RCVDINIT MVC   SC2LN24,ENDLNE04    PUT OUT BEGINNING MESSAGE
        $FS    SF=NORMAL,MF=(I,SC2LN07) SET NORMAL INPUT
RCVDLOOP MVC   SC2LN08,INPUT+0     PUT DATA INTO SCREEN
         LM    R0,R2,=A(SCREEN2,LSCREEN2,RSCRT2)
         STM   R0,R2,ASCRIPTR      STORE PTR'S
        #GO    FULLSCR             GO DO DEMO SCREEN WORK
         B     *+L'*(R15)          HOW COMPLETE?
         B     R$CVDX              0 - RETURN TO MENU - WILD GOTO
         B     R$CVDX              4 - ERROR
         LTR   R1,R1               8 - DID USER TYPE IN?
         BZ    RCVDLOOP            NO, PUT SCREEN BACK OUT
         BP    *+L'*+8             YES, GO PROCESS
         MVI   INPUT+0,C' '        ELSE, RESET OPTION MENU
         B     R$CVDX              AND RETURN TO MENU
         MVC   HDINPUT,INPUT+0     MOVE INPUT NUMBER
        #GO    HEXDEC              CONVERT HEX TO DEC
         CLI   HDRC,C'0'           DID IT GO OK?
         BNE   RCVDBAD             NO, PUT OUT ERROR MESSAGE
         MVI   RESULTSW,C'1'       INDICATE A CURRENT RESULT
         MVI   RESULTRD,C'D'       INDICATE RESULT IN DECIMAL
         ZAP   RESULT99,HDOUTDEC   SAVE CURRENT RESULT
         MVC   INPUT+0(8),HDINPUT  PUT DATA BACK
         MVC   SC2LN10,DECEDIT     MOVE EDIT MASK
         ED    SC2LN10,HDOUTDEC    EDIT THE OUTPUT
         CLI   SC2LN10+L'SC2LN10-1,C' ' IS IT A SPACE?
         BNE   RCVDINIT            NO, GO PUT ORIGINAL SCREEN OUT
         MVI   SC2LN10+L'SC2LN10-1,C'+' WAS A SPACE, REPLACE WITH A +
         B     RCVDINIT            PUT ORIGINAL SCREEN BACK OUT
RCVDBAD  MVC   SC2LN24,ENDLNE05    PUT OUT ERROR MESSAGE
        $FS    SF=(INT),MF=(I,SC2LN07) SET ERROR INPUT
         MVC   SC2LN10,=CL50' '    CLEAR OUTPUT
         B     RCVDLOOP
R$CVDX  $XRET  CC=(R15)
         SPACE 1
        LTORG
         SPACE 1
SCREEN2  $FS   CC=EW,WCC=(KBR,RMDT),SBA=(1,1),RA=(1,1,00),MF=L
         $FS   SBA=(1,1),SF=(SKIP,INT),MF=L
         $FS   SBA=(1,19),MF=L
         $FS   TEXT='T S O   A R I T H M E T I C   C O M M A N D',MF=L
         $FS   SBA=(2,1),RA=(3,1,-),MF=L
         $FS   SBA=(4,6),SF=(SKIP),MF=L
         $FS   TEXT='====   C O N V E R T   T O   D E C I M A L',MF=L
         $FS   TEXT='   P R O C E S S O R   ====',MF=L
         $FS   SBA=(5,80),SF=(SKIP,INT),MF=L
         $FS   RA=(7,1,-),MF=L
         $FS   SBA=(7,80),MF=L
SC2LN07  $FS   SF=NORMAL,MF=L
SC2LN08  $FS   TEXT=(' ',8),MF=L
         $FS   SF=(SKIP,INT),TEXT='<====',MF=L
         $FS   SF=(SKIP),TEXT='Enter',MF=L
         $FS   SF=(SKIP,INT),TEXT='Hex value',MF=L
         $FS   SF=(SKIP),TEXT='that you wish converted to',MF=L
         $FS   SF=(SKIP,INT),TEXT='Decimal',MF=L
         $FS   SBA=(9,80),SF=(SKIP,INT),MF=L
SC2LN10  $FS   TEXT=(' ',21),MF=L
         $FS   SF=(SKIP),TEXT='<====',MF=L
         $FS   SF=(SKIP,INT),TEXT='Result ',MF=L
         $FS   SF=(SKIP),RA=(10,80,=),MF=L
         $FS   SBA=(23,80),MF=L
SC2LN24  $FS   TEXT=(' ',88),MF=L
SC2CSRP  $FS   SBA=(8,1),SF=(IC),MF=L
LSCREEN2 EQU   *-SCREEN2
         SPACE 1
         DROP  R9
         EJECT
*------> INPUT "SCREEN2" PROCESS ROUTINE.
*        AT EXIT : R1=INPUT TRUE LENGTH AND R3=INPUT SCAN LENGTH.
         SPACE 1
RSCRT2  $XENT  BASE=(R9)
         XR    R2,R2               INITIAL COUNT
R2LOOP  @FSR   ,                   GET REPLY TEXT
         LTR   R15,R15             NO MORE FIELDS MODIFIED?
         BNZ   R2PRCD              NO
         L     R1,4(R13)           YES, END, GET PREVIOUS SAVE AREA
         ST    R2,24(R1)           PASS BACK COUNT IN R1
         LA    R2,8                AND INPUT SCAN LENGTH IN R3
         ST    R2,32(R1)
         XR    R15,R15             EXIT
        $XRET  CC=(R15)
R2PRCD   CLC   SC2CSF1,0(R15)
         BNE   R2LOOP              UNEXPECTED (CHECK SCREEN IMAGE)
         LTR   R1,R1
         BZ    R2FC1               FIELD CLEARED (CANC FC)
         CH    R1,=H'8'
         BH    R2LOOP              UNEXPECTED (CHECK SCREEN IMAGE)
         MVC   INPUT+0(8),=CL50' ' FOR UPPERCASE
         SH    R1,=H'1'
         EX    R1,R2OF1            COPY HEX VALUE
         B     R2BF1
R2FC1    MVC   INPUT+0(8),=CL50' ' HEX VALUE CLEARED
R2BF1    LA    R2,8(R2)            BUMP COUNT
         B     R2LOOP
R2OF1    OC    INPUT+0(*-*),3(R15) <<EXECUTED>>
SC2CSF1  $FS   SBA=(8,1),MF=L
         SPACE 1
        LTORG
         SPACE 1
         DROP  R9
         EJECT
*------> THIS ROUTINE PROCESSES THE CONVERT-TO-HEX SCREEN.
*        AT EXIT : R15 = 0, 4 OR 8.
         SPACE 1
RTN$CVB $XENT  BASE=(R9)
         MVC   INPUT+0(16),=CL50' ' CLEAR INPUT
         MVC   SC3LN10,=CL50' '     " "  OUTPUT
RCVBINIT MVC   SC3LN24,ENDLNE04    PUT OUT BEGINNING MESSAGE
        $FS    SF=NORMAL,MF=(I,SC3LN07) SET NORMAL INPUT
RCVBLOOP MVC   SC3LN08,INPUT+0     PUT DATA INTO SCREEN
         LM    R0,R2,=A(SCREEN3,LSCREEN3,RSCRT3)
         STM   R0,R2,ASCRIPTR      STORE PTR'S
        #GO    FULLSCR             GO DO DEMO SCREEN WORK
         B     *+L'*(R15)          HOW COMPLETE?
         B     R$CVBX              0 - RETURN TO MENU - WILD GOTO
         B     R$CVBX              4 - ERROR
         LTR   R1,R1               8 - DID USER TYPE IN?
         BZ    RCVBLOOP            NO, PUT SCREEN BACK OUT
         BP    *+L'*+8             YES, GO PROCESS
         MVI   INPUT+0,C' '        ELSE, RESET OPTION MENU
         B     R$CVBX              AND RETURN TO MENU
         MVC   DHINPUT,INPUT       MOVE INPUT NUMBER
        #GO    DECHEX              CONVERT TO HEX
         CLI   DHRC,C'0'           DID IT GO OK?
         BNE   RCVBBAD             NO, PUT OUT ERROR MESSAGE
         MVI   RESULTSW,C'1'       INDICATE A CURRENT RESULT
         MVI   RESULTRD,C'X'       INDICATE RESULT IN HEX
         ZAP   RESULT99,DHOUTDEC   SAVE CURRENT RESULT
         MVC   INPUT+0(16),DHINPUT PUT DATA BACK
         MVC   SC3LN10,DHOUTCHR    MOVE THE OUTPUT
         B     RCVBINIT            PUT ORIGINAL SCREEN BACK OUT
RCVBBAD  MVC   SC3LN24,ENDLNE05    PUT OUT ERROR MESSAGE
        $FS    SF=(INT),MF=(I,SC3LN07) SET ERROR INPUT
         MVC   SC3LN10,=CL50' '    CLEAR OUTPUT
         B     RCVBLOOP
R$CVBX  $XRET  CC=(R15)
         SPACE 1
        LTORG
         SPACE 1
SCREEN3  $FS   CC=EW,WCC=(KBR,RMDT),SBA=(1,1),RA=(1,1,00),MF=L
         $FS   SBA=(1,1),SF=(SKIP,INT),MF=L
         $FS   SBA=(1,19),MF=L
         $FS   TEXT='T S O   A R I T H M E T I C   C O M M A N D',MF=L
         $FS   SBA=(2,1),RA=(3,1,-),MF=L
         $FS   SBA=(4,3),SF=(SKIP),MF=L
         $FS   TEXT='====  C O N V E R T   T O   H E X A D E C ',MF=L
         $FS   TEXT='I M A L   P R O C E S S O R  ====',MF=L
         $FS   SBA=(5,80),SF=(SKIP,INT),MF=L
         $FS   RA=(7,1,-),MF=L
         $FS   SBA=(7,80),MF=L
SC3LN07  $FS   SF=NORMAL,MF=L
SC3LN08  $FS   TEXT=(' ',16),MF=L
         $FS   SF=(SKIP,INT),TEXT='<====',MF=L
         $FS   SF=(SKIP),TEXT='Enter the',MF=L
         $FS   SF=(SKIP,INT),TEXT='Decimal value',MF=L
         $FS   SF=(SKIP),TEXT='that you wish converted to',MF=L
         $FS   SF=(SKIP,INT),TEXT='Hex',MF=L
         $FS   SBA=(9,80),SF=(SKIP,INT),MF=L
SC3LN10  $FS   TEXT=(' ',8),MF=L
         $FS   SF=(SKIP),TEXT='<====',MF=L
         $FS   SF=(SKIP,INT),TEXT='Result ',MF=L
         $FS   SF=(SKIP),RA=(10,80,=),MF=L
         $FS   SBA=(23,80),MF=L
SC3LN24  $FS   TEXT=(' ',88),MF=L
SC3CSRP  $FS   SBA=(8,1),SF=(IC),MF=L
LSCREEN3 EQU   *-SCREEN3
         SPACE 1
         DROP  R9
         EJECT
*------> INPUT "SCREEN3" PROCESS ROUTINE.
*        AT EXIT : R1=INPUT TRUE LENGTH AND R3=INPUT SCAN LENGTH.
         SPACE 1
RSCRT3  $XENT  BASE=(R9)
         XR    R2,R2               INITIAL COUNT
R3LOOP  @FSR   ,                   GET REPLY TEXT
         LTR   R15,R15             NO MORE FIELDS MODIFIED?
         BNZ   R3PRCD              NO
         L     R1,4(R13)           YES, END, GET PREVIOUS SAVE AREA
         ST    R2,24(R1)           PASS BACK COUNT IN R1
         LA    R2,16               AND INPUT SCAN LENGTH IN R3
         ST    R2,32(R1)
         XR    R15,R15             EXIT
        $XRET  CC=(R15)
R3PRCD   CLC   SC3CSF1,0(R15)
         BNE   R3LOOP              UNEXPECTED (CHECK SCREEN IMAGE)
         LTR   R1,R1
         BZ    R3FC1               FIELD CLEARED (CANC FC)
         CH    R1,=H'16'
         BH    R3LOOP              UNEXPECTED (CHECK SCREEN IMAGE)
         MVC   INPUT+0(16),=CL50' ' FOR UPPERCASE
         SH    R1,=H'1'
         EX    R1,R3OF1            COPY DECIMAL VALUE
         B     R3BF1
R3FC1    MVC   INPUT+0(16),=CL50' ' DECIMAL VALUE CLEARED
R3BF1    LA    R2,16(R2)           BUMP COUNT
         B     R3LOOP
R3OF1    OC    INPUT+0(*-*),3(R15) <<EXECUTED>>
SC3CSF1  $FS   SBA=(8,1),MF=L
         SPACE 1
        LTORG
         SPACE 1
         DROP  R9
         EJECT
*------> THIS ROUTINE PROCESSES THE ADD SCREEN.
*        AT EXIT : R15 = 0, 4 OR 8.
         SPACE 1
RTN$ADD $XENT  BASE=(R9)
         MVI   INPUT+0,DEFRADIX    INIT RADIX
         MVI   INPUT+17,DEFRADIX
         MVI   INPUT+34,DEFRADIX
         MVC   INPUT+1(16),=CL50' ' INIT TO SPACE
         CLI   RESULTSW,C'1'       IS THERE A CURRENT RESULT?
         BNE   RADDNOCR            NO, BYPASS
         CLI   RESULTRD,C'D'       IS CURRENT RESULT DECIMAL?
         BE    RADDRESD            YES, PROCESS DECIMAL
         UNPK  DHINPUT,RESULT99    UNPACK IT
         OI    DHINPUT+L'DHINPUT-1,C'0' CLEAR SIGN NIBBLE
        #GO    DECHEX              CONVERT NUMBER TO HEX DISPLAY
         MVC   INPUT+9(L'DHOUTCHR),DHOUTCHR PUT HEX NUMBER IN SCREEN
         MVI   INPUT+0,C'X'        INDICATE HEX RADIX
         B     RADDNOCR            BYPASS DECIMAL CODE
RADDRESD MVC   INPUT+1(16),EDUNPK  UNPACK CURRENT RESULT
         ED    INPUT+1(16),RESULT99+8 EDIT CURRENT RESULT
         MVI   INPUT+1,C'+'        INIT TO POSITIVE
         CP    RESULT99,=PL1'0'    SET CONDITION CODE
         BNL   RADDNOCR            BYPASS MOVE
         MVI   INPUT+1,C'-'        SET TO NEGATIVE
RADDNOCR MVC   INPUT+18(16),=CL50' ' INIT TO SPACE
         MVC   DIRADIX1,INPUT+0    COPY RADIX 1ST NUMBER
         MVC   DIDATA1,INPUT+1     COPY 1ST NUMBER
         MVC   DIRADIX2,INPUT+17   COPY RADIX 2ND NUMBER
         MVC   DIDATA2,INPUT+18    COPY 2ND NUMBER
         MVC   DIRADIX3,INPUT+34   COPY RADIX RESULT
         MVC   SC4LN13N,=CL50' '   CLEAR RESULT DATA
        $FS    SF=NORMAL,MF=(I,SC4LN08I) SET NORMAL INPUT
        $FS    SF=NORMAL,MF=(I,SC4LN09I)  " "
        $FS    SF=NORMAL,MF=(I,SC4LN10I)  " "
        $FS    SF=NORMAL,MF=(I,SC4LN11I)  " "
        $FS    SF=NORMAL,MF=(I,SC4LN14I)  " "
        $FS    SBA=(8,5),MF=(I,SC4CSRP) SET CURSOR TO 1ST NUMBER
         XR    R7,R7
RADDRCA  MVC   SC4LN24,ENDLNE04    POST GOOD MESSAGE
         LTR   R7,R7
         BZ    RADDINIT
        $FS    SF=NORMAL,MF=(I,(R7)) RESET ERROR INPUT
         XR    R7,R7
RADDINIT MVC   SC4LN09R,DIRADIX1   PUT DATA INTO SCREEN
         MVC   SC4LN11R,DIRADIX2
         MVC   SC4LN14R,DIRADIX3
         MVC   SC4LN08N,DIDATA1
         MVC   SC4LN10N,DIDATA2
RADDLOOP LM    R0,R2,=A(SCREEN4,LSCREEN4,RSCRT4)
         STM   R0,R2,ASCRIPTR      STORE PTR'S
        #GO    FULLSCR             GO DO DEMO SCREEN WORK
         B     *+L'*(R15)          HOW COMPLETE?
         B     R$ADDX              0 - RETURN TO MENU - WILD GOTO
         B     R$ADDX              4 - ERROR
         LTR   R1,R1               8 - DID USER TYPE IN?
         BZ    RADDLOOP            NO, PUT SCREEN BACK OUT
         BP    *+L'*+8             YES, GO PROCESS
         MVI   INPUT+0,C' '        ELSE, RESET OPTION MENU
         B     R$ADDX              AND RETURN TO MENU
        #GO    DYADIC              GO DO PRELIMINARY EDITING
         MVC   SC4LN13N,=CL50' '   CLEAR RESULT AREA
         B     *+L'*(R15)          BRANCH ON RETURN CODE
         B     RADD00              EDITING/CONVERSION OK
         B     RADD04              ERROR, RC=04
         B     RADD08              ERROR, RC=08
         B     RADD12              ERROR, RC=12
         B     RADD16              ERROR, RC=16
         B     RADD20              ERROR, RC=20
RADD00  $FS    SBA=(8,5),MF=(I,SC4CSRP) SET CURSOR TO 1ST NUMBER
         ZAP   RESULT3,RESULT1     SHIFT FIRST RESULT
         AP    RESULT3,RESULT2     ADD SECOND RESULT
         ZAP   RESULT99,RESULT3    CAPTURE CURRENT RESULT
         MVI   RESULTSW,C'1'       INDICATE CURRENT RESULT ACTIVE
         MVC   RESULTRD,DIRADIX3   INDICATE CURRENT RESULT RADIX
         CP    RESULT3,=PL1'0'     SET CONDITION CODE
         BL    *+L'*+8             IF NEGATIVE, INSERT -
         MVI   DHINPUT+L'DHINPUT-1,C'+' MOVE A POSITIVE SIGN
         B     *+L'*+4             GO TO BYPASS
         MVI   DHINPUT+L'DHINPUT-1,C'-' INSERT A - SIGN
         CLI   DIRADIX3,C'D'       DID USER WANT ANSWER IN DEC?
         BE    RADDYESD            YES, IN DECIMAL
         UNPK  DHINPUT(L'DHINPUT-1),RESULT3 SET INPUT UP
         OI    DHINPUT+L'DHINPUT-2,C'0' CLEAR SIGN NIBBLE
        #GO    DECHEX              CONVERT TO HEX
         MVC   SC4LN13N+11(L'DHOUTCHR),DHOUTCHR MOVE CONVERTED HEX
         B     RADDRCA             GO PUT SCREEN BACK OUT
RADDYESD MVC   SC4LN13N,DECEDIT2   PUT EDIT MASK IN SCREEN
         ED    SC4LN13N,RESULT3+3  EDIT DECIMAL RESULT
         CLI   SC4LN13N+L'SC4LN13N-1,C' ' IS SIGN A BLANK
         BNE   RADDRCA             NO, GO PUT SCREEN BACK OUT
         MVI   SC4LN13N+L'SC4LN13N-1,C'+' YES, REPLACE WITH A +
         B     RADDRCA             GO PUT SCREEN BACK OUT
RADD04  $FS    SBA=(9,31),MF=(I,SC4CSRP) RESET CURSOR POSITION
         LA    R2,SC4LN09I
         B     RADDBAD
RADD08  $FS    SBA=(11,31),MF=(I,SC4CSRP) RESET CURSOR POSITION
         LA    R2,SC4LN11I
         B     RADDBAD
RADD12  $FS    SBA=(14,46),MF=(I,SC4CSRP) RESET CURSOR POSITION
         LA    R2,SC4LN14I
         B     RADDBAD
RADD16  $FS    SBA=(8,5),MF=(I,SC4CSRP) RESET CURSOR POSITION
         LA    R2,SC4LN08I
         B     RADDBAD
RADD20  $FS    SBA=(10,5),MF=(I,SC4CSRP) RESET CURSOR POSITION
         LA    R2,SC4LN10I
RADDBAD  LTR   R7,R7
         BZ    RADDBADX
        $FS    SF=NORMAL,MF=(I,(R7)) RESET ERROR INPUT
RADDBADX LR    R7,R2
         MVC   SC4LN24,ENDLNE05    PUT OUT ERROR MESSAGE
        $FS    SF=(INT),MF=(I,(R7)) SET ERROR INPUT
         B     RADDINIT
R$ADDX  $XRET  CC=(R15)
         SPACE 1
        LTORG
         SPACE 1
SCREEN4  $FS   CC=EW,WCC=(KBR,RMDT),SBA=(1,1),RA=(1,1,00),MF=L
         $FS   SBA=(1,1),SF=(SKIP,INT),MF=L
         $FS   SBA=(1,19),MF=L
         $FS   TEXT='T S O   A R I T H M E T I C   C O M M A N D',MF=L
         $FS   SBA=(2,1),RA=(3,1,-),MF=L
         $FS   SBA=(4,15),SF=(SKIP),MF=L
         $FS   TEXT='====   A D D I T I O N   ',MF=L
         $FS   TEXT='P R O C E S S O R   ====',MF=L
         $FS   SBA=(5,80),SF=(SKIP,INT),MF=L
         $FS   RA=(7,1,-),MF=L
         $FS   SBA=(8,1),SF=(SKIP),TEXT='1:',MF=L
SC4LN08I $FS   SF=NORMAL,MF=L
SC4LN08N $FS   TEXT=(' ',16),MF=L
         $FS   SF=(SKIP,INT),TEXT='<====',MF=L
         $FS   SF=(SKIP),TEXT='Enter',MF=L
         $FS   SF=(SKIP,INT),TEXT='1st #',MF=L
         $FS   SF=(SKIP),TEXT='to add',MF=L
         $FS   SBA=(9,27),SF=(SKIP),TEXT='2:',MF=L
SC4LN09I $FS   SF=NORMAL,MF=L
SC4LN09R $FS   TEXT=(' ',1),MF=L
         $FS   SF=(SKIP,INT),TEXT='<====',MF=L
         $FS   SF=(SKIP),TEXT='Enter',MF=L
         $FS   SF=(SKIP,INT),TEXT='Radix',MF=L
         $FS   SBA=(10,1),SF=(SKIP),TEXT='3:',MF=L
SC4LN10I $FS   SF=NORMAL,MF=L
SC4LN10N $FS   TEXT=(' ',16),MF=L
         $FS   SF=(SKIP,INT),TEXT='<====',MF=L
         $FS   SF=(SKIP),TEXT='Enter',MF=L
         $FS   SF=(SKIP,INT),TEXT='2nd #',MF=L
         $FS   SF=(SKIP),TEXT='to add',MF=L
         $FS   SBA=(11,27),SF=(SKIP),TEXT='4:',MF=L
SC4LN11I $FS   SF=NORMAL,MF=L
SC4LN11R $FS   TEXT=(' ',1),MF=L
         $FS   SF=(SKIP,INT),TEXT='<====',MF=L
         $FS   SF=(SKIP),TEXT='Enter',MF=L
         $FS   SF=(SKIP,INT),TEXT='Radix',MF=L
         $FS   SF=(SKIP),MF=L
         $FS   SBA=(12,1),TEXT='------------------',MF=L
         $FS   TEXT='----------------',MF=L
         $FS   SBA=(13,1),SF=(SKIP,INT),MF=L
SC4LN13N $FS   TEXT=(' ',34),MF=L
         $FS   SF=(SKIP),TEXT='<====',MF=L
         $FS   SF=(SKIP,INT),TEXT='Sum',MF=L
         $FS   SF=(SKIP),RA=(13,80,=),MF=L
         $FS   SBA=(14,42),SF=(SKIP),TEXT='5:',MF=L
SC4LN14I $FS   SF=NORMAL,MF=L
SC4LN14R $FS   TEXT=(' ',1),MF=L
         $FS   SF=(SKIP,INT),TEXT='<====',MF=L
         $FS   SF=(SKIP),TEXT='Enter',MF=L
         $FS   SF=(SKIP,INT),TEXT='Radix',MF=L
         $FS   SF=(SKIP),MF=L
         $FS   SBA=(17,1),SF=(SKIP,INT),TEXT='1:',MF=L
         $FS   SF=(SKIP),TEXT='Enter 1st # to add, please ',MF=L
         $FS   TEXT='make sure item (2) is equivalent',MF=L
         $FS   SBA=(18,1),SF=(SKIP,INT),TEXT='2:',MF=L
         $FS   SF=(SKIP),TEXT='Enter Radix of 1st # to ',MF=L
         $FS   TEXT='add (D=Decimal, X=Hexadecimal)',MF=L
         $FS   SBA=(19,1),SF=(SKIP,INT),TEXT='3:',MF=L
         $FS   SF=(SKIP),TEXT='Enter 2nd # to add, please',MF=L
         $FS   TEXT=' make sure item (4) is equivalent',MF=L
         $FS   SBA=(20,1),SF=(SKIP,INT),TEXT='4:',MF=L
         $FS   SF=(SKIP),TEXT='Enter Radix of 2nd # to ',MF=L
         $FS   TEXT='add (D=Decimal, X=Hexadecimal)',MF=L
         $FS   SBA=(21,1),SF=(SKIP,INT),TEXT='5:',MF=L
         $FS   SF=(SKIP),TEXT='Enter Radix you would display ',MF=L
         $FS   TEXT='the sum (D=Decimal, X=Hexadecimal)',MF=L
         $FS   SBA=(23,80),MF=L
SC4LN24  $FS   TEXT=(' ',88),MF=L
SC4CSRP  $FS   SBA=(8,5),SF=(IC),MF=L
LSCREEN4 EQU   *-SCREEN4
         SPACE 1
         DROP  R9
         EJECT
*------> INPUT "SCREEN4" PROCESS ROUTINE.
*        AT EXIT : R1=INPUT TRUE LENGTH AND R3=INPUT SCAN LENGTH.
         SPACE 1
RSCRT4  $XENT  BASE=(R9)
         XR    R2,R2               INITIAL COUNT
R4LOOP  @FSR   ,                   GET REPLY TEXT
         LTR   R15,R15             NO MORE FIELDS MODIFIED?
         BNZ   R4PRCD              NO
         L     R1,4(R13)           YES, END, GET PREVIOUS SAVE AREA
         ST    R2,24(R1)           PASS BACK COUNT IN R1
         LA    R2,35               AND INPUT SCAN LENGTH IN R3
         ST    R2,32(R1)
         XR    R15,R15             EXIT
        $XRET  CC=(R15)
R4PRCD   CLC   SC4CSF1,0(R15)
         BE    R4FL1
         CLC   SC4CSF2,0(R15)
         BE    R4FL2
         CLC   SC4CSF3,0(R15)
         BE    R4FL3
         CLC   SC4CSF4,0(R15)
         BE    R4FL4
         CLC   SC4CSF5,0(R15)
         BE    R4FL5
         B     R4LOOP              UNEXPECTED (CHECK SCREEN IMAGE)
R4FL1    LTR   R1,R1
         BZ    R4FC1               FIELD CLEARED (CANC FC)
         CH    R1,=H'1'
         BNE   R4LOOP              UNEXPECTED (CHECK SCREEN IMAGE)
         MVI   INPUT+0,C' '        FOR UPPERCASE
         OC    INPUT+0(1),3(R15)   COPY RADIX OF 1ST NUMBER
         B     R4BF1
R4FC1    MVI   INPUT+0,C' '        RADIX OF 1ST NUMBER CLEARED
R4BF1    LA    R2,1(R2)            BUMP COUNT
         B     R4LOOP
R4FL2    LTR   R1,R1
         BZ    R4FC2               FIELD CLEARED (CANC FC)
         CH    R1,=H'16'
         BH    R4LOOP              UNEXPECTED (CHECK SCREEN IMAGE)
         MVC   INPUT+1(16),=CL50' ' FOR UPPERCASE
         SH    R1,=H'1'
         EX    R1,R4OF2            COPY 1ST NUMBER VALUE
         B     R4BF2
R4FC2    MVC   INPUT+1(16),=CL50' ' 1ST NUMBER VALUE CLEARED
R4BF2    LA    R2,16(R2)           BUMP COUNT
         B     R4LOOP
R4OF2    OC    INPUT+1(*-*),3(R15) <<EXECUTED>>
R4FL3    LTR   R1,R1
         BZ    R4FC3               FIELD CLEARED (CANC FC)
         CH    R1,=H'1'
         BNE   R4LOOP              UNEXPECTED (CHECK SCREEN IMAGE)
         MVI   INPUT+17,C' '       FOR UPPERCASE
         OC    INPUT+17(1),3(R15)  COPY RADIX OF 2ND NUMBER
         B     R4BF3
R4FC3    MVI   INPUT+17,C' '       RADIX OF 2ND NUMBER CLEARED
R4BF3    LA    R2,1(R2)            BUMP COUNT
         B     R4LOOP
R4FL4    LTR   R1,R1
         BZ    R4FC4               FIELD CLEARED (CANC FC)
         CH    R1,=H'16'
         BH    R4LOOP              UNEXPECTED (CHECK SCREEN IMAGE)
         MVC   INPUT+18(16),=CL50' ' FOR UPPERCASE
         SH    R1,=H'1'
         EX    R1,R4OF4            COPY 2ND NUMBER VALUE
         B     R4BF4
R4FC4    MVC   INPUT+18(16),=CL50' ' 2ND NUMBER VALUE CLEARED
R4BF4    LA    R2,16(R2)           BUMP COUNT
         B     R4LOOP
R4OF4    OC    INPUT+18(*-*),3(R15) <<EXECUTED>>
R4FL5    LTR   R1,R1
         BZ    R4FC5               FIELD CLEARED (CANC FC)
         CH    R1,=H'1'
         BNE   R4LOOP              UNEXPECTED (CHECK SCREEN IMAGE)
         MVI   INPUT+34,C' '       FOR UPPERCASE
         OC    INPUT+34(1),3(R15)  COPY RADIX OF RESULT
         B     R4BF5
R4FC5    MVI   INPUT+34,C' '       RADIX OF RESULT CLEARED
R4BF5    LA    R2,1(R2)            BUMP COUNT
         B     R4LOOP
SC4CSF1  $FS   SBA=(9,31),MF=L
SC4CSF2  $FS   SBA=(8,5),MF=L
SC4CSF3  $FS   SBA=(11,31),MF=L
SC4CSF4  $FS   SBA=(10,5),MF=L
SC4CSF5  $FS   SBA=(14,46),MF=L
         SPACE 1
        LTORG
         SPACE 1
         DROP  R9
         EJECT
*------> THIS ROUTINE PROCESSES THE SUBTRACT SCREEN.
*        AT EXIT : R15 = 0, 4 OR 8.
         SPACE 1
RTN$SUB $XENT  BASE=(R9)
         MVI   INPUT+0,DEFRADIX    INIT RADIX
         MVI   INPUT+17,DEFRADIX
         MVI   INPUT+34,DEFRADIX
         MVC   INPUT+1(16),=CL50' ' INIT TO SPACE
         CLI   RESULTSW,C'1'       IS THERE A CURRENT RESULT?
         BNE   RSUBNOCR            NO, BYPASS
         CLI   RESULTRD,C'D'       IS CURRENT RESULT DECIMAL?
         BE    RSUBRESD            YES, PROCESS DECIMAL
         UNPK  DHINPUT,RESULT99    UNPACK IT
         OI    DHINPUT+L'DHINPUT-1,C'0' CLEAR SIGN NIBBLE
        #GO    DECHEX              CONVERT NUMBER TO HEX DISPLAY
         MVC   INPUT+9(L'DHOUTCHR),DHOUTCHR PUT HEX NUMBER IN SCREEN
         MVI   INPUT+0,C'X'        INDICATE HEX RADIX
         B     RSUBNOCR            BYPASS DECIMAL CODE
RSUBRESD MVC   INPUT+1(16),EDUNPK  UNPACK CURRENT RESULT
         ED    INPUT+1(16),RESULT99+8 EDIT CURRENT RESULT
         MVI   INPUT+1,C'+'        INIT TO POSITIVE
         CP    RESULT99,=PL1'0'    SET CONDITION CODE
         BNL   RSUBNOCR            BYPASS MOVE
         MVI   INPUT+1,C'-'        SET TO NEGATIVE
RSUBNOCR MVC   INPUT+18(16),=CL50' ' INIT TO SPACE
         MVC   DIRADIX1,INPUT+0    COPY RADIX 1ST NUMBER
         MVC   DIDATA1,INPUT+1     COPY 1ST NUMBER
         MVC   DIRADIX2,INPUT+17   COPY RADIX 2ND NUMBER
         MVC   DIDATA2,INPUT+18    COPY 2ND NUMBER
         MVC   DIRADIX3,INPUT+34   COPY RADIX RESULT
         MVC   SC5LN13N,=CL50' '   CLEAR RESULT DATA
        $FS    SF=NORMAL,MF=(I,SC5LN08I) SET NORMAL INPUT
        $FS    SF=NORMAL,MF=(I,SC5LN09I)  " "
        $FS    SF=NORMAL,MF=(I,SC5LN10I)  " "
        $FS    SF=NORMAL,MF=(I,SC5LN11I)  " "
        $FS    SF=NORMAL,MF=(I,SC5LN14I)  " "
        $FS    SBA=(8,5),MF=(I,SC5CSRP) SET CURSOR TO 1ST NUMBER
         XR    R7,R7
RSUBRCA  MVC   SC5LN24,ENDLNE04    POST GOOD MESSAGE
         LTR   R7,R7
         BZ    RSUBINIT
        $FS    SF=NORMAL,MF=(I,(R7)) RESET ERROR INPUT
         XR    R7,R7
RSUBINIT MVC   SC5LN09R,DIRADIX1   PUT DATA INTO SCREEN
         MVC   SC5LN11R,DIRADIX2
         MVC   SC5LN14R,DIRADIX3
         MVC   SC5LN08N,DIDATA1
         MVC   SC5LN10N,DIDATA2
RSUBLOOP LM    R0,R2,=A(SCREEN5,LSCREEN5,RSCRT5)
         STM   R0,R2,ASCRIPTR      STORE PTR'S
        #GO    FULLSCR             GO DO DEMO SCREEN WORK
         B     *+L'*(R15)          HOW COMPLETE?
         B     R$SUBX              0 - RETURN TO MENU - WILD GOTO
         B     R$SUBX              4 - ERROR
         LTR   R1,R1               8 - DID USER TYPE IN?
         BZ    RSUBLOOP            NO, PUT SCREEN BACK OUT
         BP    *+L'*+8             YES, GO PROCESS
         MVI   INPUT+0,C' '        ELSE, RESET OPTION MENU
         B     R$SUBX              AND RETURN TO MENU
        #GO    DYADIC              GO DO PRELIMINARY EDITING
         MVC   SC5LN13N,=CL50' '   CLEAR RESULT AREA
         B     *+L'*(R15)          BRANCH ON RETURN CODE
         B     RSUB00              EDITING/CONVERSION OK
         B     RSUB04              ERROR, RC=04
         B     RSUB08              ERROR, RC=08
         B     RSUB12              ERROR, RC=12
         B     RSUB16              ERROR, RC=16
         B     RSUB20              ERROR, RC=20
RSUB00  $FS    SBA=(8,5),MF=(I,SC5CSRP) SET CURSOR TO 1ST NUMBER
         ZAP   RESULT3,RESULT1     SHIFT FIRST RESULT
         SP    RESULT3,RESULT2     SUBTRACT SECOND RESULT
         ZAP   RESULT99,RESULT3    CAPTURE CURRENT RESULT
         MVI   RESULTSW,C'1'       INDICATE CURRENT RESULT ACTIVE
         MVC   RESULTRD,DIRADIX3   INDICATE CURRENT RESULT RADIX
         CP    RESULT3,=PL1'0'     SET CONDITION CODE
         BL    *+L'*+8             IF NEGATIVE, INSERT -
         MVI   DHINPUT+L'DHINPUT-1,C'+' MOVE A POSITIVE SIGN
         B     *+L'*+4             GO TO BYPASS
         MVI   DHINPUT+L'DHINPUT-1,C'-' INSERT A - SIGN
         CLI   DIRADIX3,C'D'       DID USER WANT ANSWER IN DEC?
         BE    RSUBYESD            YES, IN DECIMAL
         UNPK  DHINPUT(L'DHINPUT-1),RESULT3 SET INPUT UP
         OI    DHINPUT+L'DHINPUT-2,C'0' CLEAR SIGN NIBBLE
        #GO    DECHEX              CONVERT TO HEX
         MVC   SC5LN13N+11(L'DHOUTCHR),DHOUTCHR MOVE CONVERTED HEX
         B     RSUBRCA             GO PUT SCREEN BACK OUT
RSUBYESD MVC   SC5LN13N,DECEDIT2   PUT EDIT MASK IN SCREEN
         ED    SC5LN13N,RESULT3+3  EDIT DECIMAL RESULT
         CLI   SC5LN13N+L'SC5LN13N-1,C' ' IS SIGN A BLANK
         BNE   RSUBRCA             NO, GO PUT SCREEN BACK OUT
         MVI   SC5LN13N+L'SC5LN13N-1,C'+' YES, REPLACE WITH A +
         B     RSUBRCA             GO PUT SCREEN BACK OUT
RSUB04  $FS    SBA=(9,31),MF=(I,SC5CSRP) RESET CURSOR POSITION
         LA    R2,SC5LN09I
         B     RSUBBAD
RSUB08  $FS    SBA=(11,31),MF=(I,SC5CSRP) RESET CURSOR POSITION
         LA    R2,SC5LN11I
         B     RSUBBAD
RSUB12  $FS    SBA=(14,46),MF=(I,SC5CSRP) RESET CURSOR POSITION
         LA    R2,SC5LN14I
         B     RSUBBAD
RSUB16  $FS    SBA=(8,5),MF=(I,SC5CSRP) RESET CURSOR POSITION
         LA    R2,SC5LN08I
         B     RSUBBAD
RSUB20  $FS    SBA=(10,5),MF=(I,SC5CSRP) RESET CURSOR POSITION
         LA    R2,SC5LN10I
RSUBBAD  LTR   R7,R7
         BZ    RSUBBADX
        $FS    SF=NORMAL,MF=(I,(R7)) RESET ERROR INPUT
RSUBBADX LR    R7,R2
         MVC   SC5LN24,ENDLNE05    PUT OUT ERROR MESSAGE
        $FS    SF=(INT),MF=(I,(R7)) SET ERROR INPUT
         B     RSUBINIT
R$SUBX  $XRET  CC=(R15)
         SPACE 1
        LTORG
         SPACE 1
SCREEN5  $FS   CC=EW,WCC=(KBR,RMDT),SBA=(1,1),RA=(1,1,00),MF=L
         $FS   SBA=(1,1),SF=(SKIP,INT),MF=L
         $FS   SBA=(1,19),MF=L
         $FS   TEXT='T S O   A R I T H M E T I C   C O M M A N D',MF=L
         $FS   SBA=(2,1),RA=(3,1,-),MF=L
         $FS   SBA=(4,13),SF=(SKIP),MF=L
         $FS   TEXT='====   S U B T R A C T I O N   ',MF=L
         $FS   TEXT='P R O C E S S O R   ====',MF=L
         $FS   SBA=(5,80),SF=(SKIP,INT),MF=L
         $FS   RA=(7,1,-),MF=L
         $FS   SBA=(8,1),SF=(SKIP),TEXT='1:',MF=L
SC5LN08I $FS   SF=NORMAL,MF=L
SC5LN08N $FS   TEXT=(' ',16),MF=L
         $FS   SF=(SKIP,INT),TEXT='<====',MF=L
         $FS   SF=(SKIP),TEXT='Enter',MF=L
         $FS   SF=(SKIP,INT),TEXT='1st #',MF=L
         $FS   SF=(SKIP),TEXT='to substract from',MF=L
         $FS   SBA=(9,27),SF=(SKIP),TEXT='2:',MF=L
SC5LN09I $FS   SF=NORMAL,MF=L
SC5LN09R $FS   TEXT=(' ',1),MF=L
         $FS   SF=(SKIP,INT),TEXT='<====',MF=L
         $FS   SF=(SKIP),TEXT='Enter',MF=L
         $FS   SF=(SKIP,INT),TEXT='Radix',MF=L
         $FS   SBA=(10,1),SF=(SKIP),TEXT='3:',MF=L
SC5LN10I $FS   SF=NORMAL,MF=L
SC5LN10N $FS   TEXT=(' ',16),MF=L
         $FS   SF=(SKIP,INT),TEXT='<====',MF=L
         $FS   SF=(SKIP),TEXT='Enter',MF=L
         $FS   SF=(SKIP,INT),TEXT='2nd #',MF=L
         $FS   SF=(SKIP),TEXT='to substract',MF=L
         $FS   SBA=(11,27),SF=(SKIP),TEXT='4:',MF=L
SC5LN11I $FS   SF=NORMAL,MF=L
SC5LN11R $FS   TEXT=(' ',1),MF=L
         $FS   SF=(SKIP,INT),TEXT='<====',MF=L
         $FS   SF=(SKIP),TEXT='Enter',MF=L
         $FS   SF=(SKIP,INT),TEXT='Radix',MF=L
         $FS   SF=(SKIP),MF=L
         $FS   SBA=(12,2),TEXT='------------------',MF=L
         $FS   TEXT='----------------',MF=L
         $FS   SBA=(13,1),SF=(SKIP,INT),MF=L
SC5LN13N $FS   TEXT=(' ',34),MF=L
         $FS   SF=(SKIP),TEXT='<====',MF=L
         $FS   SF=(SKIP,INT),TEXT='Difference',MF=L
         $FS   SF=(SKIP),RA=(13,80,=),MF=L
         $FS   SBA=(14,42),SF=(SKIP),TEXT='5:',MF=L
SC5LN14I $FS   SF=NORMAL,MF=L
SC5LN14R $FS   TEXT=(' ',1),MF=L
         $FS   SF=(SKIP,INT),TEXT='<====',MF=L
         $FS   SF=(SKIP),TEXT='Enter',MF=L
         $FS   SF=(SKIP,INT),TEXT='Radix',MF=L
         $FS   SF=(SKIP),MF=L
         $FS   SBA=(17,1),SF=(SKIP,INT),TEXT='1:',MF=L
         $FS   SF=(SKIP),TEXT='Enter # to subtract from, please ',MF=L
         $FS   TEXT='make sure item (2) is equivalent',MF=L
         $FS   SBA=(18,1),SF=(SKIP,INT),TEXT='2:',MF=L
         $FS   SF=(SKIP),TEXT='Enter Radix of # to subtract ',MF=L
         $FS   TEXT='from (D=Decimal, X=Hexadecimal)',MF=L
         $FS   SBA=(19,1),SF=(SKIP,INT),TEXT='3:',MF=L
         $FS   SF=(SKIP),TEXT='Enter # to subtract, please',MF=L
         $FS   TEXT=' make sure item (4) is equivalent',MF=L
         $FS   SBA=(20,1),SF=(SKIP,INT),TEXT='4:',MF=L
         $FS   SF=(SKIP),TEXT='Enter Radix of # to ',MF=L
         $FS   TEXT='subtract (D=Decimal, X=Hexadecimal)',MF=L
         $FS   SBA=(21,1),SF=(SKIP,INT),TEXT='5:',MF=L
         $FS   SF=(SKIP),TEXT='Enter Radix you would display ',MF=L
         $FS   TEXT='the difference (D=Decimal, X=Hexadecimal)',MF=L
         $FS   SBA=(23,80),MF=L
SC5LN24  $FS   TEXT=(' ',88),MF=L
SC5CSRP  $FS   SBA=(8,5),SF=(IC),MF=L
LSCREEN5 EQU   *-SCREEN5
         SPACE 1
         DROP  R9
         EJECT
*------> INPUT "SCREEN5" PROCESS ROUTINE.
*        AT EXIT : R1=INPUT TRUE LENGTH AND R3=INPUT SCAN LENGTH.
         SPACE 1
RSCRT5  $XENT  BASE=(R9)
         XR    R2,R2               INITIAL COUNT
R5LOOP  @FSR   ,                   GET REPLY TEXT
         LTR   R15,R15             NO MORE FIELDS MODIFIED?
         BNZ   R5PRCD              NO
         L     R1,4(R13)           YES, END, GET PREVIOUS SAVE AREA
         ST    R2,24(R1)           PASS BACK COUNT IN R1
         LA    R2,35               AND INPUT SCAN LENGTH IN R3
         ST    R2,32(R1)
         XR    R15,R15             EXIT
        $XRET  CC=(R15)
R5PRCD   CLC   SC5CSF1,0(R15)
         BE    R5FL1
         CLC   SC5CSF2,0(R15)
         BE    R5FL2
         CLC   SC5CSF3,0(R15)
         BE    R5FL3
         CLC   SC5CSF4,0(R15)
         BE    R5FL4
         CLC   SC5CSF5,0(R15)
         BE    R5FL5
         B     R5LOOP              UNEXPECTED (CHECK SCREEN IMAGE)
R5FL1    LTR   R1,R1
         BZ    R5FC1               FIELD CLEARED (CANC FC)
         CH    R1,=H'1'
         BNE   R5LOOP              UNEXPECTED (CHECK SCREEN IMAGE)
         MVI   INPUT+0,C' '        FOR UPPERCASE
         OC    INPUT+0(1),3(R15)   COPY RADIX OF 1ST NUMBER
         B     R5BF1
R5FC1    MVI   INPUT+0,C' '        RADIX OF 1ST NUMBER CLEARED
R5BF1    LA    R2,1(R2)            BUMP COUNT
         B     R5LOOP
R5FL2    LTR   R1,R1
         BZ    R5FC2               FIELD CLEARED (CANC FC)
         CH    R1,=H'16'
         BH    R5LOOP              UNEXPECTED (CHECK SCREEN IMAGE)
         MVC   INPUT+1(16),=CL50' ' FOR UPPERCASE
         SH    R1,=H'1'
         EX    R1,R5OF2            COPY 1ST NUMBER VALUE
         B     R5BF2
R5FC2    MVC   INPUT+1(16),=CL50' ' 1ST NUMBER VALUE CLEARED
R5BF2    LA    R2,16(R2)           BUMP COUNT
         B     R5LOOP
R5OF2    OC    INPUT+1(*-*),3(R15) <<EXECUTED>>
R5FL3    LTR   R1,R1
         BZ    R5FC3               FIELD CLEARED (CANC FC)
         CH    R1,=H'1'
         BNE   R5LOOP              UNEXPECTED (CHECK SCREEN IMAGE)
         MVI   INPUT+17,C' '       FOR UPPERCASE
         OC    INPUT+17(1),3(R15)  COPY RADIX OF 2ND NUMBER
         B     R5BF3
R5FC3    MVI   INPUT+17,C' '       RADIX OF 2ND NUMBER CLEARED
R5BF3    LA    R2,1(R2)            BUMP COUNT
         B     R5LOOP
R5FL4    LTR   R1,R1
         BZ    R5FC4               FIELD CLEARED (CANC FC)
         CH    R1,=H'16'
         BH    R5LOOP              UNEXPECTED (CHECK SCREEN IMAGE)
         MVC   INPUT+18(16),=CL50' ' FOR UPPERCASE
         SH    R1,=H'1'
         EX    R1,R5OF4            COPY 2ND NUMBER VALUE
         B     R5BF4
R5FC4    MVC   INPUT+18(16),=CL50' ' 2ND NUMBER VALUE CLEARED
R5BF4    LA    R2,16(R2)           BUMP COUNT
         B     R5LOOP
R5OF4    OC    INPUT+18(*-*),3(R15) <<EXECUTED>>
R5FL5    LTR   R1,R1
         BZ    R5FC5               FIELD CLEARED (CANC FC)
         CH    R1,=H'1'
         BNE   R5LOOP              UNEXPECTED (CHECK SCREEN IMAGE)
         MVI   INPUT+34,C' '       FOR UPPERCASE
         OC    INPUT+34(1),3(R15)  COPY RADIX OF RESULT
         B     R5BF5
R5FC5    MVI   INPUT+34,C' '       RADIX OF RESULT CLEARED
R5BF5    LA    R2,1(R2)            BUMP COUNT
         B     R5LOOP
SC5CSF1  $FS   SBA=(9,31),MF=L
SC5CSF2  $FS   SBA=(8,5),MF=L
SC5CSF3  $FS   SBA=(11,31),MF=L
SC5CSF4  $FS   SBA=(10,5),MF=L
SC5CSF5  $FS   SBA=(14,46),MF=L
         SPACE 1
        LTORG
         SPACE 1
         DROP  R9
         EJECT
*------> THIS ROUTINE PROCESSES THE MULTIPLY SCREEN.
*        AT EXIT : R15 = 0, 4 OR 8.
         SPACE 1
RTN$MUL $XENT  BASE=(R9)
         MVI   INPUT+0,DEFRADIX    INIT RADIX
         MVI   INPUT+17,DEFRADIX
         MVI   INPUT+34,DEFRADIX
         MVC   INPUT+1(16),=CL50' ' INIT TO SPACE
         CLI   RESULTSW,C'1'       IS THERE A CURRENT RESULT?
         BNE   RMULNOCR            NO, BYPASS
         CLI   RESULTRD,C'D'       IS CURRENT RESULT DECIMAL?
         BE    RMULRESD            YES, PROCESS DECIMAL
         UNPK  DHINPUT,RESULT99    UNPACK IT
         OI    DHINPUT+L'DHINPUT-1,C'0' CLEAR SIGN NIBBLE
        #GO    DECHEX              CONVERT NUMBER TO HEX DISPLAY
         MVC   INPUT+9(L'DHOUTCHR),DHOUTCHR PUT HEX NUMBER IN SCREEN
         MVI   INPUT+0,C'X'        INDICATE HEX RADIX
         B     RMULNOCR            BYPASS DECIMAL CODE
RMULRESD MVC   INPUT+1(16),EDUNPK  UNPACK CURRENT RESULT
         ED    INPUT+1(16),RESULT99+8 EDIT CURRENT RESULT
         MVI   INPUT+1,C'+'        INIT TO POSITIVE
         CP    RESULT99,=PL1'0'    SET CONDITION CODE
         BNL   RMULNOCR            BYPASS MOVE
         MVI   INPUT+1,C'-'        SET TO NEGATIVE
RMULNOCR MVC   INPUT+18(16),=CL50' ' INIT TO SPACE
         MVC   DIRADIX1,INPUT+0    COPY RADIX 1ST NUMBER
         MVC   DIDATA1,INPUT+1     COPY 1ST NUMBER
         MVC   DIRADIX2,INPUT+17   COPY RADIX 2ND NUMBER
         MVC   DIDATA2,INPUT+18    COPY 2ND NUMBER
         MVC   DIRADIX3,INPUT+34   COPY RADIX RESULT
         MVC   SC6LN13N,=CL50' '   CLEAR RESULT DATA
        $FS    SF=NORMAL,MF=(I,SC6LN08I) SET NORMAL INPUT
        $FS    SF=NORMAL,MF=(I,SC6LN09I)  " "
        $FS    SF=NORMAL,MF=(I,SC6LN10I)  " "
        $FS    SF=NORMAL,MF=(I,SC6LN11I)  " "
        $FS    SF=NORMAL,MF=(I,SC6LN14I)  " "
        $FS    SBA=(8,5),MF=(I,SC6CSRP) SET CURSOR TO 1ST NUMBER
         XR    R7,R7
RMULRCA  MVC   SC6LN24,ENDLNE04    POST GOOD MESSAGE
         LTR   R7,R7
         BZ    RMULINIT
        $FS    SF=NORMAL,MF=(I,(R7)) RESET ERROR INPUT
         XR    R7,R7
RMULINIT MVC   SC6LN09R,DIRADIX1   PUT DATA INTO SCREEN
         MVC   SC6LN11R,DIRADIX2
         MVC   SC6LN14R,DIRADIX3
         MVC   SC6LN08N,DIDATA1
         MVC   SC6LN10N,DIDATA2
RMULLOOP LM    R0,R2,=A(SCREEN6,LSCREEN6,RSCRT6)
         STM   R0,R2,ASCRIPTR      STORE PTR'S
        #GO    FULLSCR             GO DO DEMO SCREEN WORK
         B     *+L'*(R15)          HOW COMPLETE?
         B     R$MULX              0 - RETURN TO MENU - WILD GOTO
         B     R$MULX              4 - ERROR
         LTR   R1,R1               8 - DID USER TYPE IN?
         BZ    RMULLOOP            NO, PUT SCREEN BACK OUT
         BP    *+L'*+8             YES, GO PROCESS
         MVI   INPUT+0,C' '        ELSE, RESET OPTION MENU
         B     R$MULX              AND RETURN TO MENU
        #GO    DYADIC              GO DO PRELIMINARY EDITING
         MVC   SC6LN13N,=CL50' '   CLEAR RESULT AREA
         B     *+L'*(R15)          BRANCH ON RETURN CODE
         B     RMUL00              EDITING/CONVERSION OK
         B     RMUL04              ERROR, RC=04
         B     RMUL08              ERROR, RC=08
         B     RMUL12              ERROR, RC=12
         B     RMUL16              ERROR, RC=16
         B     RMUL20              ERROR, RC=20
RMUL00  $FS    SBA=(8,5),MF=(I,SC6CSRP) SET CURSOR TO 1ST NUMBER
         ZAP   RESULT3,RESULT1     SHIFT FIRST RESULT
         MP    RESULT3,RESULT2+9(7) MULTIPLY BY SECOND RESULT
         ZAP   RESULT99,RESULT3    CAPTURE CURRENT RESULT
         MVI   RESULTSW,C'1'       INDICATE CURRENT RESULT ACTIVE
         MVC   RESULTRD,DIRADIX3   INDICATE CURRENT RESULT RADIX
         CP    RESULT3,=PL1'0'     SET THE CONDITION CODE
         BL    *+L'*+8             IF NEGATIVE, INSERT -
         MVI   DHINPUT+L'DHINPUT-1,C'+' MOVE A POSITIVE SIGN
         B     *+L'*+4             GO TO BYPASS
         MVI   DHINPUT+L'DHINPUT-1,C'-' INSERT A - SIGN
         CLI   DIRADIX3,C'D'       DID USER WANT ANSWER IN DEC?
         BE    RMULYESD            YES, IN DECIMAL
         UNPK  DHINPUT(L'DHINPUT-1),RESULT3 SET INPUT UP
         OI    DHINPUT+L'DHINPUT-2,C'0' CLEAR SIGN NIBBLE
        #GO    DECHEX              CONVERT TO HEX
         MVC   SC6LN13N+11(L'DHOUTCHR),DHOUTCHR MOVE CONVERTED HEX
         B     RMULRCA             GO PUT SCREEN BACK OUT
RMULYESD MVC   SC6LN13N,DECEDIT2   PUT EDIT MASK IN SCREEN
         ED    SC6LN13N,RESULT3+3  EDIT DECIMAL RESULT
         CLI   SC6LN13N+L'SC6LN13N-1,C' ' IS SIGN A BLANK
         BNE   RMULRCA             NO, GO PUT SCREEN BACK OUT
         MVI   SC6LN13N+L'SC6LN13N-1,C'+' YES, REPLACE WITH A +
         B     RMULRCA             GO PUT SCREEN BACK OUT
RMUL04  $FS    SBA=(9,31),MF=(I,SC6CSRP) RESET CURSOR POSITION
         LA    R2,SC6LN09I
         B     RMULBAD
RMUL08  $FS    SBA=(11,31),MF=(I,SC6CSRP) RESET CURSOR POSITION
         LA    R2,SC6LN11I
         B     RMULBAD
RMUL12  $FS    SBA=(14,46),MF=(I,SC6CSRP) RESET CURSOR POSITION
         LA    R2,SC6LN14I
         B     RMULBAD
RMUL16  $FS    SBA=(8,5),MF=(I,SC6CSRP) RESET CURSOR POSITION
         LA    R2,SC6LN08I
         B     RMULBAD
RMUL20  $FS    SBA=(10,5),MF=(I,SC6CSRP) RESET CURSOR POSITION
         LA    R2,SC6LN10I
RMULBAD  LTR   R7,R7
         BZ    RMULBADX
        $FS    SF=NORMAL,MF=(I,(R7)) RESET ERROR INPUT
RMULBADX LR    R7,R2
         MVC   SC6LN24,ENDLNE05    PUT OUT ERROR MESSAGE
        $FS    SF=(INT),MF=(I,(R7)) SET ERROR INPUT
         B     RMULINIT
R$MULX  $XRET  CC=(R15)
         SPACE 1
        LTORG
         SPACE 1
SCREEN6  $FS   CC=EW,WCC=(KBR,RMDT),SBA=(1,1),RA=(1,1,00),MF=L
         $FS   SBA=(1,1),SF=(SKIP,INT),MF=L
         $FS   SBA=(1,19),MF=L
         $FS   TEXT='T S O   A R I T H M E T I C   C O M M A N D',MF=L
         $FS   SBA=(2,1),RA=(3,1,-),MF=L
         $FS   SBA=(4,10),SF=(SKIP),MF=L
         $FS   TEXT='====   M U L T I P L I C A T I O N   ',MF=L
         $FS   TEXT='P R O C E S S O R   ====',MF=L
         $FS   SBA=(5,80),SF=(SKIP,INT),MF=L
         $FS   RA=(7,1,-),MF=L
         $FS   SBA=(8,1),SF=(SKIP),TEXT='1:',MF=L
SC6LN08I $FS   SF=NORMAL,MF=L
SC6LN08N $FS   TEXT=(' ',16),MF=L
         $FS   SF=(SKIP,INT),TEXT='<====',MF=L
         $FS   SF=(SKIP),TEXT='Enter',MF=L
         $FS   SF=(SKIP,INT),TEXT='1st #',MF=L
         $FS   SF=(SKIP),TEXT='to multiply (multiplicand)',MF=L
         $FS   SBA=(9,27),SF=(SKIP),TEXT='2:',MF=L
SC6LN09I $FS   SF=NORMAL,MF=L
SC6LN09R $FS   TEXT=(' ',1),MF=L
         $FS   SF=(SKIP,INT),TEXT='<====',MF=L
         $FS   SF=(SKIP),TEXT='Enter',MF=L
         $FS   SF=(SKIP,INT),TEXT='Radix',MF=L
         $FS   SBA=(10,1),SF=(SKIP),TEXT='3:',MF=L
SC6LN10I $FS   SF=NORMAL,MF=L
SC6LN10N $FS   TEXT=(' ',16),MF=L
         $FS   SF=(SKIP,INT),TEXT='<====',MF=L
         $FS   SF=(SKIP),TEXT='Enter',MF=L
         $FS   SF=(SKIP,INT),TEXT='2nd #',MF=L
         $FS   SF=(SKIP),TEXT='to multiply (multiplier)',MF=L
         $FS   SBA=(11,27),SF=(SKIP),TEXT='4:',MF=L
SC6LN11I $FS   SF=NORMAL,MF=L
SC6LN11R $FS   TEXT=(' ',1),MF=L
         $FS   SF=(SKIP,INT),TEXT='<====',MF=L
         $FS   SF=(SKIP),TEXT='Enter',MF=L
         $FS   SF=(SKIP,INT),TEXT='Radix',MF=L
         $FS   SF=(SKIP),MF=L
         $FS   SBA=(12,2),TEXT='------------------',MF=L
         $FS   TEXT='----------------',MF=L
         $FS   SBA=(13,1),SF=(SKIP,INT),MF=L
SC6LN13N $FS   TEXT=(' ',34),MF=L
         $FS   SF=(SKIP),TEXT='<====',MF=L
         $FS   SF=(SKIP,INT),TEXT='Product',MF=L
         $FS   SF=(SKIP),RA=(13,80,=),MF=L
         $FS   SBA=(14,42),SF=(SKIP),TEXT='5:',MF=L
SC6LN14I $FS   SF=NORMAL,MF=L
SC6LN14R $FS   TEXT=(' ',1),MF=L
         $FS   SF=(SKIP,INT),TEXT='<====',MF=L
         $FS   SF=(SKIP),TEXT='Enter',MF=L
         $FS   SF=(SKIP,INT),TEXT='Radix',MF=L
         $FS   SF=(SKIP),MF=L
         $FS   SBA=(17,1),SF=(SKIP,INT),TEXT='1:',MF=L
         $FS   SF=(SKIP),TEXT='Enter 1st # to multiply, please ',MF=L
         $FS   TEXT='make sure item (2) is equivalent',MF=L
         $FS   SBA=(18,1),SF=(SKIP,INT),TEXT='2:',MF=L
         $FS   SF=(SKIP),TEXT='Enter Radix of 1st # to multiply ',MF=L
         $FS   TEXT='(D=Decimal, X=Hexadecimal)',MF=L
         $FS   SBA=(19,1),SF=(SKIP,INT),TEXT='3:',MF=L
         $FS   SF=(SKIP),TEXT='Enter 2nd # to multiply, please',MF=L
         $FS   TEXT=' make sure item (4) is equivalent',MF=L
         $FS   SBA=(20,1),SF=(SKIP,INT),TEXT='4:',MF=L
         $FS   SF=(SKIP),TEXT='Enter Radix of 2nd # to ',MF=L
         $FS   TEXT='multiply (D=Decimal, X=Hexadecimal)',MF=L
         $FS   SBA=(21,1),SF=(SKIP,INT),TEXT='5:',MF=L
         $FS   SF=(SKIP),TEXT='Enter Radix you would display ',MF=L
         $FS   TEXT='the product (D=Decimal, X=Hexadecimal)',MF=L
         $FS   SBA=(23,80),MF=L
SC6LN24  $FS   TEXT=(' ',88),MF=L
SC6CSRP  $FS   SBA=(8,5),SF=(IC),MF=L
LSCREEN6 EQU   *-SCREEN6
         SPACE 1
         DROP  R9
         EJECT
*------> INPUT "SCREEN6" PROCESS ROUTINE.
*        AT EXIT : R1=INPUT TRUE LENGTH AND R3=INPUT SCAN LENGTH.
         SPACE 1
RSCRT6  $XENT  BASE=(R9)
         XR    R2,R2               INITIAL COUNT
R6LOOP  @FSR   ,                   GET REPLY TEXT
         LTR   R15,R15             NO MORE FIELDS MODIFIED?
         BNZ   R6PRCD              NO
         L     R1,4(R13)           YES, END, GET PREVIOUS SAVE AREA
         ST    R2,24(R1)           PASS BACK COUNT IN R1
         LA    R2,35               AND INPUT SCAN LENGTH IN R3
         ST    R2,32(R1)
         XR    R15,R15             EXIT
        $XRET  CC=(R15)
R6PRCD   CLC   SC6CSF1,0(R15)
         BE    R6FL1
         CLC   SC6CSF2,0(R15)
         BE    R6FL2
         CLC   SC6CSF3,0(R15)
         BE    R6FL3
         CLC   SC6CSF4,0(R15)
         BE    R6FL4
         CLC   SC6CSF5,0(R15)
         BE    R6FL5
         B     R6LOOP              UNEXPECTED (CHECK SCREEN IMAGE)
R6FL1    LTR   R1,R1
         BZ    R6FC1               FIELD CLEARED (CANC FC)
         CH    R1,=H'1'
         BNE   R6LOOP              UNEXPECTED (CHECK SCREEN IMAGE)
         MVI   INPUT+0,C' '        FOR UPPERCASE
         OC    INPUT+0(1),3(R15)   COPY RADIX OF 1ST NUMBER
         B     R6BF1
R6FC1    MVI   INPUT+0,C' '        RADIX OF 1ST NUMBER CLEARED
R6BF1    LA    R2,1(R2)            BUMP COUNT
         B     R6LOOP
R6FL2    LTR   R1,R1
         BZ    R6FC2               FIELD CLEARED (CANC FC)
         CH    R1,=H'16'
         BH    R6LOOP              UNEXPECTED (CHECK SCREEN IMAGE)
         MVC   INPUT+1(16),=CL50' ' FOR UPPERCASE
         SH    R1,=H'1'
         EX    R1,R6OF2            COPY 1ST NUMBER VALUE
         B     R6BF2
R6FC2    MVC   INPUT+1(16),=CL50' ' 1ST NUMBER VALUE CLEARED
R6BF2    LA    R2,16(R2)           BUMP COUNT
         B     R6LOOP
R6OF2    OC    INPUT+1(*-*),3(R15) <<EXECUTED>>
R6FL3    LTR   R1,R1
         BZ    R6FC3               FIELD CLEARED (CANC FC)
         CH    R1,=H'1'
         BNE   R6LOOP              UNEXPECTED (CHECK SCREEN IMAGE)
         MVI   INPUT+17,C' '       FOR UPPERCASE
         OC    INPUT+17(1),3(R15)  COPY RADIX OF 2ND NUMBER
         B     R6BF3
R6FC3    MVI   INPUT+17,C' '       RADIX OF 2ND NUMBER CLEARED
R6BF3    LA    R2,1(R2)            BUMP COUNT
         B     R6LOOP
R6FL4    LTR   R1,R1
         BZ    R6FC4               FIELD CLEARED (CANC FC)
         CH    R1,=H'16'
         BH    R6LOOP              UNEXPECTED (CHECK SCREEN IMAGE)
         MVC   INPUT+18(16),=CL50' ' FOR UPPERCASE
         SH    R1,=H'1'
         EX    R1,R6OF4            COPY 2ND NUMBER VALUE
         B     R6BF4
R6FC4    MVC   INPUT+18(16),=CL50' ' 2ND NUMBER VALUE CLEARED
R6BF4    LA    R2,16(R2)           BUMP COUNT
         B     R6LOOP
R6OF4    OC    INPUT+18(*-*),3(R15) <<EXECUTED>>
R6FL5    LTR   R1,R1
         BZ    R6FC5               FIELD CLEARED (CANC FC)
         CH    R1,=H'1'
         BNE   R6LOOP              UNEXPECTED (CHECK SCREEN IMAGE)
         MVI   INPUT+34,C' '       FOR UPPERCASE
         OC    INPUT+34(1),3(R15)  COPY RADIX OF RESULT
         B     R6BF5
R6FC5    MVI   INPUT+34,C' '       RADIX OF RESULT CLEARED
R6BF5    LA    R2,1(R2)            BUMP COUNT
         B     R6LOOP
SC6CSF1  $FS   SBA=(9,31),MF=L
SC6CSF2  $FS   SBA=(8,5),MF=L
SC6CSF3  $FS   SBA=(11,31),MF=L
SC6CSF4  $FS   SBA=(10,5),MF=L
SC6CSF5  $FS   SBA=(14,46),MF=L
         SPACE 1
        LTORG
         SPACE 1
         DROP  R9
         EJECT
*------> THIS ROUTINE PROCESSES THE DIVIDE SCREEN.
*        AT EXIT : R15 = 0, 4 OR 8.
         SPACE 1
RTN$DIV $XENT  BASE=(R9)
         MVI   INPUT+0,DEFRADIX    INIT RADIX
         MVI   INPUT+17,DEFRADIX
         MVI   INPUT+34,DEFRADIX
         MVC   INPUT+1(16),=CL50' ' INIT TO SPACE
         CLI   RESULTSW,C'1'       IS THERE A CURRENT RESULT?
         BNE   RDIVNOCR            NO, BYPASS
         CLI   RESULTRD,C'D'       IS CURRENT RESULT DECIMAL?
         BE    RDIVRESD            YES, PROCESS DECIMAL
         UNPK  DHINPUT,RESULT99    UNPACK IT
         OI    DHINPUT+L'DHINPUT-1,C'0' CLEAR SIGN NIBBLE
        #GO    DECHEX              CONVERT NUMBER TO HEX DISPLAY
         MVC   INPUT+9(L'DHOUTCHR),DHOUTCHR PUT HEX NUMBER IN SCREEN
         MVI   INPUT+0,C'X'        INDICATE HEX RADIX
         B     RDIVNOCR            BYPASS DECIMAL CODE
RDIVRESD MVC   INPUT+1(16),EDUNPK  UNPACK CURRENT RESULT
         ED    INPUT+1(16),RESULT99+8 EDIT CURRENT RESULT
         MVI   INPUT+1,C'+'        INIT TO POSITIVE
         CP    RESULT99,=PL1'0'    SET CONDITION CODE
         BNL   RDIVNOCR            BYPASS MOVE
         MVI   INPUT+1,C'-'        SET TO NEGATIVE
RDIVNOCR MVC   INPUT+18(16),=CL50' ' INIT TO SPACE
         MVC   DIRADIX1,INPUT+0    COPY RADIX 1ST NUMBER
         MVC   DIDATA1,INPUT+1     COPY 1ST NUMBER
         MVC   DIRADIX2,INPUT+17   COPY RADIX 2ND NUMBER
         MVC   DIDATA2,INPUT+18    COPY 2ND NUMBER
         MVC   DIRADIX3,INPUT+34   COPY RADIX RESULT
         MVC   SC7LN13N,=CL50' '   CLEAR RESULT DATA
         MVC   SC7LN15N,=CL50' '    " "
        $FS    SF=NORMAL,MF=(I,SC7LN08I) SET NORMAL INPUT
        $FS    SF=NORMAL,MF=(I,SC7LN09I)  " "
        $FS    SF=NORMAL,MF=(I,SC7LN10I)  " "
        $FS    SF=NORMAL,MF=(I,SC7LN11I)  " "
        $FS    SF=NORMAL,MF=(I,SC7LN14I)  " "
        $FS    SBA=(8,5),MF=(I,SC7CSRP) SET CURSOR TO 1ST NUMBER
         XR    R7,R7
RDIVRCA  MVC   SC7LN24,ENDLNE04    POST GOOD MESSAGE
         LTR   R7,R7
         BZ    RDIVINIT
        $FS    SF=NORMAL,MF=(I,(R7)) RESET ERROR INPUT
         XR    R7,R7
RDIVINIT MVC   SC7LN09R,DIRADIX1   PUT DATA INTO SCREEN
         MVC   SC7LN11R,DIRADIX2
         MVC   SC7LN14R,DIRADIX3
         MVC   SC7LN08N,DIDATA1
         MVC   SC7LN10N,DIDATA2
RDIVLOOP LM    R0,R2,=A(SCREEN7,LSCREEN7,RSCRT7)
         STM   R0,R2,ASCRIPTR      STORE PTR'S
        #GO    FULLSCR             GO DO DEMO SCREEN WORK
         B     *+L'*(R15)          HOW COMPLETE?
         B     R$DIVX              0 - RETURN TO MENU - WILD GOTO
         B     R$DIVX              4 - ERROR
         LTR   R1,R1               DID USER TYPE IN?
         BZ    RDIVLOOP            NO, PUT SCREEN BACK OUT
         BP    *+L'*+8             YES, GO PROCESS
         MVI   INPUT+0,C' '        ELSE, RESET OPTION MENU
         B     R$DIVX              AND RETURN TO MENU
        #GO    DYADIC              GO DO PRELIMINARY EDITING
         MVC   SC7LN13N,=CL50' '   CLEAR RESULT AREA
         MVC   SC7LN15N,=CL50' '    " "
         B     *+L'*(R15)          BRANCH ON RETURN CODE
         B     RDIV00              EDITING/CONVERSION OK
         B     RDIV04              ERROR, RC=04
         B     RDIV08              ERROR, RC=08
         B     RDIV12              ERROR, RC=12
         B     RDIV16              ERROR, RC=16
         B     RDIV20              ERROR, RC=20
RDIV00  $FS    SBA=(8,5),MF=(I,SC7CSRP) SET CURSOR TO 1ST NUMBER
         ZAP   RESULT3,RESULT1     SHIFT FIRST RESULT
         DP    RESULT3,RESULT2+9(7) SUBTRACT SECOND RESULT
         ZAP   REMAIN,RESULT3+9(7) SAVE THE REMAINDER
         ZAP   DIVWORK1,RESULT3(9) COPY THE QUOTIENT
         ZAP   RESULT3,DIVWORK1    COPY IT BACK, EXPANDED
         ZAP   RESULT99,RESULT3    CAPTURE CURRENT RESULT
         MVI   RESULTSW,C'1'       INDICATE CURRENT RESULT ACTIVE
         MVC   RESULTRD,DIRADIX3   INDICATE CURRENT RESULT RADIX
         CP    RESULT3,=PL1'0'     SET THE CONDITION CODE
         BL    *+L'*+8             IF NEGATIVE, INSERT -
         MVI   DHINPUT+L'DHINPUT-1,C'+' MOVE A POSITIVE SIGN
         B     *+L'*+4             GO TO BYPASS
         MVI   DHINPUT+L'DHINPUT-1,C'-' INSERT A - SIGN
         CLI   DIRADIX3,C'D'       DID USER WANT ANSWER IN DEC?
         BE    RDIVYESD            YES, IN DECIMAL
         UNPK  DHINPUT(L'DHINPUT-1),RESULT3 SET INPUT UP
         OI    DHINPUT+L'DHINPUT-2,C'0' CLEAR SIGN NIBBLE
        #GO    DECHEX              CONVERT TO HEX
         MVC   SC7LN13N+11(L'DHOUTCHR),DHOUTCHR MOVE CONVERTED HEX
         B     RDIVREMN
RDIVYESD MVC   SC7LN13N,DECEDIT2   PUT EDIT MASK IN SCREEN
         ED    SC7LN13N,RESULT3+3  EDIT DECIMAL RESULT
         CLI   SC7LN13N+L'SC7LN13N-1,C' ' IS SIGN A BLANK
         BNE   RDIVREMN            NO
         MVI   SC7LN13N+L'SC7LN13N-1,C'+' YES, REPLACE WITH A +
RDIVREMN MVI   DHINPUT+L'DHINPUT-1,C'+' MOVE A POSITIVE SIGN
         CLI   DIRADIX3,C'D'       DID USER WANT ANSWER IN DEC?
         BE    RDIVYSD2            YES, IN DECIMAL
         UNPK  DHINPUT(L'DHINPUT-1),REMAIN  SET INPUT UP
         OI    DHINPUT+L'DHINPUT-2,C'0' CLEAR SIGN NIBBLE
        #GO    DECHEX              CONVERT TO HEX
         MVC   SC7LN15N+11(L'DHOUTCHR),DHOUTCHR MOVE CONVERTED HEX
         B     RDIVRCA             GO PUT SCREEN BACK OUT
RDIVYSD2 MVC   SC7LN15N,DECEDIT2   PUT EDIT MASK IN SCREEN
         ED    SC7LN15N,REMAIN+3   EDIT DECIMAL RESULT
         CLI   SC7LN15N+L'SC7LN15N-1,C' ' IS SIGN A BLANK
         BNE   RDIVRCA             NO, GO PUT SCREEN BACK OUT
         MVI   SC7LN15N+L'SC7LN15N-1,C'+' YES, REPLACE WITH A +
         B     RDIVRCA             GO PUT SCREEN BACK OUT
RDIV04  $FS    SBA=(9,31),MF=(I,SC7CSRP) RESET CURSOR POSITION
         LA    R2,SC7LN09I
         B     RDIVBAD
RDIV08  $FS    SBA=(11,31),MF=(I,SC7CSRP) RESET CURSOR POSITION
         LA    R2,SC7LN11I
         B     RDIVBAD
RDIV12  $FS    SBA=(14,46),MF=(I,SC7CSRP) RESET CURSOR POSITION
         LA    R2,SC7LN14I
         B     RDIVBAD
RDIV16  $FS    SBA=(8,5),MF=(I,SC7CSRP) RESET CURSOR POSITION
         LA    R2,SC7LN08I
         B     RDIVBAD
RDIV20  $FS    SBA=(10,5),MF=(I,SC7CSRP) RESET CURSOR POSITION
         LA    R2,SC7LN10I
RDIVBAD  LTR   R7,R7
         BZ    RDIVBADX
        $FS    SF=NORMAL,MF=(I,(R7)) RESET ERROR INPUT
RDIVBADX LR    R7,R2
         MVC   SC7LN24,ENDLNE05    PUT OUT ERROR MESSAGE
        $FS    SF=(INT),MF=(I,(R7)) SET ERROR INPUT
         B     RDIVINIT
R$DIVX  $XRET  CC=(R15)
         SPACE 1
        LTORG
         SPACE 1
SCREEN7  $FS   CC=EW,WCC=(KBR,RMDT),SBA=(1,1),RA=(1,1,00),MF=L
         $FS   SBA=(1,1),SF=(SKIP,INT),MF=L
         $FS   SBA=(1,19),MF=L
         $FS   TEXT='T S O   A R I T H M E T I C   C O M M A N D',MF=L
         $FS   SBA=(2,1),RA=(3,1,-),MF=L
         $FS   SBA=(4,15),SF=(SKIP),MF=L
         $FS   TEXT='====   D I V I S I O N   ',MF=L
         $FS   TEXT='P R O C E S S O R   ====',MF=L
         $FS   SBA=(5,80),SF=(SKIP,INT),MF=L
         $FS   RA=(7,1,-),MF=L
         $FS   SBA=(8,1),SF=(SKIP),TEXT='1:',MF=L
SC7LN08I $FS   SF=NORMAL,MF=L
SC7LN08N $FS   TEXT=(' ',16),MF=L
         $FS   SF=(SKIP,INT),TEXT='<====',MF=L
         $FS   SF=(SKIP),TEXT='Enter',MF=L
         $FS   SF=(SKIP,INT),TEXT='1st #',MF=L
         $FS   SF=(SKIP),TEXT='to divide (dividend)',MF=L
         $FS   SBA=(9,27),SF=(SKIP),TEXT='2:',MF=L
SC7LN09I $FS   SF=NORMAL,MF=L
SC7LN09R $FS   TEXT=(' ',1),MF=L
         $FS   SF=(SKIP,INT),TEXT='<====',MF=L
         $FS   SF=(SKIP),TEXT='Enter',MF=L
         $FS   SF=(SKIP,INT),TEXT='Radix',MF=L
         $FS   SBA=(10,1),SF=(SKIP),TEXT='3:',MF=L
SC7LN10I $FS   SF=NORMAL,MF=L
SC7LN10N $FS   TEXT=(' ',16),MF=L
         $FS   SF=(SKIP,INT),TEXT='<====',MF=L
         $FS   SF=(SKIP),TEXT='Enter',MF=L
         $FS   SF=(SKIP,INT),TEXT='2nd #',MF=L
         $FS   SF=(SKIP),TEXT='to divide (divisor)',MF=L
         $FS   SBA=(11,27),SF=(SKIP),TEXT='4:',MF=L
SC7LN11I $FS   SF=NORMAL,MF=L
SC7LN11R $FS   TEXT=(' ',1),MF=L
         $FS   SF=(SKIP,INT),TEXT='<====',MF=L
         $FS   SF=(SKIP),TEXT='Enter',MF=L
         $FS   SF=(SKIP,INT),TEXT='Radix',MF=L
         $FS   SF=(SKIP),MF=L
         $FS   SBA=(12,2),TEXT='------------------',MF=L
         $FS   TEXT='----------------',MF=L
         $FS   SBA=(13,1),SF=(SKIP,INT),MF=L
SC7LN13N $FS   TEXT=(' ',34),MF=L
         $FS   SF=(SKIP),TEXT='<====',MF=L
         $FS   SF=(SKIP,INT),TEXT='Quotient',MF=L
         $FS   SF=(SKIP),RA=(13,80,=),MF=L
         $FS   SBA=(14,42),SF=(SKIP),TEXT='5:',MF=L
SC7LN14I $FS   SF=NORMAL,MF=L
SC7LN14R $FS   TEXT=(' ',1),MF=L
         $FS   SF=(SKIP,INT),TEXT='<====',MF=L
         $FS   SF=(SKIP),TEXT='Enter',MF=L
         $FS   SF=(SKIP,INT),TEXT='Radix',MF=L
         $FS   SF=(SKIP),MF=L
         $FS   SBA=(15,1),SF=(SKIP,INT),MF=L
SC7LN15N $FS   TEXT=(' ',34),MF=L
         $FS   SF=(SKIP),TEXT='<====',MF=L
         $FS   SF=(SKIP,INT),TEXT='Remainder',MF=L
         $FS   SF=(SKIP),RA=(15,80,=),MF=L
         $FS   SBA=(17,1),SF=(SKIP,INT),TEXT='1:',MF=L
         $FS   SF=(SKIP),TEXT='Enter dividend, please ',MF=L
         $FS   TEXT='make sure item (2) is equivalent',MF=L
         $FS   SBA=(18,1),SF=(SKIP,INT),TEXT='2:',MF=L
         $FS   SF=(SKIP),TEXT='Enter Radix of dividend ',MF=L
         $FS   TEXT='(D=Decimal, X=Hexadecimal)',MF=L
         $FS   SBA=(19,1),SF=(SKIP,INT),TEXT='3:',MF=L
         $FS   SF=(SKIP),TEXT='Enter divisor, please',MF=L
         $FS   TEXT=' make sure item (4) is equivalent',MF=L
         $FS   SBA=(20,1),SF=(SKIP,INT),TEXT='4:',MF=L
         $FS   SF=(SKIP),TEXT='Enter Radix of divisor ',MF=L
         $FS   TEXT='(D=Decimal, X=Hexadecimal)',MF=L
         $FS   SBA=(21,1),SF=(SKIP,INT),TEXT='5:',MF=L
         $FS   SF=(SKIP),TEXT='Enter Radix you would display ',MF=L
         $FS   TEXT='the quotient (D=Decimal, X=Hexadecimal)',MF=L
         $FS   SBA=(23,80),MF=L
SC7LN24  $FS   TEXT=(' ',88),MF=L
SC7CSRP  $FS   SBA=(8,5),SF=(IC),MF=L
LSCREEN7 EQU   *-SCREEN7
         SPACE 1
         DROP  R9
         EJECT
*------> INPUT "SCREEN7" PROCESS ROUTINE.
*        AT EXIT : R1=INPUT TRUE LENGTH AND R3=INPUT SCAN LENGTH.
         SPACE 1
RSCRT7  $XENT  BASE=(R9)
         XR    R2,R2               INITIAL COUNT
R7LOOP  @FSR   ,                   GET REPLY TEXT
         LTR   R15,R15             NO MORE FIELDS MODIFIED?
         BNZ   R7PRCD              NO
         L     R1,4(R13)           YES, END, GET PREVIOUS SAVE AREA
         ST    R2,24(R1)           PASS BACK COUNT IN R1
         LA    R2,35               AND INPUT SCAN LENGTH IN R3
         ST    R2,32(R1)
         XR    R15,R15             EXIT
        $XRET  CC=(R15)
R7PRCD   CLC   SC7CSF1,0(R15)
         BE    R7FL1
         CLC   SC7CSF2,0(R15)
         BE    R7FL2
         CLC   SC7CSF3,0(R15)
         BE    R7FL3
         CLC   SC7CSF4,0(R15)
         BE    R7FL4
         CLC   SC7CSF5,0(R15)
         BE    R7FL5
         B     R7LOOP              UNEXPECTED (CHECK SCREEN IMAGE)
R7FL1    LTR   R1,R1
         BZ    R7FC1               FIELD CLEARED (CANC FC)
         CH    R1,=H'1'
         BNE   R7LOOP              UNEXPECTED (CHECK SCREEN IMAGE)
         MVI   INPUT+0,C' '        FOR UPPERCASE
         OC    INPUT+0(1),3(R15)   COPY RADIX OF 1ST NUMBER
         B     R7BF1
R7FC1    MVI   INPUT+0,C' '        RADIX OF 1ST NUMBER CLEARED
R7BF1    LA    R2,1(R2)            BUMP COUNT
         B     R7LOOP
R7FL2    LTR   R1,R1
         BZ    R7FC2               FIELD CLEARED (CANC FC)
         CH    R1,=H'16'
         BH    R7LOOP              UNEXPECTED (CHECK SCREEN IMAGE)
         MVC   INPUT+1(16),=CL50' ' FOR UPPERCASE
         SH    R1,=H'1'
         EX    R1,R7OF2            COPY 1ST NUMBER VALUE
         B     R7BF2
R7FC2    MVC   INPUT+1(16),=CL50' ' 1ST NUMBER VALUE CLEARED
R7BF2    LA    R2,16(R2)           BUMP COUNT
         B     R7LOOP
R7OF2    OC    INPUT+1(*-*),3(R15) <<EXECUTED>>
R7FL3    LTR   R1,R1
         BZ    R7FC3               FIELD CLEARED (CANC FC)
         CH    R1,=H'1'
         BNE   R7LOOP              UNEXPECTED (CHECK SCREEN IMAGE)
         MVI   INPUT+17,C' '       FOR UPPERCASE
         OC    INPUT+17(1),3(R15)  COPY RADIX OF 2ND NUMBER
         B     R7BF3
R7FC3    MVI   INPUT+17,C' '       RADIX OF 2ND NUMBER CLEARED
R7BF3    LA    R2,1(R2)            BUMP COUNT
         B     R7LOOP
R7FL4    LTR   R1,R1
         BZ    R7FC4               FIELD CLEARED (CANC FC)
         CH    R1,=H'16'
         BH    R7LOOP              UNEXPECTED (CHECK SCREEN IMAGE)
         MVC   INPUT+18(16),=CL50' ' FOR UPPERCASE
         SH    R1,=H'1'
         EX    R1,R7OF4            COPY 2ND NUMBER VALUE
         B     R7BF4
R7FC4    MVC   INPUT+18(16),=CL50' ' 2ND NUMBER VALUE CLEARED
R7BF4    LA    R2,16(R2)           BUMP COUNT
         B     R7LOOP
R7OF4    OC    INPUT+18(*-*),3(R15) <<EXECUTED>>
R7FL5    LTR   R1,R1
         BZ    R7FC5               FIELD CLEARED (CANC FC)
         CH    R1,=H'1'
         BNE   R7LOOP              UNEXPECTED (CHECK SCREEN IMAGE)
         MVI   INPUT+34,C' '       FOR UPPERCASE
         OC    INPUT+34(1),3(R15)  COPY RADIX OF RESULT
         B     R7BF5
R7FC5    MVI   INPUT+34,C' '       RADIX OF RESULT CLEARED
R7BF5    LA    R2,1(R2)            BUMP COUNT
         B     R7LOOP
SC7CSF1  $FS   SBA=(9,31),MF=L
SC7CSF2  $FS   SBA=(8,5),MF=L
SC7CSF3  $FS   SBA=(11,31),MF=L
SC7CSF4  $FS   SBA=(10,5),MF=L
SC7CSF5  $FS   SBA=(14,46),MF=L
         SPACE 1
        LTORG
         SPACE 1
         DROP  R9
         EJECT
*------> THIS ROUTINE PROCESSES THE 3270 BUFFER CONVERSION SCREEN.
*        AT EXIT : R15 = 0, 4 OR 8.
         SPACE 1
RTN$SCR $XENT  BASE=(R9)
         MVI   INPUT+0,C'2'        DEFAULT TO MODEL 2
         MVC   INPUT+1(2),=CL3'___' UNDERSCORE ROW FIELD
         MVC   INPUT+3(3),=CL3'___'   " "     COLUMN FIELD
         MVC   INPUT+6(2),=CL3'___'   " "     1ST BUFFER ADDR
         MVC   INPUT+8(2),=CL3'___'   " "     2ND BUFFER ADDR
         MVC   SC8LN09R,=CL7'24,80) ' SET MODEL (SCREEN SIZE)
         MVC   SC8LN12R,=CL50' '   CLEAR THE DECIMAL ADDRESS
         MVC   SC8LN13R,=CL50' '    " "  THE HEX ADDRESS
        $FS    SF=NORMAL,MF=(I,SC8LN091) SET NORMAL INPUT
        $FS    SF=NORMAL,MF=(I,SC8LN121)  " "
        $FS    SF=NORMAL,MF=(I,SC8LN131)  " "
        $FS    SF=NORMAL,MF=(I,SC8LN161)  " "
        $FS    SF=NORMAL,MF=(I,SC8LN171)  " "
         XR    R7,R7
RSCGOOD $FS    SBA=(9,4),MF=(I,SC8CSRP) RESET THE CURSOR ADDRESS
         MVC   SC8LN24,ENDLNE04    POST GOOD MESSAGE
         LTR   R7,R7
         BZ    RSCINIT
        $FS    SF=NORMAL,MF=(I,(R7)) RESET ERROR INPUT
         XR    R7,R7
RSCINIT  MVC   SC8LN09N,INPUT+0    SET MODEL
         MVC   SC8LN12N,INPUT+1    SET ROW FIELD
         MVC   SC8LN13N,INPUT+3    SET COLUMN FIELD
         MVC   SC8LN16N,INPUT+6    SET 1ST BUFFER ADDR
         MVC   SC8LN17N,INPUT+8    SET 2ND BUFFER ADDR
RSCLOOP  LM    R0,R2,=A(SCREEN8,LSCREEN8,RSCRT8)
         STM   R0,R2,ASCRIPTR      STORE PTR'S
        #GO    FULLSCR             GO DO DEMO SCREEN WORK
         B     *+L'*(R15)          HOW COMPLETE?
         B     R$SCRX              0 - RETURN TO MENU - WILD GOTO
         B     R$SCRX              4 - ERROR
         LTR   R1,R1               8 - DID USER TYPE IN?
         BZ    RSCLOOP             NO, PUT SCREEN BACK OUT
         BP    *+L'*+8             YES, GO PROCESS
         MVI   INPUT+0,C' '        YES, RESET OPTION MENU
         B     R$SCRX              AND RETURN TO MENU
         CLI   INPUT+0,C'2'        IS IT  A 2?
         BNE   *+L'*+16            NO, TRY NEXT
         ZAP   RSCROW,=PL2'24'     YES, SET SCREEN SIZE = 24 * 80
         ZAP   RSCCOL,=PL2'80'
         B     RSCSMDL
         CLI   INPUT+0,C'3'        IS IT  A 3?
         BNE   *+L'*+16            NO, TRY NEXT
         ZAP   RSCROW,=PL2'27'     YES, SET SCREEN SIZE = 27 * 132
         ZAP   RSCCOL,=PL2'132'
         B     RSCSMDL
         CLI   INPUT+0,C'4'        IS IT  A 4?
         BNE   *+L'*+16            NO, TRY NEXT
         ZAP   RSCROW,=PL2'32'     YES, SET SCREEN SIZE = 32 * 80
         ZAP   RSCCOL,=PL2'80'
         B     RSCSMDL
         CLI   INPUT+0,C'5'        IS IT A 5?
         BNE   RSCBAD1             NO, POST AS ERROR
         ZAP   RSCROW,=PL2'43'     YES, SET SCREEN SIZE = 43 * 80
         ZAP   RSCCOL,=PL2'80'
RSCSMDL  MVC   SC8LN09R,=CL50' '   SET MODEL (SCREEN SIZE)
         MVC   WORKDBLW(4),=XL4'40202120'
         ED    WORKDBLW(4),RSCROW
         MVC   SC8LN09R(2),WORKDBLW+2
         MVI   SC8LN09R+2,C','
         MVC   WORKDBLW(4),=XL4'40202120'
         ED    WORKDBLW(4),RSCCOL
         CLI   WORKDBLW+1,C' '
         BE    *+L'*+14
         MVC   SC8LN09R+3(3),WORKDBLW+1
         MVI   SC8LN09R+6,C')'
         B     *+L'*+10
         MVC   SC8LN09R+3(2),WORKDBLW+2
         MVI   SC8LN09R+5,C')'
         CLC   INPUT+1(2),=CL3'___' DID USER TYPE IN A ROW VALUE?
         BE    RSCSBAV             NO, MAY BE HE WANTS TO GO BUFFER
         CLC   INPUT+3(3),=CL3'___' YES, DID USER TYPE IN A COLUMN?
         BE    RSCBAD3             NO, BUT HE SHOULD HAVE
         CLC   SC8LN12N,INPUT+1    DID USER TYPE A NEW ROW?
         BNE   RSCTIT2             YES
         CLC   SC8LN13N,INPUT+3    DID USER TYPE A NEW COLUMN?
         BNE   RSCTIT2             YES
         CLC   SC8LN16N,INPUT+6    DID USER TYPE A NEW 1ST ADDR?
         BNE   RSCTIT1             YES
         CLC   SC8LN17N,INPUT+8    DID USER TYPE A NEW 2ND ADDR?
         BNE   RSCTIT1             YES
         CLC   SC8LN09N,INPUT+0    DID USER CHANGE MODEL?
         BNE   RSCTIT2             YES
         B     RSCLOOP             NO, NOTHING CHANGED
RSCTIT1  CLC   INPUT+6(2),=CL3'___' DID USER TYPE IN 1ST BUFFER VALUE?
         BE    RSCTIT2             NO
         CLC   INPUT+8(2),=CL3'___' DID USER TYPE IN 2ND BUFFER VALUE?
         BNE   RSCSBAV             YES, HE HAS TO TYPE IN SOMETHING
RSCTIT2  TRT   INPUT+1(2),TRTDEC   IS THE ROW NUMERIC?
         BNZ   RSCBAD2             NO, POST ERROR MESSAGE
         TRT   INPUT+3(3),TRTDEC   IS THE COLUMN NUMERIC?
         BNZ   RSCBAD3             NO, POST ERROR MESSAGE
*        --> USER WANTS A ROW/COLUMN TO BUFFER ADDRESS CONVERSION.
         PACK  RSCFLD1,INPUT+1(2)  PACK THE ROW NUMBER
         CP    RSCFLD1,RSCROW      HIGHEST ROW POSSIBLE
         BH    RSCBAD2             POST ERROR MESSAGE
         PACK  RSCFLD2,INPUT+3(3)  PACK THE COLUMN
         CP    RSCFLD2,RSCCOL      HIGHEST COLUMN POSSIBLE
         BH    RSCBAD3             POST ERROR MESSAGE
         SP    RSCFLD1,=PL1'1'     SUBTRACT 1
         MP    RSCFLD1,RSCCOL      NO, MULTIPLY BY NUMBER OF COLUMNS
         AP    RSCFLD1,RSCFLD2     ADD TO GET POSITION NUMBER
         SP    RSCFLD1,=PL1'1'     SUBTRACT TO GET REL POSITION
         MVC   WORKDBLW(6),=XL6'402020202120' PUT THE DECIMAL IN SCREEN
         ED    WORKDBLW(6),RSCFLD1+1
         MVC   SC8LN12R,WORKDBLW+2
         UNPK  DHINPUT,RSCFLD1     SET UP FOR TRANSLATION
         OI    DHINPUT+L'DHINPUT-1,C'0' CLEAR SIGN
        #GO    DECHEX              CONVERT TO HEX CHARACTERS
         MVC   SC8LN13R,DHOUTCHR+4 MOVE TO SCREEN
         LA    R0,L'SC8LN13R-1
         LA    R1,SC8LN13R
         CLI   0(R1),C' '
         BNE   *+L'*+12
         MVI   0(R1),C'0'
         LA    R1,1(R1)
         BCT   R0,*-16
         DP    RSCFLD1,=PL2'64'    DIVIDE BY BASE 64
         ZAP   WORKDBLW,RSCFLD1(2) MOVE FOR CONVERSION
         CVB   R2,WORKDBLW         CONVERT FOR USE AS AN INDEX
         SLL   R2,1                MULTIPLY BY 2
         LA    R3,TABLESCR         GET BASE ADDRESS
         AR    R3,R2               ADD DISPLACEMENT TO BASE
         MVC   INPUT+6(2),0(R3)    MOVE CHARACTERS FROM TABLE
         ZAP   WORKDBLW,RSCFLD1+2(2) MOVE FOR CONVERSION
         CVB   R2,WORKDBLW         CONVERT FOR USE AS AN INDEX
         SLL   R2,1                MULTIPLY BY 2
         LA    R3,TABLESCR         GET BASE ADDRESS
         AR    R3,R2               ADD DISPLACEMENT TO BASE
         MVC   INPUT+8(2),0(R3)    MOVE CHARACTERS FROM TABLE
         B     RSCGOOD             GO POST GOOD MESSAGE AND DISPLAY
RSCSBAV  CLC   INPUT+6(2),=CL3'___' DID USER TYPE IN A BUFFER VALUE?
         BE    RSCBAD6             NO, HE HAS TO TYPE IN SOMETHING
         CLC   INPUT+8(2),=CL3'___' DID USER TYPE IN A BUFFER VALUE?
         BE    RSCBAD5             NO, HE HAS TO TYPE IN SOMETHING
*        --> USER WANTS A BUFFER ADDRESS TO ROW/COLUMN CONVERSION.
         LA    R2,TABLESCR         GET BASE ADDRESS OF TABLE
         LA    R3,64               GET TABLE LENGTH
         CLC   INPUT+6(2),0(R2)    IS IT THIS POINT IN TABLE
         BE    *+L'*+12            YES, BREAK OUT
         LA    R2,2(R2)            BUMP
         BCT   R3,*-14             ITERATE
         B     RSCBAD4             POST ERROR MESSAGE
         LA    R3,TABLESCR         GET BASE ADDRESS OF TABLE
         SR    R2,R3               GET OFFSET
         SRL   R2,1                DIVIDE BY 2
         SLL   R2,6                MULTIPLY BY 64
         CVD   R2,WORKDBLW         CONVERT TO DECIMAL
         ZAP   RSCFLD1,WORKDBLW    PLACE IN SAFE-KEEPING
         LA    R2,TABLESCR         GET BASE ADDRESS OF TABLE
         LA    R3,64               GET TABLE LENGTH
         CLC   INPUT+8(2),0(R2)    IS IT THIS POINT IN TABLE
         BE    *+L'*+12            YES, BREAK OUT
         LA    R2,2(R2)            BUMP
         BCT   R3,*-14             ITERATE
         B     RSCBAD5             POST ERROR MESSAGE
         LA    R3,TABLESCR         GET BASE ADDRESS OF TABLE
         SR    R2,R3               GET OFFSET
         SRL   R2,1                DIVIDE BY 2
         CVD   R2,WORKDBLW         CONVERT TO DECIMAL
         AP    RSCFLD1,WORKDBLW    ADD TO BASE
         MVC   WORKDBLW(6),=XL6'402020202120' PUT THE DECIMAL IN SCREEN
         ED    WORKDBLW(6),RSCFLD1+1
         MVC   SC8LN12R,WORKDBLW+2
         UNPK  DHINPUT,RSCFLD1     SET UP FOR TRANSLATION
         OI    DHINPUT+L'DHINPUT-1,C'0' CLEAR SIGN
        #GO    DECHEX              CONVERT TO HEX CHARACTERS
         MVC   SC8LN13R,DHOUTCHR+4 MOVE TO SCREEN
         LA    R0,L'SC8LN13R-1
         LA    R1,SC8LN13R
         CLI   0(R1),C' '
         BNE   *+L'*+12
         MVI   0(R1),C'0'
         LA    R1,1(R1)
         BCT   R0,*-16
         DP    RSCFLD1,RSCCOL      DIVIDE BY NUMBER OF COLUMNS
         AP    RSCFLD1+0(2),=PL1'1' ADD 1 TO GET REAL ROW
         AP    RSCFLD1+2(2),=PL1'1' ADD 1 TO GET REAL COLUMN
         MVC   WORKDBLW(4),=XL4'40202120' PUT ROW IN SCREEN
         ED    WORKDBLW(4),RSCFLD1
         MVC   INPUT+1(2),WORKDBLW+2
         MVC   WORKDBLW(4),=XL4'40202120' PUT COLUMN IN SCREEN
         ED    WORKDBLW(4),RSCFLD1+2
         MVC   INPUT+3(3),WORKDBLW+1
         B     RSCGOOD             GO POST GOOD MESSAGE AND DISPLAY
RSCBAD1 $FS    SBA=(9,4),MF=(I,SC8CSRP) RESET CURSOR ADDRESS
         LA    R2,SC8LN091
         B     RSCXBAD             GO PAINT SCREEN AGAIN
RSCBAD2 $FS    SBA=(12,3),MF=(I,SC8CSRP) RESET CURSOR ADDRESS
         LA    R2,SC8LN121
         B     RSCXBAD             GO PAINT SCREEN AGAIN
RSCBAD3 $FS    SBA=(13,2),MF=(I,SC8CSRP) RESET CURSOR ADDRESS
         LA    R2,SC8LN131
         B     RSCXBAD             GO PAINT SCREEN AGAIN
RSCBAD4 $FS    SBA=(16,3),MF=(I,SC8CSRP) RESET CURSOR ADDRESS
         LA    R2,SC8LN161
         B     RSCXBAD             GO PAINT SCREEN AGAIN
RSCBAD5 $FS    SBA=(17,3),MF=(I,SC8CSRP) RESET CURSOR ADDRESS
         LA    R2,SC8LN171
RSCXBAD  LTR   R7,R7
         BZ    RSCBADX
        $FS    SF=NORMAL,MF=(I,(R7)) RESET ERROR INPUT
RSCBADX  LR    R7,R2
         MVC   SC8LN24,ENDLNE05    POST ERROR MESSAGE
        $FS    SF=(INT),MF=(I,(R7)) SET ERROR INPUT
         B     RSCBADZ             GO PAINT SCREEN AGAIN
RSCBAD6 $FS    SBA=(12,3),MF=(I,SC8CSRP) RESET CURSOR ADDRESS
         MVC   SC8LN24,ENDLNE06    POST CHOOSE MESSAGE
         LTR   R7,R7
         BZ    RSCBADZ             GO PAINT SCREEN AGAIN
        $FS    SF=NORMAL,MF=(I,(R7)) RESET ERROR INPUT
         XR    R7,R7
RSCBADZ  MVC   SC8LN12R,=CL50' '   CLEAR THE DECIMAL ADDRESS
         MVC   SC8LN13R,=CL50' '    " "  THE HEX ADDRESS
         B     RSCINIT             GO PAINT SCREEN AGAIN
R$SCRX  $XRET  CC=(R15)
         SPACE 1
        LTORG
         SPACE 1
SCREEN8  $FS   CC=EW,WCC=(KBR,RMDT),SBA=(1,1),RA=(1,1,00),MF=L
         $FS   SBA=(1,1),SF=(SKIP,INT),MF=L
         $FS   SBA=(1,19),MF=L
         $FS   TEXT='T S O   A R I T H M E T I C   C O M M A N D',MF=L
         $FS   SBA=(2,1),RA=(3,1,-),MF=L
         $FS   SBA=(4,4),SF=(SKIP),MF=L
         $FS   TEXT='====   3 2 7 0   B U F F E R   A D D ',MF=L
         $FS   TEXT='R E S S   P R O C E S S O R   ====',MF=L
         $FS   SBA=(5,80),SF=(SKIP,INT),MF=L
         $FS   RA=(7,1,-),MF=L
         $FS   SBA=(9,3),MF=L
SC8LN091 $FS   SF=NORMAL,MF=L
SC8LN09N $FS   TEXT=(' ',1),MF=L
         $FS   SF=(SKIP,INT),TEXT='<====',MF=L
         $FS   SF=(SKIP),TEXT='Enter screen',MF=L
         $FS   SF=(SKIP,INT),TEXT='Model',MF=L
         $FS   SF=(SKIP),TEXT='number',MF=L
         $FS   SF=(SKIP,INT),TEXT='(2, 3, 4',MF=L
         $FS   SF=(SKIP),TEXT='or',MF=L
         $FS   SF=(SKIP,INT),TEXT='5)',MF=L
         $FS   SF=(SKIP),TEXT='= ---> Screen',MF=L
         $FS   SF=(SKIP,INT),TEXT='SIZE=(',MF=L
SC8LN09R $FS   TEXT=(' ',7),MF=L
         $FS   SF=(SKIP),MF=L
         $FS   SBA=(12,2),MF=L
SC8LN121 $FS   SF=NORMAL,MF=L
SC8LN12N $FS   TEXT=(' ',2),MF=L
         $FS   SF=(SKIP,INT),TEXT='<====',MF=L
         $FS   SF=(SKIP),TEXT='Enter',MF=L
         $FS   SF=(SKIP,INT),TEXT='ROW',MF=L
         $FS   SF=(SKIP),TEXT='number',MF=L
         $FS   SBA=(12,45),MF=L
         $FS   SF=(SKIP),TEXT='Screen address',MF=L
         $FS   SF=(SKIP,INT),TEXT='(Decimal) ====> ',MF=L
SC8LN12R $FS   TEXT=(' ',4),MF=L
         $FS   SBA=(13,1),MF=L
SC8LN131 $FS   SF=NORMAL,MF=L
SC8LN13N $FS   TEXT=(' ',3),MF=L
         $FS   SF=(SKIP,INT),TEXT='<====',MF=L
         $FS   SF=(SKIP),TEXT='Enter',MF=L
         $FS   SF=(SKIP,INT),TEXT='COLUMN',MF=L
         $FS   SF=(SKIP),TEXT='number',MF=L
         $FS   SBA=(13,63),SF=(SKIP,INT),TEXT='(Hex) ====> ',MF=L
SC8LN13R $FS   TEXT=(' ',4),MF=L
         $FS   SBA=(16,2),MF=L
SC8LN161 $FS   SF=NORMAL,MF=L
SC8LN16N $FS   TEXT=(' ',2),MF=L
         $FS   SF=(SKIP,INT),TEXT='<====',MF=L
         $FS   SF=(SKIP),TEXT='Enter the',MF=L
         $FS   SF=(SKIP,INT),TEXT='1st byte',MF=L
         $FS   SF=(SKIP),TEXT='of the',MF=L
         $FS   SF=(SKIP,INT),TEXT='Buffer Address',MF=L
         $FS   SF=(SKIP),MF=L
         $FS   SBA=(17,2),MF=L
SC8LN171 $FS   SF=NORMAL,MF=L
SC8LN17N $FS   TEXT=(' ',2),MF=L
         $FS   SF=(SKIP,INT),TEXT='<====',MF=L
         $FS   SF=(SKIP),TEXT='Enter the',MF=L
         $FS   SF=(SKIP,INT),TEXT='2nd byte',MF=L
         $FS   SF=(SKIP),TEXT='of the',MF=L
         $FS   SF=(SKIP,INT),TEXT='Buffer Address',MF=L
         $FS   SF=(SKIP),MF=L
         $FS   SBA=(20,1),SF=(SKIP,INT),TEXT='Note:',MF=L
         $FS   SF=(SKIP),TEXT='If you are converting from',MF=L
         $FS   SF=(SKIP,INT),TEXT='ROW/COLUMN',MF=L
         $FS   SF=(SKIP),TEXT='format to',MF=L
         $FS   SF=(SKIP,INT),TEXT='Buffer Address',MF=L
         $FS   SF=(SKIP),TEXT='format, do',MF=L
         $FS   SBA=(21,8),TEXT='not type in the Buffer Address',MF=L
         $FS   TEXT=' data. If you are converting',MF=L
         $FS   SF=(SKIP,INT),TEXT='Buffer Address',MF=L
         $FS   SBA=(22,7),SF=(SKIP),TEXT='to',MF=L
         $FS   SF=(SKIP,INT),TEXT='ROW/COLUMN',MF=L
         $FS   SF=(SKIP),TEXT='format, do not type in the ',MF=L
         $FS   TEXT='ROW/COLUMN data.',MF=L
         $FS   SBA=(23,80),MF=L
SC8LN24  $FS   TEXT=(' ',88),MF=L
SC8CSRP  $FS   SBA=(9,4),SF=(IC),MF=L
LSCREEN8 EQU   *-SCREEN8
         SPACE 1
         DROP  R9
         EJECT
*------> INPUT "SCREEN8" PROCESS ROUTINE.
*        AT EXIT : R1=INPUT TRUE LENGTH AND R3=INPUT SCAN LENGTH.
         SPACE 1
RSCRT8  $XENT  BASE=(R9)
         XR    R2,R2               INITIAL COUNT
R8LOOP  @FSR   ,                   GET REPLY TEXT
         LTR   R15,R15             NO MORE FIELDS MODIFIED?
         BNZ   R8PRCD              NO
         L     R1,4(R13)           YES, END, GET PREVIOUS SAVE AREA
         ST    R2,24(R1)           PASS BACK COUNT IN R1
         LA    R2,10               AND INPUT SCAN LENGTH IN R3
         ST    R2,32(R1)
         XR    R15,R15             EXIT
        $XRET  CC=(R15)
R8PRCD   CLC   SC8CSF1,0(R15)
         BE    R8FL1
         CLC   SC8CSF2,0(R15)
         BE    R8FL2
         CLC   SC8CSF3,0(R15)
         BE    R8FL3
         CLC   SC8CSF4,0(R15)
         BE    R8FL4
         CLC   SC8CSF5,0(R15)
         BE    R8FL5
         B     R8LOOP              UNEXPECTED (CHECK SCREEN IMAGE)
R8FL1    LTR   R1,R1
         BZ    R8FC1               FIELD CLEARED (CANC FC)
         CH    R1,=H'1'
         BNE   R8LOOP              UNEXPECTED (CHECK SCREEN IMAGE)
         MVI   INPUT+0,C' '        FOR UPPERCASE
         OC    INPUT+0(1),3(R15)   COPY MODEL
         B     R8BF1
R8FC1    MVI   INPUT+0,C'_'        MODEL CLEARED
R8BF1    LA    R2,1(R2)            BUMP COUNT
         B     R8LOOP
R8FL2    LTR   R1,R1
         BZ    R8FC2               FIELD CLEARED (CANC FC)
         CH    R1,=H'2'
         BH    R8LOOP              UNEXPECTED (CHECK SCREEN IMAGE)
         MVC   INPUT+1(2),=CL50' ' FOR UPPERCASE
         LA    R14,INPUT+2
         SH    R1,=H'1'
         SR    R14,R1
         EX    R1,R8OF2            COPY ROW NUMBER
         CLI   INPUT+1,C'_'
         BNE   *+L'*+4
         MVI   INPUT+1,C' '
         CLI   INPUT+2,C'_'
         BNE   *+L'*+4
         MVI   INPUT+2,C' '
         CLC   INPUT+1(2),=CL50' '
         BE    R8FC2
         CLI   INPUT+2,C' '
         BNE   R8BF2
         MVC   INPUT+2(1),INPUT+1
         MVI   INPUT+1,C' '
         B     R8BF2
R8FC2    MVC   INPUT+1(2),=CL3'___' ROW NUMBER CLEARED
R8BF2    LA    R2,2(R2)            BUMP COUNT
         B     R8LOOP
R8OF2    OC    0(*-*,R14),3(R15)   <<EXECUTED>>
R8FL3    LTR   R1,R1
         BZ    R8FC3               FIELD CLEARED (CANC FC)
         CH    R1,=H'3'
         BH    R8LOOP              UNEXPECTED (CHECK SCREEN IMAGE)
         MVC   INPUT+3(3),=CL50' ' FOR UPPERCASE
         LA    R14,INPUT+5
         SH    R1,=H'1'
         SR    R14,R1
         EX    R1,R8OF3            COPY COLUMN NUMBER
         CLI   INPUT+3,C'_'
         BNE   *+L'*+4
         MVI   INPUT+3,C' '
         CLI   INPUT+4,C'_'
         BNE   *+L'*+4
         MVI   INPUT+4,C' '
         CLI   INPUT+5,C'_'
         BNE   *+L'*+4
         MVI   INPUT+5,C' '
         CLC   INPUT+3(3),=CL50' '
         BE    R8FC3
R8SF3    CLI   INPUT+5,C' '
         BNE   R8BF3
         MVC   INPUT+5(1),INPUT+4
         MVC   INPUT+4(1),INPUT+3
         MVI   INPUT+3,C' '
         B     R8SF3
R8FC3    MVC   INPUT+3(3),=CL3'___' ROW NUMBER CLEARED
R8BF3    LA    R2,3(R2)            BUMP COUNT
         B     R8LOOP
R8OF3    OC    0(*-*,R14),3(R15)   <<EXECUTED>>
R8FL4    LTR   R1,R1
         BZ    R8FC4               FIELD CLEARED (CANC FC)
         CH    R1,=H'2'
         BH    R8LOOP              UNEXPECTED (CHECK SCREEN IMAGE)
         MVC   INPUT+6(2),=CL50' ' FOR UPPERCASE
         SH    R1,=H'1'
         EX    R1,R8OF4            COPY 1ST BUFFER ADDR
         CLC   INPUT+6(2),=CL50' '
         BNE   R8BF4
R8FC4    MVC   INPUT+6(2),=CL3'___' 1ST BUFFER ADDR CLEARED
R8BF4    LA    R2,2(R2)            BUMP COUNT
         B     R8LOOP
R8OF4    OC    INPUT+6(*-*),3(R15) <<EXECUTED>>
R8FL5    LTR   R1,R1
         BZ    R8FC5               FIELD CLEARED (CANC FC)
         CH    R1,=H'2'
         BH    R8LOOP              UNEXPECTED (CHECK SCREEN IMAGE)
         MVC   INPUT+8(2),=CL50' ' FOR UPPERCASE
         SH    R1,=H'1'
         EX    R1,R8OF5            COPY 2ND BUFFER ADDR
         CLC   INPUT+8(2),=CL50' '
         BNE   R8BF5
R8FC5    MVC   INPUT+8(2),=CL3'___' 2ND BUFFER ADDR CLEARED
R8BF5    LA    R2,2(R2)            BUMP COUNT
         B     R8LOOP
R8OF5    OC    INPUT+8(*-*),3(R15) <<EXECUTED>>
SC8CSF1  $FS   SBA=(9,4),MF=L
SC8CSF2  $FS   SBA=(12,3),MF=L
SC8CSF3  $FS   SBA=(13,2),MF=L
SC8CSF4  $FS   SBA=(16,3),MF=L
SC8CSF5  $FS   SBA=(17,3),MF=L
         SPACE 1
        LTORG
         SPACE 1
         DROP  R9
         EJECT
*------> FULL-SCREEN SERVICE ROUTINE (STANDARD 24 X 80 SCREEN).
*        AT ENTRY, THE ROUTINE HAS THREE INPUTS :
*              "ASCRIPTR" POINTS TO THE SCREEN IMAGE,
*              "ASCRLGTH" POINTS TO THE SCREEN IMAGE LENGTH,
*              "ASCRRTN" POINTS TO THE INPUT SCREEN PROCESS ROUTINE.
*        AT EXIT : R15 = 0 - RETURN TO MENU, WILD GOTO
*                        4 - ERROR
*                        8 - R1 = ZERO -> RESHOW
*                                 MINUS -> CLEAR AND END
*                                 PLUS -> ANALYZE INPUT
         SPACE 1
FULLSCR $XENT  BASE=(R9)
*        --> DO FULL-SCREEN TPUT (OUTPUT) AND TGET (INPUT).
         NI    OPTFS,FSFULL+FSSNAP
         L     R2,ASCRIPTR
        @FS    OPTFS,(R2),ASCRLGTH,MF=(E,FSPARM)
         LTR   R15,R15
         BZ    FSCHKTX
         CH    R15,=H'8'           END REQUESTED?
         BE    *+L'*+8             YES
         LA    R15,4               NO, ERROR, SET RC=4
         B     FSX                 EXIT
         L     R1,=F'-1'           YES (PA-KEY)
         B     FSRC
FSCHKTX  LTR   R1,R1               AID?
         BZ    FSNONE              NO, NONE
         CLI   0(R1),X'7D'         YES, ENTER KEY?
         BE    FSENTER             YES
         CLI   0(R1),X'F1'         NO, PF-KEY 1-9?
         BL    FSNONE              NO
         CLI   0(R1),X'F9'
         BNH   FSPFKEY             YES
FSNONE   XR    R1,R1               NO, RE-DISPLAY
         B     FSRC
FSENTER #GO    ASCRRTN,AR=D        GO TO REPLY ROUTINE
*        -->   AT EXIT, R1=INPUT TRUE LENGTH AND R3=INPUT SCAN LENGTH.
         CH    R1,=H'2'            DID WE GET ANYTHING USABLE?
         BL    FSRC                NO, EXIT
         XR    R15,R15             SET RC=0
         LA    R2,INPUT            GET ADDRESS OF INPUT
FSCHKDIR CLI   0(R2),C'='          DID USER WANT TO GO SOMEWHERE?
         BE    FSWILDGO            YEP, DO IT TO IT ...
         LA    R2,1(R2)            BUMP PTR
         BCT   R3,FSCHKDIR         ITERATE
FSRC     LA    R15,8               NOT FOUND, SET RC=8
         L     R14,4(R13)          PREVIOUS SAVE AREA
         ST    R1,24(R14)          SET BACK R1
         B     FSX                 EXIT
FSWILDGO MVC   INPUT+0(1),1(R2)    MOVE THE REQUESTED OPTION
         OI    INPUT+0,C' '        UPPERCASE IT
         CLI   INPUT+0,C'X'        WAS IT =X?
         BNE   FSX                 NO, EXIT
         MVI   INPUT+0,C' '        YES, RE-DISPLAY MAIN MENU
         B     FSX                 EXIT
FSPFKEY  MVC   INPUT+0(1),0(R1)    MOVE THE REQUESTED OPTION
FSX     $XRET  CC=(R15)
         SPACE 1
        LTORG
         SPACE 1
         DROP  R9
         EJECT
*------> INPUT TO THIS ROUTINE IS AN 8 CHARACTER REPRESENTATION OF A
*              FULLWORD HEX NUMBER. THIS ROUTINE RIGHT-JUSTIFIES THE
*              NUMBER, CHECKS IT FOR ALLOWABLE CHARACTERS, PADS IT WITH
*              ZEROES, AND TRANSLATES IT INTO REAL HEX AND DECIMAL.
*              INPUT TO THE ROUTINE IS IN HDINPUT, OUTPUT IS HDOUTHEX,
*              HDOUTDEC, HDINPUT(NORMALIZED), AND HDRC.
*              HDRC=0 (GOOD), HDRC=1 (BAD).
         SPACE 1
HEXDEC  $XENT  BASE=(R9)
         MVI   HDRC,C'0'           INIT TO GOOD
*        --> CHECK FOR VALID HEX CHARACTERS.
         TRT   HDINPUT,TRTHEX      ANY INVALID CHARS?
         BNZ   HCVDBAD             GO PUT OUT BAD MESSAGE
*        --> RIGHT-JUSTIFY HEX REPRESENTATION.
         LA    R2,L'HDINPUT        GET LENGTH OF INPUT
HCVDFNDB CLI   HDINPUT+L'HDINPUT-1,C' ' IS IT A BLANK?
         BNE   HCVDNOTB            NO, FINISHED
         MVC   HDWORK+1(L'HDINPUT-1),HDINPUT MOVE FIRST 7
         MVI   HDWORK,C' '         REPLACE WITH A BLANK
         MVC   HDINPUT,HDWORK      MOVE IT BACK
         BCT   R2,HCVDFNDB         GO TRY NEXT
         B     HCVDBAD             ALL BLANKS? - PUT OUT ERROR
*        --> REPLACE LEADING BLANKS WITH ZEROES.
HCVDNOTB LA    R3,HDINPUT          GET BEGINNING ADDRESS
         LA    R2,L'HDINPUT        GET LENGTH
HCVDTRBL CLI   0(R3),C' '          IS IT A BLANK?
         BNE   HCVDTR              NO, GO TRANSLATE
         MVI   0(R3),C'0'          CHANGE IT TO A ZERO
         LA    R3,1(R3)            BUMP INDEX
         BCT   R2,HCVDTRBL         GO TRY NEXT BYTE
*        --> CHECK FOR ANY REMAINING BLANKS.
HCVDTR   MVI   TRTHEX+C' ',X'FF'   CHANGE BLANKS TO INVALID
         TRT   HDINPUT,TRTHEX      ANY INVALID CHARS?
         MVI   TRTHEX+C' ',X'00'   RESTORE TRT TABLE
         BNZ   HCVDBAD             YES, GO PUT OUT BAD MESSAGE
*        --> TRANSLATE HEX CHARS TO HEX NIBBLES AND CONVERT RADIX.
         MVC   HDWORK,HDINPUT      COPY INPUT TO WORK
         TR    HDWORK,TRHEXNIB     TRANSLATE HEX TO NIBBLES
         LA    R2,L'HDWORK         GET LENGTH
         LA    R3,HDWORK           GET BEGINNING ADDRESS
         XR    R4,R4               CLEAR REGISTER
         XC    WORKDBLW,WORKDBLW   CLEAR WORK AREA
HCVDLOAD MVC   WORKDBLW+3(1),0(R3) MOVE TRANSLATED CHAR
         SLL   R4,4                SHIFT LEFT 4 BITS
         O     R4,WORKDBLW         OR IN THE NIBBLE
         LA    R3,1(R3)            BUMP INDEX
         BCT   R2,HCVDLOAD         GO LOAD NEXT NIBBLE
         ST    R4,HDOUTHEX         STORE HEX OUTPUT
         CVD   R4,HDOUTDEC         STORE DEC OUTPUT
*        --> REPLACE LEADING ZEROES WITH BLANKS IN HEX FIELD.
         LA    R2,L'HDINPUT-1      GET LENGTH -1
         LA    R3,HDINPUT          GET BEGINNING OF FIELD
HCVDRPL0 CLI   0(R3),C'0'          IS IT A ZERO?
         BNE   HEXDECX             NO, EXIT
         MVI   0(R3),C' '          REPLACE WITH A BLANK
         LA    R3,1(R3)            BUMP BY 1
         BCT   R2,HCVDRPL0         ITERATE THROUGH ZERO CHECK
         B     HEXDECX             BRANCH AROUND ERROR CODE
*        --> FLAG AS BAD INPUT.
HCVDBAD  MVI   HDRC,C'1'           FLAG AS BAD
HEXDECX $XRET  CC=0
         SPACE 1
        LTORG
         SPACE 1
         DROP  R9
         EJECT
*------> INPUT TO THIS ROUTINE IS A 15-DIGIT DECIMAL NUMBER IN
*              CHARACTER FORMAT. THIS ROUTINE RIGHT-JUSTIFIES THE
*              NUMBER, CHECKS IT FOR ALLOWABLE CHARACTERS, PADS IT WITH
*              ZEROES, AND TRANSLATES IT INTO REAL HEX AND DECIMAL.
*              INPUT TO RTN IS DHINPUT, OUTPUT IS DHOUTHEX, DHOUTDEC,
*              DHOUTCHR, DHINPUT(NORMALIZED), AND HDRC.
*              DHRC=0 (GOOD), DHRC=1 (BAD).
         SPACE 1
DECHEX  $XENT  BASE=(R9)
         MVI   DHRC,C'0'           INIT TO GOOD
         MVI   DHNEG,C'+'          INITIALIZE TO POSITIVE
*        --> CHECK FOR NEGATIVE SIGN.
         XC    TRCOMMON,TRCOMMON   CLEAR COMMON TRT AREA
         MVI   TRCOMMON+C'+',C'+'  INSERT A PLUS SIGN
         TRT   DHINPUT,TRCOMMON    DID USER TYPE IN A PLUS SIGN?
         BZ    *+L'*+8             GO TRY DASH
         MVI   0(R1),C' '          REPLACE PLUS SIGN WITH BLANK
         B     HCVBRTJS            GO RIGHT-JUSTIFY
         MVI   TRCOMMON+C'+',X'00' CLEAR PLUS SIGN FROM TRT AREA
         MVI   TRCOMMON+C'-',C'-'  INSERT A DASH
         TRT   DHINPUT,TRCOMMON    DID USER TYPE IN NEGATIVE SIGN?
         BZ    HCVBRTJS            GO RIGHT-JUSTIFY
         MVI   0(R1),C' '          REPLACE NEG SIGN WITH BLANK
         MVI   DHNEG,C'-'          SET SIGN SWITCH TO NEGATIVE
*        --> CHECK FOR ILLEGALS THEN RIGHT-JUSTIFY.
HCVBRTJS TRT   DHINPUT,TRTDEC      ANY INVALID CHARS?
         BNZ   HCVBBAD             GO PUT OUT BAD MESSAGE
         LA    R2,L'DHINPUT        GET LENGTH OF INPUT
HCVBFNDB CLI   DHINPUT+L'DHINPUT-1,C' ' IS IT A BLANK?
         BNE   HCVBNOTB            NO, FINISHED
         MVC   DHWORK+1(L'DHINPUT-1),DHINPUT MOVE FIRST 15
         MVI   DHWORK,C' '         REPLACE WITH A BLANK
         MVC   DHINPUT,DHWORK      MOVE IT BACK
         BCT   R2,HCVBFNDB         GO TRY NEXT
         B     HCVBBAD             ALL BLANKS? - PUT OUT ERROR
*        --> REPLACE LEADING BLANKS WITH ZEROES.
HCVBNOTB LA    R3,DHINPUT          GET BEGINNING ADDRESS
         LA    R2,L'DHINPUT        GET LENGTH
HCVBTRBL CLI   0(R3),C' '          IS IT A BLANK?
         BNE   HCVBTR              NO, GO TRANSLATE
         MVI   0(R3),C'0'          CHANGE IT TO A ZERO
         LA    R3,1(R3)            BUMP INDEX
         BCT   R2,HCVBTRBL         GO TRY NEXT BYTE
*        --> CHECK FOR ANY REMAINING BLANKS.
HCVBTR   MVI   TRTDEC+C' ',X'FF'   CHANGE BLANKS TO INVALID
         TRT   DHINPUT,TRTDEC      ANY INVALID CHARS?
         MVI   TRTDEC+C' ',X'00'   RESTORE TRT TABLE
         BNZ   HCVBBAD             YES, GO PUT OUT BAD MESSAGE
*        --> TRANSLATE DECIMAL NUMBER TO HEX.
         PACK  DHOUTDEC,DHINPUT    PACK INPUT
         MVC   DHINPUT(L'DHINPUT-1),DHINPUT+1 SHIFT LEFT 1 BYTE
         MVC   DHINPUT+L'DHINPUT-1(1),DHNEG INDICATE NEG OR POSITIVE
         CLI   DHNEG,C'+'          IS IT POSITIVE?
         BE    *+L'*+8             BYPASS CHANGE SIGN
         NI    DHOUTDEC+7,X'F0'    TURN OFF BITS IN SIGN
         OI    DHOUTDEC+7,X'0D'    INDICATE NEGATIVE
         L     R1,=A(ESPLST)
        ESPIE  SET,MF=(E,(1))      INTERCEPT INT = 9
         ST    R1,OLDPICA          OLD PICA ADDRESS
         CVB   R2,DHOUTDEC         CONVERT TO BINARY
        ESPIE  RESET,OLDPICA       RESTORE SPIE/ESPIE ENVIRONMENT
         ST    R2,DHOUTHEX         STORE HEX VERSION
         LA    R3,L'DHOUTCHR       GET NUMBER OF NIBBLES
         LA    R4,DHOUTCHR+L'DHOUTCHR-1 GET BEGIN ADDRESS
HCVBCHR1 STC   R2,0(R4)            STORE LOW-ORDER NIBBLE
         SRL   R2,4                SHIFT RIGHT ONE NIBBLE
         BCTR  R4,0                SUBTRACT ONE FROM INDEX
         BCT   R3,HCVBCHR1         ITERATE THROUGH ZERO CHECK
         NC    DHOUTCHR,=8XL1'0F'  AND OUT HIGH ORDER NIBBLE
         TR    DHOUTCHR,TRHEXCHR   TRANSLATE TO REAL CHARACTERS
*--> REPLACE LEADING ZEROES WITH BLANKS IN HEX FIELD
         LA    R2,L'DHOUTCHR-1     GET LENGTH -1
         LA    R3,DHOUTCHR         GET BEGINNING OF FIELD
HCVBRPL0 CLI   0(R3),C'0'          IS IT A ZERO?
         BNE   HCVBRPL1            NO, EXIT
         MVI   0(R3),C' '          REPLACE WITH A BLANK
         LA    R3,1(R3)            BUMP BY 1
         BCT   R2,HCVBRPL0         ITERATE THROUGH ZERO CHECK
*        --> REPLACE LEADING ZEROES WITH BLANKS IN DEC FIELD.
HCVBRPL1 LA    R2,L'DHINPUT-2      GET LENGTH -2 (LAST IS SIGN)
         LA    R3,DHINPUT          GET BEGINNING OF FIELD
HCVBRPL2 CLI   0(R3),C'0'          IS IT A ZERO?
         BNE   DECHEXX             NO, EXIT
         MVI   0(R3),C' '          REPLACE WITH A BLANK
         LA    R3,1(R3)            BUMP BY 1
         BCT   R2,HCVBRPL2         ITERATE THROUGH ZERO CHECK
         B     DECHEXX             BYPASS ERROR CODE
RECOVER ESPIE  RESET,OLDPICA       RESTORE SPIE/ESPIE ENVIRONMENT
*        --> FLAG AS BAD INPUT.
HCVBBAD  MVI   DHRC,C'1'           FLAG AS BAD
DECHEXX $XRET  CC=0
         SPACE 1
        LTORG
         SPACE 1
         DROP  R9
         SPACE 1
         CNOP  0,8
         USING *,R15
         USING EPIE,R1
ESPEXIT  MVC   EPIEPSW+4(4),RCVADDR     SET RETURN ADDRESS
         BR    R14                 BACK TO CONTROL PROGRAM
         DROP  R1
         SPACE 1
RCVADDR  DC    A(RECOVER)
         SPACE 1
         DROP  R15
         EJECT
*------> THIS ROUTINE HANDLES ALL PRELIMINARY EDITING AND CONVERSION
*              FOR THE HIGHER LEVEL ROUTINES THAT PERFORM DYADIC
*              OPERATIONS SUCH AS ADDITION AND MULTIPLICATION.
*              AT ENTRY TO THE ROUTINE, THE INPUT IS LOCATED IN THE
*              'INPUT' INPUT BUFFER.
*        AT EXIT, R15 = 0, 4, 8, 12, 16 or 20.
         SPACE 1
DYADIC  $XENT  BASE=(R9)
         XR    R15,R15             CLEAR RETURN CODE REGISTER
*        --> MOVE THE INPUT DATA FROM INPUT AREA TO FORMAT AREA.
         MVC   DIRADIX1,INPUT+0    MOVE RADIX 1
         MVC   DIDATA1,INPUT+1     MOVE DATA 1
         MVC   DIRADIX2,INPUT+17   MOVE RADIX 2
         MVC   DIDATA2,INPUT+18    MOVE DATA 2
         MVC   DIRADIX3,INPUT+34   MOVE RADIX 3
*        --> CHECK THAT RADIX ITEMS ARE ALLOWABLE.
         MVI   TRCOMMON,X'FF'      SET UP TRT AREA
         MVC   TRCOMMON+1(L'TRCOMMON-1),TRCOMMON
         MVI   TRCOMMON+C'D',X'00' ALLOW D=DECIMAL
         MVI   TRCOMMON+C'X',X'00'  " "  X=HEX
         TRT   DIRADIX1,TRCOMMON   RADIX 1 OK?
         BNZ   DPERR04             GO FLAG ERROR RC=04
         TRT   DIRADIX2,TRCOMMON   RADIX 2 OK?
         BNZ   DPERR08             GO FLAG ERROR RC=08
         TRT   DIRADIX3,TRCOMMON   RADIX 3 OK?
         BNZ   DPERR12             GO FLAG ERROR RC=12
*        --> CHECK THE DATA ITEMS FOR DECIMAL.
         CLI   DIRADIX1,C'D'       DECIMAL?
         BNE   DPCHKD2             NO, CHECK RADIX 2 : DEC
         MVC   DHINPUT,DIDATA1     SET INPUT UP
        #GO    DECHEX              CALL REFORMAT ROUTINE
         CLI   DHRC,C'1'           DID IT GO OK?
         BE    DPERR16             NO, FLAG ERROR RC=16
         MVC   DIDATA1,DHINPUT     MOVE REFORMATTED INPUT
         ZAP   RESULT1,DHOUTDEC    SAVE RESULT IN RESULT1
DPCHKD2  CLI   DIRADIX2,C'D'       DECIMAL?
         BNE   DPCHKX1             NO, CHECK RADIX 1 : HEX
         MVC   DHINPUT,DIDATA2     SET INPUT UP
        #GO    DECHEX              CALL REFORMAT ROUTINE
         CLI   DHRC,C'1'           DID IT GO OK?
         BE    DPERR20             NO, FLAG ERROR RC=20
         MVC   DIDATA2,DHINPUT     MOVE REFORMATTED INPUT
         ZAP   RESULT2,DHOUTDEC    SAVE RESULT IN RESULT2
*        --> CHECK THE DATA ITEMS FOR HEX; LEFT JUSTIFY AND CONVERT.
DPCHKX1  CLI   DIRADIX1,C'D'       DECIMAL?
         BE    DPCHKX2             YES, ALREADY CHECKED ABOVE
         LA    R2,8                NUMBER OF BYTES
         LA    R3,DIDATA1          GET BEGINNING ADDRESS
DPX1LP01 CLI   0(R3),C' '          IS THIS A BLANK?
         BNE   DPX1LP02            NO, BREAK OUT OF LOOP
         MVC   DIDATA1(L'DIDATA1-1),DIDATA1+1 SHIFT LEFT ONE BYTE
         MVI   DIDATA1+L'DIDATA1-1,C' ' CLEAR SLACK BYTE
         BCT   R2,DPX1LP01         ITERATE 8 TIMES
DPX1LP02 MVC   HDINPUT,DIDATA1     SET INPUT UP
        #GO    HEXDEC              CALL REFORMAT ROUTINE
         CLI   HDRC,C'1'           DID IT GO OK?
         BE    DPERR16             NO, FLAG ERROR RC=16
         MVC   DIDATA1+0(8),=CL50' ' CLEAR BEGINNING PART
         MVC   DIDATA1+8(8),HDINPUT MOVE REFORMATTED INPUT
         ZAP   RESULT1,HDOUTDEC    SAVE RESULT IN RESULT1
DPCHKX2  CLI   DIRADIX2,C'D'       DECIMAL?
         BE    DYADICX             YES, ALREADY CHECKED:EXIT RTN
         LA    R2,8                NUMBER OF BYTES
         LA    R3,DIDATA2          GET BEGINNING ADDRESS
DPX2LP01 CLI   0(R3),C' '          IS THIS A BLANK?
         BNE   DPX2LP02            NO, BREAK OUT OF LOOP
         MVC   DIDATA2(L'DIDATA2-1),DIDATA2+1 SHIFT LEFT ONE BYTE
         MVI   DIDATA2+L'DIDATA2-1,C' ' CLEAR SLACK BYTE
         BCT   R2,DPX2LP01         ITERATE 8 TIMES
DPX2LP02 MVC   HDINPUT,DIDATA2     SET INPUT UP
        #GO    HEXDEC              CALL REFORMAT ROUTINE
         CLI   HDRC,C'1'           DID IT GO OK?
         BE    DPERR20             NO, FLAG ERROR RC=20
         MVC   DIDATA2+0(8),=CL50' ' CLEAR BEGINNING PART
         MVC   DIDATA2+8(8),HDINPUT MOVE REFORMATTED INPUT
         ZAP   RESULT2,HDOUTDEC    SAVE RESULT IN RESULT2
         B     DYADICX             EXIT RTN
DPERR04  LA    R15,4               INDICATE RADIX 1 NO GOOD
         B     DYADICX             EXIT RTN
DPERR08  LA    R15,8               INDICATE RADIX 2 NO GOOD
         B     DYADICX             EXIT RTN
DPERR12  LA    R15,12              INDICATE RADIX 3 NO GOOD
         B     DYADICX             EXIT RTN
DPERR16  LA    R15,16              INDICATE DATA 1 NOT DECIMAL
         B     DYADICX             EXIT RTN
DPERR20  LA    R15,20              INDICATE DATA 2 NOT DECIMAL
DYADICX $XRET  CC=(R15)
         SPACE 1
        LTORG
         SPACE 1
         DROP  R9
         EJECT
*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*
*          W O R K I N G     S T O R A G E     S E C T I O N          *
*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*
         SPACE 1
WORKDBLW DC    D'0'                HEX/DECIMAL CONVERSION AREA
ATIOT    DC    A(*-*)
ATSO     DC    A(*-*)
APSCB    DC    A(*-*)
ERRMSA   DC    F'0'
ASCRIPTR DC    A(*-*)              PTR TO ACTIVE SCREEN IMAGE
ASCRLGTH DC    A(*-*)              PTR TO LENGTH OF ACTIVE SCREEN IMAGE
ASCRRTN  DC    A(*-*)              PTR TO PROCESS READ SCREEN ROUTINE
*                                  INT.CODE :  9 = FIXED-POINT DIVIDE
ESPLST  ESPIE  SET,ESPEXIT,(9),MF=L
OLDPICA  DC    F'0'                SAVE OLD PICA ADDRESS
FSPARM  @FS    ,,,MF=L
FSMSBA   EQU   6*L'SC1CSF1         MAX. = 6 * SCREEN BUFFER ADDRESSES
FSBFSZ   DC    A((((FSMSBA+L'INPUT)+7)/8)*8) MAX. => L.SBA'S + TEXT
ERRMSL   DC    H'0'
INPUT    DC    CL50' '             INPUT FROM TERMINAL VIA TGET
RESULT1  DC    PL16'0'             RESULT 1 FROM DYADIC ROUTINE
RESULT2  DC    PL16'0'             RESULT 2 FROM DYADIC ROUTINE
RESULT3  DC    PL16'0'             RESULT 3 FROM PROCESSORS
REMAIN   DC    PL16'0'             REMAINDER FROM DIVIDE PROCESSOR
RESULT99 DC    PL16'0'             RESULT FROM LAST OPERATION
DIVWORK1 DC    PL9'0'              WORK AREA FOR DIVIDE PROC
         PRINT GEN
OPTFS   @FSO   ,
         PRINT &EULST
RESULTSW DC    CL1'0'              0=NO RESULT99, 1=CURR RESULT99
RESULTRD DC    CL1'D'              RESULT RADIX = D/X
MSG1     DC    C' -> "FSRTNI" routine failed / RC =    '
MSG1F1   EQU   MSG1+L'MSG1-4,4
MSG2     DC    C' -> "FSRTN" routine failed - OPT =    , RC =    '
MSG2F1   EQU   MSG2+35,2
MSG2F2   EQU   MSG2+L'MSG2-4,4
*        --> "END" line message is 7 SF's + 74 characters long, so,
*              the needed space is ((7 * 2) + 74) = 88 bytes long.
ENDLNE01 $FS   SF=(SKIP),TEXT='=============>',MF=L
         $FS   SF=(SKIP),TEXT='Enter menu',MF=L
         $FS   SF=(SKIP,INT),TEXT='option number',MF=L
         $FS   SF=(SKIP),TEXT='desired',MF=L
         $FS   SF=(SKIP),TEXT='then press',MF=L
         $FS   SF=(SKIP,INT),TEXT='ENTER',MF=L
         $FS   SF=(SKIP),TEXT='<==============',MF=L
LEL01    EQU   *-ENDLNE01          THIS VALUE MUST BE X'00058' (88)
ENDLNE02 $FS   SF=(SKIP,INT),TEXT='=================>',MF=L
         $FS   SF=(SKIP),TEXT='Correct',MF=L
         $FS   SF=(SKIP,INT),TEXT='option number',MF=L
         $FS   SF=(SKIP),TEXT='and',MF=L
         $FS   SF=(SKIP),TEXT='then press',MF=L
         $FS   SF=(SKIP,INT),TEXT='ENTER',MF=L
         $FS   SF=(SKIP,INT),TEXT='<=================',MF=L
LEL02    EQU   *-ENDLNE02          THIS VALUE MUST BE X'00058' (88)
ENDLNE03 $FS   SF=(SKIP,INT),TEXT='================>',MF=L
         $FS   SF=(SKIP,INT),TEXT='Option',MF=L
         $FS   SF=(SKIP),TEXT='not in use -',MF=L
         $FS   SF=(SKIP,INT),TEXT='Correct',MF=L
         $FS   SF=(SKIP),TEXT='and press',MF=L
         $FS   SF=(SKIP,INT),TEXT='ENTER',MF=L
         $FS   SF=(SKIP,INT),TEXT='<=================',MF=L
LEL03    EQU   *-ENDLNE03          THIS VALUE MUST BE X'00058' (88)
ENDLNE04 $FS   SF=(SKIP),TEXT='======================>',MF=L
         $FS   SF=(SKIP),TEXT='To',MF=L
         $FS   SF=(SKIP,INT),TEXT='return',MF=L
         $FS   SF=(SKIP),TEXT='to menu press',MF=L
         $FS   SF=(SKIP,INT),TEXT='PA1',MF=L
         $FS   SF=(SKIP),TEXT='key',MF=L
         $FS   SF=(SKIP),TEXT='<=======================',MF=L
LEL04    EQU   *-ENDLNE04          THIS VALUE MUST BE X'00058' (88)
ENDLNE05 $FS   SF=(SKIP,INT),TEXT='===========>',MF=L
         $FS   SF=(SKIP,INT),TEXT='Invalid value',MF=L
         $FS   SF=(SKIP),TEXT='entered, please',MF=L
         $FS   SF=(SKIP,INT),TEXT='correct',MF=L
         $FS   SF=(SKIP),TEXT='and press',MF=L
         $FS   SF=(SKIP,INT),TEXT='ENTER',MF=L
         $FS   SF=(SKIP,INT),TEXT='<============',MF=L
LEL05    EQU   *-ENDLNE05          THIS VALUE MUST BE X'00058' (88)
ENDLNE06 $FS   SF=(SKIP,INT),TEXT='=================>',MF=L
         $FS   SF=(SKIP,INT),TEXT='Choose',MF=L
         $FS   SF=(SKIP),TEXT='either',MF=L
         $FS   SF=(SKIP,INT),TEXT='Row/Column',MF=L
         $FS   SF=(SKIP),TEXT='or',MF=L
         $FS   SF=(SKIP,INT),TEXT='Buffer Address',MF=L
         $FS   SF=(SKIP,INT),TEXT='<=================',MF=L
LEL06    EQU   *-ENDLNE06          THIS VALUE MUST BE X'00058' (88)
EDUNPK   DC    XL16'40202020202020202020202020202120'
         AIF   ('&EUEDN' EQ 'EUROPE').EDN1
DECEDIT  DC    XL21'402020206B2020206B2020206B2020206B20212060'
DECEDIT2 DC    XL18'40202020206B2020206B2020206B2020206B'
         DC    XL16'2020206B2020206B2020206B20212060'
         AGO   .EDN2
.EDN1    ANOP
DECEDIT  DC    XL21'402020204B2020204B2020204B2020204B20212060'
DECEDIT2 DC    XL18'40202020204B2020204B2020204B2020204B'
         DC    XL16'2020204B2020204B2020204B20212060'
.EDN2    ANOP
*        --> WORK DATA ITEMS FOR 3270 TRANSLATION ROUTINE.
RSCFLD1  DS    F                   WORK AREA
RSCFLD2  DS    F                   WORK AREA
RSCROW   DS    PL2                 SCREEN NUMBER OF ROWS
RSCCOL   DS    PL2                 SCREEN NUMBER OF COLUMNS
*        --> WORK DATA ITEMS FOR HEXDEC ROUTINE.
         DS    0D
HDINPUT  DS    CL8                 INPUT TO HEXDEC RTN
HDWORK   DS    CL8                 WORKAREA FOR HEXDEC RTN
HDOUTDEC DS    PL8                 OUTPUT FROM HEXDEC RTN:DEC
HDOUTHEX DS    F                   OUTPUT FROM HEXDEC RTN:HEX
HDRC     DS    CL1                 RETURN CODE FROM HEXDEC RTN
*        --> WORK DATA ITEMS FOR DECHEX ROUTINE.
         DS    0D
DHOUTDEC DS    PL8                 OUTPUT FROM DECHEX RTN:DEC
DHINPUT  DS    CL16                INPUT TO DECHEX RTN
DHWORK   DS    CL16                WORKAREA FOR DECHEX RTN
DHOUTCHR DS    CL8                 OUTPUT FROM DECHEX RTN:CHAR
DHOUTHEX DS    F                   OUTPUT FROM DECHEX RTN:HEX
DHRC     DS    CL1                 RETURN CODE FROM DECHEX RTN
DHNEG    DC    CL1'+'              '+'=POS, '-'=NEG
*        --> WORK AREA FOR THE DYADIC ROUTINE.
DIDATA1  DS    CL16                DATA NUMBER 1
DIDATA2  DS    CL16                DATA NUMBER 2
DEFRADIX EQU   C'D'                DEFAULT RADIX
DIRADIX1 DS    CL1                 D=DECIMAL, X=HEX
DIRADIX2 DS    CL1                 D=DECIMAL, X=HEX
DIRADIX3 DS    CL1                 D=DECIMAL, X=HEX
*        --> TRT TABLES.
         DS    0D
TRTHEX   DC    256XL1'FF'          ALL CHARS OTHER THAN
         ORG   TRTHEX+C'0'
         DC    10XL1'00'               0-9
         ORG   TRTHEX+C'A'
         DC    6XL1'00'                A-F
         ORG   TRTHEX+C' '
         DC    1XL1'00'                BLANK
         ORG
TRTDEC   DC    256XL1'FF'          ALL CHARS OTHER THAN
         ORG   TRTDEC+C'0'
         DC    10XL1'00'               0-9
         ORG   TRTDEC+C' '
         DC    1XL1'00'                BLANK
         ORG
TRHEXNIB DC    256XL1'00'          DEFAULT CHARACTERS ARE ZERO
         ORG   TRHEXNIB+C'0'
         DC    XL10'00010203040506070809' 0-9
         ORG   TRHEXNIB+C'A'
         DC    XL6'0A0B0C0D0E0F'       A-F
         ORG
TRCOMMON DC    XL256'00'           COMMON TRT AREA
TRHEXCHR DC    CL16'0123456789ABCDEF' TRANSLATE HEX TO HEX CHARS
*        --> IBM 3270 BASE 64 ENCODING TABLE.
*              (IS THERE A ROUTINE SOMEWHERE?)
TABLESCR DC    C'40C1C2C3C4C5C6C7C8C94A4B4C4D4E4F'
         DC    C'50D1D2D3D4D5D6D7D8D95A5B5C5D5E5F'
         DC    C'6061E2E3E4E5E6E7E8E96A6B6C6D6E6F'
         DC    C'F0F1F2F3F4F5F6F7F8F97A7B7C7D7E7F'
         SPACE 1
*- - - - DSECT'S - - - - - - - - - - - - - - - - - - - - - - - - - - -*
         PRINT NOGEN
        IKJCPPL
        IKJPSCB
        IKJEBECA
TIODSECT DSECT
        IEFTIOT1
        IHAEPIE
        PRINT  GEN
         SPACE 1
         END
