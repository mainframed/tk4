BSC3     TITLE 'I N I T I A L I Z A T I O N    L O G I C'
US1NG    OPSYN USING              MAKE 'US1NG' SAME AS 'USING'
USING    OPSYN ,                  CANCEL 'USING'
DR0P     OPSYN DROP               MAKE 'DR0P' SAME AS 'DROP'
DROP     OPSYN ,                  CANCEL 'DROP'
BSC3IO#  CSECT
         EQUREG
         SAVE  (14,12),,*         SAVE CALLER'S REGISTERS
         LR    R2,R1              TEMP PARM POINTER
         LR    R12,R15            CSECT BASE REGISTER
         L     R3,0(0,R2)         GET MY LTT ADDRESS
         SPACE
         USING LTT,R3             LTT ADDRESSABILITY
         USING TDCB,R4            TERMINAL DCB ADDRESSABILITY
         USING TDECB,R5           TERMINAL DECB ADDRESSABILITY
         USING IHADCB,R6          ADDRESSABILITY TO THE LINE DCB
         USING BSC3IO#,R12        CSECT ADDRESSABILITY
         USING LINEWORK,R13       SAVE AREA/WORK AREA
         SPACE
         SR    R4,R4              CLEAR TILL NEEDED
         SR    R5,R5              CLEAR TILL NEEDED
         SR    R6,R6              CLEAR TILL NEEDED
         EJECT
         LA    R1,POLLENTL        GET LEN OF 1 ENT IN POLL TABLE
         MH    R1,LTTTCNT         TIMES NBR TERM. = TABLE LEN
         LA    R1,L'POLLEOTS(R1)  PLUS LEN OF EOT ENTRY IN POLL LIST
         SLL   R1,1               TIMES 2 ALLOWS FOR INACTIVE ENTRIES
         LR    R10,R1             HOLD TILL IT CAN BE STORED
         AH    R1,LTTBUFFL        PLUS LEN OF I/O BUFFER
         LA    R1,WORKSIZE(0,R1)  PLUS FIXED WRK AREA = TOTAL WRK LEN
         LA    R0,SUBPOOL         GET WRK AREA SBPL NBR INTO R0
         SLL   R1,8               SHFT WRK AREA LEN INTO HI 3 BYTES
         SLDL  R0,24              LOAD IT ALL INTO R0 FOR GETMAIN
         SPACE
         GETMAIN R,LV=(0)         ALLOCATE THE WORK AREA
         SPACE
         LR    R11,R13            SAVE HSA POINTER
         LR    R13,R1             GET ADDRESSABILITY TO WORKAREA
*
*        WILL NULL THE WORK AREA BEFORE USING IT
*
         LA    R14,SAVEAREA       ADDR OF AREA TO CLEAR
         LA    R15,(WORKSIZE-L'SAVEAREA)(0,R10) LEN OF AREA TO NULL
         AH    R15,LTTBUFFL       PLUS I/O BUFFER LEN
         LA    R0,0               DON'T WANT A 'FROM' ADDR
         LA    R1,0               FORCE USE OF THE PAD CHARACTER
         MVCL  R14,R0
         SPACE
*        CHAIN SAVE AREAS THE OS WAY
         ST    R11,4(0,R13)       SET HSA POINTER
         ST    R13,8(0,R11)       SET LSA POINTER
         EJECT
*
*        WORK AREA NOW NULLED
*        MUST NOW INITIALIZE IT
*
         LA    R0,FIRSTBLK        GET ADDR OF INPUT AREA FOR BLK #1
         ST    R0,LN1BLKAD        SET POINTER
         ST    R10,POLLTBLN       SAVE LEN OF POLL LIST
         SRL   R10,1              DIVIDE BY 2 FOR ACTIVE LIST LEN
         ST    R10,POLSTCNT       SAVE ACTIVE LIST LEN
         LA    R10,FIRSTBLK       PICKUP ADDR OF VARIABLE LEN AREA
         AH    R10,LTTBUFFL       BUMP PAST BUFFER AREA
         ST    R10,POLSTADR       ST ADDR OF POLL LIST START ADDRESS
         MVI   CURRACK,DLE        INITIALIZE ACK FIELD
*        BUILD AND OPEN THE LINE DCB
         LA    R6,LINEDCB         SETUP DCB POINTER REG
         MVC   DCBDDNAM(DCBOPTCD-DCBDDNAM),LNEDCB+(DCBDDNAM-IHADCB)
*                                 MOVE IN DCB FOUNDATION
         MVC   DCBDDNAM,LTTDDNME  INSERT DDNAME FOR MY LINE
         OI    DCBIFLG,X'0C'      TURN OFF ERROR RECOVERY
         LA    R1,OPENLIST        ADDR OF LIST FORM OF OPEN
         MVI   OPENLIST,X'80'     INDICATE END OF OPEN LIST
         SPACE
         OPEN  ((R6)),MF=(E,(1))  OPEN THE LINE
         SPACE
         TM    DCBOFLGS,DCBOFOPN  Q-OPEN SUCCESSFUL?
         BNO   BADLINE            A.NO-BETTER STOP
         EJECT
*        BUILD IOB FOR THE LINE
         MVI   IOBFLAG1,X'C2'     CD, CC & UNRLTD IOBFLAGS ARE SET
         ST    R6,IOBDCBPT        POINT IOB TO DCB
         LA    R0,OPENLINE        GET ADDR OF INIT CCW LIST
         ST    R0,IOBSTART        STORE IN IOB
         LA    R1,ECBIO           GET ADDR OF ECB THAT IOS WILL POST
         ST    R1,IOBECBPT        STORE IN IOB
         SPACE
*        PREPARE THE TCU FOR OPERATION
         EXCP  IOB                FINISH CONDITIONING TCU
         SPACE
         WAIT  ECB=ECBIO
         SPACE
         CLI   ECBIO,NOERR        Q-END W/O ERROR?
         BNE   BADLINE            A.NO BETTER QUIT
         SPACE
         CLI   IOBCSW+3,CHANEND+DEVEND      Q-GET IT ALL DONE?
         BNE   BADLINE            A.NO-BETTER QUIT
         SPACE
         XC    ECBIO,ECBIO        CLEAR THE ECB
         SPACE
*        LOAD THE TERMINAL READ/WRITE MODULE AND CHECK ROUTINE
RTNELOAD DS    0H
         LA    R0,LTTRDRTE
         LOAD  EPLOC=(0)
         ST    R0,RDRTEENT
         SPACE
         LA    R0,LTTCHK          GET ADDR OF NAME OF CHK MODULE
         LOAD  EPLOC=(0)
         ST    R0,CHKENT
         EJECT
*
*        NOW WILL LOOP THRU THE FOLLOWING LOGIC ONCE PER TERMINAL
*
         SPACE
         L     R4,LTTFTDCB        GET FIRST TDCB POINTER
         LH    R7,LTTTCNT         GET TERMINAL COUNT
         CH    R7,=H'0'           Q-COUNT VALID ON LOW END?
         BNH   BADTCNT            A.NO-BETTER QUIT
         SPACE
         LA    R8,LTTSELID        GET FIRST TERMINAL TRAILER ADDR
         L     R9,POLSTADR        PICKUP ADDR OF POLL LIST BLD AREA
         LA    R10,1              SET LOOP 'UPWARD' COUNTER
         LA    R2,ECBWORK         GET ADDR OF ECB FOR WORK
         SPACE
         USING LTTSELID,R8
         USING POLLLIST,R9
         SPACE
OPENTERM EQU   *                  TOP OF THE TERMINAL LOOP
         ST    R2,TDCBLECB        SET WORK ECB POINTER ADDR
         MVC   TDCBMSGL,LTTMSGL
         MVC   TDCBRDWR,RDRTEENT  SET THE RD/RITE RTNE ENTRY ADDR
         MVC   TDCBCHK,CHKENT     SET CHECK RTNE ENTRY ADDR
         MVC   TDCBSLID,LTTSELID  SET BISYNC SELECT ID
         MVC   TDCBPLID,LTTPOLID  SET BISYNC POLLING ID
         MVC   TDCBTYPE,LTTTYPE   SET TERM TYPE CODE
         MVC   POLLLIST,LTTPOLID  TERM POLLID INTO POLL LIST
         MVI   POLLENQ,ENQ        'ENQ' CHAR INTO THIS POLL ENT
         STC   R10,POLLINDX       SET POLL LIST INDEX BYTE
         L     R4,TDCBFWDP        BUMP TO THE NEXT TDCB
         LA    R8,LTTEND          BUMP TERM TRAILER POINTER
         LA    R9,POLLEND         BUMP POLL LIST POINTER
         LA    R10,1(0,R10)       ADD ONE TO LOOP COUNTER
         BCT   R7,OPENTERM        NOW THE NEXT ONE
         MVI   POLLEOTS,EOT       INIT. 1ST BYTE OF 'EOT' ENTRY
         ST    R9,POLLEOTA        SAVE ADDR OF END OF POLL LIST
         SPACE
         DROP  R8,R9
         INUSE
         EJECT
*
*        INITIALIZE THE POLL CCW STRING
*
         SPACE
         MVC   CCWPOLL1(CCWPOLLN),CCWPOLL   MOVE CCW'S TO WORK AREA
         L     R0,POLLEOTA        GET ADDR OF EOT CHAR
         STCM  R0,LOW3,CCWPOLL1+1 SET DATA ADDR OF 1ST POLL CCW
         L     R0,POLSTADR        GET ADDR OF POLL LIST START
         STCM  R0,LOW3,CCWPOLL2+1 STORE IN POLL CCW
         STCM  R0,LOW3,CCWPOLL5+1 STORE IN POLL CCW
         L     R0,POLSTCNT        GET LEN OF ACTIVE POLL LIST
         STH   R0,CCWPOLL2+6      SET COUNT IN POLL CCW
         STH   R0,CCWPOLL5+6      SET COUNT IN POLL CCW
         LA    R0,CCWPOLL5        GET 2ND POLL CCW ADDR
         STCM  R0,LOW3,CCWPOLL3+1 SET TIC ADDR IN CCW
         STCM  R0,LOW3,CCWPOLL6+1 SET TIC ADDR IN CCW
         LA    R0,CCWPOLL7        GET READ CCW ADDR
         STCM  R0,LOW3,CCWPOLL4+1 ST IN TIC ADDR
         LA    R0,INDEXBYT        GET ADDR OF INDEX BYTE INPUT AREA
         STCM  R0,LOW3,CCWPOLL7+1 ST IN DATA ADDR OF READ
         L     R0,LN1BLKAD        GET ADDR FOR REST OF INPUT
         STCM  R0,LOW3,CCWPOLL8+1 ST IN DATA ADDR OF READ
         LH    R0,LTTBUFFL        GET LEN OF BUFFER
         STH   R0,CCWPOLL8+6      ST IN CNT FLD OF READ CCW
         SPACE
*        SET 'RESUME POLL' ADDRESS AND DATA COUNT
         MVC   POLLRCNT,POLSTCNT  RESUME POLL DATA CNT SAME AS INIT CNT
         L     R0,POLSTADR        RESUME POLL ADDRESS
         ST    R0,POLLRADR        SAME AS INITIAL POLL ADDRESS
         SPACE
*        BUILD THE ECB ADDRESS LIST FOR 'TWAIT'
         LA    R0,ECBIO           GET ADDR OF I/O ECB
         ST    R0,ECBIOADR        STORE IN LIST
         LA    R0,ECBWORK         GET EDITOR'S ECB ADDR
         ST    R0,ECBWRKAD        STORE IN LIST
         LA    R0,LTTLNECB        GET SUPV ECB
         ST    R0,SUPVECB         STORE IN LIST
         OI    ECBLSTEN-4,X'80'   INDICATE END OF LIST
         SPACE
*        TELL SUPERVISOR I'M ALL SET
         POST  LTTSPECB
*
*        LOCATE TDECB AND TDCB OF ANY WAITING OUTBOUND MESSAGES
*
         SPACE
CKFORWRK DS    0H                 TOP OF THE PROCESSING LOOP
CKOUTBND EQU   *
         MVI   CCWPOLL6,NOOP           SET UP FOR SINGLE POLL
         LA    R1,LTT             GET ADDR OF END OF TDCB CHAIN
         SR    R4,R4              CLEAR FOR WORK
         ICM   R4,LOW3,LTTFTDCB+1 GET ADDR OF 1ST TDCB IN CHAIN
         SPACE
TDCBSRCH EQU   *                  TOP OF TDCB CHAIN SEARCH LOOP
         CR    R1,R4              Q-AM I ALL DONE
         BE    AWAITWRK           A.YES-DIDN'T FIND ANY WAITING
         SPACE
         CLC   TDCBWECB,=XL4'00'  Q-OUTBOUND MSG WAITING
         BNE   RDORRITE           A.YES-SETUP TO PROCESS IT
         SPACE
         TM    TDCBCFLG,TDCBLOG        IS A USER LOGGED ON
         BZ    NOUSER
         MVI   CCWPOLL6,TIC            YES, CAUSE AUTOPOLL
NOUSER   EQU   *
         SPACE
         ICM   R4,LOW3,TDCBFWDP+1 PICKUP NEXT TDCB ADDR
         B     TDCBSRCH           BACK TO TOP AND CHECK THIS ONE
         SPACE
*
*        RESUME POLLING WHERE I LEFT OFF
*
         SPACE
AWAITWRK DS    0H
         CLI   CCWPOLL6,TIC            WAS A USER FOUND
         BE    DOAUTPLL                YES, AUTOPOLL
*
*    NO USERS ARE LOGGED IN ON THE LINE CONTROLLED BY THIS TASK,
*    THEREFORE A 5 SECOND WAIT WILL BE DONE BETWEEN POLLS.
*
         XC    ECBIO,ECBIO             CLEAR ECB TO BE USED
         STIMER REAL,TIMEXIT,BINTVL==F'500'  FOR DELAY
         WAIT  1,ECBLIST=WAITLIST      WAIT FOR SOME EVENT
         TTIMER CANCEL                 CANCEL THE DELAY
         TM    ECBWORK,X'40'           IS THERE OUTPUT TO WRITE
         MVI   ECBWORK,0               RESET THE ECB
         BO    CKFORWRK                YES, GO SEE WHOSE IT IS
         TM    LTTLNECB,X'40'          DOES THE SUPERVISOR WANT US
         MVI   LTTLNECB,0              RESET HIS ECB NO MATTER WHAT
         BO    SUPVCOMM                YES, GO CHECK IT OUT
         SPACE 2
DOAUTPLL EQU   *
         LA    R0,CCWPOLL1        GET POLL CCW STRING ADDR
         ST    R0,IOBSTART        STORE IN IOB
         L     R0,POLLRCNT        GET RESUME POLL DATA CNT
         STH   R0,CCWPOLL2+6      STORE IN RESUME POLL CCW CNT FLD
         L     R0,POLLRADR        GET RESUME POLL ENT ADDR
         STCM  R0,LOW3,CCWPOLL2+1 STORE IN RESUME DATA ADDR
         MVI   CCWPOLL3,TIC       ENSURE TIC IS 3RD CCW
         XC    INDEXBYT,INDEXBYT  CLEAR INPUT AREA
         SPACE
         EXCP  IOB                RESUME POLLING
         EJECT
*        GOT NOTHING LEFT TO DO SO WAIT AWHILE
MAINWAIT EQU   *
         TWAIT (R2),ECBLIST=WAITLIST        WAIT FOR SOMETHING TO HPN
         SPACE
         MVC   ECBHOLD,0(R2)      SAVE ECB FIELD CONTENTS
         XC    0(4,R2),0(R2)      CLR IT SO I DON'T PROCESS IT AGN
         B     WORKTBLE(R15)      FIND PROCESSING RTNE ENTRY ADDR
         SPACE
WORKTBLE DS    0H                 ENTRIES IN SAME SEQ AS TWAIT ECB LIST
         B     POLLRESP           PROCESS RESPONSE TO POLLING
         B     STOPPOLL           REQUEST IS FOR AN OUTBND MSG
         B     SUPVCOMM           PROCESS SUPV. TASK COMMUNICATIONS
         SPACE
SUPVCOMM EQU   *
         B     CKFORWRK           DONE - LOOK FOR MORE WORK
         TITLE 'O U T B O U N D    M E S S A G E    P R O C E S S I N GX
               '
*
*        HAVE DISCOVERED AN OUTBOUND MESSAGE TO BE SENT
*
         SPACE
*        INITIALIZE WORK FIELDS
RDORRITE DS    0H                 FORCE HALFWORD ALIGNMENT
         L     R5,TDCBWECB        GET ADDR OF OUTBND MSG TDECB
         XC    TDCBWECB,TDCBWECB  DON'T PROCESS THIS MSG AGN
RPTMSG   EQU   *
         XC    FRSTMESW,FRSTMESW  ÖESET 1ST BLK OF MSG SWITCH
         MVI   CURRACK+1,ACK0     SETUP ACK FLIP-FLOP
         SPACE
         MVC   CCWBUILD(SLCTCCWL),SLCTCCW   SETUP TER. 'SELECT' CCW'S
         LA    R0,TDCBSLID        GET ADDR OF TERM SELECT ID
         STCM  R0,LOW3,CCW2+1     STORE IN WRITE CCW
         LA    R0,INDEXBYT        GET ADDR OF RESPONSE INPUT AREA
         STCM  R0,LOW3,CCW4+1     STORE IN READ CCW
         LA    R0,CCWBUILD        GET ADDR OF START OF CCW STRING
         ST    R0,IOBSTART        SAVE IN IOB FOR EXCP
         SPACE
*        WRITE SELECT SEQUENCE TO TERMINAL
SELECT   EQU   *
         EXCP  IOB
         SPACE
         WAIT  ECB=ECBIO
         MVC   ECBHOLD,ECBIO      SAVE THE ECB
         XC    ECBIO,ECBIO        RESET ECB TO ZERO
         CLI   ECBHOLD,NOERR      Q-SELECT GO OK?
         BNE   BADSELCT           A.NO-BETTER CALL IT QUITS
         SPACE
         CLC   CURRACK,INDEXBYT   Q-GET BACK AN ACK0 RESPONSE?
         BNE   DONTSEND           A.NO-BETTER NOT TRANSMIT
         SPACE
*        OK TO SEND - FINISH SETTING UP TO TRANSMIT
         MVI   CURRACK+1,ACK1     ALTERNATE ACK CKER
         L     R7,TDECBBFR        GET ADDR OF STRT OF OUTPUT MSG(BXLE)
         LH    R8,TDCBMSGL        GET BLK TO SEND(MINUS STX,ETX,ETC)
         LH    R9,0(R7)           GET TOTAL LEN TO SEND(BXLE REG)
         AR    R9,R7              FIND LAST BYTE + 1
         BCTR  R9,0               MINUS 1 FOR BXLE USE
         LA    R7,4(R7)           MSG STARTS PAST RDW
         SPACE
*        BXLE REGS SETUP, NOW BUILD CCW'S, ETC
         MVC   CCWBUILD(WR1STLN),WR1STCCW   SETUP RITE 1ST BLK CCW'S
         LA    R0,OPCDE           GET ADDR OF 3270 OP CMD CDE
         STCM  R0,LOW3,CCW2+1
         LA    R0,INDEXBYT        GET ADDR OF RESPONSE AREA
         STCM  R0,LOW3,CCW5+1     STORE IN RD CCW
         STCM  R7,LOW3,CCW3+1     STORE ADDR OF TEXT START IN CCW
         MVC   OPCDE,TDECBTYP     MOVE USER DECB TYPE CDE TO WRK FIELD
         MVC   OPCDE+1(1),0(R7)   SAVE WCC FOR REUSE IF MULT. BLK MSG
         TR    OPCDE,OPCDTBL      TRANSLATE TO 3270 OPCDE
         STH   R8,CCW3+6          SET CCW CNT FIELD
         BXLE  R7,R8,MULTIPLE     IF MORE THAN 1 BLK CAN SKIP FOLLOWING
         SPACE
*        MUST TAKE SPECIAL ACTION WHEN SENDING LAST MESSAGE BLOCK
SENDETX  EQU   *                  DETERMINED THAT THIS IS THE LAST BLK
         LA    R0,ETXDATA         GET ADDR OF ETX END CHAR
         STCM  R0,LOW3,CCW4+1     SEND ETX AS LAST CHAR
         SR    R7,R9              MUST RECOMPUTE CCW CNT SINCE LAST MSG
         BCTR  R7,0
         SR    R8,R7
         STH   R8,CCW3+6          UPDATE CCW CNT FIELD
         MVI   FRSTMESW,ETX       INDICATE ETX HAS BEEN SENT
         SPACE
*        1ST MSG BLK ALL SET TO GO - NOW SEND IT
MULTIPLE EQU   *
         EXCP  IOB
         SPACE
         WAIT  ECB=ECBIO
         SPACE
         MVC   ECBHOLD,ECBIO      SAVE ECB CONTENTS
         XC    ECBIO,ECBIO        CLEAR THE ECB USED
         CLI   ECBHOLD,NOERR      Q-MSG BLK SENT OK?
         BNE   BADMSG             A.NO-BETTER CALL IT QUITS
         EJECT
         CLC   CURRACK,INDEXBYT   Q-ANY UNUSUAL CONDITIONS?
         BNE   BADRCVE            A.YES-BETTER HANDLE THEM
         SPACE
*        FIND OUT IF THAT WAS THE LAST BLOCK
         CLI   FRSTMESW,ETX       Q-WAS THAT THE LAST BLK OF MSG?
         BE    POSTRITE           A.YES-TELL USER I SENT IT OK
         SPACE
         CLI   FRSTMESW,X'00'     QWAS THAT THE 1ST MSG SENT?
         BNE   UPDTECCW           A.NO-DON'T ALTER CCW STRING SEQUENCE
         SPACE
         MVI   FRSTMESW,ETB       INDICATE FIRST MSG BLK HAS BEEN SENT
         MVI   OPCDE,X'F1'        FORCE 'WRITES' ON SUBSEQUENT BLKS
         MVI   CCW2+7,X'02'       SET CNT TO INCLUDE SAVED WCC
         SPACE
*        UPDATE CCW CNT AND ADDR FLDS FOR NEXT MSG BLK
UPDTECCW EQU   *
         STCM  R7,LOW3,CCW3+1     NEXT TEXT STARTS HERE
         TR    CURRACK+1(1),MSCTRTBL        ALTERNATE ACK CKER
         BXLE  R7,R8,MULTIPLE     IF NOT THE LAST BLK THEN OK TO SEND
         B     SENDETX            SETUP TO SEND LAST BLK
POSTRITE EQU   *
         POST  TDECB
         B    CKFORWRK
         EJECT
BADRCVE  EQU   *                  DIDN'T GET BK THE ACK,SEE IF RVI, ETC
BADSELCT EQU   *                  I/O ERR DURING 'SELECT' SEQUENCE
DONTSEND EQU   *                  RECEIVED A 'WACK' RESPONSE
BADMSG   EQU   *                  RECEIVED A 'NAK' RESPONSE
BADEND   EQU   *                  LAST BLK NOT SENT OK
         TM    IOBCSW+3,UNITEXC   Q-GET AN UNEXPECTED EOT?
         BO    SAVEMSG            A.YES-TRY TO SEND IT AGN LATER
         TM    IOBSENS0,TIMEOUT+INTVREQD    Q-GOT A MODEM PROBLEM?
         BM    SAVEMSG            A.YES-TRY TO SEND IT AGN LATER
         WTO   'OUTBOUND TRANSMISSION TERMINATED WITH ERRORS'
SAVEMSG  EQU   *
         ST    R5,TDCBWECB        SAVE THE TDECB ADDR FOR NEXT TIME
         B     AWAITWRK           RESUME POLLING-DON'T TRY TO SEND AGN
         TITLE 'S T O P    L I N E    P O L L I N G'
*        THE FOLLOWING ROUTINE MODIFIES THE POLLING CCW STRING BEING
*        EXECUTED THEREBY TERMINATING AUTO POLL.
*
         SPACE
*        MUST DETERMINE IF ENVIRONMENT IS OS OR OS/VS
STOPPOLL DS    0H
         TM    33,X'08'           Q-SVC OLD PSW HAVE EC BIT ON?
         BO    ASSUMEVS           A.YES-ASSUME OS/VS ENVIRONMENT
         SPACE
*        CHANGE TIC'S TO IO NO-OP'S UNDER OS
         MVI   CCWPOLL3,NOOP      CHANGE 1ST TIC TO AN I/O NO-OP
         MVI   CCWPOLL6,NOOP      CHANGE 2ND TIC TO AN I/O NO-OP
         B     PPOLLXIT           ALL DONE-EXIT
         SPACE
*        UNDER VS MUST GET TO TRANSLATED CCW STRING AND CHANGE TIC'S
ASSUMEVS EQU   *
         L     R2,DCBDEBAD        GET THE LINE DEB ADDRESS
         L     R2,32(R2)          DEB + 32 --> LINE UCB
         LA    R2,0(R2)           CLEAR HI BYTE
         O     R2,BIT8ON          TURN ON 8TH BIT FOR IOHALT SVC FLAG
         SPACE
         LA    R0,CCWPOLL3-IOB    GET DISPL. OF TIC CCW FRM IOB STRT
         LR    R1,R2              GET UCB ADDR (8TH BIT MUST BE ON)
         SVC   33                 I/O HALT SVC WILL CHNG TIC TO NO-OP
         SPACE
         LA    R0,CCWPOLL6-IOB    GET DISPL OF NEXT TIC CCW TO CHNG
         LR    R1,R2              GET UCB ADDR (8TH BIT MUST BE ON)
         SVC   33                 I/O HALT SVC WILL CHNG TIC TO NO-OP
         SPACE
PPOLLXIT EQU   *                  COMMON EXIT POINT FOR 'STOPPOLL' ENT.
         B     MAINWAIT           WAIT TILL POLLING TERMINATES
         TITLE 'P O L L I N G    R E S P O N S E    P R O C E S S I N GX
               '
*        ON END OF SUCCESSFUL POLL, THE FIRST BYTE READ IN FROM THE TCU
*        IS THE LAST BYTE IT COPIED FROM THE POLL LIST
         SPACE
         INUSE
POLLRESP DS    0H
         CLI   ECBHOLD,NOERR      Q-EVERYTHING GO OK?
         BNE   LINERR
         SPACE
         CLI   INDEXBYT,X'00'     Q-INPUT AREA HAVE DATA?
         BE    CKFORWRK           A.NO-MUST HAVE OUTBND MSGS WAITING
         SPACE
*        FIND THE ENTRY IN THE POLL LIST FOR THE CTL UNIT THAT RESPONDS
         SR    R1,R1              CLEAR FOR WORK
         IC    R1,INDEXBYT        PICKUP 1ST INPUT BYTE=POLL LST INDEX
         BCTR  R1,0               MINUS 1 FOR REL LIST ENTRY NBR
         MH    R1,=Y(POLLENTL)    TIMES LEN 1 ENT = LIST DISPL
         A     R1,POLSTADR        PLUS LIST START ADR = ENTRY ADDR
         ST    R1,POLLIDAD        SAVE FOR LATER USE
         SPACE
*        NOW COMPUTE 'RESUME POLL' DATA SO I PICKUP WHERE I LEFT OFF
         LA    R1,POLLENTL(R1)    CURR ENT + LEN 1 ENT = RESUME ENT ADR
         ST    R1,POLLRADR        SAVE FOR RESUME POLL USE
         S     R1,POLSTADR        MINUS STRT ADDR = DISPL FROM START
         S     R1,POLSTCNT        MINUS TOT. LEN = REMAINING LEN
         ST    R1,POLLRCNT        SAVE FOR RESUME POLL USE
         CH    R1,=Y(POLLENTL)    Q-GOT AT LEAST 1 ENT LEFT IN LIST?
         BH    RSMEXIT            A.YES-RESUME POLL DATA IS OK AS IS
         SPACE
         MVC   POLLRADR,POLSTADR  RESET RESUME POLL ADDR TO TOP OF LIST
         MVC   POLLRCNT,POLSTCNT  RESET RSME POLL CNT TO FULL LIST CNT
RSMEXIT  EQU   *
         EJECT
*        INITIALIZE WORK FIELDS AND WORK REGISTERS TO PROCESS INPUT MSG
         MVI   CURRACK+1,ACK1     FIRST ACK I RTRN IS ACK 1
INPUTMSG EQU   *
         XC    LENCNT,LENCNT      RESET INPUT DATA LEN ACCUMULATOR
         MVC   CUCUDVDV(1),INDEXBYT+2       CONSTRUCT 1ST DIGIT OF POLL
         MVC   CUCUDVDV+1(1),INDEXBYT+2     CONSTRUCT 2ND DIGIT OF POLL
         MVC   CUCUDVDV+2(1),INDEXBYT+3     CONSTRUCT 3RD DIGIT OF POLL
         MVC   CUCUDVDV+3(1),INDEXBYT+3     CONSTRUCT 4TH DIGIT OF POLL
         SR    R1,R1              CLEAR FOR WORK
         ICM   R1,LOW3,IOBCSW     PICKUP ADDR OF LAST CCW EXECUTED
         LA    R0,CCWPOLL8+8      GET ADDR OF END OF POLL CCW STRING
         CR    R0,R1              Q-DID I END AT THE LAST ONE?
         BNE   ERLYEND            A.NO-BETTER FIND OUT WHY NOT
         SPACE
         CLI   INDEXBYT+1,SOH     Q-THIS A HEADER MSG?
         BE    HDRMSG             A.YES-GO PROCESS IT
         EJECT
         CLI   ECBHOLD,NOERR      Q-IOS POST ANY ERRORS?
         BNE   TMEOUTCK           A.YES-GO PROCESS ABNORMAL CONDITIONS
         SPACE
*        VALID RESPONSE SO FAR - MUST NOW MATCH IT TO A TDCB
         LA    R14,LTT            PICKUP ADDR OF END OF TDCB CHAIN
         SR    R4,R4              CLEAR FOR WORK
         ICM   R4,LOW3,LTTFTDCB+1 PICKUP 1ST TDCB TO CHECK
         SPACE
TDCBLOOK EQU   *                  TOP OF TDCB SEARCH LOOP
         CR    R4,R14             Q-WAS THAT THE LAST TDCB TO CK?
         BE    NOSUCHID           A.YES-DIDN'T GET A TDCB HIT
         SPACE
         CLC   TDCBPLID,CUCUDVDV  Q-TDCBPOLL ID SAME AS INPUT TERM ID
         BE    CKMORE             A.YES-FOUND THE TDCB I WANT
         SPACE
         ICM   R4,LOW3,TDCBFWDP+1 PICKUP ADDR OF NEXT TDCB IN CHAIN
         B     TDCBLOOK           TAKE A LOOK AT IT
         SPACE
CKMORE   EQU   *
         MVC   TDCBAID,INDEXBYT+4      SAVE LAST AID ENTERED
*        IF CLEAR KEY WAS HIT - THEN NOTIFY SUPERVISOR
         CLI   INDEXBYT+4,X'6D'        Q-WAS 3270 CLEAR KEY HIT?
         BNE   NOTCLRKY                A.NO-EXIT THIS ROUTINE
         SPACE
         OI    TDCBCFLG,TDCBNTR        INDICATE NEW TASK REQUIRED
         ICM   R5,15,TDCBPECB          IS THIS TASK EXPECTING INPUT
         BZ    POSTSUPV                NO, JUST SUSPEND HIM
         XC    TDCBPECB,TDCBPECB       REMOVE ECB POINTER
         L     R1,TDECBBFR             PICK UP BUFFER POINTER
         MVC   0(5,R1),=X'000500006D'  SIMULATE CLEAR KEY INPUT
POSTSUPV POST  LTTSPECB                NOTIFY SUPERVISOR OF NEW TASK
         LTR   R5,R5                   WAS THERE INPUT PENDING
         BZ    UNSOLICI                NO, CONTINUE
         POST  TDECB                   YES, MAKE HIM START LATER
         B     UNSOLICI                THIS MSG DONE - SETUP FOR NEXT
         SPACE
NOTCLRKY EQU   *
         CLC   TDCBWECB,=XL4'00'  Q-OUT BND MSG WAITING FOR THIS TERM.?
         BNE   OUTBNDWT           A.YES-TREAT AS UNWANTED INPUT
         SPACE
         CLC   TDCBPECB,=XL4'00'  Q-OK TO ACCEPT INPUT FRM THIS TERM?
         BE    UNSOLICI           A.NO-PROCESS UNWANTED INPUT
         EJECT
*        LOCATE RELATED TDECB & COMPUTE INPUT MSG LEN
         L     R5,TDCBPECB        SETUP TDECB POINTER REG
         XC    TDCBPECB,TDCBPECB  ONLY 1 INPUT MSG PER TDECB ALLOWED
         SPACE
         SR    R1,R1              CLEAR FOR WORK
         ICM   R1,LOW3,IOBCSW     PICKUP ADDR OF LAST CCW EXECUTED
         SH    R1,=H'8'           BACKUP TO START OF LAST CCW
         LH    R0,6(R1)           PICKUP FULL LEN FROM LAST CCW
         SR    R14,R14            CLEAR FOR WORK
         ICM   R14,B'0011',IOBCSW+5 PICKUP CSW RESIDUAL BYTE COUNT
         SR    R0,R14             FULL LEN MINUS RESIDUAL = LEN READ
         SH    R0,=H'2'           MINUS LEN OF INDEX,STX,C0,&5V
         ST    R0,LENCNT          STORE UPDATED ACCUMULATOR VALUE
         SPACE
*        VERIFY USER BUFFER IS BIG ENOUGH, THEN MOVE 1ST BLK INTO IT
         LH    R7,TDECBLEN        PICKUP LEN OF USER BUFFER
         C     R7,LENCNT          Q-GOT ENOUGH ROOM FOR 1ST BLK?
         BNH   SHORTBUF           A.NO-BETTER STOP HERE
         SPACE
         S     R7,LENCNT          DECREMENT BFR LN TO REFLECT REMAINDER
         L     R8,TDECBBFR        PICKUP ADDR OF BUFFER START
         XC    0(4,R8),0(R8)      CLEAR MSG RDW
         LA    R0,4(0,R8)         PICKUP ADDR OF MSG START
         L     R1,LENCNT          PICKUP LEN OF BLK TO MOVE
         LA    R8,4(R1,R8)        GET ADDR OF CURR MSG END
         BCTR  R8,0               BACKUP TO ETX/ETB-WILL OVERLAY IT
         LR    R15,R1             IN THIS REG ALSO FOR MVE LONG
         LA    R14,INDEXBYT+4     PICKUP START POINT OF DATA TO MOVE
         MVCL  R0,R14             MOVE 1ST INPUT BLK TO USER BUFFER
         EJECT
*        SETUP TO ISSUE REPETIVE READS TILL ALL INPUT EXHAUSTED
RDMORE   EQU   *
         CLI   ECBHOLD,NOERR      Q-DID IOS POST ANY ERRORS?
         BNE   TMOUTCK2           A.YES-BETTER CHECK ON THEM
         SPACE
*        BUILD 'READ CONTINE' CCW'S
         LA    R0,CCWBUILD        GET ADDR OF CCW'S THAT WILL EXECUTE
         ST    R0,IOBSTART        STORE IN IOB
         MVC   CCWBUILD(RDCONTLN),RDCNTCCW  MVE BASE CCW'S TO WRK AREA
         LA    R0,CURRACK         1ST WRITE AN ACK RESPONSE
         STCM  R0,LOW3,CCW1+1     POINT 1ST CCW TO IT
         CLI   0(R8),ETX          Q-THAT THE LAST BLK OF CURR MSG?
         BE    RCVDETX            A.YES-SETUP FOR NEXT MSG OR EOT
         SPACE
         LA    R0,INDEXBYT+1      PICKUP 'STX' INPUT AREA
         STCM  R0,LOW3,CCW2+1     ST IN AREA ADDR OF 2ND CCW
         STCM  R8,LOW3,CCW3+1     SET BFR ADDR IN 3RD CCW
         STH   R7,CCW3+6          SET 3RD CCW DATA LEN
         SPACE
         EXCP  IOB                READ NEXT BLOCK
         SPACE
         WAIT  ECB=ECBIO          GOT NOTHING ELSE TO DO
         MVC   ECBHOLD,ECBIO      SAVE THE ECB
         XC    ECBIO,ECBIO        CLEAR FOR REUSE
         SPACE
         SPACE
*        COMPUTE LEN READ, THEN UPDATE BFR PTR & BFR LEN REGS
         SR    R1,R1              CLEAR FOR WORK
         ICM   R1,LOW3,IOBCSW     PICKUP ADDR OF LAST CCW EXECUTED
         SH    R1,=H'8'           BACKUP TO START OF LAST CCW EXEC'ED
         LA    R0,CCW3            PICKUP ADDR OF LAST CCW I EXPECTED
         CR    R0,R1              Q-DID I END WHERE I THOUGHT?
         BNE   ERLYEND2           A.NO-BETTER GET OUT NOW
         SPACE
         LH    R0,6(R1)           PICKUP MAX LEN TO HAVE READ
         SR    R14,R14            CLEAR FOR WORK
         ICM   R14,B'0011',IOBCSW+5         PICKUP RESIDUAL CSW COUNT
         SR    R0,R14             FULL LEN MINUS RESIDUAL = LEN RCVD
         BCTR  R0,0               MINUS 1 FOR LEN OF ETX/ETB
         AR    R8,R0              BUMP BFR PTR TO NXT INPUT AREA
         SR    R7,R0              DECREMENT BFR LEN AVAILABLE
         A     R0,LENCNT          PLUS OLD LEN ACCUMULATOR VALUE
         ST    R0,LENCNT          EQUAL UPDATE ACCUMULATOR
         TR    CURRACK+1(1),MSCTRTBL        ALTERNATE ACK'S
         B     RDMORE             NOW READ NEXT BLOCK
         EJECT
*        DETECTED END OF CURRENT MESSAGE - SET UP RECEIVE NEXT MSG
RCVDETX  DS    0H                 ALL INPUT EXHAUSTED FROM CURR TERM
         L     R8,TDECBBFR        PICKUP START OF USER'S BUFFER
         L     R1,LENCNT          GET THE LEN OF DATA RCVD
         LA    R1,4(R1)           ADD IN LEN OF RDW PREFIX
         BCTR  R1,0               DON'T COUNT ETX IN RDW
         STCM  R1,B'0011',0(R8)   SET MSG RDW
         SPACE
NXTMSG   EQU   *
         LA    R0,INDEXBYT+1      PICKUP ADDR OF MY INPUT AREA
         STCM  R0,LOW3,CCW2+1     SET AREA ADDR OF 2ND CCW
         MVI   CCW2+4,SLI         RESET FLAGS TO SLI ONLY - NO CC/CD
         MVC   CCW2+6(2),LTTBUFFL SET CCW INPUT LEN ARGUMENT
         SPACE
         EXCP  IOB                READ NEXT MSG OR EOT
         SPACE
         POST  TDECB              POST USER OF LAST INPUT MSG
         SPACE
         WAIT  ECB=ECBIO          NOTHING ELSE TO DO
         SPACE
         MVC   ECBHOLD,ECBIO      SAVE POSTED ECB CONTENTS
         XC    ECBIO,ECBIO        CLEAR FOR REUSE
         CLI   ECBHOLD,NOERR      Q-GOT ANOTHER MSG TO PROCESS?
         BE    INPUTMSG           A.YES-GO HANDLE IT
         TM    IOBCSW+3,UNITEXC   Q-GET AN EOT THAT TIME?
         BO    CKFORWRK           A.YES-ALL DONE WITH THIS CU
         CLI   INDEXBYT+1,EOT     Q-WAS THAT THE END?
         BNE   INPUTMSG           A.NO-HE'S GOT ANOTHER ONE TO PROCESS
         B     CKFORWRK           ALL INPUT EXHAUSTED-LOOK FOR OUTBOUND
         EJECT
SHORTBUF EQU   *                  USER BUFFER WAS TOO SHORT
TMOUTCK2 EQU   *
ERLYEND2 EQU   *
         ST    R5,TDCBPECB        REQUE THE READ REQUEST
LINERR   DS    0H
ERLYEND  EQU   *                  DIDN'T END POLL ON LAST CCW IN STRING
         SR    R1,R1              CLEAR FOR WORK
         ICM   R1,LOW3,IOBCSW     GET ADDR OF LAST CCW EXECUTED
         LA    R0,CCWPOLL3        GET ADDR OF TIC/NO-OP CCW
         CR    R0,R1              Q-THIS THE CCW I STOPPED ON?
         BE    CKFORWRK           A.YES-MUST HAVE AN OUTBND MSG WAITING
         SPACE
         LA    R0,CCWPOLL6        GET ADDR OF TIC/NO-OP
         CR    R0,R1              Q-THIS THE CCW I STOPPED ON?
         BE    CKFORWRK           A.YES-MUST HAVE AN OUTBND MSG WAITING
         SPACE
NOSUCHID EQU   *                  DIDN'T FIND RELATED TDCB IN CHAIN
TMEOUTCK EQU   *                  KNOWN TIMEOUTS COME HERE
         TM    IOBSENS0,TIMEOUT   Q-WAS THE PROBLEM A TIMEOUT?
         BO    CKFORWRK           A.YES-RESUME PROCESSING
*        WE'RE GOING TO TERMINATE ANY FURTHER INPUT
         WTO   'INPUT TRANSMISSION TERMINATED WITH ERRORS'
HDRMSG   EQU   *                  INPUT MSG STARTS WITH 'SOH'
OUTBNDWT EQU   *                  TERM HAS AN OUTBND MSG WAITING
UNSOLICI EQU   *                  NO WANTS THIS TERM'S INPUT
         XC    INDEXBYT,INDEXBYT  CLEAT THE INPUT AREA
         MVC   IOBHOLD,IOB        SAVE THE ERR IOB IN CASE I DUMP
         MVC   CCWBUILD(RVICCWLN),RVICCW    BASIC RVI CCW STRING
         LA    R0,INDEXBYT        RESPONSE (EOT) GOES HERE
         STCM  R0,LOW3,CCW2+1     SET CCW AREA ADDRESS
         LA    R0,CCWBUILD        GET CCW START ADDRESS
         ST    R0,IOBSTART        POST CCW START IN IOB
         EXCP  IOB                WRITE RVI, READ EOT
         SPACE
         WAIT  ECB=ECBIO          WAIT IT FINISHES
         MVC   ECBHOLD,ECBIO      SAVE THE POSTED ECB
         XC    ECBIO,ECBIO        DON'T ALLOW FALSE POST
         CLI   ECBHOLD,NOERR      Q-DID IT ALL GO OK?
         BE    CKFORWRK           A.YES-INPUT PROCESSING DONE FOR NOW
         SPACE
         CLI   INDEXBYT,EOT       Q-DID I GET BACK THE RIGHT ANSWER?
         BE    CKFORWRK           A.YES-OK TO CONTINUE
         B     CKFORWRK
         SIO   0(0)               FORCE ABEND
         EJECT
         DROP
***********************************************************************
*        TIMER EXIT FOR DELAYED POLLING WHEN ALL LOGGED OFF.          *
*                                                                     *
*              THIS EXIT WILL CHAIN THROUGH ALL THE CONTROL           *
*              BLOCKS NECESSARY TO FIND THE ECB THAT IS WAITED        *
*              ON FOR INTERVAL COMPLETION, AND POSTS IT.              *
***********************************************************************
TIMEXIT  STM   R14,R2,12(R13)          SAVE SUPV REGS
         L     R2,16                   POINT AT CVT
         L     R2,0(,R2)               NEW/OLD
         L     R2,4(,R2)               OUR TCB
         L     R2,X'70'(,R2)           FSA
         L     R2,8(,R2)               LINEWORK
         POST  ECBIO-LINEWORK(,R2)     NOTE EVENT COMPLETE
         LM    R14,R2,12(R13)          RESTORE REGISTERS
         BR    R14                     EXIT
         TITLE 'E Q U A T E S'
         TPIOEQU
         TITLE 'R E A D    O N L Y    C O N S T A N T S'
*
*        SETMODE & ENABLE CCW STRING - CONDITION THE LINE
*
OPENLINE CCW   DISABLE,0,CC+SLI,1 RESET THE LINE
         CCW   SETMODE,CTLBYTE,CC+SLI,L'CTLBYTE  ENTER MODE BYTE
         CCW   ENABLE,0,SLI,1     RESTART LINE
CTLBYTE  DC    X'0'               SET INFORMATION BYTE - NO EIB
         SPACE
*
*        POLLING CCW STRING - SETUP LIKE BTAM'S
*
CCWPOLL  CCW   POLL,EOTDATA,CC+SLI,L'EOTDATA WRITE EOT
         CCW   POLL,0,CC+SLI,0    FIRST POLL
         CCW   TIC,0,SLI,1        POLL OK - XFER TO POLL AGN AT #5
         CCW   TIC,0,SLI,1        GOT A RESP.-GO READ IT AT #7
         CCW   POLL,0,CC+SLI,0    2ND AND SUBSEQUENT POLLS
         CCW   TIC,0,SLI,1        LOOP ON POLL TILL GET RESPONSE
         CCW   READ,0,CD+SLI,2    READ INDEX BYTE
         CCW   READ,0,SLI,0       READ THE REST OF THE RESPONSE
CCWPOLLN EQU   *-CCWPOLL          LEN OF THE CCW'S USED IN POLLING
EOTDATA  DC    YL1(EOT)           EOT CHAR WRITTEN BY POLL
         SPACE
         SPACE
*
*        READ 2ND AND HIGHER MSG BLKS RECEIVED FROM POLLING RESPONSE
*
RDCNTCCW CCW   WRITE,0,CC+SLI,2   WRITE PROPER ACK RESPONSE
         CCW   READ,0,CD+SLI,1    READ THE 'STX' INTO DIFFERENT AREA
         CCW   READ,0,SLI,0       READ REST OF DATA INTO USER BUFFER
RDCONTLN EQU   *-RDCNTCCW         LEN OF THIS CCW STRING
         SPACE
*
*        RVI SEQUENCE TO RESET 3270 STATUS AND CLEAR SENSE
*
RVICCW   CCW   WRITE,RVIDATA,CC+SLI,2 WRITE 2 BYTE RVI SEQUENCE
         CCW   READ,0,SLI,1       READ AN EOT IN RESPONSE
RVICCWLN EQU   *-RVICCW           LEN OF RVI CCW STRING
RVIDATA  DC    YL1(DLE,RVI)       RVI DATA SEQUENCE - DLE,RVI
*
*        'SELECT' TERMINAL CCW STRING
*
SLCTCCW  DS    0D
         CCW   WRITE,EOTDATA,CC+SLI,1       1ST SET LINE IN CTL MODE
         CCW   WRITE,0,CD+SLI,L'POLLLIST    SEND SELECTION SEQUENCE
         CCW   WRITE,ENQDATA,CC+SLI,L'ENQDATA    END WITH ENQ
         CCW   READ,0,SLI,2       READ SELECT RESPONSE
SLCTCCWL EQU   *-SLCTCCW
ENQDATA  DC    YL1(ENQ)
               SPACE
*
*        WRITE WRITE SUCCESSIVE MESSAGE BLOCKS
*
WR1STCCW DS    0D
         CCW   WRITE,STXESC,CD+SLI,2        1ST FRAOMING CHAR-STX,ESC
         CCW   WRITE,0,CD+SLI,1   WRITE TYPE CMD CDE
         CCW   WRITE,0,CD+SLI,0   ACTUAL TEXT MSG BLK
         CCW   WRITE,ETBDATA,CC+SLI,L'ETBDATA    END FRAMING CHAR
         CCW   READ,0,SLI,2       READ BACK THE RESPONSE
WR1STLN  EQU   *-WR1STCCW
ETBDATA  DC    YL1(ETB)
ETXDATA  DC    YL1(ETX)
STXESC   DC    YL1(STX,ESC)
         SPACE
LNEDCB   DCB   MACRF=(E)
         EJECT
*
*        PROBLEMS COME HERE
BADLINE  EQU   *
BADTCNT  EQU   *
         SIO   0(0)
         TITLE 'D S E C T S'
         LTT
         EJECT
         TDCB
         EJECT
         TDECB
         EJECT
LINEWORK DSECT
SAVEAREA DC    18F'0'             LINE I/O SAVE AREA
ECBIO    DC    F'0'               POSTED BY IOS WHEN I/O FINISHED
ECBWORK  DC    F'0'               POSTED BY TP TERM EDITOR TASK
RDRTEENT DC    F'0'               ADDR OF ASSOC RD/RITE RTNE
CHKENT   DC    F'0'               ADDR OF ASSOC. CHK RTNE
LN1BLKAD DC    F'0'               ADDR OF 1ST INPUT BLK BUFFER AREA
POLLTBLN DC    F'0'               LEN OF ENTIRE POLL LIST-ACT+DEACT
POLSTCNT DC    F'0'               ACTIVE POLL LIST LEN
POLSTADR DC    F'0'               ADDR OF START OF ACTIVE POLL LIST
POLLRADR DC    F'0'               ADDR OF ENT TO RESUME POLLING AT
POLLRCNT DC    F'0'               CNT OF DATA REMAINING AT RADR
POLLEOTA DC    F'0'               ADDR OF EOT CHAR AT END OF POLL LIST
POLLIDAD DC    F'0'               ADDR OF POLL LIST ENT THAT RESPONDED
CURRACK  DC    X'0000'            ACK FLIP FLOP HOLD AREA
OPCDE    DS    X'00',X'00'        TRNSLTD 'TYPE' CDE FRM TDECB-SVED WCC
FRSTMESW DC    X'00'              SWITCH (I KNOW YOU SHOULDN'T USE IT)
LENCNT   DC    F'0'               INCOMING DATA LEN ACCUMULATOR
CUCUDVDV DC    XL4'00'            RESPONDING TERMID EXPANDED LIKE POLL
WAITLIST DS    0F                 ENTRIES IN SAME SEQ AS WORKTBLE BRNCH
ECBIOADR DC    F'0'               ADDR OF IOS ECB
ECBWRKAD DC    F'0'               ADDR OF WORK ECB
SUPVECB  DC    F'0'               ADDR OF ECB POSTED BY TASK SUPV
ECBLSTEN EQU   *                  END OF ADDR LIST OF ECB'S
         DC    10F'0'             FILLER
ECBHOLD  DC    F'0'               CONTENTS OF POSTED ECB HELD HERE
IOB      DS    0F
IOBFLAG1 DC    X'0'               FIRST FLAG BYTE
IOBFLAG2 DC    X'0'               SECOND FLAG BYTE
IOBSENS0 DC    X'0'
IOBSENS1 DC    X'0'
IOBECBCC DC    X'0'               COMPLETION CODE FOR THE I/O
         ORG   *-1
IOBECBPT DC    A(0)               EVENT CONTROL BLOCK ADDRESS
IOBFLAG3 DC    X'0'               I/O ERR PROCESSING FLAGS
IOBCSW   DC    XL7'0'             LOW ORDER 7 BYTES OF LAST CSW
IOBSIOCC DC    X'0'               SIO CONDITION CODE
         ORG   *-1
IOBSTART DC    A(0)               ADDRESS OF START OF CCW'S TO EXEC.
         DC                       X'0'      RESERVED
         ORG   *-1
IOBDCBPT DC    A(0)               ADDRESS OF DCB
IOBRESTR DC    A(0)               ADDR OF NXT IOB IN PURGE CHN
IOBINCAM DC    XL2'0'             NOT USED
IOBERRCT DC    XL2'0'             NOT USED
IOBDAM   DC    D'0'               EXTENT NUMBER
IOBLEN   EQU   *-IOB              LEN OF THE IOB
IOBHOLD  DC    XL(IOBLEN)'00'     QUESTIONABLE IOB'S STORED HERE
CCWBUILD DC    10D'0'             CCW STRING BUILD AREA
         ORG   CCWBUILD           REDEFINE BUILD AREA
CCW1     DC    D'0'
CCW2     DC    D'0'
CCW3     DC    D'0'
CCW4     DC    D'0'
CCW5     DC    D'0'
CCW6     DC    D'0'
CCW7     DC    D'0'
CCW8     DC    D'0'
CCW9     DC    D'0'
CCW10    DC    D'0'
CCWPOLL1 CCW   0,0,0,0            START OF POLLING CCW'S GOES HERE
CCWPOLL2 CCW   0,0,0,0
CCWPOLL3 CCW   0,0,0,0
CCWPOLL4 CCW   0,0,0,0
CCWPOLL5 CCW   0,0,0,0
CCWPOLL6 CCW   0,0,0,0
CCWPOLL7 CCW   0,0,0,0
CCWPOLL8 CCW   0,0,0,0            END OF POLLING CCW'S
OPENLIST OPEN  (LINEDCB),MF=L
LINEDCB  DCB   MACRF=(E)          DCB HOLD AREA
INDEXBYT DC    XL2'0'             INDEX BYTE FROM POLLING RD IN HERE
*
*        THE FOLLOWING AREAS ARE DYNAMICALLY ALLOCATED DURING TASK
*        INITIALIZATION AS FOLLOWS
*              1 - FIRST IS A BUFFER AREA TO HOLD THE INITIAL BLOCK
*                RECEIVED IN RESPONSE TO POLLING.  ITS SIZE IS IN LTT
*              2 - SECOND IS THE POLL LIST . IT IS A DOUBLE SIZE TABLE
*                WHOSE SECOND HALF IS USED TO STORE ENTRIES IN FROM
*                THE FIRST HALF IF THE TERMINAL IS DEACTIVATED AND
*                THEREFORE NOT TO BE POLLED FOR NOW.  THE FIRST HALF
*                IS THE ACTUAL POLL LIST CURRENTLY IN USE
FIRSTBLK EQU   *                  BUFFR FOR 1ST BLK INPUT FRM POLLING
LOW3     EQU   B'0111'            STORE CHAR MASK FOR LOW 3 BYTES OF RG
SUBPOOL  EQU   9                  WORK AREA SUBPOOL ID
WORKSIZE EQU   *-LINEWORK         LENGTH OF WORKAREA
POLLLIST DC    XL4'0'             VARIABLE LEN POLL LIST BUILT HERE
POLLENQ  DC    X'0'               'ENQ' CHAR PLACED HERE
POLLINDX DC    X'0'               CURR ENT INDEX BYTE HERE
POLLENTL EQU   *-POLLLIST         LENGTH OF ONE ENTRY IN THE POLL LIST
         ORG   POLLLIST           REDEFINE THE POLL LIST ENTRY
POLLEOTS DC    X'00'              EOT OCCURS AFTER LAST ENTRY IN LIST
         ORG
POLLEND  EQU   *                  END OF 1ST ENT IN POLL LIST
         EJECT
         PRINT NOGEN
         DCBD  DSORG=BS,DEVD=BS
         EJECT
BSC3IO#  CSECT
BIT8ON   DS    0F
         DC    X'00800000'
*
*        TRANSLATE TABLES
*
OPCDTBL  DC    256X'00'
         ORG   OPCDTBL+TDECBRSF
         DC    X'F6'              READ SF = REMOTE F6
         ORG   OPCDTBL+TDECBRSB
         DC    X'F2'              READ      SB = REMOTE F2
         ORG   OPCDTBL+TDECBWSF
         DC    X'F1'              WRITE SF = REMOTE F1
         ORG   OPCDTBL+TDECBWSD
         DC    X'6F'              WRITE SD = REMOTE 6F
         ORG   OPCDTBL+TDECBWSZ
         DC    X'F5'              WRITE SZ = REMOTE F5
         ORG
         SPACE
MSCTRTBL DC    256X'00'
         ORG   MSCTRTBL+ACK1
         DC    YL1(ACK0)          ACK1 ALTERNATES TO ACK0
         ORG   MSCTRTBL+ACK0
         DC    YL1(ACK1)          ACK0 ALTERNATES TO ACK1
         ORG
         LTORG
         END
