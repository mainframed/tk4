//ARNIE2 JOB 526TSO000S0003,TEC,CLASS=D,MSGCLASS=3,NOTIFY=ARNIE,
// PRTY=11
//*
//*   BE CAREFUL OF THIS GUY
//*
//*   THE ASMBLY OF ZA06AS HAS TWO ADDITIONAL ENTRY POINTS
//*    THEY ARE ZA06BS AND ZA06CS
//*
//ASMBLR       PROC OBJ=NODECK,K=256,CC=4,SO=D
//ASMBLR       EXEC PGM=IEV90,REGION=&K.K,COND=(&CC,LT),
//             PARM='LOAD,LINECNT=59,&OBJ'
//SYSLIB       DD   DISP=SHR,DSN=SYS1.MACLIB
//             DD   DISP=SHR,DSN=CBT.MACLIB
//SYSPRINT     DD   SYSOUT=&SO,
//             DCB=(RECFM=FBM,LRECL=121,BLKSIZE=12221)
//SYSPUNCH     DD   SYSOUT=B,DCB=(RECFM=FB,LRECL=80,BLKSIZE=12240)
//SYSUT1       DD   UNIT=SYSDA,SPACE=(CYL,(10,2))
//SYSLIN       DD   DSN=&LOADSET,UNIT=SYSDA,SPACE=(CYL,(5,1)),
//             DISP=(MOD,PASS),DCB=BLKSIZE=12240
//SYSIN        DD   DISP=(OLD,DELETE),DSN=&WORK
//SYSUDUMP  DD SYSOUT=&SO
// PEND
//FORTRAN      PROC  ASM=NOLIST,OBJ=NODECK,CC=4,SO=D
//FORTRAN      EXEC  PGM=IGIFORT,REGION=128K,COND=(&CC,LT),
//             PARM='LOAD,MAP,&OBJ,&ASM,LINECNT=59,ID'
//SYSPRINT     DD    SYSOUT=&SO
//SYSTERM      DD    SYSOUT=&SO
//SYSPUNCH     DD    SYSOUT=B
//SYSLIN       DD    DSN=&LOADSET,UNIT=SYSDA,SPACE=(1680,(100,16)),
//             DISP=(MOD,PASS),DCB=BLKSIZE=1680
//SYSIN        DD    DSN=&WORK,DISP=(OLD,DELETE)
// PEND
//TESTLINK     PROC OPT=,NAME=RUN,CC=4,SO=D,LIB='TEST.LOAD'
//LKED         EXEC PGM=IEWL,REGION=256K,COND=(&CC,LT),
//             PARM='XREF,LIST&OPT',DPRTY=(15,10)
//SYSPRINT     DD   SYSOUT=&SO
//SYSUT1       DD   DSN=&SYSUT1,UNIT=SYSDA,SPACE=(TRK,(10,5)),
//             DCB=OPTCD=C
//SYSLMOD      DD   DISP=SHR,DSN=&LIB.(&NAME)
//SYSUDUMP  DD  SYSOUT=C
//SYSLIN       DD   UNIT=SYSDA,DSN=&LOADSET,DISP=(OLD,DELETE)
//             DD   DDNAME=SYSIN
//SYSLIB       DD   DISP=SHR,DSN=PROD.UTIL
//             DD   DISP=SHR,DSN=SYS1.COBLIB
//             DD   DISP=SHR,DSN=MVS.APEMAN
//             DD   DISP=SHR,DSN=SYS1.TELCMLIB
//             DD   DISP=SHR,DSN=SYS1.FORTLIB
//*            DD   DISP=SHR,DSN=SYS1.PL1LIB
//PRODLIB      DD   DISP=SHR,DSN=PROD.LOAD
//TESTLIB      DD   DISP=SHR,DSN=TEST.LOAD
// PEND
//STEP01 EXEC ASMBLR,SO=3,COND=EVEN
DECVB    START
*
*   LINKAGE IS CALL DECVB(IDEC,IBIN)
*   IDEC CONTAINS UNSIGNED PACKED DECIMAL DIGITS
*   WHICH ARE THE TOD IN THE FORM HHMMSSTH
*   THE BINARY VALUE OF IDEC IS RETURNED IN IBIN
*
RB2      EQU   2
RW3      EQU   3
RW4      EQU   4
RW5      EQU   5
*
         STM   14,12,12(13)
         BALR  RB2,0
         USING *,RB2
         LR    RW3,13
         ST    13,SAVE+4
         LA    13,SAVE
         ST    13,8(RW3)
*
         L     RW3,4(1)                ADDRESS OF IBIN
         L     RW5,0(1)                ADDRESS OF IBEC
         L     RW5,0(RW5)              IDEC
         ST    RW5,IDEC                STORE IDEC
         SR    RW4,RW4
         SR    RW5,RW5
         IC    RW5,IDEC                INSERT HH INTO REGISTER
         SLDL  RW4,4
         A     RW5,TWELVE              ADD IN SIGN
         STM   RW4,RW5,BCD             STORE IN DOUBLE WORD
         CVB   RW5,BCD                 CONVERT # HOURS TO BINARY
         M     RW4,SIXTY               CONVERT TO MINUTES
         ST    RW5,TIME
         SR    RW5,RW5
         IC    RW5,IDEC+1              INSERT MM INTO REGISTER
         SLDL  RW4,4
         A     RW5,TWELVE              ADD IN SIGN
         STM   RW4,RW5,BCD             STORE IN DOUBLE WORD
         CVB   RW5,BCD                 CONVERT # MINUTES TO BINARY
         A     RW5,TIME                ADD IN HOURS
         M     RW4,SIX000              CONVERT TO HUNDREDTHS
         ST    RW5,TIME
         SR    RW5,RW5
         LH    RW5,IDEC+2              LOAD SSTH INTO REGISTER
         SLDL  RW4,4
         A     RW5,TWELVE              ADD IN SIGN
         STM   RW4,RW5,BCD             STORE IN DOUBLE WORD
         CVB   RW5,BCD                 CONVERT TO BINARY
         A     RW5,TIME                ADD IN MINS AND HOURS
         ST     RW5,0(RW3)             STORE IN IBIN
         L     13,4(13)
         LM    14,12,12(13)
         BR    14
*
SAVE      DS    18F
TWELVE   DC    F'12'
SIXTY    DC    F'60'
SIX000   DC    F'6000'
IDEC     DS    F
TIME     DS    F
BCD      DS    D
         LTORG
         END
//S1A EXEC TESTLINK,SO=3,COND=EVEN,OPT=',NCAL,LET,AC=1',NAME=DECVB,
// LIB='MVS.APEMAN'
//STEP02 EXEC FORTRAN,SO=3,COND=EVEN
      COMMON/OPTION/ISTRM,GRAPH,LIST,ALL,DUMP,TRACE,TITLE
      REAL*8 KEY1/'GRAPH   '/,KEY2/'LIST    '/
      REAL*8 KEY3/'ALL     '/,KEY4/'DUMP    '/
      REAL*8 KEY5/'TRACE   '/
      REAL*8 DATE
      REAL*8 NULL/'        '/
      INTEGER NAME/'MAIN'/,MINT(26)
      INTEGER*4 NAME2/'DATE'/
      LOGICAL ON/.FALSE./
      LOGICAL TRACE
      LOGICAL DUMP
      LOGICAL ANY,ALL
      LOGICAL GRAPH,LIST
      INTEGER*2 TYPE(5),YES/' Y'/,NO/' N'/
      LOGICAL*1 IBUF(80)
      LOGICAL*1 TITLE(20)
      DATA IEND/'END '/
      DATA MONS/'MONS'/
      DATA MONP/'MONP'/
      DATA MONA/'MONA'/,MONZ/'MONZ'/
      DATA LENGTH/26/
C   ***********************************
C
C   MAIN ANALYSIS ROUTINE
C
C   ***********************************
   40 CONTINUE
C
C   TRANSFER MLPA MAP TO TEMP DS TO ENABLE REWIND
C
      READ(9,9000,END=45) IBUF
 9000 FORMAT(80A1)
      WRITE(11,9000) IBUF
      GOTO 40
   45 CONTINUE
   10 CONTINUE
      READ(5,5000,END=50) ISTRM,TYPE,TITLE
 5000 FORMAT(I2,5A2,20A1)
C
C   LOOK FOR DEFAULT FOR KEYWORDS
C
      CALL ZA06CS(5,KEY1,GRAPH)
      CALL ZA06CS(4,KEY2,LIST)
      CALL ZA06CS(3,KEY3,ALL)
      CALL ZA06CS(4,KEY4,DUMP)
      CALL ZA06CS(5,KEY5,TRACE)
C
C   SET UP OPTIONS REQUIRED FOR THIS RUN
C
      IF(TYPE(1).EQ.YES)  GRAPH=.TRUE.
      IF(TYPE(1).EQ.NO) GRAPH=.FALSE.
      IF(TYPE(2).EQ.YES) LIST=.TRUE.
      IF(TYPE(2).EQ.NO) LIST=.FALSE.
      IF(TYPE(3).EQ.YES) ALL=.TRUE.
      IF(TYPE(3).EQ.NO) ALL=.FALSE.
      IF(TYPE(4).EQ.YES) DUMP=.TRUE.
      IF(TYPE(4).EQ.NO) DUMP=.FALSE.
      IF(TYPE(5).EQ.YES) TRACE=.TRUE.
      IF(TYPE(5).EQ.NO) TRACE=.FALSE.
      WRITE(6,6000)TITLE
 6000 FORMAT('1DATA BEING ANALYSED IS   ',20A1,/,1X)
      WRITE(6,6030) GRAPH,LIST,ALL,DUMP,TRACE
 6030 FORMAT(' OPTIONS ARE :',/' GRAPH=',L1,',LIST=',L1,',ALL=',
     *L1,',DUMP=',L1,',TRACE=',L1)
      IF(.NOT.ON.AND.GRAPH) CALL FILM(1)
      IF(.NOT.ON.AND.GRAPH) ON=.TRUE.
C
C   READ DATE OF RUN FROM LOG
C
      DATE=NULL
      IFLAG=-1
      CALL MONRD(NAME2,2,DATE,IFLAG)
      IF(IFLAG.GT.0) GOTO 99
      IFLAG=0
      CALL MONRD(NAME2,2,DATE,IFLAG)
      IF(IFLAG.GT.0) GOTO 100
      WRITE(6,6040) DATE
 6040 FORMAT(' MONITOR RUN ON ',A8)
  100 CONTINUE
      IF(DUMP) CALL HEXDMP
      IF(ALL) GOTO 20
C
C   FIND ACTIVE MONITORS
C
      IFLAG=-1
      CALL MONRD(NAME,LENGTH,MINT,IFLAG)
      IF(IFLAG.GT.0) GOTO 99
      IFLAG=0
      CALL MONRD(NAME,LENGTH,MINT,IFLAG)
      IF(IFLAG.GT.0) GOTO 99
      ANY=.FALSE.
      DO 5 I=1,26
      IF(MINT(I).GT.0) ANY=.TRUE.
    5 CONTINUE
      IF(ANY) GOTO 30
   99 CONTINUE
      WRITE(6,6020)
 6020 FORMAT(' NO MONITORS ACTIVE OR ALL NOT SELECTED')
      GOTO 10
   20 CONTINUE
C
C   ALL SELECTED - EVERY ANALYSIS ROUTINE TO BE CALLED
C
      CALL TIME(MONA,DATE)
      CALL TIME(MONZ,DATE)
      CALL DUMPP0(MONP,DATE)
      CALL DUMPP1(MONP,DATE)
      CALL DUMPP2(MONP,DATE)
      CALL SNAP(MONS,DATE)
      GOTO 10
   30 CONTINUE
C
C   CALL ANALYSIS ROUTINES CORRESPONDING TO ACTIVE MONITORS ONLY
C
      IF(MINT(1).GT.0) CALL TIME(MONA,DATE)
      IF(MINT(26).GT.0) CALL TIME(MONZ,DATE)
      IF(MINT(16).LE.0) GOTO 35
      CALL DUMPP0(MONP,DATE)
      CALL DUMPP1(MONP,DATE)
      CALL DUMPP2(MONP,DATE)
   35 CONTINUE
      IF(MINT(19).GT.0) CALL SNAP(MONS,DATE)
      GOTO 10
   50 CONTINUE
      IF(ON) CALL GREND
      WRITE(6,6010)
 6010 FORMAT('0END OF ANALYSIS')
      STOP
      END
      SUBROUTINE HEXDMP
      COMMON/OPTION/ISTRM
      DIMENSION IBUF(1000)
C
C   HEX DUMP ROUTINE
C
      REWIND ISTRM
      WRITE(6,6000)
 6000 FORMAT('1 HEX DUMP OPTION')
   20 CONTINUE
      READ(ISTRM,1000,END=10) IBUF
 1000 FORMAT(4(250A4))
      WRITE(6,6010) IBUF
 6010 FORMAT((5(1X,Z8,1X),3X,5(1X,Z8,1X)))
      GOTO 20
   10 CONTINUE
      RETURN
      END
      SUBROUTINE MAPLPA(MODULE,INDIC,IMIN)
      REAL*8 MODULE(1000),NAME(2),NULL/'        '/
      INTEGER LOC(2),LEN(2)
      LOGICAL*1 INDIC(1000),AST/'*'/,LTEST(2),LTST(2)
      INTEGER*2 ITEST,ONE/' 1'/,NUM/' N'/,BLNK/'  '/,ITST
      EQUIVALENCE(ITEST,LTEST(1)),(ITST,LTST(1))
C
C   ROUTINE READS IN MODULE NAMES FROM STREAMS 10 AND 11
C   AND PLACES THEM IN MODULE . INDIC=* IF MORE THAN ONE MODULE/PFTE
C
      REWIND 10
      REWIND 11
   20 CONTINUE
      ITST=BLNK
      ITEST=BLNK
      READ(10,1000,END=10) LTEST(2),LTST(2)
 1000 FORMAT(A1,30X,A1)
      IF(ITEST.NE.ONE.OR.ITST.NE.NUM) GOTO 20
C
C   BEGINNING OF NUMERICAL LPA MAP
C
   30 CONTINUE
      READ(10,1010,END=10) LTEST(2)
 1010 FORMAT(A1)
      IF(ITEST.NE.BLNK) GOTO 30
      BACKSPACE 10
      READ(10,1011,END=10) (NAME(I),LOC(I),LEN(I),I=1,2)
 1011 FORMAT(1X,A8,1X,Z3,7X,Z3,38X,A8,1X,Z3,7X,Z3)
      DO 40 I=1,2
      IF(NAME(I).EQ.NULL) GOTO 40
      IT=LOC(I)-IMIN+1
      IF(IT.GT.1000.OR.IT.LE.0) GOTO 40
      IEND=IT+LEN(I)-1
      IF(IEND.LT.IT) IEND=IT
      DO 35 J=IT,IEND
      IF(MODULE(J).NE.NULL) INDIC(J)=AST
      IF(MODULE(J).EQ.NULL) MODULE(J)=NAME(I)
   35 CONTINUE
   40 CONTINUE
      GOTO 30
   10 CONTINUE
C
C   END OF LPA DATA
C
      READ(11,1100,END=11) NAME(1),LOC(1),LEN(1)
 1100 FORMAT(A8,1X,Z3,1X,Z3)
      IT=LOC(1)-IMIN+1
      IF(IT.GT.1000.OR.IT.LE.0) GOTO 10
      IEND=IT+LEN(1)-1
      IF(IEND.LT.IT) IEND=IT
      DO 50 J=IT,IEND
      IF(MODULE(J).NE.NULL) INDIC(J)=AST
      IF(MODULE(J).EQ.NULL) MODULE(J)=NAME(1)
   50 CONTINUE
      GOTO 10
   11 CONTINUE
C
C   END OF MLPA DATA
C
      NAME(1)=MODULE(1)
      DO 60 I=2,1000
      IF(MODULE(I).EQ.NULL) MODULE(I)=NAME(1)
      NAME(1)=MODULE(I)
   60 CONTINUE
      RETURN
      END
      SUBROUTINE DUMPP0(NAME,DATE)
      COMMON/OPTION/ISTRM,GRAPH,LIST
      DIMENSION IDATA(7)
      REAL*8 VIO/'*VIO    '/
      REAL*8 DATE
      REAL*8 MODL(10)
      REAL*8 MODT
      REAL*8 MODULE(1000),NULL/'        '/
      INTEGER LIMSKS(3)
      INTEGER IFLGS(425),IT4,TYPE,ASID,FLAGS
      INTEGER VBMAX,VBMIN,VBSTEP
      INTEGER*2 NT2(2),IVBN(425),IFIX(425)
      INTEGER*2 IT2(2),IDAT(14),VBN,FIX
      REAL COUNT(1000)
      REAL*8 JOBNAM,IJOB
      REAL TOTAVL,TOTSQA,TOTOTH,TOTPGC
      LOGICAL GRAPH,LIST
      LOGICAL PMSK(425),LMSKS(3)
      LOGICAL PLOT/.TRUE./,ILG,MSKS(4),ANY,FIRST/.TRUE./,PAGE/.FALSE./
      LOGICAL*1 INDIC(1000),BLNK/' '/,AST/'*'/,LINE(100)
      LOGICAL*1 MINUS/'-'/
      LOGICAL*1 LTIME(4),LTTIME(4)
      EQUIVALENCE(LTIME(1),TIME),(LTTIME(1),TTIME)
      EQUIVALENCE(ITMP,ILG),(NT2(1),NT4),(IT2(1),IT4)
      EQUIVALENCE(IDATA(1),IDAT(1)),(IDATA(1),TIME),(IDATA(2),TYPE),
     *(IDATA(3),JOBNAM),(IDATA(5),ASID),(IDAT(11),VBN),(IDAT(12),FIX),
     *(IDATA(7),FLAGS)
      EQUIVALENCE(PMSK(1),IFLGS(1)),(LIMSKS(1),LMSKS(1))
      DATA ITOP/Z0000B000/
      DATA LMSKS/Z80000000,Z20000000,ZA0000000/
      DATA MSKS/Z0000F000,Z00000F00,Z000000F0,Z0000000F/
      DATA LENGTH/7/
C
C   ROUTINE WRITES OUT RECORDS WRITTEN BY MONP
C
      IFLAG=-1
      CALL MONRD(NAME,LENGTH,IDATA,IFLAG)
      IF(IFLAG.GT.0) GOTO 999
      WRITE(6,6100)
 6100 FORMAT('1MVS PAGING ANALYSIS')
      WRITE(6,6101)
 6101 FORMAT(' --- ------ --------',/,1X)
      IFLAG=0
  100 CONTINUE
C   ***********************************
C
C   WRITE OUT TYPE 0 RECORDS - JOBNAME NOT FOUND
C
C   ***********************************
      CALL MONRD(NAME,LENGTH,IDATA,IFLAG)
      IF(IFLAG.GT.0) GOTO 199
      IF(TYPE.NE.0) GOTO 100
      WRITE(6,6300) LTIME,JOBNAM
 6300 FORMAT(3X,3(Z2,'.'),Z2,'   PROGRAM ',A8,' WAS NOT FOUND')
      GOTO 100
  199 CONTINUE
      RETURN
C   ***********************************
      ENTRY DUMPP1(NAME,DATE)
C
C   WRITE OUT TYPE 1 RECORDS - PFTE'S
C
C   ***********************************
      IASMAX=0
      DO 400 K=1,257
      PLOT=.TRUE.
      XMIN=0.
      ANY=.FALSE.
      IASID=K-2
C
      CALL MONRD(NAME,LENGTH,IDATA,IFLAG)
      IF(IFLAG.GT.0) GOTO 420
      IF(TYPE.NE.1) GOTO 410
      IF(IASID.EQ.0.AND.JOBNAM.EQ.IJOB) GOTO 411
      IF(ASID.GT.IASMAX) IASMAX=ASID
      IF(ASID.NE.IASID) GOTO 410
  411 CONTINUE
      IT2(1)=0
      IT2(2)=VBN
      IF(IASID.GE.0.AND.IT4.GT.ITOP) GOTO 410
      IF(ANY) GOTO 430
      VBMAX=IT4
      VBMIN=IT4
      ANY=.TRUE.
  430 CONTINUE
      IF(VBMAX.LT.IT4) VBMAX=IT4
      IF(VBMIN.GT.IT4) VBMIN=IT4
      GOTO 410
  420 CONTINUE
      IF(.NOT.ANY) GOTO 400
      IFLAG=-1
      CALL MONRD(NAME,LENGTH,IDATA,IFLAG)
      IF(IFLAG.GT.0) GOTO 999
      IFLAG=0
C
C   SET COUNTERS TO ZREO
C
      IPGCT=0
      IAVL=0
      IOTH=0
      ISQA=0
      NCALLS=0
      TOTAVL=0.
      TOTOTH=0.
      TOTSQA=0.
      TOTPGC=0.
      VBMIN=(VBMIN/256)*16
      VBMAX=(VBMAX/256+1)*16
C
C   SET MODULE NAMES TO BLANKS
C
      DO 440 I=1,1000
      MODULE(I)=NULL
      INDIC(I)=BLNK
      COUNT(I)=0.
  440 CONTINUE
      IF(IASID.EQ.-1) CALL MAPLPA(MODULE,INDIC,VBMIN)
      IF(.NOT.LIST) WRITE(6,6102)
      FIRST=.TRUE.
  300 CONTINUE
C
C   WRITE OUT PFTE AT ANY ONE TIME
C
      CALL MONRD(NAME,LENGTH,IDATA,IFLAG)
      IF(IFLAG.GT.0) GOTO 310
      IF(TYPE.NE.1) GOTO 300
      IF(IASID.EQ.0.AND.JOBNAM.EQ.IJOB) GOTO 301
      IF(ASID.NE.IASID) GOTO 300
  301 CONTINUE
      IF(.NOT.FIRST) GOTO 303
C
C   SET UP FOR FIRST PFTE
C
      IJOB=JOBNAM
      TTIME=TIME
      FIRST=.FALSE.
  303 CONTINUE
      IF(TTIME.NE.TIME) GOTO 310
  305 CONTINUE
      IPGCT=IPGCT+1
      IVBN(IPGCT)=VBN
      IFIX(IPGCT)=FIX
      IFLGS(IPGCT)=FLAGS
      GOTO 300
  310 CONTINUE
      NCALLS=NCALLS+1
C
C   NEW ASID - SORT AND WRITE/PLOT
C
      DO 320 I=1,IPGCT
      DO 330 J=I,IPGCT
      IT2(1)=0
      NT2(1)=0
      IT2(2)=IVBN(I)
      NT2(2)=IVBN(J)
      IF(IT4.LT.NT4) GOTO 330
      IT2(2)=IVBN(I)
      IVBN(I)=IVBN(J)
      IVBN(J)=IT2(2)
      IT2(2)=IFIX(I)
      IFIX(I)=IFIX(J)
      IFIX(J)=IT2(2)
      IT4=IFLGS(I)
      IFLGS(I)=IFLGS(J)
      IFLGS(J)=IT4
  330 CONTINUE
  320 CONTINUE
      IT2(1)=0
C
C   INCREMENT COU T FOR HISTOGRAM
C
      DO 309 I=1,IPGCT
      IT2(2)=IVBN(I)
      IMOD=IT4/16-VBMIN+1
      IF(IMOD.GT.1000) GOTO 309
      COUNT(IMOD)=COUNT(IMOD)+1.
  309 CONTINUE
      IPCT=1
      PAGE=.TRUE.
      DO 500 I=1,IPGCT
      IF(.NOT.LIST) GOTO 520
      IF(.NOT.PAGE) GOTO 510
C
C   WRITE OUT FULL LIST OF PFTE'S
C
      WRITE(6,6102)
 6102 FORMAT(1H1)
      WRITE(6,6105)IPCT
 6105 FORMAT('  TYPE     TIME      JOBNAME  ASID  VBN  FIX   FLAGS',
     *45X,'PAGE ',I3)
      WRITE(6,6106)
 6106 FORMAT('  ----     ----      -------  ----  ---  ---   -----',
     *45X,'--------',/,1X)
      IPCT=IPCT+1
      PAGE=.FALSE.
  510 CONTINUE
      WRITE(6,6000)TYPE,LTTIME,IJOB,IASID,IVBN(I),IFIX(I),IFLGS(I)
 6000 FORMAT(3X,I2,3X,3(Z2,'.'),Z2,2X,A8,2X,I2,2X,Z4,2X,I2,3X,Z8)
  520 CONTINUE
C
C   CHECK FOR TYPE OF PFTE
C
      ILG=PMSK(I).AND.LMSKS(1)
      IF(ITMP.NE.LIMSKS(1)) GOTO 501
      IAVL=IAVL+1
      IF(.NOT.LIST) GOTO 501
      WRITE(6,6501)
 6501 FORMAT('+',70X,'AVAILABLE')
  501 CONTINUE
      ILG=PMSK(I).AND.LMSKS(2)
      IF(ITMP.NE.LIMSKS(2)) GOTO 502
      ISQA=ISQA+1
      IF(.NOT.LIST) GOTO 502
      WRITE(6,6502)
 6502 FORMAT('+',65X,'LSQA')
  502 CONTINUE
      ILG=PMSK(I).AND.LMSKS(3)
      IF(ITMP.EQ.0) IOTH=IOTH+1
      IF(MOD(I,36).EQ.0) PAGE=.TRUE.
      IF(IASID.NE.-1) GOTO 500
      IF(.NOT.LIST) GOTO 500
      IT4=0
      IT2(2)=IVBN(I)
      IMOD=IT4/16-VBMIN+1
      IF(IMOD.GT.1000) GOTO 500
      WRITE(6,6022) MODULE(IMOD)
 6022 FORMAT('+',55X,A8)
  500 CONTINUE
C
C   WRITE OUT SUMMARY
C
      WRITE(6,6020) LTTIME,IJOB,IASID
 6020 FORMAT(1X,/,3X,3(Z2,'.'),Z2,3X,A8,'   ASID=',I3)
      WRITE(6,6021) IAVL,ISQA,IOTH,IPGCT
 6021 FORMAT(' AVAILABLE   PAGES ',I3,/,' LSQA',8X,'PAGES ',I3,/,
     *' OTHER',7X,'PAGES ',I3,/,' TOTAL',7X,'PAGES ',I3)
      IF(IASID.NE.-1) GOTO 504
      MODT=NULL
      WRITE(6,6023)
 6023 FORMAT(' MODULES PRESENT -')
      LCT=1
      DO 503 I=1,IPGCT
      IT4=0
      IT2(2)=IVBN(I)
      IMOD=IT4/16-VBMIN+1
      IF(IMOD.GT.1000) GOTO 503
      IF(MODULE(IMOD).EQ.MODT.OR.MODULE(IMOD).EQ.NULL) GOTO 503
      MODT=MODULE(IMOD)
      MODL(LCT)=MODT
      LCT=LCT+1
      IF(LCT.LE.10) GOTO 503
      WRITE(6,6024) MODL
 6024 FORMAT(1X,10(A8,','))
      LCT=1
  503 CONTINUE
      LCT=LCT-1
      IF(LCT.EQ.0) GOTO 504
      WRITE(6,6024) (MODL(I),I=1,LCT)
  504 CONTINUE
C
C   INCREMENT COUNTERS
C
      TOTAVL=TOTAVL+IAVL
      TOTOTH=TOTOTH+IOTH
      TOTSQA=TOTSQA+ISQA
      TOTPGC=TOTPGC+IPGCT
      IF(.NOT.GRAPH) GOTO 530
      IF(.NOT.PLOT) GOTO 340
C
C   PLOT AND ANNOTATE AXES
C
      PLOT=.FALSE.
      XMAX=XMIN+10.
      YMIN=VBMIN
      YMAX=VBMAX
      CALL PSPACE(.1,.95,-.26,.95)
      CALL CSPACE(-3.,3.,-3.,3.)
      CALL MAP(XMIN,XMAX,YMIN,YMAX)
C
C   INSERT TITLE
C
      CALL POSITN(XMIN,YMAX)
      CALL LINEFD(-1)
      CALL SPACE(6)
      CALL TYPECS(IJOB,8)
      CALL TYPECS('   ASID=',8)
      CALL TYPENI(IASID)
      CALL SPACE(10)
      CALL TYPECS(DATE,8)
C
C   ANNOTATE Y AXIS
C
      CALL POSITN(XMIN,YMAX)
      CALL JOIN(XMIN,YMIN)
      CALL JOIN(XMAX,YMIN)
      INCR=(YMAX-YMIN)/16
      INCR=(INCR/16+1)*16
      DO 339 I=VBMIN,VBMAX,INCR
      Y=I
      CALL PLOTNC(XMIN,Y,44)
      CALL SPACE(-4)
      IT4=I*16
      CALL TYPHEX(IT2(2),3)
  339 CONTINUE
      XTIME=XMIN+0.5
  340 CONTINUE
      CALL CTRMAG(10)
C
C   PLOT VBN'S ON GRAPH
C
      DO 380 I=1,IPGCT
      NT2(1)=0
      NT2(2)=IVBN(I)
      Y=NT4/16
      IF(Y.GT.YMAX) GOTO 380
      CALL PLOTNC(XTIME,Y,45)
  380 CONTINUE
C
C   ANNOTATE X AXIS
C
      CALL CTRMAG(20)
      CALL POSITN(XTIME,YMIN)
      CALL CTRORI(-1.)
      CALL PLOTNC(XTIME,YMIN,44)
      CALL SPACE(1)
      CALL CTRMAG(15)
      DO 338 I=1,3
      CALL TYPHEX(LTTIME(I),2)
      CALL TYPENC(37)
  338 CONTINUE
      CALL TYPHEX(LTTIME(4),2)
      CALL CTRORI(0.)
      CALL CTRMAG(20)
      XTIME=XTIME+0.5
      IF(XTIME.GT.XMAX) XMIN=XMAX
      IF(XTIME.GT.XMAX) PLOT=.TRUE.
      IF(PLOT) CALL FRAME
  530 CONTINUE
      IF(IFLAG.GT.0) GOTO 399
      TTIME=TIME
      IPGCT=0
      IAVL=0
      IOTH=0
      ISQA=0
      GOTO 305
  399 CONTINUE
C
C   END OF DATA FOR ASID - WRITE OUT AVERAGES
C
      WRITE(6,6400) IJOB,IASID
 6400 FORMAT('1 AVERAGE PAGES FOR ',A8,'   ASID=',I3)
      TOTSQA=TOTSQA/NCALLS
      TOTPGC=TOTPGC/NCALLS
      TOTAVL=TOTAVL/NCALLS
      TOTOTH=TOTOTH/NCALLS
      WRITE(6,6401) TOTAVL,TOTSQA,TOTOTH,TOTPGC
 6401 FORMAT(' AVAILABLE   PAGES ',F5.1,/,' LSQA',8X,'PAGES ',F5.1,
     */,' OTHER',7X,'PAGES ',F5.1,/,' TOTAL',7X,'PAGES ',F5.1)
      IF(.NOT.GRAPH) GOTO 400
C
C   PLOT HISTOGRAM
C
      IPCT=1
      PAGE=.TRUE.
      NCT=1
      IMAX=VBMAX-VBMIN+1
      IF(IMAX.GT.1000) IMAX=1000
  600 CONTINUE
      IF(.NOT.PAGE) GOTO 610
      IF(NCT.GT.IMAX) GOTO 630
      IEND=NCT+40
      IF(IEND.GT.IMAX) IEND=IMAX
      ANY=.FALSE.
      DO 609 I=NCT,IEND
      IF(COUNT(I).NE.0.) ANY=.TRUE.
  609 CONTINUE
      IF(ANY) GOTO 608
      ISTRT=NCT+VBMIN-1
      IEND=IEND+VBMIN-1
      WRITE(6,6415) IJOB,IASID,ISTRT,IEND
 6415 FORMAT('0',A8,'   ASID=',I3,' - VBN ',Z3,' TO ',Z3,
     *' WERE NOT REFERENCED')
      NCT=NCT+41
      IF(NCT.GT.IMAX) GOTO 630
      IPCT=IPCT+1
      GOTO 600
  608 CONTINUE
C
C   WRITE HEADINGS
C
      WRITE(6,6410) IJOB,IASID,IPCT
 6410 FORMAT('1',A8,'   ASID=',I3,45X,'PAGE ',I3)
      WRITE(6,6420)
 6420 FORMAT(' MODULE   CONT  PERCENT  BLOCK 0',8X,'10',8X,'20',
     *8X,'30',8X,'40',8X,'50',8X,'60',8X,'70',8X,'80',8X,'90',8X,'100')
      WRITE(6,6430) (MINUS,I=1,132)
 6430 FORMAT(1X,132A1)
      IPCT=IPCT+1
      PAGE=.FALSE.
      LCT=0
  610 CONTINUE
      IMOD=VBMIN+NCT-1
      RCOUNT=COUNT(NCT)/NCALLS*100.
      DO 620 I=1,100
      LINE(I)=BLNK
      X=I
      IF(X.LE.RCOUNT) LINE(I)=AST
  620 CONTINUE
      WRITE(6,6440) MODULE(NCT),INDIC(NCT),RCOUNT,IMOD,LINE
 6440 FORMAT(1X,A8,3X,A1,3X,F7.3,3X,Z3,2X,'×',100A1)
      NCT=NCT+1
      IF(NCT.GT.IMAX) GOTO 630
      LCT=LCT+1
      IF(LCT.GT.40) PAGE=.TRUE.
      GOTO 600
  630 CONTINUE
C
C   END OF HISTOGRAM - RESET PLOTTONG
C
      CALL FRAME
      CALL PSPACE(0.1,0.95,0.1,0.95)
      CALL CSPACE(0.,1.,0.,1.)
  400 CONTINUE
   99 CONTINUE
      RETURN
C   ***********************************
C
      ENTRY DUMPP2(NAME,DATE)
C
C   WRITE OUT TYPE 2 RECORDS - JOBNAME/ASID
C
C   ***********************************
      IFLAG=-1
      CALL MONRD(NAME,LENGTH,IDATA,IFLAG)
      IF(IFLAG.GT.0) GOTO 999
      IFLAG=0
      FIRST=.TRUE.
  200 CONTINUE
      CALL MONRD(NAME,LENGTH,IDATA,IFLAG)
      IF(IFLAG.GT.0) GOTO 900
      IF(TYPE.NE.2) GOTO 200
      IF(.NOT.FIRST.AND.TIME.EQ.TTIME) GOTO 210
      IF(FIRST) WRITE(6,6102)
      TTIME=TIME
      FIRST=.FALSE.
      WRITE(6,6200) LTTIME
 6200 FORMAT(//,3X,3(Z2,'.'),Z2,'   JOBNAME  ASID')
      WRITE(6,6210)
 6210 FORMAT('   -----------   -------  ----',/,1X)
  210 CONTINUE
      WRITE(6,6220) JOBNAM,ASID
 6220 FORMAT(17X,A8,2X,I3)
      GOTO 200
  900 CONTINUE
      WRITE(6,6030)
 6030 FORMAT(1X,/,' END OF PAGING ANALYSIS')
  999 RETURN
      END
      SUBROUTINE SNAP(NAME,DATE)
C
C   STORAGE AREAS FOR 1 PAGE OF SNAPSHOTS
C
      REAL*8 DATE
      REAL*8 JOBNAM(256)
      LOGICAL*1 TYPE(18)
      LOGICAL FIRST
      INTEGER*2 PGRP(18),DISPRT(18),NODSPQ(18),DWAIT(18),
     *VIOS(18),NVIO(18),WLM(18),SWPIN(18),SWPOUT(18)
      INTEGER*2 NOWTS(256),SWCT(18)
      REAL*8 INIT/'INIT    '/
C
C   STORAGE AREAS FOR DATA INPUT
C
      INTEGER*4 IDATA(23),TIME,TTIME,ASID
      REAL*8 R81
      INTEGER J1(2,256)
      INTEGER*4 IT4,NT4
      INTEGER*2 IT2(2)
      LOGICAL*1 IT1(4),NT1(4)
      LOGICAL MASK/Z00007000/
      LOGICAL DELTA
      LOGICAL*1 S/'S'/,L/'L'/,B/'B'/,M/'M'/,EVNT(8)
      LOGICAL*1 LTIME(4),LTTIME(4)
      INTEGER*2 IDAT(46)
      REAL*8 FMT(20),NAPP,APP
      INTEGER*4 IN/'  IN'/,STS(2),IFLG(2),BLNK/'    '/
      INTEGER*4 MIN4/'-   '/
      LOGICAL*4 LTEMP,LFLG(2)
      INTEGER*2 MIN/'- '/
C
      EQUIVALENCE(IT4,IT2(1)),(IT4,IT1(1)),(NT4,NT1(1))
      EQUIVALENCE(LTTIME(1),TTIME)
      EQUIVALENCE(IDATA(1),TIME),(TIME,LTIME(1)),(IDATA(4),NASID),
     *(IDATA(1),IDAT(1)),(R81,IDATA(2)),(LTEMP,ITEMP),(LFLG(1),IFLG(1))
      EQUIVALENCE(JOBNAM(1),J1(1,1))
C
      DATA EVNT/'M','P','Q','E','C','T','O','L'/
      DATA FMT/'(1H+,12X',18*'        ',')       '/
      DATA APP/',I6     '/,NAPP/',5X,A1  '/
      DATA STS/' OUT','NS/R'/
      DATA LFLG/Z00008400,Z00000001/
      DATA LENGTH/23/
C   ***********************************
C
C   DUMP OF SNAPSHOTS
C
C   ***********************************
      IFLAG=-1
      CALL MONRD(NAME,LENGTH,IDATA,IFLAG)
      IF(IFLAG.GT.0) GOTO 999
      IFLAG=0
C
C   INITIALIZE COUNTERS AND STORAGE AREAS
C
      DELTA=.TRUE.
      FIRST=.TRUE.
C   COUNTERS FOR TOTALS FOR SNAPSHOTS
      TOTSTP=0
      TOTSRB=0
      TOTWAT=0
      TOTSRV=0
      TOTIN=0
      TOTOUT=0
      TOTNSR=0
      TOTINT=0
      TOTTSO=0
      NCALLS=0
C   COUNTERS FOR AVERAGES
      AVRIN=0.
      AVROUT=0.
      AVRNSR=0.
      AVRINT=0.
      AVRTSO=0.
      AVRSTP=0.
      AVRSRB=0.
      AVRWAT=0.
      AVRSRV=0.
C   STORAGE AREAS FOR SNAPSHOTS
      ICT=0
      DO 5 I=1,18
      VIOS(I)=0
      NVIO(I)=0
      STATUS(I)=BLNK
    5 CONTINUE
  100 CONTINUE
      CALL MONRD(NAME,LENGTH,IDATA,IFLAG)
      IF(IFLAG.GT.0) GOTO 20
      IF(NASID.LE.0) GOTO 100
      IF(.NOT.FIRST) GOTO 10
      TTIME=TIME
C
C   OBTAIN BINARY REPRESENTATION OF TIME OF CALL
C
      CALL DECVB(TTIME,LSTIM)
      IFSTIM=LSTIM
      FIRST=.FALSE.
   10 CONTINUE
C
C   CHECK FOR END OF CURRENT SNAPSHOT
C
      IF(TTIME.NE.TIME) GOTO 20
  105 CONTINUE
      ICT=ICT+1
      IF(ICT.GT.18) GOTO 20
      ASID=ICT
C
C   SET DATA INTO STORAGE AREAS
C
      IASID(ASID)=NASID
      IF(JOBNAM(NASID).EQ.R81) GOTO 13
C
C   ASID HAS NEW JOBNAME - RESET COUNTERS
C
      VIOS(ASID)=0
      NVIO(ASID)=0
      NOWTS(NASID)=0
      STPTIM(NASID)=0
      SRBTIM(NASID)=0
      SRVSUM(NASID)=0
      DWAIT(ASID)=0
      JOBNAM(NASID)=R81
   13 CONTINUE
      IF(JOBNAM(NASID).EQ.INIT) TOTINT=TOTINT+1
C
C   FIND IF ADDRESS SPACE IS IN,OUT,NS/R
C
      STATUS(ASID)=IN
      DO 15 I=1,2
      ITEMP=IDAT(21)
      LTEMP=LTEMP.AND.LFLG(I)
      IF(ITEMP.NE.0) STATUS(ASID)=STS(I)
   15 CONTINUE
C
C   INCREMENT COUNTERS
C
      IF(STATUS(ASID).EQ.IN) TOTIN=TOTIN+1
      IF(STATUS(ASID).EQ.STS(1)) TOTOUT=TOTOUT+1
      IF(STATUS(ASID).EQ.STS(2)) TOTNSR=TOTNSR+1
C
C   SET UP # WAITS,D-WAIT,# VIO SLOTS,# NON-VIO SLOTS
C
      DWAIT(ASID)=IDAT(34)-NOWTS(NASID)
      IF(DELTA) DWAIT(ASID)=0
      IF(DWAIT(ASID).LT.0) DWAIT(ASID)=0
      NOWTS(NASID)=IDAT(34)
      VIOS(ASID)=IDAT(35)
      NVIO(ASID)=IDAT(36)
      TOTWAT=TOTWAT+DWAIT(ASID)
      PGRP(ASID)=IDAT(23)
      DISPRT(ASID)=IDAT(14)
      NODSPQ(ASID)=IDAT(13)
      WLM(ASID)=IDAT(24)/256
      SWPIN(ASID)=IDAT(29)
      SWPOUT(ASID)=IDAT(30)
C
C   GET STEP TIME INTO MILLISECS
C
      IT2(1)=IDAT(10)
      IT2(2)=IDAT(11)
      IT4=(IT4/1000)*16
      DSTEP(ASID)=IT4-STPTIM(NASID)
      IF(DELTA) DSTEP(ASID)=0
      IF(DSTEP(ASID).LT.0) DSTEP(ASID)=0
      STPTIM(NASID)=IT4
      STP(ASID)=IT4/100
      TOTSTP=TOTSTP+DSTEP(ASID)
C
C   GET SRB TIME INTO MILLISECS
C
      IT2(1)=IDAT(18)
      IT2(2)=IDAT(19)
      IT4=(IT4/1000)*16
      DSRB(ASID)=IT4-SRBTIM(NASID)
      IF(DELTA) DSRB(ASID)=0
      IF(DSRB(ASID).LT.0) DSRB(ASID)=0
      SRBTIM(NASID)=IT4
      SRB(ASID)=IT4/100
      TOTSRB=TOTSRB+DSRB(ASID)
C
C   MOVE ALLOC,LSQA,LOCAL,FIXED,VIO FRAME COUNTS
C
      ALLOC(ASID)=IDATA(19)
      LSQA(ASID)=IDATA(20)
      LOCAL(ASID)=IDATA(21)
      FIXED(ASID)=IDATA(22)
      VIOF(ASID)=IDATA(23)
      SWCT(ASID)=IDAT(31)
      DSRVSM(ASID)=IDATA(14)-SRVSUM(NASID)
      IF(DELTA) DSRVSM(ASID)=0
      IF(DSRVSM(ASID).LT.0) DSRVSM(ASID)=0
      SRVSUM(NASID)=IDATA(14)
      TOTSRV=TOTSRV+DSRVSM(ASID)
      RRV(ASID)=IDATA(13)/256
C
C   SET UP TYPE OF JOB
C
      TYPE(ASID)=B
      ITEMP=IDAT(33)
      LTEMP=LTEMP.AND.MASK
      IT4=ITEMP/4096
      IF(IT4.EQ.1) TYPE(ASID)=M
      IF(IT4.EQ.2) TYPE(ASID)=L
      IF(IT4.EQ.2) TOTTSO=TOTTSO+1
      IF(IT4.EQ.4) TYPE(ASID)=S
C
C   SET UP TYPE OF EVENT
C
      NT4=BLNK
      JCT=4
      IT2(1)=IDAT(33)
      DO 17 I=1,8
      IT2(2)=0
      IT4=IT4/2
      IF(IT2(2).EQ.0) GOTO 17
      NT1(JCT)=EVNT(I)
      JCT=JCT-1
      IF(JCT.EQ.0) GOTO 18
   17 CONTINUE
   18 CONTINUE
      EVENT(ASID)=NT4
      GOTO 100
C   ***********************************
   20 CONTINUE
C
C   WRITE OUT SNAPSHOTS OF FIRST 18 ASIDS
C
C   ***********************************
      IF(FIRST) GOTO 999
      IF(ICT.GT.18) ICT=18
      IF(ICT.LE.0) GOTO 999
      IF(TTIME.NE.TIME) DELTA=.FALSE.
      DO 25 I=2,19
      FMT(I)=APP
      IF(STATUS(I-1).NE.STS(2)) GOTO 25
      FMT(I)=NAPP
      PGRP(I-1)=MIN
      SWPIN(I-1)=MIN
      SWPOUT(I-1)=MIN
      WLM(I-1)=MIN
      RRV(I-1)=MIN4
   25 CONTINUE
      WRITE(6,6000) LTTIME,DATE
 6000 FORMAT('1SNAPSHOT AT ',3(Z2,'.'),Z2,' ON ',A8)
 6001 FORMAT('+',12X,18I6)
 6002 FORMAT('+',12X,18(2X,A4))
 6003 FORMAT('+',12X,18(5X,A1))
      WRITE(6,6010)
 6010 FORMAT(' ASID')
      WRITE(6,6001) (IASID(I),I=1,ICT)
      WRITE(6,6011)
 6011 FORMAT(' JOBNAMES')
      WRITE(6,6002) (J1(1,IASID(I)),I=1,ICT)
      WRITE(6,6012)
 6012 FORMAT(1X)
      WRITE(6,6002) (J1(2,IASID(I)),I=1,ICT)
      WRITE(6,6013)
 6013 FORMAT(' TYPE')
      WRITE(6,6003) (TYPE(I),I=1,ICT)
      WRITE(6,6014)
 6014 FORMAT(' PERF GRP')
      WRITE(6,FMT) (PGRP(I),I=1,ICT)
      WRITE(6,6015)
 6015 FORMAT(' SWP-IN SIZE')
      WRITE(6,FMT) (SWPIN(I),I=1,ICT)
      WRITE(6,6016)
 6016 FORMAT(' SWP-OT SIZE')
      WRITE(6,FMT) (SWPOUT(I),I=1,ICT)
      WRITE(6,6017)
 6017 FORMAT(' DISP PRTY')
      WRITE(6,6001) (DISPRT(I),I=1,ICT)
      WRITE(6,6018)
 6018 FORMAT(' # IN DISP Q')
      WRITE(6,6001) (NODSPQ(I),I=1,ICT)
      WRITE(6,6019)
 6019 FORMAT(' STEP TIME')
      WRITE(6,6001) (STP(I),I=1,ICT)
      WRITE(6,6020)
 6020 FORMAT(' D-STEP TIME')
      WRITE(6,6001) (DSTEP(I),I=1,ICT)
      WRITE(6,6021)
 6021 FORMAT(' SRB TIME')
      WRITE(6,6001) (SRB(I),I=1,ICT)
      WRITE(6,6022)
 6022 FORMAT(' D-SRB TIME')
      WRITE(6,6001) (DSRB(I),I=1,ICT)
      WRITE(6,6023)
 6023 FORMAT(' # OF WAITS')
      WRITE(6,6001) (NOWTS(IASID(I)),I=1,ICT)
      WRITE(6,6024)
 6024 FORMAT(' D-WAIT')
      WRITE(6,6001) (DWAIT(I),I=1,ICT)
      WRITE(6,6025)
 6025 FORMAT(' ALLOC FRAME')
      WRITE(6,6001) (ALLOC(I),I=1,ICT)
      WRITE(6,6026)
 6026 FORMAT(' LSQA FRAMES')
      WRITE(6,6001) (LSQA(I),I=1,ICT)
      WRITE(6,6027)
 6027 FORMAT(' LOCAL FRAME')
      WRITE(6,6001) (LOCAL(I),I=1,ICT)
      WRITE(6,6028)
 6028 FORMAT(' FIXED FRAME')
      WRITE(6,6001) (FIXED(I),I=1,ICT)
      WRITE(6,6029)
 6029 FORMAT(' VIO FRAMES')
      WRITE(6,6001) (VIOF(I),I=1,ICT)
      WRITE(6,6030)
 6030 FORMAT(' VIO SLOTS')
      WRITE(6,6001) (VIOS(I),I=1,ICT)
      WRITE(6,6031)
 6031 FORMAT(' N-VIO SLOTS')
      WRITE(6,6001) (NVIO(I),I=1,ICT)
      WRITE(6,6032)
 6032 FORMAT(' # OF SWAPS')
      WRITE(6,6001) (SWCT(I),I=1,ICT)
      WRITE(6,6033)
 6033 FORMAT(' SERV SUM')
      WRITE(6,6001) (SRVSUM(IASID(I)),I=1,ICT)
      WRITE(6,6034)
 6034 FORMAT(' D-SERV SUM')
      WRITE(6,6001) (DSRVSM(I),I=1,ICT)
      WRITE(6,6035)
 6035 FORMAT(' WLM RV')
      WRITE(6,FMT) (WLM(I),I=1,ICT)
      WRITE(6,6036)
 6036 FORMAT(' RESOURCE RV')
      WRITE(6,FMT) (RRV(I),I=1,ICT)
      WRITE(6,6037)
 6037 FORMAT(' EVENT')
      WRITE(6,6002) (EVENT(I),I=1,ICT)
      WRITE(6,6038)
 6038 FORMAT(' STATUS')
      WRITE(6,6002) (STATUS(I),I=1,ICT)
      CALL DECVB(TTIME,NOWTIM)
      RINT=FLOAT(NOWTIM-LSTIM)
      IF(RINT.LT.0.) RINT=RINT+8640000.
      DO 200 I=1,ICT
      PCCPU(I)=0.
      IF(RINT.LE.0.) GOTO 200
      PCCPU(I)=(DSTEP(I)+DSRB(I))/RINT*10.
  200 CONTINUE
      WRITE(6,6070)
 6070 FORMAT(' % TIME/SEC')
      WRITE(6,6071) (PCCPU(I),I=1,ICT)
 6071 FORMAT('+',12X,18F6.1)
      IF(TTIME.EQ.TIME.AND.IFLAG.LE.0) GOTO 110
C
C   WRITE OUT TOTALS FOR SNAPSHOT
C
      NCALLS=NCALLS+1
      CALL DECVB(TTIME,NOWTIM)
      RINT=FLOAT(NOWTIM-LSTIM)/100.
      IF(RINT.LT.0.) RINT=RINT+86400.
      LSTIM=NOWTIM
      WRITE(6,6039) LTTIME,RINT
 6039 FORMAT('0TOTALS AT ',3(Z2,'.'),Z2,5X,'(INTERVAL= ',F6.2,' SECS)')
      WRITE(6,6041)
 6041 FORMAT(' # IN')
      WRITE(6,6040) TOTIN
      WRITE(6,6042)
 6042 FORMAT('+',30X,'# OUT')
      WRITE(6,6060) TOTOUT
 6060 FORMAT('+',48X,I6)
      WRITE(6,6043)
 6043 FORMAT(' # NS/R')
      WRITE(6,6040) TOTNSR
      WRITE(6,6061)
 6061 FORMAT('+',30X,'# TSO')
      WRITE(6,6060) TOTTSO
      WRITE(6,6063)
 6063 FORMAT(' # INITS')
      WRITE(6,6040) TOTINT
      WRITE(6,6020)
 6040 FORMAT('+',18X,I6)
      WRITE(6,6040) TOTSTP
      WRITE(6,6022)
      WRITE(6,6040) TOTSRB
      WRITE(6,6024)
      WRITE(6,6040) TOTWAT
      WRITE(6,6034)
      WRITE(6,6040) TOTSRV
      AVRIN=AVRIN+TOTIN
      AVROUT=AVROUT+TOTOUT
      AVRNSR=AVRNSR+TOTNSR
      AVRTSO=AVRTSO+TOTTSO
      AVRINT=AVRINT+TOTINT
      IF(RINT.EQ.0.) GOTO 115
      RSTP=FLOAT(TOTSTP)/(RINT*1000.)
      RSRB=FLOAT(TOTSRB)/(RINT*1000.)
      RWAIT=FLOAT(TOTWAT)/RINT
      RSRV=FLOAT(TOTSRV)/RINT
C
C   INCREMENT AVERAGE COUNTERS
C
      AVRSTP=AVRSTP+TOTSTP/1000.
      AVRSRB=AVRSRB+TOTSRB/1000.
      AVRWAT=AVRWAT+TOTWAT
      AVRSRV=AVRSRV+TOTSRV
      WRITE(6,6044)
 6044 FORMAT(' STEP TIME/SEC')
      WRITE(6,6045) RSTP
 6045 FORMAT('+',18X,F6.4)
      WRITE(6,6046)
 6046 FORMAT(' SRB TIME/SEC')
      WRITE(6,6045) RSRB
      WRITE(6,6047)
 6047 FORMAT(' # WAITS/SEC')
      WRITE(6,6048) RWAIT
 6048 FORMAT('+',18X,F6.1)
      TOTWAT=0
      TOTSRV=0
      TOTIN=0
      TOTOUT=0
      TOTNSR=0
      TOTINT=0
      TOTTSO=0
  110 CONTINUE
      IF(IFLAG.GT.0) GOTO 999
      ICT=0
      TTIME=TIME
      GOTO 105
  999 CONTINUE
      IF(FIRST) GOTO 99
C
C   WRITE OUT AVERAGES
C
      AVRIN=AVRIN/NCALLS
      AVROUT=AVROUT/NCALLS
      AVRNSR=AVRNSR/NCALLS
      AVRINT=AVRINT/NCALLS
      AVRTSO=AVRTSO/NCALLS
      RINT=FLOAT(LSTIM-IFSTIM)/100.
      IF(RINT.LT.0.) RINT=RINT+86400.
      AVRSTP=AVRSTP/RINT
      AVRSRB=AVRSRB/RINT
      AVRWAT=AVRWAT/RINT
      AVRSRV=AVRSRV/RINT
      WRITE(6,6050)
 6050 FORMAT('1SNAPSHOT AVERAGES',/,1X)
 6062 FORMAT('+',48X,F6.1)
      WRITE(6,6041)
      WRITE(6,6048) AVRIN
      WRITE(6,6042)
      WRITE(6,6062) AVROUT
      WRITE(6,6043)
      WRITE(6,6048) AVRNSR
      WRITE(6,6061)
      WRITE(6,6062) AVRTSO
      WRITE(6,6063)
      WRITE(6,6048) AVRINT
      WRITE(6,6044)
      WRITE(6,6045) AVRSTP
      WRITE(6,6046)
      WRITE(6,6045) AVRSRB
      WRITE(6,6047)
      WRITE(6,6048) AVRWAT
      WRITE(6,6049)
      WRITE(6,6048) AVRSRV
   99 CONTINUE
      RETURN
      END
      SUBROUTINE TIME(NAME,DATE)
      COMMON/OPTION/ISTRM,GRAPH,LIST
      LOGICAL GRAPH,LIST
      REAL*8 DATE
      DIMENSION IDATA(2)
      DIMENSION X(101),Y(101)
      EQUIVALENCE(IDATA(2),TNEW)
      DATA LENGTH/2/
C   ***********************************
C
C   ROUTINE PERFORMS ANALYSIS OF CALLING FREQUENCY
C
C   ***********************************
      NPTS=0
      IFLAG=-1
      CALL MONRD(NAME,LENGTH,IDATA,IFLAG)
      IF(IFLAG.GT.0) GOTO 20
      IFLAG=0
      TOLD=-1.
      TBAR=0.
      TBAR2=0.
   10 CONTINUE
C
C   COMPUTE MEAN & S.D. OF CALLING INTERVAL
C
      CALL MONRD(NAME,LENGTH,IDATA,IFLAG)
      IF(IFLAG.GT.0) GOTO 20
      IF(TOLD.LT.0.) GOTO 15
      TBAR=(TNEW-TOLD)+TBAR
      TBAR2=(TNEW-TOLD)*(TNEW-TOLD)+TBAR2
      NPTS=NPTS+1
   15 CONTINUE
      TOLD=TNEW
      GOTO 10
   20 CONTINUE
      IF(NPTS.LE.0) GOTO 150
      TBAR=TBAR/NPTS
      TBAR2=TBAR2/NPTS
      TBAR2=TBAR2-TBAR*TBAR
      TBAR2=SQRT(ABS(TBAR2))
C
C   WRITE OUT MEAN,S.D. & # POINTS
C
      WRITE(6,6000) NAME
 6000 FORMAT(1X,/,1X,A4)
      WRITE(6,6005) TBAR
 6005 FORMAT(' MEAN SAMPLE PERIOD= ',F10.7)
      WRITE(6,6015) TBAR2
 6015 FORMAT(' R.M.S. STANDARD DEVIATION= ',F10.7)
      WRITE(6,6010) NPTS
 6010 FORMAT(' NO OF POINTS= ',I5)
C
C   RETURN IF GRAPHICS NOT WANTED
C
      IF(.NOT.GRAPH) GOTO 150
      IFLAG=-1
      CALL MONRD(NAME,LENGTH,IDATA,IFLAG)
      IF(IFLAG.GT.0) GOTO 40
      IFLAG=0
      TOLD=-1.
C
C   SET UP FOR HISTOGRAM
C
      XMIN=TBAR-3.*TBAR2
      XMAX=TBAR+3.*TBAR2
      IF(XMAX.GT.(5.*TBAR)) XMAX=5.*TBAR
      IF(XMIN.LT.0.) XMIN=0.
      NBINS=NPTS/10
      IF(NBINS.GT.0) GOTO 25
C
C   NOT ENOUGH DATA POINTS
C
      WRITE(6,6020)
 6020 FORMAT(' INSUFFICIENT DATA FOR GRAPHICAL ANALYSIS')
      GOTO 30
   25 CONTINUE
C
C   SET # BINS (<100)
C
      IF(NBINS.GT.100) NBINS=100
      XSTEP=(XMAX-XMIN)/NBINS
      IF((TBAR-XMIN)/XSTEP.GT.3.) GOTO 102
      XSTEP=(TBAR-XMIN)/3.
      NBINS=(XMAX-XMIN)/XSTEP+1
      IF(NBINS.GT.100) NBINS=100
      XSTEP=(XMAX-XMIN)/NBINS
  102 CONTINUE
C
C   ZERO BIN COUNTERS
C
      DO 101 I=1,101
      Y(I)=0.
  101 CONTINUE
  100 CONTINUE
      CALL MONRD(NAME,LENGTH,IDATA,IFLAG)
      IF(IFLAG.GT.0) GOTO 40
      IF(TOLD.LT.0.) GOTO 35
      TOLD=TNEW-TOLD
      DO 110 I=1,NBINS
      TEST=XMIN+I*XSTEP
      IF(TOLD.GT.TEST) GOTO 110
      Y(I)=Y(I)+1.
      GOTO 35
  110 CONTINUE
C
C   DATA POINT > MAX BIN
C
      WRITE(6,6050) TOLD,TEST
 6050 FORMAT(' DATA POINT ',F7.4,' OUTSIDE LIMIT ',F7.4)
      Y(NBINS+1)=Y(NBINS+1)+1.
   35 CONTINUE
      TOLD=TNEW
      GOTO 100
   40 CONTINUE
      NBINS=NBINS+1
C
C   FIND MAX AND MIN INTERVALS
C
      DO 45 I=1,NBINS
      X(I)=XMIN+(I-0.5)*XSTEP
      Y(I)=Y(I)/NPTS
   45 CONTINUE
      XMAX=(I+0.5)*XSTEP+XMIN
C
C   FIND MAX & MIN #'S IN BINS
C
      YMIN=Y(1)
      YMAX=Y(1)
      DO 46 I=1,NBINS
      IF(YMIN.GT.Y(I)) YMIN=Y(I)
      IF(YMAX.LT.Y(I)) YMAX=Y(I)
   46 CONTINUE
      IF(YMAX.LT.1.) YMAX=1.
      IF(YMIN.GT.0.) YMIN=0.
C
C   PLOT HISTOGRAM OF INTERVAL/FRACTION OF CALLS
C
      CALL CSPACE(0.,1.,-.4,1.)
      CALL MAP(XMIN,XMAX,YMIN,YMAX)
      CALL HISTGM(XMIN,YMIN,XSTEP,Y,1,NBINS)
      CALL AXES
C
C   ANNOTATE X-AXIS
C
      CALL POSITN(XMIN,YMIN)
      CALL LINEFD(2)
      CALL SPACE(5)
      CALL TYPECS('INTERVAL BETWEEN MONITOR CALLS (SECS)',37)
C
C   ANNOTATE Y-AXIS
C
      CALL POSITN(XMIN,YMIN)
      CALL CTRORI(1.)
      CALL HLINFD(-5)
      CALL SPACE(14)
      CALL TYPECS('FRACTION OF CALLS',17)
      CALL CTRORI(0.)
C
C   INSERT DATE & TITLE
C
      CALL POSITN(XMIN,YMAX)
      CALL LINEFD(-1)
      CALL SPACE(12)
      CALL TYPECS('MONITOR RUN ON ',15)
      CALL TYPECS(DATE,8)
C
C   INSERT NAME,MEAN,& S.D.
C
      CALL POSITN(XMIN,YMIN)
      CALL LINEFD(4)
      CALL CRLNFD
      CALL SPACE(5)
      CALL TYPECS('MONITOR = ',10)
      CALL TYPECS(NAME,4)
      CALL CRLNFD
      CALL SPACE(5)
      CALL TYPECS('# OF POINTS = ',14)
      CALL TYPENI(NPTS)
      CALL CRLNFD
      CALL SPACE(5)
      CALL TYPECS('MEAN = ',7)
      CALL TYPENF(TBAR,3)
      CALL CRLNFD
      CALL SPACE(5)
      CALL TYPECS('S.D. = ',7)
      CALL TYPENF(TBAR2,3)
C
C   RESET PLOTTING
C
      CALL FRAME
      CALL CSPACE(0.,1.,0.,1.)
   30 CONTINUE
  150 CONTINUE
      RETURN
      END
      SUBROUTINE MRD(ICT,IBUF,IFL)
      COMMON/OPTION/ISTRM
      DIMENSION IBUF(1000)
      IFL=0
      READ(ISTRM,1000,END=10) IBUF
 1000 FORMAT(4(250A4))
      ICT=1
      RETURN
   10 CONTINUE
      IFL=1
      RETURN
      END
      SUBROUTINE MONRD(NAME,LENGTH,IDATA,IFLAG)
      COMMON/OPTION/ISTRM,IX(4),TRACE
      LOGICAL TRACE
      DIMENSION IBUF(1000),IDATA(LENGTH)
      DATA ICT/1/
      DATA IEND/'END '/
      DATA ITRCT/0/
C
C   IFLAG.LT.0 START OF READING
C   IFLAG.EQ.0 NORMAL
C   IFLAG.EQ.1 EOF
C   IFLAG.GT.1 ERROR RETURN
C
C   LENGTH IS THE MAX LENGTH OF DATA
C
      IF(IFLAG.GE.0) GOTO 10
      REWIND ISTRM
      CALL MRD(ICT,IBUF,IFL)
      IF(IFL.GT.0) GOTO 900
      RETURN
   10 CONTINUE
      IF(ICT.GT.1000) CALL MRD(ICT,IBUF,IFL)
      IF(IFL.GT.0) GOTO 900
      IF(NAME.EQ.IBUF(ICT)) GOTO 20
C
C   SKIP THIS RECORD
C
      IF(IEND.EQ.IBUF(ICT)) GOTO 900
      ICT=ICT+1
      IF(ICT.GT.1000) CALL MRD(ICT,IBUF,IFL)
      IF(IFL.GT.0) GOTO 900
      ILEN=IBUF(ICT)
      ICT=ICT+1
      IF(ILEN.LE.0) GOTO 10
      DO 15 I=1,ILEN
      IF(ICT.GT.1000) CALL MRD(ICT,IBUF,IFL)
      IF(IFL.GT.0) GOTO 900
      ICT=ICT+1
   15 CONTINUE
      GOTO 10
C
C   THIS RECORD WANTED
C
   20 CONTINUE
      ICT=ICT+1
      IF(ICT.GT.1000) CALL MRD(ICT,IBUF,IFL)
      IF(IFL.GT.0) GOTO 900
      IF(LENGTH.LT.IBUF(ICT)) GOTO 999
      ILEN=IBUF(ICT)
      ICT=ICT+1
      IF(LENGTH.LE.0) GOTO 30
      DO 25 I=1,ILEN
      IF(ICT.GT.1000) CALL MRD(ICT,IBUF,IFL)
      IF(IFL.GT.0) GOTO 900
      IDATA(I)=IBUF(ICT)
      ICT=ICT+1
   25 CONTINUE
   30 CONTINUE
C
C   SET MAXIMUM LIMIT OF 1000 RECORDS FOR TRACE
C
      IF(TRACE) ITRCT=ITRCT+1
      IF(ITRCT.GT.1000) TRACE=.FALSE.
      IF(.NOT.TRACE) ITRCT=0
      IF(TRACE) WRITE(6,6010) NAME,ILEN,(IDATA(I),I=1,ILEN)
 6010 FORMAT(1X,A4,1X,I3,10(1X,Z8,1X))
      IFLAG=0
      RETURN
C
C   EOF RETURN
C
  900 CONTINUE
      IFLAG=1
      RETURN
C
C   ERROR RETURN
C
  999 CONTINUE
      IFLAG=2
      WRITE(6,6000) LENGTH,IBUF(ICT)
 6000 FORMAT(' INCORRECT LENGTH IN RECORD',2I5)
      RETURN
      END
//S2A EXEC TESTLINK,SO=3,COND=EVEN,OPT=',NCAL,LET,AC=1',NAME=MONRD,
// LIB='MVS.APEMAN'
//STEP03 EXEC ASMBLR,SO=3,COND=EVEN
ZA06AS   CSECT
*###### 12/04/73 LAST LIBRARY UPDATE
         BC    15,12(15)     BRANCH AROUND IDENTIFIER
         DC    X'06'
         DC    CL7'ZA06AS '
         MVI   FLAG-ZA06AS(15),X'00'   FLAG=0 FOR NUMERIC FIELD
         B     MENTRY-ZA06AS(15)
         ENTRY ZA06BS
ZA06BS   BC    15,12(15)     BRANCH AROUND IDENTIFIER
         DC    X'06'
         DC    CL7'ZA06BS '
         MVI   FLAG-ZA06BS(15),X'01'   FLAG=1 FOR TEXT
         B     MENTRY-ZA06BS(15)
         ENTRY ZA06CS
ZA06CS   BC    15,12(15)     BRANCH AROUND IDENTIFIER
         DC    X'06'
         DC    CL7'ZA06CS '
         MVI   FLAG-ZA06CS(15),X'02'   FLAG=2 FOR KEYWORD ONLY
*
*******************************************************************
*
*         THIS ROUTINE CAN BE USED TO EXTRACT INFORMATION FROM
*      THE PARMLIST GIVEN ON AN EXEC CARD. THERE ARE THREE ENTRY POINTS
*      POINTS.
*      1/      ZA06AS(N,KEY,M,VALUE)
*         THIS WILL RETURN THE INTEGER VALUE OF ENTRIES IN THE
*      PARMLIST OF THE FORM ....,KEYWORD=VALUE,.... N AND KEY ARE
*      SET BY THE USER. KEY WILL CONTAIN THE KEYWORD ( INCLUDING
*      THE '=' SIGN ) AND N WILL GIVE THE NUMBER OF CHARACTERS
*      IN KEY.
*         THE ROUTINE WILL RETURN IN M THE NUMBER OF DIGITS IN
*      THE VALUE ( NOT INCLUDING THE SIGN ) AND IF M > 0 THE
*      BINARY VALUE IN VALUE.
*      2/      ZA06BS(N,KEY,M,TEXT)
*         THIS WILL RETURN THE TEXT VALUE OF AN ENTRY OF THE FORM
*      ....,KEYWORD=TEXT,.... N AND KEY ARE AS FOR ZA06AS.
*         THE ROUTINE WILL RETURN IN M THE NUMBER OF CHARACTERS
*      IN THE TEXT VALUE AND IF M > 0 TEXT WILL CONTAIN THE TEXT
*      VALUE.
*      3/      ZA06CS(N,KEY,L)
*         THIS WILL INDICATE THE PRESENCE OF AN ENTRY OF THE FORM
*      ....,KEYWORD,.... N AND KEY ARE AS ZA06AS EXCEPT THAT
*      IN GENERAL KEY WILL CONTAIN NO '=' CHARACTER. IF THE
*      KEYWORD IN KEY IS FOUND IN THE PARMLIST THE 3RD ARGUMENT
*      L IS SET TO 1 (.TRUE.) AND IF IT IS NOT FOUND IT IS SET TO
*      ZERO (.FALSE.).
*         ONLY REGISTERS 14,15,0-7 ARE SAVED AND RESTORED. THUS
*      8-13 ARE UNALTERED.
*                                    JANUARY 1970
*
*******************************************************************
*
MENTRY   STM   14,7,12(13)   SAVE REGISTERS
         LM    3,6,0(1)      PICK UP ARGUMENTS
         BALR  7,0           ESTABILISH .....
         L     1,PARMAD      YES: PUT IT INTO REGISTER 1
         B     BR10          GO AND SEARCH PARMLIST
*
*      GET PARMLIST.
*
BR9      L     1,16          CVT
         L     1,0(1)        TCB POINTERS
         L     1,4(1)        CURRENT TCB
         L     1,112(1)      FIRST SAVE AREA
         L     15,16(1)        POINT AT ENTRY POINT
         CLC   5(8,15),LOADER   IS IT THE LOADER ?
         BNE   BR11            NO: USE FIRST SAVE AREA
         L     1,8(1)          YES: USE LOADERS SAVE AREA
BR11     L     1,24(1)       POINTER TO PARMLIST
         L     1,0(1)        PARMLIST
         ST    1,PARMAD      SAVE ADDRESS
*
*      INITIALIZE AND SET UP FOR SEARCH.
*
BR10     SR    2,2
         CLC   0(2,1),HZERO  IS PARMLIST EMPTY ?
         BE    BR5           YES: FINISH THEN
         MVI   FLAG2,X'00'   PUT FOUND FLAG OFF
         BCTR  3,0           MODIFY .......
         STC   3,KEYTEST+1   .... COMPARE INSTRUCTION .....
         STC   3,INCR+3      ... AND INCREMENT INSTRUCTION
         LA    3,1(3)        RESTORE TO PROPER VALUE
         LH    0,0(1)        PICK UP PARMLIST LENGTH
         LA    1,2(1)        POINT AT PARMLIST PROPER
         AR    0,1           POINT AT END OF PARMLIST
         BCTR  1,0           REDUCE TO ENTER LOOP
         B     KEYTEST       GO AND TEST FOR KEYWORD
*
*      KEYWORD SEARCH
*
COMMA    CLI   FLAG2,X'00'   HAS KEYWORD BEEN FOUND ?
         BNE   ENDSRCH       YES: GO AND FINISH OFF
KEYTEST  CLC   0(0,4),1(1)   IS IT THE KEYWORD ?
         BNE   NXTCOMA       NO: GO AND LOOK FOR NEXT COMMA
         LA    1,1(1)        YES: POINT AT KEYWORD
         ST    1,KEYWORD     SAVE POINTER TO KEYWORD
         MVI   FLAG2,X'FF'   MARK AS FOUND
INCR     LA    1,0(1)        MOVE POINTER TO END OF KEYWORD
         B     NXTCOMA       GO AND LOOK FOR NEXT COMMA
COMATEST CLI   0(1),C','     IS IT A COMMA ?
         BE    COMMA         YES: BRANCH THEN
NXTCOMA  LA    1,1(1)        UPDATE PARMLIST POINTER
         CR    1,0           LOOP TILL .....
         BL    COMATEST      ..... END OF PARMLIST
         CLI   FLAG2,X'00'   HAS KEYWORD BEEN FOUND ?
         BE    BR5           NO: FINISH THEN
*
*      END OF SEARCH
*
ENDSRCH  S     1,KEYWORD     LENGTH OF KEYWORD FIELD
         SR    1,3           LENGTH OF KEYWORD VALUE
         CLI   FLAG,X'02'    DID WE COME .....
         BNE   BR1           .... IN AT ZA06CS ?
         LTR   1,1           YES: ARE THE LENGTHS .....
         BZ    BR7           .... THE SAME ?
         MVI   FLAG2,X'00'   NO: SET NOT FOUND
         L     1,KEYWORD     PICK UP POSITION IN PARMLIST ....
         B     INCR          ... AND GO AND HAVE ANOTHER TRY
BR7      LA    2,1           SET THIRD ARGUMENT TRUE
BR5      ST    2,0(5)        SET THIRD ARGUMENT
         B     FINISH
BR1      LTR   2,1
         BZ    BR5
         L     14,KEYWORD    POINT AT ....
         LA    14,0(14,3)    .... VALUE FIELD
         CLI   FLAG,X'00'    DID WE COME IN .....
         BNE   BR6           .... AT ZA06AS ?
         BCTR  1,0           YES: ONE OFF FOR PACK
         CLI   0(14),C'-'    IS THE NUMBER .....
        BNE    BR2           .... NEGATIVE
         LA    14,1(14)      YES: MOVE POINTER UP ONE
         BCTR  1,0           REDUCE LENGTH AGAIN
         EX    1,PACK        PACK AND CONVERT ......
         CVB   4,BUF         .... VALUE TO BINARY
         LNR   4,4           MAKE VALUE NEGATIVE
         B     BR3
BR2      EX    1,PACK        PACK AND CONVERT .....
         CVB   4,BUF         .... VALUE TO BINARY
BR3      ST    4,0(6)        SET FOURTH ARGUMENT
         LA    2,1(1)        NO. OF DIGITS
         B     BR5           GO AND FINISH OFF
BR6      LR    2,1           LENGTH OF TEXT
         BCTR  1,0           ONE OFF FOR MOVE
         EX    1,MOVE
         ST    2,0(5)        SET THIRD ARGUMENT
*
*      RETURN TO CALLER
*
FINISH   LM    14,7,12(13)   RESTORE REGISTERS
         MVI   12(13),X'FF'  SET TRACE RETURN
         BR    14
*
*      WORK AREA.
*
BUF      DC    D'0'          CVB WORKSPACE
LOADER   DC    C'IEWLCTRL'     USED TO IDENTIFY FAST LOADER
KEYWORD  DC    A(0)          ADDRESS OF KEY WORD IN PARMLIST
PARMAD   DC    A(0)          ADDRESS OF PARMLIST
PACK     PACK  BUF(8),0(0,14)
MOVE     MVC   0(0,6),0(14)
FLAG     DC    X'00'         ENTRY INDICATOR
FLAG2    DC    X'00'         KEYWORD FOUND INDICATOR
FLAG3    DC    X'00'         PARMLIST ALREADY AVAILABLE INDICATOR
HZERO    DC    H'0'
         END
//S3A EXEC TESTLINK,SO=3,COND=EVEN,OPT=',NCAL,LET,AC=1',NAME=ZA06AS,
// LIB='MVS.APEMAN'
  ALIAS ZA06CS
  ALIAS ZA06BS
//STEP04 EXEC ASMBLR,SO=3,COND=EVEN
ZA01AS      CSECT
*###### 27/03/72 LAST LIBRARY UPDATE
*        FUNCTION  ZA01AS(XX)
*                  THIS FUNCTION GIVES THE ELAPSED REAL TIME
*                  BETWEEN CALL OF THE FUNCTION. IT MAINTAINS
*                  AN INTERNAL CLOCK - REFERRED TO IN COMMENTS
*                  AS THE 'TIME OF DAY' ALTHOUGH IT STARTS FROM
*                  ZERO AT THE FIRST CALL - USING THE TIME SVC.
*                  CAN ONLY DEAL WITH TIME DIFFERENCES LESS THAN 3HRS
*                  RESULT IS LEFT AS 8 BYTES IN FL PT REG 0
RBASE       EQU     2
            B     12(15)
            DC    X'6'
            DC    CL6'ZA01AS'
            DC    X'00'
            USING  ZA01AS,RBASE
            STM    14,RBASE,12(13)
            LR      RBASE,15      GET ENTRY POINT ADDRESS
            TIME    TU
*                        GR0 HAS NO OF TIME UNITS
*                        GR1 HAS DATE IN DECIMAL
            TM      FLAGS,FRSTIME      IS THIS THE FIRST TIME ?
            BZ      FIRST      BRANCH IF SO
            CL      0,PREV      COMPARE READING WITH PREVIOUS
            BL      MIDNT       IF LOW, WE'RE JUST PAST MIDNIGHT
DIFF        LR      1,0      COPY TIME READING
            SL      1,PREV      SUBTRACT PREVIOUS READING
            AL      1,TOD      ADD PRESENT TIME OF DAY
            ST      1,TOD       STORE RESULT IN TIME OF DAY
            ST      0,PREV      RECORD READING FOR NEXT TIME
LOADTOD     LD      0,CNV     LOAD 8 BYTES INTO FLPT REG 0
            MD      0,FAC
            LM      14,RBASE,12(13)
            MVI     12(13),X'FF'
            BR      14
FIRST       DS      0H      FIRST ENTRY RECORD READING ONLY
            ST      0,PREV  STORE READING FOR FUTURE USE
            OI      FLAGS,FRSTIME      TURN ON FLAG
            B       LOADTOD
*
MIDNT       L       1,PREV      GET PREVIOUS SETTING
            SL      1,TWTY4     MINUS 24HR SETTING
            ST      1,PREV       RESET PREV
            B       DIFF
FLAGS       DC      X'00'      FLAGS
FRSTIME     EQU     X'80'      FIRST TIME FLAG
            DS      0D
CNV         DC      AL1(64+14),AL3(0)      TOP HALF OF UNORMALISED TOD
TOD         DC      A(0)      TIME OF DAY
FAC         DC      D'.000026'
TUIN24HR    DC      FL8'3323076923'  TIMER UNITS IN 24HRS
*                         VALUE EXCEEDS 2**31 AND MUST THEREFORE
*                        BE STORED IN AN 8 BYTE FIELD EVEN
*                        THOUGH ONLY LOWER 4 BYTES ARE FILLED.
PREV        EQU     TUIN24HR  PREVIOUS SETTING
TWTY4       EQU     TUIN24HR+4         24HR SETTING
            END
//S4A EXEC TESTLINK,SO=3,COND=EVEN,OPT=',NCAL,LET,AC=1',NAME=ZA01AS,
// LIB='MVS.APEMAN'
//STEP05 EXEC ASMBLR,SO=3,COND=EVEN
ZA09AS   CSECT
         BC    15,12(15)
         DC    X'06'
         DC    CL7'ZA09AS'
*        SUBROUTINE ZA09AS(DMY)
*        GIVES DATE AS EIGHT CHARACTERS
*           * * * DD/MM/YY * * *
*        IN THE * * * DOUBLE LENGTH * * * ARGUMENT DMY
         STM   14,6,12(13)
         L     6,0(0,1)
         TIME  DEC
         BALR  15,0
         USING *,15
         ST    1,DATE                  DATE IN PACKED DECIMAL
         N     1,MSK1                  REMOVE YEAR NUMBER
         ST    1,WS+4
         CVB   1,WS                    CONVERT DAY NO TO BINARY IN GR1
         SR    3,3
         IC    3,DATE+1                LOAD PACKED YEAR NO.
         LR    4,3
         SRA   3,4
         LA    2,10
         MR    2,2
         N     4,MSK2
         AR    3,4                     YEAR NO IN BINARY IN GR3
         LR    2,3
         SR    4,4
         N     2,MSK3                  LEAP YEAR TEST
         BC    4,NLEAP
         LA    4,1
NLEAP    A     4,DAYS28                ADJUST DAYS IN FEBRUARY
         ST    4,DAYSF
         SR    2,2
         LA    4,4
         LA    5,44
GETMON   S     1,DAYS(2)
         BC    12,NMON
         BXLE  2,4,GETMON
         SR    2,4
NMON     A     1,DAYS(2)               DAY IN BINARY
         CVD   1,WS                    CONVERT TO DECIMAL
         L     1,WS+4                  FIX SIGN TO 1111
         O     1,MSK2
         ST    1,WS+4
         UNPK  CC(2),WS+6(2)           UNPACK DAY NO
         LH    1,CC
         STH   1,0(0,6)                STORE DAY CHARACTERS
         AR    2,4                     4XMONTH NO
         SRL   2,2
         CVD   2,WS
         L     2,WS+4
         O     2,MSK2
         ST    2,WS+4
         UNPK  CC(2),WS+6(2)           UNPACK MONTH NO
         LH    2,CC
         STC   2,4(0,6)                STORE MONTH NUMBER CHARACTER
         SRL   2,8                     BY CHARACTER TO AVOID BOUNDARY
         STC   2,3(0,6)                ALIGNMENT DIFFICULTY
         CVD   3,WS
         L     3,WS+4
         O     3,MSK2
         ST    3,WS+4
         UNPK  CC(2),WS+6(2)
         LH    3,CC
         STH   3,6(0,6)
         IC    2,SLASH
         STC   2,2(0,6)
         STC   2,5(0,6)
         LM    14,6,12(13)
         MVI   12(13),X'FF'
         BR    14
         DS    0D
WS       DC    2F'0'
DATE     DC    F'0'
MSK1     DC    X'0000FFFF'
MSK2     DC    X'0000000F'
MSK3     DC    X'00000003'
DAYS28   DC    F'28'
DAYS     DC    F'31'
DAYSF    DC    F'28,31,30,31,30,31,31,30,31,30,31'
CC       DC    CL2'  '
SLASH    DC    CL1'/'
         END
//S5A EXEC TESTLINK,SO=3,COND=EVEN,OPT=',NCAL,LET,AC=1',NAME=ZA09AS,
// LIB='MVS.APEMAN'
//STEP06 EXEC ASMBLR,SO=3,COND=EVEN
ZR02AS   CSECT
*###### 12/04/73 LAST LIBRARY UPDATE
  SPACE 2
******** **************************************************************
*   *
*   *    THIS ROUTINE IS DESIGNED TO BE INCORPORATED IN A MODULE;
*   *    WHEN CALLED IT WILL PROVIDE:
*   *
*   *    1. (A)  THE ENTRY POINT OF THE MODULE;
*   *       (B)  THE LENGTH OF THE PARM FIELD;
*   *       (C)  THE CONTENTS OF THE PARM FIELD.  THE NUMBER OF BYTES
*   *            RETURNED IS A MULTIPLE OF FOUR;  PADDING WITH BLANKS
*   *            IS CARRIED OUT, IF NECESSARY.
*   *
*   *    2. FOR (A) AND (B) FOUR-BYTE INTEGERS MUST BE PROVIDED,
*   *       FOR (C) AN ARRAY THAT HAS A LENGTH THAT IS A MULTIPLE
*   *       OF FOUR.   (A) IS ALWAYS GIVEN, (B) AND (C) ARE OPTIONAL
*   *      AND WILL BE RETURNED ONLY IF THE ARGUMENT LIST IS OF THE
*   *       APPROPRIATE LENGTH.
*   *
******** **************************************************************
  EJECT
 SPACE
         SPACE
         BC    15,X1-*(0,15)         BRANCH ROUND IDENTIFIER
         DC    AL1(E-*-1)         L'IDENTIFIER
         DC    C'ZR02AS'          IDENTIFIER
E        EQU   *
X1       DC    0H'0'
         BALR  15,0               LOAD BASE REGISTER
         SPACE
         USING *,15
         STM   14,6,12(13)        SAVE REGISTERS
         LM    4,6,0(1)           GET FTN ARGUMENTS
   SPACE 3
*
****     GET ENTRY POINT
*
         L     2,16(0,0)          CVT
         LR    3,2                 SAVE CVT
         L     2,0(0,2)           CVTTCBP
         L     2,4(0,2)           TCB
         TM    116(3),X'10'        IS IT AN MVT SYSTEM ?
         BZ    MFT
         L     3,0(2)              REQUEST PLOCK
         L     3,12(3)             CDE
         L     3,16(3)             ENTRY POINT
         B     MVT
MFT      L     3,0(0,2)           REQUEST BLOCK
         L     3,12(0,3)          ENTRY POINT
MVT      LA    3,0(0,3)           CLEAN UP HIGH BYTE
         ST    3,0(0,4)           GIVE BACK AS 1ST FTN ARGUMENT
         SPACE 2
         TM    0(1),X'80'         TEST FOR END FORTRAN ARGUMENT LIST
         BC    1,EXIT
         SPACE 2
  EJECT
*
****     GET PARM FIELD
*
         L     3,112(0,2)         ADDRESS OF 1ST SAVE AREA
         L     2,16(3)            POINT AT ENTRY POINT
         CLC   5(8,2),LOADER      IS IT THE FAST LOADER ?
         BNE   NOTLOADR           NO: USE FIRST SAVE AREA THEN
         L     3,8(3)             YES: USE NEXT SAVE AREA DOWN
NOTLOADR L     3,24(0,3)          POINTER TO PARM FIELD (ORIG. REG 1)
         L     3,0(0,3)           A(PARM FIELD)
         LH    2,0(0,3)           L'PARM FIELD
         ST    2,0(0,5)           GIVE BACK AS 2ND FTN ARGUMENT
         TM    4(1),X'80'         TEST FOR END FORTRAN ARGUMENT LIST
         BC    1,EXIT
         LR    4,2                SAVE L'PARM FIELD
         SH    2,HW1              DECREMENT FOR EX & EXISTENCE TEST
         BC    4,EXIT             BRANCH IF NON-EXISTENT
         LA    4,3(0,4)           COMPUTE SMALLEST MULTIPLE  --
         SRL   4,2(0)             --  OF 4 THAT  --
         SLL   4,2(0)             --  IS 'GE' L'PARM FIELD
         SH    4,HW2              DECREMENT FOR EXECUTE
         MVI   0(6),C' '          BLANK OUT FIRST BYTE  --
         EX    4,BLANPARM         --  THEN THE REST
         EX    2,MVPARM           MOVE PARM FIELD TO 3RD FTN ARG.
         SPACE 2
EXIT     EQU   *
         LM    14,6,12(13)        RESTORE REGISTERS
         MVI   12(13),255         FLAG SAVE AREA
         SR    15,15              SET RETURN CODE
         BCR   15,14              RETURN
  SPACE 2
BLANPARM MVC   1(1,6),0(6)        USED TO BLANK ARRAY USED FOR P. FIELD
MVPARM   MVC   0(1,6),2(3)        USED TO MOVE PARM FIELD
HW1      DC    H'1'
HW2      DC    H'2'
LOADER   DC    C'IEWLCTRL'
         END
//S6A EXEC TESTLINK,SO=3,COND=EVEN,OPT=',NCAL,LET,AC=1',NAME=ZR02AS,
// LIB='MVS.APEMAN'
//STEP07 EXEC ASMBLR,SO=3,COND=EVEN
ITIME    START
         STM   14,2,12(13)
         BALR  2,0
         USING *,2
         TIME  DEC
         LM    14,15,12(13)
         LM    1,2,24(13)
         BR    14
*
         LTORG
         END
//S7A EXEC TESTLINK,SO=3,LIB='MVS.APEMAN',OPT=',NCAL,LET,AC=1',
// COND=EVEN,NAME=ITIME
//STEP08 EXEC ASMBLR,SO=3,COND=EVEN
STRTIM   START
*
*   LINKAGE IS STRTIM(IND,TIME)
*   IND=0 UNITS OF THE TIMER
*   IND.NE.0 HUNDREDS OF A SECOND
*
RB2      EQU   2
RW3      EQU   3
RW4      EQU   4
RW5      EQU   5
*
         STM   14,12,12(13)
         BALR  RB2,0
         USING *,RB2
         LR    RW3,13
         ST    13,SAVE+4
         LA    13,SAVE
         ST    13,8(RW3)
*
         LM    RW3,RW4,0(1)
         L     RW3,0(RW3)
         SR    RW5,RW5
         CR    RW3,RW5
         BNE   BINTIM
         TIME  TU
        B     RET
BINTIM   EQU   *
         TIME  BIN
//S8A EXEC TESTLINK,SO=3,LIB='MVS.APEMAN',OPT=',NCAL,LET,AC=1',
// COND=EVEN,NAME=STRTIM
//STEP09 EXEC ASMBLR,SO=3,COND=EVEN
INPUT    START
*
*   LINKAGE IS INPUT(NAME,BUFFER,FLAG)
*   NAME IS THE DDNAME REQUIRED
*   BUFFER IS AN 80 BYTE AREA
*   FLAG=0 FOR NORMAL RETURN
*   FLAG=1 FOR EOF RETURN
*
         ENTRY EODEX
      ENTRY INDCB
*
RW3      EQU   3
RW4      EQU   4
RW5      EQU   5
RB8      EQU   8
RB9      EQU   9
*
         SAVE  (14,12)
         BALR  RB9,0
      USING *,RB9                      ESTABLISH ADDRESSABLIITY
ENTER    EQU   *
         ST    13,SAVE+4               CHAIN SAVE AREAS
         LR    RW3,13
         LA    13,SAVE
         ST    13,8(RW3)
*
*   PICK UP ARGUMENTS
*
         LM    RW3,RW5,0(1)
         ST    RW5,ADFLAG
         ST    RW4,ADBUF
         CLC   DDNAME(8),0(RW3)
         BNE   NEWDCB                  BRANCH IF ANOTHER DDCARD
OK       EQU   *
         TM    INDCB+48,X'10'
         BO    OPENED                  TEST FOR OPEN
         OPEN  (INDCB,INPUT)
OPENED   EQU   *
         L     RW5,ADBUF
         GET   INDCB,(RW5)
         LA    RW3,0
         L     RW4,ADFLAG
RETURN   ST    RW3,0(RW4)              SET RETURN CODE
         L     13,4(13)
         RETURN (14,12)
*
NEWDCB   EQU   *
         TM    INDCB+48,X'10'
         BNO   NOPEN
         CLOSE INDCB
NOPEN    EQU   *
         MVC   DDNAME(8),0(RW3)
         MVC   INDCB+40(8),DDNAME
         B     OK
*
*   EOF
*
EODEX    EQU   *
         BALR  RB8,0
         USING *,RB8
         L     RB9,ADENTER
         B     EOD1
ADENTER  DC    A(ENTER)
EOD1     EQU   *
         DROP  RB8
         LA    13,SAVE
         CLOSE INDCB
         L     RW4,ADFLAG
         LA    RW3,1
         B     RETURN
*
SAVE     DS    18F
DDNAME   DC    C'DDDDDDDD'
ADFLAG   DS    F
ADBUF    DS    F
INDCB    DCB   DSORG=PS,MACRF=GM,LRECL=80,DDNAME=DDDDDDDD,             X
               EODAD=EODEX,BLKSIZE=80,RECFM=F
         END
//S9A EXEC TESTLINK,SO=3,LIB='MVS.APEMAN',OPT=',NCAL,LET,AC=1',
// COND=EVEN,NAME=INPUT
//STEP10 EXEC ASMBLR,SO=3,COND=EVEN
MONTIM   START
*
*   LINKAGE IS MONTIM(IND,TIME)
*   IND=0 UNITS OF THE TIMER
*   IND.NE.0 HUNDREDS OF A SECOND
*
RB2      EQU   2
RW3      EQU   3
RW4      EQU   4
RA5      EQU   5
*
         STM   14,12,12(13)
         BALR  RB2,0
         USING *,RB2
         LR    RW3,13
         ST    13,SAVE+4
         LA    13,SAVE
         ST    13,8(RW3)
         LM    RW3,RW4,0(1)
         L     RW3,0(RW3)
         L     RW4,0(RW4)
         ST    RW4,TIME
         SR    RW4,RW4
         CR    RW3,RW4
         BNE   BINTIM
         STIMER WAIT,TUINTVL=TIME
         B     RET
BINTIM   EQU   *
         STIMER WAIT,BINTVL=TIME
RET      EQU   *
         L     13,4(13)
         LM    14,12,12(13)
         BR    14
SAVE     DS    18F
DUM      DS    0D
TIME     DS    F
*
         END
//S10A EXEC TESTLINK,SO=3,LIB='MVS.APEMAN',OPT=',NCAL,LET,AC=1',
// COND=EVEN,NAME=MONTIM
//STEP11 EXEC ASMBLR,SO=3,COND=EVEN
MONRUN   START
*
*   LINKAGE IS MONRUN(NO,INPUT,MONRT,TIME)
*
RB2      EQU   2
RW3      EQU   3
RW4      EQU   4
RW5      EQU   5
RW6      EQU   6
*
         STM   14,12,12(13)
         BALR  RB2,0
         USING *,RB2
         LR    RW3,13
         ST    13,SAVE+4
          LA    13,SAVE
         ST    13,8(RW3)
*
         LM    RW3,RW6,0(1)            LOAD PARAMETERS
         L     RW3,0(RW3)
         ST    RW4,ADINPUT
         ST    RW5,ADMONRT
         ST    RW6,ADTIME
         SLL   RW3,2
         L     RW4,=V(MONAD)
         AR    RW4,RW3
         L     15,0(RW4)
         LA    1,ADINPUT
         BALR  14,15
*
         L     13,4(13)
         LM    14,12,12(13)
         BR    14
ADINPUT  DS    F
ADMONRT  DS    F
ADTIME   DS    F
SAVE     DS    18F
         END
//S11A EXEC TESTLINK,SO=3,LIB='MVS.APEMAN',OPT=',NCAL,LET,AC=1',
// COND=EVEN,NAME=MONRUN
//STEP12 EXEC ASMBLR,SO=3,COND=EVEN
MONLD    START
*
*   LINKAGE IS MONLD(NAME,NO)
*
RB2      EQU   2
RW3      EQU   3
RW4      EQU   4
RA5      EQU   5
*
         STM   14,12,12(13)
         BALR  RB2,0
         USING *,RB2
         LR    RW3,13
         ST    13,SAVE+4
         LA    13,SAVE
         ST    13,8(RW3)
*
         L     RA5,=V(MONAD)
         LM    RW3,RW4,0(1)
         L     RW3,0(RW3)
         L     RW4,0(RW4)
         ST    RW3,EPNAME
         LOAD  EPLOC=EPNAME
         SLL   RW4,2
         AR    RA5,RW4
         ST    0,0(RA5)
         L     13,4(13)
         LM    14,12,12(13)
         BR    14
*
SAVE     DS    18F
EPNAME   DC    C'        '
*
         END
//S12A EXEC TESTLINK,SO=3,LIB='MVS.APEMAN',OPT=',NCAL,LET,AC=1',
// COND=EVEN,NAME=MONLD
//*ARNIE3 JOB 526TSO000S0003,TEC,CLASS=D,MSGCLASS=3,NOTIFY=ARNIE,
//* PRTY=11
//STEP13 EXEC ASMBLR,SO=3,COND=EVEN
MONAD    CSECT
ADDRESS  DS    27F
      DC C' '
      END
//S13A EXEC TESTLINK,SO=3,LIB='MVS.APEMAN',OPT=',NCAL,LET,AC=1',
// COND=EVEN,NAME=MONAD
//STEP14 EXEC FORTRAN,SO=3,COND=EVEN
      REAL*8 UNITS/'SECS    '/,MILLI/'MILLI   '/,MINS/'MINS    '/
      REAL*8 DATE
      INTEGER NAME2/'DATE'/
      LOGICAL LFLAG
      INTEGER*2 IEQ/'= '/,IALPH(26),IT,IN/'  '/
      LOGICAL*1 LTIME(4)
      INTEGER NAME/'MAIN'/
      INTEGER TIME
      COMMON/MONCNT/IBUF,JBUF
      DATA IALPH/'A ','B ','C ','D ','E ','F ','G ','H ','I ','J ',
     *'K ','L ','M ','N ','O ','P ','Q ','R ','S ','T ','U ','V ',
     *'W ','X ','Y ','Z '/
      REAL*8 KINT/'INTVAL= '/,KTIM/'MAXTIM= '/,KMON/'MON =   '/
      REAL*4 PARM(25)
      LOGICAL*1 LPARM(100),LTEMP(4),LT(2),LMON(8),LIMON(4)
      DIMENSION MINT(26)
      DATA MON/'MON '/,NULL/'    '/
      EQUIVALENCE(TIME,LTIME(1))
      EQUIVALENCE (PARM(1),LPARM(1)),(LTEMP(1),ITEMP)
      EQUIVALENCE (LT(1),IT),(LMON(1),KMON),(LIMON(1),MON)
      EXTERNAL INPUT,MONRT
C
C   INTVAL CONTAINS THE DEFAULT SAMPLING TIME IN SECONDS
C   MAXTIM CONTAINS THE PERIOD OVER WHICH SAMPLING WILL OCCUR
C
C   THE MONITORS MUST BE OF THE FORM  MON.  WHERE . IS A
C   LETTER OF THE ALPHABET
C   THE UNITS OF SAMPLING CAN BE ALTERED BY THE PRESENCE OF
C   THE KEYWORDS  MINS  MILLI  WHICH ALTER THE SAMPLING PERIOD
C   UNITS ONLY TO MINUTES AND MILLISECONDS RESPECTIVELY
C
      NMONS=26
      MAXTIM=60
      INTVAL=15
      ITYPE=1
C
C   LOOK FOR MAXTIM AND INTVAL
C
      CALL  ZA06AS(7,KINT,I,INTVAL)
      CALL  ZA06AS(7,KTIM,I,MAXTIM)
      MAXTIM=MAXTIM*60
      IVAL=INTVAL
      DO 10 I=1,NMONS
      MINT(I)=0
   10 CONTINUE
C
C   MILLISECS?
C
      CALL  ZA06CS(5,MILLI,LFLAG)
      IF(.NOT.LFLAG) GOTO 6
      ITYPE=0
      UNITS=MILLI
      XINT=INTVAL
      XINT=XINT/0.02604166
      INTVAL=XINT
      GOTO 9
    6 CONTINUE
C
C   MINUTES?
C
      INTVAL=INTVAL*100
      CALL  ZA06CS(4,MINS,LFLAG)
      IF(.NOT.LFLAG) GOTO 9
      UNITS=MINS
      INTVAL=INTVAL*60
    9 CONTINUE
C
C   READ FROM PARM FIELD WHICH MONITORS ARE OPERATIONAL
C
      CALL  ZR02AS(KEP,LPF,PARM)
      IPF=LPF-3
      DO 20 I=1,IPF
      ITEMP=NULL
      K=I+2
      ICT=1
      DO 30 J=I,K
      LTEMP(ICT)=LPARM(J)
      ICT=ICT+1
   30 CONTINUE
C
C   SEARCH FOR  MON  IN PARM FIELD
C
      IF(ITEMP.NE.MON) GOTO 20
      IT=IN
      LT(1)=LPARM(I+3)
C
C   FIND WHICH MONITOR IS PRESENT
C
      DO 40 N=1,NMONS
      IF(IT.NE.IALPH(N)) GOTO 40
      MINT(N)=1
      IF(I.EQ.IPF) GOTO 40
      LT(1)=LPARM(I+4)
      IF(IT.NE.IEQ) GOTO 40
      LMON(4)=LPARM(I+3)
C
C   MONITOR PRESENT - BASIC INTERVAL?
C
      CALL  ZA06AS(5,KMON,M,MINT(N))
      IF(MINT(N).LT.0) MINT(N)=0
   40 CONTINUE
   20 CONTINUE
   45 CONTINUE
C
C   LOOK FOR PRESENCE OF INPUT ON STREAM 5
C
      READ(5,5000,END=50)IT,NTMP
 5000 FORMAT(3X,A2,I4)
      IF(NTMP.EQ.0) NTMP=1
      DO 60 I=1,NMONS
      IF(IT.EQ.IALPH(I)) MINT(I)=NTMP
   60 CONTINUE
      GOTO 45
   50 CONTINUE
      WRITE(6,6000)
 6000 FORMAT(' MONITORS SELECTED -')
      WRITE(6,6005)
 6005 FORMAT(' -----------------',/,1X)
      WRITE(6,6010) UNITS
 6010 FORMAT(' MONITOR    INTERVAL(',A5,')')
      WRITE(6,6015)
 6015 FORMAT(' -------    ---------------',/,1X)
      LFLAG=.FALSE.
      DO 65 I=1,NMONS
      IF(MINT(I).LE.0) GOTO 65
      LFLAG=.TRUE.
      IT=IALPH(I)
      LIMON(4)=LT(1)
      NTMP=MINT(I)*IVAL
      WRITE(6,6020)MON,NTMP
 6020 FORMAT(2X,A4,7X,I4)
C
C   LOAD REQUIRED MONITORS
C
      CALL MONLD(MON,I)
   65 CONTINUE
      IF(.NOT.LFLAG) GOTO 999
C
C   SET UP OUTPUT ROUTINE
C
      IBUF=1
      JBUF=1
C
C   WRITE ACTIVE MONITORS TO LOG
C
      IFLAG=0
      CALL MONRT(NAME,26,MINT,IFLAG)
C
C   WRITE DATE TO LOG
C
      CALL ZA09AS(DATE)
      CALL MONRT(NAME2,2,DATE,IFLAG)
      TIME=ITIME(DUM)
      WRITE(6,6030) LTIME
 6030 FORMAT(//,1X,3(Z2,'.'),Z2,' MONITORING STARTED')
      PERCNT=0.
      LFLAG=.TRUE.
      TBEG=ZA01AS(DUM)
      MONCNT=0
   70 CONTINUE
C
C   CYCLE ROUND RUNNING MONITORS WHEN WANYED
C
      CALL STRTIM(ITYPE,MSTRT)
      DO 80 I=1,NMONS
      IF(MINT(I).LE.0) GOTO 80
      IF(LFLAG) GOTO 72
      IF(MOD(MONCNT,MINT(I)).NE.0) GOTO 80
   72 CONTINUE
      TIME=ITIME(DUM)
      CALL MONRUN(I,INPUT,MONRT,TIME)
      CALL MRT2
   80 CONTINUE
      LFLAG=.FALSE.
      CALL STRTIM(ITYPE,MEND)
      PERCNT=PERCNT+(MEND-MSTRT)/INTVAL
      MEND=INTVAL+MSTRT-MEND
      IF(MEND.GT.0) CALL MONTIM(ITYPE,MEND)
      MONCNT=MONCNT+1
      TRUN=ZA01AS(DUM)
      ITRUN=TRUN-TBEG
      IF(ITRUN.LT.MAXTIM) GOTO 70
C
C   END OF MONITORING
C   EMPTY OUTPUT BUFFER
C
      IFLAG=1
      CALL MONRT(NAME,DUM,DUM,IFLAG)
C
C   ERROR EXIT - NO MONITOR SELECTED
C
      WRITE(6,6999)
 6999 FORMAT(' NO MONITORS SELECTED')
      STOP 999
      END
      SUBROUTINE MONRT(NAME,LENGTH,IDATA,IFLAG)
      COMMON/MONCNT/ICT,JCT,IBUF(1000,6)
      DATA IEND/'END '/
      DIMENSION IDATA(LENGTH)
C   IFLAG.EQ.0   NORMAL MONITORING
C   IFLAG.GT.0   END OF MONITORING
      IF(IFLAG.GT.0) GOTO 20
      IF(ICT.GT.1000) CALL MRT
      IBUF(ICT,JCT)=NAME
      ICT=ICT+1
      IF(ICT.GT.1000) CALL MRT
      IBUF(ICT,JCT)=LENGTH
      ICT=ICT+1
      DO 10 I=1,LENGTH
      IF(ICT.GT.1000) CALL MRT
      IBUF(ICT,JCT)=IDATA(I)
      ICT=ICT+1
   10 CONTINUE
   99 CONTINUE
      RETURN
   20 CONTINUE
      IF(ICT.GT.1000) CALL MRT3
      IF(ICT.EQ.1) GOTO 99
      IBUF(ICT,JCT)=IEND
      CALL MRT3
      GOTO 99
      END
      SUBROUTINE MRT
      COMMON/MONCNT/ICT,JCT,IBUF(1000,6)
      DATA JSTRT/1/
      LOGICAL TYPE
      JCT=MOD(JCT,6)+1
      ICT=1
      IF(JCT.NE.JSTRT) GOTO 99
      ENTRY MRT2
      TYPE=.TRUE.
      GOTO 20
      ENTRY MRT3
      TYPE=.FALSE.
   20 CONTINUE
      DO 10 I=1,6
      IF(JCT.EQ.JSTRT) GOTO 10
      WRITE(1,1000) (IBUF(J,JSTRT),J=1,1000)
 1000 FORMAT(4(250A4))
      JSTRT=MOD(JSTRT,6)+1
   10 CONTINUE
      IF(TYPE) GOTO 99
      WRITE(1,1000) (IBUF(J,JCT),J=1,1000)
      ICT=1
   99 RETURN
      END
//S14A EXEC TESTLINK,SO=3,LIB='MVS.APEMAN',OPT=',NCAL,LET,AC=1',
// COND=EVEN,NAME=MAIN2
//STEP15 EXEC ASMBLR,SO=3,COND=EVEN
MONS     START
*
*   ROUTINE SNAPS OUT FIELDS FROM ASCB,OUCB,PFTE
*   LINKAGE IS MONS(INPUT,MONRT,TIME)
*
*   OUTPUT IS OF THE FORM
*   MONS,LENGTH,TIME,JOBNAME,ASID,SNAPSHOT
*
RW0      EQU   0
RW1      EQU   1
RB2      EQU   2
RW3      EQU   3
RW4      EQU   4
RW5      EQU   5
RW6      EQU   6
RW7      EQU   7
RW8      EQU   8
RW9      EQU   9
RW15      EQU   15
*
         STM   14,12,12(13)
         BALR  RB2,0
         USING *,RB2
         LR    RW3,13
         ST    13,SAVE+4
         LA    13,SAVE
         ST    13,8(RW3)
*
*
         LM    RW3,RW5,0(1)            LOAD PARAMETERS
         L     RW4,0(RW4)              LOAD ADRESS OF MONRT
         ST    RW4,ADRT
         L     RW5,0(RW5)              LOAD TIME
         ST    RW5,TIME                STORE TIME
*
*   CHAIN THROUGH CONTROL BLOCKS
*
         L     RW5,76                  CVT POINTER
         ST    RW5,ADCVT
         L     RW5,556(RW5)            ASVT POINTER
         LA    RW5,528(RW5)            FIRST ASCB POINTER
AGAIN    EQU   *
         L     RW6,0(RW5)              ASCB ADDRESS
         LA    RW6,0(RW6)              REMOVE TOP BYTE
         LTR   RW6,RW6                 END OF ASVT Q
         BZ    RETURN
         TM    0(RW5),X'80'            ASCB IN USE?
         BO    INCR
         CLC   ASCB(4),0(RW6)          ASCB?
         BNE   RETURN
*
*   SNAP OPTION  MOVE DATA FROM ASCB,OUCB
*
         L     RW7,172(RW6)            JBNT POINTER
         LTR   RW7,RW7                 INITIATED PROGRAM?
         BNZ   NAMOK
         L     RW7,176(RW6)
         LTR   RW7,RW7                 START/MOUNT/LOGON
         BNZ   NAMOK
         LA    RW7,NULL                MOVE IN BLANKS
NAMOK    EQU   *
         MVC   JOBNAME(8),0(RW7)       MOVE JOBNAME
         LH    RW7,36(RW6)             ASID
         ST    RW7,ASID
         SR    RW3,RW3
         STH   RW3,ASCBDP              ZERO STORES
         STH   RW3,OUCBNPG
         MVC   ASCBSEQN(2),38(RW6)     NO IN DISP Q
         MVC   ASCBDP+1(1),43(RW6)     DISP PRTY
         MVC   ASCBEJST(8),64(RW6)     ELAPSED JOB TIME
         MVC   ASCBJSTL(4),80(RW6)     TOTAL JOB TIME
         MVC   ASCBFLAG(2),102(RW6)    FLAGS
         MVC   ASCBFMCT(2),152(RW6)    FRAME COUNT
         MVC   ASCBSRBT(8),200(RW6)    SRB TIME
         MVC   ASCBSWCT(2),112(RW6)    SHORT WAIT COUNT
         MVC   ASCBVSC(2),120(RW6)     VAM SLOT COUNT
         MVC   ASCBNVSC(2),122(RW6)    NON-VAM COUNT
*
         L     RW7,144(RW6)            OUCB
         MVC   OUCBNPG+1(1),24(RW7)
         MVC   OUCBWMR(2),72(RW7)
         MVC   OUCBRMR(4),84(RW7)
         MVC   OUCBWMS(4),44(RW7)
         MVC   OUCBWSS(2),58(RW7)
         MVC   OUCBPSO(2),56(RW7)
         MVC   OUCBFLAG(1),18(RW7)     TYPE OF JOB
         MVC   OUCBFLAG+1(1),21(RW7)   TYPE OF WAIT
         MVC   OUCBSWC(2),30(RW7)      TRANSACTION SWAP COUNT
         L     RW4,ADCVT
         L     RW4,356(RW4)            PVT POINTER
         L     RW8,12(RW4)             PFT POINTER
         LR    RW9,RW8
         AH    RW8,16(RW4)             FIRST ACTIVE PFTE
         AH    RW9,18(RW4)             LAST ACTIVE PFTE
         SR    RW3,RW3
         ST    RW3,ALLOC               ZERO COUNTERS
         ST    RW3,LSQA
         ST    RW3,LOCAL
         ST    RW3,FIXED
         ST    RW3,VIO
LOOP     EQU   *
         CR    RW8,RW9
         BH    PFTEND
         LH    RW4,0(RW8)
         C     RW4,ASID
         BNE   NOTASID
         TM    13(RW8),X'10'           VIO?
         BNO   NOTVIO
         L     RW3,VIO
         LA    RW3,1(RW3)              INCREMENT VIO COUNT
         ST    RW3,VIO
         B     NOTASID
NOTVIO   EQU   *
         L     RW3,ALLOC
         LA    RW3,1(RW3)              INCREMENT ALLOC COUNT
         ST    RW3,ALLOC
         TM    12(RW8),X'20'           LSQA?
         BNO   NOTSQA
         L     RW3,LSQA
         LA    RW3,1(RW3)              INCREMENT LSQA
         ST    RW3,LSQA
         B     NOTASID
NOTSQA   EQU   *
         L     RW3,LOCAL
         LA    RW3,1(RW3)              INCREMENT LOCAL
         ST    RW3,LOCAL
         TM    13(RW8),X'20'           V=R
         BNO   NOTASID
         L     RW3,FIXED
         LA    RW3,1(RW3)              INCREMENT FIXED
         ST    RW3,FIXED
NOTASID  EQU   *
         LA    RW8,16(RW8)             INCREMENT PFTE POINTER
         B     LOOP
*
*   WRITE OUT RECORD FOR ONE ASID
*
PFTEND   EQU   *
         LA    RW1,ADARGS
         L     RW15,ADRT
         BALR  14,15
*
*
INCR     EQU   *
         LA    RW5,4(RW5)              INCREMENT ASCB POINTER
         B     AGAIN
*
RETURN   EQU   *
         L     13,4(13)
         LM    14,12,12(13)
         BR    14
*
*   STORAGE AND CONSTANTS
*
LENGTH   DC    F'23'
NAME     DC    C'MONS'
IFLAG    DC    F'0'
*
ADARGS   DC    A(NAME)
         DC    A(LENGTH)
         DC    A(TIME)
         DC    A(IFLAG)
*
*
         DS    0D
TIME     DS    F
JOBNAME  DC    C'        '
ASID     DS    F
ASCBEJST DS    D
ASCBSEQN DS    H
ASCBDP   DS    H
ASCBJSTL DS    F
ASCBSRBT DS    D
ASCBFLAG DS    H
ASCBFMCT DS    H
OUCBNPG  DS    H
OUCBWMR  DS    H
OUCBRMR  DS    F
OUCBWMS  DS    F
OUCBWSS  DS    H
OUCBPSO  DS    H
OUCBSWC  DS    H
         DS    H
OUCBFLAG DS    H
ASCBSWCT DS    H
ASCBVSC  DS    H
ASCBNVSC DS    H
ALLOC    DS    F
LSQA     DS    F
LOCAL    DS    F
FIXED    DS    F
VIO      DS    F
*
ADCVT    DS    F
ADRT     DS    F
ASCB     DC    C'ASCB'
NULL     DC    C'        '
SAVE     DS    18F
*
         LTORG
         END
//S15A EXEC TESTLINK,SO=3,LIB='MVS.APEMAN',OPT=',NCAL,LET,AC=1',
// COND=EVEN,NAME=MONS
//STEP16 EXEC ASMBLR,SO=3,COND=EVEN
PAGE     START
*
*   LINKAGE IS PAGE(MONRT,TIME,JOBNAME,SEARCH)
*   IF SEARCH=0 JOBNAMES
*            =1 PLPA
*            =2 VIO
*            =4 ALL
*            =8 ASID/JOBNAMES
*
*   ROUTINE WRITES SEQUENCES OF RECORDS OF THE FORM:
*   MONP,LENGTH,TIME,TYPE,JOBNAME   TYPE=0   NO ASID FOUND
*   MONP,LENGTH,TIME,TYPE,JOBNAME,ASID,VBN/FIX COUNT,FLAGS
*      TYPE=1  JOBNAME FOUND
*   MONP,LENGTH,TIME,TYPE,JOBNAME,ASID  TYPE=2 ASID FOR JOBNAME
*
RW0      EQU   0
RW1      EQU   1
RB2      EQU   2
RW3      EQU   3
RW4      EQU   4
RW5      EQU   5
RW6      EQU   6
RW7      EQU   7
RW8      EQU   8
RW9      EQU   9
RW15      EQU   15
*
         STM   14,12,12(13)
         BALR  RB2,0
         USING *,RB2
         LR    RW3,13
         ST    13,SAVE+4
         LA    13,SAVE
         ST    13,8(RW3)
*
*
         LM    RW3,RW6,0(1)            LOAD PARAMETERS
         L     RW3,0(RW3)              LOAD ADRESS OF MONRT
         ST    RW3,ADRT
         MVC   TIME(4),0(RW4)          MOVE IN TIME OF CALL
         MVC   JOBNAME(8),0(RW5)       LOAD JOBNAME
         L     RW6,0(RW6)              LOAD SEARCH
         ST    RW6,SEARCH
         LR    RW3,RW6
*
*
*   CHAIN THROUGH CONTROL BLOCKS
*
         L     RW5,76                  CVT POINTER
         ST    RW5,ADCVT
         C     RW3,TWO                 VIO?
         BE    NOTJOB
         C     RW3,ONE
         BNE   NOTPLPA                 PLPA PAGES?
         L     RW5,MONE
         ST    RW5,ASID                STORE ASID FOR PLPA
         B     NOTJOB
NOTPLPA  EQU   *
*
         L     RW5,556(RW5)            ASVT POINTER
         LA    RW5,528(RW5)            ADDRESS OF ASCB POINTER
*   FIND ASID FOR JOBNAME
AGAIN    EQU   *
         ST    RW5,ADASVT
         L     RW6,0(RW5)              ASCB ADDRESS
         LA    RW6,0(RW6)              REMOVE TOP BYTE
         LTR   RW6,RW6                 TEST FOR END OF ASVT Q
         BZ    NAMEND
         TM    0(RW5),X'80'            TEST FOR ASCB IN USE
         BO    INCR
         CLC   ASCB(4),0(RW6)          CHECK FOR ASCB
         BNE   NAMEND
         ST    RW6,ADASCB
         C     RW3,FOUR                ALL?
         BE    FOUND
         L     RW7,172(RW6)            JBNT POINTER
         C     RW3,ZERO                JOBNAME?
         BE    JOB
         LTR   RW7,RW7                 CHECK FOR JOBNAME FOR
         BNZ   NAMOK                   INITIATED PROFRAM
         L     RW7,176(RW6)
         LTR   RW7,RW7                 CHECK FOR JOBNAME FOR
         BNZ   NAMOK                   START/MOUNT/LOGON
         LA    RW7,NULL                MOVE IN BLANKS
NAMOK    EQU   *
         MVC   JOBNAME(8),0(RW7)
         LH    RW7,36(RW6)             STORE ASID/JOBNAME
         ST    RW7,ASID
         LA    RW7,2
         ST    RW7,TYPE
         LA    RW7,5                   LENGTH OF DATA
         ST    RW7,LENGTH
         LA    RW1,ADARGS
         L     RW15,ADRT
         BALR  14,15
         B     INCR
*
*
JOB      EQU   *
         LTR   RW7,RW7                 CHECK FOR JOBNAME FOR
         BNZ   COMP                    INITIATED PROGRAM
         L     RW7,176(RW6)
         LTR   RW7,RW7                 CHECK FOR JOBNAME FOR
         BZ    INCR                    START/MOUNT/LOGON
COMP     EQU   *
         CLC   JOBNAME(8),0(RW7)
         BE    FOUND                   CORRECT ASID
INCR     EQU   *
         L     RW5,ADASVT
         LA    RW5,4(RW5)              INCREMENT POINTER TO ASCB Q
         B     AGAIN
*
NAMEND   EQU   *
         C     RW3,ZERO                JOBNAME?
         BNE   RETURN
*
*   JOBNAME NOT FOUND
*
*
         LA    RW4,0
         ST    RW4,TYPE
         LA    RW4,5                   LENGTH OF DATA
*
         ST    RW4,LENGTH              SET UP FOR TYPE 0
         LA    RW1,ADARGS
         L     RW15,ADRT
         BALR  14,15
         B     RETURN
*
FOUND    EQU   *
         L     RW7,172(RW6)
         LTR   RW7,RW7                 CHECK FOR JOBNAME FOR
         BNZ   OK                      INITIATED PROGRAM
         L     RW7,176(RW6)
         LTR   RW7,RW7                 CHECK FOR JOBNAME FOR
         L     RW8,12(RW4)             PFT POINTER
         LR    RW9,RW8
         AH    RW8,16(RW4)             FIRST ACTIVE PFTE
         AH    RW9,18(RW4)             LAST ACTIVE PFTE
*
*   CYCLE ROUND WRITING TYPE 1 RECORDS
*
         LA    RW4,1
         ST    RW4,TYPE
         LA    RW4,7                   LENGTH OF DATA
         ST    RW4,LENGTH
*
LOOP     EQU   *
         CR    RW8,RW9
         BH    PFTEND
         TM    13(RW8),X'10'           TEST FOR VIO
         BNO   NOTVIO
         C     RW3,TWO
         BNE    ON
         B     WANTED
NOTVIO   EQU   *
         C     RW3,TWO
         BE    ON
         LH    RW4,0(RW8)
         C     RW4,ASID
         BNE   ON                      CORRECT ASID?
WANTED   EQU   *
         LH    RW4,0(RW8)              LOAD ASID
         ST    RW4,ASID
         LH    RW4,2(RW8)              VBN
         STH    RW4,VBN
         LH    RW4,8(RW8)              FIX COUNT
         STH   RW4,FIX
         L     RW4,12(RW8)             FLAGS
         ST    RW4,FLAGS
*
*   DATA FOUND   WRITE TO LOG
*
         LA    RW1,ADARGS              POINT TO PARAMETERS
         L     RW15,ADRT
         BALR  14,15
*
ON       EQU   *
         LA    RW8,16(RW8)
         B     LOOP                    CHECK NEXT PFTE
*
*   END OF PFTE LOOP
*
PFTEND   EQU   *
         C     RW3,FOUR                ALL?
         BE    INCR
*
RETURN   EQU   *
         L     13,4(13)
         LM    14,12,12(13)
         BR    14
*
*   STORAGE AND CONSTANTS
*
SEARCH   DS    F
MONE     DC    F'-1'
ZERO     DC    F'0'
ONE      DC    F'1'
TWO      DC    F'2'
FOUR     DC    F'4'
EIGHT    DC    F'8'
LENGTH   DS   F
NAME     DC    C'MONP'
ASCB     DC    C'ASCB'
NULL     DC    C'        '
IFLAG    DC    F'0'
*
ADARGS   DC    A(NAME)
         DC    A(LENGTH)
         DC    A(TIME)
         DC    A(IFLAG)
*
*
         DS    0D
TIME     DS    F
TYPE     DS    F
JOBNAME  DC    C'        '
ASID     DS    F
VBN      DS    H
FIX      DS    H
FLAGS    DS    F
*
ADCVT    DS    F
ADASCB   DS    F
ADASVT   DS    F
ADRT     DS    F
MASK     DC    X'000000FF'
BITS     DC    X'00000010'
SAVE     DS    18F
*
         LTORG
         END
//S16A EXEC TESTLINK,SO=3,LIB='MVS.APEMAN',OPT=',NCAL,LET,AC=1',
// COND=EVEN,NAME=PAGE
//STEP17 EXEC FORTRAN,SO=3,COND=EVEN
      SUBROUTINE MONP(INPUT,MONRT,TIME)
C
C   ROUTINE MONITORS PAGES OF A JOB IN REAL STORE
C   BY WRITING THEM OUT TO STREAM 1
C
      REAL*8 RNULL/'        '/,ALL/'*ALL    '/,PLPA/'*PLPA   '/
      REAL*8 VIO/'*VIO    '/,NAM/'*NAME   '/
      REAL*8 NAME/'MONP    '/
      REAL*8 JOBNAM(10),JTEMP
      INTEGER IFL(10)
      LOGICAL*1 FIRST/.TRUE./,GO/.FALSE./,BUFFER(80)
      DATA IFLAG/0/
      EQUIVALENCE (JTEMP,BUFFER(1))
C
      IF(.NOT.FIRST) GOTO 100
      FIRST=.FALSE.
C
C   READ IN JOBNAMES TO MONITOR
C   MAX NO IS 10
C
      JCT=0
      DO 10 I=1,10
      CALL INPUT(NAME,BUFFER,IFLAG)
      IF(IFLAG.NE.0) GOTO 15
      JOBNAM(I)=JTEMP
      IFL(I)=0
C
C   IFL=0 FOR SEARCH ON JOBNAME
C      =1 FOR PLPA
C      =2 FOR VIO
C      =4 FOR ALL
C      =8 FOR ASID JOBNAME CORRESPONDENCE
      IF(JTEMP.EQ.PLPA) IFL(I)=1
      IF(JTEMP.EQ.VIO) IFL(I)=2
      IF(JTEMP.EQ.ALL) IFL(I)=4
      IF(JTEMP.EQ.NAM) IFL(I)=8
      JCT=JCT+1
   10 CONTINUE
   15 CONTINUE
      IF(JCT.NE.0) GO=.TRUE.
  100 CONTINUE
      IF(.NOT.GO) GOTO 999
      DO 110 I=1,JCT
      CALL PAGE(MONRT,TIME,JOBNAM(I),IFL(I))
  110 CONTINUE
  999 CONTINUE
      RETURN
      END
      SUBROUTINE MONA(INPUT,MONRT,TIME)
      DIMENSION IDATA(2)
      EQUIVALENCE(IDATA(1),TCALL),(IDATA(2),T)
      DATA MON/'MONA'/
      TCALL=TIME
      T=ZA01AS(DUM)
      CALL MONRT(MON,2,IDATA,0)
      RETURN
      END
      SUBROUTINE MONZ(INPUT,MONRT,TIME)
      DIMENSION IDATA(2)
      EQUIVALENCE(IDATA(1),TCALL),(IDATA(2),T)
      DATA MON/'MONZ'/
      TCALL=TIME
      T=ZA01AS(DUM)
      CALL MONRT(MON,2,IDATA,0)
      RETURN
      END
//S17A EXEC TESTLINK,SO=3,LIB='MVS.APEMAN',OPT=',NCAL,LET,AC=1',
// COND=EVEN,NAME=MAIN3
// EXEC TESTLINK,SO=3,LIB='MVS.APEMAN',OPT=',AC=1',NAME=APEMAN1
//SYSLIN DD *
 ENTRY MAIN
 INCLUDE BB(MAIN2)
 INCLUDE BB(MAIN3)
 INCLUDE BB(ITIME)
 INCLUDE BB(STRTIM)
 INCLUDE BB(INPUT)
 INCLUDE BB(MONTIM)
 INCLUDE BB(MONRUN)
 INCLUDE BB(MONAD)
 INCLUDE BB(MONLD)
 INCLUDE BB(MONS)
 INCLUDE BB(PAGE)
 INCLUDE BB(ZA01AS)
 INCLUDE BB(ZA06AS)
 INCLUDE BB(ZR02AS)
 INCLUDE BB(ZA09AS)
 INCLUDE BB(ZA06CS)
 INCLUDE BB(ZA06BS)
 NAME APEMAN1(R)
 INCLUDE BB(MAIN3)
 INCLUDE BB(ZA01AS)
 INCLUDE BB(PAGE)
 ENTRY MONA
 NAME MONA(R)
 INCLUDE BB(MAIN3)
 INCLUDE BB(ZA01AS)
 INCLUDE BB(PAGE)
 ENTRY MONZ
 NAME MONZ(R)
 INCLUDE BB(MAIN3)
 INCLUDE BB(ZA01AS)
 INCLUDE BB(PAGE)
 ENTRY MONP
 NAME MONP(R)
 INCLUDE BB(MONRD)
 INCLUDE BB(DECVB)
 INCLUDE BB(ZA06AS)
 INCLUDE BB(ZR02AS)
 INCLUDE BB(ZA09AS)
 INCLUDE BB(ZA01AS)
 INCLUDE BB(MONTIM)
 INCLUDE BB(MONRUN)
 INCLUDE BB(STRTIM)
 INCLUDE BB(INPUT)
 INCLUDE BB(MONLD)
 INCLUDE BB(MONAD)
 INCLUDE BB(ITIME)
 INCLUDE BB(APEMAN3)
 ENTRY MAIN
 NAME APEMAN2(R)
//BB DD DSN=MVS.APEMAN,DISP=SHR
