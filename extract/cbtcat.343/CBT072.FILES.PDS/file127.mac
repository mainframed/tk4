*          DATA SET CBT554     AT LEVEL 003 AS OF 04/14/77
         MACRO
         REGS
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
RA       EQU   10
RB       EQU   11
RC       EQU   12
RD       EQU   13
RE       EQU   14
RF       EQU   15
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         MEND
         MACRO
&NAME    PRIME &REG=12,&SAVE=,&ID=,&LV=0
.* PRIME WILL SAVE REGISTERS, CREATE A NEW SAVE AREA, CHAIN THE NEW
.* SAVE AREA TO THE CALLERS SAVE AREA, ESTABLISH ADDRESSABILITY,
.* OPTIONALLY OBTAIN ADDITIONAL STORAGE AND IN GENERAL PERFORM THE
.* NECESSARY ENTRY LINKAGE.
.* IF THE USER DOES NOT SPECIFY WHAT REGISTER HE REQUIRES FOR A BASE,
.* TWELVE IS USED.  NOTE..IF REG= IS SPECIFIED TO BE 0, 1, 13, 14, OR
.* 15  A WARNING MESSAGE IS ISSUED.
.* IF THE USER SPECIFIES A SAVE AREA VIA THE SAVE= OPERAND THEN PRIME
.* WILL CHAIN THE USERS SAVE AREA TO THE CALLERS SAVE AREA. IF THE
.* USER DOES NOT SPECIFY SAVE,THEN PRIME WILL OBTAIN A NEW SAVE AREA
.* VIA THE GETMAIN SVC.  AN ADDITIONAL AMOUNT OF STORAGE MAY BE
.* OBTAINED AT THIS TIME BY SPECIFIEING THE LV=, OPERAND.  IF LV IS NOT
.* SPECIFIED IN REGISTER NOTATION, 4023 IS THE MAXIMUM VALUE.
.* IF THE USER SPECIFIES SAVE=NONE, PRIME WILL NOT OBTAIN A NEW AREA.
.* REG 13 WILL POINT TO THE NEW 18 WORD SAVE AREA FOLLOWED BY THE EXTRA
.* STORAGE AREA.
         LCLA  &A,&B
         LCLC  &E,&F,&G,&H
         MNOTE *,'&REG WILL BE USED AS A BASE REGISTER'
         AIF   ('&NAME' EQ '').NONAME
&NAME    DS    0H
.NONAME  ANOP
         AIF   ('&ID' EQ '').CONT4
         AIF   ('&ID' EQ '*').SPEC
&A       SETA  ((K'&ID+2)/2)*2+4
         BAL   15,&A.(0,15)             GET PGM MASK AND BRANCH AROUND
         USING *,&REG
&A       SETA  K'&ID
         DC    AL1(&A)
.CONTB   AIF   (&A GT 32).SPLIT
.CONTAA  AIF   (&A GT 8).BRAK
&E       SETC  '&ID'(&B+1,&A)
         DC    CL&A'&E'
         AGO   .CONT1
.BRAK    ANOP
&E       SETC  '&ID'(&B+1,8)
         DC    CL8'&E'
&B       SETA  &B+8
&A       SETA  &A-8
         AGO   .CONTAA
.SPLIT   ANOP
&E       SETC  '&ID'(&B+1,8)
&F       SETC  '&ID'(&B+9,8)
&G       SETC  '&ID'(&B+17,8)
&H       SETC  '&ID'(&B+25,8)
         DC    CL32'&E.&F.&G.&H'
&B       SETA  &B+32
&A       SETA  &A-32
         AGO   .CONTB
.SPEC    AIF   ('&NAME' EQ '').CSECTN
&E       SETC  '&NAME'
&A       SETA  1
.CONTQ   AIF   ('&E'(1,&A) EQ '&E').LVE
&A       SETA  &A+1
         AGO   .CONTQ
.LVE     ANOP
&B       SETA  ((&A+2)/2)*2+4
         BAL   15,&B.(0,15)             GET PGM MASK AND BRANCH AROUND
         USING *,&REG
         DC    AL1(&A)
         DC    CL&A'&E'
         AGO   .CONT1
.CSECTN  AIF   ('&SYSECT' EQ '').E4
&E       SETC  '&SYSECT'
&A       SETA  1
         AGO   .CONTQ
.E4      IHBERMAC 78,360
.CONT4   ANOP
         BALR  15,0                     R15 NOW CONTAINS PGM MASK
         USING *,&REG
.CONT1   ANOP
         AIF   ('&REG' EQ '0' OR '&REG' EQ '1' OR '&REG' EQ '13').ERR1
         AIF   ('&REG' EQ '14' OR '&REG' EQ '15').ERR1
.CONT3   ANOP
         DS    0H
         STM   14,12,12(13)             SAVE REGS IN CALLERS AREA
         LR    &REG,15                  SET TRUE BASE EQUAL EP
         AIF ('&SAVE' EQ 'NONE').A
         AIF   ('&SAVE' EQ '').C
         AIF   ('&SAVE'(1,1) EQ '(').F
         LA    1,&SAVE                  SET R1 EQ USERS SAVE ADDRESS
         AGO   .D
.F       ANOP
         AIF   ('&SAVE' EQ '(1)').D
         LR    1,&SAVE(1)               PICK UP USERS SAVE AREA
         AGO   .D
.C       ANOP
         AIF   ('&LV'(1,1) EQ '(').E
.*         AIF   ('&LV' GT '4023').ERR2
         LA    0,&LV.+72(0,0)           PARAMETER FOR GETMAIN
         AGO   .CONT2
.E       ANOP
         AIF   ('&LV' EQ '(0)').CONT2
         LA    0,72(&LV(1).,0)          PARAMETER FOR GETMAIN
.CONT2   ANOP
         BAL   1,*+4                    INDICATE GETMAIN
         SVC   10                       ISSUE SVC 10
         ST    0,0(0,1)                 SAVE LENGTH IN 1ST WORD
.D       ANOP
         XC    4(68,1),4(1)             CLEAR AREA
         ST    1,8(0,13)                CHAIN FORWARD
         ST    13,4(0,1)                CHAIN BACKWARD
         LM    0,1,20(13)               RESET R0 AND R1
         L     13,8(0,13)               SET SAVE AREA REGISTER
.A       ANOP
         MEXIT
.ERR1    MNOTE 'ILLEGAL BASE REGISTER SPECIFIED'
         AGO   .CONT3
.ERR2    MNOTE 'LV GT 4023, LV REQUEST NOT HONORED'
         LA    0,72(0,0)                PARAMETER FOR GETMAIN
         AGO   .CONT2
         MEND
         MACRO
&NAME    TERME &OP=,&SAVE=,&LV=0
.* TERME WILL RESTORE REGISTERS, UNCHAIN SAVE AREAS, RELEASE DYNAMIC
.* STORAGE OBTAINED BY THE PRIME MACRO, RESET THE PGM MASK AND IN
.* GENERAL PERFORM THE NECESSARY EXIT LINKAGE.
.* TERME WILL FREE THE USERS SAVE AREA PLUS THE NUMBER OF BYTES
.* SPECIFIED BY THE LV OPERAND UNLESS THE USER IMPLIES THAT THE SAVE
.* AREA WAS NOT OBTAINED VIA A GETMAIN.  THE USER IMPLIES THIS BY
.* SPECIFYING SAVE= SOME VALUE OR SYMBOL.
.* IF THE USER SPECIFIED SAVE=NONE IN THE PRIME MACRO, HE SHOULD DO
.*  THE SAME FOR TERME.
.* THE USER MAY CHOOSE TO FOLLOW THE TERME MACRO WITH THE XCTL MACRO
.* RATHER THAN BRANCH ON 14.  THE USER ACCOMPLISHES THIS BY CODING
.* OP=XCTL.
         AIF   ('&NAME' EQ '').F
&NAME    DS    0H
.F       ANOP
         AIF ('&SAVE' EQ 'NONE').C
         L     13,4(0,13)              GET PTR TO USERS AREA
         STM   0,1,20(13)               TEMPORARY SAVE OF R0 AND R1
         AIF   ('&SAVE' NE '').C
         AIF   ('&LV'(1,1) EQ '(').E
         AIF   ('&LV' EQ '0').CONT
         AIF   ('&LV' GT '4023').ERR
         LA    0,&LV.+72(0,0)           PARAMETER FOR FREEMAIN
         AGO   .CONT
.E       ANOP
         AIF   ('&LV' EQ '(0)').CONT
         LA    0,72(&LV(1).,0)          PARAMETER FOR FREEMAIN
.CONT    ANOP
         L     1,8(0,13)                GET SAVE AREA ADDRESS
         LA    1,0(0,1)                 INDICATE FREEMAIN
         AIF   ('&LV' NE '0').CONTC
         L     0,0(0,1)                 LENGTH IS IN 1ST WORD OF AREA
.CONTC   ANOP
         SVC   10                       ISSUE SVC 10
.C       ANOP
         L     14,16(0,13)              RESET
         SPM   14                       PGM MASK
         L     14,12(0,13)              RESTORE
         LM    0,12,20(13)              REGISTERS
         XC    8(4,13),8(13)            DEQUEUE SAVE AREA
         AIF   ('&OP' EQ 'XCTL').D
         BR    14                       RETURN TO CALLER
         MEXIT
.D       ANOP
         BALR  15,0                     ESTABLISH ADDRESSABILITY
         USING *,15
         MEXIT
.ERR     MNOTE 'LV GT 4023, LV REQUEST NOT HONORED'
         LA    0,72(0,0)                PARAMETER FOR FREEMAIN
         AGO   .CONT
         MEND
         MACRO
&SYM     SYSGET &EODAD=EODAD,&DDNAME=SYSIN,&LRECL=80,&RECFM=,          X
               &BLKSIZE=80
         AIF   (K'&SYM EQ 0).NOSYM
         AIF   (K'&SYM GT 5).ERRSYM
         AIF   (K'&DDNAME GT 8).DDNERR
         AIF   (K'&EODAD GT 8).ERREOD
       MNOTE *,'DCB = DDNAME=&DDNAME,DSORG=PS,MACRF=GL,EODAD=&EODAD'
       MNOTE *,'          DD CARD CHANGES WILL WORK FOR '
       MNOTE *,'      LRECL=&LRECL,BLKSIZE=&BLKSIZE,RECFM=&RECFM'
***********************************************************************
*        THIS MACRO COURTESY OF D.R.CHANEY, MILWAUKEE, FE-246         *
***********************************************************************
         DS    0H
&SYM     ST    14,&SYM.14 .            SAVE RETURN REG
         TM    &SYM.DCB+48,X'10' .     IS DCB OPEN
         BC    1,&SYM.1 .              YES - BYPASS OPEN CODE
         OPEN  (&SYM.DCB,(INPUT))
         TM    &SYM.DCB+48,X'10' .     DID DCB OPEN
         BC    1,&SYM.1 .              YES
         WTO   '&SYM.DCB IS NOT OPEN - CHECK DD CARD',ROUTCDE=11
         B     &SYM.EOD
&SYM.1   GET   &SYM.DCB
         L     14,&SYM.14 .            RESTORE RETURN REG
         BR    14 .                    RETURN
&SYM.XIT CLC   &SYM.DCB+62(2),=H'0' .  IS BLOCK SIZE THERE
         BNE   &SYM.3 .                IF SO SKIP
         MVC   &SYM.DCB+62(2),=H'&BLKSIZE' .MOVE IN SIZE
&SYM.3   CLC   &SYM.DCB+82(2),=H'0' .  IS LRECL HERE
         BNE   &SYM.4 .                IF SO SKIP
         MVC   &SYM.DCB+82(2),=H'&LRECL' .   MOVE IN LRECL
&SYM.4   CLI   &SYM.DCB+36,X'00' .     IS RECFM THERE
         BNE   &SYM.5 .                BRANCH IF THERE
         MVI   &SYM.DCB+36,X'90' .     MOVE IN DEFAULT RECFM FB
&SYM.5   BR    14 .                    RETURN TO OPEN
&SYM.EOD CLOSE &SYM.DCB
         FREEPOOL &SYM.DCB
         B     &EODAD .                GO TO USERS EODAD RTN
&SYM.14  DS    1F .                    RETURN REG SAVE AREA
&SYM.LST DC    X'85' .                 DCB OPEN EXIT
         DC    AL3(&SYM.XIT) .         POINTER TO XIT RTN
&SYM.DCB DCB   DDNAME=&DDNAME,DSORG=PS,MACRF=(GL),EODAD=&SYM.EOD,      ,
               EXLST=&SYM.LST,RECFM=&RECFM
         AGO   .END
.ERRSYM MNOTE 8,'8,*** LABEL ON SYSGET MACRO MUST BE LESS THAN SIX'
         AGO   .END
.NOSYM  MNOTE 8,'8,*** SYSGET MACRO MUST HAVE A LABEL'
         AGO   .END
.DDNERR MNOTE 8,'8,*** DDNAME LARGER THAN EIGHT CHARACTERS'
         AGO   .END
.ERREOD MNOTE 8,'8,*** MAXIMUM LABEL SIZE IS EIGHT CHARACTERS'
.END     MEND
         MACRO
&SYM     SYSPUT &DDNAME=SYSPUNCH,&LRECL=80,&RECFM=,&BLKSIZE=80
         AIF   (K'&SYM GT 5).ERRSYM
         AIF   (K'&SYM EQ 0).NOSYM
         AIF   (K'&DDNAME GT 8).DDNERR
       MNOTE *,'DCB = DDNAME=&DDNAME,DSORG=PS,MACRF=PM'
       MNOTE *,'             DD CARD CHANGES WILL WORK FOR'
       MNOTE *,'      LRECL=&LRECL,BLKSIZE=&BLKSIZE,RECFM=&RECFM'
***********************************************************************
*        THIS MACRO COURTESY OF D.R.CHANEY, MILWAUKEE, FE-246         *
***********************************************************************
&SYM     DS    0H
         STM   14,1,&SYM.14 .          SAVE REGS
         TM    &SYM.DCB+48,X'10' .     IS DCB OPEN
         BC    1,&SYM.1 .              YES - BYPASS OPEN CODE
         OPEN  (&SYM.DCB,(OUTPUT))
         TM    &SYM.DCB+48,X'10' .     DID DCB OPEN
         BC    1,&SYM.1 .              YES
         B     &SYM.1S
&SYM.1   L     0,&SYM.14+12 .          SET DATA REG
         PUT   &SYM.DCB,(0)
&SYM.1S  DS    0H
         LM    14,1,&SYM.14 .          RESTORE REGS
         BR    14 .                    RETURN
&SYM.XIT CLC   &SYM.DCB+62(2),=H'0' .  IS BLKSIZE THERE
         BNE   &SYM.3 .                IF SO SKIP
         MVC   &SYM.DCB+62(2),=H'&BLKSIZE' MOVE IN BLKSIZE
&SYM.3   CLC   &SYM.DCB+82(2),=H'0' .  IS LRECL THERE
         BNE   &SYM.4 .                IF SO SKIP
         MVC   &SYM.DCB+82(2),=H'&LRECL' MOVE IN LRECL
&SYM.4   CLI   &SYM.DCB+36,X'00' .     IS RECFM THERE
         BNE   &SYM.5 .                BRANCH IF THERE
         MVI   &SYM.DCB+36,X'90' .     MOVE IN DEFAULT RECFM FB
&SYM.5   BR    14 .                    RETURN TO OPEN
&SYM.14  DS    4F .                    REG SAVE AREA
&SYM.LST DC    X'85' .                 OPEN EXIT LIST
         DC    AL3(&SYM.XIT) .         ENTRY FOR OPEN EXIT
&SYM.DCB DCB   DDNAME=&DDNAME,DSORG=PS,MACRF=(PM),EXLST=&SYM.LST,      X
               RECFM=&RECFM
         AGO   .END
.ERRSYM MNOTE 8,'8,*** LABEL ON SYSPUT MACRO MUST BE LESS THAN SIX'
         AGO   .END
.NOSYM  MNOTE 8,'8,*** SYSPUT MACRO MUST HAVE A LABEL'
         AGO   .END
.DDNERR MNOTE 8,'8,*** DDNAME LARGER THAN EIGHT CHARACTERS'
.END     MEND
         MACRO
&SYM     SYSPRINT &HEADER1=,&HEADER2=,&LINES=56,&DDNAME=SYSPRINT,      X
               &RECFM=FBA,&LRECL=133,&BLKSIZE=0
         AIF   (K'&SYM EQ 0).NOSYM
         AIF   (K'&SYM GT 5).ERRSYM
         AIF   (K'&DDNAME GT 8).DDNERR
         AIF   ('&LRECL' GT '133').ERRLEN
         MNOTE *,'DCB = DDNAME=&DDNAME,LRECL=&LRECL,LINES=&LINES'
         AIF   ('&HEADER1' EQ '').HD1
         MNOTE *,'    &HEADER1 IS FIRST HEADER LINE'
         AIF   ('&HEADER2' EQ '').HD2
         MNOTE *,'    &HEADER2 IS SECOND HEADER LINE'
.HD2     MNOTE *,'    THE FIRST BYTE OF ANY BUFFER SPECIFIED WILL'
         MNOTE *,'    BE USED BY THIS ROUTINE FOR ASA CHARACTERS'
         MNOTE *,'    AND UNPREDICTABLE RESULTS MAY OCCUR IF USED.'
***********************************************************************
*        THIS MACRO COURTESY OF D.R.CHANEY, MILWAUKEE, FE-246         *
***********************************************************************
         DS    0H
&SYM     NOP   DRC&SYSNDX.C .          NOP BRANCH SET AFTER OPEN
         NOP   DRC&SYSNDX.D .          NOP BRANCH SET AFTER OPEN
         STM   14,2,DRC&SYSNDX.B .     SAVE USERS REGS
         LA    1,DRC&SYSNDX.A .        LOAD ADDRESS OF OPEN LIST
         SVC   19 .                    ISSUE OPEN SVC
         TM    &SYM.DCB+48,X'10' .     DID DCB OPEN
         BC    1,&SYM.1 .              YES
         LM    14,2,DRC&SYSNDX.B .     RESTORE REGISTERS
         BR    14
&SYM.1   DS    0H
         OI    &SYM.+5,C'0' .          SET NOP TO BRANCH
         OI    &SYM.+1,C'0' .          SET FIRST NOP TO BRANCH
         AIF   ('&HEADER1' EQ '').HD4
DRC&SYSNDX.F MVI &HEADER1,C'1' .       SET CARRIAGE CONTROL
         PUT   &SYM.DCB,&HEADER1
         AIF   ('&HEADER2' EQ '').HD5
         MVI   &HEADER2,C'-' .         SET TRIPLE SPACE AFTER SKIP
         PUT   &SYM.DCB,&HEADER2
         AGO   .HD5
.HD4     L     15,DRC&SYSNDX.B+12 .    GET POINTER TO RECORD
DRC&SYSNDX.E MVI 0(15),C'1' .            SKIP TO ONE FIRST TIME
         LA    2,&LINES.+1 .           GET LINE COUNT
         AGO   .HD55
.HD5     L     15,DRC&SYSNDX.B+12 .    PICK UP DATA POINTER
         MVI   0(15),C'0' .            SET DOUBLE SPACE AFTER SK97
         LA    2,&LINES.+1 .           PICK UP LINE COUNT
.HD55    ANOP
DRC&SYSNDX.G BCT 2,DRC&SYSNDX.H .      BR TO PRINT FOR NUMBER OF LINES
         AIF   ('&HEADER1' NE '').HD6
         B     DRC&SYSNDX.E .          START NEW PAGE
         AGO   .P4
.HD6     B     DRC&SYSNDX.F .          GO TO DO SKIP AND PRINT HDR
.P4      ANOP
DRC&SYSNDX.H PUT &SYM.DCB,(15)
         ST    2,DRC&SYSNDX.J .        SAVE THE LINE COUNT
         LM    14,2,DRC&SYSNDX.B .     RESTORE USERS REGS
         MVI   0(1),C' ' .             PLACE BLANK INTO CARRIAGE CONTR
         MVC   1(&LRECL.-1,1),0(1) .   CLEAR THE BUFFER
         BR    14 .                    RETURN
DRC&SYSNDX.D STM 14,2,DRC&SYSNDX.B .   SAVE REGS ALWAYS
         AIF   ('&HEADER1' EQ '').P6
         B     DRC&SYSNDX.F .          GO TO HEADER ROUTINE
         AGO   .P5
.P6     ANOP
         L     15,DRC&SYSNDX.B+12 .    PICK UP POINTER TO DATA
         B     DRC&SYSNDX.E .          GO TO HEADER RTN
.P5      ANOP
DRC&SYSNDX.C STM 14,2,DRC&SYSNDX.B .   SAVE REGS ALWAYS
         L     2,DRC&SYSNDX.J .        RESTORE THE LINE COUNTER
         L     15,DRC&SYSNDX.B+12 .    PICK UP POINTER TO DATA
         MVI   0(15),C' ' .            MOVE X'40' TO ASA
         B     DRC&SYSNDX.G .          GO TEST FOR LINE COUNT
DRC&SYSNDX.M CLC &SYM.DCB+62(2),=H'0' . IS BLOCK SIZE THERE
         BNE   DRC&SYSNDX.L .          IF SO SKIP
         MVC   &SYM.DCB+62(2),=H'&LRECL'  .     MOVE IN DEFAULT SIZE
DRC&SYSNDX.L BR 14 .               RETURN TO OPEN
DRC&SYSNDX.B DS 5F .                   PRINT RTNS SAVE AREA
DRC&SYSNDX.J DS 1F .                   SAVE FOR LINE COUNTER
DRC&SYSNDX.K DC X'85' .                EXIT LIST FOR OPEN
         DC    AL3(DRC&SYSNDX.M) .     POINTER TO THE EXIT ROUTINE
DRC&SYSNDX.A DC AL1(143) .             OPTION BYTE FOR OPEN
         DC    AL3(&SYM.DCB) .         DCB ADCON FOR OPEN
&SYM.DCB DCB   DDNAME=&DDNAME,LRECL=&LRECL,RECFM=&RECFM,DSORG=PS,      X
               MACRF=(PM),EXLST=DRC&SYSNDX.K,BLKSIZE=&BLKSIZE
         MEXIT
.HD1     AIF   ('&HEADER2' EQ '').HD2
         MNOTE 8,'8,*** HEADER2 INVALID WITHOUT HEADER1 SPECIFIED'
         MEXIT
.ERRLEN MNOTE 8,'8,*** LRECL TOO LARGE FOR SYSPRINT'
         MEXIT
.NOSYM  MNOTE 8,'8,*** SYSPRINT MACRO MUST HAVE A LABEL'
         MEXIT
.ERRSYM MNOTE 8,'8,*** LABEL ON SYSPRINT MACRO MUST BE LESS THAN SIX'
         MEXIT
.DDNERR MNOTE 8,'8 *** MAXIMUM DDNAME SIZE IS EIGHT CHARACTERS'
         MEXIT
.BUFERR  MNOTE 8,'8,*** NO BUFFER SUPPLIED, EXECUTION IMPOSSIBLE'
.END     MEND
TSGTFMAP TITLE 'TSGTFMAP-SHOW DISK USAGE FROM GTF DATA - 2/15/77'
***********************************************************************
* DESC: READ GTF DATA AND SUMMARIZE DASD SIO/IO RECORDS.
*        BY DEVICE: CALCULATE NUMBER SIO CC = 0-3,
*              TOTAL CYLINDERS SEEKED,
*              AVERAGE CYLINDERS SEEKED,
*              AVERAGE IO TIME,
*              MAX. IO TIME OVER RUN,
*              BUILD TWO ARRAYS FOR DRIVE/JOB STATS.
*
*        DRIVE ARRAY:
*        SLOT SIZE(IN CYLINDERS) = ((LINESIZE-OFFSET)/
*        JOB TABLE IS AN N BY N MATRIX,
*           WHERE N IS NUMBER OF JOBS IN INCORE TABLE.
*        THIS ARRAY IS USED AS FOLLOWS:
*         JT(N,M)=JT(N,M)+1 WHERE:
*          N=JOB# THAT WAS HELD UP.
*          M=JOB# THAT HELD JOB N UP.
*         HELD UP MEANS JOB N HAD TO SEEK MORE THAN 'SEEKINTF' CYLS.
*
*        JCL:  //MAP EXEC PGM=TSGTFMAP,REGION=(100K+6K*#DASD)
*              //SYSPRINT DD SYSOUT=C
*              //SYSUT1   DD DSN=GTFDATA,DISP=SHR
***********************************************************************
         LCLB  &NOXYTEX       IF CALCOMP/XYTEX IN SYSTEM
&NOXYTEX SETB  1              YES-CALCOMP ATL IN SYSTEM
*        I AM USING THEIR PROPRIETARY DATE/TIME SUBROUTINE
TSGTFMAP CSECT                      GTF DISK USAGE MAPPER
*         PRINT NOGEN                SAVE PAPER/TREES
         REGS                       SYMBOLIC REGS
         PRIME ID=*,LV=DSASIZE      SET UP SAVE AREAS/CHAIN/BASING
         USING DSA,R13              SAVE AREA / WORKING STORE
         USING DVTAB,R11            DEVICE TABLE POINTER
         USING GTFREC,R10           GTF RECORD POINTER
         B     SETUP                GO TO SETUP
GETREC   DS    0H                   GET NEXT GTF RECORD
         BAL   R14,GET             GET GTF RECORD
         LR    R10,R1              COPY ADDR PTR
         CLC   GTLEN,=H'65'        MIN LENGTH HANDLED
         BL    BYPASS              TOO SHORT
         CLI   GTID,X'FF'          TRACE RECORD ID
         BNE   BYPASS              NO-SKIP
         CLI   GTFMT,0             FORMAT IDENTIFIER
         BNE   BYPASS              NO-BYPASS
         CLC   GTEVNT,=X'5100'     SIO REC
         BE    SIOREC              YES
         CLC   GTEVNT,=X'5200'     I/O W/ VALID UCB
         BE    IOREC               YES
         CLC   GTEVNT,=X'2100'     PCI I/O
         BE    IORECPCI            YES
         CLC   GTEVNT,=X'5201'     I/O W/O VALID UCB
         BE    IORECBAD            YES-BAD
         B     BYPASS              ALL ELSE FAILS TOO
IORECPCI DS    0H                  PCI
         AP    TOTPCI,=P'1'        BUMP
         B     GETREC              LOOP
IORECBAD DS    0H                  I/O W/O VALID UCB
         AP    TOTBAD,=P'1'        BUMP
         B     GETREC              LOOP
BYPASS   DS    0H                  BYPASSED RECORD(MANY REASONS)
         AP    TOTBYPAS,=P'1'      BUMP CTR
         B     GETREC              LOOP
         TITLE '              I / O  R E C O R D '
IOREC    DS    0H
         AP    TOTIO,=P'1'          BUMP TOT
         LH    R11,GTIDEV           GET DEV ADDR
         BAL   R14,UTGET            LOCATE DEVICE TABLE PTR
         B     GETREC               +0 RETURN = NOT FOUND
         OC    DVLTIME,DVLTIME      IS THERE A PREV SIO REC.
         BZ    GETREC               NO - RETURN
         LM    R0,R1,GTTIME         GET IO TIME
         LM    R14,R15,DVLTIME      GET SIO TIME
         XC    DVLTIME,DVLTIME      SHOW NO SIO TIME
         SLR   R1,R15               CALC DIFFERENCE
         BC    2+1,*+8              "
         SH    R0,=H'1'             "
         SR    R0,R14               "
         SRDL  R0,12                CONVERT TO MICRO SECS
         L     R15,=F'100'          CONVERT TO MILLISEC*10
         BAL   R14,DIVIDER         DIVIDE AND ROUND
         C     R1,DVMAXIO           CHECK AGAINST MAX SO FAR
         BL    *+8                  NO - SKIP
         ST    R1,DVMAXIO           YES-SAVE NEW MAX
         AL    R1,DVAVGIO           ADD IO TIME TO TOTAL
         ST    R1,DVAVGIO           STORE
         B     GETREC               LOOP
         TITLE '               S I O  R E C O R D'
SIOREC   DS    0H                   PROCESS SIO RECORD
         AP    TOTSIO,=P'1'         BUMP TOT
         LH    R11,GTSDEV           GET ADDR
         BAL   R14,UTGET            GET DEVICE TABLE PTR
         B     GETREC               +0=NOT FOUND
         IC    R1,GTSIOCC           GET SIO CC
         N     R1,=X'00000030'      MASK
         SRL   R1,2                 *2
         L     R15,DVSIO0(R1)       BUMP SIO CTR
         AH    R15,=H'1'            "
         ST    R15,DVSIO0(R1)       "
         LTR   R1,R1                SIO CC = 0
         BNZ   GETREC               NO - LOOP
         ICM   R1,3,GTSSEEK+3       GET SEEK CYL
         LH    R15,DVDELTA          GET SLOT SIZE IN CYL
         BAL   R14,DIVIDE           CALC SLOT #
         SLL   R1,2                SLOT# * 4
         L     R15,DVLROW          LAST ROW ADDR IN SEEK ARRAY
         AR    R15,R1              + OFFSET = ENTRY
         L     R0,0(R15)           DT(FROM,TO)=DT(FROM,TO)+1
         AH    R0,=H'1'            "
         ST    R0,0(R15)           "
         MH    R1,DVSLOTS          CALC NEW FROM ROW ADDR
         LA    R1,DVXREF(R1)       "
         ST    R1,DVLROW           SAVE FOR NEXT SIO
         LH    R0,DVLSEEK+3        LAST SEEK CYL
         SH    R0,GTSSEEK+3        CALC DIFFERENCE
         LPR   R0,R0               POSITIVE
         LR    R3,R0               SAVE FOR JOB ARRAY
         A     R0,DVTOTCYL         BUMP TOT CYL SEEKED
         ST    R0,DVTOTCYL         "
*        UPDATE JT TABLE
         CH    R3,SEEKINTF         CYL SEEKED ENOUGH ?
         BL    SIONOINT            NO - JOB NOT HELD UP
         LA    R3,JOBS             GET JOB NAME TABLE
         LH    R2,MAXJOB           GET # OF ENTRIES
         XR    R15,R15             CLEAR
SIOFNDJB DS    0H                  LOCATE JOB WHO CAUSED PROBLEM
         IC    R15,JOBS#CHR-JOBS(R3)  GET L'-1 OF JOBNAME
         EX    R15,SIOEXCLC        FOUND JOBNAME?
         BE    SIOFND              YES
         LA    R3,(JOB1-JOBS)(R3)  NO - BUMP TO NEXT
         BCT   R2,SIOFNDJB         LOOP
         SH    R3,=AL2(JOB1-JOBS)  NOT FOUND - BACK UP 1 ENTRY
         LA    R2,1                ADJUST LOOP REG
SIOFND   DS    0H                  NOW UPDATE ARRAY ENTRY
         LH    R14,MAXJOB          MAX JOBNAMES
         SR    R14,R2               -LOOP REG = JOB #
         LH    R1,DVLJOBI          GET LAST JOB #(CAUSED PROB)
         STH   R14,DVLJOBI         UPDATE LAST JOB #
         MH    R14,JTSIZ           *L'=OFFSET TO ARRAY ROW
         A     R14,DVJTROOT         + BASE ADDR = ROW ADDR
         SLL   R1,2                4 BYTES/ENTRY = COLLUMN INDEX
         L     R2,0(R14,R1)        JT(N,M)=JT(N,M)+1
         AH    R2,=H'1'            "
         ST    R2,0(R14,R1)        "
         B     SIONOINT            GET OUT
SIOEXCLC CLC   JOBSNAM-JOBS(0,R3),GTJOB
SIONOINT DS    0H                  UPDATE FILEDS
*        UPDATE HOLD INFO
         MVC   DVLSEEK,GTSSEEK     LAST SEEK
         MVC   DVLJOB,GTJOB        LAST JOB
         MVC   DVLTIME,GTTIME      LAST TIME
         B     GETREC              LOOP
         TITLE '             S E T U P'
SETUP    DS    0H
         ZAP   PACKS(4),=P'0'      ZERO FIRST PACKED COUNTER
         MVC   PACKS+4(PACKE-PACKS-4),PACKS  ZERO REST (64 MAX)
         MVI   HDR1,C' '           BLANK HDR
         MVC   HDR1+1(L'HDR1-1),HDR1  "
         MVI   HDR1,C'1'           SKIP CHAN 1 ASA
         AIF (&NOXYTEX).NOX1
         MVI   DTVFLAG,GETDATE     CALCOMP DATE UTILITY
         CALL  XYUTDTTM,(DTV)      "
         MVC   HDRDATE,REPTFORM    DATE
         MVC   HDRTIME,DTVCHR      TIME
.NOX1    ANOP
         MVC   HDRTITLE,LOGO       MOVE HEADER
         LH    R0,LINESIZE         GET LINE SIZE
         AH    R0,=H'10'           + 10
         GETMAIN R,LV=(0)          GET PRINT LINE
         ST    R1,@PL              SAVE ADDR
         LH    R1,STMAXDSP         DIGITS IN DEVICE ARRAY DISPLAY
         XR    R0,R0               CLEAR
SETOVFLO DS    0H                  CALC LARGEST DISPLAY NUMBER (999)
         MH    R0,=H'10'           SHIFT LEFT 1 DECIMAL
         AH    R0,=H'9'            ADD 9
         BCT   R1,SETOVFLO         LOOP TO GET STMAXDSP 9(S)
         ST    R0,EODOVFLO         SAVE 999
*        SETUP MOVE INSTR FOR SEEK COUNT
         MVC   EXMVC,MVC           MOVE MODEL
         MVC   EXMVC2,MVC2         MOVE MODEL OF *** MOVE
         MVC   EXMVC3,MVC          MOVE MODEL FORM EDIT AREA
         LH    R6,EXMVC+4          GET END OF EDIT AREA
         N     R6,=X'0000FFFF'     CLEAR TO S TYPE CON
         SH    R6,STMAXDSP         BACK UP BY DISPLAY DIHITS
         STCM  R6,3,EXMVC+4        SAVE S-TYPE ADDR OF EDIT AREA
         AH    R6,STMAXDSP         GET BACK TO ORIG. S-TYPE
         SH    R6,STJOBDSP         BACK UP FOR JOB DISPLAY DIGITS
         STCM  R6,3,EXMVC3+4       SAVE S-TYPE
         LH    R0,STMAXDSP         GET # DISPLAY DIGITS
         BCTR  R0,0                -1
         STC   R0,EXMVC+1          PUT IN MVC INSTR
         STC   R0,EXMVC2+1
         LH    R0,STJOBDSP         GET JOB ARRAY DISPLAY DIGITS
         BCTR  R0,0                -1
         STC   R0,EXMVC3+1         SET MVC L'
*        BUILD JOB INTERFERENCE TABLES
         LH    R0,MAXJOB           # JOBNAMES IN TABLE
         MH    R0,MAXJOB           SQUARE IT
         SLL   R0,2                * 4 BYTES/COUNTER
         ST    R0,JTSIZE           SAVE SIZE
*        CALC. # OF SLOTS FOR A DRIVE
         LH    R1,LINESIZE         GET LINE SIZE
         SH    R1,LINEOFST         -MARGIN INFO
         LH    R15,STMAXDSP        GET # DISPLAY DIGITS
         BAL   R14,DIVIDE          CALC # SLOTS ON A LINE
         STH   R1,DVSLOTS          SAVE IT
         MH    R1,DVSLOTS          SQUARE FOR DEVICE ARRAY
         SLL   R1,2                *4BYTES/COUNTER
         LA    R1,DVFIXSIZ(R1)     +FIX PREFIX SIZE
         ST    R1,JTOFFSET         =START OF JOB ARRAY
         A     R1,JTSIZE           +JOB ARRAY SIZE
         ST    R1,DVSIZE           =SIZE OF A DEVICE ENTRY(6K)
*        GET DEVICE VECTOR TABLE
         LH    R0,DVMAX            GET MAX DEVICES
         MH    R0,=AL2(DVVSIZ)     *SIZE OF VECTOR TABLE ENTRY(6)
         ST    R0,DVVSIZE          SAVE SIZE
         GETMAIN R,LV=(0)          GET TABLE
         ST    R1,DVVROOT          SAVE ADD
         BAL   R14,CLRIT           CLEAR CORE
*        SEARCH FOR DASD UCBS TO FILL VECTOR TABLE
         L     R1,DVVROOT          GET START OF VECTOR TABLE
         A     R1,DVVSIZE          +SIZE=END+1
         SH    R1,=AL2(DVVSIZ)     BACKUP TO LAST
         MVI   0(R1),X'FF'         MARK LAST
*        SEARCH UCB LOOKUP TABLE FOR DASDS
         L     R4,16               CVT
         L     R4,CVTILK2(R4)      LOOKUP2
         L     R5,DVVROOT          MY LOOKUP TABLE
         USING DVVTAB,R5           TELL ASM
         XR    R6,R6               CLEAR
SETDASD  DS    0H                  LOOK FOR DASD
         LA    R4,2(R4)            NEXT UCB PTR(ASSUME NOT DASD)
         ICM   R6,3,0(R4)          UCB ADDR
         BZ    SETDASD             HOLE - LOOP
         CLC   0(2,R4),=X'FFFF'    END
         BE    SETDASDE            YES-NEXT SECTION
         CLI   UCBDVCLS(R6),X'20'  DASD
         BNE   SETDASD             NO-LOOP
         L     R2,16               YES-SEE IF ANOTHER CHAN PATH
         L     R2,CVTILK2(R2)      LOOKUP TABLE
         XR    R3,R3               CLEAR
SETDASD1 DS    0H                  SEE IF ANOTHER PATH
         LA    R2,2(R2)            UCB PTR
         ICM   R3,3,0(R2)          UCB ADDR
         BZ    SETDASD1            HOLE-LOOP
         CLC   0(2,R2),=X'FFFF'    END - NO 2ND PATH
         BE    SETDASD
         CR    R3,R6               SAME UCB?
         BNE   SETDASD1            NO-LOOP
         CR    R2,R4               SANE PTR?
         BNE   SETDASD             NO-ANOTHER PATH
         LA    R14,STCYLS          GET MY DEVICE CHAR TABLE
SETDEVCK DS    0H                  LOC DEVICE ATTR
         CLC   0(1,R14),UCBUNTYP(R6)  MATCH ON UCB TYPE
         BE    SETDEVOK            YES - GOOD DEV
         LA    R14,STCYLS1-STCYLS(R14)  BUMP
         CLI   0(R14),X'FF'        END OF TABLE
         BE    SETDASD             YES-SKIP HIM
         B     SETDEVCK            LOOP
SETDEVOK DS    0H                  GOOD DASD
         STCM  R6,3,DVVUCB         SAVE UCB ADDR
         LA    R5,DVVSIZ(R5)       BUMP PTR
         CLI   DVVSIZ(R5),X'FF'    ROOM FOR MORE
         BNE   SETDASD             YES-LOOP
         ABEND 1,DUMP              NO---
SETDASDE DS    0H                  NOW BUILD DEVICE TABLES
         S     R5,DVVROOT          BACK UP TO LAST BUILT
         LR    R1,R5               PUT IN WORK
         LA    R15,DVVSIZ          SIZE OF VECTOR ENTRY
         BAL   R14,DIVIDE          GET # GOOD DASDS IN SYS
         LR    R0,R1               PUT IN WORK
         MH    R0,DVSIZE+2         *DEVICE ENTRY SIZE(6K)
         GETMAIN R,LV=(0)          GET DEVICE TABLE
         LR    R11,R1              SET PTR TO FIRST
         BAL   R14,CLRIT           CLEAR CORE
         L     R5,DVVROOT          GET VECTOR PTR
SETDT    DS    0H                  BUILD DEVICE ENTRIES
         ICM   R6,3,DVVUCB         GET UCB ADDR
         BZ    GETREC              END-OF-TABLE
         ST    R11,DVVPTR          STORE PTR TO DEVICE ENTRY
         MVC   DVUCB,UCBNAME(R6)   MOVE DISPLAY ADDR
         MVC   DVVOLI,UCBVOLI(R6)  MOVE VOLSER
         LR    R1,R11              WORK
         A     R1,JTOFFSET         +OFFSET TO JOB TABLE
         ST    R1,DVJTROOT         SAVE START OF JOB TABLE
*        CALC # OF CYLS IN A SLOT
         LA    R14,STCYLS          DEVICE CHAR TABLE
SETCYLLP DS    0H                  LOOK FOR DEVICE
         CLC   0(1,R14),UCBUNTYP(R6)  MATCH
         BE    SETCYL              YES-LOAD
         LA    R14,STCYLS1-STCYLS(R14) BUMP
         CLI   0(R14),X'FF'        END - ?
         BNE   SETCYLLP            NO - LOOP
SETCYL   DS    0H                  SET UP DEVICE CHAR
         MVC   DVTYPE,(STCYLNAM-STCYLS)(R14)  NAME (3330)
         MVC   DVTRK,(STCYLTRK-STCYLS)(R14)  TRACKS PER CYL
         LH    R1,DVSLOTS          GET # OF SLOTS
         LH    R15,(STCYLMAX-STCYLS)(R14)   GET # CYLS ON PACK
         LR    R14,R1              HALF ADJUST
         SRL   R14,1               "
         AR    R15,R14             "
         XR    R14,R14             CLEAR
         DR    R14,R1              GET # CYLS/SLOT
         STH   R15,DVDELTA         SAVE
         LA    R15,DVXREF          GET START OF DEVICE ARRAY
         ST    R15,DVLROW          SAVE AS LAST ROW SEEKED
         LA    R5,DVVSIZ(R5)       NEXT DEVICE VECTOR PTR
         A     R11,DVSIZE          NEXT DEVICE ENTRY
         B     SETDT               DO NEXT DEVICE
         DROP  R5                  TELL ASM
MVC2     MVC   0(*-*,R5),=CL10'**********'  OVERFLOW MODEL INSTR
MVC      MVC   0(*-*,R5),WE+L'WE   MODEL FOR MOVE IN REPORT
         TITLE 'E N D  O F  D A T A  -  R E P O R T  W R I T E R'
GETEOD2  DS    0H
         L     R1,DVVROOT          FIRST VECTOR ENTRY
         ST    R1,EODCURDV         SAVE
         BAL   R14,CLRPL           CLEAR PRINT LINE
         LA    R1,HDR1             PUT HDR OUT
         BAL   R14,PUT
         LA    R2,(PRTCNTE-PRTCNTS)/(PRTCNT1-PRTCNTS)
         LA    R3,PRTCNTS     #OF CTRS/STRT OF TABLE
EODTOT   DS    0H                  DISPLAY JOB TOTS
         L     R1,@PL              GET OUTPUT PLINE ADDR
         LH    R14,L'PRTCNTS(R3)   GET OFFSET FROM STRT OF CTRS
         LA    R14,PACKS(R14)      GET ADDR OF CTRS
         MVC   1(L'MASK2,R1),MASK2 MOVE EDIT MASK
         ED    1(L'MASK2,R1),0(R14) EDIT CTR IN
         MVI   1+L'MASK2(R1),C'='  FORMAT CTR COUNTS
         MVC   1+L'MASK2+1(L'PRTCNTS,R1),0(R3) MOVE CTR NAME IN
         BAL   R14,PUT             PUT OUT COUNTER
         LA    R3,L'PRTCNTS+2(R3)  BUMP TO NEXT LITERAL/OFFSET SET
         BCT   R2,EODTOT           DO NEXT TOTAL COUNT
EODLOOP  DS    0H             NOW PRINT DATA FOR EACH DASD
         BAL   R14,CLRPL           CLEAR PRT LINE TO BLANKS
         L     R1,EODCURDV         PICK UP CURRENT DEVICE PTR
         OC    0(2,R1),0(R1)  END OF VECTOR TABLE
         BZ    EODJOB              YES-FINI
         L     R11,DVVPTR-DVVTAB(R1) GET DEVICE TABLE
         LA    R1,DVVSIZ(R1)       BUMP TO NEXT DEVICE PTR
         ST    R1,EODCURDV         SAVE FOR NEXT TIME
         OC    DVSIO0,DVSIO0  NO-SIOS - SKIP
         BZ    EODLOOP             TRY NEXT DEVICE
*        CALC AVG CYL SEEKED
         L     R1,DVTOTCYL         GET TOTAL CYL SEEKED
         L     R15,DVSIO0          GET GOOD SIOS
         BAL   R14,DIVIDER         TOT CYL / SIO 0
         ST    R1,DVAVGCYL         STORE AVG. CYL SEEKED
*        CALC AVG IO TIME IN MILLI-SEC
         L     R1,DVAVGIO          GET SUM OF IO TIME(TIMES 10)
         L     R15,DVSIO0          GET GOOD SIOS
         MH    R15,=H'10'          (TIMES 10) TO OFFSET IO TIME
         BAL   R14,DIVIDER         GET AVG. I/O TIME (IN MILLISEC)
         ST    R1,DVAVGIO          SAVE
         L     R1,DVMAXIO          GET LONGEST IO TIME
         LH    R15,=H'10'          GET 10 TO NORMALIZE
         BAL   R14,DIVIDER         GET LONGEST IO TIME IN MILLISEC
         ST    R1,DVMAXIO          SAVE IT
*        SET UP TO NORMALIZE COUNTS IN XREF ARRAY
         LH    R2,DVSLOTS          GET # OF SLOTS TO MAP PACK
         MH    R2,DVSLOTS          SQUARE IT FOR # OF ARRAY ENTRIES
         XR    R3,R3               CLEAR
         LA    R4,DVXREF           GET START OF ARRAY
EODMAX   DS    0H                  LOOK FOR HIGHEST ENTRY
         C     R3,0(R4)            COMPARE AGAINST CURRENT
         BH    *+8                 NOT A NEW HIGH
         L     R3,0(R4)            NEW-HIGH - PICK UP
         LA    R4,4(R4)            BUMP TO NEXT ENTRY
         BCT   R2,EODMAX           LOOP
         ST    R3,DVMAXHIT         SAVE HIGHEST HIT PT.
         C     R3,EODOVFLO         WOULD MAX OVERFLOW A PRT ENTRY
         BL    EODMAXOK            NO-NO NEED TO NORMALIZE
         LH    R2,DVSLOTS          GET SLOTS AGAIN
         MH    R2,DVSLOTS          SQUARE TO GET ARRAY SIZE
         LA    R4,DVXREF           START OF ARRAY
         LR    R14,R3              SAVE MAX HIT POINT SIZE
         SRL   R14,1               1/2
EODNORM  DS    0H                  NORMALIZE WHOLE ARRAY TO PRT SIZE
         XR    R0,R0               CLEAR
         L     R1,0(R4)            GET ENTRIES NUMBER
         M     R0,EODOVFLO         X 999 - PRT ELEMENT SIZE
         ALR   R1,R14              ADD FOR HALF ADJUST
         BC    8+4,*+8             DID OVERFLOW OCCUR
         AH    R0,=H'1'            YES-BUMP 1ST REG
         DR    R0,R3               GET NORMALIZED SIZE
         ST    R1,0(R4)            STORE NORMALIZED ENTRY
         LA    R4,4(R4)            BUMP TO NEXT ARRAY ELEMENT
         BCT   R2,EODNORM          LOOP
EODMAXOK DS    0H                  START PRINTING DEVICE STATS
         LA    R1,HDR1             GET HEADER
         MVC   HDRUCB,DVUCB        SET UCB ADDR IN HDR
         MVC   HDRTYPE,DVTYPE      SET TYPE (3330)
         MVC   HDRVOLI,DVVOLI      SET VOLID
         BAL   R14,PUT             SKIP TO CH 1
         LA    R2,(EODCNTE-EODCNTS)/(EODCNT1-EODCNTS)  GET # TOTS
         LA    R3,EODCNTS          GET START OF DEV. TOTS
         BAL   R14,CLRPL           BLANK PRINT LINE
         L     R1,@PL              GET PRINT LINE
         MVI   0(R1),C'0'          DBL SPACE
EODTOT2  DS    0H                  PRINT DEVICE TOTS
         LH    R14,L'EODCNTS(R3)   GET OFFSET TO TOT CTR.
         L     R14,DVTAB(R14)      GET ADDR OF CTR
         CVD   R14,WD              MAKE PACKED
         MVC   1(L'MASK2,R1),MASK2 MOVE EDIT MASK
         ED    1(L'MASK2,R1),WD+4  EDIT TOT IN
         MVI   1+L'MASK2(R1),C'='  SET =
         MVC   1+L'MASK2+1(L'EODCNTS,R1),0(R3) MOVE TOT NAME IN
         BAL   R14,PUT             PRINT DEV TOTAL
         L     R1,@PL              GET PRINT LINE ADDR
         MVI   0(R1),C' '          SINGLE SPACE
         LA    R3,L'EODCNTS+2(R3)  BUMP TO NEXT TOT DESC. SET
         BCT   R2,EODTOT2          LOOP
         BAL   R14,CLRPL           CLEAR PRINT LINE
         L     R1,@PL              GET PRINT LINE
         LR    R0,R2               GET COUNT DOWN CTR
         SH    R0,DVSLOTS          SUBTRACT MAX. (0,-1,-2,..MAX)
         CVD   R0,WD               MAKE PACKED
         MVC   WE,MASK             SET MASK
         ED    WE,WD+2             EDIT IT IN (NO SIGN DISPLAYED)
         EX    0,EXMVC             MOVE IT IN PRINT LINE
         AH    R5,STMAXDSP         NEXT SLOT ADDR IN PRT LINE
         BCT   R2,EODHDR2          LOOP
         BAL   R14,PUT             PRINT ARRAY HEADER
         BAL   R14,CLRPL           CLEAR PRINT LINE
         L     R1,@PL              GET PRT LINE ADDR
         BAL   R14,PUT             PRINT A BLANK LINE
         LA    R4,DVXREF           GET START OF ARRAY
         LH    R3,DVSLOTS          GET # OF SLOTS
EODNXT   DS    0H                  PRINT A ROW OF DEV ARRAY
         LR    R0,R3               GET CURRENT DOWN CTR
         SH    R0,DVSLOTS          - MAX = NEG SLOT #
         CVD   R0,WD               PACKED
         L     R1,@PL              GET PRINT LINE
         MVC   0(4,R1),=X'40212020' SET EDIT MASK
         ED    0(4,R1),WD+6        SET SLOT # (NO SIGN SHOWN)
         MH    R0,DVDELTA          GET # OF CYLS IN A SLOT
         MH    R0,DVTRK            * # OF TRK IN A CYL
         CVD   R0,WD               MAKE PACKED
         MVC   4(6,R1),=X'402021202020' SET EDIT MASK
         ED    4(6,R1),WD+5        EDIT STARTING TRACK # IN
         LR    R5,R1               GET START OF PRINT LINE
         AH    R5,LINEOFST         ADD OFFSET TO START OF ARRAY DATA
         LH    R2,DVSLOTS          GET # OF SLOTS ON PRT LINE
EODROW   DS    0H                  RUN THRU ALL COL. IN A ROW
         L     R0,0(R4)            GET COUNTER
         LTR   R0,R0               IS COUNT ZERO
         BZ    EODZERO             YES-SPECIAL CASE
         CVD   R0,WD               NO-MAKE PACKED
         MVC   WE,MASK             SET EDIT MASK
         ED    WE,WD+2             EDIT IT IN
EODMVC   DS    0H                  MOVE COUNT FROM WORK AREA
         EX    0,EXMVC             MOVE SPECIFIED DIGITS IN
EODBUMP  DS    0H                  NEXT COL. IN A ROW
         LA    R4,4(R4)            BUMP TO NEXT CTR
         AH    R5,STMAXDSP         BUMP SLOT ADDR IN PRT LINE
         BCT   R2,EODROW           NEXT COLUMN IN ROW
         L     R1,@PL              GET PRT LINE
         BAL   R14,PUT             PRINT WHOLE ROW
         BCT   R3,EODNXT           LOOP FOR NEXT ROW
         LH    R6,MAXJOB           NOW FORMAT JOB INTERFERENCE ARRAY
         L     R4,DVJTROOT         GET START OF ARRAY
         BAL   R14,CLRPL           CLEAR PRINT LINE
         L     R1,@PL              GET PRT LINE ADDR
         BAL   R14,PUT             PRINT IT
EODJNXT  DS    0H                  PRT JOB + NAMES WHO HELD HIM UP
         BAL   R14,CLRPL           CLEAR PRINT LINE
         L     R1,@PL              GET PRT LINE ADDR
         LH    R14,MAXJOB          GET # OF JOBS MONITORED
         SR    R14,R6              GET INDEX TO CURRENT JOB
         MH    R14,=AL2(JOB1-JOBS) GET OFFSET TO JOBNAME LIT.
         LA    R14,JOBS(R14)       + BASE ADDR = START OF LIT.
         MVC   5(L'JOBSNAM,R1),(JOBSNAM-JOBS)(R14) MOVE JOBNAME
         LA    R5,14(R1)           GET START OF ARRAY IN PRT LINE
         LH    R2,MAXJOB           GET # OF JOBS MONITORED
EODJROW  DS    0H                  PRINT A ROW
         L     R0,0(R4)            GET INTERFERENCE COUNT
         CVD   R0,WD               MAKE PACKED
         MVC   WE,MASK             SET EDIT MASK
         ED    WE,WD+2             EDIT IT
         EX    0,EXMVC3            MOVE DATA INTO PRT LINE
         LA    R4,4(R4)            NEXT CTR
         AH    R5,STJOBDSP         NEXT SLOT IN PRT LINE
         BCT   R2,EODJROW          GET NEXT COLUMN
         BAL   R14,PUT             PRINT A ROW
         BCT   R6,EODJNXT          NEXT JOB
         B     EODLOOP             NEXT DASD DEVICE
EODZERO  DS    0H                  SPECIAL CASE OF DASD SIO ZERO
         CR    R2,R3               IS ZERO ON DIAGONAL
         BE    EODPLUS             YES - MARK DIAGONAL W/ +
         MVC   WE,=C'           .' ELSE MARK NULLS W/ PERIODS
*        IDEA IS TO MAKE COLUMNS HAVE PERIODS DOWN THEM
*         AND DIAGONAL TO HAVE PLUSES.
         B     EODMVC              MOVE DATA IN PRT LINE
EODPLUS  DS    0H                  SET DATA TO PLUS
         MVC   WE,=C'           +' SET WORK AREA TO PLUS
         B     EODMVC              MOVE DATA IN PRT LINE
EODJOB   DS    0H                  EOJ
*         DC    H'0'          TEST ENABLE TO LOOK AT CORE
         LA    R15,0               SET RC
*        SOMEDAY IM GOING TO CLOSE FILES AND FREE GOTTEN CORE
         TERME ,                   RETURN TO O/S
         TITLE 'U T G E T  -  LOCATE DEVICE ENTRY FROM CHAN. ADDR.'
UTGET    DS    0H                  ENTRY
         ST    R14,UTGETSAV        SAVE RETURN
         LR    R14,R11             COPY ADDR
         SRDL  R14,8               PUT CU/DEV ADDR IN R15
         SRL   R15,28              PUT CU/DEV IN LOW END
         L     R1,16               CVT
         L     R1,CVTILK1(R1)      LOOKUP 1
         XR    R3,R3               CLEAR
         IC    R3,0(R14,R1)        GET CHANNEL INDEX
         ALR   R15,R3              ADD CU/DEV
         ALR   R15,R15             TIMES 2
         LR    R3,R11              GET A FRESH COPY OF ADDR
         N     R3,=F'15'           MASK OFF CHAN/CU
         AH    R3,0(R15,R1)        ADD DEVICE INDEX
         ALR   R3,R3               DOUBLE
         L     R1,16               CVT
         L     R1,CVTILK2(R1)      LOOKUP 2
         LH    R14,0(R1,R3)        GET UCB ADDR
         N     R14,=X'0000FFFF'    MASK OFF IF OVER 32K
         LR    R11,R14             COPY TO OUTPUT REG
         L     R14,DVVROOT         GET START OF VECTOR TABLE
         L     R1,UTGETSAV         GET RETURN ADDR
UTGLOOP  DS    0H                  FIND SAME UCB PTR
         USING DVVTAB,R14          TELL ASM
         CLI   DVVUCB,X'FF'        END OF VECTOR TABLE
         BER   R1                  YES-RETURN?????
         CLM   R11,3,DVVUCB        FIND SANE UCB PTR
         BE    UTGFND              FOUND
         LA    R14,DVVSIZ(R14)     BUMP TO NEXT VECTOR ENTRY
         B     UTGLOOP             TRY AGAIN
UTGFND   DS    0H                  FOUND IT
         L     R11,DVVPTR          GET PTR TO DEVICE TABLE
         B     4(R1)               RETURN +4 = GOOD DEV
CLRPL    DS    0H                  CLEAR PRINT LINE
         L     R0,@PL              ADDR OF PRT LINE
         LH    R1,LINESIZE         GET LINE SIZE
         L     R15,=X'40000000'    SET FILL CHAR TO BLANK
         MVCL  R0,R14              MOVE BLANKS IN
         BR    R14                 RETURN
*        CLEAR A SECTION OF CORE
CLRIT    DS    0H                  CLEAR
         XR    R0,R1               SWAP REGS 1 AND 0
         XR    R1,R0               "
         XR    R0,R1               "
         XR    R15,R15             CLEAR R15
         MVCL  R0,R14              PAD WHOLE THING W/ ZEROS
         BR    R14                 RETURN
DIVIDER  DS    0H                  DIVIDE R1 BY R15
         LR    R0,R15              PUT IN R0 FOR HALF ADJUST
         SRL   R0,1                1/2
         AR    R1,R0               ADD TO DIVISOR
DIVIDE   DS    0H                  DIVIDE W/OUT HALF ADJUST
         XR    R0,R0               CLEAR
         DR    R0,R15              DIVIDE R1 BY R15 REMANDER=R0
         BR    R14                 RETURN
         TITLE 'S T A T I C  S T O R A G E'
GET      SYSGET DDNAME=SYSUT1,RECFM=VB,EODAD=GETEOD2,BLKSIZE=4096,     X
               LRECL=4092
PUT      SYSPUT DDNAME=SYSPRINT,RECFM=FBA,BLKSIZE=1463,LRECL=133
*        TABLE FOR COUNTER NAMES AND OFFSETS TO COUNTERS
*        MAKES EASY TO ADD MORE LATER
         DS    0H
EODCNTS  DS    0CL16
         DC    CL16'TOTAL SIO 0',AL2(DVSIO0-DVTAB)
EODCNT1  EQU   *
         DC    CL16'TOTAL SIO 1',AL2(DVSIO1-DVTAB)
         DC    CL16'TOTAL SIO 2',AL2(DVSIO2-DVTAB)
         DC    CL16'TOTAL SIO 3',AL2(DVSIO3-DVTAB)
         DC    CL16'CYLINDERS SEEKED',AL2(DVTOTCYL-DVTAB)
         DC    CL16'         AVERAGE',AL2(DVAVGCYL-DVTAB)
         DC    CL16'AVERAGE IO MSEC',AL2(DVAVGIO-DVTAB)
         DC    CL16'MAX     IO MSEC',AL2(DVMAXIO-DVTAB)
         DC    CL16'HIGHEST HIT PT.',AL2(DVMAXHIT-DVTAB)
EODCNTE  EQU   *              END OF TABLE
*
*        ANOTHER TABLE TO DISPLAY EOJ TOTS BY DEVICE
         DS    0H
PRTCNTS  DS    0CL16
         DC    CL16'TOTAL REC IN',AL2(TOTRECIN-PACKS)
PRTCNT1  EQU   *
         DC    CL16'TOTAL SIO',AL2(TOTSIO-PACKS)
         DC    CL16'TOTAL IO ',AL2(TOTIO-PACKS)
         DC    CL16'TOTAL PCI',AL2(TOTPCI-PACKS)
         DC    CL16'TOTAL BAD',AL2(TOTBAD-PACKS)
         DC    CL16'TOTAL BYPASSED',AL2(TOTBYPAS-PACKS)
PRTCNTE  EQU   *
*
*        TABLE OF JOBS TO MONITOR CONTENTION AMONG THEM
JOBS     DS    0H
JOBS#CHR DS    0AL1
         DC    AL1(7)         L' -1 OF NAME
JOBSNAM  DS    0CL8
         DC    CL8'POPORDER'       JOBNAME
JOB1     EQU   *
         DC    AL1(6),CL8'PTSPOLE'
         DC    AL1(7),CL8'PTSTMAST'
         DC    AL1(2),CL8'PGM'
         DC    AL1(2),CL8'N/A'
         DC    AL1(4),CL8'OTHER'
JOBE     EQU   *
*
*        DEVICE CHARACTERISTICS TABLE
STCYLS   DS    0H                  TABLE OF DEVICE TYPE TO MAX. CYLS
         DC    X'0900'             DEVICE TYPE
STCYLMAX EQU   *
         DC    H'404'              MAX CYLS
STCYLNAM EQU   *
         DC    CL8'3330'           EBCDIC NAME
STCYLTRK EQU   *
         DC    H'19'               TRACKS PER CYLINDER
STCYLS1  DS    0H                  FOR SIZE OF ENTRY CALC
         DC    X'0D00',H'808',CL8'3330-1',H'19'
         DC    H'-1',H'9999',CL8'UNKNOWN',H'19'
****************** S T A T I C  C O N S T A N T S ********************
STMAXDSP DC    H'3'                MAX DIGITS IN DEV ARRAY REPT
STJOBDSP DC    H'8'                DIGITS IN JOB REPORT
LINESIZE DC    H'133'              REPORT LINE SIZE
LINEOFST DC    H'11'               OFFSET IN PRINTLINE FOR DATA
DVMAX    DC    H'200'              MAX DASDS IN SYSTEM
MAXJOB   DC    AL2((JOBE-JOBS)/(JOB1-JOBS)) MAX JOBNAMES TO MONITOR
JTSIZ    DC    AL2((JOBE-JOBS)*4/(JOB1-JOBS)) CORE FOR A JOBNAME ROW
SEEKINTF DC    H'20'               # OF CYLS MOVED FOR SIG. CONTENTION
MASK     DC    X'402020202020202020202120' EDIT MASK
MASK2    DC    X'40206B2020206B202120' EDIT MASK
LOGO     DC    C'M O P A R  M A P P E R'  CENTER OF HEADER
HDR2     DC    C'0   FROM  /   TO SLOT NUMBER'  HDR FOR DEV ARRAY DISP
         LTORG
         AIF   (&NOXYTEX).NOX2     SKIP IF NO XYTEX
         XYUTADTV
.NOX2    ANOP
*        EQUATES
*        U C B
UCBDVCLS EQU   18,1
UCBNAME  EQU   13,3
UCBUNTYP EQU   19,1
UCBVOLI  EQU   28,6
*        C V T
CVTILK1  EQU   X'24'
CVTILK2  EQU   X'28'
         TITLE 'D Y N A M I C  S T O R A G E'
DSA      DSECT
         DS    9D                  O/S SAVE AREA
DSAPARMS DS    F                   RES
PACKS    EQU   *                   START OF PACKED COUNTERS
TOTRECIN DS    PL4                 TOTAL RECS IN
TOTSIO   DS    PL4                 TOTAL SIO RECS
TOTIO    DS    PL4                 TOTAL IO RECS
TOTPCI   DS    PL4                 TOTAL PCI RECS
TOTBAD   DS    PL4                 TOTAL BAD RECS
TOTBYPAS DS    PL4                 TOTAL BYPASSES RECS
PACKE    EQU   *                   END OF PACKED COUNTERS
DVVROOT  DS    F                   PTR TO DEV VECTOR TABLE
DVVSIZE  DS    F                   SIZE OF DVV TABLE
DVSLOTS  DS    H                   # SLOTS FOR A PACK
DVSIZE   DS    F                   SIZE OF A DEVICE TABLE ENTRY
JTOFFSET DS    F                   JOB ARRAY OFFSET IN DEV TABLE
JTSIZE   DS    F                   JOB ARRAY SIZE
EODCURDV DS    F                   PLACE HOLDER DURING EOD
UTGETSAV DS    F                   UTILITY ROUTINE SAVE AREA
WD       DS    D                   DOUBLE WORD WORK AREA
@PL      DS    F                   PTR TO PRINT LINE
WE       DS    CL12                MAX SIZE DISPLAY AREA FOR NUMERICS
         DS    0H                  ALIGN
EXMVC    DS    XL6                 EXECUTED MVC INSTRUCTION
EXMVC2   DS    XL6                 EXECUTED MVC INSTRUCTION
EXMVC3   DS    XL6                 EXECUTED MVC INSTRUCTION
EODOVFLO DS    F                   MAX SIZE FIELD THAT CAN BE PRINTED
HDR1     DS    CL133               HEADER AREA
HDRDATE  EQU   HDR1+L'HDR1-22,22   HEADER DATE
HDRTIME  EQU   HDR1+L'HDR1-22-1-8,8      TIME
HDRTITLE EQU   HDR1+(L'HDR1/2)-(L'LOGO/2),L'LOGO  CENTER OF HDR
HDRUCB   EQU   HDR1+1,3            EBCDIC UCB ADDR
HDRTYPE  EQU   HDR1+5,8            EBCDIC DEV TYPE
HDRVOLI  EQU   HDR1+14,6           VOLSER
HDRCLR   EQU   HDR1+1,19           BLANK AREA
DSASIZE  EQU   *-DSA-72            SIZE OF DSA
         TITLE 'D E V I C E  T A B L E'
DVTAB    DSECT                     DEVICE TABLE
DVUCB    DS    CL3                 EBCDIC UCB ADDR
DVFLAG1  DS    X                   FLAG
DVTYPE   DS    CL8                 EBCDIC TYEP
DVVOLI   DS    CL6                 VOLSER
DVSIO0   DS    F                   SIO ZERO COUNT
DVSIO1   DS    F                   " 1
DVSIO2   DS    F                   " 2
DVSIO3   DS    F                   " 3
DVDELTA  DS    H                   CYLINDERS PER PRINT SLOT
DVTRK    DS    H                   TRACKS PER CYLINDER
DVLJOBI  DS    H                   LAST USER OF DEV(JOB TAB INDEX)
         DS    0D                  ALIGN
DVLTIME  DS    XL8                 TIME OF LAST SIO0(CALC I/O TIME)
DVLJOB   DS    CL8                 LAST JOB NAME
DVLROW   DS    F                   ROW OF ARRAY WHERE HEAD LEFT
DVJTROOT DS    F                   JOB ARRAY PTR
DVTOTCYL DS    F                   TOTAL CYLINDERS SEEKED
DVAVGIO  DS    F                   AVG. I/O TIME
DVMAXIO  DS    F                   MAX. I/O TIME
DVMAXHIT DS    F                   MAX. DEV ARRAY ENTRY
DVAVGCYL DS    F                   AVG. CYL. SEEKED
DVLSEEK  DS    XL8                 MBBCCHHR OF LAST SEEK
DVCURJOB DS    H                   INDEX TO CURRENT JOB USER
DVTOTTIM DS    2F                  RESV.
         DS    0F                  ALIGN
DVFIXSIZ EQU   *-DVTAB             SIZE OF FIXED DEV. TABLE AREA
DVXREF   EQU   *                   START OF SEEK ARRAY
         TITLE 'D E V I C E  V E C T O R  T A B L E '
DVVTAB   DSECT                     DEVICE VECTOR TABLE
DVVPTR   DS    F                   PTR TO DEVICE TABLES
DVVUCB   DS    H                   PTR TO UCB
DVVSIZ   EQU   *-DVVTAB            SIZE OF ENTRY
         TITLE 'G T F  R E C O R D S'
GTFREC   DSECT                     GTF RECORDS
GTLEN    DS    H                   LENGTH
         DS    H                   RESV
GTID     DS    X                   RECORD ID
GTFMT    DS    X                   FORMAT ID
GTTIME   DS    XL8                 TIME STAMP IF TIME=YES
GTEVNT   DS    XL2                 EVENT IDENTIFIER
GTASCB   DS    XL4                 PTR TO ACSB
GTCPUID  DS    XL2                 CPU ID
GTJOB    DS    XL8                 JOBNAME
GTSCCWR  DS    XL4                 REAL ADDR OF CCW
GTSCCWV  DS    XL4                 VIRT ADDR OF CCW
GTSPURGE DS    XL4                 CTRL BLK USED BY PURGE
GTSIOCC  DS    XL1                 SIO CONDITION CODE
GTSDEV   DS    XL2                 DEV ADDR
GTSCAW   DS    XL4                 CAW
GTSSTAT  DS    XL2                 STATUS
GTSSEEK  DS    XL8                 SEEK ADDR
GTSFLAG  DS    XL6                 FLAGS
*        I/O RECORD                ***************
         ORG   GTSCCWR             RE-ALIGN
GTIOPSW  DS    XL8                 I/O OLD PSW
GTIRQTCB DS    XL4                 RQE TCB
GTICSW   DS    XL8                 CSW
GTICCWR  DS    XL4                 REAL ADDR OF CCW
GTICCWV  DS    XL4                 VIRT "
GTISENSE DS    XL2                 SENSE
GTIDEV   DS    XL2                 DEVICE ADDR
GTIPURGE DS    XL4                 PURGE CTRL BLOCK
GTIFLAG  DS    XL9                 FLAGS
         END
