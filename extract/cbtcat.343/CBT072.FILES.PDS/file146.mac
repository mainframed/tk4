 TITLE 'PROGRAM TO SQUISH A DISK VOLUME'
         MACRO
&LABEL   CRASH
&LABEL   BAL   14,CRASH        GO TO CRASH ROUTINE
         MEND
         SPACE
         MACRO
&LABEL   WRTVTOC &LOC,&ADR,&IND
&LABEL   MVI   OUTER,0        CLEAR ERROR BYTE
         WRITE VTCOUTDB,DI,,&LOC+44,,&LOC,MF=E
         CHECK VTCOUTDB       WAIT TILL FINISHED
         AIF   (T'&IND NE 'O').OUT
         CLI   OUTER,0        SEE IF GOOD WRITE
         BE    *+8             GOODIE
         BAL   14,CRASH        GO CRASH
.OUT     ANOP
         AIF   (T'&ADR EQ 'O').OUT2
         L     14,VTCOUTDB+16  GET IOB ADDRESS
         IHBINNRA &ADR         GET PARM IN REG 1
         MVC   0(5,1),CCHHR(14) MOVE CCHHR OF ADDRESS
.OUT2    ANOP
         L     14,BLOCKAD      GET BLOCK #
         LA    14,1(14)        INCR
         ST    14,BLOCKAD      SAVE
         MEND
         SPACE
         MACRO
&LABEL   TTRABS &DCB,&ABSAD    CONVERT FROM TTR TO ABSOLUTE ADDRESS
&LABEL   L     1,&DCB+44       GET DEB ADDRESS
         LA    2,&ABSAD        GET ADDRESS OF ABSOULTE ADDRESS
         L     14,16           GET CVT ADDRESS
         L     15,X'1C'(14)    GET CONVERT ROUTINE ADDRESS
         LA    3,RGSAV         POINT TO SAVE AREA
         STM   9,13,0(3)       SAVE THEM
         BALR  14,15           GO TO IT
         LM    9,13,0(3)       RESTORE REGS.
         MEND
         SPACE 2
         MACRO
&LABEL   ABSTTR &DCB,&ABSAD    CONVERT FROM ABSOLUTE ADDRESS TO TTR
&LABEL   L     1,&DCB+44       GET DEB ADDRESS
         LA    2,&ABSAD        GET ADDRESS OF ABSOLUTE ADDRESS
         L     14,16           GET CVT ADDRESS
         L     15,X'20'(14)    GET CONVERT ROUTINE ADDRESS
         LA    3,RGSAV         GET ADDRESS OF SAVEA AREA
         STM   9,13,0(3)       SAVE REGS
         BALR  14,15           GO TO ROUTINE
         LM    9,13,0(3)       RESTORE REGS.
         MEND
         SPACE
         MACRO
&LABEL   READVTOC &LOC
&LABEL   POINT DISKIN,FULL     POINT AT RECORD
         MVI   OUTER,0        CLEAR ERROR
         READ  VTOCINDB,SF,,&LOC,MF=E
         CHECK VTOCINDB        WAIT TO STOP
         CLI   OUTER,0        MAKE SURE NO ERROR
         BE    *+8            IF NOT, GOODIE
         BAL   14,CRASH       OTHERWISE, GO CRASH
         MEND
         EJECT
COPYDISK CSECT
         USING *,15
         B     START           GO AROUND MESSAGE
         DROP  15
         DC    AL1(L'STRTMES)
STRTMES  DC    C'SQUISHVOL - CONTACT KARL BARNHARDT (LOC-CB) IF ANY PROB
               BLEMS'
         DC    C'MODIFIED TO SAVE VSAM FIELDS, AND SUPPORT 3330-11'
START    DS    0H  ....
         SAVE  (14,12)
         BALR  12,0            12 IS PROGRAM BASE
         USING *,12
         ST    13,SAVE+4       SAVE    13
         LA    11,SAVE
         ST    11,8(13)        SET FORWARD CHAIN
         LR    13,11
         USING SAVE,13
         MVI   FMT2,0                  USE FMT2 AS PARM FLAG
         L     2,0(1)                  GET PARM ADDRESS
         CLC   0(2,2),=H'4'            SEE IF 4 BYTES LONG
         BNE   NOPARM                  IF NOT, THEN FORGET IT
         CLC   2(4,2),=C'DSYS'         DSYS MEANS DON'T COPY TEMP DSS
         BNE   NOPARM                  IF NOT, THEN FORGET IT
         MVI   FMT2,255                TURN ON FLAG
NOPARM   EQU   *
         OPEN  (SYSPRINT,OUTPUT)
         RDJFCB DISKIN
         MVI   INJFCB,4        SET VTOC AS DSNAME
         MVC   INJFCB+1(43),INJFCB
         OPEN  DISKIN,TYPE=J   OPEN VTOC
         RDJFCB DISKOUT        SET UP OUTPUT VTOC
         MVI   OUTJFCB,4       SET UP VTOC AS DSNAME
         MVC   OUTJFCB+1(43),OUTJFCB
         OI    OUTJFCB+52,X'08'        DON'T WRITE BACK JFCB
         OPEN  (DISKOUT,UPDAT),TYPE=J  OPEN OUTPUT VTOC
         L     4,DISKOUT+44    GET DEB ADDRESSES
         L     5,DISKIN+44
         L     4,32(4)         GET UCB ADDRESSES
         L     5,32(5)
         MVC   WTOR+X'20'(6),28(5)     MOVE VOL SER #
         MVC   WTOR+X'2C'(6),28(4)     MOVE VOL SER #
         CLC   16(4,4),16(5)   SEE IF UCBS THE SAME
         BE    UCBSMTCH        IF SO, GOODIE
DUMP     EQU   *
         ABEND 1,DUMP          OTHERWISE BLAST OUT
UCBSMTCH EQU   *
         CLI   18(4),X'20'     MAKE SURE DIRECT ACCESS
         BNE   DUMP            IF NOT, THEN FORGET IT
 SPACE
ASKOP    EQU   *
         MVI   INECB,0         CLEAR ECB
         WTOR  MF=(E,WTOR)     SAK HIM
         WAIT  ECB=INECB       WAIT FOR ANSWER
         OI    FULL,X'40'      UP CASE REPLY
         CLI   FULL,C'Y'       DID HE SAY YES
         BE    OPSDYES         GOODIE
         CLI   FULL,C'N'       DID HE SAY NO
         BNE   ASKOP           IF NOT, THEN ASK HIM AGAIN
 SPACE
         LA    1,BDOPMES       GET ADDRESS OF MESSAGE
         BAL   11,WRTLINE      GO TELL USER
         L     13,SAVE+4       RESTORE REG 13
         RETURN (14,12),RC=8   RETURN WITH BAD RETURN CODE
 SPACE
OPSDYES  EQU   *
         ENQ   MF=(E,ENQL)     ENQ ON THE TWO VTOCS
 EJECT
         READ  VTOCINDB,SF,,VTOCIN,MF=E
         CHECK VTOCINDB
         SR    5,5             CLEAR 5
         IC    5,19(4)         GET LAST PART OD DEVICE TYPE
         SLL   5,1             MULT BY 2
         LH    5,DACYLS(5)     GET # OF CYLS
         STH   5,INCYLS
         STH   5,OUTCYLS
         MH    5,TRKPCYL       GET TOTAL # OF TRACKS
         STH   5,#TRKS         SAVE # OF TRACKS
         MVC   DS4VSAM,VTOCIN+76  SAVE VSAM FIELDS
         MVC   ABSAD,VTOCIN+45 GET TTR
         SR    0,0             OF LAST FMT 1
         ABSTTR DISKIN,ABSHD
         ST    0,LSTFM1        SAVE FOR FUTURE
 EJECT
         MVC   INDKAD,VTOCIN+45        MOVE LAST DS ADDRESS
         LH    5,INDKAD        GET CYL #
         MH    5,TRKPCYL       GET TRACK #
         AH    5,INDKAD+2      NOW HAVE REL TRK #
         MVC   OTDKAD,VTOCIN+107       MOVE EXTENT START
         LH    6,OTDKAD        GET CYL # OF START
         MH    6,TRKPCYL       GET TRACK #
         AH    6,OTDKAD+2      NOW HAVE REL TRK # OF START
         LA    5,1(5)          UP 1 FOR SUBTRACT
         SR    5,6             5 HAS # OF TRACKS
         SR    6,6             CLEAR 6
         IC    6,VTOCIN+74     GET DSCBS PER TACK
         MR    4,6             GET # OF DSCBS IN 5
         SLL   5,2             MULT 5 BY 4
         GETMAIN R,LV=(5)      GET CORE FOR DSCB LIST
         LA    1,0(1)          CLEAR HIGH BYTE
         S     1,=F'4'         REDUCE BY 4
         ST    1,DSLSTAD       SAVE ADDRESS-4
 EJECT
         POINT DISKIN,THIRD    POINT TO THIRD RECORD
         L     10,THIRD        GET FIRST TTR IN 10
         L     2,DSLSTAD       POINT TO DSLST
VTOCRD2  EQU   *
         LA    2,4(2)          UP TO BEGINNING
VTOCRD   EQU   *
         C     10,LSTFM1       SEE IF ON LAST DATA SET
         BNL   LFM1            IF SO, THEN START WORK
         READ  VTOCINDB,SF,,FMT1,MF=E
         CHECK VTOCINDB        WAIT FOR COMPLETION
         NOTE  DISKIN          GET TTR OF ONE JUST REASD
         LR    10,1            SAVE CURRENT TTR POINTER
         ST    1,0(2)          SAVE FOR FUTURE
         CLI   FMT1+44,X'F1'   SEE IF TYPE 1
         BNE   VTOCRD          IF NOT, READ AGAIN
         CLI   FMT2,255                TEST FOR TEMP DSNAME?
         BNE   NOTMPTST                IF NOT, THEN COPY IT
         CALL  TMPTST,(FMT1)           CALL THE ROUTINE
         LTR   15,15                   SEE IF WE COPY IT
         BNZ   VTOCRD                  IF NON-ZERO RETURN, DON'T COPY
NOTMPTST EQU   *
         MVI   3(2),0          CLEAR ENDING BYTE
         TM    FMT1+82,X'80'   IS THIS IS DATA SET
         BZ    NTIS01          IF NOT, SKIP SETTING BIT
         OI    3(2),X'80'      TURN ON IS BIT
NTIS01   EQU   *
         TM    FMT1+82,X'01'   IS IT UNMOVABLE
         BZ    NTVSM01         IF NOT, TRY VSAM
         CLC   =C'.SYM',FMT1+15      IS IT A COBOL SYM FILE?
         BE    NTABS01               YES-FORCE MOVABLE
         CLC   =C'.SYM',FMT1+14      IS IT A COBOL SYM FILE?
         BE    NTABS01               YES-FORCE MOVABLE
         OI    3(2),X'40'      TURN ON BIT
NTVSM01  DS    0H             TRY VSAM
         TM    FMT1+83,X'08'  ACB ORG
         BZ    NTABS01        NO - CONTINUE
         OI    3(2),X'40'     TURN UNMOVABLE BIT
NTABS01  EQU   *
         CLC   CTLG,FMT1       IS IT THE SYSCTLG DATA SET
         BNE   NOTCT01         IF NOT, DON'T FLIP BIT
         OI    3(2),X'20'      TURN ON CTLG BIT
NOTCT01  EQU   *
         TM    FMT1+94,X'C0'   SEE IF CYLINDER ALLOCATION
         BNO   NOTCYL01        IF NOT, DON'T FLIP BIT
         OI    3(2),X'10'      TURN ON CYLINDER BIT
         B     VTOCRD2         GO INCR AND READ
NOTCYL01 EQU   *
         OI    3(2),X'08'      TURN ON TRACK BIT
         B     VTOCRD2
         EJECT
LFM1     EQU   *
         MVC   0(4,2),ZEROES   MOVE ZEROES TO END OF LIST
         READ  VTCOUTDB,DI,,VTOCOUT+44,,VTOCOUT,MF=E
         CHECK VTCOUTDB        WAIT FOR COMPLETION
         EJECT
*        INITIALIZE FREE SPACE
*        MARK TRACK ZERO AS ALLOCATED
         MVI   FREESPAC,X'FF'
         MVC   STAD,VTOCOUT+107        GET VTOC START
         MVC   ENDAD,VTOCOUT+111       VTOC END
         LA    1,STAD          1 POINTS TO EXTENT
         BAL   14,ABSALC       GO ALLOCATE THE VTOC
         LH    14,ENDAD        GET VTOC ENDING CYLINDER
         MH    14,TRKPCYL      GET TRACK NUMBER
         AH    14,ENDAD+2      ADD IN TRACK
         STH   14,OTVTCEND     SAVE LAST TRACK NUMBER IN OUTPUT VTOC
         MVC   FMT4+76(L'DS4VSAM),DS4VSAM   RESTORE VSAM FIELDS
         SPACE 2
         OI    FMT4+58,X'84'   TURN ON BAD VTOC BITS
         XC    BLOCKAD,BLOCKAD CLEAR RECORD #
         WRTVTOC FMT4          REWRITE FMT4
         NI    FMT4+58,X'FF'-X'84'     WIPE OUT BAD BITS
         LA    14,2            SET UP FIR FIRSFT DSCB BLOCK
         STH   14,REC#         SAVE IT
         EJECT
         OPEN  (OUTDISK,OUTPUT,INDISK),TYPE=J  OPEN DISK PACKS
         GETMAIN R,LV=400*8    GET SPACE FOR READ COUNTS AND DATA
         LA    1,0(1)          WIPE OUT HIGH BYTE
         ST    1,RDCNTAD       SAVE ADDRESS
         MVI   RDCNTAD,X'08'   REPLACE TIC CCW
         LA    2,1600(1)       POINT 2 AT COUNT AREA
         LA    3,199           SET UP 199 READ COUNT CCWS
         LA    4,8             DATA LENGTH OF 8
INITCCW  ST    2,0(1)          STORE DATA ADDRESS IN CCW
         ST    4,4(1)          STORE LENGTH
         MVI   0(1),X'12'      MOVE IN READ COUNT CCW
         MVI   4(1),X'40'      PUT IN COMMAND CHAINING
         LA    1,8(1)          INCREMENT TO NEXT CCW
         LA    2,8(2)          INCREMENT TO NEXT DATA AREA
         BCT   3,INITCCW       KEEP DOING IT
         ST    3,0(1)          PUT IN ADDRESS
         MVI   0(1),X'03'      PUT IN NO-OP CCW
         ST    4,4(1)          PUT IN ANY LENGTH
         MVI   4(1),X'20'      TURN ON SILI BIT
         GETMAIN R,LV=22600    GET CORE FOR DATA AND CCWS
         ST    1,DACCWADI      SAVE ADDRESS
         MVI   DACCWADI,X'08'  PUT BACK TIC
         LA    1,1600(1)       POINT TO DATA AREA
         ST    1,DATADI        SAVE IT
         GETMAIN R,LV=22600    GET CORE FOR OUTPUT DATA & CCWS
         ST    1,DACCWADO      SAVE CCW ADDRESS
         MVI   DACCWADO,X'08' PUT TIC OP CODE BACK
         LA    1,1600(1)       GET 1 UP TO DATA AREA
         ST    1,DATADO        SAVE ADDRESS OF DATA AREA
         EJECT
         L     4,DSLSTAD       POINT TO DSLST
INC1     LA    4,4(4)          UPDATE 4
         CLC   0(4,4),ZEROES   ARE WE THROUGH
         BE    GETCTLG         IF SO, GO FIND AND COPY SYSCTLG
         TM    3(4),X'C0'      IS IT UNMOVABLE
         BZ    INC1            IF NOT, THEN LOOK AGAIN
         BAL   11,GETVTOCS     GO READ THE VTOCS OF DS
         SR    0,0             CLEAR 0
         LA    1,INEXTS        GET EXTENT ADDRESS
         LA    2,16            16 MAX EXTENTS
ABSTST1  EQU   *
         CLC   0(8,1),ZEROES   ARE WE FINISHED
         BE    ABSOUT1         IF SO, DON'T DO IT AGAIN
         BAL   14,ABSALC       GO ALLOC ABS
         AH    0,TRKALC        ACCUM TRACKS ALLOCATED
         LA    1,8(1)          INCR. 1
         BCT   2,ABSTST1       KEEP IT UP
         SPACE
ABSOUT1  MVC   OUTEXTS(16*8),INEXTS    MOVE ALL EXTENTS
         STH   0,TRKUSD        SAVE FOR PUTDS
         BAL   11,PUTDS        GO WRITE DSCBS
         MVI   3(4),0          CLEAR LIST
         B     INC1            GO LOOK FOR NEXT
         EJECT
GETCTLG  EQU   *
         SR    7,7
         LA    2,PFMT5         GET FMT 5 ADDRESS
         LH    15,#TRKS        GET # OF TRKS
         LA    14,1
         LA    3,FREESPAC(15)  POINT PAST LAST TRACK
         MVI   0(3),X'FF'      SET AS ALLOCATED
         BCTR  15,0            REDUCE TO LAST TRACK
         SR    3,3
LKFREE1  LA    5,FREESPAC(3)   GET ADDRESS OF NEXT TRACK
         CLI   0(5),X'FF'      SEE IF ALLOCATED
         BNE   FFREE           IF SO, GOODIE
LKUP1    BXLE  3,14,LKFREE1    KEEP LOOKING
         B     PFMT5OUT        GET OUT IF ALL TRACKS
FFREE    EQU   *
         STH   3,4(2)          SAVE EXTENT START
LKFREE2  LA    3,1(3)          UPDATE 3
         LA    5,FREESPAC(3)   GET ADDRESS OF NEXT TRACK
         CLI   0(5),X'FF'      IS THIS FREE
         BNE   LKFREE2         IF SO, KEEP GOING
         LR    6,3
         LH    9,4(2)          GET STARTING TRACK IN 9
         LH    10,TRKPCYL      GET TRACK PER CYL
         AR    9,10            ADD TO 9
         BCTR  9,0             REDUCE BY 1
         SR    8,8             CLEAR 8 FOR DIVIDE
         DR    8,10
         MR    8,10            NOW REG 9 HAS NEXT HIGHEST CYL ADDRESS
         SH    6,4(2)          GET TOTAL TRACKS
         SH    9,4(2)          GET # TRKS BEFORE CYL
         CR    9,6             SEE WHICH IS BIGGER
         BNH   FIGR1           IF MORE THAN 1 CYL BRANCH
         STH   6,6(2)          STORE THE #
         B     LKINC1
FIGR1    EQU   *
         STH   9,6(2)          SAVE TRKS BEFORE CYL
         LCR   9,9             SET 9 NEGATIVE
         AR    9,6             NOW HAVE TRACKS LEFT
         DR    8,10            GET CY  S AGAIN
         STH   8,10(2)         SAVE TRKS AFTER LAST CYL
         MR    8,10            GET BACK TO TRACKS ON CYL
         STH   9,8(2)          SAVE TRKS ON CYL BOUND
LKINC1   LA    2,12(2)         INCR. 2
         LA    7,1(7)          INCR. EXT #
         B     LKUP1           GO LOOK FOR NEXT FREE EXTENT
PFMT5OUT EQU   *
         STH   7,#FREXTS       SAVE # OF FREE EXTENTS
         L     9,PFMT5AD       GET EXTENT POINTER
         LA    8,12(9)         8POINTS TO NEXT ONE
         LA    6,25            ONE LESS THAN FMT5 CAN HAVE
FRSETUP  ST    8,0(9)
         LA    9,12(9)         INCR 9
         LA    8,12(8)         INCR 8
         BCT   6,FRSETUP       DO IT FOR ALL
         ST    2,FPFMT5AD      SAVE FIRST FREE POINTER
         SH    2,=H'12'        GET TO LAST USED ELEMENT
         XC    0(4,2),0(2)     WIPE OUT CHAIN POINTER
         EJECT
         SR    6,6             CLEAR REG 6
         LA    5,3             GO THROUGH 3 TIMES
GETDS    EQU   *
         STM   5,6,R5R6        SAVE REGS 5 & 6
         L     4,DSLSTAD       POINT TO DSLST
INC2     LA    4,4(4)          INCR LIST POINTER
         CLC   0(4,4),ZEROES   ARE WE AT END OF LIST
         BE    THISDONE
         L     6,R5R6+4        RESTORE REG 6
         EX    0,TEST(6)       MAKE THE TEST
         BZ    INC2            BRANCH TO LOOK AT NEXT DS
         BAL   11,GETVTOCS     GO READ THE VTOC
         XC    OUTEXT(16*8),OUTEXT     CLEAR EXTENT AREA
         LH    11,FMT1+98      GET TTR OF LAST WRITTEN BLOCK
         LA    0,1(11)         NOW HAVE # OF TRACKS USED
         CLC   CTLG,FMT1       IT THIS THE CATALOG DATA SET
         BNE   GOON99          IF NOT, THEN PLAY DUMB
         LH    0,BIGGIE        GET A BIG NUMBER FOR TRACKS USER
GOON99   EQU   *
         STH   0,TRKUSD        SAVE FOR LATER
         SR    15,15           CLEAR 15
         SR    1,1             CLEAR 1
         LA    2,16            MAX @ OF EXTENTS
CYLEXT1  SR    3,3             CLEAR 3
         C     3,INEXT(1)      IS THIS EXTENT GOOD
         BE    CYLOUT          IF NOT, THEN WE'RE FINISHED
         BAL   14,ALCDS        GO ALLOCATE THE EXTENT
         LA    15,1(15)        INCR EXTENT REG
         SH    0,TRKALC        SUBTRACT TRACKS ALLOC.
         BZ    CYLOUT          IF ZERO, DATA FITS ON THIS EXTENT
         BM    ADD1TRK         IF MINUS - ADD 1 FOR GOOD MEASURE
         LA    1,8(1)          INCR EXTENT POINTER
         BCT   2,CYLEXT1       KEEP IT UP
ADD1TRK  EQU   *
         LH    1,TRKUSD        GET USED TRKS
         LA    1,1(1)          ADD 1
         STH   1,TRKUSD        AND SAVE FOR COPIER
CYLOUT   EQU   *
         STC   15,FMT1+59      SAVE # OF EXTENTS
         CLC   CTLG,FMT1       IF THIS THE CATALOG DATA SET
         BNE   GOON100         IF NOT, THEN NORMAL
         LCR   0,0             MAKE NUM NEGATIVE
         AH    0,BIGGIE        NOW REG 0 HAS TRACKS ALLOCATED
         STH   0,TRKUSD        MOVE DS WILL USE THIS NUMBER
GOON100  EQU   *
         BAL   11,PUTDS        WRITE THE DATA SET
         MVI   3(4),0          CLEAR FLAG BYTE
         B     INC2            LOOK FOR NEXT DATA SET
THISDONE EQU   *
         LM    5,6,R5R6        REATORE REGS 5 & 6
         NI    OUTDISK+X'30',X'7F'     TURN OFF WRITE FLAG FOR CLOSE
         CLOSE (INDISK,,OUTDISK)       CLOSE BIGGIES
         XC    FMT5(140),FMT5  WIPE OUT FORMAT 5 DSCB
         LH    7,TRKPCYL       GET TRAKS PER CYL
         LA    8,FMT5+5        FIRST EXTENT LOC
         L     9,PFMT5AD       GET FIRST FORMAT 5 POINTER
         LA    14,26           MAX # OF FREE EXTENTS IN FORMAT 5
EXTST10  LTR   9,9             SEE IF GOOD EXTENT
         BZ    FMT5DONE        IF FINISHED GET OUT
         MVC   0(2,8),4(9)     MOVE EXTENT START
         SR    10,10           CLEAR 10
         LH    11,8(9)         GET TRKS ON CYL
         DR    10,7            GET CYLS
         STH   11,TCYL         STORE
         MVC   2(2,8),TCYL     MOVE TO EXTENT
         LH    11,6(9)         GET TRAKS BEFORE CYL
         AH    11,10(9)        ADD TRACKS AFTER LAST CYL
         STC   11,4(8)         SAVE IN EXTENT
         LA    8,5(8)          POINT TO NEXT EXTENT
         L     9,0(9)          POINT TO NEXT EXTENT
         BCT   14,EXTST10      KEEP MOVING
         CRASH ,               MORE THAN 26 FREE EXTENTS - DIE
FMT5DONE EQU   *
         L     14,VTCOUTDB+16  GET IOB ADDRESS
         MVC   FMT4+45(5),CCHHR(14)    MOVE CCHHR
         SR    8,8             CLEAR 8
         XC    FMT2(140),FMT2  WIPE OUT BIG AREA
WRT0     WRTVTOC FMT2,,A       WRITE A FMT0
         CLI   OUTER,0        SEE IF GOOD
         BNE   NOMORE          IF NOT, THEN WE RAN OUT OF ROOM
         LA    8,1(8)          ONE MORE GOOD FMT 0
         B     WRT0            GO TRY AGAIN
NOMORE   STH   8,FMT4+50       SAVE # OF AVAIL DSCB'S
         MVC   FMT5+4(40),FMT5+5       SET UP FMT5
         MVI   FMT5+44,X'F5'   PUT IN ID
         MVI   FMT5,5
         MVC   FMT5+1(3),FMT5  NOW HAVE GOOD FORMAT 5
         LA    9,1             GET REL REC # OF FMT5
         ST    9,BLOCKAD       SAVE
         WRTVTOC FMT5          WRITE OUT FMR 5
         XC    BLOCKAD,BLOCKAD CLEAR BLOCK ADDRESS
         WRTVTOC FMT4          WRITE IT OUT
         CLOSE (DISKIN,,DISKOUT)       CLOSE THE VTOCS
         LA    1,ENDMES        GET ADDRESS OF ENDING MESSAGE
         BAL   11,WRTLINE      GO WRITE IT
         CLOSE SYSPRINT
         DEQ   MF=(E,ENQL)     DEQ THE TWO VTOCS
         CALL  TRKTOT
         L     13,SAVE+4       RESTORE REG 13
         RETURN (14,12),RC=0   RETURN WITH GOOD RETURN CODE
         SPACE
CRASH    EQU   *
EX       EX    0,EX            BLOW WIHT 0C3
         EJECT
ABSALC   LH    11,0(1)         GET STARTING CYL
         MH    11,TRKPCYL
         AH    11,2(1)         GET STARTING TRL
         LH    10,4(1)         GET ENDING CYL
         MH    10,TRKPCYL
         AH    10,6(1)         ADD ENDING TRK
         LA    10,1(10)        INCR.
         SR    10,11           GET LENGTH
         STH   10,TRKALC       SAVE # OF TRACKS IN EXTENT
         LA    11,FREESPAC(11) GET FREE SPACE
ABSLOOP  EQU   *
         CLI   0(11),X'FF'     IS THIS TRACK ALREADY ALLOCATED
         BE    BADNEWS         IF SO, VTOC PROBABLY HERE
         MVI   0(11),X'FF'     SET IT ALLOCATED
         LA    11,1(11)        INCR. 11
         BCT   10,ABSLOOP      KEEP    IT UP
         BR    14              RETURN
 SPACE
BADNEWS  EQU   *
         ABEND 3,DUMP          KILL WITH A DUMP
         EJECT
*        THIS IS THE GETVTOCS SUBROUTINE
GETVTOCS MVC   FULL(3),0(4)    MOVE DSCB TTR
         MVI   FULL+3,0        CLEAR LAST BYTE
         READVTOC FMT1         READ THE DSCB
         XC    INEXTS(16*8),INEXTS     CLEAR EXTENTS
         LA    9,FMT1+105      POINT TO FIRST EXTENT
         LA    10,INEXTS       POINT TO IN CORE LIST
         LA    8,3             MAX OF THREE EXTENTS IN FMT 1
MVEXT11  MVC   0(8,10),2(9)    MOVE THE EXTENT
         LA    10,8(10)        INCR. 10
         LA    9,10(9)         INCR 9
         BCT   8,MVEXT11       KEEP IT UP
         LA    3,FMT1+135      ADDRESS FOR FMT 3 DSCB
         TM    3(4),X'80'      SEE IF IS
         BZ    NOTIS1          IF NOT, THEN FORGET IT
         CLC   0(L'ABSAD,3),ZEROES     IS THIS A ZERO CCHHR
         BE    NOTIS1                  IF SO THEN DON'T MESS
         MVC   ABSAD,0(3)      MOVE FMT2 ADDRESS
         SR    0,0             CLEAR 0
         ABSTTR DISKIN,ABSHD   GET TTR
         ST    0,FULL          SAE IT
         READVTOC FMT2         READ THE FORMAT2 DSCB
         LA    3,FMT2+135      POINT TO FMT 3 DSCB
NOTIS1   CLC   0(5,3),ZEROES   IS THERE A FMT 3
         BER   11              IF NONE, GO BACK
         MVC   ABSAD,0(3)      MOVE FMT3 POINTER
         SR    0,0             CLEAR 0
         ABSTTR DISKIN,ABSHD   CONVERT TO TTR
         ST    0,FULL          SAVE TTR
         READVTOC FMT3         READ THE DSCB
         LA    8,4             4 EXTENTS
         LA    9,FMT3+4        START OF 4TH EXTENT
MVEXT21  MVC   0(8,10),2(9)    MOVE AN EXTENT
         LA    10,8(10)        INCR 10
         LA    9,10(9)         INCR 9
         BCT   8,MVEXT21       KEEP IT UP
         LA    8,9             9 EXTENTS
         LA    9,FMT3+45       START OF 8TH EXTENT
MVEXT22  MVC   0(8,10),2(9)    MOVE THE EXTENT
         LA    10,8(10)        UPDATE 10
         LA    9,10(9)         UPDATE 9
         BCT   8,MVEXT22       KEEP IT UP
         BR    11              AND RETURN
         EJECT
PUTDS    EQU   *
PUTVTOCS LA    2,FMT1
         TM    3(4),X'80'      IS IT IS
         BZ    PTNOIS1         IF NOT, THEN FORGET IT
         LA    2,FMT2          GET FMT2 ADDRESS I N 2
PTNOIS1  EQU   *
         XC    135(5,2),135(2) WIPE OUT FMT 3 POINTER
         CLI   FMT1+59,3       ARE THERE MORE THAN 3 EXTENTS
         BNH   PTNOFMT3        IF <= 3 - NO FORMAT 3
         LA    5,FMT3+4        POINT TO FIRST
         LA    6,OUTEXTS+3*8   POINT TO THIRD EXTENT
         LA    7,4             FOUR EXTENTS
PT3MV1   MVC   2(8,5),0(6)     MOVE AN EXTENT
         CLC   0(8,6),ZEROES   SEE IF EXTENT IS ZERO
         BNE   GOON1           IF NOT, THEN GOOD
         XC    0(2,5),0(5)     WIPE OUT FIRST TWO BYTES
GOON1    EQU   *
         LA    5,10(5)         INCR 10
         LA    6,8(6)          INCR 6
         BCT   7,PT3MV1        KEEP IT UP
         LA    5,FMT3+45
         LA    7,9             9 EXTENTS DOWN HERE
PT3MV2   MVC   2(8,5),0(6)     MOVE AN EXTENT
         CLC   0(8,6),ZEROES   SEE IF EXTENT IS ZERO
         BNE   GOON2           IF NOT, THEN GOOD
         XC    0(2,5),0(5)     WIPR OUT FIRST TWO BYTES
GOON2    EQU   *
         LA    5,10(5)         INCR 5
         LA    6,8(6)          INCR 6
         BCT   7,PT3MV2
         WRTVTOC FMT3,135(2)   WRITE FORMAT3 AND MOVE ADDRESS
PTNOFMT3 TM    3(4),X'80'      SEE IF IS
         BZ    PTNOIS2         IF NOT, THEN FORGET IT
         WRTVTOC FMT2,FMT1+135 MOVE AND WRITE FORMAT 2
PTNOIS2  EQU   *
         LA    6,OUTEXT        POINT TO OUT EXTENT
         LA    5,FMT1+105      IN DSCB TOO
         LA    7,3             ONLY THREE EXTENTS IN FMT1
PT3MV3   MVC   2(8,5),0(6)     MOVE THE EXTENT
         CLC   0(8,6),ZEROES   SEE IF EXTENT IS ZERO
         BNE   GOON3           IF NOT, THEN GOOD
         XC    0(2,5),0(5)     WIPE OUT FIRST TWO BYTES
GOON3    EQU   *
         LA    6,8(6)          INCR 6
         LA    5,10(5)         INCR 5
         BCT   7,PT3MV3        KEEP MOVEIN G
         WRTVTOC FMT1          WRITE OUT THE FORMAT 1
         CLI   FMT1+59,0       ARE THERE NO EXTENTS
         BE    TELLDS          IF SO, JUST SAY WE COPIED IT
         EJECT
*        THIS CODE WILL COPY THE DATASET TRACK BY TRACK
         ST    11,R11          SAVE REG 11
         MVI   FKEOF,0        CLEAR FAKE END OF FILE SWITCH
         LA    5,INEXT         GET INPUT EXTENT ADDRESSS IN 5
         LA    6,OUTEXT        GET OUT EXTENT ADDRESS IN 6
         MVC   INDKAD,INEXT    MOVE FIRST EXTENT
         MVC   OTDKAD,OUTEXT   MOVE OUTPUT EXTENT
         MVC   FRSTSW,ZEROES   CLEAR SWITCHES
MVTRK    EQU   *
         STM   5,6,SVR5R6      SAVE REGS 5 & 6
         LA    7,RDCNTCCW      GET ADDRESS OF READ COUNT CCWS
         ST    7,INCCWAD       STORE IN IOB
         MVC   INCCHH,INDKAD   MOVE FIRST TRACK ADDRESS TO IOB
         CLC   INCCHH,ZEROES  SEE IF TRACK ZERO
         BNE   FRSTREAD       IF NOT, LET THE READ GO
         CLI   FKEOF,255      ONE FAKE EOF ALREADY?
         BE    IOABEND        IF SO, KILL US
         MVI   FKEOF,255      TURN ON FAKE EOF
         L     2,DACCWADI     GET ADDRESS OF READ R0
         MVI   16(2),3        PUT IN NO-OP AT 3RD CCW
         MVI   20(2),X'20'    TURN ON SLI BIT IN NO-OP CCW
         MVC   14(2,2),=H'8'  MOVE IN LENGTH FOR EOF RECORD
         MVI   23(2),1        MAKE LENGTH AT LEAST 1 IN NO-OP CCW
         L     3,DATADI       ADDRESS OF DATA
         XC    0(24,3),0(3)   WIPE OUT DATA AREA
         MVI   12(3),1         PUT IN RECORD 1
         B     NOALT          GO LOOK AT LAST WRITE
FRSTREAD EQU   *
         MVI   INECB,0         CLEAR ECB
         MVI   INIOB,X'42'     SET CC & UNREL BITS
         EXCP  INIOB           READ COUNTS ON THIS TRACK
         WAIT  ECB=INECB       WAIT FOR I/O TO COMPLETE
         CLI   INECB,X'41'     SEE IF ERROR DETECTED
         BNE   IOABEND         IF NOT, THEN SOMETHING WRONG
         CLI   INIOB+3,X'08'   SEE IF NO RECORD FOUND
         BNE   IOABEND         IF NOT, THEN KILL
         L     7,INCSW         GET LAST CCWADDRESS+8
         LA    7,0(7)          CLEAR HIGH BYTE
         L     8,RDCNTAD       GET COUNT AREA ADDRESS
         LA    8,0(8)          CLEAR I/O OP CODE
         SR    7,8             SUBTRACT STARTING ADDRESS
         BNP   IOABEND         IF NOT POSITIVE KILL
         SRL   7,3             DIVIDE BY 8
         LR    11,7            SAVE REG 7
         L     3,DATADI        GET INPUT DATA ADDRESS IN O
         L     2,DACCWADI      GET ADDRESS OF INPUT CCWS
         L     8,RDCNTAD       GET ADDRESS OF FIRST CCWS
         LA    8,1600(8)       POINT TO COUNT AREAS
         LA    9,8             DATA LENGTH OF RECORD 0
         ST    3,0(2)          STORE ADDRESS
         MVI   0(2),X'06'      PUT IN READ DATA
         SR    15,15                   CLEAR 15 FOR RECORD # COMPARE
         B     ADDLNGTH        GO TO MAIN ROUTINE
INSETUP  EQU   *
         LA    15,1(15)                INCR. 15 FOR RECORD # COMPARE
         EX    15,RECOMP               MAKE SURE RECORD NUMBER THE SAME
         BNE   CNTDN                   IF NOT THE SAME THEN QUIT
         ST    3,0(2)          STORE DATA ADDRESS INTO CCW
         MVI   0(2),X'1E'      PUT IN READ CKD
         LA    9,8             START COUNT WITH 8 BYTES CCHHRKDD
         SR    1,1             CLEAR 1 FOR IC
         IC    1,5(8)          GET KEYLENGTH IN 1
         LH    10,6(8)         GET DATA LENGTH
         LA    8,8(8)          POINT 8 AT NEXT COUNT AREA
         AR    1,10            GET KEY+DATA IN
         LTR   10,10           SEE IF DATA LENGTH NON-ZERO
         BNZ   LNGTHOK         IF NOT EOF GOODIE
         SR    1,1             CLEAR 1
         MVI   0(2),X'12'      CHANGE TO READ COUNT
LNGTHOK  AR    9,1             GET TOTAL LENGTH IN 9
ADDLNGTH EQU   *
         ST    9,4(2)          STORE LENGTH IN CCW
         MVI   4(2),X'40'      TURN ON CC BIT
         AR    3,9             GET 3 UP TO NEXT DATA AREA
         LA    2,8(2)          POINT 2 AT NEXT CCW
         BCT   7,INSETUP       KEEP GENERATING
CNTDN    EQU   *
         XC    0(8,2),0(2)     CLEAR NEXT CCW
         MVI   0(2),X'03'      SET UP NO-OP
         ST    9,4(2)          MAKE LENGTH NON-ZERO
         MVI   4(2),X'20'      TURN ON SLI BIT
TRYRAGN  EQU   *
         L     2,DATADI        GET ADDRESS OF INPUT
         MVI   INECB,0         CLEAR ECB
         MVI   INIOB,X'42'     TURN ON CC&UNRELATED BIT
         LA    15,RDDACCW      GET DATA READ CCW ADDRESS
         ST    15,INCCWAD      STORE INTO INPUT IOB
         EXCP  INIOB           READ THE WHOLE TRACK
         WAIT  ECB=INECB       WAIT FOR IT
         CLI   INECB,X'7F'     LOOK GOOD?
         BE    NOALT           IF GOOD, THEN ALL IS WELL
         CLI   INECB,X'41'     COMPLETE WITH ERRORS
         BNE   IOABEND         IF NOT, THEN KILL
         CLC   INCSW+4(2),=X'0C40'     SEE IF INCOR. LNGTH WITHOUT UC
         BNE   IOABEND         IF NOT, THEN BLOW OFF
         MVI   OVSW,255        TURN ON OVERFLOW SWITCH
NOALT    EQU   *
         CLI   FRSTSW,0        SEE IF WE'VE WRITTEN YET
         BE    ARND1           IF NOT, THEN DON'T WAIT ON LAST
OWAIT    EQU   *
         TM    OUTECB,X'40'    HAS LAST WRITE FINISHED
         BO    NOWAIT          IF SO, THEN GO AROUND WAIT
         WAIT  ECB=OUTECB      WAIT FOR WRITE TO FINISH
NOWAIT   EQU   *
         CLI   OUTECB,X'7F'    WAS LAST WRITE GOOD
         BNE   IOABEND         IF NOT, THEN KILL THYSELF
         L     7,DATADO        GET STARTING ADDRESS OF OUTPUT R0 DATA
         L     6,DACCWADO      GET ADDRESS OF WRITE CCWS
         CLC   INR0DATA,0(7)   SEE IF EQUAL TO INPUT
         BE    OTR0GOOD        IF SO, WE'RE HAPPY
         MVC   0(8,7),INR0DATA         MOVE ALL OF R0 DATA
         CLI   R0FLAG,255              SEE IF FIRST PART IS DASD ADDR
         BNE   STWRTR0                 IF NOT, THEN START WRITE
         MVC   0(4,7),OUTCCHH          MOVE IN OUTPUT DASD ADDR
STWRTR0  EQU   *
         MVI   0(6),X'05'      CHANGE TO WRITE DATA
         MVI   4(6),X'00'      TURN OFF COMMAND CHAIN
         MVI   OUTIOB,X'42'    SET CC & UNRELATED
         CALL  R0WRT
         EXCP  OUTIOB          WRITE R0 DATA
         WAIT  ECB=OUTECB      WAIT FOR IT TO STOP
         CLI   OUTECB,X'7F'    SEE IF GOOD
         BNE   IOABEND         IF NOT, WIPE OUT
OTR0GOOD EQU   *
         CLI   LSTSW,0         SEE IF THAY WAS
         BNE   DSCOMPLT        IF SO, WE'RE FINISHED
         CLC   OTDKAD,ZEROES   IS OUTPUT ADDRESS ZERO
         BE    DSCOMPLT        IF SO, NO MORE OF THIS DATA SET
ARND1    EQU   *
         L     7,DATADO        GET ADDRESS OF TRACK OUTPUT DATA
         L     6,DACCWADO      GET ADDRESS OF WRITE CCWS
         L     2,DACCWADI      GET ADDRESS OF READ CCWS
         B     GSOCCW          GO PAST SOME CODE THE FIRST TIME
GENOCCW  EQU   *
         L     3,0(2)          GET CCHH AREA OF COUNT IN INPUT DATA
         MVC   0(4,3),OTDKAD   PUT IN NEW DASD ADDRESS
GSOCCW   EQU   *
         ST    7,0(6)          SAVE DATA ADDRESS IN OUPUT CCW
         MVI   0(6),X'1D'      PUT IN WRTIE CKD CCW
         LH    9,6(2)          GET LENGTH FROM READ CCW
         ST    9,4(6)          STORE IN WRTIE CCW
         MVI   4(6),X'40'      TURN ON CC BIT
         AR    7,9             7 NOW POINTS AT NEXT DATA AREA
         LA    6,8(6)          POINT 6 AT NEXT OUTPUT CCW
         LA    2,8(2)          POINT 2 AT NEXT INPUT CCW
         CLI   0(2),X'03'      IS THIS A NO-OP CCW
         BNE   GENOCCW         IF NOT, KEEP GENERATING
         CLI   OVSW,255        SEE IF WE HAVE AN OVERFLOW SEGMENT
         BNE   NOOV            IF NOT, THEN FORGET IT
         L     1,=F'-8'        SET UP 1
         AR    1,6             POINT 1 TO LAST WRITE CCW
         MVI   0(1),X'01'      CHANGE TO SPECIAL WRITE CKD
         MVI   OVSW,0          CLEAR THE SWITCH
NOOV     EQU   *
         MVC   0(8,6),0(2)     MOVE THE NO-OP CCW
         L     3,DACCWADO      GET ADDRESS OF FIRST OUTPUT CCW
         MVI   0(3),X'06'      CHANGE TO READ OUTPUT TRACK R0
         L     6,DATADO        GET START OF OUTPUT DATA
         L     2,DATADI        GET START OF INPUT ADDRESS IN 2
         SR    7,6             GET LENGTH OF TRACK DATA IN R7
         LR    3,7             GET LENGTH IN 3 ALSO
         MVCL  6,2             MOVE A TRACKS WORTH OF DATA
         MVC   OUTCCHH,OTDKAD  MOVE NEXT TRACK ADDRESS TO IOB
         MVI   OUTECB,0        CLEAR ECB
         MVI   OUTIOB,X'42'    SET CC & UNRELATED
         CALL  TRKWRT
         EXCP  OUTIOB          WRITE THE WHOLE TRACK
         L     15,DATADI       GET ADDRESS OF INPUT DATA
         MVC   INR0DATA,0(15)  MOVE INPUT R0 DATA
         MVI   R0FLAG,0                CLEAR R0 FLAG
         CLC   INCCHH,INR0DATA         SEE IF TRACK ADDR IN R0
         BNE   NTTRKAD                 IF NOT, THEN FORGET IT
         MVI   R0FLAG,255              TURN ON THE FLAG
NTTRKAD  DS    0H
         MVI   FRSTSW,X'FF'    RESET FIRST WRITE SWITCH
         LH    9,TRKUSD        GET TRACKS USED
         BCT   9,NXTRK         REDUCE BY 1
         MVI   LSTSW,X'FF'     SET LAST WRITE SWITCH
         B     OWAIT           GO WAIT FOR LAST WRITE TO STOP
NXTRK    EQU   *
         STH   9,TRKUSD        SAVE REMAINING TRACKS
         LM    5,6,SVR5R6      RESTORE REGS 5 & 6
         LH    9,INDKAD+2      GET INPUT TRACK ADDR
         LA    9,1(9)          INCR BY 1
         CH    9,TRKPCYL       CHECK WITH HIGHEST TRACK
         BL    INTRKGD         IF LOW, GOOS
         LH    9,INDKAD        GET CYL #
         LA    9,1(9)          INCR
         STH   9,INDKAD        STORE BACK
         SR    9,9             CLEAR TRK #
INTRKGD  STH   9,INDKAD+2      SAVE TRACK #
         CLC   INDKAD,4(5)     CHECK EXTENT
         BNH   INEXTOK         IF NOT HIGH THIS EXTENT STILL GOOD
         LA    5,8(5)          POINT AT NEXT EXTENT
         MVC   INDKAD,0(5)     MOVE FIRST TRACK ADDR OF THIS EXTENT
INEXTOK  EQU   *
         LH    9,OTDKAD+2      GET OUTPUT TRACK #
         LA    9,1(9)          INCR
         CH    9,TRKPCYL       CHECK WITH HIGHEST TRACK
         BL    OTTRKGD         IF LOW, GOOD
         LH    9,OTDKAD        GET CYLINDER #
         LA    9,1(9)          INCR
         STH   9,OTDKAD        STORE CYL# BACK
         SR    9,9             CLEAR 9
OTTRKGD  EQU   *
         STH   9,OTDKAD+2      SAVE TRK
         CLC   OTDKAD,4(6)     CHECK WITH EXTENT END
         BNH   OTEXTOK         IF NOT HIGH, ALL IS WELL
         LA    6,8(6)          POINT TO NEXT EXTENT
         MVC   OTDKAD,0(6)     MOVE NEW EXTENT START
OTEXTOK  EQU   *
         B     MVTRK           GO MOVE NEXT TRK
RECOMP   CLI   4(8),0                  MAKE RECORD # COMPARE
DSCOMPLT EQU   *               FINISHED COPYING DATA SET
         L     11,R11          RESTORE R11
TELLDS   EQU   *
         MVC   DSNAME,FMT1     MOVE DATA SET NAME
         LA    1,DSNAME-1      GET ADDRESS
         EJECT
WRTLINE  EQU   *
         LR    6,1             SAVE PARM REG
         IC    7,0(6)          GET ORIG CC
         CP    LINE#,=P'55'    SEE IF PAST END OF PAGE
         BNH   LINEOK
         AP    PAGE#,=P'1'     ADD 1 TO PAGE NUMBER
         OI    PAGE#+L'PAGE#-1,X'0F'   MAKE LAST DIGIT READABLE
         UNPK  PAGE#UP,PAGE#
         PUT   SYSPRINT,HEADER WRITE HEADER PAGE
         MVI   0(6),C'-'       MOVE IN PROPER CC
         ZAP   LINE#,=P'1'     START LINE # AT 1
         B     PUTIT           GO WRITE IT
IOABEND  ABEND 2,DUMP          I/O ERROR - BLOW
         SPACE 2
SAVE     DS    18F            MY SAVE AREA
         EJECT
ALCDS    EQU   *               THIS ROUTINE ALLOCATES EXTENTS
         STM   15,2,RGSAV      SAVE 15-2
         LH    10,TRKPCYL      GET TRACKS PER CYLINDER IN 10
         L     11,=F'-1'
         AR    11,10           11 HAS LAST TRACK ADDR. ON CYL
         LH    3,INEXT+4(1)    GET ENDING CYL
         MR    2,10            GET REL CYL START
         TM    3(4),X'28'      NOT CYLINDER?
         BNZ   JUSTAD          IF NOT, ADD IN TRACKS
         AR    3,11            GET UP TO LAST TRK
         B     ALCOMM
JUSTAD   AH    3,INEXT+6(1)    ADD IN LAST TRACK
ALCOMM   LA    3,1(3)          NOW HAVE # OF LAST TRACK
         LH    7,INEXT(1)      GET STARTING CYL
         MR    6,10            GET REL CYL START
         TM    3(4),X'28'      CYLINDER?
         BZ    ALNOAD1         IF SO, BRANCH
         AH    7,INEXT+2(1)    ADD IN FIRST TRK
ALNOAD1  SR    3,7             3 HAS # OF TRKS TO ALLOCATE
         STH   3,TRKALC        SAVE TRACKS ALLOCATED
         L     6,PFMT5AD       GET START OF FREE EXTENT LIST
         LA    15,PFMT5AD      GET ADDRESS OF FORMAT 5 ADDRESS
SPCLOK1  EQU   *
         TM    3(4),X'20'      SYSCTLG DATA SET?
         BZ    NTCTLG02        IF NOT, NORMAL ALLOC
         CLC   OTVTCEND,4(6)   SEE IF EXTENT PAST VTOC
         BNL   LKNXTFRE        IF NOT, LOOK AT NEXT FREE EXTENT
NTCTLG02 EQU   *
         LH    5,8(6)          GET TRKS ON CYL
         AH    5,10(6)         ADD LEFT OVER TRKS O END
         TM    3(4),X'10'      IS THIS FOR CYLINDER
         BO    ALNOAD2
         AH    5,6(6)          ADD IN TRKS BEFORE CYL
ALNOAD2  CR    3,5             SEE IF ENOUGH SPACE
         BNH   SPCFND1         IF SO, WE'RE IN
LKNXTFRE EQU   *
         LR    15,6           SAVE REG. 6
         L     6,0(15)         POINT TO NEXT  FREE EXTENT
         LTR   6,6             MAKE SURE SOME LEFT
         BNZ   SPCLOK1         OH GOODIE
         CRASH , IF NOT, THEN KILL THYSELF
SPCFND1  LH    9,4(6)          GET EXTENT START
         TM    3(4),X'10'      IS IT CYLINDER
         BNO   ALNOAD3
         AH    9,6(6)          ADD TRKS BEFORE CYL
ALNOAD3  LR    0,9             SAVE #
         SR    8,8             CLEAR 8 FOR DIVIDE
         DR    8,10            GET STARTING EXTENT ADDRESS
         STH   9,OUTEXT(1)     SAVE CYL START
         STH   8,OUTEXT+2(1)   & TRK START
         LR    9,0             GET START BACK
         AR    9,3             ADD IN # OF TRKS
         BCTR  9,0             REDUCE TO LAST TRACK ADDRESS
         SR    8,8             CLEAR 8 AGAIN
         DR    8,10            GET ENDING TRACK ADDRESS
         STH   9,OUTEXT+4(1)   SAVE ENDING CYL
         STH   8,OUTEXT+6(1)   SAVE    ENDING TRACK
         L     7,FPFMT5AD      GET START OF FERE AREA
         TM    3(4),X'10'      SEE IF CYLINDER ALLOCATION
         BNO   NOHDTRKS        IF NOT,AT BEGINNING
         SR    8,8             CLEAR 8 FOR COMPARE
         CH    8,6(6)          SEE IF TRKS BEFORE CYL IS ZERO
         BE    NOHDTRKS        IF NOT, THEN GET OUT
         LH    2,4(6)          GET EXTENT START
         AH    2,6(6)          ADD TRKS BEFORE CYL
         AR    2,3             ADD TRACKS ALLOCATED
         STH   2,4(7)          SAVE START OF NEW EXTENT
         LH    2,8(6)          GET # OF CYLS BEFORE ALLOC
         SR    2,3             SUBTRACT THOSE ALLOC
         STH   2,8(7)          SAVE THEM IN NEW EXTENT
         AH    2,10(6)         ADD IN EXTRA TRACKS
         BZ    FXTHSEXT        IF ZERO, NO NEW EXTENT
         MVC   10(2,7),10(6)   MOVE EXTRA TRACKS OVER
         MVC   FPFMT5AD,0(7)   MOVE FREE POINTER
         MVC   0(4,7),0(6)     MOVE EXT POINTER
         ST    7,0(6)          KEEP LINKING
         XC    6(2,7),6(7)     WIPE OUT TRKS BEFORE CYL
FXTHSEXT XC    8(4,6),8(6)     WIPE OUT CYLS & EXT TRKS
         B     BLASTOUT        GO BACK
NOHDTRKS EQU   *
         LH    2,4(6)          GE T EXTENT START
         AR    2,3             UP TO WHERE EXTENT WOULD END
         STH   2,4(6)          SAVE NEW EXTENT START
         LH    2,8(6)          GET # OF ORIG TRKS
         AH    2,6(6)          ADD IN TRKS BEFORE CYL
         SR    2,3             SUBTRACT THOSE ALLOCATEDC
         BP    HITIT1          IF A GOOD NUMBER, USE IT
         AH    2,10(6)         ADD IN TRKS AFTER CYL
         MVC   8(4,6),ZEROES   CLEAR IT AND ONE BEFORE
         BP    HITIT2          GO STORE TRLS
         BZ    GIVEBACK        GIVE BACK EXTENT IF ZERO
         CRASH ,               IF HERE - A REAL GOOF
HITIT1   EQU   *
         LR    3,2             LOAD 3 WITH LEFT OVER TRACKS
         SR    2,2             CLEAR 2 FOR DIVIDE
         DR    2,10            GET CYLS AND LEFT OVER TRACKS
         MH    3,TRKPCYL       GET BACK TRACKS ON CYL BOUNDARY
         STH   3,8(6)          STORE TRACKS ON CYL BOUNDARY
HITIT2   EQU   *
         STH   2,6(6)          STORE TRACKS BEFORE CYL
         B     BLASTOUT        GET OUT
GIVEBACK EQU   *
*        IF ZERO WE JUST USED UP AN EXTENT & HAVE TO GIVE IT BACK
         XC    4(8,6),4(6)     WIPE OUT EXTENT INFO
         L     2,0(6)          GET NEXT ENTRY POINTER
         ST    2,0(15)         STORE IT IN LAST ENTRY
         ST    7,0(6)          SAVE IN MINE
         ST    6,FPFMT5AD      MAKE NEW START
BLASTOUT EQU   *
         LM    15,2,RGSAV      RESTORE 15-2
         BR    14              &RETURN
         SPACE
         DROP  13,12          DROP OLD BASE REGS
IOER     EQU   *              I/O ERROR ROUTINE
         USING *,15           15 IS BASE FOR A WHILE
         MVI   OUTER,255      INDICATE ERROR
         BR    14             AND RETURN
         EJECT
VTOC     DC    CL8'SYSVTOC'    MAJOR QUEUE NAME
HEADER   DC    CL121'1DISK SQUISHER'
         ORG   *-8
         DC    C'PAGE '
PAGE#UP  DS    CL3
         ORG
         DC    CL121' '
         ORG   *-120
DSNAME   DS    CL44
         DC    C'  COPIED SUCCESSFULLY'
         ORG
PAGE#    DC    PL3'0'
LINE#    DC    P'60'
ENDMES   DC    CL121'0DISK SQUISHER COMPLETE'
ENQL     ENQ   (VTOC,WTOR+X'20',E,6,SYSTEM,VTOC,WTOR+X'2C',E,6,        +
               SYSTEM),MF=L
WTOR     WTOR  'OK TO SQUISH VOLUME XXXXXX ONTO YYYYYY ?',FULL,3,      +
               INECB,MF=L
BDOPMES  DC    CL121' OPERATOR DENIED YOUR REQUEST TO SQUISH VOLUME.'
R5R6     DS    2F
CTLG     DC    CL44'SYSCTLG'   NAME OF CATALOG DATA SET
BIGGIE   DC    H'10000'
OTVTCEND DS    H               LAST TRACK NUMBER IN OUTPUT VTOC
OUTER    DS    X              IOERROR BYTE
R0FLAG   DS    X
         DS    0D
ABSHD    DC    AL3(0)
ABSAD    DS    XL5
LSTFM1   DS    F
THIRD    DC    AL3(3),AL1(0)
ZEROES   DC    XL8'0'
OVSW     DC    X'0'            OVERFLOW SWITCH
FKEOF    DS    X
#TRKS    DS    H
FULL     DS    F
STAD     DS    F
ENDAD    DS    F
R11      DS    F
INDKAD   DS    F
OTDKAD   DS    F
DSLSTAD  DS    A
RGSAVE   DS    18F
PFMT5AD  DC    A(PFMT5)
FPFMT5AD DS    A
PFMT5    DC    (26*3)F'0'
INDISK   DCB   MACRF=E,DDNAME=SYSUT1,EXLST=INJFCBAD,EOEA=WA,           X
               IOBAD=INIOB
OUTDISK  DCB   MACRF=E,DDNAME=SYSUT2,EXLST=OTJFCBAD,EOEA=WA,           X
               IOBAD=OUTIOB
BLOCKAD  DC    F'0'
REC#     EQU   BLOCKAD+2
CCHHR    EQU   X'23'           OFFSET OF CCHHR IN IOB
FMT1     DS    140C
FMT2     DS    140C
FMT3     DS    140C
FMT5     DS    140C
VTOCOUT  DS    140C
FMT4     EQU   VTOCOUT
VTOCIN   DS    140C
DACYLS   DC    H'0,200,25,80,246,980,48,96,200,404,0,0,0,808'
DS4VSAM  DC    CL22' '            FORMAT 4 VSAM FIELDS
#EXTS    DS    H
TCYL     DS    H
TRKALC   DS    H
TRKUSD   DS    H
INEXTS   DC    16D'0'
OUTEXTS  DC    16D'0'
OUTEXT   EQU   OUTEXTS
INEXT    EQU   INEXTS
DISKIN   DCB   DSORG=PS,MACRF=RP,DDNAME=SYSUT1,RECFM=F,KEYLEN=44,      +
               LRECL=96,BLKSIZE=96,EXLST=INJFCBAD
INJFCBAD DS    0F
         DC    X'87'
         DC    AL3(INJFCB)
INJFCB   DS    44F
         READ  VTOCINCB,SF,DISKIN,MF=L
DISKOUT  DCB   DSORG=DA,MACRF=(RIC,WIC),DDNAME=SYSUT2,OPTCD=R,         +
               RECFM=F,KEYLEN=44,BLKSIZE=96,EXLST=OTJFCBAD,SYNAD=IOER
OTJFCBAD DS    0F
         DC    X'87'
         DC    AL3(OUTJFCB)
OUTJFCB  DS    44F
         READ  VTCOUTDB,DI,DISKOUT,,'S',,BLOCKAD+1,MF=L
         EJECT
INIOB    DS    0D
         DC    X'42'           CC AND UNRELATED
         DS    XL3
         DC    A(INECB)
INCSW    DC    2A(0)
INCCWAD  DS    A
         DC    A(INDISK)
         DC    2A(0)
         DC    XL3'0'
INCCHH   DC    XL4'0'
         DC    X'0'
         DC    C'SQUV'
         DC    A(VTOCIN)
INCYLS   DS    H
INECB    DC    F'0'
OUTIOB   DS    0D
         DC    X'42'
         DS    XL3
         DC    A(OUTECB)
OUTCSW   DC    2A(0)
         DC    A(OUTCCW)       ADDRESS OF OUTPUT CCW
         DC    A(OUTDISK)
         DC    2A(0)
         DC    XL3'0'
OUTCCHH  DC    XL4'0'
         DC    X'0'
         DC    C'SQUV'
         DC    A(FMT4)
OUTCYLS  DS    H
OUTECB   DC    F'0'
NOREC    EQU   X'20'
OUTCCW   CCW   X'31',OUTCCHH,X'40',5   SEARCH FOR RECORD 0
         CCW   X'08',OUTCCW,0,0        KEEP LOOKING
DACCWADO CCW   X'08',0,0,0     THIS TIC WILL BE MODIFIED BY PROG
RDDACCW  CCW   X'31',INCCHH,X'40',5    LOOK FOR RECORD 0
         CCW   X'08',RDDACCW,0,0       TIC *-8
DACCWADI CCW   X'08',0,0,0     TIC TO GOTMAIN CCW
RDCNTCCW CCW   X'31',INCCHH,X'40',5    SEARCH FOR RECORD 0
         CCW   X'08',RDCNTCCW,0,0
RDCNTAD  CCW   X'80',0,0,0     WILL BE FILLED IN BY INIT ROUTINE
DATADI   DS    F               ADDRESS OF INPUT DATA
DATADO   DS    F               ADDRESS OF OUTPUT DATA
FRSTSW   DS    CL2
LSTSW    EQU   FRSTSW+1
SVR5R6   DS    2F              OTHER SAVE AREA FOR REGS 5 & 6
INR0DATA DS    CL8
         EJECT
SYSPRINT DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,RECFM=FBA,LRECL=121,  +
               BLKSIZE=968
         LTORG
FREESPAC DC    15352X'0'        EVERYTHING UNALLOCATED AT FIRST
         DC    X'FF'           TO INSURE THE END
VTOCINDB EQU   VTOCINCB
RGSAV    EQU   RGSAVE
#FREXTS  EQU   #EXTS
TRKPCYL  EQU   VTOCIN+64
#CYL     EQU   VTOCIN+62
         LTORG
*        END   COPYDISK
         TITLE 'SUBROUTINES       -       R0WRT/TRKWRT/TRKTOT'
SQUSTAT  CSECT
         ENTRY R0WRT,TRKWRT,TRKTOT
R0WRT    DS    0H
         USING *,15
         SAVE  (14,12)
         LA    2,R0TOT
         B     SCOMMON
         DROP  15
TRKWRT   DS    0H
         USING *,15
         SAVE  (14,12)
         LA    2,TKTOT
         DROP  15
SCOMMON  BALR  12,0
         USING *,12
         L     3,0(2)
         LA    3,1(3)
         ST    3,0(2)
         RETURN                        (14,12),RC=0
         DROP  12
TRKTOT   DS    0H
         SAVE  (14,12)
         LR    12,15
         USING TRKTOT,12
         ST    13,SAV2+4
         LA    13,SAV2
         L     2,R0TOT
         CVD   2,DBWD
         MVC   R0CNT(8),=X'4020202020202120'
         ED    R0CNT(8),DBWD+4
         L     2,TKTOT
         CVD   2,DBWD
         MVC   TRKCNT(8),=X'4020202020202120'
         ED    TRKCNT(8),DBWD+4
         WTO   MF=(E,WTP)
         L     13,SAV2+4
         RETURN (14,12),RC=0
DBWD     DS    D
SAV2     DS    18F
R0TOT    DC    F'0'
TKTOT    DC    F'0'
WTP      WTO   'XXXXXXXX TRACKS WRITTEN;YYYYYYYY R0 WRITTEN',          +
               ROUTCDE=11,MF=L
TRKCNT   EQU   WTP+4
R0CNT    EQU   WTP+28
         LTORG
*        END
         TITLE 'SUBROUTINE       -       TMPTST'
TMPTST   CSECT
         SAVE  (14,12)                 SAVE REGS
         BALR  12,0                    12 IS BASE
         USING *,12
         ST    13,SAV3+4
         LA    13,SAV3
         L     2,0(1)                  ADDR. OF DATA SET NAME IN 2
         SR    15,15                   INITIALIZE RETURN CODE
         CLC   0(3,2),=C'SYS'          SEE IF SYS
         BNE   GOBACK                  IF NOT, THEN GET OUT
         CLC   8(2,2),=C'.T'
         BNE   GOBACK
         CLI   16(2),C'.'
         BNE   GOBACK
         PACK  DTEMP(4),3(6,2)         PACK THE NUMBER
         UNPK  ZTEMP(6),DTEMP(4)       UNPACK THE SAME NUMBER
         CLC   3(5,2),ZTEMP            IF EQUAL ORIG ARE NUMBERS
         BNE   GOBACK
         PACK  DTEMP(4),10(7,2)
         UNPK  ZTEMP(7),DTEMP(4)
         CLC   10(6,2),ZTEMP
         BNE   GOBACK
* IF WE GET HERE, ASSUME A TEMPOARY SYSTEM DATA SET
         LA    15,4                    SET RETURN CODE TO 4
GOBACK   EQU   *
         L     13,4(13)                RESTORE REG. 13
         RETURN (14,12),RC=(15)
SAV3     DS    18F
DTEMP    DS    CL4
ZTEMP    DS    CL7
         LTORG
         END
